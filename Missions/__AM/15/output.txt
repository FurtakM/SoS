// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitGlobalVariables ;
  15: CALL 34975 0 0
// InitMacro ;
  19: CALL 35143 0 0
// InitNature ;
  23: CALL 34843 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAlliance ;
  40: CALL 11097 0 0
// PrepareRussian ;
  44: CALL 6981 0 0
// PrepareLegion ;
  48: CALL 4206 0 0
// PreparePowell ;
  52: CALL 2943 0 0
// PrepareAmerican ;
  56: CALL 1715 0 0
// Action ;
  60: CALL 14991 0 0
// MC_Start ( ) ;
  64: CALL 37308 0 0
// end ;
  68: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// missionStart := false ;
  80: LD_ADDR_EXP 13
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// missionTime := 0 0$00 ;
  88: LD_ADDR_EXP 14
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// missionStage := 1 ;
  96: LD_ADDR_EXP 15
 100: PUSH
 101: LD_INT 1
 103: ST_TO_ADDR
// activeAttacks := false ;
 104: LD_ADDR_EXP 16
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// powellAnger := 0 ;
 112: LD_ADDR_EXP 17
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// powellAngerQuery := false ;
 120: LD_ADDR_EXP 36
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// powellAllowRetreat := true ;
 128: LD_ADDR_EXP 19
 132: PUSH
 133: LD_INT 1
 135: ST_TO_ADDR
// powellCenterCameraMode := false ;
 136: LD_ADDR_EXP 20
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 144: LD_ADDR_EXP 18
 148: PUSH
 149: EMPTY
 150: PUSH
 151: EMPTY
 152: PUSH
 153: EMPTY
 154: LIST
 155: LIST
 156: ST_TO_ADDR
// russianDestroyed := false ;
 157: LD_ADDR_EXP 21
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// legionDestroyed := false ;
 165: LD_ADDR_EXP 22
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// allianceDestroyed := false ;
 173: LD_ADDR_EXP 23
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 181: LD_ADDR_EXP 2
 185: PUSH
 186: LD_STRING 14_KappaStatus_1
 188: PPUSH
 189: LD_INT 0
 191: PPUSH
 192: CALL_OW 30
 196: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 197: LD_ADDR_EXP 3
 201: PUSH
 202: LD_STRING 06_KurtStatus_1
 204: PPUSH
 205: LD_INT 0
 207: PPUSH
 208: CALL_OW 30
 212: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 213: LD_ADDR_EXP 4
 217: PUSH
 218: LD_STRING 14_JMMVeh_1
 220: PPUSH
 221: LD_INT 0
 223: PPUSH
 224: CALL_OW 30
 228: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 229: LD_ADDR_EXP 5
 233: PUSH
 234: LD_STRING 14_JMMGirlVeh_1
 236: PPUSH
 237: LD_INT 0
 239: PPUSH
 240: CALL_OW 30
 244: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 245: LD_ADDR_EXP 7
 249: PUSH
 250: LD_STRING 14_JMMGirl_1
 252: PPUSH
 253: LD_INT 0
 255: PPUSH
 256: CALL_OW 30
 260: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 261: LD_ADDR_EXP 6
 265: PUSH
 266: LD_STRING 14_JMMGirlStatus_1
 268: PPUSH
 269: LD_INT 0
 271: PPUSH
 272: CALL_OW 30
 276: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 277: LD_ADDR_EXP 8
 281: PUSH
 282: LD_STRING 10_KhatamStatus_1
 284: PPUSH
 285: LD_INT 0
 287: PPUSH
 288: CALL_OW 30
 292: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 293: LD_ADDR_EXP 9
 297: PUSH
 298: LD_STRING 13_BurlakStatus_1
 300: PPUSH
 301: LD_INT 0
 303: PPUSH
 304: CALL_OW 30
 308: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 309: LD_ADDR_EXP 10
 313: PUSH
 314: LD_STRING 13_StevensStatus_1
 316: PPUSH
 317: LD_INT 0
 319: PPUSH
 320: CALL_OW 30
 324: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 325: LD_ADDR_EXP 11
 329: PUSH
 330: LD_STRING 14_FastEnd_1
 332: PPUSH
 333: LD_INT 0
 335: PPUSH
 336: CALL_OW 30
 340: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 341: LD_ADDR_EXP 12
 345: PUSH
 346: LD_STRING 12_MainDepositFake_1
 348: PPUSH
 349: LD_INT 0
 351: PPUSH
 352: CALL_OW 30
 356: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 357: LD_ADDR_EXP 24
 361: PUSH
 362: LD_INT 1
 364: ST_TO_ADDR
// behemothUnderConstruct := false ;
 365: LD_ADDR_EXP 26
 369: PUSH
 370: LD_INT 0
 372: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 373: LD_ADDR_EXP 27
 377: PUSH
 378: LD_INT 0
 380: ST_TO_ADDR
// behemothDone := false ;
 381: LD_ADDR_EXP 28
 385: PUSH
 386: LD_INT 0
 388: ST_TO_ADDR
// allowBehemothConstruct := false ;
 389: LD_ADDR_EXP 25
 393: PUSH
 394: LD_INT 0
 396: ST_TO_ADDR
// seeBehemoth := false ;
 397: LD_ADDR_EXP 29
 401: PUSH
 402: LD_INT 0
 404: ST_TO_ADDR
// platonovHasBomb := false ;
 405: LD_ADDR_EXP 30
 409: PUSH
 410: LD_INT 0
 412: ST_TO_ADDR
// allianceActive := false ;
 413: LD_ADDR_EXP 31
 417: PUSH
 418: LD_INT 0
 420: ST_TO_ADDR
// rothCaptured := false ;
 421: LD_ADDR_EXP 33
 425: PUSH
 426: LD_INT 0
 428: ST_TO_ADDR
// lostCounter := 0 ;
 429: LD_ADDR_EXP 32
 433: PUSH
 434: LD_INT 0
 436: ST_TO_ADDR
// capturedUnit := [ ] ;
 437: LD_ADDR_EXP 34
 441: PUSH
 442: EMPTY
 443: ST_TO_ADDR
// trueAmericans := [ ] ;
 444: LD_ADDR_EXP 35
 448: PUSH
 449: EMPTY
 450: ST_TO_ADDR
// bombExploded := false ;
 451: LD_ADDR_EXP 37
 455: PUSH
 456: LD_INT 0
 458: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 459: LD_ADDR_EXP 38
 463: PUSH
 464: EMPTY
 465: ST_TO_ADDR
// end ;
 466: LD_VAR 0 1
 470: RET
// export function CustomInitMacro ( ) ; begin
 471: LD_INT 0
 473: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 474: LD_ADDR_EXP 140
 478: PUSH
 479: LD_INT 2
 481: PUSH
 482: LD_INT 3
 484: PUSH
 485: LD_INT 6
 487: PUSH
 488: LD_INT 10
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 497: LD_ADDR_EXP 141
 501: PUSH
 502: LD_INT 1
 504: PUSH
 505: LD_INT 4
 507: PUSH
 508: LD_INT 5
 510: PUSH
 511: LD_INT 9
 513: PUSH
 514: EMPTY
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 520: LD_INT 1
 522: PPUSH
 523: LD_INT 10
 525: PUSH
 526: LD_INT 11
 528: PUSH
 529: LD_INT 12
 531: PUSH
 532: EMPTY
 533: LIST
 534: LIST
 535: LIST
 536: PPUSH
 537: CALL 59910 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 541: LD_INT 1
 543: PPUSH
 544: LD_INT 17
 546: PUSH
 547: EMPTY
 548: LIST
 549: PPUSH
 550: CALL 60003 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 554: LD_INT 1
 556: PPUSH
 557: LD_INT 5
 559: PPUSH
 560: CALL 59353 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 24
 569: PUSH
 570: LD_INT 3
 572: PUSH
 573: LD_INT 3
 575: PUSH
 576: LD_INT 47
 578: PUSH
 579: EMPTY
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: PUSH
 585: LD_INT 24
 587: PUSH
 588: LD_INT 3
 590: PUSH
 591: LD_INT 3
 593: PUSH
 594: LD_INT 47
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: PUSH
 603: LD_INT 24
 605: PUSH
 606: LD_INT 3
 608: PUSH
 609: LD_INT 3
 611: PUSH
 612: LD_INT 47
 614: PUSH
 615: EMPTY
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: PUSH
 621: LD_INT 24
 623: PUSH
 624: LD_INT 3
 626: PUSH
 627: LD_INT 1
 629: PUSH
 630: LD_INT 47
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: LIST
 637: LIST
 638: PUSH
 639: LD_INT 24
 641: PUSH
 642: LD_INT 3
 644: PUSH
 645: LD_INT 1
 647: PUSH
 648: LD_INT 47
 650: PUSH
 651: EMPTY
 652: LIST
 653: LIST
 654: LIST
 655: LIST
 656: PUSH
 657: EMPTY
 658: LIST
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: PPUSH
 664: CALL 59168 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 668: LD_INT 2
 670: PPUSH
 671: LD_INT 10
 673: PUSH
 674: LD_INT 11
 676: PUSH
 677: LD_INT 12
 679: PUSH
 680: LD_INT 14
 682: PUSH
 683: EMPTY
 684: LIST
 685: LIST
 686: LIST
 687: LIST
 688: PPUSH
 689: CALL 59910 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 693: LD_INT 2
 695: PPUSH
 696: LD_INT 16
 698: PUSH
 699: EMPTY
 700: LIST
 701: PPUSH
 702: CALL 60003 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 706: LD_INT 2
 708: PPUSH
 709: LD_INT 21
 711: PUSH
 712: LD_INT 3
 714: PUSH
 715: LD_INT 3
 717: PUSH
 718: LD_INT 51
 720: PUSH
 721: EMPTY
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: PUSH
 727: LD_INT 22
 729: PUSH
 730: LD_INT 3
 732: PUSH
 733: LD_INT 3
 735: PUSH
 736: LD_INT 52
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: PUSH
 745: LD_INT 22
 747: PUSH
 748: LD_INT 3
 750: PUSH
 751: LD_INT 3
 753: PUSH
 754: LD_INT 52
 756: PUSH
 757: EMPTY
 758: LIST
 759: LIST
 760: LIST
 761: LIST
 762: PUSH
 763: LD_INT 24
 765: PUSH
 766: LD_INT 3
 768: PUSH
 769: LD_INT 3
 771: PUSH
 772: LD_INT 47
 774: PUSH
 775: EMPTY
 776: LIST
 777: LIST
 778: LIST
 779: LIST
 780: PUSH
 781: LD_INT 24
 783: PUSH
 784: LD_INT 3
 786: PUSH
 787: LD_INT 3
 789: PUSH
 790: LD_INT 47
 792: PUSH
 793: EMPTY
 794: LIST
 795: LIST
 796: LIST
 797: LIST
 798: PUSH
 799: LD_INT 24
 801: PUSH
 802: LD_INT 3
 804: PUSH
 805: LD_INT 3
 807: PUSH
 808: LD_INT 47
 810: PUSH
 811: EMPTY
 812: LIST
 813: LIST
 814: LIST
 815: LIST
 816: PUSH
 817: LD_INT 24
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: LD_INT 3
 825: PUSH
 826: LD_INT 47
 828: PUSH
 829: EMPTY
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: PUSH
 835: LD_INT 24
 837: PUSH
 838: LD_INT 3
 840: PUSH
 841: LD_INT 3
 843: PUSH
 844: LD_INT 47
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: LIST
 851: LIST
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: PPUSH
 863: CALL 59168 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 867: LD_INT 2
 869: PPUSH
 870: LD_INT 5
 872: PPUSH
 873: CALL 59353 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 877: LD_INT 2
 879: PPUSH
 880: LD_INT 0
 882: PPUSH
 883: CALL 59783 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 887: LD_INT 3
 889: PPUSH
 890: LD_INT 10
 892: PUSH
 893: LD_INT 12
 895: PUSH
 896: LD_INT 15
 898: PUSH
 899: EMPTY
 900: LIST
 901: LIST
 902: LIST
 903: PUSH
 904: LD_OWVAR 67
 908: ARRAY
 909: PPUSH
 910: LD_INT 27
 912: PPUSH
 913: CALL 58850 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 917: LD_INT 3
 919: PPUSH
 920: LD_INT 10
 922: PUSH
 923: LD_INT 11
 925: PUSH
 926: LD_INT 13
 928: PUSH
 929: LD_INT 15
 931: PUSH
 932: EMPTY
 933: LIST
 934: LIST
 935: LIST
 936: LIST
 937: PPUSH
 938: CALL 59910 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 942: LD_INT 3
 944: PPUSH
 945: LD_INT 15
 947: PUSH
 948: EMPTY
 949: LIST
 950: PPUSH
 951: CALL 60003 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 955: LD_ADDR_EXP 145
 959: PUSH
 960: LD_EXP 145
 964: PPUSH
 965: LD_INT 3
 967: PPUSH
 968: LD_INT 22
 970: PUSH
 971: LD_INT 8
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: PUSH
 978: LD_INT 25
 980: PUSH
 981: LD_INT 15
 983: PUSH
 984: EMPTY
 985: LIST
 986: LIST
 987: PUSH
 988: EMPTY
 989: LIST
 990: LIST
 991: PPUSH
 992: CALL_OW 69
 996: PPUSH
 997: CALL_OW 1
1001: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1002: LD_INT 3
1004: PPUSH
1005: LD_INT 13
1007: PUSH
1008: LD_INT 2
1010: PUSH
1011: LD_INT 1
1013: PUSH
1014: LD_INT 31
1016: PUSH
1017: EMPTY
1018: LIST
1019: LIST
1020: LIST
1021: LIST
1022: PUSH
1023: LD_INT 13
1025: PUSH
1026: LD_INT 2
1028: PUSH
1029: LD_INT 1
1031: PUSH
1032: LD_INT 31
1034: PUSH
1035: EMPTY
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: PUSH
1041: LD_INT 13
1043: PUSH
1044: LD_INT 3
1046: PUSH
1047: LD_INT 2
1049: PUSH
1050: LD_INT 32
1052: PUSH
1053: EMPTY
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: PUSH
1059: LD_INT 14
1061: PUSH
1062: LD_INT 1
1064: PUSH
1065: LD_INT 2
1067: PUSH
1068: LD_EXP 101
1072: PUSH
1073: EMPTY
1074: LIST
1075: LIST
1076: LIST
1077: LIST
1078: PUSH
1079: EMPTY
1080: LIST
1081: LIST
1082: LIST
1083: LIST
1084: PPUSH
1085: CALL 59168 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1089: LD_INT 4
1091: PPUSH
1092: LD_INT 10
1094: PUSH
1095: LD_INT 12
1097: PUSH
1098: EMPTY
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 59910 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 9
1111: PUSH
1112: EMPTY
1113: LIST
1114: PPUSH
1115: CALL 60003 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1119: LD_INT 4
1121: PPUSH
1122: LD_INT 26
1124: PUSH
1125: LD_INT 74
1127: PUSH
1128: LD_INT 107
1130: PUSH
1131: LD_INT 0
1133: PUSH
1134: EMPTY
1135: LIST
1136: LIST
1137: LIST
1138: LIST
1139: PUSH
1140: LD_INT 32
1142: PUSH
1143: LD_INT 77
1145: PUSH
1146: LD_INT 101
1148: PUSH
1149: LD_INT 4
1151: PUSH
1152: EMPTY
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PUSH
1158: LD_INT 32
1160: PUSH
1161: LD_INT 69
1163: PUSH
1164: LD_INT 86
1166: PUSH
1167: LD_INT 4
1169: PUSH
1170: EMPTY
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: PUSH
1176: LD_INT 27
1178: PUSH
1179: LD_INT 77
1181: PUSH
1182: LD_INT 110
1184: PUSH
1185: LD_INT 3
1187: PUSH
1188: EMPTY
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: PUSH
1194: LD_INT 27
1196: PUSH
1197: LD_INT 42
1199: PUSH
1200: LD_INT 79
1202: PUSH
1203: LD_INT 5
1205: PUSH
1206: EMPTY
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: PUSH
1212: LD_INT 29
1214: PUSH
1215: LD_INT 86
1217: PUSH
1218: LD_INT 105
1220: PUSH
1221: LD_INT 2
1223: PUSH
1224: EMPTY
1225: LIST
1226: LIST
1227: LIST
1228: LIST
1229: PUSH
1230: LD_INT 30
1232: PUSH
1233: LD_INT 40
1235: PUSH
1236: LD_INT 75
1238: PUSH
1239: LD_INT 1
1241: PUSH
1242: EMPTY
1243: LIST
1244: LIST
1245: LIST
1246: LIST
1247: PUSH
1248: LD_INT 32
1250: PUSH
1251: LD_INT 80
1253: PUSH
1254: LD_INT 106
1256: PUSH
1257: LD_INT 4
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: PUSH
1266: LD_INT 32
1268: PUSH
1269: LD_INT 75
1271: PUSH
1272: LD_INT 114
1274: PUSH
1275: LD_INT 5
1277: PUSH
1278: EMPTY
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: PUSH
1284: LD_INT 32
1286: PUSH
1287: LD_INT 82
1289: PUSH
1290: LD_INT 110
1292: PUSH
1293: LD_INT 5
1295: PUSH
1296: EMPTY
1297: LIST
1298: LIST
1299: LIST
1300: LIST
1301: PUSH
1302: LD_INT 32
1304: PUSH
1305: LD_INT 62
1307: PUSH
1308: LD_INT 78
1310: PUSH
1311: LD_INT 4
1313: PUSH
1314: EMPTY
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: PUSH
1320: LD_INT 4
1322: PUSH
1323: LD_INT 39
1325: PUSH
1326: LD_INT 61
1328: PUSH
1329: LD_INT 3
1331: PUSH
1332: EMPTY
1333: LIST
1334: LIST
1335: LIST
1336: LIST
1337: PUSH
1338: EMPTY
1339: LIST
1340: LIST
1341: LIST
1342: LIST
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: PPUSH
1352: CALL 59060 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1356: LD_INT 4
1358: PPUSH
1359: LD_INT 5
1361: PUSH
1362: LD_INT 6
1364: PUSH
1365: LD_INT 7
1367: PUSH
1368: LD_INT 9
1370: PUSH
1371: EMPTY
1372: LIST
1373: LIST
1374: LIST
1375: LIST
1376: PPUSH
1377: CALL 60321 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1381: LD_INT 4
1383: PPUSH
1384: LD_INT 40
1386: PUSH
1387: LD_INT 75
1389: PUSH
1390: LD_INT 1
1392: PUSH
1393: EMPTY
1394: LIST
1395: LIST
1396: LIST
1397: PUSH
1398: LD_INT 86
1400: PUSH
1401: LD_INT 105
1403: PUSH
1404: LD_INT 0
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: PUSH
1412: EMPTY
1413: LIST
1414: LIST
1415: PPUSH
1416: CALL 59492 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1420: LD_INT 4
1422: PPUSH
1423: LD_INT 2
1425: PPUSH
1426: CALL 59783 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1430: LD_INT 4
1432: PPUSH
1433: LD_INT 0
1435: PPUSH
1436: CALL 59783 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1440: LD_INT 4
1442: PPUSH
1443: LD_INT 54
1445: PPUSH
1446: LD_INT 85
1448: PPUSH
1449: LD_INT 2
1451: PPUSH
1452: LD_INT 19
1454: PUSH
1455: LD_INT 16
1457: PUSH
1458: LD_INT 17
1460: PUSH
1461: LD_INT 18
1463: PUSH
1464: EMPTY
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: PPUSH
1470: CALL 60115 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1474: LD_INT 4
1476: PPUSH
1477: LD_INT 3
1479: PUSH
1480: LD_INT 1
1482: PUSH
1483: LD_INT 1
1485: PUSH
1486: LD_INT 5
1488: PUSH
1489: EMPTY
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: PUSH
1495: LD_INT 4
1497: PUSH
1498: LD_INT 1
1500: PUSH
1501: LD_INT 1
1503: PUSH
1504: LD_INT 6
1506: PUSH
1507: EMPTY
1508: LIST
1509: LIST
1510: LIST
1511: LIST
1512: PUSH
1513: LD_INT 4
1515: PUSH
1516: LD_INT 1
1518: PUSH
1519: LD_INT 1
1521: PUSH
1522: LD_INT 7
1524: PUSH
1525: EMPTY
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: PUSH
1531: LD_INT 4
1533: PUSH
1534: LD_INT 1
1536: PUSH
1537: LD_INT 1
1539: PUSH
1540: LD_INT 6
1542: PUSH
1543: EMPTY
1544: LIST
1545: LIST
1546: LIST
1547: LIST
1548: PUSH
1549: EMPTY
1550: LIST
1551: LIST
1552: LIST
1553: LIST
1554: PPUSH
1555: CALL 59168 0 2
// MC_SetTame ( 4 , powellApe ) ;
1559: LD_INT 4
1561: PPUSH
1562: LD_INT 13
1564: PPUSH
1565: CALL 59734 0 2
// end ;
1569: LD_VAR 0 1
1573: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1574: LD_EXP 36
1578: PUSH
1579: LD_EXP 17
1583: PUSH
1584: LD_INT 2
1586: GREATEREQUAL
1587: AND
1588: IFFALSE 1600
1590: GO 1592
1592: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1593: LD_STRING ACH_POWELL
1595: PPUSH
1596: CALL_OW 543
1600: END
// every 0 0$1 trigger debug do var i , tmp ;
1601: LD_EXP 1
1605: IFFALSE 1712
1607: GO 1609
1609: DISABLE
1610: LD_INT 0
1612: PPUSH
1613: PPUSH
// begin enable ;
1614: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1615: LD_ADDR_VAR 0 2
1619: PUSH
1620: LD_INT 22
1622: PUSH
1623: LD_INT 1
1625: PUSH
1626: EMPTY
1627: LIST
1628: LIST
1629: PUSH
1630: LD_INT 3
1632: PUSH
1633: LD_INT 21
1635: PUSH
1636: LD_INT 3
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: PUSH
1643: EMPTY
1644: LIST
1645: LIST
1646: PUSH
1647: LD_INT 3
1649: PUSH
1650: LD_INT 24
1652: PUSH
1653: LD_INT 999
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: PUSH
1660: EMPTY
1661: LIST
1662: LIST
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PPUSH
1669: CALL_OW 69
1673: ST_TO_ADDR
// if not tmp then
1674: LD_VAR 0 2
1678: NOT
1679: IFFALSE 1683
// exit ;
1681: GO 1712
// for i in tmp do
1683: LD_ADDR_VAR 0 1
1687: PUSH
1688: LD_VAR 0 2
1692: PUSH
1693: FOR_IN
1694: IFFALSE 1710
// SetLives ( i , 1000 ) ;
1696: LD_VAR 0 1
1700: PPUSH
1701: LD_INT 1000
1703: PPUSH
1704: CALL_OW 234
1708: GO 1693
1710: POP
1711: POP
// end ; end_of_file
1712: PPOPN 2
1714: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1715: LD_INT 0
1717: PPUSH
// uc_side := 1 ;
1718: LD_ADDR_OWVAR 20
1722: PUSH
1723: LD_INT 1
1725: ST_TO_ADDR
// uc_nation := 1 ;
1726: LD_ADDR_OWVAR 21
1730: PUSH
1731: LD_INT 1
1733: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1734: LD_ADDR_EXP 39
1738: PUSH
1739: LD_STRING JMM
1741: PPUSH
1742: LD_EXP 1
1746: NOT
1747: PPUSH
1748: LD_STRING 14_
1750: PPUSH
1751: CALL 65622 0 3
1755: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1756: LD_EXP 4
1760: NOT
1761: PUSH
1762: LD_EXP 4
1766: PUSH
1767: LD_INT 1
1769: ARRAY
1770: PUSH
1771: LD_INT 1
1773: ARRAY
1774: NOT
1775: OR
1776: IFFALSE 1799
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1778: LD_INT 5
1780: PPUSH
1781: LD_INT 3
1783: PPUSH
1784: LD_INT 1
1786: PPUSH
1787: LD_INT 9
1789: PPUSH
1790: LD_INT 100
1792: PPUSH
1793: CALL 70486 0 5
1797: GO 1858
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1799: LD_EXP 4
1803: PUSH
1804: LD_INT 1
1806: ARRAY
1807: PUSH
1808: LD_INT 1
1810: ARRAY
1811: PPUSH
1812: LD_EXP 4
1816: PUSH
1817: LD_INT 2
1819: ARRAY
1820: PUSH
1821: LD_INT 1
1823: ARRAY
1824: PPUSH
1825: LD_EXP 4
1829: PUSH
1830: LD_INT 3
1832: ARRAY
1833: PUSH
1834: LD_INT 1
1836: ARRAY
1837: PPUSH
1838: LD_EXP 4
1842: PUSH
1843: LD_INT 4
1845: ARRAY
1846: PUSH
1847: LD_INT 1
1849: ARRAY
1850: PPUSH
1851: LD_INT 30
1853: PPUSH
1854: CALL 70486 0 5
// JMMNewVeh := CreateVehicle ;
1858: LD_ADDR_EXP 56
1862: PUSH
1863: CALL_OW 45
1867: ST_TO_ADDR
// if not JMMNewVeh then
1868: LD_EXP 56
1872: NOT
1873: IFFALSE 1904
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1875: LD_INT 5
1877: PPUSH
1878: LD_INT 3
1880: PPUSH
1881: LD_INT 1
1883: PPUSH
1884: LD_INT 9
1886: PPUSH
1887: LD_INT 100
1889: PPUSH
1890: CALL 70486 0 5
// JMMNewVeh := CreateVehicle ;
1894: LD_ADDR_EXP 56
1898: PUSH
1899: CALL_OW 45
1903: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1904: LD_EXP 56
1908: PPUSH
1909: LD_INT 4
1911: PPUSH
1912: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1916: LD_EXP 56
1920: PPUSH
1921: LD_INT 79
1923: PPUSH
1924: LD_INT 91
1926: PPUSH
1927: LD_INT 0
1929: PPUSH
1930: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1934: LD_EXP 39
1938: PPUSH
1939: LD_EXP 56
1943: PPUSH
1944: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1948: LD_EXP 6
1952: PUSH
1953: LD_EXP 2
1957: NOT
1958: AND
1959: IFFALSE 2217
// begin if not JMMGirlVeh then
1961: LD_EXP 5
1965: NOT
1966: IFFALSE 1989
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1968: LD_INT 3
1970: PPUSH
1971: LD_INT 3
1973: PPUSH
1974: LD_INT 1
1976: PPUSH
1977: LD_INT 9
1979: PPUSH
1980: LD_INT 100
1982: PPUSH
1983: CALL 70486 0 5
1987: GO 2048
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1989: LD_EXP 5
1993: PUSH
1994: LD_INT 1
1996: ARRAY
1997: PUSH
1998: LD_INT 1
2000: ARRAY
2001: PPUSH
2002: LD_EXP 5
2006: PUSH
2007: LD_INT 2
2009: ARRAY
2010: PUSH
2011: LD_INT 1
2013: ARRAY
2014: PPUSH
2015: LD_EXP 5
2019: PUSH
2020: LD_INT 3
2022: ARRAY
2023: PUSH
2024: LD_INT 1
2026: ARRAY
2027: PPUSH
2028: LD_EXP 5
2032: PUSH
2033: LD_INT 4
2035: ARRAY
2036: PUSH
2037: LD_INT 1
2039: ARRAY
2040: PPUSH
2041: LD_INT 30
2043: PPUSH
2044: CALL 70486 0 5
// GirlNewVeh := CreateVehicle ;
2048: LD_ADDR_EXP 57
2052: PUSH
2053: CALL_OW 45
2057: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2058: LD_EXP 57
2062: PPUSH
2063: LD_INT 4
2065: PPUSH
2066: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2070: LD_EXP 57
2074: PPUSH
2075: LD_INT 82
2077: PPUSH
2078: LD_INT 96
2080: PPUSH
2081: LD_INT 0
2083: PPUSH
2084: CALL_OW 48
// if JMMGirl = 1 then
2088: LD_EXP 7
2092: PUSH
2093: LD_INT 1
2095: EQUAL
2096: IFFALSE 2131
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2098: LD_ADDR_EXP 40
2102: PUSH
2103: LD_STRING Joan
2105: PPUSH
2106: LD_INT 1
2108: PPUSH
2109: LD_STRING 14_
2111: PPUSH
2112: CALL 65622 0 3
2116: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2117: LD_EXP 40
2121: PPUSH
2122: LD_EXP 57
2126: PPUSH
2127: CALL_OW 52
// end ; if JMMGirl = 2 then
2131: LD_EXP 7
2135: PUSH
2136: LD_INT 2
2138: EQUAL
2139: IFFALSE 2174
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2141: LD_ADDR_EXP 42
2145: PUSH
2146: LD_STRING Lisa
2148: PPUSH
2149: LD_INT 1
2151: PPUSH
2152: LD_STRING 14_
2154: PPUSH
2155: CALL 65622 0 3
2159: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2160: LD_EXP 42
2164: PPUSH
2165: LD_EXP 57
2169: PPUSH
2170: CALL_OW 52
// end ; if JMMGirl = 3 then
2174: LD_EXP 7
2178: PUSH
2179: LD_INT 3
2181: EQUAL
2182: IFFALSE 2217
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2184: LD_ADDR_EXP 54
2188: PUSH
2189: LD_STRING Connie
2191: PPUSH
2192: LD_INT 1
2194: PPUSH
2195: LD_STRING 14_
2197: PPUSH
2198: CALL 65622 0 3
2202: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2203: LD_EXP 54
2207: PPUSH
2208: LD_EXP 57
2212: PPUSH
2213: CALL_OW 52
// end ; end ; end ;
2217: LD_VAR 0 1
2221: RET
// export function PrepareStevensSquad ; var tmp ; begin
2222: LD_INT 0
2224: PPUSH
2225: PPUSH
// uc_side := 1 ;
2226: LD_ADDR_OWVAR 20
2230: PUSH
2231: LD_INT 1
2233: ST_TO_ADDR
// uc_nation := 1 ;
2234: LD_ADDR_OWVAR 21
2238: PUSH
2239: LD_INT 1
2241: ST_TO_ADDR
// tmp := [ ] ;
2242: LD_ADDR_VAR 0 2
2246: PUSH
2247: EMPTY
2248: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2249: LD_ADDR_EXP 41
2253: PUSH
2254: LD_STRING Stevens
2256: PPUSH
2257: LD_EXP 1
2261: NOT
2262: PPUSH
2263: LD_STRING 13f_
2265: PPUSH
2266: CALL 65622 0 3
2270: ST_TO_ADDR
// if not Stevens then
2271: LD_EXP 41
2275: NOT
2276: IFFALSE 2332
// begin hc_name = Baker Smith ;
2278: LD_ADDR_OWVAR 26
2282: PUSH
2283: LD_STRING Baker Smith
2285: ST_TO_ADDR
// hc_gallery =  ;
2286: LD_ADDR_OWVAR 33
2290: PUSH
2291: LD_STRING 
2293: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2294: LD_INT 1
2296: PPUSH
2297: LD_INT 10
2299: PPUSH
2300: CALL_OW 384
// Baker = CreateHuman ;
2304: LD_ADDR_EXP 55
2308: PUSH
2309: CALL_OW 44
2313: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2314: LD_ADDR_VAR 0 2
2318: PUSH
2319: LD_VAR 0 2
2323: PUSH
2324: LD_EXP 55
2328: ADD
2329: ST_TO_ADDR
// end else
2330: GO 2348
// tmp := tmp ^ Stevens ;
2332: LD_ADDR_VAR 0 2
2336: PUSH
2337: LD_VAR 0 2
2341: PUSH
2342: LD_EXP 41
2346: ADD
2347: ST_TO_ADDR
// if not Lisa then
2348: LD_EXP 42
2352: NOT
2353: IFFALSE 2399
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2355: LD_ADDR_EXP 42
2359: PUSH
2360: LD_STRING Lisa
2362: PPUSH
2363: LD_EXP 1
2367: NOT
2368: PPUSH
2369: LD_STRING 13f_
2371: PPUSH
2372: CALL 65622 0 3
2376: ST_TO_ADDR
// if Lisa then
2377: LD_EXP 42
2381: IFFALSE 2399
// tmp := tmp ^ Lisa ;
2383: LD_ADDR_VAR 0 2
2387: PUSH
2388: LD_VAR 0 2
2392: PUSH
2393: LD_EXP 42
2397: ADD
2398: ST_TO_ADDR
// end ; if not Donaldson then
2399: LD_EXP 43
2403: NOT
2404: IFFALSE 2450
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2406: LD_ADDR_EXP 43
2410: PUSH
2411: LD_STRING Donaldson
2413: PPUSH
2414: LD_EXP 1
2418: NOT
2419: PPUSH
2420: LD_STRING 13f_
2422: PPUSH
2423: CALL 65622 0 3
2427: ST_TO_ADDR
// if Donaldson then
2428: LD_EXP 43
2432: IFFALSE 2450
// tmp := tmp ^ Donaldson ;
2434: LD_ADDR_VAR 0 2
2438: PUSH
2439: LD_VAR 0 2
2443: PUSH
2444: LD_EXP 43
2448: ADD
2449: ST_TO_ADDR
// end ; if not Bobby then
2450: LD_EXP 44
2454: NOT
2455: IFFALSE 2501
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2457: LD_ADDR_EXP 44
2461: PUSH
2462: LD_STRING Bobby
2464: PPUSH
2465: LD_EXP 1
2469: NOT
2470: PPUSH
2471: LD_STRING 13f_
2473: PPUSH
2474: CALL 65622 0 3
2478: ST_TO_ADDR
// if Bobby then
2479: LD_EXP 44
2483: IFFALSE 2501
// tmp := tmp ^ Bobby ;
2485: LD_ADDR_VAR 0 2
2489: PUSH
2490: LD_VAR 0 2
2494: PUSH
2495: LD_EXP 44
2499: ADD
2500: ST_TO_ADDR
// end ; if not Cyrus then
2501: LD_EXP 45
2505: NOT
2506: IFFALSE 2552
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2508: LD_ADDR_EXP 45
2512: PUSH
2513: LD_STRING Cyrus
2515: PPUSH
2516: LD_EXP 1
2520: NOT
2521: PPUSH
2522: LD_STRING 13f_
2524: PPUSH
2525: CALL 65622 0 3
2529: ST_TO_ADDR
// if Cyrus then
2530: LD_EXP 45
2534: IFFALSE 2552
// tmp := tmp ^ Cyrus ;
2536: LD_ADDR_VAR 0 2
2540: PUSH
2541: LD_VAR 0 2
2545: PUSH
2546: LD_EXP 45
2550: ADD
2551: ST_TO_ADDR
// end ; if not Brown then
2552: LD_EXP 47
2556: NOT
2557: IFFALSE 2603
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2559: LD_ADDR_EXP 47
2563: PUSH
2564: LD_STRING Brown
2566: PPUSH
2567: LD_EXP 1
2571: NOT
2572: PPUSH
2573: LD_STRING 13f_
2575: PPUSH
2576: CALL 65622 0 3
2580: ST_TO_ADDR
// if Brown then
2581: LD_EXP 47
2585: IFFALSE 2603
// tmp := tmp ^ Brown ;
2587: LD_ADDR_VAR 0 2
2591: PUSH
2592: LD_VAR 0 2
2596: PUSH
2597: LD_EXP 47
2601: ADD
2602: ST_TO_ADDR
// end ; if not Gladstone then
2603: LD_EXP 48
2607: NOT
2608: IFFALSE 2654
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2610: LD_ADDR_EXP 48
2614: PUSH
2615: LD_STRING Gladstone
2617: PPUSH
2618: LD_EXP 1
2622: NOT
2623: PPUSH
2624: LD_STRING 13f_
2626: PPUSH
2627: CALL 65622 0 3
2631: ST_TO_ADDR
// if Gladstone then
2632: LD_EXP 48
2636: IFFALSE 2654
// tmp := tmp ^ Gladstone ;
2638: LD_ADDR_VAR 0 2
2642: PUSH
2643: LD_VAR 0 2
2647: PUSH
2648: LD_EXP 48
2652: ADD
2653: ST_TO_ADDR
// end ; if not Houten then
2654: LD_EXP 49
2658: NOT
2659: IFFALSE 2705
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2661: LD_ADDR_EXP 49
2665: PUSH
2666: LD_STRING Houten
2668: PPUSH
2669: LD_EXP 1
2673: NOT
2674: PPUSH
2675: LD_STRING 13f_
2677: PPUSH
2678: CALL 65622 0 3
2682: ST_TO_ADDR
// if Houten then
2683: LD_EXP 49
2687: IFFALSE 2705
// tmp := tmp ^ Houten ;
2689: LD_ADDR_VAR 0 2
2693: PUSH
2694: LD_VAR 0 2
2698: PUSH
2699: LD_EXP 49
2703: ADD
2704: ST_TO_ADDR
// end ; if not Cornel then
2705: LD_EXP 50
2709: NOT
2710: IFFALSE 2756
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2712: LD_ADDR_EXP 50
2716: PUSH
2717: LD_STRING Cornell
2719: PPUSH
2720: LD_EXP 1
2724: NOT
2725: PPUSH
2726: LD_STRING 13f_
2728: PPUSH
2729: CALL 65622 0 3
2733: ST_TO_ADDR
// if Cornel then
2734: LD_EXP 50
2738: IFFALSE 2756
// tmp := tmp ^ Cornel ;
2740: LD_ADDR_VAR 0 2
2744: PUSH
2745: LD_VAR 0 2
2749: PUSH
2750: LD_EXP 50
2754: ADD
2755: ST_TO_ADDR
// end ; if not Gary then
2756: LD_EXP 51
2760: NOT
2761: IFFALSE 2807
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2763: LD_ADDR_EXP 51
2767: PUSH
2768: LD_STRING Gary
2770: PPUSH
2771: LD_EXP 1
2775: NOT
2776: PPUSH
2777: LD_STRING 13f_
2779: PPUSH
2780: CALL 65622 0 3
2784: ST_TO_ADDR
// if Gary then
2785: LD_EXP 51
2789: IFFALSE 2807
// tmp := tmp ^ Gary ;
2791: LD_ADDR_VAR 0 2
2795: PUSH
2796: LD_VAR 0 2
2800: PUSH
2801: LD_EXP 51
2805: ADD
2806: ST_TO_ADDR
// end ; if not Frank then
2807: LD_EXP 52
2811: NOT
2812: IFFALSE 2858
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2814: LD_ADDR_EXP 52
2818: PUSH
2819: LD_STRING Frank
2821: PPUSH
2822: LD_EXP 1
2826: NOT
2827: PPUSH
2828: LD_STRING 13f_
2830: PPUSH
2831: CALL 65622 0 3
2835: ST_TO_ADDR
// if Frank then
2836: LD_EXP 52
2840: IFFALSE 2858
// tmp := tmp ^ Frank ;
2842: LD_ADDR_VAR 0 2
2846: PUSH
2847: LD_VAR 0 2
2851: PUSH
2852: LD_EXP 52
2856: ADD
2857: ST_TO_ADDR
// end ; if not Kikuchi then
2858: LD_EXP 53
2862: NOT
2863: IFFALSE 2909
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2865: LD_ADDR_EXP 53
2869: PUSH
2870: LD_STRING Kikuchi
2872: PPUSH
2873: LD_EXP 1
2877: NOT
2878: PPUSH
2879: LD_STRING 13f_
2881: PPUSH
2882: CALL 65622 0 3
2886: ST_TO_ADDR
// if Kikuchi then
2887: LD_EXP 53
2891: IFFALSE 2909
// tmp := tmp ^ Kikuchi ;
2893: LD_ADDR_VAR 0 2
2897: PUSH
2898: LD_VAR 0 2
2902: PUSH
2903: LD_EXP 53
2907: ADD
2908: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2909: LD_ADDR_VAR 0 2
2913: PUSH
2914: LD_VAR 0 2
2918: PUSH
2919: LD_STRING 13_other_survivors
2921: PPUSH
2922: CALL_OW 31
2926: UNION
2927: ST_TO_ADDR
// result := tmp ;
2928: LD_ADDR_VAR 0 1
2932: PUSH
2933: LD_VAR 0 2
2937: ST_TO_ADDR
// end ; end_of_file
2938: LD_VAR 0 1
2942: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2943: LD_INT 0
2945: PPUSH
2946: PPUSH
2947: PPUSH
2948: PPUSH
2949: PPUSH
2950: PPUSH
2951: PPUSH
2952: PPUSH
2953: PPUSH
2954: PPUSH
// uc_side := 4 ;
2955: LD_ADDR_OWVAR 20
2959: PUSH
2960: LD_INT 4
2962: ST_TO_ADDR
// uc_nation := 1 ;
2963: LD_ADDR_OWVAR 21
2967: PUSH
2968: LD_INT 1
2970: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 ] [ Difficulty ] ) ;
2971: LD_INT 387
2973: PPUSH
2974: CALL_OW 274
2978: PPUSH
2979: LD_INT 1
2981: PPUSH
2982: LD_INT 3500
2984: PUSH
2985: LD_INT 3000
2987: PUSH
2988: LD_INT 2500
2990: PUSH
2991: EMPTY
2992: LIST
2993: LIST
2994: LIST
2995: PUSH
2996: LD_OWVAR 67
3000: ARRAY
3001: PPUSH
3002: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3006: LD_INT 387
3008: PPUSH
3009: CALL_OW 274
3013: PPUSH
3014: LD_INT 2
3016: PPUSH
3017: LD_INT 400
3019: PPUSH
3020: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3024: LD_INT 387
3026: PPUSH
3027: CALL_OW 274
3031: PPUSH
3032: LD_INT 3
3034: PPUSH
3035: LD_INT 10
3037: PPUSH
3038: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3042: LD_ADDR_EXP 58
3046: PUSH
3047: LD_STRING Powell
3049: PPUSH
3050: CALL_OW 25
3054: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3055: LD_EXP 58
3059: PPUSH
3060: LD_INT 57
3062: PPUSH
3063: LD_INT 94
3065: PPUSH
3066: LD_INT 0
3068: PPUSH
3069: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3073: LD_EXP 58
3077: PPUSH
3078: LD_INT 58
3080: PPUSH
3081: LD_INT 94
3083: PPUSH
3084: CALL_OW 118
// vip := [ ] ;
3088: LD_ADDR_EXP 59
3092: PUSH
3093: EMPTY
3094: ST_TO_ADDR
// tmp := [ ] ;
3095: LD_ADDR_VAR 0 6
3099: PUSH
3100: EMPTY
3101: ST_TO_ADDR
// if JMMGirl <> 2 then
3102: LD_EXP 7
3106: PUSH
3107: LD_INT 2
3109: NONEQUAL
3110: IFFALSE 3134
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3112: LD_ADDR_EXP 42
3116: PUSH
3117: LD_STRING Lisa
3119: PPUSH
3120: LD_EXP 1
3124: NOT
3125: PPUSH
3126: LD_STRING 13s_
3128: PPUSH
3129: CALL 65622 0 3
3133: ST_TO_ADDR
// if Lisa then
3134: LD_EXP 42
3138: IFFALSE 3156
// tmp := tmp ^ Lisa ;
3140: LD_ADDR_VAR 0 6
3144: PUSH
3145: LD_VAR 0 6
3149: PUSH
3150: LD_EXP 42
3154: ADD
3155: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3156: LD_ADDR_EXP 43
3160: PUSH
3161: LD_STRING Donaldson
3163: PPUSH
3164: LD_EXP 1
3168: NOT
3169: PPUSH
3170: LD_STRING 13s_
3172: PPUSH
3173: CALL 65622 0 3
3177: ST_TO_ADDR
// if Donaldson then
3178: LD_EXP 43
3182: IFFALSE 3200
// tmp := tmp ^ Donaldson ;
3184: LD_ADDR_VAR 0 6
3188: PUSH
3189: LD_VAR 0 6
3193: PUSH
3194: LD_EXP 43
3198: ADD
3199: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3200: LD_ADDR_EXP 44
3204: PUSH
3205: LD_STRING Bobby
3207: PPUSH
3208: LD_EXP 1
3212: NOT
3213: PPUSH
3214: LD_STRING 13s_
3216: PPUSH
3217: CALL 65622 0 3
3221: ST_TO_ADDR
// if Bobby then
3222: LD_EXP 44
3226: IFFALSE 3244
// tmp := tmp ^ Bobby ;
3228: LD_ADDR_VAR 0 6
3232: PUSH
3233: LD_VAR 0 6
3237: PUSH
3238: LD_EXP 44
3242: ADD
3243: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3244: LD_ADDR_EXP 45
3248: PUSH
3249: LD_STRING Cyrus
3251: PPUSH
3252: LD_EXP 1
3256: NOT
3257: PPUSH
3258: LD_STRING 13s_
3260: PPUSH
3261: CALL 65622 0 3
3265: ST_TO_ADDR
// if Cyrus then
3266: LD_EXP 45
3270: IFFALSE 3288
// tmp := tmp ^ Cyrus ;
3272: LD_ADDR_VAR 0 6
3276: PUSH
3277: LD_VAR 0 6
3281: PUSH
3282: LD_EXP 45
3286: ADD
3287: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3288: LD_ADDR_EXP 46
3292: PUSH
3293: LD_STRING Denis
3295: PPUSH
3296: LD_EXP 1
3300: NOT
3301: PPUSH
3302: LD_STRING 13s_
3304: PPUSH
3305: CALL 65622 0 3
3309: ST_TO_ADDR
// if not Denis then
3310: LD_EXP 46
3314: NOT
3315: IFFALSE 3339
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3317: LD_ADDR_EXP 46
3321: PUSH
3322: LD_STRING Denis
3324: PPUSH
3325: LD_EXP 1
3329: NOT
3330: PPUSH
3331: LD_STRING 13f_
3333: PPUSH
3334: CALL 65622 0 3
3338: ST_TO_ADDR
// if Denis then
3339: LD_EXP 46
3343: IFFALSE 3361
// tmp := tmp ^ Denis ;
3345: LD_ADDR_VAR 0 6
3349: PUSH
3350: LD_VAR 0 6
3354: PUSH
3355: LD_EXP 46
3359: ADD
3360: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3361: LD_ADDR_EXP 47
3365: PUSH
3366: LD_STRING Brown
3368: PPUSH
3369: LD_EXP 1
3373: NOT
3374: PPUSH
3375: LD_STRING 13s_
3377: PPUSH
3378: CALL 65622 0 3
3382: ST_TO_ADDR
// if Brown then
3383: LD_EXP 47
3387: IFFALSE 3405
// tmp := tmp ^ Brown ;
3389: LD_ADDR_VAR 0 6
3393: PUSH
3394: LD_VAR 0 6
3398: PUSH
3399: LD_EXP 47
3403: ADD
3404: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3405: LD_ADDR_EXP 48
3409: PUSH
3410: LD_STRING Gladstone
3412: PPUSH
3413: LD_EXP 1
3417: NOT
3418: PPUSH
3419: LD_STRING 13s_
3421: PPUSH
3422: CALL 65622 0 3
3426: ST_TO_ADDR
// if Gladstone then
3427: LD_EXP 48
3431: IFFALSE 3449
// tmp := tmp ^ Gladstone ;
3433: LD_ADDR_VAR 0 6
3437: PUSH
3438: LD_VAR 0 6
3442: PUSH
3443: LD_EXP 48
3447: ADD
3448: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3449: LD_ADDR_EXP 49
3453: PUSH
3454: LD_STRING Houten
3456: PPUSH
3457: LD_EXP 1
3461: NOT
3462: PPUSH
3463: LD_STRING 13s_
3465: PPUSH
3466: CALL 65622 0 3
3470: ST_TO_ADDR
// if Houten then
3471: LD_EXP 49
3475: IFFALSE 3493
// tmp := tmp ^ Houten ;
3477: LD_ADDR_VAR 0 6
3481: PUSH
3482: LD_VAR 0 6
3486: PUSH
3487: LD_EXP 49
3491: ADD
3492: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3493: LD_ADDR_EXP 50
3497: PUSH
3498: LD_STRING Cornel
3500: PPUSH
3501: LD_EXP 1
3505: NOT
3506: PPUSH
3507: LD_STRING 13s_
3509: PPUSH
3510: CALL 65622 0 3
3514: ST_TO_ADDR
// if Cornel then
3515: LD_EXP 50
3519: IFFALSE 3537
// tmp := tmp ^ Cornel ;
3521: LD_ADDR_VAR 0 6
3525: PUSH
3526: LD_VAR 0 6
3530: PUSH
3531: LD_EXP 50
3535: ADD
3536: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3537: LD_ADDR_EXP 51
3541: PUSH
3542: LD_STRING Gary
3544: PPUSH
3545: LD_EXP 1
3549: NOT
3550: PPUSH
3551: LD_STRING 13s_
3553: PPUSH
3554: CALL 65622 0 3
3558: ST_TO_ADDR
// if Gary then
3559: LD_EXP 51
3563: IFFALSE 3581
// tmp := tmp ^ Gary ;
3565: LD_ADDR_VAR 0 6
3569: PUSH
3570: LD_VAR 0 6
3574: PUSH
3575: LD_EXP 51
3579: ADD
3580: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3581: LD_ADDR_EXP 52
3585: PUSH
3586: LD_STRING Frank
3588: PPUSH
3589: LD_EXP 1
3593: NOT
3594: PPUSH
3595: LD_STRING 13s_
3597: PPUSH
3598: CALL 65622 0 3
3602: ST_TO_ADDR
// if Frank then
3603: LD_EXP 52
3607: IFFALSE 3625
// tmp := tmp ^ Frank ;
3609: LD_ADDR_VAR 0 6
3613: PUSH
3614: LD_VAR 0 6
3618: PUSH
3619: LD_EXP 52
3623: ADD
3624: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3625: LD_ADDR_EXP 53
3629: PUSH
3630: LD_STRING Kikuchi
3632: PPUSH
3633: LD_EXP 1
3637: NOT
3638: PPUSH
3639: LD_STRING 13s_
3641: PPUSH
3642: CALL 65622 0 3
3646: ST_TO_ADDR
// if Kikuchi then
3647: LD_EXP 53
3651: IFFALSE 3669
// tmp := tmp ^ Kikuchi ;
3653: LD_ADDR_VAR 0 6
3657: PUSH
3658: LD_VAR 0 6
3662: PUSH
3663: LD_EXP 53
3667: ADD
3668: ST_TO_ADDR
// vip := tmp ;
3669: LD_ADDR_EXP 59
3673: PUSH
3674: LD_VAR 0 6
3678: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3679: LD_ADDR_VAR 0 6
3683: PUSH
3684: LD_VAR 0 6
3688: PUSH
3689: LD_STRING 13s_others
3691: PPUSH
3692: CALL_OW 31
3696: UNION
3697: ST_TO_ADDR
// if tmp < 18 then
3698: LD_VAR 0 6
3702: PUSH
3703: LD_INT 18
3705: LESS
3706: IFFALSE 3773
// for i = 1 to 18 - tmp do
3708: LD_ADDR_VAR 0 2
3712: PUSH
3713: DOUBLE
3714: LD_INT 1
3716: DEC
3717: ST_TO_ADDR
3718: LD_INT 18
3720: PUSH
3721: LD_VAR 0 6
3725: MINUS
3726: PUSH
3727: FOR_TO
3728: IFFALSE 3771
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3730: LD_INT 1
3732: PPUSH
3733: LD_VAR 0 2
3737: PUSH
3738: LD_INT 4
3740: MOD
3741: PUSH
3742: LD_INT 1
3744: PLUS
3745: PPUSH
3746: LD_INT 5
3748: PPUSH
3749: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3753: LD_ADDR_VAR 0 6
3757: PUSH
3758: LD_VAR 0 6
3762: PUSH
3763: CALL_OW 44
3767: ADD
3768: ST_TO_ADDR
// end ;
3769: GO 3727
3771: POP
3772: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3773: LD_ADDR_VAR 0 7
3777: PUSH
3778: LD_INT 22
3780: PUSH
3781: LD_INT 4
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: PUSH
3788: LD_INT 30
3790: PUSH
3791: LD_INT 0
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: PUSH
3798: EMPTY
3799: LIST
3800: LIST
3801: PPUSH
3802: CALL_OW 69
3806: PUSH
3807: LD_INT 1
3809: ARRAY
3810: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3811: LD_ADDR_VAR 0 8
3815: PUSH
3816: LD_INT 22
3818: PUSH
3819: LD_INT 4
3821: PUSH
3822: EMPTY
3823: LIST
3824: LIST
3825: PUSH
3826: LD_INT 30
3828: PUSH
3829: LD_INT 6
3831: PUSH
3832: EMPTY
3833: LIST
3834: LIST
3835: PUSH
3836: EMPTY
3837: LIST
3838: LIST
3839: PPUSH
3840: CALL_OW 69
3844: PUSH
3845: LD_INT 1
3847: ARRAY
3848: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3849: LD_ADDR_VAR 0 9
3853: PUSH
3854: LD_INT 22
3856: PUSH
3857: LD_INT 4
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: PUSH
3864: LD_INT 30
3866: PUSH
3867: LD_INT 4
3869: PUSH
3870: EMPTY
3871: LIST
3872: LIST
3873: PUSH
3874: EMPTY
3875: LIST
3876: LIST
3877: PPUSH
3878: CALL_OW 69
3882: PUSH
3883: LD_INT 1
3885: ARRAY
3886: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3887: LD_ADDR_VAR 0 10
3891: PUSH
3892: LD_INT 22
3894: PUSH
3895: LD_INT 4
3897: PUSH
3898: EMPTY
3899: LIST
3900: LIST
3901: PUSH
3902: LD_INT 30
3904: PUSH
3905: LD_INT 2
3907: PUSH
3908: EMPTY
3909: LIST
3910: LIST
3911: PUSH
3912: EMPTY
3913: LIST
3914: LIST
3915: PPUSH
3916: CALL_OW 69
3920: PUSH
3921: LD_INT 1
3923: ARRAY
3924: ST_TO_ADDR
// for i in tmp do
3925: LD_ADDR_VAR 0 2
3929: PUSH
3930: LD_VAR 0 6
3934: PUSH
3935: FOR_IN
3936: IFFALSE 4062
// begin cl := GetClass ( i ) ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_VAR 0 2
3947: PPUSH
3948: CALL_OW 257
3952: ST_TO_ADDR
// if cl > 4 then
3953: LD_VAR 0 5
3957: PUSH
3958: LD_INT 4
3960: GREATER
3961: IFFALSE 3971
// cl := 1 ;
3963: LD_ADDR_VAR 0 5
3967: PUSH
3968: LD_INT 1
3970: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3971: LD_ADDR_VAR 0 3
3975: PUSH
3976: LD_VAR 0 9
3980: PUSH
3981: LD_VAR 0 7
3985: PUSH
3986: LD_VAR 0 10
3990: PUSH
3991: LD_VAR 0 8
3995: PUSH
3996: EMPTY
3997: LIST
3998: LIST
3999: LIST
4000: LIST
4001: PUSH
4002: LD_VAR 0 5
4006: ARRAY
4007: ST_TO_ADDR
// if UnitsInside ( b ) < 6 then
4008: LD_VAR 0 3
4012: PPUSH
4013: CALL_OW 313
4017: PUSH
4018: LD_INT 6
4020: LESS
4021: IFFALSE 4039
// PlaceHumanInUnit ( i , b ) else
4023: LD_VAR 0 2
4027: PPUSH
4028: LD_VAR 0 3
4032: PPUSH
4033: CALL_OW 52
4037: GO 4060
// PlaceUnitXYR ( i , 61 , 89 , 6 , false ) ;
4039: LD_VAR 0 2
4043: PPUSH
4044: LD_INT 61
4046: PPUSH
4047: LD_INT 89
4049: PPUSH
4050: LD_INT 6
4052: PPUSH
4053: LD_INT 0
4055: PPUSH
4056: CALL_OW 50
// end ;
4060: GO 3935
4062: POP
4063: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4064: LD_INT 2
4066: PPUSH
4067: LD_INT 1
4069: PPUSH
4070: LD_INT 1
4072: PPUSH
4073: LD_INT 12
4075: PPUSH
4076: LD_INT 100
4078: PPUSH
4079: CALL 70486 0 5
// veh := CreateVehicle ;
4083: LD_ADDR_VAR 0 4
4087: PUSH
4088: CALL_OW 45
4092: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4093: LD_VAR 0 4
4097: PPUSH
4098: LD_INT 4
4100: PPUSH
4101: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4105: LD_VAR 0 4
4109: PPUSH
4110: LD_INT 49
4112: PPUSH
4113: LD_INT 88
4115: PPUSH
4116: LD_INT 0
4118: PPUSH
4119: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4123: LD_VAR 0 4
4127: PPUSH
4128: LD_INT 1
4130: PPUSH
4131: LD_INT 100
4133: PPUSH
4134: CALL_OW 290
// uc_side := 0 ;
4138: LD_ADDR_OWVAR 20
4142: PUSH
4143: LD_INT 0
4145: ST_TO_ADDR
// uc_nation := 0 ;
4146: LD_ADDR_OWVAR 21
4150: PUSH
4151: LD_INT 0
4153: ST_TO_ADDR
// for i = 1 to 4 do
4154: LD_ADDR_VAR 0 2
4158: PUSH
4159: DOUBLE
4160: LD_INT 1
4162: DEC
4163: ST_TO_ADDR
4164: LD_INT 4
4166: PUSH
4167: FOR_TO
4168: IFFALSE 4199
// begin InitHc ;
4170: CALL_OW 19
// hc_class := class_apeman ;
4174: LD_ADDR_OWVAR 28
4178: PUSH
4179: LD_INT 12
4181: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4182: CALL_OW 44
4186: PPUSH
4187: LD_INT 13
4189: PPUSH
4190: LD_INT 0
4192: PPUSH
4193: CALL_OW 49
// end ;
4197: GO 4167
4199: POP
4200: POP
// end ; end_of_file
4201: LD_VAR 0 1
4205: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4206: LD_INT 0
4208: PPUSH
4209: PPUSH
4210: PPUSH
4211: PPUSH
4212: PPUSH
// side := 8 ;
4213: LD_ADDR_VAR 0 3
4217: PUSH
4218: LD_INT 8
4220: ST_TO_ADDR
// uc_side := side ;
4221: LD_ADDR_OWVAR 20
4225: PUSH
4226: LD_VAR 0 3
4230: ST_TO_ADDR
// uc_nation := 2 ;
4231: LD_ADDR_OWVAR 21
4235: PUSH
4236: LD_INT 2
4238: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4239: LD_ADDR_VAR 0 2
4243: PUSH
4244: LD_INT 22
4246: PUSH
4247: LD_VAR 0 3
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: PUSH
4256: LD_INT 21
4258: PUSH
4259: LD_INT 3
4261: PUSH
4262: EMPTY
4263: LIST
4264: LIST
4265: PUSH
4266: EMPTY
4267: LIST
4268: LIST
4269: PPUSH
4270: CALL_OW 69
4274: PUSH
4275: FOR_IN
4276: IFFALSE 4292
// SetBLevel ( i , 10 ) ;
4278: LD_VAR 0 2
4282: PPUSH
4283: LD_INT 10
4285: PPUSH
4286: CALL_OW 241
4290: GO 4275
4292: POP
4293: POP
// if KurtStatus then
4294: LD_EXP 3
4298: IFFALSE 4321
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4300: LD_ADDR_EXP 60
4304: PUSH
4305: LD_STRING Kurt
4307: PPUSH
4308: LD_INT 0
4310: PPUSH
4311: LD_STRING 
4313: PPUSH
4314: CALL 65622 0 3
4318: ST_TO_ADDR
4319: GO 4343
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4321: LD_ADDR_EXP 60
4325: PUSH
4326: LD_STRING AltKurt
4328: PPUSH
4329: LD_EXP 1
4333: NOT
4334: PPUSH
4335: LD_STRING 
4337: PPUSH
4338: CALL 65622 0 3
4342: ST_TO_ADDR
// if not Kurt then
4343: LD_EXP 60
4347: NOT
4348: IFFALSE 4374
// begin InitHc ;
4350: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4354: LD_INT 1
4356: PPUSH
4357: LD_INT 10
4359: PPUSH
4360: CALL_OW 381
// Kurt := CreateHuman ;
4364: LD_ADDR_EXP 60
4368: PUSH
4369: CALL_OW 44
4373: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4374: LD_EXP 60
4378: PPUSH
4379: LD_INT 324
4381: PPUSH
4382: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4386: LD_ADDR_EXP 61
4390: PUSH
4391: LD_STRING Kozlov
4393: PPUSH
4394: LD_INT 0
4396: PPUSH
4397: LD_STRING 
4399: PPUSH
4400: CALL 65622 0 3
4404: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4405: LD_EXP 61
4409: PPUSH
4410: LD_INT 22
4412: PUSH
4413: LD_INT 8
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: PUSH
4420: LD_INT 23
4422: PUSH
4423: LD_INT 3
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: LD_INT 30
4432: PUSH
4433: LD_INT 8
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: LIST
4444: PPUSH
4445: CALL_OW 69
4449: PUSH
4450: LD_INT 1
4452: ARRAY
4453: PPUSH
4454: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4458: LD_EXP 61
4462: PPUSH
4463: LD_INT 3
4465: PPUSH
4466: LD_INT 10
4468: PPUSH
4469: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4473: LD_EXP 61
4477: PPUSH
4478: LD_INT 4
4480: PPUSH
4481: LD_INT 10
4483: PPUSH
4484: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4488: LD_ADDR_VAR 0 5
4492: PUSH
4493: LD_INT 22
4495: PUSH
4496: LD_VAR 0 3
4500: PUSH
4501: EMPTY
4502: LIST
4503: LIST
4504: PUSH
4505: LD_INT 30
4507: PUSH
4508: LD_INT 32
4510: PUSH
4511: EMPTY
4512: LIST
4513: LIST
4514: PUSH
4515: LD_INT 58
4517: PUSH
4518: EMPTY
4519: LIST
4520: PUSH
4521: EMPTY
4522: LIST
4523: LIST
4524: LIST
4525: PPUSH
4526: CALL_OW 69
4530: ST_TO_ADDR
// for i = 1 to 10 do
4531: LD_ADDR_VAR 0 2
4535: PUSH
4536: DOUBLE
4537: LD_INT 1
4539: DEC
4540: ST_TO_ADDR
4541: LD_INT 10
4543: PUSH
4544: FOR_TO
4545: IFFALSE 4617
// begin uc_nation := nation_nature ;
4547: LD_ADDR_OWVAR 21
4551: PUSH
4552: LD_INT 0
4554: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4555: LD_ADDR_OWVAR 28
4559: PUSH
4560: LD_INT 15
4562: ST_TO_ADDR
// hc_gallery :=  ;
4563: LD_ADDR_OWVAR 33
4567: PUSH
4568: LD_STRING 
4570: ST_TO_ADDR
// hc_name :=  ;
4571: LD_ADDR_OWVAR 26
4575: PUSH
4576: LD_STRING 
4578: ST_TO_ADDR
// un := CreateHuman ;
4579: LD_ADDR_VAR 0 4
4583: PUSH
4584: CALL_OW 44
4588: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4589: LD_VAR 0 4
4593: PPUSH
4594: LD_VAR 0 5
4598: PUSH
4599: LD_VAR 0 5
4603: PUSH
4604: LD_VAR 0 2
4608: MINUS
4609: ARRAY
4610: PPUSH
4611: CALL_OW 52
// end ;
4615: GO 4544
4617: POP
4618: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4619: LD_ADDR_VAR 0 5
4623: PUSH
4624: LD_STRING 12_kurt_squad
4626: PPUSH
4627: CALL_OW 31
4631: ST_TO_ADDR
// if tmp then
4632: LD_VAR 0 5
4636: IFFALSE 4670
// for i in tmp do
4638: LD_ADDR_VAR 0 2
4642: PUSH
4643: LD_VAR 0 5
4647: PUSH
4648: FOR_IN
4649: IFFALSE 4668
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4651: LD_VAR 0 2
4655: PPUSH
4656: LD_INT 5
4658: PPUSH
4659: LD_INT 0
4661: PPUSH
4662: CALL_OW 49
4666: GO 4648
4668: POP
4669: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4670: LD_INT 324
4672: PPUSH
4673: LD_INT 5
4675: PPUSH
4676: LD_STRING 
4678: PPUSH
4679: LD_INT 8
4681: PUSH
4682: LD_INT 9
4684: PUSH
4685: LD_INT 10
4687: PUSH
4688: EMPTY
4689: LIST
4690: LIST
4691: LIST
4692: PUSH
4693: LD_OWVAR 67
4697: ARRAY
4698: PPUSH
4699: LD_INT 3000
4701: PUSH
4702: LD_INT 500
4704: PUSH
4705: LD_INT 150
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: LIST
4712: PPUSH
4713: LD_INT 16
4715: PUSH
4716: LD_INT 6
4718: PUSH
4719: LD_INT 6
4721: PUSH
4722: LD_INT 8
4724: PUSH
4725: EMPTY
4726: LIST
4727: LIST
4728: LIST
4729: LIST
4730: PPUSH
4731: CALL 73932 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4735: LD_ADDR_EXP 116
4739: PUSH
4740: LD_EXP 116
4744: PPUSH
4745: LD_INT 3
4747: PPUSH
4748: LD_INT 22
4750: PUSH
4751: LD_VAR 0 3
4755: PUSH
4756: EMPTY
4757: LIST
4758: LIST
4759: PUSH
4760: LD_INT 23
4762: PUSH
4763: LD_INT 2
4765: PUSH
4766: EMPTY
4767: LIST
4768: LIST
4769: PUSH
4770: LD_INT 3
4772: PUSH
4773: LD_INT 21
4775: PUSH
4776: LD_INT 2
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: PUSH
4783: EMPTY
4784: LIST
4785: LIST
4786: PUSH
4787: EMPTY
4788: LIST
4789: LIST
4790: LIST
4791: PPUSH
4792: CALL_OW 69
4796: PUSH
4797: LD_EXP 60
4801: DIFF
4802: PPUSH
4803: CALL_OW 1
4807: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4808: LD_INT 1
4810: PPUSH
4811: LD_INT 7
4813: PPUSH
4814: CALL_OW 383
// Friend := CreateHuman ;
4818: LD_ADDR_EXP 62
4822: PUSH
4823: CALL_OW 44
4827: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4828: LD_INT 14
4830: PPUSH
4831: LD_INT 3
4833: PPUSH
4834: LD_INT 1
4836: PPUSH
4837: LD_INT 29
4839: PPUSH
4840: LD_INT 100
4842: PPUSH
4843: CALL 70486 0 5
// powellBomb := CreateVehicle ;
4847: LD_ADDR_EXP 63
4851: PUSH
4852: CALL_OW 45
4856: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4857: LD_EXP 63
4861: PPUSH
4862: LD_INT 90
4864: PPUSH
4865: LD_INT 51
4867: PPUSH
4868: LD_INT 0
4870: PPUSH
4871: CALL_OW 48
// end ;
4875: LD_VAR 0 1
4879: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4880: LD_INT 0
4882: PPUSH
4883: PPUSH
4884: PPUSH
// if IsLive ( kozlov_fac ) then
4885: LD_INT 332
4887: PPUSH
4888: CALL_OW 300
4892: IFFALSE 4896
// exit ;
4894: GO 5463
// ComExitBuilding ( Kozlov ) ;
4896: LD_EXP 61
4900: PPUSH
4901: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4905: LD_EXP 61
4909: PPUSH
4910: CALL_OW 257
4914: PUSH
4915: LD_INT 2
4917: NONEQUAL
4918: IFFALSE 4953
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4920: LD_EXP 61
4924: PPUSH
4925: LD_INT 324
4927: PPUSH
4928: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4932: LD_EXP 61
4936: PPUSH
4937: LD_INT 2
4939: PPUSH
4940: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4944: LD_EXP 61
4948: PPUSH
4949: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4953: LD_EXP 61
4957: PPUSH
4958: LD_INT 2
4960: PPUSH
4961: LD_INT 93
4963: PPUSH
4964: LD_INT 32
4966: PPUSH
4967: LD_INT 3
4969: PPUSH
4970: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4974: LD_INT 35
4976: PPUSH
4977: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4981: LD_INT 22
4983: PUSH
4984: LD_INT 8
4986: PUSH
4987: EMPTY
4988: LIST
4989: LIST
4990: PUSH
4991: LD_INT 30
4993: PUSH
4994: LD_INT 3
4996: PUSH
4997: EMPTY
4998: LIST
4999: LIST
5000: PUSH
5001: LD_INT 23
5003: PUSH
5004: LD_INT 3
5006: PUSH
5007: EMPTY
5008: LIST
5009: LIST
5010: PUSH
5011: LD_INT 57
5013: PUSH
5014: EMPTY
5015: LIST
5016: PUSH
5017: EMPTY
5018: LIST
5019: LIST
5020: LIST
5021: LIST
5022: PPUSH
5023: CALL_OW 69
5027: IFFALSE 4974
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5029: LD_ADDR_VAR 0 2
5033: PUSH
5034: LD_INT 22
5036: PUSH
5037: LD_INT 8
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: PUSH
5044: LD_INT 30
5046: PUSH
5047: LD_INT 3
5049: PUSH
5050: EMPTY
5051: LIST
5052: LIST
5053: PUSH
5054: LD_INT 23
5056: PUSH
5057: LD_INT 3
5059: PUSH
5060: EMPTY
5061: LIST
5062: LIST
5063: PUSH
5064: LD_INT 57
5066: PUSH
5067: EMPTY
5068: LIST
5069: PUSH
5070: EMPTY
5071: LIST
5072: LIST
5073: LIST
5074: LIST
5075: PPUSH
5076: CALL_OW 69
5080: PUSH
5081: LD_INT 1
5083: ARRAY
5084: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5085: LD_INT 22
5087: PUSH
5088: LD_INT 8
5090: PUSH
5091: EMPTY
5092: LIST
5093: LIST
5094: PUSH
5095: LD_INT 23
5097: PUSH
5098: LD_INT 3
5100: PUSH
5101: EMPTY
5102: LIST
5103: LIST
5104: PUSH
5105: LD_INT 30
5107: PUSH
5108: LD_INT 21
5110: PUSH
5111: EMPTY
5112: LIST
5113: LIST
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: LIST
5119: PPUSH
5120: CALL_OW 69
5124: NOT
5125: IFFALSE 5203
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5127: LD_EXP 61
5131: PPUSH
5132: LD_INT 21
5134: PPUSH
5135: LD_INT 97
5137: PPUSH
5138: LD_INT 36
5140: PPUSH
5141: LD_INT 5
5143: PPUSH
5144: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5148: LD_INT 35
5150: PPUSH
5151: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5155: LD_INT 22
5157: PUSH
5158: LD_INT 8
5160: PUSH
5161: EMPTY
5162: LIST
5163: LIST
5164: PUSH
5165: LD_INT 23
5167: PUSH
5168: LD_INT 3
5170: PUSH
5171: EMPTY
5172: LIST
5173: LIST
5174: PUSH
5175: LD_INT 30
5177: PUSH
5178: LD_INT 21
5180: PUSH
5181: EMPTY
5182: LIST
5183: LIST
5184: PUSH
5185: LD_INT 57
5187: PUSH
5188: EMPTY
5189: LIST
5190: PUSH
5191: EMPTY
5192: LIST
5193: LIST
5194: LIST
5195: LIST
5196: PPUSH
5197: CALL_OW 69
5201: IFFALSE 5148
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5203: LD_INT 22
5205: PUSH
5206: LD_INT 8
5208: PUSH
5209: EMPTY
5210: LIST
5211: LIST
5212: PUSH
5213: LD_INT 23
5215: PUSH
5216: LD_INT 3
5218: PUSH
5219: EMPTY
5220: LIST
5221: LIST
5222: PUSH
5223: LD_INT 30
5225: PUSH
5226: LD_INT 18
5228: PUSH
5229: EMPTY
5230: LIST
5231: LIST
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: LIST
5237: PPUSH
5238: CALL_OW 69
5242: NOT
5243: IFFALSE 5321
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5245: LD_EXP 61
5249: PPUSH
5250: LD_INT 18
5252: PPUSH
5253: LD_INT 89
5255: PPUSH
5256: LD_INT 32
5258: PPUSH
5259: LD_INT 1
5261: PPUSH
5262: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5266: LD_INT 35
5268: PPUSH
5269: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5273: LD_INT 22
5275: PUSH
5276: LD_INT 8
5278: PUSH
5279: EMPTY
5280: LIST
5281: LIST
5282: PUSH
5283: LD_INT 23
5285: PUSH
5286: LD_INT 3
5288: PUSH
5289: EMPTY
5290: LIST
5291: LIST
5292: PUSH
5293: LD_INT 30
5295: PUSH
5296: LD_INT 18
5298: PUSH
5299: EMPTY
5300: LIST
5301: LIST
5302: PUSH
5303: LD_INT 57
5305: PUSH
5306: EMPTY
5307: LIST
5308: PUSH
5309: EMPTY
5310: LIST
5311: LIST
5312: LIST
5313: LIST
5314: PPUSH
5315: CALL_OW 69
5319: IFFALSE 5266
// end ; lab := kozlov_lab ;
5321: LD_ADDR_VAR 0 3
5325: PUSH
5326: LD_INT 336
5328: ST_TO_ADDR
// if not lab then
5329: LD_VAR 0 3
5333: NOT
5334: IFFALSE 5338
// exit ;
5336: GO 5463
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5338: LD_EXP 61
5342: PPUSH
5343: LD_VAR 0 3
5347: PUSH
5348: LD_INT 1
5350: ARRAY
5351: PPUSH
5352: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5356: LD_EXP 61
5360: PPUSH
5361: LD_INT 4
5363: PPUSH
5364: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5368: LD_VAR 0 3
5372: PUSH
5373: LD_INT 1
5375: ARRAY
5376: PPUSH
5377: LD_INT 25
5379: PPUSH
5380: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5384: LD_INT 35
5386: PPUSH
5387: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5391: LD_INT 25
5393: PPUSH
5394: LD_INT 8
5396: PPUSH
5397: CALL_OW 321
5401: PUSH
5402: LD_INT 2
5404: EQUAL
5405: IFFALSE 5384
// ComExitBuilding ( Kozlov ) ;
5407: LD_EXP 61
5411: PPUSH
5412: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5416: LD_EXP 61
5420: PPUSH
5421: LD_VAR 0 2
5425: PPUSH
5426: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5430: LD_EXP 61
5434: PPUSH
5435: LD_INT 3
5437: PPUSH
5438: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5442: LD_VAR 0 2
5446: PPUSH
5447: LD_INT 23
5449: PPUSH
5450: LD_INT 3
5452: PPUSH
5453: LD_INT 1
5455: PPUSH
5456: LD_INT 48
5458: PPUSH
5459: CALL_OW 125
// end ;
5463: LD_VAR 0 1
5467: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5468: LD_EXP 22
5472: NOT
5473: PUSH
5474: LD_EXP 15
5478: PUSH
5479: LD_INT 6
5481: GREATEREQUAL
5482: AND
5483: IFFALSE 5564
5485: GO 5487
5487: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5488: LD_INT 3
5490: PPUSH
5491: LD_INT 3
5493: PPUSH
5494: CALL 59353 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5498: LD_INT 3
5500: PPUSH
5501: LD_INT 14
5503: PUSH
5504: LD_INT 1
5506: PUSH
5507: LD_INT 1
5509: PUSH
5510: LD_INT 28
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: LIST
5517: LIST
5518: PUSH
5519: LD_INT 14
5521: PUSH
5522: LD_INT 1
5524: PUSH
5525: LD_INT 1
5527: PUSH
5528: LD_INT 28
5530: PUSH
5531: EMPTY
5532: LIST
5533: LIST
5534: LIST
5535: LIST
5536: PUSH
5537: LD_INT 14
5539: PUSH
5540: LD_INT 1
5542: PUSH
5543: LD_INT 1
5545: PUSH
5546: LD_INT 28
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: LIST
5553: LIST
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: LIST
5559: PPUSH
5560: CALL 59216 0 2
// end ;
5564: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5565: LD_EXP 22
5569: NOT
5570: PUSH
5571: LD_EXP 15
5575: PUSH
5576: LD_INT 6
5578: GREATEREQUAL
5579: AND
5580: PUSH
5581: LD_INT 3
5583: PPUSH
5584: LD_INT 1
5586: PPUSH
5587: CALL 60634 0 2
5591: NOT
5592: AND
5593: IFFALSE 6433
5595: GO 5597
5597: DISABLE
5598: LD_INT 0
5600: PPUSH
5601: PPUSH
5602: PPUSH
// begin enable ;
5603: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5604: LD_INT 22
5606: PUSH
5607: LD_INT 8
5609: PUSH
5610: EMPTY
5611: LIST
5612: LIST
5613: PUSH
5614: LD_INT 23
5616: PUSH
5617: LD_INT 2
5619: PUSH
5620: EMPTY
5621: LIST
5622: LIST
5623: PUSH
5624: LD_INT 30
5626: PUSH
5627: LD_INT 3
5629: PUSH
5630: EMPTY
5631: LIST
5632: LIST
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: LIST
5638: PPUSH
5639: CALL_OW 69
5643: NOT
5644: IFFALSE 5648
// exit ;
5646: GO 6433
// if Prob ( 40 ) then
5648: LD_INT 40
5650: PPUSH
5651: CALL_OW 13
5655: IFFALSE 5782
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5657: LD_INT 3
5659: PPUSH
5660: LD_INT 14
5662: PUSH
5663: LD_INT 1
5665: PUSH
5666: LD_INT 2
5668: PUSH
5669: LD_INT 28
5671: PUSH
5672: EMPTY
5673: LIST
5674: LIST
5675: LIST
5676: LIST
5677: PUSH
5678: LD_INT 14
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: LD_INT 2
5686: PUSH
5687: LD_INT 28
5689: PUSH
5690: EMPTY
5691: LIST
5692: LIST
5693: LIST
5694: LIST
5695: PUSH
5696: LD_INT 14
5698: PUSH
5699: LD_INT 1
5701: PUSH
5702: LD_INT 2
5704: PUSH
5705: LD_INT 28
5707: PUSH
5708: EMPTY
5709: LIST
5710: LIST
5711: LIST
5712: LIST
5713: PUSH
5714: LD_INT 14
5716: PUSH
5717: LD_INT 1
5719: PUSH
5720: LD_INT 2
5722: PUSH
5723: LD_INT 28
5725: PUSH
5726: EMPTY
5727: LIST
5728: LIST
5729: LIST
5730: LIST
5731: PUSH
5732: LD_INT 14
5734: PUSH
5735: LD_INT 1
5737: PUSH
5738: LD_INT 2
5740: PUSH
5741: LD_INT 28
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: LIST
5748: LIST
5749: PUSH
5750: LD_INT 14
5752: PUSH
5753: LD_INT 1
5755: PUSH
5756: LD_INT 2
5758: PUSH
5759: LD_INT 26
5761: PUSH
5762: EMPTY
5763: LIST
5764: LIST
5765: LIST
5766: LIST
5767: PUSH
5768: EMPTY
5769: LIST
5770: LIST
5771: LIST
5772: LIST
5773: LIST
5774: LIST
5775: PPUSH
5776: CALL 59216 0 2
// end else
5780: GO 5973
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5782: LD_INT 3
5784: PPUSH
5785: LD_INT 14
5787: PUSH
5788: LD_INT 1
5790: PUSH
5791: LD_INT 2
5793: PUSH
5794: LD_INT 27
5796: PUSH
5797: LD_INT 26
5799: PUSH
5800: LD_INT 26
5802: PUSH
5803: EMPTY
5804: LIST
5805: LIST
5806: LIST
5807: PUSH
5808: LD_OWVAR 67
5812: ARRAY
5813: PUSH
5814: EMPTY
5815: LIST
5816: LIST
5817: LIST
5818: LIST
5819: PUSH
5820: LD_INT 14
5822: PUSH
5823: LD_INT 1
5825: PUSH
5826: LD_INT 2
5828: PUSH
5829: LD_INT 27
5831: PUSH
5832: LD_INT 26
5834: PUSH
5835: LD_INT 26
5837: PUSH
5838: EMPTY
5839: LIST
5840: LIST
5841: LIST
5842: PUSH
5843: LD_OWVAR 67
5847: ARRAY
5848: PUSH
5849: EMPTY
5850: LIST
5851: LIST
5852: LIST
5853: LIST
5854: PUSH
5855: LD_INT 14
5857: PUSH
5858: LD_INT 1
5860: PUSH
5861: LD_INT 2
5863: PUSH
5864: LD_INT 26
5866: PUSH
5867: LD_INT 26
5869: PUSH
5870: LD_INT 29
5872: PUSH
5873: EMPTY
5874: LIST
5875: LIST
5876: LIST
5877: PUSH
5878: LD_OWVAR 67
5882: ARRAY
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: LIST
5888: LIST
5889: PUSH
5890: LD_INT 13
5892: PUSH
5893: LD_INT 1
5895: PUSH
5896: LD_INT 2
5898: PUSH
5899: LD_INT 26
5901: PUSH
5902: LD_INT 29
5904: PUSH
5905: LD_INT 29
5907: PUSH
5908: EMPTY
5909: LIST
5910: LIST
5911: LIST
5912: PUSH
5913: LD_OWVAR 67
5917: ARRAY
5918: PUSH
5919: EMPTY
5920: LIST
5921: LIST
5922: LIST
5923: LIST
5924: PUSH
5925: LD_INT 13
5927: PUSH
5928: LD_INT 1
5930: PUSH
5931: LD_INT 2
5933: PUSH
5934: LD_INT 29
5936: PUSH
5937: EMPTY
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: PUSH
5943: LD_INT 14
5945: PUSH
5946: LD_INT 1
5948: PUSH
5949: LD_INT 2
5951: PUSH
5952: LD_INT 26
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: PUSH
5961: EMPTY
5962: LIST
5963: LIST
5964: LIST
5965: LIST
5966: LIST
5967: LIST
5968: PPUSH
5969: CALL 59216 0 2
// end ; repeat wait ( 0 0$1 ) ;
5973: LD_INT 35
5975: PPUSH
5976: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5980: LD_INT 3
5982: PPUSH
5983: LD_INT 1
5985: PPUSH
5986: CALL 60634 0 2
5990: PUSH
5991: LD_INT 6
5993: GREATEREQUAL
5994: IFFALSE 5973
// wait ( 0 0$30 ) ;
5996: LD_INT 1050
5998: PPUSH
5999: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6003: LD_ADDR_VAR 0 2
6007: PUSH
6008: LD_INT 3
6010: PPUSH
6011: LD_INT 1
6013: PPUSH
6014: CALL 60634 0 2
6018: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6019: LD_ADDR_EXP 135
6023: PUSH
6024: LD_EXP 135
6028: PPUSH
6029: LD_INT 3
6031: PPUSH
6032: LD_EXP 135
6036: PUSH
6037: LD_INT 3
6039: ARRAY
6040: PUSH
6041: LD_VAR 0 2
6045: DIFF
6046: PPUSH
6047: CALL_OW 1
6051: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6052: LD_ADDR_VAR 0 3
6056: PUSH
6057: LD_INT 0
6059: PPUSH
6060: LD_INT 2
6062: PPUSH
6063: CALL_OW 12
6067: ST_TO_ADDR
// if target then
6068: LD_VAR 0 3
6072: IFFALSE 6200
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6074: LD_ADDR_VAR 0 2
6078: PUSH
6079: LD_VAR 0 2
6083: PPUSH
6084: LD_INT 24
6086: PUSH
6087: LD_INT 250
6089: PUSH
6090: EMPTY
6091: LIST
6092: LIST
6093: PPUSH
6094: CALL_OW 72
6098: ST_TO_ADDR
// for i in tmp do
6099: LD_ADDR_VAR 0 1
6103: PUSH
6104: LD_VAR 0 2
6108: PUSH
6109: FOR_IN
6110: IFFALSE 6150
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6112: LD_VAR 0 1
6116: PPUSH
6117: LD_INT 89
6119: PPUSH
6120: LD_INT 71
6122: PPUSH
6123: CALL_OW 297
6127: PUSH
6128: LD_INT 9
6130: GREATER
6131: IFFALSE 6148
// ComMoveXY ( i , 89 , 71 ) ;
6133: LD_VAR 0 1
6137: PPUSH
6138: LD_INT 89
6140: PPUSH
6141: LD_INT 71
6143: PPUSH
6144: CALL_OW 111
6148: GO 6109
6150: POP
6151: POP
// wait ( 0 0$1 ) ;
6152: LD_INT 35
6154: PPUSH
6155: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6159: LD_VAR 0 2
6163: PPUSH
6164: LD_INT 92
6166: PUSH
6167: LD_INT 89
6169: PUSH
6170: LD_INT 71
6172: PUSH
6173: LD_INT 9
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: LIST
6180: LIST
6181: PPUSH
6182: CALL_OW 72
6186: PUSH
6187: LD_VAR 0 2
6191: PUSH
6192: LD_INT 1
6194: MINUS
6195: GREATEREQUAL
6196: IFFALSE 6074
// end else
6198: GO 6324
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6200: LD_ADDR_VAR 0 2
6204: PUSH
6205: LD_VAR 0 2
6209: PPUSH
6210: LD_INT 24
6212: PUSH
6213: LD_INT 250
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: PPUSH
6220: CALL_OW 72
6224: ST_TO_ADDR
// for i in tmp do
6225: LD_ADDR_VAR 0 1
6229: PUSH
6230: LD_VAR 0 2
6234: PUSH
6235: FOR_IN
6236: IFFALSE 6276
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6238: LD_VAR 0 1
6242: PPUSH
6243: LD_INT 125
6245: PPUSH
6246: LD_INT 129
6248: PPUSH
6249: CALL_OW 297
6253: PUSH
6254: LD_INT 9
6256: GREATER
6257: IFFALSE 6274
// ComMoveXY ( i , 125 , 129 ) ;
6259: LD_VAR 0 1
6263: PPUSH
6264: LD_INT 125
6266: PPUSH
6267: LD_INT 129
6269: PPUSH
6270: CALL_OW 111
6274: GO 6235
6276: POP
6277: POP
// wait ( 0 0$1 ) ;
6278: LD_INT 35
6280: PPUSH
6281: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6285: LD_VAR 0 2
6289: PPUSH
6290: LD_INT 92
6292: PUSH
6293: LD_INT 125
6295: PUSH
6296: LD_INT 129
6298: PUSH
6299: LD_INT 9
6301: PUSH
6302: EMPTY
6303: LIST
6304: LIST
6305: LIST
6306: LIST
6307: PPUSH
6308: CALL_OW 72
6312: PUSH
6313: LD_VAR 0 2
6317: PUSH
6318: LD_INT 1
6320: MINUS
6321: GREATEREQUAL
6322: IFFALSE 6200
// end ; repeat wait ( 0 0$1 ) ;
6324: LD_INT 35
6326: PPUSH
6327: CALL_OW 67
// for i in tmp do
6331: LD_ADDR_VAR 0 1
6335: PUSH
6336: LD_VAR 0 2
6340: PUSH
6341: FOR_IN
6342: IFFALSE 6424
// begin if GetLives ( i ) > 251 then
6344: LD_VAR 0 1
6348: PPUSH
6349: CALL_OW 256
6353: PUSH
6354: LD_INT 251
6356: GREATER
6357: IFFALSE 6395
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6359: LD_VAR 0 1
6363: PPUSH
6364: LD_INT 81
6366: PUSH
6367: LD_INT 8
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: PPUSH
6374: CALL_OW 69
6378: PPUSH
6379: LD_VAR 0 1
6383: PPUSH
6384: CALL_OW 74
6388: PPUSH
6389: CALL_OW 115
6393: GO 6422
// if IsDead ( i ) then
6395: LD_VAR 0 1
6399: PPUSH
6400: CALL_OW 301
6404: IFFALSE 6422
// tmp := tmp diff i ;
6406: LD_ADDR_VAR 0 2
6410: PUSH
6411: LD_VAR 0 2
6415: PUSH
6416: LD_VAR 0 1
6420: DIFF
6421: ST_TO_ADDR
// end ;
6422: GO 6341
6424: POP
6425: POP
// until not tmp ;
6426: LD_VAR 0 2
6430: NOT
6431: IFFALSE 6324
// end ;
6433: PPOPN 3
6435: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6436: LD_EXP 22
6440: NOT
6441: PUSH
6442: LD_EXP 15
6446: PUSH
6447: LD_INT 6
6449: GREATEREQUAL
6450: AND
6451: PUSH
6452: LD_OWVAR 67
6456: PUSH
6457: LD_INT 1
6459: GREATER
6460: AND
6461: IFFALSE 6978
6463: GO 6465
6465: DISABLE
6466: LD_INT 0
6468: PPUSH
6469: PPUSH
6470: PPUSH
// begin enable ;
6471: ENABLE
// tmp := [ ] ;
6472: LD_ADDR_VAR 0 3
6476: PUSH
6477: EMPTY
6478: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6479: LD_ADDR_VAR 0 1
6483: PUSH
6484: DOUBLE
6485: LD_INT 1
6487: DEC
6488: ST_TO_ADDR
6489: LD_INT 4
6491: PUSH
6492: LD_INT 6
6494: PUSH
6495: LD_INT 7
6497: PUSH
6498: EMPTY
6499: LIST
6500: LIST
6501: LIST
6502: PUSH
6503: LD_OWVAR 67
6507: ARRAY
6508: PUSH
6509: FOR_TO
6510: IFFALSE 6670
// begin uc_side := 8 ;
6512: LD_ADDR_OWVAR 20
6516: PUSH
6517: LD_INT 8
6519: ST_TO_ADDR
// uc_nation := 2 ;
6520: LD_ADDR_OWVAR 21
6524: PUSH
6525: LD_INT 2
6527: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6528: LD_INT 13
6530: PUSH
6531: LD_INT 14
6533: PUSH
6534: EMPTY
6535: LIST
6536: LIST
6537: PUSH
6538: LD_INT 1
6540: PPUSH
6541: LD_INT 2
6543: PPUSH
6544: CALL_OW 12
6548: ARRAY
6549: PPUSH
6550: LD_INT 1
6552: PPUSH
6553: LD_INT 5
6555: PPUSH
6556: LD_INT 27
6558: PUSH
6559: LD_INT 28
6561: PUSH
6562: LD_INT 26
6564: PUSH
6565: LD_INT 25
6567: PUSH
6568: EMPTY
6569: LIST
6570: LIST
6571: LIST
6572: LIST
6573: PUSH
6574: LD_INT 1
6576: PPUSH
6577: LD_INT 4
6579: PPUSH
6580: CALL_OW 12
6584: ARRAY
6585: PPUSH
6586: LD_INT 88
6588: PPUSH
6589: CALL 70486 0 5
// un := CreateVehicle ;
6593: LD_ADDR_VAR 0 2
6597: PUSH
6598: CALL_OW 45
6602: ST_TO_ADDR
// tmp := tmp ^ un ;
6603: LD_ADDR_VAR 0 3
6607: PUSH
6608: LD_VAR 0 3
6612: PUSH
6613: LD_VAR 0 2
6617: ADD
6618: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6619: LD_VAR 0 2
6623: PPUSH
6624: LD_INT 3
6626: PPUSH
6627: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6631: LD_VAR 0 2
6635: PPUSH
6636: LD_INT 30
6638: PPUSH
6639: LD_INT 0
6641: PPUSH
6642: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6646: LD_VAR 0 2
6650: PPUSH
6651: LD_INT 16
6653: PPUSH
6654: LD_INT 11
6656: PPUSH
6657: CALL_OW 111
// wait ( 0 0$2 ) ;
6661: LD_INT 70
6663: PPUSH
6664: CALL_OW 67
// end ;
6668: GO 6509
6670: POP
6671: POP
// for i = 1 to Difficulty do
6672: LD_ADDR_VAR 0 1
6676: PUSH
6677: DOUBLE
6678: LD_INT 1
6680: DEC
6681: ST_TO_ADDR
6682: LD_OWVAR 67
6686: PUSH
6687: FOR_TO
6688: IFFALSE 6813
// begin uc_side := 8 ;
6690: LD_ADDR_OWVAR 20
6694: PUSH
6695: LD_INT 8
6697: ST_TO_ADDR
// uc_nation := 2 ;
6698: LD_ADDR_OWVAR 21
6702: PUSH
6703: LD_INT 2
6705: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6706: LD_INT 0
6708: PPUSH
6709: LD_INT 8
6711: PPUSH
6712: LD_INT 8
6714: PUSH
6715: LD_INT 8
6717: PUSH
6718: LD_INT 9
6720: PUSH
6721: EMPTY
6722: LIST
6723: LIST
6724: LIST
6725: PUSH
6726: LD_OWVAR 67
6730: ARRAY
6731: PPUSH
6732: CALL_OW 380
// un := CreateHuman ;
6736: LD_ADDR_VAR 0 2
6740: PUSH
6741: CALL_OW 44
6745: ST_TO_ADDR
// tmp := tmp ^ un ;
6746: LD_ADDR_VAR 0 3
6750: PUSH
6751: LD_VAR 0 3
6755: PUSH
6756: LD_VAR 0 2
6760: ADD
6761: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6762: LD_VAR 0 2
6766: PPUSH
6767: LD_INT 3
6769: PPUSH
6770: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6774: LD_VAR 0 2
6778: PPUSH
6779: LD_INT 30
6781: PPUSH
6782: LD_INT 0
6784: PPUSH
6785: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6789: LD_VAR 0 2
6793: PPUSH
6794: LD_INT 16
6796: PPUSH
6797: LD_INT 11
6799: PPUSH
6800: CALL_OW 111
// wait ( 0 0$2 ) ;
6804: LD_INT 70
6806: PPUSH
6807: CALL_OW 67
// end ;
6811: GO 6687
6813: POP
6814: POP
// repeat wait ( 0 0$1 ) ;
6815: LD_INT 35
6817: PPUSH
6818: CALL_OW 67
// for i in tmp do
6822: LD_ADDR_VAR 0 1
6826: PUSH
6827: LD_VAR 0 3
6831: PUSH
6832: FOR_IN
6833: IFFALSE 6969
// begin if GetLives ( i ) > 250 then
6835: LD_VAR 0 1
6839: PPUSH
6840: CALL_OW 256
6844: PUSH
6845: LD_INT 250
6847: GREATER
6848: IFFALSE 6940
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6850: LD_INT 81
6852: PUSH
6853: LD_INT 8
6855: PUSH
6856: EMPTY
6857: LIST
6858: LIST
6859: PUSH
6860: LD_INT 91
6862: PUSH
6863: LD_VAR 0 1
6867: PUSH
6868: LD_INT 10
6870: PUSH
6871: EMPTY
6872: LIST
6873: LIST
6874: LIST
6875: PUSH
6876: EMPTY
6877: LIST
6878: LIST
6879: PPUSH
6880: CALL_OW 69
6884: NOT
6885: IFFALSE 6904
// ComAgressiveMove ( i , 67 , 110 ) else
6887: LD_VAR 0 1
6891: PPUSH
6892: LD_INT 67
6894: PPUSH
6895: LD_INT 110
6897: PPUSH
6898: CALL_OW 114
6902: GO 6938
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6904: LD_VAR 0 1
6908: PPUSH
6909: LD_INT 81
6911: PUSH
6912: LD_INT 8
6914: PUSH
6915: EMPTY
6916: LIST
6917: LIST
6918: PPUSH
6919: CALL_OW 69
6923: PPUSH
6924: LD_VAR 0 1
6928: PPUSH
6929: CALL_OW 74
6933: PPUSH
6934: CALL_OW 115
// end else
6938: GO 6967
// if IsDead ( i ) then
6940: LD_VAR 0 1
6944: PPUSH
6945: CALL_OW 301
6949: IFFALSE 6967
// tmp := tmp diff i ;
6951: LD_ADDR_VAR 0 3
6955: PUSH
6956: LD_VAR 0 3
6960: PUSH
6961: LD_VAR 0 1
6965: DIFF
6966: ST_TO_ADDR
// end ;
6967: GO 6832
6969: POP
6970: POP
// until not tmp ;
6971: LD_VAR 0 3
6975: NOT
6976: IFFALSE 6815
// end ; end_of_file
6978: PPOPN 3
6980: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6981: LD_INT 0
6983: PPUSH
6984: PPUSH
6985: PPUSH
6986: PPUSH
6987: PPUSH
6988: PPUSH
6989: PPUSH
6990: PPUSH
6991: PPUSH
// side := 3 ;
6992: LD_ADDR_VAR 0 6
6996: PUSH
6997: LD_INT 3
6999: ST_TO_ADDR
// uc_side := side ;
7000: LD_ADDR_OWVAR 20
7004: PUSH
7005: LD_VAR 0 6
7009: ST_TO_ADDR
// uc_nation := 3 ;
7010: LD_ADDR_OWVAR 21
7014: PUSH
7015: LD_INT 3
7017: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7018: LD_ADDR_VAR 0 2
7022: PUSH
7023: LD_INT 22
7025: PUSH
7026: LD_VAR 0 6
7030: PUSH
7031: EMPTY
7032: LIST
7033: LIST
7034: PUSH
7035: LD_INT 21
7037: PUSH
7038: LD_INT 3
7040: PUSH
7041: EMPTY
7042: LIST
7043: LIST
7044: PUSH
7045: EMPTY
7046: LIST
7047: LIST
7048: PPUSH
7049: CALL_OW 69
7053: PUSH
7054: FOR_IN
7055: IFFALSE 7071
// SetBLevel ( i , 10 ) ;
7057: LD_VAR 0 2
7061: PPUSH
7062: LD_INT 10
7064: PPUSH
7065: CALL_OW 241
7069: GO 7054
7071: POP
7072: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7073: LD_ADDR_VAR 0 9
7077: PUSH
7078: LD_INT 22
7080: PUSH
7081: LD_VAR 0 6
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: PUSH
7090: LD_INT 30
7092: PUSH
7093: LD_INT 34
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PUSH
7100: EMPTY
7101: LIST
7102: LIST
7103: PPUSH
7104: CALL_OW 69
7108: ST_TO_ADDR
// if teleport then
7109: LD_VAR 0 9
7113: IFFALSE 7134
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7115: LD_VAR 0 9
7119: PUSH
7120: LD_INT 1
7122: ARRAY
7123: PPUSH
7124: LD_INT 123
7126: PPUSH
7127: LD_INT 122
7129: PPUSH
7130: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7134: LD_ADDR_EXP 64
7138: PUSH
7139: LD_STRING Platonov
7141: PPUSH
7142: CALL_OW 25
7146: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7147: LD_ADDR_EXP 65
7151: PUSH
7152: LD_STRING Kovalyuk
7154: PPUSH
7155: CALL_OW 25
7159: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7160: LD_ADDR_EXP 67
7164: PUSH
7165: LD_STRING Yakotich
7167: PPUSH
7168: LD_EXP 1
7172: NOT
7173: PPUSH
7174: LD_STRING 09_
7176: PPUSH
7177: CALL 65622 0 3
7181: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7182: LD_ADDR_EXP 66
7186: PUSH
7187: LD_STRING Bystrov
7189: PPUSH
7190: CALL_OW 25
7194: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7195: LD_ADDR_EXP 68
7199: PUSH
7200: LD_STRING Gleb
7202: PPUSH
7203: CALL_OW 25
7207: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7208: LD_STRING 03_Cornel
7210: PPUSH
7211: CALL_OW 28
7215: IFFALSE 7263
// begin Bierezov := NewCharacter ( Mikhail ) ;
7217: LD_ADDR_EXP 69
7221: PUSH
7222: LD_STRING Mikhail
7224: PPUSH
7225: CALL_OW 25
7229: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7230: LD_EXP 69
7234: PPUSH
7235: LD_INT 197
7237: PPUSH
7238: LD_INT 111
7240: PPUSH
7241: LD_INT 9
7243: PPUSH
7244: LD_INT 0
7246: PPUSH
7247: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7251: LD_EXP 69
7255: PPUSH
7256: LD_INT 3
7258: PPUSH
7259: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7263: LD_EXP 64
7267: PPUSH
7268: LD_INT 126
7270: PPUSH
7271: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7275: LD_EXP 65
7279: PPUSH
7280: LD_INT 134
7282: PPUSH
7283: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7287: LD_EXP 67
7291: PPUSH
7292: LD_INT 197
7294: PPUSH
7295: LD_INT 111
7297: PPUSH
7298: LD_INT 9
7300: PPUSH
7301: LD_INT 0
7303: PPUSH
7304: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7308: LD_EXP 66
7312: PPUSH
7313: LD_INT 197
7315: PPUSH
7316: LD_INT 111
7318: PPUSH
7319: LD_INT 9
7321: PPUSH
7322: LD_INT 0
7324: PPUSH
7325: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7329: LD_EXP 68
7333: PPUSH
7334: LD_INT 197
7336: PPUSH
7337: LD_INT 111
7339: PPUSH
7340: LD_INT 9
7342: PPUSH
7343: LD_INT 0
7345: PPUSH
7346: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7350: LD_ADDR_VAR 0 5
7354: PUSH
7355: LD_INT 126
7357: PPUSH
7358: LD_INT 4
7360: PPUSH
7361: LD_STRING zhukov
7363: PPUSH
7364: LD_INT 9
7366: PUSH
7367: LD_INT 10
7369: PUSH
7370: LD_INT 10
7372: PUSH
7373: EMPTY
7374: LIST
7375: LIST
7376: LIST
7377: PUSH
7378: LD_OWVAR 67
7382: ARRAY
7383: PPUSH
7384: LD_INT 90000
7386: PUSH
7387: LD_INT 1000
7389: PUSH
7390: LD_INT 300
7392: PUSH
7393: EMPTY
7394: LIST
7395: LIST
7396: LIST
7397: PPUSH
7398: LD_INT 18
7400: PUSH
7401: LD_INT 8
7403: PUSH
7404: LD_INT 13
7406: PUSH
7407: LD_INT 8
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: LIST
7414: LIST
7415: PPUSH
7416: CALL 73932 0 6
7420: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7421: LD_ADDR_VAR 0 4
7425: PUSH
7426: LD_INT 267
7428: PPUSH
7429: CALL_OW 274
7433: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7434: LD_VAR 0 4
7438: PPUSH
7439: LD_INT 1
7441: PPUSH
7442: LD_INT 5000
7444: PPUSH
7445: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7449: LD_VAR 0 4
7453: PPUSH
7454: LD_INT 2
7456: PPUSH
7457: LD_INT 200
7459: PPUSH
7460: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7464: LD_VAR 0 4
7468: PPUSH
7469: LD_INT 3
7471: PPUSH
7472: LD_INT 200
7474: PPUSH
7475: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7479: LD_ADDR_EXP 116
7483: PUSH
7484: LD_EXP 116
7488: PPUSH
7489: LD_INT 2
7491: PPUSH
7492: LD_VAR 0 5
7496: PUSH
7497: LD_INT 22
7499: PUSH
7500: LD_VAR 0 6
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PUSH
7509: LD_INT 3
7511: PUSH
7512: LD_INT 21
7514: PUSH
7515: LD_INT 2
7517: PUSH
7518: EMPTY
7519: LIST
7520: LIST
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PUSH
7526: EMPTY
7527: LIST
7528: LIST
7529: PPUSH
7530: CALL_OW 69
7534: UNION
7535: PUSH
7536: LD_EXP 64
7540: DIFF
7541: PPUSH
7542: CALL_OW 1
7546: ST_TO_ADDR
// behemoths := [ ] ;
7547: LD_ADDR_EXP 72
7551: PUSH
7552: EMPTY
7553: ST_TO_ADDR
// behemothBuilders := [ ] ;
7554: LD_ADDR_EXP 73
7558: PUSH
7559: EMPTY
7560: ST_TO_ADDR
// if Kovalyuk then
7561: LD_EXP 65
7565: IFFALSE 7587
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7567: LD_ADDR_EXP 73
7571: PUSH
7572: LD_EXP 73
7576: PPUSH
7577: LD_EXP 65
7581: PPUSH
7582: CALL 102359 0 2
7586: ST_TO_ADDR
// j := 3 ;
7587: LD_ADDR_VAR 0 3
7591: PUSH
7592: LD_INT 3
7594: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7595: LD_ADDR_VAR 0 2
7599: PUSH
7600: LD_INT 22
7602: PUSH
7603: LD_INT 3
7605: PUSH
7606: EMPTY
7607: LIST
7608: LIST
7609: PUSH
7610: LD_INT 25
7612: PUSH
7613: LD_INT 3
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PPUSH
7624: CALL_OW 69
7628: PUSH
7629: LD_EXP 65
7633: DIFF
7634: PUSH
7635: FOR_IN
7636: IFFALSE 7686
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7638: LD_ADDR_EXP 73
7642: PUSH
7643: LD_EXP 73
7647: PPUSH
7648: LD_VAR 0 2
7652: PPUSH
7653: CALL 102359 0 2
7657: ST_TO_ADDR
// j := j - 1 ;
7658: LD_ADDR_VAR 0 3
7662: PUSH
7663: LD_VAR 0 3
7667: PUSH
7668: LD_INT 1
7670: MINUS
7671: ST_TO_ADDR
// if j = 0 then
7672: LD_VAR 0 3
7676: PUSH
7677: LD_INT 0
7679: EQUAL
7680: IFFALSE 7684
// break ;
7682: GO 7686
// end ;
7684: GO 7635
7686: POP
7687: POP
// end ;
7688: LD_VAR 0 1
7692: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7693: LD_INT 0
7695: PPUSH
7696: PPUSH
7697: PPUSH
7698: PPUSH
7699: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7700: LD_ADDR_VAR 0 4
7704: PUSH
7705: LD_INT 209
7707: PUSH
7708: LD_INT 149
7710: PUSH
7711: EMPTY
7712: LIST
7713: LIST
7714: PUSH
7715: LD_INT 219
7717: PUSH
7718: LD_INT 154
7720: PUSH
7721: EMPTY
7722: LIST
7723: LIST
7724: PUSH
7725: LD_INT 223
7727: PUSH
7728: LD_INT 149
7730: PUSH
7731: EMPTY
7732: LIST
7733: LIST
7734: PUSH
7735: LD_INT 232
7737: PUSH
7738: LD_INT 155
7740: PUSH
7741: EMPTY
7742: LIST
7743: LIST
7744: PUSH
7745: EMPTY
7746: LIST
7747: LIST
7748: LIST
7749: LIST
7750: ST_TO_ADDR
// if not behemothBuilders then
7751: LD_EXP 73
7755: NOT
7756: IFFALSE 7760
// exit ;
7758: GO 7864
// j := 1 ;
7760: LD_ADDR_VAR 0 3
7764: PUSH
7765: LD_INT 1
7767: ST_TO_ADDR
// for i in behemothBuilders do
7768: LD_ADDR_VAR 0 2
7772: PUSH
7773: LD_EXP 73
7777: PUSH
7778: FOR_IN
7779: IFFALSE 7862
// begin if IsInUnit ( i ) then
7781: LD_VAR 0 2
7785: PPUSH
7786: CALL_OW 310
7790: IFFALSE 7801
// ComExitBuilding ( i ) ;
7792: LD_VAR 0 2
7796: PPUSH
7797: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7801: LD_VAR 0 2
7805: PPUSH
7806: LD_INT 37
7808: PPUSH
7809: LD_VAR 0 4
7813: PUSH
7814: LD_VAR 0 3
7818: ARRAY
7819: PUSH
7820: LD_INT 1
7822: ARRAY
7823: PPUSH
7824: LD_VAR 0 4
7828: PUSH
7829: LD_VAR 0 3
7833: ARRAY
7834: PUSH
7835: LD_INT 2
7837: ARRAY
7838: PPUSH
7839: LD_INT 0
7841: PPUSH
7842: CALL_OW 230
// j := j + 1 ;
7846: LD_ADDR_VAR 0 3
7850: PUSH
7851: LD_VAR 0 3
7855: PUSH
7856: LD_INT 1
7858: PLUS
7859: ST_TO_ADDR
// end ;
7860: GO 7778
7862: POP
7863: POP
// end ;
7864: LD_VAR 0 1
7868: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7869: LD_INT 24
7871: PPUSH
7872: LD_INT 30
7874: PUSH
7875: LD_INT 37
7877: PUSH
7878: EMPTY
7879: LIST
7880: LIST
7881: PPUSH
7882: CALL_OW 70
7886: IFFALSE 7899
7888: GO 7890
7890: DISABLE
// behemothUnderConstruct := true ;
7891: LD_ADDR_EXP 26
7895: PUSH
7896: LD_INT 1
7898: ST_TO_ADDR
7899: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7900: LD_INT 3
7902: PPUSH
7903: CALL 102420 0 1
7907: PUSH
7908: LD_INT 22
7910: PUSH
7911: LD_INT 3
7913: PUSH
7914: EMPTY
7915: LIST
7916: LIST
7917: PUSH
7918: LD_INT 30
7920: PUSH
7921: LD_INT 37
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: PUSH
7928: EMPTY
7929: LIST
7930: LIST
7931: PPUSH
7932: CALL_OW 69
7936: NOT
7937: AND
7938: IFFALSE 8124
7940: GO 7942
7942: DISABLE
7943: LD_INT 0
7945: PPUSH
7946: PPUSH
// begin enable ;
7947: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7948: LD_ADDR_VAR 0 2
7952: PUSH
7953: LD_INT 3
7955: PPUSH
7956: CALL 102420 0 1
7960: ST_TO_ADDR
// for i in tmp do
7961: LD_ADDR_VAR 0 1
7965: PUSH
7966: LD_VAR 0 2
7970: PUSH
7971: FOR_IN
7972: IFFALSE 8122
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7974: LD_VAR 0 1
7978: PPUSH
7979: LD_INT 9
7981: PPUSH
7982: CALL_OW 308
7986: PUSH
7987: LD_VAR 0 1
7991: PPUSH
7992: CALL_OW 110
7996: PUSH
7997: LD_INT 2
7999: EQUAL
8000: NOT
8001: AND
8002: IFFALSE 8016
// SetTag ( i , 2 ) ;
8004: LD_VAR 0 1
8008: PPUSH
8009: LD_INT 2
8011: PPUSH
8012: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8016: LD_INT 81
8018: PUSH
8019: LD_INT 3
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PUSH
8026: LD_INT 91
8028: PUSH
8029: LD_VAR 0 1
8033: PUSH
8034: LD_INT 12
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: LIST
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: PPUSH
8046: CALL_OW 69
8050: NOT
8051: PUSH
8052: LD_VAR 0 1
8056: PPUSH
8057: CALL_OW 110
8061: PUSH
8062: LD_INT 2
8064: EQUAL
8065: NOT
8066: AND
8067: IFFALSE 8086
// ComAgressiveMove ( i , 64 , 93 ) else
8069: LD_VAR 0 1
8073: PPUSH
8074: LD_INT 64
8076: PPUSH
8077: LD_INT 93
8079: PPUSH
8080: CALL_OW 114
8084: GO 8120
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8086: LD_VAR 0 1
8090: PPUSH
8091: LD_INT 81
8093: PUSH
8094: LD_INT 3
8096: PUSH
8097: EMPTY
8098: LIST
8099: LIST
8100: PPUSH
8101: CALL_OW 69
8105: PPUSH
8106: LD_VAR 0 1
8110: PPUSH
8111: CALL_OW 74
8115: PPUSH
8116: CALL_OW 115
// end ;
8120: GO 7971
8122: POP
8123: POP
// end ;
8124: PPOPN 2
8126: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8127: LD_INT 0
8129: PPUSH
8130: PPUSH
8131: PPUSH
// result := [ ] ;
8132: LD_ADDR_VAR 0 2
8136: PUSH
8137: EMPTY
8138: ST_TO_ADDR
// uc_side := 6 ;
8139: LD_ADDR_OWVAR 20
8143: PUSH
8144: LD_INT 6
8146: ST_TO_ADDR
// uc_nation := 3 ;
8147: LD_ADDR_OWVAR 21
8151: PUSH
8152: LD_INT 3
8154: ST_TO_ADDR
// case strength of 1 :
8155: LD_VAR 0 1
8159: PUSH
8160: LD_INT 1
8162: DOUBLE
8163: EQUAL
8164: IFTRUE 8168
8166: GO 8306
8168: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8169: LD_ADDR_VAR 0 3
8173: PUSH
8174: DOUBLE
8175: LD_INT 1
8177: DEC
8178: ST_TO_ADDR
8179: LD_INT 4
8181: PUSH
8182: LD_INT 5
8184: PUSH
8185: LD_INT 6
8187: PUSH
8188: EMPTY
8189: LIST
8190: LIST
8191: LIST
8192: PUSH
8193: LD_OWVAR 67
8197: ARRAY
8198: PUSH
8199: FOR_TO
8200: IFFALSE 8302
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8202: LD_INT 22
8204: PUSH
8205: LD_INT 24
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: PUSH
8212: LD_VAR 0 3
8216: PUSH
8217: LD_INT 2
8219: MOD
8220: PUSH
8221: LD_INT 1
8223: PLUS
8224: ARRAY
8225: PPUSH
8226: LD_INT 1
8228: PUSH
8229: LD_INT 3
8231: PUSH
8232: EMPTY
8233: LIST
8234: LIST
8235: PUSH
8236: LD_INT 1
8238: PPUSH
8239: LD_INT 2
8241: PPUSH
8242: CALL_OW 12
8246: ARRAY
8247: PPUSH
8248: LD_INT 3
8250: PPUSH
8251: LD_INT 43
8253: PUSH
8254: LD_INT 44
8256: PUSH
8257: LD_INT 45
8259: PUSH
8260: EMPTY
8261: LIST
8262: LIST
8263: LIST
8264: PUSH
8265: LD_INT 1
8267: PPUSH
8268: LD_INT 3
8270: PPUSH
8271: CALL_OW 12
8275: ARRAY
8276: PPUSH
8277: LD_INT 80
8279: PPUSH
8280: CALL 70486 0 5
// result := result union CreateVehicle ;
8284: LD_ADDR_VAR 0 2
8288: PUSH
8289: LD_VAR 0 2
8293: PUSH
8294: CALL_OW 45
8298: UNION
8299: ST_TO_ADDR
// end ;
8300: GO 8199
8302: POP
8303: POP
// end ; 2 :
8304: GO 9257
8306: LD_INT 2
8308: DOUBLE
8309: EQUAL
8310: IFTRUE 8314
8312: GO 8470
8314: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8315: LD_ADDR_VAR 0 3
8319: PUSH
8320: DOUBLE
8321: LD_INT 1
8323: DEC
8324: ST_TO_ADDR
8325: LD_INT 5
8327: PUSH
8328: LD_INT 6
8330: PUSH
8331: LD_INT 7
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: LIST
8338: PUSH
8339: LD_OWVAR 67
8343: ARRAY
8344: PUSH
8345: FOR_TO
8346: IFFALSE 8466
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8348: LD_INT 22
8350: PUSH
8351: LD_INT 24
8353: PUSH
8354: LD_INT 24
8356: PUSH
8357: EMPTY
8358: LIST
8359: LIST
8360: LIST
8361: PUSH
8362: LD_VAR 0 3
8366: PUSH
8367: LD_INT 3
8369: MOD
8370: PUSH
8371: LD_INT 1
8373: PLUS
8374: ARRAY
8375: PPUSH
8376: LD_INT 1
8378: PUSH
8379: LD_INT 3
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: PUSH
8386: LD_INT 1
8388: PPUSH
8389: LD_INT 2
8391: PPUSH
8392: CALL_OW 12
8396: ARRAY
8397: PPUSH
8398: LD_INT 3
8400: PPUSH
8401: LD_INT 43
8403: PUSH
8404: LD_INT 44
8406: PUSH
8407: LD_INT 45
8409: PUSH
8410: LD_INT 44
8412: PUSH
8413: LD_INT 46
8415: PUSH
8416: LD_INT 46
8418: PUSH
8419: EMPTY
8420: LIST
8421: LIST
8422: LIST
8423: LIST
8424: LIST
8425: LIST
8426: PUSH
8427: LD_VAR 0 3
8431: PUSH
8432: LD_INT 6
8434: MOD
8435: PUSH
8436: LD_INT 1
8438: PLUS
8439: ARRAY
8440: PPUSH
8441: LD_INT 80
8443: PPUSH
8444: CALL 70486 0 5
// result := result union CreateVehicle ;
8448: LD_ADDR_VAR 0 2
8452: PUSH
8453: LD_VAR 0 2
8457: PUSH
8458: CALL_OW 45
8462: UNION
8463: ST_TO_ADDR
// end ;
8464: GO 8345
8466: POP
8467: POP
// end ; 3 :
8468: GO 9257
8470: LD_INT 3
8472: DOUBLE
8473: EQUAL
8474: IFTRUE 8478
8476: GO 8634
8478: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8479: LD_ADDR_VAR 0 3
8483: PUSH
8484: DOUBLE
8485: LD_INT 1
8487: DEC
8488: ST_TO_ADDR
8489: LD_INT 5
8491: PUSH
8492: LD_INT 7
8494: PUSH
8495: LD_INT 8
8497: PUSH
8498: EMPTY
8499: LIST
8500: LIST
8501: LIST
8502: PUSH
8503: LD_OWVAR 67
8507: ARRAY
8508: PUSH
8509: FOR_TO
8510: IFFALSE 8630
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8512: LD_INT 22
8514: PUSH
8515: LD_INT 24
8517: PUSH
8518: LD_INT 24
8520: PUSH
8521: EMPTY
8522: LIST
8523: LIST
8524: LIST
8525: PUSH
8526: LD_VAR 0 3
8530: PUSH
8531: LD_INT 3
8533: MOD
8534: PUSH
8535: LD_INT 1
8537: PLUS
8538: ARRAY
8539: PPUSH
8540: LD_INT 1
8542: PUSH
8543: LD_INT 3
8545: PUSH
8546: EMPTY
8547: LIST
8548: LIST
8549: PUSH
8550: LD_INT 1
8552: PPUSH
8553: LD_INT 2
8555: PPUSH
8556: CALL_OW 12
8560: ARRAY
8561: PPUSH
8562: LD_INT 3
8564: PPUSH
8565: LD_INT 43
8567: PUSH
8568: LD_INT 47
8570: PUSH
8571: LD_INT 45
8573: PUSH
8574: LD_INT 45
8576: PUSH
8577: LD_INT 46
8579: PUSH
8580: LD_INT 46
8582: PUSH
8583: EMPTY
8584: LIST
8585: LIST
8586: LIST
8587: LIST
8588: LIST
8589: LIST
8590: PUSH
8591: LD_VAR 0 3
8595: PUSH
8596: LD_INT 6
8598: MOD
8599: PUSH
8600: LD_INT 1
8602: PLUS
8603: ARRAY
8604: PPUSH
8605: LD_INT 80
8607: PPUSH
8608: CALL 70486 0 5
// result := result union CreateVehicle ;
8612: LD_ADDR_VAR 0 2
8616: PUSH
8617: LD_VAR 0 2
8621: PUSH
8622: CALL_OW 45
8626: UNION
8627: ST_TO_ADDR
// end ;
8628: GO 8509
8630: POP
8631: POP
// end ; 4 :
8632: GO 9257
8634: LD_INT 4
8636: DOUBLE
8637: EQUAL
8638: IFTRUE 8642
8640: GO 9256
8642: POP
// begin uc_nation := 3 ;
8643: LD_ADDR_OWVAR 21
8647: PUSH
8648: LD_INT 3
8650: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8651: LD_ADDR_VAR 0 3
8655: PUSH
8656: DOUBLE
8657: LD_INT 1
8659: DEC
8660: ST_TO_ADDR
8661: LD_INT 6
8663: PUSH
8664: LD_INT 8
8666: PUSH
8667: LD_INT 9
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: LIST
8674: PUSH
8675: LD_OWVAR 67
8679: ARRAY
8680: PUSH
8681: FOR_TO
8682: IFFALSE 8802
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8684: LD_INT 22
8686: PUSH
8687: LD_INT 24
8689: PUSH
8690: LD_INT 24
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: LIST
8697: PUSH
8698: LD_VAR 0 3
8702: PUSH
8703: LD_INT 3
8705: MOD
8706: PUSH
8707: LD_INT 1
8709: PLUS
8710: ARRAY
8711: PPUSH
8712: LD_INT 1
8714: PUSH
8715: LD_INT 3
8717: PUSH
8718: EMPTY
8719: LIST
8720: LIST
8721: PUSH
8722: LD_INT 1
8724: PPUSH
8725: LD_INT 2
8727: PPUSH
8728: CALL_OW 12
8732: ARRAY
8733: PPUSH
8734: LD_INT 3
8736: PPUSH
8737: LD_INT 45
8739: PUSH
8740: LD_INT 47
8742: PUSH
8743: LD_INT 47
8745: PUSH
8746: LD_INT 45
8748: PUSH
8749: LD_INT 46
8751: PUSH
8752: LD_INT 46
8754: PUSH
8755: EMPTY
8756: LIST
8757: LIST
8758: LIST
8759: LIST
8760: LIST
8761: LIST
8762: PUSH
8763: LD_VAR 0 3
8767: PUSH
8768: LD_INT 6
8770: MOD
8771: PUSH
8772: LD_INT 1
8774: PLUS
8775: ARRAY
8776: PPUSH
8777: LD_INT 80
8779: PPUSH
8780: CALL 70486 0 5
// result := result union CreateVehicle ;
8784: LD_ADDR_VAR 0 2
8788: PUSH
8789: LD_VAR 0 2
8793: PUSH
8794: CALL_OW 45
8798: UNION
8799: ST_TO_ADDR
// end ;
8800: GO 8681
8802: POP
8803: POP
// if not KappaStatus then
8804: LD_EXP 2
8808: NOT
8809: IFFALSE 9044
// begin uc_nation := 1 ;
8811: LD_ADDR_OWVAR 21
8815: PUSH
8816: LD_INT 1
8818: ST_TO_ADDR
// for i = 1 to 3 do
8819: LD_ADDR_VAR 0 3
8823: PUSH
8824: DOUBLE
8825: LD_INT 1
8827: DEC
8828: ST_TO_ADDR
8829: LD_INT 3
8831: PUSH
8832: FOR_TO
8833: IFFALSE 8969
// begin j := rand ( 0 , 1 ) ;
8835: LD_ADDR_VAR 0 4
8839: PUSH
8840: LD_INT 0
8842: PPUSH
8843: LD_INT 1
8845: PPUSH
8846: CALL_OW 12
8850: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8851: LD_INT 3
8853: PUSH
8854: LD_INT 5
8856: PUSH
8857: LD_INT 5
8859: PUSH
8860: LD_INT 4
8862: PUSH
8863: EMPTY
8864: LIST
8865: LIST
8866: LIST
8867: LIST
8868: PUSH
8869: LD_VAR 0 4
8873: PUSH
8874: LD_INT 1
8876: PPUSH
8877: LD_INT 3
8879: PPUSH
8880: CALL_OW 12
8884: PLUS
8885: ARRAY
8886: PPUSH
8887: LD_INT 1
8889: PUSH
8890: LD_INT 3
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: PUSH
8897: LD_INT 1
8899: PPUSH
8900: LD_INT 2
8902: PPUSH
8903: CALL_OW 12
8907: ARRAY
8908: PPUSH
8909: LD_INT 3
8911: PPUSH
8912: LD_INT 9
8914: PUSH
8915: LD_INT 7
8917: PUSH
8918: LD_INT 6
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: LIST
8925: PUSH
8926: LD_VAR 0 4
8930: PUSH
8931: LD_INT 1
8933: PPUSH
8934: LD_INT 2
8936: PPUSH
8937: CALL_OW 12
8941: PLUS
8942: ARRAY
8943: PPUSH
8944: LD_INT 85
8946: PPUSH
8947: CALL 70486 0 5
// result := result union CreateVehicle ;
8951: LD_ADDR_VAR 0 2
8955: PUSH
8956: LD_VAR 0 2
8960: PUSH
8961: CALL_OW 45
8965: UNION
8966: ST_TO_ADDR
// end ;
8967: GO 8832
8969: POP
8970: POP
// if vsevolodFirstAttack then
8971: LD_EXP 24
8975: IFFALSE 9042
// begin vsevolodFirstAttack := false ;
8977: LD_ADDR_EXP 24
8981: PUSH
8982: LD_INT 0
8984: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8985: LD_INT 5
8987: PPUSH
8988: LD_INT 3
8990: PPUSH
8991: LD_INT 1
8993: PPUSH
8994: LD_INT 6
8996: PPUSH
8997: LD_INT 100
8999: PPUSH
9000: CALL 70486 0 5
// sewiVeh := CreateVehicle ;
9004: LD_ADDR_EXP 71
9008: PUSH
9009: CALL_OW 45
9013: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9014: LD_EXP 71
9018: PPUSH
9019: LD_INT 1
9021: PPUSH
9022: CALL_OW 242
// result := result union sewiVeh ;
9026: LD_ADDR_VAR 0 2
9030: PUSH
9031: LD_VAR 0 2
9035: PUSH
9036: LD_EXP 71
9040: UNION
9041: ST_TO_ADDR
// end ; end else
9042: GO 9254
// if vsevolodFirstAttack then
9044: LD_EXP 24
9048: IFFALSE 9254
// begin vsevolodFirstAttack := false ;
9050: LD_ADDR_EXP 24
9054: PUSH
9055: LD_INT 0
9057: ST_TO_ADDR
// uc_nation := 3 ;
9058: LD_ADDR_OWVAR 21
9062: PUSH
9063: LD_INT 3
9065: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9066: LD_ADDR_VAR 0 3
9070: PUSH
9071: DOUBLE
9072: LD_INT 1
9074: DEC
9075: ST_TO_ADDR
9076: LD_INT 2
9078: PUSH
9079: LD_OWVAR 67
9083: PLUS
9084: PUSH
9085: FOR_TO
9086: IFFALSE 9194
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9088: LD_INT 22
9090: PUSH
9091: LD_INT 24
9093: PUSH
9094: LD_INT 24
9096: PUSH
9097: EMPTY
9098: LIST
9099: LIST
9100: LIST
9101: PUSH
9102: LD_VAR 0 3
9106: PUSH
9107: LD_INT 3
9109: MOD
9110: PUSH
9111: LD_INT 1
9113: PLUS
9114: ARRAY
9115: PPUSH
9116: LD_INT 1
9118: PUSH
9119: LD_INT 3
9121: PUSH
9122: EMPTY
9123: LIST
9124: LIST
9125: PUSH
9126: LD_INT 1
9128: PPUSH
9129: LD_INT 2
9131: PPUSH
9132: CALL_OW 12
9136: ARRAY
9137: PPUSH
9138: LD_INT 1
9140: PPUSH
9141: LD_INT 45
9143: PUSH
9144: LD_INT 47
9146: PUSH
9147: LD_INT 47
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: LIST
9154: PUSH
9155: LD_VAR 0 3
9159: PUSH
9160: LD_INT 3
9162: MOD
9163: PUSH
9164: LD_INT 1
9166: PLUS
9167: ARRAY
9168: PPUSH
9169: LD_INT 80
9171: PPUSH
9172: CALL 70486 0 5
// result := result union CreateVehicle ;
9176: LD_ADDR_VAR 0 2
9180: PUSH
9181: LD_VAR 0 2
9185: PUSH
9186: CALL_OW 45
9190: UNION
9191: ST_TO_ADDR
// end ;
9192: GO 9085
9194: POP
9195: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9196: LD_INT 24
9198: PPUSH
9199: LD_INT 3
9201: PPUSH
9202: LD_INT 1
9204: PPUSH
9205: LD_INT 47
9207: PPUSH
9208: LD_INT 100
9210: PPUSH
9211: CALL 70486 0 5
// sewiVeh := CreateVehicle ;
9215: LD_ADDR_EXP 71
9219: PUSH
9220: CALL_OW 45
9224: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9225: LD_EXP 71
9229: PPUSH
9230: LD_INT 6
9232: NEG
9233: PPUSH
9234: CALL_OW 242
// result := result union sewiVeh ;
9238: LD_ADDR_VAR 0 2
9242: PUSH
9243: LD_VAR 0 2
9247: PUSH
9248: LD_EXP 71
9252: UNION
9253: ST_TO_ADDR
// end ; end ; end ;
9254: GO 9257
9256: POP
// end ;
9257: LD_VAR 0 2
9261: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9262: LD_EXP 16
9266: IFFALSE 10107
9268: GO 9270
9270: DISABLE
9271: LD_INT 0
9273: PPUSH
9274: PPUSH
9275: PPUSH
9276: PPUSH
9277: PPUSH
9278: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9279: LD_ADDR_VAR 0 4
9283: PUSH
9284: LD_INT 11
9286: PUSH
9287: LD_INT 12
9289: PUSH
9290: EMPTY
9291: LIST
9292: LIST
9293: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 ] [ Difficulty ] ;
9294: LD_ADDR_VAR 0 3
9298: PUSH
9299: LD_INT 11550
9301: PUSH
9302: LD_INT 10150
9304: PUSH
9305: LD_INT 9800
9307: PUSH
9308: EMPTY
9309: LIST
9310: LIST
9311: LIST
9312: PUSH
9313: LD_OWVAR 67
9317: ARRAY
9318: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9319: LD_ADDR_VAR 0 6
9323: PUSH
9324: LD_INT 70
9326: PUSH
9327: LD_INT 118
9329: PUSH
9330: EMPTY
9331: LIST
9332: LIST
9333: PUSH
9334: LD_INT 78
9336: PUSH
9337: LD_INT 31
9339: PUSH
9340: EMPTY
9341: LIST
9342: LIST
9343: PUSH
9344: EMPTY
9345: LIST
9346: LIST
9347: ST_TO_ADDR
// repeat if missionStage = 2 then
9348: LD_EXP 15
9352: PUSH
9353: LD_INT 2
9355: EQUAL
9356: IFFALSE 9367
// wait ( 1 1$30 ) else
9358: LD_INT 3150
9360: PPUSH
9361: CALL_OW 67
9365: GO 9376
// wait ( time ) ;
9367: LD_VAR 0 3
9371: PPUSH
9372: CALL_OW 67
// if missionStage = 6 then
9376: LD_EXP 15
9380: PUSH
9381: LD_INT 6
9383: EQUAL
9384: IFFALSE 9412
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9386: LD_INT 51
9388: PPUSH
9389: LD_INT 6
9391: PPUSH
9392: LD_INT 2
9394: PPUSH
9395: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9399: LD_INT 57
9401: PPUSH
9402: LD_INT 6
9404: PPUSH
9405: LD_INT 2
9407: PPUSH
9408: CALL_OW 322
// end ; if missionStage = 8 then
9412: LD_EXP 15
9416: PUSH
9417: LD_INT 8
9419: EQUAL
9420: IFFALSE 9448
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9422: LD_INT 52
9424: PPUSH
9425: LD_INT 6
9427: PPUSH
9428: LD_INT 2
9430: PPUSH
9431: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9435: LD_INT 58
9437: PPUSH
9438: LD_INT 6
9440: PPUSH
9441: LD_INT 2
9443: PPUSH
9444: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9448: LD_EXP 15
9452: PUSH
9453: LD_INT 10
9455: EQUAL
9456: PUSH
9457: LD_OWVAR 67
9461: PUSH
9462: LD_INT 1
9464: GREATER
9465: AND
9466: IFFALSE 9494
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9468: LD_INT 53
9470: PPUSH
9471: LD_INT 6
9473: PPUSH
9474: LD_INT 2
9476: PPUSH
9477: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9481: LD_INT 59
9483: PPUSH
9484: LD_INT 6
9486: PPUSH
9487: LD_INT 2
9489: PPUSH
9490: CALL_OW 322
// end ; if activeAttacks then
9494: LD_EXP 16
9498: IFFALSE 10101
// begin if missionStage = 2 then
9500: LD_EXP 15
9504: PUSH
9505: LD_INT 2
9507: EQUAL
9508: IFFALSE 9518
// strength := 1 ;
9510: LD_ADDR_VAR 0 5
9514: PUSH
9515: LD_INT 1
9517: ST_TO_ADDR
// if missionStage > 2 then
9518: LD_EXP 15
9522: PUSH
9523: LD_INT 2
9525: GREATER
9526: IFFALSE 9536
// strength := 2 ;
9528: LD_ADDR_VAR 0 5
9532: PUSH
9533: LD_INT 2
9535: ST_TO_ADDR
// if missionStage > 6 then
9536: LD_EXP 15
9540: PUSH
9541: LD_INT 6
9543: GREATER
9544: IFFALSE 9554
// strength := 3 ;
9546: LD_ADDR_VAR 0 5
9550: PUSH
9551: LD_INT 3
9553: ST_TO_ADDR
// if missionStage > 10 then
9554: LD_EXP 15
9558: PUSH
9559: LD_INT 10
9561: GREATER
9562: IFFALSE 9572
// strength := 4 ;
9564: LD_ADDR_VAR 0 5
9568: PUSH
9569: LD_INT 4
9571: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9572: LD_ADDR_VAR 0 2
9576: PUSH
9577: LD_VAR 0 5
9581: PPUSH
9582: CALL 8127 0 1
9586: ST_TO_ADDR
// for i in tmp do
9587: LD_ADDR_VAR 0 1
9591: PUSH
9592: LD_VAR 0 2
9596: PUSH
9597: FOR_IN
9598: IFFALSE 9781
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9600: LD_VAR 0 1
9604: PPUSH
9605: LD_VAR 0 4
9609: PUSH
9610: LD_INT 1
9612: PPUSH
9613: LD_INT 2
9615: PPUSH
9616: CALL_OW 12
9620: ARRAY
9621: PPUSH
9622: LD_INT 0
9624: PPUSH
9625: CALL_OW 49
// if i = sewiVeh then
9629: LD_VAR 0 1
9633: PUSH
9634: LD_EXP 71
9638: EQUAL
9639: IFFALSE 9676
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9641: LD_ADDR_EXP 70
9645: PUSH
9646: LD_STRING Vsevolod
9648: PPUSH
9649: LD_INT 0
9651: PPUSH
9652: LD_STRING 
9654: PPUSH
9655: CALL 65622 0 3
9659: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9660: LD_EXP 70
9664: PPUSH
9665: LD_VAR 0 1
9669: PPUSH
9670: CALL_OW 52
// end else
9674: GO 9757
// if GetControl ( i ) = control_manual then
9676: LD_VAR 0 1
9680: PPUSH
9681: CALL_OW 263
9685: PUSH
9686: LD_INT 1
9688: EQUAL
9689: IFFALSE 9757
// begin uc_side := 6 ;
9691: LD_ADDR_OWVAR 20
9695: PUSH
9696: LD_INT 6
9698: ST_TO_ADDR
// uc_nation := 3 ;
9699: LD_ADDR_OWVAR 21
9703: PUSH
9704: LD_INT 3
9706: ST_TO_ADDR
// hc_gallery :=  ;
9707: LD_ADDR_OWVAR 33
9711: PUSH
9712: LD_STRING 
9714: ST_TO_ADDR
// hc_name :=  ;
9715: LD_ADDR_OWVAR 26
9719: PUSH
9720: LD_STRING 
9722: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9723: LD_INT 0
9725: PPUSH
9726: LD_INT 3
9728: PPUSH
9729: LD_INT 10
9731: PPUSH
9732: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9736: CALL_OW 44
9740: PPUSH
9741: LD_VAR 0 1
9745: PPUSH
9746: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9750: LD_INT 10
9752: PPUSH
9753: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9757: LD_VAR 0 1
9761: PPUSH
9762: LD_INT 111
9764: PPUSH
9765: LD_INT 197
9767: PPUSH
9768: CALL_OW 111
// wait ( 0 0$2 ) ;
9772: LD_INT 70
9774: PPUSH
9775: CALL_OW 67
// end ;
9779: GO 9597
9781: POP
9782: POP
// repeat wait ( 0 0$1 ) ;
9783: LD_INT 35
9785: PPUSH
9786: CALL_OW 67
// for i in tmp do
9790: LD_ADDR_VAR 0 1
9794: PUSH
9795: LD_VAR 0 2
9799: PUSH
9800: FOR_IN
9801: IFFALSE 10082
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9803: LD_INT 81
9805: PUSH
9806: LD_INT 6
9808: PUSH
9809: EMPTY
9810: LIST
9811: LIST
9812: PUSH
9813: LD_INT 91
9815: PUSH
9816: LD_VAR 0 1
9820: PUSH
9821: LD_INT 12
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: LIST
9828: PUSH
9829: EMPTY
9830: LIST
9831: LIST
9832: PPUSH
9833: CALL_OW 69
9837: IFFALSE 9895
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9839: LD_VAR 0 1
9843: PPUSH
9844: LD_INT 81
9846: PUSH
9847: LD_INT 6
9849: PUSH
9850: EMPTY
9851: LIST
9852: LIST
9853: PUSH
9854: LD_INT 91
9856: PUSH
9857: LD_VAR 0 1
9861: PUSH
9862: LD_INT 12
9864: PUSH
9865: EMPTY
9866: LIST
9867: LIST
9868: LIST
9869: PUSH
9870: EMPTY
9871: LIST
9872: LIST
9873: PPUSH
9874: CALL_OW 69
9878: PPUSH
9879: LD_VAR 0 1
9883: PPUSH
9884: CALL_OW 74
9888: PPUSH
9889: CALL_OW 115
9893: GO 10080
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9895: LD_INT 9
9897: PPUSH
9898: LD_INT 81
9900: PUSH
9901: LD_INT 6
9903: PUSH
9904: EMPTY
9905: LIST
9906: LIST
9907: PPUSH
9908: CALL_OW 70
9912: IFFALSE 10046
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9914: LD_VAR 0 1
9918: PPUSH
9919: LD_VAR 0 6
9923: PUSH
9924: LD_INT 1
9926: ARRAY
9927: PUSH
9928: LD_INT 1
9930: ARRAY
9931: PPUSH
9932: LD_VAR 0 6
9936: PUSH
9937: LD_INT 1
9939: ARRAY
9940: PUSH
9941: LD_INT 2
9943: ARRAY
9944: PPUSH
9945: CALL_OW 297
9949: PUSH
9950: LD_INT 10
9952: GREATER
9953: PUSH
9954: LD_VAR 0 1
9958: PPUSH
9959: LD_INT 9
9961: PPUSH
9962: CALL_OW 308
9966: NOT
9967: AND
9968: IFFALSE 10007
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9970: LD_VAR 0 1
9974: PPUSH
9975: LD_VAR 0 6
9979: PUSH
9980: LD_INT 1
9982: ARRAY
9983: PUSH
9984: LD_INT 1
9986: ARRAY
9987: PPUSH
9988: LD_VAR 0 6
9992: PUSH
9993: LD_INT 1
9995: ARRAY
9996: PUSH
9997: LD_INT 2
9999: ARRAY
10000: PPUSH
10001: CALL_OW 114
10005: GO 10044
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
10007: LD_VAR 0 1
10011: PPUSH
10012: LD_INT 9
10014: PPUSH
10015: LD_INT 81
10017: PUSH
10018: LD_INT 6
10020: PUSH
10021: EMPTY
10022: LIST
10023: LIST
10024: PPUSH
10025: CALL_OW 70
10029: PPUSH
10030: LD_VAR 0 1
10034: PPUSH
10035: CALL_OW 74
10039: PPUSH
10040: CALL_OW 115
// end else
10044: GO 10080
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10046: LD_VAR 0 1
10050: PPUSH
10051: LD_INT 81
10053: PUSH
10054: LD_INT 6
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: PPUSH
10061: CALL_OW 69
10065: PPUSH
10066: LD_VAR 0 1
10070: PPUSH
10071: CALL_OW 74
10075: PPUSH
10076: CALL_OW 115
// end ;
10080: GO 9800
10082: POP
10083: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10084: LD_INT 22
10086: PUSH
10087: LD_INT 6
10089: PUSH
10090: EMPTY
10091: LIST
10092: LIST
10093: PPUSH
10094: CALL_OW 69
10098: NOT
10099: IFFALSE 9783
// end ; until russianDestroyed ;
10101: LD_EXP 21
10105: IFFALSE 9348
// end ;
10107: PPOPN 6
10109: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10110: LD_EXP 21
10114: NOT
10115: PUSH
10116: LD_EXP 15
10120: PUSH
10121: LD_INT 6
10123: GREATEREQUAL
10124: AND
10125: PUSH
10126: LD_INT 2
10128: PPUSH
10129: LD_INT 1
10131: PPUSH
10132: CALL 60634 0 2
10136: NOT
10137: AND
10138: IFFALSE 11094
10140: GO 10142
10142: DISABLE
10143: LD_INT 0
10145: PPUSH
10146: PPUSH
10147: PPUSH
10148: PPUSH
// begin enable ;
10149: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10150: LD_INT 22
10152: PUSH
10153: LD_INT 3
10155: PUSH
10156: EMPTY
10157: LIST
10158: LIST
10159: PUSH
10160: LD_INT 30
10162: PUSH
10163: LD_INT 3
10165: PUSH
10166: EMPTY
10167: LIST
10168: LIST
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PPUSH
10174: CALL_OW 69
10178: NOT
10179: IFFALSE 10183
// exit ;
10181: GO 11094
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10183: LD_ADDR_VAR 0 4
10187: PUSH
10188: LD_INT 22
10190: PUSH
10191: LD_INT 3
10193: PUSH
10194: EMPTY
10195: LIST
10196: LIST
10197: PUSH
10198: LD_INT 30
10200: PUSH
10201: LD_INT 34
10203: PUSH
10204: EMPTY
10205: LIST
10206: LIST
10207: PUSH
10208: EMPTY
10209: LIST
10210: LIST
10211: PPUSH
10212: CALL_OW 69
10216: ST_TO_ADDR
// if Prob ( 40 ) then
10217: LD_INT 40
10219: PPUSH
10220: CALL_OW 13
10224: IFFALSE 10351
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10226: LD_INT 2
10228: PPUSH
10229: LD_INT 22
10231: PUSH
10232: LD_INT 3
10234: PUSH
10235: LD_INT 3
10237: PUSH
10238: LD_INT 49
10240: PUSH
10241: EMPTY
10242: LIST
10243: LIST
10244: LIST
10245: LIST
10246: PUSH
10247: LD_INT 22
10249: PUSH
10250: LD_INT 3
10252: PUSH
10253: LD_INT 3
10255: PUSH
10256: LD_INT 49
10258: PUSH
10259: EMPTY
10260: LIST
10261: LIST
10262: LIST
10263: LIST
10264: PUSH
10265: LD_INT 22
10267: PUSH
10268: LD_INT 3
10270: PUSH
10271: LD_INT 3
10273: PUSH
10274: LD_INT 49
10276: PUSH
10277: EMPTY
10278: LIST
10279: LIST
10280: LIST
10281: LIST
10282: PUSH
10283: LD_INT 24
10285: PUSH
10286: LD_INT 3
10288: PUSH
10289: LD_INT 3
10291: PUSH
10292: LD_INT 46
10294: PUSH
10295: EMPTY
10296: LIST
10297: LIST
10298: LIST
10299: LIST
10300: PUSH
10301: LD_INT 24
10303: PUSH
10304: LD_INT 3
10306: PUSH
10307: LD_INT 3
10309: PUSH
10310: LD_INT 46
10312: PUSH
10313: EMPTY
10314: LIST
10315: LIST
10316: LIST
10317: LIST
10318: PUSH
10319: LD_INT 24
10321: PUSH
10322: LD_INT 3
10324: PUSH
10325: LD_INT 3
10327: PUSH
10328: LD_INT 46
10330: PUSH
10331: EMPTY
10332: LIST
10333: LIST
10334: LIST
10335: LIST
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: PPUSH
10345: CALL 59216 0 2
// end else
10349: GO 10474
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10351: LD_INT 2
10353: PPUSH
10354: LD_INT 24
10356: PUSH
10357: LD_INT 3
10359: PUSH
10360: LD_INT 3
10362: PUSH
10363: LD_INT 47
10365: PUSH
10366: EMPTY
10367: LIST
10368: LIST
10369: LIST
10370: LIST
10371: PUSH
10372: LD_INT 24
10374: PUSH
10375: LD_INT 3
10377: PUSH
10378: LD_INT 3
10380: PUSH
10381: LD_INT 47
10383: PUSH
10384: EMPTY
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: PUSH
10390: LD_INT 24
10392: PUSH
10393: LD_INT 3
10395: PUSH
10396: LD_INT 3
10398: PUSH
10399: LD_INT 47
10401: PUSH
10402: EMPTY
10403: LIST
10404: LIST
10405: LIST
10406: LIST
10407: PUSH
10408: LD_INT 24
10410: PUSH
10411: LD_INT 3
10413: PUSH
10414: LD_INT 3
10416: PUSH
10417: LD_INT 46
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: LIST
10424: LIST
10425: PUSH
10426: LD_INT 24
10428: PUSH
10429: LD_INT 3
10431: PUSH
10432: LD_INT 3
10434: PUSH
10435: LD_INT 46
10437: PUSH
10438: EMPTY
10439: LIST
10440: LIST
10441: LIST
10442: LIST
10443: PUSH
10444: LD_INT 24
10446: PUSH
10447: LD_INT 3
10449: PUSH
10450: LD_INT 3
10452: PUSH
10453: LD_INT 46
10455: PUSH
10456: EMPTY
10457: LIST
10458: LIST
10459: LIST
10460: LIST
10461: PUSH
10462: EMPTY
10463: LIST
10464: LIST
10465: LIST
10466: LIST
10467: LIST
10468: LIST
10469: PPUSH
10470: CALL 59216 0 2
// end ; if Difficulty > 1 then
10474: LD_OWVAR 67
10478: PUSH
10479: LD_INT 1
10481: GREATER
10482: IFFALSE 10512
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10484: LD_INT 2
10486: PPUSH
10487: LD_INT 24
10489: PUSH
10490: LD_INT 3
10492: PUSH
10493: LD_INT 3
10495: PUSH
10496: LD_INT 47
10498: PUSH
10499: EMPTY
10500: LIST
10501: LIST
10502: LIST
10503: LIST
10504: PUSH
10505: EMPTY
10506: LIST
10507: PPUSH
10508: CALL 59216 0 2
// repeat wait ( 0 0$1 ) ;
10512: LD_INT 35
10514: PPUSH
10515: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10519: LD_INT 2
10521: PPUSH
10522: LD_INT 1
10524: PPUSH
10525: CALL 60634 0 2
10529: PUSH
10530: LD_INT 6
10532: PUSH
10533: LD_INT 7
10535: PUSH
10536: LD_INT 7
10538: PUSH
10539: EMPTY
10540: LIST
10541: LIST
10542: LIST
10543: PUSH
10544: LD_OWVAR 67
10548: ARRAY
10549: GREATEREQUAL
10550: IFFALSE 10512
// wait ( 0 0$30 ) ;
10552: LD_INT 1050
10554: PPUSH
10555: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10559: LD_ADDR_VAR 0 2
10563: PUSH
10564: LD_INT 2
10566: PPUSH
10567: LD_INT 1
10569: PPUSH
10570: CALL 60634 0 2
10574: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10575: LD_ADDR_EXP 135
10579: PUSH
10580: LD_EXP 135
10584: PPUSH
10585: LD_INT 2
10587: PPUSH
10588: LD_EXP 135
10592: PUSH
10593: LD_INT 2
10595: ARRAY
10596: PUSH
10597: LD_VAR 0 2
10601: DIFF
10602: PPUSH
10603: CALL_OW 1
10607: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10608: LD_ADDR_VAR 0 3
10612: PUSH
10613: LD_INT 0
10615: PPUSH
10616: LD_INT 1
10618: PPUSH
10619: CALL_OW 12
10623: ST_TO_ADDR
// if target then
10624: LD_VAR 0 3
10628: IFFALSE 10756
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10630: LD_ADDR_VAR 0 2
10634: PUSH
10635: LD_VAR 0 2
10639: PPUSH
10640: LD_INT 24
10642: PUSH
10643: LD_INT 250
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: PPUSH
10650: CALL_OW 72
10654: ST_TO_ADDR
// for i in tmp do
10655: LD_ADDR_VAR 0 1
10659: PUSH
10660: LD_VAR 0 2
10664: PUSH
10665: FOR_IN
10666: IFFALSE 10706
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10668: LD_VAR 0 1
10672: PPUSH
10673: LD_INT 139
10675: PPUSH
10676: LD_INT 89
10678: PPUSH
10679: CALL_OW 297
10683: PUSH
10684: LD_INT 9
10686: GREATER
10687: IFFALSE 10704
// ComMoveXY ( i , 139 , 89 ) ;
10689: LD_VAR 0 1
10693: PPUSH
10694: LD_INT 139
10696: PPUSH
10697: LD_INT 89
10699: PPUSH
10700: CALL_OW 111
10704: GO 10665
10706: POP
10707: POP
// wait ( 0 0$1 ) ;
10708: LD_INT 35
10710: PPUSH
10711: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10715: LD_VAR 0 2
10719: PPUSH
10720: LD_INT 92
10722: PUSH
10723: LD_INT 139
10725: PUSH
10726: LD_INT 89
10728: PUSH
10729: LD_INT 9
10731: PUSH
10732: EMPTY
10733: LIST
10734: LIST
10735: LIST
10736: LIST
10737: PPUSH
10738: CALL_OW 72
10742: PUSH
10743: LD_VAR 0 2
10747: PUSH
10748: LD_INT 1
10750: MINUS
10751: GREATEREQUAL
10752: IFFALSE 10630
// end else
10754: GO 10898
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10756: LD_VAR 0 2
10760: PPUSH
10761: LD_VAR 0 4
10765: PUSH
10766: LD_INT 1
10768: ARRAY
10769: PPUSH
10770: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10774: LD_ADDR_VAR 0 2
10778: PUSH
10779: LD_VAR 0 2
10783: PPUSH
10784: LD_INT 24
10786: PUSH
10787: LD_INT 250
10789: PUSH
10790: EMPTY
10791: LIST
10792: LIST
10793: PPUSH
10794: CALL_OW 72
10798: ST_TO_ADDR
// for i in tmp do
10799: LD_ADDR_VAR 0 1
10803: PUSH
10804: LD_VAR 0 2
10808: PUSH
10809: FOR_IN
10810: IFFALSE 10850
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10812: LD_VAR 0 1
10816: PPUSH
10817: LD_INT 124
10819: PPUSH
10820: LD_INT 139
10822: PPUSH
10823: CALL_OW 297
10827: PUSH
10828: LD_INT 9
10830: GREATER
10831: IFFALSE 10848
// ComMoveXY ( i , 124 , 139 ) ;
10833: LD_VAR 0 1
10837: PPUSH
10838: LD_INT 124
10840: PPUSH
10841: LD_INT 139
10843: PPUSH
10844: CALL_OW 111
10848: GO 10809
10850: POP
10851: POP
// wait ( 0 0$1 ) ;
10852: LD_INT 35
10854: PPUSH
10855: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10859: LD_VAR 0 2
10863: PPUSH
10864: LD_INT 92
10866: PUSH
10867: LD_INT 124
10869: PUSH
10870: LD_INT 139
10872: PUSH
10873: LD_INT 9
10875: PUSH
10876: EMPTY
10877: LIST
10878: LIST
10879: LIST
10880: LIST
10881: PPUSH
10882: CALL_OW 72
10886: PUSH
10887: LD_VAR 0 2
10891: PUSH
10892: LD_INT 1
10894: MINUS
10895: GREATEREQUAL
10896: IFFALSE 10774
// end ; repeat wait ( 0 0$1 ) ;
10898: LD_INT 35
10900: PPUSH
10901: CALL_OW 67
// for i in tmp do
10905: LD_ADDR_VAR 0 1
10909: PUSH
10910: LD_VAR 0 2
10914: PUSH
10915: FOR_IN
10916: IFFALSE 11085
// begin if GetLives ( i ) > 251 then
10918: LD_VAR 0 1
10922: PPUSH
10923: CALL_OW 256
10927: PUSH
10928: LD_INT 251
10930: GREATER
10931: IFFALSE 11056
// begin if GetWeapon ( i ) = ru_time_lapser then
10933: LD_VAR 0 1
10937: PPUSH
10938: CALL_OW 264
10942: PUSH
10943: LD_INT 49
10945: EQUAL
10946: IFFALSE 11002
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10948: LD_VAR 0 1
10952: PPUSH
10953: LD_INT 2
10955: PUSH
10956: LD_INT 22
10958: PUSH
10959: LD_INT 1
10961: PUSH
10962: EMPTY
10963: LIST
10964: LIST
10965: PUSH
10966: LD_INT 22
10968: PUSH
10969: LD_INT 8
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: PUSH
10976: EMPTY
10977: LIST
10978: LIST
10979: LIST
10980: PPUSH
10981: CALL_OW 69
10985: PPUSH
10986: LD_VAR 0 1
10990: PPUSH
10991: CALL_OW 74
10995: PPUSH
10996: CALL_OW 112
11000: GO 11054
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11002: LD_VAR 0 1
11006: PPUSH
11007: LD_INT 2
11009: PUSH
11010: LD_INT 22
11012: PUSH
11013: LD_INT 1
11015: PUSH
11016: EMPTY
11017: LIST
11018: LIST
11019: PUSH
11020: LD_INT 22
11022: PUSH
11023: LD_INT 8
11025: PUSH
11026: EMPTY
11027: LIST
11028: LIST
11029: PUSH
11030: EMPTY
11031: LIST
11032: LIST
11033: LIST
11034: PPUSH
11035: CALL_OW 69
11039: PPUSH
11040: LD_VAR 0 1
11044: PPUSH
11045: CALL_OW 74
11049: PPUSH
11050: CALL_OW 115
// end else
11054: GO 11083
// if IsDead ( i ) then
11056: LD_VAR 0 1
11060: PPUSH
11061: CALL_OW 301
11065: IFFALSE 11083
// tmp := tmp diff i ;
11067: LD_ADDR_VAR 0 2
11071: PUSH
11072: LD_VAR 0 2
11076: PUSH
11077: LD_VAR 0 1
11081: DIFF
11082: ST_TO_ADDR
// end ;
11083: GO 10915
11085: POP
11086: POP
// until not tmp ;
11087: LD_VAR 0 2
11091: NOT
11092: IFFALSE 10898
// end ; end_of_file
11094: PPOPN 4
11096: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11097: LD_INT 0
11099: PPUSH
11100: PPUSH
11101: PPUSH
11102: PPUSH
11103: PPUSH
11104: PPUSH
// side := 7 ;
11105: LD_ADDR_VAR 0 5
11109: PUSH
11110: LD_INT 7
11112: ST_TO_ADDR
// uc_side := side ;
11113: LD_ADDR_OWVAR 20
11117: PUSH
11118: LD_VAR 0 5
11122: ST_TO_ADDR
// uc_nation := 1 ;
11123: LD_ADDR_OWVAR 21
11127: PUSH
11128: LD_INT 1
11130: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11131: LD_ADDR_VAR 0 2
11135: PUSH
11136: LD_INT 22
11138: PUSH
11139: LD_VAR 0 5
11143: PUSH
11144: EMPTY
11145: LIST
11146: LIST
11147: PUSH
11148: LD_INT 21
11150: PUSH
11151: LD_INT 3
11153: PUSH
11154: EMPTY
11155: LIST
11156: LIST
11157: PUSH
11158: EMPTY
11159: LIST
11160: LIST
11161: PPUSH
11162: CALL_OW 69
11166: PUSH
11167: FOR_IN
11168: IFFALSE 11184
// SetBLevel ( i , 10 ) ;
11170: LD_VAR 0 2
11174: PPUSH
11175: LD_INT 10
11177: PPUSH
11178: CALL_OW 241
11182: GO 11167
11184: POP
11185: POP
// base := GetBase ( al_depot ) ;
11186: LD_ADDR_VAR 0 4
11190: PUSH
11191: LD_INT 2
11193: PPUSH
11194: CALL_OW 274
11198: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11199: LD_ADDR_VAR 0 6
11203: PUSH
11204: LD_INT 22
11206: PUSH
11207: LD_VAR 0 5
11211: PUSH
11212: EMPTY
11213: LIST
11214: LIST
11215: PUSH
11216: LD_INT 30
11218: PUSH
11219: LD_INT 34
11221: PUSH
11222: EMPTY
11223: LIST
11224: LIST
11225: PUSH
11226: EMPTY
11227: LIST
11228: LIST
11229: PPUSH
11230: CALL_OW 69
11234: ST_TO_ADDR
// if teleport then
11235: LD_VAR 0 6
11239: IFFALSE 11260
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11241: LD_VAR 0 6
11245: PUSH
11246: LD_INT 1
11248: ARRAY
11249: PPUSH
11250: LD_INT 262
11252: PPUSH
11253: LD_INT 119
11255: PPUSH
11256: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11260: LD_VAR 0 4
11264: PPUSH
11265: LD_INT 1
11267: PPUSH
11268: LD_INT 19500
11270: PPUSH
11271: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11275: LD_VAR 0 4
11279: PPUSH
11280: LD_INT 2
11282: PPUSH
11283: LD_INT 200
11285: PPUSH
11286: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11290: LD_VAR 0 4
11294: PPUSH
11295: LD_INT 3
11297: PPUSH
11298: LD_INT 650
11300: PPUSH
11301: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11305: LD_ADDR_EXP 74
11309: PUSH
11310: LD_STRING Roth
11312: PPUSH
11313: CALL_OW 25
11317: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11318: LD_ADDR_EXP 75
11322: PUSH
11323: LD_STRING Simms
11325: PPUSH
11326: LD_EXP 1
11330: NOT
11331: PPUSH
11332: LD_STRING 10c_
11334: PPUSH
11335: CALL 65622 0 3
11339: ST_TO_ADDR
// if not Simms then
11340: LD_EXP 75
11344: NOT
11345: IFFALSE 11375
// begin uc_nation := 1 ;
11347: LD_ADDR_OWVAR 21
11351: PUSH
11352: LD_INT 1
11354: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11355: LD_INT 2
11357: PPUSH
11358: LD_INT 10
11360: PPUSH
11361: CALL_OW 384
// Simms := CreateHuman ;
11365: LD_ADDR_EXP 75
11369: PUSH
11370: CALL_OW 44
11374: ST_TO_ADDR
// end ; uc_nation := 3 ;
11375: LD_ADDR_OWVAR 21
11379: PUSH
11380: LD_INT 3
11382: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11383: LD_ADDR_EXP 76
11387: PUSH
11388: LD_STRING Kirilenkova
11390: PPUSH
11391: CALL_OW 25
11395: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11396: LD_ADDR_EXP 90
11400: PUSH
11401: LD_STRING Oblukov
11403: PPUSH
11404: CALL_OW 25
11408: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11409: LD_ADDR_EXP 77
11413: PUSH
11414: LD_STRING Dolgov
11416: PPUSH
11417: CALL_OW 25
11421: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11422: LD_ADDR_EXP 78
11426: PUSH
11427: LD_STRING Petrosyan
11429: PPUSH
11430: CALL_OW 25
11434: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11435: LD_ADDR_EXP 89
11439: PUSH
11440: LD_STRING Scholtze
11442: PPUSH
11443: CALL_OW 25
11447: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11448: LD_ADDR_EXP 88
11452: PUSH
11453: LD_STRING Kapitsova
11455: PPUSH
11456: CALL_OW 25
11460: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11461: LD_ADDR_EXP 79
11465: PUSH
11466: LD_STRING Petrovova
11468: PPUSH
11469: CALL_OW 25
11473: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11474: LD_ADDR_EXP 80
11478: PUSH
11479: LD_STRING Kuzmov
11481: PPUSH
11482: CALL_OW 25
11486: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11487: LD_ADDR_EXP 87
11491: PUSH
11492: LD_STRING Karamazov
11494: PPUSH
11495: CALL_OW 25
11499: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11500: LD_STRING 13_Lipshchin_1
11502: PPUSH
11503: LD_INT 0
11505: PPUSH
11506: CALL_OW 30
11510: IFFALSE 11525
// Lipshchin := NewCharacter ( Lipshchin ) ;
11512: LD_ADDR_EXP 81
11516: PUSH
11517: LD_STRING Lipshchin
11519: PPUSH
11520: CALL_OW 25
11524: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11525: LD_STRING 13_Titov_1
11527: PPUSH
11528: LD_INT 0
11530: PPUSH
11531: CALL_OW 30
11535: IFFALSE 11550
// Titov := NewCharacter ( Titov ) ;
11537: LD_ADDR_EXP 83
11541: PUSH
11542: LD_STRING Titov
11544: PPUSH
11545: CALL_OW 25
11549: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11550: LD_STRING 13_Gnyevko_1
11552: PPUSH
11553: LD_INT 0
11555: PPUSH
11556: CALL_OW 30
11560: IFFALSE 11575
// Gnyevko := NewCharacter ( Gnyevko ) ;
11562: LD_ADDR_EXP 82
11566: PUSH
11567: LD_STRING Gnyevko
11569: PPUSH
11570: CALL_OW 25
11574: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11575: LD_STRING 13_Xavier_1
11577: PPUSH
11578: LD_INT 0
11580: PPUSH
11581: CALL_OW 30
11585: IFFALSE 11600
// Xavier := NewCharacter ( Xavier2 ) ;
11587: LD_ADDR_EXP 84
11591: PUSH
11592: LD_STRING Xavier2
11594: PPUSH
11595: CALL_OW 25
11599: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11600: LD_STRING 13_Belkov_1
11602: PPUSH
11603: LD_INT 0
11605: PPUSH
11606: CALL_OW 30
11610: IFFALSE 11625
// Belkov := NewCharacter ( Belkov ) ;
11612: LD_ADDR_EXP 85
11616: PUSH
11617: LD_STRING Belkov
11619: PPUSH
11620: CALL_OW 25
11624: ST_TO_ADDR
// if not BurlakStatus then
11625: LD_EXP 9
11629: NOT
11630: IFFALSE 11645
// Burlak = NewCharacter ( Burlak ) ;
11632: LD_ADDR_EXP 86
11636: PUSH
11637: LD_STRING Burlak
11639: PPUSH
11640: CALL_OW 25
11644: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11645: LD_ADDR_VAR 0 3
11649: PUSH
11650: LD_EXP 74
11654: PUSH
11655: LD_EXP 76
11659: PUSH
11660: LD_EXP 90
11664: PUSH
11665: LD_EXP 77
11669: PUSH
11670: LD_EXP 78
11674: PUSH
11675: LD_EXP 89
11679: PUSH
11680: LD_EXP 88
11684: PUSH
11685: LD_EXP 79
11689: PUSH
11690: LD_EXP 80
11694: PUSH
11695: LD_EXP 87
11699: PUSH
11700: EMPTY
11701: LIST
11702: LIST
11703: LIST
11704: LIST
11705: LIST
11706: LIST
11707: LIST
11708: LIST
11709: LIST
11710: LIST
11711: ST_TO_ADDR
// if Simms then
11712: LD_EXP 75
11716: IFFALSE 11734
// tmp := tmp ^ Simms ;
11718: LD_ADDR_VAR 0 3
11722: PUSH
11723: LD_VAR 0 3
11727: PUSH
11728: LD_EXP 75
11732: ADD
11733: ST_TO_ADDR
// if Titov then
11734: LD_EXP 83
11738: IFFALSE 11756
// tmp := tmp ^ Titov ;
11740: LD_ADDR_VAR 0 3
11744: PUSH
11745: LD_VAR 0 3
11749: PUSH
11750: LD_EXP 83
11754: ADD
11755: ST_TO_ADDR
// if Lipshchin then
11756: LD_EXP 81
11760: IFFALSE 11778
// tmp := tmp ^ Lipshchin ;
11762: LD_ADDR_VAR 0 3
11766: PUSH
11767: LD_VAR 0 3
11771: PUSH
11772: LD_EXP 81
11776: ADD
11777: ST_TO_ADDR
// if Gnyevko then
11778: LD_EXP 82
11782: IFFALSE 11800
// tmp := tmp ^ Gnyevko ;
11784: LD_ADDR_VAR 0 3
11788: PUSH
11789: LD_VAR 0 3
11793: PUSH
11794: LD_EXP 82
11798: ADD
11799: ST_TO_ADDR
// if Xavier then
11800: LD_EXP 84
11804: IFFALSE 11822
// tmp := tmp ^ Xavier ;
11806: LD_ADDR_VAR 0 3
11810: PUSH
11811: LD_VAR 0 3
11815: PUSH
11816: LD_EXP 84
11820: ADD
11821: ST_TO_ADDR
// if Belkov then
11822: LD_EXP 85
11826: IFFALSE 11844
// tmp := tmp ^ Belkov ;
11828: LD_ADDR_VAR 0 3
11832: PUSH
11833: LD_VAR 0 3
11837: PUSH
11838: LD_EXP 85
11842: ADD
11843: ST_TO_ADDR
// if Burlak then
11844: LD_EXP 86
11848: IFFALSE 11866
// tmp := tmp ^ Burlak ;
11850: LD_ADDR_VAR 0 3
11854: PUSH
11855: LD_VAR 0 3
11859: PUSH
11860: LD_EXP 86
11864: ADD
11865: ST_TO_ADDR
// for i = 1 to 11 do
11866: LD_ADDR_VAR 0 2
11870: PUSH
11871: DOUBLE
11872: LD_INT 1
11874: DEC
11875: ST_TO_ADDR
11876: LD_INT 11
11878: PUSH
11879: FOR_TO
11880: IFFALSE 11946
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11882: LD_ADDR_OWVAR 21
11886: PUSH
11887: LD_INT 1
11889: PUSH
11890: LD_INT 3
11892: PUSH
11893: EMPTY
11894: LIST
11895: LIST
11896: PUSH
11897: LD_INT 1
11899: PPUSH
11900: LD_INT 2
11902: PPUSH
11903: CALL_OW 12
11907: ARRAY
11908: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11909: LD_INT 0
11911: PPUSH
11912: LD_VAR 0 2
11916: PUSH
11917: LD_INT 2
11919: DIV
11920: PPUSH
11921: LD_INT 10
11923: PPUSH
11924: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11928: LD_ADDR_VAR 0 3
11932: PUSH
11933: LD_VAR 0 3
11937: PUSH
11938: CALL_OW 44
11942: ADD
11943: ST_TO_ADDR
// end ;
11944: GO 11879
11946: POP
11947: POP
// for i in tmp do
11948: LD_ADDR_VAR 0 2
11952: PUSH
11953: LD_VAR 0 3
11957: PUSH
11958: FOR_IN
11959: IFFALSE 11984
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11961: LD_VAR 0 2
11965: PPUSH
11966: LD_INT 260
11968: PPUSH
11969: LD_INT 235
11971: PPUSH
11972: LD_INT 8
11974: PPUSH
11975: LD_INT 0
11977: PPUSH
11978: CALL_OW 50
11982: GO 11958
11984: POP
11985: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11986: LD_ADDR_EXP 116
11990: PUSH
11991: LD_EXP 116
11995: PPUSH
11996: LD_INT 1
11998: PPUSH
11999: LD_INT 22
12001: PUSH
12002: LD_VAR 0 5
12006: PUSH
12007: EMPTY
12008: LIST
12009: LIST
12010: PUSH
12011: LD_INT 3
12013: PUSH
12014: LD_INT 21
12016: PUSH
12017: LD_INT 2
12019: PUSH
12020: EMPTY
12021: LIST
12022: LIST
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: EMPTY
12029: LIST
12030: LIST
12031: PPUSH
12032: CALL_OW 69
12036: PUSH
12037: LD_EXP 74
12041: PUSH
12042: LD_EXP 75
12046: PUSH
12047: EMPTY
12048: LIST
12049: LIST
12050: DIFF
12051: PPUSH
12052: CALL_OW 1
12056: ST_TO_ADDR
// uc_side := 0 ;
12057: LD_ADDR_OWVAR 20
12061: PUSH
12062: LD_INT 0
12064: ST_TO_ADDR
// uc_nation := 0 ;
12065: LD_ADDR_OWVAR 21
12069: PUSH
12070: LD_INT 0
12072: ST_TO_ADDR
// for i = 1 to 5 do
12073: LD_ADDR_VAR 0 2
12077: PUSH
12078: DOUBLE
12079: LD_INT 1
12081: DEC
12082: ST_TO_ADDR
12083: LD_INT 5
12085: PUSH
12086: FOR_TO
12087: IFFALSE 12124
// begin InitHc ;
12089: CALL_OW 19
// hc_class := class_apeman ;
12093: LD_ADDR_OWVAR 28
12097: PUSH
12098: LD_INT 12
12100: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12101: CALL_OW 44
12105: PPUSH
12106: LD_INT 299
12108: PPUSH
12109: LD_INT 229
12111: PPUSH
12112: LD_INT 10
12114: PPUSH
12115: LD_INT 0
12117: PPUSH
12118: CALL_OW 50
// end ;
12122: GO 12086
12124: POP
12125: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12126: LD_EXP 74
12130: PPUSH
12131: LD_INT 259
12133: PPUSH
12134: LD_INT 235
12136: PPUSH
12137: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12141: LD_EXP 74
12145: PPUSH
12146: LD_INT 262
12148: PPUSH
12149: LD_INT 235
12151: PPUSH
12152: CALL_OW 178
// if Simms then
12156: LD_EXP 75
12160: IFFALSE 12191
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12162: LD_EXP 75
12166: PPUSH
12167: LD_INT 262
12169: PPUSH
12170: LD_INT 235
12172: PPUSH
12173: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12177: LD_EXP 75
12181: PPUSH
12182: LD_EXP 74
12186: PPUSH
12187: CALL_OW 179
// end ; end ;
12191: LD_VAR 0 1
12195: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12196: LD_EXP 31
12200: PUSH
12201: LD_EXP 23
12205: NOT
12206: AND
12207: IFFALSE 12383
12209: GO 12211
12211: DISABLE
12212: LD_INT 0
12214: PPUSH
12215: PPUSH
12216: PPUSH
// begin enable ;
12217: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12218: LD_ADDR_VAR 0 2
12222: PUSH
12223: LD_INT 81
12225: PUSH
12226: LD_INT 7
12228: PUSH
12229: EMPTY
12230: LIST
12231: LIST
12232: PUSH
12233: LD_INT 2
12235: PUSH
12236: LD_INT 32
12238: PUSH
12239: LD_INT 3
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: PUSH
12246: LD_INT 30
12248: PUSH
12249: LD_INT 30
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: PUSH
12256: LD_INT 30
12258: PUSH
12259: LD_INT 28
12261: PUSH
12262: EMPTY
12263: LIST
12264: LIST
12265: PUSH
12266: LD_INT 34
12268: PUSH
12269: LD_INT 49
12271: PUSH
12272: EMPTY
12273: LIST
12274: LIST
12275: PUSH
12276: LD_INT 34
12278: PUSH
12279: LD_INT 10
12281: PUSH
12282: EMPTY
12283: LIST
12284: LIST
12285: PUSH
12286: LD_INT 34
12288: PUSH
12289: LD_INT 8
12291: PUSH
12292: EMPTY
12293: LIST
12294: LIST
12295: PUSH
12296: EMPTY
12297: LIST
12298: LIST
12299: LIST
12300: LIST
12301: LIST
12302: LIST
12303: LIST
12304: PUSH
12305: EMPTY
12306: LIST
12307: LIST
12308: PPUSH
12309: CALL_OW 69
12313: ST_TO_ADDR
// if not tmp then
12314: LD_VAR 0 2
12318: NOT
12319: IFFALSE 12323
// exit ;
12321: GO 12383
// target := tmp [ rand ( 1 , tmp ) ] ;
12323: LD_ADDR_VAR 0 3
12327: PUSH
12328: LD_VAR 0 2
12332: PUSH
12333: LD_INT 1
12335: PPUSH
12336: LD_VAR 0 2
12340: PPUSH
12341: CALL_OW 12
12345: ARRAY
12346: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12347: LD_VAR 0 3
12351: PPUSH
12352: CALL_OW 255
12356: PUSH
12357: LD_INT 1
12359: EQUAL
12360: IFFALSE 12371
// CenterNowOnUnits ( target ) ;
12362: LD_VAR 0 3
12366: PPUSH
12367: CALL_OW 87
// SetLives ( target , 0 ) ;
12371: LD_VAR 0 3
12375: PPUSH
12376: LD_INT 0
12378: PPUSH
12379: CALL_OW 234
// end ;
12383: PPOPN 3
12385: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12386: LD_EXP 23
12390: NOT
12391: PUSH
12392: LD_EXP 31
12396: AND
12397: IFFALSE 12919
12399: GO 12401
12401: DISABLE
12402: LD_INT 0
12404: PPUSH
12405: PPUSH
12406: PPUSH
// begin uc_side := 7 ;
12407: LD_ADDR_OWVAR 20
12411: PUSH
12412: LD_INT 7
12414: ST_TO_ADDR
// uc_nation := 1 ;
12415: LD_ADDR_OWVAR 21
12419: PUSH
12420: LD_INT 1
12422: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12423: LD_ADDR_VAR 0 3
12427: PUSH
12428: LD_INT 125
12430: PUSH
12431: LD_INT 163
12433: PUSH
12434: EMPTY
12435: LIST
12436: LIST
12437: PUSH
12438: LD_INT 185
12440: PUSH
12441: LD_INT 168
12443: PUSH
12444: EMPTY
12445: LIST
12446: LIST
12447: PUSH
12448: LD_INT 111
12450: PUSH
12451: LD_INT 97
12453: PUSH
12454: EMPTY
12455: LIST
12456: LIST
12457: PUSH
12458: EMPTY
12459: LIST
12460: LIST
12461: LIST
12462: PPUSH
12463: CALL 102464 0 1
12467: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12468: LD_ADDR_EXP 91
12472: PUSH
12473: EMPTY
12474: ST_TO_ADDR
// for i = 1 to Difficulty do
12475: LD_ADDR_VAR 0 1
12479: PUSH
12480: DOUBLE
12481: LD_INT 1
12483: DEC
12484: ST_TO_ADDR
12485: LD_OWVAR 67
12489: PUSH
12490: FOR_TO
12491: IFFALSE 12649
// begin InitHc ;
12493: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12497: LD_INT 0
12499: PPUSH
12500: LD_INT 8
12502: PPUSH
12503: CALL_OW 381
// un := CreateHuman ;
12507: LD_ADDR_VAR 0 2
12511: PUSH
12512: CALL_OW 44
12516: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12517: LD_VAR 0 2
12521: PPUSH
12522: LD_INT 258
12524: PPUSH
12525: LD_INT 267
12527: PPUSH
12528: LD_INT 4
12530: PPUSH
12531: LD_INT 0
12533: PPUSH
12534: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12538: LD_ADDR_EXP 91
12542: PUSH
12543: LD_EXP 91
12547: PUSH
12548: LD_VAR 0 2
12552: UNION
12553: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12554: LD_VAR 0 2
12558: PPUSH
12559: LD_VAR 0 3
12563: PUSH
12564: LD_VAR 0 1
12568: ARRAY
12569: PUSH
12570: LD_INT 1
12572: ARRAY
12573: PPUSH
12574: LD_VAR 0 3
12578: PUSH
12579: LD_VAR 0 1
12583: ARRAY
12584: PUSH
12585: LD_INT 2
12587: ARRAY
12588: PPUSH
12589: LD_INT 4
12591: PPUSH
12592: LD_INT 1
12594: PPUSH
12595: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12599: LD_VAR 0 2
12603: PPUSH
12604: LD_VAR 0 3
12608: PUSH
12609: LD_VAR 0 1
12613: ARRAY
12614: PUSH
12615: LD_INT 1
12617: ARRAY
12618: PPUSH
12619: LD_VAR 0 3
12623: PUSH
12624: LD_VAR 0 1
12628: ARRAY
12629: PUSH
12630: LD_INT 2
12632: ARRAY
12633: PPUSH
12634: CALL_OW 171
// AddComInvisible ( un ) ;
12638: LD_VAR 0 2
12642: PPUSH
12643: CALL_OW 212
// end ;
12647: GO 12490
12649: POP
12650: POP
// repeat wait ( 0 0$20 ) ;
12651: LD_INT 700
12653: PPUSH
12654: CALL_OW 67
// for i in allianceSpecialForce do
12658: LD_ADDR_VAR 0 1
12662: PUSH
12663: LD_EXP 91
12667: PUSH
12668: FOR_IN
12669: IFFALSE 12904
// begin if IsInvisible ( i ) then
12671: LD_VAR 0 1
12675: PPUSH
12676: CALL_OW 571
12680: IFFALSE 12873
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12682: LD_ADDR_VAR 0 3
12686: PUSH
12687: LD_INT 22
12689: PUSH
12690: LD_INT 1
12692: PUSH
12693: EMPTY
12694: LIST
12695: LIST
12696: PUSH
12697: LD_INT 50
12699: PUSH
12700: EMPTY
12701: LIST
12702: PUSH
12703: LD_INT 56
12705: PUSH
12706: EMPTY
12707: LIST
12708: PUSH
12709: LD_INT 91
12711: PUSH
12712: LD_VAR 0 1
12716: PUSH
12717: LD_INT 25
12719: PUSH
12720: LD_INT 30
12722: PUSH
12723: LD_INT 35
12725: PUSH
12726: EMPTY
12727: LIST
12728: LIST
12729: LIST
12730: PUSH
12731: LD_OWVAR 67
12735: ARRAY
12736: PUSH
12737: EMPTY
12738: LIST
12739: LIST
12740: LIST
12741: PUSH
12742: LD_INT 2
12744: PUSH
12745: LD_INT 25
12747: PUSH
12748: LD_INT 1
12750: PUSH
12751: EMPTY
12752: LIST
12753: LIST
12754: PUSH
12755: LD_INT 25
12757: PUSH
12758: LD_INT 2
12760: PUSH
12761: EMPTY
12762: LIST
12763: LIST
12764: PUSH
12765: LD_INT 25
12767: PUSH
12768: LD_INT 3
12770: PUSH
12771: EMPTY
12772: LIST
12773: LIST
12774: PUSH
12775: LD_INT 25
12777: PUSH
12778: LD_INT 4
12780: PUSH
12781: EMPTY
12782: LIST
12783: LIST
12784: PUSH
12785: LD_INT 25
12787: PUSH
12788: LD_INT 5
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: PUSH
12795: LD_INT 25
12797: PUSH
12798: LD_INT 8
12800: PUSH
12801: EMPTY
12802: LIST
12803: LIST
12804: PUSH
12805: EMPTY
12806: LIST
12807: LIST
12808: LIST
12809: LIST
12810: LIST
12811: LIST
12812: LIST
12813: PUSH
12814: EMPTY
12815: LIST
12816: LIST
12817: LIST
12818: LIST
12819: LIST
12820: PPUSH
12821: CALL_OW 69
12825: ST_TO_ADDR
// if not tmp then
12826: LD_VAR 0 3
12830: NOT
12831: IFFALSE 12835
// continue ;
12833: GO 12668
// if Prob ( 30 * Difficulty ) then
12835: LD_INT 30
12837: PUSH
12838: LD_OWVAR 67
12842: MUL
12843: PPUSH
12844: CALL_OW 13
12848: IFFALSE 12873
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12850: LD_VAR 0 3
12854: PUSH
12855: LD_INT 1
12857: PPUSH
12858: LD_VAR 0 3
12862: PPUSH
12863: CALL_OW 12
12867: ARRAY
12868: PPUSH
12869: CALL 31166 0 1
// end ; if IsDead ( i ) then
12873: LD_VAR 0 1
12877: PPUSH
12878: CALL_OW 301
12882: IFFALSE 12902
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12884: LD_ADDR_EXP 91
12888: PUSH
12889: LD_EXP 91
12893: PUSH
12894: LD_VAR 0 1
12898: DIFF
12899: ST_TO_ADDR
// continue ;
12900: GO 12668
// end ; end ;
12902: GO 12668
12904: POP
12905: POP
// until allianceDestroyed or not allianceSpecialForce ;
12906: LD_EXP 23
12910: PUSH
12911: LD_EXP 91
12915: NOT
12916: OR
12917: IFFALSE 12651
// end ;
12919: PPOPN 3
12921: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12922: LD_EXP 23
12926: NOT
12927: PUSH
12928: LD_EXP 31
12932: AND
12933: IFFALSE 13900
12935: GO 12937
12937: DISABLE
12938: LD_INT 0
12940: PPUSH
12941: PPUSH
12942: PPUSH
12943: PPUSH
// begin enable ;
12944: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12945: LD_INT 22
12947: PUSH
12948: LD_INT 7
12950: PUSH
12951: EMPTY
12952: LIST
12953: LIST
12954: PUSH
12955: LD_INT 30
12957: PUSH
12958: LD_INT 3
12960: PUSH
12961: EMPTY
12962: LIST
12963: LIST
12964: PUSH
12965: EMPTY
12966: LIST
12967: LIST
12968: PPUSH
12969: CALL_OW 69
12973: NOT
12974: IFFALSE 12978
// exit ;
12976: GO 13900
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12978: LD_ADDR_VAR 0 4
12982: PUSH
12983: LD_INT 22
12985: PUSH
12986: LD_INT 7
12988: PUSH
12989: EMPTY
12990: LIST
12991: LIST
12992: PUSH
12993: LD_INT 30
12995: PUSH
12996: LD_INT 34
12998: PUSH
12999: EMPTY
13000: LIST
13001: LIST
13002: PUSH
13003: EMPTY
13004: LIST
13005: LIST
13006: PPUSH
13007: CALL_OW 69
13011: ST_TO_ADDR
// if Prob ( 40 ) then
13012: LD_INT 40
13014: PPUSH
13015: CALL_OW 13
13019: IFFALSE 13146
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
13021: LD_INT 1
13023: PPUSH
13024: LD_INT 5
13026: PUSH
13027: LD_INT 3
13029: PUSH
13030: LD_INT 2
13032: PUSH
13033: LD_INT 6
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: LIST
13040: LIST
13041: PUSH
13042: LD_INT 5
13044: PUSH
13045: LD_INT 3
13047: PUSH
13048: LD_INT 2
13050: PUSH
13051: LD_INT 6
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: LIST
13058: LIST
13059: PUSH
13060: LD_INT 5
13062: PUSH
13063: LD_INT 3
13065: PUSH
13066: LD_INT 2
13068: PUSH
13069: LD_INT 6
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: LIST
13076: LIST
13077: PUSH
13078: LD_INT 24
13080: PUSH
13081: LD_INT 3
13083: PUSH
13084: LD_INT 3
13086: PUSH
13087: LD_INT 45
13089: PUSH
13090: EMPTY
13091: LIST
13092: LIST
13093: LIST
13094: LIST
13095: PUSH
13096: LD_INT 24
13098: PUSH
13099: LD_INT 3
13101: PUSH
13102: LD_INT 3
13104: PUSH
13105: LD_INT 47
13107: PUSH
13108: EMPTY
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: PUSH
13114: LD_INT 24
13116: PUSH
13117: LD_INT 3
13119: PUSH
13120: LD_INT 3
13122: PUSH
13123: LD_INT 45
13125: PUSH
13126: EMPTY
13127: LIST
13128: LIST
13129: LIST
13130: LIST
13131: PUSH
13132: EMPTY
13133: LIST
13134: LIST
13135: LIST
13136: LIST
13137: LIST
13138: LIST
13139: PPUSH
13140: CALL 59216 0 2
// end else
13144: GO 13269
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13146: LD_INT 1
13148: PPUSH
13149: LD_INT 24
13151: PUSH
13152: LD_INT 3
13154: PUSH
13155: LD_INT 3
13157: PUSH
13158: LD_INT 47
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: LIST
13165: LIST
13166: PUSH
13167: LD_INT 24
13169: PUSH
13170: LD_INT 3
13172: PUSH
13173: LD_INT 3
13175: PUSH
13176: LD_INT 47
13178: PUSH
13179: EMPTY
13180: LIST
13181: LIST
13182: LIST
13183: LIST
13184: PUSH
13185: LD_INT 5
13187: PUSH
13188: LD_INT 3
13190: PUSH
13191: LD_INT 2
13193: PUSH
13194: LD_INT 9
13196: PUSH
13197: EMPTY
13198: LIST
13199: LIST
13200: LIST
13201: LIST
13202: PUSH
13203: LD_INT 5
13205: PUSH
13206: LD_INT 3
13208: PUSH
13209: LD_INT 2
13211: PUSH
13212: LD_INT 9
13214: PUSH
13215: EMPTY
13216: LIST
13217: LIST
13218: LIST
13219: LIST
13220: PUSH
13221: LD_INT 24
13223: PUSH
13224: LD_INT 1
13226: PUSH
13227: LD_INT 3
13229: PUSH
13230: LD_INT 45
13232: PUSH
13233: EMPTY
13234: LIST
13235: LIST
13236: LIST
13237: LIST
13238: PUSH
13239: LD_INT 24
13241: PUSH
13242: LD_INT 1
13244: PUSH
13245: LD_INT 3
13247: PUSH
13248: LD_INT 45
13250: PUSH
13251: EMPTY
13252: LIST
13253: LIST
13254: LIST
13255: LIST
13256: PUSH
13257: EMPTY
13258: LIST
13259: LIST
13260: LIST
13261: LIST
13262: LIST
13263: LIST
13264: PPUSH
13265: CALL 59216 0 2
// end ; if Difficulty > 1 then
13269: LD_OWVAR 67
13273: PUSH
13274: LD_INT 1
13276: GREATER
13277: IFFALSE 13307
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13279: LD_INT 1
13281: PPUSH
13282: LD_INT 24
13284: PUSH
13285: LD_INT 3
13287: PUSH
13288: LD_INT 3
13290: PUSH
13291: LD_INT 47
13293: PUSH
13294: EMPTY
13295: LIST
13296: LIST
13297: LIST
13298: LIST
13299: PUSH
13300: EMPTY
13301: LIST
13302: PPUSH
13303: CALL 59216 0 2
// repeat wait ( 0 0$1 ) ;
13307: LD_INT 35
13309: PPUSH
13310: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13314: LD_INT 1
13316: PPUSH
13317: LD_INT 1
13319: PPUSH
13320: CALL 60634 0 2
13324: PUSH
13325: LD_INT 6
13327: PUSH
13328: LD_INT 7
13330: PUSH
13331: LD_INT 7
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: LIST
13338: PUSH
13339: LD_OWVAR 67
13343: ARRAY
13344: GREATEREQUAL
13345: IFFALSE 13307
// wait ( 0 0$40 ) ;
13347: LD_INT 1400
13349: PPUSH
13350: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13354: LD_ADDR_VAR 0 2
13358: PUSH
13359: LD_INT 1
13361: PPUSH
13362: LD_INT 1
13364: PPUSH
13365: CALL 60634 0 2
13369: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13370: LD_ADDR_EXP 135
13374: PUSH
13375: LD_EXP 135
13379: PPUSH
13380: LD_INT 1
13382: PPUSH
13383: LD_EXP 135
13387: PUSH
13388: LD_INT 1
13390: ARRAY
13391: PUSH
13392: LD_VAR 0 2
13396: DIFF
13397: PPUSH
13398: CALL_OW 1
13402: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13403: LD_ADDR_VAR 0 3
13407: PUSH
13408: LD_INT 0
13410: PPUSH
13411: LD_INT 1
13413: PPUSH
13414: CALL_OW 12
13418: ST_TO_ADDR
// if target then
13419: LD_VAR 0 3
13423: IFFALSE 13589
// begin for i in tmp do
13425: LD_ADDR_VAR 0 1
13429: PUSH
13430: LD_VAR 0 2
13434: PUSH
13435: FOR_IN
13436: IFFALSE 13461
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13438: LD_VAR 0 1
13442: PPUSH
13443: LD_INT 179
13445: PPUSH
13446: LD_INT 209
13448: PPUSH
13449: LD_INT 8
13451: PPUSH
13452: LD_INT 1
13454: PPUSH
13455: CALL_OW 483
13459: GO 13435
13461: POP
13462: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13463: LD_ADDR_VAR 0 2
13467: PUSH
13468: LD_VAR 0 2
13472: PPUSH
13473: LD_INT 24
13475: PUSH
13476: LD_INT 250
13478: PUSH
13479: EMPTY
13480: LIST
13481: LIST
13482: PPUSH
13483: CALL_OW 72
13487: ST_TO_ADDR
// for i in tmp do
13488: LD_ADDR_VAR 0 1
13492: PUSH
13493: LD_VAR 0 2
13497: PUSH
13498: FOR_IN
13499: IFFALSE 13539
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13501: LD_VAR 0 1
13505: PPUSH
13506: LD_INT 179
13508: PPUSH
13509: LD_INT 209
13511: PPUSH
13512: CALL_OW 297
13516: PUSH
13517: LD_INT 9
13519: GREATER
13520: IFFALSE 13537
// ComMoveXY ( i , 179 , 209 ) ;
13522: LD_VAR 0 1
13526: PPUSH
13527: LD_INT 179
13529: PPUSH
13530: LD_INT 209
13532: PPUSH
13533: CALL_OW 111
13537: GO 13498
13539: POP
13540: POP
// wait ( 0 0$1 ) ;
13541: LD_INT 35
13543: PPUSH
13544: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13548: LD_VAR 0 2
13552: PPUSH
13553: LD_INT 92
13555: PUSH
13556: LD_INT 179
13558: PUSH
13559: LD_INT 209
13561: PUSH
13562: LD_INT 9
13564: PUSH
13565: EMPTY
13566: LIST
13567: LIST
13568: LIST
13569: LIST
13570: PPUSH
13571: CALL_OW 72
13575: PUSH
13576: LD_VAR 0 2
13580: PUSH
13581: LD_INT 1
13583: MINUS
13584: GREATEREQUAL
13585: IFFALSE 13463
// end else
13587: GO 13751
// begin for i in tmp do
13589: LD_ADDR_VAR 0 1
13593: PUSH
13594: LD_VAR 0 2
13598: PUSH
13599: FOR_IN
13600: IFFALSE 13625
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13602: LD_VAR 0 1
13606: PPUSH
13607: LD_INT 285
13609: PPUSH
13610: LD_INT 163
13612: PPUSH
13613: LD_INT 8
13615: PPUSH
13616: LD_INT 1
13618: PPUSH
13619: CALL_OW 483
13623: GO 13599
13625: POP
13626: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13627: LD_ADDR_VAR 0 2
13631: PUSH
13632: LD_VAR 0 2
13636: PPUSH
13637: LD_INT 24
13639: PUSH
13640: LD_INT 250
13642: PUSH
13643: EMPTY
13644: LIST
13645: LIST
13646: PPUSH
13647: CALL_OW 72
13651: ST_TO_ADDR
// for i in tmp do
13652: LD_ADDR_VAR 0 1
13656: PUSH
13657: LD_VAR 0 2
13661: PUSH
13662: FOR_IN
13663: IFFALSE 13703
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13665: LD_VAR 0 1
13669: PPUSH
13670: LD_INT 285
13672: PPUSH
13673: LD_INT 163
13675: PPUSH
13676: CALL_OW 297
13680: PUSH
13681: LD_INT 9
13683: GREATER
13684: IFFALSE 13701
// ComMoveXY ( i , 285 , 163 ) ;
13686: LD_VAR 0 1
13690: PPUSH
13691: LD_INT 285
13693: PPUSH
13694: LD_INT 163
13696: PPUSH
13697: CALL_OW 111
13701: GO 13662
13703: POP
13704: POP
// wait ( 0 0$1 ) ;
13705: LD_INT 35
13707: PPUSH
13708: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13712: LD_VAR 0 2
13716: PPUSH
13717: LD_INT 92
13719: PUSH
13720: LD_INT 285
13722: PUSH
13723: LD_INT 163
13725: PUSH
13726: LD_INT 9
13728: PUSH
13729: EMPTY
13730: LIST
13731: LIST
13732: LIST
13733: LIST
13734: PPUSH
13735: CALL_OW 72
13739: PUSH
13740: LD_VAR 0 2
13744: PUSH
13745: LD_INT 1
13747: MINUS
13748: GREATEREQUAL
13749: IFFALSE 13627
// end ; repeat wait ( 0 0$1 ) ;
13751: LD_INT 35
13753: PPUSH
13754: CALL_OW 67
// for i in tmp do
13758: LD_ADDR_VAR 0 1
13762: PUSH
13763: LD_VAR 0 2
13767: PUSH
13768: FOR_IN
13769: IFFALSE 13891
// if GetLives ( i ) > 251 then
13771: LD_VAR 0 1
13775: PPUSH
13776: CALL_OW 256
13780: PUSH
13781: LD_INT 251
13783: GREATER
13784: IFFALSE 13873
// begin if GetWeapon ( i ) = ru_time_lapser then
13786: LD_VAR 0 1
13790: PPUSH
13791: CALL_OW 264
13795: PUSH
13796: LD_INT 49
13798: EQUAL
13799: IFFALSE 13837
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13801: LD_VAR 0 1
13805: PPUSH
13806: LD_INT 81
13808: PUSH
13809: LD_INT 7
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: PPUSH
13816: CALL_OW 69
13820: PPUSH
13821: LD_VAR 0 1
13825: PPUSH
13826: CALL_OW 74
13830: PPUSH
13831: CALL_OW 112
13835: GO 13871
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13837: LD_VAR 0 1
13841: PPUSH
13842: LD_INT 81
13844: PUSH
13845: LD_INT 7
13847: PUSH
13848: EMPTY
13849: LIST
13850: LIST
13851: PPUSH
13852: CALL_OW 69
13856: PPUSH
13857: LD_VAR 0 1
13861: PPUSH
13862: CALL_OW 74
13866: PPUSH
13867: CALL_OW 115
// end else
13871: GO 13889
// tmp := tmp diff i ;
13873: LD_ADDR_VAR 0 2
13877: PUSH
13878: LD_VAR 0 2
13882: PUSH
13883: LD_VAR 0 1
13887: DIFF
13888: ST_TO_ADDR
13889: GO 13768
13891: POP
13892: POP
// until not tmp ;
13893: LD_VAR 0 2
13897: NOT
13898: IFFALSE 13751
// end ; end_of_file
13900: PPOPN 4
13902: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13903: LD_INT 0
13905: PPUSH
13906: PPUSH
13907: PPUSH
13908: PPUSH
// missionStage := 13 ;
13909: LD_ADDR_EXP 15
13913: PUSH
13914: LD_INT 13
13916: ST_TO_ADDR
// uc_side := 2 ;
13917: LD_ADDR_OWVAR 20
13921: PUSH
13922: LD_INT 2
13924: ST_TO_ADDR
// uc_nation := 2 ;
13925: LD_ADDR_OWVAR 21
13929: PUSH
13930: LD_INT 2
13932: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13933: LD_ADDR_EXP 92
13937: PUSH
13938: LD_STRING Omar
13940: PPUSH
13941: CALL_OW 25
13945: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13946: LD_EXP 92
13950: PPUSH
13951: LD_INT 4
13953: PPUSH
13954: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13958: LD_EXP 92
13962: PPUSH
13963: LD_INT 242
13965: PPUSH
13966: LD_INT 75
13968: PPUSH
13969: LD_INT 0
13971: PPUSH
13972: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13976: LD_ADDR_EXP 93
13980: PUSH
13981: LD_STRING Heike
13983: PPUSH
13984: CALL_OW 25
13988: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13989: LD_INT 14
13991: PPUSH
13992: LD_INT 3
13994: PPUSH
13995: LD_INT 1
13997: PPUSH
13998: LD_INT 27
14000: PPUSH
14001: LD_INT 100
14003: PPUSH
14004: CALL 70486 0 5
// veh := CreateVehicle ;
14008: LD_ADDR_VAR 0 3
14012: PUSH
14013: CALL_OW 45
14017: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
14018: LD_VAR 0 3
14022: PPUSH
14023: LD_INT 1
14025: PPUSH
14026: CALL_OW 242
// SetDir ( veh , 4 ) ;
14030: LD_VAR 0 3
14034: PPUSH
14035: LD_INT 4
14037: PPUSH
14038: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14042: LD_VAR 0 3
14046: PPUSH
14047: LD_INT 241
14049: PPUSH
14050: LD_INT 72
14052: PPUSH
14053: LD_INT 0
14055: PPUSH
14056: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14060: LD_EXP 93
14064: PPUSH
14065: LD_VAR 0 3
14069: PPUSH
14070: CALL_OW 52
// if KhatamStatus then
14074: LD_EXP 8
14078: IFFALSE 14129
// begin Khatam := NewCharacter ( Khatam ) ;
14080: LD_ADDR_EXP 94
14084: PUSH
14085: LD_STRING Khatam
14087: PPUSH
14088: CALL_OW 25
14092: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14093: LD_EXP 94
14097: PPUSH
14098: LD_INT 245
14100: PPUSH
14101: LD_INT 78
14103: PPUSH
14104: LD_INT 3
14106: PPUSH
14107: LD_INT 0
14109: PPUSH
14110: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14114: LD_EXP 94
14118: PPUSH
14119: LD_INT 4
14121: PPUSH
14122: LD_INT 10
14124: PPUSH
14125: CALL_OW 237
// end ; for i = 1 to Difficulty do
14129: LD_ADDR_VAR 0 2
14133: PUSH
14134: DOUBLE
14135: LD_INT 1
14137: DEC
14138: ST_TO_ADDR
14139: LD_OWVAR 67
14143: PUSH
14144: FOR_TO
14145: IFFALSE 14211
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14147: LD_INT 0
14149: PPUSH
14150: LD_INT 7
14152: PUSH
14153: LD_OWVAR 67
14157: PLUS
14158: PPUSH
14159: CALL_OW 384
// un := CreateHuman ;
14163: LD_ADDR_VAR 0 4
14167: PUSH
14168: CALL_OW 44
14172: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14173: LD_VAR 0 4
14177: PPUSH
14178: LD_INT 28
14180: PUSH
14181: LD_INT 29
14183: PUSH
14184: EMPTY
14185: LIST
14186: LIST
14187: PUSH
14188: LD_VAR 0 2
14192: PUSH
14193: LD_INT 2
14195: MOD
14196: PUSH
14197: LD_INT 1
14199: PLUS
14200: ARRAY
14201: PPUSH
14202: LD_INT 0
14204: PPUSH
14205: CALL_OW 49
// end ;
14209: GO 14144
14211: POP
14212: POP
// for i = 1 to 6 do
14213: LD_ADDR_VAR 0 2
14217: PUSH
14218: DOUBLE
14219: LD_INT 1
14221: DEC
14222: ST_TO_ADDR
14223: LD_INT 6
14225: PUSH
14226: FOR_TO
14227: IFFALSE 14272
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14229: LD_INT 0
14231: PPUSH
14232: LD_INT 7
14234: PUSH
14235: LD_OWVAR 67
14239: PLUS
14240: PPUSH
14241: CALL_OW 381
// un := CreateHuman ;
14245: LD_ADDR_VAR 0 4
14249: PUSH
14250: CALL_OW 44
14254: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14255: LD_VAR 0 4
14259: PPUSH
14260: LD_INT 28
14262: PPUSH
14263: LD_INT 0
14265: PPUSH
14266: CALL_OW 49
// end ;
14270: GO 14226
14272: POP
14273: POP
// for i = 1 to 3 do
14274: LD_ADDR_VAR 0 2
14278: PUSH
14279: DOUBLE
14280: LD_INT 1
14282: DEC
14283: ST_TO_ADDR
14284: LD_INT 3
14286: PUSH
14287: FOR_TO
14288: IFFALSE 14336
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14290: LD_INT 0
14292: PPUSH
14293: LD_INT 8
14295: PPUSH
14296: LD_INT 7
14298: PUSH
14299: LD_OWVAR 67
14303: PLUS
14304: PPUSH
14305: CALL_OW 380
// un := CreateHuman ;
14309: LD_ADDR_VAR 0 4
14313: PUSH
14314: CALL_OW 44
14318: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14319: LD_VAR 0 4
14323: PPUSH
14324: LD_INT 28
14326: PPUSH
14327: LD_INT 0
14329: PPUSH
14330: CALL_OW 49
// end ;
14334: GO 14287
14336: POP
14337: POP
// for i = 1 to 3 do
14338: LD_ADDR_VAR 0 2
14342: PUSH
14343: DOUBLE
14344: LD_INT 1
14346: DEC
14347: ST_TO_ADDR
14348: LD_INT 3
14350: PUSH
14351: FOR_TO
14352: IFFALSE 14442
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14354: LD_INT 14
14356: PPUSH
14357: LD_INT 2
14359: PPUSH
14360: LD_INT 1
14362: PPUSH
14363: LD_INT 28
14365: PPUSH
14366: LD_INT 80
14368: PPUSH
14369: CALL 70486 0 5
// veh := CreateVehicle ;
14373: LD_ADDR_VAR 0 3
14377: PUSH
14378: CALL_OW 45
14382: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14383: LD_VAR 0 3
14387: PPUSH
14388: LD_INT 3
14390: PPUSH
14391: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14395: LD_VAR 0 3
14399: PPUSH
14400: LD_INT 29
14402: PPUSH
14403: LD_INT 0
14405: PPUSH
14406: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14410: LD_INT 0
14412: PPUSH
14413: LD_INT 7
14415: PUSH
14416: LD_OWVAR 67
14420: PLUS
14421: PPUSH
14422: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14426: CALL_OW 44
14430: PPUSH
14431: LD_VAR 0 3
14435: PPUSH
14436: CALL_OW 52
// end ;
14440: GO 14351
14442: POP
14443: POP
// for i = 1 to 5 + Difficulty do
14444: LD_ADDR_VAR 0 2
14448: PUSH
14449: DOUBLE
14450: LD_INT 1
14452: DEC
14453: ST_TO_ADDR
14454: LD_INT 5
14456: PUSH
14457: LD_OWVAR 67
14461: PLUS
14462: PUSH
14463: FOR_TO
14464: IFFALSE 14591
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14466: LD_INT 14
14468: PPUSH
14469: LD_INT 1
14471: PPUSH
14472: LD_INT 3
14474: PPUSH
14475: CALL_OW 12
14479: PPUSH
14480: LD_INT 1
14482: PPUSH
14483: LD_INT 28
14485: PUSH
14486: LD_INT 26
14488: PUSH
14489: LD_INT 27
14491: PUSH
14492: LD_INT 25
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: LIST
14499: LIST
14500: PUSH
14501: LD_VAR 0 2
14505: PUSH
14506: LD_INT 4
14508: MOD
14509: PUSH
14510: LD_INT 1
14512: PLUS
14513: ARRAY
14514: PPUSH
14515: LD_INT 80
14517: PPUSH
14518: CALL 70486 0 5
// veh := CreateVehicle ;
14522: LD_ADDR_VAR 0 3
14526: PUSH
14527: CALL_OW 45
14531: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14532: LD_VAR 0 3
14536: PPUSH
14537: LD_INT 4
14539: PPUSH
14540: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14544: LD_VAR 0 3
14548: PPUSH
14549: LD_INT 28
14551: PPUSH
14552: LD_INT 0
14554: PPUSH
14555: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14559: LD_INT 0
14561: PPUSH
14562: LD_INT 7
14564: PUSH
14565: LD_OWVAR 67
14569: PLUS
14570: PPUSH
14571: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14575: CALL_OW 44
14579: PPUSH
14580: LD_VAR 0 3
14584: PPUSH
14585: CALL_OW 52
// end ;
14589: GO 14463
14591: POP
14592: POP
// for i = 1 to 3 do
14593: LD_ADDR_VAR 0 2
14597: PUSH
14598: DOUBLE
14599: LD_INT 1
14601: DEC
14602: ST_TO_ADDR
14603: LD_INT 3
14605: PUSH
14606: FOR_TO
14607: IFFALSE 14667
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14609: LD_INT 14
14611: PPUSH
14612: LD_INT 3
14614: PPUSH
14615: LD_INT 5
14617: PPUSH
14618: LD_INT 29
14620: PPUSH
14621: LD_INT 80
14623: PPUSH
14624: CALL 70486 0 5
// veh := CreateVehicle ;
14628: LD_ADDR_VAR 0 3
14632: PUSH
14633: CALL_OW 45
14637: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14638: LD_VAR 0 3
14642: PPUSH
14643: LD_INT 4
14645: PPUSH
14646: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14650: LD_VAR 0 3
14654: PPUSH
14655: LD_INT 28
14657: PPUSH
14658: LD_INT 0
14660: PPUSH
14661: CALL_OW 49
// end ;
14665: GO 14606
14667: POP
14668: POP
// end ;
14669: LD_VAR 0 1
14673: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14674: LD_INT 22
14676: PUSH
14677: LD_INT 2
14679: PUSH
14680: EMPTY
14681: LIST
14682: LIST
14683: PPUSH
14684: CALL_OW 69
14688: IFFALSE 14988
14690: GO 14692
14692: DISABLE
14693: LD_INT 0
14695: PPUSH
14696: PPUSH
14697: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14698: LD_ADDR_VAR 0 3
14702: PUSH
14703: LD_INT 22
14705: PUSH
14706: LD_INT 2
14708: PUSH
14709: EMPTY
14710: LIST
14711: LIST
14712: PUSH
14713: LD_INT 25
14715: PUSH
14716: LD_INT 4
14718: PUSH
14719: EMPTY
14720: LIST
14721: LIST
14722: PUSH
14723: EMPTY
14724: LIST
14725: LIST
14726: PPUSH
14727: CALL_OW 69
14731: PUSH
14732: LD_EXP 94
14736: DIFF
14737: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14738: LD_ADDR_VAR 0 2
14742: PUSH
14743: LD_INT 22
14745: PUSH
14746: LD_INT 2
14748: PUSH
14749: EMPTY
14750: LIST
14751: LIST
14752: PPUSH
14753: CALL_OW 69
14757: PUSH
14758: LD_EXP 94
14762: PUSH
14763: LD_VAR 0 3
14767: UNION
14768: DIFF
14769: ST_TO_ADDR
// if Khatam then
14770: LD_EXP 94
14774: IFFALSE 14791
// ComMoveXY ( Khatam , 211 , 92 ) ;
14776: LD_EXP 94
14780: PPUSH
14781: LD_INT 211
14783: PPUSH
14784: LD_INT 92
14786: PPUSH
14787: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14791: LD_INT 197
14793: PPUSH
14794: LD_INT 80
14796: PPUSH
14797: LD_INT 2
14799: PPUSH
14800: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14804: LD_INT 213
14806: PPUSH
14807: LD_INT 90
14809: PPUSH
14810: LD_INT 2
14812: PPUSH
14813: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14817: LD_INT 215
14819: PPUSH
14820: LD_INT 129
14822: PPUSH
14823: LD_INT 2
14825: PPUSH
14826: CALL_OW 441
// if sci then
14830: LD_VAR 0 3
14834: IFFALSE 14855
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14836: LD_VAR 0 3
14840: PUSH
14841: LD_INT 1
14843: ARRAY
14844: PPUSH
14845: LD_INT 197
14847: PPUSH
14848: LD_INT 80
14850: PPUSH
14851: CALL_OW 158
// if sci > 1 then
14855: LD_VAR 0 3
14859: PUSH
14860: LD_INT 1
14862: GREATER
14863: IFFALSE 14884
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14865: LD_VAR 0 3
14869: PUSH
14870: LD_INT 2
14872: ARRAY
14873: PPUSH
14874: LD_INT 213
14876: PPUSH
14877: LD_INT 90
14879: PPUSH
14880: CALL_OW 158
// if sci > 2 then
14884: LD_VAR 0 3
14888: PUSH
14889: LD_INT 2
14891: GREATER
14892: IFFALSE 14913
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14894: LD_VAR 0 3
14898: PUSH
14899: LD_INT 3
14901: ARRAY
14902: PPUSH
14903: LD_INT 215
14905: PPUSH
14906: LD_INT 129
14908: PPUSH
14909: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14913: LD_INT 35
14915: PPUSH
14916: CALL_OW 67
// for i in tmp do
14920: LD_ADDR_VAR 0 1
14924: PUSH
14925: LD_VAR 0 2
14929: PUSH
14930: FOR_IN
14931: IFFALSE 14969
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14933: LD_VAR 0 1
14937: PPUSH
14938: LD_INT 81
14940: PUSH
14941: LD_INT 2
14943: PUSH
14944: EMPTY
14945: LIST
14946: LIST
14947: PPUSH
14948: CALL_OW 69
14952: PPUSH
14953: LD_VAR 0 1
14957: PPUSH
14958: CALL_OW 74
14962: PPUSH
14963: CALL_OW 115
14967: GO 14930
14969: POP
14970: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14971: LD_INT 22
14973: PUSH
14974: LD_INT 2
14976: PUSH
14977: EMPTY
14978: LIST
14979: LIST
14980: PPUSH
14981: CALL_OW 69
14985: NOT
14986: IFFALSE 14913
// end ; end_of_file
14988: PPOPN 3
14990: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14991: LD_INT 0
14993: PPUSH
14994: PPUSH
14995: PPUSH
14996: PPUSH
14997: PPUSH
14998: PPUSH
14999: PPUSH
15000: PPUSH
15001: PPUSH
// Video ( true ) ;
15002: LD_INT 1
15004: PPUSH
15005: CALL 102331 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
15009: LD_ADDR_VAR 0 5
15013: PUSH
15014: LD_INT 7
15016: PPUSH
15017: LD_INT 0
15019: PPUSH
15020: CALL_OW 517
15024: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15025: LD_ADDR_VAR 0 2
15029: PUSH
15030: DOUBLE
15031: LD_INT 1
15033: DEC
15034: ST_TO_ADDR
15035: LD_VAR 0 5
15039: PUSH
15040: LD_INT 1
15042: ARRAY
15043: PUSH
15044: FOR_TO
15045: IFFALSE 15090
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15047: LD_VAR 0 5
15051: PUSH
15052: LD_INT 1
15054: ARRAY
15055: PUSH
15056: LD_VAR 0 2
15060: ARRAY
15061: PPUSH
15062: LD_VAR 0 5
15066: PUSH
15067: LD_INT 2
15069: ARRAY
15070: PUSH
15071: LD_VAR 0 2
15075: ARRAY
15076: PPUSH
15077: LD_INT 1
15079: PPUSH
15080: LD_INT 15
15082: NEG
15083: PPUSH
15084: CALL 102245 0 4
15088: GO 15044
15090: POP
15091: POP
// CenterNowOnUnits ( Powell ) ;
15092: LD_EXP 58
15096: PPUSH
15097: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15101: LD_ADDR_VAR 0 5
15105: PUSH
15106: LD_EXP 56
15110: PUSH
15111: EMPTY
15112: LIST
15113: ST_TO_ADDR
// if GirlNewVeh then
15114: LD_EXP 57
15118: IFFALSE 15136
// tmp := tmp ^ GirlNewVeh ;
15120: LD_ADDR_VAR 0 5
15124: PUSH
15125: LD_VAR 0 5
15129: PUSH
15130: LD_EXP 57
15134: ADD
15135: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15136: LD_VAR 0 5
15140: PPUSH
15141: LD_INT 60
15143: PPUSH
15144: LD_INT 109
15146: PPUSH
15147: CALL_OW 111
// if KappaStatus then
15151: LD_EXP 2
15155: IFFALSE 15207
// begin Say ( JMM , D1nT-JMM-1 ) ;
15157: LD_EXP 39
15161: PPUSH
15162: LD_STRING D1nT-JMM-1
15164: PPUSH
15165: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15169: LD_EXP 58
15173: PPUSH
15174: LD_STRING D1T-Pow-1
15176: PPUSH
15177: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15181: LD_EXP 39
15185: PPUSH
15186: LD_STRING D1T-JMM-2
15188: PPUSH
15189: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15193: LD_EXP 58
15197: PPUSH
15198: LD_STRING D1T-Pow-2
15200: PPUSH
15201: CALL_OW 88
// end else
15205: GO 15413
// if JMMGirlStatus then
15207: LD_EXP 6
15211: IFFALSE 15356
// begin Say ( JMM , D1T-JMM-1 ) ;
15213: LD_EXP 39
15217: PPUSH
15218: LD_STRING D1T-JMM-1
15220: PPUSH
15221: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15225: LD_EXP 58
15229: PPUSH
15230: LD_STRING D1T-Pow-1
15232: PPUSH
15233: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15237: LD_EXP 39
15241: PPUSH
15242: LD_STRING D1T-JMM-3
15244: PPUSH
15245: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15249: LD_EXP 58
15253: PPUSH
15254: LD_STRING D1T-Pow-3
15256: PPUSH
15257: CALL_OW 88
// if JMMGirl then
15261: LD_EXP 7
15265: IFFALSE 15354
// begin case JMMGirl of 1 :
15267: LD_EXP 7
15271: PUSH
15272: LD_INT 1
15274: DOUBLE
15275: EQUAL
15276: IFTRUE 15280
15278: GO 15295
15280: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15281: LD_EXP 40
15285: PPUSH
15286: LD_STRING D1T-Joan-3
15288: PPUSH
15289: CALL_OW 88
15293: GO 15342
15295: LD_INT 2
15297: DOUBLE
15298: EQUAL
15299: IFTRUE 15303
15301: GO 15318
15303: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15304: LD_EXP 42
15308: PPUSH
15309: LD_STRING D1T-Lisa-3
15311: PPUSH
15312: CALL_OW 88
15316: GO 15342
15318: LD_INT 3
15320: DOUBLE
15321: EQUAL
15322: IFTRUE 15326
15324: GO 15341
15326: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15327: LD_EXP 54
15331: PPUSH
15332: LD_STRING D1T-Con-3
15334: PPUSH
15335: CALL_OW 88
15339: GO 15342
15341: POP
// Say ( Powell , D1T-Pow-4 ) ;
15342: LD_EXP 58
15346: PPUSH
15347: LD_STRING D1T-Pow-4
15349: PPUSH
15350: CALL_OW 88
// end ; end else
15354: GO 15413
// if not FastEnd then
15356: LD_EXP 11
15360: NOT
15361: IFFALSE 15389
// begin Say ( JMM , D1T-JMM-4 ) ;
15363: LD_EXP 39
15367: PPUSH
15368: LD_STRING D1T-JMM-4
15370: PPUSH
15371: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15375: LD_EXP 58
15379: PPUSH
15380: LD_STRING D1T-Pow-5
15382: PPUSH
15383: CALL_OW 88
// end else
15387: GO 15413
// begin Say ( JMM , D1nT-JMM-1 ) ;
15389: LD_EXP 39
15393: PPUSH
15394: LD_STRING D1nT-JMM-1
15396: PPUSH
15397: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15401: LD_EXP 58
15405: PPUSH
15406: LD_STRING D1nT-Pow-1
15408: PPUSH
15409: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15413: LD_INT 35
15415: PPUSH
15416: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15420: LD_EXP 56
15424: PPUSH
15425: CALL_OW 314
15429: NOT
15430: IFFALSE 15413
// ComExitVehicle ( JMM ) ;
15432: LD_EXP 39
15436: PPUSH
15437: CALL_OW 121
// wait ( 3 ) ;
15441: LD_INT 3
15443: PPUSH
15444: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15448: LD_EXP 39
15452: PPUSH
15453: LD_INT 60
15455: PPUSH
15456: LD_INT 94
15458: PPUSH
15459: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15463: LD_EXP 39
15467: PPUSH
15468: LD_EXP 58
15472: PPUSH
15473: CALL_OW 179
// if Joan then
15477: LD_EXP 40
15481: IFFALSE 15535
// begin ComExitVehicle ( Joan ) ;
15483: LD_EXP 40
15487: PPUSH
15488: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15492: LD_EXP 40
15496: PPUSH
15497: LD_INT 35
15499: PPUSH
15500: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15504: LD_EXP 40
15508: PPUSH
15509: LD_INT 65
15511: PPUSH
15512: LD_INT 104
15514: PPUSH
15515: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15519: LD_EXP 40
15523: PPUSH
15524: LD_EXP 39
15528: PPUSH
15529: CALL_OW 179
// end else
15533: GO 15669
// if Lisa and JMMGirl = 2 then
15535: LD_EXP 42
15539: PUSH
15540: LD_EXP 7
15544: PUSH
15545: LD_INT 2
15547: EQUAL
15548: AND
15549: IFFALSE 15603
// begin ComExitVehicle ( Lisa ) ;
15551: LD_EXP 42
15555: PPUSH
15556: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15560: LD_EXP 42
15564: PPUSH
15565: LD_INT 35
15567: PPUSH
15568: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15572: LD_EXP 42
15576: PPUSH
15577: LD_INT 65
15579: PPUSH
15580: LD_INT 104
15582: PPUSH
15583: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15587: LD_EXP 42
15591: PPUSH
15592: LD_EXP 39
15596: PPUSH
15597: CALL_OW 179
// end else
15601: GO 15669
// if Connie and JMMGirl = 3 then
15603: LD_EXP 54
15607: PUSH
15608: LD_EXP 7
15612: PUSH
15613: LD_INT 3
15615: EQUAL
15616: AND
15617: IFFALSE 15669
// begin ComExitVehicle ( Connie ) ;
15619: LD_EXP 54
15623: PPUSH
15624: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15628: LD_EXP 54
15632: PPUSH
15633: LD_INT 35
15635: PPUSH
15636: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15640: LD_EXP 54
15644: PPUSH
15645: LD_INT 65
15647: PPUSH
15648: LD_INT 104
15650: PPUSH
15651: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15655: LD_EXP 54
15659: PPUSH
15660: LD_EXP 39
15664: PPUSH
15665: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15669: LD_INT 35
15671: PPUSH
15672: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15676: LD_EXP 39
15680: PPUSH
15681: LD_EXP 58
15685: PPUSH
15686: CALL_OW 296
15690: PUSH
15691: LD_INT 6
15693: LESS
15694: IFFALSE 15669
// wait ( 0 0$0.5 ) ;
15696: LD_INT 18
15698: PPUSH
15699: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15703: LD_EXP 39
15707: PPUSH
15708: LD_STRING D1-JMM-1
15710: PPUSH
15711: CALL_OW 88
// async ;
15715: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15716: LD_EXP 58
15720: PPUSH
15721: LD_STRING D1-Pow-1
15723: PPUSH
15724: CALL_OW 88
// if not dialogue_skipped then
15728: LD_OWVAR 59
15732: NOT
15733: IFFALSE 15742
// wait ( 0 0$2 ) ;
15735: LD_INT 70
15737: PPUSH
15738: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15742: LD_INT 170
15744: PPUSH
15745: LD_INT 99
15747: PPUSH
15748: LD_INT 1
15750: PPUSH
15751: LD_INT 6
15753: NEG
15754: PPUSH
15755: CALL 102245 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15759: LD_INT 174
15761: PPUSH
15762: LD_INT 115
15764: PPUSH
15765: LD_INT 1
15767: PPUSH
15768: LD_INT 6
15770: NEG
15771: PPUSH
15772: CALL 102245 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15776: LD_INT 169
15778: PPUSH
15779: LD_INT 71
15781: PPUSH
15782: LD_INT 1
15784: PPUSH
15785: LD_INT 6
15787: NEG
15788: PPUSH
15789: CALL 102245 0 4
// if not dialogue_skipped then
15793: LD_OWVAR 59
15797: NOT
15798: IFFALSE 15817
// begin CenterOnXY ( 170 , 99 ) ;
15800: LD_INT 170
15802: PPUSH
15803: LD_INT 99
15805: PPUSH
15806: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15810: LD_INT 80
15812: PPUSH
15813: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15817: LD_INT 75
15819: PPUSH
15820: LD_INT 53
15822: PPUSH
15823: LD_INT 1
15825: PPUSH
15826: LD_INT 9
15828: NEG
15829: PPUSH
15830: CALL 102245 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15834: LD_INT 54
15836: PPUSH
15837: LD_INT 42
15839: PPUSH
15840: LD_INT 1
15842: PPUSH
15843: LD_INT 9
15845: NEG
15846: PPUSH
15847: CALL 102245 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15851: LD_INT 62
15853: PPUSH
15854: LD_INT 51
15856: PPUSH
15857: LD_INT 1
15859: PPUSH
15860: LD_INT 9
15862: NEG
15863: PPUSH
15864: CALL 102245 0 4
// if not dialogue_skipped then
15868: LD_OWVAR 59
15872: NOT
15873: IFFALSE 15892
// begin CenterOnXY ( 75 , 53 ) ;
15875: LD_INT 75
15877: PPUSH
15878: LD_INT 53
15880: PPUSH
15881: CALL_OW 84
// wait ( 0 0$4 ) ;
15885: LD_INT 140
15887: PPUSH
15888: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15892: LD_EXP 58
15896: PPUSH
15897: CALL_OW 87
// if not dialogue_skipped then
15901: LD_OWVAR 59
15905: NOT
15906: IFFALSE 15915
// wait ( 0 0$2 ) ;
15908: LD_INT 70
15910: PPUSH
15911: CALL_OW 67
// sync ;
15915: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15916: LD_EXP 39
15920: PPUSH
15921: LD_STRING D1-JMM-2
15923: PPUSH
15924: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15928: LD_EXP 58
15932: PPUSH
15933: LD_STRING D1-Pow-2
15935: PPUSH
15936: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15940: LD_EXP 39
15944: PPUSH
15945: LD_STRING D1-JMM-3
15947: PPUSH
15948: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15952: LD_EXP 58
15956: PPUSH
15957: LD_STRING D1-Pow-3
15959: PPUSH
15960: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15964: LD_EXP 39
15968: PPUSH
15969: LD_STRING D1-JMM-4
15971: PPUSH
15972: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15976: LD_EXP 58
15980: PPUSH
15981: LD_STRING D1-Pow-4
15983: PPUSH
15984: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15988: LD_EXP 39
15992: PPUSH
15993: LD_STRING D1-JMM-5
15995: PPUSH
15996: CALL_OW 88
// async ;
16000: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
16001: LD_EXP 58
16005: PPUSH
16006: LD_STRING D1-Pow-5
16008: PPUSH
16009: CALL_OW 88
// if not dialogue_skipped then
16013: LD_OWVAR 59
16017: NOT
16018: IFFALSE 16027
// wait ( 0 0$3.6 ) ;
16020: LD_INT 126
16022: PPUSH
16023: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16027: LD_INT 134
16029: PPUSH
16030: LD_INT 210
16032: PPUSH
16033: LD_INT 1
16035: PPUSH
16036: LD_INT 11
16038: NEG
16039: PPUSH
16040: CALL 102245 0 4
// if not dialogue_skipped then
16044: LD_OWVAR 59
16048: NOT
16049: IFFALSE 16068
// begin CenterOnXY ( 134 , 210 ) ;
16051: LD_INT 134
16053: PPUSH
16054: LD_INT 210
16056: PPUSH
16057: CALL_OW 84
// wait ( 0 0$2 ) ;
16061: LD_INT 70
16063: PPUSH
16064: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16068: LD_INT 101
16070: PPUSH
16071: LD_INT 159
16073: PPUSH
16074: LD_INT 1
16076: PPUSH
16077: LD_INT 10
16079: NEG
16080: PPUSH
16081: CALL 102245 0 4
// if not dialogue_skipped then
16085: LD_OWVAR 59
16089: NOT
16090: IFFALSE 16109
// begin CenterOnXY ( 101 , 159 ) ;
16092: LD_INT 101
16094: PPUSH
16095: LD_INT 159
16097: PPUSH
16098: CALL_OW 84
// wait ( 0 0$2 ) ;
16102: LD_INT 70
16104: PPUSH
16105: CALL_OW 67
// end ; sync ;
16109: SYNC
// CenterNowOnUnits ( Powell ) ;
16110: LD_EXP 58
16114: PPUSH
16115: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16119: LD_ADDR_VAR 0 6
16123: PUSH
16124: LD_INT 1
16126: PUSH
16127: LD_INT 2
16129: PUSH
16130: LD_INT 3
16132: PUSH
16133: LD_INT 4
16135: PUSH
16136: LD_INT 5
16138: PUSH
16139: LD_INT 6
16141: PUSH
16142: EMPTY
16143: LIST
16144: LIST
16145: LIST
16146: LIST
16147: LIST
16148: LIST
16149: ST_TO_ADDR
// if not dialogue_skipped then
16150: LD_OWVAR 59
16154: NOT
16155: IFFALSE 16324
// begin game_speed := 4 ;
16157: LD_ADDR_OWVAR 65
16161: PUSH
16162: LD_INT 4
16164: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16165: LD_INT 210
16167: PPUSH
16168: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16172: LD_ADDR_VAR 0 7
16176: PUSH
16177: LD_STRING Q1
16179: PPUSH
16180: LD_VAR 0 6
16184: PPUSH
16185: CALL_OW 98
16189: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16190: LD_ADDR_VAR 0 7
16194: PUSH
16195: LD_STRING Q1
16197: PPUSH
16198: LD_VAR 0 6
16202: PPUSH
16203: CALL_OW 98
16207: ST_TO_ADDR
// options = options diff dec ;
16208: LD_ADDR_VAR 0 6
16212: PUSH
16213: LD_VAR 0 6
16217: PUSH
16218: LD_VAR 0 7
16222: DIFF
16223: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16224: LD_VAR 0 7
16228: PPUSH
16229: LD_VAR 0 6
16233: PPUSH
16234: CALL 17796 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16238: LD_VAR 0 7
16242: PUSH
16243: LD_INT 5
16245: PUSH
16246: LD_INT 6
16248: PUSH
16249: EMPTY
16250: LIST
16251: LIST
16252: IN
16253: PUSH
16254: LD_VAR 0 6
16258: PUSH
16259: LD_INT 2
16261: EQUAL
16262: OR
16263: IFFALSE 16190
// if not ( dec in [ 5 , 6 ] ) then
16265: LD_VAR 0 7
16269: PUSH
16270: LD_INT 5
16272: PUSH
16273: LD_INT 6
16275: PUSH
16276: EMPTY
16277: LIST
16278: LIST
16279: IN
16280: NOT
16281: IFFALSE 16324
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16283: LD_ADDR_VAR 0 7
16287: PUSH
16288: LD_STRING Q1a
16290: PPUSH
16291: LD_INT 1
16293: PUSH
16294: LD_INT 2
16296: PUSH
16297: EMPTY
16298: LIST
16299: LIST
16300: PPUSH
16301: CALL_OW 98
16305: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16306: LD_VAR 0 7
16310: PUSH
16311: LD_INT 4
16313: PLUS
16314: PPUSH
16315: LD_VAR 0 6
16319: PPUSH
16320: CALL 17796 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16324: LD_INT 81
16326: PPUSH
16327: LD_INT 127
16329: PPUSH
16330: CALL_OW 84
// amount := 5 ;
16334: LD_ADDR_VAR 0 8
16338: PUSH
16339: LD_INT 5
16341: ST_TO_ADDR
// macmilan_squad := [ ] ;
16342: LD_ADDR_VAR 0 9
16346: PUSH
16347: EMPTY
16348: ST_TO_ADDR
// if vip < amount then
16349: LD_EXP 59
16353: PUSH
16354: LD_VAR 0 8
16358: LESS
16359: IFFALSE 16403
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16361: LD_ADDR_VAR 0 5
16365: PUSH
16366: LD_EXP 59
16370: PUSH
16371: LD_INT 22
16373: PUSH
16374: LD_INT 4
16376: PUSH
16377: EMPTY
16378: LIST
16379: LIST
16380: PUSH
16381: LD_INT 21
16383: PUSH
16384: LD_INT 1
16386: PUSH
16387: EMPTY
16388: LIST
16389: LIST
16390: PUSH
16391: EMPTY
16392: LIST
16393: LIST
16394: PPUSH
16395: CALL_OW 69
16399: UNION
16400: ST_TO_ADDR
16401: GO 16413
// tmp := vip ;
16403: LD_ADDR_VAR 0 5
16407: PUSH
16408: LD_EXP 59
16412: ST_TO_ADDR
// tmp := tmp diff Powell ;
16413: LD_ADDR_VAR 0 5
16417: PUSH
16418: LD_VAR 0 5
16422: PUSH
16423: LD_EXP 58
16427: DIFF
16428: ST_TO_ADDR
// if tmp < amount then
16429: LD_VAR 0 5
16433: PUSH
16434: LD_VAR 0 8
16438: LESS
16439: IFFALSE 16451
// amount := tmp ;
16441: LD_ADDR_VAR 0 8
16445: PUSH
16446: LD_VAR 0 5
16450: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16451: LD_VAR 0 5
16455: PUSH
16456: LD_INT 1
16458: ARRAY
16459: PPUSH
16460: CALL_OW 257
16464: PUSH
16465: LD_INT 2
16467: NONEQUAL
16468: IFFALSE 16530
// begin if IsInUnit ( tmp [ 1 ] ) then
16470: LD_VAR 0 5
16474: PUSH
16475: LD_INT 1
16477: ARRAY
16478: PPUSH
16479: CALL_OW 310
16483: IFFALSE 16498
// ComExitBuilding ( tmp [ 1 ] ) ;
16485: LD_VAR 0 5
16489: PUSH
16490: LD_INT 1
16492: ARRAY
16493: PPUSH
16494: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16498: LD_VAR 0 5
16502: PUSH
16503: LD_INT 1
16505: ARRAY
16506: PPUSH
16507: LD_INT 387
16509: PPUSH
16510: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16514: LD_VAR 0 5
16518: PUSH
16519: LD_INT 1
16521: ARRAY
16522: PPUSH
16523: LD_INT 2
16525: PPUSH
16526: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16530: LD_EXP 39
16534: PPUSH
16535: LD_INT 82
16537: PPUSH
16538: LD_INT 129
16540: PPUSH
16541: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16545: LD_EXP 39
16549: PPUSH
16550: LD_EXP 58
16554: PPUSH
16555: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16559: LD_INT 22
16561: PUSH
16562: LD_INT 1
16564: PUSH
16565: EMPTY
16566: LIST
16567: LIST
16568: PPUSH
16569: CALL_OW 69
16573: PUSH
16574: LD_EXP 39
16578: DIFF
16579: PPUSH
16580: LD_INT 84
16582: PPUSH
16583: LD_INT 128
16585: PPUSH
16586: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16590: LD_INT 22
16592: PUSH
16593: LD_INT 1
16595: PUSH
16596: EMPTY
16597: LIST
16598: LIST
16599: PPUSH
16600: CALL_OW 69
16604: PUSH
16605: LD_EXP 39
16609: DIFF
16610: PPUSH
16611: LD_EXP 39
16615: PPUSH
16616: CALL_OW 179
// for i = 1 to amount do
16620: LD_ADDR_VAR 0 2
16624: PUSH
16625: DOUBLE
16626: LD_INT 1
16628: DEC
16629: ST_TO_ADDR
16630: LD_VAR 0 8
16634: PUSH
16635: FOR_TO
16636: IFFALSE 16804
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16638: LD_ADDR_VAR 0 9
16642: PUSH
16643: LD_VAR 0 9
16647: PUSH
16648: LD_VAR 0 5
16652: PUSH
16653: LD_VAR 0 2
16657: ARRAY
16658: ADD
16659: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16660: LD_VAR 0 5
16664: PUSH
16665: LD_VAR 0 2
16669: ARRAY
16670: PPUSH
16671: CALL_OW 310
16675: IFFALSE 16692
// AddComExitBuilding ( tmp [ i ] ) ;
16677: LD_VAR 0 5
16681: PUSH
16682: LD_VAR 0 2
16686: ARRAY
16687: PPUSH
16688: CALL_OW 182
// if i = 2 and JMMNewVeh then
16692: LD_VAR 0 2
16696: PUSH
16697: LD_INT 2
16699: EQUAL
16700: PUSH
16701: LD_EXP 56
16705: AND
16706: IFFALSE 16764
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16708: LD_VAR 0 5
16712: PUSH
16713: LD_VAR 0 2
16717: ARRAY
16718: PPUSH
16719: LD_EXP 56
16723: PPUSH
16724: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16728: LD_VAR 0 5
16732: PUSH
16733: LD_VAR 0 2
16737: ARRAY
16738: PPUSH
16739: LD_INT 86
16741: PPUSH
16742: LD_INT 133
16744: PPUSH
16745: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16749: LD_VAR 0 5
16753: PUSH
16754: LD_VAR 0 2
16758: ARRAY
16759: PPUSH
16760: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16764: LD_VAR 0 5
16768: PUSH
16769: LD_VAR 0 2
16773: ARRAY
16774: PPUSH
16775: LD_INT 8
16777: PPUSH
16778: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16782: LD_VAR 0 5
16786: PUSH
16787: LD_VAR 0 2
16791: ARRAY
16792: PPUSH
16793: LD_EXP 39
16797: PPUSH
16798: CALL_OW 179
// end ;
16802: GO 16635
16804: POP
16805: POP
// if GirlNewVeh then
16806: LD_EXP 57
16810: IFFALSE 16824
// SetSide ( GirlNewVeh , 4 ) ;
16812: LD_EXP 57
16816: PPUSH
16817: LD_INT 4
16819: PPUSH
16820: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16824: LD_INT 35
16826: PPUSH
16827: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16831: LD_VAR 0 9
16835: PPUSH
16836: LD_INT 95
16838: PUSH
16839: LD_INT 9
16841: PUSH
16842: EMPTY
16843: LIST
16844: LIST
16845: PPUSH
16846: CALL_OW 72
16850: PUSH
16851: LD_INT 0
16853: EQUAL
16854: PUSH
16855: LD_EXP 39
16859: PPUSH
16860: LD_INT 9
16862: PPUSH
16863: CALL_OW 308
16867: NOT
16868: AND
16869: IFFALSE 16824
// wait ( 0 0$2 ) ;
16871: LD_INT 70
16873: PPUSH
16874: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16878: LD_VAR 0 9
16882: PPUSH
16883: LD_INT 1
16885: PPUSH
16886: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16890: LD_INT 21
16892: PUSH
16893: LD_INT 2
16895: PUSH
16896: EMPTY
16897: LIST
16898: LIST
16899: PUSH
16900: LD_INT 92
16902: PUSH
16903: LD_INT 83
16905: PUSH
16906: LD_INT 130
16908: PUSH
16909: LD_INT 10
16911: PUSH
16912: EMPTY
16913: LIST
16914: LIST
16915: LIST
16916: LIST
16917: PUSH
16918: EMPTY
16919: LIST
16920: LIST
16921: PPUSH
16922: CALL_OW 69
16926: PPUSH
16927: LD_INT 1
16929: PPUSH
16930: CALL_OW 235
// Video ( false ) ;
16934: LD_INT 0
16936: PPUSH
16937: CALL 102331 0 1
// ChangeMissionObjectives ( M1 ) ;
16941: LD_STRING M1
16943: PPUSH
16944: CALL_OW 337
// SaveForQuickRestart ;
16948: CALL_OW 22
// missionStart := true ;
16952: LD_ADDR_EXP 13
16956: PUSH
16957: LD_INT 1
16959: ST_TO_ADDR
// missionStage := 2 ;
16960: LD_ADDR_EXP 15
16964: PUSH
16965: LD_INT 2
16967: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16968: LD_INT 105
16970: PPUSH
16971: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16975: LD_ADDR_VAR 0 5
16979: PUSH
16980: LD_INT 22
16982: PUSH
16983: LD_INT 4
16985: PUSH
16986: EMPTY
16987: LIST
16988: LIST
16989: PUSH
16990: LD_INT 21
16992: PUSH
16993: LD_INT 1
16995: PUSH
16996: EMPTY
16997: LIST
16998: LIST
16999: PUSH
17000: EMPTY
17001: LIST
17002: LIST
17003: PPUSH
17004: CALL_OW 69
17008: PUSH
17009: LD_EXP 58
17013: DIFF
17014: ST_TO_ADDR
// if not tmp then
17015: LD_VAR 0 5
17019: NOT
17020: IFFALSE 17035
// tmp := [ Powell ] ;
17022: LD_ADDR_VAR 0 5
17026: PUSH
17027: LD_EXP 58
17031: PUSH
17032: EMPTY
17033: LIST
17034: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
17035: LD_ADDR_EXP 116
17039: PUSH
17040: LD_EXP 116
17044: PPUSH
17045: LD_INT 4
17047: PPUSH
17048: LD_INT 22
17050: PUSH
17051: LD_INT 4
17053: PUSH
17054: EMPTY
17055: LIST
17056: LIST
17057: PUSH
17058: LD_INT 23
17060: PUSH
17061: LD_INT 1
17063: PUSH
17064: EMPTY
17065: LIST
17066: LIST
17067: PUSH
17068: LD_INT 3
17070: PUSH
17071: LD_INT 21
17073: PUSH
17074: LD_INT 2
17076: PUSH
17077: EMPTY
17078: LIST
17079: LIST
17080: PUSH
17081: EMPTY
17082: LIST
17083: LIST
17084: PUSH
17085: EMPTY
17086: LIST
17087: LIST
17088: LIST
17089: PPUSH
17090: CALL_OW 69
17094: PUSH
17095: LD_EXP 58
17099: DIFF
17100: PPUSH
17101: CALL_OW 1
17105: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17106: LD_ADDR_VAR 0 4
17110: PUSH
17111: LD_INT 22
17113: PUSH
17114: LD_INT 4
17116: PUSH
17117: EMPTY
17118: LIST
17119: LIST
17120: PUSH
17121: LD_INT 34
17123: PUSH
17124: LD_INT 12
17126: PUSH
17127: EMPTY
17128: LIST
17129: LIST
17130: PUSH
17131: EMPTY
17132: LIST
17133: LIST
17134: PPUSH
17135: CALL_OW 69
17139: PUSH
17140: LD_INT 1
17142: ARRAY
17143: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17144: LD_VAR 0 5
17148: PUSH
17149: LD_INT 1
17151: ARRAY
17152: PPUSH
17153: CALL_OW 310
17157: IFFALSE 17172
// ComExitBuilding ( tmp [ 1 ] ) ;
17159: LD_VAR 0 5
17163: PUSH
17164: LD_INT 1
17166: ARRAY
17167: PPUSH
17168: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17172: LD_VAR 0 5
17176: PUSH
17177: LD_INT 1
17179: ARRAY
17180: PPUSH
17181: LD_VAR 0 4
17185: PPUSH
17186: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17190: LD_VAR 0 5
17194: PUSH
17195: LD_INT 1
17197: ARRAY
17198: PPUSH
17199: LD_INT 80
17201: PPUSH
17202: LD_INT 136
17204: PPUSH
17205: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17209: LD_VAR 0 5
17213: PUSH
17214: LD_INT 1
17216: ARRAY
17217: PPUSH
17218: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17222: LD_VAR 0 5
17226: PUSH
17227: LD_INT 1
17229: ARRAY
17230: PPUSH
17231: LD_INT 59
17233: PPUSH
17234: LD_INT 112
17236: PPUSH
17237: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17241: LD_VAR 0 5
17245: PUSH
17246: LD_INT 1
17248: ARRAY
17249: PPUSH
17250: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17254: LD_EXP 40
17258: PUSH
17259: LD_EXP 40
17263: PPUSH
17264: CALL_OW 255
17268: PUSH
17269: LD_INT 1
17271: EQUAL
17272: AND
17273: IFFALSE 17299
// begin Say ( Joan , D3W-Joan-1 ) ;
17275: LD_EXP 40
17279: PPUSH
17280: LD_STRING D3W-Joan-1
17282: PPUSH
17283: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17287: LD_EXP 39
17291: PPUSH
17292: LD_STRING D3W-JMM-1
17294: PPUSH
17295: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17299: LD_EXP 42
17303: PUSH
17304: LD_EXP 42
17308: PPUSH
17309: CALL_OW 255
17313: PUSH
17314: LD_INT 1
17316: EQUAL
17317: AND
17318: PUSH
17319: LD_EXP 42
17323: PUSH
17324: LD_EXP 59
17328: IN
17329: NOT
17330: AND
17331: IFFALSE 17357
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17333: LD_EXP 42
17337: PPUSH
17338: LD_STRING D3W-Lisa-1
17340: PPUSH
17341: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17345: LD_EXP 39
17349: PPUSH
17350: LD_STRING D3W-JMM-1
17352: PPUSH
17353: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17357: LD_EXP 54
17361: PUSH
17362: LD_EXP 54
17366: PPUSH
17367: CALL_OW 255
17371: PUSH
17372: LD_INT 1
17374: EQUAL
17375: AND
17376: IFFALSE 17402
// begin Say ( Connie , D3W-Con-1 ) ;
17378: LD_EXP 54
17382: PPUSH
17383: LD_STRING D3W-Con-1
17385: PPUSH
17386: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17390: LD_EXP 39
17394: PPUSH
17395: LD_STRING D3W-JMM-1
17397: PPUSH
17398: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17402: LD_EXP 42
17406: PUSH
17407: LD_EXP 59
17411: IN
17412: PUSH
17413: LD_EXP 42
17417: PPUSH
17418: CALL_OW 255
17422: PUSH
17423: LD_INT 1
17425: EQUAL
17426: AND
17427: IFFALSE 17443
// Say ( Lisa , D3nW-Lisa-1 ) else
17429: LD_EXP 42
17433: PPUSH
17434: LD_STRING D3nW-Lisa-1
17436: PPUSH
17437: CALL_OW 88
17441: GO 17687
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17443: LD_EXP 45
17447: PUSH
17448: LD_EXP 59
17452: IN
17453: PUSH
17454: LD_EXP 45
17458: PPUSH
17459: CALL_OW 255
17463: PUSH
17464: LD_INT 1
17466: EQUAL
17467: AND
17468: IFFALSE 17484
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17470: LD_EXP 45
17474: PPUSH
17475: LD_STRING D3nW-Cyrus-1
17477: PPUSH
17478: CALL_OW 88
17482: GO 17687
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17484: LD_EXP 44
17488: PUSH
17489: LD_EXP 59
17493: IN
17494: PUSH
17495: LD_EXP 44
17499: PPUSH
17500: CALL_OW 255
17504: PUSH
17505: LD_INT 1
17507: EQUAL
17508: AND
17509: IFFALSE 17525
// Say ( Bobby , D3nW-Bobby-1 ) else
17511: LD_EXP 44
17515: PPUSH
17516: LD_STRING D3nW-Bobby-1
17518: PPUSH
17519: CALL_OW 88
17523: GO 17687
// if Gary in vip and GetSide ( Gary ) = 1 then
17525: LD_EXP 51
17529: PUSH
17530: LD_EXP 59
17534: IN
17535: PUSH
17536: LD_EXP 51
17540: PPUSH
17541: CALL_OW 255
17545: PUSH
17546: LD_INT 1
17548: EQUAL
17549: AND
17550: IFFALSE 17566
// Say ( Gary , D3nW-Gary-1 ) else
17552: LD_EXP 51
17556: PPUSH
17557: LD_STRING D3nW-Gary-1
17559: PPUSH
17560: CALL_OW 88
17564: GO 17687
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17566: LD_EXP 43
17570: PUSH
17571: LD_EXP 59
17575: IN
17576: PUSH
17577: LD_EXP 43
17581: PPUSH
17582: CALL_OW 255
17586: PUSH
17587: LD_INT 1
17589: EQUAL
17590: AND
17591: IFFALSE 17607
// Say ( Donaldson , D3nW-Don-1 ) else
17593: LD_EXP 43
17597: PPUSH
17598: LD_STRING D3nW-Don-1
17600: PPUSH
17601: CALL_OW 88
17605: GO 17687
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17607: LD_EXP 50
17611: PUSH
17612: LD_EXP 59
17616: IN
17617: PUSH
17618: LD_EXP 50
17622: PPUSH
17623: CALL_OW 255
17627: PUSH
17628: LD_INT 1
17630: EQUAL
17631: AND
17632: IFFALSE 17648
// Say ( Cornel , D3nW-Corn-1 ) else
17634: LD_EXP 50
17638: PPUSH
17639: LD_STRING D3nW-Corn-1
17641: PPUSH
17642: CALL_OW 88
17646: GO 17687
// if Frank in vip and GetSide ( Frank ) = 1 then
17648: LD_EXP 52
17652: PUSH
17653: LD_EXP 59
17657: IN
17658: PUSH
17659: LD_EXP 52
17663: PPUSH
17664: CALL_OW 255
17668: PUSH
17669: LD_INT 1
17671: EQUAL
17672: AND
17673: IFFALSE 17687
// Say ( Frank , D3nW-Frank-1 ) ;
17675: LD_EXP 52
17679: PPUSH
17680: LD_STRING D3nW-Frank-1
17682: PPUSH
17683: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17687: LD_EXP 59
17691: PPUSH
17692: LD_INT 22
17694: PUSH
17695: LD_INT 1
17697: PUSH
17698: EMPTY
17699: LIST
17700: LIST
17701: PPUSH
17702: CALL_OW 72
17706: IFFALSE 17732
// begin Say ( JMM , D3nW-JMM-1 ) ;
17708: LD_EXP 39
17712: PPUSH
17713: LD_STRING D3nW-JMM-1
17715: PPUSH
17716: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17720: LD_EXP 39
17724: PPUSH
17725: LD_STRING D3nW-JMM-1a
17727: PPUSH
17728: CALL_OW 88
// end ; t := 0 0$00 ;
17732: LD_ADDR_VAR 0 3
17736: PUSH
17737: LD_INT 0
17739: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17740: LD_INT 35
17742: PPUSH
17743: CALL_OW 67
// t := t + 0 0$1 ;
17747: LD_ADDR_VAR 0 3
17751: PUSH
17752: LD_VAR 0 3
17756: PUSH
17757: LD_INT 35
17759: PLUS
17760: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17761: LD_INT 59
17763: PPUSH
17764: LD_INT 112
17766: PPUSH
17767: CALL_OW 428
17771: PUSH
17772: LD_VAR 0 3
17776: PUSH
17777: LD_INT 2100
17779: GREATER
17780: OR
17781: IFFALSE 17740
// activeAttacks := true ;
17783: LD_ADDR_EXP 16
17787: PUSH
17788: LD_INT 1
17790: ST_TO_ADDR
// end ;
17791: LD_VAR 0 1
17795: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17796: LD_INT 0
17798: PPUSH
// case question of 1 :
17799: LD_VAR 0 1
17803: PUSH
17804: LD_INT 1
17806: DOUBLE
17807: EQUAL
17808: IFTRUE 17812
17810: GO 17863
17812: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17813: LD_EXP 39
17817: PPUSH
17818: LD_STRING D2Mot-JMM-1
17820: PPUSH
17821: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17825: LD_EXP 58
17829: PPUSH
17830: LD_STRING D2Mot-Pow-1
17832: PPUSH
17833: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17837: LD_EXP 39
17841: PPUSH
17842: LD_STRING D2Mot-JMM-2
17844: PPUSH
17845: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17849: LD_EXP 58
17853: PPUSH
17854: LD_STRING D2Mot-Pow-2
17856: PPUSH
17857: CALL_OW 88
// end ; 2 :
17861: GO 18214
17863: LD_INT 2
17865: DOUBLE
17866: EQUAL
17867: IFTRUE 17871
17869: GO 17947
17871: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17872: LD_EXP 39
17876: PPUSH
17877: LD_STRING D2Rus-JMM-1
17879: PPUSH
17880: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17884: LD_EXP 58
17888: PPUSH
17889: LD_STRING D2Rus-Pow-1
17891: PPUSH
17892: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17896: LD_EXP 39
17900: PPUSH
17901: LD_STRING D2Rus-JMM-2
17903: PPUSH
17904: CALL_OW 88
// if not ( 3 in list_of_q ) then
17908: LD_INT 3
17910: PUSH
17911: LD_VAR 0 2
17915: IN
17916: NOT
17917: IFFALSE 17933
// Say ( Powell , D2Rus-Pow-2 ) else
17919: LD_EXP 58
17923: PPUSH
17924: LD_STRING D2Rus-Pow-2
17926: PPUSH
17927: CALL_OW 88
17931: GO 17945
// Say ( Powell , D2Rus-Pow-2a ) ;
17933: LD_EXP 58
17937: PPUSH
17938: LD_STRING D2Rus-Pow-2a
17940: PPUSH
17941: CALL_OW 88
// end ; 3 :
17945: GO 18214
17947: LD_INT 3
17949: DOUBLE
17950: EQUAL
17951: IFTRUE 17955
17953: GO 18040
17955: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17956: LD_EXP 39
17960: PPUSH
17961: LD_STRING D2Leg-JMM-1
17963: PPUSH
17964: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17968: LD_EXP 58
17972: PPUSH
17973: LD_STRING D2Leg-Pow-1
17975: PPUSH
17976: CALL_OW 88
// if 2 in list_of_q then
17980: LD_INT 2
17982: PUSH
17983: LD_VAR 0 2
17987: IN
17988: IFFALSE 18014
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17990: LD_EXP 39
17994: PPUSH
17995: LD_STRING D2Leg-JMM-2
17997: PPUSH
17998: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
18002: LD_EXP 58
18006: PPUSH
18007: LD_STRING D2Leg-Pow-2
18009: PPUSH
18010: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
18014: LD_EXP 39
18018: PPUSH
18019: LD_STRING D2Leg-JMM-3
18021: PPUSH
18022: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18026: LD_EXP 58
18030: PPUSH
18031: LD_STRING D2Leg-Pow-3
18033: PPUSH
18034: CALL_OW 88
// end ; 4 :
18038: GO 18214
18040: LD_INT 4
18042: DOUBLE
18043: EQUAL
18044: IFTRUE 18048
18046: GO 18123
18048: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18049: LD_EXP 39
18053: PPUSH
18054: LD_STRING D2Ar-JMM-1
18056: PPUSH
18057: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18061: LD_EXP 58
18065: PPUSH
18066: LD_STRING D2Ar-Pow-1
18068: PPUSH
18069: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18073: LD_EXP 39
18077: PPUSH
18078: LD_STRING D2Ar-JMM-2
18080: PPUSH
18081: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18085: LD_EXP 58
18089: PPUSH
18090: LD_STRING D2Ar-Pow-2
18092: PPUSH
18093: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18097: LD_EXP 39
18101: PPUSH
18102: LD_STRING D2Ar-JMM-3
18104: PPUSH
18105: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18109: LD_EXP 58
18113: PPUSH
18114: LD_STRING D2Ar-Pow-3
18116: PPUSH
18117: CALL_OW 88
// end ; 5 :
18121: GO 18214
18123: LD_INT 5
18125: DOUBLE
18126: EQUAL
18127: IFTRUE 18131
18129: GO 18146
18131: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18132: LD_EXP 39
18136: PPUSH
18137: LD_STRING D2Conf-JMM-1
18139: PPUSH
18140: CALL_OW 88
18144: GO 18214
18146: LD_INT 6
18148: DOUBLE
18149: EQUAL
18150: IFTRUE 18154
18152: GO 18213
18154: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18155: LD_EXP 39
18159: PPUSH
18160: LD_STRING D2Com-JMM-1
18162: PPUSH
18163: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18167: LD_EXP 58
18171: PPUSH
18172: LD_STRING D2Com-Pow-1
18174: PPUSH
18175: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18179: LD_EXP 39
18183: PPUSH
18184: LD_STRING D2Com-JMM-2
18186: PPUSH
18187: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18191: LD_EXP 58
18195: PPUSH
18196: LD_STRING D2Com-Pow-2
18198: PPUSH
18199: CALL_OW 88
// powellAngerQuery := true ;
18203: LD_ADDR_EXP 36
18207: PUSH
18208: LD_INT 1
18210: ST_TO_ADDR
// end ; end ;
18211: GO 18214
18213: POP
// end ;
18214: LD_VAR 0 3
18218: RET
// every 0 0$5 trigger missionStart do var tmp ;
18219: LD_EXP 13
18223: IFFALSE 18506
18225: GO 18227
18227: DISABLE
18228: LD_INT 0
18230: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18231: LD_INT 35
18233: PPUSH
18234: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18238: LD_INT 14
18240: PPUSH
18241: LD_INT 22
18243: PUSH
18244: LD_INT 1
18246: PUSH
18247: EMPTY
18248: LIST
18249: LIST
18250: PPUSH
18251: CALL_OW 70
18255: PUSH
18256: LD_EXP 15
18260: PUSH
18261: LD_INT 2
18263: PUSH
18264: LD_INT 3
18266: PUSH
18267: LD_INT 4
18269: PUSH
18270: LD_INT 5
18272: PUSH
18273: EMPTY
18274: LIST
18275: LIST
18276: LIST
18277: LIST
18278: IN
18279: AND
18280: IFFALSE 18496
// begin powellAnger := powellAnger + 1 ;
18282: LD_ADDR_EXP 17
18286: PUSH
18287: LD_EXP 17
18291: PUSH
18292: LD_INT 1
18294: PLUS
18295: ST_TO_ADDR
// Video ( true ) ;
18296: LD_INT 1
18298: PPUSH
18299: CALL 102331 0 1
// CenterNowOnUnits ( tmp ) ;
18303: LD_VAR 0 1
18307: PPUSH
18308: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18312: LD_INT 14
18314: PPUSH
18315: LD_INT 22
18317: PUSH
18318: LD_INT 1
18320: PUSH
18321: EMPTY
18322: LIST
18323: LIST
18324: PPUSH
18325: CALL_OW 70
18329: PPUSH
18330: LD_INT 86
18332: PPUSH
18333: LD_INT 133
18335: PPUSH
18336: CALL_OW 111
// async ;
18340: ASYNC
// case powellAnger of 1 :
18341: LD_EXP 17
18345: PUSH
18346: LD_INT 1
18348: DOUBLE
18349: EQUAL
18350: IFTRUE 18354
18352: GO 18369
18354: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18355: LD_EXP 58
18359: PPUSH
18360: LD_STRING DBack1-Pow-1
18362: PPUSH
18363: CALL_OW 88
18367: GO 18416
18369: LD_INT 2
18371: DOUBLE
18372: EQUAL
18373: IFTRUE 18377
18375: GO 18392
18377: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18378: LD_EXP 58
18382: PPUSH
18383: LD_STRING DBack2-Pow-1
18385: PPUSH
18386: CALL_OW 88
18390: GO 18416
18392: LD_INT 3
18394: DOUBLE
18395: EQUAL
18396: IFTRUE 18400
18398: GO 18415
18400: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18401: LD_EXP 58
18405: PPUSH
18406: LD_STRING DBack3-Pow-1
18408: PPUSH
18409: CALL_OW 88
18413: GO 18416
18415: POP
// sync ;
18416: SYNC
// repeat wait ( 0 0$1 ) ;
18417: LD_INT 35
18419: PPUSH
18420: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18424: LD_INT 14
18426: PPUSH
18427: LD_INT 22
18429: PUSH
18430: LD_INT 1
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: PPUSH
18437: CALL_OW 70
18441: PPUSH
18442: LD_INT 86
18444: PPUSH
18445: LD_INT 133
18447: PPUSH
18448: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18452: LD_INT 14
18454: PPUSH
18455: LD_INT 22
18457: PUSH
18458: LD_INT 1
18460: PUSH
18461: EMPTY
18462: LIST
18463: LIST
18464: PPUSH
18465: CALL_OW 70
18469: NOT
18470: IFFALSE 18417
// if powellAnger >= 3 then
18472: LD_EXP 17
18476: PUSH
18477: LD_INT 3
18479: GREATEREQUAL
18480: IFFALSE 18489
// YouLost ( Dismissed ) ;
18482: LD_STRING Dismissed
18484: PPUSH
18485: CALL_OW 104
// Video ( false ) ;
18489: LD_INT 0
18491: PPUSH
18492: CALL 102331 0 1
// end ; until missionStage > 5 ;
18496: LD_EXP 15
18500: PUSH
18501: LD_INT 5
18503: GREATER
18504: IFFALSE 18231
// end ;
18506: PPOPN 1
18508: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18509: LD_EXP 13
18513: PUSH
18514: LD_INT 22
18516: PUSH
18517: LD_INT 4
18519: PUSH
18520: EMPTY
18521: LIST
18522: LIST
18523: PUSH
18524: LD_INT 21
18526: PUSH
18527: LD_INT 2
18529: PUSH
18530: EMPTY
18531: LIST
18532: LIST
18533: PUSH
18534: EMPTY
18535: LIST
18536: LIST
18537: PPUSH
18538: CALL_OW 69
18542: PUSH
18543: LD_INT 4
18545: GREATEREQUAL
18546: AND
18547: PUSH
18548: LD_EXP 15
18552: PUSH
18553: LD_INT 2
18555: EQUAL
18556: AND
18557: IFFALSE 20380
18559: GO 18561
18561: DISABLE
18562: LD_INT 0
18564: PPUSH
18565: PPUSH
18566: PPUSH
18567: PPUSH
18568: PPUSH
18569: PPUSH
18570: PPUSH
18571: PPUSH
// begin missionStage := 3 ;
18572: LD_ADDR_EXP 15
18576: PUSH
18577: LD_INT 3
18579: ST_TO_ADDR
// retreat := false ;
18580: LD_ADDR_VAR 0 4
18584: PUSH
18585: LD_INT 0
18587: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18588: LD_ADDR_VAR 0 5
18592: PUSH
18593: LD_INT 22
18595: PUSH
18596: LD_INT 4
18598: PUSH
18599: EMPTY
18600: LIST
18601: LIST
18602: PUSH
18603: LD_INT 30
18605: PUSH
18606: LD_INT 4
18608: PUSH
18609: EMPTY
18610: LIST
18611: LIST
18612: PUSH
18613: EMPTY
18614: LIST
18615: LIST
18616: PPUSH
18617: CALL_OW 69
18621: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18622: LD_ADDR_VAR 0 6
18626: PUSH
18627: LD_INT 22
18629: PUSH
18630: LD_INT 4
18632: PUSH
18633: EMPTY
18634: LIST
18635: LIST
18636: PUSH
18637: LD_INT 30
18639: PUSH
18640: LD_INT 5
18642: PUSH
18643: EMPTY
18644: LIST
18645: LIST
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: PPUSH
18651: CALL_OW 69
18655: ST_TO_ADDR
// if not bar then
18656: LD_VAR 0 6
18660: NOT
18661: IFFALSE 18714
// begin repeat wait ( 0 0$1 ) ;
18663: LD_INT 35
18665: PPUSH
18666: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18670: LD_INT 22
18672: PUSH
18673: LD_INT 4
18675: PUSH
18676: EMPTY
18677: LIST
18678: LIST
18679: PUSH
18680: LD_INT 3
18682: PUSH
18683: LD_INT 57
18685: PUSH
18686: EMPTY
18687: LIST
18688: PUSH
18689: EMPTY
18690: LIST
18691: LIST
18692: PUSH
18693: LD_INT 30
18695: PUSH
18696: LD_INT 5
18698: PUSH
18699: EMPTY
18700: LIST
18701: LIST
18702: PUSH
18703: EMPTY
18704: LIST
18705: LIST
18706: LIST
18707: PPUSH
18708: CALL_OW 69
18712: IFFALSE 18663
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18714: LD_ADDR_VAR 0 6
18718: PUSH
18719: LD_INT 22
18721: PUSH
18722: LD_INT 4
18724: PUSH
18725: EMPTY
18726: LIST
18727: LIST
18728: PUSH
18729: LD_INT 30
18731: PUSH
18732: LD_INT 5
18734: PUSH
18735: EMPTY
18736: LIST
18737: LIST
18738: PUSH
18739: EMPTY
18740: LIST
18741: LIST
18742: PPUSH
18743: CALL_OW 69
18747: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18748: LD_INT 35
18750: PPUSH
18751: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18755: LD_EXP 135
18759: PUSH
18760: LD_INT 4
18762: ARRAY
18763: PUSH
18764: LD_INT 4
18766: GREATEREQUAL
18767: IFFALSE 18748
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18769: LD_ADDR_VAR 0 2
18773: PUSH
18774: LD_INT 22
18776: PUSH
18777: LD_INT 4
18779: PUSH
18780: EMPTY
18781: LIST
18782: LIST
18783: PUSH
18784: LD_INT 2
18786: PUSH
18787: LD_INT 25
18789: PUSH
18790: LD_INT 1
18792: PUSH
18793: EMPTY
18794: LIST
18795: LIST
18796: PUSH
18797: LD_INT 25
18799: PUSH
18800: LD_INT 2
18802: PUSH
18803: EMPTY
18804: LIST
18805: LIST
18806: PUSH
18807: LD_INT 25
18809: PUSH
18810: LD_INT 3
18812: PUSH
18813: EMPTY
18814: LIST
18815: LIST
18816: PUSH
18817: LD_INT 25
18819: PUSH
18820: LD_INT 4
18822: PUSH
18823: EMPTY
18824: LIST
18825: LIST
18826: PUSH
18827: LD_INT 25
18829: PUSH
18830: LD_INT 5
18832: PUSH
18833: EMPTY
18834: LIST
18835: LIST
18836: PUSH
18837: EMPTY
18838: LIST
18839: LIST
18840: LIST
18841: LIST
18842: LIST
18843: LIST
18844: PUSH
18845: EMPTY
18846: LIST
18847: LIST
18848: PPUSH
18849: CALL_OW 69
18853: PUSH
18854: LD_EXP 58
18858: PUSH
18859: LD_EXP 59
18863: ADD
18864: DIFF
18865: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18866: LD_ADDR_VAR 0 3
18870: PUSH
18871: LD_VAR 0 2
18875: PPUSH
18876: LD_INT 26
18878: PUSH
18879: LD_INT 1
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: PPUSH
18886: CALL_OW 72
18890: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18891: LD_ADDR_VAR 0 2
18895: PUSH
18896: LD_VAR 0 2
18900: PUSH
18901: LD_VAR 0 3
18905: DIFF
18906: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18907: LD_ADDR_VAR 0 2
18911: PUSH
18912: LD_VAR 0 2
18916: PPUSH
18917: LD_INT 1
18919: PPUSH
18920: CALL 100865 0 2
18924: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18925: LD_ADDR_VAR 0 3
18929: PUSH
18930: LD_VAR 0 3
18934: PPUSH
18935: LD_INT 1
18937: PPUSH
18938: CALL 100865 0 2
18942: ST_TO_ADDR
// for i = 1 to 4 do
18943: LD_ADDR_VAR 0 1
18947: PUSH
18948: DOUBLE
18949: LD_INT 1
18951: DEC
18952: ST_TO_ADDR
18953: LD_INT 4
18955: PUSH
18956: FOR_TO
18957: IFFALSE 19123
// begin if tmp2 then
18959: LD_VAR 0 3
18963: IFFALSE 19044
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18965: LD_ADDR_EXP 18
18969: PUSH
18970: LD_EXP 18
18974: PPUSH
18975: LD_INT 1
18977: PPUSH
18978: LD_EXP 18
18982: PUSH
18983: LD_INT 1
18985: ARRAY
18986: PUSH
18987: LD_VAR 0 3
18991: PUSH
18992: LD_VAR 0 3
18996: ARRAY
18997: ADD
18998: PPUSH
18999: CALL_OW 1
19003: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
19004: LD_VAR 0 3
19008: PUSH
19009: LD_VAR 0 3
19013: ARRAY
19014: PPUSH
19015: LD_INT 1
19017: PPUSH
19018: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
19022: LD_ADDR_VAR 0 3
19026: PUSH
19027: LD_VAR 0 3
19031: PPUSH
19032: LD_VAR 0 3
19036: PPUSH
19037: CALL_OW 3
19041: ST_TO_ADDR
// end else
19042: GO 19121
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19044: LD_ADDR_EXP 18
19048: PUSH
19049: LD_EXP 18
19053: PPUSH
19054: LD_INT 1
19056: PPUSH
19057: LD_EXP 18
19061: PUSH
19062: LD_INT 1
19064: ARRAY
19065: PUSH
19066: LD_VAR 0 2
19070: PUSH
19071: LD_VAR 0 2
19075: ARRAY
19076: ADD
19077: PPUSH
19078: CALL_OW 1
19082: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19083: LD_VAR 0 2
19087: PUSH
19088: LD_VAR 0 2
19092: ARRAY
19093: PPUSH
19094: LD_INT 1
19096: PPUSH
19097: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19101: LD_ADDR_VAR 0 2
19105: PUSH
19106: LD_VAR 0 2
19110: PPUSH
19111: LD_VAR 0 2
19115: PPUSH
19116: CALL_OW 3
19120: ST_TO_ADDR
// end ; end ;
19121: GO 18956
19123: POP
19124: POP
// if tmp2 then
19125: LD_VAR 0 3
19129: IFFALSE 19147
// tmp := tmp union tmp2 ;
19131: LD_ADDR_VAR 0 2
19135: PUSH
19136: LD_VAR 0 2
19140: PUSH
19141: LD_VAR 0 3
19145: UNION
19146: ST_TO_ADDR
// for i = 1 to 4 do
19147: LD_ADDR_VAR 0 1
19151: PUSH
19152: DOUBLE
19153: LD_INT 1
19155: DEC
19156: ST_TO_ADDR
19157: LD_INT 4
19159: PUSH
19160: FOR_TO
19161: IFFALSE 19210
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19163: LD_ADDR_EXP 18
19167: PUSH
19168: LD_EXP 18
19172: PPUSH
19173: LD_INT 2
19175: PPUSH
19176: LD_EXP 18
19180: PUSH
19181: LD_INT 2
19183: ARRAY
19184: PUSH
19185: LD_VAR 0 2
19189: PUSH
19190: LD_VAR 0 2
19194: PUSH
19195: LD_VAR 0 1
19199: MINUS
19200: ARRAY
19201: ADD
19202: PPUSH
19203: CALL_OW 1
19207: ST_TO_ADDR
19208: GO 19160
19210: POP
19211: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19212: LD_ADDR_EXP 116
19216: PUSH
19217: LD_EXP 116
19221: PPUSH
19222: LD_INT 4
19224: PPUSH
19225: LD_EXP 116
19229: PUSH
19230: LD_INT 4
19232: ARRAY
19233: PUSH
19234: LD_EXP 18
19238: PUSH
19239: LD_INT 1
19241: ARRAY
19242: DIFF
19243: PPUSH
19244: CALL_OW 1
19248: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19249: LD_VAR 0 5
19253: PUSH
19254: LD_INT 1
19256: ARRAY
19257: PPUSH
19258: CALL_OW 313
19262: IFFALSE 19317
// begin for i in UnitsInside ( arm [ 1 ] ) do
19264: LD_ADDR_VAR 0 1
19268: PUSH
19269: LD_VAR 0 5
19273: PUSH
19274: LD_INT 1
19276: ARRAY
19277: PPUSH
19278: CALL_OW 313
19282: PUSH
19283: FOR_IN
19284: IFFALSE 19315
// begin ComExitBuilding ( i ) ;
19286: LD_VAR 0 1
19290: PPUSH
19291: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19295: LD_VAR 0 1
19299: PPUSH
19300: LD_VAR 0 6
19304: PUSH
19305: LD_INT 1
19307: ARRAY
19308: PPUSH
19309: CALL_OW 180
// end ;
19313: GO 19283
19315: POP
19316: POP
// end ; wait ( 0 0$3 ) ;
19317: LD_INT 105
19319: PPUSH
19320: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19324: LD_ADDR_VAR 0 1
19328: PUSH
19329: LD_EXP 18
19333: PUSH
19334: LD_INT 1
19336: ARRAY
19337: PUSH
19338: FOR_IN
19339: IFFALSE 19446
// begin if IsInUnit ( i ) then
19341: LD_VAR 0 1
19345: PPUSH
19346: CALL_OW 310
19350: IFFALSE 19361
// ComExitBuilding ( i ) ;
19352: LD_VAR 0 1
19356: PPUSH
19357: CALL_OW 122
// if GetClass ( i ) <> 1 then
19361: LD_VAR 0 1
19365: PPUSH
19366: CALL_OW 257
19370: PUSH
19371: LD_INT 1
19373: NONEQUAL
19374: IFFALSE 19415
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19376: LD_VAR 0 1
19380: PPUSH
19381: LD_VAR 0 5
19385: PUSH
19386: LD_INT 1
19388: ARRAY
19389: PPUSH
19390: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19394: LD_VAR 0 1
19398: PPUSH
19399: LD_INT 1
19401: PPUSH
19402: CALL_OW 183
// AddComExitBuilding ( i ) ;
19406: LD_VAR 0 1
19410: PPUSH
19411: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19415: LD_VAR 0 1
19419: PPUSH
19420: LD_INT 60
19422: PPUSH
19423: LD_INT 94
19425: PPUSH
19426: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19430: LD_VAR 0 1
19434: PPUSH
19435: LD_EXP 58
19439: PPUSH
19440: CALL_OW 179
// end ;
19444: GO 19338
19446: POP
19447: POP
// wait ( 0 0$15 ) ;
19448: LD_INT 525
19450: PPUSH
19451: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19455: LD_EXP 58
19459: PPUSH
19460: LD_STRING D4-Pow-1
19462: PPUSH
19463: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19467: LD_ADDR_VAR 0 2
19471: PUSH
19472: LD_EXP 18
19476: PUSH
19477: LD_INT 1
19479: ARRAY
19480: PPUSH
19481: LD_INT 26
19483: PUSH
19484: LD_INT 1
19486: PUSH
19487: EMPTY
19488: LIST
19489: LIST
19490: PPUSH
19491: CALL_OW 72
19495: ST_TO_ADDR
// if tmp then
19496: LD_VAR 0 2
19500: IFFALSE 19518
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19502: LD_VAR 0 2
19506: PUSH
19507: LD_INT 1
19509: ARRAY
19510: PPUSH
19511: LD_STRING D4-Sol1-1
19513: PPUSH
19514: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19518: LD_EXP 58
19522: PPUSH
19523: LD_STRING D4-Pow-2
19525: PPUSH
19526: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19530: LD_ADDR_VAR 0 1
19534: PUSH
19535: DOUBLE
19536: LD_INT 1
19538: DEC
19539: ST_TO_ADDR
19540: LD_EXP 18
19544: PUSH
19545: LD_INT 1
19547: ARRAY
19548: PUSH
19549: FOR_TO
19550: IFFALSE 19643
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19552: LD_EXP 18
19556: PUSH
19557: LD_INT 1
19559: ARRAY
19560: PUSH
19561: LD_VAR 0 1
19565: ARRAY
19566: PPUSH
19567: LD_EXP 135
19571: PUSH
19572: LD_INT 4
19574: ARRAY
19575: PUSH
19576: LD_INT 1
19578: ARRAY
19579: PPUSH
19580: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19584: LD_ADDR_EXP 135
19588: PUSH
19589: LD_EXP 135
19593: PPUSH
19594: LD_INT 4
19596: PPUSH
19597: LD_EXP 135
19601: PUSH
19602: LD_INT 4
19604: ARRAY
19605: PPUSH
19606: LD_INT 1
19608: PPUSH
19609: CALL_OW 3
19613: PPUSH
19614: CALL_OW 1
19618: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19619: LD_INT 8
19621: PPUSH
19622: LD_EXP 18
19626: PUSH
19627: LD_INT 1
19629: ARRAY
19630: PUSH
19631: LD_VAR 0 1
19635: ARRAY
19636: PPUSH
19637: CALL_OW 471
// end ;
19641: GO 19549
19643: POP
19644: POP
// repeat wait ( 0 0$1 ) ;
19645: LD_INT 35
19647: PPUSH
19648: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19652: LD_EXP 18
19656: PUSH
19657: LD_INT 1
19659: ARRAY
19660: PPUSH
19661: LD_INT 55
19663: PUSH
19664: EMPTY
19665: LIST
19666: PPUSH
19667: CALL_OW 72
19671: PUSH
19672: LD_INT 4
19674: GREATEREQUAL
19675: IFFALSE 19645
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19677: LD_EXP 18
19681: PUSH
19682: LD_INT 1
19684: ARRAY
19685: PPUSH
19686: LD_INT 69
19688: PPUSH
19689: LD_INT 94
19691: PPUSH
19692: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19696: LD_EXP 18
19700: PUSH
19701: LD_INT 1
19703: ARRAY
19704: PPUSH
19705: LD_INT 82
19707: PPUSH
19708: LD_INT 83
19710: PPUSH
19711: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19715: LD_EXP 18
19719: PUSH
19720: LD_INT 1
19722: ARRAY
19723: PPUSH
19724: LD_INT 77
19726: PPUSH
19727: LD_INT 69
19729: PPUSH
19730: CALL_OW 174
// repeat wait ( 3 ) ;
19734: LD_INT 3
19736: PPUSH
19737: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19741: LD_ADDR_VAR 0 1
19745: PUSH
19746: LD_EXP 18
19750: PUSH
19751: LD_INT 1
19753: ARRAY
19754: PUSH
19755: FOR_IN
19756: IFFALSE 19892
// begin if GetLives ( i ) < 990 then
19758: LD_VAR 0 1
19762: PPUSH
19763: CALL_OW 256
19767: PUSH
19768: LD_INT 990
19770: LESS
19771: IFFALSE 19785
// SetLives ( i , 1000 ) ;
19773: LD_VAR 0 1
19777: PPUSH
19778: LD_INT 1000
19780: PPUSH
19781: CALL_OW 234
// if not IsInUnit ( i ) then
19785: LD_VAR 0 1
19789: PPUSH
19790: CALL_OW 310
19794: NOT
19795: IFFALSE 19890
// begin if not HasTask ( i ) then
19797: LD_VAR 0 1
19801: PPUSH
19802: CALL_OW 314
19806: NOT
19807: IFFALSE 19824
// ComMoveXY ( i , 64 , 93 ) ;
19809: LD_VAR 0 1
19813: PPUSH
19814: LD_INT 64
19816: PPUSH
19817: LD_INT 93
19819: PPUSH
19820: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19824: LD_VAR 0 4
19828: NOT
19829: PUSH
19830: LD_VAR 0 1
19834: PPUSH
19835: CALL_OW 258
19839: PUSH
19840: LD_INT 1
19842: EQUAL
19843: AND
19844: IFFALSE 19890
// begin retreat := true ;
19846: LD_ADDR_VAR 0 4
19850: PUSH
19851: LD_INT 1
19853: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19854: LD_VAR 0 1
19858: PPUSH
19859: LD_INT 2
19861: PPUSH
19862: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19866: LD_VAR 0 1
19870: PPUSH
19871: LD_STRING D4a-Sol1-1
19873: PPUSH
19874: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19878: LD_EXP 58
19882: PPUSH
19883: LD_STRING D4a-Pow-1
19885: PPUSH
19886: CALL_OW 88
// end ; end ; end ;
19890: GO 19755
19892: POP
19893: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19894: LD_EXP 18
19898: PUSH
19899: LD_INT 1
19901: ARRAY
19902: PPUSH
19903: LD_INT 95
19905: PUSH
19906: LD_INT 9
19908: PUSH
19909: EMPTY
19910: LIST
19911: LIST
19912: PUSH
19913: LD_INT 3
19915: PUSH
19916: LD_INT 55
19918: PUSH
19919: EMPTY
19920: LIST
19921: PUSH
19922: EMPTY
19923: LIST
19924: LIST
19925: PUSH
19926: EMPTY
19927: LIST
19928: LIST
19929: PPUSH
19930: CALL_OW 72
19934: PUSH
19935: LD_INT 4
19937: GREATEREQUAL
19938: IFFALSE 19734
// for i in powellSquadAttack [ 1 ] do
19940: LD_ADDR_VAR 0 1
19944: PUSH
19945: LD_EXP 18
19949: PUSH
19950: LD_INT 1
19952: ARRAY
19953: PUSH
19954: FOR_IN
19955: IFFALSE 20091
// begin if GetTag ( i ) = 2 then
19957: LD_VAR 0 1
19961: PPUSH
19962: CALL_OW 110
19966: PUSH
19967: LD_INT 2
19969: EQUAL
19970: IFFALSE 20032
// begin ComMoveXY ( i , 60 , 94 ) ;
19972: LD_VAR 0 1
19976: PPUSH
19977: LD_INT 60
19979: PPUSH
19980: LD_INT 94
19982: PPUSH
19983: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19987: LD_VAR 0 1
19991: PPUSH
19992: LD_EXP 58
19996: PPUSH
19997: CALL_OW 179
// wait ( 0 0$3 ) ;
20001: LD_INT 105
20003: PPUSH
20004: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
20008: LD_VAR 0 1
20012: PPUSH
20013: LD_STRING D4a-Sol1-2
20015: PPUSH
20016: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
20020: LD_EXP 58
20024: PPUSH
20025: LD_STRING D4a-Pow-2
20027: PPUSH
20028: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
20032: LD_VAR 0 1
20036: PPUSH
20037: LD_INT 0
20039: PPUSH
20040: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20044: LD_ADDR_EXP 116
20048: PUSH
20049: LD_EXP 116
20053: PPUSH
20054: LD_INT 4
20056: PPUSH
20057: LD_EXP 116
20061: PUSH
20062: LD_INT 4
20064: ARRAY
20065: PUSH
20066: LD_VAR 0 1
20070: UNION
20071: PPUSH
20072: CALL_OW 1
20076: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20077: LD_INT 8
20079: PPUSH
20080: LD_VAR 0 1
20084: PPUSH
20085: CALL_OW 472
// end ;
20089: GO 19954
20091: POP
20092: POP
// wait ( 4 4$00 ) ;
20093: LD_INT 8400
20095: PPUSH
20096: CALL_OW 67
// uc_side := 6 ;
20100: LD_ADDR_OWVAR 20
20104: PUSH
20105: LD_INT 6
20107: ST_TO_ADDR
// uc_nation := 3 ;
20108: LD_ADDR_OWVAR 21
20112: PUSH
20113: LD_INT 3
20115: ST_TO_ADDR
// ru := [ ] ;
20116: LD_ADDR_VAR 0 7
20120: PUSH
20121: EMPTY
20122: ST_TO_ADDR
// for i = 1 to 4 do
20123: LD_ADDR_VAR 0 1
20127: PUSH
20128: DOUBLE
20129: LD_INT 1
20131: DEC
20132: ST_TO_ADDR
20133: LD_INT 4
20135: PUSH
20136: FOR_TO
20137: IFFALSE 20238
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20139: LD_INT 22
20141: PPUSH
20142: LD_INT 1
20144: PPUSH
20145: LD_INT 3
20147: PPUSH
20148: LD_INT 43
20150: PUSH
20151: LD_INT 44
20153: PUSH
20154: EMPTY
20155: LIST
20156: LIST
20157: PUSH
20158: LD_INT 1
20160: PPUSH
20161: LD_INT 2
20163: PPUSH
20164: CALL_OW 12
20168: ARRAY
20169: PPUSH
20170: LD_INT 89
20172: PPUSH
20173: CALL 70486 0 5
// un := CreateVehicle ;
20177: LD_ADDR_VAR 0 8
20181: PUSH
20182: CALL_OW 45
20186: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20187: LD_VAR 0 8
20191: PPUSH
20192: LD_INT 4
20194: PPUSH
20195: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20199: LD_VAR 0 8
20203: PPUSH
20204: LD_INT 136
20206: PPUSH
20207: LD_INT 90
20209: PPUSH
20210: LD_INT 8
20212: PPUSH
20213: LD_INT 0
20215: PPUSH
20216: CALL_OW 50
// ru := ru ^ un ;
20220: LD_ADDR_VAR 0 7
20224: PUSH
20225: LD_VAR 0 7
20229: PUSH
20230: LD_VAR 0 8
20234: ADD
20235: ST_TO_ADDR
// end ;
20236: GO 20136
20238: POP
20239: POP
// if ru then
20240: LD_VAR 0 7
20244: IFFALSE 20261
// ComAgressiveMove ( ru , 80 , 92 ) ;
20246: LD_VAR 0 7
20250: PPUSH
20251: LD_INT 80
20253: PPUSH
20254: LD_INT 92
20256: PPUSH
20257: CALL_OW 114
// wait ( 8 8$00 ) ;
20261: LD_INT 16800
20263: PPUSH
20264: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20268: LD_INT 4
20270: PPUSH
20271: LD_INT 3
20273: PUSH
20274: LD_INT 1
20276: PUSH
20277: LD_INT 1
20279: PUSH
20280: LD_INT 5
20282: PUSH
20283: EMPTY
20284: LIST
20285: LIST
20286: LIST
20287: LIST
20288: PUSH
20289: LD_INT 4
20291: PUSH
20292: LD_INT 1
20294: PUSH
20295: LD_INT 1
20297: PUSH
20298: LD_INT 6
20300: PUSH
20301: EMPTY
20302: LIST
20303: LIST
20304: LIST
20305: LIST
20306: PUSH
20307: LD_INT 4
20309: PUSH
20310: LD_INT 1
20312: PUSH
20313: LD_INT 1
20315: PUSH
20316: LD_INT 7
20318: PUSH
20319: EMPTY
20320: LIST
20321: LIST
20322: LIST
20323: LIST
20324: PUSH
20325: LD_INT 3
20327: PUSH
20328: LD_INT 1
20330: PUSH
20331: LD_INT 1
20333: PUSH
20334: LD_INT 7
20336: PUSH
20337: EMPTY
20338: LIST
20339: LIST
20340: LIST
20341: LIST
20342: PUSH
20343: LD_INT 3
20345: PUSH
20346: LD_INT 1
20348: PUSH
20349: LD_INT 1
20351: PUSH
20352: LD_INT 5
20354: PUSH
20355: EMPTY
20356: LIST
20357: LIST
20358: LIST
20359: LIST
20360: PUSH
20361: EMPTY
20362: LIST
20363: LIST
20364: LIST
20365: LIST
20366: LIST
20367: PPUSH
20368: CALL 59168 0 2
// missionStage := 4 ;
20372: LD_ADDR_EXP 15
20376: PUSH
20377: LD_INT 4
20379: ST_TO_ADDR
// end ;
20380: PPOPN 8
20382: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20383: LD_EXP 15
20387: PUSH
20388: LD_INT 4
20390: EQUAL
20391: PUSH
20392: LD_INT 22
20394: PUSH
20395: LD_INT 4
20397: PUSH
20398: EMPTY
20399: LIST
20400: LIST
20401: PUSH
20402: LD_INT 21
20404: PUSH
20405: LD_INT 2
20407: PUSH
20408: EMPTY
20409: LIST
20410: LIST
20411: PUSH
20412: EMPTY
20413: LIST
20414: LIST
20415: PPUSH
20416: CALL_OW 69
20420: PUSH
20421: LD_INT 5
20423: GREATEREQUAL
20424: AND
20425: IFFALSE 24530
20427: GO 20429
20429: DISABLE
20430: LD_INT 0
20432: PPUSH
20433: PPUSH
20434: PPUSH
20435: PPUSH
20436: PPUSH
20437: PPUSH
20438: PPUSH
20439: PPUSH
20440: PPUSH
20441: PPUSH
20442: PPUSH
20443: PPUSH
20444: PPUSH
// begin missionStage := 5 ;
20445: LD_ADDR_EXP 15
20449: PUSH
20450: LD_INT 5
20452: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20453: LD_ADDR_VAR 0 10
20457: PUSH
20458: LD_INT 22
20460: PUSH
20461: LD_INT 4
20463: PUSH
20464: EMPTY
20465: LIST
20466: LIST
20467: PUSH
20468: LD_INT 2
20470: PUSH
20471: LD_INT 30
20473: PUSH
20474: LD_INT 4
20476: PUSH
20477: EMPTY
20478: LIST
20479: LIST
20480: PUSH
20481: LD_INT 30
20483: PUSH
20484: LD_INT 5
20486: PUSH
20487: EMPTY
20488: LIST
20489: LIST
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: LIST
20495: PUSH
20496: EMPTY
20497: LIST
20498: LIST
20499: PPUSH
20500: CALL_OW 69
20504: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20505: LD_ADDR_VAR 0 6
20509: PUSH
20510: LD_INT 22
20512: PUSH
20513: LD_INT 4
20515: PUSH
20516: EMPTY
20517: LIST
20518: LIST
20519: PUSH
20520: LD_INT 21
20522: PUSH
20523: LD_INT 1
20525: PUSH
20526: EMPTY
20527: LIST
20528: LIST
20529: PUSH
20530: LD_INT 3
20532: PUSH
20533: LD_INT 25
20535: PUSH
20536: LD_INT 16
20538: PUSH
20539: EMPTY
20540: LIST
20541: LIST
20542: PUSH
20543: EMPTY
20544: LIST
20545: LIST
20546: PUSH
20547: LD_INT 3
20549: PUSH
20550: LD_INT 25
20552: PUSH
20553: LD_INT 12
20555: PUSH
20556: EMPTY
20557: LIST
20558: LIST
20559: PUSH
20560: EMPTY
20561: LIST
20562: LIST
20563: PUSH
20564: EMPTY
20565: LIST
20566: LIST
20567: LIST
20568: LIST
20569: PPUSH
20570: CALL_OW 69
20574: PUSH
20575: LD_EXP 58
20579: DIFF
20580: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20581: LD_ADDR_VAR 0 9
20585: PUSH
20586: LD_INT 22
20588: PUSH
20589: LD_INT 4
20591: PUSH
20592: EMPTY
20593: LIST
20594: LIST
20595: PUSH
20596: LD_INT 30
20598: PUSH
20599: LD_INT 3
20601: PUSH
20602: EMPTY
20603: LIST
20604: LIST
20605: PUSH
20606: EMPTY
20607: LIST
20608: LIST
20609: PPUSH
20610: CALL_OW 69
20614: PUSH
20615: LD_INT 1
20617: ARRAY
20618: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20619: LD_INT 35
20621: PPUSH
20622: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20626: LD_EXP 135
20630: PUSH
20631: LD_INT 4
20633: ARRAY
20634: PUSH
20635: LD_INT 5
20637: GREATEREQUAL
20638: PUSH
20639: LD_EXP 135
20643: PUSH
20644: LD_INT 4
20646: ARRAY
20647: PPUSH
20648: LD_INT 58
20650: PUSH
20651: EMPTY
20652: LIST
20653: PPUSH
20654: CALL_OW 72
20658: PUSH
20659: LD_INT 5
20661: GREATEREQUAL
20662: AND
20663: IFFALSE 20619
// powellAllowRetreat := false ;
20665: LD_ADDR_EXP 19
20669: PUSH
20670: LD_INT 0
20672: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20673: LD_INT 700
20675: PPUSH
20676: CALL_OW 67
// activeAttacks := false ;
20680: LD_ADDR_EXP 16
20684: PUSH
20685: LD_INT 0
20687: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20688: LD_INT 35
20690: PPUSH
20691: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20695: LD_INT 22
20697: PUSH
20698: LD_INT 6
20700: PUSH
20701: EMPTY
20702: LIST
20703: LIST
20704: PPUSH
20705: CALL_OW 69
20709: PUSH
20710: LD_INT 0
20712: EQUAL
20713: IFFALSE 20688
// tmp := mc_vehicles [ 4 ] ;
20715: LD_ADDR_VAR 0 3
20719: PUSH
20720: LD_EXP 135
20724: PUSH
20725: LD_INT 4
20727: ARRAY
20728: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20729: LD_ADDR_VAR 0 1
20733: PUSH
20734: DOUBLE
20735: LD_INT 1
20737: DEC
20738: ST_TO_ADDR
20739: LD_EXP 18
20743: PUSH
20744: FOR_TO
20745: IFFALSE 21006
// begin for j in powellSquadAttack [ i ] do
20747: LD_ADDR_VAR 0 2
20751: PUSH
20752: LD_EXP 18
20756: PUSH
20757: LD_VAR 0 1
20761: ARRAY
20762: PUSH
20763: FOR_IN
20764: IFFALSE 21002
// begin forces := forces diff j ;
20766: LD_ADDR_VAR 0 6
20770: PUSH
20771: LD_VAR 0 6
20775: PUSH
20776: LD_VAR 0 2
20780: DIFF
20781: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20782: LD_VAR 0 2
20786: PPUSH
20787: LD_INT 1
20789: PPUSH
20790: CALL_OW 109
// wait ( 0 0$2 ) ;
20794: LD_INT 70
20796: PPUSH
20797: CALL_OW 67
// if IsInUnit ( j ) then
20801: LD_VAR 0 2
20805: PPUSH
20806: CALL_OW 310
20810: IFFALSE 20821
// ComExitBuilding ( j ) ;
20812: LD_VAR 0 2
20816: PPUSH
20817: CALL_OW 122
// if GetClass ( j ) <> 1 then
20821: LD_VAR 0 2
20825: PPUSH
20826: CALL_OW 257
20830: PUSH
20831: LD_INT 1
20833: NONEQUAL
20834: IFFALSE 20914
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20836: LD_VAR 0 10
20840: PUSH
20841: LD_INT 1
20843: ARRAY
20844: PPUSH
20845: CALL_OW 313
20849: PUSH
20850: LD_INT 5
20852: GREATEREQUAL
20853: IFFALSE 20875
// AddComEnterUnit ( j , arm [ 2 ] ) else
20855: LD_VAR 0 2
20859: PPUSH
20860: LD_VAR 0 10
20864: PUSH
20865: LD_INT 2
20867: ARRAY
20868: PPUSH
20869: CALL_OW 180
20873: GO 20893
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20875: LD_VAR 0 2
20879: PPUSH
20880: LD_VAR 0 10
20884: PUSH
20885: LD_INT 1
20887: ARRAY
20888: PPUSH
20889: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20893: LD_VAR 0 2
20897: PPUSH
20898: LD_INT 1
20900: PPUSH
20901: CALL_OW 183
// AddComExitBuilding ( j ) ;
20905: LD_VAR 0 2
20909: PPUSH
20910: CALL_OW 182
// end ; if i = 2 then
20914: LD_VAR 0 1
20918: PUSH
20919: LD_INT 2
20921: EQUAL
20922: IFFALSE 20939
// AddComMoveXY ( j , 61 , 93 ) ;
20924: LD_VAR 0 2
20928: PPUSH
20929: LD_INT 61
20931: PPUSH
20932: LD_INT 93
20934: PPUSH
20935: CALL_OW 171
// if i = 1 then
20939: LD_VAR 0 1
20943: PUSH
20944: LD_INT 1
20946: EQUAL
20947: IFFALSE 21000
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20949: LD_VAR 0 2
20953: PPUSH
20954: LD_VAR 0 3
20958: PUSH
20959: LD_INT 1
20961: ARRAY
20962: PPUSH
20963: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20967: LD_ADDR_VAR 0 3
20971: PUSH
20972: LD_VAR 0 3
20976: PPUSH
20977: LD_INT 1
20979: PPUSH
20980: CALL_OW 3
20984: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20985: LD_VAR 0 2
20989: PPUSH
20990: LD_INT 69
20992: PPUSH
20993: LD_INT 94
20995: PPUSH
20996: CALL_OW 171
// end ; end ;
21000: GO 20763
21002: POP
21003: POP
// end ;
21004: GO 20744
21006: POP
21007: POP
// wait ( 0 0$55 ) ;
21008: LD_INT 1925
21010: PPUSH
21011: CALL_OW 67
// MC_Kill ( 4 ) ;
21015: LD_INT 4
21017: PPUSH
21018: CALL 35385 0 1
// tmp := UnitsInside ( fac ) ;
21022: LD_ADDR_VAR 0 3
21026: PUSH
21027: LD_VAR 0 9
21031: PPUSH
21032: CALL_OW 313
21036: ST_TO_ADDR
// if tmp then
21037: LD_VAR 0 3
21041: IFFALSE 21162
// for i in tmp do
21043: LD_ADDR_VAR 0 1
21047: PUSH
21048: LD_VAR 0 3
21052: PUSH
21053: FOR_IN
21054: IFFALSE 21160
// begin ComExitBuilding ( i ) ;
21056: LD_VAR 0 1
21060: PPUSH
21061: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21065: LD_VAR 0 10
21069: PUSH
21070: LD_INT 2
21072: ARRAY
21073: PPUSH
21074: CALL_OW 313
21078: PUSH
21079: LD_INT 6
21081: LESS
21082: IFFALSE 21104
// AddComEnterUnit ( i , arm [ 2 ] ) else
21084: LD_VAR 0 1
21088: PPUSH
21089: LD_VAR 0 10
21093: PUSH
21094: LD_INT 2
21096: ARRAY
21097: PPUSH
21098: CALL_OW 180
21102: GO 21158
// if UnitsInside ( arm [ 1 ] ) < 6 then
21104: LD_VAR 0 10
21108: PUSH
21109: LD_INT 1
21111: ARRAY
21112: PPUSH
21113: CALL_OW 313
21117: PUSH
21118: LD_INT 6
21120: LESS
21121: IFFALSE 21143
// AddComEnterUnit ( i , arm [ 1 ] ) else
21123: LD_VAR 0 1
21127: PPUSH
21128: LD_VAR 0 10
21132: PUSH
21133: LD_INT 1
21135: ARRAY
21136: PPUSH
21137: CALL_OW 180
21141: GO 21158
// AddComMoveXY ( i , 37 , 68 ) ;
21143: LD_VAR 0 1
21147: PPUSH
21148: LD_INT 37
21150: PPUSH
21151: LD_INT 68
21153: PPUSH
21154: CALL_OW 171
// end ;
21158: GO 21053
21160: POP
21161: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21162: LD_ADDR_VAR 0 11
21166: PUSH
21167: LD_VAR 0 6
21171: PPUSH
21172: LD_INT 26
21174: PUSH
21175: LD_INT 1
21177: PUSH
21178: EMPTY
21179: LIST
21180: LIST
21181: PPUSH
21182: CALL_OW 72
21186: PUSH
21187: LD_EXP 59
21191: DIFF
21192: ST_TO_ADDR
// if not speaker then
21193: LD_VAR 0 11
21197: NOT
21198: IFFALSE 21225
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21200: LD_ADDR_VAR 0 11
21204: PUSH
21205: LD_VAR 0 6
21209: PPUSH
21210: LD_INT 26
21212: PUSH
21213: LD_INT 1
21215: PUSH
21216: EMPTY
21217: LIST
21218: LIST
21219: PPUSH
21220: CALL_OW 72
21224: ST_TO_ADDR
// if speaker then
21225: LD_VAR 0 11
21229: IFFALSE 21245
// speaker := speaker [ 1 ] ;
21231: LD_ADDR_VAR 0 11
21235: PUSH
21236: LD_VAR 0 11
21240: PUSH
21241: LD_INT 1
21243: ARRAY
21244: ST_TO_ADDR
// Video ( true ) ;
21245: LD_INT 1
21247: PPUSH
21248: CALL 102331 0 1
// CenterNowOnUnits ( Powell ) ;
21252: LD_EXP 58
21256: PPUSH
21257: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21261: LD_ADDR_VAR 0 3
21265: PUSH
21266: LD_VAR 0 6
21270: PPUSH
21271: LD_INT 3
21273: PUSH
21274: LD_INT 25
21276: PUSH
21277: LD_INT 1
21279: PUSH
21280: EMPTY
21281: LIST
21282: LIST
21283: PUSH
21284: EMPTY
21285: LIST
21286: LIST
21287: PPUSH
21288: CALL_OW 72
21292: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21293: LD_ADDR_VAR 0 12
21297: PUSH
21298: LD_INT 22
21300: PUSH
21301: LD_INT 4
21303: PUSH
21304: EMPTY
21305: LIST
21306: LIST
21307: PUSH
21308: LD_INT 30
21310: PUSH
21311: LD_INT 32
21313: PUSH
21314: EMPTY
21315: LIST
21316: LIST
21317: PUSH
21318: LD_INT 58
21320: PUSH
21321: EMPTY
21322: LIST
21323: PUSH
21324: EMPTY
21325: LIST
21326: LIST
21327: LIST
21328: PPUSH
21329: CALL_OW 69
21333: ST_TO_ADDR
// for i = 1 to 6 do
21334: LD_ADDR_VAR 0 1
21338: PUSH
21339: DOUBLE
21340: LD_INT 1
21342: DEC
21343: ST_TO_ADDR
21344: LD_INT 6
21346: PUSH
21347: FOR_TO
21348: IFFALSE 21489
// begin if IsInUnit ( tmp [ i ] ) then
21350: LD_VAR 0 3
21354: PUSH
21355: LD_VAR 0 1
21359: ARRAY
21360: PPUSH
21361: CALL_OW 310
21365: IFFALSE 21382
// ComExitBuilding ( tmp [ i ] ) ;
21367: LD_VAR 0 3
21371: PUSH
21372: LD_VAR 0 1
21376: ARRAY
21377: PPUSH
21378: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21382: LD_VAR 0 3
21386: PUSH
21387: LD_VAR 0 1
21391: ARRAY
21392: PPUSH
21393: LD_VAR 0 10
21397: PUSH
21398: LD_INT 1
21400: ARRAY
21401: PPUSH
21402: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21406: LD_VAR 0 3
21410: PUSH
21411: LD_VAR 0 1
21415: ARRAY
21416: PPUSH
21417: LD_INT 1
21419: PPUSH
21420: CALL_OW 183
// if emp_towers then
21424: LD_VAR 0 12
21428: IFFALSE 21487
// begin AddComExitBuilding ( tmp [ i ] ) ;
21430: LD_VAR 0 3
21434: PUSH
21435: LD_VAR 0 1
21439: ARRAY
21440: PPUSH
21441: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21445: LD_VAR 0 3
21449: PUSH
21450: LD_VAR 0 1
21454: ARRAY
21455: PPUSH
21456: LD_VAR 0 12
21460: PUSH
21461: LD_INT 1
21463: ARRAY
21464: PPUSH
21465: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21469: LD_ADDR_VAR 0 12
21473: PUSH
21474: LD_VAR 0 12
21478: PPUSH
21479: LD_INT 1
21481: PPUSH
21482: CALL_OW 3
21486: ST_TO_ADDR
// end ; end ;
21487: GO 21347
21489: POP
21490: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21491: LD_ADDR_VAR 0 3
21495: PUSH
21496: LD_EXP 18
21500: PUSH
21501: LD_INT 1
21503: ARRAY
21504: PUSH
21505: LD_EXP 18
21509: PUSH
21510: LD_INT 2
21512: ARRAY
21513: ADD
21514: PPUSH
21515: LD_INT 26
21517: PUSH
21518: LD_INT 1
21520: PUSH
21521: EMPTY
21522: LIST
21523: LIST
21524: PPUSH
21525: CALL_OW 72
21529: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21530: LD_ADDR_VAR 0 1
21534: PUSH
21535: LD_EXP 18
21539: PUSH
21540: LD_INT 2
21542: ARRAY
21543: PUSH
21544: FOR_IN
21545: IFFALSE 21563
// ComTurnUnit ( i , Powell ) ;
21547: LD_VAR 0 1
21551: PPUSH
21552: LD_EXP 58
21556: PPUSH
21557: CALL_OW 119
21561: GO 21544
21563: POP
21564: POP
// Say ( Powell , D5-Pow-1 ) ;
21565: LD_EXP 58
21569: PPUSH
21570: LD_STRING D5-Pow-1
21572: PPUSH
21573: CALL_OW 88
// if tmp then
21577: LD_VAR 0 3
21581: IFFALSE 21599
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21583: LD_VAR 0 3
21587: PUSH
21588: LD_INT 1
21590: ARRAY
21591: PPUSH
21592: LD_STRING D5-Sol2-1
21594: PPUSH
21595: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21599: LD_EXP 58
21603: PPUSH
21604: LD_STRING D5-Pow-2
21606: PPUSH
21607: CALL_OW 88
// if tmp > 1 then
21611: LD_VAR 0 3
21615: PUSH
21616: LD_INT 1
21618: GREATER
21619: IFFALSE 21637
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21621: LD_VAR 0 3
21625: PUSH
21626: LD_INT 2
21628: ARRAY
21629: PPUSH
21630: LD_STRING D5-Sol2-2
21632: PPUSH
21633: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21637: LD_EXP 58
21641: PPUSH
21642: LD_STRING D5-Pow-3
21644: PPUSH
21645: CALL_OW 88
// wait ( 0 0$1 ) ;
21649: LD_INT 35
21651: PPUSH
21652: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21656: LD_ADDR_VAR 0 3
21660: PUSH
21661: LD_EXP 18
21665: PUSH
21666: LD_INT 1
21668: ARRAY
21669: PUSH
21670: LD_EXP 18
21674: PUSH
21675: LD_INT 2
21677: ARRAY
21678: UNION
21679: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21680: LD_VAR 0 3
21684: PPUSH
21685: LD_INT 80
21687: PPUSH
21688: LD_INT 67
21690: PPUSH
21691: CALL_OW 114
// wait ( 0 0$2 ) ;
21695: LD_INT 70
21697: PPUSH
21698: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21702: LD_INT 79
21704: PPUSH
21705: LD_INT 72
21707: PPUSH
21708: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21712: LD_INT 35
21714: PPUSH
21715: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21719: LD_VAR 0 3
21723: PPUSH
21724: LD_INT 3
21726: PUSH
21727: LD_INT 24
21729: PUSH
21730: LD_INT 1000
21732: PUSH
21733: EMPTY
21734: LIST
21735: LIST
21736: PUSH
21737: EMPTY
21738: LIST
21739: LIST
21740: PPUSH
21741: CALL_OW 72
21745: IFFALSE 21712
// Say ( Powell , D5a-Pow-1 ) ;
21747: LD_EXP 58
21751: PPUSH
21752: LD_STRING D5a-Pow-1
21754: PPUSH
21755: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21759: LD_EXP 58
21763: PPUSH
21764: LD_STRING D5a-Pow-1a
21766: PPUSH
21767: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21771: LD_INT 10
21773: PPUSH
21774: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21778: LD_EXP 58
21782: PPUSH
21783: LD_STRING D5a-Pow-1b
21785: PPUSH
21786: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21790: LD_EXP 58
21794: PPUSH
21795: LD_STRING D5a-Pow-1c
21797: PPUSH
21798: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21802: LD_EXP 58
21806: PPUSH
21807: LD_STRING D5a-Pow-1d
21809: PPUSH
21810: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21814: LD_INT 35
21816: PPUSH
21817: CALL_OW 67
// if not HasTask ( tmp ) then
21821: LD_VAR 0 3
21825: PPUSH
21826: CALL_OW 314
21830: NOT
21831: IFFALSE 21848
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21833: LD_VAR 0 3
21837: PPUSH
21838: LD_INT 80
21840: PPUSH
21841: LD_INT 67
21843: PPUSH
21844: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21848: LD_VAR 0 3
21852: PPUSH
21853: LD_INT 24
21855: PUSH
21856: LD_INT 1
21858: PUSH
21859: EMPTY
21860: LIST
21861: LIST
21862: PPUSH
21863: CALL_OW 72
21867: NOT
21868: IFFALSE 21814
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21870: LD_ADDR_VAR 0 3
21874: PUSH
21875: LD_INT 22
21877: PUSH
21878: LD_INT 4
21880: PUSH
21881: EMPTY
21882: LIST
21883: LIST
21884: PUSH
21885: LD_INT 92
21887: PUSH
21888: LD_INT 60
21890: PUSH
21891: LD_INT 93
21893: PUSH
21894: LD_INT 10
21896: PUSH
21897: EMPTY
21898: LIST
21899: LIST
21900: LIST
21901: LIST
21902: PUSH
21903: LD_INT 3
21905: PUSH
21906: LD_INT 54
21908: PUSH
21909: EMPTY
21910: LIST
21911: PUSH
21912: EMPTY
21913: LIST
21914: LIST
21915: PUSH
21916: EMPTY
21917: LIST
21918: LIST
21919: LIST
21920: PPUSH
21921: CALL_OW 69
21925: PUSH
21926: LD_EXP 58
21930: DIFF
21931: ST_TO_ADDR
// if tmp then
21932: LD_VAR 0 3
21936: IFFALSE 21970
// for i in tmp do
21938: LD_ADDR_VAR 0 1
21942: PUSH
21943: LD_VAR 0 3
21947: PUSH
21948: FOR_IN
21949: IFFALSE 21968
// ComMoveXY ( i , 36 , 67 ) ;
21951: LD_VAR 0 1
21955: PPUSH
21956: LD_INT 36
21958: PPUSH
21959: LD_INT 67
21961: PPUSH
21962: CALL_OW 111
21966: GO 21948
21968: POP
21969: POP
// wait ( 0 0$3 ) ;
21970: LD_INT 105
21972: PPUSH
21973: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21977: LD_VAR 0 11
21981: PPUSH
21982: LD_STRING D6-Sol3-1
21984: PPUSH
21985: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21989: LD_EXP 58
21993: PPUSH
21994: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21998: LD_EXP 58
22002: PPUSH
22003: LD_STRING D6-Pow-1
22005: PPUSH
22006: CALL_OW 88
// tmp := [ ] ;
22010: LD_ADDR_VAR 0 3
22014: PUSH
22015: EMPTY
22016: ST_TO_ADDR
// for i = 1 to 2 do
22017: LD_ADDR_VAR 0 1
22021: PUSH
22022: DOUBLE
22023: LD_INT 1
22025: DEC
22026: ST_TO_ADDR
22027: LD_INT 2
22029: PUSH
22030: FOR_TO
22031: IFFALSE 22145
// begin uc_side := 8 ;
22033: LD_ADDR_OWVAR 20
22037: PUSH
22038: LD_INT 8
22040: ST_TO_ADDR
// uc_nation := 2 ;
22041: LD_ADDR_OWVAR 21
22045: PUSH
22046: LD_INT 2
22048: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22049: LD_INT 14
22051: PPUSH
22052: LD_INT 3
22054: PPUSH
22055: LD_INT 2
22057: PPUSH
22058: LD_INT 29
22060: PPUSH
22061: LD_INT 100
22063: PPUSH
22064: CALL 70486 0 5
// veh := CreateVehicle ;
22068: LD_ADDR_VAR 0 13
22072: PUSH
22073: CALL_OW 45
22077: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22078: LD_VAR 0 13
22082: PPUSH
22083: LD_INT 4
22085: PPUSH
22086: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22090: LD_VAR 0 13
22094: PPUSH
22095: LD_INT 99
22097: PPUSH
22098: LD_INT 83
22100: PPUSH
22101: LD_INT 6
22103: PPUSH
22104: LD_INT 0
22106: PPUSH
22107: CALL_OW 50
// wait ( 3 ) ;
22111: LD_INT 3
22113: PPUSH
22114: CALL_OW 67
// Connect ( veh ) ;
22118: LD_VAR 0 13
22122: PPUSH
22123: CALL 73579 0 1
// tmp := tmp ^ veh ;
22127: LD_ADDR_VAR 0 3
22131: PUSH
22132: LD_VAR 0 3
22136: PUSH
22137: LD_VAR 0 13
22141: ADD
22142: ST_TO_ADDR
// end ;
22143: GO 22030
22145: POP
22146: POP
// wait ( 0 0$1 ) ;
22147: LD_INT 35
22149: PPUSH
22150: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22154: LD_INT 99
22156: PPUSH
22157: LD_INT 83
22159: PPUSH
22160: LD_INT 1
22162: PPUSH
22163: LD_INT 10
22165: PPUSH
22166: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22170: LD_INT 99
22172: PPUSH
22173: LD_INT 83
22175: PPUSH
22176: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22180: LD_VAR 0 11
22184: PPUSH
22185: LD_STRING D6-Sol3-2
22187: PPUSH
22188: CALL_OW 88
// async ;
22192: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22193: LD_EXP 58
22197: PPUSH
22198: LD_STRING D6-Pow-2
22200: PPUSH
22201: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22205: LD_VAR 0 3
22209: PUSH
22210: LD_INT 1
22212: ARRAY
22213: PPUSH
22214: LD_VAR 0 9
22218: PPUSH
22219: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22223: LD_VAR 0 3
22227: PUSH
22228: LD_INT 2
22230: ARRAY
22231: PPUSH
22232: LD_INT 22
22234: PUSH
22235: LD_INT 4
22237: PUSH
22238: EMPTY
22239: LIST
22240: LIST
22241: PUSH
22242: LD_INT 21
22244: PUSH
22245: LD_INT 3
22247: PUSH
22248: EMPTY
22249: LIST
22250: LIST
22251: PUSH
22252: EMPTY
22253: LIST
22254: LIST
22255: PPUSH
22256: CALL_OW 69
22260: PPUSH
22261: LD_VAR 0 3
22265: PUSH
22266: LD_INT 2
22268: ARRAY
22269: PPUSH
22270: CALL_OW 74
22274: PPUSH
22275: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22279: LD_EXP 58
22283: PPUSH
22284: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22288: LD_INT 99
22290: PPUSH
22291: LD_INT 83
22293: PPUSH
22294: LD_INT 1
22296: PPUSH
22297: CALL_OW 331
// repeat wait ( 4 ) ;
22301: LD_INT 4
22303: PPUSH
22304: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22308: LD_VAR 0 3
22312: PUSH
22313: LD_INT 1
22315: ARRAY
22316: PPUSH
22317: CALL_OW 256
22321: PUSH
22322: LD_INT 1000
22324: LESS
22325: IFFALSE 22343
// SetLives ( tmp [ 1 ] , 1000 ) ;
22327: LD_VAR 0 3
22331: PUSH
22332: LD_INT 1
22334: ARRAY
22335: PPUSH
22336: LD_INT 1000
22338: PPUSH
22339: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22343: LD_INT 22
22345: PUSH
22346: LD_INT 4
22348: PUSH
22349: EMPTY
22350: LIST
22351: LIST
22352: PUSH
22353: LD_INT 30
22355: PUSH
22356: LD_INT 3
22358: PUSH
22359: EMPTY
22360: LIST
22361: LIST
22362: PUSH
22363: EMPTY
22364: LIST
22365: LIST
22366: PPUSH
22367: CALL_OW 69
22371: PUSH
22372: LD_INT 0
22374: EQUAL
22375: IFFALSE 22301
// sync ;
22377: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22378: LD_EXP 58
22382: PPUSH
22383: LD_STRING D6a-Pow-1
22385: PPUSH
22386: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22390: LD_VAR 0 11
22394: PPUSH
22395: LD_STRING D6a-Sol3-1
22397: PPUSH
22398: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22402: LD_EXP 58
22406: PPUSH
22407: LD_STRING D6a-Pow-2
22409: PPUSH
22410: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22414: LD_VAR 0 11
22418: PPUSH
22419: LD_STRING D6a-Sol3-2
22421: PPUSH
22422: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22426: LD_EXP 58
22430: PPUSH
22431: LD_STRING D6a-Pow-3
22433: PPUSH
22434: CALL_OW 88
// powellCenterCameraMode := true ;
22438: LD_ADDR_EXP 20
22442: PUSH
22443: LD_INT 1
22445: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22446: LD_ADDR_VAR 0 1
22450: PUSH
22451: LD_INT 22
22453: PUSH
22454: LD_INT 8
22456: PUSH
22457: EMPTY
22458: LIST
22459: LIST
22460: PUSH
22461: LD_INT 25
22463: PUSH
22464: LD_INT 2
22466: PUSH
22467: EMPTY
22468: LIST
22469: LIST
22470: PUSH
22471: EMPTY
22472: LIST
22473: LIST
22474: PPUSH
22475: CALL_OW 69
22479: PUSH
22480: FOR_IN
22481: IFFALSE 22536
// begin SetTag ( i , 1 ) ;
22483: LD_VAR 0 1
22487: PPUSH
22488: LD_INT 1
22490: PPUSH
22491: CALL_OW 109
// ComExitBuilding ( i ) ;
22495: LD_VAR 0 1
22499: PPUSH
22500: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22504: LD_VAR 0 1
22508: PPUSH
22509: LD_INT 35
22511: PPUSH
22512: LD_INT 6
22514: PPUSH
22515: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22519: LD_VAR 0 1
22523: PPUSH
22524: LD_INT 53
22526: PPUSH
22527: LD_INT 4
22529: PPUSH
22530: CALL_OW 171
// end ;
22534: GO 22480
22536: POP
22537: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22538: LD_ADDR_VAR 0 3
22542: PUSH
22543: LD_INT 22
22545: PUSH
22546: LD_INT 4
22548: PUSH
22549: EMPTY
22550: LIST
22551: LIST
22552: PUSH
22553: LD_INT 21
22555: PUSH
22556: LD_INT 2
22558: PUSH
22559: EMPTY
22560: LIST
22561: LIST
22562: PUSH
22563: LD_INT 3
22565: PUSH
22566: LD_INT 34
22568: PUSH
22569: LD_INT 12
22571: PUSH
22572: EMPTY
22573: LIST
22574: LIST
22575: PUSH
22576: EMPTY
22577: LIST
22578: LIST
22579: PUSH
22580: EMPTY
22581: LIST
22582: LIST
22583: LIST
22584: PPUSH
22585: CALL_OW 69
22589: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22590: LD_EXP 58
22594: PPUSH
22595: LD_VAR 0 3
22599: PPUSH
22600: LD_EXP 58
22604: PPUSH
22605: CALL_OW 74
22609: PPUSH
22610: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22614: LD_EXP 58
22618: PPUSH
22619: LD_INT 100
22621: PPUSH
22622: LD_INT 88
22624: PPUSH
22625: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22629: LD_EXP 58
22633: PPUSH
22634: LD_INT 100
22636: PPUSH
22637: LD_INT 75
22639: PPUSH
22640: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22644: LD_EXP 58
22648: PPUSH
22649: LD_INT 88
22651: PPUSH
22652: LD_INT 53
22654: PPUSH
22655: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22659: LD_INT 8
22661: PPUSH
22662: LD_EXP 58
22666: PPUSH
22667: CALL_OW 471
// repeat wait ( 3 ) ;
22671: LD_INT 3
22673: PPUSH
22674: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22678: LD_INT 22
22680: PUSH
22681: LD_INT 4
22683: PUSH
22684: EMPTY
22685: LIST
22686: LIST
22687: PUSH
22688: LD_INT 92
22690: PUSH
22691: LD_INT 100
22693: PUSH
22694: LD_INT 75
22696: PUSH
22697: LD_INT 6
22699: PUSH
22700: EMPTY
22701: LIST
22702: LIST
22703: LIST
22704: LIST
22705: PUSH
22706: EMPTY
22707: LIST
22708: LIST
22709: PPUSH
22710: CALL_OW 69
22714: IFFALSE 22671
// async ;
22716: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22717: LD_EXP 58
22721: PPUSH
22722: LD_STRING D6b-Pow-1
22724: PPUSH
22725: CALL_OW 88
// repeat wait ( 3 ) ;
22729: LD_INT 3
22731: PPUSH
22732: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22736: LD_EXP 58
22740: PPUSH
22741: CALL_OW 310
22745: PPUSH
22746: CALL_OW 256
22750: PUSH
22751: LD_INT 1000
22753: LESS
22754: IFFALSE 22773
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22756: LD_EXP 58
22760: PPUSH
22761: CALL_OW 310
22765: PPUSH
22766: LD_INT 1000
22768: PPUSH
22769: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22773: LD_EXP 58
22777: PPUSH
22778: CALL_OW 256
22782: PUSH
22783: LD_INT 1000
22785: LESS
22786: IFFALSE 22800
// SetLives ( Powell , 1000 ) ;
22788: LD_EXP 58
22792: PPUSH
22793: LD_INT 1000
22795: PPUSH
22796: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22800: LD_EXP 58
22804: PPUSH
22805: LD_EXP 63
22809: PPUSH
22810: CALL_OW 296
22814: PUSH
22815: LD_INT 5
22817: LESS
22818: PUSH
22819: LD_EXP 58
22823: PPUSH
22824: CALL_OW 310
22828: PPUSH
22829: LD_EXP 63
22833: PPUSH
22834: CALL_OW 296
22838: PUSH
22839: LD_INT 5
22841: LESS
22842: OR
22843: IFFALSE 22862
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22845: LD_EXP 58
22849: PPUSH
22850: CALL_OW 310
22854: PPUSH
22855: LD_INT 100
22857: PPUSH
22858: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22862: LD_EXP 58
22866: PPUSH
22867: CALL_OW 310
22871: NOT
22872: IFFALSE 22729
// DoNotAttack ( 8 , powellBomb ) ;
22874: LD_INT 8
22876: PPUSH
22877: LD_EXP 63
22881: PPUSH
22882: CALL_OW 471
// game_speed := 4 ;
22886: LD_ADDR_OWVAR 65
22890: PUSH
22891: LD_INT 4
22893: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22894: LD_EXP 58
22898: PPUSH
22899: LD_STRING D6b-Pow-1a
22901: PPUSH
22902: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22906: LD_EXP 58
22910: PPUSH
22911: LD_EXP 63
22915: PPUSH
22916: CALL_OW 180
// sync ;
22920: SYNC
// repeat wait ( 0 0$1 ) ;
22921: LD_INT 35
22923: PPUSH
22924: CALL_OW 67
// until IsInUnit ( Powell ) ;
22928: LD_EXP 58
22932: PPUSH
22933: CALL_OW 310
22937: IFFALSE 22921
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22939: LD_INT 8
22941: PPUSH
22942: LD_EXP 58
22946: PPUSH
22947: CALL_OW 310
22951: PPUSH
22952: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22956: LD_EXP 58
22960: PPUSH
22961: LD_INT 91
22963: PPUSH
22964: LD_INT 44
22966: PPUSH
22967: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22971: LD_EXP 58
22975: PPUSH
22976: LD_INT 96
22978: PPUSH
22979: LD_INT 44
22981: PPUSH
22982: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22986: LD_EXP 58
22990: PPUSH
22991: LD_INT 96
22993: PPUSH
22994: LD_INT 41
22996: PPUSH
22997: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23001: LD_EXP 58
23005: PPUSH
23006: LD_INT 92
23008: PPUSH
23009: LD_INT 39
23011: PPUSH
23012: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23016: LD_EXP 58
23020: PPUSH
23021: LD_INT 88
23023: PPUSH
23024: LD_INT 41
23026: PPUSH
23027: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23031: LD_EXP 58
23035: PPUSH
23036: LD_INT 91
23038: PPUSH
23039: LD_INT 44
23041: PPUSH
23042: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23046: LD_EXP 58
23050: PPUSH
23051: LD_INT 96
23053: PPUSH
23054: LD_INT 44
23056: PPUSH
23057: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23061: LD_EXP 58
23065: PPUSH
23066: LD_INT 96
23068: PPUSH
23069: LD_INT 41
23071: PPUSH
23072: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23076: LD_EXP 58
23080: PPUSH
23081: LD_INT 92
23083: PPUSH
23084: LD_INT 39
23086: PPUSH
23087: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23091: LD_EXP 58
23095: PPUSH
23096: LD_INT 88
23098: PPUSH
23099: LD_INT 41
23101: PPUSH
23102: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23106: LD_EXP 58
23110: PPUSH
23111: LD_INT 91
23113: PPUSH
23114: LD_INT 44
23116: PPUSH
23117: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23121: LD_EXP 58
23125: PPUSH
23126: LD_INT 93
23128: PPUSH
23129: LD_INT 39
23131: PPUSH
23132: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23136: LD_EXP 58
23140: PPUSH
23141: LD_INT 93
23143: PPUSH
23144: LD_INT 36
23146: PPUSH
23147: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23151: LD_INT 122
23153: PPUSH
23154: CALL_OW 67
// game_speed := 4 ;
23158: LD_ADDR_OWVAR 65
23162: PUSH
23163: LD_INT 4
23165: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23166: LD_EXP 58
23170: PPUSH
23171: LD_STRING D6b-Pow-1b
23173: PPUSH
23174: CALL_OW 88
// tmp := [ ] ;
23178: LD_ADDR_VAR 0 3
23182: PUSH
23183: EMPTY
23184: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23185: LD_ADDR_VAR 0 5
23189: PUSH
23190: LD_INT 78
23192: PUSH
23193: LD_INT 47
23195: PUSH
23196: EMPTY
23197: LIST
23198: LIST
23199: PUSH
23200: LD_INT 106
23202: PUSH
23203: LD_INT 53
23205: PUSH
23206: EMPTY
23207: LIST
23208: LIST
23209: PUSH
23210: EMPTY
23211: LIST
23212: LIST
23213: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23214: LD_ADDR_VAR 0 1
23218: PUSH
23219: LD_INT 22
23221: PUSH
23222: LD_INT 8
23224: PUSH
23225: EMPTY
23226: LIST
23227: LIST
23228: PUSH
23229: LD_INT 21
23231: PUSH
23232: LD_INT 3
23234: PUSH
23235: EMPTY
23236: LIST
23237: LIST
23238: PUSH
23239: LD_INT 92
23241: PUSH
23242: LD_INT 90
23244: PUSH
23245: LD_INT 52
23247: PUSH
23248: LD_INT 12
23250: PUSH
23251: EMPTY
23252: LIST
23253: LIST
23254: LIST
23255: LIST
23256: PUSH
23257: EMPTY
23258: LIST
23259: LIST
23260: LIST
23261: PPUSH
23262: CALL_OW 69
23266: PUSH
23267: FOR_IN
23268: IFFALSE 23293
// tmp := tmp ^ UnitsInside ( i ) ;
23270: LD_ADDR_VAR 0 3
23274: PUSH
23275: LD_VAR 0 3
23279: PUSH
23280: LD_VAR 0 1
23284: PPUSH
23285: CALL_OW 313
23289: ADD
23290: ST_TO_ADDR
23291: GO 23267
23293: POP
23294: POP
// for i in tmp do
23295: LD_ADDR_VAR 0 1
23299: PUSH
23300: LD_VAR 0 3
23304: PUSH
23305: FOR_IN
23306: IFFALSE 23468
// begin dist := 9999 ;
23308: LD_ADDR_VAR 0 8
23312: PUSH
23313: LD_INT 9999
23315: ST_TO_ADDR
// _xy := [ ] ;
23316: LD_ADDR_VAR 0 7
23320: PUSH
23321: EMPTY
23322: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23323: LD_VAR 0 1
23327: PPUSH
23328: LD_INT 1
23330: PPUSH
23331: CALL_OW 109
// ComExitBuilding ( i ) ;
23335: LD_VAR 0 1
23339: PPUSH
23340: CALL_OW 122
// for j in xy do
23344: LD_ADDR_VAR 0 2
23348: PUSH
23349: LD_VAR 0 5
23353: PUSH
23354: FOR_IN
23355: IFFALSE 23437
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23357: LD_VAR 0 1
23361: PPUSH
23362: LD_VAR 0 2
23366: PUSH
23367: LD_INT 1
23369: ARRAY
23370: PPUSH
23371: LD_VAR 0 2
23375: PUSH
23376: LD_INT 2
23378: ARRAY
23379: PPUSH
23380: CALL_OW 297
23384: PUSH
23385: LD_VAR 0 8
23389: LESS
23390: IFFALSE 23435
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23392: LD_ADDR_VAR 0 8
23396: PUSH
23397: LD_VAR 0 1
23401: PPUSH
23402: LD_VAR 0 2
23406: PUSH
23407: LD_INT 1
23409: ARRAY
23410: PPUSH
23411: LD_VAR 0 2
23415: PUSH
23416: LD_INT 2
23418: ARRAY
23419: PPUSH
23420: CALL_OW 297
23424: ST_TO_ADDR
// _xy := j ;
23425: LD_ADDR_VAR 0 7
23429: PUSH
23430: LD_VAR 0 2
23434: ST_TO_ADDR
// end ;
23435: GO 23354
23437: POP
23438: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23439: LD_VAR 0 1
23443: PPUSH
23444: LD_VAR 0 7
23448: PUSH
23449: LD_INT 1
23451: ARRAY
23452: PPUSH
23453: LD_VAR 0 7
23457: PUSH
23458: LD_INT 2
23460: ARRAY
23461: PPUSH
23462: CALL_OW 171
// end ;
23466: GO 23305
23468: POP
23469: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23470: LD_ADDR_VAR 0 4
23474: PUSH
23475: LD_VAR 0 3
23479: PPUSH
23480: LD_INT 26
23482: PUSH
23483: LD_INT 1
23485: PUSH
23486: EMPTY
23487: LIST
23488: LIST
23489: PUSH
23490: LD_INT 25
23492: PUSH
23493: LD_INT 1
23495: PUSH
23496: EMPTY
23497: LIST
23498: LIST
23499: PUSH
23500: EMPTY
23501: LIST
23502: LIST
23503: PPUSH
23504: CALL_OW 72
23508: ST_TO_ADDR
// if tmp2 < 2 then
23509: LD_VAR 0 4
23513: PUSH
23514: LD_INT 2
23516: LESS
23517: IFFALSE 23586
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23519: LD_ADDR_VAR 0 4
23523: PUSH
23524: LD_INT 22
23526: PUSH
23527: LD_INT 8
23529: PUSH
23530: EMPTY
23531: LIST
23532: LIST
23533: PUSH
23534: LD_INT 26
23536: PUSH
23537: LD_INT 1
23539: PUSH
23540: EMPTY
23541: LIST
23542: LIST
23543: PUSH
23544: LD_INT 3
23546: PUSH
23547: LD_INT 25
23549: PUSH
23550: LD_INT 15
23552: PUSH
23553: EMPTY
23554: LIST
23555: LIST
23556: PUSH
23557: EMPTY
23558: LIST
23559: LIST
23560: PUSH
23561: EMPTY
23562: LIST
23563: LIST
23564: LIST
23565: PPUSH
23566: CALL_OW 69
23570: PUSH
23571: LD_EXP 60
23575: PUSH
23576: LD_EXP 61
23580: PUSH
23581: EMPTY
23582: LIST
23583: LIST
23584: DIFF
23585: ST_TO_ADDR
// if tmp2 then
23586: LD_VAR 0 4
23590: IFFALSE 23608
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23592: LD_VAR 0 4
23596: PUSH
23597: LD_INT 1
23599: ARRAY
23600: PPUSH
23601: LD_STRING D6b-ArSol1-1
23603: PPUSH
23604: CALL_OW 88
// async ;
23608: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23609: LD_EXP 58
23613: PPUSH
23614: LD_STRING D6b-Pow-2
23616: PPUSH
23617: CALL_OW 88
// wait ( 0 0$1 ) ;
23621: LD_INT 35
23623: PPUSH
23624: CALL_OW 67
// if tmp2 > 1 then
23628: LD_VAR 0 4
23632: PUSH
23633: LD_INT 1
23635: GREATER
23636: IFFALSE 23654
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23638: LD_VAR 0 4
23642: PUSH
23643: LD_INT 2
23645: ARRAY
23646: PPUSH
23647: LD_STRING D6b-ArSol2-1
23649: PPUSH
23650: CALL_OW 88
// sync ;
23654: SYNC
// repeat wait ( 5 ) ;
23655: LD_INT 5
23657: PPUSH
23658: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23662: LD_INT 93
23664: PPUSH
23665: LD_INT 36
23667: PPUSH
23668: CALL_OW 428
23672: PPUSH
23673: CALL_OW 255
23677: PUSH
23678: LD_INT 4
23680: EQUAL
23681: IFFALSE 23655
// DialogueOn ;
23683: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23687: LD_INT 10
23689: PPUSH
23690: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23694: LD_EXP 58
23698: PPUSH
23699: LD_STRING D6b-Pow-2a
23701: PPUSH
23702: CALL_OW 88
// DialogueOff ;
23706: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23710: LD_EXP 58
23714: PPUSH
23715: CALL_OW 310
23719: PPUSH
23720: LD_INT 332
23722: PPUSH
23723: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23727: LD_INT 93
23729: PPUSH
23730: LD_INT 35
23732: PPUSH
23733: LD_INT 1
23735: PPUSH
23736: LD_INT 6
23738: NEG
23739: PPUSH
23740: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23744: LD_INT 35
23746: PPUSH
23747: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23751: LD_INT 332
23753: PPUSH
23754: CALL_OW 256
23758: PUSH
23759: LD_INT 1000
23761: LESS
23762: PUSH
23763: LD_INT 332
23765: PPUSH
23766: CALL_OW 300
23770: AND
23771: IFFALSE 23783
// SetLives ( kozlov_fac , 0 ) ;
23773: LD_INT 332
23775: PPUSH
23776: LD_INT 0
23778: PPUSH
23779: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23783: LD_INT 332
23785: PPUSH
23786: CALL_OW 301
23790: PUSH
23791: LD_EXP 58
23795: PPUSH
23796: CALL_OW 301
23800: OR
23801: IFFALSE 23744
// game_speed := 4 ;
23803: LD_ADDR_OWVAR 65
23807: PUSH
23808: LD_INT 4
23810: ST_TO_ADDR
// powellCenterCameraMode := false ;
23811: LD_ADDR_EXP 20
23815: PUSH
23816: LD_INT 0
23818: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23819: LD_ADDR_VAR 0 1
23823: PUSH
23824: LD_VAR 0 3
23828: PUSH
23829: LD_INT 22
23831: PUSH
23832: LD_INT 8
23834: PUSH
23835: EMPTY
23836: LIST
23837: LIST
23838: PUSH
23839: LD_INT 25
23841: PUSH
23842: LD_INT 2
23844: PUSH
23845: EMPTY
23846: LIST
23847: LIST
23848: PUSH
23849: EMPTY
23850: LIST
23851: LIST
23852: PPUSH
23853: CALL_OW 69
23857: UNION
23858: PUSH
23859: FOR_IN
23860: IFFALSE 23876
// SetTag ( i , 0 ) ;
23862: LD_VAR 0 1
23866: PPUSH
23867: LD_INT 0
23869: PPUSH
23870: CALL_OW 109
23874: GO 23859
23876: POP
23877: POP
// wait ( 0 0$3 ) ;
23878: LD_INT 105
23880: PPUSH
23881: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23885: LD_INT 93
23887: PPUSH
23888: LD_INT 35
23890: PPUSH
23891: LD_INT 1
23893: PPUSH
23894: CALL_OW 331
// DialogueOn ;
23898: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23902: LD_VAR 0 11
23906: PPUSH
23907: LD_STRING D6c-Sol3-1
23909: PPUSH
23910: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23914: LD_INT 10
23916: PPUSH
23917: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23921: LD_EXP 39
23925: PPUSH
23926: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23930: LD_EXP 39
23934: PPUSH
23935: LD_STRING D6c-JMM-1
23937: PPUSH
23938: CALL_OW 88
// if Cyrus then
23942: LD_EXP 45
23946: IFFALSE 23960
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23948: LD_EXP 45
23952: PPUSH
23953: LD_STRING D6c-Cyrus-1
23955: PPUSH
23956: CALL_OW 88
// if Bobby then
23960: LD_EXP 44
23964: IFFALSE 23978
// Say ( Bobby , D6c-Bobby-1 ) ;
23966: LD_EXP 44
23970: PPUSH
23971: LD_STRING D6c-Bobby-1
23973: PPUSH
23974: CALL_OW 88
// if Cornel then
23978: LD_EXP 50
23982: IFFALSE 23996
// Say ( Cornel , D6c-Corn-1 ) ;
23984: LD_EXP 50
23988: PPUSH
23989: LD_STRING D6c-Corn-1
23991: PPUSH
23992: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23996: LD_ADDR_VAR 0 4
24000: PUSH
24001: LD_INT 2
24003: PUSH
24004: LD_INT 22
24006: PUSH
24007: LD_INT 1
24009: PUSH
24010: EMPTY
24011: LIST
24012: LIST
24013: PUSH
24014: LD_INT 22
24016: PUSH
24017: LD_INT 4
24019: PUSH
24020: EMPTY
24021: LIST
24022: LIST
24023: PUSH
24024: EMPTY
24025: LIST
24026: LIST
24027: LIST
24028: PUSH
24029: LD_INT 26
24031: PUSH
24032: LD_INT 1
24034: PUSH
24035: EMPTY
24036: LIST
24037: LIST
24038: PUSH
24039: LD_INT 3
24041: PUSH
24042: LD_INT 25
24044: PUSH
24045: LD_INT 16
24047: PUSH
24048: EMPTY
24049: LIST
24050: LIST
24051: PUSH
24052: LD_INT 25
24054: PUSH
24055: LD_INT 12
24057: PUSH
24058: EMPTY
24059: LIST
24060: LIST
24061: PUSH
24062: EMPTY
24063: LIST
24064: LIST
24065: LIST
24066: PUSH
24067: EMPTY
24068: LIST
24069: LIST
24070: LIST
24071: PPUSH
24072: CALL_OW 69
24076: PUSH
24077: LD_VAR 0 11
24081: PUSH
24082: LD_EXP 39
24086: UNION
24087: PUSH
24088: LD_EXP 59
24092: UNION
24093: PUSH
24094: EMPTY
24095: LIST
24096: DIFF
24097: ST_TO_ADDR
// if tmp2 then
24098: LD_VAR 0 4
24102: IFFALSE 24120
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24104: LD_VAR 0 4
24108: PUSH
24109: LD_INT 1
24111: ARRAY
24112: PPUSH
24113: LD_STRING D6c-Sol1-1
24115: PPUSH
24116: CALL_OW 88
// if Lisa then
24120: LD_EXP 42
24124: IFFALSE 24138
// Say ( Lisa , D6c-Lisa-1 ) ;
24126: LD_EXP 42
24130: PPUSH
24131: LD_STRING D6c-Lisa-1
24133: PPUSH
24134: CALL_OW 88
// if Gary then
24138: LD_EXP 51
24142: IFFALSE 24156
// Say ( Gary , D6c-Gary-1 ) ;
24144: LD_EXP 51
24148: PPUSH
24149: LD_STRING D6c-Gary-1
24151: PPUSH
24152: CALL_OW 88
// if Donaldson then
24156: LD_EXP 43
24160: IFFALSE 24174
// Say ( Donaldson , D6c-Don-1 ) ;
24162: LD_EXP 43
24166: PPUSH
24167: LD_STRING D6c-Don-1
24169: PPUSH
24170: CALL_OW 88
// if tmp2 > 1 then
24174: LD_VAR 0 4
24178: PUSH
24179: LD_INT 1
24181: GREATER
24182: IFFALSE 24200
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24184: LD_VAR 0 4
24188: PUSH
24189: LD_INT 2
24191: ARRAY
24192: PPUSH
24193: LD_STRING D6c-Sol2-1
24195: PPUSH
24196: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24200: LD_VAR 0 11
24204: PPUSH
24205: LD_STRING D6c-Sol3-2
24207: PPUSH
24208: CALL_OW 88
// dwait ( 0 0$1 ) ;
24212: LD_INT 35
24214: PPUSH
24215: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24219: LD_EXP 39
24223: PPUSH
24224: LD_STRING D6c-JMM-2
24226: PPUSH
24227: CALL_OW 88
// DialogueOff ;
24231: CALL_OW 7
// Video ( false ) ;
24235: LD_INT 0
24237: PPUSH
24238: CALL 102331 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24242: LD_INT 22
24244: PUSH
24245: LD_INT 4
24247: PUSH
24248: EMPTY
24249: LIST
24250: LIST
24251: PPUSH
24252: CALL_OW 69
24256: PPUSH
24257: LD_INT 1
24259: PPUSH
24260: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24264: LD_INT 4
24266: PPUSH
24267: LD_INT 4
24269: PPUSH
24270: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24274: LD_ADDR_VAR 0 1
24278: PUSH
24279: LD_INT 4
24281: PPUSH
24282: LD_INT 1
24284: PPUSH
24285: LD_INT 2
24287: PPUSH
24288: CALL 65685 0 3
24292: PUSH
24293: FOR_IN
24294: IFFALSE 24331
// if GetTech ( i , 1 ) <> state_researched then
24296: LD_VAR 0 1
24300: PPUSH
24301: LD_INT 1
24303: PPUSH
24304: CALL_OW 321
24308: PUSH
24309: LD_INT 2
24311: NONEQUAL
24312: IFFALSE 24329
// SetTech ( i , 1 , state_researched ) ;
24314: LD_VAR 0 1
24318: PPUSH
24319: LD_INT 1
24321: PPUSH
24322: LD_INT 2
24324: PPUSH
24325: CALL_OW 322
24329: GO 24293
24331: POP
24332: POP
// missionStage := 6 ;
24333: LD_ADDR_EXP 15
24337: PUSH
24338: LD_INT 6
24340: ST_TO_ADDR
// activeAttacks := true ;
24341: LD_ADDR_EXP 16
24345: PUSH
24346: LD_INT 1
24348: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24349: LD_STRING M2
24351: PPUSH
24352: CALL_OW 337
// SaveForQuickRestart ;
24356: CALL_OW 22
// wait ( 0 0$40 ) ;
24360: LD_INT 1400
24362: PPUSH
24363: CALL_OW 67
// DialogueOn ;
24367: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24371: LD_EXP 62
24375: PPUSH
24376: LD_STRING D7-Friend-1
24378: PPUSH
24379: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24383: LD_EXP 39
24387: PPUSH
24388: LD_STRING D7-JMM-1
24390: PPUSH
24391: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24395: LD_EXP 62
24399: PPUSH
24400: LD_STRING D7-Friend-2
24402: PPUSH
24403: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24407: LD_EXP 39
24411: PPUSH
24412: LD_STRING D7-JMM-2
24414: PPUSH
24415: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24419: LD_EXP 62
24423: PPUSH
24424: LD_STRING D7-Friend-3
24426: PPUSH
24427: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24431: LD_EXP 39
24435: PPUSH
24436: LD_STRING D7-JMM-3
24438: PPUSH
24439: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24443: LD_EXP 62
24447: PPUSH
24448: LD_STRING D7-Friend-4
24450: PPUSH
24451: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24455: LD_EXP 39
24459: PPUSH
24460: LD_STRING D7-JMM-4
24462: PPUSH
24463: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24467: LD_EXP 62
24471: PPUSH
24472: LD_STRING D7-Friend-5
24474: PPUSH
24475: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24479: LD_EXP 39
24483: PPUSH
24484: LD_STRING D7-JMM-5
24486: PPUSH
24487: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24491: LD_EXP 62
24495: PPUSH
24496: LD_STRING D7-Friend-6
24498: PPUSH
24499: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24503: LD_EXP 39
24507: PPUSH
24508: LD_STRING D7-JMM-6
24510: PPUSH
24511: CALL_OW 88
// DialogueOff ;
24515: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24519: LD_STRING Mlegion
24521: PPUSH
24522: CALL_OW 337
// RebuildKozlovFactory ;
24526: CALL 4880 0 0
// end ;
24530: PPOPN 13
24532: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24533: LD_EXP 20
24537: PUSH
24538: LD_EXP 58
24542: PPUSH
24543: CALL_OW 300
24547: AND
24548: IFFALSE 24590
24550: GO 24552
24552: DISABLE
// begin enable ;
24553: ENABLE
// if IsInUnit ( Powell ) then
24554: LD_EXP 58
24558: PPUSH
24559: CALL_OW 310
24563: IFFALSE 24581
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24565: LD_EXP 58
24569: PPUSH
24570: CALL_OW 310
24574: PPUSH
24575: CALL_OW 85
24579: GO 24590
// CenterOnUnits ( Powell ) ;
24581: LD_EXP 58
24585: PPUSH
24586: CALL_OW 85
// end ;
24590: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24591: LD_INT 22
24593: PUSH
24594: LD_INT 8
24596: PUSH
24597: EMPTY
24598: LIST
24599: LIST
24600: PUSH
24601: LD_INT 34
24603: PUSH
24604: LD_INT 48
24606: PUSH
24607: EMPTY
24608: LIST
24609: LIST
24610: PUSH
24611: EMPTY
24612: LIST
24613: LIST
24614: PPUSH
24615: CALL_OW 69
24619: IFFALSE 24893
24621: GO 24623
24623: DISABLE
24624: LD_INT 0
24626: PPUSH
24627: PPUSH
// begin if missionStage < 9 then
24628: LD_EXP 15
24632: PUSH
24633: LD_INT 9
24635: LESS
24636: IFFALSE 24646
// missionStage := 9 ;
24638: LD_ADDR_EXP 15
24642: PUSH
24643: LD_INT 9
24645: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24646: LD_ADDR_VAR 0 1
24650: PUSH
24651: LD_INT 22
24653: PUSH
24654: LD_INT 8
24656: PUSH
24657: EMPTY
24658: LIST
24659: LIST
24660: PUSH
24661: LD_INT 34
24663: PUSH
24664: LD_INT 48
24666: PUSH
24667: EMPTY
24668: LIST
24669: LIST
24670: PUSH
24671: EMPTY
24672: LIST
24673: LIST
24674: PPUSH
24675: CALL_OW 69
24679: PUSH
24680: LD_INT 1
24682: ARRAY
24683: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24684: LD_INT 175
24686: PPUSH
24687: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24691: LD_EXP 12
24695: PUSH
24696: LD_EXP 3
24700: PUSH
24701: LD_INT 0
24703: PUSH
24704: LD_INT 2
24706: PUSH
24707: EMPTY
24708: LIST
24709: LIST
24710: IN
24711: OR
24712: IFFALSE 24735
// target := [ 68 , 108 , 1 ] else
24714: LD_ADDR_VAR 0 2
24718: PUSH
24719: LD_INT 68
24721: PUSH
24722: LD_INT 108
24724: PUSH
24725: LD_INT 1
24727: PUSH
24728: EMPTY
24729: LIST
24730: LIST
24731: LIST
24732: ST_TO_ADDR
24733: GO 24754
// target := [ 181 , 88 , 2 ] ;
24735: LD_ADDR_VAR 0 2
24739: PUSH
24740: LD_INT 181
24742: PUSH
24743: LD_INT 88
24745: PUSH
24746: LD_INT 2
24748: PUSH
24749: EMPTY
24750: LIST
24751: LIST
24752: LIST
24753: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24754: LD_VAR 0 1
24758: PPUSH
24759: LD_VAR 0 2
24763: PUSH
24764: LD_INT 1
24766: ARRAY
24767: PPUSH
24768: LD_VAR 0 2
24772: PUSH
24773: LD_INT 2
24775: ARRAY
24776: PPUSH
24777: CALL_OW 176
// if target [ 3 ] = 1 then
24781: LD_VAR 0 2
24785: PUSH
24786: LD_INT 3
24788: ARRAY
24789: PUSH
24790: LD_INT 1
24792: EQUAL
24793: IFFALSE 24809
// SayRadio ( Kurt , D12-Kurt-1 ) else
24795: LD_EXP 60
24799: PPUSH
24800: LD_STRING D12-Kurt-1
24802: PPUSH
24803: CALL_OW 94
24807: GO 24833
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24809: LD_EXP 60
24813: PPUSH
24814: LD_STRING D12a-Kurt-1
24816: PPUSH
24817: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24821: LD_EXP 74
24825: PPUSH
24826: LD_STRING D12a-Roth-1
24828: PPUSH
24829: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24833: LD_INT 350
24835: PPUSH
24836: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24840: LD_VAR 0 1
24844: PPUSH
24845: LD_INT 22
24847: PUSH
24848: LD_INT 8
24850: PUSH
24851: EMPTY
24852: LIST
24853: LIST
24854: PUSH
24855: LD_INT 23
24857: PUSH
24858: LD_INT 2
24860: PUSH
24861: EMPTY
24862: LIST
24863: LIST
24864: PUSH
24865: LD_INT 30
24867: PUSH
24868: LD_INT 3
24870: PUSH
24871: EMPTY
24872: LIST
24873: LIST
24874: PUSH
24875: EMPTY
24876: LIST
24877: LIST
24878: LIST
24879: PPUSH
24880: CALL_OW 69
24884: PUSH
24885: LD_INT 1
24887: ARRAY
24888: PPUSH
24889: CALL_OW 228
// end ;
24893: PPOPN 2
24895: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24896: LD_EXP 60
24900: PPUSH
24901: CALL_OW 256
24905: PUSH
24906: LD_INT 999
24908: LESS
24909: PUSH
24910: LD_INT 22
24912: PUSH
24913: LD_INT 8
24915: PUSH
24916: EMPTY
24917: LIST
24918: LIST
24919: PUSH
24920: LD_INT 21
24922: PUSH
24923: LD_INT 1
24925: PUSH
24926: EMPTY
24927: LIST
24928: LIST
24929: PUSH
24930: LD_INT 23
24932: PUSH
24933: LD_INT 2
24935: PUSH
24936: EMPTY
24937: LIST
24938: LIST
24939: PUSH
24940: EMPTY
24941: LIST
24942: LIST
24943: LIST
24944: PPUSH
24945: CALL_OW 69
24949: PUSH
24950: LD_INT 9
24952: PUSH
24953: LD_INT 8
24955: PUSH
24956: LD_INT 7
24958: PUSH
24959: EMPTY
24960: LIST
24961: LIST
24962: LIST
24963: PUSH
24964: LD_OWVAR 67
24968: ARRAY
24969: LESSEQUAL
24970: OR
24971: PUSH
24972: LD_INT 22
24974: PUSH
24975: LD_INT 8
24977: PUSH
24978: EMPTY
24979: LIST
24980: LIST
24981: PUSH
24982: LD_INT 34
24984: PUSH
24985: LD_INT 48
24987: PUSH
24988: EMPTY
24989: LIST
24990: LIST
24991: PUSH
24992: EMPTY
24993: LIST
24994: LIST
24995: PPUSH
24996: CALL_OW 69
25000: NOT
25001: AND
25002: PUSH
25003: LD_EXP 60
25007: PPUSH
25008: CALL_OW 302
25012: AND
25013: PUSH
25014: LD_INT 5
25016: PPUSH
25017: LD_INT 22
25019: PUSH
25020: LD_INT 1
25022: PUSH
25023: EMPTY
25024: LIST
25025: LIST
25026: PPUSH
25027: CALL_OW 70
25031: AND
25032: IFFALSE 25737
25034: GO 25036
25036: DISABLE
25037: LD_INT 0
25039: PPUSH
25040: PPUSH
25041: PPUSH
// begin DialogueOn ;
25042: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25046: LD_EXP 39
25050: PPUSH
25051: LD_STRING D13-JMM-1
25053: PPUSH
25054: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25058: LD_EXP 60
25062: PPUSH
25063: LD_STRING D13-Kurt-1
25065: PPUSH
25066: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25070: LD_EXP 39
25074: PPUSH
25075: LD_STRING D13-JMM-2
25077: PPUSH
25078: CALL_OW 88
// if FakeInfo then
25082: LD_EXP 12
25086: IFFALSE 25106
// begin Say ( Kurt , D13-Kurt-2 ) ;
25088: LD_EXP 60
25092: PPUSH
25093: LD_STRING D13-Kurt-2
25095: PPUSH
25096: CALL_OW 88
// DialogueOff ;
25100: CALL_OW 7
// exit ;
25104: GO 25737
// end ; if not KurtStatus then
25106: LD_EXP 3
25110: NOT
25111: IFFALSE 25127
// Say ( Kurt , D13-Kurt-2b ) else
25113: LD_EXP 60
25117: PPUSH
25118: LD_STRING D13-Kurt-2b
25120: PPUSH
25121: CALL_OW 88
25125: GO 25139
// Say ( Kurt , D13-Kurt-2a ) ;
25127: LD_EXP 60
25131: PPUSH
25132: LD_STRING D13-Kurt-2a
25134: PPUSH
25135: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25139: LD_EXP 39
25143: PPUSH
25144: LD_STRING D13-JMM-3
25146: PPUSH
25147: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25151: LD_EXP 60
25155: PPUSH
25156: LD_STRING D13-Kurt-3
25158: PPUSH
25159: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25163: LD_EXP 39
25167: PPUSH
25168: LD_STRING D13-JMM-4
25170: PPUSH
25171: CALL_OW 88
// DialogueOff ;
25175: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
25179: LD_STRING MlegionOut
25181: PPUSH
25182: CALL_OW 337
// legionDestroyed := true ;
25186: LD_ADDR_EXP 22
25190: PUSH
25191: LD_INT 1
25193: ST_TO_ADDR
// MC_Kill ( 3 ) ;
25194: LD_INT 3
25196: PPUSH
25197: CALL 35385 0 1
// KillUnit ( Kozlov ) ;
25201: LD_EXP 61
25205: PPUSH
25206: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25210: LD_ADDR_VAR 0 1
25214: PUSH
25215: LD_INT 22
25217: PUSH
25218: LD_INT 8
25220: PUSH
25221: EMPTY
25222: LIST
25223: LIST
25224: PUSH
25225: LD_INT 23
25227: PUSH
25228: LD_INT 3
25230: PUSH
25231: EMPTY
25232: LIST
25233: LIST
25234: PUSH
25235: LD_INT 3
25237: PUSH
25238: LD_INT 21
25240: PUSH
25241: LD_INT 33
25243: PUSH
25244: EMPTY
25245: LIST
25246: LIST
25247: PUSH
25248: EMPTY
25249: LIST
25250: LIST
25251: PUSH
25252: EMPTY
25253: LIST
25254: LIST
25255: LIST
25256: PPUSH
25257: CALL_OW 69
25261: PUSH
25262: FOR_IN
25263: IFFALSE 25276
// KillUnit ( i ) ;
25265: LD_VAR 0 1
25269: PPUSH
25270: CALL_OW 66
25274: GO 25262
25276: POP
25277: POP
// ChangeSideFog ( 8 , 1 ) ;
25278: LD_INT 8
25280: PPUSH
25281: LD_INT 1
25283: PPUSH
25284: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25288: LD_ADDR_VAR 0 2
25292: PUSH
25293: LD_INT 22
25295: PUSH
25296: LD_INT 8
25298: PUSH
25299: EMPTY
25300: LIST
25301: LIST
25302: PUSH
25303: LD_INT 21
25305: PUSH
25306: LD_INT 1
25308: PUSH
25309: EMPTY
25310: LIST
25311: LIST
25312: PUSH
25313: EMPTY
25314: LIST
25315: LIST
25316: PPUSH
25317: CALL_OW 69
25321: PUSH
25322: LD_EXP 61
25326: PUSH
25327: LD_EXP 60
25331: PUSH
25332: EMPTY
25333: LIST
25334: LIST
25335: DIFF
25336: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 ] [ Difficulty ] then
25337: LD_VAR 0 2
25341: PUSH
25342: LD_INT 6
25344: PUSH
25345: LD_INT 5
25347: PUSH
25348: LD_INT 4
25350: PUSH
25351: EMPTY
25352: LIST
25353: LIST
25354: LIST
25355: PUSH
25356: LD_OWVAR 67
25360: ARRAY
25361: GREATEREQUAL
25362: IFFALSE 25536
// begin x := [ 6 , 5 , 4 ] [ Difficulty ] ;
25364: LD_ADDR_VAR 0 3
25368: PUSH
25369: LD_INT 6
25371: PUSH
25372: LD_INT 5
25374: PUSH
25375: LD_INT 4
25377: PUSH
25378: EMPTY
25379: LIST
25380: LIST
25381: LIST
25382: PUSH
25383: LD_OWVAR 67
25387: ARRAY
25388: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25389: LD_ADDR_VAR 0 1
25393: PUSH
25394: DOUBLE
25395: LD_VAR 0 2
25399: PUSH
25400: LD_VAR 0 3
25404: PUSH
25405: LD_INT 1
25407: PLUS
25408: MINUS
25409: INC
25410: ST_TO_ADDR
25411: LD_INT 1
25413: PUSH
25414: FOR_DOWNTO
25415: IFFALSE 25532
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25417: LD_ADDR_EXP 38
25421: PUSH
25422: LD_EXP 38
25426: PUSH
25427: LD_VAR 0 2
25431: PUSH
25432: LD_VAR 0 1
25436: ARRAY
25437: ADD
25438: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25439: LD_VAR 0 2
25443: PUSH
25444: LD_VAR 0 1
25448: ARRAY
25449: PPUSH
25450: CALL_OW 310
25454: IFFALSE 25471
// ComExitBuilding ( tmp [ i ] ) ;
25456: LD_VAR 0 2
25460: PUSH
25461: LD_VAR 0 1
25465: ARRAY
25466: PPUSH
25467: CALL_OW 122
// if IsInUnit ( i ) then
25471: LD_VAR 0 1
25475: PPUSH
25476: CALL_OW 310
25480: IFFALSE 25497
// ComExitVehicle ( tmp [ i ] ) ;
25482: LD_VAR 0 2
25486: PUSH
25487: LD_VAR 0 1
25491: ARRAY
25492: PPUSH
25493: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25497: LD_VAR 0 2
25501: PUSH
25502: LD_VAR 0 1
25506: ARRAY
25507: PPUSH
25508: LD_INT 34
25510: PUSH
25511: LD_INT 0
25513: PPUSH
25514: LD_INT 6
25516: PPUSH
25517: CALL_OW 12
25521: PLUS
25522: PPUSH
25523: LD_INT 1
25525: PPUSH
25526: CALL_OW 171
// end ;
25530: GO 25414
25532: POP
25533: POP
// end else
25534: GO 25546
// x := tmp ;
25536: LD_ADDR_VAR 0 3
25540: PUSH
25541: LD_VAR 0 2
25545: ST_TO_ADDR
// for i := tmp downto tmp - x do
25546: LD_ADDR_VAR 0 1
25550: PUSH
25551: DOUBLE
25552: LD_VAR 0 2
25556: INC
25557: ST_TO_ADDR
25558: LD_VAR 0 2
25562: PUSH
25563: LD_VAR 0 3
25567: MINUS
25568: PUSH
25569: FOR_DOWNTO
25570: IFFALSE 25624
// begin if IsInUnit ( tmp [ i ] ) then
25572: LD_VAR 0 2
25576: PUSH
25577: LD_VAR 0 1
25581: ARRAY
25582: PPUSH
25583: CALL_OW 310
25587: IFFALSE 25604
// ComExitVehicle ( tmp [ i ] ) ;
25589: LD_VAR 0 2
25593: PUSH
25594: LD_VAR 0 1
25598: ARRAY
25599: PPUSH
25600: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25604: LD_VAR 0 2
25608: PUSH
25609: LD_VAR 0 1
25613: ARRAY
25614: PPUSH
25615: LD_INT 1
25617: PPUSH
25618: CALL_OW 235
// end ;
25622: GO 25569
25624: POP
25625: POP
// SetSide ( Kurt , 1 ) ;
25626: LD_EXP 60
25630: PPUSH
25631: LD_INT 1
25633: PPUSH
25634: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25638: LD_INT 22
25640: PUSH
25641: LD_INT 8
25643: PUSH
25644: EMPTY
25645: LIST
25646: LIST
25647: PUSH
25648: LD_INT 21
25650: PUSH
25651: LD_INT 3
25653: PUSH
25654: EMPTY
25655: LIST
25656: LIST
25657: PUSH
25658: EMPTY
25659: LIST
25660: LIST
25661: PPUSH
25662: CALL_OW 69
25666: PPUSH
25667: LD_INT 1
25669: PPUSH
25670: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25674: LD_INT 8
25676: PPUSH
25677: LD_INT 1
25679: PPUSH
25680: LD_INT 1
25682: PPUSH
25683: LD_INT 1
25685: PPUSH
25686: CALL_OW 80
// wait ( 1 1$20 ) ;
25690: LD_INT 2800
25692: PPUSH
25693: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25697: LD_EXP 62
25701: PPUSH
25702: LD_INT 37
25704: PPUSH
25705: LD_INT 1
25707: PPUSH
25708: LD_INT 0
25710: PPUSH
25711: CALL_OW 48
// wait ( 0 0$1 ) ;
25715: LD_INT 35
25717: PPUSH
25718: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25722: LD_EXP 62
25726: PPUSH
25727: LD_INT 60
25729: PPUSH
25730: LD_INT 95
25732: PPUSH
25733: CALL_OW 111
// end ;
25737: PPOPN 3
25739: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25740: LD_EXP 22
25744: NOT
25745: PUSH
25746: LD_INT 22
25748: PUSH
25749: LD_INT 8
25751: PUSH
25752: EMPTY
25753: LIST
25754: LIST
25755: PUSH
25756: LD_INT 21
25758: PUSH
25759: LD_INT 1
25761: PUSH
25762: EMPTY
25763: LIST
25764: LIST
25765: PUSH
25766: EMPTY
25767: LIST
25768: LIST
25769: PPUSH
25770: CALL_OW 69
25774: PUSH
25775: LD_INT 0
25777: EQUAL
25778: AND
25779: IFFALSE 25799
25781: GO 25783
25783: DISABLE
// begin legionDestroyed := true ;
25784: LD_ADDR_EXP 22
25788: PUSH
25789: LD_INT 1
25791: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
25792: LD_STRING MlegionOut
25794: PPUSH
25795: CALL_OW 337
// end ;
25799: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25800: LD_EXP 38
25804: IFFALSE 25879
25806: GO 25808
25808: DISABLE
25809: LD_INT 0
25811: PPUSH
// begin enable ;
25812: ENABLE
// for i in legionEscapeUnits do
25813: LD_ADDR_VAR 0 1
25817: PUSH
25818: LD_EXP 38
25822: PUSH
25823: FOR_IN
25824: IFFALSE 25877
// begin if IsInArea ( i , legionEscapeArea ) then
25826: LD_VAR 0 1
25830: PPUSH
25831: LD_INT 31
25833: PPUSH
25834: CALL_OW 308
25838: IFFALSE 25851
// RemoveUnit ( i ) else
25840: LD_VAR 0 1
25844: PPUSH
25845: CALL_OW 64
25849: GO 25875
// if not HasTask ( i ) then
25851: LD_VAR 0 1
25855: PPUSH
25856: CALL_OW 314
25860: NOT
25861: IFFALSE 25875
// ComMoveToArea ( i , legionEscapeArea ) ;
25863: LD_VAR 0 1
25867: PPUSH
25868: LD_INT 31
25870: PPUSH
25871: CALL_OW 113
// end ;
25875: GO 25823
25877: POP
25878: POP
// end ;
25879: PPOPN 1
25881: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25882: LD_INT 1
25884: PPUSH
25885: LD_EXP 62
25889: PPUSH
25890: CALL_OW 292
25894: IFFALSE 26192
25896: GO 25898
25898: DISABLE
25899: LD_INT 0
25901: PPUSH
// begin wait ( 0 0$2 ) ;
25902: LD_INT 70
25904: PPUSH
25905: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25909: LD_EXP 62
25913: PPUSH
25914: CALL_OW 87
// DialogueOn ;
25918: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25922: LD_EXP 39
25926: PPUSH
25927: LD_STRING D14-JMM-1
25929: PPUSH
25930: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25934: LD_EXP 62
25938: PPUSH
25939: LD_STRING D14-Friend-1
25941: PPUSH
25942: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25946: LD_EXP 39
25950: PPUSH
25951: LD_STRING D14-JMM-2
25953: PPUSH
25954: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25958: LD_EXP 62
25962: PPUSH
25963: LD_STRING D14-Friend-2
25965: PPUSH
25966: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25970: LD_EXP 39
25974: PPUSH
25975: LD_STRING D14-JMM-3
25977: PPUSH
25978: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25982: LD_EXP 62
25986: PPUSH
25987: LD_STRING D14-Friend-3
25989: PPUSH
25990: CALL_OW 88
// DialogueOff ;
25994: CALL_OW 7
// dec = Query ( Q14 ) ;
25998: LD_ADDR_VAR 0 1
26002: PUSH
26003: LD_STRING Q14
26005: PPUSH
26006: CALL_OW 97
26010: ST_TO_ADDR
// if dec = 1 then
26011: LD_VAR 0 1
26015: PUSH
26016: LD_INT 1
26018: EQUAL
26019: IFFALSE 26053
// begin DialogueOn ;
26021: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
26025: LD_EXP 39
26029: PPUSH
26030: LD_STRING D14a-JMM-1
26032: PPUSH
26033: CALL_OW 88
// DialogueOff ;
26037: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26041: LD_EXP 62
26045: PPUSH
26046: LD_INT 1
26048: PPUSH
26049: CALL_OW 235
// end ; if dec = 2 then
26053: LD_VAR 0 1
26057: PUSH
26058: LD_INT 2
26060: EQUAL
26061: IFFALSE 26114
// begin DialogueOn ;
26063: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26067: LD_EXP 39
26071: PPUSH
26072: LD_STRING D14b-JMM-1
26074: PPUSH
26075: CALL_OW 88
// DialogueOff ;
26079: CALL_OW 7
// wait ( 0 0$1 ) ;
26083: LD_INT 35
26085: PPUSH
26086: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26090: LD_EXP 62
26094: PPUSH
26095: LD_INT 9
26097: PPUSH
26098: LD_INT 2
26100: PPUSH
26101: CALL_OW 111
// AddComHold ( Friend ) ;
26105: LD_EXP 62
26109: PPUSH
26110: CALL_OW 200
// end ; if dec = 3 then
26114: LD_VAR 0 1
26118: PUSH
26119: LD_INT 3
26121: EQUAL
26122: IFFALSE 26192
// begin DialogueOn ;
26124: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26128: LD_EXP 39
26132: PPUSH
26133: LD_STRING D14c-JMM-1
26135: PPUSH
26136: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26140: LD_EXP 62
26144: PPUSH
26145: LD_STRING D14c-Friend-1
26147: PPUSH
26148: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26152: LD_EXP 39
26156: PPUSH
26157: LD_STRING D14c-JMM-2
26159: PPUSH
26160: CALL_OW 88
// DialogueOff ;
26164: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26168: LD_EXP 62
26172: PPUSH
26173: LD_INT 9
26175: PPUSH
26176: LD_INT 2
26178: PPUSH
26179: CALL_OW 111
// AddComHold ( Friend ) ;
26183: LD_EXP 62
26187: PPUSH
26188: CALL_OW 200
// end ; end ;
26192: PPOPN 1
26194: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26195: LD_INT 9
26197: PPUSH
26198: LD_INT 2
26200: PPUSH
26201: CALL_OW 428
26205: PUSH
26206: LD_EXP 62
26210: EQUAL
26211: PUSH
26212: LD_EXP 62
26216: PPUSH
26217: CALL_OW 255
26221: PUSH
26222: LD_INT 8
26224: EQUAL
26225: AND
26226: IFFALSE 26240
26228: GO 26230
26230: DISABLE
// RemoveUnit ( Friend ) ;
26231: LD_EXP 62
26235: PPUSH
26236: CALL_OW 64
26240: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26241: LD_EXP 14
26245: PUSH
26246: LD_INT 31500
26248: GREATEREQUAL
26249: PUSH
26250: LD_EXP 7
26254: AND
26255: PUSH
26256: LD_EXP 2
26260: AND
26261: IFFALSE 26691
26263: GO 26265
26265: DISABLE
26266: LD_INT 0
26268: PPUSH
26269: PPUSH
26270: PPUSH
// begin missionStage := 7 ;
26271: LD_ADDR_EXP 15
26275: PUSH
26276: LD_INT 7
26278: ST_TO_ADDR
// uc_side = 1 ;
26279: LD_ADDR_OWVAR 20
26283: PUSH
26284: LD_INT 1
26286: ST_TO_ADDR
// uc_nation = 1 ;
26287: LD_ADDR_OWVAR 21
26291: PUSH
26292: LD_INT 1
26294: ST_TO_ADDR
// for i = 1 to 5 do
26295: LD_ADDR_VAR 0 1
26299: PUSH
26300: DOUBLE
26301: LD_INT 1
26303: DEC
26304: ST_TO_ADDR
26305: LD_INT 5
26307: PUSH
26308: FOR_TO
26309: IFFALSE 26405
// begin vc_engine = 3 ;
26311: LD_ADDR_OWVAR 39
26315: PUSH
26316: LD_INT 3
26318: ST_TO_ADDR
// vc_control = 3 ;
26319: LD_ADDR_OWVAR 38
26323: PUSH
26324: LD_INT 3
26326: ST_TO_ADDR
// vc_chassis = 3 ;
26327: LD_ADDR_OWVAR 37
26331: PUSH
26332: LD_INT 3
26334: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26335: LD_ADDR_OWVAR 40
26339: PUSH
26340: LD_INT 5
26342: PUSH
26343: LD_INT 9
26345: PUSH
26346: LD_INT 7
26348: PUSH
26349: EMPTY
26350: LIST
26351: LIST
26352: LIST
26353: PUSH
26354: LD_INT 1
26356: PPUSH
26357: LD_INT 3
26359: PPUSH
26360: CALL_OW 12
26364: ARRAY
26365: ST_TO_ADDR
// veh = CreateVehicle ;
26366: LD_ADDR_VAR 0 2
26370: PUSH
26371: CALL_OW 45
26375: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26376: LD_VAR 0 2
26380: PPUSH
26381: LD_INT 1
26383: PPUSH
26384: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26388: LD_VAR 0 2
26392: PPUSH
26393: LD_INT 19
26395: PPUSH
26396: LD_INT 0
26398: PPUSH
26399: CALL_OW 49
// end ;
26403: GO 26308
26405: POP
26406: POP
// vc_engine = 3 ;
26407: LD_ADDR_OWVAR 39
26411: PUSH
26412: LD_INT 3
26414: ST_TO_ADDR
// vc_control = 1 ;
26415: LD_ADDR_OWVAR 38
26419: PUSH
26420: LD_INT 1
26422: ST_TO_ADDR
// vc_chassis = 3 ;
26423: LD_ADDR_OWVAR 37
26427: PUSH
26428: LD_INT 3
26430: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26431: LD_ADDR_OWVAR 40
26435: PUSH
26436: LD_INT 5
26438: PUSH
26439: LD_INT 9
26441: PUSH
26442: LD_INT 7
26444: PUSH
26445: EMPTY
26446: LIST
26447: LIST
26448: LIST
26449: PUSH
26450: LD_INT 1
26452: PPUSH
26453: LD_INT 3
26455: PPUSH
26456: CALL_OW 12
26460: ARRAY
26461: ST_TO_ADDR
// vehG = CreateVehicle ;
26462: LD_ADDR_VAR 0 3
26466: PUSH
26467: CALL_OW 45
26471: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26472: LD_VAR 0 3
26476: PPUSH
26477: LD_INT 1
26479: PPUSH
26480: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26484: LD_VAR 0 3
26488: PPUSH
26489: LD_INT 19
26491: PPUSH
26492: LD_INT 0
26494: PPUSH
26495: CALL_OW 49
// if JMMGirl = 1 then
26499: LD_EXP 7
26503: PUSH
26504: LD_INT 1
26506: EQUAL
26507: IFFALSE 26563
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26509: LD_ADDR_EXP 40
26513: PUSH
26514: LD_STRING Joan
26516: PPUSH
26517: LD_INT 1
26519: PPUSH
26520: LD_STRING 14_
26522: PPUSH
26523: CALL 65622 0 3
26527: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26528: LD_EXP 40
26532: PPUSH
26533: LD_VAR 0 3
26537: PPUSH
26538: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26542: LD_VAR 0 3
26546: PPUSH
26547: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26551: LD_EXP 40
26555: PPUSH
26556: LD_STRING D10BW-Joan-1
26558: PPUSH
26559: CALL_OW 94
// end ; if JMMGirl = 2 then
26563: LD_EXP 7
26567: PUSH
26568: LD_INT 2
26570: EQUAL
26571: IFFALSE 26627
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26573: LD_ADDR_EXP 42
26577: PUSH
26578: LD_STRING Lisa
26580: PPUSH
26581: LD_INT 1
26583: PPUSH
26584: LD_STRING 14_
26586: PPUSH
26587: CALL 65622 0 3
26591: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26592: LD_EXP 42
26596: PPUSH
26597: LD_VAR 0 3
26601: PPUSH
26602: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26606: LD_VAR 0 3
26610: PPUSH
26611: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26615: LD_EXP 42
26619: PPUSH
26620: LD_STRING D10BW-Lisa-1
26622: PPUSH
26623: CALL_OW 94
// end ; if JMMGirl = 3 then
26627: LD_EXP 7
26631: PUSH
26632: LD_INT 3
26634: EQUAL
26635: IFFALSE 26691
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26637: LD_ADDR_EXP 54
26641: PUSH
26642: LD_STRING Connie
26644: PPUSH
26645: LD_INT 1
26647: PPUSH
26648: LD_STRING 14_
26650: PPUSH
26651: CALL 65622 0 3
26655: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26656: LD_EXP 54
26660: PPUSH
26661: LD_VAR 0 3
26665: PPUSH
26666: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26670: LD_VAR 0 3
26674: PPUSH
26675: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26679: LD_EXP 54
26683: PPUSH
26684: LD_STRING D10BW-Con-1
26686: PPUSH
26687: CALL_OW 94
// end ; end ;
26691: PPOPN 3
26693: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26694: LD_EXP 14
26698: PUSH
26699: LD_INT 94500
26701: GREATEREQUAL
26702: IFFALSE 27114
26704: GO 26706
26706: DISABLE
26707: LD_INT 0
26709: PPUSH
26710: PPUSH
26711: PPUSH
// begin tmp := PrepareStevensSquad ;
26712: LD_ADDR_VAR 0 3
26716: PUSH
26717: CALL 2222 0 0
26721: ST_TO_ADDR
// if not tmp then
26722: LD_VAR 0 3
26726: NOT
26727: IFFALSE 26731
// exit ;
26729: GO 27114
// uc_side := 1 ;
26731: LD_ADDR_OWVAR 20
26735: PUSH
26736: LD_INT 1
26738: ST_TO_ADDR
// uc_nation := 1 ;
26739: LD_ADDR_OWVAR 21
26743: PUSH
26744: LD_INT 1
26746: ST_TO_ADDR
// for i in tmp do
26747: LD_ADDR_VAR 0 1
26751: PUSH
26752: LD_VAR 0 3
26756: PUSH
26757: FOR_IN
26758: IFFALSE 26855
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26760: LD_INT 3
26762: PPUSH
26763: LD_INT 3
26765: PPUSH
26766: LD_INT 1
26768: PPUSH
26769: LD_INT 5
26771: PUSH
26772: LD_INT 9
26774: PUSH
26775: LD_INT 7
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: LIST
26782: PUSH
26783: LD_INT 1
26785: PPUSH
26786: LD_INT 3
26788: PPUSH
26789: CALL_OW 12
26793: ARRAY
26794: PPUSH
26795: LD_INT 40
26797: PPUSH
26798: CALL 70486 0 5
// veh := CreateVehicle ;
26802: LD_ADDR_VAR 0 2
26806: PUSH
26807: CALL_OW 45
26811: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26812: LD_VAR 0 2
26816: PPUSH
26817: LD_INT 1
26819: PPUSH
26820: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26824: LD_VAR 0 2
26828: PPUSH
26829: LD_INT 19
26831: PPUSH
26832: LD_INT 0
26834: PPUSH
26835: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26839: LD_VAR 0 1
26843: PPUSH
26844: LD_VAR 0 2
26848: PPUSH
26849: CALL_OW 52
// end ;
26853: GO 26757
26855: POP
26856: POP
// missionStage := 8 ;
26857: LD_ADDR_EXP 15
26861: PUSH
26862: LD_INT 8
26864: ST_TO_ADDR
// DialogueOn ;
26865: CALL_OW 6
// if Stevens then
26869: LD_EXP 41
26873: IFFALSE 26987
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26875: LD_EXP 41
26879: PPUSH
26880: CALL_OW 310
26884: PPUSH
26885: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26889: LD_EXP 41
26893: PPUSH
26894: LD_STRING D8-Huck-1
26896: PPUSH
26897: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26901: LD_EXP 39
26905: PPUSH
26906: LD_STRING D8-JMM-1
26908: PPUSH
26909: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26913: LD_EXP 41
26917: PPUSH
26918: LD_STRING D8-Huck-2
26920: PPUSH
26921: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26925: LD_EXP 39
26929: PPUSH
26930: LD_STRING D8-JMM-2
26932: PPUSH
26933: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26937: LD_EXP 41
26941: PPUSH
26942: LD_STRING D8-Huck-3
26944: PPUSH
26945: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26949: LD_EXP 39
26953: PPUSH
26954: LD_STRING D8-JMM-3
26956: PPUSH
26957: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26961: LD_EXP 41
26965: PPUSH
26966: LD_STRING D8-Huck-4
26968: PPUSH
26969: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26973: LD_EXP 39
26977: PPUSH
26978: LD_STRING D8-JMM-4
26980: PPUSH
26981: CALL_OW 88
// end else
26985: GO 27097
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26987: LD_EXP 55
26991: PPUSH
26992: CALL_OW 310
26996: PPUSH
26997: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
27001: LD_EXP 55
27005: PPUSH
27006: LD_STRING D8-Huck-1
27008: PPUSH
27009: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
27013: LD_EXP 39
27017: PPUSH
27018: LD_STRING D8-JMM-1a
27020: PPUSH
27021: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
27025: LD_EXP 55
27029: PPUSH
27030: LD_STRING D8-Huck-2
27032: PPUSH
27033: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27037: LD_EXP 39
27041: PPUSH
27042: LD_STRING D8-JMM-2
27044: PPUSH
27045: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
27049: LD_EXP 55
27053: PPUSH
27054: LD_STRING D8-Huck-3
27056: PPUSH
27057: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27061: LD_EXP 39
27065: PPUSH
27066: LD_STRING D8-JMM-3
27068: PPUSH
27069: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27073: LD_EXP 55
27077: PPUSH
27078: LD_STRING D8-Huck-4
27080: PPUSH
27081: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27085: LD_EXP 39
27089: PPUSH
27090: LD_STRING D8-JMM-4
27092: PPUSH
27093: CALL_OW 88
// end ; DialogueOff ;
27097: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27101: LD_INT 25
27103: PPUSH
27104: LD_INT 1
27106: PPUSH
27107: LD_INT 1
27109: PPUSH
27110: CALL_OW 322
// end ;
27114: PPOPN 3
27116: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27117: LD_INT 1
27119: PPUSH
27120: LD_EXP 71
27124: PPUSH
27125: CALL_OW 292
27129: IFFALSE 27380
27131: GO 27133
27133: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27134: LD_EXP 71
27138: PPUSH
27139: CALL_OW 87
// DialogueOn ;
27143: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27147: LD_EXP 39
27151: PPUSH
27152: LD_STRING D10nB-JMM-1
27154: PPUSH
27155: CALL_OW 88
// if BurlakStatus = 1 then
27159: LD_EXP 9
27163: PUSH
27164: LD_INT 1
27166: EQUAL
27167: IFFALSE 27181
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27169: LD_EXP 70
27173: PPUSH
27174: LD_STRING D10nB-Vse-1a
27176: PPUSH
27177: CALL_OW 94
// end ; if BurlakStatus = 0 then
27181: LD_EXP 9
27185: PUSH
27186: LD_INT 0
27188: EQUAL
27189: IFFALSE 27203
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27191: LD_EXP 70
27195: PPUSH
27196: LD_STRING D10nB-Vse-1
27198: PPUSH
27199: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27203: LD_EXP 39
27207: PPUSH
27208: LD_STRING D10nB-JMM-2
27210: PPUSH
27211: CALL_OW 88
// if KappaStatus then
27215: LD_EXP 2
27219: IFFALSE 27233
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27221: LD_EXP 70
27225: PPUSH
27226: LD_STRING D10nB-Vse-5a
27228: PPUSH
27229: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27233: LD_EXP 2
27237: NOT
27238: PUSH
27239: LD_EXP 6
27243: PUSH
27244: LD_INT 0
27246: EQUAL
27247: AND
27248: IFFALSE 27376
// begin if JMMGirl = 1 then
27250: LD_EXP 7
27254: PUSH
27255: LD_INT 1
27257: EQUAL
27258: IFFALSE 27308
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27260: LD_EXP 70
27264: PPUSH
27265: LD_STRING D10nB-Vse-2
27267: PPUSH
27268: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27272: LD_EXP 39
27276: PPUSH
27277: LD_STRING D10nB-JMM-3
27279: PPUSH
27280: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27284: LD_EXP 70
27288: PPUSH
27289: LD_STRING D10nB-Vse-3
27291: PPUSH
27292: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27296: LD_EXP 39
27300: PPUSH
27301: LD_STRING D10nB-JMM-4
27303: PPUSH
27304: CALL_OW 88
// end ; if JMMGirl = 2 then
27308: LD_EXP 7
27312: PUSH
27313: LD_INT 2
27315: EQUAL
27316: IFFALSE 27342
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27318: LD_EXP 70
27322: PPUSH
27323: LD_STRING D10nB-Vse-4
27325: PPUSH
27326: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27330: LD_EXP 39
27334: PPUSH
27335: LD_STRING D10nB-JMM-5
27337: PPUSH
27338: CALL_OW 88
// end ; if JMMGirl = 3 then
27342: LD_EXP 7
27346: PUSH
27347: LD_INT 3
27349: EQUAL
27350: IFFALSE 27376
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27352: LD_EXP 70
27356: PPUSH
27357: LD_STRING D10nB-Vse-5
27359: PPUSH
27360: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27364: LD_EXP 39
27368: PPUSH
27369: LD_STRING D10nB-JMM-6
27371: PPUSH
27372: CALL_OW 88
// end ; end ; DialogueOff ;
27376: CALL_OW 7
// end ;
27380: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27381: LD_EXP 14
27385: PUSH
27386: LD_INT 115500
27388: GREATEREQUAL
27389: IFFALSE 27765
27391: GO 27393
27393: DISABLE
27394: LD_INT 0
27396: PPUSH
// begin missionStage := 10 ;
27397: LD_ADDR_EXP 15
27401: PUSH
27402: LD_INT 10
27404: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27405: LD_ADDR_VAR 0 1
27409: PUSH
27410: LD_INT 22
27412: PUSH
27413: LD_INT 1
27415: PUSH
27416: EMPTY
27417: LIST
27418: LIST
27419: PUSH
27420: LD_INT 23
27422: PUSH
27423: LD_INT 1
27425: PUSH
27426: EMPTY
27427: LIST
27428: LIST
27429: PUSH
27430: LD_INT 26
27432: PUSH
27433: LD_INT 1
27435: PUSH
27436: EMPTY
27437: LIST
27438: LIST
27439: PUSH
27440: LD_INT 3
27442: PUSH
27443: LD_INT 25
27445: PUSH
27446: LD_INT 12
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: PUSH
27453: EMPTY
27454: LIST
27455: LIST
27456: PUSH
27457: LD_INT 3
27459: PUSH
27460: LD_INT 25
27462: PUSH
27463: LD_INT 16
27465: PUSH
27466: EMPTY
27467: LIST
27468: LIST
27469: PUSH
27470: EMPTY
27471: LIST
27472: LIST
27473: PUSH
27474: EMPTY
27475: LIST
27476: LIST
27477: LIST
27478: LIST
27479: LIST
27480: PPUSH
27481: CALL_OW 69
27485: PUSH
27486: LD_EXP 39
27490: PUSH
27491: LD_EXP 60
27495: PUSH
27496: LD_EXP 41
27500: PUSH
27501: LD_EXP 55
27505: PUSH
27506: LD_EXP 42
27510: PUSH
27511: LD_EXP 43
27515: PUSH
27516: LD_EXP 44
27520: PUSH
27521: LD_EXP 45
27525: PUSH
27526: LD_EXP 46
27530: PUSH
27531: LD_EXP 47
27535: PUSH
27536: LD_EXP 48
27540: PUSH
27541: LD_EXP 49
27545: PUSH
27546: LD_EXP 50
27550: PUSH
27551: LD_EXP 51
27555: PUSH
27556: LD_EXP 52
27560: PUSH
27561: LD_EXP 53
27565: PUSH
27566: EMPTY
27567: LIST
27568: LIST
27569: LIST
27570: LIST
27571: LIST
27572: LIST
27573: LIST
27574: LIST
27575: LIST
27576: LIST
27577: LIST
27578: LIST
27579: LIST
27580: LIST
27581: LIST
27582: LIST
27583: DIFF
27584: ST_TO_ADDR
// if not tmp and Brown then
27585: LD_VAR 0 1
27589: NOT
27590: PUSH
27591: LD_EXP 47
27595: AND
27596: IFFALSE 27611
// tmp := [ Brown ] ;
27598: LD_ADDR_VAR 0 1
27602: PUSH
27603: LD_EXP 47
27607: PUSH
27608: EMPTY
27609: LIST
27610: ST_TO_ADDR
// DialogueOn ;
27611: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27615: LD_VAR 0 1
27619: PUSH
27620: LD_INT 1
27622: ARRAY
27623: PPUSH
27624: LD_STRING D11-Sol1-1
27626: PPUSH
27627: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27631: LD_EXP 64
27635: PPUSH
27636: LD_STRING D11-Pla-1
27638: PPUSH
27639: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27643: LD_EXP 65
27647: PPUSH
27648: LD_STRING D11-Kov-1
27650: PPUSH
27651: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27655: LD_EXP 64
27659: PPUSH
27660: LD_STRING D11-Pla-2
27662: PPUSH
27663: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27667: LD_VAR 0 1
27671: PUSH
27672: LD_INT 1
27674: ARRAY
27675: PPUSH
27676: LD_STRING D11-Sol1-2
27678: PPUSH
27679: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27683: LD_EXP 39
27687: PPUSH
27688: LD_STRING D11-JMM-2
27690: PPUSH
27691: CALL_OW 88
// DialogueOff ;
27695: CALL_OW 7
// allowBehemothConstruct := true ;
27699: LD_ADDR_EXP 25
27703: PUSH
27704: LD_INT 1
27706: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27707: LD_STRING M4
27709: PPUSH
27710: CALL_OW 337
// BuildBehemoths ;
27714: CALL 7693 0 0
// repeat wait ( 15 15$00 ) ;
27718: LD_INT 31500
27720: PPUSH
27721: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27725: LD_EXP 27
27729: IFFALSE 27733
// break ;
27731: GO 27765
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27733: LD_INT 267
27735: PPUSH
27736: CALL_OW 274
27740: PPUSH
27741: LD_INT 1
27743: PPUSH
27744: CALL_OW 275
27748: PUSH
27749: LD_INT 1000
27751: GREATEREQUAL
27752: IFFALSE 27758
// BuildBehemoths ;
27754: CALL 7693 0 0
// until not behemothBuilders ;
27758: LD_EXP 73
27762: NOT
27763: IFFALSE 27718
// end ;
27765: PPOPN 1
27767: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27768: LD_EXP 73
27772: NOT
27773: PUSH
27774: LD_EXP 28
27778: NOT
27779: AND
27780: PUSH
27781: LD_EXP 25
27785: AND
27786: IFFALSE 27806
27788: GO 27790
27790: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27791: LD_STRING M4a
27793: PPUSH
27794: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27798: LD_ADDR_EXP 27
27802: PUSH
27803: LD_INT 1
27805: ST_TO_ADDR
// end ;
27806: END
// every 0 0$1 trigger behemothDone do
27807: LD_EXP 28
27811: IFFALSE 27823
27813: GO 27815
27815: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27816: LD_STRING M4b
27818: PPUSH
27819: CALL_OW 337
27823: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27824: LD_EXP 29
27828: NOT
27829: IFFALSE 28025
27831: GO 27833
27833: DISABLE
27834: LD_INT 0
27836: PPUSH
27837: PPUSH
// begin enable ;
27838: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27839: LD_ADDR_VAR 0 1
27843: PUSH
27844: LD_INT 3
27846: PPUSH
27847: CALL 102420 0 1
27851: ST_TO_ADDR
// if not tmp and not behemothDone then
27852: LD_VAR 0 1
27856: NOT
27857: PUSH
27858: LD_EXP 28
27862: NOT
27863: AND
27864: IFFALSE 27900
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27866: LD_ADDR_VAR 0 1
27870: PUSH
27871: LD_INT 22
27873: PUSH
27874: LD_INT 3
27876: PUSH
27877: EMPTY
27878: LIST
27879: LIST
27880: PUSH
27881: LD_INT 30
27883: PUSH
27884: LD_INT 37
27886: PUSH
27887: EMPTY
27888: LIST
27889: LIST
27890: PUSH
27891: EMPTY
27892: LIST
27893: LIST
27894: PPUSH
27895: CALL_OW 69
27899: ST_TO_ADDR
// if not tmp then
27900: LD_VAR 0 1
27904: NOT
27905: IFFALSE 27909
// exit ;
27907: GO 28025
// for i in tmp do
27909: LD_ADDR_VAR 0 2
27913: PUSH
27914: LD_VAR 0 1
27918: PUSH
27919: FOR_IN
27920: IFFALSE 28023
// if See ( 1 , i ) then
27922: LD_INT 1
27924: PPUSH
27925: LD_VAR 0 2
27929: PPUSH
27930: CALL_OW 292
27934: IFFALSE 28021
// begin if GetType ( i ) = unit_building then
27936: LD_VAR 0 2
27940: PPUSH
27941: CALL_OW 247
27945: PUSH
27946: LD_INT 3
27948: EQUAL
27949: IFFALSE 27987
// begin CenterNowOnUnits ( i ) ;
27951: LD_VAR 0 2
27955: PPUSH
27956: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27960: LD_EXP 39
27964: PPUSH
27965: LD_STRING D17a-JMM-1
27967: PPUSH
27968: CALL_OW 88
// seeBehemoth := true ;
27972: LD_ADDR_EXP 29
27976: PUSH
27977: LD_INT 1
27979: ST_TO_ADDR
// disable ;
27980: DISABLE
// exit ;
27981: POP
27982: POP
27983: GO 28025
// end else
27985: GO 28021
// begin CenterNowOnUnits ( i ) ;
27987: LD_VAR 0 2
27991: PPUSH
27992: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27996: LD_EXP 39
28000: PPUSH
28001: LD_STRING D17b-JMM-1
28003: PPUSH
28004: CALL_OW 88
// seeBehemoth := true ;
28008: LD_ADDR_EXP 29
28012: PUSH
28013: LD_INT 1
28015: ST_TO_ADDR
// disable ;
28016: DISABLE
// exit ;
28017: POP
28018: POP
28019: GO 28025
// end ; end ;
28021: GO 27919
28023: POP
28024: POP
// end ;
28025: PPOPN 2
28027: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
28028: LD_EXP 14
28032: PUSH
28033: LD_INT 123200
28035: GREATEREQUAL
28036: IFFALSE 29212
28038: GO 28040
28040: DISABLE
28041: LD_INT 0
28043: PPUSH
28044: PPUSH
28045: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
28046: LD_INT 2
28048: PPUSH
28049: LD_INT 23
28051: PUSH
28052: LD_INT 3
28054: PUSH
28055: LD_INT 3
28057: PUSH
28058: LD_INT 48
28060: PUSH
28061: EMPTY
28062: LIST
28063: LIST
28064: LIST
28065: LIST
28066: PUSH
28067: EMPTY
28068: LIST
28069: PPUSH
28070: CALL 59216 0 2
// repeat wait ( 0 0$1 ) ;
28074: LD_INT 35
28076: PPUSH
28077: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28081: LD_INT 22
28083: PUSH
28084: LD_INT 3
28086: PUSH
28087: EMPTY
28088: LIST
28089: LIST
28090: PUSH
28091: LD_INT 34
28093: PUSH
28094: LD_INT 48
28096: PUSH
28097: EMPTY
28098: LIST
28099: LIST
28100: PUSH
28101: EMPTY
28102: LIST
28103: LIST
28104: PPUSH
28105: CALL_OW 69
28109: IFFALSE 28074
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28111: LD_ADDR_VAR 0 1
28115: PUSH
28116: LD_INT 22
28118: PUSH
28119: LD_INT 3
28121: PUSH
28122: EMPTY
28123: LIST
28124: LIST
28125: PUSH
28126: LD_INT 34
28128: PUSH
28129: LD_INT 48
28131: PUSH
28132: EMPTY
28133: LIST
28134: LIST
28135: PUSH
28136: EMPTY
28137: LIST
28138: LIST
28139: PPUSH
28140: CALL_OW 69
28144: PUSH
28145: LD_INT 1
28147: ARRAY
28148: ST_TO_ADDR
// missionStage := 12 ;
28149: LD_ADDR_EXP 15
28153: PUSH
28154: LD_INT 12
28156: ST_TO_ADDR
// platonovHasBomb := true ;
28157: LD_ADDR_EXP 30
28161: PUSH
28162: LD_INT 1
28164: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28165: LD_VAR 0 1
28169: PPUSH
28170: LD_INT 181
28172: PPUSH
28173: LD_INT 86
28175: PPUSH
28176: CALL_OW 171
// AddComHold ( bomb ) ;
28180: LD_VAR 0 1
28184: PPUSH
28185: CALL_OW 200
// wait ( 0 0$10 ) ;
28189: LD_INT 350
28191: PPUSH
28192: CALL_OW 67
// DialogueOn ;
28196: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28200: LD_EXP 64
28204: PPUSH
28205: LD_STRING D15-Pla-1
28207: PPUSH
28208: CALL_OW 94
// dec = Query ( Q15a ) ;
28212: LD_ADDR_VAR 0 2
28216: PUSH
28217: LD_STRING Q15a
28219: PPUSH
28220: CALL_OW 97
28224: ST_TO_ADDR
// if dec = 1 then
28225: LD_VAR 0 2
28229: PUSH
28230: LD_INT 1
28232: EQUAL
28233: IFFALSE 28256
// begin Say ( JMM , D15a-JMM-1 ) ;
28235: LD_EXP 39
28239: PPUSH
28240: LD_STRING D15a-JMM-1
28242: PPUSH
28243: CALL_OW 88
// YouLost ( Surrender ) ;
28247: LD_STRING Surrender
28249: PPUSH
28250: CALL_OW 104
// exit ;
28254: GO 29212
// end ; if dec = 2 then
28256: LD_VAR 0 2
28260: PUSH
28261: LD_INT 2
28263: EQUAL
28264: IFFALSE 28333
// begin Say ( JMM , D15b-JMM-1 ) ;
28266: LD_EXP 39
28270: PPUSH
28271: LD_STRING D15b-JMM-1
28273: PPUSH
28274: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28278: LD_EXP 64
28282: PPUSH
28283: LD_STRING D15b-Pla-1
28285: PPUSH
28286: CALL_OW 94
// DialogueOff ;
28290: CALL_OW 7
// wait ( 3 3$00 ) ;
28294: LD_INT 6300
28296: PPUSH
28297: CALL_OW 67
// DialogueOn ;
28301: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28305: LD_EXP 39
28309: PPUSH
28310: LD_STRING D15d-JMM-1a
28312: PPUSH
28313: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28317: LD_EXP 64
28321: PPUSH
28322: LD_STRING D15d-Pla-1
28324: PPUSH
28325: CALL_OW 94
// DialogueOff ;
28329: CALL_OW 7
// end ; if dec = 3 then
28333: LD_VAR 0 2
28337: PUSH
28338: LD_INT 3
28340: EQUAL
28341: IFFALSE 28395
// begin Say ( JMM , D15c-JMM-1 ) ;
28343: LD_EXP 39
28347: PPUSH
28348: LD_STRING D15c-JMM-1
28350: PPUSH
28351: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28355: LD_EXP 64
28359: PPUSH
28360: LD_STRING D15c-Pla-1
28362: PPUSH
28363: CALL_OW 94
// DialogueOff ;
28367: CALL_OW 7
// wait ( 0 0$15 ) ;
28371: LD_INT 525
28373: PPUSH
28374: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28378: LD_VAR 0 1
28382: PPUSH
28383: LD_INT 60
28385: PPUSH
28386: LD_INT 95
28388: PPUSH
28389: CALL_OW 116
// exit ;
28393: GO 29212
// end ; if dec = 4 then
28395: LD_VAR 0 2
28399: PUSH
28400: LD_INT 4
28402: EQUAL
28403: IFFALSE 28433
// begin Say ( JMM , D15d-JMM-1 ) ;
28405: LD_EXP 39
28409: PPUSH
28410: LD_STRING D15d-JMM-1
28412: PPUSH
28413: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28417: LD_EXP 64
28421: PPUSH
28422: LD_STRING D15d-Pla-1
28424: PPUSH
28425: CALL_OW 94
// DialogueOff ;
28429: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28433: LD_EXP 62
28437: PPUSH
28438: CALL_OW 302
28442: PUSH
28443: LD_EXP 62
28447: PPUSH
28448: CALL_OW 255
28452: PUSH
28453: LD_INT 1
28455: EQUAL
28456: AND
28457: PUSH
28458: LD_INT 22
28460: PUSH
28461: LD_INT 1
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PUSH
28468: LD_INT 34
28470: PUSH
28471: LD_INT 8
28473: PUSH
28474: EMPTY
28475: LIST
28476: LIST
28477: PUSH
28478: EMPTY
28479: LIST
28480: LIST
28481: PPUSH
28482: CALL_OW 69
28486: NOT
28487: AND
28488: IFFALSE 29113
// begin SetSide ( Friend , 8 ) ;
28490: LD_EXP 62
28494: PPUSH
28495: LD_INT 8
28497: PPUSH
28498: CALL_OW 235
// if IsInUnit ( Friend ) then
28502: LD_EXP 62
28506: PPUSH
28507: CALL_OW 310
28511: IFFALSE 28522
// ComExitBuilding ( Friend ) ;
28513: LD_EXP 62
28517: PPUSH
28518: CALL_OW 122
// if IsDriver ( Friend ) then
28522: LD_EXP 62
28526: PPUSH
28527: CALL 99965 0 1
28531: IFFALSE 28542
// ComExitVehicle ( Friend ) ;
28533: LD_EXP 62
28537: PPUSH
28538: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28542: LD_EXP 62
28546: PPUSH
28547: LD_INT 9
28549: PPUSH
28550: LD_INT 2
28552: PPUSH
28553: CALL_OW 171
// wait ( 0 0$05 ) ;
28557: LD_INT 175
28559: PPUSH
28560: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28564: LD_EXP 62
28568: PPUSH
28569: CALL_OW 87
// DialogueOn ;
28573: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28577: LD_EXP 39
28581: PPUSH
28582: LD_STRING D16-JMM-1
28584: PPUSH
28585: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28589: LD_EXP 62
28593: PPUSH
28594: LD_STRING D16-Friend-1
28596: PPUSH
28597: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28601: LD_EXP 39
28605: PPUSH
28606: LD_STRING D16-JMM-2
28608: PPUSH
28609: CALL_OW 88
// DialogueOff ;
28613: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28617: LD_EXP 62
28621: PPUSH
28622: LD_INT 1
28624: PPUSH
28625: CALL_OW 235
// ComHold ( Friend ) ;
28629: LD_EXP 62
28633: PPUSH
28634: CALL_OW 140
// wait ( 0 0$20 ) ;
28638: LD_INT 700
28640: PPUSH
28641: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28645: LD_EXP 62
28649: PPUSH
28650: LD_INT 9
28652: PPUSH
28653: LD_INT 2
28655: PPUSH
28656: CALL_OW 297
28660: PUSH
28661: LD_INT 30
28663: LESS
28664: IFFALSE 28733
// begin SetSide ( Friend , 8 ) ;
28666: LD_EXP 62
28670: PPUSH
28671: LD_INT 8
28673: PPUSH
28674: CALL_OW 235
// if IsInUnit ( Friend ) then
28678: LD_EXP 62
28682: PPUSH
28683: CALL_OW 310
28687: IFFALSE 28698
// ComExitBuilding ( Friend ) ;
28689: LD_EXP 62
28693: PPUSH
28694: CALL_OW 122
// if IsDriver ( Friend ) then
28698: LD_EXP 62
28702: PPUSH
28703: CALL 99965 0 1
28707: IFFALSE 28718
// ComExitVehicle ( Friend ) ;
28709: LD_EXP 62
28713: PPUSH
28714: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28718: LD_EXP 62
28722: PPUSH
28723: LD_INT 9
28725: PPUSH
28726: LD_INT 2
28728: PPUSH
28729: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28733: LD_INT 1050
28735: PPUSH
28736: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28740: LD_INT 22
28742: PUSH
28743: LD_INT 1
28745: PUSH
28746: EMPTY
28747: LIST
28748: LIST
28749: PUSH
28750: LD_INT 34
28752: PUSH
28753: LD_INT 8
28755: PUSH
28756: EMPTY
28757: LIST
28758: LIST
28759: PUSH
28760: EMPTY
28761: LIST
28762: LIST
28763: PPUSH
28764: CALL_OW 69
28768: NOT
28769: IFFALSE 29091
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28771: LD_ADDR_VAR 0 3
28775: PUSH
28776: LD_INT 22
28778: PUSH
28779: LD_INT 1
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: PUSH
28786: LD_INT 26
28788: PUSH
28789: LD_INT 1
28791: PUSH
28792: EMPTY
28793: LIST
28794: LIST
28795: PUSH
28796: LD_INT 3
28798: PUSH
28799: LD_INT 25
28801: PUSH
28802: LD_INT 12
28804: PUSH
28805: EMPTY
28806: LIST
28807: LIST
28808: PUSH
28809: LD_INT 25
28811: PUSH
28812: LD_INT 16
28814: PUSH
28815: EMPTY
28816: LIST
28817: LIST
28818: PUSH
28819: EMPTY
28820: LIST
28821: LIST
28822: LIST
28823: PUSH
28824: EMPTY
28825: LIST
28826: LIST
28827: LIST
28828: PPUSH
28829: CALL_OW 69
28833: PUSH
28834: LD_EXP 39
28838: PUSH
28839: LD_EXP 41
28843: PUSH
28844: LD_EXP 55
28848: PUSH
28849: LD_EXP 42
28853: PUSH
28854: LD_EXP 43
28858: PUSH
28859: LD_EXP 44
28863: PUSH
28864: LD_EXP 45
28868: PUSH
28869: LD_EXP 46
28873: PUSH
28874: LD_EXP 47
28878: PUSH
28879: LD_EXP 48
28883: PUSH
28884: LD_EXP 49
28888: PUSH
28889: LD_EXP 50
28893: PUSH
28894: LD_EXP 51
28898: PUSH
28899: LD_EXP 52
28903: PUSH
28904: LD_EXP 53
28908: PUSH
28909: EMPTY
28910: LIST
28911: LIST
28912: LIST
28913: LIST
28914: LIST
28915: LIST
28916: LIST
28917: LIST
28918: LIST
28919: LIST
28920: LIST
28921: LIST
28922: LIST
28923: LIST
28924: LIST
28925: DIFF
28926: ST_TO_ADDR
// DialogueOn ;
28927: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28931: LD_EXP 64
28935: PPUSH
28936: LD_STRING D16a-Pla-1
28938: PPUSH
28939: CALL_OW 94
// if Stevens then
28943: LD_EXP 41
28947: IFFALSE 28963
// Say ( Stevens , D16a-Huck-1 ) else
28949: LD_EXP 41
28953: PPUSH
28954: LD_STRING D16a-Huck-1
28956: PPUSH
28957: CALL_OW 88
28961: GO 29005
// if Baker then
28963: LD_EXP 55
28967: IFFALSE 28983
// Say ( Baker , D16a-Huck-1 ) else
28969: LD_EXP 55
28973: PPUSH
28974: LD_STRING D16a-Huck-1
28976: PPUSH
28977: CALL_OW 88
28981: GO 29005
// if tmp then
28983: LD_VAR 0 3
28987: IFFALSE 29005
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28989: LD_VAR 0 3
28993: PUSH
28994: LD_INT 1
28996: ARRAY
28997: PPUSH
28998: LD_STRING D16a-Sol1-1
29000: PPUSH
29001: CALL_OW 88
// if GetSide ( Friend ) = 8 then
29005: LD_EXP 62
29009: PPUSH
29010: CALL_OW 255
29014: PUSH
29015: LD_INT 8
29017: EQUAL
29018: IFFALSE 29034
// Say ( JMM , D16a-JMM-1 ) else
29020: LD_EXP 39
29024: PPUSH
29025: LD_STRING D16a-JMM-1
29027: PPUSH
29028: CALL_OW 88
29032: GO 29070
// begin Say ( JMM , D16a-JMM-1a ) ;
29034: LD_EXP 39
29038: PPUSH
29039: LD_STRING D16a-JMM-1a
29041: PPUSH
29042: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
29046: LD_EXP 62
29050: PPUSH
29051: LD_STRING D16a-Friend-1
29053: PPUSH
29054: CALL_OW 88
// SetSide ( Friend , 3 ) ;
29058: LD_EXP 62
29062: PPUSH
29063: LD_INT 3
29065: PPUSH
29066: CALL_OW 235
// end ; DialogueOff ;
29070: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29074: LD_VAR 0 1
29078: PPUSH
29079: LD_INT 60
29081: PPUSH
29082: LD_INT 95
29084: PPUSH
29085: CALL_OW 116
// end else
29089: GO 29111
// begin DialogueOn ;
29091: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29095: LD_EXP 64
29099: PPUSH
29100: LD_STRING D16c-Pla-
29102: PPUSH
29103: CALL_OW 94
// DialogueOff ;
29107: CALL_OW 7
// end ; end else
29111: GO 29212
// begin wait ( 3 3$00 ) ;
29113: LD_INT 6300
29115: PPUSH
29116: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29120: LD_INT 22
29122: PUSH
29123: LD_INT 1
29125: PUSH
29126: EMPTY
29127: LIST
29128: LIST
29129: PUSH
29130: LD_INT 34
29132: PUSH
29133: LD_INT 8
29135: PUSH
29136: EMPTY
29137: LIST
29138: LIST
29139: PUSH
29140: EMPTY
29141: LIST
29142: LIST
29143: PPUSH
29144: CALL_OW 69
29148: NOT
29149: IFFALSE 29192
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29151: LD_EXP 64
29155: PPUSH
29156: LD_STRING D16b-Pla-1
29158: PPUSH
29159: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29163: LD_EXP 39
29167: PPUSH
29168: LD_STRING D16b-JMM-
29170: PPUSH
29171: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29175: LD_VAR 0 1
29179: PPUSH
29180: LD_INT 60
29182: PPUSH
29183: LD_INT 95
29185: PPUSH
29186: CALL_OW 116
// end else
29190: GO 29212
// begin DialogueOn ;
29192: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29196: LD_EXP 64
29200: PPUSH
29201: LD_STRING D16c-Pla-
29203: PPUSH
29204: CALL_OW 94
// DialogueOff ;
29208: CALL_OW 7
// end ; end ; end ;
29212: PPOPN 3
29214: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29215: LD_EXP 14
29219: PUSH
29220: LD_INT 126000
29222: GREATEREQUAL
29223: PUSH
29224: LD_EXP 23
29228: NOT
29229: AND
29230: PUSH
29231: LD_EXP 74
29235: PPUSH
29236: CALL_OW 302
29240: AND
29241: IFFALSE 29599
29243: GO 29245
29245: DISABLE
29246: LD_INT 0
29248: PPUSH
// begin missionStage = 11 ;
29249: LD_ADDR_EXP 15
29253: PUSH
29254: LD_INT 11
29256: ST_TO_ADDR
// DialogueOn ;
29257: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29261: LD_EXP 74
29265: PPUSH
29266: LD_STRING D9-Roth-1
29268: PPUSH
29269: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29273: LD_EXP 39
29277: PPUSH
29278: LD_STRING D9-JMM-1
29280: PPUSH
29281: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29285: LD_EXP 74
29289: PPUSH
29290: LD_STRING D9-Roth-2
29292: PPUSH
29293: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29297: LD_EXP 74
29301: PPUSH
29302: LD_STRING D9-Roth-2a
29304: PPUSH
29305: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29309: LD_EXP 64
29313: PPUSH
29314: LD_STRING D9-Pla-2
29316: PPUSH
29317: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29321: LD_EXP 74
29325: PPUSH
29326: LD_STRING D9-Roth-3
29328: PPUSH
29329: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29333: LD_EXP 64
29337: PPUSH
29338: LD_STRING D9-Pla-3
29340: PPUSH
29341: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29345: LD_EXP 74
29349: PPUSH
29350: LD_STRING D9-Roth-4
29352: PPUSH
29353: CALL_OW 94
// dec = Query ( Q9 ) ;
29357: LD_ADDR_VAR 0 1
29361: PUSH
29362: LD_STRING Q9
29364: PPUSH
29365: CALL_OW 97
29369: ST_TO_ADDR
// if dec = 1 then
29370: LD_VAR 0 1
29374: PUSH
29375: LD_INT 1
29377: EQUAL
29378: IFFALSE 29392
// SayRadio ( Roth , D9a-Roth-1 ) ;
29380: LD_EXP 74
29384: PPUSH
29385: LD_STRING D9a-Roth-1
29387: PPUSH
29388: CALL_OW 94
// if dec = 2 then
29392: LD_VAR 0 1
29396: PUSH
29397: LD_INT 2
29399: EQUAL
29400: IFFALSE 29426
// begin Say ( JMM , D9b-JMM-1 ) ;
29402: LD_EXP 39
29406: PPUSH
29407: LD_STRING D9b-JMM-1
29409: PPUSH
29410: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29414: LD_EXP 74
29418: PPUSH
29419: LD_STRING D9b-Roth-1
29421: PPUSH
29422: CALL_OW 94
// end ; if dec = 3 then
29426: LD_VAR 0 1
29430: PUSH
29431: LD_INT 3
29433: EQUAL
29434: IFFALSE 29496
// begin Say ( JMM , D9c-JMM-1 ) ;
29436: LD_EXP 39
29440: PPUSH
29441: LD_STRING D9c-JMM-1
29443: PPUSH
29444: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29448: LD_EXP 74
29452: PPUSH
29453: LD_STRING D9c-Roth-1
29455: PPUSH
29456: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29460: LD_EXP 39
29464: PPUSH
29465: LD_STRING D9c-JMM-2
29467: PPUSH
29468: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29472: LD_EXP 74
29476: PPUSH
29477: LD_STRING D9c-Roth-2
29479: PPUSH
29480: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29484: LD_EXP 39
29488: PPUSH
29489: LD_STRING D9c-JMM-3
29491: PPUSH
29492: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29496: LD_EXP 74
29500: PPUSH
29501: LD_STRING D9c-Roth-3
29503: PPUSH
29504: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29508: LD_EXP 74
29512: PPUSH
29513: LD_STRING D9cont-Roth-1
29515: PPUSH
29516: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29520: LD_EXP 39
29524: PPUSH
29525: LD_STRING D9cont-JMM-1
29527: PPUSH
29528: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29532: LD_EXP 74
29536: PPUSH
29537: LD_STRING D9cont-Roth-2
29539: PPUSH
29540: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29544: LD_EXP 39
29548: PPUSH
29549: LD_STRING D9cont-JMM-2
29551: PPUSH
29552: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29556: LD_EXP 74
29560: PPUSH
29561: LD_STRING D9cont-Roth-3
29563: PPUSH
29564: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29568: LD_EXP 39
29572: PPUSH
29573: LD_STRING D9cont-JMM-3
29575: PPUSH
29576: CALL_OW 88
// DialogueOff ;
29580: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29584: LD_STRING M3
29586: PPUSH
29587: CALL_OW 337
// allianceActive := true ;
29591: LD_ADDR_EXP 31
29595: PUSH
29596: LD_INT 1
29598: ST_TO_ADDR
// end ;
29599: PPOPN 1
29601: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
29602: LD_INT 1
29604: PPUSH
29605: LD_INT 126
29607: PPUSH
29608: CALL_OW 292
29612: PUSH
29613: LD_EXP 64
29617: PPUSH
29618: CALL_OW 310
29622: AND
29623: IFFALSE 29703
29625: GO 29627
29627: DISABLE
29628: LD_INT 0
29630: PPUSH
// begin ComExitBuilding ( Platonov ) ;
29631: LD_EXP 64
29635: PPUSH
29636: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
29640: LD_ADDR_VAR 0 1
29644: PUSH
29645: LD_INT 4
29647: PPUSH
29648: LD_INT 22
29650: PUSH
29651: LD_INT 1
29653: PUSH
29654: EMPTY
29655: LIST
29656: LIST
29657: PPUSH
29658: CALL_OW 70
29662: PPUSH
29663: LD_EXP 64
29667: PPUSH
29668: CALL_OW 74
29672: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
29673: LD_EXP 64
29677: PPUSH
29678: LD_VAR 0 1
29682: PUSH
29683: LD_INT 1
29685: ARRAY
29686: PPUSH
29687: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
29691: LD_EXP 64
29695: PPUSH
29696: LD_STRING D18-Pla-1
29698: PPUSH
29699: CALL_OW 88
// end ;
29703: PPOPN 1
29705: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29706: LD_EXP 64
29710: PPUSH
29711: CALL_OW 301
29715: PUSH
29716: LD_EXP 67
29720: PPUSH
29721: CALL_OW 301
29725: AND
29726: PUSH
29727: LD_INT 22
29729: PUSH
29730: LD_INT 3
29732: PUSH
29733: EMPTY
29734: LIST
29735: LIST
29736: PUSH
29737: LD_INT 21
29739: PUSH
29740: LD_INT 1
29742: PUSH
29743: EMPTY
29744: LIST
29745: LIST
29746: PUSH
29747: LD_INT 50
29749: PUSH
29750: EMPTY
29751: LIST
29752: PUSH
29753: EMPTY
29754: LIST
29755: LIST
29756: LIST
29757: PPUSH
29758: CALL_OW 69
29762: PUSH
29763: LD_INT 7
29765: PUSH
29766: LD_INT 8
29768: PUSH
29769: LD_INT 9
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: LIST
29776: PUSH
29777: LD_OWVAR 67
29781: ARRAY
29782: LESS
29783: AND
29784: IFFALSE 30555
29786: GO 29788
29788: DISABLE
29789: LD_INT 0
29791: PPUSH
29792: PPUSH
29793: PPUSH
29794: PPUSH
// begin MC_Kill ( 2 ) ;
29795: LD_INT 2
29797: PPUSH
29798: CALL 35385 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29802: LD_INT 1
29804: PPUSH
29805: LD_INT 3
29807: PPUSH
29808: LD_INT 1
29810: PPUSH
29811: LD_INT 1
29813: PPUSH
29814: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29818: LD_ADDR_VAR 0 1
29822: PUSH
29823: LD_INT 22
29825: PUSH
29826: LD_INT 3
29828: PUSH
29829: EMPTY
29830: LIST
29831: LIST
29832: PUSH
29833: LD_INT 21
29835: PUSH
29836: LD_INT 1
29838: PUSH
29839: EMPTY
29840: LIST
29841: LIST
29842: PUSH
29843: LD_INT 24
29845: PUSH
29846: LD_INT 900
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: LIST
29857: PPUSH
29858: CALL_OW 69
29862: PUSH
29863: FOR_IN
29864: IFFALSE 29895
// if GetSex ( i ) = sex_male then
29866: LD_VAR 0 1
29870: PPUSH
29871: CALL_OW 258
29875: PUSH
29876: LD_INT 1
29878: EQUAL
29879: IFFALSE 29893
// begin tmp = i ;
29881: LD_ADDR_VAR 0 2
29885: PUSH
29886: LD_VAR 0 1
29890: ST_TO_ADDR
// break ;
29891: GO 29895
// end ;
29893: GO 29863
29895: POP
29896: POP
// if tmp = 0 then
29897: LD_VAR 0 2
29901: PUSH
29902: LD_INT 0
29904: EQUAL
29905: IFFALSE 29959
// begin uc_side = 3 ;
29907: LD_ADDR_OWVAR 20
29911: PUSH
29912: LD_INT 3
29914: ST_TO_ADDR
// uc_nation = 3 ;
29915: LD_ADDR_OWVAR 21
29919: PUSH
29920: LD_INT 3
29922: ST_TO_ADDR
// hc_name =  ;
29923: LD_ADDR_OWVAR 26
29927: PUSH
29928: LD_STRING 
29930: ST_TO_ADDR
// hc_gallery =  ;
29931: LD_ADDR_OWVAR 33
29935: PUSH
29936: LD_STRING 
29938: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29939: LD_INT 1
29941: PPUSH
29942: LD_INT 10
29944: PPUSH
29945: CALL_OW 381
// tmp = CreateHuman ;
29949: LD_ADDR_VAR 0 2
29953: PUSH
29954: CALL_OW 44
29958: ST_TO_ADDR
// end ; DialogueOn ;
29959: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29963: LD_VAR 0 2
29967: PPUSH
29968: LD_STRING DSurrenderRussians-RSol1-1a
29970: PPUSH
29971: CALL_OW 94
// DialogueOff ;
29975: CALL_OW 7
// russianDestroyed := true ;
29979: LD_ADDR_EXP 21
29983: PUSH
29984: LD_INT 1
29986: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29987: LD_INT 22
29989: PUSH
29990: LD_INT 3
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: PUSH
29997: LD_INT 21
29999: PUSH
30000: LD_INT 1
30002: PUSH
30003: EMPTY
30004: LIST
30005: LIST
30006: PUSH
30007: EMPTY
30008: LIST
30009: LIST
30010: PPUSH
30011: CALL_OW 69
30015: PPUSH
30016: CALL_OW 122
// wait ( 0 0$1 ) ;
30020: LD_INT 35
30022: PPUSH
30023: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
30027: LD_INT 22
30029: PUSH
30030: LD_INT 3
30032: PUSH
30033: EMPTY
30034: LIST
30035: LIST
30036: PUSH
30037: LD_INT 21
30039: PUSH
30040: LD_INT 1
30042: PUSH
30043: EMPTY
30044: LIST
30045: LIST
30046: PUSH
30047: EMPTY
30048: LIST
30049: LIST
30050: PPUSH
30051: CALL_OW 69
30055: PPUSH
30056: LD_INT 25
30058: PPUSH
30059: CALL_OW 173
// wait ( 0 0$10 ) ;
30063: LD_INT 350
30065: PPUSH
30066: CALL_OW 67
// PrepareOmarInvasion ;
30070: CALL 13903 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
30074: LD_ADDR_VAR 0 2
30078: PUSH
30079: LD_EXP 92
30083: PPUSH
30084: CALL_OW 250
30088: PUSH
30089: LD_EXP 92
30093: PPUSH
30094: CALL_OW 251
30098: PUSH
30099: EMPTY
30100: LIST
30101: LIST
30102: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
30103: LD_VAR 0 2
30107: PUSH
30108: LD_INT 1
30110: ARRAY
30111: PPUSH
30112: LD_VAR 0 2
30116: PUSH
30117: LD_INT 2
30119: ARRAY
30120: PPUSH
30121: LD_INT 1
30123: PPUSH
30124: LD_INT 8
30126: NEG
30127: PPUSH
30128: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
30132: LD_EXP 92
30136: PPUSH
30137: CALL_OW 87
// DialogueOn ;
30141: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
30145: LD_EXP 39
30149: PPUSH
30150: LD_STRING D19-JMM-1
30152: PPUSH
30153: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
30157: LD_ADDR_VAR 0 3
30161: PUSH
30162: LD_INT 22
30164: PUSH
30165: LD_INT 1
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: PUSH
30172: LD_INT 26
30174: PUSH
30175: LD_INT 1
30177: PUSH
30178: EMPTY
30179: LIST
30180: LIST
30181: PUSH
30182: LD_INT 2
30184: PUSH
30185: LD_INT 25
30187: PUSH
30188: LD_INT 1
30190: PUSH
30191: EMPTY
30192: LIST
30193: LIST
30194: PUSH
30195: LD_INT 25
30197: PUSH
30198: LD_INT 2
30200: PUSH
30201: EMPTY
30202: LIST
30203: LIST
30204: PUSH
30205: LD_INT 25
30207: PUSH
30208: LD_INT 3
30210: PUSH
30211: EMPTY
30212: LIST
30213: LIST
30214: PUSH
30215: LD_INT 25
30217: PUSH
30218: LD_INT 4
30220: PUSH
30221: EMPTY
30222: LIST
30223: LIST
30224: PUSH
30225: LD_INT 25
30227: PUSH
30228: LD_INT 5
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 25
30237: PUSH
30238: LD_INT 8
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: LIST
30249: LIST
30250: LIST
30251: LIST
30252: LIST
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: LIST
30258: PPUSH
30259: CALL_OW 69
30263: PUSH
30264: LD_EXP 39
30268: PUSH
30269: LD_EXP 40
30273: PUSH
30274: LD_EXP 41
30278: PUSH
30279: LD_EXP 42
30283: PUSH
30284: LD_EXP 43
30288: PUSH
30289: LD_EXP 44
30293: PUSH
30294: LD_EXP 45
30298: PUSH
30299: LD_EXP 46
30303: PUSH
30304: LD_EXP 47
30308: PUSH
30309: LD_EXP 48
30313: PUSH
30314: LD_EXP 49
30318: PUSH
30319: LD_EXP 50
30323: PUSH
30324: LD_EXP 51
30328: PUSH
30329: LD_EXP 52
30333: PUSH
30334: LD_EXP 53
30338: PUSH
30339: LD_EXP 54
30343: PUSH
30344: LD_EXP 55
30348: PUSH
30349: EMPTY
30350: LIST
30351: LIST
30352: LIST
30353: LIST
30354: LIST
30355: LIST
30356: LIST
30357: LIST
30358: LIST
30359: LIST
30360: LIST
30361: LIST
30362: LIST
30363: LIST
30364: LIST
30365: LIST
30366: LIST
30367: DIFF
30368: ST_TO_ADDR
// if tmp2 then
30369: LD_VAR 0 3
30373: IFFALSE 30391
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30375: LD_VAR 0 3
30379: PUSH
30380: LD_INT 1
30382: ARRAY
30383: PPUSH
30384: LD_STRING D19-Sol1-1
30386: PPUSH
30387: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30391: LD_EXP 39
30395: PPUSH
30396: LD_STRING D19-JMM-2
30398: PPUSH
30399: CALL_OW 88
// DialogueOff ;
30403: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30407: LD_VAR 0 2
30411: PUSH
30412: LD_INT 1
30414: ARRAY
30415: PPUSH
30416: LD_VAR 0 2
30420: PUSH
30421: LD_INT 2
30423: ARRAY
30424: PPUSH
30425: LD_INT 1
30427: PPUSH
30428: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30432: LD_STRING M5
30434: PPUSH
30435: CALL_OW 337
// omarOnMotherLode := false ;
30439: LD_ADDR_VAR 0 4
30443: PUSH
30444: LD_INT 0
30446: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30447: LD_INT 35
30449: PPUSH
30450: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30454: LD_EXP 92
30458: PPUSH
30459: LD_INT 215
30461: PPUSH
30462: LD_INT 100
30464: PPUSH
30465: CALL_OW 297
30469: PUSH
30470: LD_INT 10
30472: LESS
30473: PUSH
30474: LD_VAR 0 4
30478: NOT
30479: AND
30480: IFFALSE 30514
// begin omarOnMotherLode := true ;
30482: LD_ADDR_VAR 0 4
30486: PUSH
30487: LD_INT 1
30489: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30490: LD_EXP 39
30494: PPUSH
30495: LD_STRING D19b-JMM-1
30497: PPUSH
30498: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30502: LD_EXP 92
30506: PPUSH
30507: LD_STRING DOmarContam-Omar-1
30509: PPUSH
30510: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30514: LD_EXP 92
30518: PPUSH
30519: CALL_OW 301
30523: IFFALSE 30447
// Say ( JMM , D19a-JMM-1 ) ;
30525: LD_EXP 39
30529: PPUSH
30530: LD_STRING D19a-JMM-1
30532: PPUSH
30533: CALL_OW 88
// if Heike then
30537: LD_EXP 93
30541: IFFALSE 30555
// Say ( Heike , D19a-Hke-1 ) ;
30543: LD_EXP 93
30547: PPUSH
30548: LD_STRING D19a-Hke-1
30550: PPUSH
30551: CALL_OW 88
// end ;
30555: PPOPN 4
30557: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30558: LD_INT 22
30560: PUSH
30561: LD_INT 3
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: PUSH
30568: LD_INT 21
30570: PUSH
30571: LD_INT 1
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PPUSH
30582: CALL_OW 69
30586: PUSH
30587: LD_EXP 21
30591: AND
30592: IFFALSE 30660
30594: GO 30596
30596: DISABLE
30597: LD_INT 0
30599: PPUSH
30600: PPUSH
// begin enable ;
30601: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30602: LD_ADDR_VAR 0 2
30606: PUSH
30607: LD_INT 25
30609: PPUSH
30610: LD_INT 22
30612: PUSH
30613: LD_INT 3
30615: PUSH
30616: EMPTY
30617: LIST
30618: LIST
30619: PPUSH
30620: CALL_OW 70
30624: ST_TO_ADDR
// if not tmp then
30625: LD_VAR 0 2
30629: NOT
30630: IFFALSE 30634
// exit ;
30632: GO 30660
// for i in tmp do
30634: LD_ADDR_VAR 0 1
30638: PUSH
30639: LD_VAR 0 2
30643: PUSH
30644: FOR_IN
30645: IFFALSE 30658
// RemoveUnit ( i ) ;
30647: LD_VAR 0 1
30651: PPUSH
30652: CALL_OW 64
30656: GO 30644
30658: POP
30659: POP
// end ;
30660: PPOPN 2
30662: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30663: LD_INT 22
30665: PUSH
30666: LD_INT 7
30668: PUSH
30669: EMPTY
30670: LIST
30671: LIST
30672: PUSH
30673: LD_INT 21
30675: PUSH
30676: LD_INT 1
30678: PUSH
30679: EMPTY
30680: LIST
30681: LIST
30682: PUSH
30683: EMPTY
30684: LIST
30685: LIST
30686: PPUSH
30687: CALL_OW 69
30691: PUSH
30692: LD_INT 6
30694: LESS
30695: IFFALSE 31163
30697: GO 30699
30699: DISABLE
30700: LD_INT 0
30702: PPUSH
30703: PPUSH
// begin MC_Kill ( 1 ) ;
30704: LD_INT 1
30706: PPUSH
30707: CALL 35385 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30711: LD_INT 7
30713: PPUSH
30714: LD_INT 1
30716: PPUSH
30717: LD_INT 1
30719: PPUSH
30720: LD_INT 1
30722: PPUSH
30723: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30727: LD_ADDR_VAR 0 1
30731: PUSH
30732: LD_INT 22
30734: PUSH
30735: LD_INT 7
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: PUSH
30742: LD_INT 26
30744: PUSH
30745: LD_INT 1
30747: PUSH
30748: EMPTY
30749: LIST
30750: LIST
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: PPUSH
30756: CALL_OW 69
30760: PUSH
30761: LD_EXP 74
30765: DIFF
30766: ST_TO_ADDR
// if tmp then
30767: LD_VAR 0 1
30771: IFFALSE 30789
// tmp := tmp [ 1 ] else
30773: LD_ADDR_VAR 0 1
30777: PUSH
30778: LD_VAR 0 1
30782: PUSH
30783: LD_INT 1
30785: ARRAY
30786: ST_TO_ADDR
30787: GO 30825
// begin uc_side := 7 ;
30789: LD_ADDR_OWVAR 20
30793: PUSH
30794: LD_INT 7
30796: ST_TO_ADDR
// uc_nation := 1 ;
30797: LD_ADDR_OWVAR 21
30801: PUSH
30802: LD_INT 1
30804: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30805: LD_INT 1
30807: PPUSH
30808: LD_INT 8
30810: PPUSH
30811: CALL_OW 384
// tmp := CreateHuman ;
30815: LD_ADDR_VAR 0 1
30819: PUSH
30820: CALL_OW 44
30824: ST_TO_ADDR
// end ; DialogueOn ;
30825: CALL_OW 6
// if IsOK ( Roth ) then
30829: LD_EXP 74
30833: PPUSH
30834: CALL_OW 302
30838: IFFALSE 30852
// Say ( JMM , DAb-JMM-1 ) ;
30840: LD_EXP 39
30844: PPUSH
30845: LD_STRING DAb-JMM-1
30847: PPUSH
30848: CALL_OW 88
// if IsOK ( Roth ) then
30852: LD_EXP 74
30856: PPUSH
30857: CALL_OW 302
30861: IFFALSE 30885
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30863: LD_EXP 74
30867: PPUSH
30868: LD_STRING DSurrenderAlliance-Roth-1
30870: PPUSH
30871: CALL_OW 88
// RothCaptured := true ;
30875: LD_ADDR_EXP 33
30879: PUSH
30880: LD_INT 1
30882: ST_TO_ADDR
// end else
30883: GO 30897
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30885: LD_VAR 0 1
30889: PPUSH
30890: LD_STRING DSurrenderAlliance-Sci1-1
30892: PPUSH
30893: CALL_OW 88
// DialogueOff ;
30897: CALL_OW 7
// allianceDestroyed := true ;
30901: LD_ADDR_EXP 23
30905: PUSH
30906: LD_INT 1
30908: ST_TO_ADDR
// if capturedUnit = 0 then
30909: LD_EXP 34
30913: PUSH
30914: LD_INT 0
30916: EQUAL
30917: IFFALSE 30926
// SetAchievement ( ACH_ALLIANCE ) ;
30919: LD_STRING ACH_ALLIANCE
30921: PPUSH
30922: CALL_OW 543
// if trueAmericans then
30926: LD_EXP 35
30930: IFFALSE 31006
// begin if trueAmericans = 1 then
30932: LD_EXP 35
30936: PUSH
30937: LD_INT 1
30939: EQUAL
30940: IFFALSE 30956
// Say ( JMM , DAb-JMM-1a ) else
30942: LD_EXP 39
30946: PPUSH
30947: LD_STRING DAb-JMM-1a
30949: PPUSH
30950: CALL_OW 88
30954: GO 30968
// Say ( JMM , DAb-JMM-1b ) ;
30956: LD_EXP 39
30960: PPUSH
30961: LD_STRING DAb-JMM-1b
30963: PPUSH
30964: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30968: LD_EXP 35
30972: PPUSH
30973: CALL_OW 87
// for i in trueAmericans do
30977: LD_ADDR_VAR 0 2
30981: PUSH
30982: LD_EXP 35
30986: PUSH
30987: FOR_IN
30988: IFFALSE 31004
// SetSide ( i , 1 ) ;
30990: LD_VAR 0 2
30994: PPUSH
30995: LD_INT 1
30997: PPUSH
30998: CALL_OW 235
31002: GO 30987
31004: POP
31005: POP
// end ; repeat wait ( 0 0$1 ) ;
31006: LD_INT 35
31008: PPUSH
31009: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
31013: LD_ADDR_VAR 0 2
31017: PUSH
31018: LD_INT 22
31020: PUSH
31021: LD_INT 7
31023: PUSH
31024: EMPTY
31025: LIST
31026: LIST
31027: PUSH
31028: LD_INT 21
31030: PUSH
31031: LD_INT 1
31033: PUSH
31034: EMPTY
31035: LIST
31036: LIST
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PPUSH
31042: CALL_OW 69
31046: PUSH
31047: FOR_IN
31048: IFFALSE 31130
// begin if IsInUnit ( i ) then
31050: LD_VAR 0 2
31054: PPUSH
31055: CALL_OW 310
31059: IFFALSE 31070
// ComExitBuilding ( i ) ;
31061: LD_VAR 0 2
31065: PPUSH
31066: CALL_OW 122
// if IsDriver ( i ) then
31070: LD_VAR 0 2
31074: PPUSH
31075: CALL 99965 0 1
31079: IFFALSE 31090
// ComExitVehicle ( i ) ;
31081: LD_VAR 0 2
31085: PPUSH
31086: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
31090: LD_VAR 0 2
31094: PPUSH
31095: LD_INT 26
31097: PPUSH
31098: CALL_OW 308
31102: NOT
31103: IFFALSE 31119
// AddComMoveToArea ( i , allianceEscapeArea ) else
31105: LD_VAR 0 2
31109: PPUSH
31110: LD_INT 26
31112: PPUSH
31113: CALL_OW 173
31117: GO 31128
// RemoveUnit ( i ) ;
31119: LD_VAR 0 2
31123: PPUSH
31124: CALL_OW 64
// end ;
31128: GO 31047
31130: POP
31131: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
31132: LD_INT 22
31134: PUSH
31135: LD_INT 7
31137: PUSH
31138: EMPTY
31139: LIST
31140: LIST
31141: PUSH
31142: LD_INT 21
31144: PUSH
31145: LD_INT 1
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: PUSH
31152: EMPTY
31153: LIST
31154: LIST
31155: PPUSH
31156: CALL_OW 69
31160: NOT
31161: IFFALSE 31006
// end ;
31163: PPOPN 2
31165: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31166: LD_INT 0
31168: PPUSH
31169: PPUSH
// if not unit then
31170: LD_VAR 0 1
31174: NOT
31175: IFFALSE 31179
// exit ;
31177: GO 32677
// DoNotAttack ( 7 , unit ) ;
31179: LD_INT 7
31181: PPUSH
31182: LD_VAR 0 1
31186: PPUSH
31187: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31191: LD_VAR 0 1
31195: PPUSH
31196: LD_INT 260
31198: PPUSH
31199: LD_INT 235
31201: PPUSH
31202: LD_INT 3
31204: PPUSH
31205: LD_INT 1
31207: PPUSH
31208: CALL_OW 483
// SetSide ( unit , 4 ) ;
31212: LD_VAR 0 1
31216: PPUSH
31217: LD_INT 4
31219: PPUSH
31220: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31224: LD_ADDR_EXP 34
31228: PUSH
31229: LD_EXP 34
31233: PUSH
31234: LD_INT 1
31236: PLUS
31237: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31238: LD_INT 70
31240: PPUSH
31241: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31245: LD_INT 260
31247: PPUSH
31248: LD_INT 235
31250: PPUSH
31251: LD_INT 1
31253: PPUSH
31254: LD_INT 8
31256: NEG
31257: PPUSH
31258: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31262: LD_VAR 0 1
31266: PPUSH
31267: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31271: LD_VAR 0 1
31275: PPUSH
31276: LD_EXP 74
31280: PPUSH
31281: CALL_OW 119
// DialogueOn ;
31285: CALL_OW 6
// case unit of JMM :
31289: LD_VAR 0 1
31293: PUSH
31294: LD_EXP 39
31298: DOUBLE
31299: EQUAL
31300: IFTRUE 31304
31302: GO 31319
31304: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31305: LD_EXP 39
31309: PPUSH
31310: LD_STRING DA1-JMM-1
31312: PPUSH
31313: CALL_OW 91
31317: GO 31761
31319: LD_EXP 40
31323: DOUBLE
31324: EQUAL
31325: IFTRUE 31329
31327: GO 31344
31329: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31330: LD_EXP 40
31334: PPUSH
31335: LD_STRING DA1-Joan-1
31337: PPUSH
31338: CALL_OW 91
31342: GO 31761
31344: LD_EXP 42
31348: DOUBLE
31349: EQUAL
31350: IFTRUE 31354
31352: GO 31369
31354: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31355: LD_EXP 42
31359: PPUSH
31360: LD_STRING DA1-Lisa-1
31362: PPUSH
31363: CALL_OW 91
31367: GO 31761
31369: LD_EXP 43
31373: DOUBLE
31374: EQUAL
31375: IFTRUE 31379
31377: GO 31394
31379: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31380: LD_EXP 43
31384: PPUSH
31385: LD_STRING DA1-Don-1
31387: PPUSH
31388: CALL_OW 91
31392: GO 31761
31394: LD_EXP 50
31398: DOUBLE
31399: EQUAL
31400: IFTRUE 31404
31402: GO 31419
31404: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31405: LD_EXP 50
31409: PPUSH
31410: LD_STRING DA1-Corn-1
31412: PPUSH
31413: CALL_OW 91
31417: GO 31761
31419: LD_EXP 46
31423: DOUBLE
31424: EQUAL
31425: IFTRUE 31429
31427: GO 31444
31429: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31430: LD_EXP 46
31434: PPUSH
31435: LD_STRING DA1-Den-1
31437: PPUSH
31438: CALL_OW 91
31442: GO 31761
31444: LD_EXP 44
31448: DOUBLE
31449: EQUAL
31450: IFTRUE 31454
31452: GO 31469
31454: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31455: LD_EXP 44
31459: PPUSH
31460: LD_STRING DA1-Bobby-1
31462: PPUSH
31463: CALL_OW 91
31467: GO 31761
31469: LD_EXP 48
31473: DOUBLE
31474: EQUAL
31475: IFTRUE 31479
31477: GO 31494
31479: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31480: LD_EXP 48
31484: PPUSH
31485: LD_STRING DA1-Glad-1
31487: PPUSH
31488: CALL_OW 91
31492: GO 31761
31494: LD_EXP 45
31498: DOUBLE
31499: EQUAL
31500: IFTRUE 31504
31502: GO 31519
31504: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31505: LD_EXP 45
31509: PPUSH
31510: LD_STRING DA1-Cyrus-1
31512: PPUSH
31513: CALL_OW 91
31517: GO 31761
31519: LD_EXP 41
31523: DOUBLE
31524: EQUAL
31525: IFTRUE 31529
31527: GO 31544
31529: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31530: LD_EXP 41
31534: PPUSH
31535: LD_STRING DA1-Huck-1
31537: PPUSH
31538: CALL_OW 91
31542: GO 31761
31544: LD_EXP 55
31548: DOUBLE
31549: EQUAL
31550: IFTRUE 31554
31552: GO 31569
31554: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31555: LD_EXP 55
31559: PPUSH
31560: LD_STRING DA1-Huck-1
31562: PPUSH
31563: CALL_OW 91
31567: GO 31761
31569: LD_EXP 47
31573: DOUBLE
31574: EQUAL
31575: IFTRUE 31579
31577: GO 31594
31579: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31580: LD_EXP 47
31584: PPUSH
31585: LD_STRING DA1-Brown-1
31587: PPUSH
31588: CALL_OW 91
31592: GO 31761
31594: LD_EXP 51
31598: DOUBLE
31599: EQUAL
31600: IFTRUE 31604
31602: GO 31619
31604: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31605: LD_EXP 51
31609: PPUSH
31610: LD_STRING DA1-Gary-1
31612: PPUSH
31613: CALL_OW 91
31617: GO 31761
31619: LD_EXP 54
31623: DOUBLE
31624: EQUAL
31625: IFTRUE 31629
31627: GO 31644
31629: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31630: LD_EXP 54
31634: PPUSH
31635: LD_STRING DA1-Con-1
31637: PPUSH
31638: CALL_OW 91
31642: GO 31761
31644: LD_EXP 60
31648: DOUBLE
31649: EQUAL
31650: IFTRUE 31654
31652: GO 31669
31654: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31655: LD_EXP 60
31659: PPUSH
31660: LD_STRING DA1-Kurt-1
31662: PPUSH
31663: CALL_OW 91
31667: GO 31761
31669: LD_EXP 53
31673: DOUBLE
31674: EQUAL
31675: IFTRUE 31679
31677: GO 31694
31679: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31680: LD_EXP 53
31684: PPUSH
31685: LD_STRING DA1-Yam-1
31687: PPUSH
31688: CALL_OW 91
31692: GO 31761
31694: LD_EXP 52
31698: DOUBLE
31699: EQUAL
31700: IFTRUE 31704
31702: GO 31719
31704: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31705: LD_EXP 52
31709: PPUSH
31710: LD_STRING DA1-Frank-1
31712: PPUSH
31713: CALL_OW 91
31717: GO 31761
31719: POP
// begin if GetSex ( unit ) = sex_male then
31720: LD_VAR 0 1
31724: PPUSH
31725: CALL_OW 258
31729: PUSH
31730: LD_INT 1
31732: EQUAL
31733: IFFALSE 31749
// ForceSay ( unit , DA1-Sol1-1 ) else
31735: LD_VAR 0 1
31739: PPUSH
31740: LD_STRING DA1-Sol1-1
31742: PPUSH
31743: CALL_OW 91
31747: GO 31761
// ForceSay ( unit , DA1-FSol1-1 ) ;
31749: LD_VAR 0 1
31753: PPUSH
31754: LD_STRING DA1-FSol1-1
31756: PPUSH
31757: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31761: LD_EXP 74
31765: PPUSH
31766: LD_STRING DA-Roth-1
31768: PPUSH
31769: CALL_OW 88
// if capturedUnit = 1 then
31773: LD_EXP 34
31777: PUSH
31778: LD_INT 1
31780: EQUAL
31781: IFFALSE 31809
// begin Say ( Simms , DA-Sim-1 ) ;
31783: LD_EXP 75
31787: PPUSH
31788: LD_STRING DA-Sim-1
31790: PPUSH
31791: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31795: LD_EXP 74
31799: PPUSH
31800: LD_STRING DA-Roth-2
31802: PPUSH
31803: CALL_OW 88
// end else
31807: GO 31821
// Say ( Simms , DA-Sim-2 ) ;
31809: LD_EXP 75
31813: PPUSH
31814: LD_STRING DA-Sim-2
31816: PPUSH
31817: CALL_OW 88
// case unit of JMM :
31821: LD_VAR 0 1
31825: PUSH
31826: LD_EXP 39
31830: DOUBLE
31831: EQUAL
31832: IFTRUE 31836
31834: GO 31851
31836: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31837: LD_EXP 39
31841: PPUSH
31842: LD_STRING DA1-JMM-1a
31844: PPUSH
31845: CALL_OW 91
31849: GO 32358
31851: LD_EXP 40
31855: DOUBLE
31856: EQUAL
31857: IFTRUE 31861
31859: GO 31876
31861: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31862: LD_EXP 40
31866: PPUSH
31867: LD_STRING DA1-Joan-1a
31869: PPUSH
31870: CALL_OW 91
31874: GO 32358
31876: LD_EXP 42
31880: DOUBLE
31881: EQUAL
31882: IFTRUE 31886
31884: GO 31901
31886: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31887: LD_EXP 42
31891: PPUSH
31892: LD_STRING DA1-Lisa-1a
31894: PPUSH
31895: CALL_OW 91
31899: GO 32358
31901: LD_EXP 43
31905: DOUBLE
31906: EQUAL
31907: IFTRUE 31911
31909: GO 31926
31911: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31912: LD_EXP 43
31916: PPUSH
31917: LD_STRING DA1-Don-1a
31919: PPUSH
31920: CALL_OW 91
31924: GO 32358
31926: LD_EXP 50
31930: DOUBLE
31931: EQUAL
31932: IFTRUE 31936
31934: GO 31951
31936: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31937: LD_EXP 50
31941: PPUSH
31942: LD_STRING DA1-Corn-1a
31944: PPUSH
31945: CALL_OW 91
31949: GO 32358
31951: LD_EXP 46
31955: DOUBLE
31956: EQUAL
31957: IFTRUE 31961
31959: GO 31976
31961: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31962: LD_EXP 46
31966: PPUSH
31967: LD_STRING DA1-Den-1a
31969: PPUSH
31970: CALL_OW 91
31974: GO 32358
31976: LD_EXP 44
31980: DOUBLE
31981: EQUAL
31982: IFTRUE 31986
31984: GO 32001
31986: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31987: LD_EXP 44
31991: PPUSH
31992: LD_STRING DA1-Bobby-1a
31994: PPUSH
31995: CALL_OW 91
31999: GO 32358
32001: LD_EXP 48
32005: DOUBLE
32006: EQUAL
32007: IFTRUE 32011
32009: GO 32026
32011: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
32012: LD_EXP 48
32016: PPUSH
32017: LD_STRING DA1-Glad-1a
32019: PPUSH
32020: CALL_OW 91
32024: GO 32358
32026: LD_EXP 45
32030: DOUBLE
32031: EQUAL
32032: IFTRUE 32036
32034: GO 32051
32036: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
32037: LD_EXP 45
32041: PPUSH
32042: LD_STRING DA1-Cyrus-1a
32044: PPUSH
32045: CALL_OW 91
32049: GO 32358
32051: LD_EXP 41
32055: DOUBLE
32056: EQUAL
32057: IFTRUE 32061
32059: GO 32076
32061: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
32062: LD_EXP 41
32066: PPUSH
32067: LD_STRING DA1-Huck-1a
32069: PPUSH
32070: CALL_OW 91
32074: GO 32358
32076: LD_EXP 55
32080: DOUBLE
32081: EQUAL
32082: IFTRUE 32086
32084: GO 32101
32086: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
32087: LD_EXP 55
32091: PPUSH
32092: LD_STRING DA1-Huck-1a
32094: PPUSH
32095: CALL_OW 91
32099: GO 32358
32101: LD_EXP 47
32105: DOUBLE
32106: EQUAL
32107: IFTRUE 32111
32109: GO 32126
32111: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
32112: LD_EXP 47
32116: PPUSH
32117: LD_STRING DA1-Brown-1a
32119: PPUSH
32120: CALL_OW 91
32124: GO 32358
32126: LD_EXP 51
32130: DOUBLE
32131: EQUAL
32132: IFTRUE 32136
32134: GO 32151
32136: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
32137: LD_EXP 51
32141: PPUSH
32142: LD_STRING DA1-Gary-1a
32144: PPUSH
32145: CALL_OW 91
32149: GO 32358
32151: LD_EXP 54
32155: DOUBLE
32156: EQUAL
32157: IFTRUE 32161
32159: GO 32176
32161: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
32162: LD_EXP 54
32166: PPUSH
32167: LD_STRING DA1-Con-1a
32169: PPUSH
32170: CALL_OW 91
32174: GO 32358
32176: LD_EXP 60
32180: DOUBLE
32181: EQUAL
32182: IFTRUE 32186
32184: GO 32201
32186: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32187: LD_EXP 60
32191: PPUSH
32192: LD_STRING DA1-Kurt-1a
32194: PPUSH
32195: CALL_OW 91
32199: GO 32358
32201: LD_EXP 53
32205: DOUBLE
32206: EQUAL
32207: IFTRUE 32211
32209: GO 32226
32211: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32212: LD_EXP 53
32216: PPUSH
32217: LD_STRING DA1-Yam-1a
32219: PPUSH
32220: CALL_OW 91
32224: GO 32358
32226: LD_EXP 52
32230: DOUBLE
32231: EQUAL
32232: IFTRUE 32236
32234: GO 32251
32236: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32237: LD_EXP 52
32241: PPUSH
32242: LD_STRING DA1-Frank-1a
32244: PPUSH
32245: CALL_OW 91
32249: GO 32358
32251: POP
// begin join := rand ( 0 , 1 ) ;
32252: LD_ADDR_VAR 0 3
32256: PUSH
32257: LD_INT 0
32259: PPUSH
32260: LD_INT 1
32262: PPUSH
32263: CALL_OW 12
32267: ST_TO_ADDR
// if join then
32268: LD_VAR 0 3
32272: IFFALSE 32317
// begin if GetSex ( unit ) = sex_male then
32274: LD_VAR 0 1
32278: PPUSH
32279: CALL_OW 258
32283: PUSH
32284: LD_INT 1
32286: EQUAL
32287: IFFALSE 32303
// ForceSay ( unit , DA1-Sol1-1b ) else
32289: LD_VAR 0 1
32293: PPUSH
32294: LD_STRING DA1-Sol1-1b
32296: PPUSH
32297: CALL_OW 91
32301: GO 32315
// ForceSay ( unit , DA1-FSol1-1b ) ;
32303: LD_VAR 0 1
32307: PPUSH
32308: LD_STRING DA1-FSol1-1b
32310: PPUSH
32311: CALL_OW 91
// end else
32315: GO 32358
// begin if GetSex ( unit ) = sex_male then
32317: LD_VAR 0 1
32321: PPUSH
32322: CALL_OW 258
32326: PUSH
32327: LD_INT 1
32329: EQUAL
32330: IFFALSE 32346
// ForceSay ( unit , DA1-Sol1-1a ) else
32332: LD_VAR 0 1
32336: PPUSH
32337: LD_STRING DA1-Sol1-1a
32339: PPUSH
32340: CALL_OW 91
32344: GO 32358
// ForceSay ( unit , DA1-FSol1-1a ) ;
32346: LD_VAR 0 1
32350: PPUSH
32351: LD_STRING DA1-FSol1-1a
32353: PPUSH
32354: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32358: LD_VAR 0 1
32362: PUSH
32363: LD_EXP 39
32367: EQUAL
32368: IFFALSE 32379
// begin YouLost ( JMMCaptured ) ;
32370: LD_STRING JMMCaptured
32372: PPUSH
32373: CALL_OW 104
// exit ;
32377: GO 32677
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32379: LD_VAR 0 1
32383: PUSH
32384: LD_EXP 43
32388: PUSH
32389: LD_EXP 46
32393: PUSH
32394: LD_EXP 44
32398: PUSH
32399: LD_EXP 41
32403: PUSH
32404: LD_EXP 55
32408: PUSH
32409: LD_EXP 47
32413: PUSH
32414: LD_EXP 53
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: LIST
32423: LIST
32424: LIST
32425: LIST
32426: LIST
32427: IN
32428: PUSH
32429: LD_VAR 0 3
32433: OR
32434: IFFALSE 32533
// begin Say ( Roth , DA-Roth-3 ) ;
32436: LD_EXP 74
32440: PPUSH
32441: LD_STRING DA-Roth-3
32443: PPUSH
32444: CALL_OW 88
// SetSide ( unit , 7 ) ;
32448: LD_VAR 0 1
32452: PPUSH
32453: LD_INT 7
32455: PPUSH
32456: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32460: LD_ADDR_EXP 116
32464: PUSH
32465: LD_EXP 116
32469: PPUSH
32470: LD_INT 1
32472: PPUSH
32473: LD_EXP 116
32477: PUSH
32478: LD_INT 1
32480: ARRAY
32481: PUSH
32482: LD_VAR 0 1
32486: ADD
32487: PPUSH
32488: CALL_OW 1
32492: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32493: LD_INT 260
32495: PPUSH
32496: LD_INT 235
32498: PPUSH
32499: LD_INT 1
32501: PPUSH
32502: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32506: LD_VAR 0 1
32510: PPUSH
32511: LD_INT 1000
32513: PPUSH
32514: CALL_OW 234
// DialogueOff ;
32518: CALL_OW 7
// ComFree ( unit ) ;
32522: LD_VAR 0 1
32526: PPUSH
32527: CALL_OW 139
// end else
32531: GO 32614
// begin Say ( Roth , DA-Roth-3a ) ;
32533: LD_EXP 74
32537: PPUSH
32538: LD_STRING DA-Roth-3a
32540: PPUSH
32541: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32545: LD_ADDR_EXP 35
32549: PUSH
32550: LD_EXP 35
32554: PUSH
32555: LD_VAR 0 1
32559: ADD
32560: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32561: LD_INT 260
32563: PPUSH
32564: LD_INT 235
32566: PPUSH
32567: LD_INT 1
32569: PPUSH
32570: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32574: LD_VAR 0 1
32578: PPUSH
32579: LD_INT 1000
32581: PPUSH
32582: CALL_OW 234
// DialogueOff ;
32586: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32590: LD_VAR 0 1
32594: PPUSH
32595: LD_INT 272
32597: PPUSH
32598: LD_INT 254
32600: PPUSH
32601: CALL_OW 111
// AddComHold ( unit ) ;
32605: LD_VAR 0 1
32609: PPUSH
32610: CALL_OW 200
// end ; if capturedUnit = 1 then
32614: LD_EXP 34
32618: PUSH
32619: LD_INT 1
32621: EQUAL
32622: IFFALSE 32677
// begin DialogueOn ;
32624: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32628: LD_EXP 39
32632: PPUSH
32633: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32637: LD_EXP 39
32641: PPUSH
32642: LD_STRING DAa-JMM-1
32644: PPUSH
32645: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32649: LD_EXP 39
32653: PPUSH
32654: LD_STRING DAa-JMM-1a
32656: PPUSH
32657: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32661: LD_EXP 39
32665: PPUSH
32666: LD_STRING DAa-JMM-1b
32668: PPUSH
32669: CALL_OW 88
// DialogueOff ;
32673: CALL_OW 7
// end ; end ;
32677: LD_VAR 0 2
32681: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32682: LD_EXP 15
32686: PUSH
32687: LD_INT 13
32689: GREATEREQUAL
32690: PUSH
32691: LD_INT 22
32693: PUSH
32694: LD_INT 2
32696: PUSH
32697: EMPTY
32698: LIST
32699: LIST
32700: PUSH
32701: LD_INT 21
32703: PUSH
32704: LD_INT 1
32706: PUSH
32707: EMPTY
32708: LIST
32709: LIST
32710: PUSH
32711: EMPTY
32712: LIST
32713: LIST
32714: PPUSH
32715: CALL_OW 69
32719: PUSH
32720: LD_INT 0
32722: EQUAL
32723: AND
32724: PUSH
32725: LD_INT 22
32727: PUSH
32728: LD_INT 2
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 33
32737: PUSH
32738: LD_INT 5
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: PUSH
32745: LD_INT 21
32747: PUSH
32748: LD_INT 2
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 50
32757: PUSH
32758: EMPTY
32759: LIST
32760: PUSH
32761: EMPTY
32762: LIST
32763: LIST
32764: LIST
32765: LIST
32766: PPUSH
32767: CALL_OW 69
32771: PUSH
32772: LD_INT 0
32774: EQUAL
32775: AND
32776: PUSH
32777: LD_EXP 21
32781: AND
32782: PUSH
32783: LD_EXP 22
32787: AND
32788: PUSH
32789: LD_EXP 23
32793: AND
32794: IFFALSE 33443
32796: GO 32798
32798: DISABLE
32799: LD_INT 0
32801: PPUSH
32802: PPUSH
32803: PPUSH
// begin m1 := false ;
32804: LD_ADDR_VAR 0 1
32808: PUSH
32809: LD_INT 0
32811: ST_TO_ADDR
// m2 := false ;
32812: LD_ADDR_VAR 0 2
32816: PUSH
32817: LD_INT 0
32819: ST_TO_ADDR
// m3 := false ;
32820: LD_ADDR_VAR 0 3
32824: PUSH
32825: LD_INT 0
32827: ST_TO_ADDR
// if not bombExploded then
32828: LD_EXP 37
32832: NOT
32833: IFFALSE 32842
// SetAchievement ( ACH_SIBROCKET ) ;
32835: LD_STRING ACH_SIBROCKET
32837: PPUSH
32838: CALL_OW 543
// if tick <= 120 120$00 then
32842: LD_OWVAR 1
32846: PUSH
32847: LD_INT 252000
32849: LESSEQUAL
32850: IFFALSE 32866
// begin wait ( 3 ) ;
32852: LD_INT 3
32854: PPUSH
32855: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32859: LD_STRING ACH_ASPEED_15
32861: PPUSH
32862: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32866: LD_EXP 39
32870: PPUSH
32871: CALL_OW 87
// music_class := 5 ;
32875: LD_ADDR_OWVAR 72
32879: PUSH
32880: LD_INT 5
32882: ST_TO_ADDR
// music_nat := 5 ;
32883: LD_ADDR_OWVAR 71
32887: PUSH
32888: LD_INT 5
32890: ST_TO_ADDR
// DialogueOn ;
32891: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32895: LD_EXP 39
32899: PPUSH
32900: LD_STRING D20-JMM-1
32902: PPUSH
32903: CALL_OW 88
// if IsOK ( Joan ) then
32907: LD_EXP 40
32911: PPUSH
32912: CALL_OW 302
32916: IFFALSE 32930
// Say ( Joan , D20-Joan-1 ) ;
32918: LD_EXP 40
32922: PPUSH
32923: LD_STRING D20-Joan-1
32925: PPUSH
32926: CALL_OW 88
// if IsOk ( Lisa ) then
32930: LD_EXP 42
32934: PPUSH
32935: CALL_OW 302
32939: IFFALSE 32953
// Say ( Lisa , D20-Lisa-1 ) ;
32941: LD_EXP 42
32945: PPUSH
32946: LD_STRING D20-Lisa-1
32948: PPUSH
32949: CALL_OW 88
// if IsOk ( Donaldson ) then
32953: LD_EXP 43
32957: PPUSH
32958: CALL_OW 302
32962: IFFALSE 32976
// Say ( Donaldson , D20-Don-1 ) ;
32964: LD_EXP 43
32968: PPUSH
32969: LD_STRING D20-Don-1
32971: PPUSH
32972: CALL_OW 88
// if IsOK ( Cornel ) then
32976: LD_EXP 50
32980: PPUSH
32981: CALL_OW 302
32985: IFFALSE 32999
// Say ( Cornel , D20-Corn-1 ) ;
32987: LD_EXP 50
32991: PPUSH
32992: LD_STRING D20-Corn-1
32994: PPUSH
32995: CALL_OW 88
// if IsOk ( Denis ) then
32999: LD_EXP 46
33003: PPUSH
33004: CALL_OW 302
33008: IFFALSE 33022
// Say ( Denis , D20-Den-1 ) ;
33010: LD_EXP 46
33014: PPUSH
33015: LD_STRING D20-Den-1
33017: PPUSH
33018: CALL_OW 88
// if IsOk ( Bobby ) then
33022: LD_EXP 44
33026: PPUSH
33027: CALL_OW 302
33031: IFFALSE 33045
// Say ( Bobby , D20-Bobby-1 ) ;
33033: LD_EXP 44
33037: PPUSH
33038: LD_STRING D20-Bobby-1
33040: PPUSH
33041: CALL_OW 88
// if IsOk ( Gladstone ) then
33045: LD_EXP 48
33049: PPUSH
33050: CALL_OW 302
33054: IFFALSE 33068
// Say ( Gladstone , D20-Glad-1 ) ;
33056: LD_EXP 48
33060: PPUSH
33061: LD_STRING D20-Glad-1
33063: PPUSH
33064: CALL_OW 88
// if IsOk ( Cyrus ) then
33068: LD_EXP 45
33072: PPUSH
33073: CALL_OW 302
33077: IFFALSE 33091
// Say ( Cyrus , D20-Cyrus-1 ) ;
33079: LD_EXP 45
33083: PPUSH
33084: LD_STRING D20-Cyrus-1
33086: PPUSH
33087: CALL_OW 88
// if IsOk ( Stevens ) then
33091: LD_EXP 41
33095: PPUSH
33096: CALL_OW 302
33100: IFFALSE 33114
// Say ( Stevens , D20-Huck-1 ) ;
33102: LD_EXP 41
33106: PPUSH
33107: LD_STRING D20-Huck-1
33109: PPUSH
33110: CALL_OW 88
// if IsOk ( Brown ) then
33114: LD_EXP 47
33118: PPUSH
33119: CALL_OW 302
33123: IFFALSE 33137
// Say ( Brown , D20-Brown-1 ) ;
33125: LD_EXP 47
33129: PPUSH
33130: LD_STRING D20-Brown-1
33132: PPUSH
33133: CALL_OW 88
// if IsOk ( Gary ) then
33137: LD_EXP 51
33141: PPUSH
33142: CALL_OW 302
33146: IFFALSE 33160
// Say ( Gary , D20-Gary-1 ) ;
33148: LD_EXP 51
33152: PPUSH
33153: LD_STRING D20-Gary-1
33155: PPUSH
33156: CALL_OW 88
// if IsOk ( Connie ) then
33160: LD_EXP 54
33164: PPUSH
33165: CALL_OW 302
33169: IFFALSE 33183
// Say ( Connie , D20-Con-1 ) ;
33171: LD_EXP 54
33175: PPUSH
33176: LD_STRING D20-Con-1
33178: PPUSH
33179: CALL_OW 88
// if IsOk ( Kurt ) then
33183: LD_EXP 60
33187: PPUSH
33188: CALL_OW 302
33192: IFFALSE 33206
// Say ( Kurt , D20-Kurt-1 ) ;
33194: LD_EXP 60
33198: PPUSH
33199: LD_STRING D20-Kurt-1
33201: PPUSH
33202: CALL_OW 88
// if IsOk ( Kikuchi ) then
33206: LD_EXP 53
33210: PPUSH
33211: CALL_OW 302
33215: IFFALSE 33229
// Say ( Kikuchi , D20-Yam-1 ) ;
33217: LD_EXP 53
33221: PPUSH
33222: LD_STRING D20-Yam-1
33224: PPUSH
33225: CALL_OW 88
// if IsOk ( Frank ) then
33229: LD_EXP 52
33233: PPUSH
33234: CALL_OW 302
33238: IFFALSE 33252
// Say ( Frank , D20-Frank-1 ) ;
33240: LD_EXP 52
33244: PPUSH
33245: LD_STRING D20-Frank-1
33247: PPUSH
33248: CALL_OW 88
// DialogueOff ;
33252: CALL_OW 7
// if RothCaptured then
33256: LD_EXP 33
33260: IFFALSE 33282
// begin m1 := true ;
33262: LD_ADDR_VAR 0 1
33266: PUSH
33267: LD_INT 1
33269: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33270: LD_STRING Roth
33272: PPUSH
33273: LD_INT 1
33275: PPUSH
33276: CALL_OW 101
// end else
33280: GO 33293
// AddMedal ( Roth , - 1 ) ;
33282: LD_STRING Roth
33284: PPUSH
33285: LD_INT 1
33287: NEG
33288: PPUSH
33289: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish then
33293: LD_EXP 25
33297: NOT
33298: PUSH
33299: LD_EXP 27
33303: OR
33304: IFFALSE 33326
// begin m2 := true ;
33306: LD_ADDR_VAR 0 2
33310: PUSH
33311: LD_INT 1
33313: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33314: LD_STRING Project
33316: PPUSH
33317: LD_INT 1
33319: PPUSH
33320: CALL_OW 101
// end else
33324: GO 33337
// AddMedal ( Project , - 1 ) ;
33326: LD_STRING Project
33328: PPUSH
33329: LD_INT 1
33331: NEG
33332: PPUSH
33333: CALL_OW 101
// if lostCounter = 0 then
33337: LD_EXP 32
33341: PUSH
33342: LD_INT 0
33344: EQUAL
33345: IFFALSE 33367
// begin m3 := true ;
33347: LD_ADDR_VAR 0 3
33351: PUSH
33352: LD_INT 1
33354: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33355: LD_STRING NoLosses
33357: PPUSH
33358: LD_INT 1
33360: PPUSH
33361: CALL_OW 101
// end else
33365: GO 33378
// AddMedal ( NoLosses , - 1 ) ;
33367: LD_STRING NoLosses
33369: PPUSH
33370: LD_INT 1
33372: NEG
33373: PPUSH
33374: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
33378: LD_VAR 0 1
33382: PUSH
33383: LD_VAR 0 2
33387: AND
33388: PUSH
33389: LD_VAR 0 3
33393: AND
33394: PUSH
33395: LD_OWVAR 67
33399: PUSH
33400: LD_INT 3
33402: EQUAL
33403: AND
33404: IFFALSE 33416
// SetAchievementEX ( ACH_AMER , 15 ) ;
33406: LD_STRING ACH_AMER
33408: PPUSH
33409: LD_INT 15
33411: PPUSH
33412: CALL_OW 564
// GiveMedals ( MAIN ) ;
33416: LD_STRING MAIN
33418: PPUSH
33419: CALL_OW 102
// music_class := 4 ;
33423: LD_ADDR_OWVAR 72
33427: PUSH
33428: LD_INT 4
33430: ST_TO_ADDR
// music_nat := 1 ;
33431: LD_ADDR_OWVAR 71
33435: PUSH
33436: LD_INT 1
33438: ST_TO_ADDR
// YouWin ;
33439: CALL_OW 103
// end ; end_of_file
33443: PPOPN 3
33445: END
// export function CustomEvent ( event ) ; begin
33446: LD_INT 0
33448: PPUSH
// end ;
33449: LD_VAR 0 2
33453: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33454: LD_VAR 0 1
33458: PUSH
33459: LD_INT 1
33461: EQUAL
33462: PUSH
33463: LD_VAR 0 2
33467: PUSH
33468: LD_INT 4
33470: EQUAL
33471: AND
33472: PUSH
33473: LD_EXP 58
33477: PPUSH
33478: CALL_OW 300
33482: AND
33483: IFFALSE 33499
// begin wait ( 0 0$2 ) ;
33485: LD_INT 70
33487: PPUSH
33488: CALL_OW 67
// YouLost ( Dismissed ) ;
33492: LD_STRING Dismissed
33494: PPUSH
33495: CALL_OW 104
// end ; end ;
33499: PPOPN 2
33501: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33502: LD_VAR 0 2
33506: PPUSH
33507: LD_VAR 0 3
33511: PPUSH
33512: LD_INT 18
33514: PPUSH
33515: CALL_OW 309
33519: IFFALSE 33528
// YouLost ( Motherlode3 ) ;
33521: LD_STRING Motherlode3
33523: PPUSH
33524: CALL_OW 104
// end ;
33528: PPOPN 3
33530: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33531: LD_EXP 27
33535: NOT
33536: IFFALSE 33546
// behemothDone := true ;
33538: LD_ADDR_EXP 28
33542: PUSH
33543: LD_INT 1
33545: ST_TO_ADDR
// end ;
33546: PPOPN 1
33548: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33549: LD_VAR 0 1
33553: PPUSH
33554: CALL_OW 255
33558: PUSH
33559: LD_INT 1
33561: EQUAL
33562: IFFALSE 33572
// bombExploded := true ;
33564: LD_ADDR_EXP 37
33568: PUSH
33569: LD_INT 1
33571: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33572: LD_VAR 0 1
33576: PPUSH
33577: CALL_OW 255
33581: PUSH
33582: LD_INT 1
33584: EQUAL
33585: PUSH
33586: LD_EXP 30
33590: AND
33591: PUSH
33592: LD_INT 22
33594: PUSH
33595: LD_INT 3
33597: PUSH
33598: EMPTY
33599: LIST
33600: LIST
33601: PUSH
33602: LD_INT 34
33604: PUSH
33605: LD_INT 48
33607: PUSH
33608: EMPTY
33609: LIST
33610: LIST
33611: PUSH
33612: EMPTY
33613: LIST
33614: LIST
33615: PPUSH
33616: CALL_OW 69
33620: AND
33621: PUSH
33622: LD_INT 22
33624: PUSH
33625: LD_INT 1
33627: PUSH
33628: EMPTY
33629: LIST
33630: LIST
33631: PUSH
33632: LD_INT 34
33634: PUSH
33635: LD_INT 8
33637: PUSH
33638: EMPTY
33639: LIST
33640: LIST
33641: PUSH
33642: EMPTY
33643: LIST
33644: LIST
33645: PPUSH
33646: CALL_OW 69
33650: NOT
33651: AND
33652: IFFALSE 33704
// begin wait ( 0 0$5 ) ;
33654: LD_INT 175
33656: PPUSH
33657: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33661: LD_INT 22
33663: PUSH
33664: LD_INT 3
33666: PUSH
33667: EMPTY
33668: LIST
33669: LIST
33670: PUSH
33671: LD_INT 34
33673: PUSH
33674: LD_INT 48
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: PUSH
33681: EMPTY
33682: LIST
33683: LIST
33684: PPUSH
33685: CALL_OW 69
33689: PUSH
33690: LD_INT 1
33692: ARRAY
33693: PPUSH
33694: LD_INT 60
33696: PPUSH
33697: LD_INT 95
33699: PPUSH
33700: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33704: LD_VAR 0 2
33708: PPUSH
33709: LD_VAR 0 3
33713: PPUSH
33714: LD_INT 18
33716: PPUSH
33717: CALL_OW 309
33721: IFFALSE 33768
// begin if GetSide ( unit ) = 1 then
33723: LD_VAR 0 1
33727: PPUSH
33728: CALL_OW 255
33732: PUSH
33733: LD_INT 1
33735: EQUAL
33736: IFFALSE 33754
// begin wait ( 0 0$6 ) ;
33738: LD_INT 210
33740: PPUSH
33741: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33745: LD_STRING Motherlode2
33747: PPUSH
33748: CALL_OW 104
// end else
33752: GO 33768
// begin wait ( 0 0$6 ) ;
33754: LD_INT 210
33756: PPUSH
33757: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33761: LD_STRING Motherlode1
33763: PPUSH
33764: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33768: LD_VAR 0 1
33772: PPUSH
33773: CALL_OW 255
33777: PUSH
33778: LD_INT 3
33780: EQUAL
33781: IFFALSE 33802
// begin wait ( 0 0$5 ) ;
33783: LD_INT 175
33785: PPUSH
33786: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33790: LD_EXP 64
33794: PPUSH
33795: LD_STRING D18-Pla-1
33797: PPUSH
33798: CALL_OW 94
// end ; end ;
33802: PPOPN 3
33804: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
33805: LD_VAR 0 1
33809: PUSH
33810: LD_INT 22
33812: PUSH
33813: LD_INT 1
33815: PUSH
33816: EMPTY
33817: LIST
33818: LIST
33819: PUSH
33820: LD_INT 21
33822: PUSH
33823: LD_INT 1
33825: PUSH
33826: EMPTY
33827: LIST
33828: LIST
33829: PUSH
33830: LD_INT 23
33832: PUSH
33833: LD_INT 1
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: EMPTY
33841: LIST
33842: LIST
33843: LIST
33844: PPUSH
33845: CALL_OW 69
33849: IN
33850: IFFALSE 33866
// lostCounter := lostCounter + 1 ;
33852: LD_ADDR_EXP 32
33856: PUSH
33857: LD_EXP 32
33861: PUSH
33862: LD_INT 1
33864: PLUS
33865: ST_TO_ADDR
// if un in behemothBuilders then
33866: LD_VAR 0 1
33870: PUSH
33871: LD_EXP 73
33875: IN
33876: IFFALSE 33896
// begin behemothBuilders := behemothBuilders diff un ;
33878: LD_ADDR_EXP 73
33882: PUSH
33883: LD_EXP 73
33887: PUSH
33888: LD_VAR 0 1
33892: DIFF
33893: ST_TO_ADDR
// exit ;
33894: GO 33926
// end ; if un = JMM then
33896: LD_VAR 0 1
33900: PUSH
33901: LD_EXP 39
33905: EQUAL
33906: IFFALSE 33917
// begin YouLost ( JMM ) ;
33908: LD_STRING JMM
33910: PPUSH
33911: CALL_OW 104
// exit ;
33915: GO 33926
// end ; MCE_UnitDestroyed ( un ) ;
33917: LD_VAR 0 1
33921: PPUSH
33922: CALL 62636 0 1
// end ;
33926: PPOPN 1
33928: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33929: LD_VAR 0 1
33933: PPUSH
33934: LD_VAR 0 2
33938: PPUSH
33939: CALL 64970 0 2
// end ;
33943: PPOPN 2
33945: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33946: LD_VAR 0 1
33950: PPUSH
33951: CALL 64038 0 1
// end ;
33955: PPOPN 1
33957: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33958: LD_VAR 0 1
33962: PUSH
33963: LD_INT 22
33965: PUSH
33966: LD_INT 8
33968: PUSH
33969: EMPTY
33970: LIST
33971: LIST
33972: PUSH
33973: LD_INT 30
33975: PUSH
33976: LD_INT 2
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: LD_INT 23
33985: PUSH
33986: LD_INT 3
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: EMPTY
33994: LIST
33995: LIST
33996: LIST
33997: PPUSH
33998: CALL_OW 69
34002: IN
34003: IFFALSE 34030
// begin ComUpgrade ( building ) ;
34005: LD_VAR 0 1
34009: PPUSH
34010: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
34014: LD_EXP 61
34018: PPUSH
34019: LD_VAR 0 1
34023: PPUSH
34024: CALL 73471 0 2
// exit ;
34028: GO 34039
// end ; MCE_BuildingComplete ( building ) ;
34030: LD_VAR 0 1
34034: PPUSH
34035: CALL 64279 0 1
// end ;
34039: PPOPN 1
34041: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
34042: LD_VAR 0 1
34046: PPUSH
34047: LD_VAR 0 2
34051: PPUSH
34052: CALL 62332 0 2
// end ;
34056: PPOPN 2
34058: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
34059: LD_VAR 0 1
34063: PPUSH
34064: LD_VAR 0 2
34068: PPUSH
34069: LD_VAR 0 3
34073: PPUSH
34074: LD_VAR 0 4
34078: PPUSH
34079: LD_VAR 0 5
34083: PPUSH
34084: CALL 61952 0 5
// end ;
34088: PPOPN 5
34090: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
34091: LD_VAR 0 1
34095: PPUSH
34096: LD_VAR 0 2
34100: PPUSH
34101: CALL 61533 0 2
// end ;
34105: PPOPN 2
34107: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
34108: LD_VAR 0 1
34112: PPUSH
34113: LD_VAR 0 2
34117: PPUSH
34118: LD_VAR 0 3
34122: PPUSH
34123: LD_VAR 0 4
34127: PPUSH
34128: CALL 61371 0 4
// end ;
34132: PPOPN 4
34134: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
34135: LD_VAR 0 1
34139: PPUSH
34140: LD_VAR 0 2
34144: PPUSH
34145: LD_VAR 0 3
34149: PPUSH
34150: CALL 61146 0 3
// end ;
34154: PPOPN 3
34156: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
34157: LD_VAR 0 1
34161: PPUSH
34162: LD_VAR 0 2
34166: PPUSH
34167: CALL 61031 0 2
// end ;
34171: PPOPN 2
34173: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34174: LD_VAR 0 1
34178: PPUSH
34179: LD_VAR 0 2
34183: PPUSH
34184: CALL 65265 0 2
// end ;
34188: PPOPN 2
34190: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34191: LD_VAR 0 1
34195: PPUSH
34196: CALL_OW 255
34200: PUSH
34201: LD_INT 4
34203: EQUAL
34204: PUSH
34205: LD_VAR 0 1
34209: PUSH
34210: LD_EXP 18
34214: PUSH
34215: LD_INT 1
34217: ARRAY
34218: IN
34219: AND
34220: PUSH
34221: LD_EXP 19
34225: AND
34226: IFFALSE 34245
// begin ComMoveXY ( driver , 61 , 93 ) ;
34228: LD_VAR 0 1
34232: PPUSH
34233: LD_INT 61
34235: PPUSH
34236: LD_INT 93
34238: PPUSH
34239: CALL_OW 111
// exit ;
34243: GO 34269
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34245: LD_VAR 0 1
34249: PPUSH
34250: LD_VAR 0 2
34254: PPUSH
34255: LD_VAR 0 3
34259: PPUSH
34260: LD_VAR 0 4
34264: PPUSH
34265: CALL 65481 0 4
// end ;
34269: PPOPN 4
34271: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34272: LD_VAR 0 1
34276: PPUSH
34277: LD_VAR 0 2
34281: PPUSH
34282: CALL 60840 0 2
// end ;
34286: PPOPN 2
34288: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34289: LD_VAR 0 1
34293: PPUSH
34294: CALL 118101 0 1
// end ; end_of_file
34298: PPOPN 1
34300: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34301: LD_EXP 15
34305: PUSH
34306: LD_INT 2
34308: EQUAL
34309: IFFALSE 34788
34311: GO 34313
34313: DISABLE
34314: LD_INT 0
34316: PPUSH
// begin time := 0 0$40 ;
34317: LD_ADDR_VAR 0 1
34321: PUSH
34322: LD_INT 1400
34324: ST_TO_ADDR
// repeat wait ( time ) ;
34325: LD_VAR 0 1
34329: PPUSH
34330: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34334: LD_INT 1
34336: PPUSH
34337: LD_INT 5
34339: PPUSH
34340: CALL_OW 12
34344: PPUSH
34345: LD_INT 106
34347: PPUSH
34348: LD_INT 150
34350: PPUSH
34351: LD_INT 19
34353: PPUSH
34354: LD_INT 1
34356: PPUSH
34357: CALL_OW 56
// time := time + 0 0$9 ;
34361: LD_ADDR_VAR 0 1
34365: PUSH
34366: LD_VAR 0 1
34370: PUSH
34371: LD_INT 315
34373: PLUS
34374: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34375: LD_INT 455
34377: PPUSH
34378: LD_INT 840
34380: PPUSH
34381: CALL_OW 12
34385: PPUSH
34386: CALL_OW 67
// if Prob ( 50 ) then
34390: LD_INT 50
34392: PPUSH
34393: CALL_OW 13
34397: IFFALSE 34426
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34399: LD_INT 1
34401: PPUSH
34402: LD_INT 5
34404: PPUSH
34405: CALL_OW 12
34409: PPUSH
34410: LD_INT 62
34412: PPUSH
34413: LD_INT 108
34415: PPUSH
34416: LD_INT 10
34418: PPUSH
34419: LD_INT 1
34421: PPUSH
34422: CALL_OW 56
// until missionStage > 4 ;
34426: LD_EXP 15
34430: PUSH
34431: LD_INT 4
34433: GREATER
34434: IFFALSE 34325
// repeat wait ( 0 0$1 ) ;
34436: LD_INT 35
34438: PPUSH
34439: CALL_OW 67
// until missionStage = 6 ;
34443: LD_EXP 15
34447: PUSH
34448: LD_INT 6
34450: EQUAL
34451: IFFALSE 34436
// time := 0 0$50 ;
34453: LD_ADDR_VAR 0 1
34457: PUSH
34458: LD_INT 1750
34460: ST_TO_ADDR
// repeat wait ( time ) ;
34461: LD_VAR 0 1
34465: PPUSH
34466: CALL_OW 67
// if Prob ( 50 ) then
34470: LD_INT 50
34472: PPUSH
34473: CALL_OW 13
34477: IFFALSE 34506
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34479: LD_INT 1
34481: PPUSH
34482: LD_INT 5
34484: PPUSH
34485: CALL_OW 12
34489: PPUSH
34490: LD_INT 106
34492: PPUSH
34493: LD_INT 89
34495: PPUSH
34496: LD_INT 45
34498: PPUSH
34499: LD_INT 1
34501: PPUSH
34502: CALL_OW 56
// time := time + 0 0$2 ;
34506: LD_ADDR_VAR 0 1
34510: PUSH
34511: LD_VAR 0 1
34515: PUSH
34516: LD_INT 70
34518: PLUS
34519: ST_TO_ADDR
// if Prob ( 30 ) then
34520: LD_INT 30
34522: PPUSH
34523: CALL_OW 13
34527: IFFALSE 34573
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34529: LD_INT 385
34531: PPUSH
34532: LD_INT 945
34534: PPUSH
34535: CALL_OW 12
34539: PPUSH
34540: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34544: LD_INT 1
34546: PPUSH
34547: LD_INT 5
34549: PPUSH
34550: CALL_OW 12
34554: PPUSH
34555: LD_INT 21
34557: PPUSH
34558: LD_INT 26
34560: PPUSH
34561: LD_INT 12
34563: PPUSH
34564: LD_INT 1
34566: PPUSH
34567: CALL_OW 56
// end else
34571: GO 34609
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34573: LD_INT 700
34575: PPUSH
34576: LD_INT 1225
34578: PPUSH
34579: CALL_OW 12
34583: PPUSH
34584: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34588: LD_INT 1
34590: PPUSH
34591: LD_INT 5
34593: PPUSH
34594: CALL_OW 12
34598: PPUSH
34599: LD_INT 16
34601: PPUSH
34602: LD_INT 1
34604: PPUSH
34605: CALL_OW 55
// end ; if Prob ( 50 ) then
34609: LD_INT 50
34611: PPUSH
34612: CALL_OW 13
34616: IFFALSE 34662
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34618: LD_INT 700
34620: PPUSH
34621: LD_INT 1050
34623: PPUSH
34624: CALL_OW 12
34628: PPUSH
34629: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34633: LD_INT 1
34635: PPUSH
34636: LD_INT 5
34638: PPUSH
34639: CALL_OW 12
34643: PPUSH
34644: LD_INT 181
34646: PPUSH
34647: LD_INT 218
34649: PPUSH
34650: LD_INT 16
34652: PPUSH
34653: LD_INT 1
34655: PPUSH
34656: CALL_OW 56
// end else
34660: GO 34698
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34662: LD_INT 350
34664: PPUSH
34665: LD_INT 525
34667: PPUSH
34668: CALL_OW 12
34672: PPUSH
34673: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34677: LD_INT 1
34679: PPUSH
34680: LD_INT 5
34682: PPUSH
34683: CALL_OW 12
34687: PPUSH
34688: LD_INT 15
34690: PPUSH
34691: LD_INT 1
34693: PPUSH
34694: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
34698: LD_INT 45
34700: PUSH
34701: LD_INT 32
34703: PUSH
34704: LD_INT 25
34706: PUSH
34707: EMPTY
34708: LIST
34709: LIST
34710: LIST
34711: PUSH
34712: LD_OWVAR 67
34716: ARRAY
34717: PPUSH
34718: CALL_OW 13
34722: IFFALSE 34766
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34724: LD_INT 175
34726: PPUSH
34727: LD_INT 315
34729: PPUSH
34730: CALL_OW 12
34734: PPUSH
34735: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34739: LD_INT 1
34741: PPUSH
34742: LD_INT 5
34744: PPUSH
34745: CALL_OW 12
34749: PPUSH
34750: LD_INT 103
34752: PPUSH
34753: LD_INT 140
34755: PPUSH
34756: LD_INT 20
34758: PPUSH
34759: LD_INT 1
34761: PPUSH
34762: CALL_OW 56
// end ; if time > 1 1$20 then
34766: LD_VAR 0 1
34770: PUSH
34771: LD_INT 2800
34773: GREATER
34774: IFFALSE 34784
// time := 0 0$30 ;
34776: LD_ADDR_VAR 0 1
34780: PUSH
34781: LD_INT 1050
34783: ST_TO_ADDR
// until false ;
34784: LD_INT 0
34786: IFFALSE 34461
// end ; end_of_file
34788: PPOPN 1
34790: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34791: LD_EXP 13
34795: PUSH
34796: LD_EXP 15
34800: PUSH
34801: LD_INT 6
34803: GREATEREQUAL
34804: AND
34805: IFFALSE 34842
34807: GO 34809
34809: DISABLE
// begin enable ;
34810: ENABLE
// missionTime := missionTime + 0 0$1 ;
34811: LD_ADDR_EXP 14
34815: PUSH
34816: LD_EXP 14
34820: PUSH
34821: LD_INT 35
34823: PLUS
34824: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34825: LD_ADDR_OWVAR 47
34829: PUSH
34830: LD_STRING #Am15-1
34832: PUSH
34833: LD_EXP 14
34837: PUSH
34838: EMPTY
34839: LIST
34840: LIST
34841: ST_TO_ADDR
// end ; end_of_file
34842: END
// export function InitNature ; begin
34843: LD_INT 0
34845: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34846: LD_INT 3
34848: PPUSH
34849: LD_INT 3
34851: PPUSH
34852: LD_INT 2
34854: PPUSH
34855: LD_INT 1
34857: PPUSH
34858: LD_INT 1
34860: PPUSH
34861: LD_INT 0
34863: PPUSH
34864: LD_INT 0
34866: PPUSH
34867: LD_INT 20
34869: PPUSH
34870: LD_INT 0
34872: PPUSH
34873: CALL 98985 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34877: LD_INT 2
34879: PPUSH
34880: LD_INT 1
34882: PPUSH
34883: LD_INT 1
34885: PPUSH
34886: LD_INT 1
34888: PPUSH
34889: LD_INT 1
34891: PPUSH
34892: LD_INT 0
34894: PPUSH
34895: LD_INT 0
34897: PPUSH
34898: LD_INT 21
34900: PPUSH
34901: LD_INT 0
34903: PPUSH
34904: CALL 98985 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34908: LD_INT 4
34910: PPUSH
34911: LD_INT 1
34913: PPUSH
34914: LD_INT 2
34916: PPUSH
34917: LD_INT 4
34919: PPUSH
34920: LD_INT 2
34922: PPUSH
34923: LD_INT 1
34925: PPUSH
34926: LD_INT 0
34928: PPUSH
34929: LD_INT 22
34931: PPUSH
34932: LD_INT 0
34934: PPUSH
34935: CALL 98985 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34939: LD_INT 0
34941: PPUSH
34942: LD_INT 0
34944: PPUSH
34945: LD_INT 0
34947: PPUSH
34948: LD_INT 0
34950: PPUSH
34951: LD_INT 0
34953: PPUSH
34954: LD_INT 0
34956: PPUSH
34957: LD_INT 9
34959: PPUSH
34960: LD_INT 0
34962: PPUSH
34963: LD_INT 23
34965: PPUSH
34966: CALL 98985 0 9
// end ; end_of_file
34970: LD_VAR 0 1
34974: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
34975: LD_INT 0
34977: PPUSH
// ar_miner := 81 ;
34978: LD_ADDR_EXP 102
34982: PUSH
34983: LD_INT 81
34985: ST_TO_ADDR
// ar_crane := 88 ;
34986: LD_ADDR_EXP 101
34990: PUSH
34991: LD_INT 88
34993: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34994: LD_ADDR_EXP 96
34998: PUSH
34999: LD_INT 89
35001: ST_TO_ADDR
// us_hack := 99 ;
35002: LD_ADDR_EXP 97
35006: PUSH
35007: LD_INT 99
35009: ST_TO_ADDR
// us_artillery := 97 ;
35010: LD_ADDR_EXP 98
35014: PUSH
35015: LD_INT 97
35017: ST_TO_ADDR
// ar_bio_bomb := 91 ;
35018: LD_ADDR_EXP 99
35022: PUSH
35023: LD_INT 91
35025: ST_TO_ADDR
// ar_mortar := 92 ;
35026: LD_ADDR_EXP 100
35030: PUSH
35031: LD_INT 92
35033: ST_TO_ADDR
// ru_radar := 98 ;
35034: LD_ADDR_EXP 95
35038: PUSH
35039: LD_INT 98
35041: ST_TO_ADDR
// tech_Artillery := 80 ;
35042: LD_ADDR_EXP 103
35046: PUSH
35047: LD_INT 80
35049: ST_TO_ADDR
// tech_RadMat := 81 ;
35050: LD_ADDR_EXP 104
35054: PUSH
35055: LD_INT 81
35057: ST_TO_ADDR
// tech_BasicTools := 82 ;
35058: LD_ADDR_EXP 105
35062: PUSH
35063: LD_INT 82
35065: ST_TO_ADDR
// tech_Cargo := 83 ;
35066: LD_ADDR_EXP 106
35070: PUSH
35071: LD_INT 83
35073: ST_TO_ADDR
// tech_Track := 84 ;
35074: LD_ADDR_EXP 107
35078: PUSH
35079: LD_INT 84
35081: ST_TO_ADDR
// tech_Crane := 85 ;
35082: LD_ADDR_EXP 108
35086: PUSH
35087: LD_INT 85
35089: ST_TO_ADDR
// tech_Bulldozer := 86 ;
35090: LD_ADDR_EXP 109
35094: PUSH
35095: LD_INT 86
35097: ST_TO_ADDR
// tech_Hovercraft := 87 ;
35098: LD_ADDR_EXP 110
35102: PUSH
35103: LD_INT 87
35105: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
35106: LD_ADDR_EXP 111
35110: PUSH
35111: LD_INT 88
35113: ST_TO_ADDR
// class_mastodont := 31 ;
35114: LD_ADDR_EXP 112
35118: PUSH
35119: LD_INT 31
35121: ST_TO_ADDR
// class_horse := 21 ;
35122: LD_ADDR_EXP 113
35126: PUSH
35127: LD_INT 21
35129: ST_TO_ADDR
// end ;
35130: LD_VAR 0 1
35134: RET
// every 1 do
35135: GO 35137
35137: DISABLE
// InitGlobalVariables ; end_of_file
35138: CALL 34975 0 0
35142: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
35143: LD_INT 0
35145: PPUSH
35146: PPUSH
// skirmish := false ;
35147: LD_ADDR_EXP 114
35151: PUSH
35152: LD_INT 0
35154: ST_TO_ADDR
// debug_mc := false ;
35155: LD_ADDR_EXP 115
35159: PUSH
35160: LD_INT 0
35162: ST_TO_ADDR
// mc_bases := [ ] ;
35163: LD_ADDR_EXP 116
35167: PUSH
35168: EMPTY
35169: ST_TO_ADDR
// mc_sides := [ ] ;
35170: LD_ADDR_EXP 142
35174: PUSH
35175: EMPTY
35176: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
35177: LD_ADDR_EXP 117
35181: PUSH
35182: EMPTY
35183: ST_TO_ADDR
// mc_building_repairs := [ ] ;
35184: LD_ADDR_EXP 118
35188: PUSH
35189: EMPTY
35190: ST_TO_ADDR
// mc_need_heal := [ ] ;
35191: LD_ADDR_EXP 119
35195: PUSH
35196: EMPTY
35197: ST_TO_ADDR
// mc_healers := [ ] ;
35198: LD_ADDR_EXP 120
35202: PUSH
35203: EMPTY
35204: ST_TO_ADDR
// mc_build_list := [ ] ;
35205: LD_ADDR_EXP 121
35209: PUSH
35210: EMPTY
35211: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
35212: LD_ADDR_EXP 148
35216: PUSH
35217: EMPTY
35218: ST_TO_ADDR
// mc_builders := [ ] ;
35219: LD_ADDR_EXP 122
35223: PUSH
35224: EMPTY
35225: ST_TO_ADDR
// mc_construct_list := [ ] ;
35226: LD_ADDR_EXP 123
35230: PUSH
35231: EMPTY
35232: ST_TO_ADDR
// mc_turret_list := [ ] ;
35233: LD_ADDR_EXP 124
35237: PUSH
35238: EMPTY
35239: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
35240: LD_ADDR_EXP 125
35244: PUSH
35245: EMPTY
35246: ST_TO_ADDR
// mc_miners := [ ] ;
35247: LD_ADDR_EXP 130
35251: PUSH
35252: EMPTY
35253: ST_TO_ADDR
// mc_mines := [ ] ;
35254: LD_ADDR_EXP 129
35258: PUSH
35259: EMPTY
35260: ST_TO_ADDR
// mc_minefields := [ ] ;
35261: LD_ADDR_EXP 131
35265: PUSH
35266: EMPTY
35267: ST_TO_ADDR
// mc_crates := [ ] ;
35268: LD_ADDR_EXP 132
35272: PUSH
35273: EMPTY
35274: ST_TO_ADDR
// mc_crates_collector := [ ] ;
35275: LD_ADDR_EXP 133
35279: PUSH
35280: EMPTY
35281: ST_TO_ADDR
// mc_crates_area := [ ] ;
35282: LD_ADDR_EXP 134
35286: PUSH
35287: EMPTY
35288: ST_TO_ADDR
// mc_vehicles := [ ] ;
35289: LD_ADDR_EXP 135
35293: PUSH
35294: EMPTY
35295: ST_TO_ADDR
// mc_attack := [ ] ;
35296: LD_ADDR_EXP 136
35300: PUSH
35301: EMPTY
35302: ST_TO_ADDR
// mc_produce := [ ] ;
35303: LD_ADDR_EXP 137
35307: PUSH
35308: EMPTY
35309: ST_TO_ADDR
// mc_defender := [ ] ;
35310: LD_ADDR_EXP 138
35314: PUSH
35315: EMPTY
35316: ST_TO_ADDR
// mc_parking := [ ] ;
35317: LD_ADDR_EXP 140
35321: PUSH
35322: EMPTY
35323: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35324: LD_ADDR_EXP 126
35328: PUSH
35329: EMPTY
35330: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35331: LD_ADDR_EXP 128
35335: PUSH
35336: EMPTY
35337: ST_TO_ADDR
// mc_scan := [ ] ;
35338: LD_ADDR_EXP 139
35342: PUSH
35343: EMPTY
35344: ST_TO_ADDR
// mc_scan_area := [ ] ;
35345: LD_ADDR_EXP 141
35349: PUSH
35350: EMPTY
35351: ST_TO_ADDR
// mc_tech := [ ] ;
35352: LD_ADDR_EXP 143
35356: PUSH
35357: EMPTY
35358: ST_TO_ADDR
// mc_class := [ ] ;
35359: LD_ADDR_EXP 157
35363: PUSH
35364: EMPTY
35365: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35366: LD_ADDR_EXP 158
35370: PUSH
35371: EMPTY
35372: ST_TO_ADDR
// mc_is_defending := [ ] ;
35373: LD_ADDR_EXP 159
35377: PUSH
35378: EMPTY
35379: ST_TO_ADDR
// end ;
35380: LD_VAR 0 1
35384: RET
// export function MC_Kill ( base ) ; begin
35385: LD_INT 0
35387: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35388: LD_ADDR_EXP 116
35392: PUSH
35393: LD_EXP 116
35397: PPUSH
35398: LD_VAR 0 1
35402: PPUSH
35403: EMPTY
35404: PPUSH
35405: CALL_OW 1
35409: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35410: LD_ADDR_EXP 117
35414: PUSH
35415: LD_EXP 117
35419: PPUSH
35420: LD_VAR 0 1
35424: PPUSH
35425: EMPTY
35426: PPUSH
35427: CALL_OW 1
35431: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35432: LD_ADDR_EXP 118
35436: PUSH
35437: LD_EXP 118
35441: PPUSH
35442: LD_VAR 0 1
35446: PPUSH
35447: EMPTY
35448: PPUSH
35449: CALL_OW 1
35453: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35454: LD_ADDR_EXP 119
35458: PUSH
35459: LD_EXP 119
35463: PPUSH
35464: LD_VAR 0 1
35468: PPUSH
35469: EMPTY
35470: PPUSH
35471: CALL_OW 1
35475: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35476: LD_ADDR_EXP 120
35480: PUSH
35481: LD_EXP 120
35485: PPUSH
35486: LD_VAR 0 1
35490: PPUSH
35491: EMPTY
35492: PPUSH
35493: CALL_OW 1
35497: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35498: LD_ADDR_EXP 121
35502: PUSH
35503: LD_EXP 121
35507: PPUSH
35508: LD_VAR 0 1
35512: PPUSH
35513: EMPTY
35514: PPUSH
35515: CALL_OW 1
35519: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35520: LD_ADDR_EXP 122
35524: PUSH
35525: LD_EXP 122
35529: PPUSH
35530: LD_VAR 0 1
35534: PPUSH
35535: EMPTY
35536: PPUSH
35537: CALL_OW 1
35541: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35542: LD_ADDR_EXP 123
35546: PUSH
35547: LD_EXP 123
35551: PPUSH
35552: LD_VAR 0 1
35556: PPUSH
35557: EMPTY
35558: PPUSH
35559: CALL_OW 1
35563: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35564: LD_ADDR_EXP 124
35568: PUSH
35569: LD_EXP 124
35573: PPUSH
35574: LD_VAR 0 1
35578: PPUSH
35579: EMPTY
35580: PPUSH
35581: CALL_OW 1
35585: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35586: LD_ADDR_EXP 125
35590: PUSH
35591: LD_EXP 125
35595: PPUSH
35596: LD_VAR 0 1
35600: PPUSH
35601: EMPTY
35602: PPUSH
35603: CALL_OW 1
35607: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35608: LD_ADDR_EXP 126
35612: PUSH
35613: LD_EXP 126
35617: PPUSH
35618: LD_VAR 0 1
35622: PPUSH
35623: EMPTY
35624: PPUSH
35625: CALL_OW 1
35629: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35630: LD_ADDR_EXP 127
35634: PUSH
35635: LD_EXP 127
35639: PPUSH
35640: LD_VAR 0 1
35644: PPUSH
35645: LD_INT 0
35647: PPUSH
35648: CALL_OW 1
35652: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35653: LD_ADDR_EXP 128
35657: PUSH
35658: LD_EXP 128
35662: PPUSH
35663: LD_VAR 0 1
35667: PPUSH
35668: EMPTY
35669: PPUSH
35670: CALL_OW 1
35674: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35675: LD_ADDR_EXP 129
35679: PUSH
35680: LD_EXP 129
35684: PPUSH
35685: LD_VAR 0 1
35689: PPUSH
35690: EMPTY
35691: PPUSH
35692: CALL_OW 1
35696: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35697: LD_ADDR_EXP 130
35701: PUSH
35702: LD_EXP 130
35706: PPUSH
35707: LD_VAR 0 1
35711: PPUSH
35712: EMPTY
35713: PPUSH
35714: CALL_OW 1
35718: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35719: LD_ADDR_EXP 131
35723: PUSH
35724: LD_EXP 131
35728: PPUSH
35729: LD_VAR 0 1
35733: PPUSH
35734: EMPTY
35735: PPUSH
35736: CALL_OW 1
35740: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35741: LD_ADDR_EXP 132
35745: PUSH
35746: LD_EXP 132
35750: PPUSH
35751: LD_VAR 0 1
35755: PPUSH
35756: EMPTY
35757: PPUSH
35758: CALL_OW 1
35762: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35763: LD_ADDR_EXP 133
35767: PUSH
35768: LD_EXP 133
35772: PPUSH
35773: LD_VAR 0 1
35777: PPUSH
35778: EMPTY
35779: PPUSH
35780: CALL_OW 1
35784: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35785: LD_ADDR_EXP 134
35789: PUSH
35790: LD_EXP 134
35794: PPUSH
35795: LD_VAR 0 1
35799: PPUSH
35800: EMPTY
35801: PPUSH
35802: CALL_OW 1
35806: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35807: LD_ADDR_EXP 135
35811: PUSH
35812: LD_EXP 135
35816: PPUSH
35817: LD_VAR 0 1
35821: PPUSH
35822: EMPTY
35823: PPUSH
35824: CALL_OW 1
35828: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35829: LD_ADDR_EXP 136
35833: PUSH
35834: LD_EXP 136
35838: PPUSH
35839: LD_VAR 0 1
35843: PPUSH
35844: EMPTY
35845: PPUSH
35846: CALL_OW 1
35850: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35851: LD_ADDR_EXP 137
35855: PUSH
35856: LD_EXP 137
35860: PPUSH
35861: LD_VAR 0 1
35865: PPUSH
35866: EMPTY
35867: PPUSH
35868: CALL_OW 1
35872: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35873: LD_ADDR_EXP 138
35877: PUSH
35878: LD_EXP 138
35882: PPUSH
35883: LD_VAR 0 1
35887: PPUSH
35888: EMPTY
35889: PPUSH
35890: CALL_OW 1
35894: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35895: LD_ADDR_EXP 139
35899: PUSH
35900: LD_EXP 139
35904: PPUSH
35905: LD_VAR 0 1
35909: PPUSH
35910: EMPTY
35911: PPUSH
35912: CALL_OW 1
35916: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35917: LD_ADDR_EXP 140
35921: PUSH
35922: LD_EXP 140
35926: PPUSH
35927: LD_VAR 0 1
35931: PPUSH
35932: EMPTY
35933: PPUSH
35934: CALL_OW 1
35938: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35939: LD_ADDR_EXP 141
35943: PUSH
35944: LD_EXP 141
35948: PPUSH
35949: LD_VAR 0 1
35953: PPUSH
35954: EMPTY
35955: PPUSH
35956: CALL_OW 1
35960: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35961: LD_ADDR_EXP 143
35965: PUSH
35966: LD_EXP 143
35970: PPUSH
35971: LD_VAR 0 1
35975: PPUSH
35976: EMPTY
35977: PPUSH
35978: CALL_OW 1
35982: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35983: LD_ADDR_EXP 145
35987: PUSH
35988: LD_EXP 145
35992: PPUSH
35993: LD_VAR 0 1
35997: PPUSH
35998: EMPTY
35999: PPUSH
36000: CALL_OW 1
36004: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36005: LD_ADDR_EXP 146
36009: PUSH
36010: LD_EXP 146
36014: PPUSH
36015: LD_VAR 0 1
36019: PPUSH
36020: EMPTY
36021: PPUSH
36022: CALL_OW 1
36026: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36027: LD_ADDR_EXP 147
36031: PUSH
36032: LD_EXP 147
36036: PPUSH
36037: LD_VAR 0 1
36041: PPUSH
36042: EMPTY
36043: PPUSH
36044: CALL_OW 1
36048: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36049: LD_ADDR_EXP 148
36053: PUSH
36054: LD_EXP 148
36058: PPUSH
36059: LD_VAR 0 1
36063: PPUSH
36064: EMPTY
36065: PPUSH
36066: CALL_OW 1
36070: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36071: LD_ADDR_EXP 149
36075: PUSH
36076: LD_EXP 149
36080: PPUSH
36081: LD_VAR 0 1
36085: PPUSH
36086: EMPTY
36087: PPUSH
36088: CALL_OW 1
36092: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36093: LD_ADDR_EXP 150
36097: PUSH
36098: LD_EXP 150
36102: PPUSH
36103: LD_VAR 0 1
36107: PPUSH
36108: EMPTY
36109: PPUSH
36110: CALL_OW 1
36114: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36115: LD_ADDR_EXP 151
36119: PUSH
36120: LD_EXP 151
36124: PPUSH
36125: LD_VAR 0 1
36129: PPUSH
36130: EMPTY
36131: PPUSH
36132: CALL_OW 1
36136: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36137: LD_ADDR_EXP 152
36141: PUSH
36142: LD_EXP 152
36146: PPUSH
36147: LD_VAR 0 1
36151: PPUSH
36152: EMPTY
36153: PPUSH
36154: CALL_OW 1
36158: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36159: LD_ADDR_EXP 153
36163: PUSH
36164: LD_EXP 153
36168: PPUSH
36169: LD_VAR 0 1
36173: PPUSH
36174: EMPTY
36175: PPUSH
36176: CALL_OW 1
36180: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36181: LD_ADDR_EXP 154
36185: PUSH
36186: LD_EXP 154
36190: PPUSH
36191: LD_VAR 0 1
36195: PPUSH
36196: EMPTY
36197: PPUSH
36198: CALL_OW 1
36202: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36203: LD_ADDR_EXP 155
36207: PUSH
36208: LD_EXP 155
36212: PPUSH
36213: LD_VAR 0 1
36217: PPUSH
36218: EMPTY
36219: PPUSH
36220: CALL_OW 1
36224: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36225: LD_ADDR_EXP 156
36229: PUSH
36230: LD_EXP 156
36234: PPUSH
36235: LD_VAR 0 1
36239: PPUSH
36240: EMPTY
36241: PPUSH
36242: CALL_OW 1
36246: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36247: LD_ADDR_EXP 157
36251: PUSH
36252: LD_EXP 157
36256: PPUSH
36257: LD_VAR 0 1
36261: PPUSH
36262: EMPTY
36263: PPUSH
36264: CALL_OW 1
36268: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36269: LD_ADDR_EXP 158
36273: PUSH
36274: LD_EXP 158
36278: PPUSH
36279: LD_VAR 0 1
36283: PPUSH
36284: LD_INT 0
36286: PPUSH
36287: CALL_OW 1
36291: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
36292: LD_ADDR_EXP 159
36296: PUSH
36297: LD_EXP 159
36301: PPUSH
36302: LD_VAR 0 1
36306: PPUSH
36307: LD_INT 0
36309: PPUSH
36310: CALL_OW 1
36314: ST_TO_ADDR
// end ;
36315: LD_VAR 0 2
36319: RET
// export function MC_Add ( side , units ) ; var base ; begin
36320: LD_INT 0
36322: PPUSH
36323: PPUSH
// base := mc_bases + 1 ;
36324: LD_ADDR_VAR 0 4
36328: PUSH
36329: LD_EXP 116
36333: PUSH
36334: LD_INT 1
36336: PLUS
36337: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36338: LD_ADDR_EXP 142
36342: PUSH
36343: LD_EXP 142
36347: PPUSH
36348: LD_VAR 0 4
36352: PPUSH
36353: LD_VAR 0 1
36357: PPUSH
36358: CALL_OW 1
36362: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36363: LD_ADDR_EXP 116
36367: PUSH
36368: LD_EXP 116
36372: PPUSH
36373: LD_VAR 0 4
36377: PPUSH
36378: LD_VAR 0 2
36382: PPUSH
36383: CALL_OW 1
36387: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36388: LD_ADDR_EXP 117
36392: PUSH
36393: LD_EXP 117
36397: PPUSH
36398: LD_VAR 0 4
36402: PPUSH
36403: EMPTY
36404: PPUSH
36405: CALL_OW 1
36409: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36410: LD_ADDR_EXP 118
36414: PUSH
36415: LD_EXP 118
36419: PPUSH
36420: LD_VAR 0 4
36424: PPUSH
36425: EMPTY
36426: PPUSH
36427: CALL_OW 1
36431: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36432: LD_ADDR_EXP 119
36436: PUSH
36437: LD_EXP 119
36441: PPUSH
36442: LD_VAR 0 4
36446: PPUSH
36447: EMPTY
36448: PPUSH
36449: CALL_OW 1
36453: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36454: LD_ADDR_EXP 120
36458: PUSH
36459: LD_EXP 120
36463: PPUSH
36464: LD_VAR 0 4
36468: PPUSH
36469: EMPTY
36470: PPUSH
36471: CALL_OW 1
36475: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36476: LD_ADDR_EXP 121
36480: PUSH
36481: LD_EXP 121
36485: PPUSH
36486: LD_VAR 0 4
36490: PPUSH
36491: EMPTY
36492: PPUSH
36493: CALL_OW 1
36497: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36498: LD_ADDR_EXP 122
36502: PUSH
36503: LD_EXP 122
36507: PPUSH
36508: LD_VAR 0 4
36512: PPUSH
36513: EMPTY
36514: PPUSH
36515: CALL_OW 1
36519: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36520: LD_ADDR_EXP 123
36524: PUSH
36525: LD_EXP 123
36529: PPUSH
36530: LD_VAR 0 4
36534: PPUSH
36535: EMPTY
36536: PPUSH
36537: CALL_OW 1
36541: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36542: LD_ADDR_EXP 124
36546: PUSH
36547: LD_EXP 124
36551: PPUSH
36552: LD_VAR 0 4
36556: PPUSH
36557: EMPTY
36558: PPUSH
36559: CALL_OW 1
36563: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36564: LD_ADDR_EXP 125
36568: PUSH
36569: LD_EXP 125
36573: PPUSH
36574: LD_VAR 0 4
36578: PPUSH
36579: EMPTY
36580: PPUSH
36581: CALL_OW 1
36585: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36586: LD_ADDR_EXP 126
36590: PUSH
36591: LD_EXP 126
36595: PPUSH
36596: LD_VAR 0 4
36600: PPUSH
36601: EMPTY
36602: PPUSH
36603: CALL_OW 1
36607: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36608: LD_ADDR_EXP 127
36612: PUSH
36613: LD_EXP 127
36617: PPUSH
36618: LD_VAR 0 4
36622: PPUSH
36623: LD_INT 0
36625: PPUSH
36626: CALL_OW 1
36630: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36631: LD_ADDR_EXP 128
36635: PUSH
36636: LD_EXP 128
36640: PPUSH
36641: LD_VAR 0 4
36645: PPUSH
36646: EMPTY
36647: PPUSH
36648: CALL_OW 1
36652: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36653: LD_ADDR_EXP 129
36657: PUSH
36658: LD_EXP 129
36662: PPUSH
36663: LD_VAR 0 4
36667: PPUSH
36668: EMPTY
36669: PPUSH
36670: CALL_OW 1
36674: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36675: LD_ADDR_EXP 130
36679: PUSH
36680: LD_EXP 130
36684: PPUSH
36685: LD_VAR 0 4
36689: PPUSH
36690: EMPTY
36691: PPUSH
36692: CALL_OW 1
36696: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36697: LD_ADDR_EXP 131
36701: PUSH
36702: LD_EXP 131
36706: PPUSH
36707: LD_VAR 0 4
36711: PPUSH
36712: EMPTY
36713: PPUSH
36714: CALL_OW 1
36718: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36719: LD_ADDR_EXP 132
36723: PUSH
36724: LD_EXP 132
36728: PPUSH
36729: LD_VAR 0 4
36733: PPUSH
36734: EMPTY
36735: PPUSH
36736: CALL_OW 1
36740: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36741: LD_ADDR_EXP 133
36745: PUSH
36746: LD_EXP 133
36750: PPUSH
36751: LD_VAR 0 4
36755: PPUSH
36756: EMPTY
36757: PPUSH
36758: CALL_OW 1
36762: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36763: LD_ADDR_EXP 134
36767: PUSH
36768: LD_EXP 134
36772: PPUSH
36773: LD_VAR 0 4
36777: PPUSH
36778: EMPTY
36779: PPUSH
36780: CALL_OW 1
36784: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36785: LD_ADDR_EXP 135
36789: PUSH
36790: LD_EXP 135
36794: PPUSH
36795: LD_VAR 0 4
36799: PPUSH
36800: EMPTY
36801: PPUSH
36802: CALL_OW 1
36806: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36807: LD_ADDR_EXP 136
36811: PUSH
36812: LD_EXP 136
36816: PPUSH
36817: LD_VAR 0 4
36821: PPUSH
36822: EMPTY
36823: PPUSH
36824: CALL_OW 1
36828: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36829: LD_ADDR_EXP 137
36833: PUSH
36834: LD_EXP 137
36838: PPUSH
36839: LD_VAR 0 4
36843: PPUSH
36844: EMPTY
36845: PPUSH
36846: CALL_OW 1
36850: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36851: LD_ADDR_EXP 138
36855: PUSH
36856: LD_EXP 138
36860: PPUSH
36861: LD_VAR 0 4
36865: PPUSH
36866: EMPTY
36867: PPUSH
36868: CALL_OW 1
36872: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36873: LD_ADDR_EXP 139
36877: PUSH
36878: LD_EXP 139
36882: PPUSH
36883: LD_VAR 0 4
36887: PPUSH
36888: EMPTY
36889: PPUSH
36890: CALL_OW 1
36894: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36895: LD_ADDR_EXP 140
36899: PUSH
36900: LD_EXP 140
36904: PPUSH
36905: LD_VAR 0 4
36909: PPUSH
36910: EMPTY
36911: PPUSH
36912: CALL_OW 1
36916: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36917: LD_ADDR_EXP 141
36921: PUSH
36922: LD_EXP 141
36926: PPUSH
36927: LD_VAR 0 4
36931: PPUSH
36932: EMPTY
36933: PPUSH
36934: CALL_OW 1
36938: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36939: LD_ADDR_EXP 143
36943: PUSH
36944: LD_EXP 143
36948: PPUSH
36949: LD_VAR 0 4
36953: PPUSH
36954: EMPTY
36955: PPUSH
36956: CALL_OW 1
36960: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36961: LD_ADDR_EXP 145
36965: PUSH
36966: LD_EXP 145
36970: PPUSH
36971: LD_VAR 0 4
36975: PPUSH
36976: EMPTY
36977: PPUSH
36978: CALL_OW 1
36982: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36983: LD_ADDR_EXP 146
36987: PUSH
36988: LD_EXP 146
36992: PPUSH
36993: LD_VAR 0 4
36997: PPUSH
36998: EMPTY
36999: PPUSH
37000: CALL_OW 1
37004: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
37005: LD_ADDR_EXP 147
37009: PUSH
37010: LD_EXP 147
37014: PPUSH
37015: LD_VAR 0 4
37019: PPUSH
37020: EMPTY
37021: PPUSH
37022: CALL_OW 1
37026: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
37027: LD_ADDR_EXP 148
37031: PUSH
37032: LD_EXP 148
37036: PPUSH
37037: LD_VAR 0 4
37041: PPUSH
37042: EMPTY
37043: PPUSH
37044: CALL_OW 1
37048: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
37049: LD_ADDR_EXP 149
37053: PUSH
37054: LD_EXP 149
37058: PPUSH
37059: LD_VAR 0 4
37063: PPUSH
37064: EMPTY
37065: PPUSH
37066: CALL_OW 1
37070: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37071: LD_ADDR_EXP 150
37075: PUSH
37076: LD_EXP 150
37080: PPUSH
37081: LD_VAR 0 4
37085: PPUSH
37086: EMPTY
37087: PPUSH
37088: CALL_OW 1
37092: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37093: LD_ADDR_EXP 151
37097: PUSH
37098: LD_EXP 151
37102: PPUSH
37103: LD_VAR 0 4
37107: PPUSH
37108: EMPTY
37109: PPUSH
37110: CALL_OW 1
37114: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37115: LD_ADDR_EXP 152
37119: PUSH
37120: LD_EXP 152
37124: PPUSH
37125: LD_VAR 0 4
37129: PPUSH
37130: EMPTY
37131: PPUSH
37132: CALL_OW 1
37136: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37137: LD_ADDR_EXP 153
37141: PUSH
37142: LD_EXP 153
37146: PPUSH
37147: LD_VAR 0 4
37151: PPUSH
37152: EMPTY
37153: PPUSH
37154: CALL_OW 1
37158: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37159: LD_ADDR_EXP 154
37163: PUSH
37164: LD_EXP 154
37168: PPUSH
37169: LD_VAR 0 4
37173: PPUSH
37174: EMPTY
37175: PPUSH
37176: CALL_OW 1
37180: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37181: LD_ADDR_EXP 155
37185: PUSH
37186: LD_EXP 155
37190: PPUSH
37191: LD_VAR 0 4
37195: PPUSH
37196: EMPTY
37197: PPUSH
37198: CALL_OW 1
37202: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37203: LD_ADDR_EXP 156
37207: PUSH
37208: LD_EXP 156
37212: PPUSH
37213: LD_VAR 0 4
37217: PPUSH
37218: EMPTY
37219: PPUSH
37220: CALL_OW 1
37224: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37225: LD_ADDR_EXP 157
37229: PUSH
37230: LD_EXP 157
37234: PPUSH
37235: LD_VAR 0 4
37239: PPUSH
37240: EMPTY
37241: PPUSH
37242: CALL_OW 1
37246: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37247: LD_ADDR_EXP 158
37251: PUSH
37252: LD_EXP 158
37256: PPUSH
37257: LD_VAR 0 4
37261: PPUSH
37262: LD_INT 0
37264: PPUSH
37265: CALL_OW 1
37269: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
37270: LD_ADDR_EXP 159
37274: PUSH
37275: LD_EXP 159
37279: PPUSH
37280: LD_VAR 0 4
37284: PPUSH
37285: LD_INT 0
37287: PPUSH
37288: CALL_OW 1
37292: ST_TO_ADDR
// result := base ;
37293: LD_ADDR_VAR 0 3
37297: PUSH
37298: LD_VAR 0 4
37302: ST_TO_ADDR
// end ;
37303: LD_VAR 0 3
37307: RET
// export function MC_Start ( ) ; var i ; begin
37308: LD_INT 0
37310: PPUSH
37311: PPUSH
// for i = 1 to mc_bases do
37312: LD_ADDR_VAR 0 2
37316: PUSH
37317: DOUBLE
37318: LD_INT 1
37320: DEC
37321: ST_TO_ADDR
37322: LD_EXP 116
37326: PUSH
37327: FOR_TO
37328: IFFALSE 38428
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
37330: LD_ADDR_EXP 116
37334: PUSH
37335: LD_EXP 116
37339: PPUSH
37340: LD_VAR 0 2
37344: PPUSH
37345: LD_EXP 116
37349: PUSH
37350: LD_VAR 0 2
37354: ARRAY
37355: PUSH
37356: LD_INT 0
37358: DIFF
37359: PPUSH
37360: CALL_OW 1
37364: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37365: LD_ADDR_EXP 117
37369: PUSH
37370: LD_EXP 117
37374: PPUSH
37375: LD_VAR 0 2
37379: PPUSH
37380: EMPTY
37381: PPUSH
37382: CALL_OW 1
37386: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37387: LD_ADDR_EXP 118
37391: PUSH
37392: LD_EXP 118
37396: PPUSH
37397: LD_VAR 0 2
37401: PPUSH
37402: EMPTY
37403: PPUSH
37404: CALL_OW 1
37408: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37409: LD_ADDR_EXP 119
37413: PUSH
37414: LD_EXP 119
37418: PPUSH
37419: LD_VAR 0 2
37423: PPUSH
37424: EMPTY
37425: PPUSH
37426: CALL_OW 1
37430: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37431: LD_ADDR_EXP 120
37435: PUSH
37436: LD_EXP 120
37440: PPUSH
37441: LD_VAR 0 2
37445: PPUSH
37446: EMPTY
37447: PUSH
37448: EMPTY
37449: PUSH
37450: EMPTY
37451: LIST
37452: LIST
37453: PPUSH
37454: CALL_OW 1
37458: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37459: LD_ADDR_EXP 121
37463: PUSH
37464: LD_EXP 121
37468: PPUSH
37469: LD_VAR 0 2
37473: PPUSH
37474: EMPTY
37475: PPUSH
37476: CALL_OW 1
37480: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37481: LD_ADDR_EXP 148
37485: PUSH
37486: LD_EXP 148
37490: PPUSH
37491: LD_VAR 0 2
37495: PPUSH
37496: EMPTY
37497: PPUSH
37498: CALL_OW 1
37502: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37503: LD_ADDR_EXP 122
37507: PUSH
37508: LD_EXP 122
37512: PPUSH
37513: LD_VAR 0 2
37517: PPUSH
37518: EMPTY
37519: PPUSH
37520: CALL_OW 1
37524: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37525: LD_ADDR_EXP 123
37529: PUSH
37530: LD_EXP 123
37534: PPUSH
37535: LD_VAR 0 2
37539: PPUSH
37540: EMPTY
37541: PPUSH
37542: CALL_OW 1
37546: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37547: LD_ADDR_EXP 124
37551: PUSH
37552: LD_EXP 124
37556: PPUSH
37557: LD_VAR 0 2
37561: PPUSH
37562: LD_EXP 116
37566: PUSH
37567: LD_VAR 0 2
37571: ARRAY
37572: PPUSH
37573: LD_INT 2
37575: PUSH
37576: LD_INT 30
37578: PUSH
37579: LD_INT 32
37581: PUSH
37582: EMPTY
37583: LIST
37584: LIST
37585: PUSH
37586: LD_INT 30
37588: PUSH
37589: LD_INT 33
37591: PUSH
37592: EMPTY
37593: LIST
37594: LIST
37595: PUSH
37596: EMPTY
37597: LIST
37598: LIST
37599: LIST
37600: PPUSH
37601: CALL_OW 72
37605: PPUSH
37606: CALL_OW 1
37610: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37611: LD_ADDR_EXP 125
37615: PUSH
37616: LD_EXP 125
37620: PPUSH
37621: LD_VAR 0 2
37625: PPUSH
37626: LD_EXP 116
37630: PUSH
37631: LD_VAR 0 2
37635: ARRAY
37636: PPUSH
37637: LD_INT 2
37639: PUSH
37640: LD_INT 30
37642: PUSH
37643: LD_INT 32
37645: PUSH
37646: EMPTY
37647: LIST
37648: LIST
37649: PUSH
37650: LD_INT 30
37652: PUSH
37653: LD_INT 31
37655: PUSH
37656: EMPTY
37657: LIST
37658: LIST
37659: PUSH
37660: EMPTY
37661: LIST
37662: LIST
37663: LIST
37664: PUSH
37665: LD_INT 58
37667: PUSH
37668: EMPTY
37669: LIST
37670: PUSH
37671: EMPTY
37672: LIST
37673: LIST
37674: PPUSH
37675: CALL_OW 72
37679: PPUSH
37680: CALL_OW 1
37684: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37685: LD_ADDR_EXP 126
37689: PUSH
37690: LD_EXP 126
37694: PPUSH
37695: LD_VAR 0 2
37699: PPUSH
37700: EMPTY
37701: PPUSH
37702: CALL_OW 1
37706: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37707: LD_ADDR_EXP 130
37711: PUSH
37712: LD_EXP 130
37716: PPUSH
37717: LD_VAR 0 2
37721: PPUSH
37722: EMPTY
37723: PPUSH
37724: CALL_OW 1
37728: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37729: LD_ADDR_EXP 129
37733: PUSH
37734: LD_EXP 129
37738: PPUSH
37739: LD_VAR 0 2
37743: PPUSH
37744: EMPTY
37745: PPUSH
37746: CALL_OW 1
37750: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37751: LD_ADDR_EXP 131
37755: PUSH
37756: LD_EXP 131
37760: PPUSH
37761: LD_VAR 0 2
37765: PPUSH
37766: EMPTY
37767: PPUSH
37768: CALL_OW 1
37772: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37773: LD_ADDR_EXP 132
37777: PUSH
37778: LD_EXP 132
37782: PPUSH
37783: LD_VAR 0 2
37787: PPUSH
37788: EMPTY
37789: PPUSH
37790: CALL_OW 1
37794: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37795: LD_ADDR_EXP 133
37799: PUSH
37800: LD_EXP 133
37804: PPUSH
37805: LD_VAR 0 2
37809: PPUSH
37810: EMPTY
37811: PPUSH
37812: CALL_OW 1
37816: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37817: LD_ADDR_EXP 134
37821: PUSH
37822: LD_EXP 134
37826: PPUSH
37827: LD_VAR 0 2
37831: PPUSH
37832: EMPTY
37833: PPUSH
37834: CALL_OW 1
37838: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37839: LD_ADDR_EXP 135
37843: PUSH
37844: LD_EXP 135
37848: PPUSH
37849: LD_VAR 0 2
37853: PPUSH
37854: EMPTY
37855: PPUSH
37856: CALL_OW 1
37860: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37861: LD_ADDR_EXP 136
37865: PUSH
37866: LD_EXP 136
37870: PPUSH
37871: LD_VAR 0 2
37875: PPUSH
37876: EMPTY
37877: PPUSH
37878: CALL_OW 1
37882: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37883: LD_ADDR_EXP 137
37887: PUSH
37888: LD_EXP 137
37892: PPUSH
37893: LD_VAR 0 2
37897: PPUSH
37898: EMPTY
37899: PPUSH
37900: CALL_OW 1
37904: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37905: LD_ADDR_EXP 138
37909: PUSH
37910: LD_EXP 138
37914: PPUSH
37915: LD_VAR 0 2
37919: PPUSH
37920: EMPTY
37921: PPUSH
37922: CALL_OW 1
37926: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
37927: LD_ADDR_EXP 127
37931: PUSH
37932: LD_EXP 127
37936: PPUSH
37937: LD_VAR 0 2
37941: PPUSH
37942: LD_INT 0
37944: PPUSH
37945: CALL_OW 1
37949: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
37950: LD_ADDR_EXP 140
37954: PUSH
37955: LD_EXP 140
37959: PPUSH
37960: LD_VAR 0 2
37964: PPUSH
37965: LD_INT 0
37967: PPUSH
37968: CALL_OW 1
37972: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37973: LD_ADDR_EXP 128
37977: PUSH
37978: LD_EXP 128
37982: PPUSH
37983: LD_VAR 0 2
37987: PPUSH
37988: EMPTY
37989: PPUSH
37990: CALL_OW 1
37994: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37995: LD_ADDR_EXP 139
37999: PUSH
38000: LD_EXP 139
38004: PPUSH
38005: LD_VAR 0 2
38009: PPUSH
38010: LD_INT 0
38012: PPUSH
38013: CALL_OW 1
38017: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
38018: LD_ADDR_EXP 141
38022: PUSH
38023: LD_EXP 141
38027: PPUSH
38028: LD_VAR 0 2
38032: PPUSH
38033: EMPTY
38034: PPUSH
38035: CALL_OW 1
38039: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
38040: LD_ADDR_EXP 144
38044: PUSH
38045: LD_EXP 144
38049: PPUSH
38050: LD_VAR 0 2
38054: PPUSH
38055: LD_INT 0
38057: PPUSH
38058: CALL_OW 1
38062: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
38063: LD_ADDR_EXP 145
38067: PUSH
38068: LD_EXP 145
38072: PPUSH
38073: LD_VAR 0 2
38077: PPUSH
38078: EMPTY
38079: PPUSH
38080: CALL_OW 1
38084: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
38085: LD_ADDR_EXP 146
38089: PUSH
38090: LD_EXP 146
38094: PPUSH
38095: LD_VAR 0 2
38099: PPUSH
38100: EMPTY
38101: PPUSH
38102: CALL_OW 1
38106: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38107: LD_ADDR_EXP 147
38111: PUSH
38112: LD_EXP 147
38116: PPUSH
38117: LD_VAR 0 2
38121: PPUSH
38122: EMPTY
38123: PPUSH
38124: CALL_OW 1
38128: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
38129: LD_ADDR_EXP 149
38133: PUSH
38134: LD_EXP 149
38138: PPUSH
38139: LD_VAR 0 2
38143: PPUSH
38144: LD_EXP 116
38148: PUSH
38149: LD_VAR 0 2
38153: ARRAY
38154: PPUSH
38155: LD_INT 2
38157: PUSH
38158: LD_INT 30
38160: PUSH
38161: LD_INT 6
38163: PUSH
38164: EMPTY
38165: LIST
38166: LIST
38167: PUSH
38168: LD_INT 30
38170: PUSH
38171: LD_INT 7
38173: PUSH
38174: EMPTY
38175: LIST
38176: LIST
38177: PUSH
38178: LD_INT 30
38180: PUSH
38181: LD_INT 8
38183: PUSH
38184: EMPTY
38185: LIST
38186: LIST
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: LIST
38192: LIST
38193: PPUSH
38194: CALL_OW 72
38198: PPUSH
38199: CALL_OW 1
38203: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
38204: LD_ADDR_EXP 150
38208: PUSH
38209: LD_EXP 150
38213: PPUSH
38214: LD_VAR 0 2
38218: PPUSH
38219: EMPTY
38220: PPUSH
38221: CALL_OW 1
38225: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
38226: LD_ADDR_EXP 151
38230: PUSH
38231: LD_EXP 151
38235: PPUSH
38236: LD_VAR 0 2
38240: PPUSH
38241: EMPTY
38242: PPUSH
38243: CALL_OW 1
38247: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
38248: LD_ADDR_EXP 152
38252: PUSH
38253: LD_EXP 152
38257: PPUSH
38258: LD_VAR 0 2
38262: PPUSH
38263: EMPTY
38264: PPUSH
38265: CALL_OW 1
38269: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
38270: LD_ADDR_EXP 153
38274: PUSH
38275: LD_EXP 153
38279: PPUSH
38280: LD_VAR 0 2
38284: PPUSH
38285: EMPTY
38286: PPUSH
38287: CALL_OW 1
38291: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38292: LD_ADDR_EXP 154
38296: PUSH
38297: LD_EXP 154
38301: PPUSH
38302: LD_VAR 0 2
38306: PPUSH
38307: EMPTY
38308: PPUSH
38309: CALL_OW 1
38313: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
38314: LD_ADDR_EXP 155
38318: PUSH
38319: LD_EXP 155
38323: PPUSH
38324: LD_VAR 0 2
38328: PPUSH
38329: EMPTY
38330: PPUSH
38331: CALL_OW 1
38335: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
38336: LD_ADDR_EXP 156
38340: PUSH
38341: LD_EXP 156
38345: PPUSH
38346: LD_VAR 0 2
38350: PPUSH
38351: EMPTY
38352: PPUSH
38353: CALL_OW 1
38357: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38358: LD_ADDR_EXP 157
38362: PUSH
38363: LD_EXP 157
38367: PPUSH
38368: LD_VAR 0 2
38372: PPUSH
38373: EMPTY
38374: PPUSH
38375: CALL_OW 1
38379: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38380: LD_ADDR_EXP 158
38384: PUSH
38385: LD_EXP 158
38389: PPUSH
38390: LD_VAR 0 2
38394: PPUSH
38395: LD_INT 0
38397: PPUSH
38398: CALL_OW 1
38402: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
38403: LD_ADDR_EXP 159
38407: PUSH
38408: LD_EXP 159
38412: PPUSH
38413: LD_VAR 0 2
38417: PPUSH
38418: LD_INT 0
38420: PPUSH
38421: CALL_OW 1
38425: ST_TO_ADDR
// end ;
38426: GO 37327
38428: POP
38429: POP
// MC_InitSides ( ) ;
38430: CALL 38716 0 0
// MC_InitResearch ( ) ;
38434: CALL 38455 0 0
// CustomInitMacro ( ) ;
38438: CALL 471 0 0
// skirmish := true ;
38442: LD_ADDR_EXP 114
38446: PUSH
38447: LD_INT 1
38449: ST_TO_ADDR
// end ;
38450: LD_VAR 0 1
38454: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38455: LD_INT 0
38457: PPUSH
38458: PPUSH
38459: PPUSH
38460: PPUSH
38461: PPUSH
38462: PPUSH
// if not mc_bases then
38463: LD_EXP 116
38467: NOT
38468: IFFALSE 38472
// exit ;
38470: GO 38711
// for i = 1 to 8 do
38472: LD_ADDR_VAR 0 2
38476: PUSH
38477: DOUBLE
38478: LD_INT 1
38480: DEC
38481: ST_TO_ADDR
38482: LD_INT 8
38484: PUSH
38485: FOR_TO
38486: IFFALSE 38512
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38488: LD_ADDR_EXP 143
38492: PUSH
38493: LD_EXP 143
38497: PPUSH
38498: LD_VAR 0 2
38502: PPUSH
38503: EMPTY
38504: PPUSH
38505: CALL_OW 1
38509: ST_TO_ADDR
38510: GO 38485
38512: POP
38513: POP
// tmp := [ ] ;
38514: LD_ADDR_VAR 0 5
38518: PUSH
38519: EMPTY
38520: ST_TO_ADDR
// for i = 1 to mc_sides do
38521: LD_ADDR_VAR 0 2
38525: PUSH
38526: DOUBLE
38527: LD_INT 1
38529: DEC
38530: ST_TO_ADDR
38531: LD_EXP 142
38535: PUSH
38536: FOR_TO
38537: IFFALSE 38595
// if not mc_sides [ i ] in tmp then
38539: LD_EXP 142
38543: PUSH
38544: LD_VAR 0 2
38548: ARRAY
38549: PUSH
38550: LD_VAR 0 5
38554: IN
38555: NOT
38556: IFFALSE 38593
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38558: LD_ADDR_VAR 0 5
38562: PUSH
38563: LD_VAR 0 5
38567: PPUSH
38568: LD_VAR 0 5
38572: PUSH
38573: LD_INT 1
38575: PLUS
38576: PPUSH
38577: LD_EXP 142
38581: PUSH
38582: LD_VAR 0 2
38586: ARRAY
38587: PPUSH
38588: CALL_OW 2
38592: ST_TO_ADDR
38593: GO 38536
38595: POP
38596: POP
// if not tmp then
38597: LD_VAR 0 5
38601: NOT
38602: IFFALSE 38606
// exit ;
38604: GO 38711
// for j in tmp do
38606: LD_ADDR_VAR 0 3
38610: PUSH
38611: LD_VAR 0 5
38615: PUSH
38616: FOR_IN
38617: IFFALSE 38709
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38619: LD_ADDR_VAR 0 6
38623: PUSH
38624: LD_INT 22
38626: PUSH
38627: LD_VAR 0 3
38631: PUSH
38632: EMPTY
38633: LIST
38634: LIST
38635: PPUSH
38636: CALL_OW 69
38640: ST_TO_ADDR
// if not un then
38641: LD_VAR 0 6
38645: NOT
38646: IFFALSE 38650
// continue ;
38648: GO 38616
// nation := GetNation ( un [ 1 ] ) ;
38650: LD_ADDR_VAR 0 4
38654: PUSH
38655: LD_VAR 0 6
38659: PUSH
38660: LD_INT 1
38662: ARRAY
38663: PPUSH
38664: CALL_OW 248
38668: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38669: LD_ADDR_EXP 143
38673: PUSH
38674: LD_EXP 143
38678: PPUSH
38679: LD_VAR 0 3
38683: PPUSH
38684: LD_VAR 0 3
38688: PPUSH
38689: LD_VAR 0 4
38693: PPUSH
38694: LD_INT 1
38696: PPUSH
38697: CALL 65685 0 3
38701: PPUSH
38702: CALL_OW 1
38706: ST_TO_ADDR
// end ;
38707: GO 38616
38709: POP
38710: POP
// end ;
38711: LD_VAR 0 1
38715: RET
// export function MC_InitSides ( ) ; var i ; begin
38716: LD_INT 0
38718: PPUSH
38719: PPUSH
// if not mc_bases then
38720: LD_EXP 116
38724: NOT
38725: IFFALSE 38729
// exit ;
38727: GO 38803
// for i = 1 to mc_bases do
38729: LD_ADDR_VAR 0 2
38733: PUSH
38734: DOUBLE
38735: LD_INT 1
38737: DEC
38738: ST_TO_ADDR
38739: LD_EXP 116
38743: PUSH
38744: FOR_TO
38745: IFFALSE 38801
// if mc_bases [ i ] then
38747: LD_EXP 116
38751: PUSH
38752: LD_VAR 0 2
38756: ARRAY
38757: IFFALSE 38799
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38759: LD_ADDR_EXP 142
38763: PUSH
38764: LD_EXP 142
38768: PPUSH
38769: LD_VAR 0 2
38773: PPUSH
38774: LD_EXP 116
38778: PUSH
38779: LD_VAR 0 2
38783: ARRAY
38784: PUSH
38785: LD_INT 1
38787: ARRAY
38788: PPUSH
38789: CALL_OW 255
38793: PPUSH
38794: CALL_OW 1
38798: ST_TO_ADDR
38799: GO 38744
38801: POP
38802: POP
// end ;
38803: LD_VAR 0 1
38807: RET
// every 0 0$03 trigger skirmish do
38808: LD_EXP 114
38812: IFFALSE 38966
38814: GO 38816
38816: DISABLE
// begin enable ;
38817: ENABLE
// MC_CheckBuildings ( ) ;
38818: CALL 43464 0 0
// MC_CheckPeopleLife ( ) ;
38822: CALL 43625 0 0
// RaiseSailEvent ( 100 ) ;
38826: LD_INT 100
38828: PPUSH
38829: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38833: LD_INT 103
38835: PPUSH
38836: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38840: LD_INT 104
38842: PPUSH
38843: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38847: LD_INT 105
38849: PPUSH
38850: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38854: LD_INT 106
38856: PPUSH
38857: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38861: LD_INT 107
38863: PPUSH
38864: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38868: LD_INT 108
38870: PPUSH
38871: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38875: LD_INT 109
38877: PPUSH
38878: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38882: LD_INT 110
38884: PPUSH
38885: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38889: LD_INT 111
38891: PPUSH
38892: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
38896: LD_INT 112
38898: PPUSH
38899: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
38903: LD_INT 113
38905: PPUSH
38906: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
38910: LD_INT 120
38912: PPUSH
38913: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
38917: LD_INT 121
38919: PPUSH
38920: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
38924: LD_INT 122
38926: PPUSH
38927: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
38931: LD_INT 123
38933: PPUSH
38934: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
38938: LD_INT 124
38940: PPUSH
38941: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
38945: LD_INT 125
38947: PPUSH
38948: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
38952: LD_INT 126
38954: PPUSH
38955: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
38959: LD_INT 200
38961: PPUSH
38962: CALL_OW 427
// end ;
38966: END
// on SailEvent ( event ) do begin if event < 100 then
38967: LD_VAR 0 1
38971: PUSH
38972: LD_INT 100
38974: LESS
38975: IFFALSE 38986
// CustomEvent ( event ) ;
38977: LD_VAR 0 1
38981: PPUSH
38982: CALL 33446 0 1
// if event = 100 then
38986: LD_VAR 0 1
38990: PUSH
38991: LD_INT 100
38993: EQUAL
38994: IFFALSE 39000
// MC_ClassManager ( ) ;
38996: CALL 39392 0 0
// if event = 101 then
39000: LD_VAR 0 1
39004: PUSH
39005: LD_INT 101
39007: EQUAL
39008: IFFALSE 39014
// MC_RepairBuildings ( ) ;
39010: CALL 44210 0 0
// if event = 102 then
39014: LD_VAR 0 1
39018: PUSH
39019: LD_INT 102
39021: EQUAL
39022: IFFALSE 39028
// MC_Heal ( ) ;
39024: CALL 45117 0 0
// if event = 103 then
39028: LD_VAR 0 1
39032: PUSH
39033: LD_INT 103
39035: EQUAL
39036: IFFALSE 39042
// MC_Build ( ) ;
39038: CALL 45539 0 0
// if event = 104 then
39042: LD_VAR 0 1
39046: PUSH
39047: LD_INT 104
39049: EQUAL
39050: IFFALSE 39056
// MC_TurretWeapon ( ) ;
39052: CALL 47180 0 0
// if event = 105 then
39056: LD_VAR 0 1
39060: PUSH
39061: LD_INT 105
39063: EQUAL
39064: IFFALSE 39070
// MC_BuildUpgrade ( ) ;
39066: CALL 46731 0 0
// if event = 106 then
39070: LD_VAR 0 1
39074: PUSH
39075: LD_INT 106
39077: EQUAL
39078: IFFALSE 39084
// MC_PlantMines ( ) ;
39080: CALL 47610 0 0
// if event = 107 then
39084: LD_VAR 0 1
39088: PUSH
39089: LD_INT 107
39091: EQUAL
39092: IFFALSE 39098
// MC_CollectCrates ( ) ;
39094: CALL 48401 0 0
// if event = 108 then
39098: LD_VAR 0 1
39102: PUSH
39103: LD_INT 108
39105: EQUAL
39106: IFFALSE 39112
// MC_LinkRemoteControl ( ) ;
39108: CALL 50251 0 0
// if event = 109 then
39112: LD_VAR 0 1
39116: PUSH
39117: LD_INT 109
39119: EQUAL
39120: IFFALSE 39126
// MC_ProduceVehicle ( ) ;
39122: CALL 50432 0 0
// if event = 110 then
39126: LD_VAR 0 1
39130: PUSH
39131: LD_INT 110
39133: EQUAL
39134: IFFALSE 39140
// MC_SendAttack ( ) ;
39136: CALL 50898 0 0
// if event = 111 then
39140: LD_VAR 0 1
39144: PUSH
39145: LD_INT 111
39147: EQUAL
39148: IFFALSE 39154
// MC_Defend ( ) ;
39150: CALL 51006 0 0
// if event = 112 then
39154: LD_VAR 0 1
39158: PUSH
39159: LD_INT 112
39161: EQUAL
39162: IFFALSE 39168
// MC_Research ( ) ;
39164: CALL 51739 0 0
// if event = 113 then
39168: LD_VAR 0 1
39172: PUSH
39173: LD_INT 113
39175: EQUAL
39176: IFFALSE 39182
// MC_MinesTrigger ( ) ;
39178: CALL 52853 0 0
// if event = 120 then
39182: LD_VAR 0 1
39186: PUSH
39187: LD_INT 120
39189: EQUAL
39190: IFFALSE 39196
// MC_RepairVehicle ( ) ;
39192: CALL 52952 0 0
// if event = 121 then
39196: LD_VAR 0 1
39200: PUSH
39201: LD_INT 121
39203: EQUAL
39204: IFFALSE 39210
// MC_TameApe ( ) ;
39206: CALL 53693 0 0
// if event = 122 then
39210: LD_VAR 0 1
39214: PUSH
39215: LD_INT 122
39217: EQUAL
39218: IFFALSE 39224
// MC_ChangeApeClass ( ) ;
39220: CALL 54522 0 0
// if event = 123 then
39224: LD_VAR 0 1
39228: PUSH
39229: LD_INT 123
39231: EQUAL
39232: IFFALSE 39238
// MC_Bazooka ( ) ;
39234: CALL 55172 0 0
// if event = 124 then
39238: LD_VAR 0 1
39242: PUSH
39243: LD_INT 124
39245: EQUAL
39246: IFFALSE 39252
// MC_TeleportExit ( ) ;
39248: CALL 55370 0 0
// if event = 125 then
39252: LD_VAR 0 1
39256: PUSH
39257: LD_INT 125
39259: EQUAL
39260: IFFALSE 39266
// MC_Deposits ( ) ;
39262: CALL 56017 0 0
// if event = 126 then
39266: LD_VAR 0 1
39270: PUSH
39271: LD_INT 126
39273: EQUAL
39274: IFFALSE 39280
// MC_RemoteDriver ( ) ;
39276: CALL 56642 0 0
// if event = 200 then
39280: LD_VAR 0 1
39284: PUSH
39285: LD_INT 200
39287: EQUAL
39288: IFFALSE 39294
// MC_Idle ( ) ;
39290: CALL 58591 0 0
// end ;
39294: PPOPN 1
39296: END
// export function MC_Reset ( base , tag ) ; var i ; begin
39297: LD_INT 0
39299: PPUSH
39300: PPUSH
// if not mc_bases [ base ] or not tag then
39301: LD_EXP 116
39305: PUSH
39306: LD_VAR 0 1
39310: ARRAY
39311: NOT
39312: PUSH
39313: LD_VAR 0 2
39317: NOT
39318: OR
39319: IFFALSE 39323
// exit ;
39321: GO 39387
// for i in mc_bases [ base ] union mc_ape [ base ] do
39323: LD_ADDR_VAR 0 4
39327: PUSH
39328: LD_EXP 116
39332: PUSH
39333: LD_VAR 0 1
39337: ARRAY
39338: PUSH
39339: LD_EXP 145
39343: PUSH
39344: LD_VAR 0 1
39348: ARRAY
39349: UNION
39350: PUSH
39351: FOR_IN
39352: IFFALSE 39385
// if GetTag ( i ) = tag then
39354: LD_VAR 0 4
39358: PPUSH
39359: CALL_OW 110
39363: PUSH
39364: LD_VAR 0 2
39368: EQUAL
39369: IFFALSE 39383
// SetTag ( i , 0 ) ;
39371: LD_VAR 0 4
39375: PPUSH
39376: LD_INT 0
39378: PPUSH
39379: CALL_OW 109
39383: GO 39351
39385: POP
39386: POP
// end ;
39387: LD_VAR 0 3
39391: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39392: LD_INT 0
39394: PPUSH
39395: PPUSH
39396: PPUSH
39397: PPUSH
39398: PPUSH
39399: PPUSH
39400: PPUSH
39401: PPUSH
// if not mc_bases then
39402: LD_EXP 116
39406: NOT
39407: IFFALSE 39411
// exit ;
39409: GO 39869
// for i = 1 to mc_bases do
39411: LD_ADDR_VAR 0 2
39415: PUSH
39416: DOUBLE
39417: LD_INT 1
39419: DEC
39420: ST_TO_ADDR
39421: LD_EXP 116
39425: PUSH
39426: FOR_TO
39427: IFFALSE 39867
// begin tmp := MC_ClassCheckReq ( i ) ;
39429: LD_ADDR_VAR 0 4
39433: PUSH
39434: LD_VAR 0 2
39438: PPUSH
39439: CALL 39874 0 1
39443: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39444: LD_ADDR_EXP 157
39448: PUSH
39449: LD_EXP 157
39453: PPUSH
39454: LD_VAR 0 2
39458: PPUSH
39459: LD_VAR 0 4
39463: PPUSH
39464: CALL_OW 1
39468: ST_TO_ADDR
// if not tmp then
39469: LD_VAR 0 4
39473: NOT
39474: IFFALSE 39478
// continue ;
39476: GO 39426
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39478: LD_ADDR_VAR 0 6
39482: PUSH
39483: LD_EXP 116
39487: PUSH
39488: LD_VAR 0 2
39492: ARRAY
39493: PPUSH
39494: LD_INT 2
39496: PUSH
39497: LD_INT 30
39499: PUSH
39500: LD_INT 4
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: PUSH
39507: LD_INT 30
39509: PUSH
39510: LD_INT 5
39512: PUSH
39513: EMPTY
39514: LIST
39515: LIST
39516: PUSH
39517: EMPTY
39518: LIST
39519: LIST
39520: LIST
39521: PPUSH
39522: CALL_OW 72
39526: PUSH
39527: LD_EXP 116
39531: PUSH
39532: LD_VAR 0 2
39536: ARRAY
39537: PPUSH
39538: LD_INT 2
39540: PUSH
39541: LD_INT 30
39543: PUSH
39544: LD_INT 0
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: PUSH
39551: LD_INT 30
39553: PUSH
39554: LD_INT 1
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: EMPTY
39562: LIST
39563: LIST
39564: LIST
39565: PPUSH
39566: CALL_OW 72
39570: PUSH
39571: LD_EXP 116
39575: PUSH
39576: LD_VAR 0 2
39580: ARRAY
39581: PPUSH
39582: LD_INT 30
39584: PUSH
39585: LD_INT 3
39587: PUSH
39588: EMPTY
39589: LIST
39590: LIST
39591: PPUSH
39592: CALL_OW 72
39596: PUSH
39597: LD_EXP 116
39601: PUSH
39602: LD_VAR 0 2
39606: ARRAY
39607: PPUSH
39608: LD_INT 2
39610: PUSH
39611: LD_INT 30
39613: PUSH
39614: LD_INT 6
39616: PUSH
39617: EMPTY
39618: LIST
39619: LIST
39620: PUSH
39621: LD_INT 30
39623: PUSH
39624: LD_INT 7
39626: PUSH
39627: EMPTY
39628: LIST
39629: LIST
39630: PUSH
39631: LD_INT 30
39633: PUSH
39634: LD_INT 8
39636: PUSH
39637: EMPTY
39638: LIST
39639: LIST
39640: PUSH
39641: EMPTY
39642: LIST
39643: LIST
39644: LIST
39645: LIST
39646: PPUSH
39647: CALL_OW 72
39651: PUSH
39652: EMPTY
39653: LIST
39654: LIST
39655: LIST
39656: LIST
39657: ST_TO_ADDR
// for j = 1 to 4 do
39658: LD_ADDR_VAR 0 3
39662: PUSH
39663: DOUBLE
39664: LD_INT 1
39666: DEC
39667: ST_TO_ADDR
39668: LD_INT 4
39670: PUSH
39671: FOR_TO
39672: IFFALSE 39863
// begin if not tmp [ j ] then
39674: LD_VAR 0 4
39678: PUSH
39679: LD_VAR 0 3
39683: ARRAY
39684: NOT
39685: IFFALSE 39689
// continue ;
39687: GO 39671
// for p in tmp [ j ] do
39689: LD_ADDR_VAR 0 5
39693: PUSH
39694: LD_VAR 0 4
39698: PUSH
39699: LD_VAR 0 3
39703: ARRAY
39704: PUSH
39705: FOR_IN
39706: IFFALSE 39859
// begin if not b [ j ] then
39708: LD_VAR 0 6
39712: PUSH
39713: LD_VAR 0 3
39717: ARRAY
39718: NOT
39719: IFFALSE 39723
// break ;
39721: GO 39859
// e := 0 ;
39723: LD_ADDR_VAR 0 7
39727: PUSH
39728: LD_INT 0
39730: ST_TO_ADDR
// for k in b [ j ] do
39731: LD_ADDR_VAR 0 8
39735: PUSH
39736: LD_VAR 0 6
39740: PUSH
39741: LD_VAR 0 3
39745: ARRAY
39746: PUSH
39747: FOR_IN
39748: IFFALSE 39775
// if IsNotFull ( k ) then
39750: LD_VAR 0 8
39754: PPUSH
39755: CALL 67838 0 1
39759: IFFALSE 39773
// begin e := k ;
39761: LD_ADDR_VAR 0 7
39765: PUSH
39766: LD_VAR 0 8
39770: ST_TO_ADDR
// break ;
39771: GO 39775
// end ;
39773: GO 39747
39775: POP
39776: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39777: LD_VAR 0 7
39781: PUSH
39782: LD_VAR 0 5
39786: PPUSH
39787: LD_VAR 0 7
39791: PPUSH
39792: CALL 101002 0 2
39796: NOT
39797: AND
39798: IFFALSE 39857
// begin if IsInUnit ( p ) then
39800: LD_VAR 0 5
39804: PPUSH
39805: CALL_OW 310
39809: IFFALSE 39820
// ComExitBuilding ( p ) ;
39811: LD_VAR 0 5
39815: PPUSH
39816: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39820: LD_VAR 0 5
39824: PPUSH
39825: LD_VAR 0 7
39829: PPUSH
39830: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39834: LD_VAR 0 5
39838: PPUSH
39839: LD_VAR 0 3
39843: PPUSH
39844: CALL_OW 183
// AddComExitBuilding ( p ) ;
39848: LD_VAR 0 5
39852: PPUSH
39853: CALL_OW 182
// end ; end ;
39857: GO 39705
39859: POP
39860: POP
// end ;
39861: GO 39671
39863: POP
39864: POP
// end ;
39865: GO 39426
39867: POP
39868: POP
// end ;
39869: LD_VAR 0 1
39873: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39874: LD_INT 0
39876: PPUSH
39877: PPUSH
39878: PPUSH
39879: PPUSH
39880: PPUSH
39881: PPUSH
39882: PPUSH
39883: PPUSH
39884: PPUSH
39885: PPUSH
39886: PPUSH
39887: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39888: LD_VAR 0 1
39892: NOT
39893: PUSH
39894: LD_EXP 116
39898: PUSH
39899: LD_VAR 0 1
39903: ARRAY
39904: NOT
39905: OR
39906: PUSH
39907: LD_EXP 116
39911: PUSH
39912: LD_VAR 0 1
39916: ARRAY
39917: PPUSH
39918: LD_INT 2
39920: PUSH
39921: LD_INT 30
39923: PUSH
39924: LD_INT 0
39926: PUSH
39927: EMPTY
39928: LIST
39929: LIST
39930: PUSH
39931: LD_INT 30
39933: PUSH
39934: LD_INT 1
39936: PUSH
39937: EMPTY
39938: LIST
39939: LIST
39940: PUSH
39941: EMPTY
39942: LIST
39943: LIST
39944: LIST
39945: PPUSH
39946: CALL_OW 72
39950: NOT
39951: OR
39952: IFFALSE 39956
// exit ;
39954: GO 43459
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39956: LD_ADDR_VAR 0 4
39960: PUSH
39961: LD_EXP 116
39965: PUSH
39966: LD_VAR 0 1
39970: ARRAY
39971: PPUSH
39972: LD_INT 2
39974: PUSH
39975: LD_INT 25
39977: PUSH
39978: LD_INT 1
39980: PUSH
39981: EMPTY
39982: LIST
39983: LIST
39984: PUSH
39985: LD_INT 25
39987: PUSH
39988: LD_INT 2
39990: PUSH
39991: EMPTY
39992: LIST
39993: LIST
39994: PUSH
39995: LD_INT 25
39997: PUSH
39998: LD_INT 3
40000: PUSH
40001: EMPTY
40002: LIST
40003: LIST
40004: PUSH
40005: LD_INT 25
40007: PUSH
40008: LD_INT 4
40010: PUSH
40011: EMPTY
40012: LIST
40013: LIST
40014: PUSH
40015: LD_INT 25
40017: PUSH
40018: LD_INT 5
40020: PUSH
40021: EMPTY
40022: LIST
40023: LIST
40024: PUSH
40025: LD_INT 25
40027: PUSH
40028: LD_INT 8
40030: PUSH
40031: EMPTY
40032: LIST
40033: LIST
40034: PUSH
40035: LD_INT 25
40037: PUSH
40038: LD_INT 9
40040: PUSH
40041: EMPTY
40042: LIST
40043: LIST
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: LIST
40049: LIST
40050: LIST
40051: LIST
40052: LIST
40053: LIST
40054: PPUSH
40055: CALL_OW 72
40059: ST_TO_ADDR
// if not tmp then
40060: LD_VAR 0 4
40064: NOT
40065: IFFALSE 40069
// exit ;
40067: GO 43459
// for i in tmp do
40069: LD_ADDR_VAR 0 3
40073: PUSH
40074: LD_VAR 0 4
40078: PUSH
40079: FOR_IN
40080: IFFALSE 40111
// if GetTag ( i ) then
40082: LD_VAR 0 3
40086: PPUSH
40087: CALL_OW 110
40091: IFFALSE 40109
// tmp := tmp diff i ;
40093: LD_ADDR_VAR 0 4
40097: PUSH
40098: LD_VAR 0 4
40102: PUSH
40103: LD_VAR 0 3
40107: DIFF
40108: ST_TO_ADDR
40109: GO 40079
40111: POP
40112: POP
// if not tmp then
40113: LD_VAR 0 4
40117: NOT
40118: IFFALSE 40122
// exit ;
40120: GO 43459
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40122: LD_ADDR_VAR 0 5
40126: PUSH
40127: LD_EXP 116
40131: PUSH
40132: LD_VAR 0 1
40136: ARRAY
40137: PPUSH
40138: LD_INT 2
40140: PUSH
40141: LD_INT 25
40143: PUSH
40144: LD_INT 1
40146: PUSH
40147: EMPTY
40148: LIST
40149: LIST
40150: PUSH
40151: LD_INT 25
40153: PUSH
40154: LD_INT 5
40156: PUSH
40157: EMPTY
40158: LIST
40159: LIST
40160: PUSH
40161: LD_INT 25
40163: PUSH
40164: LD_INT 8
40166: PUSH
40167: EMPTY
40168: LIST
40169: LIST
40170: PUSH
40171: LD_INT 25
40173: PUSH
40174: LD_INT 9
40176: PUSH
40177: EMPTY
40178: LIST
40179: LIST
40180: PUSH
40181: EMPTY
40182: LIST
40183: LIST
40184: LIST
40185: LIST
40186: LIST
40187: PPUSH
40188: CALL_OW 72
40192: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
40193: LD_ADDR_VAR 0 6
40197: PUSH
40198: LD_EXP 116
40202: PUSH
40203: LD_VAR 0 1
40207: ARRAY
40208: PPUSH
40209: LD_INT 25
40211: PUSH
40212: LD_INT 2
40214: PUSH
40215: EMPTY
40216: LIST
40217: LIST
40218: PPUSH
40219: CALL_OW 72
40223: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
40224: LD_ADDR_VAR 0 7
40228: PUSH
40229: LD_EXP 116
40233: PUSH
40234: LD_VAR 0 1
40238: ARRAY
40239: PPUSH
40240: LD_INT 25
40242: PUSH
40243: LD_INT 3
40245: PUSH
40246: EMPTY
40247: LIST
40248: LIST
40249: PPUSH
40250: CALL_OW 72
40254: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
40255: LD_ADDR_VAR 0 8
40259: PUSH
40260: LD_EXP 116
40264: PUSH
40265: LD_VAR 0 1
40269: ARRAY
40270: PPUSH
40271: LD_INT 25
40273: PUSH
40274: LD_INT 4
40276: PUSH
40277: EMPTY
40278: LIST
40279: LIST
40280: PUSH
40281: LD_INT 24
40283: PUSH
40284: LD_INT 251
40286: PUSH
40287: EMPTY
40288: LIST
40289: LIST
40290: PUSH
40291: EMPTY
40292: LIST
40293: LIST
40294: PPUSH
40295: CALL_OW 72
40299: ST_TO_ADDR
// if mc_is_defending [ base ] then
40300: LD_EXP 159
40304: PUSH
40305: LD_VAR 0 1
40309: ARRAY
40310: IFFALSE 40771
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
40312: LD_ADDR_EXP 158
40316: PUSH
40317: LD_EXP 158
40321: PPUSH
40322: LD_VAR 0 1
40326: PPUSH
40327: LD_INT 4
40329: PPUSH
40330: CALL_OW 1
40334: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40335: LD_ADDR_VAR 0 12
40339: PUSH
40340: LD_EXP 116
40344: PUSH
40345: LD_VAR 0 1
40349: ARRAY
40350: PPUSH
40351: LD_INT 2
40353: PUSH
40354: LD_INT 30
40356: PUSH
40357: LD_INT 4
40359: PUSH
40360: EMPTY
40361: LIST
40362: LIST
40363: PUSH
40364: LD_INT 30
40366: PUSH
40367: LD_INT 5
40369: PUSH
40370: EMPTY
40371: LIST
40372: LIST
40373: PUSH
40374: EMPTY
40375: LIST
40376: LIST
40377: LIST
40378: PPUSH
40379: CALL_OW 72
40383: ST_TO_ADDR
// if not b then
40384: LD_VAR 0 12
40388: NOT
40389: IFFALSE 40393
// exit ;
40391: GO 43459
// p := [ ] ;
40393: LD_ADDR_VAR 0 11
40397: PUSH
40398: EMPTY
40399: ST_TO_ADDR
// if sci >= 2 then
40400: LD_VAR 0 8
40404: PUSH
40405: LD_INT 2
40407: GREATEREQUAL
40408: IFFALSE 40439
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40410: LD_ADDR_VAR 0 8
40414: PUSH
40415: LD_VAR 0 8
40419: PUSH
40420: LD_INT 1
40422: ARRAY
40423: PUSH
40424: LD_VAR 0 8
40428: PUSH
40429: LD_INT 2
40431: ARRAY
40432: PUSH
40433: EMPTY
40434: LIST
40435: LIST
40436: ST_TO_ADDR
40437: GO 40500
// if sci = 1 then
40439: LD_VAR 0 8
40443: PUSH
40444: LD_INT 1
40446: EQUAL
40447: IFFALSE 40468
// sci := [ sci [ 1 ] ] else
40449: LD_ADDR_VAR 0 8
40453: PUSH
40454: LD_VAR 0 8
40458: PUSH
40459: LD_INT 1
40461: ARRAY
40462: PUSH
40463: EMPTY
40464: LIST
40465: ST_TO_ADDR
40466: GO 40500
// if sci = 0 then
40468: LD_VAR 0 8
40472: PUSH
40473: LD_INT 0
40475: EQUAL
40476: IFFALSE 40500
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40478: LD_ADDR_VAR 0 11
40482: PUSH
40483: LD_VAR 0 4
40487: PPUSH
40488: LD_INT 4
40490: PPUSH
40491: CALL 100865 0 2
40495: PUSH
40496: LD_INT 1
40498: ARRAY
40499: ST_TO_ADDR
// if eng > 4 then
40500: LD_VAR 0 6
40504: PUSH
40505: LD_INT 4
40507: GREATER
40508: IFFALSE 40554
// for i = eng downto 4 do
40510: LD_ADDR_VAR 0 3
40514: PUSH
40515: DOUBLE
40516: LD_VAR 0 6
40520: INC
40521: ST_TO_ADDR
40522: LD_INT 4
40524: PUSH
40525: FOR_DOWNTO
40526: IFFALSE 40552
// eng := eng diff eng [ i ] ;
40528: LD_ADDR_VAR 0 6
40532: PUSH
40533: LD_VAR 0 6
40537: PUSH
40538: LD_VAR 0 6
40542: PUSH
40543: LD_VAR 0 3
40547: ARRAY
40548: DIFF
40549: ST_TO_ADDR
40550: GO 40525
40552: POP
40553: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40554: LD_ADDR_VAR 0 4
40558: PUSH
40559: LD_VAR 0 4
40563: PUSH
40564: LD_VAR 0 5
40568: PUSH
40569: LD_VAR 0 6
40573: UNION
40574: PUSH
40575: LD_VAR 0 7
40579: UNION
40580: PUSH
40581: LD_VAR 0 8
40585: UNION
40586: DIFF
40587: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40588: LD_ADDR_VAR 0 13
40592: PUSH
40593: LD_EXP 116
40597: PUSH
40598: LD_VAR 0 1
40602: ARRAY
40603: PPUSH
40604: LD_INT 2
40606: PUSH
40607: LD_INT 30
40609: PUSH
40610: LD_INT 32
40612: PUSH
40613: EMPTY
40614: LIST
40615: LIST
40616: PUSH
40617: LD_INT 30
40619: PUSH
40620: LD_INT 31
40622: PUSH
40623: EMPTY
40624: LIST
40625: LIST
40626: PUSH
40627: EMPTY
40628: LIST
40629: LIST
40630: LIST
40631: PPUSH
40632: CALL_OW 72
40636: PUSH
40637: LD_EXP 116
40641: PUSH
40642: LD_VAR 0 1
40646: ARRAY
40647: PPUSH
40648: LD_INT 2
40650: PUSH
40651: LD_INT 30
40653: PUSH
40654: LD_INT 4
40656: PUSH
40657: EMPTY
40658: LIST
40659: LIST
40660: PUSH
40661: LD_INT 30
40663: PUSH
40664: LD_INT 5
40666: PUSH
40667: EMPTY
40668: LIST
40669: LIST
40670: PUSH
40671: EMPTY
40672: LIST
40673: LIST
40674: LIST
40675: PPUSH
40676: CALL_OW 72
40680: PUSH
40681: LD_INT 6
40683: MUL
40684: PLUS
40685: ST_TO_ADDR
// if bcount < tmp then
40686: LD_VAR 0 13
40690: PUSH
40691: LD_VAR 0 4
40695: LESS
40696: IFFALSE 40742
// for i = tmp downto bcount do
40698: LD_ADDR_VAR 0 3
40702: PUSH
40703: DOUBLE
40704: LD_VAR 0 4
40708: INC
40709: ST_TO_ADDR
40710: LD_VAR 0 13
40714: PUSH
40715: FOR_DOWNTO
40716: IFFALSE 40740
// tmp := Delete ( tmp , tmp ) ;
40718: LD_ADDR_VAR 0 4
40722: PUSH
40723: LD_VAR 0 4
40727: PPUSH
40728: LD_VAR 0 4
40732: PPUSH
40733: CALL_OW 3
40737: ST_TO_ADDR
40738: GO 40715
40740: POP
40741: POP
// result := [ tmp , 0 , 0 , p ] ;
40742: LD_ADDR_VAR 0 2
40746: PUSH
40747: LD_VAR 0 4
40751: PUSH
40752: LD_INT 0
40754: PUSH
40755: LD_INT 0
40757: PUSH
40758: LD_VAR 0 11
40762: PUSH
40763: EMPTY
40764: LIST
40765: LIST
40766: LIST
40767: LIST
40768: ST_TO_ADDR
// exit ;
40769: GO 43459
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40771: LD_EXP 116
40775: PUSH
40776: LD_VAR 0 1
40780: ARRAY
40781: PPUSH
40782: LD_INT 2
40784: PUSH
40785: LD_INT 30
40787: PUSH
40788: LD_INT 6
40790: PUSH
40791: EMPTY
40792: LIST
40793: LIST
40794: PUSH
40795: LD_INT 30
40797: PUSH
40798: LD_INT 7
40800: PUSH
40801: EMPTY
40802: LIST
40803: LIST
40804: PUSH
40805: LD_INT 30
40807: PUSH
40808: LD_INT 8
40810: PUSH
40811: EMPTY
40812: LIST
40813: LIST
40814: PUSH
40815: EMPTY
40816: LIST
40817: LIST
40818: LIST
40819: LIST
40820: PPUSH
40821: CALL_OW 72
40825: NOT
40826: PUSH
40827: LD_EXP 116
40831: PUSH
40832: LD_VAR 0 1
40836: ARRAY
40837: PPUSH
40838: LD_INT 30
40840: PUSH
40841: LD_INT 3
40843: PUSH
40844: EMPTY
40845: LIST
40846: LIST
40847: PPUSH
40848: CALL_OW 72
40852: NOT
40853: AND
40854: IFFALSE 40926
// begin if eng = tmp then
40856: LD_VAR 0 6
40860: PUSH
40861: LD_VAR 0 4
40865: EQUAL
40866: IFFALSE 40870
// exit ;
40868: GO 43459
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40870: LD_ADDR_EXP 158
40874: PUSH
40875: LD_EXP 158
40879: PPUSH
40880: LD_VAR 0 1
40884: PPUSH
40885: LD_INT 1
40887: PPUSH
40888: CALL_OW 1
40892: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
40893: LD_ADDR_VAR 0 2
40897: PUSH
40898: LD_INT 0
40900: PUSH
40901: LD_VAR 0 4
40905: PUSH
40906: LD_VAR 0 6
40910: DIFF
40911: PUSH
40912: LD_INT 0
40914: PUSH
40915: LD_INT 0
40917: PUSH
40918: EMPTY
40919: LIST
40920: LIST
40921: LIST
40922: LIST
40923: ST_TO_ADDR
// exit ;
40924: GO 43459
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40926: LD_EXP 143
40930: PUSH
40931: LD_EXP 142
40935: PUSH
40936: LD_VAR 0 1
40940: ARRAY
40941: ARRAY
40942: PUSH
40943: LD_EXP 116
40947: PUSH
40948: LD_VAR 0 1
40952: ARRAY
40953: PPUSH
40954: LD_INT 2
40956: PUSH
40957: LD_INT 30
40959: PUSH
40960: LD_INT 6
40962: PUSH
40963: EMPTY
40964: LIST
40965: LIST
40966: PUSH
40967: LD_INT 30
40969: PUSH
40970: LD_INT 7
40972: PUSH
40973: EMPTY
40974: LIST
40975: LIST
40976: PUSH
40977: LD_INT 30
40979: PUSH
40980: LD_INT 8
40982: PUSH
40983: EMPTY
40984: LIST
40985: LIST
40986: PUSH
40987: EMPTY
40988: LIST
40989: LIST
40990: LIST
40991: LIST
40992: PPUSH
40993: CALL_OW 72
40997: AND
40998: PUSH
40999: LD_EXP 116
41003: PUSH
41004: LD_VAR 0 1
41008: ARRAY
41009: PPUSH
41010: LD_INT 30
41012: PUSH
41013: LD_INT 3
41015: PUSH
41016: EMPTY
41017: LIST
41018: LIST
41019: PPUSH
41020: CALL_OW 72
41024: NOT
41025: AND
41026: IFFALSE 41240
// begin if sci >= 6 then
41028: LD_VAR 0 8
41032: PUSH
41033: LD_INT 6
41035: GREATEREQUAL
41036: IFFALSE 41040
// exit ;
41038: GO 43459
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
41040: LD_ADDR_EXP 158
41044: PUSH
41045: LD_EXP 158
41049: PPUSH
41050: LD_VAR 0 1
41054: PPUSH
41055: LD_INT 2
41057: PPUSH
41058: CALL_OW 1
41062: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
41063: LD_ADDR_VAR 0 9
41067: PUSH
41068: LD_VAR 0 4
41072: PUSH
41073: LD_VAR 0 8
41077: DIFF
41078: PPUSH
41079: LD_INT 4
41081: PPUSH
41082: CALL 100865 0 2
41086: ST_TO_ADDR
// p := [ ] ;
41087: LD_ADDR_VAR 0 11
41091: PUSH
41092: EMPTY
41093: ST_TO_ADDR
// if sci < 6 and sort > 6 then
41094: LD_VAR 0 8
41098: PUSH
41099: LD_INT 6
41101: LESS
41102: PUSH
41103: LD_VAR 0 9
41107: PUSH
41108: LD_INT 6
41110: GREATER
41111: AND
41112: IFFALSE 41193
// begin for i = 1 to 6 - sci do
41114: LD_ADDR_VAR 0 3
41118: PUSH
41119: DOUBLE
41120: LD_INT 1
41122: DEC
41123: ST_TO_ADDR
41124: LD_INT 6
41126: PUSH
41127: LD_VAR 0 8
41131: MINUS
41132: PUSH
41133: FOR_TO
41134: IFFALSE 41189
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
41136: LD_ADDR_VAR 0 11
41140: PUSH
41141: LD_VAR 0 11
41145: PPUSH
41146: LD_VAR 0 11
41150: PUSH
41151: LD_INT 1
41153: PLUS
41154: PPUSH
41155: LD_VAR 0 9
41159: PUSH
41160: LD_INT 1
41162: ARRAY
41163: PPUSH
41164: CALL_OW 2
41168: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
41169: LD_ADDR_VAR 0 9
41173: PUSH
41174: LD_VAR 0 9
41178: PPUSH
41179: LD_INT 1
41181: PPUSH
41182: CALL_OW 3
41186: ST_TO_ADDR
// end ;
41187: GO 41133
41189: POP
41190: POP
// end else
41191: GO 41213
// if sort then
41193: LD_VAR 0 9
41197: IFFALSE 41213
// p := sort [ 1 ] ;
41199: LD_ADDR_VAR 0 11
41203: PUSH
41204: LD_VAR 0 9
41208: PUSH
41209: LD_INT 1
41211: ARRAY
41212: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
41213: LD_ADDR_VAR 0 2
41217: PUSH
41218: LD_INT 0
41220: PUSH
41221: LD_INT 0
41223: PUSH
41224: LD_INT 0
41226: PUSH
41227: LD_VAR 0 11
41231: PUSH
41232: EMPTY
41233: LIST
41234: LIST
41235: LIST
41236: LIST
41237: ST_TO_ADDR
// exit ;
41238: GO 43459
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41240: LD_EXP 143
41244: PUSH
41245: LD_EXP 142
41249: PUSH
41250: LD_VAR 0 1
41254: ARRAY
41255: ARRAY
41256: PUSH
41257: LD_EXP 116
41261: PUSH
41262: LD_VAR 0 1
41266: ARRAY
41267: PPUSH
41268: LD_INT 2
41270: PUSH
41271: LD_INT 30
41273: PUSH
41274: LD_INT 6
41276: PUSH
41277: EMPTY
41278: LIST
41279: LIST
41280: PUSH
41281: LD_INT 30
41283: PUSH
41284: LD_INT 7
41286: PUSH
41287: EMPTY
41288: LIST
41289: LIST
41290: PUSH
41291: LD_INT 30
41293: PUSH
41294: LD_INT 8
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: PUSH
41301: EMPTY
41302: LIST
41303: LIST
41304: LIST
41305: LIST
41306: PPUSH
41307: CALL_OW 72
41311: AND
41312: PUSH
41313: LD_EXP 116
41317: PUSH
41318: LD_VAR 0 1
41322: ARRAY
41323: PPUSH
41324: LD_INT 30
41326: PUSH
41327: LD_INT 3
41329: PUSH
41330: EMPTY
41331: LIST
41332: LIST
41333: PPUSH
41334: CALL_OW 72
41338: AND
41339: IFFALSE 42073
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
41341: LD_ADDR_EXP 158
41345: PUSH
41346: LD_EXP 158
41350: PPUSH
41351: LD_VAR 0 1
41355: PPUSH
41356: LD_INT 3
41358: PPUSH
41359: CALL_OW 1
41363: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41364: LD_ADDR_VAR 0 2
41368: PUSH
41369: LD_INT 0
41371: PUSH
41372: LD_INT 0
41374: PUSH
41375: LD_INT 0
41377: PUSH
41378: LD_INT 0
41380: PUSH
41381: EMPTY
41382: LIST
41383: LIST
41384: LIST
41385: LIST
41386: ST_TO_ADDR
// if not eng then
41387: LD_VAR 0 6
41391: NOT
41392: IFFALSE 41455
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41394: LD_ADDR_VAR 0 11
41398: PUSH
41399: LD_VAR 0 4
41403: PPUSH
41404: LD_INT 2
41406: PPUSH
41407: CALL 100865 0 2
41411: PUSH
41412: LD_INT 1
41414: ARRAY
41415: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41416: LD_ADDR_VAR 0 2
41420: PUSH
41421: LD_VAR 0 2
41425: PPUSH
41426: LD_INT 2
41428: PPUSH
41429: LD_VAR 0 11
41433: PPUSH
41434: CALL_OW 1
41438: ST_TO_ADDR
// tmp := tmp diff p ;
41439: LD_ADDR_VAR 0 4
41443: PUSH
41444: LD_VAR 0 4
41448: PUSH
41449: LD_VAR 0 11
41453: DIFF
41454: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41455: LD_VAR 0 4
41459: PUSH
41460: LD_VAR 0 8
41464: PUSH
41465: LD_INT 6
41467: LESS
41468: AND
41469: IFFALSE 41657
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41471: LD_ADDR_VAR 0 9
41475: PUSH
41476: LD_VAR 0 4
41480: PUSH
41481: LD_VAR 0 8
41485: PUSH
41486: LD_VAR 0 7
41490: UNION
41491: DIFF
41492: PPUSH
41493: LD_INT 4
41495: PPUSH
41496: CALL 100865 0 2
41500: ST_TO_ADDR
// p := [ ] ;
41501: LD_ADDR_VAR 0 11
41505: PUSH
41506: EMPTY
41507: ST_TO_ADDR
// if sort then
41508: LD_VAR 0 9
41512: IFFALSE 41628
// for i = 1 to 6 - sci do
41514: LD_ADDR_VAR 0 3
41518: PUSH
41519: DOUBLE
41520: LD_INT 1
41522: DEC
41523: ST_TO_ADDR
41524: LD_INT 6
41526: PUSH
41527: LD_VAR 0 8
41531: MINUS
41532: PUSH
41533: FOR_TO
41534: IFFALSE 41626
// begin if i = sort then
41536: LD_VAR 0 3
41540: PUSH
41541: LD_VAR 0 9
41545: EQUAL
41546: IFFALSE 41550
// break ;
41548: GO 41626
// if GetClass ( i ) = 4 then
41550: LD_VAR 0 3
41554: PPUSH
41555: CALL_OW 257
41559: PUSH
41560: LD_INT 4
41562: EQUAL
41563: IFFALSE 41567
// continue ;
41565: GO 41533
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41567: LD_ADDR_VAR 0 11
41571: PUSH
41572: LD_VAR 0 11
41576: PPUSH
41577: LD_VAR 0 11
41581: PUSH
41582: LD_INT 1
41584: PLUS
41585: PPUSH
41586: LD_VAR 0 9
41590: PUSH
41591: LD_VAR 0 3
41595: ARRAY
41596: PPUSH
41597: CALL_OW 2
41601: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41602: LD_ADDR_VAR 0 4
41606: PUSH
41607: LD_VAR 0 4
41611: PUSH
41612: LD_VAR 0 9
41616: PUSH
41617: LD_VAR 0 3
41621: ARRAY
41622: DIFF
41623: ST_TO_ADDR
// end ;
41624: GO 41533
41626: POP
41627: POP
// if p then
41628: LD_VAR 0 11
41632: IFFALSE 41657
// result := Replace ( result , 4 , p ) ;
41634: LD_ADDR_VAR 0 2
41638: PUSH
41639: LD_VAR 0 2
41643: PPUSH
41644: LD_INT 4
41646: PPUSH
41647: LD_VAR 0 11
41651: PPUSH
41652: CALL_OW 1
41656: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41657: LD_VAR 0 4
41661: PUSH
41662: LD_VAR 0 7
41666: PUSH
41667: LD_INT 6
41669: LESS
41670: AND
41671: IFFALSE 41859
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41673: LD_ADDR_VAR 0 9
41677: PUSH
41678: LD_VAR 0 4
41682: PUSH
41683: LD_VAR 0 8
41687: PUSH
41688: LD_VAR 0 7
41692: UNION
41693: DIFF
41694: PPUSH
41695: LD_INT 3
41697: PPUSH
41698: CALL 100865 0 2
41702: ST_TO_ADDR
// p := [ ] ;
41703: LD_ADDR_VAR 0 11
41707: PUSH
41708: EMPTY
41709: ST_TO_ADDR
// if sort then
41710: LD_VAR 0 9
41714: IFFALSE 41830
// for i = 1 to 6 - mech do
41716: LD_ADDR_VAR 0 3
41720: PUSH
41721: DOUBLE
41722: LD_INT 1
41724: DEC
41725: ST_TO_ADDR
41726: LD_INT 6
41728: PUSH
41729: LD_VAR 0 7
41733: MINUS
41734: PUSH
41735: FOR_TO
41736: IFFALSE 41828
// begin if i = sort then
41738: LD_VAR 0 3
41742: PUSH
41743: LD_VAR 0 9
41747: EQUAL
41748: IFFALSE 41752
// break ;
41750: GO 41828
// if GetClass ( i ) = 3 then
41752: LD_VAR 0 3
41756: PPUSH
41757: CALL_OW 257
41761: PUSH
41762: LD_INT 3
41764: EQUAL
41765: IFFALSE 41769
// continue ;
41767: GO 41735
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41769: LD_ADDR_VAR 0 11
41773: PUSH
41774: LD_VAR 0 11
41778: PPUSH
41779: LD_VAR 0 11
41783: PUSH
41784: LD_INT 1
41786: PLUS
41787: PPUSH
41788: LD_VAR 0 9
41792: PUSH
41793: LD_VAR 0 3
41797: ARRAY
41798: PPUSH
41799: CALL_OW 2
41803: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41804: LD_ADDR_VAR 0 4
41808: PUSH
41809: LD_VAR 0 4
41813: PUSH
41814: LD_VAR 0 9
41818: PUSH
41819: LD_VAR 0 3
41823: ARRAY
41824: DIFF
41825: ST_TO_ADDR
// end ;
41826: GO 41735
41828: POP
41829: POP
// if p then
41830: LD_VAR 0 11
41834: IFFALSE 41859
// result := Replace ( result , 3 , p ) ;
41836: LD_ADDR_VAR 0 2
41840: PUSH
41841: LD_VAR 0 2
41845: PPUSH
41846: LD_INT 3
41848: PPUSH
41849: LD_VAR 0 11
41853: PPUSH
41854: CALL_OW 1
41858: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41859: LD_VAR 0 4
41863: PUSH
41864: LD_INT 6
41866: GREATER
41867: PUSH
41868: LD_VAR 0 6
41872: PUSH
41873: LD_INT 6
41875: LESS
41876: AND
41877: IFFALSE 42071
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41879: LD_ADDR_VAR 0 9
41883: PUSH
41884: LD_VAR 0 4
41888: PUSH
41889: LD_VAR 0 8
41893: PUSH
41894: LD_VAR 0 7
41898: UNION
41899: PUSH
41900: LD_VAR 0 6
41904: UNION
41905: DIFF
41906: PPUSH
41907: LD_INT 2
41909: PPUSH
41910: CALL 100865 0 2
41914: ST_TO_ADDR
// p := [ ] ;
41915: LD_ADDR_VAR 0 11
41919: PUSH
41920: EMPTY
41921: ST_TO_ADDR
// if sort then
41922: LD_VAR 0 9
41926: IFFALSE 42042
// for i = 1 to 6 - eng do
41928: LD_ADDR_VAR 0 3
41932: PUSH
41933: DOUBLE
41934: LD_INT 1
41936: DEC
41937: ST_TO_ADDR
41938: LD_INT 6
41940: PUSH
41941: LD_VAR 0 6
41945: MINUS
41946: PUSH
41947: FOR_TO
41948: IFFALSE 42040
// begin if i = sort then
41950: LD_VAR 0 3
41954: PUSH
41955: LD_VAR 0 9
41959: EQUAL
41960: IFFALSE 41964
// break ;
41962: GO 42040
// if GetClass ( i ) = 2 then
41964: LD_VAR 0 3
41968: PPUSH
41969: CALL_OW 257
41973: PUSH
41974: LD_INT 2
41976: EQUAL
41977: IFFALSE 41981
// continue ;
41979: GO 41947
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41981: LD_ADDR_VAR 0 11
41985: PUSH
41986: LD_VAR 0 11
41990: PPUSH
41991: LD_VAR 0 11
41995: PUSH
41996: LD_INT 1
41998: PLUS
41999: PPUSH
42000: LD_VAR 0 9
42004: PUSH
42005: LD_VAR 0 3
42009: ARRAY
42010: PPUSH
42011: CALL_OW 2
42015: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42016: LD_ADDR_VAR 0 4
42020: PUSH
42021: LD_VAR 0 4
42025: PUSH
42026: LD_VAR 0 9
42030: PUSH
42031: LD_VAR 0 3
42035: ARRAY
42036: DIFF
42037: ST_TO_ADDR
// end ;
42038: GO 41947
42040: POP
42041: POP
// if p then
42042: LD_VAR 0 11
42046: IFFALSE 42071
// result := Replace ( result , 2 , p ) ;
42048: LD_ADDR_VAR 0 2
42052: PUSH
42053: LD_VAR 0 2
42057: PPUSH
42058: LD_INT 2
42060: PPUSH
42061: LD_VAR 0 11
42065: PPUSH
42066: CALL_OW 1
42070: ST_TO_ADDR
// end ; exit ;
42071: GO 43459
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
42073: LD_EXP 143
42077: PUSH
42078: LD_EXP 142
42082: PUSH
42083: LD_VAR 0 1
42087: ARRAY
42088: ARRAY
42089: NOT
42090: PUSH
42091: LD_EXP 116
42095: PUSH
42096: LD_VAR 0 1
42100: ARRAY
42101: PPUSH
42102: LD_INT 30
42104: PUSH
42105: LD_INT 3
42107: PUSH
42108: EMPTY
42109: LIST
42110: LIST
42111: PPUSH
42112: CALL_OW 72
42116: AND
42117: PUSH
42118: LD_EXP 121
42122: PUSH
42123: LD_VAR 0 1
42127: ARRAY
42128: AND
42129: IFFALSE 42737
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
42131: LD_ADDR_EXP 158
42135: PUSH
42136: LD_EXP 158
42140: PPUSH
42141: LD_VAR 0 1
42145: PPUSH
42146: LD_INT 5
42148: PPUSH
42149: CALL_OW 1
42153: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42154: LD_ADDR_VAR 0 2
42158: PUSH
42159: LD_INT 0
42161: PUSH
42162: LD_INT 0
42164: PUSH
42165: LD_INT 0
42167: PUSH
42168: LD_INT 0
42170: PUSH
42171: EMPTY
42172: LIST
42173: LIST
42174: LIST
42175: LIST
42176: ST_TO_ADDR
// if sci > 1 then
42177: LD_VAR 0 8
42181: PUSH
42182: LD_INT 1
42184: GREATER
42185: IFFALSE 42213
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
42187: LD_ADDR_VAR 0 4
42191: PUSH
42192: LD_VAR 0 4
42196: PUSH
42197: LD_VAR 0 8
42201: PUSH
42202: LD_VAR 0 8
42206: PUSH
42207: LD_INT 1
42209: ARRAY
42210: DIFF
42211: DIFF
42212: ST_TO_ADDR
// if tmp and not sci then
42213: LD_VAR 0 4
42217: PUSH
42218: LD_VAR 0 8
42222: NOT
42223: AND
42224: IFFALSE 42293
// begin sort := SortBySkill ( tmp , 4 ) ;
42226: LD_ADDR_VAR 0 9
42230: PUSH
42231: LD_VAR 0 4
42235: PPUSH
42236: LD_INT 4
42238: PPUSH
42239: CALL 100865 0 2
42243: ST_TO_ADDR
// if sort then
42244: LD_VAR 0 9
42248: IFFALSE 42264
// p := sort [ 1 ] ;
42250: LD_ADDR_VAR 0 11
42254: PUSH
42255: LD_VAR 0 9
42259: PUSH
42260: LD_INT 1
42262: ARRAY
42263: ST_TO_ADDR
// if p then
42264: LD_VAR 0 11
42268: IFFALSE 42293
// result := Replace ( result , 4 , p ) ;
42270: LD_ADDR_VAR 0 2
42274: PUSH
42275: LD_VAR 0 2
42279: PPUSH
42280: LD_INT 4
42282: PPUSH
42283: LD_VAR 0 11
42287: PPUSH
42288: CALL_OW 1
42292: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42293: LD_ADDR_VAR 0 4
42297: PUSH
42298: LD_VAR 0 4
42302: PUSH
42303: LD_VAR 0 7
42307: DIFF
42308: ST_TO_ADDR
// if tmp and mech < 6 then
42309: LD_VAR 0 4
42313: PUSH
42314: LD_VAR 0 7
42318: PUSH
42319: LD_INT 6
42321: LESS
42322: AND
42323: IFFALSE 42511
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
42325: LD_ADDR_VAR 0 9
42329: PUSH
42330: LD_VAR 0 4
42334: PUSH
42335: LD_VAR 0 8
42339: PUSH
42340: LD_VAR 0 7
42344: UNION
42345: DIFF
42346: PPUSH
42347: LD_INT 3
42349: PPUSH
42350: CALL 100865 0 2
42354: ST_TO_ADDR
// p := [ ] ;
42355: LD_ADDR_VAR 0 11
42359: PUSH
42360: EMPTY
42361: ST_TO_ADDR
// if sort then
42362: LD_VAR 0 9
42366: IFFALSE 42482
// for i = 1 to 6 - mech do
42368: LD_ADDR_VAR 0 3
42372: PUSH
42373: DOUBLE
42374: LD_INT 1
42376: DEC
42377: ST_TO_ADDR
42378: LD_INT 6
42380: PUSH
42381: LD_VAR 0 7
42385: MINUS
42386: PUSH
42387: FOR_TO
42388: IFFALSE 42480
// begin if i = sort then
42390: LD_VAR 0 3
42394: PUSH
42395: LD_VAR 0 9
42399: EQUAL
42400: IFFALSE 42404
// break ;
42402: GO 42480
// if GetClass ( i ) = 3 then
42404: LD_VAR 0 3
42408: PPUSH
42409: CALL_OW 257
42413: PUSH
42414: LD_INT 3
42416: EQUAL
42417: IFFALSE 42421
// continue ;
42419: GO 42387
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42421: LD_ADDR_VAR 0 11
42425: PUSH
42426: LD_VAR 0 11
42430: PPUSH
42431: LD_VAR 0 11
42435: PUSH
42436: LD_INT 1
42438: PLUS
42439: PPUSH
42440: LD_VAR 0 9
42444: PUSH
42445: LD_VAR 0 3
42449: ARRAY
42450: PPUSH
42451: CALL_OW 2
42455: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42456: LD_ADDR_VAR 0 4
42460: PUSH
42461: LD_VAR 0 4
42465: PUSH
42466: LD_VAR 0 9
42470: PUSH
42471: LD_VAR 0 3
42475: ARRAY
42476: DIFF
42477: ST_TO_ADDR
// end ;
42478: GO 42387
42480: POP
42481: POP
// if p then
42482: LD_VAR 0 11
42486: IFFALSE 42511
// result := Replace ( result , 3 , p ) ;
42488: LD_ADDR_VAR 0 2
42492: PUSH
42493: LD_VAR 0 2
42497: PPUSH
42498: LD_INT 3
42500: PPUSH
42501: LD_VAR 0 11
42505: PPUSH
42506: CALL_OW 1
42510: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42511: LD_ADDR_VAR 0 4
42515: PUSH
42516: LD_VAR 0 4
42520: PUSH
42521: LD_VAR 0 6
42525: DIFF
42526: ST_TO_ADDR
// if tmp and eng < 6 then
42527: LD_VAR 0 4
42531: PUSH
42532: LD_VAR 0 6
42536: PUSH
42537: LD_INT 6
42539: LESS
42540: AND
42541: IFFALSE 42735
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42543: LD_ADDR_VAR 0 9
42547: PUSH
42548: LD_VAR 0 4
42552: PUSH
42553: LD_VAR 0 8
42557: PUSH
42558: LD_VAR 0 7
42562: UNION
42563: PUSH
42564: LD_VAR 0 6
42568: UNION
42569: DIFF
42570: PPUSH
42571: LD_INT 2
42573: PPUSH
42574: CALL 100865 0 2
42578: ST_TO_ADDR
// p := [ ] ;
42579: LD_ADDR_VAR 0 11
42583: PUSH
42584: EMPTY
42585: ST_TO_ADDR
// if sort then
42586: LD_VAR 0 9
42590: IFFALSE 42706
// for i = 1 to 6 - eng do
42592: LD_ADDR_VAR 0 3
42596: PUSH
42597: DOUBLE
42598: LD_INT 1
42600: DEC
42601: ST_TO_ADDR
42602: LD_INT 6
42604: PUSH
42605: LD_VAR 0 6
42609: MINUS
42610: PUSH
42611: FOR_TO
42612: IFFALSE 42704
// begin if i = sort then
42614: LD_VAR 0 3
42618: PUSH
42619: LD_VAR 0 9
42623: EQUAL
42624: IFFALSE 42628
// break ;
42626: GO 42704
// if GetClass ( i ) = 2 then
42628: LD_VAR 0 3
42632: PPUSH
42633: CALL_OW 257
42637: PUSH
42638: LD_INT 2
42640: EQUAL
42641: IFFALSE 42645
// continue ;
42643: GO 42611
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42645: LD_ADDR_VAR 0 11
42649: PUSH
42650: LD_VAR 0 11
42654: PPUSH
42655: LD_VAR 0 11
42659: PUSH
42660: LD_INT 1
42662: PLUS
42663: PPUSH
42664: LD_VAR 0 9
42668: PUSH
42669: LD_VAR 0 3
42673: ARRAY
42674: PPUSH
42675: CALL_OW 2
42679: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42680: LD_ADDR_VAR 0 4
42684: PUSH
42685: LD_VAR 0 4
42689: PUSH
42690: LD_VAR 0 9
42694: PUSH
42695: LD_VAR 0 3
42699: ARRAY
42700: DIFF
42701: ST_TO_ADDR
// end ;
42702: GO 42611
42704: POP
42705: POP
// if p then
42706: LD_VAR 0 11
42710: IFFALSE 42735
// result := Replace ( result , 2 , p ) ;
42712: LD_ADDR_VAR 0 2
42716: PUSH
42717: LD_VAR 0 2
42721: PPUSH
42722: LD_INT 2
42724: PPUSH
42725: LD_VAR 0 11
42729: PPUSH
42730: CALL_OW 1
42734: ST_TO_ADDR
// end ; exit ;
42735: GO 43459
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42737: LD_EXP 143
42741: PUSH
42742: LD_EXP 142
42746: PUSH
42747: LD_VAR 0 1
42751: ARRAY
42752: ARRAY
42753: NOT
42754: PUSH
42755: LD_EXP 116
42759: PUSH
42760: LD_VAR 0 1
42764: ARRAY
42765: PPUSH
42766: LD_INT 30
42768: PUSH
42769: LD_INT 3
42771: PUSH
42772: EMPTY
42773: LIST
42774: LIST
42775: PPUSH
42776: CALL_OW 72
42780: AND
42781: PUSH
42782: LD_EXP 121
42786: PUSH
42787: LD_VAR 0 1
42791: ARRAY
42792: NOT
42793: AND
42794: IFFALSE 43459
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42796: LD_ADDR_EXP 158
42800: PUSH
42801: LD_EXP 158
42805: PPUSH
42806: LD_VAR 0 1
42810: PPUSH
42811: LD_INT 6
42813: PPUSH
42814: CALL_OW 1
42818: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42819: LD_ADDR_VAR 0 2
42823: PUSH
42824: LD_INT 0
42826: PUSH
42827: LD_INT 0
42829: PUSH
42830: LD_INT 0
42832: PUSH
42833: LD_INT 0
42835: PUSH
42836: EMPTY
42837: LIST
42838: LIST
42839: LIST
42840: LIST
42841: ST_TO_ADDR
// if sci >= 1 then
42842: LD_VAR 0 8
42846: PUSH
42847: LD_INT 1
42849: GREATEREQUAL
42850: IFFALSE 42872
// tmp := tmp diff sci [ 1 ] ;
42852: LD_ADDR_VAR 0 4
42856: PUSH
42857: LD_VAR 0 4
42861: PUSH
42862: LD_VAR 0 8
42866: PUSH
42867: LD_INT 1
42869: ARRAY
42870: DIFF
42871: ST_TO_ADDR
// if tmp and not sci then
42872: LD_VAR 0 4
42876: PUSH
42877: LD_VAR 0 8
42881: NOT
42882: AND
42883: IFFALSE 42952
// begin sort := SortBySkill ( tmp , 4 ) ;
42885: LD_ADDR_VAR 0 9
42889: PUSH
42890: LD_VAR 0 4
42894: PPUSH
42895: LD_INT 4
42897: PPUSH
42898: CALL 100865 0 2
42902: ST_TO_ADDR
// if sort then
42903: LD_VAR 0 9
42907: IFFALSE 42923
// p := sort [ 1 ] ;
42909: LD_ADDR_VAR 0 11
42913: PUSH
42914: LD_VAR 0 9
42918: PUSH
42919: LD_INT 1
42921: ARRAY
42922: ST_TO_ADDR
// if p then
42923: LD_VAR 0 11
42927: IFFALSE 42952
// result := Replace ( result , 4 , p ) ;
42929: LD_ADDR_VAR 0 2
42933: PUSH
42934: LD_VAR 0 2
42938: PPUSH
42939: LD_INT 4
42941: PPUSH
42942: LD_VAR 0 11
42946: PPUSH
42947: CALL_OW 1
42951: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42952: LD_ADDR_VAR 0 4
42956: PUSH
42957: LD_VAR 0 4
42961: PUSH
42962: LD_VAR 0 7
42966: DIFF
42967: ST_TO_ADDR
// if tmp and mech < 6 then
42968: LD_VAR 0 4
42972: PUSH
42973: LD_VAR 0 7
42977: PUSH
42978: LD_INT 6
42980: LESS
42981: AND
42982: IFFALSE 43164
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
42984: LD_ADDR_VAR 0 9
42988: PUSH
42989: LD_VAR 0 4
42993: PUSH
42994: LD_VAR 0 7
42998: DIFF
42999: PPUSH
43000: LD_INT 3
43002: PPUSH
43003: CALL 100865 0 2
43007: ST_TO_ADDR
// p := [ ] ;
43008: LD_ADDR_VAR 0 11
43012: PUSH
43013: EMPTY
43014: ST_TO_ADDR
// if sort then
43015: LD_VAR 0 9
43019: IFFALSE 43135
// for i = 1 to 6 - mech do
43021: LD_ADDR_VAR 0 3
43025: PUSH
43026: DOUBLE
43027: LD_INT 1
43029: DEC
43030: ST_TO_ADDR
43031: LD_INT 6
43033: PUSH
43034: LD_VAR 0 7
43038: MINUS
43039: PUSH
43040: FOR_TO
43041: IFFALSE 43133
// begin if i = sort then
43043: LD_VAR 0 3
43047: PUSH
43048: LD_VAR 0 9
43052: EQUAL
43053: IFFALSE 43057
// break ;
43055: GO 43133
// if GetClass ( i ) = 3 then
43057: LD_VAR 0 3
43061: PPUSH
43062: CALL_OW 257
43066: PUSH
43067: LD_INT 3
43069: EQUAL
43070: IFFALSE 43074
// continue ;
43072: GO 43040
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43074: LD_ADDR_VAR 0 11
43078: PUSH
43079: LD_VAR 0 11
43083: PPUSH
43084: LD_VAR 0 11
43088: PUSH
43089: LD_INT 1
43091: PLUS
43092: PPUSH
43093: LD_VAR 0 9
43097: PUSH
43098: LD_VAR 0 3
43102: ARRAY
43103: PPUSH
43104: CALL_OW 2
43108: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43109: LD_ADDR_VAR 0 4
43113: PUSH
43114: LD_VAR 0 4
43118: PUSH
43119: LD_VAR 0 9
43123: PUSH
43124: LD_VAR 0 3
43128: ARRAY
43129: DIFF
43130: ST_TO_ADDR
// end ;
43131: GO 43040
43133: POP
43134: POP
// if p then
43135: LD_VAR 0 11
43139: IFFALSE 43164
// result := Replace ( result , 3 , p ) ;
43141: LD_ADDR_VAR 0 2
43145: PUSH
43146: LD_VAR 0 2
43150: PPUSH
43151: LD_INT 3
43153: PPUSH
43154: LD_VAR 0 11
43158: PPUSH
43159: CALL_OW 1
43163: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
43164: LD_ADDR_VAR 0 4
43168: PUSH
43169: LD_VAR 0 4
43173: PUSH
43174: LD_VAR 0 6
43178: DIFF
43179: ST_TO_ADDR
// if tmp and eng < 4 then
43180: LD_VAR 0 4
43184: PUSH
43185: LD_VAR 0 6
43189: PUSH
43190: LD_INT 4
43192: LESS
43193: AND
43194: IFFALSE 43384
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
43196: LD_ADDR_VAR 0 9
43200: PUSH
43201: LD_VAR 0 4
43205: PUSH
43206: LD_VAR 0 7
43210: PUSH
43211: LD_VAR 0 6
43215: UNION
43216: DIFF
43217: PPUSH
43218: LD_INT 2
43220: PPUSH
43221: CALL 100865 0 2
43225: ST_TO_ADDR
// p := [ ] ;
43226: LD_ADDR_VAR 0 11
43230: PUSH
43231: EMPTY
43232: ST_TO_ADDR
// if sort then
43233: LD_VAR 0 9
43237: IFFALSE 43353
// for i = 1 to 4 - eng do
43239: LD_ADDR_VAR 0 3
43243: PUSH
43244: DOUBLE
43245: LD_INT 1
43247: DEC
43248: ST_TO_ADDR
43249: LD_INT 4
43251: PUSH
43252: LD_VAR 0 6
43256: MINUS
43257: PUSH
43258: FOR_TO
43259: IFFALSE 43351
// begin if i = sort then
43261: LD_VAR 0 3
43265: PUSH
43266: LD_VAR 0 9
43270: EQUAL
43271: IFFALSE 43275
// break ;
43273: GO 43351
// if GetClass ( i ) = 2 then
43275: LD_VAR 0 3
43279: PPUSH
43280: CALL_OW 257
43284: PUSH
43285: LD_INT 2
43287: EQUAL
43288: IFFALSE 43292
// continue ;
43290: GO 43258
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43292: LD_ADDR_VAR 0 11
43296: PUSH
43297: LD_VAR 0 11
43301: PPUSH
43302: LD_VAR 0 11
43306: PUSH
43307: LD_INT 1
43309: PLUS
43310: PPUSH
43311: LD_VAR 0 9
43315: PUSH
43316: LD_VAR 0 3
43320: ARRAY
43321: PPUSH
43322: CALL_OW 2
43326: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43327: LD_ADDR_VAR 0 4
43331: PUSH
43332: LD_VAR 0 4
43336: PUSH
43337: LD_VAR 0 9
43341: PUSH
43342: LD_VAR 0 3
43346: ARRAY
43347: DIFF
43348: ST_TO_ADDR
// end ;
43349: GO 43258
43351: POP
43352: POP
// if p then
43353: LD_VAR 0 11
43357: IFFALSE 43382
// result := Replace ( result , 2 , p ) ;
43359: LD_ADDR_VAR 0 2
43363: PUSH
43364: LD_VAR 0 2
43368: PPUSH
43369: LD_INT 2
43371: PPUSH
43372: LD_VAR 0 11
43376: PPUSH
43377: CALL_OW 1
43381: ST_TO_ADDR
// end else
43382: GO 43428
// for i = eng downto 5 do
43384: LD_ADDR_VAR 0 3
43388: PUSH
43389: DOUBLE
43390: LD_VAR 0 6
43394: INC
43395: ST_TO_ADDR
43396: LD_INT 5
43398: PUSH
43399: FOR_DOWNTO
43400: IFFALSE 43426
// tmp := tmp union eng [ i ] ;
43402: LD_ADDR_VAR 0 4
43406: PUSH
43407: LD_VAR 0 4
43411: PUSH
43412: LD_VAR 0 6
43416: PUSH
43417: LD_VAR 0 3
43421: ARRAY
43422: UNION
43423: ST_TO_ADDR
43424: GO 43399
43426: POP
43427: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43428: LD_ADDR_VAR 0 2
43432: PUSH
43433: LD_VAR 0 2
43437: PPUSH
43438: LD_INT 1
43440: PPUSH
43441: LD_VAR 0 4
43445: PUSH
43446: LD_VAR 0 5
43450: DIFF
43451: PPUSH
43452: CALL_OW 1
43456: ST_TO_ADDR
// exit ;
43457: GO 43459
// end ; end ;
43459: LD_VAR 0 2
43463: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43464: LD_INT 0
43466: PPUSH
43467: PPUSH
43468: PPUSH
// if not mc_bases then
43469: LD_EXP 116
43473: NOT
43474: IFFALSE 43478
// exit ;
43476: GO 43620
// for i = 1 to mc_bases do
43478: LD_ADDR_VAR 0 2
43482: PUSH
43483: DOUBLE
43484: LD_INT 1
43486: DEC
43487: ST_TO_ADDR
43488: LD_EXP 116
43492: PUSH
43493: FOR_TO
43494: IFFALSE 43611
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43496: LD_ADDR_VAR 0 3
43500: PUSH
43501: LD_EXP 116
43505: PUSH
43506: LD_VAR 0 2
43510: ARRAY
43511: PPUSH
43512: LD_INT 21
43514: PUSH
43515: LD_INT 3
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: PUSH
43522: LD_INT 3
43524: PUSH
43525: LD_INT 2
43527: PUSH
43528: LD_INT 30
43530: PUSH
43531: LD_INT 29
43533: PUSH
43534: EMPTY
43535: LIST
43536: LIST
43537: PUSH
43538: LD_INT 30
43540: PUSH
43541: LD_INT 30
43543: PUSH
43544: EMPTY
43545: LIST
43546: LIST
43547: PUSH
43548: EMPTY
43549: LIST
43550: LIST
43551: LIST
43552: PUSH
43553: EMPTY
43554: LIST
43555: LIST
43556: PUSH
43557: LD_INT 3
43559: PUSH
43560: LD_INT 24
43562: PUSH
43563: LD_INT 1000
43565: PUSH
43566: EMPTY
43567: LIST
43568: LIST
43569: PUSH
43570: EMPTY
43571: LIST
43572: LIST
43573: PUSH
43574: EMPTY
43575: LIST
43576: LIST
43577: LIST
43578: PPUSH
43579: CALL_OW 72
43583: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43584: LD_ADDR_EXP 117
43588: PUSH
43589: LD_EXP 117
43593: PPUSH
43594: LD_VAR 0 2
43598: PPUSH
43599: LD_VAR 0 3
43603: PPUSH
43604: CALL_OW 1
43608: ST_TO_ADDR
// end ;
43609: GO 43493
43611: POP
43612: POP
// RaiseSailEvent ( 101 ) ;
43613: LD_INT 101
43615: PPUSH
43616: CALL_OW 427
// end ;
43620: LD_VAR 0 1
43624: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43625: LD_INT 0
43627: PPUSH
43628: PPUSH
43629: PPUSH
43630: PPUSH
43631: PPUSH
43632: PPUSH
43633: PPUSH
// if not mc_bases then
43634: LD_EXP 116
43638: NOT
43639: IFFALSE 43643
// exit ;
43641: GO 44205
// for i = 1 to mc_bases do
43643: LD_ADDR_VAR 0 2
43647: PUSH
43648: DOUBLE
43649: LD_INT 1
43651: DEC
43652: ST_TO_ADDR
43653: LD_EXP 116
43657: PUSH
43658: FOR_TO
43659: IFFALSE 44196
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
43661: LD_ADDR_VAR 0 5
43665: PUSH
43666: LD_EXP 116
43670: PUSH
43671: LD_VAR 0 2
43675: ARRAY
43676: PUSH
43677: LD_EXP 145
43681: PUSH
43682: LD_VAR 0 2
43686: ARRAY
43687: UNION
43688: PPUSH
43689: LD_INT 21
43691: PUSH
43692: LD_INT 1
43694: PUSH
43695: EMPTY
43696: LIST
43697: LIST
43698: PUSH
43699: LD_INT 1
43701: PUSH
43702: LD_INT 3
43704: PUSH
43705: LD_INT 54
43707: PUSH
43708: EMPTY
43709: LIST
43710: PUSH
43711: EMPTY
43712: LIST
43713: LIST
43714: PUSH
43715: LD_INT 3
43717: PUSH
43718: LD_INT 24
43720: PUSH
43721: LD_INT 1000
43723: PUSH
43724: EMPTY
43725: LIST
43726: LIST
43727: PUSH
43728: EMPTY
43729: LIST
43730: LIST
43731: PUSH
43732: EMPTY
43733: LIST
43734: LIST
43735: LIST
43736: PUSH
43737: EMPTY
43738: LIST
43739: LIST
43740: PPUSH
43741: CALL_OW 72
43745: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43746: LD_ADDR_VAR 0 6
43750: PUSH
43751: LD_EXP 116
43755: PUSH
43756: LD_VAR 0 2
43760: ARRAY
43761: PPUSH
43762: LD_INT 21
43764: PUSH
43765: LD_INT 1
43767: PUSH
43768: EMPTY
43769: LIST
43770: LIST
43771: PUSH
43772: LD_INT 1
43774: PUSH
43775: LD_INT 3
43777: PUSH
43778: LD_INT 54
43780: PUSH
43781: EMPTY
43782: LIST
43783: PUSH
43784: EMPTY
43785: LIST
43786: LIST
43787: PUSH
43788: LD_INT 3
43790: PUSH
43791: LD_INT 24
43793: PUSH
43794: LD_INT 250
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: PUSH
43801: EMPTY
43802: LIST
43803: LIST
43804: PUSH
43805: EMPTY
43806: LIST
43807: LIST
43808: LIST
43809: PUSH
43810: EMPTY
43811: LIST
43812: LIST
43813: PPUSH
43814: CALL_OW 72
43818: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43819: LD_ADDR_VAR 0 7
43823: PUSH
43824: LD_VAR 0 5
43828: PUSH
43829: LD_VAR 0 6
43833: DIFF
43834: ST_TO_ADDR
// if not need_heal_1 then
43835: LD_VAR 0 6
43839: NOT
43840: IFFALSE 43873
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43842: LD_ADDR_EXP 119
43846: PUSH
43847: LD_EXP 119
43851: PPUSH
43852: LD_VAR 0 2
43856: PUSH
43857: LD_INT 1
43859: PUSH
43860: EMPTY
43861: LIST
43862: LIST
43863: PPUSH
43864: EMPTY
43865: PPUSH
43866: CALL 70608 0 3
43870: ST_TO_ADDR
43871: GO 43943
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43873: LD_ADDR_EXP 119
43877: PUSH
43878: LD_EXP 119
43882: PPUSH
43883: LD_VAR 0 2
43887: PUSH
43888: LD_INT 1
43890: PUSH
43891: EMPTY
43892: LIST
43893: LIST
43894: PPUSH
43895: LD_EXP 119
43899: PUSH
43900: LD_VAR 0 2
43904: ARRAY
43905: PUSH
43906: LD_INT 1
43908: ARRAY
43909: PPUSH
43910: LD_INT 3
43912: PUSH
43913: LD_INT 24
43915: PUSH
43916: LD_INT 1000
43918: PUSH
43919: EMPTY
43920: LIST
43921: LIST
43922: PUSH
43923: EMPTY
43924: LIST
43925: LIST
43926: PPUSH
43927: CALL_OW 72
43931: PUSH
43932: LD_VAR 0 6
43936: UNION
43937: PPUSH
43938: CALL 70608 0 3
43942: ST_TO_ADDR
// if not need_heal_2 then
43943: LD_VAR 0 7
43947: NOT
43948: IFFALSE 43981
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
43950: LD_ADDR_EXP 119
43954: PUSH
43955: LD_EXP 119
43959: PPUSH
43960: LD_VAR 0 2
43964: PUSH
43965: LD_INT 2
43967: PUSH
43968: EMPTY
43969: LIST
43970: LIST
43971: PPUSH
43972: EMPTY
43973: PPUSH
43974: CALL 70608 0 3
43978: ST_TO_ADDR
43979: GO 44013
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
43981: LD_ADDR_EXP 119
43985: PUSH
43986: LD_EXP 119
43990: PPUSH
43991: LD_VAR 0 2
43995: PUSH
43996: LD_INT 2
43998: PUSH
43999: EMPTY
44000: LIST
44001: LIST
44002: PPUSH
44003: LD_VAR 0 7
44007: PPUSH
44008: CALL 70608 0 3
44012: ST_TO_ADDR
// if need_heal_2 then
44013: LD_VAR 0 7
44017: IFFALSE 44178
// for j in need_heal_2 do
44019: LD_ADDR_VAR 0 3
44023: PUSH
44024: LD_VAR 0 7
44028: PUSH
44029: FOR_IN
44030: IFFALSE 44176
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44032: LD_ADDR_VAR 0 5
44036: PUSH
44037: LD_EXP 116
44041: PUSH
44042: LD_VAR 0 2
44046: ARRAY
44047: PPUSH
44048: LD_INT 2
44050: PUSH
44051: LD_INT 30
44053: PUSH
44054: LD_INT 6
44056: PUSH
44057: EMPTY
44058: LIST
44059: LIST
44060: PUSH
44061: LD_INT 30
44063: PUSH
44064: LD_INT 7
44066: PUSH
44067: EMPTY
44068: LIST
44069: LIST
44070: PUSH
44071: LD_INT 30
44073: PUSH
44074: LD_INT 8
44076: PUSH
44077: EMPTY
44078: LIST
44079: LIST
44080: PUSH
44081: LD_INT 30
44083: PUSH
44084: LD_INT 0
44086: PUSH
44087: EMPTY
44088: LIST
44089: LIST
44090: PUSH
44091: LD_INT 30
44093: PUSH
44094: LD_INT 1
44096: PUSH
44097: EMPTY
44098: LIST
44099: LIST
44100: PUSH
44101: EMPTY
44102: LIST
44103: LIST
44104: LIST
44105: LIST
44106: LIST
44107: LIST
44108: PPUSH
44109: CALL_OW 72
44113: ST_TO_ADDR
// if tmp then
44114: LD_VAR 0 5
44118: IFFALSE 44174
// begin k := NearestUnitToUnit ( tmp , j ) ;
44120: LD_ADDR_VAR 0 4
44124: PUSH
44125: LD_VAR 0 5
44129: PPUSH
44130: LD_VAR 0 3
44134: PPUSH
44135: CALL_OW 74
44139: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
44140: LD_VAR 0 3
44144: PPUSH
44145: LD_VAR 0 4
44149: PPUSH
44150: CALL_OW 296
44154: PUSH
44155: LD_INT 5
44157: GREATER
44158: IFFALSE 44174
// ComMoveToNearbyEntrance ( j , k ) ;
44160: LD_VAR 0 3
44164: PPUSH
44165: LD_VAR 0 4
44169: PPUSH
44170: CALL 103226 0 2
// end ; end ;
44174: GO 44029
44176: POP
44177: POP
// if not need_heal_1 and not need_heal_2 then
44178: LD_VAR 0 6
44182: NOT
44183: PUSH
44184: LD_VAR 0 7
44188: NOT
44189: AND
44190: IFFALSE 44194
// continue ;
44192: GO 43658
// end ;
44194: GO 43658
44196: POP
44197: POP
// RaiseSailEvent ( 102 ) ;
44198: LD_INT 102
44200: PPUSH
44201: CALL_OW 427
// end ;
44205: LD_VAR 0 1
44209: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
44210: LD_INT 0
44212: PPUSH
44213: PPUSH
44214: PPUSH
44215: PPUSH
44216: PPUSH
44217: PPUSH
44218: PPUSH
44219: PPUSH
// if not mc_bases then
44220: LD_EXP 116
44224: NOT
44225: IFFALSE 44229
// exit ;
44227: GO 45112
// for i = 1 to mc_bases do
44229: LD_ADDR_VAR 0 2
44233: PUSH
44234: DOUBLE
44235: LD_INT 1
44237: DEC
44238: ST_TO_ADDR
44239: LD_EXP 116
44243: PUSH
44244: FOR_TO
44245: IFFALSE 45110
// begin if not mc_building_need_repair [ i ] then
44247: LD_EXP 117
44251: PUSH
44252: LD_VAR 0 2
44256: ARRAY
44257: NOT
44258: IFFALSE 44445
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
44260: LD_ADDR_VAR 0 6
44264: PUSH
44265: LD_EXP 135
44269: PUSH
44270: LD_VAR 0 2
44274: ARRAY
44275: PPUSH
44276: LD_INT 3
44278: PUSH
44279: LD_INT 24
44281: PUSH
44282: LD_INT 1000
44284: PUSH
44285: EMPTY
44286: LIST
44287: LIST
44288: PUSH
44289: EMPTY
44290: LIST
44291: LIST
44292: PUSH
44293: LD_INT 2
44295: PUSH
44296: LD_INT 34
44298: PUSH
44299: LD_INT 13
44301: PUSH
44302: EMPTY
44303: LIST
44304: LIST
44305: PUSH
44306: LD_INT 34
44308: PUSH
44309: LD_INT 52
44311: PUSH
44312: EMPTY
44313: LIST
44314: LIST
44315: PUSH
44316: LD_INT 34
44318: PUSH
44319: LD_EXP 101
44323: PUSH
44324: EMPTY
44325: LIST
44326: LIST
44327: PUSH
44328: EMPTY
44329: LIST
44330: LIST
44331: LIST
44332: LIST
44333: PUSH
44334: EMPTY
44335: LIST
44336: LIST
44337: PPUSH
44338: CALL_OW 72
44342: ST_TO_ADDR
// if cranes then
44343: LD_VAR 0 6
44347: IFFALSE 44409
// for j in cranes do
44349: LD_ADDR_VAR 0 3
44353: PUSH
44354: LD_VAR 0 6
44358: PUSH
44359: FOR_IN
44360: IFFALSE 44407
// if not IsInArea ( j , mc_parking [ i ] ) then
44362: LD_VAR 0 3
44366: PPUSH
44367: LD_EXP 140
44371: PUSH
44372: LD_VAR 0 2
44376: ARRAY
44377: PPUSH
44378: CALL_OW 308
44382: NOT
44383: IFFALSE 44405
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44385: LD_VAR 0 3
44389: PPUSH
44390: LD_EXP 140
44394: PUSH
44395: LD_VAR 0 2
44399: ARRAY
44400: PPUSH
44401: CALL_OW 113
44405: GO 44359
44407: POP
44408: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44409: LD_ADDR_EXP 118
44413: PUSH
44414: LD_EXP 118
44418: PPUSH
44419: LD_VAR 0 2
44423: PPUSH
44424: EMPTY
44425: PPUSH
44426: CALL_OW 1
44430: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44431: LD_VAR 0 2
44435: PPUSH
44436: LD_INT 101
44438: PPUSH
44439: CALL 39297 0 2
// continue ;
44443: GO 44244
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44445: LD_ADDR_EXP 122
44449: PUSH
44450: LD_EXP 122
44454: PPUSH
44455: LD_VAR 0 2
44459: PPUSH
44460: EMPTY
44461: PPUSH
44462: CALL_OW 1
44466: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44467: LD_VAR 0 2
44471: PPUSH
44472: LD_INT 103
44474: PPUSH
44475: CALL 39297 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
44479: LD_ADDR_VAR 0 5
44483: PUSH
44484: LD_EXP 116
44488: PUSH
44489: LD_VAR 0 2
44493: ARRAY
44494: PUSH
44495: LD_EXP 145
44499: PUSH
44500: LD_VAR 0 2
44504: ARRAY
44505: UNION
44506: PPUSH
44507: LD_INT 2
44509: PUSH
44510: LD_INT 25
44512: PUSH
44513: LD_INT 2
44515: PUSH
44516: EMPTY
44517: LIST
44518: LIST
44519: PUSH
44520: LD_INT 25
44522: PUSH
44523: LD_INT 16
44525: PUSH
44526: EMPTY
44527: LIST
44528: LIST
44529: PUSH
44530: EMPTY
44531: LIST
44532: LIST
44533: LIST
44534: PUSH
44535: EMPTY
44536: LIST
44537: PPUSH
44538: CALL_OW 72
44542: ST_TO_ADDR
// if mc_need_heal [ i ] then
44543: LD_EXP 119
44547: PUSH
44548: LD_VAR 0 2
44552: ARRAY
44553: IFFALSE 44597
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
44555: LD_ADDR_VAR 0 5
44559: PUSH
44560: LD_VAR 0 5
44564: PUSH
44565: LD_EXP 119
44569: PUSH
44570: LD_VAR 0 2
44574: ARRAY
44575: PUSH
44576: LD_INT 1
44578: ARRAY
44579: PUSH
44580: LD_EXP 119
44584: PUSH
44585: LD_VAR 0 2
44589: ARRAY
44590: PUSH
44591: LD_INT 2
44593: ARRAY
44594: UNION
44595: DIFF
44596: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
44597: LD_ADDR_VAR 0 6
44601: PUSH
44602: LD_EXP 135
44606: PUSH
44607: LD_VAR 0 2
44611: ARRAY
44612: PPUSH
44613: LD_INT 2
44615: PUSH
44616: LD_INT 34
44618: PUSH
44619: LD_INT 13
44621: PUSH
44622: EMPTY
44623: LIST
44624: LIST
44625: PUSH
44626: LD_INT 34
44628: PUSH
44629: LD_INT 52
44631: PUSH
44632: EMPTY
44633: LIST
44634: LIST
44635: PUSH
44636: LD_INT 34
44638: PUSH
44639: LD_EXP 101
44643: PUSH
44644: EMPTY
44645: LIST
44646: LIST
44647: PUSH
44648: EMPTY
44649: LIST
44650: LIST
44651: LIST
44652: LIST
44653: PPUSH
44654: CALL_OW 72
44658: ST_TO_ADDR
// if cranes then
44659: LD_VAR 0 6
44663: IFFALSE 44799
// begin for j in cranes do
44665: LD_ADDR_VAR 0 3
44669: PUSH
44670: LD_VAR 0 6
44674: PUSH
44675: FOR_IN
44676: IFFALSE 44797
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
44678: LD_VAR 0 3
44682: PPUSH
44683: CALL_OW 256
44687: PUSH
44688: LD_INT 1000
44690: EQUAL
44691: PUSH
44692: LD_VAR 0 3
44696: PPUSH
44697: CALL_OW 314
44701: NOT
44702: AND
44703: IFFALSE 44737
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44705: LD_VAR 0 3
44709: PPUSH
44710: LD_EXP 117
44714: PUSH
44715: LD_VAR 0 2
44719: ARRAY
44720: PPUSH
44721: LD_VAR 0 3
44725: PPUSH
44726: CALL_OW 74
44730: PPUSH
44731: CALL_OW 130
44735: GO 44795
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44737: LD_VAR 0 3
44741: PPUSH
44742: CALL_OW 256
44746: PUSH
44747: LD_INT 500
44749: LESS
44750: PUSH
44751: LD_VAR 0 3
44755: PPUSH
44756: LD_EXP 140
44760: PUSH
44761: LD_VAR 0 2
44765: ARRAY
44766: PPUSH
44767: CALL_OW 308
44771: NOT
44772: AND
44773: IFFALSE 44795
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44775: LD_VAR 0 3
44779: PPUSH
44780: LD_EXP 140
44784: PUSH
44785: LD_VAR 0 2
44789: ARRAY
44790: PPUSH
44791: CALL_OW 113
// end ;
44795: GO 44675
44797: POP
44798: POP
// end ; if tmp > 3 then
44799: LD_VAR 0 5
44803: PUSH
44804: LD_INT 3
44806: GREATER
44807: IFFALSE 44827
// tmp := ShrinkArray ( tmp , 4 ) ;
44809: LD_ADDR_VAR 0 5
44813: PUSH
44814: LD_VAR 0 5
44818: PPUSH
44819: LD_INT 4
44821: PPUSH
44822: CALL 102674 0 2
44826: ST_TO_ADDR
// if not tmp then
44827: LD_VAR 0 5
44831: NOT
44832: IFFALSE 44836
// continue ;
44834: GO 44244
// for j in tmp do
44836: LD_ADDR_VAR 0 3
44840: PUSH
44841: LD_VAR 0 5
44845: PUSH
44846: FOR_IN
44847: IFFALSE 45106
// begin if IsInUnit ( j ) then
44849: LD_VAR 0 3
44853: PPUSH
44854: CALL_OW 310
44858: IFFALSE 44869
// ComExitBuilding ( j ) ;
44860: LD_VAR 0 3
44864: PPUSH
44865: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44869: LD_VAR 0 3
44873: PUSH
44874: LD_EXP 118
44878: PUSH
44879: LD_VAR 0 2
44883: ARRAY
44884: IN
44885: NOT
44886: IFFALSE 44944
// begin SetTag ( j , 101 ) ;
44888: LD_VAR 0 3
44892: PPUSH
44893: LD_INT 101
44895: PPUSH
44896: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
44900: LD_ADDR_EXP 118
44904: PUSH
44905: LD_EXP 118
44909: PPUSH
44910: LD_VAR 0 2
44914: PUSH
44915: LD_EXP 118
44919: PUSH
44920: LD_VAR 0 2
44924: ARRAY
44925: PUSH
44926: LD_INT 1
44928: PLUS
44929: PUSH
44930: EMPTY
44931: LIST
44932: LIST
44933: PPUSH
44934: LD_VAR 0 3
44938: PPUSH
44939: CALL 70608 0 3
44943: ST_TO_ADDR
// end ; wait ( 1 ) ;
44944: LD_INT 1
44946: PPUSH
44947: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
44951: LD_ADDR_VAR 0 7
44955: PUSH
44956: LD_EXP 117
44960: PUSH
44961: LD_VAR 0 2
44965: ARRAY
44966: ST_TO_ADDR
// if mc_scan [ i ] then
44967: LD_EXP 139
44971: PUSH
44972: LD_VAR 0 2
44976: ARRAY
44977: IFFALSE 45039
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
44979: LD_ADDR_VAR 0 7
44983: PUSH
44984: LD_EXP 117
44988: PUSH
44989: LD_VAR 0 2
44993: ARRAY
44994: PPUSH
44995: LD_INT 3
44997: PUSH
44998: LD_INT 30
45000: PUSH
45001: LD_INT 32
45003: PUSH
45004: EMPTY
45005: LIST
45006: LIST
45007: PUSH
45008: LD_INT 30
45010: PUSH
45011: LD_INT 33
45013: PUSH
45014: EMPTY
45015: LIST
45016: LIST
45017: PUSH
45018: LD_INT 30
45020: PUSH
45021: LD_INT 31
45023: PUSH
45024: EMPTY
45025: LIST
45026: LIST
45027: PUSH
45028: EMPTY
45029: LIST
45030: LIST
45031: LIST
45032: LIST
45033: PPUSH
45034: CALL_OW 72
45038: ST_TO_ADDR
// if not to_repair_tmp then
45039: LD_VAR 0 7
45043: NOT
45044: IFFALSE 45048
// continue ;
45046: GO 44846
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
45048: LD_ADDR_VAR 0 8
45052: PUSH
45053: LD_VAR 0 7
45057: PPUSH
45058: LD_VAR 0 3
45062: PPUSH
45063: CALL_OW 74
45067: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
45068: LD_VAR 0 8
45072: PPUSH
45073: LD_INT 16
45075: PPUSH
45076: CALL 73207 0 2
45080: PUSH
45081: LD_INT 4
45083: ARRAY
45084: PUSH
45085: LD_INT 10
45087: LESS
45088: IFFALSE 45104
// ComRepairBuilding ( j , to_repair ) ;
45090: LD_VAR 0 3
45094: PPUSH
45095: LD_VAR 0 8
45099: PPUSH
45100: CALL_OW 130
// end ;
45104: GO 44846
45106: POP
45107: POP
// end ;
45108: GO 44244
45110: POP
45111: POP
// end ;
45112: LD_VAR 0 1
45116: RET
// export function MC_Heal ; var i , j , tmp ; begin
45117: LD_INT 0
45119: PPUSH
45120: PPUSH
45121: PPUSH
45122: PPUSH
// if not mc_bases then
45123: LD_EXP 116
45127: NOT
45128: IFFALSE 45132
// exit ;
45130: GO 45534
// for i = 1 to mc_bases do
45132: LD_ADDR_VAR 0 2
45136: PUSH
45137: DOUBLE
45138: LD_INT 1
45140: DEC
45141: ST_TO_ADDR
45142: LD_EXP 116
45146: PUSH
45147: FOR_TO
45148: IFFALSE 45532
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
45150: LD_EXP 119
45154: PUSH
45155: LD_VAR 0 2
45159: ARRAY
45160: PUSH
45161: LD_INT 1
45163: ARRAY
45164: NOT
45165: PUSH
45166: LD_EXP 119
45170: PUSH
45171: LD_VAR 0 2
45175: ARRAY
45176: PUSH
45177: LD_INT 2
45179: ARRAY
45180: NOT
45181: AND
45182: IFFALSE 45220
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
45184: LD_ADDR_EXP 120
45188: PUSH
45189: LD_EXP 120
45193: PPUSH
45194: LD_VAR 0 2
45198: PPUSH
45199: EMPTY
45200: PPUSH
45201: CALL_OW 1
45205: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
45206: LD_VAR 0 2
45210: PPUSH
45211: LD_INT 102
45213: PPUSH
45214: CALL 39297 0 2
// continue ;
45218: GO 45147
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
45220: LD_ADDR_VAR 0 4
45224: PUSH
45225: LD_EXP 116
45229: PUSH
45230: LD_VAR 0 2
45234: ARRAY
45235: PPUSH
45236: LD_INT 25
45238: PUSH
45239: LD_INT 4
45241: PUSH
45242: EMPTY
45243: LIST
45244: LIST
45245: PPUSH
45246: CALL_OW 72
45250: ST_TO_ADDR
// if not tmp then
45251: LD_VAR 0 4
45255: NOT
45256: IFFALSE 45260
// continue ;
45258: GO 45147
// if mc_taming [ i ] then
45260: LD_EXP 147
45264: PUSH
45265: LD_VAR 0 2
45269: ARRAY
45270: IFFALSE 45294
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
45272: LD_ADDR_EXP 147
45276: PUSH
45277: LD_EXP 147
45281: PPUSH
45282: LD_VAR 0 2
45286: PPUSH
45287: EMPTY
45288: PPUSH
45289: CALL_OW 1
45293: ST_TO_ADDR
// for j in tmp do
45294: LD_ADDR_VAR 0 3
45298: PUSH
45299: LD_VAR 0 4
45303: PUSH
45304: FOR_IN
45305: IFFALSE 45528
// begin if IsInUnit ( j ) then
45307: LD_VAR 0 3
45311: PPUSH
45312: CALL_OW 310
45316: IFFALSE 45327
// ComExitBuilding ( j ) ;
45318: LD_VAR 0 3
45322: PPUSH
45323: CALL_OW 122
// if not j in mc_healers [ i ] then
45327: LD_VAR 0 3
45331: PUSH
45332: LD_EXP 120
45336: PUSH
45337: LD_VAR 0 2
45341: ARRAY
45342: IN
45343: NOT
45344: IFFALSE 45390
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
45346: LD_ADDR_EXP 120
45350: PUSH
45351: LD_EXP 120
45355: PPUSH
45356: LD_VAR 0 2
45360: PUSH
45361: LD_EXP 120
45365: PUSH
45366: LD_VAR 0 2
45370: ARRAY
45371: PUSH
45372: LD_INT 1
45374: PLUS
45375: PUSH
45376: EMPTY
45377: LIST
45378: LIST
45379: PPUSH
45380: LD_VAR 0 3
45384: PPUSH
45385: CALL 70608 0 3
45389: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
45390: LD_VAR 0 3
45394: PPUSH
45395: CALL_OW 110
45399: PUSH
45400: LD_INT 102
45402: NONEQUAL
45403: IFFALSE 45417
// SetTag ( j , 102 ) ;
45405: LD_VAR 0 3
45409: PPUSH
45410: LD_INT 102
45412: PPUSH
45413: CALL_OW 109
// Wait ( 3 ) ;
45417: LD_INT 3
45419: PPUSH
45420: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
45424: LD_EXP 119
45428: PUSH
45429: LD_VAR 0 2
45433: ARRAY
45434: PUSH
45435: LD_INT 1
45437: ARRAY
45438: IFFALSE 45470
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45440: LD_VAR 0 3
45444: PPUSH
45445: LD_EXP 119
45449: PUSH
45450: LD_VAR 0 2
45454: ARRAY
45455: PUSH
45456: LD_INT 1
45458: ARRAY
45459: PUSH
45460: LD_INT 1
45462: ARRAY
45463: PPUSH
45464: CALL_OW 128
45468: GO 45526
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45470: LD_VAR 0 3
45474: PPUSH
45475: CALL_OW 314
45479: NOT
45480: PUSH
45481: LD_EXP 119
45485: PUSH
45486: LD_VAR 0 2
45490: ARRAY
45491: PUSH
45492: LD_INT 2
45494: ARRAY
45495: AND
45496: IFFALSE 45526
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45498: LD_VAR 0 3
45502: PPUSH
45503: LD_EXP 119
45507: PUSH
45508: LD_VAR 0 2
45512: ARRAY
45513: PUSH
45514: LD_INT 2
45516: ARRAY
45517: PUSH
45518: LD_INT 1
45520: ARRAY
45521: PPUSH
45522: CALL_OW 128
// end ;
45526: GO 45304
45528: POP
45529: POP
// end ;
45530: GO 45147
45532: POP
45533: POP
// end ;
45534: LD_VAR 0 1
45538: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45539: LD_INT 0
45541: PPUSH
45542: PPUSH
45543: PPUSH
45544: PPUSH
45545: PPUSH
// if not mc_bases then
45546: LD_EXP 116
45550: NOT
45551: IFFALSE 45555
// exit ;
45553: GO 46726
// for i = 1 to mc_bases do
45555: LD_ADDR_VAR 0 2
45559: PUSH
45560: DOUBLE
45561: LD_INT 1
45563: DEC
45564: ST_TO_ADDR
45565: LD_EXP 116
45569: PUSH
45570: FOR_TO
45571: IFFALSE 46724
// begin if mc_scan [ i ] then
45573: LD_EXP 139
45577: PUSH
45578: LD_VAR 0 2
45582: ARRAY
45583: IFFALSE 45587
// continue ;
45585: GO 45570
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45587: LD_EXP 121
45591: PUSH
45592: LD_VAR 0 2
45596: ARRAY
45597: NOT
45598: PUSH
45599: LD_EXP 123
45603: PUSH
45604: LD_VAR 0 2
45608: ARRAY
45609: NOT
45610: AND
45611: PUSH
45612: LD_EXP 122
45616: PUSH
45617: LD_VAR 0 2
45621: ARRAY
45622: AND
45623: IFFALSE 45661
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45625: LD_ADDR_EXP 122
45629: PUSH
45630: LD_EXP 122
45634: PPUSH
45635: LD_VAR 0 2
45639: PPUSH
45640: EMPTY
45641: PPUSH
45642: CALL_OW 1
45646: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45647: LD_VAR 0 2
45651: PPUSH
45652: LD_INT 103
45654: PPUSH
45655: CALL 39297 0 2
// continue ;
45659: GO 45570
// end ; if mc_construct_list [ i ] then
45661: LD_EXP 123
45665: PUSH
45666: LD_VAR 0 2
45670: ARRAY
45671: IFFALSE 45891
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45673: LD_ADDR_VAR 0 4
45677: PUSH
45678: LD_EXP 116
45682: PUSH
45683: LD_VAR 0 2
45687: ARRAY
45688: PPUSH
45689: LD_INT 25
45691: PUSH
45692: LD_INT 2
45694: PUSH
45695: EMPTY
45696: LIST
45697: LIST
45698: PPUSH
45699: CALL_OW 72
45703: PUSH
45704: LD_EXP 118
45708: PUSH
45709: LD_VAR 0 2
45713: ARRAY
45714: DIFF
45715: ST_TO_ADDR
// if not tmp then
45716: LD_VAR 0 4
45720: NOT
45721: IFFALSE 45725
// continue ;
45723: GO 45570
// for j in tmp do
45725: LD_ADDR_VAR 0 3
45729: PUSH
45730: LD_VAR 0 4
45734: PUSH
45735: FOR_IN
45736: IFFALSE 45887
// begin if not mc_builders [ i ] then
45738: LD_EXP 122
45742: PUSH
45743: LD_VAR 0 2
45747: ARRAY
45748: NOT
45749: IFFALSE 45807
// begin SetTag ( j , 103 ) ;
45751: LD_VAR 0 3
45755: PPUSH
45756: LD_INT 103
45758: PPUSH
45759: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45763: LD_ADDR_EXP 122
45767: PUSH
45768: LD_EXP 122
45772: PPUSH
45773: LD_VAR 0 2
45777: PUSH
45778: LD_EXP 122
45782: PUSH
45783: LD_VAR 0 2
45787: ARRAY
45788: PUSH
45789: LD_INT 1
45791: PLUS
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: PPUSH
45797: LD_VAR 0 3
45801: PPUSH
45802: CALL 70608 0 3
45806: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45807: LD_VAR 0 3
45811: PPUSH
45812: CALL_OW 310
45816: IFFALSE 45827
// ComExitBuilding ( j ) ;
45818: LD_VAR 0 3
45822: PPUSH
45823: CALL_OW 122
// wait ( 3 ) ;
45827: LD_INT 3
45829: PPUSH
45830: CALL_OW 67
// if not mc_construct_list [ i ] then
45834: LD_EXP 123
45838: PUSH
45839: LD_VAR 0 2
45843: ARRAY
45844: NOT
45845: IFFALSE 45849
// break ;
45847: GO 45887
// if not HasTask ( j ) then
45849: LD_VAR 0 3
45853: PPUSH
45854: CALL_OW 314
45858: NOT
45859: IFFALSE 45885
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45861: LD_VAR 0 3
45865: PPUSH
45866: LD_EXP 123
45870: PUSH
45871: LD_VAR 0 2
45875: ARRAY
45876: PUSH
45877: LD_INT 1
45879: ARRAY
45880: PPUSH
45881: CALL 73471 0 2
// end ;
45885: GO 45735
45887: POP
45888: POP
// end else
45889: GO 46722
// if mc_build_list [ i ] then
45891: LD_EXP 121
45895: PUSH
45896: LD_VAR 0 2
45900: ARRAY
45901: IFFALSE 46722
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45903: LD_ADDR_VAR 0 5
45907: PUSH
45908: LD_EXP 116
45912: PUSH
45913: LD_VAR 0 2
45917: ARRAY
45918: PPUSH
45919: LD_INT 2
45921: PUSH
45922: LD_INT 30
45924: PUSH
45925: LD_INT 0
45927: PUSH
45928: EMPTY
45929: LIST
45930: LIST
45931: PUSH
45932: LD_INT 30
45934: PUSH
45935: LD_INT 1
45937: PUSH
45938: EMPTY
45939: LIST
45940: LIST
45941: PUSH
45942: EMPTY
45943: LIST
45944: LIST
45945: LIST
45946: PPUSH
45947: CALL_OW 72
45951: ST_TO_ADDR
// if depot then
45952: LD_VAR 0 5
45956: IFFALSE 45974
// depot := depot [ 1 ] else
45958: LD_ADDR_VAR 0 5
45962: PUSH
45963: LD_VAR 0 5
45967: PUSH
45968: LD_INT 1
45970: ARRAY
45971: ST_TO_ADDR
45972: GO 45982
// depot := 0 ;
45974: LD_ADDR_VAR 0 5
45978: PUSH
45979: LD_INT 0
45981: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
45982: LD_EXP 121
45986: PUSH
45987: LD_VAR 0 2
45991: ARRAY
45992: PUSH
45993: LD_INT 1
45995: ARRAY
45996: PUSH
45997: LD_INT 1
45999: ARRAY
46000: PPUSH
46001: CALL 73295 0 1
46005: PUSH
46006: LD_EXP 116
46010: PUSH
46011: LD_VAR 0 2
46015: ARRAY
46016: PPUSH
46017: LD_INT 2
46019: PUSH
46020: LD_INT 30
46022: PUSH
46023: LD_INT 2
46025: PUSH
46026: EMPTY
46027: LIST
46028: LIST
46029: PUSH
46030: LD_INT 30
46032: PUSH
46033: LD_INT 3
46035: PUSH
46036: EMPTY
46037: LIST
46038: LIST
46039: PUSH
46040: EMPTY
46041: LIST
46042: LIST
46043: LIST
46044: PPUSH
46045: CALL_OW 72
46049: NOT
46050: AND
46051: IFFALSE 46156
// begin for j = 1 to mc_build_list [ i ] do
46053: LD_ADDR_VAR 0 3
46057: PUSH
46058: DOUBLE
46059: LD_INT 1
46061: DEC
46062: ST_TO_ADDR
46063: LD_EXP 121
46067: PUSH
46068: LD_VAR 0 2
46072: ARRAY
46073: PUSH
46074: FOR_TO
46075: IFFALSE 46154
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
46077: LD_EXP 121
46081: PUSH
46082: LD_VAR 0 2
46086: ARRAY
46087: PUSH
46088: LD_VAR 0 3
46092: ARRAY
46093: PUSH
46094: LD_INT 1
46096: ARRAY
46097: PUSH
46098: LD_INT 2
46100: EQUAL
46101: IFFALSE 46152
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
46103: LD_ADDR_EXP 121
46107: PUSH
46108: LD_EXP 121
46112: PPUSH
46113: LD_VAR 0 2
46117: PPUSH
46118: LD_EXP 121
46122: PUSH
46123: LD_VAR 0 2
46127: ARRAY
46128: PPUSH
46129: LD_VAR 0 3
46133: PPUSH
46134: LD_INT 1
46136: PPUSH
46137: LD_INT 0
46139: PPUSH
46140: CALL 70026 0 4
46144: PPUSH
46145: CALL_OW 1
46149: ST_TO_ADDR
// break ;
46150: GO 46154
// end ;
46152: GO 46074
46154: POP
46155: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
46156: LD_EXP 121
46160: PUSH
46161: LD_VAR 0 2
46165: ARRAY
46166: PUSH
46167: LD_INT 1
46169: ARRAY
46170: PUSH
46171: LD_INT 1
46173: ARRAY
46174: PUSH
46175: LD_INT 0
46177: EQUAL
46178: PUSH
46179: LD_VAR 0 5
46183: PUSH
46184: LD_VAR 0 5
46188: PPUSH
46189: LD_EXP 121
46193: PUSH
46194: LD_VAR 0 2
46198: ARRAY
46199: PUSH
46200: LD_INT 1
46202: ARRAY
46203: PUSH
46204: LD_INT 1
46206: ARRAY
46207: PPUSH
46208: LD_EXP 121
46212: PUSH
46213: LD_VAR 0 2
46217: ARRAY
46218: PUSH
46219: LD_INT 1
46221: ARRAY
46222: PUSH
46223: LD_INT 2
46225: ARRAY
46226: PPUSH
46227: LD_EXP 121
46231: PUSH
46232: LD_VAR 0 2
46236: ARRAY
46237: PUSH
46238: LD_INT 1
46240: ARRAY
46241: PUSH
46242: LD_INT 3
46244: ARRAY
46245: PPUSH
46246: LD_EXP 121
46250: PUSH
46251: LD_VAR 0 2
46255: ARRAY
46256: PUSH
46257: LD_INT 1
46259: ARRAY
46260: PUSH
46261: LD_INT 4
46263: ARRAY
46264: PPUSH
46265: CALL 78711 0 5
46269: AND
46270: OR
46271: IFFALSE 46552
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
46273: LD_ADDR_VAR 0 4
46277: PUSH
46278: LD_EXP 116
46282: PUSH
46283: LD_VAR 0 2
46287: ARRAY
46288: PPUSH
46289: LD_INT 25
46291: PUSH
46292: LD_INT 2
46294: PUSH
46295: EMPTY
46296: LIST
46297: LIST
46298: PPUSH
46299: CALL_OW 72
46303: PUSH
46304: LD_EXP 118
46308: PUSH
46309: LD_VAR 0 2
46313: ARRAY
46314: DIFF
46315: ST_TO_ADDR
// if not tmp then
46316: LD_VAR 0 4
46320: NOT
46321: IFFALSE 46325
// continue ;
46323: GO 45570
// for j in tmp do
46325: LD_ADDR_VAR 0 3
46329: PUSH
46330: LD_VAR 0 4
46334: PUSH
46335: FOR_IN
46336: IFFALSE 46548
// begin if not mc_builders [ i ] then
46338: LD_EXP 122
46342: PUSH
46343: LD_VAR 0 2
46347: ARRAY
46348: NOT
46349: IFFALSE 46407
// begin SetTag ( j , 103 ) ;
46351: LD_VAR 0 3
46355: PPUSH
46356: LD_INT 103
46358: PPUSH
46359: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
46363: LD_ADDR_EXP 122
46367: PUSH
46368: LD_EXP 122
46372: PPUSH
46373: LD_VAR 0 2
46377: PUSH
46378: LD_EXP 122
46382: PUSH
46383: LD_VAR 0 2
46387: ARRAY
46388: PUSH
46389: LD_INT 1
46391: PLUS
46392: PUSH
46393: EMPTY
46394: LIST
46395: LIST
46396: PPUSH
46397: LD_VAR 0 3
46401: PPUSH
46402: CALL 70608 0 3
46406: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
46407: LD_VAR 0 3
46411: PPUSH
46412: CALL_OW 310
46416: IFFALSE 46427
// ComExitBuilding ( j ) ;
46418: LD_VAR 0 3
46422: PPUSH
46423: CALL_OW 122
// wait ( 3 ) ;
46427: LD_INT 3
46429: PPUSH
46430: CALL_OW 67
// if not mc_build_list [ i ] then
46434: LD_EXP 121
46438: PUSH
46439: LD_VAR 0 2
46443: ARRAY
46444: NOT
46445: IFFALSE 46449
// break ;
46447: GO 46548
// if not HasTask ( j ) then
46449: LD_VAR 0 3
46453: PPUSH
46454: CALL_OW 314
46458: NOT
46459: IFFALSE 46546
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46461: LD_VAR 0 3
46465: PPUSH
46466: LD_EXP 121
46470: PUSH
46471: LD_VAR 0 2
46475: ARRAY
46476: PUSH
46477: LD_INT 1
46479: ARRAY
46480: PUSH
46481: LD_INT 1
46483: ARRAY
46484: PPUSH
46485: LD_EXP 121
46489: PUSH
46490: LD_VAR 0 2
46494: ARRAY
46495: PUSH
46496: LD_INT 1
46498: ARRAY
46499: PUSH
46500: LD_INT 2
46502: ARRAY
46503: PPUSH
46504: LD_EXP 121
46508: PUSH
46509: LD_VAR 0 2
46513: ARRAY
46514: PUSH
46515: LD_INT 1
46517: ARRAY
46518: PUSH
46519: LD_INT 3
46521: ARRAY
46522: PPUSH
46523: LD_EXP 121
46527: PUSH
46528: LD_VAR 0 2
46532: ARRAY
46533: PUSH
46534: LD_INT 1
46536: ARRAY
46537: PUSH
46538: LD_INT 4
46540: ARRAY
46541: PPUSH
46542: CALL_OW 145
// end ;
46546: GO 46335
46548: POP
46549: POP
// end else
46550: GO 46722
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
46552: LD_EXP 116
46556: PUSH
46557: LD_VAR 0 2
46561: ARRAY
46562: PPUSH
46563: LD_EXP 121
46567: PUSH
46568: LD_VAR 0 2
46572: ARRAY
46573: PUSH
46574: LD_INT 1
46576: ARRAY
46577: PUSH
46578: LD_INT 1
46580: ARRAY
46581: PPUSH
46582: LD_EXP 121
46586: PUSH
46587: LD_VAR 0 2
46591: ARRAY
46592: PUSH
46593: LD_INT 1
46595: ARRAY
46596: PUSH
46597: LD_INT 2
46599: ARRAY
46600: PPUSH
46601: LD_EXP 121
46605: PUSH
46606: LD_VAR 0 2
46610: ARRAY
46611: PUSH
46612: LD_INT 1
46614: ARRAY
46615: PUSH
46616: LD_INT 3
46618: ARRAY
46619: PPUSH
46620: LD_EXP 121
46624: PUSH
46625: LD_VAR 0 2
46629: ARRAY
46630: PUSH
46631: LD_INT 1
46633: ARRAY
46634: PUSH
46635: LD_INT 4
46637: ARRAY
46638: PPUSH
46639: LD_EXP 116
46643: PUSH
46644: LD_VAR 0 2
46648: ARRAY
46649: PPUSH
46650: LD_INT 21
46652: PUSH
46653: LD_INT 3
46655: PUSH
46656: EMPTY
46657: LIST
46658: LIST
46659: PPUSH
46660: CALL_OW 72
46664: PPUSH
46665: EMPTY
46666: PPUSH
46667: CALL 77461 0 7
46671: NOT
46672: IFFALSE 46722
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46674: LD_ADDR_EXP 121
46678: PUSH
46679: LD_EXP 121
46683: PPUSH
46684: LD_VAR 0 2
46688: PPUSH
46689: LD_EXP 121
46693: PUSH
46694: LD_VAR 0 2
46698: ARRAY
46699: PPUSH
46700: LD_INT 1
46702: PPUSH
46703: LD_INT 1
46705: NEG
46706: PPUSH
46707: LD_INT 0
46709: PPUSH
46710: CALL 70026 0 4
46714: PPUSH
46715: CALL_OW 1
46719: ST_TO_ADDR
// continue ;
46720: GO 45570
// end ; end ; end ;
46722: GO 45570
46724: POP
46725: POP
// end ;
46726: LD_VAR 0 1
46730: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46731: LD_INT 0
46733: PPUSH
46734: PPUSH
46735: PPUSH
46736: PPUSH
46737: PPUSH
46738: PPUSH
// if not mc_bases then
46739: LD_EXP 116
46743: NOT
46744: IFFALSE 46748
// exit ;
46746: GO 47175
// for i = 1 to mc_bases do
46748: LD_ADDR_VAR 0 2
46752: PUSH
46753: DOUBLE
46754: LD_INT 1
46756: DEC
46757: ST_TO_ADDR
46758: LD_EXP 116
46762: PUSH
46763: FOR_TO
46764: IFFALSE 47173
// begin tmp := mc_build_upgrade [ i ] ;
46766: LD_ADDR_VAR 0 4
46770: PUSH
46771: LD_EXP 148
46775: PUSH
46776: LD_VAR 0 2
46780: ARRAY
46781: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46782: LD_ADDR_VAR 0 6
46786: PUSH
46787: LD_EXP 149
46791: PUSH
46792: LD_VAR 0 2
46796: ARRAY
46797: PPUSH
46798: LD_INT 2
46800: PUSH
46801: LD_INT 30
46803: PUSH
46804: LD_INT 6
46806: PUSH
46807: EMPTY
46808: LIST
46809: LIST
46810: PUSH
46811: LD_INT 30
46813: PUSH
46814: LD_INT 7
46816: PUSH
46817: EMPTY
46818: LIST
46819: LIST
46820: PUSH
46821: EMPTY
46822: LIST
46823: LIST
46824: LIST
46825: PPUSH
46826: CALL_OW 72
46830: ST_TO_ADDR
// if not tmp and not lab then
46831: LD_VAR 0 4
46835: NOT
46836: PUSH
46837: LD_VAR 0 6
46841: NOT
46842: AND
46843: IFFALSE 46847
// continue ;
46845: GO 46763
// if tmp then
46847: LD_VAR 0 4
46851: IFFALSE 46971
// for j in tmp do
46853: LD_ADDR_VAR 0 3
46857: PUSH
46858: LD_VAR 0 4
46862: PUSH
46863: FOR_IN
46864: IFFALSE 46969
// begin if UpgradeCost ( j ) then
46866: LD_VAR 0 3
46870: PPUSH
46871: CALL 77121 0 1
46875: IFFALSE 46967
// begin ComUpgrade ( j ) ;
46877: LD_VAR 0 3
46881: PPUSH
46882: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46886: LD_ADDR_EXP 148
46890: PUSH
46891: LD_EXP 148
46895: PPUSH
46896: LD_VAR 0 2
46900: PPUSH
46901: LD_EXP 148
46905: PUSH
46906: LD_VAR 0 2
46910: ARRAY
46911: PUSH
46912: LD_VAR 0 3
46916: DIFF
46917: PPUSH
46918: CALL_OW 1
46922: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46923: LD_ADDR_EXP 123
46927: PUSH
46928: LD_EXP 123
46932: PPUSH
46933: LD_VAR 0 2
46937: PUSH
46938: LD_EXP 123
46942: PUSH
46943: LD_VAR 0 2
46947: ARRAY
46948: PUSH
46949: LD_INT 1
46951: PLUS
46952: PUSH
46953: EMPTY
46954: LIST
46955: LIST
46956: PPUSH
46957: LD_VAR 0 3
46961: PPUSH
46962: CALL 70608 0 3
46966: ST_TO_ADDR
// end ; end ;
46967: GO 46863
46969: POP
46970: POP
// if not lab or not mc_lab_upgrade [ i ] then
46971: LD_VAR 0 6
46975: NOT
46976: PUSH
46977: LD_EXP 150
46981: PUSH
46982: LD_VAR 0 2
46986: ARRAY
46987: NOT
46988: OR
46989: IFFALSE 46993
// continue ;
46991: GO 46763
// for j in lab do
46993: LD_ADDR_VAR 0 3
46997: PUSH
46998: LD_VAR 0 6
47002: PUSH
47003: FOR_IN
47004: IFFALSE 47169
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
47006: LD_VAR 0 3
47010: PPUSH
47011: CALL_OW 266
47015: PUSH
47016: LD_INT 6
47018: PUSH
47019: LD_INT 7
47021: PUSH
47022: EMPTY
47023: LIST
47024: LIST
47025: IN
47026: PUSH
47027: LD_VAR 0 3
47031: PPUSH
47032: CALL_OW 461
47036: PUSH
47037: LD_INT 1
47039: NONEQUAL
47040: AND
47041: IFFALSE 47167
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
47043: LD_VAR 0 3
47047: PPUSH
47048: LD_EXP 150
47052: PUSH
47053: LD_VAR 0 2
47057: ARRAY
47058: PUSH
47059: LD_INT 1
47061: ARRAY
47062: PPUSH
47063: CALL 77326 0 2
47067: IFFALSE 47167
// begin ComCancel ( j ) ;
47069: LD_VAR 0 3
47073: PPUSH
47074: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
47078: LD_VAR 0 3
47082: PPUSH
47083: LD_EXP 150
47087: PUSH
47088: LD_VAR 0 2
47092: ARRAY
47093: PUSH
47094: LD_INT 1
47096: ARRAY
47097: PPUSH
47098: CALL_OW 207
// if not j in mc_construct_list [ i ] then
47102: LD_VAR 0 3
47106: PUSH
47107: LD_EXP 123
47111: PUSH
47112: LD_VAR 0 2
47116: ARRAY
47117: IN
47118: NOT
47119: IFFALSE 47165
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
47121: LD_ADDR_EXP 123
47125: PUSH
47126: LD_EXP 123
47130: PPUSH
47131: LD_VAR 0 2
47135: PUSH
47136: LD_EXP 123
47140: PUSH
47141: LD_VAR 0 2
47145: ARRAY
47146: PUSH
47147: LD_INT 1
47149: PLUS
47150: PUSH
47151: EMPTY
47152: LIST
47153: LIST
47154: PPUSH
47155: LD_VAR 0 3
47159: PPUSH
47160: CALL 70608 0 3
47164: ST_TO_ADDR
// break ;
47165: GO 47169
// end ; end ; end ;
47167: GO 47003
47169: POP
47170: POP
// end ;
47171: GO 46763
47173: POP
47174: POP
// end ;
47175: LD_VAR 0 1
47179: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
47180: LD_INT 0
47182: PPUSH
47183: PPUSH
47184: PPUSH
47185: PPUSH
47186: PPUSH
47187: PPUSH
47188: PPUSH
47189: PPUSH
47190: PPUSH
// if not mc_bases then
47191: LD_EXP 116
47195: NOT
47196: IFFALSE 47200
// exit ;
47198: GO 47605
// for i = 1 to mc_bases do
47200: LD_ADDR_VAR 0 2
47204: PUSH
47205: DOUBLE
47206: LD_INT 1
47208: DEC
47209: ST_TO_ADDR
47210: LD_EXP 116
47214: PUSH
47215: FOR_TO
47216: IFFALSE 47603
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
47218: LD_EXP 124
47222: PUSH
47223: LD_VAR 0 2
47227: ARRAY
47228: NOT
47229: PUSH
47230: LD_EXP 116
47234: PUSH
47235: LD_VAR 0 2
47239: ARRAY
47240: PPUSH
47241: LD_INT 30
47243: PUSH
47244: LD_INT 3
47246: PUSH
47247: EMPTY
47248: LIST
47249: LIST
47250: PPUSH
47251: CALL_OW 72
47255: NOT
47256: OR
47257: IFFALSE 47261
// continue ;
47259: GO 47215
// busy := false ;
47261: LD_ADDR_VAR 0 8
47265: PUSH
47266: LD_INT 0
47268: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
47269: LD_ADDR_VAR 0 4
47273: PUSH
47274: LD_EXP 116
47278: PUSH
47279: LD_VAR 0 2
47283: ARRAY
47284: PPUSH
47285: LD_INT 30
47287: PUSH
47288: LD_INT 3
47290: PUSH
47291: EMPTY
47292: LIST
47293: LIST
47294: PPUSH
47295: CALL_OW 72
47299: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
47300: LD_ADDR_VAR 0 6
47304: PUSH
47305: LD_EXP 124
47309: PUSH
47310: LD_VAR 0 2
47314: ARRAY
47315: PPUSH
47316: LD_INT 2
47318: PUSH
47319: LD_INT 30
47321: PUSH
47322: LD_INT 32
47324: PUSH
47325: EMPTY
47326: LIST
47327: LIST
47328: PUSH
47329: LD_INT 30
47331: PUSH
47332: LD_INT 33
47334: PUSH
47335: EMPTY
47336: LIST
47337: LIST
47338: PUSH
47339: EMPTY
47340: LIST
47341: LIST
47342: LIST
47343: PPUSH
47344: CALL_OW 72
47348: ST_TO_ADDR
// if not t then
47349: LD_VAR 0 6
47353: NOT
47354: IFFALSE 47358
// continue ;
47356: GO 47215
// for j in tmp do
47358: LD_ADDR_VAR 0 3
47362: PUSH
47363: LD_VAR 0 4
47367: PUSH
47368: FOR_IN
47369: IFFALSE 47399
// if not BuildingStatus ( j ) = bs_idle then
47371: LD_VAR 0 3
47375: PPUSH
47376: CALL_OW 461
47380: PUSH
47381: LD_INT 2
47383: EQUAL
47384: NOT
47385: IFFALSE 47397
// begin busy := true ;
47387: LD_ADDR_VAR 0 8
47391: PUSH
47392: LD_INT 1
47394: ST_TO_ADDR
// break ;
47395: GO 47399
// end ;
47397: GO 47368
47399: POP
47400: POP
// if busy then
47401: LD_VAR 0 8
47405: IFFALSE 47409
// continue ;
47407: GO 47215
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
47409: LD_ADDR_VAR 0 7
47413: PUSH
47414: LD_VAR 0 6
47418: PPUSH
47419: LD_INT 35
47421: PUSH
47422: LD_INT 0
47424: PUSH
47425: EMPTY
47426: LIST
47427: LIST
47428: PPUSH
47429: CALL_OW 72
47433: ST_TO_ADDR
// if tw then
47434: LD_VAR 0 7
47438: IFFALSE 47515
// begin tw := tw [ 1 ] ;
47440: LD_ADDR_VAR 0 7
47444: PUSH
47445: LD_VAR 0 7
47449: PUSH
47450: LD_INT 1
47452: ARRAY
47453: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
47454: LD_ADDR_VAR 0 9
47458: PUSH
47459: LD_VAR 0 7
47463: PPUSH
47464: LD_EXP 141
47468: PUSH
47469: LD_VAR 0 2
47473: ARRAY
47474: PPUSH
47475: CALL 75618 0 2
47479: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47480: LD_EXP 155
47484: PUSH
47485: LD_VAR 0 2
47489: ARRAY
47490: IFFALSE 47513
// if not weapon in mc_allowed_tower_weapons [ i ] then
47492: LD_VAR 0 9
47496: PUSH
47497: LD_EXP 155
47501: PUSH
47502: LD_VAR 0 2
47506: ARRAY
47507: IN
47508: NOT
47509: IFFALSE 47513
// continue ;
47511: GO 47215
// end else
47513: GO 47578
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47515: LD_ADDR_VAR 0 5
47519: PUSH
47520: LD_EXP 124
47524: PUSH
47525: LD_VAR 0 2
47529: ARRAY
47530: PPUSH
47531: LD_VAR 0 4
47535: PPUSH
47536: CALL 101907 0 2
47540: ST_TO_ADDR
// if not tmp2 then
47541: LD_VAR 0 5
47545: NOT
47546: IFFALSE 47550
// continue ;
47548: GO 47215
// tw := tmp2 [ 1 ] ;
47550: LD_ADDR_VAR 0 7
47554: PUSH
47555: LD_VAR 0 5
47559: PUSH
47560: LD_INT 1
47562: ARRAY
47563: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47564: LD_ADDR_VAR 0 9
47568: PUSH
47569: LD_VAR 0 5
47573: PUSH
47574: LD_INT 2
47576: ARRAY
47577: ST_TO_ADDR
// end ; if not weapon then
47578: LD_VAR 0 9
47582: NOT
47583: IFFALSE 47587
// continue ;
47585: GO 47215
// ComPlaceWeapon ( tw , weapon ) ;
47587: LD_VAR 0 7
47591: PPUSH
47592: LD_VAR 0 9
47596: PPUSH
47597: CALL_OW 148
// end ;
47601: GO 47215
47603: POP
47604: POP
// end ;
47605: LD_VAR 0 1
47609: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
47610: LD_INT 0
47612: PPUSH
47613: PPUSH
47614: PPUSH
47615: PPUSH
47616: PPUSH
47617: PPUSH
47618: PPUSH
// if not mc_bases then
47619: LD_EXP 116
47623: NOT
47624: IFFALSE 47628
// exit ;
47626: GO 48396
// for i = 1 to mc_bases do
47628: LD_ADDR_VAR 0 2
47632: PUSH
47633: DOUBLE
47634: LD_INT 1
47636: DEC
47637: ST_TO_ADDR
47638: LD_EXP 116
47642: PUSH
47643: FOR_TO
47644: IFFALSE 48394
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47646: LD_EXP 129
47650: PUSH
47651: LD_VAR 0 2
47655: ARRAY
47656: NOT
47657: PUSH
47658: LD_EXP 129
47662: PUSH
47663: LD_VAR 0 2
47667: ARRAY
47668: PUSH
47669: LD_EXP 130
47673: PUSH
47674: LD_VAR 0 2
47678: ARRAY
47679: EQUAL
47680: OR
47681: PUSH
47682: LD_EXP 139
47686: PUSH
47687: LD_VAR 0 2
47691: ARRAY
47692: OR
47693: IFFALSE 47697
// continue ;
47695: GO 47643
// if mc_miners [ i ] then
47697: LD_EXP 130
47701: PUSH
47702: LD_VAR 0 2
47706: ARRAY
47707: IFFALSE 48081
// begin for j = mc_miners [ i ] downto 1 do
47709: LD_ADDR_VAR 0 3
47713: PUSH
47714: DOUBLE
47715: LD_EXP 130
47719: PUSH
47720: LD_VAR 0 2
47724: ARRAY
47725: INC
47726: ST_TO_ADDR
47727: LD_INT 1
47729: PUSH
47730: FOR_DOWNTO
47731: IFFALSE 48079
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47733: LD_EXP 130
47737: PUSH
47738: LD_VAR 0 2
47742: ARRAY
47743: PUSH
47744: LD_VAR 0 3
47748: ARRAY
47749: PPUSH
47750: CALL_OW 301
47754: PUSH
47755: LD_EXP 130
47759: PUSH
47760: LD_VAR 0 2
47764: ARRAY
47765: PUSH
47766: LD_VAR 0 3
47770: ARRAY
47771: PPUSH
47772: CALL_OW 257
47776: PUSH
47777: LD_INT 1
47779: NONEQUAL
47780: OR
47781: IFFALSE 47844
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47783: LD_ADDR_VAR 0 5
47787: PUSH
47788: LD_EXP 130
47792: PUSH
47793: LD_VAR 0 2
47797: ARRAY
47798: PUSH
47799: LD_EXP 130
47803: PUSH
47804: LD_VAR 0 2
47808: ARRAY
47809: PUSH
47810: LD_VAR 0 3
47814: ARRAY
47815: DIFF
47816: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47817: LD_ADDR_EXP 130
47821: PUSH
47822: LD_EXP 130
47826: PPUSH
47827: LD_VAR 0 2
47831: PPUSH
47832: LD_VAR 0 5
47836: PPUSH
47837: CALL_OW 1
47841: ST_TO_ADDR
// continue ;
47842: GO 47730
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47844: LD_EXP 130
47848: PUSH
47849: LD_VAR 0 2
47853: ARRAY
47854: PUSH
47855: LD_VAR 0 3
47859: ARRAY
47860: PPUSH
47861: CALL_OW 257
47865: PUSH
47866: LD_INT 1
47868: EQUAL
47869: PUSH
47870: LD_EXP 130
47874: PUSH
47875: LD_VAR 0 2
47879: ARRAY
47880: PUSH
47881: LD_VAR 0 3
47885: ARRAY
47886: PPUSH
47887: CALL_OW 459
47891: NOT
47892: AND
47893: PUSH
47894: LD_EXP 130
47898: PUSH
47899: LD_VAR 0 2
47903: ARRAY
47904: PUSH
47905: LD_VAR 0 3
47909: ARRAY
47910: PPUSH
47911: CALL_OW 314
47915: NOT
47916: AND
47917: IFFALSE 48077
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
47919: LD_EXP 130
47923: PUSH
47924: LD_VAR 0 2
47928: ARRAY
47929: PUSH
47930: LD_VAR 0 3
47934: ARRAY
47935: PPUSH
47936: CALL_OW 310
47940: IFFALSE 47963
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
47942: LD_EXP 130
47946: PUSH
47947: LD_VAR 0 2
47951: ARRAY
47952: PUSH
47953: LD_VAR 0 3
47957: ARRAY
47958: PPUSH
47959: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
47963: LD_EXP 130
47967: PUSH
47968: LD_VAR 0 2
47972: ARRAY
47973: PUSH
47974: LD_VAR 0 3
47978: ARRAY
47979: PPUSH
47980: CALL_OW 314
47984: NOT
47985: IFFALSE 48077
// begin r := rand ( 1 , mc_mines [ i ] ) ;
47987: LD_ADDR_VAR 0 7
47991: PUSH
47992: LD_INT 1
47994: PPUSH
47995: LD_EXP 129
47999: PUSH
48000: LD_VAR 0 2
48004: ARRAY
48005: PPUSH
48006: CALL_OW 12
48010: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
48011: LD_EXP 130
48015: PUSH
48016: LD_VAR 0 2
48020: ARRAY
48021: PUSH
48022: LD_VAR 0 3
48026: ARRAY
48027: PPUSH
48028: LD_EXP 129
48032: PUSH
48033: LD_VAR 0 2
48037: ARRAY
48038: PUSH
48039: LD_VAR 0 7
48043: ARRAY
48044: PUSH
48045: LD_INT 1
48047: ARRAY
48048: PPUSH
48049: LD_EXP 129
48053: PUSH
48054: LD_VAR 0 2
48058: ARRAY
48059: PUSH
48060: LD_VAR 0 7
48064: ARRAY
48065: PUSH
48066: LD_INT 2
48068: ARRAY
48069: PPUSH
48070: LD_INT 0
48072: PPUSH
48073: CALL_OW 193
// end ; end ; end ;
48077: GO 47730
48079: POP
48080: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
48081: LD_ADDR_VAR 0 5
48085: PUSH
48086: LD_EXP 116
48090: PUSH
48091: LD_VAR 0 2
48095: ARRAY
48096: PPUSH
48097: LD_INT 2
48099: PUSH
48100: LD_INT 30
48102: PUSH
48103: LD_INT 4
48105: PUSH
48106: EMPTY
48107: LIST
48108: LIST
48109: PUSH
48110: LD_INT 30
48112: PUSH
48113: LD_INT 5
48115: PUSH
48116: EMPTY
48117: LIST
48118: LIST
48119: PUSH
48120: LD_INT 30
48122: PUSH
48123: LD_INT 32
48125: PUSH
48126: EMPTY
48127: LIST
48128: LIST
48129: PUSH
48130: EMPTY
48131: LIST
48132: LIST
48133: LIST
48134: LIST
48135: PPUSH
48136: CALL_OW 72
48140: ST_TO_ADDR
// if not tmp then
48141: LD_VAR 0 5
48145: NOT
48146: IFFALSE 48150
// continue ;
48148: GO 47643
// list := [ ] ;
48150: LD_ADDR_VAR 0 6
48154: PUSH
48155: EMPTY
48156: ST_TO_ADDR
// for j in tmp do
48157: LD_ADDR_VAR 0 3
48161: PUSH
48162: LD_VAR 0 5
48166: PUSH
48167: FOR_IN
48168: IFFALSE 48237
// begin for k in UnitsInside ( j ) do
48170: LD_ADDR_VAR 0 4
48174: PUSH
48175: LD_VAR 0 3
48179: PPUSH
48180: CALL_OW 313
48184: PUSH
48185: FOR_IN
48186: IFFALSE 48233
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
48188: LD_VAR 0 4
48192: PPUSH
48193: CALL_OW 257
48197: PUSH
48198: LD_INT 1
48200: EQUAL
48201: PUSH
48202: LD_VAR 0 4
48206: PPUSH
48207: CALL_OW 459
48211: NOT
48212: AND
48213: IFFALSE 48231
// list := list ^ k ;
48215: LD_ADDR_VAR 0 6
48219: PUSH
48220: LD_VAR 0 6
48224: PUSH
48225: LD_VAR 0 4
48229: ADD
48230: ST_TO_ADDR
48231: GO 48185
48233: POP
48234: POP
// end ;
48235: GO 48167
48237: POP
48238: POP
// list := list diff mc_miners [ i ] ;
48239: LD_ADDR_VAR 0 6
48243: PUSH
48244: LD_VAR 0 6
48248: PUSH
48249: LD_EXP 130
48253: PUSH
48254: LD_VAR 0 2
48258: ARRAY
48259: DIFF
48260: ST_TO_ADDR
// if not list then
48261: LD_VAR 0 6
48265: NOT
48266: IFFALSE 48270
// continue ;
48268: GO 47643
// k := mc_mines [ i ] - mc_miners [ i ] ;
48270: LD_ADDR_VAR 0 4
48274: PUSH
48275: LD_EXP 129
48279: PUSH
48280: LD_VAR 0 2
48284: ARRAY
48285: PUSH
48286: LD_EXP 130
48290: PUSH
48291: LD_VAR 0 2
48295: ARRAY
48296: MINUS
48297: ST_TO_ADDR
// if k > list then
48298: LD_VAR 0 4
48302: PUSH
48303: LD_VAR 0 6
48307: GREATER
48308: IFFALSE 48320
// k := list ;
48310: LD_ADDR_VAR 0 4
48314: PUSH
48315: LD_VAR 0 6
48319: ST_TO_ADDR
// for j = 1 to k do
48320: LD_ADDR_VAR 0 3
48324: PUSH
48325: DOUBLE
48326: LD_INT 1
48328: DEC
48329: ST_TO_ADDR
48330: LD_VAR 0 4
48334: PUSH
48335: FOR_TO
48336: IFFALSE 48390
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
48338: LD_ADDR_EXP 130
48342: PUSH
48343: LD_EXP 130
48347: PPUSH
48348: LD_VAR 0 2
48352: PUSH
48353: LD_EXP 130
48357: PUSH
48358: LD_VAR 0 2
48362: ARRAY
48363: PUSH
48364: LD_INT 1
48366: PLUS
48367: PUSH
48368: EMPTY
48369: LIST
48370: LIST
48371: PPUSH
48372: LD_VAR 0 6
48376: PUSH
48377: LD_VAR 0 3
48381: ARRAY
48382: PPUSH
48383: CALL 70608 0 3
48387: ST_TO_ADDR
48388: GO 48335
48390: POP
48391: POP
// end ;
48392: GO 47643
48394: POP
48395: POP
// end ;
48396: LD_VAR 0 1
48400: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
48401: LD_INT 0
48403: PPUSH
48404: PPUSH
48405: PPUSH
48406: PPUSH
48407: PPUSH
48408: PPUSH
48409: PPUSH
48410: PPUSH
48411: PPUSH
48412: PPUSH
48413: PPUSH
// if not mc_bases then
48414: LD_EXP 116
48418: NOT
48419: IFFALSE 48423
// exit ;
48421: GO 50246
// for i = 1 to mc_bases do
48423: LD_ADDR_VAR 0 2
48427: PUSH
48428: DOUBLE
48429: LD_INT 1
48431: DEC
48432: ST_TO_ADDR
48433: LD_EXP 116
48437: PUSH
48438: FOR_TO
48439: IFFALSE 50244
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
48441: LD_EXP 116
48445: PUSH
48446: LD_VAR 0 2
48450: ARRAY
48451: NOT
48452: PUSH
48453: LD_EXP 123
48457: PUSH
48458: LD_VAR 0 2
48462: ARRAY
48463: OR
48464: IFFALSE 48468
// continue ;
48466: GO 48438
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48468: LD_EXP 132
48472: PUSH
48473: LD_VAR 0 2
48477: ARRAY
48478: NOT
48479: PUSH
48480: LD_EXP 133
48484: PUSH
48485: LD_VAR 0 2
48489: ARRAY
48490: AND
48491: IFFALSE 48529
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48493: LD_ADDR_EXP 133
48497: PUSH
48498: LD_EXP 133
48502: PPUSH
48503: LD_VAR 0 2
48507: PPUSH
48508: EMPTY
48509: PPUSH
48510: CALL_OW 1
48514: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48515: LD_VAR 0 2
48519: PPUSH
48520: LD_INT 107
48522: PPUSH
48523: CALL 39297 0 2
// continue ;
48527: GO 48438
// end ; target := [ ] ;
48529: LD_ADDR_VAR 0 7
48533: PUSH
48534: EMPTY
48535: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
48536: LD_ADDR_VAR 0 6
48540: PUSH
48541: LD_EXP 116
48545: PUSH
48546: LD_VAR 0 2
48550: ARRAY
48551: PUSH
48552: LD_INT 1
48554: ARRAY
48555: PPUSH
48556: CALL_OW 255
48560: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48561: LD_ADDR_VAR 0 9
48565: PUSH
48566: LD_EXP 116
48570: PUSH
48571: LD_VAR 0 2
48575: ARRAY
48576: PPUSH
48577: LD_INT 2
48579: PUSH
48580: LD_INT 30
48582: PUSH
48583: LD_INT 0
48585: PUSH
48586: EMPTY
48587: LIST
48588: LIST
48589: PUSH
48590: LD_INT 30
48592: PUSH
48593: LD_INT 1
48595: PUSH
48596: EMPTY
48597: LIST
48598: LIST
48599: PUSH
48600: EMPTY
48601: LIST
48602: LIST
48603: LIST
48604: PPUSH
48605: CALL_OW 72
48609: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48610: LD_ADDR_VAR 0 3
48614: PUSH
48615: DOUBLE
48616: LD_EXP 132
48620: PUSH
48621: LD_VAR 0 2
48625: ARRAY
48626: INC
48627: ST_TO_ADDR
48628: LD_INT 1
48630: PUSH
48631: FOR_DOWNTO
48632: IFFALSE 48877
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48634: LD_EXP 132
48638: PUSH
48639: LD_VAR 0 2
48643: ARRAY
48644: PUSH
48645: LD_VAR 0 3
48649: ARRAY
48650: PUSH
48651: LD_INT 2
48653: ARRAY
48654: PPUSH
48655: LD_EXP 132
48659: PUSH
48660: LD_VAR 0 2
48664: ARRAY
48665: PUSH
48666: LD_VAR 0 3
48670: ARRAY
48671: PUSH
48672: LD_INT 3
48674: ARRAY
48675: PPUSH
48676: CALL_OW 488
48680: PUSH
48681: LD_EXP 132
48685: PUSH
48686: LD_VAR 0 2
48690: ARRAY
48691: PUSH
48692: LD_VAR 0 3
48696: ARRAY
48697: PUSH
48698: LD_INT 2
48700: ARRAY
48701: PPUSH
48702: LD_EXP 132
48706: PUSH
48707: LD_VAR 0 2
48711: ARRAY
48712: PUSH
48713: LD_VAR 0 3
48717: ARRAY
48718: PUSH
48719: LD_INT 3
48721: ARRAY
48722: PPUSH
48723: CALL_OW 284
48727: PUSH
48728: LD_INT 0
48730: EQUAL
48731: AND
48732: IFFALSE 48787
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48734: LD_ADDR_VAR 0 5
48738: PUSH
48739: LD_EXP 132
48743: PUSH
48744: LD_VAR 0 2
48748: ARRAY
48749: PPUSH
48750: LD_VAR 0 3
48754: PPUSH
48755: CALL_OW 3
48759: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48760: LD_ADDR_EXP 132
48764: PUSH
48765: LD_EXP 132
48769: PPUSH
48770: LD_VAR 0 2
48774: PPUSH
48775: LD_VAR 0 5
48779: PPUSH
48780: CALL_OW 1
48784: ST_TO_ADDR
// continue ;
48785: GO 48631
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48787: LD_VAR 0 6
48791: PPUSH
48792: LD_EXP 132
48796: PUSH
48797: LD_VAR 0 2
48801: ARRAY
48802: PUSH
48803: LD_VAR 0 3
48807: ARRAY
48808: PUSH
48809: LD_INT 2
48811: ARRAY
48812: PPUSH
48813: LD_EXP 132
48817: PUSH
48818: LD_VAR 0 2
48822: ARRAY
48823: PUSH
48824: LD_VAR 0 3
48828: ARRAY
48829: PUSH
48830: LD_INT 3
48832: ARRAY
48833: PPUSH
48834: LD_INT 30
48836: PPUSH
48837: CALL 71504 0 4
48841: PUSH
48842: LD_INT 4
48844: ARRAY
48845: PUSH
48846: LD_INT 0
48848: EQUAL
48849: IFFALSE 48875
// begin target := mc_crates [ i ] [ j ] ;
48851: LD_ADDR_VAR 0 7
48855: PUSH
48856: LD_EXP 132
48860: PUSH
48861: LD_VAR 0 2
48865: ARRAY
48866: PUSH
48867: LD_VAR 0 3
48871: ARRAY
48872: ST_TO_ADDR
// break ;
48873: GO 48877
// end ; end ;
48875: GO 48631
48877: POP
48878: POP
// if not target then
48879: LD_VAR 0 7
48883: NOT
48884: IFFALSE 48888
// continue ;
48886: GO 48438
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48888: LD_ADDR_VAR 0 8
48892: PUSH
48893: LD_EXP 135
48897: PUSH
48898: LD_VAR 0 2
48902: ARRAY
48903: PPUSH
48904: LD_INT 2
48906: PUSH
48907: LD_INT 3
48909: PUSH
48910: LD_INT 58
48912: PUSH
48913: EMPTY
48914: LIST
48915: PUSH
48916: EMPTY
48917: LIST
48918: LIST
48919: PUSH
48920: LD_INT 61
48922: PUSH
48923: EMPTY
48924: LIST
48925: PUSH
48926: LD_INT 33
48928: PUSH
48929: LD_INT 5
48931: PUSH
48932: EMPTY
48933: LIST
48934: LIST
48935: PUSH
48936: LD_INT 33
48938: PUSH
48939: LD_INT 3
48941: PUSH
48942: EMPTY
48943: LIST
48944: LIST
48945: PUSH
48946: EMPTY
48947: LIST
48948: LIST
48949: LIST
48950: LIST
48951: LIST
48952: PUSH
48953: LD_INT 2
48955: PUSH
48956: LD_INT 34
48958: PUSH
48959: LD_INT 32
48961: PUSH
48962: EMPTY
48963: LIST
48964: LIST
48965: PUSH
48966: LD_INT 34
48968: PUSH
48969: LD_INT 51
48971: PUSH
48972: EMPTY
48973: LIST
48974: LIST
48975: PUSH
48976: LD_INT 34
48978: PUSH
48979: LD_INT 12
48981: PUSH
48982: EMPTY
48983: LIST
48984: LIST
48985: PUSH
48986: EMPTY
48987: LIST
48988: LIST
48989: LIST
48990: LIST
48991: PUSH
48992: EMPTY
48993: LIST
48994: LIST
48995: PPUSH
48996: CALL_OW 72
49000: ST_TO_ADDR
// if not cargo then
49001: LD_VAR 0 8
49005: NOT
49006: IFFALSE 49712
// begin if mc_crates_collector [ i ] < 5 then
49008: LD_EXP 133
49012: PUSH
49013: LD_VAR 0 2
49017: ARRAY
49018: PUSH
49019: LD_INT 5
49021: LESS
49022: IFFALSE 49388
// begin if mc_ape [ i ] then
49024: LD_EXP 145
49028: PUSH
49029: LD_VAR 0 2
49033: ARRAY
49034: IFFALSE 49081
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
49036: LD_ADDR_VAR 0 5
49040: PUSH
49041: LD_EXP 145
49045: PUSH
49046: LD_VAR 0 2
49050: ARRAY
49051: PPUSH
49052: LD_INT 25
49054: PUSH
49055: LD_INT 16
49057: PUSH
49058: EMPTY
49059: LIST
49060: LIST
49061: PUSH
49062: LD_INT 24
49064: PUSH
49065: LD_INT 750
49067: PUSH
49068: EMPTY
49069: LIST
49070: LIST
49071: PUSH
49072: EMPTY
49073: LIST
49074: LIST
49075: PPUSH
49076: CALL_OW 72
49080: ST_TO_ADDR
// if not tmp then
49081: LD_VAR 0 5
49085: NOT
49086: IFFALSE 49133
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
49088: LD_ADDR_VAR 0 5
49092: PUSH
49093: LD_EXP 116
49097: PUSH
49098: LD_VAR 0 2
49102: ARRAY
49103: PPUSH
49104: LD_INT 25
49106: PUSH
49107: LD_INT 2
49109: PUSH
49110: EMPTY
49111: LIST
49112: LIST
49113: PUSH
49114: LD_INT 24
49116: PUSH
49117: LD_INT 750
49119: PUSH
49120: EMPTY
49121: LIST
49122: LIST
49123: PUSH
49124: EMPTY
49125: LIST
49126: LIST
49127: PPUSH
49128: CALL_OW 72
49132: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
49133: LD_EXP 145
49137: PUSH
49138: LD_VAR 0 2
49142: ARRAY
49143: PUSH
49144: LD_EXP 116
49148: PUSH
49149: LD_VAR 0 2
49153: ARRAY
49154: PPUSH
49155: LD_INT 25
49157: PUSH
49158: LD_INT 2
49160: PUSH
49161: EMPTY
49162: LIST
49163: LIST
49164: PUSH
49165: LD_INT 24
49167: PUSH
49168: LD_INT 750
49170: PUSH
49171: EMPTY
49172: LIST
49173: LIST
49174: PUSH
49175: EMPTY
49176: LIST
49177: LIST
49178: PPUSH
49179: CALL_OW 72
49183: AND
49184: PUSH
49185: LD_VAR 0 5
49189: PUSH
49190: LD_INT 5
49192: LESS
49193: AND
49194: IFFALSE 49276
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
49196: LD_ADDR_VAR 0 3
49200: PUSH
49201: LD_EXP 116
49205: PUSH
49206: LD_VAR 0 2
49210: ARRAY
49211: PPUSH
49212: LD_INT 25
49214: PUSH
49215: LD_INT 2
49217: PUSH
49218: EMPTY
49219: LIST
49220: LIST
49221: PUSH
49222: LD_INT 24
49224: PUSH
49225: LD_INT 750
49227: PUSH
49228: EMPTY
49229: LIST
49230: LIST
49231: PUSH
49232: EMPTY
49233: LIST
49234: LIST
49235: PPUSH
49236: CALL_OW 72
49240: PUSH
49241: FOR_IN
49242: IFFALSE 49274
// begin tmp := tmp union j ;
49244: LD_ADDR_VAR 0 5
49248: PUSH
49249: LD_VAR 0 5
49253: PUSH
49254: LD_VAR 0 3
49258: UNION
49259: ST_TO_ADDR
// if tmp >= 5 then
49260: LD_VAR 0 5
49264: PUSH
49265: LD_INT 5
49267: GREATEREQUAL
49268: IFFALSE 49272
// break ;
49270: GO 49274
// end ;
49272: GO 49241
49274: POP
49275: POP
// end ; if not tmp then
49276: LD_VAR 0 5
49280: NOT
49281: IFFALSE 49285
// continue ;
49283: GO 48438
// for j in tmp do
49285: LD_ADDR_VAR 0 3
49289: PUSH
49290: LD_VAR 0 5
49294: PUSH
49295: FOR_IN
49296: IFFALSE 49386
// if not GetTag ( j ) then
49298: LD_VAR 0 3
49302: PPUSH
49303: CALL_OW 110
49307: NOT
49308: IFFALSE 49384
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
49310: LD_ADDR_EXP 133
49314: PUSH
49315: LD_EXP 133
49319: PPUSH
49320: LD_VAR 0 2
49324: PUSH
49325: LD_EXP 133
49329: PUSH
49330: LD_VAR 0 2
49334: ARRAY
49335: PUSH
49336: LD_INT 1
49338: PLUS
49339: PUSH
49340: EMPTY
49341: LIST
49342: LIST
49343: PPUSH
49344: LD_VAR 0 3
49348: PPUSH
49349: CALL 70608 0 3
49353: ST_TO_ADDR
// SetTag ( j , 107 ) ;
49354: LD_VAR 0 3
49358: PPUSH
49359: LD_INT 107
49361: PPUSH
49362: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
49366: LD_EXP 133
49370: PUSH
49371: LD_VAR 0 2
49375: ARRAY
49376: PUSH
49377: LD_INT 5
49379: GREATEREQUAL
49380: IFFALSE 49384
// break ;
49382: GO 49386
// end ;
49384: GO 49295
49386: POP
49387: POP
// end ; if mc_crates_collector [ i ] and target then
49388: LD_EXP 133
49392: PUSH
49393: LD_VAR 0 2
49397: ARRAY
49398: PUSH
49399: LD_VAR 0 7
49403: AND
49404: IFFALSE 49710
// begin if mc_crates_collector [ i ] < target [ 1 ] then
49406: LD_EXP 133
49410: PUSH
49411: LD_VAR 0 2
49415: ARRAY
49416: PUSH
49417: LD_VAR 0 7
49421: PUSH
49422: LD_INT 1
49424: ARRAY
49425: LESS
49426: IFFALSE 49446
// tmp := mc_crates_collector [ i ] else
49428: LD_ADDR_VAR 0 5
49432: PUSH
49433: LD_EXP 133
49437: PUSH
49438: LD_VAR 0 2
49442: ARRAY
49443: ST_TO_ADDR
49444: GO 49460
// tmp := target [ 1 ] ;
49446: LD_ADDR_VAR 0 5
49450: PUSH
49451: LD_VAR 0 7
49455: PUSH
49456: LD_INT 1
49458: ARRAY
49459: ST_TO_ADDR
// k := 0 ;
49460: LD_ADDR_VAR 0 4
49464: PUSH
49465: LD_INT 0
49467: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
49468: LD_ADDR_VAR 0 3
49472: PUSH
49473: LD_EXP 133
49477: PUSH
49478: LD_VAR 0 2
49482: ARRAY
49483: PUSH
49484: FOR_IN
49485: IFFALSE 49708
// begin k := k + 1 ;
49487: LD_ADDR_VAR 0 4
49491: PUSH
49492: LD_VAR 0 4
49496: PUSH
49497: LD_INT 1
49499: PLUS
49500: ST_TO_ADDR
// if k > tmp then
49501: LD_VAR 0 4
49505: PUSH
49506: LD_VAR 0 5
49510: GREATER
49511: IFFALSE 49515
// break ;
49513: GO 49708
// if not GetClass ( j ) in [ 2 , 16 ] then
49515: LD_VAR 0 3
49519: PPUSH
49520: CALL_OW 257
49524: PUSH
49525: LD_INT 2
49527: PUSH
49528: LD_INT 16
49530: PUSH
49531: EMPTY
49532: LIST
49533: LIST
49534: IN
49535: NOT
49536: IFFALSE 49589
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49538: LD_ADDR_EXP 133
49542: PUSH
49543: LD_EXP 133
49547: PPUSH
49548: LD_VAR 0 2
49552: PPUSH
49553: LD_EXP 133
49557: PUSH
49558: LD_VAR 0 2
49562: ARRAY
49563: PUSH
49564: LD_VAR 0 3
49568: DIFF
49569: PPUSH
49570: CALL_OW 1
49574: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49575: LD_VAR 0 3
49579: PPUSH
49580: LD_INT 0
49582: PPUSH
49583: CALL_OW 109
// continue ;
49587: GO 49484
// end ; if IsInUnit ( j ) then
49589: LD_VAR 0 3
49593: PPUSH
49594: CALL_OW 310
49598: IFFALSE 49609
// ComExitBuilding ( j ) ;
49600: LD_VAR 0 3
49604: PPUSH
49605: CALL_OW 122
// wait ( 3 ) ;
49609: LD_INT 3
49611: PPUSH
49612: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
49616: LD_VAR 0 3
49620: PPUSH
49621: CALL_OW 314
49625: PUSH
49626: LD_VAR 0 6
49630: PPUSH
49631: LD_VAR 0 7
49635: PUSH
49636: LD_INT 2
49638: ARRAY
49639: PPUSH
49640: LD_VAR 0 7
49644: PUSH
49645: LD_INT 3
49647: ARRAY
49648: PPUSH
49649: LD_INT 30
49651: PPUSH
49652: CALL 71504 0 4
49656: PUSH
49657: LD_INT 4
49659: ARRAY
49660: AND
49661: IFFALSE 49679
// ComStandNearbyBuilding ( j , depot ) else
49663: LD_VAR 0 3
49667: PPUSH
49668: LD_VAR 0 9
49672: PPUSH
49673: CALL 67186 0 2
49677: GO 49706
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49679: LD_VAR 0 3
49683: PPUSH
49684: LD_VAR 0 7
49688: PUSH
49689: LD_INT 2
49691: ARRAY
49692: PPUSH
49693: LD_VAR 0 7
49697: PUSH
49698: LD_INT 3
49700: ARRAY
49701: PPUSH
49702: CALL_OW 117
// end ;
49706: GO 49484
49708: POP
49709: POP
// end ; end else
49710: GO 50242
// begin for j in cargo do
49712: LD_ADDR_VAR 0 3
49716: PUSH
49717: LD_VAR 0 8
49721: PUSH
49722: FOR_IN
49723: IFFALSE 50240
// begin if GetTag ( j ) <> 0 then
49725: LD_VAR 0 3
49729: PPUSH
49730: CALL_OW 110
49734: PUSH
49735: LD_INT 0
49737: NONEQUAL
49738: IFFALSE 49742
// continue ;
49740: GO 49722
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49742: LD_VAR 0 3
49746: PPUSH
49747: CALL_OW 256
49751: PUSH
49752: LD_INT 1000
49754: LESS
49755: PUSH
49756: LD_VAR 0 3
49760: PPUSH
49761: LD_EXP 140
49765: PUSH
49766: LD_VAR 0 2
49770: ARRAY
49771: PPUSH
49772: CALL_OW 308
49776: NOT
49777: AND
49778: IFFALSE 49800
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49780: LD_VAR 0 3
49784: PPUSH
49785: LD_EXP 140
49789: PUSH
49790: LD_VAR 0 2
49794: ARRAY
49795: PPUSH
49796: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49800: LD_VAR 0 3
49804: PPUSH
49805: CALL_OW 256
49809: PUSH
49810: LD_INT 1000
49812: LESS
49813: PUSH
49814: LD_VAR 0 3
49818: PPUSH
49819: LD_EXP 140
49823: PUSH
49824: LD_VAR 0 2
49828: ARRAY
49829: PPUSH
49830: CALL_OW 308
49834: AND
49835: IFFALSE 49839
// continue ;
49837: GO 49722
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49839: LD_VAR 0 3
49843: PPUSH
49844: CALL_OW 262
49848: PUSH
49849: LD_INT 2
49851: EQUAL
49852: PUSH
49853: LD_VAR 0 3
49857: PPUSH
49858: CALL_OW 261
49862: PUSH
49863: LD_INT 15
49865: LESS
49866: AND
49867: IFFALSE 49871
// continue ;
49869: GO 49722
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49871: LD_VAR 0 3
49875: PPUSH
49876: CALL_OW 262
49880: PUSH
49881: LD_INT 1
49883: EQUAL
49884: PUSH
49885: LD_VAR 0 3
49889: PPUSH
49890: CALL_OW 261
49894: PUSH
49895: LD_INT 10
49897: LESS
49898: AND
49899: IFFALSE 50179
// begin if not depot then
49901: LD_VAR 0 9
49905: NOT
49906: IFFALSE 49910
// continue ;
49908: GO 49722
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
49910: LD_VAR 0 3
49914: PPUSH
49915: LD_VAR 0 9
49919: PPUSH
49920: LD_VAR 0 3
49924: PPUSH
49925: CALL_OW 74
49929: PPUSH
49930: CALL_OW 296
49934: PUSH
49935: LD_INT 6
49937: LESS
49938: IFFALSE 49954
// SetFuel ( j , 100 ) else
49940: LD_VAR 0 3
49944: PPUSH
49945: LD_INT 100
49947: PPUSH
49948: CALL_OW 240
49952: GO 50179
// if GetFuel ( j ) = 0 then
49954: LD_VAR 0 3
49958: PPUSH
49959: CALL_OW 261
49963: PUSH
49964: LD_INT 0
49966: EQUAL
49967: IFFALSE 50179
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
49969: LD_ADDR_EXP 135
49973: PUSH
49974: LD_EXP 135
49978: PPUSH
49979: LD_VAR 0 2
49983: PPUSH
49984: LD_EXP 135
49988: PUSH
49989: LD_VAR 0 2
49993: ARRAY
49994: PUSH
49995: LD_VAR 0 3
49999: DIFF
50000: PPUSH
50001: CALL_OW 1
50005: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
50006: LD_VAR 0 3
50010: PPUSH
50011: CALL_OW 263
50015: PUSH
50016: LD_INT 1
50018: EQUAL
50019: IFFALSE 50035
// ComExitVehicle ( IsInUnit ( j ) ) ;
50021: LD_VAR 0 3
50025: PPUSH
50026: CALL_OW 310
50030: PPUSH
50031: CALL_OW 121
// if GetControl ( j ) = control_remote then
50035: LD_VAR 0 3
50039: PPUSH
50040: CALL_OW 263
50044: PUSH
50045: LD_INT 2
50047: EQUAL
50048: IFFALSE 50059
// ComUnlink ( j ) ;
50050: LD_VAR 0 3
50054: PPUSH
50055: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
50059: LD_ADDR_VAR 0 10
50063: PUSH
50064: LD_VAR 0 2
50068: PPUSH
50069: LD_INT 3
50071: PPUSH
50072: CALL 59671 0 2
50076: ST_TO_ADDR
// if fac then
50077: LD_VAR 0 10
50081: IFFALSE 50177
// begin for k in fac do
50083: LD_ADDR_VAR 0 4
50087: PUSH
50088: LD_VAR 0 10
50092: PUSH
50093: FOR_IN
50094: IFFALSE 50175
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
50096: LD_ADDR_VAR 0 11
50100: PUSH
50101: LD_VAR 0 10
50105: PPUSH
50106: LD_VAR 0 3
50110: PPUSH
50111: CALL_OW 265
50115: PPUSH
50116: LD_VAR 0 3
50120: PPUSH
50121: CALL_OW 262
50125: PPUSH
50126: LD_VAR 0 3
50130: PPUSH
50131: CALL_OW 263
50135: PPUSH
50136: LD_VAR 0 3
50140: PPUSH
50141: CALL_OW 264
50145: PPUSH
50146: CALL 68104 0 5
50150: ST_TO_ADDR
// if components then
50151: LD_VAR 0 11
50155: IFFALSE 50173
// begin MC_InsertProduceList ( i , components ) ;
50157: LD_VAR 0 2
50161: PPUSH
50162: LD_VAR 0 11
50166: PPUSH
50167: CALL 59216 0 2
// break ;
50171: GO 50175
// end ; end ;
50173: GO 50093
50175: POP
50176: POP
// end ; continue ;
50177: GO 49722
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
50179: LD_VAR 0 3
50183: PPUSH
50184: LD_INT 1
50186: PPUSH
50187: CALL_OW 289
50191: PUSH
50192: LD_INT 100
50194: LESS
50195: PUSH
50196: LD_VAR 0 3
50200: PPUSH
50201: CALL_OW 314
50205: NOT
50206: AND
50207: IFFALSE 50236
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
50209: LD_VAR 0 3
50213: PPUSH
50214: LD_VAR 0 7
50218: PUSH
50219: LD_INT 2
50221: ARRAY
50222: PPUSH
50223: LD_VAR 0 7
50227: PUSH
50228: LD_INT 3
50230: ARRAY
50231: PPUSH
50232: CALL_OW 117
// break ;
50236: GO 50240
// end ;
50238: GO 49722
50240: POP
50241: POP
// end ; end ;
50242: GO 48438
50244: POP
50245: POP
// end ;
50246: LD_VAR 0 1
50250: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
50251: LD_INT 0
50253: PPUSH
50254: PPUSH
50255: PPUSH
50256: PPUSH
// if not mc_bases then
50257: LD_EXP 116
50261: NOT
50262: IFFALSE 50266
// exit ;
50264: GO 50427
// for i = 1 to mc_bases do
50266: LD_ADDR_VAR 0 2
50270: PUSH
50271: DOUBLE
50272: LD_INT 1
50274: DEC
50275: ST_TO_ADDR
50276: LD_EXP 116
50280: PUSH
50281: FOR_TO
50282: IFFALSE 50425
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
50284: LD_ADDR_VAR 0 4
50288: PUSH
50289: LD_EXP 135
50293: PUSH
50294: LD_VAR 0 2
50298: ARRAY
50299: PUSH
50300: LD_EXP 138
50304: PUSH
50305: LD_VAR 0 2
50309: ARRAY
50310: UNION
50311: PPUSH
50312: LD_INT 33
50314: PUSH
50315: LD_INT 2
50317: PUSH
50318: EMPTY
50319: LIST
50320: LIST
50321: PPUSH
50322: CALL_OW 72
50326: ST_TO_ADDR
// if tmp then
50327: LD_VAR 0 4
50331: IFFALSE 50423
// for j in tmp do
50333: LD_ADDR_VAR 0 3
50337: PUSH
50338: LD_VAR 0 4
50342: PUSH
50343: FOR_IN
50344: IFFALSE 50421
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
50346: LD_VAR 0 3
50350: PPUSH
50351: CALL_OW 312
50355: NOT
50356: PUSH
50357: LD_VAR 0 3
50361: PPUSH
50362: CALL_OW 256
50366: PUSH
50367: LD_INT 250
50369: GREATEREQUAL
50370: AND
50371: IFFALSE 50384
// Connect ( j ) else
50373: LD_VAR 0 3
50377: PPUSH
50378: CALL 73579 0 1
50382: GO 50419
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
50384: LD_VAR 0 3
50388: PPUSH
50389: CALL_OW 256
50393: PUSH
50394: LD_INT 250
50396: LESS
50397: PUSH
50398: LD_VAR 0 3
50402: PPUSH
50403: CALL_OW 312
50407: AND
50408: IFFALSE 50419
// ComUnlink ( j ) ;
50410: LD_VAR 0 3
50414: PPUSH
50415: CALL_OW 136
50419: GO 50343
50421: POP
50422: POP
// end ;
50423: GO 50281
50425: POP
50426: POP
// end ;
50427: LD_VAR 0 1
50431: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
50432: LD_INT 0
50434: PPUSH
50435: PPUSH
50436: PPUSH
50437: PPUSH
50438: PPUSH
// if not mc_bases then
50439: LD_EXP 116
50443: NOT
50444: IFFALSE 50448
// exit ;
50446: GO 50893
// for i = 1 to mc_bases do
50448: LD_ADDR_VAR 0 2
50452: PUSH
50453: DOUBLE
50454: LD_INT 1
50456: DEC
50457: ST_TO_ADDR
50458: LD_EXP 116
50462: PUSH
50463: FOR_TO
50464: IFFALSE 50891
// begin if not mc_produce [ i ] then
50466: LD_EXP 137
50470: PUSH
50471: LD_VAR 0 2
50475: ARRAY
50476: NOT
50477: IFFALSE 50481
// continue ;
50479: GO 50463
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50481: LD_ADDR_VAR 0 5
50485: PUSH
50486: LD_EXP 116
50490: PUSH
50491: LD_VAR 0 2
50495: ARRAY
50496: PPUSH
50497: LD_INT 30
50499: PUSH
50500: LD_INT 3
50502: PUSH
50503: EMPTY
50504: LIST
50505: LIST
50506: PPUSH
50507: CALL_OW 72
50511: ST_TO_ADDR
// if not fac then
50512: LD_VAR 0 5
50516: NOT
50517: IFFALSE 50521
// continue ;
50519: GO 50463
// for j in fac do
50521: LD_ADDR_VAR 0 3
50525: PUSH
50526: LD_VAR 0 5
50530: PUSH
50531: FOR_IN
50532: IFFALSE 50887
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50534: LD_VAR 0 3
50538: PPUSH
50539: CALL_OW 461
50543: PUSH
50544: LD_INT 2
50546: NONEQUAL
50547: PUSH
50548: LD_VAR 0 3
50552: PPUSH
50553: LD_INT 15
50555: PPUSH
50556: CALL 73207 0 2
50560: PUSH
50561: LD_INT 4
50563: ARRAY
50564: OR
50565: IFFALSE 50569
// continue ;
50567: GO 50531
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50569: LD_VAR 0 3
50573: PPUSH
50574: LD_EXP 137
50578: PUSH
50579: LD_VAR 0 2
50583: ARRAY
50584: PUSH
50585: LD_INT 1
50587: ARRAY
50588: PUSH
50589: LD_INT 1
50591: ARRAY
50592: PPUSH
50593: LD_EXP 137
50597: PUSH
50598: LD_VAR 0 2
50602: ARRAY
50603: PUSH
50604: LD_INT 1
50606: ARRAY
50607: PUSH
50608: LD_INT 2
50610: ARRAY
50611: PPUSH
50612: LD_EXP 137
50616: PUSH
50617: LD_VAR 0 2
50621: ARRAY
50622: PUSH
50623: LD_INT 1
50625: ARRAY
50626: PUSH
50627: LD_INT 3
50629: ARRAY
50630: PPUSH
50631: LD_EXP 137
50635: PUSH
50636: LD_VAR 0 2
50640: ARRAY
50641: PUSH
50642: LD_INT 1
50644: ARRAY
50645: PUSH
50646: LD_INT 4
50648: ARRAY
50649: PPUSH
50650: CALL_OW 448
50654: PUSH
50655: LD_VAR 0 3
50659: PPUSH
50660: LD_EXP 137
50664: PUSH
50665: LD_VAR 0 2
50669: ARRAY
50670: PUSH
50671: LD_INT 1
50673: ARRAY
50674: PUSH
50675: LD_INT 1
50677: ARRAY
50678: PUSH
50679: LD_EXP 137
50683: PUSH
50684: LD_VAR 0 2
50688: ARRAY
50689: PUSH
50690: LD_INT 1
50692: ARRAY
50693: PUSH
50694: LD_INT 2
50696: ARRAY
50697: PUSH
50698: LD_EXP 137
50702: PUSH
50703: LD_VAR 0 2
50707: ARRAY
50708: PUSH
50709: LD_INT 1
50711: ARRAY
50712: PUSH
50713: LD_INT 3
50715: ARRAY
50716: PUSH
50717: LD_EXP 137
50721: PUSH
50722: LD_VAR 0 2
50726: ARRAY
50727: PUSH
50728: LD_INT 1
50730: ARRAY
50731: PUSH
50732: LD_INT 4
50734: ARRAY
50735: PUSH
50736: EMPTY
50737: LIST
50738: LIST
50739: LIST
50740: LIST
50741: PPUSH
50742: CALL 76974 0 2
50746: AND
50747: IFFALSE 50885
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50749: LD_VAR 0 3
50753: PPUSH
50754: LD_EXP 137
50758: PUSH
50759: LD_VAR 0 2
50763: ARRAY
50764: PUSH
50765: LD_INT 1
50767: ARRAY
50768: PUSH
50769: LD_INT 1
50771: ARRAY
50772: PPUSH
50773: LD_EXP 137
50777: PUSH
50778: LD_VAR 0 2
50782: ARRAY
50783: PUSH
50784: LD_INT 1
50786: ARRAY
50787: PUSH
50788: LD_INT 2
50790: ARRAY
50791: PPUSH
50792: LD_EXP 137
50796: PUSH
50797: LD_VAR 0 2
50801: ARRAY
50802: PUSH
50803: LD_INT 1
50805: ARRAY
50806: PUSH
50807: LD_INT 3
50809: ARRAY
50810: PPUSH
50811: LD_EXP 137
50815: PUSH
50816: LD_VAR 0 2
50820: ARRAY
50821: PUSH
50822: LD_INT 1
50824: ARRAY
50825: PUSH
50826: LD_INT 4
50828: ARRAY
50829: PPUSH
50830: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50834: LD_ADDR_VAR 0 4
50838: PUSH
50839: LD_EXP 137
50843: PUSH
50844: LD_VAR 0 2
50848: ARRAY
50849: PPUSH
50850: LD_INT 1
50852: PPUSH
50853: CALL_OW 3
50857: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50858: LD_ADDR_EXP 137
50862: PUSH
50863: LD_EXP 137
50867: PPUSH
50868: LD_VAR 0 2
50872: PPUSH
50873: LD_VAR 0 4
50877: PPUSH
50878: CALL_OW 1
50882: ST_TO_ADDR
// break ;
50883: GO 50887
// end ; end ;
50885: GO 50531
50887: POP
50888: POP
// end ;
50889: GO 50463
50891: POP
50892: POP
// end ;
50893: LD_VAR 0 1
50897: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
50898: LD_INT 0
50900: PPUSH
50901: PPUSH
50902: PPUSH
// if not mc_bases then
50903: LD_EXP 116
50907: NOT
50908: IFFALSE 50912
// exit ;
50910: GO 51001
// for i = 1 to mc_bases do
50912: LD_ADDR_VAR 0 2
50916: PUSH
50917: DOUBLE
50918: LD_INT 1
50920: DEC
50921: ST_TO_ADDR
50922: LD_EXP 116
50926: PUSH
50927: FOR_TO
50928: IFFALSE 50999
// begin if mc_attack [ i ] then
50930: LD_EXP 136
50934: PUSH
50935: LD_VAR 0 2
50939: ARRAY
50940: IFFALSE 50997
// begin tmp := mc_attack [ i ] [ 1 ] ;
50942: LD_ADDR_VAR 0 3
50946: PUSH
50947: LD_EXP 136
50951: PUSH
50952: LD_VAR 0 2
50956: ARRAY
50957: PUSH
50958: LD_INT 1
50960: ARRAY
50961: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50962: LD_ADDR_EXP 136
50966: PUSH
50967: LD_EXP 136
50971: PPUSH
50972: LD_VAR 0 2
50976: PPUSH
50977: EMPTY
50978: PPUSH
50979: CALL_OW 1
50983: ST_TO_ADDR
// Attack ( tmp ) ;
50984: LD_VAR 0 3
50988: PPUSH
50989: CALL 122010 0 1
// exit ;
50993: POP
50994: POP
50995: GO 51001
// end ; end ;
50997: GO 50927
50999: POP
51000: POP
// end ;
51001: LD_VAR 0 1
51005: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
51006: LD_INT 0
51008: PPUSH
51009: PPUSH
51010: PPUSH
51011: PPUSH
51012: PPUSH
51013: PPUSH
51014: PPUSH
// if not mc_bases then
51015: LD_EXP 116
51019: NOT
51020: IFFALSE 51024
// exit ;
51022: GO 51734
// for i = 1 to mc_bases do
51024: LD_ADDR_VAR 0 2
51028: PUSH
51029: DOUBLE
51030: LD_INT 1
51032: DEC
51033: ST_TO_ADDR
51034: LD_EXP 116
51038: PUSH
51039: FOR_TO
51040: IFFALSE 51732
// begin if not mc_bases [ i ] then
51042: LD_EXP 116
51046: PUSH
51047: LD_VAR 0 2
51051: ARRAY
51052: NOT
51053: IFFALSE 51057
// continue ;
51055: GO 51039
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
51057: LD_ADDR_VAR 0 7
51061: PUSH
51062: LD_EXP 116
51066: PUSH
51067: LD_VAR 0 2
51071: ARRAY
51072: PUSH
51073: LD_INT 1
51075: ARRAY
51076: PPUSH
51077: CALL 67408 0 1
51081: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
51082: LD_ADDR_EXP 139
51086: PUSH
51087: LD_EXP 139
51091: PPUSH
51092: LD_VAR 0 2
51096: PPUSH
51097: LD_EXP 116
51101: PUSH
51102: LD_VAR 0 2
51106: ARRAY
51107: PUSH
51108: LD_INT 1
51110: ARRAY
51111: PPUSH
51112: CALL_OW 255
51116: PPUSH
51117: LD_EXP 141
51121: PUSH
51122: LD_VAR 0 2
51126: ARRAY
51127: PPUSH
51128: CALL 67373 0 2
51132: PPUSH
51133: CALL_OW 1
51137: ST_TO_ADDR
// if not mc_scan [ i ] then
51138: LD_EXP 139
51142: PUSH
51143: LD_VAR 0 2
51147: ARRAY
51148: NOT
51149: IFFALSE 51327
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
51151: LD_ADDR_EXP 159
51155: PUSH
51156: LD_EXP 159
51160: PPUSH
51161: LD_VAR 0 2
51165: PPUSH
51166: LD_INT 0
51168: PPUSH
51169: CALL_OW 1
51173: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51174: LD_ADDR_VAR 0 4
51178: PUSH
51179: LD_EXP 116
51183: PUSH
51184: LD_VAR 0 2
51188: ARRAY
51189: PPUSH
51190: LD_INT 2
51192: PUSH
51193: LD_INT 25
51195: PUSH
51196: LD_INT 5
51198: PUSH
51199: EMPTY
51200: LIST
51201: LIST
51202: PUSH
51203: LD_INT 25
51205: PUSH
51206: LD_INT 8
51208: PUSH
51209: EMPTY
51210: LIST
51211: LIST
51212: PUSH
51213: LD_INT 25
51215: PUSH
51216: LD_INT 9
51218: PUSH
51219: EMPTY
51220: LIST
51221: LIST
51222: PUSH
51223: EMPTY
51224: LIST
51225: LIST
51226: LIST
51227: LIST
51228: PPUSH
51229: CALL_OW 72
51233: ST_TO_ADDR
// if not tmp then
51234: LD_VAR 0 4
51238: NOT
51239: IFFALSE 51243
// continue ;
51241: GO 51039
// for j in tmp do
51243: LD_ADDR_VAR 0 3
51247: PUSH
51248: LD_VAR 0 4
51252: PUSH
51253: FOR_IN
51254: IFFALSE 51325
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
51256: LD_VAR 0 3
51260: PPUSH
51261: CALL_OW 310
51265: PPUSH
51266: CALL_OW 266
51270: PUSH
51271: LD_INT 5
51273: EQUAL
51274: PUSH
51275: LD_VAR 0 3
51279: PPUSH
51280: CALL_OW 257
51284: PUSH
51285: LD_INT 1
51287: EQUAL
51288: AND
51289: PUSH
51290: LD_VAR 0 3
51294: PPUSH
51295: CALL_OW 459
51299: NOT
51300: AND
51301: PUSH
51302: LD_VAR 0 7
51306: AND
51307: IFFALSE 51323
// ComChangeProfession ( j , class ) ;
51309: LD_VAR 0 3
51313: PPUSH
51314: LD_VAR 0 7
51318: PPUSH
51319: CALL_OW 123
51323: GO 51253
51325: POP
51326: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] then
51327: LD_EXP 139
51331: PUSH
51332: LD_VAR 0 2
51336: ARRAY
51337: PUSH
51338: LD_EXP 159
51342: PUSH
51343: LD_VAR 0 2
51347: ARRAY
51348: NOT
51349: AND
51350: PUSH
51351: LD_EXP 138
51355: PUSH
51356: LD_VAR 0 2
51360: ARRAY
51361: NOT
51362: AND
51363: IFFALSE 51614
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
51365: LD_ADDR_EXP 159
51369: PUSH
51370: LD_EXP 159
51374: PPUSH
51375: LD_VAR 0 2
51379: PPUSH
51380: LD_INT 1
51382: PPUSH
51383: CALL_OW 1
51387: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51388: LD_ADDR_VAR 0 4
51392: PUSH
51393: LD_EXP 116
51397: PUSH
51398: LD_VAR 0 2
51402: ARRAY
51403: PPUSH
51404: LD_INT 2
51406: PUSH
51407: LD_INT 25
51409: PUSH
51410: LD_INT 1
51412: PUSH
51413: EMPTY
51414: LIST
51415: LIST
51416: PUSH
51417: LD_INT 25
51419: PUSH
51420: LD_INT 5
51422: PUSH
51423: EMPTY
51424: LIST
51425: LIST
51426: PUSH
51427: LD_INT 25
51429: PUSH
51430: LD_INT 8
51432: PUSH
51433: EMPTY
51434: LIST
51435: LIST
51436: PUSH
51437: LD_INT 25
51439: PUSH
51440: LD_INT 9
51442: PUSH
51443: EMPTY
51444: LIST
51445: LIST
51446: PUSH
51447: EMPTY
51448: LIST
51449: LIST
51450: LIST
51451: LIST
51452: LIST
51453: PPUSH
51454: CALL_OW 72
51458: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
51459: LD_ADDR_VAR 0 4
51463: PUSH
51464: LD_VAR 0 4
51468: PUSH
51469: LD_VAR 0 4
51473: PPUSH
51474: LD_INT 18
51476: PPUSH
51477: CALL 99877 0 2
51481: DIFF
51482: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
51483: LD_VAR 0 4
51487: NOT
51488: PUSH
51489: LD_EXP 116
51493: PUSH
51494: LD_VAR 0 2
51498: ARRAY
51499: PPUSH
51500: LD_INT 2
51502: PUSH
51503: LD_INT 30
51505: PUSH
51506: LD_INT 4
51508: PUSH
51509: EMPTY
51510: LIST
51511: LIST
51512: PUSH
51513: LD_INT 30
51515: PUSH
51516: LD_INT 5
51518: PUSH
51519: EMPTY
51520: LIST
51521: LIST
51522: PUSH
51523: EMPTY
51524: LIST
51525: LIST
51526: LIST
51527: PPUSH
51528: CALL_OW 72
51532: NOT
51533: AND
51534: IFFALSE 51596
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
51536: LD_ADDR_VAR 0 4
51540: PUSH
51541: LD_EXP 116
51545: PUSH
51546: LD_VAR 0 2
51550: ARRAY
51551: PPUSH
51552: LD_INT 2
51554: PUSH
51555: LD_INT 25
51557: PUSH
51558: LD_INT 2
51560: PUSH
51561: EMPTY
51562: LIST
51563: LIST
51564: PUSH
51565: LD_INT 25
51567: PUSH
51568: LD_INT 3
51570: PUSH
51571: EMPTY
51572: LIST
51573: LIST
51574: PUSH
51575: LD_INT 25
51577: PUSH
51578: LD_INT 4
51580: PUSH
51581: EMPTY
51582: LIST
51583: LIST
51584: PUSH
51585: EMPTY
51586: LIST
51587: LIST
51588: LIST
51589: LIST
51590: PPUSH
51591: CALL_OW 72
51595: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
51596: LD_VAR 0 2
51600: PPUSH
51601: LD_VAR 0 4
51605: PPUSH
51606: CALL 126719 0 2
// exit ;
51610: POP
51611: POP
51612: GO 51734
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
51614: LD_EXP 139
51618: PUSH
51619: LD_VAR 0 2
51623: ARRAY
51624: PUSH
51625: LD_EXP 159
51629: PUSH
51630: LD_VAR 0 2
51634: ARRAY
51635: NOT
51636: AND
51637: PUSH
51638: LD_EXP 138
51642: PUSH
51643: LD_VAR 0 2
51647: ARRAY
51648: AND
51649: IFFALSE 51730
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
51651: LD_ADDR_EXP 159
51655: PUSH
51656: LD_EXP 159
51660: PPUSH
51661: LD_VAR 0 2
51665: PPUSH
51666: LD_INT 1
51668: PPUSH
51669: CALL_OW 1
51673: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
51674: LD_ADDR_VAR 0 4
51678: PUSH
51679: LD_EXP 138
51683: PUSH
51684: LD_VAR 0 2
51688: ARRAY
51689: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
51690: LD_ADDR_EXP 138
51694: PUSH
51695: LD_EXP 138
51699: PPUSH
51700: LD_VAR 0 2
51704: PPUSH
51705: EMPTY
51706: PPUSH
51707: CALL_OW 1
51711: ST_TO_ADDR
// Defend ( i , tmp ) ;
51712: LD_VAR 0 2
51716: PPUSH
51717: LD_VAR 0 4
51721: PPUSH
51722: CALL 127289 0 2
// exit ;
51726: POP
51727: POP
51728: GO 51734
// end ; end ;
51730: GO 51039
51732: POP
51733: POP
// end ;
51734: LD_VAR 0 1
51738: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
51739: LD_INT 0
51741: PPUSH
51742: PPUSH
51743: PPUSH
51744: PPUSH
51745: PPUSH
51746: PPUSH
51747: PPUSH
51748: PPUSH
51749: PPUSH
51750: PPUSH
51751: PPUSH
// if not mc_bases then
51752: LD_EXP 116
51756: NOT
51757: IFFALSE 51761
// exit ;
51759: GO 52848
// for i = 1 to mc_bases do
51761: LD_ADDR_VAR 0 2
51765: PUSH
51766: DOUBLE
51767: LD_INT 1
51769: DEC
51770: ST_TO_ADDR
51771: LD_EXP 116
51775: PUSH
51776: FOR_TO
51777: IFFALSE 52846
// begin tmp := mc_lab [ i ] ;
51779: LD_ADDR_VAR 0 6
51783: PUSH
51784: LD_EXP 149
51788: PUSH
51789: LD_VAR 0 2
51793: ARRAY
51794: ST_TO_ADDR
// if not tmp then
51795: LD_VAR 0 6
51799: NOT
51800: IFFALSE 51804
// continue ;
51802: GO 51776
// idle_lab := 0 ;
51804: LD_ADDR_VAR 0 11
51808: PUSH
51809: LD_INT 0
51811: ST_TO_ADDR
// for j in tmp do
51812: LD_ADDR_VAR 0 3
51816: PUSH
51817: LD_VAR 0 6
51821: PUSH
51822: FOR_IN
51823: IFFALSE 52842
// begin researching := false ;
51825: LD_ADDR_VAR 0 10
51829: PUSH
51830: LD_INT 0
51832: ST_TO_ADDR
// side := GetSide ( j ) ;
51833: LD_ADDR_VAR 0 4
51837: PUSH
51838: LD_VAR 0 3
51842: PPUSH
51843: CALL_OW 255
51847: ST_TO_ADDR
// if not mc_tech [ side ] then
51848: LD_EXP 143
51852: PUSH
51853: LD_VAR 0 4
51857: ARRAY
51858: NOT
51859: IFFALSE 51863
// continue ;
51861: GO 51822
// if BuildingStatus ( j ) = bs_idle then
51863: LD_VAR 0 3
51867: PPUSH
51868: CALL_OW 461
51872: PUSH
51873: LD_INT 2
51875: EQUAL
51876: IFFALSE 52064
// begin if idle_lab and UnitsInside ( j ) < 6 then
51878: LD_VAR 0 11
51882: PUSH
51883: LD_VAR 0 3
51887: PPUSH
51888: CALL_OW 313
51892: PUSH
51893: LD_INT 6
51895: LESS
51896: AND
51897: IFFALSE 51968
// begin tmp2 := UnitsInside ( idle_lab ) ;
51899: LD_ADDR_VAR 0 9
51903: PUSH
51904: LD_VAR 0 11
51908: PPUSH
51909: CALL_OW 313
51913: ST_TO_ADDR
// if tmp2 then
51914: LD_VAR 0 9
51918: IFFALSE 51960
// for x in tmp2 do
51920: LD_ADDR_VAR 0 7
51924: PUSH
51925: LD_VAR 0 9
51929: PUSH
51930: FOR_IN
51931: IFFALSE 51958
// begin ComExitBuilding ( x ) ;
51933: LD_VAR 0 7
51937: PPUSH
51938: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51942: LD_VAR 0 7
51946: PPUSH
51947: LD_VAR 0 3
51951: PPUSH
51952: CALL_OW 180
// end ;
51956: GO 51930
51958: POP
51959: POP
// idle_lab := 0 ;
51960: LD_ADDR_VAR 0 11
51964: PUSH
51965: LD_INT 0
51967: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
51968: LD_ADDR_VAR 0 5
51972: PUSH
51973: LD_EXP 143
51977: PUSH
51978: LD_VAR 0 4
51982: ARRAY
51983: PUSH
51984: FOR_IN
51985: IFFALSE 52045
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
51987: LD_VAR 0 3
51991: PPUSH
51992: LD_VAR 0 5
51996: PPUSH
51997: CALL_OW 430
52001: PUSH
52002: LD_VAR 0 4
52006: PPUSH
52007: LD_VAR 0 5
52011: PPUSH
52012: CALL 66478 0 2
52016: AND
52017: IFFALSE 52043
// begin researching := true ;
52019: LD_ADDR_VAR 0 10
52023: PUSH
52024: LD_INT 1
52026: ST_TO_ADDR
// ComResearch ( j , t ) ;
52027: LD_VAR 0 3
52031: PPUSH
52032: LD_VAR 0 5
52036: PPUSH
52037: CALL_OW 124
// break ;
52041: GO 52045
// end ;
52043: GO 51984
52045: POP
52046: POP
// if not researching then
52047: LD_VAR 0 10
52051: NOT
52052: IFFALSE 52064
// idle_lab := j ;
52054: LD_ADDR_VAR 0 11
52058: PUSH
52059: LD_VAR 0 3
52063: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
52064: LD_VAR 0 3
52068: PPUSH
52069: CALL_OW 461
52073: PUSH
52074: LD_INT 10
52076: EQUAL
52077: IFFALSE 52665
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
52079: LD_EXP 145
52083: PUSH
52084: LD_VAR 0 2
52088: ARRAY
52089: NOT
52090: PUSH
52091: LD_EXP 146
52095: PUSH
52096: LD_VAR 0 2
52100: ARRAY
52101: NOT
52102: AND
52103: PUSH
52104: LD_EXP 143
52108: PUSH
52109: LD_VAR 0 4
52113: ARRAY
52114: PUSH
52115: LD_INT 1
52117: GREATER
52118: AND
52119: IFFALSE 52250
// begin ComCancel ( j ) ;
52121: LD_VAR 0 3
52125: PPUSH
52126: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
52130: LD_ADDR_EXP 143
52134: PUSH
52135: LD_EXP 143
52139: PPUSH
52140: LD_VAR 0 4
52144: PPUSH
52145: LD_EXP 143
52149: PUSH
52150: LD_VAR 0 4
52154: ARRAY
52155: PPUSH
52156: LD_EXP 143
52160: PUSH
52161: LD_VAR 0 4
52165: ARRAY
52166: PUSH
52167: LD_INT 1
52169: MINUS
52170: PPUSH
52171: LD_EXP 143
52175: PUSH
52176: LD_VAR 0 4
52180: ARRAY
52181: PPUSH
52182: LD_INT 0
52184: PPUSH
52185: CALL 70026 0 4
52189: PPUSH
52190: CALL_OW 1
52194: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
52195: LD_ADDR_EXP 143
52199: PUSH
52200: LD_EXP 143
52204: PPUSH
52205: LD_VAR 0 4
52209: PPUSH
52210: LD_EXP 143
52214: PUSH
52215: LD_VAR 0 4
52219: ARRAY
52220: PPUSH
52221: LD_EXP 143
52225: PUSH
52226: LD_VAR 0 4
52230: ARRAY
52231: PPUSH
52232: LD_INT 1
52234: PPUSH
52235: LD_INT 0
52237: PPUSH
52238: CALL 70026 0 4
52242: PPUSH
52243: CALL_OW 1
52247: ST_TO_ADDR
// continue ;
52248: GO 51822
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
52250: LD_EXP 145
52254: PUSH
52255: LD_VAR 0 2
52259: ARRAY
52260: PUSH
52261: LD_EXP 146
52265: PUSH
52266: LD_VAR 0 2
52270: ARRAY
52271: NOT
52272: AND
52273: IFFALSE 52400
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
52275: LD_ADDR_EXP 146
52279: PUSH
52280: LD_EXP 146
52284: PPUSH
52285: LD_VAR 0 2
52289: PUSH
52290: LD_EXP 146
52294: PUSH
52295: LD_VAR 0 2
52299: ARRAY
52300: PUSH
52301: LD_INT 1
52303: PLUS
52304: PUSH
52305: EMPTY
52306: LIST
52307: LIST
52308: PPUSH
52309: LD_EXP 145
52313: PUSH
52314: LD_VAR 0 2
52318: ARRAY
52319: PUSH
52320: LD_INT 1
52322: ARRAY
52323: PPUSH
52324: CALL 70608 0 3
52328: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
52329: LD_EXP 145
52333: PUSH
52334: LD_VAR 0 2
52338: ARRAY
52339: PUSH
52340: LD_INT 1
52342: ARRAY
52343: PPUSH
52344: LD_INT 112
52346: PPUSH
52347: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
52351: LD_ADDR_VAR 0 9
52355: PUSH
52356: LD_EXP 145
52360: PUSH
52361: LD_VAR 0 2
52365: ARRAY
52366: PPUSH
52367: LD_INT 1
52369: PPUSH
52370: CALL_OW 3
52374: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
52375: LD_ADDR_EXP 145
52379: PUSH
52380: LD_EXP 145
52384: PPUSH
52385: LD_VAR 0 2
52389: PPUSH
52390: LD_VAR 0 9
52394: PPUSH
52395: CALL_OW 1
52399: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
52400: LD_EXP 145
52404: PUSH
52405: LD_VAR 0 2
52409: ARRAY
52410: PUSH
52411: LD_EXP 146
52415: PUSH
52416: LD_VAR 0 2
52420: ARRAY
52421: AND
52422: PUSH
52423: LD_EXP 146
52427: PUSH
52428: LD_VAR 0 2
52432: ARRAY
52433: PUSH
52434: LD_INT 1
52436: ARRAY
52437: PPUSH
52438: CALL_OW 310
52442: NOT
52443: AND
52444: PUSH
52445: LD_VAR 0 3
52449: PPUSH
52450: CALL_OW 313
52454: PUSH
52455: LD_INT 6
52457: EQUAL
52458: AND
52459: IFFALSE 52515
// begin tmp2 := UnitsInside ( j ) ;
52461: LD_ADDR_VAR 0 9
52465: PUSH
52466: LD_VAR 0 3
52470: PPUSH
52471: CALL_OW 313
52475: ST_TO_ADDR
// if tmp2 = 6 then
52476: LD_VAR 0 9
52480: PUSH
52481: LD_INT 6
52483: EQUAL
52484: IFFALSE 52515
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
52486: LD_VAR 0 9
52490: PUSH
52491: LD_INT 1
52493: ARRAY
52494: PPUSH
52495: LD_INT 112
52497: PPUSH
52498: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
52502: LD_VAR 0 9
52506: PUSH
52507: LD_INT 1
52509: ARRAY
52510: PPUSH
52511: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
52515: LD_EXP 146
52519: PUSH
52520: LD_VAR 0 2
52524: ARRAY
52525: PUSH
52526: LD_EXP 146
52530: PUSH
52531: LD_VAR 0 2
52535: ARRAY
52536: PUSH
52537: LD_INT 1
52539: ARRAY
52540: PPUSH
52541: CALL_OW 314
52545: NOT
52546: AND
52547: PUSH
52548: LD_EXP 146
52552: PUSH
52553: LD_VAR 0 2
52557: ARRAY
52558: PUSH
52559: LD_INT 1
52561: ARRAY
52562: PPUSH
52563: CALL_OW 310
52567: NOT
52568: AND
52569: IFFALSE 52595
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
52571: LD_EXP 146
52575: PUSH
52576: LD_VAR 0 2
52580: ARRAY
52581: PUSH
52582: LD_INT 1
52584: ARRAY
52585: PPUSH
52586: LD_VAR 0 3
52590: PPUSH
52591: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
52595: LD_EXP 146
52599: PUSH
52600: LD_VAR 0 2
52604: ARRAY
52605: PUSH
52606: LD_INT 1
52608: ARRAY
52609: PPUSH
52610: CALL_OW 310
52614: PUSH
52615: LD_EXP 146
52619: PUSH
52620: LD_VAR 0 2
52624: ARRAY
52625: PUSH
52626: LD_INT 1
52628: ARRAY
52629: PPUSH
52630: CALL_OW 310
52634: PPUSH
52635: CALL_OW 461
52639: PUSH
52640: LD_INT 3
52642: NONEQUAL
52643: AND
52644: IFFALSE 52665
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
52646: LD_EXP 146
52650: PUSH
52651: LD_VAR 0 2
52655: ARRAY
52656: PUSH
52657: LD_INT 1
52659: ARRAY
52660: PPUSH
52661: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52665: LD_VAR 0 3
52669: PPUSH
52670: CALL_OW 461
52674: PUSH
52675: LD_INT 6
52677: EQUAL
52678: PUSH
52679: LD_VAR 0 6
52683: PUSH
52684: LD_INT 1
52686: GREATER
52687: AND
52688: IFFALSE 52840
// begin sci := [ ] ;
52690: LD_ADDR_VAR 0 8
52694: PUSH
52695: EMPTY
52696: ST_TO_ADDR
// for x in ( tmp diff j ) do
52697: LD_ADDR_VAR 0 7
52701: PUSH
52702: LD_VAR 0 6
52706: PUSH
52707: LD_VAR 0 3
52711: DIFF
52712: PUSH
52713: FOR_IN
52714: IFFALSE 52766
// begin if sci = 6 then
52716: LD_VAR 0 8
52720: PUSH
52721: LD_INT 6
52723: EQUAL
52724: IFFALSE 52728
// break ;
52726: GO 52766
// if BuildingStatus ( x ) = bs_idle then
52728: LD_VAR 0 7
52732: PPUSH
52733: CALL_OW 461
52737: PUSH
52738: LD_INT 2
52740: EQUAL
52741: IFFALSE 52764
// sci := sci ^ UnitsInside ( x ) ;
52743: LD_ADDR_VAR 0 8
52747: PUSH
52748: LD_VAR 0 8
52752: PUSH
52753: LD_VAR 0 7
52757: PPUSH
52758: CALL_OW 313
52762: ADD
52763: ST_TO_ADDR
// end ;
52764: GO 52713
52766: POP
52767: POP
// if not sci then
52768: LD_VAR 0 8
52772: NOT
52773: IFFALSE 52777
// continue ;
52775: GO 51822
// for x in sci do
52777: LD_ADDR_VAR 0 7
52781: PUSH
52782: LD_VAR 0 8
52786: PUSH
52787: FOR_IN
52788: IFFALSE 52838
// if IsInUnit ( x ) and not HasTask ( x ) then
52790: LD_VAR 0 7
52794: PPUSH
52795: CALL_OW 310
52799: PUSH
52800: LD_VAR 0 7
52804: PPUSH
52805: CALL_OW 314
52809: NOT
52810: AND
52811: IFFALSE 52836
// begin ComExitBuilding ( x ) ;
52813: LD_VAR 0 7
52817: PPUSH
52818: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52822: LD_VAR 0 7
52826: PPUSH
52827: LD_VAR 0 3
52831: PPUSH
52832: CALL_OW 180
// end ;
52836: GO 52787
52838: POP
52839: POP
// end ; end ;
52840: GO 51822
52842: POP
52843: POP
// end ;
52844: GO 51776
52846: POP
52847: POP
// end ;
52848: LD_VAR 0 1
52852: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
52853: LD_INT 0
52855: PPUSH
52856: PPUSH
// if not mc_bases then
52857: LD_EXP 116
52861: NOT
52862: IFFALSE 52866
// exit ;
52864: GO 52947
// for i = 1 to mc_bases do
52866: LD_ADDR_VAR 0 2
52870: PUSH
52871: DOUBLE
52872: LD_INT 1
52874: DEC
52875: ST_TO_ADDR
52876: LD_EXP 116
52880: PUSH
52881: FOR_TO
52882: IFFALSE 52945
// if mc_mines [ i ] and mc_miners [ i ] then
52884: LD_EXP 129
52888: PUSH
52889: LD_VAR 0 2
52893: ARRAY
52894: PUSH
52895: LD_EXP 130
52899: PUSH
52900: LD_VAR 0 2
52904: ARRAY
52905: AND
52906: IFFALSE 52943
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
52908: LD_EXP 130
52912: PUSH
52913: LD_VAR 0 2
52917: ARRAY
52918: PUSH
52919: LD_INT 1
52921: ARRAY
52922: PPUSH
52923: CALL_OW 255
52927: PPUSH
52928: LD_EXP 129
52932: PUSH
52933: LD_VAR 0 2
52937: ARRAY
52938: PPUSH
52939: CALL 67561 0 2
52943: GO 52881
52945: POP
52946: POP
// end ;
52947: LD_VAR 0 1
52951: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
52952: LD_INT 0
52954: PPUSH
52955: PPUSH
52956: PPUSH
52957: PPUSH
52958: PPUSH
52959: PPUSH
52960: PPUSH
52961: PPUSH
// if not mc_bases or not mc_parking then
52962: LD_EXP 116
52966: NOT
52967: PUSH
52968: LD_EXP 140
52972: NOT
52973: OR
52974: IFFALSE 52978
// exit ;
52976: GO 53688
// for i = 1 to mc_bases do
52978: LD_ADDR_VAR 0 2
52982: PUSH
52983: DOUBLE
52984: LD_INT 1
52986: DEC
52987: ST_TO_ADDR
52988: LD_EXP 116
52992: PUSH
52993: FOR_TO
52994: IFFALSE 53686
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
52996: LD_EXP 116
53000: PUSH
53001: LD_VAR 0 2
53005: ARRAY
53006: NOT
53007: PUSH
53008: LD_EXP 140
53012: PUSH
53013: LD_VAR 0 2
53017: ARRAY
53018: NOT
53019: OR
53020: IFFALSE 53024
// continue ;
53022: GO 52993
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
53024: LD_ADDR_VAR 0 5
53028: PUSH
53029: LD_EXP 116
53033: PUSH
53034: LD_VAR 0 2
53038: ARRAY
53039: PUSH
53040: LD_INT 1
53042: ARRAY
53043: PPUSH
53044: CALL_OW 255
53048: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53049: LD_ADDR_VAR 0 6
53053: PUSH
53054: LD_EXP 116
53058: PUSH
53059: LD_VAR 0 2
53063: ARRAY
53064: PPUSH
53065: LD_INT 30
53067: PUSH
53068: LD_INT 3
53070: PUSH
53071: EMPTY
53072: LIST
53073: LIST
53074: PPUSH
53075: CALL_OW 72
53079: ST_TO_ADDR
// if not fac then
53080: LD_VAR 0 6
53084: NOT
53085: IFFALSE 53136
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53087: LD_ADDR_VAR 0 6
53091: PUSH
53092: LD_EXP 116
53096: PUSH
53097: LD_VAR 0 2
53101: ARRAY
53102: PPUSH
53103: LD_INT 2
53105: PUSH
53106: LD_INT 30
53108: PUSH
53109: LD_INT 0
53111: PUSH
53112: EMPTY
53113: LIST
53114: LIST
53115: PUSH
53116: LD_INT 30
53118: PUSH
53119: LD_INT 1
53121: PUSH
53122: EMPTY
53123: LIST
53124: LIST
53125: PUSH
53126: EMPTY
53127: LIST
53128: LIST
53129: LIST
53130: PPUSH
53131: CALL_OW 72
53135: ST_TO_ADDR
// if not fac then
53136: LD_VAR 0 6
53140: NOT
53141: IFFALSE 53145
// continue ;
53143: GO 52993
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
53145: LD_ADDR_VAR 0 7
53149: PUSH
53150: LD_EXP 140
53154: PUSH
53155: LD_VAR 0 2
53159: ARRAY
53160: PPUSH
53161: LD_INT 22
53163: PUSH
53164: LD_VAR 0 5
53168: PUSH
53169: EMPTY
53170: LIST
53171: LIST
53172: PUSH
53173: LD_INT 21
53175: PUSH
53176: LD_INT 2
53178: PUSH
53179: EMPTY
53180: LIST
53181: LIST
53182: PUSH
53183: LD_INT 3
53185: PUSH
53186: LD_INT 24
53188: PUSH
53189: LD_INT 1000
53191: PUSH
53192: EMPTY
53193: LIST
53194: LIST
53195: PUSH
53196: EMPTY
53197: LIST
53198: LIST
53199: PUSH
53200: EMPTY
53201: LIST
53202: LIST
53203: LIST
53204: PPUSH
53205: CALL_OW 70
53209: ST_TO_ADDR
// for j in fac do
53210: LD_ADDR_VAR 0 3
53214: PUSH
53215: LD_VAR 0 6
53219: PUSH
53220: FOR_IN
53221: IFFALSE 53302
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
53223: LD_ADDR_VAR 0 7
53227: PUSH
53228: LD_VAR 0 7
53232: PUSH
53233: LD_INT 22
53235: PUSH
53236: LD_VAR 0 5
53240: PUSH
53241: EMPTY
53242: LIST
53243: LIST
53244: PUSH
53245: LD_INT 91
53247: PUSH
53248: LD_VAR 0 3
53252: PUSH
53253: LD_INT 15
53255: PUSH
53256: EMPTY
53257: LIST
53258: LIST
53259: LIST
53260: PUSH
53261: LD_INT 21
53263: PUSH
53264: LD_INT 2
53266: PUSH
53267: EMPTY
53268: LIST
53269: LIST
53270: PUSH
53271: LD_INT 3
53273: PUSH
53274: LD_INT 24
53276: PUSH
53277: LD_INT 1000
53279: PUSH
53280: EMPTY
53281: LIST
53282: LIST
53283: PUSH
53284: EMPTY
53285: LIST
53286: LIST
53287: PUSH
53288: EMPTY
53289: LIST
53290: LIST
53291: LIST
53292: LIST
53293: PPUSH
53294: CALL_OW 69
53298: UNION
53299: ST_TO_ADDR
53300: GO 53220
53302: POP
53303: POP
// if not vehs then
53304: LD_VAR 0 7
53308: NOT
53309: IFFALSE 53335
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53311: LD_ADDR_EXP 128
53315: PUSH
53316: LD_EXP 128
53320: PPUSH
53321: LD_VAR 0 2
53325: PPUSH
53326: EMPTY
53327: PPUSH
53328: CALL_OW 1
53332: ST_TO_ADDR
// continue ;
53333: GO 52993
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53335: LD_ADDR_VAR 0 8
53339: PUSH
53340: LD_EXP 116
53344: PUSH
53345: LD_VAR 0 2
53349: ARRAY
53350: PPUSH
53351: LD_INT 30
53353: PUSH
53354: LD_INT 3
53356: PUSH
53357: EMPTY
53358: LIST
53359: LIST
53360: PPUSH
53361: CALL_OW 72
53365: ST_TO_ADDR
// if tmp then
53366: LD_VAR 0 8
53370: IFFALSE 53473
// begin for j in tmp do
53372: LD_ADDR_VAR 0 3
53376: PUSH
53377: LD_VAR 0 8
53381: PUSH
53382: FOR_IN
53383: IFFALSE 53471
// for k in UnitsInside ( j ) do
53385: LD_ADDR_VAR 0 4
53389: PUSH
53390: LD_VAR 0 3
53394: PPUSH
53395: CALL_OW 313
53399: PUSH
53400: FOR_IN
53401: IFFALSE 53467
// if k then
53403: LD_VAR 0 4
53407: IFFALSE 53465
// if not k in mc_repair_vehicle [ i ] then
53409: LD_VAR 0 4
53413: PUSH
53414: LD_EXP 128
53418: PUSH
53419: LD_VAR 0 2
53423: ARRAY
53424: IN
53425: NOT
53426: IFFALSE 53465
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
53428: LD_ADDR_EXP 128
53432: PUSH
53433: LD_EXP 128
53437: PPUSH
53438: LD_VAR 0 2
53442: PPUSH
53443: LD_EXP 128
53447: PUSH
53448: LD_VAR 0 2
53452: ARRAY
53453: PUSH
53454: LD_VAR 0 4
53458: UNION
53459: PPUSH
53460: CALL_OW 1
53464: ST_TO_ADDR
53465: GO 53400
53467: POP
53468: POP
53469: GO 53382
53471: POP
53472: POP
// end ; if not mc_repair_vehicle [ i ] then
53473: LD_EXP 128
53477: PUSH
53478: LD_VAR 0 2
53482: ARRAY
53483: NOT
53484: IFFALSE 53488
// continue ;
53486: GO 52993
// for j in mc_repair_vehicle [ i ] do
53488: LD_ADDR_VAR 0 3
53492: PUSH
53493: LD_EXP 128
53497: PUSH
53498: LD_VAR 0 2
53502: ARRAY
53503: PUSH
53504: FOR_IN
53505: IFFALSE 53682
// begin if GetClass ( j ) <> 3 then
53507: LD_VAR 0 3
53511: PPUSH
53512: CALL_OW 257
53516: PUSH
53517: LD_INT 3
53519: NONEQUAL
53520: IFFALSE 53561
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
53522: LD_ADDR_EXP 128
53526: PUSH
53527: LD_EXP 128
53531: PPUSH
53532: LD_VAR 0 2
53536: PPUSH
53537: LD_EXP 128
53541: PUSH
53542: LD_VAR 0 2
53546: ARRAY
53547: PUSH
53548: LD_VAR 0 3
53552: DIFF
53553: PPUSH
53554: CALL_OW 1
53558: ST_TO_ADDR
// continue ;
53559: GO 53504
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53561: LD_VAR 0 3
53565: PPUSH
53566: CALL_OW 311
53570: NOT
53571: PUSH
53572: LD_VAR 0 3
53576: PUSH
53577: LD_EXP 119
53581: PUSH
53582: LD_VAR 0 2
53586: ARRAY
53587: PUSH
53588: LD_INT 1
53590: ARRAY
53591: IN
53592: NOT
53593: AND
53594: PUSH
53595: LD_VAR 0 3
53599: PUSH
53600: LD_EXP 119
53604: PUSH
53605: LD_VAR 0 2
53609: ARRAY
53610: PUSH
53611: LD_INT 2
53613: ARRAY
53614: IN
53615: NOT
53616: AND
53617: IFFALSE 53680
// begin if IsInUnit ( j ) then
53619: LD_VAR 0 3
53623: PPUSH
53624: CALL_OW 310
53628: IFFALSE 53641
// ComExitBuilding ( j ) else
53630: LD_VAR 0 3
53634: PPUSH
53635: CALL_OW 122
53639: GO 53680
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
53641: LD_VAR 0 3
53645: PPUSH
53646: LD_VAR 0 7
53650: PUSH
53651: LD_INT 1
53653: ARRAY
53654: PPUSH
53655: CALL 104215 0 2
53659: NOT
53660: IFFALSE 53680
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
53662: LD_VAR 0 3
53666: PPUSH
53667: LD_VAR 0 7
53671: PUSH
53672: LD_INT 1
53674: ARRAY
53675: PPUSH
53676: CALL_OW 129
// end ; end ;
53680: GO 53504
53682: POP
53683: POP
// end ;
53684: GO 52993
53686: POP
53687: POP
// end ;
53688: LD_VAR 0 1
53692: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53693: LD_INT 0
53695: PPUSH
53696: PPUSH
53697: PPUSH
53698: PPUSH
53699: PPUSH
53700: PPUSH
53701: PPUSH
53702: PPUSH
53703: PPUSH
53704: PPUSH
53705: PPUSH
// if not mc_bases then
53706: LD_EXP 116
53710: NOT
53711: IFFALSE 53715
// exit ;
53713: GO 54517
// for i = 1 to mc_bases do
53715: LD_ADDR_VAR 0 2
53719: PUSH
53720: DOUBLE
53721: LD_INT 1
53723: DEC
53724: ST_TO_ADDR
53725: LD_EXP 116
53729: PUSH
53730: FOR_TO
53731: IFFALSE 54515
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
53733: LD_EXP 144
53737: PUSH
53738: LD_VAR 0 2
53742: ARRAY
53743: NOT
53744: PUSH
53745: LD_EXP 119
53749: PUSH
53750: LD_VAR 0 2
53754: ARRAY
53755: PUSH
53756: LD_INT 1
53758: ARRAY
53759: OR
53760: PUSH
53761: LD_EXP 119
53765: PUSH
53766: LD_VAR 0 2
53770: ARRAY
53771: PUSH
53772: LD_INT 2
53774: ARRAY
53775: OR
53776: PUSH
53777: LD_EXP 142
53781: PUSH
53782: LD_VAR 0 2
53786: ARRAY
53787: PPUSH
53788: LD_INT 1
53790: PPUSH
53791: CALL_OW 325
53795: NOT
53796: OR
53797: PUSH
53798: LD_EXP 139
53802: PUSH
53803: LD_VAR 0 2
53807: ARRAY
53808: OR
53809: IFFALSE 53813
// continue ;
53811: GO 53730
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
53813: LD_ADDR_VAR 0 8
53817: PUSH
53818: LD_EXP 116
53822: PUSH
53823: LD_VAR 0 2
53827: ARRAY
53828: PPUSH
53829: LD_INT 25
53831: PUSH
53832: LD_INT 4
53834: PUSH
53835: EMPTY
53836: LIST
53837: LIST
53838: PUSH
53839: LD_INT 50
53841: PUSH
53842: EMPTY
53843: LIST
53844: PUSH
53845: LD_INT 3
53847: PUSH
53848: LD_INT 60
53850: PUSH
53851: EMPTY
53852: LIST
53853: PUSH
53854: EMPTY
53855: LIST
53856: LIST
53857: PUSH
53858: EMPTY
53859: LIST
53860: LIST
53861: LIST
53862: PPUSH
53863: CALL_OW 72
53867: PUSH
53868: LD_EXP 120
53872: PUSH
53873: LD_VAR 0 2
53877: ARRAY
53878: DIFF
53879: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53880: LD_ADDR_VAR 0 9
53884: PUSH
53885: LD_EXP 116
53889: PUSH
53890: LD_VAR 0 2
53894: ARRAY
53895: PPUSH
53896: LD_INT 2
53898: PUSH
53899: LD_INT 30
53901: PUSH
53902: LD_INT 0
53904: PUSH
53905: EMPTY
53906: LIST
53907: LIST
53908: PUSH
53909: LD_INT 30
53911: PUSH
53912: LD_INT 1
53914: PUSH
53915: EMPTY
53916: LIST
53917: LIST
53918: PUSH
53919: EMPTY
53920: LIST
53921: LIST
53922: LIST
53923: PPUSH
53924: CALL_OW 72
53928: ST_TO_ADDR
// if not tmp or not dep then
53929: LD_VAR 0 8
53933: NOT
53934: PUSH
53935: LD_VAR 0 9
53939: NOT
53940: OR
53941: IFFALSE 53945
// continue ;
53943: GO 53730
// side := GetSide ( tmp [ 1 ] ) ;
53945: LD_ADDR_VAR 0 11
53949: PUSH
53950: LD_VAR 0 8
53954: PUSH
53955: LD_INT 1
53957: ARRAY
53958: PPUSH
53959: CALL_OW 255
53963: ST_TO_ADDR
// dep := dep [ 1 ] ;
53964: LD_ADDR_VAR 0 9
53968: PUSH
53969: LD_VAR 0 9
53973: PUSH
53974: LD_INT 1
53976: ARRAY
53977: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
53978: LD_ADDR_VAR 0 7
53982: PUSH
53983: LD_EXP 144
53987: PUSH
53988: LD_VAR 0 2
53992: ARRAY
53993: PPUSH
53994: LD_INT 22
53996: PUSH
53997: LD_INT 0
53999: PUSH
54000: EMPTY
54001: LIST
54002: LIST
54003: PUSH
54004: LD_INT 25
54006: PUSH
54007: LD_INT 12
54009: PUSH
54010: EMPTY
54011: LIST
54012: LIST
54013: PUSH
54014: EMPTY
54015: LIST
54016: LIST
54017: PPUSH
54018: CALL_OW 70
54022: PUSH
54023: LD_INT 22
54025: PUSH
54026: LD_INT 0
54028: PUSH
54029: EMPTY
54030: LIST
54031: LIST
54032: PUSH
54033: LD_INT 25
54035: PUSH
54036: LD_INT 12
54038: PUSH
54039: EMPTY
54040: LIST
54041: LIST
54042: PUSH
54043: LD_INT 91
54045: PUSH
54046: LD_VAR 0 9
54050: PUSH
54051: LD_INT 20
54053: PUSH
54054: EMPTY
54055: LIST
54056: LIST
54057: LIST
54058: PUSH
54059: EMPTY
54060: LIST
54061: LIST
54062: LIST
54063: PPUSH
54064: CALL_OW 69
54068: UNION
54069: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
54070: LD_ADDR_VAR 0 10
54074: PUSH
54075: LD_EXP 144
54079: PUSH
54080: LD_VAR 0 2
54084: ARRAY
54085: PPUSH
54086: LD_INT 81
54088: PUSH
54089: LD_VAR 0 11
54093: PUSH
54094: EMPTY
54095: LIST
54096: LIST
54097: PPUSH
54098: CALL_OW 70
54102: ST_TO_ADDR
// if not apes or danger_at_area then
54103: LD_VAR 0 7
54107: NOT
54108: PUSH
54109: LD_VAR 0 10
54113: OR
54114: IFFALSE 54164
// begin if mc_taming [ i ] then
54116: LD_EXP 147
54120: PUSH
54121: LD_VAR 0 2
54125: ARRAY
54126: IFFALSE 54162
// begin MC_Reset ( i , 121 ) ;
54128: LD_VAR 0 2
54132: PPUSH
54133: LD_INT 121
54135: PPUSH
54136: CALL 39297 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54140: LD_ADDR_EXP 147
54144: PUSH
54145: LD_EXP 147
54149: PPUSH
54150: LD_VAR 0 2
54154: PPUSH
54155: EMPTY
54156: PPUSH
54157: CALL_OW 1
54161: ST_TO_ADDR
// end ; continue ;
54162: GO 53730
// end ; for j in tmp do
54164: LD_ADDR_VAR 0 3
54168: PUSH
54169: LD_VAR 0 8
54173: PUSH
54174: FOR_IN
54175: IFFALSE 54511
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
54177: LD_VAR 0 3
54181: PUSH
54182: LD_EXP 147
54186: PUSH
54187: LD_VAR 0 2
54191: ARRAY
54192: IN
54193: NOT
54194: PUSH
54195: LD_EXP 147
54199: PUSH
54200: LD_VAR 0 2
54204: ARRAY
54205: PUSH
54206: LD_INT 3
54208: LESS
54209: AND
54210: IFFALSE 54268
// begin SetTag ( j , 121 ) ;
54212: LD_VAR 0 3
54216: PPUSH
54217: LD_INT 121
54219: PPUSH
54220: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
54224: LD_ADDR_EXP 147
54228: PUSH
54229: LD_EXP 147
54233: PPUSH
54234: LD_VAR 0 2
54238: PUSH
54239: LD_EXP 147
54243: PUSH
54244: LD_VAR 0 2
54248: ARRAY
54249: PUSH
54250: LD_INT 1
54252: PLUS
54253: PUSH
54254: EMPTY
54255: LIST
54256: LIST
54257: PPUSH
54258: LD_VAR 0 3
54262: PPUSH
54263: CALL 70608 0 3
54267: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
54268: LD_VAR 0 3
54272: PUSH
54273: LD_EXP 147
54277: PUSH
54278: LD_VAR 0 2
54282: ARRAY
54283: IN
54284: IFFALSE 54509
// begin if GetClass ( j ) <> 4 then
54286: LD_VAR 0 3
54290: PPUSH
54291: CALL_OW 257
54295: PUSH
54296: LD_INT 4
54298: NONEQUAL
54299: IFFALSE 54352
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
54301: LD_ADDR_EXP 147
54305: PUSH
54306: LD_EXP 147
54310: PPUSH
54311: LD_VAR 0 2
54315: PPUSH
54316: LD_EXP 147
54320: PUSH
54321: LD_VAR 0 2
54325: ARRAY
54326: PUSH
54327: LD_VAR 0 3
54331: DIFF
54332: PPUSH
54333: CALL_OW 1
54337: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54338: LD_VAR 0 3
54342: PPUSH
54343: LD_INT 0
54345: PPUSH
54346: CALL_OW 109
// continue ;
54350: GO 54174
// end ; if IsInUnit ( j ) then
54352: LD_VAR 0 3
54356: PPUSH
54357: CALL_OW 310
54361: IFFALSE 54372
// ComExitBuilding ( j ) ;
54363: LD_VAR 0 3
54367: PPUSH
54368: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
54372: LD_ADDR_VAR 0 6
54376: PUSH
54377: LD_VAR 0 7
54381: PPUSH
54382: LD_VAR 0 3
54386: PPUSH
54387: CALL_OW 74
54391: ST_TO_ADDR
// if not ape then
54392: LD_VAR 0 6
54396: NOT
54397: IFFALSE 54401
// break ;
54399: GO 54511
// x := GetX ( ape ) ;
54401: LD_ADDR_VAR 0 4
54405: PUSH
54406: LD_VAR 0 6
54410: PPUSH
54411: CALL_OW 250
54415: ST_TO_ADDR
// y := GetY ( ape ) ;
54416: LD_ADDR_VAR 0 5
54420: PUSH
54421: LD_VAR 0 6
54425: PPUSH
54426: CALL_OW 251
54430: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
54431: LD_VAR 0 4
54435: PPUSH
54436: LD_VAR 0 5
54440: PPUSH
54441: CALL_OW 488
54445: NOT
54446: PUSH
54447: LD_VAR 0 11
54451: PPUSH
54452: LD_VAR 0 4
54456: PPUSH
54457: LD_VAR 0 5
54461: PPUSH
54462: LD_INT 20
54464: PPUSH
54465: CALL 71504 0 4
54469: PUSH
54470: LD_INT 4
54472: ARRAY
54473: OR
54474: IFFALSE 54478
// break ;
54476: GO 54511
// if not HasTask ( j ) then
54478: LD_VAR 0 3
54482: PPUSH
54483: CALL_OW 314
54487: NOT
54488: IFFALSE 54509
// ComTameXY ( j , x , y ) ;
54490: LD_VAR 0 3
54494: PPUSH
54495: LD_VAR 0 4
54499: PPUSH
54500: LD_VAR 0 5
54504: PPUSH
54505: CALL_OW 131
// end ; end ;
54509: GO 54174
54511: POP
54512: POP
// end ;
54513: GO 53730
54515: POP
54516: POP
// end ;
54517: LD_VAR 0 1
54521: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
54522: LD_INT 0
54524: PPUSH
54525: PPUSH
54526: PPUSH
54527: PPUSH
54528: PPUSH
54529: PPUSH
54530: PPUSH
54531: PPUSH
// if not mc_bases then
54532: LD_EXP 116
54536: NOT
54537: IFFALSE 54541
// exit ;
54539: GO 55167
// for i = 1 to mc_bases do
54541: LD_ADDR_VAR 0 2
54545: PUSH
54546: DOUBLE
54547: LD_INT 1
54549: DEC
54550: ST_TO_ADDR
54551: LD_EXP 116
54555: PUSH
54556: FOR_TO
54557: IFFALSE 55165
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
54559: LD_EXP 145
54563: PUSH
54564: LD_VAR 0 2
54568: ARRAY
54569: NOT
54570: PUSH
54571: LD_EXP 145
54575: PUSH
54576: LD_VAR 0 2
54580: ARRAY
54581: PPUSH
54582: LD_INT 25
54584: PUSH
54585: LD_INT 12
54587: PUSH
54588: EMPTY
54589: LIST
54590: LIST
54591: PPUSH
54592: CALL_OW 72
54596: NOT
54597: OR
54598: IFFALSE 54602
// continue ;
54600: GO 54556
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
54602: LD_ADDR_VAR 0 5
54606: PUSH
54607: LD_EXP 145
54611: PUSH
54612: LD_VAR 0 2
54616: ARRAY
54617: PUSH
54618: LD_INT 1
54620: ARRAY
54621: PPUSH
54622: CALL_OW 255
54626: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
54627: LD_VAR 0 5
54631: PPUSH
54632: LD_INT 2
54634: PPUSH
54635: CALL_OW 325
54639: IFFALSE 54892
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54641: LD_ADDR_VAR 0 4
54645: PUSH
54646: LD_EXP 145
54650: PUSH
54651: LD_VAR 0 2
54655: ARRAY
54656: PPUSH
54657: LD_INT 25
54659: PUSH
54660: LD_INT 16
54662: PUSH
54663: EMPTY
54664: LIST
54665: LIST
54666: PPUSH
54667: CALL_OW 72
54671: ST_TO_ADDR
// if tmp < 6 then
54672: LD_VAR 0 4
54676: PUSH
54677: LD_INT 6
54679: LESS
54680: IFFALSE 54892
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54682: LD_ADDR_VAR 0 6
54686: PUSH
54687: LD_EXP 116
54691: PUSH
54692: LD_VAR 0 2
54696: ARRAY
54697: PPUSH
54698: LD_INT 2
54700: PUSH
54701: LD_INT 30
54703: PUSH
54704: LD_INT 0
54706: PUSH
54707: EMPTY
54708: LIST
54709: LIST
54710: PUSH
54711: LD_INT 30
54713: PUSH
54714: LD_INT 1
54716: PUSH
54717: EMPTY
54718: LIST
54719: LIST
54720: PUSH
54721: EMPTY
54722: LIST
54723: LIST
54724: LIST
54725: PPUSH
54726: CALL_OW 72
54730: ST_TO_ADDR
// if depot then
54731: LD_VAR 0 6
54735: IFFALSE 54892
// begin selected := 0 ;
54737: LD_ADDR_VAR 0 7
54741: PUSH
54742: LD_INT 0
54744: ST_TO_ADDR
// for j in depot do
54745: LD_ADDR_VAR 0 3
54749: PUSH
54750: LD_VAR 0 6
54754: PUSH
54755: FOR_IN
54756: IFFALSE 54787
// begin if UnitsInside ( j ) < 6 then
54758: LD_VAR 0 3
54762: PPUSH
54763: CALL_OW 313
54767: PUSH
54768: LD_INT 6
54770: LESS
54771: IFFALSE 54785
// begin selected := j ;
54773: LD_ADDR_VAR 0 7
54777: PUSH
54778: LD_VAR 0 3
54782: ST_TO_ADDR
// break ;
54783: GO 54787
// end ; end ;
54785: GO 54755
54787: POP
54788: POP
// if selected then
54789: LD_VAR 0 7
54793: IFFALSE 54892
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54795: LD_ADDR_VAR 0 3
54799: PUSH
54800: LD_EXP 145
54804: PUSH
54805: LD_VAR 0 2
54809: ARRAY
54810: PPUSH
54811: LD_INT 25
54813: PUSH
54814: LD_INT 12
54816: PUSH
54817: EMPTY
54818: LIST
54819: LIST
54820: PPUSH
54821: CALL_OW 72
54825: PUSH
54826: FOR_IN
54827: IFFALSE 54890
// if not HasTask ( j ) then
54829: LD_VAR 0 3
54833: PPUSH
54834: CALL_OW 314
54838: NOT
54839: IFFALSE 54888
// begin if not IsInUnit ( j ) then
54841: LD_VAR 0 3
54845: PPUSH
54846: CALL_OW 310
54850: NOT
54851: IFFALSE 54867
// ComEnterUnit ( j , selected ) ;
54853: LD_VAR 0 3
54857: PPUSH
54858: LD_VAR 0 7
54862: PPUSH
54863: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
54867: LD_VAR 0 3
54871: PPUSH
54872: LD_INT 16
54874: PPUSH
54875: CALL_OW 183
// AddComExitBuilding ( j ) ;
54879: LD_VAR 0 3
54883: PPUSH
54884: CALL_OW 182
// end ;
54888: GO 54826
54890: POP
54891: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
54892: LD_VAR 0 5
54896: PPUSH
54897: LD_INT 11
54899: PPUSH
54900: CALL_OW 325
54904: IFFALSE 55163
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54906: LD_ADDR_VAR 0 4
54910: PUSH
54911: LD_EXP 145
54915: PUSH
54916: LD_VAR 0 2
54920: ARRAY
54921: PPUSH
54922: LD_INT 25
54924: PUSH
54925: LD_INT 16
54927: PUSH
54928: EMPTY
54929: LIST
54930: LIST
54931: PPUSH
54932: CALL_OW 72
54936: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
54937: LD_VAR 0 4
54941: PUSH
54942: LD_INT 6
54944: GREATEREQUAL
54945: PUSH
54946: LD_VAR 0 5
54950: PPUSH
54951: LD_INT 2
54953: PPUSH
54954: CALL_OW 325
54958: NOT
54959: OR
54960: IFFALSE 55163
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
54962: LD_ADDR_VAR 0 8
54966: PUSH
54967: LD_EXP 116
54971: PUSH
54972: LD_VAR 0 2
54976: ARRAY
54977: PPUSH
54978: LD_INT 2
54980: PUSH
54981: LD_INT 30
54983: PUSH
54984: LD_INT 4
54986: PUSH
54987: EMPTY
54988: LIST
54989: LIST
54990: PUSH
54991: LD_INT 30
54993: PUSH
54994: LD_INT 5
54996: PUSH
54997: EMPTY
54998: LIST
54999: LIST
55000: PUSH
55001: EMPTY
55002: LIST
55003: LIST
55004: LIST
55005: PPUSH
55006: CALL_OW 72
55010: ST_TO_ADDR
// if barracks then
55011: LD_VAR 0 8
55015: IFFALSE 55163
// begin selected := 0 ;
55017: LD_ADDR_VAR 0 7
55021: PUSH
55022: LD_INT 0
55024: ST_TO_ADDR
// for j in barracks do
55025: LD_ADDR_VAR 0 3
55029: PUSH
55030: LD_VAR 0 8
55034: PUSH
55035: FOR_IN
55036: IFFALSE 55067
// begin if UnitsInside ( j ) < 6 then
55038: LD_VAR 0 3
55042: PPUSH
55043: CALL_OW 313
55047: PUSH
55048: LD_INT 6
55050: LESS
55051: IFFALSE 55065
// begin selected := j ;
55053: LD_ADDR_VAR 0 7
55057: PUSH
55058: LD_VAR 0 3
55062: ST_TO_ADDR
// break ;
55063: GO 55067
// end ; end ;
55065: GO 55035
55067: POP
55068: POP
// if selected then
55069: LD_VAR 0 7
55073: IFFALSE 55163
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
55075: LD_ADDR_VAR 0 3
55079: PUSH
55080: LD_EXP 145
55084: PUSH
55085: LD_VAR 0 2
55089: ARRAY
55090: PPUSH
55091: LD_INT 25
55093: PUSH
55094: LD_INT 12
55096: PUSH
55097: EMPTY
55098: LIST
55099: LIST
55100: PPUSH
55101: CALL_OW 72
55105: PUSH
55106: FOR_IN
55107: IFFALSE 55161
// if not IsInUnit ( j ) and not HasTask ( j ) then
55109: LD_VAR 0 3
55113: PPUSH
55114: CALL_OW 310
55118: NOT
55119: PUSH
55120: LD_VAR 0 3
55124: PPUSH
55125: CALL_OW 314
55129: NOT
55130: AND
55131: IFFALSE 55159
// begin ComEnterUnit ( j , selected ) ;
55133: LD_VAR 0 3
55137: PPUSH
55138: LD_VAR 0 7
55142: PPUSH
55143: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
55147: LD_VAR 0 3
55151: PPUSH
55152: LD_INT 15
55154: PPUSH
55155: CALL_OW 183
// end ;
55159: GO 55106
55161: POP
55162: POP
// end ; end ; end ; end ; end ;
55163: GO 54556
55165: POP
55166: POP
// end ;
55167: LD_VAR 0 1
55171: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
55172: LD_INT 0
55174: PPUSH
55175: PPUSH
55176: PPUSH
55177: PPUSH
// if not mc_bases then
55178: LD_EXP 116
55182: NOT
55183: IFFALSE 55187
// exit ;
55185: GO 55365
// for i = 1 to mc_bases do
55187: LD_ADDR_VAR 0 2
55191: PUSH
55192: DOUBLE
55193: LD_INT 1
55195: DEC
55196: ST_TO_ADDR
55197: LD_EXP 116
55201: PUSH
55202: FOR_TO
55203: IFFALSE 55363
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
55205: LD_ADDR_VAR 0 4
55209: PUSH
55210: LD_EXP 116
55214: PUSH
55215: LD_VAR 0 2
55219: ARRAY
55220: PPUSH
55221: LD_INT 25
55223: PUSH
55224: LD_INT 9
55226: PUSH
55227: EMPTY
55228: LIST
55229: LIST
55230: PPUSH
55231: CALL_OW 72
55235: ST_TO_ADDR
// if not tmp then
55236: LD_VAR 0 4
55240: NOT
55241: IFFALSE 55245
// continue ;
55243: GO 55202
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
55245: LD_EXP 142
55249: PUSH
55250: LD_VAR 0 2
55254: ARRAY
55255: PPUSH
55256: LD_INT 29
55258: PPUSH
55259: CALL_OW 325
55263: NOT
55264: PUSH
55265: LD_EXP 142
55269: PUSH
55270: LD_VAR 0 2
55274: ARRAY
55275: PPUSH
55276: LD_INT 28
55278: PPUSH
55279: CALL_OW 325
55283: NOT
55284: AND
55285: IFFALSE 55289
// continue ;
55287: GO 55202
// for j in tmp do
55289: LD_ADDR_VAR 0 3
55293: PUSH
55294: LD_VAR 0 4
55298: PUSH
55299: FOR_IN
55300: IFFALSE 55359
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
55302: LD_VAR 0 3
55306: PUSH
55307: LD_EXP 119
55311: PUSH
55312: LD_VAR 0 2
55316: ARRAY
55317: PUSH
55318: LD_INT 1
55320: ARRAY
55321: IN
55322: NOT
55323: PUSH
55324: LD_VAR 0 3
55328: PUSH
55329: LD_EXP 119
55333: PUSH
55334: LD_VAR 0 2
55338: ARRAY
55339: PUSH
55340: LD_INT 2
55342: ARRAY
55343: IN
55344: NOT
55345: AND
55346: IFFALSE 55357
// ComSpaceTimeShoot ( j ) ;
55348: LD_VAR 0 3
55352: PPUSH
55353: CALL 66569 0 1
55357: GO 55299
55359: POP
55360: POP
// end ;
55361: GO 55202
55363: POP
55364: POP
// end ;
55365: LD_VAR 0 1
55369: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
55370: LD_INT 0
55372: PPUSH
55373: PPUSH
55374: PPUSH
55375: PPUSH
55376: PPUSH
55377: PPUSH
55378: PPUSH
55379: PPUSH
55380: PPUSH
// if not mc_bases then
55381: LD_EXP 116
55385: NOT
55386: IFFALSE 55390
// exit ;
55388: GO 56012
// for i = 1 to mc_bases do
55390: LD_ADDR_VAR 0 2
55394: PUSH
55395: DOUBLE
55396: LD_INT 1
55398: DEC
55399: ST_TO_ADDR
55400: LD_EXP 116
55404: PUSH
55405: FOR_TO
55406: IFFALSE 56010
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
55408: LD_EXP 151
55412: PUSH
55413: LD_VAR 0 2
55417: ARRAY
55418: NOT
55419: PUSH
55420: LD_INT 38
55422: PPUSH
55423: LD_EXP 142
55427: PUSH
55428: LD_VAR 0 2
55432: ARRAY
55433: PPUSH
55434: CALL_OW 321
55438: PUSH
55439: LD_INT 2
55441: NONEQUAL
55442: OR
55443: IFFALSE 55447
// continue ;
55445: GO 55405
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
55447: LD_ADDR_VAR 0 8
55451: PUSH
55452: LD_EXP 116
55456: PUSH
55457: LD_VAR 0 2
55461: ARRAY
55462: PPUSH
55463: LD_INT 30
55465: PUSH
55466: LD_INT 34
55468: PUSH
55469: EMPTY
55470: LIST
55471: LIST
55472: PPUSH
55473: CALL_OW 72
55477: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
55478: LD_ADDR_VAR 0 9
55482: PUSH
55483: LD_EXP 116
55487: PUSH
55488: LD_VAR 0 2
55492: ARRAY
55493: PPUSH
55494: LD_INT 25
55496: PUSH
55497: LD_INT 4
55499: PUSH
55500: EMPTY
55501: LIST
55502: LIST
55503: PPUSH
55504: CALL_OW 72
55508: PPUSH
55509: LD_INT 0
55511: PPUSH
55512: CALL 99877 0 2
55516: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
55517: LD_VAR 0 9
55521: NOT
55522: PUSH
55523: LD_VAR 0 8
55527: NOT
55528: OR
55529: PUSH
55530: LD_EXP 116
55534: PUSH
55535: LD_VAR 0 2
55539: ARRAY
55540: PPUSH
55541: LD_INT 124
55543: PPUSH
55544: CALL 99877 0 2
55548: OR
55549: IFFALSE 55553
// continue ;
55551: GO 55405
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
55553: LD_EXP 152
55557: PUSH
55558: LD_VAR 0 2
55562: ARRAY
55563: PUSH
55564: LD_EXP 151
55568: PUSH
55569: LD_VAR 0 2
55573: ARRAY
55574: LESS
55575: PUSH
55576: LD_EXP 152
55580: PUSH
55581: LD_VAR 0 2
55585: ARRAY
55586: PUSH
55587: LD_VAR 0 8
55591: LESS
55592: AND
55593: IFFALSE 56008
// begin tmp := sci [ 1 ] ;
55595: LD_ADDR_VAR 0 7
55599: PUSH
55600: LD_VAR 0 9
55604: PUSH
55605: LD_INT 1
55607: ARRAY
55608: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
55609: LD_VAR 0 7
55613: PPUSH
55614: LD_INT 124
55616: PPUSH
55617: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
55621: LD_ADDR_VAR 0 3
55625: PUSH
55626: DOUBLE
55627: LD_EXP 151
55631: PUSH
55632: LD_VAR 0 2
55636: ARRAY
55637: INC
55638: ST_TO_ADDR
55639: LD_EXP 151
55643: PUSH
55644: LD_VAR 0 2
55648: ARRAY
55649: PUSH
55650: FOR_DOWNTO
55651: IFFALSE 55994
// begin if IsInUnit ( tmp ) then
55653: LD_VAR 0 7
55657: PPUSH
55658: CALL_OW 310
55662: IFFALSE 55673
// ComExitBuilding ( tmp ) ;
55664: LD_VAR 0 7
55668: PPUSH
55669: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55673: LD_INT 35
55675: PPUSH
55676: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55680: LD_VAR 0 7
55684: PPUSH
55685: CALL_OW 310
55689: NOT
55690: PUSH
55691: LD_VAR 0 7
55695: PPUSH
55696: CALL_OW 314
55700: NOT
55701: AND
55702: IFFALSE 55673
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
55704: LD_ADDR_VAR 0 6
55708: PUSH
55709: LD_VAR 0 7
55713: PPUSH
55714: CALL_OW 250
55718: PUSH
55719: LD_VAR 0 7
55723: PPUSH
55724: CALL_OW 251
55728: PUSH
55729: EMPTY
55730: LIST
55731: LIST
55732: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55733: LD_INT 35
55735: PPUSH
55736: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
55740: LD_ADDR_VAR 0 4
55744: PUSH
55745: LD_EXP 151
55749: PUSH
55750: LD_VAR 0 2
55754: ARRAY
55755: PUSH
55756: LD_VAR 0 3
55760: ARRAY
55761: PUSH
55762: LD_INT 1
55764: ARRAY
55765: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
55766: LD_ADDR_VAR 0 5
55770: PUSH
55771: LD_EXP 151
55775: PUSH
55776: LD_VAR 0 2
55780: ARRAY
55781: PUSH
55782: LD_VAR 0 3
55786: ARRAY
55787: PUSH
55788: LD_INT 2
55790: ARRAY
55791: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
55792: LD_VAR 0 7
55796: PPUSH
55797: LD_INT 10
55799: PPUSH
55800: CALL 73207 0 2
55804: PUSH
55805: LD_INT 4
55807: ARRAY
55808: IFFALSE 55846
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
55810: LD_VAR 0 7
55814: PPUSH
55815: LD_VAR 0 6
55819: PUSH
55820: LD_INT 1
55822: ARRAY
55823: PPUSH
55824: LD_VAR 0 6
55828: PUSH
55829: LD_INT 2
55831: ARRAY
55832: PPUSH
55833: CALL_OW 111
// wait ( 0 0$10 ) ;
55837: LD_INT 350
55839: PPUSH
55840: CALL_OW 67
// end else
55844: GO 55872
// begin ComMoveXY ( tmp , x , y ) ;
55846: LD_VAR 0 7
55850: PPUSH
55851: LD_VAR 0 4
55855: PPUSH
55856: LD_VAR 0 5
55860: PPUSH
55861: CALL_OW 111
// wait ( 0 0$3 ) ;
55865: LD_INT 105
55867: PPUSH
55868: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
55872: LD_VAR 0 7
55876: PPUSH
55877: LD_VAR 0 4
55881: PPUSH
55882: LD_VAR 0 5
55886: PPUSH
55887: CALL_OW 307
55891: IFFALSE 55733
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
55893: LD_VAR 0 7
55897: PPUSH
55898: LD_VAR 0 4
55902: PPUSH
55903: LD_VAR 0 5
55907: PPUSH
55908: LD_VAR 0 8
55912: PUSH
55913: LD_VAR 0 3
55917: ARRAY
55918: PPUSH
55919: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
55923: LD_INT 35
55925: PPUSH
55926: CALL_OW 67
// until not HasTask ( tmp ) ;
55930: LD_VAR 0 7
55934: PPUSH
55935: CALL_OW 314
55939: NOT
55940: IFFALSE 55923
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
55942: LD_ADDR_EXP 152
55946: PUSH
55947: LD_EXP 152
55951: PPUSH
55952: LD_VAR 0 2
55956: PUSH
55957: LD_EXP 152
55961: PUSH
55962: LD_VAR 0 2
55966: ARRAY
55967: PUSH
55968: LD_INT 1
55970: PLUS
55971: PUSH
55972: EMPTY
55973: LIST
55974: LIST
55975: PPUSH
55976: LD_VAR 0 8
55980: PUSH
55981: LD_VAR 0 3
55985: ARRAY
55986: PPUSH
55987: CALL 70608 0 3
55991: ST_TO_ADDR
// end ;
55992: GO 55650
55994: POP
55995: POP
// MC_Reset ( i , 124 ) ;
55996: LD_VAR 0 2
56000: PPUSH
56001: LD_INT 124
56003: PPUSH
56004: CALL 39297 0 2
// end ; end ;
56008: GO 55405
56010: POP
56011: POP
// end ;
56012: LD_VAR 0 1
56016: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
56017: LD_INT 0
56019: PPUSH
56020: PPUSH
56021: PPUSH
// if not mc_bases then
56022: LD_EXP 116
56026: NOT
56027: IFFALSE 56031
// exit ;
56029: GO 56637
// for i = 1 to mc_bases do
56031: LD_ADDR_VAR 0 2
56035: PUSH
56036: DOUBLE
56037: LD_INT 1
56039: DEC
56040: ST_TO_ADDR
56041: LD_EXP 116
56045: PUSH
56046: FOR_TO
56047: IFFALSE 56635
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
56049: LD_ADDR_VAR 0 3
56053: PUSH
56054: LD_EXP 116
56058: PUSH
56059: LD_VAR 0 2
56063: ARRAY
56064: PPUSH
56065: LD_INT 25
56067: PUSH
56068: LD_INT 4
56070: PUSH
56071: EMPTY
56072: LIST
56073: LIST
56074: PPUSH
56075: CALL_OW 72
56079: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
56080: LD_VAR 0 3
56084: NOT
56085: PUSH
56086: LD_EXP 153
56090: PUSH
56091: LD_VAR 0 2
56095: ARRAY
56096: NOT
56097: OR
56098: PUSH
56099: LD_EXP 116
56103: PUSH
56104: LD_VAR 0 2
56108: ARRAY
56109: PPUSH
56110: LD_INT 2
56112: PUSH
56113: LD_INT 30
56115: PUSH
56116: LD_INT 0
56118: PUSH
56119: EMPTY
56120: LIST
56121: LIST
56122: PUSH
56123: LD_INT 30
56125: PUSH
56126: LD_INT 1
56128: PUSH
56129: EMPTY
56130: LIST
56131: LIST
56132: PUSH
56133: EMPTY
56134: LIST
56135: LIST
56136: LIST
56137: PPUSH
56138: CALL_OW 72
56142: NOT
56143: OR
56144: IFFALSE 56194
// begin if mc_deposits_finder [ i ] then
56146: LD_EXP 154
56150: PUSH
56151: LD_VAR 0 2
56155: ARRAY
56156: IFFALSE 56192
// begin MC_Reset ( i , 125 ) ;
56158: LD_VAR 0 2
56162: PPUSH
56163: LD_INT 125
56165: PPUSH
56166: CALL 39297 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56170: LD_ADDR_EXP 154
56174: PUSH
56175: LD_EXP 154
56179: PPUSH
56180: LD_VAR 0 2
56184: PPUSH
56185: EMPTY
56186: PPUSH
56187: CALL_OW 1
56191: ST_TO_ADDR
// end ; continue ;
56192: GO 56046
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
56194: LD_EXP 153
56198: PUSH
56199: LD_VAR 0 2
56203: ARRAY
56204: PUSH
56205: LD_INT 1
56207: ARRAY
56208: PUSH
56209: LD_INT 3
56211: ARRAY
56212: PUSH
56213: LD_INT 1
56215: EQUAL
56216: PUSH
56217: LD_INT 20
56219: PPUSH
56220: LD_EXP 142
56224: PUSH
56225: LD_VAR 0 2
56229: ARRAY
56230: PPUSH
56231: CALL_OW 321
56235: PUSH
56236: LD_INT 2
56238: NONEQUAL
56239: AND
56240: IFFALSE 56290
// begin if mc_deposits_finder [ i ] then
56242: LD_EXP 154
56246: PUSH
56247: LD_VAR 0 2
56251: ARRAY
56252: IFFALSE 56288
// begin MC_Reset ( i , 125 ) ;
56254: LD_VAR 0 2
56258: PPUSH
56259: LD_INT 125
56261: PPUSH
56262: CALL 39297 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56266: LD_ADDR_EXP 154
56270: PUSH
56271: LD_EXP 154
56275: PPUSH
56276: LD_VAR 0 2
56280: PPUSH
56281: EMPTY
56282: PPUSH
56283: CALL_OW 1
56287: ST_TO_ADDR
// end ; continue ;
56288: GO 56046
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
56290: LD_EXP 153
56294: PUSH
56295: LD_VAR 0 2
56299: ARRAY
56300: PUSH
56301: LD_INT 1
56303: ARRAY
56304: PUSH
56305: LD_INT 1
56307: ARRAY
56308: PPUSH
56309: LD_EXP 153
56313: PUSH
56314: LD_VAR 0 2
56318: ARRAY
56319: PUSH
56320: LD_INT 1
56322: ARRAY
56323: PUSH
56324: LD_INT 2
56326: ARRAY
56327: PPUSH
56328: LD_EXP 142
56332: PUSH
56333: LD_VAR 0 2
56337: ARRAY
56338: PPUSH
56339: CALL_OW 440
56343: IFFALSE 56386
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
56345: LD_ADDR_EXP 153
56349: PUSH
56350: LD_EXP 153
56354: PPUSH
56355: LD_VAR 0 2
56359: PPUSH
56360: LD_EXP 153
56364: PUSH
56365: LD_VAR 0 2
56369: ARRAY
56370: PPUSH
56371: LD_INT 1
56373: PPUSH
56374: CALL_OW 3
56378: PPUSH
56379: CALL_OW 1
56383: ST_TO_ADDR
56384: GO 56633
// begin if not mc_deposits_finder [ i ] then
56386: LD_EXP 154
56390: PUSH
56391: LD_VAR 0 2
56395: ARRAY
56396: NOT
56397: IFFALSE 56449
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
56399: LD_ADDR_EXP 154
56403: PUSH
56404: LD_EXP 154
56408: PPUSH
56409: LD_VAR 0 2
56413: PPUSH
56414: LD_VAR 0 3
56418: PUSH
56419: LD_INT 1
56421: ARRAY
56422: PUSH
56423: EMPTY
56424: LIST
56425: PPUSH
56426: CALL_OW 1
56430: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
56431: LD_VAR 0 3
56435: PUSH
56436: LD_INT 1
56438: ARRAY
56439: PPUSH
56440: LD_INT 125
56442: PPUSH
56443: CALL_OW 109
// end else
56447: GO 56633
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
56449: LD_EXP 154
56453: PUSH
56454: LD_VAR 0 2
56458: ARRAY
56459: PUSH
56460: LD_INT 1
56462: ARRAY
56463: PPUSH
56464: CALL_OW 310
56468: IFFALSE 56491
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
56470: LD_EXP 154
56474: PUSH
56475: LD_VAR 0 2
56479: ARRAY
56480: PUSH
56481: LD_INT 1
56483: ARRAY
56484: PPUSH
56485: CALL_OW 122
56489: GO 56633
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
56491: LD_EXP 154
56495: PUSH
56496: LD_VAR 0 2
56500: ARRAY
56501: PUSH
56502: LD_INT 1
56504: ARRAY
56505: PPUSH
56506: CALL_OW 314
56510: NOT
56511: PUSH
56512: LD_EXP 154
56516: PUSH
56517: LD_VAR 0 2
56521: ARRAY
56522: PUSH
56523: LD_INT 1
56525: ARRAY
56526: PPUSH
56527: LD_EXP 153
56531: PUSH
56532: LD_VAR 0 2
56536: ARRAY
56537: PUSH
56538: LD_INT 1
56540: ARRAY
56541: PUSH
56542: LD_INT 1
56544: ARRAY
56545: PPUSH
56546: LD_EXP 153
56550: PUSH
56551: LD_VAR 0 2
56555: ARRAY
56556: PUSH
56557: LD_INT 1
56559: ARRAY
56560: PUSH
56561: LD_INT 2
56563: ARRAY
56564: PPUSH
56565: CALL_OW 297
56569: PUSH
56570: LD_INT 6
56572: GREATER
56573: AND
56574: IFFALSE 56633
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
56576: LD_EXP 154
56580: PUSH
56581: LD_VAR 0 2
56585: ARRAY
56586: PUSH
56587: LD_INT 1
56589: ARRAY
56590: PPUSH
56591: LD_EXP 153
56595: PUSH
56596: LD_VAR 0 2
56600: ARRAY
56601: PUSH
56602: LD_INT 1
56604: ARRAY
56605: PUSH
56606: LD_INT 1
56608: ARRAY
56609: PPUSH
56610: LD_EXP 153
56614: PUSH
56615: LD_VAR 0 2
56619: ARRAY
56620: PUSH
56621: LD_INT 1
56623: ARRAY
56624: PUSH
56625: LD_INT 2
56627: ARRAY
56628: PPUSH
56629: CALL_OW 111
// end ; end ; end ;
56633: GO 56046
56635: POP
56636: POP
// end ;
56637: LD_VAR 0 1
56641: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
56642: LD_INT 0
56644: PPUSH
56645: PPUSH
56646: PPUSH
56647: PPUSH
56648: PPUSH
56649: PPUSH
56650: PPUSH
56651: PPUSH
56652: PPUSH
56653: PPUSH
56654: PPUSH
// if not mc_bases then
56655: LD_EXP 116
56659: NOT
56660: IFFALSE 56664
// exit ;
56662: GO 57604
// for i = 1 to mc_bases do
56664: LD_ADDR_VAR 0 2
56668: PUSH
56669: DOUBLE
56670: LD_INT 1
56672: DEC
56673: ST_TO_ADDR
56674: LD_EXP 116
56678: PUSH
56679: FOR_TO
56680: IFFALSE 57602
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56682: LD_EXP 116
56686: PUSH
56687: LD_VAR 0 2
56691: ARRAY
56692: NOT
56693: PUSH
56694: LD_EXP 139
56698: PUSH
56699: LD_VAR 0 2
56703: ARRAY
56704: OR
56705: IFFALSE 56709
// continue ;
56707: GO 56679
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
56709: LD_ADDR_VAR 0 7
56713: PUSH
56714: LD_EXP 116
56718: PUSH
56719: LD_VAR 0 2
56723: ARRAY
56724: PUSH
56725: LD_INT 1
56727: ARRAY
56728: PPUSH
56729: CALL_OW 248
56733: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
56734: LD_VAR 0 7
56738: PUSH
56739: LD_INT 3
56741: EQUAL
56742: PUSH
56743: LD_EXP 135
56747: PUSH
56748: LD_VAR 0 2
56752: ARRAY
56753: PUSH
56754: LD_EXP 138
56758: PUSH
56759: LD_VAR 0 2
56763: ARRAY
56764: UNION
56765: PPUSH
56766: LD_INT 33
56768: PUSH
56769: LD_INT 2
56771: PUSH
56772: EMPTY
56773: LIST
56774: LIST
56775: PPUSH
56776: CALL_OW 72
56780: NOT
56781: OR
56782: IFFALSE 56786
// continue ;
56784: GO 56679
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
56786: LD_ADDR_VAR 0 9
56790: PUSH
56791: LD_EXP 116
56795: PUSH
56796: LD_VAR 0 2
56800: ARRAY
56801: PPUSH
56802: LD_INT 30
56804: PUSH
56805: LD_INT 36
56807: PUSH
56808: EMPTY
56809: LIST
56810: LIST
56811: PPUSH
56812: CALL_OW 72
56816: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
56817: LD_ADDR_VAR 0 10
56821: PUSH
56822: LD_EXP 135
56826: PUSH
56827: LD_VAR 0 2
56831: ARRAY
56832: PPUSH
56833: LD_INT 34
56835: PUSH
56836: LD_INT 31
56838: PUSH
56839: EMPTY
56840: LIST
56841: LIST
56842: PPUSH
56843: CALL_OW 72
56847: ST_TO_ADDR
// if not cts and not mcts then
56848: LD_VAR 0 9
56852: NOT
56853: PUSH
56854: LD_VAR 0 10
56858: NOT
56859: AND
56860: IFFALSE 56864
// continue ;
56862: GO 56679
// x := cts ;
56864: LD_ADDR_VAR 0 11
56868: PUSH
56869: LD_VAR 0 9
56873: ST_TO_ADDR
// if not x then
56874: LD_VAR 0 11
56878: NOT
56879: IFFALSE 56891
// x := mcts ;
56881: LD_ADDR_VAR 0 11
56885: PUSH
56886: LD_VAR 0 10
56890: ST_TO_ADDR
// if not x then
56891: LD_VAR 0 11
56895: NOT
56896: IFFALSE 56900
// continue ;
56898: GO 56679
// if mc_remote_driver [ i ] then
56900: LD_EXP 156
56904: PUSH
56905: LD_VAR 0 2
56909: ARRAY
56910: IFFALSE 57297
// for j in mc_remote_driver [ i ] do
56912: LD_ADDR_VAR 0 3
56916: PUSH
56917: LD_EXP 156
56921: PUSH
56922: LD_VAR 0 2
56926: ARRAY
56927: PUSH
56928: FOR_IN
56929: IFFALSE 57295
// begin if GetClass ( j ) <> 3 then
56931: LD_VAR 0 3
56935: PPUSH
56936: CALL_OW 257
56940: PUSH
56941: LD_INT 3
56943: NONEQUAL
56944: IFFALSE 56997
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
56946: LD_ADDR_EXP 156
56950: PUSH
56951: LD_EXP 156
56955: PPUSH
56956: LD_VAR 0 2
56960: PPUSH
56961: LD_EXP 156
56965: PUSH
56966: LD_VAR 0 2
56970: ARRAY
56971: PUSH
56972: LD_VAR 0 3
56976: DIFF
56977: PPUSH
56978: CALL_OW 1
56982: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56983: LD_VAR 0 3
56987: PPUSH
56988: LD_INT 0
56990: PPUSH
56991: CALL_OW 109
// continue ;
56995: GO 56928
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
56997: LD_EXP 135
57001: PUSH
57002: LD_VAR 0 2
57006: ARRAY
57007: PPUSH
57008: LD_INT 34
57010: PUSH
57011: LD_INT 31
57013: PUSH
57014: EMPTY
57015: LIST
57016: LIST
57017: PUSH
57018: LD_INT 58
57020: PUSH
57021: EMPTY
57022: LIST
57023: PUSH
57024: EMPTY
57025: LIST
57026: LIST
57027: PPUSH
57028: CALL_OW 72
57032: PUSH
57033: LD_VAR 0 3
57037: PPUSH
57038: CALL 99965 0 1
57042: NOT
57043: AND
57044: IFFALSE 57115
// begin if IsInUnit ( j ) then
57046: LD_VAR 0 3
57050: PPUSH
57051: CALL_OW 310
57055: IFFALSE 57066
// ComExitBuilding ( j ) ;
57057: LD_VAR 0 3
57061: PPUSH
57062: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
57066: LD_VAR 0 3
57070: PPUSH
57071: LD_EXP 135
57075: PUSH
57076: LD_VAR 0 2
57080: ARRAY
57081: PPUSH
57082: LD_INT 34
57084: PUSH
57085: LD_INT 31
57087: PUSH
57088: EMPTY
57089: LIST
57090: LIST
57091: PUSH
57092: LD_INT 58
57094: PUSH
57095: EMPTY
57096: LIST
57097: PUSH
57098: EMPTY
57099: LIST
57100: LIST
57101: PPUSH
57102: CALL_OW 72
57106: PUSH
57107: LD_INT 1
57109: ARRAY
57110: PPUSH
57111: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
57115: LD_VAR 0 3
57119: PPUSH
57120: CALL_OW 310
57124: NOT
57125: PUSH
57126: LD_VAR 0 3
57130: PPUSH
57131: CALL_OW 310
57135: PPUSH
57136: CALL_OW 266
57140: PUSH
57141: LD_INT 36
57143: NONEQUAL
57144: PUSH
57145: LD_VAR 0 3
57149: PPUSH
57150: CALL 99965 0 1
57154: NOT
57155: AND
57156: OR
57157: IFFALSE 57293
// begin if IsInUnit ( j ) then
57159: LD_VAR 0 3
57163: PPUSH
57164: CALL_OW 310
57168: IFFALSE 57179
// ComExitBuilding ( j ) ;
57170: LD_VAR 0 3
57174: PPUSH
57175: CALL_OW 122
// ct := 0 ;
57179: LD_ADDR_VAR 0 8
57183: PUSH
57184: LD_INT 0
57186: ST_TO_ADDR
// for k in x do
57187: LD_ADDR_VAR 0 4
57191: PUSH
57192: LD_VAR 0 11
57196: PUSH
57197: FOR_IN
57198: IFFALSE 57271
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
57200: LD_VAR 0 4
57204: PPUSH
57205: CALL_OW 264
57209: PUSH
57210: LD_INT 31
57212: EQUAL
57213: PUSH
57214: LD_VAR 0 4
57218: PPUSH
57219: CALL_OW 311
57223: NOT
57224: AND
57225: PUSH
57226: LD_VAR 0 4
57230: PPUSH
57231: CALL_OW 266
57235: PUSH
57236: LD_INT 36
57238: EQUAL
57239: PUSH
57240: LD_VAR 0 4
57244: PPUSH
57245: CALL_OW 313
57249: PUSH
57250: LD_INT 3
57252: LESS
57253: AND
57254: OR
57255: IFFALSE 57269
// begin ct := k ;
57257: LD_ADDR_VAR 0 8
57261: PUSH
57262: LD_VAR 0 4
57266: ST_TO_ADDR
// break ;
57267: GO 57271
// end ;
57269: GO 57197
57271: POP
57272: POP
// if ct then
57273: LD_VAR 0 8
57277: IFFALSE 57293
// ComEnterUnit ( j , ct ) ;
57279: LD_VAR 0 3
57283: PPUSH
57284: LD_VAR 0 8
57288: PPUSH
57289: CALL_OW 120
// end ; end ;
57293: GO 56928
57295: POP
57296: POP
// places := 0 ;
57297: LD_ADDR_VAR 0 5
57301: PUSH
57302: LD_INT 0
57304: ST_TO_ADDR
// for j = 1 to x do
57305: LD_ADDR_VAR 0 3
57309: PUSH
57310: DOUBLE
57311: LD_INT 1
57313: DEC
57314: ST_TO_ADDR
57315: LD_VAR 0 11
57319: PUSH
57320: FOR_TO
57321: IFFALSE 57397
// if GetWeapon ( x [ j ] ) = ar_control_tower then
57323: LD_VAR 0 11
57327: PUSH
57328: LD_VAR 0 3
57332: ARRAY
57333: PPUSH
57334: CALL_OW 264
57338: PUSH
57339: LD_INT 31
57341: EQUAL
57342: IFFALSE 57360
// places := places + 1 else
57344: LD_ADDR_VAR 0 5
57348: PUSH
57349: LD_VAR 0 5
57353: PUSH
57354: LD_INT 1
57356: PLUS
57357: ST_TO_ADDR
57358: GO 57395
// if GetBType ( x [ j ] ) = b_control_tower then
57360: LD_VAR 0 11
57364: PUSH
57365: LD_VAR 0 3
57369: ARRAY
57370: PPUSH
57371: CALL_OW 266
57375: PUSH
57376: LD_INT 36
57378: EQUAL
57379: IFFALSE 57395
// places := places + 3 ;
57381: LD_ADDR_VAR 0 5
57385: PUSH
57386: LD_VAR 0 5
57390: PUSH
57391: LD_INT 3
57393: PLUS
57394: ST_TO_ADDR
57395: GO 57320
57397: POP
57398: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
57399: LD_VAR 0 5
57403: PUSH
57404: LD_INT 0
57406: EQUAL
57407: PUSH
57408: LD_VAR 0 5
57412: PUSH
57413: LD_EXP 156
57417: PUSH
57418: LD_VAR 0 2
57422: ARRAY
57423: LESSEQUAL
57424: OR
57425: IFFALSE 57429
// continue ;
57427: GO 56679
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
57429: LD_ADDR_VAR 0 6
57433: PUSH
57434: LD_EXP 116
57438: PUSH
57439: LD_VAR 0 2
57443: ARRAY
57444: PPUSH
57445: LD_INT 25
57447: PUSH
57448: LD_INT 3
57450: PUSH
57451: EMPTY
57452: LIST
57453: LIST
57454: PPUSH
57455: CALL_OW 72
57459: PUSH
57460: LD_EXP 156
57464: PUSH
57465: LD_VAR 0 2
57469: ARRAY
57470: DIFF
57471: PPUSH
57472: LD_INT 3
57474: PPUSH
57475: CALL 100865 0 2
57479: ST_TO_ADDR
// for j in tmp do
57480: LD_ADDR_VAR 0 3
57484: PUSH
57485: LD_VAR 0 6
57489: PUSH
57490: FOR_IN
57491: IFFALSE 57526
// if GetTag ( j ) > 0 then
57493: LD_VAR 0 3
57497: PPUSH
57498: CALL_OW 110
57502: PUSH
57503: LD_INT 0
57505: GREATER
57506: IFFALSE 57524
// tmp := tmp diff j ;
57508: LD_ADDR_VAR 0 6
57512: PUSH
57513: LD_VAR 0 6
57517: PUSH
57518: LD_VAR 0 3
57522: DIFF
57523: ST_TO_ADDR
57524: GO 57490
57526: POP
57527: POP
// if not tmp then
57528: LD_VAR 0 6
57532: NOT
57533: IFFALSE 57537
// continue ;
57535: GO 56679
// if places then
57537: LD_VAR 0 5
57541: IFFALSE 57600
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
57543: LD_ADDR_EXP 156
57547: PUSH
57548: LD_EXP 156
57552: PPUSH
57553: LD_VAR 0 2
57557: PPUSH
57558: LD_EXP 156
57562: PUSH
57563: LD_VAR 0 2
57567: ARRAY
57568: PUSH
57569: LD_VAR 0 6
57573: PUSH
57574: LD_INT 1
57576: ARRAY
57577: UNION
57578: PPUSH
57579: CALL_OW 1
57583: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
57584: LD_VAR 0 6
57588: PUSH
57589: LD_INT 1
57591: ARRAY
57592: PPUSH
57593: LD_INT 126
57595: PPUSH
57596: CALL_OW 109
// end ; end ;
57600: GO 56679
57602: POP
57603: POP
// end ;
57604: LD_VAR 0 1
57608: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
57609: LD_INT 0
57611: PPUSH
57612: PPUSH
57613: PPUSH
57614: PPUSH
57615: PPUSH
57616: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
57617: LD_VAR 0 1
57621: NOT
57622: PUSH
57623: LD_VAR 0 2
57627: NOT
57628: OR
57629: PUSH
57630: LD_VAR 0 3
57634: NOT
57635: OR
57636: PUSH
57637: LD_VAR 0 4
57641: PUSH
57642: LD_INT 1
57644: PUSH
57645: LD_INT 2
57647: PUSH
57648: LD_INT 3
57650: PUSH
57651: LD_INT 4
57653: PUSH
57654: LD_INT 5
57656: PUSH
57657: LD_INT 8
57659: PUSH
57660: LD_INT 9
57662: PUSH
57663: LD_INT 15
57665: PUSH
57666: LD_INT 16
57668: PUSH
57669: EMPTY
57670: LIST
57671: LIST
57672: LIST
57673: LIST
57674: LIST
57675: LIST
57676: LIST
57677: LIST
57678: LIST
57679: IN
57680: NOT
57681: OR
57682: IFFALSE 57686
// exit ;
57684: GO 58586
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57686: LD_ADDR_VAR 0 2
57690: PUSH
57691: LD_VAR 0 2
57695: PPUSH
57696: LD_INT 21
57698: PUSH
57699: LD_INT 3
57701: PUSH
57702: EMPTY
57703: LIST
57704: LIST
57705: PUSH
57706: LD_INT 24
57708: PUSH
57709: LD_INT 250
57711: PUSH
57712: EMPTY
57713: LIST
57714: LIST
57715: PUSH
57716: EMPTY
57717: LIST
57718: LIST
57719: PPUSH
57720: CALL_OW 72
57724: ST_TO_ADDR
// case class of 1 , 15 :
57725: LD_VAR 0 4
57729: PUSH
57730: LD_INT 1
57732: DOUBLE
57733: EQUAL
57734: IFTRUE 57744
57736: LD_INT 15
57738: DOUBLE
57739: EQUAL
57740: IFTRUE 57744
57742: GO 57829
57744: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
57745: LD_ADDR_VAR 0 8
57749: PUSH
57750: LD_VAR 0 2
57754: PPUSH
57755: LD_INT 2
57757: PUSH
57758: LD_INT 30
57760: PUSH
57761: LD_INT 32
57763: PUSH
57764: EMPTY
57765: LIST
57766: LIST
57767: PUSH
57768: LD_INT 30
57770: PUSH
57771: LD_INT 31
57773: PUSH
57774: EMPTY
57775: LIST
57776: LIST
57777: PUSH
57778: EMPTY
57779: LIST
57780: LIST
57781: LIST
57782: PPUSH
57783: CALL_OW 72
57787: PUSH
57788: LD_VAR 0 2
57792: PPUSH
57793: LD_INT 2
57795: PUSH
57796: LD_INT 30
57798: PUSH
57799: LD_INT 4
57801: PUSH
57802: EMPTY
57803: LIST
57804: LIST
57805: PUSH
57806: LD_INT 30
57808: PUSH
57809: LD_INT 5
57811: PUSH
57812: EMPTY
57813: LIST
57814: LIST
57815: PUSH
57816: EMPTY
57817: LIST
57818: LIST
57819: LIST
57820: PPUSH
57821: CALL_OW 72
57825: ADD
57826: ST_TO_ADDR
57827: GO 58075
57829: LD_INT 2
57831: DOUBLE
57832: EQUAL
57833: IFTRUE 57843
57835: LD_INT 16
57837: DOUBLE
57838: EQUAL
57839: IFTRUE 57843
57841: GO 57889
57843: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
57844: LD_ADDR_VAR 0 8
57848: PUSH
57849: LD_VAR 0 2
57853: PPUSH
57854: LD_INT 2
57856: PUSH
57857: LD_INT 30
57859: PUSH
57860: LD_INT 0
57862: PUSH
57863: EMPTY
57864: LIST
57865: LIST
57866: PUSH
57867: LD_INT 30
57869: PUSH
57870: LD_INT 1
57872: PUSH
57873: EMPTY
57874: LIST
57875: LIST
57876: PUSH
57877: EMPTY
57878: LIST
57879: LIST
57880: LIST
57881: PPUSH
57882: CALL_OW 72
57886: ST_TO_ADDR
57887: GO 58075
57889: LD_INT 3
57891: DOUBLE
57892: EQUAL
57893: IFTRUE 57897
57895: GO 57943
57897: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
57898: LD_ADDR_VAR 0 8
57902: PUSH
57903: LD_VAR 0 2
57907: PPUSH
57908: LD_INT 2
57910: PUSH
57911: LD_INT 30
57913: PUSH
57914: LD_INT 2
57916: PUSH
57917: EMPTY
57918: LIST
57919: LIST
57920: PUSH
57921: LD_INT 30
57923: PUSH
57924: LD_INT 3
57926: PUSH
57927: EMPTY
57928: LIST
57929: LIST
57930: PUSH
57931: EMPTY
57932: LIST
57933: LIST
57934: LIST
57935: PPUSH
57936: CALL_OW 72
57940: ST_TO_ADDR
57941: GO 58075
57943: LD_INT 4
57945: DOUBLE
57946: EQUAL
57947: IFTRUE 57951
57949: GO 58008
57951: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
57952: LD_ADDR_VAR 0 8
57956: PUSH
57957: LD_VAR 0 2
57961: PPUSH
57962: LD_INT 2
57964: PUSH
57965: LD_INT 30
57967: PUSH
57968: LD_INT 6
57970: PUSH
57971: EMPTY
57972: LIST
57973: LIST
57974: PUSH
57975: LD_INT 30
57977: PUSH
57978: LD_INT 7
57980: PUSH
57981: EMPTY
57982: LIST
57983: LIST
57984: PUSH
57985: LD_INT 30
57987: PUSH
57988: LD_INT 8
57990: PUSH
57991: EMPTY
57992: LIST
57993: LIST
57994: PUSH
57995: EMPTY
57996: LIST
57997: LIST
57998: LIST
57999: LIST
58000: PPUSH
58001: CALL_OW 72
58005: ST_TO_ADDR
58006: GO 58075
58008: LD_INT 5
58010: DOUBLE
58011: EQUAL
58012: IFTRUE 58028
58014: LD_INT 8
58016: DOUBLE
58017: EQUAL
58018: IFTRUE 58028
58020: LD_INT 9
58022: DOUBLE
58023: EQUAL
58024: IFTRUE 58028
58026: GO 58074
58028: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
58029: LD_ADDR_VAR 0 8
58033: PUSH
58034: LD_VAR 0 2
58038: PPUSH
58039: LD_INT 2
58041: PUSH
58042: LD_INT 30
58044: PUSH
58045: LD_INT 4
58047: PUSH
58048: EMPTY
58049: LIST
58050: LIST
58051: PUSH
58052: LD_INT 30
58054: PUSH
58055: LD_INT 5
58057: PUSH
58058: EMPTY
58059: LIST
58060: LIST
58061: PUSH
58062: EMPTY
58063: LIST
58064: LIST
58065: LIST
58066: PPUSH
58067: CALL_OW 72
58071: ST_TO_ADDR
58072: GO 58075
58074: POP
// if not tmp then
58075: LD_VAR 0 8
58079: NOT
58080: IFFALSE 58084
// exit ;
58082: GO 58586
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
58084: LD_VAR 0 4
58088: PUSH
58089: LD_INT 1
58091: PUSH
58092: LD_INT 15
58094: PUSH
58095: EMPTY
58096: LIST
58097: LIST
58098: IN
58099: PUSH
58100: LD_EXP 125
58104: PUSH
58105: LD_VAR 0 1
58109: ARRAY
58110: AND
58111: IFFALSE 58267
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
58113: LD_ADDR_VAR 0 9
58117: PUSH
58118: LD_EXP 125
58122: PUSH
58123: LD_VAR 0 1
58127: ARRAY
58128: PUSH
58129: LD_INT 1
58131: ARRAY
58132: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
58133: LD_VAR 0 9
58137: PUSH
58138: LD_EXP 126
58142: PUSH
58143: LD_VAR 0 1
58147: ARRAY
58148: IN
58149: NOT
58150: IFFALSE 58265
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
58152: LD_ADDR_EXP 126
58156: PUSH
58157: LD_EXP 126
58161: PPUSH
58162: LD_VAR 0 1
58166: PUSH
58167: LD_EXP 126
58171: PUSH
58172: LD_VAR 0 1
58176: ARRAY
58177: PUSH
58178: LD_INT 1
58180: PLUS
58181: PUSH
58182: EMPTY
58183: LIST
58184: LIST
58185: PPUSH
58186: LD_VAR 0 9
58190: PPUSH
58191: CALL 70608 0 3
58195: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
58196: LD_ADDR_EXP 125
58200: PUSH
58201: LD_EXP 125
58205: PPUSH
58206: LD_VAR 0 1
58210: PPUSH
58211: LD_EXP 125
58215: PUSH
58216: LD_VAR 0 1
58220: ARRAY
58221: PUSH
58222: LD_VAR 0 9
58226: DIFF
58227: PPUSH
58228: CALL_OW 1
58232: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
58233: LD_VAR 0 3
58237: PPUSH
58238: LD_EXP 126
58242: PUSH
58243: LD_VAR 0 1
58247: ARRAY
58248: PUSH
58249: LD_EXP 126
58253: PUSH
58254: LD_VAR 0 1
58258: ARRAY
58259: ARRAY
58260: PPUSH
58261: CALL_OW 120
// end ; exit ;
58265: GO 58586
// end ; if tmp > 1 then
58267: LD_VAR 0 8
58271: PUSH
58272: LD_INT 1
58274: GREATER
58275: IFFALSE 58379
// for i = 2 to tmp do
58277: LD_ADDR_VAR 0 6
58281: PUSH
58282: DOUBLE
58283: LD_INT 2
58285: DEC
58286: ST_TO_ADDR
58287: LD_VAR 0 8
58291: PUSH
58292: FOR_TO
58293: IFFALSE 58377
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
58295: LD_VAR 0 8
58299: PUSH
58300: LD_VAR 0 6
58304: ARRAY
58305: PPUSH
58306: CALL_OW 461
58310: PUSH
58311: LD_INT 6
58313: EQUAL
58314: IFFALSE 58375
// begin x := tmp [ i ] ;
58316: LD_ADDR_VAR 0 9
58320: PUSH
58321: LD_VAR 0 8
58325: PUSH
58326: LD_VAR 0 6
58330: ARRAY
58331: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
58332: LD_ADDR_VAR 0 8
58336: PUSH
58337: LD_VAR 0 8
58341: PPUSH
58342: LD_VAR 0 6
58346: PPUSH
58347: CALL_OW 3
58351: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
58352: LD_ADDR_VAR 0 8
58356: PUSH
58357: LD_VAR 0 8
58361: PPUSH
58362: LD_INT 1
58364: PPUSH
58365: LD_VAR 0 9
58369: PPUSH
58370: CALL_OW 2
58374: ST_TO_ADDR
// end ;
58375: GO 58292
58377: POP
58378: POP
// for i in tmp do
58379: LD_ADDR_VAR 0 6
58383: PUSH
58384: LD_VAR 0 8
58388: PUSH
58389: FOR_IN
58390: IFFALSE 58459
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
58392: LD_VAR 0 6
58396: PPUSH
58397: CALL_OW 313
58401: PUSH
58402: LD_INT 6
58404: LESS
58405: PUSH
58406: LD_VAR 0 6
58410: PPUSH
58411: CALL_OW 266
58415: PUSH
58416: LD_INT 31
58418: PUSH
58419: LD_INT 32
58421: PUSH
58422: EMPTY
58423: LIST
58424: LIST
58425: IN
58426: NOT
58427: AND
58428: PUSH
58429: LD_VAR 0 6
58433: PPUSH
58434: CALL_OW 313
58438: PUSH
58439: LD_INT 0
58441: EQUAL
58442: OR
58443: IFFALSE 58457
// begin j := i ;
58445: LD_ADDR_VAR 0 7
58449: PUSH
58450: LD_VAR 0 6
58454: ST_TO_ADDR
// break ;
58455: GO 58459
// end ; end ;
58457: GO 58389
58459: POP
58460: POP
// if j then
58461: LD_VAR 0 7
58465: IFFALSE 58483
// ComEnterUnit ( unit , j ) else
58467: LD_VAR 0 3
58471: PPUSH
58472: LD_VAR 0 7
58476: PPUSH
58477: CALL_OW 120
58481: GO 58586
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58483: LD_ADDR_VAR 0 10
58487: PUSH
58488: LD_VAR 0 2
58492: PPUSH
58493: LD_INT 2
58495: PUSH
58496: LD_INT 30
58498: PUSH
58499: LD_INT 0
58501: PUSH
58502: EMPTY
58503: LIST
58504: LIST
58505: PUSH
58506: LD_INT 30
58508: PUSH
58509: LD_INT 1
58511: PUSH
58512: EMPTY
58513: LIST
58514: LIST
58515: PUSH
58516: EMPTY
58517: LIST
58518: LIST
58519: LIST
58520: PPUSH
58521: CALL_OW 72
58525: ST_TO_ADDR
// if depot then
58526: LD_VAR 0 10
58530: IFFALSE 58586
// begin depot := NearestUnitToUnit ( depot , unit ) ;
58532: LD_ADDR_VAR 0 10
58536: PUSH
58537: LD_VAR 0 10
58541: PPUSH
58542: LD_VAR 0 3
58546: PPUSH
58547: CALL_OW 74
58551: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
58552: LD_VAR 0 3
58556: PPUSH
58557: LD_VAR 0 10
58561: PPUSH
58562: CALL_OW 296
58566: PUSH
58567: LD_INT 10
58569: GREATER
58570: IFFALSE 58586
// ComStandNearbyBuilding ( unit , depot ) ;
58572: LD_VAR 0 3
58576: PPUSH
58577: LD_VAR 0 10
58581: PPUSH
58582: CALL 67186 0 2
// end ; end ; end ;
58586: LD_VAR 0 5
58590: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
58591: LD_INT 0
58593: PPUSH
58594: PPUSH
58595: PPUSH
58596: PPUSH
// if not mc_bases then
58597: LD_EXP 116
58601: NOT
58602: IFFALSE 58606
// exit ;
58604: GO 58845
// for i = 1 to mc_bases do
58606: LD_ADDR_VAR 0 2
58610: PUSH
58611: DOUBLE
58612: LD_INT 1
58614: DEC
58615: ST_TO_ADDR
58616: LD_EXP 116
58620: PUSH
58621: FOR_TO
58622: IFFALSE 58843
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
58624: LD_ADDR_VAR 0 4
58628: PUSH
58629: LD_EXP 116
58633: PUSH
58634: LD_VAR 0 2
58638: ARRAY
58639: PPUSH
58640: LD_INT 21
58642: PUSH
58643: LD_INT 1
58645: PUSH
58646: EMPTY
58647: LIST
58648: LIST
58649: PPUSH
58650: CALL_OW 72
58654: PUSH
58655: LD_EXP 145
58659: PUSH
58660: LD_VAR 0 2
58664: ARRAY
58665: UNION
58666: ST_TO_ADDR
// if not tmp then
58667: LD_VAR 0 4
58671: NOT
58672: IFFALSE 58676
// continue ;
58674: GO 58621
// for j in tmp do
58676: LD_ADDR_VAR 0 3
58680: PUSH
58681: LD_VAR 0 4
58685: PUSH
58686: FOR_IN
58687: IFFALSE 58839
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58689: LD_VAR 0 3
58693: PPUSH
58694: CALL_OW 110
58698: NOT
58699: PUSH
58700: LD_VAR 0 3
58704: PPUSH
58705: CALL_OW 314
58709: NOT
58710: AND
58711: PUSH
58712: LD_VAR 0 3
58716: PPUSH
58717: CALL_OW 311
58721: NOT
58722: AND
58723: PUSH
58724: LD_VAR 0 3
58728: PPUSH
58729: CALL_OW 310
58733: NOT
58734: AND
58735: PUSH
58736: LD_VAR 0 3
58740: PUSH
58741: LD_EXP 119
58745: PUSH
58746: LD_VAR 0 2
58750: ARRAY
58751: PUSH
58752: LD_INT 1
58754: ARRAY
58755: IN
58756: NOT
58757: AND
58758: PUSH
58759: LD_VAR 0 3
58763: PUSH
58764: LD_EXP 119
58768: PUSH
58769: LD_VAR 0 2
58773: ARRAY
58774: PUSH
58775: LD_INT 2
58777: ARRAY
58778: IN
58779: NOT
58780: AND
58781: PUSH
58782: LD_VAR 0 3
58786: PUSH
58787: LD_EXP 128
58791: PUSH
58792: LD_VAR 0 2
58796: ARRAY
58797: IN
58798: NOT
58799: AND
58800: IFFALSE 58837
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
58802: LD_VAR 0 2
58806: PPUSH
58807: LD_EXP 116
58811: PUSH
58812: LD_VAR 0 2
58816: ARRAY
58817: PPUSH
58818: LD_VAR 0 3
58822: PPUSH
58823: LD_VAR 0 3
58827: PPUSH
58828: CALL_OW 257
58832: PPUSH
58833: CALL 57609 0 4
// end ;
58837: GO 58686
58839: POP
58840: POP
// end ;
58841: GO 58621
58843: POP
58844: POP
// end ;
58845: LD_VAR 0 1
58849: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
58850: LD_INT 0
58852: PPUSH
58853: PPUSH
58854: PPUSH
58855: PPUSH
58856: PPUSH
58857: PPUSH
// if not mc_bases [ base ] then
58858: LD_EXP 116
58862: PUSH
58863: LD_VAR 0 1
58867: ARRAY
58868: NOT
58869: IFFALSE 58873
// exit ;
58871: GO 59055
// tmp := [ ] ;
58873: LD_ADDR_VAR 0 6
58877: PUSH
58878: EMPTY
58879: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
58880: LD_ADDR_VAR 0 7
58884: PUSH
58885: LD_VAR 0 3
58889: PPUSH
58890: LD_INT 0
58892: PPUSH
58893: CALL_OW 517
58897: ST_TO_ADDR
// if not list then
58898: LD_VAR 0 7
58902: NOT
58903: IFFALSE 58907
// exit ;
58905: GO 59055
// for i = 1 to amount do
58907: LD_ADDR_VAR 0 5
58911: PUSH
58912: DOUBLE
58913: LD_INT 1
58915: DEC
58916: ST_TO_ADDR
58917: LD_VAR 0 2
58921: PUSH
58922: FOR_TO
58923: IFFALSE 59003
// begin x := rand ( 1 , list [ 1 ] ) ;
58925: LD_ADDR_VAR 0 8
58929: PUSH
58930: LD_INT 1
58932: PPUSH
58933: LD_VAR 0 7
58937: PUSH
58938: LD_INT 1
58940: ARRAY
58941: PPUSH
58942: CALL_OW 12
58946: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
58947: LD_ADDR_VAR 0 6
58951: PUSH
58952: LD_VAR 0 6
58956: PPUSH
58957: LD_VAR 0 5
58961: PPUSH
58962: LD_VAR 0 7
58966: PUSH
58967: LD_INT 1
58969: ARRAY
58970: PUSH
58971: LD_VAR 0 8
58975: ARRAY
58976: PUSH
58977: LD_VAR 0 7
58981: PUSH
58982: LD_INT 2
58984: ARRAY
58985: PUSH
58986: LD_VAR 0 8
58990: ARRAY
58991: PUSH
58992: EMPTY
58993: LIST
58994: LIST
58995: PPUSH
58996: CALL_OW 1
59000: ST_TO_ADDR
// end ;
59001: GO 58922
59003: POP
59004: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
59005: LD_ADDR_EXP 129
59009: PUSH
59010: LD_EXP 129
59014: PPUSH
59015: LD_VAR 0 1
59019: PPUSH
59020: LD_VAR 0 6
59024: PPUSH
59025: CALL_OW 1
59029: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
59030: LD_ADDR_EXP 131
59034: PUSH
59035: LD_EXP 131
59039: PPUSH
59040: LD_VAR 0 1
59044: PPUSH
59045: LD_VAR 0 3
59049: PPUSH
59050: CALL_OW 1
59054: ST_TO_ADDR
// end ;
59055: LD_VAR 0 4
59059: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
59060: LD_INT 0
59062: PPUSH
// if not mc_bases [ base ] then
59063: LD_EXP 116
59067: PUSH
59068: LD_VAR 0 1
59072: ARRAY
59073: NOT
59074: IFFALSE 59078
// exit ;
59076: GO 59103
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
59078: LD_ADDR_EXP 121
59082: PUSH
59083: LD_EXP 121
59087: PPUSH
59088: LD_VAR 0 1
59092: PPUSH
59093: LD_VAR 0 2
59097: PPUSH
59098: CALL_OW 1
59102: ST_TO_ADDR
// end ;
59103: LD_VAR 0 3
59107: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
59108: LD_INT 0
59110: PPUSH
// if not mc_bases [ base ] then
59111: LD_EXP 116
59115: PUSH
59116: LD_VAR 0 1
59120: ARRAY
59121: NOT
59122: IFFALSE 59126
// exit ;
59124: GO 59163
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
59126: LD_ADDR_EXP 121
59130: PUSH
59131: LD_EXP 121
59135: PPUSH
59136: LD_VAR 0 1
59140: PPUSH
59141: LD_EXP 121
59145: PUSH
59146: LD_VAR 0 1
59150: ARRAY
59151: PUSH
59152: LD_VAR 0 2
59156: UNION
59157: PPUSH
59158: CALL_OW 1
59162: ST_TO_ADDR
// end ;
59163: LD_VAR 0 3
59167: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
59168: LD_INT 0
59170: PPUSH
// if not mc_bases [ base ] then
59171: LD_EXP 116
59175: PUSH
59176: LD_VAR 0 1
59180: ARRAY
59181: NOT
59182: IFFALSE 59186
// exit ;
59184: GO 59211
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
59186: LD_ADDR_EXP 137
59190: PUSH
59191: LD_EXP 137
59195: PPUSH
59196: LD_VAR 0 1
59200: PPUSH
59201: LD_VAR 0 2
59205: PPUSH
59206: CALL_OW 1
59210: ST_TO_ADDR
// end ;
59211: LD_VAR 0 3
59215: RET
// export function MC_InsertProduceList ( base , components ) ; begin
59216: LD_INT 0
59218: PPUSH
// if not mc_bases [ base ] then
59219: LD_EXP 116
59223: PUSH
59224: LD_VAR 0 1
59228: ARRAY
59229: NOT
59230: IFFALSE 59234
// exit ;
59232: GO 59271
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
59234: LD_ADDR_EXP 137
59238: PUSH
59239: LD_EXP 137
59243: PPUSH
59244: LD_VAR 0 1
59248: PPUSH
59249: LD_EXP 137
59253: PUSH
59254: LD_VAR 0 1
59258: ARRAY
59259: PUSH
59260: LD_VAR 0 2
59264: ADD
59265: PPUSH
59266: CALL_OW 1
59270: ST_TO_ADDR
// end ;
59271: LD_VAR 0 3
59275: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
59276: LD_INT 0
59278: PPUSH
// if not mc_bases [ base ] then
59279: LD_EXP 116
59283: PUSH
59284: LD_VAR 0 1
59288: ARRAY
59289: NOT
59290: IFFALSE 59294
// exit ;
59292: GO 59348
// mc_defender := Replace ( mc_defender , base , deflist ) ;
59294: LD_ADDR_EXP 138
59298: PUSH
59299: LD_EXP 138
59303: PPUSH
59304: LD_VAR 0 1
59308: PPUSH
59309: LD_VAR 0 2
59313: PPUSH
59314: CALL_OW 1
59318: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
59319: LD_ADDR_EXP 127
59323: PUSH
59324: LD_EXP 127
59328: PPUSH
59329: LD_VAR 0 1
59333: PPUSH
59334: LD_VAR 0 2
59338: PUSH
59339: LD_INT 0
59341: PLUS
59342: PPUSH
59343: CALL_OW 1
59347: ST_TO_ADDR
// end ;
59348: LD_VAR 0 3
59352: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
59353: LD_INT 0
59355: PPUSH
// if not mc_bases [ base ] then
59356: LD_EXP 116
59360: PUSH
59361: LD_VAR 0 1
59365: ARRAY
59366: NOT
59367: IFFALSE 59371
// exit ;
59369: GO 59396
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
59371: LD_ADDR_EXP 127
59375: PUSH
59376: LD_EXP 127
59380: PPUSH
59381: LD_VAR 0 1
59385: PPUSH
59386: LD_VAR 0 2
59390: PPUSH
59391: CALL_OW 1
59395: ST_TO_ADDR
// end ;
59396: LD_VAR 0 3
59400: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
59401: LD_INT 0
59403: PPUSH
59404: PPUSH
59405: PPUSH
59406: PPUSH
// if not mc_bases [ base ] then
59407: LD_EXP 116
59411: PUSH
59412: LD_VAR 0 1
59416: ARRAY
59417: NOT
59418: IFFALSE 59422
// exit ;
59420: GO 59487
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
59422: LD_ADDR_EXP 136
59426: PUSH
59427: LD_EXP 136
59431: PPUSH
59432: LD_VAR 0 1
59436: PUSH
59437: LD_EXP 136
59441: PUSH
59442: LD_VAR 0 1
59446: ARRAY
59447: PUSH
59448: LD_INT 1
59450: PLUS
59451: PUSH
59452: EMPTY
59453: LIST
59454: LIST
59455: PPUSH
59456: LD_VAR 0 1
59460: PUSH
59461: LD_VAR 0 2
59465: PUSH
59466: LD_VAR 0 3
59470: PUSH
59471: LD_VAR 0 4
59475: PUSH
59476: EMPTY
59477: LIST
59478: LIST
59479: LIST
59480: LIST
59481: PPUSH
59482: CALL 70608 0 3
59486: ST_TO_ADDR
// end ;
59487: LD_VAR 0 5
59491: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
59492: LD_INT 0
59494: PPUSH
// if not mc_bases [ base ] then
59495: LD_EXP 116
59499: PUSH
59500: LD_VAR 0 1
59504: ARRAY
59505: NOT
59506: IFFALSE 59510
// exit ;
59508: GO 59535
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
59510: LD_ADDR_EXP 153
59514: PUSH
59515: LD_EXP 153
59519: PPUSH
59520: LD_VAR 0 1
59524: PPUSH
59525: LD_VAR 0 2
59529: PPUSH
59530: CALL_OW 1
59534: ST_TO_ADDR
// end ;
59535: LD_VAR 0 3
59539: RET
// export function MC_GetMinesField ( base ) ; begin
59540: LD_INT 0
59542: PPUSH
// result := mc_mines [ base ] ;
59543: LD_ADDR_VAR 0 2
59547: PUSH
59548: LD_EXP 129
59552: PUSH
59553: LD_VAR 0 1
59557: ARRAY
59558: ST_TO_ADDR
// end ;
59559: LD_VAR 0 2
59563: RET
// export function MC_GetProduceList ( base ) ; begin
59564: LD_INT 0
59566: PPUSH
// result := mc_produce [ base ] ;
59567: LD_ADDR_VAR 0 2
59571: PUSH
59572: LD_EXP 137
59576: PUSH
59577: LD_VAR 0 1
59581: ARRAY
59582: ST_TO_ADDR
// end ;
59583: LD_VAR 0 2
59587: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
59588: LD_INT 0
59590: PPUSH
59591: PPUSH
// if not mc_bases then
59592: LD_EXP 116
59596: NOT
59597: IFFALSE 59601
// exit ;
59599: GO 59666
// if mc_bases [ base ] then
59601: LD_EXP 116
59605: PUSH
59606: LD_VAR 0 1
59610: ARRAY
59611: IFFALSE 59666
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59613: LD_ADDR_VAR 0 3
59617: PUSH
59618: LD_EXP 116
59622: PUSH
59623: LD_VAR 0 1
59627: ARRAY
59628: PPUSH
59629: LD_INT 30
59631: PUSH
59632: LD_VAR 0 2
59636: PUSH
59637: EMPTY
59638: LIST
59639: LIST
59640: PPUSH
59641: CALL_OW 72
59645: ST_TO_ADDR
// if result then
59646: LD_VAR 0 3
59650: IFFALSE 59666
// result := result [ 1 ] ;
59652: LD_ADDR_VAR 0 3
59656: PUSH
59657: LD_VAR 0 3
59661: PUSH
59662: LD_INT 1
59664: ARRAY
59665: ST_TO_ADDR
// end ; end ;
59666: LD_VAR 0 3
59670: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59671: LD_INT 0
59673: PPUSH
59674: PPUSH
// if not mc_bases then
59675: LD_EXP 116
59679: NOT
59680: IFFALSE 59684
// exit ;
59682: GO 59729
// if mc_bases [ base ] then
59684: LD_EXP 116
59688: PUSH
59689: LD_VAR 0 1
59693: ARRAY
59694: IFFALSE 59729
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59696: LD_ADDR_VAR 0 3
59700: PUSH
59701: LD_EXP 116
59705: PUSH
59706: LD_VAR 0 1
59710: ARRAY
59711: PPUSH
59712: LD_INT 30
59714: PUSH
59715: LD_VAR 0 2
59719: PUSH
59720: EMPTY
59721: LIST
59722: LIST
59723: PPUSH
59724: CALL_OW 72
59728: ST_TO_ADDR
// end ;
59729: LD_VAR 0 3
59733: RET
// export function MC_SetTame ( base , area ) ; begin
59734: LD_INT 0
59736: PPUSH
// if not mc_bases or not base then
59737: LD_EXP 116
59741: NOT
59742: PUSH
59743: LD_VAR 0 1
59747: NOT
59748: OR
59749: IFFALSE 59753
// exit ;
59751: GO 59778
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
59753: LD_ADDR_EXP 144
59757: PUSH
59758: LD_EXP 144
59762: PPUSH
59763: LD_VAR 0 1
59767: PPUSH
59768: LD_VAR 0 2
59772: PPUSH
59773: CALL_OW 1
59777: ST_TO_ADDR
// end ;
59778: LD_VAR 0 3
59782: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
59783: LD_INT 0
59785: PPUSH
59786: PPUSH
// if not mc_bases or not base then
59787: LD_EXP 116
59791: NOT
59792: PUSH
59793: LD_VAR 0 1
59797: NOT
59798: OR
59799: IFFALSE 59803
// exit ;
59801: GO 59905
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59803: LD_ADDR_VAR 0 4
59807: PUSH
59808: LD_EXP 116
59812: PUSH
59813: LD_VAR 0 1
59817: ARRAY
59818: PPUSH
59819: LD_INT 30
59821: PUSH
59822: LD_VAR 0 2
59826: PUSH
59827: EMPTY
59828: LIST
59829: LIST
59830: PPUSH
59831: CALL_OW 72
59835: ST_TO_ADDR
// if not tmp then
59836: LD_VAR 0 4
59840: NOT
59841: IFFALSE 59845
// exit ;
59843: GO 59905
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
59845: LD_ADDR_EXP 148
59849: PUSH
59850: LD_EXP 148
59854: PPUSH
59855: LD_VAR 0 1
59859: PPUSH
59860: LD_EXP 148
59864: PUSH
59865: LD_VAR 0 1
59869: ARRAY
59870: PPUSH
59871: LD_EXP 148
59875: PUSH
59876: LD_VAR 0 1
59880: ARRAY
59881: PUSH
59882: LD_INT 1
59884: PLUS
59885: PPUSH
59886: LD_VAR 0 4
59890: PUSH
59891: LD_INT 1
59893: ARRAY
59894: PPUSH
59895: CALL_OW 2
59899: PPUSH
59900: CALL_OW 1
59904: ST_TO_ADDR
// end ;
59905: LD_VAR 0 3
59909: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
59910: LD_INT 0
59912: PPUSH
59913: PPUSH
// if not mc_bases or not base or not kinds then
59914: LD_EXP 116
59918: NOT
59919: PUSH
59920: LD_VAR 0 1
59924: NOT
59925: OR
59926: PUSH
59927: LD_VAR 0 2
59931: NOT
59932: OR
59933: IFFALSE 59937
// exit ;
59935: GO 59998
// for i in kinds do
59937: LD_ADDR_VAR 0 4
59941: PUSH
59942: LD_VAR 0 2
59946: PUSH
59947: FOR_IN
59948: IFFALSE 59996
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
59950: LD_ADDR_EXP 150
59954: PUSH
59955: LD_EXP 150
59959: PPUSH
59960: LD_VAR 0 1
59964: PUSH
59965: LD_EXP 150
59969: PUSH
59970: LD_VAR 0 1
59974: ARRAY
59975: PUSH
59976: LD_INT 1
59978: PLUS
59979: PUSH
59980: EMPTY
59981: LIST
59982: LIST
59983: PPUSH
59984: LD_VAR 0 4
59988: PPUSH
59989: CALL 70608 0 3
59993: ST_TO_ADDR
59994: GO 59947
59996: POP
59997: POP
// end ;
59998: LD_VAR 0 3
60002: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
60003: LD_INT 0
60005: PPUSH
// if not mc_bases or not base or not areas then
60006: LD_EXP 116
60010: NOT
60011: PUSH
60012: LD_VAR 0 1
60016: NOT
60017: OR
60018: PUSH
60019: LD_VAR 0 2
60023: NOT
60024: OR
60025: IFFALSE 60029
// exit ;
60027: GO 60054
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
60029: LD_ADDR_EXP 134
60033: PUSH
60034: LD_EXP 134
60038: PPUSH
60039: LD_VAR 0 1
60043: PPUSH
60044: LD_VAR 0 2
60048: PPUSH
60049: CALL_OW 1
60053: ST_TO_ADDR
// end ;
60054: LD_VAR 0 3
60058: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
60059: LD_INT 0
60061: PPUSH
// if not mc_bases or not base or not teleports_exit then
60062: LD_EXP 116
60066: NOT
60067: PUSH
60068: LD_VAR 0 1
60072: NOT
60073: OR
60074: PUSH
60075: LD_VAR 0 2
60079: NOT
60080: OR
60081: IFFALSE 60085
// exit ;
60083: GO 60110
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
60085: LD_ADDR_EXP 151
60089: PUSH
60090: LD_EXP 151
60094: PPUSH
60095: LD_VAR 0 1
60099: PPUSH
60100: LD_VAR 0 2
60104: PPUSH
60105: CALL_OW 1
60109: ST_TO_ADDR
// end ;
60110: LD_VAR 0 3
60114: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
60115: LD_INT 0
60117: PPUSH
60118: PPUSH
60119: PPUSH
// if not mc_bases or not base or not ext_list then
60120: LD_EXP 116
60124: NOT
60125: PUSH
60126: LD_VAR 0 1
60130: NOT
60131: OR
60132: PUSH
60133: LD_VAR 0 5
60137: NOT
60138: OR
60139: IFFALSE 60143
// exit ;
60141: GO 60316
// tmp := GetFacExtXYD ( x , y , d ) ;
60143: LD_ADDR_VAR 0 8
60147: PUSH
60148: LD_VAR 0 2
60152: PPUSH
60153: LD_VAR 0 3
60157: PPUSH
60158: LD_VAR 0 4
60162: PPUSH
60163: CALL 99995 0 3
60167: ST_TO_ADDR
// if not tmp then
60168: LD_VAR 0 8
60172: NOT
60173: IFFALSE 60177
// exit ;
60175: GO 60316
// for i in tmp do
60177: LD_ADDR_VAR 0 7
60181: PUSH
60182: LD_VAR 0 8
60186: PUSH
60187: FOR_IN
60188: IFFALSE 60314
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
60190: LD_ADDR_EXP 121
60194: PUSH
60195: LD_EXP 121
60199: PPUSH
60200: LD_VAR 0 1
60204: PPUSH
60205: LD_EXP 121
60209: PUSH
60210: LD_VAR 0 1
60214: ARRAY
60215: PPUSH
60216: LD_EXP 121
60220: PUSH
60221: LD_VAR 0 1
60225: ARRAY
60226: PUSH
60227: LD_INT 1
60229: PLUS
60230: PPUSH
60231: LD_VAR 0 5
60235: PUSH
60236: LD_INT 1
60238: ARRAY
60239: PUSH
60240: LD_VAR 0 7
60244: PUSH
60245: LD_INT 1
60247: ARRAY
60248: PUSH
60249: LD_VAR 0 7
60253: PUSH
60254: LD_INT 2
60256: ARRAY
60257: PUSH
60258: LD_VAR 0 7
60262: PUSH
60263: LD_INT 3
60265: ARRAY
60266: PUSH
60267: EMPTY
60268: LIST
60269: LIST
60270: LIST
60271: LIST
60272: PPUSH
60273: CALL_OW 2
60277: PPUSH
60278: CALL_OW 1
60282: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
60283: LD_ADDR_VAR 0 5
60287: PUSH
60288: LD_VAR 0 5
60292: PPUSH
60293: LD_INT 1
60295: PPUSH
60296: CALL_OW 3
60300: ST_TO_ADDR
// if not ext_list then
60301: LD_VAR 0 5
60305: NOT
60306: IFFALSE 60312
// exit ;
60308: POP
60309: POP
60310: GO 60316
// end ;
60312: GO 60187
60314: POP
60315: POP
// end ;
60316: LD_VAR 0 6
60320: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
60321: LD_INT 0
60323: PPUSH
// if not mc_bases or not base or not weapon_list then
60324: LD_EXP 116
60328: NOT
60329: PUSH
60330: LD_VAR 0 1
60334: NOT
60335: OR
60336: PUSH
60337: LD_VAR 0 2
60341: NOT
60342: OR
60343: IFFALSE 60347
// exit ;
60345: GO 60372
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
60347: LD_ADDR_EXP 155
60351: PUSH
60352: LD_EXP 155
60356: PPUSH
60357: LD_VAR 0 1
60361: PPUSH
60362: LD_VAR 0 2
60366: PPUSH
60367: CALL_OW 1
60371: ST_TO_ADDR
// end ;
60372: LD_VAR 0 3
60376: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
60377: LD_INT 0
60379: PPUSH
// if not mc_bases or not base or not tech_list then
60380: LD_EXP 116
60384: NOT
60385: PUSH
60386: LD_VAR 0 1
60390: NOT
60391: OR
60392: PUSH
60393: LD_VAR 0 2
60397: NOT
60398: OR
60399: IFFALSE 60403
// exit ;
60401: GO 60428
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
60403: LD_ADDR_EXP 143
60407: PUSH
60408: LD_EXP 143
60412: PPUSH
60413: LD_VAR 0 1
60417: PPUSH
60418: LD_VAR 0 2
60422: PPUSH
60423: CALL_OW 1
60427: ST_TO_ADDR
// end ;
60428: LD_VAR 0 3
60432: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
60433: LD_INT 0
60435: PPUSH
// if not mc_bases or not parking_area or not base then
60436: LD_EXP 116
60440: NOT
60441: PUSH
60442: LD_VAR 0 2
60446: NOT
60447: OR
60448: PUSH
60449: LD_VAR 0 1
60453: NOT
60454: OR
60455: IFFALSE 60459
// exit ;
60457: GO 60484
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
60459: LD_ADDR_EXP 140
60463: PUSH
60464: LD_EXP 140
60468: PPUSH
60469: LD_VAR 0 1
60473: PPUSH
60474: LD_VAR 0 2
60478: PPUSH
60479: CALL_OW 1
60483: ST_TO_ADDR
// end ;
60484: LD_VAR 0 3
60488: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
60489: LD_INT 0
60491: PPUSH
// if not mc_bases or not base or not scan_area then
60492: LD_EXP 116
60496: NOT
60497: PUSH
60498: LD_VAR 0 1
60502: NOT
60503: OR
60504: PUSH
60505: LD_VAR 0 2
60509: NOT
60510: OR
60511: IFFALSE 60515
// exit ;
60513: GO 60540
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
60515: LD_ADDR_EXP 141
60519: PUSH
60520: LD_EXP 141
60524: PPUSH
60525: LD_VAR 0 1
60529: PPUSH
60530: LD_VAR 0 2
60534: PPUSH
60535: CALL_OW 1
60539: ST_TO_ADDR
// end ;
60540: LD_VAR 0 3
60544: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
60545: LD_INT 0
60547: PPUSH
60548: PPUSH
// if not mc_bases or not base then
60549: LD_EXP 116
60553: NOT
60554: PUSH
60555: LD_VAR 0 1
60559: NOT
60560: OR
60561: IFFALSE 60565
// exit ;
60563: GO 60629
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
60565: LD_ADDR_VAR 0 3
60569: PUSH
60570: LD_INT 1
60572: PUSH
60573: LD_INT 2
60575: PUSH
60576: LD_INT 3
60578: PUSH
60579: LD_INT 4
60581: PUSH
60582: LD_INT 11
60584: PUSH
60585: EMPTY
60586: LIST
60587: LIST
60588: LIST
60589: LIST
60590: LIST
60591: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
60592: LD_ADDR_EXP 143
60596: PUSH
60597: LD_EXP 143
60601: PPUSH
60602: LD_VAR 0 1
60606: PPUSH
60607: LD_EXP 143
60611: PUSH
60612: LD_VAR 0 1
60616: ARRAY
60617: PUSH
60618: LD_VAR 0 3
60622: DIFF
60623: PPUSH
60624: CALL_OW 1
60628: ST_TO_ADDR
// end ;
60629: LD_VAR 0 2
60633: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
60634: LD_INT 0
60636: PPUSH
// result := mc_vehicles [ base ] ;
60637: LD_ADDR_VAR 0 3
60641: PUSH
60642: LD_EXP 135
60646: PUSH
60647: LD_VAR 0 1
60651: ARRAY
60652: ST_TO_ADDR
// if onlyCombat then
60653: LD_VAR 0 2
60657: IFFALSE 60835
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
60659: LD_ADDR_VAR 0 3
60663: PUSH
60664: LD_VAR 0 3
60668: PUSH
60669: LD_VAR 0 3
60673: PPUSH
60674: LD_INT 2
60676: PUSH
60677: LD_INT 34
60679: PUSH
60680: LD_INT 12
60682: PUSH
60683: EMPTY
60684: LIST
60685: LIST
60686: PUSH
60687: LD_INT 34
60689: PUSH
60690: LD_INT 51
60692: PUSH
60693: EMPTY
60694: LIST
60695: LIST
60696: PUSH
60697: LD_INT 34
60699: PUSH
60700: LD_EXP 96
60704: PUSH
60705: EMPTY
60706: LIST
60707: LIST
60708: PUSH
60709: LD_INT 34
60711: PUSH
60712: LD_INT 32
60714: PUSH
60715: EMPTY
60716: LIST
60717: LIST
60718: PUSH
60719: LD_INT 34
60721: PUSH
60722: LD_INT 13
60724: PUSH
60725: EMPTY
60726: LIST
60727: LIST
60728: PUSH
60729: LD_INT 34
60731: PUSH
60732: LD_INT 52
60734: PUSH
60735: EMPTY
60736: LIST
60737: LIST
60738: PUSH
60739: LD_INT 34
60741: PUSH
60742: LD_EXP 101
60746: PUSH
60747: EMPTY
60748: LIST
60749: LIST
60750: PUSH
60751: LD_INT 34
60753: PUSH
60754: LD_INT 14
60756: PUSH
60757: EMPTY
60758: LIST
60759: LIST
60760: PUSH
60761: LD_INT 34
60763: PUSH
60764: LD_INT 53
60766: PUSH
60767: EMPTY
60768: LIST
60769: LIST
60770: PUSH
60771: LD_INT 34
60773: PUSH
60774: LD_EXP 95
60778: PUSH
60779: EMPTY
60780: LIST
60781: LIST
60782: PUSH
60783: LD_INT 34
60785: PUSH
60786: LD_INT 31
60788: PUSH
60789: EMPTY
60790: LIST
60791: LIST
60792: PUSH
60793: LD_INT 34
60795: PUSH
60796: LD_INT 48
60798: PUSH
60799: EMPTY
60800: LIST
60801: LIST
60802: PUSH
60803: LD_INT 34
60805: PUSH
60806: LD_INT 8
60808: PUSH
60809: EMPTY
60810: LIST
60811: LIST
60812: PUSH
60813: EMPTY
60814: LIST
60815: LIST
60816: LIST
60817: LIST
60818: LIST
60819: LIST
60820: LIST
60821: LIST
60822: LIST
60823: LIST
60824: LIST
60825: LIST
60826: LIST
60827: LIST
60828: PPUSH
60829: CALL_OW 72
60833: DIFF
60834: ST_TO_ADDR
// end ; end_of_file
60835: LD_VAR 0 3
60839: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
60840: LD_INT 0
60842: PPUSH
60843: PPUSH
60844: PPUSH
// if not mc_bases or not skirmish then
60845: LD_EXP 116
60849: NOT
60850: PUSH
60851: LD_EXP 114
60855: NOT
60856: OR
60857: IFFALSE 60861
// exit ;
60859: GO 61026
// for i = 1 to mc_bases do
60861: LD_ADDR_VAR 0 4
60865: PUSH
60866: DOUBLE
60867: LD_INT 1
60869: DEC
60870: ST_TO_ADDR
60871: LD_EXP 116
60875: PUSH
60876: FOR_TO
60877: IFFALSE 61024
// begin if sci in mc_bases [ i ] then
60879: LD_VAR 0 2
60883: PUSH
60884: LD_EXP 116
60888: PUSH
60889: LD_VAR 0 4
60893: ARRAY
60894: IN
60895: IFFALSE 61022
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
60897: LD_ADDR_EXP 145
60901: PUSH
60902: LD_EXP 145
60906: PPUSH
60907: LD_VAR 0 4
60911: PUSH
60912: LD_EXP 145
60916: PUSH
60917: LD_VAR 0 4
60921: ARRAY
60922: PUSH
60923: LD_INT 1
60925: PLUS
60926: PUSH
60927: EMPTY
60928: LIST
60929: LIST
60930: PPUSH
60931: LD_VAR 0 1
60935: PPUSH
60936: CALL 70608 0 3
60940: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
60941: LD_ADDR_VAR 0 5
60945: PUSH
60946: LD_EXP 116
60950: PUSH
60951: LD_VAR 0 4
60955: ARRAY
60956: PPUSH
60957: LD_INT 2
60959: PUSH
60960: LD_INT 30
60962: PUSH
60963: LD_INT 0
60965: PUSH
60966: EMPTY
60967: LIST
60968: LIST
60969: PUSH
60970: LD_INT 30
60972: PUSH
60973: LD_INT 1
60975: PUSH
60976: EMPTY
60977: LIST
60978: LIST
60979: PUSH
60980: EMPTY
60981: LIST
60982: LIST
60983: LIST
60984: PPUSH
60985: CALL_OW 72
60989: PPUSH
60990: LD_VAR 0 1
60994: PPUSH
60995: CALL_OW 74
60999: ST_TO_ADDR
// if tmp then
61000: LD_VAR 0 5
61004: IFFALSE 61020
// ComStandNearbyBuilding ( ape , tmp ) ;
61006: LD_VAR 0 1
61010: PPUSH
61011: LD_VAR 0 5
61015: PPUSH
61016: CALL 67186 0 2
// break ;
61020: GO 61024
// end ; end ;
61022: GO 60876
61024: POP
61025: POP
// end ;
61026: LD_VAR 0 3
61030: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
61031: LD_INT 0
61033: PPUSH
61034: PPUSH
61035: PPUSH
// if not mc_bases or not skirmish then
61036: LD_EXP 116
61040: NOT
61041: PUSH
61042: LD_EXP 114
61046: NOT
61047: OR
61048: IFFALSE 61052
// exit ;
61050: GO 61141
// for i = 1 to mc_bases do
61052: LD_ADDR_VAR 0 4
61056: PUSH
61057: DOUBLE
61058: LD_INT 1
61060: DEC
61061: ST_TO_ADDR
61062: LD_EXP 116
61066: PUSH
61067: FOR_TO
61068: IFFALSE 61139
// begin if building in mc_busy_turret_list [ i ] then
61070: LD_VAR 0 1
61074: PUSH
61075: LD_EXP 126
61079: PUSH
61080: LD_VAR 0 4
61084: ARRAY
61085: IN
61086: IFFALSE 61137
// begin tmp := mc_busy_turret_list [ i ] diff building ;
61088: LD_ADDR_VAR 0 5
61092: PUSH
61093: LD_EXP 126
61097: PUSH
61098: LD_VAR 0 4
61102: ARRAY
61103: PUSH
61104: LD_VAR 0 1
61108: DIFF
61109: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
61110: LD_ADDR_EXP 126
61114: PUSH
61115: LD_EXP 126
61119: PPUSH
61120: LD_VAR 0 4
61124: PPUSH
61125: LD_VAR 0 5
61129: PPUSH
61130: CALL_OW 1
61134: ST_TO_ADDR
// break ;
61135: GO 61139
// end ; end ;
61137: GO 61067
61139: POP
61140: POP
// end ;
61141: LD_VAR 0 3
61145: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
61146: LD_INT 0
61148: PPUSH
61149: PPUSH
61150: PPUSH
// if not mc_bases or not skirmish then
61151: LD_EXP 116
61155: NOT
61156: PUSH
61157: LD_EXP 114
61161: NOT
61162: OR
61163: IFFALSE 61167
// exit ;
61165: GO 61366
// for i = 1 to mc_bases do
61167: LD_ADDR_VAR 0 5
61171: PUSH
61172: DOUBLE
61173: LD_INT 1
61175: DEC
61176: ST_TO_ADDR
61177: LD_EXP 116
61181: PUSH
61182: FOR_TO
61183: IFFALSE 61364
// if building in mc_bases [ i ] then
61185: LD_VAR 0 1
61189: PUSH
61190: LD_EXP 116
61194: PUSH
61195: LD_VAR 0 5
61199: ARRAY
61200: IN
61201: IFFALSE 61362
// begin tmp := mc_bases [ i ] diff building ;
61203: LD_ADDR_VAR 0 6
61207: PUSH
61208: LD_EXP 116
61212: PUSH
61213: LD_VAR 0 5
61217: ARRAY
61218: PUSH
61219: LD_VAR 0 1
61223: DIFF
61224: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
61225: LD_ADDR_EXP 116
61229: PUSH
61230: LD_EXP 116
61234: PPUSH
61235: LD_VAR 0 5
61239: PPUSH
61240: LD_VAR 0 6
61244: PPUSH
61245: CALL_OW 1
61249: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
61250: LD_VAR 0 1
61254: PUSH
61255: LD_EXP 124
61259: PUSH
61260: LD_VAR 0 5
61264: ARRAY
61265: IN
61266: IFFALSE 61305
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
61268: LD_ADDR_EXP 124
61272: PUSH
61273: LD_EXP 124
61277: PPUSH
61278: LD_VAR 0 5
61282: PPUSH
61283: LD_EXP 124
61287: PUSH
61288: LD_VAR 0 5
61292: ARRAY
61293: PUSH
61294: LD_VAR 0 1
61298: DIFF
61299: PPUSH
61300: CALL_OW 1
61304: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
61305: LD_VAR 0 1
61309: PUSH
61310: LD_EXP 125
61314: PUSH
61315: LD_VAR 0 5
61319: ARRAY
61320: IN
61321: IFFALSE 61360
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
61323: LD_ADDR_EXP 125
61327: PUSH
61328: LD_EXP 125
61332: PPUSH
61333: LD_VAR 0 5
61337: PPUSH
61338: LD_EXP 125
61342: PUSH
61343: LD_VAR 0 5
61347: ARRAY
61348: PUSH
61349: LD_VAR 0 1
61353: DIFF
61354: PPUSH
61355: CALL_OW 1
61359: ST_TO_ADDR
// break ;
61360: GO 61364
// end ;
61362: GO 61182
61364: POP
61365: POP
// end ;
61366: LD_VAR 0 4
61370: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
61371: LD_INT 0
61373: PPUSH
61374: PPUSH
61375: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
61376: LD_EXP 116
61380: NOT
61381: PUSH
61382: LD_EXP 114
61386: NOT
61387: OR
61388: PUSH
61389: LD_VAR 0 3
61393: PUSH
61394: LD_EXP 142
61398: IN
61399: NOT
61400: OR
61401: IFFALSE 61405
// exit ;
61403: GO 61528
// for i = 1 to mc_vehicles do
61405: LD_ADDR_VAR 0 6
61409: PUSH
61410: DOUBLE
61411: LD_INT 1
61413: DEC
61414: ST_TO_ADDR
61415: LD_EXP 135
61419: PUSH
61420: FOR_TO
61421: IFFALSE 61526
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
61423: LD_VAR 0 2
61427: PUSH
61428: LD_EXP 135
61432: PUSH
61433: LD_VAR 0 6
61437: ARRAY
61438: IN
61439: PUSH
61440: LD_VAR 0 1
61444: PUSH
61445: LD_EXP 135
61449: PUSH
61450: LD_VAR 0 6
61454: ARRAY
61455: IN
61456: OR
61457: IFFALSE 61524
// begin tmp := mc_vehicles [ i ] diff old ;
61459: LD_ADDR_VAR 0 7
61463: PUSH
61464: LD_EXP 135
61468: PUSH
61469: LD_VAR 0 6
61473: ARRAY
61474: PUSH
61475: LD_VAR 0 2
61479: DIFF
61480: ST_TO_ADDR
// tmp := tmp diff new ;
61481: LD_ADDR_VAR 0 7
61485: PUSH
61486: LD_VAR 0 7
61490: PUSH
61491: LD_VAR 0 1
61495: DIFF
61496: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
61497: LD_ADDR_EXP 135
61501: PUSH
61502: LD_EXP 135
61506: PPUSH
61507: LD_VAR 0 6
61511: PPUSH
61512: LD_VAR 0 7
61516: PPUSH
61517: CALL_OW 1
61521: ST_TO_ADDR
// break ;
61522: GO 61526
// end ;
61524: GO 61420
61526: POP
61527: POP
// end ;
61528: LD_VAR 0 5
61532: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
61533: LD_INT 0
61535: PPUSH
61536: PPUSH
61537: PPUSH
61538: PPUSH
// if not mc_bases or not skirmish then
61539: LD_EXP 116
61543: NOT
61544: PUSH
61545: LD_EXP 114
61549: NOT
61550: OR
61551: IFFALSE 61555
// exit ;
61553: GO 61947
// side := GetSide ( vehicle ) ;
61555: LD_ADDR_VAR 0 5
61559: PUSH
61560: LD_VAR 0 1
61564: PPUSH
61565: CALL_OW 255
61569: ST_TO_ADDR
// for i = 1 to mc_bases do
61570: LD_ADDR_VAR 0 4
61574: PUSH
61575: DOUBLE
61576: LD_INT 1
61578: DEC
61579: ST_TO_ADDR
61580: LD_EXP 116
61584: PUSH
61585: FOR_TO
61586: IFFALSE 61945
// begin if factory in mc_bases [ i ] then
61588: LD_VAR 0 2
61592: PUSH
61593: LD_EXP 116
61597: PUSH
61598: LD_VAR 0 4
61602: ARRAY
61603: IN
61604: IFFALSE 61943
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
61606: LD_EXP 138
61610: PUSH
61611: LD_VAR 0 4
61615: ARRAY
61616: PUSH
61617: LD_EXP 127
61621: PUSH
61622: LD_VAR 0 4
61626: ARRAY
61627: LESS
61628: PUSH
61629: LD_VAR 0 1
61633: PPUSH
61634: CALL_OW 264
61638: PUSH
61639: LD_INT 31
61641: PUSH
61642: LD_INT 32
61644: PUSH
61645: LD_INT 51
61647: PUSH
61648: LD_EXP 96
61652: PUSH
61653: LD_INT 12
61655: PUSH
61656: LD_INT 30
61658: PUSH
61659: LD_EXP 95
61663: PUSH
61664: LD_INT 11
61666: PUSH
61667: LD_INT 53
61669: PUSH
61670: LD_INT 14
61672: PUSH
61673: LD_EXP 99
61677: PUSH
61678: LD_INT 29
61680: PUSH
61681: LD_EXP 97
61685: PUSH
61686: LD_INT 13
61688: PUSH
61689: LD_INT 52
61691: PUSH
61692: LD_EXP 101
61696: PUSH
61697: LD_INT 48
61699: PUSH
61700: LD_INT 8
61702: PUSH
61703: EMPTY
61704: LIST
61705: LIST
61706: LIST
61707: LIST
61708: LIST
61709: LIST
61710: LIST
61711: LIST
61712: LIST
61713: LIST
61714: LIST
61715: LIST
61716: LIST
61717: LIST
61718: LIST
61719: LIST
61720: LIST
61721: LIST
61722: IN
61723: NOT
61724: AND
61725: IFFALSE 61773
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
61727: LD_ADDR_EXP 138
61731: PUSH
61732: LD_EXP 138
61736: PPUSH
61737: LD_VAR 0 4
61741: PUSH
61742: LD_EXP 138
61746: PUSH
61747: LD_VAR 0 4
61751: ARRAY
61752: PUSH
61753: LD_INT 1
61755: PLUS
61756: PUSH
61757: EMPTY
61758: LIST
61759: LIST
61760: PPUSH
61761: LD_VAR 0 1
61765: PPUSH
61766: CALL 70608 0 3
61770: ST_TO_ADDR
61771: GO 61817
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
61773: LD_ADDR_EXP 135
61777: PUSH
61778: LD_EXP 135
61782: PPUSH
61783: LD_VAR 0 4
61787: PUSH
61788: LD_EXP 135
61792: PUSH
61793: LD_VAR 0 4
61797: ARRAY
61798: PUSH
61799: LD_INT 1
61801: PLUS
61802: PUSH
61803: EMPTY
61804: LIST
61805: LIST
61806: PPUSH
61807: LD_VAR 0 1
61811: PPUSH
61812: CALL 70608 0 3
61816: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
61817: LD_VAR 0 1
61821: PPUSH
61822: CALL_OW 263
61826: PUSH
61827: LD_INT 2
61829: EQUAL
61830: IFFALSE 61859
// begin repeat wait ( 0 0$3 ) ;
61832: LD_INT 105
61834: PPUSH
61835: CALL_OW 67
// Connect ( vehicle ) ;
61839: LD_VAR 0 1
61843: PPUSH
61844: CALL 73579 0 1
// until IsControledBy ( vehicle ) ;
61848: LD_VAR 0 1
61852: PPUSH
61853: CALL_OW 312
61857: IFFALSE 61832
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
61859: LD_VAR 0 1
61863: PPUSH
61864: LD_EXP 140
61868: PUSH
61869: LD_VAR 0 4
61873: ARRAY
61874: PPUSH
61875: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
61879: LD_VAR 0 1
61883: PPUSH
61884: CALL_OW 263
61888: PUSH
61889: LD_INT 1
61891: NONEQUAL
61892: IFFALSE 61896
// break ;
61894: GO 61945
// repeat wait ( 0 0$1 ) ;
61896: LD_INT 35
61898: PPUSH
61899: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
61903: LD_VAR 0 1
61907: PPUSH
61908: LD_EXP 140
61912: PUSH
61913: LD_VAR 0 4
61917: ARRAY
61918: PPUSH
61919: CALL_OW 308
61923: IFFALSE 61896
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
61925: LD_VAR 0 1
61929: PPUSH
61930: CALL_OW 311
61934: PPUSH
61935: CALL_OW 121
// exit ;
61939: POP
61940: POP
61941: GO 61947
// end ; end ;
61943: GO 61585
61945: POP
61946: POP
// end ;
61947: LD_VAR 0 3
61951: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
61952: LD_INT 0
61954: PPUSH
61955: PPUSH
61956: PPUSH
61957: PPUSH
// if not mc_bases or not skirmish then
61958: LD_EXP 116
61962: NOT
61963: PUSH
61964: LD_EXP 114
61968: NOT
61969: OR
61970: IFFALSE 61974
// exit ;
61972: GO 62327
// repeat wait ( 0 0$1 ) ;
61974: LD_INT 35
61976: PPUSH
61977: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
61981: LD_VAR 0 2
61985: PPUSH
61986: LD_VAR 0 3
61990: PPUSH
61991: CALL_OW 284
61995: IFFALSE 61974
// if GetResourceTypeXY ( x , y ) = mat_artefact then
61997: LD_VAR 0 2
62001: PPUSH
62002: LD_VAR 0 3
62006: PPUSH
62007: CALL_OW 283
62011: PUSH
62012: LD_INT 4
62014: EQUAL
62015: IFFALSE 62019
// exit ;
62017: GO 62327
// for i = 1 to mc_bases do
62019: LD_ADDR_VAR 0 7
62023: PUSH
62024: DOUBLE
62025: LD_INT 1
62027: DEC
62028: ST_TO_ADDR
62029: LD_EXP 116
62033: PUSH
62034: FOR_TO
62035: IFFALSE 62325
// begin if mc_crates_area [ i ] then
62037: LD_EXP 134
62041: PUSH
62042: LD_VAR 0 7
62046: ARRAY
62047: IFFALSE 62158
// for j in mc_crates_area [ i ] do
62049: LD_ADDR_VAR 0 8
62053: PUSH
62054: LD_EXP 134
62058: PUSH
62059: LD_VAR 0 7
62063: ARRAY
62064: PUSH
62065: FOR_IN
62066: IFFALSE 62156
// if InArea ( x , y , j ) then
62068: LD_VAR 0 2
62072: PPUSH
62073: LD_VAR 0 3
62077: PPUSH
62078: LD_VAR 0 8
62082: PPUSH
62083: CALL_OW 309
62087: IFFALSE 62154
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
62089: LD_ADDR_EXP 132
62093: PUSH
62094: LD_EXP 132
62098: PPUSH
62099: LD_VAR 0 7
62103: PUSH
62104: LD_EXP 132
62108: PUSH
62109: LD_VAR 0 7
62113: ARRAY
62114: PUSH
62115: LD_INT 1
62117: PLUS
62118: PUSH
62119: EMPTY
62120: LIST
62121: LIST
62122: PPUSH
62123: LD_VAR 0 4
62127: PUSH
62128: LD_VAR 0 2
62132: PUSH
62133: LD_VAR 0 3
62137: PUSH
62138: EMPTY
62139: LIST
62140: LIST
62141: LIST
62142: PPUSH
62143: CALL 70608 0 3
62147: ST_TO_ADDR
// exit ;
62148: POP
62149: POP
62150: POP
62151: POP
62152: GO 62327
// end ;
62154: GO 62065
62156: POP
62157: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62158: LD_ADDR_VAR 0 9
62162: PUSH
62163: LD_EXP 116
62167: PUSH
62168: LD_VAR 0 7
62172: ARRAY
62173: PPUSH
62174: LD_INT 2
62176: PUSH
62177: LD_INT 30
62179: PUSH
62180: LD_INT 0
62182: PUSH
62183: EMPTY
62184: LIST
62185: LIST
62186: PUSH
62187: LD_INT 30
62189: PUSH
62190: LD_INT 1
62192: PUSH
62193: EMPTY
62194: LIST
62195: LIST
62196: PUSH
62197: EMPTY
62198: LIST
62199: LIST
62200: LIST
62201: PPUSH
62202: CALL_OW 72
62206: ST_TO_ADDR
// if not depot then
62207: LD_VAR 0 9
62211: NOT
62212: IFFALSE 62216
// continue ;
62214: GO 62034
// for j in depot do
62216: LD_ADDR_VAR 0 8
62220: PUSH
62221: LD_VAR 0 9
62225: PUSH
62226: FOR_IN
62227: IFFALSE 62321
// if GetDistUnitXY ( j , x , y ) < 30 then
62229: LD_VAR 0 8
62233: PPUSH
62234: LD_VAR 0 2
62238: PPUSH
62239: LD_VAR 0 3
62243: PPUSH
62244: CALL_OW 297
62248: PUSH
62249: LD_INT 30
62251: LESS
62252: IFFALSE 62319
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
62254: LD_ADDR_EXP 132
62258: PUSH
62259: LD_EXP 132
62263: PPUSH
62264: LD_VAR 0 7
62268: PUSH
62269: LD_EXP 132
62273: PUSH
62274: LD_VAR 0 7
62278: ARRAY
62279: PUSH
62280: LD_INT 1
62282: PLUS
62283: PUSH
62284: EMPTY
62285: LIST
62286: LIST
62287: PPUSH
62288: LD_VAR 0 4
62292: PUSH
62293: LD_VAR 0 2
62297: PUSH
62298: LD_VAR 0 3
62302: PUSH
62303: EMPTY
62304: LIST
62305: LIST
62306: LIST
62307: PPUSH
62308: CALL 70608 0 3
62312: ST_TO_ADDR
// exit ;
62313: POP
62314: POP
62315: POP
62316: POP
62317: GO 62327
// end ;
62319: GO 62226
62321: POP
62322: POP
// end ;
62323: GO 62034
62325: POP
62326: POP
// end ;
62327: LD_VAR 0 6
62331: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
62332: LD_INT 0
62334: PPUSH
62335: PPUSH
62336: PPUSH
62337: PPUSH
// if not mc_bases or not skirmish then
62338: LD_EXP 116
62342: NOT
62343: PUSH
62344: LD_EXP 114
62348: NOT
62349: OR
62350: IFFALSE 62354
// exit ;
62352: GO 62631
// side := GetSide ( lab ) ;
62354: LD_ADDR_VAR 0 4
62358: PUSH
62359: LD_VAR 0 2
62363: PPUSH
62364: CALL_OW 255
62368: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
62369: LD_VAR 0 4
62373: PUSH
62374: LD_EXP 142
62378: IN
62379: NOT
62380: PUSH
62381: LD_EXP 143
62385: NOT
62386: OR
62387: PUSH
62388: LD_EXP 116
62392: NOT
62393: OR
62394: IFFALSE 62398
// exit ;
62396: GO 62631
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
62398: LD_ADDR_EXP 143
62402: PUSH
62403: LD_EXP 143
62407: PPUSH
62408: LD_VAR 0 4
62412: PPUSH
62413: LD_EXP 143
62417: PUSH
62418: LD_VAR 0 4
62422: ARRAY
62423: PUSH
62424: LD_VAR 0 1
62428: DIFF
62429: PPUSH
62430: CALL_OW 1
62434: ST_TO_ADDR
// for i = 1 to mc_bases do
62435: LD_ADDR_VAR 0 5
62439: PUSH
62440: DOUBLE
62441: LD_INT 1
62443: DEC
62444: ST_TO_ADDR
62445: LD_EXP 116
62449: PUSH
62450: FOR_TO
62451: IFFALSE 62629
// begin if lab in mc_bases [ i ] then
62453: LD_VAR 0 2
62457: PUSH
62458: LD_EXP 116
62462: PUSH
62463: LD_VAR 0 5
62467: ARRAY
62468: IN
62469: IFFALSE 62627
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
62471: LD_VAR 0 1
62475: PUSH
62476: LD_INT 11
62478: PUSH
62479: LD_INT 4
62481: PUSH
62482: LD_INT 3
62484: PUSH
62485: LD_INT 2
62487: PUSH
62488: EMPTY
62489: LIST
62490: LIST
62491: LIST
62492: LIST
62493: IN
62494: PUSH
62495: LD_EXP 146
62499: PUSH
62500: LD_VAR 0 5
62504: ARRAY
62505: AND
62506: IFFALSE 62627
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
62508: LD_ADDR_VAR 0 6
62512: PUSH
62513: LD_EXP 146
62517: PUSH
62518: LD_VAR 0 5
62522: ARRAY
62523: PUSH
62524: LD_INT 1
62526: ARRAY
62527: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62528: LD_ADDR_EXP 146
62532: PUSH
62533: LD_EXP 146
62537: PPUSH
62538: LD_VAR 0 5
62542: PPUSH
62543: EMPTY
62544: PPUSH
62545: CALL_OW 1
62549: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
62550: LD_VAR 0 6
62554: PPUSH
62555: LD_INT 0
62557: PPUSH
62558: CALL_OW 109
// ComExitBuilding ( tmp ) ;
62562: LD_VAR 0 6
62566: PPUSH
62567: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
62571: LD_ADDR_EXP 145
62575: PUSH
62576: LD_EXP 145
62580: PPUSH
62581: LD_VAR 0 5
62585: PPUSH
62586: LD_EXP 145
62590: PUSH
62591: LD_VAR 0 5
62595: ARRAY
62596: PPUSH
62597: LD_INT 1
62599: PPUSH
62600: LD_VAR 0 6
62604: PPUSH
62605: CALL_OW 2
62609: PPUSH
62610: CALL_OW 1
62614: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
62615: LD_VAR 0 5
62619: PPUSH
62620: LD_INT 112
62622: PPUSH
62623: CALL 39297 0 2
// end ; end ; end ;
62627: GO 62450
62629: POP
62630: POP
// end ;
62631: LD_VAR 0 3
62635: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
62636: LD_INT 0
62638: PPUSH
62639: PPUSH
62640: PPUSH
62641: PPUSH
62642: PPUSH
62643: PPUSH
62644: PPUSH
62645: PPUSH
// if not mc_bases or not skirmish then
62646: LD_EXP 116
62650: NOT
62651: PUSH
62652: LD_EXP 114
62656: NOT
62657: OR
62658: IFFALSE 62662
// exit ;
62660: GO 64033
// for i = 1 to mc_bases do
62662: LD_ADDR_VAR 0 3
62666: PUSH
62667: DOUBLE
62668: LD_INT 1
62670: DEC
62671: ST_TO_ADDR
62672: LD_EXP 116
62676: PUSH
62677: FOR_TO
62678: IFFALSE 64031
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
62680: LD_VAR 0 1
62684: PUSH
62685: LD_EXP 116
62689: PUSH
62690: LD_VAR 0 3
62694: ARRAY
62695: IN
62696: PUSH
62697: LD_VAR 0 1
62701: PUSH
62702: LD_EXP 123
62706: PUSH
62707: LD_VAR 0 3
62711: ARRAY
62712: IN
62713: OR
62714: PUSH
62715: LD_VAR 0 1
62719: PUSH
62720: LD_EXP 138
62724: PUSH
62725: LD_VAR 0 3
62729: ARRAY
62730: IN
62731: OR
62732: PUSH
62733: LD_VAR 0 1
62737: PUSH
62738: LD_EXP 135
62742: PUSH
62743: LD_VAR 0 3
62747: ARRAY
62748: IN
62749: OR
62750: PUSH
62751: LD_VAR 0 1
62755: PUSH
62756: LD_EXP 145
62760: PUSH
62761: LD_VAR 0 3
62765: ARRAY
62766: IN
62767: OR
62768: PUSH
62769: LD_VAR 0 1
62773: PUSH
62774: LD_EXP 146
62778: PUSH
62779: LD_VAR 0 3
62783: ARRAY
62784: IN
62785: OR
62786: IFFALSE 64029
// begin if un in mc_ape [ i ] then
62788: LD_VAR 0 1
62792: PUSH
62793: LD_EXP 145
62797: PUSH
62798: LD_VAR 0 3
62802: ARRAY
62803: IN
62804: IFFALSE 62843
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
62806: LD_ADDR_EXP 145
62810: PUSH
62811: LD_EXP 145
62815: PPUSH
62816: LD_VAR 0 3
62820: PPUSH
62821: LD_EXP 145
62825: PUSH
62826: LD_VAR 0 3
62830: ARRAY
62831: PUSH
62832: LD_VAR 0 1
62836: DIFF
62837: PPUSH
62838: CALL_OW 1
62842: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
62843: LD_VAR 0 1
62847: PUSH
62848: LD_EXP 146
62852: PUSH
62853: LD_VAR 0 3
62857: ARRAY
62858: IN
62859: IFFALSE 62883
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62861: LD_ADDR_EXP 146
62865: PUSH
62866: LD_EXP 146
62870: PPUSH
62871: LD_VAR 0 3
62875: PPUSH
62876: EMPTY
62877: PPUSH
62878: CALL_OW 1
62882: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
62883: LD_VAR 0 1
62887: PPUSH
62888: CALL_OW 247
62892: PUSH
62893: LD_INT 2
62895: EQUAL
62896: PUSH
62897: LD_VAR 0 1
62901: PPUSH
62902: CALL_OW 110
62906: PUSH
62907: LD_INT 20
62909: EQUAL
62910: PUSH
62911: LD_VAR 0 1
62915: PUSH
62916: LD_EXP 138
62920: PUSH
62921: LD_VAR 0 3
62925: ARRAY
62926: IN
62927: OR
62928: PUSH
62929: LD_VAR 0 1
62933: PPUSH
62934: CALL_OW 264
62938: PUSH
62939: LD_INT 12
62941: PUSH
62942: LD_INT 51
62944: PUSH
62945: LD_EXP 96
62949: PUSH
62950: LD_INT 32
62952: PUSH
62953: LD_INT 13
62955: PUSH
62956: LD_INT 52
62958: PUSH
62959: LD_INT 31
62961: PUSH
62962: EMPTY
62963: LIST
62964: LIST
62965: LIST
62966: LIST
62967: LIST
62968: LIST
62969: LIST
62970: IN
62971: OR
62972: AND
62973: IFFALSE 63281
// begin if un in mc_defender [ i ] then
62975: LD_VAR 0 1
62979: PUSH
62980: LD_EXP 138
62984: PUSH
62985: LD_VAR 0 3
62989: ARRAY
62990: IN
62991: IFFALSE 63030
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62993: LD_ADDR_EXP 138
62997: PUSH
62998: LD_EXP 138
63002: PPUSH
63003: LD_VAR 0 3
63007: PPUSH
63008: LD_EXP 138
63012: PUSH
63013: LD_VAR 0 3
63017: ARRAY
63018: PUSH
63019: LD_VAR 0 1
63023: DIFF
63024: PPUSH
63025: CALL_OW 1
63029: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
63030: LD_ADDR_VAR 0 8
63034: PUSH
63035: LD_VAR 0 3
63039: PPUSH
63040: LD_INT 3
63042: PPUSH
63043: CALL 59671 0 2
63047: ST_TO_ADDR
// if fac then
63048: LD_VAR 0 8
63052: IFFALSE 63281
// begin for j in fac do
63054: LD_ADDR_VAR 0 4
63058: PUSH
63059: LD_VAR 0 8
63063: PUSH
63064: FOR_IN
63065: IFFALSE 63279
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
63067: LD_ADDR_VAR 0 9
63071: PUSH
63072: LD_VAR 0 8
63076: PPUSH
63077: LD_VAR 0 1
63081: PPUSH
63082: CALL_OW 265
63086: PPUSH
63087: LD_VAR 0 1
63091: PPUSH
63092: CALL_OW 262
63096: PPUSH
63097: LD_VAR 0 1
63101: PPUSH
63102: CALL_OW 263
63106: PPUSH
63107: LD_VAR 0 1
63111: PPUSH
63112: CALL_OW 264
63116: PPUSH
63117: CALL 68104 0 5
63121: ST_TO_ADDR
// if components then
63122: LD_VAR 0 9
63126: IFFALSE 63277
// begin if GetWeapon ( un ) = ar_control_tower then
63128: LD_VAR 0 1
63132: PPUSH
63133: CALL_OW 264
63137: PUSH
63138: LD_INT 31
63140: EQUAL
63141: IFFALSE 63258
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
63143: LD_VAR 0 1
63147: PPUSH
63148: CALL_OW 311
63152: PPUSH
63153: LD_INT 0
63155: PPUSH
63156: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
63160: LD_ADDR_EXP 156
63164: PUSH
63165: LD_EXP 156
63169: PPUSH
63170: LD_VAR 0 3
63174: PPUSH
63175: LD_EXP 156
63179: PUSH
63180: LD_VAR 0 3
63184: ARRAY
63185: PUSH
63186: LD_VAR 0 1
63190: PPUSH
63191: CALL_OW 311
63195: DIFF
63196: PPUSH
63197: CALL_OW 1
63201: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
63202: LD_ADDR_VAR 0 7
63206: PUSH
63207: LD_EXP 137
63211: PUSH
63212: LD_VAR 0 3
63216: ARRAY
63217: PPUSH
63218: LD_INT 1
63220: PPUSH
63221: LD_VAR 0 9
63225: PPUSH
63226: CALL_OW 2
63230: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
63231: LD_ADDR_EXP 137
63235: PUSH
63236: LD_EXP 137
63240: PPUSH
63241: LD_VAR 0 3
63245: PPUSH
63246: LD_VAR 0 7
63250: PPUSH
63251: CALL_OW 1
63255: ST_TO_ADDR
// end else
63256: GO 63275
// MC_InsertProduceList ( i , [ components ] ) ;
63258: LD_VAR 0 3
63262: PPUSH
63263: LD_VAR 0 9
63267: PUSH
63268: EMPTY
63269: LIST
63270: PPUSH
63271: CALL 59216 0 2
// break ;
63275: GO 63279
// end ; end ;
63277: GO 63064
63279: POP
63280: POP
// end ; end ; if GetType ( un ) = unit_building then
63281: LD_VAR 0 1
63285: PPUSH
63286: CALL_OW 247
63290: PUSH
63291: LD_INT 3
63293: EQUAL
63294: IFFALSE 63697
// begin btype := GetBType ( un ) ;
63296: LD_ADDR_VAR 0 5
63300: PUSH
63301: LD_VAR 0 1
63305: PPUSH
63306: CALL_OW 266
63310: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
63311: LD_VAR 0 5
63315: PUSH
63316: LD_INT 29
63318: PUSH
63319: LD_INT 30
63321: PUSH
63322: EMPTY
63323: LIST
63324: LIST
63325: IN
63326: IFFALSE 63399
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
63328: LD_VAR 0 1
63332: PPUSH
63333: CALL_OW 250
63337: PPUSH
63338: LD_VAR 0 1
63342: PPUSH
63343: CALL_OW 251
63347: PPUSH
63348: LD_VAR 0 1
63352: PPUSH
63353: CALL_OW 255
63357: PPUSH
63358: CALL_OW 440
63362: NOT
63363: IFFALSE 63399
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
63365: LD_VAR 0 1
63369: PPUSH
63370: CALL_OW 250
63374: PPUSH
63375: LD_VAR 0 1
63379: PPUSH
63380: CALL_OW 251
63384: PPUSH
63385: LD_VAR 0 1
63389: PPUSH
63390: CALL_OW 255
63394: PPUSH
63395: CALL_OW 441
// end ; if btype = b_warehouse then
63399: LD_VAR 0 5
63403: PUSH
63404: LD_INT 1
63406: EQUAL
63407: IFFALSE 63425
// begin btype := b_depot ;
63409: LD_ADDR_VAR 0 5
63413: PUSH
63414: LD_INT 0
63416: ST_TO_ADDR
// pos := 1 ;
63417: LD_ADDR_VAR 0 6
63421: PUSH
63422: LD_INT 1
63424: ST_TO_ADDR
// end ; if btype = b_factory then
63425: LD_VAR 0 5
63429: PUSH
63430: LD_INT 3
63432: EQUAL
63433: IFFALSE 63451
// begin btype := b_workshop ;
63435: LD_ADDR_VAR 0 5
63439: PUSH
63440: LD_INT 2
63442: ST_TO_ADDR
// pos := 1 ;
63443: LD_ADDR_VAR 0 6
63447: PUSH
63448: LD_INT 1
63450: ST_TO_ADDR
// end ; if btype = b_barracks then
63451: LD_VAR 0 5
63455: PUSH
63456: LD_INT 5
63458: EQUAL
63459: IFFALSE 63469
// btype := b_armoury ;
63461: LD_ADDR_VAR 0 5
63465: PUSH
63466: LD_INT 4
63468: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
63469: LD_VAR 0 5
63473: PUSH
63474: LD_INT 7
63476: PUSH
63477: LD_INT 8
63479: PUSH
63480: EMPTY
63481: LIST
63482: LIST
63483: IN
63484: IFFALSE 63494
// btype := b_lab ;
63486: LD_ADDR_VAR 0 5
63490: PUSH
63491: LD_INT 6
63493: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
63494: LD_ADDR_EXP 121
63498: PUSH
63499: LD_EXP 121
63503: PPUSH
63504: LD_VAR 0 3
63508: PUSH
63509: LD_EXP 121
63513: PUSH
63514: LD_VAR 0 3
63518: ARRAY
63519: PUSH
63520: LD_INT 1
63522: PLUS
63523: PUSH
63524: EMPTY
63525: LIST
63526: LIST
63527: PPUSH
63528: LD_VAR 0 5
63532: PUSH
63533: LD_VAR 0 1
63537: PPUSH
63538: CALL_OW 250
63542: PUSH
63543: LD_VAR 0 1
63547: PPUSH
63548: CALL_OW 251
63552: PUSH
63553: LD_VAR 0 1
63557: PPUSH
63558: CALL_OW 254
63562: PUSH
63563: EMPTY
63564: LIST
63565: LIST
63566: LIST
63567: LIST
63568: PPUSH
63569: CALL 70608 0 3
63573: ST_TO_ADDR
// if pos = 1 then
63574: LD_VAR 0 6
63578: PUSH
63579: LD_INT 1
63581: EQUAL
63582: IFFALSE 63697
// begin tmp := mc_build_list [ i ] ;
63584: LD_ADDR_VAR 0 7
63588: PUSH
63589: LD_EXP 121
63593: PUSH
63594: LD_VAR 0 3
63598: ARRAY
63599: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
63600: LD_VAR 0 7
63604: PPUSH
63605: LD_INT 2
63607: PUSH
63608: LD_INT 30
63610: PUSH
63611: LD_INT 0
63613: PUSH
63614: EMPTY
63615: LIST
63616: LIST
63617: PUSH
63618: LD_INT 30
63620: PUSH
63621: LD_INT 1
63623: PUSH
63624: EMPTY
63625: LIST
63626: LIST
63627: PUSH
63628: EMPTY
63629: LIST
63630: LIST
63631: LIST
63632: PPUSH
63633: CALL_OW 72
63637: IFFALSE 63647
// pos := 2 ;
63639: LD_ADDR_VAR 0 6
63643: PUSH
63644: LD_INT 2
63646: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
63647: LD_ADDR_VAR 0 7
63651: PUSH
63652: LD_VAR 0 7
63656: PPUSH
63657: LD_VAR 0 6
63661: PPUSH
63662: LD_VAR 0 7
63666: PPUSH
63667: CALL 70934 0 3
63671: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
63672: LD_ADDR_EXP 121
63676: PUSH
63677: LD_EXP 121
63681: PPUSH
63682: LD_VAR 0 3
63686: PPUSH
63687: LD_VAR 0 7
63691: PPUSH
63692: CALL_OW 1
63696: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63697: LD_VAR 0 1
63701: PUSH
63702: LD_EXP 116
63706: PUSH
63707: LD_VAR 0 3
63711: ARRAY
63712: IN
63713: IFFALSE 63752
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
63715: LD_ADDR_EXP 116
63719: PUSH
63720: LD_EXP 116
63724: PPUSH
63725: LD_VAR 0 3
63729: PPUSH
63730: LD_EXP 116
63734: PUSH
63735: LD_VAR 0 3
63739: ARRAY
63740: PUSH
63741: LD_VAR 0 1
63745: DIFF
63746: PPUSH
63747: CALL_OW 1
63751: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
63752: LD_VAR 0 1
63756: PUSH
63757: LD_EXP 123
63761: PUSH
63762: LD_VAR 0 3
63766: ARRAY
63767: IN
63768: IFFALSE 63807
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
63770: LD_ADDR_EXP 123
63774: PUSH
63775: LD_EXP 123
63779: PPUSH
63780: LD_VAR 0 3
63784: PPUSH
63785: LD_EXP 123
63789: PUSH
63790: LD_VAR 0 3
63794: ARRAY
63795: PUSH
63796: LD_VAR 0 1
63800: DIFF
63801: PPUSH
63802: CALL_OW 1
63806: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
63807: LD_VAR 0 1
63811: PUSH
63812: LD_EXP 135
63816: PUSH
63817: LD_VAR 0 3
63821: ARRAY
63822: IN
63823: IFFALSE 63862
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
63825: LD_ADDR_EXP 135
63829: PUSH
63830: LD_EXP 135
63834: PPUSH
63835: LD_VAR 0 3
63839: PPUSH
63840: LD_EXP 135
63844: PUSH
63845: LD_VAR 0 3
63849: ARRAY
63850: PUSH
63851: LD_VAR 0 1
63855: DIFF
63856: PPUSH
63857: CALL_OW 1
63861: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
63862: LD_VAR 0 1
63866: PUSH
63867: LD_EXP 138
63871: PUSH
63872: LD_VAR 0 3
63876: ARRAY
63877: IN
63878: IFFALSE 63917
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63880: LD_ADDR_EXP 138
63884: PUSH
63885: LD_EXP 138
63889: PPUSH
63890: LD_VAR 0 3
63894: PPUSH
63895: LD_EXP 138
63899: PUSH
63900: LD_VAR 0 3
63904: ARRAY
63905: PUSH
63906: LD_VAR 0 1
63910: DIFF
63911: PPUSH
63912: CALL_OW 1
63916: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
63917: LD_VAR 0 1
63921: PUSH
63922: LD_EXP 125
63926: PUSH
63927: LD_VAR 0 3
63931: ARRAY
63932: IN
63933: IFFALSE 63972
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
63935: LD_ADDR_EXP 125
63939: PUSH
63940: LD_EXP 125
63944: PPUSH
63945: LD_VAR 0 3
63949: PPUSH
63950: LD_EXP 125
63954: PUSH
63955: LD_VAR 0 3
63959: ARRAY
63960: PUSH
63961: LD_VAR 0 1
63965: DIFF
63966: PPUSH
63967: CALL_OW 1
63971: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
63972: LD_VAR 0 1
63976: PUSH
63977: LD_EXP 124
63981: PUSH
63982: LD_VAR 0 3
63986: ARRAY
63987: IN
63988: IFFALSE 64027
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
63990: LD_ADDR_EXP 124
63994: PUSH
63995: LD_EXP 124
63999: PPUSH
64000: LD_VAR 0 3
64004: PPUSH
64005: LD_EXP 124
64009: PUSH
64010: LD_VAR 0 3
64014: ARRAY
64015: PUSH
64016: LD_VAR 0 1
64020: DIFF
64021: PPUSH
64022: CALL_OW 1
64026: ST_TO_ADDR
// end ; break ;
64027: GO 64031
// end ;
64029: GO 62677
64031: POP
64032: POP
// end ;
64033: LD_VAR 0 2
64037: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
64038: LD_INT 0
64040: PPUSH
64041: PPUSH
64042: PPUSH
// if not mc_bases or not skirmish then
64043: LD_EXP 116
64047: NOT
64048: PUSH
64049: LD_EXP 114
64053: NOT
64054: OR
64055: IFFALSE 64059
// exit ;
64057: GO 64274
// for i = 1 to mc_bases do
64059: LD_ADDR_VAR 0 3
64063: PUSH
64064: DOUBLE
64065: LD_INT 1
64067: DEC
64068: ST_TO_ADDR
64069: LD_EXP 116
64073: PUSH
64074: FOR_TO
64075: IFFALSE 64272
// begin if building in mc_construct_list [ i ] then
64077: LD_VAR 0 1
64081: PUSH
64082: LD_EXP 123
64086: PUSH
64087: LD_VAR 0 3
64091: ARRAY
64092: IN
64093: IFFALSE 64270
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
64095: LD_ADDR_EXP 123
64099: PUSH
64100: LD_EXP 123
64104: PPUSH
64105: LD_VAR 0 3
64109: PPUSH
64110: LD_EXP 123
64114: PUSH
64115: LD_VAR 0 3
64119: ARRAY
64120: PUSH
64121: LD_VAR 0 1
64125: DIFF
64126: PPUSH
64127: CALL_OW 1
64131: ST_TO_ADDR
// if building in mc_lab [ i ] then
64132: LD_VAR 0 1
64136: PUSH
64137: LD_EXP 149
64141: PUSH
64142: LD_VAR 0 3
64146: ARRAY
64147: IN
64148: IFFALSE 64203
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
64150: LD_ADDR_EXP 150
64154: PUSH
64155: LD_EXP 150
64159: PPUSH
64160: LD_VAR 0 3
64164: PPUSH
64165: LD_EXP 150
64169: PUSH
64170: LD_VAR 0 3
64174: ARRAY
64175: PPUSH
64176: LD_INT 1
64178: PPUSH
64179: LD_EXP 150
64183: PUSH
64184: LD_VAR 0 3
64188: ARRAY
64189: PPUSH
64190: LD_INT 0
64192: PPUSH
64193: CALL 70026 0 4
64197: PPUSH
64198: CALL_OW 1
64202: ST_TO_ADDR
// if not building in mc_bases [ i ] then
64203: LD_VAR 0 1
64207: PUSH
64208: LD_EXP 116
64212: PUSH
64213: LD_VAR 0 3
64217: ARRAY
64218: IN
64219: NOT
64220: IFFALSE 64266
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64222: LD_ADDR_EXP 116
64226: PUSH
64227: LD_EXP 116
64231: PPUSH
64232: LD_VAR 0 3
64236: PUSH
64237: LD_EXP 116
64241: PUSH
64242: LD_VAR 0 3
64246: ARRAY
64247: PUSH
64248: LD_INT 1
64250: PLUS
64251: PUSH
64252: EMPTY
64253: LIST
64254: LIST
64255: PPUSH
64256: LD_VAR 0 1
64260: PPUSH
64261: CALL 70608 0 3
64265: ST_TO_ADDR
// exit ;
64266: POP
64267: POP
64268: GO 64274
// end ; end ;
64270: GO 64074
64272: POP
64273: POP
// end ;
64274: LD_VAR 0 2
64278: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
64279: LD_INT 0
64281: PPUSH
64282: PPUSH
64283: PPUSH
64284: PPUSH
64285: PPUSH
64286: PPUSH
64287: PPUSH
// if not mc_bases or not skirmish then
64288: LD_EXP 116
64292: NOT
64293: PUSH
64294: LD_EXP 114
64298: NOT
64299: OR
64300: IFFALSE 64304
// exit ;
64302: GO 64965
// for i = 1 to mc_bases do
64304: LD_ADDR_VAR 0 3
64308: PUSH
64309: DOUBLE
64310: LD_INT 1
64312: DEC
64313: ST_TO_ADDR
64314: LD_EXP 116
64318: PUSH
64319: FOR_TO
64320: IFFALSE 64963
// begin if building in mc_construct_list [ i ] then
64322: LD_VAR 0 1
64326: PUSH
64327: LD_EXP 123
64331: PUSH
64332: LD_VAR 0 3
64336: ARRAY
64337: IN
64338: IFFALSE 64961
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
64340: LD_ADDR_EXP 123
64344: PUSH
64345: LD_EXP 123
64349: PPUSH
64350: LD_VAR 0 3
64354: PPUSH
64355: LD_EXP 123
64359: PUSH
64360: LD_VAR 0 3
64364: ARRAY
64365: PUSH
64366: LD_VAR 0 1
64370: DIFF
64371: PPUSH
64372: CALL_OW 1
64376: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64377: LD_ADDR_EXP 116
64381: PUSH
64382: LD_EXP 116
64386: PPUSH
64387: LD_VAR 0 3
64391: PUSH
64392: LD_EXP 116
64396: PUSH
64397: LD_VAR 0 3
64401: ARRAY
64402: PUSH
64403: LD_INT 1
64405: PLUS
64406: PUSH
64407: EMPTY
64408: LIST
64409: LIST
64410: PPUSH
64411: LD_VAR 0 1
64415: PPUSH
64416: CALL 70608 0 3
64420: ST_TO_ADDR
// btype := GetBType ( building ) ;
64421: LD_ADDR_VAR 0 5
64425: PUSH
64426: LD_VAR 0 1
64430: PPUSH
64431: CALL_OW 266
64435: ST_TO_ADDR
// side := GetSide ( building ) ;
64436: LD_ADDR_VAR 0 8
64440: PUSH
64441: LD_VAR 0 1
64445: PPUSH
64446: CALL_OW 255
64450: ST_TO_ADDR
// if btype = b_lab then
64451: LD_VAR 0 5
64455: PUSH
64456: LD_INT 6
64458: EQUAL
64459: IFFALSE 64509
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
64461: LD_ADDR_EXP 149
64465: PUSH
64466: LD_EXP 149
64470: PPUSH
64471: LD_VAR 0 3
64475: PUSH
64476: LD_EXP 149
64480: PUSH
64481: LD_VAR 0 3
64485: ARRAY
64486: PUSH
64487: LD_INT 1
64489: PLUS
64490: PUSH
64491: EMPTY
64492: LIST
64493: LIST
64494: PPUSH
64495: LD_VAR 0 1
64499: PPUSH
64500: CALL 70608 0 3
64504: ST_TO_ADDR
// exit ;
64505: POP
64506: POP
64507: GO 64965
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
64509: LD_VAR 0 5
64513: PUSH
64514: LD_INT 0
64516: PUSH
64517: LD_INT 2
64519: PUSH
64520: LD_INT 4
64522: PUSH
64523: EMPTY
64524: LIST
64525: LIST
64526: LIST
64527: IN
64528: IFFALSE 64652
// begin if btype = b_armoury then
64530: LD_VAR 0 5
64534: PUSH
64535: LD_INT 4
64537: EQUAL
64538: IFFALSE 64548
// btype := b_barracks ;
64540: LD_ADDR_VAR 0 5
64544: PUSH
64545: LD_INT 5
64547: ST_TO_ADDR
// if btype = b_depot then
64548: LD_VAR 0 5
64552: PUSH
64553: LD_INT 0
64555: EQUAL
64556: IFFALSE 64566
// btype := b_warehouse ;
64558: LD_ADDR_VAR 0 5
64562: PUSH
64563: LD_INT 1
64565: ST_TO_ADDR
// if btype = b_workshop then
64566: LD_VAR 0 5
64570: PUSH
64571: LD_INT 2
64573: EQUAL
64574: IFFALSE 64584
// btype := b_factory ;
64576: LD_ADDR_VAR 0 5
64580: PUSH
64581: LD_INT 3
64583: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
64584: LD_VAR 0 5
64588: PPUSH
64589: LD_VAR 0 8
64593: PPUSH
64594: CALL_OW 323
64598: PUSH
64599: LD_INT 1
64601: EQUAL
64602: IFFALSE 64648
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
64604: LD_ADDR_EXP 148
64608: PUSH
64609: LD_EXP 148
64613: PPUSH
64614: LD_VAR 0 3
64618: PUSH
64619: LD_EXP 148
64623: PUSH
64624: LD_VAR 0 3
64628: ARRAY
64629: PUSH
64630: LD_INT 1
64632: PLUS
64633: PUSH
64634: EMPTY
64635: LIST
64636: LIST
64637: PPUSH
64638: LD_VAR 0 1
64642: PPUSH
64643: CALL 70608 0 3
64647: ST_TO_ADDR
// exit ;
64648: POP
64649: POP
64650: GO 64965
// end ; if btype in [ b_bunker , b_turret ] then
64652: LD_VAR 0 5
64656: PUSH
64657: LD_INT 32
64659: PUSH
64660: LD_INT 33
64662: PUSH
64663: EMPTY
64664: LIST
64665: LIST
64666: IN
64667: IFFALSE 64957
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
64669: LD_ADDR_EXP 124
64673: PUSH
64674: LD_EXP 124
64678: PPUSH
64679: LD_VAR 0 3
64683: PUSH
64684: LD_EXP 124
64688: PUSH
64689: LD_VAR 0 3
64693: ARRAY
64694: PUSH
64695: LD_INT 1
64697: PLUS
64698: PUSH
64699: EMPTY
64700: LIST
64701: LIST
64702: PPUSH
64703: LD_VAR 0 1
64707: PPUSH
64708: CALL 70608 0 3
64712: ST_TO_ADDR
// if btype = b_bunker then
64713: LD_VAR 0 5
64717: PUSH
64718: LD_INT 32
64720: EQUAL
64721: IFFALSE 64957
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64723: LD_ADDR_EXP 125
64727: PUSH
64728: LD_EXP 125
64732: PPUSH
64733: LD_VAR 0 3
64737: PUSH
64738: LD_EXP 125
64742: PUSH
64743: LD_VAR 0 3
64747: ARRAY
64748: PUSH
64749: LD_INT 1
64751: PLUS
64752: PUSH
64753: EMPTY
64754: LIST
64755: LIST
64756: PPUSH
64757: LD_VAR 0 1
64761: PPUSH
64762: CALL 70608 0 3
64766: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
64767: LD_ADDR_VAR 0 6
64771: PUSH
64772: LD_EXP 116
64776: PUSH
64777: LD_VAR 0 3
64781: ARRAY
64782: PPUSH
64783: LD_INT 25
64785: PUSH
64786: LD_INT 1
64788: PUSH
64789: EMPTY
64790: LIST
64791: LIST
64792: PUSH
64793: LD_INT 3
64795: PUSH
64796: LD_INT 54
64798: PUSH
64799: EMPTY
64800: LIST
64801: PUSH
64802: EMPTY
64803: LIST
64804: LIST
64805: PUSH
64806: EMPTY
64807: LIST
64808: LIST
64809: PPUSH
64810: CALL_OW 72
64814: ST_TO_ADDR
// if tmp then
64815: LD_VAR 0 6
64819: IFFALSE 64825
// exit ;
64821: POP
64822: POP
64823: GO 64965
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64825: LD_ADDR_VAR 0 6
64829: PUSH
64830: LD_EXP 116
64834: PUSH
64835: LD_VAR 0 3
64839: ARRAY
64840: PPUSH
64841: LD_INT 2
64843: PUSH
64844: LD_INT 30
64846: PUSH
64847: LD_INT 4
64849: PUSH
64850: EMPTY
64851: LIST
64852: LIST
64853: PUSH
64854: LD_INT 30
64856: PUSH
64857: LD_INT 5
64859: PUSH
64860: EMPTY
64861: LIST
64862: LIST
64863: PUSH
64864: EMPTY
64865: LIST
64866: LIST
64867: LIST
64868: PPUSH
64869: CALL_OW 72
64873: ST_TO_ADDR
// if not tmp then
64874: LD_VAR 0 6
64878: NOT
64879: IFFALSE 64885
// exit ;
64881: POP
64882: POP
64883: GO 64965
// for j in tmp do
64885: LD_ADDR_VAR 0 4
64889: PUSH
64890: LD_VAR 0 6
64894: PUSH
64895: FOR_IN
64896: IFFALSE 64955
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
64898: LD_ADDR_VAR 0 7
64902: PUSH
64903: LD_VAR 0 4
64907: PPUSH
64908: CALL_OW 313
64912: PPUSH
64913: LD_INT 25
64915: PUSH
64916: LD_INT 1
64918: PUSH
64919: EMPTY
64920: LIST
64921: LIST
64922: PPUSH
64923: CALL_OW 72
64927: ST_TO_ADDR
// if units then
64928: LD_VAR 0 7
64932: IFFALSE 64953
// begin ComExitBuilding ( units [ 1 ] ) ;
64934: LD_VAR 0 7
64938: PUSH
64939: LD_INT 1
64941: ARRAY
64942: PPUSH
64943: CALL_OW 122
// exit ;
64947: POP
64948: POP
64949: POP
64950: POP
64951: GO 64965
// end ; end ;
64953: GO 64895
64955: POP
64956: POP
// end ; end ; exit ;
64957: POP
64958: POP
64959: GO 64965
// end ; end ;
64961: GO 64319
64963: POP
64964: POP
// end ;
64965: LD_VAR 0 2
64969: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
64970: LD_INT 0
64972: PPUSH
64973: PPUSH
64974: PPUSH
64975: PPUSH
64976: PPUSH
64977: PPUSH
64978: PPUSH
// if not mc_bases or not skirmish then
64979: LD_EXP 116
64983: NOT
64984: PUSH
64985: LD_EXP 114
64989: NOT
64990: OR
64991: IFFALSE 64995
// exit ;
64993: GO 65260
// btype := GetBType ( building ) ;
64995: LD_ADDR_VAR 0 6
64999: PUSH
65000: LD_VAR 0 1
65004: PPUSH
65005: CALL_OW 266
65009: ST_TO_ADDR
// x := GetX ( building ) ;
65010: LD_ADDR_VAR 0 7
65014: PUSH
65015: LD_VAR 0 1
65019: PPUSH
65020: CALL_OW 250
65024: ST_TO_ADDR
// y := GetY ( building ) ;
65025: LD_ADDR_VAR 0 8
65029: PUSH
65030: LD_VAR 0 1
65034: PPUSH
65035: CALL_OW 251
65039: ST_TO_ADDR
// d := GetDir ( building ) ;
65040: LD_ADDR_VAR 0 9
65044: PUSH
65045: LD_VAR 0 1
65049: PPUSH
65050: CALL_OW 254
65054: ST_TO_ADDR
// for i = 1 to mc_bases do
65055: LD_ADDR_VAR 0 4
65059: PUSH
65060: DOUBLE
65061: LD_INT 1
65063: DEC
65064: ST_TO_ADDR
65065: LD_EXP 116
65069: PUSH
65070: FOR_TO
65071: IFFALSE 65258
// begin if not mc_build_list [ i ] then
65073: LD_EXP 121
65077: PUSH
65078: LD_VAR 0 4
65082: ARRAY
65083: NOT
65084: IFFALSE 65088
// continue ;
65086: GO 65070
// for j := 1 to mc_build_list [ i ] do
65088: LD_ADDR_VAR 0 5
65092: PUSH
65093: DOUBLE
65094: LD_INT 1
65096: DEC
65097: ST_TO_ADDR
65098: LD_EXP 121
65102: PUSH
65103: LD_VAR 0 4
65107: ARRAY
65108: PUSH
65109: FOR_TO
65110: IFFALSE 65254
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
65112: LD_VAR 0 6
65116: PUSH
65117: LD_VAR 0 7
65121: PUSH
65122: LD_VAR 0 8
65126: PUSH
65127: LD_VAR 0 9
65131: PUSH
65132: EMPTY
65133: LIST
65134: LIST
65135: LIST
65136: LIST
65137: PPUSH
65138: LD_EXP 121
65142: PUSH
65143: LD_VAR 0 4
65147: ARRAY
65148: PUSH
65149: LD_VAR 0 5
65153: ARRAY
65154: PPUSH
65155: CALL 76790 0 2
65159: IFFALSE 65252
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
65161: LD_ADDR_EXP 121
65165: PUSH
65166: LD_EXP 121
65170: PPUSH
65171: LD_VAR 0 4
65175: PPUSH
65176: LD_EXP 121
65180: PUSH
65181: LD_VAR 0 4
65185: ARRAY
65186: PPUSH
65187: LD_VAR 0 5
65191: PPUSH
65192: CALL_OW 3
65196: PPUSH
65197: CALL_OW 1
65201: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
65202: LD_ADDR_EXP 123
65206: PUSH
65207: LD_EXP 123
65211: PPUSH
65212: LD_VAR 0 4
65216: PUSH
65217: LD_EXP 123
65221: PUSH
65222: LD_VAR 0 4
65226: ARRAY
65227: PUSH
65228: LD_INT 1
65230: PLUS
65231: PUSH
65232: EMPTY
65233: LIST
65234: LIST
65235: PPUSH
65236: LD_VAR 0 1
65240: PPUSH
65241: CALL 70608 0 3
65245: ST_TO_ADDR
// exit ;
65246: POP
65247: POP
65248: POP
65249: POP
65250: GO 65260
// end ;
65252: GO 65109
65254: POP
65255: POP
// end ;
65256: GO 65070
65258: POP
65259: POP
// end ;
65260: LD_VAR 0 3
65264: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
65265: LD_INT 0
65267: PPUSH
65268: PPUSH
65269: PPUSH
// if not mc_bases or not skirmish then
65270: LD_EXP 116
65274: NOT
65275: PUSH
65276: LD_EXP 114
65280: NOT
65281: OR
65282: IFFALSE 65286
// exit ;
65284: GO 65476
// for i = 1 to mc_bases do
65286: LD_ADDR_VAR 0 4
65290: PUSH
65291: DOUBLE
65292: LD_INT 1
65294: DEC
65295: ST_TO_ADDR
65296: LD_EXP 116
65300: PUSH
65301: FOR_TO
65302: IFFALSE 65389
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
65304: LD_VAR 0 1
65308: PUSH
65309: LD_EXP 124
65313: PUSH
65314: LD_VAR 0 4
65318: ARRAY
65319: IN
65320: PUSH
65321: LD_VAR 0 1
65325: PUSH
65326: LD_EXP 125
65330: PUSH
65331: LD_VAR 0 4
65335: ARRAY
65336: IN
65337: NOT
65338: AND
65339: IFFALSE 65387
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
65341: LD_ADDR_EXP 125
65345: PUSH
65346: LD_EXP 125
65350: PPUSH
65351: LD_VAR 0 4
65355: PUSH
65356: LD_EXP 125
65360: PUSH
65361: LD_VAR 0 4
65365: ARRAY
65366: PUSH
65367: LD_INT 1
65369: PLUS
65370: PUSH
65371: EMPTY
65372: LIST
65373: LIST
65374: PPUSH
65375: LD_VAR 0 1
65379: PPUSH
65380: CALL 70608 0 3
65384: ST_TO_ADDR
// break ;
65385: GO 65389
// end ; end ;
65387: GO 65301
65389: POP
65390: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
65391: LD_VAR 0 1
65395: PPUSH
65396: CALL_OW 257
65400: PUSH
65401: LD_EXP 142
65405: IN
65406: PUSH
65407: LD_VAR 0 1
65411: PPUSH
65412: CALL_OW 266
65416: PUSH
65417: LD_INT 5
65419: EQUAL
65420: AND
65421: PUSH
65422: LD_VAR 0 2
65426: PPUSH
65427: CALL_OW 110
65431: PUSH
65432: LD_INT 18
65434: NONEQUAL
65435: AND
65436: IFFALSE 65476
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
65438: LD_VAR 0 2
65442: PPUSH
65443: CALL_OW 257
65447: PUSH
65448: LD_INT 5
65450: PUSH
65451: LD_INT 8
65453: PUSH
65454: LD_INT 9
65456: PUSH
65457: EMPTY
65458: LIST
65459: LIST
65460: LIST
65461: IN
65462: IFFALSE 65476
// SetClass ( unit , 1 ) ;
65464: LD_VAR 0 2
65468: PPUSH
65469: LD_INT 1
65471: PPUSH
65472: CALL_OW 336
// end ;
65476: LD_VAR 0 3
65480: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
65481: LD_INT 0
65483: PPUSH
65484: PPUSH
// if not mc_bases or not skirmish then
65485: LD_EXP 116
65489: NOT
65490: PUSH
65491: LD_EXP 114
65495: NOT
65496: OR
65497: IFFALSE 65501
// exit ;
65499: GO 65617
// if GetLives ( abandoned_vehicle ) > 250 then
65501: LD_VAR 0 2
65505: PPUSH
65506: CALL_OW 256
65510: PUSH
65511: LD_INT 250
65513: GREATER
65514: IFFALSE 65518
// exit ;
65516: GO 65617
// for i = 1 to mc_bases do
65518: LD_ADDR_VAR 0 6
65522: PUSH
65523: DOUBLE
65524: LD_INT 1
65526: DEC
65527: ST_TO_ADDR
65528: LD_EXP 116
65532: PUSH
65533: FOR_TO
65534: IFFALSE 65615
// begin if driver in mc_bases [ i ] then
65536: LD_VAR 0 1
65540: PUSH
65541: LD_EXP 116
65545: PUSH
65546: LD_VAR 0 6
65550: ARRAY
65551: IN
65552: IFFALSE 65613
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
65554: LD_VAR 0 1
65558: PPUSH
65559: LD_EXP 116
65563: PUSH
65564: LD_VAR 0 6
65568: ARRAY
65569: PPUSH
65570: LD_INT 2
65572: PUSH
65573: LD_INT 30
65575: PUSH
65576: LD_INT 0
65578: PUSH
65579: EMPTY
65580: LIST
65581: LIST
65582: PUSH
65583: LD_INT 30
65585: PUSH
65586: LD_INT 1
65588: PUSH
65589: EMPTY
65590: LIST
65591: LIST
65592: PUSH
65593: EMPTY
65594: LIST
65595: LIST
65596: LIST
65597: PPUSH
65598: CALL_OW 72
65602: PUSH
65603: LD_INT 1
65605: ARRAY
65606: PPUSH
65607: CALL 103226 0 2
// break ;
65611: GO 65615
// end ; end ;
65613: GO 65533
65615: POP
65616: POP
// end ; end_of_file
65617: LD_VAR 0 5
65621: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
65622: LD_INT 0
65624: PPUSH
65625: PPUSH
// if exist_mode then
65626: LD_VAR 0 2
65630: IFFALSE 65655
// unit := CreateCharacter ( prefix & ident ) else
65632: LD_ADDR_VAR 0 5
65636: PUSH
65637: LD_VAR 0 3
65641: PUSH
65642: LD_VAR 0 1
65646: STR
65647: PPUSH
65648: CALL_OW 34
65652: ST_TO_ADDR
65653: GO 65670
// unit := NewCharacter ( ident ) ;
65655: LD_ADDR_VAR 0 5
65659: PUSH
65660: LD_VAR 0 1
65664: PPUSH
65665: CALL_OW 25
65669: ST_TO_ADDR
// result := unit ;
65670: LD_ADDR_VAR 0 4
65674: PUSH
65675: LD_VAR 0 5
65679: ST_TO_ADDR
// end ;
65680: LD_VAR 0 4
65684: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
65685: LD_INT 0
65687: PPUSH
65688: PPUSH
// if not side or not nation then
65689: LD_VAR 0 1
65693: NOT
65694: PUSH
65695: LD_VAR 0 2
65699: NOT
65700: OR
65701: IFFALSE 65705
// exit ;
65703: GO 66473
// case nation of nation_american :
65705: LD_VAR 0 2
65709: PUSH
65710: LD_INT 1
65712: DOUBLE
65713: EQUAL
65714: IFTRUE 65718
65716: GO 65932
65718: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
65719: LD_ADDR_VAR 0 4
65723: PUSH
65724: LD_INT 35
65726: PUSH
65727: LD_INT 45
65729: PUSH
65730: LD_INT 46
65732: PUSH
65733: LD_INT 47
65735: PUSH
65736: LD_INT 82
65738: PUSH
65739: LD_INT 83
65741: PUSH
65742: LD_INT 84
65744: PUSH
65745: LD_INT 85
65747: PUSH
65748: LD_INT 86
65750: PUSH
65751: LD_INT 1
65753: PUSH
65754: LD_INT 2
65756: PUSH
65757: LD_INT 6
65759: PUSH
65760: LD_INT 15
65762: PUSH
65763: LD_INT 16
65765: PUSH
65766: LD_INT 7
65768: PUSH
65769: LD_INT 12
65771: PUSH
65772: LD_INT 13
65774: PUSH
65775: LD_INT 10
65777: PUSH
65778: LD_INT 14
65780: PUSH
65781: LD_INT 20
65783: PUSH
65784: LD_INT 21
65786: PUSH
65787: LD_INT 22
65789: PUSH
65790: LD_INT 25
65792: PUSH
65793: LD_INT 32
65795: PUSH
65796: LD_INT 27
65798: PUSH
65799: LD_INT 36
65801: PUSH
65802: LD_INT 69
65804: PUSH
65805: LD_INT 39
65807: PUSH
65808: LD_INT 34
65810: PUSH
65811: LD_INT 40
65813: PUSH
65814: LD_INT 48
65816: PUSH
65817: LD_INT 49
65819: PUSH
65820: LD_INT 50
65822: PUSH
65823: LD_INT 51
65825: PUSH
65826: LD_INT 52
65828: PUSH
65829: LD_INT 53
65831: PUSH
65832: LD_INT 54
65834: PUSH
65835: LD_INT 55
65837: PUSH
65838: LD_INT 56
65840: PUSH
65841: LD_INT 57
65843: PUSH
65844: LD_INT 58
65846: PUSH
65847: LD_INT 59
65849: PUSH
65850: LD_INT 60
65852: PUSH
65853: LD_INT 61
65855: PUSH
65856: LD_INT 62
65858: PUSH
65859: LD_INT 80
65861: PUSH
65862: LD_INT 82
65864: PUSH
65865: LD_INT 83
65867: PUSH
65868: LD_INT 84
65870: PUSH
65871: LD_INT 85
65873: PUSH
65874: LD_INT 86
65876: PUSH
65877: EMPTY
65878: LIST
65879: LIST
65880: LIST
65881: LIST
65882: LIST
65883: LIST
65884: LIST
65885: LIST
65886: LIST
65887: LIST
65888: LIST
65889: LIST
65890: LIST
65891: LIST
65892: LIST
65893: LIST
65894: LIST
65895: LIST
65896: LIST
65897: LIST
65898: LIST
65899: LIST
65900: LIST
65901: LIST
65902: LIST
65903: LIST
65904: LIST
65905: LIST
65906: LIST
65907: LIST
65908: LIST
65909: LIST
65910: LIST
65911: LIST
65912: LIST
65913: LIST
65914: LIST
65915: LIST
65916: LIST
65917: LIST
65918: LIST
65919: LIST
65920: LIST
65921: LIST
65922: LIST
65923: LIST
65924: LIST
65925: LIST
65926: LIST
65927: LIST
65928: LIST
65929: ST_TO_ADDR
65930: GO 66397
65932: LD_INT 2
65934: DOUBLE
65935: EQUAL
65936: IFTRUE 65940
65938: GO 66166
65940: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
65941: LD_ADDR_VAR 0 4
65945: PUSH
65946: LD_INT 35
65948: PUSH
65949: LD_INT 45
65951: PUSH
65952: LD_INT 46
65954: PUSH
65955: LD_INT 47
65957: PUSH
65958: LD_INT 82
65960: PUSH
65961: LD_INT 83
65963: PUSH
65964: LD_INT 84
65966: PUSH
65967: LD_INT 85
65969: PUSH
65970: LD_INT 87
65972: PUSH
65973: LD_INT 70
65975: PUSH
65976: LD_INT 1
65978: PUSH
65979: LD_INT 11
65981: PUSH
65982: LD_INT 3
65984: PUSH
65985: LD_INT 4
65987: PUSH
65988: LD_INT 5
65990: PUSH
65991: LD_INT 6
65993: PUSH
65994: LD_INT 15
65996: PUSH
65997: LD_INT 18
65999: PUSH
66000: LD_INT 7
66002: PUSH
66003: LD_INT 17
66005: PUSH
66006: LD_INT 8
66008: PUSH
66009: LD_INT 20
66011: PUSH
66012: LD_INT 21
66014: PUSH
66015: LD_INT 22
66017: PUSH
66018: LD_INT 72
66020: PUSH
66021: LD_INT 26
66023: PUSH
66024: LD_INT 69
66026: PUSH
66027: LD_INT 39
66029: PUSH
66030: LD_INT 40
66032: PUSH
66033: LD_INT 41
66035: PUSH
66036: LD_INT 42
66038: PUSH
66039: LD_INT 43
66041: PUSH
66042: LD_INT 48
66044: PUSH
66045: LD_INT 49
66047: PUSH
66048: LD_INT 50
66050: PUSH
66051: LD_INT 51
66053: PUSH
66054: LD_INT 52
66056: PUSH
66057: LD_INT 53
66059: PUSH
66060: LD_INT 54
66062: PUSH
66063: LD_INT 55
66065: PUSH
66066: LD_INT 56
66068: PUSH
66069: LD_INT 60
66071: PUSH
66072: LD_INT 61
66074: PUSH
66075: LD_INT 62
66077: PUSH
66078: LD_INT 66
66080: PUSH
66081: LD_INT 67
66083: PUSH
66084: LD_INT 68
66086: PUSH
66087: LD_INT 81
66089: PUSH
66090: LD_INT 82
66092: PUSH
66093: LD_INT 83
66095: PUSH
66096: LD_INT 84
66098: PUSH
66099: LD_INT 85
66101: PUSH
66102: LD_INT 87
66104: PUSH
66105: LD_INT 88
66107: PUSH
66108: EMPTY
66109: LIST
66110: LIST
66111: LIST
66112: LIST
66113: LIST
66114: LIST
66115: LIST
66116: LIST
66117: LIST
66118: LIST
66119: LIST
66120: LIST
66121: LIST
66122: LIST
66123: LIST
66124: LIST
66125: LIST
66126: LIST
66127: LIST
66128: LIST
66129: LIST
66130: LIST
66131: LIST
66132: LIST
66133: LIST
66134: LIST
66135: LIST
66136: LIST
66137: LIST
66138: LIST
66139: LIST
66140: LIST
66141: LIST
66142: LIST
66143: LIST
66144: LIST
66145: LIST
66146: LIST
66147: LIST
66148: LIST
66149: LIST
66150: LIST
66151: LIST
66152: LIST
66153: LIST
66154: LIST
66155: LIST
66156: LIST
66157: LIST
66158: LIST
66159: LIST
66160: LIST
66161: LIST
66162: LIST
66163: ST_TO_ADDR
66164: GO 66397
66166: LD_INT 3
66168: DOUBLE
66169: EQUAL
66170: IFTRUE 66174
66172: GO 66396
66174: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
66175: LD_ADDR_VAR 0 4
66179: PUSH
66180: LD_INT 46
66182: PUSH
66183: LD_INT 47
66185: PUSH
66186: LD_INT 1
66188: PUSH
66189: LD_INT 2
66191: PUSH
66192: LD_INT 82
66194: PUSH
66195: LD_INT 83
66197: PUSH
66198: LD_INT 84
66200: PUSH
66201: LD_INT 85
66203: PUSH
66204: LD_INT 86
66206: PUSH
66207: LD_INT 11
66209: PUSH
66210: LD_INT 9
66212: PUSH
66213: LD_INT 20
66215: PUSH
66216: LD_INT 19
66218: PUSH
66219: LD_INT 21
66221: PUSH
66222: LD_INT 24
66224: PUSH
66225: LD_INT 22
66227: PUSH
66228: LD_INT 25
66230: PUSH
66231: LD_INT 28
66233: PUSH
66234: LD_INT 29
66236: PUSH
66237: LD_INT 30
66239: PUSH
66240: LD_INT 31
66242: PUSH
66243: LD_INT 37
66245: PUSH
66246: LD_INT 38
66248: PUSH
66249: LD_INT 32
66251: PUSH
66252: LD_INT 27
66254: PUSH
66255: LD_INT 33
66257: PUSH
66258: LD_INT 69
66260: PUSH
66261: LD_INT 39
66263: PUSH
66264: LD_INT 34
66266: PUSH
66267: LD_INT 40
66269: PUSH
66270: LD_INT 71
66272: PUSH
66273: LD_INT 23
66275: PUSH
66276: LD_INT 44
66278: PUSH
66279: LD_INT 48
66281: PUSH
66282: LD_INT 49
66284: PUSH
66285: LD_INT 50
66287: PUSH
66288: LD_INT 51
66290: PUSH
66291: LD_INT 52
66293: PUSH
66294: LD_INT 53
66296: PUSH
66297: LD_INT 54
66299: PUSH
66300: LD_INT 55
66302: PUSH
66303: LD_INT 56
66305: PUSH
66306: LD_INT 57
66308: PUSH
66309: LD_INT 58
66311: PUSH
66312: LD_INT 59
66314: PUSH
66315: LD_INT 63
66317: PUSH
66318: LD_INT 64
66320: PUSH
66321: LD_INT 65
66323: PUSH
66324: LD_INT 82
66326: PUSH
66327: LD_INT 83
66329: PUSH
66330: LD_INT 84
66332: PUSH
66333: LD_INT 85
66335: PUSH
66336: LD_INT 86
66338: PUSH
66339: EMPTY
66340: LIST
66341: LIST
66342: LIST
66343: LIST
66344: LIST
66345: LIST
66346: LIST
66347: LIST
66348: LIST
66349: LIST
66350: LIST
66351: LIST
66352: LIST
66353: LIST
66354: LIST
66355: LIST
66356: LIST
66357: LIST
66358: LIST
66359: LIST
66360: LIST
66361: LIST
66362: LIST
66363: LIST
66364: LIST
66365: LIST
66366: LIST
66367: LIST
66368: LIST
66369: LIST
66370: LIST
66371: LIST
66372: LIST
66373: LIST
66374: LIST
66375: LIST
66376: LIST
66377: LIST
66378: LIST
66379: LIST
66380: LIST
66381: LIST
66382: LIST
66383: LIST
66384: LIST
66385: LIST
66386: LIST
66387: LIST
66388: LIST
66389: LIST
66390: LIST
66391: LIST
66392: LIST
66393: ST_TO_ADDR
66394: GO 66397
66396: POP
// if state > - 1 and state < 3 then
66397: LD_VAR 0 3
66401: PUSH
66402: LD_INT 1
66404: NEG
66405: GREATER
66406: PUSH
66407: LD_VAR 0 3
66411: PUSH
66412: LD_INT 3
66414: LESS
66415: AND
66416: IFFALSE 66473
// for i in result do
66418: LD_ADDR_VAR 0 5
66422: PUSH
66423: LD_VAR 0 4
66427: PUSH
66428: FOR_IN
66429: IFFALSE 66471
// if GetTech ( i , side ) <> state then
66431: LD_VAR 0 5
66435: PPUSH
66436: LD_VAR 0 1
66440: PPUSH
66441: CALL_OW 321
66445: PUSH
66446: LD_VAR 0 3
66450: NONEQUAL
66451: IFFALSE 66469
// result := result diff i ;
66453: LD_ADDR_VAR 0 4
66457: PUSH
66458: LD_VAR 0 4
66462: PUSH
66463: LD_VAR 0 5
66467: DIFF
66468: ST_TO_ADDR
66469: GO 66428
66471: POP
66472: POP
// end ;
66473: LD_VAR 0 4
66477: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
66478: LD_INT 0
66480: PPUSH
66481: PPUSH
66482: PPUSH
// result := true ;
66483: LD_ADDR_VAR 0 3
66487: PUSH
66488: LD_INT 1
66490: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
66491: LD_ADDR_VAR 0 5
66495: PUSH
66496: LD_VAR 0 2
66500: PPUSH
66501: CALL_OW 480
66505: ST_TO_ADDR
// if not tmp then
66506: LD_VAR 0 5
66510: NOT
66511: IFFALSE 66515
// exit ;
66513: GO 66564
// for i in tmp do
66515: LD_ADDR_VAR 0 4
66519: PUSH
66520: LD_VAR 0 5
66524: PUSH
66525: FOR_IN
66526: IFFALSE 66562
// if GetTech ( i , side ) <> state_researched then
66528: LD_VAR 0 4
66532: PPUSH
66533: LD_VAR 0 1
66537: PPUSH
66538: CALL_OW 321
66542: PUSH
66543: LD_INT 2
66545: NONEQUAL
66546: IFFALSE 66560
// begin result := false ;
66548: LD_ADDR_VAR 0 3
66552: PUSH
66553: LD_INT 0
66555: ST_TO_ADDR
// exit ;
66556: POP
66557: POP
66558: GO 66564
// end ;
66560: GO 66525
66562: POP
66563: POP
// end ;
66564: LD_VAR 0 3
66568: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
66569: LD_INT 0
66571: PPUSH
66572: PPUSH
66573: PPUSH
66574: PPUSH
66575: PPUSH
66576: PPUSH
66577: PPUSH
66578: PPUSH
66579: PPUSH
66580: PPUSH
66581: PPUSH
66582: PPUSH
66583: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
66584: LD_VAR 0 1
66588: NOT
66589: PUSH
66590: LD_VAR 0 1
66594: PPUSH
66595: CALL_OW 257
66599: PUSH
66600: LD_INT 9
66602: NONEQUAL
66603: OR
66604: IFFALSE 66608
// exit ;
66606: GO 67181
// side := GetSide ( unit ) ;
66608: LD_ADDR_VAR 0 9
66612: PUSH
66613: LD_VAR 0 1
66617: PPUSH
66618: CALL_OW 255
66622: ST_TO_ADDR
// tech_space := tech_spacanom ;
66623: LD_ADDR_VAR 0 12
66627: PUSH
66628: LD_INT 29
66630: ST_TO_ADDR
// tech_time := tech_taurad ;
66631: LD_ADDR_VAR 0 13
66635: PUSH
66636: LD_INT 28
66638: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
66639: LD_ADDR_VAR 0 11
66643: PUSH
66644: LD_VAR 0 1
66648: PPUSH
66649: CALL_OW 310
66653: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
66654: LD_VAR 0 11
66658: PPUSH
66659: CALL_OW 247
66663: PUSH
66664: LD_INT 2
66666: EQUAL
66667: IFFALSE 66671
// exit ;
66669: GO 67181
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66671: LD_ADDR_VAR 0 8
66675: PUSH
66676: LD_INT 81
66678: PUSH
66679: LD_VAR 0 9
66683: PUSH
66684: EMPTY
66685: LIST
66686: LIST
66687: PUSH
66688: LD_INT 3
66690: PUSH
66691: LD_INT 21
66693: PUSH
66694: LD_INT 3
66696: PUSH
66697: EMPTY
66698: LIST
66699: LIST
66700: PUSH
66701: EMPTY
66702: LIST
66703: LIST
66704: PUSH
66705: EMPTY
66706: LIST
66707: LIST
66708: PPUSH
66709: CALL_OW 69
66713: ST_TO_ADDR
// if not tmp then
66714: LD_VAR 0 8
66718: NOT
66719: IFFALSE 66723
// exit ;
66721: GO 67181
// if in_unit then
66723: LD_VAR 0 11
66727: IFFALSE 66751
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
66729: LD_ADDR_VAR 0 10
66733: PUSH
66734: LD_VAR 0 8
66738: PPUSH
66739: LD_VAR 0 11
66743: PPUSH
66744: CALL_OW 74
66748: ST_TO_ADDR
66749: GO 66771
// enemy := NearestUnitToUnit ( tmp , unit ) ;
66751: LD_ADDR_VAR 0 10
66755: PUSH
66756: LD_VAR 0 8
66760: PPUSH
66761: LD_VAR 0 1
66765: PPUSH
66766: CALL_OW 74
66770: ST_TO_ADDR
// if not enemy then
66771: LD_VAR 0 10
66775: NOT
66776: IFFALSE 66780
// exit ;
66778: GO 67181
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
66780: LD_VAR 0 11
66784: PUSH
66785: LD_VAR 0 11
66789: PPUSH
66790: LD_VAR 0 10
66794: PPUSH
66795: CALL_OW 296
66799: PUSH
66800: LD_INT 13
66802: GREATER
66803: AND
66804: PUSH
66805: LD_VAR 0 1
66809: PPUSH
66810: LD_VAR 0 10
66814: PPUSH
66815: CALL_OW 296
66819: PUSH
66820: LD_INT 12
66822: GREATER
66823: OR
66824: IFFALSE 66828
// exit ;
66826: GO 67181
// missile := [ 1 ] ;
66828: LD_ADDR_VAR 0 14
66832: PUSH
66833: LD_INT 1
66835: PUSH
66836: EMPTY
66837: LIST
66838: ST_TO_ADDR
// if Researched ( side , tech_space ) then
66839: LD_VAR 0 9
66843: PPUSH
66844: LD_VAR 0 12
66848: PPUSH
66849: CALL_OW 325
66853: IFFALSE 66882
// missile := Insert ( missile , missile + 1 , 2 ) ;
66855: LD_ADDR_VAR 0 14
66859: PUSH
66860: LD_VAR 0 14
66864: PPUSH
66865: LD_VAR 0 14
66869: PUSH
66870: LD_INT 1
66872: PLUS
66873: PPUSH
66874: LD_INT 2
66876: PPUSH
66877: CALL_OW 2
66881: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
66882: LD_VAR 0 9
66886: PPUSH
66887: LD_VAR 0 13
66891: PPUSH
66892: CALL_OW 325
66896: PUSH
66897: LD_VAR 0 10
66901: PPUSH
66902: CALL_OW 255
66906: PPUSH
66907: LD_VAR 0 13
66911: PPUSH
66912: CALL_OW 325
66916: NOT
66917: AND
66918: IFFALSE 66947
// missile := Insert ( missile , missile + 1 , 3 ) ;
66920: LD_ADDR_VAR 0 14
66924: PUSH
66925: LD_VAR 0 14
66929: PPUSH
66930: LD_VAR 0 14
66934: PUSH
66935: LD_INT 1
66937: PLUS
66938: PPUSH
66939: LD_INT 3
66941: PPUSH
66942: CALL_OW 2
66946: ST_TO_ADDR
// if missile < 2 then
66947: LD_VAR 0 14
66951: PUSH
66952: LD_INT 2
66954: LESS
66955: IFFALSE 66959
// exit ;
66957: GO 67181
// x := GetX ( enemy ) ;
66959: LD_ADDR_VAR 0 4
66963: PUSH
66964: LD_VAR 0 10
66968: PPUSH
66969: CALL_OW 250
66973: ST_TO_ADDR
// y := GetY ( enemy ) ;
66974: LD_ADDR_VAR 0 5
66978: PUSH
66979: LD_VAR 0 10
66983: PPUSH
66984: CALL_OW 251
66988: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
66989: LD_ADDR_VAR 0 6
66993: PUSH
66994: LD_VAR 0 4
66998: PUSH
66999: LD_INT 1
67001: NEG
67002: PPUSH
67003: LD_INT 1
67005: PPUSH
67006: CALL_OW 12
67010: PLUS
67011: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
67012: LD_ADDR_VAR 0 7
67016: PUSH
67017: LD_VAR 0 5
67021: PUSH
67022: LD_INT 1
67024: NEG
67025: PPUSH
67026: LD_INT 1
67028: PPUSH
67029: CALL_OW 12
67033: PLUS
67034: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
67035: LD_VAR 0 6
67039: PPUSH
67040: LD_VAR 0 7
67044: PPUSH
67045: CALL_OW 488
67049: NOT
67050: IFFALSE 67072
// begin _x := x ;
67052: LD_ADDR_VAR 0 6
67056: PUSH
67057: LD_VAR 0 4
67061: ST_TO_ADDR
// _y := y ;
67062: LD_ADDR_VAR 0 7
67066: PUSH
67067: LD_VAR 0 5
67071: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
67072: LD_ADDR_VAR 0 3
67076: PUSH
67077: LD_INT 1
67079: PPUSH
67080: LD_VAR 0 14
67084: PPUSH
67085: CALL_OW 12
67089: ST_TO_ADDR
// case i of 1 :
67090: LD_VAR 0 3
67094: PUSH
67095: LD_INT 1
67097: DOUBLE
67098: EQUAL
67099: IFTRUE 67103
67101: GO 67120
67103: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
67104: LD_VAR 0 1
67108: PPUSH
67109: LD_VAR 0 10
67113: PPUSH
67114: CALL_OW 115
67118: GO 67181
67120: LD_INT 2
67122: DOUBLE
67123: EQUAL
67124: IFTRUE 67128
67126: GO 67150
67128: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
67129: LD_VAR 0 1
67133: PPUSH
67134: LD_VAR 0 6
67138: PPUSH
67139: LD_VAR 0 7
67143: PPUSH
67144: CALL_OW 153
67148: GO 67181
67150: LD_INT 3
67152: DOUBLE
67153: EQUAL
67154: IFTRUE 67158
67156: GO 67180
67158: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
67159: LD_VAR 0 1
67163: PPUSH
67164: LD_VAR 0 6
67168: PPUSH
67169: LD_VAR 0 7
67173: PPUSH
67174: CALL_OW 154
67178: GO 67181
67180: POP
// end ;
67181: LD_VAR 0 2
67185: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
67186: LD_INT 0
67188: PPUSH
67189: PPUSH
67190: PPUSH
67191: PPUSH
67192: PPUSH
67193: PPUSH
// if not unit or not building then
67194: LD_VAR 0 1
67198: NOT
67199: PUSH
67200: LD_VAR 0 2
67204: NOT
67205: OR
67206: IFFALSE 67210
// exit ;
67208: GO 67368
// x := GetX ( building ) ;
67210: LD_ADDR_VAR 0 5
67214: PUSH
67215: LD_VAR 0 2
67219: PPUSH
67220: CALL_OW 250
67224: ST_TO_ADDR
// y := GetY ( building ) ;
67225: LD_ADDR_VAR 0 6
67229: PUSH
67230: LD_VAR 0 2
67234: PPUSH
67235: CALL_OW 251
67239: ST_TO_ADDR
// for i = 0 to 5 do
67240: LD_ADDR_VAR 0 4
67244: PUSH
67245: DOUBLE
67246: LD_INT 0
67248: DEC
67249: ST_TO_ADDR
67250: LD_INT 5
67252: PUSH
67253: FOR_TO
67254: IFFALSE 67366
// begin _x := ShiftX ( x , i , 3 ) ;
67256: LD_ADDR_VAR 0 7
67260: PUSH
67261: LD_VAR 0 5
67265: PPUSH
67266: LD_VAR 0 4
67270: PPUSH
67271: LD_INT 3
67273: PPUSH
67274: CALL_OW 272
67278: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
67279: LD_ADDR_VAR 0 8
67283: PUSH
67284: LD_VAR 0 6
67288: PPUSH
67289: LD_VAR 0 4
67293: PPUSH
67294: LD_INT 3
67296: PPUSH
67297: CALL_OW 273
67301: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
67302: LD_VAR 0 7
67306: PPUSH
67307: LD_VAR 0 8
67311: PPUSH
67312: CALL_OW 488
67316: NOT
67317: IFFALSE 67321
// continue ;
67319: GO 67253
// if HexInfo ( _x , _y ) = 0 then
67321: LD_VAR 0 7
67325: PPUSH
67326: LD_VAR 0 8
67330: PPUSH
67331: CALL_OW 428
67335: PUSH
67336: LD_INT 0
67338: EQUAL
67339: IFFALSE 67364
// begin ComMoveXY ( unit , _x , _y ) ;
67341: LD_VAR 0 1
67345: PPUSH
67346: LD_VAR 0 7
67350: PPUSH
67351: LD_VAR 0 8
67355: PPUSH
67356: CALL_OW 111
// exit ;
67360: POP
67361: POP
67362: GO 67368
// end ; end ;
67364: GO 67253
67366: POP
67367: POP
// end ;
67368: LD_VAR 0 3
67372: RET
// export function ScanBase ( side , base_area ) ; begin
67373: LD_INT 0
67375: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
67376: LD_ADDR_VAR 0 3
67380: PUSH
67381: LD_VAR 0 2
67385: PPUSH
67386: LD_INT 81
67388: PUSH
67389: LD_VAR 0 1
67393: PUSH
67394: EMPTY
67395: LIST
67396: LIST
67397: PPUSH
67398: CALL_OW 70
67402: ST_TO_ADDR
// end ;
67403: LD_VAR 0 3
67407: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
67408: LD_INT 0
67410: PPUSH
67411: PPUSH
67412: PPUSH
67413: PPUSH
// result := false ;
67414: LD_ADDR_VAR 0 2
67418: PUSH
67419: LD_INT 0
67421: ST_TO_ADDR
// side := GetSide ( unit ) ;
67422: LD_ADDR_VAR 0 3
67426: PUSH
67427: LD_VAR 0 1
67431: PPUSH
67432: CALL_OW 255
67436: ST_TO_ADDR
// nat := GetNation ( unit ) ;
67437: LD_ADDR_VAR 0 4
67441: PUSH
67442: LD_VAR 0 1
67446: PPUSH
67447: CALL_OW 248
67451: ST_TO_ADDR
// case nat of 1 :
67452: LD_VAR 0 4
67456: PUSH
67457: LD_INT 1
67459: DOUBLE
67460: EQUAL
67461: IFTRUE 67465
67463: GO 67476
67465: POP
// tech := tech_lassight ; 2 :
67466: LD_ADDR_VAR 0 5
67470: PUSH
67471: LD_INT 12
67473: ST_TO_ADDR
67474: GO 67515
67476: LD_INT 2
67478: DOUBLE
67479: EQUAL
67480: IFTRUE 67484
67482: GO 67495
67484: POP
// tech := tech_mortar ; 3 :
67485: LD_ADDR_VAR 0 5
67489: PUSH
67490: LD_INT 41
67492: ST_TO_ADDR
67493: GO 67515
67495: LD_INT 3
67497: DOUBLE
67498: EQUAL
67499: IFTRUE 67503
67501: GO 67514
67503: POP
// tech := tech_bazooka ; end ;
67504: LD_ADDR_VAR 0 5
67508: PUSH
67509: LD_INT 44
67511: ST_TO_ADDR
67512: GO 67515
67514: POP
// if Researched ( side , tech ) then
67515: LD_VAR 0 3
67519: PPUSH
67520: LD_VAR 0 5
67524: PPUSH
67525: CALL_OW 325
67529: IFFALSE 67556
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
67531: LD_ADDR_VAR 0 2
67535: PUSH
67536: LD_INT 5
67538: PUSH
67539: LD_INT 8
67541: PUSH
67542: LD_INT 9
67544: PUSH
67545: EMPTY
67546: LIST
67547: LIST
67548: LIST
67549: PUSH
67550: LD_VAR 0 4
67554: ARRAY
67555: ST_TO_ADDR
// end ;
67556: LD_VAR 0 2
67560: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
67561: LD_INT 0
67563: PPUSH
67564: PPUSH
67565: PPUSH
// if not mines then
67566: LD_VAR 0 2
67570: NOT
67571: IFFALSE 67575
// exit ;
67573: GO 67719
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67575: LD_ADDR_VAR 0 5
67579: PUSH
67580: LD_INT 81
67582: PUSH
67583: LD_VAR 0 1
67587: PUSH
67588: EMPTY
67589: LIST
67590: LIST
67591: PUSH
67592: LD_INT 3
67594: PUSH
67595: LD_INT 21
67597: PUSH
67598: LD_INT 3
67600: PUSH
67601: EMPTY
67602: LIST
67603: LIST
67604: PUSH
67605: EMPTY
67606: LIST
67607: LIST
67608: PUSH
67609: EMPTY
67610: LIST
67611: LIST
67612: PPUSH
67613: CALL_OW 69
67617: ST_TO_ADDR
// for i in mines do
67618: LD_ADDR_VAR 0 4
67622: PUSH
67623: LD_VAR 0 2
67627: PUSH
67628: FOR_IN
67629: IFFALSE 67717
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
67631: LD_VAR 0 4
67635: PUSH
67636: LD_INT 1
67638: ARRAY
67639: PPUSH
67640: LD_VAR 0 4
67644: PUSH
67645: LD_INT 2
67647: ARRAY
67648: PPUSH
67649: CALL_OW 458
67653: NOT
67654: IFFALSE 67658
// continue ;
67656: GO 67628
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
67658: LD_VAR 0 4
67662: PUSH
67663: LD_INT 1
67665: ARRAY
67666: PPUSH
67667: LD_VAR 0 4
67671: PUSH
67672: LD_INT 2
67674: ARRAY
67675: PPUSH
67676: CALL_OW 428
67680: PUSH
67681: LD_VAR 0 5
67685: IN
67686: IFFALSE 67715
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
67688: LD_VAR 0 4
67692: PUSH
67693: LD_INT 1
67695: ARRAY
67696: PPUSH
67697: LD_VAR 0 4
67701: PUSH
67702: LD_INT 2
67704: ARRAY
67705: PPUSH
67706: LD_VAR 0 1
67710: PPUSH
67711: CALL_OW 456
// end ;
67715: GO 67628
67717: POP
67718: POP
// end ;
67719: LD_VAR 0 3
67723: RET
// export function Count ( array ) ; var i ; begin
67724: LD_INT 0
67726: PPUSH
67727: PPUSH
// result := 0 ;
67728: LD_ADDR_VAR 0 2
67732: PUSH
67733: LD_INT 0
67735: ST_TO_ADDR
// for i in array do
67736: LD_ADDR_VAR 0 3
67740: PUSH
67741: LD_VAR 0 1
67745: PUSH
67746: FOR_IN
67747: IFFALSE 67771
// if i then
67749: LD_VAR 0 3
67753: IFFALSE 67769
// result := result + 1 ;
67755: LD_ADDR_VAR 0 2
67759: PUSH
67760: LD_VAR 0 2
67764: PUSH
67765: LD_INT 1
67767: PLUS
67768: ST_TO_ADDR
67769: GO 67746
67771: POP
67772: POP
// end ;
67773: LD_VAR 0 2
67777: RET
// export function IsEmpty ( building ) ; begin
67778: LD_INT 0
67780: PPUSH
// if not building then
67781: LD_VAR 0 1
67785: NOT
67786: IFFALSE 67790
// exit ;
67788: GO 67833
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
67790: LD_ADDR_VAR 0 2
67794: PUSH
67795: LD_VAR 0 1
67799: PUSH
67800: LD_INT 22
67802: PUSH
67803: LD_VAR 0 1
67807: PPUSH
67808: CALL_OW 255
67812: PUSH
67813: EMPTY
67814: LIST
67815: LIST
67816: PUSH
67817: LD_INT 58
67819: PUSH
67820: EMPTY
67821: LIST
67822: PUSH
67823: EMPTY
67824: LIST
67825: LIST
67826: PPUSH
67827: CALL_OW 69
67831: IN
67832: ST_TO_ADDR
// end ;
67833: LD_VAR 0 2
67837: RET
// export function IsNotFull ( building ) ; begin
67838: LD_INT 0
67840: PPUSH
// if not building then
67841: LD_VAR 0 1
67845: NOT
67846: IFFALSE 67850
// exit ;
67848: GO 67869
// result := UnitsInside ( building ) < 6 ;
67850: LD_ADDR_VAR 0 2
67854: PUSH
67855: LD_VAR 0 1
67859: PPUSH
67860: CALL_OW 313
67864: PUSH
67865: LD_INT 6
67867: LESS
67868: ST_TO_ADDR
// end ;
67869: LD_VAR 0 2
67873: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
67874: LD_INT 0
67876: PPUSH
67877: PPUSH
67878: PPUSH
67879: PPUSH
// tmp := [ ] ;
67880: LD_ADDR_VAR 0 3
67884: PUSH
67885: EMPTY
67886: ST_TO_ADDR
// list := [ ] ;
67887: LD_ADDR_VAR 0 5
67891: PUSH
67892: EMPTY
67893: ST_TO_ADDR
// for i = 16 to 25 do
67894: LD_ADDR_VAR 0 4
67898: PUSH
67899: DOUBLE
67900: LD_INT 16
67902: DEC
67903: ST_TO_ADDR
67904: LD_INT 25
67906: PUSH
67907: FOR_TO
67908: IFFALSE 67981
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
67910: LD_ADDR_VAR 0 3
67914: PUSH
67915: LD_VAR 0 3
67919: PUSH
67920: LD_INT 22
67922: PUSH
67923: LD_VAR 0 1
67927: PPUSH
67928: CALL_OW 255
67932: PUSH
67933: EMPTY
67934: LIST
67935: LIST
67936: PUSH
67937: LD_INT 91
67939: PUSH
67940: LD_VAR 0 1
67944: PUSH
67945: LD_INT 6
67947: PUSH
67948: EMPTY
67949: LIST
67950: LIST
67951: LIST
67952: PUSH
67953: LD_INT 30
67955: PUSH
67956: LD_VAR 0 4
67960: PUSH
67961: EMPTY
67962: LIST
67963: LIST
67964: PUSH
67965: EMPTY
67966: LIST
67967: LIST
67968: LIST
67969: PUSH
67970: EMPTY
67971: LIST
67972: PPUSH
67973: CALL_OW 69
67977: ADD
67978: ST_TO_ADDR
67979: GO 67907
67981: POP
67982: POP
// for i = 1 to tmp do
67983: LD_ADDR_VAR 0 4
67987: PUSH
67988: DOUBLE
67989: LD_INT 1
67991: DEC
67992: ST_TO_ADDR
67993: LD_VAR 0 3
67997: PUSH
67998: FOR_TO
67999: IFFALSE 68087
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
68001: LD_ADDR_VAR 0 5
68005: PUSH
68006: LD_VAR 0 5
68010: PUSH
68011: LD_VAR 0 3
68015: PUSH
68016: LD_VAR 0 4
68020: ARRAY
68021: PPUSH
68022: CALL_OW 266
68026: PUSH
68027: LD_VAR 0 3
68031: PUSH
68032: LD_VAR 0 4
68036: ARRAY
68037: PPUSH
68038: CALL_OW 250
68042: PUSH
68043: LD_VAR 0 3
68047: PUSH
68048: LD_VAR 0 4
68052: ARRAY
68053: PPUSH
68054: CALL_OW 251
68058: PUSH
68059: LD_VAR 0 3
68063: PUSH
68064: LD_VAR 0 4
68068: ARRAY
68069: PPUSH
68070: CALL_OW 254
68074: PUSH
68075: EMPTY
68076: LIST
68077: LIST
68078: LIST
68079: LIST
68080: PUSH
68081: EMPTY
68082: LIST
68083: ADD
68084: ST_TO_ADDR
68085: GO 67998
68087: POP
68088: POP
// result := list ;
68089: LD_ADDR_VAR 0 2
68093: PUSH
68094: LD_VAR 0 5
68098: ST_TO_ADDR
// end ;
68099: LD_VAR 0 2
68103: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
68104: LD_INT 0
68106: PPUSH
68107: PPUSH
68108: PPUSH
68109: PPUSH
68110: PPUSH
68111: PPUSH
68112: PPUSH
// if not factory then
68113: LD_VAR 0 1
68117: NOT
68118: IFFALSE 68122
// exit ;
68120: GO 68715
// if control = control_apeman then
68122: LD_VAR 0 4
68126: PUSH
68127: LD_INT 5
68129: EQUAL
68130: IFFALSE 68239
// begin tmp := UnitsInside ( factory ) ;
68132: LD_ADDR_VAR 0 8
68136: PUSH
68137: LD_VAR 0 1
68141: PPUSH
68142: CALL_OW 313
68146: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
68147: LD_VAR 0 8
68151: PPUSH
68152: LD_INT 25
68154: PUSH
68155: LD_INT 12
68157: PUSH
68158: EMPTY
68159: LIST
68160: LIST
68161: PPUSH
68162: CALL_OW 72
68166: NOT
68167: IFFALSE 68177
// control := control_manual ;
68169: LD_ADDR_VAR 0 4
68173: PUSH
68174: LD_INT 1
68176: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
68177: LD_ADDR_VAR 0 8
68181: PUSH
68182: LD_VAR 0 1
68186: PPUSH
68187: CALL 67874 0 1
68191: ST_TO_ADDR
// if tmp then
68192: LD_VAR 0 8
68196: IFFALSE 68239
// begin for i in tmp do
68198: LD_ADDR_VAR 0 7
68202: PUSH
68203: LD_VAR 0 8
68207: PUSH
68208: FOR_IN
68209: IFFALSE 68237
// if i [ 1 ] = b_ext_radio then
68211: LD_VAR 0 7
68215: PUSH
68216: LD_INT 1
68218: ARRAY
68219: PUSH
68220: LD_INT 22
68222: EQUAL
68223: IFFALSE 68235
// begin control := control_remote ;
68225: LD_ADDR_VAR 0 4
68229: PUSH
68230: LD_INT 2
68232: ST_TO_ADDR
// break ;
68233: GO 68237
// end ;
68235: GO 68208
68237: POP
68238: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68239: LD_VAR 0 1
68243: PPUSH
68244: LD_VAR 0 2
68248: PPUSH
68249: LD_VAR 0 3
68253: PPUSH
68254: LD_VAR 0 4
68258: PPUSH
68259: LD_VAR 0 5
68263: PPUSH
68264: CALL_OW 448
68268: IFFALSE 68303
// begin result := [ chassis , engine , control , weapon ] ;
68270: LD_ADDR_VAR 0 6
68274: PUSH
68275: LD_VAR 0 2
68279: PUSH
68280: LD_VAR 0 3
68284: PUSH
68285: LD_VAR 0 4
68289: PUSH
68290: LD_VAR 0 5
68294: PUSH
68295: EMPTY
68296: LIST
68297: LIST
68298: LIST
68299: LIST
68300: ST_TO_ADDR
// exit ;
68301: GO 68715
// end ; _chassis := AvailableChassisList ( factory ) ;
68303: LD_ADDR_VAR 0 9
68307: PUSH
68308: LD_VAR 0 1
68312: PPUSH
68313: CALL_OW 475
68317: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
68318: LD_ADDR_VAR 0 11
68322: PUSH
68323: LD_VAR 0 1
68327: PPUSH
68328: CALL_OW 476
68332: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
68333: LD_ADDR_VAR 0 12
68337: PUSH
68338: LD_VAR 0 1
68342: PPUSH
68343: CALL_OW 477
68347: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
68348: LD_ADDR_VAR 0 10
68352: PUSH
68353: LD_VAR 0 1
68357: PPUSH
68358: CALL_OW 478
68362: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
68363: LD_VAR 0 9
68367: NOT
68368: PUSH
68369: LD_VAR 0 11
68373: NOT
68374: OR
68375: PUSH
68376: LD_VAR 0 12
68380: NOT
68381: OR
68382: PUSH
68383: LD_VAR 0 10
68387: NOT
68388: OR
68389: IFFALSE 68424
// begin result := [ chassis , engine , control , weapon ] ;
68391: LD_ADDR_VAR 0 6
68395: PUSH
68396: LD_VAR 0 2
68400: PUSH
68401: LD_VAR 0 3
68405: PUSH
68406: LD_VAR 0 4
68410: PUSH
68411: LD_VAR 0 5
68415: PUSH
68416: EMPTY
68417: LIST
68418: LIST
68419: LIST
68420: LIST
68421: ST_TO_ADDR
// exit ;
68422: GO 68715
// end ; if not chassis in _chassis then
68424: LD_VAR 0 2
68428: PUSH
68429: LD_VAR 0 9
68433: IN
68434: NOT
68435: IFFALSE 68461
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
68437: LD_ADDR_VAR 0 2
68441: PUSH
68442: LD_VAR 0 9
68446: PUSH
68447: LD_INT 1
68449: PPUSH
68450: LD_VAR 0 9
68454: PPUSH
68455: CALL_OW 12
68459: ARRAY
68460: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
68461: LD_VAR 0 2
68465: PPUSH
68466: LD_VAR 0 3
68470: PPUSH
68471: CALL 68720 0 2
68475: NOT
68476: IFFALSE 68535
// repeat engine := _engine [ 1 ] ;
68478: LD_ADDR_VAR 0 3
68482: PUSH
68483: LD_VAR 0 11
68487: PUSH
68488: LD_INT 1
68490: ARRAY
68491: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
68492: LD_ADDR_VAR 0 11
68496: PUSH
68497: LD_VAR 0 11
68501: PPUSH
68502: LD_INT 1
68504: PPUSH
68505: CALL_OW 3
68509: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
68510: LD_VAR 0 2
68514: PPUSH
68515: LD_VAR 0 3
68519: PPUSH
68520: CALL 68720 0 2
68524: PUSH
68525: LD_VAR 0 11
68529: PUSH
68530: EMPTY
68531: EQUAL
68532: OR
68533: IFFALSE 68478
// if not control in _control then
68535: LD_VAR 0 4
68539: PUSH
68540: LD_VAR 0 12
68544: IN
68545: NOT
68546: IFFALSE 68572
// control := _control [ rand ( 1 , _control ) ] ;
68548: LD_ADDR_VAR 0 4
68552: PUSH
68553: LD_VAR 0 12
68557: PUSH
68558: LD_INT 1
68560: PPUSH
68561: LD_VAR 0 12
68565: PPUSH
68566: CALL_OW 12
68570: ARRAY
68571: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
68572: LD_VAR 0 2
68576: PPUSH
68577: LD_VAR 0 5
68581: PPUSH
68582: CALL 68940 0 2
68586: NOT
68587: IFFALSE 68646
// repeat weapon := _weapon [ 1 ] ;
68589: LD_ADDR_VAR 0 5
68593: PUSH
68594: LD_VAR 0 10
68598: PUSH
68599: LD_INT 1
68601: ARRAY
68602: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
68603: LD_ADDR_VAR 0 10
68607: PUSH
68608: LD_VAR 0 10
68612: PPUSH
68613: LD_INT 1
68615: PPUSH
68616: CALL_OW 3
68620: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
68621: LD_VAR 0 2
68625: PPUSH
68626: LD_VAR 0 5
68630: PPUSH
68631: CALL 68940 0 2
68635: PUSH
68636: LD_VAR 0 10
68640: PUSH
68641: EMPTY
68642: EQUAL
68643: OR
68644: IFFALSE 68589
// result := [ ] ;
68646: LD_ADDR_VAR 0 6
68650: PUSH
68651: EMPTY
68652: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68653: LD_VAR 0 1
68657: PPUSH
68658: LD_VAR 0 2
68662: PPUSH
68663: LD_VAR 0 3
68667: PPUSH
68668: LD_VAR 0 4
68672: PPUSH
68673: LD_VAR 0 5
68677: PPUSH
68678: CALL_OW 448
68682: IFFALSE 68715
// result := [ chassis , engine , control , weapon ] ;
68684: LD_ADDR_VAR 0 6
68688: PUSH
68689: LD_VAR 0 2
68693: PUSH
68694: LD_VAR 0 3
68698: PUSH
68699: LD_VAR 0 4
68703: PUSH
68704: LD_VAR 0 5
68708: PUSH
68709: EMPTY
68710: LIST
68711: LIST
68712: LIST
68713: LIST
68714: ST_TO_ADDR
// end ;
68715: LD_VAR 0 6
68719: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
68720: LD_INT 0
68722: PPUSH
// if not chassis or not engine then
68723: LD_VAR 0 1
68727: NOT
68728: PUSH
68729: LD_VAR 0 2
68733: NOT
68734: OR
68735: IFFALSE 68739
// exit ;
68737: GO 68935
// case engine of engine_solar :
68739: LD_VAR 0 2
68743: PUSH
68744: LD_INT 2
68746: DOUBLE
68747: EQUAL
68748: IFTRUE 68752
68750: GO 68790
68752: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
68753: LD_ADDR_VAR 0 3
68757: PUSH
68758: LD_INT 11
68760: PUSH
68761: LD_INT 12
68763: PUSH
68764: LD_INT 13
68766: PUSH
68767: LD_INT 14
68769: PUSH
68770: LD_INT 1
68772: PUSH
68773: LD_INT 2
68775: PUSH
68776: LD_INT 3
68778: PUSH
68779: EMPTY
68780: LIST
68781: LIST
68782: LIST
68783: LIST
68784: LIST
68785: LIST
68786: LIST
68787: ST_TO_ADDR
68788: GO 68919
68790: LD_INT 1
68792: DOUBLE
68793: EQUAL
68794: IFTRUE 68798
68796: GO 68860
68798: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
68799: LD_ADDR_VAR 0 3
68803: PUSH
68804: LD_INT 11
68806: PUSH
68807: LD_INT 12
68809: PUSH
68810: LD_INT 13
68812: PUSH
68813: LD_INT 14
68815: PUSH
68816: LD_INT 1
68818: PUSH
68819: LD_INT 2
68821: PUSH
68822: LD_INT 3
68824: PUSH
68825: LD_INT 4
68827: PUSH
68828: LD_INT 5
68830: PUSH
68831: LD_INT 21
68833: PUSH
68834: LD_INT 23
68836: PUSH
68837: LD_INT 22
68839: PUSH
68840: LD_INT 24
68842: PUSH
68843: EMPTY
68844: LIST
68845: LIST
68846: LIST
68847: LIST
68848: LIST
68849: LIST
68850: LIST
68851: LIST
68852: LIST
68853: LIST
68854: LIST
68855: LIST
68856: LIST
68857: ST_TO_ADDR
68858: GO 68919
68860: LD_INT 3
68862: DOUBLE
68863: EQUAL
68864: IFTRUE 68868
68866: GO 68918
68868: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
68869: LD_ADDR_VAR 0 3
68873: PUSH
68874: LD_INT 13
68876: PUSH
68877: LD_INT 14
68879: PUSH
68880: LD_INT 2
68882: PUSH
68883: LD_INT 3
68885: PUSH
68886: LD_INT 4
68888: PUSH
68889: LD_INT 5
68891: PUSH
68892: LD_INT 21
68894: PUSH
68895: LD_INT 22
68897: PUSH
68898: LD_INT 23
68900: PUSH
68901: LD_INT 24
68903: PUSH
68904: EMPTY
68905: LIST
68906: LIST
68907: LIST
68908: LIST
68909: LIST
68910: LIST
68911: LIST
68912: LIST
68913: LIST
68914: LIST
68915: ST_TO_ADDR
68916: GO 68919
68918: POP
// result := ( chassis in result ) ;
68919: LD_ADDR_VAR 0 3
68923: PUSH
68924: LD_VAR 0 1
68928: PUSH
68929: LD_VAR 0 3
68933: IN
68934: ST_TO_ADDR
// end ;
68935: LD_VAR 0 3
68939: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
68940: LD_INT 0
68942: PPUSH
// if not chassis or not weapon then
68943: LD_VAR 0 1
68947: NOT
68948: PUSH
68949: LD_VAR 0 2
68953: NOT
68954: OR
68955: IFFALSE 68959
// exit ;
68957: GO 70021
// case weapon of us_machine_gun :
68959: LD_VAR 0 2
68963: PUSH
68964: LD_INT 2
68966: DOUBLE
68967: EQUAL
68968: IFTRUE 68972
68970: GO 69002
68972: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
68973: LD_ADDR_VAR 0 3
68977: PUSH
68978: LD_INT 1
68980: PUSH
68981: LD_INT 2
68983: PUSH
68984: LD_INT 3
68986: PUSH
68987: LD_INT 4
68989: PUSH
68990: LD_INT 5
68992: PUSH
68993: EMPTY
68994: LIST
68995: LIST
68996: LIST
68997: LIST
68998: LIST
68999: ST_TO_ADDR
69000: GO 70005
69002: LD_INT 3
69004: DOUBLE
69005: EQUAL
69006: IFTRUE 69010
69008: GO 69040
69010: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
69011: LD_ADDR_VAR 0 3
69015: PUSH
69016: LD_INT 1
69018: PUSH
69019: LD_INT 2
69021: PUSH
69022: LD_INT 3
69024: PUSH
69025: LD_INT 4
69027: PUSH
69028: LD_INT 5
69030: PUSH
69031: EMPTY
69032: LIST
69033: LIST
69034: LIST
69035: LIST
69036: LIST
69037: ST_TO_ADDR
69038: GO 70005
69040: LD_INT 11
69042: DOUBLE
69043: EQUAL
69044: IFTRUE 69048
69046: GO 69078
69048: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
69049: LD_ADDR_VAR 0 3
69053: PUSH
69054: LD_INT 1
69056: PUSH
69057: LD_INT 2
69059: PUSH
69060: LD_INT 3
69062: PUSH
69063: LD_INT 4
69065: PUSH
69066: LD_INT 5
69068: PUSH
69069: EMPTY
69070: LIST
69071: LIST
69072: LIST
69073: LIST
69074: LIST
69075: ST_TO_ADDR
69076: GO 70005
69078: LD_INT 4
69080: DOUBLE
69081: EQUAL
69082: IFTRUE 69086
69084: GO 69112
69086: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
69087: LD_ADDR_VAR 0 3
69091: PUSH
69092: LD_INT 2
69094: PUSH
69095: LD_INT 3
69097: PUSH
69098: LD_INT 4
69100: PUSH
69101: LD_INT 5
69103: PUSH
69104: EMPTY
69105: LIST
69106: LIST
69107: LIST
69108: LIST
69109: ST_TO_ADDR
69110: GO 70005
69112: LD_INT 5
69114: DOUBLE
69115: EQUAL
69116: IFTRUE 69120
69118: GO 69146
69120: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
69121: LD_ADDR_VAR 0 3
69125: PUSH
69126: LD_INT 2
69128: PUSH
69129: LD_INT 3
69131: PUSH
69132: LD_INT 4
69134: PUSH
69135: LD_INT 5
69137: PUSH
69138: EMPTY
69139: LIST
69140: LIST
69141: LIST
69142: LIST
69143: ST_TO_ADDR
69144: GO 70005
69146: LD_INT 9
69148: DOUBLE
69149: EQUAL
69150: IFTRUE 69154
69152: GO 69180
69154: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
69155: LD_ADDR_VAR 0 3
69159: PUSH
69160: LD_INT 2
69162: PUSH
69163: LD_INT 3
69165: PUSH
69166: LD_INT 4
69168: PUSH
69169: LD_INT 5
69171: PUSH
69172: EMPTY
69173: LIST
69174: LIST
69175: LIST
69176: LIST
69177: ST_TO_ADDR
69178: GO 70005
69180: LD_INT 7
69182: DOUBLE
69183: EQUAL
69184: IFTRUE 69188
69186: GO 69214
69188: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
69189: LD_ADDR_VAR 0 3
69193: PUSH
69194: LD_INT 2
69196: PUSH
69197: LD_INT 3
69199: PUSH
69200: LD_INT 4
69202: PUSH
69203: LD_INT 5
69205: PUSH
69206: EMPTY
69207: LIST
69208: LIST
69209: LIST
69210: LIST
69211: ST_TO_ADDR
69212: GO 70005
69214: LD_INT 12
69216: DOUBLE
69217: EQUAL
69218: IFTRUE 69222
69220: GO 69248
69222: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
69223: LD_ADDR_VAR 0 3
69227: PUSH
69228: LD_INT 2
69230: PUSH
69231: LD_INT 3
69233: PUSH
69234: LD_INT 4
69236: PUSH
69237: LD_INT 5
69239: PUSH
69240: EMPTY
69241: LIST
69242: LIST
69243: LIST
69244: LIST
69245: ST_TO_ADDR
69246: GO 70005
69248: LD_INT 13
69250: DOUBLE
69251: EQUAL
69252: IFTRUE 69256
69254: GO 69282
69256: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
69257: LD_ADDR_VAR 0 3
69261: PUSH
69262: LD_INT 2
69264: PUSH
69265: LD_INT 3
69267: PUSH
69268: LD_INT 4
69270: PUSH
69271: LD_INT 5
69273: PUSH
69274: EMPTY
69275: LIST
69276: LIST
69277: LIST
69278: LIST
69279: ST_TO_ADDR
69280: GO 70005
69282: LD_INT 14
69284: DOUBLE
69285: EQUAL
69286: IFTRUE 69290
69288: GO 69308
69290: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
69291: LD_ADDR_VAR 0 3
69295: PUSH
69296: LD_INT 4
69298: PUSH
69299: LD_INT 5
69301: PUSH
69302: EMPTY
69303: LIST
69304: LIST
69305: ST_TO_ADDR
69306: GO 70005
69308: LD_INT 6
69310: DOUBLE
69311: EQUAL
69312: IFTRUE 69316
69314: GO 69334
69316: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
69317: LD_ADDR_VAR 0 3
69321: PUSH
69322: LD_INT 4
69324: PUSH
69325: LD_INT 5
69327: PUSH
69328: EMPTY
69329: LIST
69330: LIST
69331: ST_TO_ADDR
69332: GO 70005
69334: LD_INT 10
69336: DOUBLE
69337: EQUAL
69338: IFTRUE 69342
69340: GO 69360
69342: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
69343: LD_ADDR_VAR 0 3
69347: PUSH
69348: LD_INT 4
69350: PUSH
69351: LD_INT 5
69353: PUSH
69354: EMPTY
69355: LIST
69356: LIST
69357: ST_TO_ADDR
69358: GO 70005
69360: LD_INT 22
69362: DOUBLE
69363: EQUAL
69364: IFTRUE 69368
69366: GO 69394
69368: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
69369: LD_ADDR_VAR 0 3
69373: PUSH
69374: LD_INT 11
69376: PUSH
69377: LD_INT 12
69379: PUSH
69380: LD_INT 13
69382: PUSH
69383: LD_INT 14
69385: PUSH
69386: EMPTY
69387: LIST
69388: LIST
69389: LIST
69390: LIST
69391: ST_TO_ADDR
69392: GO 70005
69394: LD_INT 23
69396: DOUBLE
69397: EQUAL
69398: IFTRUE 69402
69400: GO 69428
69402: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
69403: LD_ADDR_VAR 0 3
69407: PUSH
69408: LD_INT 11
69410: PUSH
69411: LD_INT 12
69413: PUSH
69414: LD_INT 13
69416: PUSH
69417: LD_INT 14
69419: PUSH
69420: EMPTY
69421: LIST
69422: LIST
69423: LIST
69424: LIST
69425: ST_TO_ADDR
69426: GO 70005
69428: LD_INT 24
69430: DOUBLE
69431: EQUAL
69432: IFTRUE 69436
69434: GO 69462
69436: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
69437: LD_ADDR_VAR 0 3
69441: PUSH
69442: LD_INT 11
69444: PUSH
69445: LD_INT 12
69447: PUSH
69448: LD_INT 13
69450: PUSH
69451: LD_INT 14
69453: PUSH
69454: EMPTY
69455: LIST
69456: LIST
69457: LIST
69458: LIST
69459: ST_TO_ADDR
69460: GO 70005
69462: LD_INT 30
69464: DOUBLE
69465: EQUAL
69466: IFTRUE 69470
69468: GO 69496
69470: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
69471: LD_ADDR_VAR 0 3
69475: PUSH
69476: LD_INT 11
69478: PUSH
69479: LD_INT 12
69481: PUSH
69482: LD_INT 13
69484: PUSH
69485: LD_INT 14
69487: PUSH
69488: EMPTY
69489: LIST
69490: LIST
69491: LIST
69492: LIST
69493: ST_TO_ADDR
69494: GO 70005
69496: LD_INT 25
69498: DOUBLE
69499: EQUAL
69500: IFTRUE 69504
69502: GO 69522
69504: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
69505: LD_ADDR_VAR 0 3
69509: PUSH
69510: LD_INT 13
69512: PUSH
69513: LD_INT 14
69515: PUSH
69516: EMPTY
69517: LIST
69518: LIST
69519: ST_TO_ADDR
69520: GO 70005
69522: LD_INT 27
69524: DOUBLE
69525: EQUAL
69526: IFTRUE 69530
69528: GO 69548
69530: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
69531: LD_ADDR_VAR 0 3
69535: PUSH
69536: LD_INT 13
69538: PUSH
69539: LD_INT 14
69541: PUSH
69542: EMPTY
69543: LIST
69544: LIST
69545: ST_TO_ADDR
69546: GO 70005
69548: LD_EXP 100
69552: DOUBLE
69553: EQUAL
69554: IFTRUE 69558
69556: GO 69584
69558: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
69559: LD_ADDR_VAR 0 3
69563: PUSH
69564: LD_INT 11
69566: PUSH
69567: LD_INT 12
69569: PUSH
69570: LD_INT 13
69572: PUSH
69573: LD_INT 14
69575: PUSH
69576: EMPTY
69577: LIST
69578: LIST
69579: LIST
69580: LIST
69581: ST_TO_ADDR
69582: GO 70005
69584: LD_INT 28
69586: DOUBLE
69587: EQUAL
69588: IFTRUE 69592
69590: GO 69610
69592: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
69593: LD_ADDR_VAR 0 3
69597: PUSH
69598: LD_INT 13
69600: PUSH
69601: LD_INT 14
69603: PUSH
69604: EMPTY
69605: LIST
69606: LIST
69607: ST_TO_ADDR
69608: GO 70005
69610: LD_INT 29
69612: DOUBLE
69613: EQUAL
69614: IFTRUE 69618
69616: GO 69636
69618: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
69619: LD_ADDR_VAR 0 3
69623: PUSH
69624: LD_INT 13
69626: PUSH
69627: LD_INT 14
69629: PUSH
69630: EMPTY
69631: LIST
69632: LIST
69633: ST_TO_ADDR
69634: GO 70005
69636: LD_INT 31
69638: DOUBLE
69639: EQUAL
69640: IFTRUE 69644
69642: GO 69662
69644: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
69645: LD_ADDR_VAR 0 3
69649: PUSH
69650: LD_INT 13
69652: PUSH
69653: LD_INT 14
69655: PUSH
69656: EMPTY
69657: LIST
69658: LIST
69659: ST_TO_ADDR
69660: GO 70005
69662: LD_INT 26
69664: DOUBLE
69665: EQUAL
69666: IFTRUE 69670
69668: GO 69688
69670: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
69671: LD_ADDR_VAR 0 3
69675: PUSH
69676: LD_INT 13
69678: PUSH
69679: LD_INT 14
69681: PUSH
69682: EMPTY
69683: LIST
69684: LIST
69685: ST_TO_ADDR
69686: GO 70005
69688: LD_INT 42
69690: DOUBLE
69691: EQUAL
69692: IFTRUE 69696
69694: GO 69722
69696: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
69697: LD_ADDR_VAR 0 3
69701: PUSH
69702: LD_INT 21
69704: PUSH
69705: LD_INT 22
69707: PUSH
69708: LD_INT 23
69710: PUSH
69711: LD_INT 24
69713: PUSH
69714: EMPTY
69715: LIST
69716: LIST
69717: LIST
69718: LIST
69719: ST_TO_ADDR
69720: GO 70005
69722: LD_INT 43
69724: DOUBLE
69725: EQUAL
69726: IFTRUE 69730
69728: GO 69756
69730: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
69731: LD_ADDR_VAR 0 3
69735: PUSH
69736: LD_INT 21
69738: PUSH
69739: LD_INT 22
69741: PUSH
69742: LD_INT 23
69744: PUSH
69745: LD_INT 24
69747: PUSH
69748: EMPTY
69749: LIST
69750: LIST
69751: LIST
69752: LIST
69753: ST_TO_ADDR
69754: GO 70005
69756: LD_INT 44
69758: DOUBLE
69759: EQUAL
69760: IFTRUE 69764
69762: GO 69790
69764: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
69765: LD_ADDR_VAR 0 3
69769: PUSH
69770: LD_INT 21
69772: PUSH
69773: LD_INT 22
69775: PUSH
69776: LD_INT 23
69778: PUSH
69779: LD_INT 24
69781: PUSH
69782: EMPTY
69783: LIST
69784: LIST
69785: LIST
69786: LIST
69787: ST_TO_ADDR
69788: GO 70005
69790: LD_INT 45
69792: DOUBLE
69793: EQUAL
69794: IFTRUE 69798
69796: GO 69824
69798: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
69799: LD_ADDR_VAR 0 3
69803: PUSH
69804: LD_INT 21
69806: PUSH
69807: LD_INT 22
69809: PUSH
69810: LD_INT 23
69812: PUSH
69813: LD_INT 24
69815: PUSH
69816: EMPTY
69817: LIST
69818: LIST
69819: LIST
69820: LIST
69821: ST_TO_ADDR
69822: GO 70005
69824: LD_INT 49
69826: DOUBLE
69827: EQUAL
69828: IFTRUE 69832
69830: GO 69858
69832: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
69833: LD_ADDR_VAR 0 3
69837: PUSH
69838: LD_INT 21
69840: PUSH
69841: LD_INT 22
69843: PUSH
69844: LD_INT 23
69846: PUSH
69847: LD_INT 24
69849: PUSH
69850: EMPTY
69851: LIST
69852: LIST
69853: LIST
69854: LIST
69855: ST_TO_ADDR
69856: GO 70005
69858: LD_INT 51
69860: DOUBLE
69861: EQUAL
69862: IFTRUE 69866
69864: GO 69892
69866: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
69867: LD_ADDR_VAR 0 3
69871: PUSH
69872: LD_INT 21
69874: PUSH
69875: LD_INT 22
69877: PUSH
69878: LD_INT 23
69880: PUSH
69881: LD_INT 24
69883: PUSH
69884: EMPTY
69885: LIST
69886: LIST
69887: LIST
69888: LIST
69889: ST_TO_ADDR
69890: GO 70005
69892: LD_INT 52
69894: DOUBLE
69895: EQUAL
69896: IFTRUE 69900
69898: GO 69926
69900: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
69901: LD_ADDR_VAR 0 3
69905: PUSH
69906: LD_INT 21
69908: PUSH
69909: LD_INT 22
69911: PUSH
69912: LD_INT 23
69914: PUSH
69915: LD_INT 24
69917: PUSH
69918: EMPTY
69919: LIST
69920: LIST
69921: LIST
69922: LIST
69923: ST_TO_ADDR
69924: GO 70005
69926: LD_INT 53
69928: DOUBLE
69929: EQUAL
69930: IFTRUE 69934
69932: GO 69952
69934: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
69935: LD_ADDR_VAR 0 3
69939: PUSH
69940: LD_INT 23
69942: PUSH
69943: LD_INT 24
69945: PUSH
69946: EMPTY
69947: LIST
69948: LIST
69949: ST_TO_ADDR
69950: GO 70005
69952: LD_INT 46
69954: DOUBLE
69955: EQUAL
69956: IFTRUE 69960
69958: GO 69978
69960: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
69961: LD_ADDR_VAR 0 3
69965: PUSH
69966: LD_INT 23
69968: PUSH
69969: LD_INT 24
69971: PUSH
69972: EMPTY
69973: LIST
69974: LIST
69975: ST_TO_ADDR
69976: GO 70005
69978: LD_INT 47
69980: DOUBLE
69981: EQUAL
69982: IFTRUE 69986
69984: GO 70004
69986: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69987: LD_ADDR_VAR 0 3
69991: PUSH
69992: LD_INT 23
69994: PUSH
69995: LD_INT 24
69997: PUSH
69998: EMPTY
69999: LIST
70000: LIST
70001: ST_TO_ADDR
70002: GO 70005
70004: POP
// result := ( chassis in result ) ;
70005: LD_ADDR_VAR 0 3
70009: PUSH
70010: LD_VAR 0 1
70014: PUSH
70015: LD_VAR 0 3
70019: IN
70020: ST_TO_ADDR
// end ;
70021: LD_VAR 0 3
70025: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
70026: LD_INT 0
70028: PPUSH
70029: PPUSH
70030: PPUSH
70031: PPUSH
70032: PPUSH
70033: PPUSH
70034: PPUSH
// result := array ;
70035: LD_ADDR_VAR 0 5
70039: PUSH
70040: LD_VAR 0 1
70044: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
70045: LD_VAR 0 1
70049: NOT
70050: PUSH
70051: LD_VAR 0 2
70055: NOT
70056: OR
70057: PUSH
70058: LD_VAR 0 3
70062: NOT
70063: OR
70064: PUSH
70065: LD_VAR 0 2
70069: PUSH
70070: LD_VAR 0 1
70074: GREATER
70075: OR
70076: PUSH
70077: LD_VAR 0 3
70081: PUSH
70082: LD_VAR 0 1
70086: GREATER
70087: OR
70088: IFFALSE 70092
// exit ;
70090: GO 70388
// if direction then
70092: LD_VAR 0 4
70096: IFFALSE 70160
// begin d := 1 ;
70098: LD_ADDR_VAR 0 9
70102: PUSH
70103: LD_INT 1
70105: ST_TO_ADDR
// if i_from > i_to then
70106: LD_VAR 0 2
70110: PUSH
70111: LD_VAR 0 3
70115: GREATER
70116: IFFALSE 70142
// length := ( array - i_from ) + i_to else
70118: LD_ADDR_VAR 0 11
70122: PUSH
70123: LD_VAR 0 1
70127: PUSH
70128: LD_VAR 0 2
70132: MINUS
70133: PUSH
70134: LD_VAR 0 3
70138: PLUS
70139: ST_TO_ADDR
70140: GO 70158
// length := i_to - i_from ;
70142: LD_ADDR_VAR 0 11
70146: PUSH
70147: LD_VAR 0 3
70151: PUSH
70152: LD_VAR 0 2
70156: MINUS
70157: ST_TO_ADDR
// end else
70158: GO 70221
// begin d := - 1 ;
70160: LD_ADDR_VAR 0 9
70164: PUSH
70165: LD_INT 1
70167: NEG
70168: ST_TO_ADDR
// if i_from > i_to then
70169: LD_VAR 0 2
70173: PUSH
70174: LD_VAR 0 3
70178: GREATER
70179: IFFALSE 70199
// length := i_from - i_to else
70181: LD_ADDR_VAR 0 11
70185: PUSH
70186: LD_VAR 0 2
70190: PUSH
70191: LD_VAR 0 3
70195: MINUS
70196: ST_TO_ADDR
70197: GO 70221
// length := ( array - i_to ) + i_from ;
70199: LD_ADDR_VAR 0 11
70203: PUSH
70204: LD_VAR 0 1
70208: PUSH
70209: LD_VAR 0 3
70213: MINUS
70214: PUSH
70215: LD_VAR 0 2
70219: PLUS
70220: ST_TO_ADDR
// end ; if not length then
70221: LD_VAR 0 11
70225: NOT
70226: IFFALSE 70230
// exit ;
70228: GO 70388
// tmp := array ;
70230: LD_ADDR_VAR 0 10
70234: PUSH
70235: LD_VAR 0 1
70239: ST_TO_ADDR
// for i = 1 to length do
70240: LD_ADDR_VAR 0 6
70244: PUSH
70245: DOUBLE
70246: LD_INT 1
70248: DEC
70249: ST_TO_ADDR
70250: LD_VAR 0 11
70254: PUSH
70255: FOR_TO
70256: IFFALSE 70376
// begin for j = 1 to array do
70258: LD_ADDR_VAR 0 7
70262: PUSH
70263: DOUBLE
70264: LD_INT 1
70266: DEC
70267: ST_TO_ADDR
70268: LD_VAR 0 1
70272: PUSH
70273: FOR_TO
70274: IFFALSE 70362
// begin k := j + d ;
70276: LD_ADDR_VAR 0 8
70280: PUSH
70281: LD_VAR 0 7
70285: PUSH
70286: LD_VAR 0 9
70290: PLUS
70291: ST_TO_ADDR
// if k > array then
70292: LD_VAR 0 8
70296: PUSH
70297: LD_VAR 0 1
70301: GREATER
70302: IFFALSE 70312
// k := 1 ;
70304: LD_ADDR_VAR 0 8
70308: PUSH
70309: LD_INT 1
70311: ST_TO_ADDR
// if not k then
70312: LD_VAR 0 8
70316: NOT
70317: IFFALSE 70329
// k := array ;
70319: LD_ADDR_VAR 0 8
70323: PUSH
70324: LD_VAR 0 1
70328: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
70329: LD_ADDR_VAR 0 10
70333: PUSH
70334: LD_VAR 0 10
70338: PPUSH
70339: LD_VAR 0 8
70343: PPUSH
70344: LD_VAR 0 1
70348: PUSH
70349: LD_VAR 0 7
70353: ARRAY
70354: PPUSH
70355: CALL_OW 1
70359: ST_TO_ADDR
// end ;
70360: GO 70273
70362: POP
70363: POP
// array := tmp ;
70364: LD_ADDR_VAR 0 1
70368: PUSH
70369: LD_VAR 0 10
70373: ST_TO_ADDR
// end ;
70374: GO 70255
70376: POP
70377: POP
// result := array ;
70378: LD_ADDR_VAR 0 5
70382: PUSH
70383: LD_VAR 0 1
70387: ST_TO_ADDR
// end ;
70388: LD_VAR 0 5
70392: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
70393: LD_INT 0
70395: PPUSH
70396: PPUSH
// result := 0 ;
70397: LD_ADDR_VAR 0 3
70401: PUSH
70402: LD_INT 0
70404: ST_TO_ADDR
// if not array or not value in array then
70405: LD_VAR 0 1
70409: NOT
70410: PUSH
70411: LD_VAR 0 2
70415: PUSH
70416: LD_VAR 0 1
70420: IN
70421: NOT
70422: OR
70423: IFFALSE 70427
// exit ;
70425: GO 70481
// for i = 1 to array do
70427: LD_ADDR_VAR 0 4
70431: PUSH
70432: DOUBLE
70433: LD_INT 1
70435: DEC
70436: ST_TO_ADDR
70437: LD_VAR 0 1
70441: PUSH
70442: FOR_TO
70443: IFFALSE 70479
// if value = array [ i ] then
70445: LD_VAR 0 2
70449: PUSH
70450: LD_VAR 0 1
70454: PUSH
70455: LD_VAR 0 4
70459: ARRAY
70460: EQUAL
70461: IFFALSE 70477
// begin result := i ;
70463: LD_ADDR_VAR 0 3
70467: PUSH
70468: LD_VAR 0 4
70472: ST_TO_ADDR
// exit ;
70473: POP
70474: POP
70475: GO 70481
// end ;
70477: GO 70442
70479: POP
70480: POP
// end ;
70481: LD_VAR 0 3
70485: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
70486: LD_INT 0
70488: PPUSH
// vc_chassis := chassis ;
70489: LD_ADDR_OWVAR 37
70493: PUSH
70494: LD_VAR 0 1
70498: ST_TO_ADDR
// vc_engine := engine ;
70499: LD_ADDR_OWVAR 39
70503: PUSH
70504: LD_VAR 0 2
70508: ST_TO_ADDR
// vc_control := control ;
70509: LD_ADDR_OWVAR 38
70513: PUSH
70514: LD_VAR 0 3
70518: ST_TO_ADDR
// vc_weapon := weapon ;
70519: LD_ADDR_OWVAR 40
70523: PUSH
70524: LD_VAR 0 4
70528: ST_TO_ADDR
// vc_fuel_battery := fuel ;
70529: LD_ADDR_OWVAR 41
70533: PUSH
70534: LD_VAR 0 5
70538: ST_TO_ADDR
// end ;
70539: LD_VAR 0 6
70543: RET
// export function WantPlant ( unit ) ; var task ; begin
70544: LD_INT 0
70546: PPUSH
70547: PPUSH
// result := false ;
70548: LD_ADDR_VAR 0 2
70552: PUSH
70553: LD_INT 0
70555: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
70556: LD_ADDR_VAR 0 3
70560: PUSH
70561: LD_VAR 0 1
70565: PPUSH
70566: CALL_OW 437
70570: ST_TO_ADDR
// if task then
70571: LD_VAR 0 3
70575: IFFALSE 70603
// if task [ 1 ] [ 1 ] = p then
70577: LD_VAR 0 3
70581: PUSH
70582: LD_INT 1
70584: ARRAY
70585: PUSH
70586: LD_INT 1
70588: ARRAY
70589: PUSH
70590: LD_STRING p
70592: EQUAL
70593: IFFALSE 70603
// result := true ;
70595: LD_ADDR_VAR 0 2
70599: PUSH
70600: LD_INT 1
70602: ST_TO_ADDR
// end ;
70603: LD_VAR 0 2
70607: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
70608: LD_INT 0
70610: PPUSH
70611: PPUSH
70612: PPUSH
70613: PPUSH
// if pos < 1 then
70614: LD_VAR 0 2
70618: PUSH
70619: LD_INT 1
70621: LESS
70622: IFFALSE 70626
// exit ;
70624: GO 70929
// if pos = 1 then
70626: LD_VAR 0 2
70630: PUSH
70631: LD_INT 1
70633: EQUAL
70634: IFFALSE 70667
// result := Replace ( arr , pos [ 1 ] , value ) else
70636: LD_ADDR_VAR 0 4
70640: PUSH
70641: LD_VAR 0 1
70645: PPUSH
70646: LD_VAR 0 2
70650: PUSH
70651: LD_INT 1
70653: ARRAY
70654: PPUSH
70655: LD_VAR 0 3
70659: PPUSH
70660: CALL_OW 1
70664: ST_TO_ADDR
70665: GO 70929
// begin tmp := arr ;
70667: LD_ADDR_VAR 0 6
70671: PUSH
70672: LD_VAR 0 1
70676: ST_TO_ADDR
// s_arr := [ tmp ] ;
70677: LD_ADDR_VAR 0 7
70681: PUSH
70682: LD_VAR 0 6
70686: PUSH
70687: EMPTY
70688: LIST
70689: ST_TO_ADDR
// for i = 1 to pos - 1 do
70690: LD_ADDR_VAR 0 5
70694: PUSH
70695: DOUBLE
70696: LD_INT 1
70698: DEC
70699: ST_TO_ADDR
70700: LD_VAR 0 2
70704: PUSH
70705: LD_INT 1
70707: MINUS
70708: PUSH
70709: FOR_TO
70710: IFFALSE 70755
// begin tmp := tmp [ pos [ i ] ] ;
70712: LD_ADDR_VAR 0 6
70716: PUSH
70717: LD_VAR 0 6
70721: PUSH
70722: LD_VAR 0 2
70726: PUSH
70727: LD_VAR 0 5
70731: ARRAY
70732: ARRAY
70733: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
70734: LD_ADDR_VAR 0 7
70738: PUSH
70739: LD_VAR 0 7
70743: PUSH
70744: LD_VAR 0 6
70748: PUSH
70749: EMPTY
70750: LIST
70751: ADD
70752: ST_TO_ADDR
// end ;
70753: GO 70709
70755: POP
70756: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
70757: LD_ADDR_VAR 0 6
70761: PUSH
70762: LD_VAR 0 6
70766: PPUSH
70767: LD_VAR 0 2
70771: PUSH
70772: LD_VAR 0 2
70776: ARRAY
70777: PPUSH
70778: LD_VAR 0 3
70782: PPUSH
70783: CALL_OW 1
70787: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
70788: LD_ADDR_VAR 0 7
70792: PUSH
70793: LD_VAR 0 7
70797: PPUSH
70798: LD_VAR 0 7
70802: PPUSH
70803: LD_VAR 0 6
70807: PPUSH
70808: CALL_OW 1
70812: ST_TO_ADDR
// for i = s_arr downto 2 do
70813: LD_ADDR_VAR 0 5
70817: PUSH
70818: DOUBLE
70819: LD_VAR 0 7
70823: INC
70824: ST_TO_ADDR
70825: LD_INT 2
70827: PUSH
70828: FOR_DOWNTO
70829: IFFALSE 70913
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
70831: LD_ADDR_VAR 0 6
70835: PUSH
70836: LD_VAR 0 7
70840: PUSH
70841: LD_VAR 0 5
70845: PUSH
70846: LD_INT 1
70848: MINUS
70849: ARRAY
70850: PPUSH
70851: LD_VAR 0 2
70855: PUSH
70856: LD_VAR 0 5
70860: PUSH
70861: LD_INT 1
70863: MINUS
70864: ARRAY
70865: PPUSH
70866: LD_VAR 0 7
70870: PUSH
70871: LD_VAR 0 5
70875: ARRAY
70876: PPUSH
70877: CALL_OW 1
70881: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
70882: LD_ADDR_VAR 0 7
70886: PUSH
70887: LD_VAR 0 7
70891: PPUSH
70892: LD_VAR 0 5
70896: PUSH
70897: LD_INT 1
70899: MINUS
70900: PPUSH
70901: LD_VAR 0 6
70905: PPUSH
70906: CALL_OW 1
70910: ST_TO_ADDR
// end ;
70911: GO 70828
70913: POP
70914: POP
// result := s_arr [ 1 ] ;
70915: LD_ADDR_VAR 0 4
70919: PUSH
70920: LD_VAR 0 7
70924: PUSH
70925: LD_INT 1
70927: ARRAY
70928: ST_TO_ADDR
// end ; end ;
70929: LD_VAR 0 4
70933: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
70934: LD_INT 0
70936: PPUSH
70937: PPUSH
// if not list then
70938: LD_VAR 0 1
70942: NOT
70943: IFFALSE 70947
// exit ;
70945: GO 71038
// i := list [ pos1 ] ;
70947: LD_ADDR_VAR 0 5
70951: PUSH
70952: LD_VAR 0 1
70956: PUSH
70957: LD_VAR 0 2
70961: ARRAY
70962: ST_TO_ADDR
// if not i then
70963: LD_VAR 0 5
70967: NOT
70968: IFFALSE 70972
// exit ;
70970: GO 71038
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
70972: LD_ADDR_VAR 0 1
70976: PUSH
70977: LD_VAR 0 1
70981: PPUSH
70982: LD_VAR 0 2
70986: PPUSH
70987: LD_VAR 0 1
70991: PUSH
70992: LD_VAR 0 3
70996: ARRAY
70997: PPUSH
70998: CALL_OW 1
71002: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
71003: LD_ADDR_VAR 0 1
71007: PUSH
71008: LD_VAR 0 1
71012: PPUSH
71013: LD_VAR 0 3
71017: PPUSH
71018: LD_VAR 0 5
71022: PPUSH
71023: CALL_OW 1
71027: ST_TO_ADDR
// result := list ;
71028: LD_ADDR_VAR 0 4
71032: PUSH
71033: LD_VAR 0 1
71037: ST_TO_ADDR
// end ;
71038: LD_VAR 0 4
71042: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
71043: LD_INT 0
71045: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
71046: LD_ADDR_VAR 0 5
71050: PUSH
71051: LD_VAR 0 1
71055: PPUSH
71056: CALL_OW 250
71060: PPUSH
71061: LD_VAR 0 1
71065: PPUSH
71066: CALL_OW 251
71070: PPUSH
71071: LD_VAR 0 2
71075: PPUSH
71076: LD_VAR 0 3
71080: PPUSH
71081: LD_VAR 0 4
71085: PPUSH
71086: CALL 71096 0 5
71090: ST_TO_ADDR
// end ;
71091: LD_VAR 0 5
71095: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
71096: LD_INT 0
71098: PPUSH
71099: PPUSH
71100: PPUSH
71101: PPUSH
// if not list then
71102: LD_VAR 0 3
71106: NOT
71107: IFFALSE 71111
// exit ;
71109: GO 71499
// result := [ ] ;
71111: LD_ADDR_VAR 0 6
71115: PUSH
71116: EMPTY
71117: ST_TO_ADDR
// for i in list do
71118: LD_ADDR_VAR 0 7
71122: PUSH
71123: LD_VAR 0 3
71127: PUSH
71128: FOR_IN
71129: IFFALSE 71331
// begin tmp := GetDistUnitXY ( i , x , y ) ;
71131: LD_ADDR_VAR 0 9
71135: PUSH
71136: LD_VAR 0 7
71140: PPUSH
71141: LD_VAR 0 1
71145: PPUSH
71146: LD_VAR 0 2
71150: PPUSH
71151: CALL_OW 297
71155: ST_TO_ADDR
// if not result then
71156: LD_VAR 0 6
71160: NOT
71161: IFFALSE 71187
// result := [ [ i , tmp ] ] else
71163: LD_ADDR_VAR 0 6
71167: PUSH
71168: LD_VAR 0 7
71172: PUSH
71173: LD_VAR 0 9
71177: PUSH
71178: EMPTY
71179: LIST
71180: LIST
71181: PUSH
71182: EMPTY
71183: LIST
71184: ST_TO_ADDR
71185: GO 71329
// begin if result [ result ] [ 2 ] < tmp then
71187: LD_VAR 0 6
71191: PUSH
71192: LD_VAR 0 6
71196: ARRAY
71197: PUSH
71198: LD_INT 2
71200: ARRAY
71201: PUSH
71202: LD_VAR 0 9
71206: LESS
71207: IFFALSE 71249
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
71209: LD_ADDR_VAR 0 6
71213: PUSH
71214: LD_VAR 0 6
71218: PPUSH
71219: LD_VAR 0 6
71223: PUSH
71224: LD_INT 1
71226: PLUS
71227: PPUSH
71228: LD_VAR 0 7
71232: PUSH
71233: LD_VAR 0 9
71237: PUSH
71238: EMPTY
71239: LIST
71240: LIST
71241: PPUSH
71242: CALL_OW 2
71246: ST_TO_ADDR
71247: GO 71329
// for j = 1 to result do
71249: LD_ADDR_VAR 0 8
71253: PUSH
71254: DOUBLE
71255: LD_INT 1
71257: DEC
71258: ST_TO_ADDR
71259: LD_VAR 0 6
71263: PUSH
71264: FOR_TO
71265: IFFALSE 71327
// begin if tmp < result [ j ] [ 2 ] then
71267: LD_VAR 0 9
71271: PUSH
71272: LD_VAR 0 6
71276: PUSH
71277: LD_VAR 0 8
71281: ARRAY
71282: PUSH
71283: LD_INT 2
71285: ARRAY
71286: LESS
71287: IFFALSE 71325
// begin result := Insert ( result , j , [ i , tmp ] ) ;
71289: LD_ADDR_VAR 0 6
71293: PUSH
71294: LD_VAR 0 6
71298: PPUSH
71299: LD_VAR 0 8
71303: PPUSH
71304: LD_VAR 0 7
71308: PUSH
71309: LD_VAR 0 9
71313: PUSH
71314: EMPTY
71315: LIST
71316: LIST
71317: PPUSH
71318: CALL_OW 2
71322: ST_TO_ADDR
// break ;
71323: GO 71327
// end ; end ;
71325: GO 71264
71327: POP
71328: POP
// end ; end ;
71329: GO 71128
71331: POP
71332: POP
// if result and not asc then
71333: LD_VAR 0 6
71337: PUSH
71338: LD_VAR 0 4
71342: NOT
71343: AND
71344: IFFALSE 71419
// begin tmp := result ;
71346: LD_ADDR_VAR 0 9
71350: PUSH
71351: LD_VAR 0 6
71355: ST_TO_ADDR
// for i = tmp downto 1 do
71356: LD_ADDR_VAR 0 7
71360: PUSH
71361: DOUBLE
71362: LD_VAR 0 9
71366: INC
71367: ST_TO_ADDR
71368: LD_INT 1
71370: PUSH
71371: FOR_DOWNTO
71372: IFFALSE 71417
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
71374: LD_ADDR_VAR 0 6
71378: PUSH
71379: LD_VAR 0 6
71383: PPUSH
71384: LD_VAR 0 9
71388: PUSH
71389: LD_VAR 0 7
71393: MINUS
71394: PUSH
71395: LD_INT 1
71397: PLUS
71398: PPUSH
71399: LD_VAR 0 9
71403: PUSH
71404: LD_VAR 0 7
71408: ARRAY
71409: PPUSH
71410: CALL_OW 1
71414: ST_TO_ADDR
71415: GO 71371
71417: POP
71418: POP
// end ; tmp := [ ] ;
71419: LD_ADDR_VAR 0 9
71423: PUSH
71424: EMPTY
71425: ST_TO_ADDR
// if mode then
71426: LD_VAR 0 5
71430: IFFALSE 71499
// begin for i = 1 to result do
71432: LD_ADDR_VAR 0 7
71436: PUSH
71437: DOUBLE
71438: LD_INT 1
71440: DEC
71441: ST_TO_ADDR
71442: LD_VAR 0 6
71446: PUSH
71447: FOR_TO
71448: IFFALSE 71487
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
71450: LD_ADDR_VAR 0 9
71454: PUSH
71455: LD_VAR 0 9
71459: PPUSH
71460: LD_VAR 0 7
71464: PPUSH
71465: LD_VAR 0 6
71469: PUSH
71470: LD_VAR 0 7
71474: ARRAY
71475: PUSH
71476: LD_INT 1
71478: ARRAY
71479: PPUSH
71480: CALL_OW 1
71484: ST_TO_ADDR
71485: GO 71447
71487: POP
71488: POP
// result := tmp ;
71489: LD_ADDR_VAR 0 6
71493: PUSH
71494: LD_VAR 0 9
71498: ST_TO_ADDR
// end ; end ;
71499: LD_VAR 0 6
71503: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
71504: LD_INT 0
71506: PPUSH
71507: PPUSH
71508: PPUSH
71509: PPUSH
71510: PPUSH
71511: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
71512: LD_ADDR_VAR 0 5
71516: PUSH
71517: LD_INT 0
71519: PUSH
71520: LD_INT 0
71522: PUSH
71523: LD_INT 0
71525: PUSH
71526: EMPTY
71527: PUSH
71528: EMPTY
71529: LIST
71530: LIST
71531: LIST
71532: LIST
71533: ST_TO_ADDR
// if not x or not y then
71534: LD_VAR 0 2
71538: NOT
71539: PUSH
71540: LD_VAR 0 3
71544: NOT
71545: OR
71546: IFFALSE 71550
// exit ;
71548: GO 73202
// if not range then
71550: LD_VAR 0 4
71554: NOT
71555: IFFALSE 71565
// range := 10 ;
71557: LD_ADDR_VAR 0 4
71561: PUSH
71562: LD_INT 10
71564: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71565: LD_ADDR_VAR 0 8
71569: PUSH
71570: LD_INT 81
71572: PUSH
71573: LD_VAR 0 1
71577: PUSH
71578: EMPTY
71579: LIST
71580: LIST
71581: PUSH
71582: LD_INT 92
71584: PUSH
71585: LD_VAR 0 2
71589: PUSH
71590: LD_VAR 0 3
71594: PUSH
71595: LD_VAR 0 4
71599: PUSH
71600: EMPTY
71601: LIST
71602: LIST
71603: LIST
71604: LIST
71605: PUSH
71606: LD_INT 3
71608: PUSH
71609: LD_INT 21
71611: PUSH
71612: LD_INT 3
71614: PUSH
71615: EMPTY
71616: LIST
71617: LIST
71618: PUSH
71619: EMPTY
71620: LIST
71621: LIST
71622: PUSH
71623: EMPTY
71624: LIST
71625: LIST
71626: LIST
71627: PPUSH
71628: CALL_OW 69
71632: ST_TO_ADDR
// if not tmp then
71633: LD_VAR 0 8
71637: NOT
71638: IFFALSE 71642
// exit ;
71640: GO 73202
// for i in tmp do
71642: LD_ADDR_VAR 0 6
71646: PUSH
71647: LD_VAR 0 8
71651: PUSH
71652: FOR_IN
71653: IFFALSE 73177
// begin points := [ 0 , 0 , 0 ] ;
71655: LD_ADDR_VAR 0 9
71659: PUSH
71660: LD_INT 0
71662: PUSH
71663: LD_INT 0
71665: PUSH
71666: LD_INT 0
71668: PUSH
71669: EMPTY
71670: LIST
71671: LIST
71672: LIST
71673: ST_TO_ADDR
// bpoints := 1 ;
71674: LD_ADDR_VAR 0 10
71678: PUSH
71679: LD_INT 1
71681: ST_TO_ADDR
// case GetType ( i ) of unit_human :
71682: LD_VAR 0 6
71686: PPUSH
71687: CALL_OW 247
71691: PUSH
71692: LD_INT 1
71694: DOUBLE
71695: EQUAL
71696: IFTRUE 71700
71698: GO 72278
71700: POP
// begin if GetClass ( i ) = 1 then
71701: LD_VAR 0 6
71705: PPUSH
71706: CALL_OW 257
71710: PUSH
71711: LD_INT 1
71713: EQUAL
71714: IFFALSE 71735
// points := [ 10 , 5 , 3 ] ;
71716: LD_ADDR_VAR 0 9
71720: PUSH
71721: LD_INT 10
71723: PUSH
71724: LD_INT 5
71726: PUSH
71727: LD_INT 3
71729: PUSH
71730: EMPTY
71731: LIST
71732: LIST
71733: LIST
71734: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
71735: LD_VAR 0 6
71739: PPUSH
71740: CALL_OW 257
71744: PUSH
71745: LD_INT 2
71747: PUSH
71748: LD_INT 3
71750: PUSH
71751: LD_INT 4
71753: PUSH
71754: EMPTY
71755: LIST
71756: LIST
71757: LIST
71758: IN
71759: IFFALSE 71780
// points := [ 3 , 2 , 1 ] ;
71761: LD_ADDR_VAR 0 9
71765: PUSH
71766: LD_INT 3
71768: PUSH
71769: LD_INT 2
71771: PUSH
71772: LD_INT 1
71774: PUSH
71775: EMPTY
71776: LIST
71777: LIST
71778: LIST
71779: ST_TO_ADDR
// if GetClass ( i ) = 5 then
71780: LD_VAR 0 6
71784: PPUSH
71785: CALL_OW 257
71789: PUSH
71790: LD_INT 5
71792: EQUAL
71793: IFFALSE 71814
// points := [ 130 , 5 , 2 ] ;
71795: LD_ADDR_VAR 0 9
71799: PUSH
71800: LD_INT 130
71802: PUSH
71803: LD_INT 5
71805: PUSH
71806: LD_INT 2
71808: PUSH
71809: EMPTY
71810: LIST
71811: LIST
71812: LIST
71813: ST_TO_ADDR
// if GetClass ( i ) = 8 then
71814: LD_VAR 0 6
71818: PPUSH
71819: CALL_OW 257
71823: PUSH
71824: LD_INT 8
71826: EQUAL
71827: IFFALSE 71848
// points := [ 35 , 35 , 30 ] ;
71829: LD_ADDR_VAR 0 9
71833: PUSH
71834: LD_INT 35
71836: PUSH
71837: LD_INT 35
71839: PUSH
71840: LD_INT 30
71842: PUSH
71843: EMPTY
71844: LIST
71845: LIST
71846: LIST
71847: ST_TO_ADDR
// if GetClass ( i ) = 9 then
71848: LD_VAR 0 6
71852: PPUSH
71853: CALL_OW 257
71857: PUSH
71858: LD_INT 9
71860: EQUAL
71861: IFFALSE 71882
// points := [ 20 , 55 , 40 ] ;
71863: LD_ADDR_VAR 0 9
71867: PUSH
71868: LD_INT 20
71870: PUSH
71871: LD_INT 55
71873: PUSH
71874: LD_INT 40
71876: PUSH
71877: EMPTY
71878: LIST
71879: LIST
71880: LIST
71881: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
71882: LD_VAR 0 6
71886: PPUSH
71887: CALL_OW 257
71891: PUSH
71892: LD_INT 12
71894: PUSH
71895: LD_INT 16
71897: PUSH
71898: EMPTY
71899: LIST
71900: LIST
71901: IN
71902: IFFALSE 71923
// points := [ 5 , 3 , 2 ] ;
71904: LD_ADDR_VAR 0 9
71908: PUSH
71909: LD_INT 5
71911: PUSH
71912: LD_INT 3
71914: PUSH
71915: LD_INT 2
71917: PUSH
71918: EMPTY
71919: LIST
71920: LIST
71921: LIST
71922: ST_TO_ADDR
// if GetClass ( i ) = 17 then
71923: LD_VAR 0 6
71927: PPUSH
71928: CALL_OW 257
71932: PUSH
71933: LD_INT 17
71935: EQUAL
71936: IFFALSE 71957
// points := [ 100 , 50 , 75 ] ;
71938: LD_ADDR_VAR 0 9
71942: PUSH
71943: LD_INT 100
71945: PUSH
71946: LD_INT 50
71948: PUSH
71949: LD_INT 75
71951: PUSH
71952: EMPTY
71953: LIST
71954: LIST
71955: LIST
71956: ST_TO_ADDR
// if GetClass ( i ) = 15 then
71957: LD_VAR 0 6
71961: PPUSH
71962: CALL_OW 257
71966: PUSH
71967: LD_INT 15
71969: EQUAL
71970: IFFALSE 71991
// points := [ 10 , 5 , 3 ] ;
71972: LD_ADDR_VAR 0 9
71976: PUSH
71977: LD_INT 10
71979: PUSH
71980: LD_INT 5
71982: PUSH
71983: LD_INT 3
71985: PUSH
71986: EMPTY
71987: LIST
71988: LIST
71989: LIST
71990: ST_TO_ADDR
// if GetClass ( i ) = 14 then
71991: LD_VAR 0 6
71995: PPUSH
71996: CALL_OW 257
72000: PUSH
72001: LD_INT 14
72003: EQUAL
72004: IFFALSE 72025
// points := [ 10 , 0 , 0 ] ;
72006: LD_ADDR_VAR 0 9
72010: PUSH
72011: LD_INT 10
72013: PUSH
72014: LD_INT 0
72016: PUSH
72017: LD_INT 0
72019: PUSH
72020: EMPTY
72021: LIST
72022: LIST
72023: LIST
72024: ST_TO_ADDR
// if GetClass ( i ) = 11 then
72025: LD_VAR 0 6
72029: PPUSH
72030: CALL_OW 257
72034: PUSH
72035: LD_INT 11
72037: EQUAL
72038: IFFALSE 72059
// points := [ 30 , 10 , 5 ] ;
72040: LD_ADDR_VAR 0 9
72044: PUSH
72045: LD_INT 30
72047: PUSH
72048: LD_INT 10
72050: PUSH
72051: LD_INT 5
72053: PUSH
72054: EMPTY
72055: LIST
72056: LIST
72057: LIST
72058: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
72059: LD_VAR 0 1
72063: PPUSH
72064: LD_INT 5
72066: PPUSH
72067: CALL_OW 321
72071: PUSH
72072: LD_INT 2
72074: EQUAL
72075: IFFALSE 72092
// bpoints := bpoints * 1.8 ;
72077: LD_ADDR_VAR 0 10
72081: PUSH
72082: LD_VAR 0 10
72086: PUSH
72087: LD_REAL  1.80000000000000E+0000
72090: MUL
72091: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
72092: LD_VAR 0 6
72096: PPUSH
72097: CALL_OW 257
72101: PUSH
72102: LD_INT 1
72104: PUSH
72105: LD_INT 2
72107: PUSH
72108: LD_INT 3
72110: PUSH
72111: LD_INT 4
72113: PUSH
72114: EMPTY
72115: LIST
72116: LIST
72117: LIST
72118: LIST
72119: IN
72120: PUSH
72121: LD_VAR 0 1
72125: PPUSH
72126: LD_INT 51
72128: PPUSH
72129: CALL_OW 321
72133: PUSH
72134: LD_INT 2
72136: EQUAL
72137: AND
72138: IFFALSE 72155
// bpoints := bpoints * 1.2 ;
72140: LD_ADDR_VAR 0 10
72144: PUSH
72145: LD_VAR 0 10
72149: PUSH
72150: LD_REAL  1.20000000000000E+0000
72153: MUL
72154: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
72155: LD_VAR 0 6
72159: PPUSH
72160: CALL_OW 257
72164: PUSH
72165: LD_INT 5
72167: PUSH
72168: LD_INT 7
72170: PUSH
72171: LD_INT 9
72173: PUSH
72174: EMPTY
72175: LIST
72176: LIST
72177: LIST
72178: IN
72179: PUSH
72180: LD_VAR 0 1
72184: PPUSH
72185: LD_INT 52
72187: PPUSH
72188: CALL_OW 321
72192: PUSH
72193: LD_INT 2
72195: EQUAL
72196: AND
72197: IFFALSE 72214
// bpoints := bpoints * 1.5 ;
72199: LD_ADDR_VAR 0 10
72203: PUSH
72204: LD_VAR 0 10
72208: PUSH
72209: LD_REAL  1.50000000000000E+0000
72212: MUL
72213: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
72214: LD_VAR 0 1
72218: PPUSH
72219: LD_INT 66
72221: PPUSH
72222: CALL_OW 321
72226: PUSH
72227: LD_INT 2
72229: EQUAL
72230: IFFALSE 72247
// bpoints := bpoints * 1.1 ;
72232: LD_ADDR_VAR 0 10
72236: PUSH
72237: LD_VAR 0 10
72241: PUSH
72242: LD_REAL  1.10000000000000E+0000
72245: MUL
72246: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
72247: LD_ADDR_VAR 0 10
72251: PUSH
72252: LD_VAR 0 10
72256: PUSH
72257: LD_VAR 0 6
72261: PPUSH
72262: LD_INT 1
72264: PPUSH
72265: CALL_OW 259
72269: PUSH
72270: LD_REAL  1.15000000000000E+0000
72273: MUL
72274: MUL
72275: ST_TO_ADDR
// end ; unit_vehicle :
72276: GO 73106
72278: LD_INT 2
72280: DOUBLE
72281: EQUAL
72282: IFTRUE 72286
72284: GO 73094
72286: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
72287: LD_VAR 0 6
72291: PPUSH
72292: CALL_OW 264
72296: PUSH
72297: LD_INT 2
72299: PUSH
72300: LD_INT 42
72302: PUSH
72303: LD_INT 24
72305: PUSH
72306: EMPTY
72307: LIST
72308: LIST
72309: LIST
72310: IN
72311: IFFALSE 72332
// points := [ 25 , 5 , 3 ] ;
72313: LD_ADDR_VAR 0 9
72317: PUSH
72318: LD_INT 25
72320: PUSH
72321: LD_INT 5
72323: PUSH
72324: LD_INT 3
72326: PUSH
72327: EMPTY
72328: LIST
72329: LIST
72330: LIST
72331: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
72332: LD_VAR 0 6
72336: PPUSH
72337: CALL_OW 264
72341: PUSH
72342: LD_INT 4
72344: PUSH
72345: LD_INT 43
72347: PUSH
72348: LD_INT 25
72350: PUSH
72351: EMPTY
72352: LIST
72353: LIST
72354: LIST
72355: IN
72356: IFFALSE 72377
// points := [ 40 , 15 , 5 ] ;
72358: LD_ADDR_VAR 0 9
72362: PUSH
72363: LD_INT 40
72365: PUSH
72366: LD_INT 15
72368: PUSH
72369: LD_INT 5
72371: PUSH
72372: EMPTY
72373: LIST
72374: LIST
72375: LIST
72376: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
72377: LD_VAR 0 6
72381: PPUSH
72382: CALL_OW 264
72386: PUSH
72387: LD_INT 3
72389: PUSH
72390: LD_INT 23
72392: PUSH
72393: EMPTY
72394: LIST
72395: LIST
72396: IN
72397: IFFALSE 72418
// points := [ 7 , 25 , 8 ] ;
72399: LD_ADDR_VAR 0 9
72403: PUSH
72404: LD_INT 7
72406: PUSH
72407: LD_INT 25
72409: PUSH
72410: LD_INT 8
72412: PUSH
72413: EMPTY
72414: LIST
72415: LIST
72416: LIST
72417: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
72418: LD_VAR 0 6
72422: PPUSH
72423: CALL_OW 264
72427: PUSH
72428: LD_INT 5
72430: PUSH
72431: LD_INT 27
72433: PUSH
72434: LD_INT 44
72436: PUSH
72437: EMPTY
72438: LIST
72439: LIST
72440: LIST
72441: IN
72442: IFFALSE 72463
// points := [ 14 , 50 , 16 ] ;
72444: LD_ADDR_VAR 0 9
72448: PUSH
72449: LD_INT 14
72451: PUSH
72452: LD_INT 50
72454: PUSH
72455: LD_INT 16
72457: PUSH
72458: EMPTY
72459: LIST
72460: LIST
72461: LIST
72462: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
72463: LD_VAR 0 6
72467: PPUSH
72468: CALL_OW 264
72472: PUSH
72473: LD_INT 6
72475: PUSH
72476: LD_INT 46
72478: PUSH
72479: EMPTY
72480: LIST
72481: LIST
72482: IN
72483: IFFALSE 72504
// points := [ 32 , 120 , 70 ] ;
72485: LD_ADDR_VAR 0 9
72489: PUSH
72490: LD_INT 32
72492: PUSH
72493: LD_INT 120
72495: PUSH
72496: LD_INT 70
72498: PUSH
72499: EMPTY
72500: LIST
72501: LIST
72502: LIST
72503: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
72504: LD_VAR 0 6
72508: PPUSH
72509: CALL_OW 264
72513: PUSH
72514: LD_INT 7
72516: PUSH
72517: LD_INT 28
72519: PUSH
72520: LD_INT 45
72522: PUSH
72523: LD_EXP 100
72527: PUSH
72528: EMPTY
72529: LIST
72530: LIST
72531: LIST
72532: LIST
72533: IN
72534: IFFALSE 72555
// points := [ 35 , 20 , 45 ] ;
72536: LD_ADDR_VAR 0 9
72540: PUSH
72541: LD_INT 35
72543: PUSH
72544: LD_INT 20
72546: PUSH
72547: LD_INT 45
72549: PUSH
72550: EMPTY
72551: LIST
72552: LIST
72553: LIST
72554: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
72555: LD_VAR 0 6
72559: PPUSH
72560: CALL_OW 264
72564: PUSH
72565: LD_INT 47
72567: PUSH
72568: EMPTY
72569: LIST
72570: IN
72571: IFFALSE 72592
// points := [ 67 , 45 , 75 ] ;
72573: LD_ADDR_VAR 0 9
72577: PUSH
72578: LD_INT 67
72580: PUSH
72581: LD_INT 45
72583: PUSH
72584: LD_INT 75
72586: PUSH
72587: EMPTY
72588: LIST
72589: LIST
72590: LIST
72591: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
72592: LD_VAR 0 6
72596: PPUSH
72597: CALL_OW 264
72601: PUSH
72602: LD_INT 26
72604: PUSH
72605: EMPTY
72606: LIST
72607: IN
72608: IFFALSE 72629
// points := [ 120 , 30 , 80 ] ;
72610: LD_ADDR_VAR 0 9
72614: PUSH
72615: LD_INT 120
72617: PUSH
72618: LD_INT 30
72620: PUSH
72621: LD_INT 80
72623: PUSH
72624: EMPTY
72625: LIST
72626: LIST
72627: LIST
72628: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
72629: LD_VAR 0 6
72633: PPUSH
72634: CALL_OW 264
72638: PUSH
72639: LD_INT 22
72641: PUSH
72642: EMPTY
72643: LIST
72644: IN
72645: IFFALSE 72666
// points := [ 40 , 1 , 1 ] ;
72647: LD_ADDR_VAR 0 9
72651: PUSH
72652: LD_INT 40
72654: PUSH
72655: LD_INT 1
72657: PUSH
72658: LD_INT 1
72660: PUSH
72661: EMPTY
72662: LIST
72663: LIST
72664: LIST
72665: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
72666: LD_VAR 0 6
72670: PPUSH
72671: CALL_OW 264
72675: PUSH
72676: LD_INT 29
72678: PUSH
72679: EMPTY
72680: LIST
72681: IN
72682: IFFALSE 72703
// points := [ 70 , 200 , 400 ] ;
72684: LD_ADDR_VAR 0 9
72688: PUSH
72689: LD_INT 70
72691: PUSH
72692: LD_INT 200
72694: PUSH
72695: LD_INT 400
72697: PUSH
72698: EMPTY
72699: LIST
72700: LIST
72701: LIST
72702: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
72703: LD_VAR 0 6
72707: PPUSH
72708: CALL_OW 264
72712: PUSH
72713: LD_INT 14
72715: PUSH
72716: LD_INT 53
72718: PUSH
72719: EMPTY
72720: LIST
72721: LIST
72722: IN
72723: IFFALSE 72744
// points := [ 40 , 10 , 20 ] ;
72725: LD_ADDR_VAR 0 9
72729: PUSH
72730: LD_INT 40
72732: PUSH
72733: LD_INT 10
72735: PUSH
72736: LD_INT 20
72738: PUSH
72739: EMPTY
72740: LIST
72741: LIST
72742: LIST
72743: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
72744: LD_VAR 0 6
72748: PPUSH
72749: CALL_OW 264
72753: PUSH
72754: LD_INT 9
72756: PUSH
72757: EMPTY
72758: LIST
72759: IN
72760: IFFALSE 72781
// points := [ 5 , 70 , 20 ] ;
72762: LD_ADDR_VAR 0 9
72766: PUSH
72767: LD_INT 5
72769: PUSH
72770: LD_INT 70
72772: PUSH
72773: LD_INT 20
72775: PUSH
72776: EMPTY
72777: LIST
72778: LIST
72779: LIST
72780: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
72781: LD_VAR 0 6
72785: PPUSH
72786: CALL_OW 264
72790: PUSH
72791: LD_INT 10
72793: PUSH
72794: EMPTY
72795: LIST
72796: IN
72797: IFFALSE 72818
// points := [ 35 , 110 , 70 ] ;
72799: LD_ADDR_VAR 0 9
72803: PUSH
72804: LD_INT 35
72806: PUSH
72807: LD_INT 110
72809: PUSH
72810: LD_INT 70
72812: PUSH
72813: EMPTY
72814: LIST
72815: LIST
72816: LIST
72817: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
72818: LD_VAR 0 6
72822: PPUSH
72823: CALL_OW 265
72827: PUSH
72828: LD_INT 25
72830: EQUAL
72831: IFFALSE 72852
// points := [ 80 , 65 , 100 ] ;
72833: LD_ADDR_VAR 0 9
72837: PUSH
72838: LD_INT 80
72840: PUSH
72841: LD_INT 65
72843: PUSH
72844: LD_INT 100
72846: PUSH
72847: EMPTY
72848: LIST
72849: LIST
72850: LIST
72851: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
72852: LD_VAR 0 6
72856: PPUSH
72857: CALL_OW 263
72861: PUSH
72862: LD_INT 1
72864: EQUAL
72865: IFFALSE 72900
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
72867: LD_ADDR_VAR 0 10
72871: PUSH
72872: LD_VAR 0 10
72876: PUSH
72877: LD_VAR 0 6
72881: PPUSH
72882: CALL_OW 311
72886: PPUSH
72887: LD_INT 3
72889: PPUSH
72890: CALL_OW 259
72894: PUSH
72895: LD_INT 4
72897: MUL
72898: MUL
72899: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
72900: LD_VAR 0 6
72904: PPUSH
72905: CALL_OW 263
72909: PUSH
72910: LD_INT 2
72912: EQUAL
72913: IFFALSE 72964
// begin j := IsControledBy ( i ) ;
72915: LD_ADDR_VAR 0 7
72919: PUSH
72920: LD_VAR 0 6
72924: PPUSH
72925: CALL_OW 312
72929: ST_TO_ADDR
// if j then
72930: LD_VAR 0 7
72934: IFFALSE 72964
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
72936: LD_ADDR_VAR 0 10
72940: PUSH
72941: LD_VAR 0 10
72945: PUSH
72946: LD_VAR 0 7
72950: PPUSH
72951: LD_INT 3
72953: PPUSH
72954: CALL_OW 259
72958: PUSH
72959: LD_INT 3
72961: MUL
72962: MUL
72963: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
72964: LD_VAR 0 6
72968: PPUSH
72969: CALL_OW 264
72973: PUSH
72974: LD_INT 5
72976: PUSH
72977: LD_INT 6
72979: PUSH
72980: LD_INT 46
72982: PUSH
72983: LD_INT 44
72985: PUSH
72986: LD_INT 47
72988: PUSH
72989: LD_INT 45
72991: PUSH
72992: LD_INT 28
72994: PUSH
72995: LD_INT 7
72997: PUSH
72998: LD_INT 27
73000: PUSH
73001: LD_INT 29
73003: PUSH
73004: EMPTY
73005: LIST
73006: LIST
73007: LIST
73008: LIST
73009: LIST
73010: LIST
73011: LIST
73012: LIST
73013: LIST
73014: LIST
73015: IN
73016: PUSH
73017: LD_VAR 0 1
73021: PPUSH
73022: LD_INT 52
73024: PPUSH
73025: CALL_OW 321
73029: PUSH
73030: LD_INT 2
73032: EQUAL
73033: AND
73034: IFFALSE 73051
// bpoints := bpoints * 1.2 ;
73036: LD_ADDR_VAR 0 10
73040: PUSH
73041: LD_VAR 0 10
73045: PUSH
73046: LD_REAL  1.20000000000000E+0000
73049: MUL
73050: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
73051: LD_VAR 0 6
73055: PPUSH
73056: CALL_OW 264
73060: PUSH
73061: LD_INT 6
73063: PUSH
73064: LD_INT 46
73066: PUSH
73067: LD_INT 47
73069: PUSH
73070: EMPTY
73071: LIST
73072: LIST
73073: LIST
73074: IN
73075: IFFALSE 73092
// bpoints := bpoints * 1.2 ;
73077: LD_ADDR_VAR 0 10
73081: PUSH
73082: LD_VAR 0 10
73086: PUSH
73087: LD_REAL  1.20000000000000E+0000
73090: MUL
73091: ST_TO_ADDR
// end ; unit_building :
73092: GO 73106
73094: LD_INT 3
73096: DOUBLE
73097: EQUAL
73098: IFTRUE 73102
73100: GO 73105
73102: POP
// ; end ;
73103: GO 73106
73105: POP
// for j = 1 to 3 do
73106: LD_ADDR_VAR 0 7
73110: PUSH
73111: DOUBLE
73112: LD_INT 1
73114: DEC
73115: ST_TO_ADDR
73116: LD_INT 3
73118: PUSH
73119: FOR_TO
73120: IFFALSE 73173
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
73122: LD_ADDR_VAR 0 5
73126: PUSH
73127: LD_VAR 0 5
73131: PPUSH
73132: LD_VAR 0 7
73136: PPUSH
73137: LD_VAR 0 5
73141: PUSH
73142: LD_VAR 0 7
73146: ARRAY
73147: PUSH
73148: LD_VAR 0 9
73152: PUSH
73153: LD_VAR 0 7
73157: ARRAY
73158: PUSH
73159: LD_VAR 0 10
73163: MUL
73164: PLUS
73165: PPUSH
73166: CALL_OW 1
73170: ST_TO_ADDR
73171: GO 73119
73173: POP
73174: POP
// end ;
73175: GO 71652
73177: POP
73178: POP
// result := Replace ( result , 4 , tmp ) ;
73179: LD_ADDR_VAR 0 5
73183: PUSH
73184: LD_VAR 0 5
73188: PPUSH
73189: LD_INT 4
73191: PPUSH
73192: LD_VAR 0 8
73196: PPUSH
73197: CALL_OW 1
73201: ST_TO_ADDR
// end ;
73202: LD_VAR 0 5
73206: RET
// export function DangerAtRange ( unit , range ) ; begin
73207: LD_INT 0
73209: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
73210: LD_ADDR_VAR 0 3
73214: PUSH
73215: LD_VAR 0 1
73219: PPUSH
73220: CALL_OW 255
73224: PPUSH
73225: LD_VAR 0 1
73229: PPUSH
73230: CALL_OW 250
73234: PPUSH
73235: LD_VAR 0 1
73239: PPUSH
73240: CALL_OW 251
73244: PPUSH
73245: LD_VAR 0 2
73249: PPUSH
73250: CALL 71504 0 4
73254: ST_TO_ADDR
// end ;
73255: LD_VAR 0 3
73259: RET
// export function DangerInArea ( side , area ) ; begin
73260: LD_INT 0
73262: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
73263: LD_ADDR_VAR 0 3
73267: PUSH
73268: LD_VAR 0 2
73272: PPUSH
73273: LD_INT 81
73275: PUSH
73276: LD_VAR 0 1
73280: PUSH
73281: EMPTY
73282: LIST
73283: LIST
73284: PPUSH
73285: CALL_OW 70
73289: ST_TO_ADDR
// end ;
73290: LD_VAR 0 3
73294: RET
// export function IsExtension ( b ) ; begin
73295: LD_INT 0
73297: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
73298: LD_ADDR_VAR 0 2
73302: PUSH
73303: LD_VAR 0 1
73307: PUSH
73308: LD_INT 23
73310: PUSH
73311: LD_INT 20
73313: PUSH
73314: LD_INT 22
73316: PUSH
73317: LD_INT 17
73319: PUSH
73320: LD_INT 24
73322: PUSH
73323: LD_INT 21
73325: PUSH
73326: LD_INT 19
73328: PUSH
73329: LD_INT 16
73331: PUSH
73332: LD_INT 25
73334: PUSH
73335: LD_INT 18
73337: PUSH
73338: EMPTY
73339: LIST
73340: LIST
73341: LIST
73342: LIST
73343: LIST
73344: LIST
73345: LIST
73346: LIST
73347: LIST
73348: LIST
73349: IN
73350: ST_TO_ADDR
// end ;
73351: LD_VAR 0 2
73355: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
73356: LD_INT 0
73358: PPUSH
73359: PPUSH
73360: PPUSH
// result := [ ] ;
73361: LD_ADDR_VAR 0 4
73365: PUSH
73366: EMPTY
73367: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
73368: LD_ADDR_VAR 0 5
73372: PUSH
73373: LD_VAR 0 2
73377: PPUSH
73378: LD_INT 21
73380: PUSH
73381: LD_INT 3
73383: PUSH
73384: EMPTY
73385: LIST
73386: LIST
73387: PPUSH
73388: CALL_OW 70
73392: ST_TO_ADDR
// if not tmp then
73393: LD_VAR 0 5
73397: NOT
73398: IFFALSE 73402
// exit ;
73400: GO 73466
// if checkLink then
73402: LD_VAR 0 3
73406: IFFALSE 73456
// begin for i in tmp do
73408: LD_ADDR_VAR 0 6
73412: PUSH
73413: LD_VAR 0 5
73417: PUSH
73418: FOR_IN
73419: IFFALSE 73454
// if GetBase ( i ) <> base then
73421: LD_VAR 0 6
73425: PPUSH
73426: CALL_OW 274
73430: PUSH
73431: LD_VAR 0 1
73435: NONEQUAL
73436: IFFALSE 73452
// ComLinkToBase ( base , i ) ;
73438: LD_VAR 0 1
73442: PPUSH
73443: LD_VAR 0 6
73447: PPUSH
73448: CALL_OW 169
73452: GO 73418
73454: POP
73455: POP
// end ; result := tmp ;
73456: LD_ADDR_VAR 0 4
73460: PUSH
73461: LD_VAR 0 5
73465: ST_TO_ADDR
// end ;
73466: LD_VAR 0 4
73470: RET
// export function ComComplete ( units , b ) ; var i ; begin
73471: LD_INT 0
73473: PPUSH
73474: PPUSH
// if not units then
73475: LD_VAR 0 1
73479: NOT
73480: IFFALSE 73484
// exit ;
73482: GO 73574
// for i in units do
73484: LD_ADDR_VAR 0 4
73488: PUSH
73489: LD_VAR 0 1
73493: PUSH
73494: FOR_IN
73495: IFFALSE 73572
// if BuildingStatus ( b ) = bs_build then
73497: LD_VAR 0 2
73501: PPUSH
73502: CALL_OW 461
73506: PUSH
73507: LD_INT 1
73509: EQUAL
73510: IFFALSE 73570
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
73512: LD_VAR 0 4
73516: PPUSH
73517: LD_STRING h
73519: PUSH
73520: LD_VAR 0 2
73524: PPUSH
73525: CALL_OW 250
73529: PUSH
73530: LD_VAR 0 2
73534: PPUSH
73535: CALL_OW 251
73539: PUSH
73540: LD_VAR 0 2
73544: PUSH
73545: LD_INT 0
73547: PUSH
73548: LD_INT 0
73550: PUSH
73551: LD_INT 0
73553: PUSH
73554: EMPTY
73555: LIST
73556: LIST
73557: LIST
73558: LIST
73559: LIST
73560: LIST
73561: LIST
73562: PUSH
73563: EMPTY
73564: LIST
73565: PPUSH
73566: CALL_OW 446
73570: GO 73494
73572: POP
73573: POP
// end ;
73574: LD_VAR 0 3
73578: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
73579: LD_INT 0
73581: PPUSH
73582: PPUSH
73583: PPUSH
73584: PPUSH
73585: PPUSH
73586: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
73587: LD_VAR 0 1
73591: NOT
73592: PUSH
73593: LD_VAR 0 1
73597: PPUSH
73598: CALL_OW 263
73602: PUSH
73603: LD_INT 2
73605: NONEQUAL
73606: OR
73607: IFFALSE 73611
// exit ;
73609: GO 73927
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
73611: LD_ADDR_VAR 0 6
73615: PUSH
73616: LD_INT 22
73618: PUSH
73619: LD_VAR 0 1
73623: PPUSH
73624: CALL_OW 255
73628: PUSH
73629: EMPTY
73630: LIST
73631: LIST
73632: PUSH
73633: LD_INT 2
73635: PUSH
73636: LD_INT 30
73638: PUSH
73639: LD_INT 36
73641: PUSH
73642: EMPTY
73643: LIST
73644: LIST
73645: PUSH
73646: LD_INT 34
73648: PUSH
73649: LD_INT 31
73651: PUSH
73652: EMPTY
73653: LIST
73654: LIST
73655: PUSH
73656: EMPTY
73657: LIST
73658: LIST
73659: LIST
73660: PUSH
73661: EMPTY
73662: LIST
73663: LIST
73664: PPUSH
73665: CALL_OW 69
73669: ST_TO_ADDR
// if not tmp then
73670: LD_VAR 0 6
73674: NOT
73675: IFFALSE 73679
// exit ;
73677: GO 73927
// result := [ ] ;
73679: LD_ADDR_VAR 0 2
73683: PUSH
73684: EMPTY
73685: ST_TO_ADDR
// for i in tmp do
73686: LD_ADDR_VAR 0 3
73690: PUSH
73691: LD_VAR 0 6
73695: PUSH
73696: FOR_IN
73697: IFFALSE 73768
// begin t := UnitsInside ( i ) ;
73699: LD_ADDR_VAR 0 4
73703: PUSH
73704: LD_VAR 0 3
73708: PPUSH
73709: CALL_OW 313
73713: ST_TO_ADDR
// if t then
73714: LD_VAR 0 4
73718: IFFALSE 73766
// for j in t do
73720: LD_ADDR_VAR 0 7
73724: PUSH
73725: LD_VAR 0 4
73729: PUSH
73730: FOR_IN
73731: IFFALSE 73764
// result := Replace ( result , result + 1 , j ) ;
73733: LD_ADDR_VAR 0 2
73737: PUSH
73738: LD_VAR 0 2
73742: PPUSH
73743: LD_VAR 0 2
73747: PUSH
73748: LD_INT 1
73750: PLUS
73751: PPUSH
73752: LD_VAR 0 7
73756: PPUSH
73757: CALL_OW 1
73761: ST_TO_ADDR
73762: GO 73730
73764: POP
73765: POP
// end ;
73766: GO 73696
73768: POP
73769: POP
// if not result then
73770: LD_VAR 0 2
73774: NOT
73775: IFFALSE 73779
// exit ;
73777: GO 73927
// mech := result [ 1 ] ;
73779: LD_ADDR_VAR 0 5
73783: PUSH
73784: LD_VAR 0 2
73788: PUSH
73789: LD_INT 1
73791: ARRAY
73792: ST_TO_ADDR
// if result > 1 then
73793: LD_VAR 0 2
73797: PUSH
73798: LD_INT 1
73800: GREATER
73801: IFFALSE 73913
// begin for i = 2 to result do
73803: LD_ADDR_VAR 0 3
73807: PUSH
73808: DOUBLE
73809: LD_INT 2
73811: DEC
73812: ST_TO_ADDR
73813: LD_VAR 0 2
73817: PUSH
73818: FOR_TO
73819: IFFALSE 73911
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
73821: LD_ADDR_VAR 0 4
73825: PUSH
73826: LD_VAR 0 2
73830: PUSH
73831: LD_VAR 0 3
73835: ARRAY
73836: PPUSH
73837: LD_INT 3
73839: PPUSH
73840: CALL_OW 259
73844: PUSH
73845: LD_VAR 0 2
73849: PUSH
73850: LD_VAR 0 3
73854: ARRAY
73855: PPUSH
73856: CALL_OW 432
73860: MINUS
73861: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
73862: LD_VAR 0 4
73866: PUSH
73867: LD_VAR 0 5
73871: PPUSH
73872: LD_INT 3
73874: PPUSH
73875: CALL_OW 259
73879: PUSH
73880: LD_VAR 0 5
73884: PPUSH
73885: CALL_OW 432
73889: MINUS
73890: GREATEREQUAL
73891: IFFALSE 73909
// mech := result [ i ] ;
73893: LD_ADDR_VAR 0 5
73897: PUSH
73898: LD_VAR 0 2
73902: PUSH
73903: LD_VAR 0 3
73907: ARRAY
73908: ST_TO_ADDR
// end ;
73909: GO 73818
73911: POP
73912: POP
// end ; ComLinkTo ( vehicle , mech ) ;
73913: LD_VAR 0 1
73917: PPUSH
73918: LD_VAR 0 5
73922: PPUSH
73923: CALL_OW 135
// end ;
73927: LD_VAR 0 2
73931: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
73932: LD_INT 0
73934: PPUSH
73935: PPUSH
73936: PPUSH
73937: PPUSH
73938: PPUSH
73939: PPUSH
73940: PPUSH
73941: PPUSH
73942: PPUSH
73943: PPUSH
73944: PPUSH
73945: PPUSH
73946: PPUSH
// result := [ ] ;
73947: LD_ADDR_VAR 0 7
73951: PUSH
73952: EMPTY
73953: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
73954: LD_VAR 0 1
73958: PPUSH
73959: CALL_OW 266
73963: PUSH
73964: LD_INT 0
73966: PUSH
73967: LD_INT 1
73969: PUSH
73970: EMPTY
73971: LIST
73972: LIST
73973: IN
73974: NOT
73975: IFFALSE 73979
// exit ;
73977: GO 75613
// if name then
73979: LD_VAR 0 3
73983: IFFALSE 73999
// SetBName ( base_dep , name ) ;
73985: LD_VAR 0 1
73989: PPUSH
73990: LD_VAR 0 3
73994: PPUSH
73995: CALL_OW 500
// base := GetBase ( base_dep ) ;
73999: LD_ADDR_VAR 0 15
74003: PUSH
74004: LD_VAR 0 1
74008: PPUSH
74009: CALL_OW 274
74013: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
74014: LD_ADDR_VAR 0 16
74018: PUSH
74019: LD_VAR 0 1
74023: PPUSH
74024: CALL_OW 255
74028: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
74029: LD_ADDR_VAR 0 17
74033: PUSH
74034: LD_VAR 0 1
74038: PPUSH
74039: CALL_OW 248
74043: ST_TO_ADDR
// if sources then
74044: LD_VAR 0 5
74048: IFFALSE 74095
// for i = 1 to 3 do
74050: LD_ADDR_VAR 0 8
74054: PUSH
74055: DOUBLE
74056: LD_INT 1
74058: DEC
74059: ST_TO_ADDR
74060: LD_INT 3
74062: PUSH
74063: FOR_TO
74064: IFFALSE 74093
// AddResourceType ( base , i , sources [ i ] ) ;
74066: LD_VAR 0 15
74070: PPUSH
74071: LD_VAR 0 8
74075: PPUSH
74076: LD_VAR 0 5
74080: PUSH
74081: LD_VAR 0 8
74085: ARRAY
74086: PPUSH
74087: CALL_OW 276
74091: GO 74063
74093: POP
74094: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
74095: LD_ADDR_VAR 0 18
74099: PUSH
74100: LD_VAR 0 15
74104: PPUSH
74105: LD_VAR 0 2
74109: PPUSH
74110: LD_INT 1
74112: PPUSH
74113: CALL 73356 0 3
74117: ST_TO_ADDR
// InitHc ;
74118: CALL_OW 19
// InitUc ;
74122: CALL_OW 18
// uc_side := side ;
74126: LD_ADDR_OWVAR 20
74130: PUSH
74131: LD_VAR 0 16
74135: ST_TO_ADDR
// uc_nation := nation ;
74136: LD_ADDR_OWVAR 21
74140: PUSH
74141: LD_VAR 0 17
74145: ST_TO_ADDR
// if buildings then
74146: LD_VAR 0 18
74150: IFFALSE 75472
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
74152: LD_ADDR_VAR 0 19
74156: PUSH
74157: LD_VAR 0 18
74161: PPUSH
74162: LD_INT 2
74164: PUSH
74165: LD_INT 30
74167: PUSH
74168: LD_INT 29
74170: PUSH
74171: EMPTY
74172: LIST
74173: LIST
74174: PUSH
74175: LD_INT 30
74177: PUSH
74178: LD_INT 30
74180: PUSH
74181: EMPTY
74182: LIST
74183: LIST
74184: PUSH
74185: EMPTY
74186: LIST
74187: LIST
74188: LIST
74189: PPUSH
74190: CALL_OW 72
74194: ST_TO_ADDR
// if tmp then
74195: LD_VAR 0 19
74199: IFFALSE 74247
// for i in tmp do
74201: LD_ADDR_VAR 0 8
74205: PUSH
74206: LD_VAR 0 19
74210: PUSH
74211: FOR_IN
74212: IFFALSE 74245
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
74214: LD_VAR 0 8
74218: PPUSH
74219: CALL_OW 250
74223: PPUSH
74224: LD_VAR 0 8
74228: PPUSH
74229: CALL_OW 251
74233: PPUSH
74234: LD_VAR 0 16
74238: PPUSH
74239: CALL_OW 441
74243: GO 74211
74245: POP
74246: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
74247: LD_VAR 0 18
74251: PPUSH
74252: LD_INT 2
74254: PUSH
74255: LD_INT 30
74257: PUSH
74258: LD_INT 32
74260: PUSH
74261: EMPTY
74262: LIST
74263: LIST
74264: PUSH
74265: LD_INT 30
74267: PUSH
74268: LD_INT 33
74270: PUSH
74271: EMPTY
74272: LIST
74273: LIST
74274: PUSH
74275: EMPTY
74276: LIST
74277: LIST
74278: LIST
74279: PPUSH
74280: CALL_OW 72
74284: IFFALSE 74372
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
74286: LD_ADDR_VAR 0 8
74290: PUSH
74291: LD_VAR 0 18
74295: PPUSH
74296: LD_INT 2
74298: PUSH
74299: LD_INT 30
74301: PUSH
74302: LD_INT 32
74304: PUSH
74305: EMPTY
74306: LIST
74307: LIST
74308: PUSH
74309: LD_INT 30
74311: PUSH
74312: LD_INT 33
74314: PUSH
74315: EMPTY
74316: LIST
74317: LIST
74318: PUSH
74319: EMPTY
74320: LIST
74321: LIST
74322: LIST
74323: PPUSH
74324: CALL_OW 72
74328: PUSH
74329: FOR_IN
74330: IFFALSE 74370
// begin if not GetBWeapon ( i ) then
74332: LD_VAR 0 8
74336: PPUSH
74337: CALL_OW 269
74341: NOT
74342: IFFALSE 74368
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
74344: LD_VAR 0 8
74348: PPUSH
74349: LD_VAR 0 8
74353: PPUSH
74354: LD_VAR 0 2
74358: PPUSH
74359: CALL 75618 0 2
74363: PPUSH
74364: CALL_OW 431
// end ;
74368: GO 74329
74370: POP
74371: POP
// end ; for i = 1 to personel do
74372: LD_ADDR_VAR 0 8
74376: PUSH
74377: DOUBLE
74378: LD_INT 1
74380: DEC
74381: ST_TO_ADDR
74382: LD_VAR 0 6
74386: PUSH
74387: FOR_TO
74388: IFFALSE 75452
// begin if i > 4 then
74390: LD_VAR 0 8
74394: PUSH
74395: LD_INT 4
74397: GREATER
74398: IFFALSE 74402
// break ;
74400: GO 75452
// case i of 1 :
74402: LD_VAR 0 8
74406: PUSH
74407: LD_INT 1
74409: DOUBLE
74410: EQUAL
74411: IFTRUE 74415
74413: GO 74495
74415: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
74416: LD_ADDR_VAR 0 12
74420: PUSH
74421: LD_VAR 0 18
74425: PPUSH
74426: LD_INT 22
74428: PUSH
74429: LD_VAR 0 16
74433: PUSH
74434: EMPTY
74435: LIST
74436: LIST
74437: PUSH
74438: LD_INT 58
74440: PUSH
74441: EMPTY
74442: LIST
74443: PUSH
74444: LD_INT 2
74446: PUSH
74447: LD_INT 30
74449: PUSH
74450: LD_INT 32
74452: PUSH
74453: EMPTY
74454: LIST
74455: LIST
74456: PUSH
74457: LD_INT 30
74459: PUSH
74460: LD_INT 4
74462: PUSH
74463: EMPTY
74464: LIST
74465: LIST
74466: PUSH
74467: LD_INT 30
74469: PUSH
74470: LD_INT 5
74472: PUSH
74473: EMPTY
74474: LIST
74475: LIST
74476: PUSH
74477: EMPTY
74478: LIST
74479: LIST
74480: LIST
74481: LIST
74482: PUSH
74483: EMPTY
74484: LIST
74485: LIST
74486: LIST
74487: PPUSH
74488: CALL_OW 72
74492: ST_TO_ADDR
74493: GO 74717
74495: LD_INT 2
74497: DOUBLE
74498: EQUAL
74499: IFTRUE 74503
74501: GO 74565
74503: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
74504: LD_ADDR_VAR 0 12
74508: PUSH
74509: LD_VAR 0 18
74513: PPUSH
74514: LD_INT 22
74516: PUSH
74517: LD_VAR 0 16
74521: PUSH
74522: EMPTY
74523: LIST
74524: LIST
74525: PUSH
74526: LD_INT 2
74528: PUSH
74529: LD_INT 30
74531: PUSH
74532: LD_INT 0
74534: PUSH
74535: EMPTY
74536: LIST
74537: LIST
74538: PUSH
74539: LD_INT 30
74541: PUSH
74542: LD_INT 1
74544: PUSH
74545: EMPTY
74546: LIST
74547: LIST
74548: PUSH
74549: EMPTY
74550: LIST
74551: LIST
74552: LIST
74553: PUSH
74554: EMPTY
74555: LIST
74556: LIST
74557: PPUSH
74558: CALL_OW 72
74562: ST_TO_ADDR
74563: GO 74717
74565: LD_INT 3
74567: DOUBLE
74568: EQUAL
74569: IFTRUE 74573
74571: GO 74635
74573: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
74574: LD_ADDR_VAR 0 12
74578: PUSH
74579: LD_VAR 0 18
74583: PPUSH
74584: LD_INT 22
74586: PUSH
74587: LD_VAR 0 16
74591: PUSH
74592: EMPTY
74593: LIST
74594: LIST
74595: PUSH
74596: LD_INT 2
74598: PUSH
74599: LD_INT 30
74601: PUSH
74602: LD_INT 2
74604: PUSH
74605: EMPTY
74606: LIST
74607: LIST
74608: PUSH
74609: LD_INT 30
74611: PUSH
74612: LD_INT 3
74614: PUSH
74615: EMPTY
74616: LIST
74617: LIST
74618: PUSH
74619: EMPTY
74620: LIST
74621: LIST
74622: LIST
74623: PUSH
74624: EMPTY
74625: LIST
74626: LIST
74627: PPUSH
74628: CALL_OW 72
74632: ST_TO_ADDR
74633: GO 74717
74635: LD_INT 4
74637: DOUBLE
74638: EQUAL
74639: IFTRUE 74643
74641: GO 74716
74643: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
74644: LD_ADDR_VAR 0 12
74648: PUSH
74649: LD_VAR 0 18
74653: PPUSH
74654: LD_INT 22
74656: PUSH
74657: LD_VAR 0 16
74661: PUSH
74662: EMPTY
74663: LIST
74664: LIST
74665: PUSH
74666: LD_INT 2
74668: PUSH
74669: LD_INT 30
74671: PUSH
74672: LD_INT 6
74674: PUSH
74675: EMPTY
74676: LIST
74677: LIST
74678: PUSH
74679: LD_INT 30
74681: PUSH
74682: LD_INT 7
74684: PUSH
74685: EMPTY
74686: LIST
74687: LIST
74688: PUSH
74689: LD_INT 30
74691: PUSH
74692: LD_INT 8
74694: PUSH
74695: EMPTY
74696: LIST
74697: LIST
74698: PUSH
74699: EMPTY
74700: LIST
74701: LIST
74702: LIST
74703: LIST
74704: PUSH
74705: EMPTY
74706: LIST
74707: LIST
74708: PPUSH
74709: CALL_OW 72
74713: ST_TO_ADDR
74714: GO 74717
74716: POP
// if i = 1 then
74717: LD_VAR 0 8
74721: PUSH
74722: LD_INT 1
74724: EQUAL
74725: IFFALSE 74836
// begin tmp := [ ] ;
74727: LD_ADDR_VAR 0 19
74731: PUSH
74732: EMPTY
74733: ST_TO_ADDR
// for j in f do
74734: LD_ADDR_VAR 0 9
74738: PUSH
74739: LD_VAR 0 12
74743: PUSH
74744: FOR_IN
74745: IFFALSE 74818
// if GetBType ( j ) = b_bunker then
74747: LD_VAR 0 9
74751: PPUSH
74752: CALL_OW 266
74756: PUSH
74757: LD_INT 32
74759: EQUAL
74760: IFFALSE 74787
// tmp := Insert ( tmp , 1 , j ) else
74762: LD_ADDR_VAR 0 19
74766: PUSH
74767: LD_VAR 0 19
74771: PPUSH
74772: LD_INT 1
74774: PPUSH
74775: LD_VAR 0 9
74779: PPUSH
74780: CALL_OW 2
74784: ST_TO_ADDR
74785: GO 74816
// tmp := Insert ( tmp , tmp + 1 , j ) ;
74787: LD_ADDR_VAR 0 19
74791: PUSH
74792: LD_VAR 0 19
74796: PPUSH
74797: LD_VAR 0 19
74801: PUSH
74802: LD_INT 1
74804: PLUS
74805: PPUSH
74806: LD_VAR 0 9
74810: PPUSH
74811: CALL_OW 2
74815: ST_TO_ADDR
74816: GO 74744
74818: POP
74819: POP
// if tmp then
74820: LD_VAR 0 19
74824: IFFALSE 74836
// f := tmp ;
74826: LD_ADDR_VAR 0 12
74830: PUSH
74831: LD_VAR 0 19
74835: ST_TO_ADDR
// end ; x := personel [ i ] ;
74836: LD_ADDR_VAR 0 13
74840: PUSH
74841: LD_VAR 0 6
74845: PUSH
74846: LD_VAR 0 8
74850: ARRAY
74851: ST_TO_ADDR
// if x = - 1 then
74852: LD_VAR 0 13
74856: PUSH
74857: LD_INT 1
74859: NEG
74860: EQUAL
74861: IFFALSE 75070
// begin for j in f do
74863: LD_ADDR_VAR 0 9
74867: PUSH
74868: LD_VAR 0 12
74872: PUSH
74873: FOR_IN
74874: IFFALSE 75066
// repeat InitHc ;
74876: CALL_OW 19
// if GetBType ( j ) = b_barracks then
74880: LD_VAR 0 9
74884: PPUSH
74885: CALL_OW 266
74889: PUSH
74890: LD_INT 5
74892: EQUAL
74893: IFFALSE 74963
// begin if UnitsInside ( j ) < 3 then
74895: LD_VAR 0 9
74899: PPUSH
74900: CALL_OW 313
74904: PUSH
74905: LD_INT 3
74907: LESS
74908: IFFALSE 74944
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74910: LD_INT 0
74912: PPUSH
74913: LD_INT 5
74915: PUSH
74916: LD_INT 8
74918: PUSH
74919: LD_INT 9
74921: PUSH
74922: EMPTY
74923: LIST
74924: LIST
74925: LIST
74926: PUSH
74927: LD_VAR 0 17
74931: ARRAY
74932: PPUSH
74933: LD_VAR 0 4
74937: PPUSH
74938: CALL_OW 380
74942: GO 74961
// PrepareHuman ( false , i , skill ) ;
74944: LD_INT 0
74946: PPUSH
74947: LD_VAR 0 8
74951: PPUSH
74952: LD_VAR 0 4
74956: PPUSH
74957: CALL_OW 380
// end else
74961: GO 74980
// PrepareHuman ( false , i , skill ) ;
74963: LD_INT 0
74965: PPUSH
74966: LD_VAR 0 8
74970: PPUSH
74971: LD_VAR 0 4
74975: PPUSH
74976: CALL_OW 380
// un := CreateHuman ;
74980: LD_ADDR_VAR 0 14
74984: PUSH
74985: CALL_OW 44
74989: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74990: LD_ADDR_VAR 0 7
74994: PUSH
74995: LD_VAR 0 7
74999: PPUSH
75000: LD_INT 1
75002: PPUSH
75003: LD_VAR 0 14
75007: PPUSH
75008: CALL_OW 2
75012: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
75013: LD_VAR 0 14
75017: PPUSH
75018: LD_VAR 0 9
75022: PPUSH
75023: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
75027: LD_VAR 0 9
75031: PPUSH
75032: CALL_OW 313
75036: PUSH
75037: LD_INT 6
75039: EQUAL
75040: PUSH
75041: LD_VAR 0 9
75045: PPUSH
75046: CALL_OW 266
75050: PUSH
75051: LD_INT 32
75053: PUSH
75054: LD_INT 31
75056: PUSH
75057: EMPTY
75058: LIST
75059: LIST
75060: IN
75061: OR
75062: IFFALSE 74876
75064: GO 74873
75066: POP
75067: POP
// end else
75068: GO 75450
// for j = 1 to x do
75070: LD_ADDR_VAR 0 9
75074: PUSH
75075: DOUBLE
75076: LD_INT 1
75078: DEC
75079: ST_TO_ADDR
75080: LD_VAR 0 13
75084: PUSH
75085: FOR_TO
75086: IFFALSE 75448
// begin InitHc ;
75088: CALL_OW 19
// if not f then
75092: LD_VAR 0 12
75096: NOT
75097: IFFALSE 75186
// begin PrepareHuman ( false , i , skill ) ;
75099: LD_INT 0
75101: PPUSH
75102: LD_VAR 0 8
75106: PPUSH
75107: LD_VAR 0 4
75111: PPUSH
75112: CALL_OW 380
// un := CreateHuman ;
75116: LD_ADDR_VAR 0 14
75120: PUSH
75121: CALL_OW 44
75125: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75126: LD_ADDR_VAR 0 7
75130: PUSH
75131: LD_VAR 0 7
75135: PPUSH
75136: LD_INT 1
75138: PPUSH
75139: LD_VAR 0 14
75143: PPUSH
75144: CALL_OW 2
75148: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75149: LD_VAR 0 14
75153: PPUSH
75154: LD_VAR 0 1
75158: PPUSH
75159: CALL_OW 250
75163: PPUSH
75164: LD_VAR 0 1
75168: PPUSH
75169: CALL_OW 251
75173: PPUSH
75174: LD_INT 10
75176: PPUSH
75177: LD_INT 0
75179: PPUSH
75180: CALL_OW 50
// continue ;
75184: GO 75085
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
75186: LD_VAR 0 12
75190: PUSH
75191: LD_INT 1
75193: ARRAY
75194: PPUSH
75195: CALL_OW 313
75199: PUSH
75200: LD_VAR 0 12
75204: PUSH
75205: LD_INT 1
75207: ARRAY
75208: PPUSH
75209: CALL_OW 266
75213: PUSH
75214: LD_INT 32
75216: PUSH
75217: LD_INT 31
75219: PUSH
75220: EMPTY
75221: LIST
75222: LIST
75223: IN
75224: AND
75225: PUSH
75226: LD_VAR 0 12
75230: PUSH
75231: LD_INT 1
75233: ARRAY
75234: PPUSH
75235: CALL_OW 313
75239: PUSH
75240: LD_INT 6
75242: EQUAL
75243: OR
75244: IFFALSE 75264
// f := Delete ( f , 1 ) ;
75246: LD_ADDR_VAR 0 12
75250: PUSH
75251: LD_VAR 0 12
75255: PPUSH
75256: LD_INT 1
75258: PPUSH
75259: CALL_OW 3
75263: ST_TO_ADDR
// if not f then
75264: LD_VAR 0 12
75268: NOT
75269: IFFALSE 75287
// begin x := x + 2 ;
75271: LD_ADDR_VAR 0 13
75275: PUSH
75276: LD_VAR 0 13
75280: PUSH
75281: LD_INT 2
75283: PLUS
75284: ST_TO_ADDR
// continue ;
75285: GO 75085
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
75287: LD_VAR 0 12
75291: PUSH
75292: LD_INT 1
75294: ARRAY
75295: PPUSH
75296: CALL_OW 266
75300: PUSH
75301: LD_INT 5
75303: EQUAL
75304: IFFALSE 75378
// begin if UnitsInside ( f [ 1 ] ) < 3 then
75306: LD_VAR 0 12
75310: PUSH
75311: LD_INT 1
75313: ARRAY
75314: PPUSH
75315: CALL_OW 313
75319: PUSH
75320: LD_INT 3
75322: LESS
75323: IFFALSE 75359
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75325: LD_INT 0
75327: PPUSH
75328: LD_INT 5
75330: PUSH
75331: LD_INT 8
75333: PUSH
75334: LD_INT 9
75336: PUSH
75337: EMPTY
75338: LIST
75339: LIST
75340: LIST
75341: PUSH
75342: LD_VAR 0 17
75346: ARRAY
75347: PPUSH
75348: LD_VAR 0 4
75352: PPUSH
75353: CALL_OW 380
75357: GO 75376
// PrepareHuman ( false , i , skill ) ;
75359: LD_INT 0
75361: PPUSH
75362: LD_VAR 0 8
75366: PPUSH
75367: LD_VAR 0 4
75371: PPUSH
75372: CALL_OW 380
// end else
75376: GO 75395
// PrepareHuman ( false , i , skill ) ;
75378: LD_INT 0
75380: PPUSH
75381: LD_VAR 0 8
75385: PPUSH
75386: LD_VAR 0 4
75390: PPUSH
75391: CALL_OW 380
// un := CreateHuman ;
75395: LD_ADDR_VAR 0 14
75399: PUSH
75400: CALL_OW 44
75404: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75405: LD_ADDR_VAR 0 7
75409: PUSH
75410: LD_VAR 0 7
75414: PPUSH
75415: LD_INT 1
75417: PPUSH
75418: LD_VAR 0 14
75422: PPUSH
75423: CALL_OW 2
75427: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
75428: LD_VAR 0 14
75432: PPUSH
75433: LD_VAR 0 12
75437: PUSH
75438: LD_INT 1
75440: ARRAY
75441: PPUSH
75442: CALL_OW 52
// end ;
75446: GO 75085
75448: POP
75449: POP
// end ;
75450: GO 74387
75452: POP
75453: POP
// result := result ^ buildings ;
75454: LD_ADDR_VAR 0 7
75458: PUSH
75459: LD_VAR 0 7
75463: PUSH
75464: LD_VAR 0 18
75468: ADD
75469: ST_TO_ADDR
// end else
75470: GO 75613
// begin for i = 1 to personel do
75472: LD_ADDR_VAR 0 8
75476: PUSH
75477: DOUBLE
75478: LD_INT 1
75480: DEC
75481: ST_TO_ADDR
75482: LD_VAR 0 6
75486: PUSH
75487: FOR_TO
75488: IFFALSE 75611
// begin if i > 4 then
75490: LD_VAR 0 8
75494: PUSH
75495: LD_INT 4
75497: GREATER
75498: IFFALSE 75502
// break ;
75500: GO 75611
// x := personel [ i ] ;
75502: LD_ADDR_VAR 0 13
75506: PUSH
75507: LD_VAR 0 6
75511: PUSH
75512: LD_VAR 0 8
75516: ARRAY
75517: ST_TO_ADDR
// if x = - 1 then
75518: LD_VAR 0 13
75522: PUSH
75523: LD_INT 1
75525: NEG
75526: EQUAL
75527: IFFALSE 75531
// continue ;
75529: GO 75487
// PrepareHuman ( false , i , skill ) ;
75531: LD_INT 0
75533: PPUSH
75534: LD_VAR 0 8
75538: PPUSH
75539: LD_VAR 0 4
75543: PPUSH
75544: CALL_OW 380
// un := CreateHuman ;
75548: LD_ADDR_VAR 0 14
75552: PUSH
75553: CALL_OW 44
75557: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75558: LD_VAR 0 14
75562: PPUSH
75563: LD_VAR 0 1
75567: PPUSH
75568: CALL_OW 250
75572: PPUSH
75573: LD_VAR 0 1
75577: PPUSH
75578: CALL_OW 251
75582: PPUSH
75583: LD_INT 10
75585: PPUSH
75586: LD_INT 0
75588: PPUSH
75589: CALL_OW 50
// result := result ^ un ;
75593: LD_ADDR_VAR 0 7
75597: PUSH
75598: LD_VAR 0 7
75602: PUSH
75603: LD_VAR 0 14
75607: ADD
75608: ST_TO_ADDR
// end ;
75609: GO 75487
75611: POP
75612: POP
// end ; end ;
75613: LD_VAR 0 7
75617: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
75618: LD_INT 0
75620: PPUSH
75621: PPUSH
75622: PPUSH
75623: PPUSH
75624: PPUSH
75625: PPUSH
75626: PPUSH
75627: PPUSH
75628: PPUSH
75629: PPUSH
75630: PPUSH
75631: PPUSH
75632: PPUSH
75633: PPUSH
75634: PPUSH
75635: PPUSH
// result := false ;
75636: LD_ADDR_VAR 0 3
75640: PUSH
75641: LD_INT 0
75643: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
75644: LD_VAR 0 1
75648: NOT
75649: PUSH
75650: LD_VAR 0 1
75654: PPUSH
75655: CALL_OW 266
75659: PUSH
75660: LD_INT 32
75662: PUSH
75663: LD_INT 33
75665: PUSH
75666: EMPTY
75667: LIST
75668: LIST
75669: IN
75670: NOT
75671: OR
75672: IFFALSE 75676
// exit ;
75674: GO 76785
// nat := GetNation ( tower ) ;
75676: LD_ADDR_VAR 0 12
75680: PUSH
75681: LD_VAR 0 1
75685: PPUSH
75686: CALL_OW 248
75690: ST_TO_ADDR
// side := GetSide ( tower ) ;
75691: LD_ADDR_VAR 0 16
75695: PUSH
75696: LD_VAR 0 1
75700: PPUSH
75701: CALL_OW 255
75705: ST_TO_ADDR
// x := GetX ( tower ) ;
75706: LD_ADDR_VAR 0 10
75710: PUSH
75711: LD_VAR 0 1
75715: PPUSH
75716: CALL_OW 250
75720: ST_TO_ADDR
// y := GetY ( tower ) ;
75721: LD_ADDR_VAR 0 11
75725: PUSH
75726: LD_VAR 0 1
75730: PPUSH
75731: CALL_OW 251
75735: ST_TO_ADDR
// if not x or not y then
75736: LD_VAR 0 10
75740: NOT
75741: PUSH
75742: LD_VAR 0 11
75746: NOT
75747: OR
75748: IFFALSE 75752
// exit ;
75750: GO 76785
// weapon := 0 ;
75752: LD_ADDR_VAR 0 18
75756: PUSH
75757: LD_INT 0
75759: ST_TO_ADDR
// fac_list := [ ] ;
75760: LD_ADDR_VAR 0 17
75764: PUSH
75765: EMPTY
75766: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
75767: LD_ADDR_VAR 0 6
75771: PUSH
75772: LD_VAR 0 1
75776: PPUSH
75777: CALL_OW 274
75781: PPUSH
75782: LD_VAR 0 2
75786: PPUSH
75787: LD_INT 0
75789: PPUSH
75790: CALL 73356 0 3
75794: PPUSH
75795: LD_INT 30
75797: PUSH
75798: LD_INT 3
75800: PUSH
75801: EMPTY
75802: LIST
75803: LIST
75804: PPUSH
75805: CALL_OW 72
75809: ST_TO_ADDR
// if not factories then
75810: LD_VAR 0 6
75814: NOT
75815: IFFALSE 75819
// exit ;
75817: GO 76785
// for i in factories do
75819: LD_ADDR_VAR 0 8
75823: PUSH
75824: LD_VAR 0 6
75828: PUSH
75829: FOR_IN
75830: IFFALSE 75855
// fac_list := fac_list union AvailableWeaponList ( i ) ;
75832: LD_ADDR_VAR 0 17
75836: PUSH
75837: LD_VAR 0 17
75841: PUSH
75842: LD_VAR 0 8
75846: PPUSH
75847: CALL_OW 478
75851: UNION
75852: ST_TO_ADDR
75853: GO 75829
75855: POP
75856: POP
// if not fac_list then
75857: LD_VAR 0 17
75861: NOT
75862: IFFALSE 75866
// exit ;
75864: GO 76785
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
75866: LD_ADDR_VAR 0 5
75870: PUSH
75871: LD_INT 4
75873: PUSH
75874: LD_INT 5
75876: PUSH
75877: LD_INT 9
75879: PUSH
75880: LD_INT 10
75882: PUSH
75883: LD_INT 6
75885: PUSH
75886: LD_INT 7
75888: PUSH
75889: LD_INT 11
75891: PUSH
75892: EMPTY
75893: LIST
75894: LIST
75895: LIST
75896: LIST
75897: LIST
75898: LIST
75899: LIST
75900: PUSH
75901: LD_INT 27
75903: PUSH
75904: LD_INT 28
75906: PUSH
75907: LD_INT 26
75909: PUSH
75910: LD_INT 30
75912: PUSH
75913: EMPTY
75914: LIST
75915: LIST
75916: LIST
75917: LIST
75918: PUSH
75919: LD_INT 43
75921: PUSH
75922: LD_INT 44
75924: PUSH
75925: LD_INT 46
75927: PUSH
75928: LD_INT 45
75930: PUSH
75931: LD_INT 47
75933: PUSH
75934: LD_INT 49
75936: PUSH
75937: EMPTY
75938: LIST
75939: LIST
75940: LIST
75941: LIST
75942: LIST
75943: LIST
75944: PUSH
75945: EMPTY
75946: LIST
75947: LIST
75948: LIST
75949: PUSH
75950: LD_VAR 0 12
75954: ARRAY
75955: ST_TO_ADDR
// list := list isect fac_list ;
75956: LD_ADDR_VAR 0 5
75960: PUSH
75961: LD_VAR 0 5
75965: PUSH
75966: LD_VAR 0 17
75970: ISECT
75971: ST_TO_ADDR
// if not list then
75972: LD_VAR 0 5
75976: NOT
75977: IFFALSE 75981
// exit ;
75979: GO 76785
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
75981: LD_VAR 0 12
75985: PUSH
75986: LD_INT 3
75988: EQUAL
75989: PUSH
75990: LD_INT 49
75992: PUSH
75993: LD_VAR 0 5
75997: IN
75998: AND
75999: PUSH
76000: LD_INT 31
76002: PPUSH
76003: LD_VAR 0 16
76007: PPUSH
76008: CALL_OW 321
76012: PUSH
76013: LD_INT 2
76015: EQUAL
76016: AND
76017: IFFALSE 76077
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
76019: LD_INT 22
76021: PUSH
76022: LD_VAR 0 16
76026: PUSH
76027: EMPTY
76028: LIST
76029: LIST
76030: PUSH
76031: LD_INT 35
76033: PUSH
76034: LD_INT 49
76036: PUSH
76037: EMPTY
76038: LIST
76039: LIST
76040: PUSH
76041: LD_INT 91
76043: PUSH
76044: LD_VAR 0 1
76048: PUSH
76049: LD_INT 10
76051: PUSH
76052: EMPTY
76053: LIST
76054: LIST
76055: LIST
76056: PUSH
76057: EMPTY
76058: LIST
76059: LIST
76060: LIST
76061: PPUSH
76062: CALL_OW 69
76066: NOT
76067: IFFALSE 76077
// weapon := ru_time_lapser ;
76069: LD_ADDR_VAR 0 18
76073: PUSH
76074: LD_INT 49
76076: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
76077: LD_VAR 0 12
76081: PUSH
76082: LD_INT 1
76084: PUSH
76085: LD_INT 2
76087: PUSH
76088: EMPTY
76089: LIST
76090: LIST
76091: IN
76092: PUSH
76093: LD_INT 11
76095: PUSH
76096: LD_VAR 0 5
76100: IN
76101: PUSH
76102: LD_INT 30
76104: PUSH
76105: LD_VAR 0 5
76109: IN
76110: OR
76111: AND
76112: PUSH
76113: LD_INT 6
76115: PPUSH
76116: LD_VAR 0 16
76120: PPUSH
76121: CALL_OW 321
76125: PUSH
76126: LD_INT 2
76128: EQUAL
76129: AND
76130: IFFALSE 76295
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
76132: LD_INT 22
76134: PUSH
76135: LD_VAR 0 16
76139: PUSH
76140: EMPTY
76141: LIST
76142: LIST
76143: PUSH
76144: LD_INT 2
76146: PUSH
76147: LD_INT 35
76149: PUSH
76150: LD_INT 11
76152: PUSH
76153: EMPTY
76154: LIST
76155: LIST
76156: PUSH
76157: LD_INT 35
76159: PUSH
76160: LD_INT 30
76162: PUSH
76163: EMPTY
76164: LIST
76165: LIST
76166: PUSH
76167: EMPTY
76168: LIST
76169: LIST
76170: LIST
76171: PUSH
76172: LD_INT 91
76174: PUSH
76175: LD_VAR 0 1
76179: PUSH
76180: LD_INT 18
76182: PUSH
76183: EMPTY
76184: LIST
76185: LIST
76186: LIST
76187: PUSH
76188: EMPTY
76189: LIST
76190: LIST
76191: LIST
76192: PPUSH
76193: CALL_OW 69
76197: NOT
76198: PUSH
76199: LD_INT 22
76201: PUSH
76202: LD_VAR 0 16
76206: PUSH
76207: EMPTY
76208: LIST
76209: LIST
76210: PUSH
76211: LD_INT 2
76213: PUSH
76214: LD_INT 30
76216: PUSH
76217: LD_INT 32
76219: PUSH
76220: EMPTY
76221: LIST
76222: LIST
76223: PUSH
76224: LD_INT 30
76226: PUSH
76227: LD_INT 33
76229: PUSH
76230: EMPTY
76231: LIST
76232: LIST
76233: PUSH
76234: EMPTY
76235: LIST
76236: LIST
76237: LIST
76238: PUSH
76239: LD_INT 91
76241: PUSH
76242: LD_VAR 0 1
76246: PUSH
76247: LD_INT 12
76249: PUSH
76250: EMPTY
76251: LIST
76252: LIST
76253: LIST
76254: PUSH
76255: EMPTY
76256: LIST
76257: LIST
76258: LIST
76259: PUSH
76260: EMPTY
76261: LIST
76262: PPUSH
76263: CALL_OW 69
76267: PUSH
76268: LD_INT 2
76270: GREATER
76271: AND
76272: IFFALSE 76295
// weapon := [ us_radar , ar_radar ] [ nat ] ;
76274: LD_ADDR_VAR 0 18
76278: PUSH
76279: LD_INT 11
76281: PUSH
76282: LD_INT 30
76284: PUSH
76285: EMPTY
76286: LIST
76287: LIST
76288: PUSH
76289: LD_VAR 0 12
76293: ARRAY
76294: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
76295: LD_VAR 0 18
76299: NOT
76300: PUSH
76301: LD_INT 40
76303: PPUSH
76304: LD_VAR 0 16
76308: PPUSH
76309: CALL_OW 321
76313: PUSH
76314: LD_INT 2
76316: EQUAL
76317: AND
76318: PUSH
76319: LD_INT 7
76321: PUSH
76322: LD_VAR 0 5
76326: IN
76327: PUSH
76328: LD_INT 28
76330: PUSH
76331: LD_VAR 0 5
76335: IN
76336: OR
76337: PUSH
76338: LD_INT 45
76340: PUSH
76341: LD_VAR 0 5
76345: IN
76346: OR
76347: AND
76348: IFFALSE 76602
// begin hex := GetHexInfo ( x , y ) ;
76350: LD_ADDR_VAR 0 4
76354: PUSH
76355: LD_VAR 0 10
76359: PPUSH
76360: LD_VAR 0 11
76364: PPUSH
76365: CALL_OW 546
76369: ST_TO_ADDR
// if hex [ 1 ] then
76370: LD_VAR 0 4
76374: PUSH
76375: LD_INT 1
76377: ARRAY
76378: IFFALSE 76382
// exit ;
76380: GO 76785
// height := hex [ 2 ] ;
76382: LD_ADDR_VAR 0 15
76386: PUSH
76387: LD_VAR 0 4
76391: PUSH
76392: LD_INT 2
76394: ARRAY
76395: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
76396: LD_ADDR_VAR 0 14
76400: PUSH
76401: LD_INT 0
76403: PUSH
76404: LD_INT 2
76406: PUSH
76407: LD_INT 3
76409: PUSH
76410: LD_INT 5
76412: PUSH
76413: EMPTY
76414: LIST
76415: LIST
76416: LIST
76417: LIST
76418: ST_TO_ADDR
// for i in tmp do
76419: LD_ADDR_VAR 0 8
76423: PUSH
76424: LD_VAR 0 14
76428: PUSH
76429: FOR_IN
76430: IFFALSE 76600
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
76432: LD_ADDR_VAR 0 9
76436: PUSH
76437: LD_VAR 0 10
76441: PPUSH
76442: LD_VAR 0 8
76446: PPUSH
76447: LD_INT 5
76449: PPUSH
76450: CALL_OW 272
76454: PUSH
76455: LD_VAR 0 11
76459: PPUSH
76460: LD_VAR 0 8
76464: PPUSH
76465: LD_INT 5
76467: PPUSH
76468: CALL_OW 273
76472: PUSH
76473: EMPTY
76474: LIST
76475: LIST
76476: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
76477: LD_VAR 0 9
76481: PUSH
76482: LD_INT 1
76484: ARRAY
76485: PPUSH
76486: LD_VAR 0 9
76490: PUSH
76491: LD_INT 2
76493: ARRAY
76494: PPUSH
76495: CALL_OW 488
76499: IFFALSE 76598
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
76501: LD_ADDR_VAR 0 4
76505: PUSH
76506: LD_VAR 0 9
76510: PUSH
76511: LD_INT 1
76513: ARRAY
76514: PPUSH
76515: LD_VAR 0 9
76519: PUSH
76520: LD_INT 2
76522: ARRAY
76523: PPUSH
76524: CALL_OW 546
76528: ST_TO_ADDR
// if hex [ 1 ] then
76529: LD_VAR 0 4
76533: PUSH
76534: LD_INT 1
76536: ARRAY
76537: IFFALSE 76541
// continue ;
76539: GO 76429
// h := hex [ 2 ] ;
76541: LD_ADDR_VAR 0 13
76545: PUSH
76546: LD_VAR 0 4
76550: PUSH
76551: LD_INT 2
76553: ARRAY
76554: ST_TO_ADDR
// if h + 7 < height then
76555: LD_VAR 0 13
76559: PUSH
76560: LD_INT 7
76562: PLUS
76563: PUSH
76564: LD_VAR 0 15
76568: LESS
76569: IFFALSE 76598
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
76571: LD_ADDR_VAR 0 18
76575: PUSH
76576: LD_INT 7
76578: PUSH
76579: LD_INT 28
76581: PUSH
76582: LD_INT 45
76584: PUSH
76585: EMPTY
76586: LIST
76587: LIST
76588: LIST
76589: PUSH
76590: LD_VAR 0 12
76594: ARRAY
76595: ST_TO_ADDR
// break ;
76596: GO 76600
// end ; end ; end ;
76598: GO 76429
76600: POP
76601: POP
// end ; if not weapon then
76602: LD_VAR 0 18
76606: NOT
76607: IFFALSE 76667
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
76609: LD_ADDR_VAR 0 5
76613: PUSH
76614: LD_VAR 0 5
76618: PUSH
76619: LD_INT 11
76621: PUSH
76622: LD_INT 30
76624: PUSH
76625: LD_INT 49
76627: PUSH
76628: EMPTY
76629: LIST
76630: LIST
76631: LIST
76632: DIFF
76633: ST_TO_ADDR
// if not list then
76634: LD_VAR 0 5
76638: NOT
76639: IFFALSE 76643
// exit ;
76641: GO 76785
// weapon := list [ rand ( 1 , list ) ] ;
76643: LD_ADDR_VAR 0 18
76647: PUSH
76648: LD_VAR 0 5
76652: PUSH
76653: LD_INT 1
76655: PPUSH
76656: LD_VAR 0 5
76660: PPUSH
76661: CALL_OW 12
76665: ARRAY
76666: ST_TO_ADDR
// end ; if weapon then
76667: LD_VAR 0 18
76671: IFFALSE 76785
// begin tmp := CostOfWeapon ( weapon ) ;
76673: LD_ADDR_VAR 0 14
76677: PUSH
76678: LD_VAR 0 18
76682: PPUSH
76683: CALL_OW 451
76687: ST_TO_ADDR
// j := GetBase ( tower ) ;
76688: LD_ADDR_VAR 0 9
76692: PUSH
76693: LD_VAR 0 1
76697: PPUSH
76698: CALL_OW 274
76702: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
76703: LD_VAR 0 9
76707: PPUSH
76708: LD_INT 1
76710: PPUSH
76711: CALL_OW 275
76715: PUSH
76716: LD_VAR 0 14
76720: PUSH
76721: LD_INT 1
76723: ARRAY
76724: GREATEREQUAL
76725: PUSH
76726: LD_VAR 0 9
76730: PPUSH
76731: LD_INT 2
76733: PPUSH
76734: CALL_OW 275
76738: PUSH
76739: LD_VAR 0 14
76743: PUSH
76744: LD_INT 2
76746: ARRAY
76747: GREATEREQUAL
76748: AND
76749: PUSH
76750: LD_VAR 0 9
76754: PPUSH
76755: LD_INT 3
76757: PPUSH
76758: CALL_OW 275
76762: PUSH
76763: LD_VAR 0 14
76767: PUSH
76768: LD_INT 3
76770: ARRAY
76771: GREATEREQUAL
76772: AND
76773: IFFALSE 76785
// result := weapon ;
76775: LD_ADDR_VAR 0 3
76779: PUSH
76780: LD_VAR 0 18
76784: ST_TO_ADDR
// end ; end ;
76785: LD_VAR 0 3
76789: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
76790: LD_INT 0
76792: PPUSH
76793: PPUSH
// result := true ;
76794: LD_ADDR_VAR 0 3
76798: PUSH
76799: LD_INT 1
76801: ST_TO_ADDR
// if array1 = array2 then
76802: LD_VAR 0 1
76806: PUSH
76807: LD_VAR 0 2
76811: EQUAL
76812: IFFALSE 76872
// begin for i = 1 to array1 do
76814: LD_ADDR_VAR 0 4
76818: PUSH
76819: DOUBLE
76820: LD_INT 1
76822: DEC
76823: ST_TO_ADDR
76824: LD_VAR 0 1
76828: PUSH
76829: FOR_TO
76830: IFFALSE 76868
// if array1 [ i ] <> array2 [ i ] then
76832: LD_VAR 0 1
76836: PUSH
76837: LD_VAR 0 4
76841: ARRAY
76842: PUSH
76843: LD_VAR 0 2
76847: PUSH
76848: LD_VAR 0 4
76852: ARRAY
76853: NONEQUAL
76854: IFFALSE 76866
// begin result := false ;
76856: LD_ADDR_VAR 0 3
76860: PUSH
76861: LD_INT 0
76863: ST_TO_ADDR
// break ;
76864: GO 76868
// end ;
76866: GO 76829
76868: POP
76869: POP
// end else
76870: GO 76880
// result := false ;
76872: LD_ADDR_VAR 0 3
76876: PUSH
76877: LD_INT 0
76879: ST_TO_ADDR
// end ;
76880: LD_VAR 0 3
76884: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
76885: LD_INT 0
76887: PPUSH
76888: PPUSH
// if not array1 or not array2 then
76889: LD_VAR 0 1
76893: NOT
76894: PUSH
76895: LD_VAR 0 2
76899: NOT
76900: OR
76901: IFFALSE 76905
// exit ;
76903: GO 76969
// result := true ;
76905: LD_ADDR_VAR 0 3
76909: PUSH
76910: LD_INT 1
76912: ST_TO_ADDR
// for i = 1 to array1 do
76913: LD_ADDR_VAR 0 4
76917: PUSH
76918: DOUBLE
76919: LD_INT 1
76921: DEC
76922: ST_TO_ADDR
76923: LD_VAR 0 1
76927: PUSH
76928: FOR_TO
76929: IFFALSE 76967
// if array1 [ i ] <> array2 [ i ] then
76931: LD_VAR 0 1
76935: PUSH
76936: LD_VAR 0 4
76940: ARRAY
76941: PUSH
76942: LD_VAR 0 2
76946: PUSH
76947: LD_VAR 0 4
76951: ARRAY
76952: NONEQUAL
76953: IFFALSE 76965
// begin result := false ;
76955: LD_ADDR_VAR 0 3
76959: PUSH
76960: LD_INT 0
76962: ST_TO_ADDR
// break ;
76963: GO 76967
// end ;
76965: GO 76928
76967: POP
76968: POP
// end ;
76969: LD_VAR 0 3
76973: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
76974: LD_INT 0
76976: PPUSH
76977: PPUSH
76978: PPUSH
// pom := GetBase ( fac ) ;
76979: LD_ADDR_VAR 0 5
76983: PUSH
76984: LD_VAR 0 1
76988: PPUSH
76989: CALL_OW 274
76993: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
76994: LD_ADDR_VAR 0 4
76998: PUSH
76999: LD_VAR 0 2
77003: PUSH
77004: LD_INT 1
77006: ARRAY
77007: PPUSH
77008: LD_VAR 0 2
77012: PUSH
77013: LD_INT 2
77015: ARRAY
77016: PPUSH
77017: LD_VAR 0 2
77021: PUSH
77022: LD_INT 3
77024: ARRAY
77025: PPUSH
77026: LD_VAR 0 2
77030: PUSH
77031: LD_INT 4
77033: ARRAY
77034: PPUSH
77035: CALL_OW 449
77039: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77040: LD_ADDR_VAR 0 3
77044: PUSH
77045: LD_VAR 0 5
77049: PPUSH
77050: LD_INT 1
77052: PPUSH
77053: CALL_OW 275
77057: PUSH
77058: LD_VAR 0 4
77062: PUSH
77063: LD_INT 1
77065: ARRAY
77066: GREATEREQUAL
77067: PUSH
77068: LD_VAR 0 5
77072: PPUSH
77073: LD_INT 2
77075: PPUSH
77076: CALL_OW 275
77080: PUSH
77081: LD_VAR 0 4
77085: PUSH
77086: LD_INT 2
77088: ARRAY
77089: GREATEREQUAL
77090: AND
77091: PUSH
77092: LD_VAR 0 5
77096: PPUSH
77097: LD_INT 3
77099: PPUSH
77100: CALL_OW 275
77104: PUSH
77105: LD_VAR 0 4
77109: PUSH
77110: LD_INT 3
77112: ARRAY
77113: GREATEREQUAL
77114: AND
77115: ST_TO_ADDR
// end ;
77116: LD_VAR 0 3
77120: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
77121: LD_INT 0
77123: PPUSH
77124: PPUSH
77125: PPUSH
77126: PPUSH
// pom := GetBase ( building ) ;
77127: LD_ADDR_VAR 0 3
77131: PUSH
77132: LD_VAR 0 1
77136: PPUSH
77137: CALL_OW 274
77141: ST_TO_ADDR
// if not pom then
77142: LD_VAR 0 3
77146: NOT
77147: IFFALSE 77151
// exit ;
77149: GO 77321
// btype := GetBType ( building ) ;
77151: LD_ADDR_VAR 0 5
77155: PUSH
77156: LD_VAR 0 1
77160: PPUSH
77161: CALL_OW 266
77165: ST_TO_ADDR
// if btype = b_armoury then
77166: LD_VAR 0 5
77170: PUSH
77171: LD_INT 4
77173: EQUAL
77174: IFFALSE 77184
// btype := b_barracks ;
77176: LD_ADDR_VAR 0 5
77180: PUSH
77181: LD_INT 5
77183: ST_TO_ADDR
// if btype = b_depot then
77184: LD_VAR 0 5
77188: PUSH
77189: LD_INT 0
77191: EQUAL
77192: IFFALSE 77202
// btype := b_warehouse ;
77194: LD_ADDR_VAR 0 5
77198: PUSH
77199: LD_INT 1
77201: ST_TO_ADDR
// if btype = b_workshop then
77202: LD_VAR 0 5
77206: PUSH
77207: LD_INT 2
77209: EQUAL
77210: IFFALSE 77220
// btype := b_factory ;
77212: LD_ADDR_VAR 0 5
77216: PUSH
77217: LD_INT 3
77219: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77220: LD_ADDR_VAR 0 4
77224: PUSH
77225: LD_VAR 0 5
77229: PPUSH
77230: LD_VAR 0 1
77234: PPUSH
77235: CALL_OW 248
77239: PPUSH
77240: CALL_OW 450
77244: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77245: LD_ADDR_VAR 0 2
77249: PUSH
77250: LD_VAR 0 3
77254: PPUSH
77255: LD_INT 1
77257: PPUSH
77258: CALL_OW 275
77262: PUSH
77263: LD_VAR 0 4
77267: PUSH
77268: LD_INT 1
77270: ARRAY
77271: GREATEREQUAL
77272: PUSH
77273: LD_VAR 0 3
77277: PPUSH
77278: LD_INT 2
77280: PPUSH
77281: CALL_OW 275
77285: PUSH
77286: LD_VAR 0 4
77290: PUSH
77291: LD_INT 2
77293: ARRAY
77294: GREATEREQUAL
77295: AND
77296: PUSH
77297: LD_VAR 0 3
77301: PPUSH
77302: LD_INT 3
77304: PPUSH
77305: CALL_OW 275
77309: PUSH
77310: LD_VAR 0 4
77314: PUSH
77315: LD_INT 3
77317: ARRAY
77318: GREATEREQUAL
77319: AND
77320: ST_TO_ADDR
// end ;
77321: LD_VAR 0 2
77325: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
77326: LD_INT 0
77328: PPUSH
77329: PPUSH
77330: PPUSH
// pom := GetBase ( building ) ;
77331: LD_ADDR_VAR 0 4
77335: PUSH
77336: LD_VAR 0 1
77340: PPUSH
77341: CALL_OW 274
77345: ST_TO_ADDR
// if not pom then
77346: LD_VAR 0 4
77350: NOT
77351: IFFALSE 77355
// exit ;
77353: GO 77456
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77355: LD_ADDR_VAR 0 5
77359: PUSH
77360: LD_VAR 0 2
77364: PPUSH
77365: LD_VAR 0 1
77369: PPUSH
77370: CALL_OW 248
77374: PPUSH
77375: CALL_OW 450
77379: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77380: LD_ADDR_VAR 0 3
77384: PUSH
77385: LD_VAR 0 4
77389: PPUSH
77390: LD_INT 1
77392: PPUSH
77393: CALL_OW 275
77397: PUSH
77398: LD_VAR 0 5
77402: PUSH
77403: LD_INT 1
77405: ARRAY
77406: GREATEREQUAL
77407: PUSH
77408: LD_VAR 0 4
77412: PPUSH
77413: LD_INT 2
77415: PPUSH
77416: CALL_OW 275
77420: PUSH
77421: LD_VAR 0 5
77425: PUSH
77426: LD_INT 2
77428: ARRAY
77429: GREATEREQUAL
77430: AND
77431: PUSH
77432: LD_VAR 0 4
77436: PPUSH
77437: LD_INT 3
77439: PPUSH
77440: CALL_OW 275
77444: PUSH
77445: LD_VAR 0 5
77449: PUSH
77450: LD_INT 3
77452: ARRAY
77453: GREATEREQUAL
77454: AND
77455: ST_TO_ADDR
// end ;
77456: LD_VAR 0 3
77460: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
77461: LD_INT 0
77463: PPUSH
77464: PPUSH
77465: PPUSH
77466: PPUSH
77467: PPUSH
77468: PPUSH
77469: PPUSH
77470: PPUSH
77471: PPUSH
77472: PPUSH
77473: PPUSH
// result := false ;
77474: LD_ADDR_VAR 0 8
77478: PUSH
77479: LD_INT 0
77481: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
77482: LD_VAR 0 5
77486: NOT
77487: PUSH
77488: LD_VAR 0 1
77492: NOT
77493: OR
77494: PUSH
77495: LD_VAR 0 2
77499: NOT
77500: OR
77501: PUSH
77502: LD_VAR 0 3
77506: NOT
77507: OR
77508: IFFALSE 77512
// exit ;
77510: GO 78326
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
77512: LD_ADDR_VAR 0 14
77516: PUSH
77517: LD_VAR 0 1
77521: PPUSH
77522: LD_VAR 0 2
77526: PPUSH
77527: LD_VAR 0 3
77531: PPUSH
77532: LD_VAR 0 4
77536: PPUSH
77537: LD_VAR 0 5
77541: PUSH
77542: LD_INT 1
77544: ARRAY
77545: PPUSH
77546: CALL_OW 248
77550: PPUSH
77551: LD_INT 0
77553: PPUSH
77554: CALL 79563 0 6
77558: ST_TO_ADDR
// if not hexes then
77559: LD_VAR 0 14
77563: NOT
77564: IFFALSE 77568
// exit ;
77566: GO 78326
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
77568: LD_ADDR_VAR 0 17
77572: PUSH
77573: LD_VAR 0 5
77577: PPUSH
77578: LD_INT 22
77580: PUSH
77581: LD_VAR 0 13
77585: PPUSH
77586: CALL_OW 255
77590: PUSH
77591: EMPTY
77592: LIST
77593: LIST
77594: PUSH
77595: LD_INT 2
77597: PUSH
77598: LD_INT 30
77600: PUSH
77601: LD_INT 0
77603: PUSH
77604: EMPTY
77605: LIST
77606: LIST
77607: PUSH
77608: LD_INT 30
77610: PUSH
77611: LD_INT 1
77613: PUSH
77614: EMPTY
77615: LIST
77616: LIST
77617: PUSH
77618: EMPTY
77619: LIST
77620: LIST
77621: LIST
77622: PUSH
77623: EMPTY
77624: LIST
77625: LIST
77626: PPUSH
77627: CALL_OW 72
77631: ST_TO_ADDR
// for i = 1 to hexes do
77632: LD_ADDR_VAR 0 9
77636: PUSH
77637: DOUBLE
77638: LD_INT 1
77640: DEC
77641: ST_TO_ADDR
77642: LD_VAR 0 14
77646: PUSH
77647: FOR_TO
77648: IFFALSE 78324
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77650: LD_ADDR_VAR 0 13
77654: PUSH
77655: LD_VAR 0 14
77659: PUSH
77660: LD_VAR 0 9
77664: ARRAY
77665: PUSH
77666: LD_INT 1
77668: ARRAY
77669: PPUSH
77670: LD_VAR 0 14
77674: PUSH
77675: LD_VAR 0 9
77679: ARRAY
77680: PUSH
77681: LD_INT 2
77683: ARRAY
77684: PPUSH
77685: CALL_OW 428
77689: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
77690: LD_VAR 0 14
77694: PUSH
77695: LD_VAR 0 9
77699: ARRAY
77700: PUSH
77701: LD_INT 1
77703: ARRAY
77704: PPUSH
77705: LD_VAR 0 14
77709: PUSH
77710: LD_VAR 0 9
77714: ARRAY
77715: PUSH
77716: LD_INT 2
77718: ARRAY
77719: PPUSH
77720: CALL_OW 351
77724: PUSH
77725: LD_VAR 0 14
77729: PUSH
77730: LD_VAR 0 9
77734: ARRAY
77735: PUSH
77736: LD_INT 1
77738: ARRAY
77739: PPUSH
77740: LD_VAR 0 14
77744: PUSH
77745: LD_VAR 0 9
77749: ARRAY
77750: PUSH
77751: LD_INT 2
77753: ARRAY
77754: PPUSH
77755: CALL_OW 488
77759: NOT
77760: OR
77761: PUSH
77762: LD_VAR 0 13
77766: PPUSH
77767: CALL_OW 247
77771: PUSH
77772: LD_INT 3
77774: EQUAL
77775: OR
77776: IFFALSE 77782
// exit ;
77778: POP
77779: POP
77780: GO 78326
// if not tmp then
77782: LD_VAR 0 13
77786: NOT
77787: IFFALSE 77791
// continue ;
77789: GO 77647
// result := true ;
77791: LD_ADDR_VAR 0 8
77795: PUSH
77796: LD_INT 1
77798: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
77799: LD_VAR 0 6
77803: PUSH
77804: LD_VAR 0 13
77808: PPUSH
77809: CALL_OW 247
77813: PUSH
77814: LD_INT 2
77816: EQUAL
77817: AND
77818: PUSH
77819: LD_VAR 0 13
77823: PPUSH
77824: CALL_OW 263
77828: PUSH
77829: LD_INT 1
77831: EQUAL
77832: AND
77833: IFFALSE 77997
// begin if IsDrivenBy ( tmp ) then
77835: LD_VAR 0 13
77839: PPUSH
77840: CALL_OW 311
77844: IFFALSE 77848
// continue ;
77846: GO 77647
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
77848: LD_VAR 0 6
77852: PPUSH
77853: LD_INT 3
77855: PUSH
77856: LD_INT 60
77858: PUSH
77859: EMPTY
77860: LIST
77861: PUSH
77862: EMPTY
77863: LIST
77864: LIST
77865: PUSH
77866: LD_INT 3
77868: PUSH
77869: LD_INT 55
77871: PUSH
77872: EMPTY
77873: LIST
77874: PUSH
77875: EMPTY
77876: LIST
77877: LIST
77878: PUSH
77879: EMPTY
77880: LIST
77881: LIST
77882: PPUSH
77883: CALL_OW 72
77887: IFFALSE 77995
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
77889: LD_ADDR_VAR 0 18
77893: PUSH
77894: LD_VAR 0 6
77898: PPUSH
77899: LD_INT 3
77901: PUSH
77902: LD_INT 60
77904: PUSH
77905: EMPTY
77906: LIST
77907: PUSH
77908: EMPTY
77909: LIST
77910: LIST
77911: PUSH
77912: LD_INT 3
77914: PUSH
77915: LD_INT 55
77917: PUSH
77918: EMPTY
77919: LIST
77920: PUSH
77921: EMPTY
77922: LIST
77923: LIST
77924: PUSH
77925: EMPTY
77926: LIST
77927: LIST
77928: PPUSH
77929: CALL_OW 72
77933: PUSH
77934: LD_INT 1
77936: ARRAY
77937: ST_TO_ADDR
// if IsInUnit ( driver ) then
77938: LD_VAR 0 18
77942: PPUSH
77943: CALL_OW 310
77947: IFFALSE 77958
// ComExit ( driver ) ;
77949: LD_VAR 0 18
77953: PPUSH
77954: CALL 102747 0 1
// AddComEnterUnit ( driver , tmp ) ;
77958: LD_VAR 0 18
77962: PPUSH
77963: LD_VAR 0 13
77967: PPUSH
77968: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
77972: LD_VAR 0 18
77976: PPUSH
77977: LD_VAR 0 7
77981: PPUSH
77982: CALL_OW 173
// AddComExitVehicle ( driver ) ;
77986: LD_VAR 0 18
77990: PPUSH
77991: CALL_OW 181
// end ; continue ;
77995: GO 77647
// end ; if not cleaners or not tmp in cleaners then
77997: LD_VAR 0 6
78001: NOT
78002: PUSH
78003: LD_VAR 0 13
78007: PUSH
78008: LD_VAR 0 6
78012: IN
78013: NOT
78014: OR
78015: IFFALSE 78322
// begin if dep then
78017: LD_VAR 0 17
78021: IFFALSE 78157
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
78023: LD_ADDR_VAR 0 16
78027: PUSH
78028: LD_VAR 0 17
78032: PUSH
78033: LD_INT 1
78035: ARRAY
78036: PPUSH
78037: CALL_OW 250
78041: PPUSH
78042: LD_VAR 0 17
78046: PUSH
78047: LD_INT 1
78049: ARRAY
78050: PPUSH
78051: CALL_OW 254
78055: PPUSH
78056: LD_INT 5
78058: PPUSH
78059: CALL_OW 272
78063: PUSH
78064: LD_VAR 0 17
78068: PUSH
78069: LD_INT 1
78071: ARRAY
78072: PPUSH
78073: CALL_OW 251
78077: PPUSH
78078: LD_VAR 0 17
78082: PUSH
78083: LD_INT 1
78085: ARRAY
78086: PPUSH
78087: CALL_OW 254
78091: PPUSH
78092: LD_INT 5
78094: PPUSH
78095: CALL_OW 273
78099: PUSH
78100: EMPTY
78101: LIST
78102: LIST
78103: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
78104: LD_VAR 0 16
78108: PUSH
78109: LD_INT 1
78111: ARRAY
78112: PPUSH
78113: LD_VAR 0 16
78117: PUSH
78118: LD_INT 2
78120: ARRAY
78121: PPUSH
78122: CALL_OW 488
78126: IFFALSE 78157
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
78128: LD_VAR 0 13
78132: PPUSH
78133: LD_VAR 0 16
78137: PUSH
78138: LD_INT 1
78140: ARRAY
78141: PPUSH
78142: LD_VAR 0 16
78146: PUSH
78147: LD_INT 2
78149: ARRAY
78150: PPUSH
78151: CALL_OW 111
// continue ;
78155: GO 77647
// end ; end ; r := GetDir ( tmp ) ;
78157: LD_ADDR_VAR 0 15
78161: PUSH
78162: LD_VAR 0 13
78166: PPUSH
78167: CALL_OW 254
78171: ST_TO_ADDR
// if r = 5 then
78172: LD_VAR 0 15
78176: PUSH
78177: LD_INT 5
78179: EQUAL
78180: IFFALSE 78190
// r := 0 ;
78182: LD_ADDR_VAR 0 15
78186: PUSH
78187: LD_INT 0
78189: ST_TO_ADDR
// for j = r to 5 do
78190: LD_ADDR_VAR 0 10
78194: PUSH
78195: DOUBLE
78196: LD_VAR 0 15
78200: DEC
78201: ST_TO_ADDR
78202: LD_INT 5
78204: PUSH
78205: FOR_TO
78206: IFFALSE 78320
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
78208: LD_ADDR_VAR 0 11
78212: PUSH
78213: LD_VAR 0 13
78217: PPUSH
78218: CALL_OW 250
78222: PPUSH
78223: LD_VAR 0 10
78227: PPUSH
78228: LD_INT 2
78230: PPUSH
78231: CALL_OW 272
78235: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
78236: LD_ADDR_VAR 0 12
78240: PUSH
78241: LD_VAR 0 13
78245: PPUSH
78246: CALL_OW 251
78250: PPUSH
78251: LD_VAR 0 10
78255: PPUSH
78256: LD_INT 2
78258: PPUSH
78259: CALL_OW 273
78263: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
78264: LD_VAR 0 11
78268: PPUSH
78269: LD_VAR 0 12
78273: PPUSH
78274: CALL_OW 488
78278: PUSH
78279: LD_VAR 0 11
78283: PPUSH
78284: LD_VAR 0 12
78288: PPUSH
78289: CALL_OW 428
78293: NOT
78294: AND
78295: IFFALSE 78318
// begin ComMoveXY ( tmp , _x , _y ) ;
78297: LD_VAR 0 13
78301: PPUSH
78302: LD_VAR 0 11
78306: PPUSH
78307: LD_VAR 0 12
78311: PPUSH
78312: CALL_OW 111
// break ;
78316: GO 78320
// end ; end ;
78318: GO 78205
78320: POP
78321: POP
// end ; end ;
78322: GO 77647
78324: POP
78325: POP
// end ;
78326: LD_VAR 0 8
78330: RET
// export function BuildingTechInvented ( side , btype ) ; begin
78331: LD_INT 0
78333: PPUSH
// result := true ;
78334: LD_ADDR_VAR 0 3
78338: PUSH
78339: LD_INT 1
78341: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
78342: LD_VAR 0 2
78346: PUSH
78347: LD_INT 24
78349: DOUBLE
78350: EQUAL
78351: IFTRUE 78361
78353: LD_INT 33
78355: DOUBLE
78356: EQUAL
78357: IFTRUE 78361
78359: GO 78386
78361: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
78362: LD_ADDR_VAR 0 3
78366: PUSH
78367: LD_INT 32
78369: PPUSH
78370: LD_VAR 0 1
78374: PPUSH
78375: CALL_OW 321
78379: PUSH
78380: LD_INT 2
78382: EQUAL
78383: ST_TO_ADDR
78384: GO 78706
78386: LD_INT 20
78388: DOUBLE
78389: EQUAL
78390: IFTRUE 78394
78392: GO 78419
78394: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
78395: LD_ADDR_VAR 0 3
78399: PUSH
78400: LD_INT 6
78402: PPUSH
78403: LD_VAR 0 1
78407: PPUSH
78408: CALL_OW 321
78412: PUSH
78413: LD_INT 2
78415: EQUAL
78416: ST_TO_ADDR
78417: GO 78706
78419: LD_INT 22
78421: DOUBLE
78422: EQUAL
78423: IFTRUE 78433
78425: LD_INT 36
78427: DOUBLE
78428: EQUAL
78429: IFTRUE 78433
78431: GO 78458
78433: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
78434: LD_ADDR_VAR 0 3
78438: PUSH
78439: LD_INT 15
78441: PPUSH
78442: LD_VAR 0 1
78446: PPUSH
78447: CALL_OW 321
78451: PUSH
78452: LD_INT 2
78454: EQUAL
78455: ST_TO_ADDR
78456: GO 78706
78458: LD_INT 30
78460: DOUBLE
78461: EQUAL
78462: IFTRUE 78466
78464: GO 78491
78466: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
78467: LD_ADDR_VAR 0 3
78471: PUSH
78472: LD_INT 20
78474: PPUSH
78475: LD_VAR 0 1
78479: PPUSH
78480: CALL_OW 321
78484: PUSH
78485: LD_INT 2
78487: EQUAL
78488: ST_TO_ADDR
78489: GO 78706
78491: LD_INT 28
78493: DOUBLE
78494: EQUAL
78495: IFTRUE 78505
78497: LD_INT 21
78499: DOUBLE
78500: EQUAL
78501: IFTRUE 78505
78503: GO 78530
78505: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
78506: LD_ADDR_VAR 0 3
78510: PUSH
78511: LD_INT 21
78513: PPUSH
78514: LD_VAR 0 1
78518: PPUSH
78519: CALL_OW 321
78523: PUSH
78524: LD_INT 2
78526: EQUAL
78527: ST_TO_ADDR
78528: GO 78706
78530: LD_INT 16
78532: DOUBLE
78533: EQUAL
78534: IFTRUE 78538
78536: GO 78565
78538: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
78539: LD_ADDR_VAR 0 3
78543: PUSH
78544: LD_EXP 107
78548: PPUSH
78549: LD_VAR 0 1
78553: PPUSH
78554: CALL_OW 321
78558: PUSH
78559: LD_INT 2
78561: EQUAL
78562: ST_TO_ADDR
78563: GO 78706
78565: LD_INT 19
78567: DOUBLE
78568: EQUAL
78569: IFTRUE 78579
78571: LD_INT 23
78573: DOUBLE
78574: EQUAL
78575: IFTRUE 78579
78577: GO 78606
78579: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
78580: LD_ADDR_VAR 0 3
78584: PUSH
78585: LD_EXP 106
78589: PPUSH
78590: LD_VAR 0 1
78594: PPUSH
78595: CALL_OW 321
78599: PUSH
78600: LD_INT 2
78602: EQUAL
78603: ST_TO_ADDR
78604: GO 78706
78606: LD_INT 17
78608: DOUBLE
78609: EQUAL
78610: IFTRUE 78614
78612: GO 78639
78614: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
78615: LD_ADDR_VAR 0 3
78619: PUSH
78620: LD_INT 39
78622: PPUSH
78623: LD_VAR 0 1
78627: PPUSH
78628: CALL_OW 321
78632: PUSH
78633: LD_INT 2
78635: EQUAL
78636: ST_TO_ADDR
78637: GO 78706
78639: LD_INT 18
78641: DOUBLE
78642: EQUAL
78643: IFTRUE 78647
78645: GO 78672
78647: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
78648: LD_ADDR_VAR 0 3
78652: PUSH
78653: LD_INT 40
78655: PPUSH
78656: LD_VAR 0 1
78660: PPUSH
78661: CALL_OW 321
78665: PUSH
78666: LD_INT 2
78668: EQUAL
78669: ST_TO_ADDR
78670: GO 78706
78672: LD_INT 27
78674: DOUBLE
78675: EQUAL
78676: IFTRUE 78680
78678: GO 78705
78680: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
78681: LD_ADDR_VAR 0 3
78685: PUSH
78686: LD_INT 35
78688: PPUSH
78689: LD_VAR 0 1
78693: PPUSH
78694: CALL_OW 321
78698: PUSH
78699: LD_INT 2
78701: EQUAL
78702: ST_TO_ADDR
78703: GO 78706
78705: POP
// end ;
78706: LD_VAR 0 3
78710: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
78711: LD_INT 0
78713: PPUSH
78714: PPUSH
78715: PPUSH
78716: PPUSH
78717: PPUSH
78718: PPUSH
78719: PPUSH
78720: PPUSH
78721: PPUSH
78722: PPUSH
78723: PPUSH
// result := false ;
78724: LD_ADDR_VAR 0 6
78728: PUSH
78729: LD_INT 0
78731: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
78732: LD_VAR 0 1
78736: NOT
78737: PUSH
78738: LD_VAR 0 1
78742: PPUSH
78743: CALL_OW 266
78747: PUSH
78748: LD_INT 0
78750: PUSH
78751: LD_INT 1
78753: PUSH
78754: EMPTY
78755: LIST
78756: LIST
78757: IN
78758: NOT
78759: OR
78760: PUSH
78761: LD_VAR 0 2
78765: NOT
78766: OR
78767: PUSH
78768: LD_VAR 0 5
78772: PUSH
78773: LD_INT 0
78775: PUSH
78776: LD_INT 1
78778: PUSH
78779: LD_INT 2
78781: PUSH
78782: LD_INT 3
78784: PUSH
78785: LD_INT 4
78787: PUSH
78788: LD_INT 5
78790: PUSH
78791: EMPTY
78792: LIST
78793: LIST
78794: LIST
78795: LIST
78796: LIST
78797: LIST
78798: IN
78799: NOT
78800: OR
78801: PUSH
78802: LD_VAR 0 3
78806: PPUSH
78807: LD_VAR 0 4
78811: PPUSH
78812: CALL_OW 488
78816: NOT
78817: OR
78818: IFFALSE 78822
// exit ;
78820: GO 79558
// side := GetSide ( depot ) ;
78822: LD_ADDR_VAR 0 9
78826: PUSH
78827: LD_VAR 0 1
78831: PPUSH
78832: CALL_OW 255
78836: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
78837: LD_VAR 0 9
78841: PPUSH
78842: LD_VAR 0 2
78846: PPUSH
78847: CALL 78331 0 2
78851: NOT
78852: IFFALSE 78856
// exit ;
78854: GO 79558
// pom := GetBase ( depot ) ;
78856: LD_ADDR_VAR 0 10
78860: PUSH
78861: LD_VAR 0 1
78865: PPUSH
78866: CALL_OW 274
78870: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
78871: LD_ADDR_VAR 0 11
78875: PUSH
78876: LD_VAR 0 2
78880: PPUSH
78881: LD_VAR 0 1
78885: PPUSH
78886: CALL_OW 248
78890: PPUSH
78891: CALL_OW 450
78895: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
78896: LD_VAR 0 10
78900: PPUSH
78901: LD_INT 1
78903: PPUSH
78904: CALL_OW 275
78908: PUSH
78909: LD_VAR 0 11
78913: PUSH
78914: LD_INT 1
78916: ARRAY
78917: GREATEREQUAL
78918: PUSH
78919: LD_VAR 0 10
78923: PPUSH
78924: LD_INT 2
78926: PPUSH
78927: CALL_OW 275
78931: PUSH
78932: LD_VAR 0 11
78936: PUSH
78937: LD_INT 2
78939: ARRAY
78940: GREATEREQUAL
78941: AND
78942: PUSH
78943: LD_VAR 0 10
78947: PPUSH
78948: LD_INT 3
78950: PPUSH
78951: CALL_OW 275
78955: PUSH
78956: LD_VAR 0 11
78960: PUSH
78961: LD_INT 3
78963: ARRAY
78964: GREATEREQUAL
78965: AND
78966: NOT
78967: IFFALSE 78971
// exit ;
78969: GO 79558
// if GetBType ( depot ) = b_depot then
78971: LD_VAR 0 1
78975: PPUSH
78976: CALL_OW 266
78980: PUSH
78981: LD_INT 0
78983: EQUAL
78984: IFFALSE 78996
// dist := 28 else
78986: LD_ADDR_VAR 0 14
78990: PUSH
78991: LD_INT 28
78993: ST_TO_ADDR
78994: GO 79004
// dist := 36 ;
78996: LD_ADDR_VAR 0 14
79000: PUSH
79001: LD_INT 36
79003: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
79004: LD_VAR 0 1
79008: PPUSH
79009: LD_VAR 0 3
79013: PPUSH
79014: LD_VAR 0 4
79018: PPUSH
79019: CALL_OW 297
79023: PUSH
79024: LD_VAR 0 14
79028: GREATER
79029: IFFALSE 79033
// exit ;
79031: GO 79558
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
79033: LD_ADDR_VAR 0 12
79037: PUSH
79038: LD_VAR 0 2
79042: PPUSH
79043: LD_VAR 0 3
79047: PPUSH
79048: LD_VAR 0 4
79052: PPUSH
79053: LD_VAR 0 5
79057: PPUSH
79058: LD_VAR 0 1
79062: PPUSH
79063: CALL_OW 248
79067: PPUSH
79068: LD_INT 0
79070: PPUSH
79071: CALL 79563 0 6
79075: ST_TO_ADDR
// if not hexes then
79076: LD_VAR 0 12
79080: NOT
79081: IFFALSE 79085
// exit ;
79083: GO 79558
// hex := GetHexInfo ( x , y ) ;
79085: LD_ADDR_VAR 0 15
79089: PUSH
79090: LD_VAR 0 3
79094: PPUSH
79095: LD_VAR 0 4
79099: PPUSH
79100: CALL_OW 546
79104: ST_TO_ADDR
// if hex [ 1 ] then
79105: LD_VAR 0 15
79109: PUSH
79110: LD_INT 1
79112: ARRAY
79113: IFFALSE 79117
// exit ;
79115: GO 79558
// height := hex [ 2 ] ;
79117: LD_ADDR_VAR 0 13
79121: PUSH
79122: LD_VAR 0 15
79126: PUSH
79127: LD_INT 2
79129: ARRAY
79130: ST_TO_ADDR
// for i = 1 to hexes do
79131: LD_ADDR_VAR 0 7
79135: PUSH
79136: DOUBLE
79137: LD_INT 1
79139: DEC
79140: ST_TO_ADDR
79141: LD_VAR 0 12
79145: PUSH
79146: FOR_TO
79147: IFFALSE 79477
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79149: LD_VAR 0 12
79153: PUSH
79154: LD_VAR 0 7
79158: ARRAY
79159: PUSH
79160: LD_INT 1
79162: ARRAY
79163: PPUSH
79164: LD_VAR 0 12
79168: PUSH
79169: LD_VAR 0 7
79173: ARRAY
79174: PUSH
79175: LD_INT 2
79177: ARRAY
79178: PPUSH
79179: CALL_OW 488
79183: NOT
79184: PUSH
79185: LD_VAR 0 12
79189: PUSH
79190: LD_VAR 0 7
79194: ARRAY
79195: PUSH
79196: LD_INT 1
79198: ARRAY
79199: PPUSH
79200: LD_VAR 0 12
79204: PUSH
79205: LD_VAR 0 7
79209: ARRAY
79210: PUSH
79211: LD_INT 2
79213: ARRAY
79214: PPUSH
79215: CALL_OW 428
79219: PUSH
79220: LD_INT 0
79222: GREATER
79223: OR
79224: PUSH
79225: LD_VAR 0 12
79229: PUSH
79230: LD_VAR 0 7
79234: ARRAY
79235: PUSH
79236: LD_INT 1
79238: ARRAY
79239: PPUSH
79240: LD_VAR 0 12
79244: PUSH
79245: LD_VAR 0 7
79249: ARRAY
79250: PUSH
79251: LD_INT 2
79253: ARRAY
79254: PPUSH
79255: CALL_OW 351
79259: OR
79260: IFFALSE 79266
// exit ;
79262: POP
79263: POP
79264: GO 79558
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79266: LD_ADDR_VAR 0 8
79270: PUSH
79271: LD_VAR 0 12
79275: PUSH
79276: LD_VAR 0 7
79280: ARRAY
79281: PUSH
79282: LD_INT 1
79284: ARRAY
79285: PPUSH
79286: LD_VAR 0 12
79290: PUSH
79291: LD_VAR 0 7
79295: ARRAY
79296: PUSH
79297: LD_INT 2
79299: ARRAY
79300: PPUSH
79301: CALL_OW 546
79305: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79306: LD_VAR 0 8
79310: PUSH
79311: LD_INT 1
79313: ARRAY
79314: PUSH
79315: LD_VAR 0 8
79319: PUSH
79320: LD_INT 2
79322: ARRAY
79323: PUSH
79324: LD_VAR 0 13
79328: PUSH
79329: LD_INT 2
79331: PLUS
79332: GREATER
79333: OR
79334: PUSH
79335: LD_VAR 0 8
79339: PUSH
79340: LD_INT 2
79342: ARRAY
79343: PUSH
79344: LD_VAR 0 13
79348: PUSH
79349: LD_INT 2
79351: MINUS
79352: LESS
79353: OR
79354: PUSH
79355: LD_VAR 0 8
79359: PUSH
79360: LD_INT 3
79362: ARRAY
79363: PUSH
79364: LD_INT 0
79366: PUSH
79367: LD_INT 8
79369: PUSH
79370: LD_INT 9
79372: PUSH
79373: LD_INT 10
79375: PUSH
79376: LD_INT 11
79378: PUSH
79379: LD_INT 12
79381: PUSH
79382: LD_INT 13
79384: PUSH
79385: LD_INT 16
79387: PUSH
79388: LD_INT 17
79390: PUSH
79391: LD_INT 18
79393: PUSH
79394: LD_INT 19
79396: PUSH
79397: LD_INT 20
79399: PUSH
79400: LD_INT 21
79402: PUSH
79403: EMPTY
79404: LIST
79405: LIST
79406: LIST
79407: LIST
79408: LIST
79409: LIST
79410: LIST
79411: LIST
79412: LIST
79413: LIST
79414: LIST
79415: LIST
79416: LIST
79417: IN
79418: NOT
79419: OR
79420: PUSH
79421: LD_VAR 0 8
79425: PUSH
79426: LD_INT 5
79428: ARRAY
79429: NOT
79430: OR
79431: PUSH
79432: LD_VAR 0 8
79436: PUSH
79437: LD_INT 6
79439: ARRAY
79440: PUSH
79441: LD_INT 1
79443: PUSH
79444: LD_INT 2
79446: PUSH
79447: LD_INT 7
79449: PUSH
79450: LD_INT 9
79452: PUSH
79453: LD_INT 10
79455: PUSH
79456: LD_INT 11
79458: PUSH
79459: EMPTY
79460: LIST
79461: LIST
79462: LIST
79463: LIST
79464: LIST
79465: LIST
79466: IN
79467: NOT
79468: OR
79469: IFFALSE 79475
// exit ;
79471: POP
79472: POP
79473: GO 79558
// end ;
79475: GO 79146
79477: POP
79478: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
79479: LD_VAR 0 9
79483: PPUSH
79484: LD_VAR 0 3
79488: PPUSH
79489: LD_VAR 0 4
79493: PPUSH
79494: LD_INT 20
79496: PPUSH
79497: CALL 71504 0 4
79501: PUSH
79502: LD_INT 4
79504: ARRAY
79505: IFFALSE 79509
// exit ;
79507: GO 79558
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
79509: LD_VAR 0 2
79513: PUSH
79514: LD_INT 29
79516: PUSH
79517: LD_INT 30
79519: PUSH
79520: EMPTY
79521: LIST
79522: LIST
79523: IN
79524: PUSH
79525: LD_VAR 0 3
79529: PPUSH
79530: LD_VAR 0 4
79534: PPUSH
79535: LD_VAR 0 9
79539: PPUSH
79540: CALL_OW 440
79544: NOT
79545: AND
79546: IFFALSE 79550
// exit ;
79548: GO 79558
// result := true ;
79550: LD_ADDR_VAR 0 6
79554: PUSH
79555: LD_INT 1
79557: ST_TO_ADDR
// end ;
79558: LD_VAR 0 6
79562: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
79563: LD_INT 0
79565: PPUSH
79566: PPUSH
79567: PPUSH
79568: PPUSH
79569: PPUSH
79570: PPUSH
79571: PPUSH
79572: PPUSH
79573: PPUSH
79574: PPUSH
79575: PPUSH
79576: PPUSH
79577: PPUSH
79578: PPUSH
79579: PPUSH
79580: PPUSH
79581: PPUSH
79582: PPUSH
79583: PPUSH
79584: PPUSH
79585: PPUSH
79586: PPUSH
79587: PPUSH
79588: PPUSH
79589: PPUSH
79590: PPUSH
79591: PPUSH
79592: PPUSH
79593: PPUSH
79594: PPUSH
79595: PPUSH
79596: PPUSH
79597: PPUSH
79598: PPUSH
79599: PPUSH
79600: PPUSH
79601: PPUSH
79602: PPUSH
79603: PPUSH
79604: PPUSH
79605: PPUSH
79606: PPUSH
79607: PPUSH
79608: PPUSH
79609: PPUSH
79610: PPUSH
79611: PPUSH
79612: PPUSH
79613: PPUSH
79614: PPUSH
79615: PPUSH
79616: PPUSH
79617: PPUSH
79618: PPUSH
79619: PPUSH
79620: PPUSH
79621: PPUSH
79622: PPUSH
// result = [ ] ;
79623: LD_ADDR_VAR 0 7
79627: PUSH
79628: EMPTY
79629: ST_TO_ADDR
// temp_list = [ ] ;
79630: LD_ADDR_VAR 0 9
79634: PUSH
79635: EMPTY
79636: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
79637: LD_VAR 0 4
79641: PUSH
79642: LD_INT 0
79644: PUSH
79645: LD_INT 1
79647: PUSH
79648: LD_INT 2
79650: PUSH
79651: LD_INT 3
79653: PUSH
79654: LD_INT 4
79656: PUSH
79657: LD_INT 5
79659: PUSH
79660: EMPTY
79661: LIST
79662: LIST
79663: LIST
79664: LIST
79665: LIST
79666: LIST
79667: IN
79668: NOT
79669: PUSH
79670: LD_VAR 0 1
79674: PUSH
79675: LD_INT 0
79677: PUSH
79678: LD_INT 1
79680: PUSH
79681: EMPTY
79682: LIST
79683: LIST
79684: IN
79685: PUSH
79686: LD_VAR 0 5
79690: PUSH
79691: LD_INT 1
79693: PUSH
79694: LD_INT 2
79696: PUSH
79697: LD_INT 3
79699: PUSH
79700: EMPTY
79701: LIST
79702: LIST
79703: LIST
79704: IN
79705: NOT
79706: AND
79707: OR
79708: IFFALSE 79712
// exit ;
79710: GO 98103
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
79712: LD_VAR 0 1
79716: PUSH
79717: LD_INT 6
79719: PUSH
79720: LD_INT 7
79722: PUSH
79723: LD_INT 8
79725: PUSH
79726: LD_INT 13
79728: PUSH
79729: LD_INT 12
79731: PUSH
79732: LD_INT 15
79734: PUSH
79735: LD_INT 11
79737: PUSH
79738: LD_INT 14
79740: PUSH
79741: LD_INT 10
79743: PUSH
79744: EMPTY
79745: LIST
79746: LIST
79747: LIST
79748: LIST
79749: LIST
79750: LIST
79751: LIST
79752: LIST
79753: LIST
79754: IN
79755: IFFALSE 79765
// btype = b_lab ;
79757: LD_ADDR_VAR 0 1
79761: PUSH
79762: LD_INT 6
79764: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
79765: LD_VAR 0 6
79769: PUSH
79770: LD_INT 0
79772: PUSH
79773: LD_INT 1
79775: PUSH
79776: LD_INT 2
79778: PUSH
79779: EMPTY
79780: LIST
79781: LIST
79782: LIST
79783: IN
79784: NOT
79785: PUSH
79786: LD_VAR 0 1
79790: PUSH
79791: LD_INT 0
79793: PUSH
79794: LD_INT 1
79796: PUSH
79797: LD_INT 2
79799: PUSH
79800: LD_INT 3
79802: PUSH
79803: LD_INT 6
79805: PUSH
79806: LD_INT 36
79808: PUSH
79809: LD_INT 4
79811: PUSH
79812: LD_INT 5
79814: PUSH
79815: LD_INT 31
79817: PUSH
79818: LD_INT 32
79820: PUSH
79821: LD_INT 33
79823: PUSH
79824: EMPTY
79825: LIST
79826: LIST
79827: LIST
79828: LIST
79829: LIST
79830: LIST
79831: LIST
79832: LIST
79833: LIST
79834: LIST
79835: LIST
79836: IN
79837: NOT
79838: PUSH
79839: LD_VAR 0 6
79843: PUSH
79844: LD_INT 1
79846: EQUAL
79847: AND
79848: OR
79849: PUSH
79850: LD_VAR 0 1
79854: PUSH
79855: LD_INT 2
79857: PUSH
79858: LD_INT 3
79860: PUSH
79861: EMPTY
79862: LIST
79863: LIST
79864: IN
79865: NOT
79866: PUSH
79867: LD_VAR 0 6
79871: PUSH
79872: LD_INT 2
79874: EQUAL
79875: AND
79876: OR
79877: IFFALSE 79887
// mode = 0 ;
79879: LD_ADDR_VAR 0 6
79883: PUSH
79884: LD_INT 0
79886: ST_TO_ADDR
// case mode of 0 :
79887: LD_VAR 0 6
79891: PUSH
79892: LD_INT 0
79894: DOUBLE
79895: EQUAL
79896: IFTRUE 79900
79898: GO 91353
79900: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79901: LD_ADDR_VAR 0 11
79905: PUSH
79906: LD_INT 0
79908: PUSH
79909: LD_INT 0
79911: PUSH
79912: EMPTY
79913: LIST
79914: LIST
79915: PUSH
79916: LD_INT 0
79918: PUSH
79919: LD_INT 1
79921: NEG
79922: PUSH
79923: EMPTY
79924: LIST
79925: LIST
79926: PUSH
79927: LD_INT 1
79929: PUSH
79930: LD_INT 0
79932: PUSH
79933: EMPTY
79934: LIST
79935: LIST
79936: PUSH
79937: LD_INT 1
79939: PUSH
79940: LD_INT 1
79942: PUSH
79943: EMPTY
79944: LIST
79945: LIST
79946: PUSH
79947: LD_INT 0
79949: PUSH
79950: LD_INT 1
79952: PUSH
79953: EMPTY
79954: LIST
79955: LIST
79956: PUSH
79957: LD_INT 1
79959: NEG
79960: PUSH
79961: LD_INT 0
79963: PUSH
79964: EMPTY
79965: LIST
79966: LIST
79967: PUSH
79968: LD_INT 1
79970: NEG
79971: PUSH
79972: LD_INT 1
79974: NEG
79975: PUSH
79976: EMPTY
79977: LIST
79978: LIST
79979: PUSH
79980: LD_INT 1
79982: NEG
79983: PUSH
79984: LD_INT 2
79986: NEG
79987: PUSH
79988: EMPTY
79989: LIST
79990: LIST
79991: PUSH
79992: LD_INT 0
79994: PUSH
79995: LD_INT 2
79997: NEG
79998: PUSH
79999: EMPTY
80000: LIST
80001: LIST
80002: PUSH
80003: LD_INT 1
80005: PUSH
80006: LD_INT 1
80008: NEG
80009: PUSH
80010: EMPTY
80011: LIST
80012: LIST
80013: PUSH
80014: LD_INT 1
80016: PUSH
80017: LD_INT 2
80019: PUSH
80020: EMPTY
80021: LIST
80022: LIST
80023: PUSH
80024: LD_INT 0
80026: PUSH
80027: LD_INT 2
80029: PUSH
80030: EMPTY
80031: LIST
80032: LIST
80033: PUSH
80034: LD_INT 1
80036: NEG
80037: PUSH
80038: LD_INT 1
80040: PUSH
80041: EMPTY
80042: LIST
80043: LIST
80044: PUSH
80045: LD_INT 1
80047: PUSH
80048: LD_INT 3
80050: PUSH
80051: EMPTY
80052: LIST
80053: LIST
80054: PUSH
80055: LD_INT 0
80057: PUSH
80058: LD_INT 3
80060: PUSH
80061: EMPTY
80062: LIST
80063: LIST
80064: PUSH
80065: LD_INT 1
80067: NEG
80068: PUSH
80069: LD_INT 2
80071: PUSH
80072: EMPTY
80073: LIST
80074: LIST
80075: PUSH
80076: EMPTY
80077: LIST
80078: LIST
80079: LIST
80080: LIST
80081: LIST
80082: LIST
80083: LIST
80084: LIST
80085: LIST
80086: LIST
80087: LIST
80088: LIST
80089: LIST
80090: LIST
80091: LIST
80092: LIST
80093: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80094: LD_ADDR_VAR 0 12
80098: PUSH
80099: LD_INT 0
80101: PUSH
80102: LD_INT 0
80104: PUSH
80105: EMPTY
80106: LIST
80107: LIST
80108: PUSH
80109: LD_INT 0
80111: PUSH
80112: LD_INT 1
80114: NEG
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: PUSH
80120: LD_INT 1
80122: PUSH
80123: LD_INT 0
80125: PUSH
80126: EMPTY
80127: LIST
80128: LIST
80129: PUSH
80130: LD_INT 1
80132: PUSH
80133: LD_INT 1
80135: PUSH
80136: EMPTY
80137: LIST
80138: LIST
80139: PUSH
80140: LD_INT 0
80142: PUSH
80143: LD_INT 1
80145: PUSH
80146: EMPTY
80147: LIST
80148: LIST
80149: PUSH
80150: LD_INT 1
80152: NEG
80153: PUSH
80154: LD_INT 0
80156: PUSH
80157: EMPTY
80158: LIST
80159: LIST
80160: PUSH
80161: LD_INT 1
80163: NEG
80164: PUSH
80165: LD_INT 1
80167: NEG
80168: PUSH
80169: EMPTY
80170: LIST
80171: LIST
80172: PUSH
80173: LD_INT 1
80175: PUSH
80176: LD_INT 1
80178: NEG
80179: PUSH
80180: EMPTY
80181: LIST
80182: LIST
80183: PUSH
80184: LD_INT 2
80186: PUSH
80187: LD_INT 0
80189: PUSH
80190: EMPTY
80191: LIST
80192: LIST
80193: PUSH
80194: LD_INT 2
80196: PUSH
80197: LD_INT 1
80199: PUSH
80200: EMPTY
80201: LIST
80202: LIST
80203: PUSH
80204: LD_INT 1
80206: NEG
80207: PUSH
80208: LD_INT 1
80210: PUSH
80211: EMPTY
80212: LIST
80213: LIST
80214: PUSH
80215: LD_INT 2
80217: NEG
80218: PUSH
80219: LD_INT 0
80221: PUSH
80222: EMPTY
80223: LIST
80224: LIST
80225: PUSH
80226: LD_INT 2
80228: NEG
80229: PUSH
80230: LD_INT 1
80232: NEG
80233: PUSH
80234: EMPTY
80235: LIST
80236: LIST
80237: PUSH
80238: LD_INT 2
80240: NEG
80241: PUSH
80242: LD_INT 1
80244: PUSH
80245: EMPTY
80246: LIST
80247: LIST
80248: PUSH
80249: LD_INT 3
80251: NEG
80252: PUSH
80253: LD_INT 0
80255: PUSH
80256: EMPTY
80257: LIST
80258: LIST
80259: PUSH
80260: LD_INT 3
80262: NEG
80263: PUSH
80264: LD_INT 1
80266: NEG
80267: PUSH
80268: EMPTY
80269: LIST
80270: LIST
80271: PUSH
80272: EMPTY
80273: LIST
80274: LIST
80275: LIST
80276: LIST
80277: LIST
80278: LIST
80279: LIST
80280: LIST
80281: LIST
80282: LIST
80283: LIST
80284: LIST
80285: LIST
80286: LIST
80287: LIST
80288: LIST
80289: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80290: LD_ADDR_VAR 0 13
80294: PUSH
80295: LD_INT 0
80297: PUSH
80298: LD_INT 0
80300: PUSH
80301: EMPTY
80302: LIST
80303: LIST
80304: PUSH
80305: LD_INT 0
80307: PUSH
80308: LD_INT 1
80310: NEG
80311: PUSH
80312: EMPTY
80313: LIST
80314: LIST
80315: PUSH
80316: LD_INT 1
80318: PUSH
80319: LD_INT 0
80321: PUSH
80322: EMPTY
80323: LIST
80324: LIST
80325: PUSH
80326: LD_INT 1
80328: PUSH
80329: LD_INT 1
80331: PUSH
80332: EMPTY
80333: LIST
80334: LIST
80335: PUSH
80336: LD_INT 0
80338: PUSH
80339: LD_INT 1
80341: PUSH
80342: EMPTY
80343: LIST
80344: LIST
80345: PUSH
80346: LD_INT 1
80348: NEG
80349: PUSH
80350: LD_INT 0
80352: PUSH
80353: EMPTY
80354: LIST
80355: LIST
80356: PUSH
80357: LD_INT 1
80359: NEG
80360: PUSH
80361: LD_INT 1
80363: NEG
80364: PUSH
80365: EMPTY
80366: LIST
80367: LIST
80368: PUSH
80369: LD_INT 1
80371: NEG
80372: PUSH
80373: LD_INT 2
80375: NEG
80376: PUSH
80377: EMPTY
80378: LIST
80379: LIST
80380: PUSH
80381: LD_INT 2
80383: PUSH
80384: LD_INT 1
80386: PUSH
80387: EMPTY
80388: LIST
80389: LIST
80390: PUSH
80391: LD_INT 2
80393: PUSH
80394: LD_INT 2
80396: PUSH
80397: EMPTY
80398: LIST
80399: LIST
80400: PUSH
80401: LD_INT 1
80403: PUSH
80404: LD_INT 2
80406: PUSH
80407: EMPTY
80408: LIST
80409: LIST
80410: PUSH
80411: LD_INT 2
80413: NEG
80414: PUSH
80415: LD_INT 1
80417: NEG
80418: PUSH
80419: EMPTY
80420: LIST
80421: LIST
80422: PUSH
80423: LD_INT 2
80425: NEG
80426: PUSH
80427: LD_INT 2
80429: NEG
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: PUSH
80435: LD_INT 2
80437: NEG
80438: PUSH
80439: LD_INT 3
80441: NEG
80442: PUSH
80443: EMPTY
80444: LIST
80445: LIST
80446: PUSH
80447: LD_INT 3
80449: NEG
80450: PUSH
80451: LD_INT 2
80453: NEG
80454: PUSH
80455: EMPTY
80456: LIST
80457: LIST
80458: PUSH
80459: LD_INT 3
80461: NEG
80462: PUSH
80463: LD_INT 3
80465: NEG
80466: PUSH
80467: EMPTY
80468: LIST
80469: LIST
80470: PUSH
80471: EMPTY
80472: LIST
80473: LIST
80474: LIST
80475: LIST
80476: LIST
80477: LIST
80478: LIST
80479: LIST
80480: LIST
80481: LIST
80482: LIST
80483: LIST
80484: LIST
80485: LIST
80486: LIST
80487: LIST
80488: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80489: LD_ADDR_VAR 0 14
80493: PUSH
80494: LD_INT 0
80496: PUSH
80497: LD_INT 0
80499: PUSH
80500: EMPTY
80501: LIST
80502: LIST
80503: PUSH
80504: LD_INT 0
80506: PUSH
80507: LD_INT 1
80509: NEG
80510: PUSH
80511: EMPTY
80512: LIST
80513: LIST
80514: PUSH
80515: LD_INT 1
80517: PUSH
80518: LD_INT 0
80520: PUSH
80521: EMPTY
80522: LIST
80523: LIST
80524: PUSH
80525: LD_INT 1
80527: PUSH
80528: LD_INT 1
80530: PUSH
80531: EMPTY
80532: LIST
80533: LIST
80534: PUSH
80535: LD_INT 0
80537: PUSH
80538: LD_INT 1
80540: PUSH
80541: EMPTY
80542: LIST
80543: LIST
80544: PUSH
80545: LD_INT 1
80547: NEG
80548: PUSH
80549: LD_INT 0
80551: PUSH
80552: EMPTY
80553: LIST
80554: LIST
80555: PUSH
80556: LD_INT 1
80558: NEG
80559: PUSH
80560: LD_INT 1
80562: NEG
80563: PUSH
80564: EMPTY
80565: LIST
80566: LIST
80567: PUSH
80568: LD_INT 1
80570: NEG
80571: PUSH
80572: LD_INT 2
80574: NEG
80575: PUSH
80576: EMPTY
80577: LIST
80578: LIST
80579: PUSH
80580: LD_INT 0
80582: PUSH
80583: LD_INT 2
80585: NEG
80586: PUSH
80587: EMPTY
80588: LIST
80589: LIST
80590: PUSH
80591: LD_INT 1
80593: PUSH
80594: LD_INT 1
80596: NEG
80597: PUSH
80598: EMPTY
80599: LIST
80600: LIST
80601: PUSH
80602: LD_INT 1
80604: PUSH
80605: LD_INT 2
80607: PUSH
80608: EMPTY
80609: LIST
80610: LIST
80611: PUSH
80612: LD_INT 0
80614: PUSH
80615: LD_INT 2
80617: PUSH
80618: EMPTY
80619: LIST
80620: LIST
80621: PUSH
80622: LD_INT 1
80624: NEG
80625: PUSH
80626: LD_INT 1
80628: PUSH
80629: EMPTY
80630: LIST
80631: LIST
80632: PUSH
80633: LD_INT 1
80635: NEG
80636: PUSH
80637: LD_INT 3
80639: NEG
80640: PUSH
80641: EMPTY
80642: LIST
80643: LIST
80644: PUSH
80645: LD_INT 0
80647: PUSH
80648: LD_INT 3
80650: NEG
80651: PUSH
80652: EMPTY
80653: LIST
80654: LIST
80655: PUSH
80656: LD_INT 1
80658: PUSH
80659: LD_INT 2
80661: NEG
80662: PUSH
80663: EMPTY
80664: LIST
80665: LIST
80666: PUSH
80667: EMPTY
80668: LIST
80669: LIST
80670: LIST
80671: LIST
80672: LIST
80673: LIST
80674: LIST
80675: LIST
80676: LIST
80677: LIST
80678: LIST
80679: LIST
80680: LIST
80681: LIST
80682: LIST
80683: LIST
80684: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80685: LD_ADDR_VAR 0 15
80689: PUSH
80690: LD_INT 0
80692: PUSH
80693: LD_INT 0
80695: PUSH
80696: EMPTY
80697: LIST
80698: LIST
80699: PUSH
80700: LD_INT 0
80702: PUSH
80703: LD_INT 1
80705: NEG
80706: PUSH
80707: EMPTY
80708: LIST
80709: LIST
80710: PUSH
80711: LD_INT 1
80713: PUSH
80714: LD_INT 0
80716: PUSH
80717: EMPTY
80718: LIST
80719: LIST
80720: PUSH
80721: LD_INT 1
80723: PUSH
80724: LD_INT 1
80726: PUSH
80727: EMPTY
80728: LIST
80729: LIST
80730: PUSH
80731: LD_INT 0
80733: PUSH
80734: LD_INT 1
80736: PUSH
80737: EMPTY
80738: LIST
80739: LIST
80740: PUSH
80741: LD_INT 1
80743: NEG
80744: PUSH
80745: LD_INT 0
80747: PUSH
80748: EMPTY
80749: LIST
80750: LIST
80751: PUSH
80752: LD_INT 1
80754: NEG
80755: PUSH
80756: LD_INT 1
80758: NEG
80759: PUSH
80760: EMPTY
80761: LIST
80762: LIST
80763: PUSH
80764: LD_INT 1
80766: PUSH
80767: LD_INT 1
80769: NEG
80770: PUSH
80771: EMPTY
80772: LIST
80773: LIST
80774: PUSH
80775: LD_INT 2
80777: PUSH
80778: LD_INT 0
80780: PUSH
80781: EMPTY
80782: LIST
80783: LIST
80784: PUSH
80785: LD_INT 2
80787: PUSH
80788: LD_INT 1
80790: PUSH
80791: EMPTY
80792: LIST
80793: LIST
80794: PUSH
80795: LD_INT 1
80797: NEG
80798: PUSH
80799: LD_INT 1
80801: PUSH
80802: EMPTY
80803: LIST
80804: LIST
80805: PUSH
80806: LD_INT 2
80808: NEG
80809: PUSH
80810: LD_INT 0
80812: PUSH
80813: EMPTY
80814: LIST
80815: LIST
80816: PUSH
80817: LD_INT 2
80819: NEG
80820: PUSH
80821: LD_INT 1
80823: NEG
80824: PUSH
80825: EMPTY
80826: LIST
80827: LIST
80828: PUSH
80829: LD_INT 2
80831: PUSH
80832: LD_INT 1
80834: NEG
80835: PUSH
80836: EMPTY
80837: LIST
80838: LIST
80839: PUSH
80840: LD_INT 3
80842: PUSH
80843: LD_INT 0
80845: PUSH
80846: EMPTY
80847: LIST
80848: LIST
80849: PUSH
80850: LD_INT 3
80852: PUSH
80853: LD_INT 1
80855: PUSH
80856: EMPTY
80857: LIST
80858: LIST
80859: PUSH
80860: EMPTY
80861: LIST
80862: LIST
80863: LIST
80864: LIST
80865: LIST
80866: LIST
80867: LIST
80868: LIST
80869: LIST
80870: LIST
80871: LIST
80872: LIST
80873: LIST
80874: LIST
80875: LIST
80876: LIST
80877: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80878: LD_ADDR_VAR 0 16
80882: PUSH
80883: LD_INT 0
80885: PUSH
80886: LD_INT 0
80888: PUSH
80889: EMPTY
80890: LIST
80891: LIST
80892: PUSH
80893: LD_INT 0
80895: PUSH
80896: LD_INT 1
80898: NEG
80899: PUSH
80900: EMPTY
80901: LIST
80902: LIST
80903: PUSH
80904: LD_INT 1
80906: PUSH
80907: LD_INT 0
80909: PUSH
80910: EMPTY
80911: LIST
80912: LIST
80913: PUSH
80914: LD_INT 1
80916: PUSH
80917: LD_INT 1
80919: PUSH
80920: EMPTY
80921: LIST
80922: LIST
80923: PUSH
80924: LD_INT 0
80926: PUSH
80927: LD_INT 1
80929: PUSH
80930: EMPTY
80931: LIST
80932: LIST
80933: PUSH
80934: LD_INT 1
80936: NEG
80937: PUSH
80938: LD_INT 0
80940: PUSH
80941: EMPTY
80942: LIST
80943: LIST
80944: PUSH
80945: LD_INT 1
80947: NEG
80948: PUSH
80949: LD_INT 1
80951: NEG
80952: PUSH
80953: EMPTY
80954: LIST
80955: LIST
80956: PUSH
80957: LD_INT 1
80959: NEG
80960: PUSH
80961: LD_INT 2
80963: NEG
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: LD_INT 2
80971: PUSH
80972: LD_INT 1
80974: PUSH
80975: EMPTY
80976: LIST
80977: LIST
80978: PUSH
80979: LD_INT 2
80981: PUSH
80982: LD_INT 2
80984: PUSH
80985: EMPTY
80986: LIST
80987: LIST
80988: PUSH
80989: LD_INT 1
80991: PUSH
80992: LD_INT 2
80994: PUSH
80995: EMPTY
80996: LIST
80997: LIST
80998: PUSH
80999: LD_INT 2
81001: NEG
81002: PUSH
81003: LD_INT 1
81005: NEG
81006: PUSH
81007: EMPTY
81008: LIST
81009: LIST
81010: PUSH
81011: LD_INT 2
81013: NEG
81014: PUSH
81015: LD_INT 2
81017: NEG
81018: PUSH
81019: EMPTY
81020: LIST
81021: LIST
81022: PUSH
81023: LD_INT 3
81025: PUSH
81026: LD_INT 2
81028: PUSH
81029: EMPTY
81030: LIST
81031: LIST
81032: PUSH
81033: LD_INT 3
81035: PUSH
81036: LD_INT 3
81038: PUSH
81039: EMPTY
81040: LIST
81041: LIST
81042: PUSH
81043: LD_INT 2
81045: PUSH
81046: LD_INT 3
81048: PUSH
81049: EMPTY
81050: LIST
81051: LIST
81052: PUSH
81053: EMPTY
81054: LIST
81055: LIST
81056: LIST
81057: LIST
81058: LIST
81059: LIST
81060: LIST
81061: LIST
81062: LIST
81063: LIST
81064: LIST
81065: LIST
81066: LIST
81067: LIST
81068: LIST
81069: LIST
81070: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81071: LD_ADDR_VAR 0 17
81075: PUSH
81076: LD_INT 0
81078: PUSH
81079: LD_INT 0
81081: PUSH
81082: EMPTY
81083: LIST
81084: LIST
81085: PUSH
81086: LD_INT 0
81088: PUSH
81089: LD_INT 1
81091: NEG
81092: PUSH
81093: EMPTY
81094: LIST
81095: LIST
81096: PUSH
81097: LD_INT 1
81099: PUSH
81100: LD_INT 0
81102: PUSH
81103: EMPTY
81104: LIST
81105: LIST
81106: PUSH
81107: LD_INT 1
81109: PUSH
81110: LD_INT 1
81112: PUSH
81113: EMPTY
81114: LIST
81115: LIST
81116: PUSH
81117: LD_INT 0
81119: PUSH
81120: LD_INT 1
81122: PUSH
81123: EMPTY
81124: LIST
81125: LIST
81126: PUSH
81127: LD_INT 1
81129: NEG
81130: PUSH
81131: LD_INT 0
81133: PUSH
81134: EMPTY
81135: LIST
81136: LIST
81137: PUSH
81138: LD_INT 1
81140: NEG
81141: PUSH
81142: LD_INT 1
81144: NEG
81145: PUSH
81146: EMPTY
81147: LIST
81148: LIST
81149: PUSH
81150: LD_INT 1
81152: NEG
81153: PUSH
81154: LD_INT 2
81156: NEG
81157: PUSH
81158: EMPTY
81159: LIST
81160: LIST
81161: PUSH
81162: LD_INT 0
81164: PUSH
81165: LD_INT 2
81167: NEG
81168: PUSH
81169: EMPTY
81170: LIST
81171: LIST
81172: PUSH
81173: LD_INT 1
81175: PUSH
81176: LD_INT 1
81178: NEG
81179: PUSH
81180: EMPTY
81181: LIST
81182: LIST
81183: PUSH
81184: LD_INT 2
81186: PUSH
81187: LD_INT 0
81189: PUSH
81190: EMPTY
81191: LIST
81192: LIST
81193: PUSH
81194: LD_INT 2
81196: PUSH
81197: LD_INT 1
81199: PUSH
81200: EMPTY
81201: LIST
81202: LIST
81203: PUSH
81204: LD_INT 2
81206: PUSH
81207: LD_INT 2
81209: PUSH
81210: EMPTY
81211: LIST
81212: LIST
81213: PUSH
81214: LD_INT 1
81216: PUSH
81217: LD_INT 2
81219: PUSH
81220: EMPTY
81221: LIST
81222: LIST
81223: PUSH
81224: LD_INT 0
81226: PUSH
81227: LD_INT 2
81229: PUSH
81230: EMPTY
81231: LIST
81232: LIST
81233: PUSH
81234: LD_INT 1
81236: NEG
81237: PUSH
81238: LD_INT 1
81240: PUSH
81241: EMPTY
81242: LIST
81243: LIST
81244: PUSH
81245: LD_INT 2
81247: NEG
81248: PUSH
81249: LD_INT 0
81251: PUSH
81252: EMPTY
81253: LIST
81254: LIST
81255: PUSH
81256: LD_INT 2
81258: NEG
81259: PUSH
81260: LD_INT 1
81262: NEG
81263: PUSH
81264: EMPTY
81265: LIST
81266: LIST
81267: PUSH
81268: LD_INT 2
81270: NEG
81271: PUSH
81272: LD_INT 2
81274: NEG
81275: PUSH
81276: EMPTY
81277: LIST
81278: LIST
81279: PUSH
81280: EMPTY
81281: LIST
81282: LIST
81283: LIST
81284: LIST
81285: LIST
81286: LIST
81287: LIST
81288: LIST
81289: LIST
81290: LIST
81291: LIST
81292: LIST
81293: LIST
81294: LIST
81295: LIST
81296: LIST
81297: LIST
81298: LIST
81299: LIST
81300: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81301: LD_ADDR_VAR 0 18
81305: PUSH
81306: LD_INT 0
81308: PUSH
81309: LD_INT 0
81311: PUSH
81312: EMPTY
81313: LIST
81314: LIST
81315: PUSH
81316: LD_INT 0
81318: PUSH
81319: LD_INT 1
81321: NEG
81322: PUSH
81323: EMPTY
81324: LIST
81325: LIST
81326: PUSH
81327: LD_INT 1
81329: PUSH
81330: LD_INT 0
81332: PUSH
81333: EMPTY
81334: LIST
81335: LIST
81336: PUSH
81337: LD_INT 1
81339: PUSH
81340: LD_INT 1
81342: PUSH
81343: EMPTY
81344: LIST
81345: LIST
81346: PUSH
81347: LD_INT 0
81349: PUSH
81350: LD_INT 1
81352: PUSH
81353: EMPTY
81354: LIST
81355: LIST
81356: PUSH
81357: LD_INT 1
81359: NEG
81360: PUSH
81361: LD_INT 0
81363: PUSH
81364: EMPTY
81365: LIST
81366: LIST
81367: PUSH
81368: LD_INT 1
81370: NEG
81371: PUSH
81372: LD_INT 1
81374: NEG
81375: PUSH
81376: EMPTY
81377: LIST
81378: LIST
81379: PUSH
81380: LD_INT 1
81382: NEG
81383: PUSH
81384: LD_INT 2
81386: NEG
81387: PUSH
81388: EMPTY
81389: LIST
81390: LIST
81391: PUSH
81392: LD_INT 0
81394: PUSH
81395: LD_INT 2
81397: NEG
81398: PUSH
81399: EMPTY
81400: LIST
81401: LIST
81402: PUSH
81403: LD_INT 1
81405: PUSH
81406: LD_INT 1
81408: NEG
81409: PUSH
81410: EMPTY
81411: LIST
81412: LIST
81413: PUSH
81414: LD_INT 2
81416: PUSH
81417: LD_INT 0
81419: PUSH
81420: EMPTY
81421: LIST
81422: LIST
81423: PUSH
81424: LD_INT 2
81426: PUSH
81427: LD_INT 1
81429: PUSH
81430: EMPTY
81431: LIST
81432: LIST
81433: PUSH
81434: LD_INT 2
81436: PUSH
81437: LD_INT 2
81439: PUSH
81440: EMPTY
81441: LIST
81442: LIST
81443: PUSH
81444: LD_INT 1
81446: PUSH
81447: LD_INT 2
81449: PUSH
81450: EMPTY
81451: LIST
81452: LIST
81453: PUSH
81454: LD_INT 0
81456: PUSH
81457: LD_INT 2
81459: PUSH
81460: EMPTY
81461: LIST
81462: LIST
81463: PUSH
81464: LD_INT 1
81466: NEG
81467: PUSH
81468: LD_INT 1
81470: PUSH
81471: EMPTY
81472: LIST
81473: LIST
81474: PUSH
81475: LD_INT 2
81477: NEG
81478: PUSH
81479: LD_INT 0
81481: PUSH
81482: EMPTY
81483: LIST
81484: LIST
81485: PUSH
81486: LD_INT 2
81488: NEG
81489: PUSH
81490: LD_INT 1
81492: NEG
81493: PUSH
81494: EMPTY
81495: LIST
81496: LIST
81497: PUSH
81498: LD_INT 2
81500: NEG
81501: PUSH
81502: LD_INT 2
81504: NEG
81505: PUSH
81506: EMPTY
81507: LIST
81508: LIST
81509: PUSH
81510: EMPTY
81511: LIST
81512: LIST
81513: LIST
81514: LIST
81515: LIST
81516: LIST
81517: LIST
81518: LIST
81519: LIST
81520: LIST
81521: LIST
81522: LIST
81523: LIST
81524: LIST
81525: LIST
81526: LIST
81527: LIST
81528: LIST
81529: LIST
81530: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81531: LD_ADDR_VAR 0 19
81535: PUSH
81536: LD_INT 0
81538: PUSH
81539: LD_INT 0
81541: PUSH
81542: EMPTY
81543: LIST
81544: LIST
81545: PUSH
81546: LD_INT 0
81548: PUSH
81549: LD_INT 1
81551: NEG
81552: PUSH
81553: EMPTY
81554: LIST
81555: LIST
81556: PUSH
81557: LD_INT 1
81559: PUSH
81560: LD_INT 0
81562: PUSH
81563: EMPTY
81564: LIST
81565: LIST
81566: PUSH
81567: LD_INT 1
81569: PUSH
81570: LD_INT 1
81572: PUSH
81573: EMPTY
81574: LIST
81575: LIST
81576: PUSH
81577: LD_INT 0
81579: PUSH
81580: LD_INT 1
81582: PUSH
81583: EMPTY
81584: LIST
81585: LIST
81586: PUSH
81587: LD_INT 1
81589: NEG
81590: PUSH
81591: LD_INT 0
81593: PUSH
81594: EMPTY
81595: LIST
81596: LIST
81597: PUSH
81598: LD_INT 1
81600: NEG
81601: PUSH
81602: LD_INT 1
81604: NEG
81605: PUSH
81606: EMPTY
81607: LIST
81608: LIST
81609: PUSH
81610: LD_INT 1
81612: NEG
81613: PUSH
81614: LD_INT 2
81616: NEG
81617: PUSH
81618: EMPTY
81619: LIST
81620: LIST
81621: PUSH
81622: LD_INT 0
81624: PUSH
81625: LD_INT 2
81627: NEG
81628: PUSH
81629: EMPTY
81630: LIST
81631: LIST
81632: PUSH
81633: LD_INT 1
81635: PUSH
81636: LD_INT 1
81638: NEG
81639: PUSH
81640: EMPTY
81641: LIST
81642: LIST
81643: PUSH
81644: LD_INT 2
81646: PUSH
81647: LD_INT 0
81649: PUSH
81650: EMPTY
81651: LIST
81652: LIST
81653: PUSH
81654: LD_INT 2
81656: PUSH
81657: LD_INT 1
81659: PUSH
81660: EMPTY
81661: LIST
81662: LIST
81663: PUSH
81664: LD_INT 2
81666: PUSH
81667: LD_INT 2
81669: PUSH
81670: EMPTY
81671: LIST
81672: LIST
81673: PUSH
81674: LD_INT 1
81676: PUSH
81677: LD_INT 2
81679: PUSH
81680: EMPTY
81681: LIST
81682: LIST
81683: PUSH
81684: LD_INT 0
81686: PUSH
81687: LD_INT 2
81689: PUSH
81690: EMPTY
81691: LIST
81692: LIST
81693: PUSH
81694: LD_INT 1
81696: NEG
81697: PUSH
81698: LD_INT 1
81700: PUSH
81701: EMPTY
81702: LIST
81703: LIST
81704: PUSH
81705: LD_INT 2
81707: NEG
81708: PUSH
81709: LD_INT 0
81711: PUSH
81712: EMPTY
81713: LIST
81714: LIST
81715: PUSH
81716: LD_INT 2
81718: NEG
81719: PUSH
81720: LD_INT 1
81722: NEG
81723: PUSH
81724: EMPTY
81725: LIST
81726: LIST
81727: PUSH
81728: LD_INT 2
81730: NEG
81731: PUSH
81732: LD_INT 2
81734: NEG
81735: PUSH
81736: EMPTY
81737: LIST
81738: LIST
81739: PUSH
81740: EMPTY
81741: LIST
81742: LIST
81743: LIST
81744: LIST
81745: LIST
81746: LIST
81747: LIST
81748: LIST
81749: LIST
81750: LIST
81751: LIST
81752: LIST
81753: LIST
81754: LIST
81755: LIST
81756: LIST
81757: LIST
81758: LIST
81759: LIST
81760: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81761: LD_ADDR_VAR 0 20
81765: PUSH
81766: LD_INT 0
81768: PUSH
81769: LD_INT 0
81771: PUSH
81772: EMPTY
81773: LIST
81774: LIST
81775: PUSH
81776: LD_INT 0
81778: PUSH
81779: LD_INT 1
81781: NEG
81782: PUSH
81783: EMPTY
81784: LIST
81785: LIST
81786: PUSH
81787: LD_INT 1
81789: PUSH
81790: LD_INT 0
81792: PUSH
81793: EMPTY
81794: LIST
81795: LIST
81796: PUSH
81797: LD_INT 1
81799: PUSH
81800: LD_INT 1
81802: PUSH
81803: EMPTY
81804: LIST
81805: LIST
81806: PUSH
81807: LD_INT 0
81809: PUSH
81810: LD_INT 1
81812: PUSH
81813: EMPTY
81814: LIST
81815: LIST
81816: PUSH
81817: LD_INT 1
81819: NEG
81820: PUSH
81821: LD_INT 0
81823: PUSH
81824: EMPTY
81825: LIST
81826: LIST
81827: PUSH
81828: LD_INT 1
81830: NEG
81831: PUSH
81832: LD_INT 1
81834: NEG
81835: PUSH
81836: EMPTY
81837: LIST
81838: LIST
81839: PUSH
81840: LD_INT 1
81842: NEG
81843: PUSH
81844: LD_INT 2
81846: NEG
81847: PUSH
81848: EMPTY
81849: LIST
81850: LIST
81851: PUSH
81852: LD_INT 0
81854: PUSH
81855: LD_INT 2
81857: NEG
81858: PUSH
81859: EMPTY
81860: LIST
81861: LIST
81862: PUSH
81863: LD_INT 1
81865: PUSH
81866: LD_INT 1
81868: NEG
81869: PUSH
81870: EMPTY
81871: LIST
81872: LIST
81873: PUSH
81874: LD_INT 2
81876: PUSH
81877: LD_INT 0
81879: PUSH
81880: EMPTY
81881: LIST
81882: LIST
81883: PUSH
81884: LD_INT 2
81886: PUSH
81887: LD_INT 1
81889: PUSH
81890: EMPTY
81891: LIST
81892: LIST
81893: PUSH
81894: LD_INT 2
81896: PUSH
81897: LD_INT 2
81899: PUSH
81900: EMPTY
81901: LIST
81902: LIST
81903: PUSH
81904: LD_INT 1
81906: PUSH
81907: LD_INT 2
81909: PUSH
81910: EMPTY
81911: LIST
81912: LIST
81913: PUSH
81914: LD_INT 0
81916: PUSH
81917: LD_INT 2
81919: PUSH
81920: EMPTY
81921: LIST
81922: LIST
81923: PUSH
81924: LD_INT 1
81926: NEG
81927: PUSH
81928: LD_INT 1
81930: PUSH
81931: EMPTY
81932: LIST
81933: LIST
81934: PUSH
81935: LD_INT 2
81937: NEG
81938: PUSH
81939: LD_INT 0
81941: PUSH
81942: EMPTY
81943: LIST
81944: LIST
81945: PUSH
81946: LD_INT 2
81948: NEG
81949: PUSH
81950: LD_INT 1
81952: NEG
81953: PUSH
81954: EMPTY
81955: LIST
81956: LIST
81957: PUSH
81958: LD_INT 2
81960: NEG
81961: PUSH
81962: LD_INT 2
81964: NEG
81965: PUSH
81966: EMPTY
81967: LIST
81968: LIST
81969: PUSH
81970: EMPTY
81971: LIST
81972: LIST
81973: LIST
81974: LIST
81975: LIST
81976: LIST
81977: LIST
81978: LIST
81979: LIST
81980: LIST
81981: LIST
81982: LIST
81983: LIST
81984: LIST
81985: LIST
81986: LIST
81987: LIST
81988: LIST
81989: LIST
81990: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81991: LD_ADDR_VAR 0 21
81995: PUSH
81996: LD_INT 0
81998: PUSH
81999: LD_INT 0
82001: PUSH
82002: EMPTY
82003: LIST
82004: LIST
82005: PUSH
82006: LD_INT 0
82008: PUSH
82009: LD_INT 1
82011: NEG
82012: PUSH
82013: EMPTY
82014: LIST
82015: LIST
82016: PUSH
82017: LD_INT 1
82019: PUSH
82020: LD_INT 0
82022: PUSH
82023: EMPTY
82024: LIST
82025: LIST
82026: PUSH
82027: LD_INT 1
82029: PUSH
82030: LD_INT 1
82032: PUSH
82033: EMPTY
82034: LIST
82035: LIST
82036: PUSH
82037: LD_INT 0
82039: PUSH
82040: LD_INT 1
82042: PUSH
82043: EMPTY
82044: LIST
82045: LIST
82046: PUSH
82047: LD_INT 1
82049: NEG
82050: PUSH
82051: LD_INT 0
82053: PUSH
82054: EMPTY
82055: LIST
82056: LIST
82057: PUSH
82058: LD_INT 1
82060: NEG
82061: PUSH
82062: LD_INT 1
82064: NEG
82065: PUSH
82066: EMPTY
82067: LIST
82068: LIST
82069: PUSH
82070: LD_INT 1
82072: NEG
82073: PUSH
82074: LD_INT 2
82076: NEG
82077: PUSH
82078: EMPTY
82079: LIST
82080: LIST
82081: PUSH
82082: LD_INT 0
82084: PUSH
82085: LD_INT 2
82087: NEG
82088: PUSH
82089: EMPTY
82090: LIST
82091: LIST
82092: PUSH
82093: LD_INT 1
82095: PUSH
82096: LD_INT 1
82098: NEG
82099: PUSH
82100: EMPTY
82101: LIST
82102: LIST
82103: PUSH
82104: LD_INT 2
82106: PUSH
82107: LD_INT 0
82109: PUSH
82110: EMPTY
82111: LIST
82112: LIST
82113: PUSH
82114: LD_INT 2
82116: PUSH
82117: LD_INT 1
82119: PUSH
82120: EMPTY
82121: LIST
82122: LIST
82123: PUSH
82124: LD_INT 2
82126: PUSH
82127: LD_INT 2
82129: PUSH
82130: EMPTY
82131: LIST
82132: LIST
82133: PUSH
82134: LD_INT 1
82136: PUSH
82137: LD_INT 2
82139: PUSH
82140: EMPTY
82141: LIST
82142: LIST
82143: PUSH
82144: LD_INT 0
82146: PUSH
82147: LD_INT 2
82149: PUSH
82150: EMPTY
82151: LIST
82152: LIST
82153: PUSH
82154: LD_INT 1
82156: NEG
82157: PUSH
82158: LD_INT 1
82160: PUSH
82161: EMPTY
82162: LIST
82163: LIST
82164: PUSH
82165: LD_INT 2
82167: NEG
82168: PUSH
82169: LD_INT 0
82171: PUSH
82172: EMPTY
82173: LIST
82174: LIST
82175: PUSH
82176: LD_INT 2
82178: NEG
82179: PUSH
82180: LD_INT 1
82182: NEG
82183: PUSH
82184: EMPTY
82185: LIST
82186: LIST
82187: PUSH
82188: LD_INT 2
82190: NEG
82191: PUSH
82192: LD_INT 2
82194: NEG
82195: PUSH
82196: EMPTY
82197: LIST
82198: LIST
82199: PUSH
82200: EMPTY
82201: LIST
82202: LIST
82203: LIST
82204: LIST
82205: LIST
82206: LIST
82207: LIST
82208: LIST
82209: LIST
82210: LIST
82211: LIST
82212: LIST
82213: LIST
82214: LIST
82215: LIST
82216: LIST
82217: LIST
82218: LIST
82219: LIST
82220: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82221: LD_ADDR_VAR 0 22
82225: PUSH
82226: LD_INT 0
82228: PUSH
82229: LD_INT 0
82231: PUSH
82232: EMPTY
82233: LIST
82234: LIST
82235: PUSH
82236: LD_INT 0
82238: PUSH
82239: LD_INT 1
82241: NEG
82242: PUSH
82243: EMPTY
82244: LIST
82245: LIST
82246: PUSH
82247: LD_INT 1
82249: PUSH
82250: LD_INT 0
82252: PUSH
82253: EMPTY
82254: LIST
82255: LIST
82256: PUSH
82257: LD_INT 1
82259: PUSH
82260: LD_INT 1
82262: PUSH
82263: EMPTY
82264: LIST
82265: LIST
82266: PUSH
82267: LD_INT 0
82269: PUSH
82270: LD_INT 1
82272: PUSH
82273: EMPTY
82274: LIST
82275: LIST
82276: PUSH
82277: LD_INT 1
82279: NEG
82280: PUSH
82281: LD_INT 0
82283: PUSH
82284: EMPTY
82285: LIST
82286: LIST
82287: PUSH
82288: LD_INT 1
82290: NEG
82291: PUSH
82292: LD_INT 1
82294: NEG
82295: PUSH
82296: EMPTY
82297: LIST
82298: LIST
82299: PUSH
82300: LD_INT 1
82302: NEG
82303: PUSH
82304: LD_INT 2
82306: NEG
82307: PUSH
82308: EMPTY
82309: LIST
82310: LIST
82311: PUSH
82312: LD_INT 0
82314: PUSH
82315: LD_INT 2
82317: NEG
82318: PUSH
82319: EMPTY
82320: LIST
82321: LIST
82322: PUSH
82323: LD_INT 1
82325: PUSH
82326: LD_INT 1
82328: NEG
82329: PUSH
82330: EMPTY
82331: LIST
82332: LIST
82333: PUSH
82334: LD_INT 2
82336: PUSH
82337: LD_INT 0
82339: PUSH
82340: EMPTY
82341: LIST
82342: LIST
82343: PUSH
82344: LD_INT 2
82346: PUSH
82347: LD_INT 1
82349: PUSH
82350: EMPTY
82351: LIST
82352: LIST
82353: PUSH
82354: LD_INT 2
82356: PUSH
82357: LD_INT 2
82359: PUSH
82360: EMPTY
82361: LIST
82362: LIST
82363: PUSH
82364: LD_INT 1
82366: PUSH
82367: LD_INT 2
82369: PUSH
82370: EMPTY
82371: LIST
82372: LIST
82373: PUSH
82374: LD_INT 0
82376: PUSH
82377: LD_INT 2
82379: PUSH
82380: EMPTY
82381: LIST
82382: LIST
82383: PUSH
82384: LD_INT 1
82386: NEG
82387: PUSH
82388: LD_INT 1
82390: PUSH
82391: EMPTY
82392: LIST
82393: LIST
82394: PUSH
82395: LD_INT 2
82397: NEG
82398: PUSH
82399: LD_INT 0
82401: PUSH
82402: EMPTY
82403: LIST
82404: LIST
82405: PUSH
82406: LD_INT 2
82408: NEG
82409: PUSH
82410: LD_INT 1
82412: NEG
82413: PUSH
82414: EMPTY
82415: LIST
82416: LIST
82417: PUSH
82418: LD_INT 2
82420: NEG
82421: PUSH
82422: LD_INT 2
82424: NEG
82425: PUSH
82426: EMPTY
82427: LIST
82428: LIST
82429: PUSH
82430: EMPTY
82431: LIST
82432: LIST
82433: LIST
82434: LIST
82435: LIST
82436: LIST
82437: LIST
82438: LIST
82439: LIST
82440: LIST
82441: LIST
82442: LIST
82443: LIST
82444: LIST
82445: LIST
82446: LIST
82447: LIST
82448: LIST
82449: LIST
82450: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
82451: LD_ADDR_VAR 0 23
82455: PUSH
82456: LD_INT 0
82458: PUSH
82459: LD_INT 0
82461: PUSH
82462: EMPTY
82463: LIST
82464: LIST
82465: PUSH
82466: LD_INT 0
82468: PUSH
82469: LD_INT 1
82471: NEG
82472: PUSH
82473: EMPTY
82474: LIST
82475: LIST
82476: PUSH
82477: LD_INT 1
82479: PUSH
82480: LD_INT 0
82482: PUSH
82483: EMPTY
82484: LIST
82485: LIST
82486: PUSH
82487: LD_INT 1
82489: PUSH
82490: LD_INT 1
82492: PUSH
82493: EMPTY
82494: LIST
82495: LIST
82496: PUSH
82497: LD_INT 0
82499: PUSH
82500: LD_INT 1
82502: PUSH
82503: EMPTY
82504: LIST
82505: LIST
82506: PUSH
82507: LD_INT 1
82509: NEG
82510: PUSH
82511: LD_INT 0
82513: PUSH
82514: EMPTY
82515: LIST
82516: LIST
82517: PUSH
82518: LD_INT 1
82520: NEG
82521: PUSH
82522: LD_INT 1
82524: NEG
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: PUSH
82530: LD_INT 1
82532: NEG
82533: PUSH
82534: LD_INT 2
82536: NEG
82537: PUSH
82538: EMPTY
82539: LIST
82540: LIST
82541: PUSH
82542: LD_INT 0
82544: PUSH
82545: LD_INT 2
82547: NEG
82548: PUSH
82549: EMPTY
82550: LIST
82551: LIST
82552: PUSH
82553: LD_INT 1
82555: PUSH
82556: LD_INT 1
82558: NEG
82559: PUSH
82560: EMPTY
82561: LIST
82562: LIST
82563: PUSH
82564: LD_INT 2
82566: PUSH
82567: LD_INT 0
82569: PUSH
82570: EMPTY
82571: LIST
82572: LIST
82573: PUSH
82574: LD_INT 2
82576: PUSH
82577: LD_INT 1
82579: PUSH
82580: EMPTY
82581: LIST
82582: LIST
82583: PUSH
82584: LD_INT 2
82586: PUSH
82587: LD_INT 2
82589: PUSH
82590: EMPTY
82591: LIST
82592: LIST
82593: PUSH
82594: LD_INT 1
82596: PUSH
82597: LD_INT 2
82599: PUSH
82600: EMPTY
82601: LIST
82602: LIST
82603: PUSH
82604: LD_INT 0
82606: PUSH
82607: LD_INT 2
82609: PUSH
82610: EMPTY
82611: LIST
82612: LIST
82613: PUSH
82614: LD_INT 1
82616: NEG
82617: PUSH
82618: LD_INT 1
82620: PUSH
82621: EMPTY
82622: LIST
82623: LIST
82624: PUSH
82625: LD_INT 2
82627: NEG
82628: PUSH
82629: LD_INT 0
82631: PUSH
82632: EMPTY
82633: LIST
82634: LIST
82635: PUSH
82636: LD_INT 2
82638: NEG
82639: PUSH
82640: LD_INT 1
82642: NEG
82643: PUSH
82644: EMPTY
82645: LIST
82646: LIST
82647: PUSH
82648: LD_INT 2
82650: NEG
82651: PUSH
82652: LD_INT 2
82654: NEG
82655: PUSH
82656: EMPTY
82657: LIST
82658: LIST
82659: PUSH
82660: LD_INT 2
82662: NEG
82663: PUSH
82664: LD_INT 3
82666: NEG
82667: PUSH
82668: EMPTY
82669: LIST
82670: LIST
82671: PUSH
82672: LD_INT 1
82674: NEG
82675: PUSH
82676: LD_INT 3
82678: NEG
82679: PUSH
82680: EMPTY
82681: LIST
82682: LIST
82683: PUSH
82684: LD_INT 1
82686: PUSH
82687: LD_INT 2
82689: NEG
82690: PUSH
82691: EMPTY
82692: LIST
82693: LIST
82694: PUSH
82695: LD_INT 2
82697: PUSH
82698: LD_INT 1
82700: NEG
82701: PUSH
82702: EMPTY
82703: LIST
82704: LIST
82705: PUSH
82706: EMPTY
82707: LIST
82708: LIST
82709: LIST
82710: LIST
82711: LIST
82712: LIST
82713: LIST
82714: LIST
82715: LIST
82716: LIST
82717: LIST
82718: LIST
82719: LIST
82720: LIST
82721: LIST
82722: LIST
82723: LIST
82724: LIST
82725: LIST
82726: LIST
82727: LIST
82728: LIST
82729: LIST
82730: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
82731: LD_ADDR_VAR 0 24
82735: PUSH
82736: LD_INT 0
82738: PUSH
82739: LD_INT 0
82741: PUSH
82742: EMPTY
82743: LIST
82744: LIST
82745: PUSH
82746: LD_INT 0
82748: PUSH
82749: LD_INT 1
82751: NEG
82752: PUSH
82753: EMPTY
82754: LIST
82755: LIST
82756: PUSH
82757: LD_INT 1
82759: PUSH
82760: LD_INT 0
82762: PUSH
82763: EMPTY
82764: LIST
82765: LIST
82766: PUSH
82767: LD_INT 1
82769: PUSH
82770: LD_INT 1
82772: PUSH
82773: EMPTY
82774: LIST
82775: LIST
82776: PUSH
82777: LD_INT 0
82779: PUSH
82780: LD_INT 1
82782: PUSH
82783: EMPTY
82784: LIST
82785: LIST
82786: PUSH
82787: LD_INT 1
82789: NEG
82790: PUSH
82791: LD_INT 0
82793: PUSH
82794: EMPTY
82795: LIST
82796: LIST
82797: PUSH
82798: LD_INT 1
82800: NEG
82801: PUSH
82802: LD_INT 1
82804: NEG
82805: PUSH
82806: EMPTY
82807: LIST
82808: LIST
82809: PUSH
82810: LD_INT 1
82812: NEG
82813: PUSH
82814: LD_INT 2
82816: NEG
82817: PUSH
82818: EMPTY
82819: LIST
82820: LIST
82821: PUSH
82822: LD_INT 0
82824: PUSH
82825: LD_INT 2
82827: NEG
82828: PUSH
82829: EMPTY
82830: LIST
82831: LIST
82832: PUSH
82833: LD_INT 1
82835: PUSH
82836: LD_INT 1
82838: NEG
82839: PUSH
82840: EMPTY
82841: LIST
82842: LIST
82843: PUSH
82844: LD_INT 2
82846: PUSH
82847: LD_INT 0
82849: PUSH
82850: EMPTY
82851: LIST
82852: LIST
82853: PUSH
82854: LD_INT 2
82856: PUSH
82857: LD_INT 1
82859: PUSH
82860: EMPTY
82861: LIST
82862: LIST
82863: PUSH
82864: LD_INT 2
82866: PUSH
82867: LD_INT 2
82869: PUSH
82870: EMPTY
82871: LIST
82872: LIST
82873: PUSH
82874: LD_INT 1
82876: PUSH
82877: LD_INT 2
82879: PUSH
82880: EMPTY
82881: LIST
82882: LIST
82883: PUSH
82884: LD_INT 0
82886: PUSH
82887: LD_INT 2
82889: PUSH
82890: EMPTY
82891: LIST
82892: LIST
82893: PUSH
82894: LD_INT 1
82896: NEG
82897: PUSH
82898: LD_INT 1
82900: PUSH
82901: EMPTY
82902: LIST
82903: LIST
82904: PUSH
82905: LD_INT 2
82907: NEG
82908: PUSH
82909: LD_INT 0
82911: PUSH
82912: EMPTY
82913: LIST
82914: LIST
82915: PUSH
82916: LD_INT 2
82918: NEG
82919: PUSH
82920: LD_INT 1
82922: NEG
82923: PUSH
82924: EMPTY
82925: LIST
82926: LIST
82927: PUSH
82928: LD_INT 2
82930: NEG
82931: PUSH
82932: LD_INT 2
82934: NEG
82935: PUSH
82936: EMPTY
82937: LIST
82938: LIST
82939: PUSH
82940: LD_INT 1
82942: PUSH
82943: LD_INT 2
82945: NEG
82946: PUSH
82947: EMPTY
82948: LIST
82949: LIST
82950: PUSH
82951: LD_INT 2
82953: PUSH
82954: LD_INT 1
82956: NEG
82957: PUSH
82958: EMPTY
82959: LIST
82960: LIST
82961: PUSH
82962: LD_INT 3
82964: PUSH
82965: LD_INT 1
82967: PUSH
82968: EMPTY
82969: LIST
82970: LIST
82971: PUSH
82972: LD_INT 3
82974: PUSH
82975: LD_INT 2
82977: PUSH
82978: EMPTY
82979: LIST
82980: LIST
82981: PUSH
82982: EMPTY
82983: LIST
82984: LIST
82985: LIST
82986: LIST
82987: LIST
82988: LIST
82989: LIST
82990: LIST
82991: LIST
82992: LIST
82993: LIST
82994: LIST
82995: LIST
82996: LIST
82997: LIST
82998: LIST
82999: LIST
83000: LIST
83001: LIST
83002: LIST
83003: LIST
83004: LIST
83005: LIST
83006: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
83007: LD_ADDR_VAR 0 25
83011: PUSH
83012: LD_INT 0
83014: PUSH
83015: LD_INT 0
83017: PUSH
83018: EMPTY
83019: LIST
83020: LIST
83021: PUSH
83022: LD_INT 0
83024: PUSH
83025: LD_INT 1
83027: NEG
83028: PUSH
83029: EMPTY
83030: LIST
83031: LIST
83032: PUSH
83033: LD_INT 1
83035: PUSH
83036: LD_INT 0
83038: PUSH
83039: EMPTY
83040: LIST
83041: LIST
83042: PUSH
83043: LD_INT 1
83045: PUSH
83046: LD_INT 1
83048: PUSH
83049: EMPTY
83050: LIST
83051: LIST
83052: PUSH
83053: LD_INT 0
83055: PUSH
83056: LD_INT 1
83058: PUSH
83059: EMPTY
83060: LIST
83061: LIST
83062: PUSH
83063: LD_INT 1
83065: NEG
83066: PUSH
83067: LD_INT 0
83069: PUSH
83070: EMPTY
83071: LIST
83072: LIST
83073: PUSH
83074: LD_INT 1
83076: NEG
83077: PUSH
83078: LD_INT 1
83080: NEG
83081: PUSH
83082: EMPTY
83083: LIST
83084: LIST
83085: PUSH
83086: LD_INT 1
83088: NEG
83089: PUSH
83090: LD_INT 2
83092: NEG
83093: PUSH
83094: EMPTY
83095: LIST
83096: LIST
83097: PUSH
83098: LD_INT 0
83100: PUSH
83101: LD_INT 2
83103: NEG
83104: PUSH
83105: EMPTY
83106: LIST
83107: LIST
83108: PUSH
83109: LD_INT 1
83111: PUSH
83112: LD_INT 1
83114: NEG
83115: PUSH
83116: EMPTY
83117: LIST
83118: LIST
83119: PUSH
83120: LD_INT 2
83122: PUSH
83123: LD_INT 0
83125: PUSH
83126: EMPTY
83127: LIST
83128: LIST
83129: PUSH
83130: LD_INT 2
83132: PUSH
83133: LD_INT 1
83135: PUSH
83136: EMPTY
83137: LIST
83138: LIST
83139: PUSH
83140: LD_INT 2
83142: PUSH
83143: LD_INT 2
83145: PUSH
83146: EMPTY
83147: LIST
83148: LIST
83149: PUSH
83150: LD_INT 1
83152: PUSH
83153: LD_INT 2
83155: PUSH
83156: EMPTY
83157: LIST
83158: LIST
83159: PUSH
83160: LD_INT 0
83162: PUSH
83163: LD_INT 2
83165: PUSH
83166: EMPTY
83167: LIST
83168: LIST
83169: PUSH
83170: LD_INT 1
83172: NEG
83173: PUSH
83174: LD_INT 1
83176: PUSH
83177: EMPTY
83178: LIST
83179: LIST
83180: PUSH
83181: LD_INT 2
83183: NEG
83184: PUSH
83185: LD_INT 0
83187: PUSH
83188: EMPTY
83189: LIST
83190: LIST
83191: PUSH
83192: LD_INT 2
83194: NEG
83195: PUSH
83196: LD_INT 1
83198: NEG
83199: PUSH
83200: EMPTY
83201: LIST
83202: LIST
83203: PUSH
83204: LD_INT 2
83206: NEG
83207: PUSH
83208: LD_INT 2
83210: NEG
83211: PUSH
83212: EMPTY
83213: LIST
83214: LIST
83215: PUSH
83216: LD_INT 3
83218: PUSH
83219: LD_INT 1
83221: PUSH
83222: EMPTY
83223: LIST
83224: LIST
83225: PUSH
83226: LD_INT 3
83228: PUSH
83229: LD_INT 2
83231: PUSH
83232: EMPTY
83233: LIST
83234: LIST
83235: PUSH
83236: LD_INT 2
83238: PUSH
83239: LD_INT 3
83241: PUSH
83242: EMPTY
83243: LIST
83244: LIST
83245: PUSH
83246: LD_INT 1
83248: PUSH
83249: LD_INT 3
83251: PUSH
83252: EMPTY
83253: LIST
83254: LIST
83255: PUSH
83256: EMPTY
83257: LIST
83258: LIST
83259: LIST
83260: LIST
83261: LIST
83262: LIST
83263: LIST
83264: LIST
83265: LIST
83266: LIST
83267: LIST
83268: LIST
83269: LIST
83270: LIST
83271: LIST
83272: LIST
83273: LIST
83274: LIST
83275: LIST
83276: LIST
83277: LIST
83278: LIST
83279: LIST
83280: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83281: LD_ADDR_VAR 0 26
83285: PUSH
83286: LD_INT 0
83288: PUSH
83289: LD_INT 0
83291: PUSH
83292: EMPTY
83293: LIST
83294: LIST
83295: PUSH
83296: LD_INT 0
83298: PUSH
83299: LD_INT 1
83301: NEG
83302: PUSH
83303: EMPTY
83304: LIST
83305: LIST
83306: PUSH
83307: LD_INT 1
83309: PUSH
83310: LD_INT 0
83312: PUSH
83313: EMPTY
83314: LIST
83315: LIST
83316: PUSH
83317: LD_INT 1
83319: PUSH
83320: LD_INT 1
83322: PUSH
83323: EMPTY
83324: LIST
83325: LIST
83326: PUSH
83327: LD_INT 0
83329: PUSH
83330: LD_INT 1
83332: PUSH
83333: EMPTY
83334: LIST
83335: LIST
83336: PUSH
83337: LD_INT 1
83339: NEG
83340: PUSH
83341: LD_INT 0
83343: PUSH
83344: EMPTY
83345: LIST
83346: LIST
83347: PUSH
83348: LD_INT 1
83350: NEG
83351: PUSH
83352: LD_INT 1
83354: NEG
83355: PUSH
83356: EMPTY
83357: LIST
83358: LIST
83359: PUSH
83360: LD_INT 1
83362: NEG
83363: PUSH
83364: LD_INT 2
83366: NEG
83367: PUSH
83368: EMPTY
83369: LIST
83370: LIST
83371: PUSH
83372: LD_INT 0
83374: PUSH
83375: LD_INT 2
83377: NEG
83378: PUSH
83379: EMPTY
83380: LIST
83381: LIST
83382: PUSH
83383: LD_INT 1
83385: PUSH
83386: LD_INT 1
83388: NEG
83389: PUSH
83390: EMPTY
83391: LIST
83392: LIST
83393: PUSH
83394: LD_INT 2
83396: PUSH
83397: LD_INT 0
83399: PUSH
83400: EMPTY
83401: LIST
83402: LIST
83403: PUSH
83404: LD_INT 2
83406: PUSH
83407: LD_INT 1
83409: PUSH
83410: EMPTY
83411: LIST
83412: LIST
83413: PUSH
83414: LD_INT 2
83416: PUSH
83417: LD_INT 2
83419: PUSH
83420: EMPTY
83421: LIST
83422: LIST
83423: PUSH
83424: LD_INT 1
83426: PUSH
83427: LD_INT 2
83429: PUSH
83430: EMPTY
83431: LIST
83432: LIST
83433: PUSH
83434: LD_INT 0
83436: PUSH
83437: LD_INT 2
83439: PUSH
83440: EMPTY
83441: LIST
83442: LIST
83443: PUSH
83444: LD_INT 1
83446: NEG
83447: PUSH
83448: LD_INT 1
83450: PUSH
83451: EMPTY
83452: LIST
83453: LIST
83454: PUSH
83455: LD_INT 2
83457: NEG
83458: PUSH
83459: LD_INT 0
83461: PUSH
83462: EMPTY
83463: LIST
83464: LIST
83465: PUSH
83466: LD_INT 2
83468: NEG
83469: PUSH
83470: LD_INT 1
83472: NEG
83473: PUSH
83474: EMPTY
83475: LIST
83476: LIST
83477: PUSH
83478: LD_INT 2
83480: NEG
83481: PUSH
83482: LD_INT 2
83484: NEG
83485: PUSH
83486: EMPTY
83487: LIST
83488: LIST
83489: PUSH
83490: LD_INT 2
83492: PUSH
83493: LD_INT 3
83495: PUSH
83496: EMPTY
83497: LIST
83498: LIST
83499: PUSH
83500: LD_INT 1
83502: PUSH
83503: LD_INT 3
83505: PUSH
83506: EMPTY
83507: LIST
83508: LIST
83509: PUSH
83510: LD_INT 1
83512: NEG
83513: PUSH
83514: LD_INT 2
83516: PUSH
83517: EMPTY
83518: LIST
83519: LIST
83520: PUSH
83521: LD_INT 2
83523: NEG
83524: PUSH
83525: LD_INT 1
83527: PUSH
83528: EMPTY
83529: LIST
83530: LIST
83531: PUSH
83532: EMPTY
83533: LIST
83534: LIST
83535: LIST
83536: LIST
83537: LIST
83538: LIST
83539: LIST
83540: LIST
83541: LIST
83542: LIST
83543: LIST
83544: LIST
83545: LIST
83546: LIST
83547: LIST
83548: LIST
83549: LIST
83550: LIST
83551: LIST
83552: LIST
83553: LIST
83554: LIST
83555: LIST
83556: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83557: LD_ADDR_VAR 0 27
83561: PUSH
83562: LD_INT 0
83564: PUSH
83565: LD_INT 0
83567: PUSH
83568: EMPTY
83569: LIST
83570: LIST
83571: PUSH
83572: LD_INT 0
83574: PUSH
83575: LD_INT 1
83577: NEG
83578: PUSH
83579: EMPTY
83580: LIST
83581: LIST
83582: PUSH
83583: LD_INT 1
83585: PUSH
83586: LD_INT 0
83588: PUSH
83589: EMPTY
83590: LIST
83591: LIST
83592: PUSH
83593: LD_INT 1
83595: PUSH
83596: LD_INT 1
83598: PUSH
83599: EMPTY
83600: LIST
83601: LIST
83602: PUSH
83603: LD_INT 0
83605: PUSH
83606: LD_INT 1
83608: PUSH
83609: EMPTY
83610: LIST
83611: LIST
83612: PUSH
83613: LD_INT 1
83615: NEG
83616: PUSH
83617: LD_INT 0
83619: PUSH
83620: EMPTY
83621: LIST
83622: LIST
83623: PUSH
83624: LD_INT 1
83626: NEG
83627: PUSH
83628: LD_INT 1
83630: NEG
83631: PUSH
83632: EMPTY
83633: LIST
83634: LIST
83635: PUSH
83636: LD_INT 1
83638: NEG
83639: PUSH
83640: LD_INT 2
83642: NEG
83643: PUSH
83644: EMPTY
83645: LIST
83646: LIST
83647: PUSH
83648: LD_INT 0
83650: PUSH
83651: LD_INT 2
83653: NEG
83654: PUSH
83655: EMPTY
83656: LIST
83657: LIST
83658: PUSH
83659: LD_INT 1
83661: PUSH
83662: LD_INT 1
83664: NEG
83665: PUSH
83666: EMPTY
83667: LIST
83668: LIST
83669: PUSH
83670: LD_INT 2
83672: PUSH
83673: LD_INT 0
83675: PUSH
83676: EMPTY
83677: LIST
83678: LIST
83679: PUSH
83680: LD_INT 2
83682: PUSH
83683: LD_INT 1
83685: PUSH
83686: EMPTY
83687: LIST
83688: LIST
83689: PUSH
83690: LD_INT 2
83692: PUSH
83693: LD_INT 2
83695: PUSH
83696: EMPTY
83697: LIST
83698: LIST
83699: PUSH
83700: LD_INT 1
83702: PUSH
83703: LD_INT 2
83705: PUSH
83706: EMPTY
83707: LIST
83708: LIST
83709: PUSH
83710: LD_INT 0
83712: PUSH
83713: LD_INT 2
83715: PUSH
83716: EMPTY
83717: LIST
83718: LIST
83719: PUSH
83720: LD_INT 1
83722: NEG
83723: PUSH
83724: LD_INT 1
83726: PUSH
83727: EMPTY
83728: LIST
83729: LIST
83730: PUSH
83731: LD_INT 2
83733: NEG
83734: PUSH
83735: LD_INT 0
83737: PUSH
83738: EMPTY
83739: LIST
83740: LIST
83741: PUSH
83742: LD_INT 2
83744: NEG
83745: PUSH
83746: LD_INT 1
83748: NEG
83749: PUSH
83750: EMPTY
83751: LIST
83752: LIST
83753: PUSH
83754: LD_INT 2
83756: NEG
83757: PUSH
83758: LD_INT 2
83760: NEG
83761: PUSH
83762: EMPTY
83763: LIST
83764: LIST
83765: PUSH
83766: LD_INT 1
83768: NEG
83769: PUSH
83770: LD_INT 2
83772: PUSH
83773: EMPTY
83774: LIST
83775: LIST
83776: PUSH
83777: LD_INT 2
83779: NEG
83780: PUSH
83781: LD_INT 1
83783: PUSH
83784: EMPTY
83785: LIST
83786: LIST
83787: PUSH
83788: LD_INT 3
83790: NEG
83791: PUSH
83792: LD_INT 1
83794: NEG
83795: PUSH
83796: EMPTY
83797: LIST
83798: LIST
83799: PUSH
83800: LD_INT 3
83802: NEG
83803: PUSH
83804: LD_INT 2
83806: NEG
83807: PUSH
83808: EMPTY
83809: LIST
83810: LIST
83811: PUSH
83812: EMPTY
83813: LIST
83814: LIST
83815: LIST
83816: LIST
83817: LIST
83818: LIST
83819: LIST
83820: LIST
83821: LIST
83822: LIST
83823: LIST
83824: LIST
83825: LIST
83826: LIST
83827: LIST
83828: LIST
83829: LIST
83830: LIST
83831: LIST
83832: LIST
83833: LIST
83834: LIST
83835: LIST
83836: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83837: LD_ADDR_VAR 0 28
83841: PUSH
83842: LD_INT 0
83844: PUSH
83845: LD_INT 0
83847: PUSH
83848: EMPTY
83849: LIST
83850: LIST
83851: PUSH
83852: LD_INT 0
83854: PUSH
83855: LD_INT 1
83857: NEG
83858: PUSH
83859: EMPTY
83860: LIST
83861: LIST
83862: PUSH
83863: LD_INT 1
83865: PUSH
83866: LD_INT 0
83868: PUSH
83869: EMPTY
83870: LIST
83871: LIST
83872: PUSH
83873: LD_INT 1
83875: PUSH
83876: LD_INT 1
83878: PUSH
83879: EMPTY
83880: LIST
83881: LIST
83882: PUSH
83883: LD_INT 0
83885: PUSH
83886: LD_INT 1
83888: PUSH
83889: EMPTY
83890: LIST
83891: LIST
83892: PUSH
83893: LD_INT 1
83895: NEG
83896: PUSH
83897: LD_INT 0
83899: PUSH
83900: EMPTY
83901: LIST
83902: LIST
83903: PUSH
83904: LD_INT 1
83906: NEG
83907: PUSH
83908: LD_INT 1
83910: NEG
83911: PUSH
83912: EMPTY
83913: LIST
83914: LIST
83915: PUSH
83916: LD_INT 1
83918: NEG
83919: PUSH
83920: LD_INT 2
83922: NEG
83923: PUSH
83924: EMPTY
83925: LIST
83926: LIST
83927: PUSH
83928: LD_INT 0
83930: PUSH
83931: LD_INT 2
83933: NEG
83934: PUSH
83935: EMPTY
83936: LIST
83937: LIST
83938: PUSH
83939: LD_INT 1
83941: PUSH
83942: LD_INT 1
83944: NEG
83945: PUSH
83946: EMPTY
83947: LIST
83948: LIST
83949: PUSH
83950: LD_INT 2
83952: PUSH
83953: LD_INT 0
83955: PUSH
83956: EMPTY
83957: LIST
83958: LIST
83959: PUSH
83960: LD_INT 2
83962: PUSH
83963: LD_INT 1
83965: PUSH
83966: EMPTY
83967: LIST
83968: LIST
83969: PUSH
83970: LD_INT 2
83972: PUSH
83973: LD_INT 2
83975: PUSH
83976: EMPTY
83977: LIST
83978: LIST
83979: PUSH
83980: LD_INT 1
83982: PUSH
83983: LD_INT 2
83985: PUSH
83986: EMPTY
83987: LIST
83988: LIST
83989: PUSH
83990: LD_INT 0
83992: PUSH
83993: LD_INT 2
83995: PUSH
83996: EMPTY
83997: LIST
83998: LIST
83999: PUSH
84000: LD_INT 1
84002: NEG
84003: PUSH
84004: LD_INT 1
84006: PUSH
84007: EMPTY
84008: LIST
84009: LIST
84010: PUSH
84011: LD_INT 2
84013: NEG
84014: PUSH
84015: LD_INT 0
84017: PUSH
84018: EMPTY
84019: LIST
84020: LIST
84021: PUSH
84022: LD_INT 2
84024: NEG
84025: PUSH
84026: LD_INT 1
84028: NEG
84029: PUSH
84030: EMPTY
84031: LIST
84032: LIST
84033: PUSH
84034: LD_INT 2
84036: NEG
84037: PUSH
84038: LD_INT 2
84040: NEG
84041: PUSH
84042: EMPTY
84043: LIST
84044: LIST
84045: PUSH
84046: LD_INT 2
84048: NEG
84049: PUSH
84050: LD_INT 3
84052: NEG
84053: PUSH
84054: EMPTY
84055: LIST
84056: LIST
84057: PUSH
84058: LD_INT 1
84060: NEG
84061: PUSH
84062: LD_INT 3
84064: NEG
84065: PUSH
84066: EMPTY
84067: LIST
84068: LIST
84069: PUSH
84070: LD_INT 3
84072: NEG
84073: PUSH
84074: LD_INT 1
84076: NEG
84077: PUSH
84078: EMPTY
84079: LIST
84080: LIST
84081: PUSH
84082: LD_INT 3
84084: NEG
84085: PUSH
84086: LD_INT 2
84088: NEG
84089: PUSH
84090: EMPTY
84091: LIST
84092: LIST
84093: PUSH
84094: EMPTY
84095: LIST
84096: LIST
84097: LIST
84098: LIST
84099: LIST
84100: LIST
84101: LIST
84102: LIST
84103: LIST
84104: LIST
84105: LIST
84106: LIST
84107: LIST
84108: LIST
84109: LIST
84110: LIST
84111: LIST
84112: LIST
84113: LIST
84114: LIST
84115: LIST
84116: LIST
84117: LIST
84118: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84119: LD_ADDR_VAR 0 29
84123: PUSH
84124: LD_INT 0
84126: PUSH
84127: LD_INT 0
84129: PUSH
84130: EMPTY
84131: LIST
84132: LIST
84133: PUSH
84134: LD_INT 0
84136: PUSH
84137: LD_INT 1
84139: NEG
84140: PUSH
84141: EMPTY
84142: LIST
84143: LIST
84144: PUSH
84145: LD_INT 1
84147: PUSH
84148: LD_INT 0
84150: PUSH
84151: EMPTY
84152: LIST
84153: LIST
84154: PUSH
84155: LD_INT 1
84157: PUSH
84158: LD_INT 1
84160: PUSH
84161: EMPTY
84162: LIST
84163: LIST
84164: PUSH
84165: LD_INT 0
84167: PUSH
84168: LD_INT 1
84170: PUSH
84171: EMPTY
84172: LIST
84173: LIST
84174: PUSH
84175: LD_INT 1
84177: NEG
84178: PUSH
84179: LD_INT 0
84181: PUSH
84182: EMPTY
84183: LIST
84184: LIST
84185: PUSH
84186: LD_INT 1
84188: NEG
84189: PUSH
84190: LD_INT 1
84192: NEG
84193: PUSH
84194: EMPTY
84195: LIST
84196: LIST
84197: PUSH
84198: LD_INT 1
84200: NEG
84201: PUSH
84202: LD_INT 2
84204: NEG
84205: PUSH
84206: EMPTY
84207: LIST
84208: LIST
84209: PUSH
84210: LD_INT 0
84212: PUSH
84213: LD_INT 2
84215: NEG
84216: PUSH
84217: EMPTY
84218: LIST
84219: LIST
84220: PUSH
84221: LD_INT 1
84223: PUSH
84224: LD_INT 1
84226: NEG
84227: PUSH
84228: EMPTY
84229: LIST
84230: LIST
84231: PUSH
84232: LD_INT 2
84234: PUSH
84235: LD_INT 0
84237: PUSH
84238: EMPTY
84239: LIST
84240: LIST
84241: PUSH
84242: LD_INT 2
84244: PUSH
84245: LD_INT 1
84247: PUSH
84248: EMPTY
84249: LIST
84250: LIST
84251: PUSH
84252: LD_INT 1
84254: PUSH
84255: LD_INT 2
84257: PUSH
84258: EMPTY
84259: LIST
84260: LIST
84261: PUSH
84262: LD_INT 0
84264: PUSH
84265: LD_INT 2
84267: PUSH
84268: EMPTY
84269: LIST
84270: LIST
84271: PUSH
84272: LD_INT 1
84274: NEG
84275: PUSH
84276: LD_INT 1
84278: PUSH
84279: EMPTY
84280: LIST
84281: LIST
84282: PUSH
84283: LD_INT 2
84285: NEG
84286: PUSH
84287: LD_INT 1
84289: NEG
84290: PUSH
84291: EMPTY
84292: LIST
84293: LIST
84294: PUSH
84295: LD_INT 2
84297: NEG
84298: PUSH
84299: LD_INT 2
84301: NEG
84302: PUSH
84303: EMPTY
84304: LIST
84305: LIST
84306: PUSH
84307: LD_INT 2
84309: NEG
84310: PUSH
84311: LD_INT 3
84313: NEG
84314: PUSH
84315: EMPTY
84316: LIST
84317: LIST
84318: PUSH
84319: LD_INT 2
84321: PUSH
84322: LD_INT 1
84324: NEG
84325: PUSH
84326: EMPTY
84327: LIST
84328: LIST
84329: PUSH
84330: LD_INT 3
84332: PUSH
84333: LD_INT 1
84335: PUSH
84336: EMPTY
84337: LIST
84338: LIST
84339: PUSH
84340: LD_INT 1
84342: PUSH
84343: LD_INT 3
84345: PUSH
84346: EMPTY
84347: LIST
84348: LIST
84349: PUSH
84350: LD_INT 1
84352: NEG
84353: PUSH
84354: LD_INT 2
84356: PUSH
84357: EMPTY
84358: LIST
84359: LIST
84360: PUSH
84361: LD_INT 3
84363: NEG
84364: PUSH
84365: LD_INT 2
84367: NEG
84368: PUSH
84369: EMPTY
84370: LIST
84371: LIST
84372: PUSH
84373: EMPTY
84374: LIST
84375: LIST
84376: LIST
84377: LIST
84378: LIST
84379: LIST
84380: LIST
84381: LIST
84382: LIST
84383: LIST
84384: LIST
84385: LIST
84386: LIST
84387: LIST
84388: LIST
84389: LIST
84390: LIST
84391: LIST
84392: LIST
84393: LIST
84394: LIST
84395: LIST
84396: LIST
84397: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84398: LD_ADDR_VAR 0 30
84402: PUSH
84403: LD_INT 0
84405: PUSH
84406: LD_INT 0
84408: PUSH
84409: EMPTY
84410: LIST
84411: LIST
84412: PUSH
84413: LD_INT 0
84415: PUSH
84416: LD_INT 1
84418: NEG
84419: PUSH
84420: EMPTY
84421: LIST
84422: LIST
84423: PUSH
84424: LD_INT 1
84426: PUSH
84427: LD_INT 0
84429: PUSH
84430: EMPTY
84431: LIST
84432: LIST
84433: PUSH
84434: LD_INT 1
84436: PUSH
84437: LD_INT 1
84439: PUSH
84440: EMPTY
84441: LIST
84442: LIST
84443: PUSH
84444: LD_INT 0
84446: PUSH
84447: LD_INT 1
84449: PUSH
84450: EMPTY
84451: LIST
84452: LIST
84453: PUSH
84454: LD_INT 1
84456: NEG
84457: PUSH
84458: LD_INT 0
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: PUSH
84465: LD_INT 1
84467: NEG
84468: PUSH
84469: LD_INT 1
84471: NEG
84472: PUSH
84473: EMPTY
84474: LIST
84475: LIST
84476: PUSH
84477: LD_INT 1
84479: NEG
84480: PUSH
84481: LD_INT 2
84483: NEG
84484: PUSH
84485: EMPTY
84486: LIST
84487: LIST
84488: PUSH
84489: LD_INT 0
84491: PUSH
84492: LD_INT 2
84494: NEG
84495: PUSH
84496: EMPTY
84497: LIST
84498: LIST
84499: PUSH
84500: LD_INT 1
84502: PUSH
84503: LD_INT 1
84505: NEG
84506: PUSH
84507: EMPTY
84508: LIST
84509: LIST
84510: PUSH
84511: LD_INT 2
84513: PUSH
84514: LD_INT 0
84516: PUSH
84517: EMPTY
84518: LIST
84519: LIST
84520: PUSH
84521: LD_INT 2
84523: PUSH
84524: LD_INT 1
84526: PUSH
84527: EMPTY
84528: LIST
84529: LIST
84530: PUSH
84531: LD_INT 2
84533: PUSH
84534: LD_INT 2
84536: PUSH
84537: EMPTY
84538: LIST
84539: LIST
84540: PUSH
84541: LD_INT 1
84543: PUSH
84544: LD_INT 2
84546: PUSH
84547: EMPTY
84548: LIST
84549: LIST
84550: PUSH
84551: LD_INT 1
84553: NEG
84554: PUSH
84555: LD_INT 1
84557: PUSH
84558: EMPTY
84559: LIST
84560: LIST
84561: PUSH
84562: LD_INT 2
84564: NEG
84565: PUSH
84566: LD_INT 0
84568: PUSH
84569: EMPTY
84570: LIST
84571: LIST
84572: PUSH
84573: LD_INT 2
84575: NEG
84576: PUSH
84577: LD_INT 1
84579: NEG
84580: PUSH
84581: EMPTY
84582: LIST
84583: LIST
84584: PUSH
84585: LD_INT 1
84587: NEG
84588: PUSH
84589: LD_INT 3
84591: NEG
84592: PUSH
84593: EMPTY
84594: LIST
84595: LIST
84596: PUSH
84597: LD_INT 1
84599: PUSH
84600: LD_INT 2
84602: NEG
84603: PUSH
84604: EMPTY
84605: LIST
84606: LIST
84607: PUSH
84608: LD_INT 3
84610: PUSH
84611: LD_INT 2
84613: PUSH
84614: EMPTY
84615: LIST
84616: LIST
84617: PUSH
84618: LD_INT 2
84620: PUSH
84621: LD_INT 3
84623: PUSH
84624: EMPTY
84625: LIST
84626: LIST
84627: PUSH
84628: LD_INT 2
84630: NEG
84631: PUSH
84632: LD_INT 1
84634: PUSH
84635: EMPTY
84636: LIST
84637: LIST
84638: PUSH
84639: LD_INT 3
84641: NEG
84642: PUSH
84643: LD_INT 1
84645: NEG
84646: PUSH
84647: EMPTY
84648: LIST
84649: LIST
84650: PUSH
84651: EMPTY
84652: LIST
84653: LIST
84654: LIST
84655: LIST
84656: LIST
84657: LIST
84658: LIST
84659: LIST
84660: LIST
84661: LIST
84662: LIST
84663: LIST
84664: LIST
84665: LIST
84666: LIST
84667: LIST
84668: LIST
84669: LIST
84670: LIST
84671: LIST
84672: LIST
84673: LIST
84674: LIST
84675: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84676: LD_ADDR_VAR 0 31
84680: PUSH
84681: LD_INT 0
84683: PUSH
84684: LD_INT 0
84686: PUSH
84687: EMPTY
84688: LIST
84689: LIST
84690: PUSH
84691: LD_INT 0
84693: PUSH
84694: LD_INT 1
84696: NEG
84697: PUSH
84698: EMPTY
84699: LIST
84700: LIST
84701: PUSH
84702: LD_INT 1
84704: PUSH
84705: LD_INT 0
84707: PUSH
84708: EMPTY
84709: LIST
84710: LIST
84711: PUSH
84712: LD_INT 1
84714: PUSH
84715: LD_INT 1
84717: PUSH
84718: EMPTY
84719: LIST
84720: LIST
84721: PUSH
84722: LD_INT 0
84724: PUSH
84725: LD_INT 1
84727: PUSH
84728: EMPTY
84729: LIST
84730: LIST
84731: PUSH
84732: LD_INT 1
84734: NEG
84735: PUSH
84736: LD_INT 0
84738: PUSH
84739: EMPTY
84740: LIST
84741: LIST
84742: PUSH
84743: LD_INT 1
84745: NEG
84746: PUSH
84747: LD_INT 1
84749: NEG
84750: PUSH
84751: EMPTY
84752: LIST
84753: LIST
84754: PUSH
84755: LD_INT 1
84757: NEG
84758: PUSH
84759: LD_INT 2
84761: NEG
84762: PUSH
84763: EMPTY
84764: LIST
84765: LIST
84766: PUSH
84767: LD_INT 1
84769: PUSH
84770: LD_INT 1
84772: NEG
84773: PUSH
84774: EMPTY
84775: LIST
84776: LIST
84777: PUSH
84778: LD_INT 2
84780: PUSH
84781: LD_INT 0
84783: PUSH
84784: EMPTY
84785: LIST
84786: LIST
84787: PUSH
84788: LD_INT 2
84790: PUSH
84791: LD_INT 1
84793: PUSH
84794: EMPTY
84795: LIST
84796: LIST
84797: PUSH
84798: LD_INT 2
84800: PUSH
84801: LD_INT 2
84803: PUSH
84804: EMPTY
84805: LIST
84806: LIST
84807: PUSH
84808: LD_INT 1
84810: PUSH
84811: LD_INT 2
84813: PUSH
84814: EMPTY
84815: LIST
84816: LIST
84817: PUSH
84818: LD_INT 0
84820: PUSH
84821: LD_INT 2
84823: PUSH
84824: EMPTY
84825: LIST
84826: LIST
84827: PUSH
84828: LD_INT 1
84830: NEG
84831: PUSH
84832: LD_INT 1
84834: PUSH
84835: EMPTY
84836: LIST
84837: LIST
84838: PUSH
84839: LD_INT 2
84841: NEG
84842: PUSH
84843: LD_INT 1
84845: NEG
84846: PUSH
84847: EMPTY
84848: LIST
84849: LIST
84850: PUSH
84851: LD_INT 2
84853: NEG
84854: PUSH
84855: LD_INT 2
84857: NEG
84858: PUSH
84859: EMPTY
84860: LIST
84861: LIST
84862: PUSH
84863: LD_INT 2
84865: NEG
84866: PUSH
84867: LD_INT 3
84869: NEG
84870: PUSH
84871: EMPTY
84872: LIST
84873: LIST
84874: PUSH
84875: LD_INT 2
84877: PUSH
84878: LD_INT 1
84880: NEG
84881: PUSH
84882: EMPTY
84883: LIST
84884: LIST
84885: PUSH
84886: LD_INT 3
84888: PUSH
84889: LD_INT 1
84891: PUSH
84892: EMPTY
84893: LIST
84894: LIST
84895: PUSH
84896: LD_INT 1
84898: PUSH
84899: LD_INT 3
84901: PUSH
84902: EMPTY
84903: LIST
84904: LIST
84905: PUSH
84906: LD_INT 1
84908: NEG
84909: PUSH
84910: LD_INT 2
84912: PUSH
84913: EMPTY
84914: LIST
84915: LIST
84916: PUSH
84917: LD_INT 3
84919: NEG
84920: PUSH
84921: LD_INT 2
84923: NEG
84924: PUSH
84925: EMPTY
84926: LIST
84927: LIST
84928: PUSH
84929: EMPTY
84930: LIST
84931: LIST
84932: LIST
84933: LIST
84934: LIST
84935: LIST
84936: LIST
84937: LIST
84938: LIST
84939: LIST
84940: LIST
84941: LIST
84942: LIST
84943: LIST
84944: LIST
84945: LIST
84946: LIST
84947: LIST
84948: LIST
84949: LIST
84950: LIST
84951: LIST
84952: LIST
84953: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84954: LD_ADDR_VAR 0 32
84958: PUSH
84959: LD_INT 0
84961: PUSH
84962: LD_INT 0
84964: PUSH
84965: EMPTY
84966: LIST
84967: LIST
84968: PUSH
84969: LD_INT 0
84971: PUSH
84972: LD_INT 1
84974: NEG
84975: PUSH
84976: EMPTY
84977: LIST
84978: LIST
84979: PUSH
84980: LD_INT 1
84982: PUSH
84983: LD_INT 0
84985: PUSH
84986: EMPTY
84987: LIST
84988: LIST
84989: PUSH
84990: LD_INT 1
84992: PUSH
84993: LD_INT 1
84995: PUSH
84996: EMPTY
84997: LIST
84998: LIST
84999: PUSH
85000: LD_INT 0
85002: PUSH
85003: LD_INT 1
85005: PUSH
85006: EMPTY
85007: LIST
85008: LIST
85009: PUSH
85010: LD_INT 1
85012: NEG
85013: PUSH
85014: LD_INT 0
85016: PUSH
85017: EMPTY
85018: LIST
85019: LIST
85020: PUSH
85021: LD_INT 1
85023: NEG
85024: PUSH
85025: LD_INT 1
85027: NEG
85028: PUSH
85029: EMPTY
85030: LIST
85031: LIST
85032: PUSH
85033: LD_INT 1
85035: NEG
85036: PUSH
85037: LD_INT 2
85039: NEG
85040: PUSH
85041: EMPTY
85042: LIST
85043: LIST
85044: PUSH
85045: LD_INT 0
85047: PUSH
85048: LD_INT 2
85050: NEG
85051: PUSH
85052: EMPTY
85053: LIST
85054: LIST
85055: PUSH
85056: LD_INT 1
85058: PUSH
85059: LD_INT 1
85061: NEG
85062: PUSH
85063: EMPTY
85064: LIST
85065: LIST
85066: PUSH
85067: LD_INT 2
85069: PUSH
85070: LD_INT 1
85072: PUSH
85073: EMPTY
85074: LIST
85075: LIST
85076: PUSH
85077: LD_INT 2
85079: PUSH
85080: LD_INT 2
85082: PUSH
85083: EMPTY
85084: LIST
85085: LIST
85086: PUSH
85087: LD_INT 1
85089: PUSH
85090: LD_INT 2
85092: PUSH
85093: EMPTY
85094: LIST
85095: LIST
85096: PUSH
85097: LD_INT 0
85099: PUSH
85100: LD_INT 2
85102: PUSH
85103: EMPTY
85104: LIST
85105: LIST
85106: PUSH
85107: LD_INT 1
85109: NEG
85110: PUSH
85111: LD_INT 1
85113: PUSH
85114: EMPTY
85115: LIST
85116: LIST
85117: PUSH
85118: LD_INT 2
85120: NEG
85121: PUSH
85122: LD_INT 0
85124: PUSH
85125: EMPTY
85126: LIST
85127: LIST
85128: PUSH
85129: LD_INT 2
85131: NEG
85132: PUSH
85133: LD_INT 1
85135: NEG
85136: PUSH
85137: EMPTY
85138: LIST
85139: LIST
85140: PUSH
85141: LD_INT 1
85143: NEG
85144: PUSH
85145: LD_INT 3
85147: NEG
85148: PUSH
85149: EMPTY
85150: LIST
85151: LIST
85152: PUSH
85153: LD_INT 1
85155: PUSH
85156: LD_INT 2
85158: NEG
85159: PUSH
85160: EMPTY
85161: LIST
85162: LIST
85163: PUSH
85164: LD_INT 3
85166: PUSH
85167: LD_INT 2
85169: PUSH
85170: EMPTY
85171: LIST
85172: LIST
85173: PUSH
85174: LD_INT 2
85176: PUSH
85177: LD_INT 3
85179: PUSH
85180: EMPTY
85181: LIST
85182: LIST
85183: PUSH
85184: LD_INT 2
85186: NEG
85187: PUSH
85188: LD_INT 1
85190: PUSH
85191: EMPTY
85192: LIST
85193: LIST
85194: PUSH
85195: LD_INT 3
85197: NEG
85198: PUSH
85199: LD_INT 1
85201: NEG
85202: PUSH
85203: EMPTY
85204: LIST
85205: LIST
85206: PUSH
85207: EMPTY
85208: LIST
85209: LIST
85210: LIST
85211: LIST
85212: LIST
85213: LIST
85214: LIST
85215: LIST
85216: LIST
85217: LIST
85218: LIST
85219: LIST
85220: LIST
85221: LIST
85222: LIST
85223: LIST
85224: LIST
85225: LIST
85226: LIST
85227: LIST
85228: LIST
85229: LIST
85230: LIST
85231: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85232: LD_ADDR_VAR 0 33
85236: PUSH
85237: LD_INT 0
85239: PUSH
85240: LD_INT 0
85242: PUSH
85243: EMPTY
85244: LIST
85245: LIST
85246: PUSH
85247: LD_INT 0
85249: PUSH
85250: LD_INT 1
85252: NEG
85253: PUSH
85254: EMPTY
85255: LIST
85256: LIST
85257: PUSH
85258: LD_INT 1
85260: PUSH
85261: LD_INT 0
85263: PUSH
85264: EMPTY
85265: LIST
85266: LIST
85267: PUSH
85268: LD_INT 1
85270: PUSH
85271: LD_INT 1
85273: PUSH
85274: EMPTY
85275: LIST
85276: LIST
85277: PUSH
85278: LD_INT 0
85280: PUSH
85281: LD_INT 1
85283: PUSH
85284: EMPTY
85285: LIST
85286: LIST
85287: PUSH
85288: LD_INT 1
85290: NEG
85291: PUSH
85292: LD_INT 0
85294: PUSH
85295: EMPTY
85296: LIST
85297: LIST
85298: PUSH
85299: LD_INT 1
85301: NEG
85302: PUSH
85303: LD_INT 1
85305: NEG
85306: PUSH
85307: EMPTY
85308: LIST
85309: LIST
85310: PUSH
85311: LD_INT 1
85313: NEG
85314: PUSH
85315: LD_INT 2
85317: NEG
85318: PUSH
85319: EMPTY
85320: LIST
85321: LIST
85322: PUSH
85323: LD_INT 1
85325: PUSH
85326: LD_INT 1
85328: NEG
85329: PUSH
85330: EMPTY
85331: LIST
85332: LIST
85333: PUSH
85334: LD_INT 2
85336: PUSH
85337: LD_INT 0
85339: PUSH
85340: EMPTY
85341: LIST
85342: LIST
85343: PUSH
85344: LD_INT 2
85346: PUSH
85347: LD_INT 1
85349: PUSH
85350: EMPTY
85351: LIST
85352: LIST
85353: PUSH
85354: LD_INT 1
85356: PUSH
85357: LD_INT 2
85359: PUSH
85360: EMPTY
85361: LIST
85362: LIST
85363: PUSH
85364: LD_INT 0
85366: PUSH
85367: LD_INT 2
85369: PUSH
85370: EMPTY
85371: LIST
85372: LIST
85373: PUSH
85374: LD_INT 1
85376: NEG
85377: PUSH
85378: LD_INT 1
85380: PUSH
85381: EMPTY
85382: LIST
85383: LIST
85384: PUSH
85385: LD_INT 2
85387: NEG
85388: PUSH
85389: LD_INT 0
85391: PUSH
85392: EMPTY
85393: LIST
85394: LIST
85395: PUSH
85396: LD_INT 2
85398: NEG
85399: PUSH
85400: LD_INT 1
85402: NEG
85403: PUSH
85404: EMPTY
85405: LIST
85406: LIST
85407: PUSH
85408: LD_INT 2
85410: NEG
85411: PUSH
85412: LD_INT 2
85414: NEG
85415: PUSH
85416: EMPTY
85417: LIST
85418: LIST
85419: PUSH
85420: LD_INT 2
85422: NEG
85423: PUSH
85424: LD_INT 3
85426: NEG
85427: PUSH
85428: EMPTY
85429: LIST
85430: LIST
85431: PUSH
85432: LD_INT 2
85434: PUSH
85435: LD_INT 1
85437: NEG
85438: PUSH
85439: EMPTY
85440: LIST
85441: LIST
85442: PUSH
85443: LD_INT 3
85445: PUSH
85446: LD_INT 1
85448: PUSH
85449: EMPTY
85450: LIST
85451: LIST
85452: PUSH
85453: LD_INT 1
85455: PUSH
85456: LD_INT 3
85458: PUSH
85459: EMPTY
85460: LIST
85461: LIST
85462: PUSH
85463: LD_INT 1
85465: NEG
85466: PUSH
85467: LD_INT 2
85469: PUSH
85470: EMPTY
85471: LIST
85472: LIST
85473: PUSH
85474: LD_INT 3
85476: NEG
85477: PUSH
85478: LD_INT 2
85480: NEG
85481: PUSH
85482: EMPTY
85483: LIST
85484: LIST
85485: PUSH
85486: EMPTY
85487: LIST
85488: LIST
85489: LIST
85490: LIST
85491: LIST
85492: LIST
85493: LIST
85494: LIST
85495: LIST
85496: LIST
85497: LIST
85498: LIST
85499: LIST
85500: LIST
85501: LIST
85502: LIST
85503: LIST
85504: LIST
85505: LIST
85506: LIST
85507: LIST
85508: LIST
85509: LIST
85510: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85511: LD_ADDR_VAR 0 34
85515: PUSH
85516: LD_INT 0
85518: PUSH
85519: LD_INT 0
85521: PUSH
85522: EMPTY
85523: LIST
85524: LIST
85525: PUSH
85526: LD_INT 0
85528: PUSH
85529: LD_INT 1
85531: NEG
85532: PUSH
85533: EMPTY
85534: LIST
85535: LIST
85536: PUSH
85537: LD_INT 1
85539: PUSH
85540: LD_INT 0
85542: PUSH
85543: EMPTY
85544: LIST
85545: LIST
85546: PUSH
85547: LD_INT 1
85549: PUSH
85550: LD_INT 1
85552: PUSH
85553: EMPTY
85554: LIST
85555: LIST
85556: PUSH
85557: LD_INT 0
85559: PUSH
85560: LD_INT 1
85562: PUSH
85563: EMPTY
85564: LIST
85565: LIST
85566: PUSH
85567: LD_INT 1
85569: NEG
85570: PUSH
85571: LD_INT 0
85573: PUSH
85574: EMPTY
85575: LIST
85576: LIST
85577: PUSH
85578: LD_INT 1
85580: NEG
85581: PUSH
85582: LD_INT 1
85584: NEG
85585: PUSH
85586: EMPTY
85587: LIST
85588: LIST
85589: PUSH
85590: LD_INT 1
85592: NEG
85593: PUSH
85594: LD_INT 2
85596: NEG
85597: PUSH
85598: EMPTY
85599: LIST
85600: LIST
85601: PUSH
85602: LD_INT 0
85604: PUSH
85605: LD_INT 2
85607: NEG
85608: PUSH
85609: EMPTY
85610: LIST
85611: LIST
85612: PUSH
85613: LD_INT 1
85615: PUSH
85616: LD_INT 1
85618: NEG
85619: PUSH
85620: EMPTY
85621: LIST
85622: LIST
85623: PUSH
85624: LD_INT 2
85626: PUSH
85627: LD_INT 1
85629: PUSH
85630: EMPTY
85631: LIST
85632: LIST
85633: PUSH
85634: LD_INT 2
85636: PUSH
85637: LD_INT 2
85639: PUSH
85640: EMPTY
85641: LIST
85642: LIST
85643: PUSH
85644: LD_INT 1
85646: PUSH
85647: LD_INT 2
85649: PUSH
85650: EMPTY
85651: LIST
85652: LIST
85653: PUSH
85654: LD_INT 1
85656: NEG
85657: PUSH
85658: LD_INT 1
85660: PUSH
85661: EMPTY
85662: LIST
85663: LIST
85664: PUSH
85665: LD_INT 2
85667: NEG
85668: PUSH
85669: LD_INT 0
85671: PUSH
85672: EMPTY
85673: LIST
85674: LIST
85675: PUSH
85676: LD_INT 2
85678: NEG
85679: PUSH
85680: LD_INT 1
85682: NEG
85683: PUSH
85684: EMPTY
85685: LIST
85686: LIST
85687: PUSH
85688: LD_INT 2
85690: NEG
85691: PUSH
85692: LD_INT 2
85694: NEG
85695: PUSH
85696: EMPTY
85697: LIST
85698: LIST
85699: PUSH
85700: LD_INT 1
85702: NEG
85703: PUSH
85704: LD_INT 3
85706: NEG
85707: PUSH
85708: EMPTY
85709: LIST
85710: LIST
85711: PUSH
85712: LD_INT 1
85714: PUSH
85715: LD_INT 2
85717: NEG
85718: PUSH
85719: EMPTY
85720: LIST
85721: LIST
85722: PUSH
85723: LD_INT 3
85725: PUSH
85726: LD_INT 2
85728: PUSH
85729: EMPTY
85730: LIST
85731: LIST
85732: PUSH
85733: LD_INT 2
85735: PUSH
85736: LD_INT 3
85738: PUSH
85739: EMPTY
85740: LIST
85741: LIST
85742: PUSH
85743: LD_INT 2
85745: NEG
85746: PUSH
85747: LD_INT 1
85749: PUSH
85750: EMPTY
85751: LIST
85752: LIST
85753: PUSH
85754: LD_INT 3
85756: NEG
85757: PUSH
85758: LD_INT 1
85760: NEG
85761: PUSH
85762: EMPTY
85763: LIST
85764: LIST
85765: PUSH
85766: EMPTY
85767: LIST
85768: LIST
85769: LIST
85770: LIST
85771: LIST
85772: LIST
85773: LIST
85774: LIST
85775: LIST
85776: LIST
85777: LIST
85778: LIST
85779: LIST
85780: LIST
85781: LIST
85782: LIST
85783: LIST
85784: LIST
85785: LIST
85786: LIST
85787: LIST
85788: LIST
85789: LIST
85790: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
85791: LD_ADDR_VAR 0 35
85795: PUSH
85796: LD_INT 0
85798: PUSH
85799: LD_INT 0
85801: PUSH
85802: EMPTY
85803: LIST
85804: LIST
85805: PUSH
85806: LD_INT 0
85808: PUSH
85809: LD_INT 1
85811: NEG
85812: PUSH
85813: EMPTY
85814: LIST
85815: LIST
85816: PUSH
85817: LD_INT 1
85819: PUSH
85820: LD_INT 0
85822: PUSH
85823: EMPTY
85824: LIST
85825: LIST
85826: PUSH
85827: LD_INT 1
85829: PUSH
85830: LD_INT 1
85832: PUSH
85833: EMPTY
85834: LIST
85835: LIST
85836: PUSH
85837: LD_INT 0
85839: PUSH
85840: LD_INT 1
85842: PUSH
85843: EMPTY
85844: LIST
85845: LIST
85846: PUSH
85847: LD_INT 1
85849: NEG
85850: PUSH
85851: LD_INT 0
85853: PUSH
85854: EMPTY
85855: LIST
85856: LIST
85857: PUSH
85858: LD_INT 1
85860: NEG
85861: PUSH
85862: LD_INT 1
85864: NEG
85865: PUSH
85866: EMPTY
85867: LIST
85868: LIST
85869: PUSH
85870: LD_INT 2
85872: PUSH
85873: LD_INT 1
85875: PUSH
85876: EMPTY
85877: LIST
85878: LIST
85879: PUSH
85880: LD_INT 2
85882: NEG
85883: PUSH
85884: LD_INT 1
85886: NEG
85887: PUSH
85888: EMPTY
85889: LIST
85890: LIST
85891: PUSH
85892: EMPTY
85893: LIST
85894: LIST
85895: LIST
85896: LIST
85897: LIST
85898: LIST
85899: LIST
85900: LIST
85901: LIST
85902: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
85903: LD_ADDR_VAR 0 36
85907: PUSH
85908: LD_INT 0
85910: PUSH
85911: LD_INT 0
85913: PUSH
85914: EMPTY
85915: LIST
85916: LIST
85917: PUSH
85918: LD_INT 0
85920: PUSH
85921: LD_INT 1
85923: NEG
85924: PUSH
85925: EMPTY
85926: LIST
85927: LIST
85928: PUSH
85929: LD_INT 1
85931: PUSH
85932: LD_INT 0
85934: PUSH
85935: EMPTY
85936: LIST
85937: LIST
85938: PUSH
85939: LD_INT 1
85941: PUSH
85942: LD_INT 1
85944: PUSH
85945: EMPTY
85946: LIST
85947: LIST
85948: PUSH
85949: LD_INT 0
85951: PUSH
85952: LD_INT 1
85954: PUSH
85955: EMPTY
85956: LIST
85957: LIST
85958: PUSH
85959: LD_INT 1
85961: NEG
85962: PUSH
85963: LD_INT 0
85965: PUSH
85966: EMPTY
85967: LIST
85968: LIST
85969: PUSH
85970: LD_INT 1
85972: NEG
85973: PUSH
85974: LD_INT 1
85976: NEG
85977: PUSH
85978: EMPTY
85979: LIST
85980: LIST
85981: PUSH
85982: LD_INT 1
85984: NEG
85985: PUSH
85986: LD_INT 2
85988: NEG
85989: PUSH
85990: EMPTY
85991: LIST
85992: LIST
85993: PUSH
85994: LD_INT 1
85996: PUSH
85997: LD_INT 2
85999: PUSH
86000: EMPTY
86001: LIST
86002: LIST
86003: PUSH
86004: EMPTY
86005: LIST
86006: LIST
86007: LIST
86008: LIST
86009: LIST
86010: LIST
86011: LIST
86012: LIST
86013: LIST
86014: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86015: LD_ADDR_VAR 0 37
86019: PUSH
86020: LD_INT 0
86022: PUSH
86023: LD_INT 0
86025: PUSH
86026: EMPTY
86027: LIST
86028: LIST
86029: PUSH
86030: LD_INT 0
86032: PUSH
86033: LD_INT 1
86035: NEG
86036: PUSH
86037: EMPTY
86038: LIST
86039: LIST
86040: PUSH
86041: LD_INT 1
86043: PUSH
86044: LD_INT 0
86046: PUSH
86047: EMPTY
86048: LIST
86049: LIST
86050: PUSH
86051: LD_INT 1
86053: PUSH
86054: LD_INT 1
86056: PUSH
86057: EMPTY
86058: LIST
86059: LIST
86060: PUSH
86061: LD_INT 0
86063: PUSH
86064: LD_INT 1
86066: PUSH
86067: EMPTY
86068: LIST
86069: LIST
86070: PUSH
86071: LD_INT 1
86073: NEG
86074: PUSH
86075: LD_INT 0
86077: PUSH
86078: EMPTY
86079: LIST
86080: LIST
86081: PUSH
86082: LD_INT 1
86084: NEG
86085: PUSH
86086: LD_INT 1
86088: NEG
86089: PUSH
86090: EMPTY
86091: LIST
86092: LIST
86093: PUSH
86094: LD_INT 1
86096: PUSH
86097: LD_INT 1
86099: NEG
86100: PUSH
86101: EMPTY
86102: LIST
86103: LIST
86104: PUSH
86105: LD_INT 1
86107: NEG
86108: PUSH
86109: LD_INT 1
86111: PUSH
86112: EMPTY
86113: LIST
86114: LIST
86115: PUSH
86116: EMPTY
86117: LIST
86118: LIST
86119: LIST
86120: LIST
86121: LIST
86122: LIST
86123: LIST
86124: LIST
86125: LIST
86126: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86127: LD_ADDR_VAR 0 38
86131: PUSH
86132: LD_INT 0
86134: PUSH
86135: LD_INT 0
86137: PUSH
86138: EMPTY
86139: LIST
86140: LIST
86141: PUSH
86142: LD_INT 0
86144: PUSH
86145: LD_INT 1
86147: NEG
86148: PUSH
86149: EMPTY
86150: LIST
86151: LIST
86152: PUSH
86153: LD_INT 1
86155: PUSH
86156: LD_INT 0
86158: PUSH
86159: EMPTY
86160: LIST
86161: LIST
86162: PUSH
86163: LD_INT 1
86165: PUSH
86166: LD_INT 1
86168: PUSH
86169: EMPTY
86170: LIST
86171: LIST
86172: PUSH
86173: LD_INT 0
86175: PUSH
86176: LD_INT 1
86178: PUSH
86179: EMPTY
86180: LIST
86181: LIST
86182: PUSH
86183: LD_INT 1
86185: NEG
86186: PUSH
86187: LD_INT 0
86189: PUSH
86190: EMPTY
86191: LIST
86192: LIST
86193: PUSH
86194: LD_INT 1
86196: NEG
86197: PUSH
86198: LD_INT 1
86200: NEG
86201: PUSH
86202: EMPTY
86203: LIST
86204: LIST
86205: PUSH
86206: LD_INT 2
86208: PUSH
86209: LD_INT 1
86211: PUSH
86212: EMPTY
86213: LIST
86214: LIST
86215: PUSH
86216: LD_INT 2
86218: NEG
86219: PUSH
86220: LD_INT 1
86222: NEG
86223: PUSH
86224: EMPTY
86225: LIST
86226: LIST
86227: PUSH
86228: EMPTY
86229: LIST
86230: LIST
86231: LIST
86232: LIST
86233: LIST
86234: LIST
86235: LIST
86236: LIST
86237: LIST
86238: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86239: LD_ADDR_VAR 0 39
86243: PUSH
86244: LD_INT 0
86246: PUSH
86247: LD_INT 0
86249: PUSH
86250: EMPTY
86251: LIST
86252: LIST
86253: PUSH
86254: LD_INT 0
86256: PUSH
86257: LD_INT 1
86259: NEG
86260: PUSH
86261: EMPTY
86262: LIST
86263: LIST
86264: PUSH
86265: LD_INT 1
86267: PUSH
86268: LD_INT 0
86270: PUSH
86271: EMPTY
86272: LIST
86273: LIST
86274: PUSH
86275: LD_INT 1
86277: PUSH
86278: LD_INT 1
86280: PUSH
86281: EMPTY
86282: LIST
86283: LIST
86284: PUSH
86285: LD_INT 0
86287: PUSH
86288: LD_INT 1
86290: PUSH
86291: EMPTY
86292: LIST
86293: LIST
86294: PUSH
86295: LD_INT 1
86297: NEG
86298: PUSH
86299: LD_INT 0
86301: PUSH
86302: EMPTY
86303: LIST
86304: LIST
86305: PUSH
86306: LD_INT 1
86308: NEG
86309: PUSH
86310: LD_INT 1
86312: NEG
86313: PUSH
86314: EMPTY
86315: LIST
86316: LIST
86317: PUSH
86318: LD_INT 1
86320: NEG
86321: PUSH
86322: LD_INT 2
86324: NEG
86325: PUSH
86326: EMPTY
86327: LIST
86328: LIST
86329: PUSH
86330: LD_INT 1
86332: PUSH
86333: LD_INT 2
86335: PUSH
86336: EMPTY
86337: LIST
86338: LIST
86339: PUSH
86340: EMPTY
86341: LIST
86342: LIST
86343: LIST
86344: LIST
86345: LIST
86346: LIST
86347: LIST
86348: LIST
86349: LIST
86350: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86351: LD_ADDR_VAR 0 40
86355: PUSH
86356: LD_INT 0
86358: PUSH
86359: LD_INT 0
86361: PUSH
86362: EMPTY
86363: LIST
86364: LIST
86365: PUSH
86366: LD_INT 0
86368: PUSH
86369: LD_INT 1
86371: NEG
86372: PUSH
86373: EMPTY
86374: LIST
86375: LIST
86376: PUSH
86377: LD_INT 1
86379: PUSH
86380: LD_INT 0
86382: PUSH
86383: EMPTY
86384: LIST
86385: LIST
86386: PUSH
86387: LD_INT 1
86389: PUSH
86390: LD_INT 1
86392: PUSH
86393: EMPTY
86394: LIST
86395: LIST
86396: PUSH
86397: LD_INT 0
86399: PUSH
86400: LD_INT 1
86402: PUSH
86403: EMPTY
86404: LIST
86405: LIST
86406: PUSH
86407: LD_INT 1
86409: NEG
86410: PUSH
86411: LD_INT 0
86413: PUSH
86414: EMPTY
86415: LIST
86416: LIST
86417: PUSH
86418: LD_INT 1
86420: NEG
86421: PUSH
86422: LD_INT 1
86424: NEG
86425: PUSH
86426: EMPTY
86427: LIST
86428: LIST
86429: PUSH
86430: LD_INT 1
86432: PUSH
86433: LD_INT 1
86435: NEG
86436: PUSH
86437: EMPTY
86438: LIST
86439: LIST
86440: PUSH
86441: LD_INT 1
86443: NEG
86444: PUSH
86445: LD_INT 1
86447: PUSH
86448: EMPTY
86449: LIST
86450: LIST
86451: PUSH
86452: EMPTY
86453: LIST
86454: LIST
86455: LIST
86456: LIST
86457: LIST
86458: LIST
86459: LIST
86460: LIST
86461: LIST
86462: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86463: LD_ADDR_VAR 0 41
86467: PUSH
86468: LD_INT 0
86470: PUSH
86471: LD_INT 0
86473: PUSH
86474: EMPTY
86475: LIST
86476: LIST
86477: PUSH
86478: LD_INT 0
86480: PUSH
86481: LD_INT 1
86483: NEG
86484: PUSH
86485: EMPTY
86486: LIST
86487: LIST
86488: PUSH
86489: LD_INT 1
86491: PUSH
86492: LD_INT 0
86494: PUSH
86495: EMPTY
86496: LIST
86497: LIST
86498: PUSH
86499: LD_INT 1
86501: PUSH
86502: LD_INT 1
86504: PUSH
86505: EMPTY
86506: LIST
86507: LIST
86508: PUSH
86509: LD_INT 0
86511: PUSH
86512: LD_INT 1
86514: PUSH
86515: EMPTY
86516: LIST
86517: LIST
86518: PUSH
86519: LD_INT 1
86521: NEG
86522: PUSH
86523: LD_INT 0
86525: PUSH
86526: EMPTY
86527: LIST
86528: LIST
86529: PUSH
86530: LD_INT 1
86532: NEG
86533: PUSH
86534: LD_INT 1
86536: NEG
86537: PUSH
86538: EMPTY
86539: LIST
86540: LIST
86541: PUSH
86542: LD_INT 1
86544: NEG
86545: PUSH
86546: LD_INT 2
86548: NEG
86549: PUSH
86550: EMPTY
86551: LIST
86552: LIST
86553: PUSH
86554: LD_INT 1
86556: PUSH
86557: LD_INT 1
86559: NEG
86560: PUSH
86561: EMPTY
86562: LIST
86563: LIST
86564: PUSH
86565: LD_INT 2
86567: PUSH
86568: LD_INT 0
86570: PUSH
86571: EMPTY
86572: LIST
86573: LIST
86574: PUSH
86575: LD_INT 2
86577: PUSH
86578: LD_INT 1
86580: PUSH
86581: EMPTY
86582: LIST
86583: LIST
86584: PUSH
86585: LD_INT 2
86587: PUSH
86588: LD_INT 2
86590: PUSH
86591: EMPTY
86592: LIST
86593: LIST
86594: PUSH
86595: LD_INT 1
86597: PUSH
86598: LD_INT 2
86600: PUSH
86601: EMPTY
86602: LIST
86603: LIST
86604: PUSH
86605: LD_INT 1
86607: NEG
86608: PUSH
86609: LD_INT 1
86611: PUSH
86612: EMPTY
86613: LIST
86614: LIST
86615: PUSH
86616: LD_INT 2
86618: NEG
86619: PUSH
86620: LD_INT 0
86622: PUSH
86623: EMPTY
86624: LIST
86625: LIST
86626: PUSH
86627: LD_INT 2
86629: NEG
86630: PUSH
86631: LD_INT 1
86633: NEG
86634: PUSH
86635: EMPTY
86636: LIST
86637: LIST
86638: PUSH
86639: LD_INT 2
86641: NEG
86642: PUSH
86643: LD_INT 2
86645: NEG
86646: PUSH
86647: EMPTY
86648: LIST
86649: LIST
86650: PUSH
86651: LD_INT 2
86653: NEG
86654: PUSH
86655: LD_INT 3
86657: NEG
86658: PUSH
86659: EMPTY
86660: LIST
86661: LIST
86662: PUSH
86663: LD_INT 2
86665: PUSH
86666: LD_INT 1
86668: NEG
86669: PUSH
86670: EMPTY
86671: LIST
86672: LIST
86673: PUSH
86674: LD_INT 3
86676: PUSH
86677: LD_INT 0
86679: PUSH
86680: EMPTY
86681: LIST
86682: LIST
86683: PUSH
86684: LD_INT 3
86686: PUSH
86687: LD_INT 1
86689: PUSH
86690: EMPTY
86691: LIST
86692: LIST
86693: PUSH
86694: LD_INT 3
86696: PUSH
86697: LD_INT 2
86699: PUSH
86700: EMPTY
86701: LIST
86702: LIST
86703: PUSH
86704: LD_INT 3
86706: PUSH
86707: LD_INT 3
86709: PUSH
86710: EMPTY
86711: LIST
86712: LIST
86713: PUSH
86714: LD_INT 2
86716: PUSH
86717: LD_INT 3
86719: PUSH
86720: EMPTY
86721: LIST
86722: LIST
86723: PUSH
86724: LD_INT 2
86726: NEG
86727: PUSH
86728: LD_INT 1
86730: PUSH
86731: EMPTY
86732: LIST
86733: LIST
86734: PUSH
86735: LD_INT 3
86737: NEG
86738: PUSH
86739: LD_INT 0
86741: PUSH
86742: EMPTY
86743: LIST
86744: LIST
86745: PUSH
86746: LD_INT 3
86748: NEG
86749: PUSH
86750: LD_INT 1
86752: NEG
86753: PUSH
86754: EMPTY
86755: LIST
86756: LIST
86757: PUSH
86758: LD_INT 3
86760: NEG
86761: PUSH
86762: LD_INT 2
86764: NEG
86765: PUSH
86766: EMPTY
86767: LIST
86768: LIST
86769: PUSH
86770: LD_INT 3
86772: NEG
86773: PUSH
86774: LD_INT 3
86776: NEG
86777: PUSH
86778: EMPTY
86779: LIST
86780: LIST
86781: PUSH
86782: EMPTY
86783: LIST
86784: LIST
86785: LIST
86786: LIST
86787: LIST
86788: LIST
86789: LIST
86790: LIST
86791: LIST
86792: LIST
86793: LIST
86794: LIST
86795: LIST
86796: LIST
86797: LIST
86798: LIST
86799: LIST
86800: LIST
86801: LIST
86802: LIST
86803: LIST
86804: LIST
86805: LIST
86806: LIST
86807: LIST
86808: LIST
86809: LIST
86810: LIST
86811: LIST
86812: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86813: LD_ADDR_VAR 0 42
86817: PUSH
86818: LD_INT 0
86820: PUSH
86821: LD_INT 0
86823: PUSH
86824: EMPTY
86825: LIST
86826: LIST
86827: PUSH
86828: LD_INT 0
86830: PUSH
86831: LD_INT 1
86833: NEG
86834: PUSH
86835: EMPTY
86836: LIST
86837: LIST
86838: PUSH
86839: LD_INT 1
86841: PUSH
86842: LD_INT 0
86844: PUSH
86845: EMPTY
86846: LIST
86847: LIST
86848: PUSH
86849: LD_INT 1
86851: PUSH
86852: LD_INT 1
86854: PUSH
86855: EMPTY
86856: LIST
86857: LIST
86858: PUSH
86859: LD_INT 0
86861: PUSH
86862: LD_INT 1
86864: PUSH
86865: EMPTY
86866: LIST
86867: LIST
86868: PUSH
86869: LD_INT 1
86871: NEG
86872: PUSH
86873: LD_INT 0
86875: PUSH
86876: EMPTY
86877: LIST
86878: LIST
86879: PUSH
86880: LD_INT 1
86882: NEG
86883: PUSH
86884: LD_INT 1
86886: NEG
86887: PUSH
86888: EMPTY
86889: LIST
86890: LIST
86891: PUSH
86892: LD_INT 1
86894: NEG
86895: PUSH
86896: LD_INT 2
86898: NEG
86899: PUSH
86900: EMPTY
86901: LIST
86902: LIST
86903: PUSH
86904: LD_INT 0
86906: PUSH
86907: LD_INT 2
86909: NEG
86910: PUSH
86911: EMPTY
86912: LIST
86913: LIST
86914: PUSH
86915: LD_INT 1
86917: PUSH
86918: LD_INT 1
86920: NEG
86921: PUSH
86922: EMPTY
86923: LIST
86924: LIST
86925: PUSH
86926: LD_INT 2
86928: PUSH
86929: LD_INT 1
86931: PUSH
86932: EMPTY
86933: LIST
86934: LIST
86935: PUSH
86936: LD_INT 2
86938: PUSH
86939: LD_INT 2
86941: PUSH
86942: EMPTY
86943: LIST
86944: LIST
86945: PUSH
86946: LD_INT 1
86948: PUSH
86949: LD_INT 2
86951: PUSH
86952: EMPTY
86953: LIST
86954: LIST
86955: PUSH
86956: LD_INT 0
86958: PUSH
86959: LD_INT 2
86961: PUSH
86962: EMPTY
86963: LIST
86964: LIST
86965: PUSH
86966: LD_INT 1
86968: NEG
86969: PUSH
86970: LD_INT 1
86972: PUSH
86973: EMPTY
86974: LIST
86975: LIST
86976: PUSH
86977: LD_INT 2
86979: NEG
86980: PUSH
86981: LD_INT 1
86983: NEG
86984: PUSH
86985: EMPTY
86986: LIST
86987: LIST
86988: PUSH
86989: LD_INT 2
86991: NEG
86992: PUSH
86993: LD_INT 2
86995: NEG
86996: PUSH
86997: EMPTY
86998: LIST
86999: LIST
87000: PUSH
87001: LD_INT 2
87003: NEG
87004: PUSH
87005: LD_INT 3
87007: NEG
87008: PUSH
87009: EMPTY
87010: LIST
87011: LIST
87012: PUSH
87013: LD_INT 1
87015: NEG
87016: PUSH
87017: LD_INT 3
87019: NEG
87020: PUSH
87021: EMPTY
87022: LIST
87023: LIST
87024: PUSH
87025: LD_INT 0
87027: PUSH
87028: LD_INT 3
87030: NEG
87031: PUSH
87032: EMPTY
87033: LIST
87034: LIST
87035: PUSH
87036: LD_INT 1
87038: PUSH
87039: LD_INT 2
87041: NEG
87042: PUSH
87043: EMPTY
87044: LIST
87045: LIST
87046: PUSH
87047: LD_INT 3
87049: PUSH
87050: LD_INT 2
87052: PUSH
87053: EMPTY
87054: LIST
87055: LIST
87056: PUSH
87057: LD_INT 3
87059: PUSH
87060: LD_INT 3
87062: PUSH
87063: EMPTY
87064: LIST
87065: LIST
87066: PUSH
87067: LD_INT 2
87069: PUSH
87070: LD_INT 3
87072: PUSH
87073: EMPTY
87074: LIST
87075: LIST
87076: PUSH
87077: LD_INT 1
87079: PUSH
87080: LD_INT 3
87082: PUSH
87083: EMPTY
87084: LIST
87085: LIST
87086: PUSH
87087: LD_INT 0
87089: PUSH
87090: LD_INT 3
87092: PUSH
87093: EMPTY
87094: LIST
87095: LIST
87096: PUSH
87097: LD_INT 1
87099: NEG
87100: PUSH
87101: LD_INT 2
87103: PUSH
87104: EMPTY
87105: LIST
87106: LIST
87107: PUSH
87108: LD_INT 3
87110: NEG
87111: PUSH
87112: LD_INT 2
87114: NEG
87115: PUSH
87116: EMPTY
87117: LIST
87118: LIST
87119: PUSH
87120: LD_INT 3
87122: NEG
87123: PUSH
87124: LD_INT 3
87126: NEG
87127: PUSH
87128: EMPTY
87129: LIST
87130: LIST
87131: PUSH
87132: EMPTY
87133: LIST
87134: LIST
87135: LIST
87136: LIST
87137: LIST
87138: LIST
87139: LIST
87140: LIST
87141: LIST
87142: LIST
87143: LIST
87144: LIST
87145: LIST
87146: LIST
87147: LIST
87148: LIST
87149: LIST
87150: LIST
87151: LIST
87152: LIST
87153: LIST
87154: LIST
87155: LIST
87156: LIST
87157: LIST
87158: LIST
87159: LIST
87160: LIST
87161: LIST
87162: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87163: LD_ADDR_VAR 0 43
87167: PUSH
87168: LD_INT 0
87170: PUSH
87171: LD_INT 0
87173: PUSH
87174: EMPTY
87175: LIST
87176: LIST
87177: PUSH
87178: LD_INT 0
87180: PUSH
87181: LD_INT 1
87183: NEG
87184: PUSH
87185: EMPTY
87186: LIST
87187: LIST
87188: PUSH
87189: LD_INT 1
87191: PUSH
87192: LD_INT 0
87194: PUSH
87195: EMPTY
87196: LIST
87197: LIST
87198: PUSH
87199: LD_INT 1
87201: PUSH
87202: LD_INT 1
87204: PUSH
87205: EMPTY
87206: LIST
87207: LIST
87208: PUSH
87209: LD_INT 0
87211: PUSH
87212: LD_INT 1
87214: PUSH
87215: EMPTY
87216: LIST
87217: LIST
87218: PUSH
87219: LD_INT 1
87221: NEG
87222: PUSH
87223: LD_INT 0
87225: PUSH
87226: EMPTY
87227: LIST
87228: LIST
87229: PUSH
87230: LD_INT 1
87232: NEG
87233: PUSH
87234: LD_INT 1
87236: NEG
87237: PUSH
87238: EMPTY
87239: LIST
87240: LIST
87241: PUSH
87242: LD_INT 1
87244: NEG
87245: PUSH
87246: LD_INT 2
87248: NEG
87249: PUSH
87250: EMPTY
87251: LIST
87252: LIST
87253: PUSH
87254: LD_INT 0
87256: PUSH
87257: LD_INT 2
87259: NEG
87260: PUSH
87261: EMPTY
87262: LIST
87263: LIST
87264: PUSH
87265: LD_INT 1
87267: PUSH
87268: LD_INT 1
87270: NEG
87271: PUSH
87272: EMPTY
87273: LIST
87274: LIST
87275: PUSH
87276: LD_INT 2
87278: PUSH
87279: LD_INT 0
87281: PUSH
87282: EMPTY
87283: LIST
87284: LIST
87285: PUSH
87286: LD_INT 2
87288: PUSH
87289: LD_INT 1
87291: PUSH
87292: EMPTY
87293: LIST
87294: LIST
87295: PUSH
87296: LD_INT 1
87298: PUSH
87299: LD_INT 2
87301: PUSH
87302: EMPTY
87303: LIST
87304: LIST
87305: PUSH
87306: LD_INT 0
87308: PUSH
87309: LD_INT 2
87311: PUSH
87312: EMPTY
87313: LIST
87314: LIST
87315: PUSH
87316: LD_INT 1
87318: NEG
87319: PUSH
87320: LD_INT 1
87322: PUSH
87323: EMPTY
87324: LIST
87325: LIST
87326: PUSH
87327: LD_INT 2
87329: NEG
87330: PUSH
87331: LD_INT 0
87333: PUSH
87334: EMPTY
87335: LIST
87336: LIST
87337: PUSH
87338: LD_INT 2
87340: NEG
87341: PUSH
87342: LD_INT 1
87344: NEG
87345: PUSH
87346: EMPTY
87347: LIST
87348: LIST
87349: PUSH
87350: LD_INT 1
87352: NEG
87353: PUSH
87354: LD_INT 3
87356: NEG
87357: PUSH
87358: EMPTY
87359: LIST
87360: LIST
87361: PUSH
87362: LD_INT 0
87364: PUSH
87365: LD_INT 3
87367: NEG
87368: PUSH
87369: EMPTY
87370: LIST
87371: LIST
87372: PUSH
87373: LD_INT 1
87375: PUSH
87376: LD_INT 2
87378: NEG
87379: PUSH
87380: EMPTY
87381: LIST
87382: LIST
87383: PUSH
87384: LD_INT 2
87386: PUSH
87387: LD_INT 1
87389: NEG
87390: PUSH
87391: EMPTY
87392: LIST
87393: LIST
87394: PUSH
87395: LD_INT 3
87397: PUSH
87398: LD_INT 0
87400: PUSH
87401: EMPTY
87402: LIST
87403: LIST
87404: PUSH
87405: LD_INT 3
87407: PUSH
87408: LD_INT 1
87410: PUSH
87411: EMPTY
87412: LIST
87413: LIST
87414: PUSH
87415: LD_INT 1
87417: PUSH
87418: LD_INT 3
87420: PUSH
87421: EMPTY
87422: LIST
87423: LIST
87424: PUSH
87425: LD_INT 0
87427: PUSH
87428: LD_INT 3
87430: PUSH
87431: EMPTY
87432: LIST
87433: LIST
87434: PUSH
87435: LD_INT 1
87437: NEG
87438: PUSH
87439: LD_INT 2
87441: PUSH
87442: EMPTY
87443: LIST
87444: LIST
87445: PUSH
87446: LD_INT 2
87448: NEG
87449: PUSH
87450: LD_INT 1
87452: PUSH
87453: EMPTY
87454: LIST
87455: LIST
87456: PUSH
87457: LD_INT 3
87459: NEG
87460: PUSH
87461: LD_INT 0
87463: PUSH
87464: EMPTY
87465: LIST
87466: LIST
87467: PUSH
87468: LD_INT 3
87470: NEG
87471: PUSH
87472: LD_INT 1
87474: NEG
87475: PUSH
87476: EMPTY
87477: LIST
87478: LIST
87479: PUSH
87480: EMPTY
87481: LIST
87482: LIST
87483: LIST
87484: LIST
87485: LIST
87486: LIST
87487: LIST
87488: LIST
87489: LIST
87490: LIST
87491: LIST
87492: LIST
87493: LIST
87494: LIST
87495: LIST
87496: LIST
87497: LIST
87498: LIST
87499: LIST
87500: LIST
87501: LIST
87502: LIST
87503: LIST
87504: LIST
87505: LIST
87506: LIST
87507: LIST
87508: LIST
87509: LIST
87510: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87511: LD_ADDR_VAR 0 44
87515: PUSH
87516: LD_INT 0
87518: PUSH
87519: LD_INT 0
87521: PUSH
87522: EMPTY
87523: LIST
87524: LIST
87525: PUSH
87526: LD_INT 0
87528: PUSH
87529: LD_INT 1
87531: NEG
87532: PUSH
87533: EMPTY
87534: LIST
87535: LIST
87536: PUSH
87537: LD_INT 1
87539: PUSH
87540: LD_INT 0
87542: PUSH
87543: EMPTY
87544: LIST
87545: LIST
87546: PUSH
87547: LD_INT 1
87549: PUSH
87550: LD_INT 1
87552: PUSH
87553: EMPTY
87554: LIST
87555: LIST
87556: PUSH
87557: LD_INT 0
87559: PUSH
87560: LD_INT 1
87562: PUSH
87563: EMPTY
87564: LIST
87565: LIST
87566: PUSH
87567: LD_INT 1
87569: NEG
87570: PUSH
87571: LD_INT 0
87573: PUSH
87574: EMPTY
87575: LIST
87576: LIST
87577: PUSH
87578: LD_INT 1
87580: NEG
87581: PUSH
87582: LD_INT 1
87584: NEG
87585: PUSH
87586: EMPTY
87587: LIST
87588: LIST
87589: PUSH
87590: LD_INT 1
87592: NEG
87593: PUSH
87594: LD_INT 2
87596: NEG
87597: PUSH
87598: EMPTY
87599: LIST
87600: LIST
87601: PUSH
87602: LD_INT 1
87604: PUSH
87605: LD_INT 1
87607: NEG
87608: PUSH
87609: EMPTY
87610: LIST
87611: LIST
87612: PUSH
87613: LD_INT 2
87615: PUSH
87616: LD_INT 0
87618: PUSH
87619: EMPTY
87620: LIST
87621: LIST
87622: PUSH
87623: LD_INT 2
87625: PUSH
87626: LD_INT 1
87628: PUSH
87629: EMPTY
87630: LIST
87631: LIST
87632: PUSH
87633: LD_INT 2
87635: PUSH
87636: LD_INT 2
87638: PUSH
87639: EMPTY
87640: LIST
87641: LIST
87642: PUSH
87643: LD_INT 1
87645: PUSH
87646: LD_INT 2
87648: PUSH
87649: EMPTY
87650: LIST
87651: LIST
87652: PUSH
87653: LD_INT 1
87655: NEG
87656: PUSH
87657: LD_INT 1
87659: PUSH
87660: EMPTY
87661: LIST
87662: LIST
87663: PUSH
87664: LD_INT 2
87666: NEG
87667: PUSH
87668: LD_INT 0
87670: PUSH
87671: EMPTY
87672: LIST
87673: LIST
87674: PUSH
87675: LD_INT 2
87677: NEG
87678: PUSH
87679: LD_INT 1
87681: NEG
87682: PUSH
87683: EMPTY
87684: LIST
87685: LIST
87686: PUSH
87687: LD_INT 2
87689: NEG
87690: PUSH
87691: LD_INT 2
87693: NEG
87694: PUSH
87695: EMPTY
87696: LIST
87697: LIST
87698: PUSH
87699: LD_INT 2
87701: NEG
87702: PUSH
87703: LD_INT 3
87705: NEG
87706: PUSH
87707: EMPTY
87708: LIST
87709: LIST
87710: PUSH
87711: LD_INT 2
87713: PUSH
87714: LD_INT 1
87716: NEG
87717: PUSH
87718: EMPTY
87719: LIST
87720: LIST
87721: PUSH
87722: LD_INT 3
87724: PUSH
87725: LD_INT 0
87727: PUSH
87728: EMPTY
87729: LIST
87730: LIST
87731: PUSH
87732: LD_INT 3
87734: PUSH
87735: LD_INT 1
87737: PUSH
87738: EMPTY
87739: LIST
87740: LIST
87741: PUSH
87742: LD_INT 3
87744: PUSH
87745: LD_INT 2
87747: PUSH
87748: EMPTY
87749: LIST
87750: LIST
87751: PUSH
87752: LD_INT 3
87754: PUSH
87755: LD_INT 3
87757: PUSH
87758: EMPTY
87759: LIST
87760: LIST
87761: PUSH
87762: LD_INT 2
87764: PUSH
87765: LD_INT 3
87767: PUSH
87768: EMPTY
87769: LIST
87770: LIST
87771: PUSH
87772: LD_INT 2
87774: NEG
87775: PUSH
87776: LD_INT 1
87778: PUSH
87779: EMPTY
87780: LIST
87781: LIST
87782: PUSH
87783: LD_INT 3
87785: NEG
87786: PUSH
87787: LD_INT 0
87789: PUSH
87790: EMPTY
87791: LIST
87792: LIST
87793: PUSH
87794: LD_INT 3
87796: NEG
87797: PUSH
87798: LD_INT 1
87800: NEG
87801: PUSH
87802: EMPTY
87803: LIST
87804: LIST
87805: PUSH
87806: LD_INT 3
87808: NEG
87809: PUSH
87810: LD_INT 2
87812: NEG
87813: PUSH
87814: EMPTY
87815: LIST
87816: LIST
87817: PUSH
87818: LD_INT 3
87820: NEG
87821: PUSH
87822: LD_INT 3
87824: NEG
87825: PUSH
87826: EMPTY
87827: LIST
87828: LIST
87829: PUSH
87830: EMPTY
87831: LIST
87832: LIST
87833: LIST
87834: LIST
87835: LIST
87836: LIST
87837: LIST
87838: LIST
87839: LIST
87840: LIST
87841: LIST
87842: LIST
87843: LIST
87844: LIST
87845: LIST
87846: LIST
87847: LIST
87848: LIST
87849: LIST
87850: LIST
87851: LIST
87852: LIST
87853: LIST
87854: LIST
87855: LIST
87856: LIST
87857: LIST
87858: LIST
87859: LIST
87860: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87861: LD_ADDR_VAR 0 45
87865: PUSH
87866: LD_INT 0
87868: PUSH
87869: LD_INT 0
87871: PUSH
87872: EMPTY
87873: LIST
87874: LIST
87875: PUSH
87876: LD_INT 0
87878: PUSH
87879: LD_INT 1
87881: NEG
87882: PUSH
87883: EMPTY
87884: LIST
87885: LIST
87886: PUSH
87887: LD_INT 1
87889: PUSH
87890: LD_INT 0
87892: PUSH
87893: EMPTY
87894: LIST
87895: LIST
87896: PUSH
87897: LD_INT 1
87899: PUSH
87900: LD_INT 1
87902: PUSH
87903: EMPTY
87904: LIST
87905: LIST
87906: PUSH
87907: LD_INT 0
87909: PUSH
87910: LD_INT 1
87912: PUSH
87913: EMPTY
87914: LIST
87915: LIST
87916: PUSH
87917: LD_INT 1
87919: NEG
87920: PUSH
87921: LD_INT 0
87923: PUSH
87924: EMPTY
87925: LIST
87926: LIST
87927: PUSH
87928: LD_INT 1
87930: NEG
87931: PUSH
87932: LD_INT 1
87934: NEG
87935: PUSH
87936: EMPTY
87937: LIST
87938: LIST
87939: PUSH
87940: LD_INT 1
87942: NEG
87943: PUSH
87944: LD_INT 2
87946: NEG
87947: PUSH
87948: EMPTY
87949: LIST
87950: LIST
87951: PUSH
87952: LD_INT 0
87954: PUSH
87955: LD_INT 2
87957: NEG
87958: PUSH
87959: EMPTY
87960: LIST
87961: LIST
87962: PUSH
87963: LD_INT 1
87965: PUSH
87966: LD_INT 1
87968: NEG
87969: PUSH
87970: EMPTY
87971: LIST
87972: LIST
87973: PUSH
87974: LD_INT 2
87976: PUSH
87977: LD_INT 1
87979: PUSH
87980: EMPTY
87981: LIST
87982: LIST
87983: PUSH
87984: LD_INT 2
87986: PUSH
87987: LD_INT 2
87989: PUSH
87990: EMPTY
87991: LIST
87992: LIST
87993: PUSH
87994: LD_INT 1
87996: PUSH
87997: LD_INT 2
87999: PUSH
88000: EMPTY
88001: LIST
88002: LIST
88003: PUSH
88004: LD_INT 0
88006: PUSH
88007: LD_INT 2
88009: PUSH
88010: EMPTY
88011: LIST
88012: LIST
88013: PUSH
88014: LD_INT 1
88016: NEG
88017: PUSH
88018: LD_INT 1
88020: PUSH
88021: EMPTY
88022: LIST
88023: LIST
88024: PUSH
88025: LD_INT 2
88027: NEG
88028: PUSH
88029: LD_INT 1
88031: NEG
88032: PUSH
88033: EMPTY
88034: LIST
88035: LIST
88036: PUSH
88037: LD_INT 2
88039: NEG
88040: PUSH
88041: LD_INT 2
88043: NEG
88044: PUSH
88045: EMPTY
88046: LIST
88047: LIST
88048: PUSH
88049: LD_INT 2
88051: NEG
88052: PUSH
88053: LD_INT 3
88055: NEG
88056: PUSH
88057: EMPTY
88058: LIST
88059: LIST
88060: PUSH
88061: LD_INT 1
88063: NEG
88064: PUSH
88065: LD_INT 3
88067: NEG
88068: PUSH
88069: EMPTY
88070: LIST
88071: LIST
88072: PUSH
88073: LD_INT 0
88075: PUSH
88076: LD_INT 3
88078: NEG
88079: PUSH
88080: EMPTY
88081: LIST
88082: LIST
88083: PUSH
88084: LD_INT 1
88086: PUSH
88087: LD_INT 2
88089: NEG
88090: PUSH
88091: EMPTY
88092: LIST
88093: LIST
88094: PUSH
88095: LD_INT 3
88097: PUSH
88098: LD_INT 2
88100: PUSH
88101: EMPTY
88102: LIST
88103: LIST
88104: PUSH
88105: LD_INT 3
88107: PUSH
88108: LD_INT 3
88110: PUSH
88111: EMPTY
88112: LIST
88113: LIST
88114: PUSH
88115: LD_INT 2
88117: PUSH
88118: LD_INT 3
88120: PUSH
88121: EMPTY
88122: LIST
88123: LIST
88124: PUSH
88125: LD_INT 1
88127: PUSH
88128: LD_INT 3
88130: PUSH
88131: EMPTY
88132: LIST
88133: LIST
88134: PUSH
88135: LD_INT 0
88137: PUSH
88138: LD_INT 3
88140: PUSH
88141: EMPTY
88142: LIST
88143: LIST
88144: PUSH
88145: LD_INT 1
88147: NEG
88148: PUSH
88149: LD_INT 2
88151: PUSH
88152: EMPTY
88153: LIST
88154: LIST
88155: PUSH
88156: LD_INT 3
88158: NEG
88159: PUSH
88160: LD_INT 2
88162: NEG
88163: PUSH
88164: EMPTY
88165: LIST
88166: LIST
88167: PUSH
88168: LD_INT 3
88170: NEG
88171: PUSH
88172: LD_INT 3
88174: NEG
88175: PUSH
88176: EMPTY
88177: LIST
88178: LIST
88179: PUSH
88180: EMPTY
88181: LIST
88182: LIST
88183: LIST
88184: LIST
88185: LIST
88186: LIST
88187: LIST
88188: LIST
88189: LIST
88190: LIST
88191: LIST
88192: LIST
88193: LIST
88194: LIST
88195: LIST
88196: LIST
88197: LIST
88198: LIST
88199: LIST
88200: LIST
88201: LIST
88202: LIST
88203: LIST
88204: LIST
88205: LIST
88206: LIST
88207: LIST
88208: LIST
88209: LIST
88210: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88211: LD_ADDR_VAR 0 46
88215: PUSH
88216: LD_INT 0
88218: PUSH
88219: LD_INT 0
88221: PUSH
88222: EMPTY
88223: LIST
88224: LIST
88225: PUSH
88226: LD_INT 0
88228: PUSH
88229: LD_INT 1
88231: NEG
88232: PUSH
88233: EMPTY
88234: LIST
88235: LIST
88236: PUSH
88237: LD_INT 1
88239: PUSH
88240: LD_INT 0
88242: PUSH
88243: EMPTY
88244: LIST
88245: LIST
88246: PUSH
88247: LD_INT 1
88249: PUSH
88250: LD_INT 1
88252: PUSH
88253: EMPTY
88254: LIST
88255: LIST
88256: PUSH
88257: LD_INT 0
88259: PUSH
88260: LD_INT 1
88262: PUSH
88263: EMPTY
88264: LIST
88265: LIST
88266: PUSH
88267: LD_INT 1
88269: NEG
88270: PUSH
88271: LD_INT 0
88273: PUSH
88274: EMPTY
88275: LIST
88276: LIST
88277: PUSH
88278: LD_INT 1
88280: NEG
88281: PUSH
88282: LD_INT 1
88284: NEG
88285: PUSH
88286: EMPTY
88287: LIST
88288: LIST
88289: PUSH
88290: LD_INT 1
88292: NEG
88293: PUSH
88294: LD_INT 2
88296: NEG
88297: PUSH
88298: EMPTY
88299: LIST
88300: LIST
88301: PUSH
88302: LD_INT 0
88304: PUSH
88305: LD_INT 2
88307: NEG
88308: PUSH
88309: EMPTY
88310: LIST
88311: LIST
88312: PUSH
88313: LD_INT 1
88315: PUSH
88316: LD_INT 1
88318: NEG
88319: PUSH
88320: EMPTY
88321: LIST
88322: LIST
88323: PUSH
88324: LD_INT 2
88326: PUSH
88327: LD_INT 0
88329: PUSH
88330: EMPTY
88331: LIST
88332: LIST
88333: PUSH
88334: LD_INT 2
88336: PUSH
88337: LD_INT 1
88339: PUSH
88340: EMPTY
88341: LIST
88342: LIST
88343: PUSH
88344: LD_INT 1
88346: PUSH
88347: LD_INT 2
88349: PUSH
88350: EMPTY
88351: LIST
88352: LIST
88353: PUSH
88354: LD_INT 0
88356: PUSH
88357: LD_INT 2
88359: PUSH
88360: EMPTY
88361: LIST
88362: LIST
88363: PUSH
88364: LD_INT 1
88366: NEG
88367: PUSH
88368: LD_INT 1
88370: PUSH
88371: EMPTY
88372: LIST
88373: LIST
88374: PUSH
88375: LD_INT 2
88377: NEG
88378: PUSH
88379: LD_INT 0
88381: PUSH
88382: EMPTY
88383: LIST
88384: LIST
88385: PUSH
88386: LD_INT 2
88388: NEG
88389: PUSH
88390: LD_INT 1
88392: NEG
88393: PUSH
88394: EMPTY
88395: LIST
88396: LIST
88397: PUSH
88398: LD_INT 1
88400: NEG
88401: PUSH
88402: LD_INT 3
88404: NEG
88405: PUSH
88406: EMPTY
88407: LIST
88408: LIST
88409: PUSH
88410: LD_INT 0
88412: PUSH
88413: LD_INT 3
88415: NEG
88416: PUSH
88417: EMPTY
88418: LIST
88419: LIST
88420: PUSH
88421: LD_INT 1
88423: PUSH
88424: LD_INT 2
88426: NEG
88427: PUSH
88428: EMPTY
88429: LIST
88430: LIST
88431: PUSH
88432: LD_INT 2
88434: PUSH
88435: LD_INT 1
88437: NEG
88438: PUSH
88439: EMPTY
88440: LIST
88441: LIST
88442: PUSH
88443: LD_INT 3
88445: PUSH
88446: LD_INT 0
88448: PUSH
88449: EMPTY
88450: LIST
88451: LIST
88452: PUSH
88453: LD_INT 3
88455: PUSH
88456: LD_INT 1
88458: PUSH
88459: EMPTY
88460: LIST
88461: LIST
88462: PUSH
88463: LD_INT 1
88465: PUSH
88466: LD_INT 3
88468: PUSH
88469: EMPTY
88470: LIST
88471: LIST
88472: PUSH
88473: LD_INT 0
88475: PUSH
88476: LD_INT 3
88478: PUSH
88479: EMPTY
88480: LIST
88481: LIST
88482: PUSH
88483: LD_INT 1
88485: NEG
88486: PUSH
88487: LD_INT 2
88489: PUSH
88490: EMPTY
88491: LIST
88492: LIST
88493: PUSH
88494: LD_INT 2
88496: NEG
88497: PUSH
88498: LD_INT 1
88500: PUSH
88501: EMPTY
88502: LIST
88503: LIST
88504: PUSH
88505: LD_INT 3
88507: NEG
88508: PUSH
88509: LD_INT 0
88511: PUSH
88512: EMPTY
88513: LIST
88514: LIST
88515: PUSH
88516: LD_INT 3
88518: NEG
88519: PUSH
88520: LD_INT 1
88522: NEG
88523: PUSH
88524: EMPTY
88525: LIST
88526: LIST
88527: PUSH
88528: EMPTY
88529: LIST
88530: LIST
88531: LIST
88532: LIST
88533: LIST
88534: LIST
88535: LIST
88536: LIST
88537: LIST
88538: LIST
88539: LIST
88540: LIST
88541: LIST
88542: LIST
88543: LIST
88544: LIST
88545: LIST
88546: LIST
88547: LIST
88548: LIST
88549: LIST
88550: LIST
88551: LIST
88552: LIST
88553: LIST
88554: LIST
88555: LIST
88556: LIST
88557: LIST
88558: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88559: LD_ADDR_VAR 0 47
88563: PUSH
88564: LD_INT 0
88566: PUSH
88567: LD_INT 0
88569: PUSH
88570: EMPTY
88571: LIST
88572: LIST
88573: PUSH
88574: LD_INT 0
88576: PUSH
88577: LD_INT 1
88579: NEG
88580: PUSH
88581: EMPTY
88582: LIST
88583: LIST
88584: PUSH
88585: LD_INT 1
88587: PUSH
88588: LD_INT 0
88590: PUSH
88591: EMPTY
88592: LIST
88593: LIST
88594: PUSH
88595: LD_INT 1
88597: PUSH
88598: LD_INT 1
88600: PUSH
88601: EMPTY
88602: LIST
88603: LIST
88604: PUSH
88605: LD_INT 0
88607: PUSH
88608: LD_INT 1
88610: PUSH
88611: EMPTY
88612: LIST
88613: LIST
88614: PUSH
88615: LD_INT 1
88617: NEG
88618: PUSH
88619: LD_INT 0
88621: PUSH
88622: EMPTY
88623: LIST
88624: LIST
88625: PUSH
88626: LD_INT 1
88628: NEG
88629: PUSH
88630: LD_INT 1
88632: NEG
88633: PUSH
88634: EMPTY
88635: LIST
88636: LIST
88637: PUSH
88638: LD_INT 1
88640: NEG
88641: PUSH
88642: LD_INT 2
88644: NEG
88645: PUSH
88646: EMPTY
88647: LIST
88648: LIST
88649: PUSH
88650: LD_INT 0
88652: PUSH
88653: LD_INT 2
88655: NEG
88656: PUSH
88657: EMPTY
88658: LIST
88659: LIST
88660: PUSH
88661: LD_INT 1
88663: PUSH
88664: LD_INT 1
88666: NEG
88667: PUSH
88668: EMPTY
88669: LIST
88670: LIST
88671: PUSH
88672: LD_INT 2
88674: NEG
88675: PUSH
88676: LD_INT 1
88678: NEG
88679: PUSH
88680: EMPTY
88681: LIST
88682: LIST
88683: PUSH
88684: LD_INT 2
88686: NEG
88687: PUSH
88688: LD_INT 2
88690: NEG
88691: PUSH
88692: EMPTY
88693: LIST
88694: LIST
88695: PUSH
88696: EMPTY
88697: LIST
88698: LIST
88699: LIST
88700: LIST
88701: LIST
88702: LIST
88703: LIST
88704: LIST
88705: LIST
88706: LIST
88707: LIST
88708: LIST
88709: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
88710: LD_ADDR_VAR 0 48
88714: PUSH
88715: LD_INT 0
88717: PUSH
88718: LD_INT 0
88720: PUSH
88721: EMPTY
88722: LIST
88723: LIST
88724: PUSH
88725: LD_INT 0
88727: PUSH
88728: LD_INT 1
88730: NEG
88731: PUSH
88732: EMPTY
88733: LIST
88734: LIST
88735: PUSH
88736: LD_INT 1
88738: PUSH
88739: LD_INT 0
88741: PUSH
88742: EMPTY
88743: LIST
88744: LIST
88745: PUSH
88746: LD_INT 1
88748: PUSH
88749: LD_INT 1
88751: PUSH
88752: EMPTY
88753: LIST
88754: LIST
88755: PUSH
88756: LD_INT 0
88758: PUSH
88759: LD_INT 1
88761: PUSH
88762: EMPTY
88763: LIST
88764: LIST
88765: PUSH
88766: LD_INT 1
88768: NEG
88769: PUSH
88770: LD_INT 0
88772: PUSH
88773: EMPTY
88774: LIST
88775: LIST
88776: PUSH
88777: LD_INT 1
88779: NEG
88780: PUSH
88781: LD_INT 1
88783: NEG
88784: PUSH
88785: EMPTY
88786: LIST
88787: LIST
88788: PUSH
88789: LD_INT 1
88791: NEG
88792: PUSH
88793: LD_INT 2
88795: NEG
88796: PUSH
88797: EMPTY
88798: LIST
88799: LIST
88800: PUSH
88801: LD_INT 0
88803: PUSH
88804: LD_INT 2
88806: NEG
88807: PUSH
88808: EMPTY
88809: LIST
88810: LIST
88811: PUSH
88812: LD_INT 1
88814: PUSH
88815: LD_INT 1
88817: NEG
88818: PUSH
88819: EMPTY
88820: LIST
88821: LIST
88822: PUSH
88823: LD_INT 2
88825: PUSH
88826: LD_INT 0
88828: PUSH
88829: EMPTY
88830: LIST
88831: LIST
88832: PUSH
88833: LD_INT 2
88835: PUSH
88836: LD_INT 1
88838: PUSH
88839: EMPTY
88840: LIST
88841: LIST
88842: PUSH
88843: EMPTY
88844: LIST
88845: LIST
88846: LIST
88847: LIST
88848: LIST
88849: LIST
88850: LIST
88851: LIST
88852: LIST
88853: LIST
88854: LIST
88855: LIST
88856: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
88857: LD_ADDR_VAR 0 49
88861: PUSH
88862: LD_INT 0
88864: PUSH
88865: LD_INT 0
88867: PUSH
88868: EMPTY
88869: LIST
88870: LIST
88871: PUSH
88872: LD_INT 0
88874: PUSH
88875: LD_INT 1
88877: NEG
88878: PUSH
88879: EMPTY
88880: LIST
88881: LIST
88882: PUSH
88883: LD_INT 1
88885: PUSH
88886: LD_INT 0
88888: PUSH
88889: EMPTY
88890: LIST
88891: LIST
88892: PUSH
88893: LD_INT 1
88895: PUSH
88896: LD_INT 1
88898: PUSH
88899: EMPTY
88900: LIST
88901: LIST
88902: PUSH
88903: LD_INT 0
88905: PUSH
88906: LD_INT 1
88908: PUSH
88909: EMPTY
88910: LIST
88911: LIST
88912: PUSH
88913: LD_INT 1
88915: NEG
88916: PUSH
88917: LD_INT 0
88919: PUSH
88920: EMPTY
88921: LIST
88922: LIST
88923: PUSH
88924: LD_INT 1
88926: NEG
88927: PUSH
88928: LD_INT 1
88930: NEG
88931: PUSH
88932: EMPTY
88933: LIST
88934: LIST
88935: PUSH
88936: LD_INT 1
88938: PUSH
88939: LD_INT 1
88941: NEG
88942: PUSH
88943: EMPTY
88944: LIST
88945: LIST
88946: PUSH
88947: LD_INT 2
88949: PUSH
88950: LD_INT 0
88952: PUSH
88953: EMPTY
88954: LIST
88955: LIST
88956: PUSH
88957: LD_INT 2
88959: PUSH
88960: LD_INT 1
88962: PUSH
88963: EMPTY
88964: LIST
88965: LIST
88966: PUSH
88967: LD_INT 2
88969: PUSH
88970: LD_INT 2
88972: PUSH
88973: EMPTY
88974: LIST
88975: LIST
88976: PUSH
88977: LD_INT 1
88979: PUSH
88980: LD_INT 2
88982: PUSH
88983: EMPTY
88984: LIST
88985: LIST
88986: PUSH
88987: EMPTY
88988: LIST
88989: LIST
88990: LIST
88991: LIST
88992: LIST
88993: LIST
88994: LIST
88995: LIST
88996: LIST
88997: LIST
88998: LIST
88999: LIST
89000: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
89001: LD_ADDR_VAR 0 50
89005: PUSH
89006: LD_INT 0
89008: PUSH
89009: LD_INT 0
89011: PUSH
89012: EMPTY
89013: LIST
89014: LIST
89015: PUSH
89016: LD_INT 0
89018: PUSH
89019: LD_INT 1
89021: NEG
89022: PUSH
89023: EMPTY
89024: LIST
89025: LIST
89026: PUSH
89027: LD_INT 1
89029: PUSH
89030: LD_INT 0
89032: PUSH
89033: EMPTY
89034: LIST
89035: LIST
89036: PUSH
89037: LD_INT 1
89039: PUSH
89040: LD_INT 1
89042: PUSH
89043: EMPTY
89044: LIST
89045: LIST
89046: PUSH
89047: LD_INT 0
89049: PUSH
89050: LD_INT 1
89052: PUSH
89053: EMPTY
89054: LIST
89055: LIST
89056: PUSH
89057: LD_INT 1
89059: NEG
89060: PUSH
89061: LD_INT 0
89063: PUSH
89064: EMPTY
89065: LIST
89066: LIST
89067: PUSH
89068: LD_INT 1
89070: NEG
89071: PUSH
89072: LD_INT 1
89074: NEG
89075: PUSH
89076: EMPTY
89077: LIST
89078: LIST
89079: PUSH
89080: LD_INT 2
89082: PUSH
89083: LD_INT 1
89085: PUSH
89086: EMPTY
89087: LIST
89088: LIST
89089: PUSH
89090: LD_INT 2
89092: PUSH
89093: LD_INT 2
89095: PUSH
89096: EMPTY
89097: LIST
89098: LIST
89099: PUSH
89100: LD_INT 1
89102: PUSH
89103: LD_INT 2
89105: PUSH
89106: EMPTY
89107: LIST
89108: LIST
89109: PUSH
89110: LD_INT 0
89112: PUSH
89113: LD_INT 2
89115: PUSH
89116: EMPTY
89117: LIST
89118: LIST
89119: PUSH
89120: LD_INT 1
89122: NEG
89123: PUSH
89124: LD_INT 1
89126: PUSH
89127: EMPTY
89128: LIST
89129: LIST
89130: PUSH
89131: EMPTY
89132: LIST
89133: LIST
89134: LIST
89135: LIST
89136: LIST
89137: LIST
89138: LIST
89139: LIST
89140: LIST
89141: LIST
89142: LIST
89143: LIST
89144: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89145: LD_ADDR_VAR 0 51
89149: PUSH
89150: LD_INT 0
89152: PUSH
89153: LD_INT 0
89155: PUSH
89156: EMPTY
89157: LIST
89158: LIST
89159: PUSH
89160: LD_INT 0
89162: PUSH
89163: LD_INT 1
89165: NEG
89166: PUSH
89167: EMPTY
89168: LIST
89169: LIST
89170: PUSH
89171: LD_INT 1
89173: PUSH
89174: LD_INT 0
89176: PUSH
89177: EMPTY
89178: LIST
89179: LIST
89180: PUSH
89181: LD_INT 1
89183: PUSH
89184: LD_INT 1
89186: PUSH
89187: EMPTY
89188: LIST
89189: LIST
89190: PUSH
89191: LD_INT 0
89193: PUSH
89194: LD_INT 1
89196: PUSH
89197: EMPTY
89198: LIST
89199: LIST
89200: PUSH
89201: LD_INT 1
89203: NEG
89204: PUSH
89205: LD_INT 0
89207: PUSH
89208: EMPTY
89209: LIST
89210: LIST
89211: PUSH
89212: LD_INT 1
89214: NEG
89215: PUSH
89216: LD_INT 1
89218: NEG
89219: PUSH
89220: EMPTY
89221: LIST
89222: LIST
89223: PUSH
89224: LD_INT 1
89226: PUSH
89227: LD_INT 2
89229: PUSH
89230: EMPTY
89231: LIST
89232: LIST
89233: PUSH
89234: LD_INT 0
89236: PUSH
89237: LD_INT 2
89239: PUSH
89240: EMPTY
89241: LIST
89242: LIST
89243: PUSH
89244: LD_INT 1
89246: NEG
89247: PUSH
89248: LD_INT 1
89250: PUSH
89251: EMPTY
89252: LIST
89253: LIST
89254: PUSH
89255: LD_INT 2
89257: NEG
89258: PUSH
89259: LD_INT 0
89261: PUSH
89262: EMPTY
89263: LIST
89264: LIST
89265: PUSH
89266: LD_INT 2
89268: NEG
89269: PUSH
89270: LD_INT 1
89272: NEG
89273: PUSH
89274: EMPTY
89275: LIST
89276: LIST
89277: PUSH
89278: EMPTY
89279: LIST
89280: LIST
89281: LIST
89282: LIST
89283: LIST
89284: LIST
89285: LIST
89286: LIST
89287: LIST
89288: LIST
89289: LIST
89290: LIST
89291: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89292: LD_ADDR_VAR 0 52
89296: PUSH
89297: LD_INT 0
89299: PUSH
89300: LD_INT 0
89302: PUSH
89303: EMPTY
89304: LIST
89305: LIST
89306: PUSH
89307: LD_INT 0
89309: PUSH
89310: LD_INT 1
89312: NEG
89313: PUSH
89314: EMPTY
89315: LIST
89316: LIST
89317: PUSH
89318: LD_INT 1
89320: PUSH
89321: LD_INT 0
89323: PUSH
89324: EMPTY
89325: LIST
89326: LIST
89327: PUSH
89328: LD_INT 1
89330: PUSH
89331: LD_INT 1
89333: PUSH
89334: EMPTY
89335: LIST
89336: LIST
89337: PUSH
89338: LD_INT 0
89340: PUSH
89341: LD_INT 1
89343: PUSH
89344: EMPTY
89345: LIST
89346: LIST
89347: PUSH
89348: LD_INT 1
89350: NEG
89351: PUSH
89352: LD_INT 0
89354: PUSH
89355: EMPTY
89356: LIST
89357: LIST
89358: PUSH
89359: LD_INT 1
89361: NEG
89362: PUSH
89363: LD_INT 1
89365: NEG
89366: PUSH
89367: EMPTY
89368: LIST
89369: LIST
89370: PUSH
89371: LD_INT 1
89373: NEG
89374: PUSH
89375: LD_INT 2
89377: NEG
89378: PUSH
89379: EMPTY
89380: LIST
89381: LIST
89382: PUSH
89383: LD_INT 1
89385: NEG
89386: PUSH
89387: LD_INT 1
89389: PUSH
89390: EMPTY
89391: LIST
89392: LIST
89393: PUSH
89394: LD_INT 2
89396: NEG
89397: PUSH
89398: LD_INT 0
89400: PUSH
89401: EMPTY
89402: LIST
89403: LIST
89404: PUSH
89405: LD_INT 2
89407: NEG
89408: PUSH
89409: LD_INT 1
89411: NEG
89412: PUSH
89413: EMPTY
89414: LIST
89415: LIST
89416: PUSH
89417: LD_INT 2
89419: NEG
89420: PUSH
89421: LD_INT 2
89423: NEG
89424: PUSH
89425: EMPTY
89426: LIST
89427: LIST
89428: PUSH
89429: EMPTY
89430: LIST
89431: LIST
89432: LIST
89433: LIST
89434: LIST
89435: LIST
89436: LIST
89437: LIST
89438: LIST
89439: LIST
89440: LIST
89441: LIST
89442: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89443: LD_ADDR_VAR 0 53
89447: PUSH
89448: LD_INT 0
89450: PUSH
89451: LD_INT 0
89453: PUSH
89454: EMPTY
89455: LIST
89456: LIST
89457: PUSH
89458: LD_INT 0
89460: PUSH
89461: LD_INT 1
89463: NEG
89464: PUSH
89465: EMPTY
89466: LIST
89467: LIST
89468: PUSH
89469: LD_INT 1
89471: PUSH
89472: LD_INT 0
89474: PUSH
89475: EMPTY
89476: LIST
89477: LIST
89478: PUSH
89479: LD_INT 1
89481: PUSH
89482: LD_INT 1
89484: PUSH
89485: EMPTY
89486: LIST
89487: LIST
89488: PUSH
89489: LD_INT 0
89491: PUSH
89492: LD_INT 1
89494: PUSH
89495: EMPTY
89496: LIST
89497: LIST
89498: PUSH
89499: LD_INT 1
89501: NEG
89502: PUSH
89503: LD_INT 0
89505: PUSH
89506: EMPTY
89507: LIST
89508: LIST
89509: PUSH
89510: LD_INT 1
89512: NEG
89513: PUSH
89514: LD_INT 1
89516: NEG
89517: PUSH
89518: EMPTY
89519: LIST
89520: LIST
89521: PUSH
89522: LD_INT 1
89524: NEG
89525: PUSH
89526: LD_INT 2
89528: NEG
89529: PUSH
89530: EMPTY
89531: LIST
89532: LIST
89533: PUSH
89534: LD_INT 0
89536: PUSH
89537: LD_INT 2
89539: NEG
89540: PUSH
89541: EMPTY
89542: LIST
89543: LIST
89544: PUSH
89545: LD_INT 1
89547: PUSH
89548: LD_INT 1
89550: NEG
89551: PUSH
89552: EMPTY
89553: LIST
89554: LIST
89555: PUSH
89556: LD_INT 2
89558: PUSH
89559: LD_INT 0
89561: PUSH
89562: EMPTY
89563: LIST
89564: LIST
89565: PUSH
89566: LD_INT 2
89568: PUSH
89569: LD_INT 1
89571: PUSH
89572: EMPTY
89573: LIST
89574: LIST
89575: PUSH
89576: LD_INT 2
89578: PUSH
89579: LD_INT 2
89581: PUSH
89582: EMPTY
89583: LIST
89584: LIST
89585: PUSH
89586: LD_INT 1
89588: PUSH
89589: LD_INT 2
89591: PUSH
89592: EMPTY
89593: LIST
89594: LIST
89595: PUSH
89596: LD_INT 0
89598: PUSH
89599: LD_INT 2
89601: PUSH
89602: EMPTY
89603: LIST
89604: LIST
89605: PUSH
89606: LD_INT 1
89608: NEG
89609: PUSH
89610: LD_INT 1
89612: PUSH
89613: EMPTY
89614: LIST
89615: LIST
89616: PUSH
89617: LD_INT 2
89619: NEG
89620: PUSH
89621: LD_INT 0
89623: PUSH
89624: EMPTY
89625: LIST
89626: LIST
89627: PUSH
89628: LD_INT 2
89630: NEG
89631: PUSH
89632: LD_INT 1
89634: NEG
89635: PUSH
89636: EMPTY
89637: LIST
89638: LIST
89639: PUSH
89640: LD_INT 2
89642: NEG
89643: PUSH
89644: LD_INT 2
89646: NEG
89647: PUSH
89648: EMPTY
89649: LIST
89650: LIST
89651: PUSH
89652: EMPTY
89653: LIST
89654: LIST
89655: LIST
89656: LIST
89657: LIST
89658: LIST
89659: LIST
89660: LIST
89661: LIST
89662: LIST
89663: LIST
89664: LIST
89665: LIST
89666: LIST
89667: LIST
89668: LIST
89669: LIST
89670: LIST
89671: LIST
89672: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89673: LD_ADDR_VAR 0 54
89677: PUSH
89678: LD_INT 0
89680: PUSH
89681: LD_INT 0
89683: PUSH
89684: EMPTY
89685: LIST
89686: LIST
89687: PUSH
89688: LD_INT 0
89690: PUSH
89691: LD_INT 1
89693: NEG
89694: PUSH
89695: EMPTY
89696: LIST
89697: LIST
89698: PUSH
89699: LD_INT 1
89701: PUSH
89702: LD_INT 0
89704: PUSH
89705: EMPTY
89706: LIST
89707: LIST
89708: PUSH
89709: LD_INT 1
89711: PUSH
89712: LD_INT 1
89714: PUSH
89715: EMPTY
89716: LIST
89717: LIST
89718: PUSH
89719: LD_INT 0
89721: PUSH
89722: LD_INT 1
89724: PUSH
89725: EMPTY
89726: LIST
89727: LIST
89728: PUSH
89729: LD_INT 1
89731: NEG
89732: PUSH
89733: LD_INT 0
89735: PUSH
89736: EMPTY
89737: LIST
89738: LIST
89739: PUSH
89740: LD_INT 1
89742: NEG
89743: PUSH
89744: LD_INT 1
89746: NEG
89747: PUSH
89748: EMPTY
89749: LIST
89750: LIST
89751: PUSH
89752: LD_INT 1
89754: NEG
89755: PUSH
89756: LD_INT 2
89758: NEG
89759: PUSH
89760: EMPTY
89761: LIST
89762: LIST
89763: PUSH
89764: LD_INT 0
89766: PUSH
89767: LD_INT 2
89769: NEG
89770: PUSH
89771: EMPTY
89772: LIST
89773: LIST
89774: PUSH
89775: LD_INT 1
89777: PUSH
89778: LD_INT 1
89780: NEG
89781: PUSH
89782: EMPTY
89783: LIST
89784: LIST
89785: PUSH
89786: LD_INT 2
89788: PUSH
89789: LD_INT 0
89791: PUSH
89792: EMPTY
89793: LIST
89794: LIST
89795: PUSH
89796: LD_INT 2
89798: PUSH
89799: LD_INT 1
89801: PUSH
89802: EMPTY
89803: LIST
89804: LIST
89805: PUSH
89806: LD_INT 2
89808: PUSH
89809: LD_INT 2
89811: PUSH
89812: EMPTY
89813: LIST
89814: LIST
89815: PUSH
89816: LD_INT 1
89818: PUSH
89819: LD_INT 2
89821: PUSH
89822: EMPTY
89823: LIST
89824: LIST
89825: PUSH
89826: LD_INT 0
89828: PUSH
89829: LD_INT 2
89831: PUSH
89832: EMPTY
89833: LIST
89834: LIST
89835: PUSH
89836: LD_INT 1
89838: NEG
89839: PUSH
89840: LD_INT 1
89842: PUSH
89843: EMPTY
89844: LIST
89845: LIST
89846: PUSH
89847: LD_INT 2
89849: NEG
89850: PUSH
89851: LD_INT 0
89853: PUSH
89854: EMPTY
89855: LIST
89856: LIST
89857: PUSH
89858: LD_INT 2
89860: NEG
89861: PUSH
89862: LD_INT 1
89864: NEG
89865: PUSH
89866: EMPTY
89867: LIST
89868: LIST
89869: PUSH
89870: LD_INT 2
89872: NEG
89873: PUSH
89874: LD_INT 2
89876: NEG
89877: PUSH
89878: EMPTY
89879: LIST
89880: LIST
89881: PUSH
89882: EMPTY
89883: LIST
89884: LIST
89885: LIST
89886: LIST
89887: LIST
89888: LIST
89889: LIST
89890: LIST
89891: LIST
89892: LIST
89893: LIST
89894: LIST
89895: LIST
89896: LIST
89897: LIST
89898: LIST
89899: LIST
89900: LIST
89901: LIST
89902: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89903: LD_ADDR_VAR 0 55
89907: PUSH
89908: LD_INT 0
89910: PUSH
89911: LD_INT 0
89913: PUSH
89914: EMPTY
89915: LIST
89916: LIST
89917: PUSH
89918: LD_INT 0
89920: PUSH
89921: LD_INT 1
89923: NEG
89924: PUSH
89925: EMPTY
89926: LIST
89927: LIST
89928: PUSH
89929: LD_INT 1
89931: PUSH
89932: LD_INT 0
89934: PUSH
89935: EMPTY
89936: LIST
89937: LIST
89938: PUSH
89939: LD_INT 1
89941: PUSH
89942: LD_INT 1
89944: PUSH
89945: EMPTY
89946: LIST
89947: LIST
89948: PUSH
89949: LD_INT 0
89951: PUSH
89952: LD_INT 1
89954: PUSH
89955: EMPTY
89956: LIST
89957: LIST
89958: PUSH
89959: LD_INT 1
89961: NEG
89962: PUSH
89963: LD_INT 0
89965: PUSH
89966: EMPTY
89967: LIST
89968: LIST
89969: PUSH
89970: LD_INT 1
89972: NEG
89973: PUSH
89974: LD_INT 1
89976: NEG
89977: PUSH
89978: EMPTY
89979: LIST
89980: LIST
89981: PUSH
89982: LD_INT 1
89984: NEG
89985: PUSH
89986: LD_INT 2
89988: NEG
89989: PUSH
89990: EMPTY
89991: LIST
89992: LIST
89993: PUSH
89994: LD_INT 0
89996: PUSH
89997: LD_INT 2
89999: NEG
90000: PUSH
90001: EMPTY
90002: LIST
90003: LIST
90004: PUSH
90005: LD_INT 1
90007: PUSH
90008: LD_INT 1
90010: NEG
90011: PUSH
90012: EMPTY
90013: LIST
90014: LIST
90015: PUSH
90016: LD_INT 2
90018: PUSH
90019: LD_INT 0
90021: PUSH
90022: EMPTY
90023: LIST
90024: LIST
90025: PUSH
90026: LD_INT 2
90028: PUSH
90029: LD_INT 1
90031: PUSH
90032: EMPTY
90033: LIST
90034: LIST
90035: PUSH
90036: LD_INT 2
90038: PUSH
90039: LD_INT 2
90041: PUSH
90042: EMPTY
90043: LIST
90044: LIST
90045: PUSH
90046: LD_INT 1
90048: PUSH
90049: LD_INT 2
90051: PUSH
90052: EMPTY
90053: LIST
90054: LIST
90055: PUSH
90056: LD_INT 0
90058: PUSH
90059: LD_INT 2
90061: PUSH
90062: EMPTY
90063: LIST
90064: LIST
90065: PUSH
90066: LD_INT 1
90068: NEG
90069: PUSH
90070: LD_INT 1
90072: PUSH
90073: EMPTY
90074: LIST
90075: LIST
90076: PUSH
90077: LD_INT 2
90079: NEG
90080: PUSH
90081: LD_INT 0
90083: PUSH
90084: EMPTY
90085: LIST
90086: LIST
90087: PUSH
90088: LD_INT 2
90090: NEG
90091: PUSH
90092: LD_INT 1
90094: NEG
90095: PUSH
90096: EMPTY
90097: LIST
90098: LIST
90099: PUSH
90100: LD_INT 2
90102: NEG
90103: PUSH
90104: LD_INT 2
90106: NEG
90107: PUSH
90108: EMPTY
90109: LIST
90110: LIST
90111: PUSH
90112: EMPTY
90113: LIST
90114: LIST
90115: LIST
90116: LIST
90117: LIST
90118: LIST
90119: LIST
90120: LIST
90121: LIST
90122: LIST
90123: LIST
90124: LIST
90125: LIST
90126: LIST
90127: LIST
90128: LIST
90129: LIST
90130: LIST
90131: LIST
90132: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90133: LD_ADDR_VAR 0 56
90137: PUSH
90138: LD_INT 0
90140: PUSH
90141: LD_INT 0
90143: PUSH
90144: EMPTY
90145: LIST
90146: LIST
90147: PUSH
90148: LD_INT 0
90150: PUSH
90151: LD_INT 1
90153: NEG
90154: PUSH
90155: EMPTY
90156: LIST
90157: LIST
90158: PUSH
90159: LD_INT 1
90161: PUSH
90162: LD_INT 0
90164: PUSH
90165: EMPTY
90166: LIST
90167: LIST
90168: PUSH
90169: LD_INT 1
90171: PUSH
90172: LD_INT 1
90174: PUSH
90175: EMPTY
90176: LIST
90177: LIST
90178: PUSH
90179: LD_INT 0
90181: PUSH
90182: LD_INT 1
90184: PUSH
90185: EMPTY
90186: LIST
90187: LIST
90188: PUSH
90189: LD_INT 1
90191: NEG
90192: PUSH
90193: LD_INT 0
90195: PUSH
90196: EMPTY
90197: LIST
90198: LIST
90199: PUSH
90200: LD_INT 1
90202: NEG
90203: PUSH
90204: LD_INT 1
90206: NEG
90207: PUSH
90208: EMPTY
90209: LIST
90210: LIST
90211: PUSH
90212: LD_INT 1
90214: NEG
90215: PUSH
90216: LD_INT 2
90218: NEG
90219: PUSH
90220: EMPTY
90221: LIST
90222: LIST
90223: PUSH
90224: LD_INT 0
90226: PUSH
90227: LD_INT 2
90229: NEG
90230: PUSH
90231: EMPTY
90232: LIST
90233: LIST
90234: PUSH
90235: LD_INT 1
90237: PUSH
90238: LD_INT 1
90240: NEG
90241: PUSH
90242: EMPTY
90243: LIST
90244: LIST
90245: PUSH
90246: LD_INT 2
90248: PUSH
90249: LD_INT 0
90251: PUSH
90252: EMPTY
90253: LIST
90254: LIST
90255: PUSH
90256: LD_INT 2
90258: PUSH
90259: LD_INT 1
90261: PUSH
90262: EMPTY
90263: LIST
90264: LIST
90265: PUSH
90266: LD_INT 2
90268: PUSH
90269: LD_INT 2
90271: PUSH
90272: EMPTY
90273: LIST
90274: LIST
90275: PUSH
90276: LD_INT 1
90278: PUSH
90279: LD_INT 2
90281: PUSH
90282: EMPTY
90283: LIST
90284: LIST
90285: PUSH
90286: LD_INT 0
90288: PUSH
90289: LD_INT 2
90291: PUSH
90292: EMPTY
90293: LIST
90294: LIST
90295: PUSH
90296: LD_INT 1
90298: NEG
90299: PUSH
90300: LD_INT 1
90302: PUSH
90303: EMPTY
90304: LIST
90305: LIST
90306: PUSH
90307: LD_INT 2
90309: NEG
90310: PUSH
90311: LD_INT 0
90313: PUSH
90314: EMPTY
90315: LIST
90316: LIST
90317: PUSH
90318: LD_INT 2
90320: NEG
90321: PUSH
90322: LD_INT 1
90324: NEG
90325: PUSH
90326: EMPTY
90327: LIST
90328: LIST
90329: PUSH
90330: LD_INT 2
90332: NEG
90333: PUSH
90334: LD_INT 2
90336: NEG
90337: PUSH
90338: EMPTY
90339: LIST
90340: LIST
90341: PUSH
90342: EMPTY
90343: LIST
90344: LIST
90345: LIST
90346: LIST
90347: LIST
90348: LIST
90349: LIST
90350: LIST
90351: LIST
90352: LIST
90353: LIST
90354: LIST
90355: LIST
90356: LIST
90357: LIST
90358: LIST
90359: LIST
90360: LIST
90361: LIST
90362: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90363: LD_ADDR_VAR 0 57
90367: PUSH
90368: LD_INT 0
90370: PUSH
90371: LD_INT 0
90373: PUSH
90374: EMPTY
90375: LIST
90376: LIST
90377: PUSH
90378: LD_INT 0
90380: PUSH
90381: LD_INT 1
90383: NEG
90384: PUSH
90385: EMPTY
90386: LIST
90387: LIST
90388: PUSH
90389: LD_INT 1
90391: PUSH
90392: LD_INT 0
90394: PUSH
90395: EMPTY
90396: LIST
90397: LIST
90398: PUSH
90399: LD_INT 1
90401: PUSH
90402: LD_INT 1
90404: PUSH
90405: EMPTY
90406: LIST
90407: LIST
90408: PUSH
90409: LD_INT 0
90411: PUSH
90412: LD_INT 1
90414: PUSH
90415: EMPTY
90416: LIST
90417: LIST
90418: PUSH
90419: LD_INT 1
90421: NEG
90422: PUSH
90423: LD_INT 0
90425: PUSH
90426: EMPTY
90427: LIST
90428: LIST
90429: PUSH
90430: LD_INT 1
90432: NEG
90433: PUSH
90434: LD_INT 1
90436: NEG
90437: PUSH
90438: EMPTY
90439: LIST
90440: LIST
90441: PUSH
90442: LD_INT 1
90444: NEG
90445: PUSH
90446: LD_INT 2
90448: NEG
90449: PUSH
90450: EMPTY
90451: LIST
90452: LIST
90453: PUSH
90454: LD_INT 0
90456: PUSH
90457: LD_INT 2
90459: NEG
90460: PUSH
90461: EMPTY
90462: LIST
90463: LIST
90464: PUSH
90465: LD_INT 1
90467: PUSH
90468: LD_INT 1
90470: NEG
90471: PUSH
90472: EMPTY
90473: LIST
90474: LIST
90475: PUSH
90476: LD_INT 2
90478: PUSH
90479: LD_INT 0
90481: PUSH
90482: EMPTY
90483: LIST
90484: LIST
90485: PUSH
90486: LD_INT 2
90488: PUSH
90489: LD_INT 1
90491: PUSH
90492: EMPTY
90493: LIST
90494: LIST
90495: PUSH
90496: LD_INT 2
90498: PUSH
90499: LD_INT 2
90501: PUSH
90502: EMPTY
90503: LIST
90504: LIST
90505: PUSH
90506: LD_INT 1
90508: PUSH
90509: LD_INT 2
90511: PUSH
90512: EMPTY
90513: LIST
90514: LIST
90515: PUSH
90516: LD_INT 0
90518: PUSH
90519: LD_INT 2
90521: PUSH
90522: EMPTY
90523: LIST
90524: LIST
90525: PUSH
90526: LD_INT 1
90528: NEG
90529: PUSH
90530: LD_INT 1
90532: PUSH
90533: EMPTY
90534: LIST
90535: LIST
90536: PUSH
90537: LD_INT 2
90539: NEG
90540: PUSH
90541: LD_INT 0
90543: PUSH
90544: EMPTY
90545: LIST
90546: LIST
90547: PUSH
90548: LD_INT 2
90550: NEG
90551: PUSH
90552: LD_INT 1
90554: NEG
90555: PUSH
90556: EMPTY
90557: LIST
90558: LIST
90559: PUSH
90560: LD_INT 2
90562: NEG
90563: PUSH
90564: LD_INT 2
90566: NEG
90567: PUSH
90568: EMPTY
90569: LIST
90570: LIST
90571: PUSH
90572: EMPTY
90573: LIST
90574: LIST
90575: LIST
90576: LIST
90577: LIST
90578: LIST
90579: LIST
90580: LIST
90581: LIST
90582: LIST
90583: LIST
90584: LIST
90585: LIST
90586: LIST
90587: LIST
90588: LIST
90589: LIST
90590: LIST
90591: LIST
90592: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90593: LD_ADDR_VAR 0 58
90597: PUSH
90598: LD_INT 0
90600: PUSH
90601: LD_INT 0
90603: PUSH
90604: EMPTY
90605: LIST
90606: LIST
90607: PUSH
90608: LD_INT 0
90610: PUSH
90611: LD_INT 1
90613: NEG
90614: PUSH
90615: EMPTY
90616: LIST
90617: LIST
90618: PUSH
90619: LD_INT 1
90621: PUSH
90622: LD_INT 0
90624: PUSH
90625: EMPTY
90626: LIST
90627: LIST
90628: PUSH
90629: LD_INT 1
90631: PUSH
90632: LD_INT 1
90634: PUSH
90635: EMPTY
90636: LIST
90637: LIST
90638: PUSH
90639: LD_INT 0
90641: PUSH
90642: LD_INT 1
90644: PUSH
90645: EMPTY
90646: LIST
90647: LIST
90648: PUSH
90649: LD_INT 1
90651: NEG
90652: PUSH
90653: LD_INT 0
90655: PUSH
90656: EMPTY
90657: LIST
90658: LIST
90659: PUSH
90660: LD_INT 1
90662: NEG
90663: PUSH
90664: LD_INT 1
90666: NEG
90667: PUSH
90668: EMPTY
90669: LIST
90670: LIST
90671: PUSH
90672: LD_INT 1
90674: NEG
90675: PUSH
90676: LD_INT 2
90678: NEG
90679: PUSH
90680: EMPTY
90681: LIST
90682: LIST
90683: PUSH
90684: LD_INT 0
90686: PUSH
90687: LD_INT 2
90689: NEG
90690: PUSH
90691: EMPTY
90692: LIST
90693: LIST
90694: PUSH
90695: LD_INT 1
90697: PUSH
90698: LD_INT 1
90700: NEG
90701: PUSH
90702: EMPTY
90703: LIST
90704: LIST
90705: PUSH
90706: LD_INT 2
90708: PUSH
90709: LD_INT 0
90711: PUSH
90712: EMPTY
90713: LIST
90714: LIST
90715: PUSH
90716: LD_INT 2
90718: PUSH
90719: LD_INT 1
90721: PUSH
90722: EMPTY
90723: LIST
90724: LIST
90725: PUSH
90726: LD_INT 2
90728: PUSH
90729: LD_INT 2
90731: PUSH
90732: EMPTY
90733: LIST
90734: LIST
90735: PUSH
90736: LD_INT 1
90738: PUSH
90739: LD_INT 2
90741: PUSH
90742: EMPTY
90743: LIST
90744: LIST
90745: PUSH
90746: LD_INT 0
90748: PUSH
90749: LD_INT 2
90751: PUSH
90752: EMPTY
90753: LIST
90754: LIST
90755: PUSH
90756: LD_INT 1
90758: NEG
90759: PUSH
90760: LD_INT 1
90762: PUSH
90763: EMPTY
90764: LIST
90765: LIST
90766: PUSH
90767: LD_INT 2
90769: NEG
90770: PUSH
90771: LD_INT 0
90773: PUSH
90774: EMPTY
90775: LIST
90776: LIST
90777: PUSH
90778: LD_INT 2
90780: NEG
90781: PUSH
90782: LD_INT 1
90784: NEG
90785: PUSH
90786: EMPTY
90787: LIST
90788: LIST
90789: PUSH
90790: LD_INT 2
90792: NEG
90793: PUSH
90794: LD_INT 2
90796: NEG
90797: PUSH
90798: EMPTY
90799: LIST
90800: LIST
90801: PUSH
90802: EMPTY
90803: LIST
90804: LIST
90805: LIST
90806: LIST
90807: LIST
90808: LIST
90809: LIST
90810: LIST
90811: LIST
90812: LIST
90813: LIST
90814: LIST
90815: LIST
90816: LIST
90817: LIST
90818: LIST
90819: LIST
90820: LIST
90821: LIST
90822: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90823: LD_ADDR_VAR 0 59
90827: PUSH
90828: LD_INT 0
90830: PUSH
90831: LD_INT 0
90833: PUSH
90834: EMPTY
90835: LIST
90836: LIST
90837: PUSH
90838: LD_INT 0
90840: PUSH
90841: LD_INT 1
90843: NEG
90844: PUSH
90845: EMPTY
90846: LIST
90847: LIST
90848: PUSH
90849: LD_INT 1
90851: PUSH
90852: LD_INT 0
90854: PUSH
90855: EMPTY
90856: LIST
90857: LIST
90858: PUSH
90859: LD_INT 1
90861: PUSH
90862: LD_INT 1
90864: PUSH
90865: EMPTY
90866: LIST
90867: LIST
90868: PUSH
90869: LD_INT 0
90871: PUSH
90872: LD_INT 1
90874: PUSH
90875: EMPTY
90876: LIST
90877: LIST
90878: PUSH
90879: LD_INT 1
90881: NEG
90882: PUSH
90883: LD_INT 0
90885: PUSH
90886: EMPTY
90887: LIST
90888: LIST
90889: PUSH
90890: LD_INT 1
90892: NEG
90893: PUSH
90894: LD_INT 1
90896: NEG
90897: PUSH
90898: EMPTY
90899: LIST
90900: LIST
90901: PUSH
90902: EMPTY
90903: LIST
90904: LIST
90905: LIST
90906: LIST
90907: LIST
90908: LIST
90909: LIST
90910: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90911: LD_ADDR_VAR 0 60
90915: PUSH
90916: LD_INT 0
90918: PUSH
90919: LD_INT 0
90921: PUSH
90922: EMPTY
90923: LIST
90924: LIST
90925: PUSH
90926: LD_INT 0
90928: PUSH
90929: LD_INT 1
90931: NEG
90932: PUSH
90933: EMPTY
90934: LIST
90935: LIST
90936: PUSH
90937: LD_INT 1
90939: PUSH
90940: LD_INT 0
90942: PUSH
90943: EMPTY
90944: LIST
90945: LIST
90946: PUSH
90947: LD_INT 1
90949: PUSH
90950: LD_INT 1
90952: PUSH
90953: EMPTY
90954: LIST
90955: LIST
90956: PUSH
90957: LD_INT 0
90959: PUSH
90960: LD_INT 1
90962: PUSH
90963: EMPTY
90964: LIST
90965: LIST
90966: PUSH
90967: LD_INT 1
90969: NEG
90970: PUSH
90971: LD_INT 0
90973: PUSH
90974: EMPTY
90975: LIST
90976: LIST
90977: PUSH
90978: LD_INT 1
90980: NEG
90981: PUSH
90982: LD_INT 1
90984: NEG
90985: PUSH
90986: EMPTY
90987: LIST
90988: LIST
90989: PUSH
90990: EMPTY
90991: LIST
90992: LIST
90993: LIST
90994: LIST
90995: LIST
90996: LIST
90997: LIST
90998: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90999: LD_ADDR_VAR 0 61
91003: PUSH
91004: LD_INT 0
91006: PUSH
91007: LD_INT 0
91009: PUSH
91010: EMPTY
91011: LIST
91012: LIST
91013: PUSH
91014: LD_INT 0
91016: PUSH
91017: LD_INT 1
91019: NEG
91020: PUSH
91021: EMPTY
91022: LIST
91023: LIST
91024: PUSH
91025: LD_INT 1
91027: PUSH
91028: LD_INT 0
91030: PUSH
91031: EMPTY
91032: LIST
91033: LIST
91034: PUSH
91035: LD_INT 1
91037: PUSH
91038: LD_INT 1
91040: PUSH
91041: EMPTY
91042: LIST
91043: LIST
91044: PUSH
91045: LD_INT 0
91047: PUSH
91048: LD_INT 1
91050: PUSH
91051: EMPTY
91052: LIST
91053: LIST
91054: PUSH
91055: LD_INT 1
91057: NEG
91058: PUSH
91059: LD_INT 0
91061: PUSH
91062: EMPTY
91063: LIST
91064: LIST
91065: PUSH
91066: LD_INT 1
91068: NEG
91069: PUSH
91070: LD_INT 1
91072: NEG
91073: PUSH
91074: EMPTY
91075: LIST
91076: LIST
91077: PUSH
91078: EMPTY
91079: LIST
91080: LIST
91081: LIST
91082: LIST
91083: LIST
91084: LIST
91085: LIST
91086: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91087: LD_ADDR_VAR 0 62
91091: PUSH
91092: LD_INT 0
91094: PUSH
91095: LD_INT 0
91097: PUSH
91098: EMPTY
91099: LIST
91100: LIST
91101: PUSH
91102: LD_INT 0
91104: PUSH
91105: LD_INT 1
91107: NEG
91108: PUSH
91109: EMPTY
91110: LIST
91111: LIST
91112: PUSH
91113: LD_INT 1
91115: PUSH
91116: LD_INT 0
91118: PUSH
91119: EMPTY
91120: LIST
91121: LIST
91122: PUSH
91123: LD_INT 1
91125: PUSH
91126: LD_INT 1
91128: PUSH
91129: EMPTY
91130: LIST
91131: LIST
91132: PUSH
91133: LD_INT 0
91135: PUSH
91136: LD_INT 1
91138: PUSH
91139: EMPTY
91140: LIST
91141: LIST
91142: PUSH
91143: LD_INT 1
91145: NEG
91146: PUSH
91147: LD_INT 0
91149: PUSH
91150: EMPTY
91151: LIST
91152: LIST
91153: PUSH
91154: LD_INT 1
91156: NEG
91157: PUSH
91158: LD_INT 1
91160: NEG
91161: PUSH
91162: EMPTY
91163: LIST
91164: LIST
91165: PUSH
91166: EMPTY
91167: LIST
91168: LIST
91169: LIST
91170: LIST
91171: LIST
91172: LIST
91173: LIST
91174: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91175: LD_ADDR_VAR 0 63
91179: PUSH
91180: LD_INT 0
91182: PUSH
91183: LD_INT 0
91185: PUSH
91186: EMPTY
91187: LIST
91188: LIST
91189: PUSH
91190: LD_INT 0
91192: PUSH
91193: LD_INT 1
91195: NEG
91196: PUSH
91197: EMPTY
91198: LIST
91199: LIST
91200: PUSH
91201: LD_INT 1
91203: PUSH
91204: LD_INT 0
91206: PUSH
91207: EMPTY
91208: LIST
91209: LIST
91210: PUSH
91211: LD_INT 1
91213: PUSH
91214: LD_INT 1
91216: PUSH
91217: EMPTY
91218: LIST
91219: LIST
91220: PUSH
91221: LD_INT 0
91223: PUSH
91224: LD_INT 1
91226: PUSH
91227: EMPTY
91228: LIST
91229: LIST
91230: PUSH
91231: LD_INT 1
91233: NEG
91234: PUSH
91235: LD_INT 0
91237: PUSH
91238: EMPTY
91239: LIST
91240: LIST
91241: PUSH
91242: LD_INT 1
91244: NEG
91245: PUSH
91246: LD_INT 1
91248: NEG
91249: PUSH
91250: EMPTY
91251: LIST
91252: LIST
91253: PUSH
91254: EMPTY
91255: LIST
91256: LIST
91257: LIST
91258: LIST
91259: LIST
91260: LIST
91261: LIST
91262: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91263: LD_ADDR_VAR 0 64
91267: PUSH
91268: LD_INT 0
91270: PUSH
91271: LD_INT 0
91273: PUSH
91274: EMPTY
91275: LIST
91276: LIST
91277: PUSH
91278: LD_INT 0
91280: PUSH
91281: LD_INT 1
91283: NEG
91284: PUSH
91285: EMPTY
91286: LIST
91287: LIST
91288: PUSH
91289: LD_INT 1
91291: PUSH
91292: LD_INT 0
91294: PUSH
91295: EMPTY
91296: LIST
91297: LIST
91298: PUSH
91299: LD_INT 1
91301: PUSH
91302: LD_INT 1
91304: PUSH
91305: EMPTY
91306: LIST
91307: LIST
91308: PUSH
91309: LD_INT 0
91311: PUSH
91312: LD_INT 1
91314: PUSH
91315: EMPTY
91316: LIST
91317: LIST
91318: PUSH
91319: LD_INT 1
91321: NEG
91322: PUSH
91323: LD_INT 0
91325: PUSH
91326: EMPTY
91327: LIST
91328: LIST
91329: PUSH
91330: LD_INT 1
91332: NEG
91333: PUSH
91334: LD_INT 1
91336: NEG
91337: PUSH
91338: EMPTY
91339: LIST
91340: LIST
91341: PUSH
91342: EMPTY
91343: LIST
91344: LIST
91345: LIST
91346: LIST
91347: LIST
91348: LIST
91349: LIST
91350: ST_TO_ADDR
// end ; 1 :
91351: GO 97248
91353: LD_INT 1
91355: DOUBLE
91356: EQUAL
91357: IFTRUE 91361
91359: GO 93984
91361: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91362: LD_ADDR_VAR 0 11
91366: PUSH
91367: LD_INT 1
91369: NEG
91370: PUSH
91371: LD_INT 3
91373: NEG
91374: PUSH
91375: EMPTY
91376: LIST
91377: LIST
91378: PUSH
91379: LD_INT 0
91381: PUSH
91382: LD_INT 3
91384: NEG
91385: PUSH
91386: EMPTY
91387: LIST
91388: LIST
91389: PUSH
91390: LD_INT 1
91392: PUSH
91393: LD_INT 2
91395: NEG
91396: PUSH
91397: EMPTY
91398: LIST
91399: LIST
91400: PUSH
91401: EMPTY
91402: LIST
91403: LIST
91404: LIST
91405: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91406: LD_ADDR_VAR 0 12
91410: PUSH
91411: LD_INT 2
91413: PUSH
91414: LD_INT 1
91416: NEG
91417: PUSH
91418: EMPTY
91419: LIST
91420: LIST
91421: PUSH
91422: LD_INT 3
91424: PUSH
91425: LD_INT 0
91427: PUSH
91428: EMPTY
91429: LIST
91430: LIST
91431: PUSH
91432: LD_INT 3
91434: PUSH
91435: LD_INT 1
91437: PUSH
91438: EMPTY
91439: LIST
91440: LIST
91441: PUSH
91442: EMPTY
91443: LIST
91444: LIST
91445: LIST
91446: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91447: LD_ADDR_VAR 0 13
91451: PUSH
91452: LD_INT 3
91454: PUSH
91455: LD_INT 2
91457: PUSH
91458: EMPTY
91459: LIST
91460: LIST
91461: PUSH
91462: LD_INT 3
91464: PUSH
91465: LD_INT 3
91467: PUSH
91468: EMPTY
91469: LIST
91470: LIST
91471: PUSH
91472: LD_INT 2
91474: PUSH
91475: LD_INT 3
91477: PUSH
91478: EMPTY
91479: LIST
91480: LIST
91481: PUSH
91482: EMPTY
91483: LIST
91484: LIST
91485: LIST
91486: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91487: LD_ADDR_VAR 0 14
91491: PUSH
91492: LD_INT 1
91494: PUSH
91495: LD_INT 3
91497: PUSH
91498: EMPTY
91499: LIST
91500: LIST
91501: PUSH
91502: LD_INT 0
91504: PUSH
91505: LD_INT 3
91507: PUSH
91508: EMPTY
91509: LIST
91510: LIST
91511: PUSH
91512: LD_INT 1
91514: NEG
91515: PUSH
91516: LD_INT 2
91518: PUSH
91519: EMPTY
91520: LIST
91521: LIST
91522: PUSH
91523: EMPTY
91524: LIST
91525: LIST
91526: LIST
91527: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91528: LD_ADDR_VAR 0 15
91532: PUSH
91533: LD_INT 2
91535: NEG
91536: PUSH
91537: LD_INT 1
91539: PUSH
91540: EMPTY
91541: LIST
91542: LIST
91543: PUSH
91544: LD_INT 3
91546: NEG
91547: PUSH
91548: LD_INT 0
91550: PUSH
91551: EMPTY
91552: LIST
91553: LIST
91554: PUSH
91555: LD_INT 3
91557: NEG
91558: PUSH
91559: LD_INT 1
91561: NEG
91562: PUSH
91563: EMPTY
91564: LIST
91565: LIST
91566: PUSH
91567: EMPTY
91568: LIST
91569: LIST
91570: LIST
91571: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91572: LD_ADDR_VAR 0 16
91576: PUSH
91577: LD_INT 2
91579: NEG
91580: PUSH
91581: LD_INT 3
91583: NEG
91584: PUSH
91585: EMPTY
91586: LIST
91587: LIST
91588: PUSH
91589: LD_INT 3
91591: NEG
91592: PUSH
91593: LD_INT 2
91595: NEG
91596: PUSH
91597: EMPTY
91598: LIST
91599: LIST
91600: PUSH
91601: LD_INT 3
91603: NEG
91604: PUSH
91605: LD_INT 3
91607: NEG
91608: PUSH
91609: EMPTY
91610: LIST
91611: LIST
91612: PUSH
91613: EMPTY
91614: LIST
91615: LIST
91616: LIST
91617: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91618: LD_ADDR_VAR 0 17
91622: PUSH
91623: LD_INT 1
91625: NEG
91626: PUSH
91627: LD_INT 3
91629: NEG
91630: PUSH
91631: EMPTY
91632: LIST
91633: LIST
91634: PUSH
91635: LD_INT 0
91637: PUSH
91638: LD_INT 3
91640: NEG
91641: PUSH
91642: EMPTY
91643: LIST
91644: LIST
91645: PUSH
91646: LD_INT 1
91648: PUSH
91649: LD_INT 2
91651: NEG
91652: PUSH
91653: EMPTY
91654: LIST
91655: LIST
91656: PUSH
91657: EMPTY
91658: LIST
91659: LIST
91660: LIST
91661: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91662: LD_ADDR_VAR 0 18
91666: PUSH
91667: LD_INT 2
91669: PUSH
91670: LD_INT 1
91672: NEG
91673: PUSH
91674: EMPTY
91675: LIST
91676: LIST
91677: PUSH
91678: LD_INT 3
91680: PUSH
91681: LD_INT 0
91683: PUSH
91684: EMPTY
91685: LIST
91686: LIST
91687: PUSH
91688: LD_INT 3
91690: PUSH
91691: LD_INT 1
91693: PUSH
91694: EMPTY
91695: LIST
91696: LIST
91697: PUSH
91698: EMPTY
91699: LIST
91700: LIST
91701: LIST
91702: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91703: LD_ADDR_VAR 0 19
91707: PUSH
91708: LD_INT 3
91710: PUSH
91711: LD_INT 2
91713: PUSH
91714: EMPTY
91715: LIST
91716: LIST
91717: PUSH
91718: LD_INT 3
91720: PUSH
91721: LD_INT 3
91723: PUSH
91724: EMPTY
91725: LIST
91726: LIST
91727: PUSH
91728: LD_INT 2
91730: PUSH
91731: LD_INT 3
91733: PUSH
91734: EMPTY
91735: LIST
91736: LIST
91737: PUSH
91738: EMPTY
91739: LIST
91740: LIST
91741: LIST
91742: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91743: LD_ADDR_VAR 0 20
91747: PUSH
91748: LD_INT 1
91750: PUSH
91751: LD_INT 3
91753: PUSH
91754: EMPTY
91755: LIST
91756: LIST
91757: PUSH
91758: LD_INT 0
91760: PUSH
91761: LD_INT 3
91763: PUSH
91764: EMPTY
91765: LIST
91766: LIST
91767: PUSH
91768: LD_INT 1
91770: NEG
91771: PUSH
91772: LD_INT 2
91774: PUSH
91775: EMPTY
91776: LIST
91777: LIST
91778: PUSH
91779: EMPTY
91780: LIST
91781: LIST
91782: LIST
91783: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91784: LD_ADDR_VAR 0 21
91788: PUSH
91789: LD_INT 2
91791: NEG
91792: PUSH
91793: LD_INT 1
91795: PUSH
91796: EMPTY
91797: LIST
91798: LIST
91799: PUSH
91800: LD_INT 3
91802: NEG
91803: PUSH
91804: LD_INT 0
91806: PUSH
91807: EMPTY
91808: LIST
91809: LIST
91810: PUSH
91811: LD_INT 3
91813: NEG
91814: PUSH
91815: LD_INT 1
91817: NEG
91818: PUSH
91819: EMPTY
91820: LIST
91821: LIST
91822: PUSH
91823: EMPTY
91824: LIST
91825: LIST
91826: LIST
91827: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91828: LD_ADDR_VAR 0 22
91832: PUSH
91833: LD_INT 2
91835: NEG
91836: PUSH
91837: LD_INT 3
91839: NEG
91840: PUSH
91841: EMPTY
91842: LIST
91843: LIST
91844: PUSH
91845: LD_INT 3
91847: NEG
91848: PUSH
91849: LD_INT 2
91851: NEG
91852: PUSH
91853: EMPTY
91854: LIST
91855: LIST
91856: PUSH
91857: LD_INT 3
91859: NEG
91860: PUSH
91861: LD_INT 3
91863: NEG
91864: PUSH
91865: EMPTY
91866: LIST
91867: LIST
91868: PUSH
91869: EMPTY
91870: LIST
91871: LIST
91872: LIST
91873: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
91874: LD_ADDR_VAR 0 23
91878: PUSH
91879: LD_INT 0
91881: PUSH
91882: LD_INT 3
91884: NEG
91885: PUSH
91886: EMPTY
91887: LIST
91888: LIST
91889: PUSH
91890: LD_INT 1
91892: NEG
91893: PUSH
91894: LD_INT 4
91896: NEG
91897: PUSH
91898: EMPTY
91899: LIST
91900: LIST
91901: PUSH
91902: LD_INT 1
91904: PUSH
91905: LD_INT 3
91907: NEG
91908: PUSH
91909: EMPTY
91910: LIST
91911: LIST
91912: PUSH
91913: EMPTY
91914: LIST
91915: LIST
91916: LIST
91917: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
91918: LD_ADDR_VAR 0 24
91922: PUSH
91923: LD_INT 3
91925: PUSH
91926: LD_INT 0
91928: PUSH
91929: EMPTY
91930: LIST
91931: LIST
91932: PUSH
91933: LD_INT 3
91935: PUSH
91936: LD_INT 1
91938: NEG
91939: PUSH
91940: EMPTY
91941: LIST
91942: LIST
91943: PUSH
91944: LD_INT 4
91946: PUSH
91947: LD_INT 1
91949: PUSH
91950: EMPTY
91951: LIST
91952: LIST
91953: PUSH
91954: EMPTY
91955: LIST
91956: LIST
91957: LIST
91958: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
91959: LD_ADDR_VAR 0 25
91963: PUSH
91964: LD_INT 3
91966: PUSH
91967: LD_INT 3
91969: PUSH
91970: EMPTY
91971: LIST
91972: LIST
91973: PUSH
91974: LD_INT 4
91976: PUSH
91977: LD_INT 3
91979: PUSH
91980: EMPTY
91981: LIST
91982: LIST
91983: PUSH
91984: LD_INT 3
91986: PUSH
91987: LD_INT 4
91989: PUSH
91990: EMPTY
91991: LIST
91992: LIST
91993: PUSH
91994: EMPTY
91995: LIST
91996: LIST
91997: LIST
91998: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
91999: LD_ADDR_VAR 0 26
92003: PUSH
92004: LD_INT 0
92006: PUSH
92007: LD_INT 3
92009: PUSH
92010: EMPTY
92011: LIST
92012: LIST
92013: PUSH
92014: LD_INT 1
92016: PUSH
92017: LD_INT 4
92019: PUSH
92020: EMPTY
92021: LIST
92022: LIST
92023: PUSH
92024: LD_INT 1
92026: NEG
92027: PUSH
92028: LD_INT 3
92030: PUSH
92031: EMPTY
92032: LIST
92033: LIST
92034: PUSH
92035: EMPTY
92036: LIST
92037: LIST
92038: LIST
92039: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
92040: LD_ADDR_VAR 0 27
92044: PUSH
92045: LD_INT 3
92047: NEG
92048: PUSH
92049: LD_INT 0
92051: PUSH
92052: EMPTY
92053: LIST
92054: LIST
92055: PUSH
92056: LD_INT 3
92058: NEG
92059: PUSH
92060: LD_INT 1
92062: PUSH
92063: EMPTY
92064: LIST
92065: LIST
92066: PUSH
92067: LD_INT 4
92069: NEG
92070: PUSH
92071: LD_INT 1
92073: NEG
92074: PUSH
92075: EMPTY
92076: LIST
92077: LIST
92078: PUSH
92079: EMPTY
92080: LIST
92081: LIST
92082: LIST
92083: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
92084: LD_ADDR_VAR 0 28
92088: PUSH
92089: LD_INT 3
92091: NEG
92092: PUSH
92093: LD_INT 3
92095: NEG
92096: PUSH
92097: EMPTY
92098: LIST
92099: LIST
92100: PUSH
92101: LD_INT 3
92103: NEG
92104: PUSH
92105: LD_INT 4
92107: NEG
92108: PUSH
92109: EMPTY
92110: LIST
92111: LIST
92112: PUSH
92113: LD_INT 4
92115: NEG
92116: PUSH
92117: LD_INT 3
92119: NEG
92120: PUSH
92121: EMPTY
92122: LIST
92123: LIST
92124: PUSH
92125: EMPTY
92126: LIST
92127: LIST
92128: LIST
92129: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92130: LD_ADDR_VAR 0 29
92134: PUSH
92135: LD_INT 1
92137: NEG
92138: PUSH
92139: LD_INT 3
92141: NEG
92142: PUSH
92143: EMPTY
92144: LIST
92145: LIST
92146: PUSH
92147: LD_INT 0
92149: PUSH
92150: LD_INT 3
92152: NEG
92153: PUSH
92154: EMPTY
92155: LIST
92156: LIST
92157: PUSH
92158: LD_INT 1
92160: PUSH
92161: LD_INT 2
92163: NEG
92164: PUSH
92165: EMPTY
92166: LIST
92167: LIST
92168: PUSH
92169: LD_INT 1
92171: NEG
92172: PUSH
92173: LD_INT 4
92175: NEG
92176: PUSH
92177: EMPTY
92178: LIST
92179: LIST
92180: PUSH
92181: LD_INT 0
92183: PUSH
92184: LD_INT 4
92186: NEG
92187: PUSH
92188: EMPTY
92189: LIST
92190: LIST
92191: PUSH
92192: LD_INT 1
92194: PUSH
92195: LD_INT 3
92197: NEG
92198: PUSH
92199: EMPTY
92200: LIST
92201: LIST
92202: PUSH
92203: LD_INT 1
92205: NEG
92206: PUSH
92207: LD_INT 5
92209: NEG
92210: PUSH
92211: EMPTY
92212: LIST
92213: LIST
92214: PUSH
92215: LD_INT 0
92217: PUSH
92218: LD_INT 5
92220: NEG
92221: PUSH
92222: EMPTY
92223: LIST
92224: LIST
92225: PUSH
92226: LD_INT 1
92228: PUSH
92229: LD_INT 4
92231: NEG
92232: PUSH
92233: EMPTY
92234: LIST
92235: LIST
92236: PUSH
92237: LD_INT 1
92239: NEG
92240: PUSH
92241: LD_INT 6
92243: NEG
92244: PUSH
92245: EMPTY
92246: LIST
92247: LIST
92248: PUSH
92249: LD_INT 0
92251: PUSH
92252: LD_INT 6
92254: NEG
92255: PUSH
92256: EMPTY
92257: LIST
92258: LIST
92259: PUSH
92260: LD_INT 1
92262: PUSH
92263: LD_INT 5
92265: NEG
92266: PUSH
92267: EMPTY
92268: LIST
92269: LIST
92270: PUSH
92271: EMPTY
92272: LIST
92273: LIST
92274: LIST
92275: LIST
92276: LIST
92277: LIST
92278: LIST
92279: LIST
92280: LIST
92281: LIST
92282: LIST
92283: LIST
92284: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92285: LD_ADDR_VAR 0 30
92289: PUSH
92290: LD_INT 2
92292: PUSH
92293: LD_INT 1
92295: NEG
92296: PUSH
92297: EMPTY
92298: LIST
92299: LIST
92300: PUSH
92301: LD_INT 3
92303: PUSH
92304: LD_INT 0
92306: PUSH
92307: EMPTY
92308: LIST
92309: LIST
92310: PUSH
92311: LD_INT 3
92313: PUSH
92314: LD_INT 1
92316: PUSH
92317: EMPTY
92318: LIST
92319: LIST
92320: PUSH
92321: LD_INT 3
92323: PUSH
92324: LD_INT 1
92326: NEG
92327: PUSH
92328: EMPTY
92329: LIST
92330: LIST
92331: PUSH
92332: LD_INT 4
92334: PUSH
92335: LD_INT 0
92337: PUSH
92338: EMPTY
92339: LIST
92340: LIST
92341: PUSH
92342: LD_INT 4
92344: PUSH
92345: LD_INT 1
92347: PUSH
92348: EMPTY
92349: LIST
92350: LIST
92351: PUSH
92352: LD_INT 4
92354: PUSH
92355: LD_INT 1
92357: NEG
92358: PUSH
92359: EMPTY
92360: LIST
92361: LIST
92362: PUSH
92363: LD_INT 5
92365: PUSH
92366: LD_INT 0
92368: PUSH
92369: EMPTY
92370: LIST
92371: LIST
92372: PUSH
92373: LD_INT 5
92375: PUSH
92376: LD_INT 1
92378: PUSH
92379: EMPTY
92380: LIST
92381: LIST
92382: PUSH
92383: LD_INT 5
92385: PUSH
92386: LD_INT 1
92388: NEG
92389: PUSH
92390: EMPTY
92391: LIST
92392: LIST
92393: PUSH
92394: LD_INT 6
92396: PUSH
92397: LD_INT 0
92399: PUSH
92400: EMPTY
92401: LIST
92402: LIST
92403: PUSH
92404: LD_INT 6
92406: PUSH
92407: LD_INT 1
92409: PUSH
92410: EMPTY
92411: LIST
92412: LIST
92413: PUSH
92414: EMPTY
92415: LIST
92416: LIST
92417: LIST
92418: LIST
92419: LIST
92420: LIST
92421: LIST
92422: LIST
92423: LIST
92424: LIST
92425: LIST
92426: LIST
92427: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
92428: LD_ADDR_VAR 0 31
92432: PUSH
92433: LD_INT 3
92435: PUSH
92436: LD_INT 2
92438: PUSH
92439: EMPTY
92440: LIST
92441: LIST
92442: PUSH
92443: LD_INT 3
92445: PUSH
92446: LD_INT 3
92448: PUSH
92449: EMPTY
92450: LIST
92451: LIST
92452: PUSH
92453: LD_INT 2
92455: PUSH
92456: LD_INT 3
92458: PUSH
92459: EMPTY
92460: LIST
92461: LIST
92462: PUSH
92463: LD_INT 4
92465: PUSH
92466: LD_INT 3
92468: PUSH
92469: EMPTY
92470: LIST
92471: LIST
92472: PUSH
92473: LD_INT 4
92475: PUSH
92476: LD_INT 4
92478: PUSH
92479: EMPTY
92480: LIST
92481: LIST
92482: PUSH
92483: LD_INT 3
92485: PUSH
92486: LD_INT 4
92488: PUSH
92489: EMPTY
92490: LIST
92491: LIST
92492: PUSH
92493: LD_INT 5
92495: PUSH
92496: LD_INT 4
92498: PUSH
92499: EMPTY
92500: LIST
92501: LIST
92502: PUSH
92503: LD_INT 5
92505: PUSH
92506: LD_INT 5
92508: PUSH
92509: EMPTY
92510: LIST
92511: LIST
92512: PUSH
92513: LD_INT 4
92515: PUSH
92516: LD_INT 5
92518: PUSH
92519: EMPTY
92520: LIST
92521: LIST
92522: PUSH
92523: LD_INT 6
92525: PUSH
92526: LD_INT 5
92528: PUSH
92529: EMPTY
92530: LIST
92531: LIST
92532: PUSH
92533: LD_INT 6
92535: PUSH
92536: LD_INT 6
92538: PUSH
92539: EMPTY
92540: LIST
92541: LIST
92542: PUSH
92543: LD_INT 5
92545: PUSH
92546: LD_INT 6
92548: PUSH
92549: EMPTY
92550: LIST
92551: LIST
92552: PUSH
92553: EMPTY
92554: LIST
92555: LIST
92556: LIST
92557: LIST
92558: LIST
92559: LIST
92560: LIST
92561: LIST
92562: LIST
92563: LIST
92564: LIST
92565: LIST
92566: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
92567: LD_ADDR_VAR 0 32
92571: PUSH
92572: LD_INT 1
92574: PUSH
92575: LD_INT 3
92577: PUSH
92578: EMPTY
92579: LIST
92580: LIST
92581: PUSH
92582: LD_INT 0
92584: PUSH
92585: LD_INT 3
92587: PUSH
92588: EMPTY
92589: LIST
92590: LIST
92591: PUSH
92592: LD_INT 1
92594: NEG
92595: PUSH
92596: LD_INT 2
92598: PUSH
92599: EMPTY
92600: LIST
92601: LIST
92602: PUSH
92603: LD_INT 1
92605: PUSH
92606: LD_INT 4
92608: PUSH
92609: EMPTY
92610: LIST
92611: LIST
92612: PUSH
92613: LD_INT 0
92615: PUSH
92616: LD_INT 4
92618: PUSH
92619: EMPTY
92620: LIST
92621: LIST
92622: PUSH
92623: LD_INT 1
92625: NEG
92626: PUSH
92627: LD_INT 3
92629: PUSH
92630: EMPTY
92631: LIST
92632: LIST
92633: PUSH
92634: LD_INT 1
92636: PUSH
92637: LD_INT 5
92639: PUSH
92640: EMPTY
92641: LIST
92642: LIST
92643: PUSH
92644: LD_INT 0
92646: PUSH
92647: LD_INT 5
92649: PUSH
92650: EMPTY
92651: LIST
92652: LIST
92653: PUSH
92654: LD_INT 1
92656: NEG
92657: PUSH
92658: LD_INT 4
92660: PUSH
92661: EMPTY
92662: LIST
92663: LIST
92664: PUSH
92665: LD_INT 1
92667: PUSH
92668: LD_INT 6
92670: PUSH
92671: EMPTY
92672: LIST
92673: LIST
92674: PUSH
92675: LD_INT 0
92677: PUSH
92678: LD_INT 6
92680: PUSH
92681: EMPTY
92682: LIST
92683: LIST
92684: PUSH
92685: LD_INT 1
92687: NEG
92688: PUSH
92689: LD_INT 5
92691: PUSH
92692: EMPTY
92693: LIST
92694: LIST
92695: PUSH
92696: EMPTY
92697: LIST
92698: LIST
92699: LIST
92700: LIST
92701: LIST
92702: LIST
92703: LIST
92704: LIST
92705: LIST
92706: LIST
92707: LIST
92708: LIST
92709: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
92710: LD_ADDR_VAR 0 33
92714: PUSH
92715: LD_INT 2
92717: NEG
92718: PUSH
92719: LD_INT 1
92721: PUSH
92722: EMPTY
92723: LIST
92724: LIST
92725: PUSH
92726: LD_INT 3
92728: NEG
92729: PUSH
92730: LD_INT 0
92732: PUSH
92733: EMPTY
92734: LIST
92735: LIST
92736: PUSH
92737: LD_INT 3
92739: NEG
92740: PUSH
92741: LD_INT 1
92743: NEG
92744: PUSH
92745: EMPTY
92746: LIST
92747: LIST
92748: PUSH
92749: LD_INT 3
92751: NEG
92752: PUSH
92753: LD_INT 1
92755: PUSH
92756: EMPTY
92757: LIST
92758: LIST
92759: PUSH
92760: LD_INT 4
92762: NEG
92763: PUSH
92764: LD_INT 0
92766: PUSH
92767: EMPTY
92768: LIST
92769: LIST
92770: PUSH
92771: LD_INT 4
92773: NEG
92774: PUSH
92775: LD_INT 1
92777: NEG
92778: PUSH
92779: EMPTY
92780: LIST
92781: LIST
92782: PUSH
92783: LD_INT 4
92785: NEG
92786: PUSH
92787: LD_INT 1
92789: PUSH
92790: EMPTY
92791: LIST
92792: LIST
92793: PUSH
92794: LD_INT 5
92796: NEG
92797: PUSH
92798: LD_INT 0
92800: PUSH
92801: EMPTY
92802: LIST
92803: LIST
92804: PUSH
92805: LD_INT 5
92807: NEG
92808: PUSH
92809: LD_INT 1
92811: NEG
92812: PUSH
92813: EMPTY
92814: LIST
92815: LIST
92816: PUSH
92817: LD_INT 5
92819: NEG
92820: PUSH
92821: LD_INT 1
92823: PUSH
92824: EMPTY
92825: LIST
92826: LIST
92827: PUSH
92828: LD_INT 6
92830: NEG
92831: PUSH
92832: LD_INT 0
92834: PUSH
92835: EMPTY
92836: LIST
92837: LIST
92838: PUSH
92839: LD_INT 6
92841: NEG
92842: PUSH
92843: LD_INT 1
92845: NEG
92846: PUSH
92847: EMPTY
92848: LIST
92849: LIST
92850: PUSH
92851: EMPTY
92852: LIST
92853: LIST
92854: LIST
92855: LIST
92856: LIST
92857: LIST
92858: LIST
92859: LIST
92860: LIST
92861: LIST
92862: LIST
92863: LIST
92864: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
92865: LD_ADDR_VAR 0 34
92869: PUSH
92870: LD_INT 2
92872: NEG
92873: PUSH
92874: LD_INT 3
92876: NEG
92877: PUSH
92878: EMPTY
92879: LIST
92880: LIST
92881: PUSH
92882: LD_INT 3
92884: NEG
92885: PUSH
92886: LD_INT 2
92888: NEG
92889: PUSH
92890: EMPTY
92891: LIST
92892: LIST
92893: PUSH
92894: LD_INT 3
92896: NEG
92897: PUSH
92898: LD_INT 3
92900: NEG
92901: PUSH
92902: EMPTY
92903: LIST
92904: LIST
92905: PUSH
92906: LD_INT 3
92908: NEG
92909: PUSH
92910: LD_INT 4
92912: NEG
92913: PUSH
92914: EMPTY
92915: LIST
92916: LIST
92917: PUSH
92918: LD_INT 4
92920: NEG
92921: PUSH
92922: LD_INT 3
92924: NEG
92925: PUSH
92926: EMPTY
92927: LIST
92928: LIST
92929: PUSH
92930: LD_INT 4
92932: NEG
92933: PUSH
92934: LD_INT 4
92936: NEG
92937: PUSH
92938: EMPTY
92939: LIST
92940: LIST
92941: PUSH
92942: LD_INT 4
92944: NEG
92945: PUSH
92946: LD_INT 5
92948: NEG
92949: PUSH
92950: EMPTY
92951: LIST
92952: LIST
92953: PUSH
92954: LD_INT 5
92956: NEG
92957: PUSH
92958: LD_INT 4
92960: NEG
92961: PUSH
92962: EMPTY
92963: LIST
92964: LIST
92965: PUSH
92966: LD_INT 5
92968: NEG
92969: PUSH
92970: LD_INT 5
92972: NEG
92973: PUSH
92974: EMPTY
92975: LIST
92976: LIST
92977: PUSH
92978: LD_INT 5
92980: NEG
92981: PUSH
92982: LD_INT 6
92984: NEG
92985: PUSH
92986: EMPTY
92987: LIST
92988: LIST
92989: PUSH
92990: LD_INT 6
92992: NEG
92993: PUSH
92994: LD_INT 5
92996: NEG
92997: PUSH
92998: EMPTY
92999: LIST
93000: LIST
93001: PUSH
93002: LD_INT 6
93004: NEG
93005: PUSH
93006: LD_INT 6
93008: NEG
93009: PUSH
93010: EMPTY
93011: LIST
93012: LIST
93013: PUSH
93014: EMPTY
93015: LIST
93016: LIST
93017: LIST
93018: LIST
93019: LIST
93020: LIST
93021: LIST
93022: LIST
93023: LIST
93024: LIST
93025: LIST
93026: LIST
93027: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
93028: LD_ADDR_VAR 0 41
93032: PUSH
93033: LD_INT 0
93035: PUSH
93036: LD_INT 2
93038: NEG
93039: PUSH
93040: EMPTY
93041: LIST
93042: LIST
93043: PUSH
93044: LD_INT 1
93046: NEG
93047: PUSH
93048: LD_INT 3
93050: NEG
93051: PUSH
93052: EMPTY
93053: LIST
93054: LIST
93055: PUSH
93056: LD_INT 1
93058: PUSH
93059: LD_INT 2
93061: NEG
93062: PUSH
93063: EMPTY
93064: LIST
93065: LIST
93066: PUSH
93067: EMPTY
93068: LIST
93069: LIST
93070: LIST
93071: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
93072: LD_ADDR_VAR 0 42
93076: PUSH
93077: LD_INT 2
93079: PUSH
93080: LD_INT 0
93082: PUSH
93083: EMPTY
93084: LIST
93085: LIST
93086: PUSH
93087: LD_INT 2
93089: PUSH
93090: LD_INT 1
93092: NEG
93093: PUSH
93094: EMPTY
93095: LIST
93096: LIST
93097: PUSH
93098: LD_INT 3
93100: PUSH
93101: LD_INT 1
93103: PUSH
93104: EMPTY
93105: LIST
93106: LIST
93107: PUSH
93108: EMPTY
93109: LIST
93110: LIST
93111: LIST
93112: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93113: LD_ADDR_VAR 0 43
93117: PUSH
93118: LD_INT 2
93120: PUSH
93121: LD_INT 2
93123: PUSH
93124: EMPTY
93125: LIST
93126: LIST
93127: PUSH
93128: LD_INT 3
93130: PUSH
93131: LD_INT 2
93133: PUSH
93134: EMPTY
93135: LIST
93136: LIST
93137: PUSH
93138: LD_INT 2
93140: PUSH
93141: LD_INT 3
93143: PUSH
93144: EMPTY
93145: LIST
93146: LIST
93147: PUSH
93148: EMPTY
93149: LIST
93150: LIST
93151: LIST
93152: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93153: LD_ADDR_VAR 0 44
93157: PUSH
93158: LD_INT 0
93160: PUSH
93161: LD_INT 2
93163: PUSH
93164: EMPTY
93165: LIST
93166: LIST
93167: PUSH
93168: LD_INT 1
93170: PUSH
93171: LD_INT 3
93173: PUSH
93174: EMPTY
93175: LIST
93176: LIST
93177: PUSH
93178: LD_INT 1
93180: NEG
93181: PUSH
93182: LD_INT 2
93184: PUSH
93185: EMPTY
93186: LIST
93187: LIST
93188: PUSH
93189: EMPTY
93190: LIST
93191: LIST
93192: LIST
93193: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93194: LD_ADDR_VAR 0 45
93198: PUSH
93199: LD_INT 2
93201: NEG
93202: PUSH
93203: LD_INT 0
93205: PUSH
93206: EMPTY
93207: LIST
93208: LIST
93209: PUSH
93210: LD_INT 2
93212: NEG
93213: PUSH
93214: LD_INT 1
93216: PUSH
93217: EMPTY
93218: LIST
93219: LIST
93220: PUSH
93221: LD_INT 3
93223: NEG
93224: PUSH
93225: LD_INT 1
93227: NEG
93228: PUSH
93229: EMPTY
93230: LIST
93231: LIST
93232: PUSH
93233: EMPTY
93234: LIST
93235: LIST
93236: LIST
93237: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93238: LD_ADDR_VAR 0 46
93242: PUSH
93243: LD_INT 2
93245: NEG
93246: PUSH
93247: LD_INT 2
93249: NEG
93250: PUSH
93251: EMPTY
93252: LIST
93253: LIST
93254: PUSH
93255: LD_INT 2
93257: NEG
93258: PUSH
93259: LD_INT 3
93261: NEG
93262: PUSH
93263: EMPTY
93264: LIST
93265: LIST
93266: PUSH
93267: LD_INT 3
93269: NEG
93270: PUSH
93271: LD_INT 2
93273: NEG
93274: PUSH
93275: EMPTY
93276: LIST
93277: LIST
93278: PUSH
93279: EMPTY
93280: LIST
93281: LIST
93282: LIST
93283: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93284: LD_ADDR_VAR 0 47
93288: PUSH
93289: LD_INT 2
93291: NEG
93292: PUSH
93293: LD_INT 3
93295: NEG
93296: PUSH
93297: EMPTY
93298: LIST
93299: LIST
93300: PUSH
93301: LD_INT 1
93303: NEG
93304: PUSH
93305: LD_INT 3
93307: NEG
93308: PUSH
93309: EMPTY
93310: LIST
93311: LIST
93312: PUSH
93313: EMPTY
93314: LIST
93315: LIST
93316: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
93317: LD_ADDR_VAR 0 48
93321: PUSH
93322: LD_INT 1
93324: PUSH
93325: LD_INT 2
93327: NEG
93328: PUSH
93329: EMPTY
93330: LIST
93331: LIST
93332: PUSH
93333: LD_INT 2
93335: PUSH
93336: LD_INT 1
93338: NEG
93339: PUSH
93340: EMPTY
93341: LIST
93342: LIST
93343: PUSH
93344: EMPTY
93345: LIST
93346: LIST
93347: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
93348: LD_ADDR_VAR 0 49
93352: PUSH
93353: LD_INT 3
93355: PUSH
93356: LD_INT 1
93358: PUSH
93359: EMPTY
93360: LIST
93361: LIST
93362: PUSH
93363: LD_INT 3
93365: PUSH
93366: LD_INT 2
93368: PUSH
93369: EMPTY
93370: LIST
93371: LIST
93372: PUSH
93373: EMPTY
93374: LIST
93375: LIST
93376: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
93377: LD_ADDR_VAR 0 50
93381: PUSH
93382: LD_INT 2
93384: PUSH
93385: LD_INT 3
93387: PUSH
93388: EMPTY
93389: LIST
93390: LIST
93391: PUSH
93392: LD_INT 1
93394: PUSH
93395: LD_INT 3
93397: PUSH
93398: EMPTY
93399: LIST
93400: LIST
93401: PUSH
93402: EMPTY
93403: LIST
93404: LIST
93405: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
93406: LD_ADDR_VAR 0 51
93410: PUSH
93411: LD_INT 1
93413: NEG
93414: PUSH
93415: LD_INT 2
93417: PUSH
93418: EMPTY
93419: LIST
93420: LIST
93421: PUSH
93422: LD_INT 2
93424: NEG
93425: PUSH
93426: LD_INT 1
93428: PUSH
93429: EMPTY
93430: LIST
93431: LIST
93432: PUSH
93433: EMPTY
93434: LIST
93435: LIST
93436: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
93437: LD_ADDR_VAR 0 52
93441: PUSH
93442: LD_INT 3
93444: NEG
93445: PUSH
93446: LD_INT 1
93448: NEG
93449: PUSH
93450: EMPTY
93451: LIST
93452: LIST
93453: PUSH
93454: LD_INT 3
93456: NEG
93457: PUSH
93458: LD_INT 2
93460: NEG
93461: PUSH
93462: EMPTY
93463: LIST
93464: LIST
93465: PUSH
93466: EMPTY
93467: LIST
93468: LIST
93469: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93470: LD_ADDR_VAR 0 53
93474: PUSH
93475: LD_INT 1
93477: NEG
93478: PUSH
93479: LD_INT 3
93481: NEG
93482: PUSH
93483: EMPTY
93484: LIST
93485: LIST
93486: PUSH
93487: LD_INT 0
93489: PUSH
93490: LD_INT 3
93492: NEG
93493: PUSH
93494: EMPTY
93495: LIST
93496: LIST
93497: PUSH
93498: LD_INT 1
93500: PUSH
93501: LD_INT 2
93503: NEG
93504: PUSH
93505: EMPTY
93506: LIST
93507: LIST
93508: PUSH
93509: EMPTY
93510: LIST
93511: LIST
93512: LIST
93513: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93514: LD_ADDR_VAR 0 54
93518: PUSH
93519: LD_INT 2
93521: PUSH
93522: LD_INT 1
93524: NEG
93525: PUSH
93526: EMPTY
93527: LIST
93528: LIST
93529: PUSH
93530: LD_INT 3
93532: PUSH
93533: LD_INT 0
93535: PUSH
93536: EMPTY
93537: LIST
93538: LIST
93539: PUSH
93540: LD_INT 3
93542: PUSH
93543: LD_INT 1
93545: PUSH
93546: EMPTY
93547: LIST
93548: LIST
93549: PUSH
93550: EMPTY
93551: LIST
93552: LIST
93553: LIST
93554: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93555: LD_ADDR_VAR 0 55
93559: PUSH
93560: LD_INT 3
93562: PUSH
93563: LD_INT 2
93565: PUSH
93566: EMPTY
93567: LIST
93568: LIST
93569: PUSH
93570: LD_INT 3
93572: PUSH
93573: LD_INT 3
93575: PUSH
93576: EMPTY
93577: LIST
93578: LIST
93579: PUSH
93580: LD_INT 2
93582: PUSH
93583: LD_INT 3
93585: PUSH
93586: EMPTY
93587: LIST
93588: LIST
93589: PUSH
93590: EMPTY
93591: LIST
93592: LIST
93593: LIST
93594: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93595: LD_ADDR_VAR 0 56
93599: PUSH
93600: LD_INT 1
93602: PUSH
93603: LD_INT 3
93605: PUSH
93606: EMPTY
93607: LIST
93608: LIST
93609: PUSH
93610: LD_INT 0
93612: PUSH
93613: LD_INT 3
93615: PUSH
93616: EMPTY
93617: LIST
93618: LIST
93619: PUSH
93620: LD_INT 1
93622: NEG
93623: PUSH
93624: LD_INT 2
93626: PUSH
93627: EMPTY
93628: LIST
93629: LIST
93630: PUSH
93631: EMPTY
93632: LIST
93633: LIST
93634: LIST
93635: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93636: LD_ADDR_VAR 0 57
93640: PUSH
93641: LD_INT 2
93643: NEG
93644: PUSH
93645: LD_INT 1
93647: PUSH
93648: EMPTY
93649: LIST
93650: LIST
93651: PUSH
93652: LD_INT 3
93654: NEG
93655: PUSH
93656: LD_INT 0
93658: PUSH
93659: EMPTY
93660: LIST
93661: LIST
93662: PUSH
93663: LD_INT 3
93665: NEG
93666: PUSH
93667: LD_INT 1
93669: NEG
93670: PUSH
93671: EMPTY
93672: LIST
93673: LIST
93674: PUSH
93675: EMPTY
93676: LIST
93677: LIST
93678: LIST
93679: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93680: LD_ADDR_VAR 0 58
93684: PUSH
93685: LD_INT 2
93687: NEG
93688: PUSH
93689: LD_INT 3
93691: NEG
93692: PUSH
93693: EMPTY
93694: LIST
93695: LIST
93696: PUSH
93697: LD_INT 3
93699: NEG
93700: PUSH
93701: LD_INT 2
93703: NEG
93704: PUSH
93705: EMPTY
93706: LIST
93707: LIST
93708: PUSH
93709: LD_INT 3
93711: NEG
93712: PUSH
93713: LD_INT 3
93715: NEG
93716: PUSH
93717: EMPTY
93718: LIST
93719: LIST
93720: PUSH
93721: EMPTY
93722: LIST
93723: LIST
93724: LIST
93725: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
93726: LD_ADDR_VAR 0 59
93730: PUSH
93731: LD_INT 1
93733: NEG
93734: PUSH
93735: LD_INT 2
93737: NEG
93738: PUSH
93739: EMPTY
93740: LIST
93741: LIST
93742: PUSH
93743: LD_INT 0
93745: PUSH
93746: LD_INT 2
93748: NEG
93749: PUSH
93750: EMPTY
93751: LIST
93752: LIST
93753: PUSH
93754: LD_INT 1
93756: PUSH
93757: LD_INT 1
93759: NEG
93760: PUSH
93761: EMPTY
93762: LIST
93763: LIST
93764: PUSH
93765: EMPTY
93766: LIST
93767: LIST
93768: LIST
93769: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
93770: LD_ADDR_VAR 0 60
93774: PUSH
93775: LD_INT 1
93777: PUSH
93778: LD_INT 1
93780: NEG
93781: PUSH
93782: EMPTY
93783: LIST
93784: LIST
93785: PUSH
93786: LD_INT 2
93788: PUSH
93789: LD_INT 0
93791: PUSH
93792: EMPTY
93793: LIST
93794: LIST
93795: PUSH
93796: LD_INT 2
93798: PUSH
93799: LD_INT 1
93801: PUSH
93802: EMPTY
93803: LIST
93804: LIST
93805: PUSH
93806: EMPTY
93807: LIST
93808: LIST
93809: LIST
93810: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
93811: LD_ADDR_VAR 0 61
93815: PUSH
93816: LD_INT 2
93818: PUSH
93819: LD_INT 1
93821: PUSH
93822: EMPTY
93823: LIST
93824: LIST
93825: PUSH
93826: LD_INT 2
93828: PUSH
93829: LD_INT 2
93831: PUSH
93832: EMPTY
93833: LIST
93834: LIST
93835: PUSH
93836: LD_INT 1
93838: PUSH
93839: LD_INT 2
93841: PUSH
93842: EMPTY
93843: LIST
93844: LIST
93845: PUSH
93846: EMPTY
93847: LIST
93848: LIST
93849: LIST
93850: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
93851: LD_ADDR_VAR 0 62
93855: PUSH
93856: LD_INT 1
93858: PUSH
93859: LD_INT 2
93861: PUSH
93862: EMPTY
93863: LIST
93864: LIST
93865: PUSH
93866: LD_INT 0
93868: PUSH
93869: LD_INT 2
93871: PUSH
93872: EMPTY
93873: LIST
93874: LIST
93875: PUSH
93876: LD_INT 1
93878: NEG
93879: PUSH
93880: LD_INT 1
93882: PUSH
93883: EMPTY
93884: LIST
93885: LIST
93886: PUSH
93887: EMPTY
93888: LIST
93889: LIST
93890: LIST
93891: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
93892: LD_ADDR_VAR 0 63
93896: PUSH
93897: LD_INT 1
93899: NEG
93900: PUSH
93901: LD_INT 1
93903: PUSH
93904: EMPTY
93905: LIST
93906: LIST
93907: PUSH
93908: LD_INT 2
93910: NEG
93911: PUSH
93912: LD_INT 0
93914: PUSH
93915: EMPTY
93916: LIST
93917: LIST
93918: PUSH
93919: LD_INT 2
93921: NEG
93922: PUSH
93923: LD_INT 1
93925: NEG
93926: PUSH
93927: EMPTY
93928: LIST
93929: LIST
93930: PUSH
93931: EMPTY
93932: LIST
93933: LIST
93934: LIST
93935: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93936: LD_ADDR_VAR 0 64
93940: PUSH
93941: LD_INT 1
93943: NEG
93944: PUSH
93945: LD_INT 2
93947: NEG
93948: PUSH
93949: EMPTY
93950: LIST
93951: LIST
93952: PUSH
93953: LD_INT 2
93955: NEG
93956: PUSH
93957: LD_INT 1
93959: NEG
93960: PUSH
93961: EMPTY
93962: LIST
93963: LIST
93964: PUSH
93965: LD_INT 2
93967: NEG
93968: PUSH
93969: LD_INT 2
93971: NEG
93972: PUSH
93973: EMPTY
93974: LIST
93975: LIST
93976: PUSH
93977: EMPTY
93978: LIST
93979: LIST
93980: LIST
93981: ST_TO_ADDR
// end ; 2 :
93982: GO 97248
93984: LD_INT 2
93986: DOUBLE
93987: EQUAL
93988: IFTRUE 93992
93990: GO 97247
93992: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
93993: LD_ADDR_VAR 0 29
93997: PUSH
93998: LD_INT 4
94000: PUSH
94001: LD_INT 0
94003: PUSH
94004: EMPTY
94005: LIST
94006: LIST
94007: PUSH
94008: LD_INT 4
94010: PUSH
94011: LD_INT 1
94013: NEG
94014: PUSH
94015: EMPTY
94016: LIST
94017: LIST
94018: PUSH
94019: LD_INT 5
94021: PUSH
94022: LD_INT 0
94024: PUSH
94025: EMPTY
94026: LIST
94027: LIST
94028: PUSH
94029: LD_INT 5
94031: PUSH
94032: LD_INT 1
94034: PUSH
94035: EMPTY
94036: LIST
94037: LIST
94038: PUSH
94039: LD_INT 4
94041: PUSH
94042: LD_INT 1
94044: PUSH
94045: EMPTY
94046: LIST
94047: LIST
94048: PUSH
94049: LD_INT 3
94051: PUSH
94052: LD_INT 0
94054: PUSH
94055: EMPTY
94056: LIST
94057: LIST
94058: PUSH
94059: LD_INT 3
94061: PUSH
94062: LD_INT 1
94064: NEG
94065: PUSH
94066: EMPTY
94067: LIST
94068: LIST
94069: PUSH
94070: LD_INT 3
94072: PUSH
94073: LD_INT 2
94075: NEG
94076: PUSH
94077: EMPTY
94078: LIST
94079: LIST
94080: PUSH
94081: LD_INT 5
94083: PUSH
94084: LD_INT 2
94086: PUSH
94087: EMPTY
94088: LIST
94089: LIST
94090: PUSH
94091: LD_INT 3
94093: PUSH
94094: LD_INT 3
94096: PUSH
94097: EMPTY
94098: LIST
94099: LIST
94100: PUSH
94101: LD_INT 3
94103: PUSH
94104: LD_INT 2
94106: PUSH
94107: EMPTY
94108: LIST
94109: LIST
94110: PUSH
94111: LD_INT 4
94113: PUSH
94114: LD_INT 3
94116: PUSH
94117: EMPTY
94118: LIST
94119: LIST
94120: PUSH
94121: LD_INT 4
94123: PUSH
94124: LD_INT 4
94126: PUSH
94127: EMPTY
94128: LIST
94129: LIST
94130: PUSH
94131: LD_INT 3
94133: PUSH
94134: LD_INT 4
94136: PUSH
94137: EMPTY
94138: LIST
94139: LIST
94140: PUSH
94141: LD_INT 2
94143: PUSH
94144: LD_INT 3
94146: PUSH
94147: EMPTY
94148: LIST
94149: LIST
94150: PUSH
94151: LD_INT 2
94153: PUSH
94154: LD_INT 2
94156: PUSH
94157: EMPTY
94158: LIST
94159: LIST
94160: PUSH
94161: LD_INT 4
94163: PUSH
94164: LD_INT 2
94166: PUSH
94167: EMPTY
94168: LIST
94169: LIST
94170: PUSH
94171: LD_INT 2
94173: PUSH
94174: LD_INT 4
94176: PUSH
94177: EMPTY
94178: LIST
94179: LIST
94180: PUSH
94181: LD_INT 0
94183: PUSH
94184: LD_INT 4
94186: PUSH
94187: EMPTY
94188: LIST
94189: LIST
94190: PUSH
94191: LD_INT 0
94193: PUSH
94194: LD_INT 3
94196: PUSH
94197: EMPTY
94198: LIST
94199: LIST
94200: PUSH
94201: LD_INT 1
94203: PUSH
94204: LD_INT 4
94206: PUSH
94207: EMPTY
94208: LIST
94209: LIST
94210: PUSH
94211: LD_INT 1
94213: PUSH
94214: LD_INT 5
94216: PUSH
94217: EMPTY
94218: LIST
94219: LIST
94220: PUSH
94221: LD_INT 0
94223: PUSH
94224: LD_INT 5
94226: PUSH
94227: EMPTY
94228: LIST
94229: LIST
94230: PUSH
94231: LD_INT 1
94233: NEG
94234: PUSH
94235: LD_INT 4
94237: PUSH
94238: EMPTY
94239: LIST
94240: LIST
94241: PUSH
94242: LD_INT 1
94244: NEG
94245: PUSH
94246: LD_INT 3
94248: PUSH
94249: EMPTY
94250: LIST
94251: LIST
94252: PUSH
94253: LD_INT 2
94255: PUSH
94256: LD_INT 5
94258: PUSH
94259: EMPTY
94260: LIST
94261: LIST
94262: PUSH
94263: LD_INT 2
94265: NEG
94266: PUSH
94267: LD_INT 3
94269: PUSH
94270: EMPTY
94271: LIST
94272: LIST
94273: PUSH
94274: LD_INT 3
94276: NEG
94277: PUSH
94278: LD_INT 0
94280: PUSH
94281: EMPTY
94282: LIST
94283: LIST
94284: PUSH
94285: LD_INT 3
94287: NEG
94288: PUSH
94289: LD_INT 1
94291: NEG
94292: PUSH
94293: EMPTY
94294: LIST
94295: LIST
94296: PUSH
94297: LD_INT 2
94299: NEG
94300: PUSH
94301: LD_INT 0
94303: PUSH
94304: EMPTY
94305: LIST
94306: LIST
94307: PUSH
94308: LD_INT 2
94310: NEG
94311: PUSH
94312: LD_INT 1
94314: PUSH
94315: EMPTY
94316: LIST
94317: LIST
94318: PUSH
94319: LD_INT 3
94321: NEG
94322: PUSH
94323: LD_INT 1
94325: PUSH
94326: EMPTY
94327: LIST
94328: LIST
94329: PUSH
94330: LD_INT 4
94332: NEG
94333: PUSH
94334: LD_INT 0
94336: PUSH
94337: EMPTY
94338: LIST
94339: LIST
94340: PUSH
94341: LD_INT 4
94343: NEG
94344: PUSH
94345: LD_INT 1
94347: NEG
94348: PUSH
94349: EMPTY
94350: LIST
94351: LIST
94352: PUSH
94353: LD_INT 4
94355: NEG
94356: PUSH
94357: LD_INT 2
94359: NEG
94360: PUSH
94361: EMPTY
94362: LIST
94363: LIST
94364: PUSH
94365: LD_INT 2
94367: NEG
94368: PUSH
94369: LD_INT 2
94371: PUSH
94372: EMPTY
94373: LIST
94374: LIST
94375: PUSH
94376: LD_INT 4
94378: NEG
94379: PUSH
94380: LD_INT 4
94382: NEG
94383: PUSH
94384: EMPTY
94385: LIST
94386: LIST
94387: PUSH
94388: LD_INT 4
94390: NEG
94391: PUSH
94392: LD_INT 5
94394: NEG
94395: PUSH
94396: EMPTY
94397: LIST
94398: LIST
94399: PUSH
94400: LD_INT 3
94402: NEG
94403: PUSH
94404: LD_INT 4
94406: NEG
94407: PUSH
94408: EMPTY
94409: LIST
94410: LIST
94411: PUSH
94412: LD_INT 3
94414: NEG
94415: PUSH
94416: LD_INT 3
94418: NEG
94419: PUSH
94420: EMPTY
94421: LIST
94422: LIST
94423: PUSH
94424: LD_INT 4
94426: NEG
94427: PUSH
94428: LD_INT 3
94430: NEG
94431: PUSH
94432: EMPTY
94433: LIST
94434: LIST
94435: PUSH
94436: LD_INT 5
94438: NEG
94439: PUSH
94440: LD_INT 4
94442: NEG
94443: PUSH
94444: EMPTY
94445: LIST
94446: LIST
94447: PUSH
94448: LD_INT 5
94450: NEG
94451: PUSH
94452: LD_INT 5
94454: NEG
94455: PUSH
94456: EMPTY
94457: LIST
94458: LIST
94459: PUSH
94460: LD_INT 3
94462: NEG
94463: PUSH
94464: LD_INT 5
94466: NEG
94467: PUSH
94468: EMPTY
94469: LIST
94470: LIST
94471: PUSH
94472: LD_INT 5
94474: NEG
94475: PUSH
94476: LD_INT 3
94478: NEG
94479: PUSH
94480: EMPTY
94481: LIST
94482: LIST
94483: PUSH
94484: EMPTY
94485: LIST
94486: LIST
94487: LIST
94488: LIST
94489: LIST
94490: LIST
94491: LIST
94492: LIST
94493: LIST
94494: LIST
94495: LIST
94496: LIST
94497: LIST
94498: LIST
94499: LIST
94500: LIST
94501: LIST
94502: LIST
94503: LIST
94504: LIST
94505: LIST
94506: LIST
94507: LIST
94508: LIST
94509: LIST
94510: LIST
94511: LIST
94512: LIST
94513: LIST
94514: LIST
94515: LIST
94516: LIST
94517: LIST
94518: LIST
94519: LIST
94520: LIST
94521: LIST
94522: LIST
94523: LIST
94524: LIST
94525: LIST
94526: LIST
94527: LIST
94528: LIST
94529: LIST
94530: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
94531: LD_ADDR_VAR 0 30
94535: PUSH
94536: LD_INT 4
94538: PUSH
94539: LD_INT 4
94541: PUSH
94542: EMPTY
94543: LIST
94544: LIST
94545: PUSH
94546: LD_INT 4
94548: PUSH
94549: LD_INT 3
94551: PUSH
94552: EMPTY
94553: LIST
94554: LIST
94555: PUSH
94556: LD_INT 5
94558: PUSH
94559: LD_INT 4
94561: PUSH
94562: EMPTY
94563: LIST
94564: LIST
94565: PUSH
94566: LD_INT 5
94568: PUSH
94569: LD_INT 5
94571: PUSH
94572: EMPTY
94573: LIST
94574: LIST
94575: PUSH
94576: LD_INT 4
94578: PUSH
94579: LD_INT 5
94581: PUSH
94582: EMPTY
94583: LIST
94584: LIST
94585: PUSH
94586: LD_INT 3
94588: PUSH
94589: LD_INT 4
94591: PUSH
94592: EMPTY
94593: LIST
94594: LIST
94595: PUSH
94596: LD_INT 3
94598: PUSH
94599: LD_INT 3
94601: PUSH
94602: EMPTY
94603: LIST
94604: LIST
94605: PUSH
94606: LD_INT 5
94608: PUSH
94609: LD_INT 3
94611: PUSH
94612: EMPTY
94613: LIST
94614: LIST
94615: PUSH
94616: LD_INT 3
94618: PUSH
94619: LD_INT 5
94621: PUSH
94622: EMPTY
94623: LIST
94624: LIST
94625: PUSH
94626: LD_INT 0
94628: PUSH
94629: LD_INT 3
94631: PUSH
94632: EMPTY
94633: LIST
94634: LIST
94635: PUSH
94636: LD_INT 0
94638: PUSH
94639: LD_INT 2
94641: PUSH
94642: EMPTY
94643: LIST
94644: LIST
94645: PUSH
94646: LD_INT 1
94648: PUSH
94649: LD_INT 3
94651: PUSH
94652: EMPTY
94653: LIST
94654: LIST
94655: PUSH
94656: LD_INT 1
94658: PUSH
94659: LD_INT 4
94661: PUSH
94662: EMPTY
94663: LIST
94664: LIST
94665: PUSH
94666: LD_INT 0
94668: PUSH
94669: LD_INT 4
94671: PUSH
94672: EMPTY
94673: LIST
94674: LIST
94675: PUSH
94676: LD_INT 1
94678: NEG
94679: PUSH
94680: LD_INT 3
94682: PUSH
94683: EMPTY
94684: LIST
94685: LIST
94686: PUSH
94687: LD_INT 1
94689: NEG
94690: PUSH
94691: LD_INT 2
94693: PUSH
94694: EMPTY
94695: LIST
94696: LIST
94697: PUSH
94698: LD_INT 2
94700: PUSH
94701: LD_INT 4
94703: PUSH
94704: EMPTY
94705: LIST
94706: LIST
94707: PUSH
94708: LD_INT 2
94710: NEG
94711: PUSH
94712: LD_INT 2
94714: PUSH
94715: EMPTY
94716: LIST
94717: LIST
94718: PUSH
94719: LD_INT 4
94721: NEG
94722: PUSH
94723: LD_INT 0
94725: PUSH
94726: EMPTY
94727: LIST
94728: LIST
94729: PUSH
94730: LD_INT 4
94732: NEG
94733: PUSH
94734: LD_INT 1
94736: NEG
94737: PUSH
94738: EMPTY
94739: LIST
94740: LIST
94741: PUSH
94742: LD_INT 3
94744: NEG
94745: PUSH
94746: LD_INT 0
94748: PUSH
94749: EMPTY
94750: LIST
94751: LIST
94752: PUSH
94753: LD_INT 3
94755: NEG
94756: PUSH
94757: LD_INT 1
94759: PUSH
94760: EMPTY
94761: LIST
94762: LIST
94763: PUSH
94764: LD_INT 4
94766: NEG
94767: PUSH
94768: LD_INT 1
94770: PUSH
94771: EMPTY
94772: LIST
94773: LIST
94774: PUSH
94775: LD_INT 5
94777: NEG
94778: PUSH
94779: LD_INT 0
94781: PUSH
94782: EMPTY
94783: LIST
94784: LIST
94785: PUSH
94786: LD_INT 5
94788: NEG
94789: PUSH
94790: LD_INT 1
94792: NEG
94793: PUSH
94794: EMPTY
94795: LIST
94796: LIST
94797: PUSH
94798: LD_INT 5
94800: NEG
94801: PUSH
94802: LD_INT 2
94804: NEG
94805: PUSH
94806: EMPTY
94807: LIST
94808: LIST
94809: PUSH
94810: LD_INT 3
94812: NEG
94813: PUSH
94814: LD_INT 2
94816: PUSH
94817: EMPTY
94818: LIST
94819: LIST
94820: PUSH
94821: LD_INT 3
94823: NEG
94824: PUSH
94825: LD_INT 3
94827: NEG
94828: PUSH
94829: EMPTY
94830: LIST
94831: LIST
94832: PUSH
94833: LD_INT 3
94835: NEG
94836: PUSH
94837: LD_INT 4
94839: NEG
94840: PUSH
94841: EMPTY
94842: LIST
94843: LIST
94844: PUSH
94845: LD_INT 2
94847: NEG
94848: PUSH
94849: LD_INT 3
94851: NEG
94852: PUSH
94853: EMPTY
94854: LIST
94855: LIST
94856: PUSH
94857: LD_INT 2
94859: NEG
94860: PUSH
94861: LD_INT 2
94863: NEG
94864: PUSH
94865: EMPTY
94866: LIST
94867: LIST
94868: PUSH
94869: LD_INT 3
94871: NEG
94872: PUSH
94873: LD_INT 2
94875: NEG
94876: PUSH
94877: EMPTY
94878: LIST
94879: LIST
94880: PUSH
94881: LD_INT 4
94883: NEG
94884: PUSH
94885: LD_INT 3
94887: NEG
94888: PUSH
94889: EMPTY
94890: LIST
94891: LIST
94892: PUSH
94893: LD_INT 4
94895: NEG
94896: PUSH
94897: LD_INT 4
94899: NEG
94900: PUSH
94901: EMPTY
94902: LIST
94903: LIST
94904: PUSH
94905: LD_INT 2
94907: NEG
94908: PUSH
94909: LD_INT 4
94911: NEG
94912: PUSH
94913: EMPTY
94914: LIST
94915: LIST
94916: PUSH
94917: LD_INT 4
94919: NEG
94920: PUSH
94921: LD_INT 2
94923: NEG
94924: PUSH
94925: EMPTY
94926: LIST
94927: LIST
94928: PUSH
94929: LD_INT 0
94931: PUSH
94932: LD_INT 4
94934: NEG
94935: PUSH
94936: EMPTY
94937: LIST
94938: LIST
94939: PUSH
94940: LD_INT 0
94942: PUSH
94943: LD_INT 5
94945: NEG
94946: PUSH
94947: EMPTY
94948: LIST
94949: LIST
94950: PUSH
94951: LD_INT 1
94953: PUSH
94954: LD_INT 4
94956: NEG
94957: PUSH
94958: EMPTY
94959: LIST
94960: LIST
94961: PUSH
94962: LD_INT 1
94964: PUSH
94965: LD_INT 3
94967: NEG
94968: PUSH
94969: EMPTY
94970: LIST
94971: LIST
94972: PUSH
94973: LD_INT 0
94975: PUSH
94976: LD_INT 3
94978: NEG
94979: PUSH
94980: EMPTY
94981: LIST
94982: LIST
94983: PUSH
94984: LD_INT 1
94986: NEG
94987: PUSH
94988: LD_INT 4
94990: NEG
94991: PUSH
94992: EMPTY
94993: LIST
94994: LIST
94995: PUSH
94996: LD_INT 1
94998: NEG
94999: PUSH
95000: LD_INT 5
95002: NEG
95003: PUSH
95004: EMPTY
95005: LIST
95006: LIST
95007: PUSH
95008: LD_INT 2
95010: PUSH
95011: LD_INT 3
95013: NEG
95014: PUSH
95015: EMPTY
95016: LIST
95017: LIST
95018: PUSH
95019: LD_INT 2
95021: NEG
95022: PUSH
95023: LD_INT 5
95025: NEG
95026: PUSH
95027: EMPTY
95028: LIST
95029: LIST
95030: PUSH
95031: EMPTY
95032: LIST
95033: LIST
95034: LIST
95035: LIST
95036: LIST
95037: LIST
95038: LIST
95039: LIST
95040: LIST
95041: LIST
95042: LIST
95043: LIST
95044: LIST
95045: LIST
95046: LIST
95047: LIST
95048: LIST
95049: LIST
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: LIST
95056: LIST
95057: LIST
95058: LIST
95059: LIST
95060: LIST
95061: LIST
95062: LIST
95063: LIST
95064: LIST
95065: LIST
95066: LIST
95067: LIST
95068: LIST
95069: LIST
95070: LIST
95071: LIST
95072: LIST
95073: LIST
95074: LIST
95075: LIST
95076: LIST
95077: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
95078: LD_ADDR_VAR 0 31
95082: PUSH
95083: LD_INT 0
95085: PUSH
95086: LD_INT 4
95088: PUSH
95089: EMPTY
95090: LIST
95091: LIST
95092: PUSH
95093: LD_INT 0
95095: PUSH
95096: LD_INT 3
95098: PUSH
95099: EMPTY
95100: LIST
95101: LIST
95102: PUSH
95103: LD_INT 1
95105: PUSH
95106: LD_INT 4
95108: PUSH
95109: EMPTY
95110: LIST
95111: LIST
95112: PUSH
95113: LD_INT 1
95115: PUSH
95116: LD_INT 5
95118: PUSH
95119: EMPTY
95120: LIST
95121: LIST
95122: PUSH
95123: LD_INT 0
95125: PUSH
95126: LD_INT 5
95128: PUSH
95129: EMPTY
95130: LIST
95131: LIST
95132: PUSH
95133: LD_INT 1
95135: NEG
95136: PUSH
95137: LD_INT 4
95139: PUSH
95140: EMPTY
95141: LIST
95142: LIST
95143: PUSH
95144: LD_INT 1
95146: NEG
95147: PUSH
95148: LD_INT 3
95150: PUSH
95151: EMPTY
95152: LIST
95153: LIST
95154: PUSH
95155: LD_INT 2
95157: PUSH
95158: LD_INT 5
95160: PUSH
95161: EMPTY
95162: LIST
95163: LIST
95164: PUSH
95165: LD_INT 2
95167: NEG
95168: PUSH
95169: LD_INT 3
95171: PUSH
95172: EMPTY
95173: LIST
95174: LIST
95175: PUSH
95176: LD_INT 3
95178: NEG
95179: PUSH
95180: LD_INT 0
95182: PUSH
95183: EMPTY
95184: LIST
95185: LIST
95186: PUSH
95187: LD_INT 3
95189: NEG
95190: PUSH
95191: LD_INT 1
95193: NEG
95194: PUSH
95195: EMPTY
95196: LIST
95197: LIST
95198: PUSH
95199: LD_INT 2
95201: NEG
95202: PUSH
95203: LD_INT 0
95205: PUSH
95206: EMPTY
95207: LIST
95208: LIST
95209: PUSH
95210: LD_INT 2
95212: NEG
95213: PUSH
95214: LD_INT 1
95216: PUSH
95217: EMPTY
95218: LIST
95219: LIST
95220: PUSH
95221: LD_INT 3
95223: NEG
95224: PUSH
95225: LD_INT 1
95227: PUSH
95228: EMPTY
95229: LIST
95230: LIST
95231: PUSH
95232: LD_INT 4
95234: NEG
95235: PUSH
95236: LD_INT 0
95238: PUSH
95239: EMPTY
95240: LIST
95241: LIST
95242: PUSH
95243: LD_INT 4
95245: NEG
95246: PUSH
95247: LD_INT 1
95249: NEG
95250: PUSH
95251: EMPTY
95252: LIST
95253: LIST
95254: PUSH
95255: LD_INT 4
95257: NEG
95258: PUSH
95259: LD_INT 2
95261: NEG
95262: PUSH
95263: EMPTY
95264: LIST
95265: LIST
95266: PUSH
95267: LD_INT 2
95269: NEG
95270: PUSH
95271: LD_INT 2
95273: PUSH
95274: EMPTY
95275: LIST
95276: LIST
95277: PUSH
95278: LD_INT 4
95280: NEG
95281: PUSH
95282: LD_INT 4
95284: NEG
95285: PUSH
95286: EMPTY
95287: LIST
95288: LIST
95289: PUSH
95290: LD_INT 4
95292: NEG
95293: PUSH
95294: LD_INT 5
95296: NEG
95297: PUSH
95298: EMPTY
95299: LIST
95300: LIST
95301: PUSH
95302: LD_INT 3
95304: NEG
95305: PUSH
95306: LD_INT 4
95308: NEG
95309: PUSH
95310: EMPTY
95311: LIST
95312: LIST
95313: PUSH
95314: LD_INT 3
95316: NEG
95317: PUSH
95318: LD_INT 3
95320: NEG
95321: PUSH
95322: EMPTY
95323: LIST
95324: LIST
95325: PUSH
95326: LD_INT 4
95328: NEG
95329: PUSH
95330: LD_INT 3
95332: NEG
95333: PUSH
95334: EMPTY
95335: LIST
95336: LIST
95337: PUSH
95338: LD_INT 5
95340: NEG
95341: PUSH
95342: LD_INT 4
95344: NEG
95345: PUSH
95346: EMPTY
95347: LIST
95348: LIST
95349: PUSH
95350: LD_INT 5
95352: NEG
95353: PUSH
95354: LD_INT 5
95356: NEG
95357: PUSH
95358: EMPTY
95359: LIST
95360: LIST
95361: PUSH
95362: LD_INT 3
95364: NEG
95365: PUSH
95366: LD_INT 5
95368: NEG
95369: PUSH
95370: EMPTY
95371: LIST
95372: LIST
95373: PUSH
95374: LD_INT 5
95376: NEG
95377: PUSH
95378: LD_INT 3
95380: NEG
95381: PUSH
95382: EMPTY
95383: LIST
95384: LIST
95385: PUSH
95386: LD_INT 0
95388: PUSH
95389: LD_INT 3
95391: NEG
95392: PUSH
95393: EMPTY
95394: LIST
95395: LIST
95396: PUSH
95397: LD_INT 0
95399: PUSH
95400: LD_INT 4
95402: NEG
95403: PUSH
95404: EMPTY
95405: LIST
95406: LIST
95407: PUSH
95408: LD_INT 1
95410: PUSH
95411: LD_INT 3
95413: NEG
95414: PUSH
95415: EMPTY
95416: LIST
95417: LIST
95418: PUSH
95419: LD_INT 1
95421: PUSH
95422: LD_INT 2
95424: NEG
95425: PUSH
95426: EMPTY
95427: LIST
95428: LIST
95429: PUSH
95430: LD_INT 0
95432: PUSH
95433: LD_INT 2
95435: NEG
95436: PUSH
95437: EMPTY
95438: LIST
95439: LIST
95440: PUSH
95441: LD_INT 1
95443: NEG
95444: PUSH
95445: LD_INT 3
95447: NEG
95448: PUSH
95449: EMPTY
95450: LIST
95451: LIST
95452: PUSH
95453: LD_INT 1
95455: NEG
95456: PUSH
95457: LD_INT 4
95459: NEG
95460: PUSH
95461: EMPTY
95462: LIST
95463: LIST
95464: PUSH
95465: LD_INT 2
95467: PUSH
95468: LD_INT 2
95470: NEG
95471: PUSH
95472: EMPTY
95473: LIST
95474: LIST
95475: PUSH
95476: LD_INT 2
95478: NEG
95479: PUSH
95480: LD_INT 4
95482: NEG
95483: PUSH
95484: EMPTY
95485: LIST
95486: LIST
95487: PUSH
95488: LD_INT 4
95490: PUSH
95491: LD_INT 0
95493: PUSH
95494: EMPTY
95495: LIST
95496: LIST
95497: PUSH
95498: LD_INT 4
95500: PUSH
95501: LD_INT 1
95503: NEG
95504: PUSH
95505: EMPTY
95506: LIST
95507: LIST
95508: PUSH
95509: LD_INT 5
95511: PUSH
95512: LD_INT 0
95514: PUSH
95515: EMPTY
95516: LIST
95517: LIST
95518: PUSH
95519: LD_INT 5
95521: PUSH
95522: LD_INT 1
95524: PUSH
95525: EMPTY
95526: LIST
95527: LIST
95528: PUSH
95529: LD_INT 4
95531: PUSH
95532: LD_INT 1
95534: PUSH
95535: EMPTY
95536: LIST
95537: LIST
95538: PUSH
95539: LD_INT 3
95541: PUSH
95542: LD_INT 0
95544: PUSH
95545: EMPTY
95546: LIST
95547: LIST
95548: PUSH
95549: LD_INT 3
95551: PUSH
95552: LD_INT 1
95554: NEG
95555: PUSH
95556: EMPTY
95557: LIST
95558: LIST
95559: PUSH
95560: LD_INT 3
95562: PUSH
95563: LD_INT 2
95565: NEG
95566: PUSH
95567: EMPTY
95568: LIST
95569: LIST
95570: PUSH
95571: LD_INT 5
95573: PUSH
95574: LD_INT 2
95576: PUSH
95577: EMPTY
95578: LIST
95579: LIST
95580: PUSH
95581: EMPTY
95582: LIST
95583: LIST
95584: LIST
95585: LIST
95586: LIST
95587: LIST
95588: LIST
95589: LIST
95590: LIST
95591: LIST
95592: LIST
95593: LIST
95594: LIST
95595: LIST
95596: LIST
95597: LIST
95598: LIST
95599: LIST
95600: LIST
95601: LIST
95602: LIST
95603: LIST
95604: LIST
95605: LIST
95606: LIST
95607: LIST
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: LIST
95614: LIST
95615: LIST
95616: LIST
95617: LIST
95618: LIST
95619: LIST
95620: LIST
95621: LIST
95622: LIST
95623: LIST
95624: LIST
95625: LIST
95626: LIST
95627: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
95628: LD_ADDR_VAR 0 32
95632: PUSH
95633: LD_INT 4
95635: NEG
95636: PUSH
95637: LD_INT 0
95639: PUSH
95640: EMPTY
95641: LIST
95642: LIST
95643: PUSH
95644: LD_INT 4
95646: NEG
95647: PUSH
95648: LD_INT 1
95650: NEG
95651: PUSH
95652: EMPTY
95653: LIST
95654: LIST
95655: PUSH
95656: LD_INT 3
95658: NEG
95659: PUSH
95660: LD_INT 0
95662: PUSH
95663: EMPTY
95664: LIST
95665: LIST
95666: PUSH
95667: LD_INT 3
95669: NEG
95670: PUSH
95671: LD_INT 1
95673: PUSH
95674: EMPTY
95675: LIST
95676: LIST
95677: PUSH
95678: LD_INT 4
95680: NEG
95681: PUSH
95682: LD_INT 1
95684: PUSH
95685: EMPTY
95686: LIST
95687: LIST
95688: PUSH
95689: LD_INT 5
95691: NEG
95692: PUSH
95693: LD_INT 0
95695: PUSH
95696: EMPTY
95697: LIST
95698: LIST
95699: PUSH
95700: LD_INT 5
95702: NEG
95703: PUSH
95704: LD_INT 1
95706: NEG
95707: PUSH
95708: EMPTY
95709: LIST
95710: LIST
95711: PUSH
95712: LD_INT 5
95714: NEG
95715: PUSH
95716: LD_INT 2
95718: NEG
95719: PUSH
95720: EMPTY
95721: LIST
95722: LIST
95723: PUSH
95724: LD_INT 3
95726: NEG
95727: PUSH
95728: LD_INT 2
95730: PUSH
95731: EMPTY
95732: LIST
95733: LIST
95734: PUSH
95735: LD_INT 3
95737: NEG
95738: PUSH
95739: LD_INT 3
95741: NEG
95742: PUSH
95743: EMPTY
95744: LIST
95745: LIST
95746: PUSH
95747: LD_INT 3
95749: NEG
95750: PUSH
95751: LD_INT 4
95753: NEG
95754: PUSH
95755: EMPTY
95756: LIST
95757: LIST
95758: PUSH
95759: LD_INT 2
95761: NEG
95762: PUSH
95763: LD_INT 3
95765: NEG
95766: PUSH
95767: EMPTY
95768: LIST
95769: LIST
95770: PUSH
95771: LD_INT 2
95773: NEG
95774: PUSH
95775: LD_INT 2
95777: NEG
95778: PUSH
95779: EMPTY
95780: LIST
95781: LIST
95782: PUSH
95783: LD_INT 3
95785: NEG
95786: PUSH
95787: LD_INT 2
95789: NEG
95790: PUSH
95791: EMPTY
95792: LIST
95793: LIST
95794: PUSH
95795: LD_INT 4
95797: NEG
95798: PUSH
95799: LD_INT 3
95801: NEG
95802: PUSH
95803: EMPTY
95804: LIST
95805: LIST
95806: PUSH
95807: LD_INT 4
95809: NEG
95810: PUSH
95811: LD_INT 4
95813: NEG
95814: PUSH
95815: EMPTY
95816: LIST
95817: LIST
95818: PUSH
95819: LD_INT 2
95821: NEG
95822: PUSH
95823: LD_INT 4
95825: NEG
95826: PUSH
95827: EMPTY
95828: LIST
95829: LIST
95830: PUSH
95831: LD_INT 4
95833: NEG
95834: PUSH
95835: LD_INT 2
95837: NEG
95838: PUSH
95839: EMPTY
95840: LIST
95841: LIST
95842: PUSH
95843: LD_INT 0
95845: PUSH
95846: LD_INT 4
95848: NEG
95849: PUSH
95850: EMPTY
95851: LIST
95852: LIST
95853: PUSH
95854: LD_INT 0
95856: PUSH
95857: LD_INT 5
95859: NEG
95860: PUSH
95861: EMPTY
95862: LIST
95863: LIST
95864: PUSH
95865: LD_INT 1
95867: PUSH
95868: LD_INT 4
95870: NEG
95871: PUSH
95872: EMPTY
95873: LIST
95874: LIST
95875: PUSH
95876: LD_INT 1
95878: PUSH
95879: LD_INT 3
95881: NEG
95882: PUSH
95883: EMPTY
95884: LIST
95885: LIST
95886: PUSH
95887: LD_INT 0
95889: PUSH
95890: LD_INT 3
95892: NEG
95893: PUSH
95894: EMPTY
95895: LIST
95896: LIST
95897: PUSH
95898: LD_INT 1
95900: NEG
95901: PUSH
95902: LD_INT 4
95904: NEG
95905: PUSH
95906: EMPTY
95907: LIST
95908: LIST
95909: PUSH
95910: LD_INT 1
95912: NEG
95913: PUSH
95914: LD_INT 5
95916: NEG
95917: PUSH
95918: EMPTY
95919: LIST
95920: LIST
95921: PUSH
95922: LD_INT 2
95924: PUSH
95925: LD_INT 3
95927: NEG
95928: PUSH
95929: EMPTY
95930: LIST
95931: LIST
95932: PUSH
95933: LD_INT 2
95935: NEG
95936: PUSH
95937: LD_INT 5
95939: NEG
95940: PUSH
95941: EMPTY
95942: LIST
95943: LIST
95944: PUSH
95945: LD_INT 3
95947: PUSH
95948: LD_INT 0
95950: PUSH
95951: EMPTY
95952: LIST
95953: LIST
95954: PUSH
95955: LD_INT 3
95957: PUSH
95958: LD_INT 1
95960: NEG
95961: PUSH
95962: EMPTY
95963: LIST
95964: LIST
95965: PUSH
95966: LD_INT 4
95968: PUSH
95969: LD_INT 0
95971: PUSH
95972: EMPTY
95973: LIST
95974: LIST
95975: PUSH
95976: LD_INT 4
95978: PUSH
95979: LD_INT 1
95981: PUSH
95982: EMPTY
95983: LIST
95984: LIST
95985: PUSH
95986: LD_INT 3
95988: PUSH
95989: LD_INT 1
95991: PUSH
95992: EMPTY
95993: LIST
95994: LIST
95995: PUSH
95996: LD_INT 2
95998: PUSH
95999: LD_INT 0
96001: PUSH
96002: EMPTY
96003: LIST
96004: LIST
96005: PUSH
96006: LD_INT 2
96008: PUSH
96009: LD_INT 1
96011: NEG
96012: PUSH
96013: EMPTY
96014: LIST
96015: LIST
96016: PUSH
96017: LD_INT 2
96019: PUSH
96020: LD_INT 2
96022: NEG
96023: PUSH
96024: EMPTY
96025: LIST
96026: LIST
96027: PUSH
96028: LD_INT 4
96030: PUSH
96031: LD_INT 2
96033: PUSH
96034: EMPTY
96035: LIST
96036: LIST
96037: PUSH
96038: LD_INT 4
96040: PUSH
96041: LD_INT 4
96043: PUSH
96044: EMPTY
96045: LIST
96046: LIST
96047: PUSH
96048: LD_INT 4
96050: PUSH
96051: LD_INT 3
96053: PUSH
96054: EMPTY
96055: LIST
96056: LIST
96057: PUSH
96058: LD_INT 5
96060: PUSH
96061: LD_INT 4
96063: PUSH
96064: EMPTY
96065: LIST
96066: LIST
96067: PUSH
96068: LD_INT 5
96070: PUSH
96071: LD_INT 5
96073: PUSH
96074: EMPTY
96075: LIST
96076: LIST
96077: PUSH
96078: LD_INT 4
96080: PUSH
96081: LD_INT 5
96083: PUSH
96084: EMPTY
96085: LIST
96086: LIST
96087: PUSH
96088: LD_INT 3
96090: PUSH
96091: LD_INT 4
96093: PUSH
96094: EMPTY
96095: LIST
96096: LIST
96097: PUSH
96098: LD_INT 3
96100: PUSH
96101: LD_INT 3
96103: PUSH
96104: EMPTY
96105: LIST
96106: LIST
96107: PUSH
96108: LD_INT 5
96110: PUSH
96111: LD_INT 3
96113: PUSH
96114: EMPTY
96115: LIST
96116: LIST
96117: PUSH
96118: LD_INT 3
96120: PUSH
96121: LD_INT 5
96123: PUSH
96124: EMPTY
96125: LIST
96126: LIST
96127: PUSH
96128: EMPTY
96129: LIST
96130: LIST
96131: LIST
96132: LIST
96133: LIST
96134: LIST
96135: LIST
96136: LIST
96137: LIST
96138: LIST
96139: LIST
96140: LIST
96141: LIST
96142: LIST
96143: LIST
96144: LIST
96145: LIST
96146: LIST
96147: LIST
96148: LIST
96149: LIST
96150: LIST
96151: LIST
96152: LIST
96153: LIST
96154: LIST
96155: LIST
96156: LIST
96157: LIST
96158: LIST
96159: LIST
96160: LIST
96161: LIST
96162: LIST
96163: LIST
96164: LIST
96165: LIST
96166: LIST
96167: LIST
96168: LIST
96169: LIST
96170: LIST
96171: LIST
96172: LIST
96173: LIST
96174: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96175: LD_ADDR_VAR 0 33
96179: PUSH
96180: LD_INT 4
96182: NEG
96183: PUSH
96184: LD_INT 4
96186: NEG
96187: PUSH
96188: EMPTY
96189: LIST
96190: LIST
96191: PUSH
96192: LD_INT 4
96194: NEG
96195: PUSH
96196: LD_INT 5
96198: NEG
96199: PUSH
96200: EMPTY
96201: LIST
96202: LIST
96203: PUSH
96204: LD_INT 3
96206: NEG
96207: PUSH
96208: LD_INT 4
96210: NEG
96211: PUSH
96212: EMPTY
96213: LIST
96214: LIST
96215: PUSH
96216: LD_INT 3
96218: NEG
96219: PUSH
96220: LD_INT 3
96222: NEG
96223: PUSH
96224: EMPTY
96225: LIST
96226: LIST
96227: PUSH
96228: LD_INT 4
96230: NEG
96231: PUSH
96232: LD_INT 3
96234: NEG
96235: PUSH
96236: EMPTY
96237: LIST
96238: LIST
96239: PUSH
96240: LD_INT 5
96242: NEG
96243: PUSH
96244: LD_INT 4
96246: NEG
96247: PUSH
96248: EMPTY
96249: LIST
96250: LIST
96251: PUSH
96252: LD_INT 5
96254: NEG
96255: PUSH
96256: LD_INT 5
96258: NEG
96259: PUSH
96260: EMPTY
96261: LIST
96262: LIST
96263: PUSH
96264: LD_INT 3
96266: NEG
96267: PUSH
96268: LD_INT 5
96270: NEG
96271: PUSH
96272: EMPTY
96273: LIST
96274: LIST
96275: PUSH
96276: LD_INT 5
96278: NEG
96279: PUSH
96280: LD_INT 3
96282: NEG
96283: PUSH
96284: EMPTY
96285: LIST
96286: LIST
96287: PUSH
96288: LD_INT 0
96290: PUSH
96291: LD_INT 3
96293: NEG
96294: PUSH
96295: EMPTY
96296: LIST
96297: LIST
96298: PUSH
96299: LD_INT 0
96301: PUSH
96302: LD_INT 4
96304: NEG
96305: PUSH
96306: EMPTY
96307: LIST
96308: LIST
96309: PUSH
96310: LD_INT 1
96312: PUSH
96313: LD_INT 3
96315: NEG
96316: PUSH
96317: EMPTY
96318: LIST
96319: LIST
96320: PUSH
96321: LD_INT 1
96323: PUSH
96324: LD_INT 2
96326: NEG
96327: PUSH
96328: EMPTY
96329: LIST
96330: LIST
96331: PUSH
96332: LD_INT 0
96334: PUSH
96335: LD_INT 2
96337: NEG
96338: PUSH
96339: EMPTY
96340: LIST
96341: LIST
96342: PUSH
96343: LD_INT 1
96345: NEG
96346: PUSH
96347: LD_INT 3
96349: NEG
96350: PUSH
96351: EMPTY
96352: LIST
96353: LIST
96354: PUSH
96355: LD_INT 1
96357: NEG
96358: PUSH
96359: LD_INT 4
96361: NEG
96362: PUSH
96363: EMPTY
96364: LIST
96365: LIST
96366: PUSH
96367: LD_INT 2
96369: PUSH
96370: LD_INT 2
96372: NEG
96373: PUSH
96374: EMPTY
96375: LIST
96376: LIST
96377: PUSH
96378: LD_INT 2
96380: NEG
96381: PUSH
96382: LD_INT 4
96384: NEG
96385: PUSH
96386: EMPTY
96387: LIST
96388: LIST
96389: PUSH
96390: LD_INT 4
96392: PUSH
96393: LD_INT 0
96395: PUSH
96396: EMPTY
96397: LIST
96398: LIST
96399: PUSH
96400: LD_INT 4
96402: PUSH
96403: LD_INT 1
96405: NEG
96406: PUSH
96407: EMPTY
96408: LIST
96409: LIST
96410: PUSH
96411: LD_INT 5
96413: PUSH
96414: LD_INT 0
96416: PUSH
96417: EMPTY
96418: LIST
96419: LIST
96420: PUSH
96421: LD_INT 5
96423: PUSH
96424: LD_INT 1
96426: PUSH
96427: EMPTY
96428: LIST
96429: LIST
96430: PUSH
96431: LD_INT 4
96433: PUSH
96434: LD_INT 1
96436: PUSH
96437: EMPTY
96438: LIST
96439: LIST
96440: PUSH
96441: LD_INT 3
96443: PUSH
96444: LD_INT 0
96446: PUSH
96447: EMPTY
96448: LIST
96449: LIST
96450: PUSH
96451: LD_INT 3
96453: PUSH
96454: LD_INT 1
96456: NEG
96457: PUSH
96458: EMPTY
96459: LIST
96460: LIST
96461: PUSH
96462: LD_INT 3
96464: PUSH
96465: LD_INT 2
96467: NEG
96468: PUSH
96469: EMPTY
96470: LIST
96471: LIST
96472: PUSH
96473: LD_INT 5
96475: PUSH
96476: LD_INT 2
96478: PUSH
96479: EMPTY
96480: LIST
96481: LIST
96482: PUSH
96483: LD_INT 3
96485: PUSH
96486: LD_INT 3
96488: PUSH
96489: EMPTY
96490: LIST
96491: LIST
96492: PUSH
96493: LD_INT 3
96495: PUSH
96496: LD_INT 2
96498: PUSH
96499: EMPTY
96500: LIST
96501: LIST
96502: PUSH
96503: LD_INT 4
96505: PUSH
96506: LD_INT 3
96508: PUSH
96509: EMPTY
96510: LIST
96511: LIST
96512: PUSH
96513: LD_INT 4
96515: PUSH
96516: LD_INT 4
96518: PUSH
96519: EMPTY
96520: LIST
96521: LIST
96522: PUSH
96523: LD_INT 3
96525: PUSH
96526: LD_INT 4
96528: PUSH
96529: EMPTY
96530: LIST
96531: LIST
96532: PUSH
96533: LD_INT 2
96535: PUSH
96536: LD_INT 3
96538: PUSH
96539: EMPTY
96540: LIST
96541: LIST
96542: PUSH
96543: LD_INT 2
96545: PUSH
96546: LD_INT 2
96548: PUSH
96549: EMPTY
96550: LIST
96551: LIST
96552: PUSH
96553: LD_INT 4
96555: PUSH
96556: LD_INT 2
96558: PUSH
96559: EMPTY
96560: LIST
96561: LIST
96562: PUSH
96563: LD_INT 2
96565: PUSH
96566: LD_INT 4
96568: PUSH
96569: EMPTY
96570: LIST
96571: LIST
96572: PUSH
96573: LD_INT 0
96575: PUSH
96576: LD_INT 4
96578: PUSH
96579: EMPTY
96580: LIST
96581: LIST
96582: PUSH
96583: LD_INT 0
96585: PUSH
96586: LD_INT 3
96588: PUSH
96589: EMPTY
96590: LIST
96591: LIST
96592: PUSH
96593: LD_INT 1
96595: PUSH
96596: LD_INT 4
96598: PUSH
96599: EMPTY
96600: LIST
96601: LIST
96602: PUSH
96603: LD_INT 1
96605: PUSH
96606: LD_INT 5
96608: PUSH
96609: EMPTY
96610: LIST
96611: LIST
96612: PUSH
96613: LD_INT 0
96615: PUSH
96616: LD_INT 5
96618: PUSH
96619: EMPTY
96620: LIST
96621: LIST
96622: PUSH
96623: LD_INT 1
96625: NEG
96626: PUSH
96627: LD_INT 4
96629: PUSH
96630: EMPTY
96631: LIST
96632: LIST
96633: PUSH
96634: LD_INT 1
96636: NEG
96637: PUSH
96638: LD_INT 3
96640: PUSH
96641: EMPTY
96642: LIST
96643: LIST
96644: PUSH
96645: LD_INT 2
96647: PUSH
96648: LD_INT 5
96650: PUSH
96651: EMPTY
96652: LIST
96653: LIST
96654: PUSH
96655: LD_INT 2
96657: NEG
96658: PUSH
96659: LD_INT 3
96661: PUSH
96662: EMPTY
96663: LIST
96664: LIST
96665: PUSH
96666: EMPTY
96667: LIST
96668: LIST
96669: LIST
96670: LIST
96671: LIST
96672: LIST
96673: LIST
96674: LIST
96675: LIST
96676: LIST
96677: LIST
96678: LIST
96679: LIST
96680: LIST
96681: LIST
96682: LIST
96683: LIST
96684: LIST
96685: LIST
96686: LIST
96687: LIST
96688: LIST
96689: LIST
96690: LIST
96691: LIST
96692: LIST
96693: LIST
96694: LIST
96695: LIST
96696: LIST
96697: LIST
96698: LIST
96699: LIST
96700: LIST
96701: LIST
96702: LIST
96703: LIST
96704: LIST
96705: LIST
96706: LIST
96707: LIST
96708: LIST
96709: LIST
96710: LIST
96711: LIST
96712: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
96713: LD_ADDR_VAR 0 34
96717: PUSH
96718: LD_INT 0
96720: PUSH
96721: LD_INT 4
96723: NEG
96724: PUSH
96725: EMPTY
96726: LIST
96727: LIST
96728: PUSH
96729: LD_INT 0
96731: PUSH
96732: LD_INT 5
96734: NEG
96735: PUSH
96736: EMPTY
96737: LIST
96738: LIST
96739: PUSH
96740: LD_INT 1
96742: PUSH
96743: LD_INT 4
96745: NEG
96746: PUSH
96747: EMPTY
96748: LIST
96749: LIST
96750: PUSH
96751: LD_INT 1
96753: PUSH
96754: LD_INT 3
96756: NEG
96757: PUSH
96758: EMPTY
96759: LIST
96760: LIST
96761: PUSH
96762: LD_INT 0
96764: PUSH
96765: LD_INT 3
96767: NEG
96768: PUSH
96769: EMPTY
96770: LIST
96771: LIST
96772: PUSH
96773: LD_INT 1
96775: NEG
96776: PUSH
96777: LD_INT 4
96779: NEG
96780: PUSH
96781: EMPTY
96782: LIST
96783: LIST
96784: PUSH
96785: LD_INT 1
96787: NEG
96788: PUSH
96789: LD_INT 5
96791: NEG
96792: PUSH
96793: EMPTY
96794: LIST
96795: LIST
96796: PUSH
96797: LD_INT 2
96799: PUSH
96800: LD_INT 3
96802: NEG
96803: PUSH
96804: EMPTY
96805: LIST
96806: LIST
96807: PUSH
96808: LD_INT 2
96810: NEG
96811: PUSH
96812: LD_INT 5
96814: NEG
96815: PUSH
96816: EMPTY
96817: LIST
96818: LIST
96819: PUSH
96820: LD_INT 3
96822: PUSH
96823: LD_INT 0
96825: PUSH
96826: EMPTY
96827: LIST
96828: LIST
96829: PUSH
96830: LD_INT 3
96832: PUSH
96833: LD_INT 1
96835: NEG
96836: PUSH
96837: EMPTY
96838: LIST
96839: LIST
96840: PUSH
96841: LD_INT 4
96843: PUSH
96844: LD_INT 0
96846: PUSH
96847: EMPTY
96848: LIST
96849: LIST
96850: PUSH
96851: LD_INT 4
96853: PUSH
96854: LD_INT 1
96856: PUSH
96857: EMPTY
96858: LIST
96859: LIST
96860: PUSH
96861: LD_INT 3
96863: PUSH
96864: LD_INT 1
96866: PUSH
96867: EMPTY
96868: LIST
96869: LIST
96870: PUSH
96871: LD_INT 2
96873: PUSH
96874: LD_INT 0
96876: PUSH
96877: EMPTY
96878: LIST
96879: LIST
96880: PUSH
96881: LD_INT 2
96883: PUSH
96884: LD_INT 1
96886: NEG
96887: PUSH
96888: EMPTY
96889: LIST
96890: LIST
96891: PUSH
96892: LD_INT 2
96894: PUSH
96895: LD_INT 2
96897: NEG
96898: PUSH
96899: EMPTY
96900: LIST
96901: LIST
96902: PUSH
96903: LD_INT 4
96905: PUSH
96906: LD_INT 2
96908: PUSH
96909: EMPTY
96910: LIST
96911: LIST
96912: PUSH
96913: LD_INT 4
96915: PUSH
96916: LD_INT 4
96918: PUSH
96919: EMPTY
96920: LIST
96921: LIST
96922: PUSH
96923: LD_INT 4
96925: PUSH
96926: LD_INT 3
96928: PUSH
96929: EMPTY
96930: LIST
96931: LIST
96932: PUSH
96933: LD_INT 5
96935: PUSH
96936: LD_INT 4
96938: PUSH
96939: EMPTY
96940: LIST
96941: LIST
96942: PUSH
96943: LD_INT 5
96945: PUSH
96946: LD_INT 5
96948: PUSH
96949: EMPTY
96950: LIST
96951: LIST
96952: PUSH
96953: LD_INT 4
96955: PUSH
96956: LD_INT 5
96958: PUSH
96959: EMPTY
96960: LIST
96961: LIST
96962: PUSH
96963: LD_INT 3
96965: PUSH
96966: LD_INT 4
96968: PUSH
96969: EMPTY
96970: LIST
96971: LIST
96972: PUSH
96973: LD_INT 3
96975: PUSH
96976: LD_INT 3
96978: PUSH
96979: EMPTY
96980: LIST
96981: LIST
96982: PUSH
96983: LD_INT 5
96985: PUSH
96986: LD_INT 3
96988: PUSH
96989: EMPTY
96990: LIST
96991: LIST
96992: PUSH
96993: LD_INT 3
96995: PUSH
96996: LD_INT 5
96998: PUSH
96999: EMPTY
97000: LIST
97001: LIST
97002: PUSH
97003: LD_INT 0
97005: PUSH
97006: LD_INT 3
97008: PUSH
97009: EMPTY
97010: LIST
97011: LIST
97012: PUSH
97013: LD_INT 0
97015: PUSH
97016: LD_INT 2
97018: PUSH
97019: EMPTY
97020: LIST
97021: LIST
97022: PUSH
97023: LD_INT 1
97025: PUSH
97026: LD_INT 3
97028: PUSH
97029: EMPTY
97030: LIST
97031: LIST
97032: PUSH
97033: LD_INT 1
97035: PUSH
97036: LD_INT 4
97038: PUSH
97039: EMPTY
97040: LIST
97041: LIST
97042: PUSH
97043: LD_INT 0
97045: PUSH
97046: LD_INT 4
97048: PUSH
97049: EMPTY
97050: LIST
97051: LIST
97052: PUSH
97053: LD_INT 1
97055: NEG
97056: PUSH
97057: LD_INT 3
97059: PUSH
97060: EMPTY
97061: LIST
97062: LIST
97063: PUSH
97064: LD_INT 1
97066: NEG
97067: PUSH
97068: LD_INT 2
97070: PUSH
97071: EMPTY
97072: LIST
97073: LIST
97074: PUSH
97075: LD_INT 2
97077: PUSH
97078: LD_INT 4
97080: PUSH
97081: EMPTY
97082: LIST
97083: LIST
97084: PUSH
97085: LD_INT 2
97087: NEG
97088: PUSH
97089: LD_INT 2
97091: PUSH
97092: EMPTY
97093: LIST
97094: LIST
97095: PUSH
97096: LD_INT 4
97098: NEG
97099: PUSH
97100: LD_INT 0
97102: PUSH
97103: EMPTY
97104: LIST
97105: LIST
97106: PUSH
97107: LD_INT 4
97109: NEG
97110: PUSH
97111: LD_INT 1
97113: NEG
97114: PUSH
97115: EMPTY
97116: LIST
97117: LIST
97118: PUSH
97119: LD_INT 3
97121: NEG
97122: PUSH
97123: LD_INT 0
97125: PUSH
97126: EMPTY
97127: LIST
97128: LIST
97129: PUSH
97130: LD_INT 3
97132: NEG
97133: PUSH
97134: LD_INT 1
97136: PUSH
97137: EMPTY
97138: LIST
97139: LIST
97140: PUSH
97141: LD_INT 4
97143: NEG
97144: PUSH
97145: LD_INT 1
97147: PUSH
97148: EMPTY
97149: LIST
97150: LIST
97151: PUSH
97152: LD_INT 5
97154: NEG
97155: PUSH
97156: LD_INT 0
97158: PUSH
97159: EMPTY
97160: LIST
97161: LIST
97162: PUSH
97163: LD_INT 5
97165: NEG
97166: PUSH
97167: LD_INT 1
97169: NEG
97170: PUSH
97171: EMPTY
97172: LIST
97173: LIST
97174: PUSH
97175: LD_INT 5
97177: NEG
97178: PUSH
97179: LD_INT 2
97181: NEG
97182: PUSH
97183: EMPTY
97184: LIST
97185: LIST
97186: PUSH
97187: LD_INT 3
97189: NEG
97190: PUSH
97191: LD_INT 2
97193: PUSH
97194: EMPTY
97195: LIST
97196: LIST
97197: PUSH
97198: EMPTY
97199: LIST
97200: LIST
97201: LIST
97202: LIST
97203: LIST
97204: LIST
97205: LIST
97206: LIST
97207: LIST
97208: LIST
97209: LIST
97210: LIST
97211: LIST
97212: LIST
97213: LIST
97214: LIST
97215: LIST
97216: LIST
97217: LIST
97218: LIST
97219: LIST
97220: LIST
97221: LIST
97222: LIST
97223: LIST
97224: LIST
97225: LIST
97226: LIST
97227: LIST
97228: LIST
97229: LIST
97230: LIST
97231: LIST
97232: LIST
97233: LIST
97234: LIST
97235: LIST
97236: LIST
97237: LIST
97238: LIST
97239: LIST
97240: LIST
97241: LIST
97242: LIST
97243: LIST
97244: ST_TO_ADDR
// end ; end ;
97245: GO 97248
97247: POP
// case btype of b_depot , b_warehouse :
97248: LD_VAR 0 1
97252: PUSH
97253: LD_INT 0
97255: DOUBLE
97256: EQUAL
97257: IFTRUE 97267
97259: LD_INT 1
97261: DOUBLE
97262: EQUAL
97263: IFTRUE 97267
97265: GO 97468
97267: POP
// case nation of nation_american :
97268: LD_VAR 0 5
97272: PUSH
97273: LD_INT 1
97275: DOUBLE
97276: EQUAL
97277: IFTRUE 97281
97279: GO 97337
97281: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
97282: LD_ADDR_VAR 0 9
97286: PUSH
97287: LD_VAR 0 11
97291: PUSH
97292: LD_VAR 0 12
97296: PUSH
97297: LD_VAR 0 13
97301: PUSH
97302: LD_VAR 0 14
97306: PUSH
97307: LD_VAR 0 15
97311: PUSH
97312: LD_VAR 0 16
97316: PUSH
97317: EMPTY
97318: LIST
97319: LIST
97320: LIST
97321: LIST
97322: LIST
97323: LIST
97324: PUSH
97325: LD_VAR 0 4
97329: PUSH
97330: LD_INT 1
97332: PLUS
97333: ARRAY
97334: ST_TO_ADDR
97335: GO 97466
97337: LD_INT 2
97339: DOUBLE
97340: EQUAL
97341: IFTRUE 97345
97343: GO 97401
97345: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
97346: LD_ADDR_VAR 0 9
97350: PUSH
97351: LD_VAR 0 17
97355: PUSH
97356: LD_VAR 0 18
97360: PUSH
97361: LD_VAR 0 19
97365: PUSH
97366: LD_VAR 0 20
97370: PUSH
97371: LD_VAR 0 21
97375: PUSH
97376: LD_VAR 0 22
97380: PUSH
97381: EMPTY
97382: LIST
97383: LIST
97384: LIST
97385: LIST
97386: LIST
97387: LIST
97388: PUSH
97389: LD_VAR 0 4
97393: PUSH
97394: LD_INT 1
97396: PLUS
97397: ARRAY
97398: ST_TO_ADDR
97399: GO 97466
97401: LD_INT 3
97403: DOUBLE
97404: EQUAL
97405: IFTRUE 97409
97407: GO 97465
97409: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
97410: LD_ADDR_VAR 0 9
97414: PUSH
97415: LD_VAR 0 23
97419: PUSH
97420: LD_VAR 0 24
97424: PUSH
97425: LD_VAR 0 25
97429: PUSH
97430: LD_VAR 0 26
97434: PUSH
97435: LD_VAR 0 27
97439: PUSH
97440: LD_VAR 0 28
97444: PUSH
97445: EMPTY
97446: LIST
97447: LIST
97448: LIST
97449: LIST
97450: LIST
97451: LIST
97452: PUSH
97453: LD_VAR 0 4
97457: PUSH
97458: LD_INT 1
97460: PLUS
97461: ARRAY
97462: ST_TO_ADDR
97463: GO 97466
97465: POP
97466: GO 98021
97468: LD_INT 2
97470: DOUBLE
97471: EQUAL
97472: IFTRUE 97482
97474: LD_INT 3
97476: DOUBLE
97477: EQUAL
97478: IFTRUE 97482
97480: GO 97538
97482: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
97483: LD_ADDR_VAR 0 9
97487: PUSH
97488: LD_VAR 0 29
97492: PUSH
97493: LD_VAR 0 30
97497: PUSH
97498: LD_VAR 0 31
97502: PUSH
97503: LD_VAR 0 32
97507: PUSH
97508: LD_VAR 0 33
97512: PUSH
97513: LD_VAR 0 34
97517: PUSH
97518: EMPTY
97519: LIST
97520: LIST
97521: LIST
97522: LIST
97523: LIST
97524: LIST
97525: PUSH
97526: LD_VAR 0 4
97530: PUSH
97531: LD_INT 1
97533: PLUS
97534: ARRAY
97535: ST_TO_ADDR
97536: GO 98021
97538: LD_INT 16
97540: DOUBLE
97541: EQUAL
97542: IFTRUE 97600
97544: LD_INT 17
97546: DOUBLE
97547: EQUAL
97548: IFTRUE 97600
97550: LD_INT 18
97552: DOUBLE
97553: EQUAL
97554: IFTRUE 97600
97556: LD_INT 19
97558: DOUBLE
97559: EQUAL
97560: IFTRUE 97600
97562: LD_INT 22
97564: DOUBLE
97565: EQUAL
97566: IFTRUE 97600
97568: LD_INT 20
97570: DOUBLE
97571: EQUAL
97572: IFTRUE 97600
97574: LD_INT 21
97576: DOUBLE
97577: EQUAL
97578: IFTRUE 97600
97580: LD_INT 23
97582: DOUBLE
97583: EQUAL
97584: IFTRUE 97600
97586: LD_INT 24
97588: DOUBLE
97589: EQUAL
97590: IFTRUE 97600
97592: LD_INT 25
97594: DOUBLE
97595: EQUAL
97596: IFTRUE 97600
97598: GO 97656
97600: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
97601: LD_ADDR_VAR 0 9
97605: PUSH
97606: LD_VAR 0 35
97610: PUSH
97611: LD_VAR 0 36
97615: PUSH
97616: LD_VAR 0 37
97620: PUSH
97621: LD_VAR 0 38
97625: PUSH
97626: LD_VAR 0 39
97630: PUSH
97631: LD_VAR 0 40
97635: PUSH
97636: EMPTY
97637: LIST
97638: LIST
97639: LIST
97640: LIST
97641: LIST
97642: LIST
97643: PUSH
97644: LD_VAR 0 4
97648: PUSH
97649: LD_INT 1
97651: PLUS
97652: ARRAY
97653: ST_TO_ADDR
97654: GO 98021
97656: LD_INT 6
97658: DOUBLE
97659: EQUAL
97660: IFTRUE 97712
97662: LD_INT 7
97664: DOUBLE
97665: EQUAL
97666: IFTRUE 97712
97668: LD_INT 8
97670: DOUBLE
97671: EQUAL
97672: IFTRUE 97712
97674: LD_INT 13
97676: DOUBLE
97677: EQUAL
97678: IFTRUE 97712
97680: LD_INT 12
97682: DOUBLE
97683: EQUAL
97684: IFTRUE 97712
97686: LD_INT 15
97688: DOUBLE
97689: EQUAL
97690: IFTRUE 97712
97692: LD_INT 11
97694: DOUBLE
97695: EQUAL
97696: IFTRUE 97712
97698: LD_INT 14
97700: DOUBLE
97701: EQUAL
97702: IFTRUE 97712
97704: LD_INT 10
97706: DOUBLE
97707: EQUAL
97708: IFTRUE 97712
97710: GO 97768
97712: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
97713: LD_ADDR_VAR 0 9
97717: PUSH
97718: LD_VAR 0 41
97722: PUSH
97723: LD_VAR 0 42
97727: PUSH
97728: LD_VAR 0 43
97732: PUSH
97733: LD_VAR 0 44
97737: PUSH
97738: LD_VAR 0 45
97742: PUSH
97743: LD_VAR 0 46
97747: PUSH
97748: EMPTY
97749: LIST
97750: LIST
97751: LIST
97752: LIST
97753: LIST
97754: LIST
97755: PUSH
97756: LD_VAR 0 4
97760: PUSH
97761: LD_INT 1
97763: PLUS
97764: ARRAY
97765: ST_TO_ADDR
97766: GO 98021
97768: LD_INT 36
97770: DOUBLE
97771: EQUAL
97772: IFTRUE 97776
97774: GO 97832
97776: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
97777: LD_ADDR_VAR 0 9
97781: PUSH
97782: LD_VAR 0 47
97786: PUSH
97787: LD_VAR 0 48
97791: PUSH
97792: LD_VAR 0 49
97796: PUSH
97797: LD_VAR 0 50
97801: PUSH
97802: LD_VAR 0 51
97806: PUSH
97807: LD_VAR 0 52
97811: PUSH
97812: EMPTY
97813: LIST
97814: LIST
97815: LIST
97816: LIST
97817: LIST
97818: LIST
97819: PUSH
97820: LD_VAR 0 4
97824: PUSH
97825: LD_INT 1
97827: PLUS
97828: ARRAY
97829: ST_TO_ADDR
97830: GO 98021
97832: LD_INT 4
97834: DOUBLE
97835: EQUAL
97836: IFTRUE 97858
97838: LD_INT 5
97840: DOUBLE
97841: EQUAL
97842: IFTRUE 97858
97844: LD_INT 34
97846: DOUBLE
97847: EQUAL
97848: IFTRUE 97858
97850: LD_INT 37
97852: DOUBLE
97853: EQUAL
97854: IFTRUE 97858
97856: GO 97914
97858: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
97859: LD_ADDR_VAR 0 9
97863: PUSH
97864: LD_VAR 0 53
97868: PUSH
97869: LD_VAR 0 54
97873: PUSH
97874: LD_VAR 0 55
97878: PUSH
97879: LD_VAR 0 56
97883: PUSH
97884: LD_VAR 0 57
97888: PUSH
97889: LD_VAR 0 58
97893: PUSH
97894: EMPTY
97895: LIST
97896: LIST
97897: LIST
97898: LIST
97899: LIST
97900: LIST
97901: PUSH
97902: LD_VAR 0 4
97906: PUSH
97907: LD_INT 1
97909: PLUS
97910: ARRAY
97911: ST_TO_ADDR
97912: GO 98021
97914: LD_INT 31
97916: DOUBLE
97917: EQUAL
97918: IFTRUE 97964
97920: LD_INT 32
97922: DOUBLE
97923: EQUAL
97924: IFTRUE 97964
97926: LD_INT 33
97928: DOUBLE
97929: EQUAL
97930: IFTRUE 97964
97932: LD_INT 27
97934: DOUBLE
97935: EQUAL
97936: IFTRUE 97964
97938: LD_INT 26
97940: DOUBLE
97941: EQUAL
97942: IFTRUE 97964
97944: LD_INT 28
97946: DOUBLE
97947: EQUAL
97948: IFTRUE 97964
97950: LD_INT 29
97952: DOUBLE
97953: EQUAL
97954: IFTRUE 97964
97956: LD_INT 30
97958: DOUBLE
97959: EQUAL
97960: IFTRUE 97964
97962: GO 98020
97964: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
97965: LD_ADDR_VAR 0 9
97969: PUSH
97970: LD_VAR 0 59
97974: PUSH
97975: LD_VAR 0 60
97979: PUSH
97980: LD_VAR 0 61
97984: PUSH
97985: LD_VAR 0 62
97989: PUSH
97990: LD_VAR 0 63
97994: PUSH
97995: LD_VAR 0 64
97999: PUSH
98000: EMPTY
98001: LIST
98002: LIST
98003: LIST
98004: LIST
98005: LIST
98006: LIST
98007: PUSH
98008: LD_VAR 0 4
98012: PUSH
98013: LD_INT 1
98015: PLUS
98016: ARRAY
98017: ST_TO_ADDR
98018: GO 98021
98020: POP
// temp_list2 = [ ] ;
98021: LD_ADDR_VAR 0 10
98025: PUSH
98026: EMPTY
98027: ST_TO_ADDR
// for i in temp_list do
98028: LD_ADDR_VAR 0 8
98032: PUSH
98033: LD_VAR 0 9
98037: PUSH
98038: FOR_IN
98039: IFFALSE 98091
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
98041: LD_ADDR_VAR 0 10
98045: PUSH
98046: LD_VAR 0 10
98050: PUSH
98051: LD_VAR 0 8
98055: PUSH
98056: LD_INT 1
98058: ARRAY
98059: PUSH
98060: LD_VAR 0 2
98064: PLUS
98065: PUSH
98066: LD_VAR 0 8
98070: PUSH
98071: LD_INT 2
98073: ARRAY
98074: PUSH
98075: LD_VAR 0 3
98079: PLUS
98080: PUSH
98081: EMPTY
98082: LIST
98083: LIST
98084: PUSH
98085: EMPTY
98086: LIST
98087: ADD
98088: ST_TO_ADDR
98089: GO 98038
98091: POP
98092: POP
// result = temp_list2 ;
98093: LD_ADDR_VAR 0 7
98097: PUSH
98098: LD_VAR 0 10
98102: ST_TO_ADDR
// end ;
98103: LD_VAR 0 7
98107: RET
// export function EnemyInRange ( unit , dist ) ; begin
98108: LD_INT 0
98110: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98111: LD_ADDR_VAR 0 3
98115: PUSH
98116: LD_VAR 0 1
98120: PPUSH
98121: CALL_OW 255
98125: PPUSH
98126: LD_VAR 0 1
98130: PPUSH
98131: CALL_OW 250
98135: PPUSH
98136: LD_VAR 0 1
98140: PPUSH
98141: CALL_OW 251
98145: PPUSH
98146: LD_VAR 0 2
98150: PPUSH
98151: CALL 71504 0 4
98155: PUSH
98156: LD_INT 4
98158: ARRAY
98159: ST_TO_ADDR
// end ;
98160: LD_VAR 0 3
98164: RET
// export function PlayerSeeMe ( unit ) ; begin
98165: LD_INT 0
98167: PPUSH
// result := See ( your_side , unit ) ;
98168: LD_ADDR_VAR 0 2
98172: PUSH
98173: LD_OWVAR 2
98177: PPUSH
98178: LD_VAR 0 1
98182: PPUSH
98183: CALL_OW 292
98187: ST_TO_ADDR
// end ;
98188: LD_VAR 0 2
98192: RET
// export function ReverseDir ( unit ) ; begin
98193: LD_INT 0
98195: PPUSH
// if not unit then
98196: LD_VAR 0 1
98200: NOT
98201: IFFALSE 98205
// exit ;
98203: GO 98228
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
98205: LD_ADDR_VAR 0 2
98209: PUSH
98210: LD_VAR 0 1
98214: PPUSH
98215: CALL_OW 254
98219: PUSH
98220: LD_INT 3
98222: PLUS
98223: PUSH
98224: LD_INT 6
98226: MOD
98227: ST_TO_ADDR
// end ;
98228: LD_VAR 0 2
98232: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
98233: LD_INT 0
98235: PPUSH
98236: PPUSH
98237: PPUSH
98238: PPUSH
98239: PPUSH
// if not hexes then
98240: LD_VAR 0 2
98244: NOT
98245: IFFALSE 98249
// exit ;
98247: GO 98397
// dist := 9999 ;
98249: LD_ADDR_VAR 0 5
98253: PUSH
98254: LD_INT 9999
98256: ST_TO_ADDR
// for i = 1 to hexes do
98257: LD_ADDR_VAR 0 4
98261: PUSH
98262: DOUBLE
98263: LD_INT 1
98265: DEC
98266: ST_TO_ADDR
98267: LD_VAR 0 2
98271: PUSH
98272: FOR_TO
98273: IFFALSE 98385
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
98275: LD_VAR 0 1
98279: PPUSH
98280: LD_VAR 0 2
98284: PUSH
98285: LD_VAR 0 4
98289: ARRAY
98290: PUSH
98291: LD_INT 1
98293: ARRAY
98294: PPUSH
98295: LD_VAR 0 2
98299: PUSH
98300: LD_VAR 0 4
98304: ARRAY
98305: PUSH
98306: LD_INT 2
98308: ARRAY
98309: PPUSH
98310: CALL_OW 297
98314: PUSH
98315: LD_VAR 0 5
98319: LESS
98320: IFFALSE 98383
// begin hex := hexes [ i ] ;
98322: LD_ADDR_VAR 0 7
98326: PUSH
98327: LD_VAR 0 2
98331: PUSH
98332: LD_VAR 0 4
98336: ARRAY
98337: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
98338: LD_ADDR_VAR 0 5
98342: PUSH
98343: LD_VAR 0 1
98347: PPUSH
98348: LD_VAR 0 2
98352: PUSH
98353: LD_VAR 0 4
98357: ARRAY
98358: PUSH
98359: LD_INT 1
98361: ARRAY
98362: PPUSH
98363: LD_VAR 0 2
98367: PUSH
98368: LD_VAR 0 4
98372: ARRAY
98373: PUSH
98374: LD_INT 2
98376: ARRAY
98377: PPUSH
98378: CALL_OW 297
98382: ST_TO_ADDR
// end ; end ;
98383: GO 98272
98385: POP
98386: POP
// result := hex ;
98387: LD_ADDR_VAR 0 3
98391: PUSH
98392: LD_VAR 0 7
98396: ST_TO_ADDR
// end ;
98397: LD_VAR 0 3
98401: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
98402: LD_INT 0
98404: PPUSH
98405: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
98406: LD_VAR 0 1
98410: NOT
98411: PUSH
98412: LD_VAR 0 1
98416: PUSH
98417: LD_INT 21
98419: PUSH
98420: LD_INT 2
98422: PUSH
98423: EMPTY
98424: LIST
98425: LIST
98426: PUSH
98427: LD_INT 23
98429: PUSH
98430: LD_INT 2
98432: PUSH
98433: EMPTY
98434: LIST
98435: LIST
98436: PUSH
98437: EMPTY
98438: LIST
98439: LIST
98440: PPUSH
98441: CALL_OW 69
98445: IN
98446: NOT
98447: OR
98448: IFFALSE 98452
// exit ;
98450: GO 98499
// for i = 1 to 3 do
98452: LD_ADDR_VAR 0 3
98456: PUSH
98457: DOUBLE
98458: LD_INT 1
98460: DEC
98461: ST_TO_ADDR
98462: LD_INT 3
98464: PUSH
98465: FOR_TO
98466: IFFALSE 98497
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
98468: LD_VAR 0 1
98472: PPUSH
98473: CALL_OW 250
98477: PPUSH
98478: LD_VAR 0 1
98482: PPUSH
98483: CALL_OW 251
98487: PPUSH
98488: LD_INT 1
98490: PPUSH
98491: CALL_OW 453
98495: GO 98465
98497: POP
98498: POP
// end ;
98499: LD_VAR 0 2
98503: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
98504: LD_INT 0
98506: PPUSH
98507: PPUSH
98508: PPUSH
98509: PPUSH
98510: PPUSH
98511: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
98512: LD_VAR 0 1
98516: NOT
98517: PUSH
98518: LD_VAR 0 2
98522: NOT
98523: OR
98524: PUSH
98525: LD_VAR 0 1
98529: PPUSH
98530: CALL_OW 314
98534: OR
98535: IFFALSE 98539
// exit ;
98537: GO 98980
// x := GetX ( enemy_unit ) ;
98539: LD_ADDR_VAR 0 7
98543: PUSH
98544: LD_VAR 0 2
98548: PPUSH
98549: CALL_OW 250
98553: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
98554: LD_ADDR_VAR 0 8
98558: PUSH
98559: LD_VAR 0 2
98563: PPUSH
98564: CALL_OW 251
98568: ST_TO_ADDR
// if not x or not y then
98569: LD_VAR 0 7
98573: NOT
98574: PUSH
98575: LD_VAR 0 8
98579: NOT
98580: OR
98581: IFFALSE 98585
// exit ;
98583: GO 98980
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
98585: LD_ADDR_VAR 0 6
98589: PUSH
98590: LD_VAR 0 7
98594: PPUSH
98595: LD_INT 0
98597: PPUSH
98598: LD_INT 4
98600: PPUSH
98601: CALL_OW 272
98605: PUSH
98606: LD_VAR 0 8
98610: PPUSH
98611: LD_INT 0
98613: PPUSH
98614: LD_INT 4
98616: PPUSH
98617: CALL_OW 273
98621: PUSH
98622: EMPTY
98623: LIST
98624: LIST
98625: PUSH
98626: LD_VAR 0 7
98630: PPUSH
98631: LD_INT 1
98633: PPUSH
98634: LD_INT 4
98636: PPUSH
98637: CALL_OW 272
98641: PUSH
98642: LD_VAR 0 8
98646: PPUSH
98647: LD_INT 1
98649: PPUSH
98650: LD_INT 4
98652: PPUSH
98653: CALL_OW 273
98657: PUSH
98658: EMPTY
98659: LIST
98660: LIST
98661: PUSH
98662: LD_VAR 0 7
98666: PPUSH
98667: LD_INT 2
98669: PPUSH
98670: LD_INT 4
98672: PPUSH
98673: CALL_OW 272
98677: PUSH
98678: LD_VAR 0 8
98682: PPUSH
98683: LD_INT 2
98685: PPUSH
98686: LD_INT 4
98688: PPUSH
98689: CALL_OW 273
98693: PUSH
98694: EMPTY
98695: LIST
98696: LIST
98697: PUSH
98698: LD_VAR 0 7
98702: PPUSH
98703: LD_INT 3
98705: PPUSH
98706: LD_INT 4
98708: PPUSH
98709: CALL_OW 272
98713: PUSH
98714: LD_VAR 0 8
98718: PPUSH
98719: LD_INT 3
98721: PPUSH
98722: LD_INT 4
98724: PPUSH
98725: CALL_OW 273
98729: PUSH
98730: EMPTY
98731: LIST
98732: LIST
98733: PUSH
98734: LD_VAR 0 7
98738: PPUSH
98739: LD_INT 4
98741: PPUSH
98742: LD_INT 4
98744: PPUSH
98745: CALL_OW 272
98749: PUSH
98750: LD_VAR 0 8
98754: PPUSH
98755: LD_INT 4
98757: PPUSH
98758: LD_INT 4
98760: PPUSH
98761: CALL_OW 273
98765: PUSH
98766: EMPTY
98767: LIST
98768: LIST
98769: PUSH
98770: LD_VAR 0 7
98774: PPUSH
98775: LD_INT 5
98777: PPUSH
98778: LD_INT 4
98780: PPUSH
98781: CALL_OW 272
98785: PUSH
98786: LD_VAR 0 8
98790: PPUSH
98791: LD_INT 5
98793: PPUSH
98794: LD_INT 4
98796: PPUSH
98797: CALL_OW 273
98801: PUSH
98802: EMPTY
98803: LIST
98804: LIST
98805: PUSH
98806: EMPTY
98807: LIST
98808: LIST
98809: LIST
98810: LIST
98811: LIST
98812: LIST
98813: ST_TO_ADDR
// for i = tmp downto 1 do
98814: LD_ADDR_VAR 0 4
98818: PUSH
98819: DOUBLE
98820: LD_VAR 0 6
98824: INC
98825: ST_TO_ADDR
98826: LD_INT 1
98828: PUSH
98829: FOR_DOWNTO
98830: IFFALSE 98931
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
98832: LD_VAR 0 6
98836: PUSH
98837: LD_VAR 0 4
98841: ARRAY
98842: PUSH
98843: LD_INT 1
98845: ARRAY
98846: PPUSH
98847: LD_VAR 0 6
98851: PUSH
98852: LD_VAR 0 4
98856: ARRAY
98857: PUSH
98858: LD_INT 2
98860: ARRAY
98861: PPUSH
98862: CALL_OW 488
98866: NOT
98867: PUSH
98868: LD_VAR 0 6
98872: PUSH
98873: LD_VAR 0 4
98877: ARRAY
98878: PUSH
98879: LD_INT 1
98881: ARRAY
98882: PPUSH
98883: LD_VAR 0 6
98887: PUSH
98888: LD_VAR 0 4
98892: ARRAY
98893: PUSH
98894: LD_INT 2
98896: ARRAY
98897: PPUSH
98898: CALL_OW 428
98902: PUSH
98903: LD_INT 0
98905: NONEQUAL
98906: OR
98907: IFFALSE 98929
// tmp := Delete ( tmp , i ) ;
98909: LD_ADDR_VAR 0 6
98913: PUSH
98914: LD_VAR 0 6
98918: PPUSH
98919: LD_VAR 0 4
98923: PPUSH
98924: CALL_OW 3
98928: ST_TO_ADDR
98929: GO 98829
98931: POP
98932: POP
// j := GetClosestHex ( unit , tmp ) ;
98933: LD_ADDR_VAR 0 5
98937: PUSH
98938: LD_VAR 0 1
98942: PPUSH
98943: LD_VAR 0 6
98947: PPUSH
98948: CALL 98233 0 2
98952: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
98953: LD_VAR 0 1
98957: PPUSH
98958: LD_VAR 0 5
98962: PUSH
98963: LD_INT 1
98965: ARRAY
98966: PPUSH
98967: LD_VAR 0 5
98971: PUSH
98972: LD_INT 2
98974: ARRAY
98975: PPUSH
98976: CALL_OW 111
// end ;
98980: LD_VAR 0 3
98984: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
98985: LD_INT 0
98987: PPUSH
98988: PPUSH
98989: PPUSH
// uc_side = 0 ;
98990: LD_ADDR_OWVAR 20
98994: PUSH
98995: LD_INT 0
98997: ST_TO_ADDR
// uc_nation = 0 ;
98998: LD_ADDR_OWVAR 21
99002: PUSH
99003: LD_INT 0
99005: ST_TO_ADDR
// InitHc_All ( ) ;
99006: CALL_OW 584
// InitVc ;
99010: CALL_OW 20
// if mastodonts then
99014: LD_VAR 0 6
99018: IFFALSE 99085
// for i = 1 to mastodonts do
99020: LD_ADDR_VAR 0 11
99024: PUSH
99025: DOUBLE
99026: LD_INT 1
99028: DEC
99029: ST_TO_ADDR
99030: LD_VAR 0 6
99034: PUSH
99035: FOR_TO
99036: IFFALSE 99083
// begin vc_chassis := 31 ;
99038: LD_ADDR_OWVAR 37
99042: PUSH
99043: LD_INT 31
99045: ST_TO_ADDR
// vc_control := control_rider ;
99046: LD_ADDR_OWVAR 38
99050: PUSH
99051: LD_INT 4
99053: ST_TO_ADDR
// animal := CreateVehicle ;
99054: LD_ADDR_VAR 0 12
99058: PUSH
99059: CALL_OW 45
99063: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99064: LD_VAR 0 12
99068: PPUSH
99069: LD_VAR 0 8
99073: PPUSH
99074: LD_INT 0
99076: PPUSH
99077: CALL 101273 0 3
// end ;
99081: GO 99035
99083: POP
99084: POP
// if horses then
99085: LD_VAR 0 5
99089: IFFALSE 99156
// for i = 1 to horses do
99091: LD_ADDR_VAR 0 11
99095: PUSH
99096: DOUBLE
99097: LD_INT 1
99099: DEC
99100: ST_TO_ADDR
99101: LD_VAR 0 5
99105: PUSH
99106: FOR_TO
99107: IFFALSE 99154
// begin hc_class := 21 ;
99109: LD_ADDR_OWVAR 28
99113: PUSH
99114: LD_INT 21
99116: ST_TO_ADDR
// hc_gallery :=  ;
99117: LD_ADDR_OWVAR 33
99121: PUSH
99122: LD_STRING 
99124: ST_TO_ADDR
// animal := CreateHuman ;
99125: LD_ADDR_VAR 0 12
99129: PUSH
99130: CALL_OW 44
99134: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99135: LD_VAR 0 12
99139: PPUSH
99140: LD_VAR 0 8
99144: PPUSH
99145: LD_INT 0
99147: PPUSH
99148: CALL 101273 0 3
// end ;
99152: GO 99106
99154: POP
99155: POP
// if birds then
99156: LD_VAR 0 1
99160: IFFALSE 99227
// for i = 1 to birds do
99162: LD_ADDR_VAR 0 11
99166: PUSH
99167: DOUBLE
99168: LD_INT 1
99170: DEC
99171: ST_TO_ADDR
99172: LD_VAR 0 1
99176: PUSH
99177: FOR_TO
99178: IFFALSE 99225
// begin hc_class = 18 ;
99180: LD_ADDR_OWVAR 28
99184: PUSH
99185: LD_INT 18
99187: ST_TO_ADDR
// hc_gallery =  ;
99188: LD_ADDR_OWVAR 33
99192: PUSH
99193: LD_STRING 
99195: ST_TO_ADDR
// animal := CreateHuman ;
99196: LD_ADDR_VAR 0 12
99200: PUSH
99201: CALL_OW 44
99205: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99206: LD_VAR 0 12
99210: PPUSH
99211: LD_VAR 0 8
99215: PPUSH
99216: LD_INT 0
99218: PPUSH
99219: CALL 101273 0 3
// end ;
99223: GO 99177
99225: POP
99226: POP
// if tigers then
99227: LD_VAR 0 2
99231: IFFALSE 99315
// for i = 1 to tigers do
99233: LD_ADDR_VAR 0 11
99237: PUSH
99238: DOUBLE
99239: LD_INT 1
99241: DEC
99242: ST_TO_ADDR
99243: LD_VAR 0 2
99247: PUSH
99248: FOR_TO
99249: IFFALSE 99313
// begin hc_class = class_tiger ;
99251: LD_ADDR_OWVAR 28
99255: PUSH
99256: LD_INT 14
99258: ST_TO_ADDR
// hc_gallery =  ;
99259: LD_ADDR_OWVAR 33
99263: PUSH
99264: LD_STRING 
99266: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
99267: LD_ADDR_OWVAR 35
99271: PUSH
99272: LD_INT 7
99274: NEG
99275: PPUSH
99276: LD_INT 7
99278: PPUSH
99279: CALL_OW 12
99283: ST_TO_ADDR
// animal := CreateHuman ;
99284: LD_ADDR_VAR 0 12
99288: PUSH
99289: CALL_OW 44
99293: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99294: LD_VAR 0 12
99298: PPUSH
99299: LD_VAR 0 8
99303: PPUSH
99304: LD_INT 0
99306: PPUSH
99307: CALL 101273 0 3
// end ;
99311: GO 99248
99313: POP
99314: POP
// if apemans then
99315: LD_VAR 0 3
99319: IFFALSE 99442
// for i = 1 to apemans do
99321: LD_ADDR_VAR 0 11
99325: PUSH
99326: DOUBLE
99327: LD_INT 1
99329: DEC
99330: ST_TO_ADDR
99331: LD_VAR 0 3
99335: PUSH
99336: FOR_TO
99337: IFFALSE 99440
// begin hc_class = class_apeman ;
99339: LD_ADDR_OWVAR 28
99343: PUSH
99344: LD_INT 12
99346: ST_TO_ADDR
// hc_gallery =  ;
99347: LD_ADDR_OWVAR 33
99351: PUSH
99352: LD_STRING 
99354: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
99355: LD_ADDR_OWVAR 35
99359: PUSH
99360: LD_INT 2
99362: NEG
99363: PPUSH
99364: LD_INT 2
99366: PPUSH
99367: CALL_OW 12
99371: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
99372: LD_ADDR_OWVAR 31
99376: PUSH
99377: LD_INT 1
99379: PPUSH
99380: LD_INT 3
99382: PPUSH
99383: CALL_OW 12
99387: PUSH
99388: LD_INT 1
99390: PPUSH
99391: LD_INT 3
99393: PPUSH
99394: CALL_OW 12
99398: PUSH
99399: LD_INT 0
99401: PUSH
99402: LD_INT 0
99404: PUSH
99405: EMPTY
99406: LIST
99407: LIST
99408: LIST
99409: LIST
99410: ST_TO_ADDR
// animal := CreateHuman ;
99411: LD_ADDR_VAR 0 12
99415: PUSH
99416: CALL_OW 44
99420: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99421: LD_VAR 0 12
99425: PPUSH
99426: LD_VAR 0 8
99430: PPUSH
99431: LD_INT 0
99433: PPUSH
99434: CALL 101273 0 3
// end ;
99438: GO 99336
99440: POP
99441: POP
// if enchidnas then
99442: LD_VAR 0 4
99446: IFFALSE 99513
// for i = 1 to enchidnas do
99448: LD_ADDR_VAR 0 11
99452: PUSH
99453: DOUBLE
99454: LD_INT 1
99456: DEC
99457: ST_TO_ADDR
99458: LD_VAR 0 4
99462: PUSH
99463: FOR_TO
99464: IFFALSE 99511
// begin hc_class = 13 ;
99466: LD_ADDR_OWVAR 28
99470: PUSH
99471: LD_INT 13
99473: ST_TO_ADDR
// hc_gallery =  ;
99474: LD_ADDR_OWVAR 33
99478: PUSH
99479: LD_STRING 
99481: ST_TO_ADDR
// animal := CreateHuman ;
99482: LD_ADDR_VAR 0 12
99486: PUSH
99487: CALL_OW 44
99491: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99492: LD_VAR 0 12
99496: PPUSH
99497: LD_VAR 0 8
99501: PPUSH
99502: LD_INT 0
99504: PPUSH
99505: CALL 101273 0 3
// end ;
99509: GO 99463
99511: POP
99512: POP
// if fishes then
99513: LD_VAR 0 7
99517: IFFALSE 99584
// for i = 1 to fishes do
99519: LD_ADDR_VAR 0 11
99523: PUSH
99524: DOUBLE
99525: LD_INT 1
99527: DEC
99528: ST_TO_ADDR
99529: LD_VAR 0 7
99533: PUSH
99534: FOR_TO
99535: IFFALSE 99582
// begin hc_class = 20 ;
99537: LD_ADDR_OWVAR 28
99541: PUSH
99542: LD_INT 20
99544: ST_TO_ADDR
// hc_gallery =  ;
99545: LD_ADDR_OWVAR 33
99549: PUSH
99550: LD_STRING 
99552: ST_TO_ADDR
// animal := CreateHuman ;
99553: LD_ADDR_VAR 0 12
99557: PUSH
99558: CALL_OW 44
99562: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
99563: LD_VAR 0 12
99567: PPUSH
99568: LD_VAR 0 9
99572: PPUSH
99573: LD_INT 0
99575: PPUSH
99576: CALL 101273 0 3
// end ;
99580: GO 99534
99582: POP
99583: POP
// end ;
99584: LD_VAR 0 10
99588: RET
// export function WantHeal ( sci , unit ) ; begin
99589: LD_INT 0
99591: PPUSH
// if GetTaskList ( sci ) > 0 then
99592: LD_VAR 0 1
99596: PPUSH
99597: CALL_OW 437
99601: PUSH
99602: LD_INT 0
99604: GREATER
99605: IFFALSE 99675
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
99607: LD_VAR 0 1
99611: PPUSH
99612: CALL_OW 437
99616: PUSH
99617: LD_INT 1
99619: ARRAY
99620: PUSH
99621: LD_INT 1
99623: ARRAY
99624: PUSH
99625: LD_STRING l
99627: EQUAL
99628: PUSH
99629: LD_VAR 0 1
99633: PPUSH
99634: CALL_OW 437
99638: PUSH
99639: LD_INT 1
99641: ARRAY
99642: PUSH
99643: LD_INT 4
99645: ARRAY
99646: PUSH
99647: LD_VAR 0 2
99651: EQUAL
99652: AND
99653: IFFALSE 99665
// result := true else
99655: LD_ADDR_VAR 0 3
99659: PUSH
99660: LD_INT 1
99662: ST_TO_ADDR
99663: GO 99673
// result := false ;
99665: LD_ADDR_VAR 0 3
99669: PUSH
99670: LD_INT 0
99672: ST_TO_ADDR
// end else
99673: GO 99683
// result := false ;
99675: LD_ADDR_VAR 0 3
99679: PUSH
99680: LD_INT 0
99682: ST_TO_ADDR
// end ;
99683: LD_VAR 0 3
99687: RET
// export function HealTarget ( sci ) ; begin
99688: LD_INT 0
99690: PPUSH
// if not sci then
99691: LD_VAR 0 1
99695: NOT
99696: IFFALSE 99700
// exit ;
99698: GO 99765
// result := 0 ;
99700: LD_ADDR_VAR 0 2
99704: PUSH
99705: LD_INT 0
99707: ST_TO_ADDR
// if GetTaskList ( sci ) then
99708: LD_VAR 0 1
99712: PPUSH
99713: CALL_OW 437
99717: IFFALSE 99765
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
99719: LD_VAR 0 1
99723: PPUSH
99724: CALL_OW 437
99728: PUSH
99729: LD_INT 1
99731: ARRAY
99732: PUSH
99733: LD_INT 1
99735: ARRAY
99736: PUSH
99737: LD_STRING l
99739: EQUAL
99740: IFFALSE 99765
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
99742: LD_ADDR_VAR 0 2
99746: PUSH
99747: LD_VAR 0 1
99751: PPUSH
99752: CALL_OW 437
99756: PUSH
99757: LD_INT 1
99759: ARRAY
99760: PUSH
99761: LD_INT 4
99763: ARRAY
99764: ST_TO_ADDR
// end ;
99765: LD_VAR 0 2
99769: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
99770: LD_INT 0
99772: PPUSH
99773: PPUSH
99774: PPUSH
99775: PPUSH
// if not base_units then
99776: LD_VAR 0 1
99780: NOT
99781: IFFALSE 99785
// exit ;
99783: GO 99872
// result := false ;
99785: LD_ADDR_VAR 0 2
99789: PUSH
99790: LD_INT 0
99792: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
99793: LD_ADDR_VAR 0 5
99797: PUSH
99798: LD_VAR 0 1
99802: PPUSH
99803: LD_INT 21
99805: PUSH
99806: LD_INT 3
99808: PUSH
99809: EMPTY
99810: LIST
99811: LIST
99812: PPUSH
99813: CALL_OW 72
99817: ST_TO_ADDR
// if not tmp then
99818: LD_VAR 0 5
99822: NOT
99823: IFFALSE 99827
// exit ;
99825: GO 99872
// for i in tmp do
99827: LD_ADDR_VAR 0 3
99831: PUSH
99832: LD_VAR 0 5
99836: PUSH
99837: FOR_IN
99838: IFFALSE 99870
// begin result := EnemyInRange ( i , 22 ) ;
99840: LD_ADDR_VAR 0 2
99844: PUSH
99845: LD_VAR 0 3
99849: PPUSH
99850: LD_INT 22
99852: PPUSH
99853: CALL 98108 0 2
99857: ST_TO_ADDR
// if result then
99858: LD_VAR 0 2
99862: IFFALSE 99868
// exit ;
99864: POP
99865: POP
99866: GO 99872
// end ;
99868: GO 99837
99870: POP
99871: POP
// end ;
99872: LD_VAR 0 2
99876: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
99877: LD_INT 0
99879: PPUSH
99880: PPUSH
// if not units then
99881: LD_VAR 0 1
99885: NOT
99886: IFFALSE 99890
// exit ;
99888: GO 99960
// result := [ ] ;
99890: LD_ADDR_VAR 0 3
99894: PUSH
99895: EMPTY
99896: ST_TO_ADDR
// for i in units do
99897: LD_ADDR_VAR 0 4
99901: PUSH
99902: LD_VAR 0 1
99906: PUSH
99907: FOR_IN
99908: IFFALSE 99958
// if GetTag ( i ) = tag then
99910: LD_VAR 0 4
99914: PPUSH
99915: CALL_OW 110
99919: PUSH
99920: LD_VAR 0 2
99924: EQUAL
99925: IFFALSE 99956
// result := Replace ( result , result + 1 , i ) ;
99927: LD_ADDR_VAR 0 3
99931: PUSH
99932: LD_VAR 0 3
99936: PPUSH
99937: LD_VAR 0 3
99941: PUSH
99942: LD_INT 1
99944: PLUS
99945: PPUSH
99946: LD_VAR 0 4
99950: PPUSH
99951: CALL_OW 1
99955: ST_TO_ADDR
99956: GO 99907
99958: POP
99959: POP
// end ;
99960: LD_VAR 0 3
99964: RET
// export function IsDriver ( un ) ; begin
99965: LD_INT 0
99967: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
99968: LD_ADDR_VAR 0 2
99972: PUSH
99973: LD_VAR 0 1
99977: PUSH
99978: LD_INT 55
99980: PUSH
99981: EMPTY
99982: LIST
99983: PPUSH
99984: CALL_OW 69
99988: IN
99989: ST_TO_ADDR
// end ;
99990: LD_VAR 0 2
99994: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
99995: LD_INT 0
99997: PPUSH
99998: PPUSH
// list := [ ] ;
99999: LD_ADDR_VAR 0 5
100003: PUSH
100004: EMPTY
100005: ST_TO_ADDR
// case d of 0 :
100006: LD_VAR 0 3
100010: PUSH
100011: LD_INT 0
100013: DOUBLE
100014: EQUAL
100015: IFTRUE 100019
100017: GO 100152
100019: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
100020: LD_ADDR_VAR 0 5
100024: PUSH
100025: LD_VAR 0 1
100029: PUSH
100030: LD_INT 4
100032: MINUS
100033: PUSH
100034: LD_VAR 0 2
100038: PUSH
100039: LD_INT 4
100041: MINUS
100042: PUSH
100043: LD_INT 2
100045: PUSH
100046: EMPTY
100047: LIST
100048: LIST
100049: LIST
100050: PUSH
100051: LD_VAR 0 1
100055: PUSH
100056: LD_INT 3
100058: MINUS
100059: PUSH
100060: LD_VAR 0 2
100064: PUSH
100065: LD_INT 1
100067: PUSH
100068: EMPTY
100069: LIST
100070: LIST
100071: LIST
100072: PUSH
100073: LD_VAR 0 1
100077: PUSH
100078: LD_INT 4
100080: PLUS
100081: PUSH
100082: LD_VAR 0 2
100086: PUSH
100087: LD_INT 4
100089: PUSH
100090: EMPTY
100091: LIST
100092: LIST
100093: LIST
100094: PUSH
100095: LD_VAR 0 1
100099: PUSH
100100: LD_INT 3
100102: PLUS
100103: PUSH
100104: LD_VAR 0 2
100108: PUSH
100109: LD_INT 3
100111: PLUS
100112: PUSH
100113: LD_INT 5
100115: PUSH
100116: EMPTY
100117: LIST
100118: LIST
100119: LIST
100120: PUSH
100121: LD_VAR 0 1
100125: PUSH
100126: LD_VAR 0 2
100130: PUSH
100131: LD_INT 4
100133: PLUS
100134: PUSH
100135: LD_INT 0
100137: PUSH
100138: EMPTY
100139: LIST
100140: LIST
100141: LIST
100142: PUSH
100143: EMPTY
100144: LIST
100145: LIST
100146: LIST
100147: LIST
100148: LIST
100149: ST_TO_ADDR
// end ; 1 :
100150: GO 100850
100152: LD_INT 1
100154: DOUBLE
100155: EQUAL
100156: IFTRUE 100160
100158: GO 100293
100160: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
100161: LD_ADDR_VAR 0 5
100165: PUSH
100166: LD_VAR 0 1
100170: PUSH
100171: LD_VAR 0 2
100175: PUSH
100176: LD_INT 4
100178: MINUS
100179: PUSH
100180: LD_INT 3
100182: PUSH
100183: EMPTY
100184: LIST
100185: LIST
100186: LIST
100187: PUSH
100188: LD_VAR 0 1
100192: PUSH
100193: LD_INT 3
100195: MINUS
100196: PUSH
100197: LD_VAR 0 2
100201: PUSH
100202: LD_INT 3
100204: MINUS
100205: PUSH
100206: LD_INT 2
100208: PUSH
100209: EMPTY
100210: LIST
100211: LIST
100212: LIST
100213: PUSH
100214: LD_VAR 0 1
100218: PUSH
100219: LD_INT 4
100221: MINUS
100222: PUSH
100223: LD_VAR 0 2
100227: PUSH
100228: LD_INT 1
100230: PUSH
100231: EMPTY
100232: LIST
100233: LIST
100234: LIST
100235: PUSH
100236: LD_VAR 0 1
100240: PUSH
100241: LD_VAR 0 2
100245: PUSH
100246: LD_INT 3
100248: PLUS
100249: PUSH
100250: LD_INT 0
100252: PUSH
100253: EMPTY
100254: LIST
100255: LIST
100256: LIST
100257: PUSH
100258: LD_VAR 0 1
100262: PUSH
100263: LD_INT 4
100265: PLUS
100266: PUSH
100267: LD_VAR 0 2
100271: PUSH
100272: LD_INT 4
100274: PLUS
100275: PUSH
100276: LD_INT 5
100278: PUSH
100279: EMPTY
100280: LIST
100281: LIST
100282: LIST
100283: PUSH
100284: EMPTY
100285: LIST
100286: LIST
100287: LIST
100288: LIST
100289: LIST
100290: ST_TO_ADDR
// end ; 2 :
100291: GO 100850
100293: LD_INT 2
100295: DOUBLE
100296: EQUAL
100297: IFTRUE 100301
100299: GO 100430
100301: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
100302: LD_ADDR_VAR 0 5
100306: PUSH
100307: LD_VAR 0 1
100311: PUSH
100312: LD_VAR 0 2
100316: PUSH
100317: LD_INT 3
100319: MINUS
100320: PUSH
100321: LD_INT 3
100323: PUSH
100324: EMPTY
100325: LIST
100326: LIST
100327: LIST
100328: PUSH
100329: LD_VAR 0 1
100333: PUSH
100334: LD_INT 4
100336: PLUS
100337: PUSH
100338: LD_VAR 0 2
100342: PUSH
100343: LD_INT 4
100345: PUSH
100346: EMPTY
100347: LIST
100348: LIST
100349: LIST
100350: PUSH
100351: LD_VAR 0 1
100355: PUSH
100356: LD_VAR 0 2
100360: PUSH
100361: LD_INT 4
100363: PLUS
100364: PUSH
100365: LD_INT 0
100367: PUSH
100368: EMPTY
100369: LIST
100370: LIST
100371: LIST
100372: PUSH
100373: LD_VAR 0 1
100377: PUSH
100378: LD_INT 3
100380: MINUS
100381: PUSH
100382: LD_VAR 0 2
100386: PUSH
100387: LD_INT 1
100389: PUSH
100390: EMPTY
100391: LIST
100392: LIST
100393: LIST
100394: PUSH
100395: LD_VAR 0 1
100399: PUSH
100400: LD_INT 4
100402: MINUS
100403: PUSH
100404: LD_VAR 0 2
100408: PUSH
100409: LD_INT 4
100411: MINUS
100412: PUSH
100413: LD_INT 2
100415: PUSH
100416: EMPTY
100417: LIST
100418: LIST
100419: LIST
100420: PUSH
100421: EMPTY
100422: LIST
100423: LIST
100424: LIST
100425: LIST
100426: LIST
100427: ST_TO_ADDR
// end ; 3 :
100428: GO 100850
100430: LD_INT 3
100432: DOUBLE
100433: EQUAL
100434: IFTRUE 100438
100436: GO 100571
100438: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
100439: LD_ADDR_VAR 0 5
100443: PUSH
100444: LD_VAR 0 1
100448: PUSH
100449: LD_INT 3
100451: PLUS
100452: PUSH
100453: LD_VAR 0 2
100457: PUSH
100458: LD_INT 4
100460: PUSH
100461: EMPTY
100462: LIST
100463: LIST
100464: LIST
100465: PUSH
100466: LD_VAR 0 1
100470: PUSH
100471: LD_INT 4
100473: PLUS
100474: PUSH
100475: LD_VAR 0 2
100479: PUSH
100480: LD_INT 4
100482: PLUS
100483: PUSH
100484: LD_INT 5
100486: PUSH
100487: EMPTY
100488: LIST
100489: LIST
100490: LIST
100491: PUSH
100492: LD_VAR 0 1
100496: PUSH
100497: LD_INT 4
100499: MINUS
100500: PUSH
100501: LD_VAR 0 2
100505: PUSH
100506: LD_INT 1
100508: PUSH
100509: EMPTY
100510: LIST
100511: LIST
100512: LIST
100513: PUSH
100514: LD_VAR 0 1
100518: PUSH
100519: LD_VAR 0 2
100523: PUSH
100524: LD_INT 4
100526: MINUS
100527: PUSH
100528: LD_INT 3
100530: PUSH
100531: EMPTY
100532: LIST
100533: LIST
100534: LIST
100535: PUSH
100536: LD_VAR 0 1
100540: PUSH
100541: LD_INT 3
100543: MINUS
100544: PUSH
100545: LD_VAR 0 2
100549: PUSH
100550: LD_INT 3
100552: MINUS
100553: PUSH
100554: LD_INT 2
100556: PUSH
100557: EMPTY
100558: LIST
100559: LIST
100560: LIST
100561: PUSH
100562: EMPTY
100563: LIST
100564: LIST
100565: LIST
100566: LIST
100567: LIST
100568: ST_TO_ADDR
// end ; 4 :
100569: GO 100850
100571: LD_INT 4
100573: DOUBLE
100574: EQUAL
100575: IFTRUE 100579
100577: GO 100712
100579: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
100580: LD_ADDR_VAR 0 5
100584: PUSH
100585: LD_VAR 0 1
100589: PUSH
100590: LD_VAR 0 2
100594: PUSH
100595: LD_INT 4
100597: PLUS
100598: PUSH
100599: LD_INT 0
100601: PUSH
100602: EMPTY
100603: LIST
100604: LIST
100605: LIST
100606: PUSH
100607: LD_VAR 0 1
100611: PUSH
100612: LD_INT 3
100614: PLUS
100615: PUSH
100616: LD_VAR 0 2
100620: PUSH
100621: LD_INT 3
100623: PLUS
100624: PUSH
100625: LD_INT 5
100627: PUSH
100628: EMPTY
100629: LIST
100630: LIST
100631: LIST
100632: PUSH
100633: LD_VAR 0 1
100637: PUSH
100638: LD_INT 4
100640: PLUS
100641: PUSH
100642: LD_VAR 0 2
100646: PUSH
100647: LD_INT 4
100649: PUSH
100650: EMPTY
100651: LIST
100652: LIST
100653: LIST
100654: PUSH
100655: LD_VAR 0 1
100659: PUSH
100660: LD_VAR 0 2
100664: PUSH
100665: LD_INT 3
100667: MINUS
100668: PUSH
100669: LD_INT 3
100671: PUSH
100672: EMPTY
100673: LIST
100674: LIST
100675: LIST
100676: PUSH
100677: LD_VAR 0 1
100681: PUSH
100682: LD_INT 4
100684: MINUS
100685: PUSH
100686: LD_VAR 0 2
100690: PUSH
100691: LD_INT 4
100693: MINUS
100694: PUSH
100695: LD_INT 2
100697: PUSH
100698: EMPTY
100699: LIST
100700: LIST
100701: LIST
100702: PUSH
100703: EMPTY
100704: LIST
100705: LIST
100706: LIST
100707: LIST
100708: LIST
100709: ST_TO_ADDR
// end ; 5 :
100710: GO 100850
100712: LD_INT 5
100714: DOUBLE
100715: EQUAL
100716: IFTRUE 100720
100718: GO 100849
100720: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
100721: LD_ADDR_VAR 0 5
100725: PUSH
100726: LD_VAR 0 1
100730: PUSH
100731: LD_INT 4
100733: MINUS
100734: PUSH
100735: LD_VAR 0 2
100739: PUSH
100740: LD_INT 1
100742: PUSH
100743: EMPTY
100744: LIST
100745: LIST
100746: LIST
100747: PUSH
100748: LD_VAR 0 1
100752: PUSH
100753: LD_VAR 0 2
100757: PUSH
100758: LD_INT 4
100760: MINUS
100761: PUSH
100762: LD_INT 3
100764: PUSH
100765: EMPTY
100766: LIST
100767: LIST
100768: LIST
100769: PUSH
100770: LD_VAR 0 1
100774: PUSH
100775: LD_INT 4
100777: PLUS
100778: PUSH
100779: LD_VAR 0 2
100783: PUSH
100784: LD_INT 4
100786: PLUS
100787: PUSH
100788: LD_INT 5
100790: PUSH
100791: EMPTY
100792: LIST
100793: LIST
100794: LIST
100795: PUSH
100796: LD_VAR 0 1
100800: PUSH
100801: LD_INT 3
100803: PLUS
100804: PUSH
100805: LD_VAR 0 2
100809: PUSH
100810: LD_INT 4
100812: PUSH
100813: EMPTY
100814: LIST
100815: LIST
100816: LIST
100817: PUSH
100818: LD_VAR 0 1
100822: PUSH
100823: LD_VAR 0 2
100827: PUSH
100828: LD_INT 3
100830: PLUS
100831: PUSH
100832: LD_INT 0
100834: PUSH
100835: EMPTY
100836: LIST
100837: LIST
100838: LIST
100839: PUSH
100840: EMPTY
100841: LIST
100842: LIST
100843: LIST
100844: LIST
100845: LIST
100846: ST_TO_ADDR
// end ; end ;
100847: GO 100850
100849: POP
// result := list ;
100850: LD_ADDR_VAR 0 4
100854: PUSH
100855: LD_VAR 0 5
100859: ST_TO_ADDR
// end ;
100860: LD_VAR 0 4
100864: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
100865: LD_INT 0
100867: PPUSH
100868: PPUSH
100869: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
100870: LD_VAR 0 1
100874: NOT
100875: PUSH
100876: LD_VAR 0 2
100880: PUSH
100881: LD_INT 1
100883: PUSH
100884: LD_INT 2
100886: PUSH
100887: LD_INT 3
100889: PUSH
100890: LD_INT 4
100892: PUSH
100893: EMPTY
100894: LIST
100895: LIST
100896: LIST
100897: LIST
100898: IN
100899: NOT
100900: OR
100901: IFFALSE 100905
// exit ;
100903: GO 100997
// tmp := [ ] ;
100905: LD_ADDR_VAR 0 5
100909: PUSH
100910: EMPTY
100911: ST_TO_ADDR
// for i in units do
100912: LD_ADDR_VAR 0 4
100916: PUSH
100917: LD_VAR 0 1
100921: PUSH
100922: FOR_IN
100923: IFFALSE 100966
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
100925: LD_ADDR_VAR 0 5
100929: PUSH
100930: LD_VAR 0 5
100934: PPUSH
100935: LD_VAR 0 5
100939: PUSH
100940: LD_INT 1
100942: PLUS
100943: PPUSH
100944: LD_VAR 0 4
100948: PPUSH
100949: LD_VAR 0 2
100953: PPUSH
100954: CALL_OW 259
100958: PPUSH
100959: CALL_OW 2
100963: ST_TO_ADDR
100964: GO 100922
100966: POP
100967: POP
// if not tmp then
100968: LD_VAR 0 5
100972: NOT
100973: IFFALSE 100977
// exit ;
100975: GO 100997
// result := SortListByListDesc ( units , tmp ) ;
100977: LD_ADDR_VAR 0 3
100981: PUSH
100982: LD_VAR 0 1
100986: PPUSH
100987: LD_VAR 0 5
100991: PPUSH
100992: CALL_OW 77
100996: ST_TO_ADDR
// end ;
100997: LD_VAR 0 3
101001: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
101002: LD_INT 0
101004: PPUSH
101005: PPUSH
101006: PPUSH
// result := false ;
101007: LD_ADDR_VAR 0 3
101011: PUSH
101012: LD_INT 0
101014: ST_TO_ADDR
// x := GetX ( building ) ;
101015: LD_ADDR_VAR 0 4
101019: PUSH
101020: LD_VAR 0 2
101024: PPUSH
101025: CALL_OW 250
101029: ST_TO_ADDR
// y := GetY ( building ) ;
101030: LD_ADDR_VAR 0 5
101034: PUSH
101035: LD_VAR 0 2
101039: PPUSH
101040: CALL_OW 251
101044: ST_TO_ADDR
// if not building or not x or not y then
101045: LD_VAR 0 2
101049: NOT
101050: PUSH
101051: LD_VAR 0 4
101055: NOT
101056: OR
101057: PUSH
101058: LD_VAR 0 5
101062: NOT
101063: OR
101064: IFFALSE 101068
// exit ;
101066: GO 101160
// if GetTaskList ( unit ) then
101068: LD_VAR 0 1
101072: PPUSH
101073: CALL_OW 437
101077: IFFALSE 101160
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
101079: LD_STRING e
101081: PUSH
101082: LD_VAR 0 1
101086: PPUSH
101087: CALL_OW 437
101091: PUSH
101092: LD_INT 1
101094: ARRAY
101095: PUSH
101096: LD_INT 1
101098: ARRAY
101099: EQUAL
101100: PUSH
101101: LD_VAR 0 4
101105: PUSH
101106: LD_VAR 0 1
101110: PPUSH
101111: CALL_OW 437
101115: PUSH
101116: LD_INT 1
101118: ARRAY
101119: PUSH
101120: LD_INT 2
101122: ARRAY
101123: EQUAL
101124: AND
101125: PUSH
101126: LD_VAR 0 5
101130: PUSH
101131: LD_VAR 0 1
101135: PPUSH
101136: CALL_OW 437
101140: PUSH
101141: LD_INT 1
101143: ARRAY
101144: PUSH
101145: LD_INT 3
101147: ARRAY
101148: EQUAL
101149: AND
101150: IFFALSE 101160
// result := true end ;
101152: LD_ADDR_VAR 0 3
101156: PUSH
101157: LD_INT 1
101159: ST_TO_ADDR
// end ;
101160: LD_VAR 0 3
101164: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
101165: LD_INT 0
101167: PPUSH
// result := false ;
101168: LD_ADDR_VAR 0 4
101172: PUSH
101173: LD_INT 0
101175: ST_TO_ADDR
// if GetTaskList ( unit ) then
101176: LD_VAR 0 1
101180: PPUSH
101181: CALL_OW 437
101185: IFFALSE 101268
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
101187: LD_STRING M
101189: PUSH
101190: LD_VAR 0 1
101194: PPUSH
101195: CALL_OW 437
101199: PUSH
101200: LD_INT 1
101202: ARRAY
101203: PUSH
101204: LD_INT 1
101206: ARRAY
101207: EQUAL
101208: PUSH
101209: LD_VAR 0 2
101213: PUSH
101214: LD_VAR 0 1
101218: PPUSH
101219: CALL_OW 437
101223: PUSH
101224: LD_INT 1
101226: ARRAY
101227: PUSH
101228: LD_INT 2
101230: ARRAY
101231: EQUAL
101232: AND
101233: PUSH
101234: LD_VAR 0 3
101238: PUSH
101239: LD_VAR 0 1
101243: PPUSH
101244: CALL_OW 437
101248: PUSH
101249: LD_INT 1
101251: ARRAY
101252: PUSH
101253: LD_INT 3
101255: ARRAY
101256: EQUAL
101257: AND
101258: IFFALSE 101268
// result := true ;
101260: LD_ADDR_VAR 0 4
101264: PUSH
101265: LD_INT 1
101267: ST_TO_ADDR
// end ; end ;
101268: LD_VAR 0 4
101272: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
101273: LD_INT 0
101275: PPUSH
101276: PPUSH
101277: PPUSH
101278: PPUSH
// if not unit or not area then
101279: LD_VAR 0 1
101283: NOT
101284: PUSH
101285: LD_VAR 0 2
101289: NOT
101290: OR
101291: IFFALSE 101295
// exit ;
101293: GO 101459
// tmp := AreaToList ( area , i ) ;
101295: LD_ADDR_VAR 0 6
101299: PUSH
101300: LD_VAR 0 2
101304: PPUSH
101305: LD_VAR 0 5
101309: PPUSH
101310: CALL_OW 517
101314: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
101315: LD_ADDR_VAR 0 5
101319: PUSH
101320: DOUBLE
101321: LD_INT 1
101323: DEC
101324: ST_TO_ADDR
101325: LD_VAR 0 6
101329: PUSH
101330: LD_INT 1
101332: ARRAY
101333: PUSH
101334: FOR_TO
101335: IFFALSE 101457
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
101337: LD_ADDR_VAR 0 7
101341: PUSH
101342: LD_VAR 0 6
101346: PUSH
101347: LD_INT 1
101349: ARRAY
101350: PUSH
101351: LD_VAR 0 5
101355: ARRAY
101356: PUSH
101357: LD_VAR 0 6
101361: PUSH
101362: LD_INT 2
101364: ARRAY
101365: PUSH
101366: LD_VAR 0 5
101370: ARRAY
101371: PUSH
101372: EMPTY
101373: LIST
101374: LIST
101375: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
101376: LD_VAR 0 7
101380: PUSH
101381: LD_INT 1
101383: ARRAY
101384: PPUSH
101385: LD_VAR 0 7
101389: PUSH
101390: LD_INT 2
101392: ARRAY
101393: PPUSH
101394: CALL_OW 428
101398: PUSH
101399: LD_INT 0
101401: EQUAL
101402: IFFALSE 101455
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
101404: LD_VAR 0 1
101408: PPUSH
101409: LD_VAR 0 7
101413: PUSH
101414: LD_INT 1
101416: ARRAY
101417: PPUSH
101418: LD_VAR 0 7
101422: PUSH
101423: LD_INT 2
101425: ARRAY
101426: PPUSH
101427: LD_VAR 0 3
101431: PPUSH
101432: CALL_OW 48
// result := IsPlaced ( unit ) ;
101436: LD_ADDR_VAR 0 4
101440: PUSH
101441: LD_VAR 0 1
101445: PPUSH
101446: CALL_OW 305
101450: ST_TO_ADDR
// exit ;
101451: POP
101452: POP
101453: GO 101459
// end ; end ;
101455: GO 101334
101457: POP
101458: POP
// end ;
101459: LD_VAR 0 4
101463: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
101464: LD_INT 0
101466: PPUSH
101467: PPUSH
101468: PPUSH
// if not side or side > 8 then
101469: LD_VAR 0 1
101473: NOT
101474: PUSH
101475: LD_VAR 0 1
101479: PUSH
101480: LD_INT 8
101482: GREATER
101483: OR
101484: IFFALSE 101488
// exit ;
101486: GO 101675
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
101488: LD_ADDR_VAR 0 4
101492: PUSH
101493: LD_INT 22
101495: PUSH
101496: LD_VAR 0 1
101500: PUSH
101501: EMPTY
101502: LIST
101503: LIST
101504: PUSH
101505: LD_INT 21
101507: PUSH
101508: LD_INT 3
101510: PUSH
101511: EMPTY
101512: LIST
101513: LIST
101514: PUSH
101515: EMPTY
101516: LIST
101517: LIST
101518: PPUSH
101519: CALL_OW 69
101523: ST_TO_ADDR
// if not tmp then
101524: LD_VAR 0 4
101528: NOT
101529: IFFALSE 101533
// exit ;
101531: GO 101675
// enable_addtolog := true ;
101533: LD_ADDR_OWVAR 81
101537: PUSH
101538: LD_INT 1
101540: ST_TO_ADDR
// AddToLog ( [ ) ;
101541: LD_STRING [
101543: PPUSH
101544: CALL_OW 561
// for i in tmp do
101548: LD_ADDR_VAR 0 3
101552: PUSH
101553: LD_VAR 0 4
101557: PUSH
101558: FOR_IN
101559: IFFALSE 101666
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
101561: LD_STRING [
101563: PUSH
101564: LD_VAR 0 3
101568: PPUSH
101569: CALL_OW 266
101573: STR
101574: PUSH
101575: LD_STRING , 
101577: STR
101578: PUSH
101579: LD_VAR 0 3
101583: PPUSH
101584: CALL_OW 250
101588: STR
101589: PUSH
101590: LD_STRING , 
101592: STR
101593: PUSH
101594: LD_VAR 0 3
101598: PPUSH
101599: CALL_OW 251
101603: STR
101604: PUSH
101605: LD_STRING , 
101607: STR
101608: PUSH
101609: LD_VAR 0 3
101613: PPUSH
101614: CALL_OW 254
101618: STR
101619: PUSH
101620: LD_STRING , 
101622: STR
101623: PUSH
101624: LD_VAR 0 3
101628: PPUSH
101629: LD_INT 1
101631: PPUSH
101632: CALL_OW 268
101636: STR
101637: PUSH
101638: LD_STRING , 
101640: STR
101641: PUSH
101642: LD_VAR 0 3
101646: PPUSH
101647: LD_INT 2
101649: PPUSH
101650: CALL_OW 268
101654: STR
101655: PUSH
101656: LD_STRING ],
101658: STR
101659: PPUSH
101660: CALL_OW 561
// end ;
101664: GO 101558
101666: POP
101667: POP
// AddToLog ( ]; ) ;
101668: LD_STRING ];
101670: PPUSH
101671: CALL_OW 561
// end ;
101675: LD_VAR 0 2
101679: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
101680: LD_INT 0
101682: PPUSH
101683: PPUSH
101684: PPUSH
101685: PPUSH
101686: PPUSH
// if not area or not rate or not max then
101687: LD_VAR 0 1
101691: NOT
101692: PUSH
101693: LD_VAR 0 2
101697: NOT
101698: OR
101699: PUSH
101700: LD_VAR 0 4
101704: NOT
101705: OR
101706: IFFALSE 101710
// exit ;
101708: GO 101902
// while 1 do
101710: LD_INT 1
101712: IFFALSE 101902
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
101714: LD_ADDR_VAR 0 9
101718: PUSH
101719: LD_VAR 0 1
101723: PPUSH
101724: LD_INT 1
101726: PPUSH
101727: CALL_OW 287
101731: PUSH
101732: LD_INT 10
101734: MUL
101735: ST_TO_ADDR
// r := rate / 10 ;
101736: LD_ADDR_VAR 0 7
101740: PUSH
101741: LD_VAR 0 2
101745: PUSH
101746: LD_INT 10
101748: DIVREAL
101749: ST_TO_ADDR
// time := 1 1$00 ;
101750: LD_ADDR_VAR 0 8
101754: PUSH
101755: LD_INT 2100
101757: ST_TO_ADDR
// if amount < min then
101758: LD_VAR 0 9
101762: PUSH
101763: LD_VAR 0 3
101767: LESS
101768: IFFALSE 101786
// r := r * 2 else
101770: LD_ADDR_VAR 0 7
101774: PUSH
101775: LD_VAR 0 7
101779: PUSH
101780: LD_INT 2
101782: MUL
101783: ST_TO_ADDR
101784: GO 101812
// if amount > max then
101786: LD_VAR 0 9
101790: PUSH
101791: LD_VAR 0 4
101795: GREATER
101796: IFFALSE 101812
// r := r / 2 ;
101798: LD_ADDR_VAR 0 7
101802: PUSH
101803: LD_VAR 0 7
101807: PUSH
101808: LD_INT 2
101810: DIVREAL
101811: ST_TO_ADDR
// time := time / r ;
101812: LD_ADDR_VAR 0 8
101816: PUSH
101817: LD_VAR 0 8
101821: PUSH
101822: LD_VAR 0 7
101826: DIVREAL
101827: ST_TO_ADDR
// if time < 0 then
101828: LD_VAR 0 8
101832: PUSH
101833: LD_INT 0
101835: LESS
101836: IFFALSE 101853
// time := time * - 1 ;
101838: LD_ADDR_VAR 0 8
101842: PUSH
101843: LD_VAR 0 8
101847: PUSH
101848: LD_INT 1
101850: NEG
101851: MUL
101852: ST_TO_ADDR
// wait ( time ) ;
101853: LD_VAR 0 8
101857: PPUSH
101858: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
101862: LD_INT 35
101864: PPUSH
101865: LD_INT 875
101867: PPUSH
101868: CALL_OW 12
101872: PPUSH
101873: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
101877: LD_INT 1
101879: PPUSH
101880: LD_INT 5
101882: PPUSH
101883: CALL_OW 12
101887: PPUSH
101888: LD_VAR 0 1
101892: PPUSH
101893: LD_INT 1
101895: PPUSH
101896: CALL_OW 55
// end ;
101900: GO 101710
// end ;
101902: LD_VAR 0 5
101906: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
101907: LD_INT 0
101909: PPUSH
101910: PPUSH
101911: PPUSH
101912: PPUSH
101913: PPUSH
101914: PPUSH
101915: PPUSH
101916: PPUSH
// if not turrets or not factories then
101917: LD_VAR 0 1
101921: NOT
101922: PUSH
101923: LD_VAR 0 2
101927: NOT
101928: OR
101929: IFFALSE 101933
// exit ;
101931: GO 102240
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
101933: LD_ADDR_VAR 0 10
101937: PUSH
101938: LD_INT 5
101940: PUSH
101941: LD_INT 6
101943: PUSH
101944: EMPTY
101945: LIST
101946: LIST
101947: PUSH
101948: LD_INT 2
101950: PUSH
101951: LD_INT 4
101953: PUSH
101954: EMPTY
101955: LIST
101956: LIST
101957: PUSH
101958: LD_INT 3
101960: PUSH
101961: LD_INT 5
101963: PUSH
101964: EMPTY
101965: LIST
101966: LIST
101967: PUSH
101968: EMPTY
101969: LIST
101970: LIST
101971: LIST
101972: PUSH
101973: LD_INT 24
101975: PUSH
101976: LD_INT 25
101978: PUSH
101979: EMPTY
101980: LIST
101981: LIST
101982: PUSH
101983: LD_INT 23
101985: PUSH
101986: LD_INT 27
101988: PUSH
101989: EMPTY
101990: LIST
101991: LIST
101992: PUSH
101993: EMPTY
101994: LIST
101995: LIST
101996: PUSH
101997: LD_INT 42
101999: PUSH
102000: LD_INT 43
102002: PUSH
102003: EMPTY
102004: LIST
102005: LIST
102006: PUSH
102007: LD_INT 44
102009: PUSH
102010: LD_INT 46
102012: PUSH
102013: EMPTY
102014: LIST
102015: LIST
102016: PUSH
102017: LD_INT 45
102019: PUSH
102020: LD_INT 47
102022: PUSH
102023: EMPTY
102024: LIST
102025: LIST
102026: PUSH
102027: EMPTY
102028: LIST
102029: LIST
102030: LIST
102031: PUSH
102032: EMPTY
102033: LIST
102034: LIST
102035: LIST
102036: ST_TO_ADDR
// result := [ ] ;
102037: LD_ADDR_VAR 0 3
102041: PUSH
102042: EMPTY
102043: ST_TO_ADDR
// for i in turrets do
102044: LD_ADDR_VAR 0 4
102048: PUSH
102049: LD_VAR 0 1
102053: PUSH
102054: FOR_IN
102055: IFFALSE 102238
// begin nat := GetNation ( i ) ;
102057: LD_ADDR_VAR 0 7
102061: PUSH
102062: LD_VAR 0 4
102066: PPUSH
102067: CALL_OW 248
102071: ST_TO_ADDR
// weapon := 0 ;
102072: LD_ADDR_VAR 0 8
102076: PUSH
102077: LD_INT 0
102079: ST_TO_ADDR
// if not nat then
102080: LD_VAR 0 7
102084: NOT
102085: IFFALSE 102089
// continue ;
102087: GO 102054
// for j in list [ nat ] do
102089: LD_ADDR_VAR 0 5
102093: PUSH
102094: LD_VAR 0 10
102098: PUSH
102099: LD_VAR 0 7
102103: ARRAY
102104: PUSH
102105: FOR_IN
102106: IFFALSE 102147
// if GetBWeapon ( i ) = j [ 1 ] then
102108: LD_VAR 0 4
102112: PPUSH
102113: CALL_OW 269
102117: PUSH
102118: LD_VAR 0 5
102122: PUSH
102123: LD_INT 1
102125: ARRAY
102126: EQUAL
102127: IFFALSE 102145
// begin weapon := j [ 2 ] ;
102129: LD_ADDR_VAR 0 8
102133: PUSH
102134: LD_VAR 0 5
102138: PUSH
102139: LD_INT 2
102141: ARRAY
102142: ST_TO_ADDR
// break ;
102143: GO 102147
// end ;
102145: GO 102105
102147: POP
102148: POP
// if not weapon then
102149: LD_VAR 0 8
102153: NOT
102154: IFFALSE 102158
// continue ;
102156: GO 102054
// for k in factories do
102158: LD_ADDR_VAR 0 6
102162: PUSH
102163: LD_VAR 0 2
102167: PUSH
102168: FOR_IN
102169: IFFALSE 102234
// begin weapons := AvailableWeaponList ( k ) ;
102171: LD_ADDR_VAR 0 9
102175: PUSH
102176: LD_VAR 0 6
102180: PPUSH
102181: CALL_OW 478
102185: ST_TO_ADDR
// if not weapons then
102186: LD_VAR 0 9
102190: NOT
102191: IFFALSE 102195
// continue ;
102193: GO 102168
// if weapon in weapons then
102195: LD_VAR 0 8
102199: PUSH
102200: LD_VAR 0 9
102204: IN
102205: IFFALSE 102232
// begin result := [ i , weapon ] ;
102207: LD_ADDR_VAR 0 3
102211: PUSH
102212: LD_VAR 0 4
102216: PUSH
102217: LD_VAR 0 8
102221: PUSH
102222: EMPTY
102223: LIST
102224: LIST
102225: ST_TO_ADDR
// exit ;
102226: POP
102227: POP
102228: POP
102229: POP
102230: GO 102240
// end ; end ;
102232: GO 102168
102234: POP
102235: POP
// end ;
102236: GO 102054
102238: POP
102239: POP
// end ;
102240: LD_VAR 0 3
102244: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
102245: LD_INT 0
102247: PPUSH
// if not side or side > 8 then
102248: LD_VAR 0 3
102252: NOT
102253: PUSH
102254: LD_VAR 0 3
102258: PUSH
102259: LD_INT 8
102261: GREATER
102262: OR
102263: IFFALSE 102267
// exit ;
102265: GO 102326
// if not range then
102267: LD_VAR 0 4
102271: NOT
102272: IFFALSE 102283
// range := - 12 ;
102274: LD_ADDR_VAR 0 4
102278: PUSH
102279: LD_INT 12
102281: NEG
102282: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
102283: LD_VAR 0 1
102287: PPUSH
102288: LD_VAR 0 2
102292: PPUSH
102293: LD_VAR 0 3
102297: PPUSH
102298: LD_VAR 0 4
102302: PPUSH
102303: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
102307: LD_VAR 0 1
102311: PPUSH
102312: LD_VAR 0 2
102316: PPUSH
102317: LD_VAR 0 3
102321: PPUSH
102322: CALL_OW 331
// end ;
102326: LD_VAR 0 5
102330: RET
// export function Video ( mode ) ; begin
102331: LD_INT 0
102333: PPUSH
// ingame_video = mode ;
102334: LD_ADDR_OWVAR 52
102338: PUSH
102339: LD_VAR 0 1
102343: ST_TO_ADDR
// interface_hidden = mode ;
102344: LD_ADDR_OWVAR 54
102348: PUSH
102349: LD_VAR 0 1
102353: ST_TO_ADDR
// end ;
102354: LD_VAR 0 2
102358: RET
// export function Join ( array , element ) ; begin
102359: LD_INT 0
102361: PPUSH
// result := Replace ( array , array + 1 , element ) ;
102362: LD_ADDR_VAR 0 3
102366: PUSH
102367: LD_VAR 0 1
102371: PPUSH
102372: LD_VAR 0 1
102376: PUSH
102377: LD_INT 1
102379: PLUS
102380: PPUSH
102381: LD_VAR 0 2
102385: PPUSH
102386: CALL_OW 1
102390: ST_TO_ADDR
// end ;
102391: LD_VAR 0 3
102395: RET
// export function JoinUnion ( array , element ) ; begin
102396: LD_INT 0
102398: PPUSH
// result := array union element ;
102399: LD_ADDR_VAR 0 3
102403: PUSH
102404: LD_VAR 0 1
102408: PUSH
102409: LD_VAR 0 2
102413: UNION
102414: ST_TO_ADDR
// end ;
102415: LD_VAR 0 3
102419: RET
// export function GetBehemoths ( side ) ; begin
102420: LD_INT 0
102422: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
102423: LD_ADDR_VAR 0 2
102427: PUSH
102428: LD_INT 22
102430: PUSH
102431: LD_VAR 0 1
102435: PUSH
102436: EMPTY
102437: LIST
102438: LIST
102439: PUSH
102440: LD_INT 31
102442: PUSH
102443: LD_INT 25
102445: PUSH
102446: EMPTY
102447: LIST
102448: LIST
102449: PUSH
102450: EMPTY
102451: LIST
102452: LIST
102453: PPUSH
102454: CALL_OW 69
102458: ST_TO_ADDR
// end ;
102459: LD_VAR 0 2
102463: RET
// export function Shuffle ( array ) ; var i , index ; begin
102464: LD_INT 0
102466: PPUSH
102467: PPUSH
102468: PPUSH
// result := [ ] ;
102469: LD_ADDR_VAR 0 2
102473: PUSH
102474: EMPTY
102475: ST_TO_ADDR
// if not array then
102476: LD_VAR 0 1
102480: NOT
102481: IFFALSE 102485
// exit ;
102483: GO 102584
// Randomize ;
102485: CALL_OW 10
// for i = array downto 1 do
102489: LD_ADDR_VAR 0 3
102493: PUSH
102494: DOUBLE
102495: LD_VAR 0 1
102499: INC
102500: ST_TO_ADDR
102501: LD_INT 1
102503: PUSH
102504: FOR_DOWNTO
102505: IFFALSE 102582
// begin index := rand ( 1 , array ) ;
102507: LD_ADDR_VAR 0 4
102511: PUSH
102512: LD_INT 1
102514: PPUSH
102515: LD_VAR 0 1
102519: PPUSH
102520: CALL_OW 12
102524: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
102525: LD_ADDR_VAR 0 2
102529: PUSH
102530: LD_VAR 0 2
102534: PPUSH
102535: LD_VAR 0 2
102539: PUSH
102540: LD_INT 1
102542: PLUS
102543: PPUSH
102544: LD_VAR 0 1
102548: PUSH
102549: LD_VAR 0 4
102553: ARRAY
102554: PPUSH
102555: CALL_OW 2
102559: ST_TO_ADDR
// array := Delete ( array , index ) ;
102560: LD_ADDR_VAR 0 1
102564: PUSH
102565: LD_VAR 0 1
102569: PPUSH
102570: LD_VAR 0 4
102574: PPUSH
102575: CALL_OW 3
102579: ST_TO_ADDR
// end ;
102580: GO 102504
102582: POP
102583: POP
// end ;
102584: LD_VAR 0 2
102588: RET
// export function GetBaseMaterials ( base ) ; begin
102589: LD_INT 0
102591: PPUSH
// result := [ 0 , 0 , 0 ] ;
102592: LD_ADDR_VAR 0 2
102596: PUSH
102597: LD_INT 0
102599: PUSH
102600: LD_INT 0
102602: PUSH
102603: LD_INT 0
102605: PUSH
102606: EMPTY
102607: LIST
102608: LIST
102609: LIST
102610: ST_TO_ADDR
// if not base then
102611: LD_VAR 0 1
102615: NOT
102616: IFFALSE 102620
// exit ;
102618: GO 102669
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
102620: LD_ADDR_VAR 0 2
102624: PUSH
102625: LD_VAR 0 1
102629: PPUSH
102630: LD_INT 1
102632: PPUSH
102633: CALL_OW 275
102637: PUSH
102638: LD_VAR 0 1
102642: PPUSH
102643: LD_INT 2
102645: PPUSH
102646: CALL_OW 275
102650: PUSH
102651: LD_VAR 0 1
102655: PPUSH
102656: LD_INT 3
102658: PPUSH
102659: CALL_OW 275
102663: PUSH
102664: EMPTY
102665: LIST
102666: LIST
102667: LIST
102668: ST_TO_ADDR
// end ;
102669: LD_VAR 0 2
102673: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
102674: LD_INT 0
102676: PPUSH
102677: PPUSH
// result := array ;
102678: LD_ADDR_VAR 0 3
102682: PUSH
102683: LD_VAR 0 1
102687: ST_TO_ADDR
// if size > 0 then
102688: LD_VAR 0 2
102692: PUSH
102693: LD_INT 0
102695: GREATER
102696: IFFALSE 102742
// for i := array downto size do
102698: LD_ADDR_VAR 0 4
102702: PUSH
102703: DOUBLE
102704: LD_VAR 0 1
102708: INC
102709: ST_TO_ADDR
102710: LD_VAR 0 2
102714: PUSH
102715: FOR_DOWNTO
102716: IFFALSE 102740
// result := Delete ( result , result ) ;
102718: LD_ADDR_VAR 0 3
102722: PUSH
102723: LD_VAR 0 3
102727: PPUSH
102728: LD_VAR 0 3
102732: PPUSH
102733: CALL_OW 3
102737: ST_TO_ADDR
102738: GO 102715
102740: POP
102741: POP
// end ;
102742: LD_VAR 0 3
102746: RET
// export function ComExit ( unit ) ; var tmp ; begin
102747: LD_INT 0
102749: PPUSH
102750: PPUSH
// if not IsInUnit ( unit ) then
102751: LD_VAR 0 1
102755: PPUSH
102756: CALL_OW 310
102760: NOT
102761: IFFALSE 102765
// exit ;
102763: GO 102825
// tmp := IsInUnit ( unit ) ;
102765: LD_ADDR_VAR 0 3
102769: PUSH
102770: LD_VAR 0 1
102774: PPUSH
102775: CALL_OW 310
102779: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
102780: LD_VAR 0 3
102784: PPUSH
102785: CALL_OW 247
102789: PUSH
102790: LD_INT 2
102792: EQUAL
102793: IFFALSE 102806
// ComExitVehicle ( unit ) else
102795: LD_VAR 0 1
102799: PPUSH
102800: CALL_OW 121
102804: GO 102815
// ComExitBuilding ( unit ) ;
102806: LD_VAR 0 1
102810: PPUSH
102811: CALL_OW 122
// result := tmp ;
102815: LD_ADDR_VAR 0 2
102819: PUSH
102820: LD_VAR 0 3
102824: ST_TO_ADDR
// end ;
102825: LD_VAR 0 2
102829: RET
// export function ComExitAll ( units ) ; var i ; begin
102830: LD_INT 0
102832: PPUSH
102833: PPUSH
// if not units then
102834: LD_VAR 0 1
102838: NOT
102839: IFFALSE 102843
// exit ;
102841: GO 102869
// for i in units do
102843: LD_ADDR_VAR 0 3
102847: PUSH
102848: LD_VAR 0 1
102852: PUSH
102853: FOR_IN
102854: IFFALSE 102867
// ComExit ( i ) ;
102856: LD_VAR 0 3
102860: PPUSH
102861: CALL 102747 0 1
102865: GO 102853
102867: POP
102868: POP
// end ;
102869: LD_VAR 0 2
102873: RET
// export function ResetHc ; begin
102874: LD_INT 0
102876: PPUSH
// InitHc ;
102877: CALL_OW 19
// hc_importance := 0 ;
102881: LD_ADDR_OWVAR 32
102885: PUSH
102886: LD_INT 0
102888: ST_TO_ADDR
// end ;
102889: LD_VAR 0 1
102893: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
102894: LD_INT 0
102896: PPUSH
102897: PPUSH
102898: PPUSH
// _x := ( x1 + x2 ) div 2 ;
102899: LD_ADDR_VAR 0 6
102903: PUSH
102904: LD_VAR 0 1
102908: PUSH
102909: LD_VAR 0 3
102913: PLUS
102914: PUSH
102915: LD_INT 2
102917: DIV
102918: ST_TO_ADDR
// if _x < 0 then
102919: LD_VAR 0 6
102923: PUSH
102924: LD_INT 0
102926: LESS
102927: IFFALSE 102944
// _x := _x * - 1 ;
102929: LD_ADDR_VAR 0 6
102933: PUSH
102934: LD_VAR 0 6
102938: PUSH
102939: LD_INT 1
102941: NEG
102942: MUL
102943: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
102944: LD_ADDR_VAR 0 7
102948: PUSH
102949: LD_VAR 0 2
102953: PUSH
102954: LD_VAR 0 4
102958: PLUS
102959: PUSH
102960: LD_INT 2
102962: DIV
102963: ST_TO_ADDR
// if _y < 0 then
102964: LD_VAR 0 7
102968: PUSH
102969: LD_INT 0
102971: LESS
102972: IFFALSE 102989
// _y := _y * - 1 ;
102974: LD_ADDR_VAR 0 7
102978: PUSH
102979: LD_VAR 0 7
102983: PUSH
102984: LD_INT 1
102986: NEG
102987: MUL
102988: ST_TO_ADDR
// result := [ _x , _y ] ;
102989: LD_ADDR_VAR 0 5
102993: PUSH
102994: LD_VAR 0 6
102998: PUSH
102999: LD_VAR 0 7
103003: PUSH
103004: EMPTY
103005: LIST
103006: LIST
103007: ST_TO_ADDR
// end ;
103008: LD_VAR 0 5
103012: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
103013: LD_INT 0
103015: PPUSH
103016: PPUSH
103017: PPUSH
103018: PPUSH
// task := GetTaskList ( unit ) ;
103019: LD_ADDR_VAR 0 7
103023: PUSH
103024: LD_VAR 0 1
103028: PPUSH
103029: CALL_OW 437
103033: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
103034: LD_VAR 0 7
103038: NOT
103039: PUSH
103040: LD_VAR 0 1
103044: PPUSH
103045: LD_VAR 0 2
103049: PPUSH
103050: CALL_OW 308
103054: NOT
103055: AND
103056: IFFALSE 103060
// exit ;
103058: GO 103178
// if IsInArea ( unit , area ) then
103060: LD_VAR 0 1
103064: PPUSH
103065: LD_VAR 0 2
103069: PPUSH
103070: CALL_OW 308
103074: IFFALSE 103092
// begin ComMoveToArea ( unit , goAway ) ;
103076: LD_VAR 0 1
103080: PPUSH
103081: LD_VAR 0 3
103085: PPUSH
103086: CALL_OW 113
// exit ;
103090: GO 103178
// end ; if task [ 1 ] [ 1 ] <> M then
103092: LD_VAR 0 7
103096: PUSH
103097: LD_INT 1
103099: ARRAY
103100: PUSH
103101: LD_INT 1
103103: ARRAY
103104: PUSH
103105: LD_STRING M
103107: NONEQUAL
103108: IFFALSE 103112
// exit ;
103110: GO 103178
// x := task [ 1 ] [ 2 ] ;
103112: LD_ADDR_VAR 0 5
103116: PUSH
103117: LD_VAR 0 7
103121: PUSH
103122: LD_INT 1
103124: ARRAY
103125: PUSH
103126: LD_INT 2
103128: ARRAY
103129: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
103130: LD_ADDR_VAR 0 6
103134: PUSH
103135: LD_VAR 0 7
103139: PUSH
103140: LD_INT 1
103142: ARRAY
103143: PUSH
103144: LD_INT 3
103146: ARRAY
103147: ST_TO_ADDR
// if InArea ( x , y , area ) then
103148: LD_VAR 0 5
103152: PPUSH
103153: LD_VAR 0 6
103157: PPUSH
103158: LD_VAR 0 2
103162: PPUSH
103163: CALL_OW 309
103167: IFFALSE 103178
// ComStop ( unit ) ;
103169: LD_VAR 0 1
103173: PPUSH
103174: CALL_OW 141
// end ;
103178: LD_VAR 0 4
103182: RET
// export function Abs ( value ) ; begin
103183: LD_INT 0
103185: PPUSH
// result := value ;
103186: LD_ADDR_VAR 0 2
103190: PUSH
103191: LD_VAR 0 1
103195: ST_TO_ADDR
// if value < 0 then
103196: LD_VAR 0 1
103200: PUSH
103201: LD_INT 0
103203: LESS
103204: IFFALSE 103221
// result := value * - 1 ;
103206: LD_ADDR_VAR 0 2
103210: PUSH
103211: LD_VAR 0 1
103215: PUSH
103216: LD_INT 1
103218: NEG
103219: MUL
103220: ST_TO_ADDR
// end ;
103221: LD_VAR 0 2
103225: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
103226: LD_INT 0
103228: PPUSH
103229: PPUSH
103230: PPUSH
103231: PPUSH
103232: PPUSH
103233: PPUSH
103234: PPUSH
103235: PPUSH
// if not unit or not building then
103236: LD_VAR 0 1
103240: NOT
103241: PUSH
103242: LD_VAR 0 2
103246: NOT
103247: OR
103248: IFFALSE 103252
// exit ;
103250: GO 103478
// x := GetX ( building ) ;
103252: LD_ADDR_VAR 0 4
103256: PUSH
103257: LD_VAR 0 2
103261: PPUSH
103262: CALL_OW 250
103266: ST_TO_ADDR
// y := GetY ( building ) ;
103267: LD_ADDR_VAR 0 6
103271: PUSH
103272: LD_VAR 0 2
103276: PPUSH
103277: CALL_OW 251
103281: ST_TO_ADDR
// d := GetDir ( building ) ;
103282: LD_ADDR_VAR 0 8
103286: PUSH
103287: LD_VAR 0 2
103291: PPUSH
103292: CALL_OW 254
103296: ST_TO_ADDR
// r := 4 ;
103297: LD_ADDR_VAR 0 9
103301: PUSH
103302: LD_INT 4
103304: ST_TO_ADDR
// for i := 1 to 5 do
103305: LD_ADDR_VAR 0 10
103309: PUSH
103310: DOUBLE
103311: LD_INT 1
103313: DEC
103314: ST_TO_ADDR
103315: LD_INT 5
103317: PUSH
103318: FOR_TO
103319: IFFALSE 103476
// begin _x := ShiftX ( x , d , r + i ) ;
103321: LD_ADDR_VAR 0 5
103325: PUSH
103326: LD_VAR 0 4
103330: PPUSH
103331: LD_VAR 0 8
103335: PPUSH
103336: LD_VAR 0 9
103340: PUSH
103341: LD_VAR 0 10
103345: PLUS
103346: PPUSH
103347: CALL_OW 272
103351: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
103352: LD_ADDR_VAR 0 7
103356: PUSH
103357: LD_VAR 0 6
103361: PPUSH
103362: LD_VAR 0 8
103366: PPUSH
103367: LD_VAR 0 9
103371: PUSH
103372: LD_VAR 0 10
103376: PLUS
103377: PPUSH
103378: CALL_OW 273
103382: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
103383: LD_VAR 0 5
103387: PPUSH
103388: LD_VAR 0 7
103392: PPUSH
103393: CALL_OW 488
103397: PUSH
103398: LD_VAR 0 5
103402: PPUSH
103403: LD_VAR 0 7
103407: PPUSH
103408: CALL_OW 428
103412: PPUSH
103413: CALL_OW 247
103417: PUSH
103418: LD_INT 3
103420: PUSH
103421: LD_INT 2
103423: PUSH
103424: EMPTY
103425: LIST
103426: LIST
103427: IN
103428: NOT
103429: AND
103430: IFFALSE 103474
// begin ComMoveXY ( unit , _x , _y ) ;
103432: LD_VAR 0 1
103436: PPUSH
103437: LD_VAR 0 5
103441: PPUSH
103442: LD_VAR 0 7
103446: PPUSH
103447: CALL_OW 111
// result := [ _x , _y ] ;
103451: LD_ADDR_VAR 0 3
103455: PUSH
103456: LD_VAR 0 5
103460: PUSH
103461: LD_VAR 0 7
103465: PUSH
103466: EMPTY
103467: LIST
103468: LIST
103469: ST_TO_ADDR
// exit ;
103470: POP
103471: POP
103472: GO 103478
// end ; end ;
103474: GO 103318
103476: POP
103477: POP
// end ;
103478: LD_VAR 0 3
103482: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
103483: LD_INT 0
103485: PPUSH
103486: PPUSH
103487: PPUSH
// result := 0 ;
103488: LD_ADDR_VAR 0 3
103492: PUSH
103493: LD_INT 0
103495: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
103496: LD_VAR 0 1
103500: PUSH
103501: LD_INT 0
103503: LESS
103504: PUSH
103505: LD_VAR 0 1
103509: PUSH
103510: LD_INT 8
103512: GREATER
103513: OR
103514: PUSH
103515: LD_VAR 0 2
103519: PUSH
103520: LD_INT 0
103522: LESS
103523: OR
103524: PUSH
103525: LD_VAR 0 2
103529: PUSH
103530: LD_INT 8
103532: GREATER
103533: OR
103534: IFFALSE 103538
// exit ;
103536: GO 103613
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
103538: LD_ADDR_VAR 0 4
103542: PUSH
103543: LD_INT 22
103545: PUSH
103546: LD_VAR 0 2
103550: PUSH
103551: EMPTY
103552: LIST
103553: LIST
103554: PPUSH
103555: CALL_OW 69
103559: PUSH
103560: FOR_IN
103561: IFFALSE 103611
// begin un := UnitShoot ( i ) ;
103563: LD_ADDR_VAR 0 5
103567: PUSH
103568: LD_VAR 0 4
103572: PPUSH
103573: CALL_OW 504
103577: ST_TO_ADDR
// if GetSide ( un ) = side1 then
103578: LD_VAR 0 5
103582: PPUSH
103583: CALL_OW 255
103587: PUSH
103588: LD_VAR 0 1
103592: EQUAL
103593: IFFALSE 103609
// begin result := un ;
103595: LD_ADDR_VAR 0 3
103599: PUSH
103600: LD_VAR 0 5
103604: ST_TO_ADDR
// exit ;
103605: POP
103606: POP
103607: GO 103613
// end ; end ;
103609: GO 103560
103611: POP
103612: POP
// end ;
103613: LD_VAR 0 3
103617: RET
// export function GetCargoBay ( units ) ; begin
103618: LD_INT 0
103620: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
103621: LD_ADDR_VAR 0 2
103625: PUSH
103626: LD_VAR 0 1
103630: PPUSH
103631: LD_INT 2
103633: PUSH
103634: LD_INT 34
103636: PUSH
103637: LD_INT 12
103639: PUSH
103640: EMPTY
103641: LIST
103642: LIST
103643: PUSH
103644: LD_INT 34
103646: PUSH
103647: LD_INT 51
103649: PUSH
103650: EMPTY
103651: LIST
103652: LIST
103653: PUSH
103654: LD_INT 34
103656: PUSH
103657: LD_INT 32
103659: PUSH
103660: EMPTY
103661: LIST
103662: LIST
103663: PUSH
103664: LD_INT 34
103666: PUSH
103667: LD_EXP 96
103671: PUSH
103672: EMPTY
103673: LIST
103674: LIST
103675: PUSH
103676: EMPTY
103677: LIST
103678: LIST
103679: LIST
103680: LIST
103681: LIST
103682: PPUSH
103683: CALL_OW 72
103687: ST_TO_ADDR
// end ;
103688: LD_VAR 0 2
103692: RET
// export function Negate ( value ) ; begin
103693: LD_INT 0
103695: PPUSH
// result := not value ;
103696: LD_ADDR_VAR 0 2
103700: PUSH
103701: LD_VAR 0 1
103705: NOT
103706: ST_TO_ADDR
// end ;
103707: LD_VAR 0 2
103711: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
103712: LD_INT 0
103714: PPUSH
// if x1 = x2 then
103715: LD_VAR 0 1
103719: PUSH
103720: LD_VAR 0 3
103724: EQUAL
103725: IFFALSE 103759
// begin if y1 > y2 then
103727: LD_VAR 0 2
103731: PUSH
103732: LD_VAR 0 4
103736: GREATER
103737: IFFALSE 103749
// result := 0 else
103739: LD_ADDR_VAR 0 5
103743: PUSH
103744: LD_INT 0
103746: ST_TO_ADDR
103747: GO 103757
// result := 3 ;
103749: LD_ADDR_VAR 0 5
103753: PUSH
103754: LD_INT 3
103756: ST_TO_ADDR
// exit ;
103757: GO 103845
// end ; if y1 = y2 then
103759: LD_VAR 0 2
103763: PUSH
103764: LD_VAR 0 4
103768: EQUAL
103769: IFFALSE 103803
// begin if x1 > x2 then
103771: LD_VAR 0 1
103775: PUSH
103776: LD_VAR 0 3
103780: GREATER
103781: IFFALSE 103793
// result := 1 else
103783: LD_ADDR_VAR 0 5
103787: PUSH
103788: LD_INT 1
103790: ST_TO_ADDR
103791: GO 103801
// result := 4 ;
103793: LD_ADDR_VAR 0 5
103797: PUSH
103798: LD_INT 4
103800: ST_TO_ADDR
// exit ;
103801: GO 103845
// end ; if x1 > x2 and y1 > y2 then
103803: LD_VAR 0 1
103807: PUSH
103808: LD_VAR 0 3
103812: GREATER
103813: PUSH
103814: LD_VAR 0 2
103818: PUSH
103819: LD_VAR 0 4
103823: GREATER
103824: AND
103825: IFFALSE 103837
// result := 2 else
103827: LD_ADDR_VAR 0 5
103831: PUSH
103832: LD_INT 2
103834: ST_TO_ADDR
103835: GO 103845
// result := 5 ;
103837: LD_ADDR_VAR 0 5
103841: PUSH
103842: LD_INT 5
103844: ST_TO_ADDR
// end ;
103845: LD_VAR 0 5
103849: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
103850: LD_INT 0
103852: PPUSH
103853: PPUSH
// if not driver or not IsInUnit ( driver ) then
103854: LD_VAR 0 1
103858: NOT
103859: PUSH
103860: LD_VAR 0 1
103864: PPUSH
103865: CALL_OW 310
103869: NOT
103870: OR
103871: IFFALSE 103875
// exit ;
103873: GO 103965
// vehicle := IsInUnit ( driver ) ;
103875: LD_ADDR_VAR 0 3
103879: PUSH
103880: LD_VAR 0 1
103884: PPUSH
103885: CALL_OW 310
103889: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
103890: LD_VAR 0 1
103894: PPUSH
103895: LD_STRING \
103897: PUSH
103898: LD_INT 0
103900: PUSH
103901: LD_INT 0
103903: PUSH
103904: LD_INT 0
103906: PUSH
103907: LD_INT 0
103909: PUSH
103910: LD_INT 0
103912: PUSH
103913: LD_INT 0
103915: PUSH
103916: EMPTY
103917: LIST
103918: LIST
103919: LIST
103920: LIST
103921: LIST
103922: LIST
103923: LIST
103924: PUSH
103925: LD_STRING E
103927: PUSH
103928: LD_INT 0
103930: PUSH
103931: LD_INT 0
103933: PUSH
103934: LD_VAR 0 3
103938: PUSH
103939: LD_INT 0
103941: PUSH
103942: LD_INT 0
103944: PUSH
103945: LD_INT 0
103947: PUSH
103948: EMPTY
103949: LIST
103950: LIST
103951: LIST
103952: LIST
103953: LIST
103954: LIST
103955: LIST
103956: PUSH
103957: EMPTY
103958: LIST
103959: LIST
103960: PPUSH
103961: CALL_OW 446
// end ;
103965: LD_VAR 0 2
103969: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
103970: LD_INT 0
103972: PPUSH
103973: PPUSH
// if not driver or not IsInUnit ( driver ) then
103974: LD_VAR 0 1
103978: NOT
103979: PUSH
103980: LD_VAR 0 1
103984: PPUSH
103985: CALL_OW 310
103989: NOT
103990: OR
103991: IFFALSE 103995
// exit ;
103993: GO 104085
// vehicle := IsInUnit ( driver ) ;
103995: LD_ADDR_VAR 0 3
103999: PUSH
104000: LD_VAR 0 1
104004: PPUSH
104005: CALL_OW 310
104009: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
104010: LD_VAR 0 1
104014: PPUSH
104015: LD_STRING \
104017: PUSH
104018: LD_INT 0
104020: PUSH
104021: LD_INT 0
104023: PUSH
104024: LD_INT 0
104026: PUSH
104027: LD_INT 0
104029: PUSH
104030: LD_INT 0
104032: PUSH
104033: LD_INT 0
104035: PUSH
104036: EMPTY
104037: LIST
104038: LIST
104039: LIST
104040: LIST
104041: LIST
104042: LIST
104043: LIST
104044: PUSH
104045: LD_STRING E
104047: PUSH
104048: LD_INT 0
104050: PUSH
104051: LD_INT 0
104053: PUSH
104054: LD_VAR 0 3
104058: PUSH
104059: LD_INT 0
104061: PUSH
104062: LD_INT 0
104064: PUSH
104065: LD_INT 0
104067: PUSH
104068: EMPTY
104069: LIST
104070: LIST
104071: LIST
104072: LIST
104073: LIST
104074: LIST
104075: LIST
104076: PUSH
104077: EMPTY
104078: LIST
104079: LIST
104080: PPUSH
104081: CALL_OW 447
// end ;
104085: LD_VAR 0 2
104089: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
104090: LD_INT 0
104092: PPUSH
104093: PPUSH
104094: PPUSH
// tmp := [ ] ;
104095: LD_ADDR_VAR 0 5
104099: PUSH
104100: EMPTY
104101: ST_TO_ADDR
// for i in units do
104102: LD_ADDR_VAR 0 4
104106: PUSH
104107: LD_VAR 0 1
104111: PUSH
104112: FOR_IN
104113: IFFALSE 104151
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
104115: LD_ADDR_VAR 0 5
104119: PUSH
104120: LD_VAR 0 5
104124: PPUSH
104125: LD_VAR 0 5
104129: PUSH
104130: LD_INT 1
104132: PLUS
104133: PPUSH
104134: LD_VAR 0 4
104138: PPUSH
104139: CALL_OW 256
104143: PPUSH
104144: CALL_OW 2
104148: ST_TO_ADDR
104149: GO 104112
104151: POP
104152: POP
// if not tmp then
104153: LD_VAR 0 5
104157: NOT
104158: IFFALSE 104162
// exit ;
104160: GO 104210
// if asc then
104162: LD_VAR 0 2
104166: IFFALSE 104190
// result := SortListByListAsc ( units , tmp ) else
104168: LD_ADDR_VAR 0 3
104172: PUSH
104173: LD_VAR 0 1
104177: PPUSH
104178: LD_VAR 0 5
104182: PPUSH
104183: CALL_OW 76
104187: ST_TO_ADDR
104188: GO 104210
// result := SortListByListDesc ( units , tmp ) ;
104190: LD_ADDR_VAR 0 3
104194: PUSH
104195: LD_VAR 0 1
104199: PPUSH
104200: LD_VAR 0 5
104204: PPUSH
104205: CALL_OW 77
104209: ST_TO_ADDR
// end ;
104210: LD_VAR 0 3
104214: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
104215: LD_INT 0
104217: PPUSH
104218: PPUSH
// task := GetTaskList ( mech ) ;
104219: LD_ADDR_VAR 0 4
104223: PUSH
104224: LD_VAR 0 1
104228: PPUSH
104229: CALL_OW 437
104233: ST_TO_ADDR
// if not task then
104234: LD_VAR 0 4
104238: NOT
104239: IFFALSE 104243
// exit ;
104241: GO 104285
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
104243: LD_ADDR_VAR 0 3
104247: PUSH
104248: LD_VAR 0 4
104252: PUSH
104253: LD_INT 1
104255: ARRAY
104256: PUSH
104257: LD_INT 1
104259: ARRAY
104260: PUSH
104261: LD_STRING r
104263: EQUAL
104264: PUSH
104265: LD_VAR 0 4
104269: PUSH
104270: LD_INT 1
104272: ARRAY
104273: PUSH
104274: LD_INT 4
104276: ARRAY
104277: PUSH
104278: LD_VAR 0 2
104282: EQUAL
104283: AND
104284: ST_TO_ADDR
// end ;
104285: LD_VAR 0 3
104289: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
104290: LD_INT 0
104292: PPUSH
// SetDir ( unit , d ) ;
104293: LD_VAR 0 1
104297: PPUSH
104298: LD_VAR 0 4
104302: PPUSH
104303: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
104307: LD_VAR 0 1
104311: PPUSH
104312: LD_VAR 0 2
104316: PPUSH
104317: LD_VAR 0 3
104321: PPUSH
104322: LD_VAR 0 5
104326: PPUSH
104327: CALL_OW 48
// end ;
104331: LD_VAR 0 6
104335: RET
// export function ToNaturalNumber ( number ) ; begin
104336: LD_INT 0
104338: PPUSH
// result := number div 1 ;
104339: LD_ADDR_VAR 0 2
104343: PUSH
104344: LD_VAR 0 1
104348: PUSH
104349: LD_INT 1
104351: DIV
104352: ST_TO_ADDR
// if number < 0 then
104353: LD_VAR 0 1
104357: PUSH
104358: LD_INT 0
104360: LESS
104361: IFFALSE 104371
// result := 0 ;
104363: LD_ADDR_VAR 0 2
104367: PUSH
104368: LD_INT 0
104370: ST_TO_ADDR
// end ;
104371: LD_VAR 0 2
104375: RET
// export function SortByClass ( units , class ) ; var un ; begin
104376: LD_INT 0
104378: PPUSH
104379: PPUSH
// if not units or not class then
104380: LD_VAR 0 1
104384: NOT
104385: PUSH
104386: LD_VAR 0 2
104390: NOT
104391: OR
104392: IFFALSE 104396
// exit ;
104394: GO 104491
// result := [ ] ;
104396: LD_ADDR_VAR 0 3
104400: PUSH
104401: EMPTY
104402: ST_TO_ADDR
// for un in units do
104403: LD_ADDR_VAR 0 4
104407: PUSH
104408: LD_VAR 0 1
104412: PUSH
104413: FOR_IN
104414: IFFALSE 104489
// if GetClass ( un ) = class then
104416: LD_VAR 0 4
104420: PPUSH
104421: CALL_OW 257
104425: PUSH
104426: LD_VAR 0 2
104430: EQUAL
104431: IFFALSE 104458
// result := Insert ( result , 1 , un ) else
104433: LD_ADDR_VAR 0 3
104437: PUSH
104438: LD_VAR 0 3
104442: PPUSH
104443: LD_INT 1
104445: PPUSH
104446: LD_VAR 0 4
104450: PPUSH
104451: CALL_OW 2
104455: ST_TO_ADDR
104456: GO 104487
// result := Replace ( result , result + 1 , un ) ;
104458: LD_ADDR_VAR 0 3
104462: PUSH
104463: LD_VAR 0 3
104467: PPUSH
104468: LD_VAR 0 3
104472: PUSH
104473: LD_INT 1
104475: PLUS
104476: PPUSH
104477: LD_VAR 0 4
104481: PPUSH
104482: CALL_OW 1
104486: ST_TO_ADDR
104487: GO 104413
104489: POP
104490: POP
// end ;
104491: LD_VAR 0 3
104495: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , side , tag ; begin
104496: LD_INT 0
104498: PPUSH
104499: PPUSH
104500: PPUSH
104501: PPUSH
104502: PPUSH
// if not units then
104503: LD_VAR 0 1
104507: NOT
104508: IFFALSE 104512
// exit ;
104510: GO 104818
// side := GetSide ( units [ 1 ] ) ;
104512: LD_ADDR_VAR 0 6
104516: PUSH
104517: LD_VAR 0 1
104521: PUSH
104522: LD_INT 1
104524: ARRAY
104525: PPUSH
104526: CALL_OW 255
104530: ST_TO_ADDR
// for i in units do
104531: LD_ADDR_VAR 0 4
104535: PUSH
104536: LD_VAR 0 1
104540: PUSH
104541: FOR_IN
104542: IFFALSE 104816
// begin if IsOk ( i ) then
104544: LD_VAR 0 4
104548: PPUSH
104549: CALL_OW 302
104553: IFFALSE 104814
// begin tag := GetTag ( i ) + 1 ;
104555: LD_ADDR_VAR 0 7
104559: PUSH
104560: LD_VAR 0 4
104564: PPUSH
104565: CALL_OW 110
104569: PUSH
104570: LD_INT 1
104572: PLUS
104573: ST_TO_ADDR
// if path > tag then
104574: LD_VAR 0 2
104578: PUSH
104579: LD_VAR 0 7
104583: GREATER
104584: IFFALSE 104762
// begin enemy := FilterAllUnits ( [ [ f_enemy , side ] , [ f_dist , i , 12 ] ] ) ;
104586: LD_ADDR_VAR 0 5
104590: PUSH
104591: LD_INT 81
104593: PUSH
104594: LD_VAR 0 6
104598: PUSH
104599: EMPTY
104600: LIST
104601: LIST
104602: PUSH
104603: LD_INT 91
104605: PUSH
104606: LD_VAR 0 4
104610: PUSH
104611: LD_INT 12
104613: PUSH
104614: EMPTY
104615: LIST
104616: LIST
104617: LIST
104618: PUSH
104619: EMPTY
104620: LIST
104621: LIST
104622: PPUSH
104623: CALL_OW 69
104627: ST_TO_ADDR
// if enemy then
104628: LD_VAR 0 5
104632: IFFALSE 104660
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
104634: LD_VAR 0 4
104638: PPUSH
104639: LD_VAR 0 5
104643: PPUSH
104644: LD_VAR 0 4
104648: PPUSH
104649: CALL_OW 74
104653: PPUSH
104654: CALL_OW 115
104658: GO 104760
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
104660: LD_VAR 0 4
104664: PPUSH
104665: LD_VAR 0 2
104669: PUSH
104670: LD_VAR 0 7
104674: ARRAY
104675: PUSH
104676: LD_INT 1
104678: ARRAY
104679: PPUSH
104680: LD_VAR 0 2
104684: PUSH
104685: LD_VAR 0 7
104689: ARRAY
104690: PUSH
104691: LD_INT 2
104693: ARRAY
104694: PPUSH
104695: CALL_OW 297
104699: PUSH
104700: LD_INT 6
104702: GREATER
104703: IFFALSE 104746
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
104705: LD_VAR 0 4
104709: PPUSH
104710: LD_VAR 0 2
104714: PUSH
104715: LD_VAR 0 7
104719: ARRAY
104720: PUSH
104721: LD_INT 1
104723: ARRAY
104724: PPUSH
104725: LD_VAR 0 2
104729: PUSH
104730: LD_VAR 0 7
104734: ARRAY
104735: PUSH
104736: LD_INT 2
104738: ARRAY
104739: PPUSH
104740: CALL_OW 114
104744: GO 104760
// SetTag ( i , tag ) ;
104746: LD_VAR 0 4
104750: PPUSH
104751: LD_VAR 0 7
104755: PPUSH
104756: CALL_OW 109
// end else
104760: GO 104814
// begin enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
104762: LD_ADDR_VAR 0 5
104766: PUSH
104767: LD_INT 81
104769: PUSH
104770: LD_VAR 0 6
104774: PUSH
104775: EMPTY
104776: LIST
104777: LIST
104778: PPUSH
104779: CALL_OW 69
104783: ST_TO_ADDR
// if enemy then
104784: LD_VAR 0 5
104788: IFFALSE 104814
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
104790: LD_VAR 0 4
104794: PPUSH
104795: LD_VAR 0 5
104799: PPUSH
104800: LD_VAR 0 4
104804: PPUSH
104805: CALL_OW 74
104809: PPUSH
104810: CALL_OW 115
// end ; end ; end ;
104814: GO 104541
104816: POP
104817: POP
// end ; end_of_file end_of_file
104818: LD_VAR 0 3
104822: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
104823: LD_INT 0
104825: PPUSH
// if p2 = 100 then
104826: LD_VAR 0 2
104830: PUSH
104831: LD_INT 100
104833: EQUAL
104834: IFFALSE 105783
// begin if not StreamModeActive then
104836: LD_EXP 160
104840: NOT
104841: IFFALSE 104851
// StreamModeActive := true ;
104843: LD_ADDR_EXP 160
104847: PUSH
104848: LD_INT 1
104850: ST_TO_ADDR
// if p3 = 0 then
104851: LD_VAR 0 3
104855: PUSH
104856: LD_INT 0
104858: EQUAL
104859: IFFALSE 104865
// InitStreamMode ;
104861: CALL 105943 0 0
// if p3 = 1 then
104865: LD_VAR 0 3
104869: PUSH
104870: LD_INT 1
104872: EQUAL
104873: IFFALSE 104883
// sRocket := true ;
104875: LD_ADDR_EXP 165
104879: PUSH
104880: LD_INT 1
104882: ST_TO_ADDR
// if p3 = 2 then
104883: LD_VAR 0 3
104887: PUSH
104888: LD_INT 2
104890: EQUAL
104891: IFFALSE 104901
// sSpeed := true ;
104893: LD_ADDR_EXP 164
104897: PUSH
104898: LD_INT 1
104900: ST_TO_ADDR
// if p3 = 3 then
104901: LD_VAR 0 3
104905: PUSH
104906: LD_INT 3
104908: EQUAL
104909: IFFALSE 104919
// sEngine := true ;
104911: LD_ADDR_EXP 166
104915: PUSH
104916: LD_INT 1
104918: ST_TO_ADDR
// if p3 = 4 then
104919: LD_VAR 0 3
104923: PUSH
104924: LD_INT 4
104926: EQUAL
104927: IFFALSE 104937
// sSpec := true ;
104929: LD_ADDR_EXP 163
104933: PUSH
104934: LD_INT 1
104936: ST_TO_ADDR
// if p3 = 5 then
104937: LD_VAR 0 3
104941: PUSH
104942: LD_INT 5
104944: EQUAL
104945: IFFALSE 104955
// sLevel := true ;
104947: LD_ADDR_EXP 167
104951: PUSH
104952: LD_INT 1
104954: ST_TO_ADDR
// if p3 = 6 then
104955: LD_VAR 0 3
104959: PUSH
104960: LD_INT 6
104962: EQUAL
104963: IFFALSE 104973
// sArmoury := true ;
104965: LD_ADDR_EXP 168
104969: PUSH
104970: LD_INT 1
104972: ST_TO_ADDR
// if p3 = 7 then
104973: LD_VAR 0 3
104977: PUSH
104978: LD_INT 7
104980: EQUAL
104981: IFFALSE 104991
// sRadar := true ;
104983: LD_ADDR_EXP 169
104987: PUSH
104988: LD_INT 1
104990: ST_TO_ADDR
// if p3 = 8 then
104991: LD_VAR 0 3
104995: PUSH
104996: LD_INT 8
104998: EQUAL
104999: IFFALSE 105009
// sBunker := true ;
105001: LD_ADDR_EXP 170
105005: PUSH
105006: LD_INT 1
105008: ST_TO_ADDR
// if p3 = 9 then
105009: LD_VAR 0 3
105013: PUSH
105014: LD_INT 9
105016: EQUAL
105017: IFFALSE 105027
// sHack := true ;
105019: LD_ADDR_EXP 171
105023: PUSH
105024: LD_INT 1
105026: ST_TO_ADDR
// if p3 = 10 then
105027: LD_VAR 0 3
105031: PUSH
105032: LD_INT 10
105034: EQUAL
105035: IFFALSE 105045
// sFire := true ;
105037: LD_ADDR_EXP 172
105041: PUSH
105042: LD_INT 1
105044: ST_TO_ADDR
// if p3 = 11 then
105045: LD_VAR 0 3
105049: PUSH
105050: LD_INT 11
105052: EQUAL
105053: IFFALSE 105063
// sRefresh := true ;
105055: LD_ADDR_EXP 173
105059: PUSH
105060: LD_INT 1
105062: ST_TO_ADDR
// if p3 = 12 then
105063: LD_VAR 0 3
105067: PUSH
105068: LD_INT 12
105070: EQUAL
105071: IFFALSE 105081
// sExp := true ;
105073: LD_ADDR_EXP 174
105077: PUSH
105078: LD_INT 1
105080: ST_TO_ADDR
// if p3 = 13 then
105081: LD_VAR 0 3
105085: PUSH
105086: LD_INT 13
105088: EQUAL
105089: IFFALSE 105099
// sDepot := true ;
105091: LD_ADDR_EXP 175
105095: PUSH
105096: LD_INT 1
105098: ST_TO_ADDR
// if p3 = 14 then
105099: LD_VAR 0 3
105103: PUSH
105104: LD_INT 14
105106: EQUAL
105107: IFFALSE 105117
// sFlag := true ;
105109: LD_ADDR_EXP 176
105113: PUSH
105114: LD_INT 1
105116: ST_TO_ADDR
// if p3 = 15 then
105117: LD_VAR 0 3
105121: PUSH
105122: LD_INT 15
105124: EQUAL
105125: IFFALSE 105135
// sKamikadze := true ;
105127: LD_ADDR_EXP 184
105131: PUSH
105132: LD_INT 1
105134: ST_TO_ADDR
// if p3 = 16 then
105135: LD_VAR 0 3
105139: PUSH
105140: LD_INT 16
105142: EQUAL
105143: IFFALSE 105153
// sTroll := true ;
105145: LD_ADDR_EXP 185
105149: PUSH
105150: LD_INT 1
105152: ST_TO_ADDR
// if p3 = 17 then
105153: LD_VAR 0 3
105157: PUSH
105158: LD_INT 17
105160: EQUAL
105161: IFFALSE 105171
// sSlow := true ;
105163: LD_ADDR_EXP 186
105167: PUSH
105168: LD_INT 1
105170: ST_TO_ADDR
// if p3 = 18 then
105171: LD_VAR 0 3
105175: PUSH
105176: LD_INT 18
105178: EQUAL
105179: IFFALSE 105189
// sLack := true ;
105181: LD_ADDR_EXP 187
105185: PUSH
105186: LD_INT 1
105188: ST_TO_ADDR
// if p3 = 19 then
105189: LD_VAR 0 3
105193: PUSH
105194: LD_INT 19
105196: EQUAL
105197: IFFALSE 105207
// sTank := true ;
105199: LD_ADDR_EXP 189
105203: PUSH
105204: LD_INT 1
105206: ST_TO_ADDR
// if p3 = 20 then
105207: LD_VAR 0 3
105211: PUSH
105212: LD_INT 20
105214: EQUAL
105215: IFFALSE 105225
// sRemote := true ;
105217: LD_ADDR_EXP 190
105221: PUSH
105222: LD_INT 1
105224: ST_TO_ADDR
// if p3 = 21 then
105225: LD_VAR 0 3
105229: PUSH
105230: LD_INT 21
105232: EQUAL
105233: IFFALSE 105243
// sPowell := true ;
105235: LD_ADDR_EXP 191
105239: PUSH
105240: LD_INT 1
105242: ST_TO_ADDR
// if p3 = 22 then
105243: LD_VAR 0 3
105247: PUSH
105248: LD_INT 22
105250: EQUAL
105251: IFFALSE 105261
// sTeleport := true ;
105253: LD_ADDR_EXP 194
105257: PUSH
105258: LD_INT 1
105260: ST_TO_ADDR
// if p3 = 23 then
105261: LD_VAR 0 3
105265: PUSH
105266: LD_INT 23
105268: EQUAL
105269: IFFALSE 105279
// sOilTower := true ;
105271: LD_ADDR_EXP 196
105275: PUSH
105276: LD_INT 1
105278: ST_TO_ADDR
// if p3 = 24 then
105279: LD_VAR 0 3
105283: PUSH
105284: LD_INT 24
105286: EQUAL
105287: IFFALSE 105297
// sShovel := true ;
105289: LD_ADDR_EXP 197
105293: PUSH
105294: LD_INT 1
105296: ST_TO_ADDR
// if p3 = 25 then
105297: LD_VAR 0 3
105301: PUSH
105302: LD_INT 25
105304: EQUAL
105305: IFFALSE 105315
// sSheik := true ;
105307: LD_ADDR_EXP 198
105311: PUSH
105312: LD_INT 1
105314: ST_TO_ADDR
// if p3 = 26 then
105315: LD_VAR 0 3
105319: PUSH
105320: LD_INT 26
105322: EQUAL
105323: IFFALSE 105333
// sEarthquake := true ;
105325: LD_ADDR_EXP 200
105329: PUSH
105330: LD_INT 1
105332: ST_TO_ADDR
// if p3 = 27 then
105333: LD_VAR 0 3
105337: PUSH
105338: LD_INT 27
105340: EQUAL
105341: IFFALSE 105351
// sAI := true ;
105343: LD_ADDR_EXP 201
105347: PUSH
105348: LD_INT 1
105350: ST_TO_ADDR
// if p3 = 28 then
105351: LD_VAR 0 3
105355: PUSH
105356: LD_INT 28
105358: EQUAL
105359: IFFALSE 105369
// sCargo := true ;
105361: LD_ADDR_EXP 204
105365: PUSH
105366: LD_INT 1
105368: ST_TO_ADDR
// if p3 = 29 then
105369: LD_VAR 0 3
105373: PUSH
105374: LD_INT 29
105376: EQUAL
105377: IFFALSE 105387
// sDLaser := true ;
105379: LD_ADDR_EXP 205
105383: PUSH
105384: LD_INT 1
105386: ST_TO_ADDR
// if p3 = 30 then
105387: LD_VAR 0 3
105391: PUSH
105392: LD_INT 30
105394: EQUAL
105395: IFFALSE 105405
// sExchange := true ;
105397: LD_ADDR_EXP 206
105401: PUSH
105402: LD_INT 1
105404: ST_TO_ADDR
// if p3 = 31 then
105405: LD_VAR 0 3
105409: PUSH
105410: LD_INT 31
105412: EQUAL
105413: IFFALSE 105423
// sFac := true ;
105415: LD_ADDR_EXP 207
105419: PUSH
105420: LD_INT 1
105422: ST_TO_ADDR
// if p3 = 32 then
105423: LD_VAR 0 3
105427: PUSH
105428: LD_INT 32
105430: EQUAL
105431: IFFALSE 105441
// sPower := true ;
105433: LD_ADDR_EXP 208
105437: PUSH
105438: LD_INT 1
105440: ST_TO_ADDR
// if p3 = 33 then
105441: LD_VAR 0 3
105445: PUSH
105446: LD_INT 33
105448: EQUAL
105449: IFFALSE 105459
// sRandom := true ;
105451: LD_ADDR_EXP 209
105455: PUSH
105456: LD_INT 1
105458: ST_TO_ADDR
// if p3 = 34 then
105459: LD_VAR 0 3
105463: PUSH
105464: LD_INT 34
105466: EQUAL
105467: IFFALSE 105477
// sShield := true ;
105469: LD_ADDR_EXP 210
105473: PUSH
105474: LD_INT 1
105476: ST_TO_ADDR
// if p3 = 35 then
105477: LD_VAR 0 3
105481: PUSH
105482: LD_INT 35
105484: EQUAL
105485: IFFALSE 105495
// sTime := true ;
105487: LD_ADDR_EXP 211
105491: PUSH
105492: LD_INT 1
105494: ST_TO_ADDR
// if p3 = 36 then
105495: LD_VAR 0 3
105499: PUSH
105500: LD_INT 36
105502: EQUAL
105503: IFFALSE 105513
// sTools := true ;
105505: LD_ADDR_EXP 212
105509: PUSH
105510: LD_INT 1
105512: ST_TO_ADDR
// if p3 = 101 then
105513: LD_VAR 0 3
105517: PUSH
105518: LD_INT 101
105520: EQUAL
105521: IFFALSE 105531
// sSold := true ;
105523: LD_ADDR_EXP 177
105527: PUSH
105528: LD_INT 1
105530: ST_TO_ADDR
// if p3 = 102 then
105531: LD_VAR 0 3
105535: PUSH
105536: LD_INT 102
105538: EQUAL
105539: IFFALSE 105549
// sDiff := true ;
105541: LD_ADDR_EXP 178
105545: PUSH
105546: LD_INT 1
105548: ST_TO_ADDR
// if p3 = 103 then
105549: LD_VAR 0 3
105553: PUSH
105554: LD_INT 103
105556: EQUAL
105557: IFFALSE 105567
// sFog := true ;
105559: LD_ADDR_EXP 181
105563: PUSH
105564: LD_INT 1
105566: ST_TO_ADDR
// if p3 = 104 then
105567: LD_VAR 0 3
105571: PUSH
105572: LD_INT 104
105574: EQUAL
105575: IFFALSE 105585
// sReset := true ;
105577: LD_ADDR_EXP 182
105581: PUSH
105582: LD_INT 1
105584: ST_TO_ADDR
// if p3 = 105 then
105585: LD_VAR 0 3
105589: PUSH
105590: LD_INT 105
105592: EQUAL
105593: IFFALSE 105603
// sSun := true ;
105595: LD_ADDR_EXP 183
105599: PUSH
105600: LD_INT 1
105602: ST_TO_ADDR
// if p3 = 106 then
105603: LD_VAR 0 3
105607: PUSH
105608: LD_INT 106
105610: EQUAL
105611: IFFALSE 105621
// sTiger := true ;
105613: LD_ADDR_EXP 179
105617: PUSH
105618: LD_INT 1
105620: ST_TO_ADDR
// if p3 = 107 then
105621: LD_VAR 0 3
105625: PUSH
105626: LD_INT 107
105628: EQUAL
105629: IFFALSE 105639
// sBomb := true ;
105631: LD_ADDR_EXP 180
105635: PUSH
105636: LD_INT 1
105638: ST_TO_ADDR
// if p3 = 108 then
105639: LD_VAR 0 3
105643: PUSH
105644: LD_INT 108
105646: EQUAL
105647: IFFALSE 105657
// sWound := true ;
105649: LD_ADDR_EXP 188
105653: PUSH
105654: LD_INT 1
105656: ST_TO_ADDR
// if p3 = 109 then
105657: LD_VAR 0 3
105661: PUSH
105662: LD_INT 109
105664: EQUAL
105665: IFFALSE 105675
// sBetray := true ;
105667: LD_ADDR_EXP 192
105671: PUSH
105672: LD_INT 1
105674: ST_TO_ADDR
// if p3 = 110 then
105675: LD_VAR 0 3
105679: PUSH
105680: LD_INT 110
105682: EQUAL
105683: IFFALSE 105693
// sContamin := true ;
105685: LD_ADDR_EXP 193
105689: PUSH
105690: LD_INT 1
105692: ST_TO_ADDR
// if p3 = 111 then
105693: LD_VAR 0 3
105697: PUSH
105698: LD_INT 111
105700: EQUAL
105701: IFFALSE 105711
// sOil := true ;
105703: LD_ADDR_EXP 195
105707: PUSH
105708: LD_INT 1
105710: ST_TO_ADDR
// if p3 = 112 then
105711: LD_VAR 0 3
105715: PUSH
105716: LD_INT 112
105718: EQUAL
105719: IFFALSE 105729
// sStu := true ;
105721: LD_ADDR_EXP 199
105725: PUSH
105726: LD_INT 1
105728: ST_TO_ADDR
// if p3 = 113 then
105729: LD_VAR 0 3
105733: PUSH
105734: LD_INT 113
105736: EQUAL
105737: IFFALSE 105747
// sBazooka := true ;
105739: LD_ADDR_EXP 202
105743: PUSH
105744: LD_INT 1
105746: ST_TO_ADDR
// if p3 = 114 then
105747: LD_VAR 0 3
105751: PUSH
105752: LD_INT 114
105754: EQUAL
105755: IFFALSE 105765
// sMortar := true ;
105757: LD_ADDR_EXP 203
105761: PUSH
105762: LD_INT 1
105764: ST_TO_ADDR
// if p3 = 115 then
105765: LD_VAR 0 3
105769: PUSH
105770: LD_INT 115
105772: EQUAL
105773: IFFALSE 105783
// sRanger := true ;
105775: LD_ADDR_EXP 213
105779: PUSH
105780: LD_INT 1
105782: ST_TO_ADDR
// end ; if p2 = 101 then
105783: LD_VAR 0 2
105787: PUSH
105788: LD_INT 101
105790: EQUAL
105791: IFFALSE 105919
// begin case p3 of 1 :
105793: LD_VAR 0 3
105797: PUSH
105798: LD_INT 1
105800: DOUBLE
105801: EQUAL
105802: IFTRUE 105806
105804: GO 105813
105806: POP
// hHackUnlimitedResources ; 2 :
105807: CALL 116956 0 0
105811: GO 105919
105813: LD_INT 2
105815: DOUBLE
105816: EQUAL
105817: IFTRUE 105821
105819: GO 105828
105821: POP
// hHackSetLevel10 ; 3 :
105822: CALL 117089 0 0
105826: GO 105919
105828: LD_INT 3
105830: DOUBLE
105831: EQUAL
105832: IFTRUE 105836
105834: GO 105843
105836: POP
// hHackSetLevel10YourUnits ; 4 :
105837: CALL 117174 0 0
105841: GO 105919
105843: LD_INT 4
105845: DOUBLE
105846: EQUAL
105847: IFTRUE 105851
105849: GO 105858
105851: POP
// hHackInvincible ; 5 :
105852: CALL 117622 0 0
105856: GO 105919
105858: LD_INT 5
105860: DOUBLE
105861: EQUAL
105862: IFTRUE 105866
105864: GO 105873
105866: POP
// hHackInvisible ; 6 :
105867: CALL 117733 0 0
105871: GO 105919
105873: LD_INT 6
105875: DOUBLE
105876: EQUAL
105877: IFTRUE 105881
105879: GO 105888
105881: POP
// hHackChangeYourSide ; 7 :
105882: CALL 117790 0 0
105886: GO 105919
105888: LD_INT 7
105890: DOUBLE
105891: EQUAL
105892: IFTRUE 105896
105894: GO 105903
105896: POP
// hHackChangeUnitSide ; 8 :
105897: CALL 117832 0 0
105901: GO 105919
105903: LD_INT 8
105905: DOUBLE
105906: EQUAL
105907: IFTRUE 105911
105909: GO 105918
105911: POP
// hHackFog ; end ;
105912: CALL 117933 0 0
105916: GO 105919
105918: POP
// end ; end ;
105919: LD_VAR 0 7
105923: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
105924: GO 105926
105926: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
105927: LD_STRING initStreamRollete();
105929: PPUSH
105930: CALL_OW 559
// InitStreamMode ;
105934: CALL 105943 0 0
// DefineStreamItems ( ) ;
105938: CALL 106383 0 0
// end ;
105942: END
// function InitStreamMode ; begin
105943: LD_INT 0
105945: PPUSH
// streamModeActive := false ;
105946: LD_ADDR_EXP 160
105950: PUSH
105951: LD_INT 0
105953: ST_TO_ADDR
// normalCounter := 36 ;
105954: LD_ADDR_EXP 161
105958: PUSH
105959: LD_INT 36
105961: ST_TO_ADDR
// hardcoreCounter := 16 ;
105962: LD_ADDR_EXP 162
105966: PUSH
105967: LD_INT 16
105969: ST_TO_ADDR
// sRocket := false ;
105970: LD_ADDR_EXP 165
105974: PUSH
105975: LD_INT 0
105977: ST_TO_ADDR
// sSpeed := false ;
105978: LD_ADDR_EXP 164
105982: PUSH
105983: LD_INT 0
105985: ST_TO_ADDR
// sEngine := false ;
105986: LD_ADDR_EXP 166
105990: PUSH
105991: LD_INT 0
105993: ST_TO_ADDR
// sSpec := false ;
105994: LD_ADDR_EXP 163
105998: PUSH
105999: LD_INT 0
106001: ST_TO_ADDR
// sLevel := false ;
106002: LD_ADDR_EXP 167
106006: PUSH
106007: LD_INT 0
106009: ST_TO_ADDR
// sArmoury := false ;
106010: LD_ADDR_EXP 168
106014: PUSH
106015: LD_INT 0
106017: ST_TO_ADDR
// sRadar := false ;
106018: LD_ADDR_EXP 169
106022: PUSH
106023: LD_INT 0
106025: ST_TO_ADDR
// sBunker := false ;
106026: LD_ADDR_EXP 170
106030: PUSH
106031: LD_INT 0
106033: ST_TO_ADDR
// sHack := false ;
106034: LD_ADDR_EXP 171
106038: PUSH
106039: LD_INT 0
106041: ST_TO_ADDR
// sFire := false ;
106042: LD_ADDR_EXP 172
106046: PUSH
106047: LD_INT 0
106049: ST_TO_ADDR
// sRefresh := false ;
106050: LD_ADDR_EXP 173
106054: PUSH
106055: LD_INT 0
106057: ST_TO_ADDR
// sExp := false ;
106058: LD_ADDR_EXP 174
106062: PUSH
106063: LD_INT 0
106065: ST_TO_ADDR
// sDepot := false ;
106066: LD_ADDR_EXP 175
106070: PUSH
106071: LD_INT 0
106073: ST_TO_ADDR
// sFlag := false ;
106074: LD_ADDR_EXP 176
106078: PUSH
106079: LD_INT 0
106081: ST_TO_ADDR
// sKamikadze := false ;
106082: LD_ADDR_EXP 184
106086: PUSH
106087: LD_INT 0
106089: ST_TO_ADDR
// sTroll := false ;
106090: LD_ADDR_EXP 185
106094: PUSH
106095: LD_INT 0
106097: ST_TO_ADDR
// sSlow := false ;
106098: LD_ADDR_EXP 186
106102: PUSH
106103: LD_INT 0
106105: ST_TO_ADDR
// sLack := false ;
106106: LD_ADDR_EXP 187
106110: PUSH
106111: LD_INT 0
106113: ST_TO_ADDR
// sTank := false ;
106114: LD_ADDR_EXP 189
106118: PUSH
106119: LD_INT 0
106121: ST_TO_ADDR
// sRemote := false ;
106122: LD_ADDR_EXP 190
106126: PUSH
106127: LD_INT 0
106129: ST_TO_ADDR
// sPowell := false ;
106130: LD_ADDR_EXP 191
106134: PUSH
106135: LD_INT 0
106137: ST_TO_ADDR
// sTeleport := false ;
106138: LD_ADDR_EXP 194
106142: PUSH
106143: LD_INT 0
106145: ST_TO_ADDR
// sOilTower := false ;
106146: LD_ADDR_EXP 196
106150: PUSH
106151: LD_INT 0
106153: ST_TO_ADDR
// sShovel := false ;
106154: LD_ADDR_EXP 197
106158: PUSH
106159: LD_INT 0
106161: ST_TO_ADDR
// sSheik := false ;
106162: LD_ADDR_EXP 198
106166: PUSH
106167: LD_INT 0
106169: ST_TO_ADDR
// sEarthquake := false ;
106170: LD_ADDR_EXP 200
106174: PUSH
106175: LD_INT 0
106177: ST_TO_ADDR
// sAI := false ;
106178: LD_ADDR_EXP 201
106182: PUSH
106183: LD_INT 0
106185: ST_TO_ADDR
// sCargo := false ;
106186: LD_ADDR_EXP 204
106190: PUSH
106191: LD_INT 0
106193: ST_TO_ADDR
// sDLaser := false ;
106194: LD_ADDR_EXP 205
106198: PUSH
106199: LD_INT 0
106201: ST_TO_ADDR
// sExchange := false ;
106202: LD_ADDR_EXP 206
106206: PUSH
106207: LD_INT 0
106209: ST_TO_ADDR
// sFac := false ;
106210: LD_ADDR_EXP 207
106214: PUSH
106215: LD_INT 0
106217: ST_TO_ADDR
// sPower := false ;
106218: LD_ADDR_EXP 208
106222: PUSH
106223: LD_INT 0
106225: ST_TO_ADDR
// sRandom := false ;
106226: LD_ADDR_EXP 209
106230: PUSH
106231: LD_INT 0
106233: ST_TO_ADDR
// sShield := false ;
106234: LD_ADDR_EXP 210
106238: PUSH
106239: LD_INT 0
106241: ST_TO_ADDR
// sTime := false ;
106242: LD_ADDR_EXP 211
106246: PUSH
106247: LD_INT 0
106249: ST_TO_ADDR
// sTools := false ;
106250: LD_ADDR_EXP 212
106254: PUSH
106255: LD_INT 0
106257: ST_TO_ADDR
// sSold := false ;
106258: LD_ADDR_EXP 177
106262: PUSH
106263: LD_INT 0
106265: ST_TO_ADDR
// sDiff := false ;
106266: LD_ADDR_EXP 178
106270: PUSH
106271: LD_INT 0
106273: ST_TO_ADDR
// sFog := false ;
106274: LD_ADDR_EXP 181
106278: PUSH
106279: LD_INT 0
106281: ST_TO_ADDR
// sReset := false ;
106282: LD_ADDR_EXP 182
106286: PUSH
106287: LD_INT 0
106289: ST_TO_ADDR
// sSun := false ;
106290: LD_ADDR_EXP 183
106294: PUSH
106295: LD_INT 0
106297: ST_TO_ADDR
// sTiger := false ;
106298: LD_ADDR_EXP 179
106302: PUSH
106303: LD_INT 0
106305: ST_TO_ADDR
// sBomb := false ;
106306: LD_ADDR_EXP 180
106310: PUSH
106311: LD_INT 0
106313: ST_TO_ADDR
// sWound := false ;
106314: LD_ADDR_EXP 188
106318: PUSH
106319: LD_INT 0
106321: ST_TO_ADDR
// sBetray := false ;
106322: LD_ADDR_EXP 192
106326: PUSH
106327: LD_INT 0
106329: ST_TO_ADDR
// sContamin := false ;
106330: LD_ADDR_EXP 193
106334: PUSH
106335: LD_INT 0
106337: ST_TO_ADDR
// sOil := false ;
106338: LD_ADDR_EXP 195
106342: PUSH
106343: LD_INT 0
106345: ST_TO_ADDR
// sStu := false ;
106346: LD_ADDR_EXP 199
106350: PUSH
106351: LD_INT 0
106353: ST_TO_ADDR
// sBazooka := false ;
106354: LD_ADDR_EXP 202
106358: PUSH
106359: LD_INT 0
106361: ST_TO_ADDR
// sMortar := false ;
106362: LD_ADDR_EXP 203
106366: PUSH
106367: LD_INT 0
106369: ST_TO_ADDR
// sRanger := false ;
106370: LD_ADDR_EXP 213
106374: PUSH
106375: LD_INT 0
106377: ST_TO_ADDR
// end ;
106378: LD_VAR 0 1
106382: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
106383: LD_INT 0
106385: PPUSH
106386: PPUSH
106387: PPUSH
106388: PPUSH
106389: PPUSH
// result := [ ] ;
106390: LD_ADDR_VAR 0 1
106394: PUSH
106395: EMPTY
106396: ST_TO_ADDR
// if campaign_id = 1 then
106397: LD_OWVAR 69
106401: PUSH
106402: LD_INT 1
106404: EQUAL
106405: IFFALSE 109343
// begin case mission_number of 1 :
106407: LD_OWVAR 70
106411: PUSH
106412: LD_INT 1
106414: DOUBLE
106415: EQUAL
106416: IFTRUE 106420
106418: GO 106484
106420: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
106421: LD_ADDR_VAR 0 1
106425: PUSH
106426: LD_INT 2
106428: PUSH
106429: LD_INT 4
106431: PUSH
106432: LD_INT 11
106434: PUSH
106435: LD_INT 12
106437: PUSH
106438: LD_INT 15
106440: PUSH
106441: LD_INT 16
106443: PUSH
106444: LD_INT 22
106446: PUSH
106447: LD_INT 23
106449: PUSH
106450: LD_INT 26
106452: PUSH
106453: EMPTY
106454: LIST
106455: LIST
106456: LIST
106457: LIST
106458: LIST
106459: LIST
106460: LIST
106461: LIST
106462: LIST
106463: PUSH
106464: LD_INT 101
106466: PUSH
106467: LD_INT 102
106469: PUSH
106470: LD_INT 106
106472: PUSH
106473: EMPTY
106474: LIST
106475: LIST
106476: LIST
106477: PUSH
106478: EMPTY
106479: LIST
106480: LIST
106481: ST_TO_ADDR
106482: GO 109341
106484: LD_INT 2
106486: DOUBLE
106487: EQUAL
106488: IFTRUE 106492
106490: GO 106564
106492: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
106493: LD_ADDR_VAR 0 1
106497: PUSH
106498: LD_INT 2
106500: PUSH
106501: LD_INT 4
106503: PUSH
106504: LD_INT 11
106506: PUSH
106507: LD_INT 12
106509: PUSH
106510: LD_INT 15
106512: PUSH
106513: LD_INT 16
106515: PUSH
106516: LD_INT 22
106518: PUSH
106519: LD_INT 23
106521: PUSH
106522: LD_INT 26
106524: PUSH
106525: EMPTY
106526: LIST
106527: LIST
106528: LIST
106529: LIST
106530: LIST
106531: LIST
106532: LIST
106533: LIST
106534: LIST
106535: PUSH
106536: LD_INT 101
106538: PUSH
106539: LD_INT 102
106541: PUSH
106542: LD_INT 105
106544: PUSH
106545: LD_INT 106
106547: PUSH
106548: LD_INT 108
106550: PUSH
106551: EMPTY
106552: LIST
106553: LIST
106554: LIST
106555: LIST
106556: LIST
106557: PUSH
106558: EMPTY
106559: LIST
106560: LIST
106561: ST_TO_ADDR
106562: GO 109341
106564: LD_INT 3
106566: DOUBLE
106567: EQUAL
106568: IFTRUE 106572
106570: GO 106648
106572: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
106573: LD_ADDR_VAR 0 1
106577: PUSH
106578: LD_INT 2
106580: PUSH
106581: LD_INT 4
106583: PUSH
106584: LD_INT 5
106586: PUSH
106587: LD_INT 11
106589: PUSH
106590: LD_INT 12
106592: PUSH
106593: LD_INT 15
106595: PUSH
106596: LD_INT 16
106598: PUSH
106599: LD_INT 22
106601: PUSH
106602: LD_INT 26
106604: PUSH
106605: LD_INT 36
106607: PUSH
106608: EMPTY
106609: LIST
106610: LIST
106611: LIST
106612: LIST
106613: LIST
106614: LIST
106615: LIST
106616: LIST
106617: LIST
106618: LIST
106619: PUSH
106620: LD_INT 101
106622: PUSH
106623: LD_INT 102
106625: PUSH
106626: LD_INT 105
106628: PUSH
106629: LD_INT 106
106631: PUSH
106632: LD_INT 108
106634: PUSH
106635: EMPTY
106636: LIST
106637: LIST
106638: LIST
106639: LIST
106640: LIST
106641: PUSH
106642: EMPTY
106643: LIST
106644: LIST
106645: ST_TO_ADDR
106646: GO 109341
106648: LD_INT 4
106650: DOUBLE
106651: EQUAL
106652: IFTRUE 106656
106654: GO 106740
106656: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
106657: LD_ADDR_VAR 0 1
106661: PUSH
106662: LD_INT 2
106664: PUSH
106665: LD_INT 4
106667: PUSH
106668: LD_INT 5
106670: PUSH
106671: LD_INT 8
106673: PUSH
106674: LD_INT 11
106676: PUSH
106677: LD_INT 12
106679: PUSH
106680: LD_INT 15
106682: PUSH
106683: LD_INT 16
106685: PUSH
106686: LD_INT 22
106688: PUSH
106689: LD_INT 23
106691: PUSH
106692: LD_INT 26
106694: PUSH
106695: LD_INT 36
106697: PUSH
106698: EMPTY
106699: LIST
106700: LIST
106701: LIST
106702: LIST
106703: LIST
106704: LIST
106705: LIST
106706: LIST
106707: LIST
106708: LIST
106709: LIST
106710: LIST
106711: PUSH
106712: LD_INT 101
106714: PUSH
106715: LD_INT 102
106717: PUSH
106718: LD_INT 105
106720: PUSH
106721: LD_INT 106
106723: PUSH
106724: LD_INT 108
106726: PUSH
106727: EMPTY
106728: LIST
106729: LIST
106730: LIST
106731: LIST
106732: LIST
106733: PUSH
106734: EMPTY
106735: LIST
106736: LIST
106737: ST_TO_ADDR
106738: GO 109341
106740: LD_INT 5
106742: DOUBLE
106743: EQUAL
106744: IFTRUE 106748
106746: GO 106848
106748: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
106749: LD_ADDR_VAR 0 1
106753: PUSH
106754: LD_INT 2
106756: PUSH
106757: LD_INT 4
106759: PUSH
106760: LD_INT 5
106762: PUSH
106763: LD_INT 6
106765: PUSH
106766: LD_INT 8
106768: PUSH
106769: LD_INT 11
106771: PUSH
106772: LD_INT 12
106774: PUSH
106775: LD_INT 15
106777: PUSH
106778: LD_INT 16
106780: PUSH
106781: LD_INT 22
106783: PUSH
106784: LD_INT 23
106786: PUSH
106787: LD_INT 25
106789: PUSH
106790: LD_INT 26
106792: PUSH
106793: LD_INT 36
106795: PUSH
106796: EMPTY
106797: LIST
106798: LIST
106799: LIST
106800: LIST
106801: LIST
106802: LIST
106803: LIST
106804: LIST
106805: LIST
106806: LIST
106807: LIST
106808: LIST
106809: LIST
106810: LIST
106811: PUSH
106812: LD_INT 101
106814: PUSH
106815: LD_INT 102
106817: PUSH
106818: LD_INT 105
106820: PUSH
106821: LD_INT 106
106823: PUSH
106824: LD_INT 108
106826: PUSH
106827: LD_INT 109
106829: PUSH
106830: LD_INT 112
106832: PUSH
106833: EMPTY
106834: LIST
106835: LIST
106836: LIST
106837: LIST
106838: LIST
106839: LIST
106840: LIST
106841: PUSH
106842: EMPTY
106843: LIST
106844: LIST
106845: ST_TO_ADDR
106846: GO 109341
106848: LD_INT 6
106850: DOUBLE
106851: EQUAL
106852: IFTRUE 106856
106854: GO 106976
106856: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
106857: LD_ADDR_VAR 0 1
106861: PUSH
106862: LD_INT 2
106864: PUSH
106865: LD_INT 4
106867: PUSH
106868: LD_INT 5
106870: PUSH
106871: LD_INT 6
106873: PUSH
106874: LD_INT 8
106876: PUSH
106877: LD_INT 11
106879: PUSH
106880: LD_INT 12
106882: PUSH
106883: LD_INT 15
106885: PUSH
106886: LD_INT 16
106888: PUSH
106889: LD_INT 20
106891: PUSH
106892: LD_INT 21
106894: PUSH
106895: LD_INT 22
106897: PUSH
106898: LD_INT 23
106900: PUSH
106901: LD_INT 25
106903: PUSH
106904: LD_INT 26
106906: PUSH
106907: LD_INT 30
106909: PUSH
106910: LD_INT 31
106912: PUSH
106913: LD_INT 32
106915: PUSH
106916: LD_INT 36
106918: PUSH
106919: EMPTY
106920: LIST
106921: LIST
106922: LIST
106923: LIST
106924: LIST
106925: LIST
106926: LIST
106927: LIST
106928: LIST
106929: LIST
106930: LIST
106931: LIST
106932: LIST
106933: LIST
106934: LIST
106935: LIST
106936: LIST
106937: LIST
106938: LIST
106939: PUSH
106940: LD_INT 101
106942: PUSH
106943: LD_INT 102
106945: PUSH
106946: LD_INT 105
106948: PUSH
106949: LD_INT 106
106951: PUSH
106952: LD_INT 108
106954: PUSH
106955: LD_INT 109
106957: PUSH
106958: LD_INT 112
106960: PUSH
106961: EMPTY
106962: LIST
106963: LIST
106964: LIST
106965: LIST
106966: LIST
106967: LIST
106968: LIST
106969: PUSH
106970: EMPTY
106971: LIST
106972: LIST
106973: ST_TO_ADDR
106974: GO 109341
106976: LD_INT 7
106978: DOUBLE
106979: EQUAL
106980: IFTRUE 106984
106982: GO 107084
106984: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
106985: LD_ADDR_VAR 0 1
106989: PUSH
106990: LD_INT 2
106992: PUSH
106993: LD_INT 4
106995: PUSH
106996: LD_INT 5
106998: PUSH
106999: LD_INT 7
107001: PUSH
107002: LD_INT 11
107004: PUSH
107005: LD_INT 12
107007: PUSH
107008: LD_INT 15
107010: PUSH
107011: LD_INT 16
107013: PUSH
107014: LD_INT 20
107016: PUSH
107017: LD_INT 21
107019: PUSH
107020: LD_INT 22
107022: PUSH
107023: LD_INT 23
107025: PUSH
107026: LD_INT 25
107028: PUSH
107029: LD_INT 26
107031: PUSH
107032: EMPTY
107033: LIST
107034: LIST
107035: LIST
107036: LIST
107037: LIST
107038: LIST
107039: LIST
107040: LIST
107041: LIST
107042: LIST
107043: LIST
107044: LIST
107045: LIST
107046: LIST
107047: PUSH
107048: LD_INT 101
107050: PUSH
107051: LD_INT 102
107053: PUSH
107054: LD_INT 103
107056: PUSH
107057: LD_INT 105
107059: PUSH
107060: LD_INT 106
107062: PUSH
107063: LD_INT 108
107065: PUSH
107066: LD_INT 112
107068: PUSH
107069: EMPTY
107070: LIST
107071: LIST
107072: LIST
107073: LIST
107074: LIST
107075: LIST
107076: LIST
107077: PUSH
107078: EMPTY
107079: LIST
107080: LIST
107081: ST_TO_ADDR
107082: GO 109341
107084: LD_INT 8
107086: DOUBLE
107087: EQUAL
107088: IFTRUE 107092
107090: GO 107220
107092: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
107093: LD_ADDR_VAR 0 1
107097: PUSH
107098: LD_INT 2
107100: PUSH
107101: LD_INT 4
107103: PUSH
107104: LD_INT 5
107106: PUSH
107107: LD_INT 6
107109: PUSH
107110: LD_INT 7
107112: PUSH
107113: LD_INT 8
107115: PUSH
107116: LD_INT 11
107118: PUSH
107119: LD_INT 12
107121: PUSH
107122: LD_INT 15
107124: PUSH
107125: LD_INT 16
107127: PUSH
107128: LD_INT 20
107130: PUSH
107131: LD_INT 21
107133: PUSH
107134: LD_INT 22
107136: PUSH
107137: LD_INT 23
107139: PUSH
107140: LD_INT 25
107142: PUSH
107143: LD_INT 26
107145: PUSH
107146: LD_INT 30
107148: PUSH
107149: LD_INT 31
107151: PUSH
107152: LD_INT 32
107154: PUSH
107155: LD_INT 36
107157: PUSH
107158: EMPTY
107159: LIST
107160: LIST
107161: LIST
107162: LIST
107163: LIST
107164: LIST
107165: LIST
107166: LIST
107167: LIST
107168: LIST
107169: LIST
107170: LIST
107171: LIST
107172: LIST
107173: LIST
107174: LIST
107175: LIST
107176: LIST
107177: LIST
107178: LIST
107179: PUSH
107180: LD_INT 101
107182: PUSH
107183: LD_INT 102
107185: PUSH
107186: LD_INT 103
107188: PUSH
107189: LD_INT 105
107191: PUSH
107192: LD_INT 106
107194: PUSH
107195: LD_INT 108
107197: PUSH
107198: LD_INT 109
107200: PUSH
107201: LD_INT 112
107203: PUSH
107204: EMPTY
107205: LIST
107206: LIST
107207: LIST
107208: LIST
107209: LIST
107210: LIST
107211: LIST
107212: LIST
107213: PUSH
107214: EMPTY
107215: LIST
107216: LIST
107217: ST_TO_ADDR
107218: GO 109341
107220: LD_INT 9
107222: DOUBLE
107223: EQUAL
107224: IFTRUE 107228
107226: GO 107364
107228: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
107229: LD_ADDR_VAR 0 1
107233: PUSH
107234: LD_INT 2
107236: PUSH
107237: LD_INT 4
107239: PUSH
107240: LD_INT 5
107242: PUSH
107243: LD_INT 6
107245: PUSH
107246: LD_INT 7
107248: PUSH
107249: LD_INT 8
107251: PUSH
107252: LD_INT 11
107254: PUSH
107255: LD_INT 12
107257: PUSH
107258: LD_INT 15
107260: PUSH
107261: LD_INT 16
107263: PUSH
107264: LD_INT 20
107266: PUSH
107267: LD_INT 21
107269: PUSH
107270: LD_INT 22
107272: PUSH
107273: LD_INT 23
107275: PUSH
107276: LD_INT 25
107278: PUSH
107279: LD_INT 26
107281: PUSH
107282: LD_INT 28
107284: PUSH
107285: LD_INT 30
107287: PUSH
107288: LD_INT 31
107290: PUSH
107291: LD_INT 32
107293: PUSH
107294: LD_INT 36
107296: PUSH
107297: EMPTY
107298: LIST
107299: LIST
107300: LIST
107301: LIST
107302: LIST
107303: LIST
107304: LIST
107305: LIST
107306: LIST
107307: LIST
107308: LIST
107309: LIST
107310: LIST
107311: LIST
107312: LIST
107313: LIST
107314: LIST
107315: LIST
107316: LIST
107317: LIST
107318: LIST
107319: PUSH
107320: LD_INT 101
107322: PUSH
107323: LD_INT 102
107325: PUSH
107326: LD_INT 103
107328: PUSH
107329: LD_INT 105
107331: PUSH
107332: LD_INT 106
107334: PUSH
107335: LD_INT 108
107337: PUSH
107338: LD_INT 109
107340: PUSH
107341: LD_INT 112
107343: PUSH
107344: LD_INT 114
107346: PUSH
107347: EMPTY
107348: LIST
107349: LIST
107350: LIST
107351: LIST
107352: LIST
107353: LIST
107354: LIST
107355: LIST
107356: LIST
107357: PUSH
107358: EMPTY
107359: LIST
107360: LIST
107361: ST_TO_ADDR
107362: GO 109341
107364: LD_INT 10
107366: DOUBLE
107367: EQUAL
107368: IFTRUE 107372
107370: GO 107556
107372: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
107373: LD_ADDR_VAR 0 1
107377: PUSH
107378: LD_INT 2
107380: PUSH
107381: LD_INT 4
107383: PUSH
107384: LD_INT 5
107386: PUSH
107387: LD_INT 6
107389: PUSH
107390: LD_INT 7
107392: PUSH
107393: LD_INT 8
107395: PUSH
107396: LD_INT 9
107398: PUSH
107399: LD_INT 10
107401: PUSH
107402: LD_INT 11
107404: PUSH
107405: LD_INT 12
107407: PUSH
107408: LD_INT 13
107410: PUSH
107411: LD_INT 14
107413: PUSH
107414: LD_INT 15
107416: PUSH
107417: LD_INT 16
107419: PUSH
107420: LD_INT 17
107422: PUSH
107423: LD_INT 18
107425: PUSH
107426: LD_INT 19
107428: PUSH
107429: LD_INT 20
107431: PUSH
107432: LD_INT 21
107434: PUSH
107435: LD_INT 22
107437: PUSH
107438: LD_INT 23
107440: PUSH
107441: LD_INT 24
107443: PUSH
107444: LD_INT 25
107446: PUSH
107447: LD_INT 26
107449: PUSH
107450: LD_INT 28
107452: PUSH
107453: LD_INT 30
107455: PUSH
107456: LD_INT 31
107458: PUSH
107459: LD_INT 32
107461: PUSH
107462: LD_INT 36
107464: PUSH
107465: EMPTY
107466: LIST
107467: LIST
107468: LIST
107469: LIST
107470: LIST
107471: LIST
107472: LIST
107473: LIST
107474: LIST
107475: LIST
107476: LIST
107477: LIST
107478: LIST
107479: LIST
107480: LIST
107481: LIST
107482: LIST
107483: LIST
107484: LIST
107485: LIST
107486: LIST
107487: LIST
107488: LIST
107489: LIST
107490: LIST
107491: LIST
107492: LIST
107493: LIST
107494: LIST
107495: PUSH
107496: LD_INT 101
107498: PUSH
107499: LD_INT 102
107501: PUSH
107502: LD_INT 103
107504: PUSH
107505: LD_INT 104
107507: PUSH
107508: LD_INT 105
107510: PUSH
107511: LD_INT 106
107513: PUSH
107514: LD_INT 107
107516: PUSH
107517: LD_INT 108
107519: PUSH
107520: LD_INT 109
107522: PUSH
107523: LD_INT 110
107525: PUSH
107526: LD_INT 111
107528: PUSH
107529: LD_INT 112
107531: PUSH
107532: LD_INT 114
107534: PUSH
107535: EMPTY
107536: LIST
107537: LIST
107538: LIST
107539: LIST
107540: LIST
107541: LIST
107542: LIST
107543: LIST
107544: LIST
107545: LIST
107546: LIST
107547: LIST
107548: LIST
107549: PUSH
107550: EMPTY
107551: LIST
107552: LIST
107553: ST_TO_ADDR
107554: GO 109341
107556: LD_INT 11
107558: DOUBLE
107559: EQUAL
107560: IFTRUE 107564
107562: GO 107756
107564: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
107565: LD_ADDR_VAR 0 1
107569: PUSH
107570: LD_INT 2
107572: PUSH
107573: LD_INT 3
107575: PUSH
107576: LD_INT 4
107578: PUSH
107579: LD_INT 5
107581: PUSH
107582: LD_INT 6
107584: PUSH
107585: LD_INT 7
107587: PUSH
107588: LD_INT 8
107590: PUSH
107591: LD_INT 9
107593: PUSH
107594: LD_INT 10
107596: PUSH
107597: LD_INT 11
107599: PUSH
107600: LD_INT 12
107602: PUSH
107603: LD_INT 13
107605: PUSH
107606: LD_INT 14
107608: PUSH
107609: LD_INT 15
107611: PUSH
107612: LD_INT 16
107614: PUSH
107615: LD_INT 17
107617: PUSH
107618: LD_INT 18
107620: PUSH
107621: LD_INT 19
107623: PUSH
107624: LD_INT 20
107626: PUSH
107627: LD_INT 21
107629: PUSH
107630: LD_INT 22
107632: PUSH
107633: LD_INT 23
107635: PUSH
107636: LD_INT 24
107638: PUSH
107639: LD_INT 25
107641: PUSH
107642: LD_INT 26
107644: PUSH
107645: LD_INT 28
107647: PUSH
107648: LD_INT 30
107650: PUSH
107651: LD_INT 31
107653: PUSH
107654: LD_INT 32
107656: PUSH
107657: LD_INT 34
107659: PUSH
107660: LD_INT 36
107662: PUSH
107663: EMPTY
107664: LIST
107665: LIST
107666: LIST
107667: LIST
107668: LIST
107669: LIST
107670: LIST
107671: LIST
107672: LIST
107673: LIST
107674: LIST
107675: LIST
107676: LIST
107677: LIST
107678: LIST
107679: LIST
107680: LIST
107681: LIST
107682: LIST
107683: LIST
107684: LIST
107685: LIST
107686: LIST
107687: LIST
107688: LIST
107689: LIST
107690: LIST
107691: LIST
107692: LIST
107693: LIST
107694: LIST
107695: PUSH
107696: LD_INT 101
107698: PUSH
107699: LD_INT 102
107701: PUSH
107702: LD_INT 103
107704: PUSH
107705: LD_INT 104
107707: PUSH
107708: LD_INT 105
107710: PUSH
107711: LD_INT 106
107713: PUSH
107714: LD_INT 107
107716: PUSH
107717: LD_INT 108
107719: PUSH
107720: LD_INT 109
107722: PUSH
107723: LD_INT 110
107725: PUSH
107726: LD_INT 111
107728: PUSH
107729: LD_INT 112
107731: PUSH
107732: LD_INT 114
107734: PUSH
107735: EMPTY
107736: LIST
107737: LIST
107738: LIST
107739: LIST
107740: LIST
107741: LIST
107742: LIST
107743: LIST
107744: LIST
107745: LIST
107746: LIST
107747: LIST
107748: LIST
107749: PUSH
107750: EMPTY
107751: LIST
107752: LIST
107753: ST_TO_ADDR
107754: GO 109341
107756: LD_INT 12
107758: DOUBLE
107759: EQUAL
107760: IFTRUE 107764
107762: GO 107972
107764: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
107765: LD_ADDR_VAR 0 1
107769: PUSH
107770: LD_INT 1
107772: PUSH
107773: LD_INT 2
107775: PUSH
107776: LD_INT 3
107778: PUSH
107779: LD_INT 4
107781: PUSH
107782: LD_INT 5
107784: PUSH
107785: LD_INT 6
107787: PUSH
107788: LD_INT 7
107790: PUSH
107791: LD_INT 8
107793: PUSH
107794: LD_INT 9
107796: PUSH
107797: LD_INT 10
107799: PUSH
107800: LD_INT 11
107802: PUSH
107803: LD_INT 12
107805: PUSH
107806: LD_INT 13
107808: PUSH
107809: LD_INT 14
107811: PUSH
107812: LD_INT 15
107814: PUSH
107815: LD_INT 16
107817: PUSH
107818: LD_INT 17
107820: PUSH
107821: LD_INT 18
107823: PUSH
107824: LD_INT 19
107826: PUSH
107827: LD_INT 20
107829: PUSH
107830: LD_INT 21
107832: PUSH
107833: LD_INT 22
107835: PUSH
107836: LD_INT 23
107838: PUSH
107839: LD_INT 24
107841: PUSH
107842: LD_INT 25
107844: PUSH
107845: LD_INT 26
107847: PUSH
107848: LD_INT 27
107850: PUSH
107851: LD_INT 28
107853: PUSH
107854: LD_INT 30
107856: PUSH
107857: LD_INT 31
107859: PUSH
107860: LD_INT 32
107862: PUSH
107863: LD_INT 33
107865: PUSH
107866: LD_INT 34
107868: PUSH
107869: LD_INT 36
107871: PUSH
107872: EMPTY
107873: LIST
107874: LIST
107875: LIST
107876: LIST
107877: LIST
107878: LIST
107879: LIST
107880: LIST
107881: LIST
107882: LIST
107883: LIST
107884: LIST
107885: LIST
107886: LIST
107887: LIST
107888: LIST
107889: LIST
107890: LIST
107891: LIST
107892: LIST
107893: LIST
107894: LIST
107895: LIST
107896: LIST
107897: LIST
107898: LIST
107899: LIST
107900: LIST
107901: LIST
107902: LIST
107903: LIST
107904: LIST
107905: LIST
107906: LIST
107907: PUSH
107908: LD_INT 101
107910: PUSH
107911: LD_INT 102
107913: PUSH
107914: LD_INT 103
107916: PUSH
107917: LD_INT 104
107919: PUSH
107920: LD_INT 105
107922: PUSH
107923: LD_INT 106
107925: PUSH
107926: LD_INT 107
107928: PUSH
107929: LD_INT 108
107931: PUSH
107932: LD_INT 109
107934: PUSH
107935: LD_INT 110
107937: PUSH
107938: LD_INT 111
107940: PUSH
107941: LD_INT 112
107943: PUSH
107944: LD_INT 113
107946: PUSH
107947: LD_INT 114
107949: PUSH
107950: EMPTY
107951: LIST
107952: LIST
107953: LIST
107954: LIST
107955: LIST
107956: LIST
107957: LIST
107958: LIST
107959: LIST
107960: LIST
107961: LIST
107962: LIST
107963: LIST
107964: LIST
107965: PUSH
107966: EMPTY
107967: LIST
107968: LIST
107969: ST_TO_ADDR
107970: GO 109341
107972: LD_INT 13
107974: DOUBLE
107975: EQUAL
107976: IFTRUE 107980
107978: GO 108176
107980: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
107981: LD_ADDR_VAR 0 1
107985: PUSH
107986: LD_INT 1
107988: PUSH
107989: LD_INT 2
107991: PUSH
107992: LD_INT 3
107994: PUSH
107995: LD_INT 4
107997: PUSH
107998: LD_INT 5
108000: PUSH
108001: LD_INT 8
108003: PUSH
108004: LD_INT 9
108006: PUSH
108007: LD_INT 10
108009: PUSH
108010: LD_INT 11
108012: PUSH
108013: LD_INT 12
108015: PUSH
108016: LD_INT 14
108018: PUSH
108019: LD_INT 15
108021: PUSH
108022: LD_INT 16
108024: PUSH
108025: LD_INT 17
108027: PUSH
108028: LD_INT 18
108030: PUSH
108031: LD_INT 19
108033: PUSH
108034: LD_INT 20
108036: PUSH
108037: LD_INT 21
108039: PUSH
108040: LD_INT 22
108042: PUSH
108043: LD_INT 23
108045: PUSH
108046: LD_INT 24
108048: PUSH
108049: LD_INT 25
108051: PUSH
108052: LD_INT 26
108054: PUSH
108055: LD_INT 27
108057: PUSH
108058: LD_INT 28
108060: PUSH
108061: LD_INT 30
108063: PUSH
108064: LD_INT 31
108066: PUSH
108067: LD_INT 32
108069: PUSH
108070: LD_INT 33
108072: PUSH
108073: LD_INT 34
108075: PUSH
108076: LD_INT 36
108078: PUSH
108079: EMPTY
108080: LIST
108081: LIST
108082: LIST
108083: LIST
108084: LIST
108085: LIST
108086: LIST
108087: LIST
108088: LIST
108089: LIST
108090: LIST
108091: LIST
108092: LIST
108093: LIST
108094: LIST
108095: LIST
108096: LIST
108097: LIST
108098: LIST
108099: LIST
108100: LIST
108101: LIST
108102: LIST
108103: LIST
108104: LIST
108105: LIST
108106: LIST
108107: LIST
108108: LIST
108109: LIST
108110: LIST
108111: PUSH
108112: LD_INT 101
108114: PUSH
108115: LD_INT 102
108117: PUSH
108118: LD_INT 103
108120: PUSH
108121: LD_INT 104
108123: PUSH
108124: LD_INT 105
108126: PUSH
108127: LD_INT 106
108129: PUSH
108130: LD_INT 107
108132: PUSH
108133: LD_INT 108
108135: PUSH
108136: LD_INT 109
108138: PUSH
108139: LD_INT 110
108141: PUSH
108142: LD_INT 111
108144: PUSH
108145: LD_INT 112
108147: PUSH
108148: LD_INT 113
108150: PUSH
108151: LD_INT 114
108153: PUSH
108154: EMPTY
108155: LIST
108156: LIST
108157: LIST
108158: LIST
108159: LIST
108160: LIST
108161: LIST
108162: LIST
108163: LIST
108164: LIST
108165: LIST
108166: LIST
108167: LIST
108168: LIST
108169: PUSH
108170: EMPTY
108171: LIST
108172: LIST
108173: ST_TO_ADDR
108174: GO 109341
108176: LD_INT 14
108178: DOUBLE
108179: EQUAL
108180: IFTRUE 108184
108182: GO 108396
108184: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
108185: LD_ADDR_VAR 0 1
108189: PUSH
108190: LD_INT 1
108192: PUSH
108193: LD_INT 2
108195: PUSH
108196: LD_INT 3
108198: PUSH
108199: LD_INT 4
108201: PUSH
108202: LD_INT 5
108204: PUSH
108205: LD_INT 6
108207: PUSH
108208: LD_INT 7
108210: PUSH
108211: LD_INT 8
108213: PUSH
108214: LD_INT 9
108216: PUSH
108217: LD_INT 10
108219: PUSH
108220: LD_INT 11
108222: PUSH
108223: LD_INT 12
108225: PUSH
108226: LD_INT 13
108228: PUSH
108229: LD_INT 14
108231: PUSH
108232: LD_INT 15
108234: PUSH
108235: LD_INT 16
108237: PUSH
108238: LD_INT 17
108240: PUSH
108241: LD_INT 18
108243: PUSH
108244: LD_INT 19
108246: PUSH
108247: LD_INT 20
108249: PUSH
108250: LD_INT 21
108252: PUSH
108253: LD_INT 22
108255: PUSH
108256: LD_INT 23
108258: PUSH
108259: LD_INT 24
108261: PUSH
108262: LD_INT 25
108264: PUSH
108265: LD_INT 26
108267: PUSH
108268: LD_INT 27
108270: PUSH
108271: LD_INT 28
108273: PUSH
108274: LD_INT 29
108276: PUSH
108277: LD_INT 30
108279: PUSH
108280: LD_INT 31
108282: PUSH
108283: LD_INT 32
108285: PUSH
108286: LD_INT 33
108288: PUSH
108289: LD_INT 34
108291: PUSH
108292: LD_INT 36
108294: PUSH
108295: EMPTY
108296: LIST
108297: LIST
108298: LIST
108299: LIST
108300: LIST
108301: LIST
108302: LIST
108303: LIST
108304: LIST
108305: LIST
108306: LIST
108307: LIST
108308: LIST
108309: LIST
108310: LIST
108311: LIST
108312: LIST
108313: LIST
108314: LIST
108315: LIST
108316: LIST
108317: LIST
108318: LIST
108319: LIST
108320: LIST
108321: LIST
108322: LIST
108323: LIST
108324: LIST
108325: LIST
108326: LIST
108327: LIST
108328: LIST
108329: LIST
108330: LIST
108331: PUSH
108332: LD_INT 101
108334: PUSH
108335: LD_INT 102
108337: PUSH
108338: LD_INT 103
108340: PUSH
108341: LD_INT 104
108343: PUSH
108344: LD_INT 105
108346: PUSH
108347: LD_INT 106
108349: PUSH
108350: LD_INT 107
108352: PUSH
108353: LD_INT 108
108355: PUSH
108356: LD_INT 109
108358: PUSH
108359: LD_INT 110
108361: PUSH
108362: LD_INT 111
108364: PUSH
108365: LD_INT 112
108367: PUSH
108368: LD_INT 113
108370: PUSH
108371: LD_INT 114
108373: PUSH
108374: EMPTY
108375: LIST
108376: LIST
108377: LIST
108378: LIST
108379: LIST
108380: LIST
108381: LIST
108382: LIST
108383: LIST
108384: LIST
108385: LIST
108386: LIST
108387: LIST
108388: LIST
108389: PUSH
108390: EMPTY
108391: LIST
108392: LIST
108393: ST_TO_ADDR
108394: GO 109341
108396: LD_INT 15
108398: DOUBLE
108399: EQUAL
108400: IFTRUE 108404
108402: GO 108616
108404: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
108405: LD_ADDR_VAR 0 1
108409: PUSH
108410: LD_INT 1
108412: PUSH
108413: LD_INT 2
108415: PUSH
108416: LD_INT 3
108418: PUSH
108419: LD_INT 4
108421: PUSH
108422: LD_INT 5
108424: PUSH
108425: LD_INT 6
108427: PUSH
108428: LD_INT 7
108430: PUSH
108431: LD_INT 8
108433: PUSH
108434: LD_INT 9
108436: PUSH
108437: LD_INT 10
108439: PUSH
108440: LD_INT 11
108442: PUSH
108443: LD_INT 12
108445: PUSH
108446: LD_INT 13
108448: PUSH
108449: LD_INT 14
108451: PUSH
108452: LD_INT 15
108454: PUSH
108455: LD_INT 16
108457: PUSH
108458: LD_INT 17
108460: PUSH
108461: LD_INT 18
108463: PUSH
108464: LD_INT 19
108466: PUSH
108467: LD_INT 20
108469: PUSH
108470: LD_INT 21
108472: PUSH
108473: LD_INT 22
108475: PUSH
108476: LD_INT 23
108478: PUSH
108479: LD_INT 24
108481: PUSH
108482: LD_INT 25
108484: PUSH
108485: LD_INT 26
108487: PUSH
108488: LD_INT 27
108490: PUSH
108491: LD_INT 28
108493: PUSH
108494: LD_INT 29
108496: PUSH
108497: LD_INT 30
108499: PUSH
108500: LD_INT 31
108502: PUSH
108503: LD_INT 32
108505: PUSH
108506: LD_INT 33
108508: PUSH
108509: LD_INT 34
108511: PUSH
108512: LD_INT 36
108514: PUSH
108515: EMPTY
108516: LIST
108517: LIST
108518: LIST
108519: LIST
108520: LIST
108521: LIST
108522: LIST
108523: LIST
108524: LIST
108525: LIST
108526: LIST
108527: LIST
108528: LIST
108529: LIST
108530: LIST
108531: LIST
108532: LIST
108533: LIST
108534: LIST
108535: LIST
108536: LIST
108537: LIST
108538: LIST
108539: LIST
108540: LIST
108541: LIST
108542: LIST
108543: LIST
108544: LIST
108545: LIST
108546: LIST
108547: LIST
108548: LIST
108549: LIST
108550: LIST
108551: PUSH
108552: LD_INT 101
108554: PUSH
108555: LD_INT 102
108557: PUSH
108558: LD_INT 103
108560: PUSH
108561: LD_INT 104
108563: PUSH
108564: LD_INT 105
108566: PUSH
108567: LD_INT 106
108569: PUSH
108570: LD_INT 107
108572: PUSH
108573: LD_INT 108
108575: PUSH
108576: LD_INT 109
108578: PUSH
108579: LD_INT 110
108581: PUSH
108582: LD_INT 111
108584: PUSH
108585: LD_INT 112
108587: PUSH
108588: LD_INT 113
108590: PUSH
108591: LD_INT 114
108593: PUSH
108594: EMPTY
108595: LIST
108596: LIST
108597: LIST
108598: LIST
108599: LIST
108600: LIST
108601: LIST
108602: LIST
108603: LIST
108604: LIST
108605: LIST
108606: LIST
108607: LIST
108608: LIST
108609: PUSH
108610: EMPTY
108611: LIST
108612: LIST
108613: ST_TO_ADDR
108614: GO 109341
108616: LD_INT 16
108618: DOUBLE
108619: EQUAL
108620: IFTRUE 108624
108622: GO 108748
108624: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
108625: LD_ADDR_VAR 0 1
108629: PUSH
108630: LD_INT 2
108632: PUSH
108633: LD_INT 4
108635: PUSH
108636: LD_INT 5
108638: PUSH
108639: LD_INT 7
108641: PUSH
108642: LD_INT 11
108644: PUSH
108645: LD_INT 12
108647: PUSH
108648: LD_INT 15
108650: PUSH
108651: LD_INT 16
108653: PUSH
108654: LD_INT 20
108656: PUSH
108657: LD_INT 21
108659: PUSH
108660: LD_INT 22
108662: PUSH
108663: LD_INT 23
108665: PUSH
108666: LD_INT 25
108668: PUSH
108669: LD_INT 26
108671: PUSH
108672: LD_INT 30
108674: PUSH
108675: LD_INT 31
108677: PUSH
108678: LD_INT 32
108680: PUSH
108681: LD_INT 33
108683: PUSH
108684: LD_INT 34
108686: PUSH
108687: EMPTY
108688: LIST
108689: LIST
108690: LIST
108691: LIST
108692: LIST
108693: LIST
108694: LIST
108695: LIST
108696: LIST
108697: LIST
108698: LIST
108699: LIST
108700: LIST
108701: LIST
108702: LIST
108703: LIST
108704: LIST
108705: LIST
108706: LIST
108707: PUSH
108708: LD_INT 101
108710: PUSH
108711: LD_INT 102
108713: PUSH
108714: LD_INT 103
108716: PUSH
108717: LD_INT 106
108719: PUSH
108720: LD_INT 108
108722: PUSH
108723: LD_INT 112
108725: PUSH
108726: LD_INT 113
108728: PUSH
108729: LD_INT 114
108731: PUSH
108732: EMPTY
108733: LIST
108734: LIST
108735: LIST
108736: LIST
108737: LIST
108738: LIST
108739: LIST
108740: LIST
108741: PUSH
108742: EMPTY
108743: LIST
108744: LIST
108745: ST_TO_ADDR
108746: GO 109341
108748: LD_INT 17
108750: DOUBLE
108751: EQUAL
108752: IFTRUE 108756
108754: GO 108968
108756: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
108757: LD_ADDR_VAR 0 1
108761: PUSH
108762: LD_INT 1
108764: PUSH
108765: LD_INT 2
108767: PUSH
108768: LD_INT 3
108770: PUSH
108771: LD_INT 4
108773: PUSH
108774: LD_INT 5
108776: PUSH
108777: LD_INT 6
108779: PUSH
108780: LD_INT 7
108782: PUSH
108783: LD_INT 8
108785: PUSH
108786: LD_INT 9
108788: PUSH
108789: LD_INT 10
108791: PUSH
108792: LD_INT 11
108794: PUSH
108795: LD_INT 12
108797: PUSH
108798: LD_INT 13
108800: PUSH
108801: LD_INT 14
108803: PUSH
108804: LD_INT 15
108806: PUSH
108807: LD_INT 16
108809: PUSH
108810: LD_INT 17
108812: PUSH
108813: LD_INT 18
108815: PUSH
108816: LD_INT 19
108818: PUSH
108819: LD_INT 20
108821: PUSH
108822: LD_INT 21
108824: PUSH
108825: LD_INT 22
108827: PUSH
108828: LD_INT 23
108830: PUSH
108831: LD_INT 24
108833: PUSH
108834: LD_INT 25
108836: PUSH
108837: LD_INT 26
108839: PUSH
108840: LD_INT 27
108842: PUSH
108843: LD_INT 28
108845: PUSH
108846: LD_INT 29
108848: PUSH
108849: LD_INT 30
108851: PUSH
108852: LD_INT 31
108854: PUSH
108855: LD_INT 32
108857: PUSH
108858: LD_INT 33
108860: PUSH
108861: LD_INT 34
108863: PUSH
108864: LD_INT 36
108866: PUSH
108867: EMPTY
108868: LIST
108869: LIST
108870: LIST
108871: LIST
108872: LIST
108873: LIST
108874: LIST
108875: LIST
108876: LIST
108877: LIST
108878: LIST
108879: LIST
108880: LIST
108881: LIST
108882: LIST
108883: LIST
108884: LIST
108885: LIST
108886: LIST
108887: LIST
108888: LIST
108889: LIST
108890: LIST
108891: LIST
108892: LIST
108893: LIST
108894: LIST
108895: LIST
108896: LIST
108897: LIST
108898: LIST
108899: LIST
108900: LIST
108901: LIST
108902: LIST
108903: PUSH
108904: LD_INT 101
108906: PUSH
108907: LD_INT 102
108909: PUSH
108910: LD_INT 103
108912: PUSH
108913: LD_INT 104
108915: PUSH
108916: LD_INT 105
108918: PUSH
108919: LD_INT 106
108921: PUSH
108922: LD_INT 107
108924: PUSH
108925: LD_INT 108
108927: PUSH
108928: LD_INT 109
108930: PUSH
108931: LD_INT 110
108933: PUSH
108934: LD_INT 111
108936: PUSH
108937: LD_INT 112
108939: PUSH
108940: LD_INT 113
108942: PUSH
108943: LD_INT 114
108945: PUSH
108946: EMPTY
108947: LIST
108948: LIST
108949: LIST
108950: LIST
108951: LIST
108952: LIST
108953: LIST
108954: LIST
108955: LIST
108956: LIST
108957: LIST
108958: LIST
108959: LIST
108960: LIST
108961: PUSH
108962: EMPTY
108963: LIST
108964: LIST
108965: ST_TO_ADDR
108966: GO 109341
108968: LD_INT 18
108970: DOUBLE
108971: EQUAL
108972: IFTRUE 108976
108974: GO 109112
108976: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
108977: LD_ADDR_VAR 0 1
108981: PUSH
108982: LD_INT 2
108984: PUSH
108985: LD_INT 4
108987: PUSH
108988: LD_INT 5
108990: PUSH
108991: LD_INT 7
108993: PUSH
108994: LD_INT 11
108996: PUSH
108997: LD_INT 12
108999: PUSH
109000: LD_INT 15
109002: PUSH
109003: LD_INT 16
109005: PUSH
109006: LD_INT 20
109008: PUSH
109009: LD_INT 21
109011: PUSH
109012: LD_INT 22
109014: PUSH
109015: LD_INT 23
109017: PUSH
109018: LD_INT 25
109020: PUSH
109021: LD_INT 26
109023: PUSH
109024: LD_INT 30
109026: PUSH
109027: LD_INT 31
109029: PUSH
109030: LD_INT 32
109032: PUSH
109033: LD_INT 33
109035: PUSH
109036: LD_INT 34
109038: PUSH
109039: LD_INT 35
109041: PUSH
109042: LD_INT 36
109044: PUSH
109045: EMPTY
109046: LIST
109047: LIST
109048: LIST
109049: LIST
109050: LIST
109051: LIST
109052: LIST
109053: LIST
109054: LIST
109055: LIST
109056: LIST
109057: LIST
109058: LIST
109059: LIST
109060: LIST
109061: LIST
109062: LIST
109063: LIST
109064: LIST
109065: LIST
109066: LIST
109067: PUSH
109068: LD_INT 101
109070: PUSH
109071: LD_INT 102
109073: PUSH
109074: LD_INT 103
109076: PUSH
109077: LD_INT 106
109079: PUSH
109080: LD_INT 108
109082: PUSH
109083: LD_INT 112
109085: PUSH
109086: LD_INT 113
109088: PUSH
109089: LD_INT 114
109091: PUSH
109092: LD_INT 115
109094: PUSH
109095: EMPTY
109096: LIST
109097: LIST
109098: LIST
109099: LIST
109100: LIST
109101: LIST
109102: LIST
109103: LIST
109104: LIST
109105: PUSH
109106: EMPTY
109107: LIST
109108: LIST
109109: ST_TO_ADDR
109110: GO 109341
109112: LD_INT 19
109114: DOUBLE
109115: EQUAL
109116: IFTRUE 109120
109118: GO 109340
109120: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
109121: LD_ADDR_VAR 0 1
109125: PUSH
109126: LD_INT 1
109128: PUSH
109129: LD_INT 2
109131: PUSH
109132: LD_INT 3
109134: PUSH
109135: LD_INT 4
109137: PUSH
109138: LD_INT 5
109140: PUSH
109141: LD_INT 6
109143: PUSH
109144: LD_INT 7
109146: PUSH
109147: LD_INT 8
109149: PUSH
109150: LD_INT 9
109152: PUSH
109153: LD_INT 10
109155: PUSH
109156: LD_INT 11
109158: PUSH
109159: LD_INT 12
109161: PUSH
109162: LD_INT 13
109164: PUSH
109165: LD_INT 14
109167: PUSH
109168: LD_INT 15
109170: PUSH
109171: LD_INT 16
109173: PUSH
109174: LD_INT 17
109176: PUSH
109177: LD_INT 18
109179: PUSH
109180: LD_INT 19
109182: PUSH
109183: LD_INT 20
109185: PUSH
109186: LD_INT 21
109188: PUSH
109189: LD_INT 22
109191: PUSH
109192: LD_INT 23
109194: PUSH
109195: LD_INT 24
109197: PUSH
109198: LD_INT 25
109200: PUSH
109201: LD_INT 26
109203: PUSH
109204: LD_INT 27
109206: PUSH
109207: LD_INT 28
109209: PUSH
109210: LD_INT 29
109212: PUSH
109213: LD_INT 30
109215: PUSH
109216: LD_INT 31
109218: PUSH
109219: LD_INT 32
109221: PUSH
109222: LD_INT 33
109224: PUSH
109225: LD_INT 34
109227: PUSH
109228: LD_INT 35
109230: PUSH
109231: LD_INT 36
109233: PUSH
109234: EMPTY
109235: LIST
109236: LIST
109237: LIST
109238: LIST
109239: LIST
109240: LIST
109241: LIST
109242: LIST
109243: LIST
109244: LIST
109245: LIST
109246: LIST
109247: LIST
109248: LIST
109249: LIST
109250: LIST
109251: LIST
109252: LIST
109253: LIST
109254: LIST
109255: LIST
109256: LIST
109257: LIST
109258: LIST
109259: LIST
109260: LIST
109261: LIST
109262: LIST
109263: LIST
109264: LIST
109265: LIST
109266: LIST
109267: LIST
109268: LIST
109269: LIST
109270: LIST
109271: PUSH
109272: LD_INT 101
109274: PUSH
109275: LD_INT 102
109277: PUSH
109278: LD_INT 103
109280: PUSH
109281: LD_INT 104
109283: PUSH
109284: LD_INT 105
109286: PUSH
109287: LD_INT 106
109289: PUSH
109290: LD_INT 107
109292: PUSH
109293: LD_INT 108
109295: PUSH
109296: LD_INT 109
109298: PUSH
109299: LD_INT 110
109301: PUSH
109302: LD_INT 111
109304: PUSH
109305: LD_INT 112
109307: PUSH
109308: LD_INT 113
109310: PUSH
109311: LD_INT 114
109313: PUSH
109314: LD_INT 115
109316: PUSH
109317: EMPTY
109318: LIST
109319: LIST
109320: LIST
109321: LIST
109322: LIST
109323: LIST
109324: LIST
109325: LIST
109326: LIST
109327: LIST
109328: LIST
109329: LIST
109330: LIST
109331: LIST
109332: LIST
109333: PUSH
109334: EMPTY
109335: LIST
109336: LIST
109337: ST_TO_ADDR
109338: GO 109341
109340: POP
// end else
109341: GO 109560
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
109343: LD_ADDR_VAR 0 1
109347: PUSH
109348: LD_INT 1
109350: PUSH
109351: LD_INT 2
109353: PUSH
109354: LD_INT 3
109356: PUSH
109357: LD_INT 4
109359: PUSH
109360: LD_INT 5
109362: PUSH
109363: LD_INT 6
109365: PUSH
109366: LD_INT 7
109368: PUSH
109369: LD_INT 8
109371: PUSH
109372: LD_INT 9
109374: PUSH
109375: LD_INT 10
109377: PUSH
109378: LD_INT 11
109380: PUSH
109381: LD_INT 12
109383: PUSH
109384: LD_INT 13
109386: PUSH
109387: LD_INT 14
109389: PUSH
109390: LD_INT 15
109392: PUSH
109393: LD_INT 16
109395: PUSH
109396: LD_INT 17
109398: PUSH
109399: LD_INT 18
109401: PUSH
109402: LD_INT 19
109404: PUSH
109405: LD_INT 20
109407: PUSH
109408: LD_INT 21
109410: PUSH
109411: LD_INT 22
109413: PUSH
109414: LD_INT 23
109416: PUSH
109417: LD_INT 24
109419: PUSH
109420: LD_INT 25
109422: PUSH
109423: LD_INT 26
109425: PUSH
109426: LD_INT 27
109428: PUSH
109429: LD_INT 28
109431: PUSH
109432: LD_INT 29
109434: PUSH
109435: LD_INT 30
109437: PUSH
109438: LD_INT 31
109440: PUSH
109441: LD_INT 32
109443: PUSH
109444: LD_INT 33
109446: PUSH
109447: LD_INT 34
109449: PUSH
109450: LD_INT 35
109452: PUSH
109453: LD_INT 36
109455: PUSH
109456: EMPTY
109457: LIST
109458: LIST
109459: LIST
109460: LIST
109461: LIST
109462: LIST
109463: LIST
109464: LIST
109465: LIST
109466: LIST
109467: LIST
109468: LIST
109469: LIST
109470: LIST
109471: LIST
109472: LIST
109473: LIST
109474: LIST
109475: LIST
109476: LIST
109477: LIST
109478: LIST
109479: LIST
109480: LIST
109481: LIST
109482: LIST
109483: LIST
109484: LIST
109485: LIST
109486: LIST
109487: LIST
109488: LIST
109489: LIST
109490: LIST
109491: LIST
109492: LIST
109493: PUSH
109494: LD_INT 101
109496: PUSH
109497: LD_INT 102
109499: PUSH
109500: LD_INT 103
109502: PUSH
109503: LD_INT 104
109505: PUSH
109506: LD_INT 105
109508: PUSH
109509: LD_INT 106
109511: PUSH
109512: LD_INT 107
109514: PUSH
109515: LD_INT 108
109517: PUSH
109518: LD_INT 109
109520: PUSH
109521: LD_INT 110
109523: PUSH
109524: LD_INT 111
109526: PUSH
109527: LD_INT 112
109529: PUSH
109530: LD_INT 113
109532: PUSH
109533: LD_INT 114
109535: PUSH
109536: LD_INT 115
109538: PUSH
109539: EMPTY
109540: LIST
109541: LIST
109542: LIST
109543: LIST
109544: LIST
109545: LIST
109546: LIST
109547: LIST
109548: LIST
109549: LIST
109550: LIST
109551: LIST
109552: LIST
109553: LIST
109554: LIST
109555: PUSH
109556: EMPTY
109557: LIST
109558: LIST
109559: ST_TO_ADDR
// if result then
109560: LD_VAR 0 1
109564: IFFALSE 109853
// begin normal :=  ;
109566: LD_ADDR_VAR 0 3
109570: PUSH
109571: LD_STRING 
109573: ST_TO_ADDR
// hardcore :=  ;
109574: LD_ADDR_VAR 0 4
109578: PUSH
109579: LD_STRING 
109581: ST_TO_ADDR
// for i = 1 to normalCounter do
109582: LD_ADDR_VAR 0 5
109586: PUSH
109587: DOUBLE
109588: LD_INT 1
109590: DEC
109591: ST_TO_ADDR
109592: LD_EXP 161
109596: PUSH
109597: FOR_TO
109598: IFFALSE 109699
// begin tmp := 0 ;
109600: LD_ADDR_VAR 0 2
109604: PUSH
109605: LD_STRING 0
109607: ST_TO_ADDR
// if result [ 1 ] then
109608: LD_VAR 0 1
109612: PUSH
109613: LD_INT 1
109615: ARRAY
109616: IFFALSE 109681
// if result [ 1 ] [ 1 ] = i then
109618: LD_VAR 0 1
109622: PUSH
109623: LD_INT 1
109625: ARRAY
109626: PUSH
109627: LD_INT 1
109629: ARRAY
109630: PUSH
109631: LD_VAR 0 5
109635: EQUAL
109636: IFFALSE 109681
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
109638: LD_ADDR_VAR 0 1
109642: PUSH
109643: LD_VAR 0 1
109647: PPUSH
109648: LD_INT 1
109650: PPUSH
109651: LD_VAR 0 1
109655: PUSH
109656: LD_INT 1
109658: ARRAY
109659: PPUSH
109660: LD_INT 1
109662: PPUSH
109663: CALL_OW 3
109667: PPUSH
109668: CALL_OW 1
109672: ST_TO_ADDR
// tmp := 1 ;
109673: LD_ADDR_VAR 0 2
109677: PUSH
109678: LD_STRING 1
109680: ST_TO_ADDR
// end ; normal := normal & tmp ;
109681: LD_ADDR_VAR 0 3
109685: PUSH
109686: LD_VAR 0 3
109690: PUSH
109691: LD_VAR 0 2
109695: STR
109696: ST_TO_ADDR
// end ;
109697: GO 109597
109699: POP
109700: POP
// for i = 1 to hardcoreCounter do
109701: LD_ADDR_VAR 0 5
109705: PUSH
109706: DOUBLE
109707: LD_INT 1
109709: DEC
109710: ST_TO_ADDR
109711: LD_EXP 162
109715: PUSH
109716: FOR_TO
109717: IFFALSE 109822
// begin tmp := 0 ;
109719: LD_ADDR_VAR 0 2
109723: PUSH
109724: LD_STRING 0
109726: ST_TO_ADDR
// if result [ 2 ] then
109727: LD_VAR 0 1
109731: PUSH
109732: LD_INT 2
109734: ARRAY
109735: IFFALSE 109804
// if result [ 2 ] [ 1 ] = 100 + i then
109737: LD_VAR 0 1
109741: PUSH
109742: LD_INT 2
109744: ARRAY
109745: PUSH
109746: LD_INT 1
109748: ARRAY
109749: PUSH
109750: LD_INT 100
109752: PUSH
109753: LD_VAR 0 5
109757: PLUS
109758: EQUAL
109759: IFFALSE 109804
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
109761: LD_ADDR_VAR 0 1
109765: PUSH
109766: LD_VAR 0 1
109770: PPUSH
109771: LD_INT 2
109773: PPUSH
109774: LD_VAR 0 1
109778: PUSH
109779: LD_INT 2
109781: ARRAY
109782: PPUSH
109783: LD_INT 1
109785: PPUSH
109786: CALL_OW 3
109790: PPUSH
109791: CALL_OW 1
109795: ST_TO_ADDR
// tmp := 1 ;
109796: LD_ADDR_VAR 0 2
109800: PUSH
109801: LD_STRING 1
109803: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
109804: LD_ADDR_VAR 0 4
109808: PUSH
109809: LD_VAR 0 4
109813: PUSH
109814: LD_VAR 0 2
109818: STR
109819: ST_TO_ADDR
// end ;
109820: GO 109716
109822: POP
109823: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
109824: LD_STRING getStreamItemsFromMission("
109826: PUSH
109827: LD_VAR 0 3
109831: STR
109832: PUSH
109833: LD_STRING ","
109835: STR
109836: PUSH
109837: LD_VAR 0 4
109841: STR
109842: PUSH
109843: LD_STRING ")
109845: STR
109846: PPUSH
109847: CALL_OW 559
// end else
109851: GO 109860
// ToLua ( getStreamItemsFromMission("","") ) ;
109853: LD_STRING getStreamItemsFromMission("","")
109855: PPUSH
109856: CALL_OW 559
// end ;
109860: LD_VAR 0 1
109864: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
109865: LD_EXP 160
109869: PUSH
109870: LD_EXP 165
109874: AND
109875: IFFALSE 109999
109877: GO 109879
109879: DISABLE
109880: LD_INT 0
109882: PPUSH
109883: PPUSH
// begin enable ;
109884: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
109885: LD_ADDR_VAR 0 2
109889: PUSH
109890: LD_INT 22
109892: PUSH
109893: LD_OWVAR 2
109897: PUSH
109898: EMPTY
109899: LIST
109900: LIST
109901: PUSH
109902: LD_INT 2
109904: PUSH
109905: LD_INT 34
109907: PUSH
109908: LD_INT 7
109910: PUSH
109911: EMPTY
109912: LIST
109913: LIST
109914: PUSH
109915: LD_INT 34
109917: PUSH
109918: LD_INT 45
109920: PUSH
109921: EMPTY
109922: LIST
109923: LIST
109924: PUSH
109925: LD_INT 34
109927: PUSH
109928: LD_INT 28
109930: PUSH
109931: EMPTY
109932: LIST
109933: LIST
109934: PUSH
109935: LD_INT 34
109937: PUSH
109938: LD_INT 47
109940: PUSH
109941: EMPTY
109942: LIST
109943: LIST
109944: PUSH
109945: EMPTY
109946: LIST
109947: LIST
109948: LIST
109949: LIST
109950: LIST
109951: PUSH
109952: EMPTY
109953: LIST
109954: LIST
109955: PPUSH
109956: CALL_OW 69
109960: ST_TO_ADDR
// if not tmp then
109961: LD_VAR 0 2
109965: NOT
109966: IFFALSE 109970
// exit ;
109968: GO 109999
// for i in tmp do
109970: LD_ADDR_VAR 0 1
109974: PUSH
109975: LD_VAR 0 2
109979: PUSH
109980: FOR_IN
109981: IFFALSE 109997
// begin SetLives ( i , 0 ) ;
109983: LD_VAR 0 1
109987: PPUSH
109988: LD_INT 0
109990: PPUSH
109991: CALL_OW 234
// end ;
109995: GO 109980
109997: POP
109998: POP
// end ;
109999: PPOPN 2
110001: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
110002: LD_EXP 160
110006: PUSH
110007: LD_EXP 166
110011: AND
110012: IFFALSE 110096
110014: GO 110016
110016: DISABLE
110017: LD_INT 0
110019: PPUSH
110020: PPUSH
// begin enable ;
110021: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
110022: LD_ADDR_VAR 0 2
110026: PUSH
110027: LD_INT 22
110029: PUSH
110030: LD_OWVAR 2
110034: PUSH
110035: EMPTY
110036: LIST
110037: LIST
110038: PUSH
110039: LD_INT 32
110041: PUSH
110042: LD_INT 3
110044: PUSH
110045: EMPTY
110046: LIST
110047: LIST
110048: PUSH
110049: EMPTY
110050: LIST
110051: LIST
110052: PPUSH
110053: CALL_OW 69
110057: ST_TO_ADDR
// if not tmp then
110058: LD_VAR 0 2
110062: NOT
110063: IFFALSE 110067
// exit ;
110065: GO 110096
// for i in tmp do
110067: LD_ADDR_VAR 0 1
110071: PUSH
110072: LD_VAR 0 2
110076: PUSH
110077: FOR_IN
110078: IFFALSE 110094
// begin SetLives ( i , 0 ) ;
110080: LD_VAR 0 1
110084: PPUSH
110085: LD_INT 0
110087: PPUSH
110088: CALL_OW 234
// end ;
110092: GO 110077
110094: POP
110095: POP
// end ;
110096: PPOPN 2
110098: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
110099: LD_EXP 160
110103: PUSH
110104: LD_EXP 163
110108: AND
110109: IFFALSE 110202
110111: GO 110113
110113: DISABLE
110114: LD_INT 0
110116: PPUSH
// begin enable ;
110117: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
110118: LD_ADDR_VAR 0 1
110122: PUSH
110123: LD_INT 22
110125: PUSH
110126: LD_OWVAR 2
110130: PUSH
110131: EMPTY
110132: LIST
110133: LIST
110134: PUSH
110135: LD_INT 2
110137: PUSH
110138: LD_INT 25
110140: PUSH
110141: LD_INT 5
110143: PUSH
110144: EMPTY
110145: LIST
110146: LIST
110147: PUSH
110148: LD_INT 25
110150: PUSH
110151: LD_INT 9
110153: PUSH
110154: EMPTY
110155: LIST
110156: LIST
110157: PUSH
110158: LD_INT 25
110160: PUSH
110161: LD_INT 8
110163: PUSH
110164: EMPTY
110165: LIST
110166: LIST
110167: PUSH
110168: EMPTY
110169: LIST
110170: LIST
110171: LIST
110172: LIST
110173: PUSH
110174: EMPTY
110175: LIST
110176: LIST
110177: PPUSH
110178: CALL_OW 69
110182: PUSH
110183: FOR_IN
110184: IFFALSE 110200
// begin SetClass ( i , 1 ) ;
110186: LD_VAR 0 1
110190: PPUSH
110191: LD_INT 1
110193: PPUSH
110194: CALL_OW 336
// end ;
110198: GO 110183
110200: POP
110201: POP
// end ;
110202: PPOPN 1
110204: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
110205: LD_EXP 160
110209: PUSH
110210: LD_EXP 164
110214: AND
110215: PUSH
110216: LD_OWVAR 65
110220: PUSH
110221: LD_INT 7
110223: LESS
110224: AND
110225: IFFALSE 110239
110227: GO 110229
110229: DISABLE
// begin enable ;
110230: ENABLE
// game_speed := 7 ;
110231: LD_ADDR_OWVAR 65
110235: PUSH
110236: LD_INT 7
110238: ST_TO_ADDR
// end ;
110239: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
110240: LD_EXP 160
110244: PUSH
110245: LD_EXP 167
110249: AND
110250: IFFALSE 110452
110252: GO 110254
110254: DISABLE
110255: LD_INT 0
110257: PPUSH
110258: PPUSH
110259: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
110260: LD_ADDR_VAR 0 3
110264: PUSH
110265: LD_INT 81
110267: PUSH
110268: LD_OWVAR 2
110272: PUSH
110273: EMPTY
110274: LIST
110275: LIST
110276: PUSH
110277: LD_INT 21
110279: PUSH
110280: LD_INT 1
110282: PUSH
110283: EMPTY
110284: LIST
110285: LIST
110286: PUSH
110287: EMPTY
110288: LIST
110289: LIST
110290: PPUSH
110291: CALL_OW 69
110295: ST_TO_ADDR
// if not tmp then
110296: LD_VAR 0 3
110300: NOT
110301: IFFALSE 110305
// exit ;
110303: GO 110452
// if tmp > 5 then
110305: LD_VAR 0 3
110309: PUSH
110310: LD_INT 5
110312: GREATER
110313: IFFALSE 110325
// k := 5 else
110315: LD_ADDR_VAR 0 2
110319: PUSH
110320: LD_INT 5
110322: ST_TO_ADDR
110323: GO 110335
// k := tmp ;
110325: LD_ADDR_VAR 0 2
110329: PUSH
110330: LD_VAR 0 3
110334: ST_TO_ADDR
// for i := 1 to k do
110335: LD_ADDR_VAR 0 1
110339: PUSH
110340: DOUBLE
110341: LD_INT 1
110343: DEC
110344: ST_TO_ADDR
110345: LD_VAR 0 2
110349: PUSH
110350: FOR_TO
110351: IFFALSE 110450
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
110353: LD_VAR 0 3
110357: PUSH
110358: LD_VAR 0 1
110362: ARRAY
110363: PPUSH
110364: LD_VAR 0 1
110368: PUSH
110369: LD_INT 4
110371: MOD
110372: PUSH
110373: LD_INT 1
110375: PLUS
110376: PPUSH
110377: CALL_OW 259
110381: PUSH
110382: LD_INT 10
110384: LESS
110385: IFFALSE 110448
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
110387: LD_VAR 0 3
110391: PUSH
110392: LD_VAR 0 1
110396: ARRAY
110397: PPUSH
110398: LD_VAR 0 1
110402: PUSH
110403: LD_INT 4
110405: MOD
110406: PUSH
110407: LD_INT 1
110409: PLUS
110410: PPUSH
110411: LD_VAR 0 3
110415: PUSH
110416: LD_VAR 0 1
110420: ARRAY
110421: PPUSH
110422: LD_VAR 0 1
110426: PUSH
110427: LD_INT 4
110429: MOD
110430: PUSH
110431: LD_INT 1
110433: PLUS
110434: PPUSH
110435: CALL_OW 259
110439: PUSH
110440: LD_INT 1
110442: PLUS
110443: PPUSH
110444: CALL_OW 237
110448: GO 110350
110450: POP
110451: POP
// end ;
110452: PPOPN 3
110454: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
110455: LD_EXP 160
110459: PUSH
110460: LD_EXP 168
110464: AND
110465: IFFALSE 110485
110467: GO 110469
110469: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
110470: LD_INT 4
110472: PPUSH
110473: LD_OWVAR 2
110477: PPUSH
110478: LD_INT 0
110480: PPUSH
110481: CALL_OW 324
110485: END
// every 0 0$1 trigger StreamModeActive and sShovel do
110486: LD_EXP 160
110490: PUSH
110491: LD_EXP 197
110495: AND
110496: IFFALSE 110516
110498: GO 110500
110500: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
110501: LD_INT 19
110503: PPUSH
110504: LD_OWVAR 2
110508: PPUSH
110509: LD_INT 0
110511: PPUSH
110512: CALL_OW 324
110516: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
110517: LD_EXP 160
110521: PUSH
110522: LD_EXP 169
110526: AND
110527: IFFALSE 110629
110529: GO 110531
110531: DISABLE
110532: LD_INT 0
110534: PPUSH
110535: PPUSH
// begin enable ;
110536: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
110537: LD_ADDR_VAR 0 2
110541: PUSH
110542: LD_INT 22
110544: PUSH
110545: LD_OWVAR 2
110549: PUSH
110550: EMPTY
110551: LIST
110552: LIST
110553: PUSH
110554: LD_INT 2
110556: PUSH
110557: LD_INT 34
110559: PUSH
110560: LD_INT 11
110562: PUSH
110563: EMPTY
110564: LIST
110565: LIST
110566: PUSH
110567: LD_INT 34
110569: PUSH
110570: LD_INT 30
110572: PUSH
110573: EMPTY
110574: LIST
110575: LIST
110576: PUSH
110577: EMPTY
110578: LIST
110579: LIST
110580: LIST
110581: PUSH
110582: EMPTY
110583: LIST
110584: LIST
110585: PPUSH
110586: CALL_OW 69
110590: ST_TO_ADDR
// if not tmp then
110591: LD_VAR 0 2
110595: NOT
110596: IFFALSE 110600
// exit ;
110598: GO 110629
// for i in tmp do
110600: LD_ADDR_VAR 0 1
110604: PUSH
110605: LD_VAR 0 2
110609: PUSH
110610: FOR_IN
110611: IFFALSE 110627
// begin SetLives ( i , 0 ) ;
110613: LD_VAR 0 1
110617: PPUSH
110618: LD_INT 0
110620: PPUSH
110621: CALL_OW 234
// end ;
110625: GO 110610
110627: POP
110628: POP
// end ;
110629: PPOPN 2
110631: END
// every 0 0$1 trigger StreamModeActive and sBunker do
110632: LD_EXP 160
110636: PUSH
110637: LD_EXP 170
110641: AND
110642: IFFALSE 110662
110644: GO 110646
110646: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
110647: LD_INT 32
110649: PPUSH
110650: LD_OWVAR 2
110654: PPUSH
110655: LD_INT 0
110657: PPUSH
110658: CALL_OW 324
110662: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
110663: LD_EXP 160
110667: PUSH
110668: LD_EXP 171
110672: AND
110673: IFFALSE 110854
110675: GO 110677
110677: DISABLE
110678: LD_INT 0
110680: PPUSH
110681: PPUSH
110682: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
110683: LD_ADDR_VAR 0 2
110687: PUSH
110688: LD_INT 22
110690: PUSH
110691: LD_OWVAR 2
110695: PUSH
110696: EMPTY
110697: LIST
110698: LIST
110699: PUSH
110700: LD_INT 33
110702: PUSH
110703: LD_INT 3
110705: PUSH
110706: EMPTY
110707: LIST
110708: LIST
110709: PUSH
110710: EMPTY
110711: LIST
110712: LIST
110713: PPUSH
110714: CALL_OW 69
110718: ST_TO_ADDR
// if not tmp then
110719: LD_VAR 0 2
110723: NOT
110724: IFFALSE 110728
// exit ;
110726: GO 110854
// side := 0 ;
110728: LD_ADDR_VAR 0 3
110732: PUSH
110733: LD_INT 0
110735: ST_TO_ADDR
// for i := 1 to 8 do
110736: LD_ADDR_VAR 0 1
110740: PUSH
110741: DOUBLE
110742: LD_INT 1
110744: DEC
110745: ST_TO_ADDR
110746: LD_INT 8
110748: PUSH
110749: FOR_TO
110750: IFFALSE 110798
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
110752: LD_OWVAR 2
110756: PUSH
110757: LD_VAR 0 1
110761: NONEQUAL
110762: PUSH
110763: LD_OWVAR 2
110767: PPUSH
110768: LD_VAR 0 1
110772: PPUSH
110773: CALL_OW 81
110777: PUSH
110778: LD_INT 2
110780: EQUAL
110781: AND
110782: IFFALSE 110796
// begin side := i ;
110784: LD_ADDR_VAR 0 3
110788: PUSH
110789: LD_VAR 0 1
110793: ST_TO_ADDR
// break ;
110794: GO 110798
// end ;
110796: GO 110749
110798: POP
110799: POP
// if not side then
110800: LD_VAR 0 3
110804: NOT
110805: IFFALSE 110809
// exit ;
110807: GO 110854
// for i := 1 to tmp do
110809: LD_ADDR_VAR 0 1
110813: PUSH
110814: DOUBLE
110815: LD_INT 1
110817: DEC
110818: ST_TO_ADDR
110819: LD_VAR 0 2
110823: PUSH
110824: FOR_TO
110825: IFFALSE 110852
// if Prob ( 60 ) then
110827: LD_INT 60
110829: PPUSH
110830: CALL_OW 13
110834: IFFALSE 110850
// SetSide ( i , side ) ;
110836: LD_VAR 0 1
110840: PPUSH
110841: LD_VAR 0 3
110845: PPUSH
110846: CALL_OW 235
110850: GO 110824
110852: POP
110853: POP
// end ;
110854: PPOPN 3
110856: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
110857: LD_EXP 160
110861: PUSH
110862: LD_EXP 173
110866: AND
110867: IFFALSE 110986
110869: GO 110871
110871: DISABLE
110872: LD_INT 0
110874: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
110875: LD_ADDR_VAR 0 1
110879: PUSH
110880: LD_INT 22
110882: PUSH
110883: LD_OWVAR 2
110887: PUSH
110888: EMPTY
110889: LIST
110890: LIST
110891: PUSH
110892: LD_INT 21
110894: PUSH
110895: LD_INT 1
110897: PUSH
110898: EMPTY
110899: LIST
110900: LIST
110901: PUSH
110902: LD_INT 3
110904: PUSH
110905: LD_INT 23
110907: PUSH
110908: LD_INT 0
110910: PUSH
110911: EMPTY
110912: LIST
110913: LIST
110914: PUSH
110915: EMPTY
110916: LIST
110917: LIST
110918: PUSH
110919: EMPTY
110920: LIST
110921: LIST
110922: LIST
110923: PPUSH
110924: CALL_OW 69
110928: PUSH
110929: FOR_IN
110930: IFFALSE 110984
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
110932: LD_VAR 0 1
110936: PPUSH
110937: CALL_OW 257
110941: PUSH
110942: LD_INT 1
110944: PUSH
110945: LD_INT 2
110947: PUSH
110948: LD_INT 3
110950: PUSH
110951: LD_INT 4
110953: PUSH
110954: EMPTY
110955: LIST
110956: LIST
110957: LIST
110958: LIST
110959: IN
110960: IFFALSE 110982
// SetClass ( un , rand ( 1 , 4 ) ) ;
110962: LD_VAR 0 1
110966: PPUSH
110967: LD_INT 1
110969: PPUSH
110970: LD_INT 4
110972: PPUSH
110973: CALL_OW 12
110977: PPUSH
110978: CALL_OW 336
110982: GO 110929
110984: POP
110985: POP
// end ;
110986: PPOPN 1
110988: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
110989: LD_EXP 160
110993: PUSH
110994: LD_EXP 172
110998: AND
110999: IFFALSE 111078
111001: GO 111003
111003: DISABLE
111004: LD_INT 0
111006: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
111007: LD_ADDR_VAR 0 1
111011: PUSH
111012: LD_INT 22
111014: PUSH
111015: LD_OWVAR 2
111019: PUSH
111020: EMPTY
111021: LIST
111022: LIST
111023: PUSH
111024: LD_INT 21
111026: PUSH
111027: LD_INT 3
111029: PUSH
111030: EMPTY
111031: LIST
111032: LIST
111033: PUSH
111034: EMPTY
111035: LIST
111036: LIST
111037: PPUSH
111038: CALL_OW 69
111042: ST_TO_ADDR
// if not tmp then
111043: LD_VAR 0 1
111047: NOT
111048: IFFALSE 111052
// exit ;
111050: GO 111078
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
111052: LD_VAR 0 1
111056: PUSH
111057: LD_INT 1
111059: PPUSH
111060: LD_VAR 0 1
111064: PPUSH
111065: CALL_OW 12
111069: ARRAY
111070: PPUSH
111071: LD_INT 100
111073: PPUSH
111074: CALL_OW 234
// end ;
111078: PPOPN 1
111080: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
111081: LD_EXP 160
111085: PUSH
111086: LD_EXP 174
111090: AND
111091: IFFALSE 111189
111093: GO 111095
111095: DISABLE
111096: LD_INT 0
111098: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
111099: LD_ADDR_VAR 0 1
111103: PUSH
111104: LD_INT 22
111106: PUSH
111107: LD_OWVAR 2
111111: PUSH
111112: EMPTY
111113: LIST
111114: LIST
111115: PUSH
111116: LD_INT 21
111118: PUSH
111119: LD_INT 1
111121: PUSH
111122: EMPTY
111123: LIST
111124: LIST
111125: PUSH
111126: EMPTY
111127: LIST
111128: LIST
111129: PPUSH
111130: CALL_OW 69
111134: ST_TO_ADDR
// if not tmp then
111135: LD_VAR 0 1
111139: NOT
111140: IFFALSE 111144
// exit ;
111142: GO 111189
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
111144: LD_VAR 0 1
111148: PUSH
111149: LD_INT 1
111151: PPUSH
111152: LD_VAR 0 1
111156: PPUSH
111157: CALL_OW 12
111161: ARRAY
111162: PPUSH
111163: LD_INT 1
111165: PPUSH
111166: LD_INT 4
111168: PPUSH
111169: CALL_OW 12
111173: PPUSH
111174: LD_INT 3000
111176: PPUSH
111177: LD_INT 9000
111179: PPUSH
111180: CALL_OW 12
111184: PPUSH
111185: CALL_OW 492
// end ;
111189: PPOPN 1
111191: END
// every 0 0$1 trigger StreamModeActive and sDepot do
111192: LD_EXP 160
111196: PUSH
111197: LD_EXP 175
111201: AND
111202: IFFALSE 111222
111204: GO 111206
111206: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
111207: LD_INT 1
111209: PPUSH
111210: LD_OWVAR 2
111214: PPUSH
111215: LD_INT 0
111217: PPUSH
111218: CALL_OW 324
111222: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
111223: LD_EXP 160
111227: PUSH
111228: LD_EXP 176
111232: AND
111233: IFFALSE 111316
111235: GO 111237
111237: DISABLE
111238: LD_INT 0
111240: PPUSH
111241: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
111242: LD_ADDR_VAR 0 2
111246: PUSH
111247: LD_INT 22
111249: PUSH
111250: LD_OWVAR 2
111254: PUSH
111255: EMPTY
111256: LIST
111257: LIST
111258: PUSH
111259: LD_INT 21
111261: PUSH
111262: LD_INT 3
111264: PUSH
111265: EMPTY
111266: LIST
111267: LIST
111268: PUSH
111269: EMPTY
111270: LIST
111271: LIST
111272: PPUSH
111273: CALL_OW 69
111277: ST_TO_ADDR
// if not tmp then
111278: LD_VAR 0 2
111282: NOT
111283: IFFALSE 111287
// exit ;
111285: GO 111316
// for i in tmp do
111287: LD_ADDR_VAR 0 1
111291: PUSH
111292: LD_VAR 0 2
111296: PUSH
111297: FOR_IN
111298: IFFALSE 111314
// SetBLevel ( i , 10 ) ;
111300: LD_VAR 0 1
111304: PPUSH
111305: LD_INT 10
111307: PPUSH
111308: CALL_OW 241
111312: GO 111297
111314: POP
111315: POP
// end ;
111316: PPOPN 2
111318: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
111319: LD_EXP 160
111323: PUSH
111324: LD_EXP 177
111328: AND
111329: IFFALSE 111440
111331: GO 111333
111333: DISABLE
111334: LD_INT 0
111336: PPUSH
111337: PPUSH
111338: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
111339: LD_ADDR_VAR 0 3
111343: PUSH
111344: LD_INT 22
111346: PUSH
111347: LD_OWVAR 2
111351: PUSH
111352: EMPTY
111353: LIST
111354: LIST
111355: PUSH
111356: LD_INT 25
111358: PUSH
111359: LD_INT 1
111361: PUSH
111362: EMPTY
111363: LIST
111364: LIST
111365: PUSH
111366: EMPTY
111367: LIST
111368: LIST
111369: PPUSH
111370: CALL_OW 69
111374: ST_TO_ADDR
// if not tmp then
111375: LD_VAR 0 3
111379: NOT
111380: IFFALSE 111384
// exit ;
111382: GO 111440
// un := tmp [ rand ( 1 , tmp ) ] ;
111384: LD_ADDR_VAR 0 2
111388: PUSH
111389: LD_VAR 0 3
111393: PUSH
111394: LD_INT 1
111396: PPUSH
111397: LD_VAR 0 3
111401: PPUSH
111402: CALL_OW 12
111406: ARRAY
111407: ST_TO_ADDR
// if Crawls ( un ) then
111408: LD_VAR 0 2
111412: PPUSH
111413: CALL_OW 318
111417: IFFALSE 111428
// ComWalk ( un ) ;
111419: LD_VAR 0 2
111423: PPUSH
111424: CALL_OW 138
// SetClass ( un , class_sniper ) ;
111428: LD_VAR 0 2
111432: PPUSH
111433: LD_INT 5
111435: PPUSH
111436: CALL_OW 336
// end ;
111440: PPOPN 3
111442: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
111443: LD_EXP 160
111447: PUSH
111448: LD_EXP 178
111452: AND
111453: PUSH
111454: LD_OWVAR 67
111458: PUSH
111459: LD_INT 3
111461: LESS
111462: AND
111463: IFFALSE 111482
111465: GO 111467
111467: DISABLE
// Difficulty := Difficulty + 1 ;
111468: LD_ADDR_OWVAR 67
111472: PUSH
111473: LD_OWVAR 67
111477: PUSH
111478: LD_INT 1
111480: PLUS
111481: ST_TO_ADDR
111482: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
111483: LD_EXP 160
111487: PUSH
111488: LD_EXP 179
111492: AND
111493: IFFALSE 111596
111495: GO 111497
111497: DISABLE
111498: LD_INT 0
111500: PPUSH
// begin for i := 1 to 5 do
111501: LD_ADDR_VAR 0 1
111505: PUSH
111506: DOUBLE
111507: LD_INT 1
111509: DEC
111510: ST_TO_ADDR
111511: LD_INT 5
111513: PUSH
111514: FOR_TO
111515: IFFALSE 111594
// begin uc_nation := nation_nature ;
111517: LD_ADDR_OWVAR 21
111521: PUSH
111522: LD_INT 0
111524: ST_TO_ADDR
// uc_side := 0 ;
111525: LD_ADDR_OWVAR 20
111529: PUSH
111530: LD_INT 0
111532: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
111533: LD_ADDR_OWVAR 29
111537: PUSH
111538: LD_INT 12
111540: PUSH
111541: LD_INT 12
111543: PUSH
111544: EMPTY
111545: LIST
111546: LIST
111547: ST_TO_ADDR
// hc_agressivity := 20 ;
111548: LD_ADDR_OWVAR 35
111552: PUSH
111553: LD_INT 20
111555: ST_TO_ADDR
// hc_class := class_tiger ;
111556: LD_ADDR_OWVAR 28
111560: PUSH
111561: LD_INT 14
111563: ST_TO_ADDR
// hc_gallery :=  ;
111564: LD_ADDR_OWVAR 33
111568: PUSH
111569: LD_STRING 
111571: ST_TO_ADDR
// hc_name :=  ;
111572: LD_ADDR_OWVAR 26
111576: PUSH
111577: LD_STRING 
111579: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
111580: CALL_OW 44
111584: PPUSH
111585: LD_INT 0
111587: PPUSH
111588: CALL_OW 51
// end ;
111592: GO 111514
111594: POP
111595: POP
// end ;
111596: PPOPN 1
111598: END
// every 0 0$1 trigger StreamModeActive and sBomb do
111599: LD_EXP 160
111603: PUSH
111604: LD_EXP 180
111608: AND
111609: IFFALSE 111618
111611: GO 111613
111613: DISABLE
// StreamSibBomb ;
111614: CALL 111619 0 0
111618: END
// export function StreamSibBomb ; var i , x , y ; begin
111619: LD_INT 0
111621: PPUSH
111622: PPUSH
111623: PPUSH
111624: PPUSH
// result := false ;
111625: LD_ADDR_VAR 0 1
111629: PUSH
111630: LD_INT 0
111632: ST_TO_ADDR
// for i := 1 to 16 do
111633: LD_ADDR_VAR 0 2
111637: PUSH
111638: DOUBLE
111639: LD_INT 1
111641: DEC
111642: ST_TO_ADDR
111643: LD_INT 16
111645: PUSH
111646: FOR_TO
111647: IFFALSE 111846
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
111649: LD_ADDR_VAR 0 3
111653: PUSH
111654: LD_INT 10
111656: PUSH
111657: LD_INT 20
111659: PUSH
111660: LD_INT 30
111662: PUSH
111663: LD_INT 40
111665: PUSH
111666: LD_INT 50
111668: PUSH
111669: LD_INT 60
111671: PUSH
111672: LD_INT 70
111674: PUSH
111675: LD_INT 80
111677: PUSH
111678: LD_INT 90
111680: PUSH
111681: LD_INT 100
111683: PUSH
111684: LD_INT 110
111686: PUSH
111687: LD_INT 120
111689: PUSH
111690: LD_INT 130
111692: PUSH
111693: LD_INT 140
111695: PUSH
111696: LD_INT 150
111698: PUSH
111699: EMPTY
111700: LIST
111701: LIST
111702: LIST
111703: LIST
111704: LIST
111705: LIST
111706: LIST
111707: LIST
111708: LIST
111709: LIST
111710: LIST
111711: LIST
111712: LIST
111713: LIST
111714: LIST
111715: PUSH
111716: LD_INT 1
111718: PPUSH
111719: LD_INT 15
111721: PPUSH
111722: CALL_OW 12
111726: ARRAY
111727: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
111728: LD_ADDR_VAR 0 4
111732: PUSH
111733: LD_INT 10
111735: PUSH
111736: LD_INT 20
111738: PUSH
111739: LD_INT 30
111741: PUSH
111742: LD_INT 40
111744: PUSH
111745: LD_INT 50
111747: PUSH
111748: LD_INT 60
111750: PUSH
111751: LD_INT 70
111753: PUSH
111754: LD_INT 80
111756: PUSH
111757: LD_INT 90
111759: PUSH
111760: LD_INT 100
111762: PUSH
111763: LD_INT 110
111765: PUSH
111766: LD_INT 120
111768: PUSH
111769: LD_INT 130
111771: PUSH
111772: LD_INT 140
111774: PUSH
111775: LD_INT 150
111777: PUSH
111778: EMPTY
111779: LIST
111780: LIST
111781: LIST
111782: LIST
111783: LIST
111784: LIST
111785: LIST
111786: LIST
111787: LIST
111788: LIST
111789: LIST
111790: LIST
111791: LIST
111792: LIST
111793: LIST
111794: PUSH
111795: LD_INT 1
111797: PPUSH
111798: LD_INT 15
111800: PPUSH
111801: CALL_OW 12
111805: ARRAY
111806: ST_TO_ADDR
// if ValidHex ( x , y ) then
111807: LD_VAR 0 3
111811: PPUSH
111812: LD_VAR 0 4
111816: PPUSH
111817: CALL_OW 488
111821: IFFALSE 111844
// begin result := [ x , y ] ;
111823: LD_ADDR_VAR 0 1
111827: PUSH
111828: LD_VAR 0 3
111832: PUSH
111833: LD_VAR 0 4
111837: PUSH
111838: EMPTY
111839: LIST
111840: LIST
111841: ST_TO_ADDR
// break ;
111842: GO 111846
// end ; end ;
111844: GO 111646
111846: POP
111847: POP
// if result then
111848: LD_VAR 0 1
111852: IFFALSE 111912
// begin ToLua ( playSibBomb() ) ;
111854: LD_STRING playSibBomb()
111856: PPUSH
111857: CALL_OW 559
// wait ( 0 0$14 ) ;
111861: LD_INT 490
111863: PPUSH
111864: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
111868: LD_VAR 0 1
111872: PUSH
111873: LD_INT 1
111875: ARRAY
111876: PPUSH
111877: LD_VAR 0 1
111881: PUSH
111882: LD_INT 2
111884: ARRAY
111885: PPUSH
111886: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
111890: LD_VAR 0 1
111894: PUSH
111895: LD_INT 1
111897: ARRAY
111898: PPUSH
111899: LD_VAR 0 1
111903: PUSH
111904: LD_INT 2
111906: ARRAY
111907: PPUSH
111908: CALL_OW 429
// end ; end ;
111912: LD_VAR 0 1
111916: RET
// every 0 0$1 trigger StreamModeActive and sReset do
111917: LD_EXP 160
111921: PUSH
111922: LD_EXP 182
111926: AND
111927: IFFALSE 111939
111929: GO 111931
111931: DISABLE
// YouLost (  ) ;
111932: LD_STRING 
111934: PPUSH
111935: CALL_OW 104
111939: END
// every 0 0$1 trigger StreamModeActive and sFog do
111940: LD_EXP 160
111944: PUSH
111945: LD_EXP 181
111949: AND
111950: IFFALSE 111964
111952: GO 111954
111954: DISABLE
// FogOff ( your_side ) ;
111955: LD_OWVAR 2
111959: PPUSH
111960: CALL_OW 344
111964: END
// every 0 0$1 trigger StreamModeActive and sSun do
111965: LD_EXP 160
111969: PUSH
111970: LD_EXP 183
111974: AND
111975: IFFALSE 112003
111977: GO 111979
111979: DISABLE
// begin solar_recharge_percent := 0 ;
111980: LD_ADDR_OWVAR 79
111984: PUSH
111985: LD_INT 0
111987: ST_TO_ADDR
// wait ( 5 5$00 ) ;
111988: LD_INT 10500
111990: PPUSH
111991: CALL_OW 67
// solar_recharge_percent := 100 ;
111995: LD_ADDR_OWVAR 79
111999: PUSH
112000: LD_INT 100
112002: ST_TO_ADDR
// end ;
112003: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
112004: LD_EXP 160
112008: PUSH
112009: LD_EXP 184
112013: AND
112014: IFFALSE 112253
112016: GO 112018
112018: DISABLE
112019: LD_INT 0
112021: PPUSH
112022: PPUSH
112023: PPUSH
// begin tmp := [ ] ;
112024: LD_ADDR_VAR 0 3
112028: PUSH
112029: EMPTY
112030: ST_TO_ADDR
// for i := 1 to 6 do
112031: LD_ADDR_VAR 0 1
112035: PUSH
112036: DOUBLE
112037: LD_INT 1
112039: DEC
112040: ST_TO_ADDR
112041: LD_INT 6
112043: PUSH
112044: FOR_TO
112045: IFFALSE 112150
// begin uc_nation := nation_nature ;
112047: LD_ADDR_OWVAR 21
112051: PUSH
112052: LD_INT 0
112054: ST_TO_ADDR
// uc_side := 0 ;
112055: LD_ADDR_OWVAR 20
112059: PUSH
112060: LD_INT 0
112062: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
112063: LD_ADDR_OWVAR 29
112067: PUSH
112068: LD_INT 12
112070: PUSH
112071: LD_INT 12
112073: PUSH
112074: EMPTY
112075: LIST
112076: LIST
112077: ST_TO_ADDR
// hc_agressivity := 20 ;
112078: LD_ADDR_OWVAR 35
112082: PUSH
112083: LD_INT 20
112085: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
112086: LD_ADDR_OWVAR 28
112090: PUSH
112091: LD_INT 17
112093: ST_TO_ADDR
// hc_gallery :=  ;
112094: LD_ADDR_OWVAR 33
112098: PUSH
112099: LD_STRING 
112101: ST_TO_ADDR
// hc_name :=  ;
112102: LD_ADDR_OWVAR 26
112106: PUSH
112107: LD_STRING 
112109: ST_TO_ADDR
// un := CreateHuman ;
112110: LD_ADDR_VAR 0 2
112114: PUSH
112115: CALL_OW 44
112119: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
112120: LD_VAR 0 2
112124: PPUSH
112125: LD_INT 1
112127: PPUSH
112128: CALL_OW 51
// tmp := tmp ^ un ;
112132: LD_ADDR_VAR 0 3
112136: PUSH
112137: LD_VAR 0 3
112141: PUSH
112142: LD_VAR 0 2
112146: ADD
112147: ST_TO_ADDR
// end ;
112148: GO 112044
112150: POP
112151: POP
// repeat wait ( 0 0$1 ) ;
112152: LD_INT 35
112154: PPUSH
112155: CALL_OW 67
// for un in tmp do
112159: LD_ADDR_VAR 0 2
112163: PUSH
112164: LD_VAR 0 3
112168: PUSH
112169: FOR_IN
112170: IFFALSE 112244
// begin if IsDead ( un ) then
112172: LD_VAR 0 2
112176: PPUSH
112177: CALL_OW 301
112181: IFFALSE 112201
// begin tmp := tmp diff un ;
112183: LD_ADDR_VAR 0 3
112187: PUSH
112188: LD_VAR 0 3
112192: PUSH
112193: LD_VAR 0 2
112197: DIFF
112198: ST_TO_ADDR
// continue ;
112199: GO 112169
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
112201: LD_VAR 0 2
112205: PPUSH
112206: LD_INT 3
112208: PUSH
112209: LD_INT 22
112211: PUSH
112212: LD_INT 0
112214: PUSH
112215: EMPTY
112216: LIST
112217: LIST
112218: PUSH
112219: EMPTY
112220: LIST
112221: LIST
112222: PPUSH
112223: CALL_OW 69
112227: PPUSH
112228: LD_VAR 0 2
112232: PPUSH
112233: CALL_OW 74
112237: PPUSH
112238: CALL_OW 115
// end ;
112242: GO 112169
112244: POP
112245: POP
// until not tmp ;
112246: LD_VAR 0 3
112250: NOT
112251: IFFALSE 112152
// end ;
112253: PPOPN 3
112255: END
// every 0 0$1 trigger StreamModeActive and sTroll do
112256: LD_EXP 160
112260: PUSH
112261: LD_EXP 185
112265: AND
112266: IFFALSE 112320
112268: GO 112270
112270: DISABLE
// begin ToLua ( displayTroll(); ) ;
112271: LD_STRING displayTroll();
112273: PPUSH
112274: CALL_OW 559
// wait ( 3 3$00 ) ;
112278: LD_INT 6300
112280: PPUSH
112281: CALL_OW 67
// ToLua ( hideTroll(); ) ;
112285: LD_STRING hideTroll();
112287: PPUSH
112288: CALL_OW 559
// wait ( 1 1$00 ) ;
112292: LD_INT 2100
112294: PPUSH
112295: CALL_OW 67
// ToLua ( displayTroll(); ) ;
112299: LD_STRING displayTroll();
112301: PPUSH
112302: CALL_OW 559
// wait ( 1 1$00 ) ;
112306: LD_INT 2100
112308: PPUSH
112309: CALL_OW 67
// ToLua ( hideTroll(); ) ;
112313: LD_STRING hideTroll();
112315: PPUSH
112316: CALL_OW 559
// end ;
112320: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
112321: LD_EXP 160
112325: PUSH
112326: LD_EXP 186
112330: AND
112331: IFFALSE 112394
112333: GO 112335
112335: DISABLE
112336: LD_INT 0
112338: PPUSH
// begin p := 0 ;
112339: LD_ADDR_VAR 0 1
112343: PUSH
112344: LD_INT 0
112346: ST_TO_ADDR
// repeat game_speed := 1 ;
112347: LD_ADDR_OWVAR 65
112351: PUSH
112352: LD_INT 1
112354: ST_TO_ADDR
// wait ( 0 0$1 ) ;
112355: LD_INT 35
112357: PPUSH
112358: CALL_OW 67
// p := p + 1 ;
112362: LD_ADDR_VAR 0 1
112366: PUSH
112367: LD_VAR 0 1
112371: PUSH
112372: LD_INT 1
112374: PLUS
112375: ST_TO_ADDR
// until p >= 60 ;
112376: LD_VAR 0 1
112380: PUSH
112381: LD_INT 60
112383: GREATEREQUAL
112384: IFFALSE 112347
// game_speed := 4 ;
112386: LD_ADDR_OWVAR 65
112390: PUSH
112391: LD_INT 4
112393: ST_TO_ADDR
// end ;
112394: PPOPN 1
112396: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
112397: LD_EXP 160
112401: PUSH
112402: LD_EXP 187
112406: AND
112407: IFFALSE 112553
112409: GO 112411
112411: DISABLE
112412: LD_INT 0
112414: PPUSH
112415: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
112416: LD_ADDR_VAR 0 1
112420: PUSH
112421: LD_INT 22
112423: PUSH
112424: LD_OWVAR 2
112428: PUSH
112429: EMPTY
112430: LIST
112431: LIST
112432: PUSH
112433: LD_INT 2
112435: PUSH
112436: LD_INT 30
112438: PUSH
112439: LD_INT 0
112441: PUSH
112442: EMPTY
112443: LIST
112444: LIST
112445: PUSH
112446: LD_INT 30
112448: PUSH
112449: LD_INT 1
112451: PUSH
112452: EMPTY
112453: LIST
112454: LIST
112455: PUSH
112456: EMPTY
112457: LIST
112458: LIST
112459: LIST
112460: PUSH
112461: EMPTY
112462: LIST
112463: LIST
112464: PPUSH
112465: CALL_OW 69
112469: ST_TO_ADDR
// if not depot then
112470: LD_VAR 0 1
112474: NOT
112475: IFFALSE 112479
// exit ;
112477: GO 112553
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
112479: LD_ADDR_VAR 0 2
112483: PUSH
112484: LD_VAR 0 1
112488: PUSH
112489: LD_INT 1
112491: PPUSH
112492: LD_VAR 0 1
112496: PPUSH
112497: CALL_OW 12
112501: ARRAY
112502: PPUSH
112503: CALL_OW 274
112507: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
112508: LD_VAR 0 2
112512: PPUSH
112513: LD_INT 1
112515: PPUSH
112516: LD_INT 0
112518: PPUSH
112519: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
112523: LD_VAR 0 2
112527: PPUSH
112528: LD_INT 2
112530: PPUSH
112531: LD_INT 0
112533: PPUSH
112534: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
112538: LD_VAR 0 2
112542: PPUSH
112543: LD_INT 3
112545: PPUSH
112546: LD_INT 0
112548: PPUSH
112549: CALL_OW 277
// end ;
112553: PPOPN 2
112555: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
112556: LD_EXP 160
112560: PUSH
112561: LD_EXP 188
112565: AND
112566: IFFALSE 112663
112568: GO 112570
112570: DISABLE
112571: LD_INT 0
112573: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
112574: LD_ADDR_VAR 0 1
112578: PUSH
112579: LD_INT 22
112581: PUSH
112582: LD_OWVAR 2
112586: PUSH
112587: EMPTY
112588: LIST
112589: LIST
112590: PUSH
112591: LD_INT 21
112593: PUSH
112594: LD_INT 1
112596: PUSH
112597: EMPTY
112598: LIST
112599: LIST
112600: PUSH
112601: LD_INT 3
112603: PUSH
112604: LD_INT 23
112606: PUSH
112607: LD_INT 0
112609: PUSH
112610: EMPTY
112611: LIST
112612: LIST
112613: PUSH
112614: EMPTY
112615: LIST
112616: LIST
112617: PUSH
112618: EMPTY
112619: LIST
112620: LIST
112621: LIST
112622: PPUSH
112623: CALL_OW 69
112627: ST_TO_ADDR
// if not tmp then
112628: LD_VAR 0 1
112632: NOT
112633: IFFALSE 112637
// exit ;
112635: GO 112663
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
112637: LD_VAR 0 1
112641: PUSH
112642: LD_INT 1
112644: PPUSH
112645: LD_VAR 0 1
112649: PPUSH
112650: CALL_OW 12
112654: ARRAY
112655: PPUSH
112656: LD_INT 200
112658: PPUSH
112659: CALL_OW 234
// end ;
112663: PPOPN 1
112665: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
112666: LD_EXP 160
112670: PUSH
112671: LD_EXP 189
112675: AND
112676: IFFALSE 112755
112678: GO 112680
112680: DISABLE
112681: LD_INT 0
112683: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
112684: LD_ADDR_VAR 0 1
112688: PUSH
112689: LD_INT 22
112691: PUSH
112692: LD_OWVAR 2
112696: PUSH
112697: EMPTY
112698: LIST
112699: LIST
112700: PUSH
112701: LD_INT 21
112703: PUSH
112704: LD_INT 2
112706: PUSH
112707: EMPTY
112708: LIST
112709: LIST
112710: PUSH
112711: EMPTY
112712: LIST
112713: LIST
112714: PPUSH
112715: CALL_OW 69
112719: ST_TO_ADDR
// if not tmp then
112720: LD_VAR 0 1
112724: NOT
112725: IFFALSE 112729
// exit ;
112727: GO 112755
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
112729: LD_VAR 0 1
112733: PUSH
112734: LD_INT 1
112736: PPUSH
112737: LD_VAR 0 1
112741: PPUSH
112742: CALL_OW 12
112746: ARRAY
112747: PPUSH
112748: LD_INT 60
112750: PPUSH
112751: CALL_OW 234
// end ;
112755: PPOPN 1
112757: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
112758: LD_EXP 160
112762: PUSH
112763: LD_EXP 190
112767: AND
112768: IFFALSE 112867
112770: GO 112772
112772: DISABLE
112773: LD_INT 0
112775: PPUSH
112776: PPUSH
// begin enable ;
112777: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
112778: LD_ADDR_VAR 0 1
112782: PUSH
112783: LD_INT 22
112785: PUSH
112786: LD_OWVAR 2
112790: PUSH
112791: EMPTY
112792: LIST
112793: LIST
112794: PUSH
112795: LD_INT 61
112797: PUSH
112798: EMPTY
112799: LIST
112800: PUSH
112801: LD_INT 33
112803: PUSH
112804: LD_INT 2
112806: PUSH
112807: EMPTY
112808: LIST
112809: LIST
112810: PUSH
112811: EMPTY
112812: LIST
112813: LIST
112814: LIST
112815: PPUSH
112816: CALL_OW 69
112820: ST_TO_ADDR
// if not tmp then
112821: LD_VAR 0 1
112825: NOT
112826: IFFALSE 112830
// exit ;
112828: GO 112867
// for i in tmp do
112830: LD_ADDR_VAR 0 2
112834: PUSH
112835: LD_VAR 0 1
112839: PUSH
112840: FOR_IN
112841: IFFALSE 112865
// if IsControledBy ( i ) then
112843: LD_VAR 0 2
112847: PPUSH
112848: CALL_OW 312
112852: IFFALSE 112863
// ComUnlink ( i ) ;
112854: LD_VAR 0 2
112858: PPUSH
112859: CALL_OW 136
112863: GO 112840
112865: POP
112866: POP
// end ;
112867: PPOPN 2
112869: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
112870: LD_EXP 160
112874: PUSH
112875: LD_EXP 191
112879: AND
112880: IFFALSE 113020
112882: GO 112884
112884: DISABLE
112885: LD_INT 0
112887: PPUSH
112888: PPUSH
// begin ToLua ( displayPowell(); ) ;
112889: LD_STRING displayPowell();
112891: PPUSH
112892: CALL_OW 559
// uc_side := 0 ;
112896: LD_ADDR_OWVAR 20
112900: PUSH
112901: LD_INT 0
112903: ST_TO_ADDR
// uc_nation := 2 ;
112904: LD_ADDR_OWVAR 21
112908: PUSH
112909: LD_INT 2
112911: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
112912: LD_ADDR_OWVAR 37
112916: PUSH
112917: LD_INT 14
112919: ST_TO_ADDR
// vc_engine := engine_siberite ;
112920: LD_ADDR_OWVAR 39
112924: PUSH
112925: LD_INT 3
112927: ST_TO_ADDR
// vc_control := control_apeman ;
112928: LD_ADDR_OWVAR 38
112932: PUSH
112933: LD_INT 5
112935: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
112936: LD_ADDR_OWVAR 40
112940: PUSH
112941: LD_INT 29
112943: ST_TO_ADDR
// un := CreateVehicle ;
112944: LD_ADDR_VAR 0 2
112948: PUSH
112949: CALL_OW 45
112953: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
112954: LD_VAR 0 2
112958: PPUSH
112959: LD_INT 1
112961: PPUSH
112962: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
112966: LD_INT 35
112968: PPUSH
112969: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
112973: LD_VAR 0 2
112977: PPUSH
112978: LD_INT 22
112980: PUSH
112981: LD_OWVAR 2
112985: PUSH
112986: EMPTY
112987: LIST
112988: LIST
112989: PPUSH
112990: CALL_OW 69
112994: PPUSH
112995: LD_VAR 0 2
112999: PPUSH
113000: CALL_OW 74
113004: PPUSH
113005: CALL_OW 115
// until IsDead ( un ) ;
113009: LD_VAR 0 2
113013: PPUSH
113014: CALL_OW 301
113018: IFFALSE 112966
// end ;
113020: PPOPN 2
113022: END
// every 0 0$1 trigger StreamModeActive and sStu do
113023: LD_EXP 160
113027: PUSH
113028: LD_EXP 199
113032: AND
113033: IFFALSE 113049
113035: GO 113037
113037: DISABLE
// begin ToLua ( displayStucuk(); ) ;
113038: LD_STRING displayStucuk();
113040: PPUSH
113041: CALL_OW 559
// ResetFog ;
113045: CALL_OW 335
// end ;
113049: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
113050: LD_EXP 160
113054: PUSH
113055: LD_EXP 192
113059: AND
113060: IFFALSE 113201
113062: GO 113064
113064: DISABLE
113065: LD_INT 0
113067: PPUSH
113068: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
113069: LD_ADDR_VAR 0 2
113073: PUSH
113074: LD_INT 22
113076: PUSH
113077: LD_OWVAR 2
113081: PUSH
113082: EMPTY
113083: LIST
113084: LIST
113085: PUSH
113086: LD_INT 21
113088: PUSH
113089: LD_INT 1
113091: PUSH
113092: EMPTY
113093: LIST
113094: LIST
113095: PUSH
113096: EMPTY
113097: LIST
113098: LIST
113099: PPUSH
113100: CALL_OW 69
113104: ST_TO_ADDR
// if not tmp then
113105: LD_VAR 0 2
113109: NOT
113110: IFFALSE 113114
// exit ;
113112: GO 113201
// un := tmp [ rand ( 1 , tmp ) ] ;
113114: LD_ADDR_VAR 0 1
113118: PUSH
113119: LD_VAR 0 2
113123: PUSH
113124: LD_INT 1
113126: PPUSH
113127: LD_VAR 0 2
113131: PPUSH
113132: CALL_OW 12
113136: ARRAY
113137: ST_TO_ADDR
// SetSide ( un , 0 ) ;
113138: LD_VAR 0 1
113142: PPUSH
113143: LD_INT 0
113145: PPUSH
113146: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
113150: LD_VAR 0 1
113154: PPUSH
113155: LD_OWVAR 3
113159: PUSH
113160: LD_VAR 0 1
113164: DIFF
113165: PPUSH
113166: LD_VAR 0 1
113170: PPUSH
113171: CALL_OW 74
113175: PPUSH
113176: CALL_OW 115
// wait ( 0 0$20 ) ;
113180: LD_INT 700
113182: PPUSH
113183: CALL_OW 67
// SetSide ( un , your_side ) ;
113187: LD_VAR 0 1
113191: PPUSH
113192: LD_OWVAR 2
113196: PPUSH
113197: CALL_OW 235
// end ;
113201: PPOPN 2
113203: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
113204: LD_EXP 160
113208: PUSH
113209: LD_EXP 193
113213: AND
113214: IFFALSE 113320
113216: GO 113218
113218: DISABLE
113219: LD_INT 0
113221: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
113222: LD_ADDR_VAR 0 1
113226: PUSH
113227: LD_INT 22
113229: PUSH
113230: LD_OWVAR 2
113234: PUSH
113235: EMPTY
113236: LIST
113237: LIST
113238: PUSH
113239: LD_INT 2
113241: PUSH
113242: LD_INT 30
113244: PUSH
113245: LD_INT 0
113247: PUSH
113248: EMPTY
113249: LIST
113250: LIST
113251: PUSH
113252: LD_INT 30
113254: PUSH
113255: LD_INT 1
113257: PUSH
113258: EMPTY
113259: LIST
113260: LIST
113261: PUSH
113262: EMPTY
113263: LIST
113264: LIST
113265: LIST
113266: PUSH
113267: EMPTY
113268: LIST
113269: LIST
113270: PPUSH
113271: CALL_OW 69
113275: ST_TO_ADDR
// if not depot then
113276: LD_VAR 0 1
113280: NOT
113281: IFFALSE 113285
// exit ;
113283: GO 113320
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
113285: LD_VAR 0 1
113289: PUSH
113290: LD_INT 1
113292: ARRAY
113293: PPUSH
113294: CALL_OW 250
113298: PPUSH
113299: LD_VAR 0 1
113303: PUSH
113304: LD_INT 1
113306: ARRAY
113307: PPUSH
113308: CALL_OW 251
113312: PPUSH
113313: LD_INT 70
113315: PPUSH
113316: CALL_OW 495
// end ;
113320: PPOPN 1
113322: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
113323: LD_EXP 160
113327: PUSH
113328: LD_EXP 194
113332: AND
113333: IFFALSE 113544
113335: GO 113337
113337: DISABLE
113338: LD_INT 0
113340: PPUSH
113341: PPUSH
113342: PPUSH
113343: PPUSH
113344: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
113345: LD_ADDR_VAR 0 5
113349: PUSH
113350: LD_INT 22
113352: PUSH
113353: LD_OWVAR 2
113357: PUSH
113358: EMPTY
113359: LIST
113360: LIST
113361: PUSH
113362: LD_INT 21
113364: PUSH
113365: LD_INT 1
113367: PUSH
113368: EMPTY
113369: LIST
113370: LIST
113371: PUSH
113372: EMPTY
113373: LIST
113374: LIST
113375: PPUSH
113376: CALL_OW 69
113380: ST_TO_ADDR
// if not tmp then
113381: LD_VAR 0 5
113385: NOT
113386: IFFALSE 113390
// exit ;
113388: GO 113544
// for i in tmp do
113390: LD_ADDR_VAR 0 1
113394: PUSH
113395: LD_VAR 0 5
113399: PUSH
113400: FOR_IN
113401: IFFALSE 113542
// begin d := rand ( 0 , 5 ) ;
113403: LD_ADDR_VAR 0 4
113407: PUSH
113408: LD_INT 0
113410: PPUSH
113411: LD_INT 5
113413: PPUSH
113414: CALL_OW 12
113418: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
113419: LD_ADDR_VAR 0 2
113423: PUSH
113424: LD_VAR 0 1
113428: PPUSH
113429: CALL_OW 250
113433: PPUSH
113434: LD_VAR 0 4
113438: PPUSH
113439: LD_INT 3
113441: PPUSH
113442: LD_INT 12
113444: PPUSH
113445: CALL_OW 12
113449: PPUSH
113450: CALL_OW 272
113454: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
113455: LD_ADDR_VAR 0 3
113459: PUSH
113460: LD_VAR 0 1
113464: PPUSH
113465: CALL_OW 251
113469: PPUSH
113470: LD_VAR 0 4
113474: PPUSH
113475: LD_INT 3
113477: PPUSH
113478: LD_INT 12
113480: PPUSH
113481: CALL_OW 12
113485: PPUSH
113486: CALL_OW 273
113490: ST_TO_ADDR
// if ValidHex ( x , y ) then
113491: LD_VAR 0 2
113495: PPUSH
113496: LD_VAR 0 3
113500: PPUSH
113501: CALL_OW 488
113505: IFFALSE 113540
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
113507: LD_VAR 0 1
113511: PPUSH
113512: LD_VAR 0 2
113516: PPUSH
113517: LD_VAR 0 3
113521: PPUSH
113522: LD_INT 3
113524: PPUSH
113525: LD_INT 6
113527: PPUSH
113528: CALL_OW 12
113532: PPUSH
113533: LD_INT 1
113535: PPUSH
113536: CALL_OW 483
// end ;
113540: GO 113400
113542: POP
113543: POP
// end ;
113544: PPOPN 5
113546: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
113547: LD_EXP 160
113551: PUSH
113552: LD_EXP 195
113556: AND
113557: IFFALSE 113651
113559: GO 113561
113561: DISABLE
113562: LD_INT 0
113564: PPUSH
113565: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
113566: LD_ADDR_VAR 0 2
113570: PUSH
113571: LD_INT 22
113573: PUSH
113574: LD_OWVAR 2
113578: PUSH
113579: EMPTY
113580: LIST
113581: LIST
113582: PUSH
113583: LD_INT 32
113585: PUSH
113586: LD_INT 1
113588: PUSH
113589: EMPTY
113590: LIST
113591: LIST
113592: PUSH
113593: LD_INT 21
113595: PUSH
113596: LD_INT 2
113598: PUSH
113599: EMPTY
113600: LIST
113601: LIST
113602: PUSH
113603: EMPTY
113604: LIST
113605: LIST
113606: LIST
113607: PPUSH
113608: CALL_OW 69
113612: ST_TO_ADDR
// if not tmp then
113613: LD_VAR 0 2
113617: NOT
113618: IFFALSE 113622
// exit ;
113620: GO 113651
// for i in tmp do
113622: LD_ADDR_VAR 0 1
113626: PUSH
113627: LD_VAR 0 2
113631: PUSH
113632: FOR_IN
113633: IFFALSE 113649
// SetFuel ( i , 0 ) ;
113635: LD_VAR 0 1
113639: PPUSH
113640: LD_INT 0
113642: PPUSH
113643: CALL_OW 240
113647: GO 113632
113649: POP
113650: POP
// end ;
113651: PPOPN 2
113653: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
113654: LD_EXP 160
113658: PUSH
113659: LD_EXP 196
113663: AND
113664: IFFALSE 113730
113666: GO 113668
113668: DISABLE
113669: LD_INT 0
113671: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
113672: LD_ADDR_VAR 0 1
113676: PUSH
113677: LD_INT 22
113679: PUSH
113680: LD_OWVAR 2
113684: PUSH
113685: EMPTY
113686: LIST
113687: LIST
113688: PUSH
113689: LD_INT 30
113691: PUSH
113692: LD_INT 29
113694: PUSH
113695: EMPTY
113696: LIST
113697: LIST
113698: PUSH
113699: EMPTY
113700: LIST
113701: LIST
113702: PPUSH
113703: CALL_OW 69
113707: ST_TO_ADDR
// if not tmp then
113708: LD_VAR 0 1
113712: NOT
113713: IFFALSE 113717
// exit ;
113715: GO 113730
// DestroyUnit ( tmp [ 1 ] ) ;
113717: LD_VAR 0 1
113721: PUSH
113722: LD_INT 1
113724: ARRAY
113725: PPUSH
113726: CALL_OW 65
// end ;
113730: PPOPN 1
113732: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
113733: LD_EXP 160
113737: PUSH
113738: LD_EXP 198
113742: AND
113743: IFFALSE 113872
113745: GO 113747
113747: DISABLE
113748: LD_INT 0
113750: PPUSH
// begin uc_side := 0 ;
113751: LD_ADDR_OWVAR 20
113755: PUSH
113756: LD_INT 0
113758: ST_TO_ADDR
// uc_nation := nation_arabian ;
113759: LD_ADDR_OWVAR 21
113763: PUSH
113764: LD_INT 2
113766: ST_TO_ADDR
// hc_gallery :=  ;
113767: LD_ADDR_OWVAR 33
113771: PUSH
113772: LD_STRING 
113774: ST_TO_ADDR
// hc_name :=  ;
113775: LD_ADDR_OWVAR 26
113779: PUSH
113780: LD_STRING 
113782: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
113783: LD_INT 1
113785: PPUSH
113786: LD_INT 11
113788: PPUSH
113789: LD_INT 10
113791: PPUSH
113792: CALL_OW 380
// un := CreateHuman ;
113796: LD_ADDR_VAR 0 1
113800: PUSH
113801: CALL_OW 44
113805: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
113806: LD_VAR 0 1
113810: PPUSH
113811: LD_INT 1
113813: PPUSH
113814: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
113818: LD_INT 35
113820: PPUSH
113821: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
113825: LD_VAR 0 1
113829: PPUSH
113830: LD_INT 22
113832: PUSH
113833: LD_OWVAR 2
113837: PUSH
113838: EMPTY
113839: LIST
113840: LIST
113841: PPUSH
113842: CALL_OW 69
113846: PPUSH
113847: LD_VAR 0 1
113851: PPUSH
113852: CALL_OW 74
113856: PPUSH
113857: CALL_OW 115
// until IsDead ( un ) ;
113861: LD_VAR 0 1
113865: PPUSH
113866: CALL_OW 301
113870: IFFALSE 113818
// end ;
113872: PPOPN 1
113874: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
113875: LD_EXP 160
113879: PUSH
113880: LD_EXP 200
113884: AND
113885: IFFALSE 113897
113887: GO 113889
113889: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
113890: LD_STRING earthquake(getX(game), 0, 32)
113892: PPUSH
113893: CALL_OW 559
113897: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
113898: LD_EXP 160
113902: PUSH
113903: LD_EXP 201
113907: AND
113908: IFFALSE 113999
113910: GO 113912
113912: DISABLE
113913: LD_INT 0
113915: PPUSH
// begin enable ;
113916: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
113917: LD_ADDR_VAR 0 1
113921: PUSH
113922: LD_INT 22
113924: PUSH
113925: LD_OWVAR 2
113929: PUSH
113930: EMPTY
113931: LIST
113932: LIST
113933: PUSH
113934: LD_INT 21
113936: PUSH
113937: LD_INT 2
113939: PUSH
113940: EMPTY
113941: LIST
113942: LIST
113943: PUSH
113944: LD_INT 33
113946: PUSH
113947: LD_INT 3
113949: PUSH
113950: EMPTY
113951: LIST
113952: LIST
113953: PUSH
113954: EMPTY
113955: LIST
113956: LIST
113957: LIST
113958: PPUSH
113959: CALL_OW 69
113963: ST_TO_ADDR
// if not tmp then
113964: LD_VAR 0 1
113968: NOT
113969: IFFALSE 113973
// exit ;
113971: GO 113999
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
113973: LD_VAR 0 1
113977: PUSH
113978: LD_INT 1
113980: PPUSH
113981: LD_VAR 0 1
113985: PPUSH
113986: CALL_OW 12
113990: ARRAY
113991: PPUSH
113992: LD_INT 1
113994: PPUSH
113995: CALL_OW 234
// end ;
113999: PPOPN 1
114001: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
114002: LD_EXP 160
114006: PUSH
114007: LD_EXP 202
114011: AND
114012: IFFALSE 114153
114014: GO 114016
114016: DISABLE
114017: LD_INT 0
114019: PPUSH
114020: PPUSH
114021: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
114022: LD_ADDR_VAR 0 3
114026: PUSH
114027: LD_INT 22
114029: PUSH
114030: LD_OWVAR 2
114034: PUSH
114035: EMPTY
114036: LIST
114037: LIST
114038: PUSH
114039: LD_INT 25
114041: PUSH
114042: LD_INT 1
114044: PUSH
114045: EMPTY
114046: LIST
114047: LIST
114048: PUSH
114049: EMPTY
114050: LIST
114051: LIST
114052: PPUSH
114053: CALL_OW 69
114057: ST_TO_ADDR
// if not tmp then
114058: LD_VAR 0 3
114062: NOT
114063: IFFALSE 114067
// exit ;
114065: GO 114153
// un := tmp [ rand ( 1 , tmp ) ] ;
114067: LD_ADDR_VAR 0 2
114071: PUSH
114072: LD_VAR 0 3
114076: PUSH
114077: LD_INT 1
114079: PPUSH
114080: LD_VAR 0 3
114084: PPUSH
114085: CALL_OW 12
114089: ARRAY
114090: ST_TO_ADDR
// if Crawls ( un ) then
114091: LD_VAR 0 2
114095: PPUSH
114096: CALL_OW 318
114100: IFFALSE 114111
// ComWalk ( un ) ;
114102: LD_VAR 0 2
114106: PPUSH
114107: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
114111: LD_VAR 0 2
114115: PPUSH
114116: LD_INT 9
114118: PPUSH
114119: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
114123: LD_INT 28
114125: PPUSH
114126: LD_OWVAR 2
114130: PPUSH
114131: LD_INT 2
114133: PPUSH
114134: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
114138: LD_INT 29
114140: PPUSH
114141: LD_OWVAR 2
114145: PPUSH
114146: LD_INT 2
114148: PPUSH
114149: CALL_OW 322
// end ;
114153: PPOPN 3
114155: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
114156: LD_EXP 160
114160: PUSH
114161: LD_EXP 203
114165: AND
114166: IFFALSE 114277
114168: GO 114170
114170: DISABLE
114171: LD_INT 0
114173: PPUSH
114174: PPUSH
114175: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
114176: LD_ADDR_VAR 0 3
114180: PUSH
114181: LD_INT 22
114183: PUSH
114184: LD_OWVAR 2
114188: PUSH
114189: EMPTY
114190: LIST
114191: LIST
114192: PUSH
114193: LD_INT 25
114195: PUSH
114196: LD_INT 1
114198: PUSH
114199: EMPTY
114200: LIST
114201: LIST
114202: PUSH
114203: EMPTY
114204: LIST
114205: LIST
114206: PPUSH
114207: CALL_OW 69
114211: ST_TO_ADDR
// if not tmp then
114212: LD_VAR 0 3
114216: NOT
114217: IFFALSE 114221
// exit ;
114219: GO 114277
// un := tmp [ rand ( 1 , tmp ) ] ;
114221: LD_ADDR_VAR 0 2
114225: PUSH
114226: LD_VAR 0 3
114230: PUSH
114231: LD_INT 1
114233: PPUSH
114234: LD_VAR 0 3
114238: PPUSH
114239: CALL_OW 12
114243: ARRAY
114244: ST_TO_ADDR
// if Crawls ( un ) then
114245: LD_VAR 0 2
114249: PPUSH
114250: CALL_OW 318
114254: IFFALSE 114265
// ComWalk ( un ) ;
114256: LD_VAR 0 2
114260: PPUSH
114261: CALL_OW 138
// SetClass ( un , class_mortar ) ;
114265: LD_VAR 0 2
114269: PPUSH
114270: LD_INT 8
114272: PPUSH
114273: CALL_OW 336
// end ;
114277: PPOPN 3
114279: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
114280: LD_EXP 160
114284: PUSH
114285: LD_EXP 204
114289: AND
114290: IFFALSE 114434
114292: GO 114294
114294: DISABLE
114295: LD_INT 0
114297: PPUSH
114298: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
114299: LD_ADDR_VAR 0 2
114303: PUSH
114304: LD_INT 22
114306: PUSH
114307: LD_OWVAR 2
114311: PUSH
114312: EMPTY
114313: LIST
114314: LIST
114315: PUSH
114316: LD_INT 21
114318: PUSH
114319: LD_INT 2
114321: PUSH
114322: EMPTY
114323: LIST
114324: LIST
114325: PUSH
114326: LD_INT 2
114328: PUSH
114329: LD_INT 34
114331: PUSH
114332: LD_INT 12
114334: PUSH
114335: EMPTY
114336: LIST
114337: LIST
114338: PUSH
114339: LD_INT 34
114341: PUSH
114342: LD_INT 51
114344: PUSH
114345: EMPTY
114346: LIST
114347: LIST
114348: PUSH
114349: LD_INT 34
114351: PUSH
114352: LD_INT 32
114354: PUSH
114355: EMPTY
114356: LIST
114357: LIST
114358: PUSH
114359: EMPTY
114360: LIST
114361: LIST
114362: LIST
114363: LIST
114364: PUSH
114365: EMPTY
114366: LIST
114367: LIST
114368: LIST
114369: PPUSH
114370: CALL_OW 69
114374: ST_TO_ADDR
// if not tmp then
114375: LD_VAR 0 2
114379: NOT
114380: IFFALSE 114384
// exit ;
114382: GO 114434
// for i in tmp do
114384: LD_ADDR_VAR 0 1
114388: PUSH
114389: LD_VAR 0 2
114393: PUSH
114394: FOR_IN
114395: IFFALSE 114432
// if GetCargo ( i , mat_artifact ) = 0 then
114397: LD_VAR 0 1
114401: PPUSH
114402: LD_INT 4
114404: PPUSH
114405: CALL_OW 289
114409: PUSH
114410: LD_INT 0
114412: EQUAL
114413: IFFALSE 114430
// SetCargo ( i , mat_siberit , 100 ) ;
114415: LD_VAR 0 1
114419: PPUSH
114420: LD_INT 3
114422: PPUSH
114423: LD_INT 100
114425: PPUSH
114426: CALL_OW 290
114430: GO 114394
114432: POP
114433: POP
// end ;
114434: PPOPN 2
114436: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
114437: LD_EXP 160
114441: PUSH
114442: LD_EXP 205
114446: AND
114447: IFFALSE 114630
114449: GO 114451
114451: DISABLE
114452: LD_INT 0
114454: PPUSH
114455: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
114456: LD_ADDR_VAR 0 2
114460: PUSH
114461: LD_INT 22
114463: PUSH
114464: LD_OWVAR 2
114468: PUSH
114469: EMPTY
114470: LIST
114471: LIST
114472: PPUSH
114473: CALL_OW 69
114477: ST_TO_ADDR
// if not tmp then
114478: LD_VAR 0 2
114482: NOT
114483: IFFALSE 114487
// exit ;
114485: GO 114630
// for i := 1 to 2 do
114487: LD_ADDR_VAR 0 1
114491: PUSH
114492: DOUBLE
114493: LD_INT 1
114495: DEC
114496: ST_TO_ADDR
114497: LD_INT 2
114499: PUSH
114500: FOR_TO
114501: IFFALSE 114628
// begin uc_side := your_side ;
114503: LD_ADDR_OWVAR 20
114507: PUSH
114508: LD_OWVAR 2
114512: ST_TO_ADDR
// uc_nation := nation_american ;
114513: LD_ADDR_OWVAR 21
114517: PUSH
114518: LD_INT 1
114520: ST_TO_ADDR
// vc_chassis := us_morphling ;
114521: LD_ADDR_OWVAR 37
114525: PUSH
114526: LD_INT 5
114528: ST_TO_ADDR
// vc_engine := engine_siberite ;
114529: LD_ADDR_OWVAR 39
114533: PUSH
114534: LD_INT 3
114536: ST_TO_ADDR
// vc_control := control_computer ;
114537: LD_ADDR_OWVAR 38
114541: PUSH
114542: LD_INT 3
114544: ST_TO_ADDR
// vc_weapon := us_double_laser ;
114545: LD_ADDR_OWVAR 40
114549: PUSH
114550: LD_INT 10
114552: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
114553: LD_VAR 0 2
114557: PUSH
114558: LD_INT 1
114560: ARRAY
114561: PPUSH
114562: CALL_OW 310
114566: NOT
114567: IFFALSE 114614
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
114569: CALL_OW 45
114573: PPUSH
114574: LD_VAR 0 2
114578: PUSH
114579: LD_INT 1
114581: ARRAY
114582: PPUSH
114583: CALL_OW 250
114587: PPUSH
114588: LD_VAR 0 2
114592: PUSH
114593: LD_INT 1
114595: ARRAY
114596: PPUSH
114597: CALL_OW 251
114601: PPUSH
114602: LD_INT 12
114604: PPUSH
114605: LD_INT 1
114607: PPUSH
114608: CALL_OW 50
114612: GO 114626
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
114614: CALL_OW 45
114618: PPUSH
114619: LD_INT 1
114621: PPUSH
114622: CALL_OW 51
// end ;
114626: GO 114500
114628: POP
114629: POP
// end ;
114630: PPOPN 2
114632: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
114633: LD_EXP 160
114637: PUSH
114638: LD_EXP 206
114642: AND
114643: IFFALSE 114865
114645: GO 114647
114647: DISABLE
114648: LD_INT 0
114650: PPUSH
114651: PPUSH
114652: PPUSH
114653: PPUSH
114654: PPUSH
114655: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
114656: LD_ADDR_VAR 0 6
114660: PUSH
114661: LD_INT 22
114663: PUSH
114664: LD_OWVAR 2
114668: PUSH
114669: EMPTY
114670: LIST
114671: LIST
114672: PUSH
114673: LD_INT 21
114675: PUSH
114676: LD_INT 1
114678: PUSH
114679: EMPTY
114680: LIST
114681: LIST
114682: PUSH
114683: LD_INT 3
114685: PUSH
114686: LD_INT 23
114688: PUSH
114689: LD_INT 0
114691: PUSH
114692: EMPTY
114693: LIST
114694: LIST
114695: PUSH
114696: EMPTY
114697: LIST
114698: LIST
114699: PUSH
114700: EMPTY
114701: LIST
114702: LIST
114703: LIST
114704: PPUSH
114705: CALL_OW 69
114709: ST_TO_ADDR
// if not tmp then
114710: LD_VAR 0 6
114714: NOT
114715: IFFALSE 114719
// exit ;
114717: GO 114865
// s1 := rand ( 1 , 4 ) ;
114719: LD_ADDR_VAR 0 2
114723: PUSH
114724: LD_INT 1
114726: PPUSH
114727: LD_INT 4
114729: PPUSH
114730: CALL_OW 12
114734: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
114735: LD_ADDR_VAR 0 4
114739: PUSH
114740: LD_VAR 0 6
114744: PUSH
114745: LD_INT 1
114747: ARRAY
114748: PPUSH
114749: LD_VAR 0 2
114753: PPUSH
114754: CALL_OW 259
114758: ST_TO_ADDR
// if s1 = 1 then
114759: LD_VAR 0 2
114763: PUSH
114764: LD_INT 1
114766: EQUAL
114767: IFFALSE 114787
// s2 := rand ( 2 , 4 ) else
114769: LD_ADDR_VAR 0 3
114773: PUSH
114774: LD_INT 2
114776: PPUSH
114777: LD_INT 4
114779: PPUSH
114780: CALL_OW 12
114784: ST_TO_ADDR
114785: GO 114795
// s2 := 1 ;
114787: LD_ADDR_VAR 0 3
114791: PUSH
114792: LD_INT 1
114794: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
114795: LD_ADDR_VAR 0 5
114799: PUSH
114800: LD_VAR 0 6
114804: PUSH
114805: LD_INT 1
114807: ARRAY
114808: PPUSH
114809: LD_VAR 0 3
114813: PPUSH
114814: CALL_OW 259
114818: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
114819: LD_VAR 0 6
114823: PUSH
114824: LD_INT 1
114826: ARRAY
114827: PPUSH
114828: LD_VAR 0 2
114832: PPUSH
114833: LD_VAR 0 5
114837: PPUSH
114838: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
114842: LD_VAR 0 6
114846: PUSH
114847: LD_INT 1
114849: ARRAY
114850: PPUSH
114851: LD_VAR 0 3
114855: PPUSH
114856: LD_VAR 0 4
114860: PPUSH
114861: CALL_OW 237
// end ;
114865: PPOPN 6
114867: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
114868: LD_EXP 160
114872: PUSH
114873: LD_EXP 207
114877: AND
114878: IFFALSE 114957
114880: GO 114882
114882: DISABLE
114883: LD_INT 0
114885: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
114886: LD_ADDR_VAR 0 1
114890: PUSH
114891: LD_INT 22
114893: PUSH
114894: LD_OWVAR 2
114898: PUSH
114899: EMPTY
114900: LIST
114901: LIST
114902: PUSH
114903: LD_INT 30
114905: PUSH
114906: LD_INT 3
114908: PUSH
114909: EMPTY
114910: LIST
114911: LIST
114912: PUSH
114913: EMPTY
114914: LIST
114915: LIST
114916: PPUSH
114917: CALL_OW 69
114921: ST_TO_ADDR
// if not tmp then
114922: LD_VAR 0 1
114926: NOT
114927: IFFALSE 114931
// exit ;
114929: GO 114957
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
114931: LD_VAR 0 1
114935: PUSH
114936: LD_INT 1
114938: PPUSH
114939: LD_VAR 0 1
114943: PPUSH
114944: CALL_OW 12
114948: ARRAY
114949: PPUSH
114950: LD_INT 1
114952: PPUSH
114953: CALL_OW 234
// end ;
114957: PPOPN 1
114959: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
114960: LD_EXP 160
114964: PUSH
114965: LD_EXP 208
114969: AND
114970: IFFALSE 115082
114972: GO 114974
114974: DISABLE
114975: LD_INT 0
114977: PPUSH
114978: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
114979: LD_ADDR_VAR 0 2
114983: PUSH
114984: LD_INT 22
114986: PUSH
114987: LD_OWVAR 2
114991: PUSH
114992: EMPTY
114993: LIST
114994: LIST
114995: PUSH
114996: LD_INT 2
114998: PUSH
114999: LD_INT 30
115001: PUSH
115002: LD_INT 27
115004: PUSH
115005: EMPTY
115006: LIST
115007: LIST
115008: PUSH
115009: LD_INT 30
115011: PUSH
115012: LD_INT 26
115014: PUSH
115015: EMPTY
115016: LIST
115017: LIST
115018: PUSH
115019: LD_INT 30
115021: PUSH
115022: LD_INT 28
115024: PUSH
115025: EMPTY
115026: LIST
115027: LIST
115028: PUSH
115029: EMPTY
115030: LIST
115031: LIST
115032: LIST
115033: LIST
115034: PUSH
115035: EMPTY
115036: LIST
115037: LIST
115038: PPUSH
115039: CALL_OW 69
115043: ST_TO_ADDR
// if not tmp then
115044: LD_VAR 0 2
115048: NOT
115049: IFFALSE 115053
// exit ;
115051: GO 115082
// for i in tmp do
115053: LD_ADDR_VAR 0 1
115057: PUSH
115058: LD_VAR 0 2
115062: PUSH
115063: FOR_IN
115064: IFFALSE 115080
// SetLives ( i , 1 ) ;
115066: LD_VAR 0 1
115070: PPUSH
115071: LD_INT 1
115073: PPUSH
115074: CALL_OW 234
115078: GO 115063
115080: POP
115081: POP
// end ;
115082: PPOPN 2
115084: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
115085: LD_EXP 160
115089: PUSH
115090: LD_EXP 209
115094: AND
115095: IFFALSE 115369
115097: GO 115099
115099: DISABLE
115100: LD_INT 0
115102: PPUSH
115103: PPUSH
115104: PPUSH
// begin i := rand ( 1 , 7 ) ;
115105: LD_ADDR_VAR 0 1
115109: PUSH
115110: LD_INT 1
115112: PPUSH
115113: LD_INT 7
115115: PPUSH
115116: CALL_OW 12
115120: ST_TO_ADDR
// case i of 1 :
115121: LD_VAR 0 1
115125: PUSH
115126: LD_INT 1
115128: DOUBLE
115129: EQUAL
115130: IFTRUE 115134
115132: GO 115144
115134: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
115135: LD_STRING earthquake(getX(game), 0, 32)
115137: PPUSH
115138: CALL_OW 559
115142: GO 115369
115144: LD_INT 2
115146: DOUBLE
115147: EQUAL
115148: IFTRUE 115152
115150: GO 115166
115152: POP
// begin ToLua ( displayStucuk(); ) ;
115153: LD_STRING displayStucuk();
115155: PPUSH
115156: CALL_OW 559
// ResetFog ;
115160: CALL_OW 335
// end ; 3 :
115164: GO 115369
115166: LD_INT 3
115168: DOUBLE
115169: EQUAL
115170: IFTRUE 115174
115172: GO 115278
115174: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
115175: LD_ADDR_VAR 0 2
115179: PUSH
115180: LD_INT 22
115182: PUSH
115183: LD_OWVAR 2
115187: PUSH
115188: EMPTY
115189: LIST
115190: LIST
115191: PUSH
115192: LD_INT 25
115194: PUSH
115195: LD_INT 1
115197: PUSH
115198: EMPTY
115199: LIST
115200: LIST
115201: PUSH
115202: EMPTY
115203: LIST
115204: LIST
115205: PPUSH
115206: CALL_OW 69
115210: ST_TO_ADDR
// if not tmp then
115211: LD_VAR 0 2
115215: NOT
115216: IFFALSE 115220
// exit ;
115218: GO 115369
// un := tmp [ rand ( 1 , tmp ) ] ;
115220: LD_ADDR_VAR 0 3
115224: PUSH
115225: LD_VAR 0 2
115229: PUSH
115230: LD_INT 1
115232: PPUSH
115233: LD_VAR 0 2
115237: PPUSH
115238: CALL_OW 12
115242: ARRAY
115243: ST_TO_ADDR
// if Crawls ( un ) then
115244: LD_VAR 0 3
115248: PPUSH
115249: CALL_OW 318
115253: IFFALSE 115264
// ComWalk ( un ) ;
115255: LD_VAR 0 3
115259: PPUSH
115260: CALL_OW 138
// SetClass ( un , class_mortar ) ;
115264: LD_VAR 0 3
115268: PPUSH
115269: LD_INT 8
115271: PPUSH
115272: CALL_OW 336
// end ; 4 :
115276: GO 115369
115278: LD_INT 4
115280: DOUBLE
115281: EQUAL
115282: IFTRUE 115286
115284: GO 115347
115286: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
115287: LD_ADDR_VAR 0 2
115291: PUSH
115292: LD_INT 22
115294: PUSH
115295: LD_OWVAR 2
115299: PUSH
115300: EMPTY
115301: LIST
115302: LIST
115303: PUSH
115304: LD_INT 30
115306: PUSH
115307: LD_INT 29
115309: PUSH
115310: EMPTY
115311: LIST
115312: LIST
115313: PUSH
115314: EMPTY
115315: LIST
115316: LIST
115317: PPUSH
115318: CALL_OW 69
115322: ST_TO_ADDR
// if not tmp then
115323: LD_VAR 0 2
115327: NOT
115328: IFFALSE 115332
// exit ;
115330: GO 115369
// DestroyUnit ( tmp [ 1 ] ) ;
115332: LD_VAR 0 2
115336: PUSH
115337: LD_INT 1
115339: ARRAY
115340: PPUSH
115341: CALL_OW 65
// end ; 5 .. 7 :
115345: GO 115369
115347: LD_INT 5
115349: DOUBLE
115350: GREATEREQUAL
115351: IFFALSE 115359
115353: LD_INT 7
115355: DOUBLE
115356: LESSEQUAL
115357: IFTRUE 115361
115359: GO 115368
115361: POP
// StreamSibBomb ; end ;
115362: CALL 111619 0 0
115366: GO 115369
115368: POP
// end ;
115369: PPOPN 3
115371: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
115372: LD_EXP 160
115376: PUSH
115377: LD_EXP 210
115381: AND
115382: IFFALSE 115538
115384: GO 115386
115386: DISABLE
115387: LD_INT 0
115389: PPUSH
115390: PPUSH
115391: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
115392: LD_ADDR_VAR 0 2
115396: PUSH
115397: LD_INT 81
115399: PUSH
115400: LD_OWVAR 2
115404: PUSH
115405: EMPTY
115406: LIST
115407: LIST
115408: PUSH
115409: LD_INT 2
115411: PUSH
115412: LD_INT 21
115414: PUSH
115415: LD_INT 1
115417: PUSH
115418: EMPTY
115419: LIST
115420: LIST
115421: PUSH
115422: LD_INT 21
115424: PUSH
115425: LD_INT 2
115427: PUSH
115428: EMPTY
115429: LIST
115430: LIST
115431: PUSH
115432: EMPTY
115433: LIST
115434: LIST
115435: LIST
115436: PUSH
115437: EMPTY
115438: LIST
115439: LIST
115440: PPUSH
115441: CALL_OW 69
115445: ST_TO_ADDR
// if not tmp then
115446: LD_VAR 0 2
115450: NOT
115451: IFFALSE 115455
// exit ;
115453: GO 115538
// p := 0 ;
115455: LD_ADDR_VAR 0 3
115459: PUSH
115460: LD_INT 0
115462: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
115463: LD_INT 35
115465: PPUSH
115466: CALL_OW 67
// p := p + 1 ;
115470: LD_ADDR_VAR 0 3
115474: PUSH
115475: LD_VAR 0 3
115479: PUSH
115480: LD_INT 1
115482: PLUS
115483: ST_TO_ADDR
// for i in tmp do
115484: LD_ADDR_VAR 0 1
115488: PUSH
115489: LD_VAR 0 2
115493: PUSH
115494: FOR_IN
115495: IFFALSE 115526
// if GetLives ( i ) < 1000 then
115497: LD_VAR 0 1
115501: PPUSH
115502: CALL_OW 256
115506: PUSH
115507: LD_INT 1000
115509: LESS
115510: IFFALSE 115524
// SetLives ( i , 1000 ) ;
115512: LD_VAR 0 1
115516: PPUSH
115517: LD_INT 1000
115519: PPUSH
115520: CALL_OW 234
115524: GO 115494
115526: POP
115527: POP
// until p > 20 ;
115528: LD_VAR 0 3
115532: PUSH
115533: LD_INT 20
115535: GREATER
115536: IFFALSE 115463
// end ;
115538: PPOPN 3
115540: END
// every 0 0$1 trigger StreamModeActive and sTime do
115541: LD_EXP 160
115545: PUSH
115546: LD_EXP 211
115550: AND
115551: IFFALSE 115586
115553: GO 115555
115555: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
115556: LD_INT 28
115558: PPUSH
115559: LD_OWVAR 2
115563: PPUSH
115564: LD_INT 2
115566: PPUSH
115567: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
115571: LD_INT 30
115573: PPUSH
115574: LD_OWVAR 2
115578: PPUSH
115579: LD_INT 2
115581: PPUSH
115582: CALL_OW 322
// end ;
115586: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
115587: LD_EXP 160
115591: PUSH
115592: LD_EXP 212
115596: AND
115597: IFFALSE 115718
115599: GO 115601
115601: DISABLE
115602: LD_INT 0
115604: PPUSH
115605: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
115606: LD_ADDR_VAR 0 2
115610: PUSH
115611: LD_INT 22
115613: PUSH
115614: LD_OWVAR 2
115618: PUSH
115619: EMPTY
115620: LIST
115621: LIST
115622: PUSH
115623: LD_INT 21
115625: PUSH
115626: LD_INT 1
115628: PUSH
115629: EMPTY
115630: LIST
115631: LIST
115632: PUSH
115633: LD_INT 3
115635: PUSH
115636: LD_INT 23
115638: PUSH
115639: LD_INT 0
115641: PUSH
115642: EMPTY
115643: LIST
115644: LIST
115645: PUSH
115646: EMPTY
115647: LIST
115648: LIST
115649: PUSH
115650: EMPTY
115651: LIST
115652: LIST
115653: LIST
115654: PPUSH
115655: CALL_OW 69
115659: ST_TO_ADDR
// if not tmp then
115660: LD_VAR 0 2
115664: NOT
115665: IFFALSE 115669
// exit ;
115667: GO 115718
// for i in tmp do
115669: LD_ADDR_VAR 0 1
115673: PUSH
115674: LD_VAR 0 2
115678: PUSH
115679: FOR_IN
115680: IFFALSE 115716
// begin if Crawls ( i ) then
115682: LD_VAR 0 1
115686: PPUSH
115687: CALL_OW 318
115691: IFFALSE 115702
// ComWalk ( i ) ;
115693: LD_VAR 0 1
115697: PPUSH
115698: CALL_OW 138
// SetClass ( i , 2 ) ;
115702: LD_VAR 0 1
115706: PPUSH
115707: LD_INT 2
115709: PPUSH
115710: CALL_OW 336
// end ;
115714: GO 115679
115716: POP
115717: POP
// end ;
115718: PPOPN 2
115720: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
115721: LD_EXP 160
115725: PUSH
115726: LD_EXP 213
115730: AND
115731: IFFALSE 116012
115733: GO 115735
115735: DISABLE
115736: LD_INT 0
115738: PPUSH
115739: PPUSH
115740: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
115741: LD_OWVAR 2
115745: PPUSH
115746: LD_INT 9
115748: PPUSH
115749: LD_INT 1
115751: PPUSH
115752: LD_INT 1
115754: PPUSH
115755: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
115759: LD_INT 9
115761: PPUSH
115762: LD_OWVAR 2
115766: PPUSH
115767: CALL_OW 343
// uc_side := 9 ;
115771: LD_ADDR_OWVAR 20
115775: PUSH
115776: LD_INT 9
115778: ST_TO_ADDR
// uc_nation := 2 ;
115779: LD_ADDR_OWVAR 21
115783: PUSH
115784: LD_INT 2
115786: ST_TO_ADDR
// hc_name := Dark Warrior ;
115787: LD_ADDR_OWVAR 26
115791: PUSH
115792: LD_STRING Dark Warrior
115794: ST_TO_ADDR
// hc_gallery :=  ;
115795: LD_ADDR_OWVAR 33
115799: PUSH
115800: LD_STRING 
115802: ST_TO_ADDR
// hc_noskilllimit := true ;
115803: LD_ADDR_OWVAR 76
115807: PUSH
115808: LD_INT 1
115810: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
115811: LD_ADDR_OWVAR 31
115815: PUSH
115816: LD_INT 30
115818: PUSH
115819: LD_INT 30
115821: PUSH
115822: LD_INT 30
115824: PUSH
115825: LD_INT 30
115827: PUSH
115828: EMPTY
115829: LIST
115830: LIST
115831: LIST
115832: LIST
115833: ST_TO_ADDR
// un := CreateHuman ;
115834: LD_ADDR_VAR 0 3
115838: PUSH
115839: CALL_OW 44
115843: ST_TO_ADDR
// hc_noskilllimit := false ;
115844: LD_ADDR_OWVAR 76
115848: PUSH
115849: LD_INT 0
115851: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
115852: LD_VAR 0 3
115856: PPUSH
115857: LD_INT 1
115859: PPUSH
115860: CALL_OW 51
// p := 0 ;
115864: LD_ADDR_VAR 0 2
115868: PUSH
115869: LD_INT 0
115871: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
115872: LD_INT 35
115874: PPUSH
115875: CALL_OW 67
// p := p + 1 ;
115879: LD_ADDR_VAR 0 2
115883: PUSH
115884: LD_VAR 0 2
115888: PUSH
115889: LD_INT 1
115891: PLUS
115892: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
115893: LD_VAR 0 3
115897: PPUSH
115898: CALL_OW 256
115902: PUSH
115903: LD_INT 1000
115905: LESS
115906: IFFALSE 115920
// SetLives ( un , 1000 ) ;
115908: LD_VAR 0 3
115912: PPUSH
115913: LD_INT 1000
115915: PPUSH
115916: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
115920: LD_VAR 0 3
115924: PPUSH
115925: LD_INT 81
115927: PUSH
115928: LD_OWVAR 2
115932: PUSH
115933: EMPTY
115934: LIST
115935: LIST
115936: PUSH
115937: LD_INT 91
115939: PUSH
115940: LD_VAR 0 3
115944: PUSH
115945: LD_INT 30
115947: PUSH
115948: EMPTY
115949: LIST
115950: LIST
115951: LIST
115952: PUSH
115953: EMPTY
115954: LIST
115955: LIST
115956: PPUSH
115957: CALL_OW 69
115961: PPUSH
115962: LD_VAR 0 3
115966: PPUSH
115967: CALL_OW 74
115971: PPUSH
115972: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
115976: LD_VAR 0 2
115980: PUSH
115981: LD_INT 60
115983: GREATER
115984: PUSH
115985: LD_VAR 0 3
115989: PPUSH
115990: CALL_OW 301
115994: OR
115995: IFFALSE 115872
// if un then
115997: LD_VAR 0 3
116001: IFFALSE 116012
// RemoveUnit ( un ) ;
116003: LD_VAR 0 3
116007: PPUSH
116008: CALL_OW 64
// end ;
116012: PPOPN 3
116014: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
116015: LD_INT 0
116017: PPUSH
// case cmd of 301 :
116018: LD_VAR 0 1
116022: PUSH
116023: LD_INT 301
116025: DOUBLE
116026: EQUAL
116027: IFTRUE 116031
116029: GO 116063
116031: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
116032: LD_VAR 0 6
116036: PPUSH
116037: LD_VAR 0 7
116041: PPUSH
116042: LD_VAR 0 8
116046: PPUSH
116047: LD_VAR 0 4
116051: PPUSH
116052: LD_VAR 0 5
116056: PPUSH
116057: CALL 117264 0 5
116061: GO 116184
116063: LD_INT 302
116065: DOUBLE
116066: EQUAL
116067: IFTRUE 116071
116069: GO 116108
116071: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
116072: LD_VAR 0 6
116076: PPUSH
116077: LD_VAR 0 7
116081: PPUSH
116082: LD_VAR 0 8
116086: PPUSH
116087: LD_VAR 0 9
116091: PPUSH
116092: LD_VAR 0 4
116096: PPUSH
116097: LD_VAR 0 5
116101: PPUSH
116102: CALL 117355 0 6
116106: GO 116184
116108: LD_INT 303
116110: DOUBLE
116111: EQUAL
116112: IFTRUE 116116
116114: GO 116153
116116: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
116117: LD_VAR 0 6
116121: PPUSH
116122: LD_VAR 0 7
116126: PPUSH
116127: LD_VAR 0 8
116131: PPUSH
116132: LD_VAR 0 9
116136: PPUSH
116137: LD_VAR 0 4
116141: PPUSH
116142: LD_VAR 0 5
116146: PPUSH
116147: CALL 116189 0 6
116151: GO 116184
116153: LD_INT 304
116155: DOUBLE
116156: EQUAL
116157: IFTRUE 116161
116159: GO 116183
116161: POP
// hHackTeleport ( unit , x , y ) ; end ;
116162: LD_VAR 0 2
116166: PPUSH
116167: LD_VAR 0 4
116171: PPUSH
116172: LD_VAR 0 5
116176: PPUSH
116177: CALL 117948 0 3
116181: GO 116184
116183: POP
// end ;
116184: LD_VAR 0 12
116188: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
116189: LD_INT 0
116191: PPUSH
116192: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
116193: LD_VAR 0 1
116197: PUSH
116198: LD_INT 1
116200: LESS
116201: PUSH
116202: LD_VAR 0 1
116206: PUSH
116207: LD_INT 3
116209: GREATER
116210: OR
116211: PUSH
116212: LD_VAR 0 5
116216: PPUSH
116217: LD_VAR 0 6
116221: PPUSH
116222: CALL_OW 428
116226: OR
116227: IFFALSE 116231
// exit ;
116229: GO 116951
// uc_side := your_side ;
116231: LD_ADDR_OWVAR 20
116235: PUSH
116236: LD_OWVAR 2
116240: ST_TO_ADDR
// uc_nation := nation ;
116241: LD_ADDR_OWVAR 21
116245: PUSH
116246: LD_VAR 0 1
116250: ST_TO_ADDR
// bc_level = 1 ;
116251: LD_ADDR_OWVAR 43
116255: PUSH
116256: LD_INT 1
116258: ST_TO_ADDR
// case btype of 1 :
116259: LD_VAR 0 2
116263: PUSH
116264: LD_INT 1
116266: DOUBLE
116267: EQUAL
116268: IFTRUE 116272
116270: GO 116283
116272: POP
// bc_type := b_depot ; 2 :
116273: LD_ADDR_OWVAR 42
116277: PUSH
116278: LD_INT 0
116280: ST_TO_ADDR
116281: GO 116895
116283: LD_INT 2
116285: DOUBLE
116286: EQUAL
116287: IFTRUE 116291
116289: GO 116302
116291: POP
// bc_type := b_warehouse ; 3 :
116292: LD_ADDR_OWVAR 42
116296: PUSH
116297: LD_INT 1
116299: ST_TO_ADDR
116300: GO 116895
116302: LD_INT 3
116304: DOUBLE
116305: EQUAL
116306: IFTRUE 116310
116308: GO 116321
116310: POP
// bc_type := b_lab ; 4 .. 9 :
116311: LD_ADDR_OWVAR 42
116315: PUSH
116316: LD_INT 6
116318: ST_TO_ADDR
116319: GO 116895
116321: LD_INT 4
116323: DOUBLE
116324: GREATEREQUAL
116325: IFFALSE 116333
116327: LD_INT 9
116329: DOUBLE
116330: LESSEQUAL
116331: IFTRUE 116335
116333: GO 116387
116335: POP
// begin bc_type := b_lab_half ;
116336: LD_ADDR_OWVAR 42
116340: PUSH
116341: LD_INT 7
116343: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
116344: LD_ADDR_OWVAR 44
116348: PUSH
116349: LD_INT 10
116351: PUSH
116352: LD_INT 11
116354: PUSH
116355: LD_INT 12
116357: PUSH
116358: LD_INT 15
116360: PUSH
116361: LD_INT 14
116363: PUSH
116364: LD_INT 13
116366: PUSH
116367: EMPTY
116368: LIST
116369: LIST
116370: LIST
116371: LIST
116372: LIST
116373: LIST
116374: PUSH
116375: LD_VAR 0 2
116379: PUSH
116380: LD_INT 3
116382: MINUS
116383: ARRAY
116384: ST_TO_ADDR
// end ; 10 .. 13 :
116385: GO 116895
116387: LD_INT 10
116389: DOUBLE
116390: GREATEREQUAL
116391: IFFALSE 116399
116393: LD_INT 13
116395: DOUBLE
116396: LESSEQUAL
116397: IFTRUE 116401
116399: GO 116478
116401: POP
// begin bc_type := b_lab_full ;
116402: LD_ADDR_OWVAR 42
116406: PUSH
116407: LD_INT 8
116409: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
116410: LD_ADDR_OWVAR 44
116414: PUSH
116415: LD_INT 10
116417: PUSH
116418: LD_INT 12
116420: PUSH
116421: LD_INT 14
116423: PUSH
116424: LD_INT 13
116426: PUSH
116427: EMPTY
116428: LIST
116429: LIST
116430: LIST
116431: LIST
116432: PUSH
116433: LD_VAR 0 2
116437: PUSH
116438: LD_INT 9
116440: MINUS
116441: ARRAY
116442: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
116443: LD_ADDR_OWVAR 45
116447: PUSH
116448: LD_INT 11
116450: PUSH
116451: LD_INT 15
116453: PUSH
116454: LD_INT 12
116456: PUSH
116457: LD_INT 15
116459: PUSH
116460: EMPTY
116461: LIST
116462: LIST
116463: LIST
116464: LIST
116465: PUSH
116466: LD_VAR 0 2
116470: PUSH
116471: LD_INT 9
116473: MINUS
116474: ARRAY
116475: ST_TO_ADDR
// end ; 14 :
116476: GO 116895
116478: LD_INT 14
116480: DOUBLE
116481: EQUAL
116482: IFTRUE 116486
116484: GO 116497
116486: POP
// bc_type := b_workshop ; 15 :
116487: LD_ADDR_OWVAR 42
116491: PUSH
116492: LD_INT 2
116494: ST_TO_ADDR
116495: GO 116895
116497: LD_INT 15
116499: DOUBLE
116500: EQUAL
116501: IFTRUE 116505
116503: GO 116516
116505: POP
// bc_type := b_factory ; 16 :
116506: LD_ADDR_OWVAR 42
116510: PUSH
116511: LD_INT 3
116513: ST_TO_ADDR
116514: GO 116895
116516: LD_INT 16
116518: DOUBLE
116519: EQUAL
116520: IFTRUE 116524
116522: GO 116535
116524: POP
// bc_type := b_ext_gun ; 17 :
116525: LD_ADDR_OWVAR 42
116529: PUSH
116530: LD_INT 17
116532: ST_TO_ADDR
116533: GO 116895
116535: LD_INT 17
116537: DOUBLE
116538: EQUAL
116539: IFTRUE 116543
116541: GO 116571
116543: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
116544: LD_ADDR_OWVAR 42
116548: PUSH
116549: LD_INT 19
116551: PUSH
116552: LD_INT 23
116554: PUSH
116555: LD_INT 19
116557: PUSH
116558: EMPTY
116559: LIST
116560: LIST
116561: LIST
116562: PUSH
116563: LD_VAR 0 1
116567: ARRAY
116568: ST_TO_ADDR
116569: GO 116895
116571: LD_INT 18
116573: DOUBLE
116574: EQUAL
116575: IFTRUE 116579
116577: GO 116590
116579: POP
// bc_type := b_ext_radar ; 19 :
116580: LD_ADDR_OWVAR 42
116584: PUSH
116585: LD_INT 20
116587: ST_TO_ADDR
116588: GO 116895
116590: LD_INT 19
116592: DOUBLE
116593: EQUAL
116594: IFTRUE 116598
116596: GO 116609
116598: POP
// bc_type := b_ext_radio ; 20 :
116599: LD_ADDR_OWVAR 42
116603: PUSH
116604: LD_INT 22
116606: ST_TO_ADDR
116607: GO 116895
116609: LD_INT 20
116611: DOUBLE
116612: EQUAL
116613: IFTRUE 116617
116615: GO 116628
116617: POP
// bc_type := b_ext_siberium ; 21 :
116618: LD_ADDR_OWVAR 42
116622: PUSH
116623: LD_INT 21
116625: ST_TO_ADDR
116626: GO 116895
116628: LD_INT 21
116630: DOUBLE
116631: EQUAL
116632: IFTRUE 116636
116634: GO 116647
116636: POP
// bc_type := b_ext_computer ; 22 :
116637: LD_ADDR_OWVAR 42
116641: PUSH
116642: LD_INT 24
116644: ST_TO_ADDR
116645: GO 116895
116647: LD_INT 22
116649: DOUBLE
116650: EQUAL
116651: IFTRUE 116655
116653: GO 116666
116655: POP
// bc_type := b_ext_track ; 23 :
116656: LD_ADDR_OWVAR 42
116660: PUSH
116661: LD_INT 16
116663: ST_TO_ADDR
116664: GO 116895
116666: LD_INT 23
116668: DOUBLE
116669: EQUAL
116670: IFTRUE 116674
116672: GO 116685
116674: POP
// bc_type := b_ext_laser ; 24 :
116675: LD_ADDR_OWVAR 42
116679: PUSH
116680: LD_INT 25
116682: ST_TO_ADDR
116683: GO 116895
116685: LD_INT 24
116687: DOUBLE
116688: EQUAL
116689: IFTRUE 116693
116691: GO 116704
116693: POP
// bc_type := b_control_tower ; 25 :
116694: LD_ADDR_OWVAR 42
116698: PUSH
116699: LD_INT 36
116701: ST_TO_ADDR
116702: GO 116895
116704: LD_INT 25
116706: DOUBLE
116707: EQUAL
116708: IFTRUE 116712
116710: GO 116723
116712: POP
// bc_type := b_breastwork ; 26 :
116713: LD_ADDR_OWVAR 42
116717: PUSH
116718: LD_INT 31
116720: ST_TO_ADDR
116721: GO 116895
116723: LD_INT 26
116725: DOUBLE
116726: EQUAL
116727: IFTRUE 116731
116729: GO 116742
116731: POP
// bc_type := b_bunker ; 27 :
116732: LD_ADDR_OWVAR 42
116736: PUSH
116737: LD_INT 32
116739: ST_TO_ADDR
116740: GO 116895
116742: LD_INT 27
116744: DOUBLE
116745: EQUAL
116746: IFTRUE 116750
116748: GO 116761
116750: POP
// bc_type := b_turret ; 28 :
116751: LD_ADDR_OWVAR 42
116755: PUSH
116756: LD_INT 33
116758: ST_TO_ADDR
116759: GO 116895
116761: LD_INT 28
116763: DOUBLE
116764: EQUAL
116765: IFTRUE 116769
116767: GO 116780
116769: POP
// bc_type := b_armoury ; 29 :
116770: LD_ADDR_OWVAR 42
116774: PUSH
116775: LD_INT 4
116777: ST_TO_ADDR
116778: GO 116895
116780: LD_INT 29
116782: DOUBLE
116783: EQUAL
116784: IFTRUE 116788
116786: GO 116799
116788: POP
// bc_type := b_barracks ; 30 :
116789: LD_ADDR_OWVAR 42
116793: PUSH
116794: LD_INT 5
116796: ST_TO_ADDR
116797: GO 116895
116799: LD_INT 30
116801: DOUBLE
116802: EQUAL
116803: IFTRUE 116807
116805: GO 116818
116807: POP
// bc_type := b_solar_power ; 31 :
116808: LD_ADDR_OWVAR 42
116812: PUSH
116813: LD_INT 27
116815: ST_TO_ADDR
116816: GO 116895
116818: LD_INT 31
116820: DOUBLE
116821: EQUAL
116822: IFTRUE 116826
116824: GO 116837
116826: POP
// bc_type := b_oil_power ; 32 :
116827: LD_ADDR_OWVAR 42
116831: PUSH
116832: LD_INT 26
116834: ST_TO_ADDR
116835: GO 116895
116837: LD_INT 32
116839: DOUBLE
116840: EQUAL
116841: IFTRUE 116845
116843: GO 116856
116845: POP
// bc_type := b_siberite_power ; 33 :
116846: LD_ADDR_OWVAR 42
116850: PUSH
116851: LD_INT 28
116853: ST_TO_ADDR
116854: GO 116895
116856: LD_INT 33
116858: DOUBLE
116859: EQUAL
116860: IFTRUE 116864
116862: GO 116875
116864: POP
// bc_type := b_oil_mine ; 34 :
116865: LD_ADDR_OWVAR 42
116869: PUSH
116870: LD_INT 29
116872: ST_TO_ADDR
116873: GO 116895
116875: LD_INT 34
116877: DOUBLE
116878: EQUAL
116879: IFTRUE 116883
116881: GO 116894
116883: POP
// bc_type := b_siberite_mine ; end ;
116884: LD_ADDR_OWVAR 42
116888: PUSH
116889: LD_INT 30
116891: ST_TO_ADDR
116892: GO 116895
116894: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
116895: LD_ADDR_VAR 0 8
116899: PUSH
116900: LD_VAR 0 5
116904: PPUSH
116905: LD_VAR 0 6
116909: PPUSH
116910: LD_VAR 0 3
116914: PPUSH
116915: CALL_OW 47
116919: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
116920: LD_OWVAR 42
116924: PUSH
116925: LD_INT 32
116927: PUSH
116928: LD_INT 33
116930: PUSH
116931: EMPTY
116932: LIST
116933: LIST
116934: IN
116935: IFFALSE 116951
// PlaceWeaponTurret ( b , weapon ) ;
116937: LD_VAR 0 8
116941: PPUSH
116942: LD_VAR 0 4
116946: PPUSH
116947: CALL_OW 431
// end ;
116951: LD_VAR 0 7
116955: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
116956: LD_INT 0
116958: PPUSH
116959: PPUSH
116960: PPUSH
116961: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
116962: LD_ADDR_VAR 0 4
116966: PUSH
116967: LD_INT 22
116969: PUSH
116970: LD_OWVAR 2
116974: PUSH
116975: EMPTY
116976: LIST
116977: LIST
116978: PUSH
116979: LD_INT 2
116981: PUSH
116982: LD_INT 30
116984: PUSH
116985: LD_INT 0
116987: PUSH
116988: EMPTY
116989: LIST
116990: LIST
116991: PUSH
116992: LD_INT 30
116994: PUSH
116995: LD_INT 1
116997: PUSH
116998: EMPTY
116999: LIST
117000: LIST
117001: PUSH
117002: EMPTY
117003: LIST
117004: LIST
117005: LIST
117006: PUSH
117007: EMPTY
117008: LIST
117009: LIST
117010: PPUSH
117011: CALL_OW 69
117015: ST_TO_ADDR
// if not tmp then
117016: LD_VAR 0 4
117020: NOT
117021: IFFALSE 117025
// exit ;
117023: GO 117084
// for i in tmp do
117025: LD_ADDR_VAR 0 2
117029: PUSH
117030: LD_VAR 0 4
117034: PUSH
117035: FOR_IN
117036: IFFALSE 117082
// for j = 1 to 3 do
117038: LD_ADDR_VAR 0 3
117042: PUSH
117043: DOUBLE
117044: LD_INT 1
117046: DEC
117047: ST_TO_ADDR
117048: LD_INT 3
117050: PUSH
117051: FOR_TO
117052: IFFALSE 117078
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
117054: LD_VAR 0 2
117058: PPUSH
117059: CALL_OW 274
117063: PPUSH
117064: LD_VAR 0 3
117068: PPUSH
117069: LD_INT 99999
117071: PPUSH
117072: CALL_OW 277
117076: GO 117051
117078: POP
117079: POP
117080: GO 117035
117082: POP
117083: POP
// end ;
117084: LD_VAR 0 1
117088: RET
// export function hHackSetLevel10 ; var i , j ; begin
117089: LD_INT 0
117091: PPUSH
117092: PPUSH
117093: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
117094: LD_ADDR_VAR 0 2
117098: PUSH
117099: LD_INT 21
117101: PUSH
117102: LD_INT 1
117104: PUSH
117105: EMPTY
117106: LIST
117107: LIST
117108: PPUSH
117109: CALL_OW 69
117113: PUSH
117114: FOR_IN
117115: IFFALSE 117167
// if IsSelected ( i ) then
117117: LD_VAR 0 2
117121: PPUSH
117122: CALL_OW 306
117126: IFFALSE 117165
// begin for j := 1 to 4 do
117128: LD_ADDR_VAR 0 3
117132: PUSH
117133: DOUBLE
117134: LD_INT 1
117136: DEC
117137: ST_TO_ADDR
117138: LD_INT 4
117140: PUSH
117141: FOR_TO
117142: IFFALSE 117163
// SetSkill ( i , j , 10 ) ;
117144: LD_VAR 0 2
117148: PPUSH
117149: LD_VAR 0 3
117153: PPUSH
117154: LD_INT 10
117156: PPUSH
117157: CALL_OW 237
117161: GO 117141
117163: POP
117164: POP
// end ;
117165: GO 117114
117167: POP
117168: POP
// end ;
117169: LD_VAR 0 1
117173: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
117174: LD_INT 0
117176: PPUSH
117177: PPUSH
117178: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
117179: LD_ADDR_VAR 0 2
117183: PUSH
117184: LD_INT 22
117186: PUSH
117187: LD_OWVAR 2
117191: PUSH
117192: EMPTY
117193: LIST
117194: LIST
117195: PUSH
117196: LD_INT 21
117198: PUSH
117199: LD_INT 1
117201: PUSH
117202: EMPTY
117203: LIST
117204: LIST
117205: PUSH
117206: EMPTY
117207: LIST
117208: LIST
117209: PPUSH
117210: CALL_OW 69
117214: PUSH
117215: FOR_IN
117216: IFFALSE 117257
// begin for j := 1 to 4 do
117218: LD_ADDR_VAR 0 3
117222: PUSH
117223: DOUBLE
117224: LD_INT 1
117226: DEC
117227: ST_TO_ADDR
117228: LD_INT 4
117230: PUSH
117231: FOR_TO
117232: IFFALSE 117253
// SetSkill ( i , j , 10 ) ;
117234: LD_VAR 0 2
117238: PPUSH
117239: LD_VAR 0 3
117243: PPUSH
117244: LD_INT 10
117246: PPUSH
117247: CALL_OW 237
117251: GO 117231
117253: POP
117254: POP
// end ;
117255: GO 117215
117257: POP
117258: POP
// end ;
117259: LD_VAR 0 1
117263: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
117264: LD_INT 0
117266: PPUSH
// uc_side := your_side ;
117267: LD_ADDR_OWVAR 20
117271: PUSH
117272: LD_OWVAR 2
117276: ST_TO_ADDR
// uc_nation := nation ;
117277: LD_ADDR_OWVAR 21
117281: PUSH
117282: LD_VAR 0 1
117286: ST_TO_ADDR
// InitHc ;
117287: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
117291: LD_INT 0
117293: PPUSH
117294: LD_VAR 0 2
117298: PPUSH
117299: LD_VAR 0 3
117303: PPUSH
117304: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
117308: LD_VAR 0 4
117312: PPUSH
117313: LD_VAR 0 5
117317: PPUSH
117318: CALL_OW 428
117322: PUSH
117323: LD_INT 0
117325: EQUAL
117326: IFFALSE 117350
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
117328: CALL_OW 44
117332: PPUSH
117333: LD_VAR 0 4
117337: PPUSH
117338: LD_VAR 0 5
117342: PPUSH
117343: LD_INT 1
117345: PPUSH
117346: CALL_OW 48
// end ;
117350: LD_VAR 0 6
117354: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
117355: LD_INT 0
117357: PPUSH
117358: PPUSH
// uc_side := your_side ;
117359: LD_ADDR_OWVAR 20
117363: PUSH
117364: LD_OWVAR 2
117368: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
117369: LD_VAR 0 1
117373: PUSH
117374: LD_INT 1
117376: PUSH
117377: LD_INT 2
117379: PUSH
117380: LD_INT 3
117382: PUSH
117383: LD_INT 4
117385: PUSH
117386: LD_INT 5
117388: PUSH
117389: EMPTY
117390: LIST
117391: LIST
117392: LIST
117393: LIST
117394: LIST
117395: IN
117396: IFFALSE 117408
// uc_nation := nation_american else
117398: LD_ADDR_OWVAR 21
117402: PUSH
117403: LD_INT 1
117405: ST_TO_ADDR
117406: GO 117451
// if chassis in [ 11 , 12 , 13 , 14 ] then
117408: LD_VAR 0 1
117412: PUSH
117413: LD_INT 11
117415: PUSH
117416: LD_INT 12
117418: PUSH
117419: LD_INT 13
117421: PUSH
117422: LD_INT 14
117424: PUSH
117425: EMPTY
117426: LIST
117427: LIST
117428: LIST
117429: LIST
117430: IN
117431: IFFALSE 117443
// uc_nation := nation_arabian else
117433: LD_ADDR_OWVAR 21
117437: PUSH
117438: LD_INT 2
117440: ST_TO_ADDR
117441: GO 117451
// uc_nation := nation_russian ;
117443: LD_ADDR_OWVAR 21
117447: PUSH
117448: LD_INT 3
117450: ST_TO_ADDR
// vc_chassis := chassis ;
117451: LD_ADDR_OWVAR 37
117455: PUSH
117456: LD_VAR 0 1
117460: ST_TO_ADDR
// vc_engine := engine ;
117461: LD_ADDR_OWVAR 39
117465: PUSH
117466: LD_VAR 0 2
117470: ST_TO_ADDR
// vc_control := control ;
117471: LD_ADDR_OWVAR 38
117475: PUSH
117476: LD_VAR 0 3
117480: ST_TO_ADDR
// vc_weapon := weapon ;
117481: LD_ADDR_OWVAR 40
117485: PUSH
117486: LD_VAR 0 4
117490: ST_TO_ADDR
// un := CreateVehicle ;
117491: LD_ADDR_VAR 0 8
117495: PUSH
117496: CALL_OW 45
117500: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
117501: LD_VAR 0 8
117505: PPUSH
117506: LD_INT 0
117508: PPUSH
117509: LD_INT 5
117511: PPUSH
117512: CALL_OW 12
117516: PPUSH
117517: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
117521: LD_VAR 0 8
117525: PPUSH
117526: LD_VAR 0 5
117530: PPUSH
117531: LD_VAR 0 6
117535: PPUSH
117536: LD_INT 1
117538: PPUSH
117539: CALL_OW 48
// end ;
117543: LD_VAR 0 7
117547: RET
// export hInvincible ; every 1 do
117548: GO 117550
117550: DISABLE
// hInvincible := [ ] ;
117551: LD_ADDR_EXP 214
117555: PUSH
117556: EMPTY
117557: ST_TO_ADDR
117558: END
// every 10 do var i ;
117559: GO 117561
117561: DISABLE
117562: LD_INT 0
117564: PPUSH
// begin enable ;
117565: ENABLE
// if not hInvincible then
117566: LD_EXP 214
117570: NOT
117571: IFFALSE 117575
// exit ;
117573: GO 117619
// for i in hInvincible do
117575: LD_ADDR_VAR 0 1
117579: PUSH
117580: LD_EXP 214
117584: PUSH
117585: FOR_IN
117586: IFFALSE 117617
// if GetLives ( i ) < 1000 then
117588: LD_VAR 0 1
117592: PPUSH
117593: CALL_OW 256
117597: PUSH
117598: LD_INT 1000
117600: LESS
117601: IFFALSE 117615
// SetLives ( i , 1000 ) ;
117603: LD_VAR 0 1
117607: PPUSH
117608: LD_INT 1000
117610: PPUSH
117611: CALL_OW 234
117615: GO 117585
117617: POP
117618: POP
// end ;
117619: PPOPN 1
117621: END
// export function hHackInvincible ; var i ; begin
117622: LD_INT 0
117624: PPUSH
117625: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
117626: LD_ADDR_VAR 0 2
117630: PUSH
117631: LD_INT 2
117633: PUSH
117634: LD_INT 21
117636: PUSH
117637: LD_INT 1
117639: PUSH
117640: EMPTY
117641: LIST
117642: LIST
117643: PUSH
117644: LD_INT 21
117646: PUSH
117647: LD_INT 2
117649: PUSH
117650: EMPTY
117651: LIST
117652: LIST
117653: PUSH
117654: EMPTY
117655: LIST
117656: LIST
117657: LIST
117658: PPUSH
117659: CALL_OW 69
117663: PUSH
117664: FOR_IN
117665: IFFALSE 117726
// if IsSelected ( i ) then
117667: LD_VAR 0 2
117671: PPUSH
117672: CALL_OW 306
117676: IFFALSE 117724
// begin if i in hInvincible then
117678: LD_VAR 0 2
117682: PUSH
117683: LD_EXP 214
117687: IN
117688: IFFALSE 117708
// hInvincible := hInvincible diff i else
117690: LD_ADDR_EXP 214
117694: PUSH
117695: LD_EXP 214
117699: PUSH
117700: LD_VAR 0 2
117704: DIFF
117705: ST_TO_ADDR
117706: GO 117724
// hInvincible := hInvincible union i ;
117708: LD_ADDR_EXP 214
117712: PUSH
117713: LD_EXP 214
117717: PUSH
117718: LD_VAR 0 2
117722: UNION
117723: ST_TO_ADDR
// end ;
117724: GO 117664
117726: POP
117727: POP
// end ;
117728: LD_VAR 0 1
117732: RET
// export function hHackInvisible ; var i , j ; begin
117733: LD_INT 0
117735: PPUSH
117736: PPUSH
117737: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
117738: LD_ADDR_VAR 0 2
117742: PUSH
117743: LD_INT 21
117745: PUSH
117746: LD_INT 1
117748: PUSH
117749: EMPTY
117750: LIST
117751: LIST
117752: PPUSH
117753: CALL_OW 69
117757: PUSH
117758: FOR_IN
117759: IFFALSE 117783
// if IsSelected ( i ) then
117761: LD_VAR 0 2
117765: PPUSH
117766: CALL_OW 306
117770: IFFALSE 117781
// ComForceInvisible ( i ) ;
117772: LD_VAR 0 2
117776: PPUSH
117777: CALL_OW 496
117781: GO 117758
117783: POP
117784: POP
// end ;
117785: LD_VAR 0 1
117789: RET
// export function hHackChangeYourSide ; begin
117790: LD_INT 0
117792: PPUSH
// if your_side = 8 then
117793: LD_OWVAR 2
117797: PUSH
117798: LD_INT 8
117800: EQUAL
117801: IFFALSE 117813
// your_side := 0 else
117803: LD_ADDR_OWVAR 2
117807: PUSH
117808: LD_INT 0
117810: ST_TO_ADDR
117811: GO 117827
// your_side := your_side + 1 ;
117813: LD_ADDR_OWVAR 2
117817: PUSH
117818: LD_OWVAR 2
117822: PUSH
117823: LD_INT 1
117825: PLUS
117826: ST_TO_ADDR
// end ;
117827: LD_VAR 0 1
117831: RET
// export function hHackChangeUnitSide ; var i , j ; begin
117832: LD_INT 0
117834: PPUSH
117835: PPUSH
117836: PPUSH
// for i in all_units do
117837: LD_ADDR_VAR 0 2
117841: PUSH
117842: LD_OWVAR 3
117846: PUSH
117847: FOR_IN
117848: IFFALSE 117926
// if IsSelected ( i ) then
117850: LD_VAR 0 2
117854: PPUSH
117855: CALL_OW 306
117859: IFFALSE 117924
// begin j := GetSide ( i ) ;
117861: LD_ADDR_VAR 0 3
117865: PUSH
117866: LD_VAR 0 2
117870: PPUSH
117871: CALL_OW 255
117875: ST_TO_ADDR
// if j = 8 then
117876: LD_VAR 0 3
117880: PUSH
117881: LD_INT 8
117883: EQUAL
117884: IFFALSE 117896
// j := 0 else
117886: LD_ADDR_VAR 0 3
117890: PUSH
117891: LD_INT 0
117893: ST_TO_ADDR
117894: GO 117910
// j := j + 1 ;
117896: LD_ADDR_VAR 0 3
117900: PUSH
117901: LD_VAR 0 3
117905: PUSH
117906: LD_INT 1
117908: PLUS
117909: ST_TO_ADDR
// SetSide ( i , j ) ;
117910: LD_VAR 0 2
117914: PPUSH
117915: LD_VAR 0 3
117919: PPUSH
117920: CALL_OW 235
// end ;
117924: GO 117847
117926: POP
117927: POP
// end ;
117928: LD_VAR 0 1
117932: RET
// export function hHackFog ; begin
117933: LD_INT 0
117935: PPUSH
// FogOff ( true ) ;
117936: LD_INT 1
117938: PPUSH
117939: CALL_OW 344
// end ;
117943: LD_VAR 0 1
117947: RET
// export function hHackTeleport ( unit , x , y ) ; begin
117948: LD_INT 0
117950: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
117951: LD_VAR 0 1
117955: PPUSH
117956: LD_VAR 0 2
117960: PPUSH
117961: LD_VAR 0 3
117965: PPUSH
117966: LD_INT 1
117968: PPUSH
117969: LD_INT 1
117971: PPUSH
117972: CALL_OW 483
// CenterOnXY ( x , y ) ;
117976: LD_VAR 0 2
117980: PPUSH
117981: LD_VAR 0 3
117985: PPUSH
117986: CALL_OW 84
// end ; end_of_file
117990: LD_VAR 0 4
117994: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
117995: LD_INT 0
117997: PPUSH
117998: PPUSH
117999: PPUSH
118000: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
118001: LD_VAR 0 1
118005: PPUSH
118006: CALL_OW 264
118010: PUSH
118011: LD_EXP 99
118015: EQUAL
118016: IFFALSE 118088
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
118018: LD_INT 68
118020: PPUSH
118021: LD_VAR 0 1
118025: PPUSH
118026: CALL_OW 255
118030: PPUSH
118031: CALL_OW 321
118035: PUSH
118036: LD_INT 2
118038: EQUAL
118039: IFFALSE 118051
// eff := 70 else
118041: LD_ADDR_VAR 0 4
118045: PUSH
118046: LD_INT 70
118048: ST_TO_ADDR
118049: GO 118059
// eff := 30 ;
118051: LD_ADDR_VAR 0 4
118055: PUSH
118056: LD_INT 30
118058: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
118059: LD_VAR 0 1
118063: PPUSH
118064: CALL_OW 250
118068: PPUSH
118069: LD_VAR 0 1
118073: PPUSH
118074: CALL_OW 251
118078: PPUSH
118079: LD_VAR 0 4
118083: PPUSH
118084: CALL_OW 495
// end ; end ;
118088: LD_VAR 0 2
118092: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
118093: LD_INT 0
118095: PPUSH
// end ;
118096: LD_VAR 0 4
118100: RET
// export function SOS_Command ( cmd ) ; begin
118101: LD_INT 0
118103: PPUSH
// end ;
118104: LD_VAR 0 2
118108: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
118109: LD_INT 0
118111: PPUSH
// if cmd = 121 then
118112: LD_VAR 0 1
118116: PUSH
118117: LD_INT 121
118119: EQUAL
118120: IFFALSE 118122
// end ;
118122: LD_VAR 0 6
118126: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
118127: LD_INT 0
118129: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
118130: LD_VAR 0 1
118134: PUSH
118135: LD_INT 250
118137: EQUAL
118138: PUSH
118139: LD_VAR 0 2
118143: PPUSH
118144: CALL_OW 264
118148: PUSH
118149: LD_EXP 102
118153: EQUAL
118154: AND
118155: IFFALSE 118176
// MinerPlaceMine ( unit , x , y ) ;
118157: LD_VAR 0 2
118161: PPUSH
118162: LD_VAR 0 4
118166: PPUSH
118167: LD_VAR 0 5
118171: PPUSH
118172: CALL 120525 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
118176: LD_VAR 0 1
118180: PUSH
118181: LD_INT 251
118183: EQUAL
118184: PUSH
118185: LD_VAR 0 2
118189: PPUSH
118190: CALL_OW 264
118194: PUSH
118195: LD_EXP 102
118199: EQUAL
118200: AND
118201: IFFALSE 118222
// MinerDetonateMine ( unit , x , y ) ;
118203: LD_VAR 0 2
118207: PPUSH
118208: LD_VAR 0 4
118212: PPUSH
118213: LD_VAR 0 5
118217: PPUSH
118218: CALL 120802 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
118222: LD_VAR 0 1
118226: PUSH
118227: LD_INT 252
118229: EQUAL
118230: PUSH
118231: LD_VAR 0 2
118235: PPUSH
118236: CALL_OW 264
118240: PUSH
118241: LD_EXP 102
118245: EQUAL
118246: AND
118247: IFFALSE 118268
// MinerCreateMinefield ( unit , x , y ) ;
118249: LD_VAR 0 2
118253: PPUSH
118254: LD_VAR 0 4
118258: PPUSH
118259: LD_VAR 0 5
118263: PPUSH
118264: CALL 121219 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
118268: LD_VAR 0 1
118272: PUSH
118273: LD_INT 253
118275: EQUAL
118276: PUSH
118277: LD_VAR 0 2
118281: PPUSH
118282: CALL_OW 257
118286: PUSH
118287: LD_INT 5
118289: EQUAL
118290: AND
118291: IFFALSE 118312
// ComBinocular ( unit , x , y ) ;
118293: LD_VAR 0 2
118297: PPUSH
118298: LD_VAR 0 4
118302: PPUSH
118303: LD_VAR 0 5
118307: PPUSH
118308: CALL 121590 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
118312: LD_VAR 0 1
118316: PUSH
118317: LD_INT 254
118319: EQUAL
118320: PUSH
118321: LD_VAR 0 2
118325: PPUSH
118326: CALL_OW 264
118330: PUSH
118331: LD_EXP 97
118335: EQUAL
118336: AND
118337: PUSH
118338: LD_VAR 0 3
118342: PPUSH
118343: CALL_OW 263
118347: PUSH
118348: LD_INT 3
118350: EQUAL
118351: AND
118352: IFFALSE 118368
// HackDestroyVehicle ( unit , selectedUnit ) ;
118354: LD_VAR 0 2
118358: PPUSH
118359: LD_VAR 0 3
118363: PPUSH
118364: CALL 119885 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
118368: LD_VAR 0 1
118372: PUSH
118373: LD_INT 255
118375: EQUAL
118376: PUSH
118377: LD_VAR 0 2
118381: PPUSH
118382: CALL_OW 264
118386: PUSH
118387: LD_INT 14
118389: PUSH
118390: LD_INT 53
118392: PUSH
118393: EMPTY
118394: LIST
118395: LIST
118396: IN
118397: AND
118398: PUSH
118399: LD_VAR 0 4
118403: PPUSH
118404: LD_VAR 0 5
118408: PPUSH
118409: CALL_OW 488
118413: AND
118414: IFFALSE 118438
// CutTreeXYR ( unit , x , y , 12 ) ;
118416: LD_VAR 0 2
118420: PPUSH
118421: LD_VAR 0 4
118425: PPUSH
118426: LD_VAR 0 5
118430: PPUSH
118431: LD_INT 12
118433: PPUSH
118434: CALL 118451 0 4
// end ;
118438: LD_VAR 0 6
118442: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
118443: LD_INT 0
118445: PPUSH
// end ;
118446: LD_VAR 0 4
118450: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
118451: LD_INT 0
118453: PPUSH
118454: PPUSH
118455: PPUSH
118456: PPUSH
118457: PPUSH
118458: PPUSH
118459: PPUSH
118460: PPUSH
118461: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
118462: LD_VAR 0 1
118466: NOT
118467: PUSH
118468: LD_VAR 0 2
118472: PPUSH
118473: LD_VAR 0 3
118477: PPUSH
118478: CALL_OW 488
118482: NOT
118483: OR
118484: PUSH
118485: LD_VAR 0 4
118489: NOT
118490: OR
118491: IFFALSE 118495
// exit ;
118493: GO 118835
// list := [ ] ;
118495: LD_ADDR_VAR 0 13
118499: PUSH
118500: EMPTY
118501: ST_TO_ADDR
// if x - r < 0 then
118502: LD_VAR 0 2
118506: PUSH
118507: LD_VAR 0 4
118511: MINUS
118512: PUSH
118513: LD_INT 0
118515: LESS
118516: IFFALSE 118528
// min_x := 0 else
118518: LD_ADDR_VAR 0 7
118522: PUSH
118523: LD_INT 0
118525: ST_TO_ADDR
118526: GO 118544
// min_x := x - r ;
118528: LD_ADDR_VAR 0 7
118532: PUSH
118533: LD_VAR 0 2
118537: PUSH
118538: LD_VAR 0 4
118542: MINUS
118543: ST_TO_ADDR
// if y - r < 0 then
118544: LD_VAR 0 3
118548: PUSH
118549: LD_VAR 0 4
118553: MINUS
118554: PUSH
118555: LD_INT 0
118557: LESS
118558: IFFALSE 118570
// min_y := 0 else
118560: LD_ADDR_VAR 0 8
118564: PUSH
118565: LD_INT 0
118567: ST_TO_ADDR
118568: GO 118586
// min_y := y - r ;
118570: LD_ADDR_VAR 0 8
118574: PUSH
118575: LD_VAR 0 3
118579: PUSH
118580: LD_VAR 0 4
118584: MINUS
118585: ST_TO_ADDR
// max_x := x + r ;
118586: LD_ADDR_VAR 0 9
118590: PUSH
118591: LD_VAR 0 2
118595: PUSH
118596: LD_VAR 0 4
118600: PLUS
118601: ST_TO_ADDR
// max_y := y + r ;
118602: LD_ADDR_VAR 0 10
118606: PUSH
118607: LD_VAR 0 3
118611: PUSH
118612: LD_VAR 0 4
118616: PLUS
118617: ST_TO_ADDR
// for _x = min_x to max_x do
118618: LD_ADDR_VAR 0 11
118622: PUSH
118623: DOUBLE
118624: LD_VAR 0 7
118628: DEC
118629: ST_TO_ADDR
118630: LD_VAR 0 9
118634: PUSH
118635: FOR_TO
118636: IFFALSE 118753
// for _y = min_y to max_y do
118638: LD_ADDR_VAR 0 12
118642: PUSH
118643: DOUBLE
118644: LD_VAR 0 8
118648: DEC
118649: ST_TO_ADDR
118650: LD_VAR 0 10
118654: PUSH
118655: FOR_TO
118656: IFFALSE 118749
// begin if not ValidHex ( _x , _y ) then
118658: LD_VAR 0 11
118662: PPUSH
118663: LD_VAR 0 12
118667: PPUSH
118668: CALL_OW 488
118672: NOT
118673: IFFALSE 118677
// continue ;
118675: GO 118655
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
118677: LD_VAR 0 11
118681: PPUSH
118682: LD_VAR 0 12
118686: PPUSH
118687: CALL_OW 351
118691: PUSH
118692: LD_VAR 0 11
118696: PPUSH
118697: LD_VAR 0 12
118701: PPUSH
118702: CALL_OW 554
118706: AND
118707: IFFALSE 118747
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
118709: LD_ADDR_VAR 0 13
118713: PUSH
118714: LD_VAR 0 13
118718: PPUSH
118719: LD_VAR 0 13
118723: PUSH
118724: LD_INT 1
118726: PLUS
118727: PPUSH
118728: LD_VAR 0 11
118732: PUSH
118733: LD_VAR 0 12
118737: PUSH
118738: EMPTY
118739: LIST
118740: LIST
118741: PPUSH
118742: CALL_OW 2
118746: ST_TO_ADDR
// end ;
118747: GO 118655
118749: POP
118750: POP
118751: GO 118635
118753: POP
118754: POP
// if not list then
118755: LD_VAR 0 13
118759: NOT
118760: IFFALSE 118764
// exit ;
118762: GO 118835
// for i in list do
118764: LD_ADDR_VAR 0 6
118768: PUSH
118769: LD_VAR 0 13
118773: PUSH
118774: FOR_IN
118775: IFFALSE 118833
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
118777: LD_VAR 0 1
118781: PPUSH
118782: LD_STRING M
118784: PUSH
118785: LD_VAR 0 6
118789: PUSH
118790: LD_INT 1
118792: ARRAY
118793: PUSH
118794: LD_VAR 0 6
118798: PUSH
118799: LD_INT 2
118801: ARRAY
118802: PUSH
118803: LD_INT 0
118805: PUSH
118806: LD_INT 0
118808: PUSH
118809: LD_INT 0
118811: PUSH
118812: LD_INT 0
118814: PUSH
118815: EMPTY
118816: LIST
118817: LIST
118818: LIST
118819: LIST
118820: LIST
118821: LIST
118822: LIST
118823: PUSH
118824: EMPTY
118825: LIST
118826: PPUSH
118827: CALL_OW 447
118831: GO 118774
118833: POP
118834: POP
// end ;
118835: LD_VAR 0 5
118839: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
118840: LD_EXP 217
118844: NOT
118845: IFFALSE 118895
118847: GO 118849
118849: DISABLE
// begin initHack := true ;
118850: LD_ADDR_EXP 217
118854: PUSH
118855: LD_INT 1
118857: ST_TO_ADDR
// hackTanks := [ ] ;
118858: LD_ADDR_EXP 218
118862: PUSH
118863: EMPTY
118864: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
118865: LD_ADDR_EXP 219
118869: PUSH
118870: EMPTY
118871: ST_TO_ADDR
// hackLimit := 3 ;
118872: LD_ADDR_EXP 220
118876: PUSH
118877: LD_INT 3
118879: ST_TO_ADDR
// hackDist := 12 ;
118880: LD_ADDR_EXP 221
118884: PUSH
118885: LD_INT 12
118887: ST_TO_ADDR
// hackCounter := [ ] ;
118888: LD_ADDR_EXP 222
118892: PUSH
118893: EMPTY
118894: ST_TO_ADDR
// end ;
118895: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
118896: LD_EXP 217
118900: PUSH
118901: LD_INT 34
118903: PUSH
118904: LD_EXP 97
118908: PUSH
118909: EMPTY
118910: LIST
118911: LIST
118912: PPUSH
118913: CALL_OW 69
118917: AND
118918: IFFALSE 119173
118920: GO 118922
118922: DISABLE
118923: LD_INT 0
118925: PPUSH
118926: PPUSH
// begin enable ;
118927: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
118928: LD_ADDR_VAR 0 1
118932: PUSH
118933: LD_INT 34
118935: PUSH
118936: LD_EXP 97
118940: PUSH
118941: EMPTY
118942: LIST
118943: LIST
118944: PPUSH
118945: CALL_OW 69
118949: PUSH
118950: FOR_IN
118951: IFFALSE 119171
// begin if not i in hackTanks then
118953: LD_VAR 0 1
118957: PUSH
118958: LD_EXP 218
118962: IN
118963: NOT
118964: IFFALSE 119047
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
118966: LD_ADDR_EXP 218
118970: PUSH
118971: LD_EXP 218
118975: PPUSH
118976: LD_EXP 218
118980: PUSH
118981: LD_INT 1
118983: PLUS
118984: PPUSH
118985: LD_VAR 0 1
118989: PPUSH
118990: CALL_OW 1
118994: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
118995: LD_ADDR_EXP 219
118999: PUSH
119000: LD_EXP 219
119004: PPUSH
119005: LD_EXP 219
119009: PUSH
119010: LD_INT 1
119012: PLUS
119013: PPUSH
119014: EMPTY
119015: PPUSH
119016: CALL_OW 1
119020: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
119021: LD_ADDR_EXP 222
119025: PUSH
119026: LD_EXP 222
119030: PPUSH
119031: LD_EXP 222
119035: PUSH
119036: LD_INT 1
119038: PLUS
119039: PPUSH
119040: EMPTY
119041: PPUSH
119042: CALL_OW 1
119046: ST_TO_ADDR
// end ; if not IsOk ( i ) then
119047: LD_VAR 0 1
119051: PPUSH
119052: CALL_OW 302
119056: NOT
119057: IFFALSE 119070
// begin HackUnlinkAll ( i ) ;
119059: LD_VAR 0 1
119063: PPUSH
119064: CALL 119176 0 1
// continue ;
119068: GO 118950
// end ; HackCheckCapturedStatus ( i ) ;
119070: LD_VAR 0 1
119074: PPUSH
119075: CALL 119619 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
119079: LD_ADDR_VAR 0 2
119083: PUSH
119084: LD_INT 81
119086: PUSH
119087: LD_VAR 0 1
119091: PPUSH
119092: CALL_OW 255
119096: PUSH
119097: EMPTY
119098: LIST
119099: LIST
119100: PUSH
119101: LD_INT 33
119103: PUSH
119104: LD_INT 3
119106: PUSH
119107: EMPTY
119108: LIST
119109: LIST
119110: PUSH
119111: LD_INT 91
119113: PUSH
119114: LD_VAR 0 1
119118: PUSH
119119: LD_EXP 221
119123: PUSH
119124: EMPTY
119125: LIST
119126: LIST
119127: LIST
119128: PUSH
119129: LD_INT 50
119131: PUSH
119132: EMPTY
119133: LIST
119134: PUSH
119135: EMPTY
119136: LIST
119137: LIST
119138: LIST
119139: LIST
119140: PPUSH
119141: CALL_OW 69
119145: ST_TO_ADDR
// if not tmp then
119146: LD_VAR 0 2
119150: NOT
119151: IFFALSE 119155
// continue ;
119153: GO 118950
// HackLink ( i , tmp ) ;
119155: LD_VAR 0 1
119159: PPUSH
119160: LD_VAR 0 2
119164: PPUSH
119165: CALL 119312 0 2
// end ;
119169: GO 118950
119171: POP
119172: POP
// end ;
119173: PPOPN 2
119175: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
119176: LD_INT 0
119178: PPUSH
119179: PPUSH
119180: PPUSH
// if not hack in hackTanks then
119181: LD_VAR 0 1
119185: PUSH
119186: LD_EXP 218
119190: IN
119191: NOT
119192: IFFALSE 119196
// exit ;
119194: GO 119307
// index := GetElementIndex ( hackTanks , hack ) ;
119196: LD_ADDR_VAR 0 4
119200: PUSH
119201: LD_EXP 218
119205: PPUSH
119206: LD_VAR 0 1
119210: PPUSH
119211: CALL 70393 0 2
119215: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
119216: LD_EXP 219
119220: PUSH
119221: LD_VAR 0 4
119225: ARRAY
119226: IFFALSE 119307
// begin for i in hackTanksCaptured [ index ] do
119228: LD_ADDR_VAR 0 3
119232: PUSH
119233: LD_EXP 219
119237: PUSH
119238: LD_VAR 0 4
119242: ARRAY
119243: PUSH
119244: FOR_IN
119245: IFFALSE 119271
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
119247: LD_VAR 0 3
119251: PUSH
119252: LD_INT 1
119254: ARRAY
119255: PPUSH
119256: LD_VAR 0 3
119260: PUSH
119261: LD_INT 2
119263: ARRAY
119264: PPUSH
119265: CALL_OW 235
119269: GO 119244
119271: POP
119272: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
119273: LD_ADDR_EXP 219
119277: PUSH
119278: LD_EXP 219
119282: PPUSH
119283: LD_VAR 0 4
119287: PPUSH
119288: EMPTY
119289: PPUSH
119290: CALL_OW 1
119294: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
119295: LD_VAR 0 1
119299: PPUSH
119300: LD_INT 0
119302: PPUSH
119303: CALL_OW 505
// end ; end ;
119307: LD_VAR 0 2
119311: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
119312: LD_INT 0
119314: PPUSH
119315: PPUSH
119316: PPUSH
// if not hack in hackTanks or not vehicles then
119317: LD_VAR 0 1
119321: PUSH
119322: LD_EXP 218
119326: IN
119327: NOT
119328: PUSH
119329: LD_VAR 0 2
119333: NOT
119334: OR
119335: IFFALSE 119339
// exit ;
119337: GO 119614
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
119339: LD_ADDR_VAR 0 2
119343: PUSH
119344: LD_VAR 0 1
119348: PPUSH
119349: LD_VAR 0 2
119353: PPUSH
119354: LD_INT 1
119356: PPUSH
119357: LD_INT 1
119359: PPUSH
119360: CALL 71043 0 4
119364: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
119365: LD_ADDR_VAR 0 5
119369: PUSH
119370: LD_EXP 218
119374: PPUSH
119375: LD_VAR 0 1
119379: PPUSH
119380: CALL 70393 0 2
119384: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
119385: LD_EXP 219
119389: PUSH
119390: LD_VAR 0 5
119394: ARRAY
119395: PUSH
119396: LD_EXP 220
119400: LESS
119401: IFFALSE 119590
// begin for i := 1 to vehicles do
119403: LD_ADDR_VAR 0 4
119407: PUSH
119408: DOUBLE
119409: LD_INT 1
119411: DEC
119412: ST_TO_ADDR
119413: LD_VAR 0 2
119417: PUSH
119418: FOR_TO
119419: IFFALSE 119588
// begin if hackTanksCaptured [ index ] = hackLimit then
119421: LD_EXP 219
119425: PUSH
119426: LD_VAR 0 5
119430: ARRAY
119431: PUSH
119432: LD_EXP 220
119436: EQUAL
119437: IFFALSE 119441
// break ;
119439: GO 119588
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
119441: LD_ADDR_EXP 222
119445: PUSH
119446: LD_EXP 222
119450: PPUSH
119451: LD_VAR 0 5
119455: PPUSH
119456: LD_EXP 222
119460: PUSH
119461: LD_VAR 0 5
119465: ARRAY
119466: PUSH
119467: LD_INT 1
119469: PLUS
119470: PPUSH
119471: CALL_OW 1
119475: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
119476: LD_ADDR_EXP 219
119480: PUSH
119481: LD_EXP 219
119485: PPUSH
119486: LD_VAR 0 5
119490: PUSH
119491: LD_EXP 219
119495: PUSH
119496: LD_VAR 0 5
119500: ARRAY
119501: PUSH
119502: LD_INT 1
119504: PLUS
119505: PUSH
119506: EMPTY
119507: LIST
119508: LIST
119509: PPUSH
119510: LD_VAR 0 2
119514: PUSH
119515: LD_VAR 0 4
119519: ARRAY
119520: PUSH
119521: LD_VAR 0 2
119525: PUSH
119526: LD_VAR 0 4
119530: ARRAY
119531: PPUSH
119532: CALL_OW 255
119536: PUSH
119537: EMPTY
119538: LIST
119539: LIST
119540: PPUSH
119541: CALL 70608 0 3
119545: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
119546: LD_VAR 0 2
119550: PUSH
119551: LD_VAR 0 4
119555: ARRAY
119556: PPUSH
119557: LD_VAR 0 1
119561: PPUSH
119562: CALL_OW 255
119566: PPUSH
119567: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
119571: LD_VAR 0 2
119575: PUSH
119576: LD_VAR 0 4
119580: ARRAY
119581: PPUSH
119582: CALL_OW 141
// end ;
119586: GO 119418
119588: POP
119589: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
119590: LD_VAR 0 1
119594: PPUSH
119595: LD_EXP 219
119599: PUSH
119600: LD_VAR 0 5
119604: ARRAY
119605: PUSH
119606: LD_INT 0
119608: PLUS
119609: PPUSH
119610: CALL_OW 505
// end ;
119614: LD_VAR 0 3
119618: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
119619: LD_INT 0
119621: PPUSH
119622: PPUSH
119623: PPUSH
119624: PPUSH
// if not hack in hackTanks then
119625: LD_VAR 0 1
119629: PUSH
119630: LD_EXP 218
119634: IN
119635: NOT
119636: IFFALSE 119640
// exit ;
119638: GO 119880
// index := GetElementIndex ( hackTanks , hack ) ;
119640: LD_ADDR_VAR 0 4
119644: PUSH
119645: LD_EXP 218
119649: PPUSH
119650: LD_VAR 0 1
119654: PPUSH
119655: CALL 70393 0 2
119659: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
119660: LD_ADDR_VAR 0 3
119664: PUSH
119665: DOUBLE
119666: LD_EXP 219
119670: PUSH
119671: LD_VAR 0 4
119675: ARRAY
119676: INC
119677: ST_TO_ADDR
119678: LD_INT 1
119680: PUSH
119681: FOR_DOWNTO
119682: IFFALSE 119854
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
119684: LD_ADDR_VAR 0 5
119688: PUSH
119689: LD_EXP 219
119693: PUSH
119694: LD_VAR 0 4
119698: ARRAY
119699: PUSH
119700: LD_VAR 0 3
119704: ARRAY
119705: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
119706: LD_VAR 0 5
119710: PUSH
119711: LD_INT 1
119713: ARRAY
119714: PPUSH
119715: CALL_OW 302
119719: NOT
119720: PUSH
119721: LD_VAR 0 5
119725: PUSH
119726: LD_INT 1
119728: ARRAY
119729: PPUSH
119730: CALL_OW 255
119734: PUSH
119735: LD_VAR 0 1
119739: PPUSH
119740: CALL_OW 255
119744: NONEQUAL
119745: OR
119746: IFFALSE 119852
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
119748: LD_VAR 0 5
119752: PUSH
119753: LD_INT 1
119755: ARRAY
119756: PPUSH
119757: CALL_OW 305
119761: PUSH
119762: LD_VAR 0 5
119766: PUSH
119767: LD_INT 1
119769: ARRAY
119770: PPUSH
119771: CALL_OW 255
119775: PUSH
119776: LD_VAR 0 1
119780: PPUSH
119781: CALL_OW 255
119785: EQUAL
119786: AND
119787: IFFALSE 119811
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
119789: LD_VAR 0 5
119793: PUSH
119794: LD_INT 1
119796: ARRAY
119797: PPUSH
119798: LD_VAR 0 5
119802: PUSH
119803: LD_INT 2
119805: ARRAY
119806: PPUSH
119807: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
119811: LD_ADDR_EXP 219
119815: PUSH
119816: LD_EXP 219
119820: PPUSH
119821: LD_VAR 0 4
119825: PPUSH
119826: LD_EXP 219
119830: PUSH
119831: LD_VAR 0 4
119835: ARRAY
119836: PPUSH
119837: LD_VAR 0 3
119841: PPUSH
119842: CALL_OW 3
119846: PPUSH
119847: CALL_OW 1
119851: ST_TO_ADDR
// end ; end ;
119852: GO 119681
119854: POP
119855: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
119856: LD_VAR 0 1
119860: PPUSH
119861: LD_EXP 219
119865: PUSH
119866: LD_VAR 0 4
119870: ARRAY
119871: PUSH
119872: LD_INT 0
119874: PLUS
119875: PPUSH
119876: CALL_OW 505
// end ;
119880: LD_VAR 0 2
119884: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
119885: LD_INT 0
119887: PPUSH
119888: PPUSH
119889: PPUSH
119890: PPUSH
// if not hack in hackTanks then
119891: LD_VAR 0 1
119895: PUSH
119896: LD_EXP 218
119900: IN
119901: NOT
119902: IFFALSE 119906
// exit ;
119904: GO 119991
// index := GetElementIndex ( hackTanks , hack ) ;
119906: LD_ADDR_VAR 0 5
119910: PUSH
119911: LD_EXP 218
119915: PPUSH
119916: LD_VAR 0 1
119920: PPUSH
119921: CALL 70393 0 2
119925: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
119926: LD_ADDR_VAR 0 4
119930: PUSH
119931: DOUBLE
119932: LD_INT 1
119934: DEC
119935: ST_TO_ADDR
119936: LD_EXP 219
119940: PUSH
119941: LD_VAR 0 5
119945: ARRAY
119946: PUSH
119947: FOR_TO
119948: IFFALSE 119989
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
119950: LD_EXP 219
119954: PUSH
119955: LD_VAR 0 5
119959: ARRAY
119960: PUSH
119961: LD_VAR 0 4
119965: ARRAY
119966: PUSH
119967: LD_INT 1
119969: ARRAY
119970: PUSH
119971: LD_VAR 0 2
119975: EQUAL
119976: IFFALSE 119987
// KillUnit ( vehicle ) ;
119978: LD_VAR 0 2
119982: PPUSH
119983: CALL_OW 66
119987: GO 119947
119989: POP
119990: POP
// end ;
119991: LD_VAR 0 3
119995: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
119996: LD_EXP 223
120000: NOT
120001: IFFALSE 120036
120003: GO 120005
120005: DISABLE
// begin initMiner := true ;
120006: LD_ADDR_EXP 223
120010: PUSH
120011: LD_INT 1
120013: ST_TO_ADDR
// minersList := [ ] ;
120014: LD_ADDR_EXP 224
120018: PUSH
120019: EMPTY
120020: ST_TO_ADDR
// minerMinesList := [ ] ;
120021: LD_ADDR_EXP 225
120025: PUSH
120026: EMPTY
120027: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
120028: LD_ADDR_EXP 226
120032: PUSH
120033: LD_INT 5
120035: ST_TO_ADDR
// end ;
120036: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
120037: LD_EXP 223
120041: PUSH
120042: LD_INT 34
120044: PUSH
120045: LD_EXP 102
120049: PUSH
120050: EMPTY
120051: LIST
120052: LIST
120053: PPUSH
120054: CALL_OW 69
120058: AND
120059: IFFALSE 120522
120061: GO 120063
120063: DISABLE
120064: LD_INT 0
120066: PPUSH
120067: PPUSH
120068: PPUSH
120069: PPUSH
// begin enable ;
120070: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
120071: LD_ADDR_VAR 0 1
120075: PUSH
120076: LD_INT 34
120078: PUSH
120079: LD_EXP 102
120083: PUSH
120084: EMPTY
120085: LIST
120086: LIST
120087: PPUSH
120088: CALL_OW 69
120092: PUSH
120093: FOR_IN
120094: IFFALSE 120166
// begin if not i in minersList then
120096: LD_VAR 0 1
120100: PUSH
120101: LD_EXP 224
120105: IN
120106: NOT
120107: IFFALSE 120164
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
120109: LD_ADDR_EXP 224
120113: PUSH
120114: LD_EXP 224
120118: PPUSH
120119: LD_EXP 224
120123: PUSH
120124: LD_INT 1
120126: PLUS
120127: PPUSH
120128: LD_VAR 0 1
120132: PPUSH
120133: CALL_OW 1
120137: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
120138: LD_ADDR_EXP 225
120142: PUSH
120143: LD_EXP 225
120147: PPUSH
120148: LD_EXP 225
120152: PUSH
120153: LD_INT 1
120155: PLUS
120156: PPUSH
120157: EMPTY
120158: PPUSH
120159: CALL_OW 1
120163: ST_TO_ADDR
// end end ;
120164: GO 120093
120166: POP
120167: POP
// for i := minerMinesList downto 1 do
120168: LD_ADDR_VAR 0 1
120172: PUSH
120173: DOUBLE
120174: LD_EXP 225
120178: INC
120179: ST_TO_ADDR
120180: LD_INT 1
120182: PUSH
120183: FOR_DOWNTO
120184: IFFALSE 120520
// begin if IsLive ( minersList [ i ] ) then
120186: LD_EXP 224
120190: PUSH
120191: LD_VAR 0 1
120195: ARRAY
120196: PPUSH
120197: CALL_OW 300
120201: IFFALSE 120229
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
120203: LD_EXP 224
120207: PUSH
120208: LD_VAR 0 1
120212: ARRAY
120213: PPUSH
120214: LD_EXP 225
120218: PUSH
120219: LD_VAR 0 1
120223: ARRAY
120224: PPUSH
120225: CALL_OW 505
// if not minerMinesList [ i ] then
120229: LD_EXP 225
120233: PUSH
120234: LD_VAR 0 1
120238: ARRAY
120239: NOT
120240: IFFALSE 120244
// continue ;
120242: GO 120183
// for j := minerMinesList [ i ] downto 1 do
120244: LD_ADDR_VAR 0 2
120248: PUSH
120249: DOUBLE
120250: LD_EXP 225
120254: PUSH
120255: LD_VAR 0 1
120259: ARRAY
120260: INC
120261: ST_TO_ADDR
120262: LD_INT 1
120264: PUSH
120265: FOR_DOWNTO
120266: IFFALSE 120516
// begin side := GetSide ( minersList [ i ] ) ;
120268: LD_ADDR_VAR 0 3
120272: PUSH
120273: LD_EXP 224
120277: PUSH
120278: LD_VAR 0 1
120282: ARRAY
120283: PPUSH
120284: CALL_OW 255
120288: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
120289: LD_ADDR_VAR 0 4
120293: PUSH
120294: LD_EXP 225
120298: PUSH
120299: LD_VAR 0 1
120303: ARRAY
120304: PUSH
120305: LD_VAR 0 2
120309: ARRAY
120310: PUSH
120311: LD_INT 1
120313: ARRAY
120314: PPUSH
120315: LD_EXP 225
120319: PUSH
120320: LD_VAR 0 1
120324: ARRAY
120325: PUSH
120326: LD_VAR 0 2
120330: ARRAY
120331: PUSH
120332: LD_INT 2
120334: ARRAY
120335: PPUSH
120336: CALL_OW 428
120340: ST_TO_ADDR
// if not tmp then
120341: LD_VAR 0 4
120345: NOT
120346: IFFALSE 120350
// continue ;
120348: GO 120265
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
120350: LD_VAR 0 4
120354: PUSH
120355: LD_INT 81
120357: PUSH
120358: LD_VAR 0 3
120362: PUSH
120363: EMPTY
120364: LIST
120365: LIST
120366: PPUSH
120367: CALL_OW 69
120371: IN
120372: PUSH
120373: LD_EXP 225
120377: PUSH
120378: LD_VAR 0 1
120382: ARRAY
120383: PUSH
120384: LD_VAR 0 2
120388: ARRAY
120389: PUSH
120390: LD_INT 1
120392: ARRAY
120393: PPUSH
120394: LD_EXP 225
120398: PUSH
120399: LD_VAR 0 1
120403: ARRAY
120404: PUSH
120405: LD_VAR 0 2
120409: ARRAY
120410: PUSH
120411: LD_INT 2
120413: ARRAY
120414: PPUSH
120415: CALL_OW 458
120419: AND
120420: IFFALSE 120514
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
120422: LD_EXP 225
120426: PUSH
120427: LD_VAR 0 1
120431: ARRAY
120432: PUSH
120433: LD_VAR 0 2
120437: ARRAY
120438: PUSH
120439: LD_INT 1
120441: ARRAY
120442: PPUSH
120443: LD_EXP 225
120447: PUSH
120448: LD_VAR 0 1
120452: ARRAY
120453: PUSH
120454: LD_VAR 0 2
120458: ARRAY
120459: PUSH
120460: LD_INT 2
120462: ARRAY
120463: PPUSH
120464: LD_VAR 0 3
120468: PPUSH
120469: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
120473: LD_ADDR_EXP 225
120477: PUSH
120478: LD_EXP 225
120482: PPUSH
120483: LD_VAR 0 1
120487: PPUSH
120488: LD_EXP 225
120492: PUSH
120493: LD_VAR 0 1
120497: ARRAY
120498: PPUSH
120499: LD_VAR 0 2
120503: PPUSH
120504: CALL_OW 3
120508: PPUSH
120509: CALL_OW 1
120513: ST_TO_ADDR
// end ; end ;
120514: GO 120265
120516: POP
120517: POP
// end ;
120518: GO 120183
120520: POP
120521: POP
// end ;
120522: PPOPN 4
120524: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
120525: LD_INT 0
120527: PPUSH
120528: PPUSH
// result := false ;
120529: LD_ADDR_VAR 0 4
120533: PUSH
120534: LD_INT 0
120536: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
120537: LD_VAR 0 1
120541: PPUSH
120542: CALL_OW 264
120546: PUSH
120547: LD_EXP 102
120551: EQUAL
120552: NOT
120553: IFFALSE 120557
// exit ;
120555: GO 120797
// index := GetElementIndex ( minersList , unit ) ;
120557: LD_ADDR_VAR 0 5
120561: PUSH
120562: LD_EXP 224
120566: PPUSH
120567: LD_VAR 0 1
120571: PPUSH
120572: CALL 70393 0 2
120576: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
120577: LD_EXP 225
120581: PUSH
120582: LD_VAR 0 5
120586: ARRAY
120587: PUSH
120588: LD_EXP 226
120592: GREATEREQUAL
120593: IFFALSE 120597
// exit ;
120595: GO 120797
// ComMoveXY ( unit , x , y ) ;
120597: LD_VAR 0 1
120601: PPUSH
120602: LD_VAR 0 2
120606: PPUSH
120607: LD_VAR 0 3
120611: PPUSH
120612: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
120616: LD_INT 35
120618: PPUSH
120619: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
120623: LD_VAR 0 1
120627: PPUSH
120628: LD_VAR 0 2
120632: PPUSH
120633: LD_VAR 0 3
120637: PPUSH
120638: CALL 101165 0 3
120642: NOT
120643: PUSH
120644: LD_VAR 0 1
120648: PPUSH
120649: CALL_OW 314
120653: AND
120654: IFFALSE 120658
// exit ;
120656: GO 120797
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
120658: LD_VAR 0 2
120662: PPUSH
120663: LD_VAR 0 3
120667: PPUSH
120668: CALL_OW 428
120672: PUSH
120673: LD_VAR 0 1
120677: EQUAL
120678: PUSH
120679: LD_VAR 0 1
120683: PPUSH
120684: CALL_OW 314
120688: NOT
120689: AND
120690: IFFALSE 120616
// PlaySoundXY ( x , y , PlantMine ) ;
120692: LD_VAR 0 2
120696: PPUSH
120697: LD_VAR 0 3
120701: PPUSH
120702: LD_STRING PlantMine
120704: PPUSH
120705: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
120709: LD_VAR 0 2
120713: PPUSH
120714: LD_VAR 0 3
120718: PPUSH
120719: LD_VAR 0 1
120723: PPUSH
120724: CALL_OW 255
120728: PPUSH
120729: LD_INT 0
120731: PPUSH
120732: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
120736: LD_ADDR_EXP 225
120740: PUSH
120741: LD_EXP 225
120745: PPUSH
120746: LD_VAR 0 5
120750: PUSH
120751: LD_EXP 225
120755: PUSH
120756: LD_VAR 0 5
120760: ARRAY
120761: PUSH
120762: LD_INT 1
120764: PLUS
120765: PUSH
120766: EMPTY
120767: LIST
120768: LIST
120769: PPUSH
120770: LD_VAR 0 2
120774: PUSH
120775: LD_VAR 0 3
120779: PUSH
120780: EMPTY
120781: LIST
120782: LIST
120783: PPUSH
120784: CALL 70608 0 3
120788: ST_TO_ADDR
// result := true ;
120789: LD_ADDR_VAR 0 4
120793: PUSH
120794: LD_INT 1
120796: ST_TO_ADDR
// end ;
120797: LD_VAR 0 4
120801: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
120802: LD_INT 0
120804: PPUSH
120805: PPUSH
120806: PPUSH
// if not unit in minersList then
120807: LD_VAR 0 1
120811: PUSH
120812: LD_EXP 224
120816: IN
120817: NOT
120818: IFFALSE 120822
// exit ;
120820: GO 121214
// index := GetElementIndex ( minersList , unit ) ;
120822: LD_ADDR_VAR 0 6
120826: PUSH
120827: LD_EXP 224
120831: PPUSH
120832: LD_VAR 0 1
120836: PPUSH
120837: CALL 70393 0 2
120841: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
120842: LD_ADDR_VAR 0 5
120846: PUSH
120847: DOUBLE
120848: LD_EXP 225
120852: PUSH
120853: LD_VAR 0 6
120857: ARRAY
120858: INC
120859: ST_TO_ADDR
120860: LD_INT 1
120862: PUSH
120863: FOR_DOWNTO
120864: IFFALSE 121025
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
120866: LD_EXP 225
120870: PUSH
120871: LD_VAR 0 6
120875: ARRAY
120876: PUSH
120877: LD_VAR 0 5
120881: ARRAY
120882: PUSH
120883: LD_INT 1
120885: ARRAY
120886: PUSH
120887: LD_VAR 0 2
120891: EQUAL
120892: PUSH
120893: LD_EXP 225
120897: PUSH
120898: LD_VAR 0 6
120902: ARRAY
120903: PUSH
120904: LD_VAR 0 5
120908: ARRAY
120909: PUSH
120910: LD_INT 2
120912: ARRAY
120913: PUSH
120914: LD_VAR 0 3
120918: EQUAL
120919: AND
120920: IFFALSE 121023
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
120922: LD_EXP 225
120926: PUSH
120927: LD_VAR 0 6
120931: ARRAY
120932: PUSH
120933: LD_VAR 0 5
120937: ARRAY
120938: PUSH
120939: LD_INT 1
120941: ARRAY
120942: PPUSH
120943: LD_EXP 225
120947: PUSH
120948: LD_VAR 0 6
120952: ARRAY
120953: PUSH
120954: LD_VAR 0 5
120958: ARRAY
120959: PUSH
120960: LD_INT 2
120962: ARRAY
120963: PPUSH
120964: LD_VAR 0 1
120968: PPUSH
120969: CALL_OW 255
120973: PPUSH
120974: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
120978: LD_ADDR_EXP 225
120982: PUSH
120983: LD_EXP 225
120987: PPUSH
120988: LD_VAR 0 6
120992: PPUSH
120993: LD_EXP 225
120997: PUSH
120998: LD_VAR 0 6
121002: ARRAY
121003: PPUSH
121004: LD_VAR 0 5
121008: PPUSH
121009: CALL_OW 3
121013: PPUSH
121014: CALL_OW 1
121018: ST_TO_ADDR
// exit ;
121019: POP
121020: POP
121021: GO 121214
// end ; end ;
121023: GO 120863
121025: POP
121026: POP
// for i := minerMinesList [ index ] downto 1 do
121027: LD_ADDR_VAR 0 5
121031: PUSH
121032: DOUBLE
121033: LD_EXP 225
121037: PUSH
121038: LD_VAR 0 6
121042: ARRAY
121043: INC
121044: ST_TO_ADDR
121045: LD_INT 1
121047: PUSH
121048: FOR_DOWNTO
121049: IFFALSE 121212
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
121051: LD_EXP 225
121055: PUSH
121056: LD_VAR 0 6
121060: ARRAY
121061: PUSH
121062: LD_VAR 0 5
121066: ARRAY
121067: PUSH
121068: LD_INT 1
121070: ARRAY
121071: PPUSH
121072: LD_EXP 225
121076: PUSH
121077: LD_VAR 0 6
121081: ARRAY
121082: PUSH
121083: LD_VAR 0 5
121087: ARRAY
121088: PUSH
121089: LD_INT 2
121091: ARRAY
121092: PPUSH
121093: LD_VAR 0 2
121097: PPUSH
121098: LD_VAR 0 3
121102: PPUSH
121103: CALL_OW 298
121107: PUSH
121108: LD_INT 6
121110: LESS
121111: IFFALSE 121210
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
121113: LD_EXP 225
121117: PUSH
121118: LD_VAR 0 6
121122: ARRAY
121123: PUSH
121124: LD_VAR 0 5
121128: ARRAY
121129: PUSH
121130: LD_INT 1
121132: ARRAY
121133: PPUSH
121134: LD_EXP 225
121138: PUSH
121139: LD_VAR 0 6
121143: ARRAY
121144: PUSH
121145: LD_VAR 0 5
121149: ARRAY
121150: PUSH
121151: LD_INT 2
121153: ARRAY
121154: PPUSH
121155: LD_VAR 0 1
121159: PPUSH
121160: CALL_OW 255
121164: PPUSH
121165: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
121169: LD_ADDR_EXP 225
121173: PUSH
121174: LD_EXP 225
121178: PPUSH
121179: LD_VAR 0 6
121183: PPUSH
121184: LD_EXP 225
121188: PUSH
121189: LD_VAR 0 6
121193: ARRAY
121194: PPUSH
121195: LD_VAR 0 5
121199: PPUSH
121200: CALL_OW 3
121204: PPUSH
121205: CALL_OW 1
121209: ST_TO_ADDR
// end ; end ;
121210: GO 121048
121212: POP
121213: POP
// end ;
121214: LD_VAR 0 4
121218: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
121219: LD_INT 0
121221: PPUSH
121222: PPUSH
121223: PPUSH
121224: PPUSH
121225: PPUSH
121226: PPUSH
121227: PPUSH
121228: PPUSH
121229: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
121230: LD_VAR 0 1
121234: PPUSH
121235: CALL_OW 264
121239: PUSH
121240: LD_EXP 102
121244: EQUAL
121245: NOT
121246: PUSH
121247: LD_VAR 0 1
121251: PUSH
121252: LD_EXP 224
121256: IN
121257: NOT
121258: OR
121259: IFFALSE 121263
// exit ;
121261: GO 121585
// index := GetElementIndex ( minersList , unit ) ;
121263: LD_ADDR_VAR 0 6
121267: PUSH
121268: LD_EXP 224
121272: PPUSH
121273: LD_VAR 0 1
121277: PPUSH
121278: CALL 70393 0 2
121282: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
121283: LD_ADDR_VAR 0 8
121287: PUSH
121288: LD_EXP 226
121292: PUSH
121293: LD_EXP 225
121297: PUSH
121298: LD_VAR 0 6
121302: ARRAY
121303: MINUS
121304: ST_TO_ADDR
// if not minesFreeAmount then
121305: LD_VAR 0 8
121309: NOT
121310: IFFALSE 121314
// exit ;
121312: GO 121585
// tmp := [ ] ;
121314: LD_ADDR_VAR 0 7
121318: PUSH
121319: EMPTY
121320: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
121321: LD_ADDR_VAR 0 5
121325: PUSH
121326: DOUBLE
121327: LD_INT 1
121329: DEC
121330: ST_TO_ADDR
121331: LD_VAR 0 8
121335: PUSH
121336: FOR_TO
121337: IFFALSE 121532
// begin _d := rand ( 0 , 5 ) ;
121339: LD_ADDR_VAR 0 11
121343: PUSH
121344: LD_INT 0
121346: PPUSH
121347: LD_INT 5
121349: PPUSH
121350: CALL_OW 12
121354: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
121355: LD_ADDR_VAR 0 12
121359: PUSH
121360: LD_INT 2
121362: PPUSH
121363: LD_INT 6
121365: PPUSH
121366: CALL_OW 12
121370: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
121371: LD_ADDR_VAR 0 9
121375: PUSH
121376: LD_VAR 0 2
121380: PPUSH
121381: LD_VAR 0 11
121385: PPUSH
121386: LD_VAR 0 12
121390: PPUSH
121391: CALL_OW 272
121395: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
121396: LD_ADDR_VAR 0 10
121400: PUSH
121401: LD_VAR 0 3
121405: PPUSH
121406: LD_VAR 0 11
121410: PPUSH
121411: LD_VAR 0 12
121415: PPUSH
121416: CALL_OW 273
121420: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
121421: LD_VAR 0 9
121425: PPUSH
121426: LD_VAR 0 10
121430: PPUSH
121431: CALL_OW 488
121435: PUSH
121436: LD_VAR 0 9
121440: PUSH
121441: LD_VAR 0 10
121445: PUSH
121446: EMPTY
121447: LIST
121448: LIST
121449: PUSH
121450: LD_VAR 0 7
121454: IN
121455: NOT
121456: AND
121457: PUSH
121458: LD_VAR 0 9
121462: PPUSH
121463: LD_VAR 0 10
121467: PPUSH
121468: CALL_OW 458
121472: NOT
121473: AND
121474: IFFALSE 121516
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
121476: LD_ADDR_VAR 0 7
121480: PUSH
121481: LD_VAR 0 7
121485: PPUSH
121486: LD_VAR 0 7
121490: PUSH
121491: LD_INT 1
121493: PLUS
121494: PPUSH
121495: LD_VAR 0 9
121499: PUSH
121500: LD_VAR 0 10
121504: PUSH
121505: EMPTY
121506: LIST
121507: LIST
121508: PPUSH
121509: CALL_OW 1
121513: ST_TO_ADDR
121514: GO 121530
// i := i - 1 ;
121516: LD_ADDR_VAR 0 5
121520: PUSH
121521: LD_VAR 0 5
121525: PUSH
121526: LD_INT 1
121528: MINUS
121529: ST_TO_ADDR
// end ;
121530: GO 121336
121532: POP
121533: POP
// for i in tmp do
121534: LD_ADDR_VAR 0 5
121538: PUSH
121539: LD_VAR 0 7
121543: PUSH
121544: FOR_IN
121545: IFFALSE 121583
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
121547: LD_VAR 0 1
121551: PPUSH
121552: LD_VAR 0 5
121556: PUSH
121557: LD_INT 1
121559: ARRAY
121560: PPUSH
121561: LD_VAR 0 5
121565: PUSH
121566: LD_INT 2
121568: ARRAY
121569: PPUSH
121570: CALL 120525 0 3
121574: NOT
121575: IFFALSE 121581
// exit ;
121577: POP
121578: POP
121579: GO 121585
121581: GO 121544
121583: POP
121584: POP
// end ;
121585: LD_VAR 0 4
121589: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
121590: LD_INT 0
121592: PPUSH
121593: PPUSH
121594: PPUSH
121595: PPUSH
121596: PPUSH
121597: PPUSH
121598: PPUSH
// if not GetClass ( unit ) = class_sniper then
121599: LD_VAR 0 1
121603: PPUSH
121604: CALL_OW 257
121608: PUSH
121609: LD_INT 5
121611: EQUAL
121612: NOT
121613: IFFALSE 121617
// exit ;
121615: GO 122005
// dist := 8 ;
121617: LD_ADDR_VAR 0 5
121621: PUSH
121622: LD_INT 8
121624: ST_TO_ADDR
// viewRange := 12 ;
121625: LD_ADDR_VAR 0 7
121629: PUSH
121630: LD_INT 12
121632: ST_TO_ADDR
// side := GetSide ( unit ) ;
121633: LD_ADDR_VAR 0 6
121637: PUSH
121638: LD_VAR 0 1
121642: PPUSH
121643: CALL_OW 255
121647: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
121648: LD_INT 61
121650: PPUSH
121651: LD_VAR 0 6
121655: PPUSH
121656: CALL_OW 321
121660: PUSH
121661: LD_INT 2
121663: EQUAL
121664: IFFALSE 121674
// viewRange := 16 ;
121666: LD_ADDR_VAR 0 7
121670: PUSH
121671: LD_INT 16
121673: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
121674: LD_VAR 0 1
121678: PPUSH
121679: LD_VAR 0 2
121683: PPUSH
121684: LD_VAR 0 3
121688: PPUSH
121689: CALL_OW 297
121693: PUSH
121694: LD_VAR 0 5
121698: GREATER
121699: IFFALSE 121778
// begin ComMoveXY ( unit , x , y ) ;
121701: LD_VAR 0 1
121705: PPUSH
121706: LD_VAR 0 2
121710: PPUSH
121711: LD_VAR 0 3
121715: PPUSH
121716: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
121720: LD_INT 35
121722: PPUSH
121723: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
121727: LD_VAR 0 1
121731: PPUSH
121732: LD_VAR 0 2
121736: PPUSH
121737: LD_VAR 0 3
121741: PPUSH
121742: CALL 101165 0 3
121746: NOT
121747: IFFALSE 121751
// exit ;
121749: GO 122005
// until GetDistUnitXY ( unit , x , y ) < dist ;
121751: LD_VAR 0 1
121755: PPUSH
121756: LD_VAR 0 2
121760: PPUSH
121761: LD_VAR 0 3
121765: PPUSH
121766: CALL_OW 297
121770: PUSH
121771: LD_VAR 0 5
121775: LESS
121776: IFFALSE 121720
// end ; ComTurnXY ( unit , x , y ) ;
121778: LD_VAR 0 1
121782: PPUSH
121783: LD_VAR 0 2
121787: PPUSH
121788: LD_VAR 0 3
121792: PPUSH
121793: CALL_OW 118
// wait ( 5 ) ;
121797: LD_INT 5
121799: PPUSH
121800: CALL_OW 67
// _d := GetDir ( unit ) ;
121804: LD_ADDR_VAR 0 10
121808: PUSH
121809: LD_VAR 0 1
121813: PPUSH
121814: CALL_OW 254
121818: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
121819: LD_ADDR_VAR 0 8
121823: PUSH
121824: LD_VAR 0 1
121828: PPUSH
121829: CALL_OW 250
121833: PPUSH
121834: LD_VAR 0 10
121838: PPUSH
121839: LD_VAR 0 5
121843: PPUSH
121844: CALL_OW 272
121848: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
121849: LD_ADDR_VAR 0 9
121853: PUSH
121854: LD_VAR 0 1
121858: PPUSH
121859: CALL_OW 251
121863: PPUSH
121864: LD_VAR 0 10
121868: PPUSH
121869: LD_VAR 0 5
121873: PPUSH
121874: CALL_OW 273
121878: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
121879: LD_VAR 0 8
121883: PPUSH
121884: LD_VAR 0 9
121888: PPUSH
121889: CALL_OW 488
121893: NOT
121894: IFFALSE 121898
// exit ;
121896: GO 122005
// ComAnimCustom ( unit , 1 ) ;
121898: LD_VAR 0 1
121902: PPUSH
121903: LD_INT 1
121905: PPUSH
121906: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
121910: LD_VAR 0 8
121914: PPUSH
121915: LD_VAR 0 9
121919: PPUSH
121920: LD_VAR 0 6
121924: PPUSH
121925: LD_VAR 0 7
121929: PPUSH
121930: CALL_OW 330
// repeat wait ( 1 ) ;
121934: LD_INT 1
121936: PPUSH
121937: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
121941: LD_VAR 0 1
121945: PPUSH
121946: CALL_OW 316
121950: PUSH
121951: LD_VAR 0 1
121955: PPUSH
121956: CALL_OW 314
121960: OR
121961: PUSH
121962: LD_VAR 0 1
121966: PPUSH
121967: CALL_OW 302
121971: NOT
121972: OR
121973: PUSH
121974: LD_VAR 0 1
121978: PPUSH
121979: CALL_OW 301
121983: OR
121984: IFFALSE 121934
// RemoveSeeing ( _x , _y , side ) ;
121986: LD_VAR 0 8
121990: PPUSH
121991: LD_VAR 0 9
121995: PPUSH
121996: LD_VAR 0 6
122000: PPUSH
122001: CALL_OW 331
// end ; end_of_file
122005: LD_VAR 0 4
122009: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
122010: LD_INT 0
122012: PPUSH
122013: PPUSH
122014: PPUSH
122015: PPUSH
122016: PPUSH
122017: PPUSH
122018: PPUSH
122019: PPUSH
122020: PPUSH
122021: PPUSH
122022: PPUSH
122023: PPUSH
122024: PPUSH
122025: PPUSH
122026: PPUSH
122027: PPUSH
122028: PPUSH
122029: PPUSH
122030: PPUSH
122031: PPUSH
122032: PPUSH
122033: PPUSH
122034: PPUSH
122035: PPUSH
122036: PPUSH
122037: PPUSH
122038: PPUSH
122039: PPUSH
122040: PPUSH
122041: PPUSH
122042: PPUSH
122043: PPUSH
122044: PPUSH
122045: PPUSH
// if not list then
122046: LD_VAR 0 1
122050: NOT
122051: IFFALSE 122055
// exit ;
122053: GO 126714
// base := list [ 1 ] ;
122055: LD_ADDR_VAR 0 3
122059: PUSH
122060: LD_VAR 0 1
122064: PUSH
122065: LD_INT 1
122067: ARRAY
122068: ST_TO_ADDR
// group := list [ 2 ] ;
122069: LD_ADDR_VAR 0 4
122073: PUSH
122074: LD_VAR 0 1
122078: PUSH
122079: LD_INT 2
122081: ARRAY
122082: ST_TO_ADDR
// path := list [ 3 ] ;
122083: LD_ADDR_VAR 0 5
122087: PUSH
122088: LD_VAR 0 1
122092: PUSH
122093: LD_INT 3
122095: ARRAY
122096: ST_TO_ADDR
// flags := list [ 4 ] ;
122097: LD_ADDR_VAR 0 6
122101: PUSH
122102: LD_VAR 0 1
122106: PUSH
122107: LD_INT 4
122109: ARRAY
122110: ST_TO_ADDR
// mined := [ ] ;
122111: LD_ADDR_VAR 0 27
122115: PUSH
122116: EMPTY
122117: ST_TO_ADDR
// bombed := [ ] ;
122118: LD_ADDR_VAR 0 28
122122: PUSH
122123: EMPTY
122124: ST_TO_ADDR
// healers := [ ] ;
122125: LD_ADDR_VAR 0 31
122129: PUSH
122130: EMPTY
122131: ST_TO_ADDR
// to_heal := [ ] ;
122132: LD_ADDR_VAR 0 30
122136: PUSH
122137: EMPTY
122138: ST_TO_ADDR
// repairs := [ ] ;
122139: LD_ADDR_VAR 0 33
122143: PUSH
122144: EMPTY
122145: ST_TO_ADDR
// to_repair := [ ] ;
122146: LD_ADDR_VAR 0 32
122150: PUSH
122151: EMPTY
122152: ST_TO_ADDR
// if not group or not path then
122153: LD_VAR 0 4
122157: NOT
122158: PUSH
122159: LD_VAR 0 5
122163: NOT
122164: OR
122165: IFFALSE 122169
// exit ;
122167: GO 126714
// side := GetSide ( group [ 1 ] ) ;
122169: LD_ADDR_VAR 0 35
122173: PUSH
122174: LD_VAR 0 4
122178: PUSH
122179: LD_INT 1
122181: ARRAY
122182: PPUSH
122183: CALL_OW 255
122187: ST_TO_ADDR
// if flags then
122188: LD_VAR 0 6
122192: IFFALSE 122336
// begin f_ignore_area := flags [ 1 ] ;
122194: LD_ADDR_VAR 0 17
122198: PUSH
122199: LD_VAR 0 6
122203: PUSH
122204: LD_INT 1
122206: ARRAY
122207: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
122208: LD_ADDR_VAR 0 18
122212: PUSH
122213: LD_VAR 0 6
122217: PUSH
122218: LD_INT 2
122220: ARRAY
122221: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
122222: LD_ADDR_VAR 0 19
122226: PUSH
122227: LD_VAR 0 6
122231: PUSH
122232: LD_INT 3
122234: ARRAY
122235: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
122236: LD_ADDR_VAR 0 20
122240: PUSH
122241: LD_VAR 0 6
122245: PUSH
122246: LD_INT 4
122248: ARRAY
122249: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
122250: LD_ADDR_VAR 0 21
122254: PUSH
122255: LD_VAR 0 6
122259: PUSH
122260: LD_INT 5
122262: ARRAY
122263: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
122264: LD_ADDR_VAR 0 22
122268: PUSH
122269: LD_VAR 0 6
122273: PUSH
122274: LD_INT 6
122276: ARRAY
122277: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
122278: LD_ADDR_VAR 0 23
122282: PUSH
122283: LD_VAR 0 6
122287: PUSH
122288: LD_INT 7
122290: ARRAY
122291: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
122292: LD_ADDR_VAR 0 24
122296: PUSH
122297: LD_VAR 0 6
122301: PUSH
122302: LD_INT 8
122304: ARRAY
122305: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
122306: LD_ADDR_VAR 0 25
122310: PUSH
122311: LD_VAR 0 6
122315: PUSH
122316: LD_INT 9
122318: ARRAY
122319: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
122320: LD_ADDR_VAR 0 26
122324: PUSH
122325: LD_VAR 0 6
122329: PUSH
122330: LD_INT 10
122332: ARRAY
122333: ST_TO_ADDR
// end else
122334: GO 122416
// begin f_ignore_area := false ;
122336: LD_ADDR_VAR 0 17
122340: PUSH
122341: LD_INT 0
122343: ST_TO_ADDR
// f_capture := false ;
122344: LD_ADDR_VAR 0 18
122348: PUSH
122349: LD_INT 0
122351: ST_TO_ADDR
// f_ignore_civ := false ;
122352: LD_ADDR_VAR 0 19
122356: PUSH
122357: LD_INT 0
122359: ST_TO_ADDR
// f_murder := false ;
122360: LD_ADDR_VAR 0 20
122364: PUSH
122365: LD_INT 0
122367: ST_TO_ADDR
// f_mines := false ;
122368: LD_ADDR_VAR 0 21
122372: PUSH
122373: LD_INT 0
122375: ST_TO_ADDR
// f_repair := false ;
122376: LD_ADDR_VAR 0 22
122380: PUSH
122381: LD_INT 0
122383: ST_TO_ADDR
// f_heal := false ;
122384: LD_ADDR_VAR 0 23
122388: PUSH
122389: LD_INT 0
122391: ST_TO_ADDR
// f_spacetime := false ;
122392: LD_ADDR_VAR 0 24
122396: PUSH
122397: LD_INT 0
122399: ST_TO_ADDR
// f_attack_depot := false ;
122400: LD_ADDR_VAR 0 25
122404: PUSH
122405: LD_INT 0
122407: ST_TO_ADDR
// f_crawl := false ;
122408: LD_ADDR_VAR 0 26
122412: PUSH
122413: LD_INT 0
122415: ST_TO_ADDR
// end ; if f_heal then
122416: LD_VAR 0 23
122420: IFFALSE 122447
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
122422: LD_ADDR_VAR 0 31
122426: PUSH
122427: LD_VAR 0 4
122431: PPUSH
122432: LD_INT 25
122434: PUSH
122435: LD_INT 4
122437: PUSH
122438: EMPTY
122439: LIST
122440: LIST
122441: PPUSH
122442: CALL_OW 72
122446: ST_TO_ADDR
// if f_repair then
122447: LD_VAR 0 22
122451: IFFALSE 122478
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
122453: LD_ADDR_VAR 0 33
122457: PUSH
122458: LD_VAR 0 4
122462: PPUSH
122463: LD_INT 25
122465: PUSH
122466: LD_INT 3
122468: PUSH
122469: EMPTY
122470: LIST
122471: LIST
122472: PPUSH
122473: CALL_OW 72
122477: ST_TO_ADDR
// units_path := [ ] ;
122478: LD_ADDR_VAR 0 16
122482: PUSH
122483: EMPTY
122484: ST_TO_ADDR
// for i = 1 to group do
122485: LD_ADDR_VAR 0 7
122489: PUSH
122490: DOUBLE
122491: LD_INT 1
122493: DEC
122494: ST_TO_ADDR
122495: LD_VAR 0 4
122499: PUSH
122500: FOR_TO
122501: IFFALSE 122530
// units_path := Replace ( units_path , i , path ) ;
122503: LD_ADDR_VAR 0 16
122507: PUSH
122508: LD_VAR 0 16
122512: PPUSH
122513: LD_VAR 0 7
122517: PPUSH
122518: LD_VAR 0 5
122522: PPUSH
122523: CALL_OW 1
122527: ST_TO_ADDR
122528: GO 122500
122530: POP
122531: POP
// repeat for i = group downto 1 do
122532: LD_ADDR_VAR 0 7
122536: PUSH
122537: DOUBLE
122538: LD_VAR 0 4
122542: INC
122543: ST_TO_ADDR
122544: LD_INT 1
122546: PUSH
122547: FOR_DOWNTO
122548: IFFALSE 126670
// begin wait ( 5 ) ;
122550: LD_INT 5
122552: PPUSH
122553: CALL_OW 67
// tmp := [ ] ;
122557: LD_ADDR_VAR 0 14
122561: PUSH
122562: EMPTY
122563: ST_TO_ADDR
// attacking := false ;
122564: LD_ADDR_VAR 0 29
122568: PUSH
122569: LD_INT 0
122571: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
122572: LD_VAR 0 4
122576: PUSH
122577: LD_VAR 0 7
122581: ARRAY
122582: PPUSH
122583: CALL_OW 301
122587: PUSH
122588: LD_VAR 0 4
122592: PUSH
122593: LD_VAR 0 7
122597: ARRAY
122598: NOT
122599: OR
122600: IFFALSE 122709
// begin if GetType ( group [ i ] ) = unit_human then
122602: LD_VAR 0 4
122606: PUSH
122607: LD_VAR 0 7
122611: ARRAY
122612: PPUSH
122613: CALL_OW 247
122617: PUSH
122618: LD_INT 1
122620: EQUAL
122621: IFFALSE 122667
// begin to_heal := to_heal diff group [ i ] ;
122623: LD_ADDR_VAR 0 30
122627: PUSH
122628: LD_VAR 0 30
122632: PUSH
122633: LD_VAR 0 4
122637: PUSH
122638: LD_VAR 0 7
122642: ARRAY
122643: DIFF
122644: ST_TO_ADDR
// healers := healers diff group [ i ] ;
122645: LD_ADDR_VAR 0 31
122649: PUSH
122650: LD_VAR 0 31
122654: PUSH
122655: LD_VAR 0 4
122659: PUSH
122660: LD_VAR 0 7
122664: ARRAY
122665: DIFF
122666: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
122667: LD_ADDR_VAR 0 4
122671: PUSH
122672: LD_VAR 0 4
122676: PPUSH
122677: LD_VAR 0 7
122681: PPUSH
122682: CALL_OW 3
122686: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
122687: LD_ADDR_VAR 0 16
122691: PUSH
122692: LD_VAR 0 16
122696: PPUSH
122697: LD_VAR 0 7
122701: PPUSH
122702: CALL_OW 3
122706: ST_TO_ADDR
// continue ;
122707: GO 122547
// end ; if f_repair then
122709: LD_VAR 0 22
122713: IFFALSE 123202
// begin if GetType ( group [ i ] ) = unit_vehicle then
122715: LD_VAR 0 4
122719: PUSH
122720: LD_VAR 0 7
122724: ARRAY
122725: PPUSH
122726: CALL_OW 247
122730: PUSH
122731: LD_INT 2
122733: EQUAL
122734: IFFALSE 122924
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
122736: LD_VAR 0 4
122740: PUSH
122741: LD_VAR 0 7
122745: ARRAY
122746: PPUSH
122747: CALL_OW 256
122751: PUSH
122752: LD_INT 700
122754: LESS
122755: PUSH
122756: LD_VAR 0 4
122760: PUSH
122761: LD_VAR 0 7
122765: ARRAY
122766: PUSH
122767: LD_VAR 0 32
122771: IN
122772: NOT
122773: AND
122774: IFFALSE 122798
// to_repair := to_repair union group [ i ] ;
122776: LD_ADDR_VAR 0 32
122780: PUSH
122781: LD_VAR 0 32
122785: PUSH
122786: LD_VAR 0 4
122790: PUSH
122791: LD_VAR 0 7
122795: ARRAY
122796: UNION
122797: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
122798: LD_VAR 0 4
122802: PUSH
122803: LD_VAR 0 7
122807: ARRAY
122808: PPUSH
122809: CALL_OW 256
122813: PUSH
122814: LD_INT 1000
122816: EQUAL
122817: PUSH
122818: LD_VAR 0 4
122822: PUSH
122823: LD_VAR 0 7
122827: ARRAY
122828: PUSH
122829: LD_VAR 0 32
122833: IN
122834: AND
122835: IFFALSE 122859
// to_repair := to_repair diff group [ i ] ;
122837: LD_ADDR_VAR 0 32
122841: PUSH
122842: LD_VAR 0 32
122846: PUSH
122847: LD_VAR 0 4
122851: PUSH
122852: LD_VAR 0 7
122856: ARRAY
122857: DIFF
122858: ST_TO_ADDR
// if group [ i ] in to_repair then
122859: LD_VAR 0 4
122863: PUSH
122864: LD_VAR 0 7
122868: ARRAY
122869: PUSH
122870: LD_VAR 0 32
122874: IN
122875: IFFALSE 122922
// begin if not IsInArea ( group [ i ] , f_repair ) then
122877: LD_VAR 0 4
122881: PUSH
122882: LD_VAR 0 7
122886: ARRAY
122887: PPUSH
122888: LD_VAR 0 22
122892: PPUSH
122893: CALL_OW 308
122897: NOT
122898: IFFALSE 122920
// ComMoveToArea ( group [ i ] , f_repair ) ;
122900: LD_VAR 0 4
122904: PUSH
122905: LD_VAR 0 7
122909: ARRAY
122910: PPUSH
122911: LD_VAR 0 22
122915: PPUSH
122916: CALL_OW 113
// continue ;
122920: GO 122547
// end ; end else
122922: GO 123202
// if group [ i ] in repairs then
122924: LD_VAR 0 4
122928: PUSH
122929: LD_VAR 0 7
122933: ARRAY
122934: PUSH
122935: LD_VAR 0 33
122939: IN
122940: IFFALSE 123202
// begin if IsInUnit ( group [ i ] ) then
122942: LD_VAR 0 4
122946: PUSH
122947: LD_VAR 0 7
122951: ARRAY
122952: PPUSH
122953: CALL_OW 310
122957: IFFALSE 123025
// begin z := IsInUnit ( group [ i ] ) ;
122959: LD_ADDR_VAR 0 13
122963: PUSH
122964: LD_VAR 0 4
122968: PUSH
122969: LD_VAR 0 7
122973: ARRAY
122974: PPUSH
122975: CALL_OW 310
122979: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
122980: LD_VAR 0 13
122984: PUSH
122985: LD_VAR 0 32
122989: IN
122990: PUSH
122991: LD_VAR 0 13
122995: PPUSH
122996: LD_VAR 0 22
123000: PPUSH
123001: CALL_OW 308
123005: AND
123006: IFFALSE 123023
// ComExitVehicle ( group [ i ] ) ;
123008: LD_VAR 0 4
123012: PUSH
123013: LD_VAR 0 7
123017: ARRAY
123018: PPUSH
123019: CALL_OW 121
// end else
123023: GO 123202
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
123025: LD_ADDR_VAR 0 13
123029: PUSH
123030: LD_VAR 0 4
123034: PPUSH
123035: LD_INT 95
123037: PUSH
123038: LD_VAR 0 22
123042: PUSH
123043: EMPTY
123044: LIST
123045: LIST
123046: PUSH
123047: LD_INT 58
123049: PUSH
123050: EMPTY
123051: LIST
123052: PUSH
123053: EMPTY
123054: LIST
123055: LIST
123056: PPUSH
123057: CALL_OW 72
123061: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
123062: LD_VAR 0 4
123066: PUSH
123067: LD_VAR 0 7
123071: ARRAY
123072: PPUSH
123073: CALL_OW 314
123077: NOT
123078: IFFALSE 123200
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
123080: LD_ADDR_VAR 0 10
123084: PUSH
123085: LD_VAR 0 13
123089: PPUSH
123090: LD_VAR 0 4
123094: PUSH
123095: LD_VAR 0 7
123099: ARRAY
123100: PPUSH
123101: CALL_OW 74
123105: ST_TO_ADDR
// if not x then
123106: LD_VAR 0 10
123110: NOT
123111: IFFALSE 123115
// continue ;
123113: GO 122547
// if GetLives ( x ) < 1000 then
123115: LD_VAR 0 10
123119: PPUSH
123120: CALL_OW 256
123124: PUSH
123125: LD_INT 1000
123127: LESS
123128: IFFALSE 123152
// ComRepairVehicle ( group [ i ] , x ) else
123130: LD_VAR 0 4
123134: PUSH
123135: LD_VAR 0 7
123139: ARRAY
123140: PPUSH
123141: LD_VAR 0 10
123145: PPUSH
123146: CALL_OW 129
123150: GO 123200
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
123152: LD_VAR 0 23
123156: PUSH
123157: LD_VAR 0 4
123161: PUSH
123162: LD_VAR 0 7
123166: ARRAY
123167: PPUSH
123168: CALL_OW 256
123172: PUSH
123173: LD_INT 1000
123175: LESS
123176: AND
123177: NOT
123178: IFFALSE 123200
// ComEnterUnit ( group [ i ] , x ) ;
123180: LD_VAR 0 4
123184: PUSH
123185: LD_VAR 0 7
123189: ARRAY
123190: PPUSH
123191: LD_VAR 0 10
123195: PPUSH
123196: CALL_OW 120
// end ; continue ;
123200: GO 122547
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
123202: LD_VAR 0 23
123206: PUSH
123207: LD_VAR 0 4
123211: PUSH
123212: LD_VAR 0 7
123216: ARRAY
123217: PPUSH
123218: CALL_OW 247
123222: PUSH
123223: LD_INT 1
123225: EQUAL
123226: AND
123227: IFFALSE 123705
// begin if group [ i ] in healers then
123229: LD_VAR 0 4
123233: PUSH
123234: LD_VAR 0 7
123238: ARRAY
123239: PUSH
123240: LD_VAR 0 31
123244: IN
123245: IFFALSE 123518
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
123247: LD_VAR 0 4
123251: PUSH
123252: LD_VAR 0 7
123256: ARRAY
123257: PPUSH
123258: LD_VAR 0 23
123262: PPUSH
123263: CALL_OW 308
123267: NOT
123268: PUSH
123269: LD_VAR 0 4
123273: PUSH
123274: LD_VAR 0 7
123278: ARRAY
123279: PPUSH
123280: CALL_OW 314
123284: NOT
123285: AND
123286: IFFALSE 123310
// ComMoveToArea ( group [ i ] , f_heal ) else
123288: LD_VAR 0 4
123292: PUSH
123293: LD_VAR 0 7
123297: ARRAY
123298: PPUSH
123299: LD_VAR 0 23
123303: PPUSH
123304: CALL_OW 113
123308: GO 123516
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
123310: LD_VAR 0 4
123314: PUSH
123315: LD_VAR 0 7
123319: ARRAY
123320: PPUSH
123321: CALL 99688 0 1
123325: PPUSH
123326: CALL_OW 256
123330: PUSH
123331: LD_INT 1000
123333: EQUAL
123334: IFFALSE 123353
// ComStop ( group [ i ] ) else
123336: LD_VAR 0 4
123340: PUSH
123341: LD_VAR 0 7
123345: ARRAY
123346: PPUSH
123347: CALL_OW 141
123351: GO 123516
// if not HasTask ( group [ i ] ) and to_heal then
123353: LD_VAR 0 4
123357: PUSH
123358: LD_VAR 0 7
123362: ARRAY
123363: PPUSH
123364: CALL_OW 314
123368: NOT
123369: PUSH
123370: LD_VAR 0 30
123374: AND
123375: IFFALSE 123516
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
123377: LD_ADDR_VAR 0 13
123381: PUSH
123382: LD_VAR 0 30
123386: PPUSH
123387: LD_INT 3
123389: PUSH
123390: LD_INT 54
123392: PUSH
123393: EMPTY
123394: LIST
123395: PUSH
123396: EMPTY
123397: LIST
123398: LIST
123399: PPUSH
123400: CALL_OW 72
123404: PPUSH
123405: LD_VAR 0 4
123409: PUSH
123410: LD_VAR 0 7
123414: ARRAY
123415: PPUSH
123416: CALL_OW 74
123420: ST_TO_ADDR
// if z then
123421: LD_VAR 0 13
123425: IFFALSE 123516
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
123427: LD_INT 91
123429: PUSH
123430: LD_VAR 0 13
123434: PUSH
123435: LD_INT 10
123437: PUSH
123438: EMPTY
123439: LIST
123440: LIST
123441: LIST
123442: PUSH
123443: LD_INT 81
123445: PUSH
123446: LD_VAR 0 13
123450: PPUSH
123451: CALL_OW 255
123455: PUSH
123456: EMPTY
123457: LIST
123458: LIST
123459: PUSH
123460: EMPTY
123461: LIST
123462: LIST
123463: PPUSH
123464: CALL_OW 69
123468: PUSH
123469: LD_INT 0
123471: EQUAL
123472: IFFALSE 123496
// ComHeal ( group [ i ] , z ) else
123474: LD_VAR 0 4
123478: PUSH
123479: LD_VAR 0 7
123483: ARRAY
123484: PPUSH
123485: LD_VAR 0 13
123489: PPUSH
123490: CALL_OW 128
123494: GO 123516
// ComMoveToArea ( group [ i ] , f_heal ) ;
123496: LD_VAR 0 4
123500: PUSH
123501: LD_VAR 0 7
123505: ARRAY
123506: PPUSH
123507: LD_VAR 0 23
123511: PPUSH
123512: CALL_OW 113
// end ; continue ;
123516: GO 122547
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
123518: LD_VAR 0 4
123522: PUSH
123523: LD_VAR 0 7
123527: ARRAY
123528: PPUSH
123529: CALL_OW 256
123533: PUSH
123534: LD_INT 700
123536: LESS
123537: PUSH
123538: LD_VAR 0 4
123542: PUSH
123543: LD_VAR 0 7
123547: ARRAY
123548: PUSH
123549: LD_VAR 0 30
123553: IN
123554: NOT
123555: AND
123556: IFFALSE 123580
// to_heal := to_heal union group [ i ] ;
123558: LD_ADDR_VAR 0 30
123562: PUSH
123563: LD_VAR 0 30
123567: PUSH
123568: LD_VAR 0 4
123572: PUSH
123573: LD_VAR 0 7
123577: ARRAY
123578: UNION
123579: ST_TO_ADDR
// if group [ i ] in to_heal then
123580: LD_VAR 0 4
123584: PUSH
123585: LD_VAR 0 7
123589: ARRAY
123590: PUSH
123591: LD_VAR 0 30
123595: IN
123596: IFFALSE 123705
// begin if GetLives ( group [ i ] ) = 1000 then
123598: LD_VAR 0 4
123602: PUSH
123603: LD_VAR 0 7
123607: ARRAY
123608: PPUSH
123609: CALL_OW 256
123613: PUSH
123614: LD_INT 1000
123616: EQUAL
123617: IFFALSE 123643
// to_heal := to_heal diff group [ i ] else
123619: LD_ADDR_VAR 0 30
123623: PUSH
123624: LD_VAR 0 30
123628: PUSH
123629: LD_VAR 0 4
123633: PUSH
123634: LD_VAR 0 7
123638: ARRAY
123639: DIFF
123640: ST_TO_ADDR
123641: GO 123705
// begin if not IsInArea ( group [ i ] , to_heal ) then
123643: LD_VAR 0 4
123647: PUSH
123648: LD_VAR 0 7
123652: ARRAY
123653: PPUSH
123654: LD_VAR 0 30
123658: PPUSH
123659: CALL_OW 308
123663: NOT
123664: IFFALSE 123688
// ComMoveToArea ( group [ i ] , f_heal ) else
123666: LD_VAR 0 4
123670: PUSH
123671: LD_VAR 0 7
123675: ARRAY
123676: PPUSH
123677: LD_VAR 0 23
123681: PPUSH
123682: CALL_OW 113
123686: GO 123703
// ComHold ( group [ i ] ) ;
123688: LD_VAR 0 4
123692: PUSH
123693: LD_VAR 0 7
123697: ARRAY
123698: PPUSH
123699: CALL_OW 140
// continue ;
123703: GO 122547
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
123705: LD_VAR 0 4
123709: PUSH
123710: LD_VAR 0 7
123714: ARRAY
123715: PPUSH
123716: LD_INT 10
123718: PPUSH
123719: CALL 98108 0 2
123723: NOT
123724: PUSH
123725: LD_VAR 0 16
123729: PUSH
123730: LD_VAR 0 7
123734: ARRAY
123735: PUSH
123736: EMPTY
123737: EQUAL
123738: NOT
123739: AND
123740: IFFALSE 124006
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
123742: LD_VAR 0 4
123746: PUSH
123747: LD_VAR 0 7
123751: ARRAY
123752: PPUSH
123753: CALL_OW 262
123757: PUSH
123758: LD_INT 1
123760: PUSH
123761: LD_INT 2
123763: PUSH
123764: EMPTY
123765: LIST
123766: LIST
123767: IN
123768: IFFALSE 123809
// if GetFuel ( group [ i ] ) < 10 then
123770: LD_VAR 0 4
123774: PUSH
123775: LD_VAR 0 7
123779: ARRAY
123780: PPUSH
123781: CALL_OW 261
123785: PUSH
123786: LD_INT 10
123788: LESS
123789: IFFALSE 123809
// SetFuel ( group [ i ] , 12 ) ;
123791: LD_VAR 0 4
123795: PUSH
123796: LD_VAR 0 7
123800: ARRAY
123801: PPUSH
123802: LD_INT 12
123804: PPUSH
123805: CALL_OW 240
// if units_path [ i ] then
123809: LD_VAR 0 16
123813: PUSH
123814: LD_VAR 0 7
123818: ARRAY
123819: IFFALSE 124004
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
123821: LD_VAR 0 4
123825: PUSH
123826: LD_VAR 0 7
123830: ARRAY
123831: PPUSH
123832: LD_VAR 0 16
123836: PUSH
123837: LD_VAR 0 7
123841: ARRAY
123842: PUSH
123843: LD_INT 1
123845: ARRAY
123846: PUSH
123847: LD_INT 1
123849: ARRAY
123850: PPUSH
123851: LD_VAR 0 16
123855: PUSH
123856: LD_VAR 0 7
123860: ARRAY
123861: PUSH
123862: LD_INT 1
123864: ARRAY
123865: PUSH
123866: LD_INT 2
123868: ARRAY
123869: PPUSH
123870: CALL_OW 297
123874: PUSH
123875: LD_INT 6
123877: GREATER
123878: IFFALSE 123953
// begin if not HasTask ( group [ i ] ) then
123880: LD_VAR 0 4
123884: PUSH
123885: LD_VAR 0 7
123889: ARRAY
123890: PPUSH
123891: CALL_OW 314
123895: NOT
123896: IFFALSE 123951
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
123898: LD_VAR 0 4
123902: PUSH
123903: LD_VAR 0 7
123907: ARRAY
123908: PPUSH
123909: LD_VAR 0 16
123913: PUSH
123914: LD_VAR 0 7
123918: ARRAY
123919: PUSH
123920: LD_INT 1
123922: ARRAY
123923: PUSH
123924: LD_INT 1
123926: ARRAY
123927: PPUSH
123928: LD_VAR 0 16
123932: PUSH
123933: LD_VAR 0 7
123937: ARRAY
123938: PUSH
123939: LD_INT 1
123941: ARRAY
123942: PUSH
123943: LD_INT 2
123945: ARRAY
123946: PPUSH
123947: CALL_OW 114
// end else
123951: GO 124004
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
123953: LD_ADDR_VAR 0 15
123957: PUSH
123958: LD_VAR 0 16
123962: PUSH
123963: LD_VAR 0 7
123967: ARRAY
123968: PPUSH
123969: LD_INT 1
123971: PPUSH
123972: CALL_OW 3
123976: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
123977: LD_ADDR_VAR 0 16
123981: PUSH
123982: LD_VAR 0 16
123986: PPUSH
123987: LD_VAR 0 7
123991: PPUSH
123992: LD_VAR 0 15
123996: PPUSH
123997: CALL_OW 1
124001: ST_TO_ADDR
// continue ;
124002: GO 122547
// end ; end ; end else
124004: GO 126668
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
124006: LD_ADDR_VAR 0 14
124010: PUSH
124011: LD_INT 81
124013: PUSH
124014: LD_VAR 0 4
124018: PUSH
124019: LD_VAR 0 7
124023: ARRAY
124024: PPUSH
124025: CALL_OW 255
124029: PUSH
124030: EMPTY
124031: LIST
124032: LIST
124033: PPUSH
124034: CALL_OW 69
124038: ST_TO_ADDR
// if not tmp then
124039: LD_VAR 0 14
124043: NOT
124044: IFFALSE 124048
// continue ;
124046: GO 122547
// if f_ignore_area then
124048: LD_VAR 0 17
124052: IFFALSE 124140
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
124054: LD_ADDR_VAR 0 15
124058: PUSH
124059: LD_VAR 0 14
124063: PPUSH
124064: LD_INT 3
124066: PUSH
124067: LD_INT 92
124069: PUSH
124070: LD_VAR 0 17
124074: PUSH
124075: LD_INT 1
124077: ARRAY
124078: PUSH
124079: LD_VAR 0 17
124083: PUSH
124084: LD_INT 2
124086: ARRAY
124087: PUSH
124088: LD_VAR 0 17
124092: PUSH
124093: LD_INT 3
124095: ARRAY
124096: PUSH
124097: EMPTY
124098: LIST
124099: LIST
124100: LIST
124101: LIST
124102: PUSH
124103: EMPTY
124104: LIST
124105: LIST
124106: PPUSH
124107: CALL_OW 72
124111: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
124112: LD_VAR 0 14
124116: PUSH
124117: LD_VAR 0 15
124121: DIFF
124122: IFFALSE 124140
// tmp := tmp diff tmp2 ;
124124: LD_ADDR_VAR 0 14
124128: PUSH
124129: LD_VAR 0 14
124133: PUSH
124134: LD_VAR 0 15
124138: DIFF
124139: ST_TO_ADDR
// end ; if not f_murder then
124140: LD_VAR 0 20
124144: NOT
124145: IFFALSE 124203
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
124147: LD_ADDR_VAR 0 15
124151: PUSH
124152: LD_VAR 0 14
124156: PPUSH
124157: LD_INT 3
124159: PUSH
124160: LD_INT 50
124162: PUSH
124163: EMPTY
124164: LIST
124165: PUSH
124166: EMPTY
124167: LIST
124168: LIST
124169: PPUSH
124170: CALL_OW 72
124174: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
124175: LD_VAR 0 14
124179: PUSH
124180: LD_VAR 0 15
124184: DIFF
124185: IFFALSE 124203
// tmp := tmp diff tmp2 ;
124187: LD_ADDR_VAR 0 14
124191: PUSH
124192: LD_VAR 0 14
124196: PUSH
124197: LD_VAR 0 15
124201: DIFF
124202: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
124203: LD_ADDR_VAR 0 14
124207: PUSH
124208: LD_VAR 0 4
124212: PUSH
124213: LD_VAR 0 7
124217: ARRAY
124218: PPUSH
124219: LD_VAR 0 14
124223: PPUSH
124224: LD_INT 1
124226: PPUSH
124227: LD_INT 1
124229: PPUSH
124230: CALL 71043 0 4
124234: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
124235: LD_VAR 0 4
124239: PUSH
124240: LD_VAR 0 7
124244: ARRAY
124245: PPUSH
124246: CALL_OW 257
124250: PUSH
124251: LD_INT 1
124253: EQUAL
124254: IFFALSE 124702
// begin if WantPlant ( group [ i ] ) then
124256: LD_VAR 0 4
124260: PUSH
124261: LD_VAR 0 7
124265: ARRAY
124266: PPUSH
124267: CALL 70544 0 1
124271: IFFALSE 124275
// continue ;
124273: GO 122547
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
124275: LD_VAR 0 18
124279: PUSH
124280: LD_VAR 0 4
124284: PUSH
124285: LD_VAR 0 7
124289: ARRAY
124290: PPUSH
124291: CALL_OW 310
124295: NOT
124296: AND
124297: PUSH
124298: LD_VAR 0 14
124302: PUSH
124303: LD_INT 1
124305: ARRAY
124306: PUSH
124307: LD_VAR 0 14
124311: PPUSH
124312: LD_INT 21
124314: PUSH
124315: LD_INT 2
124317: PUSH
124318: EMPTY
124319: LIST
124320: LIST
124321: PUSH
124322: LD_INT 58
124324: PUSH
124325: EMPTY
124326: LIST
124327: PUSH
124328: EMPTY
124329: LIST
124330: LIST
124331: PPUSH
124332: CALL_OW 72
124336: IN
124337: AND
124338: IFFALSE 124374
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
124340: LD_VAR 0 4
124344: PUSH
124345: LD_VAR 0 7
124349: ARRAY
124350: PPUSH
124351: LD_VAR 0 14
124355: PUSH
124356: LD_INT 1
124358: ARRAY
124359: PPUSH
124360: CALL_OW 120
// attacking := true ;
124364: LD_ADDR_VAR 0 29
124368: PUSH
124369: LD_INT 1
124371: ST_TO_ADDR
// continue ;
124372: GO 122547
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
124374: LD_VAR 0 26
124378: PUSH
124379: LD_VAR 0 4
124383: PUSH
124384: LD_VAR 0 7
124388: ARRAY
124389: PPUSH
124390: CALL_OW 257
124394: PUSH
124395: LD_INT 1
124397: EQUAL
124398: AND
124399: PUSH
124400: LD_VAR 0 4
124404: PUSH
124405: LD_VAR 0 7
124409: ARRAY
124410: PPUSH
124411: CALL_OW 256
124415: PUSH
124416: LD_INT 800
124418: LESS
124419: AND
124420: PUSH
124421: LD_VAR 0 4
124425: PUSH
124426: LD_VAR 0 7
124430: ARRAY
124431: PPUSH
124432: CALL_OW 318
124436: NOT
124437: AND
124438: IFFALSE 124455
// ComCrawl ( group [ i ] ) ;
124440: LD_VAR 0 4
124444: PUSH
124445: LD_VAR 0 7
124449: ARRAY
124450: PPUSH
124451: CALL_OW 137
// if f_mines then
124455: LD_VAR 0 21
124459: IFFALSE 124702
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
124461: LD_VAR 0 14
124465: PUSH
124466: LD_INT 1
124468: ARRAY
124469: PPUSH
124470: CALL_OW 247
124474: PUSH
124475: LD_INT 3
124477: EQUAL
124478: PUSH
124479: LD_VAR 0 14
124483: PUSH
124484: LD_INT 1
124486: ARRAY
124487: PUSH
124488: LD_VAR 0 27
124492: IN
124493: NOT
124494: AND
124495: IFFALSE 124702
// begin x := GetX ( tmp [ 1 ] ) ;
124497: LD_ADDR_VAR 0 10
124501: PUSH
124502: LD_VAR 0 14
124506: PUSH
124507: LD_INT 1
124509: ARRAY
124510: PPUSH
124511: CALL_OW 250
124515: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
124516: LD_ADDR_VAR 0 11
124520: PUSH
124521: LD_VAR 0 14
124525: PUSH
124526: LD_INT 1
124528: ARRAY
124529: PPUSH
124530: CALL_OW 251
124534: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
124535: LD_ADDR_VAR 0 12
124539: PUSH
124540: LD_VAR 0 4
124544: PUSH
124545: LD_VAR 0 7
124549: ARRAY
124550: PPUSH
124551: CALL 98193 0 1
124555: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
124556: LD_VAR 0 4
124560: PUSH
124561: LD_VAR 0 7
124565: ARRAY
124566: PPUSH
124567: LD_VAR 0 10
124571: PPUSH
124572: LD_VAR 0 11
124576: PPUSH
124577: LD_VAR 0 14
124581: PUSH
124582: LD_INT 1
124584: ARRAY
124585: PPUSH
124586: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
124590: LD_VAR 0 4
124594: PUSH
124595: LD_VAR 0 7
124599: ARRAY
124600: PPUSH
124601: LD_VAR 0 10
124605: PPUSH
124606: LD_VAR 0 12
124610: PPUSH
124611: LD_INT 7
124613: PPUSH
124614: CALL_OW 272
124618: PPUSH
124619: LD_VAR 0 11
124623: PPUSH
124624: LD_VAR 0 12
124628: PPUSH
124629: LD_INT 7
124631: PPUSH
124632: CALL_OW 273
124636: PPUSH
124637: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
124641: LD_VAR 0 4
124645: PUSH
124646: LD_VAR 0 7
124650: ARRAY
124651: PPUSH
124652: LD_INT 71
124654: PPUSH
124655: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
124659: LD_ADDR_VAR 0 27
124663: PUSH
124664: LD_VAR 0 27
124668: PPUSH
124669: LD_VAR 0 27
124673: PUSH
124674: LD_INT 1
124676: PLUS
124677: PPUSH
124678: LD_VAR 0 14
124682: PUSH
124683: LD_INT 1
124685: ARRAY
124686: PPUSH
124687: CALL_OW 1
124691: ST_TO_ADDR
// attacking := true ;
124692: LD_ADDR_VAR 0 29
124696: PUSH
124697: LD_INT 1
124699: ST_TO_ADDR
// continue ;
124700: GO 122547
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
124702: LD_VAR 0 4
124706: PUSH
124707: LD_VAR 0 7
124711: ARRAY
124712: PPUSH
124713: CALL_OW 257
124717: PUSH
124718: LD_INT 17
124720: EQUAL
124721: PUSH
124722: LD_VAR 0 4
124726: PUSH
124727: LD_VAR 0 7
124731: ARRAY
124732: PPUSH
124733: CALL_OW 110
124737: PUSH
124738: LD_INT 71
124740: EQUAL
124741: NOT
124742: AND
124743: IFFALSE 124889
// begin attacking := false ;
124745: LD_ADDR_VAR 0 29
124749: PUSH
124750: LD_INT 0
124752: ST_TO_ADDR
// k := 5 ;
124753: LD_ADDR_VAR 0 9
124757: PUSH
124758: LD_INT 5
124760: ST_TO_ADDR
// if tmp < k then
124761: LD_VAR 0 14
124765: PUSH
124766: LD_VAR 0 9
124770: LESS
124771: IFFALSE 124783
// k := tmp ;
124773: LD_ADDR_VAR 0 9
124777: PUSH
124778: LD_VAR 0 14
124782: ST_TO_ADDR
// for j = 1 to k do
124783: LD_ADDR_VAR 0 8
124787: PUSH
124788: DOUBLE
124789: LD_INT 1
124791: DEC
124792: ST_TO_ADDR
124793: LD_VAR 0 9
124797: PUSH
124798: FOR_TO
124799: IFFALSE 124887
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
124801: LD_VAR 0 14
124805: PUSH
124806: LD_VAR 0 8
124810: ARRAY
124811: PUSH
124812: LD_VAR 0 14
124816: PPUSH
124817: LD_INT 58
124819: PUSH
124820: EMPTY
124821: LIST
124822: PPUSH
124823: CALL_OW 72
124827: IN
124828: NOT
124829: IFFALSE 124885
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
124831: LD_VAR 0 4
124835: PUSH
124836: LD_VAR 0 7
124840: ARRAY
124841: PPUSH
124842: LD_VAR 0 14
124846: PUSH
124847: LD_VAR 0 8
124851: ARRAY
124852: PPUSH
124853: CALL_OW 115
// attacking := true ;
124857: LD_ADDR_VAR 0 29
124861: PUSH
124862: LD_INT 1
124864: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
124865: LD_VAR 0 4
124869: PUSH
124870: LD_VAR 0 7
124874: ARRAY
124875: PPUSH
124876: LD_INT 71
124878: PPUSH
124879: CALL_OW 109
// continue ;
124883: GO 124798
// end ; end ;
124885: GO 124798
124887: POP
124888: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
124889: LD_VAR 0 4
124893: PUSH
124894: LD_VAR 0 7
124898: ARRAY
124899: PPUSH
124900: CALL_OW 257
124904: PUSH
124905: LD_INT 8
124907: EQUAL
124908: PUSH
124909: LD_VAR 0 4
124913: PUSH
124914: LD_VAR 0 7
124918: ARRAY
124919: PPUSH
124920: CALL_OW 264
124924: PUSH
124925: LD_INT 28
124927: PUSH
124928: LD_INT 45
124930: PUSH
124931: LD_INT 7
124933: PUSH
124934: LD_INT 47
124936: PUSH
124937: EMPTY
124938: LIST
124939: LIST
124940: LIST
124941: LIST
124942: IN
124943: OR
124944: IFFALSE 125200
// begin attacking := false ;
124946: LD_ADDR_VAR 0 29
124950: PUSH
124951: LD_INT 0
124953: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
124954: LD_VAR 0 14
124958: PUSH
124959: LD_INT 1
124961: ARRAY
124962: PPUSH
124963: CALL_OW 266
124967: PUSH
124968: LD_INT 32
124970: PUSH
124971: LD_INT 31
124973: PUSH
124974: LD_INT 33
124976: PUSH
124977: LD_INT 4
124979: PUSH
124980: LD_INT 5
124982: PUSH
124983: EMPTY
124984: LIST
124985: LIST
124986: LIST
124987: LIST
124988: LIST
124989: IN
124990: IFFALSE 125176
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
124992: LD_ADDR_VAR 0 9
124996: PUSH
124997: LD_VAR 0 14
125001: PUSH
125002: LD_INT 1
125004: ARRAY
125005: PPUSH
125006: CALL_OW 266
125010: PPUSH
125011: LD_VAR 0 14
125015: PUSH
125016: LD_INT 1
125018: ARRAY
125019: PPUSH
125020: CALL_OW 250
125024: PPUSH
125025: LD_VAR 0 14
125029: PUSH
125030: LD_INT 1
125032: ARRAY
125033: PPUSH
125034: CALL_OW 251
125038: PPUSH
125039: LD_VAR 0 14
125043: PUSH
125044: LD_INT 1
125046: ARRAY
125047: PPUSH
125048: CALL_OW 254
125052: PPUSH
125053: LD_VAR 0 14
125057: PUSH
125058: LD_INT 1
125060: ARRAY
125061: PPUSH
125062: CALL_OW 248
125066: PPUSH
125067: LD_INT 0
125069: PPUSH
125070: CALL 79563 0 6
125074: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
125075: LD_ADDR_VAR 0 8
125079: PUSH
125080: LD_VAR 0 4
125084: PUSH
125085: LD_VAR 0 7
125089: ARRAY
125090: PPUSH
125091: LD_VAR 0 9
125095: PPUSH
125096: CALL 98233 0 2
125100: ST_TO_ADDR
// if j then
125101: LD_VAR 0 8
125105: IFFALSE 125174
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
125107: LD_VAR 0 8
125111: PUSH
125112: LD_INT 1
125114: ARRAY
125115: PPUSH
125116: LD_VAR 0 8
125120: PUSH
125121: LD_INT 2
125123: ARRAY
125124: PPUSH
125125: CALL_OW 488
125129: IFFALSE 125174
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
125131: LD_VAR 0 4
125135: PUSH
125136: LD_VAR 0 7
125140: ARRAY
125141: PPUSH
125142: LD_VAR 0 8
125146: PUSH
125147: LD_INT 1
125149: ARRAY
125150: PPUSH
125151: LD_VAR 0 8
125155: PUSH
125156: LD_INT 2
125158: ARRAY
125159: PPUSH
125160: CALL_OW 116
// attacking := true ;
125164: LD_ADDR_VAR 0 29
125168: PUSH
125169: LD_INT 1
125171: ST_TO_ADDR
// continue ;
125172: GO 122547
// end ; end else
125174: GO 125200
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
125176: LD_VAR 0 4
125180: PUSH
125181: LD_VAR 0 7
125185: ARRAY
125186: PPUSH
125187: LD_VAR 0 14
125191: PUSH
125192: LD_INT 1
125194: ARRAY
125195: PPUSH
125196: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
125200: LD_VAR 0 4
125204: PUSH
125205: LD_VAR 0 7
125209: ARRAY
125210: PPUSH
125211: CALL_OW 265
125215: PUSH
125216: LD_INT 11
125218: EQUAL
125219: IFFALSE 125497
// begin k := 10 ;
125221: LD_ADDR_VAR 0 9
125225: PUSH
125226: LD_INT 10
125228: ST_TO_ADDR
// x := 0 ;
125229: LD_ADDR_VAR 0 10
125233: PUSH
125234: LD_INT 0
125236: ST_TO_ADDR
// if tmp < k then
125237: LD_VAR 0 14
125241: PUSH
125242: LD_VAR 0 9
125246: LESS
125247: IFFALSE 125259
// k := tmp ;
125249: LD_ADDR_VAR 0 9
125253: PUSH
125254: LD_VAR 0 14
125258: ST_TO_ADDR
// for j = k downto 1 do
125259: LD_ADDR_VAR 0 8
125263: PUSH
125264: DOUBLE
125265: LD_VAR 0 9
125269: INC
125270: ST_TO_ADDR
125271: LD_INT 1
125273: PUSH
125274: FOR_DOWNTO
125275: IFFALSE 125350
// begin if GetType ( tmp [ j ] ) = unit_human then
125277: LD_VAR 0 14
125281: PUSH
125282: LD_VAR 0 8
125286: ARRAY
125287: PPUSH
125288: CALL_OW 247
125292: PUSH
125293: LD_INT 1
125295: EQUAL
125296: IFFALSE 125348
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
125298: LD_VAR 0 4
125302: PUSH
125303: LD_VAR 0 7
125307: ARRAY
125308: PPUSH
125309: LD_VAR 0 14
125313: PUSH
125314: LD_VAR 0 8
125318: ARRAY
125319: PPUSH
125320: CALL 98504 0 2
// x := tmp [ j ] ;
125324: LD_ADDR_VAR 0 10
125328: PUSH
125329: LD_VAR 0 14
125333: PUSH
125334: LD_VAR 0 8
125338: ARRAY
125339: ST_TO_ADDR
// attacking := true ;
125340: LD_ADDR_VAR 0 29
125344: PUSH
125345: LD_INT 1
125347: ST_TO_ADDR
// end ; end ;
125348: GO 125274
125350: POP
125351: POP
// if not x then
125352: LD_VAR 0 10
125356: NOT
125357: IFFALSE 125497
// begin attacking := true ;
125359: LD_ADDR_VAR 0 29
125363: PUSH
125364: LD_INT 1
125366: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
125367: LD_VAR 0 4
125371: PUSH
125372: LD_VAR 0 7
125376: ARRAY
125377: PPUSH
125378: CALL_OW 250
125382: PPUSH
125383: LD_VAR 0 4
125387: PUSH
125388: LD_VAR 0 7
125392: ARRAY
125393: PPUSH
125394: CALL_OW 251
125398: PPUSH
125399: CALL_OW 546
125403: PUSH
125404: LD_INT 2
125406: ARRAY
125407: PUSH
125408: LD_VAR 0 14
125412: PUSH
125413: LD_INT 1
125415: ARRAY
125416: PPUSH
125417: CALL_OW 250
125421: PPUSH
125422: LD_VAR 0 14
125426: PUSH
125427: LD_INT 1
125429: ARRAY
125430: PPUSH
125431: CALL_OW 251
125435: PPUSH
125436: CALL_OW 546
125440: PUSH
125441: LD_INT 2
125443: ARRAY
125444: EQUAL
125445: IFFALSE 125473
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
125447: LD_VAR 0 4
125451: PUSH
125452: LD_VAR 0 7
125456: ARRAY
125457: PPUSH
125458: LD_VAR 0 14
125462: PUSH
125463: LD_INT 1
125465: ARRAY
125466: PPUSH
125467: CALL 98504 0 2
125471: GO 125497
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
125473: LD_VAR 0 4
125477: PUSH
125478: LD_VAR 0 7
125482: ARRAY
125483: PPUSH
125484: LD_VAR 0 14
125488: PUSH
125489: LD_INT 1
125491: ARRAY
125492: PPUSH
125493: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
125497: LD_VAR 0 4
125501: PUSH
125502: LD_VAR 0 7
125506: ARRAY
125507: PPUSH
125508: CALL_OW 264
125512: PUSH
125513: LD_INT 29
125515: EQUAL
125516: IFFALSE 125882
// begin if WantsToAttack ( group [ i ] ) in bombed then
125518: LD_VAR 0 4
125522: PUSH
125523: LD_VAR 0 7
125527: ARRAY
125528: PPUSH
125529: CALL_OW 319
125533: PUSH
125534: LD_VAR 0 28
125538: IN
125539: IFFALSE 125543
// continue ;
125541: GO 122547
// k := 8 ;
125543: LD_ADDR_VAR 0 9
125547: PUSH
125548: LD_INT 8
125550: ST_TO_ADDR
// x := 0 ;
125551: LD_ADDR_VAR 0 10
125555: PUSH
125556: LD_INT 0
125558: ST_TO_ADDR
// if tmp < k then
125559: LD_VAR 0 14
125563: PUSH
125564: LD_VAR 0 9
125568: LESS
125569: IFFALSE 125581
// k := tmp ;
125571: LD_ADDR_VAR 0 9
125575: PUSH
125576: LD_VAR 0 14
125580: ST_TO_ADDR
// for j = 1 to k do
125581: LD_ADDR_VAR 0 8
125585: PUSH
125586: DOUBLE
125587: LD_INT 1
125589: DEC
125590: ST_TO_ADDR
125591: LD_VAR 0 9
125595: PUSH
125596: FOR_TO
125597: IFFALSE 125729
// begin if GetType ( tmp [ j ] ) = unit_building then
125599: LD_VAR 0 14
125603: PUSH
125604: LD_VAR 0 8
125608: ARRAY
125609: PPUSH
125610: CALL_OW 247
125614: PUSH
125615: LD_INT 3
125617: EQUAL
125618: IFFALSE 125727
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
125620: LD_VAR 0 14
125624: PUSH
125625: LD_VAR 0 8
125629: ARRAY
125630: PUSH
125631: LD_VAR 0 28
125635: IN
125636: NOT
125637: PUSH
125638: LD_VAR 0 14
125642: PUSH
125643: LD_VAR 0 8
125647: ARRAY
125648: PPUSH
125649: CALL_OW 313
125653: AND
125654: IFFALSE 125727
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
125656: LD_VAR 0 4
125660: PUSH
125661: LD_VAR 0 7
125665: ARRAY
125666: PPUSH
125667: LD_VAR 0 14
125671: PUSH
125672: LD_VAR 0 8
125676: ARRAY
125677: PPUSH
125678: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
125682: LD_ADDR_VAR 0 28
125686: PUSH
125687: LD_VAR 0 28
125691: PPUSH
125692: LD_VAR 0 28
125696: PUSH
125697: LD_INT 1
125699: PLUS
125700: PPUSH
125701: LD_VAR 0 14
125705: PUSH
125706: LD_VAR 0 8
125710: ARRAY
125711: PPUSH
125712: CALL_OW 1
125716: ST_TO_ADDR
// attacking := true ;
125717: LD_ADDR_VAR 0 29
125721: PUSH
125722: LD_INT 1
125724: ST_TO_ADDR
// break ;
125725: GO 125729
// end ; end ;
125727: GO 125596
125729: POP
125730: POP
// if not attacking and f_attack_depot then
125731: LD_VAR 0 29
125735: NOT
125736: PUSH
125737: LD_VAR 0 25
125741: AND
125742: IFFALSE 125837
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
125744: LD_ADDR_VAR 0 13
125748: PUSH
125749: LD_VAR 0 14
125753: PPUSH
125754: LD_INT 2
125756: PUSH
125757: LD_INT 30
125759: PUSH
125760: LD_INT 0
125762: PUSH
125763: EMPTY
125764: LIST
125765: LIST
125766: PUSH
125767: LD_INT 30
125769: PUSH
125770: LD_INT 1
125772: PUSH
125773: EMPTY
125774: LIST
125775: LIST
125776: PUSH
125777: EMPTY
125778: LIST
125779: LIST
125780: LIST
125781: PPUSH
125782: CALL_OW 72
125786: ST_TO_ADDR
// if z then
125787: LD_VAR 0 13
125791: IFFALSE 125837
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
125793: LD_VAR 0 4
125797: PUSH
125798: LD_VAR 0 7
125802: ARRAY
125803: PPUSH
125804: LD_VAR 0 13
125808: PPUSH
125809: LD_VAR 0 4
125813: PUSH
125814: LD_VAR 0 7
125818: ARRAY
125819: PPUSH
125820: CALL_OW 74
125824: PPUSH
125825: CALL_OW 115
// attacking := true ;
125829: LD_ADDR_VAR 0 29
125833: PUSH
125834: LD_INT 1
125836: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
125837: LD_VAR 0 4
125841: PUSH
125842: LD_VAR 0 7
125846: ARRAY
125847: PPUSH
125848: CALL_OW 256
125852: PUSH
125853: LD_INT 500
125855: LESS
125856: IFFALSE 125882
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
125858: LD_VAR 0 4
125862: PUSH
125863: LD_VAR 0 7
125867: ARRAY
125868: PPUSH
125869: LD_VAR 0 14
125873: PUSH
125874: LD_INT 1
125876: ARRAY
125877: PPUSH
125878: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
125882: LD_VAR 0 4
125886: PUSH
125887: LD_VAR 0 7
125891: ARRAY
125892: PPUSH
125893: CALL_OW 264
125897: PUSH
125898: LD_INT 49
125900: EQUAL
125901: IFFALSE 126022
// begin if not HasTask ( group [ i ] ) then
125903: LD_VAR 0 4
125907: PUSH
125908: LD_VAR 0 7
125912: ARRAY
125913: PPUSH
125914: CALL_OW 314
125918: NOT
125919: IFFALSE 126022
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
125921: LD_ADDR_VAR 0 9
125925: PUSH
125926: LD_INT 81
125928: PUSH
125929: LD_VAR 0 4
125933: PUSH
125934: LD_VAR 0 7
125938: ARRAY
125939: PPUSH
125940: CALL_OW 255
125944: PUSH
125945: EMPTY
125946: LIST
125947: LIST
125948: PPUSH
125949: CALL_OW 69
125953: PPUSH
125954: LD_VAR 0 4
125958: PUSH
125959: LD_VAR 0 7
125963: ARRAY
125964: PPUSH
125965: CALL_OW 74
125969: ST_TO_ADDR
// if k then
125970: LD_VAR 0 9
125974: IFFALSE 126022
// if GetDistUnits ( group [ i ] , k ) > 10 then
125976: LD_VAR 0 4
125980: PUSH
125981: LD_VAR 0 7
125985: ARRAY
125986: PPUSH
125987: LD_VAR 0 9
125991: PPUSH
125992: CALL_OW 296
125996: PUSH
125997: LD_INT 10
125999: GREATER
126000: IFFALSE 126022
// ComMoveUnit ( group [ i ] , k ) ;
126002: LD_VAR 0 4
126006: PUSH
126007: LD_VAR 0 7
126011: ARRAY
126012: PPUSH
126013: LD_VAR 0 9
126017: PPUSH
126018: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
126022: LD_VAR 0 4
126026: PUSH
126027: LD_VAR 0 7
126031: ARRAY
126032: PPUSH
126033: CALL_OW 256
126037: PUSH
126038: LD_INT 250
126040: LESS
126041: PUSH
126042: LD_VAR 0 4
126046: PUSH
126047: LD_VAR 0 7
126051: ARRAY
126052: PUSH
126053: LD_INT 21
126055: PUSH
126056: LD_INT 2
126058: PUSH
126059: EMPTY
126060: LIST
126061: LIST
126062: PUSH
126063: LD_INT 23
126065: PUSH
126066: LD_INT 2
126068: PUSH
126069: EMPTY
126070: LIST
126071: LIST
126072: PUSH
126073: EMPTY
126074: LIST
126075: LIST
126076: PPUSH
126077: CALL_OW 69
126081: IN
126082: AND
126083: IFFALSE 126208
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
126085: LD_ADDR_VAR 0 9
126089: PUSH
126090: LD_OWVAR 3
126094: PUSH
126095: LD_VAR 0 4
126099: PUSH
126100: LD_VAR 0 7
126104: ARRAY
126105: DIFF
126106: PPUSH
126107: LD_VAR 0 4
126111: PUSH
126112: LD_VAR 0 7
126116: ARRAY
126117: PPUSH
126118: CALL_OW 74
126122: ST_TO_ADDR
// if not k then
126123: LD_VAR 0 9
126127: NOT
126128: IFFALSE 126132
// continue ;
126130: GO 122547
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
126132: LD_VAR 0 9
126136: PUSH
126137: LD_INT 81
126139: PUSH
126140: LD_VAR 0 4
126144: PUSH
126145: LD_VAR 0 7
126149: ARRAY
126150: PPUSH
126151: CALL_OW 255
126155: PUSH
126156: EMPTY
126157: LIST
126158: LIST
126159: PPUSH
126160: CALL_OW 69
126164: IN
126165: PUSH
126166: LD_VAR 0 9
126170: PPUSH
126171: LD_VAR 0 4
126175: PUSH
126176: LD_VAR 0 7
126180: ARRAY
126181: PPUSH
126182: CALL_OW 296
126186: PUSH
126187: LD_INT 5
126189: LESS
126190: AND
126191: IFFALSE 126208
// ComAutodestruct ( group [ i ] ) ;
126193: LD_VAR 0 4
126197: PUSH
126198: LD_VAR 0 7
126202: ARRAY
126203: PPUSH
126204: CALL 98402 0 1
// end ; if f_attack_depot then
126208: LD_VAR 0 25
126212: IFFALSE 126324
// begin k := 6 ;
126214: LD_ADDR_VAR 0 9
126218: PUSH
126219: LD_INT 6
126221: ST_TO_ADDR
// if tmp < k then
126222: LD_VAR 0 14
126226: PUSH
126227: LD_VAR 0 9
126231: LESS
126232: IFFALSE 126244
// k := tmp ;
126234: LD_ADDR_VAR 0 9
126238: PUSH
126239: LD_VAR 0 14
126243: ST_TO_ADDR
// for j = 1 to k do
126244: LD_ADDR_VAR 0 8
126248: PUSH
126249: DOUBLE
126250: LD_INT 1
126252: DEC
126253: ST_TO_ADDR
126254: LD_VAR 0 9
126258: PUSH
126259: FOR_TO
126260: IFFALSE 126322
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
126262: LD_VAR 0 8
126266: PPUSH
126267: CALL_OW 266
126271: PUSH
126272: LD_INT 0
126274: PUSH
126275: LD_INT 1
126277: PUSH
126278: EMPTY
126279: LIST
126280: LIST
126281: IN
126282: IFFALSE 126320
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
126284: LD_VAR 0 4
126288: PUSH
126289: LD_VAR 0 7
126293: ARRAY
126294: PPUSH
126295: LD_VAR 0 14
126299: PUSH
126300: LD_VAR 0 8
126304: ARRAY
126305: PPUSH
126306: CALL_OW 115
// attacking := true ;
126310: LD_ADDR_VAR 0 29
126314: PUSH
126315: LD_INT 1
126317: ST_TO_ADDR
// break ;
126318: GO 126322
// end ;
126320: GO 126259
126322: POP
126323: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
126324: LD_VAR 0 4
126328: PUSH
126329: LD_VAR 0 7
126333: ARRAY
126334: PPUSH
126335: CALL_OW 302
126339: PUSH
126340: LD_VAR 0 29
126344: NOT
126345: AND
126346: IFFALSE 126668
// begin if GetTag ( group [ i ] ) = 71 then
126348: LD_VAR 0 4
126352: PUSH
126353: LD_VAR 0 7
126357: ARRAY
126358: PPUSH
126359: CALL_OW 110
126363: PUSH
126364: LD_INT 71
126366: EQUAL
126367: IFFALSE 126408
// begin if HasTask ( group [ i ] ) then
126369: LD_VAR 0 4
126373: PUSH
126374: LD_VAR 0 7
126378: ARRAY
126379: PPUSH
126380: CALL_OW 314
126384: IFFALSE 126390
// continue else
126386: GO 122547
126388: GO 126408
// SetTag ( group [ i ] , 0 ) ;
126390: LD_VAR 0 4
126394: PUSH
126395: LD_VAR 0 7
126399: ARRAY
126400: PPUSH
126401: LD_INT 0
126403: PPUSH
126404: CALL_OW 109
// end ; k := 8 ;
126408: LD_ADDR_VAR 0 9
126412: PUSH
126413: LD_INT 8
126415: ST_TO_ADDR
// x := 0 ;
126416: LD_ADDR_VAR 0 10
126420: PUSH
126421: LD_INT 0
126423: ST_TO_ADDR
// if tmp < k then
126424: LD_VAR 0 14
126428: PUSH
126429: LD_VAR 0 9
126433: LESS
126434: IFFALSE 126446
// k := tmp ;
126436: LD_ADDR_VAR 0 9
126440: PUSH
126441: LD_VAR 0 14
126445: ST_TO_ADDR
// for j = 1 to k do
126446: LD_ADDR_VAR 0 8
126450: PUSH
126451: DOUBLE
126452: LD_INT 1
126454: DEC
126455: ST_TO_ADDR
126456: LD_VAR 0 9
126460: PUSH
126461: FOR_TO
126462: IFFALSE 126560
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
126464: LD_VAR 0 14
126468: PUSH
126469: LD_VAR 0 8
126473: ARRAY
126474: PPUSH
126475: CALL_OW 247
126479: PUSH
126480: LD_INT 1
126482: EQUAL
126483: PUSH
126484: LD_VAR 0 14
126488: PUSH
126489: LD_VAR 0 8
126493: ARRAY
126494: PPUSH
126495: CALL_OW 256
126499: PUSH
126500: LD_INT 250
126502: LESS
126503: PUSH
126504: LD_VAR 0 20
126508: AND
126509: PUSH
126510: LD_VAR 0 20
126514: NOT
126515: PUSH
126516: LD_VAR 0 14
126520: PUSH
126521: LD_VAR 0 8
126525: ARRAY
126526: PPUSH
126527: CALL_OW 256
126531: PUSH
126532: LD_INT 250
126534: GREATEREQUAL
126535: AND
126536: OR
126537: AND
126538: IFFALSE 126558
// begin x := tmp [ j ] ;
126540: LD_ADDR_VAR 0 10
126544: PUSH
126545: LD_VAR 0 14
126549: PUSH
126550: LD_VAR 0 8
126554: ARRAY
126555: ST_TO_ADDR
// break ;
126556: GO 126560
// end ;
126558: GO 126461
126560: POP
126561: POP
// if x then
126562: LD_VAR 0 10
126566: IFFALSE 126590
// ComAttackUnit ( group [ i ] , x ) else
126568: LD_VAR 0 4
126572: PUSH
126573: LD_VAR 0 7
126577: ARRAY
126578: PPUSH
126579: LD_VAR 0 10
126583: PPUSH
126584: CALL_OW 115
126588: GO 126614
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
126590: LD_VAR 0 4
126594: PUSH
126595: LD_VAR 0 7
126599: ARRAY
126600: PPUSH
126601: LD_VAR 0 14
126605: PUSH
126606: LD_INT 1
126608: ARRAY
126609: PPUSH
126610: CALL_OW 115
// if not HasTask ( group [ i ] ) then
126614: LD_VAR 0 4
126618: PUSH
126619: LD_VAR 0 7
126623: ARRAY
126624: PPUSH
126625: CALL_OW 314
126629: NOT
126630: IFFALSE 126668
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
126632: LD_VAR 0 4
126636: PUSH
126637: LD_VAR 0 7
126641: ARRAY
126642: PPUSH
126643: LD_VAR 0 14
126647: PPUSH
126648: LD_VAR 0 4
126652: PUSH
126653: LD_VAR 0 7
126657: ARRAY
126658: PPUSH
126659: CALL_OW 74
126663: PPUSH
126664: CALL_OW 115
// end ; end ; end ;
126668: GO 122547
126670: POP
126671: POP
// wait ( 0 0$2 ) ;
126672: LD_INT 70
126674: PPUSH
126675: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
126679: LD_VAR 0 4
126683: NOT
126684: PUSH
126685: LD_VAR 0 4
126689: PUSH
126690: EMPTY
126691: EQUAL
126692: OR
126693: PUSH
126694: LD_INT 81
126696: PUSH
126697: LD_VAR 0 35
126701: PUSH
126702: EMPTY
126703: LIST
126704: LIST
126705: PPUSH
126706: CALL_OW 69
126710: NOT
126711: OR
126712: IFFALSE 122532
// end ;
126714: LD_VAR 0 2
126718: RET
// export function BasicDefend ( base , solds ) ; var enemy , side , i , hex ; begin
126719: LD_INT 0
126721: PPUSH
126722: PPUSH
126723: PPUSH
126724: PPUSH
126725: PPUSH
// if not base or not mc_bases [ base ] or not solds then
126726: LD_VAR 0 1
126730: NOT
126731: PUSH
126732: LD_EXP 116
126736: PUSH
126737: LD_VAR 0 1
126741: ARRAY
126742: NOT
126743: OR
126744: PUSH
126745: LD_VAR 0 2
126749: NOT
126750: OR
126751: IFFALSE 126755
// exit ;
126753: GO 127284
// side := mc_sides [ base ] ;
126755: LD_ADDR_VAR 0 5
126759: PUSH
126760: LD_EXP 142
126764: PUSH
126765: LD_VAR 0 1
126769: ARRAY
126770: ST_TO_ADDR
// if not side then
126771: LD_VAR 0 5
126775: NOT
126776: IFFALSE 126780
// exit ;
126778: GO 127284
// for i in solds do
126780: LD_ADDR_VAR 0 6
126784: PUSH
126785: LD_VAR 0 2
126789: PUSH
126790: FOR_IN
126791: IFFALSE 126852
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
126793: LD_VAR 0 6
126797: PPUSH
126798: CALL_OW 310
126802: PPUSH
126803: CALL_OW 266
126807: PUSH
126808: LD_INT 32
126810: PUSH
126811: LD_INT 31
126813: PUSH
126814: EMPTY
126815: LIST
126816: LIST
126817: IN
126818: IFFALSE 126838
// solds := solds diff i else
126820: LD_ADDR_VAR 0 2
126824: PUSH
126825: LD_VAR 0 2
126829: PUSH
126830: LD_VAR 0 6
126834: DIFF
126835: ST_TO_ADDR
126836: GO 126850
// SetTag ( i , 18 ) ;
126838: LD_VAR 0 6
126842: PPUSH
126843: LD_INT 18
126845: PPUSH
126846: CALL_OW 109
126850: GO 126790
126852: POP
126853: POP
// if not solds then
126854: LD_VAR 0 2
126858: NOT
126859: IFFALSE 126863
// exit ;
126861: GO 127284
// repeat wait ( 0 0$2 ) ;
126863: LD_INT 70
126865: PPUSH
126866: CALL_OW 67
// enemy := mc_scan [ base ] ;
126870: LD_ADDR_VAR 0 4
126874: PUSH
126875: LD_EXP 139
126879: PUSH
126880: LD_VAR 0 1
126884: ARRAY
126885: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
126886: LD_EXP 116
126890: PUSH
126891: LD_VAR 0 1
126895: ARRAY
126896: NOT
126897: PUSH
126898: LD_EXP 116
126902: PUSH
126903: LD_VAR 0 1
126907: ARRAY
126908: PUSH
126909: EMPTY
126910: EQUAL
126911: OR
126912: IFFALSE 126949
// begin for i in solds do
126914: LD_ADDR_VAR 0 6
126918: PUSH
126919: LD_VAR 0 2
126923: PUSH
126924: FOR_IN
126925: IFFALSE 126938
// ComStop ( i ) ;
126927: LD_VAR 0 6
126931: PPUSH
126932: CALL_OW 141
126936: GO 126924
126938: POP
126939: POP
// solds := [ ] ;
126940: LD_ADDR_VAR 0 2
126944: PUSH
126945: EMPTY
126946: ST_TO_ADDR
// exit ;
126947: GO 127284
// end ; for i in solds do
126949: LD_ADDR_VAR 0 6
126953: PUSH
126954: LD_VAR 0 2
126958: PUSH
126959: FOR_IN
126960: IFFALSE 127256
// begin if IsInUnit ( i ) then
126962: LD_VAR 0 6
126966: PPUSH
126967: CALL_OW 310
126971: IFFALSE 126982
// ComExitBuilding ( i ) ;
126973: LD_VAR 0 6
126977: PPUSH
126978: CALL_OW 122
// if GetLives ( i ) > 333 then
126982: LD_VAR 0 6
126986: PPUSH
126987: CALL_OW 256
126991: PUSH
126992: LD_INT 333
126994: GREATER
126995: IFFALSE 127023
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
126997: LD_VAR 0 6
127001: PPUSH
127002: LD_VAR 0 4
127006: PPUSH
127007: LD_VAR 0 6
127011: PPUSH
127012: CALL_OW 74
127016: PPUSH
127017: CALL_OW 115
127021: GO 127254
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
127023: LD_VAR 0 6
127027: PPUSH
127028: LD_EXP 116
127032: PUSH
127033: LD_VAR 0 1
127037: ARRAY
127038: PPUSH
127039: LD_INT 2
127041: PUSH
127042: LD_INT 30
127044: PUSH
127045: LD_INT 0
127047: PUSH
127048: EMPTY
127049: LIST
127050: LIST
127051: PUSH
127052: LD_INT 30
127054: PUSH
127055: LD_INT 1
127057: PUSH
127058: EMPTY
127059: LIST
127060: LIST
127061: PUSH
127062: LD_INT 30
127064: PUSH
127065: LD_INT 6
127067: PUSH
127068: EMPTY
127069: LIST
127070: LIST
127071: PUSH
127072: EMPTY
127073: LIST
127074: LIST
127075: LIST
127076: LIST
127077: PPUSH
127078: CALL_OW 72
127082: PPUSH
127083: LD_VAR 0 6
127087: PPUSH
127088: CALL_OW 74
127092: PPUSH
127093: CALL_OW 296
127097: PUSH
127098: LD_INT 10
127100: GREATER
127101: IFFALSE 127254
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
127103: LD_ADDR_VAR 0 7
127107: PUSH
127108: LD_EXP 116
127112: PUSH
127113: LD_VAR 0 1
127117: ARRAY
127118: PPUSH
127119: LD_INT 2
127121: PUSH
127122: LD_INT 30
127124: PUSH
127125: LD_INT 0
127127: PUSH
127128: EMPTY
127129: LIST
127130: LIST
127131: PUSH
127132: LD_INT 30
127134: PUSH
127135: LD_INT 1
127137: PUSH
127138: EMPTY
127139: LIST
127140: LIST
127141: PUSH
127142: LD_INT 30
127144: PUSH
127145: LD_INT 6
127147: PUSH
127148: EMPTY
127149: LIST
127150: LIST
127151: PUSH
127152: EMPTY
127153: LIST
127154: LIST
127155: LIST
127156: LIST
127157: PPUSH
127158: CALL_OW 72
127162: PPUSH
127163: LD_VAR 0 6
127167: PPUSH
127168: CALL_OW 74
127172: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
127173: LD_VAR 0 6
127177: PPUSH
127178: LD_VAR 0 7
127182: PPUSH
127183: CALL_OW 250
127187: PPUSH
127188: LD_INT 3
127190: PPUSH
127191: LD_INT 5
127193: PPUSH
127194: CALL_OW 272
127198: PPUSH
127199: LD_VAR 0 7
127203: PPUSH
127204: CALL_OW 251
127208: PPUSH
127209: LD_INT 3
127211: PPUSH
127212: LD_INT 5
127214: PPUSH
127215: CALL_OW 273
127219: PPUSH
127220: CALL_OW 111
// SetTag ( i , 0 ) ;
127224: LD_VAR 0 6
127228: PPUSH
127229: LD_INT 0
127231: PPUSH
127232: CALL_OW 109
// solds := solds diff i ;
127236: LD_ADDR_VAR 0 2
127240: PUSH
127241: LD_VAR 0 2
127245: PUSH
127246: LD_VAR 0 6
127250: DIFF
127251: ST_TO_ADDR
// continue ;
127252: GO 126959
// end ; end ;
127254: GO 126959
127256: POP
127257: POP
// until not solds or not enemy ;
127258: LD_VAR 0 2
127262: NOT
127263: PUSH
127264: LD_VAR 0 4
127268: NOT
127269: OR
127270: IFFALSE 126863
// MC_Reset ( base , 18 ) ;
127272: LD_VAR 0 1
127276: PPUSH
127277: LD_INT 18
127279: PPUSH
127280: CALL 39297 0 2
// end ;
127284: LD_VAR 0 3
127288: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
127289: LD_INT 0
127291: PPUSH
127292: PPUSH
127293: PPUSH
127294: PPUSH
127295: PPUSH
127296: PPUSH
127297: PPUSH
127298: PPUSH
127299: PPUSH
127300: PPUSH
127301: PPUSH
127302: PPUSH
127303: PPUSH
127304: PPUSH
127305: PPUSH
127306: PPUSH
127307: PPUSH
127308: PPUSH
127309: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
127310: LD_ADDR_VAR 0 12
127314: PUSH
127315: LD_EXP 116
127319: PUSH
127320: LD_VAR 0 1
127324: ARRAY
127325: PPUSH
127326: LD_INT 25
127328: PUSH
127329: LD_INT 3
127331: PUSH
127332: EMPTY
127333: LIST
127334: LIST
127335: PPUSH
127336: CALL_OW 72
127340: ST_TO_ADDR
// if mc_remote_driver [ base ] then
127341: LD_EXP 156
127345: PUSH
127346: LD_VAR 0 1
127350: ARRAY
127351: IFFALSE 127375
// mechs := mechs diff mc_remote_driver [ base ] ;
127353: LD_ADDR_VAR 0 12
127357: PUSH
127358: LD_VAR 0 12
127362: PUSH
127363: LD_EXP 156
127367: PUSH
127368: LD_VAR 0 1
127372: ARRAY
127373: DIFF
127374: ST_TO_ADDR
// for i in mechs do
127375: LD_ADDR_VAR 0 4
127379: PUSH
127380: LD_VAR 0 12
127384: PUSH
127385: FOR_IN
127386: IFFALSE 127421
// if GetTag ( i ) > 0 then
127388: LD_VAR 0 4
127392: PPUSH
127393: CALL_OW 110
127397: PUSH
127398: LD_INT 0
127400: GREATER
127401: IFFALSE 127419
// mechs := mechs diff i ;
127403: LD_ADDR_VAR 0 12
127407: PUSH
127408: LD_VAR 0 12
127412: PUSH
127413: LD_VAR 0 4
127417: DIFF
127418: ST_TO_ADDR
127419: GO 127385
127421: POP
127422: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
127423: LD_ADDR_VAR 0 8
127427: PUSH
127428: LD_EXP 116
127432: PUSH
127433: LD_VAR 0 1
127437: ARRAY
127438: PPUSH
127439: LD_INT 2
127441: PUSH
127442: LD_INT 25
127444: PUSH
127445: LD_INT 1
127447: PUSH
127448: EMPTY
127449: LIST
127450: LIST
127451: PUSH
127452: LD_INT 25
127454: PUSH
127455: LD_INT 5
127457: PUSH
127458: EMPTY
127459: LIST
127460: LIST
127461: PUSH
127462: LD_INT 25
127464: PUSH
127465: LD_INT 8
127467: PUSH
127468: EMPTY
127469: LIST
127470: LIST
127471: PUSH
127472: LD_INT 25
127474: PUSH
127475: LD_INT 9
127477: PUSH
127478: EMPTY
127479: LIST
127480: LIST
127481: PUSH
127482: EMPTY
127483: LIST
127484: LIST
127485: LIST
127486: LIST
127487: LIST
127488: PPUSH
127489: CALL_OW 72
127493: ST_TO_ADDR
// if not defenders and not solds then
127494: LD_VAR 0 2
127498: NOT
127499: PUSH
127500: LD_VAR 0 8
127504: NOT
127505: AND
127506: IFFALSE 127510
// exit ;
127508: GO 129280
// depot_under_attack := false ;
127510: LD_ADDR_VAR 0 16
127514: PUSH
127515: LD_INT 0
127517: ST_TO_ADDR
// sold_defenders := [ ] ;
127518: LD_ADDR_VAR 0 17
127522: PUSH
127523: EMPTY
127524: ST_TO_ADDR
// if mechs then
127525: LD_VAR 0 12
127529: IFFALSE 127682
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
127531: LD_ADDR_VAR 0 4
127535: PUSH
127536: LD_VAR 0 2
127540: PPUSH
127541: LD_INT 21
127543: PUSH
127544: LD_INT 2
127546: PUSH
127547: EMPTY
127548: LIST
127549: LIST
127550: PPUSH
127551: CALL_OW 72
127555: PUSH
127556: FOR_IN
127557: IFFALSE 127680
// begin if GetTag ( i ) <> 20 then
127559: LD_VAR 0 4
127563: PPUSH
127564: CALL_OW 110
127568: PUSH
127569: LD_INT 20
127571: NONEQUAL
127572: IFFALSE 127586
// SetTag ( i , 20 ) ;
127574: LD_VAR 0 4
127578: PPUSH
127579: LD_INT 20
127581: PPUSH
127582: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
127586: LD_VAR 0 4
127590: PPUSH
127591: CALL_OW 263
127595: PUSH
127596: LD_INT 1
127598: EQUAL
127599: PUSH
127600: LD_VAR 0 4
127604: PPUSH
127605: CALL_OW 311
127609: NOT
127610: AND
127611: IFFALSE 127678
// begin un := mechs [ 1 ] ;
127613: LD_ADDR_VAR 0 10
127617: PUSH
127618: LD_VAR 0 12
127622: PUSH
127623: LD_INT 1
127625: ARRAY
127626: ST_TO_ADDR
// ComExit ( un ) ;
127627: LD_VAR 0 10
127631: PPUSH
127632: CALL 102747 0 1
// AddComEnterUnit ( un , i ) ;
127636: LD_VAR 0 10
127640: PPUSH
127641: LD_VAR 0 4
127645: PPUSH
127646: CALL_OW 180
// SetTag ( un , 19 ) ;
127650: LD_VAR 0 10
127654: PPUSH
127655: LD_INT 19
127657: PPUSH
127658: CALL_OW 109
// mechs := mechs diff un ;
127662: LD_ADDR_VAR 0 12
127666: PUSH
127667: LD_VAR 0 12
127671: PUSH
127672: LD_VAR 0 10
127676: DIFF
127677: ST_TO_ADDR
// end ; end ;
127678: GO 127556
127680: POP
127681: POP
// if solds then
127682: LD_VAR 0 8
127686: IFFALSE 127745
// for i in solds do
127688: LD_ADDR_VAR 0 4
127692: PUSH
127693: LD_VAR 0 8
127697: PUSH
127698: FOR_IN
127699: IFFALSE 127743
// if not GetTag ( i ) then
127701: LD_VAR 0 4
127705: PPUSH
127706: CALL_OW 110
127710: NOT
127711: IFFALSE 127741
// begin defenders := defenders union i ;
127713: LD_ADDR_VAR 0 2
127717: PUSH
127718: LD_VAR 0 2
127722: PUSH
127723: LD_VAR 0 4
127727: UNION
127728: ST_TO_ADDR
// SetTag ( i , 18 ) ;
127729: LD_VAR 0 4
127733: PPUSH
127734: LD_INT 18
127736: PPUSH
127737: CALL_OW 109
// end ;
127741: GO 127698
127743: POP
127744: POP
// repeat wait ( 0 0$2 ) ;
127745: LD_INT 70
127747: PPUSH
127748: CALL_OW 67
// enemy := mc_scan [ base ] ;
127752: LD_ADDR_VAR 0 21
127756: PUSH
127757: LD_EXP 139
127761: PUSH
127762: LD_VAR 0 1
127766: ARRAY
127767: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
127768: LD_EXP 116
127772: PUSH
127773: LD_VAR 0 1
127777: ARRAY
127778: NOT
127779: PUSH
127780: LD_EXP 116
127784: PUSH
127785: LD_VAR 0 1
127789: ARRAY
127790: PUSH
127791: EMPTY
127792: EQUAL
127793: OR
127794: IFFALSE 127831
// begin for i in defenders do
127796: LD_ADDR_VAR 0 4
127800: PUSH
127801: LD_VAR 0 2
127805: PUSH
127806: FOR_IN
127807: IFFALSE 127820
// ComStop ( i ) ;
127809: LD_VAR 0 4
127813: PPUSH
127814: CALL_OW 141
127818: GO 127806
127820: POP
127821: POP
// defenders := [ ] ;
127822: LD_ADDR_VAR 0 2
127826: PUSH
127827: EMPTY
127828: ST_TO_ADDR
// exit ;
127829: GO 129280
// end ; for i in defenders do
127831: LD_ADDR_VAR 0 4
127835: PUSH
127836: LD_VAR 0 2
127840: PUSH
127841: FOR_IN
127842: IFFALSE 128740
// begin e := NearestUnitToUnit ( enemy , i ) ;
127844: LD_ADDR_VAR 0 13
127848: PUSH
127849: LD_VAR 0 21
127853: PPUSH
127854: LD_VAR 0 4
127858: PPUSH
127859: CALL_OW 74
127863: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
127864: LD_ADDR_VAR 0 7
127868: PUSH
127869: LD_EXP 116
127873: PUSH
127874: LD_VAR 0 1
127878: ARRAY
127879: PPUSH
127880: LD_INT 2
127882: PUSH
127883: LD_INT 30
127885: PUSH
127886: LD_INT 0
127888: PUSH
127889: EMPTY
127890: LIST
127891: LIST
127892: PUSH
127893: LD_INT 30
127895: PUSH
127896: LD_INT 1
127898: PUSH
127899: EMPTY
127900: LIST
127901: LIST
127902: PUSH
127903: EMPTY
127904: LIST
127905: LIST
127906: LIST
127907: PPUSH
127908: CALL_OW 72
127912: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
127913: LD_ADDR_VAR 0 16
127917: PUSH
127918: LD_VAR 0 7
127922: NOT
127923: PUSH
127924: LD_VAR 0 7
127928: PPUSH
127929: LD_INT 3
127931: PUSH
127932: LD_INT 24
127934: PUSH
127935: LD_INT 600
127937: PUSH
127938: EMPTY
127939: LIST
127940: LIST
127941: PUSH
127942: EMPTY
127943: LIST
127944: LIST
127945: PPUSH
127946: CALL_OW 72
127950: OR
127951: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
127952: LD_VAR 0 4
127956: PPUSH
127957: CALL_OW 247
127961: PUSH
127962: LD_INT 2
127964: DOUBLE
127965: EQUAL
127966: IFTRUE 127970
127968: GO 128366
127970: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
127971: LD_VAR 0 4
127975: PPUSH
127976: CALL_OW 256
127980: PUSH
127981: LD_INT 1000
127983: EQUAL
127984: PUSH
127985: LD_VAR 0 4
127989: PPUSH
127990: LD_VAR 0 13
127994: PPUSH
127995: CALL_OW 296
127999: PUSH
128000: LD_INT 40
128002: LESS
128003: PUSH
128004: LD_VAR 0 13
128008: PPUSH
128009: LD_EXP 141
128013: PUSH
128014: LD_VAR 0 1
128018: ARRAY
128019: PPUSH
128020: CALL_OW 308
128024: OR
128025: AND
128026: IFFALSE 128148
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
128028: LD_VAR 0 4
128032: PPUSH
128033: CALL_OW 262
128037: PUSH
128038: LD_INT 1
128040: EQUAL
128041: PUSH
128042: LD_VAR 0 4
128046: PPUSH
128047: CALL_OW 261
128051: PUSH
128052: LD_INT 30
128054: LESS
128055: AND
128056: PUSH
128057: LD_VAR 0 7
128061: AND
128062: IFFALSE 128132
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
128064: LD_VAR 0 4
128068: PPUSH
128069: LD_VAR 0 7
128073: PPUSH
128074: LD_VAR 0 4
128078: PPUSH
128079: CALL_OW 74
128083: PPUSH
128084: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
128088: LD_VAR 0 4
128092: PPUSH
128093: LD_VAR 0 7
128097: PPUSH
128098: LD_VAR 0 4
128102: PPUSH
128103: CALL_OW 74
128107: PPUSH
128108: CALL_OW 296
128112: PUSH
128113: LD_INT 6
128115: LESS
128116: IFFALSE 128130
// SetFuel ( i , 100 ) ;
128118: LD_VAR 0 4
128122: PPUSH
128123: LD_INT 100
128125: PPUSH
128126: CALL_OW 240
// end else
128130: GO 128146
// ComAttackUnit ( i , e ) ;
128132: LD_VAR 0 4
128136: PPUSH
128137: LD_VAR 0 13
128141: PPUSH
128142: CALL_OW 115
// end else
128146: GO 128249
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
128148: LD_VAR 0 13
128152: PPUSH
128153: LD_EXP 141
128157: PUSH
128158: LD_VAR 0 1
128162: ARRAY
128163: PPUSH
128164: CALL_OW 308
128168: NOT
128169: PUSH
128170: LD_VAR 0 4
128174: PPUSH
128175: LD_VAR 0 13
128179: PPUSH
128180: CALL_OW 296
128184: PUSH
128185: LD_INT 40
128187: GREATEREQUAL
128188: AND
128189: PUSH
128190: LD_VAR 0 4
128194: PPUSH
128195: CALL_OW 256
128199: PUSH
128200: LD_INT 650
128202: LESSEQUAL
128203: OR
128204: PUSH
128205: LD_VAR 0 4
128209: PPUSH
128210: LD_EXP 140
128214: PUSH
128215: LD_VAR 0 1
128219: ARRAY
128220: PPUSH
128221: CALL_OW 308
128225: NOT
128226: AND
128227: IFFALSE 128249
// ComMoveToArea ( i , mc_parking [ base ] ) ;
128229: LD_VAR 0 4
128233: PPUSH
128234: LD_EXP 140
128238: PUSH
128239: LD_VAR 0 1
128243: ARRAY
128244: PPUSH
128245: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
128249: LD_VAR 0 4
128253: PPUSH
128254: CALL_OW 256
128258: PUSH
128259: LD_INT 1000
128261: LESS
128262: PUSH
128263: LD_VAR 0 4
128267: PPUSH
128268: CALL_OW 263
128272: PUSH
128273: LD_INT 1
128275: EQUAL
128276: AND
128277: PUSH
128278: LD_VAR 0 4
128282: PPUSH
128283: CALL_OW 311
128287: AND
128288: PUSH
128289: LD_VAR 0 4
128293: PPUSH
128294: LD_EXP 140
128298: PUSH
128299: LD_VAR 0 1
128303: ARRAY
128304: PPUSH
128305: CALL_OW 308
128309: AND
128310: IFFALSE 128364
// begin mech := IsDrivenBy ( i ) ;
128312: LD_ADDR_VAR 0 9
128316: PUSH
128317: LD_VAR 0 4
128321: PPUSH
128322: CALL_OW 311
128326: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
128327: LD_VAR 0 9
128331: PPUSH
128332: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
128336: LD_VAR 0 9
128340: PPUSH
128341: LD_VAR 0 4
128345: PPUSH
128346: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
128350: LD_VAR 0 9
128354: PPUSH
128355: LD_VAR 0 4
128359: PPUSH
128360: CALL_OW 180
// end ; end ; unit_human :
128364: GO 128711
128366: LD_INT 1
128368: DOUBLE
128369: EQUAL
128370: IFTRUE 128374
128372: GO 128710
128374: POP
// begin b := IsInUnit ( i ) ;
128375: LD_ADDR_VAR 0 18
128379: PUSH
128380: LD_VAR 0 4
128384: PPUSH
128385: CALL_OW 310
128389: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
128390: LD_ADDR_VAR 0 19
128394: PUSH
128395: LD_VAR 0 18
128399: NOT
128400: PUSH
128401: LD_VAR 0 18
128405: PPUSH
128406: CALL_OW 266
128410: PUSH
128411: LD_INT 32
128413: PUSH
128414: LD_INT 31
128416: PUSH
128417: EMPTY
128418: LIST
128419: LIST
128420: IN
128421: OR
128422: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
128423: LD_VAR 0 18
128427: PPUSH
128428: CALL_OW 266
128432: PUSH
128433: LD_INT 5
128435: EQUAL
128436: PUSH
128437: LD_VAR 0 4
128441: PPUSH
128442: CALL_OW 257
128446: PUSH
128447: LD_INT 1
128449: PUSH
128450: LD_INT 2
128452: PUSH
128453: LD_INT 3
128455: PUSH
128456: LD_INT 4
128458: PUSH
128459: EMPTY
128460: LIST
128461: LIST
128462: LIST
128463: LIST
128464: IN
128465: AND
128466: IFFALSE 128503
// begin class := AllowSpecClass ( i ) ;
128468: LD_ADDR_VAR 0 20
128472: PUSH
128473: LD_VAR 0 4
128477: PPUSH
128478: CALL 67408 0 1
128482: ST_TO_ADDR
// if class then
128483: LD_VAR 0 20
128487: IFFALSE 128503
// ComChangeProfession ( i , class ) ;
128489: LD_VAR 0 4
128493: PPUSH
128494: LD_VAR 0 20
128498: PPUSH
128499: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
128503: LD_VAR 0 16
128507: PUSH
128508: LD_VAR 0 2
128512: PPUSH
128513: LD_INT 21
128515: PUSH
128516: LD_INT 2
128518: PUSH
128519: EMPTY
128520: LIST
128521: LIST
128522: PPUSH
128523: CALL_OW 72
128527: PUSH
128528: LD_INT 1
128530: LESSEQUAL
128531: OR
128532: PUSH
128533: LD_VAR 0 19
128537: AND
128538: PUSH
128539: LD_VAR 0 4
128543: PUSH
128544: LD_VAR 0 17
128548: IN
128549: NOT
128550: AND
128551: IFFALSE 128644
// begin if b then
128553: LD_VAR 0 18
128557: IFFALSE 128606
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
128559: LD_VAR 0 18
128563: PPUSH
128564: LD_VAR 0 21
128568: PPUSH
128569: LD_VAR 0 18
128573: PPUSH
128574: CALL_OW 74
128578: PPUSH
128579: CALL_OW 296
128583: PUSH
128584: LD_INT 10
128586: LESS
128587: PUSH
128588: LD_VAR 0 18
128592: PPUSH
128593: CALL_OW 461
128597: PUSH
128598: LD_INT 7
128600: NONEQUAL
128601: AND
128602: IFFALSE 128606
// continue ;
128604: GO 127841
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
128606: LD_ADDR_VAR 0 17
128610: PUSH
128611: LD_VAR 0 17
128615: PPUSH
128616: LD_VAR 0 17
128620: PUSH
128621: LD_INT 1
128623: PLUS
128624: PPUSH
128625: LD_VAR 0 4
128629: PPUSH
128630: CALL_OW 1
128634: ST_TO_ADDR
// ComExitBuilding ( i ) ;
128635: LD_VAR 0 4
128639: PPUSH
128640: CALL_OW 122
// end ; if sold_defenders then
128644: LD_VAR 0 17
128648: IFFALSE 128708
// if i in sold_defenders then
128650: LD_VAR 0 4
128654: PUSH
128655: LD_VAR 0 17
128659: IN
128660: IFFALSE 128708
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
128662: LD_VAR 0 4
128666: PPUSH
128667: CALL_OW 314
128671: NOT
128672: PUSH
128673: LD_VAR 0 4
128677: PPUSH
128678: LD_VAR 0 13
128682: PPUSH
128683: CALL_OW 296
128687: PUSH
128688: LD_INT 30
128690: LESS
128691: AND
128692: IFFALSE 128708
// ComAttackUnit ( i , e ) ;
128694: LD_VAR 0 4
128698: PPUSH
128699: LD_VAR 0 13
128703: PPUSH
128704: CALL_OW 115
// end ; end ; end ;
128708: GO 128711
128710: POP
// if IsDead ( i ) then
128711: LD_VAR 0 4
128715: PPUSH
128716: CALL_OW 301
128720: IFFALSE 128738
// defenders := defenders diff i ;
128722: LD_ADDR_VAR 0 2
128726: PUSH
128727: LD_VAR 0 2
128731: PUSH
128732: LD_VAR 0 4
128736: DIFF
128737: ST_TO_ADDR
// end ;
128738: GO 127841
128740: POP
128741: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
128742: LD_VAR 0 21
128746: NOT
128747: PUSH
128748: LD_VAR 0 2
128752: NOT
128753: OR
128754: PUSH
128755: LD_EXP 116
128759: PUSH
128760: LD_VAR 0 1
128764: ARRAY
128765: NOT
128766: OR
128767: IFFALSE 127745
// MC_Reset ( base , 18 ) ;
128769: LD_VAR 0 1
128773: PPUSH
128774: LD_INT 18
128776: PPUSH
128777: CALL 39297 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
128781: LD_ADDR_VAR 0 2
128785: PUSH
128786: LD_VAR 0 2
128790: PUSH
128791: LD_VAR 0 2
128795: PPUSH
128796: LD_INT 2
128798: PUSH
128799: LD_INT 25
128801: PUSH
128802: LD_INT 1
128804: PUSH
128805: EMPTY
128806: LIST
128807: LIST
128808: PUSH
128809: LD_INT 25
128811: PUSH
128812: LD_INT 5
128814: PUSH
128815: EMPTY
128816: LIST
128817: LIST
128818: PUSH
128819: LD_INT 25
128821: PUSH
128822: LD_INT 8
128824: PUSH
128825: EMPTY
128826: LIST
128827: LIST
128828: PUSH
128829: LD_INT 25
128831: PUSH
128832: LD_INT 9
128834: PUSH
128835: EMPTY
128836: LIST
128837: LIST
128838: PUSH
128839: EMPTY
128840: LIST
128841: LIST
128842: LIST
128843: LIST
128844: LIST
128845: PPUSH
128846: CALL_OW 72
128850: DIFF
128851: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
128852: LD_VAR 0 21
128856: NOT
128857: PUSH
128858: LD_VAR 0 2
128862: PPUSH
128863: LD_INT 21
128865: PUSH
128866: LD_INT 2
128868: PUSH
128869: EMPTY
128870: LIST
128871: LIST
128872: PPUSH
128873: CALL_OW 72
128877: AND
128878: IFFALSE 129216
// begin tmp := FilterByTag ( defenders , 19 ) ;
128880: LD_ADDR_VAR 0 11
128884: PUSH
128885: LD_VAR 0 2
128889: PPUSH
128890: LD_INT 19
128892: PPUSH
128893: CALL 99877 0 2
128897: ST_TO_ADDR
// if tmp then
128898: LD_VAR 0 11
128902: IFFALSE 128972
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
128904: LD_ADDR_VAR 0 11
128908: PUSH
128909: LD_VAR 0 11
128913: PPUSH
128914: LD_INT 25
128916: PUSH
128917: LD_INT 3
128919: PUSH
128920: EMPTY
128921: LIST
128922: LIST
128923: PPUSH
128924: CALL_OW 72
128928: ST_TO_ADDR
// if tmp then
128929: LD_VAR 0 11
128933: IFFALSE 128972
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
128935: LD_ADDR_EXP 128
128939: PUSH
128940: LD_EXP 128
128944: PPUSH
128945: LD_VAR 0 1
128949: PPUSH
128950: LD_EXP 128
128954: PUSH
128955: LD_VAR 0 1
128959: ARRAY
128960: PUSH
128961: LD_VAR 0 11
128965: UNION
128966: PPUSH
128967: CALL_OW 1
128971: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
128972: LD_VAR 0 1
128976: PPUSH
128977: LD_INT 19
128979: PPUSH
128980: CALL 39297 0 2
// repeat wait ( 0 0$1 ) ;
128984: LD_INT 35
128986: PPUSH
128987: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
128991: LD_EXP 116
128995: PUSH
128996: LD_VAR 0 1
129000: ARRAY
129001: NOT
129002: PUSH
129003: LD_EXP 116
129007: PUSH
129008: LD_VAR 0 1
129012: ARRAY
129013: PUSH
129014: EMPTY
129015: EQUAL
129016: OR
129017: IFFALSE 129054
// begin for i in defenders do
129019: LD_ADDR_VAR 0 4
129023: PUSH
129024: LD_VAR 0 2
129028: PUSH
129029: FOR_IN
129030: IFFALSE 129043
// ComStop ( i ) ;
129032: LD_VAR 0 4
129036: PPUSH
129037: CALL_OW 141
129041: GO 129029
129043: POP
129044: POP
// defenders := [ ] ;
129045: LD_ADDR_VAR 0 2
129049: PUSH
129050: EMPTY
129051: ST_TO_ADDR
// exit ;
129052: GO 129280
// end ; for i in defenders do
129054: LD_ADDR_VAR 0 4
129058: PUSH
129059: LD_VAR 0 2
129063: PUSH
129064: FOR_IN
129065: IFFALSE 129154
// begin if not IsInArea ( i , mc_parking [ base ] ) then
129067: LD_VAR 0 4
129071: PPUSH
129072: LD_EXP 140
129076: PUSH
129077: LD_VAR 0 1
129081: ARRAY
129082: PPUSH
129083: CALL_OW 308
129087: NOT
129088: IFFALSE 129112
// ComMoveToArea ( i , mc_parking [ base ] ) else
129090: LD_VAR 0 4
129094: PPUSH
129095: LD_EXP 140
129099: PUSH
129100: LD_VAR 0 1
129104: ARRAY
129105: PPUSH
129106: CALL_OW 113
129110: GO 129152
// if GetControl ( i ) = control_manual then
129112: LD_VAR 0 4
129116: PPUSH
129117: CALL_OW 263
129121: PUSH
129122: LD_INT 1
129124: EQUAL
129125: IFFALSE 129152
// if IsDrivenBy ( i ) then
129127: LD_VAR 0 4
129131: PPUSH
129132: CALL_OW 311
129136: IFFALSE 129152
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
129138: LD_VAR 0 4
129142: PPUSH
129143: CALL_OW 311
129147: PPUSH
129148: CALL_OW 121
// end ;
129152: GO 129064
129154: POP
129155: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
129156: LD_VAR 0 2
129160: PPUSH
129161: LD_INT 95
129163: PUSH
129164: LD_EXP 140
129168: PUSH
129169: LD_VAR 0 1
129173: ARRAY
129174: PUSH
129175: EMPTY
129176: LIST
129177: LIST
129178: PPUSH
129179: CALL_OW 72
129183: PUSH
129184: LD_VAR 0 2
129188: EQUAL
129189: PUSH
129190: LD_EXP 139
129194: PUSH
129195: LD_VAR 0 1
129199: ARRAY
129200: OR
129201: PUSH
129202: LD_EXP 116
129206: PUSH
129207: LD_VAR 0 1
129211: ARRAY
129212: NOT
129213: OR
129214: IFFALSE 128984
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
129216: LD_ADDR_EXP 138
129220: PUSH
129221: LD_EXP 138
129225: PPUSH
129226: LD_VAR 0 1
129230: PPUSH
129231: LD_VAR 0 2
129235: PPUSH
129236: LD_INT 21
129238: PUSH
129239: LD_INT 2
129241: PUSH
129242: EMPTY
129243: LIST
129244: LIST
129245: PPUSH
129246: CALL_OW 72
129250: PPUSH
129251: CALL_OW 1
129255: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
129256: LD_VAR 0 1
129260: PPUSH
129261: LD_INT 19
129263: PPUSH
129264: CALL 39297 0 2
// MC_Reset ( base , 20 ) ;
129268: LD_VAR 0 1
129272: PPUSH
129273: LD_INT 20
129275: PPUSH
129276: CALL 39297 0 2
// end ; end_of_file
129280: LD_VAR 0 3
129284: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
129285: LD_VAR 0 1
129289: PUSH
129290: LD_INT 200
129292: DOUBLE
129293: GREATEREQUAL
129294: IFFALSE 129302
129296: LD_INT 299
129298: DOUBLE
129299: LESSEQUAL
129300: IFTRUE 129304
129302: GO 129336
129304: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
129305: LD_VAR 0 1
129309: PPUSH
129310: LD_VAR 0 2
129314: PPUSH
129315: LD_VAR 0 3
129319: PPUSH
129320: LD_VAR 0 4
129324: PPUSH
129325: LD_VAR 0 5
129329: PPUSH
129330: CALL 118127 0 5
129334: GO 129413
129336: LD_INT 300
129338: DOUBLE
129339: GREATEREQUAL
129340: IFFALSE 129348
129342: LD_INT 399
129344: DOUBLE
129345: LESSEQUAL
129346: IFTRUE 129350
129348: GO 129412
129350: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
129351: LD_VAR 0 1
129355: PPUSH
129356: LD_VAR 0 2
129360: PPUSH
129361: LD_VAR 0 3
129365: PPUSH
129366: LD_VAR 0 4
129370: PPUSH
129371: LD_VAR 0 5
129375: PPUSH
129376: LD_VAR 0 6
129380: PPUSH
129381: LD_VAR 0 7
129385: PPUSH
129386: LD_VAR 0 8
129390: PPUSH
129391: LD_VAR 0 9
129395: PPUSH
129396: LD_VAR 0 10
129400: PPUSH
129401: LD_VAR 0 11
129405: PPUSH
129406: CALL 116015 0 11
129410: GO 129413
129412: POP
// end ;
129413: PPOPN 11
129415: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
129416: LD_VAR 0 1
129420: PPUSH
129421: LD_VAR 0 2
129425: PPUSH
129426: LD_VAR 0 3
129430: PPUSH
129431: LD_VAR 0 4
129435: PPUSH
129436: LD_VAR 0 5
129440: PPUSH
129441: CALL 118109 0 5
// end ; end_of_file
129445: PPOPN 5
129447: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
129448: LD_VAR 0 1
129452: PPUSH
129453: LD_VAR 0 2
129457: PPUSH
129458: LD_VAR 0 3
129462: PPUSH
129463: LD_VAR 0 4
129467: PPUSH
129468: LD_VAR 0 5
129472: PPUSH
129473: LD_VAR 0 6
129477: PPUSH
129478: CALL 104823 0 6
// end ;
129482: PPOPN 6
129484: END
