// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 36570 0 0
// InitNature ;
  19: CALL 36438 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 11877 0 0
// PrepareRussian ;
  40: CALL 7149 0 0
// PrepareLegion ;
  44: CALL 4338 0 0
// PreparePowell ;
  48: CALL 3044 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 15944 0 0
// MC_Start ( ) ;
  60: CALL 38742 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 123
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 124
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 61540 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 61633 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 60983 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 1
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 1
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 60798 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 61540 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 61633 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 60798 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 60983 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 61413 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 60480 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 61540 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 61633 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 128
 971: PUSH
 972: LD_EXP 128
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 60798 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 61540 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 61633 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 60690 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 61951 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 61122 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 61413 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 61413 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 61745 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 60798 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 61364 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 67234 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1900
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 72249 0 5
1898: GO 1959
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1900: LD_EXP 4
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 1
1911: ARRAY
1912: PPUSH
1913: LD_EXP 4
1917: PUSH
1918: LD_INT 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_EXP 4
1930: PUSH
1931: LD_INT 3
1933: ARRAY
1934: PUSH
1935: LD_INT 1
1937: ARRAY
1938: PPUSH
1939: LD_EXP 4
1943: PUSH
1944: LD_INT 4
1946: ARRAY
1947: PUSH
1948: LD_INT 1
1950: ARRAY
1951: PPUSH
1952: LD_INT 30
1954: PPUSH
1955: CALL 72249 0 5
// JMMNewVeh := CreateVehicle ;
1959: LD_ADDR_EXP 57
1963: PUSH
1964: CALL_OW 45
1968: ST_TO_ADDR
// if not JMMNewVeh then
1969: LD_EXP 57
1973: NOT
1974: IFFALSE 2005
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1976: LD_INT 5
1978: PPUSH
1979: LD_INT 3
1981: PPUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 9
1987: PPUSH
1988: LD_INT 100
1990: PPUSH
1991: CALL 72249 0 5
// JMMNewVeh := CreateVehicle ;
1995: LD_ADDR_EXP 57
1999: PUSH
2000: CALL_OW 45
2004: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2005: LD_EXP 57
2009: PPUSH
2010: LD_INT 4
2012: PPUSH
2013: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2017: LD_EXP 57
2021: PPUSH
2022: LD_INT 79
2024: PPUSH
2025: LD_INT 91
2027: PPUSH
2028: LD_INT 0
2030: PPUSH
2031: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2035: LD_EXP 40
2039: PPUSH
2040: LD_EXP 57
2044: PPUSH
2045: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2049: LD_EXP 6
2053: PUSH
2054: LD_EXP 2
2058: NOT
2059: AND
2060: IFFALSE 2318
// begin if not JMMGirlVeh then
2062: LD_EXP 5
2066: NOT
2067: IFFALSE 2090
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2069: LD_INT 3
2071: PPUSH
2072: LD_INT 3
2074: PPUSH
2075: LD_INT 1
2077: PPUSH
2078: LD_INT 9
2080: PPUSH
2081: LD_INT 100
2083: PPUSH
2084: CALL 72249 0 5
2088: GO 2149
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2090: LD_EXP 5
2094: PUSH
2095: LD_INT 1
2097: ARRAY
2098: PUSH
2099: LD_INT 1
2101: ARRAY
2102: PPUSH
2103: LD_EXP 5
2107: PUSH
2108: LD_INT 2
2110: ARRAY
2111: PUSH
2112: LD_INT 1
2114: ARRAY
2115: PPUSH
2116: LD_EXP 5
2120: PUSH
2121: LD_INT 3
2123: ARRAY
2124: PUSH
2125: LD_INT 1
2127: ARRAY
2128: PPUSH
2129: LD_EXP 5
2133: PUSH
2134: LD_INT 4
2136: ARRAY
2137: PUSH
2138: LD_INT 1
2140: ARRAY
2141: PPUSH
2142: LD_INT 30
2144: PPUSH
2145: CALL 72249 0 5
// GirlNewVeh := CreateVehicle ;
2149: LD_ADDR_EXP 58
2153: PUSH
2154: CALL_OW 45
2158: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2159: LD_EXP 58
2163: PPUSH
2164: LD_INT 4
2166: PPUSH
2167: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2171: LD_EXP 58
2175: PPUSH
2176: LD_INT 82
2178: PPUSH
2179: LD_INT 96
2181: PPUSH
2182: LD_INT 0
2184: PPUSH
2185: CALL_OW 48
// if JMMGirl = 1 then
2189: LD_EXP 7
2193: PUSH
2194: LD_INT 1
2196: EQUAL
2197: IFFALSE 2232
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2199: LD_ADDR_EXP 41
2203: PUSH
2204: LD_STRING Joan
2206: PPUSH
2207: LD_INT 1
2209: PPUSH
2210: LD_STRING 14_
2212: PPUSH
2213: CALL 67234 0 3
2217: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2218: LD_EXP 41
2222: PPUSH
2223: LD_EXP 58
2227: PPUSH
2228: CALL_OW 52
// end ; if JMMGirl = 2 then
2232: LD_EXP 7
2236: PUSH
2237: LD_INT 2
2239: EQUAL
2240: IFFALSE 2275
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2242: LD_ADDR_EXP 43
2246: PUSH
2247: LD_STRING Lisa
2249: PPUSH
2250: LD_INT 1
2252: PPUSH
2253: LD_STRING 14_
2255: PPUSH
2256: CALL 67234 0 3
2260: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2261: LD_EXP 43
2265: PPUSH
2266: LD_EXP 58
2270: PPUSH
2271: CALL_OW 52
// end ; if JMMGirl = 3 then
2275: LD_EXP 7
2279: PUSH
2280: LD_INT 3
2282: EQUAL
2283: IFFALSE 2318
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2285: LD_ADDR_EXP 55
2289: PUSH
2290: LD_STRING Connie
2292: PPUSH
2293: LD_INT 1
2295: PPUSH
2296: LD_STRING 14_
2298: PPUSH
2299: CALL 67234 0 3
2303: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2304: LD_EXP 55
2308: PPUSH
2309: LD_EXP 58
2313: PPUSH
2314: CALL_OW 52
// end ; end ; end ;
2318: LD_VAR 0 1
2322: RET
// export function PrepareStevensSquad ; var tmp ; begin
2323: LD_INT 0
2325: PPUSH
2326: PPUSH
// uc_side := 1 ;
2327: LD_ADDR_OWVAR 20
2331: PUSH
2332: LD_INT 1
2334: ST_TO_ADDR
// uc_nation := 1 ;
2335: LD_ADDR_OWVAR 21
2339: PUSH
2340: LD_INT 1
2342: ST_TO_ADDR
// tmp := [ ] ;
2343: LD_ADDR_VAR 0 2
2347: PUSH
2348: EMPTY
2349: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2350: LD_ADDR_EXP 42
2354: PUSH
2355: LD_STRING Stevens
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13f_
2366: PPUSH
2367: CALL 67234 0 3
2371: ST_TO_ADDR
// if not Stevens then
2372: LD_EXP 42
2376: NOT
2377: IFFALSE 2433
// begin hc_name = Baker Smith ;
2379: LD_ADDR_OWVAR 26
2383: PUSH
2384: LD_STRING Baker Smith
2386: ST_TO_ADDR
// hc_gallery =  ;
2387: LD_ADDR_OWVAR 33
2391: PUSH
2392: LD_STRING 
2394: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2395: LD_INT 1
2397: PPUSH
2398: LD_INT 10
2400: PPUSH
2401: CALL_OW 384
// Baker = CreateHuman ;
2405: LD_ADDR_EXP 56
2409: PUSH
2410: CALL_OW 44
2414: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2415: LD_ADDR_VAR 0 2
2419: PUSH
2420: LD_VAR 0 2
2424: PUSH
2425: LD_EXP 56
2429: ADD
2430: ST_TO_ADDR
// end else
2431: GO 2449
// tmp := tmp ^ Stevens ;
2433: LD_ADDR_VAR 0 2
2437: PUSH
2438: LD_VAR 0 2
2442: PUSH
2443: LD_EXP 42
2447: ADD
2448: ST_TO_ADDR
// if not Lisa then
2449: LD_EXP 43
2453: NOT
2454: IFFALSE 2500
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2456: LD_ADDR_EXP 43
2460: PUSH
2461: LD_STRING Lisa
2463: PPUSH
2464: LD_EXP 1
2468: NOT
2469: PPUSH
2470: LD_STRING 13f_
2472: PPUSH
2473: CALL 67234 0 3
2477: ST_TO_ADDR
// if Lisa then
2478: LD_EXP 43
2482: IFFALSE 2500
// tmp := tmp ^ Lisa ;
2484: LD_ADDR_VAR 0 2
2488: PUSH
2489: LD_VAR 0 2
2493: PUSH
2494: LD_EXP 43
2498: ADD
2499: ST_TO_ADDR
// end ; if not Donaldson then
2500: LD_EXP 44
2504: NOT
2505: IFFALSE 2551
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2507: LD_ADDR_EXP 44
2511: PUSH
2512: LD_STRING Donaldson
2514: PPUSH
2515: LD_EXP 1
2519: NOT
2520: PPUSH
2521: LD_STRING 13f_
2523: PPUSH
2524: CALL 67234 0 3
2528: ST_TO_ADDR
// if Donaldson then
2529: LD_EXP 44
2533: IFFALSE 2551
// tmp := tmp ^ Donaldson ;
2535: LD_ADDR_VAR 0 2
2539: PUSH
2540: LD_VAR 0 2
2544: PUSH
2545: LD_EXP 44
2549: ADD
2550: ST_TO_ADDR
// end ; if not Bobby then
2551: LD_EXP 45
2555: NOT
2556: IFFALSE 2602
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2558: LD_ADDR_EXP 45
2562: PUSH
2563: LD_STRING Bobby
2565: PPUSH
2566: LD_EXP 1
2570: NOT
2571: PPUSH
2572: LD_STRING 13f_
2574: PPUSH
2575: CALL 67234 0 3
2579: ST_TO_ADDR
// if Bobby then
2580: LD_EXP 45
2584: IFFALSE 2602
// tmp := tmp ^ Bobby ;
2586: LD_ADDR_VAR 0 2
2590: PUSH
2591: LD_VAR 0 2
2595: PUSH
2596: LD_EXP 45
2600: ADD
2601: ST_TO_ADDR
// end ; if not Cyrus then
2602: LD_EXP 46
2606: NOT
2607: IFFALSE 2653
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2609: LD_ADDR_EXP 46
2613: PUSH
2614: LD_STRING Cyrus
2616: PPUSH
2617: LD_EXP 1
2621: NOT
2622: PPUSH
2623: LD_STRING 13f_
2625: PPUSH
2626: CALL 67234 0 3
2630: ST_TO_ADDR
// if Cyrus then
2631: LD_EXP 46
2635: IFFALSE 2653
// tmp := tmp ^ Cyrus ;
2637: LD_ADDR_VAR 0 2
2641: PUSH
2642: LD_VAR 0 2
2646: PUSH
2647: LD_EXP 46
2651: ADD
2652: ST_TO_ADDR
// end ; if not Brown then
2653: LD_EXP 48
2657: NOT
2658: IFFALSE 2704
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2660: LD_ADDR_EXP 48
2664: PUSH
2665: LD_STRING Brown
2667: PPUSH
2668: LD_EXP 1
2672: NOT
2673: PPUSH
2674: LD_STRING 13f_
2676: PPUSH
2677: CALL 67234 0 3
2681: ST_TO_ADDR
// if Brown then
2682: LD_EXP 48
2686: IFFALSE 2704
// tmp := tmp ^ Brown ;
2688: LD_ADDR_VAR 0 2
2692: PUSH
2693: LD_VAR 0 2
2697: PUSH
2698: LD_EXP 48
2702: ADD
2703: ST_TO_ADDR
// end ; if not Gladstone then
2704: LD_EXP 49
2708: NOT
2709: IFFALSE 2755
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2711: LD_ADDR_EXP 49
2715: PUSH
2716: LD_STRING Gladstone
2718: PPUSH
2719: LD_EXP 1
2723: NOT
2724: PPUSH
2725: LD_STRING 13f_
2727: PPUSH
2728: CALL 67234 0 3
2732: ST_TO_ADDR
// if Gladstone then
2733: LD_EXP 49
2737: IFFALSE 2755
// tmp := tmp ^ Gladstone ;
2739: LD_ADDR_VAR 0 2
2743: PUSH
2744: LD_VAR 0 2
2748: PUSH
2749: LD_EXP 49
2753: ADD
2754: ST_TO_ADDR
// end ; if not Houten then
2755: LD_EXP 50
2759: NOT
2760: IFFALSE 2806
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2762: LD_ADDR_EXP 50
2766: PUSH
2767: LD_STRING Houten
2769: PPUSH
2770: LD_EXP 1
2774: NOT
2775: PPUSH
2776: LD_STRING 13f_
2778: PPUSH
2779: CALL 67234 0 3
2783: ST_TO_ADDR
// if Houten then
2784: LD_EXP 50
2788: IFFALSE 2806
// tmp := tmp ^ Houten ;
2790: LD_ADDR_VAR 0 2
2794: PUSH
2795: LD_VAR 0 2
2799: PUSH
2800: LD_EXP 50
2804: ADD
2805: ST_TO_ADDR
// end ; if not Cornel then
2806: LD_EXP 51
2810: NOT
2811: IFFALSE 2857
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2813: LD_ADDR_EXP 51
2817: PUSH
2818: LD_STRING Cornell
2820: PPUSH
2821: LD_EXP 1
2825: NOT
2826: PPUSH
2827: LD_STRING 13f_
2829: PPUSH
2830: CALL 67234 0 3
2834: ST_TO_ADDR
// if Cornel then
2835: LD_EXP 51
2839: IFFALSE 2857
// tmp := tmp ^ Cornel ;
2841: LD_ADDR_VAR 0 2
2845: PUSH
2846: LD_VAR 0 2
2850: PUSH
2851: LD_EXP 51
2855: ADD
2856: ST_TO_ADDR
// end ; if not Gary then
2857: LD_EXP 52
2861: NOT
2862: IFFALSE 2908
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2864: LD_ADDR_EXP 52
2868: PUSH
2869: LD_STRING Gary
2871: PPUSH
2872: LD_EXP 1
2876: NOT
2877: PPUSH
2878: LD_STRING 13f_
2880: PPUSH
2881: CALL 67234 0 3
2885: ST_TO_ADDR
// if Gary then
2886: LD_EXP 52
2890: IFFALSE 2908
// tmp := tmp ^ Gary ;
2892: LD_ADDR_VAR 0 2
2896: PUSH
2897: LD_VAR 0 2
2901: PUSH
2902: LD_EXP 52
2906: ADD
2907: ST_TO_ADDR
// end ; if not Frank then
2908: LD_EXP 53
2912: NOT
2913: IFFALSE 2959
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2915: LD_ADDR_EXP 53
2919: PUSH
2920: LD_STRING Frank
2922: PPUSH
2923: LD_EXP 1
2927: NOT
2928: PPUSH
2929: LD_STRING 13f_
2931: PPUSH
2932: CALL 67234 0 3
2936: ST_TO_ADDR
// if Frank then
2937: LD_EXP 53
2941: IFFALSE 2959
// tmp := tmp ^ Frank ;
2943: LD_ADDR_VAR 0 2
2947: PUSH
2948: LD_VAR 0 2
2952: PUSH
2953: LD_EXP 53
2957: ADD
2958: ST_TO_ADDR
// end ; if not Kikuchi then
2959: LD_EXP 54
2963: NOT
2964: IFFALSE 3010
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2966: LD_ADDR_EXP 54
2970: PUSH
2971: LD_STRING Kikuchi
2973: PPUSH
2974: LD_EXP 1
2978: NOT
2979: PPUSH
2980: LD_STRING 13f_
2982: PPUSH
2983: CALL 67234 0 3
2987: ST_TO_ADDR
// if Kikuchi then
2988: LD_EXP 54
2992: IFFALSE 3010
// tmp := tmp ^ Kikuchi ;
2994: LD_ADDR_VAR 0 2
2998: PUSH
2999: LD_VAR 0 2
3003: PUSH
3004: LD_EXP 54
3008: ADD
3009: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3010: LD_ADDR_VAR 0 2
3014: PUSH
3015: LD_VAR 0 2
3019: PUSH
3020: LD_STRING 13_other_survivors
3022: PPUSH
3023: CALL_OW 31
3027: UNION
3028: ST_TO_ADDR
// result := tmp ;
3029: LD_ADDR_VAR 0 1
3033: PUSH
3034: LD_VAR 0 2
3038: ST_TO_ADDR
// end ; end_of_file
3039: LD_VAR 0 1
3043: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop , un ; begin
3044: LD_INT 0
3046: PPUSH
3047: PPUSH
3048: PPUSH
3049: PPUSH
3050: PPUSH
3051: PPUSH
3052: PPUSH
3053: PPUSH
3054: PPUSH
3055: PPUSH
3056: PPUSH
// uc_side := 4 ;
3057: LD_ADDR_OWVAR 20
3061: PUSH
3062: LD_INT 4
3064: ST_TO_ADDR
// uc_nation := 1 ;
3065: LD_ADDR_OWVAR 21
3069: PUSH
3070: LD_INT 1
3072: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3073: LD_INT 387
3075: PPUSH
3076: CALL_OW 274
3080: PPUSH
3081: LD_INT 1
3083: PPUSH
3084: LD_INT 3500
3086: PUSH
3087: LD_INT 3000
3089: PUSH
3090: LD_INT 2500
3092: PUSH
3093: LD_INT 2000
3095: PUSH
3096: EMPTY
3097: LIST
3098: LIST
3099: LIST
3100: LIST
3101: PUSH
3102: LD_OWVAR 67
3106: ARRAY
3107: PPUSH
3108: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3112: LD_INT 387
3114: PPUSH
3115: CALL_OW 274
3119: PPUSH
3120: LD_INT 2
3122: PPUSH
3123: LD_INT 400
3125: PPUSH
3126: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3130: LD_INT 387
3132: PPUSH
3133: CALL_OW 274
3137: PPUSH
3138: LD_INT 3
3140: PPUSH
3141: LD_INT 10
3143: PPUSH
3144: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3148: LD_ADDR_EXP 59
3152: PUSH
3153: LD_STRING Powell
3155: PPUSH
3156: CALL_OW 25
3160: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3161: LD_EXP 59
3165: PPUSH
3166: LD_INT 57
3168: PPUSH
3169: LD_INT 94
3171: PPUSH
3172: LD_INT 0
3174: PPUSH
3175: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3179: LD_EXP 59
3183: PPUSH
3184: LD_INT 58
3186: PPUSH
3187: LD_INT 94
3189: PPUSH
3190: CALL_OW 118
// vip := [ ] ;
3194: LD_ADDR_EXP 60
3198: PUSH
3199: EMPTY
3200: ST_TO_ADDR
// tmp := [ ] ;
3201: LD_ADDR_VAR 0 6
3205: PUSH
3206: EMPTY
3207: ST_TO_ADDR
// if JMMGirl <> 2 then
3208: LD_EXP 7
3212: PUSH
3213: LD_INT 2
3215: NONEQUAL
3216: IFFALSE 3240
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3218: LD_ADDR_EXP 43
3222: PUSH
3223: LD_STRING Lisa
3225: PPUSH
3226: LD_EXP 1
3230: NOT
3231: PPUSH
3232: LD_STRING 13s_
3234: PPUSH
3235: CALL 67234 0 3
3239: ST_TO_ADDR
// if Lisa then
3240: LD_EXP 43
3244: IFFALSE 3262
// tmp := tmp ^ Lisa ;
3246: LD_ADDR_VAR 0 6
3250: PUSH
3251: LD_VAR 0 6
3255: PUSH
3256: LD_EXP 43
3260: ADD
3261: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3262: LD_ADDR_EXP 44
3266: PUSH
3267: LD_STRING Donaldson
3269: PPUSH
3270: LD_EXP 1
3274: NOT
3275: PPUSH
3276: LD_STRING 13s_
3278: PPUSH
3279: CALL 67234 0 3
3283: ST_TO_ADDR
// if Donaldson then
3284: LD_EXP 44
3288: IFFALSE 3306
// tmp := tmp ^ Donaldson ;
3290: LD_ADDR_VAR 0 6
3294: PUSH
3295: LD_VAR 0 6
3299: PUSH
3300: LD_EXP 44
3304: ADD
3305: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3306: LD_ADDR_EXP 45
3310: PUSH
3311: LD_STRING Bobby
3313: PPUSH
3314: LD_EXP 1
3318: NOT
3319: PPUSH
3320: LD_STRING 13s_
3322: PPUSH
3323: CALL 67234 0 3
3327: ST_TO_ADDR
// if Bobby then
3328: LD_EXP 45
3332: IFFALSE 3350
// tmp := tmp ^ Bobby ;
3334: LD_ADDR_VAR 0 6
3338: PUSH
3339: LD_VAR 0 6
3343: PUSH
3344: LD_EXP 45
3348: ADD
3349: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3350: LD_ADDR_EXP 46
3354: PUSH
3355: LD_STRING Cyrus
3357: PPUSH
3358: LD_EXP 1
3362: NOT
3363: PPUSH
3364: LD_STRING 13s_
3366: PPUSH
3367: CALL 67234 0 3
3371: ST_TO_ADDR
// if Cyrus then
3372: LD_EXP 46
3376: IFFALSE 3394
// tmp := tmp ^ Cyrus ;
3378: LD_ADDR_VAR 0 6
3382: PUSH
3383: LD_VAR 0 6
3387: PUSH
3388: LD_EXP 46
3392: ADD
3393: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3394: LD_ADDR_EXP 47
3398: PUSH
3399: LD_STRING Denis
3401: PPUSH
3402: LD_EXP 1
3406: NOT
3407: PPUSH
3408: LD_STRING 13s_
3410: PPUSH
3411: CALL 67234 0 3
3415: ST_TO_ADDR
// if not Denis then
3416: LD_EXP 47
3420: NOT
3421: IFFALSE 3445
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3423: LD_ADDR_EXP 47
3427: PUSH
3428: LD_STRING Denis
3430: PPUSH
3431: LD_EXP 1
3435: NOT
3436: PPUSH
3437: LD_STRING 13f_
3439: PPUSH
3440: CALL 67234 0 3
3444: ST_TO_ADDR
// if Denis then
3445: LD_EXP 47
3449: IFFALSE 3467
// tmp := tmp ^ Denis ;
3451: LD_ADDR_VAR 0 6
3455: PUSH
3456: LD_VAR 0 6
3460: PUSH
3461: LD_EXP 47
3465: ADD
3466: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3467: LD_ADDR_EXP 48
3471: PUSH
3472: LD_STRING Brown
3474: PPUSH
3475: LD_EXP 1
3479: NOT
3480: PPUSH
3481: LD_STRING 13s_
3483: PPUSH
3484: CALL 67234 0 3
3488: ST_TO_ADDR
// if Brown then
3489: LD_EXP 48
3493: IFFALSE 3511
// tmp := tmp ^ Brown ;
3495: LD_ADDR_VAR 0 6
3499: PUSH
3500: LD_VAR 0 6
3504: PUSH
3505: LD_EXP 48
3509: ADD
3510: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3511: LD_ADDR_EXP 49
3515: PUSH
3516: LD_STRING Gladstone
3518: PPUSH
3519: LD_EXP 1
3523: NOT
3524: PPUSH
3525: LD_STRING 13s_
3527: PPUSH
3528: CALL 67234 0 3
3532: ST_TO_ADDR
// if Gladstone then
3533: LD_EXP 49
3537: IFFALSE 3555
// tmp := tmp ^ Gladstone ;
3539: LD_ADDR_VAR 0 6
3543: PUSH
3544: LD_VAR 0 6
3548: PUSH
3549: LD_EXP 49
3553: ADD
3554: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3555: LD_ADDR_EXP 50
3559: PUSH
3560: LD_STRING Houten
3562: PPUSH
3563: LD_EXP 1
3567: NOT
3568: PPUSH
3569: LD_STRING 13s_
3571: PPUSH
3572: CALL 67234 0 3
3576: ST_TO_ADDR
// if Houten then
3577: LD_EXP 50
3581: IFFALSE 3599
// tmp := tmp ^ Houten ;
3583: LD_ADDR_VAR 0 6
3587: PUSH
3588: LD_VAR 0 6
3592: PUSH
3593: LD_EXP 50
3597: ADD
3598: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3599: LD_ADDR_EXP 51
3603: PUSH
3604: LD_STRING Cornel
3606: PPUSH
3607: LD_EXP 1
3611: NOT
3612: PPUSH
3613: LD_STRING 13s_
3615: PPUSH
3616: CALL 67234 0 3
3620: ST_TO_ADDR
// if Cornel then
3621: LD_EXP 51
3625: IFFALSE 3643
// tmp := tmp ^ Cornel ;
3627: LD_ADDR_VAR 0 6
3631: PUSH
3632: LD_VAR 0 6
3636: PUSH
3637: LD_EXP 51
3641: ADD
3642: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3643: LD_ADDR_EXP 52
3647: PUSH
3648: LD_STRING Gary
3650: PPUSH
3651: LD_EXP 1
3655: NOT
3656: PPUSH
3657: LD_STRING 13s_
3659: PPUSH
3660: CALL 67234 0 3
3664: ST_TO_ADDR
// if Gary then
3665: LD_EXP 52
3669: IFFALSE 3687
// tmp := tmp ^ Gary ;
3671: LD_ADDR_VAR 0 6
3675: PUSH
3676: LD_VAR 0 6
3680: PUSH
3681: LD_EXP 52
3685: ADD
3686: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3687: LD_ADDR_EXP 53
3691: PUSH
3692: LD_STRING Frank
3694: PPUSH
3695: LD_EXP 1
3699: NOT
3700: PPUSH
3701: LD_STRING 13s_
3703: PPUSH
3704: CALL 67234 0 3
3708: ST_TO_ADDR
// if Frank then
3709: LD_EXP 53
3713: IFFALSE 3731
// tmp := tmp ^ Frank ;
3715: LD_ADDR_VAR 0 6
3719: PUSH
3720: LD_VAR 0 6
3724: PUSH
3725: LD_EXP 53
3729: ADD
3730: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3731: LD_ADDR_EXP 54
3735: PUSH
3736: LD_STRING Kikuchi
3738: PPUSH
3739: LD_EXP 1
3743: NOT
3744: PPUSH
3745: LD_STRING 13s_
3747: PPUSH
3748: CALL 67234 0 3
3752: ST_TO_ADDR
// if Kikuchi then
3753: LD_EXP 54
3757: IFFALSE 3775
// tmp := tmp ^ Kikuchi ;
3759: LD_ADDR_VAR 0 6
3763: PUSH
3764: LD_VAR 0 6
3768: PUSH
3769: LD_EXP 54
3773: ADD
3774: ST_TO_ADDR
// vip := tmp ;
3775: LD_ADDR_EXP 60
3779: PUSH
3780: LD_VAR 0 6
3784: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3785: LD_ADDR_VAR 0 6
3789: PUSH
3790: LD_VAR 0 6
3794: PUSH
3795: LD_STRING 13s_others
3797: PPUSH
3798: CALL_OW 31
3802: UNION
3803: ST_TO_ADDR
// if tmp < 18 then
3804: LD_VAR 0 6
3808: PUSH
3809: LD_INT 18
3811: LESS
3812: IFFALSE 3905
// for i = 1 to 18 - tmp do
3814: LD_ADDR_VAR 0 2
3818: PUSH
3819: DOUBLE
3820: LD_INT 1
3822: DEC
3823: ST_TO_ADDR
3824: LD_INT 18
3826: PUSH
3827: LD_VAR 0 6
3831: MINUS
3832: PUSH
3833: FOR_TO
3834: IFFALSE 3903
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
3836: LD_INT 1
3838: PPUSH
3839: LD_VAR 0 2
3843: PUSH
3844: LD_INT 4
3846: MOD
3847: PUSH
3848: LD_INT 1
3850: PLUS
3851: PPUSH
3852: LD_INT 4
3854: PPUSH
3855: CALL_OW 380
// un := CreateHuman ;
3859: LD_ADDR_VAR 0 11
3863: PUSH
3864: CALL_OW 44
3868: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
3869: LD_ADDR_VAR 0 6
3873: PUSH
3874: LD_VAR 0 6
3878: PPUSH
3879: LD_VAR 0 11
3883: PPUSH
3884: CALL 104683 0 2
3888: ST_TO_ADDR
// SetTag ( un , 1 ) ;
3889: LD_VAR 0 11
3893: PPUSH
3894: LD_INT 1
3896: PPUSH
3897: CALL_OW 109
// end ;
3901: GO 3833
3903: POP
3904: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3905: LD_ADDR_VAR 0 7
3909: PUSH
3910: LD_INT 22
3912: PUSH
3913: LD_INT 4
3915: PUSH
3916: EMPTY
3917: LIST
3918: LIST
3919: PUSH
3920: LD_INT 30
3922: PUSH
3923: LD_INT 0
3925: PUSH
3926: EMPTY
3927: LIST
3928: LIST
3929: PUSH
3930: EMPTY
3931: LIST
3932: LIST
3933: PPUSH
3934: CALL_OW 69
3938: PUSH
3939: LD_INT 1
3941: ARRAY
3942: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3943: LD_ADDR_VAR 0 8
3947: PUSH
3948: LD_INT 22
3950: PUSH
3951: LD_INT 4
3953: PUSH
3954: EMPTY
3955: LIST
3956: LIST
3957: PUSH
3958: LD_INT 30
3960: PUSH
3961: LD_INT 6
3963: PUSH
3964: EMPTY
3965: LIST
3966: LIST
3967: PUSH
3968: EMPTY
3969: LIST
3970: LIST
3971: PPUSH
3972: CALL_OW 69
3976: PUSH
3977: LD_INT 1
3979: ARRAY
3980: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3981: LD_ADDR_VAR 0 9
3985: PUSH
3986: LD_INT 22
3988: PUSH
3989: LD_INT 4
3991: PUSH
3992: EMPTY
3993: LIST
3994: LIST
3995: PUSH
3996: LD_INT 30
3998: PUSH
3999: LD_INT 4
4001: PUSH
4002: EMPTY
4003: LIST
4004: LIST
4005: PUSH
4006: EMPTY
4007: LIST
4008: LIST
4009: PPUSH
4010: CALL_OW 69
4014: PUSH
4015: LD_INT 1
4017: ARRAY
4018: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
4019: LD_ADDR_VAR 0 10
4023: PUSH
4024: LD_INT 22
4026: PUSH
4027: LD_INT 4
4029: PUSH
4030: EMPTY
4031: LIST
4032: LIST
4033: PUSH
4034: LD_INT 30
4036: PUSH
4037: LD_INT 2
4039: PUSH
4040: EMPTY
4041: LIST
4042: LIST
4043: PUSH
4044: EMPTY
4045: LIST
4046: LIST
4047: PPUSH
4048: CALL_OW 69
4052: PUSH
4053: LD_INT 1
4055: ARRAY
4056: ST_TO_ADDR
// for i in tmp do
4057: LD_ADDR_VAR 0 2
4061: PUSH
4062: LD_VAR 0 6
4066: PUSH
4067: FOR_IN
4068: IFFALSE 4194
// begin cl := GetClass ( i ) ;
4070: LD_ADDR_VAR 0 5
4074: PUSH
4075: LD_VAR 0 2
4079: PPUSH
4080: CALL_OW 257
4084: ST_TO_ADDR
// if cl > 4 then
4085: LD_VAR 0 5
4089: PUSH
4090: LD_INT 4
4092: GREATER
4093: IFFALSE 4103
// cl := 1 ;
4095: LD_ADDR_VAR 0 5
4099: PUSH
4100: LD_INT 1
4102: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
4103: LD_ADDR_VAR 0 3
4107: PUSH
4108: LD_VAR 0 9
4112: PUSH
4113: LD_VAR 0 7
4117: PUSH
4118: LD_VAR 0 10
4122: PUSH
4123: LD_VAR 0 8
4127: PUSH
4128: EMPTY
4129: LIST
4130: LIST
4131: LIST
4132: LIST
4133: PUSH
4134: LD_VAR 0 5
4138: ARRAY
4139: ST_TO_ADDR
// if UnitsInside ( b ) < 6 then
4140: LD_VAR 0 3
4144: PPUSH
4145: CALL_OW 313
4149: PUSH
4150: LD_INT 6
4152: LESS
4153: IFFALSE 4171
// PlaceHumanInUnit ( i , b ) else
4155: LD_VAR 0 2
4159: PPUSH
4160: LD_VAR 0 3
4164: PPUSH
4165: CALL_OW 52
4169: GO 4192
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4171: LD_VAR 0 2
4175: PPUSH
4176: LD_INT 61
4178: PPUSH
4179: LD_INT 89
4181: PPUSH
4182: LD_INT 8
4184: PPUSH
4185: LD_INT 0
4187: PPUSH
4188: CALL_OW 50
// end ;
4192: GO 4067
4194: POP
4195: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4196: LD_INT 2
4198: PPUSH
4199: LD_INT 1
4201: PPUSH
4202: LD_INT 1
4204: PPUSH
4205: LD_INT 12
4207: PPUSH
4208: LD_INT 100
4210: PPUSH
4211: CALL 72249 0 5
// veh := CreateVehicle ;
4215: LD_ADDR_VAR 0 4
4219: PUSH
4220: CALL_OW 45
4224: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4225: LD_VAR 0 4
4229: PPUSH
4230: LD_INT 4
4232: PPUSH
4233: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4237: LD_VAR 0 4
4241: PPUSH
4242: LD_INT 49
4244: PPUSH
4245: LD_INT 88
4247: PPUSH
4248: LD_INT 0
4250: PPUSH
4251: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4255: LD_VAR 0 4
4259: PPUSH
4260: LD_INT 1
4262: PPUSH
4263: LD_INT 100
4265: PPUSH
4266: CALL_OW 290
// uc_side := 0 ;
4270: LD_ADDR_OWVAR 20
4274: PUSH
4275: LD_INT 0
4277: ST_TO_ADDR
// uc_nation := 0 ;
4278: LD_ADDR_OWVAR 21
4282: PUSH
4283: LD_INT 0
4285: ST_TO_ADDR
// for i := 1 to 3 do
4286: LD_ADDR_VAR 0 2
4290: PUSH
4291: DOUBLE
4292: LD_INT 1
4294: DEC
4295: ST_TO_ADDR
4296: LD_INT 3
4298: PUSH
4299: FOR_TO
4300: IFFALSE 4331
// begin InitHc ;
4302: CALL_OW 19
// hc_class := class_apeman ;
4306: LD_ADDR_OWVAR 28
4310: PUSH
4311: LD_INT 12
4313: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4314: CALL_OW 44
4318: PPUSH
4319: LD_INT 13
4321: PPUSH
4322: LD_INT 0
4324: PPUSH
4325: CALL_OW 49
// end ;
4329: GO 4299
4331: POP
4332: POP
// end ; end_of_file
4333: LD_VAR 0 1
4337: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4338: LD_INT 0
4340: PPUSH
4341: PPUSH
4342: PPUSH
4343: PPUSH
4344: PPUSH
// side := 8 ;
4345: LD_ADDR_VAR 0 3
4349: PUSH
4350: LD_INT 8
4352: ST_TO_ADDR
// uc_side := side ;
4353: LD_ADDR_OWVAR 20
4357: PUSH
4358: LD_VAR 0 3
4362: ST_TO_ADDR
// uc_nation := 2 ;
4363: LD_ADDR_OWVAR 21
4367: PUSH
4368: LD_INT 2
4370: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4371: LD_ADDR_VAR 0 2
4375: PUSH
4376: LD_INT 22
4378: PUSH
4379: LD_VAR 0 3
4383: PUSH
4384: EMPTY
4385: LIST
4386: LIST
4387: PUSH
4388: LD_INT 21
4390: PUSH
4391: LD_INT 3
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PPUSH
4402: CALL_OW 69
4406: PUSH
4407: FOR_IN
4408: IFFALSE 4424
// SetBLevel ( i , 10 ) ;
4410: LD_VAR 0 2
4414: PPUSH
4415: LD_INT 10
4417: PPUSH
4418: CALL_OW 241
4422: GO 4407
4424: POP
4425: POP
// if KurtStatus then
4426: LD_EXP 3
4430: IFFALSE 4453
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4432: LD_ADDR_EXP 61
4436: PUSH
4437: LD_STRING Kurt
4439: PPUSH
4440: LD_INT 0
4442: PPUSH
4443: LD_STRING 
4445: PPUSH
4446: CALL 67234 0 3
4450: ST_TO_ADDR
4451: GO 4475
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4453: LD_ADDR_EXP 61
4457: PUSH
4458: LD_STRING AltKurt
4460: PPUSH
4461: LD_EXP 1
4465: NOT
4466: PPUSH
4467: LD_STRING 
4469: PPUSH
4470: CALL 67234 0 3
4474: ST_TO_ADDR
// if not Kurt then
4475: LD_EXP 61
4479: NOT
4480: IFFALSE 4506
// begin InitHc ;
4482: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4486: LD_INT 1
4488: PPUSH
4489: LD_INT 10
4491: PPUSH
4492: CALL_OW 381
// Kurt := CreateHuman ;
4496: LD_ADDR_EXP 61
4500: PUSH
4501: CALL_OW 44
4505: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4506: LD_EXP 61
4510: PPUSH
4511: LD_INT 324
4513: PPUSH
4514: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4518: LD_ADDR_EXP 62
4522: PUSH
4523: LD_STRING Kozlov
4525: PPUSH
4526: LD_INT 0
4528: PPUSH
4529: LD_STRING 
4531: PPUSH
4532: CALL 67234 0 3
4536: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4537: LD_EXP 62
4541: PPUSH
4542: LD_INT 22
4544: PUSH
4545: LD_INT 8
4547: PUSH
4548: EMPTY
4549: LIST
4550: LIST
4551: PUSH
4552: LD_INT 23
4554: PUSH
4555: LD_INT 3
4557: PUSH
4558: EMPTY
4559: LIST
4560: LIST
4561: PUSH
4562: LD_INT 30
4564: PUSH
4565: LD_INT 8
4567: PUSH
4568: EMPTY
4569: LIST
4570: LIST
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: LIST
4576: PPUSH
4577: CALL_OW 69
4581: PUSH
4582: LD_INT 1
4584: ARRAY
4585: PPUSH
4586: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4590: LD_EXP 62
4594: PPUSH
4595: LD_INT 3
4597: PPUSH
4598: LD_INT 10
4600: PPUSH
4601: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4605: LD_EXP 62
4609: PPUSH
4610: LD_INT 4
4612: PPUSH
4613: LD_INT 10
4615: PPUSH
4616: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4620: LD_ADDR_VAR 0 5
4624: PUSH
4625: LD_INT 22
4627: PUSH
4628: LD_VAR 0 3
4632: PUSH
4633: EMPTY
4634: LIST
4635: LIST
4636: PUSH
4637: LD_INT 30
4639: PUSH
4640: LD_INT 32
4642: PUSH
4643: EMPTY
4644: LIST
4645: LIST
4646: PUSH
4647: LD_INT 58
4649: PUSH
4650: EMPTY
4651: LIST
4652: PUSH
4653: EMPTY
4654: LIST
4655: LIST
4656: LIST
4657: PPUSH
4658: CALL_OW 69
4662: ST_TO_ADDR
// for i = 1 to 10 do
4663: LD_ADDR_VAR 0 2
4667: PUSH
4668: DOUBLE
4669: LD_INT 1
4671: DEC
4672: ST_TO_ADDR
4673: LD_INT 10
4675: PUSH
4676: FOR_TO
4677: IFFALSE 4749
// begin uc_nation := nation_nature ;
4679: LD_ADDR_OWVAR 21
4683: PUSH
4684: LD_INT 0
4686: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4687: LD_ADDR_OWVAR 28
4691: PUSH
4692: LD_INT 15
4694: ST_TO_ADDR
// hc_gallery :=  ;
4695: LD_ADDR_OWVAR 33
4699: PUSH
4700: LD_STRING 
4702: ST_TO_ADDR
// hc_name :=  ;
4703: LD_ADDR_OWVAR 26
4707: PUSH
4708: LD_STRING 
4710: ST_TO_ADDR
// un := CreateHuman ;
4711: LD_ADDR_VAR 0 4
4715: PUSH
4716: CALL_OW 44
4720: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4721: LD_VAR 0 4
4725: PPUSH
4726: LD_VAR 0 5
4730: PUSH
4731: LD_VAR 0 5
4735: PUSH
4736: LD_VAR 0 2
4740: MINUS
4741: ARRAY
4742: PPUSH
4743: CALL_OW 52
// end ;
4747: GO 4676
4749: POP
4750: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4751: LD_ADDR_VAR 0 5
4755: PUSH
4756: LD_STRING 12_kurt_squad
4758: PPUSH
4759: CALL_OW 31
4763: ST_TO_ADDR
// if tmp then
4764: LD_VAR 0 5
4768: IFFALSE 4802
// for i in tmp do
4770: LD_ADDR_VAR 0 2
4774: PUSH
4775: LD_VAR 0 5
4779: PUSH
4780: FOR_IN
4781: IFFALSE 4800
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4783: LD_VAR 0 2
4787: PPUSH
4788: LD_INT 5
4790: PPUSH
4791: LD_INT 0
4793: PPUSH
4794: CALL_OW 49
4798: GO 4780
4800: POP
4801: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4802: LD_INT 324
4804: PPUSH
4805: LD_INT 5
4807: PPUSH
4808: LD_STRING 
4810: PPUSH
4811: LD_INT 8
4813: PUSH
4814: LD_INT 9
4816: PUSH
4817: LD_INT 10
4819: PUSH
4820: LD_INT 10
4822: PUSH
4823: EMPTY
4824: LIST
4825: LIST
4826: LIST
4827: LIST
4828: PUSH
4829: LD_OWVAR 67
4833: ARRAY
4834: PPUSH
4835: LD_INT 3000
4837: PUSH
4838: LD_INT 500
4840: PUSH
4841: LD_INT 150
4843: PUSH
4844: EMPTY
4845: LIST
4846: LIST
4847: LIST
4848: PPUSH
4849: LD_INT 16
4851: PUSH
4852: LD_INT 6
4854: PUSH
4855: LD_INT 6
4857: PUSH
4858: LD_INT 8
4860: PUSH
4861: EMPTY
4862: LIST
4863: LIST
4864: LIST
4865: LIST
4866: PPUSH
4867: CALL 75693 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4871: LD_ADDR_EXP 99
4875: PUSH
4876: LD_EXP 99
4880: PPUSH
4881: LD_INT 3
4883: PPUSH
4884: LD_INT 22
4886: PUSH
4887: LD_VAR 0 3
4891: PUSH
4892: EMPTY
4893: LIST
4894: LIST
4895: PUSH
4896: LD_INT 23
4898: PUSH
4899: LD_INT 2
4901: PUSH
4902: EMPTY
4903: LIST
4904: LIST
4905: PUSH
4906: LD_INT 3
4908: PUSH
4909: LD_INT 21
4911: PUSH
4912: LD_INT 2
4914: PUSH
4915: EMPTY
4916: LIST
4917: LIST
4918: PUSH
4919: EMPTY
4920: LIST
4921: LIST
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: LIST
4927: PPUSH
4928: CALL_OW 69
4932: PUSH
4933: LD_EXP 61
4937: DIFF
4938: PPUSH
4939: CALL_OW 1
4943: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4944: LD_INT 1
4946: PPUSH
4947: LD_INT 7
4949: PPUSH
4950: CALL_OW 383
// Friend := CreateHuman ;
4954: LD_ADDR_EXP 63
4958: PUSH
4959: CALL_OW 44
4963: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4964: LD_INT 14
4966: PPUSH
4967: LD_INT 3
4969: PPUSH
4970: LD_INT 1
4972: PPUSH
4973: LD_INT 29
4975: PPUSH
4976: LD_INT 100
4978: PPUSH
4979: CALL 72249 0 5
// powellBomb := CreateVehicle ;
4983: LD_ADDR_EXP 64
4987: PUSH
4988: CALL_OW 45
4992: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4993: LD_EXP 64
4997: PPUSH
4998: LD_INT 90
5000: PPUSH
5001: LD_INT 51
5003: PPUSH
5004: LD_INT 0
5006: PPUSH
5007: CALL_OW 48
// end ;
5011: LD_VAR 0 1
5015: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
5016: LD_INT 0
5018: PPUSH
5019: PPUSH
5020: PPUSH
// if IsLive ( kozlov_fac ) then
5021: LD_INT 332
5023: PPUSH
5024: CALL_OW 300
5028: IFFALSE 5032
// exit ;
5030: GO 5599
// ComExitBuilding ( Kozlov ) ;
5032: LD_EXP 62
5036: PPUSH
5037: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
5041: LD_EXP 62
5045: PPUSH
5046: CALL_OW 257
5050: PUSH
5051: LD_INT 2
5053: NONEQUAL
5054: IFFALSE 5089
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
5056: LD_EXP 62
5060: PPUSH
5061: LD_INT 324
5063: PPUSH
5064: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
5068: LD_EXP 62
5072: PPUSH
5073: LD_INT 2
5075: PPUSH
5076: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
5080: LD_EXP 62
5084: PPUSH
5085: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
5089: LD_EXP 62
5093: PPUSH
5094: LD_INT 2
5096: PPUSH
5097: LD_INT 93
5099: PPUSH
5100: LD_INT 32
5102: PPUSH
5103: LD_INT 3
5105: PPUSH
5106: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5110: LD_INT 35
5112: PPUSH
5113: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5117: LD_INT 22
5119: PUSH
5120: LD_INT 8
5122: PUSH
5123: EMPTY
5124: LIST
5125: LIST
5126: PUSH
5127: LD_INT 30
5129: PUSH
5130: LD_INT 3
5132: PUSH
5133: EMPTY
5134: LIST
5135: LIST
5136: PUSH
5137: LD_INT 23
5139: PUSH
5140: LD_INT 3
5142: PUSH
5143: EMPTY
5144: LIST
5145: LIST
5146: PUSH
5147: LD_INT 57
5149: PUSH
5150: EMPTY
5151: LIST
5152: PUSH
5153: EMPTY
5154: LIST
5155: LIST
5156: LIST
5157: LIST
5158: PPUSH
5159: CALL_OW 69
5163: IFFALSE 5110
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5165: LD_ADDR_VAR 0 2
5169: PUSH
5170: LD_INT 22
5172: PUSH
5173: LD_INT 8
5175: PUSH
5176: EMPTY
5177: LIST
5178: LIST
5179: PUSH
5180: LD_INT 30
5182: PUSH
5183: LD_INT 3
5185: PUSH
5186: EMPTY
5187: LIST
5188: LIST
5189: PUSH
5190: LD_INT 23
5192: PUSH
5193: LD_INT 3
5195: PUSH
5196: EMPTY
5197: LIST
5198: LIST
5199: PUSH
5200: LD_INT 57
5202: PUSH
5203: EMPTY
5204: LIST
5205: PUSH
5206: EMPTY
5207: LIST
5208: LIST
5209: LIST
5210: LIST
5211: PPUSH
5212: CALL_OW 69
5216: PUSH
5217: LD_INT 1
5219: ARRAY
5220: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5221: LD_INT 22
5223: PUSH
5224: LD_INT 8
5226: PUSH
5227: EMPTY
5228: LIST
5229: LIST
5230: PUSH
5231: LD_INT 23
5233: PUSH
5234: LD_INT 3
5236: PUSH
5237: EMPTY
5238: LIST
5239: LIST
5240: PUSH
5241: LD_INT 30
5243: PUSH
5244: LD_INT 21
5246: PUSH
5247: EMPTY
5248: LIST
5249: LIST
5250: PUSH
5251: EMPTY
5252: LIST
5253: LIST
5254: LIST
5255: PPUSH
5256: CALL_OW 69
5260: NOT
5261: IFFALSE 5339
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5263: LD_EXP 62
5267: PPUSH
5268: LD_INT 21
5270: PPUSH
5271: LD_INT 97
5273: PPUSH
5274: LD_INT 36
5276: PPUSH
5277: LD_INT 5
5279: PPUSH
5280: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5284: LD_INT 35
5286: PPUSH
5287: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5291: LD_INT 22
5293: PUSH
5294: LD_INT 8
5296: PUSH
5297: EMPTY
5298: LIST
5299: LIST
5300: PUSH
5301: LD_INT 23
5303: PUSH
5304: LD_INT 3
5306: PUSH
5307: EMPTY
5308: LIST
5309: LIST
5310: PUSH
5311: LD_INT 30
5313: PUSH
5314: LD_INT 21
5316: PUSH
5317: EMPTY
5318: LIST
5319: LIST
5320: PUSH
5321: LD_INT 57
5323: PUSH
5324: EMPTY
5325: LIST
5326: PUSH
5327: EMPTY
5328: LIST
5329: LIST
5330: LIST
5331: LIST
5332: PPUSH
5333: CALL_OW 69
5337: IFFALSE 5284
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5339: LD_INT 22
5341: PUSH
5342: LD_INT 8
5344: PUSH
5345: EMPTY
5346: LIST
5347: LIST
5348: PUSH
5349: LD_INT 23
5351: PUSH
5352: LD_INT 3
5354: PUSH
5355: EMPTY
5356: LIST
5357: LIST
5358: PUSH
5359: LD_INT 30
5361: PUSH
5362: LD_INT 18
5364: PUSH
5365: EMPTY
5366: LIST
5367: LIST
5368: PUSH
5369: EMPTY
5370: LIST
5371: LIST
5372: LIST
5373: PPUSH
5374: CALL_OW 69
5378: NOT
5379: IFFALSE 5457
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5381: LD_EXP 62
5385: PPUSH
5386: LD_INT 18
5388: PPUSH
5389: LD_INT 89
5391: PPUSH
5392: LD_INT 32
5394: PPUSH
5395: LD_INT 1
5397: PPUSH
5398: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5402: LD_INT 35
5404: PPUSH
5405: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5409: LD_INT 22
5411: PUSH
5412: LD_INT 8
5414: PUSH
5415: EMPTY
5416: LIST
5417: LIST
5418: PUSH
5419: LD_INT 23
5421: PUSH
5422: LD_INT 3
5424: PUSH
5425: EMPTY
5426: LIST
5427: LIST
5428: PUSH
5429: LD_INT 30
5431: PUSH
5432: LD_INT 18
5434: PUSH
5435: EMPTY
5436: LIST
5437: LIST
5438: PUSH
5439: LD_INT 57
5441: PUSH
5442: EMPTY
5443: LIST
5444: PUSH
5445: EMPTY
5446: LIST
5447: LIST
5448: LIST
5449: LIST
5450: PPUSH
5451: CALL_OW 69
5455: IFFALSE 5402
// end ; lab := kozlov_lab ;
5457: LD_ADDR_VAR 0 3
5461: PUSH
5462: LD_INT 336
5464: ST_TO_ADDR
// if not lab then
5465: LD_VAR 0 3
5469: NOT
5470: IFFALSE 5474
// exit ;
5472: GO 5599
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5474: LD_EXP 62
5478: PPUSH
5479: LD_VAR 0 3
5483: PUSH
5484: LD_INT 1
5486: ARRAY
5487: PPUSH
5488: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5492: LD_EXP 62
5496: PPUSH
5497: LD_INT 4
5499: PPUSH
5500: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5504: LD_VAR 0 3
5508: PUSH
5509: LD_INT 1
5511: ARRAY
5512: PPUSH
5513: LD_INT 25
5515: PPUSH
5516: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5520: LD_INT 35
5522: PPUSH
5523: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5527: LD_INT 25
5529: PPUSH
5530: LD_INT 8
5532: PPUSH
5533: CALL_OW 321
5537: PUSH
5538: LD_INT 2
5540: EQUAL
5541: IFFALSE 5520
// ComExitBuilding ( Kozlov ) ;
5543: LD_EXP 62
5547: PPUSH
5548: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5552: LD_EXP 62
5556: PPUSH
5557: LD_VAR 0 2
5561: PPUSH
5562: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5566: LD_EXP 62
5570: PPUSH
5571: LD_INT 3
5573: PPUSH
5574: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5578: LD_VAR 0 2
5582: PPUSH
5583: LD_INT 23
5585: PPUSH
5586: LD_INT 3
5588: PPUSH
5589: LD_INT 1
5591: PPUSH
5592: LD_INT 48
5594: PPUSH
5595: CALL_OW 125
// end ;
5599: LD_VAR 0 1
5603: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5604: LD_EXP 22
5608: NOT
5609: PUSH
5610: LD_EXP 15
5614: PUSH
5615: LD_INT 6
5617: GREATEREQUAL
5618: AND
5619: IFFALSE 5700
5621: GO 5623
5623: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5624: LD_INT 3
5626: PPUSH
5627: LD_INT 3
5629: PPUSH
5630: CALL 60983 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5634: LD_INT 3
5636: PPUSH
5637: LD_INT 14
5639: PUSH
5640: LD_INT 1
5642: PUSH
5643: LD_INT 1
5645: PUSH
5646: LD_INT 28
5648: PUSH
5649: EMPTY
5650: LIST
5651: LIST
5652: LIST
5653: LIST
5654: PUSH
5655: LD_INT 14
5657: PUSH
5658: LD_INT 1
5660: PUSH
5661: LD_INT 1
5663: PUSH
5664: LD_INT 28
5666: PUSH
5667: EMPTY
5668: LIST
5669: LIST
5670: LIST
5671: LIST
5672: PUSH
5673: LD_INT 14
5675: PUSH
5676: LD_INT 1
5678: PUSH
5679: LD_INT 1
5681: PUSH
5682: LD_INT 28
5684: PUSH
5685: EMPTY
5686: LIST
5687: LIST
5688: LIST
5689: LIST
5690: PUSH
5691: EMPTY
5692: LIST
5693: LIST
5694: LIST
5695: PPUSH
5696: CALL 60846 0 2
// end ;
5700: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5701: LD_EXP 22
5705: NOT
5706: PUSH
5707: LD_EXP 15
5711: PUSH
5712: LD_INT 6
5714: GREATEREQUAL
5715: AND
5716: PUSH
5717: LD_INT 3
5719: PPUSH
5720: LD_INT 1
5722: PPUSH
5723: CALL 62264 0 2
5727: NOT
5728: AND
5729: IFFALSE 6585
5731: GO 5733
5733: DISABLE
5734: LD_INT 0
5736: PPUSH
5737: PPUSH
5738: PPUSH
// begin enable ;
5739: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5740: LD_INT 22
5742: PUSH
5743: LD_INT 8
5745: PUSH
5746: EMPTY
5747: LIST
5748: LIST
5749: PUSH
5750: LD_INT 23
5752: PUSH
5753: LD_INT 2
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: PUSH
5760: LD_INT 30
5762: PUSH
5763: LD_INT 3
5765: PUSH
5766: EMPTY
5767: LIST
5768: LIST
5769: PUSH
5770: EMPTY
5771: LIST
5772: LIST
5773: LIST
5774: PPUSH
5775: CALL_OW 69
5779: NOT
5780: IFFALSE 5784
// exit ;
5782: GO 6585
// if Prob ( 40 ) then
5784: LD_INT 40
5786: PPUSH
5787: CALL_OW 13
5791: IFFALSE 5918
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5793: LD_INT 3
5795: PPUSH
5796: LD_INT 14
5798: PUSH
5799: LD_INT 1
5801: PUSH
5802: LD_INT 2
5804: PUSH
5805: LD_INT 28
5807: PUSH
5808: EMPTY
5809: LIST
5810: LIST
5811: LIST
5812: LIST
5813: PUSH
5814: LD_INT 14
5816: PUSH
5817: LD_INT 1
5819: PUSH
5820: LD_INT 2
5822: PUSH
5823: LD_INT 28
5825: PUSH
5826: EMPTY
5827: LIST
5828: LIST
5829: LIST
5830: LIST
5831: PUSH
5832: LD_INT 14
5834: PUSH
5835: LD_INT 1
5837: PUSH
5838: LD_INT 2
5840: PUSH
5841: LD_INT 28
5843: PUSH
5844: EMPTY
5845: LIST
5846: LIST
5847: LIST
5848: LIST
5849: PUSH
5850: LD_INT 14
5852: PUSH
5853: LD_INT 1
5855: PUSH
5856: LD_INT 2
5858: PUSH
5859: LD_INT 28
5861: PUSH
5862: EMPTY
5863: LIST
5864: LIST
5865: LIST
5866: LIST
5867: PUSH
5868: LD_INT 14
5870: PUSH
5871: LD_INT 1
5873: PUSH
5874: LD_INT 2
5876: PUSH
5877: LD_INT 28
5879: PUSH
5880: EMPTY
5881: LIST
5882: LIST
5883: LIST
5884: LIST
5885: PUSH
5886: LD_INT 14
5888: PUSH
5889: LD_INT 1
5891: PUSH
5892: LD_INT 2
5894: PUSH
5895: LD_INT 26
5897: PUSH
5898: EMPTY
5899: LIST
5900: LIST
5901: LIST
5902: LIST
5903: PUSH
5904: EMPTY
5905: LIST
5906: LIST
5907: LIST
5908: LIST
5909: LIST
5910: LIST
5911: PPUSH
5912: CALL 60846 0 2
// end else
5916: GO 6125
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5918: LD_INT 3
5920: PPUSH
5921: LD_INT 14
5923: PUSH
5924: LD_INT 1
5926: PUSH
5927: LD_INT 2
5929: PUSH
5930: LD_INT 27
5932: PUSH
5933: LD_INT 26
5935: PUSH
5936: LD_INT 26
5938: PUSH
5939: LD_INT 28
5941: PUSH
5942: EMPTY
5943: LIST
5944: LIST
5945: LIST
5946: LIST
5947: PUSH
5948: LD_OWVAR 67
5952: ARRAY
5953: PUSH
5954: EMPTY
5955: LIST
5956: LIST
5957: LIST
5958: LIST
5959: PUSH
5960: LD_INT 14
5962: PUSH
5963: LD_INT 1
5965: PUSH
5966: LD_INT 2
5968: PUSH
5969: LD_INT 27
5971: PUSH
5972: LD_INT 26
5974: PUSH
5975: LD_INT 26
5977: PUSH
5978: LD_INT 26
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: LIST
5985: LIST
5986: PUSH
5987: LD_OWVAR 67
5991: ARRAY
5992: PUSH
5993: EMPTY
5994: LIST
5995: LIST
5996: LIST
5997: LIST
5998: PUSH
5999: LD_INT 14
6001: PUSH
6002: LD_INT 1
6004: PUSH
6005: LD_INT 2
6007: PUSH
6008: LD_INT 26
6010: PUSH
6011: LD_INT 26
6013: PUSH
6014: LD_INT 29
6016: PUSH
6017: LD_INT 29
6019: PUSH
6020: EMPTY
6021: LIST
6022: LIST
6023: LIST
6024: LIST
6025: PUSH
6026: LD_OWVAR 67
6030: ARRAY
6031: PUSH
6032: EMPTY
6033: LIST
6034: LIST
6035: LIST
6036: LIST
6037: PUSH
6038: LD_INT 13
6040: PUSH
6041: LD_INT 1
6043: PUSH
6044: LD_INT 2
6046: PUSH
6047: LD_INT 26
6049: PUSH
6050: LD_INT 29
6052: PUSH
6053: LD_INT 29
6055: PUSH
6056: LD_INT 29
6058: PUSH
6059: EMPTY
6060: LIST
6061: LIST
6062: LIST
6063: LIST
6064: PUSH
6065: LD_OWVAR 67
6069: ARRAY
6070: PUSH
6071: EMPTY
6072: LIST
6073: LIST
6074: LIST
6075: LIST
6076: PUSH
6077: LD_INT 13
6079: PUSH
6080: LD_INT 1
6082: PUSH
6083: LD_INT 2
6085: PUSH
6086: LD_INT 29
6088: PUSH
6089: EMPTY
6090: LIST
6091: LIST
6092: LIST
6093: LIST
6094: PUSH
6095: LD_INT 14
6097: PUSH
6098: LD_INT 1
6100: PUSH
6101: LD_INT 2
6103: PUSH
6104: LD_INT 26
6106: PUSH
6107: EMPTY
6108: LIST
6109: LIST
6110: LIST
6111: LIST
6112: PUSH
6113: EMPTY
6114: LIST
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: LIST
6120: PPUSH
6121: CALL 60846 0 2
// end ; repeat wait ( 0 0$1 ) ;
6125: LD_INT 35
6127: PPUSH
6128: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
6132: LD_INT 3
6134: PPUSH
6135: LD_INT 1
6137: PPUSH
6138: CALL 62264 0 2
6142: PUSH
6143: LD_INT 6
6145: GREATEREQUAL
6146: IFFALSE 6125
// wait ( 0 0$30 ) ;
6148: LD_INT 1050
6150: PPUSH
6151: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6155: LD_ADDR_VAR 0 2
6159: PUSH
6160: LD_INT 3
6162: PPUSH
6163: LD_INT 1
6165: PPUSH
6166: CALL 62264 0 2
6170: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6171: LD_ADDR_EXP 118
6175: PUSH
6176: LD_EXP 118
6180: PPUSH
6181: LD_INT 3
6183: PPUSH
6184: LD_EXP 118
6188: PUSH
6189: LD_INT 3
6191: ARRAY
6192: PUSH
6193: LD_VAR 0 2
6197: DIFF
6198: PPUSH
6199: CALL_OW 1
6203: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6204: LD_ADDR_VAR 0 3
6208: PUSH
6209: LD_INT 0
6211: PPUSH
6212: LD_INT 2
6214: PPUSH
6215: CALL_OW 12
6219: ST_TO_ADDR
// if target then
6220: LD_VAR 0 3
6224: IFFALSE 6352
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6226: LD_ADDR_VAR 0 2
6230: PUSH
6231: LD_VAR 0 2
6235: PPUSH
6236: LD_INT 24
6238: PUSH
6239: LD_INT 250
6241: PUSH
6242: EMPTY
6243: LIST
6244: LIST
6245: PPUSH
6246: CALL_OW 72
6250: ST_TO_ADDR
// for i in tmp do
6251: LD_ADDR_VAR 0 1
6255: PUSH
6256: LD_VAR 0 2
6260: PUSH
6261: FOR_IN
6262: IFFALSE 6302
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6264: LD_VAR 0 1
6268: PPUSH
6269: LD_INT 89
6271: PPUSH
6272: LD_INT 71
6274: PPUSH
6275: CALL_OW 297
6279: PUSH
6280: LD_INT 9
6282: GREATER
6283: IFFALSE 6300
// ComMoveXY ( i , 89 , 71 ) ;
6285: LD_VAR 0 1
6289: PPUSH
6290: LD_INT 89
6292: PPUSH
6293: LD_INT 71
6295: PPUSH
6296: CALL_OW 111
6300: GO 6261
6302: POP
6303: POP
// wait ( 0 0$1 ) ;
6304: LD_INT 35
6306: PPUSH
6307: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6311: LD_VAR 0 2
6315: PPUSH
6316: LD_INT 92
6318: PUSH
6319: LD_INT 89
6321: PUSH
6322: LD_INT 71
6324: PUSH
6325: LD_INT 9
6327: PUSH
6328: EMPTY
6329: LIST
6330: LIST
6331: LIST
6332: LIST
6333: PPUSH
6334: CALL_OW 72
6338: PUSH
6339: LD_VAR 0 2
6343: PUSH
6344: LD_INT 1
6346: MINUS
6347: GREATEREQUAL
6348: IFFALSE 6226
// end else
6350: GO 6476
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6352: LD_ADDR_VAR 0 2
6356: PUSH
6357: LD_VAR 0 2
6361: PPUSH
6362: LD_INT 24
6364: PUSH
6365: LD_INT 250
6367: PUSH
6368: EMPTY
6369: LIST
6370: LIST
6371: PPUSH
6372: CALL_OW 72
6376: ST_TO_ADDR
// for i in tmp do
6377: LD_ADDR_VAR 0 1
6381: PUSH
6382: LD_VAR 0 2
6386: PUSH
6387: FOR_IN
6388: IFFALSE 6428
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6390: LD_VAR 0 1
6394: PPUSH
6395: LD_INT 125
6397: PPUSH
6398: LD_INT 129
6400: PPUSH
6401: CALL_OW 297
6405: PUSH
6406: LD_INT 9
6408: GREATER
6409: IFFALSE 6426
// ComMoveXY ( i , 125 , 129 ) ;
6411: LD_VAR 0 1
6415: PPUSH
6416: LD_INT 125
6418: PPUSH
6419: LD_INT 129
6421: PPUSH
6422: CALL_OW 111
6426: GO 6387
6428: POP
6429: POP
// wait ( 0 0$1 ) ;
6430: LD_INT 35
6432: PPUSH
6433: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6437: LD_VAR 0 2
6441: PPUSH
6442: LD_INT 92
6444: PUSH
6445: LD_INT 125
6447: PUSH
6448: LD_INT 129
6450: PUSH
6451: LD_INT 9
6453: PUSH
6454: EMPTY
6455: LIST
6456: LIST
6457: LIST
6458: LIST
6459: PPUSH
6460: CALL_OW 72
6464: PUSH
6465: LD_VAR 0 2
6469: PUSH
6470: LD_INT 1
6472: MINUS
6473: GREATEREQUAL
6474: IFFALSE 6352
// end ; repeat wait ( 0 0$1 ) ;
6476: LD_INT 35
6478: PPUSH
6479: CALL_OW 67
// for i in tmp do
6483: LD_ADDR_VAR 0 1
6487: PUSH
6488: LD_VAR 0 2
6492: PUSH
6493: FOR_IN
6494: IFFALSE 6576
// begin if GetLives ( i ) > 251 then
6496: LD_VAR 0 1
6500: PPUSH
6501: CALL_OW 256
6505: PUSH
6506: LD_INT 251
6508: GREATER
6509: IFFALSE 6547
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6511: LD_VAR 0 1
6515: PPUSH
6516: LD_INT 81
6518: PUSH
6519: LD_INT 8
6521: PUSH
6522: EMPTY
6523: LIST
6524: LIST
6525: PPUSH
6526: CALL_OW 69
6530: PPUSH
6531: LD_VAR 0 1
6535: PPUSH
6536: CALL_OW 74
6540: PPUSH
6541: CALL_OW 115
6545: GO 6574
// if IsDead ( i ) then
6547: LD_VAR 0 1
6551: PPUSH
6552: CALL_OW 301
6556: IFFALSE 6574
// tmp := tmp diff i ;
6558: LD_ADDR_VAR 0 2
6562: PUSH
6563: LD_VAR 0 2
6567: PUSH
6568: LD_VAR 0 1
6572: DIFF
6573: ST_TO_ADDR
// end ;
6574: GO 6493
6576: POP
6577: POP
// until not tmp ;
6578: LD_VAR 0 2
6582: NOT
6583: IFFALSE 6476
// end ;
6585: PPOPN 3
6587: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6588: LD_EXP 22
6592: NOT
6593: PUSH
6594: LD_EXP 15
6598: PUSH
6599: LD_INT 6
6601: GREATEREQUAL
6602: AND
6603: PUSH
6604: LD_OWVAR 67
6608: PUSH
6609: LD_INT 1
6611: GREATER
6612: AND
6613: IFFALSE 7146
6615: GO 6617
6617: DISABLE
6618: LD_INT 0
6620: PPUSH
6621: PPUSH
6622: PPUSH
// begin enable ;
6623: ENABLE
// tmp := [ ] ;
6624: LD_ADDR_VAR 0 3
6628: PUSH
6629: EMPTY
6630: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6631: LD_ADDR_VAR 0 1
6635: PUSH
6636: DOUBLE
6637: LD_INT 1
6639: DEC
6640: ST_TO_ADDR
6641: LD_INT 4
6643: PUSH
6644: LD_INT 6
6646: PUSH
6647: LD_INT 7
6649: PUSH
6650: LD_INT 8
6652: PUSH
6653: EMPTY
6654: LIST
6655: LIST
6656: LIST
6657: LIST
6658: PUSH
6659: LD_OWVAR 67
6663: ARRAY
6664: PUSH
6665: FOR_TO
6666: IFFALSE 6826
// begin uc_side := 8 ;
6668: LD_ADDR_OWVAR 20
6672: PUSH
6673: LD_INT 8
6675: ST_TO_ADDR
// uc_nation := 2 ;
6676: LD_ADDR_OWVAR 21
6680: PUSH
6681: LD_INT 2
6683: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6684: LD_INT 13
6686: PUSH
6687: LD_INT 14
6689: PUSH
6690: EMPTY
6691: LIST
6692: LIST
6693: PUSH
6694: LD_INT 1
6696: PPUSH
6697: LD_INT 2
6699: PPUSH
6700: CALL_OW 12
6704: ARRAY
6705: PPUSH
6706: LD_INT 1
6708: PPUSH
6709: LD_INT 5
6711: PPUSH
6712: LD_INT 27
6714: PUSH
6715: LD_INT 28
6717: PUSH
6718: LD_INT 26
6720: PUSH
6721: LD_INT 25
6723: PUSH
6724: EMPTY
6725: LIST
6726: LIST
6727: LIST
6728: LIST
6729: PUSH
6730: LD_INT 1
6732: PPUSH
6733: LD_INT 4
6735: PPUSH
6736: CALL_OW 12
6740: ARRAY
6741: PPUSH
6742: LD_INT 88
6744: PPUSH
6745: CALL 72249 0 5
// un := CreateVehicle ;
6749: LD_ADDR_VAR 0 2
6753: PUSH
6754: CALL_OW 45
6758: ST_TO_ADDR
// tmp := tmp ^ un ;
6759: LD_ADDR_VAR 0 3
6763: PUSH
6764: LD_VAR 0 3
6768: PUSH
6769: LD_VAR 0 2
6773: ADD
6774: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6775: LD_VAR 0 2
6779: PPUSH
6780: LD_INT 3
6782: PPUSH
6783: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6787: LD_VAR 0 2
6791: PPUSH
6792: LD_INT 30
6794: PPUSH
6795: LD_INT 0
6797: PPUSH
6798: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6802: LD_VAR 0 2
6806: PPUSH
6807: LD_INT 16
6809: PPUSH
6810: LD_INT 11
6812: PPUSH
6813: CALL_OW 111
// wait ( 0 0$2 ) ;
6817: LD_INT 70
6819: PPUSH
6820: CALL_OW 67
// end ;
6824: GO 6665
6826: POP
6827: POP
// for i = 1 to Difficulty do
6828: LD_ADDR_VAR 0 1
6832: PUSH
6833: DOUBLE
6834: LD_INT 1
6836: DEC
6837: ST_TO_ADDR
6838: LD_OWVAR 67
6842: PUSH
6843: FOR_TO
6844: IFFALSE 6973
// begin uc_side := 8 ;
6846: LD_ADDR_OWVAR 20
6850: PUSH
6851: LD_INT 8
6853: ST_TO_ADDR
// uc_nation := 2 ;
6854: LD_ADDR_OWVAR 21
6858: PUSH
6859: LD_INT 2
6861: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
6862: LD_INT 0
6864: PPUSH
6865: LD_INT 8
6867: PPUSH
6868: LD_INT 8
6870: PUSH
6871: LD_INT 8
6873: PUSH
6874: LD_INT 9
6876: PUSH
6877: LD_INT 10
6879: PUSH
6880: EMPTY
6881: LIST
6882: LIST
6883: LIST
6884: LIST
6885: PUSH
6886: LD_OWVAR 67
6890: ARRAY
6891: PPUSH
6892: CALL_OW 380
// un := CreateHuman ;
6896: LD_ADDR_VAR 0 2
6900: PUSH
6901: CALL_OW 44
6905: ST_TO_ADDR
// tmp := tmp ^ un ;
6906: LD_ADDR_VAR 0 3
6910: PUSH
6911: LD_VAR 0 3
6915: PUSH
6916: LD_VAR 0 2
6920: ADD
6921: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6922: LD_VAR 0 2
6926: PPUSH
6927: LD_INT 3
6929: PPUSH
6930: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6934: LD_VAR 0 2
6938: PPUSH
6939: LD_INT 30
6941: PPUSH
6942: LD_INT 0
6944: PPUSH
6945: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6949: LD_VAR 0 2
6953: PPUSH
6954: LD_INT 16
6956: PPUSH
6957: LD_INT 11
6959: PPUSH
6960: CALL_OW 111
// wait ( 0 0$2 ) ;
6964: LD_INT 70
6966: PPUSH
6967: CALL_OW 67
// end ;
6971: GO 6843
6973: POP
6974: POP
// repeat wait ( 0 0$1 ) ;
6975: LD_INT 35
6977: PPUSH
6978: CALL_OW 67
// if legionDestroyed then
6982: LD_EXP 22
6986: IFFALSE 6990
// exit ;
6988: GO 7146
// for i in tmp do
6990: LD_ADDR_VAR 0 1
6994: PUSH
6995: LD_VAR 0 3
6999: PUSH
7000: FOR_IN
7001: IFFALSE 7137
// begin if GetLives ( i ) > 250 then
7003: LD_VAR 0 1
7007: PPUSH
7008: CALL_OW 256
7012: PUSH
7013: LD_INT 250
7015: GREATER
7016: IFFALSE 7108
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
7018: LD_INT 81
7020: PUSH
7021: LD_INT 8
7023: PUSH
7024: EMPTY
7025: LIST
7026: LIST
7027: PUSH
7028: LD_INT 91
7030: PUSH
7031: LD_VAR 0 1
7035: PUSH
7036: LD_INT 10
7038: PUSH
7039: EMPTY
7040: LIST
7041: LIST
7042: LIST
7043: PUSH
7044: EMPTY
7045: LIST
7046: LIST
7047: PPUSH
7048: CALL_OW 69
7052: NOT
7053: IFFALSE 7072
// ComAgressiveMove ( i , 67 , 110 ) else
7055: LD_VAR 0 1
7059: PPUSH
7060: LD_INT 67
7062: PPUSH
7063: LD_INT 110
7065: PPUSH
7066: CALL_OW 114
7070: GO 7106
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7072: LD_VAR 0 1
7076: PPUSH
7077: LD_INT 81
7079: PUSH
7080: LD_INT 8
7082: PUSH
7083: EMPTY
7084: LIST
7085: LIST
7086: PPUSH
7087: CALL_OW 69
7091: PPUSH
7092: LD_VAR 0 1
7096: PPUSH
7097: CALL_OW 74
7101: PPUSH
7102: CALL_OW 115
// end else
7106: GO 7135
// if IsDead ( i ) then
7108: LD_VAR 0 1
7112: PPUSH
7113: CALL_OW 301
7117: IFFALSE 7135
// tmp := tmp diff i ;
7119: LD_ADDR_VAR 0 3
7123: PUSH
7124: LD_VAR 0 3
7128: PUSH
7129: LD_VAR 0 1
7133: DIFF
7134: ST_TO_ADDR
// end ;
7135: GO 7000
7137: POP
7138: POP
// until not tmp ;
7139: LD_VAR 0 3
7143: NOT
7144: IFFALSE 6975
// end ; end_of_file
7146: PPOPN 3
7148: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
7149: LD_INT 0
7151: PPUSH
7152: PPUSH
7153: PPUSH
7154: PPUSH
7155: PPUSH
7156: PPUSH
7157: PPUSH
7158: PPUSH
7159: PPUSH
// side := 3 ;
7160: LD_ADDR_VAR 0 6
7164: PUSH
7165: LD_INT 3
7167: ST_TO_ADDR
// uc_side := side ;
7168: LD_ADDR_OWVAR 20
7172: PUSH
7173: LD_VAR 0 6
7177: ST_TO_ADDR
// uc_nation := 3 ;
7178: LD_ADDR_OWVAR 21
7182: PUSH
7183: LD_INT 3
7185: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7186: LD_ADDR_VAR 0 2
7190: PUSH
7191: LD_INT 22
7193: PUSH
7194: LD_VAR 0 6
7198: PUSH
7199: EMPTY
7200: LIST
7201: LIST
7202: PUSH
7203: LD_INT 21
7205: PUSH
7206: LD_INT 3
7208: PUSH
7209: EMPTY
7210: LIST
7211: LIST
7212: PUSH
7213: EMPTY
7214: LIST
7215: LIST
7216: PPUSH
7217: CALL_OW 69
7221: PUSH
7222: FOR_IN
7223: IFFALSE 7239
// SetBLevel ( i , 10 ) ;
7225: LD_VAR 0 2
7229: PPUSH
7230: LD_INT 10
7232: PPUSH
7233: CALL_OW 241
7237: GO 7222
7239: POP
7240: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7241: LD_ADDR_VAR 0 9
7245: PUSH
7246: LD_INT 22
7248: PUSH
7249: LD_VAR 0 6
7253: PUSH
7254: EMPTY
7255: LIST
7256: LIST
7257: PUSH
7258: LD_INT 30
7260: PUSH
7261: LD_INT 34
7263: PUSH
7264: EMPTY
7265: LIST
7266: LIST
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: PPUSH
7272: CALL_OW 69
7276: ST_TO_ADDR
// if teleport then
7277: LD_VAR 0 9
7281: IFFALSE 7302
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7283: LD_VAR 0 9
7287: PUSH
7288: LD_INT 1
7290: ARRAY
7291: PPUSH
7292: LD_INT 123
7294: PPUSH
7295: LD_INT 122
7297: PPUSH
7298: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7302: LD_ADDR_EXP 65
7306: PUSH
7307: LD_STRING Platonov
7309: PPUSH
7310: CALL_OW 25
7314: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7315: LD_ADDR_EXP 66
7319: PUSH
7320: LD_STRING Kovalyuk
7322: PPUSH
7323: CALL_OW 25
7327: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7328: LD_ADDR_EXP 68
7332: PUSH
7333: LD_STRING Yakotich
7335: PPUSH
7336: LD_EXP 1
7340: NOT
7341: PPUSH
7342: LD_STRING 09_
7344: PPUSH
7345: CALL 67234 0 3
7349: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7350: LD_ADDR_EXP 67
7354: PUSH
7355: LD_STRING Bystrov
7357: PPUSH
7358: CALL_OW 25
7362: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7363: LD_ADDR_EXP 69
7367: PUSH
7368: LD_STRING Gleb
7370: PPUSH
7371: CALL_OW 25
7375: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7376: LD_STRING 03_Cornel
7378: PPUSH
7379: CALL_OW 28
7383: IFFALSE 7431
// begin Bierezov := NewCharacter ( Mikhail ) ;
7385: LD_ADDR_EXP 70
7389: PUSH
7390: LD_STRING Mikhail
7392: PPUSH
7393: CALL_OW 25
7397: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7398: LD_EXP 70
7402: PPUSH
7403: LD_INT 197
7405: PPUSH
7406: LD_INT 111
7408: PPUSH
7409: LD_INT 9
7411: PPUSH
7412: LD_INT 0
7414: PPUSH
7415: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7419: LD_EXP 70
7423: PPUSH
7424: LD_INT 3
7426: PPUSH
7427: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7431: LD_EXP 65
7435: PPUSH
7436: LD_INT 126
7438: PPUSH
7439: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7443: LD_EXP 66
7447: PPUSH
7448: LD_INT 134
7450: PPUSH
7451: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7455: LD_EXP 68
7459: PPUSH
7460: LD_INT 197
7462: PPUSH
7463: LD_INT 111
7465: PPUSH
7466: LD_INT 9
7468: PPUSH
7469: LD_INT 0
7471: PPUSH
7472: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7476: LD_EXP 67
7480: PPUSH
7481: LD_INT 197
7483: PPUSH
7484: LD_INT 111
7486: PPUSH
7487: LD_INT 9
7489: PPUSH
7490: LD_INT 0
7492: PPUSH
7493: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7497: LD_EXP 69
7501: PPUSH
7502: LD_INT 197
7504: PPUSH
7505: LD_INT 111
7507: PPUSH
7508: LD_INT 9
7510: PPUSH
7511: LD_INT 0
7513: PPUSH
7514: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7518: LD_ADDR_VAR 0 5
7522: PUSH
7523: LD_INT 126
7525: PPUSH
7526: LD_INT 4
7528: PPUSH
7529: LD_STRING zhukov
7531: PPUSH
7532: LD_INT 9
7534: PUSH
7535: LD_INT 10
7537: PUSH
7538: LD_INT 10
7540: PUSH
7541: LD_INT 10
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: LIST
7548: LIST
7549: PUSH
7550: LD_OWVAR 67
7554: ARRAY
7555: PPUSH
7556: LD_INT 90000
7558: PUSH
7559: LD_INT 1000
7561: PUSH
7562: LD_INT 300
7564: PUSH
7565: EMPTY
7566: LIST
7567: LIST
7568: LIST
7569: PPUSH
7570: LD_INT 18
7572: PUSH
7573: LD_INT 8
7575: PUSH
7576: LD_INT 13
7578: PUSH
7579: LD_INT 8
7581: PUSH
7582: EMPTY
7583: LIST
7584: LIST
7585: LIST
7586: LIST
7587: PPUSH
7588: CALL 75693 0 6
7592: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7593: LD_ADDR_VAR 0 4
7597: PUSH
7598: LD_INT 267
7600: PPUSH
7601: CALL_OW 274
7605: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7606: LD_VAR 0 4
7610: PPUSH
7611: LD_INT 1
7613: PPUSH
7614: LD_INT 5000
7616: PPUSH
7617: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7621: LD_VAR 0 4
7625: PPUSH
7626: LD_INT 2
7628: PPUSH
7629: LD_INT 200
7631: PPUSH
7632: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7636: LD_VAR 0 4
7640: PPUSH
7641: LD_INT 3
7643: PPUSH
7644: LD_INT 200
7646: PPUSH
7647: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7651: LD_ADDR_EXP 99
7655: PUSH
7656: LD_EXP 99
7660: PPUSH
7661: LD_INT 2
7663: PPUSH
7664: LD_VAR 0 5
7668: PUSH
7669: LD_INT 22
7671: PUSH
7672: LD_VAR 0 6
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: PUSH
7681: LD_INT 3
7683: PUSH
7684: LD_INT 21
7686: PUSH
7687: LD_INT 2
7689: PUSH
7690: EMPTY
7691: LIST
7692: LIST
7693: PUSH
7694: EMPTY
7695: LIST
7696: LIST
7697: PUSH
7698: EMPTY
7699: LIST
7700: LIST
7701: PPUSH
7702: CALL_OW 69
7706: UNION
7707: PUSH
7708: LD_EXP 65
7712: DIFF
7713: PPUSH
7714: CALL_OW 1
7718: ST_TO_ADDR
// behemoths := [ ] ;
7719: LD_ADDR_EXP 73
7723: PUSH
7724: EMPTY
7725: ST_TO_ADDR
// behemothBuilders := [ ] ;
7726: LD_ADDR_EXP 74
7730: PUSH
7731: EMPTY
7732: ST_TO_ADDR
// if Kovalyuk then
7733: LD_EXP 66
7737: IFFALSE 7759
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7739: LD_ADDR_EXP 74
7743: PUSH
7744: LD_EXP 74
7748: PPUSH
7749: LD_EXP 66
7753: PPUSH
7754: CALL 104683 0 2
7758: ST_TO_ADDR
// j := 3 ;
7759: LD_ADDR_VAR 0 3
7763: PUSH
7764: LD_INT 3
7766: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7767: LD_ADDR_VAR 0 2
7771: PUSH
7772: LD_INT 22
7774: PUSH
7775: LD_INT 3
7777: PUSH
7778: EMPTY
7779: LIST
7780: LIST
7781: PUSH
7782: LD_INT 25
7784: PUSH
7785: LD_INT 3
7787: PUSH
7788: EMPTY
7789: LIST
7790: LIST
7791: PUSH
7792: EMPTY
7793: LIST
7794: LIST
7795: PPUSH
7796: CALL_OW 69
7800: PUSH
7801: LD_EXP 66
7805: DIFF
7806: PUSH
7807: FOR_IN
7808: IFFALSE 7858
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7810: LD_ADDR_EXP 74
7814: PUSH
7815: LD_EXP 74
7819: PPUSH
7820: LD_VAR 0 2
7824: PPUSH
7825: CALL 104683 0 2
7829: ST_TO_ADDR
// j := j - 1 ;
7830: LD_ADDR_VAR 0 3
7834: PUSH
7835: LD_VAR 0 3
7839: PUSH
7840: LD_INT 1
7842: MINUS
7843: ST_TO_ADDR
// if j = 0 then
7844: LD_VAR 0 3
7848: PUSH
7849: LD_INT 0
7851: EQUAL
7852: IFFALSE 7856
// break ;
7854: GO 7858
// end ;
7856: GO 7807
7858: POP
7859: POP
// end ;
7860: LD_VAR 0 1
7864: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7865: LD_INT 0
7867: PPUSH
7868: PPUSH
7869: PPUSH
7870: PPUSH
7871: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7872: LD_ADDR_VAR 0 4
7876: PUSH
7877: LD_INT 209
7879: PUSH
7880: LD_INT 149
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: PUSH
7887: LD_INT 219
7889: PUSH
7890: LD_INT 154
7892: PUSH
7893: EMPTY
7894: LIST
7895: LIST
7896: PUSH
7897: LD_INT 223
7899: PUSH
7900: LD_INT 149
7902: PUSH
7903: EMPTY
7904: LIST
7905: LIST
7906: PUSH
7907: LD_INT 232
7909: PUSH
7910: LD_INT 155
7912: PUSH
7913: EMPTY
7914: LIST
7915: LIST
7916: PUSH
7917: EMPTY
7918: LIST
7919: LIST
7920: LIST
7921: LIST
7922: ST_TO_ADDR
// if not behemothBuilders then
7923: LD_EXP 74
7927: NOT
7928: IFFALSE 7932
// exit ;
7930: GO 8063
// j := 1 ;
7932: LD_ADDR_VAR 0 3
7936: PUSH
7937: LD_INT 1
7939: ST_TO_ADDR
// for i in behemothBuilders do
7940: LD_ADDR_VAR 0 2
7944: PUSH
7945: LD_EXP 74
7949: PUSH
7950: FOR_IN
7951: IFFALSE 8061
// begin if GetClass ( i ) <> class_mechanic then
7953: LD_VAR 0 2
7957: PPUSH
7958: CALL_OW 257
7962: PUSH
7963: LD_INT 3
7965: NONEQUAL
7966: IFFALSE 7980
// SetClass ( i , class_mechanic ) ;
7968: LD_VAR 0 2
7972: PPUSH
7973: LD_INT 3
7975: PPUSH
7976: CALL_OW 336
// if IsInUnit ( i ) then
7980: LD_VAR 0 2
7984: PPUSH
7985: CALL_OW 310
7989: IFFALSE 8000
// ComExitBuilding ( i ) ;
7991: LD_VAR 0 2
7995: PPUSH
7996: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8000: LD_VAR 0 2
8004: PPUSH
8005: LD_INT 37
8007: PPUSH
8008: LD_VAR 0 4
8012: PUSH
8013: LD_VAR 0 3
8017: ARRAY
8018: PUSH
8019: LD_INT 1
8021: ARRAY
8022: PPUSH
8023: LD_VAR 0 4
8027: PUSH
8028: LD_VAR 0 3
8032: ARRAY
8033: PUSH
8034: LD_INT 2
8036: ARRAY
8037: PPUSH
8038: LD_INT 0
8040: PPUSH
8041: CALL_OW 230
// j := j + 1 ;
8045: LD_ADDR_VAR 0 3
8049: PUSH
8050: LD_VAR 0 3
8054: PUSH
8055: LD_INT 1
8057: PLUS
8058: ST_TO_ADDR
// end ;
8059: GO 7950
8061: POP
8062: POP
// end ;
8063: LD_VAR 0 1
8067: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
8068: LD_INT 24
8070: PPUSH
8071: LD_INT 30
8073: PUSH
8074: LD_INT 37
8076: PUSH
8077: EMPTY
8078: LIST
8079: LIST
8080: PPUSH
8081: CALL_OW 70
8085: IFFALSE 8098
8087: GO 8089
8089: DISABLE
// behemothUnderConstruct := true ;
8090: LD_ADDR_EXP 26
8094: PUSH
8095: LD_INT 1
8097: ST_TO_ADDR
8098: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8099: LD_INT 3
8101: PPUSH
8102: CALL 104744 0 1
8106: PUSH
8107: LD_INT 22
8109: PUSH
8110: LD_INT 3
8112: PUSH
8113: EMPTY
8114: LIST
8115: LIST
8116: PUSH
8117: LD_INT 30
8119: PUSH
8120: LD_INT 37
8122: PUSH
8123: EMPTY
8124: LIST
8125: LIST
8126: PUSH
8127: EMPTY
8128: LIST
8129: LIST
8130: PPUSH
8131: CALL_OW 69
8135: NOT
8136: AND
8137: IFFALSE 8323
8139: GO 8141
8141: DISABLE
8142: LD_INT 0
8144: PPUSH
8145: PPUSH
// begin enable ;
8146: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8147: LD_ADDR_VAR 0 2
8151: PUSH
8152: LD_INT 3
8154: PPUSH
8155: CALL 104744 0 1
8159: ST_TO_ADDR
// for i in tmp do
8160: LD_ADDR_VAR 0 1
8164: PUSH
8165: LD_VAR 0 2
8169: PUSH
8170: FOR_IN
8171: IFFALSE 8321
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8173: LD_VAR 0 1
8177: PPUSH
8178: LD_INT 9
8180: PPUSH
8181: CALL_OW 308
8185: PUSH
8186: LD_VAR 0 1
8190: PPUSH
8191: CALL_OW 110
8195: PUSH
8196: LD_INT 2
8198: EQUAL
8199: NOT
8200: AND
8201: IFFALSE 8215
// SetTag ( i , 2 ) ;
8203: LD_VAR 0 1
8207: PPUSH
8208: LD_INT 2
8210: PPUSH
8211: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8215: LD_INT 81
8217: PUSH
8218: LD_INT 3
8220: PUSH
8221: EMPTY
8222: LIST
8223: LIST
8224: PUSH
8225: LD_INT 91
8227: PUSH
8228: LD_VAR 0 1
8232: PUSH
8233: LD_INT 12
8235: PUSH
8236: EMPTY
8237: LIST
8238: LIST
8239: LIST
8240: PUSH
8241: EMPTY
8242: LIST
8243: LIST
8244: PPUSH
8245: CALL_OW 69
8249: NOT
8250: PUSH
8251: LD_VAR 0 1
8255: PPUSH
8256: CALL_OW 110
8260: PUSH
8261: LD_INT 2
8263: EQUAL
8264: NOT
8265: AND
8266: IFFALSE 8285
// ComAgressiveMove ( i , 64 , 93 ) else
8268: LD_VAR 0 1
8272: PPUSH
8273: LD_INT 64
8275: PPUSH
8276: LD_INT 93
8278: PPUSH
8279: CALL_OW 114
8283: GO 8319
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8285: LD_VAR 0 1
8289: PPUSH
8290: LD_INT 81
8292: PUSH
8293: LD_INT 3
8295: PUSH
8296: EMPTY
8297: LIST
8298: LIST
8299: PPUSH
8300: CALL_OW 69
8304: PPUSH
8305: LD_VAR 0 1
8309: PPUSH
8310: CALL_OW 74
8314: PPUSH
8315: CALL_OW 115
// end ;
8319: GO 8170
8321: POP
8322: POP
// end ;
8323: PPOPN 2
8325: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8326: LD_INT 0
8328: PPUSH
8329: PPUSH
8330: PPUSH
// result := [ ] ;
8331: LD_ADDR_VAR 0 2
8335: PUSH
8336: EMPTY
8337: ST_TO_ADDR
// uc_side := 6 ;
8338: LD_ADDR_OWVAR 20
8342: PUSH
8343: LD_INT 6
8345: ST_TO_ADDR
// uc_nation := 3 ;
8346: LD_ADDR_OWVAR 21
8350: PUSH
8351: LD_INT 3
8353: ST_TO_ADDR
// case strength of 1 :
8354: LD_VAR 0 1
8358: PUSH
8359: LD_INT 1
8361: DOUBLE
8362: EQUAL
8363: IFTRUE 8367
8365: GO 8509
8367: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8368: LD_ADDR_VAR 0 3
8372: PUSH
8373: DOUBLE
8374: LD_INT 1
8376: DEC
8377: ST_TO_ADDR
8378: LD_INT 4
8380: PUSH
8381: LD_INT 5
8383: PUSH
8384: LD_INT 6
8386: PUSH
8387: LD_INT 7
8389: PUSH
8390: EMPTY
8391: LIST
8392: LIST
8393: LIST
8394: LIST
8395: PUSH
8396: LD_OWVAR 67
8400: ARRAY
8401: PUSH
8402: FOR_TO
8403: IFFALSE 8505
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8405: LD_INT 22
8407: PUSH
8408: LD_INT 24
8410: PUSH
8411: EMPTY
8412: LIST
8413: LIST
8414: PUSH
8415: LD_VAR 0 3
8419: PUSH
8420: LD_INT 2
8422: MOD
8423: PUSH
8424: LD_INT 1
8426: PLUS
8427: ARRAY
8428: PPUSH
8429: LD_INT 1
8431: PUSH
8432: LD_INT 3
8434: PUSH
8435: EMPTY
8436: LIST
8437: LIST
8438: PUSH
8439: LD_INT 1
8441: PPUSH
8442: LD_INT 2
8444: PPUSH
8445: CALL_OW 12
8449: ARRAY
8450: PPUSH
8451: LD_INT 3
8453: PPUSH
8454: LD_INT 43
8456: PUSH
8457: LD_INT 44
8459: PUSH
8460: LD_INT 45
8462: PUSH
8463: EMPTY
8464: LIST
8465: LIST
8466: LIST
8467: PUSH
8468: LD_INT 1
8470: PPUSH
8471: LD_INT 3
8473: PPUSH
8474: CALL_OW 12
8478: ARRAY
8479: PPUSH
8480: LD_INT 80
8482: PPUSH
8483: CALL 72249 0 5
// result := result union CreateVehicle ;
8487: LD_ADDR_VAR 0 2
8491: PUSH
8492: LD_VAR 0 2
8496: PUSH
8497: CALL_OW 45
8501: UNION
8502: ST_TO_ADDR
// end ;
8503: GO 8402
8505: POP
8506: POP
// end ; 2 :
8507: GO 9504
8509: LD_INT 2
8511: DOUBLE
8512: EQUAL
8513: IFTRUE 8517
8515: GO 8685
8517: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8518: LD_ADDR_VAR 0 3
8522: PUSH
8523: DOUBLE
8524: LD_INT 1
8526: DEC
8527: ST_TO_ADDR
8528: LD_INT 5
8530: PUSH
8531: LD_INT 6
8533: PUSH
8534: LD_INT 7
8536: PUSH
8537: LD_INT 8
8539: PUSH
8540: EMPTY
8541: LIST
8542: LIST
8543: LIST
8544: LIST
8545: PUSH
8546: LD_OWVAR 67
8550: ARRAY
8551: PUSH
8552: FOR_TO
8553: IFFALSE 8681
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
8555: LD_INT 22
8557: PUSH
8558: LD_INT 24
8560: PUSH
8561: LD_INT 24
8563: PUSH
8564: EMPTY
8565: LIST
8566: LIST
8567: LIST
8568: PUSH
8569: LD_VAR 0 3
8573: PUSH
8574: LD_INT 3
8576: MOD
8577: PUSH
8578: LD_INT 1
8580: PLUS
8581: ARRAY
8582: PPUSH
8583: LD_INT 1
8585: PUSH
8586: LD_INT 3
8588: PUSH
8589: EMPTY
8590: LIST
8591: LIST
8592: PUSH
8593: LD_INT 1
8595: PPUSH
8596: LD_INT 2
8598: PPUSH
8599: CALL_OW 12
8603: ARRAY
8604: PPUSH
8605: LD_INT 3
8607: PPUSH
8608: LD_INT 43
8610: PUSH
8611: LD_INT 44
8613: PUSH
8614: LD_INT 45
8616: PUSH
8617: LD_INT 44
8619: PUSH
8620: LD_INT 46
8622: PUSH
8623: LD_INT 46
8625: PUSH
8626: LD_INT 49
8628: PUSH
8629: LD_INT 49
8631: PUSH
8632: EMPTY
8633: LIST
8634: LIST
8635: LIST
8636: LIST
8637: LIST
8638: LIST
8639: LIST
8640: LIST
8641: PUSH
8642: LD_VAR 0 3
8646: PUSH
8647: LD_INT 8
8649: MOD
8650: PUSH
8651: LD_INT 1
8653: PLUS
8654: ARRAY
8655: PPUSH
8656: LD_INT 80
8658: PPUSH
8659: CALL 72249 0 5
// result := result union CreateVehicle ;
8663: LD_ADDR_VAR 0 2
8667: PUSH
8668: LD_VAR 0 2
8672: PUSH
8673: CALL_OW 45
8677: UNION
8678: ST_TO_ADDR
// end ;
8679: GO 8552
8681: POP
8682: POP
// end ; 3 :
8683: GO 9504
8685: LD_INT 3
8687: DOUBLE
8688: EQUAL
8689: IFTRUE 8693
8691: GO 8865
8693: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
8694: LD_ADDR_VAR 0 3
8698: PUSH
8699: DOUBLE
8700: LD_INT 1
8702: DEC
8703: ST_TO_ADDR
8704: LD_INT 6
8706: PUSH
8707: LD_INT 7
8709: PUSH
8710: LD_INT 8
8712: PUSH
8713: LD_INT 9
8715: PUSH
8716: EMPTY
8717: LIST
8718: LIST
8719: LIST
8720: LIST
8721: PUSH
8722: LD_OWVAR 67
8726: ARRAY
8727: PUSH
8728: FOR_TO
8729: IFFALSE 8861
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
8731: LD_INT 22
8733: PUSH
8734: LD_INT 24
8736: PUSH
8737: LD_INT 24
8739: PUSH
8740: EMPTY
8741: LIST
8742: LIST
8743: LIST
8744: PUSH
8745: LD_VAR 0 3
8749: PUSH
8750: LD_INT 3
8752: MOD
8753: PUSH
8754: LD_INT 1
8756: PLUS
8757: ARRAY
8758: PPUSH
8759: LD_INT 1
8761: PUSH
8762: LD_INT 3
8764: PUSH
8765: EMPTY
8766: LIST
8767: LIST
8768: PUSH
8769: LD_INT 1
8771: PPUSH
8772: LD_INT 2
8774: PPUSH
8775: CALL_OW 12
8779: ARRAY
8780: PPUSH
8781: LD_INT 3
8783: PPUSH
8784: LD_INT 43
8786: PUSH
8787: LD_INT 47
8789: PUSH
8790: LD_INT 45
8792: PUSH
8793: LD_INT 45
8795: PUSH
8796: LD_INT 46
8798: PUSH
8799: LD_INT 46
8801: PUSH
8802: LD_INT 49
8804: PUSH
8805: LD_INT 49
8807: PUSH
8808: LD_INT 49
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: LIST
8815: LIST
8816: LIST
8817: LIST
8818: LIST
8819: LIST
8820: LIST
8821: PUSH
8822: LD_VAR 0 3
8826: PUSH
8827: LD_INT 9
8829: MOD
8830: PUSH
8831: LD_INT 1
8833: PLUS
8834: ARRAY
8835: PPUSH
8836: LD_INT 80
8838: PPUSH
8839: CALL 72249 0 5
// result := result union CreateVehicle ;
8843: LD_ADDR_VAR 0 2
8847: PUSH
8848: LD_VAR 0 2
8852: PUSH
8853: CALL_OW 45
8857: UNION
8858: ST_TO_ADDR
// end ;
8859: GO 8728
8861: POP
8862: POP
// end ; 4 :
8863: GO 9504
8865: LD_INT 4
8867: DOUBLE
8868: EQUAL
8869: IFTRUE 8873
8871: GO 9503
8873: POP
// begin uc_nation := 3 ;
8874: LD_ADDR_OWVAR 21
8878: PUSH
8879: LD_INT 3
8881: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
8882: LD_ADDR_VAR 0 3
8886: PUSH
8887: DOUBLE
8888: LD_INT 1
8890: DEC
8891: ST_TO_ADDR
8892: LD_INT 6
8894: PUSH
8895: LD_INT 8
8897: PUSH
8898: LD_INT 9
8900: PUSH
8901: LD_INT 10
8903: PUSH
8904: EMPTY
8905: LIST
8906: LIST
8907: LIST
8908: LIST
8909: PUSH
8910: LD_OWVAR 67
8914: ARRAY
8915: PUSH
8916: FOR_TO
8917: IFFALSE 9049
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
8919: LD_INT 22
8921: PUSH
8922: LD_INT 24
8924: PUSH
8925: LD_INT 24
8927: PUSH
8928: EMPTY
8929: LIST
8930: LIST
8931: LIST
8932: PUSH
8933: LD_VAR 0 3
8937: PUSH
8938: LD_INT 3
8940: MOD
8941: PUSH
8942: LD_INT 1
8944: PLUS
8945: ARRAY
8946: PPUSH
8947: LD_INT 1
8949: PUSH
8950: LD_INT 3
8952: PUSH
8953: EMPTY
8954: LIST
8955: LIST
8956: PUSH
8957: LD_INT 1
8959: PPUSH
8960: LD_INT 2
8962: PPUSH
8963: CALL_OW 12
8967: ARRAY
8968: PPUSH
8969: LD_INT 3
8971: PPUSH
8972: LD_INT 45
8974: PUSH
8975: LD_INT 47
8977: PUSH
8978: LD_INT 47
8980: PUSH
8981: LD_INT 45
8983: PUSH
8984: LD_INT 46
8986: PUSH
8987: LD_INT 46
8989: PUSH
8990: LD_INT 49
8992: PUSH
8993: LD_INT 49
8995: PUSH
8996: LD_INT 49
8998: PUSH
8999: EMPTY
9000: LIST
9001: LIST
9002: LIST
9003: LIST
9004: LIST
9005: LIST
9006: LIST
9007: LIST
9008: LIST
9009: PUSH
9010: LD_VAR 0 3
9014: PUSH
9015: LD_INT 9
9017: MOD
9018: PUSH
9019: LD_INT 1
9021: PLUS
9022: ARRAY
9023: PPUSH
9024: LD_INT 80
9026: PPUSH
9027: CALL 72249 0 5
// result := result union CreateVehicle ;
9031: LD_ADDR_VAR 0 2
9035: PUSH
9036: LD_VAR 0 2
9040: PUSH
9041: CALL_OW 45
9045: UNION
9046: ST_TO_ADDR
// end ;
9047: GO 8916
9049: POP
9050: POP
// if not KappaStatus then
9051: LD_EXP 2
9055: NOT
9056: IFFALSE 9291
// begin uc_nation := 1 ;
9058: LD_ADDR_OWVAR 21
9062: PUSH
9063: LD_INT 1
9065: ST_TO_ADDR
// for i = 1 to 3 do
9066: LD_ADDR_VAR 0 3
9070: PUSH
9071: DOUBLE
9072: LD_INT 1
9074: DEC
9075: ST_TO_ADDR
9076: LD_INT 3
9078: PUSH
9079: FOR_TO
9080: IFFALSE 9216
// begin j := rand ( 0 , 1 ) ;
9082: LD_ADDR_VAR 0 4
9086: PUSH
9087: LD_INT 0
9089: PPUSH
9090: LD_INT 1
9092: PPUSH
9093: CALL_OW 12
9097: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9098: LD_INT 3
9100: PUSH
9101: LD_INT 5
9103: PUSH
9104: LD_INT 5
9106: PUSH
9107: LD_INT 4
9109: PUSH
9110: EMPTY
9111: LIST
9112: LIST
9113: LIST
9114: LIST
9115: PUSH
9116: LD_VAR 0 4
9120: PUSH
9121: LD_INT 1
9123: PPUSH
9124: LD_INT 3
9126: PPUSH
9127: CALL_OW 12
9131: PLUS
9132: ARRAY
9133: PPUSH
9134: LD_INT 1
9136: PUSH
9137: LD_INT 3
9139: PUSH
9140: EMPTY
9141: LIST
9142: LIST
9143: PUSH
9144: LD_INT 1
9146: PPUSH
9147: LD_INT 2
9149: PPUSH
9150: CALL_OW 12
9154: ARRAY
9155: PPUSH
9156: LD_INT 3
9158: PPUSH
9159: LD_INT 9
9161: PUSH
9162: LD_INT 7
9164: PUSH
9165: LD_INT 6
9167: PUSH
9168: EMPTY
9169: LIST
9170: LIST
9171: LIST
9172: PUSH
9173: LD_VAR 0 4
9177: PUSH
9178: LD_INT 1
9180: PPUSH
9181: LD_INT 2
9183: PPUSH
9184: CALL_OW 12
9188: PLUS
9189: ARRAY
9190: PPUSH
9191: LD_INT 85
9193: PPUSH
9194: CALL 72249 0 5
// result := result union CreateVehicle ;
9198: LD_ADDR_VAR 0 2
9202: PUSH
9203: LD_VAR 0 2
9207: PUSH
9208: CALL_OW 45
9212: UNION
9213: ST_TO_ADDR
// end ;
9214: GO 9079
9216: POP
9217: POP
// if vsevolodFirstAttack then
9218: LD_EXP 24
9222: IFFALSE 9289
// begin vsevolodFirstAttack := false ;
9224: LD_ADDR_EXP 24
9228: PUSH
9229: LD_INT 0
9231: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9232: LD_INT 5
9234: PPUSH
9235: LD_INT 3
9237: PPUSH
9238: LD_INT 1
9240: PPUSH
9241: LD_INT 6
9243: PPUSH
9244: LD_INT 100
9246: PPUSH
9247: CALL 72249 0 5
// sewiVeh := CreateVehicle ;
9251: LD_ADDR_EXP 72
9255: PUSH
9256: CALL_OW 45
9260: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9261: LD_EXP 72
9265: PPUSH
9266: LD_INT 1
9268: PPUSH
9269: CALL_OW 242
// result := result union sewiVeh ;
9273: LD_ADDR_VAR 0 2
9277: PUSH
9278: LD_VAR 0 2
9282: PUSH
9283: LD_EXP 72
9287: UNION
9288: ST_TO_ADDR
// end ; end else
9289: GO 9501
// if vsevolodFirstAttack then
9291: LD_EXP 24
9295: IFFALSE 9501
// begin vsevolodFirstAttack := false ;
9297: LD_ADDR_EXP 24
9301: PUSH
9302: LD_INT 0
9304: ST_TO_ADDR
// uc_nation := 3 ;
9305: LD_ADDR_OWVAR 21
9309: PUSH
9310: LD_INT 3
9312: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9313: LD_ADDR_VAR 0 3
9317: PUSH
9318: DOUBLE
9319: LD_INT 1
9321: DEC
9322: ST_TO_ADDR
9323: LD_INT 2
9325: PUSH
9326: LD_OWVAR 67
9330: PLUS
9331: PUSH
9332: FOR_TO
9333: IFFALSE 9441
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9335: LD_INT 22
9337: PUSH
9338: LD_INT 24
9340: PUSH
9341: LD_INT 24
9343: PUSH
9344: EMPTY
9345: LIST
9346: LIST
9347: LIST
9348: PUSH
9349: LD_VAR 0 3
9353: PUSH
9354: LD_INT 3
9356: MOD
9357: PUSH
9358: LD_INT 1
9360: PLUS
9361: ARRAY
9362: PPUSH
9363: LD_INT 1
9365: PUSH
9366: LD_INT 3
9368: PUSH
9369: EMPTY
9370: LIST
9371: LIST
9372: PUSH
9373: LD_INT 1
9375: PPUSH
9376: LD_INT 2
9378: PPUSH
9379: CALL_OW 12
9383: ARRAY
9384: PPUSH
9385: LD_INT 1
9387: PPUSH
9388: LD_INT 45
9390: PUSH
9391: LD_INT 47
9393: PUSH
9394: LD_INT 47
9396: PUSH
9397: EMPTY
9398: LIST
9399: LIST
9400: LIST
9401: PUSH
9402: LD_VAR 0 3
9406: PUSH
9407: LD_INT 3
9409: MOD
9410: PUSH
9411: LD_INT 1
9413: PLUS
9414: ARRAY
9415: PPUSH
9416: LD_INT 80
9418: PPUSH
9419: CALL 72249 0 5
// result := result union CreateVehicle ;
9423: LD_ADDR_VAR 0 2
9427: PUSH
9428: LD_VAR 0 2
9432: PUSH
9433: CALL_OW 45
9437: UNION
9438: ST_TO_ADDR
// end ;
9439: GO 9332
9441: POP
9442: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9443: LD_INT 24
9445: PPUSH
9446: LD_INT 3
9448: PPUSH
9449: LD_INT 1
9451: PPUSH
9452: LD_INT 47
9454: PPUSH
9455: LD_INT 100
9457: PPUSH
9458: CALL 72249 0 5
// sewiVeh := CreateVehicle ;
9462: LD_ADDR_EXP 72
9466: PUSH
9467: CALL_OW 45
9471: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9472: LD_EXP 72
9476: PPUSH
9477: LD_INT 6
9479: NEG
9480: PPUSH
9481: CALL_OW 242
// result := result union sewiVeh ;
9485: LD_ADDR_VAR 0 2
9489: PUSH
9490: LD_VAR 0 2
9494: PUSH
9495: LD_EXP 72
9499: UNION
9500: ST_TO_ADDR
// end ; end ; end ;
9501: GO 9504
9503: POP
// end ;
9504: LD_VAR 0 2
9508: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9509: LD_EXP 16
9513: IFFALSE 10184
9515: GO 9517
9517: DISABLE
9518: LD_INT 0
9520: PPUSH
9521: PPUSH
9522: PPUSH
9523: PPUSH
9524: PPUSH
9525: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9526: LD_ADDR_VAR 0 4
9530: PUSH
9531: LD_INT 11
9533: PUSH
9534: LD_INT 12
9536: PUSH
9537: EMPTY
9538: LIST
9539: LIST
9540: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9541: LD_ADDR_VAR 0 3
9545: PUSH
9546: LD_INT 11550
9548: PUSH
9549: LD_INT 10150
9551: PUSH
9552: LD_INT 9800
9554: PUSH
9555: LD_INT 9450
9557: PUSH
9558: EMPTY
9559: LIST
9560: LIST
9561: LIST
9562: LIST
9563: PUSH
9564: LD_OWVAR 67
9568: ARRAY
9569: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9570: LD_ADDR_VAR 0 6
9574: PUSH
9575: LD_INT 70
9577: PUSH
9578: LD_INT 118
9580: PUSH
9581: EMPTY
9582: LIST
9583: LIST
9584: PUSH
9585: LD_INT 78
9587: PUSH
9588: LD_INT 31
9590: PUSH
9591: EMPTY
9592: LIST
9593: LIST
9594: PUSH
9595: EMPTY
9596: LIST
9597: LIST
9598: ST_TO_ADDR
// repeat if missionStage = 2 then
9599: LD_EXP 15
9603: PUSH
9604: LD_INT 2
9606: EQUAL
9607: IFFALSE 9618
// wait ( 1 1$30 ) else
9609: LD_INT 3150
9611: PPUSH
9612: CALL_OW 67
9616: GO 9627
// wait ( time ) ;
9618: LD_VAR 0 3
9622: PPUSH
9623: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
9627: LD_EXP 15
9631: PUSH
9632: LD_INT 6
9634: EQUAL
9635: PUSH
9636: LD_OWVAR 67
9640: PUSH
9641: LD_INT 2
9643: GREATER
9644: OR
9645: IFFALSE 9673
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9647: LD_INT 51
9649: PPUSH
9650: LD_INT 6
9652: PPUSH
9653: LD_INT 2
9655: PPUSH
9656: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9660: LD_INT 57
9662: PPUSH
9663: LD_INT 6
9665: PPUSH
9666: LD_INT 2
9668: PPUSH
9669: CALL_OW 322
// end ; if missionStage = 8 then
9673: LD_EXP 15
9677: PUSH
9678: LD_INT 8
9680: EQUAL
9681: IFFALSE 9709
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9683: LD_INT 52
9685: PPUSH
9686: LD_INT 6
9688: PPUSH
9689: LD_INT 2
9691: PPUSH
9692: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9696: LD_INT 58
9698: PPUSH
9699: LD_INT 6
9701: PPUSH
9702: LD_INT 2
9704: PPUSH
9705: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9709: LD_EXP 15
9713: PUSH
9714: LD_INT 10
9716: EQUAL
9717: PUSH
9718: LD_OWVAR 67
9722: PUSH
9723: LD_INT 1
9725: GREATER
9726: AND
9727: IFFALSE 9755
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9729: LD_INT 53
9731: PPUSH
9732: LD_INT 6
9734: PPUSH
9735: LD_INT 2
9737: PPUSH
9738: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9742: LD_INT 59
9744: PPUSH
9745: LD_INT 6
9747: PPUSH
9748: LD_INT 2
9750: PPUSH
9751: CALL_OW 322
// end ; if activeAttacks then
9755: LD_EXP 16
9759: IFFALSE 10178
// begin if missionStage = 2 then
9761: LD_EXP 15
9765: PUSH
9766: LD_INT 2
9768: EQUAL
9769: IFFALSE 9779
// strength := 1 ;
9771: LD_ADDR_VAR 0 5
9775: PUSH
9776: LD_INT 1
9778: ST_TO_ADDR
// if missionStage > 2 then
9779: LD_EXP 15
9783: PUSH
9784: LD_INT 2
9786: GREATER
9787: IFFALSE 9797
// strength := 2 ;
9789: LD_ADDR_VAR 0 5
9793: PUSH
9794: LD_INT 2
9796: ST_TO_ADDR
// if missionStage > 6 then
9797: LD_EXP 15
9801: PUSH
9802: LD_INT 6
9804: GREATER
9805: IFFALSE 9815
// strength := 3 ;
9807: LD_ADDR_VAR 0 5
9811: PUSH
9812: LD_INT 3
9814: ST_TO_ADDR
// if missionStage > 10 then
9815: LD_EXP 15
9819: PUSH
9820: LD_INT 10
9822: GREATER
9823: IFFALSE 9833
// strength := 4 ;
9825: LD_ADDR_VAR 0 5
9829: PUSH
9830: LD_INT 4
9832: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9833: LD_ADDR_VAR 0 2
9837: PUSH
9838: LD_VAR 0 5
9842: PPUSH
9843: CALL 8326 0 1
9847: ST_TO_ADDR
// for i in tmp do
9848: LD_ADDR_VAR 0 1
9852: PUSH
9853: LD_VAR 0 2
9857: PUSH
9858: FOR_IN
9859: IFFALSE 10068
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9861: LD_VAR 0 1
9865: PPUSH
9866: LD_VAR 0 4
9870: PUSH
9871: LD_INT 1
9873: PPUSH
9874: LD_INT 2
9876: PPUSH
9877: CALL_OW 12
9881: ARRAY
9882: PPUSH
9883: LD_INT 0
9885: PPUSH
9886: CALL_OW 49
// if i = sewiVeh then
9890: LD_VAR 0 1
9894: PUSH
9895: LD_EXP 72
9899: EQUAL
9900: IFFALSE 9937
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9902: LD_ADDR_EXP 71
9906: PUSH
9907: LD_STRING Vsevolod
9909: PPUSH
9910: LD_INT 0
9912: PPUSH
9913: LD_STRING 
9915: PPUSH
9916: CALL 67234 0 3
9920: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9921: LD_EXP 71
9925: PPUSH
9926: LD_VAR 0 1
9930: PPUSH
9931: CALL_OW 52
// end else
9935: GO 10018
// if GetControl ( i ) = control_manual then
9937: LD_VAR 0 1
9941: PPUSH
9942: CALL_OW 263
9946: PUSH
9947: LD_INT 1
9949: EQUAL
9950: IFFALSE 10018
// begin uc_side := 6 ;
9952: LD_ADDR_OWVAR 20
9956: PUSH
9957: LD_INT 6
9959: ST_TO_ADDR
// uc_nation := 3 ;
9960: LD_ADDR_OWVAR 21
9964: PUSH
9965: LD_INT 3
9967: ST_TO_ADDR
// hc_gallery :=  ;
9968: LD_ADDR_OWVAR 33
9972: PUSH
9973: LD_STRING 
9975: ST_TO_ADDR
// hc_name :=  ;
9976: LD_ADDR_OWVAR 26
9980: PUSH
9981: LD_STRING 
9983: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9984: LD_INT 0
9986: PPUSH
9987: LD_INT 3
9989: PPUSH
9990: LD_INT 10
9992: PPUSH
9993: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9997: CALL_OW 44
10001: PPUSH
10002: LD_VAR 0 1
10006: PPUSH
10007: CALL_OW 52
// wait ( 0 0$0.3 ) ;
10011: LD_INT 10
10013: PPUSH
10014: CALL_OW 67
// end ; if Prob ( 50 ) then
10018: LD_INT 50
10020: PPUSH
10021: CALL_OW 13
10025: IFFALSE 10044
// ComMoveXY ( i , 111 , 197 ) else
10027: LD_VAR 0 1
10031: PPUSH
10032: LD_INT 111
10034: PPUSH
10035: LD_INT 197
10037: PPUSH
10038: CALL_OW 111
10042: GO 10059
// ComMoveXY ( i , 91 , 165 ) ;
10044: LD_VAR 0 1
10048: PPUSH
10049: LD_INT 91
10051: PPUSH
10052: LD_INT 165
10054: PPUSH
10055: CALL_OW 111
// wait ( 0 0$2 ) ;
10059: LD_INT 70
10061: PPUSH
10062: CALL_OW 67
// end ;
10066: GO 9858
10068: POP
10069: POP
// repeat wait ( 0 0$1 ) ;
10070: LD_INT 35
10072: PPUSH
10073: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
10077: LD_ADDR_VAR 0 1
10081: PUSH
10082: LD_VAR 0 2
10086: PPUSH
10087: LD_INT 50
10089: PUSH
10090: EMPTY
10091: LIST
10092: PPUSH
10093: CALL_OW 72
10097: PUSH
10098: FOR_IN
10099: IFFALSE 10158
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10101: LD_VAR 0 1
10105: PPUSH
10106: LD_INT 108
10108: PUSH
10109: LD_INT 153
10111: PUSH
10112: EMPTY
10113: LIST
10114: LIST
10115: PUSH
10116: LD_INT 105
10118: PUSH
10119: LD_INT 149
10121: PUSH
10122: EMPTY
10123: LIST
10124: LIST
10125: PUSH
10126: LD_INT 85
10128: PUSH
10129: LD_INT 131
10131: PUSH
10132: EMPTY
10133: LIST
10134: LIST
10135: PUSH
10136: LD_INT 64
10138: PUSH
10139: LD_INT 105
10141: PUSH
10142: EMPTY
10143: LIST
10144: LIST
10145: PUSH
10146: EMPTY
10147: LIST
10148: LIST
10149: LIST
10150: LIST
10151: PPUSH
10152: CALL 107287 0 2
10156: GO 10098
10158: POP
10159: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
10160: LD_VAR 0 2
10164: PPUSH
10165: LD_INT 50
10167: PUSH
10168: EMPTY
10169: LIST
10170: PPUSH
10171: CALL_OW 72
10175: NOT
10176: IFFALSE 10070
// end ; until russianDestroyed ;
10178: LD_EXP 21
10182: IFFALSE 9599
// end ;
10184: PPOPN 6
10186: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10187: LD_EXP 21
10191: NOT
10192: PUSH
10193: LD_EXP 15
10197: PUSH
10198: LD_INT 6
10200: GREATEREQUAL
10201: AND
10202: PUSH
10203: LD_INT 2
10205: PPUSH
10206: LD_INT 1
10208: PPUSH
10209: CALL 62264 0 2
10213: NOT
10214: AND
10215: IFFALSE 11154
10217: GO 10219
10219: DISABLE
10220: LD_INT 0
10222: PPUSH
10223: PPUSH
10224: PPUSH
10225: PPUSH
// begin enable ;
10226: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10227: LD_INT 22
10229: PUSH
10230: LD_INT 3
10232: PUSH
10233: EMPTY
10234: LIST
10235: LIST
10236: PUSH
10237: LD_INT 30
10239: PUSH
10240: LD_INT 3
10242: PUSH
10243: EMPTY
10244: LIST
10245: LIST
10246: PUSH
10247: EMPTY
10248: LIST
10249: LIST
10250: PPUSH
10251: CALL_OW 69
10255: NOT
10256: IFFALSE 10260
// exit ;
10258: GO 11154
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10260: LD_ADDR_VAR 0 4
10264: PUSH
10265: LD_INT 22
10267: PUSH
10268: LD_INT 3
10270: PUSH
10271: EMPTY
10272: LIST
10273: LIST
10274: PUSH
10275: LD_INT 30
10277: PUSH
10278: LD_INT 34
10280: PUSH
10281: EMPTY
10282: LIST
10283: LIST
10284: PUSH
10285: EMPTY
10286: LIST
10287: LIST
10288: PPUSH
10289: CALL_OW 69
10293: ST_TO_ADDR
// if Prob ( 40 ) then
10294: LD_INT 40
10296: PPUSH
10297: CALL_OW 13
10301: IFFALSE 10447
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10303: LD_INT 2
10305: PPUSH
10306: LD_INT 22
10308: PUSH
10309: LD_INT 3
10311: PUSH
10312: LD_INT 3
10314: PUSH
10315: LD_INT 49
10317: PUSH
10318: EMPTY
10319: LIST
10320: LIST
10321: LIST
10322: LIST
10323: PUSH
10324: LD_INT 22
10326: PUSH
10327: LD_INT 3
10329: PUSH
10330: LD_INT 3
10332: PUSH
10333: LD_INT 49
10335: PUSH
10336: EMPTY
10337: LIST
10338: LIST
10339: LIST
10340: LIST
10341: PUSH
10342: LD_INT 22
10344: PUSH
10345: LD_INT 3
10347: PUSH
10348: LD_INT 3
10350: PUSH
10351: LD_INT 49
10353: PUSH
10354: EMPTY
10355: LIST
10356: LIST
10357: LIST
10358: LIST
10359: PUSH
10360: LD_INT 24
10362: PUSH
10363: LD_INT 3
10365: PUSH
10366: LD_INT 3
10368: PUSH
10369: LD_INT 46
10371: PUSH
10372: EMPTY
10373: LIST
10374: LIST
10375: LIST
10376: LIST
10377: PUSH
10378: LD_INT 24
10380: PUSH
10381: LD_INT 3
10383: PUSH
10384: LD_INT 3
10386: PUSH
10387: LD_INT 46
10389: PUSH
10390: EMPTY
10391: LIST
10392: LIST
10393: LIST
10394: LIST
10395: PUSH
10396: LD_INT 24
10398: PUSH
10399: LD_INT 3
10401: PUSH
10402: LD_INT 3
10404: PUSH
10405: LD_INT 46
10407: PUSH
10408: EMPTY
10409: LIST
10410: LIST
10411: LIST
10412: LIST
10413: PUSH
10414: LD_INT 24
10416: PUSH
10417: LD_INT 3
10419: PUSH
10420: LD_INT 3
10422: PUSH
10423: LD_INT 46
10425: PUSH
10426: EMPTY
10427: LIST
10428: LIST
10429: LIST
10430: LIST
10431: PUSH
10432: EMPTY
10433: LIST
10434: LIST
10435: LIST
10436: LIST
10437: LIST
10438: LIST
10439: LIST
10440: PPUSH
10441: CALL 60846 0 2
// end else
10445: GO 10589
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10447: LD_INT 2
10449: PPUSH
10450: LD_INT 24
10452: PUSH
10453: LD_INT 3
10455: PUSH
10456: LD_INT 3
10458: PUSH
10459: LD_INT 47
10461: PUSH
10462: EMPTY
10463: LIST
10464: LIST
10465: LIST
10466: LIST
10467: PUSH
10468: LD_INT 24
10470: PUSH
10471: LD_INT 3
10473: PUSH
10474: LD_INT 3
10476: PUSH
10477: LD_INT 47
10479: PUSH
10480: EMPTY
10481: LIST
10482: LIST
10483: LIST
10484: LIST
10485: PUSH
10486: LD_INT 24
10488: PUSH
10489: LD_INT 3
10491: PUSH
10492: LD_INT 3
10494: PUSH
10495: LD_INT 47
10497: PUSH
10498: EMPTY
10499: LIST
10500: LIST
10501: LIST
10502: LIST
10503: PUSH
10504: LD_INT 24
10506: PUSH
10507: LD_INT 3
10509: PUSH
10510: LD_INT 3
10512: PUSH
10513: LD_INT 46
10515: PUSH
10516: EMPTY
10517: LIST
10518: LIST
10519: LIST
10520: LIST
10521: PUSH
10522: LD_INT 24
10524: PUSH
10525: LD_INT 3
10527: PUSH
10528: LD_INT 3
10530: PUSH
10531: LD_INT 46
10533: PUSH
10534: EMPTY
10535: LIST
10536: LIST
10537: LIST
10538: LIST
10539: PUSH
10540: LD_INT 24
10542: PUSH
10543: LD_INT 3
10545: PUSH
10546: LD_INT 3
10548: PUSH
10549: LD_INT 46
10551: PUSH
10552: EMPTY
10553: LIST
10554: LIST
10555: LIST
10556: LIST
10557: PUSH
10558: LD_INT 24
10560: PUSH
10561: LD_INT 3
10563: PUSH
10564: LD_INT 3
10566: PUSH
10567: LD_INT 46
10569: PUSH
10570: EMPTY
10571: LIST
10572: LIST
10573: LIST
10574: LIST
10575: PUSH
10576: EMPTY
10577: LIST
10578: LIST
10579: LIST
10580: LIST
10581: LIST
10582: LIST
10583: LIST
10584: PPUSH
10585: CALL 60846 0 2
// end ; repeat wait ( 0 0$1 ) ;
10589: LD_INT 35
10591: PPUSH
10592: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= 7 ;
10596: LD_INT 2
10598: PPUSH
10599: LD_INT 1
10601: PPUSH
10602: CALL 62264 0 2
10606: PUSH
10607: LD_INT 7
10609: GREATEREQUAL
10610: IFFALSE 10589
// wait ( 0 0$10 ) ;
10612: LD_INT 350
10614: PPUSH
10615: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10619: LD_ADDR_VAR 0 2
10623: PUSH
10624: LD_INT 2
10626: PPUSH
10627: LD_INT 1
10629: PPUSH
10630: CALL 62264 0 2
10634: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10635: LD_ADDR_EXP 118
10639: PUSH
10640: LD_EXP 118
10644: PPUSH
10645: LD_INT 2
10647: PPUSH
10648: LD_EXP 118
10652: PUSH
10653: LD_INT 2
10655: ARRAY
10656: PUSH
10657: LD_VAR 0 2
10661: DIFF
10662: PPUSH
10663: CALL_OW 1
10667: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10668: LD_ADDR_VAR 0 3
10672: PUSH
10673: LD_INT 0
10675: PPUSH
10676: LD_INT 1
10678: PPUSH
10679: CALL_OW 12
10683: ST_TO_ADDR
// if target then
10684: LD_VAR 0 3
10688: IFFALSE 10816
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10690: LD_ADDR_VAR 0 2
10694: PUSH
10695: LD_VAR 0 2
10699: PPUSH
10700: LD_INT 24
10702: PUSH
10703: LD_INT 250
10705: PUSH
10706: EMPTY
10707: LIST
10708: LIST
10709: PPUSH
10710: CALL_OW 72
10714: ST_TO_ADDR
// for i in tmp do
10715: LD_ADDR_VAR 0 1
10719: PUSH
10720: LD_VAR 0 2
10724: PUSH
10725: FOR_IN
10726: IFFALSE 10766
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10728: LD_VAR 0 1
10732: PPUSH
10733: LD_INT 139
10735: PPUSH
10736: LD_INT 89
10738: PPUSH
10739: CALL_OW 297
10743: PUSH
10744: LD_INT 9
10746: GREATER
10747: IFFALSE 10764
// ComMoveXY ( i , 139 , 89 ) ;
10749: LD_VAR 0 1
10753: PPUSH
10754: LD_INT 139
10756: PPUSH
10757: LD_INT 89
10759: PPUSH
10760: CALL_OW 111
10764: GO 10725
10766: POP
10767: POP
// wait ( 0 0$1 ) ;
10768: LD_INT 35
10770: PPUSH
10771: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10775: LD_VAR 0 2
10779: PPUSH
10780: LD_INT 92
10782: PUSH
10783: LD_INT 139
10785: PUSH
10786: LD_INT 89
10788: PUSH
10789: LD_INT 9
10791: PUSH
10792: EMPTY
10793: LIST
10794: LIST
10795: LIST
10796: LIST
10797: PPUSH
10798: CALL_OW 72
10802: PUSH
10803: LD_VAR 0 2
10807: PUSH
10808: LD_INT 1
10810: MINUS
10811: GREATEREQUAL
10812: IFFALSE 10690
// end else
10814: GO 10958
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10816: LD_VAR 0 2
10820: PPUSH
10821: LD_VAR 0 4
10825: PUSH
10826: LD_INT 1
10828: ARRAY
10829: PPUSH
10830: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10834: LD_ADDR_VAR 0 2
10838: PUSH
10839: LD_VAR 0 2
10843: PPUSH
10844: LD_INT 24
10846: PUSH
10847: LD_INT 250
10849: PUSH
10850: EMPTY
10851: LIST
10852: LIST
10853: PPUSH
10854: CALL_OW 72
10858: ST_TO_ADDR
// for i in tmp do
10859: LD_ADDR_VAR 0 1
10863: PUSH
10864: LD_VAR 0 2
10868: PUSH
10869: FOR_IN
10870: IFFALSE 10910
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10872: LD_VAR 0 1
10876: PPUSH
10877: LD_INT 124
10879: PPUSH
10880: LD_INT 139
10882: PPUSH
10883: CALL_OW 297
10887: PUSH
10888: LD_INT 9
10890: GREATER
10891: IFFALSE 10908
// ComMoveXY ( i , 124 , 139 ) ;
10893: LD_VAR 0 1
10897: PPUSH
10898: LD_INT 124
10900: PPUSH
10901: LD_INT 139
10903: PPUSH
10904: CALL_OW 111
10908: GO 10869
10910: POP
10911: POP
// wait ( 0 0$1 ) ;
10912: LD_INT 35
10914: PPUSH
10915: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10919: LD_VAR 0 2
10923: PPUSH
10924: LD_INT 92
10926: PUSH
10927: LD_INT 124
10929: PUSH
10930: LD_INT 139
10932: PUSH
10933: LD_INT 9
10935: PUSH
10936: EMPTY
10937: LIST
10938: LIST
10939: LIST
10940: LIST
10941: PPUSH
10942: CALL_OW 72
10946: PUSH
10947: LD_VAR 0 2
10951: PUSH
10952: LD_INT 1
10954: MINUS
10955: GREATEREQUAL
10956: IFFALSE 10834
// end ; repeat wait ( 0 0$1 ) ;
10958: LD_INT 35
10960: PPUSH
10961: CALL_OW 67
// for i in tmp do
10965: LD_ADDR_VAR 0 1
10969: PUSH
10970: LD_VAR 0 2
10974: PUSH
10975: FOR_IN
10976: IFFALSE 11145
// begin if GetLives ( i ) > 251 then
10978: LD_VAR 0 1
10982: PPUSH
10983: CALL_OW 256
10987: PUSH
10988: LD_INT 251
10990: GREATER
10991: IFFALSE 11116
// begin if GetWeapon ( i ) = ru_time_lapser then
10993: LD_VAR 0 1
10997: PPUSH
10998: CALL_OW 264
11002: PUSH
11003: LD_INT 49
11005: EQUAL
11006: IFFALSE 11062
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11008: LD_VAR 0 1
11012: PPUSH
11013: LD_INT 2
11015: PUSH
11016: LD_INT 22
11018: PUSH
11019: LD_INT 1
11021: PUSH
11022: EMPTY
11023: LIST
11024: LIST
11025: PUSH
11026: LD_INT 22
11028: PUSH
11029: LD_INT 8
11031: PUSH
11032: EMPTY
11033: LIST
11034: LIST
11035: PUSH
11036: EMPTY
11037: LIST
11038: LIST
11039: LIST
11040: PPUSH
11041: CALL_OW 69
11045: PPUSH
11046: LD_VAR 0 1
11050: PPUSH
11051: CALL_OW 74
11055: PPUSH
11056: CALL_OW 112
11060: GO 11114
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11062: LD_VAR 0 1
11066: PPUSH
11067: LD_INT 2
11069: PUSH
11070: LD_INT 22
11072: PUSH
11073: LD_INT 1
11075: PUSH
11076: EMPTY
11077: LIST
11078: LIST
11079: PUSH
11080: LD_INT 22
11082: PUSH
11083: LD_INT 8
11085: PUSH
11086: EMPTY
11087: LIST
11088: LIST
11089: PUSH
11090: EMPTY
11091: LIST
11092: LIST
11093: LIST
11094: PPUSH
11095: CALL_OW 69
11099: PPUSH
11100: LD_VAR 0 1
11104: PPUSH
11105: CALL_OW 74
11109: PPUSH
11110: CALL_OW 115
// end else
11114: GO 11143
// if IsDead ( i ) then
11116: LD_VAR 0 1
11120: PPUSH
11121: CALL_OW 301
11125: IFFALSE 11143
// tmp := tmp diff i ;
11127: LD_ADDR_VAR 0 2
11131: PUSH
11132: LD_VAR 0 2
11136: PUSH
11137: LD_VAR 0 1
11141: DIFF
11142: ST_TO_ADDR
// end ;
11143: GO 10975
11145: POP
11146: POP
// until not tmp ;
11147: LD_VAR 0 2
11151: NOT
11152: IFFALSE 10958
// end ;
11154: PPOPN 4
11156: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 8 and Difficulty > 1 do var i , veh , un ;
11157: LD_EXP 15
11161: PUSH
11162: LD_INT 8
11164: GREATEREQUAL
11165: PUSH
11166: LD_OWVAR 67
11170: PUSH
11171: LD_INT 1
11173: GREATER
11174: AND
11175: IFFALSE 11359
11177: GO 11179
11179: DISABLE
11180: LD_INT 0
11182: PPUSH
11183: PPUSH
11184: PPUSH
// begin ruMobile := [ ] ;
11185: LD_ADDR_EXP 75
11189: PUSH
11190: EMPTY
11191: ST_TO_ADDR
// for i := 1 to [ 3 , 4 , 5 ] [ Difficulty - 1 ] do
11192: LD_ADDR_VAR 0 1
11196: PUSH
11197: DOUBLE
11198: LD_INT 1
11200: DEC
11201: ST_TO_ADDR
11202: LD_INT 3
11204: PUSH
11205: LD_INT 4
11207: PUSH
11208: LD_INT 5
11210: PUSH
11211: EMPTY
11212: LIST
11213: LIST
11214: LIST
11215: PUSH
11216: LD_OWVAR 67
11220: PUSH
11221: LD_INT 1
11223: MINUS
11224: ARRAY
11225: PUSH
11226: FOR_TO
11227: IFFALSE 11357
// begin uc_side := 3 ;
11229: LD_ADDR_OWVAR 20
11233: PUSH
11234: LD_INT 3
11236: ST_TO_ADDR
// uc_nation := 3 ;
11237: LD_ADDR_OWVAR 21
11241: PUSH
11242: LD_INT 3
11244: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
11245: LD_INT 21
11247: PPUSH
11248: LD_INT 3
11250: PPUSH
11251: LD_INT 1
11253: PPUSH
11254: LD_INT 45
11256: PPUSH
11257: LD_INT 100
11259: PPUSH
11260: CALL 72249 0 5
// veh := CreateVehicle ;
11264: LD_ADDR_VAR 0 2
11268: PUSH
11269: CALL_OW 45
11273: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11274: LD_VAR 0 2
11278: PPUSH
11279: LD_INT 3
11281: PPUSH
11282: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11286: LD_VAR 0 2
11290: PPUSH
11291: LD_INT 29
11293: PPUSH
11294: LD_INT 0
11296: PPUSH
11297: CALL_OW 49
// PrepareMechanic ( false , 10 ) ;
11301: LD_INT 0
11303: PPUSH
11304: LD_INT 10
11306: PPUSH
11307: CALL_OW 383
// un := CreateHuman ;
11311: LD_ADDR_VAR 0 3
11315: PUSH
11316: CALL_OW 44
11320: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
11321: LD_VAR 0 3
11325: PPUSH
11326: LD_VAR 0 2
11330: PPUSH
11331: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
11335: LD_ADDR_EXP 75
11339: PUSH
11340: LD_EXP 75
11344: PPUSH
11345: LD_VAR 0 2
11349: PPUSH
11350: CALL 104683 0 2
11354: ST_TO_ADDR
// end ;
11355: GO 11226
11357: POP
11358: POP
// end ;
11359: PPOPN 3
11361: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
11362: LD_EXP 75
11366: IFFALSE 11874
11368: GO 11370
11370: DISABLE
11371: LD_INT 0
11373: PPUSH
11374: PPUSH
11375: PPUSH
// begin enable ;
11376: ENABLE
// if not ruMobile then
11377: LD_EXP 75
11381: NOT
11382: IFFALSE 11386
// exit ;
11384: GO 11874
// for i in ruMobile do
11386: LD_ADDR_VAR 0 1
11390: PUSH
11391: LD_EXP 75
11395: PUSH
11396: FOR_IN
11397: IFFALSE 11872
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
11399: LD_VAR 0 1
11403: PPUSH
11404: CALL_OW 302
11408: NOT
11409: PUSH
11410: LD_VAR 0 1
11414: PPUSH
11415: CALL_OW 255
11419: PUSH
11420: LD_INT 3
11422: NONEQUAL
11423: OR
11424: IFFALSE 11444
// begin ruMobile := ruMobile diff i ;
11426: LD_ADDR_EXP 75
11430: PUSH
11431: LD_EXP 75
11435: PUSH
11436: LD_VAR 0 1
11440: DIFF
11441: ST_TO_ADDR
// continue ;
11442: GO 11396
// end ; if GetTag ( i ) = 300 then
11444: LD_VAR 0 1
11448: PPUSH
11449: CALL_OW 110
11453: PUSH
11454: LD_INT 300
11456: EQUAL
11457: IFFALSE 11507
// begin ComMoveXY ( i , 160 , 81 ) ;
11459: LD_VAR 0 1
11463: PPUSH
11464: LD_INT 160
11466: PPUSH
11467: LD_INT 81
11469: PPUSH
11470: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
11474: LD_VAR 0 1
11478: PPUSH
11479: LD_INT 160
11481: PPUSH
11482: LD_INT 81
11484: PPUSH
11485: CALL_OW 297
11489: PUSH
11490: LD_INT 8
11492: LESS
11493: IFFALSE 11507
// SetTag ( i , 301 ) ;
11495: LD_VAR 0 1
11499: PPUSH
11500: LD_INT 301
11502: PPUSH
11503: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
11507: LD_VAR 0 1
11511: PPUSH
11512: CALL_OW 110
11516: PUSH
11517: LD_INT 301
11519: EQUAL
11520: IFFALSE 11563
// begin if not IsInArea ( i , ruMobileParkingArea ) then
11522: LD_VAR 0 1
11526: PPUSH
11527: LD_INT 33
11529: PPUSH
11530: CALL_OW 308
11534: NOT
11535: IFFALSE 11551
// ComMoveToArea ( i , ruMobileParkingArea ) else
11537: LD_VAR 0 1
11541: PPUSH
11542: LD_INT 33
11544: PPUSH
11545: CALL_OW 113
11549: GO 11563
// SetTag ( i , 302 ) ;
11551: LD_VAR 0 1
11555: PPUSH
11556: LD_INT 302
11558: PPUSH
11559: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
11563: LD_VAR 0 1
11567: PPUSH
11568: CALL_OW 110
11572: PUSH
11573: LD_INT 302
11575: EQUAL
11576: IFFALSE 11706
// begin if GetLives ( i ) < 1000 then
11578: LD_VAR 0 1
11582: PPUSH
11583: CALL_OW 256
11587: PUSH
11588: LD_INT 1000
11590: LESS
11591: IFFALSE 11683
// begin if not IsDrivenBy ( i ) then
11593: LD_VAR 0 1
11597: PPUSH
11598: CALL_OW 311
11602: NOT
11603: IFFALSE 11607
// continue ;
11605: GO 11396
// mech := IsDrivenBy ( i ) ;
11607: LD_ADDR_VAR 0 2
11611: PUSH
11612: LD_VAR 0 1
11616: PPUSH
11617: CALL_OW 311
11621: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
11622: LD_VAR 0 2
11626: PPUSH
11627: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
11631: LD_VAR 0 2
11635: PPUSH
11636: LD_VAR 0 1
11640: PPUSH
11641: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
11645: LD_INT 35
11647: PPUSH
11648: CALL_OW 67
// until GetLives ( i ) = 1000 ;
11652: LD_VAR 0 1
11656: PPUSH
11657: CALL_OW 256
11661: PUSH
11662: LD_INT 1000
11664: EQUAL
11665: IFFALSE 11645
// ComEnterUnit ( mech , i ) ;
11667: LD_VAR 0 2
11671: PPUSH
11672: LD_VAR 0 1
11676: PPUSH
11677: CALL_OW 120
// end else
11681: GO 11706
// if IsDrivenBy ( i ) then
11683: LD_VAR 0 1
11687: PPUSH
11688: CALL_OW 311
11692: IFFALSE 11706
// SetTag ( i , 0 ) ;
11694: LD_VAR 0 1
11698: PPUSH
11699: LD_INT 0
11701: PPUSH
11702: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
11706: LD_VAR 0 1
11710: PPUSH
11711: CALL_OW 110
11715: PUSH
11716: LD_INT 300
11718: LESS
11719: IFFALSE 11870
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
11721: LD_ADDR_VAR 0 3
11725: PUSH
11726: LD_INT 4
11728: PPUSH
11729: LD_INT 81
11731: PUSH
11732: LD_INT 3
11734: PUSH
11735: EMPTY
11736: LIST
11737: LIST
11738: PPUSH
11739: CALL_OW 70
11743: ST_TO_ADDR
// if GetLives ( i ) < 650 then
11744: LD_VAR 0 1
11748: PPUSH
11749: CALL_OW 256
11753: PUSH
11754: LD_INT 650
11756: LESS
11757: IFFALSE 11782
// begin ComStop ( i ) ;
11759: LD_VAR 0 1
11763: PPUSH
11764: CALL_OW 141
// SetTag ( i , 300 ) ;
11768: LD_VAR 0 1
11772: PPUSH
11773: LD_INT 300
11775: PPUSH
11776: CALL_OW 109
// continue ;
11780: GO 11396
// end ; if enemy then
11782: LD_VAR 0 3
11786: IFFALSE 11826
// begin if not HasTask ( i ) then
11788: LD_VAR 0 1
11792: PPUSH
11793: CALL_OW 314
11797: NOT
11798: IFFALSE 11824
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
11800: LD_VAR 0 1
11804: PPUSH
11805: LD_VAR 0 3
11809: PPUSH
11810: LD_VAR 0 1
11814: PPUSH
11815: CALL_OW 74
11819: PPUSH
11820: CALL_OW 115
// end else
11824: GO 11870
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
11826: LD_VAR 0 1
11830: PPUSH
11831: LD_INT 158
11833: PUSH
11834: LD_INT 61
11836: PUSH
11837: EMPTY
11838: LIST
11839: LIST
11840: PUSH
11841: LD_INT 98
11843: PUSH
11844: LD_INT 100
11846: PUSH
11847: EMPTY
11848: LIST
11849: LIST
11850: PUSH
11851: LD_INT 78
11853: PUSH
11854: LD_INT 93
11856: PUSH
11857: EMPTY
11858: LIST
11859: LIST
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: LIST
11865: PPUSH
11866: CALL 107287 0 2
// end ; end ;
11870: GO 11396
11872: POP
11873: POP
// end ; end_of_file
11874: PPOPN 3
11876: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11877: LD_INT 0
11879: PPUSH
11880: PPUSH
11881: PPUSH
11882: PPUSH
11883: PPUSH
11884: PPUSH
// side := 7 ;
11885: LD_ADDR_VAR 0 5
11889: PUSH
11890: LD_INT 7
11892: ST_TO_ADDR
// uc_side := side ;
11893: LD_ADDR_OWVAR 20
11897: PUSH
11898: LD_VAR 0 5
11902: ST_TO_ADDR
// uc_nation := 1 ;
11903: LD_ADDR_OWVAR 21
11907: PUSH
11908: LD_INT 1
11910: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11911: LD_ADDR_VAR 0 2
11915: PUSH
11916: LD_INT 22
11918: PUSH
11919: LD_VAR 0 5
11923: PUSH
11924: EMPTY
11925: LIST
11926: LIST
11927: PUSH
11928: LD_INT 21
11930: PUSH
11931: LD_INT 3
11933: PUSH
11934: EMPTY
11935: LIST
11936: LIST
11937: PUSH
11938: EMPTY
11939: LIST
11940: LIST
11941: PPUSH
11942: CALL_OW 69
11946: PUSH
11947: FOR_IN
11948: IFFALSE 11964
// SetBLevel ( i , 10 ) ;
11950: LD_VAR 0 2
11954: PPUSH
11955: LD_INT 10
11957: PPUSH
11958: CALL_OW 241
11962: GO 11947
11964: POP
11965: POP
// base := GetBase ( al_depot ) ;
11966: LD_ADDR_VAR 0 4
11970: PUSH
11971: LD_INT 2
11973: PPUSH
11974: CALL_OW 274
11978: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11979: LD_ADDR_VAR 0 6
11983: PUSH
11984: LD_INT 22
11986: PUSH
11987: LD_VAR 0 5
11991: PUSH
11992: EMPTY
11993: LIST
11994: LIST
11995: PUSH
11996: LD_INT 30
11998: PUSH
11999: LD_INT 34
12001: PUSH
12002: EMPTY
12003: LIST
12004: LIST
12005: PUSH
12006: EMPTY
12007: LIST
12008: LIST
12009: PPUSH
12010: CALL_OW 69
12014: ST_TO_ADDR
// if teleport then
12015: LD_VAR 0 6
12019: IFFALSE 12040
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
12021: LD_VAR 0 6
12025: PUSH
12026: LD_INT 1
12028: ARRAY
12029: PPUSH
12030: LD_INT 262
12032: PPUSH
12033: LD_INT 119
12035: PPUSH
12036: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
12040: LD_VAR 0 4
12044: PPUSH
12045: LD_INT 1
12047: PPUSH
12048: LD_INT 19500
12050: PPUSH
12051: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
12055: LD_VAR 0 4
12059: PPUSH
12060: LD_INT 2
12062: PPUSH
12063: LD_INT 200
12065: PPUSH
12066: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
12070: LD_VAR 0 4
12074: PPUSH
12075: LD_INT 3
12077: PPUSH
12078: LD_INT 650
12080: PPUSH
12081: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12085: LD_ADDR_EXP 76
12089: PUSH
12090: LD_STRING Roth
12092: PPUSH
12093: CALL_OW 25
12097: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12098: LD_ADDR_EXP 77
12102: PUSH
12103: LD_STRING Simms
12105: PPUSH
12106: LD_EXP 1
12110: NOT
12111: PPUSH
12112: LD_STRING 10c_
12114: PPUSH
12115: CALL 67234 0 3
12119: ST_TO_ADDR
// if not Simms then
12120: LD_EXP 77
12124: NOT
12125: IFFALSE 12155
// begin uc_nation := 1 ;
12127: LD_ADDR_OWVAR 21
12131: PUSH
12132: LD_INT 1
12134: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12135: LD_INT 2
12137: PPUSH
12138: LD_INT 10
12140: PPUSH
12141: CALL_OW 384
// Simms := CreateHuman ;
12145: LD_ADDR_EXP 77
12149: PUSH
12150: CALL_OW 44
12154: ST_TO_ADDR
// end ; uc_nation := 3 ;
12155: LD_ADDR_OWVAR 21
12159: PUSH
12160: LD_INT 3
12162: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
12163: LD_ADDR_EXP 78
12167: PUSH
12168: LD_STRING Kirilenkova
12170: PPUSH
12171: CALL_OW 25
12175: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
12176: LD_ADDR_EXP 92
12180: PUSH
12181: LD_STRING Oblukov
12183: PPUSH
12184: CALL_OW 25
12188: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
12189: LD_ADDR_EXP 79
12193: PUSH
12194: LD_STRING Dolgov
12196: PPUSH
12197: CALL_OW 25
12201: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
12202: LD_ADDR_EXP 80
12206: PUSH
12207: LD_STRING Petrosyan
12209: PPUSH
12210: CALL_OW 25
12214: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
12215: LD_ADDR_EXP 91
12219: PUSH
12220: LD_STRING Scholtze
12222: PPUSH
12223: CALL_OW 25
12227: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
12228: LD_ADDR_EXP 90
12232: PUSH
12233: LD_STRING Kapitsova
12235: PPUSH
12236: CALL_OW 25
12240: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
12241: LD_ADDR_EXP 81
12245: PUSH
12246: LD_STRING Petrovova
12248: PPUSH
12249: CALL_OW 25
12253: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
12254: LD_ADDR_EXP 82
12258: PUSH
12259: LD_STRING Kuzmov
12261: PPUSH
12262: CALL_OW 25
12266: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
12267: LD_ADDR_EXP 89
12271: PUSH
12272: LD_STRING Karamazov
12274: PPUSH
12275: CALL_OW 25
12279: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
12280: LD_STRING 13_Lipshchin_1
12282: PPUSH
12283: LD_INT 0
12285: PPUSH
12286: CALL_OW 30
12290: IFFALSE 12305
// Lipshchin := NewCharacter ( Lipshchin ) ;
12292: LD_ADDR_EXP 83
12296: PUSH
12297: LD_STRING Lipshchin
12299: PPUSH
12300: CALL_OW 25
12304: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
12305: LD_STRING 13_Titov_1
12307: PPUSH
12308: LD_INT 0
12310: PPUSH
12311: CALL_OW 30
12315: IFFALSE 12330
// Titov := NewCharacter ( Titov ) ;
12317: LD_ADDR_EXP 85
12321: PUSH
12322: LD_STRING Titov
12324: PPUSH
12325: CALL_OW 25
12329: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
12330: LD_STRING 13_Gnyevko_1
12332: PPUSH
12333: LD_INT 0
12335: PPUSH
12336: CALL_OW 30
12340: IFFALSE 12355
// Gnyevko := NewCharacter ( Gnyevko ) ;
12342: LD_ADDR_EXP 84
12346: PUSH
12347: LD_STRING Gnyevko
12349: PPUSH
12350: CALL_OW 25
12354: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
12355: LD_STRING 13_Xavier_1
12357: PPUSH
12358: LD_INT 0
12360: PPUSH
12361: CALL_OW 30
12365: IFFALSE 12380
// Xavier := NewCharacter ( Xavier2 ) ;
12367: LD_ADDR_EXP 86
12371: PUSH
12372: LD_STRING Xavier2
12374: PPUSH
12375: CALL_OW 25
12379: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
12380: LD_STRING 13_Belkov_1
12382: PPUSH
12383: LD_INT 0
12385: PPUSH
12386: CALL_OW 30
12390: IFFALSE 12405
// Belkov := NewCharacter ( Belkov ) ;
12392: LD_ADDR_EXP 87
12396: PUSH
12397: LD_STRING Belkov
12399: PPUSH
12400: CALL_OW 25
12404: ST_TO_ADDR
// if not BurlakStatus then
12405: LD_EXP 9
12409: NOT
12410: IFFALSE 12425
// Burlak = NewCharacter ( Burlak ) ;
12412: LD_ADDR_EXP 88
12416: PUSH
12417: LD_STRING Burlak
12419: PPUSH
12420: CALL_OW 25
12424: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
12425: LD_ADDR_VAR 0 3
12429: PUSH
12430: LD_EXP 76
12434: PUSH
12435: LD_EXP 78
12439: PUSH
12440: LD_EXP 92
12444: PUSH
12445: LD_EXP 79
12449: PUSH
12450: LD_EXP 80
12454: PUSH
12455: LD_EXP 91
12459: PUSH
12460: LD_EXP 90
12464: PUSH
12465: LD_EXP 81
12469: PUSH
12470: LD_EXP 82
12474: PUSH
12475: LD_EXP 89
12479: PUSH
12480: EMPTY
12481: LIST
12482: LIST
12483: LIST
12484: LIST
12485: LIST
12486: LIST
12487: LIST
12488: LIST
12489: LIST
12490: LIST
12491: ST_TO_ADDR
// if Simms then
12492: LD_EXP 77
12496: IFFALSE 12514
// tmp := tmp ^ Simms ;
12498: LD_ADDR_VAR 0 3
12502: PUSH
12503: LD_VAR 0 3
12507: PUSH
12508: LD_EXP 77
12512: ADD
12513: ST_TO_ADDR
// if Titov then
12514: LD_EXP 85
12518: IFFALSE 12536
// tmp := tmp ^ Titov ;
12520: LD_ADDR_VAR 0 3
12524: PUSH
12525: LD_VAR 0 3
12529: PUSH
12530: LD_EXP 85
12534: ADD
12535: ST_TO_ADDR
// if Lipshchin then
12536: LD_EXP 83
12540: IFFALSE 12558
// tmp := tmp ^ Lipshchin ;
12542: LD_ADDR_VAR 0 3
12546: PUSH
12547: LD_VAR 0 3
12551: PUSH
12552: LD_EXP 83
12556: ADD
12557: ST_TO_ADDR
// if Gnyevko then
12558: LD_EXP 84
12562: IFFALSE 12580
// tmp := tmp ^ Gnyevko ;
12564: LD_ADDR_VAR 0 3
12568: PUSH
12569: LD_VAR 0 3
12573: PUSH
12574: LD_EXP 84
12578: ADD
12579: ST_TO_ADDR
// if Xavier then
12580: LD_EXP 86
12584: IFFALSE 12602
// tmp := tmp ^ Xavier ;
12586: LD_ADDR_VAR 0 3
12590: PUSH
12591: LD_VAR 0 3
12595: PUSH
12596: LD_EXP 86
12600: ADD
12601: ST_TO_ADDR
// if Belkov then
12602: LD_EXP 87
12606: IFFALSE 12624
// tmp := tmp ^ Belkov ;
12608: LD_ADDR_VAR 0 3
12612: PUSH
12613: LD_VAR 0 3
12617: PUSH
12618: LD_EXP 87
12622: ADD
12623: ST_TO_ADDR
// if Burlak then
12624: LD_EXP 88
12628: IFFALSE 12646
// tmp := tmp ^ Burlak ;
12630: LD_ADDR_VAR 0 3
12634: PUSH
12635: LD_VAR 0 3
12639: PUSH
12640: LD_EXP 88
12644: ADD
12645: ST_TO_ADDR
// for i = 1 to 11 do
12646: LD_ADDR_VAR 0 2
12650: PUSH
12651: DOUBLE
12652: LD_INT 1
12654: DEC
12655: ST_TO_ADDR
12656: LD_INT 11
12658: PUSH
12659: FOR_TO
12660: IFFALSE 12726
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
12662: LD_ADDR_OWVAR 21
12666: PUSH
12667: LD_INT 1
12669: PUSH
12670: LD_INT 3
12672: PUSH
12673: EMPTY
12674: LIST
12675: LIST
12676: PUSH
12677: LD_INT 1
12679: PPUSH
12680: LD_INT 2
12682: PPUSH
12683: CALL_OW 12
12687: ARRAY
12688: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
12689: LD_INT 0
12691: PPUSH
12692: LD_VAR 0 2
12696: PUSH
12697: LD_INT 2
12699: DIV
12700: PPUSH
12701: LD_INT 10
12703: PPUSH
12704: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
12708: LD_ADDR_VAR 0 3
12712: PUSH
12713: LD_VAR 0 3
12717: PUSH
12718: CALL_OW 44
12722: ADD
12723: ST_TO_ADDR
// end ;
12724: GO 12659
12726: POP
12727: POP
// for i in tmp do
12728: LD_ADDR_VAR 0 2
12732: PUSH
12733: LD_VAR 0 3
12737: PUSH
12738: FOR_IN
12739: IFFALSE 12764
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
12741: LD_VAR 0 2
12745: PPUSH
12746: LD_INT 260
12748: PPUSH
12749: LD_INT 235
12751: PPUSH
12752: LD_INT 8
12754: PPUSH
12755: LD_INT 0
12757: PPUSH
12758: CALL_OW 50
12762: GO 12738
12764: POP
12765: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
12766: LD_ADDR_EXP 99
12770: PUSH
12771: LD_EXP 99
12775: PPUSH
12776: LD_INT 1
12778: PPUSH
12779: LD_INT 22
12781: PUSH
12782: LD_VAR 0 5
12786: PUSH
12787: EMPTY
12788: LIST
12789: LIST
12790: PUSH
12791: LD_INT 3
12793: PUSH
12794: LD_INT 21
12796: PUSH
12797: LD_INT 2
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: EMPTY
12805: LIST
12806: LIST
12807: PUSH
12808: EMPTY
12809: LIST
12810: LIST
12811: PPUSH
12812: CALL_OW 69
12816: PUSH
12817: LD_EXP 76
12821: PUSH
12822: LD_EXP 77
12826: PUSH
12827: EMPTY
12828: LIST
12829: LIST
12830: DIFF
12831: PPUSH
12832: CALL_OW 1
12836: ST_TO_ADDR
// uc_side := 0 ;
12837: LD_ADDR_OWVAR 20
12841: PUSH
12842: LD_INT 0
12844: ST_TO_ADDR
// uc_nation := 0 ;
12845: LD_ADDR_OWVAR 21
12849: PUSH
12850: LD_INT 0
12852: ST_TO_ADDR
// for i = 1 to 5 do
12853: LD_ADDR_VAR 0 2
12857: PUSH
12858: DOUBLE
12859: LD_INT 1
12861: DEC
12862: ST_TO_ADDR
12863: LD_INT 5
12865: PUSH
12866: FOR_TO
12867: IFFALSE 12904
// begin InitHc ;
12869: CALL_OW 19
// hc_class := class_apeman ;
12873: LD_ADDR_OWVAR 28
12877: PUSH
12878: LD_INT 12
12880: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12881: CALL_OW 44
12885: PPUSH
12886: LD_INT 299
12888: PPUSH
12889: LD_INT 229
12891: PPUSH
12892: LD_INT 10
12894: PPUSH
12895: LD_INT 0
12897: PPUSH
12898: CALL_OW 50
// end ;
12902: GO 12866
12904: POP
12905: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12906: LD_EXP 76
12910: PPUSH
12911: LD_INT 259
12913: PPUSH
12914: LD_INT 235
12916: PPUSH
12917: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12921: LD_EXP 76
12925: PPUSH
12926: LD_INT 262
12928: PPUSH
12929: LD_INT 235
12931: PPUSH
12932: CALL_OW 178
// if Simms then
12936: LD_EXP 77
12940: IFFALSE 12971
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12942: LD_EXP 77
12946: PPUSH
12947: LD_INT 262
12949: PPUSH
12950: LD_INT 235
12952: PPUSH
12953: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12957: LD_EXP 77
12961: PPUSH
12962: LD_EXP 76
12966: PPUSH
12967: CALL_OW 179
// end ; end ;
12971: LD_VAR 0 1
12975: RET
// every 5 5$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12976: LD_EXP 31
12980: PUSH
12981: LD_EXP 23
12985: NOT
12986: AND
12987: IFFALSE 13215
12989: GO 12991
12991: DISABLE
12992: LD_INT 0
12994: PPUSH
12995: PPUSH
12996: PPUSH
// begin enable ;
12997: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12998: LD_ADDR_VAR 0 2
13002: PUSH
13003: LD_INT 81
13005: PUSH
13006: LD_INT 7
13008: PUSH
13009: EMPTY
13010: LIST
13011: LIST
13012: PUSH
13013: LD_INT 2
13015: PUSH
13016: LD_INT 32
13018: PUSH
13019: LD_INT 3
13021: PUSH
13022: EMPTY
13023: LIST
13024: LIST
13025: PUSH
13026: LD_INT 30
13028: PUSH
13029: LD_INT 30
13031: PUSH
13032: EMPTY
13033: LIST
13034: LIST
13035: PUSH
13036: LD_INT 30
13038: PUSH
13039: LD_INT 28
13041: PUSH
13042: EMPTY
13043: LIST
13044: LIST
13045: PUSH
13046: LD_INT 34
13048: PUSH
13049: LD_INT 49
13051: PUSH
13052: EMPTY
13053: LIST
13054: LIST
13055: PUSH
13056: LD_INT 34
13058: PUSH
13059: LD_INT 10
13061: PUSH
13062: EMPTY
13063: LIST
13064: LIST
13065: PUSH
13066: LD_INT 34
13068: PUSH
13069: LD_INT 8
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: PUSH
13076: EMPTY
13077: LIST
13078: LIST
13079: LIST
13080: LIST
13081: LIST
13082: LIST
13083: LIST
13084: PUSH
13085: EMPTY
13086: LIST
13087: LIST
13088: PPUSH
13089: CALL_OW 69
13093: ST_TO_ADDR
// if not tmp then
13094: LD_VAR 0 2
13098: NOT
13099: IFFALSE 13103
// exit ;
13101: GO 13215
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
13103: LD_VAR 0 2
13107: PPUSH
13108: LD_INT 34
13110: PUSH
13111: LD_INT 8
13113: PUSH
13114: EMPTY
13115: LIST
13116: LIST
13117: PPUSH
13118: CALL_OW 72
13122: IFFALSE 13155
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
13124: LD_ADDR_VAR 0 3
13128: PUSH
13129: LD_VAR 0 2
13133: PPUSH
13134: LD_INT 34
13136: PUSH
13137: LD_INT 8
13139: PUSH
13140: EMPTY
13141: LIST
13142: LIST
13143: PPUSH
13144: CALL_OW 72
13148: PUSH
13149: LD_INT 1
13151: ARRAY
13152: ST_TO_ADDR
13153: GO 13179
// target := tmp [ rand ( 1 , tmp ) ] ;
13155: LD_ADDR_VAR 0 3
13159: PUSH
13160: LD_VAR 0 2
13164: PUSH
13165: LD_INT 1
13167: PPUSH
13168: LD_VAR 0 2
13172: PPUSH
13173: CALL_OW 12
13177: ARRAY
13178: ST_TO_ADDR
// if GetSide ( target ) = 1 then
13179: LD_VAR 0 3
13183: PPUSH
13184: CALL_OW 255
13188: PUSH
13189: LD_INT 1
13191: EQUAL
13192: IFFALSE 13203
// CenterNowOnUnits ( target ) ;
13194: LD_VAR 0 3
13198: PPUSH
13199: CALL_OW 87
// SetLives ( target , 0 ) ;
13203: LD_VAR 0 3
13207: PPUSH
13208: LD_INT 0
13210: PPUSH
13211: CALL_OW 234
// end ;
13215: PPOPN 3
13217: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
13218: LD_EXP 23
13222: NOT
13223: PUSH
13224: LD_EXP 31
13228: AND
13229: IFFALSE 13755
13231: GO 13233
13233: DISABLE
13234: LD_INT 0
13236: PPUSH
13237: PPUSH
13238: PPUSH
// begin uc_side := 7 ;
13239: LD_ADDR_OWVAR 20
13243: PUSH
13244: LD_INT 7
13246: ST_TO_ADDR
// uc_nation := 1 ;
13247: LD_ADDR_OWVAR 21
13251: PUSH
13252: LD_INT 1
13254: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
13255: LD_ADDR_VAR 0 3
13259: PUSH
13260: LD_INT 125
13262: PUSH
13263: LD_INT 163
13265: PUSH
13266: EMPTY
13267: LIST
13268: LIST
13269: PUSH
13270: LD_INT 185
13272: PUSH
13273: LD_INT 168
13275: PUSH
13276: EMPTY
13277: LIST
13278: LIST
13279: PUSH
13280: LD_INT 111
13282: PUSH
13283: LD_INT 97
13285: PUSH
13286: EMPTY
13287: LIST
13288: LIST
13289: PUSH
13290: EMPTY
13291: LIST
13292: LIST
13293: LIST
13294: PPUSH
13295: CALL 104788 0 1
13299: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
13300: LD_ADDR_EXP 93
13304: PUSH
13305: EMPTY
13306: ST_TO_ADDR
// for i = 1 to Difficulty do
13307: LD_ADDR_VAR 0 1
13311: PUSH
13312: DOUBLE
13313: LD_INT 1
13315: DEC
13316: ST_TO_ADDR
13317: LD_OWVAR 67
13321: PUSH
13322: FOR_TO
13323: IFFALSE 13481
// begin InitHc ;
13325: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
13329: LD_INT 0
13331: PPUSH
13332: LD_INT 8
13334: PPUSH
13335: CALL_OW 381
// un := CreateHuman ;
13339: LD_ADDR_VAR 0 2
13343: PUSH
13344: CALL_OW 44
13348: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
13349: LD_VAR 0 2
13353: PPUSH
13354: LD_INT 258
13356: PPUSH
13357: LD_INT 267
13359: PPUSH
13360: LD_INT 4
13362: PPUSH
13363: LD_INT 0
13365: PPUSH
13366: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
13370: LD_ADDR_EXP 93
13374: PUSH
13375: LD_EXP 93
13379: PUSH
13380: LD_VAR 0 2
13384: UNION
13385: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
13386: LD_VAR 0 2
13390: PPUSH
13391: LD_VAR 0 3
13395: PUSH
13396: LD_VAR 0 1
13400: ARRAY
13401: PUSH
13402: LD_INT 1
13404: ARRAY
13405: PPUSH
13406: LD_VAR 0 3
13410: PUSH
13411: LD_VAR 0 1
13415: ARRAY
13416: PUSH
13417: LD_INT 2
13419: ARRAY
13420: PPUSH
13421: LD_INT 4
13423: PPUSH
13424: LD_INT 1
13426: PPUSH
13427: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
13431: LD_VAR 0 2
13435: PPUSH
13436: LD_VAR 0 3
13440: PUSH
13441: LD_VAR 0 1
13445: ARRAY
13446: PUSH
13447: LD_INT 1
13449: ARRAY
13450: PPUSH
13451: LD_VAR 0 3
13455: PUSH
13456: LD_VAR 0 1
13460: ARRAY
13461: PUSH
13462: LD_INT 2
13464: ARRAY
13465: PPUSH
13466: CALL_OW 171
// AddComInvisible ( un ) ;
13470: LD_VAR 0 2
13474: PPUSH
13475: CALL_OW 212
// end ;
13479: GO 13322
13481: POP
13482: POP
// repeat wait ( 0 0$20 ) ;
13483: LD_INT 700
13485: PPUSH
13486: CALL_OW 67
// for i in allianceSpecialForce do
13490: LD_ADDR_VAR 0 1
13494: PUSH
13495: LD_EXP 93
13499: PUSH
13500: FOR_IN
13501: IFFALSE 13740
// begin if IsInvisible ( i ) then
13503: LD_VAR 0 1
13507: PPUSH
13508: CALL_OW 571
13512: IFFALSE 13709
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 , 40 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
13514: LD_ADDR_VAR 0 3
13518: PUSH
13519: LD_INT 22
13521: PUSH
13522: LD_INT 1
13524: PUSH
13525: EMPTY
13526: LIST
13527: LIST
13528: PUSH
13529: LD_INT 50
13531: PUSH
13532: EMPTY
13533: LIST
13534: PUSH
13535: LD_INT 56
13537: PUSH
13538: EMPTY
13539: LIST
13540: PUSH
13541: LD_INT 91
13543: PUSH
13544: LD_VAR 0 1
13548: PUSH
13549: LD_INT 25
13551: PUSH
13552: LD_INT 30
13554: PUSH
13555: LD_INT 35
13557: PUSH
13558: LD_INT 40
13560: PUSH
13561: EMPTY
13562: LIST
13563: LIST
13564: LIST
13565: LIST
13566: PUSH
13567: LD_OWVAR 67
13571: ARRAY
13572: PUSH
13573: EMPTY
13574: LIST
13575: LIST
13576: LIST
13577: PUSH
13578: LD_INT 2
13580: PUSH
13581: LD_INT 25
13583: PUSH
13584: LD_INT 1
13586: PUSH
13587: EMPTY
13588: LIST
13589: LIST
13590: PUSH
13591: LD_INT 25
13593: PUSH
13594: LD_INT 2
13596: PUSH
13597: EMPTY
13598: LIST
13599: LIST
13600: PUSH
13601: LD_INT 25
13603: PUSH
13604: LD_INT 3
13606: PUSH
13607: EMPTY
13608: LIST
13609: LIST
13610: PUSH
13611: LD_INT 25
13613: PUSH
13614: LD_INT 4
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: PUSH
13621: LD_INT 25
13623: PUSH
13624: LD_INT 5
13626: PUSH
13627: EMPTY
13628: LIST
13629: LIST
13630: PUSH
13631: LD_INT 25
13633: PUSH
13634: LD_INT 8
13636: PUSH
13637: EMPTY
13638: LIST
13639: LIST
13640: PUSH
13641: EMPTY
13642: LIST
13643: LIST
13644: LIST
13645: LIST
13646: LIST
13647: LIST
13648: LIST
13649: PUSH
13650: EMPTY
13651: LIST
13652: LIST
13653: LIST
13654: LIST
13655: LIST
13656: PPUSH
13657: CALL_OW 69
13661: ST_TO_ADDR
// if not tmp then
13662: LD_VAR 0 3
13666: NOT
13667: IFFALSE 13671
// continue ;
13669: GO 13500
// if Prob ( 30 * Difficulty ) then
13671: LD_INT 30
13673: PUSH
13674: LD_OWVAR 67
13678: MUL
13679: PPUSH
13680: CALL_OW 13
13684: IFFALSE 13709
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
13686: LD_VAR 0 3
13690: PUSH
13691: LD_INT 1
13693: PPUSH
13694: LD_VAR 0 3
13698: PPUSH
13699: CALL_OW 12
13703: ARRAY
13704: PPUSH
13705: CALL 32644 0 1
// end ; if IsDead ( i ) then
13709: LD_VAR 0 1
13713: PPUSH
13714: CALL_OW 301
13718: IFFALSE 13738
// begin allianceSpecialForce := allianceSpecialForce diff i ;
13720: LD_ADDR_EXP 93
13724: PUSH
13725: LD_EXP 93
13729: PUSH
13730: LD_VAR 0 1
13734: DIFF
13735: ST_TO_ADDR
// continue ;
13736: GO 13500
// end ; end ;
13738: GO 13500
13740: POP
13741: POP
// until allianceDestroyed or not allianceSpecialForce ;
13742: LD_EXP 23
13746: PUSH
13747: LD_EXP 93
13751: NOT
13752: OR
13753: IFFALSE 13483
// end ;
13755: PPOPN 3
13757: END
// every 12 12$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
13758: LD_EXP 23
13762: NOT
13763: PUSH
13764: LD_EXP 31
13768: AND
13769: IFFALSE 14719
13771: GO 13773
13773: DISABLE
13774: LD_INT 0
13776: PPUSH
13777: PPUSH
13778: PPUSH
13779: PPUSH
// begin enable ;
13780: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
13781: LD_INT 22
13783: PUSH
13784: LD_INT 7
13786: PUSH
13787: EMPTY
13788: LIST
13789: LIST
13790: PUSH
13791: LD_INT 30
13793: PUSH
13794: LD_INT 3
13796: PUSH
13797: EMPTY
13798: LIST
13799: LIST
13800: PUSH
13801: EMPTY
13802: LIST
13803: LIST
13804: PPUSH
13805: CALL_OW 69
13809: NOT
13810: IFFALSE 13814
// exit ;
13812: GO 14719
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
13814: LD_ADDR_VAR 0 4
13818: PUSH
13819: LD_INT 22
13821: PUSH
13822: LD_INT 7
13824: PUSH
13825: EMPTY
13826: LIST
13827: LIST
13828: PUSH
13829: LD_INT 30
13831: PUSH
13832: LD_INT 34
13834: PUSH
13835: EMPTY
13836: LIST
13837: LIST
13838: PUSH
13839: EMPTY
13840: LIST
13841: LIST
13842: PPUSH
13843: CALL_OW 69
13847: ST_TO_ADDR
// if Prob ( 40 ) then
13848: LD_INT 40
13850: PPUSH
13851: CALL_OW 13
13855: IFFALSE 14001
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
13857: LD_INT 1
13859: PPUSH
13860: LD_INT 5
13862: PUSH
13863: LD_INT 3
13865: PUSH
13866: LD_INT 2
13868: PUSH
13869: LD_INT 6
13871: PUSH
13872: EMPTY
13873: LIST
13874: LIST
13875: LIST
13876: LIST
13877: PUSH
13878: LD_INT 5
13880: PUSH
13881: LD_INT 3
13883: PUSH
13884: LD_INT 2
13886: PUSH
13887: LD_INT 6
13889: PUSH
13890: EMPTY
13891: LIST
13892: LIST
13893: LIST
13894: LIST
13895: PUSH
13896: LD_INT 5
13898: PUSH
13899: LD_INT 3
13901: PUSH
13902: LD_INT 2
13904: PUSH
13905: LD_INT 6
13907: PUSH
13908: EMPTY
13909: LIST
13910: LIST
13911: LIST
13912: LIST
13913: PUSH
13914: LD_INT 5
13916: PUSH
13917: LD_INT 3
13919: PUSH
13920: LD_INT 2
13922: PUSH
13923: LD_INT 9
13925: PUSH
13926: EMPTY
13927: LIST
13928: LIST
13929: LIST
13930: LIST
13931: PUSH
13932: LD_INT 24
13934: PUSH
13935: LD_INT 3
13937: PUSH
13938: LD_INT 3
13940: PUSH
13941: LD_INT 45
13943: PUSH
13944: EMPTY
13945: LIST
13946: LIST
13947: LIST
13948: LIST
13949: PUSH
13950: LD_INT 24
13952: PUSH
13953: LD_INT 3
13955: PUSH
13956: LD_INT 3
13958: PUSH
13959: LD_INT 47
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: LIST
13966: LIST
13967: PUSH
13968: LD_INT 24
13970: PUSH
13971: LD_INT 3
13973: PUSH
13974: LD_INT 3
13976: PUSH
13977: LD_INT 45
13979: PUSH
13980: EMPTY
13981: LIST
13982: LIST
13983: LIST
13984: LIST
13985: PUSH
13986: EMPTY
13987: LIST
13988: LIST
13989: LIST
13990: LIST
13991: LIST
13992: LIST
13993: LIST
13994: PPUSH
13995: CALL 60846 0 2
// end else
13999: GO 14143
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
14001: LD_INT 1
14003: PPUSH
14004: LD_INT 24
14006: PUSH
14007: LD_INT 3
14009: PUSH
14010: LD_INT 3
14012: PUSH
14013: LD_INT 47
14015: PUSH
14016: EMPTY
14017: LIST
14018: LIST
14019: LIST
14020: LIST
14021: PUSH
14022: LD_INT 24
14024: PUSH
14025: LD_INT 3
14027: PUSH
14028: LD_INT 3
14030: PUSH
14031: LD_INT 47
14033: PUSH
14034: EMPTY
14035: LIST
14036: LIST
14037: LIST
14038: LIST
14039: PUSH
14040: LD_INT 5
14042: PUSH
14043: LD_INT 3
14045: PUSH
14046: LD_INT 2
14048: PUSH
14049: LD_INT 9
14051: PUSH
14052: EMPTY
14053: LIST
14054: LIST
14055: LIST
14056: LIST
14057: PUSH
14058: LD_INT 5
14060: PUSH
14061: LD_INT 3
14063: PUSH
14064: LD_INT 2
14066: PUSH
14067: LD_INT 9
14069: PUSH
14070: EMPTY
14071: LIST
14072: LIST
14073: LIST
14074: LIST
14075: PUSH
14076: LD_INT 5
14078: PUSH
14079: LD_INT 3
14081: PUSH
14082: LD_INT 2
14084: PUSH
14085: LD_INT 9
14087: PUSH
14088: EMPTY
14089: LIST
14090: LIST
14091: LIST
14092: LIST
14093: PUSH
14094: LD_INT 24
14096: PUSH
14097: LD_INT 1
14099: PUSH
14100: LD_INT 3
14102: PUSH
14103: LD_INT 45
14105: PUSH
14106: EMPTY
14107: LIST
14108: LIST
14109: LIST
14110: LIST
14111: PUSH
14112: LD_INT 24
14114: PUSH
14115: LD_INT 1
14117: PUSH
14118: LD_INT 3
14120: PUSH
14121: LD_INT 45
14123: PUSH
14124: EMPTY
14125: LIST
14126: LIST
14127: LIST
14128: LIST
14129: PUSH
14130: EMPTY
14131: LIST
14132: LIST
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: PPUSH
14139: CALL 60846 0 2
// end ; repeat wait ( 0 0$1 ) ;
14143: LD_INT 35
14145: PPUSH
14146: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= 7 ;
14150: LD_INT 1
14152: PPUSH
14153: LD_INT 1
14155: PPUSH
14156: CALL 62264 0 2
14160: PUSH
14161: LD_INT 7
14163: GREATEREQUAL
14164: IFFALSE 14143
// wait ( 0 0$10 ) ;
14166: LD_INT 350
14168: PPUSH
14169: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
14173: LD_ADDR_VAR 0 2
14177: PUSH
14178: LD_INT 1
14180: PPUSH
14181: LD_INT 1
14183: PPUSH
14184: CALL 62264 0 2
14188: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
14189: LD_ADDR_EXP 118
14193: PUSH
14194: LD_EXP 118
14198: PPUSH
14199: LD_INT 1
14201: PPUSH
14202: LD_EXP 118
14206: PUSH
14207: LD_INT 1
14209: ARRAY
14210: PUSH
14211: LD_VAR 0 2
14215: DIFF
14216: PPUSH
14217: CALL_OW 1
14221: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
14222: LD_ADDR_VAR 0 3
14226: PUSH
14227: LD_INT 0
14229: PPUSH
14230: LD_INT 1
14232: PPUSH
14233: CALL_OW 12
14237: ST_TO_ADDR
// if target then
14238: LD_VAR 0 3
14242: IFFALSE 14408
// begin for i in tmp do
14244: LD_ADDR_VAR 0 1
14248: PUSH
14249: LD_VAR 0 2
14253: PUSH
14254: FOR_IN
14255: IFFALSE 14280
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
14257: LD_VAR 0 1
14261: PPUSH
14262: LD_INT 179
14264: PPUSH
14265: LD_INT 209
14267: PPUSH
14268: LD_INT 8
14270: PPUSH
14271: LD_INT 1
14273: PPUSH
14274: CALL_OW 483
14278: GO 14254
14280: POP
14281: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
14282: LD_ADDR_VAR 0 2
14286: PUSH
14287: LD_VAR 0 2
14291: PPUSH
14292: LD_INT 24
14294: PUSH
14295: LD_INT 250
14297: PUSH
14298: EMPTY
14299: LIST
14300: LIST
14301: PPUSH
14302: CALL_OW 72
14306: ST_TO_ADDR
// for i in tmp do
14307: LD_ADDR_VAR 0 1
14311: PUSH
14312: LD_VAR 0 2
14316: PUSH
14317: FOR_IN
14318: IFFALSE 14358
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
14320: LD_VAR 0 1
14324: PPUSH
14325: LD_INT 179
14327: PPUSH
14328: LD_INT 209
14330: PPUSH
14331: CALL_OW 297
14335: PUSH
14336: LD_INT 9
14338: GREATER
14339: IFFALSE 14356
// ComMoveXY ( i , 179 , 209 ) ;
14341: LD_VAR 0 1
14345: PPUSH
14346: LD_INT 179
14348: PPUSH
14349: LD_INT 209
14351: PPUSH
14352: CALL_OW 111
14356: GO 14317
14358: POP
14359: POP
// wait ( 0 0$1 ) ;
14360: LD_INT 35
14362: PPUSH
14363: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
14367: LD_VAR 0 2
14371: PPUSH
14372: LD_INT 92
14374: PUSH
14375: LD_INT 179
14377: PUSH
14378: LD_INT 209
14380: PUSH
14381: LD_INT 9
14383: PUSH
14384: EMPTY
14385: LIST
14386: LIST
14387: LIST
14388: LIST
14389: PPUSH
14390: CALL_OW 72
14394: PUSH
14395: LD_VAR 0 2
14399: PUSH
14400: LD_INT 1
14402: MINUS
14403: GREATEREQUAL
14404: IFFALSE 14282
// end else
14406: GO 14570
// begin for i in tmp do
14408: LD_ADDR_VAR 0 1
14412: PUSH
14413: LD_VAR 0 2
14417: PUSH
14418: FOR_IN
14419: IFFALSE 14444
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
14421: LD_VAR 0 1
14425: PPUSH
14426: LD_INT 285
14428: PPUSH
14429: LD_INT 163
14431: PPUSH
14432: LD_INT 8
14434: PPUSH
14435: LD_INT 1
14437: PPUSH
14438: CALL_OW 483
14442: GO 14418
14444: POP
14445: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
14446: LD_ADDR_VAR 0 2
14450: PUSH
14451: LD_VAR 0 2
14455: PPUSH
14456: LD_INT 24
14458: PUSH
14459: LD_INT 250
14461: PUSH
14462: EMPTY
14463: LIST
14464: LIST
14465: PPUSH
14466: CALL_OW 72
14470: ST_TO_ADDR
// for i in tmp do
14471: LD_ADDR_VAR 0 1
14475: PUSH
14476: LD_VAR 0 2
14480: PUSH
14481: FOR_IN
14482: IFFALSE 14522
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
14484: LD_VAR 0 1
14488: PPUSH
14489: LD_INT 285
14491: PPUSH
14492: LD_INT 163
14494: PPUSH
14495: CALL_OW 297
14499: PUSH
14500: LD_INT 9
14502: GREATER
14503: IFFALSE 14520
// ComMoveXY ( i , 285 , 163 ) ;
14505: LD_VAR 0 1
14509: PPUSH
14510: LD_INT 285
14512: PPUSH
14513: LD_INT 163
14515: PPUSH
14516: CALL_OW 111
14520: GO 14481
14522: POP
14523: POP
// wait ( 0 0$1 ) ;
14524: LD_INT 35
14526: PPUSH
14527: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
14531: LD_VAR 0 2
14535: PPUSH
14536: LD_INT 92
14538: PUSH
14539: LD_INT 285
14541: PUSH
14542: LD_INT 163
14544: PUSH
14545: LD_INT 9
14547: PUSH
14548: EMPTY
14549: LIST
14550: LIST
14551: LIST
14552: LIST
14553: PPUSH
14554: CALL_OW 72
14558: PUSH
14559: LD_VAR 0 2
14563: PUSH
14564: LD_INT 1
14566: MINUS
14567: GREATEREQUAL
14568: IFFALSE 14446
// end ; repeat wait ( 0 0$1 ) ;
14570: LD_INT 35
14572: PPUSH
14573: CALL_OW 67
// for i in tmp do
14577: LD_ADDR_VAR 0 1
14581: PUSH
14582: LD_VAR 0 2
14586: PUSH
14587: FOR_IN
14588: IFFALSE 14710
// if GetLives ( i ) > 251 then
14590: LD_VAR 0 1
14594: PPUSH
14595: CALL_OW 256
14599: PUSH
14600: LD_INT 251
14602: GREATER
14603: IFFALSE 14692
// begin if GetWeapon ( i ) = ru_time_lapser then
14605: LD_VAR 0 1
14609: PPUSH
14610: CALL_OW 264
14614: PUSH
14615: LD_INT 49
14617: EQUAL
14618: IFFALSE 14656
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
14620: LD_VAR 0 1
14624: PPUSH
14625: LD_INT 81
14627: PUSH
14628: LD_INT 7
14630: PUSH
14631: EMPTY
14632: LIST
14633: LIST
14634: PPUSH
14635: CALL_OW 69
14639: PPUSH
14640: LD_VAR 0 1
14644: PPUSH
14645: CALL_OW 74
14649: PPUSH
14650: CALL_OW 112
14654: GO 14690
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
14656: LD_VAR 0 1
14660: PPUSH
14661: LD_INT 81
14663: PUSH
14664: LD_INT 7
14666: PUSH
14667: EMPTY
14668: LIST
14669: LIST
14670: PPUSH
14671: CALL_OW 69
14675: PPUSH
14676: LD_VAR 0 1
14680: PPUSH
14681: CALL_OW 74
14685: PPUSH
14686: CALL_OW 115
// end else
14690: GO 14708
// tmp := tmp diff i ;
14692: LD_ADDR_VAR 0 2
14696: PUSH
14697: LD_VAR 0 2
14701: PUSH
14702: LD_VAR 0 1
14706: DIFF
14707: ST_TO_ADDR
14708: GO 14587
14710: POP
14711: POP
// until not tmp ;
14712: LD_VAR 0 2
14716: NOT
14717: IFFALSE 14570
// end ; end_of_file
14719: PPOPN 4
14721: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
14722: LD_INT 0
14724: PPUSH
14725: PPUSH
14726: PPUSH
14727: PPUSH
// missionStage := 13 ;
14728: LD_ADDR_EXP 15
14732: PUSH
14733: LD_INT 13
14735: ST_TO_ADDR
// uc_side := 2 ;
14736: LD_ADDR_OWVAR 20
14740: PUSH
14741: LD_INT 2
14743: ST_TO_ADDR
// uc_nation := 2 ;
14744: LD_ADDR_OWVAR 21
14748: PUSH
14749: LD_INT 2
14751: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
14752: LD_ADDR_EXP 94
14756: PUSH
14757: LD_STRING Omar
14759: PPUSH
14760: CALL_OW 25
14764: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
14765: LD_EXP 94
14769: PPUSH
14770: LD_INT 4
14772: PPUSH
14773: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
14777: LD_EXP 94
14781: PPUSH
14782: LD_INT 242
14784: PPUSH
14785: LD_INT 75
14787: PPUSH
14788: LD_INT 0
14790: PPUSH
14791: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
14795: LD_ADDR_EXP 95
14799: PUSH
14800: LD_STRING Heike
14802: PPUSH
14803: CALL_OW 25
14807: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
14808: LD_INT 14
14810: PPUSH
14811: LD_INT 3
14813: PPUSH
14814: LD_INT 1
14816: PPUSH
14817: LD_INT 27
14819: PPUSH
14820: LD_INT 100
14822: PPUSH
14823: CALL 72249 0 5
// veh := CreateVehicle ;
14827: LD_ADDR_VAR 0 3
14831: PUSH
14832: CALL_OW 45
14836: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
14837: LD_VAR 0 3
14841: PPUSH
14842: LD_INT 2
14844: NEG
14845: PPUSH
14846: CALL_OW 242
// SetDir ( veh , 4 ) ;
14850: LD_VAR 0 3
14854: PPUSH
14855: LD_INT 4
14857: PPUSH
14858: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14862: LD_VAR 0 3
14866: PPUSH
14867: LD_INT 241
14869: PPUSH
14870: LD_INT 72
14872: PPUSH
14873: LD_INT 0
14875: PPUSH
14876: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14880: LD_EXP 95
14884: PPUSH
14885: LD_VAR 0 3
14889: PPUSH
14890: CALL_OW 52
// if KhatamStatus then
14894: LD_EXP 8
14898: IFFALSE 14961
// begin Khatam := NewCharacter ( Khatam ) ;
14900: LD_ADDR_EXP 96
14904: PUSH
14905: LD_STRING Khatam
14907: PPUSH
14908: CALL_OW 25
14912: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14913: LD_EXP 96
14917: PPUSH
14918: LD_INT 245
14920: PPUSH
14921: LD_INT 78
14923: PPUSH
14924: LD_INT 3
14926: PPUSH
14927: LD_INT 0
14929: PPUSH
14930: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14934: LD_EXP 96
14938: PPUSH
14939: LD_INT 4
14941: PPUSH
14942: LD_INT 10
14944: PPUSH
14945: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
14949: LD_EXP 96
14953: PPUSH
14954: LD_INT 4
14956: PPUSH
14957: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
14961: LD_ADDR_VAR 0 2
14965: PUSH
14966: DOUBLE
14967: LD_INT 1
14969: DEC
14970: ST_TO_ADDR
14971: LD_INT 2
14973: PUSH
14974: LD_INT 2
14976: PUSH
14977: LD_INT 3
14979: PUSH
14980: LD_INT 3
14982: PUSH
14983: EMPTY
14984: LIST
14985: LIST
14986: LIST
14987: LIST
14988: PUSH
14989: LD_OWVAR 67
14993: ARRAY
14994: PUSH
14995: FOR_TO
14996: IFFALSE 15062
// begin PrepareScientist ( false , 6 + Difficulty ) ;
14998: LD_INT 0
15000: PPUSH
15001: LD_INT 6
15003: PUSH
15004: LD_OWVAR 67
15008: PLUS
15009: PPUSH
15010: CALL_OW 384
// un := CreateHuman ;
15014: LD_ADDR_VAR 0 4
15018: PUSH
15019: CALL_OW 44
15023: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
15024: LD_VAR 0 4
15028: PPUSH
15029: LD_INT 28
15031: PUSH
15032: LD_INT 29
15034: PUSH
15035: EMPTY
15036: LIST
15037: LIST
15038: PUSH
15039: LD_VAR 0 2
15043: PUSH
15044: LD_INT 2
15046: MOD
15047: PUSH
15048: LD_INT 1
15050: PLUS
15051: ARRAY
15052: PPUSH
15053: LD_INT 0
15055: PPUSH
15056: CALL_OW 49
// end ;
15060: GO 14995
15062: POP
15063: POP
// for i = 1 to 6 do
15064: LD_ADDR_VAR 0 2
15068: PUSH
15069: DOUBLE
15070: LD_INT 1
15072: DEC
15073: ST_TO_ADDR
15074: LD_INT 6
15076: PUSH
15077: FOR_TO
15078: IFFALSE 15123
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
15080: LD_INT 0
15082: PPUSH
15083: LD_INT 6
15085: PUSH
15086: LD_OWVAR 67
15090: PLUS
15091: PPUSH
15092: CALL_OW 381
// un := CreateHuman ;
15096: LD_ADDR_VAR 0 4
15100: PUSH
15101: CALL_OW 44
15105: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
15106: LD_VAR 0 4
15110: PPUSH
15111: LD_INT 32
15113: PPUSH
15114: LD_INT 0
15116: PPUSH
15117: CALL_OW 49
// end ;
15121: GO 15077
15123: POP
15124: POP
// for i = 1 to 3 do
15125: LD_ADDR_VAR 0 2
15129: PUSH
15130: DOUBLE
15131: LD_INT 1
15133: DEC
15134: ST_TO_ADDR
15135: LD_INT 3
15137: PUSH
15138: FOR_TO
15139: IFFALSE 15187
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
15141: LD_INT 0
15143: PPUSH
15144: LD_INT 8
15146: PPUSH
15147: LD_INT 6
15149: PUSH
15150: LD_OWVAR 67
15154: PLUS
15155: PPUSH
15156: CALL_OW 380
// un := CreateHuman ;
15160: LD_ADDR_VAR 0 4
15164: PUSH
15165: CALL_OW 44
15169: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
15170: LD_VAR 0 4
15174: PPUSH
15175: LD_INT 32
15177: PPUSH
15178: LD_INT 0
15180: PPUSH
15181: CALL_OW 49
// end ;
15185: GO 15138
15187: POP
15188: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
15189: LD_ADDR_VAR 0 2
15193: PUSH
15194: DOUBLE
15195: LD_INT 1
15197: DEC
15198: ST_TO_ADDR
15199: LD_INT 2
15201: PUSH
15202: LD_INT 3
15204: PUSH
15205: LD_INT 4
15207: PUSH
15208: LD_INT 4
15210: PUSH
15211: EMPTY
15212: LIST
15213: LIST
15214: LIST
15215: LIST
15216: PUSH
15217: LD_OWVAR 67
15221: ARRAY
15222: PUSH
15223: FOR_TO
15224: IFFALSE 15314
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
15226: LD_INT 14
15228: PPUSH
15229: LD_INT 2
15231: PPUSH
15232: LD_INT 1
15234: PPUSH
15235: LD_INT 28
15237: PPUSH
15238: LD_INT 80
15240: PPUSH
15241: CALL 72249 0 5
// veh := CreateVehicle ;
15245: LD_ADDR_VAR 0 3
15249: PUSH
15250: CALL_OW 45
15254: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
15255: LD_VAR 0 3
15259: PPUSH
15260: LD_INT 3
15262: PPUSH
15263: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
15267: LD_VAR 0 3
15271: PPUSH
15272: LD_INT 29
15274: PPUSH
15275: LD_INT 0
15277: PPUSH
15278: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
15282: LD_INT 0
15284: PPUSH
15285: LD_INT 6
15287: PUSH
15288: LD_OWVAR 67
15292: PLUS
15293: PPUSH
15294: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
15298: CALL_OW 44
15302: PPUSH
15303: LD_VAR 0 3
15307: PPUSH
15308: CALL_OW 52
// end ;
15312: GO 15223
15314: POP
15315: POP
// for i = 1 to 5 + Difficulty do
15316: LD_ADDR_VAR 0 2
15320: PUSH
15321: DOUBLE
15322: LD_INT 1
15324: DEC
15325: ST_TO_ADDR
15326: LD_INT 5
15328: PUSH
15329: LD_OWVAR 67
15333: PLUS
15334: PUSH
15335: FOR_TO
15336: IFFALSE 15463
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
15338: LD_INT 14
15340: PPUSH
15341: LD_INT 1
15343: PPUSH
15344: LD_INT 3
15346: PPUSH
15347: CALL_OW 12
15351: PPUSH
15352: LD_INT 1
15354: PPUSH
15355: LD_INT 28
15357: PUSH
15358: LD_INT 26
15360: PUSH
15361: LD_INT 27
15363: PUSH
15364: LD_INT 25
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: LIST
15371: LIST
15372: PUSH
15373: LD_VAR 0 2
15377: PUSH
15378: LD_INT 4
15380: MOD
15381: PUSH
15382: LD_INT 1
15384: PLUS
15385: ARRAY
15386: PPUSH
15387: LD_INT 80
15389: PPUSH
15390: CALL 72249 0 5
// veh := CreateVehicle ;
15394: LD_ADDR_VAR 0 3
15398: PUSH
15399: CALL_OW 45
15403: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
15404: LD_VAR 0 3
15408: PPUSH
15409: LD_INT 4
15411: PPUSH
15412: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
15416: LD_VAR 0 3
15420: PPUSH
15421: LD_INT 28
15423: PPUSH
15424: LD_INT 0
15426: PPUSH
15427: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
15431: LD_INT 0
15433: PPUSH
15434: LD_INT 6
15436: PUSH
15437: LD_OWVAR 67
15441: PLUS
15442: PPUSH
15443: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
15447: CALL_OW 44
15451: PPUSH
15452: LD_VAR 0 3
15456: PPUSH
15457: CALL_OW 52
// end ;
15461: GO 15335
15463: POP
15464: POP
// for i = 1 to Difficulty do
15465: LD_ADDR_VAR 0 2
15469: PUSH
15470: DOUBLE
15471: LD_INT 1
15473: DEC
15474: ST_TO_ADDR
15475: LD_OWVAR 67
15479: PUSH
15480: FOR_TO
15481: IFFALSE 15541
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
15483: LD_INT 14
15485: PPUSH
15486: LD_INT 3
15488: PPUSH
15489: LD_INT 5
15491: PPUSH
15492: LD_INT 29
15494: PPUSH
15495: LD_INT 80
15497: PPUSH
15498: CALL 72249 0 5
// veh := CreateVehicle ;
15502: LD_ADDR_VAR 0 3
15506: PUSH
15507: CALL_OW 45
15511: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
15512: LD_VAR 0 3
15516: PPUSH
15517: LD_INT 4
15519: PPUSH
15520: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
15524: LD_VAR 0 3
15528: PPUSH
15529: LD_INT 28
15531: PPUSH
15532: LD_INT 0
15534: PPUSH
15535: CALL_OW 49
// end ;
15539: GO 15480
15541: POP
15542: POP
// end ;
15543: LD_VAR 0 1
15547: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
15548: LD_INT 22
15550: PUSH
15551: LD_INT 2
15553: PUSH
15554: EMPTY
15555: LIST
15556: LIST
15557: PPUSH
15558: CALL_OW 69
15562: IFFALSE 15941
15564: GO 15566
15566: DISABLE
15567: LD_INT 0
15569: PPUSH
15570: PPUSH
15571: PPUSH
15572: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
15573: LD_ADDR_VAR 0 3
15577: PUSH
15578: LD_INT 22
15580: PUSH
15581: LD_INT 2
15583: PUSH
15584: EMPTY
15585: LIST
15586: LIST
15587: PUSH
15588: LD_INT 25
15590: PUSH
15591: LD_INT 4
15593: PUSH
15594: EMPTY
15595: LIST
15596: LIST
15597: PUSH
15598: EMPTY
15599: LIST
15600: LIST
15601: PPUSH
15602: CALL_OW 69
15606: PUSH
15607: LD_EXP 96
15611: DIFF
15612: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
15613: LD_ADDR_VAR 0 2
15617: PUSH
15618: LD_INT 22
15620: PUSH
15621: LD_INT 2
15623: PUSH
15624: EMPTY
15625: LIST
15626: LIST
15627: PPUSH
15628: CALL_OW 69
15632: PUSH
15633: LD_EXP 96
15637: PUSH
15638: LD_VAR 0 3
15642: UNION
15643: DIFF
15644: ST_TO_ADDR
// if Khatam then
15645: LD_EXP 96
15649: IFFALSE 15666
// ComMoveXY ( Khatam , 211 , 92 ) ;
15651: LD_EXP 96
15655: PPUSH
15656: LD_INT 211
15658: PPUSH
15659: LD_INT 92
15661: PPUSH
15662: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
15666: LD_INT 197
15668: PPUSH
15669: LD_INT 80
15671: PPUSH
15672: LD_INT 2
15674: PPUSH
15675: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
15679: LD_INT 213
15681: PPUSH
15682: LD_INT 90
15684: PPUSH
15685: LD_INT 2
15687: PPUSH
15688: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
15692: LD_INT 215
15694: PPUSH
15695: LD_INT 129
15697: PPUSH
15698: LD_INT 2
15700: PPUSH
15701: CALL_OW 441
// if sci then
15705: LD_VAR 0 3
15709: IFFALSE 15730
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
15711: LD_VAR 0 3
15715: PUSH
15716: LD_INT 1
15718: ARRAY
15719: PPUSH
15720: LD_INT 197
15722: PPUSH
15723: LD_INT 80
15725: PPUSH
15726: CALL_OW 158
// if sci > 1 then
15730: LD_VAR 0 3
15734: PUSH
15735: LD_INT 1
15737: GREATER
15738: IFFALSE 15759
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
15740: LD_VAR 0 3
15744: PUSH
15745: LD_INT 2
15747: ARRAY
15748: PPUSH
15749: LD_INT 213
15751: PPUSH
15752: LD_INT 90
15754: PPUSH
15755: CALL_OW 158
// if sci > 2 then
15759: LD_VAR 0 3
15763: PUSH
15764: LD_INT 2
15766: GREATER
15767: IFFALSE 15788
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
15769: LD_VAR 0 3
15773: PUSH
15774: LD_INT 3
15776: ARRAY
15777: PPUSH
15778: LD_INT 215
15780: PPUSH
15781: LD_INT 129
15783: PPUSH
15784: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
15788: LD_VAR 0 2
15792: PPUSH
15793: LD_INT 195
15795: PPUSH
15796: LD_INT 102
15798: PPUSH
15799: CALL_OW 114
// wait ( 0 0$5 ) ;
15803: LD_INT 175
15805: PPUSH
15806: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
15810: LD_INT 70
15812: PPUSH
15813: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_enemy , 2 ] ] ) ;
15817: LD_ADDR_VAR 0 4
15821: PUSH
15822: LD_INT 92
15824: PUSH
15825: LD_INT 195
15827: PUSH
15828: LD_INT 102
15830: PUSH
15831: LD_INT 36
15833: PUSH
15834: EMPTY
15835: LIST
15836: LIST
15837: LIST
15838: LIST
15839: PUSH
15840: LD_INT 81
15842: PUSH
15843: LD_INT 2
15845: PUSH
15846: EMPTY
15847: LIST
15848: LIST
15849: PUSH
15850: EMPTY
15851: LIST
15852: LIST
15853: PPUSH
15854: CALL_OW 69
15858: ST_TO_ADDR
// for i in tmp do
15859: LD_ADDR_VAR 0 1
15863: PUSH
15864: LD_VAR 0 2
15868: PUSH
15869: FOR_IN
15870: IFFALSE 15921
// if enemy then
15872: LD_VAR 0 4
15876: IFFALSE 15904
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15878: LD_VAR 0 1
15882: PPUSH
15883: LD_VAR 0 4
15887: PPUSH
15888: LD_VAR 0 1
15892: PPUSH
15893: CALL_OW 74
15897: PPUSH
15898: CALL_OW 115
15902: GO 15919
// ComAgressiveMove ( i , 195 , 102 ) ;
15904: LD_VAR 0 1
15908: PPUSH
15909: LD_INT 195
15911: PPUSH
15912: LD_INT 102
15914: PPUSH
15915: CALL_OW 114
15919: GO 15869
15921: POP
15922: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
15923: LD_VAR 0 2
15927: PPUSH
15928: LD_INT 50
15930: PUSH
15931: EMPTY
15932: LIST
15933: PPUSH
15934: CALL_OW 72
15938: NOT
15939: IFFALSE 15810
// end ; end_of_file
15941: PPOPN 4
15943: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
15944: LD_INT 0
15946: PPUSH
15947: PPUSH
15948: PPUSH
15949: PPUSH
15950: PPUSH
15951: PPUSH
15952: PPUSH
15953: PPUSH
15954: PPUSH
// Video ( true ) ;
15955: LD_INT 1
15957: PPUSH
15958: CALL 104655 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
15962: LD_ADDR_VAR 0 5
15966: PUSH
15967: LD_INT 7
15969: PPUSH
15970: LD_INT 0
15972: PPUSH
15973: CALL_OW 517
15977: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15978: LD_ADDR_VAR 0 2
15982: PUSH
15983: DOUBLE
15984: LD_INT 1
15986: DEC
15987: ST_TO_ADDR
15988: LD_VAR 0 5
15992: PUSH
15993: LD_INT 1
15995: ARRAY
15996: PUSH
15997: FOR_TO
15998: IFFALSE 16043
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
16000: LD_VAR 0 5
16004: PUSH
16005: LD_INT 1
16007: ARRAY
16008: PUSH
16009: LD_VAR 0 2
16013: ARRAY
16014: PPUSH
16015: LD_VAR 0 5
16019: PUSH
16020: LD_INT 2
16022: ARRAY
16023: PUSH
16024: LD_VAR 0 2
16028: ARRAY
16029: PPUSH
16030: LD_INT 1
16032: PPUSH
16033: LD_INT 15
16035: NEG
16036: PPUSH
16037: CALL 104569 0 4
16041: GO 15997
16043: POP
16044: POP
// CenterNowOnUnits ( Powell ) ;
16045: LD_EXP 59
16049: PPUSH
16050: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
16054: LD_ADDR_VAR 0 5
16058: PUSH
16059: LD_EXP 57
16063: PUSH
16064: EMPTY
16065: LIST
16066: ST_TO_ADDR
// if GirlNewVeh then
16067: LD_EXP 58
16071: IFFALSE 16089
// tmp := tmp ^ GirlNewVeh ;
16073: LD_ADDR_VAR 0 5
16077: PUSH
16078: LD_VAR 0 5
16082: PUSH
16083: LD_EXP 58
16087: ADD
16088: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
16089: LD_VAR 0 5
16093: PPUSH
16094: LD_INT 60
16096: PPUSH
16097: LD_INT 109
16099: PPUSH
16100: CALL_OW 111
// if KappaStatus then
16104: LD_EXP 2
16108: IFFALSE 16160
// begin Say ( JMM , D1nT-JMM-1 ) ;
16110: LD_EXP 40
16114: PPUSH
16115: LD_STRING D1nT-JMM-1
16117: PPUSH
16118: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
16122: LD_EXP 59
16126: PPUSH
16127: LD_STRING D1T-Pow-1
16129: PPUSH
16130: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
16134: LD_EXP 40
16138: PPUSH
16139: LD_STRING D1T-JMM-2
16141: PPUSH
16142: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
16146: LD_EXP 59
16150: PPUSH
16151: LD_STRING D1T-Pow-2
16153: PPUSH
16154: CALL_OW 88
// end else
16158: GO 16366
// if JMMGirlStatus then
16160: LD_EXP 6
16164: IFFALSE 16309
// begin Say ( JMM , D1T-JMM-1 ) ;
16166: LD_EXP 40
16170: PPUSH
16171: LD_STRING D1T-JMM-1
16173: PPUSH
16174: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
16178: LD_EXP 59
16182: PPUSH
16183: LD_STRING D1T-Pow-1
16185: PPUSH
16186: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
16190: LD_EXP 40
16194: PPUSH
16195: LD_STRING D1T-JMM-3
16197: PPUSH
16198: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
16202: LD_EXP 59
16206: PPUSH
16207: LD_STRING D1T-Pow-3
16209: PPUSH
16210: CALL_OW 88
// if JMMGirl then
16214: LD_EXP 7
16218: IFFALSE 16307
// begin case JMMGirl of 1 :
16220: LD_EXP 7
16224: PUSH
16225: LD_INT 1
16227: DOUBLE
16228: EQUAL
16229: IFTRUE 16233
16231: GO 16248
16233: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
16234: LD_EXP 41
16238: PPUSH
16239: LD_STRING D1T-Joan-3
16241: PPUSH
16242: CALL_OW 88
16246: GO 16295
16248: LD_INT 2
16250: DOUBLE
16251: EQUAL
16252: IFTRUE 16256
16254: GO 16271
16256: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
16257: LD_EXP 43
16261: PPUSH
16262: LD_STRING D1T-Lisa-3
16264: PPUSH
16265: CALL_OW 88
16269: GO 16295
16271: LD_INT 3
16273: DOUBLE
16274: EQUAL
16275: IFTRUE 16279
16277: GO 16294
16279: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
16280: LD_EXP 55
16284: PPUSH
16285: LD_STRING D1T-Con-3
16287: PPUSH
16288: CALL_OW 88
16292: GO 16295
16294: POP
// Say ( Powell , D1T-Pow-4 ) ;
16295: LD_EXP 59
16299: PPUSH
16300: LD_STRING D1T-Pow-4
16302: PPUSH
16303: CALL_OW 88
// end ; end else
16307: GO 16366
// if not FastEnd then
16309: LD_EXP 11
16313: NOT
16314: IFFALSE 16342
// begin Say ( JMM , D1T-JMM-4 ) ;
16316: LD_EXP 40
16320: PPUSH
16321: LD_STRING D1T-JMM-4
16323: PPUSH
16324: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
16328: LD_EXP 59
16332: PPUSH
16333: LD_STRING D1T-Pow-5
16335: PPUSH
16336: CALL_OW 88
// end else
16340: GO 16366
// begin Say ( JMM , D1nT-JMM-1 ) ;
16342: LD_EXP 40
16346: PPUSH
16347: LD_STRING D1nT-JMM-1
16349: PPUSH
16350: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
16354: LD_EXP 59
16358: PPUSH
16359: LD_STRING D1nT-Pow-1
16361: PPUSH
16362: CALL_OW 88
// end ; repeat wait ( 3 ) ;
16366: LD_INT 3
16368: PPUSH
16369: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
16373: LD_EXP 57
16377: PPUSH
16378: CALL_OW 314
16382: NOT
16383: IFFALSE 16366
// ComExitVehicle ( JMM ) ;
16385: LD_EXP 40
16389: PPUSH
16390: CALL_OW 121
// repeat wait ( 3 ) ;
16394: LD_INT 3
16396: PPUSH
16397: CALL_OW 67
// until not IsInUnit ( JMM ) ;
16401: LD_EXP 40
16405: PPUSH
16406: CALL_OW 310
16410: NOT
16411: IFFALSE 16394
// ComMoveXY ( JMM , 60 , 94 ) ;
16413: LD_EXP 40
16417: PPUSH
16418: LD_INT 60
16420: PPUSH
16421: LD_INT 94
16423: PPUSH
16424: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16428: LD_EXP 40
16432: PPUSH
16433: LD_EXP 59
16437: PPUSH
16438: CALL_OW 179
// if Joan then
16442: LD_EXP 41
16446: IFFALSE 16500
// begin ComExitVehicle ( Joan ) ;
16448: LD_EXP 41
16452: PPUSH
16453: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
16457: LD_EXP 41
16461: PPUSH
16462: LD_INT 35
16464: PPUSH
16465: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
16469: LD_EXP 41
16473: PPUSH
16474: LD_INT 65
16476: PPUSH
16477: LD_INT 104
16479: PPUSH
16480: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
16484: LD_EXP 41
16488: PPUSH
16489: LD_EXP 40
16493: PPUSH
16494: CALL_OW 179
// end else
16498: GO 16634
// if Lisa and JMMGirl = 2 then
16500: LD_EXP 43
16504: PUSH
16505: LD_EXP 7
16509: PUSH
16510: LD_INT 2
16512: EQUAL
16513: AND
16514: IFFALSE 16568
// begin ComExitVehicle ( Lisa ) ;
16516: LD_EXP 43
16520: PPUSH
16521: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
16525: LD_EXP 43
16529: PPUSH
16530: LD_INT 35
16532: PPUSH
16533: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
16537: LD_EXP 43
16541: PPUSH
16542: LD_INT 65
16544: PPUSH
16545: LD_INT 104
16547: PPUSH
16548: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
16552: LD_EXP 43
16556: PPUSH
16557: LD_EXP 40
16561: PPUSH
16562: CALL_OW 179
// end else
16566: GO 16634
// if Connie and JMMGirl = 3 then
16568: LD_EXP 55
16572: PUSH
16573: LD_EXP 7
16577: PUSH
16578: LD_INT 3
16580: EQUAL
16581: AND
16582: IFFALSE 16634
// begin ComExitVehicle ( Connie ) ;
16584: LD_EXP 55
16588: PPUSH
16589: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
16593: LD_EXP 55
16597: PPUSH
16598: LD_INT 35
16600: PPUSH
16601: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
16605: LD_EXP 55
16609: PPUSH
16610: LD_INT 65
16612: PPUSH
16613: LD_INT 104
16615: PPUSH
16616: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
16620: LD_EXP 55
16624: PPUSH
16625: LD_EXP 40
16629: PPUSH
16630: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
16634: LD_INT 35
16636: PPUSH
16637: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
16641: LD_EXP 40
16645: PPUSH
16646: LD_EXP 59
16650: PPUSH
16651: CALL_OW 296
16655: PUSH
16656: LD_INT 8
16658: LESS
16659: IFFALSE 16634
// wait ( 0 0$0.5 ) ;
16661: LD_INT 18
16663: PPUSH
16664: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
16668: LD_EXP 40
16672: PPUSH
16673: LD_STRING D1-JMM-1
16675: PPUSH
16676: CALL_OW 88
// async ;
16680: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
16681: LD_EXP 59
16685: PPUSH
16686: LD_STRING D1-Pow-1
16688: PPUSH
16689: CALL_OW 88
// if not dialogue_skipped then
16693: LD_OWVAR 59
16697: NOT
16698: IFFALSE 16707
// wait ( 0 0$2 ) ;
16700: LD_INT 70
16702: PPUSH
16703: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
16707: LD_INT 170
16709: PPUSH
16710: LD_INT 99
16712: PPUSH
16713: LD_INT 1
16715: PPUSH
16716: LD_INT 6
16718: NEG
16719: PPUSH
16720: CALL 104569 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
16724: LD_INT 174
16726: PPUSH
16727: LD_INT 115
16729: PPUSH
16730: LD_INT 1
16732: PPUSH
16733: LD_INT 6
16735: NEG
16736: PPUSH
16737: CALL 104569 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
16741: LD_INT 169
16743: PPUSH
16744: LD_INT 71
16746: PPUSH
16747: LD_INT 1
16749: PPUSH
16750: LD_INT 6
16752: NEG
16753: PPUSH
16754: CALL 104569 0 4
// if not dialogue_skipped then
16758: LD_OWVAR 59
16762: NOT
16763: IFFALSE 16782
// begin CenterOnXY ( 170 , 99 ) ;
16765: LD_INT 170
16767: PPUSH
16768: LD_INT 99
16770: PPUSH
16771: CALL_OW 84
// wait ( 0 0$2.3 ) ;
16775: LD_INT 80
16777: PPUSH
16778: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
16782: LD_INT 75
16784: PPUSH
16785: LD_INT 53
16787: PPUSH
16788: LD_INT 1
16790: PPUSH
16791: LD_INT 9
16793: NEG
16794: PPUSH
16795: CALL 104569 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
16799: LD_INT 54
16801: PPUSH
16802: LD_INT 42
16804: PPUSH
16805: LD_INT 1
16807: PPUSH
16808: LD_INT 9
16810: NEG
16811: PPUSH
16812: CALL 104569 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
16816: LD_INT 62
16818: PPUSH
16819: LD_INT 51
16821: PPUSH
16822: LD_INT 1
16824: PPUSH
16825: LD_INT 9
16827: NEG
16828: PPUSH
16829: CALL 104569 0 4
// if not dialogue_skipped then
16833: LD_OWVAR 59
16837: NOT
16838: IFFALSE 16857
// begin CenterOnXY ( 75 , 53 ) ;
16840: LD_INT 75
16842: PPUSH
16843: LD_INT 53
16845: PPUSH
16846: CALL_OW 84
// wait ( 0 0$4 ) ;
16850: LD_INT 140
16852: PPUSH
16853: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
16857: LD_EXP 59
16861: PPUSH
16862: CALL_OW 87
// if not dialogue_skipped then
16866: LD_OWVAR 59
16870: NOT
16871: IFFALSE 16880
// wait ( 0 0$2 ) ;
16873: LD_INT 70
16875: PPUSH
16876: CALL_OW 67
// sync ;
16880: SYNC
// Say ( JMM , D1-JMM-2 ) ;
16881: LD_EXP 40
16885: PPUSH
16886: LD_STRING D1-JMM-2
16888: PPUSH
16889: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
16893: LD_EXP 59
16897: PPUSH
16898: LD_STRING D1-Pow-2
16900: PPUSH
16901: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
16905: LD_EXP 40
16909: PPUSH
16910: LD_STRING D1-JMM-3
16912: PPUSH
16913: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
16917: LD_EXP 59
16921: PPUSH
16922: LD_STRING D1-Pow-3
16924: PPUSH
16925: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
16929: LD_EXP 40
16933: PPUSH
16934: LD_STRING D1-JMM-4
16936: PPUSH
16937: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
16941: LD_EXP 59
16945: PPUSH
16946: LD_STRING D1-Pow-4
16948: PPUSH
16949: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
16953: LD_EXP 40
16957: PPUSH
16958: LD_STRING D1-JMM-5
16960: PPUSH
16961: CALL_OW 88
// async ;
16965: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
16966: LD_EXP 59
16970: PPUSH
16971: LD_STRING D1-Pow-5
16973: PPUSH
16974: CALL_OW 88
// if not dialogue_skipped then
16978: LD_OWVAR 59
16982: NOT
16983: IFFALSE 16992
// wait ( 0 0$3.6 ) ;
16985: LD_INT 126
16987: PPUSH
16988: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16992: LD_INT 134
16994: PPUSH
16995: LD_INT 210
16997: PPUSH
16998: LD_INT 1
17000: PPUSH
17001: LD_INT 11
17003: NEG
17004: PPUSH
17005: CALL 104569 0 4
// if not dialogue_skipped then
17009: LD_OWVAR 59
17013: NOT
17014: IFFALSE 17033
// begin CenterOnXY ( 134 , 210 ) ;
17016: LD_INT 134
17018: PPUSH
17019: LD_INT 210
17021: PPUSH
17022: CALL_OW 84
// wait ( 0 0$2 ) ;
17026: LD_INT 70
17028: PPUSH
17029: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
17033: LD_INT 101
17035: PPUSH
17036: LD_INT 159
17038: PPUSH
17039: LD_INT 1
17041: PPUSH
17042: LD_INT 10
17044: NEG
17045: PPUSH
17046: CALL 104569 0 4
// if not dialogue_skipped then
17050: LD_OWVAR 59
17054: NOT
17055: IFFALSE 17074
// begin CenterOnXY ( 101 , 159 ) ;
17057: LD_INT 101
17059: PPUSH
17060: LD_INT 159
17062: PPUSH
17063: CALL_OW 84
// wait ( 0 0$2 ) ;
17067: LD_INT 70
17069: PPUSH
17070: CALL_OW 67
// end ; sync ;
17074: SYNC
// CenterNowOnUnits ( Powell ) ;
17075: LD_EXP 59
17079: PPUSH
17080: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
17084: LD_ADDR_VAR 0 6
17088: PUSH
17089: LD_INT 1
17091: PUSH
17092: LD_INT 2
17094: PUSH
17095: LD_INT 3
17097: PUSH
17098: LD_INT 4
17100: PUSH
17101: LD_INT 5
17103: PUSH
17104: LD_INT 6
17106: PUSH
17107: EMPTY
17108: LIST
17109: LIST
17110: LIST
17111: LIST
17112: LIST
17113: LIST
17114: ST_TO_ADDR
// if not dialogue_skipped then
17115: LD_OWVAR 59
17119: NOT
17120: IFFALSE 17289
// begin game_speed := 4 ;
17122: LD_ADDR_OWVAR 65
17126: PUSH
17127: LD_INT 4
17129: ST_TO_ADDR
// wait ( 0 0$6 ) ;
17130: LD_INT 210
17132: PPUSH
17133: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
17137: LD_ADDR_VAR 0 7
17141: PUSH
17142: LD_STRING Q1
17144: PPUSH
17145: LD_VAR 0 6
17149: PPUSH
17150: CALL_OW 98
17154: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
17155: LD_ADDR_VAR 0 7
17159: PUSH
17160: LD_STRING Q1
17162: PPUSH
17163: LD_VAR 0 6
17167: PPUSH
17168: CALL_OW 98
17172: ST_TO_ADDR
// options := options diff dec ;
17173: LD_ADDR_VAR 0 6
17177: PUSH
17178: LD_VAR 0 6
17182: PUSH
17183: LD_VAR 0 7
17187: DIFF
17188: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
17189: LD_VAR 0 7
17193: PPUSH
17194: LD_VAR 0 6
17198: PPUSH
17199: CALL 18805 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
17203: LD_VAR 0 7
17207: PUSH
17208: LD_INT 5
17210: PUSH
17211: LD_INT 6
17213: PUSH
17214: EMPTY
17215: LIST
17216: LIST
17217: IN
17218: PUSH
17219: LD_VAR 0 6
17223: PUSH
17224: LD_INT 2
17226: EQUAL
17227: OR
17228: IFFALSE 17155
// if not ( dec in [ 5 , 6 ] ) then
17230: LD_VAR 0 7
17234: PUSH
17235: LD_INT 5
17237: PUSH
17238: LD_INT 6
17240: PUSH
17241: EMPTY
17242: LIST
17243: LIST
17244: IN
17245: NOT
17246: IFFALSE 17289
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
17248: LD_ADDR_VAR 0 7
17252: PUSH
17253: LD_STRING Q1a
17255: PPUSH
17256: LD_INT 1
17258: PUSH
17259: LD_INT 2
17261: PUSH
17262: EMPTY
17263: LIST
17264: LIST
17265: PPUSH
17266: CALL_OW 98
17270: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
17271: LD_VAR 0 7
17275: PUSH
17276: LD_INT 4
17278: PLUS
17279: PPUSH
17280: LD_VAR 0 6
17284: PPUSH
17285: CALL 18805 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
17289: LD_INT 81
17291: PPUSH
17292: LD_INT 127
17294: PPUSH
17295: CALL_OW 84
// amount := 8 ;
17299: LD_ADDR_VAR 0 8
17303: PUSH
17304: LD_INT 8
17306: ST_TO_ADDR
// macmilan_squad := [ ] ;
17307: LD_ADDR_VAR 0 9
17311: PUSH
17312: EMPTY
17313: ST_TO_ADDR
// if vip < amount then
17314: LD_EXP 60
17318: PUSH
17319: LD_VAR 0 8
17323: LESS
17324: IFFALSE 17368
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
17326: LD_ADDR_VAR 0 5
17330: PUSH
17331: LD_EXP 60
17335: PUSH
17336: LD_INT 22
17338: PUSH
17339: LD_INT 4
17341: PUSH
17342: EMPTY
17343: LIST
17344: LIST
17345: PUSH
17346: LD_INT 21
17348: PUSH
17349: LD_INT 1
17351: PUSH
17352: EMPTY
17353: LIST
17354: LIST
17355: PUSH
17356: EMPTY
17357: LIST
17358: LIST
17359: PPUSH
17360: CALL_OW 69
17364: UNION
17365: ST_TO_ADDR
17366: GO 17378
// tmp := vip ;
17368: LD_ADDR_VAR 0 5
17372: PUSH
17373: LD_EXP 60
17377: ST_TO_ADDR
// tmp := tmp diff Powell ;
17378: LD_ADDR_VAR 0 5
17382: PUSH
17383: LD_VAR 0 5
17387: PUSH
17388: LD_EXP 59
17392: DIFF
17393: ST_TO_ADDR
// if tmp < amount then
17394: LD_VAR 0 5
17398: PUSH
17399: LD_VAR 0 8
17403: LESS
17404: IFFALSE 17416
// amount := tmp ;
17406: LD_ADDR_VAR 0 8
17410: PUSH
17411: LD_VAR 0 5
17415: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
17416: LD_VAR 0 5
17420: PUSH
17421: LD_INT 1
17423: ARRAY
17424: PPUSH
17425: CALL_OW 257
17429: PUSH
17430: LD_INT 2
17432: NONEQUAL
17433: IFFALSE 17531
// begin if IsInUnit ( tmp [ 1 ] ) then
17435: LD_VAR 0 5
17439: PUSH
17440: LD_INT 1
17442: ARRAY
17443: PPUSH
17444: CALL_OW 310
17448: IFFALSE 17463
// ComExitBuilding ( tmp [ 1 ] ) ;
17450: LD_VAR 0 5
17454: PUSH
17455: LD_INT 1
17457: ARRAY
17458: PPUSH
17459: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
17463: LD_INT 387
17465: PPUSH
17466: CALL_OW 313
17470: PUSH
17471: LD_INT 6
17473: EQUAL
17474: IFFALSE 17499
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
17476: LD_INT 387
17478: PPUSH
17479: CALL_OW 313
17483: PUSH
17484: LD_INT 1
17486: ARRAY
17487: PPUSH
17488: CALL_OW 122
// wait ( 3 ) ;
17492: LD_INT 3
17494: PPUSH
17495: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
17499: LD_VAR 0 5
17503: PUSH
17504: LD_INT 1
17506: ARRAY
17507: PPUSH
17508: LD_INT 387
17510: PPUSH
17511: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
17515: LD_VAR 0 5
17519: PUSH
17520: LD_INT 1
17522: ARRAY
17523: PPUSH
17524: LD_INT 2
17526: PPUSH
17527: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
17531: LD_EXP 40
17535: PPUSH
17536: LD_INT 82
17538: PPUSH
17539: LD_INT 129
17541: PPUSH
17542: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
17546: LD_EXP 40
17550: PPUSH
17551: LD_EXP 59
17555: PPUSH
17556: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
17560: LD_INT 22
17562: PUSH
17563: LD_INT 1
17565: PUSH
17566: EMPTY
17567: LIST
17568: LIST
17569: PPUSH
17570: CALL_OW 69
17574: PUSH
17575: LD_EXP 40
17579: DIFF
17580: PPUSH
17581: LD_INT 84
17583: PPUSH
17584: LD_INT 128
17586: PPUSH
17587: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
17591: LD_INT 22
17593: PUSH
17594: LD_INT 1
17596: PUSH
17597: EMPTY
17598: LIST
17599: LIST
17600: PPUSH
17601: CALL_OW 69
17605: PUSH
17606: LD_EXP 40
17610: DIFF
17611: PPUSH
17612: LD_EXP 40
17616: PPUSH
17617: CALL_OW 179
// for i = 1 to amount do
17621: LD_ADDR_VAR 0 2
17625: PUSH
17626: DOUBLE
17627: LD_INT 1
17629: DEC
17630: ST_TO_ADDR
17631: LD_VAR 0 8
17635: PUSH
17636: FOR_TO
17637: IFFALSE 17805
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
17639: LD_ADDR_VAR 0 9
17643: PUSH
17644: LD_VAR 0 9
17648: PUSH
17649: LD_VAR 0 5
17653: PUSH
17654: LD_VAR 0 2
17658: ARRAY
17659: ADD
17660: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
17661: LD_VAR 0 5
17665: PUSH
17666: LD_VAR 0 2
17670: ARRAY
17671: PPUSH
17672: CALL_OW 310
17676: IFFALSE 17693
// AddComExitBuilding ( tmp [ i ] ) ;
17678: LD_VAR 0 5
17682: PUSH
17683: LD_VAR 0 2
17687: ARRAY
17688: PPUSH
17689: CALL_OW 182
// if i = 2 and JMMNewVeh then
17693: LD_VAR 0 2
17697: PUSH
17698: LD_INT 2
17700: EQUAL
17701: PUSH
17702: LD_EXP 57
17706: AND
17707: IFFALSE 17765
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
17709: LD_VAR 0 5
17713: PUSH
17714: LD_VAR 0 2
17718: ARRAY
17719: PPUSH
17720: LD_EXP 57
17724: PPUSH
17725: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
17729: LD_VAR 0 5
17733: PUSH
17734: LD_VAR 0 2
17738: ARRAY
17739: PPUSH
17740: LD_INT 86
17742: PPUSH
17743: LD_INT 133
17745: PPUSH
17746: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
17750: LD_VAR 0 5
17754: PUSH
17755: LD_VAR 0 2
17759: ARRAY
17760: PPUSH
17761: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
17765: LD_VAR 0 5
17769: PUSH
17770: LD_VAR 0 2
17774: ARRAY
17775: PPUSH
17776: LD_INT 8
17778: PPUSH
17779: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
17783: LD_VAR 0 5
17787: PUSH
17788: LD_VAR 0 2
17792: ARRAY
17793: PPUSH
17794: LD_EXP 40
17798: PPUSH
17799: CALL_OW 179
// end ;
17803: GO 17636
17805: POP
17806: POP
// if GirlNewVeh then
17807: LD_EXP 58
17811: IFFALSE 17825
// SetSide ( GirlNewVeh , 4 ) ;
17813: LD_EXP 58
17817: PPUSH
17818: LD_INT 4
17820: PPUSH
17821: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
17825: LD_INT 35
17827: PPUSH
17828: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
17832: LD_VAR 0 9
17836: PPUSH
17837: LD_INT 95
17839: PUSH
17840: LD_INT 9
17842: PUSH
17843: EMPTY
17844: LIST
17845: LIST
17846: PPUSH
17847: CALL_OW 72
17851: PUSH
17852: LD_INT 0
17854: EQUAL
17855: PUSH
17856: LD_EXP 40
17860: PPUSH
17861: LD_INT 9
17863: PPUSH
17864: CALL_OW 308
17868: NOT
17869: AND
17870: IFFALSE 17825
// wait ( 0 0$2 ) ;
17872: LD_INT 70
17874: PPUSH
17875: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
17879: LD_VAR 0 9
17883: PPUSH
17884: LD_INT 1
17886: PPUSH
17887: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
17891: LD_INT 21
17893: PUSH
17894: LD_INT 2
17896: PUSH
17897: EMPTY
17898: LIST
17899: LIST
17900: PUSH
17901: LD_INT 92
17903: PUSH
17904: LD_INT 83
17906: PUSH
17907: LD_INT 130
17909: PUSH
17910: LD_INT 10
17912: PUSH
17913: EMPTY
17914: LIST
17915: LIST
17916: LIST
17917: LIST
17918: PUSH
17919: EMPTY
17920: LIST
17921: LIST
17922: PPUSH
17923: CALL_OW 69
17927: PPUSH
17928: LD_INT 1
17930: PPUSH
17931: CALL_OW 235
// tick := 0 ;
17935: LD_ADDR_OWVAR 1
17939: PUSH
17940: LD_INT 0
17942: ST_TO_ADDR
// Video ( false ) ;
17943: LD_INT 0
17945: PPUSH
17946: CALL 104655 0 1
// ChangeMissionObjectives ( M1 ) ;
17950: LD_STRING M1
17952: PPUSH
17953: CALL_OW 337
// SaveForQuickRestart ;
17957: CALL_OW 22
// missionStart := true ;
17961: LD_ADDR_EXP 13
17965: PUSH
17966: LD_INT 1
17968: ST_TO_ADDR
// missionStage := 2 ;
17969: LD_ADDR_EXP 15
17973: PUSH
17974: LD_INT 2
17976: ST_TO_ADDR
// wait ( 0 0$1 ) ;
17977: LD_INT 35
17979: PPUSH
17980: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
17984: LD_ADDR_VAR 0 5
17988: PUSH
17989: LD_INT 22
17991: PUSH
17992: LD_INT 4
17994: PUSH
17995: EMPTY
17996: LIST
17997: LIST
17998: PUSH
17999: LD_INT 21
18001: PUSH
18002: LD_INT 1
18004: PUSH
18005: EMPTY
18006: LIST
18007: LIST
18008: PUSH
18009: EMPTY
18010: LIST
18011: LIST
18012: PPUSH
18013: CALL_OW 69
18017: PUSH
18018: LD_EXP 59
18022: DIFF
18023: ST_TO_ADDR
// if not tmp then
18024: LD_VAR 0 5
18028: NOT
18029: IFFALSE 18044
// tmp := [ Powell ] ;
18031: LD_ADDR_VAR 0 5
18035: PUSH
18036: LD_EXP 59
18040: PUSH
18041: EMPTY
18042: LIST
18043: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
18044: LD_ADDR_VAR 0 4
18048: PUSH
18049: LD_INT 22
18051: PUSH
18052: LD_INT 4
18054: PUSH
18055: EMPTY
18056: LIST
18057: LIST
18058: PUSH
18059: LD_INT 34
18061: PUSH
18062: LD_INT 12
18064: PUSH
18065: EMPTY
18066: LIST
18067: LIST
18068: PUSH
18069: EMPTY
18070: LIST
18071: LIST
18072: PPUSH
18073: CALL_OW 69
18077: PUSH
18078: LD_INT 1
18080: ARRAY
18081: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
18082: LD_VAR 0 5
18086: PUSH
18087: LD_INT 1
18089: ARRAY
18090: PPUSH
18091: CALL_OW 310
18095: IFFALSE 18110
// ComExitBuilding ( tmp [ 1 ] ) ;
18097: LD_VAR 0 5
18101: PUSH
18102: LD_INT 1
18104: ARRAY
18105: PPUSH
18106: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
18110: LD_VAR 0 5
18114: PUSH
18115: LD_INT 1
18117: ARRAY
18118: PPUSH
18119: LD_VAR 0 4
18123: PPUSH
18124: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
18128: LD_VAR 0 5
18132: PUSH
18133: LD_INT 1
18135: ARRAY
18136: PPUSH
18137: LD_INT 80
18139: PPUSH
18140: LD_INT 136
18142: PPUSH
18143: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
18147: LD_VAR 0 5
18151: PUSH
18152: LD_INT 1
18154: ARRAY
18155: PPUSH
18156: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
18160: LD_VAR 0 5
18164: PUSH
18165: LD_INT 1
18167: ARRAY
18168: PPUSH
18169: LD_INT 59
18171: PPUSH
18172: LD_INT 112
18174: PPUSH
18175: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
18179: LD_VAR 0 5
18183: PUSH
18184: LD_INT 1
18186: ARRAY
18187: PPUSH
18188: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
18192: LD_EXP 41
18196: PUSH
18197: LD_EXP 41
18201: PPUSH
18202: CALL_OW 255
18206: PUSH
18207: LD_INT 1
18209: EQUAL
18210: AND
18211: IFFALSE 18237
// begin Say ( Joan , D3W-Joan-1 ) ;
18213: LD_EXP 41
18217: PPUSH
18218: LD_STRING D3W-Joan-1
18220: PPUSH
18221: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18225: LD_EXP 40
18229: PPUSH
18230: LD_STRING D3W-JMM-1
18232: PPUSH
18233: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
18237: LD_EXP 43
18241: PUSH
18242: LD_EXP 43
18246: PPUSH
18247: CALL_OW 255
18251: PUSH
18252: LD_INT 1
18254: EQUAL
18255: AND
18256: PUSH
18257: LD_EXP 43
18261: PUSH
18262: LD_EXP 60
18266: IN
18267: NOT
18268: AND
18269: IFFALSE 18295
// begin Say ( Lisa , D3W-Lisa-1 ) ;
18271: LD_EXP 43
18275: PPUSH
18276: LD_STRING D3W-Lisa-1
18278: PPUSH
18279: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18283: LD_EXP 40
18287: PPUSH
18288: LD_STRING D3W-JMM-1
18290: PPUSH
18291: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
18295: LD_EXP 55
18299: PUSH
18300: LD_EXP 55
18304: PPUSH
18305: CALL_OW 255
18309: PUSH
18310: LD_INT 1
18312: EQUAL
18313: AND
18314: IFFALSE 18340
// begin Say ( Connie , D3W-Con-1 ) ;
18316: LD_EXP 55
18320: PPUSH
18321: LD_STRING D3W-Con-1
18323: PPUSH
18324: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18328: LD_EXP 40
18332: PPUSH
18333: LD_STRING D3W-JMM-1
18335: PPUSH
18336: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
18340: LD_EXP 43
18344: PUSH
18345: LD_EXP 60
18349: IN
18350: PUSH
18351: LD_EXP 43
18355: PPUSH
18356: CALL_OW 255
18360: PUSH
18361: LD_INT 1
18363: EQUAL
18364: AND
18365: IFFALSE 18381
// Say ( Lisa , D3nW-Lisa-1 ) else
18367: LD_EXP 43
18371: PPUSH
18372: LD_STRING D3nW-Lisa-1
18374: PPUSH
18375: CALL_OW 88
18379: GO 18625
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
18381: LD_EXP 46
18385: PUSH
18386: LD_EXP 60
18390: IN
18391: PUSH
18392: LD_EXP 46
18396: PPUSH
18397: CALL_OW 255
18401: PUSH
18402: LD_INT 1
18404: EQUAL
18405: AND
18406: IFFALSE 18422
// Say ( Cyrus , D3nW-Cyrus-1 ) else
18408: LD_EXP 46
18412: PPUSH
18413: LD_STRING D3nW-Cyrus-1
18415: PPUSH
18416: CALL_OW 88
18420: GO 18625
// if Bobby in vip and GetSide ( Bobby ) = 1 then
18422: LD_EXP 45
18426: PUSH
18427: LD_EXP 60
18431: IN
18432: PUSH
18433: LD_EXP 45
18437: PPUSH
18438: CALL_OW 255
18442: PUSH
18443: LD_INT 1
18445: EQUAL
18446: AND
18447: IFFALSE 18463
// Say ( Bobby , D3nW-Bobby-1 ) else
18449: LD_EXP 45
18453: PPUSH
18454: LD_STRING D3nW-Bobby-1
18456: PPUSH
18457: CALL_OW 88
18461: GO 18625
// if Gary in vip and GetSide ( Gary ) = 1 then
18463: LD_EXP 52
18467: PUSH
18468: LD_EXP 60
18472: IN
18473: PUSH
18474: LD_EXP 52
18478: PPUSH
18479: CALL_OW 255
18483: PUSH
18484: LD_INT 1
18486: EQUAL
18487: AND
18488: IFFALSE 18504
// Say ( Gary , D3nW-Gary-1 ) else
18490: LD_EXP 52
18494: PPUSH
18495: LD_STRING D3nW-Gary-1
18497: PPUSH
18498: CALL_OW 88
18502: GO 18625
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
18504: LD_EXP 44
18508: PUSH
18509: LD_EXP 60
18513: IN
18514: PUSH
18515: LD_EXP 44
18519: PPUSH
18520: CALL_OW 255
18524: PUSH
18525: LD_INT 1
18527: EQUAL
18528: AND
18529: IFFALSE 18545
// Say ( Donaldson , D3nW-Don-1 ) else
18531: LD_EXP 44
18535: PPUSH
18536: LD_STRING D3nW-Don-1
18538: PPUSH
18539: CALL_OW 88
18543: GO 18625
// if Cornel in vip and GetSide ( Cornel ) = 1 then
18545: LD_EXP 51
18549: PUSH
18550: LD_EXP 60
18554: IN
18555: PUSH
18556: LD_EXP 51
18560: PPUSH
18561: CALL_OW 255
18565: PUSH
18566: LD_INT 1
18568: EQUAL
18569: AND
18570: IFFALSE 18586
// Say ( Cornel , D3nW-Corn-1 ) else
18572: LD_EXP 51
18576: PPUSH
18577: LD_STRING D3nW-Corn-1
18579: PPUSH
18580: CALL_OW 88
18584: GO 18625
// if Frank in vip and GetSide ( Frank ) = 1 then
18586: LD_EXP 53
18590: PUSH
18591: LD_EXP 60
18595: IN
18596: PUSH
18597: LD_EXP 53
18601: PPUSH
18602: CALL_OW 255
18606: PUSH
18607: LD_INT 1
18609: EQUAL
18610: AND
18611: IFFALSE 18625
// Say ( Frank , D3nW-Frank-1 ) ;
18613: LD_EXP 53
18617: PPUSH
18618: LD_STRING D3nW-Frank-1
18620: PPUSH
18621: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
18625: LD_EXP 60
18629: PPUSH
18630: LD_INT 22
18632: PUSH
18633: LD_INT 1
18635: PUSH
18636: EMPTY
18637: LIST
18638: LIST
18639: PPUSH
18640: CALL_OW 72
18644: IFFALSE 18670
// begin Say ( JMM , D3nW-JMM-1 ) ;
18646: LD_EXP 40
18650: PPUSH
18651: LD_STRING D3nW-JMM-1
18653: PPUSH
18654: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
18658: LD_EXP 40
18662: PPUSH
18663: LD_STRING D3nW-JMM-1a
18665: PPUSH
18666: CALL_OW 88
// end ; t := 0 0$00 ;
18670: LD_ADDR_VAR 0 3
18674: PUSH
18675: LD_INT 0
18677: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18678: LD_INT 35
18680: PPUSH
18681: CALL_OW 67
// t := t + 0 0$1 ;
18685: LD_ADDR_VAR 0 3
18689: PUSH
18690: LD_VAR 0 3
18694: PUSH
18695: LD_INT 35
18697: PLUS
18698: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
18699: LD_INT 59
18701: PPUSH
18702: LD_INT 112
18704: PPUSH
18705: CALL_OW 428
18709: PUSH
18710: LD_VAR 0 3
18714: PUSH
18715: LD_INT 2100
18717: GREATER
18718: OR
18719: IFFALSE 18678
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
18721: LD_ADDR_EXP 99
18725: PUSH
18726: LD_EXP 99
18730: PPUSH
18731: LD_INT 4
18733: PPUSH
18734: LD_INT 22
18736: PUSH
18737: LD_INT 4
18739: PUSH
18740: EMPTY
18741: LIST
18742: LIST
18743: PUSH
18744: LD_INT 23
18746: PUSH
18747: LD_INT 1
18749: PUSH
18750: EMPTY
18751: LIST
18752: LIST
18753: PUSH
18754: LD_INT 3
18756: PUSH
18757: LD_INT 21
18759: PUSH
18760: LD_INT 2
18762: PUSH
18763: EMPTY
18764: LIST
18765: LIST
18766: PUSH
18767: EMPTY
18768: LIST
18769: LIST
18770: PUSH
18771: EMPTY
18772: LIST
18773: LIST
18774: LIST
18775: PPUSH
18776: CALL_OW 69
18780: PUSH
18781: LD_EXP 59
18785: DIFF
18786: PPUSH
18787: CALL_OW 1
18791: ST_TO_ADDR
// activeAttacks := true ;
18792: LD_ADDR_EXP 16
18796: PUSH
18797: LD_INT 1
18799: ST_TO_ADDR
// end ;
18800: LD_VAR 0 1
18804: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
18805: LD_INT 0
18807: PPUSH
// case question of 1 :
18808: LD_VAR 0 1
18812: PUSH
18813: LD_INT 1
18815: DOUBLE
18816: EQUAL
18817: IFTRUE 18821
18819: GO 18872
18821: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
18822: LD_EXP 40
18826: PPUSH
18827: LD_STRING D2Mot-JMM-1
18829: PPUSH
18830: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
18834: LD_EXP 59
18838: PPUSH
18839: LD_STRING D2Mot-Pow-1
18841: PPUSH
18842: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
18846: LD_EXP 40
18850: PPUSH
18851: LD_STRING D2Mot-JMM-2
18853: PPUSH
18854: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
18858: LD_EXP 59
18862: PPUSH
18863: LD_STRING D2Mot-Pow-2
18865: PPUSH
18866: CALL_OW 88
// end ; 2 :
18870: GO 19223
18872: LD_INT 2
18874: DOUBLE
18875: EQUAL
18876: IFTRUE 18880
18878: GO 18956
18880: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
18881: LD_EXP 40
18885: PPUSH
18886: LD_STRING D2Rus-JMM-1
18888: PPUSH
18889: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
18893: LD_EXP 59
18897: PPUSH
18898: LD_STRING D2Rus-Pow-1
18900: PPUSH
18901: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
18905: LD_EXP 40
18909: PPUSH
18910: LD_STRING D2Rus-JMM-2
18912: PPUSH
18913: CALL_OW 88
// if not ( 3 in list_of_q ) then
18917: LD_INT 3
18919: PUSH
18920: LD_VAR 0 2
18924: IN
18925: NOT
18926: IFFALSE 18942
// Say ( Powell , D2Rus-Pow-2 ) else
18928: LD_EXP 59
18932: PPUSH
18933: LD_STRING D2Rus-Pow-2
18935: PPUSH
18936: CALL_OW 88
18940: GO 18954
// Say ( Powell , D2Rus-Pow-2a ) ;
18942: LD_EXP 59
18946: PPUSH
18947: LD_STRING D2Rus-Pow-2a
18949: PPUSH
18950: CALL_OW 88
// end ; 3 :
18954: GO 19223
18956: LD_INT 3
18958: DOUBLE
18959: EQUAL
18960: IFTRUE 18964
18962: GO 19049
18964: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
18965: LD_EXP 40
18969: PPUSH
18970: LD_STRING D2Leg-JMM-1
18972: PPUSH
18973: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
18977: LD_EXP 59
18981: PPUSH
18982: LD_STRING D2Leg-Pow-1
18984: PPUSH
18985: CALL_OW 88
// if 2 in list_of_q then
18989: LD_INT 2
18991: PUSH
18992: LD_VAR 0 2
18996: IN
18997: IFFALSE 19023
// begin Say ( JMM , D2Leg-JMM-2 ) ;
18999: LD_EXP 40
19003: PPUSH
19004: LD_STRING D2Leg-JMM-2
19006: PPUSH
19007: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
19011: LD_EXP 59
19015: PPUSH
19016: LD_STRING D2Leg-Pow-2
19018: PPUSH
19019: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
19023: LD_EXP 40
19027: PPUSH
19028: LD_STRING D2Leg-JMM-3
19030: PPUSH
19031: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
19035: LD_EXP 59
19039: PPUSH
19040: LD_STRING D2Leg-Pow-3
19042: PPUSH
19043: CALL_OW 88
// end ; 4 :
19047: GO 19223
19049: LD_INT 4
19051: DOUBLE
19052: EQUAL
19053: IFTRUE 19057
19055: GO 19132
19057: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
19058: LD_EXP 40
19062: PPUSH
19063: LD_STRING D2Ar-JMM-1
19065: PPUSH
19066: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
19070: LD_EXP 59
19074: PPUSH
19075: LD_STRING D2Ar-Pow-1
19077: PPUSH
19078: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
19082: LD_EXP 40
19086: PPUSH
19087: LD_STRING D2Ar-JMM-2
19089: PPUSH
19090: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
19094: LD_EXP 59
19098: PPUSH
19099: LD_STRING D2Ar-Pow-2
19101: PPUSH
19102: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
19106: LD_EXP 40
19110: PPUSH
19111: LD_STRING D2Ar-JMM-3
19113: PPUSH
19114: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
19118: LD_EXP 59
19122: PPUSH
19123: LD_STRING D2Ar-Pow-3
19125: PPUSH
19126: CALL_OW 88
// end ; 5 :
19130: GO 19223
19132: LD_INT 5
19134: DOUBLE
19135: EQUAL
19136: IFTRUE 19140
19138: GO 19155
19140: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
19141: LD_EXP 40
19145: PPUSH
19146: LD_STRING D2Conf-JMM-1
19148: PPUSH
19149: CALL_OW 88
19153: GO 19223
19155: LD_INT 6
19157: DOUBLE
19158: EQUAL
19159: IFTRUE 19163
19161: GO 19222
19163: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
19164: LD_EXP 40
19168: PPUSH
19169: LD_STRING D2Com-JMM-1
19171: PPUSH
19172: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
19176: LD_EXP 59
19180: PPUSH
19181: LD_STRING D2Com-Pow-1
19183: PPUSH
19184: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
19188: LD_EXP 40
19192: PPUSH
19193: LD_STRING D2Com-JMM-2
19195: PPUSH
19196: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
19200: LD_EXP 59
19204: PPUSH
19205: LD_STRING D2Com-Pow-2
19207: PPUSH
19208: CALL_OW 88
// powellAngerQuery := true ;
19212: LD_ADDR_EXP 36
19216: PUSH
19217: LD_INT 1
19219: ST_TO_ADDR
// end ; end ;
19220: GO 19223
19222: POP
// end ;
19223: LD_VAR 0 3
19227: RET
// every 0 0$5 trigger missionStart do var tmp ;
19228: LD_EXP 13
19232: IFFALSE 19515
19234: GO 19236
19236: DISABLE
19237: LD_INT 0
19239: PPUSH
// begin repeat wait ( 0 0$1 ) ;
19240: LD_INT 35
19242: PPUSH
19243: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
19247: LD_INT 14
19249: PPUSH
19250: LD_INT 22
19252: PUSH
19253: LD_INT 1
19255: PUSH
19256: EMPTY
19257: LIST
19258: LIST
19259: PPUSH
19260: CALL_OW 70
19264: PUSH
19265: LD_EXP 15
19269: PUSH
19270: LD_INT 2
19272: PUSH
19273: LD_INT 3
19275: PUSH
19276: LD_INT 4
19278: PUSH
19279: LD_INT 5
19281: PUSH
19282: EMPTY
19283: LIST
19284: LIST
19285: LIST
19286: LIST
19287: IN
19288: AND
19289: IFFALSE 19505
// begin powellAnger := powellAnger + 1 ;
19291: LD_ADDR_EXP 17
19295: PUSH
19296: LD_EXP 17
19300: PUSH
19301: LD_INT 1
19303: PLUS
19304: ST_TO_ADDR
// Video ( true ) ;
19305: LD_INT 1
19307: PPUSH
19308: CALL 104655 0 1
// CenterNowOnUnits ( tmp ) ;
19312: LD_VAR 0 1
19316: PPUSH
19317: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
19321: LD_INT 14
19323: PPUSH
19324: LD_INT 22
19326: PUSH
19327: LD_INT 1
19329: PUSH
19330: EMPTY
19331: LIST
19332: LIST
19333: PPUSH
19334: CALL_OW 70
19338: PPUSH
19339: LD_INT 86
19341: PPUSH
19342: LD_INT 133
19344: PPUSH
19345: CALL_OW 111
// async ;
19349: ASYNC
// case powellAnger of 1 :
19350: LD_EXP 17
19354: PUSH
19355: LD_INT 1
19357: DOUBLE
19358: EQUAL
19359: IFTRUE 19363
19361: GO 19378
19363: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
19364: LD_EXP 59
19368: PPUSH
19369: LD_STRING DBack1-Pow-1
19371: PPUSH
19372: CALL_OW 88
19376: GO 19425
19378: LD_INT 2
19380: DOUBLE
19381: EQUAL
19382: IFTRUE 19386
19384: GO 19401
19386: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
19387: LD_EXP 59
19391: PPUSH
19392: LD_STRING DBack2-Pow-1
19394: PPUSH
19395: CALL_OW 88
19399: GO 19425
19401: LD_INT 3
19403: DOUBLE
19404: EQUAL
19405: IFTRUE 19409
19407: GO 19424
19409: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
19410: LD_EXP 59
19414: PPUSH
19415: LD_STRING DBack3-Pow-1
19417: PPUSH
19418: CALL_OW 88
19422: GO 19425
19424: POP
// sync ;
19425: SYNC
// repeat wait ( 0 0$1 ) ;
19426: LD_INT 35
19428: PPUSH
19429: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
19433: LD_INT 14
19435: PPUSH
19436: LD_INT 22
19438: PUSH
19439: LD_INT 1
19441: PUSH
19442: EMPTY
19443: LIST
19444: LIST
19445: PPUSH
19446: CALL_OW 70
19450: PPUSH
19451: LD_INT 86
19453: PPUSH
19454: LD_INT 133
19456: PPUSH
19457: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
19461: LD_INT 14
19463: PPUSH
19464: LD_INT 22
19466: PUSH
19467: LD_INT 1
19469: PUSH
19470: EMPTY
19471: LIST
19472: LIST
19473: PPUSH
19474: CALL_OW 70
19478: NOT
19479: IFFALSE 19426
// if powellAnger >= 3 then
19481: LD_EXP 17
19485: PUSH
19486: LD_INT 3
19488: GREATEREQUAL
19489: IFFALSE 19498
// YouLost ( Dismissed ) ;
19491: LD_STRING Dismissed
19493: PPUSH
19494: CALL_OW 104
// Video ( false ) ;
19498: LD_INT 0
19500: PPUSH
19501: CALL 104655 0 1
// end ; until missionStage > 5 ;
19505: LD_EXP 15
19509: PUSH
19510: LD_INT 5
19512: GREATER
19513: IFFALSE 19240
// end ;
19515: PPOPN 1
19517: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t ;
19518: LD_EXP 13
19522: PUSH
19523: LD_INT 22
19525: PUSH
19526: LD_INT 4
19528: PUSH
19529: EMPTY
19530: LIST
19531: LIST
19532: PUSH
19533: LD_INT 21
19535: PUSH
19536: LD_INT 2
19538: PUSH
19539: EMPTY
19540: LIST
19541: LIST
19542: PUSH
19543: EMPTY
19544: LIST
19545: LIST
19546: PPUSH
19547: CALL_OW 69
19551: PUSH
19552: LD_INT 4
19554: GREATEREQUAL
19555: AND
19556: PUSH
19557: LD_EXP 15
19561: PUSH
19562: LD_INT 2
19564: EQUAL
19565: AND
19566: IFFALSE 21756
19568: GO 19570
19570: DISABLE
19571: LD_INT 0
19573: PPUSH
19574: PPUSH
19575: PPUSH
19576: PPUSH
19577: PPUSH
19578: PPUSH
19579: PPUSH
19580: PPUSH
19581: PPUSH
19582: PPUSH
// begin missionStage := 3 ;
19583: LD_ADDR_EXP 15
19587: PUSH
19588: LD_INT 3
19590: ST_TO_ADDR
// retreat := false ;
19591: LD_ADDR_VAR 0 4
19595: PUSH
19596: LD_INT 0
19598: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
19599: LD_ADDR_VAR 0 5
19603: PUSH
19604: LD_INT 22
19606: PUSH
19607: LD_INT 4
19609: PUSH
19610: EMPTY
19611: LIST
19612: LIST
19613: PUSH
19614: LD_INT 30
19616: PUSH
19617: LD_INT 4
19619: PUSH
19620: EMPTY
19621: LIST
19622: LIST
19623: PUSH
19624: EMPTY
19625: LIST
19626: LIST
19627: PPUSH
19628: CALL_OW 69
19632: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
19633: LD_ADDR_VAR 0 6
19637: PUSH
19638: LD_INT 22
19640: PUSH
19641: LD_INT 4
19643: PUSH
19644: EMPTY
19645: LIST
19646: LIST
19647: PUSH
19648: LD_INT 30
19650: PUSH
19651: LD_INT 5
19653: PUSH
19654: EMPTY
19655: LIST
19656: LIST
19657: PUSH
19658: EMPTY
19659: LIST
19660: LIST
19661: PPUSH
19662: CALL_OW 69
19666: ST_TO_ADDR
// if not bar then
19667: LD_VAR 0 6
19671: NOT
19672: IFFALSE 19725
// begin repeat wait ( 0 0$1 ) ;
19674: LD_INT 35
19676: PPUSH
19677: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
19681: LD_INT 22
19683: PUSH
19684: LD_INT 4
19686: PUSH
19687: EMPTY
19688: LIST
19689: LIST
19690: PUSH
19691: LD_INT 3
19693: PUSH
19694: LD_INT 57
19696: PUSH
19697: EMPTY
19698: LIST
19699: PUSH
19700: EMPTY
19701: LIST
19702: LIST
19703: PUSH
19704: LD_INT 30
19706: PUSH
19707: LD_INT 5
19709: PUSH
19710: EMPTY
19711: LIST
19712: LIST
19713: PUSH
19714: EMPTY
19715: LIST
19716: LIST
19717: LIST
19718: PPUSH
19719: CALL_OW 69
19723: IFFALSE 19674
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
19725: LD_ADDR_VAR 0 6
19729: PUSH
19730: LD_INT 22
19732: PUSH
19733: LD_INT 4
19735: PUSH
19736: EMPTY
19737: LIST
19738: LIST
19739: PUSH
19740: LD_INT 30
19742: PUSH
19743: LD_INT 5
19745: PUSH
19746: EMPTY
19747: LIST
19748: LIST
19749: PUSH
19750: EMPTY
19751: LIST
19752: LIST
19753: PPUSH
19754: CALL_OW 69
19758: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19759: LD_INT 35
19761: PPUSH
19762: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
19766: LD_EXP 118
19770: PUSH
19771: LD_INT 4
19773: ARRAY
19774: PUSH
19775: LD_INT 4
19777: GREATEREQUAL
19778: IFFALSE 19759
// tmp := [ ] ;
19780: LD_ADDR_VAR 0 2
19784: PUSH
19785: EMPTY
19786: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) do
19787: LD_ADDR_VAR 0 1
19791: PUSH
19792: LD_INT 22
19794: PUSH
19795: LD_INT 4
19797: PUSH
19798: EMPTY
19799: LIST
19800: LIST
19801: PUSH
19802: LD_INT 2
19804: PUSH
19805: LD_INT 25
19807: PUSH
19808: LD_INT 1
19810: PUSH
19811: EMPTY
19812: LIST
19813: LIST
19814: PUSH
19815: LD_INT 25
19817: PUSH
19818: LD_INT 2
19820: PUSH
19821: EMPTY
19822: LIST
19823: LIST
19824: PUSH
19825: LD_INT 25
19827: PUSH
19828: LD_INT 3
19830: PUSH
19831: EMPTY
19832: LIST
19833: LIST
19834: PUSH
19835: LD_INT 25
19837: PUSH
19838: LD_INT 4
19840: PUSH
19841: EMPTY
19842: LIST
19843: LIST
19844: PUSH
19845: LD_INT 25
19847: PUSH
19848: LD_INT 5
19850: PUSH
19851: EMPTY
19852: LIST
19853: LIST
19854: PUSH
19855: EMPTY
19856: LIST
19857: LIST
19858: LIST
19859: LIST
19860: LIST
19861: LIST
19862: PUSH
19863: EMPTY
19864: LIST
19865: LIST
19866: PPUSH
19867: CALL_OW 69
19871: PUSH
19872: LD_EXP 59
19876: PUSH
19877: LD_EXP 60
19881: ADD
19882: DIFF
19883: PUSH
19884: FOR_IN
19885: IFFALSE 19949
// if GetTag ( i ) = 1 then
19887: LD_VAR 0 1
19891: PPUSH
19892: CALL_OW 110
19896: PUSH
19897: LD_INT 1
19899: EQUAL
19900: IFFALSE 19924
// tmp := Join ( tmp , i ) else
19902: LD_ADDR_VAR 0 2
19906: PUSH
19907: LD_VAR 0 2
19911: PPUSH
19912: LD_VAR 0 1
19916: PPUSH
19917: CALL 104683 0 2
19921: ST_TO_ADDR
19922: GO 19947
// tmp := Insert ( tmp , 1 , i ) ;
19924: LD_ADDR_VAR 0 2
19928: PUSH
19929: LD_VAR 0 2
19933: PPUSH
19934: LD_INT 1
19936: PPUSH
19937: LD_VAR 0 1
19941: PPUSH
19942: CALL_OW 2
19946: ST_TO_ADDR
19947: GO 19884
19949: POP
19950: POP
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
19951: LD_ADDR_VAR 0 3
19955: PUSH
19956: LD_VAR 0 2
19960: PPUSH
19961: LD_INT 26
19963: PUSH
19964: LD_INT 1
19966: PUSH
19967: EMPTY
19968: LIST
19969: LIST
19970: PPUSH
19971: CALL_OW 72
19975: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
19976: LD_ADDR_VAR 0 2
19980: PUSH
19981: LD_VAR 0 2
19985: PUSH
19986: LD_VAR 0 3
19990: DIFF
19991: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
19992: LD_ADDR_VAR 0 2
19996: PUSH
19997: LD_VAR 0 2
20001: PPUSH
20002: LD_INT 3
20004: PPUSH
20005: CALL 103192 0 2
20009: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
20010: LD_ADDR_VAR 0 3
20014: PUSH
20015: LD_VAR 0 3
20019: PPUSH
20020: LD_INT 3
20022: PPUSH
20023: CALL 103192 0 2
20027: ST_TO_ADDR
// for i := 1 to 4 do
20028: LD_ADDR_VAR 0 1
20032: PUSH
20033: DOUBLE
20034: LD_INT 1
20036: DEC
20037: ST_TO_ADDR
20038: LD_INT 4
20040: PUSH
20041: FOR_TO
20042: IFFALSE 20195
// begin if tmp2 then
20044: LD_VAR 0 3
20048: IFFALSE 20116
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
20050: LD_ADDR_EXP 18
20054: PUSH
20055: LD_EXP 18
20059: PPUSH
20060: LD_INT 1
20062: PPUSH
20063: LD_EXP 18
20067: PUSH
20068: LD_INT 1
20070: ARRAY
20071: PUSH
20072: LD_VAR 0 3
20076: PUSH
20077: LD_VAR 0 3
20081: ARRAY
20082: ADD
20083: PPUSH
20084: CALL_OW 1
20088: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
20089: LD_VAR 0 3
20093: PUSH
20094: LD_VAR 0 3
20098: ARRAY
20099: PPUSH
20100: LD_INT 1
20102: PPUSH
20103: CALL_OW 109
// tmp2 := [ ] ;
20107: LD_ADDR_VAR 0 3
20111: PUSH
20112: EMPTY
20113: ST_TO_ADDR
// end else
20114: GO 20193
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
20116: LD_ADDR_EXP 18
20120: PUSH
20121: LD_EXP 18
20125: PPUSH
20126: LD_INT 1
20128: PPUSH
20129: LD_EXP 18
20133: PUSH
20134: LD_INT 1
20136: ARRAY
20137: PUSH
20138: LD_VAR 0 2
20142: PUSH
20143: LD_VAR 0 2
20147: ARRAY
20148: ADD
20149: PPUSH
20150: CALL_OW 1
20154: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
20155: LD_VAR 0 2
20159: PUSH
20160: LD_VAR 0 2
20164: ARRAY
20165: PPUSH
20166: LD_INT 1
20168: PPUSH
20169: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
20173: LD_ADDR_VAR 0 2
20177: PUSH
20178: LD_VAR 0 2
20182: PPUSH
20183: LD_VAR 0 2
20187: PPUSH
20188: CALL_OW 3
20192: ST_TO_ADDR
// end ; end ;
20193: GO 20041
20195: POP
20196: POP
// if tmp2 then
20197: LD_VAR 0 3
20201: IFFALSE 20219
// tmp := tmp union tmp2 ;
20203: LD_ADDR_VAR 0 2
20207: PUSH
20208: LD_VAR 0 2
20212: PUSH
20213: LD_VAR 0 3
20217: UNION
20218: ST_TO_ADDR
// for i := 1 to 4 do
20219: LD_ADDR_VAR 0 1
20223: PUSH
20224: DOUBLE
20225: LD_INT 1
20227: DEC
20228: ST_TO_ADDR
20229: LD_INT 4
20231: PUSH
20232: FOR_TO
20233: IFFALSE 20282
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
20235: LD_ADDR_EXP 18
20239: PUSH
20240: LD_EXP 18
20244: PPUSH
20245: LD_INT 2
20247: PPUSH
20248: LD_EXP 18
20252: PUSH
20253: LD_INT 2
20255: ARRAY
20256: PUSH
20257: LD_VAR 0 2
20261: PUSH
20262: LD_VAR 0 2
20266: PUSH
20267: LD_VAR 0 1
20271: MINUS
20272: ARRAY
20273: ADD
20274: PPUSH
20275: CALL_OW 1
20279: ST_TO_ADDR
20280: GO 20232
20282: POP
20283: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
20284: LD_ADDR_EXP 99
20288: PUSH
20289: LD_EXP 99
20293: PPUSH
20294: LD_INT 4
20296: PPUSH
20297: LD_EXP 99
20301: PUSH
20302: LD_INT 4
20304: ARRAY
20305: PUSH
20306: LD_EXP 18
20310: PUSH
20311: LD_INT 1
20313: ARRAY
20314: DIFF
20315: PPUSH
20316: CALL_OW 1
20320: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
20321: LD_VAR 0 5
20325: PUSH
20326: LD_INT 1
20328: ARRAY
20329: PPUSH
20330: CALL_OW 313
20334: IFFALSE 20389
// begin for i in UnitsInside ( arm [ 1 ] ) do
20336: LD_ADDR_VAR 0 1
20340: PUSH
20341: LD_VAR 0 5
20345: PUSH
20346: LD_INT 1
20348: ARRAY
20349: PPUSH
20350: CALL_OW 313
20354: PUSH
20355: FOR_IN
20356: IFFALSE 20387
// begin ComExitBuilding ( i ) ;
20358: LD_VAR 0 1
20362: PPUSH
20363: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
20367: LD_VAR 0 1
20371: PPUSH
20372: LD_VAR 0 6
20376: PUSH
20377: LD_INT 1
20379: ARRAY
20380: PPUSH
20381: CALL_OW 180
// end ;
20385: GO 20355
20387: POP
20388: POP
// end ; wait ( 0 0$3 ) ;
20389: LD_INT 105
20391: PPUSH
20392: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
20396: LD_ADDR_VAR 0 1
20400: PUSH
20401: LD_EXP 18
20405: PUSH
20406: LD_INT 1
20408: ARRAY
20409: PUSH
20410: FOR_IN
20411: IFFALSE 20518
// begin if IsInUnit ( i ) then
20413: LD_VAR 0 1
20417: PPUSH
20418: CALL_OW 310
20422: IFFALSE 20433
// ComExitBuilding ( i ) ;
20424: LD_VAR 0 1
20428: PPUSH
20429: CALL_OW 122
// if GetClass ( i ) <> 1 then
20433: LD_VAR 0 1
20437: PPUSH
20438: CALL_OW 257
20442: PUSH
20443: LD_INT 1
20445: NONEQUAL
20446: IFFALSE 20487
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
20448: LD_VAR 0 1
20452: PPUSH
20453: LD_VAR 0 5
20457: PUSH
20458: LD_INT 1
20460: ARRAY
20461: PPUSH
20462: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
20466: LD_VAR 0 1
20470: PPUSH
20471: LD_INT 1
20473: PPUSH
20474: CALL_OW 183
// AddComExitBuilding ( i ) ;
20478: LD_VAR 0 1
20482: PPUSH
20483: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
20487: LD_VAR 0 1
20491: PPUSH
20492: LD_INT 60
20494: PPUSH
20495: LD_INT 94
20497: PPUSH
20498: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
20502: LD_VAR 0 1
20506: PPUSH
20507: LD_EXP 59
20511: PPUSH
20512: CALL_OW 179
// end ;
20516: GO 20410
20518: POP
20519: POP
// wait ( 0 0$10 ) ;
20520: LD_INT 350
20522: PPUSH
20523: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
20527: LD_EXP 59
20531: PPUSH
20532: LD_STRING D4-Pow-1
20534: PPUSH
20535: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
20539: LD_ADDR_VAR 0 2
20543: PUSH
20544: LD_EXP 18
20548: PUSH
20549: LD_INT 1
20551: ARRAY
20552: PPUSH
20553: LD_INT 26
20555: PUSH
20556: LD_INT 1
20558: PUSH
20559: EMPTY
20560: LIST
20561: LIST
20562: PPUSH
20563: CALL_OW 72
20567: ST_TO_ADDR
// if tmp then
20568: LD_VAR 0 2
20572: IFFALSE 20590
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
20574: LD_VAR 0 2
20578: PUSH
20579: LD_INT 1
20581: ARRAY
20582: PPUSH
20583: LD_STRING D4-Sol1-1
20585: PPUSH
20586: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
20590: LD_EXP 59
20594: PPUSH
20595: LD_STRING D4-Pow-2
20597: PPUSH
20598: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
20602: LD_ADDR_VAR 0 1
20606: PUSH
20607: DOUBLE
20608: LD_INT 1
20610: DEC
20611: ST_TO_ADDR
20612: LD_EXP 18
20616: PUSH
20617: LD_INT 1
20619: ARRAY
20620: PUSH
20621: FOR_TO
20622: IFFALSE 20715
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
20624: LD_EXP 18
20628: PUSH
20629: LD_INT 1
20631: ARRAY
20632: PUSH
20633: LD_VAR 0 1
20637: ARRAY
20638: PPUSH
20639: LD_EXP 118
20643: PUSH
20644: LD_INT 4
20646: ARRAY
20647: PUSH
20648: LD_INT 1
20650: ARRAY
20651: PPUSH
20652: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
20656: LD_ADDR_EXP 118
20660: PUSH
20661: LD_EXP 118
20665: PPUSH
20666: LD_INT 4
20668: PPUSH
20669: LD_EXP 118
20673: PUSH
20674: LD_INT 4
20676: ARRAY
20677: PPUSH
20678: LD_INT 1
20680: PPUSH
20681: CALL_OW 3
20685: PPUSH
20686: CALL_OW 1
20690: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
20691: LD_INT 8
20693: PPUSH
20694: LD_EXP 18
20698: PUSH
20699: LD_INT 1
20701: ARRAY
20702: PUSH
20703: LD_VAR 0 1
20707: ARRAY
20708: PPUSH
20709: CALL_OW 471
// end ;
20713: GO 20621
20715: POP
20716: POP
// repeat wait ( 0 0$1 ) ;
20717: LD_INT 35
20719: PPUSH
20720: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
20724: LD_EXP 18
20728: PUSH
20729: LD_INT 1
20731: ARRAY
20732: PPUSH
20733: LD_INT 55
20735: PUSH
20736: EMPTY
20737: LIST
20738: PPUSH
20739: CALL_OW 72
20743: PUSH
20744: LD_INT 4
20746: GREATEREQUAL
20747: IFFALSE 20717
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
20749: LD_EXP 18
20753: PUSH
20754: LD_INT 1
20756: ARRAY
20757: PPUSH
20758: LD_INT 69
20760: PPUSH
20761: LD_INT 94
20763: PPUSH
20764: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
20768: LD_EXP 18
20772: PUSH
20773: LD_INT 1
20775: ARRAY
20776: PPUSH
20777: LD_INT 82
20779: PPUSH
20780: LD_INT 83
20782: PPUSH
20783: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
20787: LD_EXP 18
20791: PUSH
20792: LD_INT 1
20794: ARRAY
20795: PPUSH
20796: LD_INT 77
20798: PPUSH
20799: LD_INT 69
20801: PPUSH
20802: CALL_OW 174
// repeat wait ( 3 ) ;
20806: LD_INT 3
20808: PPUSH
20809: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
20813: LD_ADDR_VAR 0 1
20817: PUSH
20818: LD_EXP 18
20822: PUSH
20823: LD_INT 1
20825: ARRAY
20826: PUSH
20827: FOR_IN
20828: IFFALSE 20964
// begin if GetLives ( i ) < 990 then
20830: LD_VAR 0 1
20834: PPUSH
20835: CALL_OW 256
20839: PUSH
20840: LD_INT 990
20842: LESS
20843: IFFALSE 20857
// SetLives ( i , 1000 ) ;
20845: LD_VAR 0 1
20849: PPUSH
20850: LD_INT 1000
20852: PPUSH
20853: CALL_OW 234
// if not IsInUnit ( i ) then
20857: LD_VAR 0 1
20861: PPUSH
20862: CALL_OW 310
20866: NOT
20867: IFFALSE 20962
// begin if not HasTask ( i ) then
20869: LD_VAR 0 1
20873: PPUSH
20874: CALL_OW 314
20878: NOT
20879: IFFALSE 20896
// ComMoveXY ( i , 64 , 93 ) ;
20881: LD_VAR 0 1
20885: PPUSH
20886: LD_INT 64
20888: PPUSH
20889: LD_INT 93
20891: PPUSH
20892: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
20896: LD_VAR 0 4
20900: NOT
20901: PUSH
20902: LD_VAR 0 1
20906: PPUSH
20907: CALL_OW 258
20911: PUSH
20912: LD_INT 1
20914: EQUAL
20915: AND
20916: IFFALSE 20962
// begin retreat := true ;
20918: LD_ADDR_VAR 0 4
20922: PUSH
20923: LD_INT 1
20925: ST_TO_ADDR
// SetTag ( i , 2 ) ;
20926: LD_VAR 0 1
20930: PPUSH
20931: LD_INT 2
20933: PPUSH
20934: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
20938: LD_VAR 0 1
20942: PPUSH
20943: LD_STRING D4a-Sol1-1
20945: PPUSH
20946: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
20950: LD_EXP 59
20954: PPUSH
20955: LD_STRING D4a-Pow-1
20957: PPUSH
20958: CALL_OW 88
// end ; end ; end ;
20962: GO 20827
20964: POP
20965: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
20966: LD_EXP 18
20970: PUSH
20971: LD_INT 1
20973: ARRAY
20974: PPUSH
20975: LD_INT 95
20977: PUSH
20978: LD_INT 9
20980: PUSH
20981: EMPTY
20982: LIST
20983: LIST
20984: PUSH
20985: LD_INT 3
20987: PUSH
20988: LD_INT 55
20990: PUSH
20991: EMPTY
20992: LIST
20993: PUSH
20994: EMPTY
20995: LIST
20996: LIST
20997: PUSH
20998: EMPTY
20999: LIST
21000: LIST
21001: PPUSH
21002: CALL_OW 72
21006: PUSH
21007: LD_INT 4
21009: GREATEREQUAL
21010: IFFALSE 20806
// for i in powellSquadAttack [ 1 ] do
21012: LD_ADDR_VAR 0 1
21016: PUSH
21017: LD_EXP 18
21021: PUSH
21022: LD_INT 1
21024: ARRAY
21025: PUSH
21026: FOR_IN
21027: IFFALSE 21163
// begin if GetTag ( i ) = 2 then
21029: LD_VAR 0 1
21033: PPUSH
21034: CALL_OW 110
21038: PUSH
21039: LD_INT 2
21041: EQUAL
21042: IFFALSE 21104
// begin ComMoveXY ( i , 60 , 94 ) ;
21044: LD_VAR 0 1
21048: PPUSH
21049: LD_INT 60
21051: PPUSH
21052: LD_INT 94
21054: PPUSH
21055: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
21059: LD_VAR 0 1
21063: PPUSH
21064: LD_EXP 59
21068: PPUSH
21069: CALL_OW 179
// wait ( 0 0$3 ) ;
21073: LD_INT 105
21075: PPUSH
21076: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
21080: LD_VAR 0 1
21084: PPUSH
21085: LD_STRING D4a-Sol1-2
21087: PPUSH
21088: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
21092: LD_EXP 59
21096: PPUSH
21097: LD_STRING D4a-Pow-2
21099: PPUSH
21100: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
21104: LD_VAR 0 1
21108: PPUSH
21109: LD_INT 0
21111: PPUSH
21112: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
21116: LD_ADDR_EXP 99
21120: PUSH
21121: LD_EXP 99
21125: PPUSH
21126: LD_INT 4
21128: PPUSH
21129: LD_EXP 99
21133: PUSH
21134: LD_INT 4
21136: ARRAY
21137: PUSH
21138: LD_VAR 0 1
21142: UNION
21143: PPUSH
21144: CALL_OW 1
21148: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
21149: LD_INT 8
21151: PPUSH
21152: LD_VAR 0 1
21156: PPUSH
21157: CALL_OW 472
// end ;
21161: GO 21026
21163: POP
21164: POP
// wait ( 2 2$00 ) ;
21165: LD_INT 4200
21167: PPUSH
21168: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21172: LD_ADDR_VAR 0 9
21176: PUSH
21177: LD_INT 22
21179: PUSH
21180: LD_INT 4
21182: PUSH
21183: EMPTY
21184: LIST
21185: LIST
21186: PUSH
21187: LD_INT 30
21189: PUSH
21190: LD_INT 32
21192: PUSH
21193: EMPTY
21194: LIST
21195: LIST
21196: PUSH
21197: LD_INT 58
21199: PUSH
21200: EMPTY
21201: LIST
21202: PUSH
21203: EMPTY
21204: LIST
21205: LIST
21206: LIST
21207: PPUSH
21208: CALL_OW 69
21212: ST_TO_ADDR
// if tmp then
21213: LD_VAR 0 2
21217: IFFALSE 21457
// begin for i := 1 to tmp do
21219: LD_ADDR_VAR 0 1
21223: PUSH
21224: DOUBLE
21225: LD_INT 1
21227: DEC
21228: ST_TO_ADDR
21229: LD_VAR 0 2
21233: PUSH
21234: FOR_TO
21235: IFFALSE 21448
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
21237: LD_ADDR_EXP 99
21241: PUSH
21242: LD_EXP 99
21246: PPUSH
21247: LD_INT 4
21249: PPUSH
21250: LD_EXP 99
21254: PUSH
21255: LD_INT 4
21257: ARRAY
21258: PUSH
21259: LD_VAR 0 2
21263: PUSH
21264: LD_VAR 0 1
21268: ARRAY
21269: DIFF
21270: PPUSH
21271: CALL_OW 1
21275: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
21276: LD_ADDR_VAR 0 10
21280: PUSH
21281: LD_VAR 0 2
21285: PUSH
21286: LD_VAR 0 1
21290: ARRAY
21291: PPUSH
21292: CALL_OW 310
21296: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
21297: LD_VAR 0 10
21301: PUSH
21302: LD_VAR 0 10
21306: PPUSH
21307: CALL_OW 266
21311: PUSH
21312: LD_INT 32
21314: EQUAL
21315: AND
21316: IFFALSE 21320
// continue ;
21318: GO 21234
// if t then
21320: LD_VAR 0 10
21324: IFFALSE 21341
// ComExitBuilding ( tmp [ i ] ) ;
21326: LD_VAR 0 2
21330: PUSH
21331: LD_VAR 0 1
21335: ARRAY
21336: PPUSH
21337: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21341: LD_VAR 0 2
21345: PUSH
21346: LD_VAR 0 1
21350: ARRAY
21351: PPUSH
21352: LD_VAR 0 5
21356: PUSH
21357: LD_INT 1
21359: ARRAY
21360: PPUSH
21361: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21365: LD_VAR 0 2
21369: PUSH
21370: LD_VAR 0 1
21374: ARRAY
21375: PPUSH
21376: LD_INT 1
21378: PPUSH
21379: CALL_OW 183
// if emptyTowers then
21383: LD_VAR 0 9
21387: IFFALSE 21446
// begin AddComExitBuilding ( tmp [ i ] ) ;
21389: LD_VAR 0 2
21393: PUSH
21394: LD_VAR 0 1
21398: ARRAY
21399: PPUSH
21400: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
21404: LD_VAR 0 2
21408: PUSH
21409: LD_VAR 0 1
21413: ARRAY
21414: PPUSH
21415: LD_VAR 0 9
21419: PUSH
21420: LD_INT 1
21422: ARRAY
21423: PPUSH
21424: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
21428: LD_ADDR_VAR 0 9
21432: PUSH
21433: LD_VAR 0 9
21437: PPUSH
21438: LD_INT 1
21440: PPUSH
21441: CALL_OW 3
21445: ST_TO_ADDR
// end ; end ;
21446: GO 21234
21448: POP
21449: POP
// wait ( 0 0$30 ) ;
21450: LD_INT 1050
21452: PPUSH
21453: CALL_OW 67
// end ; uc_side := 6 ;
21457: LD_ADDR_OWVAR 20
21461: PUSH
21462: LD_INT 6
21464: ST_TO_ADDR
// uc_nation := 3 ;
21465: LD_ADDR_OWVAR 21
21469: PUSH
21470: LD_INT 3
21472: ST_TO_ADDR
// ru := [ ] ;
21473: LD_ADDR_VAR 0 7
21477: PUSH
21478: EMPTY
21479: ST_TO_ADDR
// for i = 1 to 5 do
21480: LD_ADDR_VAR 0 1
21484: PUSH
21485: DOUBLE
21486: LD_INT 1
21488: DEC
21489: ST_TO_ADDR
21490: LD_INT 5
21492: PUSH
21493: FOR_TO
21494: IFFALSE 21614
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
21496: LD_INT 22
21498: PUSH
21499: LD_INT 23
21501: PUSH
21502: EMPTY
21503: LIST
21504: LIST
21505: PUSH
21506: LD_INT 1
21508: PPUSH
21509: LD_INT 2
21511: PPUSH
21512: CALL_OW 12
21516: ARRAY
21517: PPUSH
21518: LD_INT 1
21520: PPUSH
21521: LD_INT 3
21523: PPUSH
21524: LD_INT 43
21526: PUSH
21527: LD_INT 44
21529: PUSH
21530: EMPTY
21531: LIST
21532: LIST
21533: PUSH
21534: LD_INT 1
21536: PPUSH
21537: LD_INT 2
21539: PPUSH
21540: CALL_OW 12
21544: ARRAY
21545: PPUSH
21546: LD_INT 89
21548: PPUSH
21549: CALL 72249 0 5
// un := CreateVehicle ;
21553: LD_ADDR_VAR 0 8
21557: PUSH
21558: CALL_OW 45
21562: ST_TO_ADDR
// SetDir ( un , 4 ) ;
21563: LD_VAR 0 8
21567: PPUSH
21568: LD_INT 4
21570: PPUSH
21571: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
21575: LD_VAR 0 8
21579: PPUSH
21580: LD_INT 136
21582: PPUSH
21583: LD_INT 90
21585: PPUSH
21586: LD_INT 8
21588: PPUSH
21589: LD_INT 0
21591: PPUSH
21592: CALL_OW 50
// ru := ru ^ un ;
21596: LD_ADDR_VAR 0 7
21600: PUSH
21601: LD_VAR 0 7
21605: PUSH
21606: LD_VAR 0 8
21610: ADD
21611: ST_TO_ADDR
// end ;
21612: GO 21493
21614: POP
21615: POP
// if ru then
21616: LD_VAR 0 7
21620: IFFALSE 21637
// ComAgressiveMove ( ru , 57 , 94 ) ;
21622: LD_VAR 0 7
21626: PPUSH
21627: LD_INT 57
21629: PPUSH
21630: LD_INT 94
21632: PPUSH
21633: CALL_OW 114
// wait ( 3 3$00 ) ;
21637: LD_INT 6300
21639: PPUSH
21640: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
21644: LD_INT 4
21646: PPUSH
21647: LD_INT 3
21649: PUSH
21650: LD_INT 1
21652: PUSH
21653: LD_INT 1
21655: PUSH
21656: LD_INT 5
21658: PUSH
21659: EMPTY
21660: LIST
21661: LIST
21662: LIST
21663: LIST
21664: PUSH
21665: LD_INT 4
21667: PUSH
21668: LD_INT 1
21670: PUSH
21671: LD_INT 1
21673: PUSH
21674: LD_INT 6
21676: PUSH
21677: EMPTY
21678: LIST
21679: LIST
21680: LIST
21681: LIST
21682: PUSH
21683: LD_INT 4
21685: PUSH
21686: LD_INT 1
21688: PUSH
21689: LD_INT 1
21691: PUSH
21692: LD_INT 7
21694: PUSH
21695: EMPTY
21696: LIST
21697: LIST
21698: LIST
21699: LIST
21700: PUSH
21701: LD_INT 3
21703: PUSH
21704: LD_INT 1
21706: PUSH
21707: LD_INT 1
21709: PUSH
21710: LD_INT 7
21712: PUSH
21713: EMPTY
21714: LIST
21715: LIST
21716: LIST
21717: LIST
21718: PUSH
21719: LD_INT 3
21721: PUSH
21722: LD_INT 1
21724: PUSH
21725: LD_INT 1
21727: PUSH
21728: LD_INT 5
21730: PUSH
21731: EMPTY
21732: LIST
21733: LIST
21734: LIST
21735: LIST
21736: PUSH
21737: EMPTY
21738: LIST
21739: LIST
21740: LIST
21741: LIST
21742: LIST
21743: PPUSH
21744: CALL 60798 0 2
// missionStage := 4 ;
21748: LD_ADDR_EXP 15
21752: PUSH
21753: LD_INT 4
21755: ST_TO_ADDR
// end ;
21756: PPOPN 10
21758: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
21759: LD_EXP 15
21763: PUSH
21764: LD_INT 4
21766: EQUAL
21767: PUSH
21768: LD_INT 22
21770: PUSH
21771: LD_INT 4
21773: PUSH
21774: EMPTY
21775: LIST
21776: LIST
21777: PUSH
21778: LD_INT 21
21780: PUSH
21781: LD_INT 2
21783: PUSH
21784: EMPTY
21785: LIST
21786: LIST
21787: PUSH
21788: EMPTY
21789: LIST
21790: LIST
21791: PPUSH
21792: CALL_OW 69
21796: PUSH
21797: LD_INT 5
21799: GREATEREQUAL
21800: AND
21801: IFFALSE 26014
21803: GO 21805
21805: DISABLE
21806: LD_INT 0
21808: PPUSH
21809: PPUSH
21810: PPUSH
21811: PPUSH
21812: PPUSH
21813: PPUSH
21814: PPUSH
21815: PPUSH
21816: PPUSH
21817: PPUSH
21818: PPUSH
21819: PPUSH
21820: PPUSH
// begin wait ( 0 0$10 ) ;
21821: LD_INT 350
21823: PPUSH
21824: CALL_OW 67
// missionStage := 5 ;
21828: LD_ADDR_EXP 15
21832: PUSH
21833: LD_INT 5
21835: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
21836: LD_ADDR_VAR 0 10
21840: PUSH
21841: LD_INT 22
21843: PUSH
21844: LD_INT 4
21846: PUSH
21847: EMPTY
21848: LIST
21849: LIST
21850: PUSH
21851: LD_INT 2
21853: PUSH
21854: LD_INT 30
21856: PUSH
21857: LD_INT 4
21859: PUSH
21860: EMPTY
21861: LIST
21862: LIST
21863: PUSH
21864: LD_INT 30
21866: PUSH
21867: LD_INT 5
21869: PUSH
21870: EMPTY
21871: LIST
21872: LIST
21873: PUSH
21874: EMPTY
21875: LIST
21876: LIST
21877: LIST
21878: PUSH
21879: EMPTY
21880: LIST
21881: LIST
21882: PPUSH
21883: CALL_OW 69
21887: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
21888: LD_ADDR_VAR 0 6
21892: PUSH
21893: LD_INT 22
21895: PUSH
21896: LD_INT 4
21898: PUSH
21899: EMPTY
21900: LIST
21901: LIST
21902: PUSH
21903: LD_INT 21
21905: PUSH
21906: LD_INT 1
21908: PUSH
21909: EMPTY
21910: LIST
21911: LIST
21912: PUSH
21913: LD_INT 3
21915: PUSH
21916: LD_INT 25
21918: PUSH
21919: LD_INT 16
21921: PUSH
21922: EMPTY
21923: LIST
21924: LIST
21925: PUSH
21926: EMPTY
21927: LIST
21928: LIST
21929: PUSH
21930: LD_INT 3
21932: PUSH
21933: LD_INT 25
21935: PUSH
21936: LD_INT 12
21938: PUSH
21939: EMPTY
21940: LIST
21941: LIST
21942: PUSH
21943: EMPTY
21944: LIST
21945: LIST
21946: PUSH
21947: EMPTY
21948: LIST
21949: LIST
21950: LIST
21951: LIST
21952: PPUSH
21953: CALL_OW 69
21957: PUSH
21958: LD_EXP 59
21962: DIFF
21963: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
21964: LD_ADDR_VAR 0 9
21968: PUSH
21969: LD_INT 22
21971: PUSH
21972: LD_INT 4
21974: PUSH
21975: EMPTY
21976: LIST
21977: LIST
21978: PUSH
21979: LD_INT 30
21981: PUSH
21982: LD_INT 3
21984: PUSH
21985: EMPTY
21986: LIST
21987: LIST
21988: PUSH
21989: EMPTY
21990: LIST
21991: LIST
21992: PPUSH
21993: CALL_OW 69
21997: PUSH
21998: LD_INT 1
22000: ARRAY
22001: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
22002: LD_INT 350
22004: PPUSH
22005: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
22009: LD_EXP 118
22013: PUSH
22014: LD_INT 4
22016: ARRAY
22017: PUSH
22018: LD_INT 5
22020: LESS
22021: PUSH
22022: LD_VAR 0 9
22026: PPUSH
22027: CALL_OW 461
22031: PUSH
22032: LD_INT 2
22034: EQUAL
22035: AND
22036: IFFALSE 22066
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
22038: LD_INT 4
22040: PPUSH
22041: LD_INT 3
22043: PUSH
22044: LD_INT 1
22046: PUSH
22047: LD_INT 1
22049: PUSH
22050: LD_INT 5
22052: PUSH
22053: EMPTY
22054: LIST
22055: LIST
22056: LIST
22057: LIST
22058: PUSH
22059: EMPTY
22060: LIST
22061: PPUSH
22062: CALL 60846 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
22066: LD_EXP 118
22070: PUSH
22071: LD_INT 4
22073: ARRAY
22074: PUSH
22075: LD_INT 5
22077: GREATEREQUAL
22078: PUSH
22079: LD_EXP 118
22083: PUSH
22084: LD_INT 4
22086: ARRAY
22087: PPUSH
22088: LD_INT 58
22090: PUSH
22091: EMPTY
22092: LIST
22093: PPUSH
22094: CALL_OW 72
22098: PUSH
22099: LD_INT 5
22101: GREATEREQUAL
22102: AND
22103: IFFALSE 22002
// powellAllowRetreat := false ;
22105: LD_ADDR_EXP 19
22109: PUSH
22110: LD_INT 0
22112: ST_TO_ADDR
// activeAttacks := false ;
22113: LD_ADDR_EXP 16
22117: PUSH
22118: LD_INT 0
22120: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22121: LD_INT 35
22123: PPUSH
22124: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
22128: LD_INT 22
22130: PUSH
22131: LD_INT 6
22133: PUSH
22134: EMPTY
22135: LIST
22136: LIST
22137: PPUSH
22138: CALL_OW 69
22142: PUSH
22143: LD_INT 0
22145: EQUAL
22146: IFFALSE 22121
// tmp := mc_vehicles [ 4 ] ;
22148: LD_ADDR_VAR 0 3
22152: PUSH
22153: LD_EXP 118
22157: PUSH
22158: LD_INT 4
22160: ARRAY
22161: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
22162: LD_ADDR_VAR 0 1
22166: PUSH
22167: DOUBLE
22168: LD_INT 1
22170: DEC
22171: ST_TO_ADDR
22172: LD_EXP 18
22176: PUSH
22177: FOR_TO
22178: IFFALSE 22439
// begin for j in powellSquadAttack [ i ] do
22180: LD_ADDR_VAR 0 2
22184: PUSH
22185: LD_EXP 18
22189: PUSH
22190: LD_VAR 0 1
22194: ARRAY
22195: PUSH
22196: FOR_IN
22197: IFFALSE 22435
// begin forces := forces diff j ;
22199: LD_ADDR_VAR 0 6
22203: PUSH
22204: LD_VAR 0 6
22208: PUSH
22209: LD_VAR 0 2
22213: DIFF
22214: ST_TO_ADDR
// SetTag ( j , 1 ) ;
22215: LD_VAR 0 2
22219: PPUSH
22220: LD_INT 1
22222: PPUSH
22223: CALL_OW 109
// wait ( 0 0$2 ) ;
22227: LD_INT 70
22229: PPUSH
22230: CALL_OW 67
// if IsInUnit ( j ) then
22234: LD_VAR 0 2
22238: PPUSH
22239: CALL_OW 310
22243: IFFALSE 22254
// ComExitBuilding ( j ) ;
22245: LD_VAR 0 2
22249: PPUSH
22250: CALL_OW 122
// if GetClass ( j ) <> 1 then
22254: LD_VAR 0 2
22258: PPUSH
22259: CALL_OW 257
22263: PUSH
22264: LD_INT 1
22266: NONEQUAL
22267: IFFALSE 22347
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
22269: LD_VAR 0 10
22273: PUSH
22274: LD_INT 1
22276: ARRAY
22277: PPUSH
22278: CALL_OW 313
22282: PUSH
22283: LD_INT 5
22285: GREATEREQUAL
22286: IFFALSE 22308
// AddComEnterUnit ( j , arm [ 2 ] ) else
22288: LD_VAR 0 2
22292: PPUSH
22293: LD_VAR 0 10
22297: PUSH
22298: LD_INT 2
22300: ARRAY
22301: PPUSH
22302: CALL_OW 180
22306: GO 22326
// AddComEnterUnit ( j , arm [ 1 ] ) ;
22308: LD_VAR 0 2
22312: PPUSH
22313: LD_VAR 0 10
22317: PUSH
22318: LD_INT 1
22320: ARRAY
22321: PPUSH
22322: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
22326: LD_VAR 0 2
22330: PPUSH
22331: LD_INT 1
22333: PPUSH
22334: CALL_OW 183
// AddComExitBuilding ( j ) ;
22338: LD_VAR 0 2
22342: PPUSH
22343: CALL_OW 182
// end ; if i = 2 then
22347: LD_VAR 0 1
22351: PUSH
22352: LD_INT 2
22354: EQUAL
22355: IFFALSE 22372
// AddComMoveXY ( j , 61 , 93 ) ;
22357: LD_VAR 0 2
22361: PPUSH
22362: LD_INT 61
22364: PPUSH
22365: LD_INT 93
22367: PPUSH
22368: CALL_OW 171
// if i = 1 then
22372: LD_VAR 0 1
22376: PUSH
22377: LD_INT 1
22379: EQUAL
22380: IFFALSE 22433
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
22382: LD_VAR 0 2
22386: PPUSH
22387: LD_VAR 0 3
22391: PUSH
22392: LD_INT 1
22394: ARRAY
22395: PPUSH
22396: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
22400: LD_ADDR_VAR 0 3
22404: PUSH
22405: LD_VAR 0 3
22409: PPUSH
22410: LD_INT 1
22412: PPUSH
22413: CALL_OW 3
22417: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
22418: LD_VAR 0 2
22422: PPUSH
22423: LD_INT 69
22425: PPUSH
22426: LD_INT 94
22428: PPUSH
22429: CALL_OW 171
// end ; end ;
22433: GO 22196
22435: POP
22436: POP
// end ;
22437: GO 22177
22439: POP
22440: POP
// wait ( 0 0$30 ) ;
22441: LD_INT 1050
22443: PPUSH
22444: CALL_OW 67
// MC_Kill ( 4 ) ;
22448: LD_INT 4
22450: PPUSH
22451: CALL 36819 0 1
// tmp := UnitsInside ( fac ) ;
22455: LD_ADDR_VAR 0 3
22459: PUSH
22460: LD_VAR 0 9
22464: PPUSH
22465: CALL_OW 313
22469: ST_TO_ADDR
// if tmp then
22470: LD_VAR 0 3
22474: IFFALSE 22595
// for i in tmp do
22476: LD_ADDR_VAR 0 1
22480: PUSH
22481: LD_VAR 0 3
22485: PUSH
22486: FOR_IN
22487: IFFALSE 22593
// begin ComExitBuilding ( i ) ;
22489: LD_VAR 0 1
22493: PPUSH
22494: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
22498: LD_VAR 0 10
22502: PUSH
22503: LD_INT 2
22505: ARRAY
22506: PPUSH
22507: CALL_OW 313
22511: PUSH
22512: LD_INT 6
22514: LESS
22515: IFFALSE 22537
// AddComEnterUnit ( i , arm [ 2 ] ) else
22517: LD_VAR 0 1
22521: PPUSH
22522: LD_VAR 0 10
22526: PUSH
22527: LD_INT 2
22529: ARRAY
22530: PPUSH
22531: CALL_OW 180
22535: GO 22591
// if UnitsInside ( arm [ 1 ] ) < 6 then
22537: LD_VAR 0 10
22541: PUSH
22542: LD_INT 1
22544: ARRAY
22545: PPUSH
22546: CALL_OW 313
22550: PUSH
22551: LD_INT 6
22553: LESS
22554: IFFALSE 22576
// AddComEnterUnit ( i , arm [ 1 ] ) else
22556: LD_VAR 0 1
22560: PPUSH
22561: LD_VAR 0 10
22565: PUSH
22566: LD_INT 1
22568: ARRAY
22569: PPUSH
22570: CALL_OW 180
22574: GO 22591
// AddComMoveXY ( i , 37 , 68 ) ;
22576: LD_VAR 0 1
22580: PPUSH
22581: LD_INT 37
22583: PPUSH
22584: LD_INT 68
22586: PPUSH
22587: CALL_OW 171
// end ;
22591: GO 22486
22593: POP
22594: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
22595: LD_ADDR_VAR 0 11
22599: PUSH
22600: LD_VAR 0 6
22604: PPUSH
22605: LD_INT 26
22607: PUSH
22608: LD_INT 1
22610: PUSH
22611: EMPTY
22612: LIST
22613: LIST
22614: PPUSH
22615: CALL_OW 72
22619: PUSH
22620: LD_EXP 60
22624: DIFF
22625: ST_TO_ADDR
// if not speaker then
22626: LD_VAR 0 11
22630: NOT
22631: IFFALSE 22658
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
22633: LD_ADDR_VAR 0 11
22637: PUSH
22638: LD_VAR 0 6
22642: PPUSH
22643: LD_INT 26
22645: PUSH
22646: LD_INT 1
22648: PUSH
22649: EMPTY
22650: LIST
22651: LIST
22652: PPUSH
22653: CALL_OW 72
22657: ST_TO_ADDR
// if speaker then
22658: LD_VAR 0 11
22662: IFFALSE 22678
// speaker := speaker [ 1 ] ;
22664: LD_ADDR_VAR 0 11
22668: PUSH
22669: LD_VAR 0 11
22673: PUSH
22674: LD_INT 1
22676: ARRAY
22677: ST_TO_ADDR
// Video ( true ) ;
22678: LD_INT 1
22680: PPUSH
22681: CALL 104655 0 1
// CenterNowOnUnits ( Powell ) ;
22685: LD_EXP 59
22689: PPUSH
22690: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
22694: LD_ADDR_VAR 0 3
22698: PUSH
22699: LD_VAR 0 6
22703: PPUSH
22704: LD_INT 3
22706: PUSH
22707: LD_INT 25
22709: PUSH
22710: LD_INT 1
22712: PUSH
22713: EMPTY
22714: LIST
22715: LIST
22716: PUSH
22717: EMPTY
22718: LIST
22719: LIST
22720: PPUSH
22721: CALL_OW 72
22725: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
22726: LD_ADDR_VAR 0 12
22730: PUSH
22731: LD_INT 22
22733: PUSH
22734: LD_INT 4
22736: PUSH
22737: EMPTY
22738: LIST
22739: LIST
22740: PUSH
22741: LD_INT 30
22743: PUSH
22744: LD_INT 32
22746: PUSH
22747: EMPTY
22748: LIST
22749: LIST
22750: PUSH
22751: LD_INT 58
22753: PUSH
22754: EMPTY
22755: LIST
22756: PUSH
22757: EMPTY
22758: LIST
22759: LIST
22760: LIST
22761: PPUSH
22762: CALL_OW 69
22766: ST_TO_ADDR
// for i := 1 to 4 do
22767: LD_ADDR_VAR 0 1
22771: PUSH
22772: DOUBLE
22773: LD_INT 1
22775: DEC
22776: ST_TO_ADDR
22777: LD_INT 4
22779: PUSH
22780: FOR_TO
22781: IFFALSE 22922
// begin if IsInUnit ( tmp [ i ] ) then
22783: LD_VAR 0 3
22787: PUSH
22788: LD_VAR 0 1
22792: ARRAY
22793: PPUSH
22794: CALL_OW 310
22798: IFFALSE 22815
// ComExitBuilding ( tmp [ i ] ) ;
22800: LD_VAR 0 3
22804: PUSH
22805: LD_VAR 0 1
22809: ARRAY
22810: PPUSH
22811: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
22815: LD_VAR 0 3
22819: PUSH
22820: LD_VAR 0 1
22824: ARRAY
22825: PPUSH
22826: LD_VAR 0 10
22830: PUSH
22831: LD_INT 1
22833: ARRAY
22834: PPUSH
22835: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
22839: LD_VAR 0 3
22843: PUSH
22844: LD_VAR 0 1
22848: ARRAY
22849: PPUSH
22850: LD_INT 1
22852: PPUSH
22853: CALL_OW 183
// if emp_towers then
22857: LD_VAR 0 12
22861: IFFALSE 22920
// begin AddComExitBuilding ( tmp [ i ] ) ;
22863: LD_VAR 0 3
22867: PUSH
22868: LD_VAR 0 1
22872: ARRAY
22873: PPUSH
22874: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
22878: LD_VAR 0 3
22882: PUSH
22883: LD_VAR 0 1
22887: ARRAY
22888: PPUSH
22889: LD_VAR 0 12
22893: PUSH
22894: LD_INT 1
22896: ARRAY
22897: PPUSH
22898: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
22902: LD_ADDR_VAR 0 12
22906: PUSH
22907: LD_VAR 0 12
22911: PPUSH
22912: LD_INT 1
22914: PPUSH
22915: CALL_OW 3
22919: ST_TO_ADDR
// end ; end ;
22920: GO 22780
22922: POP
22923: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
22924: LD_ADDR_VAR 0 3
22928: PUSH
22929: LD_EXP 18
22933: PUSH
22934: LD_INT 1
22936: ARRAY
22937: PUSH
22938: LD_EXP 18
22942: PUSH
22943: LD_INT 2
22945: ARRAY
22946: ADD
22947: PPUSH
22948: LD_INT 26
22950: PUSH
22951: LD_INT 1
22953: PUSH
22954: EMPTY
22955: LIST
22956: LIST
22957: PPUSH
22958: CALL_OW 72
22962: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
22963: LD_ADDR_VAR 0 1
22967: PUSH
22968: LD_EXP 18
22972: PUSH
22973: LD_INT 2
22975: ARRAY
22976: PUSH
22977: FOR_IN
22978: IFFALSE 22996
// ComTurnUnit ( i , Powell ) ;
22980: LD_VAR 0 1
22984: PPUSH
22985: LD_EXP 59
22989: PPUSH
22990: CALL_OW 119
22994: GO 22977
22996: POP
22997: POP
// Say ( Powell , D5-Pow-1 ) ;
22998: LD_EXP 59
23002: PPUSH
23003: LD_STRING D5-Pow-1
23005: PPUSH
23006: CALL_OW 88
// if tmp then
23010: LD_VAR 0 3
23014: IFFALSE 23032
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
23016: LD_VAR 0 3
23020: PUSH
23021: LD_INT 1
23023: ARRAY
23024: PPUSH
23025: LD_STRING D5-Sol2-1
23027: PPUSH
23028: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
23032: LD_EXP 59
23036: PPUSH
23037: LD_STRING D5-Pow-2
23039: PPUSH
23040: CALL_OW 88
// if tmp > 1 then
23044: LD_VAR 0 3
23048: PUSH
23049: LD_INT 1
23051: GREATER
23052: IFFALSE 23070
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
23054: LD_VAR 0 3
23058: PUSH
23059: LD_INT 2
23061: ARRAY
23062: PPUSH
23063: LD_STRING D5-Sol2-2
23065: PPUSH
23066: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
23070: LD_EXP 59
23074: PPUSH
23075: LD_STRING D5-Pow-3
23077: PPUSH
23078: CALL_OW 88
// wait ( 0 0$1 ) ;
23082: LD_INT 35
23084: PPUSH
23085: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
23089: LD_ADDR_VAR 0 3
23093: PUSH
23094: LD_EXP 18
23098: PUSH
23099: LD_INT 1
23101: ARRAY
23102: PUSH
23103: LD_EXP 18
23107: PUSH
23108: LD_INT 2
23110: ARRAY
23111: UNION
23112: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
23113: LD_VAR 0 3
23117: PPUSH
23118: LD_INT 80
23120: PPUSH
23121: LD_INT 67
23123: PPUSH
23124: CALL_OW 114
// wait ( 0 0$2 ) ;
23128: LD_INT 70
23130: PPUSH
23131: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
23135: LD_INT 79
23137: PPUSH
23138: LD_INT 72
23140: PPUSH
23141: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
23145: LD_INT 70
23147: PPUSH
23148: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
23152: LD_VAR 0 3
23156: PPUSH
23157: LD_INT 3
23159: PUSH
23160: LD_INT 24
23162: PUSH
23163: LD_INT 1000
23165: PUSH
23166: EMPTY
23167: LIST
23168: LIST
23169: PUSH
23170: EMPTY
23171: LIST
23172: LIST
23173: PPUSH
23174: CALL_OW 72
23178: IFFALSE 23145
// Say ( Powell , D5a-Pow-1 ) ;
23180: LD_EXP 59
23184: PPUSH
23185: LD_STRING D5a-Pow-1
23187: PPUSH
23188: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
23192: LD_EXP 59
23196: PPUSH
23197: LD_STRING D5a-Pow-1a
23199: PPUSH
23200: CALL_OW 88
// wait ( 0 0$0.7 ) ;
23204: LD_INT 24
23206: PPUSH
23207: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
23211: LD_EXP 59
23215: PPUSH
23216: LD_STRING D5a-Pow-1b
23218: PPUSH
23219: CALL_OW 88
// wait ( 0 0$0.3 ) ;
23223: LD_INT 10
23225: PPUSH
23226: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
23230: LD_EXP 59
23234: PPUSH
23235: LD_STRING D5a-Pow-1c
23237: PPUSH
23238: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
23242: LD_VAR 0 3
23246: PPUSH
23247: LD_INT 68
23249: PPUSH
23250: LD_INT 63
23252: PPUSH
23253: CALL_OW 111
// wait ( 0 0$0.5 ) ;
23257: LD_INT 18
23259: PPUSH
23260: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
23264: LD_EXP 59
23268: PPUSH
23269: LD_STRING D5a-Pow-1d
23271: PPUSH
23272: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
23276: LD_INT 35
23278: PPUSH
23279: CALL_OW 67
// if not HasTask ( tmp ) then
23283: LD_VAR 0 3
23287: PPUSH
23288: CALL_OW 314
23292: NOT
23293: IFFALSE 23310
// ComAgressiveMove ( tmp , 68 , 63 ) ;
23295: LD_VAR 0 3
23299: PPUSH
23300: LD_INT 68
23302: PPUSH
23303: LD_INT 63
23305: PPUSH
23306: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
23310: LD_VAR 0 3
23314: PPUSH
23315: LD_INT 24
23317: PUSH
23318: LD_INT 1
23320: PUSH
23321: EMPTY
23322: LIST
23323: LIST
23324: PPUSH
23325: CALL_OW 72
23329: NOT
23330: IFFALSE 23276
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
23332: LD_ADDR_VAR 0 3
23336: PUSH
23337: LD_INT 22
23339: PUSH
23340: LD_INT 4
23342: PUSH
23343: EMPTY
23344: LIST
23345: LIST
23346: PUSH
23347: LD_INT 92
23349: PUSH
23350: LD_INT 60
23352: PUSH
23353: LD_INT 93
23355: PUSH
23356: LD_INT 10
23358: PUSH
23359: EMPTY
23360: LIST
23361: LIST
23362: LIST
23363: LIST
23364: PUSH
23365: LD_INT 3
23367: PUSH
23368: LD_INT 54
23370: PUSH
23371: EMPTY
23372: LIST
23373: PUSH
23374: EMPTY
23375: LIST
23376: LIST
23377: PUSH
23378: EMPTY
23379: LIST
23380: LIST
23381: LIST
23382: PPUSH
23383: CALL_OW 69
23387: PUSH
23388: LD_EXP 59
23392: DIFF
23393: ST_TO_ADDR
// if tmp then
23394: LD_VAR 0 3
23398: IFFALSE 23432
// for i in tmp do
23400: LD_ADDR_VAR 0 1
23404: PUSH
23405: LD_VAR 0 3
23409: PUSH
23410: FOR_IN
23411: IFFALSE 23430
// ComMoveXY ( i , 36 , 67 ) ;
23413: LD_VAR 0 1
23417: PPUSH
23418: LD_INT 36
23420: PPUSH
23421: LD_INT 67
23423: PPUSH
23424: CALL_OW 111
23428: GO 23410
23430: POP
23431: POP
// wait ( 0 0$3 ) ;
23432: LD_INT 105
23434: PPUSH
23435: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
23439: LD_VAR 0 11
23443: PPUSH
23444: LD_STRING D6-Sol3-1
23446: PPUSH
23447: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
23451: LD_EXP 59
23455: PPUSH
23456: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
23460: LD_EXP 59
23464: PPUSH
23465: LD_STRING D6-Pow-1
23467: PPUSH
23468: CALL_OW 88
// tmp := [ ] ;
23472: LD_ADDR_VAR 0 3
23476: PUSH
23477: EMPTY
23478: ST_TO_ADDR
// for i = 1 to 2 do
23479: LD_ADDR_VAR 0 1
23483: PUSH
23484: DOUBLE
23485: LD_INT 1
23487: DEC
23488: ST_TO_ADDR
23489: LD_INT 2
23491: PUSH
23492: FOR_TO
23493: IFFALSE 23607
// begin uc_side := 8 ;
23495: LD_ADDR_OWVAR 20
23499: PUSH
23500: LD_INT 8
23502: ST_TO_ADDR
// uc_nation := 2 ;
23503: LD_ADDR_OWVAR 21
23507: PUSH
23508: LD_INT 2
23510: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
23511: LD_INT 14
23513: PPUSH
23514: LD_INT 3
23516: PPUSH
23517: LD_INT 2
23519: PPUSH
23520: LD_INT 29
23522: PPUSH
23523: LD_INT 100
23525: PPUSH
23526: CALL 72249 0 5
// veh := CreateVehicle ;
23530: LD_ADDR_VAR 0 13
23534: PUSH
23535: CALL_OW 45
23539: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
23540: LD_VAR 0 13
23544: PPUSH
23545: LD_INT 4
23547: PPUSH
23548: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
23552: LD_VAR 0 13
23556: PPUSH
23557: LD_INT 99
23559: PPUSH
23560: LD_INT 83
23562: PPUSH
23563: LD_INT 3
23565: PPUSH
23566: LD_INT 0
23568: PPUSH
23569: CALL_OW 50
// wait ( 3 ) ;
23573: LD_INT 3
23575: PPUSH
23576: CALL_OW 67
// Connect ( veh ) ;
23580: LD_VAR 0 13
23584: PPUSH
23585: CALL 75340 0 1
// tmp := tmp ^ veh ;
23589: LD_ADDR_VAR 0 3
23593: PUSH
23594: LD_VAR 0 3
23598: PUSH
23599: LD_VAR 0 13
23603: ADD
23604: ST_TO_ADDR
// end ;
23605: GO 23492
23607: POP
23608: POP
// wait ( 0 0$1 ) ;
23609: LD_INT 35
23611: PPUSH
23612: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
23616: LD_INT 99
23618: PPUSH
23619: LD_INT 83
23621: PPUSH
23622: LD_INT 1
23624: PPUSH
23625: LD_INT 10
23627: PPUSH
23628: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
23632: LD_INT 99
23634: PPUSH
23635: LD_INT 83
23637: PPUSH
23638: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
23642: LD_VAR 0 11
23646: PPUSH
23647: LD_STRING D6-Sol3-2
23649: PPUSH
23650: CALL_OW 88
// async ;
23654: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
23655: LD_EXP 59
23659: PPUSH
23660: LD_STRING D6-Pow-2
23662: PPUSH
23663: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
23667: LD_VAR 0 3
23671: PUSH
23672: LD_INT 1
23674: ARRAY
23675: PPUSH
23676: LD_VAR 0 9
23680: PPUSH
23681: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
23685: LD_VAR 0 3
23689: PUSH
23690: LD_INT 2
23692: ARRAY
23693: PPUSH
23694: LD_INT 22
23696: PUSH
23697: LD_INT 4
23699: PUSH
23700: EMPTY
23701: LIST
23702: LIST
23703: PUSH
23704: LD_INT 21
23706: PUSH
23707: LD_INT 3
23709: PUSH
23710: EMPTY
23711: LIST
23712: LIST
23713: PUSH
23714: EMPTY
23715: LIST
23716: LIST
23717: PPUSH
23718: CALL_OW 69
23722: PPUSH
23723: LD_VAR 0 3
23727: PUSH
23728: LD_INT 2
23730: ARRAY
23731: PPUSH
23732: CALL_OW 74
23736: PPUSH
23737: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
23741: LD_EXP 59
23745: PPUSH
23746: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
23750: LD_INT 99
23752: PPUSH
23753: LD_INT 83
23755: PPUSH
23756: LD_INT 1
23758: PPUSH
23759: CALL_OW 331
// repeat wait ( 4 ) ;
23763: LD_INT 4
23765: PPUSH
23766: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
23770: LD_VAR 0 3
23774: PUSH
23775: LD_INT 1
23777: ARRAY
23778: PPUSH
23779: CALL_OW 256
23783: PUSH
23784: LD_INT 1000
23786: LESS
23787: IFFALSE 23805
// SetLives ( tmp [ 1 ] , 1000 ) ;
23789: LD_VAR 0 3
23793: PUSH
23794: LD_INT 1
23796: ARRAY
23797: PPUSH
23798: LD_INT 1000
23800: PPUSH
23801: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
23805: LD_INT 22
23807: PUSH
23808: LD_INT 4
23810: PUSH
23811: EMPTY
23812: LIST
23813: LIST
23814: PUSH
23815: LD_INT 30
23817: PUSH
23818: LD_INT 3
23820: PUSH
23821: EMPTY
23822: LIST
23823: LIST
23824: PUSH
23825: EMPTY
23826: LIST
23827: LIST
23828: PPUSH
23829: CALL_OW 69
23833: PUSH
23834: LD_INT 0
23836: EQUAL
23837: IFFALSE 23763
// skirmish := false ;
23839: LD_ADDR_EXP 97
23843: PUSH
23844: LD_INT 0
23846: ST_TO_ADDR
// sync ;
23847: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
23848: LD_EXP 59
23852: PPUSH
23853: LD_STRING D6a-Pow-1
23855: PPUSH
23856: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
23860: LD_VAR 0 11
23864: PPUSH
23865: LD_STRING D6a-Sol3-1
23867: PPUSH
23868: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
23872: LD_EXP 59
23876: PPUSH
23877: LD_STRING D6a-Pow-2
23879: PPUSH
23880: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
23884: LD_VAR 0 11
23888: PPUSH
23889: LD_STRING D6a-Sol3-2
23891: PPUSH
23892: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
23896: LD_EXP 59
23900: PPUSH
23901: LD_STRING D6a-Pow-3
23903: PPUSH
23904: CALL_OW 88
// powellCenterCameraMode := true ;
23908: LD_ADDR_EXP 20
23912: PUSH
23913: LD_INT 1
23915: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23916: LD_ADDR_VAR 0 1
23920: PUSH
23921: LD_INT 22
23923: PUSH
23924: LD_INT 8
23926: PUSH
23927: EMPTY
23928: LIST
23929: LIST
23930: PUSH
23931: LD_INT 25
23933: PUSH
23934: LD_INT 2
23936: PUSH
23937: EMPTY
23938: LIST
23939: LIST
23940: PUSH
23941: EMPTY
23942: LIST
23943: LIST
23944: PPUSH
23945: CALL_OW 69
23949: PUSH
23950: FOR_IN
23951: IFFALSE 24006
// begin SetTag ( i , 1 ) ;
23953: LD_VAR 0 1
23957: PPUSH
23958: LD_INT 1
23960: PPUSH
23961: CALL_OW 109
// ComExitBuilding ( i ) ;
23965: LD_VAR 0 1
23969: PPUSH
23970: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
23974: LD_VAR 0 1
23978: PPUSH
23979: LD_INT 35
23981: PPUSH
23982: LD_INT 6
23984: PPUSH
23985: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
23989: LD_VAR 0 1
23993: PPUSH
23994: LD_INT 53
23996: PPUSH
23997: LD_INT 4
23999: PPUSH
24000: CALL_OW 171
// end ;
24004: GO 23950
24006: POP
24007: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
24008: LD_ADDR_VAR 0 3
24012: PUSH
24013: LD_INT 22
24015: PUSH
24016: LD_INT 4
24018: PUSH
24019: EMPTY
24020: LIST
24021: LIST
24022: PUSH
24023: LD_INT 21
24025: PUSH
24026: LD_INT 2
24028: PUSH
24029: EMPTY
24030: LIST
24031: LIST
24032: PUSH
24033: LD_INT 3
24035: PUSH
24036: LD_INT 34
24038: PUSH
24039: LD_INT 12
24041: PUSH
24042: EMPTY
24043: LIST
24044: LIST
24045: PUSH
24046: EMPTY
24047: LIST
24048: LIST
24049: PUSH
24050: EMPTY
24051: LIST
24052: LIST
24053: LIST
24054: PPUSH
24055: CALL_OW 69
24059: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
24060: LD_EXP 59
24064: PPUSH
24065: LD_VAR 0 3
24069: PPUSH
24070: LD_EXP 59
24074: PPUSH
24075: CALL_OW 74
24079: PPUSH
24080: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
24084: LD_EXP 59
24088: PPUSH
24089: LD_INT 100
24091: PPUSH
24092: LD_INT 88
24094: PPUSH
24095: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
24099: LD_EXP 59
24103: PPUSH
24104: LD_INT 100
24106: PPUSH
24107: LD_INT 75
24109: PPUSH
24110: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
24114: LD_EXP 59
24118: PPUSH
24119: LD_INT 88
24121: PPUSH
24122: LD_INT 53
24124: PPUSH
24125: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
24129: LD_INT 8
24131: PPUSH
24132: LD_EXP 59
24136: PPUSH
24137: CALL_OW 471
// repeat wait ( 3 ) ;
24141: LD_INT 3
24143: PPUSH
24144: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
24148: LD_INT 22
24150: PUSH
24151: LD_INT 4
24153: PUSH
24154: EMPTY
24155: LIST
24156: LIST
24157: PUSH
24158: LD_INT 92
24160: PUSH
24161: LD_INT 100
24163: PUSH
24164: LD_INT 75
24166: PUSH
24167: LD_INT 6
24169: PUSH
24170: EMPTY
24171: LIST
24172: LIST
24173: LIST
24174: LIST
24175: PUSH
24176: EMPTY
24177: LIST
24178: LIST
24179: PPUSH
24180: CALL_OW 69
24184: IFFALSE 24141
// async ;
24186: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
24187: LD_EXP 59
24191: PPUSH
24192: LD_STRING D6b-Pow-1
24194: PPUSH
24195: CALL_OW 88
// repeat wait ( 3 ) ;
24199: LD_INT 3
24201: PPUSH
24202: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
24206: LD_EXP 59
24210: PPUSH
24211: CALL_OW 310
24215: PPUSH
24216: CALL_OW 256
24220: PUSH
24221: LD_INT 1000
24223: LESS
24224: IFFALSE 24243
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
24226: LD_EXP 59
24230: PPUSH
24231: CALL_OW 310
24235: PPUSH
24236: LD_INT 1000
24238: PPUSH
24239: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
24243: LD_EXP 59
24247: PPUSH
24248: CALL_OW 256
24252: PUSH
24253: LD_INT 1000
24255: LESS
24256: IFFALSE 24270
// SetLives ( Powell , 1000 ) ;
24258: LD_EXP 59
24262: PPUSH
24263: LD_INT 1000
24265: PPUSH
24266: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
24270: LD_EXP 59
24274: PPUSH
24275: LD_EXP 64
24279: PPUSH
24280: CALL_OW 296
24284: PUSH
24285: LD_INT 5
24287: LESS
24288: PUSH
24289: LD_EXP 59
24293: PPUSH
24294: CALL_OW 310
24298: PPUSH
24299: LD_EXP 64
24303: PPUSH
24304: CALL_OW 296
24308: PUSH
24309: LD_INT 5
24311: LESS
24312: OR
24313: IFFALSE 24332
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
24315: LD_EXP 59
24319: PPUSH
24320: CALL_OW 310
24324: PPUSH
24325: LD_INT 100
24327: PPUSH
24328: CALL_OW 234
// until not IsInUnit ( Powell ) ;
24332: LD_EXP 59
24336: PPUSH
24337: CALL_OW 310
24341: NOT
24342: IFFALSE 24199
// DoNotAttack ( 8 , powellBomb ) ;
24344: LD_INT 8
24346: PPUSH
24347: LD_EXP 64
24351: PPUSH
24352: CALL_OW 471
// game_speed := 4 ;
24356: LD_ADDR_OWVAR 65
24360: PUSH
24361: LD_INT 4
24363: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
24364: LD_EXP 59
24368: PPUSH
24369: LD_STRING D6b-Pow-1a
24371: PPUSH
24372: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
24376: LD_EXP 59
24380: PPUSH
24381: LD_EXP 64
24385: PPUSH
24386: CALL_OW 180
// sync ;
24390: SYNC
// repeat wait ( 0 0$1 ) ;
24391: LD_INT 35
24393: PPUSH
24394: CALL_OW 67
// until IsInUnit ( Powell ) ;
24398: LD_EXP 59
24402: PPUSH
24403: CALL_OW 310
24407: IFFALSE 24391
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
24409: LD_INT 8
24411: PPUSH
24412: LD_EXP 59
24416: PPUSH
24417: CALL_OW 310
24421: PPUSH
24422: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
24426: LD_EXP 59
24430: PPUSH
24431: LD_INT 91
24433: PPUSH
24434: LD_INT 44
24436: PPUSH
24437: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
24441: LD_EXP 59
24445: PPUSH
24446: LD_INT 96
24448: PPUSH
24449: LD_INT 44
24451: PPUSH
24452: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
24456: LD_EXP 59
24460: PPUSH
24461: LD_INT 96
24463: PPUSH
24464: LD_INT 41
24466: PPUSH
24467: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
24471: LD_EXP 59
24475: PPUSH
24476: LD_INT 92
24478: PPUSH
24479: LD_INT 39
24481: PPUSH
24482: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
24486: LD_EXP 59
24490: PPUSH
24491: LD_INT 88
24493: PPUSH
24494: LD_INT 41
24496: PPUSH
24497: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
24501: LD_EXP 59
24505: PPUSH
24506: LD_INT 91
24508: PPUSH
24509: LD_INT 44
24511: PPUSH
24512: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
24516: LD_EXP 59
24520: PPUSH
24521: LD_INT 96
24523: PPUSH
24524: LD_INT 44
24526: PPUSH
24527: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
24531: LD_EXP 59
24535: PPUSH
24536: LD_INT 96
24538: PPUSH
24539: LD_INT 41
24541: PPUSH
24542: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
24546: LD_EXP 59
24550: PPUSH
24551: LD_INT 92
24553: PPUSH
24554: LD_INT 39
24556: PPUSH
24557: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
24561: LD_EXP 59
24565: PPUSH
24566: LD_INT 88
24568: PPUSH
24569: LD_INT 41
24571: PPUSH
24572: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
24576: LD_EXP 59
24580: PPUSH
24581: LD_INT 91
24583: PPUSH
24584: LD_INT 44
24586: PPUSH
24587: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
24591: LD_EXP 59
24595: PPUSH
24596: LD_INT 93
24598: PPUSH
24599: LD_INT 39
24601: PPUSH
24602: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
24606: LD_EXP 59
24610: PPUSH
24611: LD_INT 93
24613: PPUSH
24614: LD_INT 36
24616: PPUSH
24617: CALL_OW 171
// wait ( 0 0$3.5 ) ;
24621: LD_INT 122
24623: PPUSH
24624: CALL_OW 67
// game_speed := 4 ;
24628: LD_ADDR_OWVAR 65
24632: PUSH
24633: LD_INT 4
24635: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
24636: LD_EXP 59
24640: PPUSH
24641: LD_STRING D6b-Pow-1b
24643: PPUSH
24644: CALL_OW 88
// tmp := [ ] ;
24648: LD_ADDR_VAR 0 3
24652: PUSH
24653: EMPTY
24654: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
24655: LD_ADDR_VAR 0 5
24659: PUSH
24660: LD_INT 78
24662: PUSH
24663: LD_INT 47
24665: PUSH
24666: EMPTY
24667: LIST
24668: LIST
24669: PUSH
24670: LD_INT 106
24672: PUSH
24673: LD_INT 53
24675: PUSH
24676: EMPTY
24677: LIST
24678: LIST
24679: PUSH
24680: EMPTY
24681: LIST
24682: LIST
24683: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
24684: LD_ADDR_VAR 0 1
24688: PUSH
24689: LD_INT 22
24691: PUSH
24692: LD_INT 8
24694: PUSH
24695: EMPTY
24696: LIST
24697: LIST
24698: PUSH
24699: LD_INT 21
24701: PUSH
24702: LD_INT 3
24704: PUSH
24705: EMPTY
24706: LIST
24707: LIST
24708: PUSH
24709: LD_INT 92
24711: PUSH
24712: LD_INT 90
24714: PUSH
24715: LD_INT 52
24717: PUSH
24718: LD_INT 12
24720: PUSH
24721: EMPTY
24722: LIST
24723: LIST
24724: LIST
24725: LIST
24726: PUSH
24727: EMPTY
24728: LIST
24729: LIST
24730: LIST
24731: PPUSH
24732: CALL_OW 69
24736: PUSH
24737: FOR_IN
24738: IFFALSE 24763
// tmp := tmp ^ UnitsInside ( i ) ;
24740: LD_ADDR_VAR 0 3
24744: PUSH
24745: LD_VAR 0 3
24749: PUSH
24750: LD_VAR 0 1
24754: PPUSH
24755: CALL_OW 313
24759: ADD
24760: ST_TO_ADDR
24761: GO 24737
24763: POP
24764: POP
// for i in tmp do
24765: LD_ADDR_VAR 0 1
24769: PUSH
24770: LD_VAR 0 3
24774: PUSH
24775: FOR_IN
24776: IFFALSE 24938
// begin dist := 9999 ;
24778: LD_ADDR_VAR 0 8
24782: PUSH
24783: LD_INT 9999
24785: ST_TO_ADDR
// _xy := [ ] ;
24786: LD_ADDR_VAR 0 7
24790: PUSH
24791: EMPTY
24792: ST_TO_ADDR
// SetTag ( i , 1 ) ;
24793: LD_VAR 0 1
24797: PPUSH
24798: LD_INT 1
24800: PPUSH
24801: CALL_OW 109
// ComExitBuilding ( i ) ;
24805: LD_VAR 0 1
24809: PPUSH
24810: CALL_OW 122
// for j in xy do
24814: LD_ADDR_VAR 0 2
24818: PUSH
24819: LD_VAR 0 5
24823: PUSH
24824: FOR_IN
24825: IFFALSE 24907
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
24827: LD_VAR 0 1
24831: PPUSH
24832: LD_VAR 0 2
24836: PUSH
24837: LD_INT 1
24839: ARRAY
24840: PPUSH
24841: LD_VAR 0 2
24845: PUSH
24846: LD_INT 2
24848: ARRAY
24849: PPUSH
24850: CALL_OW 297
24854: PUSH
24855: LD_VAR 0 8
24859: LESS
24860: IFFALSE 24905
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
24862: LD_ADDR_VAR 0 8
24866: PUSH
24867: LD_VAR 0 1
24871: PPUSH
24872: LD_VAR 0 2
24876: PUSH
24877: LD_INT 1
24879: ARRAY
24880: PPUSH
24881: LD_VAR 0 2
24885: PUSH
24886: LD_INT 2
24888: ARRAY
24889: PPUSH
24890: CALL_OW 297
24894: ST_TO_ADDR
// _xy := j ;
24895: LD_ADDR_VAR 0 7
24899: PUSH
24900: LD_VAR 0 2
24904: ST_TO_ADDR
// end ;
24905: GO 24824
24907: POP
24908: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
24909: LD_VAR 0 1
24913: PPUSH
24914: LD_VAR 0 7
24918: PUSH
24919: LD_INT 1
24921: ARRAY
24922: PPUSH
24923: LD_VAR 0 7
24927: PUSH
24928: LD_INT 2
24930: ARRAY
24931: PPUSH
24932: CALL_OW 171
// end ;
24936: GO 24775
24938: POP
24939: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
24940: LD_ADDR_VAR 0 4
24944: PUSH
24945: LD_VAR 0 3
24949: PPUSH
24950: LD_INT 26
24952: PUSH
24953: LD_INT 1
24955: PUSH
24956: EMPTY
24957: LIST
24958: LIST
24959: PUSH
24960: LD_INT 25
24962: PUSH
24963: LD_INT 1
24965: PUSH
24966: EMPTY
24967: LIST
24968: LIST
24969: PUSH
24970: EMPTY
24971: LIST
24972: LIST
24973: PPUSH
24974: CALL_OW 72
24978: ST_TO_ADDR
// if tmp2 < 2 then
24979: LD_VAR 0 4
24983: PUSH
24984: LD_INT 2
24986: LESS
24987: IFFALSE 25056
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
24989: LD_ADDR_VAR 0 4
24993: PUSH
24994: LD_INT 22
24996: PUSH
24997: LD_INT 8
24999: PUSH
25000: EMPTY
25001: LIST
25002: LIST
25003: PUSH
25004: LD_INT 26
25006: PUSH
25007: LD_INT 1
25009: PUSH
25010: EMPTY
25011: LIST
25012: LIST
25013: PUSH
25014: LD_INT 3
25016: PUSH
25017: LD_INT 25
25019: PUSH
25020: LD_INT 15
25022: PUSH
25023: EMPTY
25024: LIST
25025: LIST
25026: PUSH
25027: EMPTY
25028: LIST
25029: LIST
25030: PUSH
25031: EMPTY
25032: LIST
25033: LIST
25034: LIST
25035: PPUSH
25036: CALL_OW 69
25040: PUSH
25041: LD_EXP 61
25045: PUSH
25046: LD_EXP 62
25050: PUSH
25051: EMPTY
25052: LIST
25053: LIST
25054: DIFF
25055: ST_TO_ADDR
// if tmp2 then
25056: LD_VAR 0 4
25060: IFFALSE 25078
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
25062: LD_VAR 0 4
25066: PUSH
25067: LD_INT 1
25069: ARRAY
25070: PPUSH
25071: LD_STRING D6b-ArSol1-1
25073: PPUSH
25074: CALL_OW 88
// async ;
25078: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
25079: LD_EXP 59
25083: PPUSH
25084: LD_STRING D6b-Pow-2
25086: PPUSH
25087: CALL_OW 88
// wait ( 0 0$0.5 ) ;
25091: LD_INT 18
25093: PPUSH
25094: CALL_OW 67
// if tmp2 > 1 then
25098: LD_VAR 0 4
25102: PUSH
25103: LD_INT 1
25105: GREATER
25106: IFFALSE 25124
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
25108: LD_VAR 0 4
25112: PUSH
25113: LD_INT 2
25115: ARRAY
25116: PPUSH
25117: LD_STRING D6b-ArSol2-1
25119: PPUSH
25120: CALL_OW 88
// sync ;
25124: SYNC
// repeat wait ( 5 ) ;
25125: LD_INT 5
25127: PPUSH
25128: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
25132: LD_INT 93
25134: PPUSH
25135: LD_INT 36
25137: PPUSH
25138: CALL_OW 428
25142: PPUSH
25143: CALL_OW 255
25147: PUSH
25148: LD_INT 4
25150: EQUAL
25151: IFFALSE 25125
// DialogueOn ;
25153: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
25157: LD_INT 10
25159: PPUSH
25160: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
25164: LD_EXP 59
25168: PPUSH
25169: LD_STRING D6b-Pow-2a
25171: PPUSH
25172: CALL_OW 88
// DialogueOff ;
25176: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
25180: LD_EXP 59
25184: PPUSH
25185: CALL_OW 310
25189: PPUSH
25190: LD_INT 332
25192: PPUSH
25193: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
25197: LD_INT 93
25199: PPUSH
25200: LD_INT 35
25202: PPUSH
25203: LD_INT 1
25205: PPUSH
25206: LD_INT 6
25208: NEG
25209: PPUSH
25210: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
25214: LD_INT 35
25216: PPUSH
25217: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
25221: LD_INT 332
25223: PPUSH
25224: CALL_OW 256
25228: PUSH
25229: LD_INT 1000
25231: LESS
25232: PUSH
25233: LD_INT 332
25235: PPUSH
25236: CALL_OW 300
25240: AND
25241: IFFALSE 25253
// SetLives ( kozlov_fac , 0 ) ;
25243: LD_INT 332
25245: PPUSH
25246: LD_INT 0
25248: PPUSH
25249: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
25253: LD_INT 332
25255: PPUSH
25256: CALL_OW 301
25260: PUSH
25261: LD_EXP 59
25265: PPUSH
25266: CALL_OW 301
25270: OR
25271: IFFALSE 25214
// game_speed := 4 ;
25273: LD_ADDR_OWVAR 65
25277: PUSH
25278: LD_INT 4
25280: ST_TO_ADDR
// powellCenterCameraMode := false ;
25281: LD_ADDR_EXP 20
25285: PUSH
25286: LD_INT 0
25288: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
25289: LD_ADDR_VAR 0 1
25293: PUSH
25294: LD_VAR 0 3
25298: PUSH
25299: LD_INT 22
25301: PUSH
25302: LD_INT 8
25304: PUSH
25305: EMPTY
25306: LIST
25307: LIST
25308: PUSH
25309: LD_INT 25
25311: PUSH
25312: LD_INT 2
25314: PUSH
25315: EMPTY
25316: LIST
25317: LIST
25318: PUSH
25319: EMPTY
25320: LIST
25321: LIST
25322: PPUSH
25323: CALL_OW 69
25327: UNION
25328: PUSH
25329: FOR_IN
25330: IFFALSE 25346
// SetTag ( i , 0 ) ;
25332: LD_VAR 0 1
25336: PPUSH
25337: LD_INT 0
25339: PPUSH
25340: CALL_OW 109
25344: GO 25329
25346: POP
25347: POP
// wait ( 0 0$3 ) ;
25348: LD_INT 105
25350: PPUSH
25351: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
25355: LD_INT 93
25357: PPUSH
25358: LD_INT 35
25360: PPUSH
25361: LD_INT 1
25363: PPUSH
25364: CALL_OW 331
// DialogueOn ;
25368: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
25372: LD_VAR 0 11
25376: PPUSH
25377: LD_STRING D6c-Sol3-1
25379: PPUSH
25380: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
25384: LD_INT 10
25386: PPUSH
25387: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
25391: LD_EXP 40
25395: PPUSH
25396: LD_STRING D6c-JMM-1
25398: PPUSH
25399: CALL_OW 88
// if Cyrus then
25403: LD_EXP 46
25407: IFFALSE 25421
// Say ( Cyrus , D6c-Cyrus-1 ) ;
25409: LD_EXP 46
25413: PPUSH
25414: LD_STRING D6c-Cyrus-1
25416: PPUSH
25417: CALL_OW 88
// if Bobby then
25421: LD_EXP 45
25425: IFFALSE 25439
// Say ( Bobby , D6c-Bobby-1 ) ;
25427: LD_EXP 45
25431: PPUSH
25432: LD_STRING D6c-Bobby-1
25434: PPUSH
25435: CALL_OW 88
// if Cornel then
25439: LD_EXP 51
25443: IFFALSE 25457
// Say ( Cornel , D6c-Corn-1 ) ;
25445: LD_EXP 51
25449: PPUSH
25450: LD_STRING D6c-Corn-1
25452: PPUSH
25453: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
25457: LD_ADDR_VAR 0 4
25461: PUSH
25462: LD_INT 2
25464: PUSH
25465: LD_INT 22
25467: PUSH
25468: LD_INT 1
25470: PUSH
25471: EMPTY
25472: LIST
25473: LIST
25474: PUSH
25475: LD_INT 22
25477: PUSH
25478: LD_INT 4
25480: PUSH
25481: EMPTY
25482: LIST
25483: LIST
25484: PUSH
25485: EMPTY
25486: LIST
25487: LIST
25488: LIST
25489: PUSH
25490: LD_INT 26
25492: PUSH
25493: LD_INT 1
25495: PUSH
25496: EMPTY
25497: LIST
25498: LIST
25499: PUSH
25500: LD_INT 23
25502: PUSH
25503: LD_INT 1
25505: PUSH
25506: EMPTY
25507: LIST
25508: LIST
25509: PUSH
25510: EMPTY
25511: LIST
25512: LIST
25513: LIST
25514: PPUSH
25515: CALL_OW 69
25519: PUSH
25520: LD_VAR 0 11
25524: PUSH
25525: LD_EXP 40
25529: UNION
25530: PUSH
25531: LD_EXP 60
25535: UNION
25536: DIFF
25537: ST_TO_ADDR
// if tmp2 then
25538: LD_VAR 0 4
25542: IFFALSE 25560
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
25544: LD_VAR 0 4
25548: PUSH
25549: LD_INT 1
25551: ARRAY
25552: PPUSH
25553: LD_STRING D6c-Sol1-1
25555: PPUSH
25556: CALL_OW 88
// if Lisa then
25560: LD_EXP 43
25564: IFFALSE 25578
// Say ( Lisa , D6c-Lisa-1 ) ;
25566: LD_EXP 43
25570: PPUSH
25571: LD_STRING D6c-Lisa-1
25573: PPUSH
25574: CALL_OW 88
// if Gary then
25578: LD_EXP 52
25582: IFFALSE 25596
// Say ( Gary , D6c-Gary-1 ) ;
25584: LD_EXP 52
25588: PPUSH
25589: LD_STRING D6c-Gary-1
25591: PPUSH
25592: CALL_OW 88
// if Donaldson then
25596: LD_EXP 44
25600: IFFALSE 25614
// Say ( Donaldson , D6c-Don-1 ) ;
25602: LD_EXP 44
25606: PPUSH
25607: LD_STRING D6c-Don-1
25609: PPUSH
25610: CALL_OW 88
// if tmp2 > 1 then
25614: LD_VAR 0 4
25618: PUSH
25619: LD_INT 1
25621: GREATER
25622: IFFALSE 25640
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
25624: LD_VAR 0 4
25628: PUSH
25629: LD_INT 2
25631: ARRAY
25632: PPUSH
25633: LD_STRING D6c-Sol2-1
25635: PPUSH
25636: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
25640: LD_VAR 0 11
25644: PPUSH
25645: LD_STRING D6c-Sol3-2
25647: PPUSH
25648: CALL_OW 88
// if IsInUnit ( JMM ) then
25652: LD_EXP 40
25656: PPUSH
25657: CALL_OW 310
25661: IFFALSE 25679
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
25663: LD_EXP 40
25667: PPUSH
25668: CALL_OW 310
25672: PPUSH
25673: CALL_OW 87
25677: GO 25688
// CenterNowOnUnits ( JMM ) ;
25679: LD_EXP 40
25683: PPUSH
25684: CALL_OW 87
// dwait ( 0 0$2 ) ;
25688: LD_INT 70
25690: PPUSH
25691: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
25695: LD_EXP 40
25699: PPUSH
25700: LD_STRING D6c-JMM-2
25702: PPUSH
25703: CALL_OW 88
// DialogueOff ;
25707: CALL_OW 7
// Video ( false ) ;
25711: LD_INT 0
25713: PPUSH
25714: CALL 104655 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
25718: LD_INT 22
25720: PUSH
25721: LD_INT 4
25723: PUSH
25724: EMPTY
25725: LIST
25726: LIST
25727: PPUSH
25728: CALL_OW 69
25732: PPUSH
25733: LD_INT 1
25735: PPUSH
25736: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
25740: LD_INT 4
25742: PPUSH
25743: LD_INT 4
25745: PPUSH
25746: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
25750: LD_ADDR_VAR 0 1
25754: PUSH
25755: LD_INT 4
25757: PPUSH
25758: LD_INT 1
25760: PPUSH
25761: LD_INT 2
25763: PPUSH
25764: CALL 67297 0 3
25768: PUSH
25769: FOR_IN
25770: IFFALSE 25807
// if GetTech ( i , 1 ) <> state_researched then
25772: LD_VAR 0 1
25776: PPUSH
25777: LD_INT 1
25779: PPUSH
25780: CALL_OW 321
25784: PUSH
25785: LD_INT 2
25787: NONEQUAL
25788: IFFALSE 25805
// SetTech ( i , 1 , state_researched ) ;
25790: LD_VAR 0 1
25794: PPUSH
25795: LD_INT 1
25797: PPUSH
25798: LD_INT 2
25800: PPUSH
25801: CALL_OW 322
25805: GO 25769
25807: POP
25808: POP
// missionStage := 6 ;
25809: LD_ADDR_EXP 15
25813: PUSH
25814: LD_INT 6
25816: ST_TO_ADDR
// activeAttacks := true ;
25817: LD_ADDR_EXP 16
25821: PUSH
25822: LD_INT 1
25824: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
25825: LD_STRING M2
25827: PPUSH
25828: CALL_OW 337
// SaveForQuickRestart ;
25832: CALL_OW 22
// wait ( 0 0$40 ) ;
25836: LD_INT 1400
25838: PPUSH
25839: CALL_OW 67
// DialogueOn ;
25843: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
25847: LD_EXP 63
25851: PPUSH
25852: LD_STRING D7-Friend-1
25854: PPUSH
25855: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
25859: LD_EXP 40
25863: PPUSH
25864: LD_STRING D7-JMM-1
25866: PPUSH
25867: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
25871: LD_EXP 63
25875: PPUSH
25876: LD_STRING D7-Friend-2
25878: PPUSH
25879: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
25883: LD_EXP 40
25887: PPUSH
25888: LD_STRING D7-JMM-2
25890: PPUSH
25891: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
25895: LD_EXP 63
25899: PPUSH
25900: LD_STRING D7-Friend-3
25902: PPUSH
25903: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
25907: LD_EXP 40
25911: PPUSH
25912: LD_STRING D7-JMM-3
25914: PPUSH
25915: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
25919: LD_EXP 63
25923: PPUSH
25924: LD_STRING D7-Friend-4
25926: PPUSH
25927: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
25931: LD_EXP 40
25935: PPUSH
25936: LD_STRING D7-JMM-4
25938: PPUSH
25939: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
25943: LD_EXP 63
25947: PPUSH
25948: LD_STRING D7-Friend-5
25950: PPUSH
25951: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
25955: LD_EXP 40
25959: PPUSH
25960: LD_STRING D7-JMM-5
25962: PPUSH
25963: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
25967: LD_EXP 63
25971: PPUSH
25972: LD_STRING D7-Friend-6
25974: PPUSH
25975: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
25979: LD_EXP 40
25983: PPUSH
25984: LD_STRING D7-JMM-6
25986: PPUSH
25987: CALL_OW 88
// DialogueOff ;
25991: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
25995: LD_STRING Mlegion
25997: PPUSH
25998: CALL_OW 337
// skirmish := true ;
26002: LD_ADDR_EXP 97
26006: PUSH
26007: LD_INT 1
26009: ST_TO_ADDR
// RebuildKozlovFactory ;
26010: CALL 5016 0 0
// end ;
26014: PPOPN 13
26016: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
26017: LD_EXP 20
26021: PUSH
26022: LD_EXP 59
26026: PPUSH
26027: CALL_OW 300
26031: AND
26032: IFFALSE 26074
26034: GO 26036
26036: DISABLE
// begin enable ;
26037: ENABLE
// if IsInUnit ( Powell ) then
26038: LD_EXP 59
26042: PPUSH
26043: CALL_OW 310
26047: IFFALSE 26065
// CenterOnUnits ( IsInUnit ( Powell ) ) else
26049: LD_EXP 59
26053: PPUSH
26054: CALL_OW 310
26058: PPUSH
26059: CALL_OW 85
26063: GO 26074
// CenterOnUnits ( Powell ) ;
26065: LD_EXP 59
26069: PPUSH
26070: CALL_OW 85
// end ;
26074: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
26075: LD_INT 22
26077: PUSH
26078: LD_INT 8
26080: PUSH
26081: EMPTY
26082: LIST
26083: LIST
26084: PUSH
26085: LD_INT 34
26087: PUSH
26088: LD_INT 48
26090: PUSH
26091: EMPTY
26092: LIST
26093: LIST
26094: PUSH
26095: EMPTY
26096: LIST
26097: LIST
26098: PPUSH
26099: CALL_OW 69
26103: IFFALSE 26377
26105: GO 26107
26107: DISABLE
26108: LD_INT 0
26110: PPUSH
26111: PPUSH
// begin if missionStage < 9 then
26112: LD_EXP 15
26116: PUSH
26117: LD_INT 9
26119: LESS
26120: IFFALSE 26130
// missionStage := 9 ;
26122: LD_ADDR_EXP 15
26126: PUSH
26127: LD_INT 9
26129: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
26130: LD_ADDR_VAR 0 1
26134: PUSH
26135: LD_INT 22
26137: PUSH
26138: LD_INT 8
26140: PUSH
26141: EMPTY
26142: LIST
26143: LIST
26144: PUSH
26145: LD_INT 34
26147: PUSH
26148: LD_INT 48
26150: PUSH
26151: EMPTY
26152: LIST
26153: LIST
26154: PUSH
26155: EMPTY
26156: LIST
26157: LIST
26158: PPUSH
26159: CALL_OW 69
26163: PUSH
26164: LD_INT 1
26166: ARRAY
26167: ST_TO_ADDR
// wait ( 0 0$05 ) ;
26168: LD_INT 175
26170: PPUSH
26171: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
26175: LD_EXP 12
26179: PUSH
26180: LD_EXP 3
26184: PUSH
26185: LD_INT 0
26187: PUSH
26188: LD_INT 2
26190: PUSH
26191: EMPTY
26192: LIST
26193: LIST
26194: IN
26195: OR
26196: IFFALSE 26219
// target := [ 68 , 108 , 1 ] else
26198: LD_ADDR_VAR 0 2
26202: PUSH
26203: LD_INT 68
26205: PUSH
26206: LD_INT 108
26208: PUSH
26209: LD_INT 1
26211: PUSH
26212: EMPTY
26213: LIST
26214: LIST
26215: LIST
26216: ST_TO_ADDR
26217: GO 26238
// target := [ 181 , 88 , 2 ] ;
26219: LD_ADDR_VAR 0 2
26223: PUSH
26224: LD_INT 181
26226: PUSH
26227: LD_INT 88
26229: PUSH
26230: LD_INT 2
26232: PUSH
26233: EMPTY
26234: LIST
26235: LIST
26236: LIST
26237: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
26238: LD_VAR 0 1
26242: PPUSH
26243: LD_VAR 0 2
26247: PUSH
26248: LD_INT 1
26250: ARRAY
26251: PPUSH
26252: LD_VAR 0 2
26256: PUSH
26257: LD_INT 2
26259: ARRAY
26260: PPUSH
26261: CALL_OW 176
// if target [ 3 ] = 1 then
26265: LD_VAR 0 2
26269: PUSH
26270: LD_INT 3
26272: ARRAY
26273: PUSH
26274: LD_INT 1
26276: EQUAL
26277: IFFALSE 26293
// SayRadio ( Kurt , D12-Kurt-1 ) else
26279: LD_EXP 61
26283: PPUSH
26284: LD_STRING D12-Kurt-1
26286: PPUSH
26287: CALL_OW 94
26291: GO 26317
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
26293: LD_EXP 61
26297: PPUSH
26298: LD_STRING D12a-Kurt-1
26300: PPUSH
26301: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
26305: LD_EXP 76
26309: PPUSH
26310: LD_STRING D12a-Roth-1
26312: PPUSH
26313: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
26317: LD_INT 350
26319: PPUSH
26320: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
26324: LD_VAR 0 1
26328: PPUSH
26329: LD_INT 22
26331: PUSH
26332: LD_INT 8
26334: PUSH
26335: EMPTY
26336: LIST
26337: LIST
26338: PUSH
26339: LD_INT 23
26341: PUSH
26342: LD_INT 2
26344: PUSH
26345: EMPTY
26346: LIST
26347: LIST
26348: PUSH
26349: LD_INT 30
26351: PUSH
26352: LD_INT 3
26354: PUSH
26355: EMPTY
26356: LIST
26357: LIST
26358: PUSH
26359: EMPTY
26360: LIST
26361: LIST
26362: LIST
26363: PPUSH
26364: CALL_OW 69
26368: PUSH
26369: LD_INT 1
26371: ARRAY
26372: PPUSH
26373: CALL_OW 228
// end ;
26377: PPOPN 2
26379: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
26380: LD_EXP 61
26384: PPUSH
26385: CALL_OW 256
26389: PUSH
26390: LD_INT 999
26392: LESS
26393: PUSH
26394: LD_INT 22
26396: PUSH
26397: LD_INT 8
26399: PUSH
26400: EMPTY
26401: LIST
26402: LIST
26403: PUSH
26404: LD_INT 21
26406: PUSH
26407: LD_INT 1
26409: PUSH
26410: EMPTY
26411: LIST
26412: LIST
26413: PUSH
26414: LD_INT 23
26416: PUSH
26417: LD_INT 2
26419: PUSH
26420: EMPTY
26421: LIST
26422: LIST
26423: PUSH
26424: EMPTY
26425: LIST
26426: LIST
26427: LIST
26428: PPUSH
26429: CALL_OW 69
26433: PUSH
26434: LD_INT 9
26436: PUSH
26437: LD_INT 8
26439: PUSH
26440: LD_INT 7
26442: PUSH
26443: LD_INT 6
26445: PUSH
26446: EMPTY
26447: LIST
26448: LIST
26449: LIST
26450: LIST
26451: PUSH
26452: LD_OWVAR 67
26456: ARRAY
26457: LESSEQUAL
26458: OR
26459: PUSH
26460: LD_INT 22
26462: PUSH
26463: LD_INT 8
26465: PUSH
26466: EMPTY
26467: LIST
26468: LIST
26469: PUSH
26470: LD_INT 34
26472: PUSH
26473: LD_INT 48
26475: PUSH
26476: EMPTY
26477: LIST
26478: LIST
26479: PUSH
26480: EMPTY
26481: LIST
26482: LIST
26483: PPUSH
26484: CALL_OW 69
26488: NOT
26489: AND
26490: PUSH
26491: LD_EXP 61
26495: PPUSH
26496: CALL_OW 302
26500: AND
26501: PUSH
26502: LD_INT 5
26504: PPUSH
26505: LD_INT 22
26507: PUSH
26508: LD_INT 1
26510: PUSH
26511: EMPTY
26512: LIST
26513: LIST
26514: PPUSH
26515: CALL_OW 70
26519: AND
26520: IFFALSE 27225
26522: GO 26524
26524: DISABLE
26525: LD_INT 0
26527: PPUSH
26528: PPUSH
26529: PPUSH
// begin legionDestroyed := true ;
26530: LD_ADDR_EXP 22
26534: PUSH
26535: LD_INT 1
26537: ST_TO_ADDR
// DialogueOn ;
26538: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
26542: LD_EXP 40
26546: PPUSH
26547: LD_STRING D13-JMM-1
26549: PPUSH
26550: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
26554: LD_EXP 61
26558: PPUSH
26559: LD_STRING D13-Kurt-1
26561: PPUSH
26562: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
26566: LD_EXP 40
26570: PPUSH
26571: LD_STRING D13-JMM-2
26573: PPUSH
26574: CALL_OW 88
// if FakeInfo then
26578: LD_EXP 12
26582: IFFALSE 26602
// begin Say ( Kurt , D13-Kurt-2 ) ;
26584: LD_EXP 61
26588: PPUSH
26589: LD_STRING D13-Kurt-2
26591: PPUSH
26592: CALL_OW 88
// DialogueOff ;
26596: CALL_OW 7
// exit ;
26600: GO 27225
// end ; if not KurtStatus then
26602: LD_EXP 3
26606: NOT
26607: IFFALSE 26623
// Say ( Kurt , D13-Kurt-2b ) else
26609: LD_EXP 61
26613: PPUSH
26614: LD_STRING D13-Kurt-2b
26616: PPUSH
26617: CALL_OW 88
26621: GO 26635
// Say ( Kurt , D13-Kurt-2a ) ;
26623: LD_EXP 61
26627: PPUSH
26628: LD_STRING D13-Kurt-2a
26630: PPUSH
26631: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
26635: LD_EXP 40
26639: PPUSH
26640: LD_STRING D13-JMM-3
26642: PPUSH
26643: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
26647: LD_EXP 61
26651: PPUSH
26652: LD_STRING D13-Kurt-3
26654: PPUSH
26655: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
26659: LD_EXP 40
26663: PPUSH
26664: LD_STRING D13-JMM-4
26666: PPUSH
26667: CALL_OW 88
// DialogueOff ;
26671: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
26675: LD_STRING MlegionOut
26677: PPUSH
26678: CALL_OW 337
// MC_Kill ( 3 ) ;
26682: LD_INT 3
26684: PPUSH
26685: CALL 36819 0 1
// KillUnit ( Kozlov ) ;
26689: LD_EXP 62
26693: PPUSH
26694: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
26698: LD_ADDR_VAR 0 1
26702: PUSH
26703: LD_INT 22
26705: PUSH
26706: LD_INT 8
26708: PUSH
26709: EMPTY
26710: LIST
26711: LIST
26712: PUSH
26713: LD_INT 23
26715: PUSH
26716: LD_INT 3
26718: PUSH
26719: EMPTY
26720: LIST
26721: LIST
26722: PUSH
26723: LD_INT 3
26725: PUSH
26726: LD_INT 21
26728: PUSH
26729: LD_INT 33
26731: PUSH
26732: EMPTY
26733: LIST
26734: LIST
26735: PUSH
26736: EMPTY
26737: LIST
26738: LIST
26739: PUSH
26740: EMPTY
26741: LIST
26742: LIST
26743: LIST
26744: PPUSH
26745: CALL_OW 69
26749: PUSH
26750: FOR_IN
26751: IFFALSE 26764
// KillUnit ( i ) ;
26753: LD_VAR 0 1
26757: PPUSH
26758: CALL_OW 66
26762: GO 26750
26764: POP
26765: POP
// ChangeSideFog ( 8 , 1 ) ;
26766: LD_INT 8
26768: PPUSH
26769: LD_INT 1
26771: PPUSH
26772: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
26776: LD_ADDR_VAR 0 2
26780: PUSH
26781: LD_INT 22
26783: PUSH
26784: LD_INT 8
26786: PUSH
26787: EMPTY
26788: LIST
26789: LIST
26790: PUSH
26791: LD_INT 21
26793: PUSH
26794: LD_INT 1
26796: PUSH
26797: EMPTY
26798: LIST
26799: LIST
26800: PUSH
26801: EMPTY
26802: LIST
26803: LIST
26804: PPUSH
26805: CALL_OW 69
26809: PUSH
26810: LD_EXP 62
26814: PUSH
26815: LD_EXP 61
26819: PUSH
26820: EMPTY
26821: LIST
26822: LIST
26823: DIFF
26824: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
26825: LD_VAR 0 2
26829: PUSH
26830: LD_INT 6
26832: PUSH
26833: LD_INT 5
26835: PUSH
26836: LD_INT 4
26838: PUSH
26839: LD_INT 3
26841: PUSH
26842: EMPTY
26843: LIST
26844: LIST
26845: LIST
26846: LIST
26847: PUSH
26848: LD_OWVAR 67
26852: ARRAY
26853: GREATEREQUAL
26854: IFFALSE 27006
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
26856: LD_ADDR_VAR 0 3
26860: PUSH
26861: LD_INT 6
26863: PUSH
26864: LD_INT 5
26866: PUSH
26867: LD_INT 4
26869: PUSH
26870: LD_INT 3
26872: PUSH
26873: EMPTY
26874: LIST
26875: LIST
26876: LIST
26877: LIST
26878: PUSH
26879: LD_OWVAR 67
26883: ARRAY
26884: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
26885: LD_ADDR_VAR 0 1
26889: PUSH
26890: DOUBLE
26891: LD_VAR 0 2
26895: PUSH
26896: LD_VAR 0 3
26900: PUSH
26901: LD_INT 1
26903: PLUS
26904: MINUS
26905: INC
26906: ST_TO_ADDR
26907: LD_INT 1
26909: PUSH
26910: FOR_DOWNTO
26911: IFFALSE 27002
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
26913: LD_ADDR_EXP 38
26917: PUSH
26918: LD_EXP 38
26922: PUSH
26923: LD_VAR 0 2
26927: PUSH
26928: LD_VAR 0 1
26932: ARRAY
26933: ADD
26934: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
26935: LD_VAR 0 2
26939: PUSH
26940: LD_VAR 0 1
26944: ARRAY
26945: PPUSH
26946: CALL_OW 310
26950: IFFALSE 26967
// ComExit ( tmp [ i ] ) ;
26952: LD_VAR 0 2
26956: PUSH
26957: LD_VAR 0 1
26961: ARRAY
26962: PPUSH
26963: CALL 105081 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
26967: LD_VAR 0 2
26971: PUSH
26972: LD_VAR 0 1
26976: ARRAY
26977: PPUSH
26978: LD_INT 34
26980: PUSH
26981: LD_INT 0
26983: PPUSH
26984: LD_INT 6
26986: PPUSH
26987: CALL_OW 12
26991: PLUS
26992: PPUSH
26993: LD_INT 1
26995: PPUSH
26996: CALL_OW 171
// end ;
27000: GO 26910
27002: POP
27003: POP
// end else
27004: GO 27016
// x := tmp ;
27006: LD_ADDR_VAR 0 3
27010: PUSH
27011: LD_VAR 0 2
27015: ST_TO_ADDR
// for i := tmp downto tmp - x do
27016: LD_ADDR_VAR 0 1
27020: PUSH
27021: DOUBLE
27022: LD_VAR 0 2
27026: INC
27027: ST_TO_ADDR
27028: LD_VAR 0 2
27032: PUSH
27033: LD_VAR 0 3
27037: MINUS
27038: PUSH
27039: FOR_DOWNTO
27040: IFFALSE 27094
// begin if IsInUnit ( tmp [ i ] ) then
27042: LD_VAR 0 2
27046: PUSH
27047: LD_VAR 0 1
27051: ARRAY
27052: PPUSH
27053: CALL_OW 310
27057: IFFALSE 27074
// ComExit ( tmp [ i ] ) ;
27059: LD_VAR 0 2
27063: PUSH
27064: LD_VAR 0 1
27068: ARRAY
27069: PPUSH
27070: CALL 105081 0 1
// SetSide ( tmp [ i ] , 1 ) ;
27074: LD_VAR 0 2
27078: PUSH
27079: LD_VAR 0 1
27083: ARRAY
27084: PPUSH
27085: LD_INT 1
27087: PPUSH
27088: CALL_OW 235
// end ;
27092: GO 27039
27094: POP
27095: POP
// SetSide ( Kurt , 1 ) ;
27096: LD_EXP 61
27100: PPUSH
27101: LD_INT 1
27103: PPUSH
27104: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_building ] , [ f_type , unit_vehicle ] ] ] ) , 1 ) ;
27108: LD_INT 22
27110: PUSH
27111: LD_INT 8
27113: PUSH
27114: EMPTY
27115: LIST
27116: LIST
27117: PUSH
27118: LD_INT 2
27120: PUSH
27121: LD_INT 21
27123: PUSH
27124: LD_INT 3
27126: PUSH
27127: EMPTY
27128: LIST
27129: LIST
27130: PUSH
27131: LD_INT 21
27133: PUSH
27134: LD_INT 2
27136: PUSH
27137: EMPTY
27138: LIST
27139: LIST
27140: PUSH
27141: EMPTY
27142: LIST
27143: LIST
27144: LIST
27145: PUSH
27146: EMPTY
27147: LIST
27148: LIST
27149: PPUSH
27150: CALL_OW 69
27154: PPUSH
27155: LD_INT 1
27157: PPUSH
27158: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
27162: LD_INT 8
27164: PPUSH
27165: LD_INT 1
27167: PPUSH
27168: LD_INT 1
27170: PPUSH
27171: LD_INT 1
27173: PPUSH
27174: CALL_OW 80
// wait ( 1 1$20 ) ;
27178: LD_INT 2800
27180: PPUSH
27181: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
27185: LD_EXP 63
27189: PPUSH
27190: LD_INT 37
27192: PPUSH
27193: LD_INT 1
27195: PPUSH
27196: LD_INT 0
27198: PPUSH
27199: CALL_OW 48
// wait ( 0 0$1 ) ;
27203: LD_INT 35
27205: PPUSH
27206: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
27210: LD_EXP 63
27214: PPUSH
27215: LD_INT 60
27217: PPUSH
27218: LD_INT 95
27220: PPUSH
27221: CALL_OW 111
// end ;
27225: PPOPN 3
27227: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
27228: LD_EXP 22
27232: NOT
27233: PUSH
27234: LD_INT 22
27236: PUSH
27237: LD_INT 8
27239: PUSH
27240: EMPTY
27241: LIST
27242: LIST
27243: PUSH
27244: LD_INT 21
27246: PUSH
27247: LD_INT 1
27249: PUSH
27250: EMPTY
27251: LIST
27252: LIST
27253: PUSH
27254: EMPTY
27255: LIST
27256: LIST
27257: PPUSH
27258: CALL_OW 69
27262: PUSH
27263: LD_INT 0
27265: EQUAL
27266: AND
27267: IFFALSE 27287
27269: GO 27271
27271: DISABLE
// begin legionDestroyed := true ;
27272: LD_ADDR_EXP 22
27276: PUSH
27277: LD_INT 1
27279: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
27280: LD_STRING MlegionOut
27282: PPUSH
27283: CALL_OW 337
// end ;
27287: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
27288: LD_EXP 38
27292: IFFALSE 27367
27294: GO 27296
27296: DISABLE
27297: LD_INT 0
27299: PPUSH
// begin enable ;
27300: ENABLE
// for i in legionEscapeUnits do
27301: LD_ADDR_VAR 0 1
27305: PUSH
27306: LD_EXP 38
27310: PUSH
27311: FOR_IN
27312: IFFALSE 27365
// begin if IsInArea ( i , legionEscapeArea ) then
27314: LD_VAR 0 1
27318: PPUSH
27319: LD_INT 31
27321: PPUSH
27322: CALL_OW 308
27326: IFFALSE 27339
// RemoveUnit ( i ) else
27328: LD_VAR 0 1
27332: PPUSH
27333: CALL_OW 64
27337: GO 27363
// if not HasTask ( i ) then
27339: LD_VAR 0 1
27343: PPUSH
27344: CALL_OW 314
27348: NOT
27349: IFFALSE 27363
// ComMoveToArea ( i , legionEscapeArea ) ;
27351: LD_VAR 0 1
27355: PPUSH
27356: LD_INT 31
27358: PPUSH
27359: CALL_OW 113
// end ;
27363: GO 27311
27365: POP
27366: POP
// end ;
27367: PPOPN 1
27369: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
27370: LD_INT 1
27372: PPUSH
27373: LD_EXP 63
27377: PPUSH
27378: CALL_OW 292
27382: IFFALSE 27680
27384: GO 27386
27386: DISABLE
27387: LD_INT 0
27389: PPUSH
// begin wait ( 0 0$2 ) ;
27390: LD_INT 70
27392: PPUSH
27393: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27397: LD_EXP 63
27401: PPUSH
27402: CALL_OW 87
// DialogueOn ;
27406: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
27410: LD_EXP 40
27414: PPUSH
27415: LD_STRING D14-JMM-1
27417: PPUSH
27418: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
27422: LD_EXP 63
27426: PPUSH
27427: LD_STRING D14-Friend-1
27429: PPUSH
27430: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
27434: LD_EXP 40
27438: PPUSH
27439: LD_STRING D14-JMM-2
27441: PPUSH
27442: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
27446: LD_EXP 63
27450: PPUSH
27451: LD_STRING D14-Friend-2
27453: PPUSH
27454: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
27458: LD_EXP 40
27462: PPUSH
27463: LD_STRING D14-JMM-3
27465: PPUSH
27466: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
27470: LD_EXP 63
27474: PPUSH
27475: LD_STRING D14-Friend-3
27477: PPUSH
27478: CALL_OW 88
// DialogueOff ;
27482: CALL_OW 7
// dec = Query ( Q14 ) ;
27486: LD_ADDR_VAR 0 1
27490: PUSH
27491: LD_STRING Q14
27493: PPUSH
27494: CALL_OW 97
27498: ST_TO_ADDR
// if dec = 1 then
27499: LD_VAR 0 1
27503: PUSH
27504: LD_INT 1
27506: EQUAL
27507: IFFALSE 27541
// begin DialogueOn ;
27509: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
27513: LD_EXP 40
27517: PPUSH
27518: LD_STRING D14a-JMM-1
27520: PPUSH
27521: CALL_OW 88
// DialogueOff ;
27525: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27529: LD_EXP 63
27533: PPUSH
27534: LD_INT 1
27536: PPUSH
27537: CALL_OW 235
// end ; if dec = 2 then
27541: LD_VAR 0 1
27545: PUSH
27546: LD_INT 2
27548: EQUAL
27549: IFFALSE 27602
// begin DialogueOn ;
27551: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
27555: LD_EXP 40
27559: PPUSH
27560: LD_STRING D14b-JMM-1
27562: PPUSH
27563: CALL_OW 88
// DialogueOff ;
27567: CALL_OW 7
// wait ( 0 0$1 ) ;
27571: LD_INT 35
27573: PPUSH
27574: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
27578: LD_EXP 63
27582: PPUSH
27583: LD_INT 9
27585: PPUSH
27586: LD_INT 2
27588: PPUSH
27589: CALL_OW 111
// AddComHold ( Friend ) ;
27593: LD_EXP 63
27597: PPUSH
27598: CALL_OW 200
// end ; if dec = 3 then
27602: LD_VAR 0 1
27606: PUSH
27607: LD_INT 3
27609: EQUAL
27610: IFFALSE 27680
// begin DialogueOn ;
27612: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
27616: LD_EXP 40
27620: PPUSH
27621: LD_STRING D14c-JMM-1
27623: PPUSH
27624: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
27628: LD_EXP 63
27632: PPUSH
27633: LD_STRING D14c-Friend-1
27635: PPUSH
27636: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
27640: LD_EXP 40
27644: PPUSH
27645: LD_STRING D14c-JMM-2
27647: PPUSH
27648: CALL_OW 88
// DialogueOff ;
27652: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
27656: LD_EXP 63
27660: PPUSH
27661: LD_INT 9
27663: PPUSH
27664: LD_INT 2
27666: PPUSH
27667: CALL_OW 111
// AddComHold ( Friend ) ;
27671: LD_EXP 63
27675: PPUSH
27676: CALL_OW 200
// end ; end ;
27680: PPOPN 1
27682: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
27683: LD_INT 9
27685: PPUSH
27686: LD_INT 2
27688: PPUSH
27689: CALL_OW 428
27693: PUSH
27694: LD_EXP 63
27698: EQUAL
27699: PUSH
27700: LD_EXP 63
27704: PPUSH
27705: CALL_OW 255
27709: PUSH
27710: LD_INT 8
27712: EQUAL
27713: AND
27714: IFFALSE 27728
27716: GO 27718
27718: DISABLE
// RemoveUnit ( Friend ) ;
27719: LD_EXP 63
27723: PPUSH
27724: CALL_OW 64
27728: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
27729: LD_EXP 14
27733: PUSH
27734: LD_INT 31500
27736: GREATEREQUAL
27737: PUSH
27738: LD_EXP 7
27742: AND
27743: PUSH
27744: LD_EXP 2
27748: AND
27749: IFFALSE 28179
27751: GO 27753
27753: DISABLE
27754: LD_INT 0
27756: PPUSH
27757: PPUSH
27758: PPUSH
// begin missionStage := 7 ;
27759: LD_ADDR_EXP 15
27763: PUSH
27764: LD_INT 7
27766: ST_TO_ADDR
// uc_side = 1 ;
27767: LD_ADDR_OWVAR 20
27771: PUSH
27772: LD_INT 1
27774: ST_TO_ADDR
// uc_nation = 1 ;
27775: LD_ADDR_OWVAR 21
27779: PUSH
27780: LD_INT 1
27782: ST_TO_ADDR
// for i = 1 to 5 do
27783: LD_ADDR_VAR 0 1
27787: PUSH
27788: DOUBLE
27789: LD_INT 1
27791: DEC
27792: ST_TO_ADDR
27793: LD_INT 5
27795: PUSH
27796: FOR_TO
27797: IFFALSE 27893
// begin vc_engine = 3 ;
27799: LD_ADDR_OWVAR 39
27803: PUSH
27804: LD_INT 3
27806: ST_TO_ADDR
// vc_control = 3 ;
27807: LD_ADDR_OWVAR 38
27811: PUSH
27812: LD_INT 3
27814: ST_TO_ADDR
// vc_chassis = 3 ;
27815: LD_ADDR_OWVAR 37
27819: PUSH
27820: LD_INT 3
27822: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
27823: LD_ADDR_OWVAR 40
27827: PUSH
27828: LD_INT 5
27830: PUSH
27831: LD_INT 9
27833: PUSH
27834: LD_INT 7
27836: PUSH
27837: EMPTY
27838: LIST
27839: LIST
27840: LIST
27841: PUSH
27842: LD_INT 1
27844: PPUSH
27845: LD_INT 3
27847: PPUSH
27848: CALL_OW 12
27852: ARRAY
27853: ST_TO_ADDR
// veh = CreateVehicle ;
27854: LD_ADDR_VAR 0 2
27858: PUSH
27859: CALL_OW 45
27863: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
27864: LD_VAR 0 2
27868: PPUSH
27869: LD_INT 1
27871: PPUSH
27872: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
27876: LD_VAR 0 2
27880: PPUSH
27881: LD_INT 19
27883: PPUSH
27884: LD_INT 0
27886: PPUSH
27887: CALL_OW 49
// end ;
27891: GO 27796
27893: POP
27894: POP
// vc_engine = 3 ;
27895: LD_ADDR_OWVAR 39
27899: PUSH
27900: LD_INT 3
27902: ST_TO_ADDR
// vc_control = 1 ;
27903: LD_ADDR_OWVAR 38
27907: PUSH
27908: LD_INT 1
27910: ST_TO_ADDR
// vc_chassis = 3 ;
27911: LD_ADDR_OWVAR 37
27915: PUSH
27916: LD_INT 3
27918: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
27919: LD_ADDR_OWVAR 40
27923: PUSH
27924: LD_INT 5
27926: PUSH
27927: LD_INT 9
27929: PUSH
27930: LD_INT 7
27932: PUSH
27933: EMPTY
27934: LIST
27935: LIST
27936: LIST
27937: PUSH
27938: LD_INT 1
27940: PPUSH
27941: LD_INT 3
27943: PPUSH
27944: CALL_OW 12
27948: ARRAY
27949: ST_TO_ADDR
// vehG = CreateVehicle ;
27950: LD_ADDR_VAR 0 3
27954: PUSH
27955: CALL_OW 45
27959: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
27960: LD_VAR 0 3
27964: PPUSH
27965: LD_INT 1
27967: PPUSH
27968: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
27972: LD_VAR 0 3
27976: PPUSH
27977: LD_INT 19
27979: PPUSH
27980: LD_INT 0
27982: PPUSH
27983: CALL_OW 49
// if JMMGirl = 1 then
27987: LD_EXP 7
27991: PUSH
27992: LD_INT 1
27994: EQUAL
27995: IFFALSE 28051
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
27997: LD_ADDR_EXP 41
28001: PUSH
28002: LD_STRING Joan
28004: PPUSH
28005: LD_INT 1
28007: PPUSH
28008: LD_STRING 14_
28010: PPUSH
28011: CALL 67234 0 3
28015: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
28016: LD_EXP 41
28020: PPUSH
28021: LD_VAR 0 3
28025: PPUSH
28026: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28030: LD_VAR 0 3
28034: PPUSH
28035: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
28039: LD_EXP 41
28043: PPUSH
28044: LD_STRING D10BW-Joan-1
28046: PPUSH
28047: CALL_OW 94
// end ; if JMMGirl = 2 then
28051: LD_EXP 7
28055: PUSH
28056: LD_INT 2
28058: EQUAL
28059: IFFALSE 28115
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
28061: LD_ADDR_EXP 43
28065: PUSH
28066: LD_STRING Lisa
28068: PPUSH
28069: LD_INT 1
28071: PPUSH
28072: LD_STRING 14_
28074: PPUSH
28075: CALL 67234 0 3
28079: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
28080: LD_EXP 43
28084: PPUSH
28085: LD_VAR 0 3
28089: PPUSH
28090: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28094: LD_VAR 0 3
28098: PPUSH
28099: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
28103: LD_EXP 43
28107: PPUSH
28108: LD_STRING D10BW-Lisa-1
28110: PPUSH
28111: CALL_OW 94
// end ; if JMMGirl = 3 then
28115: LD_EXP 7
28119: PUSH
28120: LD_INT 3
28122: EQUAL
28123: IFFALSE 28179
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
28125: LD_ADDR_EXP 55
28129: PUSH
28130: LD_STRING Connie
28132: PPUSH
28133: LD_INT 1
28135: PPUSH
28136: LD_STRING 14_
28138: PPUSH
28139: CALL 67234 0 3
28143: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
28144: LD_EXP 55
28148: PPUSH
28149: LD_VAR 0 3
28153: PPUSH
28154: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28158: LD_VAR 0 3
28162: PPUSH
28163: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
28167: LD_EXP 55
28171: PPUSH
28172: LD_STRING D10BW-Con-1
28174: PPUSH
28175: CALL_OW 94
// end ; end ;
28179: PPOPN 3
28181: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
28182: LD_EXP 14
28186: PUSH
28187: LD_INT 94500
28189: GREATEREQUAL
28190: IFFALSE 28602
28192: GO 28194
28194: DISABLE
28195: LD_INT 0
28197: PPUSH
28198: PPUSH
28199: PPUSH
// begin tmp := PrepareStevensSquad ;
28200: LD_ADDR_VAR 0 3
28204: PUSH
28205: CALL 2323 0 0
28209: ST_TO_ADDR
// if not tmp then
28210: LD_VAR 0 3
28214: NOT
28215: IFFALSE 28219
// exit ;
28217: GO 28602
// uc_side := 1 ;
28219: LD_ADDR_OWVAR 20
28223: PUSH
28224: LD_INT 1
28226: ST_TO_ADDR
// uc_nation := 1 ;
28227: LD_ADDR_OWVAR 21
28231: PUSH
28232: LD_INT 1
28234: ST_TO_ADDR
// for i in tmp do
28235: LD_ADDR_VAR 0 1
28239: PUSH
28240: LD_VAR 0 3
28244: PUSH
28245: FOR_IN
28246: IFFALSE 28343
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
28248: LD_INT 3
28250: PPUSH
28251: LD_INT 3
28253: PPUSH
28254: LD_INT 1
28256: PPUSH
28257: LD_INT 5
28259: PUSH
28260: LD_INT 9
28262: PUSH
28263: LD_INT 7
28265: PUSH
28266: EMPTY
28267: LIST
28268: LIST
28269: LIST
28270: PUSH
28271: LD_INT 1
28273: PPUSH
28274: LD_INT 3
28276: PPUSH
28277: CALL_OW 12
28281: ARRAY
28282: PPUSH
28283: LD_INT 40
28285: PPUSH
28286: CALL 72249 0 5
// veh := CreateVehicle ;
28290: LD_ADDR_VAR 0 2
28294: PUSH
28295: CALL_OW 45
28299: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
28300: LD_VAR 0 2
28304: PPUSH
28305: LD_INT 1
28307: PPUSH
28308: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
28312: LD_VAR 0 2
28316: PPUSH
28317: LD_INT 19
28319: PPUSH
28320: LD_INT 0
28322: PPUSH
28323: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
28327: LD_VAR 0 1
28331: PPUSH
28332: LD_VAR 0 2
28336: PPUSH
28337: CALL_OW 52
// end ;
28341: GO 28245
28343: POP
28344: POP
// missionStage := 8 ;
28345: LD_ADDR_EXP 15
28349: PUSH
28350: LD_INT 8
28352: ST_TO_ADDR
// DialogueOn ;
28353: CALL_OW 6
// if Stevens then
28357: LD_EXP 42
28361: IFFALSE 28475
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
28363: LD_EXP 42
28367: PPUSH
28368: CALL_OW 310
28372: PPUSH
28373: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
28377: LD_EXP 42
28381: PPUSH
28382: LD_STRING D8-Huck-1
28384: PPUSH
28385: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
28389: LD_EXP 40
28393: PPUSH
28394: LD_STRING D8-JMM-1
28396: PPUSH
28397: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
28401: LD_EXP 42
28405: PPUSH
28406: LD_STRING D8-Huck-2
28408: PPUSH
28409: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
28413: LD_EXP 40
28417: PPUSH
28418: LD_STRING D8-JMM-2
28420: PPUSH
28421: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
28425: LD_EXP 42
28429: PPUSH
28430: LD_STRING D8-Huck-3
28432: PPUSH
28433: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
28437: LD_EXP 40
28441: PPUSH
28442: LD_STRING D8-JMM-3
28444: PPUSH
28445: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
28449: LD_EXP 42
28453: PPUSH
28454: LD_STRING D8-Huck-4
28456: PPUSH
28457: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
28461: LD_EXP 40
28465: PPUSH
28466: LD_STRING D8-JMM-4
28468: PPUSH
28469: CALL_OW 88
// end else
28473: GO 28585
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
28475: LD_EXP 56
28479: PPUSH
28480: CALL_OW 310
28484: PPUSH
28485: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
28489: LD_EXP 56
28493: PPUSH
28494: LD_STRING D8-Huck-1
28496: PPUSH
28497: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
28501: LD_EXP 40
28505: PPUSH
28506: LD_STRING D8-JMM-1a
28508: PPUSH
28509: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
28513: LD_EXP 56
28517: PPUSH
28518: LD_STRING D8-Huck-2
28520: PPUSH
28521: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
28525: LD_EXP 40
28529: PPUSH
28530: LD_STRING D8-JMM-2
28532: PPUSH
28533: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
28537: LD_EXP 56
28541: PPUSH
28542: LD_STRING D8-Huck-3
28544: PPUSH
28545: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
28549: LD_EXP 40
28553: PPUSH
28554: LD_STRING D8-JMM-3
28556: PPUSH
28557: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
28561: LD_EXP 56
28565: PPUSH
28566: LD_STRING D8-Huck-4
28568: PPUSH
28569: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
28573: LD_EXP 40
28577: PPUSH
28578: LD_STRING D8-JMM-4
28580: PPUSH
28581: CALL_OW 88
// end ; DialogueOff ;
28585: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
28589: LD_INT 25
28591: PPUSH
28592: LD_INT 1
28594: PPUSH
28595: LD_INT 1
28597: PPUSH
28598: CALL_OW 322
// end ;
28602: PPOPN 3
28604: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
28605: LD_INT 1
28607: PPUSH
28608: LD_EXP 72
28612: PPUSH
28613: CALL_OW 292
28617: IFFALSE 28868
28619: GO 28621
28621: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
28622: LD_EXP 72
28626: PPUSH
28627: CALL_OW 87
// DialogueOn ;
28631: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
28635: LD_EXP 40
28639: PPUSH
28640: LD_STRING D10nB-JMM-1
28642: PPUSH
28643: CALL_OW 88
// if BurlakStatus = 1 then
28647: LD_EXP 9
28651: PUSH
28652: LD_INT 1
28654: EQUAL
28655: IFFALSE 28669
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
28657: LD_EXP 71
28661: PPUSH
28662: LD_STRING D10nB-Vse-1a
28664: PPUSH
28665: CALL_OW 94
// end ; if BurlakStatus = 0 then
28669: LD_EXP 9
28673: PUSH
28674: LD_INT 0
28676: EQUAL
28677: IFFALSE 28691
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
28679: LD_EXP 71
28683: PPUSH
28684: LD_STRING D10nB-Vse-1
28686: PPUSH
28687: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
28691: LD_EXP 40
28695: PPUSH
28696: LD_STRING D10nB-JMM-2
28698: PPUSH
28699: CALL_OW 88
// if KappaStatus then
28703: LD_EXP 2
28707: IFFALSE 28721
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
28709: LD_EXP 71
28713: PPUSH
28714: LD_STRING D10nB-Vse-5a
28716: PPUSH
28717: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
28721: LD_EXP 2
28725: NOT
28726: PUSH
28727: LD_EXP 6
28731: PUSH
28732: LD_INT 0
28734: EQUAL
28735: AND
28736: IFFALSE 28864
// begin if JMMGirl = 1 then
28738: LD_EXP 7
28742: PUSH
28743: LD_INT 1
28745: EQUAL
28746: IFFALSE 28796
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
28748: LD_EXP 71
28752: PPUSH
28753: LD_STRING D10nB-Vse-2
28755: PPUSH
28756: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
28760: LD_EXP 40
28764: PPUSH
28765: LD_STRING D10nB-JMM-3
28767: PPUSH
28768: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
28772: LD_EXP 71
28776: PPUSH
28777: LD_STRING D10nB-Vse-3
28779: PPUSH
28780: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
28784: LD_EXP 40
28788: PPUSH
28789: LD_STRING D10nB-JMM-4
28791: PPUSH
28792: CALL_OW 88
// end ; if JMMGirl = 2 then
28796: LD_EXP 7
28800: PUSH
28801: LD_INT 2
28803: EQUAL
28804: IFFALSE 28830
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
28806: LD_EXP 71
28810: PPUSH
28811: LD_STRING D10nB-Vse-4
28813: PPUSH
28814: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
28818: LD_EXP 40
28822: PPUSH
28823: LD_STRING D10nB-JMM-5
28825: PPUSH
28826: CALL_OW 88
// end ; if JMMGirl = 3 then
28830: LD_EXP 7
28834: PUSH
28835: LD_INT 3
28837: EQUAL
28838: IFFALSE 28864
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
28840: LD_EXP 71
28844: PPUSH
28845: LD_STRING D10nB-Vse-5
28847: PPUSH
28848: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
28852: LD_EXP 40
28856: PPUSH
28857: LD_STRING D10nB-JMM-6
28859: PPUSH
28860: CALL_OW 88
// end ; end ; DialogueOff ;
28864: CALL_OW 7
// end ;
28868: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
28869: LD_EXP 14
28873: PUSH
28874: LD_INT 115500
28876: GREATEREQUAL
28877: IFFALSE 29253
28879: GO 28881
28881: DISABLE
28882: LD_INT 0
28884: PPUSH
// begin missionStage := 10 ;
28885: LD_ADDR_EXP 15
28889: PUSH
28890: LD_INT 10
28892: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28893: LD_ADDR_VAR 0 1
28897: PUSH
28898: LD_INT 22
28900: PUSH
28901: LD_INT 1
28903: PUSH
28904: EMPTY
28905: LIST
28906: LIST
28907: PUSH
28908: LD_INT 23
28910: PUSH
28911: LD_INT 1
28913: PUSH
28914: EMPTY
28915: LIST
28916: LIST
28917: PUSH
28918: LD_INT 26
28920: PUSH
28921: LD_INT 1
28923: PUSH
28924: EMPTY
28925: LIST
28926: LIST
28927: PUSH
28928: LD_INT 3
28930: PUSH
28931: LD_INT 25
28933: PUSH
28934: LD_INT 12
28936: PUSH
28937: EMPTY
28938: LIST
28939: LIST
28940: PUSH
28941: EMPTY
28942: LIST
28943: LIST
28944: PUSH
28945: LD_INT 3
28947: PUSH
28948: LD_INT 25
28950: PUSH
28951: LD_INT 16
28953: PUSH
28954: EMPTY
28955: LIST
28956: LIST
28957: PUSH
28958: EMPTY
28959: LIST
28960: LIST
28961: PUSH
28962: EMPTY
28963: LIST
28964: LIST
28965: LIST
28966: LIST
28967: LIST
28968: PPUSH
28969: CALL_OW 69
28973: PUSH
28974: LD_EXP 40
28978: PUSH
28979: LD_EXP 61
28983: PUSH
28984: LD_EXP 42
28988: PUSH
28989: LD_EXP 56
28993: PUSH
28994: LD_EXP 43
28998: PUSH
28999: LD_EXP 44
29003: PUSH
29004: LD_EXP 45
29008: PUSH
29009: LD_EXP 46
29013: PUSH
29014: LD_EXP 47
29018: PUSH
29019: LD_EXP 48
29023: PUSH
29024: LD_EXP 49
29028: PUSH
29029: LD_EXP 50
29033: PUSH
29034: LD_EXP 51
29038: PUSH
29039: LD_EXP 52
29043: PUSH
29044: LD_EXP 53
29048: PUSH
29049: LD_EXP 54
29053: PUSH
29054: EMPTY
29055: LIST
29056: LIST
29057: LIST
29058: LIST
29059: LIST
29060: LIST
29061: LIST
29062: LIST
29063: LIST
29064: LIST
29065: LIST
29066: LIST
29067: LIST
29068: LIST
29069: LIST
29070: LIST
29071: DIFF
29072: ST_TO_ADDR
// if not tmp and Brown then
29073: LD_VAR 0 1
29077: NOT
29078: PUSH
29079: LD_EXP 48
29083: AND
29084: IFFALSE 29099
// tmp := [ Brown ] ;
29086: LD_ADDR_VAR 0 1
29090: PUSH
29091: LD_EXP 48
29095: PUSH
29096: EMPTY
29097: LIST
29098: ST_TO_ADDR
// DialogueOn ;
29099: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
29103: LD_VAR 0 1
29107: PUSH
29108: LD_INT 1
29110: ARRAY
29111: PPUSH
29112: LD_STRING D11-Sol1-1
29114: PPUSH
29115: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
29119: LD_EXP 65
29123: PPUSH
29124: LD_STRING D11-Pla-1
29126: PPUSH
29127: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
29131: LD_EXP 66
29135: PPUSH
29136: LD_STRING D11-Kov-1
29138: PPUSH
29139: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
29143: LD_EXP 65
29147: PPUSH
29148: LD_STRING D11-Pla-2
29150: PPUSH
29151: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
29155: LD_VAR 0 1
29159: PUSH
29160: LD_INT 1
29162: ARRAY
29163: PPUSH
29164: LD_STRING D11-Sol1-2
29166: PPUSH
29167: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
29171: LD_EXP 40
29175: PPUSH
29176: LD_STRING D11-JMM-2
29178: PPUSH
29179: CALL_OW 88
// DialogueOff ;
29183: CALL_OW 7
// allowBehemothConstruct := true ;
29187: LD_ADDR_EXP 25
29191: PUSH
29192: LD_INT 1
29194: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
29195: LD_STRING M4
29197: PPUSH
29198: CALL_OW 337
// BuildBehemoths ;
29202: CALL 7865 0 0
// repeat wait ( 15 15$00 ) ;
29206: LD_INT 31500
29208: PPUSH
29209: CALL_OW 67
// if behemothDestroyedBeforeFinish then
29213: LD_EXP 27
29217: IFFALSE 29221
// break ;
29219: GO 29253
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
29221: LD_INT 267
29223: PPUSH
29224: CALL_OW 274
29228: PPUSH
29229: LD_INT 1
29231: PPUSH
29232: CALL_OW 275
29236: PUSH
29237: LD_INT 1000
29239: GREATEREQUAL
29240: IFFALSE 29246
// BuildBehemoths ;
29242: CALL 7865 0 0
// until not behemothBuilders ;
29246: LD_EXP 74
29250: NOT
29251: IFFALSE 29206
// end ;
29253: PPOPN 1
29255: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
29256: LD_EXP 74
29260: NOT
29261: PUSH
29262: LD_EXP 28
29266: NOT
29267: AND
29268: PUSH
29269: LD_EXP 25
29273: AND
29274: IFFALSE 29294
29276: GO 29278
29278: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
29279: LD_STRING M4a
29281: PPUSH
29282: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
29286: LD_ADDR_EXP 27
29290: PUSH
29291: LD_INT 1
29293: ST_TO_ADDR
// end ;
29294: END
// every 0 0$1 trigger behemothDone do
29295: LD_EXP 28
29299: IFFALSE 29311
29301: GO 29303
29303: DISABLE
// ChangeMissionObjectives ( M4b ) ;
29304: LD_STRING M4b
29306: PPUSH
29307: CALL_OW 337
29311: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
29312: LD_EXP 29
29316: NOT
29317: IFFALSE 29513
29319: GO 29321
29321: DISABLE
29322: LD_INT 0
29324: PPUSH
29325: PPUSH
// begin enable ;
29326: ENABLE
// tmp := GetBehemoths ( 3 ) ;
29327: LD_ADDR_VAR 0 1
29331: PUSH
29332: LD_INT 3
29334: PPUSH
29335: CALL 104744 0 1
29339: ST_TO_ADDR
// if not tmp and not behemothDone then
29340: LD_VAR 0 1
29344: NOT
29345: PUSH
29346: LD_EXP 28
29350: NOT
29351: AND
29352: IFFALSE 29388
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
29354: LD_ADDR_VAR 0 1
29358: PUSH
29359: LD_INT 22
29361: PUSH
29362: LD_INT 3
29364: PUSH
29365: EMPTY
29366: LIST
29367: LIST
29368: PUSH
29369: LD_INT 30
29371: PUSH
29372: LD_INT 37
29374: PUSH
29375: EMPTY
29376: LIST
29377: LIST
29378: PUSH
29379: EMPTY
29380: LIST
29381: LIST
29382: PPUSH
29383: CALL_OW 69
29387: ST_TO_ADDR
// if not tmp then
29388: LD_VAR 0 1
29392: NOT
29393: IFFALSE 29397
// exit ;
29395: GO 29513
// for i in tmp do
29397: LD_ADDR_VAR 0 2
29401: PUSH
29402: LD_VAR 0 1
29406: PUSH
29407: FOR_IN
29408: IFFALSE 29511
// if See ( 1 , i ) then
29410: LD_INT 1
29412: PPUSH
29413: LD_VAR 0 2
29417: PPUSH
29418: CALL_OW 292
29422: IFFALSE 29509
// begin if GetType ( i ) = unit_building then
29424: LD_VAR 0 2
29428: PPUSH
29429: CALL_OW 247
29433: PUSH
29434: LD_INT 3
29436: EQUAL
29437: IFFALSE 29475
// begin CenterNowOnUnits ( i ) ;
29439: LD_VAR 0 2
29443: PPUSH
29444: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
29448: LD_EXP 40
29452: PPUSH
29453: LD_STRING D17a-JMM-1
29455: PPUSH
29456: CALL_OW 88
// seeBehemoth := true ;
29460: LD_ADDR_EXP 29
29464: PUSH
29465: LD_INT 1
29467: ST_TO_ADDR
// disable ;
29468: DISABLE
// exit ;
29469: POP
29470: POP
29471: GO 29513
// end else
29473: GO 29509
// begin CenterNowOnUnits ( i ) ;
29475: LD_VAR 0 2
29479: PPUSH
29480: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
29484: LD_EXP 40
29488: PPUSH
29489: LD_STRING D17b-JMM-1
29491: PPUSH
29492: CALL_OW 88
// seeBehemoth := true ;
29496: LD_ADDR_EXP 29
29500: PUSH
29501: LD_INT 1
29503: ST_TO_ADDR
// disable ;
29504: DISABLE
// exit ;
29505: POP
29506: POP
29507: GO 29513
// end ; end ;
29509: GO 29407
29511: POP
29512: POP
// end ;
29513: PPOPN 2
29515: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
29516: LD_EXP 14
29520: PUSH
29521: LD_INT 123200
29523: GREATEREQUAL
29524: IFFALSE 30700
29526: GO 29528
29528: DISABLE
29529: LD_INT 0
29531: PPUSH
29532: PPUSH
29533: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
29534: LD_INT 2
29536: PPUSH
29537: LD_INT 23
29539: PUSH
29540: LD_INT 3
29542: PUSH
29543: LD_INT 3
29545: PUSH
29546: LD_INT 48
29548: PUSH
29549: EMPTY
29550: LIST
29551: LIST
29552: LIST
29553: LIST
29554: PUSH
29555: EMPTY
29556: LIST
29557: PPUSH
29558: CALL 60846 0 2
// repeat wait ( 0 0$1 ) ;
29562: LD_INT 35
29564: PPUSH
29565: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
29569: LD_INT 22
29571: PUSH
29572: LD_INT 3
29574: PUSH
29575: EMPTY
29576: LIST
29577: LIST
29578: PUSH
29579: LD_INT 34
29581: PUSH
29582: LD_INT 48
29584: PUSH
29585: EMPTY
29586: LIST
29587: LIST
29588: PUSH
29589: EMPTY
29590: LIST
29591: LIST
29592: PPUSH
29593: CALL_OW 69
29597: IFFALSE 29562
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
29599: LD_ADDR_VAR 0 1
29603: PUSH
29604: LD_INT 22
29606: PUSH
29607: LD_INT 3
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PUSH
29614: LD_INT 34
29616: PUSH
29617: LD_INT 48
29619: PUSH
29620: EMPTY
29621: LIST
29622: LIST
29623: PUSH
29624: EMPTY
29625: LIST
29626: LIST
29627: PPUSH
29628: CALL_OW 69
29632: PUSH
29633: LD_INT 1
29635: ARRAY
29636: ST_TO_ADDR
// missionStage := 12 ;
29637: LD_ADDR_EXP 15
29641: PUSH
29642: LD_INT 12
29644: ST_TO_ADDR
// platonovHasBomb := true ;
29645: LD_ADDR_EXP 30
29649: PUSH
29650: LD_INT 1
29652: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
29653: LD_VAR 0 1
29657: PPUSH
29658: LD_INT 181
29660: PPUSH
29661: LD_INT 86
29663: PPUSH
29664: CALL_OW 171
// AddComHold ( bomb ) ;
29668: LD_VAR 0 1
29672: PPUSH
29673: CALL_OW 200
// wait ( 0 0$10 ) ;
29677: LD_INT 350
29679: PPUSH
29680: CALL_OW 67
// DialogueOn ;
29684: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
29688: LD_EXP 65
29692: PPUSH
29693: LD_STRING D15-Pla-1
29695: PPUSH
29696: CALL_OW 94
// dec = Query ( Q15a ) ;
29700: LD_ADDR_VAR 0 2
29704: PUSH
29705: LD_STRING Q15a
29707: PPUSH
29708: CALL_OW 97
29712: ST_TO_ADDR
// if dec = 1 then
29713: LD_VAR 0 2
29717: PUSH
29718: LD_INT 1
29720: EQUAL
29721: IFFALSE 29744
// begin Say ( JMM , D15a-JMM-1 ) ;
29723: LD_EXP 40
29727: PPUSH
29728: LD_STRING D15a-JMM-1
29730: PPUSH
29731: CALL_OW 88
// YouLost ( Surrender ) ;
29735: LD_STRING Surrender
29737: PPUSH
29738: CALL_OW 104
// exit ;
29742: GO 30700
// end ; if dec = 2 then
29744: LD_VAR 0 2
29748: PUSH
29749: LD_INT 2
29751: EQUAL
29752: IFFALSE 29821
// begin Say ( JMM , D15b-JMM-1 ) ;
29754: LD_EXP 40
29758: PPUSH
29759: LD_STRING D15b-JMM-1
29761: PPUSH
29762: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
29766: LD_EXP 65
29770: PPUSH
29771: LD_STRING D15b-Pla-1
29773: PPUSH
29774: CALL_OW 94
// DialogueOff ;
29778: CALL_OW 7
// wait ( 3 3$00 ) ;
29782: LD_INT 6300
29784: PPUSH
29785: CALL_OW 67
// DialogueOn ;
29789: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
29793: LD_EXP 40
29797: PPUSH
29798: LD_STRING D15d-JMM-1a
29800: PPUSH
29801: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
29805: LD_EXP 65
29809: PPUSH
29810: LD_STRING D15d-Pla-1
29812: PPUSH
29813: CALL_OW 94
// DialogueOff ;
29817: CALL_OW 7
// end ; if dec = 3 then
29821: LD_VAR 0 2
29825: PUSH
29826: LD_INT 3
29828: EQUAL
29829: IFFALSE 29883
// begin Say ( JMM , D15c-JMM-1 ) ;
29831: LD_EXP 40
29835: PPUSH
29836: LD_STRING D15c-JMM-1
29838: PPUSH
29839: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
29843: LD_EXP 65
29847: PPUSH
29848: LD_STRING D15c-Pla-1
29850: PPUSH
29851: CALL_OW 94
// DialogueOff ;
29855: CALL_OW 7
// wait ( 0 0$15 ) ;
29859: LD_INT 525
29861: PPUSH
29862: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
29866: LD_VAR 0 1
29870: PPUSH
29871: LD_INT 60
29873: PPUSH
29874: LD_INT 95
29876: PPUSH
29877: CALL_OW 116
// exit ;
29881: GO 30700
// end ; if dec = 4 then
29883: LD_VAR 0 2
29887: PUSH
29888: LD_INT 4
29890: EQUAL
29891: IFFALSE 29921
// begin Say ( JMM , D15d-JMM-1 ) ;
29893: LD_EXP 40
29897: PPUSH
29898: LD_STRING D15d-JMM-1
29900: PPUSH
29901: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
29905: LD_EXP 65
29909: PPUSH
29910: LD_STRING D15d-Pla-1
29912: PPUSH
29913: CALL_OW 94
// DialogueOff ;
29917: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29921: LD_EXP 63
29925: PPUSH
29926: CALL_OW 302
29930: PUSH
29931: LD_EXP 63
29935: PPUSH
29936: CALL_OW 255
29940: PUSH
29941: LD_INT 1
29943: EQUAL
29944: AND
29945: PUSH
29946: LD_INT 22
29948: PUSH
29949: LD_INT 1
29951: PUSH
29952: EMPTY
29953: LIST
29954: LIST
29955: PUSH
29956: LD_INT 34
29958: PUSH
29959: LD_INT 8
29961: PUSH
29962: EMPTY
29963: LIST
29964: LIST
29965: PUSH
29966: EMPTY
29967: LIST
29968: LIST
29969: PPUSH
29970: CALL_OW 69
29974: NOT
29975: AND
29976: IFFALSE 30601
// begin SetSide ( Friend , 8 ) ;
29978: LD_EXP 63
29982: PPUSH
29983: LD_INT 8
29985: PPUSH
29986: CALL_OW 235
// if IsInUnit ( Friend ) then
29990: LD_EXP 63
29994: PPUSH
29995: CALL_OW 310
29999: IFFALSE 30010
// ComExitBuilding ( Friend ) ;
30001: LD_EXP 63
30005: PPUSH
30006: CALL_OW 122
// if IsDriver ( Friend ) then
30010: LD_EXP 63
30014: PPUSH
30015: CALL 102292 0 1
30019: IFFALSE 30030
// ComExitVehicle ( Friend ) ;
30021: LD_EXP 63
30025: PPUSH
30026: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
30030: LD_EXP 63
30034: PPUSH
30035: LD_INT 9
30037: PPUSH
30038: LD_INT 2
30040: PPUSH
30041: CALL_OW 171
// wait ( 0 0$05 ) ;
30045: LD_INT 175
30047: PPUSH
30048: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
30052: LD_EXP 63
30056: PPUSH
30057: CALL_OW 87
// DialogueOn ;
30061: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
30065: LD_EXP 40
30069: PPUSH
30070: LD_STRING D16-JMM-1
30072: PPUSH
30073: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
30077: LD_EXP 63
30081: PPUSH
30082: LD_STRING D16-Friend-1
30084: PPUSH
30085: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
30089: LD_EXP 40
30093: PPUSH
30094: LD_STRING D16-JMM-2
30096: PPUSH
30097: CALL_OW 88
// DialogueOff ;
30101: CALL_OW 7
// SetSide ( Friend , 1 ) ;
30105: LD_EXP 63
30109: PPUSH
30110: LD_INT 1
30112: PPUSH
30113: CALL_OW 235
// ComHold ( Friend ) ;
30117: LD_EXP 63
30121: PPUSH
30122: CALL_OW 140
// wait ( 0 0$20 ) ;
30126: LD_INT 700
30128: PPUSH
30129: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
30133: LD_EXP 63
30137: PPUSH
30138: LD_INT 9
30140: PPUSH
30141: LD_INT 2
30143: PPUSH
30144: CALL_OW 297
30148: PUSH
30149: LD_INT 30
30151: LESS
30152: IFFALSE 30221
// begin SetSide ( Friend , 8 ) ;
30154: LD_EXP 63
30158: PPUSH
30159: LD_INT 8
30161: PPUSH
30162: CALL_OW 235
// if IsInUnit ( Friend ) then
30166: LD_EXP 63
30170: PPUSH
30171: CALL_OW 310
30175: IFFALSE 30186
// ComExitBuilding ( Friend ) ;
30177: LD_EXP 63
30181: PPUSH
30182: CALL_OW 122
// if IsDriver ( Friend ) then
30186: LD_EXP 63
30190: PPUSH
30191: CALL 102292 0 1
30195: IFFALSE 30206
// ComExitVehicle ( Friend ) ;
30197: LD_EXP 63
30201: PPUSH
30202: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
30206: LD_EXP 63
30210: PPUSH
30211: LD_INT 9
30213: PPUSH
30214: LD_INT 2
30216: PPUSH
30217: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
30221: LD_INT 1050
30223: PPUSH
30224: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30228: LD_INT 22
30230: PUSH
30231: LD_INT 1
30233: PUSH
30234: EMPTY
30235: LIST
30236: LIST
30237: PUSH
30238: LD_INT 34
30240: PUSH
30241: LD_INT 8
30243: PUSH
30244: EMPTY
30245: LIST
30246: LIST
30247: PUSH
30248: EMPTY
30249: LIST
30250: LIST
30251: PPUSH
30252: CALL_OW 69
30256: NOT
30257: IFFALSE 30579
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
30259: LD_ADDR_VAR 0 3
30263: PUSH
30264: LD_INT 22
30266: PUSH
30267: LD_INT 1
30269: PUSH
30270: EMPTY
30271: LIST
30272: LIST
30273: PUSH
30274: LD_INT 26
30276: PUSH
30277: LD_INT 1
30279: PUSH
30280: EMPTY
30281: LIST
30282: LIST
30283: PUSH
30284: LD_INT 3
30286: PUSH
30287: LD_INT 25
30289: PUSH
30290: LD_INT 12
30292: PUSH
30293: EMPTY
30294: LIST
30295: LIST
30296: PUSH
30297: LD_INT 25
30299: PUSH
30300: LD_INT 16
30302: PUSH
30303: EMPTY
30304: LIST
30305: LIST
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: LIST
30311: PUSH
30312: EMPTY
30313: LIST
30314: LIST
30315: LIST
30316: PPUSH
30317: CALL_OW 69
30321: PUSH
30322: LD_EXP 40
30326: PUSH
30327: LD_EXP 42
30331: PUSH
30332: LD_EXP 56
30336: PUSH
30337: LD_EXP 43
30341: PUSH
30342: LD_EXP 44
30346: PUSH
30347: LD_EXP 45
30351: PUSH
30352: LD_EXP 46
30356: PUSH
30357: LD_EXP 47
30361: PUSH
30362: LD_EXP 48
30366: PUSH
30367: LD_EXP 49
30371: PUSH
30372: LD_EXP 50
30376: PUSH
30377: LD_EXP 51
30381: PUSH
30382: LD_EXP 52
30386: PUSH
30387: LD_EXP 53
30391: PUSH
30392: LD_EXP 54
30396: PUSH
30397: EMPTY
30398: LIST
30399: LIST
30400: LIST
30401: LIST
30402: LIST
30403: LIST
30404: LIST
30405: LIST
30406: LIST
30407: LIST
30408: LIST
30409: LIST
30410: LIST
30411: LIST
30412: LIST
30413: DIFF
30414: ST_TO_ADDR
// DialogueOn ;
30415: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
30419: LD_EXP 65
30423: PPUSH
30424: LD_STRING D16a-Pla-1
30426: PPUSH
30427: CALL_OW 94
// if Stevens then
30431: LD_EXP 42
30435: IFFALSE 30451
// Say ( Stevens , D16a-Huck-1 ) else
30437: LD_EXP 42
30441: PPUSH
30442: LD_STRING D16a-Huck-1
30444: PPUSH
30445: CALL_OW 88
30449: GO 30493
// if Baker then
30451: LD_EXP 56
30455: IFFALSE 30471
// Say ( Baker , D16a-Huck-1 ) else
30457: LD_EXP 56
30461: PPUSH
30462: LD_STRING D16a-Huck-1
30464: PPUSH
30465: CALL_OW 88
30469: GO 30493
// if tmp then
30471: LD_VAR 0 3
30475: IFFALSE 30493
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
30477: LD_VAR 0 3
30481: PUSH
30482: LD_INT 1
30484: ARRAY
30485: PPUSH
30486: LD_STRING D16a-Sol1-1
30488: PPUSH
30489: CALL_OW 88
// if GetSide ( Friend ) = 8 then
30493: LD_EXP 63
30497: PPUSH
30498: CALL_OW 255
30502: PUSH
30503: LD_INT 8
30505: EQUAL
30506: IFFALSE 30522
// Say ( JMM , D16a-JMM-1 ) else
30508: LD_EXP 40
30512: PPUSH
30513: LD_STRING D16a-JMM-1
30515: PPUSH
30516: CALL_OW 88
30520: GO 30558
// begin Say ( JMM , D16a-JMM-1a ) ;
30522: LD_EXP 40
30526: PPUSH
30527: LD_STRING D16a-JMM-1a
30529: PPUSH
30530: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
30534: LD_EXP 63
30538: PPUSH
30539: LD_STRING D16a-Friend-1
30541: PPUSH
30542: CALL_OW 88
// SetSide ( Friend , 3 ) ;
30546: LD_EXP 63
30550: PPUSH
30551: LD_INT 3
30553: PPUSH
30554: CALL_OW 235
// end ; DialogueOff ;
30558: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
30562: LD_VAR 0 1
30566: PPUSH
30567: LD_INT 60
30569: PPUSH
30570: LD_INT 95
30572: PPUSH
30573: CALL_OW 116
// end else
30577: GO 30599
// begin DialogueOn ;
30579: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
30583: LD_EXP 65
30587: PPUSH
30588: LD_STRING D16c-Pla-
30590: PPUSH
30591: CALL_OW 94
// DialogueOff ;
30595: CALL_OW 7
// end ; end else
30599: GO 30700
// begin wait ( 3 3$00 ) ;
30601: LD_INT 6300
30603: PPUSH
30604: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30608: LD_INT 22
30610: PUSH
30611: LD_INT 1
30613: PUSH
30614: EMPTY
30615: LIST
30616: LIST
30617: PUSH
30618: LD_INT 34
30620: PUSH
30621: LD_INT 8
30623: PUSH
30624: EMPTY
30625: LIST
30626: LIST
30627: PUSH
30628: EMPTY
30629: LIST
30630: LIST
30631: PPUSH
30632: CALL_OW 69
30636: NOT
30637: IFFALSE 30680
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
30639: LD_EXP 65
30643: PPUSH
30644: LD_STRING D16b-Pla-1
30646: PPUSH
30647: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
30651: LD_EXP 40
30655: PPUSH
30656: LD_STRING D16b-JMM-
30658: PPUSH
30659: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
30663: LD_VAR 0 1
30667: PPUSH
30668: LD_INT 60
30670: PPUSH
30671: LD_INT 95
30673: PPUSH
30674: CALL_OW 116
// end else
30678: GO 30700
// begin DialogueOn ;
30680: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
30684: LD_EXP 65
30688: PPUSH
30689: LD_STRING D16c-Pla-1
30691: PPUSH
30692: CALL_OW 94
// DialogueOff ;
30696: CALL_OW 7
// end ; end ; end ;
30700: PPOPN 3
30702: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
30703: LD_EXP 14
30707: PUSH
30708: LD_INT 126000
30710: GREATEREQUAL
30711: PUSH
30712: LD_EXP 23
30716: NOT
30717: AND
30718: PUSH
30719: LD_EXP 76
30723: PPUSH
30724: CALL_OW 302
30728: AND
30729: IFFALSE 31087
30731: GO 30733
30733: DISABLE
30734: LD_INT 0
30736: PPUSH
// begin missionStage = 11 ;
30737: LD_ADDR_EXP 15
30741: PUSH
30742: LD_INT 11
30744: ST_TO_ADDR
// DialogueOn ;
30745: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
30749: LD_EXP 76
30753: PPUSH
30754: LD_STRING D9-Roth-1
30756: PPUSH
30757: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
30761: LD_EXP 40
30765: PPUSH
30766: LD_STRING D9-JMM-1
30768: PPUSH
30769: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
30773: LD_EXP 76
30777: PPUSH
30778: LD_STRING D9-Roth-2
30780: PPUSH
30781: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
30785: LD_EXP 76
30789: PPUSH
30790: LD_STRING D9-Roth-2a
30792: PPUSH
30793: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
30797: LD_EXP 65
30801: PPUSH
30802: LD_STRING D9-Pla-2
30804: PPUSH
30805: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
30809: LD_EXP 76
30813: PPUSH
30814: LD_STRING D9-Roth-3
30816: PPUSH
30817: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
30821: LD_EXP 65
30825: PPUSH
30826: LD_STRING D9-Pla-3
30828: PPUSH
30829: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
30833: LD_EXP 76
30837: PPUSH
30838: LD_STRING D9-Roth-4
30840: PPUSH
30841: CALL_OW 94
// dec = Query ( Q9 ) ;
30845: LD_ADDR_VAR 0 1
30849: PUSH
30850: LD_STRING Q9
30852: PPUSH
30853: CALL_OW 97
30857: ST_TO_ADDR
// if dec = 1 then
30858: LD_VAR 0 1
30862: PUSH
30863: LD_INT 1
30865: EQUAL
30866: IFFALSE 30880
// SayRadio ( Roth , D9a-Roth-1 ) ;
30868: LD_EXP 76
30872: PPUSH
30873: LD_STRING D9a-Roth-1
30875: PPUSH
30876: CALL_OW 94
// if dec = 2 then
30880: LD_VAR 0 1
30884: PUSH
30885: LD_INT 2
30887: EQUAL
30888: IFFALSE 30914
// begin Say ( JMM , D9b-JMM-1 ) ;
30890: LD_EXP 40
30894: PPUSH
30895: LD_STRING D9b-JMM-1
30897: PPUSH
30898: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
30902: LD_EXP 76
30906: PPUSH
30907: LD_STRING D9b-Roth-1
30909: PPUSH
30910: CALL_OW 94
// end ; if dec = 3 then
30914: LD_VAR 0 1
30918: PUSH
30919: LD_INT 3
30921: EQUAL
30922: IFFALSE 30984
// begin Say ( JMM , D9c-JMM-1 ) ;
30924: LD_EXP 40
30928: PPUSH
30929: LD_STRING D9c-JMM-1
30931: PPUSH
30932: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
30936: LD_EXP 76
30940: PPUSH
30941: LD_STRING D9c-Roth-1
30943: PPUSH
30944: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
30948: LD_EXP 40
30952: PPUSH
30953: LD_STRING D9c-JMM-2
30955: PPUSH
30956: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
30960: LD_EXP 76
30964: PPUSH
30965: LD_STRING D9c-Roth-2
30967: PPUSH
30968: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
30972: LD_EXP 40
30976: PPUSH
30977: LD_STRING D9c-JMM-3
30979: PPUSH
30980: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
30984: LD_EXP 76
30988: PPUSH
30989: LD_STRING D9c-Roth-3
30991: PPUSH
30992: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
30996: LD_EXP 76
31000: PPUSH
31001: LD_STRING D9cont-Roth-1
31003: PPUSH
31004: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
31008: LD_EXP 40
31012: PPUSH
31013: LD_STRING D9cont-JMM-1
31015: PPUSH
31016: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
31020: LD_EXP 76
31024: PPUSH
31025: LD_STRING D9cont-Roth-2
31027: PPUSH
31028: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
31032: LD_EXP 40
31036: PPUSH
31037: LD_STRING D9cont-JMM-2
31039: PPUSH
31040: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
31044: LD_EXP 76
31048: PPUSH
31049: LD_STRING D9cont-Roth-3
31051: PPUSH
31052: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
31056: LD_EXP 40
31060: PPUSH
31061: LD_STRING D9cont-JMM-3
31063: PPUSH
31064: CALL_OW 88
// DialogueOff ;
31068: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
31072: LD_STRING M3
31074: PPUSH
31075: CALL_OW 337
// allianceActive := true ;
31079: LD_ADDR_EXP 31
31083: PUSH
31084: LD_INT 1
31086: ST_TO_ADDR
// end ;
31087: PPOPN 1
31089: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
31090: LD_INT 1
31092: PPUSH
31093: LD_INT 126
31095: PPUSH
31096: CALL_OW 292
31100: PUSH
31101: LD_EXP 65
31105: PPUSH
31106: CALL_OW 310
31110: AND
31111: IFFALSE 31191
31113: GO 31115
31115: DISABLE
31116: LD_INT 0
31118: PPUSH
// begin ComExitBuilding ( Platonov ) ;
31119: LD_EXP 65
31123: PPUSH
31124: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
31128: LD_ADDR_VAR 0 1
31132: PUSH
31133: LD_INT 4
31135: PPUSH
31136: LD_INT 22
31138: PUSH
31139: LD_INT 1
31141: PUSH
31142: EMPTY
31143: LIST
31144: LIST
31145: PPUSH
31146: CALL_OW 70
31150: PPUSH
31151: LD_EXP 65
31155: PPUSH
31156: CALL_OW 74
31160: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
31161: LD_EXP 65
31165: PPUSH
31166: LD_VAR 0 1
31170: PUSH
31171: LD_INT 1
31173: ARRAY
31174: PPUSH
31175: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
31179: LD_EXP 65
31183: PPUSH
31184: LD_STRING D18-Pla-1
31186: PPUSH
31187: CALL_OW 88
// end ;
31191: PPOPN 1
31193: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
31194: LD_EXP 65
31198: PPUSH
31199: CALL_OW 301
31203: PUSH
31204: LD_EXP 68
31208: PPUSH
31209: CALL_OW 301
31213: AND
31214: PUSH
31215: LD_INT 22
31217: PUSH
31218: LD_INT 3
31220: PUSH
31221: EMPTY
31222: LIST
31223: LIST
31224: PUSH
31225: LD_INT 21
31227: PUSH
31228: LD_INT 1
31230: PUSH
31231: EMPTY
31232: LIST
31233: LIST
31234: PUSH
31235: LD_INT 50
31237: PUSH
31238: EMPTY
31239: LIST
31240: PUSH
31241: EMPTY
31242: LIST
31243: LIST
31244: LIST
31245: PPUSH
31246: CALL_OW 69
31250: PUSH
31251: LD_INT 7
31253: PUSH
31254: LD_INT 8
31256: PUSH
31257: LD_INT 9
31259: PUSH
31260: LD_INT 10
31262: PUSH
31263: EMPTY
31264: LIST
31265: LIST
31266: LIST
31267: LIST
31268: PUSH
31269: LD_OWVAR 67
31273: ARRAY
31274: LESS
31275: AND
31276: IFFALSE 32033
31278: GO 31280
31280: DISABLE
31281: LD_INT 0
31283: PPUSH
31284: PPUSH
31285: PPUSH
31286: PPUSH
// begin MC_Kill ( 2 ) ;
31287: LD_INT 2
31289: PPUSH
31290: CALL 36819 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
31294: LD_INT 1
31296: PPUSH
31297: LD_INT 3
31299: PPUSH
31300: LD_INT 1
31302: PPUSH
31303: LD_INT 1
31305: PPUSH
31306: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
31310: LD_ADDR_VAR 0 2
31314: PUSH
31315: LD_INT 22
31317: PUSH
31318: LD_INT 3
31320: PUSH
31321: EMPTY
31322: LIST
31323: LIST
31324: PUSH
31325: LD_INT 21
31327: PUSH
31328: LD_INT 1
31330: PUSH
31331: EMPTY
31332: LIST
31333: LIST
31334: PUSH
31335: LD_INT 50
31337: PUSH
31338: EMPTY
31339: LIST
31340: PUSH
31341: LD_INT 26
31343: PUSH
31344: LD_INT 1
31346: PUSH
31347: EMPTY
31348: LIST
31349: LIST
31350: PUSH
31351: EMPTY
31352: LIST
31353: LIST
31354: LIST
31355: LIST
31356: PPUSH
31357: CALL_OW 69
31361: ST_TO_ADDR
// if not tmp then
31362: LD_VAR 0 2
31366: NOT
31367: IFFALSE 31423
// begin uc_side = 3 ;
31369: LD_ADDR_OWVAR 20
31373: PUSH
31374: LD_INT 3
31376: ST_TO_ADDR
// uc_nation = 3 ;
31377: LD_ADDR_OWVAR 21
31381: PUSH
31382: LD_INT 3
31384: ST_TO_ADDR
// hc_name =  ;
31385: LD_ADDR_OWVAR 26
31389: PUSH
31390: LD_STRING 
31392: ST_TO_ADDR
// hc_gallery =  ;
31393: LD_ADDR_OWVAR 33
31397: PUSH
31398: LD_STRING 
31400: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
31401: LD_INT 1
31403: PPUSH
31404: LD_INT 10
31406: PPUSH
31407: CALL_OW 381
// tmp = CreateHuman ;
31411: LD_ADDR_VAR 0 2
31415: PUSH
31416: CALL_OW 44
31420: ST_TO_ADDR
// end else
31421: GO 31437
// tmp := tmp [ 1 ] ;
31423: LD_ADDR_VAR 0 2
31427: PUSH
31428: LD_VAR 0 2
31432: PUSH
31433: LD_INT 1
31435: ARRAY
31436: ST_TO_ADDR
// DialogueOn ;
31437: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
31441: LD_VAR 0 2
31445: PPUSH
31446: LD_STRING DSurrenderRussians-RSol1-1a
31448: PPUSH
31449: CALL_OW 94
// DialogueOff ;
31453: CALL_OW 7
// russianDestroyed := true ;
31457: LD_ADDR_EXP 21
31461: PUSH
31462: LD_INT 1
31464: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
31465: LD_INT 22
31467: PUSH
31468: LD_INT 3
31470: PUSH
31471: EMPTY
31472: LIST
31473: LIST
31474: PUSH
31475: LD_INT 21
31477: PUSH
31478: LD_INT 1
31480: PUSH
31481: EMPTY
31482: LIST
31483: LIST
31484: PUSH
31485: EMPTY
31486: LIST
31487: LIST
31488: PPUSH
31489: CALL_OW 69
31493: PPUSH
31494: CALL_OW 122
// wait ( 0 0$1 ) ;
31498: LD_INT 35
31500: PPUSH
31501: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
31505: LD_INT 22
31507: PUSH
31508: LD_INT 3
31510: PUSH
31511: EMPTY
31512: LIST
31513: LIST
31514: PUSH
31515: LD_INT 21
31517: PUSH
31518: LD_INT 1
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: PUSH
31525: EMPTY
31526: LIST
31527: LIST
31528: PPUSH
31529: CALL_OW 69
31533: PPUSH
31534: LD_INT 25
31536: PPUSH
31537: CALL_OW 173
// wait ( 0 0$35 ) ;
31541: LD_INT 1225
31543: PPUSH
31544: CALL_OW 67
// PrepareOmarInvasion ;
31548: CALL 14722 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
31552: LD_ADDR_VAR 0 2
31556: PUSH
31557: LD_EXP 94
31561: PPUSH
31562: CALL_OW 250
31566: PUSH
31567: LD_EXP 94
31571: PPUSH
31572: CALL_OW 251
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
31581: LD_VAR 0 2
31585: PUSH
31586: LD_INT 1
31588: ARRAY
31589: PPUSH
31590: LD_VAR 0 2
31594: PUSH
31595: LD_INT 2
31597: ARRAY
31598: PPUSH
31599: LD_INT 1
31601: PPUSH
31602: LD_INT 8
31604: NEG
31605: PPUSH
31606: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
31610: LD_EXP 94
31614: PPUSH
31615: CALL_OW 87
// DialogueOn ;
31619: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
31623: LD_EXP 40
31627: PPUSH
31628: LD_STRING D19-JMM-1
31630: PPUSH
31631: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
31635: LD_ADDR_VAR 0 3
31639: PUSH
31640: LD_INT 22
31642: PUSH
31643: LD_INT 1
31645: PUSH
31646: EMPTY
31647: LIST
31648: LIST
31649: PUSH
31650: LD_INT 26
31652: PUSH
31653: LD_INT 1
31655: PUSH
31656: EMPTY
31657: LIST
31658: LIST
31659: PUSH
31660: LD_INT 2
31662: PUSH
31663: LD_INT 25
31665: PUSH
31666: LD_INT 1
31668: PUSH
31669: EMPTY
31670: LIST
31671: LIST
31672: PUSH
31673: LD_INT 25
31675: PUSH
31676: LD_INT 2
31678: PUSH
31679: EMPTY
31680: LIST
31681: LIST
31682: PUSH
31683: LD_INT 25
31685: PUSH
31686: LD_INT 3
31688: PUSH
31689: EMPTY
31690: LIST
31691: LIST
31692: PUSH
31693: LD_INT 25
31695: PUSH
31696: LD_INT 4
31698: PUSH
31699: EMPTY
31700: LIST
31701: LIST
31702: PUSH
31703: LD_INT 25
31705: PUSH
31706: LD_INT 5
31708: PUSH
31709: EMPTY
31710: LIST
31711: LIST
31712: PUSH
31713: LD_INT 25
31715: PUSH
31716: LD_INT 8
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: PUSH
31723: EMPTY
31724: LIST
31725: LIST
31726: LIST
31727: LIST
31728: LIST
31729: LIST
31730: LIST
31731: PUSH
31732: EMPTY
31733: LIST
31734: LIST
31735: LIST
31736: PPUSH
31737: CALL_OW 69
31741: PUSH
31742: LD_EXP 40
31746: PUSH
31747: LD_EXP 41
31751: PUSH
31752: LD_EXP 42
31756: PUSH
31757: LD_EXP 43
31761: PUSH
31762: LD_EXP 44
31766: PUSH
31767: LD_EXP 45
31771: PUSH
31772: LD_EXP 46
31776: PUSH
31777: LD_EXP 47
31781: PUSH
31782: LD_EXP 48
31786: PUSH
31787: LD_EXP 49
31791: PUSH
31792: LD_EXP 50
31796: PUSH
31797: LD_EXP 51
31801: PUSH
31802: LD_EXP 52
31806: PUSH
31807: LD_EXP 53
31811: PUSH
31812: LD_EXP 54
31816: PUSH
31817: LD_EXP 55
31821: PUSH
31822: LD_EXP 56
31826: PUSH
31827: EMPTY
31828: LIST
31829: LIST
31830: LIST
31831: LIST
31832: LIST
31833: LIST
31834: LIST
31835: LIST
31836: LIST
31837: LIST
31838: LIST
31839: LIST
31840: LIST
31841: LIST
31842: LIST
31843: LIST
31844: LIST
31845: DIFF
31846: ST_TO_ADDR
// if tmp2 then
31847: LD_VAR 0 3
31851: IFFALSE 31869
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
31853: LD_VAR 0 3
31857: PUSH
31858: LD_INT 1
31860: ARRAY
31861: PPUSH
31862: LD_STRING D19-Sol1-1
31864: PPUSH
31865: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
31869: LD_EXP 40
31873: PPUSH
31874: LD_STRING D19-JMM-2
31876: PPUSH
31877: CALL_OW 88
// DialogueOff ;
31881: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
31885: LD_VAR 0 2
31889: PUSH
31890: LD_INT 1
31892: ARRAY
31893: PPUSH
31894: LD_VAR 0 2
31898: PUSH
31899: LD_INT 2
31901: ARRAY
31902: PPUSH
31903: LD_INT 1
31905: PPUSH
31906: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
31910: LD_STRING M5
31912: PPUSH
31913: CALL_OW 337
// omarOnMotherLode := false ;
31917: LD_ADDR_VAR 0 4
31921: PUSH
31922: LD_INT 0
31924: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
31925: LD_INT 35
31927: PPUSH
31928: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
31932: LD_EXP 94
31936: PPUSH
31937: LD_INT 215
31939: PPUSH
31940: LD_INT 100
31942: PPUSH
31943: CALL_OW 297
31947: PUSH
31948: LD_INT 10
31950: LESS
31951: PUSH
31952: LD_VAR 0 4
31956: NOT
31957: AND
31958: IFFALSE 31992
// begin omarOnMotherLode := true ;
31960: LD_ADDR_VAR 0 4
31964: PUSH
31965: LD_INT 1
31967: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
31968: LD_EXP 40
31972: PPUSH
31973: LD_STRING D19b-JMM-1
31975: PPUSH
31976: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
31980: LD_EXP 94
31984: PPUSH
31985: LD_STRING DOmarContam-Omar-1
31987: PPUSH
31988: CALL_OW 88
// end ; until IsDead ( Omar ) ;
31992: LD_EXP 94
31996: PPUSH
31997: CALL_OW 301
32001: IFFALSE 31925
// Say ( JMM , D19a-JMM-1 ) ;
32003: LD_EXP 40
32007: PPUSH
32008: LD_STRING D19a-JMM-1
32010: PPUSH
32011: CALL_OW 88
// if Heike then
32015: LD_EXP 95
32019: IFFALSE 32033
// Say ( Heike , D19a-Hke-1 ) ;
32021: LD_EXP 95
32025: PPUSH
32026: LD_STRING D19a-Hke-1
32028: PPUSH
32029: CALL_OW 88
// end ;
32033: PPOPN 4
32035: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
32036: LD_INT 22
32038: PUSH
32039: LD_INT 3
32041: PUSH
32042: EMPTY
32043: LIST
32044: LIST
32045: PUSH
32046: LD_INT 21
32048: PUSH
32049: LD_INT 1
32051: PUSH
32052: EMPTY
32053: LIST
32054: LIST
32055: PUSH
32056: EMPTY
32057: LIST
32058: LIST
32059: PPUSH
32060: CALL_OW 69
32064: PUSH
32065: LD_EXP 21
32069: AND
32070: IFFALSE 32138
32072: GO 32074
32074: DISABLE
32075: LD_INT 0
32077: PPUSH
32078: PPUSH
// begin enable ;
32079: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
32080: LD_ADDR_VAR 0 2
32084: PUSH
32085: LD_INT 25
32087: PPUSH
32088: LD_INT 22
32090: PUSH
32091: LD_INT 3
32093: PUSH
32094: EMPTY
32095: LIST
32096: LIST
32097: PPUSH
32098: CALL_OW 70
32102: ST_TO_ADDR
// if not tmp then
32103: LD_VAR 0 2
32107: NOT
32108: IFFALSE 32112
// exit ;
32110: GO 32138
// for i in tmp do
32112: LD_ADDR_VAR 0 1
32116: PUSH
32117: LD_VAR 0 2
32121: PUSH
32122: FOR_IN
32123: IFFALSE 32136
// RemoveUnit ( i ) ;
32125: LD_VAR 0 1
32129: PPUSH
32130: CALL_OW 64
32134: GO 32122
32136: POP
32137: POP
// end ;
32138: PPOPN 2
32140: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
32141: LD_INT 22
32143: PUSH
32144: LD_INT 7
32146: PUSH
32147: EMPTY
32148: LIST
32149: LIST
32150: PUSH
32151: LD_INT 21
32153: PUSH
32154: LD_INT 1
32156: PUSH
32157: EMPTY
32158: LIST
32159: LIST
32160: PUSH
32161: EMPTY
32162: LIST
32163: LIST
32164: PPUSH
32165: CALL_OW 69
32169: PUSH
32170: LD_INT 6
32172: LESS
32173: IFFALSE 32641
32175: GO 32177
32177: DISABLE
32178: LD_INT 0
32180: PPUSH
32181: PPUSH
// begin MC_Kill ( 1 ) ;
32182: LD_INT 1
32184: PPUSH
32185: CALL 36819 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
32189: LD_INT 7
32191: PPUSH
32192: LD_INT 1
32194: PPUSH
32195: LD_INT 1
32197: PPUSH
32198: LD_INT 1
32200: PPUSH
32201: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
32205: LD_ADDR_VAR 0 1
32209: PUSH
32210: LD_INT 22
32212: PUSH
32213: LD_INT 7
32215: PUSH
32216: EMPTY
32217: LIST
32218: LIST
32219: PUSH
32220: LD_INT 26
32222: PUSH
32223: LD_INT 1
32225: PUSH
32226: EMPTY
32227: LIST
32228: LIST
32229: PUSH
32230: EMPTY
32231: LIST
32232: LIST
32233: PPUSH
32234: CALL_OW 69
32238: PUSH
32239: LD_EXP 76
32243: DIFF
32244: ST_TO_ADDR
// if tmp then
32245: LD_VAR 0 1
32249: IFFALSE 32267
// tmp := tmp [ 1 ] else
32251: LD_ADDR_VAR 0 1
32255: PUSH
32256: LD_VAR 0 1
32260: PUSH
32261: LD_INT 1
32263: ARRAY
32264: ST_TO_ADDR
32265: GO 32303
// begin uc_side := 7 ;
32267: LD_ADDR_OWVAR 20
32271: PUSH
32272: LD_INT 7
32274: ST_TO_ADDR
// uc_nation := 1 ;
32275: LD_ADDR_OWVAR 21
32279: PUSH
32280: LD_INT 1
32282: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
32283: LD_INT 1
32285: PPUSH
32286: LD_INT 8
32288: PPUSH
32289: CALL_OW 384
// tmp := CreateHuman ;
32293: LD_ADDR_VAR 0 1
32297: PUSH
32298: CALL_OW 44
32302: ST_TO_ADDR
// end ; DialogueOn ;
32303: CALL_OW 6
// if IsOK ( Roth ) then
32307: LD_EXP 76
32311: PPUSH
32312: CALL_OW 302
32316: IFFALSE 32330
// Say ( JMM , DAb-JMM-1 ) ;
32318: LD_EXP 40
32322: PPUSH
32323: LD_STRING DAb-JMM-1
32325: PPUSH
32326: CALL_OW 88
// if IsOK ( Roth ) then
32330: LD_EXP 76
32334: PPUSH
32335: CALL_OW 302
32339: IFFALSE 32363
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
32341: LD_EXP 76
32345: PPUSH
32346: LD_STRING DSurrenderAlliance-Roth-1
32348: PPUSH
32349: CALL_OW 88
// RothCaptured := true ;
32353: LD_ADDR_EXP 33
32357: PUSH
32358: LD_INT 1
32360: ST_TO_ADDR
// end else
32361: GO 32375
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
32363: LD_VAR 0 1
32367: PPUSH
32368: LD_STRING DSurrenderAlliance-Sci1-1
32370: PPUSH
32371: CALL_OW 88
// DialogueOff ;
32375: CALL_OW 7
// allianceDestroyed := true ;
32379: LD_ADDR_EXP 23
32383: PUSH
32384: LD_INT 1
32386: ST_TO_ADDR
// if capturedUnit = 0 then
32387: LD_EXP 34
32391: PUSH
32392: LD_INT 0
32394: EQUAL
32395: IFFALSE 32404
// SetAchievement ( ACH_ALLIANCE ) ;
32397: LD_STRING ACH_ALLIANCE
32399: PPUSH
32400: CALL_OW 543
// if trueAmericans then
32404: LD_EXP 35
32408: IFFALSE 32484
// begin if trueAmericans = 1 then
32410: LD_EXP 35
32414: PUSH
32415: LD_INT 1
32417: EQUAL
32418: IFFALSE 32434
// Say ( JMM , DAb-JMM-1a ) else
32420: LD_EXP 40
32424: PPUSH
32425: LD_STRING DAb-JMM-1a
32427: PPUSH
32428: CALL_OW 88
32432: GO 32446
// Say ( JMM , DAb-JMM-1b ) ;
32434: LD_EXP 40
32438: PPUSH
32439: LD_STRING DAb-JMM-1b
32441: PPUSH
32442: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
32446: LD_EXP 35
32450: PPUSH
32451: CALL_OW 87
// for i in trueAmericans do
32455: LD_ADDR_VAR 0 2
32459: PUSH
32460: LD_EXP 35
32464: PUSH
32465: FOR_IN
32466: IFFALSE 32482
// SetSide ( i , 1 ) ;
32468: LD_VAR 0 2
32472: PPUSH
32473: LD_INT 1
32475: PPUSH
32476: CALL_OW 235
32480: GO 32465
32482: POP
32483: POP
// end ; repeat wait ( 0 0$1 ) ;
32484: LD_INT 35
32486: PPUSH
32487: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
32491: LD_ADDR_VAR 0 2
32495: PUSH
32496: LD_INT 22
32498: PUSH
32499: LD_INT 7
32501: PUSH
32502: EMPTY
32503: LIST
32504: LIST
32505: PUSH
32506: LD_INT 21
32508: PUSH
32509: LD_INT 1
32511: PUSH
32512: EMPTY
32513: LIST
32514: LIST
32515: PUSH
32516: EMPTY
32517: LIST
32518: LIST
32519: PPUSH
32520: CALL_OW 69
32524: PUSH
32525: FOR_IN
32526: IFFALSE 32608
// begin if IsInUnit ( i ) then
32528: LD_VAR 0 2
32532: PPUSH
32533: CALL_OW 310
32537: IFFALSE 32548
// ComExitBuilding ( i ) ;
32539: LD_VAR 0 2
32543: PPUSH
32544: CALL_OW 122
// if IsDriver ( i ) then
32548: LD_VAR 0 2
32552: PPUSH
32553: CALL 102292 0 1
32557: IFFALSE 32568
// ComExitVehicle ( i ) ;
32559: LD_VAR 0 2
32563: PPUSH
32564: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
32568: LD_VAR 0 2
32572: PPUSH
32573: LD_INT 26
32575: PPUSH
32576: CALL_OW 308
32580: NOT
32581: IFFALSE 32597
// AddComMoveToArea ( i , allianceEscapeArea ) else
32583: LD_VAR 0 2
32587: PPUSH
32588: LD_INT 26
32590: PPUSH
32591: CALL_OW 173
32595: GO 32606
// RemoveUnit ( i ) ;
32597: LD_VAR 0 2
32601: PPUSH
32602: CALL_OW 64
// end ;
32606: GO 32525
32608: POP
32609: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
32610: LD_INT 22
32612: PUSH
32613: LD_INT 7
32615: PUSH
32616: EMPTY
32617: LIST
32618: LIST
32619: PUSH
32620: LD_INT 21
32622: PUSH
32623: LD_INT 1
32625: PUSH
32626: EMPTY
32627: LIST
32628: LIST
32629: PUSH
32630: EMPTY
32631: LIST
32632: LIST
32633: PPUSH
32634: CALL_OW 69
32638: NOT
32639: IFFALSE 32484
// end ;
32641: PPOPN 2
32643: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
32644: LD_INT 0
32646: PPUSH
32647: PPUSH
// if not unit then
32648: LD_VAR 0 1
32652: NOT
32653: IFFALSE 32657
// exit ;
32655: GO 34155
// DoNotAttack ( 7 , unit ) ;
32657: LD_INT 7
32659: PPUSH
32660: LD_VAR 0 1
32664: PPUSH
32665: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
32669: LD_VAR 0 1
32673: PPUSH
32674: LD_INT 260
32676: PPUSH
32677: LD_INT 235
32679: PPUSH
32680: LD_INT 3
32682: PPUSH
32683: LD_INT 1
32685: PPUSH
32686: CALL_OW 483
// SetSide ( unit , 4 ) ;
32690: LD_VAR 0 1
32694: PPUSH
32695: LD_INT 4
32697: PPUSH
32698: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
32702: LD_ADDR_EXP 34
32706: PUSH
32707: LD_EXP 34
32711: PUSH
32712: LD_INT 1
32714: PLUS
32715: ST_TO_ADDR
// wait ( 0 0$2 ) ;
32716: LD_INT 70
32718: PPUSH
32719: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
32723: LD_INT 260
32725: PPUSH
32726: LD_INT 235
32728: PPUSH
32729: LD_INT 1
32731: PPUSH
32732: LD_INT 8
32734: NEG
32735: PPUSH
32736: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
32740: LD_VAR 0 1
32744: PPUSH
32745: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
32749: LD_VAR 0 1
32753: PPUSH
32754: LD_EXP 76
32758: PPUSH
32759: CALL_OW 119
// DialogueOn ;
32763: CALL_OW 6
// case unit of JMM :
32767: LD_VAR 0 1
32771: PUSH
32772: LD_EXP 40
32776: DOUBLE
32777: EQUAL
32778: IFTRUE 32782
32780: GO 32797
32782: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
32783: LD_EXP 40
32787: PPUSH
32788: LD_STRING DA1-JMM-1
32790: PPUSH
32791: CALL_OW 91
32795: GO 33239
32797: LD_EXP 41
32801: DOUBLE
32802: EQUAL
32803: IFTRUE 32807
32805: GO 32822
32807: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
32808: LD_EXP 41
32812: PPUSH
32813: LD_STRING DA1-Joan-1
32815: PPUSH
32816: CALL_OW 91
32820: GO 33239
32822: LD_EXP 43
32826: DOUBLE
32827: EQUAL
32828: IFTRUE 32832
32830: GO 32847
32832: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
32833: LD_EXP 43
32837: PPUSH
32838: LD_STRING DA1-Lisa-1
32840: PPUSH
32841: CALL_OW 91
32845: GO 33239
32847: LD_EXP 44
32851: DOUBLE
32852: EQUAL
32853: IFTRUE 32857
32855: GO 32872
32857: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
32858: LD_EXP 44
32862: PPUSH
32863: LD_STRING DA1-Don-1
32865: PPUSH
32866: CALL_OW 91
32870: GO 33239
32872: LD_EXP 51
32876: DOUBLE
32877: EQUAL
32878: IFTRUE 32882
32880: GO 32897
32882: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
32883: LD_EXP 51
32887: PPUSH
32888: LD_STRING DA1-Corn-1
32890: PPUSH
32891: CALL_OW 91
32895: GO 33239
32897: LD_EXP 47
32901: DOUBLE
32902: EQUAL
32903: IFTRUE 32907
32905: GO 32922
32907: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
32908: LD_EXP 47
32912: PPUSH
32913: LD_STRING DA1-Den-1
32915: PPUSH
32916: CALL_OW 91
32920: GO 33239
32922: LD_EXP 45
32926: DOUBLE
32927: EQUAL
32928: IFTRUE 32932
32930: GO 32947
32932: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
32933: LD_EXP 45
32937: PPUSH
32938: LD_STRING DA1-Bobby-1
32940: PPUSH
32941: CALL_OW 91
32945: GO 33239
32947: LD_EXP 49
32951: DOUBLE
32952: EQUAL
32953: IFTRUE 32957
32955: GO 32972
32957: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
32958: LD_EXP 49
32962: PPUSH
32963: LD_STRING DA1-Glad-1
32965: PPUSH
32966: CALL_OW 91
32970: GO 33239
32972: LD_EXP 46
32976: DOUBLE
32977: EQUAL
32978: IFTRUE 32982
32980: GO 32997
32982: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
32983: LD_EXP 46
32987: PPUSH
32988: LD_STRING DA1-Cyrus-1
32990: PPUSH
32991: CALL_OW 91
32995: GO 33239
32997: LD_EXP 42
33001: DOUBLE
33002: EQUAL
33003: IFTRUE 33007
33005: GO 33022
33007: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
33008: LD_EXP 42
33012: PPUSH
33013: LD_STRING DA1-Huck-1
33015: PPUSH
33016: CALL_OW 91
33020: GO 33239
33022: LD_EXP 56
33026: DOUBLE
33027: EQUAL
33028: IFTRUE 33032
33030: GO 33047
33032: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
33033: LD_EXP 56
33037: PPUSH
33038: LD_STRING DA1-Huck-1
33040: PPUSH
33041: CALL_OW 91
33045: GO 33239
33047: LD_EXP 48
33051: DOUBLE
33052: EQUAL
33053: IFTRUE 33057
33055: GO 33072
33057: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
33058: LD_EXP 48
33062: PPUSH
33063: LD_STRING DA1-Brown-1
33065: PPUSH
33066: CALL_OW 91
33070: GO 33239
33072: LD_EXP 52
33076: DOUBLE
33077: EQUAL
33078: IFTRUE 33082
33080: GO 33097
33082: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
33083: LD_EXP 52
33087: PPUSH
33088: LD_STRING DA1-Gary-1
33090: PPUSH
33091: CALL_OW 91
33095: GO 33239
33097: LD_EXP 55
33101: DOUBLE
33102: EQUAL
33103: IFTRUE 33107
33105: GO 33122
33107: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
33108: LD_EXP 55
33112: PPUSH
33113: LD_STRING DA1-Con-1
33115: PPUSH
33116: CALL_OW 91
33120: GO 33239
33122: LD_EXP 61
33126: DOUBLE
33127: EQUAL
33128: IFTRUE 33132
33130: GO 33147
33132: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
33133: LD_EXP 61
33137: PPUSH
33138: LD_STRING DA1-Kurt-1
33140: PPUSH
33141: CALL_OW 91
33145: GO 33239
33147: LD_EXP 54
33151: DOUBLE
33152: EQUAL
33153: IFTRUE 33157
33155: GO 33172
33157: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
33158: LD_EXP 54
33162: PPUSH
33163: LD_STRING DA1-Yam-1
33165: PPUSH
33166: CALL_OW 91
33170: GO 33239
33172: LD_EXP 53
33176: DOUBLE
33177: EQUAL
33178: IFTRUE 33182
33180: GO 33197
33182: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
33183: LD_EXP 53
33187: PPUSH
33188: LD_STRING DA1-Frank-1
33190: PPUSH
33191: CALL_OW 91
33195: GO 33239
33197: POP
// begin if GetSex ( unit ) = sex_male then
33198: LD_VAR 0 1
33202: PPUSH
33203: CALL_OW 258
33207: PUSH
33208: LD_INT 1
33210: EQUAL
33211: IFFALSE 33227
// ForceSay ( unit , DA1-Sol1-1 ) else
33213: LD_VAR 0 1
33217: PPUSH
33218: LD_STRING DA1-Sol1-1
33220: PPUSH
33221: CALL_OW 91
33225: GO 33239
// ForceSay ( unit , DA1-FSol1-1 ) ;
33227: LD_VAR 0 1
33231: PPUSH
33232: LD_STRING DA1-FSol1-1
33234: PPUSH
33235: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
33239: LD_EXP 76
33243: PPUSH
33244: LD_STRING DA-Roth-1
33246: PPUSH
33247: CALL_OW 88
// if capturedUnit = 1 then
33251: LD_EXP 34
33255: PUSH
33256: LD_INT 1
33258: EQUAL
33259: IFFALSE 33287
// begin Say ( Simms , DA-Sim-1 ) ;
33261: LD_EXP 77
33265: PPUSH
33266: LD_STRING DA-Sim-1
33268: PPUSH
33269: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
33273: LD_EXP 76
33277: PPUSH
33278: LD_STRING DA-Roth-2
33280: PPUSH
33281: CALL_OW 88
// end else
33285: GO 33299
// Say ( Simms , DA-Sim-2 ) ;
33287: LD_EXP 77
33291: PPUSH
33292: LD_STRING DA-Sim-2
33294: PPUSH
33295: CALL_OW 88
// case unit of JMM :
33299: LD_VAR 0 1
33303: PUSH
33304: LD_EXP 40
33308: DOUBLE
33309: EQUAL
33310: IFTRUE 33314
33312: GO 33329
33314: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
33315: LD_EXP 40
33319: PPUSH
33320: LD_STRING DA1-JMM-1a
33322: PPUSH
33323: CALL_OW 91
33327: GO 33836
33329: LD_EXP 41
33333: DOUBLE
33334: EQUAL
33335: IFTRUE 33339
33337: GO 33354
33339: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
33340: LD_EXP 41
33344: PPUSH
33345: LD_STRING DA1-Joan-1a
33347: PPUSH
33348: CALL_OW 91
33352: GO 33836
33354: LD_EXP 43
33358: DOUBLE
33359: EQUAL
33360: IFTRUE 33364
33362: GO 33379
33364: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
33365: LD_EXP 43
33369: PPUSH
33370: LD_STRING DA1-Lisa-1a
33372: PPUSH
33373: CALL_OW 91
33377: GO 33836
33379: LD_EXP 44
33383: DOUBLE
33384: EQUAL
33385: IFTRUE 33389
33387: GO 33404
33389: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
33390: LD_EXP 44
33394: PPUSH
33395: LD_STRING DA1-Don-1a
33397: PPUSH
33398: CALL_OW 91
33402: GO 33836
33404: LD_EXP 51
33408: DOUBLE
33409: EQUAL
33410: IFTRUE 33414
33412: GO 33429
33414: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
33415: LD_EXP 51
33419: PPUSH
33420: LD_STRING DA1-Corn-1a
33422: PPUSH
33423: CALL_OW 91
33427: GO 33836
33429: LD_EXP 47
33433: DOUBLE
33434: EQUAL
33435: IFTRUE 33439
33437: GO 33454
33439: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
33440: LD_EXP 47
33444: PPUSH
33445: LD_STRING DA1-Den-1a
33447: PPUSH
33448: CALL_OW 91
33452: GO 33836
33454: LD_EXP 45
33458: DOUBLE
33459: EQUAL
33460: IFTRUE 33464
33462: GO 33479
33464: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
33465: LD_EXP 45
33469: PPUSH
33470: LD_STRING DA1-Bobby-1a
33472: PPUSH
33473: CALL_OW 91
33477: GO 33836
33479: LD_EXP 49
33483: DOUBLE
33484: EQUAL
33485: IFTRUE 33489
33487: GO 33504
33489: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
33490: LD_EXP 49
33494: PPUSH
33495: LD_STRING DA1-Glad-1a
33497: PPUSH
33498: CALL_OW 91
33502: GO 33836
33504: LD_EXP 46
33508: DOUBLE
33509: EQUAL
33510: IFTRUE 33514
33512: GO 33529
33514: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
33515: LD_EXP 46
33519: PPUSH
33520: LD_STRING DA1-Cyrus-1a
33522: PPUSH
33523: CALL_OW 91
33527: GO 33836
33529: LD_EXP 42
33533: DOUBLE
33534: EQUAL
33535: IFTRUE 33539
33537: GO 33554
33539: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
33540: LD_EXP 42
33544: PPUSH
33545: LD_STRING DA1-Huck-1a
33547: PPUSH
33548: CALL_OW 91
33552: GO 33836
33554: LD_EXP 56
33558: DOUBLE
33559: EQUAL
33560: IFTRUE 33564
33562: GO 33579
33564: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
33565: LD_EXP 56
33569: PPUSH
33570: LD_STRING DA1-Huck-1a
33572: PPUSH
33573: CALL_OW 91
33577: GO 33836
33579: LD_EXP 48
33583: DOUBLE
33584: EQUAL
33585: IFTRUE 33589
33587: GO 33604
33589: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
33590: LD_EXP 48
33594: PPUSH
33595: LD_STRING DA1-Brown-1a
33597: PPUSH
33598: CALL_OW 91
33602: GO 33836
33604: LD_EXP 52
33608: DOUBLE
33609: EQUAL
33610: IFTRUE 33614
33612: GO 33629
33614: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
33615: LD_EXP 52
33619: PPUSH
33620: LD_STRING DA1-Gary-1a
33622: PPUSH
33623: CALL_OW 91
33627: GO 33836
33629: LD_EXP 55
33633: DOUBLE
33634: EQUAL
33635: IFTRUE 33639
33637: GO 33654
33639: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
33640: LD_EXP 55
33644: PPUSH
33645: LD_STRING DA1-Con-1a
33647: PPUSH
33648: CALL_OW 91
33652: GO 33836
33654: LD_EXP 61
33658: DOUBLE
33659: EQUAL
33660: IFTRUE 33664
33662: GO 33679
33664: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
33665: LD_EXP 61
33669: PPUSH
33670: LD_STRING DA1-Kurt-1a
33672: PPUSH
33673: CALL_OW 91
33677: GO 33836
33679: LD_EXP 54
33683: DOUBLE
33684: EQUAL
33685: IFTRUE 33689
33687: GO 33704
33689: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
33690: LD_EXP 54
33694: PPUSH
33695: LD_STRING DA1-Yam-1a
33697: PPUSH
33698: CALL_OW 91
33702: GO 33836
33704: LD_EXP 53
33708: DOUBLE
33709: EQUAL
33710: IFTRUE 33714
33712: GO 33729
33714: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
33715: LD_EXP 53
33719: PPUSH
33720: LD_STRING DA1-Frank-1a
33722: PPUSH
33723: CALL_OW 91
33727: GO 33836
33729: POP
// begin join := rand ( 0 , 1 ) ;
33730: LD_ADDR_VAR 0 3
33734: PUSH
33735: LD_INT 0
33737: PPUSH
33738: LD_INT 1
33740: PPUSH
33741: CALL_OW 12
33745: ST_TO_ADDR
// if join then
33746: LD_VAR 0 3
33750: IFFALSE 33795
// begin if GetSex ( unit ) = sex_male then
33752: LD_VAR 0 1
33756: PPUSH
33757: CALL_OW 258
33761: PUSH
33762: LD_INT 1
33764: EQUAL
33765: IFFALSE 33781
// ForceSay ( unit , DA1-Sol1-1b ) else
33767: LD_VAR 0 1
33771: PPUSH
33772: LD_STRING DA1-Sol1-1b
33774: PPUSH
33775: CALL_OW 91
33779: GO 33793
// ForceSay ( unit , DA1-FSol1-1b ) ;
33781: LD_VAR 0 1
33785: PPUSH
33786: LD_STRING DA1-FSol1-1b
33788: PPUSH
33789: CALL_OW 91
// end else
33793: GO 33836
// begin if GetSex ( unit ) = sex_male then
33795: LD_VAR 0 1
33799: PPUSH
33800: CALL_OW 258
33804: PUSH
33805: LD_INT 1
33807: EQUAL
33808: IFFALSE 33824
// ForceSay ( unit , DA1-Sol1-1a ) else
33810: LD_VAR 0 1
33814: PPUSH
33815: LD_STRING DA1-Sol1-1a
33817: PPUSH
33818: CALL_OW 91
33822: GO 33836
// ForceSay ( unit , DA1-FSol1-1a ) ;
33824: LD_VAR 0 1
33828: PPUSH
33829: LD_STRING DA1-FSol1-1a
33831: PPUSH
33832: CALL_OW 91
// end ; end ; end ; if unit = JMM then
33836: LD_VAR 0 1
33840: PUSH
33841: LD_EXP 40
33845: EQUAL
33846: IFFALSE 33857
// begin YouLost ( JMMCaptured ) ;
33848: LD_STRING JMMCaptured
33850: PPUSH
33851: CALL_OW 104
// exit ;
33855: GO 34155
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
33857: LD_VAR 0 1
33861: PUSH
33862: LD_EXP 44
33866: PUSH
33867: LD_EXP 47
33871: PUSH
33872: LD_EXP 45
33876: PUSH
33877: LD_EXP 42
33881: PUSH
33882: LD_EXP 56
33886: PUSH
33887: LD_EXP 48
33891: PUSH
33892: LD_EXP 54
33896: PUSH
33897: EMPTY
33898: LIST
33899: LIST
33900: LIST
33901: LIST
33902: LIST
33903: LIST
33904: LIST
33905: IN
33906: PUSH
33907: LD_VAR 0 3
33911: OR
33912: IFFALSE 34011
// begin Say ( Roth , DA-Roth-3 ) ;
33914: LD_EXP 76
33918: PPUSH
33919: LD_STRING DA-Roth-3
33921: PPUSH
33922: CALL_OW 88
// SetSide ( unit , 7 ) ;
33926: LD_VAR 0 1
33930: PPUSH
33931: LD_INT 7
33933: PPUSH
33934: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
33938: LD_ADDR_EXP 99
33942: PUSH
33943: LD_EXP 99
33947: PPUSH
33948: LD_INT 1
33950: PPUSH
33951: LD_EXP 99
33955: PUSH
33956: LD_INT 1
33958: ARRAY
33959: PUSH
33960: LD_VAR 0 1
33964: ADD
33965: PPUSH
33966: CALL_OW 1
33970: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
33971: LD_INT 260
33973: PPUSH
33974: LD_INT 235
33976: PPUSH
33977: LD_INT 1
33979: PPUSH
33980: CALL_OW 331
// SetLives ( unit , 1000 ) ;
33984: LD_VAR 0 1
33988: PPUSH
33989: LD_INT 1000
33991: PPUSH
33992: CALL_OW 234
// DialogueOff ;
33996: CALL_OW 7
// ComFree ( unit ) ;
34000: LD_VAR 0 1
34004: PPUSH
34005: CALL_OW 139
// end else
34009: GO 34092
// begin Say ( Roth , DA-Roth-3a ) ;
34011: LD_EXP 76
34015: PPUSH
34016: LD_STRING DA-Roth-3a
34018: PPUSH
34019: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
34023: LD_ADDR_EXP 35
34027: PUSH
34028: LD_EXP 35
34032: PUSH
34033: LD_VAR 0 1
34037: ADD
34038: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
34039: LD_INT 260
34041: PPUSH
34042: LD_INT 235
34044: PPUSH
34045: LD_INT 1
34047: PPUSH
34048: CALL_OW 331
// SetLives ( unit , 1000 ) ;
34052: LD_VAR 0 1
34056: PPUSH
34057: LD_INT 1000
34059: PPUSH
34060: CALL_OW 234
// DialogueOff ;
34064: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
34068: LD_VAR 0 1
34072: PPUSH
34073: LD_INT 272
34075: PPUSH
34076: LD_INT 254
34078: PPUSH
34079: CALL_OW 111
// AddComHold ( unit ) ;
34083: LD_VAR 0 1
34087: PPUSH
34088: CALL_OW 200
// end ; if capturedUnit = 1 then
34092: LD_EXP 34
34096: PUSH
34097: LD_INT 1
34099: EQUAL
34100: IFFALSE 34155
// begin DialogueOn ;
34102: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
34106: LD_EXP 40
34110: PPUSH
34111: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
34115: LD_EXP 40
34119: PPUSH
34120: LD_STRING DAa-JMM-1
34122: PPUSH
34123: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
34127: LD_EXP 40
34131: PPUSH
34132: LD_STRING DAa-JMM-1a
34134: PPUSH
34135: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
34139: LD_EXP 40
34143: PPUSH
34144: LD_STRING DAa-JMM-1b
34146: PPUSH
34147: CALL_OW 88
// DialogueOff ;
34151: CALL_OW 7
// end ; end ;
34155: LD_VAR 0 2
34159: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
34160: LD_EXP 15
34164: PUSH
34165: LD_INT 13
34167: GREATEREQUAL
34168: PUSH
34169: LD_INT 22
34171: PUSH
34172: LD_INT 2
34174: PUSH
34175: EMPTY
34176: LIST
34177: LIST
34178: PUSH
34179: LD_INT 21
34181: PUSH
34182: LD_INT 1
34184: PUSH
34185: EMPTY
34186: LIST
34187: LIST
34188: PUSH
34189: EMPTY
34190: LIST
34191: LIST
34192: PPUSH
34193: CALL_OW 69
34197: PUSH
34198: LD_INT 0
34200: EQUAL
34201: AND
34202: PUSH
34203: LD_INT 22
34205: PUSH
34206: LD_INT 2
34208: PUSH
34209: EMPTY
34210: LIST
34211: LIST
34212: PUSH
34213: LD_INT 33
34215: PUSH
34216: LD_INT 5
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: LD_INT 21
34225: PUSH
34226: LD_INT 2
34228: PUSH
34229: EMPTY
34230: LIST
34231: LIST
34232: PUSH
34233: LD_INT 50
34235: PUSH
34236: EMPTY
34237: LIST
34238: PUSH
34239: EMPTY
34240: LIST
34241: LIST
34242: LIST
34243: LIST
34244: PPUSH
34245: CALL_OW 69
34249: PUSH
34250: LD_INT 0
34252: EQUAL
34253: AND
34254: PUSH
34255: LD_EXP 21
34259: AND
34260: PUSH
34261: LD_EXP 22
34265: AND
34266: PUSH
34267: LD_EXP 23
34271: AND
34272: IFFALSE 34961
34274: GO 34276
34276: DISABLE
34277: LD_INT 0
34279: PPUSH
34280: PPUSH
34281: PPUSH
// begin m1 := false ;
34282: LD_ADDR_VAR 0 1
34286: PUSH
34287: LD_INT 0
34289: ST_TO_ADDR
// m2 := false ;
34290: LD_ADDR_VAR 0 2
34294: PUSH
34295: LD_INT 0
34297: ST_TO_ADDR
// m3 := false ;
34298: LD_ADDR_VAR 0 3
34302: PUSH
34303: LD_INT 0
34305: ST_TO_ADDR
// if not bombExploded then
34306: LD_EXP 37
34310: NOT
34311: IFFALSE 34320
// SetAchievement ( ACH_SIBROCKET ) ;
34313: LD_STRING ACH_SIBROCKET
34315: PPUSH
34316: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
34320: LD_EXP 63
34324: PPUSH
34325: CALL_OW 255
34329: PUSH
34330: LD_INT 1
34332: EQUAL
34333: PUSH
34334: LD_EXP 63
34338: PPUSH
34339: CALL_OW 302
34343: AND
34344: IFFALSE 34360
// begin wait ( 3 ) ;
34346: LD_INT 3
34348: PPUSH
34349: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
34353: LD_STRING ACH_OPO
34355: PPUSH
34356: CALL_OW 543
// end ; if tick <= 120 120$00 then
34360: LD_OWVAR 1
34364: PUSH
34365: LD_INT 252000
34367: LESSEQUAL
34368: IFFALSE 34384
// begin wait ( 3 ) ;
34370: LD_INT 3
34372: PPUSH
34373: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
34377: LD_STRING ACH_ASPEED_15
34379: PPUSH
34380: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
34384: LD_EXP 40
34388: PPUSH
34389: CALL_OW 87
// music_class := 5 ;
34393: LD_ADDR_OWVAR 72
34397: PUSH
34398: LD_INT 5
34400: ST_TO_ADDR
// music_nat := 5 ;
34401: LD_ADDR_OWVAR 71
34405: PUSH
34406: LD_INT 5
34408: ST_TO_ADDR
// DialogueOn ;
34409: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
34413: LD_EXP 40
34417: PPUSH
34418: LD_STRING D20-JMM-1
34420: PPUSH
34421: CALL_OW 88
// if IsOK ( Joan ) then
34425: LD_EXP 41
34429: PPUSH
34430: CALL_OW 302
34434: IFFALSE 34448
// Say ( Joan , D20-Joan-1 ) ;
34436: LD_EXP 41
34440: PPUSH
34441: LD_STRING D20-Joan-1
34443: PPUSH
34444: CALL_OW 88
// if IsOk ( Lisa ) then
34448: LD_EXP 43
34452: PPUSH
34453: CALL_OW 302
34457: IFFALSE 34471
// Say ( Lisa , D20-Lisa-1 ) ;
34459: LD_EXP 43
34463: PPUSH
34464: LD_STRING D20-Lisa-1
34466: PPUSH
34467: CALL_OW 88
// if IsOk ( Donaldson ) then
34471: LD_EXP 44
34475: PPUSH
34476: CALL_OW 302
34480: IFFALSE 34494
// Say ( Donaldson , D20-Don-1 ) ;
34482: LD_EXP 44
34486: PPUSH
34487: LD_STRING D20-Don-1
34489: PPUSH
34490: CALL_OW 88
// if IsOK ( Cornel ) then
34494: LD_EXP 51
34498: PPUSH
34499: CALL_OW 302
34503: IFFALSE 34517
// Say ( Cornel , D20-Corn-1 ) ;
34505: LD_EXP 51
34509: PPUSH
34510: LD_STRING D20-Corn-1
34512: PPUSH
34513: CALL_OW 88
// if IsOk ( Denis ) then
34517: LD_EXP 47
34521: PPUSH
34522: CALL_OW 302
34526: IFFALSE 34540
// Say ( Denis , D20-Den-1 ) ;
34528: LD_EXP 47
34532: PPUSH
34533: LD_STRING D20-Den-1
34535: PPUSH
34536: CALL_OW 88
// if IsOk ( Bobby ) then
34540: LD_EXP 45
34544: PPUSH
34545: CALL_OW 302
34549: IFFALSE 34563
// Say ( Bobby , D20-Bobby-1 ) ;
34551: LD_EXP 45
34555: PPUSH
34556: LD_STRING D20-Bobby-1
34558: PPUSH
34559: CALL_OW 88
// if IsOk ( Gladstone ) then
34563: LD_EXP 49
34567: PPUSH
34568: CALL_OW 302
34572: IFFALSE 34586
// Say ( Gladstone , D20-Glad-1 ) ;
34574: LD_EXP 49
34578: PPUSH
34579: LD_STRING D20-Glad-1
34581: PPUSH
34582: CALL_OW 88
// if IsOk ( Cyrus ) then
34586: LD_EXP 46
34590: PPUSH
34591: CALL_OW 302
34595: IFFALSE 34609
// Say ( Cyrus , D20-Cyrus-1 ) ;
34597: LD_EXP 46
34601: PPUSH
34602: LD_STRING D20-Cyrus-1
34604: PPUSH
34605: CALL_OW 88
// if IsOk ( Stevens ) then
34609: LD_EXP 42
34613: PPUSH
34614: CALL_OW 302
34618: IFFALSE 34632
// Say ( Stevens , D20-Huck-1 ) ;
34620: LD_EXP 42
34624: PPUSH
34625: LD_STRING D20-Huck-1
34627: PPUSH
34628: CALL_OW 88
// if IsOk ( Brown ) then
34632: LD_EXP 48
34636: PPUSH
34637: CALL_OW 302
34641: IFFALSE 34655
// Say ( Brown , D20-Brown-1 ) ;
34643: LD_EXP 48
34647: PPUSH
34648: LD_STRING D20-Brown-1
34650: PPUSH
34651: CALL_OW 88
// if IsOk ( Gary ) then
34655: LD_EXP 52
34659: PPUSH
34660: CALL_OW 302
34664: IFFALSE 34678
// Say ( Gary , D20-Gary-1 ) ;
34666: LD_EXP 52
34670: PPUSH
34671: LD_STRING D20-Gary-1
34673: PPUSH
34674: CALL_OW 88
// if IsOk ( Connie ) then
34678: LD_EXP 55
34682: PPUSH
34683: CALL_OW 302
34687: IFFALSE 34701
// Say ( Connie , D20-Con-1 ) ;
34689: LD_EXP 55
34693: PPUSH
34694: LD_STRING D20-Con-1
34696: PPUSH
34697: CALL_OW 88
// if IsOk ( Kurt ) then
34701: LD_EXP 61
34705: PPUSH
34706: CALL_OW 302
34710: IFFALSE 34724
// Say ( Kurt , D20-Kurt-1 ) ;
34712: LD_EXP 61
34716: PPUSH
34717: LD_STRING D20-Kurt-1
34719: PPUSH
34720: CALL_OW 88
// if IsOk ( Kikuchi ) then
34724: LD_EXP 54
34728: PPUSH
34729: CALL_OW 302
34733: IFFALSE 34747
// Say ( Kikuchi , D20-Yam-1 ) ;
34735: LD_EXP 54
34739: PPUSH
34740: LD_STRING D20-Yam-1
34742: PPUSH
34743: CALL_OW 88
// if IsOk ( Frank ) then
34747: LD_EXP 53
34751: PPUSH
34752: CALL_OW 302
34756: IFFALSE 34770
// Say ( Frank , D20-Frank-1 ) ;
34758: LD_EXP 53
34762: PPUSH
34763: LD_STRING D20-Frank-1
34765: PPUSH
34766: CALL_OW 88
// DialogueOff ;
34770: CALL_OW 7
// if RothCaptured then
34774: LD_EXP 33
34778: IFFALSE 34800
// begin m1 := true ;
34780: LD_ADDR_VAR 0 1
34784: PUSH
34785: LD_INT 1
34787: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
34788: LD_STRING Roth
34790: PPUSH
34791: LD_INT 1
34793: PPUSH
34794: CALL_OW 101
// end else
34798: GO 34811
// AddMedal ( Roth , - 1 ) ;
34800: LD_STRING Roth
34802: PPUSH
34803: LD_INT 1
34805: NEG
34806: PPUSH
34807: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish then
34811: LD_EXP 25
34815: NOT
34816: PUSH
34817: LD_EXP 27
34821: OR
34822: IFFALSE 34844
// begin m2 := true ;
34824: LD_ADDR_VAR 0 2
34828: PUSH
34829: LD_INT 1
34831: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
34832: LD_STRING Project
34834: PPUSH
34835: LD_INT 1
34837: PPUSH
34838: CALL_OW 101
// end else
34842: GO 34855
// AddMedal ( Project , - 1 ) ;
34844: LD_STRING Project
34846: PPUSH
34847: LD_INT 1
34849: NEG
34850: PPUSH
34851: CALL_OW 101
// if lostCounter = 0 then
34855: LD_EXP 32
34859: PUSH
34860: LD_INT 0
34862: EQUAL
34863: IFFALSE 34885
// begin m3 := true ;
34865: LD_ADDR_VAR 0 3
34869: PUSH
34870: LD_INT 1
34872: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
34873: LD_STRING NoLosses
34875: PPUSH
34876: LD_INT 1
34878: PPUSH
34879: CALL_OW 101
// end else
34883: GO 34896
// AddMedal ( NoLosses , - 1 ) ;
34885: LD_STRING NoLosses
34887: PPUSH
34888: LD_INT 1
34890: NEG
34891: PPUSH
34892: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
34896: LD_VAR 0 1
34900: PUSH
34901: LD_VAR 0 2
34905: AND
34906: PUSH
34907: LD_VAR 0 3
34911: AND
34912: PUSH
34913: LD_OWVAR 67
34917: PUSH
34918: LD_INT 3
34920: GREATEREQUAL
34921: AND
34922: IFFALSE 34934
// SetAchievementEX ( ACH_AMER , 15 ) ;
34924: LD_STRING ACH_AMER
34926: PPUSH
34927: LD_INT 15
34929: PPUSH
34930: CALL_OW 564
// GiveMedals ( MAIN ) ;
34934: LD_STRING MAIN
34936: PPUSH
34937: CALL_OW 102
// music_class := 4 ;
34941: LD_ADDR_OWVAR 72
34945: PUSH
34946: LD_INT 4
34948: ST_TO_ADDR
// music_nat := 1 ;
34949: LD_ADDR_OWVAR 71
34953: PUSH
34954: LD_INT 1
34956: ST_TO_ADDR
// YouWin ;
34957: CALL_OW 103
// end ; end_of_file
34961: PPOPN 3
34963: END
// export function CustomEvent ( event ) ; begin
34964: LD_INT 0
34966: PPUSH
// end ;
34967: LD_VAR 0 2
34971: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
34972: LD_VAR 0 1
34976: PUSH
34977: LD_INT 1
34979: EQUAL
34980: PUSH
34981: LD_VAR 0 2
34985: PUSH
34986: LD_INT 4
34988: EQUAL
34989: AND
34990: PUSH
34991: LD_EXP 59
34995: PPUSH
34996: CALL_OW 300
35000: AND
35001: IFFALSE 35017
// begin wait ( 0 0$2 ) ;
35003: LD_INT 70
35005: PPUSH
35006: CALL_OW 67
// YouLost ( Dismissed ) ;
35010: LD_STRING Dismissed
35012: PPUSH
35013: CALL_OW 104
// end ; end ;
35017: PPOPN 2
35019: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
35020: LD_VAR 0 2
35024: PPUSH
35025: LD_VAR 0 3
35029: PPUSH
35030: LD_INT 18
35032: PPUSH
35033: CALL_OW 309
35037: IFFALSE 35046
// YouLost ( Motherlode3 ) ;
35039: LD_STRING Motherlode3
35041: PPUSH
35042: CALL_OW 104
// end ;
35046: PPOPN 3
35048: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
35049: LD_EXP 27
35053: NOT
35054: IFFALSE 35064
// behemothDone := true ;
35056: LD_ADDR_EXP 28
35060: PUSH
35061: LD_INT 1
35063: ST_TO_ADDR
// end ;
35064: PPOPN 1
35066: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
35067: LD_VAR 0 1
35071: PPUSH
35072: CALL_OW 255
35076: PUSH
35077: LD_INT 1
35079: EQUAL
35080: IFFALSE 35090
// bombExploded := true ;
35082: LD_ADDR_EXP 37
35086: PUSH
35087: LD_INT 1
35089: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
35090: LD_VAR 0 1
35094: PPUSH
35095: CALL_OW 255
35099: PUSH
35100: LD_INT 1
35102: EQUAL
35103: PUSH
35104: LD_EXP 30
35108: AND
35109: PUSH
35110: LD_INT 22
35112: PUSH
35113: LD_INT 3
35115: PUSH
35116: EMPTY
35117: LIST
35118: LIST
35119: PUSH
35120: LD_INT 34
35122: PUSH
35123: LD_INT 48
35125: PUSH
35126: EMPTY
35127: LIST
35128: LIST
35129: PUSH
35130: EMPTY
35131: LIST
35132: LIST
35133: PPUSH
35134: CALL_OW 69
35138: AND
35139: PUSH
35140: LD_INT 22
35142: PUSH
35143: LD_INT 1
35145: PUSH
35146: EMPTY
35147: LIST
35148: LIST
35149: PUSH
35150: LD_INT 34
35152: PUSH
35153: LD_INT 8
35155: PUSH
35156: EMPTY
35157: LIST
35158: LIST
35159: PUSH
35160: EMPTY
35161: LIST
35162: LIST
35163: PPUSH
35164: CALL_OW 69
35168: NOT
35169: AND
35170: IFFALSE 35222
// begin wait ( 0 0$5 ) ;
35172: LD_INT 175
35174: PPUSH
35175: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
35179: LD_INT 22
35181: PUSH
35182: LD_INT 3
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 34
35191: PUSH
35192: LD_INT 48
35194: PUSH
35195: EMPTY
35196: LIST
35197: LIST
35198: PUSH
35199: EMPTY
35200: LIST
35201: LIST
35202: PPUSH
35203: CALL_OW 69
35207: PUSH
35208: LD_INT 1
35210: ARRAY
35211: PPUSH
35212: LD_INT 60
35214: PPUSH
35215: LD_INT 95
35217: PPUSH
35218: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
35222: LD_VAR 0 2
35226: PPUSH
35227: LD_VAR 0 3
35231: PPUSH
35232: LD_INT 18
35234: PPUSH
35235: CALL_OW 309
35239: IFFALSE 35286
// begin if GetSide ( unit ) = 1 then
35241: LD_VAR 0 1
35245: PPUSH
35246: CALL_OW 255
35250: PUSH
35251: LD_INT 1
35253: EQUAL
35254: IFFALSE 35272
// begin wait ( 0 0$6 ) ;
35256: LD_INT 210
35258: PPUSH
35259: CALL_OW 67
// YouLost ( Motherlode2 ) ;
35263: LD_STRING Motherlode2
35265: PPUSH
35266: CALL_OW 104
// end else
35270: GO 35286
// begin wait ( 0 0$6 ) ;
35272: LD_INT 210
35274: PPUSH
35275: CALL_OW 67
// YouLost ( Motherlode1 ) ;
35279: LD_STRING Motherlode1
35281: PPUSH
35282: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
35286: LD_VAR 0 1
35290: PPUSH
35291: CALL_OW 255
35295: PUSH
35296: LD_INT 3
35298: EQUAL
35299: IFFALSE 35320
// begin wait ( 0 0$5 ) ;
35301: LD_INT 175
35303: PPUSH
35304: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
35308: LD_EXP 65
35312: PPUSH
35313: LD_STRING D18-Pla-1
35315: PPUSH
35316: CALL_OW 94
// end ; end ;
35320: PPOPN 3
35322: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
35323: LD_VAR 0 1
35327: PPUSH
35328: CALL 124141 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
35332: LD_VAR 0 1
35336: PUSH
35337: LD_INT 22
35339: PUSH
35340: LD_INT 1
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: LD_INT 21
35349: PUSH
35350: LD_INT 1
35352: PUSH
35353: EMPTY
35354: LIST
35355: LIST
35356: PUSH
35357: LD_INT 23
35359: PUSH
35360: LD_INT 1
35362: PUSH
35363: EMPTY
35364: LIST
35365: LIST
35366: PUSH
35367: EMPTY
35368: LIST
35369: LIST
35370: LIST
35371: PPUSH
35372: CALL_OW 69
35376: IN
35377: IFFALSE 35393
// lostCounter := lostCounter + 1 ;
35379: LD_ADDR_EXP 32
35383: PUSH
35384: LD_EXP 32
35388: PUSH
35389: LD_INT 1
35391: PLUS
35392: ST_TO_ADDR
// if un in behemothBuilders then
35393: LD_VAR 0 1
35397: PUSH
35398: LD_EXP 74
35402: IN
35403: IFFALSE 35423
// begin behemothBuilders := behemothBuilders diff un ;
35405: LD_ADDR_EXP 74
35409: PUSH
35410: LD_EXP 74
35414: PUSH
35415: LD_VAR 0 1
35419: DIFF
35420: ST_TO_ADDR
// exit ;
35421: GO 35453
// end ; if un = JMM then
35423: LD_VAR 0 1
35427: PUSH
35428: LD_EXP 40
35432: EQUAL
35433: IFFALSE 35444
// begin YouLost ( JMM ) ;
35435: LD_STRING JMM
35437: PPUSH
35438: CALL_OW 104
// exit ;
35442: GO 35453
// end ; MCE_UnitDestroyed ( un ) ;
35444: LD_VAR 0 1
35448: PPUSH
35449: CALL 64250 0 1
// end ;
35453: PPOPN 1
35455: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
35456: LD_VAR 0 1
35460: PPUSH
35461: LD_VAR 0 2
35465: PPUSH
35466: CALL 66582 0 2
// end ;
35470: PPOPN 2
35472: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
35473: LD_VAR 0 1
35477: PPUSH
35478: CALL 65650 0 1
// end ;
35482: PPOPN 1
35484: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
35485: LD_VAR 0 1
35489: PUSH
35490: LD_INT 22
35492: PUSH
35493: LD_INT 8
35495: PUSH
35496: EMPTY
35497: LIST
35498: LIST
35499: PUSH
35500: LD_INT 30
35502: PUSH
35503: LD_INT 2
35505: PUSH
35506: EMPTY
35507: LIST
35508: LIST
35509: PUSH
35510: LD_INT 23
35512: PUSH
35513: LD_INT 3
35515: PUSH
35516: EMPTY
35517: LIST
35518: LIST
35519: PUSH
35520: EMPTY
35521: LIST
35522: LIST
35523: LIST
35524: PPUSH
35525: CALL_OW 69
35529: IN
35530: IFFALSE 35557
// begin ComUpgrade ( building ) ;
35532: LD_VAR 0 1
35536: PPUSH
35537: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
35541: LD_EXP 62
35545: PPUSH
35546: LD_VAR 0 1
35550: PPUSH
35551: CALL 75232 0 2
// exit ;
35555: GO 35566
// end ; MCE_BuildingComplete ( building ) ;
35557: LD_VAR 0 1
35561: PPUSH
35562: CALL 65891 0 1
// end ;
35566: PPOPN 1
35568: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
35569: LD_VAR 0 1
35573: PPUSH
35574: LD_VAR 0 2
35578: PPUSH
35579: CALL 63946 0 2
// end ;
35583: PPOPN 2
35585: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
35586: LD_VAR 0 1
35590: PPUSH
35591: LD_VAR 0 2
35595: PPUSH
35596: LD_VAR 0 3
35600: PPUSH
35601: LD_VAR 0 4
35605: PPUSH
35606: LD_VAR 0 5
35610: PPUSH
35611: CALL 63566 0 5
// end ;
35615: PPOPN 5
35617: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
35618: LD_VAR 0 1
35622: PPUSH
35623: CALL_OW 255
35627: PUSH
35628: LD_INT 1
35630: EQUAL
35631: IFFALSE 35648
// amConstructCounter := Inc ( amConstructCounter ) ;
35633: LD_ADDR_EXP 39
35637: PUSH
35638: LD_EXP 39
35642: PPUSH
35643: CALL 106044 0 1
35647: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
35648: LD_VAR 0 1
35652: PPUSH
35653: LD_VAR 0 2
35657: PPUSH
35658: CALL 124261 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
35662: LD_VAR 0 1
35666: PPUSH
35667: LD_VAR 0 2
35671: PPUSH
35672: CALL 63157 0 2
// end ;
35676: PPOPN 2
35678: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
35679: LD_VAR 0 1
35683: PPUSH
35684: LD_VAR 0 2
35688: PPUSH
35689: LD_VAR 0 3
35693: PPUSH
35694: LD_VAR 0 4
35698: PPUSH
35699: CALL 62995 0 4
// end ;
35703: PPOPN 4
35705: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
35706: LD_VAR 0 1
35710: PPUSH
35711: LD_VAR 0 2
35715: PPUSH
35716: LD_VAR 0 3
35720: PPUSH
35721: CALL 62770 0 3
// end ;
35725: PPOPN 3
35727: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
35728: LD_VAR 0 1
35732: PPUSH
35733: LD_VAR 0 2
35737: PPUSH
35738: CALL 62655 0 2
// end ;
35742: PPOPN 2
35744: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
35745: LD_VAR 0 1
35749: PPUSH
35750: LD_VAR 0 2
35754: PPUSH
35755: CALL 66877 0 2
// end ;
35759: PPOPN 2
35761: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
35762: LD_VAR 0 1
35766: PPUSH
35767: CALL_OW 255
35771: PUSH
35772: LD_INT 4
35774: EQUAL
35775: PUSH
35776: LD_VAR 0 1
35780: PUSH
35781: LD_EXP 18
35785: PUSH
35786: LD_INT 1
35788: ARRAY
35789: IN
35790: AND
35791: PUSH
35792: LD_EXP 19
35796: AND
35797: IFFALSE 35816
// begin ComMoveXY ( driver , 61 , 93 ) ;
35799: LD_VAR 0 1
35803: PPUSH
35804: LD_INT 61
35806: PPUSH
35807: LD_INT 93
35809: PPUSH
35810: CALL_OW 111
// exit ;
35814: GO 35840
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
35816: LD_VAR 0 1
35820: PPUSH
35821: LD_VAR 0 2
35825: PPUSH
35826: LD_VAR 0 3
35830: PPUSH
35831: LD_VAR 0 4
35835: PPUSH
35836: CALL 67093 0 4
// end ;
35840: PPOPN 4
35842: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
35843: LD_VAR 0 1
35847: PPUSH
35848: LD_VAR 0 2
35852: PPUSH
35853: CALL 62464 0 2
// end ;
35857: PPOPN 2
35859: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
35860: LD_VAR 0 1
35864: PPUSH
35865: CALL 124245 0 1
// end ; end_of_file
35869: PPOPN 1
35871: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
35872: LD_EXP 15
35876: PUSH
35877: LD_INT 2
35879: EQUAL
35880: IFFALSE 36383
35882: GO 35884
35884: DISABLE
35885: LD_INT 0
35887: PPUSH
35888: PPUSH
// begin time := 0 0$35 ;
35889: LD_ADDR_VAR 0 2
35893: PUSH
35894: LD_INT 1225
35896: ST_TO_ADDR
// repeat wait ( time ) ;
35897: LD_VAR 0 2
35901: PPUSH
35902: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
35906: LD_INT 1
35908: PPUSH
35909: LD_INT 5
35911: PPUSH
35912: CALL_OW 12
35916: PPUSH
35917: LD_INT 106
35919: PPUSH
35920: LD_INT 150
35922: PPUSH
35923: LD_INT 19
35925: PPUSH
35926: LD_INT 1
35928: PPUSH
35929: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
35933: LD_INT 455
35935: PPUSH
35936: LD_INT 770
35938: PPUSH
35939: CALL_OW 12
35943: PPUSH
35944: CALL_OW 67
// if Prob ( 50 ) then
35948: LD_INT 50
35950: PPUSH
35951: CALL_OW 13
35955: IFFALSE 35984
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
35957: LD_INT 1
35959: PPUSH
35960: LD_INT 5
35962: PPUSH
35963: CALL_OW 12
35967: PPUSH
35968: LD_INT 62
35970: PPUSH
35971: LD_INT 108
35973: PPUSH
35974: LD_INT 10
35976: PPUSH
35977: LD_INT 1
35979: PPUSH
35980: CALL_OW 56
// until missionStage > 4 ;
35984: LD_EXP 15
35988: PUSH
35989: LD_INT 4
35991: GREATER
35992: IFFALSE 35897
// repeat wait ( 0 0$1 ) ;
35994: LD_INT 35
35996: PPUSH
35997: CALL_OW 67
// until missionStage = 6 ;
36001: LD_EXP 15
36005: PUSH
36006: LD_INT 6
36008: EQUAL
36009: IFFALSE 35994
// time := 0 0$20 ;
36011: LD_ADDR_VAR 0 2
36015: PUSH
36016: LD_INT 700
36018: ST_TO_ADDR
// repeat wait ( time ) ;
36019: LD_VAR 0 2
36023: PPUSH
36024: CALL_OW 67
// if Prob ( 90 ) then
36028: LD_INT 90
36030: PPUSH
36031: CALL_OW 13
36035: IFFALSE 36078
// begin time := time + 0 0$2 ;
36037: LD_ADDR_VAR 0 2
36041: PUSH
36042: LD_VAR 0 2
36046: PUSH
36047: LD_INT 70
36049: PLUS
36050: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
36051: LD_INT 1
36053: PPUSH
36054: LD_INT 5
36056: PPUSH
36057: CALL_OW 12
36061: PPUSH
36062: LD_INT 106
36064: PPUSH
36065: LD_INT 89
36067: PPUSH
36068: LD_INT 45
36070: PPUSH
36071: LD_INT 1
36073: PPUSH
36074: CALL_OW 56
// end ; if Prob ( 45 ) then
36078: LD_INT 45
36080: PPUSH
36081: CALL_OW 13
36085: IFFALSE 36141
// begin for i := 1 to 4 do
36087: LD_ADDR_VAR 0 1
36091: PUSH
36092: DOUBLE
36093: LD_INT 1
36095: DEC
36096: ST_TO_ADDR
36097: LD_INT 4
36099: PUSH
36100: FOR_TO
36101: IFFALSE 36139
// begin wait ( 0 0$5 ) ;
36103: LD_INT 175
36105: PPUSH
36106: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
36110: LD_INT 1
36112: PPUSH
36113: LD_INT 5
36115: PPUSH
36116: CALL_OW 12
36120: PPUSH
36121: LD_INT 113
36123: PPUSH
36124: LD_INT 117
36126: PPUSH
36127: LD_INT 25
36129: PPUSH
36130: LD_INT 1
36132: PPUSH
36133: CALL_OW 56
// end ;
36137: GO 36100
36139: POP
36140: POP
// end ; if Prob ( 40 ) then
36141: LD_INT 40
36143: PPUSH
36144: CALL_OW 13
36148: IFFALSE 36194
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
36150: LD_INT 385
36152: PPUSH
36153: LD_INT 945
36155: PPUSH
36156: CALL_OW 12
36160: PPUSH
36161: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
36165: LD_INT 1
36167: PPUSH
36168: LD_INT 5
36170: PPUSH
36171: CALL_OW 12
36175: PPUSH
36176: LD_INT 21
36178: PPUSH
36179: LD_INT 26
36181: PPUSH
36182: LD_INT 12
36184: PPUSH
36185: LD_INT 1
36187: PPUSH
36188: CALL_OW 56
// end else
36192: GO 36230
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
36194: LD_INT 700
36196: PPUSH
36197: LD_INT 1225
36199: PPUSH
36200: CALL_OW 12
36204: PPUSH
36205: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
36209: LD_INT 1
36211: PPUSH
36212: LD_INT 5
36214: PPUSH
36215: CALL_OW 12
36219: PPUSH
36220: LD_INT 16
36222: PPUSH
36223: LD_INT 1
36225: PPUSH
36226: CALL_OW 55
// end ; if Prob ( 50 ) then
36230: LD_INT 50
36232: PPUSH
36233: CALL_OW 13
36237: IFFALSE 36283
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
36239: LD_INT 700
36241: PPUSH
36242: LD_INT 1050
36244: PPUSH
36245: CALL_OW 12
36249: PPUSH
36250: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
36254: LD_INT 1
36256: PPUSH
36257: LD_INT 5
36259: PPUSH
36260: CALL_OW 12
36264: PPUSH
36265: LD_INT 168
36267: PPUSH
36268: LD_INT 168
36270: PPUSH
36271: LD_INT 16
36273: PPUSH
36274: LD_INT 1
36276: PPUSH
36277: CALL_OW 56
// end else
36281: GO 36319
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
36283: LD_INT 350
36285: PPUSH
36286: LD_INT 525
36288: PPUSH
36289: CALL_OW 12
36293: PPUSH
36294: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
36298: LD_INT 1
36300: PPUSH
36301: LD_INT 5
36303: PPUSH
36304: CALL_OW 12
36308: PPUSH
36309: LD_INT 15
36311: PPUSH
36312: LD_INT 1
36314: PPUSH
36315: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
36319: LD_INT 175
36321: PPUSH
36322: LD_INT 315
36324: PPUSH
36325: CALL_OW 12
36329: PPUSH
36330: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
36334: LD_INT 1
36336: PPUSH
36337: LD_INT 5
36339: PPUSH
36340: CALL_OW 12
36344: PPUSH
36345: LD_INT 103
36347: PPUSH
36348: LD_INT 140
36350: PPUSH
36351: LD_INT 20
36353: PPUSH
36354: LD_INT 1
36356: PPUSH
36357: CALL_OW 56
// if time > 1 1$10 then
36361: LD_VAR 0 2
36365: PUSH
36366: LD_INT 2450
36368: GREATER
36369: IFFALSE 36379
// time := 0 0$30 ;
36371: LD_ADDR_VAR 0 2
36375: PUSH
36376: LD_INT 1050
36378: ST_TO_ADDR
// until false ;
36379: LD_INT 0
36381: IFFALSE 36019
// end ; end_of_file
36383: PPOPN 2
36385: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
36386: LD_EXP 13
36390: PUSH
36391: LD_EXP 15
36395: PUSH
36396: LD_INT 6
36398: GREATEREQUAL
36399: AND
36400: IFFALSE 36437
36402: GO 36404
36404: DISABLE
// begin enable ;
36405: ENABLE
// missionTime := missionTime + 0 0$1 ;
36406: LD_ADDR_EXP 14
36410: PUSH
36411: LD_EXP 14
36415: PUSH
36416: LD_INT 35
36418: PLUS
36419: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
36420: LD_ADDR_OWVAR 47
36424: PUSH
36425: LD_STRING #Am15-1
36427: PUSH
36428: LD_EXP 14
36432: PUSH
36433: EMPTY
36434: LIST
36435: LIST
36436: ST_TO_ADDR
// end ; end_of_file
36437: END
// export function InitNature ; begin
36438: LD_INT 0
36440: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
36441: LD_INT 3
36443: PPUSH
36444: LD_INT 3
36446: PPUSH
36447: LD_INT 2
36449: PPUSH
36450: LD_INT 1
36452: PPUSH
36453: LD_INT 1
36455: PPUSH
36456: LD_INT 0
36458: PPUSH
36459: LD_INT 0
36461: PPUSH
36462: LD_INT 20
36464: PPUSH
36465: LD_INT 0
36467: PPUSH
36468: CALL 101365 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
36472: LD_INT 2
36474: PPUSH
36475: LD_INT 1
36477: PPUSH
36478: LD_INT 1
36480: PPUSH
36481: LD_INT 1
36483: PPUSH
36484: LD_INT 1
36486: PPUSH
36487: LD_INT 0
36489: PPUSH
36490: LD_INT 0
36492: PPUSH
36493: LD_INT 21
36495: PPUSH
36496: LD_INT 0
36498: PPUSH
36499: CALL 101365 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
36503: LD_INT 4
36505: PPUSH
36506: LD_INT 1
36508: PPUSH
36509: LD_INT 2
36511: PPUSH
36512: LD_INT 4
36514: PPUSH
36515: LD_INT 2
36517: PPUSH
36518: LD_INT 1
36520: PPUSH
36521: LD_INT 0
36523: PPUSH
36524: LD_INT 22
36526: PPUSH
36527: LD_INT 0
36529: PPUSH
36530: CALL 101365 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
36534: LD_INT 0
36536: PPUSH
36537: LD_INT 0
36539: PPUSH
36540: LD_INT 0
36542: PPUSH
36543: LD_INT 0
36545: PPUSH
36546: LD_INT 0
36548: PPUSH
36549: LD_INT 0
36551: PPUSH
36552: LD_INT 9
36554: PPUSH
36555: LD_INT 0
36557: PPUSH
36558: LD_INT 23
36560: PPUSH
36561: CALL 101365 0 9
// end ; end_of_file
36565: LD_VAR 0 1
36569: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
36570: LD_INT 0
36572: PPUSH
36573: PPUSH
// skirmish := false ;
36574: LD_ADDR_EXP 97
36578: PUSH
36579: LD_INT 0
36581: ST_TO_ADDR
// debug_mc := false ;
36582: LD_ADDR_EXP 98
36586: PUSH
36587: LD_INT 0
36589: ST_TO_ADDR
// mc_bases := [ ] ;
36590: LD_ADDR_EXP 99
36594: PUSH
36595: EMPTY
36596: ST_TO_ADDR
// mc_sides := [ ] ;
36597: LD_ADDR_EXP 125
36601: PUSH
36602: EMPTY
36603: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
36604: LD_ADDR_EXP 100
36608: PUSH
36609: EMPTY
36610: ST_TO_ADDR
// mc_building_repairs := [ ] ;
36611: LD_ADDR_EXP 101
36615: PUSH
36616: EMPTY
36617: ST_TO_ADDR
// mc_need_heal := [ ] ;
36618: LD_ADDR_EXP 102
36622: PUSH
36623: EMPTY
36624: ST_TO_ADDR
// mc_healers := [ ] ;
36625: LD_ADDR_EXP 103
36629: PUSH
36630: EMPTY
36631: ST_TO_ADDR
// mc_build_list := [ ] ;
36632: LD_ADDR_EXP 104
36636: PUSH
36637: EMPTY
36638: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
36639: LD_ADDR_EXP 131
36643: PUSH
36644: EMPTY
36645: ST_TO_ADDR
// mc_builders := [ ] ;
36646: LD_ADDR_EXP 105
36650: PUSH
36651: EMPTY
36652: ST_TO_ADDR
// mc_construct_list := [ ] ;
36653: LD_ADDR_EXP 106
36657: PUSH
36658: EMPTY
36659: ST_TO_ADDR
// mc_turret_list := [ ] ;
36660: LD_ADDR_EXP 107
36664: PUSH
36665: EMPTY
36666: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
36667: LD_ADDR_EXP 108
36671: PUSH
36672: EMPTY
36673: ST_TO_ADDR
// mc_miners := [ ] ;
36674: LD_ADDR_EXP 113
36678: PUSH
36679: EMPTY
36680: ST_TO_ADDR
// mc_mines := [ ] ;
36681: LD_ADDR_EXP 112
36685: PUSH
36686: EMPTY
36687: ST_TO_ADDR
// mc_minefields := [ ] ;
36688: LD_ADDR_EXP 114
36692: PUSH
36693: EMPTY
36694: ST_TO_ADDR
// mc_crates := [ ] ;
36695: LD_ADDR_EXP 115
36699: PUSH
36700: EMPTY
36701: ST_TO_ADDR
// mc_crates_collector := [ ] ;
36702: LD_ADDR_EXP 116
36706: PUSH
36707: EMPTY
36708: ST_TO_ADDR
// mc_crates_area := [ ] ;
36709: LD_ADDR_EXP 117
36713: PUSH
36714: EMPTY
36715: ST_TO_ADDR
// mc_vehicles := [ ] ;
36716: LD_ADDR_EXP 118
36720: PUSH
36721: EMPTY
36722: ST_TO_ADDR
// mc_attack := [ ] ;
36723: LD_ADDR_EXP 119
36727: PUSH
36728: EMPTY
36729: ST_TO_ADDR
// mc_produce := [ ] ;
36730: LD_ADDR_EXP 120
36734: PUSH
36735: EMPTY
36736: ST_TO_ADDR
// mc_defender := [ ] ;
36737: LD_ADDR_EXP 121
36741: PUSH
36742: EMPTY
36743: ST_TO_ADDR
// mc_parking := [ ] ;
36744: LD_ADDR_EXP 123
36748: PUSH
36749: EMPTY
36750: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
36751: LD_ADDR_EXP 109
36755: PUSH
36756: EMPTY
36757: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
36758: LD_ADDR_EXP 111
36762: PUSH
36763: EMPTY
36764: ST_TO_ADDR
// mc_scan := [ ] ;
36765: LD_ADDR_EXP 122
36769: PUSH
36770: EMPTY
36771: ST_TO_ADDR
// mc_scan_area := [ ] ;
36772: LD_ADDR_EXP 124
36776: PUSH
36777: EMPTY
36778: ST_TO_ADDR
// mc_tech := [ ] ;
36779: LD_ADDR_EXP 126
36783: PUSH
36784: EMPTY
36785: ST_TO_ADDR
// mc_class := [ ] ;
36786: LD_ADDR_EXP 140
36790: PUSH
36791: EMPTY
36792: ST_TO_ADDR
// mc_class_case_use := [ ] ;
36793: LD_ADDR_EXP 141
36797: PUSH
36798: EMPTY
36799: ST_TO_ADDR
// mc_is_defending := [ ] ;
36800: LD_ADDR_EXP 142
36804: PUSH
36805: EMPTY
36806: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
36807: LD_ADDR_EXP 133
36811: PUSH
36812: EMPTY
36813: ST_TO_ADDR
// end ;
36814: LD_VAR 0 1
36818: RET
// export function MC_Kill ( base ) ; begin
36819: LD_INT 0
36821: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
36822: LD_ADDR_EXP 99
36826: PUSH
36827: LD_EXP 99
36831: PPUSH
36832: LD_VAR 0 1
36836: PPUSH
36837: EMPTY
36838: PPUSH
36839: CALL_OW 1
36843: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36844: LD_ADDR_EXP 100
36848: PUSH
36849: LD_EXP 100
36853: PPUSH
36854: LD_VAR 0 1
36858: PPUSH
36859: EMPTY
36860: PPUSH
36861: CALL_OW 1
36865: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36866: LD_ADDR_EXP 101
36870: PUSH
36871: LD_EXP 101
36875: PPUSH
36876: LD_VAR 0 1
36880: PPUSH
36881: EMPTY
36882: PPUSH
36883: CALL_OW 1
36887: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36888: LD_ADDR_EXP 102
36892: PUSH
36893: LD_EXP 102
36897: PPUSH
36898: LD_VAR 0 1
36902: PPUSH
36903: EMPTY
36904: PPUSH
36905: CALL_OW 1
36909: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36910: LD_ADDR_EXP 103
36914: PUSH
36915: LD_EXP 103
36919: PPUSH
36920: LD_VAR 0 1
36924: PPUSH
36925: EMPTY
36926: PPUSH
36927: CALL_OW 1
36931: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36932: LD_ADDR_EXP 104
36936: PUSH
36937: LD_EXP 104
36941: PPUSH
36942: LD_VAR 0 1
36946: PPUSH
36947: EMPTY
36948: PPUSH
36949: CALL_OW 1
36953: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36954: LD_ADDR_EXP 105
36958: PUSH
36959: LD_EXP 105
36963: PPUSH
36964: LD_VAR 0 1
36968: PPUSH
36969: EMPTY
36970: PPUSH
36971: CALL_OW 1
36975: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36976: LD_ADDR_EXP 106
36980: PUSH
36981: LD_EXP 106
36985: PPUSH
36986: LD_VAR 0 1
36990: PPUSH
36991: EMPTY
36992: PPUSH
36993: CALL_OW 1
36997: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36998: LD_ADDR_EXP 107
37002: PUSH
37003: LD_EXP 107
37007: PPUSH
37008: LD_VAR 0 1
37012: PPUSH
37013: EMPTY
37014: PPUSH
37015: CALL_OW 1
37019: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
37020: LD_ADDR_EXP 108
37024: PUSH
37025: LD_EXP 108
37029: PPUSH
37030: LD_VAR 0 1
37034: PPUSH
37035: EMPTY
37036: PPUSH
37037: CALL_OW 1
37041: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
37042: LD_ADDR_EXP 109
37046: PUSH
37047: LD_EXP 109
37051: PPUSH
37052: LD_VAR 0 1
37056: PPUSH
37057: EMPTY
37058: PPUSH
37059: CALL_OW 1
37063: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
37064: LD_ADDR_EXP 110
37068: PUSH
37069: LD_EXP 110
37073: PPUSH
37074: LD_VAR 0 1
37078: PPUSH
37079: LD_INT 0
37081: PPUSH
37082: CALL_OW 1
37086: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
37087: LD_ADDR_EXP 111
37091: PUSH
37092: LD_EXP 111
37096: PPUSH
37097: LD_VAR 0 1
37101: PPUSH
37102: EMPTY
37103: PPUSH
37104: CALL_OW 1
37108: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
37109: LD_ADDR_EXP 112
37113: PUSH
37114: LD_EXP 112
37118: PPUSH
37119: LD_VAR 0 1
37123: PPUSH
37124: EMPTY
37125: PPUSH
37126: CALL_OW 1
37130: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
37131: LD_ADDR_EXP 113
37135: PUSH
37136: LD_EXP 113
37140: PPUSH
37141: LD_VAR 0 1
37145: PPUSH
37146: EMPTY
37147: PPUSH
37148: CALL_OW 1
37152: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
37153: LD_ADDR_EXP 114
37157: PUSH
37158: LD_EXP 114
37162: PPUSH
37163: LD_VAR 0 1
37167: PPUSH
37168: EMPTY
37169: PPUSH
37170: CALL_OW 1
37174: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
37175: LD_ADDR_EXP 115
37179: PUSH
37180: LD_EXP 115
37184: PPUSH
37185: LD_VAR 0 1
37189: PPUSH
37190: EMPTY
37191: PPUSH
37192: CALL_OW 1
37196: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
37197: LD_ADDR_EXP 116
37201: PUSH
37202: LD_EXP 116
37206: PPUSH
37207: LD_VAR 0 1
37211: PPUSH
37212: EMPTY
37213: PPUSH
37214: CALL_OW 1
37218: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
37219: LD_ADDR_EXP 117
37223: PUSH
37224: LD_EXP 117
37228: PPUSH
37229: LD_VAR 0 1
37233: PPUSH
37234: EMPTY
37235: PPUSH
37236: CALL_OW 1
37240: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
37241: LD_ADDR_EXP 118
37245: PUSH
37246: LD_EXP 118
37250: PPUSH
37251: LD_VAR 0 1
37255: PPUSH
37256: EMPTY
37257: PPUSH
37258: CALL_OW 1
37262: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
37263: LD_ADDR_EXP 119
37267: PUSH
37268: LD_EXP 119
37272: PPUSH
37273: LD_VAR 0 1
37277: PPUSH
37278: EMPTY
37279: PPUSH
37280: CALL_OW 1
37284: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
37285: LD_ADDR_EXP 120
37289: PUSH
37290: LD_EXP 120
37294: PPUSH
37295: LD_VAR 0 1
37299: PPUSH
37300: EMPTY
37301: PPUSH
37302: CALL_OW 1
37306: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
37307: LD_ADDR_EXP 121
37311: PUSH
37312: LD_EXP 121
37316: PPUSH
37317: LD_VAR 0 1
37321: PPUSH
37322: EMPTY
37323: PPUSH
37324: CALL_OW 1
37328: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
37329: LD_ADDR_EXP 122
37333: PUSH
37334: LD_EXP 122
37338: PPUSH
37339: LD_VAR 0 1
37343: PPUSH
37344: EMPTY
37345: PPUSH
37346: CALL_OW 1
37350: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
37351: LD_ADDR_EXP 123
37355: PUSH
37356: LD_EXP 123
37360: PPUSH
37361: LD_VAR 0 1
37365: PPUSH
37366: EMPTY
37367: PPUSH
37368: CALL_OW 1
37372: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
37373: LD_ADDR_EXP 124
37377: PUSH
37378: LD_EXP 124
37382: PPUSH
37383: LD_VAR 0 1
37387: PPUSH
37388: EMPTY
37389: PPUSH
37390: CALL_OW 1
37394: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
37395: LD_ADDR_EXP 126
37399: PUSH
37400: LD_EXP 126
37404: PPUSH
37405: LD_VAR 0 1
37409: PPUSH
37410: EMPTY
37411: PPUSH
37412: CALL_OW 1
37416: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
37417: LD_ADDR_EXP 128
37421: PUSH
37422: LD_EXP 128
37426: PPUSH
37427: LD_VAR 0 1
37431: PPUSH
37432: EMPTY
37433: PPUSH
37434: CALL_OW 1
37438: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
37439: LD_ADDR_EXP 129
37443: PUSH
37444: LD_EXP 129
37448: PPUSH
37449: LD_VAR 0 1
37453: PPUSH
37454: EMPTY
37455: PPUSH
37456: CALL_OW 1
37460: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
37461: LD_ADDR_EXP 130
37465: PUSH
37466: LD_EXP 130
37470: PPUSH
37471: LD_VAR 0 1
37475: PPUSH
37476: EMPTY
37477: PPUSH
37478: CALL_OW 1
37482: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
37483: LD_ADDR_EXP 131
37487: PUSH
37488: LD_EXP 131
37492: PPUSH
37493: LD_VAR 0 1
37497: PPUSH
37498: EMPTY
37499: PPUSH
37500: CALL_OW 1
37504: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
37505: LD_ADDR_EXP 132
37509: PUSH
37510: LD_EXP 132
37514: PPUSH
37515: LD_VAR 0 1
37519: PPUSH
37520: EMPTY
37521: PPUSH
37522: CALL_OW 1
37526: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37527: LD_ADDR_EXP 133
37531: PUSH
37532: LD_EXP 133
37536: PPUSH
37537: LD_VAR 0 1
37541: PPUSH
37542: EMPTY
37543: PPUSH
37544: CALL_OW 1
37548: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37549: LD_ADDR_EXP 134
37553: PUSH
37554: LD_EXP 134
37558: PPUSH
37559: LD_VAR 0 1
37563: PPUSH
37564: EMPTY
37565: PPUSH
37566: CALL_OW 1
37570: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37571: LD_ADDR_EXP 135
37575: PUSH
37576: LD_EXP 135
37580: PPUSH
37581: LD_VAR 0 1
37585: PPUSH
37586: EMPTY
37587: PPUSH
37588: CALL_OW 1
37592: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37593: LD_ADDR_EXP 136
37597: PUSH
37598: LD_EXP 136
37602: PPUSH
37603: LD_VAR 0 1
37607: PPUSH
37608: EMPTY
37609: PPUSH
37610: CALL_OW 1
37614: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37615: LD_ADDR_EXP 137
37619: PUSH
37620: LD_EXP 137
37624: PPUSH
37625: LD_VAR 0 1
37629: PPUSH
37630: EMPTY
37631: PPUSH
37632: CALL_OW 1
37636: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37637: LD_ADDR_EXP 138
37641: PUSH
37642: LD_EXP 138
37646: PPUSH
37647: LD_VAR 0 1
37651: PPUSH
37652: EMPTY
37653: PPUSH
37654: CALL_OW 1
37658: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37659: LD_ADDR_EXP 139
37663: PUSH
37664: LD_EXP 139
37668: PPUSH
37669: LD_VAR 0 1
37673: PPUSH
37674: EMPTY
37675: PPUSH
37676: CALL_OW 1
37680: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37681: LD_ADDR_EXP 140
37685: PUSH
37686: LD_EXP 140
37690: PPUSH
37691: LD_VAR 0 1
37695: PPUSH
37696: EMPTY
37697: PPUSH
37698: CALL_OW 1
37702: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37703: LD_ADDR_EXP 141
37707: PUSH
37708: LD_EXP 141
37712: PPUSH
37713: LD_VAR 0 1
37717: PPUSH
37718: LD_INT 0
37720: PPUSH
37721: CALL_OW 1
37725: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
37726: LD_ADDR_EXP 142
37730: PUSH
37731: LD_EXP 142
37735: PPUSH
37736: LD_VAR 0 1
37740: PPUSH
37741: LD_INT 0
37743: PPUSH
37744: CALL_OW 1
37748: ST_TO_ADDR
// end ;
37749: LD_VAR 0 2
37753: RET
// export function MC_Add ( side , units ) ; var base ; begin
37754: LD_INT 0
37756: PPUSH
37757: PPUSH
// base := mc_bases + 1 ;
37758: LD_ADDR_VAR 0 4
37762: PUSH
37763: LD_EXP 99
37767: PUSH
37768: LD_INT 1
37770: PLUS
37771: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
37772: LD_ADDR_EXP 125
37776: PUSH
37777: LD_EXP 125
37781: PPUSH
37782: LD_VAR 0 4
37786: PPUSH
37787: LD_VAR 0 1
37791: PPUSH
37792: CALL_OW 1
37796: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
37797: LD_ADDR_EXP 99
37801: PUSH
37802: LD_EXP 99
37806: PPUSH
37807: LD_VAR 0 4
37811: PPUSH
37812: LD_VAR 0 2
37816: PPUSH
37817: CALL_OW 1
37821: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
37822: LD_ADDR_EXP 100
37826: PUSH
37827: LD_EXP 100
37831: PPUSH
37832: LD_VAR 0 4
37836: PPUSH
37837: EMPTY
37838: PPUSH
37839: CALL_OW 1
37843: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
37844: LD_ADDR_EXP 101
37848: PUSH
37849: LD_EXP 101
37853: PPUSH
37854: LD_VAR 0 4
37858: PPUSH
37859: EMPTY
37860: PPUSH
37861: CALL_OW 1
37865: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
37866: LD_ADDR_EXP 102
37870: PUSH
37871: LD_EXP 102
37875: PPUSH
37876: LD_VAR 0 4
37880: PPUSH
37881: EMPTY
37882: PPUSH
37883: CALL_OW 1
37887: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
37888: LD_ADDR_EXP 103
37892: PUSH
37893: LD_EXP 103
37897: PPUSH
37898: LD_VAR 0 4
37902: PPUSH
37903: EMPTY
37904: PPUSH
37905: CALL_OW 1
37909: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
37910: LD_ADDR_EXP 104
37914: PUSH
37915: LD_EXP 104
37919: PPUSH
37920: LD_VAR 0 4
37924: PPUSH
37925: EMPTY
37926: PPUSH
37927: CALL_OW 1
37931: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
37932: LD_ADDR_EXP 105
37936: PUSH
37937: LD_EXP 105
37941: PPUSH
37942: LD_VAR 0 4
37946: PPUSH
37947: EMPTY
37948: PPUSH
37949: CALL_OW 1
37953: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
37954: LD_ADDR_EXP 106
37958: PUSH
37959: LD_EXP 106
37963: PPUSH
37964: LD_VAR 0 4
37968: PPUSH
37969: EMPTY
37970: PPUSH
37971: CALL_OW 1
37975: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
37976: LD_ADDR_EXP 107
37980: PUSH
37981: LD_EXP 107
37985: PPUSH
37986: LD_VAR 0 4
37990: PPUSH
37991: EMPTY
37992: PPUSH
37993: CALL_OW 1
37997: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
37998: LD_ADDR_EXP 108
38002: PUSH
38003: LD_EXP 108
38007: PPUSH
38008: LD_VAR 0 4
38012: PPUSH
38013: EMPTY
38014: PPUSH
38015: CALL_OW 1
38019: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
38020: LD_ADDR_EXP 109
38024: PUSH
38025: LD_EXP 109
38029: PPUSH
38030: LD_VAR 0 4
38034: PPUSH
38035: EMPTY
38036: PPUSH
38037: CALL_OW 1
38041: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
38042: LD_ADDR_EXP 110
38046: PUSH
38047: LD_EXP 110
38051: PPUSH
38052: LD_VAR 0 4
38056: PPUSH
38057: LD_INT 0
38059: PPUSH
38060: CALL_OW 1
38064: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
38065: LD_ADDR_EXP 111
38069: PUSH
38070: LD_EXP 111
38074: PPUSH
38075: LD_VAR 0 4
38079: PPUSH
38080: EMPTY
38081: PPUSH
38082: CALL_OW 1
38086: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
38087: LD_ADDR_EXP 112
38091: PUSH
38092: LD_EXP 112
38096: PPUSH
38097: LD_VAR 0 4
38101: PPUSH
38102: EMPTY
38103: PPUSH
38104: CALL_OW 1
38108: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
38109: LD_ADDR_EXP 113
38113: PUSH
38114: LD_EXP 113
38118: PPUSH
38119: LD_VAR 0 4
38123: PPUSH
38124: EMPTY
38125: PPUSH
38126: CALL_OW 1
38130: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
38131: LD_ADDR_EXP 114
38135: PUSH
38136: LD_EXP 114
38140: PPUSH
38141: LD_VAR 0 4
38145: PPUSH
38146: EMPTY
38147: PPUSH
38148: CALL_OW 1
38152: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
38153: LD_ADDR_EXP 115
38157: PUSH
38158: LD_EXP 115
38162: PPUSH
38163: LD_VAR 0 4
38167: PPUSH
38168: EMPTY
38169: PPUSH
38170: CALL_OW 1
38174: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
38175: LD_ADDR_EXP 116
38179: PUSH
38180: LD_EXP 116
38184: PPUSH
38185: LD_VAR 0 4
38189: PPUSH
38190: EMPTY
38191: PPUSH
38192: CALL_OW 1
38196: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
38197: LD_ADDR_EXP 117
38201: PUSH
38202: LD_EXP 117
38206: PPUSH
38207: LD_VAR 0 4
38211: PPUSH
38212: EMPTY
38213: PPUSH
38214: CALL_OW 1
38218: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
38219: LD_ADDR_EXP 118
38223: PUSH
38224: LD_EXP 118
38228: PPUSH
38229: LD_VAR 0 4
38233: PPUSH
38234: EMPTY
38235: PPUSH
38236: CALL_OW 1
38240: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
38241: LD_ADDR_EXP 119
38245: PUSH
38246: LD_EXP 119
38250: PPUSH
38251: LD_VAR 0 4
38255: PPUSH
38256: EMPTY
38257: PPUSH
38258: CALL_OW 1
38262: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
38263: LD_ADDR_EXP 120
38267: PUSH
38268: LD_EXP 120
38272: PPUSH
38273: LD_VAR 0 4
38277: PPUSH
38278: EMPTY
38279: PPUSH
38280: CALL_OW 1
38284: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
38285: LD_ADDR_EXP 121
38289: PUSH
38290: LD_EXP 121
38294: PPUSH
38295: LD_VAR 0 4
38299: PPUSH
38300: EMPTY
38301: PPUSH
38302: CALL_OW 1
38306: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
38307: LD_ADDR_EXP 122
38311: PUSH
38312: LD_EXP 122
38316: PPUSH
38317: LD_VAR 0 4
38321: PPUSH
38322: EMPTY
38323: PPUSH
38324: CALL_OW 1
38328: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
38329: LD_ADDR_EXP 123
38333: PUSH
38334: LD_EXP 123
38338: PPUSH
38339: LD_VAR 0 4
38343: PPUSH
38344: EMPTY
38345: PPUSH
38346: CALL_OW 1
38350: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
38351: LD_ADDR_EXP 124
38355: PUSH
38356: LD_EXP 124
38360: PPUSH
38361: LD_VAR 0 4
38365: PPUSH
38366: EMPTY
38367: PPUSH
38368: CALL_OW 1
38372: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
38373: LD_ADDR_EXP 126
38377: PUSH
38378: LD_EXP 126
38382: PPUSH
38383: LD_VAR 0 4
38387: PPUSH
38388: EMPTY
38389: PPUSH
38390: CALL_OW 1
38394: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
38395: LD_ADDR_EXP 128
38399: PUSH
38400: LD_EXP 128
38404: PPUSH
38405: LD_VAR 0 4
38409: PPUSH
38410: EMPTY
38411: PPUSH
38412: CALL_OW 1
38416: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
38417: LD_ADDR_EXP 129
38421: PUSH
38422: LD_EXP 129
38426: PPUSH
38427: LD_VAR 0 4
38431: PPUSH
38432: EMPTY
38433: PPUSH
38434: CALL_OW 1
38438: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
38439: LD_ADDR_EXP 130
38443: PUSH
38444: LD_EXP 130
38448: PPUSH
38449: LD_VAR 0 4
38453: PPUSH
38454: EMPTY
38455: PPUSH
38456: CALL_OW 1
38460: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
38461: LD_ADDR_EXP 131
38465: PUSH
38466: LD_EXP 131
38470: PPUSH
38471: LD_VAR 0 4
38475: PPUSH
38476: EMPTY
38477: PPUSH
38478: CALL_OW 1
38482: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
38483: LD_ADDR_EXP 132
38487: PUSH
38488: LD_EXP 132
38492: PPUSH
38493: LD_VAR 0 4
38497: PPUSH
38498: EMPTY
38499: PPUSH
38500: CALL_OW 1
38504: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
38505: LD_ADDR_EXP 133
38509: PUSH
38510: LD_EXP 133
38514: PPUSH
38515: LD_VAR 0 4
38519: PPUSH
38520: EMPTY
38521: PPUSH
38522: CALL_OW 1
38526: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
38527: LD_ADDR_EXP 134
38531: PUSH
38532: LD_EXP 134
38536: PPUSH
38537: LD_VAR 0 4
38541: PPUSH
38542: EMPTY
38543: PPUSH
38544: CALL_OW 1
38548: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
38549: LD_ADDR_EXP 135
38553: PUSH
38554: LD_EXP 135
38558: PPUSH
38559: LD_VAR 0 4
38563: PPUSH
38564: EMPTY
38565: PPUSH
38566: CALL_OW 1
38570: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
38571: LD_ADDR_EXP 136
38575: PUSH
38576: LD_EXP 136
38580: PPUSH
38581: LD_VAR 0 4
38585: PPUSH
38586: EMPTY
38587: PPUSH
38588: CALL_OW 1
38592: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
38593: LD_ADDR_EXP 137
38597: PUSH
38598: LD_EXP 137
38602: PPUSH
38603: LD_VAR 0 4
38607: PPUSH
38608: EMPTY
38609: PPUSH
38610: CALL_OW 1
38614: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
38615: LD_ADDR_EXP 138
38619: PUSH
38620: LD_EXP 138
38624: PPUSH
38625: LD_VAR 0 4
38629: PPUSH
38630: EMPTY
38631: PPUSH
38632: CALL_OW 1
38636: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
38637: LD_ADDR_EXP 139
38641: PUSH
38642: LD_EXP 139
38646: PPUSH
38647: LD_VAR 0 4
38651: PPUSH
38652: EMPTY
38653: PPUSH
38654: CALL_OW 1
38658: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
38659: LD_ADDR_EXP 140
38663: PUSH
38664: LD_EXP 140
38668: PPUSH
38669: LD_VAR 0 4
38673: PPUSH
38674: EMPTY
38675: PPUSH
38676: CALL_OW 1
38680: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
38681: LD_ADDR_EXP 141
38685: PUSH
38686: LD_EXP 141
38690: PPUSH
38691: LD_VAR 0 4
38695: PPUSH
38696: LD_INT 0
38698: PPUSH
38699: CALL_OW 1
38703: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
38704: LD_ADDR_EXP 142
38708: PUSH
38709: LD_EXP 142
38713: PPUSH
38714: LD_VAR 0 4
38718: PPUSH
38719: LD_INT 0
38721: PPUSH
38722: CALL_OW 1
38726: ST_TO_ADDR
// result := base ;
38727: LD_ADDR_VAR 0 3
38731: PUSH
38732: LD_VAR 0 4
38736: ST_TO_ADDR
// end ;
38737: LD_VAR 0 3
38741: RET
// export function MC_Start ( ) ; var i ; begin
38742: LD_INT 0
38744: PPUSH
38745: PPUSH
// for i = 1 to mc_bases do
38746: LD_ADDR_VAR 0 2
38750: PUSH
38751: DOUBLE
38752: LD_INT 1
38754: DEC
38755: ST_TO_ADDR
38756: LD_EXP 99
38760: PUSH
38761: FOR_TO
38762: IFFALSE 39862
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
38764: LD_ADDR_EXP 99
38768: PUSH
38769: LD_EXP 99
38773: PPUSH
38774: LD_VAR 0 2
38778: PPUSH
38779: LD_EXP 99
38783: PUSH
38784: LD_VAR 0 2
38788: ARRAY
38789: PUSH
38790: LD_INT 0
38792: DIFF
38793: PPUSH
38794: CALL_OW 1
38798: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
38799: LD_ADDR_EXP 100
38803: PUSH
38804: LD_EXP 100
38808: PPUSH
38809: LD_VAR 0 2
38813: PPUSH
38814: EMPTY
38815: PPUSH
38816: CALL_OW 1
38820: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
38821: LD_ADDR_EXP 101
38825: PUSH
38826: LD_EXP 101
38830: PPUSH
38831: LD_VAR 0 2
38835: PPUSH
38836: EMPTY
38837: PPUSH
38838: CALL_OW 1
38842: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
38843: LD_ADDR_EXP 102
38847: PUSH
38848: LD_EXP 102
38852: PPUSH
38853: LD_VAR 0 2
38857: PPUSH
38858: EMPTY
38859: PPUSH
38860: CALL_OW 1
38864: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
38865: LD_ADDR_EXP 103
38869: PUSH
38870: LD_EXP 103
38874: PPUSH
38875: LD_VAR 0 2
38879: PPUSH
38880: EMPTY
38881: PUSH
38882: EMPTY
38883: PUSH
38884: EMPTY
38885: LIST
38886: LIST
38887: PPUSH
38888: CALL_OW 1
38892: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
38893: LD_ADDR_EXP 104
38897: PUSH
38898: LD_EXP 104
38902: PPUSH
38903: LD_VAR 0 2
38907: PPUSH
38908: EMPTY
38909: PPUSH
38910: CALL_OW 1
38914: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
38915: LD_ADDR_EXP 131
38919: PUSH
38920: LD_EXP 131
38924: PPUSH
38925: LD_VAR 0 2
38929: PPUSH
38930: EMPTY
38931: PPUSH
38932: CALL_OW 1
38936: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
38937: LD_ADDR_EXP 105
38941: PUSH
38942: LD_EXP 105
38946: PPUSH
38947: LD_VAR 0 2
38951: PPUSH
38952: EMPTY
38953: PPUSH
38954: CALL_OW 1
38958: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
38959: LD_ADDR_EXP 106
38963: PUSH
38964: LD_EXP 106
38968: PPUSH
38969: LD_VAR 0 2
38973: PPUSH
38974: EMPTY
38975: PPUSH
38976: CALL_OW 1
38980: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
38981: LD_ADDR_EXP 107
38985: PUSH
38986: LD_EXP 107
38990: PPUSH
38991: LD_VAR 0 2
38995: PPUSH
38996: LD_EXP 99
39000: PUSH
39001: LD_VAR 0 2
39005: ARRAY
39006: PPUSH
39007: LD_INT 2
39009: PUSH
39010: LD_INT 30
39012: PUSH
39013: LD_INT 32
39015: PUSH
39016: EMPTY
39017: LIST
39018: LIST
39019: PUSH
39020: LD_INT 30
39022: PUSH
39023: LD_INT 33
39025: PUSH
39026: EMPTY
39027: LIST
39028: LIST
39029: PUSH
39030: EMPTY
39031: LIST
39032: LIST
39033: LIST
39034: PPUSH
39035: CALL_OW 72
39039: PPUSH
39040: CALL_OW 1
39044: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
39045: LD_ADDR_EXP 108
39049: PUSH
39050: LD_EXP 108
39054: PPUSH
39055: LD_VAR 0 2
39059: PPUSH
39060: LD_EXP 99
39064: PUSH
39065: LD_VAR 0 2
39069: ARRAY
39070: PPUSH
39071: LD_INT 2
39073: PUSH
39074: LD_INT 30
39076: PUSH
39077: LD_INT 32
39079: PUSH
39080: EMPTY
39081: LIST
39082: LIST
39083: PUSH
39084: LD_INT 30
39086: PUSH
39087: LD_INT 31
39089: PUSH
39090: EMPTY
39091: LIST
39092: LIST
39093: PUSH
39094: EMPTY
39095: LIST
39096: LIST
39097: LIST
39098: PUSH
39099: LD_INT 58
39101: PUSH
39102: EMPTY
39103: LIST
39104: PUSH
39105: EMPTY
39106: LIST
39107: LIST
39108: PPUSH
39109: CALL_OW 72
39113: PPUSH
39114: CALL_OW 1
39118: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
39119: LD_ADDR_EXP 109
39123: PUSH
39124: LD_EXP 109
39128: PPUSH
39129: LD_VAR 0 2
39133: PPUSH
39134: EMPTY
39135: PPUSH
39136: CALL_OW 1
39140: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
39141: LD_ADDR_EXP 113
39145: PUSH
39146: LD_EXP 113
39150: PPUSH
39151: LD_VAR 0 2
39155: PPUSH
39156: EMPTY
39157: PPUSH
39158: CALL_OW 1
39162: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
39163: LD_ADDR_EXP 112
39167: PUSH
39168: LD_EXP 112
39172: PPUSH
39173: LD_VAR 0 2
39177: PPUSH
39178: EMPTY
39179: PPUSH
39180: CALL_OW 1
39184: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
39185: LD_ADDR_EXP 114
39189: PUSH
39190: LD_EXP 114
39194: PPUSH
39195: LD_VAR 0 2
39199: PPUSH
39200: EMPTY
39201: PPUSH
39202: CALL_OW 1
39206: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
39207: LD_ADDR_EXP 115
39211: PUSH
39212: LD_EXP 115
39216: PPUSH
39217: LD_VAR 0 2
39221: PPUSH
39222: EMPTY
39223: PPUSH
39224: CALL_OW 1
39228: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
39229: LD_ADDR_EXP 116
39233: PUSH
39234: LD_EXP 116
39238: PPUSH
39239: LD_VAR 0 2
39243: PPUSH
39244: EMPTY
39245: PPUSH
39246: CALL_OW 1
39250: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
39251: LD_ADDR_EXP 117
39255: PUSH
39256: LD_EXP 117
39260: PPUSH
39261: LD_VAR 0 2
39265: PPUSH
39266: EMPTY
39267: PPUSH
39268: CALL_OW 1
39272: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
39273: LD_ADDR_EXP 118
39277: PUSH
39278: LD_EXP 118
39282: PPUSH
39283: LD_VAR 0 2
39287: PPUSH
39288: EMPTY
39289: PPUSH
39290: CALL_OW 1
39294: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
39295: LD_ADDR_EXP 119
39299: PUSH
39300: LD_EXP 119
39304: PPUSH
39305: LD_VAR 0 2
39309: PPUSH
39310: EMPTY
39311: PPUSH
39312: CALL_OW 1
39316: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
39317: LD_ADDR_EXP 120
39321: PUSH
39322: LD_EXP 120
39326: PPUSH
39327: LD_VAR 0 2
39331: PPUSH
39332: EMPTY
39333: PPUSH
39334: CALL_OW 1
39338: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
39339: LD_ADDR_EXP 121
39343: PUSH
39344: LD_EXP 121
39348: PPUSH
39349: LD_VAR 0 2
39353: PPUSH
39354: EMPTY
39355: PPUSH
39356: CALL_OW 1
39360: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
39361: LD_ADDR_EXP 110
39365: PUSH
39366: LD_EXP 110
39370: PPUSH
39371: LD_VAR 0 2
39375: PPUSH
39376: LD_INT 0
39378: PPUSH
39379: CALL_OW 1
39383: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
39384: LD_ADDR_EXP 123
39388: PUSH
39389: LD_EXP 123
39393: PPUSH
39394: LD_VAR 0 2
39398: PPUSH
39399: LD_INT 0
39401: PPUSH
39402: CALL_OW 1
39406: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
39407: LD_ADDR_EXP 111
39411: PUSH
39412: LD_EXP 111
39416: PPUSH
39417: LD_VAR 0 2
39421: PPUSH
39422: EMPTY
39423: PPUSH
39424: CALL_OW 1
39428: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
39429: LD_ADDR_EXP 122
39433: PUSH
39434: LD_EXP 122
39438: PPUSH
39439: LD_VAR 0 2
39443: PPUSH
39444: LD_INT 0
39446: PPUSH
39447: CALL_OW 1
39451: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
39452: LD_ADDR_EXP 124
39456: PUSH
39457: LD_EXP 124
39461: PPUSH
39462: LD_VAR 0 2
39466: PPUSH
39467: EMPTY
39468: PPUSH
39469: CALL_OW 1
39473: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
39474: LD_ADDR_EXP 127
39478: PUSH
39479: LD_EXP 127
39483: PPUSH
39484: LD_VAR 0 2
39488: PPUSH
39489: LD_INT 0
39491: PPUSH
39492: CALL_OW 1
39496: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
39497: LD_ADDR_EXP 128
39501: PUSH
39502: LD_EXP 128
39506: PPUSH
39507: LD_VAR 0 2
39511: PPUSH
39512: EMPTY
39513: PPUSH
39514: CALL_OW 1
39518: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
39519: LD_ADDR_EXP 129
39523: PUSH
39524: LD_EXP 129
39528: PPUSH
39529: LD_VAR 0 2
39533: PPUSH
39534: EMPTY
39535: PPUSH
39536: CALL_OW 1
39540: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39541: LD_ADDR_EXP 130
39545: PUSH
39546: LD_EXP 130
39550: PPUSH
39551: LD_VAR 0 2
39555: PPUSH
39556: EMPTY
39557: PPUSH
39558: CALL_OW 1
39562: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
39563: LD_ADDR_EXP 132
39567: PUSH
39568: LD_EXP 132
39572: PPUSH
39573: LD_VAR 0 2
39577: PPUSH
39578: LD_EXP 99
39582: PUSH
39583: LD_VAR 0 2
39587: ARRAY
39588: PPUSH
39589: LD_INT 2
39591: PUSH
39592: LD_INT 30
39594: PUSH
39595: LD_INT 6
39597: PUSH
39598: EMPTY
39599: LIST
39600: LIST
39601: PUSH
39602: LD_INT 30
39604: PUSH
39605: LD_INT 7
39607: PUSH
39608: EMPTY
39609: LIST
39610: LIST
39611: PUSH
39612: LD_INT 30
39614: PUSH
39615: LD_INT 8
39617: PUSH
39618: EMPTY
39619: LIST
39620: LIST
39621: PUSH
39622: EMPTY
39623: LIST
39624: LIST
39625: LIST
39626: LIST
39627: PPUSH
39628: CALL_OW 72
39632: PPUSH
39633: CALL_OW 1
39637: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
39638: LD_ADDR_EXP 133
39642: PUSH
39643: LD_EXP 133
39647: PPUSH
39648: LD_VAR 0 2
39652: PPUSH
39653: EMPTY
39654: PPUSH
39655: CALL_OW 1
39659: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
39660: LD_ADDR_EXP 134
39664: PUSH
39665: LD_EXP 134
39669: PPUSH
39670: LD_VAR 0 2
39674: PPUSH
39675: EMPTY
39676: PPUSH
39677: CALL_OW 1
39681: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
39682: LD_ADDR_EXP 135
39686: PUSH
39687: LD_EXP 135
39691: PPUSH
39692: LD_VAR 0 2
39696: PPUSH
39697: EMPTY
39698: PPUSH
39699: CALL_OW 1
39703: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
39704: LD_ADDR_EXP 136
39708: PUSH
39709: LD_EXP 136
39713: PPUSH
39714: LD_VAR 0 2
39718: PPUSH
39719: EMPTY
39720: PPUSH
39721: CALL_OW 1
39725: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39726: LD_ADDR_EXP 137
39730: PUSH
39731: LD_EXP 137
39735: PPUSH
39736: LD_VAR 0 2
39740: PPUSH
39741: EMPTY
39742: PPUSH
39743: CALL_OW 1
39747: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
39748: LD_ADDR_EXP 138
39752: PUSH
39753: LD_EXP 138
39757: PPUSH
39758: LD_VAR 0 2
39762: PPUSH
39763: EMPTY
39764: PPUSH
39765: CALL_OW 1
39769: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
39770: LD_ADDR_EXP 139
39774: PUSH
39775: LD_EXP 139
39779: PPUSH
39780: LD_VAR 0 2
39784: PPUSH
39785: EMPTY
39786: PPUSH
39787: CALL_OW 1
39791: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
39792: LD_ADDR_EXP 140
39796: PUSH
39797: LD_EXP 140
39801: PPUSH
39802: LD_VAR 0 2
39806: PPUSH
39807: EMPTY
39808: PPUSH
39809: CALL_OW 1
39813: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
39814: LD_ADDR_EXP 141
39818: PUSH
39819: LD_EXP 141
39823: PPUSH
39824: LD_VAR 0 2
39828: PPUSH
39829: LD_INT 0
39831: PPUSH
39832: CALL_OW 1
39836: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
39837: LD_ADDR_EXP 142
39841: PUSH
39842: LD_EXP 142
39846: PPUSH
39847: LD_VAR 0 2
39851: PPUSH
39852: LD_INT 0
39854: PPUSH
39855: CALL_OW 1
39859: ST_TO_ADDR
// end ;
39860: GO 38761
39862: POP
39863: POP
// MC_InitSides ( ) ;
39864: CALL 40150 0 0
// MC_InitResearch ( ) ;
39868: CALL 39889 0 0
// CustomInitMacro ( ) ;
39872: CALL 475 0 0
// skirmish := true ;
39876: LD_ADDR_EXP 97
39880: PUSH
39881: LD_INT 1
39883: ST_TO_ADDR
// end ;
39884: LD_VAR 0 1
39888: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
39889: LD_INT 0
39891: PPUSH
39892: PPUSH
39893: PPUSH
39894: PPUSH
39895: PPUSH
39896: PPUSH
// if not mc_bases then
39897: LD_EXP 99
39901: NOT
39902: IFFALSE 39906
// exit ;
39904: GO 40145
// for i = 1 to 8 do
39906: LD_ADDR_VAR 0 2
39910: PUSH
39911: DOUBLE
39912: LD_INT 1
39914: DEC
39915: ST_TO_ADDR
39916: LD_INT 8
39918: PUSH
39919: FOR_TO
39920: IFFALSE 39946
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
39922: LD_ADDR_EXP 126
39926: PUSH
39927: LD_EXP 126
39931: PPUSH
39932: LD_VAR 0 2
39936: PPUSH
39937: EMPTY
39938: PPUSH
39939: CALL_OW 1
39943: ST_TO_ADDR
39944: GO 39919
39946: POP
39947: POP
// tmp := [ ] ;
39948: LD_ADDR_VAR 0 5
39952: PUSH
39953: EMPTY
39954: ST_TO_ADDR
// for i = 1 to mc_sides do
39955: LD_ADDR_VAR 0 2
39959: PUSH
39960: DOUBLE
39961: LD_INT 1
39963: DEC
39964: ST_TO_ADDR
39965: LD_EXP 125
39969: PUSH
39970: FOR_TO
39971: IFFALSE 40029
// if not mc_sides [ i ] in tmp then
39973: LD_EXP 125
39977: PUSH
39978: LD_VAR 0 2
39982: ARRAY
39983: PUSH
39984: LD_VAR 0 5
39988: IN
39989: NOT
39990: IFFALSE 40027
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
39992: LD_ADDR_VAR 0 5
39996: PUSH
39997: LD_VAR 0 5
40001: PPUSH
40002: LD_VAR 0 5
40006: PUSH
40007: LD_INT 1
40009: PLUS
40010: PPUSH
40011: LD_EXP 125
40015: PUSH
40016: LD_VAR 0 2
40020: ARRAY
40021: PPUSH
40022: CALL_OW 2
40026: ST_TO_ADDR
40027: GO 39970
40029: POP
40030: POP
// if not tmp then
40031: LD_VAR 0 5
40035: NOT
40036: IFFALSE 40040
// exit ;
40038: GO 40145
// for j in tmp do
40040: LD_ADDR_VAR 0 3
40044: PUSH
40045: LD_VAR 0 5
40049: PUSH
40050: FOR_IN
40051: IFFALSE 40143
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
40053: LD_ADDR_VAR 0 6
40057: PUSH
40058: LD_INT 22
40060: PUSH
40061: LD_VAR 0 3
40065: PUSH
40066: EMPTY
40067: LIST
40068: LIST
40069: PPUSH
40070: CALL_OW 69
40074: ST_TO_ADDR
// if not un then
40075: LD_VAR 0 6
40079: NOT
40080: IFFALSE 40084
// continue ;
40082: GO 40050
// nation := GetNation ( un [ 1 ] ) ;
40084: LD_ADDR_VAR 0 4
40088: PUSH
40089: LD_VAR 0 6
40093: PUSH
40094: LD_INT 1
40096: ARRAY
40097: PPUSH
40098: CALL_OW 248
40102: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
40103: LD_ADDR_EXP 126
40107: PUSH
40108: LD_EXP 126
40112: PPUSH
40113: LD_VAR 0 3
40117: PPUSH
40118: LD_VAR 0 3
40122: PPUSH
40123: LD_VAR 0 4
40127: PPUSH
40128: LD_INT 1
40130: PPUSH
40131: CALL 67297 0 3
40135: PPUSH
40136: CALL_OW 1
40140: ST_TO_ADDR
// end ;
40141: GO 40050
40143: POP
40144: POP
// end ;
40145: LD_VAR 0 1
40149: RET
// export function MC_InitSides ( ) ; var i ; begin
40150: LD_INT 0
40152: PPUSH
40153: PPUSH
// if not mc_bases then
40154: LD_EXP 99
40158: NOT
40159: IFFALSE 40163
// exit ;
40161: GO 40237
// for i = 1 to mc_bases do
40163: LD_ADDR_VAR 0 2
40167: PUSH
40168: DOUBLE
40169: LD_INT 1
40171: DEC
40172: ST_TO_ADDR
40173: LD_EXP 99
40177: PUSH
40178: FOR_TO
40179: IFFALSE 40235
// if mc_bases [ i ] then
40181: LD_EXP 99
40185: PUSH
40186: LD_VAR 0 2
40190: ARRAY
40191: IFFALSE 40233
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
40193: LD_ADDR_EXP 125
40197: PUSH
40198: LD_EXP 125
40202: PPUSH
40203: LD_VAR 0 2
40207: PPUSH
40208: LD_EXP 99
40212: PUSH
40213: LD_VAR 0 2
40217: ARRAY
40218: PUSH
40219: LD_INT 1
40221: ARRAY
40222: PPUSH
40223: CALL_OW 255
40227: PPUSH
40228: CALL_OW 1
40232: ST_TO_ADDR
40233: GO 40178
40235: POP
40236: POP
// end ;
40237: LD_VAR 0 1
40241: RET
// every 0 0$03 trigger skirmish do
40242: LD_EXP 97
40246: IFFALSE 40400
40248: GO 40250
40250: DISABLE
// begin enable ;
40251: ENABLE
// MC_CheckBuildings ( ) ;
40252: CALL 44898 0 0
// MC_CheckPeopleLife ( ) ;
40256: CALL 45059 0 0
// RaiseSailEvent ( 100 ) ;
40260: LD_INT 100
40262: PPUSH
40263: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
40267: LD_INT 103
40269: PPUSH
40270: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
40274: LD_INT 104
40276: PPUSH
40277: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
40281: LD_INT 105
40283: PPUSH
40284: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
40288: LD_INT 106
40290: PPUSH
40291: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
40295: LD_INT 107
40297: PPUSH
40298: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
40302: LD_INT 108
40304: PPUSH
40305: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
40309: LD_INT 109
40311: PPUSH
40312: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
40316: LD_INT 110
40318: PPUSH
40319: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
40323: LD_INT 111
40325: PPUSH
40326: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
40330: LD_INT 112
40332: PPUSH
40333: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
40337: LD_INT 113
40339: PPUSH
40340: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
40344: LD_INT 120
40346: PPUSH
40347: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
40351: LD_INT 121
40353: PPUSH
40354: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
40358: LD_INT 122
40360: PPUSH
40361: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
40365: LD_INT 123
40367: PPUSH
40368: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
40372: LD_INT 124
40374: PPUSH
40375: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
40379: LD_INT 125
40381: PPUSH
40382: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
40386: LD_INT 126
40388: PPUSH
40389: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
40393: LD_INT 200
40395: PPUSH
40396: CALL_OW 427
// end ;
40400: END
// on SailEvent ( event ) do begin if event < 100 then
40401: LD_VAR 0 1
40405: PUSH
40406: LD_INT 100
40408: LESS
40409: IFFALSE 40420
// CustomEvent ( event ) ;
40411: LD_VAR 0 1
40415: PPUSH
40416: CALL 34964 0 1
// if event = 100 then
40420: LD_VAR 0 1
40424: PUSH
40425: LD_INT 100
40427: EQUAL
40428: IFFALSE 40434
// MC_ClassManager ( ) ;
40430: CALL 40826 0 0
// if event = 101 then
40434: LD_VAR 0 1
40438: PUSH
40439: LD_INT 101
40441: EQUAL
40442: IFFALSE 40448
// MC_RepairBuildings ( ) ;
40444: CALL 45644 0 0
// if event = 102 then
40448: LD_VAR 0 1
40452: PUSH
40453: LD_INT 102
40455: EQUAL
40456: IFFALSE 40462
// MC_Heal ( ) ;
40458: CALL 46579 0 0
// if event = 103 then
40462: LD_VAR 0 1
40466: PUSH
40467: LD_INT 103
40469: EQUAL
40470: IFFALSE 40476
// MC_Build ( ) ;
40472: CALL 47001 0 0
// if event = 104 then
40476: LD_VAR 0 1
40480: PUSH
40481: LD_INT 104
40483: EQUAL
40484: IFFALSE 40490
// MC_TurretWeapon ( ) ;
40486: CALL 48635 0 0
// if event = 105 then
40490: LD_VAR 0 1
40494: PUSH
40495: LD_INT 105
40497: EQUAL
40498: IFFALSE 40504
// MC_BuildUpgrade ( ) ;
40500: CALL 48186 0 0
// if event = 106 then
40504: LD_VAR 0 1
40508: PUSH
40509: LD_INT 106
40511: EQUAL
40512: IFFALSE 40518
// MC_PlantMines ( ) ;
40514: CALL 49065 0 0
// if event = 107 then
40518: LD_VAR 0 1
40522: PUSH
40523: LD_INT 107
40525: EQUAL
40526: IFFALSE 40532
// MC_CollectCrates ( ) ;
40528: CALL 49856 0 0
// if event = 108 then
40532: LD_VAR 0 1
40536: PUSH
40537: LD_INT 108
40539: EQUAL
40540: IFFALSE 40546
// MC_LinkRemoteControl ( ) ;
40542: CALL 51706 0 0
// if event = 109 then
40546: LD_VAR 0 1
40550: PUSH
40551: LD_INT 109
40553: EQUAL
40554: IFFALSE 40560
// MC_ProduceVehicle ( ) ;
40556: CALL 51887 0 0
// if event = 110 then
40560: LD_VAR 0 1
40564: PUSH
40565: LD_INT 110
40567: EQUAL
40568: IFFALSE 40574
// MC_SendAttack ( ) ;
40570: CALL 52353 0 0
// if event = 111 then
40574: LD_VAR 0 1
40578: PUSH
40579: LD_INT 111
40581: EQUAL
40582: IFFALSE 40588
// MC_Defend ( ) ;
40584: CALL 52461 0 0
// if event = 112 then
40588: LD_VAR 0 1
40592: PUSH
40593: LD_INT 112
40595: EQUAL
40596: IFFALSE 40602
// MC_Research ( ) ;
40598: CALL 53341 0 0
// if event = 113 then
40602: LD_VAR 0 1
40606: PUSH
40607: LD_INT 113
40609: EQUAL
40610: IFFALSE 40616
// MC_MinesTrigger ( ) ;
40612: CALL 54455 0 0
// if event = 120 then
40616: LD_VAR 0 1
40620: PUSH
40621: LD_INT 120
40623: EQUAL
40624: IFFALSE 40630
// MC_RepairVehicle ( ) ;
40626: CALL 54554 0 0
// if event = 121 then
40630: LD_VAR 0 1
40634: PUSH
40635: LD_INT 121
40637: EQUAL
40638: IFFALSE 40644
// MC_TameApe ( ) ;
40640: CALL 55323 0 0
// if event = 122 then
40644: LD_VAR 0 1
40648: PUSH
40649: LD_INT 122
40651: EQUAL
40652: IFFALSE 40658
// MC_ChangeApeClass ( ) ;
40654: CALL 56152 0 0
// if event = 123 then
40658: LD_VAR 0 1
40662: PUSH
40663: LD_INT 123
40665: EQUAL
40666: IFFALSE 40672
// MC_Bazooka ( ) ;
40668: CALL 56802 0 0
// if event = 124 then
40672: LD_VAR 0 1
40676: PUSH
40677: LD_INT 124
40679: EQUAL
40680: IFFALSE 40686
// MC_TeleportExit ( ) ;
40682: CALL 57000 0 0
// if event = 125 then
40686: LD_VAR 0 1
40690: PUSH
40691: LD_INT 125
40693: EQUAL
40694: IFFALSE 40700
// MC_Deposits ( ) ;
40696: CALL 57647 0 0
// if event = 126 then
40700: LD_VAR 0 1
40704: PUSH
40705: LD_INT 126
40707: EQUAL
40708: IFFALSE 40714
// MC_RemoteDriver ( ) ;
40710: CALL 58272 0 0
// if event = 200 then
40714: LD_VAR 0 1
40718: PUSH
40719: LD_INT 200
40721: EQUAL
40722: IFFALSE 40728
// MC_Idle ( ) ;
40724: CALL 60221 0 0
// end ;
40728: PPOPN 1
40730: END
// export function MC_Reset ( base , tag ) ; var i ; begin
40731: LD_INT 0
40733: PPUSH
40734: PPUSH
// if not mc_bases [ base ] or not tag then
40735: LD_EXP 99
40739: PUSH
40740: LD_VAR 0 1
40744: ARRAY
40745: NOT
40746: PUSH
40747: LD_VAR 0 2
40751: NOT
40752: OR
40753: IFFALSE 40757
// exit ;
40755: GO 40821
// for i in mc_bases [ base ] union mc_ape [ base ] do
40757: LD_ADDR_VAR 0 4
40761: PUSH
40762: LD_EXP 99
40766: PUSH
40767: LD_VAR 0 1
40771: ARRAY
40772: PUSH
40773: LD_EXP 128
40777: PUSH
40778: LD_VAR 0 1
40782: ARRAY
40783: UNION
40784: PUSH
40785: FOR_IN
40786: IFFALSE 40819
// if GetTag ( i ) = tag then
40788: LD_VAR 0 4
40792: PPUSH
40793: CALL_OW 110
40797: PUSH
40798: LD_VAR 0 2
40802: EQUAL
40803: IFFALSE 40817
// SetTag ( i , 0 ) ;
40805: LD_VAR 0 4
40809: PPUSH
40810: LD_INT 0
40812: PPUSH
40813: CALL_OW 109
40817: GO 40785
40819: POP
40820: POP
// end ;
40821: LD_VAR 0 3
40825: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
40826: LD_INT 0
40828: PPUSH
40829: PPUSH
40830: PPUSH
40831: PPUSH
40832: PPUSH
40833: PPUSH
40834: PPUSH
40835: PPUSH
// if not mc_bases then
40836: LD_EXP 99
40840: NOT
40841: IFFALSE 40845
// exit ;
40843: GO 41303
// for i = 1 to mc_bases do
40845: LD_ADDR_VAR 0 2
40849: PUSH
40850: DOUBLE
40851: LD_INT 1
40853: DEC
40854: ST_TO_ADDR
40855: LD_EXP 99
40859: PUSH
40860: FOR_TO
40861: IFFALSE 41301
// begin tmp := MC_ClassCheckReq ( i ) ;
40863: LD_ADDR_VAR 0 4
40867: PUSH
40868: LD_VAR 0 2
40872: PPUSH
40873: CALL 41308 0 1
40877: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
40878: LD_ADDR_EXP 140
40882: PUSH
40883: LD_EXP 140
40887: PPUSH
40888: LD_VAR 0 2
40892: PPUSH
40893: LD_VAR 0 4
40897: PPUSH
40898: CALL_OW 1
40902: ST_TO_ADDR
// if not tmp then
40903: LD_VAR 0 4
40907: NOT
40908: IFFALSE 40912
// continue ;
40910: GO 40860
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
40912: LD_ADDR_VAR 0 6
40916: PUSH
40917: LD_EXP 99
40921: PUSH
40922: LD_VAR 0 2
40926: ARRAY
40927: PPUSH
40928: LD_INT 2
40930: PUSH
40931: LD_INT 30
40933: PUSH
40934: LD_INT 4
40936: PUSH
40937: EMPTY
40938: LIST
40939: LIST
40940: PUSH
40941: LD_INT 30
40943: PUSH
40944: LD_INT 5
40946: PUSH
40947: EMPTY
40948: LIST
40949: LIST
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: LIST
40955: PPUSH
40956: CALL_OW 72
40960: PUSH
40961: LD_EXP 99
40965: PUSH
40966: LD_VAR 0 2
40970: ARRAY
40971: PPUSH
40972: LD_INT 2
40974: PUSH
40975: LD_INT 30
40977: PUSH
40978: LD_INT 0
40980: PUSH
40981: EMPTY
40982: LIST
40983: LIST
40984: PUSH
40985: LD_INT 30
40987: PUSH
40988: LD_INT 1
40990: PUSH
40991: EMPTY
40992: LIST
40993: LIST
40994: PUSH
40995: EMPTY
40996: LIST
40997: LIST
40998: LIST
40999: PPUSH
41000: CALL_OW 72
41004: PUSH
41005: LD_EXP 99
41009: PUSH
41010: LD_VAR 0 2
41014: ARRAY
41015: PPUSH
41016: LD_INT 30
41018: PUSH
41019: LD_INT 3
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PPUSH
41026: CALL_OW 72
41030: PUSH
41031: LD_EXP 99
41035: PUSH
41036: LD_VAR 0 2
41040: ARRAY
41041: PPUSH
41042: LD_INT 2
41044: PUSH
41045: LD_INT 30
41047: PUSH
41048: LD_INT 6
41050: PUSH
41051: EMPTY
41052: LIST
41053: LIST
41054: PUSH
41055: LD_INT 30
41057: PUSH
41058: LD_INT 7
41060: PUSH
41061: EMPTY
41062: LIST
41063: LIST
41064: PUSH
41065: LD_INT 30
41067: PUSH
41068: LD_INT 8
41070: PUSH
41071: EMPTY
41072: LIST
41073: LIST
41074: PUSH
41075: EMPTY
41076: LIST
41077: LIST
41078: LIST
41079: LIST
41080: PPUSH
41081: CALL_OW 72
41085: PUSH
41086: EMPTY
41087: LIST
41088: LIST
41089: LIST
41090: LIST
41091: ST_TO_ADDR
// for j = 1 to 4 do
41092: LD_ADDR_VAR 0 3
41096: PUSH
41097: DOUBLE
41098: LD_INT 1
41100: DEC
41101: ST_TO_ADDR
41102: LD_INT 4
41104: PUSH
41105: FOR_TO
41106: IFFALSE 41297
// begin if not tmp [ j ] then
41108: LD_VAR 0 4
41112: PUSH
41113: LD_VAR 0 3
41117: ARRAY
41118: NOT
41119: IFFALSE 41123
// continue ;
41121: GO 41105
// for p in tmp [ j ] do
41123: LD_ADDR_VAR 0 5
41127: PUSH
41128: LD_VAR 0 4
41132: PUSH
41133: LD_VAR 0 3
41137: ARRAY
41138: PUSH
41139: FOR_IN
41140: IFFALSE 41293
// begin if not b [ j ] then
41142: LD_VAR 0 6
41146: PUSH
41147: LD_VAR 0 3
41151: ARRAY
41152: NOT
41153: IFFALSE 41157
// break ;
41155: GO 41293
// e := 0 ;
41157: LD_ADDR_VAR 0 7
41161: PUSH
41162: LD_INT 0
41164: ST_TO_ADDR
// for k in b [ j ] do
41165: LD_ADDR_VAR 0 8
41169: PUSH
41170: LD_VAR 0 6
41174: PUSH
41175: LD_VAR 0 3
41179: ARRAY
41180: PUSH
41181: FOR_IN
41182: IFFALSE 41209
// if IsNotFull ( k ) then
41184: LD_VAR 0 8
41188: PPUSH
41189: CALL 69450 0 1
41193: IFFALSE 41207
// begin e := k ;
41195: LD_ADDR_VAR 0 7
41199: PUSH
41200: LD_VAR 0 8
41204: ST_TO_ADDR
// break ;
41205: GO 41209
// end ;
41207: GO 41181
41209: POP
41210: POP
// if e and not UnitGoingToBuilding ( p , e ) then
41211: LD_VAR 0 7
41215: PUSH
41216: LD_VAR 0 5
41220: PPUSH
41221: LD_VAR 0 7
41225: PPUSH
41226: CALL 103329 0 2
41230: NOT
41231: AND
41232: IFFALSE 41291
// begin if IsInUnit ( p ) then
41234: LD_VAR 0 5
41238: PPUSH
41239: CALL_OW 310
41243: IFFALSE 41254
// ComExitBuilding ( p ) ;
41245: LD_VAR 0 5
41249: PPUSH
41250: CALL_OW 122
// ComEnterUnit ( p , e ) ;
41254: LD_VAR 0 5
41258: PPUSH
41259: LD_VAR 0 7
41263: PPUSH
41264: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
41268: LD_VAR 0 5
41272: PPUSH
41273: LD_VAR 0 3
41277: PPUSH
41278: CALL_OW 183
// AddComExitBuilding ( p ) ;
41282: LD_VAR 0 5
41286: PPUSH
41287: CALL_OW 182
// end ; end ;
41291: GO 41139
41293: POP
41294: POP
// end ;
41295: GO 41105
41297: POP
41298: POP
// end ;
41299: GO 40860
41301: POP
41302: POP
// end ;
41303: LD_VAR 0 1
41307: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
41308: LD_INT 0
41310: PPUSH
41311: PPUSH
41312: PPUSH
41313: PPUSH
41314: PPUSH
41315: PPUSH
41316: PPUSH
41317: PPUSH
41318: PPUSH
41319: PPUSH
41320: PPUSH
41321: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41322: LD_VAR 0 1
41326: NOT
41327: PUSH
41328: LD_EXP 99
41332: PUSH
41333: LD_VAR 0 1
41337: ARRAY
41338: NOT
41339: OR
41340: PUSH
41341: LD_EXP 99
41345: PUSH
41346: LD_VAR 0 1
41350: ARRAY
41351: PPUSH
41352: LD_INT 2
41354: PUSH
41355: LD_INT 30
41357: PUSH
41358: LD_INT 0
41360: PUSH
41361: EMPTY
41362: LIST
41363: LIST
41364: PUSH
41365: LD_INT 30
41367: PUSH
41368: LD_INT 1
41370: PUSH
41371: EMPTY
41372: LIST
41373: LIST
41374: PUSH
41375: EMPTY
41376: LIST
41377: LIST
41378: LIST
41379: PPUSH
41380: CALL_OW 72
41384: NOT
41385: OR
41386: IFFALSE 41390
// exit ;
41388: GO 44893
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
41390: LD_ADDR_VAR 0 4
41394: PUSH
41395: LD_EXP 99
41399: PUSH
41400: LD_VAR 0 1
41404: ARRAY
41405: PPUSH
41406: LD_INT 2
41408: PUSH
41409: LD_INT 25
41411: PUSH
41412: LD_INT 1
41414: PUSH
41415: EMPTY
41416: LIST
41417: LIST
41418: PUSH
41419: LD_INT 25
41421: PUSH
41422: LD_INT 2
41424: PUSH
41425: EMPTY
41426: LIST
41427: LIST
41428: PUSH
41429: LD_INT 25
41431: PUSH
41432: LD_INT 3
41434: PUSH
41435: EMPTY
41436: LIST
41437: LIST
41438: PUSH
41439: LD_INT 25
41441: PUSH
41442: LD_INT 4
41444: PUSH
41445: EMPTY
41446: LIST
41447: LIST
41448: PUSH
41449: LD_INT 25
41451: PUSH
41452: LD_INT 5
41454: PUSH
41455: EMPTY
41456: LIST
41457: LIST
41458: PUSH
41459: LD_INT 25
41461: PUSH
41462: LD_INT 8
41464: PUSH
41465: EMPTY
41466: LIST
41467: LIST
41468: PUSH
41469: LD_INT 25
41471: PUSH
41472: LD_INT 9
41474: PUSH
41475: EMPTY
41476: LIST
41477: LIST
41478: PUSH
41479: EMPTY
41480: LIST
41481: LIST
41482: LIST
41483: LIST
41484: LIST
41485: LIST
41486: LIST
41487: LIST
41488: PPUSH
41489: CALL_OW 72
41493: ST_TO_ADDR
// if not tmp then
41494: LD_VAR 0 4
41498: NOT
41499: IFFALSE 41503
// exit ;
41501: GO 44893
// for i in tmp do
41503: LD_ADDR_VAR 0 3
41507: PUSH
41508: LD_VAR 0 4
41512: PUSH
41513: FOR_IN
41514: IFFALSE 41545
// if GetTag ( i ) then
41516: LD_VAR 0 3
41520: PPUSH
41521: CALL_OW 110
41525: IFFALSE 41543
// tmp := tmp diff i ;
41527: LD_ADDR_VAR 0 4
41531: PUSH
41532: LD_VAR 0 4
41536: PUSH
41537: LD_VAR 0 3
41541: DIFF
41542: ST_TO_ADDR
41543: GO 41513
41545: POP
41546: POP
// if not tmp then
41547: LD_VAR 0 4
41551: NOT
41552: IFFALSE 41556
// exit ;
41554: GO 44893
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
41556: LD_ADDR_VAR 0 5
41560: PUSH
41561: LD_EXP 99
41565: PUSH
41566: LD_VAR 0 1
41570: ARRAY
41571: PPUSH
41572: LD_INT 2
41574: PUSH
41575: LD_INT 25
41577: PUSH
41578: LD_INT 1
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: PUSH
41585: LD_INT 25
41587: PUSH
41588: LD_INT 5
41590: PUSH
41591: EMPTY
41592: LIST
41593: LIST
41594: PUSH
41595: LD_INT 25
41597: PUSH
41598: LD_INT 8
41600: PUSH
41601: EMPTY
41602: LIST
41603: LIST
41604: PUSH
41605: LD_INT 25
41607: PUSH
41608: LD_INT 9
41610: PUSH
41611: EMPTY
41612: LIST
41613: LIST
41614: PUSH
41615: EMPTY
41616: LIST
41617: LIST
41618: LIST
41619: LIST
41620: LIST
41621: PPUSH
41622: CALL_OW 72
41626: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
41627: LD_ADDR_VAR 0 6
41631: PUSH
41632: LD_EXP 99
41636: PUSH
41637: LD_VAR 0 1
41641: ARRAY
41642: PPUSH
41643: LD_INT 25
41645: PUSH
41646: LD_INT 2
41648: PUSH
41649: EMPTY
41650: LIST
41651: LIST
41652: PPUSH
41653: CALL_OW 72
41657: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
41658: LD_ADDR_VAR 0 7
41662: PUSH
41663: LD_EXP 99
41667: PUSH
41668: LD_VAR 0 1
41672: ARRAY
41673: PPUSH
41674: LD_INT 25
41676: PUSH
41677: LD_INT 3
41679: PUSH
41680: EMPTY
41681: LIST
41682: LIST
41683: PPUSH
41684: CALL_OW 72
41688: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
41689: LD_ADDR_VAR 0 8
41693: PUSH
41694: LD_EXP 99
41698: PUSH
41699: LD_VAR 0 1
41703: ARRAY
41704: PPUSH
41705: LD_INT 25
41707: PUSH
41708: LD_INT 4
41710: PUSH
41711: EMPTY
41712: LIST
41713: LIST
41714: PUSH
41715: LD_INT 24
41717: PUSH
41718: LD_INT 251
41720: PUSH
41721: EMPTY
41722: LIST
41723: LIST
41724: PUSH
41725: EMPTY
41726: LIST
41727: LIST
41728: PPUSH
41729: CALL_OW 72
41733: ST_TO_ADDR
// if mc_is_defending [ base ] then
41734: LD_EXP 142
41738: PUSH
41739: LD_VAR 0 1
41743: ARRAY
41744: IFFALSE 42205
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
41746: LD_ADDR_EXP 141
41750: PUSH
41751: LD_EXP 141
41755: PPUSH
41756: LD_VAR 0 1
41760: PPUSH
41761: LD_INT 4
41763: PPUSH
41764: CALL_OW 1
41768: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
41769: LD_ADDR_VAR 0 12
41773: PUSH
41774: LD_EXP 99
41778: PUSH
41779: LD_VAR 0 1
41783: ARRAY
41784: PPUSH
41785: LD_INT 2
41787: PUSH
41788: LD_INT 30
41790: PUSH
41791: LD_INT 4
41793: PUSH
41794: EMPTY
41795: LIST
41796: LIST
41797: PUSH
41798: LD_INT 30
41800: PUSH
41801: LD_INT 5
41803: PUSH
41804: EMPTY
41805: LIST
41806: LIST
41807: PUSH
41808: EMPTY
41809: LIST
41810: LIST
41811: LIST
41812: PPUSH
41813: CALL_OW 72
41817: ST_TO_ADDR
// if not b then
41818: LD_VAR 0 12
41822: NOT
41823: IFFALSE 41827
// exit ;
41825: GO 44893
// p := [ ] ;
41827: LD_ADDR_VAR 0 11
41831: PUSH
41832: EMPTY
41833: ST_TO_ADDR
// if sci >= 2 then
41834: LD_VAR 0 8
41838: PUSH
41839: LD_INT 2
41841: GREATEREQUAL
41842: IFFALSE 41873
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
41844: LD_ADDR_VAR 0 8
41848: PUSH
41849: LD_VAR 0 8
41853: PUSH
41854: LD_INT 1
41856: ARRAY
41857: PUSH
41858: LD_VAR 0 8
41862: PUSH
41863: LD_INT 2
41865: ARRAY
41866: PUSH
41867: EMPTY
41868: LIST
41869: LIST
41870: ST_TO_ADDR
41871: GO 41934
// if sci = 1 then
41873: LD_VAR 0 8
41877: PUSH
41878: LD_INT 1
41880: EQUAL
41881: IFFALSE 41902
// sci := [ sci [ 1 ] ] else
41883: LD_ADDR_VAR 0 8
41887: PUSH
41888: LD_VAR 0 8
41892: PUSH
41893: LD_INT 1
41895: ARRAY
41896: PUSH
41897: EMPTY
41898: LIST
41899: ST_TO_ADDR
41900: GO 41934
// if sci = 0 then
41902: LD_VAR 0 8
41906: PUSH
41907: LD_INT 0
41909: EQUAL
41910: IFFALSE 41934
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
41912: LD_ADDR_VAR 0 11
41916: PUSH
41917: LD_VAR 0 4
41921: PPUSH
41922: LD_INT 4
41924: PPUSH
41925: CALL 103192 0 2
41929: PUSH
41930: LD_INT 1
41932: ARRAY
41933: ST_TO_ADDR
// if eng > 4 then
41934: LD_VAR 0 6
41938: PUSH
41939: LD_INT 4
41941: GREATER
41942: IFFALSE 41988
// for i = eng downto 4 do
41944: LD_ADDR_VAR 0 3
41948: PUSH
41949: DOUBLE
41950: LD_VAR 0 6
41954: INC
41955: ST_TO_ADDR
41956: LD_INT 4
41958: PUSH
41959: FOR_DOWNTO
41960: IFFALSE 41986
// eng := eng diff eng [ i ] ;
41962: LD_ADDR_VAR 0 6
41966: PUSH
41967: LD_VAR 0 6
41971: PUSH
41972: LD_VAR 0 6
41976: PUSH
41977: LD_VAR 0 3
41981: ARRAY
41982: DIFF
41983: ST_TO_ADDR
41984: GO 41959
41986: POP
41987: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
41988: LD_ADDR_VAR 0 4
41992: PUSH
41993: LD_VAR 0 4
41997: PUSH
41998: LD_VAR 0 5
42002: PUSH
42003: LD_VAR 0 6
42007: UNION
42008: PUSH
42009: LD_VAR 0 7
42013: UNION
42014: PUSH
42015: LD_VAR 0 8
42019: UNION
42020: DIFF
42021: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
42022: LD_ADDR_VAR 0 13
42026: PUSH
42027: LD_EXP 99
42031: PUSH
42032: LD_VAR 0 1
42036: ARRAY
42037: PPUSH
42038: LD_INT 2
42040: PUSH
42041: LD_INT 30
42043: PUSH
42044: LD_INT 32
42046: PUSH
42047: EMPTY
42048: LIST
42049: LIST
42050: PUSH
42051: LD_INT 30
42053: PUSH
42054: LD_INT 31
42056: PUSH
42057: EMPTY
42058: LIST
42059: LIST
42060: PUSH
42061: EMPTY
42062: LIST
42063: LIST
42064: LIST
42065: PPUSH
42066: CALL_OW 72
42070: PUSH
42071: LD_EXP 99
42075: PUSH
42076: LD_VAR 0 1
42080: ARRAY
42081: PPUSH
42082: LD_INT 2
42084: PUSH
42085: LD_INT 30
42087: PUSH
42088: LD_INT 4
42090: PUSH
42091: EMPTY
42092: LIST
42093: LIST
42094: PUSH
42095: LD_INT 30
42097: PUSH
42098: LD_INT 5
42100: PUSH
42101: EMPTY
42102: LIST
42103: LIST
42104: PUSH
42105: EMPTY
42106: LIST
42107: LIST
42108: LIST
42109: PPUSH
42110: CALL_OW 72
42114: PUSH
42115: LD_INT 6
42117: MUL
42118: PLUS
42119: ST_TO_ADDR
// if bcount < tmp then
42120: LD_VAR 0 13
42124: PUSH
42125: LD_VAR 0 4
42129: LESS
42130: IFFALSE 42176
// for i = tmp downto bcount do
42132: LD_ADDR_VAR 0 3
42136: PUSH
42137: DOUBLE
42138: LD_VAR 0 4
42142: INC
42143: ST_TO_ADDR
42144: LD_VAR 0 13
42148: PUSH
42149: FOR_DOWNTO
42150: IFFALSE 42174
// tmp := Delete ( tmp , tmp ) ;
42152: LD_ADDR_VAR 0 4
42156: PUSH
42157: LD_VAR 0 4
42161: PPUSH
42162: LD_VAR 0 4
42166: PPUSH
42167: CALL_OW 3
42171: ST_TO_ADDR
42172: GO 42149
42174: POP
42175: POP
// result := [ tmp , 0 , 0 , p ] ;
42176: LD_ADDR_VAR 0 2
42180: PUSH
42181: LD_VAR 0 4
42185: PUSH
42186: LD_INT 0
42188: PUSH
42189: LD_INT 0
42191: PUSH
42192: LD_VAR 0 11
42196: PUSH
42197: EMPTY
42198: LIST
42199: LIST
42200: LIST
42201: LIST
42202: ST_TO_ADDR
// exit ;
42203: GO 44893
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42205: LD_EXP 99
42209: PUSH
42210: LD_VAR 0 1
42214: ARRAY
42215: PPUSH
42216: LD_INT 2
42218: PUSH
42219: LD_INT 30
42221: PUSH
42222: LD_INT 6
42224: PUSH
42225: EMPTY
42226: LIST
42227: LIST
42228: PUSH
42229: LD_INT 30
42231: PUSH
42232: LD_INT 7
42234: PUSH
42235: EMPTY
42236: LIST
42237: LIST
42238: PUSH
42239: LD_INT 30
42241: PUSH
42242: LD_INT 8
42244: PUSH
42245: EMPTY
42246: LIST
42247: LIST
42248: PUSH
42249: EMPTY
42250: LIST
42251: LIST
42252: LIST
42253: LIST
42254: PPUSH
42255: CALL_OW 72
42259: NOT
42260: PUSH
42261: LD_EXP 99
42265: PUSH
42266: LD_VAR 0 1
42270: ARRAY
42271: PPUSH
42272: LD_INT 30
42274: PUSH
42275: LD_INT 3
42277: PUSH
42278: EMPTY
42279: LIST
42280: LIST
42281: PPUSH
42282: CALL_OW 72
42286: NOT
42287: AND
42288: IFFALSE 42360
// begin if eng = tmp then
42290: LD_VAR 0 6
42294: PUSH
42295: LD_VAR 0 4
42299: EQUAL
42300: IFFALSE 42304
// exit ;
42302: GO 44893
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
42304: LD_ADDR_EXP 141
42308: PUSH
42309: LD_EXP 141
42313: PPUSH
42314: LD_VAR 0 1
42318: PPUSH
42319: LD_INT 1
42321: PPUSH
42322: CALL_OW 1
42326: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
42327: LD_ADDR_VAR 0 2
42331: PUSH
42332: LD_INT 0
42334: PUSH
42335: LD_VAR 0 4
42339: PUSH
42340: LD_VAR 0 6
42344: DIFF
42345: PUSH
42346: LD_INT 0
42348: PUSH
42349: LD_INT 0
42351: PUSH
42352: EMPTY
42353: LIST
42354: LIST
42355: LIST
42356: LIST
42357: ST_TO_ADDR
// exit ;
42358: GO 44893
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42360: LD_EXP 126
42364: PUSH
42365: LD_EXP 125
42369: PUSH
42370: LD_VAR 0 1
42374: ARRAY
42375: ARRAY
42376: PUSH
42377: LD_EXP 99
42381: PUSH
42382: LD_VAR 0 1
42386: ARRAY
42387: PPUSH
42388: LD_INT 2
42390: PUSH
42391: LD_INT 30
42393: PUSH
42394: LD_INT 6
42396: PUSH
42397: EMPTY
42398: LIST
42399: LIST
42400: PUSH
42401: LD_INT 30
42403: PUSH
42404: LD_INT 7
42406: PUSH
42407: EMPTY
42408: LIST
42409: LIST
42410: PUSH
42411: LD_INT 30
42413: PUSH
42414: LD_INT 8
42416: PUSH
42417: EMPTY
42418: LIST
42419: LIST
42420: PUSH
42421: EMPTY
42422: LIST
42423: LIST
42424: LIST
42425: LIST
42426: PPUSH
42427: CALL_OW 72
42431: AND
42432: PUSH
42433: LD_EXP 99
42437: PUSH
42438: LD_VAR 0 1
42442: ARRAY
42443: PPUSH
42444: LD_INT 30
42446: PUSH
42447: LD_INT 3
42449: PUSH
42450: EMPTY
42451: LIST
42452: LIST
42453: PPUSH
42454: CALL_OW 72
42458: NOT
42459: AND
42460: IFFALSE 42674
// begin if sci >= 6 then
42462: LD_VAR 0 8
42466: PUSH
42467: LD_INT 6
42469: GREATEREQUAL
42470: IFFALSE 42474
// exit ;
42472: GO 44893
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
42474: LD_ADDR_EXP 141
42478: PUSH
42479: LD_EXP 141
42483: PPUSH
42484: LD_VAR 0 1
42488: PPUSH
42489: LD_INT 2
42491: PPUSH
42492: CALL_OW 1
42496: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
42497: LD_ADDR_VAR 0 9
42501: PUSH
42502: LD_VAR 0 4
42506: PUSH
42507: LD_VAR 0 8
42511: DIFF
42512: PPUSH
42513: LD_INT 4
42515: PPUSH
42516: CALL 103192 0 2
42520: ST_TO_ADDR
// p := [ ] ;
42521: LD_ADDR_VAR 0 11
42525: PUSH
42526: EMPTY
42527: ST_TO_ADDR
// if sci < 6 and sort > 6 then
42528: LD_VAR 0 8
42532: PUSH
42533: LD_INT 6
42535: LESS
42536: PUSH
42537: LD_VAR 0 9
42541: PUSH
42542: LD_INT 6
42544: GREATER
42545: AND
42546: IFFALSE 42627
// begin for i = 1 to 6 - sci do
42548: LD_ADDR_VAR 0 3
42552: PUSH
42553: DOUBLE
42554: LD_INT 1
42556: DEC
42557: ST_TO_ADDR
42558: LD_INT 6
42560: PUSH
42561: LD_VAR 0 8
42565: MINUS
42566: PUSH
42567: FOR_TO
42568: IFFALSE 42623
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
42570: LD_ADDR_VAR 0 11
42574: PUSH
42575: LD_VAR 0 11
42579: PPUSH
42580: LD_VAR 0 11
42584: PUSH
42585: LD_INT 1
42587: PLUS
42588: PPUSH
42589: LD_VAR 0 9
42593: PUSH
42594: LD_INT 1
42596: ARRAY
42597: PPUSH
42598: CALL_OW 2
42602: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
42603: LD_ADDR_VAR 0 9
42607: PUSH
42608: LD_VAR 0 9
42612: PPUSH
42613: LD_INT 1
42615: PPUSH
42616: CALL_OW 3
42620: ST_TO_ADDR
// end ;
42621: GO 42567
42623: POP
42624: POP
// end else
42625: GO 42647
// if sort then
42627: LD_VAR 0 9
42631: IFFALSE 42647
// p := sort [ 1 ] ;
42633: LD_ADDR_VAR 0 11
42637: PUSH
42638: LD_VAR 0 9
42642: PUSH
42643: LD_INT 1
42645: ARRAY
42646: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
42647: LD_ADDR_VAR 0 2
42651: PUSH
42652: LD_INT 0
42654: PUSH
42655: LD_INT 0
42657: PUSH
42658: LD_INT 0
42660: PUSH
42661: LD_VAR 0 11
42665: PUSH
42666: EMPTY
42667: LIST
42668: LIST
42669: LIST
42670: LIST
42671: ST_TO_ADDR
// exit ;
42672: GO 44893
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42674: LD_EXP 126
42678: PUSH
42679: LD_EXP 125
42683: PUSH
42684: LD_VAR 0 1
42688: ARRAY
42689: ARRAY
42690: PUSH
42691: LD_EXP 99
42695: PUSH
42696: LD_VAR 0 1
42700: ARRAY
42701: PPUSH
42702: LD_INT 2
42704: PUSH
42705: LD_INT 30
42707: PUSH
42708: LD_INT 6
42710: PUSH
42711: EMPTY
42712: LIST
42713: LIST
42714: PUSH
42715: LD_INT 30
42717: PUSH
42718: LD_INT 7
42720: PUSH
42721: EMPTY
42722: LIST
42723: LIST
42724: PUSH
42725: LD_INT 30
42727: PUSH
42728: LD_INT 8
42730: PUSH
42731: EMPTY
42732: LIST
42733: LIST
42734: PUSH
42735: EMPTY
42736: LIST
42737: LIST
42738: LIST
42739: LIST
42740: PPUSH
42741: CALL_OW 72
42745: AND
42746: PUSH
42747: LD_EXP 99
42751: PUSH
42752: LD_VAR 0 1
42756: ARRAY
42757: PPUSH
42758: LD_INT 30
42760: PUSH
42761: LD_INT 3
42763: PUSH
42764: EMPTY
42765: LIST
42766: LIST
42767: PPUSH
42768: CALL_OW 72
42772: AND
42773: IFFALSE 43507
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
42775: LD_ADDR_EXP 141
42779: PUSH
42780: LD_EXP 141
42784: PPUSH
42785: LD_VAR 0 1
42789: PPUSH
42790: LD_INT 3
42792: PPUSH
42793: CALL_OW 1
42797: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42798: LD_ADDR_VAR 0 2
42802: PUSH
42803: LD_INT 0
42805: PUSH
42806: LD_INT 0
42808: PUSH
42809: LD_INT 0
42811: PUSH
42812: LD_INT 0
42814: PUSH
42815: EMPTY
42816: LIST
42817: LIST
42818: LIST
42819: LIST
42820: ST_TO_ADDR
// if not eng then
42821: LD_VAR 0 6
42825: NOT
42826: IFFALSE 42889
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
42828: LD_ADDR_VAR 0 11
42832: PUSH
42833: LD_VAR 0 4
42837: PPUSH
42838: LD_INT 2
42840: PPUSH
42841: CALL 103192 0 2
42845: PUSH
42846: LD_INT 1
42848: ARRAY
42849: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
42850: LD_ADDR_VAR 0 2
42854: PUSH
42855: LD_VAR 0 2
42859: PPUSH
42860: LD_INT 2
42862: PPUSH
42863: LD_VAR 0 11
42867: PPUSH
42868: CALL_OW 1
42872: ST_TO_ADDR
// tmp := tmp diff p ;
42873: LD_ADDR_VAR 0 4
42877: PUSH
42878: LD_VAR 0 4
42882: PUSH
42883: LD_VAR 0 11
42887: DIFF
42888: ST_TO_ADDR
// end ; if tmp and sci < 6 then
42889: LD_VAR 0 4
42893: PUSH
42894: LD_VAR 0 8
42898: PUSH
42899: LD_INT 6
42901: LESS
42902: AND
42903: IFFALSE 43091
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
42905: LD_ADDR_VAR 0 9
42909: PUSH
42910: LD_VAR 0 4
42914: PUSH
42915: LD_VAR 0 8
42919: PUSH
42920: LD_VAR 0 7
42924: UNION
42925: DIFF
42926: PPUSH
42927: LD_INT 4
42929: PPUSH
42930: CALL 103192 0 2
42934: ST_TO_ADDR
// p := [ ] ;
42935: LD_ADDR_VAR 0 11
42939: PUSH
42940: EMPTY
42941: ST_TO_ADDR
// if sort then
42942: LD_VAR 0 9
42946: IFFALSE 43062
// for i = 1 to 6 - sci do
42948: LD_ADDR_VAR 0 3
42952: PUSH
42953: DOUBLE
42954: LD_INT 1
42956: DEC
42957: ST_TO_ADDR
42958: LD_INT 6
42960: PUSH
42961: LD_VAR 0 8
42965: MINUS
42966: PUSH
42967: FOR_TO
42968: IFFALSE 43060
// begin if i = sort then
42970: LD_VAR 0 3
42974: PUSH
42975: LD_VAR 0 9
42979: EQUAL
42980: IFFALSE 42984
// break ;
42982: GO 43060
// if GetClass ( i ) = 4 then
42984: LD_VAR 0 3
42988: PPUSH
42989: CALL_OW 257
42993: PUSH
42994: LD_INT 4
42996: EQUAL
42997: IFFALSE 43001
// continue ;
42999: GO 42967
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43001: LD_ADDR_VAR 0 11
43005: PUSH
43006: LD_VAR 0 11
43010: PPUSH
43011: LD_VAR 0 11
43015: PUSH
43016: LD_INT 1
43018: PLUS
43019: PPUSH
43020: LD_VAR 0 9
43024: PUSH
43025: LD_VAR 0 3
43029: ARRAY
43030: PPUSH
43031: CALL_OW 2
43035: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43036: LD_ADDR_VAR 0 4
43040: PUSH
43041: LD_VAR 0 4
43045: PUSH
43046: LD_VAR 0 9
43050: PUSH
43051: LD_VAR 0 3
43055: ARRAY
43056: DIFF
43057: ST_TO_ADDR
// end ;
43058: GO 42967
43060: POP
43061: POP
// if p then
43062: LD_VAR 0 11
43066: IFFALSE 43091
// result := Replace ( result , 4 , p ) ;
43068: LD_ADDR_VAR 0 2
43072: PUSH
43073: LD_VAR 0 2
43077: PPUSH
43078: LD_INT 4
43080: PPUSH
43081: LD_VAR 0 11
43085: PPUSH
43086: CALL_OW 1
43090: ST_TO_ADDR
// end ; if tmp and mech < 6 then
43091: LD_VAR 0 4
43095: PUSH
43096: LD_VAR 0 7
43100: PUSH
43101: LD_INT 6
43103: LESS
43104: AND
43105: IFFALSE 43293
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
43107: LD_ADDR_VAR 0 9
43111: PUSH
43112: LD_VAR 0 4
43116: PUSH
43117: LD_VAR 0 8
43121: PUSH
43122: LD_VAR 0 7
43126: UNION
43127: DIFF
43128: PPUSH
43129: LD_INT 3
43131: PPUSH
43132: CALL 103192 0 2
43136: ST_TO_ADDR
// p := [ ] ;
43137: LD_ADDR_VAR 0 11
43141: PUSH
43142: EMPTY
43143: ST_TO_ADDR
// if sort then
43144: LD_VAR 0 9
43148: IFFALSE 43264
// for i = 1 to 6 - mech do
43150: LD_ADDR_VAR 0 3
43154: PUSH
43155: DOUBLE
43156: LD_INT 1
43158: DEC
43159: ST_TO_ADDR
43160: LD_INT 6
43162: PUSH
43163: LD_VAR 0 7
43167: MINUS
43168: PUSH
43169: FOR_TO
43170: IFFALSE 43262
// begin if i = sort then
43172: LD_VAR 0 3
43176: PUSH
43177: LD_VAR 0 9
43181: EQUAL
43182: IFFALSE 43186
// break ;
43184: GO 43262
// if GetClass ( i ) = 3 then
43186: LD_VAR 0 3
43190: PPUSH
43191: CALL_OW 257
43195: PUSH
43196: LD_INT 3
43198: EQUAL
43199: IFFALSE 43203
// continue ;
43201: GO 43169
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43203: LD_ADDR_VAR 0 11
43207: PUSH
43208: LD_VAR 0 11
43212: PPUSH
43213: LD_VAR 0 11
43217: PUSH
43218: LD_INT 1
43220: PLUS
43221: PPUSH
43222: LD_VAR 0 9
43226: PUSH
43227: LD_VAR 0 3
43231: ARRAY
43232: PPUSH
43233: CALL_OW 2
43237: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43238: LD_ADDR_VAR 0 4
43242: PUSH
43243: LD_VAR 0 4
43247: PUSH
43248: LD_VAR 0 9
43252: PUSH
43253: LD_VAR 0 3
43257: ARRAY
43258: DIFF
43259: ST_TO_ADDR
// end ;
43260: GO 43169
43262: POP
43263: POP
// if p then
43264: LD_VAR 0 11
43268: IFFALSE 43293
// result := Replace ( result , 3 , p ) ;
43270: LD_ADDR_VAR 0 2
43274: PUSH
43275: LD_VAR 0 2
43279: PPUSH
43280: LD_INT 3
43282: PPUSH
43283: LD_VAR 0 11
43287: PPUSH
43288: CALL_OW 1
43292: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
43293: LD_VAR 0 4
43297: PUSH
43298: LD_INT 6
43300: GREATER
43301: PUSH
43302: LD_VAR 0 6
43306: PUSH
43307: LD_INT 6
43309: LESS
43310: AND
43311: IFFALSE 43505
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
43313: LD_ADDR_VAR 0 9
43317: PUSH
43318: LD_VAR 0 4
43322: PUSH
43323: LD_VAR 0 8
43327: PUSH
43328: LD_VAR 0 7
43332: UNION
43333: PUSH
43334: LD_VAR 0 6
43338: UNION
43339: DIFF
43340: PPUSH
43341: LD_INT 2
43343: PPUSH
43344: CALL 103192 0 2
43348: ST_TO_ADDR
// p := [ ] ;
43349: LD_ADDR_VAR 0 11
43353: PUSH
43354: EMPTY
43355: ST_TO_ADDR
// if sort then
43356: LD_VAR 0 9
43360: IFFALSE 43476
// for i = 1 to 6 - eng do
43362: LD_ADDR_VAR 0 3
43366: PUSH
43367: DOUBLE
43368: LD_INT 1
43370: DEC
43371: ST_TO_ADDR
43372: LD_INT 6
43374: PUSH
43375: LD_VAR 0 6
43379: MINUS
43380: PUSH
43381: FOR_TO
43382: IFFALSE 43474
// begin if i = sort then
43384: LD_VAR 0 3
43388: PUSH
43389: LD_VAR 0 9
43393: EQUAL
43394: IFFALSE 43398
// break ;
43396: GO 43474
// if GetClass ( i ) = 2 then
43398: LD_VAR 0 3
43402: PPUSH
43403: CALL_OW 257
43407: PUSH
43408: LD_INT 2
43410: EQUAL
43411: IFFALSE 43415
// continue ;
43413: GO 43381
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43415: LD_ADDR_VAR 0 11
43419: PUSH
43420: LD_VAR 0 11
43424: PPUSH
43425: LD_VAR 0 11
43429: PUSH
43430: LD_INT 1
43432: PLUS
43433: PPUSH
43434: LD_VAR 0 9
43438: PUSH
43439: LD_VAR 0 3
43443: ARRAY
43444: PPUSH
43445: CALL_OW 2
43449: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43450: LD_ADDR_VAR 0 4
43454: PUSH
43455: LD_VAR 0 4
43459: PUSH
43460: LD_VAR 0 9
43464: PUSH
43465: LD_VAR 0 3
43469: ARRAY
43470: DIFF
43471: ST_TO_ADDR
// end ;
43472: GO 43381
43474: POP
43475: POP
// if p then
43476: LD_VAR 0 11
43480: IFFALSE 43505
// result := Replace ( result , 2 , p ) ;
43482: LD_ADDR_VAR 0 2
43486: PUSH
43487: LD_VAR 0 2
43491: PPUSH
43492: LD_INT 2
43494: PPUSH
43495: LD_VAR 0 11
43499: PPUSH
43500: CALL_OW 1
43504: ST_TO_ADDR
// end ; exit ;
43505: GO 44893
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
43507: LD_EXP 126
43511: PUSH
43512: LD_EXP 125
43516: PUSH
43517: LD_VAR 0 1
43521: ARRAY
43522: ARRAY
43523: NOT
43524: PUSH
43525: LD_EXP 99
43529: PUSH
43530: LD_VAR 0 1
43534: ARRAY
43535: PPUSH
43536: LD_INT 30
43538: PUSH
43539: LD_INT 3
43541: PUSH
43542: EMPTY
43543: LIST
43544: LIST
43545: PPUSH
43546: CALL_OW 72
43550: AND
43551: PUSH
43552: LD_EXP 104
43556: PUSH
43557: LD_VAR 0 1
43561: ARRAY
43562: AND
43563: IFFALSE 44171
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
43565: LD_ADDR_EXP 141
43569: PUSH
43570: LD_EXP 141
43574: PPUSH
43575: LD_VAR 0 1
43579: PPUSH
43580: LD_INT 5
43582: PPUSH
43583: CALL_OW 1
43587: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
43588: LD_ADDR_VAR 0 2
43592: PUSH
43593: LD_INT 0
43595: PUSH
43596: LD_INT 0
43598: PUSH
43599: LD_INT 0
43601: PUSH
43602: LD_INT 0
43604: PUSH
43605: EMPTY
43606: LIST
43607: LIST
43608: LIST
43609: LIST
43610: ST_TO_ADDR
// if sci > 1 then
43611: LD_VAR 0 8
43615: PUSH
43616: LD_INT 1
43618: GREATER
43619: IFFALSE 43647
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
43621: LD_ADDR_VAR 0 4
43625: PUSH
43626: LD_VAR 0 4
43630: PUSH
43631: LD_VAR 0 8
43635: PUSH
43636: LD_VAR 0 8
43640: PUSH
43641: LD_INT 1
43643: ARRAY
43644: DIFF
43645: DIFF
43646: ST_TO_ADDR
// if tmp and not sci then
43647: LD_VAR 0 4
43651: PUSH
43652: LD_VAR 0 8
43656: NOT
43657: AND
43658: IFFALSE 43727
// begin sort := SortBySkill ( tmp , 4 ) ;
43660: LD_ADDR_VAR 0 9
43664: PUSH
43665: LD_VAR 0 4
43669: PPUSH
43670: LD_INT 4
43672: PPUSH
43673: CALL 103192 0 2
43677: ST_TO_ADDR
// if sort then
43678: LD_VAR 0 9
43682: IFFALSE 43698
// p := sort [ 1 ] ;
43684: LD_ADDR_VAR 0 11
43688: PUSH
43689: LD_VAR 0 9
43693: PUSH
43694: LD_INT 1
43696: ARRAY
43697: ST_TO_ADDR
// if p then
43698: LD_VAR 0 11
43702: IFFALSE 43727
// result := Replace ( result , 4 , p ) ;
43704: LD_ADDR_VAR 0 2
43708: PUSH
43709: LD_VAR 0 2
43713: PPUSH
43714: LD_INT 4
43716: PPUSH
43717: LD_VAR 0 11
43721: PPUSH
43722: CALL_OW 1
43726: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
43727: LD_ADDR_VAR 0 4
43731: PUSH
43732: LD_VAR 0 4
43736: PUSH
43737: LD_VAR 0 7
43741: DIFF
43742: ST_TO_ADDR
// if tmp and mech < 6 then
43743: LD_VAR 0 4
43747: PUSH
43748: LD_VAR 0 7
43752: PUSH
43753: LD_INT 6
43755: LESS
43756: AND
43757: IFFALSE 43945
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
43759: LD_ADDR_VAR 0 9
43763: PUSH
43764: LD_VAR 0 4
43768: PUSH
43769: LD_VAR 0 8
43773: PUSH
43774: LD_VAR 0 7
43778: UNION
43779: DIFF
43780: PPUSH
43781: LD_INT 3
43783: PPUSH
43784: CALL 103192 0 2
43788: ST_TO_ADDR
// p := [ ] ;
43789: LD_ADDR_VAR 0 11
43793: PUSH
43794: EMPTY
43795: ST_TO_ADDR
// if sort then
43796: LD_VAR 0 9
43800: IFFALSE 43916
// for i = 1 to 6 - mech do
43802: LD_ADDR_VAR 0 3
43806: PUSH
43807: DOUBLE
43808: LD_INT 1
43810: DEC
43811: ST_TO_ADDR
43812: LD_INT 6
43814: PUSH
43815: LD_VAR 0 7
43819: MINUS
43820: PUSH
43821: FOR_TO
43822: IFFALSE 43914
// begin if i = sort then
43824: LD_VAR 0 3
43828: PUSH
43829: LD_VAR 0 9
43833: EQUAL
43834: IFFALSE 43838
// break ;
43836: GO 43914
// if GetClass ( i ) = 3 then
43838: LD_VAR 0 3
43842: PPUSH
43843: CALL_OW 257
43847: PUSH
43848: LD_INT 3
43850: EQUAL
43851: IFFALSE 43855
// continue ;
43853: GO 43821
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43855: LD_ADDR_VAR 0 11
43859: PUSH
43860: LD_VAR 0 11
43864: PPUSH
43865: LD_VAR 0 11
43869: PUSH
43870: LD_INT 1
43872: PLUS
43873: PPUSH
43874: LD_VAR 0 9
43878: PUSH
43879: LD_VAR 0 3
43883: ARRAY
43884: PPUSH
43885: CALL_OW 2
43889: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43890: LD_ADDR_VAR 0 4
43894: PUSH
43895: LD_VAR 0 4
43899: PUSH
43900: LD_VAR 0 9
43904: PUSH
43905: LD_VAR 0 3
43909: ARRAY
43910: DIFF
43911: ST_TO_ADDR
// end ;
43912: GO 43821
43914: POP
43915: POP
// if p then
43916: LD_VAR 0 11
43920: IFFALSE 43945
// result := Replace ( result , 3 , p ) ;
43922: LD_ADDR_VAR 0 2
43926: PUSH
43927: LD_VAR 0 2
43931: PPUSH
43932: LD_INT 3
43934: PPUSH
43935: LD_VAR 0 11
43939: PPUSH
43940: CALL_OW 1
43944: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
43945: LD_ADDR_VAR 0 4
43949: PUSH
43950: LD_VAR 0 4
43954: PUSH
43955: LD_VAR 0 6
43959: DIFF
43960: ST_TO_ADDR
// if tmp and eng < 6 then
43961: LD_VAR 0 4
43965: PUSH
43966: LD_VAR 0 6
43970: PUSH
43971: LD_INT 6
43973: LESS
43974: AND
43975: IFFALSE 44169
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
43977: LD_ADDR_VAR 0 9
43981: PUSH
43982: LD_VAR 0 4
43986: PUSH
43987: LD_VAR 0 8
43991: PUSH
43992: LD_VAR 0 7
43996: UNION
43997: PUSH
43998: LD_VAR 0 6
44002: UNION
44003: DIFF
44004: PPUSH
44005: LD_INT 2
44007: PPUSH
44008: CALL 103192 0 2
44012: ST_TO_ADDR
// p := [ ] ;
44013: LD_ADDR_VAR 0 11
44017: PUSH
44018: EMPTY
44019: ST_TO_ADDR
// if sort then
44020: LD_VAR 0 9
44024: IFFALSE 44140
// for i = 1 to 6 - eng do
44026: LD_ADDR_VAR 0 3
44030: PUSH
44031: DOUBLE
44032: LD_INT 1
44034: DEC
44035: ST_TO_ADDR
44036: LD_INT 6
44038: PUSH
44039: LD_VAR 0 6
44043: MINUS
44044: PUSH
44045: FOR_TO
44046: IFFALSE 44138
// begin if i = sort then
44048: LD_VAR 0 3
44052: PUSH
44053: LD_VAR 0 9
44057: EQUAL
44058: IFFALSE 44062
// break ;
44060: GO 44138
// if GetClass ( i ) = 2 then
44062: LD_VAR 0 3
44066: PPUSH
44067: CALL_OW 257
44071: PUSH
44072: LD_INT 2
44074: EQUAL
44075: IFFALSE 44079
// continue ;
44077: GO 44045
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44079: LD_ADDR_VAR 0 11
44083: PUSH
44084: LD_VAR 0 11
44088: PPUSH
44089: LD_VAR 0 11
44093: PUSH
44094: LD_INT 1
44096: PLUS
44097: PPUSH
44098: LD_VAR 0 9
44102: PUSH
44103: LD_VAR 0 3
44107: ARRAY
44108: PPUSH
44109: CALL_OW 2
44113: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44114: LD_ADDR_VAR 0 4
44118: PUSH
44119: LD_VAR 0 4
44123: PUSH
44124: LD_VAR 0 9
44128: PUSH
44129: LD_VAR 0 3
44133: ARRAY
44134: DIFF
44135: ST_TO_ADDR
// end ;
44136: GO 44045
44138: POP
44139: POP
// if p then
44140: LD_VAR 0 11
44144: IFFALSE 44169
// result := Replace ( result , 2 , p ) ;
44146: LD_ADDR_VAR 0 2
44150: PUSH
44151: LD_VAR 0 2
44155: PPUSH
44156: LD_INT 2
44158: PPUSH
44159: LD_VAR 0 11
44163: PPUSH
44164: CALL_OW 1
44168: ST_TO_ADDR
// end ; exit ;
44169: GO 44893
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
44171: LD_EXP 126
44175: PUSH
44176: LD_EXP 125
44180: PUSH
44181: LD_VAR 0 1
44185: ARRAY
44186: ARRAY
44187: NOT
44188: PUSH
44189: LD_EXP 99
44193: PUSH
44194: LD_VAR 0 1
44198: ARRAY
44199: PPUSH
44200: LD_INT 30
44202: PUSH
44203: LD_INT 3
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PPUSH
44210: CALL_OW 72
44214: AND
44215: PUSH
44216: LD_EXP 104
44220: PUSH
44221: LD_VAR 0 1
44225: ARRAY
44226: NOT
44227: AND
44228: IFFALSE 44893
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
44230: LD_ADDR_EXP 141
44234: PUSH
44235: LD_EXP 141
44239: PPUSH
44240: LD_VAR 0 1
44244: PPUSH
44245: LD_INT 6
44247: PPUSH
44248: CALL_OW 1
44252: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
44253: LD_ADDR_VAR 0 2
44257: PUSH
44258: LD_INT 0
44260: PUSH
44261: LD_INT 0
44263: PUSH
44264: LD_INT 0
44266: PUSH
44267: LD_INT 0
44269: PUSH
44270: EMPTY
44271: LIST
44272: LIST
44273: LIST
44274: LIST
44275: ST_TO_ADDR
// if sci >= 1 then
44276: LD_VAR 0 8
44280: PUSH
44281: LD_INT 1
44283: GREATEREQUAL
44284: IFFALSE 44306
// tmp := tmp diff sci [ 1 ] ;
44286: LD_ADDR_VAR 0 4
44290: PUSH
44291: LD_VAR 0 4
44295: PUSH
44296: LD_VAR 0 8
44300: PUSH
44301: LD_INT 1
44303: ARRAY
44304: DIFF
44305: ST_TO_ADDR
// if tmp and not sci then
44306: LD_VAR 0 4
44310: PUSH
44311: LD_VAR 0 8
44315: NOT
44316: AND
44317: IFFALSE 44386
// begin sort := SortBySkill ( tmp , 4 ) ;
44319: LD_ADDR_VAR 0 9
44323: PUSH
44324: LD_VAR 0 4
44328: PPUSH
44329: LD_INT 4
44331: PPUSH
44332: CALL 103192 0 2
44336: ST_TO_ADDR
// if sort then
44337: LD_VAR 0 9
44341: IFFALSE 44357
// p := sort [ 1 ] ;
44343: LD_ADDR_VAR 0 11
44347: PUSH
44348: LD_VAR 0 9
44352: PUSH
44353: LD_INT 1
44355: ARRAY
44356: ST_TO_ADDR
// if p then
44357: LD_VAR 0 11
44361: IFFALSE 44386
// result := Replace ( result , 4 , p ) ;
44363: LD_ADDR_VAR 0 2
44367: PUSH
44368: LD_VAR 0 2
44372: PPUSH
44373: LD_INT 4
44375: PPUSH
44376: LD_VAR 0 11
44380: PPUSH
44381: CALL_OW 1
44385: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
44386: LD_ADDR_VAR 0 4
44390: PUSH
44391: LD_VAR 0 4
44395: PUSH
44396: LD_VAR 0 7
44400: DIFF
44401: ST_TO_ADDR
// if tmp and mech < 6 then
44402: LD_VAR 0 4
44406: PUSH
44407: LD_VAR 0 7
44411: PUSH
44412: LD_INT 6
44414: LESS
44415: AND
44416: IFFALSE 44598
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
44418: LD_ADDR_VAR 0 9
44422: PUSH
44423: LD_VAR 0 4
44427: PUSH
44428: LD_VAR 0 7
44432: DIFF
44433: PPUSH
44434: LD_INT 3
44436: PPUSH
44437: CALL 103192 0 2
44441: ST_TO_ADDR
// p := [ ] ;
44442: LD_ADDR_VAR 0 11
44446: PUSH
44447: EMPTY
44448: ST_TO_ADDR
// if sort then
44449: LD_VAR 0 9
44453: IFFALSE 44569
// for i = 1 to 6 - mech do
44455: LD_ADDR_VAR 0 3
44459: PUSH
44460: DOUBLE
44461: LD_INT 1
44463: DEC
44464: ST_TO_ADDR
44465: LD_INT 6
44467: PUSH
44468: LD_VAR 0 7
44472: MINUS
44473: PUSH
44474: FOR_TO
44475: IFFALSE 44567
// begin if i = sort then
44477: LD_VAR 0 3
44481: PUSH
44482: LD_VAR 0 9
44486: EQUAL
44487: IFFALSE 44491
// break ;
44489: GO 44567
// if GetClass ( i ) = 3 then
44491: LD_VAR 0 3
44495: PPUSH
44496: CALL_OW 257
44500: PUSH
44501: LD_INT 3
44503: EQUAL
44504: IFFALSE 44508
// continue ;
44506: GO 44474
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44508: LD_ADDR_VAR 0 11
44512: PUSH
44513: LD_VAR 0 11
44517: PPUSH
44518: LD_VAR 0 11
44522: PUSH
44523: LD_INT 1
44525: PLUS
44526: PPUSH
44527: LD_VAR 0 9
44531: PUSH
44532: LD_VAR 0 3
44536: ARRAY
44537: PPUSH
44538: CALL_OW 2
44542: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44543: LD_ADDR_VAR 0 4
44547: PUSH
44548: LD_VAR 0 4
44552: PUSH
44553: LD_VAR 0 9
44557: PUSH
44558: LD_VAR 0 3
44562: ARRAY
44563: DIFF
44564: ST_TO_ADDR
// end ;
44565: GO 44474
44567: POP
44568: POP
// if p then
44569: LD_VAR 0 11
44573: IFFALSE 44598
// result := Replace ( result , 3 , p ) ;
44575: LD_ADDR_VAR 0 2
44579: PUSH
44580: LD_VAR 0 2
44584: PPUSH
44585: LD_INT 3
44587: PPUSH
44588: LD_VAR 0 11
44592: PPUSH
44593: CALL_OW 1
44597: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
44598: LD_ADDR_VAR 0 4
44602: PUSH
44603: LD_VAR 0 4
44607: PUSH
44608: LD_VAR 0 6
44612: DIFF
44613: ST_TO_ADDR
// if tmp and eng < 4 then
44614: LD_VAR 0 4
44618: PUSH
44619: LD_VAR 0 6
44623: PUSH
44624: LD_INT 4
44626: LESS
44627: AND
44628: IFFALSE 44818
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
44630: LD_ADDR_VAR 0 9
44634: PUSH
44635: LD_VAR 0 4
44639: PUSH
44640: LD_VAR 0 7
44644: PUSH
44645: LD_VAR 0 6
44649: UNION
44650: DIFF
44651: PPUSH
44652: LD_INT 2
44654: PPUSH
44655: CALL 103192 0 2
44659: ST_TO_ADDR
// p := [ ] ;
44660: LD_ADDR_VAR 0 11
44664: PUSH
44665: EMPTY
44666: ST_TO_ADDR
// if sort then
44667: LD_VAR 0 9
44671: IFFALSE 44787
// for i = 1 to 4 - eng do
44673: LD_ADDR_VAR 0 3
44677: PUSH
44678: DOUBLE
44679: LD_INT 1
44681: DEC
44682: ST_TO_ADDR
44683: LD_INT 4
44685: PUSH
44686: LD_VAR 0 6
44690: MINUS
44691: PUSH
44692: FOR_TO
44693: IFFALSE 44785
// begin if i = sort then
44695: LD_VAR 0 3
44699: PUSH
44700: LD_VAR 0 9
44704: EQUAL
44705: IFFALSE 44709
// break ;
44707: GO 44785
// if GetClass ( i ) = 2 then
44709: LD_VAR 0 3
44713: PPUSH
44714: CALL_OW 257
44718: PUSH
44719: LD_INT 2
44721: EQUAL
44722: IFFALSE 44726
// continue ;
44724: GO 44692
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44726: LD_ADDR_VAR 0 11
44730: PUSH
44731: LD_VAR 0 11
44735: PPUSH
44736: LD_VAR 0 11
44740: PUSH
44741: LD_INT 1
44743: PLUS
44744: PPUSH
44745: LD_VAR 0 9
44749: PUSH
44750: LD_VAR 0 3
44754: ARRAY
44755: PPUSH
44756: CALL_OW 2
44760: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44761: LD_ADDR_VAR 0 4
44765: PUSH
44766: LD_VAR 0 4
44770: PUSH
44771: LD_VAR 0 9
44775: PUSH
44776: LD_VAR 0 3
44780: ARRAY
44781: DIFF
44782: ST_TO_ADDR
// end ;
44783: GO 44692
44785: POP
44786: POP
// if p then
44787: LD_VAR 0 11
44791: IFFALSE 44816
// result := Replace ( result , 2 , p ) ;
44793: LD_ADDR_VAR 0 2
44797: PUSH
44798: LD_VAR 0 2
44802: PPUSH
44803: LD_INT 2
44805: PPUSH
44806: LD_VAR 0 11
44810: PPUSH
44811: CALL_OW 1
44815: ST_TO_ADDR
// end else
44816: GO 44862
// for i = eng downto 5 do
44818: LD_ADDR_VAR 0 3
44822: PUSH
44823: DOUBLE
44824: LD_VAR 0 6
44828: INC
44829: ST_TO_ADDR
44830: LD_INT 5
44832: PUSH
44833: FOR_DOWNTO
44834: IFFALSE 44860
// tmp := tmp union eng [ i ] ;
44836: LD_ADDR_VAR 0 4
44840: PUSH
44841: LD_VAR 0 4
44845: PUSH
44846: LD_VAR 0 6
44850: PUSH
44851: LD_VAR 0 3
44855: ARRAY
44856: UNION
44857: ST_TO_ADDR
44858: GO 44833
44860: POP
44861: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
44862: LD_ADDR_VAR 0 2
44866: PUSH
44867: LD_VAR 0 2
44871: PPUSH
44872: LD_INT 1
44874: PPUSH
44875: LD_VAR 0 4
44879: PUSH
44880: LD_VAR 0 5
44884: DIFF
44885: PPUSH
44886: CALL_OW 1
44890: ST_TO_ADDR
// exit ;
44891: GO 44893
// end ; end ;
44893: LD_VAR 0 2
44897: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
44898: LD_INT 0
44900: PPUSH
44901: PPUSH
44902: PPUSH
// if not mc_bases then
44903: LD_EXP 99
44907: NOT
44908: IFFALSE 44912
// exit ;
44910: GO 45054
// for i = 1 to mc_bases do
44912: LD_ADDR_VAR 0 2
44916: PUSH
44917: DOUBLE
44918: LD_INT 1
44920: DEC
44921: ST_TO_ADDR
44922: LD_EXP 99
44926: PUSH
44927: FOR_TO
44928: IFFALSE 45045
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
44930: LD_ADDR_VAR 0 3
44934: PUSH
44935: LD_EXP 99
44939: PUSH
44940: LD_VAR 0 2
44944: ARRAY
44945: PPUSH
44946: LD_INT 21
44948: PUSH
44949: LD_INT 3
44951: PUSH
44952: EMPTY
44953: LIST
44954: LIST
44955: PUSH
44956: LD_INT 3
44958: PUSH
44959: LD_INT 2
44961: PUSH
44962: LD_INT 30
44964: PUSH
44965: LD_INT 29
44967: PUSH
44968: EMPTY
44969: LIST
44970: LIST
44971: PUSH
44972: LD_INT 30
44974: PUSH
44975: LD_INT 30
44977: PUSH
44978: EMPTY
44979: LIST
44980: LIST
44981: PUSH
44982: EMPTY
44983: LIST
44984: LIST
44985: LIST
44986: PUSH
44987: EMPTY
44988: LIST
44989: LIST
44990: PUSH
44991: LD_INT 3
44993: PUSH
44994: LD_INT 24
44996: PUSH
44997: LD_INT 1000
44999: PUSH
45000: EMPTY
45001: LIST
45002: LIST
45003: PUSH
45004: EMPTY
45005: LIST
45006: LIST
45007: PUSH
45008: EMPTY
45009: LIST
45010: LIST
45011: LIST
45012: PPUSH
45013: CALL_OW 72
45017: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
45018: LD_ADDR_EXP 100
45022: PUSH
45023: LD_EXP 100
45027: PPUSH
45028: LD_VAR 0 2
45032: PPUSH
45033: LD_VAR 0 3
45037: PPUSH
45038: CALL_OW 1
45042: ST_TO_ADDR
// end ;
45043: GO 44927
45045: POP
45046: POP
// RaiseSailEvent ( 101 ) ;
45047: LD_INT 101
45049: PPUSH
45050: CALL_OW 427
// end ;
45054: LD_VAR 0 1
45058: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
45059: LD_INT 0
45061: PPUSH
45062: PPUSH
45063: PPUSH
45064: PPUSH
45065: PPUSH
45066: PPUSH
45067: PPUSH
// if not mc_bases then
45068: LD_EXP 99
45072: NOT
45073: IFFALSE 45077
// exit ;
45075: GO 45639
// for i = 1 to mc_bases do
45077: LD_ADDR_VAR 0 2
45081: PUSH
45082: DOUBLE
45083: LD_INT 1
45085: DEC
45086: ST_TO_ADDR
45087: LD_EXP 99
45091: PUSH
45092: FOR_TO
45093: IFFALSE 45630
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
45095: LD_ADDR_VAR 0 5
45099: PUSH
45100: LD_EXP 99
45104: PUSH
45105: LD_VAR 0 2
45109: ARRAY
45110: PUSH
45111: LD_EXP 128
45115: PUSH
45116: LD_VAR 0 2
45120: ARRAY
45121: UNION
45122: PPUSH
45123: LD_INT 21
45125: PUSH
45126: LD_INT 1
45128: PUSH
45129: EMPTY
45130: LIST
45131: LIST
45132: PUSH
45133: LD_INT 1
45135: PUSH
45136: LD_INT 3
45138: PUSH
45139: LD_INT 54
45141: PUSH
45142: EMPTY
45143: LIST
45144: PUSH
45145: EMPTY
45146: LIST
45147: LIST
45148: PUSH
45149: LD_INT 3
45151: PUSH
45152: LD_INT 24
45154: PUSH
45155: LD_INT 1000
45157: PUSH
45158: EMPTY
45159: LIST
45160: LIST
45161: PUSH
45162: EMPTY
45163: LIST
45164: LIST
45165: PUSH
45166: EMPTY
45167: LIST
45168: LIST
45169: LIST
45170: PUSH
45171: EMPTY
45172: LIST
45173: LIST
45174: PPUSH
45175: CALL_OW 72
45179: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
45180: LD_ADDR_VAR 0 6
45184: PUSH
45185: LD_EXP 99
45189: PUSH
45190: LD_VAR 0 2
45194: ARRAY
45195: PPUSH
45196: LD_INT 21
45198: PUSH
45199: LD_INT 1
45201: PUSH
45202: EMPTY
45203: LIST
45204: LIST
45205: PUSH
45206: LD_INT 1
45208: PUSH
45209: LD_INT 3
45211: PUSH
45212: LD_INT 54
45214: PUSH
45215: EMPTY
45216: LIST
45217: PUSH
45218: EMPTY
45219: LIST
45220: LIST
45221: PUSH
45222: LD_INT 3
45224: PUSH
45225: LD_INT 24
45227: PUSH
45228: LD_INT 250
45230: PUSH
45231: EMPTY
45232: LIST
45233: LIST
45234: PUSH
45235: EMPTY
45236: LIST
45237: LIST
45238: PUSH
45239: EMPTY
45240: LIST
45241: LIST
45242: LIST
45243: PUSH
45244: EMPTY
45245: LIST
45246: LIST
45247: PPUSH
45248: CALL_OW 72
45252: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
45253: LD_ADDR_VAR 0 7
45257: PUSH
45258: LD_VAR 0 5
45262: PUSH
45263: LD_VAR 0 6
45267: DIFF
45268: ST_TO_ADDR
// if not need_heal_1 then
45269: LD_VAR 0 6
45273: NOT
45274: IFFALSE 45307
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
45276: LD_ADDR_EXP 102
45280: PUSH
45281: LD_EXP 102
45285: PPUSH
45286: LD_VAR 0 2
45290: PUSH
45291: LD_INT 1
45293: PUSH
45294: EMPTY
45295: LIST
45296: LIST
45297: PPUSH
45298: EMPTY
45299: PPUSH
45300: CALL 72371 0 3
45304: ST_TO_ADDR
45305: GO 45377
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
45307: LD_ADDR_EXP 102
45311: PUSH
45312: LD_EXP 102
45316: PPUSH
45317: LD_VAR 0 2
45321: PUSH
45322: LD_INT 1
45324: PUSH
45325: EMPTY
45326: LIST
45327: LIST
45328: PPUSH
45329: LD_EXP 102
45333: PUSH
45334: LD_VAR 0 2
45338: ARRAY
45339: PUSH
45340: LD_INT 1
45342: ARRAY
45343: PPUSH
45344: LD_INT 3
45346: PUSH
45347: LD_INT 24
45349: PUSH
45350: LD_INT 1000
45352: PUSH
45353: EMPTY
45354: LIST
45355: LIST
45356: PUSH
45357: EMPTY
45358: LIST
45359: LIST
45360: PPUSH
45361: CALL_OW 72
45365: PUSH
45366: LD_VAR 0 6
45370: UNION
45371: PPUSH
45372: CALL 72371 0 3
45376: ST_TO_ADDR
// if not need_heal_2 then
45377: LD_VAR 0 7
45381: NOT
45382: IFFALSE 45415
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
45384: LD_ADDR_EXP 102
45388: PUSH
45389: LD_EXP 102
45393: PPUSH
45394: LD_VAR 0 2
45398: PUSH
45399: LD_INT 2
45401: PUSH
45402: EMPTY
45403: LIST
45404: LIST
45405: PPUSH
45406: EMPTY
45407: PPUSH
45408: CALL 72371 0 3
45412: ST_TO_ADDR
45413: GO 45447
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
45415: LD_ADDR_EXP 102
45419: PUSH
45420: LD_EXP 102
45424: PPUSH
45425: LD_VAR 0 2
45429: PUSH
45430: LD_INT 2
45432: PUSH
45433: EMPTY
45434: LIST
45435: LIST
45436: PPUSH
45437: LD_VAR 0 7
45441: PPUSH
45442: CALL 72371 0 3
45446: ST_TO_ADDR
// if need_heal_2 then
45447: LD_VAR 0 7
45451: IFFALSE 45612
// for j in need_heal_2 do
45453: LD_ADDR_VAR 0 3
45457: PUSH
45458: LD_VAR 0 7
45462: PUSH
45463: FOR_IN
45464: IFFALSE 45610
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45466: LD_ADDR_VAR 0 5
45470: PUSH
45471: LD_EXP 99
45475: PUSH
45476: LD_VAR 0 2
45480: ARRAY
45481: PPUSH
45482: LD_INT 2
45484: PUSH
45485: LD_INT 30
45487: PUSH
45488: LD_INT 6
45490: PUSH
45491: EMPTY
45492: LIST
45493: LIST
45494: PUSH
45495: LD_INT 30
45497: PUSH
45498: LD_INT 7
45500: PUSH
45501: EMPTY
45502: LIST
45503: LIST
45504: PUSH
45505: LD_INT 30
45507: PUSH
45508: LD_INT 8
45510: PUSH
45511: EMPTY
45512: LIST
45513: LIST
45514: PUSH
45515: LD_INT 30
45517: PUSH
45518: LD_INT 0
45520: PUSH
45521: EMPTY
45522: LIST
45523: LIST
45524: PUSH
45525: LD_INT 30
45527: PUSH
45528: LD_INT 1
45530: PUSH
45531: EMPTY
45532: LIST
45533: LIST
45534: PUSH
45535: EMPTY
45536: LIST
45537: LIST
45538: LIST
45539: LIST
45540: LIST
45541: LIST
45542: PPUSH
45543: CALL_OW 72
45547: ST_TO_ADDR
// if tmp then
45548: LD_VAR 0 5
45552: IFFALSE 45608
// begin k := NearestUnitToUnit ( tmp , j ) ;
45554: LD_ADDR_VAR 0 4
45558: PUSH
45559: LD_VAR 0 5
45563: PPUSH
45564: LD_VAR 0 3
45568: PPUSH
45569: CALL_OW 74
45573: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
45574: LD_VAR 0 3
45578: PPUSH
45579: LD_VAR 0 4
45583: PPUSH
45584: CALL_OW 296
45588: PUSH
45589: LD_INT 5
45591: GREATER
45592: IFFALSE 45608
// ComMoveToNearbyEntrance ( j , k ) ;
45594: LD_VAR 0 3
45598: PPUSH
45599: LD_VAR 0 4
45603: PPUSH
45604: CALL 105560 0 2
// end ; end ;
45608: GO 45463
45610: POP
45611: POP
// if not need_heal_1 and not need_heal_2 then
45612: LD_VAR 0 6
45616: NOT
45617: PUSH
45618: LD_VAR 0 7
45622: NOT
45623: AND
45624: IFFALSE 45628
// continue ;
45626: GO 45092
// end ;
45628: GO 45092
45630: POP
45631: POP
// RaiseSailEvent ( 102 ) ;
45632: LD_INT 102
45634: PPUSH
45635: CALL_OW 427
// end ;
45639: LD_VAR 0 1
45643: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
45644: LD_INT 0
45646: PPUSH
45647: PPUSH
45648: PPUSH
45649: PPUSH
45650: PPUSH
45651: PPUSH
45652: PPUSH
45653: PPUSH
// if not mc_bases then
45654: LD_EXP 99
45658: NOT
45659: IFFALSE 45663
// exit ;
45661: GO 46574
// for i = 1 to mc_bases do
45663: LD_ADDR_VAR 0 2
45667: PUSH
45668: DOUBLE
45669: LD_INT 1
45671: DEC
45672: ST_TO_ADDR
45673: LD_EXP 99
45677: PUSH
45678: FOR_TO
45679: IFFALSE 46572
// begin if not mc_building_need_repair [ i ] then
45681: LD_EXP 100
45685: PUSH
45686: LD_VAR 0 2
45690: ARRAY
45691: NOT
45692: IFFALSE 45877
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
45694: LD_ADDR_VAR 0 6
45698: PUSH
45699: LD_EXP 118
45703: PUSH
45704: LD_VAR 0 2
45708: ARRAY
45709: PPUSH
45710: LD_INT 3
45712: PUSH
45713: LD_INT 24
45715: PUSH
45716: LD_INT 1000
45718: PUSH
45719: EMPTY
45720: LIST
45721: LIST
45722: PUSH
45723: EMPTY
45724: LIST
45725: LIST
45726: PUSH
45727: LD_INT 2
45729: PUSH
45730: LD_INT 34
45732: PUSH
45733: LD_INT 13
45735: PUSH
45736: EMPTY
45737: LIST
45738: LIST
45739: PUSH
45740: LD_INT 34
45742: PUSH
45743: LD_INT 52
45745: PUSH
45746: EMPTY
45747: LIST
45748: LIST
45749: PUSH
45750: LD_INT 34
45752: PUSH
45753: LD_INT 88
45755: PUSH
45756: EMPTY
45757: LIST
45758: LIST
45759: PUSH
45760: EMPTY
45761: LIST
45762: LIST
45763: LIST
45764: LIST
45765: PUSH
45766: EMPTY
45767: LIST
45768: LIST
45769: PPUSH
45770: CALL_OW 72
45774: ST_TO_ADDR
// if cranes then
45775: LD_VAR 0 6
45779: IFFALSE 45841
// for j in cranes do
45781: LD_ADDR_VAR 0 3
45785: PUSH
45786: LD_VAR 0 6
45790: PUSH
45791: FOR_IN
45792: IFFALSE 45839
// if not IsInArea ( j , mc_parking [ i ] ) then
45794: LD_VAR 0 3
45798: PPUSH
45799: LD_EXP 123
45803: PUSH
45804: LD_VAR 0 2
45808: ARRAY
45809: PPUSH
45810: CALL_OW 308
45814: NOT
45815: IFFALSE 45837
// ComMoveToArea ( j , mc_parking [ i ] ) ;
45817: LD_VAR 0 3
45821: PPUSH
45822: LD_EXP 123
45826: PUSH
45827: LD_VAR 0 2
45831: ARRAY
45832: PPUSH
45833: CALL_OW 113
45837: GO 45791
45839: POP
45840: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
45841: LD_ADDR_EXP 101
45845: PUSH
45846: LD_EXP 101
45850: PPUSH
45851: LD_VAR 0 2
45855: PPUSH
45856: EMPTY
45857: PPUSH
45858: CALL_OW 1
45862: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
45863: LD_VAR 0 2
45867: PPUSH
45868: LD_INT 101
45870: PPUSH
45871: CALL 40731 0 2
// continue ;
45875: GO 45678
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
45877: LD_ADDR_EXP 105
45881: PUSH
45882: LD_EXP 105
45886: PPUSH
45887: LD_VAR 0 2
45891: PPUSH
45892: EMPTY
45893: PPUSH
45894: CALL_OW 1
45898: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45899: LD_VAR 0 2
45903: PPUSH
45904: LD_INT 103
45906: PPUSH
45907: CALL 40731 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
45911: LD_ADDR_VAR 0 5
45915: PUSH
45916: LD_EXP 99
45920: PUSH
45921: LD_VAR 0 2
45925: ARRAY
45926: PUSH
45927: LD_EXP 128
45931: PUSH
45932: LD_VAR 0 2
45936: ARRAY
45937: UNION
45938: PPUSH
45939: LD_INT 2
45941: PUSH
45942: LD_INT 25
45944: PUSH
45945: LD_INT 2
45947: PUSH
45948: EMPTY
45949: LIST
45950: LIST
45951: PUSH
45952: LD_INT 25
45954: PUSH
45955: LD_INT 16
45957: PUSH
45958: EMPTY
45959: LIST
45960: LIST
45961: PUSH
45962: EMPTY
45963: LIST
45964: LIST
45965: LIST
45966: PUSH
45967: EMPTY
45968: LIST
45969: PPUSH
45970: CALL_OW 72
45974: ST_TO_ADDR
// if mc_need_heal [ i ] then
45975: LD_EXP 102
45979: PUSH
45980: LD_VAR 0 2
45984: ARRAY
45985: IFFALSE 46029
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
45987: LD_ADDR_VAR 0 5
45991: PUSH
45992: LD_VAR 0 5
45996: PUSH
45997: LD_EXP 102
46001: PUSH
46002: LD_VAR 0 2
46006: ARRAY
46007: PUSH
46008: LD_INT 1
46010: ARRAY
46011: PUSH
46012: LD_EXP 102
46016: PUSH
46017: LD_VAR 0 2
46021: ARRAY
46022: PUSH
46023: LD_INT 2
46025: ARRAY
46026: UNION
46027: DIFF
46028: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
46029: LD_ADDR_VAR 0 6
46033: PUSH
46034: LD_EXP 118
46038: PUSH
46039: LD_VAR 0 2
46043: ARRAY
46044: PPUSH
46045: LD_INT 2
46047: PUSH
46048: LD_INT 34
46050: PUSH
46051: LD_INT 13
46053: PUSH
46054: EMPTY
46055: LIST
46056: LIST
46057: PUSH
46058: LD_INT 34
46060: PUSH
46061: LD_INT 52
46063: PUSH
46064: EMPTY
46065: LIST
46066: LIST
46067: PUSH
46068: LD_INT 34
46070: PUSH
46071: LD_INT 88
46073: PUSH
46074: EMPTY
46075: LIST
46076: LIST
46077: PUSH
46078: EMPTY
46079: LIST
46080: LIST
46081: LIST
46082: LIST
46083: PPUSH
46084: CALL_OW 72
46088: ST_TO_ADDR
// if cranes then
46089: LD_VAR 0 6
46093: IFFALSE 46261
// begin for j in cranes do
46095: LD_ADDR_VAR 0 3
46099: PUSH
46100: LD_VAR 0 6
46104: PUSH
46105: FOR_IN
46106: IFFALSE 46259
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
46108: LD_VAR 0 3
46112: PPUSH
46113: CALL_OW 256
46117: PUSH
46118: LD_INT 1000
46120: EQUAL
46121: PUSH
46122: LD_VAR 0 3
46126: PPUSH
46127: CALL_OW 314
46131: NOT
46132: AND
46133: IFFALSE 46199
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
46135: LD_ADDR_VAR 0 8
46139: PUSH
46140: LD_EXP 100
46144: PUSH
46145: LD_VAR 0 2
46149: ARRAY
46150: PPUSH
46151: LD_VAR 0 3
46155: PPUSH
46156: CALL_OW 74
46160: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
46161: LD_VAR 0 8
46165: PPUSH
46166: LD_INT 16
46168: PPUSH
46169: CALL 74968 0 2
46173: PUSH
46174: LD_INT 4
46176: ARRAY
46177: PUSH
46178: LD_INT 10
46180: LESS
46181: IFFALSE 46197
// ComRepairBuilding ( j , to_repair ) ;
46183: LD_VAR 0 3
46187: PPUSH
46188: LD_VAR 0 8
46192: PPUSH
46193: CALL_OW 130
// end else
46197: GO 46257
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
46199: LD_VAR 0 3
46203: PPUSH
46204: CALL_OW 256
46208: PUSH
46209: LD_INT 500
46211: LESS
46212: PUSH
46213: LD_VAR 0 3
46217: PPUSH
46218: LD_EXP 123
46222: PUSH
46223: LD_VAR 0 2
46227: ARRAY
46228: PPUSH
46229: CALL_OW 308
46233: NOT
46234: AND
46235: IFFALSE 46257
// ComMoveToArea ( j , mc_parking [ i ] ) ;
46237: LD_VAR 0 3
46241: PPUSH
46242: LD_EXP 123
46246: PUSH
46247: LD_VAR 0 2
46251: ARRAY
46252: PPUSH
46253: CALL_OW 113
// end ;
46257: GO 46105
46259: POP
46260: POP
// end ; if tmp > 3 then
46261: LD_VAR 0 5
46265: PUSH
46266: LD_INT 3
46268: GREATER
46269: IFFALSE 46289
// tmp := ShrinkArray ( tmp , 4 ) ;
46271: LD_ADDR_VAR 0 5
46275: PUSH
46276: LD_VAR 0 5
46280: PPUSH
46281: LD_INT 4
46283: PPUSH
46284: CALL 104998 0 2
46288: ST_TO_ADDR
// if not tmp then
46289: LD_VAR 0 5
46293: NOT
46294: IFFALSE 46298
// continue ;
46296: GO 45678
// for j in tmp do
46298: LD_ADDR_VAR 0 3
46302: PUSH
46303: LD_VAR 0 5
46307: PUSH
46308: FOR_IN
46309: IFFALSE 46568
// begin if IsInUnit ( j ) then
46311: LD_VAR 0 3
46315: PPUSH
46316: CALL_OW 310
46320: IFFALSE 46331
// ComExitBuilding ( j ) ;
46322: LD_VAR 0 3
46326: PPUSH
46327: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
46331: LD_VAR 0 3
46335: PUSH
46336: LD_EXP 101
46340: PUSH
46341: LD_VAR 0 2
46345: ARRAY
46346: IN
46347: NOT
46348: IFFALSE 46406
// begin SetTag ( j , 101 ) ;
46350: LD_VAR 0 3
46354: PPUSH
46355: LD_INT 101
46357: PPUSH
46358: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
46362: LD_ADDR_EXP 101
46366: PUSH
46367: LD_EXP 101
46371: PPUSH
46372: LD_VAR 0 2
46376: PUSH
46377: LD_EXP 101
46381: PUSH
46382: LD_VAR 0 2
46386: ARRAY
46387: PUSH
46388: LD_INT 1
46390: PLUS
46391: PUSH
46392: EMPTY
46393: LIST
46394: LIST
46395: PPUSH
46396: LD_VAR 0 3
46400: PPUSH
46401: CALL 72371 0 3
46405: ST_TO_ADDR
// end ; wait ( 1 ) ;
46406: LD_INT 1
46408: PPUSH
46409: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
46413: LD_ADDR_VAR 0 7
46417: PUSH
46418: LD_EXP 100
46422: PUSH
46423: LD_VAR 0 2
46427: ARRAY
46428: ST_TO_ADDR
// if mc_scan [ i ] then
46429: LD_EXP 122
46433: PUSH
46434: LD_VAR 0 2
46438: ARRAY
46439: IFFALSE 46501
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
46441: LD_ADDR_VAR 0 7
46445: PUSH
46446: LD_EXP 100
46450: PUSH
46451: LD_VAR 0 2
46455: ARRAY
46456: PPUSH
46457: LD_INT 3
46459: PUSH
46460: LD_INT 30
46462: PUSH
46463: LD_INT 32
46465: PUSH
46466: EMPTY
46467: LIST
46468: LIST
46469: PUSH
46470: LD_INT 30
46472: PUSH
46473: LD_INT 33
46475: PUSH
46476: EMPTY
46477: LIST
46478: LIST
46479: PUSH
46480: LD_INT 30
46482: PUSH
46483: LD_INT 31
46485: PUSH
46486: EMPTY
46487: LIST
46488: LIST
46489: PUSH
46490: EMPTY
46491: LIST
46492: LIST
46493: LIST
46494: LIST
46495: PPUSH
46496: CALL_OW 72
46500: ST_TO_ADDR
// if not to_repair_tmp then
46501: LD_VAR 0 7
46505: NOT
46506: IFFALSE 46510
// continue ;
46508: GO 46308
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
46510: LD_ADDR_VAR 0 8
46514: PUSH
46515: LD_VAR 0 7
46519: PPUSH
46520: LD_VAR 0 3
46524: PPUSH
46525: CALL_OW 74
46529: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
46530: LD_VAR 0 8
46534: PPUSH
46535: LD_INT 16
46537: PPUSH
46538: CALL 74968 0 2
46542: PUSH
46543: LD_INT 4
46545: ARRAY
46546: PUSH
46547: LD_INT 14
46549: LESS
46550: IFFALSE 46566
// ComRepairBuilding ( j , to_repair ) ;
46552: LD_VAR 0 3
46556: PPUSH
46557: LD_VAR 0 8
46561: PPUSH
46562: CALL_OW 130
// end ;
46566: GO 46308
46568: POP
46569: POP
// end ;
46570: GO 45678
46572: POP
46573: POP
// end ;
46574: LD_VAR 0 1
46578: RET
// export function MC_Heal ; var i , j , tmp ; begin
46579: LD_INT 0
46581: PPUSH
46582: PPUSH
46583: PPUSH
46584: PPUSH
// if not mc_bases then
46585: LD_EXP 99
46589: NOT
46590: IFFALSE 46594
// exit ;
46592: GO 46996
// for i = 1 to mc_bases do
46594: LD_ADDR_VAR 0 2
46598: PUSH
46599: DOUBLE
46600: LD_INT 1
46602: DEC
46603: ST_TO_ADDR
46604: LD_EXP 99
46608: PUSH
46609: FOR_TO
46610: IFFALSE 46994
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
46612: LD_EXP 102
46616: PUSH
46617: LD_VAR 0 2
46621: ARRAY
46622: PUSH
46623: LD_INT 1
46625: ARRAY
46626: NOT
46627: PUSH
46628: LD_EXP 102
46632: PUSH
46633: LD_VAR 0 2
46637: ARRAY
46638: PUSH
46639: LD_INT 2
46641: ARRAY
46642: NOT
46643: AND
46644: IFFALSE 46682
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
46646: LD_ADDR_EXP 103
46650: PUSH
46651: LD_EXP 103
46655: PPUSH
46656: LD_VAR 0 2
46660: PPUSH
46661: EMPTY
46662: PPUSH
46663: CALL_OW 1
46667: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
46668: LD_VAR 0 2
46672: PPUSH
46673: LD_INT 102
46675: PPUSH
46676: CALL 40731 0 2
// continue ;
46680: GO 46609
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
46682: LD_ADDR_VAR 0 4
46686: PUSH
46687: LD_EXP 99
46691: PUSH
46692: LD_VAR 0 2
46696: ARRAY
46697: PPUSH
46698: LD_INT 25
46700: PUSH
46701: LD_INT 4
46703: PUSH
46704: EMPTY
46705: LIST
46706: LIST
46707: PPUSH
46708: CALL_OW 72
46712: ST_TO_ADDR
// if not tmp then
46713: LD_VAR 0 4
46717: NOT
46718: IFFALSE 46722
// continue ;
46720: GO 46609
// if mc_taming [ i ] then
46722: LD_EXP 130
46726: PUSH
46727: LD_VAR 0 2
46731: ARRAY
46732: IFFALSE 46756
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
46734: LD_ADDR_EXP 130
46738: PUSH
46739: LD_EXP 130
46743: PPUSH
46744: LD_VAR 0 2
46748: PPUSH
46749: EMPTY
46750: PPUSH
46751: CALL_OW 1
46755: ST_TO_ADDR
// for j in tmp do
46756: LD_ADDR_VAR 0 3
46760: PUSH
46761: LD_VAR 0 4
46765: PUSH
46766: FOR_IN
46767: IFFALSE 46990
// begin if IsInUnit ( j ) then
46769: LD_VAR 0 3
46773: PPUSH
46774: CALL_OW 310
46778: IFFALSE 46789
// ComExitBuilding ( j ) ;
46780: LD_VAR 0 3
46784: PPUSH
46785: CALL_OW 122
// if not j in mc_healers [ i ] then
46789: LD_VAR 0 3
46793: PUSH
46794: LD_EXP 103
46798: PUSH
46799: LD_VAR 0 2
46803: ARRAY
46804: IN
46805: NOT
46806: IFFALSE 46852
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
46808: LD_ADDR_EXP 103
46812: PUSH
46813: LD_EXP 103
46817: PPUSH
46818: LD_VAR 0 2
46822: PUSH
46823: LD_EXP 103
46827: PUSH
46828: LD_VAR 0 2
46832: ARRAY
46833: PUSH
46834: LD_INT 1
46836: PLUS
46837: PUSH
46838: EMPTY
46839: LIST
46840: LIST
46841: PPUSH
46842: LD_VAR 0 3
46846: PPUSH
46847: CALL 72371 0 3
46851: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
46852: LD_VAR 0 3
46856: PPUSH
46857: CALL_OW 110
46861: PUSH
46862: LD_INT 102
46864: NONEQUAL
46865: IFFALSE 46879
// SetTag ( j , 102 ) ;
46867: LD_VAR 0 3
46871: PPUSH
46872: LD_INT 102
46874: PPUSH
46875: CALL_OW 109
// Wait ( 3 ) ;
46879: LD_INT 3
46881: PPUSH
46882: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
46886: LD_EXP 102
46890: PUSH
46891: LD_VAR 0 2
46895: ARRAY
46896: PUSH
46897: LD_INT 1
46899: ARRAY
46900: IFFALSE 46932
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
46902: LD_VAR 0 3
46906: PPUSH
46907: LD_EXP 102
46911: PUSH
46912: LD_VAR 0 2
46916: ARRAY
46917: PUSH
46918: LD_INT 1
46920: ARRAY
46921: PUSH
46922: LD_INT 1
46924: ARRAY
46925: PPUSH
46926: CALL_OW 128
46930: GO 46988
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
46932: LD_VAR 0 3
46936: PPUSH
46937: CALL_OW 314
46941: NOT
46942: PUSH
46943: LD_EXP 102
46947: PUSH
46948: LD_VAR 0 2
46952: ARRAY
46953: PUSH
46954: LD_INT 2
46956: ARRAY
46957: AND
46958: IFFALSE 46988
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
46960: LD_VAR 0 3
46964: PPUSH
46965: LD_EXP 102
46969: PUSH
46970: LD_VAR 0 2
46974: ARRAY
46975: PUSH
46976: LD_INT 2
46978: ARRAY
46979: PUSH
46980: LD_INT 1
46982: ARRAY
46983: PPUSH
46984: CALL_OW 128
// end ;
46988: GO 46766
46990: POP
46991: POP
// end ;
46992: GO 46609
46994: POP
46995: POP
// end ;
46996: LD_VAR 0 1
47000: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
47001: LD_INT 0
47003: PPUSH
47004: PPUSH
47005: PPUSH
47006: PPUSH
47007: PPUSH
47008: PPUSH
// if not mc_bases then
47009: LD_EXP 99
47013: NOT
47014: IFFALSE 47018
// exit ;
47016: GO 48181
// for i = 1 to mc_bases do
47018: LD_ADDR_VAR 0 2
47022: PUSH
47023: DOUBLE
47024: LD_INT 1
47026: DEC
47027: ST_TO_ADDR
47028: LD_EXP 99
47032: PUSH
47033: FOR_TO
47034: IFFALSE 48179
// begin if mc_scan [ i ] then
47036: LD_EXP 122
47040: PUSH
47041: LD_VAR 0 2
47045: ARRAY
47046: IFFALSE 47050
// continue ;
47048: GO 47033
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
47050: LD_EXP 104
47054: PUSH
47055: LD_VAR 0 2
47059: ARRAY
47060: NOT
47061: PUSH
47062: LD_EXP 106
47066: PUSH
47067: LD_VAR 0 2
47071: ARRAY
47072: NOT
47073: AND
47074: PUSH
47075: LD_EXP 105
47079: PUSH
47080: LD_VAR 0 2
47084: ARRAY
47085: AND
47086: IFFALSE 47124
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
47088: LD_ADDR_EXP 105
47092: PUSH
47093: LD_EXP 105
47097: PPUSH
47098: LD_VAR 0 2
47102: PPUSH
47103: EMPTY
47104: PPUSH
47105: CALL_OW 1
47109: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
47110: LD_VAR 0 2
47114: PPUSH
47115: LD_INT 103
47117: PPUSH
47118: CALL 40731 0 2
// continue ;
47122: GO 47033
// end ; if mc_construct_list [ i ] then
47124: LD_EXP 106
47128: PUSH
47129: LD_VAR 0 2
47133: ARRAY
47134: IFFALSE 47354
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
47136: LD_ADDR_VAR 0 5
47140: PUSH
47141: LD_EXP 99
47145: PUSH
47146: LD_VAR 0 2
47150: ARRAY
47151: PPUSH
47152: LD_INT 25
47154: PUSH
47155: LD_INT 2
47157: PUSH
47158: EMPTY
47159: LIST
47160: LIST
47161: PPUSH
47162: CALL_OW 72
47166: PUSH
47167: LD_EXP 101
47171: PUSH
47172: LD_VAR 0 2
47176: ARRAY
47177: DIFF
47178: ST_TO_ADDR
// if not tmp then
47179: LD_VAR 0 5
47183: NOT
47184: IFFALSE 47188
// continue ;
47186: GO 47033
// for j in tmp do
47188: LD_ADDR_VAR 0 3
47192: PUSH
47193: LD_VAR 0 5
47197: PUSH
47198: FOR_IN
47199: IFFALSE 47350
// begin if not mc_builders [ i ] then
47201: LD_EXP 105
47205: PUSH
47206: LD_VAR 0 2
47210: ARRAY
47211: NOT
47212: IFFALSE 47270
// begin SetTag ( j , 103 ) ;
47214: LD_VAR 0 3
47218: PPUSH
47219: LD_INT 103
47221: PPUSH
47222: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
47226: LD_ADDR_EXP 105
47230: PUSH
47231: LD_EXP 105
47235: PPUSH
47236: LD_VAR 0 2
47240: PUSH
47241: LD_EXP 105
47245: PUSH
47246: LD_VAR 0 2
47250: ARRAY
47251: PUSH
47252: LD_INT 1
47254: PLUS
47255: PUSH
47256: EMPTY
47257: LIST
47258: LIST
47259: PPUSH
47260: LD_VAR 0 3
47264: PPUSH
47265: CALL 72371 0 3
47269: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
47270: LD_VAR 0 3
47274: PPUSH
47275: CALL_OW 310
47279: IFFALSE 47290
// ComExitBuilding ( j ) ;
47281: LD_VAR 0 3
47285: PPUSH
47286: CALL_OW 122
// wait ( 3 ) ;
47290: LD_INT 3
47292: PPUSH
47293: CALL_OW 67
// if not mc_construct_list [ i ] then
47297: LD_EXP 106
47301: PUSH
47302: LD_VAR 0 2
47306: ARRAY
47307: NOT
47308: IFFALSE 47312
// break ;
47310: GO 47350
// if not HasTask ( j ) then
47312: LD_VAR 0 3
47316: PPUSH
47317: CALL_OW 314
47321: NOT
47322: IFFALSE 47348
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
47324: LD_VAR 0 3
47328: PPUSH
47329: LD_EXP 106
47333: PUSH
47334: LD_VAR 0 2
47338: ARRAY
47339: PUSH
47340: LD_INT 1
47342: ARRAY
47343: PPUSH
47344: CALL 75232 0 2
// end ;
47348: GO 47198
47350: POP
47351: POP
// end else
47352: GO 48177
// if mc_build_list [ i ] then
47354: LD_EXP 104
47358: PUSH
47359: LD_VAR 0 2
47363: ARRAY
47364: IFFALSE 48177
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
47366: LD_EXP 104
47370: PUSH
47371: LD_VAR 0 2
47375: ARRAY
47376: PUSH
47377: LD_INT 1
47379: ARRAY
47380: PUSH
47381: LD_INT 1
47383: ARRAY
47384: PPUSH
47385: CALL 75056 0 1
47389: PUSH
47390: LD_EXP 99
47394: PUSH
47395: LD_VAR 0 2
47399: ARRAY
47400: PPUSH
47401: LD_INT 2
47403: PUSH
47404: LD_INT 30
47406: PUSH
47407: LD_INT 2
47409: PUSH
47410: EMPTY
47411: LIST
47412: LIST
47413: PUSH
47414: LD_INT 30
47416: PUSH
47417: LD_INT 3
47419: PUSH
47420: EMPTY
47421: LIST
47422: LIST
47423: PUSH
47424: EMPTY
47425: LIST
47426: LIST
47427: LIST
47428: PPUSH
47429: CALL_OW 72
47433: NOT
47434: AND
47435: IFFALSE 47540
// begin for j = 1 to mc_build_list [ i ] do
47437: LD_ADDR_VAR 0 3
47441: PUSH
47442: DOUBLE
47443: LD_INT 1
47445: DEC
47446: ST_TO_ADDR
47447: LD_EXP 104
47451: PUSH
47452: LD_VAR 0 2
47456: ARRAY
47457: PUSH
47458: FOR_TO
47459: IFFALSE 47538
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
47461: LD_EXP 104
47465: PUSH
47466: LD_VAR 0 2
47470: ARRAY
47471: PUSH
47472: LD_VAR 0 3
47476: ARRAY
47477: PUSH
47478: LD_INT 1
47480: ARRAY
47481: PUSH
47482: LD_INT 2
47484: EQUAL
47485: IFFALSE 47536
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
47487: LD_ADDR_EXP 104
47491: PUSH
47492: LD_EXP 104
47496: PPUSH
47497: LD_VAR 0 2
47501: PPUSH
47502: LD_EXP 104
47506: PUSH
47507: LD_VAR 0 2
47511: ARRAY
47512: PPUSH
47513: LD_VAR 0 3
47517: PPUSH
47518: LD_INT 1
47520: PPUSH
47521: LD_INT 0
47523: PPUSH
47524: CALL 71789 0 4
47528: PPUSH
47529: CALL_OW 1
47533: ST_TO_ADDR
// break ;
47534: GO 47538
// end ;
47536: GO 47458
47538: POP
47539: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47540: LD_ADDR_VAR 0 6
47544: PUSH
47545: LD_EXP 99
47549: PUSH
47550: LD_VAR 0 2
47554: ARRAY
47555: PPUSH
47556: LD_INT 2
47558: PUSH
47559: LD_INT 30
47561: PUSH
47562: LD_INT 0
47564: PUSH
47565: EMPTY
47566: LIST
47567: LIST
47568: PUSH
47569: LD_INT 30
47571: PUSH
47572: LD_INT 1
47574: PUSH
47575: EMPTY
47576: LIST
47577: LIST
47578: PUSH
47579: EMPTY
47580: LIST
47581: LIST
47582: LIST
47583: PPUSH
47584: CALL_OW 72
47588: ST_TO_ADDR
// for k := 1 to depot do
47589: LD_ADDR_VAR 0 4
47593: PUSH
47594: DOUBLE
47595: LD_INT 1
47597: DEC
47598: ST_TO_ADDR
47599: LD_VAR 0 6
47603: PUSH
47604: FOR_TO
47605: IFFALSE 48175
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
47607: LD_EXP 104
47611: PUSH
47612: LD_VAR 0 2
47616: ARRAY
47617: PUSH
47618: LD_INT 1
47620: ARRAY
47621: PUSH
47622: LD_INT 1
47624: ARRAY
47625: PUSH
47626: LD_INT 0
47628: EQUAL
47629: PUSH
47630: LD_VAR 0 6
47634: PUSH
47635: LD_VAR 0 4
47639: ARRAY
47640: PPUSH
47641: LD_EXP 104
47645: PUSH
47646: LD_VAR 0 2
47650: ARRAY
47651: PUSH
47652: LD_INT 1
47654: ARRAY
47655: PUSH
47656: LD_INT 1
47658: ARRAY
47659: PPUSH
47660: LD_EXP 104
47664: PUSH
47665: LD_VAR 0 2
47669: ARRAY
47670: PUSH
47671: LD_INT 1
47673: ARRAY
47674: PUSH
47675: LD_INT 2
47677: ARRAY
47678: PPUSH
47679: LD_EXP 104
47683: PUSH
47684: LD_VAR 0 2
47688: ARRAY
47689: PUSH
47690: LD_INT 1
47692: ARRAY
47693: PUSH
47694: LD_INT 3
47696: ARRAY
47697: PPUSH
47698: LD_EXP 104
47702: PUSH
47703: LD_VAR 0 2
47707: ARRAY
47708: PUSH
47709: LD_INT 1
47711: ARRAY
47712: PUSH
47713: LD_INT 4
47715: ARRAY
47716: PPUSH
47717: CALL 80468 0 5
47721: OR
47722: IFFALSE 48003
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
47724: LD_ADDR_VAR 0 5
47728: PUSH
47729: LD_EXP 99
47733: PUSH
47734: LD_VAR 0 2
47738: ARRAY
47739: PPUSH
47740: LD_INT 25
47742: PUSH
47743: LD_INT 2
47745: PUSH
47746: EMPTY
47747: LIST
47748: LIST
47749: PPUSH
47750: CALL_OW 72
47754: PUSH
47755: LD_EXP 101
47759: PUSH
47760: LD_VAR 0 2
47764: ARRAY
47765: DIFF
47766: ST_TO_ADDR
// if not tmp then
47767: LD_VAR 0 5
47771: NOT
47772: IFFALSE 47776
// continue ;
47774: GO 47604
// for j in tmp do
47776: LD_ADDR_VAR 0 3
47780: PUSH
47781: LD_VAR 0 5
47785: PUSH
47786: FOR_IN
47787: IFFALSE 47999
// begin if not mc_builders [ i ] then
47789: LD_EXP 105
47793: PUSH
47794: LD_VAR 0 2
47798: ARRAY
47799: NOT
47800: IFFALSE 47858
// begin SetTag ( j , 103 ) ;
47802: LD_VAR 0 3
47806: PPUSH
47807: LD_INT 103
47809: PPUSH
47810: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
47814: LD_ADDR_EXP 105
47818: PUSH
47819: LD_EXP 105
47823: PPUSH
47824: LD_VAR 0 2
47828: PUSH
47829: LD_EXP 105
47833: PUSH
47834: LD_VAR 0 2
47838: ARRAY
47839: PUSH
47840: LD_INT 1
47842: PLUS
47843: PUSH
47844: EMPTY
47845: LIST
47846: LIST
47847: PPUSH
47848: LD_VAR 0 3
47852: PPUSH
47853: CALL 72371 0 3
47857: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
47858: LD_VAR 0 3
47862: PPUSH
47863: CALL_OW 310
47867: IFFALSE 47878
// ComExitBuilding ( j ) ;
47869: LD_VAR 0 3
47873: PPUSH
47874: CALL_OW 122
// wait ( 3 ) ;
47878: LD_INT 3
47880: PPUSH
47881: CALL_OW 67
// if not mc_build_list [ i ] then
47885: LD_EXP 104
47889: PUSH
47890: LD_VAR 0 2
47894: ARRAY
47895: NOT
47896: IFFALSE 47900
// break ;
47898: GO 47999
// if not HasTask ( j ) then
47900: LD_VAR 0 3
47904: PPUSH
47905: CALL_OW 314
47909: NOT
47910: IFFALSE 47997
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
47912: LD_VAR 0 3
47916: PPUSH
47917: LD_EXP 104
47921: PUSH
47922: LD_VAR 0 2
47926: ARRAY
47927: PUSH
47928: LD_INT 1
47930: ARRAY
47931: PUSH
47932: LD_INT 1
47934: ARRAY
47935: PPUSH
47936: LD_EXP 104
47940: PUSH
47941: LD_VAR 0 2
47945: ARRAY
47946: PUSH
47947: LD_INT 1
47949: ARRAY
47950: PUSH
47951: LD_INT 2
47953: ARRAY
47954: PPUSH
47955: LD_EXP 104
47959: PUSH
47960: LD_VAR 0 2
47964: ARRAY
47965: PUSH
47966: LD_INT 1
47968: ARRAY
47969: PUSH
47970: LD_INT 3
47972: ARRAY
47973: PPUSH
47974: LD_EXP 104
47978: PUSH
47979: LD_VAR 0 2
47983: ARRAY
47984: PUSH
47985: LD_INT 1
47987: ARRAY
47988: PUSH
47989: LD_INT 4
47991: ARRAY
47992: PPUSH
47993: CALL_OW 145
// end ;
47997: GO 47786
47999: POP
48000: POP
// end else
48001: GO 48173
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
48003: LD_EXP 99
48007: PUSH
48008: LD_VAR 0 2
48012: ARRAY
48013: PPUSH
48014: LD_EXP 104
48018: PUSH
48019: LD_VAR 0 2
48023: ARRAY
48024: PUSH
48025: LD_INT 1
48027: ARRAY
48028: PUSH
48029: LD_INT 1
48031: ARRAY
48032: PPUSH
48033: LD_EXP 104
48037: PUSH
48038: LD_VAR 0 2
48042: ARRAY
48043: PUSH
48044: LD_INT 1
48046: ARRAY
48047: PUSH
48048: LD_INT 2
48050: ARRAY
48051: PPUSH
48052: LD_EXP 104
48056: PUSH
48057: LD_VAR 0 2
48061: ARRAY
48062: PUSH
48063: LD_INT 1
48065: ARRAY
48066: PUSH
48067: LD_INT 3
48069: ARRAY
48070: PPUSH
48071: LD_EXP 104
48075: PUSH
48076: LD_VAR 0 2
48080: ARRAY
48081: PUSH
48082: LD_INT 1
48084: ARRAY
48085: PUSH
48086: LD_INT 4
48088: ARRAY
48089: PPUSH
48090: LD_EXP 99
48094: PUSH
48095: LD_VAR 0 2
48099: ARRAY
48100: PPUSH
48101: LD_INT 21
48103: PUSH
48104: LD_INT 3
48106: PUSH
48107: EMPTY
48108: LIST
48109: LIST
48110: PPUSH
48111: CALL_OW 72
48115: PPUSH
48116: EMPTY
48117: PPUSH
48118: CALL 79222 0 7
48122: NOT
48123: IFFALSE 48173
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
48125: LD_ADDR_EXP 104
48129: PUSH
48130: LD_EXP 104
48134: PPUSH
48135: LD_VAR 0 2
48139: PPUSH
48140: LD_EXP 104
48144: PUSH
48145: LD_VAR 0 2
48149: ARRAY
48150: PPUSH
48151: LD_INT 1
48153: PPUSH
48154: LD_INT 1
48156: NEG
48157: PPUSH
48158: LD_INT 0
48160: PPUSH
48161: CALL 71789 0 4
48165: PPUSH
48166: CALL_OW 1
48170: ST_TO_ADDR
// continue ;
48171: GO 47604
// end ; end ;
48173: GO 47604
48175: POP
48176: POP
// end ; end ;
48177: GO 47033
48179: POP
48180: POP
// end ;
48181: LD_VAR 0 1
48185: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
48186: LD_INT 0
48188: PPUSH
48189: PPUSH
48190: PPUSH
48191: PPUSH
48192: PPUSH
48193: PPUSH
// if not mc_bases then
48194: LD_EXP 99
48198: NOT
48199: IFFALSE 48203
// exit ;
48201: GO 48630
// for i = 1 to mc_bases do
48203: LD_ADDR_VAR 0 2
48207: PUSH
48208: DOUBLE
48209: LD_INT 1
48211: DEC
48212: ST_TO_ADDR
48213: LD_EXP 99
48217: PUSH
48218: FOR_TO
48219: IFFALSE 48628
// begin tmp := mc_build_upgrade [ i ] ;
48221: LD_ADDR_VAR 0 4
48225: PUSH
48226: LD_EXP 131
48230: PUSH
48231: LD_VAR 0 2
48235: ARRAY
48236: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
48237: LD_ADDR_VAR 0 6
48241: PUSH
48242: LD_EXP 132
48246: PUSH
48247: LD_VAR 0 2
48251: ARRAY
48252: PPUSH
48253: LD_INT 2
48255: PUSH
48256: LD_INT 30
48258: PUSH
48259: LD_INT 6
48261: PUSH
48262: EMPTY
48263: LIST
48264: LIST
48265: PUSH
48266: LD_INT 30
48268: PUSH
48269: LD_INT 7
48271: PUSH
48272: EMPTY
48273: LIST
48274: LIST
48275: PUSH
48276: EMPTY
48277: LIST
48278: LIST
48279: LIST
48280: PPUSH
48281: CALL_OW 72
48285: ST_TO_ADDR
// if not tmp and not lab then
48286: LD_VAR 0 4
48290: NOT
48291: PUSH
48292: LD_VAR 0 6
48296: NOT
48297: AND
48298: IFFALSE 48302
// continue ;
48300: GO 48218
// if tmp then
48302: LD_VAR 0 4
48306: IFFALSE 48426
// for j in tmp do
48308: LD_ADDR_VAR 0 3
48312: PUSH
48313: LD_VAR 0 4
48317: PUSH
48318: FOR_IN
48319: IFFALSE 48424
// begin if UpgradeCost ( j ) then
48321: LD_VAR 0 3
48325: PPUSH
48326: CALL 78882 0 1
48330: IFFALSE 48422
// begin ComUpgrade ( j ) ;
48332: LD_VAR 0 3
48336: PPUSH
48337: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
48341: LD_ADDR_EXP 131
48345: PUSH
48346: LD_EXP 131
48350: PPUSH
48351: LD_VAR 0 2
48355: PPUSH
48356: LD_EXP 131
48360: PUSH
48361: LD_VAR 0 2
48365: ARRAY
48366: PUSH
48367: LD_VAR 0 3
48371: DIFF
48372: PPUSH
48373: CALL_OW 1
48377: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
48378: LD_ADDR_EXP 106
48382: PUSH
48383: LD_EXP 106
48387: PPUSH
48388: LD_VAR 0 2
48392: PUSH
48393: LD_EXP 106
48397: PUSH
48398: LD_VAR 0 2
48402: ARRAY
48403: PUSH
48404: LD_INT 1
48406: PLUS
48407: PUSH
48408: EMPTY
48409: LIST
48410: LIST
48411: PPUSH
48412: LD_VAR 0 3
48416: PPUSH
48417: CALL 72371 0 3
48421: ST_TO_ADDR
// end ; end ;
48422: GO 48318
48424: POP
48425: POP
// if not lab or not mc_lab_upgrade [ i ] then
48426: LD_VAR 0 6
48430: NOT
48431: PUSH
48432: LD_EXP 133
48436: PUSH
48437: LD_VAR 0 2
48441: ARRAY
48442: NOT
48443: OR
48444: IFFALSE 48448
// continue ;
48446: GO 48218
// for j in lab do
48448: LD_ADDR_VAR 0 3
48452: PUSH
48453: LD_VAR 0 6
48457: PUSH
48458: FOR_IN
48459: IFFALSE 48624
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
48461: LD_VAR 0 3
48465: PPUSH
48466: CALL_OW 266
48470: PUSH
48471: LD_INT 6
48473: PUSH
48474: LD_INT 7
48476: PUSH
48477: EMPTY
48478: LIST
48479: LIST
48480: IN
48481: PUSH
48482: LD_VAR 0 3
48486: PPUSH
48487: CALL_OW 461
48491: PUSH
48492: LD_INT 1
48494: NONEQUAL
48495: AND
48496: IFFALSE 48622
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
48498: LD_VAR 0 3
48502: PPUSH
48503: LD_EXP 133
48507: PUSH
48508: LD_VAR 0 2
48512: ARRAY
48513: PUSH
48514: LD_INT 1
48516: ARRAY
48517: PPUSH
48518: CALL 79087 0 2
48522: IFFALSE 48622
// begin ComCancel ( j ) ;
48524: LD_VAR 0 3
48528: PPUSH
48529: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
48533: LD_VAR 0 3
48537: PPUSH
48538: LD_EXP 133
48542: PUSH
48543: LD_VAR 0 2
48547: ARRAY
48548: PUSH
48549: LD_INT 1
48551: ARRAY
48552: PPUSH
48553: CALL_OW 207
// if not j in mc_construct_list [ i ] then
48557: LD_VAR 0 3
48561: PUSH
48562: LD_EXP 106
48566: PUSH
48567: LD_VAR 0 2
48571: ARRAY
48572: IN
48573: NOT
48574: IFFALSE 48620
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
48576: LD_ADDR_EXP 106
48580: PUSH
48581: LD_EXP 106
48585: PPUSH
48586: LD_VAR 0 2
48590: PUSH
48591: LD_EXP 106
48595: PUSH
48596: LD_VAR 0 2
48600: ARRAY
48601: PUSH
48602: LD_INT 1
48604: PLUS
48605: PUSH
48606: EMPTY
48607: LIST
48608: LIST
48609: PPUSH
48610: LD_VAR 0 3
48614: PPUSH
48615: CALL 72371 0 3
48619: ST_TO_ADDR
// break ;
48620: GO 48624
// end ; end ; end ;
48622: GO 48458
48624: POP
48625: POP
// end ;
48626: GO 48218
48628: POP
48629: POP
// end ;
48630: LD_VAR 0 1
48634: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
48635: LD_INT 0
48637: PPUSH
48638: PPUSH
48639: PPUSH
48640: PPUSH
48641: PPUSH
48642: PPUSH
48643: PPUSH
48644: PPUSH
48645: PPUSH
// if not mc_bases then
48646: LD_EXP 99
48650: NOT
48651: IFFALSE 48655
// exit ;
48653: GO 49060
// for i = 1 to mc_bases do
48655: LD_ADDR_VAR 0 2
48659: PUSH
48660: DOUBLE
48661: LD_INT 1
48663: DEC
48664: ST_TO_ADDR
48665: LD_EXP 99
48669: PUSH
48670: FOR_TO
48671: IFFALSE 49058
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
48673: LD_EXP 107
48677: PUSH
48678: LD_VAR 0 2
48682: ARRAY
48683: NOT
48684: PUSH
48685: LD_EXP 99
48689: PUSH
48690: LD_VAR 0 2
48694: ARRAY
48695: PPUSH
48696: LD_INT 30
48698: PUSH
48699: LD_INT 3
48701: PUSH
48702: EMPTY
48703: LIST
48704: LIST
48705: PPUSH
48706: CALL_OW 72
48710: NOT
48711: OR
48712: IFFALSE 48716
// continue ;
48714: GO 48670
// busy := false ;
48716: LD_ADDR_VAR 0 8
48720: PUSH
48721: LD_INT 0
48723: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
48724: LD_ADDR_VAR 0 4
48728: PUSH
48729: LD_EXP 99
48733: PUSH
48734: LD_VAR 0 2
48738: ARRAY
48739: PPUSH
48740: LD_INT 30
48742: PUSH
48743: LD_INT 3
48745: PUSH
48746: EMPTY
48747: LIST
48748: LIST
48749: PPUSH
48750: CALL_OW 72
48754: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
48755: LD_ADDR_VAR 0 6
48759: PUSH
48760: LD_EXP 107
48764: PUSH
48765: LD_VAR 0 2
48769: ARRAY
48770: PPUSH
48771: LD_INT 2
48773: PUSH
48774: LD_INT 30
48776: PUSH
48777: LD_INT 32
48779: PUSH
48780: EMPTY
48781: LIST
48782: LIST
48783: PUSH
48784: LD_INT 30
48786: PUSH
48787: LD_INT 33
48789: PUSH
48790: EMPTY
48791: LIST
48792: LIST
48793: PUSH
48794: EMPTY
48795: LIST
48796: LIST
48797: LIST
48798: PPUSH
48799: CALL_OW 72
48803: ST_TO_ADDR
// if not t then
48804: LD_VAR 0 6
48808: NOT
48809: IFFALSE 48813
// continue ;
48811: GO 48670
// for j in tmp do
48813: LD_ADDR_VAR 0 3
48817: PUSH
48818: LD_VAR 0 4
48822: PUSH
48823: FOR_IN
48824: IFFALSE 48854
// if not BuildingStatus ( j ) = bs_idle then
48826: LD_VAR 0 3
48830: PPUSH
48831: CALL_OW 461
48835: PUSH
48836: LD_INT 2
48838: EQUAL
48839: NOT
48840: IFFALSE 48852
// begin busy := true ;
48842: LD_ADDR_VAR 0 8
48846: PUSH
48847: LD_INT 1
48849: ST_TO_ADDR
// break ;
48850: GO 48854
// end ;
48852: GO 48823
48854: POP
48855: POP
// if busy then
48856: LD_VAR 0 8
48860: IFFALSE 48864
// continue ;
48862: GO 48670
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
48864: LD_ADDR_VAR 0 7
48868: PUSH
48869: LD_VAR 0 6
48873: PPUSH
48874: LD_INT 35
48876: PUSH
48877: LD_INT 0
48879: PUSH
48880: EMPTY
48881: LIST
48882: LIST
48883: PPUSH
48884: CALL_OW 72
48888: ST_TO_ADDR
// if tw then
48889: LD_VAR 0 7
48893: IFFALSE 48970
// begin tw := tw [ 1 ] ;
48895: LD_ADDR_VAR 0 7
48899: PUSH
48900: LD_VAR 0 7
48904: PUSH
48905: LD_INT 1
48907: ARRAY
48908: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
48909: LD_ADDR_VAR 0 9
48913: PUSH
48914: LD_VAR 0 7
48918: PPUSH
48919: LD_EXP 124
48923: PUSH
48924: LD_VAR 0 2
48928: ARRAY
48929: PPUSH
48930: CALL 77379 0 2
48934: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
48935: LD_EXP 138
48939: PUSH
48940: LD_VAR 0 2
48944: ARRAY
48945: IFFALSE 48968
// if not weapon in mc_allowed_tower_weapons [ i ] then
48947: LD_VAR 0 9
48951: PUSH
48952: LD_EXP 138
48956: PUSH
48957: LD_VAR 0 2
48961: ARRAY
48962: IN
48963: NOT
48964: IFFALSE 48968
// continue ;
48966: GO 48670
// end else
48968: GO 49033
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
48970: LD_ADDR_VAR 0 5
48974: PUSH
48975: LD_EXP 107
48979: PUSH
48980: LD_VAR 0 2
48984: ARRAY
48985: PPUSH
48986: LD_VAR 0 4
48990: PPUSH
48991: CALL 104231 0 2
48995: ST_TO_ADDR
// if not tmp2 then
48996: LD_VAR 0 5
49000: NOT
49001: IFFALSE 49005
// continue ;
49003: GO 48670
// tw := tmp2 [ 1 ] ;
49005: LD_ADDR_VAR 0 7
49009: PUSH
49010: LD_VAR 0 5
49014: PUSH
49015: LD_INT 1
49017: ARRAY
49018: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
49019: LD_ADDR_VAR 0 9
49023: PUSH
49024: LD_VAR 0 5
49028: PUSH
49029: LD_INT 2
49031: ARRAY
49032: ST_TO_ADDR
// end ; if not weapon then
49033: LD_VAR 0 9
49037: NOT
49038: IFFALSE 49042
// continue ;
49040: GO 48670
// ComPlaceWeapon ( tw , weapon ) ;
49042: LD_VAR 0 7
49046: PPUSH
49047: LD_VAR 0 9
49051: PPUSH
49052: CALL_OW 148
// end ;
49056: GO 48670
49058: POP
49059: POP
// end ;
49060: LD_VAR 0 1
49064: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
49065: LD_INT 0
49067: PPUSH
49068: PPUSH
49069: PPUSH
49070: PPUSH
49071: PPUSH
49072: PPUSH
49073: PPUSH
// if not mc_bases then
49074: LD_EXP 99
49078: NOT
49079: IFFALSE 49083
// exit ;
49081: GO 49851
// for i = 1 to mc_bases do
49083: LD_ADDR_VAR 0 2
49087: PUSH
49088: DOUBLE
49089: LD_INT 1
49091: DEC
49092: ST_TO_ADDR
49093: LD_EXP 99
49097: PUSH
49098: FOR_TO
49099: IFFALSE 49849
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
49101: LD_EXP 112
49105: PUSH
49106: LD_VAR 0 2
49110: ARRAY
49111: NOT
49112: PUSH
49113: LD_EXP 112
49117: PUSH
49118: LD_VAR 0 2
49122: ARRAY
49123: PUSH
49124: LD_EXP 113
49128: PUSH
49129: LD_VAR 0 2
49133: ARRAY
49134: EQUAL
49135: OR
49136: PUSH
49137: LD_EXP 122
49141: PUSH
49142: LD_VAR 0 2
49146: ARRAY
49147: OR
49148: IFFALSE 49152
// continue ;
49150: GO 49098
// if mc_miners [ i ] then
49152: LD_EXP 113
49156: PUSH
49157: LD_VAR 0 2
49161: ARRAY
49162: IFFALSE 49536
// begin for j = mc_miners [ i ] downto 1 do
49164: LD_ADDR_VAR 0 3
49168: PUSH
49169: DOUBLE
49170: LD_EXP 113
49174: PUSH
49175: LD_VAR 0 2
49179: ARRAY
49180: INC
49181: ST_TO_ADDR
49182: LD_INT 1
49184: PUSH
49185: FOR_DOWNTO
49186: IFFALSE 49534
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
49188: LD_EXP 113
49192: PUSH
49193: LD_VAR 0 2
49197: ARRAY
49198: PUSH
49199: LD_VAR 0 3
49203: ARRAY
49204: PPUSH
49205: CALL_OW 301
49209: PUSH
49210: LD_EXP 113
49214: PUSH
49215: LD_VAR 0 2
49219: ARRAY
49220: PUSH
49221: LD_VAR 0 3
49225: ARRAY
49226: PPUSH
49227: CALL_OW 257
49231: PUSH
49232: LD_INT 1
49234: NONEQUAL
49235: OR
49236: IFFALSE 49299
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
49238: LD_ADDR_VAR 0 5
49242: PUSH
49243: LD_EXP 113
49247: PUSH
49248: LD_VAR 0 2
49252: ARRAY
49253: PUSH
49254: LD_EXP 113
49258: PUSH
49259: LD_VAR 0 2
49263: ARRAY
49264: PUSH
49265: LD_VAR 0 3
49269: ARRAY
49270: DIFF
49271: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
49272: LD_ADDR_EXP 113
49276: PUSH
49277: LD_EXP 113
49281: PPUSH
49282: LD_VAR 0 2
49286: PPUSH
49287: LD_VAR 0 5
49291: PPUSH
49292: CALL_OW 1
49296: ST_TO_ADDR
// continue ;
49297: GO 49185
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
49299: LD_EXP 113
49303: PUSH
49304: LD_VAR 0 2
49308: ARRAY
49309: PUSH
49310: LD_VAR 0 3
49314: ARRAY
49315: PPUSH
49316: CALL_OW 257
49320: PUSH
49321: LD_INT 1
49323: EQUAL
49324: PUSH
49325: LD_EXP 113
49329: PUSH
49330: LD_VAR 0 2
49334: ARRAY
49335: PUSH
49336: LD_VAR 0 3
49340: ARRAY
49341: PPUSH
49342: CALL_OW 459
49346: NOT
49347: AND
49348: PUSH
49349: LD_EXP 113
49353: PUSH
49354: LD_VAR 0 2
49358: ARRAY
49359: PUSH
49360: LD_VAR 0 3
49364: ARRAY
49365: PPUSH
49366: CALL_OW 314
49370: NOT
49371: AND
49372: IFFALSE 49532
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
49374: LD_EXP 113
49378: PUSH
49379: LD_VAR 0 2
49383: ARRAY
49384: PUSH
49385: LD_VAR 0 3
49389: ARRAY
49390: PPUSH
49391: CALL_OW 310
49395: IFFALSE 49418
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
49397: LD_EXP 113
49401: PUSH
49402: LD_VAR 0 2
49406: ARRAY
49407: PUSH
49408: LD_VAR 0 3
49412: ARRAY
49413: PPUSH
49414: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
49418: LD_EXP 113
49422: PUSH
49423: LD_VAR 0 2
49427: ARRAY
49428: PUSH
49429: LD_VAR 0 3
49433: ARRAY
49434: PPUSH
49435: CALL_OW 314
49439: NOT
49440: IFFALSE 49532
// begin r := rand ( 1 , mc_mines [ i ] ) ;
49442: LD_ADDR_VAR 0 7
49446: PUSH
49447: LD_INT 1
49449: PPUSH
49450: LD_EXP 112
49454: PUSH
49455: LD_VAR 0 2
49459: ARRAY
49460: PPUSH
49461: CALL_OW 12
49465: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
49466: LD_EXP 113
49470: PUSH
49471: LD_VAR 0 2
49475: ARRAY
49476: PUSH
49477: LD_VAR 0 3
49481: ARRAY
49482: PPUSH
49483: LD_EXP 112
49487: PUSH
49488: LD_VAR 0 2
49492: ARRAY
49493: PUSH
49494: LD_VAR 0 7
49498: ARRAY
49499: PUSH
49500: LD_INT 1
49502: ARRAY
49503: PPUSH
49504: LD_EXP 112
49508: PUSH
49509: LD_VAR 0 2
49513: ARRAY
49514: PUSH
49515: LD_VAR 0 7
49519: ARRAY
49520: PUSH
49521: LD_INT 2
49523: ARRAY
49524: PPUSH
49525: LD_INT 0
49527: PPUSH
49528: CALL_OW 193
// end ; end ; end ;
49532: GO 49185
49534: POP
49535: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
49536: LD_ADDR_VAR 0 5
49540: PUSH
49541: LD_EXP 99
49545: PUSH
49546: LD_VAR 0 2
49550: ARRAY
49551: PPUSH
49552: LD_INT 2
49554: PUSH
49555: LD_INT 30
49557: PUSH
49558: LD_INT 4
49560: PUSH
49561: EMPTY
49562: LIST
49563: LIST
49564: PUSH
49565: LD_INT 30
49567: PUSH
49568: LD_INT 5
49570: PUSH
49571: EMPTY
49572: LIST
49573: LIST
49574: PUSH
49575: LD_INT 30
49577: PUSH
49578: LD_INT 32
49580: PUSH
49581: EMPTY
49582: LIST
49583: LIST
49584: PUSH
49585: EMPTY
49586: LIST
49587: LIST
49588: LIST
49589: LIST
49590: PPUSH
49591: CALL_OW 72
49595: ST_TO_ADDR
// if not tmp then
49596: LD_VAR 0 5
49600: NOT
49601: IFFALSE 49605
// continue ;
49603: GO 49098
// list := [ ] ;
49605: LD_ADDR_VAR 0 6
49609: PUSH
49610: EMPTY
49611: ST_TO_ADDR
// for j in tmp do
49612: LD_ADDR_VAR 0 3
49616: PUSH
49617: LD_VAR 0 5
49621: PUSH
49622: FOR_IN
49623: IFFALSE 49692
// begin for k in UnitsInside ( j ) do
49625: LD_ADDR_VAR 0 4
49629: PUSH
49630: LD_VAR 0 3
49634: PPUSH
49635: CALL_OW 313
49639: PUSH
49640: FOR_IN
49641: IFFALSE 49688
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
49643: LD_VAR 0 4
49647: PPUSH
49648: CALL_OW 257
49652: PUSH
49653: LD_INT 1
49655: EQUAL
49656: PUSH
49657: LD_VAR 0 4
49661: PPUSH
49662: CALL_OW 459
49666: NOT
49667: AND
49668: IFFALSE 49686
// list := list ^ k ;
49670: LD_ADDR_VAR 0 6
49674: PUSH
49675: LD_VAR 0 6
49679: PUSH
49680: LD_VAR 0 4
49684: ADD
49685: ST_TO_ADDR
49686: GO 49640
49688: POP
49689: POP
// end ;
49690: GO 49622
49692: POP
49693: POP
// list := list diff mc_miners [ i ] ;
49694: LD_ADDR_VAR 0 6
49698: PUSH
49699: LD_VAR 0 6
49703: PUSH
49704: LD_EXP 113
49708: PUSH
49709: LD_VAR 0 2
49713: ARRAY
49714: DIFF
49715: ST_TO_ADDR
// if not list then
49716: LD_VAR 0 6
49720: NOT
49721: IFFALSE 49725
// continue ;
49723: GO 49098
// k := mc_mines [ i ] - mc_miners [ i ] ;
49725: LD_ADDR_VAR 0 4
49729: PUSH
49730: LD_EXP 112
49734: PUSH
49735: LD_VAR 0 2
49739: ARRAY
49740: PUSH
49741: LD_EXP 113
49745: PUSH
49746: LD_VAR 0 2
49750: ARRAY
49751: MINUS
49752: ST_TO_ADDR
// if k > list then
49753: LD_VAR 0 4
49757: PUSH
49758: LD_VAR 0 6
49762: GREATER
49763: IFFALSE 49775
// k := list ;
49765: LD_ADDR_VAR 0 4
49769: PUSH
49770: LD_VAR 0 6
49774: ST_TO_ADDR
// for j = 1 to k do
49775: LD_ADDR_VAR 0 3
49779: PUSH
49780: DOUBLE
49781: LD_INT 1
49783: DEC
49784: ST_TO_ADDR
49785: LD_VAR 0 4
49789: PUSH
49790: FOR_TO
49791: IFFALSE 49845
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
49793: LD_ADDR_EXP 113
49797: PUSH
49798: LD_EXP 113
49802: PPUSH
49803: LD_VAR 0 2
49807: PUSH
49808: LD_EXP 113
49812: PUSH
49813: LD_VAR 0 2
49817: ARRAY
49818: PUSH
49819: LD_INT 1
49821: PLUS
49822: PUSH
49823: EMPTY
49824: LIST
49825: LIST
49826: PPUSH
49827: LD_VAR 0 6
49831: PUSH
49832: LD_VAR 0 3
49836: ARRAY
49837: PPUSH
49838: CALL 72371 0 3
49842: ST_TO_ADDR
49843: GO 49790
49845: POP
49846: POP
// end ;
49847: GO 49098
49849: POP
49850: POP
// end ;
49851: LD_VAR 0 1
49855: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
49856: LD_INT 0
49858: PPUSH
49859: PPUSH
49860: PPUSH
49861: PPUSH
49862: PPUSH
49863: PPUSH
49864: PPUSH
49865: PPUSH
49866: PPUSH
49867: PPUSH
49868: PPUSH
// if not mc_bases then
49869: LD_EXP 99
49873: NOT
49874: IFFALSE 49878
// exit ;
49876: GO 51701
// for i = 1 to mc_bases do
49878: LD_ADDR_VAR 0 2
49882: PUSH
49883: DOUBLE
49884: LD_INT 1
49886: DEC
49887: ST_TO_ADDR
49888: LD_EXP 99
49892: PUSH
49893: FOR_TO
49894: IFFALSE 51699
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
49896: LD_EXP 99
49900: PUSH
49901: LD_VAR 0 2
49905: ARRAY
49906: NOT
49907: PUSH
49908: LD_EXP 106
49912: PUSH
49913: LD_VAR 0 2
49917: ARRAY
49918: OR
49919: IFFALSE 49923
// continue ;
49921: GO 49893
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
49923: LD_EXP 115
49927: PUSH
49928: LD_VAR 0 2
49932: ARRAY
49933: NOT
49934: PUSH
49935: LD_EXP 116
49939: PUSH
49940: LD_VAR 0 2
49944: ARRAY
49945: AND
49946: IFFALSE 49984
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
49948: LD_ADDR_EXP 116
49952: PUSH
49953: LD_EXP 116
49957: PPUSH
49958: LD_VAR 0 2
49962: PPUSH
49963: EMPTY
49964: PPUSH
49965: CALL_OW 1
49969: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
49970: LD_VAR 0 2
49974: PPUSH
49975: LD_INT 107
49977: PPUSH
49978: CALL 40731 0 2
// continue ;
49982: GO 49893
// end ; target := [ ] ;
49984: LD_ADDR_VAR 0 7
49988: PUSH
49989: EMPTY
49990: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
49991: LD_ADDR_VAR 0 6
49995: PUSH
49996: LD_EXP 99
50000: PUSH
50001: LD_VAR 0 2
50005: ARRAY
50006: PUSH
50007: LD_INT 1
50009: ARRAY
50010: PPUSH
50011: CALL_OW 255
50015: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50016: LD_ADDR_VAR 0 9
50020: PUSH
50021: LD_EXP 99
50025: PUSH
50026: LD_VAR 0 2
50030: ARRAY
50031: PPUSH
50032: LD_INT 2
50034: PUSH
50035: LD_INT 30
50037: PUSH
50038: LD_INT 0
50040: PUSH
50041: EMPTY
50042: LIST
50043: LIST
50044: PUSH
50045: LD_INT 30
50047: PUSH
50048: LD_INT 1
50050: PUSH
50051: EMPTY
50052: LIST
50053: LIST
50054: PUSH
50055: EMPTY
50056: LIST
50057: LIST
50058: LIST
50059: PPUSH
50060: CALL_OW 72
50064: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
50065: LD_ADDR_VAR 0 3
50069: PUSH
50070: DOUBLE
50071: LD_EXP 115
50075: PUSH
50076: LD_VAR 0 2
50080: ARRAY
50081: INC
50082: ST_TO_ADDR
50083: LD_INT 1
50085: PUSH
50086: FOR_DOWNTO
50087: IFFALSE 50332
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
50089: LD_EXP 115
50093: PUSH
50094: LD_VAR 0 2
50098: ARRAY
50099: PUSH
50100: LD_VAR 0 3
50104: ARRAY
50105: PUSH
50106: LD_INT 2
50108: ARRAY
50109: PPUSH
50110: LD_EXP 115
50114: PUSH
50115: LD_VAR 0 2
50119: ARRAY
50120: PUSH
50121: LD_VAR 0 3
50125: ARRAY
50126: PUSH
50127: LD_INT 3
50129: ARRAY
50130: PPUSH
50131: CALL_OW 488
50135: PUSH
50136: LD_EXP 115
50140: PUSH
50141: LD_VAR 0 2
50145: ARRAY
50146: PUSH
50147: LD_VAR 0 3
50151: ARRAY
50152: PUSH
50153: LD_INT 2
50155: ARRAY
50156: PPUSH
50157: LD_EXP 115
50161: PUSH
50162: LD_VAR 0 2
50166: ARRAY
50167: PUSH
50168: LD_VAR 0 3
50172: ARRAY
50173: PUSH
50174: LD_INT 3
50176: ARRAY
50177: PPUSH
50178: CALL_OW 284
50182: PUSH
50183: LD_INT 0
50185: EQUAL
50186: AND
50187: IFFALSE 50242
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
50189: LD_ADDR_VAR 0 5
50193: PUSH
50194: LD_EXP 115
50198: PUSH
50199: LD_VAR 0 2
50203: ARRAY
50204: PPUSH
50205: LD_VAR 0 3
50209: PPUSH
50210: CALL_OW 3
50214: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
50215: LD_ADDR_EXP 115
50219: PUSH
50220: LD_EXP 115
50224: PPUSH
50225: LD_VAR 0 2
50229: PPUSH
50230: LD_VAR 0 5
50234: PPUSH
50235: CALL_OW 1
50239: ST_TO_ADDR
// continue ;
50240: GO 50086
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
50242: LD_VAR 0 6
50246: PPUSH
50247: LD_EXP 115
50251: PUSH
50252: LD_VAR 0 2
50256: ARRAY
50257: PUSH
50258: LD_VAR 0 3
50262: ARRAY
50263: PUSH
50264: LD_INT 2
50266: ARRAY
50267: PPUSH
50268: LD_EXP 115
50272: PUSH
50273: LD_VAR 0 2
50277: ARRAY
50278: PUSH
50279: LD_VAR 0 3
50283: ARRAY
50284: PUSH
50285: LD_INT 3
50287: ARRAY
50288: PPUSH
50289: LD_INT 30
50291: PPUSH
50292: CALL 73267 0 4
50296: PUSH
50297: LD_INT 4
50299: ARRAY
50300: PUSH
50301: LD_INT 0
50303: EQUAL
50304: IFFALSE 50330
// begin target := mc_crates [ i ] [ j ] ;
50306: LD_ADDR_VAR 0 7
50310: PUSH
50311: LD_EXP 115
50315: PUSH
50316: LD_VAR 0 2
50320: ARRAY
50321: PUSH
50322: LD_VAR 0 3
50326: ARRAY
50327: ST_TO_ADDR
// break ;
50328: GO 50332
// end ; end ;
50330: GO 50086
50332: POP
50333: POP
// if not target then
50334: LD_VAR 0 7
50338: NOT
50339: IFFALSE 50343
// continue ;
50341: GO 49893
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
50343: LD_ADDR_VAR 0 8
50347: PUSH
50348: LD_EXP 118
50352: PUSH
50353: LD_VAR 0 2
50357: ARRAY
50358: PPUSH
50359: LD_INT 2
50361: PUSH
50362: LD_INT 3
50364: PUSH
50365: LD_INT 58
50367: PUSH
50368: EMPTY
50369: LIST
50370: PUSH
50371: EMPTY
50372: LIST
50373: LIST
50374: PUSH
50375: LD_INT 61
50377: PUSH
50378: EMPTY
50379: LIST
50380: PUSH
50381: LD_INT 33
50383: PUSH
50384: LD_INT 5
50386: PUSH
50387: EMPTY
50388: LIST
50389: LIST
50390: PUSH
50391: LD_INT 33
50393: PUSH
50394: LD_INT 3
50396: PUSH
50397: EMPTY
50398: LIST
50399: LIST
50400: PUSH
50401: EMPTY
50402: LIST
50403: LIST
50404: LIST
50405: LIST
50406: LIST
50407: PUSH
50408: LD_INT 2
50410: PUSH
50411: LD_INT 34
50413: PUSH
50414: LD_INT 32
50416: PUSH
50417: EMPTY
50418: LIST
50419: LIST
50420: PUSH
50421: LD_INT 34
50423: PUSH
50424: LD_INT 51
50426: PUSH
50427: EMPTY
50428: LIST
50429: LIST
50430: PUSH
50431: LD_INT 34
50433: PUSH
50434: LD_INT 12
50436: PUSH
50437: EMPTY
50438: LIST
50439: LIST
50440: PUSH
50441: EMPTY
50442: LIST
50443: LIST
50444: LIST
50445: LIST
50446: PUSH
50447: EMPTY
50448: LIST
50449: LIST
50450: PPUSH
50451: CALL_OW 72
50455: ST_TO_ADDR
// if not cargo then
50456: LD_VAR 0 8
50460: NOT
50461: IFFALSE 51167
// begin if mc_crates_collector [ i ] < 5 then
50463: LD_EXP 116
50467: PUSH
50468: LD_VAR 0 2
50472: ARRAY
50473: PUSH
50474: LD_INT 5
50476: LESS
50477: IFFALSE 50843
// begin if mc_ape [ i ] then
50479: LD_EXP 128
50483: PUSH
50484: LD_VAR 0 2
50488: ARRAY
50489: IFFALSE 50536
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
50491: LD_ADDR_VAR 0 5
50495: PUSH
50496: LD_EXP 128
50500: PUSH
50501: LD_VAR 0 2
50505: ARRAY
50506: PPUSH
50507: LD_INT 25
50509: PUSH
50510: LD_INT 16
50512: PUSH
50513: EMPTY
50514: LIST
50515: LIST
50516: PUSH
50517: LD_INT 24
50519: PUSH
50520: LD_INT 750
50522: PUSH
50523: EMPTY
50524: LIST
50525: LIST
50526: PUSH
50527: EMPTY
50528: LIST
50529: LIST
50530: PPUSH
50531: CALL_OW 72
50535: ST_TO_ADDR
// if not tmp then
50536: LD_VAR 0 5
50540: NOT
50541: IFFALSE 50588
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
50543: LD_ADDR_VAR 0 5
50547: PUSH
50548: LD_EXP 99
50552: PUSH
50553: LD_VAR 0 2
50557: ARRAY
50558: PPUSH
50559: LD_INT 25
50561: PUSH
50562: LD_INT 2
50564: PUSH
50565: EMPTY
50566: LIST
50567: LIST
50568: PUSH
50569: LD_INT 24
50571: PUSH
50572: LD_INT 750
50574: PUSH
50575: EMPTY
50576: LIST
50577: LIST
50578: PUSH
50579: EMPTY
50580: LIST
50581: LIST
50582: PPUSH
50583: CALL_OW 72
50587: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
50588: LD_EXP 128
50592: PUSH
50593: LD_VAR 0 2
50597: ARRAY
50598: PUSH
50599: LD_EXP 99
50603: PUSH
50604: LD_VAR 0 2
50608: ARRAY
50609: PPUSH
50610: LD_INT 25
50612: PUSH
50613: LD_INT 2
50615: PUSH
50616: EMPTY
50617: LIST
50618: LIST
50619: PUSH
50620: LD_INT 24
50622: PUSH
50623: LD_INT 750
50625: PUSH
50626: EMPTY
50627: LIST
50628: LIST
50629: PUSH
50630: EMPTY
50631: LIST
50632: LIST
50633: PPUSH
50634: CALL_OW 72
50638: AND
50639: PUSH
50640: LD_VAR 0 5
50644: PUSH
50645: LD_INT 5
50647: LESS
50648: AND
50649: IFFALSE 50731
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
50651: LD_ADDR_VAR 0 3
50655: PUSH
50656: LD_EXP 99
50660: PUSH
50661: LD_VAR 0 2
50665: ARRAY
50666: PPUSH
50667: LD_INT 25
50669: PUSH
50670: LD_INT 2
50672: PUSH
50673: EMPTY
50674: LIST
50675: LIST
50676: PUSH
50677: LD_INT 24
50679: PUSH
50680: LD_INT 750
50682: PUSH
50683: EMPTY
50684: LIST
50685: LIST
50686: PUSH
50687: EMPTY
50688: LIST
50689: LIST
50690: PPUSH
50691: CALL_OW 72
50695: PUSH
50696: FOR_IN
50697: IFFALSE 50729
// begin tmp := tmp union j ;
50699: LD_ADDR_VAR 0 5
50703: PUSH
50704: LD_VAR 0 5
50708: PUSH
50709: LD_VAR 0 3
50713: UNION
50714: ST_TO_ADDR
// if tmp >= 5 then
50715: LD_VAR 0 5
50719: PUSH
50720: LD_INT 5
50722: GREATEREQUAL
50723: IFFALSE 50727
// break ;
50725: GO 50729
// end ;
50727: GO 50696
50729: POP
50730: POP
// end ; if not tmp then
50731: LD_VAR 0 5
50735: NOT
50736: IFFALSE 50740
// continue ;
50738: GO 49893
// for j in tmp do
50740: LD_ADDR_VAR 0 3
50744: PUSH
50745: LD_VAR 0 5
50749: PUSH
50750: FOR_IN
50751: IFFALSE 50841
// if not GetTag ( j ) then
50753: LD_VAR 0 3
50757: PPUSH
50758: CALL_OW 110
50762: NOT
50763: IFFALSE 50839
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
50765: LD_ADDR_EXP 116
50769: PUSH
50770: LD_EXP 116
50774: PPUSH
50775: LD_VAR 0 2
50779: PUSH
50780: LD_EXP 116
50784: PUSH
50785: LD_VAR 0 2
50789: ARRAY
50790: PUSH
50791: LD_INT 1
50793: PLUS
50794: PUSH
50795: EMPTY
50796: LIST
50797: LIST
50798: PPUSH
50799: LD_VAR 0 3
50803: PPUSH
50804: CALL 72371 0 3
50808: ST_TO_ADDR
// SetTag ( j , 107 ) ;
50809: LD_VAR 0 3
50813: PPUSH
50814: LD_INT 107
50816: PPUSH
50817: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
50821: LD_EXP 116
50825: PUSH
50826: LD_VAR 0 2
50830: ARRAY
50831: PUSH
50832: LD_INT 5
50834: GREATEREQUAL
50835: IFFALSE 50839
// break ;
50837: GO 50841
// end ;
50839: GO 50750
50841: POP
50842: POP
// end ; if mc_crates_collector [ i ] and target then
50843: LD_EXP 116
50847: PUSH
50848: LD_VAR 0 2
50852: ARRAY
50853: PUSH
50854: LD_VAR 0 7
50858: AND
50859: IFFALSE 51165
// begin if mc_crates_collector [ i ] < target [ 1 ] then
50861: LD_EXP 116
50865: PUSH
50866: LD_VAR 0 2
50870: ARRAY
50871: PUSH
50872: LD_VAR 0 7
50876: PUSH
50877: LD_INT 1
50879: ARRAY
50880: LESS
50881: IFFALSE 50901
// tmp := mc_crates_collector [ i ] else
50883: LD_ADDR_VAR 0 5
50887: PUSH
50888: LD_EXP 116
50892: PUSH
50893: LD_VAR 0 2
50897: ARRAY
50898: ST_TO_ADDR
50899: GO 50915
// tmp := target [ 1 ] ;
50901: LD_ADDR_VAR 0 5
50905: PUSH
50906: LD_VAR 0 7
50910: PUSH
50911: LD_INT 1
50913: ARRAY
50914: ST_TO_ADDR
// k := 0 ;
50915: LD_ADDR_VAR 0 4
50919: PUSH
50920: LD_INT 0
50922: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
50923: LD_ADDR_VAR 0 3
50927: PUSH
50928: LD_EXP 116
50932: PUSH
50933: LD_VAR 0 2
50937: ARRAY
50938: PUSH
50939: FOR_IN
50940: IFFALSE 51163
// begin k := k + 1 ;
50942: LD_ADDR_VAR 0 4
50946: PUSH
50947: LD_VAR 0 4
50951: PUSH
50952: LD_INT 1
50954: PLUS
50955: ST_TO_ADDR
// if k > tmp then
50956: LD_VAR 0 4
50960: PUSH
50961: LD_VAR 0 5
50965: GREATER
50966: IFFALSE 50970
// break ;
50968: GO 51163
// if not GetClass ( j ) in [ 2 , 16 ] then
50970: LD_VAR 0 3
50974: PPUSH
50975: CALL_OW 257
50979: PUSH
50980: LD_INT 2
50982: PUSH
50983: LD_INT 16
50985: PUSH
50986: EMPTY
50987: LIST
50988: LIST
50989: IN
50990: NOT
50991: IFFALSE 51044
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
50993: LD_ADDR_EXP 116
50997: PUSH
50998: LD_EXP 116
51002: PPUSH
51003: LD_VAR 0 2
51007: PPUSH
51008: LD_EXP 116
51012: PUSH
51013: LD_VAR 0 2
51017: ARRAY
51018: PUSH
51019: LD_VAR 0 3
51023: DIFF
51024: PPUSH
51025: CALL_OW 1
51029: ST_TO_ADDR
// SetTag ( j , 0 ) ;
51030: LD_VAR 0 3
51034: PPUSH
51035: LD_INT 0
51037: PPUSH
51038: CALL_OW 109
// continue ;
51042: GO 50939
// end ; if IsInUnit ( j ) then
51044: LD_VAR 0 3
51048: PPUSH
51049: CALL_OW 310
51053: IFFALSE 51064
// ComExitBuilding ( j ) ;
51055: LD_VAR 0 3
51059: PPUSH
51060: CALL_OW 122
// wait ( 3 ) ;
51064: LD_INT 3
51066: PPUSH
51067: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
51071: LD_VAR 0 3
51075: PPUSH
51076: CALL_OW 314
51080: PUSH
51081: LD_VAR 0 6
51085: PPUSH
51086: LD_VAR 0 7
51090: PUSH
51091: LD_INT 2
51093: ARRAY
51094: PPUSH
51095: LD_VAR 0 7
51099: PUSH
51100: LD_INT 3
51102: ARRAY
51103: PPUSH
51104: LD_INT 30
51106: PPUSH
51107: CALL 73267 0 4
51111: PUSH
51112: LD_INT 4
51114: ARRAY
51115: AND
51116: IFFALSE 51134
// ComStandNearbyBuilding ( j , depot ) else
51118: LD_VAR 0 3
51122: PPUSH
51123: LD_VAR 0 9
51127: PPUSH
51128: CALL 68798 0 2
51132: GO 51161
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
51134: LD_VAR 0 3
51138: PPUSH
51139: LD_VAR 0 7
51143: PUSH
51144: LD_INT 2
51146: ARRAY
51147: PPUSH
51148: LD_VAR 0 7
51152: PUSH
51153: LD_INT 3
51155: ARRAY
51156: PPUSH
51157: CALL_OW 117
// end ;
51161: GO 50939
51163: POP
51164: POP
// end ; end else
51165: GO 51697
// begin for j in cargo do
51167: LD_ADDR_VAR 0 3
51171: PUSH
51172: LD_VAR 0 8
51176: PUSH
51177: FOR_IN
51178: IFFALSE 51695
// begin if GetTag ( j ) <> 0 then
51180: LD_VAR 0 3
51184: PPUSH
51185: CALL_OW 110
51189: PUSH
51190: LD_INT 0
51192: NONEQUAL
51193: IFFALSE 51197
// continue ;
51195: GO 51177
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
51197: LD_VAR 0 3
51201: PPUSH
51202: CALL_OW 256
51206: PUSH
51207: LD_INT 1000
51209: LESS
51210: PUSH
51211: LD_VAR 0 3
51215: PPUSH
51216: LD_EXP 123
51220: PUSH
51221: LD_VAR 0 2
51225: ARRAY
51226: PPUSH
51227: CALL_OW 308
51231: NOT
51232: AND
51233: IFFALSE 51255
// ComMoveToArea ( j , mc_parking [ i ] ) ;
51235: LD_VAR 0 3
51239: PPUSH
51240: LD_EXP 123
51244: PUSH
51245: LD_VAR 0 2
51249: ARRAY
51250: PPUSH
51251: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
51255: LD_VAR 0 3
51259: PPUSH
51260: CALL_OW 256
51264: PUSH
51265: LD_INT 1000
51267: LESS
51268: PUSH
51269: LD_VAR 0 3
51273: PPUSH
51274: LD_EXP 123
51278: PUSH
51279: LD_VAR 0 2
51283: ARRAY
51284: PPUSH
51285: CALL_OW 308
51289: AND
51290: IFFALSE 51294
// continue ;
51292: GO 51177
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
51294: LD_VAR 0 3
51298: PPUSH
51299: CALL_OW 262
51303: PUSH
51304: LD_INT 2
51306: EQUAL
51307: PUSH
51308: LD_VAR 0 3
51312: PPUSH
51313: CALL_OW 261
51317: PUSH
51318: LD_INT 15
51320: LESS
51321: AND
51322: IFFALSE 51326
// continue ;
51324: GO 51177
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
51326: LD_VAR 0 3
51330: PPUSH
51331: CALL_OW 262
51335: PUSH
51336: LD_INT 1
51338: EQUAL
51339: PUSH
51340: LD_VAR 0 3
51344: PPUSH
51345: CALL_OW 261
51349: PUSH
51350: LD_INT 10
51352: LESS
51353: AND
51354: IFFALSE 51634
// begin if not depot then
51356: LD_VAR 0 9
51360: NOT
51361: IFFALSE 51365
// continue ;
51363: GO 51177
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
51365: LD_VAR 0 3
51369: PPUSH
51370: LD_VAR 0 9
51374: PPUSH
51375: LD_VAR 0 3
51379: PPUSH
51380: CALL_OW 74
51384: PPUSH
51385: CALL_OW 296
51389: PUSH
51390: LD_INT 6
51392: LESS
51393: IFFALSE 51409
// SetFuel ( j , 100 ) else
51395: LD_VAR 0 3
51399: PPUSH
51400: LD_INT 100
51402: PPUSH
51403: CALL_OW 240
51407: GO 51634
// if GetFuel ( j ) = 0 then
51409: LD_VAR 0 3
51413: PPUSH
51414: CALL_OW 261
51418: PUSH
51419: LD_INT 0
51421: EQUAL
51422: IFFALSE 51634
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
51424: LD_ADDR_EXP 118
51428: PUSH
51429: LD_EXP 118
51433: PPUSH
51434: LD_VAR 0 2
51438: PPUSH
51439: LD_EXP 118
51443: PUSH
51444: LD_VAR 0 2
51448: ARRAY
51449: PUSH
51450: LD_VAR 0 3
51454: DIFF
51455: PPUSH
51456: CALL_OW 1
51460: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
51461: LD_VAR 0 3
51465: PPUSH
51466: CALL_OW 263
51470: PUSH
51471: LD_INT 1
51473: EQUAL
51474: IFFALSE 51490
// ComExitVehicle ( IsInUnit ( j ) ) ;
51476: LD_VAR 0 3
51480: PPUSH
51481: CALL_OW 310
51485: PPUSH
51486: CALL_OW 121
// if GetControl ( j ) = control_remote then
51490: LD_VAR 0 3
51494: PPUSH
51495: CALL_OW 263
51499: PUSH
51500: LD_INT 2
51502: EQUAL
51503: IFFALSE 51514
// ComUnlink ( j ) ;
51505: LD_VAR 0 3
51509: PPUSH
51510: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
51514: LD_ADDR_VAR 0 10
51518: PUSH
51519: LD_VAR 0 2
51523: PPUSH
51524: LD_INT 3
51526: PPUSH
51527: CALL 61301 0 2
51531: ST_TO_ADDR
// if fac then
51532: LD_VAR 0 10
51536: IFFALSE 51632
// begin for k in fac do
51538: LD_ADDR_VAR 0 4
51542: PUSH
51543: LD_VAR 0 10
51547: PUSH
51548: FOR_IN
51549: IFFALSE 51630
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
51551: LD_ADDR_VAR 0 11
51555: PUSH
51556: LD_VAR 0 10
51560: PPUSH
51561: LD_VAR 0 3
51565: PPUSH
51566: CALL_OW 265
51570: PPUSH
51571: LD_VAR 0 3
51575: PPUSH
51576: CALL_OW 262
51580: PPUSH
51581: LD_VAR 0 3
51585: PPUSH
51586: CALL_OW 263
51590: PPUSH
51591: LD_VAR 0 3
51595: PPUSH
51596: CALL_OW 264
51600: PPUSH
51601: CALL 69869 0 5
51605: ST_TO_ADDR
// if components then
51606: LD_VAR 0 11
51610: IFFALSE 51628
// begin MC_InsertProduceList ( i , components ) ;
51612: LD_VAR 0 2
51616: PPUSH
51617: LD_VAR 0 11
51621: PPUSH
51622: CALL 60846 0 2
// break ;
51626: GO 51630
// end ; end ;
51628: GO 51548
51630: POP
51631: POP
// end ; continue ;
51632: GO 51177
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
51634: LD_VAR 0 3
51638: PPUSH
51639: LD_INT 1
51641: PPUSH
51642: CALL_OW 289
51646: PUSH
51647: LD_INT 100
51649: LESS
51650: PUSH
51651: LD_VAR 0 3
51655: PPUSH
51656: CALL_OW 314
51660: NOT
51661: AND
51662: IFFALSE 51691
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
51664: LD_VAR 0 3
51668: PPUSH
51669: LD_VAR 0 7
51673: PUSH
51674: LD_INT 2
51676: ARRAY
51677: PPUSH
51678: LD_VAR 0 7
51682: PUSH
51683: LD_INT 3
51685: ARRAY
51686: PPUSH
51687: CALL_OW 117
// break ;
51691: GO 51695
// end ;
51693: GO 51177
51695: POP
51696: POP
// end ; end ;
51697: GO 49893
51699: POP
51700: POP
// end ;
51701: LD_VAR 0 1
51705: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
51706: LD_INT 0
51708: PPUSH
51709: PPUSH
51710: PPUSH
51711: PPUSH
// if not mc_bases then
51712: LD_EXP 99
51716: NOT
51717: IFFALSE 51721
// exit ;
51719: GO 51882
// for i = 1 to mc_bases do
51721: LD_ADDR_VAR 0 2
51725: PUSH
51726: DOUBLE
51727: LD_INT 1
51729: DEC
51730: ST_TO_ADDR
51731: LD_EXP 99
51735: PUSH
51736: FOR_TO
51737: IFFALSE 51880
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
51739: LD_ADDR_VAR 0 4
51743: PUSH
51744: LD_EXP 118
51748: PUSH
51749: LD_VAR 0 2
51753: ARRAY
51754: PUSH
51755: LD_EXP 121
51759: PUSH
51760: LD_VAR 0 2
51764: ARRAY
51765: UNION
51766: PPUSH
51767: LD_INT 33
51769: PUSH
51770: LD_INT 2
51772: PUSH
51773: EMPTY
51774: LIST
51775: LIST
51776: PPUSH
51777: CALL_OW 72
51781: ST_TO_ADDR
// if tmp then
51782: LD_VAR 0 4
51786: IFFALSE 51878
// for j in tmp do
51788: LD_ADDR_VAR 0 3
51792: PUSH
51793: LD_VAR 0 4
51797: PUSH
51798: FOR_IN
51799: IFFALSE 51876
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
51801: LD_VAR 0 3
51805: PPUSH
51806: CALL_OW 312
51810: NOT
51811: PUSH
51812: LD_VAR 0 3
51816: PPUSH
51817: CALL_OW 256
51821: PUSH
51822: LD_INT 250
51824: GREATEREQUAL
51825: AND
51826: IFFALSE 51839
// Connect ( j ) else
51828: LD_VAR 0 3
51832: PPUSH
51833: CALL 75340 0 1
51837: GO 51874
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
51839: LD_VAR 0 3
51843: PPUSH
51844: CALL_OW 256
51848: PUSH
51849: LD_INT 250
51851: LESS
51852: PUSH
51853: LD_VAR 0 3
51857: PPUSH
51858: CALL_OW 312
51862: AND
51863: IFFALSE 51874
// ComUnlink ( j ) ;
51865: LD_VAR 0 3
51869: PPUSH
51870: CALL_OW 136
51874: GO 51798
51876: POP
51877: POP
// end ;
51878: GO 51736
51880: POP
51881: POP
// end ;
51882: LD_VAR 0 1
51886: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
51887: LD_INT 0
51889: PPUSH
51890: PPUSH
51891: PPUSH
51892: PPUSH
51893: PPUSH
// if not mc_bases then
51894: LD_EXP 99
51898: NOT
51899: IFFALSE 51903
// exit ;
51901: GO 52348
// for i = 1 to mc_bases do
51903: LD_ADDR_VAR 0 2
51907: PUSH
51908: DOUBLE
51909: LD_INT 1
51911: DEC
51912: ST_TO_ADDR
51913: LD_EXP 99
51917: PUSH
51918: FOR_TO
51919: IFFALSE 52346
// begin if not mc_produce [ i ] then
51921: LD_EXP 120
51925: PUSH
51926: LD_VAR 0 2
51930: ARRAY
51931: NOT
51932: IFFALSE 51936
// continue ;
51934: GO 51918
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51936: LD_ADDR_VAR 0 5
51940: PUSH
51941: LD_EXP 99
51945: PUSH
51946: LD_VAR 0 2
51950: ARRAY
51951: PPUSH
51952: LD_INT 30
51954: PUSH
51955: LD_INT 3
51957: PUSH
51958: EMPTY
51959: LIST
51960: LIST
51961: PPUSH
51962: CALL_OW 72
51966: ST_TO_ADDR
// if not fac then
51967: LD_VAR 0 5
51971: NOT
51972: IFFALSE 51976
// continue ;
51974: GO 51918
// for j in fac do
51976: LD_ADDR_VAR 0 3
51980: PUSH
51981: LD_VAR 0 5
51985: PUSH
51986: FOR_IN
51987: IFFALSE 52342
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
51989: LD_VAR 0 3
51993: PPUSH
51994: CALL_OW 461
51998: PUSH
51999: LD_INT 2
52001: NONEQUAL
52002: PUSH
52003: LD_VAR 0 3
52007: PPUSH
52008: LD_INT 15
52010: PPUSH
52011: CALL 74968 0 2
52015: PUSH
52016: LD_INT 4
52018: ARRAY
52019: OR
52020: IFFALSE 52024
// continue ;
52022: GO 51986
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
52024: LD_VAR 0 3
52028: PPUSH
52029: LD_EXP 120
52033: PUSH
52034: LD_VAR 0 2
52038: ARRAY
52039: PUSH
52040: LD_INT 1
52042: ARRAY
52043: PUSH
52044: LD_INT 1
52046: ARRAY
52047: PPUSH
52048: LD_EXP 120
52052: PUSH
52053: LD_VAR 0 2
52057: ARRAY
52058: PUSH
52059: LD_INT 1
52061: ARRAY
52062: PUSH
52063: LD_INT 2
52065: ARRAY
52066: PPUSH
52067: LD_EXP 120
52071: PUSH
52072: LD_VAR 0 2
52076: ARRAY
52077: PUSH
52078: LD_INT 1
52080: ARRAY
52081: PUSH
52082: LD_INT 3
52084: ARRAY
52085: PPUSH
52086: LD_EXP 120
52090: PUSH
52091: LD_VAR 0 2
52095: ARRAY
52096: PUSH
52097: LD_INT 1
52099: ARRAY
52100: PUSH
52101: LD_INT 4
52103: ARRAY
52104: PPUSH
52105: CALL_OW 448
52109: PUSH
52110: LD_VAR 0 3
52114: PPUSH
52115: LD_EXP 120
52119: PUSH
52120: LD_VAR 0 2
52124: ARRAY
52125: PUSH
52126: LD_INT 1
52128: ARRAY
52129: PUSH
52130: LD_INT 1
52132: ARRAY
52133: PUSH
52134: LD_EXP 120
52138: PUSH
52139: LD_VAR 0 2
52143: ARRAY
52144: PUSH
52145: LD_INT 1
52147: ARRAY
52148: PUSH
52149: LD_INT 2
52151: ARRAY
52152: PUSH
52153: LD_EXP 120
52157: PUSH
52158: LD_VAR 0 2
52162: ARRAY
52163: PUSH
52164: LD_INT 1
52166: ARRAY
52167: PUSH
52168: LD_INT 3
52170: ARRAY
52171: PUSH
52172: LD_EXP 120
52176: PUSH
52177: LD_VAR 0 2
52181: ARRAY
52182: PUSH
52183: LD_INT 1
52185: ARRAY
52186: PUSH
52187: LD_INT 4
52189: ARRAY
52190: PUSH
52191: EMPTY
52192: LIST
52193: LIST
52194: LIST
52195: LIST
52196: PPUSH
52197: CALL 78735 0 2
52201: AND
52202: IFFALSE 52340
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
52204: LD_VAR 0 3
52208: PPUSH
52209: LD_EXP 120
52213: PUSH
52214: LD_VAR 0 2
52218: ARRAY
52219: PUSH
52220: LD_INT 1
52222: ARRAY
52223: PUSH
52224: LD_INT 1
52226: ARRAY
52227: PPUSH
52228: LD_EXP 120
52232: PUSH
52233: LD_VAR 0 2
52237: ARRAY
52238: PUSH
52239: LD_INT 1
52241: ARRAY
52242: PUSH
52243: LD_INT 2
52245: ARRAY
52246: PPUSH
52247: LD_EXP 120
52251: PUSH
52252: LD_VAR 0 2
52256: ARRAY
52257: PUSH
52258: LD_INT 1
52260: ARRAY
52261: PUSH
52262: LD_INT 3
52264: ARRAY
52265: PPUSH
52266: LD_EXP 120
52270: PUSH
52271: LD_VAR 0 2
52275: ARRAY
52276: PUSH
52277: LD_INT 1
52279: ARRAY
52280: PUSH
52281: LD_INT 4
52283: ARRAY
52284: PPUSH
52285: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
52289: LD_ADDR_VAR 0 4
52293: PUSH
52294: LD_EXP 120
52298: PUSH
52299: LD_VAR 0 2
52303: ARRAY
52304: PPUSH
52305: LD_INT 1
52307: PPUSH
52308: CALL_OW 3
52312: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
52313: LD_ADDR_EXP 120
52317: PUSH
52318: LD_EXP 120
52322: PPUSH
52323: LD_VAR 0 2
52327: PPUSH
52328: LD_VAR 0 4
52332: PPUSH
52333: CALL_OW 1
52337: ST_TO_ADDR
// break ;
52338: GO 52342
// end ; end ;
52340: GO 51986
52342: POP
52343: POP
// end ;
52344: GO 51918
52346: POP
52347: POP
// end ;
52348: LD_VAR 0 1
52352: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
52353: LD_INT 0
52355: PPUSH
52356: PPUSH
52357: PPUSH
// if not mc_bases then
52358: LD_EXP 99
52362: NOT
52363: IFFALSE 52367
// exit ;
52365: GO 52456
// for i = 1 to mc_bases do
52367: LD_ADDR_VAR 0 2
52371: PUSH
52372: DOUBLE
52373: LD_INT 1
52375: DEC
52376: ST_TO_ADDR
52377: LD_EXP 99
52381: PUSH
52382: FOR_TO
52383: IFFALSE 52454
// begin if mc_attack [ i ] then
52385: LD_EXP 119
52389: PUSH
52390: LD_VAR 0 2
52394: ARRAY
52395: IFFALSE 52452
// begin tmp := mc_attack [ i ] [ 1 ] ;
52397: LD_ADDR_VAR 0 3
52401: PUSH
52402: LD_EXP 119
52406: PUSH
52407: LD_VAR 0 2
52411: ARRAY
52412: PUSH
52413: LD_INT 1
52415: ARRAY
52416: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
52417: LD_ADDR_EXP 119
52421: PUSH
52422: LD_EXP 119
52426: PPUSH
52427: LD_VAR 0 2
52431: PPUSH
52432: EMPTY
52433: PPUSH
52434: CALL_OW 1
52438: ST_TO_ADDR
// Attack ( tmp ) ;
52439: LD_VAR 0 3
52443: PPUSH
52444: CALL 128430 0 1
// exit ;
52448: POP
52449: POP
52450: GO 52456
// end ; end ;
52452: GO 52382
52454: POP
52455: POP
// end ;
52456: LD_VAR 0 1
52460: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
52461: LD_INT 0
52463: PPUSH
52464: PPUSH
52465: PPUSH
52466: PPUSH
52467: PPUSH
52468: PPUSH
52469: PPUSH
// if not mc_bases then
52470: LD_EXP 99
52474: NOT
52475: IFFALSE 52479
// exit ;
52477: GO 53336
// for i = 1 to mc_bases do
52479: LD_ADDR_VAR 0 2
52483: PUSH
52484: DOUBLE
52485: LD_INT 1
52487: DEC
52488: ST_TO_ADDR
52489: LD_EXP 99
52493: PUSH
52494: FOR_TO
52495: IFFALSE 53334
// begin if not mc_bases [ i ] then
52497: LD_EXP 99
52501: PUSH
52502: LD_VAR 0 2
52506: ARRAY
52507: NOT
52508: IFFALSE 52512
// continue ;
52510: GO 52494
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
52512: LD_ADDR_VAR 0 7
52516: PUSH
52517: LD_EXP 99
52521: PUSH
52522: LD_VAR 0 2
52526: ARRAY
52527: PUSH
52528: LD_INT 1
52530: ARRAY
52531: PPUSH
52532: CALL 69020 0 1
52536: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
52537: LD_ADDR_EXP 122
52541: PUSH
52542: LD_EXP 122
52546: PPUSH
52547: LD_VAR 0 2
52551: PPUSH
52552: LD_EXP 99
52556: PUSH
52557: LD_VAR 0 2
52561: ARRAY
52562: PUSH
52563: LD_INT 1
52565: ARRAY
52566: PPUSH
52567: CALL_OW 255
52571: PPUSH
52572: LD_EXP 124
52576: PUSH
52577: LD_VAR 0 2
52581: ARRAY
52582: PPUSH
52583: CALL 68985 0 2
52587: PPUSH
52588: CALL_OW 1
52592: ST_TO_ADDR
// if not mc_scan [ i ] then
52593: LD_EXP 122
52597: PUSH
52598: LD_VAR 0 2
52602: ARRAY
52603: NOT
52604: IFFALSE 52782
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
52606: LD_ADDR_EXP 142
52610: PUSH
52611: LD_EXP 142
52615: PPUSH
52616: LD_VAR 0 2
52620: PPUSH
52621: LD_INT 0
52623: PPUSH
52624: CALL_OW 1
52628: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52629: LD_ADDR_VAR 0 4
52633: PUSH
52634: LD_EXP 99
52638: PUSH
52639: LD_VAR 0 2
52643: ARRAY
52644: PPUSH
52645: LD_INT 2
52647: PUSH
52648: LD_INT 25
52650: PUSH
52651: LD_INT 5
52653: PUSH
52654: EMPTY
52655: LIST
52656: LIST
52657: PUSH
52658: LD_INT 25
52660: PUSH
52661: LD_INT 8
52663: PUSH
52664: EMPTY
52665: LIST
52666: LIST
52667: PUSH
52668: LD_INT 25
52670: PUSH
52671: LD_INT 9
52673: PUSH
52674: EMPTY
52675: LIST
52676: LIST
52677: PUSH
52678: EMPTY
52679: LIST
52680: LIST
52681: LIST
52682: LIST
52683: PPUSH
52684: CALL_OW 72
52688: ST_TO_ADDR
// if not tmp then
52689: LD_VAR 0 4
52693: NOT
52694: IFFALSE 52698
// continue ;
52696: GO 52494
// for j in tmp do
52698: LD_ADDR_VAR 0 3
52702: PUSH
52703: LD_VAR 0 4
52707: PUSH
52708: FOR_IN
52709: IFFALSE 52780
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
52711: LD_VAR 0 3
52715: PPUSH
52716: CALL_OW 310
52720: PPUSH
52721: CALL_OW 266
52725: PUSH
52726: LD_INT 5
52728: EQUAL
52729: PUSH
52730: LD_VAR 0 3
52734: PPUSH
52735: CALL_OW 257
52739: PUSH
52740: LD_INT 1
52742: EQUAL
52743: AND
52744: PUSH
52745: LD_VAR 0 3
52749: PPUSH
52750: CALL_OW 459
52754: NOT
52755: AND
52756: PUSH
52757: LD_VAR 0 7
52761: AND
52762: IFFALSE 52778
// ComChangeProfession ( j , class ) ;
52764: LD_VAR 0 3
52768: PPUSH
52769: LD_VAR 0 7
52773: PPUSH
52774: CALL_OW 123
52778: GO 52708
52780: POP
52781: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
52782: LD_EXP 122
52786: PUSH
52787: LD_VAR 0 2
52791: ARRAY
52792: PUSH
52793: LD_EXP 142
52797: PUSH
52798: LD_VAR 0 2
52802: ARRAY
52803: NOT
52804: AND
52805: PUSH
52806: LD_EXP 121
52810: PUSH
52811: LD_VAR 0 2
52815: ARRAY
52816: NOT
52817: AND
52818: PUSH
52819: LD_EXP 99
52823: PUSH
52824: LD_VAR 0 2
52828: ARRAY
52829: PPUSH
52830: LD_INT 50
52832: PUSH
52833: EMPTY
52834: LIST
52835: PUSH
52836: LD_INT 2
52838: PUSH
52839: LD_INT 30
52841: PUSH
52842: LD_INT 32
52844: PUSH
52845: EMPTY
52846: LIST
52847: LIST
52848: PUSH
52849: LD_INT 30
52851: PUSH
52852: LD_INT 33
52854: PUSH
52855: EMPTY
52856: LIST
52857: LIST
52858: PUSH
52859: LD_INT 30
52861: PUSH
52862: LD_INT 4
52864: PUSH
52865: EMPTY
52866: LIST
52867: LIST
52868: PUSH
52869: LD_INT 30
52871: PUSH
52872: LD_INT 5
52874: PUSH
52875: EMPTY
52876: LIST
52877: LIST
52878: PUSH
52879: EMPTY
52880: LIST
52881: LIST
52882: LIST
52883: LIST
52884: LIST
52885: PUSH
52886: EMPTY
52887: LIST
52888: LIST
52889: PPUSH
52890: CALL_OW 72
52894: PUSH
52895: LD_INT 4
52897: LESS
52898: PUSH
52899: LD_EXP 99
52903: PUSH
52904: LD_VAR 0 2
52908: ARRAY
52909: PPUSH
52910: LD_INT 3
52912: PUSH
52913: LD_INT 24
52915: PUSH
52916: LD_INT 1000
52918: PUSH
52919: EMPTY
52920: LIST
52921: LIST
52922: PUSH
52923: EMPTY
52924: LIST
52925: LIST
52926: PUSH
52927: LD_INT 2
52929: PUSH
52930: LD_INT 30
52932: PUSH
52933: LD_INT 0
52935: PUSH
52936: EMPTY
52937: LIST
52938: LIST
52939: PUSH
52940: LD_INT 30
52942: PUSH
52943: LD_INT 1
52945: PUSH
52946: EMPTY
52947: LIST
52948: LIST
52949: PUSH
52950: EMPTY
52951: LIST
52952: LIST
52953: LIST
52954: PUSH
52955: EMPTY
52956: LIST
52957: LIST
52958: PPUSH
52959: CALL_OW 72
52963: OR
52964: AND
52965: IFFALSE 53216
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
52967: LD_ADDR_EXP 142
52971: PUSH
52972: LD_EXP 142
52976: PPUSH
52977: LD_VAR 0 2
52981: PPUSH
52982: LD_INT 1
52984: PPUSH
52985: CALL_OW 1
52989: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52990: LD_ADDR_VAR 0 4
52994: PUSH
52995: LD_EXP 99
52999: PUSH
53000: LD_VAR 0 2
53004: ARRAY
53005: PPUSH
53006: LD_INT 2
53008: PUSH
53009: LD_INT 25
53011: PUSH
53012: LD_INT 1
53014: PUSH
53015: EMPTY
53016: LIST
53017: LIST
53018: PUSH
53019: LD_INT 25
53021: PUSH
53022: LD_INT 5
53024: PUSH
53025: EMPTY
53026: LIST
53027: LIST
53028: PUSH
53029: LD_INT 25
53031: PUSH
53032: LD_INT 8
53034: PUSH
53035: EMPTY
53036: LIST
53037: LIST
53038: PUSH
53039: LD_INT 25
53041: PUSH
53042: LD_INT 9
53044: PUSH
53045: EMPTY
53046: LIST
53047: LIST
53048: PUSH
53049: EMPTY
53050: LIST
53051: LIST
53052: LIST
53053: LIST
53054: LIST
53055: PPUSH
53056: CALL_OW 72
53060: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
53061: LD_ADDR_VAR 0 4
53065: PUSH
53066: LD_VAR 0 4
53070: PUSH
53071: LD_VAR 0 4
53075: PPUSH
53076: LD_INT 18
53078: PPUSH
53079: CALL 102257 0 2
53083: DIFF
53084: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
53085: LD_VAR 0 4
53089: NOT
53090: PUSH
53091: LD_EXP 99
53095: PUSH
53096: LD_VAR 0 2
53100: ARRAY
53101: PPUSH
53102: LD_INT 2
53104: PUSH
53105: LD_INT 30
53107: PUSH
53108: LD_INT 4
53110: PUSH
53111: EMPTY
53112: LIST
53113: LIST
53114: PUSH
53115: LD_INT 30
53117: PUSH
53118: LD_INT 5
53120: PUSH
53121: EMPTY
53122: LIST
53123: LIST
53124: PUSH
53125: EMPTY
53126: LIST
53127: LIST
53128: LIST
53129: PPUSH
53130: CALL_OW 72
53134: NOT
53135: AND
53136: IFFALSE 53198
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
53138: LD_ADDR_VAR 0 4
53142: PUSH
53143: LD_EXP 99
53147: PUSH
53148: LD_VAR 0 2
53152: ARRAY
53153: PPUSH
53154: LD_INT 2
53156: PUSH
53157: LD_INT 25
53159: PUSH
53160: LD_INT 2
53162: PUSH
53163: EMPTY
53164: LIST
53165: LIST
53166: PUSH
53167: LD_INT 25
53169: PUSH
53170: LD_INT 3
53172: PUSH
53173: EMPTY
53174: LIST
53175: LIST
53176: PUSH
53177: LD_INT 25
53179: PUSH
53180: LD_INT 4
53182: PUSH
53183: EMPTY
53184: LIST
53185: LIST
53186: PUSH
53187: EMPTY
53188: LIST
53189: LIST
53190: LIST
53191: LIST
53192: PPUSH
53193: CALL_OW 72
53197: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
53198: LD_VAR 0 2
53202: PPUSH
53203: LD_VAR 0 4
53207: PPUSH
53208: CALL 133139 0 2
// exit ;
53212: POP
53213: POP
53214: GO 53336
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
53216: LD_EXP 122
53220: PUSH
53221: LD_VAR 0 2
53225: ARRAY
53226: PUSH
53227: LD_EXP 142
53231: PUSH
53232: LD_VAR 0 2
53236: ARRAY
53237: NOT
53238: AND
53239: PUSH
53240: LD_EXP 121
53244: PUSH
53245: LD_VAR 0 2
53249: ARRAY
53250: AND
53251: IFFALSE 53332
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
53253: LD_ADDR_EXP 142
53257: PUSH
53258: LD_EXP 142
53262: PPUSH
53263: LD_VAR 0 2
53267: PPUSH
53268: LD_INT 1
53270: PPUSH
53271: CALL_OW 1
53275: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
53276: LD_ADDR_VAR 0 4
53280: PUSH
53281: LD_EXP 121
53285: PUSH
53286: LD_VAR 0 2
53290: ARRAY
53291: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
53292: LD_ADDR_EXP 121
53296: PUSH
53297: LD_EXP 121
53301: PPUSH
53302: LD_VAR 0 2
53306: PPUSH
53307: EMPTY
53308: PPUSH
53309: CALL_OW 1
53313: ST_TO_ADDR
// Defend ( i , tmp ) ;
53314: LD_VAR 0 2
53318: PPUSH
53319: LD_VAR 0 4
53323: PPUSH
53324: CALL 133735 0 2
// exit ;
53328: POP
53329: POP
53330: GO 53336
// end ; end ;
53332: GO 52494
53334: POP
53335: POP
// end ;
53336: LD_VAR 0 1
53340: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
53341: LD_INT 0
53343: PPUSH
53344: PPUSH
53345: PPUSH
53346: PPUSH
53347: PPUSH
53348: PPUSH
53349: PPUSH
53350: PPUSH
53351: PPUSH
53352: PPUSH
53353: PPUSH
// if not mc_bases then
53354: LD_EXP 99
53358: NOT
53359: IFFALSE 53363
// exit ;
53361: GO 54450
// for i = 1 to mc_bases do
53363: LD_ADDR_VAR 0 2
53367: PUSH
53368: DOUBLE
53369: LD_INT 1
53371: DEC
53372: ST_TO_ADDR
53373: LD_EXP 99
53377: PUSH
53378: FOR_TO
53379: IFFALSE 54448
// begin tmp := mc_lab [ i ] ;
53381: LD_ADDR_VAR 0 6
53385: PUSH
53386: LD_EXP 132
53390: PUSH
53391: LD_VAR 0 2
53395: ARRAY
53396: ST_TO_ADDR
// if not tmp then
53397: LD_VAR 0 6
53401: NOT
53402: IFFALSE 53406
// continue ;
53404: GO 53378
// idle_lab := 0 ;
53406: LD_ADDR_VAR 0 11
53410: PUSH
53411: LD_INT 0
53413: ST_TO_ADDR
// for j in tmp do
53414: LD_ADDR_VAR 0 3
53418: PUSH
53419: LD_VAR 0 6
53423: PUSH
53424: FOR_IN
53425: IFFALSE 54444
// begin researching := false ;
53427: LD_ADDR_VAR 0 10
53431: PUSH
53432: LD_INT 0
53434: ST_TO_ADDR
// side := GetSide ( j ) ;
53435: LD_ADDR_VAR 0 4
53439: PUSH
53440: LD_VAR 0 3
53444: PPUSH
53445: CALL_OW 255
53449: ST_TO_ADDR
// if not mc_tech [ side ] then
53450: LD_EXP 126
53454: PUSH
53455: LD_VAR 0 4
53459: ARRAY
53460: NOT
53461: IFFALSE 53465
// continue ;
53463: GO 53424
// if BuildingStatus ( j ) = bs_idle then
53465: LD_VAR 0 3
53469: PPUSH
53470: CALL_OW 461
53474: PUSH
53475: LD_INT 2
53477: EQUAL
53478: IFFALSE 53666
// begin if idle_lab and UnitsInside ( j ) < 6 then
53480: LD_VAR 0 11
53484: PUSH
53485: LD_VAR 0 3
53489: PPUSH
53490: CALL_OW 313
53494: PUSH
53495: LD_INT 6
53497: LESS
53498: AND
53499: IFFALSE 53570
// begin tmp2 := UnitsInside ( idle_lab ) ;
53501: LD_ADDR_VAR 0 9
53505: PUSH
53506: LD_VAR 0 11
53510: PPUSH
53511: CALL_OW 313
53515: ST_TO_ADDR
// if tmp2 then
53516: LD_VAR 0 9
53520: IFFALSE 53562
// for x in tmp2 do
53522: LD_ADDR_VAR 0 7
53526: PUSH
53527: LD_VAR 0 9
53531: PUSH
53532: FOR_IN
53533: IFFALSE 53560
// begin ComExitBuilding ( x ) ;
53535: LD_VAR 0 7
53539: PPUSH
53540: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
53544: LD_VAR 0 7
53548: PPUSH
53549: LD_VAR 0 3
53553: PPUSH
53554: CALL_OW 180
// end ;
53558: GO 53532
53560: POP
53561: POP
// idle_lab := 0 ;
53562: LD_ADDR_VAR 0 11
53566: PUSH
53567: LD_INT 0
53569: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
53570: LD_ADDR_VAR 0 5
53574: PUSH
53575: LD_EXP 126
53579: PUSH
53580: LD_VAR 0 4
53584: ARRAY
53585: PUSH
53586: FOR_IN
53587: IFFALSE 53647
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
53589: LD_VAR 0 3
53593: PPUSH
53594: LD_VAR 0 5
53598: PPUSH
53599: CALL_OW 430
53603: PUSH
53604: LD_VAR 0 4
53608: PPUSH
53609: LD_VAR 0 5
53613: PPUSH
53614: CALL 68090 0 2
53618: AND
53619: IFFALSE 53645
// begin researching := true ;
53621: LD_ADDR_VAR 0 10
53625: PUSH
53626: LD_INT 1
53628: ST_TO_ADDR
// ComResearch ( j , t ) ;
53629: LD_VAR 0 3
53633: PPUSH
53634: LD_VAR 0 5
53638: PPUSH
53639: CALL_OW 124
// break ;
53643: GO 53647
// end ;
53645: GO 53586
53647: POP
53648: POP
// if not researching then
53649: LD_VAR 0 10
53653: NOT
53654: IFFALSE 53666
// idle_lab := j ;
53656: LD_ADDR_VAR 0 11
53660: PUSH
53661: LD_VAR 0 3
53665: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
53666: LD_VAR 0 3
53670: PPUSH
53671: CALL_OW 461
53675: PUSH
53676: LD_INT 10
53678: EQUAL
53679: IFFALSE 54267
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
53681: LD_EXP 128
53685: PUSH
53686: LD_VAR 0 2
53690: ARRAY
53691: NOT
53692: PUSH
53693: LD_EXP 129
53697: PUSH
53698: LD_VAR 0 2
53702: ARRAY
53703: NOT
53704: AND
53705: PUSH
53706: LD_EXP 126
53710: PUSH
53711: LD_VAR 0 4
53715: ARRAY
53716: PUSH
53717: LD_INT 1
53719: GREATER
53720: AND
53721: IFFALSE 53852
// begin ComCancel ( j ) ;
53723: LD_VAR 0 3
53727: PPUSH
53728: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
53732: LD_ADDR_EXP 126
53736: PUSH
53737: LD_EXP 126
53741: PPUSH
53742: LD_VAR 0 4
53746: PPUSH
53747: LD_EXP 126
53751: PUSH
53752: LD_VAR 0 4
53756: ARRAY
53757: PPUSH
53758: LD_EXP 126
53762: PUSH
53763: LD_VAR 0 4
53767: ARRAY
53768: PUSH
53769: LD_INT 1
53771: MINUS
53772: PPUSH
53773: LD_EXP 126
53777: PUSH
53778: LD_VAR 0 4
53782: ARRAY
53783: PPUSH
53784: LD_INT 0
53786: PPUSH
53787: CALL 71789 0 4
53791: PPUSH
53792: CALL_OW 1
53796: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
53797: LD_ADDR_EXP 126
53801: PUSH
53802: LD_EXP 126
53806: PPUSH
53807: LD_VAR 0 4
53811: PPUSH
53812: LD_EXP 126
53816: PUSH
53817: LD_VAR 0 4
53821: ARRAY
53822: PPUSH
53823: LD_EXP 126
53827: PUSH
53828: LD_VAR 0 4
53832: ARRAY
53833: PPUSH
53834: LD_INT 1
53836: PPUSH
53837: LD_INT 0
53839: PPUSH
53840: CALL 71789 0 4
53844: PPUSH
53845: CALL_OW 1
53849: ST_TO_ADDR
// continue ;
53850: GO 53424
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
53852: LD_EXP 128
53856: PUSH
53857: LD_VAR 0 2
53861: ARRAY
53862: PUSH
53863: LD_EXP 129
53867: PUSH
53868: LD_VAR 0 2
53872: ARRAY
53873: NOT
53874: AND
53875: IFFALSE 54002
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
53877: LD_ADDR_EXP 129
53881: PUSH
53882: LD_EXP 129
53886: PPUSH
53887: LD_VAR 0 2
53891: PUSH
53892: LD_EXP 129
53896: PUSH
53897: LD_VAR 0 2
53901: ARRAY
53902: PUSH
53903: LD_INT 1
53905: PLUS
53906: PUSH
53907: EMPTY
53908: LIST
53909: LIST
53910: PPUSH
53911: LD_EXP 128
53915: PUSH
53916: LD_VAR 0 2
53920: ARRAY
53921: PUSH
53922: LD_INT 1
53924: ARRAY
53925: PPUSH
53926: CALL 72371 0 3
53930: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
53931: LD_EXP 128
53935: PUSH
53936: LD_VAR 0 2
53940: ARRAY
53941: PUSH
53942: LD_INT 1
53944: ARRAY
53945: PPUSH
53946: LD_INT 112
53948: PPUSH
53949: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
53953: LD_ADDR_VAR 0 9
53957: PUSH
53958: LD_EXP 128
53962: PUSH
53963: LD_VAR 0 2
53967: ARRAY
53968: PPUSH
53969: LD_INT 1
53971: PPUSH
53972: CALL_OW 3
53976: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
53977: LD_ADDR_EXP 128
53981: PUSH
53982: LD_EXP 128
53986: PPUSH
53987: LD_VAR 0 2
53991: PPUSH
53992: LD_VAR 0 9
53996: PPUSH
53997: CALL_OW 1
54001: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
54002: LD_EXP 128
54006: PUSH
54007: LD_VAR 0 2
54011: ARRAY
54012: PUSH
54013: LD_EXP 129
54017: PUSH
54018: LD_VAR 0 2
54022: ARRAY
54023: AND
54024: PUSH
54025: LD_EXP 129
54029: PUSH
54030: LD_VAR 0 2
54034: ARRAY
54035: PUSH
54036: LD_INT 1
54038: ARRAY
54039: PPUSH
54040: CALL_OW 310
54044: NOT
54045: AND
54046: PUSH
54047: LD_VAR 0 3
54051: PPUSH
54052: CALL_OW 313
54056: PUSH
54057: LD_INT 6
54059: EQUAL
54060: AND
54061: IFFALSE 54117
// begin tmp2 := UnitsInside ( j ) ;
54063: LD_ADDR_VAR 0 9
54067: PUSH
54068: LD_VAR 0 3
54072: PPUSH
54073: CALL_OW 313
54077: ST_TO_ADDR
// if tmp2 = 6 then
54078: LD_VAR 0 9
54082: PUSH
54083: LD_INT 6
54085: EQUAL
54086: IFFALSE 54117
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
54088: LD_VAR 0 9
54092: PUSH
54093: LD_INT 1
54095: ARRAY
54096: PPUSH
54097: LD_INT 112
54099: PPUSH
54100: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
54104: LD_VAR 0 9
54108: PUSH
54109: LD_INT 1
54111: ARRAY
54112: PPUSH
54113: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
54117: LD_EXP 129
54121: PUSH
54122: LD_VAR 0 2
54126: ARRAY
54127: PUSH
54128: LD_EXP 129
54132: PUSH
54133: LD_VAR 0 2
54137: ARRAY
54138: PUSH
54139: LD_INT 1
54141: ARRAY
54142: PPUSH
54143: CALL_OW 314
54147: NOT
54148: AND
54149: PUSH
54150: LD_EXP 129
54154: PUSH
54155: LD_VAR 0 2
54159: ARRAY
54160: PUSH
54161: LD_INT 1
54163: ARRAY
54164: PPUSH
54165: CALL_OW 310
54169: NOT
54170: AND
54171: IFFALSE 54197
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
54173: LD_EXP 129
54177: PUSH
54178: LD_VAR 0 2
54182: ARRAY
54183: PUSH
54184: LD_INT 1
54186: ARRAY
54187: PPUSH
54188: LD_VAR 0 3
54192: PPUSH
54193: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
54197: LD_EXP 129
54201: PUSH
54202: LD_VAR 0 2
54206: ARRAY
54207: PUSH
54208: LD_INT 1
54210: ARRAY
54211: PPUSH
54212: CALL_OW 310
54216: PUSH
54217: LD_EXP 129
54221: PUSH
54222: LD_VAR 0 2
54226: ARRAY
54227: PUSH
54228: LD_INT 1
54230: ARRAY
54231: PPUSH
54232: CALL_OW 310
54236: PPUSH
54237: CALL_OW 461
54241: PUSH
54242: LD_INT 3
54244: NONEQUAL
54245: AND
54246: IFFALSE 54267
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
54248: LD_EXP 129
54252: PUSH
54253: LD_VAR 0 2
54257: ARRAY
54258: PUSH
54259: LD_INT 1
54261: ARRAY
54262: PPUSH
54263: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
54267: LD_VAR 0 3
54271: PPUSH
54272: CALL_OW 461
54276: PUSH
54277: LD_INT 6
54279: EQUAL
54280: PUSH
54281: LD_VAR 0 6
54285: PUSH
54286: LD_INT 1
54288: GREATER
54289: AND
54290: IFFALSE 54442
// begin sci := [ ] ;
54292: LD_ADDR_VAR 0 8
54296: PUSH
54297: EMPTY
54298: ST_TO_ADDR
// for x in ( tmp diff j ) do
54299: LD_ADDR_VAR 0 7
54303: PUSH
54304: LD_VAR 0 6
54308: PUSH
54309: LD_VAR 0 3
54313: DIFF
54314: PUSH
54315: FOR_IN
54316: IFFALSE 54368
// begin if sci = 6 then
54318: LD_VAR 0 8
54322: PUSH
54323: LD_INT 6
54325: EQUAL
54326: IFFALSE 54330
// break ;
54328: GO 54368
// if BuildingStatus ( x ) = bs_idle then
54330: LD_VAR 0 7
54334: PPUSH
54335: CALL_OW 461
54339: PUSH
54340: LD_INT 2
54342: EQUAL
54343: IFFALSE 54366
// sci := sci ^ UnitsInside ( x ) ;
54345: LD_ADDR_VAR 0 8
54349: PUSH
54350: LD_VAR 0 8
54354: PUSH
54355: LD_VAR 0 7
54359: PPUSH
54360: CALL_OW 313
54364: ADD
54365: ST_TO_ADDR
// end ;
54366: GO 54315
54368: POP
54369: POP
// if not sci then
54370: LD_VAR 0 8
54374: NOT
54375: IFFALSE 54379
// continue ;
54377: GO 53424
// for x in sci do
54379: LD_ADDR_VAR 0 7
54383: PUSH
54384: LD_VAR 0 8
54388: PUSH
54389: FOR_IN
54390: IFFALSE 54440
// if IsInUnit ( x ) and not HasTask ( x ) then
54392: LD_VAR 0 7
54396: PPUSH
54397: CALL_OW 310
54401: PUSH
54402: LD_VAR 0 7
54406: PPUSH
54407: CALL_OW 314
54411: NOT
54412: AND
54413: IFFALSE 54438
// begin ComExitBuilding ( x ) ;
54415: LD_VAR 0 7
54419: PPUSH
54420: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
54424: LD_VAR 0 7
54428: PPUSH
54429: LD_VAR 0 3
54433: PPUSH
54434: CALL_OW 180
// end ;
54438: GO 54389
54440: POP
54441: POP
// end ; end ;
54442: GO 53424
54444: POP
54445: POP
// end ;
54446: GO 53378
54448: POP
54449: POP
// end ;
54450: LD_VAR 0 1
54454: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
54455: LD_INT 0
54457: PPUSH
54458: PPUSH
// if not mc_bases then
54459: LD_EXP 99
54463: NOT
54464: IFFALSE 54468
// exit ;
54466: GO 54549
// for i = 1 to mc_bases do
54468: LD_ADDR_VAR 0 2
54472: PUSH
54473: DOUBLE
54474: LD_INT 1
54476: DEC
54477: ST_TO_ADDR
54478: LD_EXP 99
54482: PUSH
54483: FOR_TO
54484: IFFALSE 54547
// if mc_mines [ i ] and mc_miners [ i ] then
54486: LD_EXP 112
54490: PUSH
54491: LD_VAR 0 2
54495: ARRAY
54496: PUSH
54497: LD_EXP 113
54501: PUSH
54502: LD_VAR 0 2
54506: ARRAY
54507: AND
54508: IFFALSE 54545
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
54510: LD_EXP 113
54514: PUSH
54515: LD_VAR 0 2
54519: ARRAY
54520: PUSH
54521: LD_INT 1
54523: ARRAY
54524: PPUSH
54525: CALL_OW 255
54529: PPUSH
54530: LD_EXP 112
54534: PUSH
54535: LD_VAR 0 2
54539: ARRAY
54540: PPUSH
54541: CALL 69173 0 2
54545: GO 54483
54547: POP
54548: POP
// end ;
54549: LD_VAR 0 1
54553: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
54554: LD_INT 0
54556: PPUSH
54557: PPUSH
54558: PPUSH
54559: PPUSH
54560: PPUSH
54561: PPUSH
54562: PPUSH
54563: PPUSH
// if not mc_bases or not mc_parking then
54564: LD_EXP 99
54568: NOT
54569: PUSH
54570: LD_EXP 123
54574: NOT
54575: OR
54576: IFFALSE 54580
// exit ;
54578: GO 55318
// for i = 1 to mc_bases do
54580: LD_ADDR_VAR 0 2
54584: PUSH
54585: DOUBLE
54586: LD_INT 1
54588: DEC
54589: ST_TO_ADDR
54590: LD_EXP 99
54594: PUSH
54595: FOR_TO
54596: IFFALSE 55316
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
54598: LD_EXP 99
54602: PUSH
54603: LD_VAR 0 2
54607: ARRAY
54608: NOT
54609: PUSH
54610: LD_EXP 123
54614: PUSH
54615: LD_VAR 0 2
54619: ARRAY
54620: NOT
54621: OR
54622: IFFALSE 54626
// continue ;
54624: GO 54595
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
54626: LD_ADDR_VAR 0 5
54630: PUSH
54631: LD_EXP 99
54635: PUSH
54636: LD_VAR 0 2
54640: ARRAY
54641: PUSH
54642: LD_INT 1
54644: ARRAY
54645: PPUSH
54646: CALL_OW 255
54650: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54651: LD_ADDR_VAR 0 6
54655: PUSH
54656: LD_EXP 99
54660: PUSH
54661: LD_VAR 0 2
54665: ARRAY
54666: PPUSH
54667: LD_INT 30
54669: PUSH
54670: LD_INT 3
54672: PUSH
54673: EMPTY
54674: LIST
54675: LIST
54676: PPUSH
54677: CALL_OW 72
54681: ST_TO_ADDR
// if not fac then
54682: LD_VAR 0 6
54686: NOT
54687: IFFALSE 54738
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54689: LD_ADDR_VAR 0 6
54693: PUSH
54694: LD_EXP 99
54698: PUSH
54699: LD_VAR 0 2
54703: ARRAY
54704: PPUSH
54705: LD_INT 2
54707: PUSH
54708: LD_INT 30
54710: PUSH
54711: LD_INT 0
54713: PUSH
54714: EMPTY
54715: LIST
54716: LIST
54717: PUSH
54718: LD_INT 30
54720: PUSH
54721: LD_INT 1
54723: PUSH
54724: EMPTY
54725: LIST
54726: LIST
54727: PUSH
54728: EMPTY
54729: LIST
54730: LIST
54731: LIST
54732: PPUSH
54733: CALL_OW 72
54737: ST_TO_ADDR
// if not fac then
54738: LD_VAR 0 6
54742: NOT
54743: IFFALSE 54747
// continue ;
54745: GO 54595
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
54747: LD_ADDR_VAR 0 7
54751: PUSH
54752: LD_EXP 123
54756: PUSH
54757: LD_VAR 0 2
54761: ARRAY
54762: PPUSH
54763: LD_INT 22
54765: PUSH
54766: LD_VAR 0 5
54770: PUSH
54771: EMPTY
54772: LIST
54773: LIST
54774: PUSH
54775: LD_INT 21
54777: PUSH
54778: LD_INT 2
54780: PUSH
54781: EMPTY
54782: LIST
54783: LIST
54784: PUSH
54785: LD_INT 3
54787: PUSH
54788: LD_INT 60
54790: PUSH
54791: EMPTY
54792: LIST
54793: PUSH
54794: EMPTY
54795: LIST
54796: LIST
54797: PUSH
54798: LD_INT 3
54800: PUSH
54801: LD_INT 24
54803: PUSH
54804: LD_INT 1000
54806: PUSH
54807: EMPTY
54808: LIST
54809: LIST
54810: PUSH
54811: EMPTY
54812: LIST
54813: LIST
54814: PUSH
54815: EMPTY
54816: LIST
54817: LIST
54818: LIST
54819: LIST
54820: PPUSH
54821: CALL_OW 70
54825: ST_TO_ADDR
// for j in fac do
54826: LD_ADDR_VAR 0 3
54830: PUSH
54831: LD_VAR 0 6
54835: PUSH
54836: FOR_IN
54837: IFFALSE 54932
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
54839: LD_ADDR_VAR 0 7
54843: PUSH
54844: LD_VAR 0 7
54848: PUSH
54849: LD_INT 22
54851: PUSH
54852: LD_VAR 0 5
54856: PUSH
54857: EMPTY
54858: LIST
54859: LIST
54860: PUSH
54861: LD_INT 91
54863: PUSH
54864: LD_VAR 0 3
54868: PUSH
54869: LD_INT 15
54871: PUSH
54872: EMPTY
54873: LIST
54874: LIST
54875: LIST
54876: PUSH
54877: LD_INT 21
54879: PUSH
54880: LD_INT 2
54882: PUSH
54883: EMPTY
54884: LIST
54885: LIST
54886: PUSH
54887: LD_INT 3
54889: PUSH
54890: LD_INT 60
54892: PUSH
54893: EMPTY
54894: LIST
54895: PUSH
54896: EMPTY
54897: LIST
54898: LIST
54899: PUSH
54900: LD_INT 3
54902: PUSH
54903: LD_INT 24
54905: PUSH
54906: LD_INT 1000
54908: PUSH
54909: EMPTY
54910: LIST
54911: LIST
54912: PUSH
54913: EMPTY
54914: LIST
54915: LIST
54916: PUSH
54917: EMPTY
54918: LIST
54919: LIST
54920: LIST
54921: LIST
54922: LIST
54923: PPUSH
54924: CALL_OW 69
54928: UNION
54929: ST_TO_ADDR
54930: GO 54836
54932: POP
54933: POP
// if not vehs then
54934: LD_VAR 0 7
54938: NOT
54939: IFFALSE 54965
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
54941: LD_ADDR_EXP 111
54945: PUSH
54946: LD_EXP 111
54950: PPUSH
54951: LD_VAR 0 2
54955: PPUSH
54956: EMPTY
54957: PPUSH
54958: CALL_OW 1
54962: ST_TO_ADDR
// continue ;
54963: GO 54595
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54965: LD_ADDR_VAR 0 8
54969: PUSH
54970: LD_EXP 99
54974: PUSH
54975: LD_VAR 0 2
54979: ARRAY
54980: PPUSH
54981: LD_INT 30
54983: PUSH
54984: LD_INT 3
54986: PUSH
54987: EMPTY
54988: LIST
54989: LIST
54990: PPUSH
54991: CALL_OW 72
54995: ST_TO_ADDR
// if tmp then
54996: LD_VAR 0 8
55000: IFFALSE 55103
// begin for j in tmp do
55002: LD_ADDR_VAR 0 3
55006: PUSH
55007: LD_VAR 0 8
55011: PUSH
55012: FOR_IN
55013: IFFALSE 55101
// for k in UnitsInside ( j ) do
55015: LD_ADDR_VAR 0 4
55019: PUSH
55020: LD_VAR 0 3
55024: PPUSH
55025: CALL_OW 313
55029: PUSH
55030: FOR_IN
55031: IFFALSE 55097
// if k then
55033: LD_VAR 0 4
55037: IFFALSE 55095
// if not k in mc_repair_vehicle [ i ] then
55039: LD_VAR 0 4
55043: PUSH
55044: LD_EXP 111
55048: PUSH
55049: LD_VAR 0 2
55053: ARRAY
55054: IN
55055: NOT
55056: IFFALSE 55095
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
55058: LD_ADDR_EXP 111
55062: PUSH
55063: LD_EXP 111
55067: PPUSH
55068: LD_VAR 0 2
55072: PPUSH
55073: LD_EXP 111
55077: PUSH
55078: LD_VAR 0 2
55082: ARRAY
55083: PUSH
55084: LD_VAR 0 4
55088: UNION
55089: PPUSH
55090: CALL_OW 1
55094: ST_TO_ADDR
55095: GO 55030
55097: POP
55098: POP
55099: GO 55012
55101: POP
55102: POP
// end ; if not mc_repair_vehicle [ i ] then
55103: LD_EXP 111
55107: PUSH
55108: LD_VAR 0 2
55112: ARRAY
55113: NOT
55114: IFFALSE 55118
// continue ;
55116: GO 54595
// for j in mc_repair_vehicle [ i ] do
55118: LD_ADDR_VAR 0 3
55122: PUSH
55123: LD_EXP 111
55127: PUSH
55128: LD_VAR 0 2
55132: ARRAY
55133: PUSH
55134: FOR_IN
55135: IFFALSE 55312
// begin if GetClass ( j ) <> 3 then
55137: LD_VAR 0 3
55141: PPUSH
55142: CALL_OW 257
55146: PUSH
55147: LD_INT 3
55149: NONEQUAL
55150: IFFALSE 55191
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
55152: LD_ADDR_EXP 111
55156: PUSH
55157: LD_EXP 111
55161: PPUSH
55162: LD_VAR 0 2
55166: PPUSH
55167: LD_EXP 111
55171: PUSH
55172: LD_VAR 0 2
55176: ARRAY
55177: PUSH
55178: LD_VAR 0 3
55182: DIFF
55183: PPUSH
55184: CALL_OW 1
55188: ST_TO_ADDR
// continue ;
55189: GO 55134
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
55191: LD_VAR 0 3
55195: PPUSH
55196: CALL_OW 311
55200: NOT
55201: PUSH
55202: LD_VAR 0 3
55206: PUSH
55207: LD_EXP 102
55211: PUSH
55212: LD_VAR 0 2
55216: ARRAY
55217: PUSH
55218: LD_INT 1
55220: ARRAY
55221: IN
55222: NOT
55223: AND
55224: PUSH
55225: LD_VAR 0 3
55229: PUSH
55230: LD_EXP 102
55234: PUSH
55235: LD_VAR 0 2
55239: ARRAY
55240: PUSH
55241: LD_INT 2
55243: ARRAY
55244: IN
55245: NOT
55246: AND
55247: IFFALSE 55310
// begin if IsInUnit ( j ) then
55249: LD_VAR 0 3
55253: PPUSH
55254: CALL_OW 310
55258: IFFALSE 55271
// ComExitBuilding ( j ) else
55260: LD_VAR 0 3
55264: PPUSH
55265: CALL_OW 122
55269: GO 55310
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
55271: LD_VAR 0 3
55275: PPUSH
55276: LD_VAR 0 7
55280: PUSH
55281: LD_INT 1
55283: ARRAY
55284: PPUSH
55285: CALL 106748 0 2
55289: NOT
55290: IFFALSE 55310
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
55292: LD_VAR 0 3
55296: PPUSH
55297: LD_VAR 0 7
55301: PUSH
55302: LD_INT 1
55304: ARRAY
55305: PPUSH
55306: CALL_OW 129
// end ; end ;
55310: GO 55134
55312: POP
55313: POP
// end ;
55314: GO 54595
55316: POP
55317: POP
// end ;
55318: LD_VAR 0 1
55322: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
55323: LD_INT 0
55325: PPUSH
55326: PPUSH
55327: PPUSH
55328: PPUSH
55329: PPUSH
55330: PPUSH
55331: PPUSH
55332: PPUSH
55333: PPUSH
55334: PPUSH
55335: PPUSH
// if not mc_bases then
55336: LD_EXP 99
55340: NOT
55341: IFFALSE 55345
// exit ;
55343: GO 56147
// for i = 1 to mc_bases do
55345: LD_ADDR_VAR 0 2
55349: PUSH
55350: DOUBLE
55351: LD_INT 1
55353: DEC
55354: ST_TO_ADDR
55355: LD_EXP 99
55359: PUSH
55360: FOR_TO
55361: IFFALSE 56145
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
55363: LD_EXP 127
55367: PUSH
55368: LD_VAR 0 2
55372: ARRAY
55373: NOT
55374: PUSH
55375: LD_EXP 102
55379: PUSH
55380: LD_VAR 0 2
55384: ARRAY
55385: PUSH
55386: LD_INT 1
55388: ARRAY
55389: OR
55390: PUSH
55391: LD_EXP 102
55395: PUSH
55396: LD_VAR 0 2
55400: ARRAY
55401: PUSH
55402: LD_INT 2
55404: ARRAY
55405: OR
55406: PUSH
55407: LD_EXP 125
55411: PUSH
55412: LD_VAR 0 2
55416: ARRAY
55417: PPUSH
55418: LD_INT 1
55420: PPUSH
55421: CALL_OW 325
55425: NOT
55426: OR
55427: PUSH
55428: LD_EXP 122
55432: PUSH
55433: LD_VAR 0 2
55437: ARRAY
55438: OR
55439: IFFALSE 55443
// continue ;
55441: GO 55360
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
55443: LD_ADDR_VAR 0 8
55447: PUSH
55448: LD_EXP 99
55452: PUSH
55453: LD_VAR 0 2
55457: ARRAY
55458: PPUSH
55459: LD_INT 25
55461: PUSH
55462: LD_INT 4
55464: PUSH
55465: EMPTY
55466: LIST
55467: LIST
55468: PUSH
55469: LD_INT 50
55471: PUSH
55472: EMPTY
55473: LIST
55474: PUSH
55475: LD_INT 3
55477: PUSH
55478: LD_INT 60
55480: PUSH
55481: EMPTY
55482: LIST
55483: PUSH
55484: EMPTY
55485: LIST
55486: LIST
55487: PUSH
55488: EMPTY
55489: LIST
55490: LIST
55491: LIST
55492: PPUSH
55493: CALL_OW 72
55497: PUSH
55498: LD_EXP 103
55502: PUSH
55503: LD_VAR 0 2
55507: ARRAY
55508: DIFF
55509: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
55510: LD_ADDR_VAR 0 9
55514: PUSH
55515: LD_EXP 99
55519: PUSH
55520: LD_VAR 0 2
55524: ARRAY
55525: PPUSH
55526: LD_INT 2
55528: PUSH
55529: LD_INT 30
55531: PUSH
55532: LD_INT 0
55534: PUSH
55535: EMPTY
55536: LIST
55537: LIST
55538: PUSH
55539: LD_INT 30
55541: PUSH
55542: LD_INT 1
55544: PUSH
55545: EMPTY
55546: LIST
55547: LIST
55548: PUSH
55549: EMPTY
55550: LIST
55551: LIST
55552: LIST
55553: PPUSH
55554: CALL_OW 72
55558: ST_TO_ADDR
// if not tmp or not dep then
55559: LD_VAR 0 8
55563: NOT
55564: PUSH
55565: LD_VAR 0 9
55569: NOT
55570: OR
55571: IFFALSE 55575
// continue ;
55573: GO 55360
// side := GetSide ( tmp [ 1 ] ) ;
55575: LD_ADDR_VAR 0 11
55579: PUSH
55580: LD_VAR 0 8
55584: PUSH
55585: LD_INT 1
55587: ARRAY
55588: PPUSH
55589: CALL_OW 255
55593: ST_TO_ADDR
// dep := dep [ 1 ] ;
55594: LD_ADDR_VAR 0 9
55598: PUSH
55599: LD_VAR 0 9
55603: PUSH
55604: LD_INT 1
55606: ARRAY
55607: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
55608: LD_ADDR_VAR 0 7
55612: PUSH
55613: LD_EXP 127
55617: PUSH
55618: LD_VAR 0 2
55622: ARRAY
55623: PPUSH
55624: LD_INT 22
55626: PUSH
55627: LD_INT 0
55629: PUSH
55630: EMPTY
55631: LIST
55632: LIST
55633: PUSH
55634: LD_INT 25
55636: PUSH
55637: LD_INT 12
55639: PUSH
55640: EMPTY
55641: LIST
55642: LIST
55643: PUSH
55644: EMPTY
55645: LIST
55646: LIST
55647: PPUSH
55648: CALL_OW 70
55652: PUSH
55653: LD_INT 22
55655: PUSH
55656: LD_INT 0
55658: PUSH
55659: EMPTY
55660: LIST
55661: LIST
55662: PUSH
55663: LD_INT 25
55665: PUSH
55666: LD_INT 12
55668: PUSH
55669: EMPTY
55670: LIST
55671: LIST
55672: PUSH
55673: LD_INT 91
55675: PUSH
55676: LD_VAR 0 9
55680: PUSH
55681: LD_INT 20
55683: PUSH
55684: EMPTY
55685: LIST
55686: LIST
55687: LIST
55688: PUSH
55689: EMPTY
55690: LIST
55691: LIST
55692: LIST
55693: PPUSH
55694: CALL_OW 69
55698: UNION
55699: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
55700: LD_ADDR_VAR 0 10
55704: PUSH
55705: LD_EXP 127
55709: PUSH
55710: LD_VAR 0 2
55714: ARRAY
55715: PPUSH
55716: LD_INT 81
55718: PUSH
55719: LD_VAR 0 11
55723: PUSH
55724: EMPTY
55725: LIST
55726: LIST
55727: PPUSH
55728: CALL_OW 70
55732: ST_TO_ADDR
// if not apes or danger_at_area then
55733: LD_VAR 0 7
55737: NOT
55738: PUSH
55739: LD_VAR 0 10
55743: OR
55744: IFFALSE 55794
// begin if mc_taming [ i ] then
55746: LD_EXP 130
55750: PUSH
55751: LD_VAR 0 2
55755: ARRAY
55756: IFFALSE 55792
// begin MC_Reset ( i , 121 ) ;
55758: LD_VAR 0 2
55762: PPUSH
55763: LD_INT 121
55765: PPUSH
55766: CALL 40731 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
55770: LD_ADDR_EXP 130
55774: PUSH
55775: LD_EXP 130
55779: PPUSH
55780: LD_VAR 0 2
55784: PPUSH
55785: EMPTY
55786: PPUSH
55787: CALL_OW 1
55791: ST_TO_ADDR
// end ; continue ;
55792: GO 55360
// end ; for j in tmp do
55794: LD_ADDR_VAR 0 3
55798: PUSH
55799: LD_VAR 0 8
55803: PUSH
55804: FOR_IN
55805: IFFALSE 56141
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
55807: LD_VAR 0 3
55811: PUSH
55812: LD_EXP 130
55816: PUSH
55817: LD_VAR 0 2
55821: ARRAY
55822: IN
55823: NOT
55824: PUSH
55825: LD_EXP 130
55829: PUSH
55830: LD_VAR 0 2
55834: ARRAY
55835: PUSH
55836: LD_INT 3
55838: LESS
55839: AND
55840: IFFALSE 55898
// begin SetTag ( j , 121 ) ;
55842: LD_VAR 0 3
55846: PPUSH
55847: LD_INT 121
55849: PPUSH
55850: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
55854: LD_ADDR_EXP 130
55858: PUSH
55859: LD_EXP 130
55863: PPUSH
55864: LD_VAR 0 2
55868: PUSH
55869: LD_EXP 130
55873: PUSH
55874: LD_VAR 0 2
55878: ARRAY
55879: PUSH
55880: LD_INT 1
55882: PLUS
55883: PUSH
55884: EMPTY
55885: LIST
55886: LIST
55887: PPUSH
55888: LD_VAR 0 3
55892: PPUSH
55893: CALL 72371 0 3
55897: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
55898: LD_VAR 0 3
55902: PUSH
55903: LD_EXP 130
55907: PUSH
55908: LD_VAR 0 2
55912: ARRAY
55913: IN
55914: IFFALSE 56139
// begin if GetClass ( j ) <> 4 then
55916: LD_VAR 0 3
55920: PPUSH
55921: CALL_OW 257
55925: PUSH
55926: LD_INT 4
55928: NONEQUAL
55929: IFFALSE 55982
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
55931: LD_ADDR_EXP 130
55935: PUSH
55936: LD_EXP 130
55940: PPUSH
55941: LD_VAR 0 2
55945: PPUSH
55946: LD_EXP 130
55950: PUSH
55951: LD_VAR 0 2
55955: ARRAY
55956: PUSH
55957: LD_VAR 0 3
55961: DIFF
55962: PPUSH
55963: CALL_OW 1
55967: ST_TO_ADDR
// SetTag ( j , 0 ) ;
55968: LD_VAR 0 3
55972: PPUSH
55973: LD_INT 0
55975: PPUSH
55976: CALL_OW 109
// continue ;
55980: GO 55804
// end ; if IsInUnit ( j ) then
55982: LD_VAR 0 3
55986: PPUSH
55987: CALL_OW 310
55991: IFFALSE 56002
// ComExitBuilding ( j ) ;
55993: LD_VAR 0 3
55997: PPUSH
55998: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
56002: LD_ADDR_VAR 0 6
56006: PUSH
56007: LD_VAR 0 7
56011: PPUSH
56012: LD_VAR 0 3
56016: PPUSH
56017: CALL_OW 74
56021: ST_TO_ADDR
// if not ape then
56022: LD_VAR 0 6
56026: NOT
56027: IFFALSE 56031
// break ;
56029: GO 56141
// x := GetX ( ape ) ;
56031: LD_ADDR_VAR 0 4
56035: PUSH
56036: LD_VAR 0 6
56040: PPUSH
56041: CALL_OW 250
56045: ST_TO_ADDR
// y := GetY ( ape ) ;
56046: LD_ADDR_VAR 0 5
56050: PUSH
56051: LD_VAR 0 6
56055: PPUSH
56056: CALL_OW 251
56060: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
56061: LD_VAR 0 4
56065: PPUSH
56066: LD_VAR 0 5
56070: PPUSH
56071: CALL_OW 488
56075: NOT
56076: PUSH
56077: LD_VAR 0 11
56081: PPUSH
56082: LD_VAR 0 4
56086: PPUSH
56087: LD_VAR 0 5
56091: PPUSH
56092: LD_INT 20
56094: PPUSH
56095: CALL 73267 0 4
56099: PUSH
56100: LD_INT 4
56102: ARRAY
56103: OR
56104: IFFALSE 56108
// break ;
56106: GO 56141
// if not HasTask ( j ) then
56108: LD_VAR 0 3
56112: PPUSH
56113: CALL_OW 314
56117: NOT
56118: IFFALSE 56139
// ComTameXY ( j , x , y ) ;
56120: LD_VAR 0 3
56124: PPUSH
56125: LD_VAR 0 4
56129: PPUSH
56130: LD_VAR 0 5
56134: PPUSH
56135: CALL_OW 131
// end ; end ;
56139: GO 55804
56141: POP
56142: POP
// end ;
56143: GO 55360
56145: POP
56146: POP
// end ;
56147: LD_VAR 0 1
56151: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
56152: LD_INT 0
56154: PPUSH
56155: PPUSH
56156: PPUSH
56157: PPUSH
56158: PPUSH
56159: PPUSH
56160: PPUSH
56161: PPUSH
// if not mc_bases then
56162: LD_EXP 99
56166: NOT
56167: IFFALSE 56171
// exit ;
56169: GO 56797
// for i = 1 to mc_bases do
56171: LD_ADDR_VAR 0 2
56175: PUSH
56176: DOUBLE
56177: LD_INT 1
56179: DEC
56180: ST_TO_ADDR
56181: LD_EXP 99
56185: PUSH
56186: FOR_TO
56187: IFFALSE 56795
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
56189: LD_EXP 128
56193: PUSH
56194: LD_VAR 0 2
56198: ARRAY
56199: NOT
56200: PUSH
56201: LD_EXP 128
56205: PUSH
56206: LD_VAR 0 2
56210: ARRAY
56211: PPUSH
56212: LD_INT 25
56214: PUSH
56215: LD_INT 12
56217: PUSH
56218: EMPTY
56219: LIST
56220: LIST
56221: PPUSH
56222: CALL_OW 72
56226: NOT
56227: OR
56228: IFFALSE 56232
// continue ;
56230: GO 56186
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
56232: LD_ADDR_VAR 0 5
56236: PUSH
56237: LD_EXP 128
56241: PUSH
56242: LD_VAR 0 2
56246: ARRAY
56247: PUSH
56248: LD_INT 1
56250: ARRAY
56251: PPUSH
56252: CALL_OW 255
56256: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
56257: LD_VAR 0 5
56261: PPUSH
56262: LD_INT 2
56264: PPUSH
56265: CALL_OW 325
56269: IFFALSE 56522
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
56271: LD_ADDR_VAR 0 4
56275: PUSH
56276: LD_EXP 128
56280: PUSH
56281: LD_VAR 0 2
56285: ARRAY
56286: PPUSH
56287: LD_INT 25
56289: PUSH
56290: LD_INT 16
56292: PUSH
56293: EMPTY
56294: LIST
56295: LIST
56296: PPUSH
56297: CALL_OW 72
56301: ST_TO_ADDR
// if tmp < 6 then
56302: LD_VAR 0 4
56306: PUSH
56307: LD_INT 6
56309: LESS
56310: IFFALSE 56522
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56312: LD_ADDR_VAR 0 6
56316: PUSH
56317: LD_EXP 99
56321: PUSH
56322: LD_VAR 0 2
56326: ARRAY
56327: PPUSH
56328: LD_INT 2
56330: PUSH
56331: LD_INT 30
56333: PUSH
56334: LD_INT 0
56336: PUSH
56337: EMPTY
56338: LIST
56339: LIST
56340: PUSH
56341: LD_INT 30
56343: PUSH
56344: LD_INT 1
56346: PUSH
56347: EMPTY
56348: LIST
56349: LIST
56350: PUSH
56351: EMPTY
56352: LIST
56353: LIST
56354: LIST
56355: PPUSH
56356: CALL_OW 72
56360: ST_TO_ADDR
// if depot then
56361: LD_VAR 0 6
56365: IFFALSE 56522
// begin selected := 0 ;
56367: LD_ADDR_VAR 0 7
56371: PUSH
56372: LD_INT 0
56374: ST_TO_ADDR
// for j in depot do
56375: LD_ADDR_VAR 0 3
56379: PUSH
56380: LD_VAR 0 6
56384: PUSH
56385: FOR_IN
56386: IFFALSE 56417
// begin if UnitsInside ( j ) < 6 then
56388: LD_VAR 0 3
56392: PPUSH
56393: CALL_OW 313
56397: PUSH
56398: LD_INT 6
56400: LESS
56401: IFFALSE 56415
// begin selected := j ;
56403: LD_ADDR_VAR 0 7
56407: PUSH
56408: LD_VAR 0 3
56412: ST_TO_ADDR
// break ;
56413: GO 56417
// end ; end ;
56415: GO 56385
56417: POP
56418: POP
// if selected then
56419: LD_VAR 0 7
56423: IFFALSE 56522
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
56425: LD_ADDR_VAR 0 3
56429: PUSH
56430: LD_EXP 128
56434: PUSH
56435: LD_VAR 0 2
56439: ARRAY
56440: PPUSH
56441: LD_INT 25
56443: PUSH
56444: LD_INT 12
56446: PUSH
56447: EMPTY
56448: LIST
56449: LIST
56450: PPUSH
56451: CALL_OW 72
56455: PUSH
56456: FOR_IN
56457: IFFALSE 56520
// if not HasTask ( j ) then
56459: LD_VAR 0 3
56463: PPUSH
56464: CALL_OW 314
56468: NOT
56469: IFFALSE 56518
// begin if not IsInUnit ( j ) then
56471: LD_VAR 0 3
56475: PPUSH
56476: CALL_OW 310
56480: NOT
56481: IFFALSE 56497
// ComEnterUnit ( j , selected ) ;
56483: LD_VAR 0 3
56487: PPUSH
56488: LD_VAR 0 7
56492: PPUSH
56493: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
56497: LD_VAR 0 3
56501: PPUSH
56502: LD_INT 16
56504: PPUSH
56505: CALL_OW 183
// AddComExitBuilding ( j ) ;
56509: LD_VAR 0 3
56513: PPUSH
56514: CALL_OW 182
// end ;
56518: GO 56456
56520: POP
56521: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
56522: LD_VAR 0 5
56526: PPUSH
56527: LD_INT 11
56529: PPUSH
56530: CALL_OW 325
56534: IFFALSE 56793
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
56536: LD_ADDR_VAR 0 4
56540: PUSH
56541: LD_EXP 128
56545: PUSH
56546: LD_VAR 0 2
56550: ARRAY
56551: PPUSH
56552: LD_INT 25
56554: PUSH
56555: LD_INT 16
56557: PUSH
56558: EMPTY
56559: LIST
56560: LIST
56561: PPUSH
56562: CALL_OW 72
56566: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
56567: LD_VAR 0 4
56571: PUSH
56572: LD_INT 6
56574: GREATEREQUAL
56575: PUSH
56576: LD_VAR 0 5
56580: PPUSH
56581: LD_INT 2
56583: PPUSH
56584: CALL_OW 325
56588: NOT
56589: OR
56590: IFFALSE 56793
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56592: LD_ADDR_VAR 0 8
56596: PUSH
56597: LD_EXP 99
56601: PUSH
56602: LD_VAR 0 2
56606: ARRAY
56607: PPUSH
56608: LD_INT 2
56610: PUSH
56611: LD_INT 30
56613: PUSH
56614: LD_INT 4
56616: PUSH
56617: EMPTY
56618: LIST
56619: LIST
56620: PUSH
56621: LD_INT 30
56623: PUSH
56624: LD_INT 5
56626: PUSH
56627: EMPTY
56628: LIST
56629: LIST
56630: PUSH
56631: EMPTY
56632: LIST
56633: LIST
56634: LIST
56635: PPUSH
56636: CALL_OW 72
56640: ST_TO_ADDR
// if barracks then
56641: LD_VAR 0 8
56645: IFFALSE 56793
// begin selected := 0 ;
56647: LD_ADDR_VAR 0 7
56651: PUSH
56652: LD_INT 0
56654: ST_TO_ADDR
// for j in barracks do
56655: LD_ADDR_VAR 0 3
56659: PUSH
56660: LD_VAR 0 8
56664: PUSH
56665: FOR_IN
56666: IFFALSE 56697
// begin if UnitsInside ( j ) < 6 then
56668: LD_VAR 0 3
56672: PPUSH
56673: CALL_OW 313
56677: PUSH
56678: LD_INT 6
56680: LESS
56681: IFFALSE 56695
// begin selected := j ;
56683: LD_ADDR_VAR 0 7
56687: PUSH
56688: LD_VAR 0 3
56692: ST_TO_ADDR
// break ;
56693: GO 56697
// end ; end ;
56695: GO 56665
56697: POP
56698: POP
// if selected then
56699: LD_VAR 0 7
56703: IFFALSE 56793
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
56705: LD_ADDR_VAR 0 3
56709: PUSH
56710: LD_EXP 128
56714: PUSH
56715: LD_VAR 0 2
56719: ARRAY
56720: PPUSH
56721: LD_INT 25
56723: PUSH
56724: LD_INT 12
56726: PUSH
56727: EMPTY
56728: LIST
56729: LIST
56730: PPUSH
56731: CALL_OW 72
56735: PUSH
56736: FOR_IN
56737: IFFALSE 56791
// if not IsInUnit ( j ) and not HasTask ( j ) then
56739: LD_VAR 0 3
56743: PPUSH
56744: CALL_OW 310
56748: NOT
56749: PUSH
56750: LD_VAR 0 3
56754: PPUSH
56755: CALL_OW 314
56759: NOT
56760: AND
56761: IFFALSE 56789
// begin ComEnterUnit ( j , selected ) ;
56763: LD_VAR 0 3
56767: PPUSH
56768: LD_VAR 0 7
56772: PPUSH
56773: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
56777: LD_VAR 0 3
56781: PPUSH
56782: LD_INT 15
56784: PPUSH
56785: CALL_OW 183
// end ;
56789: GO 56736
56791: POP
56792: POP
// end ; end ; end ; end ; end ;
56793: GO 56186
56795: POP
56796: POP
// end ;
56797: LD_VAR 0 1
56801: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
56802: LD_INT 0
56804: PPUSH
56805: PPUSH
56806: PPUSH
56807: PPUSH
// if not mc_bases then
56808: LD_EXP 99
56812: NOT
56813: IFFALSE 56817
// exit ;
56815: GO 56995
// for i = 1 to mc_bases do
56817: LD_ADDR_VAR 0 2
56821: PUSH
56822: DOUBLE
56823: LD_INT 1
56825: DEC
56826: ST_TO_ADDR
56827: LD_EXP 99
56831: PUSH
56832: FOR_TO
56833: IFFALSE 56993
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
56835: LD_ADDR_VAR 0 4
56839: PUSH
56840: LD_EXP 99
56844: PUSH
56845: LD_VAR 0 2
56849: ARRAY
56850: PPUSH
56851: LD_INT 25
56853: PUSH
56854: LD_INT 9
56856: PUSH
56857: EMPTY
56858: LIST
56859: LIST
56860: PPUSH
56861: CALL_OW 72
56865: ST_TO_ADDR
// if not tmp then
56866: LD_VAR 0 4
56870: NOT
56871: IFFALSE 56875
// continue ;
56873: GO 56832
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
56875: LD_EXP 125
56879: PUSH
56880: LD_VAR 0 2
56884: ARRAY
56885: PPUSH
56886: LD_INT 29
56888: PPUSH
56889: CALL_OW 325
56893: NOT
56894: PUSH
56895: LD_EXP 125
56899: PUSH
56900: LD_VAR 0 2
56904: ARRAY
56905: PPUSH
56906: LD_INT 28
56908: PPUSH
56909: CALL_OW 325
56913: NOT
56914: AND
56915: IFFALSE 56919
// continue ;
56917: GO 56832
// for j in tmp do
56919: LD_ADDR_VAR 0 3
56923: PUSH
56924: LD_VAR 0 4
56928: PUSH
56929: FOR_IN
56930: IFFALSE 56989
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
56932: LD_VAR 0 3
56936: PUSH
56937: LD_EXP 102
56941: PUSH
56942: LD_VAR 0 2
56946: ARRAY
56947: PUSH
56948: LD_INT 1
56950: ARRAY
56951: IN
56952: NOT
56953: PUSH
56954: LD_VAR 0 3
56958: PUSH
56959: LD_EXP 102
56963: PUSH
56964: LD_VAR 0 2
56968: ARRAY
56969: PUSH
56970: LD_INT 2
56972: ARRAY
56973: IN
56974: NOT
56975: AND
56976: IFFALSE 56987
// ComSpaceTimeShoot ( j ) ;
56978: LD_VAR 0 3
56982: PPUSH
56983: CALL 68181 0 1
56987: GO 56929
56989: POP
56990: POP
// end ;
56991: GO 56832
56993: POP
56994: POP
// end ;
56995: LD_VAR 0 1
56999: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
57000: LD_INT 0
57002: PPUSH
57003: PPUSH
57004: PPUSH
57005: PPUSH
57006: PPUSH
57007: PPUSH
57008: PPUSH
57009: PPUSH
57010: PPUSH
// if not mc_bases then
57011: LD_EXP 99
57015: NOT
57016: IFFALSE 57020
// exit ;
57018: GO 57642
// for i = 1 to mc_bases do
57020: LD_ADDR_VAR 0 2
57024: PUSH
57025: DOUBLE
57026: LD_INT 1
57028: DEC
57029: ST_TO_ADDR
57030: LD_EXP 99
57034: PUSH
57035: FOR_TO
57036: IFFALSE 57640
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
57038: LD_EXP 134
57042: PUSH
57043: LD_VAR 0 2
57047: ARRAY
57048: NOT
57049: PUSH
57050: LD_INT 38
57052: PPUSH
57053: LD_EXP 125
57057: PUSH
57058: LD_VAR 0 2
57062: ARRAY
57063: PPUSH
57064: CALL_OW 321
57068: PUSH
57069: LD_INT 2
57071: NONEQUAL
57072: OR
57073: IFFALSE 57077
// continue ;
57075: GO 57035
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
57077: LD_ADDR_VAR 0 8
57081: PUSH
57082: LD_EXP 99
57086: PUSH
57087: LD_VAR 0 2
57091: ARRAY
57092: PPUSH
57093: LD_INT 30
57095: PUSH
57096: LD_INT 34
57098: PUSH
57099: EMPTY
57100: LIST
57101: LIST
57102: PPUSH
57103: CALL_OW 72
57107: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
57108: LD_ADDR_VAR 0 9
57112: PUSH
57113: LD_EXP 99
57117: PUSH
57118: LD_VAR 0 2
57122: ARRAY
57123: PPUSH
57124: LD_INT 25
57126: PUSH
57127: LD_INT 4
57129: PUSH
57130: EMPTY
57131: LIST
57132: LIST
57133: PPUSH
57134: CALL_OW 72
57138: PPUSH
57139: LD_INT 0
57141: PPUSH
57142: CALL 102257 0 2
57146: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
57147: LD_VAR 0 9
57151: NOT
57152: PUSH
57153: LD_VAR 0 8
57157: NOT
57158: OR
57159: PUSH
57160: LD_EXP 99
57164: PUSH
57165: LD_VAR 0 2
57169: ARRAY
57170: PPUSH
57171: LD_INT 124
57173: PPUSH
57174: CALL 102257 0 2
57178: OR
57179: IFFALSE 57183
// continue ;
57181: GO 57035
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
57183: LD_EXP 135
57187: PUSH
57188: LD_VAR 0 2
57192: ARRAY
57193: PUSH
57194: LD_EXP 134
57198: PUSH
57199: LD_VAR 0 2
57203: ARRAY
57204: LESS
57205: PUSH
57206: LD_EXP 135
57210: PUSH
57211: LD_VAR 0 2
57215: ARRAY
57216: PUSH
57217: LD_VAR 0 8
57221: LESS
57222: AND
57223: IFFALSE 57638
// begin tmp := sci [ 1 ] ;
57225: LD_ADDR_VAR 0 7
57229: PUSH
57230: LD_VAR 0 9
57234: PUSH
57235: LD_INT 1
57237: ARRAY
57238: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
57239: LD_VAR 0 7
57243: PPUSH
57244: LD_INT 124
57246: PPUSH
57247: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
57251: LD_ADDR_VAR 0 3
57255: PUSH
57256: DOUBLE
57257: LD_EXP 134
57261: PUSH
57262: LD_VAR 0 2
57266: ARRAY
57267: INC
57268: ST_TO_ADDR
57269: LD_EXP 134
57273: PUSH
57274: LD_VAR 0 2
57278: ARRAY
57279: PUSH
57280: FOR_DOWNTO
57281: IFFALSE 57624
// begin if IsInUnit ( tmp ) then
57283: LD_VAR 0 7
57287: PPUSH
57288: CALL_OW 310
57292: IFFALSE 57303
// ComExitBuilding ( tmp ) ;
57294: LD_VAR 0 7
57298: PPUSH
57299: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
57303: LD_INT 35
57305: PPUSH
57306: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
57310: LD_VAR 0 7
57314: PPUSH
57315: CALL_OW 310
57319: NOT
57320: PUSH
57321: LD_VAR 0 7
57325: PPUSH
57326: CALL_OW 314
57330: NOT
57331: AND
57332: IFFALSE 57303
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
57334: LD_ADDR_VAR 0 6
57338: PUSH
57339: LD_VAR 0 7
57343: PPUSH
57344: CALL_OW 250
57348: PUSH
57349: LD_VAR 0 7
57353: PPUSH
57354: CALL_OW 251
57358: PUSH
57359: EMPTY
57360: LIST
57361: LIST
57362: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
57363: LD_INT 35
57365: PPUSH
57366: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
57370: LD_ADDR_VAR 0 4
57374: PUSH
57375: LD_EXP 134
57379: PUSH
57380: LD_VAR 0 2
57384: ARRAY
57385: PUSH
57386: LD_VAR 0 3
57390: ARRAY
57391: PUSH
57392: LD_INT 1
57394: ARRAY
57395: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
57396: LD_ADDR_VAR 0 5
57400: PUSH
57401: LD_EXP 134
57405: PUSH
57406: LD_VAR 0 2
57410: ARRAY
57411: PUSH
57412: LD_VAR 0 3
57416: ARRAY
57417: PUSH
57418: LD_INT 2
57420: ARRAY
57421: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
57422: LD_VAR 0 7
57426: PPUSH
57427: LD_INT 10
57429: PPUSH
57430: CALL 74968 0 2
57434: PUSH
57435: LD_INT 4
57437: ARRAY
57438: IFFALSE 57476
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
57440: LD_VAR 0 7
57444: PPUSH
57445: LD_VAR 0 6
57449: PUSH
57450: LD_INT 1
57452: ARRAY
57453: PPUSH
57454: LD_VAR 0 6
57458: PUSH
57459: LD_INT 2
57461: ARRAY
57462: PPUSH
57463: CALL_OW 111
// wait ( 0 0$10 ) ;
57467: LD_INT 350
57469: PPUSH
57470: CALL_OW 67
// end else
57474: GO 57502
// begin ComMoveXY ( tmp , x , y ) ;
57476: LD_VAR 0 7
57480: PPUSH
57481: LD_VAR 0 4
57485: PPUSH
57486: LD_VAR 0 5
57490: PPUSH
57491: CALL_OW 111
// wait ( 0 0$3 ) ;
57495: LD_INT 105
57497: PPUSH
57498: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
57502: LD_VAR 0 7
57506: PPUSH
57507: LD_VAR 0 4
57511: PPUSH
57512: LD_VAR 0 5
57516: PPUSH
57517: CALL_OW 307
57521: IFFALSE 57363
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
57523: LD_VAR 0 7
57527: PPUSH
57528: LD_VAR 0 4
57532: PPUSH
57533: LD_VAR 0 5
57537: PPUSH
57538: LD_VAR 0 8
57542: PUSH
57543: LD_VAR 0 3
57547: ARRAY
57548: PPUSH
57549: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
57553: LD_INT 35
57555: PPUSH
57556: CALL_OW 67
// until not HasTask ( tmp ) ;
57560: LD_VAR 0 7
57564: PPUSH
57565: CALL_OW 314
57569: NOT
57570: IFFALSE 57553
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
57572: LD_ADDR_EXP 135
57576: PUSH
57577: LD_EXP 135
57581: PPUSH
57582: LD_VAR 0 2
57586: PUSH
57587: LD_EXP 135
57591: PUSH
57592: LD_VAR 0 2
57596: ARRAY
57597: PUSH
57598: LD_INT 1
57600: PLUS
57601: PUSH
57602: EMPTY
57603: LIST
57604: LIST
57605: PPUSH
57606: LD_VAR 0 8
57610: PUSH
57611: LD_VAR 0 3
57615: ARRAY
57616: PPUSH
57617: CALL 72371 0 3
57621: ST_TO_ADDR
// end ;
57622: GO 57280
57624: POP
57625: POP
// MC_Reset ( i , 124 ) ;
57626: LD_VAR 0 2
57630: PPUSH
57631: LD_INT 124
57633: PPUSH
57634: CALL 40731 0 2
// end ; end ;
57638: GO 57035
57640: POP
57641: POP
// end ;
57642: LD_VAR 0 1
57646: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
57647: LD_INT 0
57649: PPUSH
57650: PPUSH
57651: PPUSH
// if not mc_bases then
57652: LD_EXP 99
57656: NOT
57657: IFFALSE 57661
// exit ;
57659: GO 58267
// for i = 1 to mc_bases do
57661: LD_ADDR_VAR 0 2
57665: PUSH
57666: DOUBLE
57667: LD_INT 1
57669: DEC
57670: ST_TO_ADDR
57671: LD_EXP 99
57675: PUSH
57676: FOR_TO
57677: IFFALSE 58265
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
57679: LD_ADDR_VAR 0 3
57683: PUSH
57684: LD_EXP 99
57688: PUSH
57689: LD_VAR 0 2
57693: ARRAY
57694: PPUSH
57695: LD_INT 25
57697: PUSH
57698: LD_INT 4
57700: PUSH
57701: EMPTY
57702: LIST
57703: LIST
57704: PPUSH
57705: CALL_OW 72
57709: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
57710: LD_VAR 0 3
57714: NOT
57715: PUSH
57716: LD_EXP 136
57720: PUSH
57721: LD_VAR 0 2
57725: ARRAY
57726: NOT
57727: OR
57728: PUSH
57729: LD_EXP 99
57733: PUSH
57734: LD_VAR 0 2
57738: ARRAY
57739: PPUSH
57740: LD_INT 2
57742: PUSH
57743: LD_INT 30
57745: PUSH
57746: LD_INT 0
57748: PUSH
57749: EMPTY
57750: LIST
57751: LIST
57752: PUSH
57753: LD_INT 30
57755: PUSH
57756: LD_INT 1
57758: PUSH
57759: EMPTY
57760: LIST
57761: LIST
57762: PUSH
57763: EMPTY
57764: LIST
57765: LIST
57766: LIST
57767: PPUSH
57768: CALL_OW 72
57772: NOT
57773: OR
57774: IFFALSE 57824
// begin if mc_deposits_finder [ i ] then
57776: LD_EXP 137
57780: PUSH
57781: LD_VAR 0 2
57785: ARRAY
57786: IFFALSE 57822
// begin MC_Reset ( i , 125 ) ;
57788: LD_VAR 0 2
57792: PPUSH
57793: LD_INT 125
57795: PPUSH
57796: CALL 40731 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
57800: LD_ADDR_EXP 137
57804: PUSH
57805: LD_EXP 137
57809: PPUSH
57810: LD_VAR 0 2
57814: PPUSH
57815: EMPTY
57816: PPUSH
57817: CALL_OW 1
57821: ST_TO_ADDR
// end ; continue ;
57822: GO 57676
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
57824: LD_EXP 136
57828: PUSH
57829: LD_VAR 0 2
57833: ARRAY
57834: PUSH
57835: LD_INT 1
57837: ARRAY
57838: PUSH
57839: LD_INT 3
57841: ARRAY
57842: PUSH
57843: LD_INT 1
57845: EQUAL
57846: PUSH
57847: LD_INT 20
57849: PPUSH
57850: LD_EXP 125
57854: PUSH
57855: LD_VAR 0 2
57859: ARRAY
57860: PPUSH
57861: CALL_OW 321
57865: PUSH
57866: LD_INT 2
57868: NONEQUAL
57869: AND
57870: IFFALSE 57920
// begin if mc_deposits_finder [ i ] then
57872: LD_EXP 137
57876: PUSH
57877: LD_VAR 0 2
57881: ARRAY
57882: IFFALSE 57918
// begin MC_Reset ( i , 125 ) ;
57884: LD_VAR 0 2
57888: PPUSH
57889: LD_INT 125
57891: PPUSH
57892: CALL 40731 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
57896: LD_ADDR_EXP 137
57900: PUSH
57901: LD_EXP 137
57905: PPUSH
57906: LD_VAR 0 2
57910: PPUSH
57911: EMPTY
57912: PPUSH
57913: CALL_OW 1
57917: ST_TO_ADDR
// end ; continue ;
57918: GO 57676
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
57920: LD_EXP 136
57924: PUSH
57925: LD_VAR 0 2
57929: ARRAY
57930: PUSH
57931: LD_INT 1
57933: ARRAY
57934: PUSH
57935: LD_INT 1
57937: ARRAY
57938: PPUSH
57939: LD_EXP 136
57943: PUSH
57944: LD_VAR 0 2
57948: ARRAY
57949: PUSH
57950: LD_INT 1
57952: ARRAY
57953: PUSH
57954: LD_INT 2
57956: ARRAY
57957: PPUSH
57958: LD_EXP 125
57962: PUSH
57963: LD_VAR 0 2
57967: ARRAY
57968: PPUSH
57969: CALL_OW 440
57973: IFFALSE 58016
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
57975: LD_ADDR_EXP 136
57979: PUSH
57980: LD_EXP 136
57984: PPUSH
57985: LD_VAR 0 2
57989: PPUSH
57990: LD_EXP 136
57994: PUSH
57995: LD_VAR 0 2
57999: ARRAY
58000: PPUSH
58001: LD_INT 1
58003: PPUSH
58004: CALL_OW 3
58008: PPUSH
58009: CALL_OW 1
58013: ST_TO_ADDR
58014: GO 58263
// begin if not mc_deposits_finder [ i ] then
58016: LD_EXP 137
58020: PUSH
58021: LD_VAR 0 2
58025: ARRAY
58026: NOT
58027: IFFALSE 58079
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
58029: LD_ADDR_EXP 137
58033: PUSH
58034: LD_EXP 137
58038: PPUSH
58039: LD_VAR 0 2
58043: PPUSH
58044: LD_VAR 0 3
58048: PUSH
58049: LD_INT 1
58051: ARRAY
58052: PUSH
58053: EMPTY
58054: LIST
58055: PPUSH
58056: CALL_OW 1
58060: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
58061: LD_VAR 0 3
58065: PUSH
58066: LD_INT 1
58068: ARRAY
58069: PPUSH
58070: LD_INT 125
58072: PPUSH
58073: CALL_OW 109
// end else
58077: GO 58263
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
58079: LD_EXP 137
58083: PUSH
58084: LD_VAR 0 2
58088: ARRAY
58089: PUSH
58090: LD_INT 1
58092: ARRAY
58093: PPUSH
58094: CALL_OW 310
58098: IFFALSE 58121
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
58100: LD_EXP 137
58104: PUSH
58105: LD_VAR 0 2
58109: ARRAY
58110: PUSH
58111: LD_INT 1
58113: ARRAY
58114: PPUSH
58115: CALL_OW 122
58119: GO 58263
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
58121: LD_EXP 137
58125: PUSH
58126: LD_VAR 0 2
58130: ARRAY
58131: PUSH
58132: LD_INT 1
58134: ARRAY
58135: PPUSH
58136: CALL_OW 314
58140: NOT
58141: PUSH
58142: LD_EXP 137
58146: PUSH
58147: LD_VAR 0 2
58151: ARRAY
58152: PUSH
58153: LD_INT 1
58155: ARRAY
58156: PPUSH
58157: LD_EXP 136
58161: PUSH
58162: LD_VAR 0 2
58166: ARRAY
58167: PUSH
58168: LD_INT 1
58170: ARRAY
58171: PUSH
58172: LD_INT 1
58174: ARRAY
58175: PPUSH
58176: LD_EXP 136
58180: PUSH
58181: LD_VAR 0 2
58185: ARRAY
58186: PUSH
58187: LD_INT 1
58189: ARRAY
58190: PUSH
58191: LD_INT 2
58193: ARRAY
58194: PPUSH
58195: CALL_OW 297
58199: PUSH
58200: LD_INT 6
58202: GREATER
58203: AND
58204: IFFALSE 58263
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
58206: LD_EXP 137
58210: PUSH
58211: LD_VAR 0 2
58215: ARRAY
58216: PUSH
58217: LD_INT 1
58219: ARRAY
58220: PPUSH
58221: LD_EXP 136
58225: PUSH
58226: LD_VAR 0 2
58230: ARRAY
58231: PUSH
58232: LD_INT 1
58234: ARRAY
58235: PUSH
58236: LD_INT 1
58238: ARRAY
58239: PPUSH
58240: LD_EXP 136
58244: PUSH
58245: LD_VAR 0 2
58249: ARRAY
58250: PUSH
58251: LD_INT 1
58253: ARRAY
58254: PUSH
58255: LD_INT 2
58257: ARRAY
58258: PPUSH
58259: CALL_OW 111
// end ; end ; end ;
58263: GO 57676
58265: POP
58266: POP
// end ;
58267: LD_VAR 0 1
58271: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
58272: LD_INT 0
58274: PPUSH
58275: PPUSH
58276: PPUSH
58277: PPUSH
58278: PPUSH
58279: PPUSH
58280: PPUSH
58281: PPUSH
58282: PPUSH
58283: PPUSH
58284: PPUSH
// if not mc_bases then
58285: LD_EXP 99
58289: NOT
58290: IFFALSE 58294
// exit ;
58292: GO 59234
// for i = 1 to mc_bases do
58294: LD_ADDR_VAR 0 2
58298: PUSH
58299: DOUBLE
58300: LD_INT 1
58302: DEC
58303: ST_TO_ADDR
58304: LD_EXP 99
58308: PUSH
58309: FOR_TO
58310: IFFALSE 59232
// begin if not mc_bases [ i ] or mc_scan [ i ] then
58312: LD_EXP 99
58316: PUSH
58317: LD_VAR 0 2
58321: ARRAY
58322: NOT
58323: PUSH
58324: LD_EXP 122
58328: PUSH
58329: LD_VAR 0 2
58333: ARRAY
58334: OR
58335: IFFALSE 58339
// continue ;
58337: GO 58309
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
58339: LD_ADDR_VAR 0 7
58343: PUSH
58344: LD_EXP 99
58348: PUSH
58349: LD_VAR 0 2
58353: ARRAY
58354: PUSH
58355: LD_INT 1
58357: ARRAY
58358: PPUSH
58359: CALL_OW 248
58363: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
58364: LD_VAR 0 7
58368: PUSH
58369: LD_INT 3
58371: EQUAL
58372: PUSH
58373: LD_EXP 118
58377: PUSH
58378: LD_VAR 0 2
58382: ARRAY
58383: PUSH
58384: LD_EXP 121
58388: PUSH
58389: LD_VAR 0 2
58393: ARRAY
58394: UNION
58395: PPUSH
58396: LD_INT 33
58398: PUSH
58399: LD_INT 2
58401: PUSH
58402: EMPTY
58403: LIST
58404: LIST
58405: PPUSH
58406: CALL_OW 72
58410: NOT
58411: OR
58412: IFFALSE 58416
// continue ;
58414: GO 58309
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
58416: LD_ADDR_VAR 0 9
58420: PUSH
58421: LD_EXP 99
58425: PUSH
58426: LD_VAR 0 2
58430: ARRAY
58431: PPUSH
58432: LD_INT 30
58434: PUSH
58435: LD_INT 36
58437: PUSH
58438: EMPTY
58439: LIST
58440: LIST
58441: PPUSH
58442: CALL_OW 72
58446: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
58447: LD_ADDR_VAR 0 10
58451: PUSH
58452: LD_EXP 118
58456: PUSH
58457: LD_VAR 0 2
58461: ARRAY
58462: PPUSH
58463: LD_INT 34
58465: PUSH
58466: LD_INT 31
58468: PUSH
58469: EMPTY
58470: LIST
58471: LIST
58472: PPUSH
58473: CALL_OW 72
58477: ST_TO_ADDR
// if not cts and not mcts then
58478: LD_VAR 0 9
58482: NOT
58483: PUSH
58484: LD_VAR 0 10
58488: NOT
58489: AND
58490: IFFALSE 58494
// continue ;
58492: GO 58309
// x := cts ;
58494: LD_ADDR_VAR 0 11
58498: PUSH
58499: LD_VAR 0 9
58503: ST_TO_ADDR
// if not x then
58504: LD_VAR 0 11
58508: NOT
58509: IFFALSE 58521
// x := mcts ;
58511: LD_ADDR_VAR 0 11
58515: PUSH
58516: LD_VAR 0 10
58520: ST_TO_ADDR
// if not x then
58521: LD_VAR 0 11
58525: NOT
58526: IFFALSE 58530
// continue ;
58528: GO 58309
// if mc_remote_driver [ i ] then
58530: LD_EXP 139
58534: PUSH
58535: LD_VAR 0 2
58539: ARRAY
58540: IFFALSE 58927
// for j in mc_remote_driver [ i ] do
58542: LD_ADDR_VAR 0 3
58546: PUSH
58547: LD_EXP 139
58551: PUSH
58552: LD_VAR 0 2
58556: ARRAY
58557: PUSH
58558: FOR_IN
58559: IFFALSE 58925
// begin if GetClass ( j ) <> 3 then
58561: LD_VAR 0 3
58565: PPUSH
58566: CALL_OW 257
58570: PUSH
58571: LD_INT 3
58573: NONEQUAL
58574: IFFALSE 58627
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
58576: LD_ADDR_EXP 139
58580: PUSH
58581: LD_EXP 139
58585: PPUSH
58586: LD_VAR 0 2
58590: PPUSH
58591: LD_EXP 139
58595: PUSH
58596: LD_VAR 0 2
58600: ARRAY
58601: PUSH
58602: LD_VAR 0 3
58606: DIFF
58607: PPUSH
58608: CALL_OW 1
58612: ST_TO_ADDR
// SetTag ( j , 0 ) ;
58613: LD_VAR 0 3
58617: PPUSH
58618: LD_INT 0
58620: PPUSH
58621: CALL_OW 109
// continue ;
58625: GO 58558
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
58627: LD_EXP 118
58631: PUSH
58632: LD_VAR 0 2
58636: ARRAY
58637: PPUSH
58638: LD_INT 34
58640: PUSH
58641: LD_INT 31
58643: PUSH
58644: EMPTY
58645: LIST
58646: LIST
58647: PUSH
58648: LD_INT 58
58650: PUSH
58651: EMPTY
58652: LIST
58653: PUSH
58654: EMPTY
58655: LIST
58656: LIST
58657: PPUSH
58658: CALL_OW 72
58662: PUSH
58663: LD_VAR 0 3
58667: PPUSH
58668: CALL 102292 0 1
58672: NOT
58673: AND
58674: IFFALSE 58745
// begin if IsInUnit ( j ) then
58676: LD_VAR 0 3
58680: PPUSH
58681: CALL_OW 310
58685: IFFALSE 58696
// ComExitBuilding ( j ) ;
58687: LD_VAR 0 3
58691: PPUSH
58692: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
58696: LD_VAR 0 3
58700: PPUSH
58701: LD_EXP 118
58705: PUSH
58706: LD_VAR 0 2
58710: ARRAY
58711: PPUSH
58712: LD_INT 34
58714: PUSH
58715: LD_INT 31
58717: PUSH
58718: EMPTY
58719: LIST
58720: LIST
58721: PUSH
58722: LD_INT 58
58724: PUSH
58725: EMPTY
58726: LIST
58727: PUSH
58728: EMPTY
58729: LIST
58730: LIST
58731: PPUSH
58732: CALL_OW 72
58736: PUSH
58737: LD_INT 1
58739: ARRAY
58740: PPUSH
58741: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
58745: LD_VAR 0 3
58749: PPUSH
58750: CALL_OW 310
58754: NOT
58755: PUSH
58756: LD_VAR 0 3
58760: PPUSH
58761: CALL_OW 310
58765: PPUSH
58766: CALL_OW 266
58770: PUSH
58771: LD_INT 36
58773: NONEQUAL
58774: PUSH
58775: LD_VAR 0 3
58779: PPUSH
58780: CALL 102292 0 1
58784: NOT
58785: AND
58786: OR
58787: IFFALSE 58923
// begin if IsInUnit ( j ) then
58789: LD_VAR 0 3
58793: PPUSH
58794: CALL_OW 310
58798: IFFALSE 58809
// ComExitBuilding ( j ) ;
58800: LD_VAR 0 3
58804: PPUSH
58805: CALL_OW 122
// ct := 0 ;
58809: LD_ADDR_VAR 0 8
58813: PUSH
58814: LD_INT 0
58816: ST_TO_ADDR
// for k in x do
58817: LD_ADDR_VAR 0 4
58821: PUSH
58822: LD_VAR 0 11
58826: PUSH
58827: FOR_IN
58828: IFFALSE 58901
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
58830: LD_VAR 0 4
58834: PPUSH
58835: CALL_OW 264
58839: PUSH
58840: LD_INT 31
58842: EQUAL
58843: PUSH
58844: LD_VAR 0 4
58848: PPUSH
58849: CALL_OW 311
58853: NOT
58854: AND
58855: PUSH
58856: LD_VAR 0 4
58860: PPUSH
58861: CALL_OW 266
58865: PUSH
58866: LD_INT 36
58868: EQUAL
58869: PUSH
58870: LD_VAR 0 4
58874: PPUSH
58875: CALL_OW 313
58879: PUSH
58880: LD_INT 3
58882: LESS
58883: AND
58884: OR
58885: IFFALSE 58899
// begin ct := k ;
58887: LD_ADDR_VAR 0 8
58891: PUSH
58892: LD_VAR 0 4
58896: ST_TO_ADDR
// break ;
58897: GO 58901
// end ;
58899: GO 58827
58901: POP
58902: POP
// if ct then
58903: LD_VAR 0 8
58907: IFFALSE 58923
// ComEnterUnit ( j , ct ) ;
58909: LD_VAR 0 3
58913: PPUSH
58914: LD_VAR 0 8
58918: PPUSH
58919: CALL_OW 120
// end ; end ;
58923: GO 58558
58925: POP
58926: POP
// places := 0 ;
58927: LD_ADDR_VAR 0 5
58931: PUSH
58932: LD_INT 0
58934: ST_TO_ADDR
// for j = 1 to x do
58935: LD_ADDR_VAR 0 3
58939: PUSH
58940: DOUBLE
58941: LD_INT 1
58943: DEC
58944: ST_TO_ADDR
58945: LD_VAR 0 11
58949: PUSH
58950: FOR_TO
58951: IFFALSE 59027
// if GetWeapon ( x [ j ] ) = ar_control_tower then
58953: LD_VAR 0 11
58957: PUSH
58958: LD_VAR 0 3
58962: ARRAY
58963: PPUSH
58964: CALL_OW 264
58968: PUSH
58969: LD_INT 31
58971: EQUAL
58972: IFFALSE 58990
// places := places + 1 else
58974: LD_ADDR_VAR 0 5
58978: PUSH
58979: LD_VAR 0 5
58983: PUSH
58984: LD_INT 1
58986: PLUS
58987: ST_TO_ADDR
58988: GO 59025
// if GetBType ( x [ j ] ) = b_control_tower then
58990: LD_VAR 0 11
58994: PUSH
58995: LD_VAR 0 3
58999: ARRAY
59000: PPUSH
59001: CALL_OW 266
59005: PUSH
59006: LD_INT 36
59008: EQUAL
59009: IFFALSE 59025
// places := places + 3 ;
59011: LD_ADDR_VAR 0 5
59015: PUSH
59016: LD_VAR 0 5
59020: PUSH
59021: LD_INT 3
59023: PLUS
59024: ST_TO_ADDR
59025: GO 58950
59027: POP
59028: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
59029: LD_VAR 0 5
59033: PUSH
59034: LD_INT 0
59036: EQUAL
59037: PUSH
59038: LD_VAR 0 5
59042: PUSH
59043: LD_EXP 139
59047: PUSH
59048: LD_VAR 0 2
59052: ARRAY
59053: LESSEQUAL
59054: OR
59055: IFFALSE 59059
// continue ;
59057: GO 58309
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
59059: LD_ADDR_VAR 0 6
59063: PUSH
59064: LD_EXP 99
59068: PUSH
59069: LD_VAR 0 2
59073: ARRAY
59074: PPUSH
59075: LD_INT 25
59077: PUSH
59078: LD_INT 3
59080: PUSH
59081: EMPTY
59082: LIST
59083: LIST
59084: PPUSH
59085: CALL_OW 72
59089: PUSH
59090: LD_EXP 139
59094: PUSH
59095: LD_VAR 0 2
59099: ARRAY
59100: DIFF
59101: PPUSH
59102: LD_INT 3
59104: PPUSH
59105: CALL 103192 0 2
59109: ST_TO_ADDR
// for j in tmp do
59110: LD_ADDR_VAR 0 3
59114: PUSH
59115: LD_VAR 0 6
59119: PUSH
59120: FOR_IN
59121: IFFALSE 59156
// if GetTag ( j ) > 0 then
59123: LD_VAR 0 3
59127: PPUSH
59128: CALL_OW 110
59132: PUSH
59133: LD_INT 0
59135: GREATER
59136: IFFALSE 59154
// tmp := tmp diff j ;
59138: LD_ADDR_VAR 0 6
59142: PUSH
59143: LD_VAR 0 6
59147: PUSH
59148: LD_VAR 0 3
59152: DIFF
59153: ST_TO_ADDR
59154: GO 59120
59156: POP
59157: POP
// if not tmp then
59158: LD_VAR 0 6
59162: NOT
59163: IFFALSE 59167
// continue ;
59165: GO 58309
// if places then
59167: LD_VAR 0 5
59171: IFFALSE 59230
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
59173: LD_ADDR_EXP 139
59177: PUSH
59178: LD_EXP 139
59182: PPUSH
59183: LD_VAR 0 2
59187: PPUSH
59188: LD_EXP 139
59192: PUSH
59193: LD_VAR 0 2
59197: ARRAY
59198: PUSH
59199: LD_VAR 0 6
59203: PUSH
59204: LD_INT 1
59206: ARRAY
59207: UNION
59208: PPUSH
59209: CALL_OW 1
59213: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
59214: LD_VAR 0 6
59218: PUSH
59219: LD_INT 1
59221: ARRAY
59222: PPUSH
59223: LD_INT 126
59225: PPUSH
59226: CALL_OW 109
// end ; end ;
59230: GO 58309
59232: POP
59233: POP
// end ;
59234: LD_VAR 0 1
59238: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
59239: LD_INT 0
59241: PPUSH
59242: PPUSH
59243: PPUSH
59244: PPUSH
59245: PPUSH
59246: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
59247: LD_VAR 0 1
59251: NOT
59252: PUSH
59253: LD_VAR 0 2
59257: NOT
59258: OR
59259: PUSH
59260: LD_VAR 0 3
59264: NOT
59265: OR
59266: PUSH
59267: LD_VAR 0 4
59271: PUSH
59272: LD_INT 1
59274: PUSH
59275: LD_INT 2
59277: PUSH
59278: LD_INT 3
59280: PUSH
59281: LD_INT 4
59283: PUSH
59284: LD_INT 5
59286: PUSH
59287: LD_INT 8
59289: PUSH
59290: LD_INT 9
59292: PUSH
59293: LD_INT 15
59295: PUSH
59296: LD_INT 16
59298: PUSH
59299: EMPTY
59300: LIST
59301: LIST
59302: LIST
59303: LIST
59304: LIST
59305: LIST
59306: LIST
59307: LIST
59308: LIST
59309: IN
59310: NOT
59311: OR
59312: IFFALSE 59316
// exit ;
59314: GO 60216
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
59316: LD_ADDR_VAR 0 2
59320: PUSH
59321: LD_VAR 0 2
59325: PPUSH
59326: LD_INT 21
59328: PUSH
59329: LD_INT 3
59331: PUSH
59332: EMPTY
59333: LIST
59334: LIST
59335: PUSH
59336: LD_INT 24
59338: PUSH
59339: LD_INT 250
59341: PUSH
59342: EMPTY
59343: LIST
59344: LIST
59345: PUSH
59346: EMPTY
59347: LIST
59348: LIST
59349: PPUSH
59350: CALL_OW 72
59354: ST_TO_ADDR
// case class of 1 , 15 :
59355: LD_VAR 0 4
59359: PUSH
59360: LD_INT 1
59362: DOUBLE
59363: EQUAL
59364: IFTRUE 59374
59366: LD_INT 15
59368: DOUBLE
59369: EQUAL
59370: IFTRUE 59374
59372: GO 59459
59374: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
59375: LD_ADDR_VAR 0 8
59379: PUSH
59380: LD_VAR 0 2
59384: PPUSH
59385: LD_INT 2
59387: PUSH
59388: LD_INT 30
59390: PUSH
59391: LD_INT 32
59393: PUSH
59394: EMPTY
59395: LIST
59396: LIST
59397: PUSH
59398: LD_INT 30
59400: PUSH
59401: LD_INT 31
59403: PUSH
59404: EMPTY
59405: LIST
59406: LIST
59407: PUSH
59408: EMPTY
59409: LIST
59410: LIST
59411: LIST
59412: PPUSH
59413: CALL_OW 72
59417: PUSH
59418: LD_VAR 0 2
59422: PPUSH
59423: LD_INT 2
59425: PUSH
59426: LD_INT 30
59428: PUSH
59429: LD_INT 4
59431: PUSH
59432: EMPTY
59433: LIST
59434: LIST
59435: PUSH
59436: LD_INT 30
59438: PUSH
59439: LD_INT 5
59441: PUSH
59442: EMPTY
59443: LIST
59444: LIST
59445: PUSH
59446: EMPTY
59447: LIST
59448: LIST
59449: LIST
59450: PPUSH
59451: CALL_OW 72
59455: ADD
59456: ST_TO_ADDR
59457: GO 59705
59459: LD_INT 2
59461: DOUBLE
59462: EQUAL
59463: IFTRUE 59473
59465: LD_INT 16
59467: DOUBLE
59468: EQUAL
59469: IFTRUE 59473
59471: GO 59519
59473: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
59474: LD_ADDR_VAR 0 8
59478: PUSH
59479: LD_VAR 0 2
59483: PPUSH
59484: LD_INT 2
59486: PUSH
59487: LD_INT 30
59489: PUSH
59490: LD_INT 0
59492: PUSH
59493: EMPTY
59494: LIST
59495: LIST
59496: PUSH
59497: LD_INT 30
59499: PUSH
59500: LD_INT 1
59502: PUSH
59503: EMPTY
59504: LIST
59505: LIST
59506: PUSH
59507: EMPTY
59508: LIST
59509: LIST
59510: LIST
59511: PPUSH
59512: CALL_OW 72
59516: ST_TO_ADDR
59517: GO 59705
59519: LD_INT 3
59521: DOUBLE
59522: EQUAL
59523: IFTRUE 59527
59525: GO 59573
59527: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
59528: LD_ADDR_VAR 0 8
59532: PUSH
59533: LD_VAR 0 2
59537: PPUSH
59538: LD_INT 2
59540: PUSH
59541: LD_INT 30
59543: PUSH
59544: LD_INT 2
59546: PUSH
59547: EMPTY
59548: LIST
59549: LIST
59550: PUSH
59551: LD_INT 30
59553: PUSH
59554: LD_INT 3
59556: PUSH
59557: EMPTY
59558: LIST
59559: LIST
59560: PUSH
59561: EMPTY
59562: LIST
59563: LIST
59564: LIST
59565: PPUSH
59566: CALL_OW 72
59570: ST_TO_ADDR
59571: GO 59705
59573: LD_INT 4
59575: DOUBLE
59576: EQUAL
59577: IFTRUE 59581
59579: GO 59638
59581: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
59582: LD_ADDR_VAR 0 8
59586: PUSH
59587: LD_VAR 0 2
59591: PPUSH
59592: LD_INT 2
59594: PUSH
59595: LD_INT 30
59597: PUSH
59598: LD_INT 6
59600: PUSH
59601: EMPTY
59602: LIST
59603: LIST
59604: PUSH
59605: LD_INT 30
59607: PUSH
59608: LD_INT 7
59610: PUSH
59611: EMPTY
59612: LIST
59613: LIST
59614: PUSH
59615: LD_INT 30
59617: PUSH
59618: LD_INT 8
59620: PUSH
59621: EMPTY
59622: LIST
59623: LIST
59624: PUSH
59625: EMPTY
59626: LIST
59627: LIST
59628: LIST
59629: LIST
59630: PPUSH
59631: CALL_OW 72
59635: ST_TO_ADDR
59636: GO 59705
59638: LD_INT 5
59640: DOUBLE
59641: EQUAL
59642: IFTRUE 59658
59644: LD_INT 8
59646: DOUBLE
59647: EQUAL
59648: IFTRUE 59658
59650: LD_INT 9
59652: DOUBLE
59653: EQUAL
59654: IFTRUE 59658
59656: GO 59704
59658: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
59659: LD_ADDR_VAR 0 8
59663: PUSH
59664: LD_VAR 0 2
59668: PPUSH
59669: LD_INT 2
59671: PUSH
59672: LD_INT 30
59674: PUSH
59675: LD_INT 4
59677: PUSH
59678: EMPTY
59679: LIST
59680: LIST
59681: PUSH
59682: LD_INT 30
59684: PUSH
59685: LD_INT 5
59687: PUSH
59688: EMPTY
59689: LIST
59690: LIST
59691: PUSH
59692: EMPTY
59693: LIST
59694: LIST
59695: LIST
59696: PPUSH
59697: CALL_OW 72
59701: ST_TO_ADDR
59702: GO 59705
59704: POP
// if not tmp then
59705: LD_VAR 0 8
59709: NOT
59710: IFFALSE 59714
// exit ;
59712: GO 60216
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
59714: LD_VAR 0 4
59718: PUSH
59719: LD_INT 1
59721: PUSH
59722: LD_INT 15
59724: PUSH
59725: EMPTY
59726: LIST
59727: LIST
59728: IN
59729: PUSH
59730: LD_EXP 108
59734: PUSH
59735: LD_VAR 0 1
59739: ARRAY
59740: AND
59741: IFFALSE 59897
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
59743: LD_ADDR_VAR 0 9
59747: PUSH
59748: LD_EXP 108
59752: PUSH
59753: LD_VAR 0 1
59757: ARRAY
59758: PUSH
59759: LD_INT 1
59761: ARRAY
59762: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
59763: LD_VAR 0 9
59767: PUSH
59768: LD_EXP 109
59772: PUSH
59773: LD_VAR 0 1
59777: ARRAY
59778: IN
59779: NOT
59780: IFFALSE 59895
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
59782: LD_ADDR_EXP 109
59786: PUSH
59787: LD_EXP 109
59791: PPUSH
59792: LD_VAR 0 1
59796: PUSH
59797: LD_EXP 109
59801: PUSH
59802: LD_VAR 0 1
59806: ARRAY
59807: PUSH
59808: LD_INT 1
59810: PLUS
59811: PUSH
59812: EMPTY
59813: LIST
59814: LIST
59815: PPUSH
59816: LD_VAR 0 9
59820: PPUSH
59821: CALL 72371 0 3
59825: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
59826: LD_ADDR_EXP 108
59830: PUSH
59831: LD_EXP 108
59835: PPUSH
59836: LD_VAR 0 1
59840: PPUSH
59841: LD_EXP 108
59845: PUSH
59846: LD_VAR 0 1
59850: ARRAY
59851: PUSH
59852: LD_VAR 0 9
59856: DIFF
59857: PPUSH
59858: CALL_OW 1
59862: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
59863: LD_VAR 0 3
59867: PPUSH
59868: LD_EXP 109
59872: PUSH
59873: LD_VAR 0 1
59877: ARRAY
59878: PUSH
59879: LD_EXP 109
59883: PUSH
59884: LD_VAR 0 1
59888: ARRAY
59889: ARRAY
59890: PPUSH
59891: CALL_OW 120
// end ; exit ;
59895: GO 60216
// end ; if tmp > 1 then
59897: LD_VAR 0 8
59901: PUSH
59902: LD_INT 1
59904: GREATER
59905: IFFALSE 60009
// for i = 2 to tmp do
59907: LD_ADDR_VAR 0 6
59911: PUSH
59912: DOUBLE
59913: LD_INT 2
59915: DEC
59916: ST_TO_ADDR
59917: LD_VAR 0 8
59921: PUSH
59922: FOR_TO
59923: IFFALSE 60007
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
59925: LD_VAR 0 8
59929: PUSH
59930: LD_VAR 0 6
59934: ARRAY
59935: PPUSH
59936: CALL_OW 461
59940: PUSH
59941: LD_INT 6
59943: EQUAL
59944: IFFALSE 60005
// begin x := tmp [ i ] ;
59946: LD_ADDR_VAR 0 9
59950: PUSH
59951: LD_VAR 0 8
59955: PUSH
59956: LD_VAR 0 6
59960: ARRAY
59961: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
59962: LD_ADDR_VAR 0 8
59966: PUSH
59967: LD_VAR 0 8
59971: PPUSH
59972: LD_VAR 0 6
59976: PPUSH
59977: CALL_OW 3
59981: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
59982: LD_ADDR_VAR 0 8
59986: PUSH
59987: LD_VAR 0 8
59991: PPUSH
59992: LD_INT 1
59994: PPUSH
59995: LD_VAR 0 9
59999: PPUSH
60000: CALL_OW 2
60004: ST_TO_ADDR
// end ;
60005: GO 59922
60007: POP
60008: POP
// for i in tmp do
60009: LD_ADDR_VAR 0 6
60013: PUSH
60014: LD_VAR 0 8
60018: PUSH
60019: FOR_IN
60020: IFFALSE 60089
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
60022: LD_VAR 0 6
60026: PPUSH
60027: CALL_OW 313
60031: PUSH
60032: LD_INT 6
60034: LESS
60035: PUSH
60036: LD_VAR 0 6
60040: PPUSH
60041: CALL_OW 266
60045: PUSH
60046: LD_INT 31
60048: PUSH
60049: LD_INT 32
60051: PUSH
60052: EMPTY
60053: LIST
60054: LIST
60055: IN
60056: NOT
60057: AND
60058: PUSH
60059: LD_VAR 0 6
60063: PPUSH
60064: CALL_OW 313
60068: PUSH
60069: LD_INT 0
60071: EQUAL
60072: OR
60073: IFFALSE 60087
// begin j := i ;
60075: LD_ADDR_VAR 0 7
60079: PUSH
60080: LD_VAR 0 6
60084: ST_TO_ADDR
// break ;
60085: GO 60089
// end ; end ;
60087: GO 60019
60089: POP
60090: POP
// if j then
60091: LD_VAR 0 7
60095: IFFALSE 60113
// ComEnterUnit ( unit , j ) else
60097: LD_VAR 0 3
60101: PPUSH
60102: LD_VAR 0 7
60106: PPUSH
60107: CALL_OW 120
60111: GO 60216
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60113: LD_ADDR_VAR 0 10
60117: PUSH
60118: LD_VAR 0 2
60122: PPUSH
60123: LD_INT 2
60125: PUSH
60126: LD_INT 30
60128: PUSH
60129: LD_INT 0
60131: PUSH
60132: EMPTY
60133: LIST
60134: LIST
60135: PUSH
60136: LD_INT 30
60138: PUSH
60139: LD_INT 1
60141: PUSH
60142: EMPTY
60143: LIST
60144: LIST
60145: PUSH
60146: EMPTY
60147: LIST
60148: LIST
60149: LIST
60150: PPUSH
60151: CALL_OW 72
60155: ST_TO_ADDR
// if depot then
60156: LD_VAR 0 10
60160: IFFALSE 60216
// begin depot := NearestUnitToUnit ( depot , unit ) ;
60162: LD_ADDR_VAR 0 10
60166: PUSH
60167: LD_VAR 0 10
60171: PPUSH
60172: LD_VAR 0 3
60176: PPUSH
60177: CALL_OW 74
60181: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
60182: LD_VAR 0 3
60186: PPUSH
60187: LD_VAR 0 10
60191: PPUSH
60192: CALL_OW 296
60196: PUSH
60197: LD_INT 10
60199: GREATER
60200: IFFALSE 60216
// ComStandNearbyBuilding ( unit , depot ) ;
60202: LD_VAR 0 3
60206: PPUSH
60207: LD_VAR 0 10
60211: PPUSH
60212: CALL 68798 0 2
// end ; end ; end ;
60216: LD_VAR 0 5
60220: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
60221: LD_INT 0
60223: PPUSH
60224: PPUSH
60225: PPUSH
60226: PPUSH
// if not mc_bases then
60227: LD_EXP 99
60231: NOT
60232: IFFALSE 60236
// exit ;
60234: GO 60475
// for i = 1 to mc_bases do
60236: LD_ADDR_VAR 0 2
60240: PUSH
60241: DOUBLE
60242: LD_INT 1
60244: DEC
60245: ST_TO_ADDR
60246: LD_EXP 99
60250: PUSH
60251: FOR_TO
60252: IFFALSE 60473
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
60254: LD_ADDR_VAR 0 4
60258: PUSH
60259: LD_EXP 99
60263: PUSH
60264: LD_VAR 0 2
60268: ARRAY
60269: PPUSH
60270: LD_INT 21
60272: PUSH
60273: LD_INT 1
60275: PUSH
60276: EMPTY
60277: LIST
60278: LIST
60279: PPUSH
60280: CALL_OW 72
60284: PUSH
60285: LD_EXP 128
60289: PUSH
60290: LD_VAR 0 2
60294: ARRAY
60295: UNION
60296: ST_TO_ADDR
// if not tmp then
60297: LD_VAR 0 4
60301: NOT
60302: IFFALSE 60306
// continue ;
60304: GO 60251
// for j in tmp do
60306: LD_ADDR_VAR 0 3
60310: PUSH
60311: LD_VAR 0 4
60315: PUSH
60316: FOR_IN
60317: IFFALSE 60469
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
60319: LD_VAR 0 3
60323: PPUSH
60324: CALL_OW 110
60328: NOT
60329: PUSH
60330: LD_VAR 0 3
60334: PPUSH
60335: CALL_OW 314
60339: NOT
60340: AND
60341: PUSH
60342: LD_VAR 0 3
60346: PPUSH
60347: CALL_OW 311
60351: NOT
60352: AND
60353: PUSH
60354: LD_VAR 0 3
60358: PPUSH
60359: CALL_OW 310
60363: NOT
60364: AND
60365: PUSH
60366: LD_VAR 0 3
60370: PUSH
60371: LD_EXP 102
60375: PUSH
60376: LD_VAR 0 2
60380: ARRAY
60381: PUSH
60382: LD_INT 1
60384: ARRAY
60385: IN
60386: NOT
60387: AND
60388: PUSH
60389: LD_VAR 0 3
60393: PUSH
60394: LD_EXP 102
60398: PUSH
60399: LD_VAR 0 2
60403: ARRAY
60404: PUSH
60405: LD_INT 2
60407: ARRAY
60408: IN
60409: NOT
60410: AND
60411: PUSH
60412: LD_VAR 0 3
60416: PUSH
60417: LD_EXP 111
60421: PUSH
60422: LD_VAR 0 2
60426: ARRAY
60427: IN
60428: NOT
60429: AND
60430: IFFALSE 60467
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
60432: LD_VAR 0 2
60436: PPUSH
60437: LD_EXP 99
60441: PUSH
60442: LD_VAR 0 2
60446: ARRAY
60447: PPUSH
60448: LD_VAR 0 3
60452: PPUSH
60453: LD_VAR 0 3
60457: PPUSH
60458: CALL_OW 257
60462: PPUSH
60463: CALL 59239 0 4
// end ;
60467: GO 60316
60469: POP
60470: POP
// end ;
60471: GO 60251
60473: POP
60474: POP
// end ;
60475: LD_VAR 0 1
60479: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
60480: LD_INT 0
60482: PPUSH
60483: PPUSH
60484: PPUSH
60485: PPUSH
60486: PPUSH
60487: PPUSH
// if not mc_bases [ base ] then
60488: LD_EXP 99
60492: PUSH
60493: LD_VAR 0 1
60497: ARRAY
60498: NOT
60499: IFFALSE 60503
// exit ;
60501: GO 60685
// tmp := [ ] ;
60503: LD_ADDR_VAR 0 6
60507: PUSH
60508: EMPTY
60509: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
60510: LD_ADDR_VAR 0 7
60514: PUSH
60515: LD_VAR 0 3
60519: PPUSH
60520: LD_INT 0
60522: PPUSH
60523: CALL_OW 517
60527: ST_TO_ADDR
// if not list then
60528: LD_VAR 0 7
60532: NOT
60533: IFFALSE 60537
// exit ;
60535: GO 60685
// for i = 1 to amount do
60537: LD_ADDR_VAR 0 5
60541: PUSH
60542: DOUBLE
60543: LD_INT 1
60545: DEC
60546: ST_TO_ADDR
60547: LD_VAR 0 2
60551: PUSH
60552: FOR_TO
60553: IFFALSE 60633
// begin x := rand ( 1 , list [ 1 ] ) ;
60555: LD_ADDR_VAR 0 8
60559: PUSH
60560: LD_INT 1
60562: PPUSH
60563: LD_VAR 0 7
60567: PUSH
60568: LD_INT 1
60570: ARRAY
60571: PPUSH
60572: CALL_OW 12
60576: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
60577: LD_ADDR_VAR 0 6
60581: PUSH
60582: LD_VAR 0 6
60586: PPUSH
60587: LD_VAR 0 5
60591: PPUSH
60592: LD_VAR 0 7
60596: PUSH
60597: LD_INT 1
60599: ARRAY
60600: PUSH
60601: LD_VAR 0 8
60605: ARRAY
60606: PUSH
60607: LD_VAR 0 7
60611: PUSH
60612: LD_INT 2
60614: ARRAY
60615: PUSH
60616: LD_VAR 0 8
60620: ARRAY
60621: PUSH
60622: EMPTY
60623: LIST
60624: LIST
60625: PPUSH
60626: CALL_OW 1
60630: ST_TO_ADDR
// end ;
60631: GO 60552
60633: POP
60634: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
60635: LD_ADDR_EXP 112
60639: PUSH
60640: LD_EXP 112
60644: PPUSH
60645: LD_VAR 0 1
60649: PPUSH
60650: LD_VAR 0 6
60654: PPUSH
60655: CALL_OW 1
60659: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
60660: LD_ADDR_EXP 114
60664: PUSH
60665: LD_EXP 114
60669: PPUSH
60670: LD_VAR 0 1
60674: PPUSH
60675: LD_VAR 0 3
60679: PPUSH
60680: CALL_OW 1
60684: ST_TO_ADDR
// end ;
60685: LD_VAR 0 4
60689: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
60690: LD_INT 0
60692: PPUSH
// if not mc_bases [ base ] then
60693: LD_EXP 99
60697: PUSH
60698: LD_VAR 0 1
60702: ARRAY
60703: NOT
60704: IFFALSE 60708
// exit ;
60706: GO 60733
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
60708: LD_ADDR_EXP 104
60712: PUSH
60713: LD_EXP 104
60717: PPUSH
60718: LD_VAR 0 1
60722: PPUSH
60723: LD_VAR 0 2
60727: PPUSH
60728: CALL_OW 1
60732: ST_TO_ADDR
// end ;
60733: LD_VAR 0 3
60737: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
60738: LD_INT 0
60740: PPUSH
// if not mc_bases [ base ] then
60741: LD_EXP 99
60745: PUSH
60746: LD_VAR 0 1
60750: ARRAY
60751: NOT
60752: IFFALSE 60756
// exit ;
60754: GO 60793
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
60756: LD_ADDR_EXP 104
60760: PUSH
60761: LD_EXP 104
60765: PPUSH
60766: LD_VAR 0 1
60770: PPUSH
60771: LD_EXP 104
60775: PUSH
60776: LD_VAR 0 1
60780: ARRAY
60781: PUSH
60782: LD_VAR 0 2
60786: UNION
60787: PPUSH
60788: CALL_OW 1
60792: ST_TO_ADDR
// end ;
60793: LD_VAR 0 3
60797: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
60798: LD_INT 0
60800: PPUSH
// if not mc_bases [ base ] then
60801: LD_EXP 99
60805: PUSH
60806: LD_VAR 0 1
60810: ARRAY
60811: NOT
60812: IFFALSE 60816
// exit ;
60814: GO 60841
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
60816: LD_ADDR_EXP 120
60820: PUSH
60821: LD_EXP 120
60825: PPUSH
60826: LD_VAR 0 1
60830: PPUSH
60831: LD_VAR 0 2
60835: PPUSH
60836: CALL_OW 1
60840: ST_TO_ADDR
// end ;
60841: LD_VAR 0 3
60845: RET
// export function MC_InsertProduceList ( base , components ) ; begin
60846: LD_INT 0
60848: PPUSH
// if not mc_bases [ base ] then
60849: LD_EXP 99
60853: PUSH
60854: LD_VAR 0 1
60858: ARRAY
60859: NOT
60860: IFFALSE 60864
// exit ;
60862: GO 60901
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
60864: LD_ADDR_EXP 120
60868: PUSH
60869: LD_EXP 120
60873: PPUSH
60874: LD_VAR 0 1
60878: PPUSH
60879: LD_EXP 120
60883: PUSH
60884: LD_VAR 0 1
60888: ARRAY
60889: PUSH
60890: LD_VAR 0 2
60894: ADD
60895: PPUSH
60896: CALL_OW 1
60900: ST_TO_ADDR
// end ;
60901: LD_VAR 0 3
60905: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
60906: LD_INT 0
60908: PPUSH
// if not mc_bases [ base ] then
60909: LD_EXP 99
60913: PUSH
60914: LD_VAR 0 1
60918: ARRAY
60919: NOT
60920: IFFALSE 60924
// exit ;
60922: GO 60978
// mc_defender := Replace ( mc_defender , base , deflist ) ;
60924: LD_ADDR_EXP 121
60928: PUSH
60929: LD_EXP 121
60933: PPUSH
60934: LD_VAR 0 1
60938: PPUSH
60939: LD_VAR 0 2
60943: PPUSH
60944: CALL_OW 1
60948: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
60949: LD_ADDR_EXP 110
60953: PUSH
60954: LD_EXP 110
60958: PPUSH
60959: LD_VAR 0 1
60963: PPUSH
60964: LD_VAR 0 2
60968: PUSH
60969: LD_INT 0
60971: PLUS
60972: PPUSH
60973: CALL_OW 1
60977: ST_TO_ADDR
// end ;
60978: LD_VAR 0 3
60982: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
60983: LD_INT 0
60985: PPUSH
// if not mc_bases [ base ] then
60986: LD_EXP 99
60990: PUSH
60991: LD_VAR 0 1
60995: ARRAY
60996: NOT
60997: IFFALSE 61001
// exit ;
60999: GO 61026
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
61001: LD_ADDR_EXP 110
61005: PUSH
61006: LD_EXP 110
61010: PPUSH
61011: LD_VAR 0 1
61015: PPUSH
61016: LD_VAR 0 2
61020: PPUSH
61021: CALL_OW 1
61025: ST_TO_ADDR
// end ;
61026: LD_VAR 0 3
61030: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
61031: LD_INT 0
61033: PPUSH
61034: PPUSH
61035: PPUSH
61036: PPUSH
// if not mc_bases [ base ] then
61037: LD_EXP 99
61041: PUSH
61042: LD_VAR 0 1
61046: ARRAY
61047: NOT
61048: IFFALSE 61052
// exit ;
61050: GO 61117
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
61052: LD_ADDR_EXP 119
61056: PUSH
61057: LD_EXP 119
61061: PPUSH
61062: LD_VAR 0 1
61066: PUSH
61067: LD_EXP 119
61071: PUSH
61072: LD_VAR 0 1
61076: ARRAY
61077: PUSH
61078: LD_INT 1
61080: PLUS
61081: PUSH
61082: EMPTY
61083: LIST
61084: LIST
61085: PPUSH
61086: LD_VAR 0 1
61090: PUSH
61091: LD_VAR 0 2
61095: PUSH
61096: LD_VAR 0 3
61100: PUSH
61101: LD_VAR 0 4
61105: PUSH
61106: EMPTY
61107: LIST
61108: LIST
61109: LIST
61110: LIST
61111: PPUSH
61112: CALL 72371 0 3
61116: ST_TO_ADDR
// end ;
61117: LD_VAR 0 5
61121: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
61122: LD_INT 0
61124: PPUSH
// if not mc_bases [ base ] then
61125: LD_EXP 99
61129: PUSH
61130: LD_VAR 0 1
61134: ARRAY
61135: NOT
61136: IFFALSE 61140
// exit ;
61138: GO 61165
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
61140: LD_ADDR_EXP 136
61144: PUSH
61145: LD_EXP 136
61149: PPUSH
61150: LD_VAR 0 1
61154: PPUSH
61155: LD_VAR 0 2
61159: PPUSH
61160: CALL_OW 1
61164: ST_TO_ADDR
// end ;
61165: LD_VAR 0 3
61169: RET
// export function MC_GetMinesField ( base ) ; begin
61170: LD_INT 0
61172: PPUSH
// result := mc_mines [ base ] ;
61173: LD_ADDR_VAR 0 2
61177: PUSH
61178: LD_EXP 112
61182: PUSH
61183: LD_VAR 0 1
61187: ARRAY
61188: ST_TO_ADDR
// end ;
61189: LD_VAR 0 2
61193: RET
// export function MC_GetProduceList ( base ) ; begin
61194: LD_INT 0
61196: PPUSH
// result := mc_produce [ base ] ;
61197: LD_ADDR_VAR 0 2
61201: PUSH
61202: LD_EXP 120
61206: PUSH
61207: LD_VAR 0 1
61211: ARRAY
61212: ST_TO_ADDR
// end ;
61213: LD_VAR 0 2
61217: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
61218: LD_INT 0
61220: PPUSH
61221: PPUSH
// if not mc_bases then
61222: LD_EXP 99
61226: NOT
61227: IFFALSE 61231
// exit ;
61229: GO 61296
// if mc_bases [ base ] then
61231: LD_EXP 99
61235: PUSH
61236: LD_VAR 0 1
61240: ARRAY
61241: IFFALSE 61296
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61243: LD_ADDR_VAR 0 3
61247: PUSH
61248: LD_EXP 99
61252: PUSH
61253: LD_VAR 0 1
61257: ARRAY
61258: PPUSH
61259: LD_INT 30
61261: PUSH
61262: LD_VAR 0 2
61266: PUSH
61267: EMPTY
61268: LIST
61269: LIST
61270: PPUSH
61271: CALL_OW 72
61275: ST_TO_ADDR
// if result then
61276: LD_VAR 0 3
61280: IFFALSE 61296
// result := result [ 1 ] ;
61282: LD_ADDR_VAR 0 3
61286: PUSH
61287: LD_VAR 0 3
61291: PUSH
61292: LD_INT 1
61294: ARRAY
61295: ST_TO_ADDR
// end ; end ;
61296: LD_VAR 0 3
61300: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
61301: LD_INT 0
61303: PPUSH
61304: PPUSH
// if not mc_bases then
61305: LD_EXP 99
61309: NOT
61310: IFFALSE 61314
// exit ;
61312: GO 61359
// if mc_bases [ base ] then
61314: LD_EXP 99
61318: PUSH
61319: LD_VAR 0 1
61323: ARRAY
61324: IFFALSE 61359
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61326: LD_ADDR_VAR 0 3
61330: PUSH
61331: LD_EXP 99
61335: PUSH
61336: LD_VAR 0 1
61340: ARRAY
61341: PPUSH
61342: LD_INT 30
61344: PUSH
61345: LD_VAR 0 2
61349: PUSH
61350: EMPTY
61351: LIST
61352: LIST
61353: PPUSH
61354: CALL_OW 72
61358: ST_TO_ADDR
// end ;
61359: LD_VAR 0 3
61363: RET
// export function MC_SetTame ( base , area ) ; begin
61364: LD_INT 0
61366: PPUSH
// if not mc_bases or not base then
61367: LD_EXP 99
61371: NOT
61372: PUSH
61373: LD_VAR 0 1
61377: NOT
61378: OR
61379: IFFALSE 61383
// exit ;
61381: GO 61408
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
61383: LD_ADDR_EXP 127
61387: PUSH
61388: LD_EXP 127
61392: PPUSH
61393: LD_VAR 0 1
61397: PPUSH
61398: LD_VAR 0 2
61402: PPUSH
61403: CALL_OW 1
61407: ST_TO_ADDR
// end ;
61408: LD_VAR 0 3
61412: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
61413: LD_INT 0
61415: PPUSH
61416: PPUSH
// if not mc_bases or not base then
61417: LD_EXP 99
61421: NOT
61422: PUSH
61423: LD_VAR 0 1
61427: NOT
61428: OR
61429: IFFALSE 61433
// exit ;
61431: GO 61535
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61433: LD_ADDR_VAR 0 4
61437: PUSH
61438: LD_EXP 99
61442: PUSH
61443: LD_VAR 0 1
61447: ARRAY
61448: PPUSH
61449: LD_INT 30
61451: PUSH
61452: LD_VAR 0 2
61456: PUSH
61457: EMPTY
61458: LIST
61459: LIST
61460: PPUSH
61461: CALL_OW 72
61465: ST_TO_ADDR
// if not tmp then
61466: LD_VAR 0 4
61470: NOT
61471: IFFALSE 61475
// exit ;
61473: GO 61535
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
61475: LD_ADDR_EXP 131
61479: PUSH
61480: LD_EXP 131
61484: PPUSH
61485: LD_VAR 0 1
61489: PPUSH
61490: LD_EXP 131
61494: PUSH
61495: LD_VAR 0 1
61499: ARRAY
61500: PPUSH
61501: LD_EXP 131
61505: PUSH
61506: LD_VAR 0 1
61510: ARRAY
61511: PUSH
61512: LD_INT 1
61514: PLUS
61515: PPUSH
61516: LD_VAR 0 4
61520: PUSH
61521: LD_INT 1
61523: ARRAY
61524: PPUSH
61525: CALL_OW 2
61529: PPUSH
61530: CALL_OW 1
61534: ST_TO_ADDR
// end ;
61535: LD_VAR 0 3
61539: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
61540: LD_INT 0
61542: PPUSH
61543: PPUSH
// if not mc_bases or not base or not kinds then
61544: LD_EXP 99
61548: NOT
61549: PUSH
61550: LD_VAR 0 1
61554: NOT
61555: OR
61556: PUSH
61557: LD_VAR 0 2
61561: NOT
61562: OR
61563: IFFALSE 61567
// exit ;
61565: GO 61628
// for i in kinds do
61567: LD_ADDR_VAR 0 4
61571: PUSH
61572: LD_VAR 0 2
61576: PUSH
61577: FOR_IN
61578: IFFALSE 61626
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
61580: LD_ADDR_EXP 133
61584: PUSH
61585: LD_EXP 133
61589: PPUSH
61590: LD_VAR 0 1
61594: PUSH
61595: LD_EXP 133
61599: PUSH
61600: LD_VAR 0 1
61604: ARRAY
61605: PUSH
61606: LD_INT 1
61608: PLUS
61609: PUSH
61610: EMPTY
61611: LIST
61612: LIST
61613: PPUSH
61614: LD_VAR 0 4
61618: PPUSH
61619: CALL 72371 0 3
61623: ST_TO_ADDR
61624: GO 61577
61626: POP
61627: POP
// end ;
61628: LD_VAR 0 3
61632: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
61633: LD_INT 0
61635: PPUSH
// if not mc_bases or not base or not areas then
61636: LD_EXP 99
61640: NOT
61641: PUSH
61642: LD_VAR 0 1
61646: NOT
61647: OR
61648: PUSH
61649: LD_VAR 0 2
61653: NOT
61654: OR
61655: IFFALSE 61659
// exit ;
61657: GO 61684
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
61659: LD_ADDR_EXP 117
61663: PUSH
61664: LD_EXP 117
61668: PPUSH
61669: LD_VAR 0 1
61673: PPUSH
61674: LD_VAR 0 2
61678: PPUSH
61679: CALL_OW 1
61683: ST_TO_ADDR
// end ;
61684: LD_VAR 0 3
61688: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
61689: LD_INT 0
61691: PPUSH
// if not mc_bases or not base or not teleports_exit then
61692: LD_EXP 99
61696: NOT
61697: PUSH
61698: LD_VAR 0 1
61702: NOT
61703: OR
61704: PUSH
61705: LD_VAR 0 2
61709: NOT
61710: OR
61711: IFFALSE 61715
// exit ;
61713: GO 61740
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
61715: LD_ADDR_EXP 134
61719: PUSH
61720: LD_EXP 134
61724: PPUSH
61725: LD_VAR 0 1
61729: PPUSH
61730: LD_VAR 0 2
61734: PPUSH
61735: CALL_OW 1
61739: ST_TO_ADDR
// end ;
61740: LD_VAR 0 3
61744: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
61745: LD_INT 0
61747: PPUSH
61748: PPUSH
61749: PPUSH
// if not mc_bases or not base or not ext_list then
61750: LD_EXP 99
61754: NOT
61755: PUSH
61756: LD_VAR 0 1
61760: NOT
61761: OR
61762: PUSH
61763: LD_VAR 0 5
61767: NOT
61768: OR
61769: IFFALSE 61773
// exit ;
61771: GO 61946
// tmp := GetFacExtXYD ( x , y , d ) ;
61773: LD_ADDR_VAR 0 8
61777: PUSH
61778: LD_VAR 0 2
61782: PPUSH
61783: LD_VAR 0 3
61787: PPUSH
61788: LD_VAR 0 4
61792: PPUSH
61793: CALL 102322 0 3
61797: ST_TO_ADDR
// if not tmp then
61798: LD_VAR 0 8
61802: NOT
61803: IFFALSE 61807
// exit ;
61805: GO 61946
// for i in tmp do
61807: LD_ADDR_VAR 0 7
61811: PUSH
61812: LD_VAR 0 8
61816: PUSH
61817: FOR_IN
61818: IFFALSE 61944
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
61820: LD_ADDR_EXP 104
61824: PUSH
61825: LD_EXP 104
61829: PPUSH
61830: LD_VAR 0 1
61834: PPUSH
61835: LD_EXP 104
61839: PUSH
61840: LD_VAR 0 1
61844: ARRAY
61845: PPUSH
61846: LD_EXP 104
61850: PUSH
61851: LD_VAR 0 1
61855: ARRAY
61856: PUSH
61857: LD_INT 1
61859: PLUS
61860: PPUSH
61861: LD_VAR 0 5
61865: PUSH
61866: LD_INT 1
61868: ARRAY
61869: PUSH
61870: LD_VAR 0 7
61874: PUSH
61875: LD_INT 1
61877: ARRAY
61878: PUSH
61879: LD_VAR 0 7
61883: PUSH
61884: LD_INT 2
61886: ARRAY
61887: PUSH
61888: LD_VAR 0 7
61892: PUSH
61893: LD_INT 3
61895: ARRAY
61896: PUSH
61897: EMPTY
61898: LIST
61899: LIST
61900: LIST
61901: LIST
61902: PPUSH
61903: CALL_OW 2
61907: PPUSH
61908: CALL_OW 1
61912: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
61913: LD_ADDR_VAR 0 5
61917: PUSH
61918: LD_VAR 0 5
61922: PPUSH
61923: LD_INT 1
61925: PPUSH
61926: CALL_OW 3
61930: ST_TO_ADDR
// if not ext_list then
61931: LD_VAR 0 5
61935: NOT
61936: IFFALSE 61942
// exit ;
61938: POP
61939: POP
61940: GO 61946
// end ;
61942: GO 61817
61944: POP
61945: POP
// end ;
61946: LD_VAR 0 6
61950: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
61951: LD_INT 0
61953: PPUSH
// if not mc_bases or not base or not weapon_list then
61954: LD_EXP 99
61958: NOT
61959: PUSH
61960: LD_VAR 0 1
61964: NOT
61965: OR
61966: PUSH
61967: LD_VAR 0 2
61971: NOT
61972: OR
61973: IFFALSE 61977
// exit ;
61975: GO 62002
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
61977: LD_ADDR_EXP 138
61981: PUSH
61982: LD_EXP 138
61986: PPUSH
61987: LD_VAR 0 1
61991: PPUSH
61992: LD_VAR 0 2
61996: PPUSH
61997: CALL_OW 1
62001: ST_TO_ADDR
// end ;
62002: LD_VAR 0 3
62006: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
62007: LD_INT 0
62009: PPUSH
// if not mc_bases or not base or not tech_list then
62010: LD_EXP 99
62014: NOT
62015: PUSH
62016: LD_VAR 0 1
62020: NOT
62021: OR
62022: PUSH
62023: LD_VAR 0 2
62027: NOT
62028: OR
62029: IFFALSE 62033
// exit ;
62031: GO 62058
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
62033: LD_ADDR_EXP 126
62037: PUSH
62038: LD_EXP 126
62042: PPUSH
62043: LD_VAR 0 1
62047: PPUSH
62048: LD_VAR 0 2
62052: PPUSH
62053: CALL_OW 1
62057: ST_TO_ADDR
// end ;
62058: LD_VAR 0 3
62062: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
62063: LD_INT 0
62065: PPUSH
// if not mc_bases or not parking_area or not base then
62066: LD_EXP 99
62070: NOT
62071: PUSH
62072: LD_VAR 0 2
62076: NOT
62077: OR
62078: PUSH
62079: LD_VAR 0 1
62083: NOT
62084: OR
62085: IFFALSE 62089
// exit ;
62087: GO 62114
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
62089: LD_ADDR_EXP 123
62093: PUSH
62094: LD_EXP 123
62098: PPUSH
62099: LD_VAR 0 1
62103: PPUSH
62104: LD_VAR 0 2
62108: PPUSH
62109: CALL_OW 1
62113: ST_TO_ADDR
// end ;
62114: LD_VAR 0 3
62118: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
62119: LD_INT 0
62121: PPUSH
// if not mc_bases or not base or not scan_area then
62122: LD_EXP 99
62126: NOT
62127: PUSH
62128: LD_VAR 0 1
62132: NOT
62133: OR
62134: PUSH
62135: LD_VAR 0 2
62139: NOT
62140: OR
62141: IFFALSE 62145
// exit ;
62143: GO 62170
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
62145: LD_ADDR_EXP 124
62149: PUSH
62150: LD_EXP 124
62154: PPUSH
62155: LD_VAR 0 1
62159: PPUSH
62160: LD_VAR 0 2
62164: PPUSH
62165: CALL_OW 1
62169: ST_TO_ADDR
// end ;
62170: LD_VAR 0 3
62174: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
62175: LD_INT 0
62177: PPUSH
62178: PPUSH
// if not mc_bases or not base then
62179: LD_EXP 99
62183: NOT
62184: PUSH
62185: LD_VAR 0 1
62189: NOT
62190: OR
62191: IFFALSE 62195
// exit ;
62193: GO 62259
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
62195: LD_ADDR_VAR 0 3
62199: PUSH
62200: LD_INT 1
62202: PUSH
62203: LD_INT 2
62205: PUSH
62206: LD_INT 3
62208: PUSH
62209: LD_INT 4
62211: PUSH
62212: LD_INT 11
62214: PUSH
62215: EMPTY
62216: LIST
62217: LIST
62218: LIST
62219: LIST
62220: LIST
62221: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
62222: LD_ADDR_EXP 126
62226: PUSH
62227: LD_EXP 126
62231: PPUSH
62232: LD_VAR 0 1
62236: PPUSH
62237: LD_EXP 126
62241: PUSH
62242: LD_VAR 0 1
62246: ARRAY
62247: PUSH
62248: LD_VAR 0 3
62252: DIFF
62253: PPUSH
62254: CALL_OW 1
62258: ST_TO_ADDR
// end ;
62259: LD_VAR 0 2
62263: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
62264: LD_INT 0
62266: PPUSH
// result := mc_vehicles [ base ] ;
62267: LD_ADDR_VAR 0 3
62271: PUSH
62272: LD_EXP 118
62276: PUSH
62277: LD_VAR 0 1
62281: ARRAY
62282: ST_TO_ADDR
// if onlyCombat then
62283: LD_VAR 0 2
62287: IFFALSE 62459
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
62289: LD_ADDR_VAR 0 3
62293: PUSH
62294: LD_VAR 0 3
62298: PUSH
62299: LD_VAR 0 3
62303: PPUSH
62304: LD_INT 2
62306: PUSH
62307: LD_INT 34
62309: PUSH
62310: LD_INT 12
62312: PUSH
62313: EMPTY
62314: LIST
62315: LIST
62316: PUSH
62317: LD_INT 34
62319: PUSH
62320: LD_INT 51
62322: PUSH
62323: EMPTY
62324: LIST
62325: LIST
62326: PUSH
62327: LD_INT 34
62329: PUSH
62330: LD_INT 89
62332: PUSH
62333: EMPTY
62334: LIST
62335: LIST
62336: PUSH
62337: LD_INT 34
62339: PUSH
62340: LD_INT 32
62342: PUSH
62343: EMPTY
62344: LIST
62345: LIST
62346: PUSH
62347: LD_INT 34
62349: PUSH
62350: LD_INT 13
62352: PUSH
62353: EMPTY
62354: LIST
62355: LIST
62356: PUSH
62357: LD_INT 34
62359: PUSH
62360: LD_INT 52
62362: PUSH
62363: EMPTY
62364: LIST
62365: LIST
62366: PUSH
62367: LD_INT 34
62369: PUSH
62370: LD_INT 88
62372: PUSH
62373: EMPTY
62374: LIST
62375: LIST
62376: PUSH
62377: LD_INT 34
62379: PUSH
62380: LD_INT 14
62382: PUSH
62383: EMPTY
62384: LIST
62385: LIST
62386: PUSH
62387: LD_INT 34
62389: PUSH
62390: LD_INT 53
62392: PUSH
62393: EMPTY
62394: LIST
62395: LIST
62396: PUSH
62397: LD_INT 34
62399: PUSH
62400: LD_INT 98
62402: PUSH
62403: EMPTY
62404: LIST
62405: LIST
62406: PUSH
62407: LD_INT 34
62409: PUSH
62410: LD_INT 31
62412: PUSH
62413: EMPTY
62414: LIST
62415: LIST
62416: PUSH
62417: LD_INT 34
62419: PUSH
62420: LD_INT 48
62422: PUSH
62423: EMPTY
62424: LIST
62425: LIST
62426: PUSH
62427: LD_INT 34
62429: PUSH
62430: LD_INT 8
62432: PUSH
62433: EMPTY
62434: LIST
62435: LIST
62436: PUSH
62437: EMPTY
62438: LIST
62439: LIST
62440: LIST
62441: LIST
62442: LIST
62443: LIST
62444: LIST
62445: LIST
62446: LIST
62447: LIST
62448: LIST
62449: LIST
62450: LIST
62451: LIST
62452: PPUSH
62453: CALL_OW 72
62457: DIFF
62458: ST_TO_ADDR
// end ; end_of_file
62459: LD_VAR 0 3
62463: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
62464: LD_INT 0
62466: PPUSH
62467: PPUSH
62468: PPUSH
// if not mc_bases or not skirmish then
62469: LD_EXP 99
62473: NOT
62474: PUSH
62475: LD_EXP 97
62479: NOT
62480: OR
62481: IFFALSE 62485
// exit ;
62483: GO 62650
// for i = 1 to mc_bases do
62485: LD_ADDR_VAR 0 4
62489: PUSH
62490: DOUBLE
62491: LD_INT 1
62493: DEC
62494: ST_TO_ADDR
62495: LD_EXP 99
62499: PUSH
62500: FOR_TO
62501: IFFALSE 62648
// begin if sci in mc_bases [ i ] then
62503: LD_VAR 0 2
62507: PUSH
62508: LD_EXP 99
62512: PUSH
62513: LD_VAR 0 4
62517: ARRAY
62518: IN
62519: IFFALSE 62646
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
62521: LD_ADDR_EXP 128
62525: PUSH
62526: LD_EXP 128
62530: PPUSH
62531: LD_VAR 0 4
62535: PUSH
62536: LD_EXP 128
62540: PUSH
62541: LD_VAR 0 4
62545: ARRAY
62546: PUSH
62547: LD_INT 1
62549: PLUS
62550: PUSH
62551: EMPTY
62552: LIST
62553: LIST
62554: PPUSH
62555: LD_VAR 0 1
62559: PPUSH
62560: CALL 72371 0 3
62564: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
62565: LD_ADDR_VAR 0 5
62569: PUSH
62570: LD_EXP 99
62574: PUSH
62575: LD_VAR 0 4
62579: ARRAY
62580: PPUSH
62581: LD_INT 2
62583: PUSH
62584: LD_INT 30
62586: PUSH
62587: LD_INT 0
62589: PUSH
62590: EMPTY
62591: LIST
62592: LIST
62593: PUSH
62594: LD_INT 30
62596: PUSH
62597: LD_INT 1
62599: PUSH
62600: EMPTY
62601: LIST
62602: LIST
62603: PUSH
62604: EMPTY
62605: LIST
62606: LIST
62607: LIST
62608: PPUSH
62609: CALL_OW 72
62613: PPUSH
62614: LD_VAR 0 1
62618: PPUSH
62619: CALL_OW 74
62623: ST_TO_ADDR
// if tmp then
62624: LD_VAR 0 5
62628: IFFALSE 62644
// ComStandNearbyBuilding ( ape , tmp ) ;
62630: LD_VAR 0 1
62634: PPUSH
62635: LD_VAR 0 5
62639: PPUSH
62640: CALL 68798 0 2
// break ;
62644: GO 62648
// end ; end ;
62646: GO 62500
62648: POP
62649: POP
// end ;
62650: LD_VAR 0 3
62654: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
62655: LD_INT 0
62657: PPUSH
62658: PPUSH
62659: PPUSH
// if not mc_bases or not skirmish then
62660: LD_EXP 99
62664: NOT
62665: PUSH
62666: LD_EXP 97
62670: NOT
62671: OR
62672: IFFALSE 62676
// exit ;
62674: GO 62765
// for i = 1 to mc_bases do
62676: LD_ADDR_VAR 0 4
62680: PUSH
62681: DOUBLE
62682: LD_INT 1
62684: DEC
62685: ST_TO_ADDR
62686: LD_EXP 99
62690: PUSH
62691: FOR_TO
62692: IFFALSE 62763
// begin if building in mc_busy_turret_list [ i ] then
62694: LD_VAR 0 1
62698: PUSH
62699: LD_EXP 109
62703: PUSH
62704: LD_VAR 0 4
62708: ARRAY
62709: IN
62710: IFFALSE 62761
// begin tmp := mc_busy_turret_list [ i ] diff building ;
62712: LD_ADDR_VAR 0 5
62716: PUSH
62717: LD_EXP 109
62721: PUSH
62722: LD_VAR 0 4
62726: ARRAY
62727: PUSH
62728: LD_VAR 0 1
62732: DIFF
62733: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
62734: LD_ADDR_EXP 109
62738: PUSH
62739: LD_EXP 109
62743: PPUSH
62744: LD_VAR 0 4
62748: PPUSH
62749: LD_VAR 0 5
62753: PPUSH
62754: CALL_OW 1
62758: ST_TO_ADDR
// break ;
62759: GO 62763
// end ; end ;
62761: GO 62691
62763: POP
62764: POP
// end ;
62765: LD_VAR 0 3
62769: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
62770: LD_INT 0
62772: PPUSH
62773: PPUSH
62774: PPUSH
// if not mc_bases or not skirmish then
62775: LD_EXP 99
62779: NOT
62780: PUSH
62781: LD_EXP 97
62785: NOT
62786: OR
62787: IFFALSE 62791
// exit ;
62789: GO 62990
// for i = 1 to mc_bases do
62791: LD_ADDR_VAR 0 5
62795: PUSH
62796: DOUBLE
62797: LD_INT 1
62799: DEC
62800: ST_TO_ADDR
62801: LD_EXP 99
62805: PUSH
62806: FOR_TO
62807: IFFALSE 62988
// if building in mc_bases [ i ] then
62809: LD_VAR 0 1
62813: PUSH
62814: LD_EXP 99
62818: PUSH
62819: LD_VAR 0 5
62823: ARRAY
62824: IN
62825: IFFALSE 62986
// begin tmp := mc_bases [ i ] diff building ;
62827: LD_ADDR_VAR 0 6
62831: PUSH
62832: LD_EXP 99
62836: PUSH
62837: LD_VAR 0 5
62841: ARRAY
62842: PUSH
62843: LD_VAR 0 1
62847: DIFF
62848: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
62849: LD_ADDR_EXP 99
62853: PUSH
62854: LD_EXP 99
62858: PPUSH
62859: LD_VAR 0 5
62863: PPUSH
62864: LD_VAR 0 6
62868: PPUSH
62869: CALL_OW 1
62873: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
62874: LD_VAR 0 1
62878: PUSH
62879: LD_EXP 107
62883: PUSH
62884: LD_VAR 0 5
62888: ARRAY
62889: IN
62890: IFFALSE 62929
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
62892: LD_ADDR_EXP 107
62896: PUSH
62897: LD_EXP 107
62901: PPUSH
62902: LD_VAR 0 5
62906: PPUSH
62907: LD_EXP 107
62911: PUSH
62912: LD_VAR 0 5
62916: ARRAY
62917: PUSH
62918: LD_VAR 0 1
62922: DIFF
62923: PPUSH
62924: CALL_OW 1
62928: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
62929: LD_VAR 0 1
62933: PUSH
62934: LD_EXP 108
62938: PUSH
62939: LD_VAR 0 5
62943: ARRAY
62944: IN
62945: IFFALSE 62984
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
62947: LD_ADDR_EXP 108
62951: PUSH
62952: LD_EXP 108
62956: PPUSH
62957: LD_VAR 0 5
62961: PPUSH
62962: LD_EXP 108
62966: PUSH
62967: LD_VAR 0 5
62971: ARRAY
62972: PUSH
62973: LD_VAR 0 1
62977: DIFF
62978: PPUSH
62979: CALL_OW 1
62983: ST_TO_ADDR
// break ;
62984: GO 62988
// end ;
62986: GO 62806
62988: POP
62989: POP
// end ;
62990: LD_VAR 0 4
62994: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
62995: LD_INT 0
62997: PPUSH
62998: PPUSH
62999: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
63000: LD_EXP 99
63004: NOT
63005: PUSH
63006: LD_EXP 97
63010: NOT
63011: OR
63012: PUSH
63013: LD_VAR 0 3
63017: PUSH
63018: LD_EXP 125
63022: IN
63023: NOT
63024: OR
63025: IFFALSE 63029
// exit ;
63027: GO 63152
// for i = 1 to mc_vehicles do
63029: LD_ADDR_VAR 0 6
63033: PUSH
63034: DOUBLE
63035: LD_INT 1
63037: DEC
63038: ST_TO_ADDR
63039: LD_EXP 118
63043: PUSH
63044: FOR_TO
63045: IFFALSE 63150
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
63047: LD_VAR 0 2
63051: PUSH
63052: LD_EXP 118
63056: PUSH
63057: LD_VAR 0 6
63061: ARRAY
63062: IN
63063: PUSH
63064: LD_VAR 0 1
63068: PUSH
63069: LD_EXP 118
63073: PUSH
63074: LD_VAR 0 6
63078: ARRAY
63079: IN
63080: OR
63081: IFFALSE 63148
// begin tmp := mc_vehicles [ i ] diff old ;
63083: LD_ADDR_VAR 0 7
63087: PUSH
63088: LD_EXP 118
63092: PUSH
63093: LD_VAR 0 6
63097: ARRAY
63098: PUSH
63099: LD_VAR 0 2
63103: DIFF
63104: ST_TO_ADDR
// tmp := tmp diff new ;
63105: LD_ADDR_VAR 0 7
63109: PUSH
63110: LD_VAR 0 7
63114: PUSH
63115: LD_VAR 0 1
63119: DIFF
63120: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
63121: LD_ADDR_EXP 118
63125: PUSH
63126: LD_EXP 118
63130: PPUSH
63131: LD_VAR 0 6
63135: PPUSH
63136: LD_VAR 0 7
63140: PPUSH
63141: CALL_OW 1
63145: ST_TO_ADDR
// break ;
63146: GO 63150
// end ;
63148: GO 63044
63150: POP
63151: POP
// end ;
63152: LD_VAR 0 5
63156: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
63157: LD_INT 0
63159: PPUSH
63160: PPUSH
63161: PPUSH
63162: PPUSH
// if not mc_bases or not skirmish then
63163: LD_EXP 99
63167: NOT
63168: PUSH
63169: LD_EXP 97
63173: NOT
63174: OR
63175: IFFALSE 63179
// exit ;
63177: GO 63561
// side := GetSide ( vehicle ) ;
63179: LD_ADDR_VAR 0 5
63183: PUSH
63184: LD_VAR 0 1
63188: PPUSH
63189: CALL_OW 255
63193: ST_TO_ADDR
// for i = 1 to mc_bases do
63194: LD_ADDR_VAR 0 4
63198: PUSH
63199: DOUBLE
63200: LD_INT 1
63202: DEC
63203: ST_TO_ADDR
63204: LD_EXP 99
63208: PUSH
63209: FOR_TO
63210: IFFALSE 63559
// begin if factory in mc_bases [ i ] then
63212: LD_VAR 0 2
63216: PUSH
63217: LD_EXP 99
63221: PUSH
63222: LD_VAR 0 4
63226: ARRAY
63227: IN
63228: IFFALSE 63557
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
63230: LD_EXP 121
63234: PUSH
63235: LD_VAR 0 4
63239: ARRAY
63240: PUSH
63241: LD_EXP 110
63245: PUSH
63246: LD_VAR 0 4
63250: ARRAY
63251: LESS
63252: PUSH
63253: LD_VAR 0 1
63257: PPUSH
63258: CALL_OW 264
63262: PUSH
63263: LD_INT 31
63265: PUSH
63266: LD_INT 32
63268: PUSH
63269: LD_INT 51
63271: PUSH
63272: LD_INT 89
63274: PUSH
63275: LD_INT 12
63277: PUSH
63278: LD_INT 30
63280: PUSH
63281: LD_INT 98
63283: PUSH
63284: LD_INT 11
63286: PUSH
63287: LD_INT 53
63289: PUSH
63290: LD_INT 14
63292: PUSH
63293: LD_INT 91
63295: PUSH
63296: LD_INT 29
63298: PUSH
63299: LD_INT 99
63301: PUSH
63302: LD_INT 13
63304: PUSH
63305: LD_INT 52
63307: PUSH
63308: LD_INT 88
63310: PUSH
63311: LD_INT 48
63313: PUSH
63314: LD_INT 8
63316: PUSH
63317: EMPTY
63318: LIST
63319: LIST
63320: LIST
63321: LIST
63322: LIST
63323: LIST
63324: LIST
63325: LIST
63326: LIST
63327: LIST
63328: LIST
63329: LIST
63330: LIST
63331: LIST
63332: LIST
63333: LIST
63334: LIST
63335: LIST
63336: IN
63337: NOT
63338: AND
63339: IFFALSE 63387
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
63341: LD_ADDR_EXP 121
63345: PUSH
63346: LD_EXP 121
63350: PPUSH
63351: LD_VAR 0 4
63355: PUSH
63356: LD_EXP 121
63360: PUSH
63361: LD_VAR 0 4
63365: ARRAY
63366: PUSH
63367: LD_INT 1
63369: PLUS
63370: PUSH
63371: EMPTY
63372: LIST
63373: LIST
63374: PPUSH
63375: LD_VAR 0 1
63379: PPUSH
63380: CALL 72371 0 3
63384: ST_TO_ADDR
63385: GO 63431
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
63387: LD_ADDR_EXP 118
63391: PUSH
63392: LD_EXP 118
63396: PPUSH
63397: LD_VAR 0 4
63401: PUSH
63402: LD_EXP 118
63406: PUSH
63407: LD_VAR 0 4
63411: ARRAY
63412: PUSH
63413: LD_INT 1
63415: PLUS
63416: PUSH
63417: EMPTY
63418: LIST
63419: LIST
63420: PPUSH
63421: LD_VAR 0 1
63425: PPUSH
63426: CALL 72371 0 3
63430: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
63431: LD_VAR 0 1
63435: PPUSH
63436: CALL_OW 263
63440: PUSH
63441: LD_INT 2
63443: EQUAL
63444: IFFALSE 63473
// begin repeat wait ( 0 0$3 ) ;
63446: LD_INT 105
63448: PPUSH
63449: CALL_OW 67
// Connect ( vehicle ) ;
63453: LD_VAR 0 1
63457: PPUSH
63458: CALL 75340 0 1
// until IsControledBy ( vehicle ) ;
63462: LD_VAR 0 1
63466: PPUSH
63467: CALL_OW 312
63471: IFFALSE 63446
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
63473: LD_VAR 0 1
63477: PPUSH
63478: LD_EXP 123
63482: PUSH
63483: LD_VAR 0 4
63487: ARRAY
63488: PPUSH
63489: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
63493: LD_VAR 0 1
63497: PPUSH
63498: CALL_OW 263
63502: PUSH
63503: LD_INT 1
63505: NONEQUAL
63506: IFFALSE 63510
// break ;
63508: GO 63559
// repeat wait ( 0 0$1 ) ;
63510: LD_INT 35
63512: PPUSH
63513: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
63517: LD_VAR 0 1
63521: PPUSH
63522: LD_EXP 123
63526: PUSH
63527: LD_VAR 0 4
63531: ARRAY
63532: PPUSH
63533: CALL_OW 308
63537: IFFALSE 63510
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
63539: LD_VAR 0 1
63543: PPUSH
63544: CALL_OW 311
63548: PPUSH
63549: CALL_OW 121
// exit ;
63553: POP
63554: POP
63555: GO 63561
// end ; end ;
63557: GO 63209
63559: POP
63560: POP
// end ;
63561: LD_VAR 0 3
63565: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
63566: LD_INT 0
63568: PPUSH
63569: PPUSH
63570: PPUSH
63571: PPUSH
// if not mc_bases or not skirmish then
63572: LD_EXP 99
63576: NOT
63577: PUSH
63578: LD_EXP 97
63582: NOT
63583: OR
63584: IFFALSE 63588
// exit ;
63586: GO 63941
// repeat wait ( 0 0$1 ) ;
63588: LD_INT 35
63590: PPUSH
63591: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
63595: LD_VAR 0 2
63599: PPUSH
63600: LD_VAR 0 3
63604: PPUSH
63605: CALL_OW 284
63609: IFFALSE 63588
// if GetResourceTypeXY ( x , y ) = mat_artefact then
63611: LD_VAR 0 2
63615: PPUSH
63616: LD_VAR 0 3
63620: PPUSH
63621: CALL_OW 283
63625: PUSH
63626: LD_INT 4
63628: EQUAL
63629: IFFALSE 63633
// exit ;
63631: GO 63941
// for i = 1 to mc_bases do
63633: LD_ADDR_VAR 0 7
63637: PUSH
63638: DOUBLE
63639: LD_INT 1
63641: DEC
63642: ST_TO_ADDR
63643: LD_EXP 99
63647: PUSH
63648: FOR_TO
63649: IFFALSE 63939
// begin if mc_crates_area [ i ] then
63651: LD_EXP 117
63655: PUSH
63656: LD_VAR 0 7
63660: ARRAY
63661: IFFALSE 63772
// for j in mc_crates_area [ i ] do
63663: LD_ADDR_VAR 0 8
63667: PUSH
63668: LD_EXP 117
63672: PUSH
63673: LD_VAR 0 7
63677: ARRAY
63678: PUSH
63679: FOR_IN
63680: IFFALSE 63770
// if InArea ( x , y , j ) then
63682: LD_VAR 0 2
63686: PPUSH
63687: LD_VAR 0 3
63691: PPUSH
63692: LD_VAR 0 8
63696: PPUSH
63697: CALL_OW 309
63701: IFFALSE 63768
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
63703: LD_ADDR_EXP 115
63707: PUSH
63708: LD_EXP 115
63712: PPUSH
63713: LD_VAR 0 7
63717: PUSH
63718: LD_EXP 115
63722: PUSH
63723: LD_VAR 0 7
63727: ARRAY
63728: PUSH
63729: LD_INT 1
63731: PLUS
63732: PUSH
63733: EMPTY
63734: LIST
63735: LIST
63736: PPUSH
63737: LD_VAR 0 4
63741: PUSH
63742: LD_VAR 0 2
63746: PUSH
63747: LD_VAR 0 3
63751: PUSH
63752: EMPTY
63753: LIST
63754: LIST
63755: LIST
63756: PPUSH
63757: CALL 72371 0 3
63761: ST_TO_ADDR
// exit ;
63762: POP
63763: POP
63764: POP
63765: POP
63766: GO 63941
// end ;
63768: GO 63679
63770: POP
63771: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63772: LD_ADDR_VAR 0 9
63776: PUSH
63777: LD_EXP 99
63781: PUSH
63782: LD_VAR 0 7
63786: ARRAY
63787: PPUSH
63788: LD_INT 2
63790: PUSH
63791: LD_INT 30
63793: PUSH
63794: LD_INT 0
63796: PUSH
63797: EMPTY
63798: LIST
63799: LIST
63800: PUSH
63801: LD_INT 30
63803: PUSH
63804: LD_INT 1
63806: PUSH
63807: EMPTY
63808: LIST
63809: LIST
63810: PUSH
63811: EMPTY
63812: LIST
63813: LIST
63814: LIST
63815: PPUSH
63816: CALL_OW 72
63820: ST_TO_ADDR
// if not depot then
63821: LD_VAR 0 9
63825: NOT
63826: IFFALSE 63830
// continue ;
63828: GO 63648
// for j in depot do
63830: LD_ADDR_VAR 0 8
63834: PUSH
63835: LD_VAR 0 9
63839: PUSH
63840: FOR_IN
63841: IFFALSE 63935
// if GetDistUnitXY ( j , x , y ) < 30 then
63843: LD_VAR 0 8
63847: PPUSH
63848: LD_VAR 0 2
63852: PPUSH
63853: LD_VAR 0 3
63857: PPUSH
63858: CALL_OW 297
63862: PUSH
63863: LD_INT 30
63865: LESS
63866: IFFALSE 63933
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
63868: LD_ADDR_EXP 115
63872: PUSH
63873: LD_EXP 115
63877: PPUSH
63878: LD_VAR 0 7
63882: PUSH
63883: LD_EXP 115
63887: PUSH
63888: LD_VAR 0 7
63892: ARRAY
63893: PUSH
63894: LD_INT 1
63896: PLUS
63897: PUSH
63898: EMPTY
63899: LIST
63900: LIST
63901: PPUSH
63902: LD_VAR 0 4
63906: PUSH
63907: LD_VAR 0 2
63911: PUSH
63912: LD_VAR 0 3
63916: PUSH
63917: EMPTY
63918: LIST
63919: LIST
63920: LIST
63921: PPUSH
63922: CALL 72371 0 3
63926: ST_TO_ADDR
// exit ;
63927: POP
63928: POP
63929: POP
63930: POP
63931: GO 63941
// end ;
63933: GO 63840
63935: POP
63936: POP
// end ;
63937: GO 63648
63939: POP
63940: POP
// end ;
63941: LD_VAR 0 6
63945: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
63946: LD_INT 0
63948: PPUSH
63949: PPUSH
63950: PPUSH
63951: PPUSH
// if not mc_bases or not skirmish then
63952: LD_EXP 99
63956: NOT
63957: PUSH
63958: LD_EXP 97
63962: NOT
63963: OR
63964: IFFALSE 63968
// exit ;
63966: GO 64245
// side := GetSide ( lab ) ;
63968: LD_ADDR_VAR 0 4
63972: PUSH
63973: LD_VAR 0 2
63977: PPUSH
63978: CALL_OW 255
63982: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
63983: LD_VAR 0 4
63987: PUSH
63988: LD_EXP 125
63992: IN
63993: NOT
63994: PUSH
63995: LD_EXP 126
63999: NOT
64000: OR
64001: PUSH
64002: LD_EXP 99
64006: NOT
64007: OR
64008: IFFALSE 64012
// exit ;
64010: GO 64245
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
64012: LD_ADDR_EXP 126
64016: PUSH
64017: LD_EXP 126
64021: PPUSH
64022: LD_VAR 0 4
64026: PPUSH
64027: LD_EXP 126
64031: PUSH
64032: LD_VAR 0 4
64036: ARRAY
64037: PUSH
64038: LD_VAR 0 1
64042: DIFF
64043: PPUSH
64044: CALL_OW 1
64048: ST_TO_ADDR
// for i = 1 to mc_bases do
64049: LD_ADDR_VAR 0 5
64053: PUSH
64054: DOUBLE
64055: LD_INT 1
64057: DEC
64058: ST_TO_ADDR
64059: LD_EXP 99
64063: PUSH
64064: FOR_TO
64065: IFFALSE 64243
// begin if lab in mc_bases [ i ] then
64067: LD_VAR 0 2
64071: PUSH
64072: LD_EXP 99
64076: PUSH
64077: LD_VAR 0 5
64081: ARRAY
64082: IN
64083: IFFALSE 64241
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
64085: LD_VAR 0 1
64089: PUSH
64090: LD_INT 11
64092: PUSH
64093: LD_INT 4
64095: PUSH
64096: LD_INT 3
64098: PUSH
64099: LD_INT 2
64101: PUSH
64102: EMPTY
64103: LIST
64104: LIST
64105: LIST
64106: LIST
64107: IN
64108: PUSH
64109: LD_EXP 129
64113: PUSH
64114: LD_VAR 0 5
64118: ARRAY
64119: AND
64120: IFFALSE 64241
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
64122: LD_ADDR_VAR 0 6
64126: PUSH
64127: LD_EXP 129
64131: PUSH
64132: LD_VAR 0 5
64136: ARRAY
64137: PUSH
64138: LD_INT 1
64140: ARRAY
64141: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64142: LD_ADDR_EXP 129
64146: PUSH
64147: LD_EXP 129
64151: PPUSH
64152: LD_VAR 0 5
64156: PPUSH
64157: EMPTY
64158: PPUSH
64159: CALL_OW 1
64163: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
64164: LD_VAR 0 6
64168: PPUSH
64169: LD_INT 0
64171: PPUSH
64172: CALL_OW 109
// ComExitBuilding ( tmp ) ;
64176: LD_VAR 0 6
64180: PPUSH
64181: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
64185: LD_ADDR_EXP 128
64189: PUSH
64190: LD_EXP 128
64194: PPUSH
64195: LD_VAR 0 5
64199: PPUSH
64200: LD_EXP 128
64204: PUSH
64205: LD_VAR 0 5
64209: ARRAY
64210: PPUSH
64211: LD_INT 1
64213: PPUSH
64214: LD_VAR 0 6
64218: PPUSH
64219: CALL_OW 2
64223: PPUSH
64224: CALL_OW 1
64228: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
64229: LD_VAR 0 5
64233: PPUSH
64234: LD_INT 112
64236: PPUSH
64237: CALL 40731 0 2
// end ; end ; end ;
64241: GO 64064
64243: POP
64244: POP
// end ;
64245: LD_VAR 0 3
64249: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
64250: LD_INT 0
64252: PPUSH
64253: PPUSH
64254: PPUSH
64255: PPUSH
64256: PPUSH
64257: PPUSH
64258: PPUSH
64259: PPUSH
// if not mc_bases or not skirmish then
64260: LD_EXP 99
64264: NOT
64265: PUSH
64266: LD_EXP 97
64270: NOT
64271: OR
64272: IFFALSE 64276
// exit ;
64274: GO 65645
// for i = 1 to mc_bases do
64276: LD_ADDR_VAR 0 3
64280: PUSH
64281: DOUBLE
64282: LD_INT 1
64284: DEC
64285: ST_TO_ADDR
64286: LD_EXP 99
64290: PUSH
64291: FOR_TO
64292: IFFALSE 65643
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
64294: LD_VAR 0 1
64298: PUSH
64299: LD_EXP 99
64303: PUSH
64304: LD_VAR 0 3
64308: ARRAY
64309: IN
64310: PUSH
64311: LD_VAR 0 1
64315: PUSH
64316: LD_EXP 106
64320: PUSH
64321: LD_VAR 0 3
64325: ARRAY
64326: IN
64327: OR
64328: PUSH
64329: LD_VAR 0 1
64333: PUSH
64334: LD_EXP 121
64338: PUSH
64339: LD_VAR 0 3
64343: ARRAY
64344: IN
64345: OR
64346: PUSH
64347: LD_VAR 0 1
64351: PUSH
64352: LD_EXP 118
64356: PUSH
64357: LD_VAR 0 3
64361: ARRAY
64362: IN
64363: OR
64364: PUSH
64365: LD_VAR 0 1
64369: PUSH
64370: LD_EXP 128
64374: PUSH
64375: LD_VAR 0 3
64379: ARRAY
64380: IN
64381: OR
64382: PUSH
64383: LD_VAR 0 1
64387: PUSH
64388: LD_EXP 129
64392: PUSH
64393: LD_VAR 0 3
64397: ARRAY
64398: IN
64399: OR
64400: IFFALSE 65641
// begin if un in mc_ape [ i ] then
64402: LD_VAR 0 1
64406: PUSH
64407: LD_EXP 128
64411: PUSH
64412: LD_VAR 0 3
64416: ARRAY
64417: IN
64418: IFFALSE 64457
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
64420: LD_ADDR_EXP 128
64424: PUSH
64425: LD_EXP 128
64429: PPUSH
64430: LD_VAR 0 3
64434: PPUSH
64435: LD_EXP 128
64439: PUSH
64440: LD_VAR 0 3
64444: ARRAY
64445: PUSH
64446: LD_VAR 0 1
64450: DIFF
64451: PPUSH
64452: CALL_OW 1
64456: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
64457: LD_VAR 0 1
64461: PUSH
64462: LD_EXP 129
64466: PUSH
64467: LD_VAR 0 3
64471: ARRAY
64472: IN
64473: IFFALSE 64497
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64475: LD_ADDR_EXP 129
64479: PUSH
64480: LD_EXP 129
64484: PPUSH
64485: LD_VAR 0 3
64489: PPUSH
64490: EMPTY
64491: PPUSH
64492: CALL_OW 1
64496: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
64497: LD_VAR 0 1
64501: PPUSH
64502: CALL_OW 247
64506: PUSH
64507: LD_INT 2
64509: EQUAL
64510: PUSH
64511: LD_VAR 0 1
64515: PPUSH
64516: CALL_OW 110
64520: PUSH
64521: LD_INT 20
64523: EQUAL
64524: PUSH
64525: LD_VAR 0 1
64529: PUSH
64530: LD_EXP 121
64534: PUSH
64535: LD_VAR 0 3
64539: ARRAY
64540: IN
64541: OR
64542: PUSH
64543: LD_VAR 0 1
64547: PPUSH
64548: CALL_OW 264
64552: PUSH
64553: LD_INT 12
64555: PUSH
64556: LD_INT 51
64558: PUSH
64559: LD_INT 89
64561: PUSH
64562: LD_INT 32
64564: PUSH
64565: LD_INT 13
64567: PUSH
64568: LD_INT 52
64570: PUSH
64571: LD_INT 31
64573: PUSH
64574: EMPTY
64575: LIST
64576: LIST
64577: LIST
64578: LIST
64579: LIST
64580: LIST
64581: LIST
64582: IN
64583: OR
64584: AND
64585: IFFALSE 64893
// begin if un in mc_defender [ i ] then
64587: LD_VAR 0 1
64591: PUSH
64592: LD_EXP 121
64596: PUSH
64597: LD_VAR 0 3
64601: ARRAY
64602: IN
64603: IFFALSE 64642
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
64605: LD_ADDR_EXP 121
64609: PUSH
64610: LD_EXP 121
64614: PPUSH
64615: LD_VAR 0 3
64619: PPUSH
64620: LD_EXP 121
64624: PUSH
64625: LD_VAR 0 3
64629: ARRAY
64630: PUSH
64631: LD_VAR 0 1
64635: DIFF
64636: PPUSH
64637: CALL_OW 1
64641: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
64642: LD_ADDR_VAR 0 8
64646: PUSH
64647: LD_VAR 0 3
64651: PPUSH
64652: LD_INT 3
64654: PPUSH
64655: CALL 61301 0 2
64659: ST_TO_ADDR
// if fac then
64660: LD_VAR 0 8
64664: IFFALSE 64893
// begin for j in fac do
64666: LD_ADDR_VAR 0 4
64670: PUSH
64671: LD_VAR 0 8
64675: PUSH
64676: FOR_IN
64677: IFFALSE 64891
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
64679: LD_ADDR_VAR 0 9
64683: PUSH
64684: LD_VAR 0 8
64688: PPUSH
64689: LD_VAR 0 1
64693: PPUSH
64694: CALL_OW 265
64698: PPUSH
64699: LD_VAR 0 1
64703: PPUSH
64704: CALL_OW 262
64708: PPUSH
64709: LD_VAR 0 1
64713: PPUSH
64714: CALL_OW 263
64718: PPUSH
64719: LD_VAR 0 1
64723: PPUSH
64724: CALL_OW 264
64728: PPUSH
64729: CALL 69869 0 5
64733: ST_TO_ADDR
// if components then
64734: LD_VAR 0 9
64738: IFFALSE 64889
// begin if GetWeapon ( un ) = ar_control_tower then
64740: LD_VAR 0 1
64744: PPUSH
64745: CALL_OW 264
64749: PUSH
64750: LD_INT 31
64752: EQUAL
64753: IFFALSE 64870
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
64755: LD_VAR 0 1
64759: PPUSH
64760: CALL_OW 311
64764: PPUSH
64765: LD_INT 0
64767: PPUSH
64768: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
64772: LD_ADDR_EXP 139
64776: PUSH
64777: LD_EXP 139
64781: PPUSH
64782: LD_VAR 0 3
64786: PPUSH
64787: LD_EXP 139
64791: PUSH
64792: LD_VAR 0 3
64796: ARRAY
64797: PUSH
64798: LD_VAR 0 1
64802: PPUSH
64803: CALL_OW 311
64807: DIFF
64808: PPUSH
64809: CALL_OW 1
64813: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
64814: LD_ADDR_VAR 0 7
64818: PUSH
64819: LD_EXP 120
64823: PUSH
64824: LD_VAR 0 3
64828: ARRAY
64829: PPUSH
64830: LD_INT 1
64832: PPUSH
64833: LD_VAR 0 9
64837: PPUSH
64838: CALL_OW 2
64842: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
64843: LD_ADDR_EXP 120
64847: PUSH
64848: LD_EXP 120
64852: PPUSH
64853: LD_VAR 0 3
64857: PPUSH
64858: LD_VAR 0 7
64862: PPUSH
64863: CALL_OW 1
64867: ST_TO_ADDR
// end else
64868: GO 64887
// MC_InsertProduceList ( i , [ components ] ) ;
64870: LD_VAR 0 3
64874: PPUSH
64875: LD_VAR 0 9
64879: PUSH
64880: EMPTY
64881: LIST
64882: PPUSH
64883: CALL 60846 0 2
// break ;
64887: GO 64891
// end ; end ;
64889: GO 64676
64891: POP
64892: POP
// end ; end ; if GetType ( un ) = unit_building then
64893: LD_VAR 0 1
64897: PPUSH
64898: CALL_OW 247
64902: PUSH
64903: LD_INT 3
64905: EQUAL
64906: IFFALSE 65309
// begin btype := GetBType ( un ) ;
64908: LD_ADDR_VAR 0 5
64912: PUSH
64913: LD_VAR 0 1
64917: PPUSH
64918: CALL_OW 266
64922: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
64923: LD_VAR 0 5
64927: PUSH
64928: LD_INT 29
64930: PUSH
64931: LD_INT 30
64933: PUSH
64934: EMPTY
64935: LIST
64936: LIST
64937: IN
64938: IFFALSE 65011
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
64940: LD_VAR 0 1
64944: PPUSH
64945: CALL_OW 250
64949: PPUSH
64950: LD_VAR 0 1
64954: PPUSH
64955: CALL_OW 251
64959: PPUSH
64960: LD_VAR 0 1
64964: PPUSH
64965: CALL_OW 255
64969: PPUSH
64970: CALL_OW 440
64974: NOT
64975: IFFALSE 65011
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
64977: LD_VAR 0 1
64981: PPUSH
64982: CALL_OW 250
64986: PPUSH
64987: LD_VAR 0 1
64991: PPUSH
64992: CALL_OW 251
64996: PPUSH
64997: LD_VAR 0 1
65001: PPUSH
65002: CALL_OW 255
65006: PPUSH
65007: CALL_OW 441
// end ; if btype = b_warehouse then
65011: LD_VAR 0 5
65015: PUSH
65016: LD_INT 1
65018: EQUAL
65019: IFFALSE 65037
// begin btype := b_depot ;
65021: LD_ADDR_VAR 0 5
65025: PUSH
65026: LD_INT 0
65028: ST_TO_ADDR
// pos := 1 ;
65029: LD_ADDR_VAR 0 6
65033: PUSH
65034: LD_INT 1
65036: ST_TO_ADDR
// end ; if btype = b_factory then
65037: LD_VAR 0 5
65041: PUSH
65042: LD_INT 3
65044: EQUAL
65045: IFFALSE 65063
// begin btype := b_workshop ;
65047: LD_ADDR_VAR 0 5
65051: PUSH
65052: LD_INT 2
65054: ST_TO_ADDR
// pos := 1 ;
65055: LD_ADDR_VAR 0 6
65059: PUSH
65060: LD_INT 1
65062: ST_TO_ADDR
// end ; if btype = b_barracks then
65063: LD_VAR 0 5
65067: PUSH
65068: LD_INT 5
65070: EQUAL
65071: IFFALSE 65081
// btype := b_armoury ;
65073: LD_ADDR_VAR 0 5
65077: PUSH
65078: LD_INT 4
65080: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
65081: LD_VAR 0 5
65085: PUSH
65086: LD_INT 7
65088: PUSH
65089: LD_INT 8
65091: PUSH
65092: EMPTY
65093: LIST
65094: LIST
65095: IN
65096: IFFALSE 65106
// btype := b_lab ;
65098: LD_ADDR_VAR 0 5
65102: PUSH
65103: LD_INT 6
65105: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
65106: LD_ADDR_EXP 104
65110: PUSH
65111: LD_EXP 104
65115: PPUSH
65116: LD_VAR 0 3
65120: PUSH
65121: LD_EXP 104
65125: PUSH
65126: LD_VAR 0 3
65130: ARRAY
65131: PUSH
65132: LD_INT 1
65134: PLUS
65135: PUSH
65136: EMPTY
65137: LIST
65138: LIST
65139: PPUSH
65140: LD_VAR 0 5
65144: PUSH
65145: LD_VAR 0 1
65149: PPUSH
65150: CALL_OW 250
65154: PUSH
65155: LD_VAR 0 1
65159: PPUSH
65160: CALL_OW 251
65164: PUSH
65165: LD_VAR 0 1
65169: PPUSH
65170: CALL_OW 254
65174: PUSH
65175: EMPTY
65176: LIST
65177: LIST
65178: LIST
65179: LIST
65180: PPUSH
65181: CALL 72371 0 3
65185: ST_TO_ADDR
// if pos = 1 then
65186: LD_VAR 0 6
65190: PUSH
65191: LD_INT 1
65193: EQUAL
65194: IFFALSE 65309
// begin tmp := mc_build_list [ i ] ;
65196: LD_ADDR_VAR 0 7
65200: PUSH
65201: LD_EXP 104
65205: PUSH
65206: LD_VAR 0 3
65210: ARRAY
65211: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
65212: LD_VAR 0 7
65216: PPUSH
65217: LD_INT 2
65219: PUSH
65220: LD_INT 30
65222: PUSH
65223: LD_INT 0
65225: PUSH
65226: EMPTY
65227: LIST
65228: LIST
65229: PUSH
65230: LD_INT 30
65232: PUSH
65233: LD_INT 1
65235: PUSH
65236: EMPTY
65237: LIST
65238: LIST
65239: PUSH
65240: EMPTY
65241: LIST
65242: LIST
65243: LIST
65244: PPUSH
65245: CALL_OW 72
65249: IFFALSE 65259
// pos := 2 ;
65251: LD_ADDR_VAR 0 6
65255: PUSH
65256: LD_INT 2
65258: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
65259: LD_ADDR_VAR 0 7
65263: PUSH
65264: LD_VAR 0 7
65268: PPUSH
65269: LD_VAR 0 6
65273: PPUSH
65274: LD_VAR 0 7
65278: PPUSH
65279: CALL 72697 0 3
65283: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
65284: LD_ADDR_EXP 104
65288: PUSH
65289: LD_EXP 104
65293: PPUSH
65294: LD_VAR 0 3
65298: PPUSH
65299: LD_VAR 0 7
65303: PPUSH
65304: CALL_OW 1
65308: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
65309: LD_VAR 0 1
65313: PUSH
65314: LD_EXP 99
65318: PUSH
65319: LD_VAR 0 3
65323: ARRAY
65324: IN
65325: IFFALSE 65364
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
65327: LD_ADDR_EXP 99
65331: PUSH
65332: LD_EXP 99
65336: PPUSH
65337: LD_VAR 0 3
65341: PPUSH
65342: LD_EXP 99
65346: PUSH
65347: LD_VAR 0 3
65351: ARRAY
65352: PUSH
65353: LD_VAR 0 1
65357: DIFF
65358: PPUSH
65359: CALL_OW 1
65363: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
65364: LD_VAR 0 1
65368: PUSH
65369: LD_EXP 106
65373: PUSH
65374: LD_VAR 0 3
65378: ARRAY
65379: IN
65380: IFFALSE 65419
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
65382: LD_ADDR_EXP 106
65386: PUSH
65387: LD_EXP 106
65391: PPUSH
65392: LD_VAR 0 3
65396: PPUSH
65397: LD_EXP 106
65401: PUSH
65402: LD_VAR 0 3
65406: ARRAY
65407: PUSH
65408: LD_VAR 0 1
65412: DIFF
65413: PPUSH
65414: CALL_OW 1
65418: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
65419: LD_VAR 0 1
65423: PUSH
65424: LD_EXP 118
65428: PUSH
65429: LD_VAR 0 3
65433: ARRAY
65434: IN
65435: IFFALSE 65474
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
65437: LD_ADDR_EXP 118
65441: PUSH
65442: LD_EXP 118
65446: PPUSH
65447: LD_VAR 0 3
65451: PPUSH
65452: LD_EXP 118
65456: PUSH
65457: LD_VAR 0 3
65461: ARRAY
65462: PUSH
65463: LD_VAR 0 1
65467: DIFF
65468: PPUSH
65469: CALL_OW 1
65473: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
65474: LD_VAR 0 1
65478: PUSH
65479: LD_EXP 121
65483: PUSH
65484: LD_VAR 0 3
65488: ARRAY
65489: IN
65490: IFFALSE 65529
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
65492: LD_ADDR_EXP 121
65496: PUSH
65497: LD_EXP 121
65501: PPUSH
65502: LD_VAR 0 3
65506: PPUSH
65507: LD_EXP 121
65511: PUSH
65512: LD_VAR 0 3
65516: ARRAY
65517: PUSH
65518: LD_VAR 0 1
65522: DIFF
65523: PPUSH
65524: CALL_OW 1
65528: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
65529: LD_VAR 0 1
65533: PUSH
65534: LD_EXP 108
65538: PUSH
65539: LD_VAR 0 3
65543: ARRAY
65544: IN
65545: IFFALSE 65584
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
65547: LD_ADDR_EXP 108
65551: PUSH
65552: LD_EXP 108
65556: PPUSH
65557: LD_VAR 0 3
65561: PPUSH
65562: LD_EXP 108
65566: PUSH
65567: LD_VAR 0 3
65571: ARRAY
65572: PUSH
65573: LD_VAR 0 1
65577: DIFF
65578: PPUSH
65579: CALL_OW 1
65583: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
65584: LD_VAR 0 1
65588: PUSH
65589: LD_EXP 107
65593: PUSH
65594: LD_VAR 0 3
65598: ARRAY
65599: IN
65600: IFFALSE 65639
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
65602: LD_ADDR_EXP 107
65606: PUSH
65607: LD_EXP 107
65611: PPUSH
65612: LD_VAR 0 3
65616: PPUSH
65617: LD_EXP 107
65621: PUSH
65622: LD_VAR 0 3
65626: ARRAY
65627: PUSH
65628: LD_VAR 0 1
65632: DIFF
65633: PPUSH
65634: CALL_OW 1
65638: ST_TO_ADDR
// end ; break ;
65639: GO 65643
// end ;
65641: GO 64291
65643: POP
65644: POP
// end ;
65645: LD_VAR 0 2
65649: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
65650: LD_INT 0
65652: PPUSH
65653: PPUSH
65654: PPUSH
// if not mc_bases or not skirmish then
65655: LD_EXP 99
65659: NOT
65660: PUSH
65661: LD_EXP 97
65665: NOT
65666: OR
65667: IFFALSE 65671
// exit ;
65669: GO 65886
// for i = 1 to mc_bases do
65671: LD_ADDR_VAR 0 3
65675: PUSH
65676: DOUBLE
65677: LD_INT 1
65679: DEC
65680: ST_TO_ADDR
65681: LD_EXP 99
65685: PUSH
65686: FOR_TO
65687: IFFALSE 65884
// begin if building in mc_construct_list [ i ] then
65689: LD_VAR 0 1
65693: PUSH
65694: LD_EXP 106
65698: PUSH
65699: LD_VAR 0 3
65703: ARRAY
65704: IN
65705: IFFALSE 65882
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
65707: LD_ADDR_EXP 106
65711: PUSH
65712: LD_EXP 106
65716: PPUSH
65717: LD_VAR 0 3
65721: PPUSH
65722: LD_EXP 106
65726: PUSH
65727: LD_VAR 0 3
65731: ARRAY
65732: PUSH
65733: LD_VAR 0 1
65737: DIFF
65738: PPUSH
65739: CALL_OW 1
65743: ST_TO_ADDR
// if building in mc_lab [ i ] then
65744: LD_VAR 0 1
65748: PUSH
65749: LD_EXP 132
65753: PUSH
65754: LD_VAR 0 3
65758: ARRAY
65759: IN
65760: IFFALSE 65815
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
65762: LD_ADDR_EXP 133
65766: PUSH
65767: LD_EXP 133
65771: PPUSH
65772: LD_VAR 0 3
65776: PPUSH
65777: LD_EXP 133
65781: PUSH
65782: LD_VAR 0 3
65786: ARRAY
65787: PPUSH
65788: LD_INT 1
65790: PPUSH
65791: LD_EXP 133
65795: PUSH
65796: LD_VAR 0 3
65800: ARRAY
65801: PPUSH
65802: LD_INT 0
65804: PPUSH
65805: CALL 71789 0 4
65809: PPUSH
65810: CALL_OW 1
65814: ST_TO_ADDR
// if not building in mc_bases [ i ] then
65815: LD_VAR 0 1
65819: PUSH
65820: LD_EXP 99
65824: PUSH
65825: LD_VAR 0 3
65829: ARRAY
65830: IN
65831: NOT
65832: IFFALSE 65878
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
65834: LD_ADDR_EXP 99
65838: PUSH
65839: LD_EXP 99
65843: PPUSH
65844: LD_VAR 0 3
65848: PUSH
65849: LD_EXP 99
65853: PUSH
65854: LD_VAR 0 3
65858: ARRAY
65859: PUSH
65860: LD_INT 1
65862: PLUS
65863: PUSH
65864: EMPTY
65865: LIST
65866: LIST
65867: PPUSH
65868: LD_VAR 0 1
65872: PPUSH
65873: CALL 72371 0 3
65877: ST_TO_ADDR
// exit ;
65878: POP
65879: POP
65880: GO 65886
// end ; end ;
65882: GO 65686
65884: POP
65885: POP
// end ;
65886: LD_VAR 0 2
65890: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
65891: LD_INT 0
65893: PPUSH
65894: PPUSH
65895: PPUSH
65896: PPUSH
65897: PPUSH
65898: PPUSH
65899: PPUSH
// if not mc_bases or not skirmish then
65900: LD_EXP 99
65904: NOT
65905: PUSH
65906: LD_EXP 97
65910: NOT
65911: OR
65912: IFFALSE 65916
// exit ;
65914: GO 66577
// for i = 1 to mc_bases do
65916: LD_ADDR_VAR 0 3
65920: PUSH
65921: DOUBLE
65922: LD_INT 1
65924: DEC
65925: ST_TO_ADDR
65926: LD_EXP 99
65930: PUSH
65931: FOR_TO
65932: IFFALSE 66575
// begin if building in mc_construct_list [ i ] then
65934: LD_VAR 0 1
65938: PUSH
65939: LD_EXP 106
65943: PUSH
65944: LD_VAR 0 3
65948: ARRAY
65949: IN
65950: IFFALSE 66573
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
65952: LD_ADDR_EXP 106
65956: PUSH
65957: LD_EXP 106
65961: PPUSH
65962: LD_VAR 0 3
65966: PPUSH
65967: LD_EXP 106
65971: PUSH
65972: LD_VAR 0 3
65976: ARRAY
65977: PUSH
65978: LD_VAR 0 1
65982: DIFF
65983: PPUSH
65984: CALL_OW 1
65988: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
65989: LD_ADDR_EXP 99
65993: PUSH
65994: LD_EXP 99
65998: PPUSH
65999: LD_VAR 0 3
66003: PUSH
66004: LD_EXP 99
66008: PUSH
66009: LD_VAR 0 3
66013: ARRAY
66014: PUSH
66015: LD_INT 1
66017: PLUS
66018: PUSH
66019: EMPTY
66020: LIST
66021: LIST
66022: PPUSH
66023: LD_VAR 0 1
66027: PPUSH
66028: CALL 72371 0 3
66032: ST_TO_ADDR
// btype := GetBType ( building ) ;
66033: LD_ADDR_VAR 0 5
66037: PUSH
66038: LD_VAR 0 1
66042: PPUSH
66043: CALL_OW 266
66047: ST_TO_ADDR
// side := GetSide ( building ) ;
66048: LD_ADDR_VAR 0 8
66052: PUSH
66053: LD_VAR 0 1
66057: PPUSH
66058: CALL_OW 255
66062: ST_TO_ADDR
// if btype = b_lab then
66063: LD_VAR 0 5
66067: PUSH
66068: LD_INT 6
66070: EQUAL
66071: IFFALSE 66121
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
66073: LD_ADDR_EXP 132
66077: PUSH
66078: LD_EXP 132
66082: PPUSH
66083: LD_VAR 0 3
66087: PUSH
66088: LD_EXP 132
66092: PUSH
66093: LD_VAR 0 3
66097: ARRAY
66098: PUSH
66099: LD_INT 1
66101: PLUS
66102: PUSH
66103: EMPTY
66104: LIST
66105: LIST
66106: PPUSH
66107: LD_VAR 0 1
66111: PPUSH
66112: CALL 72371 0 3
66116: ST_TO_ADDR
// exit ;
66117: POP
66118: POP
66119: GO 66577
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
66121: LD_VAR 0 5
66125: PUSH
66126: LD_INT 0
66128: PUSH
66129: LD_INT 2
66131: PUSH
66132: LD_INT 4
66134: PUSH
66135: EMPTY
66136: LIST
66137: LIST
66138: LIST
66139: IN
66140: IFFALSE 66264
// begin if btype = b_armoury then
66142: LD_VAR 0 5
66146: PUSH
66147: LD_INT 4
66149: EQUAL
66150: IFFALSE 66160
// btype := b_barracks ;
66152: LD_ADDR_VAR 0 5
66156: PUSH
66157: LD_INT 5
66159: ST_TO_ADDR
// if btype = b_depot then
66160: LD_VAR 0 5
66164: PUSH
66165: LD_INT 0
66167: EQUAL
66168: IFFALSE 66178
// btype := b_warehouse ;
66170: LD_ADDR_VAR 0 5
66174: PUSH
66175: LD_INT 1
66177: ST_TO_ADDR
// if btype = b_workshop then
66178: LD_VAR 0 5
66182: PUSH
66183: LD_INT 2
66185: EQUAL
66186: IFFALSE 66196
// btype := b_factory ;
66188: LD_ADDR_VAR 0 5
66192: PUSH
66193: LD_INT 3
66195: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
66196: LD_VAR 0 5
66200: PPUSH
66201: LD_VAR 0 8
66205: PPUSH
66206: CALL_OW 323
66210: PUSH
66211: LD_INT 1
66213: EQUAL
66214: IFFALSE 66260
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
66216: LD_ADDR_EXP 131
66220: PUSH
66221: LD_EXP 131
66225: PPUSH
66226: LD_VAR 0 3
66230: PUSH
66231: LD_EXP 131
66235: PUSH
66236: LD_VAR 0 3
66240: ARRAY
66241: PUSH
66242: LD_INT 1
66244: PLUS
66245: PUSH
66246: EMPTY
66247: LIST
66248: LIST
66249: PPUSH
66250: LD_VAR 0 1
66254: PPUSH
66255: CALL 72371 0 3
66259: ST_TO_ADDR
// exit ;
66260: POP
66261: POP
66262: GO 66577
// end ; if btype in [ b_bunker , b_turret ] then
66264: LD_VAR 0 5
66268: PUSH
66269: LD_INT 32
66271: PUSH
66272: LD_INT 33
66274: PUSH
66275: EMPTY
66276: LIST
66277: LIST
66278: IN
66279: IFFALSE 66569
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
66281: LD_ADDR_EXP 107
66285: PUSH
66286: LD_EXP 107
66290: PPUSH
66291: LD_VAR 0 3
66295: PUSH
66296: LD_EXP 107
66300: PUSH
66301: LD_VAR 0 3
66305: ARRAY
66306: PUSH
66307: LD_INT 1
66309: PLUS
66310: PUSH
66311: EMPTY
66312: LIST
66313: LIST
66314: PPUSH
66315: LD_VAR 0 1
66319: PPUSH
66320: CALL 72371 0 3
66324: ST_TO_ADDR
// if btype = b_bunker then
66325: LD_VAR 0 5
66329: PUSH
66330: LD_INT 32
66332: EQUAL
66333: IFFALSE 66569
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
66335: LD_ADDR_EXP 108
66339: PUSH
66340: LD_EXP 108
66344: PPUSH
66345: LD_VAR 0 3
66349: PUSH
66350: LD_EXP 108
66354: PUSH
66355: LD_VAR 0 3
66359: ARRAY
66360: PUSH
66361: LD_INT 1
66363: PLUS
66364: PUSH
66365: EMPTY
66366: LIST
66367: LIST
66368: PPUSH
66369: LD_VAR 0 1
66373: PPUSH
66374: CALL 72371 0 3
66378: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
66379: LD_ADDR_VAR 0 6
66383: PUSH
66384: LD_EXP 99
66388: PUSH
66389: LD_VAR 0 3
66393: ARRAY
66394: PPUSH
66395: LD_INT 25
66397: PUSH
66398: LD_INT 1
66400: PUSH
66401: EMPTY
66402: LIST
66403: LIST
66404: PUSH
66405: LD_INT 3
66407: PUSH
66408: LD_INT 54
66410: PUSH
66411: EMPTY
66412: LIST
66413: PUSH
66414: EMPTY
66415: LIST
66416: LIST
66417: PUSH
66418: EMPTY
66419: LIST
66420: LIST
66421: PPUSH
66422: CALL_OW 72
66426: ST_TO_ADDR
// if tmp then
66427: LD_VAR 0 6
66431: IFFALSE 66437
// exit ;
66433: POP
66434: POP
66435: GO 66577
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66437: LD_ADDR_VAR 0 6
66441: PUSH
66442: LD_EXP 99
66446: PUSH
66447: LD_VAR 0 3
66451: ARRAY
66452: PPUSH
66453: LD_INT 2
66455: PUSH
66456: LD_INT 30
66458: PUSH
66459: LD_INT 4
66461: PUSH
66462: EMPTY
66463: LIST
66464: LIST
66465: PUSH
66466: LD_INT 30
66468: PUSH
66469: LD_INT 5
66471: PUSH
66472: EMPTY
66473: LIST
66474: LIST
66475: PUSH
66476: EMPTY
66477: LIST
66478: LIST
66479: LIST
66480: PPUSH
66481: CALL_OW 72
66485: ST_TO_ADDR
// if not tmp then
66486: LD_VAR 0 6
66490: NOT
66491: IFFALSE 66497
// exit ;
66493: POP
66494: POP
66495: GO 66577
// for j in tmp do
66497: LD_ADDR_VAR 0 4
66501: PUSH
66502: LD_VAR 0 6
66506: PUSH
66507: FOR_IN
66508: IFFALSE 66567
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
66510: LD_ADDR_VAR 0 7
66514: PUSH
66515: LD_VAR 0 4
66519: PPUSH
66520: CALL_OW 313
66524: PPUSH
66525: LD_INT 25
66527: PUSH
66528: LD_INT 1
66530: PUSH
66531: EMPTY
66532: LIST
66533: LIST
66534: PPUSH
66535: CALL_OW 72
66539: ST_TO_ADDR
// if units then
66540: LD_VAR 0 7
66544: IFFALSE 66565
// begin ComExitBuilding ( units [ 1 ] ) ;
66546: LD_VAR 0 7
66550: PUSH
66551: LD_INT 1
66553: ARRAY
66554: PPUSH
66555: CALL_OW 122
// exit ;
66559: POP
66560: POP
66561: POP
66562: POP
66563: GO 66577
// end ; end ;
66565: GO 66507
66567: POP
66568: POP
// end ; end ; exit ;
66569: POP
66570: POP
66571: GO 66577
// end ; end ;
66573: GO 65931
66575: POP
66576: POP
// end ;
66577: LD_VAR 0 2
66581: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
66582: LD_INT 0
66584: PPUSH
66585: PPUSH
66586: PPUSH
66587: PPUSH
66588: PPUSH
66589: PPUSH
66590: PPUSH
// if not mc_bases or not skirmish then
66591: LD_EXP 99
66595: NOT
66596: PUSH
66597: LD_EXP 97
66601: NOT
66602: OR
66603: IFFALSE 66607
// exit ;
66605: GO 66872
// btype := GetBType ( building ) ;
66607: LD_ADDR_VAR 0 6
66611: PUSH
66612: LD_VAR 0 1
66616: PPUSH
66617: CALL_OW 266
66621: ST_TO_ADDR
// x := GetX ( building ) ;
66622: LD_ADDR_VAR 0 7
66626: PUSH
66627: LD_VAR 0 1
66631: PPUSH
66632: CALL_OW 250
66636: ST_TO_ADDR
// y := GetY ( building ) ;
66637: LD_ADDR_VAR 0 8
66641: PUSH
66642: LD_VAR 0 1
66646: PPUSH
66647: CALL_OW 251
66651: ST_TO_ADDR
// d := GetDir ( building ) ;
66652: LD_ADDR_VAR 0 9
66656: PUSH
66657: LD_VAR 0 1
66661: PPUSH
66662: CALL_OW 254
66666: ST_TO_ADDR
// for i = 1 to mc_bases do
66667: LD_ADDR_VAR 0 4
66671: PUSH
66672: DOUBLE
66673: LD_INT 1
66675: DEC
66676: ST_TO_ADDR
66677: LD_EXP 99
66681: PUSH
66682: FOR_TO
66683: IFFALSE 66870
// begin if not mc_build_list [ i ] then
66685: LD_EXP 104
66689: PUSH
66690: LD_VAR 0 4
66694: ARRAY
66695: NOT
66696: IFFALSE 66700
// continue ;
66698: GO 66682
// for j := 1 to mc_build_list [ i ] do
66700: LD_ADDR_VAR 0 5
66704: PUSH
66705: DOUBLE
66706: LD_INT 1
66708: DEC
66709: ST_TO_ADDR
66710: LD_EXP 104
66714: PUSH
66715: LD_VAR 0 4
66719: ARRAY
66720: PUSH
66721: FOR_TO
66722: IFFALSE 66866
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
66724: LD_VAR 0 6
66728: PUSH
66729: LD_VAR 0 7
66733: PUSH
66734: LD_VAR 0 8
66738: PUSH
66739: LD_VAR 0 9
66743: PUSH
66744: EMPTY
66745: LIST
66746: LIST
66747: LIST
66748: LIST
66749: PPUSH
66750: LD_EXP 104
66754: PUSH
66755: LD_VAR 0 4
66759: ARRAY
66760: PUSH
66761: LD_VAR 0 5
66765: ARRAY
66766: PPUSH
66767: CALL 78551 0 2
66771: IFFALSE 66864
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
66773: LD_ADDR_EXP 104
66777: PUSH
66778: LD_EXP 104
66782: PPUSH
66783: LD_VAR 0 4
66787: PPUSH
66788: LD_EXP 104
66792: PUSH
66793: LD_VAR 0 4
66797: ARRAY
66798: PPUSH
66799: LD_VAR 0 5
66803: PPUSH
66804: CALL_OW 3
66808: PPUSH
66809: CALL_OW 1
66813: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
66814: LD_ADDR_EXP 106
66818: PUSH
66819: LD_EXP 106
66823: PPUSH
66824: LD_VAR 0 4
66828: PUSH
66829: LD_EXP 106
66833: PUSH
66834: LD_VAR 0 4
66838: ARRAY
66839: PUSH
66840: LD_INT 1
66842: PLUS
66843: PUSH
66844: EMPTY
66845: LIST
66846: LIST
66847: PPUSH
66848: LD_VAR 0 1
66852: PPUSH
66853: CALL 72371 0 3
66857: ST_TO_ADDR
// exit ;
66858: POP
66859: POP
66860: POP
66861: POP
66862: GO 66872
// end ;
66864: GO 66721
66866: POP
66867: POP
// end ;
66868: GO 66682
66870: POP
66871: POP
// end ;
66872: LD_VAR 0 3
66876: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
66877: LD_INT 0
66879: PPUSH
66880: PPUSH
66881: PPUSH
// if not mc_bases or not skirmish then
66882: LD_EXP 99
66886: NOT
66887: PUSH
66888: LD_EXP 97
66892: NOT
66893: OR
66894: IFFALSE 66898
// exit ;
66896: GO 67088
// for i = 1 to mc_bases do
66898: LD_ADDR_VAR 0 4
66902: PUSH
66903: DOUBLE
66904: LD_INT 1
66906: DEC
66907: ST_TO_ADDR
66908: LD_EXP 99
66912: PUSH
66913: FOR_TO
66914: IFFALSE 67001
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
66916: LD_VAR 0 1
66920: PUSH
66921: LD_EXP 107
66925: PUSH
66926: LD_VAR 0 4
66930: ARRAY
66931: IN
66932: PUSH
66933: LD_VAR 0 1
66937: PUSH
66938: LD_EXP 108
66942: PUSH
66943: LD_VAR 0 4
66947: ARRAY
66948: IN
66949: NOT
66950: AND
66951: IFFALSE 66999
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
66953: LD_ADDR_EXP 108
66957: PUSH
66958: LD_EXP 108
66962: PPUSH
66963: LD_VAR 0 4
66967: PUSH
66968: LD_EXP 108
66972: PUSH
66973: LD_VAR 0 4
66977: ARRAY
66978: PUSH
66979: LD_INT 1
66981: PLUS
66982: PUSH
66983: EMPTY
66984: LIST
66985: LIST
66986: PPUSH
66987: LD_VAR 0 1
66991: PPUSH
66992: CALL 72371 0 3
66996: ST_TO_ADDR
// break ;
66997: GO 67001
// end ; end ;
66999: GO 66913
67001: POP
67002: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
67003: LD_VAR 0 1
67007: PPUSH
67008: CALL_OW 257
67012: PUSH
67013: LD_EXP 125
67017: IN
67018: PUSH
67019: LD_VAR 0 1
67023: PPUSH
67024: CALL_OW 266
67028: PUSH
67029: LD_INT 5
67031: EQUAL
67032: AND
67033: PUSH
67034: LD_VAR 0 2
67038: PPUSH
67039: CALL_OW 110
67043: PUSH
67044: LD_INT 18
67046: NONEQUAL
67047: AND
67048: IFFALSE 67088
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
67050: LD_VAR 0 2
67054: PPUSH
67055: CALL_OW 257
67059: PUSH
67060: LD_INT 5
67062: PUSH
67063: LD_INT 8
67065: PUSH
67066: LD_INT 9
67068: PUSH
67069: EMPTY
67070: LIST
67071: LIST
67072: LIST
67073: IN
67074: IFFALSE 67088
// SetClass ( unit , 1 ) ;
67076: LD_VAR 0 2
67080: PPUSH
67081: LD_INT 1
67083: PPUSH
67084: CALL_OW 336
// end ;
67088: LD_VAR 0 3
67092: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
67093: LD_INT 0
67095: PPUSH
67096: PPUSH
// if not mc_bases or not skirmish then
67097: LD_EXP 99
67101: NOT
67102: PUSH
67103: LD_EXP 97
67107: NOT
67108: OR
67109: IFFALSE 67113
// exit ;
67111: GO 67229
// if GetLives ( abandoned_vehicle ) > 250 then
67113: LD_VAR 0 2
67117: PPUSH
67118: CALL_OW 256
67122: PUSH
67123: LD_INT 250
67125: GREATER
67126: IFFALSE 67130
// exit ;
67128: GO 67229
// for i = 1 to mc_bases do
67130: LD_ADDR_VAR 0 6
67134: PUSH
67135: DOUBLE
67136: LD_INT 1
67138: DEC
67139: ST_TO_ADDR
67140: LD_EXP 99
67144: PUSH
67145: FOR_TO
67146: IFFALSE 67227
// begin if driver in mc_bases [ i ] then
67148: LD_VAR 0 1
67152: PUSH
67153: LD_EXP 99
67157: PUSH
67158: LD_VAR 0 6
67162: ARRAY
67163: IN
67164: IFFALSE 67225
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
67166: LD_VAR 0 1
67170: PPUSH
67171: LD_EXP 99
67175: PUSH
67176: LD_VAR 0 6
67180: ARRAY
67181: PPUSH
67182: LD_INT 2
67184: PUSH
67185: LD_INT 30
67187: PUSH
67188: LD_INT 0
67190: PUSH
67191: EMPTY
67192: LIST
67193: LIST
67194: PUSH
67195: LD_INT 30
67197: PUSH
67198: LD_INT 1
67200: PUSH
67201: EMPTY
67202: LIST
67203: LIST
67204: PUSH
67205: EMPTY
67206: LIST
67207: LIST
67208: LIST
67209: PPUSH
67210: CALL_OW 72
67214: PUSH
67215: LD_INT 1
67217: ARRAY
67218: PPUSH
67219: CALL 105560 0 2
// break ;
67223: GO 67227
// end ; end ;
67225: GO 67145
67227: POP
67228: POP
// end ; end_of_file
67229: LD_VAR 0 5
67233: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
67234: LD_INT 0
67236: PPUSH
67237: PPUSH
// if exist_mode then
67238: LD_VAR 0 2
67242: IFFALSE 67267
// unit := CreateCharacter ( prefix & ident ) else
67244: LD_ADDR_VAR 0 5
67248: PUSH
67249: LD_VAR 0 3
67253: PUSH
67254: LD_VAR 0 1
67258: STR
67259: PPUSH
67260: CALL_OW 34
67264: ST_TO_ADDR
67265: GO 67282
// unit := NewCharacter ( ident ) ;
67267: LD_ADDR_VAR 0 5
67271: PUSH
67272: LD_VAR 0 1
67276: PPUSH
67277: CALL_OW 25
67281: ST_TO_ADDR
// result := unit ;
67282: LD_ADDR_VAR 0 4
67286: PUSH
67287: LD_VAR 0 5
67291: ST_TO_ADDR
// end ;
67292: LD_VAR 0 4
67296: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
67297: LD_INT 0
67299: PPUSH
67300: PPUSH
// if not side or not nation then
67301: LD_VAR 0 1
67305: NOT
67306: PUSH
67307: LD_VAR 0 2
67311: NOT
67312: OR
67313: IFFALSE 67317
// exit ;
67315: GO 68085
// case nation of nation_american :
67317: LD_VAR 0 2
67321: PUSH
67322: LD_INT 1
67324: DOUBLE
67325: EQUAL
67326: IFTRUE 67330
67328: GO 67544
67330: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
67331: LD_ADDR_VAR 0 4
67335: PUSH
67336: LD_INT 35
67338: PUSH
67339: LD_INT 45
67341: PUSH
67342: LD_INT 46
67344: PUSH
67345: LD_INT 47
67347: PUSH
67348: LD_INT 82
67350: PUSH
67351: LD_INT 83
67353: PUSH
67354: LD_INT 84
67356: PUSH
67357: LD_INT 85
67359: PUSH
67360: LD_INT 86
67362: PUSH
67363: LD_INT 1
67365: PUSH
67366: LD_INT 2
67368: PUSH
67369: LD_INT 6
67371: PUSH
67372: LD_INT 15
67374: PUSH
67375: LD_INT 16
67377: PUSH
67378: LD_INT 7
67380: PUSH
67381: LD_INT 12
67383: PUSH
67384: LD_INT 13
67386: PUSH
67387: LD_INT 10
67389: PUSH
67390: LD_INT 14
67392: PUSH
67393: LD_INT 20
67395: PUSH
67396: LD_INT 21
67398: PUSH
67399: LD_INT 22
67401: PUSH
67402: LD_INT 25
67404: PUSH
67405: LD_INT 32
67407: PUSH
67408: LD_INT 27
67410: PUSH
67411: LD_INT 36
67413: PUSH
67414: LD_INT 69
67416: PUSH
67417: LD_INT 39
67419: PUSH
67420: LD_INT 34
67422: PUSH
67423: LD_INT 40
67425: PUSH
67426: LD_INT 48
67428: PUSH
67429: LD_INT 49
67431: PUSH
67432: LD_INT 50
67434: PUSH
67435: LD_INT 51
67437: PUSH
67438: LD_INT 52
67440: PUSH
67441: LD_INT 53
67443: PUSH
67444: LD_INT 54
67446: PUSH
67447: LD_INT 55
67449: PUSH
67450: LD_INT 56
67452: PUSH
67453: LD_INT 57
67455: PUSH
67456: LD_INT 58
67458: PUSH
67459: LD_INT 59
67461: PUSH
67462: LD_INT 60
67464: PUSH
67465: LD_INT 61
67467: PUSH
67468: LD_INT 62
67470: PUSH
67471: LD_INT 80
67473: PUSH
67474: LD_INT 82
67476: PUSH
67477: LD_INT 83
67479: PUSH
67480: LD_INT 84
67482: PUSH
67483: LD_INT 85
67485: PUSH
67486: LD_INT 86
67488: PUSH
67489: EMPTY
67490: LIST
67491: LIST
67492: LIST
67493: LIST
67494: LIST
67495: LIST
67496: LIST
67497: LIST
67498: LIST
67499: LIST
67500: LIST
67501: LIST
67502: LIST
67503: LIST
67504: LIST
67505: LIST
67506: LIST
67507: LIST
67508: LIST
67509: LIST
67510: LIST
67511: LIST
67512: LIST
67513: LIST
67514: LIST
67515: LIST
67516: LIST
67517: LIST
67518: LIST
67519: LIST
67520: LIST
67521: LIST
67522: LIST
67523: LIST
67524: LIST
67525: LIST
67526: LIST
67527: LIST
67528: LIST
67529: LIST
67530: LIST
67531: LIST
67532: LIST
67533: LIST
67534: LIST
67535: LIST
67536: LIST
67537: LIST
67538: LIST
67539: LIST
67540: LIST
67541: ST_TO_ADDR
67542: GO 68009
67544: LD_INT 2
67546: DOUBLE
67547: EQUAL
67548: IFTRUE 67552
67550: GO 67778
67552: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
67553: LD_ADDR_VAR 0 4
67557: PUSH
67558: LD_INT 35
67560: PUSH
67561: LD_INT 45
67563: PUSH
67564: LD_INT 46
67566: PUSH
67567: LD_INT 47
67569: PUSH
67570: LD_INT 82
67572: PUSH
67573: LD_INT 83
67575: PUSH
67576: LD_INT 84
67578: PUSH
67579: LD_INT 85
67581: PUSH
67582: LD_INT 87
67584: PUSH
67585: LD_INT 70
67587: PUSH
67588: LD_INT 1
67590: PUSH
67591: LD_INT 11
67593: PUSH
67594: LD_INT 3
67596: PUSH
67597: LD_INT 4
67599: PUSH
67600: LD_INT 5
67602: PUSH
67603: LD_INT 6
67605: PUSH
67606: LD_INT 15
67608: PUSH
67609: LD_INT 18
67611: PUSH
67612: LD_INT 7
67614: PUSH
67615: LD_INT 17
67617: PUSH
67618: LD_INT 8
67620: PUSH
67621: LD_INT 20
67623: PUSH
67624: LD_INT 21
67626: PUSH
67627: LD_INT 22
67629: PUSH
67630: LD_INT 72
67632: PUSH
67633: LD_INT 26
67635: PUSH
67636: LD_INT 69
67638: PUSH
67639: LD_INT 39
67641: PUSH
67642: LD_INT 40
67644: PUSH
67645: LD_INT 41
67647: PUSH
67648: LD_INT 42
67650: PUSH
67651: LD_INT 43
67653: PUSH
67654: LD_INT 48
67656: PUSH
67657: LD_INT 49
67659: PUSH
67660: LD_INT 50
67662: PUSH
67663: LD_INT 51
67665: PUSH
67666: LD_INT 52
67668: PUSH
67669: LD_INT 53
67671: PUSH
67672: LD_INT 54
67674: PUSH
67675: LD_INT 55
67677: PUSH
67678: LD_INT 56
67680: PUSH
67681: LD_INT 60
67683: PUSH
67684: LD_INT 61
67686: PUSH
67687: LD_INT 62
67689: PUSH
67690: LD_INT 66
67692: PUSH
67693: LD_INT 67
67695: PUSH
67696: LD_INT 68
67698: PUSH
67699: LD_INT 81
67701: PUSH
67702: LD_INT 82
67704: PUSH
67705: LD_INT 83
67707: PUSH
67708: LD_INT 84
67710: PUSH
67711: LD_INT 85
67713: PUSH
67714: LD_INT 87
67716: PUSH
67717: LD_INT 88
67719: PUSH
67720: EMPTY
67721: LIST
67722: LIST
67723: LIST
67724: LIST
67725: LIST
67726: LIST
67727: LIST
67728: LIST
67729: LIST
67730: LIST
67731: LIST
67732: LIST
67733: LIST
67734: LIST
67735: LIST
67736: LIST
67737: LIST
67738: LIST
67739: LIST
67740: LIST
67741: LIST
67742: LIST
67743: LIST
67744: LIST
67745: LIST
67746: LIST
67747: LIST
67748: LIST
67749: LIST
67750: LIST
67751: LIST
67752: LIST
67753: LIST
67754: LIST
67755: LIST
67756: LIST
67757: LIST
67758: LIST
67759: LIST
67760: LIST
67761: LIST
67762: LIST
67763: LIST
67764: LIST
67765: LIST
67766: LIST
67767: LIST
67768: LIST
67769: LIST
67770: LIST
67771: LIST
67772: LIST
67773: LIST
67774: LIST
67775: ST_TO_ADDR
67776: GO 68009
67778: LD_INT 3
67780: DOUBLE
67781: EQUAL
67782: IFTRUE 67786
67784: GO 68008
67786: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
67787: LD_ADDR_VAR 0 4
67791: PUSH
67792: LD_INT 46
67794: PUSH
67795: LD_INT 47
67797: PUSH
67798: LD_INT 1
67800: PUSH
67801: LD_INT 2
67803: PUSH
67804: LD_INT 82
67806: PUSH
67807: LD_INT 83
67809: PUSH
67810: LD_INT 84
67812: PUSH
67813: LD_INT 85
67815: PUSH
67816: LD_INT 86
67818: PUSH
67819: LD_INT 11
67821: PUSH
67822: LD_INT 9
67824: PUSH
67825: LD_INT 20
67827: PUSH
67828: LD_INT 19
67830: PUSH
67831: LD_INT 21
67833: PUSH
67834: LD_INT 24
67836: PUSH
67837: LD_INT 22
67839: PUSH
67840: LD_INT 25
67842: PUSH
67843: LD_INT 28
67845: PUSH
67846: LD_INT 29
67848: PUSH
67849: LD_INT 30
67851: PUSH
67852: LD_INT 31
67854: PUSH
67855: LD_INT 37
67857: PUSH
67858: LD_INT 38
67860: PUSH
67861: LD_INT 32
67863: PUSH
67864: LD_INT 27
67866: PUSH
67867: LD_INT 33
67869: PUSH
67870: LD_INT 69
67872: PUSH
67873: LD_INT 39
67875: PUSH
67876: LD_INT 34
67878: PUSH
67879: LD_INT 40
67881: PUSH
67882: LD_INT 71
67884: PUSH
67885: LD_INT 23
67887: PUSH
67888: LD_INT 44
67890: PUSH
67891: LD_INT 48
67893: PUSH
67894: LD_INT 49
67896: PUSH
67897: LD_INT 50
67899: PUSH
67900: LD_INT 51
67902: PUSH
67903: LD_INT 52
67905: PUSH
67906: LD_INT 53
67908: PUSH
67909: LD_INT 54
67911: PUSH
67912: LD_INT 55
67914: PUSH
67915: LD_INT 56
67917: PUSH
67918: LD_INT 57
67920: PUSH
67921: LD_INT 58
67923: PUSH
67924: LD_INT 59
67926: PUSH
67927: LD_INT 63
67929: PUSH
67930: LD_INT 64
67932: PUSH
67933: LD_INT 65
67935: PUSH
67936: LD_INT 82
67938: PUSH
67939: LD_INT 83
67941: PUSH
67942: LD_INT 84
67944: PUSH
67945: LD_INT 85
67947: PUSH
67948: LD_INT 86
67950: PUSH
67951: EMPTY
67952: LIST
67953: LIST
67954: LIST
67955: LIST
67956: LIST
67957: LIST
67958: LIST
67959: LIST
67960: LIST
67961: LIST
67962: LIST
67963: LIST
67964: LIST
67965: LIST
67966: LIST
67967: LIST
67968: LIST
67969: LIST
67970: LIST
67971: LIST
67972: LIST
67973: LIST
67974: LIST
67975: LIST
67976: LIST
67977: LIST
67978: LIST
67979: LIST
67980: LIST
67981: LIST
67982: LIST
67983: LIST
67984: LIST
67985: LIST
67986: LIST
67987: LIST
67988: LIST
67989: LIST
67990: LIST
67991: LIST
67992: LIST
67993: LIST
67994: LIST
67995: LIST
67996: LIST
67997: LIST
67998: LIST
67999: LIST
68000: LIST
68001: LIST
68002: LIST
68003: LIST
68004: LIST
68005: ST_TO_ADDR
68006: GO 68009
68008: POP
// if state > - 1 and state < 3 then
68009: LD_VAR 0 3
68013: PUSH
68014: LD_INT 1
68016: NEG
68017: GREATER
68018: PUSH
68019: LD_VAR 0 3
68023: PUSH
68024: LD_INT 3
68026: LESS
68027: AND
68028: IFFALSE 68085
// for i in result do
68030: LD_ADDR_VAR 0 5
68034: PUSH
68035: LD_VAR 0 4
68039: PUSH
68040: FOR_IN
68041: IFFALSE 68083
// if GetTech ( i , side ) <> state then
68043: LD_VAR 0 5
68047: PPUSH
68048: LD_VAR 0 1
68052: PPUSH
68053: CALL_OW 321
68057: PUSH
68058: LD_VAR 0 3
68062: NONEQUAL
68063: IFFALSE 68081
// result := result diff i ;
68065: LD_ADDR_VAR 0 4
68069: PUSH
68070: LD_VAR 0 4
68074: PUSH
68075: LD_VAR 0 5
68079: DIFF
68080: ST_TO_ADDR
68081: GO 68040
68083: POP
68084: POP
// end ;
68085: LD_VAR 0 4
68089: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
68090: LD_INT 0
68092: PPUSH
68093: PPUSH
68094: PPUSH
// result := true ;
68095: LD_ADDR_VAR 0 3
68099: PUSH
68100: LD_INT 1
68102: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
68103: LD_ADDR_VAR 0 5
68107: PUSH
68108: LD_VAR 0 2
68112: PPUSH
68113: CALL_OW 480
68117: ST_TO_ADDR
// if not tmp then
68118: LD_VAR 0 5
68122: NOT
68123: IFFALSE 68127
// exit ;
68125: GO 68176
// for i in tmp do
68127: LD_ADDR_VAR 0 4
68131: PUSH
68132: LD_VAR 0 5
68136: PUSH
68137: FOR_IN
68138: IFFALSE 68174
// if GetTech ( i , side ) <> state_researched then
68140: LD_VAR 0 4
68144: PPUSH
68145: LD_VAR 0 1
68149: PPUSH
68150: CALL_OW 321
68154: PUSH
68155: LD_INT 2
68157: NONEQUAL
68158: IFFALSE 68172
// begin result := false ;
68160: LD_ADDR_VAR 0 3
68164: PUSH
68165: LD_INT 0
68167: ST_TO_ADDR
// exit ;
68168: POP
68169: POP
68170: GO 68176
// end ;
68172: GO 68137
68174: POP
68175: POP
// end ;
68176: LD_VAR 0 3
68180: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
68181: LD_INT 0
68183: PPUSH
68184: PPUSH
68185: PPUSH
68186: PPUSH
68187: PPUSH
68188: PPUSH
68189: PPUSH
68190: PPUSH
68191: PPUSH
68192: PPUSH
68193: PPUSH
68194: PPUSH
68195: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
68196: LD_VAR 0 1
68200: NOT
68201: PUSH
68202: LD_VAR 0 1
68206: PPUSH
68207: CALL_OW 257
68211: PUSH
68212: LD_INT 9
68214: NONEQUAL
68215: OR
68216: IFFALSE 68220
// exit ;
68218: GO 68793
// side := GetSide ( unit ) ;
68220: LD_ADDR_VAR 0 9
68224: PUSH
68225: LD_VAR 0 1
68229: PPUSH
68230: CALL_OW 255
68234: ST_TO_ADDR
// tech_space := tech_spacanom ;
68235: LD_ADDR_VAR 0 12
68239: PUSH
68240: LD_INT 29
68242: ST_TO_ADDR
// tech_time := tech_taurad ;
68243: LD_ADDR_VAR 0 13
68247: PUSH
68248: LD_INT 28
68250: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
68251: LD_ADDR_VAR 0 11
68255: PUSH
68256: LD_VAR 0 1
68260: PPUSH
68261: CALL_OW 310
68265: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
68266: LD_VAR 0 11
68270: PPUSH
68271: CALL_OW 247
68275: PUSH
68276: LD_INT 2
68278: EQUAL
68279: IFFALSE 68283
// exit ;
68281: GO 68793
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
68283: LD_ADDR_VAR 0 8
68287: PUSH
68288: LD_INT 81
68290: PUSH
68291: LD_VAR 0 9
68295: PUSH
68296: EMPTY
68297: LIST
68298: LIST
68299: PUSH
68300: LD_INT 3
68302: PUSH
68303: LD_INT 21
68305: PUSH
68306: LD_INT 3
68308: PUSH
68309: EMPTY
68310: LIST
68311: LIST
68312: PUSH
68313: EMPTY
68314: LIST
68315: LIST
68316: PUSH
68317: EMPTY
68318: LIST
68319: LIST
68320: PPUSH
68321: CALL_OW 69
68325: ST_TO_ADDR
// if not tmp then
68326: LD_VAR 0 8
68330: NOT
68331: IFFALSE 68335
// exit ;
68333: GO 68793
// if in_unit then
68335: LD_VAR 0 11
68339: IFFALSE 68363
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
68341: LD_ADDR_VAR 0 10
68345: PUSH
68346: LD_VAR 0 8
68350: PPUSH
68351: LD_VAR 0 11
68355: PPUSH
68356: CALL_OW 74
68360: ST_TO_ADDR
68361: GO 68383
// enemy := NearestUnitToUnit ( tmp , unit ) ;
68363: LD_ADDR_VAR 0 10
68367: PUSH
68368: LD_VAR 0 8
68372: PPUSH
68373: LD_VAR 0 1
68377: PPUSH
68378: CALL_OW 74
68382: ST_TO_ADDR
// if not enemy then
68383: LD_VAR 0 10
68387: NOT
68388: IFFALSE 68392
// exit ;
68390: GO 68793
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
68392: LD_VAR 0 11
68396: PUSH
68397: LD_VAR 0 11
68401: PPUSH
68402: LD_VAR 0 10
68406: PPUSH
68407: CALL_OW 296
68411: PUSH
68412: LD_INT 13
68414: GREATER
68415: AND
68416: PUSH
68417: LD_VAR 0 1
68421: PPUSH
68422: LD_VAR 0 10
68426: PPUSH
68427: CALL_OW 296
68431: PUSH
68432: LD_INT 12
68434: GREATER
68435: OR
68436: IFFALSE 68440
// exit ;
68438: GO 68793
// missile := [ 1 ] ;
68440: LD_ADDR_VAR 0 14
68444: PUSH
68445: LD_INT 1
68447: PUSH
68448: EMPTY
68449: LIST
68450: ST_TO_ADDR
// if Researched ( side , tech_space ) then
68451: LD_VAR 0 9
68455: PPUSH
68456: LD_VAR 0 12
68460: PPUSH
68461: CALL_OW 325
68465: IFFALSE 68494
// missile := Replace ( missile , missile + 1 , 2 ) ;
68467: LD_ADDR_VAR 0 14
68471: PUSH
68472: LD_VAR 0 14
68476: PPUSH
68477: LD_VAR 0 14
68481: PUSH
68482: LD_INT 1
68484: PLUS
68485: PPUSH
68486: LD_INT 2
68488: PPUSH
68489: CALL_OW 1
68493: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
68494: LD_VAR 0 9
68498: PPUSH
68499: LD_VAR 0 13
68503: PPUSH
68504: CALL_OW 325
68508: PUSH
68509: LD_VAR 0 10
68513: PPUSH
68514: CALL_OW 255
68518: PPUSH
68519: LD_VAR 0 13
68523: PPUSH
68524: CALL_OW 325
68528: NOT
68529: AND
68530: IFFALSE 68559
// missile := Replace ( missile , missile + 1 , 3 ) ;
68532: LD_ADDR_VAR 0 14
68536: PUSH
68537: LD_VAR 0 14
68541: PPUSH
68542: LD_VAR 0 14
68546: PUSH
68547: LD_INT 1
68549: PLUS
68550: PPUSH
68551: LD_INT 3
68553: PPUSH
68554: CALL_OW 1
68558: ST_TO_ADDR
// if missile < 2 then
68559: LD_VAR 0 14
68563: PUSH
68564: LD_INT 2
68566: LESS
68567: IFFALSE 68571
// exit ;
68569: GO 68793
// x := GetX ( enemy ) ;
68571: LD_ADDR_VAR 0 4
68575: PUSH
68576: LD_VAR 0 10
68580: PPUSH
68581: CALL_OW 250
68585: ST_TO_ADDR
// y := GetY ( enemy ) ;
68586: LD_ADDR_VAR 0 5
68590: PUSH
68591: LD_VAR 0 10
68595: PPUSH
68596: CALL_OW 251
68600: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
68601: LD_ADDR_VAR 0 6
68605: PUSH
68606: LD_VAR 0 4
68610: PUSH
68611: LD_INT 1
68613: NEG
68614: PPUSH
68615: LD_INT 1
68617: PPUSH
68618: CALL_OW 12
68622: PLUS
68623: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
68624: LD_ADDR_VAR 0 7
68628: PUSH
68629: LD_VAR 0 5
68633: PUSH
68634: LD_INT 1
68636: NEG
68637: PPUSH
68638: LD_INT 1
68640: PPUSH
68641: CALL_OW 12
68645: PLUS
68646: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
68647: LD_VAR 0 6
68651: PPUSH
68652: LD_VAR 0 7
68656: PPUSH
68657: CALL_OW 488
68661: NOT
68662: IFFALSE 68684
// begin _x := x ;
68664: LD_ADDR_VAR 0 6
68668: PUSH
68669: LD_VAR 0 4
68673: ST_TO_ADDR
// _y := y ;
68674: LD_ADDR_VAR 0 7
68678: PUSH
68679: LD_VAR 0 5
68683: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
68684: LD_ADDR_VAR 0 3
68688: PUSH
68689: LD_INT 1
68691: PPUSH
68692: LD_VAR 0 14
68696: PPUSH
68697: CALL_OW 12
68701: ST_TO_ADDR
// case i of 1 :
68702: LD_VAR 0 3
68706: PUSH
68707: LD_INT 1
68709: DOUBLE
68710: EQUAL
68711: IFTRUE 68715
68713: GO 68732
68715: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
68716: LD_VAR 0 1
68720: PPUSH
68721: LD_VAR 0 10
68725: PPUSH
68726: CALL_OW 115
68730: GO 68793
68732: LD_INT 2
68734: DOUBLE
68735: EQUAL
68736: IFTRUE 68740
68738: GO 68762
68740: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
68741: LD_VAR 0 1
68745: PPUSH
68746: LD_VAR 0 6
68750: PPUSH
68751: LD_VAR 0 7
68755: PPUSH
68756: CALL_OW 153
68760: GO 68793
68762: LD_INT 3
68764: DOUBLE
68765: EQUAL
68766: IFTRUE 68770
68768: GO 68792
68770: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
68771: LD_VAR 0 1
68775: PPUSH
68776: LD_VAR 0 6
68780: PPUSH
68781: LD_VAR 0 7
68785: PPUSH
68786: CALL_OW 154
68790: GO 68793
68792: POP
// end ;
68793: LD_VAR 0 2
68797: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
68798: LD_INT 0
68800: PPUSH
68801: PPUSH
68802: PPUSH
68803: PPUSH
68804: PPUSH
68805: PPUSH
// if not unit or not building then
68806: LD_VAR 0 1
68810: NOT
68811: PUSH
68812: LD_VAR 0 2
68816: NOT
68817: OR
68818: IFFALSE 68822
// exit ;
68820: GO 68980
// x := GetX ( building ) ;
68822: LD_ADDR_VAR 0 5
68826: PUSH
68827: LD_VAR 0 2
68831: PPUSH
68832: CALL_OW 250
68836: ST_TO_ADDR
// y := GetY ( building ) ;
68837: LD_ADDR_VAR 0 6
68841: PUSH
68842: LD_VAR 0 2
68846: PPUSH
68847: CALL_OW 251
68851: ST_TO_ADDR
// for i = 0 to 5 do
68852: LD_ADDR_VAR 0 4
68856: PUSH
68857: DOUBLE
68858: LD_INT 0
68860: DEC
68861: ST_TO_ADDR
68862: LD_INT 5
68864: PUSH
68865: FOR_TO
68866: IFFALSE 68978
// begin _x := ShiftX ( x , i , 3 ) ;
68868: LD_ADDR_VAR 0 7
68872: PUSH
68873: LD_VAR 0 5
68877: PPUSH
68878: LD_VAR 0 4
68882: PPUSH
68883: LD_INT 3
68885: PPUSH
68886: CALL_OW 272
68890: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
68891: LD_ADDR_VAR 0 8
68895: PUSH
68896: LD_VAR 0 6
68900: PPUSH
68901: LD_VAR 0 4
68905: PPUSH
68906: LD_INT 3
68908: PPUSH
68909: CALL_OW 273
68913: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
68914: LD_VAR 0 7
68918: PPUSH
68919: LD_VAR 0 8
68923: PPUSH
68924: CALL_OW 488
68928: NOT
68929: IFFALSE 68933
// continue ;
68931: GO 68865
// if HexInfo ( _x , _y ) = 0 then
68933: LD_VAR 0 7
68937: PPUSH
68938: LD_VAR 0 8
68942: PPUSH
68943: CALL_OW 428
68947: PUSH
68948: LD_INT 0
68950: EQUAL
68951: IFFALSE 68976
// begin ComMoveXY ( unit , _x , _y ) ;
68953: LD_VAR 0 1
68957: PPUSH
68958: LD_VAR 0 7
68962: PPUSH
68963: LD_VAR 0 8
68967: PPUSH
68968: CALL_OW 111
// exit ;
68972: POP
68973: POP
68974: GO 68980
// end ; end ;
68976: GO 68865
68978: POP
68979: POP
// end ;
68980: LD_VAR 0 3
68984: RET
// export function ScanBase ( side , base_area ) ; begin
68985: LD_INT 0
68987: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
68988: LD_ADDR_VAR 0 3
68992: PUSH
68993: LD_VAR 0 2
68997: PPUSH
68998: LD_INT 81
69000: PUSH
69001: LD_VAR 0 1
69005: PUSH
69006: EMPTY
69007: LIST
69008: LIST
69009: PPUSH
69010: CALL_OW 70
69014: ST_TO_ADDR
// end ;
69015: LD_VAR 0 3
69019: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
69020: LD_INT 0
69022: PPUSH
69023: PPUSH
69024: PPUSH
69025: PPUSH
// result := false ;
69026: LD_ADDR_VAR 0 2
69030: PUSH
69031: LD_INT 0
69033: ST_TO_ADDR
// side := GetSide ( unit ) ;
69034: LD_ADDR_VAR 0 3
69038: PUSH
69039: LD_VAR 0 1
69043: PPUSH
69044: CALL_OW 255
69048: ST_TO_ADDR
// nat := GetNation ( unit ) ;
69049: LD_ADDR_VAR 0 4
69053: PUSH
69054: LD_VAR 0 1
69058: PPUSH
69059: CALL_OW 248
69063: ST_TO_ADDR
// case nat of 1 :
69064: LD_VAR 0 4
69068: PUSH
69069: LD_INT 1
69071: DOUBLE
69072: EQUAL
69073: IFTRUE 69077
69075: GO 69088
69077: POP
// tech := tech_lassight ; 2 :
69078: LD_ADDR_VAR 0 5
69082: PUSH
69083: LD_INT 12
69085: ST_TO_ADDR
69086: GO 69127
69088: LD_INT 2
69090: DOUBLE
69091: EQUAL
69092: IFTRUE 69096
69094: GO 69107
69096: POP
// tech := tech_mortar ; 3 :
69097: LD_ADDR_VAR 0 5
69101: PUSH
69102: LD_INT 41
69104: ST_TO_ADDR
69105: GO 69127
69107: LD_INT 3
69109: DOUBLE
69110: EQUAL
69111: IFTRUE 69115
69113: GO 69126
69115: POP
// tech := tech_bazooka ; end ;
69116: LD_ADDR_VAR 0 5
69120: PUSH
69121: LD_INT 44
69123: ST_TO_ADDR
69124: GO 69127
69126: POP
// if Researched ( side , tech ) then
69127: LD_VAR 0 3
69131: PPUSH
69132: LD_VAR 0 5
69136: PPUSH
69137: CALL_OW 325
69141: IFFALSE 69168
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
69143: LD_ADDR_VAR 0 2
69147: PUSH
69148: LD_INT 5
69150: PUSH
69151: LD_INT 8
69153: PUSH
69154: LD_INT 9
69156: PUSH
69157: EMPTY
69158: LIST
69159: LIST
69160: LIST
69161: PUSH
69162: LD_VAR 0 4
69166: ARRAY
69167: ST_TO_ADDR
// end ;
69168: LD_VAR 0 2
69172: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
69173: LD_INT 0
69175: PPUSH
69176: PPUSH
69177: PPUSH
// if not mines then
69178: LD_VAR 0 2
69182: NOT
69183: IFFALSE 69187
// exit ;
69185: GO 69331
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69187: LD_ADDR_VAR 0 5
69191: PUSH
69192: LD_INT 81
69194: PUSH
69195: LD_VAR 0 1
69199: PUSH
69200: EMPTY
69201: LIST
69202: LIST
69203: PUSH
69204: LD_INT 3
69206: PUSH
69207: LD_INT 21
69209: PUSH
69210: LD_INT 3
69212: PUSH
69213: EMPTY
69214: LIST
69215: LIST
69216: PUSH
69217: EMPTY
69218: LIST
69219: LIST
69220: PUSH
69221: EMPTY
69222: LIST
69223: LIST
69224: PPUSH
69225: CALL_OW 69
69229: ST_TO_ADDR
// for i in mines do
69230: LD_ADDR_VAR 0 4
69234: PUSH
69235: LD_VAR 0 2
69239: PUSH
69240: FOR_IN
69241: IFFALSE 69329
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
69243: LD_VAR 0 4
69247: PUSH
69248: LD_INT 1
69250: ARRAY
69251: PPUSH
69252: LD_VAR 0 4
69256: PUSH
69257: LD_INT 2
69259: ARRAY
69260: PPUSH
69261: CALL_OW 458
69265: NOT
69266: IFFALSE 69270
// continue ;
69268: GO 69240
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
69270: LD_VAR 0 4
69274: PUSH
69275: LD_INT 1
69277: ARRAY
69278: PPUSH
69279: LD_VAR 0 4
69283: PUSH
69284: LD_INT 2
69286: ARRAY
69287: PPUSH
69288: CALL_OW 428
69292: PUSH
69293: LD_VAR 0 5
69297: IN
69298: IFFALSE 69327
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
69300: LD_VAR 0 4
69304: PUSH
69305: LD_INT 1
69307: ARRAY
69308: PPUSH
69309: LD_VAR 0 4
69313: PUSH
69314: LD_INT 2
69316: ARRAY
69317: PPUSH
69318: LD_VAR 0 1
69322: PPUSH
69323: CALL_OW 456
// end ;
69327: GO 69240
69329: POP
69330: POP
// end ;
69331: LD_VAR 0 3
69335: RET
// export function Count ( array ) ; var i ; begin
69336: LD_INT 0
69338: PPUSH
69339: PPUSH
// result := 0 ;
69340: LD_ADDR_VAR 0 2
69344: PUSH
69345: LD_INT 0
69347: ST_TO_ADDR
// for i in array do
69348: LD_ADDR_VAR 0 3
69352: PUSH
69353: LD_VAR 0 1
69357: PUSH
69358: FOR_IN
69359: IFFALSE 69383
// if i then
69361: LD_VAR 0 3
69365: IFFALSE 69381
// result := result + 1 ;
69367: LD_ADDR_VAR 0 2
69371: PUSH
69372: LD_VAR 0 2
69376: PUSH
69377: LD_INT 1
69379: PLUS
69380: ST_TO_ADDR
69381: GO 69358
69383: POP
69384: POP
// end ;
69385: LD_VAR 0 2
69389: RET
// export function IsEmpty ( building ) ; begin
69390: LD_INT 0
69392: PPUSH
// if not building then
69393: LD_VAR 0 1
69397: NOT
69398: IFFALSE 69402
// exit ;
69400: GO 69445
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
69402: LD_ADDR_VAR 0 2
69406: PUSH
69407: LD_VAR 0 1
69411: PUSH
69412: LD_INT 22
69414: PUSH
69415: LD_VAR 0 1
69419: PPUSH
69420: CALL_OW 255
69424: PUSH
69425: EMPTY
69426: LIST
69427: LIST
69428: PUSH
69429: LD_INT 58
69431: PUSH
69432: EMPTY
69433: LIST
69434: PUSH
69435: EMPTY
69436: LIST
69437: LIST
69438: PPUSH
69439: CALL_OW 69
69443: IN
69444: ST_TO_ADDR
// end ;
69445: LD_VAR 0 2
69449: RET
// export function IsNotFull ( building ) ; var places ; begin
69450: LD_INT 0
69452: PPUSH
69453: PPUSH
// if not building then
69454: LD_VAR 0 1
69458: NOT
69459: IFFALSE 69463
// exit ;
69461: GO 69634
// result := false ;
69463: LD_ADDR_VAR 0 2
69467: PUSH
69468: LD_INT 0
69470: ST_TO_ADDR
// places := 0 ;
69471: LD_ADDR_VAR 0 3
69475: PUSH
69476: LD_INT 0
69478: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
69479: LD_VAR 0 1
69483: PPUSH
69484: CALL_OW 266
69488: PUSH
69489: LD_INT 0
69491: DOUBLE
69492: EQUAL
69493: IFTRUE 69551
69495: LD_INT 1
69497: DOUBLE
69498: EQUAL
69499: IFTRUE 69551
69501: LD_INT 6
69503: DOUBLE
69504: EQUAL
69505: IFTRUE 69551
69507: LD_INT 7
69509: DOUBLE
69510: EQUAL
69511: IFTRUE 69551
69513: LD_INT 8
69515: DOUBLE
69516: EQUAL
69517: IFTRUE 69551
69519: LD_INT 4
69521: DOUBLE
69522: EQUAL
69523: IFTRUE 69551
69525: LD_INT 5
69527: DOUBLE
69528: EQUAL
69529: IFTRUE 69551
69531: LD_INT 2
69533: DOUBLE
69534: EQUAL
69535: IFTRUE 69551
69537: LD_INT 3
69539: DOUBLE
69540: EQUAL
69541: IFTRUE 69551
69543: LD_INT 35
69545: DOUBLE
69546: EQUAL
69547: IFTRUE 69551
69549: GO 69562
69551: POP
// places := 6 ; b_bunker , b_breastwork :
69552: LD_ADDR_VAR 0 3
69556: PUSH
69557: LD_INT 6
69559: ST_TO_ADDR
69560: GO 69607
69562: LD_INT 32
69564: DOUBLE
69565: EQUAL
69566: IFTRUE 69576
69568: LD_INT 31
69570: DOUBLE
69571: EQUAL
69572: IFTRUE 69576
69574: GO 69587
69576: POP
// places := 1 ; b_control_tower :
69577: LD_ADDR_VAR 0 3
69581: PUSH
69582: LD_INT 1
69584: ST_TO_ADDR
69585: GO 69607
69587: LD_INT 36
69589: DOUBLE
69590: EQUAL
69591: IFTRUE 69595
69593: GO 69606
69595: POP
// places := 3 ; end ;
69596: LD_ADDR_VAR 0 3
69600: PUSH
69601: LD_INT 3
69603: ST_TO_ADDR
69604: GO 69607
69606: POP
// if places then
69607: LD_VAR 0 3
69611: IFFALSE 69634
// result := UnitsInside ( building ) < places ;
69613: LD_ADDR_VAR 0 2
69617: PUSH
69618: LD_VAR 0 1
69622: PPUSH
69623: CALL_OW 313
69627: PUSH
69628: LD_VAR 0 3
69632: LESS
69633: ST_TO_ADDR
// end ;
69634: LD_VAR 0 2
69638: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
69639: LD_INT 0
69641: PPUSH
69642: PPUSH
69643: PPUSH
69644: PPUSH
// tmp := [ ] ;
69645: LD_ADDR_VAR 0 3
69649: PUSH
69650: EMPTY
69651: ST_TO_ADDR
// list := [ ] ;
69652: LD_ADDR_VAR 0 5
69656: PUSH
69657: EMPTY
69658: ST_TO_ADDR
// for i = 16 to 25 do
69659: LD_ADDR_VAR 0 4
69663: PUSH
69664: DOUBLE
69665: LD_INT 16
69667: DEC
69668: ST_TO_ADDR
69669: LD_INT 25
69671: PUSH
69672: FOR_TO
69673: IFFALSE 69746
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
69675: LD_ADDR_VAR 0 3
69679: PUSH
69680: LD_VAR 0 3
69684: PUSH
69685: LD_INT 22
69687: PUSH
69688: LD_VAR 0 1
69692: PPUSH
69693: CALL_OW 255
69697: PUSH
69698: EMPTY
69699: LIST
69700: LIST
69701: PUSH
69702: LD_INT 91
69704: PUSH
69705: LD_VAR 0 1
69709: PUSH
69710: LD_INT 6
69712: PUSH
69713: EMPTY
69714: LIST
69715: LIST
69716: LIST
69717: PUSH
69718: LD_INT 30
69720: PUSH
69721: LD_VAR 0 4
69725: PUSH
69726: EMPTY
69727: LIST
69728: LIST
69729: PUSH
69730: EMPTY
69731: LIST
69732: LIST
69733: LIST
69734: PUSH
69735: EMPTY
69736: LIST
69737: PPUSH
69738: CALL_OW 69
69742: ADD
69743: ST_TO_ADDR
69744: GO 69672
69746: POP
69747: POP
// for i = 1 to tmp do
69748: LD_ADDR_VAR 0 4
69752: PUSH
69753: DOUBLE
69754: LD_INT 1
69756: DEC
69757: ST_TO_ADDR
69758: LD_VAR 0 3
69762: PUSH
69763: FOR_TO
69764: IFFALSE 69852
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
69766: LD_ADDR_VAR 0 5
69770: PUSH
69771: LD_VAR 0 5
69775: PUSH
69776: LD_VAR 0 3
69780: PUSH
69781: LD_VAR 0 4
69785: ARRAY
69786: PPUSH
69787: CALL_OW 266
69791: PUSH
69792: LD_VAR 0 3
69796: PUSH
69797: LD_VAR 0 4
69801: ARRAY
69802: PPUSH
69803: CALL_OW 250
69807: PUSH
69808: LD_VAR 0 3
69812: PUSH
69813: LD_VAR 0 4
69817: ARRAY
69818: PPUSH
69819: CALL_OW 251
69823: PUSH
69824: LD_VAR 0 3
69828: PUSH
69829: LD_VAR 0 4
69833: ARRAY
69834: PPUSH
69835: CALL_OW 254
69839: PUSH
69840: EMPTY
69841: LIST
69842: LIST
69843: LIST
69844: LIST
69845: PUSH
69846: EMPTY
69847: LIST
69848: ADD
69849: ST_TO_ADDR
69850: GO 69763
69852: POP
69853: POP
// result := list ;
69854: LD_ADDR_VAR 0 2
69858: PUSH
69859: LD_VAR 0 5
69863: ST_TO_ADDR
// end ;
69864: LD_VAR 0 2
69868: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
69869: LD_INT 0
69871: PPUSH
69872: PPUSH
69873: PPUSH
69874: PPUSH
69875: PPUSH
69876: PPUSH
69877: PPUSH
// if not factory then
69878: LD_VAR 0 1
69882: NOT
69883: IFFALSE 69887
// exit ;
69885: GO 70480
// if control = control_apeman then
69887: LD_VAR 0 4
69891: PUSH
69892: LD_INT 5
69894: EQUAL
69895: IFFALSE 70004
// begin tmp := UnitsInside ( factory ) ;
69897: LD_ADDR_VAR 0 8
69901: PUSH
69902: LD_VAR 0 1
69906: PPUSH
69907: CALL_OW 313
69911: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
69912: LD_VAR 0 8
69916: PPUSH
69917: LD_INT 25
69919: PUSH
69920: LD_INT 12
69922: PUSH
69923: EMPTY
69924: LIST
69925: LIST
69926: PPUSH
69927: CALL_OW 72
69931: NOT
69932: IFFALSE 69942
// control := control_manual ;
69934: LD_ADDR_VAR 0 4
69938: PUSH
69939: LD_INT 1
69941: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
69942: LD_ADDR_VAR 0 8
69946: PUSH
69947: LD_VAR 0 1
69951: PPUSH
69952: CALL 69639 0 1
69956: ST_TO_ADDR
// if tmp then
69957: LD_VAR 0 8
69961: IFFALSE 70004
// begin for i in tmp do
69963: LD_ADDR_VAR 0 7
69967: PUSH
69968: LD_VAR 0 8
69972: PUSH
69973: FOR_IN
69974: IFFALSE 70002
// if i [ 1 ] = b_ext_radio then
69976: LD_VAR 0 7
69980: PUSH
69981: LD_INT 1
69983: ARRAY
69984: PUSH
69985: LD_INT 22
69987: EQUAL
69988: IFFALSE 70000
// begin control := control_remote ;
69990: LD_ADDR_VAR 0 4
69994: PUSH
69995: LD_INT 2
69997: ST_TO_ADDR
// break ;
69998: GO 70002
// end ;
70000: GO 69973
70002: POP
70003: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70004: LD_VAR 0 1
70008: PPUSH
70009: LD_VAR 0 2
70013: PPUSH
70014: LD_VAR 0 3
70018: PPUSH
70019: LD_VAR 0 4
70023: PPUSH
70024: LD_VAR 0 5
70028: PPUSH
70029: CALL_OW 448
70033: IFFALSE 70068
// begin result := [ chassis , engine , control , weapon ] ;
70035: LD_ADDR_VAR 0 6
70039: PUSH
70040: LD_VAR 0 2
70044: PUSH
70045: LD_VAR 0 3
70049: PUSH
70050: LD_VAR 0 4
70054: PUSH
70055: LD_VAR 0 5
70059: PUSH
70060: EMPTY
70061: LIST
70062: LIST
70063: LIST
70064: LIST
70065: ST_TO_ADDR
// exit ;
70066: GO 70480
// end ; _chassis := AvailableChassisList ( factory ) ;
70068: LD_ADDR_VAR 0 9
70072: PUSH
70073: LD_VAR 0 1
70077: PPUSH
70078: CALL_OW 475
70082: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
70083: LD_ADDR_VAR 0 11
70087: PUSH
70088: LD_VAR 0 1
70092: PPUSH
70093: CALL_OW 476
70097: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
70098: LD_ADDR_VAR 0 12
70102: PUSH
70103: LD_VAR 0 1
70107: PPUSH
70108: CALL_OW 477
70112: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
70113: LD_ADDR_VAR 0 10
70117: PUSH
70118: LD_VAR 0 1
70122: PPUSH
70123: CALL_OW 478
70127: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
70128: LD_VAR 0 9
70132: NOT
70133: PUSH
70134: LD_VAR 0 11
70138: NOT
70139: OR
70140: PUSH
70141: LD_VAR 0 12
70145: NOT
70146: OR
70147: PUSH
70148: LD_VAR 0 10
70152: NOT
70153: OR
70154: IFFALSE 70189
// begin result := [ chassis , engine , control , weapon ] ;
70156: LD_ADDR_VAR 0 6
70160: PUSH
70161: LD_VAR 0 2
70165: PUSH
70166: LD_VAR 0 3
70170: PUSH
70171: LD_VAR 0 4
70175: PUSH
70176: LD_VAR 0 5
70180: PUSH
70181: EMPTY
70182: LIST
70183: LIST
70184: LIST
70185: LIST
70186: ST_TO_ADDR
// exit ;
70187: GO 70480
// end ; if not chassis in _chassis then
70189: LD_VAR 0 2
70193: PUSH
70194: LD_VAR 0 9
70198: IN
70199: NOT
70200: IFFALSE 70226
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
70202: LD_ADDR_VAR 0 2
70206: PUSH
70207: LD_VAR 0 9
70211: PUSH
70212: LD_INT 1
70214: PPUSH
70215: LD_VAR 0 9
70219: PPUSH
70220: CALL_OW 12
70224: ARRAY
70225: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
70226: LD_VAR 0 2
70230: PPUSH
70231: LD_VAR 0 3
70235: PPUSH
70236: CALL 70485 0 2
70240: NOT
70241: IFFALSE 70300
// repeat engine := _engine [ 1 ] ;
70243: LD_ADDR_VAR 0 3
70247: PUSH
70248: LD_VAR 0 11
70252: PUSH
70253: LD_INT 1
70255: ARRAY
70256: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
70257: LD_ADDR_VAR 0 11
70261: PUSH
70262: LD_VAR 0 11
70266: PPUSH
70267: LD_INT 1
70269: PPUSH
70270: CALL_OW 3
70274: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
70275: LD_VAR 0 2
70279: PPUSH
70280: LD_VAR 0 3
70284: PPUSH
70285: CALL 70485 0 2
70289: PUSH
70290: LD_VAR 0 11
70294: PUSH
70295: EMPTY
70296: EQUAL
70297: OR
70298: IFFALSE 70243
// if not control in _control then
70300: LD_VAR 0 4
70304: PUSH
70305: LD_VAR 0 12
70309: IN
70310: NOT
70311: IFFALSE 70337
// control := _control [ rand ( 1 , _control ) ] ;
70313: LD_ADDR_VAR 0 4
70317: PUSH
70318: LD_VAR 0 12
70322: PUSH
70323: LD_INT 1
70325: PPUSH
70326: LD_VAR 0 12
70330: PPUSH
70331: CALL_OW 12
70335: ARRAY
70336: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
70337: LD_VAR 0 2
70341: PPUSH
70342: LD_VAR 0 5
70346: PPUSH
70347: CALL 70705 0 2
70351: NOT
70352: IFFALSE 70411
// repeat weapon := _weapon [ 1 ] ;
70354: LD_ADDR_VAR 0 5
70358: PUSH
70359: LD_VAR 0 10
70363: PUSH
70364: LD_INT 1
70366: ARRAY
70367: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
70368: LD_ADDR_VAR 0 10
70372: PUSH
70373: LD_VAR 0 10
70377: PPUSH
70378: LD_INT 1
70380: PPUSH
70381: CALL_OW 3
70385: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
70386: LD_VAR 0 2
70390: PPUSH
70391: LD_VAR 0 5
70395: PPUSH
70396: CALL 70705 0 2
70400: PUSH
70401: LD_VAR 0 10
70405: PUSH
70406: EMPTY
70407: EQUAL
70408: OR
70409: IFFALSE 70354
// result := [ ] ;
70411: LD_ADDR_VAR 0 6
70415: PUSH
70416: EMPTY
70417: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70418: LD_VAR 0 1
70422: PPUSH
70423: LD_VAR 0 2
70427: PPUSH
70428: LD_VAR 0 3
70432: PPUSH
70433: LD_VAR 0 4
70437: PPUSH
70438: LD_VAR 0 5
70442: PPUSH
70443: CALL_OW 448
70447: IFFALSE 70480
// result := [ chassis , engine , control , weapon ] ;
70449: LD_ADDR_VAR 0 6
70453: PUSH
70454: LD_VAR 0 2
70458: PUSH
70459: LD_VAR 0 3
70463: PUSH
70464: LD_VAR 0 4
70468: PUSH
70469: LD_VAR 0 5
70473: PUSH
70474: EMPTY
70475: LIST
70476: LIST
70477: LIST
70478: LIST
70479: ST_TO_ADDR
// end ;
70480: LD_VAR 0 6
70484: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
70485: LD_INT 0
70487: PPUSH
// if not chassis or not engine then
70488: LD_VAR 0 1
70492: NOT
70493: PUSH
70494: LD_VAR 0 2
70498: NOT
70499: OR
70500: IFFALSE 70504
// exit ;
70502: GO 70700
// case engine of engine_solar :
70504: LD_VAR 0 2
70508: PUSH
70509: LD_INT 2
70511: DOUBLE
70512: EQUAL
70513: IFTRUE 70517
70515: GO 70555
70517: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
70518: LD_ADDR_VAR 0 3
70522: PUSH
70523: LD_INT 11
70525: PUSH
70526: LD_INT 12
70528: PUSH
70529: LD_INT 13
70531: PUSH
70532: LD_INT 14
70534: PUSH
70535: LD_INT 1
70537: PUSH
70538: LD_INT 2
70540: PUSH
70541: LD_INT 3
70543: PUSH
70544: EMPTY
70545: LIST
70546: LIST
70547: LIST
70548: LIST
70549: LIST
70550: LIST
70551: LIST
70552: ST_TO_ADDR
70553: GO 70684
70555: LD_INT 1
70557: DOUBLE
70558: EQUAL
70559: IFTRUE 70563
70561: GO 70625
70563: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
70564: LD_ADDR_VAR 0 3
70568: PUSH
70569: LD_INT 11
70571: PUSH
70572: LD_INT 12
70574: PUSH
70575: LD_INT 13
70577: PUSH
70578: LD_INT 14
70580: PUSH
70581: LD_INT 1
70583: PUSH
70584: LD_INT 2
70586: PUSH
70587: LD_INT 3
70589: PUSH
70590: LD_INT 4
70592: PUSH
70593: LD_INT 5
70595: PUSH
70596: LD_INT 21
70598: PUSH
70599: LD_INT 23
70601: PUSH
70602: LD_INT 22
70604: PUSH
70605: LD_INT 24
70607: PUSH
70608: EMPTY
70609: LIST
70610: LIST
70611: LIST
70612: LIST
70613: LIST
70614: LIST
70615: LIST
70616: LIST
70617: LIST
70618: LIST
70619: LIST
70620: LIST
70621: LIST
70622: ST_TO_ADDR
70623: GO 70684
70625: LD_INT 3
70627: DOUBLE
70628: EQUAL
70629: IFTRUE 70633
70631: GO 70683
70633: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70634: LD_ADDR_VAR 0 3
70638: PUSH
70639: LD_INT 13
70641: PUSH
70642: LD_INT 14
70644: PUSH
70645: LD_INT 2
70647: PUSH
70648: LD_INT 3
70650: PUSH
70651: LD_INT 4
70653: PUSH
70654: LD_INT 5
70656: PUSH
70657: LD_INT 21
70659: PUSH
70660: LD_INT 22
70662: PUSH
70663: LD_INT 23
70665: PUSH
70666: LD_INT 24
70668: PUSH
70669: EMPTY
70670: LIST
70671: LIST
70672: LIST
70673: LIST
70674: LIST
70675: LIST
70676: LIST
70677: LIST
70678: LIST
70679: LIST
70680: ST_TO_ADDR
70681: GO 70684
70683: POP
// result := ( chassis in result ) ;
70684: LD_ADDR_VAR 0 3
70688: PUSH
70689: LD_VAR 0 1
70693: PUSH
70694: LD_VAR 0 3
70698: IN
70699: ST_TO_ADDR
// end ;
70700: LD_VAR 0 3
70704: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
70705: LD_INT 0
70707: PPUSH
// if not chassis or not weapon then
70708: LD_VAR 0 1
70712: NOT
70713: PUSH
70714: LD_VAR 0 2
70718: NOT
70719: OR
70720: IFFALSE 70724
// exit ;
70722: GO 71784
// case weapon of us_machine_gun :
70724: LD_VAR 0 2
70728: PUSH
70729: LD_INT 2
70731: DOUBLE
70732: EQUAL
70733: IFTRUE 70737
70735: GO 70767
70737: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
70738: LD_ADDR_VAR 0 3
70742: PUSH
70743: LD_INT 1
70745: PUSH
70746: LD_INT 2
70748: PUSH
70749: LD_INT 3
70751: PUSH
70752: LD_INT 4
70754: PUSH
70755: LD_INT 5
70757: PUSH
70758: EMPTY
70759: LIST
70760: LIST
70761: LIST
70762: LIST
70763: LIST
70764: ST_TO_ADDR
70765: GO 71768
70767: LD_INT 3
70769: DOUBLE
70770: EQUAL
70771: IFTRUE 70775
70773: GO 70805
70775: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
70776: LD_ADDR_VAR 0 3
70780: PUSH
70781: LD_INT 1
70783: PUSH
70784: LD_INT 2
70786: PUSH
70787: LD_INT 3
70789: PUSH
70790: LD_INT 4
70792: PUSH
70793: LD_INT 5
70795: PUSH
70796: EMPTY
70797: LIST
70798: LIST
70799: LIST
70800: LIST
70801: LIST
70802: ST_TO_ADDR
70803: GO 71768
70805: LD_INT 11
70807: DOUBLE
70808: EQUAL
70809: IFTRUE 70813
70811: GO 70843
70813: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
70814: LD_ADDR_VAR 0 3
70818: PUSH
70819: LD_INT 1
70821: PUSH
70822: LD_INT 2
70824: PUSH
70825: LD_INT 3
70827: PUSH
70828: LD_INT 4
70830: PUSH
70831: LD_INT 5
70833: PUSH
70834: EMPTY
70835: LIST
70836: LIST
70837: LIST
70838: LIST
70839: LIST
70840: ST_TO_ADDR
70841: GO 71768
70843: LD_INT 4
70845: DOUBLE
70846: EQUAL
70847: IFTRUE 70851
70849: GO 70877
70851: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
70852: LD_ADDR_VAR 0 3
70856: PUSH
70857: LD_INT 2
70859: PUSH
70860: LD_INT 3
70862: PUSH
70863: LD_INT 4
70865: PUSH
70866: LD_INT 5
70868: PUSH
70869: EMPTY
70870: LIST
70871: LIST
70872: LIST
70873: LIST
70874: ST_TO_ADDR
70875: GO 71768
70877: LD_INT 5
70879: DOUBLE
70880: EQUAL
70881: IFTRUE 70885
70883: GO 70911
70885: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
70886: LD_ADDR_VAR 0 3
70890: PUSH
70891: LD_INT 2
70893: PUSH
70894: LD_INT 3
70896: PUSH
70897: LD_INT 4
70899: PUSH
70900: LD_INT 5
70902: PUSH
70903: EMPTY
70904: LIST
70905: LIST
70906: LIST
70907: LIST
70908: ST_TO_ADDR
70909: GO 71768
70911: LD_INT 9
70913: DOUBLE
70914: EQUAL
70915: IFTRUE 70919
70917: GO 70945
70919: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
70920: LD_ADDR_VAR 0 3
70924: PUSH
70925: LD_INT 2
70927: PUSH
70928: LD_INT 3
70930: PUSH
70931: LD_INT 4
70933: PUSH
70934: LD_INT 5
70936: PUSH
70937: EMPTY
70938: LIST
70939: LIST
70940: LIST
70941: LIST
70942: ST_TO_ADDR
70943: GO 71768
70945: LD_INT 7
70947: DOUBLE
70948: EQUAL
70949: IFTRUE 70953
70951: GO 70979
70953: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
70954: LD_ADDR_VAR 0 3
70958: PUSH
70959: LD_INT 2
70961: PUSH
70962: LD_INT 3
70964: PUSH
70965: LD_INT 4
70967: PUSH
70968: LD_INT 5
70970: PUSH
70971: EMPTY
70972: LIST
70973: LIST
70974: LIST
70975: LIST
70976: ST_TO_ADDR
70977: GO 71768
70979: LD_INT 12
70981: DOUBLE
70982: EQUAL
70983: IFTRUE 70987
70985: GO 71013
70987: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
70988: LD_ADDR_VAR 0 3
70992: PUSH
70993: LD_INT 2
70995: PUSH
70996: LD_INT 3
70998: PUSH
70999: LD_INT 4
71001: PUSH
71002: LD_INT 5
71004: PUSH
71005: EMPTY
71006: LIST
71007: LIST
71008: LIST
71009: LIST
71010: ST_TO_ADDR
71011: GO 71768
71013: LD_INT 13
71015: DOUBLE
71016: EQUAL
71017: IFTRUE 71021
71019: GO 71047
71021: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
71022: LD_ADDR_VAR 0 3
71026: PUSH
71027: LD_INT 2
71029: PUSH
71030: LD_INT 3
71032: PUSH
71033: LD_INT 4
71035: PUSH
71036: LD_INT 5
71038: PUSH
71039: EMPTY
71040: LIST
71041: LIST
71042: LIST
71043: LIST
71044: ST_TO_ADDR
71045: GO 71768
71047: LD_INT 14
71049: DOUBLE
71050: EQUAL
71051: IFTRUE 71055
71053: GO 71073
71055: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
71056: LD_ADDR_VAR 0 3
71060: PUSH
71061: LD_INT 4
71063: PUSH
71064: LD_INT 5
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: ST_TO_ADDR
71071: GO 71768
71073: LD_INT 6
71075: DOUBLE
71076: EQUAL
71077: IFTRUE 71081
71079: GO 71099
71081: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
71082: LD_ADDR_VAR 0 3
71086: PUSH
71087: LD_INT 4
71089: PUSH
71090: LD_INT 5
71092: PUSH
71093: EMPTY
71094: LIST
71095: LIST
71096: ST_TO_ADDR
71097: GO 71768
71099: LD_INT 10
71101: DOUBLE
71102: EQUAL
71103: IFTRUE 71107
71105: GO 71125
71107: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
71108: LD_ADDR_VAR 0 3
71112: PUSH
71113: LD_INT 4
71115: PUSH
71116: LD_INT 5
71118: PUSH
71119: EMPTY
71120: LIST
71121: LIST
71122: ST_TO_ADDR
71123: GO 71768
71125: LD_INT 22
71127: DOUBLE
71128: EQUAL
71129: IFTRUE 71133
71131: GO 71159
71133: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
71134: LD_ADDR_VAR 0 3
71138: PUSH
71139: LD_INT 11
71141: PUSH
71142: LD_INT 12
71144: PUSH
71145: LD_INT 13
71147: PUSH
71148: LD_INT 14
71150: PUSH
71151: EMPTY
71152: LIST
71153: LIST
71154: LIST
71155: LIST
71156: ST_TO_ADDR
71157: GO 71768
71159: LD_INT 23
71161: DOUBLE
71162: EQUAL
71163: IFTRUE 71167
71165: GO 71193
71167: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
71168: LD_ADDR_VAR 0 3
71172: PUSH
71173: LD_INT 11
71175: PUSH
71176: LD_INT 12
71178: PUSH
71179: LD_INT 13
71181: PUSH
71182: LD_INT 14
71184: PUSH
71185: EMPTY
71186: LIST
71187: LIST
71188: LIST
71189: LIST
71190: ST_TO_ADDR
71191: GO 71768
71193: LD_INT 24
71195: DOUBLE
71196: EQUAL
71197: IFTRUE 71201
71199: GO 71227
71201: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
71202: LD_ADDR_VAR 0 3
71206: PUSH
71207: LD_INT 11
71209: PUSH
71210: LD_INT 12
71212: PUSH
71213: LD_INT 13
71215: PUSH
71216: LD_INT 14
71218: PUSH
71219: EMPTY
71220: LIST
71221: LIST
71222: LIST
71223: LIST
71224: ST_TO_ADDR
71225: GO 71768
71227: LD_INT 30
71229: DOUBLE
71230: EQUAL
71231: IFTRUE 71235
71233: GO 71261
71235: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
71236: LD_ADDR_VAR 0 3
71240: PUSH
71241: LD_INT 11
71243: PUSH
71244: LD_INT 12
71246: PUSH
71247: LD_INT 13
71249: PUSH
71250: LD_INT 14
71252: PUSH
71253: EMPTY
71254: LIST
71255: LIST
71256: LIST
71257: LIST
71258: ST_TO_ADDR
71259: GO 71768
71261: LD_INT 25
71263: DOUBLE
71264: EQUAL
71265: IFTRUE 71269
71267: GO 71287
71269: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
71270: LD_ADDR_VAR 0 3
71274: PUSH
71275: LD_INT 13
71277: PUSH
71278: LD_INT 14
71280: PUSH
71281: EMPTY
71282: LIST
71283: LIST
71284: ST_TO_ADDR
71285: GO 71768
71287: LD_INT 27
71289: DOUBLE
71290: EQUAL
71291: IFTRUE 71295
71293: GO 71313
71295: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
71296: LD_ADDR_VAR 0 3
71300: PUSH
71301: LD_INT 13
71303: PUSH
71304: LD_INT 14
71306: PUSH
71307: EMPTY
71308: LIST
71309: LIST
71310: ST_TO_ADDR
71311: GO 71768
71313: LD_INT 92
71315: DOUBLE
71316: EQUAL
71317: IFTRUE 71321
71319: GO 71347
71321: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
71322: LD_ADDR_VAR 0 3
71326: PUSH
71327: LD_INT 11
71329: PUSH
71330: LD_INT 12
71332: PUSH
71333: LD_INT 13
71335: PUSH
71336: LD_INT 14
71338: PUSH
71339: EMPTY
71340: LIST
71341: LIST
71342: LIST
71343: LIST
71344: ST_TO_ADDR
71345: GO 71768
71347: LD_INT 28
71349: DOUBLE
71350: EQUAL
71351: IFTRUE 71355
71353: GO 71373
71355: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
71356: LD_ADDR_VAR 0 3
71360: PUSH
71361: LD_INT 13
71363: PUSH
71364: LD_INT 14
71366: PUSH
71367: EMPTY
71368: LIST
71369: LIST
71370: ST_TO_ADDR
71371: GO 71768
71373: LD_INT 29
71375: DOUBLE
71376: EQUAL
71377: IFTRUE 71381
71379: GO 71399
71381: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
71382: LD_ADDR_VAR 0 3
71386: PUSH
71387: LD_INT 13
71389: PUSH
71390: LD_INT 14
71392: PUSH
71393: EMPTY
71394: LIST
71395: LIST
71396: ST_TO_ADDR
71397: GO 71768
71399: LD_INT 31
71401: DOUBLE
71402: EQUAL
71403: IFTRUE 71407
71405: GO 71425
71407: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
71408: LD_ADDR_VAR 0 3
71412: PUSH
71413: LD_INT 13
71415: PUSH
71416: LD_INT 14
71418: PUSH
71419: EMPTY
71420: LIST
71421: LIST
71422: ST_TO_ADDR
71423: GO 71768
71425: LD_INT 26
71427: DOUBLE
71428: EQUAL
71429: IFTRUE 71433
71431: GO 71451
71433: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
71434: LD_ADDR_VAR 0 3
71438: PUSH
71439: LD_INT 13
71441: PUSH
71442: LD_INT 14
71444: PUSH
71445: EMPTY
71446: LIST
71447: LIST
71448: ST_TO_ADDR
71449: GO 71768
71451: LD_INT 42
71453: DOUBLE
71454: EQUAL
71455: IFTRUE 71459
71457: GO 71485
71459: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
71460: LD_ADDR_VAR 0 3
71464: PUSH
71465: LD_INT 21
71467: PUSH
71468: LD_INT 22
71470: PUSH
71471: LD_INT 23
71473: PUSH
71474: LD_INT 24
71476: PUSH
71477: EMPTY
71478: LIST
71479: LIST
71480: LIST
71481: LIST
71482: ST_TO_ADDR
71483: GO 71768
71485: LD_INT 43
71487: DOUBLE
71488: EQUAL
71489: IFTRUE 71493
71491: GO 71519
71493: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
71494: LD_ADDR_VAR 0 3
71498: PUSH
71499: LD_INT 21
71501: PUSH
71502: LD_INT 22
71504: PUSH
71505: LD_INT 23
71507: PUSH
71508: LD_INT 24
71510: PUSH
71511: EMPTY
71512: LIST
71513: LIST
71514: LIST
71515: LIST
71516: ST_TO_ADDR
71517: GO 71768
71519: LD_INT 44
71521: DOUBLE
71522: EQUAL
71523: IFTRUE 71527
71525: GO 71553
71527: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
71528: LD_ADDR_VAR 0 3
71532: PUSH
71533: LD_INT 21
71535: PUSH
71536: LD_INT 22
71538: PUSH
71539: LD_INT 23
71541: PUSH
71542: LD_INT 24
71544: PUSH
71545: EMPTY
71546: LIST
71547: LIST
71548: LIST
71549: LIST
71550: ST_TO_ADDR
71551: GO 71768
71553: LD_INT 45
71555: DOUBLE
71556: EQUAL
71557: IFTRUE 71561
71559: GO 71587
71561: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
71562: LD_ADDR_VAR 0 3
71566: PUSH
71567: LD_INT 21
71569: PUSH
71570: LD_INT 22
71572: PUSH
71573: LD_INT 23
71575: PUSH
71576: LD_INT 24
71578: PUSH
71579: EMPTY
71580: LIST
71581: LIST
71582: LIST
71583: LIST
71584: ST_TO_ADDR
71585: GO 71768
71587: LD_INT 49
71589: DOUBLE
71590: EQUAL
71591: IFTRUE 71595
71593: GO 71621
71595: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
71596: LD_ADDR_VAR 0 3
71600: PUSH
71601: LD_INT 21
71603: PUSH
71604: LD_INT 22
71606: PUSH
71607: LD_INT 23
71609: PUSH
71610: LD_INT 24
71612: PUSH
71613: EMPTY
71614: LIST
71615: LIST
71616: LIST
71617: LIST
71618: ST_TO_ADDR
71619: GO 71768
71621: LD_INT 51
71623: DOUBLE
71624: EQUAL
71625: IFTRUE 71629
71627: GO 71655
71629: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
71630: LD_ADDR_VAR 0 3
71634: PUSH
71635: LD_INT 21
71637: PUSH
71638: LD_INT 22
71640: PUSH
71641: LD_INT 23
71643: PUSH
71644: LD_INT 24
71646: PUSH
71647: EMPTY
71648: LIST
71649: LIST
71650: LIST
71651: LIST
71652: ST_TO_ADDR
71653: GO 71768
71655: LD_INT 52
71657: DOUBLE
71658: EQUAL
71659: IFTRUE 71663
71661: GO 71689
71663: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
71664: LD_ADDR_VAR 0 3
71668: PUSH
71669: LD_INT 21
71671: PUSH
71672: LD_INT 22
71674: PUSH
71675: LD_INT 23
71677: PUSH
71678: LD_INT 24
71680: PUSH
71681: EMPTY
71682: LIST
71683: LIST
71684: LIST
71685: LIST
71686: ST_TO_ADDR
71687: GO 71768
71689: LD_INT 53
71691: DOUBLE
71692: EQUAL
71693: IFTRUE 71697
71695: GO 71715
71697: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
71698: LD_ADDR_VAR 0 3
71702: PUSH
71703: LD_INT 23
71705: PUSH
71706: LD_INT 24
71708: PUSH
71709: EMPTY
71710: LIST
71711: LIST
71712: ST_TO_ADDR
71713: GO 71768
71715: LD_INT 46
71717: DOUBLE
71718: EQUAL
71719: IFTRUE 71723
71721: GO 71741
71723: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
71724: LD_ADDR_VAR 0 3
71728: PUSH
71729: LD_INT 23
71731: PUSH
71732: LD_INT 24
71734: PUSH
71735: EMPTY
71736: LIST
71737: LIST
71738: ST_TO_ADDR
71739: GO 71768
71741: LD_INT 47
71743: DOUBLE
71744: EQUAL
71745: IFTRUE 71749
71747: GO 71767
71749: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
71750: LD_ADDR_VAR 0 3
71754: PUSH
71755: LD_INT 23
71757: PUSH
71758: LD_INT 24
71760: PUSH
71761: EMPTY
71762: LIST
71763: LIST
71764: ST_TO_ADDR
71765: GO 71768
71767: POP
// result := ( chassis in result ) ;
71768: LD_ADDR_VAR 0 3
71772: PUSH
71773: LD_VAR 0 1
71777: PUSH
71778: LD_VAR 0 3
71782: IN
71783: ST_TO_ADDR
// end ;
71784: LD_VAR 0 3
71788: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
71789: LD_INT 0
71791: PPUSH
71792: PPUSH
71793: PPUSH
71794: PPUSH
71795: PPUSH
71796: PPUSH
71797: PPUSH
// result := array ;
71798: LD_ADDR_VAR 0 5
71802: PUSH
71803: LD_VAR 0 1
71807: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
71808: LD_VAR 0 1
71812: NOT
71813: PUSH
71814: LD_VAR 0 2
71818: NOT
71819: OR
71820: PUSH
71821: LD_VAR 0 3
71825: NOT
71826: OR
71827: PUSH
71828: LD_VAR 0 2
71832: PUSH
71833: LD_VAR 0 1
71837: GREATER
71838: OR
71839: PUSH
71840: LD_VAR 0 3
71844: PUSH
71845: LD_VAR 0 1
71849: GREATER
71850: OR
71851: IFFALSE 71855
// exit ;
71853: GO 72151
// if direction then
71855: LD_VAR 0 4
71859: IFFALSE 71923
// begin d := 1 ;
71861: LD_ADDR_VAR 0 9
71865: PUSH
71866: LD_INT 1
71868: ST_TO_ADDR
// if i_from > i_to then
71869: LD_VAR 0 2
71873: PUSH
71874: LD_VAR 0 3
71878: GREATER
71879: IFFALSE 71905
// length := ( array - i_from ) + i_to else
71881: LD_ADDR_VAR 0 11
71885: PUSH
71886: LD_VAR 0 1
71890: PUSH
71891: LD_VAR 0 2
71895: MINUS
71896: PUSH
71897: LD_VAR 0 3
71901: PLUS
71902: ST_TO_ADDR
71903: GO 71921
// length := i_to - i_from ;
71905: LD_ADDR_VAR 0 11
71909: PUSH
71910: LD_VAR 0 3
71914: PUSH
71915: LD_VAR 0 2
71919: MINUS
71920: ST_TO_ADDR
// end else
71921: GO 71984
// begin d := - 1 ;
71923: LD_ADDR_VAR 0 9
71927: PUSH
71928: LD_INT 1
71930: NEG
71931: ST_TO_ADDR
// if i_from > i_to then
71932: LD_VAR 0 2
71936: PUSH
71937: LD_VAR 0 3
71941: GREATER
71942: IFFALSE 71962
// length := i_from - i_to else
71944: LD_ADDR_VAR 0 11
71948: PUSH
71949: LD_VAR 0 2
71953: PUSH
71954: LD_VAR 0 3
71958: MINUS
71959: ST_TO_ADDR
71960: GO 71984
// length := ( array - i_to ) + i_from ;
71962: LD_ADDR_VAR 0 11
71966: PUSH
71967: LD_VAR 0 1
71971: PUSH
71972: LD_VAR 0 3
71976: MINUS
71977: PUSH
71978: LD_VAR 0 2
71982: PLUS
71983: ST_TO_ADDR
// end ; if not length then
71984: LD_VAR 0 11
71988: NOT
71989: IFFALSE 71993
// exit ;
71991: GO 72151
// tmp := array ;
71993: LD_ADDR_VAR 0 10
71997: PUSH
71998: LD_VAR 0 1
72002: ST_TO_ADDR
// for i = 1 to length do
72003: LD_ADDR_VAR 0 6
72007: PUSH
72008: DOUBLE
72009: LD_INT 1
72011: DEC
72012: ST_TO_ADDR
72013: LD_VAR 0 11
72017: PUSH
72018: FOR_TO
72019: IFFALSE 72139
// begin for j = 1 to array do
72021: LD_ADDR_VAR 0 7
72025: PUSH
72026: DOUBLE
72027: LD_INT 1
72029: DEC
72030: ST_TO_ADDR
72031: LD_VAR 0 1
72035: PUSH
72036: FOR_TO
72037: IFFALSE 72125
// begin k := j + d ;
72039: LD_ADDR_VAR 0 8
72043: PUSH
72044: LD_VAR 0 7
72048: PUSH
72049: LD_VAR 0 9
72053: PLUS
72054: ST_TO_ADDR
// if k > array then
72055: LD_VAR 0 8
72059: PUSH
72060: LD_VAR 0 1
72064: GREATER
72065: IFFALSE 72075
// k := 1 ;
72067: LD_ADDR_VAR 0 8
72071: PUSH
72072: LD_INT 1
72074: ST_TO_ADDR
// if not k then
72075: LD_VAR 0 8
72079: NOT
72080: IFFALSE 72092
// k := array ;
72082: LD_ADDR_VAR 0 8
72086: PUSH
72087: LD_VAR 0 1
72091: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
72092: LD_ADDR_VAR 0 10
72096: PUSH
72097: LD_VAR 0 10
72101: PPUSH
72102: LD_VAR 0 8
72106: PPUSH
72107: LD_VAR 0 1
72111: PUSH
72112: LD_VAR 0 7
72116: ARRAY
72117: PPUSH
72118: CALL_OW 1
72122: ST_TO_ADDR
// end ;
72123: GO 72036
72125: POP
72126: POP
// array := tmp ;
72127: LD_ADDR_VAR 0 1
72131: PUSH
72132: LD_VAR 0 10
72136: ST_TO_ADDR
// end ;
72137: GO 72018
72139: POP
72140: POP
// result := array ;
72141: LD_ADDR_VAR 0 5
72145: PUSH
72146: LD_VAR 0 1
72150: ST_TO_ADDR
// end ;
72151: LD_VAR 0 5
72155: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
72156: LD_INT 0
72158: PPUSH
72159: PPUSH
// result := 0 ;
72160: LD_ADDR_VAR 0 3
72164: PUSH
72165: LD_INT 0
72167: ST_TO_ADDR
// if not array or not value in array then
72168: LD_VAR 0 1
72172: NOT
72173: PUSH
72174: LD_VAR 0 2
72178: PUSH
72179: LD_VAR 0 1
72183: IN
72184: NOT
72185: OR
72186: IFFALSE 72190
// exit ;
72188: GO 72244
// for i = 1 to array do
72190: LD_ADDR_VAR 0 4
72194: PUSH
72195: DOUBLE
72196: LD_INT 1
72198: DEC
72199: ST_TO_ADDR
72200: LD_VAR 0 1
72204: PUSH
72205: FOR_TO
72206: IFFALSE 72242
// if value = array [ i ] then
72208: LD_VAR 0 2
72212: PUSH
72213: LD_VAR 0 1
72217: PUSH
72218: LD_VAR 0 4
72222: ARRAY
72223: EQUAL
72224: IFFALSE 72240
// begin result := i ;
72226: LD_ADDR_VAR 0 3
72230: PUSH
72231: LD_VAR 0 4
72235: ST_TO_ADDR
// exit ;
72236: POP
72237: POP
72238: GO 72244
// end ;
72240: GO 72205
72242: POP
72243: POP
// end ;
72244: LD_VAR 0 3
72248: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
72249: LD_INT 0
72251: PPUSH
// vc_chassis := chassis ;
72252: LD_ADDR_OWVAR 37
72256: PUSH
72257: LD_VAR 0 1
72261: ST_TO_ADDR
// vc_engine := engine ;
72262: LD_ADDR_OWVAR 39
72266: PUSH
72267: LD_VAR 0 2
72271: ST_TO_ADDR
// vc_control := control ;
72272: LD_ADDR_OWVAR 38
72276: PUSH
72277: LD_VAR 0 3
72281: ST_TO_ADDR
// vc_weapon := weapon ;
72282: LD_ADDR_OWVAR 40
72286: PUSH
72287: LD_VAR 0 4
72291: ST_TO_ADDR
// vc_fuel_battery := fuel ;
72292: LD_ADDR_OWVAR 41
72296: PUSH
72297: LD_VAR 0 5
72301: ST_TO_ADDR
// end ;
72302: LD_VAR 0 6
72306: RET
// export function WantPlant ( unit ) ; var task ; begin
72307: LD_INT 0
72309: PPUSH
72310: PPUSH
// result := false ;
72311: LD_ADDR_VAR 0 2
72315: PUSH
72316: LD_INT 0
72318: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
72319: LD_ADDR_VAR 0 3
72323: PUSH
72324: LD_VAR 0 1
72328: PPUSH
72329: CALL_OW 437
72333: ST_TO_ADDR
// if task then
72334: LD_VAR 0 3
72338: IFFALSE 72366
// if task [ 1 ] [ 1 ] = p then
72340: LD_VAR 0 3
72344: PUSH
72345: LD_INT 1
72347: ARRAY
72348: PUSH
72349: LD_INT 1
72351: ARRAY
72352: PUSH
72353: LD_STRING p
72355: EQUAL
72356: IFFALSE 72366
// result := true ;
72358: LD_ADDR_VAR 0 2
72362: PUSH
72363: LD_INT 1
72365: ST_TO_ADDR
// end ;
72366: LD_VAR 0 2
72370: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
72371: LD_INT 0
72373: PPUSH
72374: PPUSH
72375: PPUSH
72376: PPUSH
// if pos < 1 then
72377: LD_VAR 0 2
72381: PUSH
72382: LD_INT 1
72384: LESS
72385: IFFALSE 72389
// exit ;
72387: GO 72692
// if pos = 1 then
72389: LD_VAR 0 2
72393: PUSH
72394: LD_INT 1
72396: EQUAL
72397: IFFALSE 72430
// result := Replace ( arr , pos [ 1 ] , value ) else
72399: LD_ADDR_VAR 0 4
72403: PUSH
72404: LD_VAR 0 1
72408: PPUSH
72409: LD_VAR 0 2
72413: PUSH
72414: LD_INT 1
72416: ARRAY
72417: PPUSH
72418: LD_VAR 0 3
72422: PPUSH
72423: CALL_OW 1
72427: ST_TO_ADDR
72428: GO 72692
// begin tmp := arr ;
72430: LD_ADDR_VAR 0 6
72434: PUSH
72435: LD_VAR 0 1
72439: ST_TO_ADDR
// s_arr := [ tmp ] ;
72440: LD_ADDR_VAR 0 7
72444: PUSH
72445: LD_VAR 0 6
72449: PUSH
72450: EMPTY
72451: LIST
72452: ST_TO_ADDR
// for i = 1 to pos - 1 do
72453: LD_ADDR_VAR 0 5
72457: PUSH
72458: DOUBLE
72459: LD_INT 1
72461: DEC
72462: ST_TO_ADDR
72463: LD_VAR 0 2
72467: PUSH
72468: LD_INT 1
72470: MINUS
72471: PUSH
72472: FOR_TO
72473: IFFALSE 72518
// begin tmp := tmp [ pos [ i ] ] ;
72475: LD_ADDR_VAR 0 6
72479: PUSH
72480: LD_VAR 0 6
72484: PUSH
72485: LD_VAR 0 2
72489: PUSH
72490: LD_VAR 0 5
72494: ARRAY
72495: ARRAY
72496: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
72497: LD_ADDR_VAR 0 7
72501: PUSH
72502: LD_VAR 0 7
72506: PUSH
72507: LD_VAR 0 6
72511: PUSH
72512: EMPTY
72513: LIST
72514: ADD
72515: ST_TO_ADDR
// end ;
72516: GO 72472
72518: POP
72519: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
72520: LD_ADDR_VAR 0 6
72524: PUSH
72525: LD_VAR 0 6
72529: PPUSH
72530: LD_VAR 0 2
72534: PUSH
72535: LD_VAR 0 2
72539: ARRAY
72540: PPUSH
72541: LD_VAR 0 3
72545: PPUSH
72546: CALL_OW 1
72550: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
72551: LD_ADDR_VAR 0 7
72555: PUSH
72556: LD_VAR 0 7
72560: PPUSH
72561: LD_VAR 0 7
72565: PPUSH
72566: LD_VAR 0 6
72570: PPUSH
72571: CALL_OW 1
72575: ST_TO_ADDR
// for i = s_arr downto 2 do
72576: LD_ADDR_VAR 0 5
72580: PUSH
72581: DOUBLE
72582: LD_VAR 0 7
72586: INC
72587: ST_TO_ADDR
72588: LD_INT 2
72590: PUSH
72591: FOR_DOWNTO
72592: IFFALSE 72676
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
72594: LD_ADDR_VAR 0 6
72598: PUSH
72599: LD_VAR 0 7
72603: PUSH
72604: LD_VAR 0 5
72608: PUSH
72609: LD_INT 1
72611: MINUS
72612: ARRAY
72613: PPUSH
72614: LD_VAR 0 2
72618: PUSH
72619: LD_VAR 0 5
72623: PUSH
72624: LD_INT 1
72626: MINUS
72627: ARRAY
72628: PPUSH
72629: LD_VAR 0 7
72633: PUSH
72634: LD_VAR 0 5
72638: ARRAY
72639: PPUSH
72640: CALL_OW 1
72644: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
72645: LD_ADDR_VAR 0 7
72649: PUSH
72650: LD_VAR 0 7
72654: PPUSH
72655: LD_VAR 0 5
72659: PUSH
72660: LD_INT 1
72662: MINUS
72663: PPUSH
72664: LD_VAR 0 6
72668: PPUSH
72669: CALL_OW 1
72673: ST_TO_ADDR
// end ;
72674: GO 72591
72676: POP
72677: POP
// result := s_arr [ 1 ] ;
72678: LD_ADDR_VAR 0 4
72682: PUSH
72683: LD_VAR 0 7
72687: PUSH
72688: LD_INT 1
72690: ARRAY
72691: ST_TO_ADDR
// end ; end ;
72692: LD_VAR 0 4
72696: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
72697: LD_INT 0
72699: PPUSH
72700: PPUSH
// if not list then
72701: LD_VAR 0 1
72705: NOT
72706: IFFALSE 72710
// exit ;
72708: GO 72801
// i := list [ pos1 ] ;
72710: LD_ADDR_VAR 0 5
72714: PUSH
72715: LD_VAR 0 1
72719: PUSH
72720: LD_VAR 0 2
72724: ARRAY
72725: ST_TO_ADDR
// if not i then
72726: LD_VAR 0 5
72730: NOT
72731: IFFALSE 72735
// exit ;
72733: GO 72801
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
72735: LD_ADDR_VAR 0 1
72739: PUSH
72740: LD_VAR 0 1
72744: PPUSH
72745: LD_VAR 0 2
72749: PPUSH
72750: LD_VAR 0 1
72754: PUSH
72755: LD_VAR 0 3
72759: ARRAY
72760: PPUSH
72761: CALL_OW 1
72765: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
72766: LD_ADDR_VAR 0 1
72770: PUSH
72771: LD_VAR 0 1
72775: PPUSH
72776: LD_VAR 0 3
72780: PPUSH
72781: LD_VAR 0 5
72785: PPUSH
72786: CALL_OW 1
72790: ST_TO_ADDR
// result := list ;
72791: LD_ADDR_VAR 0 4
72795: PUSH
72796: LD_VAR 0 1
72800: ST_TO_ADDR
// end ;
72801: LD_VAR 0 4
72805: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
72806: LD_INT 0
72808: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
72809: LD_ADDR_VAR 0 5
72813: PUSH
72814: LD_VAR 0 1
72818: PPUSH
72819: CALL_OW 250
72823: PPUSH
72824: LD_VAR 0 1
72828: PPUSH
72829: CALL_OW 251
72833: PPUSH
72834: LD_VAR 0 2
72838: PPUSH
72839: LD_VAR 0 3
72843: PPUSH
72844: LD_VAR 0 4
72848: PPUSH
72849: CALL 72859 0 5
72853: ST_TO_ADDR
// end ;
72854: LD_VAR 0 5
72858: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
72859: LD_INT 0
72861: PPUSH
72862: PPUSH
72863: PPUSH
72864: PPUSH
// if not list then
72865: LD_VAR 0 3
72869: NOT
72870: IFFALSE 72874
// exit ;
72872: GO 73262
// result := [ ] ;
72874: LD_ADDR_VAR 0 6
72878: PUSH
72879: EMPTY
72880: ST_TO_ADDR
// for i in list do
72881: LD_ADDR_VAR 0 7
72885: PUSH
72886: LD_VAR 0 3
72890: PUSH
72891: FOR_IN
72892: IFFALSE 73094
// begin tmp := GetDistUnitXY ( i , x , y ) ;
72894: LD_ADDR_VAR 0 9
72898: PUSH
72899: LD_VAR 0 7
72903: PPUSH
72904: LD_VAR 0 1
72908: PPUSH
72909: LD_VAR 0 2
72913: PPUSH
72914: CALL_OW 297
72918: ST_TO_ADDR
// if not result then
72919: LD_VAR 0 6
72923: NOT
72924: IFFALSE 72950
// result := [ [ i , tmp ] ] else
72926: LD_ADDR_VAR 0 6
72930: PUSH
72931: LD_VAR 0 7
72935: PUSH
72936: LD_VAR 0 9
72940: PUSH
72941: EMPTY
72942: LIST
72943: LIST
72944: PUSH
72945: EMPTY
72946: LIST
72947: ST_TO_ADDR
72948: GO 73092
// begin if result [ result ] [ 2 ] < tmp then
72950: LD_VAR 0 6
72954: PUSH
72955: LD_VAR 0 6
72959: ARRAY
72960: PUSH
72961: LD_INT 2
72963: ARRAY
72964: PUSH
72965: LD_VAR 0 9
72969: LESS
72970: IFFALSE 73012
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
72972: LD_ADDR_VAR 0 6
72976: PUSH
72977: LD_VAR 0 6
72981: PPUSH
72982: LD_VAR 0 6
72986: PUSH
72987: LD_INT 1
72989: PLUS
72990: PPUSH
72991: LD_VAR 0 7
72995: PUSH
72996: LD_VAR 0 9
73000: PUSH
73001: EMPTY
73002: LIST
73003: LIST
73004: PPUSH
73005: CALL_OW 2
73009: ST_TO_ADDR
73010: GO 73092
// for j = 1 to result do
73012: LD_ADDR_VAR 0 8
73016: PUSH
73017: DOUBLE
73018: LD_INT 1
73020: DEC
73021: ST_TO_ADDR
73022: LD_VAR 0 6
73026: PUSH
73027: FOR_TO
73028: IFFALSE 73090
// begin if tmp < result [ j ] [ 2 ] then
73030: LD_VAR 0 9
73034: PUSH
73035: LD_VAR 0 6
73039: PUSH
73040: LD_VAR 0 8
73044: ARRAY
73045: PUSH
73046: LD_INT 2
73048: ARRAY
73049: LESS
73050: IFFALSE 73088
// begin result := Insert ( result , j , [ i , tmp ] ) ;
73052: LD_ADDR_VAR 0 6
73056: PUSH
73057: LD_VAR 0 6
73061: PPUSH
73062: LD_VAR 0 8
73066: PPUSH
73067: LD_VAR 0 7
73071: PUSH
73072: LD_VAR 0 9
73076: PUSH
73077: EMPTY
73078: LIST
73079: LIST
73080: PPUSH
73081: CALL_OW 2
73085: ST_TO_ADDR
// break ;
73086: GO 73090
// end ; end ;
73088: GO 73027
73090: POP
73091: POP
// end ; end ;
73092: GO 72891
73094: POP
73095: POP
// if result and not asc then
73096: LD_VAR 0 6
73100: PUSH
73101: LD_VAR 0 4
73105: NOT
73106: AND
73107: IFFALSE 73182
// begin tmp := result ;
73109: LD_ADDR_VAR 0 9
73113: PUSH
73114: LD_VAR 0 6
73118: ST_TO_ADDR
// for i = tmp downto 1 do
73119: LD_ADDR_VAR 0 7
73123: PUSH
73124: DOUBLE
73125: LD_VAR 0 9
73129: INC
73130: ST_TO_ADDR
73131: LD_INT 1
73133: PUSH
73134: FOR_DOWNTO
73135: IFFALSE 73180
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
73137: LD_ADDR_VAR 0 6
73141: PUSH
73142: LD_VAR 0 6
73146: PPUSH
73147: LD_VAR 0 9
73151: PUSH
73152: LD_VAR 0 7
73156: MINUS
73157: PUSH
73158: LD_INT 1
73160: PLUS
73161: PPUSH
73162: LD_VAR 0 9
73166: PUSH
73167: LD_VAR 0 7
73171: ARRAY
73172: PPUSH
73173: CALL_OW 1
73177: ST_TO_ADDR
73178: GO 73134
73180: POP
73181: POP
// end ; tmp := [ ] ;
73182: LD_ADDR_VAR 0 9
73186: PUSH
73187: EMPTY
73188: ST_TO_ADDR
// if mode then
73189: LD_VAR 0 5
73193: IFFALSE 73262
// begin for i = 1 to result do
73195: LD_ADDR_VAR 0 7
73199: PUSH
73200: DOUBLE
73201: LD_INT 1
73203: DEC
73204: ST_TO_ADDR
73205: LD_VAR 0 6
73209: PUSH
73210: FOR_TO
73211: IFFALSE 73250
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
73213: LD_ADDR_VAR 0 9
73217: PUSH
73218: LD_VAR 0 9
73222: PPUSH
73223: LD_VAR 0 7
73227: PPUSH
73228: LD_VAR 0 6
73232: PUSH
73233: LD_VAR 0 7
73237: ARRAY
73238: PUSH
73239: LD_INT 1
73241: ARRAY
73242: PPUSH
73243: CALL_OW 1
73247: ST_TO_ADDR
73248: GO 73210
73250: POP
73251: POP
// result := tmp ;
73252: LD_ADDR_VAR 0 6
73256: PUSH
73257: LD_VAR 0 9
73261: ST_TO_ADDR
// end ; end ;
73262: LD_VAR 0 6
73266: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
73267: LD_INT 0
73269: PPUSH
73270: PPUSH
73271: PPUSH
73272: PPUSH
73273: PPUSH
73274: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
73275: LD_ADDR_VAR 0 5
73279: PUSH
73280: LD_INT 0
73282: PUSH
73283: LD_INT 0
73285: PUSH
73286: LD_INT 0
73288: PUSH
73289: EMPTY
73290: PUSH
73291: EMPTY
73292: LIST
73293: LIST
73294: LIST
73295: LIST
73296: ST_TO_ADDR
// if not x or not y then
73297: LD_VAR 0 2
73301: NOT
73302: PUSH
73303: LD_VAR 0 3
73307: NOT
73308: OR
73309: IFFALSE 73313
// exit ;
73311: GO 74963
// if not range then
73313: LD_VAR 0 4
73317: NOT
73318: IFFALSE 73328
// range := 10 ;
73320: LD_ADDR_VAR 0 4
73324: PUSH
73325: LD_INT 10
73327: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
73328: LD_ADDR_VAR 0 8
73332: PUSH
73333: LD_INT 81
73335: PUSH
73336: LD_VAR 0 1
73340: PUSH
73341: EMPTY
73342: LIST
73343: LIST
73344: PUSH
73345: LD_INT 92
73347: PUSH
73348: LD_VAR 0 2
73352: PUSH
73353: LD_VAR 0 3
73357: PUSH
73358: LD_VAR 0 4
73362: PUSH
73363: EMPTY
73364: LIST
73365: LIST
73366: LIST
73367: LIST
73368: PUSH
73369: LD_INT 3
73371: PUSH
73372: LD_INT 21
73374: PUSH
73375: LD_INT 3
73377: PUSH
73378: EMPTY
73379: LIST
73380: LIST
73381: PUSH
73382: EMPTY
73383: LIST
73384: LIST
73385: PUSH
73386: EMPTY
73387: LIST
73388: LIST
73389: LIST
73390: PPUSH
73391: CALL_OW 69
73395: ST_TO_ADDR
// if not tmp then
73396: LD_VAR 0 8
73400: NOT
73401: IFFALSE 73405
// exit ;
73403: GO 74963
// for i in tmp do
73405: LD_ADDR_VAR 0 6
73409: PUSH
73410: LD_VAR 0 8
73414: PUSH
73415: FOR_IN
73416: IFFALSE 74938
// begin points := [ 0 , 0 , 0 ] ;
73418: LD_ADDR_VAR 0 9
73422: PUSH
73423: LD_INT 0
73425: PUSH
73426: LD_INT 0
73428: PUSH
73429: LD_INT 0
73431: PUSH
73432: EMPTY
73433: LIST
73434: LIST
73435: LIST
73436: ST_TO_ADDR
// bpoints := 1 ;
73437: LD_ADDR_VAR 0 10
73441: PUSH
73442: LD_INT 1
73444: ST_TO_ADDR
// case GetType ( i ) of unit_human :
73445: LD_VAR 0 6
73449: PPUSH
73450: CALL_OW 247
73454: PUSH
73455: LD_INT 1
73457: DOUBLE
73458: EQUAL
73459: IFTRUE 73463
73461: GO 74041
73463: POP
// begin if GetClass ( i ) = 1 then
73464: LD_VAR 0 6
73468: PPUSH
73469: CALL_OW 257
73473: PUSH
73474: LD_INT 1
73476: EQUAL
73477: IFFALSE 73498
// points := [ 10 , 5 , 3 ] ;
73479: LD_ADDR_VAR 0 9
73483: PUSH
73484: LD_INT 10
73486: PUSH
73487: LD_INT 5
73489: PUSH
73490: LD_INT 3
73492: PUSH
73493: EMPTY
73494: LIST
73495: LIST
73496: LIST
73497: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
73498: LD_VAR 0 6
73502: PPUSH
73503: CALL_OW 257
73507: PUSH
73508: LD_INT 2
73510: PUSH
73511: LD_INT 3
73513: PUSH
73514: LD_INT 4
73516: PUSH
73517: EMPTY
73518: LIST
73519: LIST
73520: LIST
73521: IN
73522: IFFALSE 73543
// points := [ 3 , 2 , 1 ] ;
73524: LD_ADDR_VAR 0 9
73528: PUSH
73529: LD_INT 3
73531: PUSH
73532: LD_INT 2
73534: PUSH
73535: LD_INT 1
73537: PUSH
73538: EMPTY
73539: LIST
73540: LIST
73541: LIST
73542: ST_TO_ADDR
// if GetClass ( i ) = 5 then
73543: LD_VAR 0 6
73547: PPUSH
73548: CALL_OW 257
73552: PUSH
73553: LD_INT 5
73555: EQUAL
73556: IFFALSE 73577
// points := [ 130 , 5 , 2 ] ;
73558: LD_ADDR_VAR 0 9
73562: PUSH
73563: LD_INT 130
73565: PUSH
73566: LD_INT 5
73568: PUSH
73569: LD_INT 2
73571: PUSH
73572: EMPTY
73573: LIST
73574: LIST
73575: LIST
73576: ST_TO_ADDR
// if GetClass ( i ) = 8 then
73577: LD_VAR 0 6
73581: PPUSH
73582: CALL_OW 257
73586: PUSH
73587: LD_INT 8
73589: EQUAL
73590: IFFALSE 73611
// points := [ 35 , 35 , 30 ] ;
73592: LD_ADDR_VAR 0 9
73596: PUSH
73597: LD_INT 35
73599: PUSH
73600: LD_INT 35
73602: PUSH
73603: LD_INT 30
73605: PUSH
73606: EMPTY
73607: LIST
73608: LIST
73609: LIST
73610: ST_TO_ADDR
// if GetClass ( i ) = 9 then
73611: LD_VAR 0 6
73615: PPUSH
73616: CALL_OW 257
73620: PUSH
73621: LD_INT 9
73623: EQUAL
73624: IFFALSE 73645
// points := [ 20 , 55 , 40 ] ;
73626: LD_ADDR_VAR 0 9
73630: PUSH
73631: LD_INT 20
73633: PUSH
73634: LD_INT 55
73636: PUSH
73637: LD_INT 40
73639: PUSH
73640: EMPTY
73641: LIST
73642: LIST
73643: LIST
73644: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
73645: LD_VAR 0 6
73649: PPUSH
73650: CALL_OW 257
73654: PUSH
73655: LD_INT 12
73657: PUSH
73658: LD_INT 16
73660: PUSH
73661: EMPTY
73662: LIST
73663: LIST
73664: IN
73665: IFFALSE 73686
// points := [ 5 , 3 , 2 ] ;
73667: LD_ADDR_VAR 0 9
73671: PUSH
73672: LD_INT 5
73674: PUSH
73675: LD_INT 3
73677: PUSH
73678: LD_INT 2
73680: PUSH
73681: EMPTY
73682: LIST
73683: LIST
73684: LIST
73685: ST_TO_ADDR
// if GetClass ( i ) = 17 then
73686: LD_VAR 0 6
73690: PPUSH
73691: CALL_OW 257
73695: PUSH
73696: LD_INT 17
73698: EQUAL
73699: IFFALSE 73720
// points := [ 100 , 50 , 75 ] ;
73701: LD_ADDR_VAR 0 9
73705: PUSH
73706: LD_INT 100
73708: PUSH
73709: LD_INT 50
73711: PUSH
73712: LD_INT 75
73714: PUSH
73715: EMPTY
73716: LIST
73717: LIST
73718: LIST
73719: ST_TO_ADDR
// if GetClass ( i ) = 15 then
73720: LD_VAR 0 6
73724: PPUSH
73725: CALL_OW 257
73729: PUSH
73730: LD_INT 15
73732: EQUAL
73733: IFFALSE 73754
// points := [ 10 , 5 , 3 ] ;
73735: LD_ADDR_VAR 0 9
73739: PUSH
73740: LD_INT 10
73742: PUSH
73743: LD_INT 5
73745: PUSH
73746: LD_INT 3
73748: PUSH
73749: EMPTY
73750: LIST
73751: LIST
73752: LIST
73753: ST_TO_ADDR
// if GetClass ( i ) = 14 then
73754: LD_VAR 0 6
73758: PPUSH
73759: CALL_OW 257
73763: PUSH
73764: LD_INT 14
73766: EQUAL
73767: IFFALSE 73788
// points := [ 10 , 0 , 0 ] ;
73769: LD_ADDR_VAR 0 9
73773: PUSH
73774: LD_INT 10
73776: PUSH
73777: LD_INT 0
73779: PUSH
73780: LD_INT 0
73782: PUSH
73783: EMPTY
73784: LIST
73785: LIST
73786: LIST
73787: ST_TO_ADDR
// if GetClass ( i ) = 11 then
73788: LD_VAR 0 6
73792: PPUSH
73793: CALL_OW 257
73797: PUSH
73798: LD_INT 11
73800: EQUAL
73801: IFFALSE 73822
// points := [ 30 , 10 , 5 ] ;
73803: LD_ADDR_VAR 0 9
73807: PUSH
73808: LD_INT 30
73810: PUSH
73811: LD_INT 10
73813: PUSH
73814: LD_INT 5
73816: PUSH
73817: EMPTY
73818: LIST
73819: LIST
73820: LIST
73821: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
73822: LD_VAR 0 1
73826: PPUSH
73827: LD_INT 5
73829: PPUSH
73830: CALL_OW 321
73834: PUSH
73835: LD_INT 2
73837: EQUAL
73838: IFFALSE 73855
// bpoints := bpoints * 1.8 ;
73840: LD_ADDR_VAR 0 10
73844: PUSH
73845: LD_VAR 0 10
73849: PUSH
73850: LD_REAL  1.80000000000000E+0000
73853: MUL
73854: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
73855: LD_VAR 0 6
73859: PPUSH
73860: CALL_OW 257
73864: PUSH
73865: LD_INT 1
73867: PUSH
73868: LD_INT 2
73870: PUSH
73871: LD_INT 3
73873: PUSH
73874: LD_INT 4
73876: PUSH
73877: EMPTY
73878: LIST
73879: LIST
73880: LIST
73881: LIST
73882: IN
73883: PUSH
73884: LD_VAR 0 1
73888: PPUSH
73889: LD_INT 51
73891: PPUSH
73892: CALL_OW 321
73896: PUSH
73897: LD_INT 2
73899: EQUAL
73900: AND
73901: IFFALSE 73918
// bpoints := bpoints * 1.2 ;
73903: LD_ADDR_VAR 0 10
73907: PUSH
73908: LD_VAR 0 10
73912: PUSH
73913: LD_REAL  1.20000000000000E+0000
73916: MUL
73917: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
73918: LD_VAR 0 6
73922: PPUSH
73923: CALL_OW 257
73927: PUSH
73928: LD_INT 5
73930: PUSH
73931: LD_INT 7
73933: PUSH
73934: LD_INT 9
73936: PUSH
73937: EMPTY
73938: LIST
73939: LIST
73940: LIST
73941: IN
73942: PUSH
73943: LD_VAR 0 1
73947: PPUSH
73948: LD_INT 52
73950: PPUSH
73951: CALL_OW 321
73955: PUSH
73956: LD_INT 2
73958: EQUAL
73959: AND
73960: IFFALSE 73977
// bpoints := bpoints * 1.5 ;
73962: LD_ADDR_VAR 0 10
73966: PUSH
73967: LD_VAR 0 10
73971: PUSH
73972: LD_REAL  1.50000000000000E+0000
73975: MUL
73976: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
73977: LD_VAR 0 1
73981: PPUSH
73982: LD_INT 66
73984: PPUSH
73985: CALL_OW 321
73989: PUSH
73990: LD_INT 2
73992: EQUAL
73993: IFFALSE 74010
// bpoints := bpoints * 1.1 ;
73995: LD_ADDR_VAR 0 10
73999: PUSH
74000: LD_VAR 0 10
74004: PUSH
74005: LD_REAL  1.10000000000000E+0000
74008: MUL
74009: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
74010: LD_ADDR_VAR 0 10
74014: PUSH
74015: LD_VAR 0 10
74019: PUSH
74020: LD_VAR 0 6
74024: PPUSH
74025: LD_INT 1
74027: PPUSH
74028: CALL_OW 259
74032: PUSH
74033: LD_REAL  1.15000000000000E+0000
74036: MUL
74037: MUL
74038: ST_TO_ADDR
// end ; unit_vehicle :
74039: GO 74867
74041: LD_INT 2
74043: DOUBLE
74044: EQUAL
74045: IFTRUE 74049
74047: GO 74855
74049: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
74050: LD_VAR 0 6
74054: PPUSH
74055: CALL_OW 264
74059: PUSH
74060: LD_INT 2
74062: PUSH
74063: LD_INT 42
74065: PUSH
74066: LD_INT 24
74068: PUSH
74069: EMPTY
74070: LIST
74071: LIST
74072: LIST
74073: IN
74074: IFFALSE 74095
// points := [ 25 , 5 , 3 ] ;
74076: LD_ADDR_VAR 0 9
74080: PUSH
74081: LD_INT 25
74083: PUSH
74084: LD_INT 5
74086: PUSH
74087: LD_INT 3
74089: PUSH
74090: EMPTY
74091: LIST
74092: LIST
74093: LIST
74094: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
74095: LD_VAR 0 6
74099: PPUSH
74100: CALL_OW 264
74104: PUSH
74105: LD_INT 4
74107: PUSH
74108: LD_INT 43
74110: PUSH
74111: LD_INT 25
74113: PUSH
74114: EMPTY
74115: LIST
74116: LIST
74117: LIST
74118: IN
74119: IFFALSE 74140
// points := [ 40 , 15 , 5 ] ;
74121: LD_ADDR_VAR 0 9
74125: PUSH
74126: LD_INT 40
74128: PUSH
74129: LD_INT 15
74131: PUSH
74132: LD_INT 5
74134: PUSH
74135: EMPTY
74136: LIST
74137: LIST
74138: LIST
74139: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
74140: LD_VAR 0 6
74144: PPUSH
74145: CALL_OW 264
74149: PUSH
74150: LD_INT 3
74152: PUSH
74153: LD_INT 23
74155: PUSH
74156: EMPTY
74157: LIST
74158: LIST
74159: IN
74160: IFFALSE 74181
// points := [ 7 , 25 , 8 ] ;
74162: LD_ADDR_VAR 0 9
74166: PUSH
74167: LD_INT 7
74169: PUSH
74170: LD_INT 25
74172: PUSH
74173: LD_INT 8
74175: PUSH
74176: EMPTY
74177: LIST
74178: LIST
74179: LIST
74180: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
74181: LD_VAR 0 6
74185: PPUSH
74186: CALL_OW 264
74190: PUSH
74191: LD_INT 5
74193: PUSH
74194: LD_INT 27
74196: PUSH
74197: LD_INT 44
74199: PUSH
74200: EMPTY
74201: LIST
74202: LIST
74203: LIST
74204: IN
74205: IFFALSE 74226
// points := [ 14 , 50 , 16 ] ;
74207: LD_ADDR_VAR 0 9
74211: PUSH
74212: LD_INT 14
74214: PUSH
74215: LD_INT 50
74217: PUSH
74218: LD_INT 16
74220: PUSH
74221: EMPTY
74222: LIST
74223: LIST
74224: LIST
74225: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
74226: LD_VAR 0 6
74230: PPUSH
74231: CALL_OW 264
74235: PUSH
74236: LD_INT 6
74238: PUSH
74239: LD_INT 46
74241: PUSH
74242: EMPTY
74243: LIST
74244: LIST
74245: IN
74246: IFFALSE 74267
// points := [ 32 , 120 , 70 ] ;
74248: LD_ADDR_VAR 0 9
74252: PUSH
74253: LD_INT 32
74255: PUSH
74256: LD_INT 120
74258: PUSH
74259: LD_INT 70
74261: PUSH
74262: EMPTY
74263: LIST
74264: LIST
74265: LIST
74266: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
74267: LD_VAR 0 6
74271: PPUSH
74272: CALL_OW 264
74276: PUSH
74277: LD_INT 7
74279: PUSH
74280: LD_INT 28
74282: PUSH
74283: LD_INT 45
74285: PUSH
74286: LD_INT 92
74288: PUSH
74289: EMPTY
74290: LIST
74291: LIST
74292: LIST
74293: LIST
74294: IN
74295: IFFALSE 74316
// points := [ 35 , 20 , 45 ] ;
74297: LD_ADDR_VAR 0 9
74301: PUSH
74302: LD_INT 35
74304: PUSH
74305: LD_INT 20
74307: PUSH
74308: LD_INT 45
74310: PUSH
74311: EMPTY
74312: LIST
74313: LIST
74314: LIST
74315: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
74316: LD_VAR 0 6
74320: PPUSH
74321: CALL_OW 264
74325: PUSH
74326: LD_INT 47
74328: PUSH
74329: EMPTY
74330: LIST
74331: IN
74332: IFFALSE 74353
// points := [ 67 , 45 , 75 ] ;
74334: LD_ADDR_VAR 0 9
74338: PUSH
74339: LD_INT 67
74341: PUSH
74342: LD_INT 45
74344: PUSH
74345: LD_INT 75
74347: PUSH
74348: EMPTY
74349: LIST
74350: LIST
74351: LIST
74352: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
74353: LD_VAR 0 6
74357: PPUSH
74358: CALL_OW 264
74362: PUSH
74363: LD_INT 26
74365: PUSH
74366: EMPTY
74367: LIST
74368: IN
74369: IFFALSE 74390
// points := [ 120 , 30 , 80 ] ;
74371: LD_ADDR_VAR 0 9
74375: PUSH
74376: LD_INT 120
74378: PUSH
74379: LD_INT 30
74381: PUSH
74382: LD_INT 80
74384: PUSH
74385: EMPTY
74386: LIST
74387: LIST
74388: LIST
74389: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
74390: LD_VAR 0 6
74394: PPUSH
74395: CALL_OW 264
74399: PUSH
74400: LD_INT 22
74402: PUSH
74403: EMPTY
74404: LIST
74405: IN
74406: IFFALSE 74427
// points := [ 40 , 1 , 1 ] ;
74408: LD_ADDR_VAR 0 9
74412: PUSH
74413: LD_INT 40
74415: PUSH
74416: LD_INT 1
74418: PUSH
74419: LD_INT 1
74421: PUSH
74422: EMPTY
74423: LIST
74424: LIST
74425: LIST
74426: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
74427: LD_VAR 0 6
74431: PPUSH
74432: CALL_OW 264
74436: PUSH
74437: LD_INT 29
74439: PUSH
74440: EMPTY
74441: LIST
74442: IN
74443: IFFALSE 74464
// points := [ 70 , 200 , 400 ] ;
74445: LD_ADDR_VAR 0 9
74449: PUSH
74450: LD_INT 70
74452: PUSH
74453: LD_INT 200
74455: PUSH
74456: LD_INT 400
74458: PUSH
74459: EMPTY
74460: LIST
74461: LIST
74462: LIST
74463: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
74464: LD_VAR 0 6
74468: PPUSH
74469: CALL_OW 264
74473: PUSH
74474: LD_INT 14
74476: PUSH
74477: LD_INT 53
74479: PUSH
74480: EMPTY
74481: LIST
74482: LIST
74483: IN
74484: IFFALSE 74505
// points := [ 40 , 10 , 20 ] ;
74486: LD_ADDR_VAR 0 9
74490: PUSH
74491: LD_INT 40
74493: PUSH
74494: LD_INT 10
74496: PUSH
74497: LD_INT 20
74499: PUSH
74500: EMPTY
74501: LIST
74502: LIST
74503: LIST
74504: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
74505: LD_VAR 0 6
74509: PPUSH
74510: CALL_OW 264
74514: PUSH
74515: LD_INT 9
74517: PUSH
74518: EMPTY
74519: LIST
74520: IN
74521: IFFALSE 74542
// points := [ 5 , 70 , 20 ] ;
74523: LD_ADDR_VAR 0 9
74527: PUSH
74528: LD_INT 5
74530: PUSH
74531: LD_INT 70
74533: PUSH
74534: LD_INT 20
74536: PUSH
74537: EMPTY
74538: LIST
74539: LIST
74540: LIST
74541: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
74542: LD_VAR 0 6
74546: PPUSH
74547: CALL_OW 264
74551: PUSH
74552: LD_INT 10
74554: PUSH
74555: EMPTY
74556: LIST
74557: IN
74558: IFFALSE 74579
// points := [ 35 , 110 , 70 ] ;
74560: LD_ADDR_VAR 0 9
74564: PUSH
74565: LD_INT 35
74567: PUSH
74568: LD_INT 110
74570: PUSH
74571: LD_INT 70
74573: PUSH
74574: EMPTY
74575: LIST
74576: LIST
74577: LIST
74578: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
74579: LD_VAR 0 6
74583: PPUSH
74584: CALL_OW 265
74588: PUSH
74589: LD_INT 25
74591: EQUAL
74592: IFFALSE 74613
// points := [ 80 , 65 , 100 ] ;
74594: LD_ADDR_VAR 0 9
74598: PUSH
74599: LD_INT 80
74601: PUSH
74602: LD_INT 65
74604: PUSH
74605: LD_INT 100
74607: PUSH
74608: EMPTY
74609: LIST
74610: LIST
74611: LIST
74612: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
74613: LD_VAR 0 6
74617: PPUSH
74618: CALL_OW 263
74622: PUSH
74623: LD_INT 1
74625: EQUAL
74626: IFFALSE 74661
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
74628: LD_ADDR_VAR 0 10
74632: PUSH
74633: LD_VAR 0 10
74637: PUSH
74638: LD_VAR 0 6
74642: PPUSH
74643: CALL_OW 311
74647: PPUSH
74648: LD_INT 3
74650: PPUSH
74651: CALL_OW 259
74655: PUSH
74656: LD_INT 4
74658: MUL
74659: MUL
74660: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
74661: LD_VAR 0 6
74665: PPUSH
74666: CALL_OW 263
74670: PUSH
74671: LD_INT 2
74673: EQUAL
74674: IFFALSE 74725
// begin j := IsControledBy ( i ) ;
74676: LD_ADDR_VAR 0 7
74680: PUSH
74681: LD_VAR 0 6
74685: PPUSH
74686: CALL_OW 312
74690: ST_TO_ADDR
// if j then
74691: LD_VAR 0 7
74695: IFFALSE 74725
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
74697: LD_ADDR_VAR 0 10
74701: PUSH
74702: LD_VAR 0 10
74706: PUSH
74707: LD_VAR 0 7
74711: PPUSH
74712: LD_INT 3
74714: PPUSH
74715: CALL_OW 259
74719: PUSH
74720: LD_INT 3
74722: MUL
74723: MUL
74724: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
74725: LD_VAR 0 6
74729: PPUSH
74730: CALL_OW 264
74734: PUSH
74735: LD_INT 5
74737: PUSH
74738: LD_INT 6
74740: PUSH
74741: LD_INT 46
74743: PUSH
74744: LD_INT 44
74746: PUSH
74747: LD_INT 47
74749: PUSH
74750: LD_INT 45
74752: PUSH
74753: LD_INT 28
74755: PUSH
74756: LD_INT 7
74758: PUSH
74759: LD_INT 27
74761: PUSH
74762: LD_INT 29
74764: PUSH
74765: EMPTY
74766: LIST
74767: LIST
74768: LIST
74769: LIST
74770: LIST
74771: LIST
74772: LIST
74773: LIST
74774: LIST
74775: LIST
74776: IN
74777: PUSH
74778: LD_VAR 0 1
74782: PPUSH
74783: LD_INT 52
74785: PPUSH
74786: CALL_OW 321
74790: PUSH
74791: LD_INT 2
74793: EQUAL
74794: AND
74795: IFFALSE 74812
// bpoints := bpoints * 1.2 ;
74797: LD_ADDR_VAR 0 10
74801: PUSH
74802: LD_VAR 0 10
74806: PUSH
74807: LD_REAL  1.20000000000000E+0000
74810: MUL
74811: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
74812: LD_VAR 0 6
74816: PPUSH
74817: CALL_OW 264
74821: PUSH
74822: LD_INT 6
74824: PUSH
74825: LD_INT 46
74827: PUSH
74828: LD_INT 47
74830: PUSH
74831: EMPTY
74832: LIST
74833: LIST
74834: LIST
74835: IN
74836: IFFALSE 74853
// bpoints := bpoints * 1.2 ;
74838: LD_ADDR_VAR 0 10
74842: PUSH
74843: LD_VAR 0 10
74847: PUSH
74848: LD_REAL  1.20000000000000E+0000
74851: MUL
74852: ST_TO_ADDR
// end ; unit_building :
74853: GO 74867
74855: LD_INT 3
74857: DOUBLE
74858: EQUAL
74859: IFTRUE 74863
74861: GO 74866
74863: POP
// ; end ;
74864: GO 74867
74866: POP
// for j = 1 to 3 do
74867: LD_ADDR_VAR 0 7
74871: PUSH
74872: DOUBLE
74873: LD_INT 1
74875: DEC
74876: ST_TO_ADDR
74877: LD_INT 3
74879: PUSH
74880: FOR_TO
74881: IFFALSE 74934
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
74883: LD_ADDR_VAR 0 5
74887: PUSH
74888: LD_VAR 0 5
74892: PPUSH
74893: LD_VAR 0 7
74897: PPUSH
74898: LD_VAR 0 5
74902: PUSH
74903: LD_VAR 0 7
74907: ARRAY
74908: PUSH
74909: LD_VAR 0 9
74913: PUSH
74914: LD_VAR 0 7
74918: ARRAY
74919: PUSH
74920: LD_VAR 0 10
74924: MUL
74925: PLUS
74926: PPUSH
74927: CALL_OW 1
74931: ST_TO_ADDR
74932: GO 74880
74934: POP
74935: POP
// end ;
74936: GO 73415
74938: POP
74939: POP
// result := Replace ( result , 4 , tmp ) ;
74940: LD_ADDR_VAR 0 5
74944: PUSH
74945: LD_VAR 0 5
74949: PPUSH
74950: LD_INT 4
74952: PPUSH
74953: LD_VAR 0 8
74957: PPUSH
74958: CALL_OW 1
74962: ST_TO_ADDR
// end ;
74963: LD_VAR 0 5
74967: RET
// export function DangerAtRange ( unit , range ) ; begin
74968: LD_INT 0
74970: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
74971: LD_ADDR_VAR 0 3
74975: PUSH
74976: LD_VAR 0 1
74980: PPUSH
74981: CALL_OW 255
74985: PPUSH
74986: LD_VAR 0 1
74990: PPUSH
74991: CALL_OW 250
74995: PPUSH
74996: LD_VAR 0 1
75000: PPUSH
75001: CALL_OW 251
75005: PPUSH
75006: LD_VAR 0 2
75010: PPUSH
75011: CALL 73267 0 4
75015: ST_TO_ADDR
// end ;
75016: LD_VAR 0 3
75020: RET
// export function DangerInArea ( side , area ) ; begin
75021: LD_INT 0
75023: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
75024: LD_ADDR_VAR 0 3
75028: PUSH
75029: LD_VAR 0 2
75033: PPUSH
75034: LD_INT 81
75036: PUSH
75037: LD_VAR 0 1
75041: PUSH
75042: EMPTY
75043: LIST
75044: LIST
75045: PPUSH
75046: CALL_OW 70
75050: ST_TO_ADDR
// end ;
75051: LD_VAR 0 3
75055: RET
// export function IsExtension ( b ) ; begin
75056: LD_INT 0
75058: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
75059: LD_ADDR_VAR 0 2
75063: PUSH
75064: LD_VAR 0 1
75068: PUSH
75069: LD_INT 23
75071: PUSH
75072: LD_INT 20
75074: PUSH
75075: LD_INT 22
75077: PUSH
75078: LD_INT 17
75080: PUSH
75081: LD_INT 24
75083: PUSH
75084: LD_INT 21
75086: PUSH
75087: LD_INT 19
75089: PUSH
75090: LD_INT 16
75092: PUSH
75093: LD_INT 25
75095: PUSH
75096: LD_INT 18
75098: PUSH
75099: EMPTY
75100: LIST
75101: LIST
75102: LIST
75103: LIST
75104: LIST
75105: LIST
75106: LIST
75107: LIST
75108: LIST
75109: LIST
75110: IN
75111: ST_TO_ADDR
// end ;
75112: LD_VAR 0 2
75116: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
75117: LD_INT 0
75119: PPUSH
75120: PPUSH
75121: PPUSH
// result := [ ] ;
75122: LD_ADDR_VAR 0 4
75126: PUSH
75127: EMPTY
75128: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
75129: LD_ADDR_VAR 0 5
75133: PUSH
75134: LD_VAR 0 2
75138: PPUSH
75139: LD_INT 21
75141: PUSH
75142: LD_INT 3
75144: PUSH
75145: EMPTY
75146: LIST
75147: LIST
75148: PPUSH
75149: CALL_OW 70
75153: ST_TO_ADDR
// if not tmp then
75154: LD_VAR 0 5
75158: NOT
75159: IFFALSE 75163
// exit ;
75161: GO 75227
// if checkLink then
75163: LD_VAR 0 3
75167: IFFALSE 75217
// begin for i in tmp do
75169: LD_ADDR_VAR 0 6
75173: PUSH
75174: LD_VAR 0 5
75178: PUSH
75179: FOR_IN
75180: IFFALSE 75215
// if GetBase ( i ) <> base then
75182: LD_VAR 0 6
75186: PPUSH
75187: CALL_OW 274
75191: PUSH
75192: LD_VAR 0 1
75196: NONEQUAL
75197: IFFALSE 75213
// ComLinkToBase ( base , i ) ;
75199: LD_VAR 0 1
75203: PPUSH
75204: LD_VAR 0 6
75208: PPUSH
75209: CALL_OW 169
75213: GO 75179
75215: POP
75216: POP
// end ; result := tmp ;
75217: LD_ADDR_VAR 0 4
75221: PUSH
75222: LD_VAR 0 5
75226: ST_TO_ADDR
// end ;
75227: LD_VAR 0 4
75231: RET
// export function ComComplete ( units , b ) ; var i ; begin
75232: LD_INT 0
75234: PPUSH
75235: PPUSH
// if not units then
75236: LD_VAR 0 1
75240: NOT
75241: IFFALSE 75245
// exit ;
75243: GO 75335
// for i in units do
75245: LD_ADDR_VAR 0 4
75249: PUSH
75250: LD_VAR 0 1
75254: PUSH
75255: FOR_IN
75256: IFFALSE 75333
// if BuildingStatus ( b ) = bs_build then
75258: LD_VAR 0 2
75262: PPUSH
75263: CALL_OW 461
75267: PUSH
75268: LD_INT 1
75270: EQUAL
75271: IFFALSE 75331
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
75273: LD_VAR 0 4
75277: PPUSH
75278: LD_STRING h
75280: PUSH
75281: LD_VAR 0 2
75285: PPUSH
75286: CALL_OW 250
75290: PUSH
75291: LD_VAR 0 2
75295: PPUSH
75296: CALL_OW 251
75300: PUSH
75301: LD_VAR 0 2
75305: PUSH
75306: LD_INT 0
75308: PUSH
75309: LD_INT 0
75311: PUSH
75312: LD_INT 0
75314: PUSH
75315: EMPTY
75316: LIST
75317: LIST
75318: LIST
75319: LIST
75320: LIST
75321: LIST
75322: LIST
75323: PUSH
75324: EMPTY
75325: LIST
75326: PPUSH
75327: CALL_OW 446
75331: GO 75255
75333: POP
75334: POP
// end ;
75335: LD_VAR 0 3
75339: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
75340: LD_INT 0
75342: PPUSH
75343: PPUSH
75344: PPUSH
75345: PPUSH
75346: PPUSH
75347: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
75348: LD_VAR 0 1
75352: NOT
75353: PUSH
75354: LD_VAR 0 1
75358: PPUSH
75359: CALL_OW 263
75363: PUSH
75364: LD_INT 2
75366: NONEQUAL
75367: OR
75368: IFFALSE 75372
// exit ;
75370: GO 75688
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
75372: LD_ADDR_VAR 0 6
75376: PUSH
75377: LD_INT 22
75379: PUSH
75380: LD_VAR 0 1
75384: PPUSH
75385: CALL_OW 255
75389: PUSH
75390: EMPTY
75391: LIST
75392: LIST
75393: PUSH
75394: LD_INT 2
75396: PUSH
75397: LD_INT 30
75399: PUSH
75400: LD_INT 36
75402: PUSH
75403: EMPTY
75404: LIST
75405: LIST
75406: PUSH
75407: LD_INT 34
75409: PUSH
75410: LD_INT 31
75412: PUSH
75413: EMPTY
75414: LIST
75415: LIST
75416: PUSH
75417: EMPTY
75418: LIST
75419: LIST
75420: LIST
75421: PUSH
75422: EMPTY
75423: LIST
75424: LIST
75425: PPUSH
75426: CALL_OW 69
75430: ST_TO_ADDR
// if not tmp then
75431: LD_VAR 0 6
75435: NOT
75436: IFFALSE 75440
// exit ;
75438: GO 75688
// result := [ ] ;
75440: LD_ADDR_VAR 0 2
75444: PUSH
75445: EMPTY
75446: ST_TO_ADDR
// for i in tmp do
75447: LD_ADDR_VAR 0 3
75451: PUSH
75452: LD_VAR 0 6
75456: PUSH
75457: FOR_IN
75458: IFFALSE 75529
// begin t := UnitsInside ( i ) ;
75460: LD_ADDR_VAR 0 4
75464: PUSH
75465: LD_VAR 0 3
75469: PPUSH
75470: CALL_OW 313
75474: ST_TO_ADDR
// if t then
75475: LD_VAR 0 4
75479: IFFALSE 75527
// for j in t do
75481: LD_ADDR_VAR 0 7
75485: PUSH
75486: LD_VAR 0 4
75490: PUSH
75491: FOR_IN
75492: IFFALSE 75525
// result := Replace ( result , result + 1 , j ) ;
75494: LD_ADDR_VAR 0 2
75498: PUSH
75499: LD_VAR 0 2
75503: PPUSH
75504: LD_VAR 0 2
75508: PUSH
75509: LD_INT 1
75511: PLUS
75512: PPUSH
75513: LD_VAR 0 7
75517: PPUSH
75518: CALL_OW 1
75522: ST_TO_ADDR
75523: GO 75491
75525: POP
75526: POP
// end ;
75527: GO 75457
75529: POP
75530: POP
// if not result then
75531: LD_VAR 0 2
75535: NOT
75536: IFFALSE 75540
// exit ;
75538: GO 75688
// mech := result [ 1 ] ;
75540: LD_ADDR_VAR 0 5
75544: PUSH
75545: LD_VAR 0 2
75549: PUSH
75550: LD_INT 1
75552: ARRAY
75553: ST_TO_ADDR
// if result > 1 then
75554: LD_VAR 0 2
75558: PUSH
75559: LD_INT 1
75561: GREATER
75562: IFFALSE 75674
// begin for i = 2 to result do
75564: LD_ADDR_VAR 0 3
75568: PUSH
75569: DOUBLE
75570: LD_INT 2
75572: DEC
75573: ST_TO_ADDR
75574: LD_VAR 0 2
75578: PUSH
75579: FOR_TO
75580: IFFALSE 75672
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
75582: LD_ADDR_VAR 0 4
75586: PUSH
75587: LD_VAR 0 2
75591: PUSH
75592: LD_VAR 0 3
75596: ARRAY
75597: PPUSH
75598: LD_INT 3
75600: PPUSH
75601: CALL_OW 259
75605: PUSH
75606: LD_VAR 0 2
75610: PUSH
75611: LD_VAR 0 3
75615: ARRAY
75616: PPUSH
75617: CALL_OW 432
75621: MINUS
75622: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
75623: LD_VAR 0 4
75627: PUSH
75628: LD_VAR 0 5
75632: PPUSH
75633: LD_INT 3
75635: PPUSH
75636: CALL_OW 259
75640: PUSH
75641: LD_VAR 0 5
75645: PPUSH
75646: CALL_OW 432
75650: MINUS
75651: GREATEREQUAL
75652: IFFALSE 75670
// mech := result [ i ] ;
75654: LD_ADDR_VAR 0 5
75658: PUSH
75659: LD_VAR 0 2
75663: PUSH
75664: LD_VAR 0 3
75668: ARRAY
75669: ST_TO_ADDR
// end ;
75670: GO 75579
75672: POP
75673: POP
// end ; ComLinkTo ( vehicle , mech ) ;
75674: LD_VAR 0 1
75678: PPUSH
75679: LD_VAR 0 5
75683: PPUSH
75684: CALL_OW 135
// end ;
75688: LD_VAR 0 2
75692: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
75693: LD_INT 0
75695: PPUSH
75696: PPUSH
75697: PPUSH
75698: PPUSH
75699: PPUSH
75700: PPUSH
75701: PPUSH
75702: PPUSH
75703: PPUSH
75704: PPUSH
75705: PPUSH
75706: PPUSH
75707: PPUSH
// result := [ ] ;
75708: LD_ADDR_VAR 0 7
75712: PUSH
75713: EMPTY
75714: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
75715: LD_VAR 0 1
75719: PPUSH
75720: CALL_OW 266
75724: PUSH
75725: LD_INT 0
75727: PUSH
75728: LD_INT 1
75730: PUSH
75731: EMPTY
75732: LIST
75733: LIST
75734: IN
75735: NOT
75736: IFFALSE 75740
// exit ;
75738: GO 77374
// if name then
75740: LD_VAR 0 3
75744: IFFALSE 75760
// SetBName ( base_dep , name ) ;
75746: LD_VAR 0 1
75750: PPUSH
75751: LD_VAR 0 3
75755: PPUSH
75756: CALL_OW 500
// base := GetBase ( base_dep ) ;
75760: LD_ADDR_VAR 0 15
75764: PUSH
75765: LD_VAR 0 1
75769: PPUSH
75770: CALL_OW 274
75774: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
75775: LD_ADDR_VAR 0 16
75779: PUSH
75780: LD_VAR 0 1
75784: PPUSH
75785: CALL_OW 255
75789: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
75790: LD_ADDR_VAR 0 17
75794: PUSH
75795: LD_VAR 0 1
75799: PPUSH
75800: CALL_OW 248
75804: ST_TO_ADDR
// if sources then
75805: LD_VAR 0 5
75809: IFFALSE 75856
// for i = 1 to 3 do
75811: LD_ADDR_VAR 0 8
75815: PUSH
75816: DOUBLE
75817: LD_INT 1
75819: DEC
75820: ST_TO_ADDR
75821: LD_INT 3
75823: PUSH
75824: FOR_TO
75825: IFFALSE 75854
// AddResourceType ( base , i , sources [ i ] ) ;
75827: LD_VAR 0 15
75831: PPUSH
75832: LD_VAR 0 8
75836: PPUSH
75837: LD_VAR 0 5
75841: PUSH
75842: LD_VAR 0 8
75846: ARRAY
75847: PPUSH
75848: CALL_OW 276
75852: GO 75824
75854: POP
75855: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
75856: LD_ADDR_VAR 0 18
75860: PUSH
75861: LD_VAR 0 15
75865: PPUSH
75866: LD_VAR 0 2
75870: PPUSH
75871: LD_INT 1
75873: PPUSH
75874: CALL 75117 0 3
75878: ST_TO_ADDR
// InitHc ;
75879: CALL_OW 19
// InitUc ;
75883: CALL_OW 18
// uc_side := side ;
75887: LD_ADDR_OWVAR 20
75891: PUSH
75892: LD_VAR 0 16
75896: ST_TO_ADDR
// uc_nation := nation ;
75897: LD_ADDR_OWVAR 21
75901: PUSH
75902: LD_VAR 0 17
75906: ST_TO_ADDR
// if buildings then
75907: LD_VAR 0 18
75911: IFFALSE 77233
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
75913: LD_ADDR_VAR 0 19
75917: PUSH
75918: LD_VAR 0 18
75922: PPUSH
75923: LD_INT 2
75925: PUSH
75926: LD_INT 30
75928: PUSH
75929: LD_INT 29
75931: PUSH
75932: EMPTY
75933: LIST
75934: LIST
75935: PUSH
75936: LD_INT 30
75938: PUSH
75939: LD_INT 30
75941: PUSH
75942: EMPTY
75943: LIST
75944: LIST
75945: PUSH
75946: EMPTY
75947: LIST
75948: LIST
75949: LIST
75950: PPUSH
75951: CALL_OW 72
75955: ST_TO_ADDR
// if tmp then
75956: LD_VAR 0 19
75960: IFFALSE 76008
// for i in tmp do
75962: LD_ADDR_VAR 0 8
75966: PUSH
75967: LD_VAR 0 19
75971: PUSH
75972: FOR_IN
75973: IFFALSE 76006
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
75975: LD_VAR 0 8
75979: PPUSH
75980: CALL_OW 250
75984: PPUSH
75985: LD_VAR 0 8
75989: PPUSH
75990: CALL_OW 251
75994: PPUSH
75995: LD_VAR 0 16
75999: PPUSH
76000: CALL_OW 441
76004: GO 75972
76006: POP
76007: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
76008: LD_VAR 0 18
76012: PPUSH
76013: LD_INT 2
76015: PUSH
76016: LD_INT 30
76018: PUSH
76019: LD_INT 32
76021: PUSH
76022: EMPTY
76023: LIST
76024: LIST
76025: PUSH
76026: LD_INT 30
76028: PUSH
76029: LD_INT 33
76031: PUSH
76032: EMPTY
76033: LIST
76034: LIST
76035: PUSH
76036: EMPTY
76037: LIST
76038: LIST
76039: LIST
76040: PPUSH
76041: CALL_OW 72
76045: IFFALSE 76133
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
76047: LD_ADDR_VAR 0 8
76051: PUSH
76052: LD_VAR 0 18
76056: PPUSH
76057: LD_INT 2
76059: PUSH
76060: LD_INT 30
76062: PUSH
76063: LD_INT 32
76065: PUSH
76066: EMPTY
76067: LIST
76068: LIST
76069: PUSH
76070: LD_INT 30
76072: PUSH
76073: LD_INT 33
76075: PUSH
76076: EMPTY
76077: LIST
76078: LIST
76079: PUSH
76080: EMPTY
76081: LIST
76082: LIST
76083: LIST
76084: PPUSH
76085: CALL_OW 72
76089: PUSH
76090: FOR_IN
76091: IFFALSE 76131
// begin if not GetBWeapon ( i ) then
76093: LD_VAR 0 8
76097: PPUSH
76098: CALL_OW 269
76102: NOT
76103: IFFALSE 76129
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
76105: LD_VAR 0 8
76109: PPUSH
76110: LD_VAR 0 8
76114: PPUSH
76115: LD_VAR 0 2
76119: PPUSH
76120: CALL 77379 0 2
76124: PPUSH
76125: CALL_OW 431
// end ;
76129: GO 76090
76131: POP
76132: POP
// end ; for i = 1 to personel do
76133: LD_ADDR_VAR 0 8
76137: PUSH
76138: DOUBLE
76139: LD_INT 1
76141: DEC
76142: ST_TO_ADDR
76143: LD_VAR 0 6
76147: PUSH
76148: FOR_TO
76149: IFFALSE 77213
// begin if i > 4 then
76151: LD_VAR 0 8
76155: PUSH
76156: LD_INT 4
76158: GREATER
76159: IFFALSE 76163
// break ;
76161: GO 77213
// case i of 1 :
76163: LD_VAR 0 8
76167: PUSH
76168: LD_INT 1
76170: DOUBLE
76171: EQUAL
76172: IFTRUE 76176
76174: GO 76256
76176: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
76177: LD_ADDR_VAR 0 12
76181: PUSH
76182: LD_VAR 0 18
76186: PPUSH
76187: LD_INT 22
76189: PUSH
76190: LD_VAR 0 16
76194: PUSH
76195: EMPTY
76196: LIST
76197: LIST
76198: PUSH
76199: LD_INT 58
76201: PUSH
76202: EMPTY
76203: LIST
76204: PUSH
76205: LD_INT 2
76207: PUSH
76208: LD_INT 30
76210: PUSH
76211: LD_INT 32
76213: PUSH
76214: EMPTY
76215: LIST
76216: LIST
76217: PUSH
76218: LD_INT 30
76220: PUSH
76221: LD_INT 4
76223: PUSH
76224: EMPTY
76225: LIST
76226: LIST
76227: PUSH
76228: LD_INT 30
76230: PUSH
76231: LD_INT 5
76233: PUSH
76234: EMPTY
76235: LIST
76236: LIST
76237: PUSH
76238: EMPTY
76239: LIST
76240: LIST
76241: LIST
76242: LIST
76243: PUSH
76244: EMPTY
76245: LIST
76246: LIST
76247: LIST
76248: PPUSH
76249: CALL_OW 72
76253: ST_TO_ADDR
76254: GO 76478
76256: LD_INT 2
76258: DOUBLE
76259: EQUAL
76260: IFTRUE 76264
76262: GO 76326
76264: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
76265: LD_ADDR_VAR 0 12
76269: PUSH
76270: LD_VAR 0 18
76274: PPUSH
76275: LD_INT 22
76277: PUSH
76278: LD_VAR 0 16
76282: PUSH
76283: EMPTY
76284: LIST
76285: LIST
76286: PUSH
76287: LD_INT 2
76289: PUSH
76290: LD_INT 30
76292: PUSH
76293: LD_INT 0
76295: PUSH
76296: EMPTY
76297: LIST
76298: LIST
76299: PUSH
76300: LD_INT 30
76302: PUSH
76303: LD_INT 1
76305: PUSH
76306: EMPTY
76307: LIST
76308: LIST
76309: PUSH
76310: EMPTY
76311: LIST
76312: LIST
76313: LIST
76314: PUSH
76315: EMPTY
76316: LIST
76317: LIST
76318: PPUSH
76319: CALL_OW 72
76323: ST_TO_ADDR
76324: GO 76478
76326: LD_INT 3
76328: DOUBLE
76329: EQUAL
76330: IFTRUE 76334
76332: GO 76396
76334: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
76335: LD_ADDR_VAR 0 12
76339: PUSH
76340: LD_VAR 0 18
76344: PPUSH
76345: LD_INT 22
76347: PUSH
76348: LD_VAR 0 16
76352: PUSH
76353: EMPTY
76354: LIST
76355: LIST
76356: PUSH
76357: LD_INT 2
76359: PUSH
76360: LD_INT 30
76362: PUSH
76363: LD_INT 2
76365: PUSH
76366: EMPTY
76367: LIST
76368: LIST
76369: PUSH
76370: LD_INT 30
76372: PUSH
76373: LD_INT 3
76375: PUSH
76376: EMPTY
76377: LIST
76378: LIST
76379: PUSH
76380: EMPTY
76381: LIST
76382: LIST
76383: LIST
76384: PUSH
76385: EMPTY
76386: LIST
76387: LIST
76388: PPUSH
76389: CALL_OW 72
76393: ST_TO_ADDR
76394: GO 76478
76396: LD_INT 4
76398: DOUBLE
76399: EQUAL
76400: IFTRUE 76404
76402: GO 76477
76404: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
76405: LD_ADDR_VAR 0 12
76409: PUSH
76410: LD_VAR 0 18
76414: PPUSH
76415: LD_INT 22
76417: PUSH
76418: LD_VAR 0 16
76422: PUSH
76423: EMPTY
76424: LIST
76425: LIST
76426: PUSH
76427: LD_INT 2
76429: PUSH
76430: LD_INT 30
76432: PUSH
76433: LD_INT 6
76435: PUSH
76436: EMPTY
76437: LIST
76438: LIST
76439: PUSH
76440: LD_INT 30
76442: PUSH
76443: LD_INT 7
76445: PUSH
76446: EMPTY
76447: LIST
76448: LIST
76449: PUSH
76450: LD_INT 30
76452: PUSH
76453: LD_INT 8
76455: PUSH
76456: EMPTY
76457: LIST
76458: LIST
76459: PUSH
76460: EMPTY
76461: LIST
76462: LIST
76463: LIST
76464: LIST
76465: PUSH
76466: EMPTY
76467: LIST
76468: LIST
76469: PPUSH
76470: CALL_OW 72
76474: ST_TO_ADDR
76475: GO 76478
76477: POP
// if i = 1 then
76478: LD_VAR 0 8
76482: PUSH
76483: LD_INT 1
76485: EQUAL
76486: IFFALSE 76597
// begin tmp := [ ] ;
76488: LD_ADDR_VAR 0 19
76492: PUSH
76493: EMPTY
76494: ST_TO_ADDR
// for j in f do
76495: LD_ADDR_VAR 0 9
76499: PUSH
76500: LD_VAR 0 12
76504: PUSH
76505: FOR_IN
76506: IFFALSE 76579
// if GetBType ( j ) = b_bunker then
76508: LD_VAR 0 9
76512: PPUSH
76513: CALL_OW 266
76517: PUSH
76518: LD_INT 32
76520: EQUAL
76521: IFFALSE 76548
// tmp := Insert ( tmp , 1 , j ) else
76523: LD_ADDR_VAR 0 19
76527: PUSH
76528: LD_VAR 0 19
76532: PPUSH
76533: LD_INT 1
76535: PPUSH
76536: LD_VAR 0 9
76540: PPUSH
76541: CALL_OW 2
76545: ST_TO_ADDR
76546: GO 76577
// tmp := Insert ( tmp , tmp + 1 , j ) ;
76548: LD_ADDR_VAR 0 19
76552: PUSH
76553: LD_VAR 0 19
76557: PPUSH
76558: LD_VAR 0 19
76562: PUSH
76563: LD_INT 1
76565: PLUS
76566: PPUSH
76567: LD_VAR 0 9
76571: PPUSH
76572: CALL_OW 2
76576: ST_TO_ADDR
76577: GO 76505
76579: POP
76580: POP
// if tmp then
76581: LD_VAR 0 19
76585: IFFALSE 76597
// f := tmp ;
76587: LD_ADDR_VAR 0 12
76591: PUSH
76592: LD_VAR 0 19
76596: ST_TO_ADDR
// end ; x := personel [ i ] ;
76597: LD_ADDR_VAR 0 13
76601: PUSH
76602: LD_VAR 0 6
76606: PUSH
76607: LD_VAR 0 8
76611: ARRAY
76612: ST_TO_ADDR
// if x = - 1 then
76613: LD_VAR 0 13
76617: PUSH
76618: LD_INT 1
76620: NEG
76621: EQUAL
76622: IFFALSE 76831
// begin for j in f do
76624: LD_ADDR_VAR 0 9
76628: PUSH
76629: LD_VAR 0 12
76633: PUSH
76634: FOR_IN
76635: IFFALSE 76827
// repeat InitHc ;
76637: CALL_OW 19
// if GetBType ( j ) = b_barracks then
76641: LD_VAR 0 9
76645: PPUSH
76646: CALL_OW 266
76650: PUSH
76651: LD_INT 5
76653: EQUAL
76654: IFFALSE 76724
// begin if UnitsInside ( j ) < 3 then
76656: LD_VAR 0 9
76660: PPUSH
76661: CALL_OW 313
76665: PUSH
76666: LD_INT 3
76668: LESS
76669: IFFALSE 76705
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76671: LD_INT 0
76673: PPUSH
76674: LD_INT 5
76676: PUSH
76677: LD_INT 8
76679: PUSH
76680: LD_INT 9
76682: PUSH
76683: EMPTY
76684: LIST
76685: LIST
76686: LIST
76687: PUSH
76688: LD_VAR 0 17
76692: ARRAY
76693: PPUSH
76694: LD_VAR 0 4
76698: PPUSH
76699: CALL_OW 380
76703: GO 76722
// PrepareHuman ( false , i , skill ) ;
76705: LD_INT 0
76707: PPUSH
76708: LD_VAR 0 8
76712: PPUSH
76713: LD_VAR 0 4
76717: PPUSH
76718: CALL_OW 380
// end else
76722: GO 76741
// PrepareHuman ( false , i , skill ) ;
76724: LD_INT 0
76726: PPUSH
76727: LD_VAR 0 8
76731: PPUSH
76732: LD_VAR 0 4
76736: PPUSH
76737: CALL_OW 380
// un := CreateHuman ;
76741: LD_ADDR_VAR 0 14
76745: PUSH
76746: CALL_OW 44
76750: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76751: LD_ADDR_VAR 0 7
76755: PUSH
76756: LD_VAR 0 7
76760: PPUSH
76761: LD_INT 1
76763: PPUSH
76764: LD_VAR 0 14
76768: PPUSH
76769: CALL_OW 2
76773: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
76774: LD_VAR 0 14
76778: PPUSH
76779: LD_VAR 0 9
76783: PPUSH
76784: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
76788: LD_VAR 0 9
76792: PPUSH
76793: CALL_OW 313
76797: PUSH
76798: LD_INT 6
76800: EQUAL
76801: PUSH
76802: LD_VAR 0 9
76806: PPUSH
76807: CALL_OW 266
76811: PUSH
76812: LD_INT 32
76814: PUSH
76815: LD_INT 31
76817: PUSH
76818: EMPTY
76819: LIST
76820: LIST
76821: IN
76822: OR
76823: IFFALSE 76637
76825: GO 76634
76827: POP
76828: POP
// end else
76829: GO 77211
// for j = 1 to x do
76831: LD_ADDR_VAR 0 9
76835: PUSH
76836: DOUBLE
76837: LD_INT 1
76839: DEC
76840: ST_TO_ADDR
76841: LD_VAR 0 13
76845: PUSH
76846: FOR_TO
76847: IFFALSE 77209
// begin InitHc ;
76849: CALL_OW 19
// if not f then
76853: LD_VAR 0 12
76857: NOT
76858: IFFALSE 76947
// begin PrepareHuman ( false , i , skill ) ;
76860: LD_INT 0
76862: PPUSH
76863: LD_VAR 0 8
76867: PPUSH
76868: LD_VAR 0 4
76872: PPUSH
76873: CALL_OW 380
// un := CreateHuman ;
76877: LD_ADDR_VAR 0 14
76881: PUSH
76882: CALL_OW 44
76886: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76887: LD_ADDR_VAR 0 7
76891: PUSH
76892: LD_VAR 0 7
76896: PPUSH
76897: LD_INT 1
76899: PPUSH
76900: LD_VAR 0 14
76904: PPUSH
76905: CALL_OW 2
76909: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76910: LD_VAR 0 14
76914: PPUSH
76915: LD_VAR 0 1
76919: PPUSH
76920: CALL_OW 250
76924: PPUSH
76925: LD_VAR 0 1
76929: PPUSH
76930: CALL_OW 251
76934: PPUSH
76935: LD_INT 10
76937: PPUSH
76938: LD_INT 0
76940: PPUSH
76941: CALL_OW 50
// continue ;
76945: GO 76846
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
76947: LD_VAR 0 12
76951: PUSH
76952: LD_INT 1
76954: ARRAY
76955: PPUSH
76956: CALL_OW 313
76960: PUSH
76961: LD_VAR 0 12
76965: PUSH
76966: LD_INT 1
76968: ARRAY
76969: PPUSH
76970: CALL_OW 266
76974: PUSH
76975: LD_INT 32
76977: PUSH
76978: LD_INT 31
76980: PUSH
76981: EMPTY
76982: LIST
76983: LIST
76984: IN
76985: AND
76986: PUSH
76987: LD_VAR 0 12
76991: PUSH
76992: LD_INT 1
76994: ARRAY
76995: PPUSH
76996: CALL_OW 313
77000: PUSH
77001: LD_INT 6
77003: EQUAL
77004: OR
77005: IFFALSE 77025
// f := Delete ( f , 1 ) ;
77007: LD_ADDR_VAR 0 12
77011: PUSH
77012: LD_VAR 0 12
77016: PPUSH
77017: LD_INT 1
77019: PPUSH
77020: CALL_OW 3
77024: ST_TO_ADDR
// if not f then
77025: LD_VAR 0 12
77029: NOT
77030: IFFALSE 77048
// begin x := x + 2 ;
77032: LD_ADDR_VAR 0 13
77036: PUSH
77037: LD_VAR 0 13
77041: PUSH
77042: LD_INT 2
77044: PLUS
77045: ST_TO_ADDR
// continue ;
77046: GO 76846
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
77048: LD_VAR 0 12
77052: PUSH
77053: LD_INT 1
77055: ARRAY
77056: PPUSH
77057: CALL_OW 266
77061: PUSH
77062: LD_INT 5
77064: EQUAL
77065: IFFALSE 77139
// begin if UnitsInside ( f [ 1 ] ) < 3 then
77067: LD_VAR 0 12
77071: PUSH
77072: LD_INT 1
77074: ARRAY
77075: PPUSH
77076: CALL_OW 313
77080: PUSH
77081: LD_INT 3
77083: LESS
77084: IFFALSE 77120
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
77086: LD_INT 0
77088: PPUSH
77089: LD_INT 5
77091: PUSH
77092: LD_INT 8
77094: PUSH
77095: LD_INT 9
77097: PUSH
77098: EMPTY
77099: LIST
77100: LIST
77101: LIST
77102: PUSH
77103: LD_VAR 0 17
77107: ARRAY
77108: PPUSH
77109: LD_VAR 0 4
77113: PPUSH
77114: CALL_OW 380
77118: GO 77137
// PrepareHuman ( false , i , skill ) ;
77120: LD_INT 0
77122: PPUSH
77123: LD_VAR 0 8
77127: PPUSH
77128: LD_VAR 0 4
77132: PPUSH
77133: CALL_OW 380
// end else
77137: GO 77156
// PrepareHuman ( false , i , skill ) ;
77139: LD_INT 0
77141: PPUSH
77142: LD_VAR 0 8
77146: PPUSH
77147: LD_VAR 0 4
77151: PPUSH
77152: CALL_OW 380
// un := CreateHuman ;
77156: LD_ADDR_VAR 0 14
77160: PUSH
77161: CALL_OW 44
77165: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
77166: LD_ADDR_VAR 0 7
77170: PUSH
77171: LD_VAR 0 7
77175: PPUSH
77176: LD_INT 1
77178: PPUSH
77179: LD_VAR 0 14
77183: PPUSH
77184: CALL_OW 2
77188: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
77189: LD_VAR 0 14
77193: PPUSH
77194: LD_VAR 0 12
77198: PUSH
77199: LD_INT 1
77201: ARRAY
77202: PPUSH
77203: CALL_OW 52
// end ;
77207: GO 76846
77209: POP
77210: POP
// end ;
77211: GO 76148
77213: POP
77214: POP
// result := result ^ buildings ;
77215: LD_ADDR_VAR 0 7
77219: PUSH
77220: LD_VAR 0 7
77224: PUSH
77225: LD_VAR 0 18
77229: ADD
77230: ST_TO_ADDR
// end else
77231: GO 77374
// begin for i = 1 to personel do
77233: LD_ADDR_VAR 0 8
77237: PUSH
77238: DOUBLE
77239: LD_INT 1
77241: DEC
77242: ST_TO_ADDR
77243: LD_VAR 0 6
77247: PUSH
77248: FOR_TO
77249: IFFALSE 77372
// begin if i > 4 then
77251: LD_VAR 0 8
77255: PUSH
77256: LD_INT 4
77258: GREATER
77259: IFFALSE 77263
// break ;
77261: GO 77372
// x := personel [ i ] ;
77263: LD_ADDR_VAR 0 13
77267: PUSH
77268: LD_VAR 0 6
77272: PUSH
77273: LD_VAR 0 8
77277: ARRAY
77278: ST_TO_ADDR
// if x = - 1 then
77279: LD_VAR 0 13
77283: PUSH
77284: LD_INT 1
77286: NEG
77287: EQUAL
77288: IFFALSE 77292
// continue ;
77290: GO 77248
// PrepareHuman ( false , i , skill ) ;
77292: LD_INT 0
77294: PPUSH
77295: LD_VAR 0 8
77299: PPUSH
77300: LD_VAR 0 4
77304: PPUSH
77305: CALL_OW 380
// un := CreateHuman ;
77309: LD_ADDR_VAR 0 14
77313: PUSH
77314: CALL_OW 44
77318: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
77319: LD_VAR 0 14
77323: PPUSH
77324: LD_VAR 0 1
77328: PPUSH
77329: CALL_OW 250
77333: PPUSH
77334: LD_VAR 0 1
77338: PPUSH
77339: CALL_OW 251
77343: PPUSH
77344: LD_INT 10
77346: PPUSH
77347: LD_INT 0
77349: PPUSH
77350: CALL_OW 50
// result := result ^ un ;
77354: LD_ADDR_VAR 0 7
77358: PUSH
77359: LD_VAR 0 7
77363: PUSH
77364: LD_VAR 0 14
77368: ADD
77369: ST_TO_ADDR
// end ;
77370: GO 77248
77372: POP
77373: POP
// end ; end ;
77374: LD_VAR 0 7
77378: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
77379: LD_INT 0
77381: PPUSH
77382: PPUSH
77383: PPUSH
77384: PPUSH
77385: PPUSH
77386: PPUSH
77387: PPUSH
77388: PPUSH
77389: PPUSH
77390: PPUSH
77391: PPUSH
77392: PPUSH
77393: PPUSH
77394: PPUSH
77395: PPUSH
77396: PPUSH
// result := false ;
77397: LD_ADDR_VAR 0 3
77401: PUSH
77402: LD_INT 0
77404: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
77405: LD_VAR 0 1
77409: NOT
77410: PUSH
77411: LD_VAR 0 1
77415: PPUSH
77416: CALL_OW 266
77420: PUSH
77421: LD_INT 32
77423: PUSH
77424: LD_INT 33
77426: PUSH
77427: EMPTY
77428: LIST
77429: LIST
77430: IN
77431: NOT
77432: OR
77433: IFFALSE 77437
// exit ;
77435: GO 78546
// nat := GetNation ( tower ) ;
77437: LD_ADDR_VAR 0 12
77441: PUSH
77442: LD_VAR 0 1
77446: PPUSH
77447: CALL_OW 248
77451: ST_TO_ADDR
// side := GetSide ( tower ) ;
77452: LD_ADDR_VAR 0 16
77456: PUSH
77457: LD_VAR 0 1
77461: PPUSH
77462: CALL_OW 255
77466: ST_TO_ADDR
// x := GetX ( tower ) ;
77467: LD_ADDR_VAR 0 10
77471: PUSH
77472: LD_VAR 0 1
77476: PPUSH
77477: CALL_OW 250
77481: ST_TO_ADDR
// y := GetY ( tower ) ;
77482: LD_ADDR_VAR 0 11
77486: PUSH
77487: LD_VAR 0 1
77491: PPUSH
77492: CALL_OW 251
77496: ST_TO_ADDR
// if not x or not y then
77497: LD_VAR 0 10
77501: NOT
77502: PUSH
77503: LD_VAR 0 11
77507: NOT
77508: OR
77509: IFFALSE 77513
// exit ;
77511: GO 78546
// weapon := 0 ;
77513: LD_ADDR_VAR 0 18
77517: PUSH
77518: LD_INT 0
77520: ST_TO_ADDR
// fac_list := [ ] ;
77521: LD_ADDR_VAR 0 17
77525: PUSH
77526: EMPTY
77527: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
77528: LD_ADDR_VAR 0 6
77532: PUSH
77533: LD_VAR 0 1
77537: PPUSH
77538: CALL_OW 274
77542: PPUSH
77543: LD_VAR 0 2
77547: PPUSH
77548: LD_INT 0
77550: PPUSH
77551: CALL 75117 0 3
77555: PPUSH
77556: LD_INT 30
77558: PUSH
77559: LD_INT 3
77561: PUSH
77562: EMPTY
77563: LIST
77564: LIST
77565: PPUSH
77566: CALL_OW 72
77570: ST_TO_ADDR
// if not factories then
77571: LD_VAR 0 6
77575: NOT
77576: IFFALSE 77580
// exit ;
77578: GO 78546
// for i in factories do
77580: LD_ADDR_VAR 0 8
77584: PUSH
77585: LD_VAR 0 6
77589: PUSH
77590: FOR_IN
77591: IFFALSE 77616
// fac_list := fac_list union AvailableWeaponList ( i ) ;
77593: LD_ADDR_VAR 0 17
77597: PUSH
77598: LD_VAR 0 17
77602: PUSH
77603: LD_VAR 0 8
77607: PPUSH
77608: CALL_OW 478
77612: UNION
77613: ST_TO_ADDR
77614: GO 77590
77616: POP
77617: POP
// if not fac_list then
77618: LD_VAR 0 17
77622: NOT
77623: IFFALSE 77627
// exit ;
77625: GO 78546
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
77627: LD_ADDR_VAR 0 5
77631: PUSH
77632: LD_INT 4
77634: PUSH
77635: LD_INT 5
77637: PUSH
77638: LD_INT 9
77640: PUSH
77641: LD_INT 10
77643: PUSH
77644: LD_INT 6
77646: PUSH
77647: LD_INT 7
77649: PUSH
77650: LD_INT 11
77652: PUSH
77653: EMPTY
77654: LIST
77655: LIST
77656: LIST
77657: LIST
77658: LIST
77659: LIST
77660: LIST
77661: PUSH
77662: LD_INT 27
77664: PUSH
77665: LD_INT 28
77667: PUSH
77668: LD_INT 26
77670: PUSH
77671: LD_INT 30
77673: PUSH
77674: EMPTY
77675: LIST
77676: LIST
77677: LIST
77678: LIST
77679: PUSH
77680: LD_INT 43
77682: PUSH
77683: LD_INT 44
77685: PUSH
77686: LD_INT 46
77688: PUSH
77689: LD_INT 45
77691: PUSH
77692: LD_INT 47
77694: PUSH
77695: LD_INT 49
77697: PUSH
77698: EMPTY
77699: LIST
77700: LIST
77701: LIST
77702: LIST
77703: LIST
77704: LIST
77705: PUSH
77706: EMPTY
77707: LIST
77708: LIST
77709: LIST
77710: PUSH
77711: LD_VAR 0 12
77715: ARRAY
77716: ST_TO_ADDR
// list := list isect fac_list ;
77717: LD_ADDR_VAR 0 5
77721: PUSH
77722: LD_VAR 0 5
77726: PUSH
77727: LD_VAR 0 17
77731: ISECT
77732: ST_TO_ADDR
// if not list then
77733: LD_VAR 0 5
77737: NOT
77738: IFFALSE 77742
// exit ;
77740: GO 78546
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
77742: LD_VAR 0 12
77746: PUSH
77747: LD_INT 3
77749: EQUAL
77750: PUSH
77751: LD_INT 49
77753: PUSH
77754: LD_VAR 0 5
77758: IN
77759: AND
77760: PUSH
77761: LD_INT 31
77763: PPUSH
77764: LD_VAR 0 16
77768: PPUSH
77769: CALL_OW 321
77773: PUSH
77774: LD_INT 2
77776: EQUAL
77777: AND
77778: IFFALSE 77838
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
77780: LD_INT 22
77782: PUSH
77783: LD_VAR 0 16
77787: PUSH
77788: EMPTY
77789: LIST
77790: LIST
77791: PUSH
77792: LD_INT 35
77794: PUSH
77795: LD_INT 49
77797: PUSH
77798: EMPTY
77799: LIST
77800: LIST
77801: PUSH
77802: LD_INT 91
77804: PUSH
77805: LD_VAR 0 1
77809: PUSH
77810: LD_INT 10
77812: PUSH
77813: EMPTY
77814: LIST
77815: LIST
77816: LIST
77817: PUSH
77818: EMPTY
77819: LIST
77820: LIST
77821: LIST
77822: PPUSH
77823: CALL_OW 69
77827: NOT
77828: IFFALSE 77838
// weapon := ru_time_lapser ;
77830: LD_ADDR_VAR 0 18
77834: PUSH
77835: LD_INT 49
77837: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
77838: LD_VAR 0 12
77842: PUSH
77843: LD_INT 1
77845: PUSH
77846: LD_INT 2
77848: PUSH
77849: EMPTY
77850: LIST
77851: LIST
77852: IN
77853: PUSH
77854: LD_INT 11
77856: PUSH
77857: LD_VAR 0 5
77861: IN
77862: PUSH
77863: LD_INT 30
77865: PUSH
77866: LD_VAR 0 5
77870: IN
77871: OR
77872: AND
77873: PUSH
77874: LD_INT 6
77876: PPUSH
77877: LD_VAR 0 16
77881: PPUSH
77882: CALL_OW 321
77886: PUSH
77887: LD_INT 2
77889: EQUAL
77890: AND
77891: IFFALSE 78056
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
77893: LD_INT 22
77895: PUSH
77896: LD_VAR 0 16
77900: PUSH
77901: EMPTY
77902: LIST
77903: LIST
77904: PUSH
77905: LD_INT 2
77907: PUSH
77908: LD_INT 35
77910: PUSH
77911: LD_INT 11
77913: PUSH
77914: EMPTY
77915: LIST
77916: LIST
77917: PUSH
77918: LD_INT 35
77920: PUSH
77921: LD_INT 30
77923: PUSH
77924: EMPTY
77925: LIST
77926: LIST
77927: PUSH
77928: EMPTY
77929: LIST
77930: LIST
77931: LIST
77932: PUSH
77933: LD_INT 91
77935: PUSH
77936: LD_VAR 0 1
77940: PUSH
77941: LD_INT 18
77943: PUSH
77944: EMPTY
77945: LIST
77946: LIST
77947: LIST
77948: PUSH
77949: EMPTY
77950: LIST
77951: LIST
77952: LIST
77953: PPUSH
77954: CALL_OW 69
77958: NOT
77959: PUSH
77960: LD_INT 22
77962: PUSH
77963: LD_VAR 0 16
77967: PUSH
77968: EMPTY
77969: LIST
77970: LIST
77971: PUSH
77972: LD_INT 2
77974: PUSH
77975: LD_INT 30
77977: PUSH
77978: LD_INT 32
77980: PUSH
77981: EMPTY
77982: LIST
77983: LIST
77984: PUSH
77985: LD_INT 30
77987: PUSH
77988: LD_INT 33
77990: PUSH
77991: EMPTY
77992: LIST
77993: LIST
77994: PUSH
77995: EMPTY
77996: LIST
77997: LIST
77998: LIST
77999: PUSH
78000: LD_INT 91
78002: PUSH
78003: LD_VAR 0 1
78007: PUSH
78008: LD_INT 12
78010: PUSH
78011: EMPTY
78012: LIST
78013: LIST
78014: LIST
78015: PUSH
78016: EMPTY
78017: LIST
78018: LIST
78019: LIST
78020: PUSH
78021: EMPTY
78022: LIST
78023: PPUSH
78024: CALL_OW 69
78028: PUSH
78029: LD_INT 2
78031: GREATER
78032: AND
78033: IFFALSE 78056
// weapon := [ us_radar , ar_radar ] [ nat ] ;
78035: LD_ADDR_VAR 0 18
78039: PUSH
78040: LD_INT 11
78042: PUSH
78043: LD_INT 30
78045: PUSH
78046: EMPTY
78047: LIST
78048: LIST
78049: PUSH
78050: LD_VAR 0 12
78054: ARRAY
78055: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
78056: LD_VAR 0 18
78060: NOT
78061: PUSH
78062: LD_INT 40
78064: PPUSH
78065: LD_VAR 0 16
78069: PPUSH
78070: CALL_OW 321
78074: PUSH
78075: LD_INT 2
78077: EQUAL
78078: AND
78079: PUSH
78080: LD_INT 7
78082: PUSH
78083: LD_VAR 0 5
78087: IN
78088: PUSH
78089: LD_INT 28
78091: PUSH
78092: LD_VAR 0 5
78096: IN
78097: OR
78098: PUSH
78099: LD_INT 45
78101: PUSH
78102: LD_VAR 0 5
78106: IN
78107: OR
78108: AND
78109: IFFALSE 78363
// begin hex := GetHexInfo ( x , y ) ;
78111: LD_ADDR_VAR 0 4
78115: PUSH
78116: LD_VAR 0 10
78120: PPUSH
78121: LD_VAR 0 11
78125: PPUSH
78126: CALL_OW 546
78130: ST_TO_ADDR
// if hex [ 1 ] then
78131: LD_VAR 0 4
78135: PUSH
78136: LD_INT 1
78138: ARRAY
78139: IFFALSE 78143
// exit ;
78141: GO 78546
// height := hex [ 2 ] ;
78143: LD_ADDR_VAR 0 15
78147: PUSH
78148: LD_VAR 0 4
78152: PUSH
78153: LD_INT 2
78155: ARRAY
78156: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
78157: LD_ADDR_VAR 0 14
78161: PUSH
78162: LD_INT 0
78164: PUSH
78165: LD_INT 2
78167: PUSH
78168: LD_INT 3
78170: PUSH
78171: LD_INT 5
78173: PUSH
78174: EMPTY
78175: LIST
78176: LIST
78177: LIST
78178: LIST
78179: ST_TO_ADDR
// for i in tmp do
78180: LD_ADDR_VAR 0 8
78184: PUSH
78185: LD_VAR 0 14
78189: PUSH
78190: FOR_IN
78191: IFFALSE 78361
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
78193: LD_ADDR_VAR 0 9
78197: PUSH
78198: LD_VAR 0 10
78202: PPUSH
78203: LD_VAR 0 8
78207: PPUSH
78208: LD_INT 5
78210: PPUSH
78211: CALL_OW 272
78215: PUSH
78216: LD_VAR 0 11
78220: PPUSH
78221: LD_VAR 0 8
78225: PPUSH
78226: LD_INT 5
78228: PPUSH
78229: CALL_OW 273
78233: PUSH
78234: EMPTY
78235: LIST
78236: LIST
78237: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
78238: LD_VAR 0 9
78242: PUSH
78243: LD_INT 1
78245: ARRAY
78246: PPUSH
78247: LD_VAR 0 9
78251: PUSH
78252: LD_INT 2
78254: ARRAY
78255: PPUSH
78256: CALL_OW 488
78260: IFFALSE 78359
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
78262: LD_ADDR_VAR 0 4
78266: PUSH
78267: LD_VAR 0 9
78271: PUSH
78272: LD_INT 1
78274: ARRAY
78275: PPUSH
78276: LD_VAR 0 9
78280: PUSH
78281: LD_INT 2
78283: ARRAY
78284: PPUSH
78285: CALL_OW 546
78289: ST_TO_ADDR
// if hex [ 1 ] then
78290: LD_VAR 0 4
78294: PUSH
78295: LD_INT 1
78297: ARRAY
78298: IFFALSE 78302
// continue ;
78300: GO 78190
// h := hex [ 2 ] ;
78302: LD_ADDR_VAR 0 13
78306: PUSH
78307: LD_VAR 0 4
78311: PUSH
78312: LD_INT 2
78314: ARRAY
78315: ST_TO_ADDR
// if h + 7 < height then
78316: LD_VAR 0 13
78320: PUSH
78321: LD_INT 7
78323: PLUS
78324: PUSH
78325: LD_VAR 0 15
78329: LESS
78330: IFFALSE 78359
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
78332: LD_ADDR_VAR 0 18
78336: PUSH
78337: LD_INT 7
78339: PUSH
78340: LD_INT 28
78342: PUSH
78343: LD_INT 45
78345: PUSH
78346: EMPTY
78347: LIST
78348: LIST
78349: LIST
78350: PUSH
78351: LD_VAR 0 12
78355: ARRAY
78356: ST_TO_ADDR
// break ;
78357: GO 78361
// end ; end ; end ;
78359: GO 78190
78361: POP
78362: POP
// end ; if not weapon then
78363: LD_VAR 0 18
78367: NOT
78368: IFFALSE 78428
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
78370: LD_ADDR_VAR 0 5
78374: PUSH
78375: LD_VAR 0 5
78379: PUSH
78380: LD_INT 11
78382: PUSH
78383: LD_INT 30
78385: PUSH
78386: LD_INT 49
78388: PUSH
78389: EMPTY
78390: LIST
78391: LIST
78392: LIST
78393: DIFF
78394: ST_TO_ADDR
// if not list then
78395: LD_VAR 0 5
78399: NOT
78400: IFFALSE 78404
// exit ;
78402: GO 78546
// weapon := list [ rand ( 1 , list ) ] ;
78404: LD_ADDR_VAR 0 18
78408: PUSH
78409: LD_VAR 0 5
78413: PUSH
78414: LD_INT 1
78416: PPUSH
78417: LD_VAR 0 5
78421: PPUSH
78422: CALL_OW 12
78426: ARRAY
78427: ST_TO_ADDR
// end ; if weapon then
78428: LD_VAR 0 18
78432: IFFALSE 78546
// begin tmp := CostOfWeapon ( weapon ) ;
78434: LD_ADDR_VAR 0 14
78438: PUSH
78439: LD_VAR 0 18
78443: PPUSH
78444: CALL_OW 451
78448: ST_TO_ADDR
// j := GetBase ( tower ) ;
78449: LD_ADDR_VAR 0 9
78453: PUSH
78454: LD_VAR 0 1
78458: PPUSH
78459: CALL_OW 274
78463: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
78464: LD_VAR 0 9
78468: PPUSH
78469: LD_INT 1
78471: PPUSH
78472: CALL_OW 275
78476: PUSH
78477: LD_VAR 0 14
78481: PUSH
78482: LD_INT 1
78484: ARRAY
78485: GREATEREQUAL
78486: PUSH
78487: LD_VAR 0 9
78491: PPUSH
78492: LD_INT 2
78494: PPUSH
78495: CALL_OW 275
78499: PUSH
78500: LD_VAR 0 14
78504: PUSH
78505: LD_INT 2
78507: ARRAY
78508: GREATEREQUAL
78509: AND
78510: PUSH
78511: LD_VAR 0 9
78515: PPUSH
78516: LD_INT 3
78518: PPUSH
78519: CALL_OW 275
78523: PUSH
78524: LD_VAR 0 14
78528: PUSH
78529: LD_INT 3
78531: ARRAY
78532: GREATEREQUAL
78533: AND
78534: IFFALSE 78546
// result := weapon ;
78536: LD_ADDR_VAR 0 3
78540: PUSH
78541: LD_VAR 0 18
78545: ST_TO_ADDR
// end ; end ;
78546: LD_VAR 0 3
78550: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
78551: LD_INT 0
78553: PPUSH
78554: PPUSH
// result := true ;
78555: LD_ADDR_VAR 0 3
78559: PUSH
78560: LD_INT 1
78562: ST_TO_ADDR
// if array1 = array2 then
78563: LD_VAR 0 1
78567: PUSH
78568: LD_VAR 0 2
78572: EQUAL
78573: IFFALSE 78633
// begin for i = 1 to array1 do
78575: LD_ADDR_VAR 0 4
78579: PUSH
78580: DOUBLE
78581: LD_INT 1
78583: DEC
78584: ST_TO_ADDR
78585: LD_VAR 0 1
78589: PUSH
78590: FOR_TO
78591: IFFALSE 78629
// if array1 [ i ] <> array2 [ i ] then
78593: LD_VAR 0 1
78597: PUSH
78598: LD_VAR 0 4
78602: ARRAY
78603: PUSH
78604: LD_VAR 0 2
78608: PUSH
78609: LD_VAR 0 4
78613: ARRAY
78614: NONEQUAL
78615: IFFALSE 78627
// begin result := false ;
78617: LD_ADDR_VAR 0 3
78621: PUSH
78622: LD_INT 0
78624: ST_TO_ADDR
// break ;
78625: GO 78629
// end ;
78627: GO 78590
78629: POP
78630: POP
// end else
78631: GO 78641
// result := false ;
78633: LD_ADDR_VAR 0 3
78637: PUSH
78638: LD_INT 0
78640: ST_TO_ADDR
// end ;
78641: LD_VAR 0 3
78645: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
78646: LD_INT 0
78648: PPUSH
78649: PPUSH
// if not array1 or not array2 then
78650: LD_VAR 0 1
78654: NOT
78655: PUSH
78656: LD_VAR 0 2
78660: NOT
78661: OR
78662: IFFALSE 78666
// exit ;
78664: GO 78730
// result := true ;
78666: LD_ADDR_VAR 0 3
78670: PUSH
78671: LD_INT 1
78673: ST_TO_ADDR
// for i = 1 to array1 do
78674: LD_ADDR_VAR 0 4
78678: PUSH
78679: DOUBLE
78680: LD_INT 1
78682: DEC
78683: ST_TO_ADDR
78684: LD_VAR 0 1
78688: PUSH
78689: FOR_TO
78690: IFFALSE 78728
// if array1 [ i ] <> array2 [ i ] then
78692: LD_VAR 0 1
78696: PUSH
78697: LD_VAR 0 4
78701: ARRAY
78702: PUSH
78703: LD_VAR 0 2
78707: PUSH
78708: LD_VAR 0 4
78712: ARRAY
78713: NONEQUAL
78714: IFFALSE 78726
// begin result := false ;
78716: LD_ADDR_VAR 0 3
78720: PUSH
78721: LD_INT 0
78723: ST_TO_ADDR
// break ;
78724: GO 78728
// end ;
78726: GO 78689
78728: POP
78729: POP
// end ;
78730: LD_VAR 0 3
78734: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
78735: LD_INT 0
78737: PPUSH
78738: PPUSH
78739: PPUSH
// pom := GetBase ( fac ) ;
78740: LD_ADDR_VAR 0 5
78744: PUSH
78745: LD_VAR 0 1
78749: PPUSH
78750: CALL_OW 274
78754: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
78755: LD_ADDR_VAR 0 4
78759: PUSH
78760: LD_VAR 0 2
78764: PUSH
78765: LD_INT 1
78767: ARRAY
78768: PPUSH
78769: LD_VAR 0 2
78773: PUSH
78774: LD_INT 2
78776: ARRAY
78777: PPUSH
78778: LD_VAR 0 2
78782: PUSH
78783: LD_INT 3
78785: ARRAY
78786: PPUSH
78787: LD_VAR 0 2
78791: PUSH
78792: LD_INT 4
78794: ARRAY
78795: PPUSH
78796: CALL_OW 449
78800: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78801: LD_ADDR_VAR 0 3
78805: PUSH
78806: LD_VAR 0 5
78810: PPUSH
78811: LD_INT 1
78813: PPUSH
78814: CALL_OW 275
78818: PUSH
78819: LD_VAR 0 4
78823: PUSH
78824: LD_INT 1
78826: ARRAY
78827: GREATEREQUAL
78828: PUSH
78829: LD_VAR 0 5
78833: PPUSH
78834: LD_INT 2
78836: PPUSH
78837: CALL_OW 275
78841: PUSH
78842: LD_VAR 0 4
78846: PUSH
78847: LD_INT 2
78849: ARRAY
78850: GREATEREQUAL
78851: AND
78852: PUSH
78853: LD_VAR 0 5
78857: PPUSH
78858: LD_INT 3
78860: PPUSH
78861: CALL_OW 275
78865: PUSH
78866: LD_VAR 0 4
78870: PUSH
78871: LD_INT 3
78873: ARRAY
78874: GREATEREQUAL
78875: AND
78876: ST_TO_ADDR
// end ;
78877: LD_VAR 0 3
78881: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
78882: LD_INT 0
78884: PPUSH
78885: PPUSH
78886: PPUSH
78887: PPUSH
// pom := GetBase ( building ) ;
78888: LD_ADDR_VAR 0 3
78892: PUSH
78893: LD_VAR 0 1
78897: PPUSH
78898: CALL_OW 274
78902: ST_TO_ADDR
// if not pom then
78903: LD_VAR 0 3
78907: NOT
78908: IFFALSE 78912
// exit ;
78910: GO 79082
// btype := GetBType ( building ) ;
78912: LD_ADDR_VAR 0 5
78916: PUSH
78917: LD_VAR 0 1
78921: PPUSH
78922: CALL_OW 266
78926: ST_TO_ADDR
// if btype = b_armoury then
78927: LD_VAR 0 5
78931: PUSH
78932: LD_INT 4
78934: EQUAL
78935: IFFALSE 78945
// btype := b_barracks ;
78937: LD_ADDR_VAR 0 5
78941: PUSH
78942: LD_INT 5
78944: ST_TO_ADDR
// if btype = b_depot then
78945: LD_VAR 0 5
78949: PUSH
78950: LD_INT 0
78952: EQUAL
78953: IFFALSE 78963
// btype := b_warehouse ;
78955: LD_ADDR_VAR 0 5
78959: PUSH
78960: LD_INT 1
78962: ST_TO_ADDR
// if btype = b_workshop then
78963: LD_VAR 0 5
78967: PUSH
78968: LD_INT 2
78970: EQUAL
78971: IFFALSE 78981
// btype := b_factory ;
78973: LD_ADDR_VAR 0 5
78977: PUSH
78978: LD_INT 3
78980: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78981: LD_ADDR_VAR 0 4
78985: PUSH
78986: LD_VAR 0 5
78990: PPUSH
78991: LD_VAR 0 1
78995: PPUSH
78996: CALL_OW 248
79000: PPUSH
79001: CALL_OW 450
79005: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79006: LD_ADDR_VAR 0 2
79010: PUSH
79011: LD_VAR 0 3
79015: PPUSH
79016: LD_INT 1
79018: PPUSH
79019: CALL_OW 275
79023: PUSH
79024: LD_VAR 0 4
79028: PUSH
79029: LD_INT 1
79031: ARRAY
79032: GREATEREQUAL
79033: PUSH
79034: LD_VAR 0 3
79038: PPUSH
79039: LD_INT 2
79041: PPUSH
79042: CALL_OW 275
79046: PUSH
79047: LD_VAR 0 4
79051: PUSH
79052: LD_INT 2
79054: ARRAY
79055: GREATEREQUAL
79056: AND
79057: PUSH
79058: LD_VAR 0 3
79062: PPUSH
79063: LD_INT 3
79065: PPUSH
79066: CALL_OW 275
79070: PUSH
79071: LD_VAR 0 4
79075: PUSH
79076: LD_INT 3
79078: ARRAY
79079: GREATEREQUAL
79080: AND
79081: ST_TO_ADDR
// end ;
79082: LD_VAR 0 2
79086: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
79087: LD_INT 0
79089: PPUSH
79090: PPUSH
79091: PPUSH
// pom := GetBase ( building ) ;
79092: LD_ADDR_VAR 0 4
79096: PUSH
79097: LD_VAR 0 1
79101: PPUSH
79102: CALL_OW 274
79106: ST_TO_ADDR
// if not pom then
79107: LD_VAR 0 4
79111: NOT
79112: IFFALSE 79116
// exit ;
79114: GO 79217
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
79116: LD_ADDR_VAR 0 5
79120: PUSH
79121: LD_VAR 0 2
79125: PPUSH
79126: LD_VAR 0 1
79130: PPUSH
79131: CALL_OW 248
79135: PPUSH
79136: CALL_OW 450
79140: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79141: LD_ADDR_VAR 0 3
79145: PUSH
79146: LD_VAR 0 4
79150: PPUSH
79151: LD_INT 1
79153: PPUSH
79154: CALL_OW 275
79158: PUSH
79159: LD_VAR 0 5
79163: PUSH
79164: LD_INT 1
79166: ARRAY
79167: GREATEREQUAL
79168: PUSH
79169: LD_VAR 0 4
79173: PPUSH
79174: LD_INT 2
79176: PPUSH
79177: CALL_OW 275
79181: PUSH
79182: LD_VAR 0 5
79186: PUSH
79187: LD_INT 2
79189: ARRAY
79190: GREATEREQUAL
79191: AND
79192: PUSH
79193: LD_VAR 0 4
79197: PPUSH
79198: LD_INT 3
79200: PPUSH
79201: CALL_OW 275
79205: PUSH
79206: LD_VAR 0 5
79210: PUSH
79211: LD_INT 3
79213: ARRAY
79214: GREATEREQUAL
79215: AND
79216: ST_TO_ADDR
// end ;
79217: LD_VAR 0 3
79221: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
79222: LD_INT 0
79224: PPUSH
79225: PPUSH
79226: PPUSH
79227: PPUSH
79228: PPUSH
79229: PPUSH
79230: PPUSH
79231: PPUSH
79232: PPUSH
79233: PPUSH
79234: PPUSH
// result := false ;
79235: LD_ADDR_VAR 0 8
79239: PUSH
79240: LD_INT 0
79242: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
79243: LD_VAR 0 5
79247: NOT
79248: PUSH
79249: LD_VAR 0 1
79253: NOT
79254: OR
79255: PUSH
79256: LD_VAR 0 2
79260: NOT
79261: OR
79262: PUSH
79263: LD_VAR 0 3
79267: NOT
79268: OR
79269: IFFALSE 79273
// exit ;
79271: GO 80087
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
79273: LD_ADDR_VAR 0 14
79277: PUSH
79278: LD_VAR 0 1
79282: PPUSH
79283: LD_VAR 0 2
79287: PPUSH
79288: LD_VAR 0 3
79292: PPUSH
79293: LD_VAR 0 4
79297: PPUSH
79298: LD_VAR 0 5
79302: PUSH
79303: LD_INT 1
79305: ARRAY
79306: PPUSH
79307: CALL_OW 248
79311: PPUSH
79312: LD_INT 0
79314: PPUSH
79315: CALL 81320 0 6
79319: ST_TO_ADDR
// if not hexes then
79320: LD_VAR 0 14
79324: NOT
79325: IFFALSE 79329
// exit ;
79327: GO 80087
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
79329: LD_ADDR_VAR 0 17
79333: PUSH
79334: LD_VAR 0 5
79338: PPUSH
79339: LD_INT 22
79341: PUSH
79342: LD_VAR 0 13
79346: PPUSH
79347: CALL_OW 255
79351: PUSH
79352: EMPTY
79353: LIST
79354: LIST
79355: PUSH
79356: LD_INT 2
79358: PUSH
79359: LD_INT 30
79361: PUSH
79362: LD_INT 0
79364: PUSH
79365: EMPTY
79366: LIST
79367: LIST
79368: PUSH
79369: LD_INT 30
79371: PUSH
79372: LD_INT 1
79374: PUSH
79375: EMPTY
79376: LIST
79377: LIST
79378: PUSH
79379: EMPTY
79380: LIST
79381: LIST
79382: LIST
79383: PUSH
79384: EMPTY
79385: LIST
79386: LIST
79387: PPUSH
79388: CALL_OW 72
79392: ST_TO_ADDR
// for i = 1 to hexes do
79393: LD_ADDR_VAR 0 9
79397: PUSH
79398: DOUBLE
79399: LD_INT 1
79401: DEC
79402: ST_TO_ADDR
79403: LD_VAR 0 14
79407: PUSH
79408: FOR_TO
79409: IFFALSE 80085
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79411: LD_ADDR_VAR 0 13
79415: PUSH
79416: LD_VAR 0 14
79420: PUSH
79421: LD_VAR 0 9
79425: ARRAY
79426: PUSH
79427: LD_INT 1
79429: ARRAY
79430: PPUSH
79431: LD_VAR 0 14
79435: PUSH
79436: LD_VAR 0 9
79440: ARRAY
79441: PUSH
79442: LD_INT 2
79444: ARRAY
79445: PPUSH
79446: CALL_OW 428
79450: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
79451: LD_VAR 0 14
79455: PUSH
79456: LD_VAR 0 9
79460: ARRAY
79461: PUSH
79462: LD_INT 1
79464: ARRAY
79465: PPUSH
79466: LD_VAR 0 14
79470: PUSH
79471: LD_VAR 0 9
79475: ARRAY
79476: PUSH
79477: LD_INT 2
79479: ARRAY
79480: PPUSH
79481: CALL_OW 351
79485: PUSH
79486: LD_VAR 0 14
79490: PUSH
79491: LD_VAR 0 9
79495: ARRAY
79496: PUSH
79497: LD_INT 1
79499: ARRAY
79500: PPUSH
79501: LD_VAR 0 14
79505: PUSH
79506: LD_VAR 0 9
79510: ARRAY
79511: PUSH
79512: LD_INT 2
79514: ARRAY
79515: PPUSH
79516: CALL_OW 488
79520: NOT
79521: OR
79522: PUSH
79523: LD_VAR 0 13
79527: PPUSH
79528: CALL_OW 247
79532: PUSH
79533: LD_INT 3
79535: EQUAL
79536: OR
79537: IFFALSE 79543
// exit ;
79539: POP
79540: POP
79541: GO 80087
// if not tmp then
79543: LD_VAR 0 13
79547: NOT
79548: IFFALSE 79552
// continue ;
79550: GO 79408
// result := true ;
79552: LD_ADDR_VAR 0 8
79556: PUSH
79557: LD_INT 1
79559: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
79560: LD_VAR 0 6
79564: PUSH
79565: LD_VAR 0 13
79569: PPUSH
79570: CALL_OW 247
79574: PUSH
79575: LD_INT 2
79577: EQUAL
79578: AND
79579: PUSH
79580: LD_VAR 0 13
79584: PPUSH
79585: CALL_OW 263
79589: PUSH
79590: LD_INT 1
79592: EQUAL
79593: AND
79594: IFFALSE 79758
// begin if IsDrivenBy ( tmp ) then
79596: LD_VAR 0 13
79600: PPUSH
79601: CALL_OW 311
79605: IFFALSE 79609
// continue ;
79607: GO 79408
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
79609: LD_VAR 0 6
79613: PPUSH
79614: LD_INT 3
79616: PUSH
79617: LD_INT 60
79619: PUSH
79620: EMPTY
79621: LIST
79622: PUSH
79623: EMPTY
79624: LIST
79625: LIST
79626: PUSH
79627: LD_INT 3
79629: PUSH
79630: LD_INT 55
79632: PUSH
79633: EMPTY
79634: LIST
79635: PUSH
79636: EMPTY
79637: LIST
79638: LIST
79639: PUSH
79640: EMPTY
79641: LIST
79642: LIST
79643: PPUSH
79644: CALL_OW 72
79648: IFFALSE 79756
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
79650: LD_ADDR_VAR 0 18
79654: PUSH
79655: LD_VAR 0 6
79659: PPUSH
79660: LD_INT 3
79662: PUSH
79663: LD_INT 60
79665: PUSH
79666: EMPTY
79667: LIST
79668: PUSH
79669: EMPTY
79670: LIST
79671: LIST
79672: PUSH
79673: LD_INT 3
79675: PUSH
79676: LD_INT 55
79678: PUSH
79679: EMPTY
79680: LIST
79681: PUSH
79682: EMPTY
79683: LIST
79684: LIST
79685: PUSH
79686: EMPTY
79687: LIST
79688: LIST
79689: PPUSH
79690: CALL_OW 72
79694: PUSH
79695: LD_INT 1
79697: ARRAY
79698: ST_TO_ADDR
// if IsInUnit ( driver ) then
79699: LD_VAR 0 18
79703: PPUSH
79704: CALL_OW 310
79708: IFFALSE 79719
// ComExit ( driver ) ;
79710: LD_VAR 0 18
79714: PPUSH
79715: CALL 105081 0 1
// AddComEnterUnit ( driver , tmp ) ;
79719: LD_VAR 0 18
79723: PPUSH
79724: LD_VAR 0 13
79728: PPUSH
79729: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
79733: LD_VAR 0 18
79737: PPUSH
79738: LD_VAR 0 7
79742: PPUSH
79743: CALL_OW 173
// AddComExitVehicle ( driver ) ;
79747: LD_VAR 0 18
79751: PPUSH
79752: CALL_OW 181
// end ; continue ;
79756: GO 79408
// end ; if not cleaners or not tmp in cleaners then
79758: LD_VAR 0 6
79762: NOT
79763: PUSH
79764: LD_VAR 0 13
79768: PUSH
79769: LD_VAR 0 6
79773: IN
79774: NOT
79775: OR
79776: IFFALSE 80083
// begin if dep then
79778: LD_VAR 0 17
79782: IFFALSE 79918
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
79784: LD_ADDR_VAR 0 16
79788: PUSH
79789: LD_VAR 0 17
79793: PUSH
79794: LD_INT 1
79796: ARRAY
79797: PPUSH
79798: CALL_OW 250
79802: PPUSH
79803: LD_VAR 0 17
79807: PUSH
79808: LD_INT 1
79810: ARRAY
79811: PPUSH
79812: CALL_OW 254
79816: PPUSH
79817: LD_INT 5
79819: PPUSH
79820: CALL_OW 272
79824: PUSH
79825: LD_VAR 0 17
79829: PUSH
79830: LD_INT 1
79832: ARRAY
79833: PPUSH
79834: CALL_OW 251
79838: PPUSH
79839: LD_VAR 0 17
79843: PUSH
79844: LD_INT 1
79846: ARRAY
79847: PPUSH
79848: CALL_OW 254
79852: PPUSH
79853: LD_INT 5
79855: PPUSH
79856: CALL_OW 273
79860: PUSH
79861: EMPTY
79862: LIST
79863: LIST
79864: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
79865: LD_VAR 0 16
79869: PUSH
79870: LD_INT 1
79872: ARRAY
79873: PPUSH
79874: LD_VAR 0 16
79878: PUSH
79879: LD_INT 2
79881: ARRAY
79882: PPUSH
79883: CALL_OW 488
79887: IFFALSE 79918
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
79889: LD_VAR 0 13
79893: PPUSH
79894: LD_VAR 0 16
79898: PUSH
79899: LD_INT 1
79901: ARRAY
79902: PPUSH
79903: LD_VAR 0 16
79907: PUSH
79908: LD_INT 2
79910: ARRAY
79911: PPUSH
79912: CALL_OW 111
// continue ;
79916: GO 79408
// end ; end ; r := GetDir ( tmp ) ;
79918: LD_ADDR_VAR 0 15
79922: PUSH
79923: LD_VAR 0 13
79927: PPUSH
79928: CALL_OW 254
79932: ST_TO_ADDR
// if r = 5 then
79933: LD_VAR 0 15
79937: PUSH
79938: LD_INT 5
79940: EQUAL
79941: IFFALSE 79951
// r := 0 ;
79943: LD_ADDR_VAR 0 15
79947: PUSH
79948: LD_INT 0
79950: ST_TO_ADDR
// for j = r to 5 do
79951: LD_ADDR_VAR 0 10
79955: PUSH
79956: DOUBLE
79957: LD_VAR 0 15
79961: DEC
79962: ST_TO_ADDR
79963: LD_INT 5
79965: PUSH
79966: FOR_TO
79967: IFFALSE 80081
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
79969: LD_ADDR_VAR 0 11
79973: PUSH
79974: LD_VAR 0 13
79978: PPUSH
79979: CALL_OW 250
79983: PPUSH
79984: LD_VAR 0 10
79988: PPUSH
79989: LD_INT 2
79991: PPUSH
79992: CALL_OW 272
79996: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
79997: LD_ADDR_VAR 0 12
80001: PUSH
80002: LD_VAR 0 13
80006: PPUSH
80007: CALL_OW 251
80011: PPUSH
80012: LD_VAR 0 10
80016: PPUSH
80017: LD_INT 2
80019: PPUSH
80020: CALL_OW 273
80024: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
80025: LD_VAR 0 11
80029: PPUSH
80030: LD_VAR 0 12
80034: PPUSH
80035: CALL_OW 488
80039: PUSH
80040: LD_VAR 0 11
80044: PPUSH
80045: LD_VAR 0 12
80049: PPUSH
80050: CALL_OW 428
80054: NOT
80055: AND
80056: IFFALSE 80079
// begin ComMoveXY ( tmp , _x , _y ) ;
80058: LD_VAR 0 13
80062: PPUSH
80063: LD_VAR 0 11
80067: PPUSH
80068: LD_VAR 0 12
80072: PPUSH
80073: CALL_OW 111
// break ;
80077: GO 80081
// end ; end ;
80079: GO 79966
80081: POP
80082: POP
// end ; end ;
80083: GO 79408
80085: POP
80086: POP
// end ;
80087: LD_VAR 0 8
80091: RET
// export function BuildingTechInvented ( side , btype ) ; begin
80092: LD_INT 0
80094: PPUSH
// result := true ;
80095: LD_ADDR_VAR 0 3
80099: PUSH
80100: LD_INT 1
80102: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
80103: LD_VAR 0 2
80107: PUSH
80108: LD_INT 24
80110: DOUBLE
80111: EQUAL
80112: IFTRUE 80122
80114: LD_INT 33
80116: DOUBLE
80117: EQUAL
80118: IFTRUE 80122
80120: GO 80147
80122: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
80123: LD_ADDR_VAR 0 3
80127: PUSH
80128: LD_INT 32
80130: PPUSH
80131: LD_VAR 0 1
80135: PPUSH
80136: CALL_OW 321
80140: PUSH
80141: LD_INT 2
80143: EQUAL
80144: ST_TO_ADDR
80145: GO 80463
80147: LD_INT 20
80149: DOUBLE
80150: EQUAL
80151: IFTRUE 80155
80153: GO 80180
80155: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
80156: LD_ADDR_VAR 0 3
80160: PUSH
80161: LD_INT 6
80163: PPUSH
80164: LD_VAR 0 1
80168: PPUSH
80169: CALL_OW 321
80173: PUSH
80174: LD_INT 2
80176: EQUAL
80177: ST_TO_ADDR
80178: GO 80463
80180: LD_INT 22
80182: DOUBLE
80183: EQUAL
80184: IFTRUE 80194
80186: LD_INT 36
80188: DOUBLE
80189: EQUAL
80190: IFTRUE 80194
80192: GO 80219
80194: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
80195: LD_ADDR_VAR 0 3
80199: PUSH
80200: LD_INT 15
80202: PPUSH
80203: LD_VAR 0 1
80207: PPUSH
80208: CALL_OW 321
80212: PUSH
80213: LD_INT 2
80215: EQUAL
80216: ST_TO_ADDR
80217: GO 80463
80219: LD_INT 30
80221: DOUBLE
80222: EQUAL
80223: IFTRUE 80227
80225: GO 80252
80227: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
80228: LD_ADDR_VAR 0 3
80232: PUSH
80233: LD_INT 20
80235: PPUSH
80236: LD_VAR 0 1
80240: PPUSH
80241: CALL_OW 321
80245: PUSH
80246: LD_INT 2
80248: EQUAL
80249: ST_TO_ADDR
80250: GO 80463
80252: LD_INT 28
80254: DOUBLE
80255: EQUAL
80256: IFTRUE 80266
80258: LD_INT 21
80260: DOUBLE
80261: EQUAL
80262: IFTRUE 80266
80264: GO 80291
80266: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
80267: LD_ADDR_VAR 0 3
80271: PUSH
80272: LD_INT 21
80274: PPUSH
80275: LD_VAR 0 1
80279: PPUSH
80280: CALL_OW 321
80284: PUSH
80285: LD_INT 2
80287: EQUAL
80288: ST_TO_ADDR
80289: GO 80463
80291: LD_INT 16
80293: DOUBLE
80294: EQUAL
80295: IFTRUE 80299
80297: GO 80324
80299: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
80300: LD_ADDR_VAR 0 3
80304: PUSH
80305: LD_INT 84
80307: PPUSH
80308: LD_VAR 0 1
80312: PPUSH
80313: CALL_OW 321
80317: PUSH
80318: LD_INT 2
80320: EQUAL
80321: ST_TO_ADDR
80322: GO 80463
80324: LD_INT 19
80326: DOUBLE
80327: EQUAL
80328: IFTRUE 80338
80330: LD_INT 23
80332: DOUBLE
80333: EQUAL
80334: IFTRUE 80338
80336: GO 80363
80338: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
80339: LD_ADDR_VAR 0 3
80343: PUSH
80344: LD_INT 83
80346: PPUSH
80347: LD_VAR 0 1
80351: PPUSH
80352: CALL_OW 321
80356: PUSH
80357: LD_INT 2
80359: EQUAL
80360: ST_TO_ADDR
80361: GO 80463
80363: LD_INT 17
80365: DOUBLE
80366: EQUAL
80367: IFTRUE 80371
80369: GO 80396
80371: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
80372: LD_ADDR_VAR 0 3
80376: PUSH
80377: LD_INT 39
80379: PPUSH
80380: LD_VAR 0 1
80384: PPUSH
80385: CALL_OW 321
80389: PUSH
80390: LD_INT 2
80392: EQUAL
80393: ST_TO_ADDR
80394: GO 80463
80396: LD_INT 18
80398: DOUBLE
80399: EQUAL
80400: IFTRUE 80404
80402: GO 80429
80404: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
80405: LD_ADDR_VAR 0 3
80409: PUSH
80410: LD_INT 40
80412: PPUSH
80413: LD_VAR 0 1
80417: PPUSH
80418: CALL_OW 321
80422: PUSH
80423: LD_INT 2
80425: EQUAL
80426: ST_TO_ADDR
80427: GO 80463
80429: LD_INT 27
80431: DOUBLE
80432: EQUAL
80433: IFTRUE 80437
80435: GO 80462
80437: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
80438: LD_ADDR_VAR 0 3
80442: PUSH
80443: LD_INT 35
80445: PPUSH
80446: LD_VAR 0 1
80450: PPUSH
80451: CALL_OW 321
80455: PUSH
80456: LD_INT 2
80458: EQUAL
80459: ST_TO_ADDR
80460: GO 80463
80462: POP
// end ;
80463: LD_VAR 0 3
80467: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
80468: LD_INT 0
80470: PPUSH
80471: PPUSH
80472: PPUSH
80473: PPUSH
80474: PPUSH
80475: PPUSH
80476: PPUSH
80477: PPUSH
80478: PPUSH
80479: PPUSH
80480: PPUSH
// result := false ;
80481: LD_ADDR_VAR 0 6
80485: PUSH
80486: LD_INT 0
80488: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
80489: LD_VAR 0 1
80493: NOT
80494: PUSH
80495: LD_VAR 0 1
80499: PPUSH
80500: CALL_OW 266
80504: PUSH
80505: LD_INT 0
80507: PUSH
80508: LD_INT 1
80510: PUSH
80511: EMPTY
80512: LIST
80513: LIST
80514: IN
80515: NOT
80516: OR
80517: PUSH
80518: LD_VAR 0 2
80522: NOT
80523: OR
80524: PUSH
80525: LD_VAR 0 5
80529: PUSH
80530: LD_INT 0
80532: PUSH
80533: LD_INT 1
80535: PUSH
80536: LD_INT 2
80538: PUSH
80539: LD_INT 3
80541: PUSH
80542: LD_INT 4
80544: PUSH
80545: LD_INT 5
80547: PUSH
80548: EMPTY
80549: LIST
80550: LIST
80551: LIST
80552: LIST
80553: LIST
80554: LIST
80555: IN
80556: NOT
80557: OR
80558: PUSH
80559: LD_VAR 0 3
80563: PPUSH
80564: LD_VAR 0 4
80568: PPUSH
80569: CALL_OW 488
80573: NOT
80574: OR
80575: IFFALSE 80579
// exit ;
80577: GO 81315
// side := GetSide ( depot ) ;
80579: LD_ADDR_VAR 0 9
80583: PUSH
80584: LD_VAR 0 1
80588: PPUSH
80589: CALL_OW 255
80593: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
80594: LD_VAR 0 9
80598: PPUSH
80599: LD_VAR 0 2
80603: PPUSH
80604: CALL 80092 0 2
80608: NOT
80609: IFFALSE 80613
// exit ;
80611: GO 81315
// pom := GetBase ( depot ) ;
80613: LD_ADDR_VAR 0 10
80617: PUSH
80618: LD_VAR 0 1
80622: PPUSH
80623: CALL_OW 274
80627: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
80628: LD_ADDR_VAR 0 11
80632: PUSH
80633: LD_VAR 0 2
80637: PPUSH
80638: LD_VAR 0 1
80642: PPUSH
80643: CALL_OW 248
80647: PPUSH
80648: CALL_OW 450
80652: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
80653: LD_VAR 0 10
80657: PPUSH
80658: LD_INT 1
80660: PPUSH
80661: CALL_OW 275
80665: PUSH
80666: LD_VAR 0 11
80670: PUSH
80671: LD_INT 1
80673: ARRAY
80674: GREATEREQUAL
80675: PUSH
80676: LD_VAR 0 10
80680: PPUSH
80681: LD_INT 2
80683: PPUSH
80684: CALL_OW 275
80688: PUSH
80689: LD_VAR 0 11
80693: PUSH
80694: LD_INT 2
80696: ARRAY
80697: GREATEREQUAL
80698: AND
80699: PUSH
80700: LD_VAR 0 10
80704: PPUSH
80705: LD_INT 3
80707: PPUSH
80708: CALL_OW 275
80712: PUSH
80713: LD_VAR 0 11
80717: PUSH
80718: LD_INT 3
80720: ARRAY
80721: GREATEREQUAL
80722: AND
80723: NOT
80724: IFFALSE 80728
// exit ;
80726: GO 81315
// if GetBType ( depot ) = b_depot then
80728: LD_VAR 0 1
80732: PPUSH
80733: CALL_OW 266
80737: PUSH
80738: LD_INT 0
80740: EQUAL
80741: IFFALSE 80753
// dist := 28 else
80743: LD_ADDR_VAR 0 14
80747: PUSH
80748: LD_INT 28
80750: ST_TO_ADDR
80751: GO 80761
// dist := 36 ;
80753: LD_ADDR_VAR 0 14
80757: PUSH
80758: LD_INT 36
80760: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
80761: LD_VAR 0 1
80765: PPUSH
80766: LD_VAR 0 3
80770: PPUSH
80771: LD_VAR 0 4
80775: PPUSH
80776: CALL_OW 297
80780: PUSH
80781: LD_VAR 0 14
80785: GREATER
80786: IFFALSE 80790
// exit ;
80788: GO 81315
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
80790: LD_ADDR_VAR 0 12
80794: PUSH
80795: LD_VAR 0 2
80799: PPUSH
80800: LD_VAR 0 3
80804: PPUSH
80805: LD_VAR 0 4
80809: PPUSH
80810: LD_VAR 0 5
80814: PPUSH
80815: LD_VAR 0 1
80819: PPUSH
80820: CALL_OW 248
80824: PPUSH
80825: LD_INT 0
80827: PPUSH
80828: CALL 81320 0 6
80832: ST_TO_ADDR
// if not hexes then
80833: LD_VAR 0 12
80837: NOT
80838: IFFALSE 80842
// exit ;
80840: GO 81315
// hex := GetHexInfo ( x , y ) ;
80842: LD_ADDR_VAR 0 15
80846: PUSH
80847: LD_VAR 0 3
80851: PPUSH
80852: LD_VAR 0 4
80856: PPUSH
80857: CALL_OW 546
80861: ST_TO_ADDR
// if hex [ 1 ] then
80862: LD_VAR 0 15
80866: PUSH
80867: LD_INT 1
80869: ARRAY
80870: IFFALSE 80874
// exit ;
80872: GO 81315
// height := hex [ 2 ] ;
80874: LD_ADDR_VAR 0 13
80878: PUSH
80879: LD_VAR 0 15
80883: PUSH
80884: LD_INT 2
80886: ARRAY
80887: ST_TO_ADDR
// for i = 1 to hexes do
80888: LD_ADDR_VAR 0 7
80892: PUSH
80893: DOUBLE
80894: LD_INT 1
80896: DEC
80897: ST_TO_ADDR
80898: LD_VAR 0 12
80902: PUSH
80903: FOR_TO
80904: IFFALSE 81234
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
80906: LD_VAR 0 12
80910: PUSH
80911: LD_VAR 0 7
80915: ARRAY
80916: PUSH
80917: LD_INT 1
80919: ARRAY
80920: PPUSH
80921: LD_VAR 0 12
80925: PUSH
80926: LD_VAR 0 7
80930: ARRAY
80931: PUSH
80932: LD_INT 2
80934: ARRAY
80935: PPUSH
80936: CALL_OW 488
80940: NOT
80941: PUSH
80942: LD_VAR 0 12
80946: PUSH
80947: LD_VAR 0 7
80951: ARRAY
80952: PUSH
80953: LD_INT 1
80955: ARRAY
80956: PPUSH
80957: LD_VAR 0 12
80961: PUSH
80962: LD_VAR 0 7
80966: ARRAY
80967: PUSH
80968: LD_INT 2
80970: ARRAY
80971: PPUSH
80972: CALL_OW 428
80976: PUSH
80977: LD_INT 0
80979: GREATER
80980: OR
80981: PUSH
80982: LD_VAR 0 12
80986: PUSH
80987: LD_VAR 0 7
80991: ARRAY
80992: PUSH
80993: LD_INT 1
80995: ARRAY
80996: PPUSH
80997: LD_VAR 0 12
81001: PUSH
81002: LD_VAR 0 7
81006: ARRAY
81007: PUSH
81008: LD_INT 2
81010: ARRAY
81011: PPUSH
81012: CALL_OW 351
81016: OR
81017: IFFALSE 81023
// exit ;
81019: POP
81020: POP
81021: GO 81315
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81023: LD_ADDR_VAR 0 8
81027: PUSH
81028: LD_VAR 0 12
81032: PUSH
81033: LD_VAR 0 7
81037: ARRAY
81038: PUSH
81039: LD_INT 1
81041: ARRAY
81042: PPUSH
81043: LD_VAR 0 12
81047: PUSH
81048: LD_VAR 0 7
81052: ARRAY
81053: PUSH
81054: LD_INT 2
81056: ARRAY
81057: PPUSH
81058: CALL_OW 546
81062: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
81063: LD_VAR 0 8
81067: PUSH
81068: LD_INT 1
81070: ARRAY
81071: PUSH
81072: LD_VAR 0 8
81076: PUSH
81077: LD_INT 2
81079: ARRAY
81080: PUSH
81081: LD_VAR 0 13
81085: PUSH
81086: LD_INT 2
81088: PLUS
81089: GREATER
81090: OR
81091: PUSH
81092: LD_VAR 0 8
81096: PUSH
81097: LD_INT 2
81099: ARRAY
81100: PUSH
81101: LD_VAR 0 13
81105: PUSH
81106: LD_INT 2
81108: MINUS
81109: LESS
81110: OR
81111: PUSH
81112: LD_VAR 0 8
81116: PUSH
81117: LD_INT 3
81119: ARRAY
81120: PUSH
81121: LD_INT 0
81123: PUSH
81124: LD_INT 8
81126: PUSH
81127: LD_INT 9
81129: PUSH
81130: LD_INT 10
81132: PUSH
81133: LD_INT 11
81135: PUSH
81136: LD_INT 12
81138: PUSH
81139: LD_INT 13
81141: PUSH
81142: LD_INT 16
81144: PUSH
81145: LD_INT 17
81147: PUSH
81148: LD_INT 18
81150: PUSH
81151: LD_INT 19
81153: PUSH
81154: LD_INT 20
81156: PUSH
81157: LD_INT 21
81159: PUSH
81160: EMPTY
81161: LIST
81162: LIST
81163: LIST
81164: LIST
81165: LIST
81166: LIST
81167: LIST
81168: LIST
81169: LIST
81170: LIST
81171: LIST
81172: LIST
81173: LIST
81174: IN
81175: NOT
81176: OR
81177: PUSH
81178: LD_VAR 0 8
81182: PUSH
81183: LD_INT 5
81185: ARRAY
81186: NOT
81187: OR
81188: PUSH
81189: LD_VAR 0 8
81193: PUSH
81194: LD_INT 6
81196: ARRAY
81197: PUSH
81198: LD_INT 1
81200: PUSH
81201: LD_INT 2
81203: PUSH
81204: LD_INT 7
81206: PUSH
81207: LD_INT 9
81209: PUSH
81210: LD_INT 10
81212: PUSH
81213: LD_INT 11
81215: PUSH
81216: EMPTY
81217: LIST
81218: LIST
81219: LIST
81220: LIST
81221: LIST
81222: LIST
81223: IN
81224: NOT
81225: OR
81226: IFFALSE 81232
// exit ;
81228: POP
81229: POP
81230: GO 81315
// end ;
81232: GO 80903
81234: POP
81235: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
81236: LD_VAR 0 9
81240: PPUSH
81241: LD_VAR 0 3
81245: PPUSH
81246: LD_VAR 0 4
81250: PPUSH
81251: LD_INT 20
81253: PPUSH
81254: CALL 73267 0 4
81258: PUSH
81259: LD_INT 4
81261: ARRAY
81262: IFFALSE 81266
// exit ;
81264: GO 81315
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
81266: LD_VAR 0 2
81270: PUSH
81271: LD_INT 29
81273: PUSH
81274: LD_INT 30
81276: PUSH
81277: EMPTY
81278: LIST
81279: LIST
81280: IN
81281: PUSH
81282: LD_VAR 0 3
81286: PPUSH
81287: LD_VAR 0 4
81291: PPUSH
81292: LD_VAR 0 9
81296: PPUSH
81297: CALL_OW 440
81301: NOT
81302: AND
81303: IFFALSE 81307
// exit ;
81305: GO 81315
// result := true ;
81307: LD_ADDR_VAR 0 6
81311: PUSH
81312: LD_INT 1
81314: ST_TO_ADDR
// end ;
81315: LD_VAR 0 6
81319: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
81320: LD_INT 0
81322: PPUSH
81323: PPUSH
81324: PPUSH
81325: PPUSH
81326: PPUSH
81327: PPUSH
81328: PPUSH
81329: PPUSH
81330: PPUSH
81331: PPUSH
81332: PPUSH
81333: PPUSH
81334: PPUSH
81335: PPUSH
81336: PPUSH
81337: PPUSH
81338: PPUSH
81339: PPUSH
81340: PPUSH
81341: PPUSH
81342: PPUSH
81343: PPUSH
81344: PPUSH
81345: PPUSH
81346: PPUSH
81347: PPUSH
81348: PPUSH
81349: PPUSH
81350: PPUSH
81351: PPUSH
81352: PPUSH
81353: PPUSH
81354: PPUSH
81355: PPUSH
81356: PPUSH
81357: PPUSH
81358: PPUSH
81359: PPUSH
81360: PPUSH
81361: PPUSH
81362: PPUSH
81363: PPUSH
81364: PPUSH
81365: PPUSH
81366: PPUSH
81367: PPUSH
81368: PPUSH
81369: PPUSH
81370: PPUSH
81371: PPUSH
81372: PPUSH
81373: PPUSH
81374: PPUSH
81375: PPUSH
81376: PPUSH
81377: PPUSH
81378: PPUSH
81379: PPUSH
// result = [ ] ;
81380: LD_ADDR_VAR 0 7
81384: PUSH
81385: EMPTY
81386: ST_TO_ADDR
// temp_list = [ ] ;
81387: LD_ADDR_VAR 0 9
81391: PUSH
81392: EMPTY
81393: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
81394: LD_VAR 0 4
81398: PUSH
81399: LD_INT 0
81401: PUSH
81402: LD_INT 1
81404: PUSH
81405: LD_INT 2
81407: PUSH
81408: LD_INT 3
81410: PUSH
81411: LD_INT 4
81413: PUSH
81414: LD_INT 5
81416: PUSH
81417: EMPTY
81418: LIST
81419: LIST
81420: LIST
81421: LIST
81422: LIST
81423: LIST
81424: IN
81425: NOT
81426: PUSH
81427: LD_VAR 0 1
81431: PUSH
81432: LD_INT 0
81434: PUSH
81435: LD_INT 1
81437: PUSH
81438: EMPTY
81439: LIST
81440: LIST
81441: IN
81442: PUSH
81443: LD_VAR 0 5
81447: PUSH
81448: LD_INT 1
81450: PUSH
81451: LD_INT 2
81453: PUSH
81454: LD_INT 3
81456: PUSH
81457: EMPTY
81458: LIST
81459: LIST
81460: LIST
81461: IN
81462: NOT
81463: AND
81464: OR
81465: IFFALSE 81469
// exit ;
81467: GO 99860
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
81469: LD_VAR 0 1
81473: PUSH
81474: LD_INT 6
81476: PUSH
81477: LD_INT 7
81479: PUSH
81480: LD_INT 8
81482: PUSH
81483: LD_INT 13
81485: PUSH
81486: LD_INT 12
81488: PUSH
81489: LD_INT 15
81491: PUSH
81492: LD_INT 11
81494: PUSH
81495: LD_INT 14
81497: PUSH
81498: LD_INT 10
81500: PUSH
81501: EMPTY
81502: LIST
81503: LIST
81504: LIST
81505: LIST
81506: LIST
81507: LIST
81508: LIST
81509: LIST
81510: LIST
81511: IN
81512: IFFALSE 81522
// btype = b_lab ;
81514: LD_ADDR_VAR 0 1
81518: PUSH
81519: LD_INT 6
81521: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
81522: LD_VAR 0 6
81526: PUSH
81527: LD_INT 0
81529: PUSH
81530: LD_INT 1
81532: PUSH
81533: LD_INT 2
81535: PUSH
81536: EMPTY
81537: LIST
81538: LIST
81539: LIST
81540: IN
81541: NOT
81542: PUSH
81543: LD_VAR 0 1
81547: PUSH
81548: LD_INT 0
81550: PUSH
81551: LD_INT 1
81553: PUSH
81554: LD_INT 2
81556: PUSH
81557: LD_INT 3
81559: PUSH
81560: LD_INT 6
81562: PUSH
81563: LD_INT 36
81565: PUSH
81566: LD_INT 4
81568: PUSH
81569: LD_INT 5
81571: PUSH
81572: LD_INT 31
81574: PUSH
81575: LD_INT 32
81577: PUSH
81578: LD_INT 33
81580: PUSH
81581: EMPTY
81582: LIST
81583: LIST
81584: LIST
81585: LIST
81586: LIST
81587: LIST
81588: LIST
81589: LIST
81590: LIST
81591: LIST
81592: LIST
81593: IN
81594: NOT
81595: PUSH
81596: LD_VAR 0 6
81600: PUSH
81601: LD_INT 1
81603: EQUAL
81604: AND
81605: OR
81606: PUSH
81607: LD_VAR 0 1
81611: PUSH
81612: LD_INT 2
81614: PUSH
81615: LD_INT 3
81617: PUSH
81618: EMPTY
81619: LIST
81620: LIST
81621: IN
81622: NOT
81623: PUSH
81624: LD_VAR 0 6
81628: PUSH
81629: LD_INT 2
81631: EQUAL
81632: AND
81633: OR
81634: IFFALSE 81644
// mode = 0 ;
81636: LD_ADDR_VAR 0 6
81640: PUSH
81641: LD_INT 0
81643: ST_TO_ADDR
// case mode of 0 :
81644: LD_VAR 0 6
81648: PUSH
81649: LD_INT 0
81651: DOUBLE
81652: EQUAL
81653: IFTRUE 81657
81655: GO 93110
81657: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
81658: LD_ADDR_VAR 0 11
81662: PUSH
81663: LD_INT 0
81665: PUSH
81666: LD_INT 0
81668: PUSH
81669: EMPTY
81670: LIST
81671: LIST
81672: PUSH
81673: LD_INT 0
81675: PUSH
81676: LD_INT 1
81678: NEG
81679: PUSH
81680: EMPTY
81681: LIST
81682: LIST
81683: PUSH
81684: LD_INT 1
81686: PUSH
81687: LD_INT 0
81689: PUSH
81690: EMPTY
81691: LIST
81692: LIST
81693: PUSH
81694: LD_INT 1
81696: PUSH
81697: LD_INT 1
81699: PUSH
81700: EMPTY
81701: LIST
81702: LIST
81703: PUSH
81704: LD_INT 0
81706: PUSH
81707: LD_INT 1
81709: PUSH
81710: EMPTY
81711: LIST
81712: LIST
81713: PUSH
81714: LD_INT 1
81716: NEG
81717: PUSH
81718: LD_INT 0
81720: PUSH
81721: EMPTY
81722: LIST
81723: LIST
81724: PUSH
81725: LD_INT 1
81727: NEG
81728: PUSH
81729: LD_INT 1
81731: NEG
81732: PUSH
81733: EMPTY
81734: LIST
81735: LIST
81736: PUSH
81737: LD_INT 1
81739: NEG
81740: PUSH
81741: LD_INT 2
81743: NEG
81744: PUSH
81745: EMPTY
81746: LIST
81747: LIST
81748: PUSH
81749: LD_INT 0
81751: PUSH
81752: LD_INT 2
81754: NEG
81755: PUSH
81756: EMPTY
81757: LIST
81758: LIST
81759: PUSH
81760: LD_INT 1
81762: PUSH
81763: LD_INT 1
81765: NEG
81766: PUSH
81767: EMPTY
81768: LIST
81769: LIST
81770: PUSH
81771: LD_INT 1
81773: PUSH
81774: LD_INT 2
81776: PUSH
81777: EMPTY
81778: LIST
81779: LIST
81780: PUSH
81781: LD_INT 0
81783: PUSH
81784: LD_INT 2
81786: PUSH
81787: EMPTY
81788: LIST
81789: LIST
81790: PUSH
81791: LD_INT 1
81793: NEG
81794: PUSH
81795: LD_INT 1
81797: PUSH
81798: EMPTY
81799: LIST
81800: LIST
81801: PUSH
81802: LD_INT 1
81804: PUSH
81805: LD_INT 3
81807: PUSH
81808: EMPTY
81809: LIST
81810: LIST
81811: PUSH
81812: LD_INT 0
81814: PUSH
81815: LD_INT 3
81817: PUSH
81818: EMPTY
81819: LIST
81820: LIST
81821: PUSH
81822: LD_INT 1
81824: NEG
81825: PUSH
81826: LD_INT 2
81828: PUSH
81829: EMPTY
81830: LIST
81831: LIST
81832: PUSH
81833: EMPTY
81834: LIST
81835: LIST
81836: LIST
81837: LIST
81838: LIST
81839: LIST
81840: LIST
81841: LIST
81842: LIST
81843: LIST
81844: LIST
81845: LIST
81846: LIST
81847: LIST
81848: LIST
81849: LIST
81850: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
81851: LD_ADDR_VAR 0 12
81855: PUSH
81856: LD_INT 0
81858: PUSH
81859: LD_INT 0
81861: PUSH
81862: EMPTY
81863: LIST
81864: LIST
81865: PUSH
81866: LD_INT 0
81868: PUSH
81869: LD_INT 1
81871: NEG
81872: PUSH
81873: EMPTY
81874: LIST
81875: LIST
81876: PUSH
81877: LD_INT 1
81879: PUSH
81880: LD_INT 0
81882: PUSH
81883: EMPTY
81884: LIST
81885: LIST
81886: PUSH
81887: LD_INT 1
81889: PUSH
81890: LD_INT 1
81892: PUSH
81893: EMPTY
81894: LIST
81895: LIST
81896: PUSH
81897: LD_INT 0
81899: PUSH
81900: LD_INT 1
81902: PUSH
81903: EMPTY
81904: LIST
81905: LIST
81906: PUSH
81907: LD_INT 1
81909: NEG
81910: PUSH
81911: LD_INT 0
81913: PUSH
81914: EMPTY
81915: LIST
81916: LIST
81917: PUSH
81918: LD_INT 1
81920: NEG
81921: PUSH
81922: LD_INT 1
81924: NEG
81925: PUSH
81926: EMPTY
81927: LIST
81928: LIST
81929: PUSH
81930: LD_INT 1
81932: PUSH
81933: LD_INT 1
81935: NEG
81936: PUSH
81937: EMPTY
81938: LIST
81939: LIST
81940: PUSH
81941: LD_INT 2
81943: PUSH
81944: LD_INT 0
81946: PUSH
81947: EMPTY
81948: LIST
81949: LIST
81950: PUSH
81951: LD_INT 2
81953: PUSH
81954: LD_INT 1
81956: PUSH
81957: EMPTY
81958: LIST
81959: LIST
81960: PUSH
81961: LD_INT 1
81963: NEG
81964: PUSH
81965: LD_INT 1
81967: PUSH
81968: EMPTY
81969: LIST
81970: LIST
81971: PUSH
81972: LD_INT 2
81974: NEG
81975: PUSH
81976: LD_INT 0
81978: PUSH
81979: EMPTY
81980: LIST
81981: LIST
81982: PUSH
81983: LD_INT 2
81985: NEG
81986: PUSH
81987: LD_INT 1
81989: NEG
81990: PUSH
81991: EMPTY
81992: LIST
81993: LIST
81994: PUSH
81995: LD_INT 2
81997: NEG
81998: PUSH
81999: LD_INT 1
82001: PUSH
82002: EMPTY
82003: LIST
82004: LIST
82005: PUSH
82006: LD_INT 3
82008: NEG
82009: PUSH
82010: LD_INT 0
82012: PUSH
82013: EMPTY
82014: LIST
82015: LIST
82016: PUSH
82017: LD_INT 3
82019: NEG
82020: PUSH
82021: LD_INT 1
82023: NEG
82024: PUSH
82025: EMPTY
82026: LIST
82027: LIST
82028: PUSH
82029: EMPTY
82030: LIST
82031: LIST
82032: LIST
82033: LIST
82034: LIST
82035: LIST
82036: LIST
82037: LIST
82038: LIST
82039: LIST
82040: LIST
82041: LIST
82042: LIST
82043: LIST
82044: LIST
82045: LIST
82046: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82047: LD_ADDR_VAR 0 13
82051: PUSH
82052: LD_INT 0
82054: PUSH
82055: LD_INT 0
82057: PUSH
82058: EMPTY
82059: LIST
82060: LIST
82061: PUSH
82062: LD_INT 0
82064: PUSH
82065: LD_INT 1
82067: NEG
82068: PUSH
82069: EMPTY
82070: LIST
82071: LIST
82072: PUSH
82073: LD_INT 1
82075: PUSH
82076: LD_INT 0
82078: PUSH
82079: EMPTY
82080: LIST
82081: LIST
82082: PUSH
82083: LD_INT 1
82085: PUSH
82086: LD_INT 1
82088: PUSH
82089: EMPTY
82090: LIST
82091: LIST
82092: PUSH
82093: LD_INT 0
82095: PUSH
82096: LD_INT 1
82098: PUSH
82099: EMPTY
82100: LIST
82101: LIST
82102: PUSH
82103: LD_INT 1
82105: NEG
82106: PUSH
82107: LD_INT 0
82109: PUSH
82110: EMPTY
82111: LIST
82112: LIST
82113: PUSH
82114: LD_INT 1
82116: NEG
82117: PUSH
82118: LD_INT 1
82120: NEG
82121: PUSH
82122: EMPTY
82123: LIST
82124: LIST
82125: PUSH
82126: LD_INT 1
82128: NEG
82129: PUSH
82130: LD_INT 2
82132: NEG
82133: PUSH
82134: EMPTY
82135: LIST
82136: LIST
82137: PUSH
82138: LD_INT 2
82140: PUSH
82141: LD_INT 1
82143: PUSH
82144: EMPTY
82145: LIST
82146: LIST
82147: PUSH
82148: LD_INT 2
82150: PUSH
82151: LD_INT 2
82153: PUSH
82154: EMPTY
82155: LIST
82156: LIST
82157: PUSH
82158: LD_INT 1
82160: PUSH
82161: LD_INT 2
82163: PUSH
82164: EMPTY
82165: LIST
82166: LIST
82167: PUSH
82168: LD_INT 2
82170: NEG
82171: PUSH
82172: LD_INT 1
82174: NEG
82175: PUSH
82176: EMPTY
82177: LIST
82178: LIST
82179: PUSH
82180: LD_INT 2
82182: NEG
82183: PUSH
82184: LD_INT 2
82186: NEG
82187: PUSH
82188: EMPTY
82189: LIST
82190: LIST
82191: PUSH
82192: LD_INT 2
82194: NEG
82195: PUSH
82196: LD_INT 3
82198: NEG
82199: PUSH
82200: EMPTY
82201: LIST
82202: LIST
82203: PUSH
82204: LD_INT 3
82206: NEG
82207: PUSH
82208: LD_INT 2
82210: NEG
82211: PUSH
82212: EMPTY
82213: LIST
82214: LIST
82215: PUSH
82216: LD_INT 3
82218: NEG
82219: PUSH
82220: LD_INT 3
82222: NEG
82223: PUSH
82224: EMPTY
82225: LIST
82226: LIST
82227: PUSH
82228: EMPTY
82229: LIST
82230: LIST
82231: LIST
82232: LIST
82233: LIST
82234: LIST
82235: LIST
82236: LIST
82237: LIST
82238: LIST
82239: LIST
82240: LIST
82241: LIST
82242: LIST
82243: LIST
82244: LIST
82245: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
82246: LD_ADDR_VAR 0 14
82250: PUSH
82251: LD_INT 0
82253: PUSH
82254: LD_INT 0
82256: PUSH
82257: EMPTY
82258: LIST
82259: LIST
82260: PUSH
82261: LD_INT 0
82263: PUSH
82264: LD_INT 1
82266: NEG
82267: PUSH
82268: EMPTY
82269: LIST
82270: LIST
82271: PUSH
82272: LD_INT 1
82274: PUSH
82275: LD_INT 0
82277: PUSH
82278: EMPTY
82279: LIST
82280: LIST
82281: PUSH
82282: LD_INT 1
82284: PUSH
82285: LD_INT 1
82287: PUSH
82288: EMPTY
82289: LIST
82290: LIST
82291: PUSH
82292: LD_INT 0
82294: PUSH
82295: LD_INT 1
82297: PUSH
82298: EMPTY
82299: LIST
82300: LIST
82301: PUSH
82302: LD_INT 1
82304: NEG
82305: PUSH
82306: LD_INT 0
82308: PUSH
82309: EMPTY
82310: LIST
82311: LIST
82312: PUSH
82313: LD_INT 1
82315: NEG
82316: PUSH
82317: LD_INT 1
82319: NEG
82320: PUSH
82321: EMPTY
82322: LIST
82323: LIST
82324: PUSH
82325: LD_INT 1
82327: NEG
82328: PUSH
82329: LD_INT 2
82331: NEG
82332: PUSH
82333: EMPTY
82334: LIST
82335: LIST
82336: PUSH
82337: LD_INT 0
82339: PUSH
82340: LD_INT 2
82342: NEG
82343: PUSH
82344: EMPTY
82345: LIST
82346: LIST
82347: PUSH
82348: LD_INT 1
82350: PUSH
82351: LD_INT 1
82353: NEG
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: PUSH
82359: LD_INT 1
82361: PUSH
82362: LD_INT 2
82364: PUSH
82365: EMPTY
82366: LIST
82367: LIST
82368: PUSH
82369: LD_INT 0
82371: PUSH
82372: LD_INT 2
82374: PUSH
82375: EMPTY
82376: LIST
82377: LIST
82378: PUSH
82379: LD_INT 1
82381: NEG
82382: PUSH
82383: LD_INT 1
82385: PUSH
82386: EMPTY
82387: LIST
82388: LIST
82389: PUSH
82390: LD_INT 1
82392: NEG
82393: PUSH
82394: LD_INT 3
82396: NEG
82397: PUSH
82398: EMPTY
82399: LIST
82400: LIST
82401: PUSH
82402: LD_INT 0
82404: PUSH
82405: LD_INT 3
82407: NEG
82408: PUSH
82409: EMPTY
82410: LIST
82411: LIST
82412: PUSH
82413: LD_INT 1
82415: PUSH
82416: LD_INT 2
82418: NEG
82419: PUSH
82420: EMPTY
82421: LIST
82422: LIST
82423: PUSH
82424: EMPTY
82425: LIST
82426: LIST
82427: LIST
82428: LIST
82429: LIST
82430: LIST
82431: LIST
82432: LIST
82433: LIST
82434: LIST
82435: LIST
82436: LIST
82437: LIST
82438: LIST
82439: LIST
82440: LIST
82441: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
82442: LD_ADDR_VAR 0 15
82446: PUSH
82447: LD_INT 0
82449: PUSH
82450: LD_INT 0
82452: PUSH
82453: EMPTY
82454: LIST
82455: LIST
82456: PUSH
82457: LD_INT 0
82459: PUSH
82460: LD_INT 1
82462: NEG
82463: PUSH
82464: EMPTY
82465: LIST
82466: LIST
82467: PUSH
82468: LD_INT 1
82470: PUSH
82471: LD_INT 0
82473: PUSH
82474: EMPTY
82475: LIST
82476: LIST
82477: PUSH
82478: LD_INT 1
82480: PUSH
82481: LD_INT 1
82483: PUSH
82484: EMPTY
82485: LIST
82486: LIST
82487: PUSH
82488: LD_INT 0
82490: PUSH
82491: LD_INT 1
82493: PUSH
82494: EMPTY
82495: LIST
82496: LIST
82497: PUSH
82498: LD_INT 1
82500: NEG
82501: PUSH
82502: LD_INT 0
82504: PUSH
82505: EMPTY
82506: LIST
82507: LIST
82508: PUSH
82509: LD_INT 1
82511: NEG
82512: PUSH
82513: LD_INT 1
82515: NEG
82516: PUSH
82517: EMPTY
82518: LIST
82519: LIST
82520: PUSH
82521: LD_INT 1
82523: PUSH
82524: LD_INT 1
82526: NEG
82527: PUSH
82528: EMPTY
82529: LIST
82530: LIST
82531: PUSH
82532: LD_INT 2
82534: PUSH
82535: LD_INT 0
82537: PUSH
82538: EMPTY
82539: LIST
82540: LIST
82541: PUSH
82542: LD_INT 2
82544: PUSH
82545: LD_INT 1
82547: PUSH
82548: EMPTY
82549: LIST
82550: LIST
82551: PUSH
82552: LD_INT 1
82554: NEG
82555: PUSH
82556: LD_INT 1
82558: PUSH
82559: EMPTY
82560: LIST
82561: LIST
82562: PUSH
82563: LD_INT 2
82565: NEG
82566: PUSH
82567: LD_INT 0
82569: PUSH
82570: EMPTY
82571: LIST
82572: LIST
82573: PUSH
82574: LD_INT 2
82576: NEG
82577: PUSH
82578: LD_INT 1
82580: NEG
82581: PUSH
82582: EMPTY
82583: LIST
82584: LIST
82585: PUSH
82586: LD_INT 2
82588: PUSH
82589: LD_INT 1
82591: NEG
82592: PUSH
82593: EMPTY
82594: LIST
82595: LIST
82596: PUSH
82597: LD_INT 3
82599: PUSH
82600: LD_INT 0
82602: PUSH
82603: EMPTY
82604: LIST
82605: LIST
82606: PUSH
82607: LD_INT 3
82609: PUSH
82610: LD_INT 1
82612: PUSH
82613: EMPTY
82614: LIST
82615: LIST
82616: PUSH
82617: EMPTY
82618: LIST
82619: LIST
82620: LIST
82621: LIST
82622: LIST
82623: LIST
82624: LIST
82625: LIST
82626: LIST
82627: LIST
82628: LIST
82629: LIST
82630: LIST
82631: LIST
82632: LIST
82633: LIST
82634: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
82635: LD_ADDR_VAR 0 16
82639: PUSH
82640: LD_INT 0
82642: PUSH
82643: LD_INT 0
82645: PUSH
82646: EMPTY
82647: LIST
82648: LIST
82649: PUSH
82650: LD_INT 0
82652: PUSH
82653: LD_INT 1
82655: NEG
82656: PUSH
82657: EMPTY
82658: LIST
82659: LIST
82660: PUSH
82661: LD_INT 1
82663: PUSH
82664: LD_INT 0
82666: PUSH
82667: EMPTY
82668: LIST
82669: LIST
82670: PUSH
82671: LD_INT 1
82673: PUSH
82674: LD_INT 1
82676: PUSH
82677: EMPTY
82678: LIST
82679: LIST
82680: PUSH
82681: LD_INT 0
82683: PUSH
82684: LD_INT 1
82686: PUSH
82687: EMPTY
82688: LIST
82689: LIST
82690: PUSH
82691: LD_INT 1
82693: NEG
82694: PUSH
82695: LD_INT 0
82697: PUSH
82698: EMPTY
82699: LIST
82700: LIST
82701: PUSH
82702: LD_INT 1
82704: NEG
82705: PUSH
82706: LD_INT 1
82708: NEG
82709: PUSH
82710: EMPTY
82711: LIST
82712: LIST
82713: PUSH
82714: LD_INT 1
82716: NEG
82717: PUSH
82718: LD_INT 2
82720: NEG
82721: PUSH
82722: EMPTY
82723: LIST
82724: LIST
82725: PUSH
82726: LD_INT 2
82728: PUSH
82729: LD_INT 1
82731: PUSH
82732: EMPTY
82733: LIST
82734: LIST
82735: PUSH
82736: LD_INT 2
82738: PUSH
82739: LD_INT 2
82741: PUSH
82742: EMPTY
82743: LIST
82744: LIST
82745: PUSH
82746: LD_INT 1
82748: PUSH
82749: LD_INT 2
82751: PUSH
82752: EMPTY
82753: LIST
82754: LIST
82755: PUSH
82756: LD_INT 2
82758: NEG
82759: PUSH
82760: LD_INT 1
82762: NEG
82763: PUSH
82764: EMPTY
82765: LIST
82766: LIST
82767: PUSH
82768: LD_INT 2
82770: NEG
82771: PUSH
82772: LD_INT 2
82774: NEG
82775: PUSH
82776: EMPTY
82777: LIST
82778: LIST
82779: PUSH
82780: LD_INT 3
82782: PUSH
82783: LD_INT 2
82785: PUSH
82786: EMPTY
82787: LIST
82788: LIST
82789: PUSH
82790: LD_INT 3
82792: PUSH
82793: LD_INT 3
82795: PUSH
82796: EMPTY
82797: LIST
82798: LIST
82799: PUSH
82800: LD_INT 2
82802: PUSH
82803: LD_INT 3
82805: PUSH
82806: EMPTY
82807: LIST
82808: LIST
82809: PUSH
82810: EMPTY
82811: LIST
82812: LIST
82813: LIST
82814: LIST
82815: LIST
82816: LIST
82817: LIST
82818: LIST
82819: LIST
82820: LIST
82821: LIST
82822: LIST
82823: LIST
82824: LIST
82825: LIST
82826: LIST
82827: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82828: LD_ADDR_VAR 0 17
82832: PUSH
82833: LD_INT 0
82835: PUSH
82836: LD_INT 0
82838: PUSH
82839: EMPTY
82840: LIST
82841: LIST
82842: PUSH
82843: LD_INT 0
82845: PUSH
82846: LD_INT 1
82848: NEG
82849: PUSH
82850: EMPTY
82851: LIST
82852: LIST
82853: PUSH
82854: LD_INT 1
82856: PUSH
82857: LD_INT 0
82859: PUSH
82860: EMPTY
82861: LIST
82862: LIST
82863: PUSH
82864: LD_INT 1
82866: PUSH
82867: LD_INT 1
82869: PUSH
82870: EMPTY
82871: LIST
82872: LIST
82873: PUSH
82874: LD_INT 0
82876: PUSH
82877: LD_INT 1
82879: PUSH
82880: EMPTY
82881: LIST
82882: LIST
82883: PUSH
82884: LD_INT 1
82886: NEG
82887: PUSH
82888: LD_INT 0
82890: PUSH
82891: EMPTY
82892: LIST
82893: LIST
82894: PUSH
82895: LD_INT 1
82897: NEG
82898: PUSH
82899: LD_INT 1
82901: NEG
82902: PUSH
82903: EMPTY
82904: LIST
82905: LIST
82906: PUSH
82907: LD_INT 1
82909: NEG
82910: PUSH
82911: LD_INT 2
82913: NEG
82914: PUSH
82915: EMPTY
82916: LIST
82917: LIST
82918: PUSH
82919: LD_INT 0
82921: PUSH
82922: LD_INT 2
82924: NEG
82925: PUSH
82926: EMPTY
82927: LIST
82928: LIST
82929: PUSH
82930: LD_INT 1
82932: PUSH
82933: LD_INT 1
82935: NEG
82936: PUSH
82937: EMPTY
82938: LIST
82939: LIST
82940: PUSH
82941: LD_INT 2
82943: PUSH
82944: LD_INT 0
82946: PUSH
82947: EMPTY
82948: LIST
82949: LIST
82950: PUSH
82951: LD_INT 2
82953: PUSH
82954: LD_INT 1
82956: PUSH
82957: EMPTY
82958: LIST
82959: LIST
82960: PUSH
82961: LD_INT 2
82963: PUSH
82964: LD_INT 2
82966: PUSH
82967: EMPTY
82968: LIST
82969: LIST
82970: PUSH
82971: LD_INT 1
82973: PUSH
82974: LD_INT 2
82976: PUSH
82977: EMPTY
82978: LIST
82979: LIST
82980: PUSH
82981: LD_INT 0
82983: PUSH
82984: LD_INT 2
82986: PUSH
82987: EMPTY
82988: LIST
82989: LIST
82990: PUSH
82991: LD_INT 1
82993: NEG
82994: PUSH
82995: LD_INT 1
82997: PUSH
82998: EMPTY
82999: LIST
83000: LIST
83001: PUSH
83002: LD_INT 2
83004: NEG
83005: PUSH
83006: LD_INT 0
83008: PUSH
83009: EMPTY
83010: LIST
83011: LIST
83012: PUSH
83013: LD_INT 2
83015: NEG
83016: PUSH
83017: LD_INT 1
83019: NEG
83020: PUSH
83021: EMPTY
83022: LIST
83023: LIST
83024: PUSH
83025: LD_INT 2
83027: NEG
83028: PUSH
83029: LD_INT 2
83031: NEG
83032: PUSH
83033: EMPTY
83034: LIST
83035: LIST
83036: PUSH
83037: EMPTY
83038: LIST
83039: LIST
83040: LIST
83041: LIST
83042: LIST
83043: LIST
83044: LIST
83045: LIST
83046: LIST
83047: LIST
83048: LIST
83049: LIST
83050: LIST
83051: LIST
83052: LIST
83053: LIST
83054: LIST
83055: LIST
83056: LIST
83057: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83058: LD_ADDR_VAR 0 18
83062: PUSH
83063: LD_INT 0
83065: PUSH
83066: LD_INT 0
83068: PUSH
83069: EMPTY
83070: LIST
83071: LIST
83072: PUSH
83073: LD_INT 0
83075: PUSH
83076: LD_INT 1
83078: NEG
83079: PUSH
83080: EMPTY
83081: LIST
83082: LIST
83083: PUSH
83084: LD_INT 1
83086: PUSH
83087: LD_INT 0
83089: PUSH
83090: EMPTY
83091: LIST
83092: LIST
83093: PUSH
83094: LD_INT 1
83096: PUSH
83097: LD_INT 1
83099: PUSH
83100: EMPTY
83101: LIST
83102: LIST
83103: PUSH
83104: LD_INT 0
83106: PUSH
83107: LD_INT 1
83109: PUSH
83110: EMPTY
83111: LIST
83112: LIST
83113: PUSH
83114: LD_INT 1
83116: NEG
83117: PUSH
83118: LD_INT 0
83120: PUSH
83121: EMPTY
83122: LIST
83123: LIST
83124: PUSH
83125: LD_INT 1
83127: NEG
83128: PUSH
83129: LD_INT 1
83131: NEG
83132: PUSH
83133: EMPTY
83134: LIST
83135: LIST
83136: PUSH
83137: LD_INT 1
83139: NEG
83140: PUSH
83141: LD_INT 2
83143: NEG
83144: PUSH
83145: EMPTY
83146: LIST
83147: LIST
83148: PUSH
83149: LD_INT 0
83151: PUSH
83152: LD_INT 2
83154: NEG
83155: PUSH
83156: EMPTY
83157: LIST
83158: LIST
83159: PUSH
83160: LD_INT 1
83162: PUSH
83163: LD_INT 1
83165: NEG
83166: PUSH
83167: EMPTY
83168: LIST
83169: LIST
83170: PUSH
83171: LD_INT 2
83173: PUSH
83174: LD_INT 0
83176: PUSH
83177: EMPTY
83178: LIST
83179: LIST
83180: PUSH
83181: LD_INT 2
83183: PUSH
83184: LD_INT 1
83186: PUSH
83187: EMPTY
83188: LIST
83189: LIST
83190: PUSH
83191: LD_INT 2
83193: PUSH
83194: LD_INT 2
83196: PUSH
83197: EMPTY
83198: LIST
83199: LIST
83200: PUSH
83201: LD_INT 1
83203: PUSH
83204: LD_INT 2
83206: PUSH
83207: EMPTY
83208: LIST
83209: LIST
83210: PUSH
83211: LD_INT 0
83213: PUSH
83214: LD_INT 2
83216: PUSH
83217: EMPTY
83218: LIST
83219: LIST
83220: PUSH
83221: LD_INT 1
83223: NEG
83224: PUSH
83225: LD_INT 1
83227: PUSH
83228: EMPTY
83229: LIST
83230: LIST
83231: PUSH
83232: LD_INT 2
83234: NEG
83235: PUSH
83236: LD_INT 0
83238: PUSH
83239: EMPTY
83240: LIST
83241: LIST
83242: PUSH
83243: LD_INT 2
83245: NEG
83246: PUSH
83247: LD_INT 1
83249: NEG
83250: PUSH
83251: EMPTY
83252: LIST
83253: LIST
83254: PUSH
83255: LD_INT 2
83257: NEG
83258: PUSH
83259: LD_INT 2
83261: NEG
83262: PUSH
83263: EMPTY
83264: LIST
83265: LIST
83266: PUSH
83267: EMPTY
83268: LIST
83269: LIST
83270: LIST
83271: LIST
83272: LIST
83273: LIST
83274: LIST
83275: LIST
83276: LIST
83277: LIST
83278: LIST
83279: LIST
83280: LIST
83281: LIST
83282: LIST
83283: LIST
83284: LIST
83285: LIST
83286: LIST
83287: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83288: LD_ADDR_VAR 0 19
83292: PUSH
83293: LD_INT 0
83295: PUSH
83296: LD_INT 0
83298: PUSH
83299: EMPTY
83300: LIST
83301: LIST
83302: PUSH
83303: LD_INT 0
83305: PUSH
83306: LD_INT 1
83308: NEG
83309: PUSH
83310: EMPTY
83311: LIST
83312: LIST
83313: PUSH
83314: LD_INT 1
83316: PUSH
83317: LD_INT 0
83319: PUSH
83320: EMPTY
83321: LIST
83322: LIST
83323: PUSH
83324: LD_INT 1
83326: PUSH
83327: LD_INT 1
83329: PUSH
83330: EMPTY
83331: LIST
83332: LIST
83333: PUSH
83334: LD_INT 0
83336: PUSH
83337: LD_INT 1
83339: PUSH
83340: EMPTY
83341: LIST
83342: LIST
83343: PUSH
83344: LD_INT 1
83346: NEG
83347: PUSH
83348: LD_INT 0
83350: PUSH
83351: EMPTY
83352: LIST
83353: LIST
83354: PUSH
83355: LD_INT 1
83357: NEG
83358: PUSH
83359: LD_INT 1
83361: NEG
83362: PUSH
83363: EMPTY
83364: LIST
83365: LIST
83366: PUSH
83367: LD_INT 1
83369: NEG
83370: PUSH
83371: LD_INT 2
83373: NEG
83374: PUSH
83375: EMPTY
83376: LIST
83377: LIST
83378: PUSH
83379: LD_INT 0
83381: PUSH
83382: LD_INT 2
83384: NEG
83385: PUSH
83386: EMPTY
83387: LIST
83388: LIST
83389: PUSH
83390: LD_INT 1
83392: PUSH
83393: LD_INT 1
83395: NEG
83396: PUSH
83397: EMPTY
83398: LIST
83399: LIST
83400: PUSH
83401: LD_INT 2
83403: PUSH
83404: LD_INT 0
83406: PUSH
83407: EMPTY
83408: LIST
83409: LIST
83410: PUSH
83411: LD_INT 2
83413: PUSH
83414: LD_INT 1
83416: PUSH
83417: EMPTY
83418: LIST
83419: LIST
83420: PUSH
83421: LD_INT 2
83423: PUSH
83424: LD_INT 2
83426: PUSH
83427: EMPTY
83428: LIST
83429: LIST
83430: PUSH
83431: LD_INT 1
83433: PUSH
83434: LD_INT 2
83436: PUSH
83437: EMPTY
83438: LIST
83439: LIST
83440: PUSH
83441: LD_INT 0
83443: PUSH
83444: LD_INT 2
83446: PUSH
83447: EMPTY
83448: LIST
83449: LIST
83450: PUSH
83451: LD_INT 1
83453: NEG
83454: PUSH
83455: LD_INT 1
83457: PUSH
83458: EMPTY
83459: LIST
83460: LIST
83461: PUSH
83462: LD_INT 2
83464: NEG
83465: PUSH
83466: LD_INT 0
83468: PUSH
83469: EMPTY
83470: LIST
83471: LIST
83472: PUSH
83473: LD_INT 2
83475: NEG
83476: PUSH
83477: LD_INT 1
83479: NEG
83480: PUSH
83481: EMPTY
83482: LIST
83483: LIST
83484: PUSH
83485: LD_INT 2
83487: NEG
83488: PUSH
83489: LD_INT 2
83491: NEG
83492: PUSH
83493: EMPTY
83494: LIST
83495: LIST
83496: PUSH
83497: EMPTY
83498: LIST
83499: LIST
83500: LIST
83501: LIST
83502: LIST
83503: LIST
83504: LIST
83505: LIST
83506: LIST
83507: LIST
83508: LIST
83509: LIST
83510: LIST
83511: LIST
83512: LIST
83513: LIST
83514: LIST
83515: LIST
83516: LIST
83517: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83518: LD_ADDR_VAR 0 20
83522: PUSH
83523: LD_INT 0
83525: PUSH
83526: LD_INT 0
83528: PUSH
83529: EMPTY
83530: LIST
83531: LIST
83532: PUSH
83533: LD_INT 0
83535: PUSH
83536: LD_INT 1
83538: NEG
83539: PUSH
83540: EMPTY
83541: LIST
83542: LIST
83543: PUSH
83544: LD_INT 1
83546: PUSH
83547: LD_INT 0
83549: PUSH
83550: EMPTY
83551: LIST
83552: LIST
83553: PUSH
83554: LD_INT 1
83556: PUSH
83557: LD_INT 1
83559: PUSH
83560: EMPTY
83561: LIST
83562: LIST
83563: PUSH
83564: LD_INT 0
83566: PUSH
83567: LD_INT 1
83569: PUSH
83570: EMPTY
83571: LIST
83572: LIST
83573: PUSH
83574: LD_INT 1
83576: NEG
83577: PUSH
83578: LD_INT 0
83580: PUSH
83581: EMPTY
83582: LIST
83583: LIST
83584: PUSH
83585: LD_INT 1
83587: NEG
83588: PUSH
83589: LD_INT 1
83591: NEG
83592: PUSH
83593: EMPTY
83594: LIST
83595: LIST
83596: PUSH
83597: LD_INT 1
83599: NEG
83600: PUSH
83601: LD_INT 2
83603: NEG
83604: PUSH
83605: EMPTY
83606: LIST
83607: LIST
83608: PUSH
83609: LD_INT 0
83611: PUSH
83612: LD_INT 2
83614: NEG
83615: PUSH
83616: EMPTY
83617: LIST
83618: LIST
83619: PUSH
83620: LD_INT 1
83622: PUSH
83623: LD_INT 1
83625: NEG
83626: PUSH
83627: EMPTY
83628: LIST
83629: LIST
83630: PUSH
83631: LD_INT 2
83633: PUSH
83634: LD_INT 0
83636: PUSH
83637: EMPTY
83638: LIST
83639: LIST
83640: PUSH
83641: LD_INT 2
83643: PUSH
83644: LD_INT 1
83646: PUSH
83647: EMPTY
83648: LIST
83649: LIST
83650: PUSH
83651: LD_INT 2
83653: PUSH
83654: LD_INT 2
83656: PUSH
83657: EMPTY
83658: LIST
83659: LIST
83660: PUSH
83661: LD_INT 1
83663: PUSH
83664: LD_INT 2
83666: PUSH
83667: EMPTY
83668: LIST
83669: LIST
83670: PUSH
83671: LD_INT 0
83673: PUSH
83674: LD_INT 2
83676: PUSH
83677: EMPTY
83678: LIST
83679: LIST
83680: PUSH
83681: LD_INT 1
83683: NEG
83684: PUSH
83685: LD_INT 1
83687: PUSH
83688: EMPTY
83689: LIST
83690: LIST
83691: PUSH
83692: LD_INT 2
83694: NEG
83695: PUSH
83696: LD_INT 0
83698: PUSH
83699: EMPTY
83700: LIST
83701: LIST
83702: PUSH
83703: LD_INT 2
83705: NEG
83706: PUSH
83707: LD_INT 1
83709: NEG
83710: PUSH
83711: EMPTY
83712: LIST
83713: LIST
83714: PUSH
83715: LD_INT 2
83717: NEG
83718: PUSH
83719: LD_INT 2
83721: NEG
83722: PUSH
83723: EMPTY
83724: LIST
83725: LIST
83726: PUSH
83727: EMPTY
83728: LIST
83729: LIST
83730: LIST
83731: LIST
83732: LIST
83733: LIST
83734: LIST
83735: LIST
83736: LIST
83737: LIST
83738: LIST
83739: LIST
83740: LIST
83741: LIST
83742: LIST
83743: LIST
83744: LIST
83745: LIST
83746: LIST
83747: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83748: LD_ADDR_VAR 0 21
83752: PUSH
83753: LD_INT 0
83755: PUSH
83756: LD_INT 0
83758: PUSH
83759: EMPTY
83760: LIST
83761: LIST
83762: PUSH
83763: LD_INT 0
83765: PUSH
83766: LD_INT 1
83768: NEG
83769: PUSH
83770: EMPTY
83771: LIST
83772: LIST
83773: PUSH
83774: LD_INT 1
83776: PUSH
83777: LD_INT 0
83779: PUSH
83780: EMPTY
83781: LIST
83782: LIST
83783: PUSH
83784: LD_INT 1
83786: PUSH
83787: LD_INT 1
83789: PUSH
83790: EMPTY
83791: LIST
83792: LIST
83793: PUSH
83794: LD_INT 0
83796: PUSH
83797: LD_INT 1
83799: PUSH
83800: EMPTY
83801: LIST
83802: LIST
83803: PUSH
83804: LD_INT 1
83806: NEG
83807: PUSH
83808: LD_INT 0
83810: PUSH
83811: EMPTY
83812: LIST
83813: LIST
83814: PUSH
83815: LD_INT 1
83817: NEG
83818: PUSH
83819: LD_INT 1
83821: NEG
83822: PUSH
83823: EMPTY
83824: LIST
83825: LIST
83826: PUSH
83827: LD_INT 1
83829: NEG
83830: PUSH
83831: LD_INT 2
83833: NEG
83834: PUSH
83835: EMPTY
83836: LIST
83837: LIST
83838: PUSH
83839: LD_INT 0
83841: PUSH
83842: LD_INT 2
83844: NEG
83845: PUSH
83846: EMPTY
83847: LIST
83848: LIST
83849: PUSH
83850: LD_INT 1
83852: PUSH
83853: LD_INT 1
83855: NEG
83856: PUSH
83857: EMPTY
83858: LIST
83859: LIST
83860: PUSH
83861: LD_INT 2
83863: PUSH
83864: LD_INT 0
83866: PUSH
83867: EMPTY
83868: LIST
83869: LIST
83870: PUSH
83871: LD_INT 2
83873: PUSH
83874: LD_INT 1
83876: PUSH
83877: EMPTY
83878: LIST
83879: LIST
83880: PUSH
83881: LD_INT 2
83883: PUSH
83884: LD_INT 2
83886: PUSH
83887: EMPTY
83888: LIST
83889: LIST
83890: PUSH
83891: LD_INT 1
83893: PUSH
83894: LD_INT 2
83896: PUSH
83897: EMPTY
83898: LIST
83899: LIST
83900: PUSH
83901: LD_INT 0
83903: PUSH
83904: LD_INT 2
83906: PUSH
83907: EMPTY
83908: LIST
83909: LIST
83910: PUSH
83911: LD_INT 1
83913: NEG
83914: PUSH
83915: LD_INT 1
83917: PUSH
83918: EMPTY
83919: LIST
83920: LIST
83921: PUSH
83922: LD_INT 2
83924: NEG
83925: PUSH
83926: LD_INT 0
83928: PUSH
83929: EMPTY
83930: LIST
83931: LIST
83932: PUSH
83933: LD_INT 2
83935: NEG
83936: PUSH
83937: LD_INT 1
83939: NEG
83940: PUSH
83941: EMPTY
83942: LIST
83943: LIST
83944: PUSH
83945: LD_INT 2
83947: NEG
83948: PUSH
83949: LD_INT 2
83951: NEG
83952: PUSH
83953: EMPTY
83954: LIST
83955: LIST
83956: PUSH
83957: EMPTY
83958: LIST
83959: LIST
83960: LIST
83961: LIST
83962: LIST
83963: LIST
83964: LIST
83965: LIST
83966: LIST
83967: LIST
83968: LIST
83969: LIST
83970: LIST
83971: LIST
83972: LIST
83973: LIST
83974: LIST
83975: LIST
83976: LIST
83977: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83978: LD_ADDR_VAR 0 22
83982: PUSH
83983: LD_INT 0
83985: PUSH
83986: LD_INT 0
83988: PUSH
83989: EMPTY
83990: LIST
83991: LIST
83992: PUSH
83993: LD_INT 0
83995: PUSH
83996: LD_INT 1
83998: NEG
83999: PUSH
84000: EMPTY
84001: LIST
84002: LIST
84003: PUSH
84004: LD_INT 1
84006: PUSH
84007: LD_INT 0
84009: PUSH
84010: EMPTY
84011: LIST
84012: LIST
84013: PUSH
84014: LD_INT 1
84016: PUSH
84017: LD_INT 1
84019: PUSH
84020: EMPTY
84021: LIST
84022: LIST
84023: PUSH
84024: LD_INT 0
84026: PUSH
84027: LD_INT 1
84029: PUSH
84030: EMPTY
84031: LIST
84032: LIST
84033: PUSH
84034: LD_INT 1
84036: NEG
84037: PUSH
84038: LD_INT 0
84040: PUSH
84041: EMPTY
84042: LIST
84043: LIST
84044: PUSH
84045: LD_INT 1
84047: NEG
84048: PUSH
84049: LD_INT 1
84051: NEG
84052: PUSH
84053: EMPTY
84054: LIST
84055: LIST
84056: PUSH
84057: LD_INT 1
84059: NEG
84060: PUSH
84061: LD_INT 2
84063: NEG
84064: PUSH
84065: EMPTY
84066: LIST
84067: LIST
84068: PUSH
84069: LD_INT 0
84071: PUSH
84072: LD_INT 2
84074: NEG
84075: PUSH
84076: EMPTY
84077: LIST
84078: LIST
84079: PUSH
84080: LD_INT 1
84082: PUSH
84083: LD_INT 1
84085: NEG
84086: PUSH
84087: EMPTY
84088: LIST
84089: LIST
84090: PUSH
84091: LD_INT 2
84093: PUSH
84094: LD_INT 0
84096: PUSH
84097: EMPTY
84098: LIST
84099: LIST
84100: PUSH
84101: LD_INT 2
84103: PUSH
84104: LD_INT 1
84106: PUSH
84107: EMPTY
84108: LIST
84109: LIST
84110: PUSH
84111: LD_INT 2
84113: PUSH
84114: LD_INT 2
84116: PUSH
84117: EMPTY
84118: LIST
84119: LIST
84120: PUSH
84121: LD_INT 1
84123: PUSH
84124: LD_INT 2
84126: PUSH
84127: EMPTY
84128: LIST
84129: LIST
84130: PUSH
84131: LD_INT 0
84133: PUSH
84134: LD_INT 2
84136: PUSH
84137: EMPTY
84138: LIST
84139: LIST
84140: PUSH
84141: LD_INT 1
84143: NEG
84144: PUSH
84145: LD_INT 1
84147: PUSH
84148: EMPTY
84149: LIST
84150: LIST
84151: PUSH
84152: LD_INT 2
84154: NEG
84155: PUSH
84156: LD_INT 0
84158: PUSH
84159: EMPTY
84160: LIST
84161: LIST
84162: PUSH
84163: LD_INT 2
84165: NEG
84166: PUSH
84167: LD_INT 1
84169: NEG
84170: PUSH
84171: EMPTY
84172: LIST
84173: LIST
84174: PUSH
84175: LD_INT 2
84177: NEG
84178: PUSH
84179: LD_INT 2
84181: NEG
84182: PUSH
84183: EMPTY
84184: LIST
84185: LIST
84186: PUSH
84187: EMPTY
84188: LIST
84189: LIST
84190: LIST
84191: LIST
84192: LIST
84193: LIST
84194: LIST
84195: LIST
84196: LIST
84197: LIST
84198: LIST
84199: LIST
84200: LIST
84201: LIST
84202: LIST
84203: LIST
84204: LIST
84205: LIST
84206: LIST
84207: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
84208: LD_ADDR_VAR 0 23
84212: PUSH
84213: LD_INT 0
84215: PUSH
84216: LD_INT 0
84218: PUSH
84219: EMPTY
84220: LIST
84221: LIST
84222: PUSH
84223: LD_INT 0
84225: PUSH
84226: LD_INT 1
84228: NEG
84229: PUSH
84230: EMPTY
84231: LIST
84232: LIST
84233: PUSH
84234: LD_INT 1
84236: PUSH
84237: LD_INT 0
84239: PUSH
84240: EMPTY
84241: LIST
84242: LIST
84243: PUSH
84244: LD_INT 1
84246: PUSH
84247: LD_INT 1
84249: PUSH
84250: EMPTY
84251: LIST
84252: LIST
84253: PUSH
84254: LD_INT 0
84256: PUSH
84257: LD_INT 1
84259: PUSH
84260: EMPTY
84261: LIST
84262: LIST
84263: PUSH
84264: LD_INT 1
84266: NEG
84267: PUSH
84268: LD_INT 0
84270: PUSH
84271: EMPTY
84272: LIST
84273: LIST
84274: PUSH
84275: LD_INT 1
84277: NEG
84278: PUSH
84279: LD_INT 1
84281: NEG
84282: PUSH
84283: EMPTY
84284: LIST
84285: LIST
84286: PUSH
84287: LD_INT 1
84289: NEG
84290: PUSH
84291: LD_INT 2
84293: NEG
84294: PUSH
84295: EMPTY
84296: LIST
84297: LIST
84298: PUSH
84299: LD_INT 0
84301: PUSH
84302: LD_INT 2
84304: NEG
84305: PUSH
84306: EMPTY
84307: LIST
84308: LIST
84309: PUSH
84310: LD_INT 1
84312: PUSH
84313: LD_INT 1
84315: NEG
84316: PUSH
84317: EMPTY
84318: LIST
84319: LIST
84320: PUSH
84321: LD_INT 2
84323: PUSH
84324: LD_INT 0
84326: PUSH
84327: EMPTY
84328: LIST
84329: LIST
84330: PUSH
84331: LD_INT 2
84333: PUSH
84334: LD_INT 1
84336: PUSH
84337: EMPTY
84338: LIST
84339: LIST
84340: PUSH
84341: LD_INT 2
84343: PUSH
84344: LD_INT 2
84346: PUSH
84347: EMPTY
84348: LIST
84349: LIST
84350: PUSH
84351: LD_INT 1
84353: PUSH
84354: LD_INT 2
84356: PUSH
84357: EMPTY
84358: LIST
84359: LIST
84360: PUSH
84361: LD_INT 0
84363: PUSH
84364: LD_INT 2
84366: PUSH
84367: EMPTY
84368: LIST
84369: LIST
84370: PUSH
84371: LD_INT 1
84373: NEG
84374: PUSH
84375: LD_INT 1
84377: PUSH
84378: EMPTY
84379: LIST
84380: LIST
84381: PUSH
84382: LD_INT 2
84384: NEG
84385: PUSH
84386: LD_INT 0
84388: PUSH
84389: EMPTY
84390: LIST
84391: LIST
84392: PUSH
84393: LD_INT 2
84395: NEG
84396: PUSH
84397: LD_INT 1
84399: NEG
84400: PUSH
84401: EMPTY
84402: LIST
84403: LIST
84404: PUSH
84405: LD_INT 2
84407: NEG
84408: PUSH
84409: LD_INT 2
84411: NEG
84412: PUSH
84413: EMPTY
84414: LIST
84415: LIST
84416: PUSH
84417: LD_INT 2
84419: NEG
84420: PUSH
84421: LD_INT 3
84423: NEG
84424: PUSH
84425: EMPTY
84426: LIST
84427: LIST
84428: PUSH
84429: LD_INT 1
84431: NEG
84432: PUSH
84433: LD_INT 3
84435: NEG
84436: PUSH
84437: EMPTY
84438: LIST
84439: LIST
84440: PUSH
84441: LD_INT 1
84443: PUSH
84444: LD_INT 2
84446: NEG
84447: PUSH
84448: EMPTY
84449: LIST
84450: LIST
84451: PUSH
84452: LD_INT 2
84454: PUSH
84455: LD_INT 1
84457: NEG
84458: PUSH
84459: EMPTY
84460: LIST
84461: LIST
84462: PUSH
84463: EMPTY
84464: LIST
84465: LIST
84466: LIST
84467: LIST
84468: LIST
84469: LIST
84470: LIST
84471: LIST
84472: LIST
84473: LIST
84474: LIST
84475: LIST
84476: LIST
84477: LIST
84478: LIST
84479: LIST
84480: LIST
84481: LIST
84482: LIST
84483: LIST
84484: LIST
84485: LIST
84486: LIST
84487: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
84488: LD_ADDR_VAR 0 24
84492: PUSH
84493: LD_INT 0
84495: PUSH
84496: LD_INT 0
84498: PUSH
84499: EMPTY
84500: LIST
84501: LIST
84502: PUSH
84503: LD_INT 0
84505: PUSH
84506: LD_INT 1
84508: NEG
84509: PUSH
84510: EMPTY
84511: LIST
84512: LIST
84513: PUSH
84514: LD_INT 1
84516: PUSH
84517: LD_INT 0
84519: PUSH
84520: EMPTY
84521: LIST
84522: LIST
84523: PUSH
84524: LD_INT 1
84526: PUSH
84527: LD_INT 1
84529: PUSH
84530: EMPTY
84531: LIST
84532: LIST
84533: PUSH
84534: LD_INT 0
84536: PUSH
84537: LD_INT 1
84539: PUSH
84540: EMPTY
84541: LIST
84542: LIST
84543: PUSH
84544: LD_INT 1
84546: NEG
84547: PUSH
84548: LD_INT 0
84550: PUSH
84551: EMPTY
84552: LIST
84553: LIST
84554: PUSH
84555: LD_INT 1
84557: NEG
84558: PUSH
84559: LD_INT 1
84561: NEG
84562: PUSH
84563: EMPTY
84564: LIST
84565: LIST
84566: PUSH
84567: LD_INT 1
84569: NEG
84570: PUSH
84571: LD_INT 2
84573: NEG
84574: PUSH
84575: EMPTY
84576: LIST
84577: LIST
84578: PUSH
84579: LD_INT 0
84581: PUSH
84582: LD_INT 2
84584: NEG
84585: PUSH
84586: EMPTY
84587: LIST
84588: LIST
84589: PUSH
84590: LD_INT 1
84592: PUSH
84593: LD_INT 1
84595: NEG
84596: PUSH
84597: EMPTY
84598: LIST
84599: LIST
84600: PUSH
84601: LD_INT 2
84603: PUSH
84604: LD_INT 0
84606: PUSH
84607: EMPTY
84608: LIST
84609: LIST
84610: PUSH
84611: LD_INT 2
84613: PUSH
84614: LD_INT 1
84616: PUSH
84617: EMPTY
84618: LIST
84619: LIST
84620: PUSH
84621: LD_INT 2
84623: PUSH
84624: LD_INT 2
84626: PUSH
84627: EMPTY
84628: LIST
84629: LIST
84630: PUSH
84631: LD_INT 1
84633: PUSH
84634: LD_INT 2
84636: PUSH
84637: EMPTY
84638: LIST
84639: LIST
84640: PUSH
84641: LD_INT 0
84643: PUSH
84644: LD_INT 2
84646: PUSH
84647: EMPTY
84648: LIST
84649: LIST
84650: PUSH
84651: LD_INT 1
84653: NEG
84654: PUSH
84655: LD_INT 1
84657: PUSH
84658: EMPTY
84659: LIST
84660: LIST
84661: PUSH
84662: LD_INT 2
84664: NEG
84665: PUSH
84666: LD_INT 0
84668: PUSH
84669: EMPTY
84670: LIST
84671: LIST
84672: PUSH
84673: LD_INT 2
84675: NEG
84676: PUSH
84677: LD_INT 1
84679: NEG
84680: PUSH
84681: EMPTY
84682: LIST
84683: LIST
84684: PUSH
84685: LD_INT 2
84687: NEG
84688: PUSH
84689: LD_INT 2
84691: NEG
84692: PUSH
84693: EMPTY
84694: LIST
84695: LIST
84696: PUSH
84697: LD_INT 1
84699: PUSH
84700: LD_INT 2
84702: NEG
84703: PUSH
84704: EMPTY
84705: LIST
84706: LIST
84707: PUSH
84708: LD_INT 2
84710: PUSH
84711: LD_INT 1
84713: NEG
84714: PUSH
84715: EMPTY
84716: LIST
84717: LIST
84718: PUSH
84719: LD_INT 3
84721: PUSH
84722: LD_INT 1
84724: PUSH
84725: EMPTY
84726: LIST
84727: LIST
84728: PUSH
84729: LD_INT 3
84731: PUSH
84732: LD_INT 2
84734: PUSH
84735: EMPTY
84736: LIST
84737: LIST
84738: PUSH
84739: EMPTY
84740: LIST
84741: LIST
84742: LIST
84743: LIST
84744: LIST
84745: LIST
84746: LIST
84747: LIST
84748: LIST
84749: LIST
84750: LIST
84751: LIST
84752: LIST
84753: LIST
84754: LIST
84755: LIST
84756: LIST
84757: LIST
84758: LIST
84759: LIST
84760: LIST
84761: LIST
84762: LIST
84763: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
84764: LD_ADDR_VAR 0 25
84768: PUSH
84769: LD_INT 0
84771: PUSH
84772: LD_INT 0
84774: PUSH
84775: EMPTY
84776: LIST
84777: LIST
84778: PUSH
84779: LD_INT 0
84781: PUSH
84782: LD_INT 1
84784: NEG
84785: PUSH
84786: EMPTY
84787: LIST
84788: LIST
84789: PUSH
84790: LD_INT 1
84792: PUSH
84793: LD_INT 0
84795: PUSH
84796: EMPTY
84797: LIST
84798: LIST
84799: PUSH
84800: LD_INT 1
84802: PUSH
84803: LD_INT 1
84805: PUSH
84806: EMPTY
84807: LIST
84808: LIST
84809: PUSH
84810: LD_INT 0
84812: PUSH
84813: LD_INT 1
84815: PUSH
84816: EMPTY
84817: LIST
84818: LIST
84819: PUSH
84820: LD_INT 1
84822: NEG
84823: PUSH
84824: LD_INT 0
84826: PUSH
84827: EMPTY
84828: LIST
84829: LIST
84830: PUSH
84831: LD_INT 1
84833: NEG
84834: PUSH
84835: LD_INT 1
84837: NEG
84838: PUSH
84839: EMPTY
84840: LIST
84841: LIST
84842: PUSH
84843: LD_INT 1
84845: NEG
84846: PUSH
84847: LD_INT 2
84849: NEG
84850: PUSH
84851: EMPTY
84852: LIST
84853: LIST
84854: PUSH
84855: LD_INT 0
84857: PUSH
84858: LD_INT 2
84860: NEG
84861: PUSH
84862: EMPTY
84863: LIST
84864: LIST
84865: PUSH
84866: LD_INT 1
84868: PUSH
84869: LD_INT 1
84871: NEG
84872: PUSH
84873: EMPTY
84874: LIST
84875: LIST
84876: PUSH
84877: LD_INT 2
84879: PUSH
84880: LD_INT 0
84882: PUSH
84883: EMPTY
84884: LIST
84885: LIST
84886: PUSH
84887: LD_INT 2
84889: PUSH
84890: LD_INT 1
84892: PUSH
84893: EMPTY
84894: LIST
84895: LIST
84896: PUSH
84897: LD_INT 2
84899: PUSH
84900: LD_INT 2
84902: PUSH
84903: EMPTY
84904: LIST
84905: LIST
84906: PUSH
84907: LD_INT 1
84909: PUSH
84910: LD_INT 2
84912: PUSH
84913: EMPTY
84914: LIST
84915: LIST
84916: PUSH
84917: LD_INT 0
84919: PUSH
84920: LD_INT 2
84922: PUSH
84923: EMPTY
84924: LIST
84925: LIST
84926: PUSH
84927: LD_INT 1
84929: NEG
84930: PUSH
84931: LD_INT 1
84933: PUSH
84934: EMPTY
84935: LIST
84936: LIST
84937: PUSH
84938: LD_INT 2
84940: NEG
84941: PUSH
84942: LD_INT 0
84944: PUSH
84945: EMPTY
84946: LIST
84947: LIST
84948: PUSH
84949: LD_INT 2
84951: NEG
84952: PUSH
84953: LD_INT 1
84955: NEG
84956: PUSH
84957: EMPTY
84958: LIST
84959: LIST
84960: PUSH
84961: LD_INT 2
84963: NEG
84964: PUSH
84965: LD_INT 2
84967: NEG
84968: PUSH
84969: EMPTY
84970: LIST
84971: LIST
84972: PUSH
84973: LD_INT 3
84975: PUSH
84976: LD_INT 1
84978: PUSH
84979: EMPTY
84980: LIST
84981: LIST
84982: PUSH
84983: LD_INT 3
84985: PUSH
84986: LD_INT 2
84988: PUSH
84989: EMPTY
84990: LIST
84991: LIST
84992: PUSH
84993: LD_INT 2
84995: PUSH
84996: LD_INT 3
84998: PUSH
84999: EMPTY
85000: LIST
85001: LIST
85002: PUSH
85003: LD_INT 1
85005: PUSH
85006: LD_INT 3
85008: PUSH
85009: EMPTY
85010: LIST
85011: LIST
85012: PUSH
85013: EMPTY
85014: LIST
85015: LIST
85016: LIST
85017: LIST
85018: LIST
85019: LIST
85020: LIST
85021: LIST
85022: LIST
85023: LIST
85024: LIST
85025: LIST
85026: LIST
85027: LIST
85028: LIST
85029: LIST
85030: LIST
85031: LIST
85032: LIST
85033: LIST
85034: LIST
85035: LIST
85036: LIST
85037: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
85038: LD_ADDR_VAR 0 26
85042: PUSH
85043: LD_INT 0
85045: PUSH
85046: LD_INT 0
85048: PUSH
85049: EMPTY
85050: LIST
85051: LIST
85052: PUSH
85053: LD_INT 0
85055: PUSH
85056: LD_INT 1
85058: NEG
85059: PUSH
85060: EMPTY
85061: LIST
85062: LIST
85063: PUSH
85064: LD_INT 1
85066: PUSH
85067: LD_INT 0
85069: PUSH
85070: EMPTY
85071: LIST
85072: LIST
85073: PUSH
85074: LD_INT 1
85076: PUSH
85077: LD_INT 1
85079: PUSH
85080: EMPTY
85081: LIST
85082: LIST
85083: PUSH
85084: LD_INT 0
85086: PUSH
85087: LD_INT 1
85089: PUSH
85090: EMPTY
85091: LIST
85092: LIST
85093: PUSH
85094: LD_INT 1
85096: NEG
85097: PUSH
85098: LD_INT 0
85100: PUSH
85101: EMPTY
85102: LIST
85103: LIST
85104: PUSH
85105: LD_INT 1
85107: NEG
85108: PUSH
85109: LD_INT 1
85111: NEG
85112: PUSH
85113: EMPTY
85114: LIST
85115: LIST
85116: PUSH
85117: LD_INT 1
85119: NEG
85120: PUSH
85121: LD_INT 2
85123: NEG
85124: PUSH
85125: EMPTY
85126: LIST
85127: LIST
85128: PUSH
85129: LD_INT 0
85131: PUSH
85132: LD_INT 2
85134: NEG
85135: PUSH
85136: EMPTY
85137: LIST
85138: LIST
85139: PUSH
85140: LD_INT 1
85142: PUSH
85143: LD_INT 1
85145: NEG
85146: PUSH
85147: EMPTY
85148: LIST
85149: LIST
85150: PUSH
85151: LD_INT 2
85153: PUSH
85154: LD_INT 0
85156: PUSH
85157: EMPTY
85158: LIST
85159: LIST
85160: PUSH
85161: LD_INT 2
85163: PUSH
85164: LD_INT 1
85166: PUSH
85167: EMPTY
85168: LIST
85169: LIST
85170: PUSH
85171: LD_INT 2
85173: PUSH
85174: LD_INT 2
85176: PUSH
85177: EMPTY
85178: LIST
85179: LIST
85180: PUSH
85181: LD_INT 1
85183: PUSH
85184: LD_INT 2
85186: PUSH
85187: EMPTY
85188: LIST
85189: LIST
85190: PUSH
85191: LD_INT 0
85193: PUSH
85194: LD_INT 2
85196: PUSH
85197: EMPTY
85198: LIST
85199: LIST
85200: PUSH
85201: LD_INT 1
85203: NEG
85204: PUSH
85205: LD_INT 1
85207: PUSH
85208: EMPTY
85209: LIST
85210: LIST
85211: PUSH
85212: LD_INT 2
85214: NEG
85215: PUSH
85216: LD_INT 0
85218: PUSH
85219: EMPTY
85220: LIST
85221: LIST
85222: PUSH
85223: LD_INT 2
85225: NEG
85226: PUSH
85227: LD_INT 1
85229: NEG
85230: PUSH
85231: EMPTY
85232: LIST
85233: LIST
85234: PUSH
85235: LD_INT 2
85237: NEG
85238: PUSH
85239: LD_INT 2
85241: NEG
85242: PUSH
85243: EMPTY
85244: LIST
85245: LIST
85246: PUSH
85247: LD_INT 2
85249: PUSH
85250: LD_INT 3
85252: PUSH
85253: EMPTY
85254: LIST
85255: LIST
85256: PUSH
85257: LD_INT 1
85259: PUSH
85260: LD_INT 3
85262: PUSH
85263: EMPTY
85264: LIST
85265: LIST
85266: PUSH
85267: LD_INT 1
85269: NEG
85270: PUSH
85271: LD_INT 2
85273: PUSH
85274: EMPTY
85275: LIST
85276: LIST
85277: PUSH
85278: LD_INT 2
85280: NEG
85281: PUSH
85282: LD_INT 1
85284: PUSH
85285: EMPTY
85286: LIST
85287: LIST
85288: PUSH
85289: EMPTY
85290: LIST
85291: LIST
85292: LIST
85293: LIST
85294: LIST
85295: LIST
85296: LIST
85297: LIST
85298: LIST
85299: LIST
85300: LIST
85301: LIST
85302: LIST
85303: LIST
85304: LIST
85305: LIST
85306: LIST
85307: LIST
85308: LIST
85309: LIST
85310: LIST
85311: LIST
85312: LIST
85313: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
85314: LD_ADDR_VAR 0 27
85318: PUSH
85319: LD_INT 0
85321: PUSH
85322: LD_INT 0
85324: PUSH
85325: EMPTY
85326: LIST
85327: LIST
85328: PUSH
85329: LD_INT 0
85331: PUSH
85332: LD_INT 1
85334: NEG
85335: PUSH
85336: EMPTY
85337: LIST
85338: LIST
85339: PUSH
85340: LD_INT 1
85342: PUSH
85343: LD_INT 0
85345: PUSH
85346: EMPTY
85347: LIST
85348: LIST
85349: PUSH
85350: LD_INT 1
85352: PUSH
85353: LD_INT 1
85355: PUSH
85356: EMPTY
85357: LIST
85358: LIST
85359: PUSH
85360: LD_INT 0
85362: PUSH
85363: LD_INT 1
85365: PUSH
85366: EMPTY
85367: LIST
85368: LIST
85369: PUSH
85370: LD_INT 1
85372: NEG
85373: PUSH
85374: LD_INT 0
85376: PUSH
85377: EMPTY
85378: LIST
85379: LIST
85380: PUSH
85381: LD_INT 1
85383: NEG
85384: PUSH
85385: LD_INT 1
85387: NEG
85388: PUSH
85389: EMPTY
85390: LIST
85391: LIST
85392: PUSH
85393: LD_INT 1
85395: NEG
85396: PUSH
85397: LD_INT 2
85399: NEG
85400: PUSH
85401: EMPTY
85402: LIST
85403: LIST
85404: PUSH
85405: LD_INT 0
85407: PUSH
85408: LD_INT 2
85410: NEG
85411: PUSH
85412: EMPTY
85413: LIST
85414: LIST
85415: PUSH
85416: LD_INT 1
85418: PUSH
85419: LD_INT 1
85421: NEG
85422: PUSH
85423: EMPTY
85424: LIST
85425: LIST
85426: PUSH
85427: LD_INT 2
85429: PUSH
85430: LD_INT 0
85432: PUSH
85433: EMPTY
85434: LIST
85435: LIST
85436: PUSH
85437: LD_INT 2
85439: PUSH
85440: LD_INT 1
85442: PUSH
85443: EMPTY
85444: LIST
85445: LIST
85446: PUSH
85447: LD_INT 2
85449: PUSH
85450: LD_INT 2
85452: PUSH
85453: EMPTY
85454: LIST
85455: LIST
85456: PUSH
85457: LD_INT 1
85459: PUSH
85460: LD_INT 2
85462: PUSH
85463: EMPTY
85464: LIST
85465: LIST
85466: PUSH
85467: LD_INT 0
85469: PUSH
85470: LD_INT 2
85472: PUSH
85473: EMPTY
85474: LIST
85475: LIST
85476: PUSH
85477: LD_INT 1
85479: NEG
85480: PUSH
85481: LD_INT 1
85483: PUSH
85484: EMPTY
85485: LIST
85486: LIST
85487: PUSH
85488: LD_INT 2
85490: NEG
85491: PUSH
85492: LD_INT 0
85494: PUSH
85495: EMPTY
85496: LIST
85497: LIST
85498: PUSH
85499: LD_INT 2
85501: NEG
85502: PUSH
85503: LD_INT 1
85505: NEG
85506: PUSH
85507: EMPTY
85508: LIST
85509: LIST
85510: PUSH
85511: LD_INT 2
85513: NEG
85514: PUSH
85515: LD_INT 2
85517: NEG
85518: PUSH
85519: EMPTY
85520: LIST
85521: LIST
85522: PUSH
85523: LD_INT 1
85525: NEG
85526: PUSH
85527: LD_INT 2
85529: PUSH
85530: EMPTY
85531: LIST
85532: LIST
85533: PUSH
85534: LD_INT 2
85536: NEG
85537: PUSH
85538: LD_INT 1
85540: PUSH
85541: EMPTY
85542: LIST
85543: LIST
85544: PUSH
85545: LD_INT 3
85547: NEG
85548: PUSH
85549: LD_INT 1
85551: NEG
85552: PUSH
85553: EMPTY
85554: LIST
85555: LIST
85556: PUSH
85557: LD_INT 3
85559: NEG
85560: PUSH
85561: LD_INT 2
85563: NEG
85564: PUSH
85565: EMPTY
85566: LIST
85567: LIST
85568: PUSH
85569: EMPTY
85570: LIST
85571: LIST
85572: LIST
85573: LIST
85574: LIST
85575: LIST
85576: LIST
85577: LIST
85578: LIST
85579: LIST
85580: LIST
85581: LIST
85582: LIST
85583: LIST
85584: LIST
85585: LIST
85586: LIST
85587: LIST
85588: LIST
85589: LIST
85590: LIST
85591: LIST
85592: LIST
85593: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
85594: LD_ADDR_VAR 0 28
85598: PUSH
85599: LD_INT 0
85601: PUSH
85602: LD_INT 0
85604: PUSH
85605: EMPTY
85606: LIST
85607: LIST
85608: PUSH
85609: LD_INT 0
85611: PUSH
85612: LD_INT 1
85614: NEG
85615: PUSH
85616: EMPTY
85617: LIST
85618: LIST
85619: PUSH
85620: LD_INT 1
85622: PUSH
85623: LD_INT 0
85625: PUSH
85626: EMPTY
85627: LIST
85628: LIST
85629: PUSH
85630: LD_INT 1
85632: PUSH
85633: LD_INT 1
85635: PUSH
85636: EMPTY
85637: LIST
85638: LIST
85639: PUSH
85640: LD_INT 0
85642: PUSH
85643: LD_INT 1
85645: PUSH
85646: EMPTY
85647: LIST
85648: LIST
85649: PUSH
85650: LD_INT 1
85652: NEG
85653: PUSH
85654: LD_INT 0
85656: PUSH
85657: EMPTY
85658: LIST
85659: LIST
85660: PUSH
85661: LD_INT 1
85663: NEG
85664: PUSH
85665: LD_INT 1
85667: NEG
85668: PUSH
85669: EMPTY
85670: LIST
85671: LIST
85672: PUSH
85673: LD_INT 1
85675: NEG
85676: PUSH
85677: LD_INT 2
85679: NEG
85680: PUSH
85681: EMPTY
85682: LIST
85683: LIST
85684: PUSH
85685: LD_INT 0
85687: PUSH
85688: LD_INT 2
85690: NEG
85691: PUSH
85692: EMPTY
85693: LIST
85694: LIST
85695: PUSH
85696: LD_INT 1
85698: PUSH
85699: LD_INT 1
85701: NEG
85702: PUSH
85703: EMPTY
85704: LIST
85705: LIST
85706: PUSH
85707: LD_INT 2
85709: PUSH
85710: LD_INT 0
85712: PUSH
85713: EMPTY
85714: LIST
85715: LIST
85716: PUSH
85717: LD_INT 2
85719: PUSH
85720: LD_INT 1
85722: PUSH
85723: EMPTY
85724: LIST
85725: LIST
85726: PUSH
85727: LD_INT 2
85729: PUSH
85730: LD_INT 2
85732: PUSH
85733: EMPTY
85734: LIST
85735: LIST
85736: PUSH
85737: LD_INT 1
85739: PUSH
85740: LD_INT 2
85742: PUSH
85743: EMPTY
85744: LIST
85745: LIST
85746: PUSH
85747: LD_INT 0
85749: PUSH
85750: LD_INT 2
85752: PUSH
85753: EMPTY
85754: LIST
85755: LIST
85756: PUSH
85757: LD_INT 1
85759: NEG
85760: PUSH
85761: LD_INT 1
85763: PUSH
85764: EMPTY
85765: LIST
85766: LIST
85767: PUSH
85768: LD_INT 2
85770: NEG
85771: PUSH
85772: LD_INT 0
85774: PUSH
85775: EMPTY
85776: LIST
85777: LIST
85778: PUSH
85779: LD_INT 2
85781: NEG
85782: PUSH
85783: LD_INT 1
85785: NEG
85786: PUSH
85787: EMPTY
85788: LIST
85789: LIST
85790: PUSH
85791: LD_INT 2
85793: NEG
85794: PUSH
85795: LD_INT 2
85797: NEG
85798: PUSH
85799: EMPTY
85800: LIST
85801: LIST
85802: PUSH
85803: LD_INT 2
85805: NEG
85806: PUSH
85807: LD_INT 3
85809: NEG
85810: PUSH
85811: EMPTY
85812: LIST
85813: LIST
85814: PUSH
85815: LD_INT 1
85817: NEG
85818: PUSH
85819: LD_INT 3
85821: NEG
85822: PUSH
85823: EMPTY
85824: LIST
85825: LIST
85826: PUSH
85827: LD_INT 3
85829: NEG
85830: PUSH
85831: LD_INT 1
85833: NEG
85834: PUSH
85835: EMPTY
85836: LIST
85837: LIST
85838: PUSH
85839: LD_INT 3
85841: NEG
85842: PUSH
85843: LD_INT 2
85845: NEG
85846: PUSH
85847: EMPTY
85848: LIST
85849: LIST
85850: PUSH
85851: EMPTY
85852: LIST
85853: LIST
85854: LIST
85855: LIST
85856: LIST
85857: LIST
85858: LIST
85859: LIST
85860: LIST
85861: LIST
85862: LIST
85863: LIST
85864: LIST
85865: LIST
85866: LIST
85867: LIST
85868: LIST
85869: LIST
85870: LIST
85871: LIST
85872: LIST
85873: LIST
85874: LIST
85875: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85876: LD_ADDR_VAR 0 29
85880: PUSH
85881: LD_INT 0
85883: PUSH
85884: LD_INT 0
85886: PUSH
85887: EMPTY
85888: LIST
85889: LIST
85890: PUSH
85891: LD_INT 0
85893: PUSH
85894: LD_INT 1
85896: NEG
85897: PUSH
85898: EMPTY
85899: LIST
85900: LIST
85901: PUSH
85902: LD_INT 1
85904: PUSH
85905: LD_INT 0
85907: PUSH
85908: EMPTY
85909: LIST
85910: LIST
85911: PUSH
85912: LD_INT 1
85914: PUSH
85915: LD_INT 1
85917: PUSH
85918: EMPTY
85919: LIST
85920: LIST
85921: PUSH
85922: LD_INT 0
85924: PUSH
85925: LD_INT 1
85927: PUSH
85928: EMPTY
85929: LIST
85930: LIST
85931: PUSH
85932: LD_INT 1
85934: NEG
85935: PUSH
85936: LD_INT 0
85938: PUSH
85939: EMPTY
85940: LIST
85941: LIST
85942: PUSH
85943: LD_INT 1
85945: NEG
85946: PUSH
85947: LD_INT 1
85949: NEG
85950: PUSH
85951: EMPTY
85952: LIST
85953: LIST
85954: PUSH
85955: LD_INT 1
85957: NEG
85958: PUSH
85959: LD_INT 2
85961: NEG
85962: PUSH
85963: EMPTY
85964: LIST
85965: LIST
85966: PUSH
85967: LD_INT 0
85969: PUSH
85970: LD_INT 2
85972: NEG
85973: PUSH
85974: EMPTY
85975: LIST
85976: LIST
85977: PUSH
85978: LD_INT 1
85980: PUSH
85981: LD_INT 1
85983: NEG
85984: PUSH
85985: EMPTY
85986: LIST
85987: LIST
85988: PUSH
85989: LD_INT 2
85991: PUSH
85992: LD_INT 0
85994: PUSH
85995: EMPTY
85996: LIST
85997: LIST
85998: PUSH
85999: LD_INT 2
86001: PUSH
86002: LD_INT 1
86004: PUSH
86005: EMPTY
86006: LIST
86007: LIST
86008: PUSH
86009: LD_INT 1
86011: PUSH
86012: LD_INT 2
86014: PUSH
86015: EMPTY
86016: LIST
86017: LIST
86018: PUSH
86019: LD_INT 0
86021: PUSH
86022: LD_INT 2
86024: PUSH
86025: EMPTY
86026: LIST
86027: LIST
86028: PUSH
86029: LD_INT 1
86031: NEG
86032: PUSH
86033: LD_INT 1
86035: PUSH
86036: EMPTY
86037: LIST
86038: LIST
86039: PUSH
86040: LD_INT 2
86042: NEG
86043: PUSH
86044: LD_INT 1
86046: NEG
86047: PUSH
86048: EMPTY
86049: LIST
86050: LIST
86051: PUSH
86052: LD_INT 2
86054: NEG
86055: PUSH
86056: LD_INT 2
86058: NEG
86059: PUSH
86060: EMPTY
86061: LIST
86062: LIST
86063: PUSH
86064: LD_INT 2
86066: NEG
86067: PUSH
86068: LD_INT 3
86070: NEG
86071: PUSH
86072: EMPTY
86073: LIST
86074: LIST
86075: PUSH
86076: LD_INT 2
86078: PUSH
86079: LD_INT 1
86081: NEG
86082: PUSH
86083: EMPTY
86084: LIST
86085: LIST
86086: PUSH
86087: LD_INT 3
86089: PUSH
86090: LD_INT 1
86092: PUSH
86093: EMPTY
86094: LIST
86095: LIST
86096: PUSH
86097: LD_INT 1
86099: PUSH
86100: LD_INT 3
86102: PUSH
86103: EMPTY
86104: LIST
86105: LIST
86106: PUSH
86107: LD_INT 1
86109: NEG
86110: PUSH
86111: LD_INT 2
86113: PUSH
86114: EMPTY
86115: LIST
86116: LIST
86117: PUSH
86118: LD_INT 3
86120: NEG
86121: PUSH
86122: LD_INT 2
86124: NEG
86125: PUSH
86126: EMPTY
86127: LIST
86128: LIST
86129: PUSH
86130: EMPTY
86131: LIST
86132: LIST
86133: LIST
86134: LIST
86135: LIST
86136: LIST
86137: LIST
86138: LIST
86139: LIST
86140: LIST
86141: LIST
86142: LIST
86143: LIST
86144: LIST
86145: LIST
86146: LIST
86147: LIST
86148: LIST
86149: LIST
86150: LIST
86151: LIST
86152: LIST
86153: LIST
86154: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86155: LD_ADDR_VAR 0 30
86159: PUSH
86160: LD_INT 0
86162: PUSH
86163: LD_INT 0
86165: PUSH
86166: EMPTY
86167: LIST
86168: LIST
86169: PUSH
86170: LD_INT 0
86172: PUSH
86173: LD_INT 1
86175: NEG
86176: PUSH
86177: EMPTY
86178: LIST
86179: LIST
86180: PUSH
86181: LD_INT 1
86183: PUSH
86184: LD_INT 0
86186: PUSH
86187: EMPTY
86188: LIST
86189: LIST
86190: PUSH
86191: LD_INT 1
86193: PUSH
86194: LD_INT 1
86196: PUSH
86197: EMPTY
86198: LIST
86199: LIST
86200: PUSH
86201: LD_INT 0
86203: PUSH
86204: LD_INT 1
86206: PUSH
86207: EMPTY
86208: LIST
86209: LIST
86210: PUSH
86211: LD_INT 1
86213: NEG
86214: PUSH
86215: LD_INT 0
86217: PUSH
86218: EMPTY
86219: LIST
86220: LIST
86221: PUSH
86222: LD_INT 1
86224: NEG
86225: PUSH
86226: LD_INT 1
86228: NEG
86229: PUSH
86230: EMPTY
86231: LIST
86232: LIST
86233: PUSH
86234: LD_INT 1
86236: NEG
86237: PUSH
86238: LD_INT 2
86240: NEG
86241: PUSH
86242: EMPTY
86243: LIST
86244: LIST
86245: PUSH
86246: LD_INT 0
86248: PUSH
86249: LD_INT 2
86251: NEG
86252: PUSH
86253: EMPTY
86254: LIST
86255: LIST
86256: PUSH
86257: LD_INT 1
86259: PUSH
86260: LD_INT 1
86262: NEG
86263: PUSH
86264: EMPTY
86265: LIST
86266: LIST
86267: PUSH
86268: LD_INT 2
86270: PUSH
86271: LD_INT 0
86273: PUSH
86274: EMPTY
86275: LIST
86276: LIST
86277: PUSH
86278: LD_INT 2
86280: PUSH
86281: LD_INT 1
86283: PUSH
86284: EMPTY
86285: LIST
86286: LIST
86287: PUSH
86288: LD_INT 2
86290: PUSH
86291: LD_INT 2
86293: PUSH
86294: EMPTY
86295: LIST
86296: LIST
86297: PUSH
86298: LD_INT 1
86300: PUSH
86301: LD_INT 2
86303: PUSH
86304: EMPTY
86305: LIST
86306: LIST
86307: PUSH
86308: LD_INT 1
86310: NEG
86311: PUSH
86312: LD_INT 1
86314: PUSH
86315: EMPTY
86316: LIST
86317: LIST
86318: PUSH
86319: LD_INT 2
86321: NEG
86322: PUSH
86323: LD_INT 0
86325: PUSH
86326: EMPTY
86327: LIST
86328: LIST
86329: PUSH
86330: LD_INT 2
86332: NEG
86333: PUSH
86334: LD_INT 1
86336: NEG
86337: PUSH
86338: EMPTY
86339: LIST
86340: LIST
86341: PUSH
86342: LD_INT 1
86344: NEG
86345: PUSH
86346: LD_INT 3
86348: NEG
86349: PUSH
86350: EMPTY
86351: LIST
86352: LIST
86353: PUSH
86354: LD_INT 1
86356: PUSH
86357: LD_INT 2
86359: NEG
86360: PUSH
86361: EMPTY
86362: LIST
86363: LIST
86364: PUSH
86365: LD_INT 3
86367: PUSH
86368: LD_INT 2
86370: PUSH
86371: EMPTY
86372: LIST
86373: LIST
86374: PUSH
86375: LD_INT 2
86377: PUSH
86378: LD_INT 3
86380: PUSH
86381: EMPTY
86382: LIST
86383: LIST
86384: PUSH
86385: LD_INT 2
86387: NEG
86388: PUSH
86389: LD_INT 1
86391: PUSH
86392: EMPTY
86393: LIST
86394: LIST
86395: PUSH
86396: LD_INT 3
86398: NEG
86399: PUSH
86400: LD_INT 1
86402: NEG
86403: PUSH
86404: EMPTY
86405: LIST
86406: LIST
86407: PUSH
86408: EMPTY
86409: LIST
86410: LIST
86411: LIST
86412: LIST
86413: LIST
86414: LIST
86415: LIST
86416: LIST
86417: LIST
86418: LIST
86419: LIST
86420: LIST
86421: LIST
86422: LIST
86423: LIST
86424: LIST
86425: LIST
86426: LIST
86427: LIST
86428: LIST
86429: LIST
86430: LIST
86431: LIST
86432: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
86433: LD_ADDR_VAR 0 31
86437: PUSH
86438: LD_INT 0
86440: PUSH
86441: LD_INT 0
86443: PUSH
86444: EMPTY
86445: LIST
86446: LIST
86447: PUSH
86448: LD_INT 0
86450: PUSH
86451: LD_INT 1
86453: NEG
86454: PUSH
86455: EMPTY
86456: LIST
86457: LIST
86458: PUSH
86459: LD_INT 1
86461: PUSH
86462: LD_INT 0
86464: PUSH
86465: EMPTY
86466: LIST
86467: LIST
86468: PUSH
86469: LD_INT 1
86471: PUSH
86472: LD_INT 1
86474: PUSH
86475: EMPTY
86476: LIST
86477: LIST
86478: PUSH
86479: LD_INT 0
86481: PUSH
86482: LD_INT 1
86484: PUSH
86485: EMPTY
86486: LIST
86487: LIST
86488: PUSH
86489: LD_INT 1
86491: NEG
86492: PUSH
86493: LD_INT 0
86495: PUSH
86496: EMPTY
86497: LIST
86498: LIST
86499: PUSH
86500: LD_INT 1
86502: NEG
86503: PUSH
86504: LD_INT 1
86506: NEG
86507: PUSH
86508: EMPTY
86509: LIST
86510: LIST
86511: PUSH
86512: LD_INT 1
86514: NEG
86515: PUSH
86516: LD_INT 2
86518: NEG
86519: PUSH
86520: EMPTY
86521: LIST
86522: LIST
86523: PUSH
86524: LD_INT 1
86526: PUSH
86527: LD_INT 1
86529: NEG
86530: PUSH
86531: EMPTY
86532: LIST
86533: LIST
86534: PUSH
86535: LD_INT 2
86537: PUSH
86538: LD_INT 0
86540: PUSH
86541: EMPTY
86542: LIST
86543: LIST
86544: PUSH
86545: LD_INT 2
86547: PUSH
86548: LD_INT 1
86550: PUSH
86551: EMPTY
86552: LIST
86553: LIST
86554: PUSH
86555: LD_INT 2
86557: PUSH
86558: LD_INT 2
86560: PUSH
86561: EMPTY
86562: LIST
86563: LIST
86564: PUSH
86565: LD_INT 1
86567: PUSH
86568: LD_INT 2
86570: PUSH
86571: EMPTY
86572: LIST
86573: LIST
86574: PUSH
86575: LD_INT 0
86577: PUSH
86578: LD_INT 2
86580: PUSH
86581: EMPTY
86582: LIST
86583: LIST
86584: PUSH
86585: LD_INT 1
86587: NEG
86588: PUSH
86589: LD_INT 1
86591: PUSH
86592: EMPTY
86593: LIST
86594: LIST
86595: PUSH
86596: LD_INT 2
86598: NEG
86599: PUSH
86600: LD_INT 1
86602: NEG
86603: PUSH
86604: EMPTY
86605: LIST
86606: LIST
86607: PUSH
86608: LD_INT 2
86610: NEG
86611: PUSH
86612: LD_INT 2
86614: NEG
86615: PUSH
86616: EMPTY
86617: LIST
86618: LIST
86619: PUSH
86620: LD_INT 2
86622: NEG
86623: PUSH
86624: LD_INT 3
86626: NEG
86627: PUSH
86628: EMPTY
86629: LIST
86630: LIST
86631: PUSH
86632: LD_INT 2
86634: PUSH
86635: LD_INT 1
86637: NEG
86638: PUSH
86639: EMPTY
86640: LIST
86641: LIST
86642: PUSH
86643: LD_INT 3
86645: PUSH
86646: LD_INT 1
86648: PUSH
86649: EMPTY
86650: LIST
86651: LIST
86652: PUSH
86653: LD_INT 1
86655: PUSH
86656: LD_INT 3
86658: PUSH
86659: EMPTY
86660: LIST
86661: LIST
86662: PUSH
86663: LD_INT 1
86665: NEG
86666: PUSH
86667: LD_INT 2
86669: PUSH
86670: EMPTY
86671: LIST
86672: LIST
86673: PUSH
86674: LD_INT 3
86676: NEG
86677: PUSH
86678: LD_INT 2
86680: NEG
86681: PUSH
86682: EMPTY
86683: LIST
86684: LIST
86685: PUSH
86686: EMPTY
86687: LIST
86688: LIST
86689: LIST
86690: LIST
86691: LIST
86692: LIST
86693: LIST
86694: LIST
86695: LIST
86696: LIST
86697: LIST
86698: LIST
86699: LIST
86700: LIST
86701: LIST
86702: LIST
86703: LIST
86704: LIST
86705: LIST
86706: LIST
86707: LIST
86708: LIST
86709: LIST
86710: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86711: LD_ADDR_VAR 0 32
86715: PUSH
86716: LD_INT 0
86718: PUSH
86719: LD_INT 0
86721: PUSH
86722: EMPTY
86723: LIST
86724: LIST
86725: PUSH
86726: LD_INT 0
86728: PUSH
86729: LD_INT 1
86731: NEG
86732: PUSH
86733: EMPTY
86734: LIST
86735: LIST
86736: PUSH
86737: LD_INT 1
86739: PUSH
86740: LD_INT 0
86742: PUSH
86743: EMPTY
86744: LIST
86745: LIST
86746: PUSH
86747: LD_INT 1
86749: PUSH
86750: LD_INT 1
86752: PUSH
86753: EMPTY
86754: LIST
86755: LIST
86756: PUSH
86757: LD_INT 0
86759: PUSH
86760: LD_INT 1
86762: PUSH
86763: EMPTY
86764: LIST
86765: LIST
86766: PUSH
86767: LD_INT 1
86769: NEG
86770: PUSH
86771: LD_INT 0
86773: PUSH
86774: EMPTY
86775: LIST
86776: LIST
86777: PUSH
86778: LD_INT 1
86780: NEG
86781: PUSH
86782: LD_INT 1
86784: NEG
86785: PUSH
86786: EMPTY
86787: LIST
86788: LIST
86789: PUSH
86790: LD_INT 1
86792: NEG
86793: PUSH
86794: LD_INT 2
86796: NEG
86797: PUSH
86798: EMPTY
86799: LIST
86800: LIST
86801: PUSH
86802: LD_INT 0
86804: PUSH
86805: LD_INT 2
86807: NEG
86808: PUSH
86809: EMPTY
86810: LIST
86811: LIST
86812: PUSH
86813: LD_INT 1
86815: PUSH
86816: LD_INT 1
86818: NEG
86819: PUSH
86820: EMPTY
86821: LIST
86822: LIST
86823: PUSH
86824: LD_INT 2
86826: PUSH
86827: LD_INT 1
86829: PUSH
86830: EMPTY
86831: LIST
86832: LIST
86833: PUSH
86834: LD_INT 2
86836: PUSH
86837: LD_INT 2
86839: PUSH
86840: EMPTY
86841: LIST
86842: LIST
86843: PUSH
86844: LD_INT 1
86846: PUSH
86847: LD_INT 2
86849: PUSH
86850: EMPTY
86851: LIST
86852: LIST
86853: PUSH
86854: LD_INT 0
86856: PUSH
86857: LD_INT 2
86859: PUSH
86860: EMPTY
86861: LIST
86862: LIST
86863: PUSH
86864: LD_INT 1
86866: NEG
86867: PUSH
86868: LD_INT 1
86870: PUSH
86871: EMPTY
86872: LIST
86873: LIST
86874: PUSH
86875: LD_INT 2
86877: NEG
86878: PUSH
86879: LD_INT 0
86881: PUSH
86882: EMPTY
86883: LIST
86884: LIST
86885: PUSH
86886: LD_INT 2
86888: NEG
86889: PUSH
86890: LD_INT 1
86892: NEG
86893: PUSH
86894: EMPTY
86895: LIST
86896: LIST
86897: PUSH
86898: LD_INT 1
86900: NEG
86901: PUSH
86902: LD_INT 3
86904: NEG
86905: PUSH
86906: EMPTY
86907: LIST
86908: LIST
86909: PUSH
86910: LD_INT 1
86912: PUSH
86913: LD_INT 2
86915: NEG
86916: PUSH
86917: EMPTY
86918: LIST
86919: LIST
86920: PUSH
86921: LD_INT 3
86923: PUSH
86924: LD_INT 2
86926: PUSH
86927: EMPTY
86928: LIST
86929: LIST
86930: PUSH
86931: LD_INT 2
86933: PUSH
86934: LD_INT 3
86936: PUSH
86937: EMPTY
86938: LIST
86939: LIST
86940: PUSH
86941: LD_INT 2
86943: NEG
86944: PUSH
86945: LD_INT 1
86947: PUSH
86948: EMPTY
86949: LIST
86950: LIST
86951: PUSH
86952: LD_INT 3
86954: NEG
86955: PUSH
86956: LD_INT 1
86958: NEG
86959: PUSH
86960: EMPTY
86961: LIST
86962: LIST
86963: PUSH
86964: EMPTY
86965: LIST
86966: LIST
86967: LIST
86968: LIST
86969: LIST
86970: LIST
86971: LIST
86972: LIST
86973: LIST
86974: LIST
86975: LIST
86976: LIST
86977: LIST
86978: LIST
86979: LIST
86980: LIST
86981: LIST
86982: LIST
86983: LIST
86984: LIST
86985: LIST
86986: LIST
86987: LIST
86988: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
86989: LD_ADDR_VAR 0 33
86993: PUSH
86994: LD_INT 0
86996: PUSH
86997: LD_INT 0
86999: PUSH
87000: EMPTY
87001: LIST
87002: LIST
87003: PUSH
87004: LD_INT 0
87006: PUSH
87007: LD_INT 1
87009: NEG
87010: PUSH
87011: EMPTY
87012: LIST
87013: LIST
87014: PUSH
87015: LD_INT 1
87017: PUSH
87018: LD_INT 0
87020: PUSH
87021: EMPTY
87022: LIST
87023: LIST
87024: PUSH
87025: LD_INT 1
87027: PUSH
87028: LD_INT 1
87030: PUSH
87031: EMPTY
87032: LIST
87033: LIST
87034: PUSH
87035: LD_INT 0
87037: PUSH
87038: LD_INT 1
87040: PUSH
87041: EMPTY
87042: LIST
87043: LIST
87044: PUSH
87045: LD_INT 1
87047: NEG
87048: PUSH
87049: LD_INT 0
87051: PUSH
87052: EMPTY
87053: LIST
87054: LIST
87055: PUSH
87056: LD_INT 1
87058: NEG
87059: PUSH
87060: LD_INT 1
87062: NEG
87063: PUSH
87064: EMPTY
87065: LIST
87066: LIST
87067: PUSH
87068: LD_INT 1
87070: NEG
87071: PUSH
87072: LD_INT 2
87074: NEG
87075: PUSH
87076: EMPTY
87077: LIST
87078: LIST
87079: PUSH
87080: LD_INT 1
87082: PUSH
87083: LD_INT 1
87085: NEG
87086: PUSH
87087: EMPTY
87088: LIST
87089: LIST
87090: PUSH
87091: LD_INT 2
87093: PUSH
87094: LD_INT 0
87096: PUSH
87097: EMPTY
87098: LIST
87099: LIST
87100: PUSH
87101: LD_INT 2
87103: PUSH
87104: LD_INT 1
87106: PUSH
87107: EMPTY
87108: LIST
87109: LIST
87110: PUSH
87111: LD_INT 1
87113: PUSH
87114: LD_INT 2
87116: PUSH
87117: EMPTY
87118: LIST
87119: LIST
87120: PUSH
87121: LD_INT 0
87123: PUSH
87124: LD_INT 2
87126: PUSH
87127: EMPTY
87128: LIST
87129: LIST
87130: PUSH
87131: LD_INT 1
87133: NEG
87134: PUSH
87135: LD_INT 1
87137: PUSH
87138: EMPTY
87139: LIST
87140: LIST
87141: PUSH
87142: LD_INT 2
87144: NEG
87145: PUSH
87146: LD_INT 0
87148: PUSH
87149: EMPTY
87150: LIST
87151: LIST
87152: PUSH
87153: LD_INT 2
87155: NEG
87156: PUSH
87157: LD_INT 1
87159: NEG
87160: PUSH
87161: EMPTY
87162: LIST
87163: LIST
87164: PUSH
87165: LD_INT 2
87167: NEG
87168: PUSH
87169: LD_INT 2
87171: NEG
87172: PUSH
87173: EMPTY
87174: LIST
87175: LIST
87176: PUSH
87177: LD_INT 2
87179: NEG
87180: PUSH
87181: LD_INT 3
87183: NEG
87184: PUSH
87185: EMPTY
87186: LIST
87187: LIST
87188: PUSH
87189: LD_INT 2
87191: PUSH
87192: LD_INT 1
87194: NEG
87195: PUSH
87196: EMPTY
87197: LIST
87198: LIST
87199: PUSH
87200: LD_INT 3
87202: PUSH
87203: LD_INT 1
87205: PUSH
87206: EMPTY
87207: LIST
87208: LIST
87209: PUSH
87210: LD_INT 1
87212: PUSH
87213: LD_INT 3
87215: PUSH
87216: EMPTY
87217: LIST
87218: LIST
87219: PUSH
87220: LD_INT 1
87222: NEG
87223: PUSH
87224: LD_INT 2
87226: PUSH
87227: EMPTY
87228: LIST
87229: LIST
87230: PUSH
87231: LD_INT 3
87233: NEG
87234: PUSH
87235: LD_INT 2
87237: NEG
87238: PUSH
87239: EMPTY
87240: LIST
87241: LIST
87242: PUSH
87243: EMPTY
87244: LIST
87245: LIST
87246: LIST
87247: LIST
87248: LIST
87249: LIST
87250: LIST
87251: LIST
87252: LIST
87253: LIST
87254: LIST
87255: LIST
87256: LIST
87257: LIST
87258: LIST
87259: LIST
87260: LIST
87261: LIST
87262: LIST
87263: LIST
87264: LIST
87265: LIST
87266: LIST
87267: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
87268: LD_ADDR_VAR 0 34
87272: PUSH
87273: LD_INT 0
87275: PUSH
87276: LD_INT 0
87278: PUSH
87279: EMPTY
87280: LIST
87281: LIST
87282: PUSH
87283: LD_INT 0
87285: PUSH
87286: LD_INT 1
87288: NEG
87289: PUSH
87290: EMPTY
87291: LIST
87292: LIST
87293: PUSH
87294: LD_INT 1
87296: PUSH
87297: LD_INT 0
87299: PUSH
87300: EMPTY
87301: LIST
87302: LIST
87303: PUSH
87304: LD_INT 1
87306: PUSH
87307: LD_INT 1
87309: PUSH
87310: EMPTY
87311: LIST
87312: LIST
87313: PUSH
87314: LD_INT 0
87316: PUSH
87317: LD_INT 1
87319: PUSH
87320: EMPTY
87321: LIST
87322: LIST
87323: PUSH
87324: LD_INT 1
87326: NEG
87327: PUSH
87328: LD_INT 0
87330: PUSH
87331: EMPTY
87332: LIST
87333: LIST
87334: PUSH
87335: LD_INT 1
87337: NEG
87338: PUSH
87339: LD_INT 1
87341: NEG
87342: PUSH
87343: EMPTY
87344: LIST
87345: LIST
87346: PUSH
87347: LD_INT 1
87349: NEG
87350: PUSH
87351: LD_INT 2
87353: NEG
87354: PUSH
87355: EMPTY
87356: LIST
87357: LIST
87358: PUSH
87359: LD_INT 0
87361: PUSH
87362: LD_INT 2
87364: NEG
87365: PUSH
87366: EMPTY
87367: LIST
87368: LIST
87369: PUSH
87370: LD_INT 1
87372: PUSH
87373: LD_INT 1
87375: NEG
87376: PUSH
87377: EMPTY
87378: LIST
87379: LIST
87380: PUSH
87381: LD_INT 2
87383: PUSH
87384: LD_INT 1
87386: PUSH
87387: EMPTY
87388: LIST
87389: LIST
87390: PUSH
87391: LD_INT 2
87393: PUSH
87394: LD_INT 2
87396: PUSH
87397: EMPTY
87398: LIST
87399: LIST
87400: PUSH
87401: LD_INT 1
87403: PUSH
87404: LD_INT 2
87406: PUSH
87407: EMPTY
87408: LIST
87409: LIST
87410: PUSH
87411: LD_INT 1
87413: NEG
87414: PUSH
87415: LD_INT 1
87417: PUSH
87418: EMPTY
87419: LIST
87420: LIST
87421: PUSH
87422: LD_INT 2
87424: NEG
87425: PUSH
87426: LD_INT 0
87428: PUSH
87429: EMPTY
87430: LIST
87431: LIST
87432: PUSH
87433: LD_INT 2
87435: NEG
87436: PUSH
87437: LD_INT 1
87439: NEG
87440: PUSH
87441: EMPTY
87442: LIST
87443: LIST
87444: PUSH
87445: LD_INT 2
87447: NEG
87448: PUSH
87449: LD_INT 2
87451: NEG
87452: PUSH
87453: EMPTY
87454: LIST
87455: LIST
87456: PUSH
87457: LD_INT 1
87459: NEG
87460: PUSH
87461: LD_INT 3
87463: NEG
87464: PUSH
87465: EMPTY
87466: LIST
87467: LIST
87468: PUSH
87469: LD_INT 1
87471: PUSH
87472: LD_INT 2
87474: NEG
87475: PUSH
87476: EMPTY
87477: LIST
87478: LIST
87479: PUSH
87480: LD_INT 3
87482: PUSH
87483: LD_INT 2
87485: PUSH
87486: EMPTY
87487: LIST
87488: LIST
87489: PUSH
87490: LD_INT 2
87492: PUSH
87493: LD_INT 3
87495: PUSH
87496: EMPTY
87497: LIST
87498: LIST
87499: PUSH
87500: LD_INT 2
87502: NEG
87503: PUSH
87504: LD_INT 1
87506: PUSH
87507: EMPTY
87508: LIST
87509: LIST
87510: PUSH
87511: LD_INT 3
87513: NEG
87514: PUSH
87515: LD_INT 1
87517: NEG
87518: PUSH
87519: EMPTY
87520: LIST
87521: LIST
87522: PUSH
87523: EMPTY
87524: LIST
87525: LIST
87526: LIST
87527: LIST
87528: LIST
87529: LIST
87530: LIST
87531: LIST
87532: LIST
87533: LIST
87534: LIST
87535: LIST
87536: LIST
87537: LIST
87538: LIST
87539: LIST
87540: LIST
87541: LIST
87542: LIST
87543: LIST
87544: LIST
87545: LIST
87546: LIST
87547: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
87548: LD_ADDR_VAR 0 35
87552: PUSH
87553: LD_INT 0
87555: PUSH
87556: LD_INT 0
87558: PUSH
87559: EMPTY
87560: LIST
87561: LIST
87562: PUSH
87563: LD_INT 0
87565: PUSH
87566: LD_INT 1
87568: NEG
87569: PUSH
87570: EMPTY
87571: LIST
87572: LIST
87573: PUSH
87574: LD_INT 1
87576: PUSH
87577: LD_INT 0
87579: PUSH
87580: EMPTY
87581: LIST
87582: LIST
87583: PUSH
87584: LD_INT 1
87586: PUSH
87587: LD_INT 1
87589: PUSH
87590: EMPTY
87591: LIST
87592: LIST
87593: PUSH
87594: LD_INT 0
87596: PUSH
87597: LD_INT 1
87599: PUSH
87600: EMPTY
87601: LIST
87602: LIST
87603: PUSH
87604: LD_INT 1
87606: NEG
87607: PUSH
87608: LD_INT 0
87610: PUSH
87611: EMPTY
87612: LIST
87613: LIST
87614: PUSH
87615: LD_INT 1
87617: NEG
87618: PUSH
87619: LD_INT 1
87621: NEG
87622: PUSH
87623: EMPTY
87624: LIST
87625: LIST
87626: PUSH
87627: LD_INT 2
87629: PUSH
87630: LD_INT 1
87632: PUSH
87633: EMPTY
87634: LIST
87635: LIST
87636: PUSH
87637: LD_INT 2
87639: NEG
87640: PUSH
87641: LD_INT 1
87643: NEG
87644: PUSH
87645: EMPTY
87646: LIST
87647: LIST
87648: PUSH
87649: EMPTY
87650: LIST
87651: LIST
87652: LIST
87653: LIST
87654: LIST
87655: LIST
87656: LIST
87657: LIST
87658: LIST
87659: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
87660: LD_ADDR_VAR 0 36
87664: PUSH
87665: LD_INT 0
87667: PUSH
87668: LD_INT 0
87670: PUSH
87671: EMPTY
87672: LIST
87673: LIST
87674: PUSH
87675: LD_INT 0
87677: PUSH
87678: LD_INT 1
87680: NEG
87681: PUSH
87682: EMPTY
87683: LIST
87684: LIST
87685: PUSH
87686: LD_INT 1
87688: PUSH
87689: LD_INT 0
87691: PUSH
87692: EMPTY
87693: LIST
87694: LIST
87695: PUSH
87696: LD_INT 1
87698: PUSH
87699: LD_INT 1
87701: PUSH
87702: EMPTY
87703: LIST
87704: LIST
87705: PUSH
87706: LD_INT 0
87708: PUSH
87709: LD_INT 1
87711: PUSH
87712: EMPTY
87713: LIST
87714: LIST
87715: PUSH
87716: LD_INT 1
87718: NEG
87719: PUSH
87720: LD_INT 0
87722: PUSH
87723: EMPTY
87724: LIST
87725: LIST
87726: PUSH
87727: LD_INT 1
87729: NEG
87730: PUSH
87731: LD_INT 1
87733: NEG
87734: PUSH
87735: EMPTY
87736: LIST
87737: LIST
87738: PUSH
87739: LD_INT 1
87741: NEG
87742: PUSH
87743: LD_INT 2
87745: NEG
87746: PUSH
87747: EMPTY
87748: LIST
87749: LIST
87750: PUSH
87751: LD_INT 1
87753: PUSH
87754: LD_INT 2
87756: PUSH
87757: EMPTY
87758: LIST
87759: LIST
87760: PUSH
87761: EMPTY
87762: LIST
87763: LIST
87764: LIST
87765: LIST
87766: LIST
87767: LIST
87768: LIST
87769: LIST
87770: LIST
87771: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
87772: LD_ADDR_VAR 0 37
87776: PUSH
87777: LD_INT 0
87779: PUSH
87780: LD_INT 0
87782: PUSH
87783: EMPTY
87784: LIST
87785: LIST
87786: PUSH
87787: LD_INT 0
87789: PUSH
87790: LD_INT 1
87792: NEG
87793: PUSH
87794: EMPTY
87795: LIST
87796: LIST
87797: PUSH
87798: LD_INT 1
87800: PUSH
87801: LD_INT 0
87803: PUSH
87804: EMPTY
87805: LIST
87806: LIST
87807: PUSH
87808: LD_INT 1
87810: PUSH
87811: LD_INT 1
87813: PUSH
87814: EMPTY
87815: LIST
87816: LIST
87817: PUSH
87818: LD_INT 0
87820: PUSH
87821: LD_INT 1
87823: PUSH
87824: EMPTY
87825: LIST
87826: LIST
87827: PUSH
87828: LD_INT 1
87830: NEG
87831: PUSH
87832: LD_INT 0
87834: PUSH
87835: EMPTY
87836: LIST
87837: LIST
87838: PUSH
87839: LD_INT 1
87841: NEG
87842: PUSH
87843: LD_INT 1
87845: NEG
87846: PUSH
87847: EMPTY
87848: LIST
87849: LIST
87850: PUSH
87851: LD_INT 1
87853: PUSH
87854: LD_INT 1
87856: NEG
87857: PUSH
87858: EMPTY
87859: LIST
87860: LIST
87861: PUSH
87862: LD_INT 1
87864: NEG
87865: PUSH
87866: LD_INT 1
87868: PUSH
87869: EMPTY
87870: LIST
87871: LIST
87872: PUSH
87873: EMPTY
87874: LIST
87875: LIST
87876: LIST
87877: LIST
87878: LIST
87879: LIST
87880: LIST
87881: LIST
87882: LIST
87883: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
87884: LD_ADDR_VAR 0 38
87888: PUSH
87889: LD_INT 0
87891: PUSH
87892: LD_INT 0
87894: PUSH
87895: EMPTY
87896: LIST
87897: LIST
87898: PUSH
87899: LD_INT 0
87901: PUSH
87902: LD_INT 1
87904: NEG
87905: PUSH
87906: EMPTY
87907: LIST
87908: LIST
87909: PUSH
87910: LD_INT 1
87912: PUSH
87913: LD_INT 0
87915: PUSH
87916: EMPTY
87917: LIST
87918: LIST
87919: PUSH
87920: LD_INT 1
87922: PUSH
87923: LD_INT 1
87925: PUSH
87926: EMPTY
87927: LIST
87928: LIST
87929: PUSH
87930: LD_INT 0
87932: PUSH
87933: LD_INT 1
87935: PUSH
87936: EMPTY
87937: LIST
87938: LIST
87939: PUSH
87940: LD_INT 1
87942: NEG
87943: PUSH
87944: LD_INT 0
87946: PUSH
87947: EMPTY
87948: LIST
87949: LIST
87950: PUSH
87951: LD_INT 1
87953: NEG
87954: PUSH
87955: LD_INT 1
87957: NEG
87958: PUSH
87959: EMPTY
87960: LIST
87961: LIST
87962: PUSH
87963: LD_INT 2
87965: PUSH
87966: LD_INT 1
87968: PUSH
87969: EMPTY
87970: LIST
87971: LIST
87972: PUSH
87973: LD_INT 2
87975: NEG
87976: PUSH
87977: LD_INT 1
87979: NEG
87980: PUSH
87981: EMPTY
87982: LIST
87983: LIST
87984: PUSH
87985: EMPTY
87986: LIST
87987: LIST
87988: LIST
87989: LIST
87990: LIST
87991: LIST
87992: LIST
87993: LIST
87994: LIST
87995: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
87996: LD_ADDR_VAR 0 39
88000: PUSH
88001: LD_INT 0
88003: PUSH
88004: LD_INT 0
88006: PUSH
88007: EMPTY
88008: LIST
88009: LIST
88010: PUSH
88011: LD_INT 0
88013: PUSH
88014: LD_INT 1
88016: NEG
88017: PUSH
88018: EMPTY
88019: LIST
88020: LIST
88021: PUSH
88022: LD_INT 1
88024: PUSH
88025: LD_INT 0
88027: PUSH
88028: EMPTY
88029: LIST
88030: LIST
88031: PUSH
88032: LD_INT 1
88034: PUSH
88035: LD_INT 1
88037: PUSH
88038: EMPTY
88039: LIST
88040: LIST
88041: PUSH
88042: LD_INT 0
88044: PUSH
88045: LD_INT 1
88047: PUSH
88048: EMPTY
88049: LIST
88050: LIST
88051: PUSH
88052: LD_INT 1
88054: NEG
88055: PUSH
88056: LD_INT 0
88058: PUSH
88059: EMPTY
88060: LIST
88061: LIST
88062: PUSH
88063: LD_INT 1
88065: NEG
88066: PUSH
88067: LD_INT 1
88069: NEG
88070: PUSH
88071: EMPTY
88072: LIST
88073: LIST
88074: PUSH
88075: LD_INT 1
88077: NEG
88078: PUSH
88079: LD_INT 2
88081: NEG
88082: PUSH
88083: EMPTY
88084: LIST
88085: LIST
88086: PUSH
88087: LD_INT 1
88089: PUSH
88090: LD_INT 2
88092: PUSH
88093: EMPTY
88094: LIST
88095: LIST
88096: PUSH
88097: EMPTY
88098: LIST
88099: LIST
88100: LIST
88101: LIST
88102: LIST
88103: LIST
88104: LIST
88105: LIST
88106: LIST
88107: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
88108: LD_ADDR_VAR 0 40
88112: PUSH
88113: LD_INT 0
88115: PUSH
88116: LD_INT 0
88118: PUSH
88119: EMPTY
88120: LIST
88121: LIST
88122: PUSH
88123: LD_INT 0
88125: PUSH
88126: LD_INT 1
88128: NEG
88129: PUSH
88130: EMPTY
88131: LIST
88132: LIST
88133: PUSH
88134: LD_INT 1
88136: PUSH
88137: LD_INT 0
88139: PUSH
88140: EMPTY
88141: LIST
88142: LIST
88143: PUSH
88144: LD_INT 1
88146: PUSH
88147: LD_INT 1
88149: PUSH
88150: EMPTY
88151: LIST
88152: LIST
88153: PUSH
88154: LD_INT 0
88156: PUSH
88157: LD_INT 1
88159: PUSH
88160: EMPTY
88161: LIST
88162: LIST
88163: PUSH
88164: LD_INT 1
88166: NEG
88167: PUSH
88168: LD_INT 0
88170: PUSH
88171: EMPTY
88172: LIST
88173: LIST
88174: PUSH
88175: LD_INT 1
88177: NEG
88178: PUSH
88179: LD_INT 1
88181: NEG
88182: PUSH
88183: EMPTY
88184: LIST
88185: LIST
88186: PUSH
88187: LD_INT 1
88189: PUSH
88190: LD_INT 1
88192: NEG
88193: PUSH
88194: EMPTY
88195: LIST
88196: LIST
88197: PUSH
88198: LD_INT 1
88200: NEG
88201: PUSH
88202: LD_INT 1
88204: PUSH
88205: EMPTY
88206: LIST
88207: LIST
88208: PUSH
88209: EMPTY
88210: LIST
88211: LIST
88212: LIST
88213: LIST
88214: LIST
88215: LIST
88216: LIST
88217: LIST
88218: LIST
88219: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88220: LD_ADDR_VAR 0 41
88224: PUSH
88225: LD_INT 0
88227: PUSH
88228: LD_INT 0
88230: PUSH
88231: EMPTY
88232: LIST
88233: LIST
88234: PUSH
88235: LD_INT 0
88237: PUSH
88238: LD_INT 1
88240: NEG
88241: PUSH
88242: EMPTY
88243: LIST
88244: LIST
88245: PUSH
88246: LD_INT 1
88248: PUSH
88249: LD_INT 0
88251: PUSH
88252: EMPTY
88253: LIST
88254: LIST
88255: PUSH
88256: LD_INT 1
88258: PUSH
88259: LD_INT 1
88261: PUSH
88262: EMPTY
88263: LIST
88264: LIST
88265: PUSH
88266: LD_INT 0
88268: PUSH
88269: LD_INT 1
88271: PUSH
88272: EMPTY
88273: LIST
88274: LIST
88275: PUSH
88276: LD_INT 1
88278: NEG
88279: PUSH
88280: LD_INT 0
88282: PUSH
88283: EMPTY
88284: LIST
88285: LIST
88286: PUSH
88287: LD_INT 1
88289: NEG
88290: PUSH
88291: LD_INT 1
88293: NEG
88294: PUSH
88295: EMPTY
88296: LIST
88297: LIST
88298: PUSH
88299: LD_INT 1
88301: NEG
88302: PUSH
88303: LD_INT 2
88305: NEG
88306: PUSH
88307: EMPTY
88308: LIST
88309: LIST
88310: PUSH
88311: LD_INT 1
88313: PUSH
88314: LD_INT 1
88316: NEG
88317: PUSH
88318: EMPTY
88319: LIST
88320: LIST
88321: PUSH
88322: LD_INT 2
88324: PUSH
88325: LD_INT 0
88327: PUSH
88328: EMPTY
88329: LIST
88330: LIST
88331: PUSH
88332: LD_INT 2
88334: PUSH
88335: LD_INT 1
88337: PUSH
88338: EMPTY
88339: LIST
88340: LIST
88341: PUSH
88342: LD_INT 2
88344: PUSH
88345: LD_INT 2
88347: PUSH
88348: EMPTY
88349: LIST
88350: LIST
88351: PUSH
88352: LD_INT 1
88354: PUSH
88355: LD_INT 2
88357: PUSH
88358: EMPTY
88359: LIST
88360: LIST
88361: PUSH
88362: LD_INT 1
88364: NEG
88365: PUSH
88366: LD_INT 1
88368: PUSH
88369: EMPTY
88370: LIST
88371: LIST
88372: PUSH
88373: LD_INT 2
88375: NEG
88376: PUSH
88377: LD_INT 0
88379: PUSH
88380: EMPTY
88381: LIST
88382: LIST
88383: PUSH
88384: LD_INT 2
88386: NEG
88387: PUSH
88388: LD_INT 1
88390: NEG
88391: PUSH
88392: EMPTY
88393: LIST
88394: LIST
88395: PUSH
88396: LD_INT 2
88398: NEG
88399: PUSH
88400: LD_INT 2
88402: NEG
88403: PUSH
88404: EMPTY
88405: LIST
88406: LIST
88407: PUSH
88408: LD_INT 2
88410: NEG
88411: PUSH
88412: LD_INT 3
88414: NEG
88415: PUSH
88416: EMPTY
88417: LIST
88418: LIST
88419: PUSH
88420: LD_INT 2
88422: PUSH
88423: LD_INT 1
88425: NEG
88426: PUSH
88427: EMPTY
88428: LIST
88429: LIST
88430: PUSH
88431: LD_INT 3
88433: PUSH
88434: LD_INT 0
88436: PUSH
88437: EMPTY
88438: LIST
88439: LIST
88440: PUSH
88441: LD_INT 3
88443: PUSH
88444: LD_INT 1
88446: PUSH
88447: EMPTY
88448: LIST
88449: LIST
88450: PUSH
88451: LD_INT 3
88453: PUSH
88454: LD_INT 2
88456: PUSH
88457: EMPTY
88458: LIST
88459: LIST
88460: PUSH
88461: LD_INT 3
88463: PUSH
88464: LD_INT 3
88466: PUSH
88467: EMPTY
88468: LIST
88469: LIST
88470: PUSH
88471: LD_INT 2
88473: PUSH
88474: LD_INT 3
88476: PUSH
88477: EMPTY
88478: LIST
88479: LIST
88480: PUSH
88481: LD_INT 2
88483: NEG
88484: PUSH
88485: LD_INT 1
88487: PUSH
88488: EMPTY
88489: LIST
88490: LIST
88491: PUSH
88492: LD_INT 3
88494: NEG
88495: PUSH
88496: LD_INT 0
88498: PUSH
88499: EMPTY
88500: LIST
88501: LIST
88502: PUSH
88503: LD_INT 3
88505: NEG
88506: PUSH
88507: LD_INT 1
88509: NEG
88510: PUSH
88511: EMPTY
88512: LIST
88513: LIST
88514: PUSH
88515: LD_INT 3
88517: NEG
88518: PUSH
88519: LD_INT 2
88521: NEG
88522: PUSH
88523: EMPTY
88524: LIST
88525: LIST
88526: PUSH
88527: LD_INT 3
88529: NEG
88530: PUSH
88531: LD_INT 3
88533: NEG
88534: PUSH
88535: EMPTY
88536: LIST
88537: LIST
88538: PUSH
88539: EMPTY
88540: LIST
88541: LIST
88542: LIST
88543: LIST
88544: LIST
88545: LIST
88546: LIST
88547: LIST
88548: LIST
88549: LIST
88550: LIST
88551: LIST
88552: LIST
88553: LIST
88554: LIST
88555: LIST
88556: LIST
88557: LIST
88558: LIST
88559: LIST
88560: LIST
88561: LIST
88562: LIST
88563: LIST
88564: LIST
88565: LIST
88566: LIST
88567: LIST
88568: LIST
88569: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88570: LD_ADDR_VAR 0 42
88574: PUSH
88575: LD_INT 0
88577: PUSH
88578: LD_INT 0
88580: PUSH
88581: EMPTY
88582: LIST
88583: LIST
88584: PUSH
88585: LD_INT 0
88587: PUSH
88588: LD_INT 1
88590: NEG
88591: PUSH
88592: EMPTY
88593: LIST
88594: LIST
88595: PUSH
88596: LD_INT 1
88598: PUSH
88599: LD_INT 0
88601: PUSH
88602: EMPTY
88603: LIST
88604: LIST
88605: PUSH
88606: LD_INT 1
88608: PUSH
88609: LD_INT 1
88611: PUSH
88612: EMPTY
88613: LIST
88614: LIST
88615: PUSH
88616: LD_INT 0
88618: PUSH
88619: LD_INT 1
88621: PUSH
88622: EMPTY
88623: LIST
88624: LIST
88625: PUSH
88626: LD_INT 1
88628: NEG
88629: PUSH
88630: LD_INT 0
88632: PUSH
88633: EMPTY
88634: LIST
88635: LIST
88636: PUSH
88637: LD_INT 1
88639: NEG
88640: PUSH
88641: LD_INT 1
88643: NEG
88644: PUSH
88645: EMPTY
88646: LIST
88647: LIST
88648: PUSH
88649: LD_INT 1
88651: NEG
88652: PUSH
88653: LD_INT 2
88655: NEG
88656: PUSH
88657: EMPTY
88658: LIST
88659: LIST
88660: PUSH
88661: LD_INT 0
88663: PUSH
88664: LD_INT 2
88666: NEG
88667: PUSH
88668: EMPTY
88669: LIST
88670: LIST
88671: PUSH
88672: LD_INT 1
88674: PUSH
88675: LD_INT 1
88677: NEG
88678: PUSH
88679: EMPTY
88680: LIST
88681: LIST
88682: PUSH
88683: LD_INT 2
88685: PUSH
88686: LD_INT 1
88688: PUSH
88689: EMPTY
88690: LIST
88691: LIST
88692: PUSH
88693: LD_INT 2
88695: PUSH
88696: LD_INT 2
88698: PUSH
88699: EMPTY
88700: LIST
88701: LIST
88702: PUSH
88703: LD_INT 1
88705: PUSH
88706: LD_INT 2
88708: PUSH
88709: EMPTY
88710: LIST
88711: LIST
88712: PUSH
88713: LD_INT 0
88715: PUSH
88716: LD_INT 2
88718: PUSH
88719: EMPTY
88720: LIST
88721: LIST
88722: PUSH
88723: LD_INT 1
88725: NEG
88726: PUSH
88727: LD_INT 1
88729: PUSH
88730: EMPTY
88731: LIST
88732: LIST
88733: PUSH
88734: LD_INT 2
88736: NEG
88737: PUSH
88738: LD_INT 1
88740: NEG
88741: PUSH
88742: EMPTY
88743: LIST
88744: LIST
88745: PUSH
88746: LD_INT 2
88748: NEG
88749: PUSH
88750: LD_INT 2
88752: NEG
88753: PUSH
88754: EMPTY
88755: LIST
88756: LIST
88757: PUSH
88758: LD_INT 2
88760: NEG
88761: PUSH
88762: LD_INT 3
88764: NEG
88765: PUSH
88766: EMPTY
88767: LIST
88768: LIST
88769: PUSH
88770: LD_INT 1
88772: NEG
88773: PUSH
88774: LD_INT 3
88776: NEG
88777: PUSH
88778: EMPTY
88779: LIST
88780: LIST
88781: PUSH
88782: LD_INT 0
88784: PUSH
88785: LD_INT 3
88787: NEG
88788: PUSH
88789: EMPTY
88790: LIST
88791: LIST
88792: PUSH
88793: LD_INT 1
88795: PUSH
88796: LD_INT 2
88798: NEG
88799: PUSH
88800: EMPTY
88801: LIST
88802: LIST
88803: PUSH
88804: LD_INT 3
88806: PUSH
88807: LD_INT 2
88809: PUSH
88810: EMPTY
88811: LIST
88812: LIST
88813: PUSH
88814: LD_INT 3
88816: PUSH
88817: LD_INT 3
88819: PUSH
88820: EMPTY
88821: LIST
88822: LIST
88823: PUSH
88824: LD_INT 2
88826: PUSH
88827: LD_INT 3
88829: PUSH
88830: EMPTY
88831: LIST
88832: LIST
88833: PUSH
88834: LD_INT 1
88836: PUSH
88837: LD_INT 3
88839: PUSH
88840: EMPTY
88841: LIST
88842: LIST
88843: PUSH
88844: LD_INT 0
88846: PUSH
88847: LD_INT 3
88849: PUSH
88850: EMPTY
88851: LIST
88852: LIST
88853: PUSH
88854: LD_INT 1
88856: NEG
88857: PUSH
88858: LD_INT 2
88860: PUSH
88861: EMPTY
88862: LIST
88863: LIST
88864: PUSH
88865: LD_INT 3
88867: NEG
88868: PUSH
88869: LD_INT 2
88871: NEG
88872: PUSH
88873: EMPTY
88874: LIST
88875: LIST
88876: PUSH
88877: LD_INT 3
88879: NEG
88880: PUSH
88881: LD_INT 3
88883: NEG
88884: PUSH
88885: EMPTY
88886: LIST
88887: LIST
88888: PUSH
88889: EMPTY
88890: LIST
88891: LIST
88892: LIST
88893: LIST
88894: LIST
88895: LIST
88896: LIST
88897: LIST
88898: LIST
88899: LIST
88900: LIST
88901: LIST
88902: LIST
88903: LIST
88904: LIST
88905: LIST
88906: LIST
88907: LIST
88908: LIST
88909: LIST
88910: LIST
88911: LIST
88912: LIST
88913: LIST
88914: LIST
88915: LIST
88916: LIST
88917: LIST
88918: LIST
88919: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88920: LD_ADDR_VAR 0 43
88924: PUSH
88925: LD_INT 0
88927: PUSH
88928: LD_INT 0
88930: PUSH
88931: EMPTY
88932: LIST
88933: LIST
88934: PUSH
88935: LD_INT 0
88937: PUSH
88938: LD_INT 1
88940: NEG
88941: PUSH
88942: EMPTY
88943: LIST
88944: LIST
88945: PUSH
88946: LD_INT 1
88948: PUSH
88949: LD_INT 0
88951: PUSH
88952: EMPTY
88953: LIST
88954: LIST
88955: PUSH
88956: LD_INT 1
88958: PUSH
88959: LD_INT 1
88961: PUSH
88962: EMPTY
88963: LIST
88964: LIST
88965: PUSH
88966: LD_INT 0
88968: PUSH
88969: LD_INT 1
88971: PUSH
88972: EMPTY
88973: LIST
88974: LIST
88975: PUSH
88976: LD_INT 1
88978: NEG
88979: PUSH
88980: LD_INT 0
88982: PUSH
88983: EMPTY
88984: LIST
88985: LIST
88986: PUSH
88987: LD_INT 1
88989: NEG
88990: PUSH
88991: LD_INT 1
88993: NEG
88994: PUSH
88995: EMPTY
88996: LIST
88997: LIST
88998: PUSH
88999: LD_INT 1
89001: NEG
89002: PUSH
89003: LD_INT 2
89005: NEG
89006: PUSH
89007: EMPTY
89008: LIST
89009: LIST
89010: PUSH
89011: LD_INT 0
89013: PUSH
89014: LD_INT 2
89016: NEG
89017: PUSH
89018: EMPTY
89019: LIST
89020: LIST
89021: PUSH
89022: LD_INT 1
89024: PUSH
89025: LD_INT 1
89027: NEG
89028: PUSH
89029: EMPTY
89030: LIST
89031: LIST
89032: PUSH
89033: LD_INT 2
89035: PUSH
89036: LD_INT 0
89038: PUSH
89039: EMPTY
89040: LIST
89041: LIST
89042: PUSH
89043: LD_INT 2
89045: PUSH
89046: LD_INT 1
89048: PUSH
89049: EMPTY
89050: LIST
89051: LIST
89052: PUSH
89053: LD_INT 1
89055: PUSH
89056: LD_INT 2
89058: PUSH
89059: EMPTY
89060: LIST
89061: LIST
89062: PUSH
89063: LD_INT 0
89065: PUSH
89066: LD_INT 2
89068: PUSH
89069: EMPTY
89070: LIST
89071: LIST
89072: PUSH
89073: LD_INT 1
89075: NEG
89076: PUSH
89077: LD_INT 1
89079: PUSH
89080: EMPTY
89081: LIST
89082: LIST
89083: PUSH
89084: LD_INT 2
89086: NEG
89087: PUSH
89088: LD_INT 0
89090: PUSH
89091: EMPTY
89092: LIST
89093: LIST
89094: PUSH
89095: LD_INT 2
89097: NEG
89098: PUSH
89099: LD_INT 1
89101: NEG
89102: PUSH
89103: EMPTY
89104: LIST
89105: LIST
89106: PUSH
89107: LD_INT 1
89109: NEG
89110: PUSH
89111: LD_INT 3
89113: NEG
89114: PUSH
89115: EMPTY
89116: LIST
89117: LIST
89118: PUSH
89119: LD_INT 0
89121: PUSH
89122: LD_INT 3
89124: NEG
89125: PUSH
89126: EMPTY
89127: LIST
89128: LIST
89129: PUSH
89130: LD_INT 1
89132: PUSH
89133: LD_INT 2
89135: NEG
89136: PUSH
89137: EMPTY
89138: LIST
89139: LIST
89140: PUSH
89141: LD_INT 2
89143: PUSH
89144: LD_INT 1
89146: NEG
89147: PUSH
89148: EMPTY
89149: LIST
89150: LIST
89151: PUSH
89152: LD_INT 3
89154: PUSH
89155: LD_INT 0
89157: PUSH
89158: EMPTY
89159: LIST
89160: LIST
89161: PUSH
89162: LD_INT 3
89164: PUSH
89165: LD_INT 1
89167: PUSH
89168: EMPTY
89169: LIST
89170: LIST
89171: PUSH
89172: LD_INT 1
89174: PUSH
89175: LD_INT 3
89177: PUSH
89178: EMPTY
89179: LIST
89180: LIST
89181: PUSH
89182: LD_INT 0
89184: PUSH
89185: LD_INT 3
89187: PUSH
89188: EMPTY
89189: LIST
89190: LIST
89191: PUSH
89192: LD_INT 1
89194: NEG
89195: PUSH
89196: LD_INT 2
89198: PUSH
89199: EMPTY
89200: LIST
89201: LIST
89202: PUSH
89203: LD_INT 2
89205: NEG
89206: PUSH
89207: LD_INT 1
89209: PUSH
89210: EMPTY
89211: LIST
89212: LIST
89213: PUSH
89214: LD_INT 3
89216: NEG
89217: PUSH
89218: LD_INT 0
89220: PUSH
89221: EMPTY
89222: LIST
89223: LIST
89224: PUSH
89225: LD_INT 3
89227: NEG
89228: PUSH
89229: LD_INT 1
89231: NEG
89232: PUSH
89233: EMPTY
89234: LIST
89235: LIST
89236: PUSH
89237: EMPTY
89238: LIST
89239: LIST
89240: LIST
89241: LIST
89242: LIST
89243: LIST
89244: LIST
89245: LIST
89246: LIST
89247: LIST
89248: LIST
89249: LIST
89250: LIST
89251: LIST
89252: LIST
89253: LIST
89254: LIST
89255: LIST
89256: LIST
89257: LIST
89258: LIST
89259: LIST
89260: LIST
89261: LIST
89262: LIST
89263: LIST
89264: LIST
89265: LIST
89266: LIST
89267: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89268: LD_ADDR_VAR 0 44
89272: PUSH
89273: LD_INT 0
89275: PUSH
89276: LD_INT 0
89278: PUSH
89279: EMPTY
89280: LIST
89281: LIST
89282: PUSH
89283: LD_INT 0
89285: PUSH
89286: LD_INT 1
89288: NEG
89289: PUSH
89290: EMPTY
89291: LIST
89292: LIST
89293: PUSH
89294: LD_INT 1
89296: PUSH
89297: LD_INT 0
89299: PUSH
89300: EMPTY
89301: LIST
89302: LIST
89303: PUSH
89304: LD_INT 1
89306: PUSH
89307: LD_INT 1
89309: PUSH
89310: EMPTY
89311: LIST
89312: LIST
89313: PUSH
89314: LD_INT 0
89316: PUSH
89317: LD_INT 1
89319: PUSH
89320: EMPTY
89321: LIST
89322: LIST
89323: PUSH
89324: LD_INT 1
89326: NEG
89327: PUSH
89328: LD_INT 0
89330: PUSH
89331: EMPTY
89332: LIST
89333: LIST
89334: PUSH
89335: LD_INT 1
89337: NEG
89338: PUSH
89339: LD_INT 1
89341: NEG
89342: PUSH
89343: EMPTY
89344: LIST
89345: LIST
89346: PUSH
89347: LD_INT 1
89349: NEG
89350: PUSH
89351: LD_INT 2
89353: NEG
89354: PUSH
89355: EMPTY
89356: LIST
89357: LIST
89358: PUSH
89359: LD_INT 1
89361: PUSH
89362: LD_INT 1
89364: NEG
89365: PUSH
89366: EMPTY
89367: LIST
89368: LIST
89369: PUSH
89370: LD_INT 2
89372: PUSH
89373: LD_INT 0
89375: PUSH
89376: EMPTY
89377: LIST
89378: LIST
89379: PUSH
89380: LD_INT 2
89382: PUSH
89383: LD_INT 1
89385: PUSH
89386: EMPTY
89387: LIST
89388: LIST
89389: PUSH
89390: LD_INT 2
89392: PUSH
89393: LD_INT 2
89395: PUSH
89396: EMPTY
89397: LIST
89398: LIST
89399: PUSH
89400: LD_INT 1
89402: PUSH
89403: LD_INT 2
89405: PUSH
89406: EMPTY
89407: LIST
89408: LIST
89409: PUSH
89410: LD_INT 1
89412: NEG
89413: PUSH
89414: LD_INT 1
89416: PUSH
89417: EMPTY
89418: LIST
89419: LIST
89420: PUSH
89421: LD_INT 2
89423: NEG
89424: PUSH
89425: LD_INT 0
89427: PUSH
89428: EMPTY
89429: LIST
89430: LIST
89431: PUSH
89432: LD_INT 2
89434: NEG
89435: PUSH
89436: LD_INT 1
89438: NEG
89439: PUSH
89440: EMPTY
89441: LIST
89442: LIST
89443: PUSH
89444: LD_INT 2
89446: NEG
89447: PUSH
89448: LD_INT 2
89450: NEG
89451: PUSH
89452: EMPTY
89453: LIST
89454: LIST
89455: PUSH
89456: LD_INT 2
89458: NEG
89459: PUSH
89460: LD_INT 3
89462: NEG
89463: PUSH
89464: EMPTY
89465: LIST
89466: LIST
89467: PUSH
89468: LD_INT 2
89470: PUSH
89471: LD_INT 1
89473: NEG
89474: PUSH
89475: EMPTY
89476: LIST
89477: LIST
89478: PUSH
89479: LD_INT 3
89481: PUSH
89482: LD_INT 0
89484: PUSH
89485: EMPTY
89486: LIST
89487: LIST
89488: PUSH
89489: LD_INT 3
89491: PUSH
89492: LD_INT 1
89494: PUSH
89495: EMPTY
89496: LIST
89497: LIST
89498: PUSH
89499: LD_INT 3
89501: PUSH
89502: LD_INT 2
89504: PUSH
89505: EMPTY
89506: LIST
89507: LIST
89508: PUSH
89509: LD_INT 3
89511: PUSH
89512: LD_INT 3
89514: PUSH
89515: EMPTY
89516: LIST
89517: LIST
89518: PUSH
89519: LD_INT 2
89521: PUSH
89522: LD_INT 3
89524: PUSH
89525: EMPTY
89526: LIST
89527: LIST
89528: PUSH
89529: LD_INT 2
89531: NEG
89532: PUSH
89533: LD_INT 1
89535: PUSH
89536: EMPTY
89537: LIST
89538: LIST
89539: PUSH
89540: LD_INT 3
89542: NEG
89543: PUSH
89544: LD_INT 0
89546: PUSH
89547: EMPTY
89548: LIST
89549: LIST
89550: PUSH
89551: LD_INT 3
89553: NEG
89554: PUSH
89555: LD_INT 1
89557: NEG
89558: PUSH
89559: EMPTY
89560: LIST
89561: LIST
89562: PUSH
89563: LD_INT 3
89565: NEG
89566: PUSH
89567: LD_INT 2
89569: NEG
89570: PUSH
89571: EMPTY
89572: LIST
89573: LIST
89574: PUSH
89575: LD_INT 3
89577: NEG
89578: PUSH
89579: LD_INT 3
89581: NEG
89582: PUSH
89583: EMPTY
89584: LIST
89585: LIST
89586: PUSH
89587: EMPTY
89588: LIST
89589: LIST
89590: LIST
89591: LIST
89592: LIST
89593: LIST
89594: LIST
89595: LIST
89596: LIST
89597: LIST
89598: LIST
89599: LIST
89600: LIST
89601: LIST
89602: LIST
89603: LIST
89604: LIST
89605: LIST
89606: LIST
89607: LIST
89608: LIST
89609: LIST
89610: LIST
89611: LIST
89612: LIST
89613: LIST
89614: LIST
89615: LIST
89616: LIST
89617: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89618: LD_ADDR_VAR 0 45
89622: PUSH
89623: LD_INT 0
89625: PUSH
89626: LD_INT 0
89628: PUSH
89629: EMPTY
89630: LIST
89631: LIST
89632: PUSH
89633: LD_INT 0
89635: PUSH
89636: LD_INT 1
89638: NEG
89639: PUSH
89640: EMPTY
89641: LIST
89642: LIST
89643: PUSH
89644: LD_INT 1
89646: PUSH
89647: LD_INT 0
89649: PUSH
89650: EMPTY
89651: LIST
89652: LIST
89653: PUSH
89654: LD_INT 1
89656: PUSH
89657: LD_INT 1
89659: PUSH
89660: EMPTY
89661: LIST
89662: LIST
89663: PUSH
89664: LD_INT 0
89666: PUSH
89667: LD_INT 1
89669: PUSH
89670: EMPTY
89671: LIST
89672: LIST
89673: PUSH
89674: LD_INT 1
89676: NEG
89677: PUSH
89678: LD_INT 0
89680: PUSH
89681: EMPTY
89682: LIST
89683: LIST
89684: PUSH
89685: LD_INT 1
89687: NEG
89688: PUSH
89689: LD_INT 1
89691: NEG
89692: PUSH
89693: EMPTY
89694: LIST
89695: LIST
89696: PUSH
89697: LD_INT 1
89699: NEG
89700: PUSH
89701: LD_INT 2
89703: NEG
89704: PUSH
89705: EMPTY
89706: LIST
89707: LIST
89708: PUSH
89709: LD_INT 0
89711: PUSH
89712: LD_INT 2
89714: NEG
89715: PUSH
89716: EMPTY
89717: LIST
89718: LIST
89719: PUSH
89720: LD_INT 1
89722: PUSH
89723: LD_INT 1
89725: NEG
89726: PUSH
89727: EMPTY
89728: LIST
89729: LIST
89730: PUSH
89731: LD_INT 2
89733: PUSH
89734: LD_INT 1
89736: PUSH
89737: EMPTY
89738: LIST
89739: LIST
89740: PUSH
89741: LD_INT 2
89743: PUSH
89744: LD_INT 2
89746: PUSH
89747: EMPTY
89748: LIST
89749: LIST
89750: PUSH
89751: LD_INT 1
89753: PUSH
89754: LD_INT 2
89756: PUSH
89757: EMPTY
89758: LIST
89759: LIST
89760: PUSH
89761: LD_INT 0
89763: PUSH
89764: LD_INT 2
89766: PUSH
89767: EMPTY
89768: LIST
89769: LIST
89770: PUSH
89771: LD_INT 1
89773: NEG
89774: PUSH
89775: LD_INT 1
89777: PUSH
89778: EMPTY
89779: LIST
89780: LIST
89781: PUSH
89782: LD_INT 2
89784: NEG
89785: PUSH
89786: LD_INT 1
89788: NEG
89789: PUSH
89790: EMPTY
89791: LIST
89792: LIST
89793: PUSH
89794: LD_INT 2
89796: NEG
89797: PUSH
89798: LD_INT 2
89800: NEG
89801: PUSH
89802: EMPTY
89803: LIST
89804: LIST
89805: PUSH
89806: LD_INT 2
89808: NEG
89809: PUSH
89810: LD_INT 3
89812: NEG
89813: PUSH
89814: EMPTY
89815: LIST
89816: LIST
89817: PUSH
89818: LD_INT 1
89820: NEG
89821: PUSH
89822: LD_INT 3
89824: NEG
89825: PUSH
89826: EMPTY
89827: LIST
89828: LIST
89829: PUSH
89830: LD_INT 0
89832: PUSH
89833: LD_INT 3
89835: NEG
89836: PUSH
89837: EMPTY
89838: LIST
89839: LIST
89840: PUSH
89841: LD_INT 1
89843: PUSH
89844: LD_INT 2
89846: NEG
89847: PUSH
89848: EMPTY
89849: LIST
89850: LIST
89851: PUSH
89852: LD_INT 3
89854: PUSH
89855: LD_INT 2
89857: PUSH
89858: EMPTY
89859: LIST
89860: LIST
89861: PUSH
89862: LD_INT 3
89864: PUSH
89865: LD_INT 3
89867: PUSH
89868: EMPTY
89869: LIST
89870: LIST
89871: PUSH
89872: LD_INT 2
89874: PUSH
89875: LD_INT 3
89877: PUSH
89878: EMPTY
89879: LIST
89880: LIST
89881: PUSH
89882: LD_INT 1
89884: PUSH
89885: LD_INT 3
89887: PUSH
89888: EMPTY
89889: LIST
89890: LIST
89891: PUSH
89892: LD_INT 0
89894: PUSH
89895: LD_INT 3
89897: PUSH
89898: EMPTY
89899: LIST
89900: LIST
89901: PUSH
89902: LD_INT 1
89904: NEG
89905: PUSH
89906: LD_INT 2
89908: PUSH
89909: EMPTY
89910: LIST
89911: LIST
89912: PUSH
89913: LD_INT 3
89915: NEG
89916: PUSH
89917: LD_INT 2
89919: NEG
89920: PUSH
89921: EMPTY
89922: LIST
89923: LIST
89924: PUSH
89925: LD_INT 3
89927: NEG
89928: PUSH
89929: LD_INT 3
89931: NEG
89932: PUSH
89933: EMPTY
89934: LIST
89935: LIST
89936: PUSH
89937: EMPTY
89938: LIST
89939: LIST
89940: LIST
89941: LIST
89942: LIST
89943: LIST
89944: LIST
89945: LIST
89946: LIST
89947: LIST
89948: LIST
89949: LIST
89950: LIST
89951: LIST
89952: LIST
89953: LIST
89954: LIST
89955: LIST
89956: LIST
89957: LIST
89958: LIST
89959: LIST
89960: LIST
89961: LIST
89962: LIST
89963: LIST
89964: LIST
89965: LIST
89966: LIST
89967: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89968: LD_ADDR_VAR 0 46
89972: PUSH
89973: LD_INT 0
89975: PUSH
89976: LD_INT 0
89978: PUSH
89979: EMPTY
89980: LIST
89981: LIST
89982: PUSH
89983: LD_INT 0
89985: PUSH
89986: LD_INT 1
89988: NEG
89989: PUSH
89990: EMPTY
89991: LIST
89992: LIST
89993: PUSH
89994: LD_INT 1
89996: PUSH
89997: LD_INT 0
89999: PUSH
90000: EMPTY
90001: LIST
90002: LIST
90003: PUSH
90004: LD_INT 1
90006: PUSH
90007: LD_INT 1
90009: PUSH
90010: EMPTY
90011: LIST
90012: LIST
90013: PUSH
90014: LD_INT 0
90016: PUSH
90017: LD_INT 1
90019: PUSH
90020: EMPTY
90021: LIST
90022: LIST
90023: PUSH
90024: LD_INT 1
90026: NEG
90027: PUSH
90028: LD_INT 0
90030: PUSH
90031: EMPTY
90032: LIST
90033: LIST
90034: PUSH
90035: LD_INT 1
90037: NEG
90038: PUSH
90039: LD_INT 1
90041: NEG
90042: PUSH
90043: EMPTY
90044: LIST
90045: LIST
90046: PUSH
90047: LD_INT 1
90049: NEG
90050: PUSH
90051: LD_INT 2
90053: NEG
90054: PUSH
90055: EMPTY
90056: LIST
90057: LIST
90058: PUSH
90059: LD_INT 0
90061: PUSH
90062: LD_INT 2
90064: NEG
90065: PUSH
90066: EMPTY
90067: LIST
90068: LIST
90069: PUSH
90070: LD_INT 1
90072: PUSH
90073: LD_INT 1
90075: NEG
90076: PUSH
90077: EMPTY
90078: LIST
90079: LIST
90080: PUSH
90081: LD_INT 2
90083: PUSH
90084: LD_INT 0
90086: PUSH
90087: EMPTY
90088: LIST
90089: LIST
90090: PUSH
90091: LD_INT 2
90093: PUSH
90094: LD_INT 1
90096: PUSH
90097: EMPTY
90098: LIST
90099: LIST
90100: PUSH
90101: LD_INT 1
90103: PUSH
90104: LD_INT 2
90106: PUSH
90107: EMPTY
90108: LIST
90109: LIST
90110: PUSH
90111: LD_INT 0
90113: PUSH
90114: LD_INT 2
90116: PUSH
90117: EMPTY
90118: LIST
90119: LIST
90120: PUSH
90121: LD_INT 1
90123: NEG
90124: PUSH
90125: LD_INT 1
90127: PUSH
90128: EMPTY
90129: LIST
90130: LIST
90131: PUSH
90132: LD_INT 2
90134: NEG
90135: PUSH
90136: LD_INT 0
90138: PUSH
90139: EMPTY
90140: LIST
90141: LIST
90142: PUSH
90143: LD_INT 2
90145: NEG
90146: PUSH
90147: LD_INT 1
90149: NEG
90150: PUSH
90151: EMPTY
90152: LIST
90153: LIST
90154: PUSH
90155: LD_INT 1
90157: NEG
90158: PUSH
90159: LD_INT 3
90161: NEG
90162: PUSH
90163: EMPTY
90164: LIST
90165: LIST
90166: PUSH
90167: LD_INT 0
90169: PUSH
90170: LD_INT 3
90172: NEG
90173: PUSH
90174: EMPTY
90175: LIST
90176: LIST
90177: PUSH
90178: LD_INT 1
90180: PUSH
90181: LD_INT 2
90183: NEG
90184: PUSH
90185: EMPTY
90186: LIST
90187: LIST
90188: PUSH
90189: LD_INT 2
90191: PUSH
90192: LD_INT 1
90194: NEG
90195: PUSH
90196: EMPTY
90197: LIST
90198: LIST
90199: PUSH
90200: LD_INT 3
90202: PUSH
90203: LD_INT 0
90205: PUSH
90206: EMPTY
90207: LIST
90208: LIST
90209: PUSH
90210: LD_INT 3
90212: PUSH
90213: LD_INT 1
90215: PUSH
90216: EMPTY
90217: LIST
90218: LIST
90219: PUSH
90220: LD_INT 1
90222: PUSH
90223: LD_INT 3
90225: PUSH
90226: EMPTY
90227: LIST
90228: LIST
90229: PUSH
90230: LD_INT 0
90232: PUSH
90233: LD_INT 3
90235: PUSH
90236: EMPTY
90237: LIST
90238: LIST
90239: PUSH
90240: LD_INT 1
90242: NEG
90243: PUSH
90244: LD_INT 2
90246: PUSH
90247: EMPTY
90248: LIST
90249: LIST
90250: PUSH
90251: LD_INT 2
90253: NEG
90254: PUSH
90255: LD_INT 1
90257: PUSH
90258: EMPTY
90259: LIST
90260: LIST
90261: PUSH
90262: LD_INT 3
90264: NEG
90265: PUSH
90266: LD_INT 0
90268: PUSH
90269: EMPTY
90270: LIST
90271: LIST
90272: PUSH
90273: LD_INT 3
90275: NEG
90276: PUSH
90277: LD_INT 1
90279: NEG
90280: PUSH
90281: EMPTY
90282: LIST
90283: LIST
90284: PUSH
90285: EMPTY
90286: LIST
90287: LIST
90288: LIST
90289: LIST
90290: LIST
90291: LIST
90292: LIST
90293: LIST
90294: LIST
90295: LIST
90296: LIST
90297: LIST
90298: LIST
90299: LIST
90300: LIST
90301: LIST
90302: LIST
90303: LIST
90304: LIST
90305: LIST
90306: LIST
90307: LIST
90308: LIST
90309: LIST
90310: LIST
90311: LIST
90312: LIST
90313: LIST
90314: LIST
90315: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90316: LD_ADDR_VAR 0 47
90320: PUSH
90321: LD_INT 0
90323: PUSH
90324: LD_INT 0
90326: PUSH
90327: EMPTY
90328: LIST
90329: LIST
90330: PUSH
90331: LD_INT 0
90333: PUSH
90334: LD_INT 1
90336: NEG
90337: PUSH
90338: EMPTY
90339: LIST
90340: LIST
90341: PUSH
90342: LD_INT 1
90344: PUSH
90345: LD_INT 0
90347: PUSH
90348: EMPTY
90349: LIST
90350: LIST
90351: PUSH
90352: LD_INT 1
90354: PUSH
90355: LD_INT 1
90357: PUSH
90358: EMPTY
90359: LIST
90360: LIST
90361: PUSH
90362: LD_INT 0
90364: PUSH
90365: LD_INT 1
90367: PUSH
90368: EMPTY
90369: LIST
90370: LIST
90371: PUSH
90372: LD_INT 1
90374: NEG
90375: PUSH
90376: LD_INT 0
90378: PUSH
90379: EMPTY
90380: LIST
90381: LIST
90382: PUSH
90383: LD_INT 1
90385: NEG
90386: PUSH
90387: LD_INT 1
90389: NEG
90390: PUSH
90391: EMPTY
90392: LIST
90393: LIST
90394: PUSH
90395: LD_INT 1
90397: NEG
90398: PUSH
90399: LD_INT 2
90401: NEG
90402: PUSH
90403: EMPTY
90404: LIST
90405: LIST
90406: PUSH
90407: LD_INT 0
90409: PUSH
90410: LD_INT 2
90412: NEG
90413: PUSH
90414: EMPTY
90415: LIST
90416: LIST
90417: PUSH
90418: LD_INT 1
90420: PUSH
90421: LD_INT 1
90423: NEG
90424: PUSH
90425: EMPTY
90426: LIST
90427: LIST
90428: PUSH
90429: LD_INT 2
90431: NEG
90432: PUSH
90433: LD_INT 1
90435: NEG
90436: PUSH
90437: EMPTY
90438: LIST
90439: LIST
90440: PUSH
90441: LD_INT 2
90443: NEG
90444: PUSH
90445: LD_INT 2
90447: NEG
90448: PUSH
90449: EMPTY
90450: LIST
90451: LIST
90452: PUSH
90453: EMPTY
90454: LIST
90455: LIST
90456: LIST
90457: LIST
90458: LIST
90459: LIST
90460: LIST
90461: LIST
90462: LIST
90463: LIST
90464: LIST
90465: LIST
90466: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
90467: LD_ADDR_VAR 0 48
90471: PUSH
90472: LD_INT 0
90474: PUSH
90475: LD_INT 0
90477: PUSH
90478: EMPTY
90479: LIST
90480: LIST
90481: PUSH
90482: LD_INT 0
90484: PUSH
90485: LD_INT 1
90487: NEG
90488: PUSH
90489: EMPTY
90490: LIST
90491: LIST
90492: PUSH
90493: LD_INT 1
90495: PUSH
90496: LD_INT 0
90498: PUSH
90499: EMPTY
90500: LIST
90501: LIST
90502: PUSH
90503: LD_INT 1
90505: PUSH
90506: LD_INT 1
90508: PUSH
90509: EMPTY
90510: LIST
90511: LIST
90512: PUSH
90513: LD_INT 0
90515: PUSH
90516: LD_INT 1
90518: PUSH
90519: EMPTY
90520: LIST
90521: LIST
90522: PUSH
90523: LD_INT 1
90525: NEG
90526: PUSH
90527: LD_INT 0
90529: PUSH
90530: EMPTY
90531: LIST
90532: LIST
90533: PUSH
90534: LD_INT 1
90536: NEG
90537: PUSH
90538: LD_INT 1
90540: NEG
90541: PUSH
90542: EMPTY
90543: LIST
90544: LIST
90545: PUSH
90546: LD_INT 1
90548: NEG
90549: PUSH
90550: LD_INT 2
90552: NEG
90553: PUSH
90554: EMPTY
90555: LIST
90556: LIST
90557: PUSH
90558: LD_INT 0
90560: PUSH
90561: LD_INT 2
90563: NEG
90564: PUSH
90565: EMPTY
90566: LIST
90567: LIST
90568: PUSH
90569: LD_INT 1
90571: PUSH
90572: LD_INT 1
90574: NEG
90575: PUSH
90576: EMPTY
90577: LIST
90578: LIST
90579: PUSH
90580: LD_INT 2
90582: PUSH
90583: LD_INT 0
90585: PUSH
90586: EMPTY
90587: LIST
90588: LIST
90589: PUSH
90590: LD_INT 2
90592: PUSH
90593: LD_INT 1
90595: PUSH
90596: EMPTY
90597: LIST
90598: LIST
90599: PUSH
90600: EMPTY
90601: LIST
90602: LIST
90603: LIST
90604: LIST
90605: LIST
90606: LIST
90607: LIST
90608: LIST
90609: LIST
90610: LIST
90611: LIST
90612: LIST
90613: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
90614: LD_ADDR_VAR 0 49
90618: PUSH
90619: LD_INT 0
90621: PUSH
90622: LD_INT 0
90624: PUSH
90625: EMPTY
90626: LIST
90627: LIST
90628: PUSH
90629: LD_INT 0
90631: PUSH
90632: LD_INT 1
90634: NEG
90635: PUSH
90636: EMPTY
90637: LIST
90638: LIST
90639: PUSH
90640: LD_INT 1
90642: PUSH
90643: LD_INT 0
90645: PUSH
90646: EMPTY
90647: LIST
90648: LIST
90649: PUSH
90650: LD_INT 1
90652: PUSH
90653: LD_INT 1
90655: PUSH
90656: EMPTY
90657: LIST
90658: LIST
90659: PUSH
90660: LD_INT 0
90662: PUSH
90663: LD_INT 1
90665: PUSH
90666: EMPTY
90667: LIST
90668: LIST
90669: PUSH
90670: LD_INT 1
90672: NEG
90673: PUSH
90674: LD_INT 0
90676: PUSH
90677: EMPTY
90678: LIST
90679: LIST
90680: PUSH
90681: LD_INT 1
90683: NEG
90684: PUSH
90685: LD_INT 1
90687: NEG
90688: PUSH
90689: EMPTY
90690: LIST
90691: LIST
90692: PUSH
90693: LD_INT 1
90695: PUSH
90696: LD_INT 1
90698: NEG
90699: PUSH
90700: EMPTY
90701: LIST
90702: LIST
90703: PUSH
90704: LD_INT 2
90706: PUSH
90707: LD_INT 0
90709: PUSH
90710: EMPTY
90711: LIST
90712: LIST
90713: PUSH
90714: LD_INT 2
90716: PUSH
90717: LD_INT 1
90719: PUSH
90720: EMPTY
90721: LIST
90722: LIST
90723: PUSH
90724: LD_INT 2
90726: PUSH
90727: LD_INT 2
90729: PUSH
90730: EMPTY
90731: LIST
90732: LIST
90733: PUSH
90734: LD_INT 1
90736: PUSH
90737: LD_INT 2
90739: PUSH
90740: EMPTY
90741: LIST
90742: LIST
90743: PUSH
90744: EMPTY
90745: LIST
90746: LIST
90747: LIST
90748: LIST
90749: LIST
90750: LIST
90751: LIST
90752: LIST
90753: LIST
90754: LIST
90755: LIST
90756: LIST
90757: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
90758: LD_ADDR_VAR 0 50
90762: PUSH
90763: LD_INT 0
90765: PUSH
90766: LD_INT 0
90768: PUSH
90769: EMPTY
90770: LIST
90771: LIST
90772: PUSH
90773: LD_INT 0
90775: PUSH
90776: LD_INT 1
90778: NEG
90779: PUSH
90780: EMPTY
90781: LIST
90782: LIST
90783: PUSH
90784: LD_INT 1
90786: PUSH
90787: LD_INT 0
90789: PUSH
90790: EMPTY
90791: LIST
90792: LIST
90793: PUSH
90794: LD_INT 1
90796: PUSH
90797: LD_INT 1
90799: PUSH
90800: EMPTY
90801: LIST
90802: LIST
90803: PUSH
90804: LD_INT 0
90806: PUSH
90807: LD_INT 1
90809: PUSH
90810: EMPTY
90811: LIST
90812: LIST
90813: PUSH
90814: LD_INT 1
90816: NEG
90817: PUSH
90818: LD_INT 0
90820: PUSH
90821: EMPTY
90822: LIST
90823: LIST
90824: PUSH
90825: LD_INT 1
90827: NEG
90828: PUSH
90829: LD_INT 1
90831: NEG
90832: PUSH
90833: EMPTY
90834: LIST
90835: LIST
90836: PUSH
90837: LD_INT 2
90839: PUSH
90840: LD_INT 1
90842: PUSH
90843: EMPTY
90844: LIST
90845: LIST
90846: PUSH
90847: LD_INT 2
90849: PUSH
90850: LD_INT 2
90852: PUSH
90853: EMPTY
90854: LIST
90855: LIST
90856: PUSH
90857: LD_INT 1
90859: PUSH
90860: LD_INT 2
90862: PUSH
90863: EMPTY
90864: LIST
90865: LIST
90866: PUSH
90867: LD_INT 0
90869: PUSH
90870: LD_INT 2
90872: PUSH
90873: EMPTY
90874: LIST
90875: LIST
90876: PUSH
90877: LD_INT 1
90879: NEG
90880: PUSH
90881: LD_INT 1
90883: PUSH
90884: EMPTY
90885: LIST
90886: LIST
90887: PUSH
90888: EMPTY
90889: LIST
90890: LIST
90891: LIST
90892: LIST
90893: LIST
90894: LIST
90895: LIST
90896: LIST
90897: LIST
90898: LIST
90899: LIST
90900: LIST
90901: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
90902: LD_ADDR_VAR 0 51
90906: PUSH
90907: LD_INT 0
90909: PUSH
90910: LD_INT 0
90912: PUSH
90913: EMPTY
90914: LIST
90915: LIST
90916: PUSH
90917: LD_INT 0
90919: PUSH
90920: LD_INT 1
90922: NEG
90923: PUSH
90924: EMPTY
90925: LIST
90926: LIST
90927: PUSH
90928: LD_INT 1
90930: PUSH
90931: LD_INT 0
90933: PUSH
90934: EMPTY
90935: LIST
90936: LIST
90937: PUSH
90938: LD_INT 1
90940: PUSH
90941: LD_INT 1
90943: PUSH
90944: EMPTY
90945: LIST
90946: LIST
90947: PUSH
90948: LD_INT 0
90950: PUSH
90951: LD_INT 1
90953: PUSH
90954: EMPTY
90955: LIST
90956: LIST
90957: PUSH
90958: LD_INT 1
90960: NEG
90961: PUSH
90962: LD_INT 0
90964: PUSH
90965: EMPTY
90966: LIST
90967: LIST
90968: PUSH
90969: LD_INT 1
90971: NEG
90972: PUSH
90973: LD_INT 1
90975: NEG
90976: PUSH
90977: EMPTY
90978: LIST
90979: LIST
90980: PUSH
90981: LD_INT 1
90983: PUSH
90984: LD_INT 2
90986: PUSH
90987: EMPTY
90988: LIST
90989: LIST
90990: PUSH
90991: LD_INT 0
90993: PUSH
90994: LD_INT 2
90996: PUSH
90997: EMPTY
90998: LIST
90999: LIST
91000: PUSH
91001: LD_INT 1
91003: NEG
91004: PUSH
91005: LD_INT 1
91007: PUSH
91008: EMPTY
91009: LIST
91010: LIST
91011: PUSH
91012: LD_INT 2
91014: NEG
91015: PUSH
91016: LD_INT 0
91018: PUSH
91019: EMPTY
91020: LIST
91021: LIST
91022: PUSH
91023: LD_INT 2
91025: NEG
91026: PUSH
91027: LD_INT 1
91029: NEG
91030: PUSH
91031: EMPTY
91032: LIST
91033: LIST
91034: PUSH
91035: EMPTY
91036: LIST
91037: LIST
91038: LIST
91039: LIST
91040: LIST
91041: LIST
91042: LIST
91043: LIST
91044: LIST
91045: LIST
91046: LIST
91047: LIST
91048: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91049: LD_ADDR_VAR 0 52
91053: PUSH
91054: LD_INT 0
91056: PUSH
91057: LD_INT 0
91059: PUSH
91060: EMPTY
91061: LIST
91062: LIST
91063: PUSH
91064: LD_INT 0
91066: PUSH
91067: LD_INT 1
91069: NEG
91070: PUSH
91071: EMPTY
91072: LIST
91073: LIST
91074: PUSH
91075: LD_INT 1
91077: PUSH
91078: LD_INT 0
91080: PUSH
91081: EMPTY
91082: LIST
91083: LIST
91084: PUSH
91085: LD_INT 1
91087: PUSH
91088: LD_INT 1
91090: PUSH
91091: EMPTY
91092: LIST
91093: LIST
91094: PUSH
91095: LD_INT 0
91097: PUSH
91098: LD_INT 1
91100: PUSH
91101: EMPTY
91102: LIST
91103: LIST
91104: PUSH
91105: LD_INT 1
91107: NEG
91108: PUSH
91109: LD_INT 0
91111: PUSH
91112: EMPTY
91113: LIST
91114: LIST
91115: PUSH
91116: LD_INT 1
91118: NEG
91119: PUSH
91120: LD_INT 1
91122: NEG
91123: PUSH
91124: EMPTY
91125: LIST
91126: LIST
91127: PUSH
91128: LD_INT 1
91130: NEG
91131: PUSH
91132: LD_INT 2
91134: NEG
91135: PUSH
91136: EMPTY
91137: LIST
91138: LIST
91139: PUSH
91140: LD_INT 1
91142: NEG
91143: PUSH
91144: LD_INT 1
91146: PUSH
91147: EMPTY
91148: LIST
91149: LIST
91150: PUSH
91151: LD_INT 2
91153: NEG
91154: PUSH
91155: LD_INT 0
91157: PUSH
91158: EMPTY
91159: LIST
91160: LIST
91161: PUSH
91162: LD_INT 2
91164: NEG
91165: PUSH
91166: LD_INT 1
91168: NEG
91169: PUSH
91170: EMPTY
91171: LIST
91172: LIST
91173: PUSH
91174: LD_INT 2
91176: NEG
91177: PUSH
91178: LD_INT 2
91180: NEG
91181: PUSH
91182: EMPTY
91183: LIST
91184: LIST
91185: PUSH
91186: EMPTY
91187: LIST
91188: LIST
91189: LIST
91190: LIST
91191: LIST
91192: LIST
91193: LIST
91194: LIST
91195: LIST
91196: LIST
91197: LIST
91198: LIST
91199: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91200: LD_ADDR_VAR 0 53
91204: PUSH
91205: LD_INT 0
91207: PUSH
91208: LD_INT 0
91210: PUSH
91211: EMPTY
91212: LIST
91213: LIST
91214: PUSH
91215: LD_INT 0
91217: PUSH
91218: LD_INT 1
91220: NEG
91221: PUSH
91222: EMPTY
91223: LIST
91224: LIST
91225: PUSH
91226: LD_INT 1
91228: PUSH
91229: LD_INT 0
91231: PUSH
91232: EMPTY
91233: LIST
91234: LIST
91235: PUSH
91236: LD_INT 1
91238: PUSH
91239: LD_INT 1
91241: PUSH
91242: EMPTY
91243: LIST
91244: LIST
91245: PUSH
91246: LD_INT 0
91248: PUSH
91249: LD_INT 1
91251: PUSH
91252: EMPTY
91253: LIST
91254: LIST
91255: PUSH
91256: LD_INT 1
91258: NEG
91259: PUSH
91260: LD_INT 0
91262: PUSH
91263: EMPTY
91264: LIST
91265: LIST
91266: PUSH
91267: LD_INT 1
91269: NEG
91270: PUSH
91271: LD_INT 1
91273: NEG
91274: PUSH
91275: EMPTY
91276: LIST
91277: LIST
91278: PUSH
91279: LD_INT 1
91281: NEG
91282: PUSH
91283: LD_INT 2
91285: NEG
91286: PUSH
91287: EMPTY
91288: LIST
91289: LIST
91290: PUSH
91291: LD_INT 0
91293: PUSH
91294: LD_INT 2
91296: NEG
91297: PUSH
91298: EMPTY
91299: LIST
91300: LIST
91301: PUSH
91302: LD_INT 1
91304: PUSH
91305: LD_INT 1
91307: NEG
91308: PUSH
91309: EMPTY
91310: LIST
91311: LIST
91312: PUSH
91313: LD_INT 2
91315: PUSH
91316: LD_INT 0
91318: PUSH
91319: EMPTY
91320: LIST
91321: LIST
91322: PUSH
91323: LD_INT 2
91325: PUSH
91326: LD_INT 1
91328: PUSH
91329: EMPTY
91330: LIST
91331: LIST
91332: PUSH
91333: LD_INT 2
91335: PUSH
91336: LD_INT 2
91338: PUSH
91339: EMPTY
91340: LIST
91341: LIST
91342: PUSH
91343: LD_INT 1
91345: PUSH
91346: LD_INT 2
91348: PUSH
91349: EMPTY
91350: LIST
91351: LIST
91352: PUSH
91353: LD_INT 0
91355: PUSH
91356: LD_INT 2
91358: PUSH
91359: EMPTY
91360: LIST
91361: LIST
91362: PUSH
91363: LD_INT 1
91365: NEG
91366: PUSH
91367: LD_INT 1
91369: PUSH
91370: EMPTY
91371: LIST
91372: LIST
91373: PUSH
91374: LD_INT 2
91376: NEG
91377: PUSH
91378: LD_INT 0
91380: PUSH
91381: EMPTY
91382: LIST
91383: LIST
91384: PUSH
91385: LD_INT 2
91387: NEG
91388: PUSH
91389: LD_INT 1
91391: NEG
91392: PUSH
91393: EMPTY
91394: LIST
91395: LIST
91396: PUSH
91397: LD_INT 2
91399: NEG
91400: PUSH
91401: LD_INT 2
91403: NEG
91404: PUSH
91405: EMPTY
91406: LIST
91407: LIST
91408: PUSH
91409: EMPTY
91410: LIST
91411: LIST
91412: LIST
91413: LIST
91414: LIST
91415: LIST
91416: LIST
91417: LIST
91418: LIST
91419: LIST
91420: LIST
91421: LIST
91422: LIST
91423: LIST
91424: LIST
91425: LIST
91426: LIST
91427: LIST
91428: LIST
91429: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91430: LD_ADDR_VAR 0 54
91434: PUSH
91435: LD_INT 0
91437: PUSH
91438: LD_INT 0
91440: PUSH
91441: EMPTY
91442: LIST
91443: LIST
91444: PUSH
91445: LD_INT 0
91447: PUSH
91448: LD_INT 1
91450: NEG
91451: PUSH
91452: EMPTY
91453: LIST
91454: LIST
91455: PUSH
91456: LD_INT 1
91458: PUSH
91459: LD_INT 0
91461: PUSH
91462: EMPTY
91463: LIST
91464: LIST
91465: PUSH
91466: LD_INT 1
91468: PUSH
91469: LD_INT 1
91471: PUSH
91472: EMPTY
91473: LIST
91474: LIST
91475: PUSH
91476: LD_INT 0
91478: PUSH
91479: LD_INT 1
91481: PUSH
91482: EMPTY
91483: LIST
91484: LIST
91485: PUSH
91486: LD_INT 1
91488: NEG
91489: PUSH
91490: LD_INT 0
91492: PUSH
91493: EMPTY
91494: LIST
91495: LIST
91496: PUSH
91497: LD_INT 1
91499: NEG
91500: PUSH
91501: LD_INT 1
91503: NEG
91504: PUSH
91505: EMPTY
91506: LIST
91507: LIST
91508: PUSH
91509: LD_INT 1
91511: NEG
91512: PUSH
91513: LD_INT 2
91515: NEG
91516: PUSH
91517: EMPTY
91518: LIST
91519: LIST
91520: PUSH
91521: LD_INT 0
91523: PUSH
91524: LD_INT 2
91526: NEG
91527: PUSH
91528: EMPTY
91529: LIST
91530: LIST
91531: PUSH
91532: LD_INT 1
91534: PUSH
91535: LD_INT 1
91537: NEG
91538: PUSH
91539: EMPTY
91540: LIST
91541: LIST
91542: PUSH
91543: LD_INT 2
91545: PUSH
91546: LD_INT 0
91548: PUSH
91549: EMPTY
91550: LIST
91551: LIST
91552: PUSH
91553: LD_INT 2
91555: PUSH
91556: LD_INT 1
91558: PUSH
91559: EMPTY
91560: LIST
91561: LIST
91562: PUSH
91563: LD_INT 2
91565: PUSH
91566: LD_INT 2
91568: PUSH
91569: EMPTY
91570: LIST
91571: LIST
91572: PUSH
91573: LD_INT 1
91575: PUSH
91576: LD_INT 2
91578: PUSH
91579: EMPTY
91580: LIST
91581: LIST
91582: PUSH
91583: LD_INT 0
91585: PUSH
91586: LD_INT 2
91588: PUSH
91589: EMPTY
91590: LIST
91591: LIST
91592: PUSH
91593: LD_INT 1
91595: NEG
91596: PUSH
91597: LD_INT 1
91599: PUSH
91600: EMPTY
91601: LIST
91602: LIST
91603: PUSH
91604: LD_INT 2
91606: NEG
91607: PUSH
91608: LD_INT 0
91610: PUSH
91611: EMPTY
91612: LIST
91613: LIST
91614: PUSH
91615: LD_INT 2
91617: NEG
91618: PUSH
91619: LD_INT 1
91621: NEG
91622: PUSH
91623: EMPTY
91624: LIST
91625: LIST
91626: PUSH
91627: LD_INT 2
91629: NEG
91630: PUSH
91631: LD_INT 2
91633: NEG
91634: PUSH
91635: EMPTY
91636: LIST
91637: LIST
91638: PUSH
91639: EMPTY
91640: LIST
91641: LIST
91642: LIST
91643: LIST
91644: LIST
91645: LIST
91646: LIST
91647: LIST
91648: LIST
91649: LIST
91650: LIST
91651: LIST
91652: LIST
91653: LIST
91654: LIST
91655: LIST
91656: LIST
91657: LIST
91658: LIST
91659: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91660: LD_ADDR_VAR 0 55
91664: PUSH
91665: LD_INT 0
91667: PUSH
91668: LD_INT 0
91670: PUSH
91671: EMPTY
91672: LIST
91673: LIST
91674: PUSH
91675: LD_INT 0
91677: PUSH
91678: LD_INT 1
91680: NEG
91681: PUSH
91682: EMPTY
91683: LIST
91684: LIST
91685: PUSH
91686: LD_INT 1
91688: PUSH
91689: LD_INT 0
91691: PUSH
91692: EMPTY
91693: LIST
91694: LIST
91695: PUSH
91696: LD_INT 1
91698: PUSH
91699: LD_INT 1
91701: PUSH
91702: EMPTY
91703: LIST
91704: LIST
91705: PUSH
91706: LD_INT 0
91708: PUSH
91709: LD_INT 1
91711: PUSH
91712: EMPTY
91713: LIST
91714: LIST
91715: PUSH
91716: LD_INT 1
91718: NEG
91719: PUSH
91720: LD_INT 0
91722: PUSH
91723: EMPTY
91724: LIST
91725: LIST
91726: PUSH
91727: LD_INT 1
91729: NEG
91730: PUSH
91731: LD_INT 1
91733: NEG
91734: PUSH
91735: EMPTY
91736: LIST
91737: LIST
91738: PUSH
91739: LD_INT 1
91741: NEG
91742: PUSH
91743: LD_INT 2
91745: NEG
91746: PUSH
91747: EMPTY
91748: LIST
91749: LIST
91750: PUSH
91751: LD_INT 0
91753: PUSH
91754: LD_INT 2
91756: NEG
91757: PUSH
91758: EMPTY
91759: LIST
91760: LIST
91761: PUSH
91762: LD_INT 1
91764: PUSH
91765: LD_INT 1
91767: NEG
91768: PUSH
91769: EMPTY
91770: LIST
91771: LIST
91772: PUSH
91773: LD_INT 2
91775: PUSH
91776: LD_INT 0
91778: PUSH
91779: EMPTY
91780: LIST
91781: LIST
91782: PUSH
91783: LD_INT 2
91785: PUSH
91786: LD_INT 1
91788: PUSH
91789: EMPTY
91790: LIST
91791: LIST
91792: PUSH
91793: LD_INT 2
91795: PUSH
91796: LD_INT 2
91798: PUSH
91799: EMPTY
91800: LIST
91801: LIST
91802: PUSH
91803: LD_INT 1
91805: PUSH
91806: LD_INT 2
91808: PUSH
91809: EMPTY
91810: LIST
91811: LIST
91812: PUSH
91813: LD_INT 0
91815: PUSH
91816: LD_INT 2
91818: PUSH
91819: EMPTY
91820: LIST
91821: LIST
91822: PUSH
91823: LD_INT 1
91825: NEG
91826: PUSH
91827: LD_INT 1
91829: PUSH
91830: EMPTY
91831: LIST
91832: LIST
91833: PUSH
91834: LD_INT 2
91836: NEG
91837: PUSH
91838: LD_INT 0
91840: PUSH
91841: EMPTY
91842: LIST
91843: LIST
91844: PUSH
91845: LD_INT 2
91847: NEG
91848: PUSH
91849: LD_INT 1
91851: NEG
91852: PUSH
91853: EMPTY
91854: LIST
91855: LIST
91856: PUSH
91857: LD_INT 2
91859: NEG
91860: PUSH
91861: LD_INT 2
91863: NEG
91864: PUSH
91865: EMPTY
91866: LIST
91867: LIST
91868: PUSH
91869: EMPTY
91870: LIST
91871: LIST
91872: LIST
91873: LIST
91874: LIST
91875: LIST
91876: LIST
91877: LIST
91878: LIST
91879: LIST
91880: LIST
91881: LIST
91882: LIST
91883: LIST
91884: LIST
91885: LIST
91886: LIST
91887: LIST
91888: LIST
91889: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91890: LD_ADDR_VAR 0 56
91894: PUSH
91895: LD_INT 0
91897: PUSH
91898: LD_INT 0
91900: PUSH
91901: EMPTY
91902: LIST
91903: LIST
91904: PUSH
91905: LD_INT 0
91907: PUSH
91908: LD_INT 1
91910: NEG
91911: PUSH
91912: EMPTY
91913: LIST
91914: LIST
91915: PUSH
91916: LD_INT 1
91918: PUSH
91919: LD_INT 0
91921: PUSH
91922: EMPTY
91923: LIST
91924: LIST
91925: PUSH
91926: LD_INT 1
91928: PUSH
91929: LD_INT 1
91931: PUSH
91932: EMPTY
91933: LIST
91934: LIST
91935: PUSH
91936: LD_INT 0
91938: PUSH
91939: LD_INT 1
91941: PUSH
91942: EMPTY
91943: LIST
91944: LIST
91945: PUSH
91946: LD_INT 1
91948: NEG
91949: PUSH
91950: LD_INT 0
91952: PUSH
91953: EMPTY
91954: LIST
91955: LIST
91956: PUSH
91957: LD_INT 1
91959: NEG
91960: PUSH
91961: LD_INT 1
91963: NEG
91964: PUSH
91965: EMPTY
91966: LIST
91967: LIST
91968: PUSH
91969: LD_INT 1
91971: NEG
91972: PUSH
91973: LD_INT 2
91975: NEG
91976: PUSH
91977: EMPTY
91978: LIST
91979: LIST
91980: PUSH
91981: LD_INT 0
91983: PUSH
91984: LD_INT 2
91986: NEG
91987: PUSH
91988: EMPTY
91989: LIST
91990: LIST
91991: PUSH
91992: LD_INT 1
91994: PUSH
91995: LD_INT 1
91997: NEG
91998: PUSH
91999: EMPTY
92000: LIST
92001: LIST
92002: PUSH
92003: LD_INT 2
92005: PUSH
92006: LD_INT 0
92008: PUSH
92009: EMPTY
92010: LIST
92011: LIST
92012: PUSH
92013: LD_INT 2
92015: PUSH
92016: LD_INT 1
92018: PUSH
92019: EMPTY
92020: LIST
92021: LIST
92022: PUSH
92023: LD_INT 2
92025: PUSH
92026: LD_INT 2
92028: PUSH
92029: EMPTY
92030: LIST
92031: LIST
92032: PUSH
92033: LD_INT 1
92035: PUSH
92036: LD_INT 2
92038: PUSH
92039: EMPTY
92040: LIST
92041: LIST
92042: PUSH
92043: LD_INT 0
92045: PUSH
92046: LD_INT 2
92048: PUSH
92049: EMPTY
92050: LIST
92051: LIST
92052: PUSH
92053: LD_INT 1
92055: NEG
92056: PUSH
92057: LD_INT 1
92059: PUSH
92060: EMPTY
92061: LIST
92062: LIST
92063: PUSH
92064: LD_INT 2
92066: NEG
92067: PUSH
92068: LD_INT 0
92070: PUSH
92071: EMPTY
92072: LIST
92073: LIST
92074: PUSH
92075: LD_INT 2
92077: NEG
92078: PUSH
92079: LD_INT 1
92081: NEG
92082: PUSH
92083: EMPTY
92084: LIST
92085: LIST
92086: PUSH
92087: LD_INT 2
92089: NEG
92090: PUSH
92091: LD_INT 2
92093: NEG
92094: PUSH
92095: EMPTY
92096: LIST
92097: LIST
92098: PUSH
92099: EMPTY
92100: LIST
92101: LIST
92102: LIST
92103: LIST
92104: LIST
92105: LIST
92106: LIST
92107: LIST
92108: LIST
92109: LIST
92110: LIST
92111: LIST
92112: LIST
92113: LIST
92114: LIST
92115: LIST
92116: LIST
92117: LIST
92118: LIST
92119: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92120: LD_ADDR_VAR 0 57
92124: PUSH
92125: LD_INT 0
92127: PUSH
92128: LD_INT 0
92130: PUSH
92131: EMPTY
92132: LIST
92133: LIST
92134: PUSH
92135: LD_INT 0
92137: PUSH
92138: LD_INT 1
92140: NEG
92141: PUSH
92142: EMPTY
92143: LIST
92144: LIST
92145: PUSH
92146: LD_INT 1
92148: PUSH
92149: LD_INT 0
92151: PUSH
92152: EMPTY
92153: LIST
92154: LIST
92155: PUSH
92156: LD_INT 1
92158: PUSH
92159: LD_INT 1
92161: PUSH
92162: EMPTY
92163: LIST
92164: LIST
92165: PUSH
92166: LD_INT 0
92168: PUSH
92169: LD_INT 1
92171: PUSH
92172: EMPTY
92173: LIST
92174: LIST
92175: PUSH
92176: LD_INT 1
92178: NEG
92179: PUSH
92180: LD_INT 0
92182: PUSH
92183: EMPTY
92184: LIST
92185: LIST
92186: PUSH
92187: LD_INT 1
92189: NEG
92190: PUSH
92191: LD_INT 1
92193: NEG
92194: PUSH
92195: EMPTY
92196: LIST
92197: LIST
92198: PUSH
92199: LD_INT 1
92201: NEG
92202: PUSH
92203: LD_INT 2
92205: NEG
92206: PUSH
92207: EMPTY
92208: LIST
92209: LIST
92210: PUSH
92211: LD_INT 0
92213: PUSH
92214: LD_INT 2
92216: NEG
92217: PUSH
92218: EMPTY
92219: LIST
92220: LIST
92221: PUSH
92222: LD_INT 1
92224: PUSH
92225: LD_INT 1
92227: NEG
92228: PUSH
92229: EMPTY
92230: LIST
92231: LIST
92232: PUSH
92233: LD_INT 2
92235: PUSH
92236: LD_INT 0
92238: PUSH
92239: EMPTY
92240: LIST
92241: LIST
92242: PUSH
92243: LD_INT 2
92245: PUSH
92246: LD_INT 1
92248: PUSH
92249: EMPTY
92250: LIST
92251: LIST
92252: PUSH
92253: LD_INT 2
92255: PUSH
92256: LD_INT 2
92258: PUSH
92259: EMPTY
92260: LIST
92261: LIST
92262: PUSH
92263: LD_INT 1
92265: PUSH
92266: LD_INT 2
92268: PUSH
92269: EMPTY
92270: LIST
92271: LIST
92272: PUSH
92273: LD_INT 0
92275: PUSH
92276: LD_INT 2
92278: PUSH
92279: EMPTY
92280: LIST
92281: LIST
92282: PUSH
92283: LD_INT 1
92285: NEG
92286: PUSH
92287: LD_INT 1
92289: PUSH
92290: EMPTY
92291: LIST
92292: LIST
92293: PUSH
92294: LD_INT 2
92296: NEG
92297: PUSH
92298: LD_INT 0
92300: PUSH
92301: EMPTY
92302: LIST
92303: LIST
92304: PUSH
92305: LD_INT 2
92307: NEG
92308: PUSH
92309: LD_INT 1
92311: NEG
92312: PUSH
92313: EMPTY
92314: LIST
92315: LIST
92316: PUSH
92317: LD_INT 2
92319: NEG
92320: PUSH
92321: LD_INT 2
92323: NEG
92324: PUSH
92325: EMPTY
92326: LIST
92327: LIST
92328: PUSH
92329: EMPTY
92330: LIST
92331: LIST
92332: LIST
92333: LIST
92334: LIST
92335: LIST
92336: LIST
92337: LIST
92338: LIST
92339: LIST
92340: LIST
92341: LIST
92342: LIST
92343: LIST
92344: LIST
92345: LIST
92346: LIST
92347: LIST
92348: LIST
92349: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92350: LD_ADDR_VAR 0 58
92354: PUSH
92355: LD_INT 0
92357: PUSH
92358: LD_INT 0
92360: PUSH
92361: EMPTY
92362: LIST
92363: LIST
92364: PUSH
92365: LD_INT 0
92367: PUSH
92368: LD_INT 1
92370: NEG
92371: PUSH
92372: EMPTY
92373: LIST
92374: LIST
92375: PUSH
92376: LD_INT 1
92378: PUSH
92379: LD_INT 0
92381: PUSH
92382: EMPTY
92383: LIST
92384: LIST
92385: PUSH
92386: LD_INT 1
92388: PUSH
92389: LD_INT 1
92391: PUSH
92392: EMPTY
92393: LIST
92394: LIST
92395: PUSH
92396: LD_INT 0
92398: PUSH
92399: LD_INT 1
92401: PUSH
92402: EMPTY
92403: LIST
92404: LIST
92405: PUSH
92406: LD_INT 1
92408: NEG
92409: PUSH
92410: LD_INT 0
92412: PUSH
92413: EMPTY
92414: LIST
92415: LIST
92416: PUSH
92417: LD_INT 1
92419: NEG
92420: PUSH
92421: LD_INT 1
92423: NEG
92424: PUSH
92425: EMPTY
92426: LIST
92427: LIST
92428: PUSH
92429: LD_INT 1
92431: NEG
92432: PUSH
92433: LD_INT 2
92435: NEG
92436: PUSH
92437: EMPTY
92438: LIST
92439: LIST
92440: PUSH
92441: LD_INT 0
92443: PUSH
92444: LD_INT 2
92446: NEG
92447: PUSH
92448: EMPTY
92449: LIST
92450: LIST
92451: PUSH
92452: LD_INT 1
92454: PUSH
92455: LD_INT 1
92457: NEG
92458: PUSH
92459: EMPTY
92460: LIST
92461: LIST
92462: PUSH
92463: LD_INT 2
92465: PUSH
92466: LD_INT 0
92468: PUSH
92469: EMPTY
92470: LIST
92471: LIST
92472: PUSH
92473: LD_INT 2
92475: PUSH
92476: LD_INT 1
92478: PUSH
92479: EMPTY
92480: LIST
92481: LIST
92482: PUSH
92483: LD_INT 2
92485: PUSH
92486: LD_INT 2
92488: PUSH
92489: EMPTY
92490: LIST
92491: LIST
92492: PUSH
92493: LD_INT 1
92495: PUSH
92496: LD_INT 2
92498: PUSH
92499: EMPTY
92500: LIST
92501: LIST
92502: PUSH
92503: LD_INT 0
92505: PUSH
92506: LD_INT 2
92508: PUSH
92509: EMPTY
92510: LIST
92511: LIST
92512: PUSH
92513: LD_INT 1
92515: NEG
92516: PUSH
92517: LD_INT 1
92519: PUSH
92520: EMPTY
92521: LIST
92522: LIST
92523: PUSH
92524: LD_INT 2
92526: NEG
92527: PUSH
92528: LD_INT 0
92530: PUSH
92531: EMPTY
92532: LIST
92533: LIST
92534: PUSH
92535: LD_INT 2
92537: NEG
92538: PUSH
92539: LD_INT 1
92541: NEG
92542: PUSH
92543: EMPTY
92544: LIST
92545: LIST
92546: PUSH
92547: LD_INT 2
92549: NEG
92550: PUSH
92551: LD_INT 2
92553: NEG
92554: PUSH
92555: EMPTY
92556: LIST
92557: LIST
92558: PUSH
92559: EMPTY
92560: LIST
92561: LIST
92562: LIST
92563: LIST
92564: LIST
92565: LIST
92566: LIST
92567: LIST
92568: LIST
92569: LIST
92570: LIST
92571: LIST
92572: LIST
92573: LIST
92574: LIST
92575: LIST
92576: LIST
92577: LIST
92578: LIST
92579: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92580: LD_ADDR_VAR 0 59
92584: PUSH
92585: LD_INT 0
92587: PUSH
92588: LD_INT 0
92590: PUSH
92591: EMPTY
92592: LIST
92593: LIST
92594: PUSH
92595: LD_INT 0
92597: PUSH
92598: LD_INT 1
92600: NEG
92601: PUSH
92602: EMPTY
92603: LIST
92604: LIST
92605: PUSH
92606: LD_INT 1
92608: PUSH
92609: LD_INT 0
92611: PUSH
92612: EMPTY
92613: LIST
92614: LIST
92615: PUSH
92616: LD_INT 1
92618: PUSH
92619: LD_INT 1
92621: PUSH
92622: EMPTY
92623: LIST
92624: LIST
92625: PUSH
92626: LD_INT 0
92628: PUSH
92629: LD_INT 1
92631: PUSH
92632: EMPTY
92633: LIST
92634: LIST
92635: PUSH
92636: LD_INT 1
92638: NEG
92639: PUSH
92640: LD_INT 0
92642: PUSH
92643: EMPTY
92644: LIST
92645: LIST
92646: PUSH
92647: LD_INT 1
92649: NEG
92650: PUSH
92651: LD_INT 1
92653: NEG
92654: PUSH
92655: EMPTY
92656: LIST
92657: LIST
92658: PUSH
92659: EMPTY
92660: LIST
92661: LIST
92662: LIST
92663: LIST
92664: LIST
92665: LIST
92666: LIST
92667: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92668: LD_ADDR_VAR 0 60
92672: PUSH
92673: LD_INT 0
92675: PUSH
92676: LD_INT 0
92678: PUSH
92679: EMPTY
92680: LIST
92681: LIST
92682: PUSH
92683: LD_INT 0
92685: PUSH
92686: LD_INT 1
92688: NEG
92689: PUSH
92690: EMPTY
92691: LIST
92692: LIST
92693: PUSH
92694: LD_INT 1
92696: PUSH
92697: LD_INT 0
92699: PUSH
92700: EMPTY
92701: LIST
92702: LIST
92703: PUSH
92704: LD_INT 1
92706: PUSH
92707: LD_INT 1
92709: PUSH
92710: EMPTY
92711: LIST
92712: LIST
92713: PUSH
92714: LD_INT 0
92716: PUSH
92717: LD_INT 1
92719: PUSH
92720: EMPTY
92721: LIST
92722: LIST
92723: PUSH
92724: LD_INT 1
92726: NEG
92727: PUSH
92728: LD_INT 0
92730: PUSH
92731: EMPTY
92732: LIST
92733: LIST
92734: PUSH
92735: LD_INT 1
92737: NEG
92738: PUSH
92739: LD_INT 1
92741: NEG
92742: PUSH
92743: EMPTY
92744: LIST
92745: LIST
92746: PUSH
92747: EMPTY
92748: LIST
92749: LIST
92750: LIST
92751: LIST
92752: LIST
92753: LIST
92754: LIST
92755: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92756: LD_ADDR_VAR 0 61
92760: PUSH
92761: LD_INT 0
92763: PUSH
92764: LD_INT 0
92766: PUSH
92767: EMPTY
92768: LIST
92769: LIST
92770: PUSH
92771: LD_INT 0
92773: PUSH
92774: LD_INT 1
92776: NEG
92777: PUSH
92778: EMPTY
92779: LIST
92780: LIST
92781: PUSH
92782: LD_INT 1
92784: PUSH
92785: LD_INT 0
92787: PUSH
92788: EMPTY
92789: LIST
92790: LIST
92791: PUSH
92792: LD_INT 1
92794: PUSH
92795: LD_INT 1
92797: PUSH
92798: EMPTY
92799: LIST
92800: LIST
92801: PUSH
92802: LD_INT 0
92804: PUSH
92805: LD_INT 1
92807: PUSH
92808: EMPTY
92809: LIST
92810: LIST
92811: PUSH
92812: LD_INT 1
92814: NEG
92815: PUSH
92816: LD_INT 0
92818: PUSH
92819: EMPTY
92820: LIST
92821: LIST
92822: PUSH
92823: LD_INT 1
92825: NEG
92826: PUSH
92827: LD_INT 1
92829: NEG
92830: PUSH
92831: EMPTY
92832: LIST
92833: LIST
92834: PUSH
92835: EMPTY
92836: LIST
92837: LIST
92838: LIST
92839: LIST
92840: LIST
92841: LIST
92842: LIST
92843: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92844: LD_ADDR_VAR 0 62
92848: PUSH
92849: LD_INT 0
92851: PUSH
92852: LD_INT 0
92854: PUSH
92855: EMPTY
92856: LIST
92857: LIST
92858: PUSH
92859: LD_INT 0
92861: PUSH
92862: LD_INT 1
92864: NEG
92865: PUSH
92866: EMPTY
92867: LIST
92868: LIST
92869: PUSH
92870: LD_INT 1
92872: PUSH
92873: LD_INT 0
92875: PUSH
92876: EMPTY
92877: LIST
92878: LIST
92879: PUSH
92880: LD_INT 1
92882: PUSH
92883: LD_INT 1
92885: PUSH
92886: EMPTY
92887: LIST
92888: LIST
92889: PUSH
92890: LD_INT 0
92892: PUSH
92893: LD_INT 1
92895: PUSH
92896: EMPTY
92897: LIST
92898: LIST
92899: PUSH
92900: LD_INT 1
92902: NEG
92903: PUSH
92904: LD_INT 0
92906: PUSH
92907: EMPTY
92908: LIST
92909: LIST
92910: PUSH
92911: LD_INT 1
92913: NEG
92914: PUSH
92915: LD_INT 1
92917: NEG
92918: PUSH
92919: EMPTY
92920: LIST
92921: LIST
92922: PUSH
92923: EMPTY
92924: LIST
92925: LIST
92926: LIST
92927: LIST
92928: LIST
92929: LIST
92930: LIST
92931: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92932: LD_ADDR_VAR 0 63
92936: PUSH
92937: LD_INT 0
92939: PUSH
92940: LD_INT 0
92942: PUSH
92943: EMPTY
92944: LIST
92945: LIST
92946: PUSH
92947: LD_INT 0
92949: PUSH
92950: LD_INT 1
92952: NEG
92953: PUSH
92954: EMPTY
92955: LIST
92956: LIST
92957: PUSH
92958: LD_INT 1
92960: PUSH
92961: LD_INT 0
92963: PUSH
92964: EMPTY
92965: LIST
92966: LIST
92967: PUSH
92968: LD_INT 1
92970: PUSH
92971: LD_INT 1
92973: PUSH
92974: EMPTY
92975: LIST
92976: LIST
92977: PUSH
92978: LD_INT 0
92980: PUSH
92981: LD_INT 1
92983: PUSH
92984: EMPTY
92985: LIST
92986: LIST
92987: PUSH
92988: LD_INT 1
92990: NEG
92991: PUSH
92992: LD_INT 0
92994: PUSH
92995: EMPTY
92996: LIST
92997: LIST
92998: PUSH
92999: LD_INT 1
93001: NEG
93002: PUSH
93003: LD_INT 1
93005: NEG
93006: PUSH
93007: EMPTY
93008: LIST
93009: LIST
93010: PUSH
93011: EMPTY
93012: LIST
93013: LIST
93014: LIST
93015: LIST
93016: LIST
93017: LIST
93018: LIST
93019: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93020: LD_ADDR_VAR 0 64
93024: PUSH
93025: LD_INT 0
93027: PUSH
93028: LD_INT 0
93030: PUSH
93031: EMPTY
93032: LIST
93033: LIST
93034: PUSH
93035: LD_INT 0
93037: PUSH
93038: LD_INT 1
93040: NEG
93041: PUSH
93042: EMPTY
93043: LIST
93044: LIST
93045: PUSH
93046: LD_INT 1
93048: PUSH
93049: LD_INT 0
93051: PUSH
93052: EMPTY
93053: LIST
93054: LIST
93055: PUSH
93056: LD_INT 1
93058: PUSH
93059: LD_INT 1
93061: PUSH
93062: EMPTY
93063: LIST
93064: LIST
93065: PUSH
93066: LD_INT 0
93068: PUSH
93069: LD_INT 1
93071: PUSH
93072: EMPTY
93073: LIST
93074: LIST
93075: PUSH
93076: LD_INT 1
93078: NEG
93079: PUSH
93080: LD_INT 0
93082: PUSH
93083: EMPTY
93084: LIST
93085: LIST
93086: PUSH
93087: LD_INT 1
93089: NEG
93090: PUSH
93091: LD_INT 1
93093: NEG
93094: PUSH
93095: EMPTY
93096: LIST
93097: LIST
93098: PUSH
93099: EMPTY
93100: LIST
93101: LIST
93102: LIST
93103: LIST
93104: LIST
93105: LIST
93106: LIST
93107: ST_TO_ADDR
// end ; 1 :
93108: GO 99005
93110: LD_INT 1
93112: DOUBLE
93113: EQUAL
93114: IFTRUE 93118
93116: GO 95741
93118: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93119: LD_ADDR_VAR 0 11
93123: PUSH
93124: LD_INT 1
93126: NEG
93127: PUSH
93128: LD_INT 3
93130: NEG
93131: PUSH
93132: EMPTY
93133: LIST
93134: LIST
93135: PUSH
93136: LD_INT 0
93138: PUSH
93139: LD_INT 3
93141: NEG
93142: PUSH
93143: EMPTY
93144: LIST
93145: LIST
93146: PUSH
93147: LD_INT 1
93149: PUSH
93150: LD_INT 2
93152: NEG
93153: PUSH
93154: EMPTY
93155: LIST
93156: LIST
93157: PUSH
93158: EMPTY
93159: LIST
93160: LIST
93161: LIST
93162: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93163: LD_ADDR_VAR 0 12
93167: PUSH
93168: LD_INT 2
93170: PUSH
93171: LD_INT 1
93173: NEG
93174: PUSH
93175: EMPTY
93176: LIST
93177: LIST
93178: PUSH
93179: LD_INT 3
93181: PUSH
93182: LD_INT 0
93184: PUSH
93185: EMPTY
93186: LIST
93187: LIST
93188: PUSH
93189: LD_INT 3
93191: PUSH
93192: LD_INT 1
93194: PUSH
93195: EMPTY
93196: LIST
93197: LIST
93198: PUSH
93199: EMPTY
93200: LIST
93201: LIST
93202: LIST
93203: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93204: LD_ADDR_VAR 0 13
93208: PUSH
93209: LD_INT 3
93211: PUSH
93212: LD_INT 2
93214: PUSH
93215: EMPTY
93216: LIST
93217: LIST
93218: PUSH
93219: LD_INT 3
93221: PUSH
93222: LD_INT 3
93224: PUSH
93225: EMPTY
93226: LIST
93227: LIST
93228: PUSH
93229: LD_INT 2
93231: PUSH
93232: LD_INT 3
93234: PUSH
93235: EMPTY
93236: LIST
93237: LIST
93238: PUSH
93239: EMPTY
93240: LIST
93241: LIST
93242: LIST
93243: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93244: LD_ADDR_VAR 0 14
93248: PUSH
93249: LD_INT 1
93251: PUSH
93252: LD_INT 3
93254: PUSH
93255: EMPTY
93256: LIST
93257: LIST
93258: PUSH
93259: LD_INT 0
93261: PUSH
93262: LD_INT 3
93264: PUSH
93265: EMPTY
93266: LIST
93267: LIST
93268: PUSH
93269: LD_INT 1
93271: NEG
93272: PUSH
93273: LD_INT 2
93275: PUSH
93276: EMPTY
93277: LIST
93278: LIST
93279: PUSH
93280: EMPTY
93281: LIST
93282: LIST
93283: LIST
93284: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93285: LD_ADDR_VAR 0 15
93289: PUSH
93290: LD_INT 2
93292: NEG
93293: PUSH
93294: LD_INT 1
93296: PUSH
93297: EMPTY
93298: LIST
93299: LIST
93300: PUSH
93301: LD_INT 3
93303: NEG
93304: PUSH
93305: LD_INT 0
93307: PUSH
93308: EMPTY
93309: LIST
93310: LIST
93311: PUSH
93312: LD_INT 3
93314: NEG
93315: PUSH
93316: LD_INT 1
93318: NEG
93319: PUSH
93320: EMPTY
93321: LIST
93322: LIST
93323: PUSH
93324: EMPTY
93325: LIST
93326: LIST
93327: LIST
93328: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93329: LD_ADDR_VAR 0 16
93333: PUSH
93334: LD_INT 2
93336: NEG
93337: PUSH
93338: LD_INT 3
93340: NEG
93341: PUSH
93342: EMPTY
93343: LIST
93344: LIST
93345: PUSH
93346: LD_INT 3
93348: NEG
93349: PUSH
93350: LD_INT 2
93352: NEG
93353: PUSH
93354: EMPTY
93355: LIST
93356: LIST
93357: PUSH
93358: LD_INT 3
93360: NEG
93361: PUSH
93362: LD_INT 3
93364: NEG
93365: PUSH
93366: EMPTY
93367: LIST
93368: LIST
93369: PUSH
93370: EMPTY
93371: LIST
93372: LIST
93373: LIST
93374: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93375: LD_ADDR_VAR 0 17
93379: PUSH
93380: LD_INT 1
93382: NEG
93383: PUSH
93384: LD_INT 3
93386: NEG
93387: PUSH
93388: EMPTY
93389: LIST
93390: LIST
93391: PUSH
93392: LD_INT 0
93394: PUSH
93395: LD_INT 3
93397: NEG
93398: PUSH
93399: EMPTY
93400: LIST
93401: LIST
93402: PUSH
93403: LD_INT 1
93405: PUSH
93406: LD_INT 2
93408: NEG
93409: PUSH
93410: EMPTY
93411: LIST
93412: LIST
93413: PUSH
93414: EMPTY
93415: LIST
93416: LIST
93417: LIST
93418: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93419: LD_ADDR_VAR 0 18
93423: PUSH
93424: LD_INT 2
93426: PUSH
93427: LD_INT 1
93429: NEG
93430: PUSH
93431: EMPTY
93432: LIST
93433: LIST
93434: PUSH
93435: LD_INT 3
93437: PUSH
93438: LD_INT 0
93440: PUSH
93441: EMPTY
93442: LIST
93443: LIST
93444: PUSH
93445: LD_INT 3
93447: PUSH
93448: LD_INT 1
93450: PUSH
93451: EMPTY
93452: LIST
93453: LIST
93454: PUSH
93455: EMPTY
93456: LIST
93457: LIST
93458: LIST
93459: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93460: LD_ADDR_VAR 0 19
93464: PUSH
93465: LD_INT 3
93467: PUSH
93468: LD_INT 2
93470: PUSH
93471: EMPTY
93472: LIST
93473: LIST
93474: PUSH
93475: LD_INT 3
93477: PUSH
93478: LD_INT 3
93480: PUSH
93481: EMPTY
93482: LIST
93483: LIST
93484: PUSH
93485: LD_INT 2
93487: PUSH
93488: LD_INT 3
93490: PUSH
93491: EMPTY
93492: LIST
93493: LIST
93494: PUSH
93495: EMPTY
93496: LIST
93497: LIST
93498: LIST
93499: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93500: LD_ADDR_VAR 0 20
93504: PUSH
93505: LD_INT 1
93507: PUSH
93508: LD_INT 3
93510: PUSH
93511: EMPTY
93512: LIST
93513: LIST
93514: PUSH
93515: LD_INT 0
93517: PUSH
93518: LD_INT 3
93520: PUSH
93521: EMPTY
93522: LIST
93523: LIST
93524: PUSH
93525: LD_INT 1
93527: NEG
93528: PUSH
93529: LD_INT 2
93531: PUSH
93532: EMPTY
93533: LIST
93534: LIST
93535: PUSH
93536: EMPTY
93537: LIST
93538: LIST
93539: LIST
93540: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93541: LD_ADDR_VAR 0 21
93545: PUSH
93546: LD_INT 2
93548: NEG
93549: PUSH
93550: LD_INT 1
93552: PUSH
93553: EMPTY
93554: LIST
93555: LIST
93556: PUSH
93557: LD_INT 3
93559: NEG
93560: PUSH
93561: LD_INT 0
93563: PUSH
93564: EMPTY
93565: LIST
93566: LIST
93567: PUSH
93568: LD_INT 3
93570: NEG
93571: PUSH
93572: LD_INT 1
93574: NEG
93575: PUSH
93576: EMPTY
93577: LIST
93578: LIST
93579: PUSH
93580: EMPTY
93581: LIST
93582: LIST
93583: LIST
93584: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93585: LD_ADDR_VAR 0 22
93589: PUSH
93590: LD_INT 2
93592: NEG
93593: PUSH
93594: LD_INT 3
93596: NEG
93597: PUSH
93598: EMPTY
93599: LIST
93600: LIST
93601: PUSH
93602: LD_INT 3
93604: NEG
93605: PUSH
93606: LD_INT 2
93608: NEG
93609: PUSH
93610: EMPTY
93611: LIST
93612: LIST
93613: PUSH
93614: LD_INT 3
93616: NEG
93617: PUSH
93618: LD_INT 3
93620: NEG
93621: PUSH
93622: EMPTY
93623: LIST
93624: LIST
93625: PUSH
93626: EMPTY
93627: LIST
93628: LIST
93629: LIST
93630: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
93631: LD_ADDR_VAR 0 23
93635: PUSH
93636: LD_INT 0
93638: PUSH
93639: LD_INT 3
93641: NEG
93642: PUSH
93643: EMPTY
93644: LIST
93645: LIST
93646: PUSH
93647: LD_INT 1
93649: NEG
93650: PUSH
93651: LD_INT 4
93653: NEG
93654: PUSH
93655: EMPTY
93656: LIST
93657: LIST
93658: PUSH
93659: LD_INT 1
93661: PUSH
93662: LD_INT 3
93664: NEG
93665: PUSH
93666: EMPTY
93667: LIST
93668: LIST
93669: PUSH
93670: EMPTY
93671: LIST
93672: LIST
93673: LIST
93674: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
93675: LD_ADDR_VAR 0 24
93679: PUSH
93680: LD_INT 3
93682: PUSH
93683: LD_INT 0
93685: PUSH
93686: EMPTY
93687: LIST
93688: LIST
93689: PUSH
93690: LD_INT 3
93692: PUSH
93693: LD_INT 1
93695: NEG
93696: PUSH
93697: EMPTY
93698: LIST
93699: LIST
93700: PUSH
93701: LD_INT 4
93703: PUSH
93704: LD_INT 1
93706: PUSH
93707: EMPTY
93708: LIST
93709: LIST
93710: PUSH
93711: EMPTY
93712: LIST
93713: LIST
93714: LIST
93715: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
93716: LD_ADDR_VAR 0 25
93720: PUSH
93721: LD_INT 3
93723: PUSH
93724: LD_INT 3
93726: PUSH
93727: EMPTY
93728: LIST
93729: LIST
93730: PUSH
93731: LD_INT 4
93733: PUSH
93734: LD_INT 3
93736: PUSH
93737: EMPTY
93738: LIST
93739: LIST
93740: PUSH
93741: LD_INT 3
93743: PUSH
93744: LD_INT 4
93746: PUSH
93747: EMPTY
93748: LIST
93749: LIST
93750: PUSH
93751: EMPTY
93752: LIST
93753: LIST
93754: LIST
93755: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
93756: LD_ADDR_VAR 0 26
93760: PUSH
93761: LD_INT 0
93763: PUSH
93764: LD_INT 3
93766: PUSH
93767: EMPTY
93768: LIST
93769: LIST
93770: PUSH
93771: LD_INT 1
93773: PUSH
93774: LD_INT 4
93776: PUSH
93777: EMPTY
93778: LIST
93779: LIST
93780: PUSH
93781: LD_INT 1
93783: NEG
93784: PUSH
93785: LD_INT 3
93787: PUSH
93788: EMPTY
93789: LIST
93790: LIST
93791: PUSH
93792: EMPTY
93793: LIST
93794: LIST
93795: LIST
93796: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
93797: LD_ADDR_VAR 0 27
93801: PUSH
93802: LD_INT 3
93804: NEG
93805: PUSH
93806: LD_INT 0
93808: PUSH
93809: EMPTY
93810: LIST
93811: LIST
93812: PUSH
93813: LD_INT 3
93815: NEG
93816: PUSH
93817: LD_INT 1
93819: PUSH
93820: EMPTY
93821: LIST
93822: LIST
93823: PUSH
93824: LD_INT 4
93826: NEG
93827: PUSH
93828: LD_INT 1
93830: NEG
93831: PUSH
93832: EMPTY
93833: LIST
93834: LIST
93835: PUSH
93836: EMPTY
93837: LIST
93838: LIST
93839: LIST
93840: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
93841: LD_ADDR_VAR 0 28
93845: PUSH
93846: LD_INT 3
93848: NEG
93849: PUSH
93850: LD_INT 3
93852: NEG
93853: PUSH
93854: EMPTY
93855: LIST
93856: LIST
93857: PUSH
93858: LD_INT 3
93860: NEG
93861: PUSH
93862: LD_INT 4
93864: NEG
93865: PUSH
93866: EMPTY
93867: LIST
93868: LIST
93869: PUSH
93870: LD_INT 4
93872: NEG
93873: PUSH
93874: LD_INT 3
93876: NEG
93877: PUSH
93878: EMPTY
93879: LIST
93880: LIST
93881: PUSH
93882: EMPTY
93883: LIST
93884: LIST
93885: LIST
93886: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
93887: LD_ADDR_VAR 0 29
93891: PUSH
93892: LD_INT 1
93894: NEG
93895: PUSH
93896: LD_INT 3
93898: NEG
93899: PUSH
93900: EMPTY
93901: LIST
93902: LIST
93903: PUSH
93904: LD_INT 0
93906: PUSH
93907: LD_INT 3
93909: NEG
93910: PUSH
93911: EMPTY
93912: LIST
93913: LIST
93914: PUSH
93915: LD_INT 1
93917: PUSH
93918: LD_INT 2
93920: NEG
93921: PUSH
93922: EMPTY
93923: LIST
93924: LIST
93925: PUSH
93926: LD_INT 1
93928: NEG
93929: PUSH
93930: LD_INT 4
93932: NEG
93933: PUSH
93934: EMPTY
93935: LIST
93936: LIST
93937: PUSH
93938: LD_INT 0
93940: PUSH
93941: LD_INT 4
93943: NEG
93944: PUSH
93945: EMPTY
93946: LIST
93947: LIST
93948: PUSH
93949: LD_INT 1
93951: PUSH
93952: LD_INT 3
93954: NEG
93955: PUSH
93956: EMPTY
93957: LIST
93958: LIST
93959: PUSH
93960: LD_INT 1
93962: NEG
93963: PUSH
93964: LD_INT 5
93966: NEG
93967: PUSH
93968: EMPTY
93969: LIST
93970: LIST
93971: PUSH
93972: LD_INT 0
93974: PUSH
93975: LD_INT 5
93977: NEG
93978: PUSH
93979: EMPTY
93980: LIST
93981: LIST
93982: PUSH
93983: LD_INT 1
93985: PUSH
93986: LD_INT 4
93988: NEG
93989: PUSH
93990: EMPTY
93991: LIST
93992: LIST
93993: PUSH
93994: LD_INT 1
93996: NEG
93997: PUSH
93998: LD_INT 6
94000: NEG
94001: PUSH
94002: EMPTY
94003: LIST
94004: LIST
94005: PUSH
94006: LD_INT 0
94008: PUSH
94009: LD_INT 6
94011: NEG
94012: PUSH
94013: EMPTY
94014: LIST
94015: LIST
94016: PUSH
94017: LD_INT 1
94019: PUSH
94020: LD_INT 5
94022: NEG
94023: PUSH
94024: EMPTY
94025: LIST
94026: LIST
94027: PUSH
94028: EMPTY
94029: LIST
94030: LIST
94031: LIST
94032: LIST
94033: LIST
94034: LIST
94035: LIST
94036: LIST
94037: LIST
94038: LIST
94039: LIST
94040: LIST
94041: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
94042: LD_ADDR_VAR 0 30
94046: PUSH
94047: LD_INT 2
94049: PUSH
94050: LD_INT 1
94052: NEG
94053: PUSH
94054: EMPTY
94055: LIST
94056: LIST
94057: PUSH
94058: LD_INT 3
94060: PUSH
94061: LD_INT 0
94063: PUSH
94064: EMPTY
94065: LIST
94066: LIST
94067: PUSH
94068: LD_INT 3
94070: PUSH
94071: LD_INT 1
94073: PUSH
94074: EMPTY
94075: LIST
94076: LIST
94077: PUSH
94078: LD_INT 3
94080: PUSH
94081: LD_INT 1
94083: NEG
94084: PUSH
94085: EMPTY
94086: LIST
94087: LIST
94088: PUSH
94089: LD_INT 4
94091: PUSH
94092: LD_INT 0
94094: PUSH
94095: EMPTY
94096: LIST
94097: LIST
94098: PUSH
94099: LD_INT 4
94101: PUSH
94102: LD_INT 1
94104: PUSH
94105: EMPTY
94106: LIST
94107: LIST
94108: PUSH
94109: LD_INT 4
94111: PUSH
94112: LD_INT 1
94114: NEG
94115: PUSH
94116: EMPTY
94117: LIST
94118: LIST
94119: PUSH
94120: LD_INT 5
94122: PUSH
94123: LD_INT 0
94125: PUSH
94126: EMPTY
94127: LIST
94128: LIST
94129: PUSH
94130: LD_INT 5
94132: PUSH
94133: LD_INT 1
94135: PUSH
94136: EMPTY
94137: LIST
94138: LIST
94139: PUSH
94140: LD_INT 5
94142: PUSH
94143: LD_INT 1
94145: NEG
94146: PUSH
94147: EMPTY
94148: LIST
94149: LIST
94150: PUSH
94151: LD_INT 6
94153: PUSH
94154: LD_INT 0
94156: PUSH
94157: EMPTY
94158: LIST
94159: LIST
94160: PUSH
94161: LD_INT 6
94163: PUSH
94164: LD_INT 1
94166: PUSH
94167: EMPTY
94168: LIST
94169: LIST
94170: PUSH
94171: EMPTY
94172: LIST
94173: LIST
94174: LIST
94175: LIST
94176: LIST
94177: LIST
94178: LIST
94179: LIST
94180: LIST
94181: LIST
94182: LIST
94183: LIST
94184: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
94185: LD_ADDR_VAR 0 31
94189: PUSH
94190: LD_INT 3
94192: PUSH
94193: LD_INT 2
94195: PUSH
94196: EMPTY
94197: LIST
94198: LIST
94199: PUSH
94200: LD_INT 3
94202: PUSH
94203: LD_INT 3
94205: PUSH
94206: EMPTY
94207: LIST
94208: LIST
94209: PUSH
94210: LD_INT 2
94212: PUSH
94213: LD_INT 3
94215: PUSH
94216: EMPTY
94217: LIST
94218: LIST
94219: PUSH
94220: LD_INT 4
94222: PUSH
94223: LD_INT 3
94225: PUSH
94226: EMPTY
94227: LIST
94228: LIST
94229: PUSH
94230: LD_INT 4
94232: PUSH
94233: LD_INT 4
94235: PUSH
94236: EMPTY
94237: LIST
94238: LIST
94239: PUSH
94240: LD_INT 3
94242: PUSH
94243: LD_INT 4
94245: PUSH
94246: EMPTY
94247: LIST
94248: LIST
94249: PUSH
94250: LD_INT 5
94252: PUSH
94253: LD_INT 4
94255: PUSH
94256: EMPTY
94257: LIST
94258: LIST
94259: PUSH
94260: LD_INT 5
94262: PUSH
94263: LD_INT 5
94265: PUSH
94266: EMPTY
94267: LIST
94268: LIST
94269: PUSH
94270: LD_INT 4
94272: PUSH
94273: LD_INT 5
94275: PUSH
94276: EMPTY
94277: LIST
94278: LIST
94279: PUSH
94280: LD_INT 6
94282: PUSH
94283: LD_INT 5
94285: PUSH
94286: EMPTY
94287: LIST
94288: LIST
94289: PUSH
94290: LD_INT 6
94292: PUSH
94293: LD_INT 6
94295: PUSH
94296: EMPTY
94297: LIST
94298: LIST
94299: PUSH
94300: LD_INT 5
94302: PUSH
94303: LD_INT 6
94305: PUSH
94306: EMPTY
94307: LIST
94308: LIST
94309: PUSH
94310: EMPTY
94311: LIST
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: LIST
94318: LIST
94319: LIST
94320: LIST
94321: LIST
94322: LIST
94323: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
94324: LD_ADDR_VAR 0 32
94328: PUSH
94329: LD_INT 1
94331: PUSH
94332: LD_INT 3
94334: PUSH
94335: EMPTY
94336: LIST
94337: LIST
94338: PUSH
94339: LD_INT 0
94341: PUSH
94342: LD_INT 3
94344: PUSH
94345: EMPTY
94346: LIST
94347: LIST
94348: PUSH
94349: LD_INT 1
94351: NEG
94352: PUSH
94353: LD_INT 2
94355: PUSH
94356: EMPTY
94357: LIST
94358: LIST
94359: PUSH
94360: LD_INT 1
94362: PUSH
94363: LD_INT 4
94365: PUSH
94366: EMPTY
94367: LIST
94368: LIST
94369: PUSH
94370: LD_INT 0
94372: PUSH
94373: LD_INT 4
94375: PUSH
94376: EMPTY
94377: LIST
94378: LIST
94379: PUSH
94380: LD_INT 1
94382: NEG
94383: PUSH
94384: LD_INT 3
94386: PUSH
94387: EMPTY
94388: LIST
94389: LIST
94390: PUSH
94391: LD_INT 1
94393: PUSH
94394: LD_INT 5
94396: PUSH
94397: EMPTY
94398: LIST
94399: LIST
94400: PUSH
94401: LD_INT 0
94403: PUSH
94404: LD_INT 5
94406: PUSH
94407: EMPTY
94408: LIST
94409: LIST
94410: PUSH
94411: LD_INT 1
94413: NEG
94414: PUSH
94415: LD_INT 4
94417: PUSH
94418: EMPTY
94419: LIST
94420: LIST
94421: PUSH
94422: LD_INT 1
94424: PUSH
94425: LD_INT 6
94427: PUSH
94428: EMPTY
94429: LIST
94430: LIST
94431: PUSH
94432: LD_INT 0
94434: PUSH
94435: LD_INT 6
94437: PUSH
94438: EMPTY
94439: LIST
94440: LIST
94441: PUSH
94442: LD_INT 1
94444: NEG
94445: PUSH
94446: LD_INT 5
94448: PUSH
94449: EMPTY
94450: LIST
94451: LIST
94452: PUSH
94453: EMPTY
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: LIST
94462: LIST
94463: LIST
94464: LIST
94465: LIST
94466: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
94467: LD_ADDR_VAR 0 33
94471: PUSH
94472: LD_INT 2
94474: NEG
94475: PUSH
94476: LD_INT 1
94478: PUSH
94479: EMPTY
94480: LIST
94481: LIST
94482: PUSH
94483: LD_INT 3
94485: NEG
94486: PUSH
94487: LD_INT 0
94489: PUSH
94490: EMPTY
94491: LIST
94492: LIST
94493: PUSH
94494: LD_INT 3
94496: NEG
94497: PUSH
94498: LD_INT 1
94500: NEG
94501: PUSH
94502: EMPTY
94503: LIST
94504: LIST
94505: PUSH
94506: LD_INT 3
94508: NEG
94509: PUSH
94510: LD_INT 1
94512: PUSH
94513: EMPTY
94514: LIST
94515: LIST
94516: PUSH
94517: LD_INT 4
94519: NEG
94520: PUSH
94521: LD_INT 0
94523: PUSH
94524: EMPTY
94525: LIST
94526: LIST
94527: PUSH
94528: LD_INT 4
94530: NEG
94531: PUSH
94532: LD_INT 1
94534: NEG
94535: PUSH
94536: EMPTY
94537: LIST
94538: LIST
94539: PUSH
94540: LD_INT 4
94542: NEG
94543: PUSH
94544: LD_INT 1
94546: PUSH
94547: EMPTY
94548: LIST
94549: LIST
94550: PUSH
94551: LD_INT 5
94553: NEG
94554: PUSH
94555: LD_INT 0
94557: PUSH
94558: EMPTY
94559: LIST
94560: LIST
94561: PUSH
94562: LD_INT 5
94564: NEG
94565: PUSH
94566: LD_INT 1
94568: NEG
94569: PUSH
94570: EMPTY
94571: LIST
94572: LIST
94573: PUSH
94574: LD_INT 5
94576: NEG
94577: PUSH
94578: LD_INT 1
94580: PUSH
94581: EMPTY
94582: LIST
94583: LIST
94584: PUSH
94585: LD_INT 6
94587: NEG
94588: PUSH
94589: LD_INT 0
94591: PUSH
94592: EMPTY
94593: LIST
94594: LIST
94595: PUSH
94596: LD_INT 6
94598: NEG
94599: PUSH
94600: LD_INT 1
94602: NEG
94603: PUSH
94604: EMPTY
94605: LIST
94606: LIST
94607: PUSH
94608: EMPTY
94609: LIST
94610: LIST
94611: LIST
94612: LIST
94613: LIST
94614: LIST
94615: LIST
94616: LIST
94617: LIST
94618: LIST
94619: LIST
94620: LIST
94621: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
94622: LD_ADDR_VAR 0 34
94626: PUSH
94627: LD_INT 2
94629: NEG
94630: PUSH
94631: LD_INT 3
94633: NEG
94634: PUSH
94635: EMPTY
94636: LIST
94637: LIST
94638: PUSH
94639: LD_INT 3
94641: NEG
94642: PUSH
94643: LD_INT 2
94645: NEG
94646: PUSH
94647: EMPTY
94648: LIST
94649: LIST
94650: PUSH
94651: LD_INT 3
94653: NEG
94654: PUSH
94655: LD_INT 3
94657: NEG
94658: PUSH
94659: EMPTY
94660: LIST
94661: LIST
94662: PUSH
94663: LD_INT 3
94665: NEG
94666: PUSH
94667: LD_INT 4
94669: NEG
94670: PUSH
94671: EMPTY
94672: LIST
94673: LIST
94674: PUSH
94675: LD_INT 4
94677: NEG
94678: PUSH
94679: LD_INT 3
94681: NEG
94682: PUSH
94683: EMPTY
94684: LIST
94685: LIST
94686: PUSH
94687: LD_INT 4
94689: NEG
94690: PUSH
94691: LD_INT 4
94693: NEG
94694: PUSH
94695: EMPTY
94696: LIST
94697: LIST
94698: PUSH
94699: LD_INT 4
94701: NEG
94702: PUSH
94703: LD_INT 5
94705: NEG
94706: PUSH
94707: EMPTY
94708: LIST
94709: LIST
94710: PUSH
94711: LD_INT 5
94713: NEG
94714: PUSH
94715: LD_INT 4
94717: NEG
94718: PUSH
94719: EMPTY
94720: LIST
94721: LIST
94722: PUSH
94723: LD_INT 5
94725: NEG
94726: PUSH
94727: LD_INT 5
94729: NEG
94730: PUSH
94731: EMPTY
94732: LIST
94733: LIST
94734: PUSH
94735: LD_INT 5
94737: NEG
94738: PUSH
94739: LD_INT 6
94741: NEG
94742: PUSH
94743: EMPTY
94744: LIST
94745: LIST
94746: PUSH
94747: LD_INT 6
94749: NEG
94750: PUSH
94751: LD_INT 5
94753: NEG
94754: PUSH
94755: EMPTY
94756: LIST
94757: LIST
94758: PUSH
94759: LD_INT 6
94761: NEG
94762: PUSH
94763: LD_INT 6
94765: NEG
94766: PUSH
94767: EMPTY
94768: LIST
94769: LIST
94770: PUSH
94771: EMPTY
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: LIST
94778: LIST
94779: LIST
94780: LIST
94781: LIST
94782: LIST
94783: LIST
94784: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
94785: LD_ADDR_VAR 0 41
94789: PUSH
94790: LD_INT 0
94792: PUSH
94793: LD_INT 2
94795: NEG
94796: PUSH
94797: EMPTY
94798: LIST
94799: LIST
94800: PUSH
94801: LD_INT 1
94803: NEG
94804: PUSH
94805: LD_INT 3
94807: NEG
94808: PUSH
94809: EMPTY
94810: LIST
94811: LIST
94812: PUSH
94813: LD_INT 1
94815: PUSH
94816: LD_INT 2
94818: NEG
94819: PUSH
94820: EMPTY
94821: LIST
94822: LIST
94823: PUSH
94824: EMPTY
94825: LIST
94826: LIST
94827: LIST
94828: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
94829: LD_ADDR_VAR 0 42
94833: PUSH
94834: LD_INT 2
94836: PUSH
94837: LD_INT 0
94839: PUSH
94840: EMPTY
94841: LIST
94842: LIST
94843: PUSH
94844: LD_INT 2
94846: PUSH
94847: LD_INT 1
94849: NEG
94850: PUSH
94851: EMPTY
94852: LIST
94853: LIST
94854: PUSH
94855: LD_INT 3
94857: PUSH
94858: LD_INT 1
94860: PUSH
94861: EMPTY
94862: LIST
94863: LIST
94864: PUSH
94865: EMPTY
94866: LIST
94867: LIST
94868: LIST
94869: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
94870: LD_ADDR_VAR 0 43
94874: PUSH
94875: LD_INT 2
94877: PUSH
94878: LD_INT 2
94880: PUSH
94881: EMPTY
94882: LIST
94883: LIST
94884: PUSH
94885: LD_INT 3
94887: PUSH
94888: LD_INT 2
94890: PUSH
94891: EMPTY
94892: LIST
94893: LIST
94894: PUSH
94895: LD_INT 2
94897: PUSH
94898: LD_INT 3
94900: PUSH
94901: EMPTY
94902: LIST
94903: LIST
94904: PUSH
94905: EMPTY
94906: LIST
94907: LIST
94908: LIST
94909: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
94910: LD_ADDR_VAR 0 44
94914: PUSH
94915: LD_INT 0
94917: PUSH
94918: LD_INT 2
94920: PUSH
94921: EMPTY
94922: LIST
94923: LIST
94924: PUSH
94925: LD_INT 1
94927: PUSH
94928: LD_INT 3
94930: PUSH
94931: EMPTY
94932: LIST
94933: LIST
94934: PUSH
94935: LD_INT 1
94937: NEG
94938: PUSH
94939: LD_INT 2
94941: PUSH
94942: EMPTY
94943: LIST
94944: LIST
94945: PUSH
94946: EMPTY
94947: LIST
94948: LIST
94949: LIST
94950: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
94951: LD_ADDR_VAR 0 45
94955: PUSH
94956: LD_INT 2
94958: NEG
94959: PUSH
94960: LD_INT 0
94962: PUSH
94963: EMPTY
94964: LIST
94965: LIST
94966: PUSH
94967: LD_INT 2
94969: NEG
94970: PUSH
94971: LD_INT 1
94973: PUSH
94974: EMPTY
94975: LIST
94976: LIST
94977: PUSH
94978: LD_INT 3
94980: NEG
94981: PUSH
94982: LD_INT 1
94984: NEG
94985: PUSH
94986: EMPTY
94987: LIST
94988: LIST
94989: PUSH
94990: EMPTY
94991: LIST
94992: LIST
94993: LIST
94994: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
94995: LD_ADDR_VAR 0 46
94999: PUSH
95000: LD_INT 2
95002: NEG
95003: PUSH
95004: LD_INT 2
95006: NEG
95007: PUSH
95008: EMPTY
95009: LIST
95010: LIST
95011: PUSH
95012: LD_INT 2
95014: NEG
95015: PUSH
95016: LD_INT 3
95018: NEG
95019: PUSH
95020: EMPTY
95021: LIST
95022: LIST
95023: PUSH
95024: LD_INT 3
95026: NEG
95027: PUSH
95028: LD_INT 2
95030: NEG
95031: PUSH
95032: EMPTY
95033: LIST
95034: LIST
95035: PUSH
95036: EMPTY
95037: LIST
95038: LIST
95039: LIST
95040: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
95041: LD_ADDR_VAR 0 47
95045: PUSH
95046: LD_INT 2
95048: NEG
95049: PUSH
95050: LD_INT 3
95052: NEG
95053: PUSH
95054: EMPTY
95055: LIST
95056: LIST
95057: PUSH
95058: LD_INT 1
95060: NEG
95061: PUSH
95062: LD_INT 3
95064: NEG
95065: PUSH
95066: EMPTY
95067: LIST
95068: LIST
95069: PUSH
95070: EMPTY
95071: LIST
95072: LIST
95073: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
95074: LD_ADDR_VAR 0 48
95078: PUSH
95079: LD_INT 1
95081: PUSH
95082: LD_INT 2
95084: NEG
95085: PUSH
95086: EMPTY
95087: LIST
95088: LIST
95089: PUSH
95090: LD_INT 2
95092: PUSH
95093: LD_INT 1
95095: NEG
95096: PUSH
95097: EMPTY
95098: LIST
95099: LIST
95100: PUSH
95101: EMPTY
95102: LIST
95103: LIST
95104: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
95105: LD_ADDR_VAR 0 49
95109: PUSH
95110: LD_INT 3
95112: PUSH
95113: LD_INT 1
95115: PUSH
95116: EMPTY
95117: LIST
95118: LIST
95119: PUSH
95120: LD_INT 3
95122: PUSH
95123: LD_INT 2
95125: PUSH
95126: EMPTY
95127: LIST
95128: LIST
95129: PUSH
95130: EMPTY
95131: LIST
95132: LIST
95133: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
95134: LD_ADDR_VAR 0 50
95138: PUSH
95139: LD_INT 2
95141: PUSH
95142: LD_INT 3
95144: PUSH
95145: EMPTY
95146: LIST
95147: LIST
95148: PUSH
95149: LD_INT 1
95151: PUSH
95152: LD_INT 3
95154: PUSH
95155: EMPTY
95156: LIST
95157: LIST
95158: PUSH
95159: EMPTY
95160: LIST
95161: LIST
95162: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
95163: LD_ADDR_VAR 0 51
95167: PUSH
95168: LD_INT 1
95170: NEG
95171: PUSH
95172: LD_INT 2
95174: PUSH
95175: EMPTY
95176: LIST
95177: LIST
95178: PUSH
95179: LD_INT 2
95181: NEG
95182: PUSH
95183: LD_INT 1
95185: PUSH
95186: EMPTY
95187: LIST
95188: LIST
95189: PUSH
95190: EMPTY
95191: LIST
95192: LIST
95193: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
95194: LD_ADDR_VAR 0 52
95198: PUSH
95199: LD_INT 3
95201: NEG
95202: PUSH
95203: LD_INT 1
95205: NEG
95206: PUSH
95207: EMPTY
95208: LIST
95209: LIST
95210: PUSH
95211: LD_INT 3
95213: NEG
95214: PUSH
95215: LD_INT 2
95217: NEG
95218: PUSH
95219: EMPTY
95220: LIST
95221: LIST
95222: PUSH
95223: EMPTY
95224: LIST
95225: LIST
95226: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
95227: LD_ADDR_VAR 0 53
95231: PUSH
95232: LD_INT 1
95234: NEG
95235: PUSH
95236: LD_INT 3
95238: NEG
95239: PUSH
95240: EMPTY
95241: LIST
95242: LIST
95243: PUSH
95244: LD_INT 0
95246: PUSH
95247: LD_INT 3
95249: NEG
95250: PUSH
95251: EMPTY
95252: LIST
95253: LIST
95254: PUSH
95255: LD_INT 1
95257: PUSH
95258: LD_INT 2
95260: NEG
95261: PUSH
95262: EMPTY
95263: LIST
95264: LIST
95265: PUSH
95266: EMPTY
95267: LIST
95268: LIST
95269: LIST
95270: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
95271: LD_ADDR_VAR 0 54
95275: PUSH
95276: LD_INT 2
95278: PUSH
95279: LD_INT 1
95281: NEG
95282: PUSH
95283: EMPTY
95284: LIST
95285: LIST
95286: PUSH
95287: LD_INT 3
95289: PUSH
95290: LD_INT 0
95292: PUSH
95293: EMPTY
95294: LIST
95295: LIST
95296: PUSH
95297: LD_INT 3
95299: PUSH
95300: LD_INT 1
95302: PUSH
95303: EMPTY
95304: LIST
95305: LIST
95306: PUSH
95307: EMPTY
95308: LIST
95309: LIST
95310: LIST
95311: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
95312: LD_ADDR_VAR 0 55
95316: PUSH
95317: LD_INT 3
95319: PUSH
95320: LD_INT 2
95322: PUSH
95323: EMPTY
95324: LIST
95325: LIST
95326: PUSH
95327: LD_INT 3
95329: PUSH
95330: LD_INT 3
95332: PUSH
95333: EMPTY
95334: LIST
95335: LIST
95336: PUSH
95337: LD_INT 2
95339: PUSH
95340: LD_INT 3
95342: PUSH
95343: EMPTY
95344: LIST
95345: LIST
95346: PUSH
95347: EMPTY
95348: LIST
95349: LIST
95350: LIST
95351: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
95352: LD_ADDR_VAR 0 56
95356: PUSH
95357: LD_INT 1
95359: PUSH
95360: LD_INT 3
95362: PUSH
95363: EMPTY
95364: LIST
95365: LIST
95366: PUSH
95367: LD_INT 0
95369: PUSH
95370: LD_INT 3
95372: PUSH
95373: EMPTY
95374: LIST
95375: LIST
95376: PUSH
95377: LD_INT 1
95379: NEG
95380: PUSH
95381: LD_INT 2
95383: PUSH
95384: EMPTY
95385: LIST
95386: LIST
95387: PUSH
95388: EMPTY
95389: LIST
95390: LIST
95391: LIST
95392: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
95393: LD_ADDR_VAR 0 57
95397: PUSH
95398: LD_INT 2
95400: NEG
95401: PUSH
95402: LD_INT 1
95404: PUSH
95405: EMPTY
95406: LIST
95407: LIST
95408: PUSH
95409: LD_INT 3
95411: NEG
95412: PUSH
95413: LD_INT 0
95415: PUSH
95416: EMPTY
95417: LIST
95418: LIST
95419: PUSH
95420: LD_INT 3
95422: NEG
95423: PUSH
95424: LD_INT 1
95426: NEG
95427: PUSH
95428: EMPTY
95429: LIST
95430: LIST
95431: PUSH
95432: EMPTY
95433: LIST
95434: LIST
95435: LIST
95436: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
95437: LD_ADDR_VAR 0 58
95441: PUSH
95442: LD_INT 2
95444: NEG
95445: PUSH
95446: LD_INT 3
95448: NEG
95449: PUSH
95450: EMPTY
95451: LIST
95452: LIST
95453: PUSH
95454: LD_INT 3
95456: NEG
95457: PUSH
95458: LD_INT 2
95460: NEG
95461: PUSH
95462: EMPTY
95463: LIST
95464: LIST
95465: PUSH
95466: LD_INT 3
95468: NEG
95469: PUSH
95470: LD_INT 3
95472: NEG
95473: PUSH
95474: EMPTY
95475: LIST
95476: LIST
95477: PUSH
95478: EMPTY
95479: LIST
95480: LIST
95481: LIST
95482: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
95483: LD_ADDR_VAR 0 59
95487: PUSH
95488: LD_INT 1
95490: NEG
95491: PUSH
95492: LD_INT 2
95494: NEG
95495: PUSH
95496: EMPTY
95497: LIST
95498: LIST
95499: PUSH
95500: LD_INT 0
95502: PUSH
95503: LD_INT 2
95505: NEG
95506: PUSH
95507: EMPTY
95508: LIST
95509: LIST
95510: PUSH
95511: LD_INT 1
95513: PUSH
95514: LD_INT 1
95516: NEG
95517: PUSH
95518: EMPTY
95519: LIST
95520: LIST
95521: PUSH
95522: EMPTY
95523: LIST
95524: LIST
95525: LIST
95526: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
95527: LD_ADDR_VAR 0 60
95531: PUSH
95532: LD_INT 1
95534: PUSH
95535: LD_INT 1
95537: NEG
95538: PUSH
95539: EMPTY
95540: LIST
95541: LIST
95542: PUSH
95543: LD_INT 2
95545: PUSH
95546: LD_INT 0
95548: PUSH
95549: EMPTY
95550: LIST
95551: LIST
95552: PUSH
95553: LD_INT 2
95555: PUSH
95556: LD_INT 1
95558: PUSH
95559: EMPTY
95560: LIST
95561: LIST
95562: PUSH
95563: EMPTY
95564: LIST
95565: LIST
95566: LIST
95567: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
95568: LD_ADDR_VAR 0 61
95572: PUSH
95573: LD_INT 2
95575: PUSH
95576: LD_INT 1
95578: PUSH
95579: EMPTY
95580: LIST
95581: LIST
95582: PUSH
95583: LD_INT 2
95585: PUSH
95586: LD_INT 2
95588: PUSH
95589: EMPTY
95590: LIST
95591: LIST
95592: PUSH
95593: LD_INT 1
95595: PUSH
95596: LD_INT 2
95598: PUSH
95599: EMPTY
95600: LIST
95601: LIST
95602: PUSH
95603: EMPTY
95604: LIST
95605: LIST
95606: LIST
95607: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
95608: LD_ADDR_VAR 0 62
95612: PUSH
95613: LD_INT 1
95615: PUSH
95616: LD_INT 2
95618: PUSH
95619: EMPTY
95620: LIST
95621: LIST
95622: PUSH
95623: LD_INT 0
95625: PUSH
95626: LD_INT 2
95628: PUSH
95629: EMPTY
95630: LIST
95631: LIST
95632: PUSH
95633: LD_INT 1
95635: NEG
95636: PUSH
95637: LD_INT 1
95639: PUSH
95640: EMPTY
95641: LIST
95642: LIST
95643: PUSH
95644: EMPTY
95645: LIST
95646: LIST
95647: LIST
95648: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
95649: LD_ADDR_VAR 0 63
95653: PUSH
95654: LD_INT 1
95656: NEG
95657: PUSH
95658: LD_INT 1
95660: PUSH
95661: EMPTY
95662: LIST
95663: LIST
95664: PUSH
95665: LD_INT 2
95667: NEG
95668: PUSH
95669: LD_INT 0
95671: PUSH
95672: EMPTY
95673: LIST
95674: LIST
95675: PUSH
95676: LD_INT 2
95678: NEG
95679: PUSH
95680: LD_INT 1
95682: NEG
95683: PUSH
95684: EMPTY
95685: LIST
95686: LIST
95687: PUSH
95688: EMPTY
95689: LIST
95690: LIST
95691: LIST
95692: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95693: LD_ADDR_VAR 0 64
95697: PUSH
95698: LD_INT 1
95700: NEG
95701: PUSH
95702: LD_INT 2
95704: NEG
95705: PUSH
95706: EMPTY
95707: LIST
95708: LIST
95709: PUSH
95710: LD_INT 2
95712: NEG
95713: PUSH
95714: LD_INT 1
95716: NEG
95717: PUSH
95718: EMPTY
95719: LIST
95720: LIST
95721: PUSH
95722: LD_INT 2
95724: NEG
95725: PUSH
95726: LD_INT 2
95728: NEG
95729: PUSH
95730: EMPTY
95731: LIST
95732: LIST
95733: PUSH
95734: EMPTY
95735: LIST
95736: LIST
95737: LIST
95738: ST_TO_ADDR
// end ; 2 :
95739: GO 99005
95741: LD_INT 2
95743: DOUBLE
95744: EQUAL
95745: IFTRUE 95749
95747: GO 99004
95749: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
95750: LD_ADDR_VAR 0 29
95754: PUSH
95755: LD_INT 4
95757: PUSH
95758: LD_INT 0
95760: PUSH
95761: EMPTY
95762: LIST
95763: LIST
95764: PUSH
95765: LD_INT 4
95767: PUSH
95768: LD_INT 1
95770: NEG
95771: PUSH
95772: EMPTY
95773: LIST
95774: LIST
95775: PUSH
95776: LD_INT 5
95778: PUSH
95779: LD_INT 0
95781: PUSH
95782: EMPTY
95783: LIST
95784: LIST
95785: PUSH
95786: LD_INT 5
95788: PUSH
95789: LD_INT 1
95791: PUSH
95792: EMPTY
95793: LIST
95794: LIST
95795: PUSH
95796: LD_INT 4
95798: PUSH
95799: LD_INT 1
95801: PUSH
95802: EMPTY
95803: LIST
95804: LIST
95805: PUSH
95806: LD_INT 3
95808: PUSH
95809: LD_INT 0
95811: PUSH
95812: EMPTY
95813: LIST
95814: LIST
95815: PUSH
95816: LD_INT 3
95818: PUSH
95819: LD_INT 1
95821: NEG
95822: PUSH
95823: EMPTY
95824: LIST
95825: LIST
95826: PUSH
95827: LD_INT 3
95829: PUSH
95830: LD_INT 2
95832: NEG
95833: PUSH
95834: EMPTY
95835: LIST
95836: LIST
95837: PUSH
95838: LD_INT 5
95840: PUSH
95841: LD_INT 2
95843: PUSH
95844: EMPTY
95845: LIST
95846: LIST
95847: PUSH
95848: LD_INT 3
95850: PUSH
95851: LD_INT 3
95853: PUSH
95854: EMPTY
95855: LIST
95856: LIST
95857: PUSH
95858: LD_INT 3
95860: PUSH
95861: LD_INT 2
95863: PUSH
95864: EMPTY
95865: LIST
95866: LIST
95867: PUSH
95868: LD_INT 4
95870: PUSH
95871: LD_INT 3
95873: PUSH
95874: EMPTY
95875: LIST
95876: LIST
95877: PUSH
95878: LD_INT 4
95880: PUSH
95881: LD_INT 4
95883: PUSH
95884: EMPTY
95885: LIST
95886: LIST
95887: PUSH
95888: LD_INT 3
95890: PUSH
95891: LD_INT 4
95893: PUSH
95894: EMPTY
95895: LIST
95896: LIST
95897: PUSH
95898: LD_INT 2
95900: PUSH
95901: LD_INT 3
95903: PUSH
95904: EMPTY
95905: LIST
95906: LIST
95907: PUSH
95908: LD_INT 2
95910: PUSH
95911: LD_INT 2
95913: PUSH
95914: EMPTY
95915: LIST
95916: LIST
95917: PUSH
95918: LD_INT 4
95920: PUSH
95921: LD_INT 2
95923: PUSH
95924: EMPTY
95925: LIST
95926: LIST
95927: PUSH
95928: LD_INT 2
95930: PUSH
95931: LD_INT 4
95933: PUSH
95934: EMPTY
95935: LIST
95936: LIST
95937: PUSH
95938: LD_INT 0
95940: PUSH
95941: LD_INT 4
95943: PUSH
95944: EMPTY
95945: LIST
95946: LIST
95947: PUSH
95948: LD_INT 0
95950: PUSH
95951: LD_INT 3
95953: PUSH
95954: EMPTY
95955: LIST
95956: LIST
95957: PUSH
95958: LD_INT 1
95960: PUSH
95961: LD_INT 4
95963: PUSH
95964: EMPTY
95965: LIST
95966: LIST
95967: PUSH
95968: LD_INT 1
95970: PUSH
95971: LD_INT 5
95973: PUSH
95974: EMPTY
95975: LIST
95976: LIST
95977: PUSH
95978: LD_INT 0
95980: PUSH
95981: LD_INT 5
95983: PUSH
95984: EMPTY
95985: LIST
95986: LIST
95987: PUSH
95988: LD_INT 1
95990: NEG
95991: PUSH
95992: LD_INT 4
95994: PUSH
95995: EMPTY
95996: LIST
95997: LIST
95998: PUSH
95999: LD_INT 1
96001: NEG
96002: PUSH
96003: LD_INT 3
96005: PUSH
96006: EMPTY
96007: LIST
96008: LIST
96009: PUSH
96010: LD_INT 2
96012: PUSH
96013: LD_INT 5
96015: PUSH
96016: EMPTY
96017: LIST
96018: LIST
96019: PUSH
96020: LD_INT 2
96022: NEG
96023: PUSH
96024: LD_INT 3
96026: PUSH
96027: EMPTY
96028: LIST
96029: LIST
96030: PUSH
96031: LD_INT 3
96033: NEG
96034: PUSH
96035: LD_INT 0
96037: PUSH
96038: EMPTY
96039: LIST
96040: LIST
96041: PUSH
96042: LD_INT 3
96044: NEG
96045: PUSH
96046: LD_INT 1
96048: NEG
96049: PUSH
96050: EMPTY
96051: LIST
96052: LIST
96053: PUSH
96054: LD_INT 2
96056: NEG
96057: PUSH
96058: LD_INT 0
96060: PUSH
96061: EMPTY
96062: LIST
96063: LIST
96064: PUSH
96065: LD_INT 2
96067: NEG
96068: PUSH
96069: LD_INT 1
96071: PUSH
96072: EMPTY
96073: LIST
96074: LIST
96075: PUSH
96076: LD_INT 3
96078: NEG
96079: PUSH
96080: LD_INT 1
96082: PUSH
96083: EMPTY
96084: LIST
96085: LIST
96086: PUSH
96087: LD_INT 4
96089: NEG
96090: PUSH
96091: LD_INT 0
96093: PUSH
96094: EMPTY
96095: LIST
96096: LIST
96097: PUSH
96098: LD_INT 4
96100: NEG
96101: PUSH
96102: LD_INT 1
96104: NEG
96105: PUSH
96106: EMPTY
96107: LIST
96108: LIST
96109: PUSH
96110: LD_INT 4
96112: NEG
96113: PUSH
96114: LD_INT 2
96116: NEG
96117: PUSH
96118: EMPTY
96119: LIST
96120: LIST
96121: PUSH
96122: LD_INT 2
96124: NEG
96125: PUSH
96126: LD_INT 2
96128: PUSH
96129: EMPTY
96130: LIST
96131: LIST
96132: PUSH
96133: LD_INT 4
96135: NEG
96136: PUSH
96137: LD_INT 4
96139: NEG
96140: PUSH
96141: EMPTY
96142: LIST
96143: LIST
96144: PUSH
96145: LD_INT 4
96147: NEG
96148: PUSH
96149: LD_INT 5
96151: NEG
96152: PUSH
96153: EMPTY
96154: LIST
96155: LIST
96156: PUSH
96157: LD_INT 3
96159: NEG
96160: PUSH
96161: LD_INT 4
96163: NEG
96164: PUSH
96165: EMPTY
96166: LIST
96167: LIST
96168: PUSH
96169: LD_INT 3
96171: NEG
96172: PUSH
96173: LD_INT 3
96175: NEG
96176: PUSH
96177: EMPTY
96178: LIST
96179: LIST
96180: PUSH
96181: LD_INT 4
96183: NEG
96184: PUSH
96185: LD_INT 3
96187: NEG
96188: PUSH
96189: EMPTY
96190: LIST
96191: LIST
96192: PUSH
96193: LD_INT 5
96195: NEG
96196: PUSH
96197: LD_INT 4
96199: NEG
96200: PUSH
96201: EMPTY
96202: LIST
96203: LIST
96204: PUSH
96205: LD_INT 5
96207: NEG
96208: PUSH
96209: LD_INT 5
96211: NEG
96212: PUSH
96213: EMPTY
96214: LIST
96215: LIST
96216: PUSH
96217: LD_INT 3
96219: NEG
96220: PUSH
96221: LD_INT 5
96223: NEG
96224: PUSH
96225: EMPTY
96226: LIST
96227: LIST
96228: PUSH
96229: LD_INT 5
96231: NEG
96232: PUSH
96233: LD_INT 3
96235: NEG
96236: PUSH
96237: EMPTY
96238: LIST
96239: LIST
96240: PUSH
96241: EMPTY
96242: LIST
96243: LIST
96244: LIST
96245: LIST
96246: LIST
96247: LIST
96248: LIST
96249: LIST
96250: LIST
96251: LIST
96252: LIST
96253: LIST
96254: LIST
96255: LIST
96256: LIST
96257: LIST
96258: LIST
96259: LIST
96260: LIST
96261: LIST
96262: LIST
96263: LIST
96264: LIST
96265: LIST
96266: LIST
96267: LIST
96268: LIST
96269: LIST
96270: LIST
96271: LIST
96272: LIST
96273: LIST
96274: LIST
96275: LIST
96276: LIST
96277: LIST
96278: LIST
96279: LIST
96280: LIST
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: LIST
96287: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
96288: LD_ADDR_VAR 0 30
96292: PUSH
96293: LD_INT 4
96295: PUSH
96296: LD_INT 4
96298: PUSH
96299: EMPTY
96300: LIST
96301: LIST
96302: PUSH
96303: LD_INT 4
96305: PUSH
96306: LD_INT 3
96308: PUSH
96309: EMPTY
96310: LIST
96311: LIST
96312: PUSH
96313: LD_INT 5
96315: PUSH
96316: LD_INT 4
96318: PUSH
96319: EMPTY
96320: LIST
96321: LIST
96322: PUSH
96323: LD_INT 5
96325: PUSH
96326: LD_INT 5
96328: PUSH
96329: EMPTY
96330: LIST
96331: LIST
96332: PUSH
96333: LD_INT 4
96335: PUSH
96336: LD_INT 5
96338: PUSH
96339: EMPTY
96340: LIST
96341: LIST
96342: PUSH
96343: LD_INT 3
96345: PUSH
96346: LD_INT 4
96348: PUSH
96349: EMPTY
96350: LIST
96351: LIST
96352: PUSH
96353: LD_INT 3
96355: PUSH
96356: LD_INT 3
96358: PUSH
96359: EMPTY
96360: LIST
96361: LIST
96362: PUSH
96363: LD_INT 5
96365: PUSH
96366: LD_INT 3
96368: PUSH
96369: EMPTY
96370: LIST
96371: LIST
96372: PUSH
96373: LD_INT 3
96375: PUSH
96376: LD_INT 5
96378: PUSH
96379: EMPTY
96380: LIST
96381: LIST
96382: PUSH
96383: LD_INT 0
96385: PUSH
96386: LD_INT 3
96388: PUSH
96389: EMPTY
96390: LIST
96391: LIST
96392: PUSH
96393: LD_INT 0
96395: PUSH
96396: LD_INT 2
96398: PUSH
96399: EMPTY
96400: LIST
96401: LIST
96402: PUSH
96403: LD_INT 1
96405: PUSH
96406: LD_INT 3
96408: PUSH
96409: EMPTY
96410: LIST
96411: LIST
96412: PUSH
96413: LD_INT 1
96415: PUSH
96416: LD_INT 4
96418: PUSH
96419: EMPTY
96420: LIST
96421: LIST
96422: PUSH
96423: LD_INT 0
96425: PUSH
96426: LD_INT 4
96428: PUSH
96429: EMPTY
96430: LIST
96431: LIST
96432: PUSH
96433: LD_INT 1
96435: NEG
96436: PUSH
96437: LD_INT 3
96439: PUSH
96440: EMPTY
96441: LIST
96442: LIST
96443: PUSH
96444: LD_INT 1
96446: NEG
96447: PUSH
96448: LD_INT 2
96450: PUSH
96451: EMPTY
96452: LIST
96453: LIST
96454: PUSH
96455: LD_INT 2
96457: PUSH
96458: LD_INT 4
96460: PUSH
96461: EMPTY
96462: LIST
96463: LIST
96464: PUSH
96465: LD_INT 2
96467: NEG
96468: PUSH
96469: LD_INT 2
96471: PUSH
96472: EMPTY
96473: LIST
96474: LIST
96475: PUSH
96476: LD_INT 4
96478: NEG
96479: PUSH
96480: LD_INT 0
96482: PUSH
96483: EMPTY
96484: LIST
96485: LIST
96486: PUSH
96487: LD_INT 4
96489: NEG
96490: PUSH
96491: LD_INT 1
96493: NEG
96494: PUSH
96495: EMPTY
96496: LIST
96497: LIST
96498: PUSH
96499: LD_INT 3
96501: NEG
96502: PUSH
96503: LD_INT 0
96505: PUSH
96506: EMPTY
96507: LIST
96508: LIST
96509: PUSH
96510: LD_INT 3
96512: NEG
96513: PUSH
96514: LD_INT 1
96516: PUSH
96517: EMPTY
96518: LIST
96519: LIST
96520: PUSH
96521: LD_INT 4
96523: NEG
96524: PUSH
96525: LD_INT 1
96527: PUSH
96528: EMPTY
96529: LIST
96530: LIST
96531: PUSH
96532: LD_INT 5
96534: NEG
96535: PUSH
96536: LD_INT 0
96538: PUSH
96539: EMPTY
96540: LIST
96541: LIST
96542: PUSH
96543: LD_INT 5
96545: NEG
96546: PUSH
96547: LD_INT 1
96549: NEG
96550: PUSH
96551: EMPTY
96552: LIST
96553: LIST
96554: PUSH
96555: LD_INT 5
96557: NEG
96558: PUSH
96559: LD_INT 2
96561: NEG
96562: PUSH
96563: EMPTY
96564: LIST
96565: LIST
96566: PUSH
96567: LD_INT 3
96569: NEG
96570: PUSH
96571: LD_INT 2
96573: PUSH
96574: EMPTY
96575: LIST
96576: LIST
96577: PUSH
96578: LD_INT 3
96580: NEG
96581: PUSH
96582: LD_INT 3
96584: NEG
96585: PUSH
96586: EMPTY
96587: LIST
96588: LIST
96589: PUSH
96590: LD_INT 3
96592: NEG
96593: PUSH
96594: LD_INT 4
96596: NEG
96597: PUSH
96598: EMPTY
96599: LIST
96600: LIST
96601: PUSH
96602: LD_INT 2
96604: NEG
96605: PUSH
96606: LD_INT 3
96608: NEG
96609: PUSH
96610: EMPTY
96611: LIST
96612: LIST
96613: PUSH
96614: LD_INT 2
96616: NEG
96617: PUSH
96618: LD_INT 2
96620: NEG
96621: PUSH
96622: EMPTY
96623: LIST
96624: LIST
96625: PUSH
96626: LD_INT 3
96628: NEG
96629: PUSH
96630: LD_INT 2
96632: NEG
96633: PUSH
96634: EMPTY
96635: LIST
96636: LIST
96637: PUSH
96638: LD_INT 4
96640: NEG
96641: PUSH
96642: LD_INT 3
96644: NEG
96645: PUSH
96646: EMPTY
96647: LIST
96648: LIST
96649: PUSH
96650: LD_INT 4
96652: NEG
96653: PUSH
96654: LD_INT 4
96656: NEG
96657: PUSH
96658: EMPTY
96659: LIST
96660: LIST
96661: PUSH
96662: LD_INT 2
96664: NEG
96665: PUSH
96666: LD_INT 4
96668: NEG
96669: PUSH
96670: EMPTY
96671: LIST
96672: LIST
96673: PUSH
96674: LD_INT 4
96676: NEG
96677: PUSH
96678: LD_INT 2
96680: NEG
96681: PUSH
96682: EMPTY
96683: LIST
96684: LIST
96685: PUSH
96686: LD_INT 0
96688: PUSH
96689: LD_INT 4
96691: NEG
96692: PUSH
96693: EMPTY
96694: LIST
96695: LIST
96696: PUSH
96697: LD_INT 0
96699: PUSH
96700: LD_INT 5
96702: NEG
96703: PUSH
96704: EMPTY
96705: LIST
96706: LIST
96707: PUSH
96708: LD_INT 1
96710: PUSH
96711: LD_INT 4
96713: NEG
96714: PUSH
96715: EMPTY
96716: LIST
96717: LIST
96718: PUSH
96719: LD_INT 1
96721: PUSH
96722: LD_INT 3
96724: NEG
96725: PUSH
96726: EMPTY
96727: LIST
96728: LIST
96729: PUSH
96730: LD_INT 0
96732: PUSH
96733: LD_INT 3
96735: NEG
96736: PUSH
96737: EMPTY
96738: LIST
96739: LIST
96740: PUSH
96741: LD_INT 1
96743: NEG
96744: PUSH
96745: LD_INT 4
96747: NEG
96748: PUSH
96749: EMPTY
96750: LIST
96751: LIST
96752: PUSH
96753: LD_INT 1
96755: NEG
96756: PUSH
96757: LD_INT 5
96759: NEG
96760: PUSH
96761: EMPTY
96762: LIST
96763: LIST
96764: PUSH
96765: LD_INT 2
96767: PUSH
96768: LD_INT 3
96770: NEG
96771: PUSH
96772: EMPTY
96773: LIST
96774: LIST
96775: PUSH
96776: LD_INT 2
96778: NEG
96779: PUSH
96780: LD_INT 5
96782: NEG
96783: PUSH
96784: EMPTY
96785: LIST
96786: LIST
96787: PUSH
96788: EMPTY
96789: LIST
96790: LIST
96791: LIST
96792: LIST
96793: LIST
96794: LIST
96795: LIST
96796: LIST
96797: LIST
96798: LIST
96799: LIST
96800: LIST
96801: LIST
96802: LIST
96803: LIST
96804: LIST
96805: LIST
96806: LIST
96807: LIST
96808: LIST
96809: LIST
96810: LIST
96811: LIST
96812: LIST
96813: LIST
96814: LIST
96815: LIST
96816: LIST
96817: LIST
96818: LIST
96819: LIST
96820: LIST
96821: LIST
96822: LIST
96823: LIST
96824: LIST
96825: LIST
96826: LIST
96827: LIST
96828: LIST
96829: LIST
96830: LIST
96831: LIST
96832: LIST
96833: LIST
96834: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
96835: LD_ADDR_VAR 0 31
96839: PUSH
96840: LD_INT 0
96842: PUSH
96843: LD_INT 4
96845: PUSH
96846: EMPTY
96847: LIST
96848: LIST
96849: PUSH
96850: LD_INT 0
96852: PUSH
96853: LD_INT 3
96855: PUSH
96856: EMPTY
96857: LIST
96858: LIST
96859: PUSH
96860: LD_INT 1
96862: PUSH
96863: LD_INT 4
96865: PUSH
96866: EMPTY
96867: LIST
96868: LIST
96869: PUSH
96870: LD_INT 1
96872: PUSH
96873: LD_INT 5
96875: PUSH
96876: EMPTY
96877: LIST
96878: LIST
96879: PUSH
96880: LD_INT 0
96882: PUSH
96883: LD_INT 5
96885: PUSH
96886: EMPTY
96887: LIST
96888: LIST
96889: PUSH
96890: LD_INT 1
96892: NEG
96893: PUSH
96894: LD_INT 4
96896: PUSH
96897: EMPTY
96898: LIST
96899: LIST
96900: PUSH
96901: LD_INT 1
96903: NEG
96904: PUSH
96905: LD_INT 3
96907: PUSH
96908: EMPTY
96909: LIST
96910: LIST
96911: PUSH
96912: LD_INT 2
96914: PUSH
96915: LD_INT 5
96917: PUSH
96918: EMPTY
96919: LIST
96920: LIST
96921: PUSH
96922: LD_INT 2
96924: NEG
96925: PUSH
96926: LD_INT 3
96928: PUSH
96929: EMPTY
96930: LIST
96931: LIST
96932: PUSH
96933: LD_INT 3
96935: NEG
96936: PUSH
96937: LD_INT 0
96939: PUSH
96940: EMPTY
96941: LIST
96942: LIST
96943: PUSH
96944: LD_INT 3
96946: NEG
96947: PUSH
96948: LD_INT 1
96950: NEG
96951: PUSH
96952: EMPTY
96953: LIST
96954: LIST
96955: PUSH
96956: LD_INT 2
96958: NEG
96959: PUSH
96960: LD_INT 0
96962: PUSH
96963: EMPTY
96964: LIST
96965: LIST
96966: PUSH
96967: LD_INT 2
96969: NEG
96970: PUSH
96971: LD_INT 1
96973: PUSH
96974: EMPTY
96975: LIST
96976: LIST
96977: PUSH
96978: LD_INT 3
96980: NEG
96981: PUSH
96982: LD_INT 1
96984: PUSH
96985: EMPTY
96986: LIST
96987: LIST
96988: PUSH
96989: LD_INT 4
96991: NEG
96992: PUSH
96993: LD_INT 0
96995: PUSH
96996: EMPTY
96997: LIST
96998: LIST
96999: PUSH
97000: LD_INT 4
97002: NEG
97003: PUSH
97004: LD_INT 1
97006: NEG
97007: PUSH
97008: EMPTY
97009: LIST
97010: LIST
97011: PUSH
97012: LD_INT 4
97014: NEG
97015: PUSH
97016: LD_INT 2
97018: NEG
97019: PUSH
97020: EMPTY
97021: LIST
97022: LIST
97023: PUSH
97024: LD_INT 2
97026: NEG
97027: PUSH
97028: LD_INT 2
97030: PUSH
97031: EMPTY
97032: LIST
97033: LIST
97034: PUSH
97035: LD_INT 4
97037: NEG
97038: PUSH
97039: LD_INT 4
97041: NEG
97042: PUSH
97043: EMPTY
97044: LIST
97045: LIST
97046: PUSH
97047: LD_INT 4
97049: NEG
97050: PUSH
97051: LD_INT 5
97053: NEG
97054: PUSH
97055: EMPTY
97056: LIST
97057: LIST
97058: PUSH
97059: LD_INT 3
97061: NEG
97062: PUSH
97063: LD_INT 4
97065: NEG
97066: PUSH
97067: EMPTY
97068: LIST
97069: LIST
97070: PUSH
97071: LD_INT 3
97073: NEG
97074: PUSH
97075: LD_INT 3
97077: NEG
97078: PUSH
97079: EMPTY
97080: LIST
97081: LIST
97082: PUSH
97083: LD_INT 4
97085: NEG
97086: PUSH
97087: LD_INT 3
97089: NEG
97090: PUSH
97091: EMPTY
97092: LIST
97093: LIST
97094: PUSH
97095: LD_INT 5
97097: NEG
97098: PUSH
97099: LD_INT 4
97101: NEG
97102: PUSH
97103: EMPTY
97104: LIST
97105: LIST
97106: PUSH
97107: LD_INT 5
97109: NEG
97110: PUSH
97111: LD_INT 5
97113: NEG
97114: PUSH
97115: EMPTY
97116: LIST
97117: LIST
97118: PUSH
97119: LD_INT 3
97121: NEG
97122: PUSH
97123: LD_INT 5
97125: NEG
97126: PUSH
97127: EMPTY
97128: LIST
97129: LIST
97130: PUSH
97131: LD_INT 5
97133: NEG
97134: PUSH
97135: LD_INT 3
97137: NEG
97138: PUSH
97139: EMPTY
97140: LIST
97141: LIST
97142: PUSH
97143: LD_INT 0
97145: PUSH
97146: LD_INT 3
97148: NEG
97149: PUSH
97150: EMPTY
97151: LIST
97152: LIST
97153: PUSH
97154: LD_INT 0
97156: PUSH
97157: LD_INT 4
97159: NEG
97160: PUSH
97161: EMPTY
97162: LIST
97163: LIST
97164: PUSH
97165: LD_INT 1
97167: PUSH
97168: LD_INT 3
97170: NEG
97171: PUSH
97172: EMPTY
97173: LIST
97174: LIST
97175: PUSH
97176: LD_INT 1
97178: PUSH
97179: LD_INT 2
97181: NEG
97182: PUSH
97183: EMPTY
97184: LIST
97185: LIST
97186: PUSH
97187: LD_INT 0
97189: PUSH
97190: LD_INT 2
97192: NEG
97193: PUSH
97194: EMPTY
97195: LIST
97196: LIST
97197: PUSH
97198: LD_INT 1
97200: NEG
97201: PUSH
97202: LD_INT 3
97204: NEG
97205: PUSH
97206: EMPTY
97207: LIST
97208: LIST
97209: PUSH
97210: LD_INT 1
97212: NEG
97213: PUSH
97214: LD_INT 4
97216: NEG
97217: PUSH
97218: EMPTY
97219: LIST
97220: LIST
97221: PUSH
97222: LD_INT 2
97224: PUSH
97225: LD_INT 2
97227: NEG
97228: PUSH
97229: EMPTY
97230: LIST
97231: LIST
97232: PUSH
97233: LD_INT 2
97235: NEG
97236: PUSH
97237: LD_INT 4
97239: NEG
97240: PUSH
97241: EMPTY
97242: LIST
97243: LIST
97244: PUSH
97245: LD_INT 4
97247: PUSH
97248: LD_INT 0
97250: PUSH
97251: EMPTY
97252: LIST
97253: LIST
97254: PUSH
97255: LD_INT 4
97257: PUSH
97258: LD_INT 1
97260: NEG
97261: PUSH
97262: EMPTY
97263: LIST
97264: LIST
97265: PUSH
97266: LD_INT 5
97268: PUSH
97269: LD_INT 0
97271: PUSH
97272: EMPTY
97273: LIST
97274: LIST
97275: PUSH
97276: LD_INT 5
97278: PUSH
97279: LD_INT 1
97281: PUSH
97282: EMPTY
97283: LIST
97284: LIST
97285: PUSH
97286: LD_INT 4
97288: PUSH
97289: LD_INT 1
97291: PUSH
97292: EMPTY
97293: LIST
97294: LIST
97295: PUSH
97296: LD_INT 3
97298: PUSH
97299: LD_INT 0
97301: PUSH
97302: EMPTY
97303: LIST
97304: LIST
97305: PUSH
97306: LD_INT 3
97308: PUSH
97309: LD_INT 1
97311: NEG
97312: PUSH
97313: EMPTY
97314: LIST
97315: LIST
97316: PUSH
97317: LD_INT 3
97319: PUSH
97320: LD_INT 2
97322: NEG
97323: PUSH
97324: EMPTY
97325: LIST
97326: LIST
97327: PUSH
97328: LD_INT 5
97330: PUSH
97331: LD_INT 2
97333: PUSH
97334: EMPTY
97335: LIST
97336: LIST
97337: PUSH
97338: EMPTY
97339: LIST
97340: LIST
97341: LIST
97342: LIST
97343: LIST
97344: LIST
97345: LIST
97346: LIST
97347: LIST
97348: LIST
97349: LIST
97350: LIST
97351: LIST
97352: LIST
97353: LIST
97354: LIST
97355: LIST
97356: LIST
97357: LIST
97358: LIST
97359: LIST
97360: LIST
97361: LIST
97362: LIST
97363: LIST
97364: LIST
97365: LIST
97366: LIST
97367: LIST
97368: LIST
97369: LIST
97370: LIST
97371: LIST
97372: LIST
97373: LIST
97374: LIST
97375: LIST
97376: LIST
97377: LIST
97378: LIST
97379: LIST
97380: LIST
97381: LIST
97382: LIST
97383: LIST
97384: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
97385: LD_ADDR_VAR 0 32
97389: PUSH
97390: LD_INT 4
97392: NEG
97393: PUSH
97394: LD_INT 0
97396: PUSH
97397: EMPTY
97398: LIST
97399: LIST
97400: PUSH
97401: LD_INT 4
97403: NEG
97404: PUSH
97405: LD_INT 1
97407: NEG
97408: PUSH
97409: EMPTY
97410: LIST
97411: LIST
97412: PUSH
97413: LD_INT 3
97415: NEG
97416: PUSH
97417: LD_INT 0
97419: PUSH
97420: EMPTY
97421: LIST
97422: LIST
97423: PUSH
97424: LD_INT 3
97426: NEG
97427: PUSH
97428: LD_INT 1
97430: PUSH
97431: EMPTY
97432: LIST
97433: LIST
97434: PUSH
97435: LD_INT 4
97437: NEG
97438: PUSH
97439: LD_INT 1
97441: PUSH
97442: EMPTY
97443: LIST
97444: LIST
97445: PUSH
97446: LD_INT 5
97448: NEG
97449: PUSH
97450: LD_INT 0
97452: PUSH
97453: EMPTY
97454: LIST
97455: LIST
97456: PUSH
97457: LD_INT 5
97459: NEG
97460: PUSH
97461: LD_INT 1
97463: NEG
97464: PUSH
97465: EMPTY
97466: LIST
97467: LIST
97468: PUSH
97469: LD_INT 5
97471: NEG
97472: PUSH
97473: LD_INT 2
97475: NEG
97476: PUSH
97477: EMPTY
97478: LIST
97479: LIST
97480: PUSH
97481: LD_INT 3
97483: NEG
97484: PUSH
97485: LD_INT 2
97487: PUSH
97488: EMPTY
97489: LIST
97490: LIST
97491: PUSH
97492: LD_INT 3
97494: NEG
97495: PUSH
97496: LD_INT 3
97498: NEG
97499: PUSH
97500: EMPTY
97501: LIST
97502: LIST
97503: PUSH
97504: LD_INT 3
97506: NEG
97507: PUSH
97508: LD_INT 4
97510: NEG
97511: PUSH
97512: EMPTY
97513: LIST
97514: LIST
97515: PUSH
97516: LD_INT 2
97518: NEG
97519: PUSH
97520: LD_INT 3
97522: NEG
97523: PUSH
97524: EMPTY
97525: LIST
97526: LIST
97527: PUSH
97528: LD_INT 2
97530: NEG
97531: PUSH
97532: LD_INT 2
97534: NEG
97535: PUSH
97536: EMPTY
97537: LIST
97538: LIST
97539: PUSH
97540: LD_INT 3
97542: NEG
97543: PUSH
97544: LD_INT 2
97546: NEG
97547: PUSH
97548: EMPTY
97549: LIST
97550: LIST
97551: PUSH
97552: LD_INT 4
97554: NEG
97555: PUSH
97556: LD_INT 3
97558: NEG
97559: PUSH
97560: EMPTY
97561: LIST
97562: LIST
97563: PUSH
97564: LD_INT 4
97566: NEG
97567: PUSH
97568: LD_INT 4
97570: NEG
97571: PUSH
97572: EMPTY
97573: LIST
97574: LIST
97575: PUSH
97576: LD_INT 2
97578: NEG
97579: PUSH
97580: LD_INT 4
97582: NEG
97583: PUSH
97584: EMPTY
97585: LIST
97586: LIST
97587: PUSH
97588: LD_INT 4
97590: NEG
97591: PUSH
97592: LD_INT 2
97594: NEG
97595: PUSH
97596: EMPTY
97597: LIST
97598: LIST
97599: PUSH
97600: LD_INT 0
97602: PUSH
97603: LD_INT 4
97605: NEG
97606: PUSH
97607: EMPTY
97608: LIST
97609: LIST
97610: PUSH
97611: LD_INT 0
97613: PUSH
97614: LD_INT 5
97616: NEG
97617: PUSH
97618: EMPTY
97619: LIST
97620: LIST
97621: PUSH
97622: LD_INT 1
97624: PUSH
97625: LD_INT 4
97627: NEG
97628: PUSH
97629: EMPTY
97630: LIST
97631: LIST
97632: PUSH
97633: LD_INT 1
97635: PUSH
97636: LD_INT 3
97638: NEG
97639: PUSH
97640: EMPTY
97641: LIST
97642: LIST
97643: PUSH
97644: LD_INT 0
97646: PUSH
97647: LD_INT 3
97649: NEG
97650: PUSH
97651: EMPTY
97652: LIST
97653: LIST
97654: PUSH
97655: LD_INT 1
97657: NEG
97658: PUSH
97659: LD_INT 4
97661: NEG
97662: PUSH
97663: EMPTY
97664: LIST
97665: LIST
97666: PUSH
97667: LD_INT 1
97669: NEG
97670: PUSH
97671: LD_INT 5
97673: NEG
97674: PUSH
97675: EMPTY
97676: LIST
97677: LIST
97678: PUSH
97679: LD_INT 2
97681: PUSH
97682: LD_INT 3
97684: NEG
97685: PUSH
97686: EMPTY
97687: LIST
97688: LIST
97689: PUSH
97690: LD_INT 2
97692: NEG
97693: PUSH
97694: LD_INT 5
97696: NEG
97697: PUSH
97698: EMPTY
97699: LIST
97700: LIST
97701: PUSH
97702: LD_INT 3
97704: PUSH
97705: LD_INT 0
97707: PUSH
97708: EMPTY
97709: LIST
97710: LIST
97711: PUSH
97712: LD_INT 3
97714: PUSH
97715: LD_INT 1
97717: NEG
97718: PUSH
97719: EMPTY
97720: LIST
97721: LIST
97722: PUSH
97723: LD_INT 4
97725: PUSH
97726: LD_INT 0
97728: PUSH
97729: EMPTY
97730: LIST
97731: LIST
97732: PUSH
97733: LD_INT 4
97735: PUSH
97736: LD_INT 1
97738: PUSH
97739: EMPTY
97740: LIST
97741: LIST
97742: PUSH
97743: LD_INT 3
97745: PUSH
97746: LD_INT 1
97748: PUSH
97749: EMPTY
97750: LIST
97751: LIST
97752: PUSH
97753: LD_INT 2
97755: PUSH
97756: LD_INT 0
97758: PUSH
97759: EMPTY
97760: LIST
97761: LIST
97762: PUSH
97763: LD_INT 2
97765: PUSH
97766: LD_INT 1
97768: NEG
97769: PUSH
97770: EMPTY
97771: LIST
97772: LIST
97773: PUSH
97774: LD_INT 2
97776: PUSH
97777: LD_INT 2
97779: NEG
97780: PUSH
97781: EMPTY
97782: LIST
97783: LIST
97784: PUSH
97785: LD_INT 4
97787: PUSH
97788: LD_INT 2
97790: PUSH
97791: EMPTY
97792: LIST
97793: LIST
97794: PUSH
97795: LD_INT 4
97797: PUSH
97798: LD_INT 4
97800: PUSH
97801: EMPTY
97802: LIST
97803: LIST
97804: PUSH
97805: LD_INT 4
97807: PUSH
97808: LD_INT 3
97810: PUSH
97811: EMPTY
97812: LIST
97813: LIST
97814: PUSH
97815: LD_INT 5
97817: PUSH
97818: LD_INT 4
97820: PUSH
97821: EMPTY
97822: LIST
97823: LIST
97824: PUSH
97825: LD_INT 5
97827: PUSH
97828: LD_INT 5
97830: PUSH
97831: EMPTY
97832: LIST
97833: LIST
97834: PUSH
97835: LD_INT 4
97837: PUSH
97838: LD_INT 5
97840: PUSH
97841: EMPTY
97842: LIST
97843: LIST
97844: PUSH
97845: LD_INT 3
97847: PUSH
97848: LD_INT 4
97850: PUSH
97851: EMPTY
97852: LIST
97853: LIST
97854: PUSH
97855: LD_INT 3
97857: PUSH
97858: LD_INT 3
97860: PUSH
97861: EMPTY
97862: LIST
97863: LIST
97864: PUSH
97865: LD_INT 5
97867: PUSH
97868: LD_INT 3
97870: PUSH
97871: EMPTY
97872: LIST
97873: LIST
97874: PUSH
97875: LD_INT 3
97877: PUSH
97878: LD_INT 5
97880: PUSH
97881: EMPTY
97882: LIST
97883: LIST
97884: PUSH
97885: EMPTY
97886: LIST
97887: LIST
97888: LIST
97889: LIST
97890: LIST
97891: LIST
97892: LIST
97893: LIST
97894: LIST
97895: LIST
97896: LIST
97897: LIST
97898: LIST
97899: LIST
97900: LIST
97901: LIST
97902: LIST
97903: LIST
97904: LIST
97905: LIST
97906: LIST
97907: LIST
97908: LIST
97909: LIST
97910: LIST
97911: LIST
97912: LIST
97913: LIST
97914: LIST
97915: LIST
97916: LIST
97917: LIST
97918: LIST
97919: LIST
97920: LIST
97921: LIST
97922: LIST
97923: LIST
97924: LIST
97925: LIST
97926: LIST
97927: LIST
97928: LIST
97929: LIST
97930: LIST
97931: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
97932: LD_ADDR_VAR 0 33
97936: PUSH
97937: LD_INT 4
97939: NEG
97940: PUSH
97941: LD_INT 4
97943: NEG
97944: PUSH
97945: EMPTY
97946: LIST
97947: LIST
97948: PUSH
97949: LD_INT 4
97951: NEG
97952: PUSH
97953: LD_INT 5
97955: NEG
97956: PUSH
97957: EMPTY
97958: LIST
97959: LIST
97960: PUSH
97961: LD_INT 3
97963: NEG
97964: PUSH
97965: LD_INT 4
97967: NEG
97968: PUSH
97969: EMPTY
97970: LIST
97971: LIST
97972: PUSH
97973: LD_INT 3
97975: NEG
97976: PUSH
97977: LD_INT 3
97979: NEG
97980: PUSH
97981: EMPTY
97982: LIST
97983: LIST
97984: PUSH
97985: LD_INT 4
97987: NEG
97988: PUSH
97989: LD_INT 3
97991: NEG
97992: PUSH
97993: EMPTY
97994: LIST
97995: LIST
97996: PUSH
97997: LD_INT 5
97999: NEG
98000: PUSH
98001: LD_INT 4
98003: NEG
98004: PUSH
98005: EMPTY
98006: LIST
98007: LIST
98008: PUSH
98009: LD_INT 5
98011: NEG
98012: PUSH
98013: LD_INT 5
98015: NEG
98016: PUSH
98017: EMPTY
98018: LIST
98019: LIST
98020: PUSH
98021: LD_INT 3
98023: NEG
98024: PUSH
98025: LD_INT 5
98027: NEG
98028: PUSH
98029: EMPTY
98030: LIST
98031: LIST
98032: PUSH
98033: LD_INT 5
98035: NEG
98036: PUSH
98037: LD_INT 3
98039: NEG
98040: PUSH
98041: EMPTY
98042: LIST
98043: LIST
98044: PUSH
98045: LD_INT 0
98047: PUSH
98048: LD_INT 3
98050: NEG
98051: PUSH
98052: EMPTY
98053: LIST
98054: LIST
98055: PUSH
98056: LD_INT 0
98058: PUSH
98059: LD_INT 4
98061: NEG
98062: PUSH
98063: EMPTY
98064: LIST
98065: LIST
98066: PUSH
98067: LD_INT 1
98069: PUSH
98070: LD_INT 3
98072: NEG
98073: PUSH
98074: EMPTY
98075: LIST
98076: LIST
98077: PUSH
98078: LD_INT 1
98080: PUSH
98081: LD_INT 2
98083: NEG
98084: PUSH
98085: EMPTY
98086: LIST
98087: LIST
98088: PUSH
98089: LD_INT 0
98091: PUSH
98092: LD_INT 2
98094: NEG
98095: PUSH
98096: EMPTY
98097: LIST
98098: LIST
98099: PUSH
98100: LD_INT 1
98102: NEG
98103: PUSH
98104: LD_INT 3
98106: NEG
98107: PUSH
98108: EMPTY
98109: LIST
98110: LIST
98111: PUSH
98112: LD_INT 1
98114: NEG
98115: PUSH
98116: LD_INT 4
98118: NEG
98119: PUSH
98120: EMPTY
98121: LIST
98122: LIST
98123: PUSH
98124: LD_INT 2
98126: PUSH
98127: LD_INT 2
98129: NEG
98130: PUSH
98131: EMPTY
98132: LIST
98133: LIST
98134: PUSH
98135: LD_INT 2
98137: NEG
98138: PUSH
98139: LD_INT 4
98141: NEG
98142: PUSH
98143: EMPTY
98144: LIST
98145: LIST
98146: PUSH
98147: LD_INT 4
98149: PUSH
98150: LD_INT 0
98152: PUSH
98153: EMPTY
98154: LIST
98155: LIST
98156: PUSH
98157: LD_INT 4
98159: PUSH
98160: LD_INT 1
98162: NEG
98163: PUSH
98164: EMPTY
98165: LIST
98166: LIST
98167: PUSH
98168: LD_INT 5
98170: PUSH
98171: LD_INT 0
98173: PUSH
98174: EMPTY
98175: LIST
98176: LIST
98177: PUSH
98178: LD_INT 5
98180: PUSH
98181: LD_INT 1
98183: PUSH
98184: EMPTY
98185: LIST
98186: LIST
98187: PUSH
98188: LD_INT 4
98190: PUSH
98191: LD_INT 1
98193: PUSH
98194: EMPTY
98195: LIST
98196: LIST
98197: PUSH
98198: LD_INT 3
98200: PUSH
98201: LD_INT 0
98203: PUSH
98204: EMPTY
98205: LIST
98206: LIST
98207: PUSH
98208: LD_INT 3
98210: PUSH
98211: LD_INT 1
98213: NEG
98214: PUSH
98215: EMPTY
98216: LIST
98217: LIST
98218: PUSH
98219: LD_INT 3
98221: PUSH
98222: LD_INT 2
98224: NEG
98225: PUSH
98226: EMPTY
98227: LIST
98228: LIST
98229: PUSH
98230: LD_INT 5
98232: PUSH
98233: LD_INT 2
98235: PUSH
98236: EMPTY
98237: LIST
98238: LIST
98239: PUSH
98240: LD_INT 3
98242: PUSH
98243: LD_INT 3
98245: PUSH
98246: EMPTY
98247: LIST
98248: LIST
98249: PUSH
98250: LD_INT 3
98252: PUSH
98253: LD_INT 2
98255: PUSH
98256: EMPTY
98257: LIST
98258: LIST
98259: PUSH
98260: LD_INT 4
98262: PUSH
98263: LD_INT 3
98265: PUSH
98266: EMPTY
98267: LIST
98268: LIST
98269: PUSH
98270: LD_INT 4
98272: PUSH
98273: LD_INT 4
98275: PUSH
98276: EMPTY
98277: LIST
98278: LIST
98279: PUSH
98280: LD_INT 3
98282: PUSH
98283: LD_INT 4
98285: PUSH
98286: EMPTY
98287: LIST
98288: LIST
98289: PUSH
98290: LD_INT 2
98292: PUSH
98293: LD_INT 3
98295: PUSH
98296: EMPTY
98297: LIST
98298: LIST
98299: PUSH
98300: LD_INT 2
98302: PUSH
98303: LD_INT 2
98305: PUSH
98306: EMPTY
98307: LIST
98308: LIST
98309: PUSH
98310: LD_INT 4
98312: PUSH
98313: LD_INT 2
98315: PUSH
98316: EMPTY
98317: LIST
98318: LIST
98319: PUSH
98320: LD_INT 2
98322: PUSH
98323: LD_INT 4
98325: PUSH
98326: EMPTY
98327: LIST
98328: LIST
98329: PUSH
98330: LD_INT 0
98332: PUSH
98333: LD_INT 4
98335: PUSH
98336: EMPTY
98337: LIST
98338: LIST
98339: PUSH
98340: LD_INT 0
98342: PUSH
98343: LD_INT 3
98345: PUSH
98346: EMPTY
98347: LIST
98348: LIST
98349: PUSH
98350: LD_INT 1
98352: PUSH
98353: LD_INT 4
98355: PUSH
98356: EMPTY
98357: LIST
98358: LIST
98359: PUSH
98360: LD_INT 1
98362: PUSH
98363: LD_INT 5
98365: PUSH
98366: EMPTY
98367: LIST
98368: LIST
98369: PUSH
98370: LD_INT 0
98372: PUSH
98373: LD_INT 5
98375: PUSH
98376: EMPTY
98377: LIST
98378: LIST
98379: PUSH
98380: LD_INT 1
98382: NEG
98383: PUSH
98384: LD_INT 4
98386: PUSH
98387: EMPTY
98388: LIST
98389: LIST
98390: PUSH
98391: LD_INT 1
98393: NEG
98394: PUSH
98395: LD_INT 3
98397: PUSH
98398: EMPTY
98399: LIST
98400: LIST
98401: PUSH
98402: LD_INT 2
98404: PUSH
98405: LD_INT 5
98407: PUSH
98408: EMPTY
98409: LIST
98410: LIST
98411: PUSH
98412: LD_INT 2
98414: NEG
98415: PUSH
98416: LD_INT 3
98418: PUSH
98419: EMPTY
98420: LIST
98421: LIST
98422: PUSH
98423: EMPTY
98424: LIST
98425: LIST
98426: LIST
98427: LIST
98428: LIST
98429: LIST
98430: LIST
98431: LIST
98432: LIST
98433: LIST
98434: LIST
98435: LIST
98436: LIST
98437: LIST
98438: LIST
98439: LIST
98440: LIST
98441: LIST
98442: LIST
98443: LIST
98444: LIST
98445: LIST
98446: LIST
98447: LIST
98448: LIST
98449: LIST
98450: LIST
98451: LIST
98452: LIST
98453: LIST
98454: LIST
98455: LIST
98456: LIST
98457: LIST
98458: LIST
98459: LIST
98460: LIST
98461: LIST
98462: LIST
98463: LIST
98464: LIST
98465: LIST
98466: LIST
98467: LIST
98468: LIST
98469: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
98470: LD_ADDR_VAR 0 34
98474: PUSH
98475: LD_INT 0
98477: PUSH
98478: LD_INT 4
98480: NEG
98481: PUSH
98482: EMPTY
98483: LIST
98484: LIST
98485: PUSH
98486: LD_INT 0
98488: PUSH
98489: LD_INT 5
98491: NEG
98492: PUSH
98493: EMPTY
98494: LIST
98495: LIST
98496: PUSH
98497: LD_INT 1
98499: PUSH
98500: LD_INT 4
98502: NEG
98503: PUSH
98504: EMPTY
98505: LIST
98506: LIST
98507: PUSH
98508: LD_INT 1
98510: PUSH
98511: LD_INT 3
98513: NEG
98514: PUSH
98515: EMPTY
98516: LIST
98517: LIST
98518: PUSH
98519: LD_INT 0
98521: PUSH
98522: LD_INT 3
98524: NEG
98525: PUSH
98526: EMPTY
98527: LIST
98528: LIST
98529: PUSH
98530: LD_INT 1
98532: NEG
98533: PUSH
98534: LD_INT 4
98536: NEG
98537: PUSH
98538: EMPTY
98539: LIST
98540: LIST
98541: PUSH
98542: LD_INT 1
98544: NEG
98545: PUSH
98546: LD_INT 5
98548: NEG
98549: PUSH
98550: EMPTY
98551: LIST
98552: LIST
98553: PUSH
98554: LD_INT 2
98556: PUSH
98557: LD_INT 3
98559: NEG
98560: PUSH
98561: EMPTY
98562: LIST
98563: LIST
98564: PUSH
98565: LD_INT 2
98567: NEG
98568: PUSH
98569: LD_INT 5
98571: NEG
98572: PUSH
98573: EMPTY
98574: LIST
98575: LIST
98576: PUSH
98577: LD_INT 3
98579: PUSH
98580: LD_INT 0
98582: PUSH
98583: EMPTY
98584: LIST
98585: LIST
98586: PUSH
98587: LD_INT 3
98589: PUSH
98590: LD_INT 1
98592: NEG
98593: PUSH
98594: EMPTY
98595: LIST
98596: LIST
98597: PUSH
98598: LD_INT 4
98600: PUSH
98601: LD_INT 0
98603: PUSH
98604: EMPTY
98605: LIST
98606: LIST
98607: PUSH
98608: LD_INT 4
98610: PUSH
98611: LD_INT 1
98613: PUSH
98614: EMPTY
98615: LIST
98616: LIST
98617: PUSH
98618: LD_INT 3
98620: PUSH
98621: LD_INT 1
98623: PUSH
98624: EMPTY
98625: LIST
98626: LIST
98627: PUSH
98628: LD_INT 2
98630: PUSH
98631: LD_INT 0
98633: PUSH
98634: EMPTY
98635: LIST
98636: LIST
98637: PUSH
98638: LD_INT 2
98640: PUSH
98641: LD_INT 1
98643: NEG
98644: PUSH
98645: EMPTY
98646: LIST
98647: LIST
98648: PUSH
98649: LD_INT 2
98651: PUSH
98652: LD_INT 2
98654: NEG
98655: PUSH
98656: EMPTY
98657: LIST
98658: LIST
98659: PUSH
98660: LD_INT 4
98662: PUSH
98663: LD_INT 2
98665: PUSH
98666: EMPTY
98667: LIST
98668: LIST
98669: PUSH
98670: LD_INT 4
98672: PUSH
98673: LD_INT 4
98675: PUSH
98676: EMPTY
98677: LIST
98678: LIST
98679: PUSH
98680: LD_INT 4
98682: PUSH
98683: LD_INT 3
98685: PUSH
98686: EMPTY
98687: LIST
98688: LIST
98689: PUSH
98690: LD_INT 5
98692: PUSH
98693: LD_INT 4
98695: PUSH
98696: EMPTY
98697: LIST
98698: LIST
98699: PUSH
98700: LD_INT 5
98702: PUSH
98703: LD_INT 5
98705: PUSH
98706: EMPTY
98707: LIST
98708: LIST
98709: PUSH
98710: LD_INT 4
98712: PUSH
98713: LD_INT 5
98715: PUSH
98716: EMPTY
98717: LIST
98718: LIST
98719: PUSH
98720: LD_INT 3
98722: PUSH
98723: LD_INT 4
98725: PUSH
98726: EMPTY
98727: LIST
98728: LIST
98729: PUSH
98730: LD_INT 3
98732: PUSH
98733: LD_INT 3
98735: PUSH
98736: EMPTY
98737: LIST
98738: LIST
98739: PUSH
98740: LD_INT 5
98742: PUSH
98743: LD_INT 3
98745: PUSH
98746: EMPTY
98747: LIST
98748: LIST
98749: PUSH
98750: LD_INT 3
98752: PUSH
98753: LD_INT 5
98755: PUSH
98756: EMPTY
98757: LIST
98758: LIST
98759: PUSH
98760: LD_INT 0
98762: PUSH
98763: LD_INT 3
98765: PUSH
98766: EMPTY
98767: LIST
98768: LIST
98769: PUSH
98770: LD_INT 0
98772: PUSH
98773: LD_INT 2
98775: PUSH
98776: EMPTY
98777: LIST
98778: LIST
98779: PUSH
98780: LD_INT 1
98782: PUSH
98783: LD_INT 3
98785: PUSH
98786: EMPTY
98787: LIST
98788: LIST
98789: PUSH
98790: LD_INT 1
98792: PUSH
98793: LD_INT 4
98795: PUSH
98796: EMPTY
98797: LIST
98798: LIST
98799: PUSH
98800: LD_INT 0
98802: PUSH
98803: LD_INT 4
98805: PUSH
98806: EMPTY
98807: LIST
98808: LIST
98809: PUSH
98810: LD_INT 1
98812: NEG
98813: PUSH
98814: LD_INT 3
98816: PUSH
98817: EMPTY
98818: LIST
98819: LIST
98820: PUSH
98821: LD_INT 1
98823: NEG
98824: PUSH
98825: LD_INT 2
98827: PUSH
98828: EMPTY
98829: LIST
98830: LIST
98831: PUSH
98832: LD_INT 2
98834: PUSH
98835: LD_INT 4
98837: PUSH
98838: EMPTY
98839: LIST
98840: LIST
98841: PUSH
98842: LD_INT 2
98844: NEG
98845: PUSH
98846: LD_INT 2
98848: PUSH
98849: EMPTY
98850: LIST
98851: LIST
98852: PUSH
98853: LD_INT 4
98855: NEG
98856: PUSH
98857: LD_INT 0
98859: PUSH
98860: EMPTY
98861: LIST
98862: LIST
98863: PUSH
98864: LD_INT 4
98866: NEG
98867: PUSH
98868: LD_INT 1
98870: NEG
98871: PUSH
98872: EMPTY
98873: LIST
98874: LIST
98875: PUSH
98876: LD_INT 3
98878: NEG
98879: PUSH
98880: LD_INT 0
98882: PUSH
98883: EMPTY
98884: LIST
98885: LIST
98886: PUSH
98887: LD_INT 3
98889: NEG
98890: PUSH
98891: LD_INT 1
98893: PUSH
98894: EMPTY
98895: LIST
98896: LIST
98897: PUSH
98898: LD_INT 4
98900: NEG
98901: PUSH
98902: LD_INT 1
98904: PUSH
98905: EMPTY
98906: LIST
98907: LIST
98908: PUSH
98909: LD_INT 5
98911: NEG
98912: PUSH
98913: LD_INT 0
98915: PUSH
98916: EMPTY
98917: LIST
98918: LIST
98919: PUSH
98920: LD_INT 5
98922: NEG
98923: PUSH
98924: LD_INT 1
98926: NEG
98927: PUSH
98928: EMPTY
98929: LIST
98930: LIST
98931: PUSH
98932: LD_INT 5
98934: NEG
98935: PUSH
98936: LD_INT 2
98938: NEG
98939: PUSH
98940: EMPTY
98941: LIST
98942: LIST
98943: PUSH
98944: LD_INT 3
98946: NEG
98947: PUSH
98948: LD_INT 2
98950: PUSH
98951: EMPTY
98952: LIST
98953: LIST
98954: PUSH
98955: EMPTY
98956: LIST
98957: LIST
98958: LIST
98959: LIST
98960: LIST
98961: LIST
98962: LIST
98963: LIST
98964: LIST
98965: LIST
98966: LIST
98967: LIST
98968: LIST
98969: LIST
98970: LIST
98971: LIST
98972: LIST
98973: LIST
98974: LIST
98975: LIST
98976: LIST
98977: LIST
98978: LIST
98979: LIST
98980: LIST
98981: LIST
98982: LIST
98983: LIST
98984: LIST
98985: LIST
98986: LIST
98987: LIST
98988: LIST
98989: LIST
98990: LIST
98991: LIST
98992: LIST
98993: LIST
98994: LIST
98995: LIST
98996: LIST
98997: LIST
98998: LIST
98999: LIST
99000: LIST
99001: ST_TO_ADDR
// end ; end ;
99002: GO 99005
99004: POP
// case btype of b_depot , b_warehouse :
99005: LD_VAR 0 1
99009: PUSH
99010: LD_INT 0
99012: DOUBLE
99013: EQUAL
99014: IFTRUE 99024
99016: LD_INT 1
99018: DOUBLE
99019: EQUAL
99020: IFTRUE 99024
99022: GO 99225
99024: POP
// case nation of nation_american :
99025: LD_VAR 0 5
99029: PUSH
99030: LD_INT 1
99032: DOUBLE
99033: EQUAL
99034: IFTRUE 99038
99036: GO 99094
99038: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
99039: LD_ADDR_VAR 0 9
99043: PUSH
99044: LD_VAR 0 11
99048: PUSH
99049: LD_VAR 0 12
99053: PUSH
99054: LD_VAR 0 13
99058: PUSH
99059: LD_VAR 0 14
99063: PUSH
99064: LD_VAR 0 15
99068: PUSH
99069: LD_VAR 0 16
99073: PUSH
99074: EMPTY
99075: LIST
99076: LIST
99077: LIST
99078: LIST
99079: LIST
99080: LIST
99081: PUSH
99082: LD_VAR 0 4
99086: PUSH
99087: LD_INT 1
99089: PLUS
99090: ARRAY
99091: ST_TO_ADDR
99092: GO 99223
99094: LD_INT 2
99096: DOUBLE
99097: EQUAL
99098: IFTRUE 99102
99100: GO 99158
99102: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
99103: LD_ADDR_VAR 0 9
99107: PUSH
99108: LD_VAR 0 17
99112: PUSH
99113: LD_VAR 0 18
99117: PUSH
99118: LD_VAR 0 19
99122: PUSH
99123: LD_VAR 0 20
99127: PUSH
99128: LD_VAR 0 21
99132: PUSH
99133: LD_VAR 0 22
99137: PUSH
99138: EMPTY
99139: LIST
99140: LIST
99141: LIST
99142: LIST
99143: LIST
99144: LIST
99145: PUSH
99146: LD_VAR 0 4
99150: PUSH
99151: LD_INT 1
99153: PLUS
99154: ARRAY
99155: ST_TO_ADDR
99156: GO 99223
99158: LD_INT 3
99160: DOUBLE
99161: EQUAL
99162: IFTRUE 99166
99164: GO 99222
99166: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
99167: LD_ADDR_VAR 0 9
99171: PUSH
99172: LD_VAR 0 23
99176: PUSH
99177: LD_VAR 0 24
99181: PUSH
99182: LD_VAR 0 25
99186: PUSH
99187: LD_VAR 0 26
99191: PUSH
99192: LD_VAR 0 27
99196: PUSH
99197: LD_VAR 0 28
99201: PUSH
99202: EMPTY
99203: LIST
99204: LIST
99205: LIST
99206: LIST
99207: LIST
99208: LIST
99209: PUSH
99210: LD_VAR 0 4
99214: PUSH
99215: LD_INT 1
99217: PLUS
99218: ARRAY
99219: ST_TO_ADDR
99220: GO 99223
99222: POP
99223: GO 99778
99225: LD_INT 2
99227: DOUBLE
99228: EQUAL
99229: IFTRUE 99239
99231: LD_INT 3
99233: DOUBLE
99234: EQUAL
99235: IFTRUE 99239
99237: GO 99295
99239: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
99240: LD_ADDR_VAR 0 9
99244: PUSH
99245: LD_VAR 0 29
99249: PUSH
99250: LD_VAR 0 30
99254: PUSH
99255: LD_VAR 0 31
99259: PUSH
99260: LD_VAR 0 32
99264: PUSH
99265: LD_VAR 0 33
99269: PUSH
99270: LD_VAR 0 34
99274: PUSH
99275: EMPTY
99276: LIST
99277: LIST
99278: LIST
99279: LIST
99280: LIST
99281: LIST
99282: PUSH
99283: LD_VAR 0 4
99287: PUSH
99288: LD_INT 1
99290: PLUS
99291: ARRAY
99292: ST_TO_ADDR
99293: GO 99778
99295: LD_INT 16
99297: DOUBLE
99298: EQUAL
99299: IFTRUE 99357
99301: LD_INT 17
99303: DOUBLE
99304: EQUAL
99305: IFTRUE 99357
99307: LD_INT 18
99309: DOUBLE
99310: EQUAL
99311: IFTRUE 99357
99313: LD_INT 19
99315: DOUBLE
99316: EQUAL
99317: IFTRUE 99357
99319: LD_INT 22
99321: DOUBLE
99322: EQUAL
99323: IFTRUE 99357
99325: LD_INT 20
99327: DOUBLE
99328: EQUAL
99329: IFTRUE 99357
99331: LD_INT 21
99333: DOUBLE
99334: EQUAL
99335: IFTRUE 99357
99337: LD_INT 23
99339: DOUBLE
99340: EQUAL
99341: IFTRUE 99357
99343: LD_INT 24
99345: DOUBLE
99346: EQUAL
99347: IFTRUE 99357
99349: LD_INT 25
99351: DOUBLE
99352: EQUAL
99353: IFTRUE 99357
99355: GO 99413
99357: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
99358: LD_ADDR_VAR 0 9
99362: PUSH
99363: LD_VAR 0 35
99367: PUSH
99368: LD_VAR 0 36
99372: PUSH
99373: LD_VAR 0 37
99377: PUSH
99378: LD_VAR 0 38
99382: PUSH
99383: LD_VAR 0 39
99387: PUSH
99388: LD_VAR 0 40
99392: PUSH
99393: EMPTY
99394: LIST
99395: LIST
99396: LIST
99397: LIST
99398: LIST
99399: LIST
99400: PUSH
99401: LD_VAR 0 4
99405: PUSH
99406: LD_INT 1
99408: PLUS
99409: ARRAY
99410: ST_TO_ADDR
99411: GO 99778
99413: LD_INT 6
99415: DOUBLE
99416: EQUAL
99417: IFTRUE 99469
99419: LD_INT 7
99421: DOUBLE
99422: EQUAL
99423: IFTRUE 99469
99425: LD_INT 8
99427: DOUBLE
99428: EQUAL
99429: IFTRUE 99469
99431: LD_INT 13
99433: DOUBLE
99434: EQUAL
99435: IFTRUE 99469
99437: LD_INT 12
99439: DOUBLE
99440: EQUAL
99441: IFTRUE 99469
99443: LD_INT 15
99445: DOUBLE
99446: EQUAL
99447: IFTRUE 99469
99449: LD_INT 11
99451: DOUBLE
99452: EQUAL
99453: IFTRUE 99469
99455: LD_INT 14
99457: DOUBLE
99458: EQUAL
99459: IFTRUE 99469
99461: LD_INT 10
99463: DOUBLE
99464: EQUAL
99465: IFTRUE 99469
99467: GO 99525
99469: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
99470: LD_ADDR_VAR 0 9
99474: PUSH
99475: LD_VAR 0 41
99479: PUSH
99480: LD_VAR 0 42
99484: PUSH
99485: LD_VAR 0 43
99489: PUSH
99490: LD_VAR 0 44
99494: PUSH
99495: LD_VAR 0 45
99499: PUSH
99500: LD_VAR 0 46
99504: PUSH
99505: EMPTY
99506: LIST
99507: LIST
99508: LIST
99509: LIST
99510: LIST
99511: LIST
99512: PUSH
99513: LD_VAR 0 4
99517: PUSH
99518: LD_INT 1
99520: PLUS
99521: ARRAY
99522: ST_TO_ADDR
99523: GO 99778
99525: LD_INT 36
99527: DOUBLE
99528: EQUAL
99529: IFTRUE 99533
99531: GO 99589
99533: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
99534: LD_ADDR_VAR 0 9
99538: PUSH
99539: LD_VAR 0 47
99543: PUSH
99544: LD_VAR 0 48
99548: PUSH
99549: LD_VAR 0 49
99553: PUSH
99554: LD_VAR 0 50
99558: PUSH
99559: LD_VAR 0 51
99563: PUSH
99564: LD_VAR 0 52
99568: PUSH
99569: EMPTY
99570: LIST
99571: LIST
99572: LIST
99573: LIST
99574: LIST
99575: LIST
99576: PUSH
99577: LD_VAR 0 4
99581: PUSH
99582: LD_INT 1
99584: PLUS
99585: ARRAY
99586: ST_TO_ADDR
99587: GO 99778
99589: LD_INT 4
99591: DOUBLE
99592: EQUAL
99593: IFTRUE 99615
99595: LD_INT 5
99597: DOUBLE
99598: EQUAL
99599: IFTRUE 99615
99601: LD_INT 34
99603: DOUBLE
99604: EQUAL
99605: IFTRUE 99615
99607: LD_INT 37
99609: DOUBLE
99610: EQUAL
99611: IFTRUE 99615
99613: GO 99671
99615: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
99616: LD_ADDR_VAR 0 9
99620: PUSH
99621: LD_VAR 0 53
99625: PUSH
99626: LD_VAR 0 54
99630: PUSH
99631: LD_VAR 0 55
99635: PUSH
99636: LD_VAR 0 56
99640: PUSH
99641: LD_VAR 0 57
99645: PUSH
99646: LD_VAR 0 58
99650: PUSH
99651: EMPTY
99652: LIST
99653: LIST
99654: LIST
99655: LIST
99656: LIST
99657: LIST
99658: PUSH
99659: LD_VAR 0 4
99663: PUSH
99664: LD_INT 1
99666: PLUS
99667: ARRAY
99668: ST_TO_ADDR
99669: GO 99778
99671: LD_INT 31
99673: DOUBLE
99674: EQUAL
99675: IFTRUE 99721
99677: LD_INT 32
99679: DOUBLE
99680: EQUAL
99681: IFTRUE 99721
99683: LD_INT 33
99685: DOUBLE
99686: EQUAL
99687: IFTRUE 99721
99689: LD_INT 27
99691: DOUBLE
99692: EQUAL
99693: IFTRUE 99721
99695: LD_INT 26
99697: DOUBLE
99698: EQUAL
99699: IFTRUE 99721
99701: LD_INT 28
99703: DOUBLE
99704: EQUAL
99705: IFTRUE 99721
99707: LD_INT 29
99709: DOUBLE
99710: EQUAL
99711: IFTRUE 99721
99713: LD_INT 30
99715: DOUBLE
99716: EQUAL
99717: IFTRUE 99721
99719: GO 99777
99721: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
99722: LD_ADDR_VAR 0 9
99726: PUSH
99727: LD_VAR 0 59
99731: PUSH
99732: LD_VAR 0 60
99736: PUSH
99737: LD_VAR 0 61
99741: PUSH
99742: LD_VAR 0 62
99746: PUSH
99747: LD_VAR 0 63
99751: PUSH
99752: LD_VAR 0 64
99756: PUSH
99757: EMPTY
99758: LIST
99759: LIST
99760: LIST
99761: LIST
99762: LIST
99763: LIST
99764: PUSH
99765: LD_VAR 0 4
99769: PUSH
99770: LD_INT 1
99772: PLUS
99773: ARRAY
99774: ST_TO_ADDR
99775: GO 99778
99777: POP
// temp_list2 = [ ] ;
99778: LD_ADDR_VAR 0 10
99782: PUSH
99783: EMPTY
99784: ST_TO_ADDR
// for i in temp_list do
99785: LD_ADDR_VAR 0 8
99789: PUSH
99790: LD_VAR 0 9
99794: PUSH
99795: FOR_IN
99796: IFFALSE 99848
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
99798: LD_ADDR_VAR 0 10
99802: PUSH
99803: LD_VAR 0 10
99807: PUSH
99808: LD_VAR 0 8
99812: PUSH
99813: LD_INT 1
99815: ARRAY
99816: PUSH
99817: LD_VAR 0 2
99821: PLUS
99822: PUSH
99823: LD_VAR 0 8
99827: PUSH
99828: LD_INT 2
99830: ARRAY
99831: PUSH
99832: LD_VAR 0 3
99836: PLUS
99837: PUSH
99838: EMPTY
99839: LIST
99840: LIST
99841: PUSH
99842: EMPTY
99843: LIST
99844: ADD
99845: ST_TO_ADDR
99846: GO 99795
99848: POP
99849: POP
// result = temp_list2 ;
99850: LD_ADDR_VAR 0 7
99854: PUSH
99855: LD_VAR 0 10
99859: ST_TO_ADDR
// end ;
99860: LD_VAR 0 7
99864: RET
// export function EnemyInRange ( unit , dist ) ; begin
99865: LD_INT 0
99867: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
99868: LD_ADDR_VAR 0 3
99872: PUSH
99873: LD_VAR 0 1
99877: PPUSH
99878: CALL_OW 255
99882: PPUSH
99883: LD_VAR 0 1
99887: PPUSH
99888: CALL_OW 250
99892: PPUSH
99893: LD_VAR 0 1
99897: PPUSH
99898: CALL_OW 251
99902: PPUSH
99903: LD_VAR 0 2
99907: PPUSH
99908: CALL 73267 0 4
99912: PUSH
99913: LD_INT 4
99915: ARRAY
99916: ST_TO_ADDR
// end ;
99917: LD_VAR 0 3
99921: RET
// export function PlayerSeeMe ( unit ) ; begin
99922: LD_INT 0
99924: PPUSH
// result := See ( your_side , unit ) ;
99925: LD_ADDR_VAR 0 2
99929: PUSH
99930: LD_OWVAR 2
99934: PPUSH
99935: LD_VAR 0 1
99939: PPUSH
99940: CALL_OW 292
99944: ST_TO_ADDR
// end ;
99945: LD_VAR 0 2
99949: RET
// export function ReverseDir ( unit ) ; begin
99950: LD_INT 0
99952: PPUSH
// if not unit then
99953: LD_VAR 0 1
99957: NOT
99958: IFFALSE 99962
// exit ;
99960: GO 99985
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
99962: LD_ADDR_VAR 0 2
99966: PUSH
99967: LD_VAR 0 1
99971: PPUSH
99972: CALL_OW 254
99976: PUSH
99977: LD_INT 3
99979: PLUS
99980: PUSH
99981: LD_INT 6
99983: MOD
99984: ST_TO_ADDR
// end ;
99985: LD_VAR 0 2
99989: RET
// export function ReverseArray ( array ) ; var i ; begin
99990: LD_INT 0
99992: PPUSH
99993: PPUSH
// if not array then
99994: LD_VAR 0 1
99998: NOT
99999: IFFALSE 100003
// exit ;
100001: GO 100058
// result := [ ] ;
100003: LD_ADDR_VAR 0 2
100007: PUSH
100008: EMPTY
100009: ST_TO_ADDR
// for i := array downto 1 do
100010: LD_ADDR_VAR 0 3
100014: PUSH
100015: DOUBLE
100016: LD_VAR 0 1
100020: INC
100021: ST_TO_ADDR
100022: LD_INT 1
100024: PUSH
100025: FOR_DOWNTO
100026: IFFALSE 100056
// result := Join ( result , array [ i ] ) ;
100028: LD_ADDR_VAR 0 2
100032: PUSH
100033: LD_VAR 0 2
100037: PPUSH
100038: LD_VAR 0 1
100042: PUSH
100043: LD_VAR 0 3
100047: ARRAY
100048: PPUSH
100049: CALL 104683 0 2
100053: ST_TO_ADDR
100054: GO 100025
100056: POP
100057: POP
// end ;
100058: LD_VAR 0 2
100062: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
100063: LD_INT 0
100065: PPUSH
100066: PPUSH
100067: PPUSH
100068: PPUSH
100069: PPUSH
100070: PPUSH
// if not unit or not hexes then
100071: LD_VAR 0 1
100075: NOT
100076: PUSH
100077: LD_VAR 0 2
100081: NOT
100082: OR
100083: IFFALSE 100087
// exit ;
100085: GO 100210
// dist := 9999 ;
100087: LD_ADDR_VAR 0 5
100091: PUSH
100092: LD_INT 9999
100094: ST_TO_ADDR
// for i = 1 to hexes do
100095: LD_ADDR_VAR 0 4
100099: PUSH
100100: DOUBLE
100101: LD_INT 1
100103: DEC
100104: ST_TO_ADDR
100105: LD_VAR 0 2
100109: PUSH
100110: FOR_TO
100111: IFFALSE 100198
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
100113: LD_ADDR_VAR 0 6
100117: PUSH
100118: LD_VAR 0 1
100122: PPUSH
100123: LD_VAR 0 2
100127: PUSH
100128: LD_VAR 0 4
100132: ARRAY
100133: PUSH
100134: LD_INT 1
100136: ARRAY
100137: PPUSH
100138: LD_VAR 0 2
100142: PUSH
100143: LD_VAR 0 4
100147: ARRAY
100148: PUSH
100149: LD_INT 2
100151: ARRAY
100152: PPUSH
100153: CALL_OW 297
100157: ST_TO_ADDR
// if tdist < dist then
100158: LD_VAR 0 6
100162: PUSH
100163: LD_VAR 0 5
100167: LESS
100168: IFFALSE 100196
// begin hex := hexes [ i ] ;
100170: LD_ADDR_VAR 0 8
100174: PUSH
100175: LD_VAR 0 2
100179: PUSH
100180: LD_VAR 0 4
100184: ARRAY
100185: ST_TO_ADDR
// dist := tdist ;
100186: LD_ADDR_VAR 0 5
100190: PUSH
100191: LD_VAR 0 6
100195: ST_TO_ADDR
// end ; end ;
100196: GO 100110
100198: POP
100199: POP
// result := hex ;
100200: LD_ADDR_VAR 0 3
100204: PUSH
100205: LD_VAR 0 8
100209: ST_TO_ADDR
// end ;
100210: LD_VAR 0 3
100214: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
100215: LD_INT 0
100217: PPUSH
100218: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
100219: LD_VAR 0 1
100223: NOT
100224: PUSH
100225: LD_VAR 0 1
100229: PUSH
100230: LD_INT 21
100232: PUSH
100233: LD_INT 2
100235: PUSH
100236: EMPTY
100237: LIST
100238: LIST
100239: PUSH
100240: LD_INT 23
100242: PUSH
100243: LD_INT 2
100245: PUSH
100246: EMPTY
100247: LIST
100248: LIST
100249: PUSH
100250: EMPTY
100251: LIST
100252: LIST
100253: PPUSH
100254: CALL_OW 69
100258: IN
100259: NOT
100260: OR
100261: IFFALSE 100265
// exit ;
100263: GO 100312
// for i = 1 to 3 do
100265: LD_ADDR_VAR 0 3
100269: PUSH
100270: DOUBLE
100271: LD_INT 1
100273: DEC
100274: ST_TO_ADDR
100275: LD_INT 3
100277: PUSH
100278: FOR_TO
100279: IFFALSE 100310
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
100281: LD_VAR 0 1
100285: PPUSH
100286: CALL_OW 250
100290: PPUSH
100291: LD_VAR 0 1
100295: PPUSH
100296: CALL_OW 251
100300: PPUSH
100301: LD_INT 1
100303: PPUSH
100304: CALL_OW 453
100308: GO 100278
100310: POP
100311: POP
// end ;
100312: LD_VAR 0 2
100316: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
100317: LD_INT 0
100319: PPUSH
100320: PPUSH
100321: PPUSH
100322: PPUSH
100323: PPUSH
100324: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
100325: LD_VAR 0 1
100329: NOT
100330: PUSH
100331: LD_VAR 0 2
100335: NOT
100336: OR
100337: PUSH
100338: LD_VAR 0 1
100342: PPUSH
100343: CALL_OW 314
100347: OR
100348: IFFALSE 100352
// exit ;
100350: GO 100793
// x := GetX ( enemy_unit ) ;
100352: LD_ADDR_VAR 0 7
100356: PUSH
100357: LD_VAR 0 2
100361: PPUSH
100362: CALL_OW 250
100366: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
100367: LD_ADDR_VAR 0 8
100371: PUSH
100372: LD_VAR 0 2
100376: PPUSH
100377: CALL_OW 251
100381: ST_TO_ADDR
// if not x or not y then
100382: LD_VAR 0 7
100386: NOT
100387: PUSH
100388: LD_VAR 0 8
100392: NOT
100393: OR
100394: IFFALSE 100398
// exit ;
100396: GO 100793
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
100398: LD_ADDR_VAR 0 6
100402: PUSH
100403: LD_VAR 0 7
100407: PPUSH
100408: LD_INT 0
100410: PPUSH
100411: LD_INT 4
100413: PPUSH
100414: CALL_OW 272
100418: PUSH
100419: LD_VAR 0 8
100423: PPUSH
100424: LD_INT 0
100426: PPUSH
100427: LD_INT 4
100429: PPUSH
100430: CALL_OW 273
100434: PUSH
100435: EMPTY
100436: LIST
100437: LIST
100438: PUSH
100439: LD_VAR 0 7
100443: PPUSH
100444: LD_INT 1
100446: PPUSH
100447: LD_INT 4
100449: PPUSH
100450: CALL_OW 272
100454: PUSH
100455: LD_VAR 0 8
100459: PPUSH
100460: LD_INT 1
100462: PPUSH
100463: LD_INT 4
100465: PPUSH
100466: CALL_OW 273
100470: PUSH
100471: EMPTY
100472: LIST
100473: LIST
100474: PUSH
100475: LD_VAR 0 7
100479: PPUSH
100480: LD_INT 2
100482: PPUSH
100483: LD_INT 4
100485: PPUSH
100486: CALL_OW 272
100490: PUSH
100491: LD_VAR 0 8
100495: PPUSH
100496: LD_INT 2
100498: PPUSH
100499: LD_INT 4
100501: PPUSH
100502: CALL_OW 273
100506: PUSH
100507: EMPTY
100508: LIST
100509: LIST
100510: PUSH
100511: LD_VAR 0 7
100515: PPUSH
100516: LD_INT 3
100518: PPUSH
100519: LD_INT 4
100521: PPUSH
100522: CALL_OW 272
100526: PUSH
100527: LD_VAR 0 8
100531: PPUSH
100532: LD_INT 3
100534: PPUSH
100535: LD_INT 4
100537: PPUSH
100538: CALL_OW 273
100542: PUSH
100543: EMPTY
100544: LIST
100545: LIST
100546: PUSH
100547: LD_VAR 0 7
100551: PPUSH
100552: LD_INT 4
100554: PPUSH
100555: LD_INT 4
100557: PPUSH
100558: CALL_OW 272
100562: PUSH
100563: LD_VAR 0 8
100567: PPUSH
100568: LD_INT 4
100570: PPUSH
100571: LD_INT 4
100573: PPUSH
100574: CALL_OW 273
100578: PUSH
100579: EMPTY
100580: LIST
100581: LIST
100582: PUSH
100583: LD_VAR 0 7
100587: PPUSH
100588: LD_INT 5
100590: PPUSH
100591: LD_INT 4
100593: PPUSH
100594: CALL_OW 272
100598: PUSH
100599: LD_VAR 0 8
100603: PPUSH
100604: LD_INT 5
100606: PPUSH
100607: LD_INT 4
100609: PPUSH
100610: CALL_OW 273
100614: PUSH
100615: EMPTY
100616: LIST
100617: LIST
100618: PUSH
100619: EMPTY
100620: LIST
100621: LIST
100622: LIST
100623: LIST
100624: LIST
100625: LIST
100626: ST_TO_ADDR
// for i = tmp downto 1 do
100627: LD_ADDR_VAR 0 4
100631: PUSH
100632: DOUBLE
100633: LD_VAR 0 6
100637: INC
100638: ST_TO_ADDR
100639: LD_INT 1
100641: PUSH
100642: FOR_DOWNTO
100643: IFFALSE 100744
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
100645: LD_VAR 0 6
100649: PUSH
100650: LD_VAR 0 4
100654: ARRAY
100655: PUSH
100656: LD_INT 1
100658: ARRAY
100659: PPUSH
100660: LD_VAR 0 6
100664: PUSH
100665: LD_VAR 0 4
100669: ARRAY
100670: PUSH
100671: LD_INT 2
100673: ARRAY
100674: PPUSH
100675: CALL_OW 488
100679: NOT
100680: PUSH
100681: LD_VAR 0 6
100685: PUSH
100686: LD_VAR 0 4
100690: ARRAY
100691: PUSH
100692: LD_INT 1
100694: ARRAY
100695: PPUSH
100696: LD_VAR 0 6
100700: PUSH
100701: LD_VAR 0 4
100705: ARRAY
100706: PUSH
100707: LD_INT 2
100709: ARRAY
100710: PPUSH
100711: CALL_OW 428
100715: PUSH
100716: LD_INT 0
100718: NONEQUAL
100719: OR
100720: IFFALSE 100742
// tmp := Delete ( tmp , i ) ;
100722: LD_ADDR_VAR 0 6
100726: PUSH
100727: LD_VAR 0 6
100731: PPUSH
100732: LD_VAR 0 4
100736: PPUSH
100737: CALL_OW 3
100741: ST_TO_ADDR
100742: GO 100642
100744: POP
100745: POP
// j := GetClosestHex ( unit , tmp ) ;
100746: LD_ADDR_VAR 0 5
100750: PUSH
100751: LD_VAR 0 1
100755: PPUSH
100756: LD_VAR 0 6
100760: PPUSH
100761: CALL 100063 0 2
100765: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
100766: LD_VAR 0 1
100770: PPUSH
100771: LD_VAR 0 5
100775: PUSH
100776: LD_INT 1
100778: ARRAY
100779: PPUSH
100780: LD_VAR 0 5
100784: PUSH
100785: LD_INT 2
100787: ARRAY
100788: PPUSH
100789: CALL_OW 111
// end ;
100793: LD_VAR 0 3
100797: RET
// export function PrepareApemanSoldier ( ) ; begin
100798: LD_INT 0
100800: PPUSH
// uc_nation := 0 ;
100801: LD_ADDR_OWVAR 21
100805: PUSH
100806: LD_INT 0
100808: ST_TO_ADDR
// hc_sex := sex_male ;
100809: LD_ADDR_OWVAR 27
100813: PUSH
100814: LD_INT 1
100816: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
100817: LD_ADDR_OWVAR 28
100821: PUSH
100822: LD_INT 15
100824: ST_TO_ADDR
// hc_gallery :=  ;
100825: LD_ADDR_OWVAR 33
100829: PUSH
100830: LD_STRING 
100832: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
100833: LD_ADDR_OWVAR 31
100837: PUSH
100838: LD_INT 0
100840: PPUSH
100841: LD_INT 3
100843: PPUSH
100844: CALL_OW 12
100848: PUSH
100849: LD_INT 0
100851: PPUSH
100852: LD_INT 3
100854: PPUSH
100855: CALL_OW 12
100859: PUSH
100860: LD_INT 0
100862: PUSH
100863: LD_INT 0
100865: PUSH
100866: EMPTY
100867: LIST
100868: LIST
100869: LIST
100870: LIST
100871: ST_TO_ADDR
// end ;
100872: LD_VAR 0 1
100876: RET
// export function PrepareApemanEngineer ( ) ; begin
100877: LD_INT 0
100879: PPUSH
// uc_nation := 0 ;
100880: LD_ADDR_OWVAR 21
100884: PUSH
100885: LD_INT 0
100887: ST_TO_ADDR
// hc_sex := sex_male ;
100888: LD_ADDR_OWVAR 27
100892: PUSH
100893: LD_INT 1
100895: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
100896: LD_ADDR_OWVAR 28
100900: PUSH
100901: LD_INT 16
100903: ST_TO_ADDR
// hc_gallery :=  ;
100904: LD_ADDR_OWVAR 33
100908: PUSH
100909: LD_STRING 
100911: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
100912: LD_ADDR_OWVAR 31
100916: PUSH
100917: LD_INT 0
100919: PPUSH
100920: LD_INT 3
100922: PPUSH
100923: CALL_OW 12
100927: PUSH
100928: LD_INT 0
100930: PPUSH
100931: LD_INT 3
100933: PPUSH
100934: CALL_OW 12
100938: PUSH
100939: LD_INT 0
100941: PUSH
100942: LD_INT 0
100944: PUSH
100945: EMPTY
100946: LIST
100947: LIST
100948: LIST
100949: LIST
100950: ST_TO_ADDR
// end ;
100951: LD_VAR 0 1
100955: RET
// export function PrepareApeman ( agressivity ) ; begin
100956: LD_INT 0
100958: PPUSH
// uc_side := 0 ;
100959: LD_ADDR_OWVAR 20
100963: PUSH
100964: LD_INT 0
100966: ST_TO_ADDR
// uc_nation := 0 ;
100967: LD_ADDR_OWVAR 21
100971: PUSH
100972: LD_INT 0
100974: ST_TO_ADDR
// hc_sex := sex_male ;
100975: LD_ADDR_OWVAR 27
100979: PUSH
100980: LD_INT 1
100982: ST_TO_ADDR
// hc_class := class_apeman ;
100983: LD_ADDR_OWVAR 28
100987: PUSH
100988: LD_INT 12
100990: ST_TO_ADDR
// hc_gallery :=  ;
100991: LD_ADDR_OWVAR 33
100995: PUSH
100996: LD_STRING 
100998: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
100999: LD_ADDR_OWVAR 35
101003: PUSH
101004: LD_VAR 0 1
101008: NEG
101009: PPUSH
101010: LD_VAR 0 1
101014: PPUSH
101015: CALL_OW 12
101019: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
101020: LD_ADDR_OWVAR 31
101024: PUSH
101025: LD_INT 0
101027: PPUSH
101028: LD_INT 3
101030: PPUSH
101031: CALL_OW 12
101035: PUSH
101036: LD_INT 0
101038: PPUSH
101039: LD_INT 3
101041: PPUSH
101042: CALL_OW 12
101046: PUSH
101047: LD_INT 0
101049: PUSH
101050: LD_INT 0
101052: PUSH
101053: EMPTY
101054: LIST
101055: LIST
101056: LIST
101057: LIST
101058: ST_TO_ADDR
// end ;
101059: LD_VAR 0 2
101063: RET
// export function PrepareTiger ( agressivity ) ; begin
101064: LD_INT 0
101066: PPUSH
// uc_side := 0 ;
101067: LD_ADDR_OWVAR 20
101071: PUSH
101072: LD_INT 0
101074: ST_TO_ADDR
// uc_nation := 0 ;
101075: LD_ADDR_OWVAR 21
101079: PUSH
101080: LD_INT 0
101082: ST_TO_ADDR
// hc_class := class_tiger ;
101083: LD_ADDR_OWVAR 28
101087: PUSH
101088: LD_INT 14
101090: ST_TO_ADDR
// hc_gallery :=  ;
101091: LD_ADDR_OWVAR 33
101095: PUSH
101096: LD_STRING 
101098: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
101099: LD_ADDR_OWVAR 35
101103: PUSH
101104: LD_VAR 0 1
101108: NEG
101109: PPUSH
101110: LD_VAR 0 1
101114: PPUSH
101115: CALL_OW 12
101119: ST_TO_ADDR
// end ;
101120: LD_VAR 0 2
101124: RET
// export function PrepareEnchidna ( ) ; begin
101125: LD_INT 0
101127: PPUSH
// uc_side := 0 ;
101128: LD_ADDR_OWVAR 20
101132: PUSH
101133: LD_INT 0
101135: ST_TO_ADDR
// uc_nation := 0 ;
101136: LD_ADDR_OWVAR 21
101140: PUSH
101141: LD_INT 0
101143: ST_TO_ADDR
// hc_class := class_baggie ;
101144: LD_ADDR_OWVAR 28
101148: PUSH
101149: LD_INT 13
101151: ST_TO_ADDR
// hc_gallery :=  ;
101152: LD_ADDR_OWVAR 33
101156: PUSH
101157: LD_STRING 
101159: ST_TO_ADDR
// end ;
101160: LD_VAR 0 1
101164: RET
// export function PrepareFrog ( ) ; begin
101165: LD_INT 0
101167: PPUSH
// uc_side := 0 ;
101168: LD_ADDR_OWVAR 20
101172: PUSH
101173: LD_INT 0
101175: ST_TO_ADDR
// uc_nation := 0 ;
101176: LD_ADDR_OWVAR 21
101180: PUSH
101181: LD_INT 0
101183: ST_TO_ADDR
// hc_class := class_frog ;
101184: LD_ADDR_OWVAR 28
101188: PUSH
101189: LD_INT 19
101191: ST_TO_ADDR
// hc_gallery :=  ;
101192: LD_ADDR_OWVAR 33
101196: PUSH
101197: LD_STRING 
101199: ST_TO_ADDR
// end ;
101200: LD_VAR 0 1
101204: RET
// export function PrepareFish ( ) ; begin
101205: LD_INT 0
101207: PPUSH
// uc_side := 0 ;
101208: LD_ADDR_OWVAR 20
101212: PUSH
101213: LD_INT 0
101215: ST_TO_ADDR
// uc_nation := 0 ;
101216: LD_ADDR_OWVAR 21
101220: PUSH
101221: LD_INT 0
101223: ST_TO_ADDR
// hc_class := class_fish ;
101224: LD_ADDR_OWVAR 28
101228: PUSH
101229: LD_INT 20
101231: ST_TO_ADDR
// hc_gallery :=  ;
101232: LD_ADDR_OWVAR 33
101236: PUSH
101237: LD_STRING 
101239: ST_TO_ADDR
// end ;
101240: LD_VAR 0 1
101244: RET
// export function PrepareBird ( ) ; begin
101245: LD_INT 0
101247: PPUSH
// uc_side := 0 ;
101248: LD_ADDR_OWVAR 20
101252: PUSH
101253: LD_INT 0
101255: ST_TO_ADDR
// uc_nation := 0 ;
101256: LD_ADDR_OWVAR 21
101260: PUSH
101261: LD_INT 0
101263: ST_TO_ADDR
// hc_class := class_phororhacos ;
101264: LD_ADDR_OWVAR 28
101268: PUSH
101269: LD_INT 18
101271: ST_TO_ADDR
// hc_gallery :=  ;
101272: LD_ADDR_OWVAR 33
101276: PUSH
101277: LD_STRING 
101279: ST_TO_ADDR
// end ;
101280: LD_VAR 0 1
101284: RET
// export function PrepareHorse ( ) ; begin
101285: LD_INT 0
101287: PPUSH
// uc_side := 0 ;
101288: LD_ADDR_OWVAR 20
101292: PUSH
101293: LD_INT 0
101295: ST_TO_ADDR
// uc_nation := 0 ;
101296: LD_ADDR_OWVAR 21
101300: PUSH
101301: LD_INT 0
101303: ST_TO_ADDR
// hc_class := class_horse ;
101304: LD_ADDR_OWVAR 28
101308: PUSH
101309: LD_INT 21
101311: ST_TO_ADDR
// hc_gallery :=  ;
101312: LD_ADDR_OWVAR 33
101316: PUSH
101317: LD_STRING 
101319: ST_TO_ADDR
// end ;
101320: LD_VAR 0 1
101324: RET
// export function PrepareMastodont ( ) ; begin
101325: LD_INT 0
101327: PPUSH
// uc_side := 0 ;
101328: LD_ADDR_OWVAR 20
101332: PUSH
101333: LD_INT 0
101335: ST_TO_ADDR
// uc_nation := 0 ;
101336: LD_ADDR_OWVAR 21
101340: PUSH
101341: LD_INT 0
101343: ST_TO_ADDR
// vc_chassis := class_mastodont ;
101344: LD_ADDR_OWVAR 37
101348: PUSH
101349: LD_INT 31
101351: ST_TO_ADDR
// vc_control := control_rider ;
101352: LD_ADDR_OWVAR 38
101356: PUSH
101357: LD_INT 4
101359: ST_TO_ADDR
// end ;
101360: LD_VAR 0 1
101364: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
101365: LD_INT 0
101367: PPUSH
101368: PPUSH
101369: PPUSH
// uc_side = 0 ;
101370: LD_ADDR_OWVAR 20
101374: PUSH
101375: LD_INT 0
101377: ST_TO_ADDR
// uc_nation = 0 ;
101378: LD_ADDR_OWVAR 21
101382: PUSH
101383: LD_INT 0
101385: ST_TO_ADDR
// InitHc_All ( ) ;
101386: CALL_OW 584
// InitVc ;
101390: CALL_OW 20
// if mastodonts then
101394: LD_VAR 0 6
101398: IFFALSE 101465
// for i = 1 to mastodonts do
101400: LD_ADDR_VAR 0 11
101404: PUSH
101405: DOUBLE
101406: LD_INT 1
101408: DEC
101409: ST_TO_ADDR
101410: LD_VAR 0 6
101414: PUSH
101415: FOR_TO
101416: IFFALSE 101463
// begin vc_chassis := 31 ;
101418: LD_ADDR_OWVAR 37
101422: PUSH
101423: LD_INT 31
101425: ST_TO_ADDR
// vc_control := control_rider ;
101426: LD_ADDR_OWVAR 38
101430: PUSH
101431: LD_INT 4
101433: ST_TO_ADDR
// animal := CreateVehicle ;
101434: LD_ADDR_VAR 0 12
101438: PUSH
101439: CALL_OW 45
101443: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101444: LD_VAR 0 12
101448: PPUSH
101449: LD_VAR 0 8
101453: PPUSH
101454: LD_INT 0
101456: PPUSH
101457: CALL 103600 0 3
// end ;
101461: GO 101415
101463: POP
101464: POP
// if horses then
101465: LD_VAR 0 5
101469: IFFALSE 101536
// for i = 1 to horses do
101471: LD_ADDR_VAR 0 11
101475: PUSH
101476: DOUBLE
101477: LD_INT 1
101479: DEC
101480: ST_TO_ADDR
101481: LD_VAR 0 5
101485: PUSH
101486: FOR_TO
101487: IFFALSE 101534
// begin hc_class := 21 ;
101489: LD_ADDR_OWVAR 28
101493: PUSH
101494: LD_INT 21
101496: ST_TO_ADDR
// hc_gallery :=  ;
101497: LD_ADDR_OWVAR 33
101501: PUSH
101502: LD_STRING 
101504: ST_TO_ADDR
// animal := CreateHuman ;
101505: LD_ADDR_VAR 0 12
101509: PUSH
101510: CALL_OW 44
101514: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101515: LD_VAR 0 12
101519: PPUSH
101520: LD_VAR 0 8
101524: PPUSH
101525: LD_INT 0
101527: PPUSH
101528: CALL 103600 0 3
// end ;
101532: GO 101486
101534: POP
101535: POP
// if birds then
101536: LD_VAR 0 1
101540: IFFALSE 101607
// for i = 1 to birds do
101542: LD_ADDR_VAR 0 11
101546: PUSH
101547: DOUBLE
101548: LD_INT 1
101550: DEC
101551: ST_TO_ADDR
101552: LD_VAR 0 1
101556: PUSH
101557: FOR_TO
101558: IFFALSE 101605
// begin hc_class = 18 ;
101560: LD_ADDR_OWVAR 28
101564: PUSH
101565: LD_INT 18
101567: ST_TO_ADDR
// hc_gallery =  ;
101568: LD_ADDR_OWVAR 33
101572: PUSH
101573: LD_STRING 
101575: ST_TO_ADDR
// animal := CreateHuman ;
101576: LD_ADDR_VAR 0 12
101580: PUSH
101581: CALL_OW 44
101585: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101586: LD_VAR 0 12
101590: PPUSH
101591: LD_VAR 0 8
101595: PPUSH
101596: LD_INT 0
101598: PPUSH
101599: CALL 103600 0 3
// end ;
101603: GO 101557
101605: POP
101606: POP
// if tigers then
101607: LD_VAR 0 2
101611: IFFALSE 101695
// for i = 1 to tigers do
101613: LD_ADDR_VAR 0 11
101617: PUSH
101618: DOUBLE
101619: LD_INT 1
101621: DEC
101622: ST_TO_ADDR
101623: LD_VAR 0 2
101627: PUSH
101628: FOR_TO
101629: IFFALSE 101693
// begin hc_class = class_tiger ;
101631: LD_ADDR_OWVAR 28
101635: PUSH
101636: LD_INT 14
101638: ST_TO_ADDR
// hc_gallery =  ;
101639: LD_ADDR_OWVAR 33
101643: PUSH
101644: LD_STRING 
101646: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
101647: LD_ADDR_OWVAR 35
101651: PUSH
101652: LD_INT 7
101654: NEG
101655: PPUSH
101656: LD_INT 7
101658: PPUSH
101659: CALL_OW 12
101663: ST_TO_ADDR
// animal := CreateHuman ;
101664: LD_ADDR_VAR 0 12
101668: PUSH
101669: CALL_OW 44
101673: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101674: LD_VAR 0 12
101678: PPUSH
101679: LD_VAR 0 8
101683: PPUSH
101684: LD_INT 0
101686: PPUSH
101687: CALL 103600 0 3
// end ;
101691: GO 101628
101693: POP
101694: POP
// if apemans then
101695: LD_VAR 0 3
101699: IFFALSE 101822
// for i = 1 to apemans do
101701: LD_ADDR_VAR 0 11
101705: PUSH
101706: DOUBLE
101707: LD_INT 1
101709: DEC
101710: ST_TO_ADDR
101711: LD_VAR 0 3
101715: PUSH
101716: FOR_TO
101717: IFFALSE 101820
// begin hc_class = class_apeman ;
101719: LD_ADDR_OWVAR 28
101723: PUSH
101724: LD_INT 12
101726: ST_TO_ADDR
// hc_gallery =  ;
101727: LD_ADDR_OWVAR 33
101731: PUSH
101732: LD_STRING 
101734: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
101735: LD_ADDR_OWVAR 35
101739: PUSH
101740: LD_INT 2
101742: NEG
101743: PPUSH
101744: LD_INT 2
101746: PPUSH
101747: CALL_OW 12
101751: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
101752: LD_ADDR_OWVAR 31
101756: PUSH
101757: LD_INT 1
101759: PPUSH
101760: LD_INT 3
101762: PPUSH
101763: CALL_OW 12
101767: PUSH
101768: LD_INT 1
101770: PPUSH
101771: LD_INT 3
101773: PPUSH
101774: CALL_OW 12
101778: PUSH
101779: LD_INT 0
101781: PUSH
101782: LD_INT 0
101784: PUSH
101785: EMPTY
101786: LIST
101787: LIST
101788: LIST
101789: LIST
101790: ST_TO_ADDR
// animal := CreateHuman ;
101791: LD_ADDR_VAR 0 12
101795: PUSH
101796: CALL_OW 44
101800: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101801: LD_VAR 0 12
101805: PPUSH
101806: LD_VAR 0 8
101810: PPUSH
101811: LD_INT 0
101813: PPUSH
101814: CALL 103600 0 3
// end ;
101818: GO 101716
101820: POP
101821: POP
// if enchidnas then
101822: LD_VAR 0 4
101826: IFFALSE 101893
// for i = 1 to enchidnas do
101828: LD_ADDR_VAR 0 11
101832: PUSH
101833: DOUBLE
101834: LD_INT 1
101836: DEC
101837: ST_TO_ADDR
101838: LD_VAR 0 4
101842: PUSH
101843: FOR_TO
101844: IFFALSE 101891
// begin hc_class = 13 ;
101846: LD_ADDR_OWVAR 28
101850: PUSH
101851: LD_INT 13
101853: ST_TO_ADDR
// hc_gallery =  ;
101854: LD_ADDR_OWVAR 33
101858: PUSH
101859: LD_STRING 
101861: ST_TO_ADDR
// animal := CreateHuman ;
101862: LD_ADDR_VAR 0 12
101866: PUSH
101867: CALL_OW 44
101871: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101872: LD_VAR 0 12
101876: PPUSH
101877: LD_VAR 0 8
101881: PPUSH
101882: LD_INT 0
101884: PPUSH
101885: CALL 103600 0 3
// end ;
101889: GO 101843
101891: POP
101892: POP
// if fishes then
101893: LD_VAR 0 7
101897: IFFALSE 101964
// for i = 1 to fishes do
101899: LD_ADDR_VAR 0 11
101903: PUSH
101904: DOUBLE
101905: LD_INT 1
101907: DEC
101908: ST_TO_ADDR
101909: LD_VAR 0 7
101913: PUSH
101914: FOR_TO
101915: IFFALSE 101962
// begin hc_class = 20 ;
101917: LD_ADDR_OWVAR 28
101921: PUSH
101922: LD_INT 20
101924: ST_TO_ADDR
// hc_gallery =  ;
101925: LD_ADDR_OWVAR 33
101929: PUSH
101930: LD_STRING 
101932: ST_TO_ADDR
// animal := CreateHuman ;
101933: LD_ADDR_VAR 0 12
101937: PUSH
101938: CALL_OW 44
101942: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
101943: LD_VAR 0 12
101947: PPUSH
101948: LD_VAR 0 9
101952: PPUSH
101953: LD_INT 0
101955: PPUSH
101956: CALL 103600 0 3
// end ;
101960: GO 101914
101962: POP
101963: POP
// end ;
101964: LD_VAR 0 10
101968: RET
// export function WantHeal ( sci , unit ) ; begin
101969: LD_INT 0
101971: PPUSH
// if GetTaskList ( sci ) > 0 then
101972: LD_VAR 0 1
101976: PPUSH
101977: CALL_OW 437
101981: PUSH
101982: LD_INT 0
101984: GREATER
101985: IFFALSE 102055
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
101987: LD_VAR 0 1
101991: PPUSH
101992: CALL_OW 437
101996: PUSH
101997: LD_INT 1
101999: ARRAY
102000: PUSH
102001: LD_INT 1
102003: ARRAY
102004: PUSH
102005: LD_STRING l
102007: EQUAL
102008: PUSH
102009: LD_VAR 0 1
102013: PPUSH
102014: CALL_OW 437
102018: PUSH
102019: LD_INT 1
102021: ARRAY
102022: PUSH
102023: LD_INT 4
102025: ARRAY
102026: PUSH
102027: LD_VAR 0 2
102031: EQUAL
102032: AND
102033: IFFALSE 102045
// result := true else
102035: LD_ADDR_VAR 0 3
102039: PUSH
102040: LD_INT 1
102042: ST_TO_ADDR
102043: GO 102053
// result := false ;
102045: LD_ADDR_VAR 0 3
102049: PUSH
102050: LD_INT 0
102052: ST_TO_ADDR
// end else
102053: GO 102063
// result := false ;
102055: LD_ADDR_VAR 0 3
102059: PUSH
102060: LD_INT 0
102062: ST_TO_ADDR
// end ;
102063: LD_VAR 0 3
102067: RET
// export function HealTarget ( sci ) ; begin
102068: LD_INT 0
102070: PPUSH
// if not sci then
102071: LD_VAR 0 1
102075: NOT
102076: IFFALSE 102080
// exit ;
102078: GO 102145
// result := 0 ;
102080: LD_ADDR_VAR 0 2
102084: PUSH
102085: LD_INT 0
102087: ST_TO_ADDR
// if GetTaskList ( sci ) then
102088: LD_VAR 0 1
102092: PPUSH
102093: CALL_OW 437
102097: IFFALSE 102145
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
102099: LD_VAR 0 1
102103: PPUSH
102104: CALL_OW 437
102108: PUSH
102109: LD_INT 1
102111: ARRAY
102112: PUSH
102113: LD_INT 1
102115: ARRAY
102116: PUSH
102117: LD_STRING l
102119: EQUAL
102120: IFFALSE 102145
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
102122: LD_ADDR_VAR 0 2
102126: PUSH
102127: LD_VAR 0 1
102131: PPUSH
102132: CALL_OW 437
102136: PUSH
102137: LD_INT 1
102139: ARRAY
102140: PUSH
102141: LD_INT 4
102143: ARRAY
102144: ST_TO_ADDR
// end ;
102145: LD_VAR 0 2
102149: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
102150: LD_INT 0
102152: PPUSH
102153: PPUSH
102154: PPUSH
102155: PPUSH
// if not base_units then
102156: LD_VAR 0 1
102160: NOT
102161: IFFALSE 102165
// exit ;
102163: GO 102252
// result := false ;
102165: LD_ADDR_VAR 0 2
102169: PUSH
102170: LD_INT 0
102172: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
102173: LD_ADDR_VAR 0 5
102177: PUSH
102178: LD_VAR 0 1
102182: PPUSH
102183: LD_INT 21
102185: PUSH
102186: LD_INT 3
102188: PUSH
102189: EMPTY
102190: LIST
102191: LIST
102192: PPUSH
102193: CALL_OW 72
102197: ST_TO_ADDR
// if not tmp then
102198: LD_VAR 0 5
102202: NOT
102203: IFFALSE 102207
// exit ;
102205: GO 102252
// for i in tmp do
102207: LD_ADDR_VAR 0 3
102211: PUSH
102212: LD_VAR 0 5
102216: PUSH
102217: FOR_IN
102218: IFFALSE 102250
// begin result := EnemyInRange ( i , 22 ) ;
102220: LD_ADDR_VAR 0 2
102224: PUSH
102225: LD_VAR 0 3
102229: PPUSH
102230: LD_INT 22
102232: PPUSH
102233: CALL 99865 0 2
102237: ST_TO_ADDR
// if result then
102238: LD_VAR 0 2
102242: IFFALSE 102248
// exit ;
102244: POP
102245: POP
102246: GO 102252
// end ;
102248: GO 102217
102250: POP
102251: POP
// end ;
102252: LD_VAR 0 2
102256: RET
// export function FilterByTag ( units , tag ) ; begin
102257: LD_INT 0
102259: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
102260: LD_ADDR_VAR 0 3
102264: PUSH
102265: LD_VAR 0 1
102269: PPUSH
102270: LD_INT 120
102272: PUSH
102273: LD_VAR 0 2
102277: PUSH
102278: EMPTY
102279: LIST
102280: LIST
102281: PPUSH
102282: CALL_OW 72
102286: ST_TO_ADDR
// end ;
102287: LD_VAR 0 3
102291: RET
// export function IsDriver ( un ) ; begin
102292: LD_INT 0
102294: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
102295: LD_ADDR_VAR 0 2
102299: PUSH
102300: LD_VAR 0 1
102304: PUSH
102305: LD_INT 55
102307: PUSH
102308: EMPTY
102309: LIST
102310: PPUSH
102311: CALL_OW 69
102315: IN
102316: ST_TO_ADDR
// end ;
102317: LD_VAR 0 2
102321: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
102322: LD_INT 0
102324: PPUSH
102325: PPUSH
// list := [ ] ;
102326: LD_ADDR_VAR 0 5
102330: PUSH
102331: EMPTY
102332: ST_TO_ADDR
// case d of 0 :
102333: LD_VAR 0 3
102337: PUSH
102338: LD_INT 0
102340: DOUBLE
102341: EQUAL
102342: IFTRUE 102346
102344: GO 102479
102346: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
102347: LD_ADDR_VAR 0 5
102351: PUSH
102352: LD_VAR 0 1
102356: PUSH
102357: LD_INT 4
102359: MINUS
102360: PUSH
102361: LD_VAR 0 2
102365: PUSH
102366: LD_INT 4
102368: MINUS
102369: PUSH
102370: LD_INT 2
102372: PUSH
102373: EMPTY
102374: LIST
102375: LIST
102376: LIST
102377: PUSH
102378: LD_VAR 0 1
102382: PUSH
102383: LD_INT 3
102385: MINUS
102386: PUSH
102387: LD_VAR 0 2
102391: PUSH
102392: LD_INT 1
102394: PUSH
102395: EMPTY
102396: LIST
102397: LIST
102398: LIST
102399: PUSH
102400: LD_VAR 0 1
102404: PUSH
102405: LD_INT 4
102407: PLUS
102408: PUSH
102409: LD_VAR 0 2
102413: PUSH
102414: LD_INT 4
102416: PUSH
102417: EMPTY
102418: LIST
102419: LIST
102420: LIST
102421: PUSH
102422: LD_VAR 0 1
102426: PUSH
102427: LD_INT 3
102429: PLUS
102430: PUSH
102431: LD_VAR 0 2
102435: PUSH
102436: LD_INT 3
102438: PLUS
102439: PUSH
102440: LD_INT 5
102442: PUSH
102443: EMPTY
102444: LIST
102445: LIST
102446: LIST
102447: PUSH
102448: LD_VAR 0 1
102452: PUSH
102453: LD_VAR 0 2
102457: PUSH
102458: LD_INT 4
102460: PLUS
102461: PUSH
102462: LD_INT 0
102464: PUSH
102465: EMPTY
102466: LIST
102467: LIST
102468: LIST
102469: PUSH
102470: EMPTY
102471: LIST
102472: LIST
102473: LIST
102474: LIST
102475: LIST
102476: ST_TO_ADDR
// end ; 1 :
102477: GO 103177
102479: LD_INT 1
102481: DOUBLE
102482: EQUAL
102483: IFTRUE 102487
102485: GO 102620
102487: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
102488: LD_ADDR_VAR 0 5
102492: PUSH
102493: LD_VAR 0 1
102497: PUSH
102498: LD_VAR 0 2
102502: PUSH
102503: LD_INT 4
102505: MINUS
102506: PUSH
102507: LD_INT 3
102509: PUSH
102510: EMPTY
102511: LIST
102512: LIST
102513: LIST
102514: PUSH
102515: LD_VAR 0 1
102519: PUSH
102520: LD_INT 3
102522: MINUS
102523: PUSH
102524: LD_VAR 0 2
102528: PUSH
102529: LD_INT 3
102531: MINUS
102532: PUSH
102533: LD_INT 2
102535: PUSH
102536: EMPTY
102537: LIST
102538: LIST
102539: LIST
102540: PUSH
102541: LD_VAR 0 1
102545: PUSH
102546: LD_INT 4
102548: MINUS
102549: PUSH
102550: LD_VAR 0 2
102554: PUSH
102555: LD_INT 1
102557: PUSH
102558: EMPTY
102559: LIST
102560: LIST
102561: LIST
102562: PUSH
102563: LD_VAR 0 1
102567: PUSH
102568: LD_VAR 0 2
102572: PUSH
102573: LD_INT 3
102575: PLUS
102576: PUSH
102577: LD_INT 0
102579: PUSH
102580: EMPTY
102581: LIST
102582: LIST
102583: LIST
102584: PUSH
102585: LD_VAR 0 1
102589: PUSH
102590: LD_INT 4
102592: PLUS
102593: PUSH
102594: LD_VAR 0 2
102598: PUSH
102599: LD_INT 4
102601: PLUS
102602: PUSH
102603: LD_INT 5
102605: PUSH
102606: EMPTY
102607: LIST
102608: LIST
102609: LIST
102610: PUSH
102611: EMPTY
102612: LIST
102613: LIST
102614: LIST
102615: LIST
102616: LIST
102617: ST_TO_ADDR
// end ; 2 :
102618: GO 103177
102620: LD_INT 2
102622: DOUBLE
102623: EQUAL
102624: IFTRUE 102628
102626: GO 102757
102628: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
102629: LD_ADDR_VAR 0 5
102633: PUSH
102634: LD_VAR 0 1
102638: PUSH
102639: LD_VAR 0 2
102643: PUSH
102644: LD_INT 3
102646: MINUS
102647: PUSH
102648: LD_INT 3
102650: PUSH
102651: EMPTY
102652: LIST
102653: LIST
102654: LIST
102655: PUSH
102656: LD_VAR 0 1
102660: PUSH
102661: LD_INT 4
102663: PLUS
102664: PUSH
102665: LD_VAR 0 2
102669: PUSH
102670: LD_INT 4
102672: PUSH
102673: EMPTY
102674: LIST
102675: LIST
102676: LIST
102677: PUSH
102678: LD_VAR 0 1
102682: PUSH
102683: LD_VAR 0 2
102687: PUSH
102688: LD_INT 4
102690: PLUS
102691: PUSH
102692: LD_INT 0
102694: PUSH
102695: EMPTY
102696: LIST
102697: LIST
102698: LIST
102699: PUSH
102700: LD_VAR 0 1
102704: PUSH
102705: LD_INT 3
102707: MINUS
102708: PUSH
102709: LD_VAR 0 2
102713: PUSH
102714: LD_INT 1
102716: PUSH
102717: EMPTY
102718: LIST
102719: LIST
102720: LIST
102721: PUSH
102722: LD_VAR 0 1
102726: PUSH
102727: LD_INT 4
102729: MINUS
102730: PUSH
102731: LD_VAR 0 2
102735: PUSH
102736: LD_INT 4
102738: MINUS
102739: PUSH
102740: LD_INT 2
102742: PUSH
102743: EMPTY
102744: LIST
102745: LIST
102746: LIST
102747: PUSH
102748: EMPTY
102749: LIST
102750: LIST
102751: LIST
102752: LIST
102753: LIST
102754: ST_TO_ADDR
// end ; 3 :
102755: GO 103177
102757: LD_INT 3
102759: DOUBLE
102760: EQUAL
102761: IFTRUE 102765
102763: GO 102898
102765: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
102766: LD_ADDR_VAR 0 5
102770: PUSH
102771: LD_VAR 0 1
102775: PUSH
102776: LD_INT 3
102778: PLUS
102779: PUSH
102780: LD_VAR 0 2
102784: PUSH
102785: LD_INT 4
102787: PUSH
102788: EMPTY
102789: LIST
102790: LIST
102791: LIST
102792: PUSH
102793: LD_VAR 0 1
102797: PUSH
102798: LD_INT 4
102800: PLUS
102801: PUSH
102802: LD_VAR 0 2
102806: PUSH
102807: LD_INT 4
102809: PLUS
102810: PUSH
102811: LD_INT 5
102813: PUSH
102814: EMPTY
102815: LIST
102816: LIST
102817: LIST
102818: PUSH
102819: LD_VAR 0 1
102823: PUSH
102824: LD_INT 4
102826: MINUS
102827: PUSH
102828: LD_VAR 0 2
102832: PUSH
102833: LD_INT 1
102835: PUSH
102836: EMPTY
102837: LIST
102838: LIST
102839: LIST
102840: PUSH
102841: LD_VAR 0 1
102845: PUSH
102846: LD_VAR 0 2
102850: PUSH
102851: LD_INT 4
102853: MINUS
102854: PUSH
102855: LD_INT 3
102857: PUSH
102858: EMPTY
102859: LIST
102860: LIST
102861: LIST
102862: PUSH
102863: LD_VAR 0 1
102867: PUSH
102868: LD_INT 3
102870: MINUS
102871: PUSH
102872: LD_VAR 0 2
102876: PUSH
102877: LD_INT 3
102879: MINUS
102880: PUSH
102881: LD_INT 2
102883: PUSH
102884: EMPTY
102885: LIST
102886: LIST
102887: LIST
102888: PUSH
102889: EMPTY
102890: LIST
102891: LIST
102892: LIST
102893: LIST
102894: LIST
102895: ST_TO_ADDR
// end ; 4 :
102896: GO 103177
102898: LD_INT 4
102900: DOUBLE
102901: EQUAL
102902: IFTRUE 102906
102904: GO 103039
102906: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
102907: LD_ADDR_VAR 0 5
102911: PUSH
102912: LD_VAR 0 1
102916: PUSH
102917: LD_VAR 0 2
102921: PUSH
102922: LD_INT 4
102924: PLUS
102925: PUSH
102926: LD_INT 0
102928: PUSH
102929: EMPTY
102930: LIST
102931: LIST
102932: LIST
102933: PUSH
102934: LD_VAR 0 1
102938: PUSH
102939: LD_INT 3
102941: PLUS
102942: PUSH
102943: LD_VAR 0 2
102947: PUSH
102948: LD_INT 3
102950: PLUS
102951: PUSH
102952: LD_INT 5
102954: PUSH
102955: EMPTY
102956: LIST
102957: LIST
102958: LIST
102959: PUSH
102960: LD_VAR 0 1
102964: PUSH
102965: LD_INT 4
102967: PLUS
102968: PUSH
102969: LD_VAR 0 2
102973: PUSH
102974: LD_INT 4
102976: PUSH
102977: EMPTY
102978: LIST
102979: LIST
102980: LIST
102981: PUSH
102982: LD_VAR 0 1
102986: PUSH
102987: LD_VAR 0 2
102991: PUSH
102992: LD_INT 3
102994: MINUS
102995: PUSH
102996: LD_INT 3
102998: PUSH
102999: EMPTY
103000: LIST
103001: LIST
103002: LIST
103003: PUSH
103004: LD_VAR 0 1
103008: PUSH
103009: LD_INT 4
103011: MINUS
103012: PUSH
103013: LD_VAR 0 2
103017: PUSH
103018: LD_INT 4
103020: MINUS
103021: PUSH
103022: LD_INT 2
103024: PUSH
103025: EMPTY
103026: LIST
103027: LIST
103028: LIST
103029: PUSH
103030: EMPTY
103031: LIST
103032: LIST
103033: LIST
103034: LIST
103035: LIST
103036: ST_TO_ADDR
// end ; 5 :
103037: GO 103177
103039: LD_INT 5
103041: DOUBLE
103042: EQUAL
103043: IFTRUE 103047
103045: GO 103176
103047: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
103048: LD_ADDR_VAR 0 5
103052: PUSH
103053: LD_VAR 0 1
103057: PUSH
103058: LD_INT 4
103060: MINUS
103061: PUSH
103062: LD_VAR 0 2
103066: PUSH
103067: LD_INT 1
103069: PUSH
103070: EMPTY
103071: LIST
103072: LIST
103073: LIST
103074: PUSH
103075: LD_VAR 0 1
103079: PUSH
103080: LD_VAR 0 2
103084: PUSH
103085: LD_INT 4
103087: MINUS
103088: PUSH
103089: LD_INT 3
103091: PUSH
103092: EMPTY
103093: LIST
103094: LIST
103095: LIST
103096: PUSH
103097: LD_VAR 0 1
103101: PUSH
103102: LD_INT 4
103104: PLUS
103105: PUSH
103106: LD_VAR 0 2
103110: PUSH
103111: LD_INT 4
103113: PLUS
103114: PUSH
103115: LD_INT 5
103117: PUSH
103118: EMPTY
103119: LIST
103120: LIST
103121: LIST
103122: PUSH
103123: LD_VAR 0 1
103127: PUSH
103128: LD_INT 3
103130: PLUS
103131: PUSH
103132: LD_VAR 0 2
103136: PUSH
103137: LD_INT 4
103139: PUSH
103140: EMPTY
103141: LIST
103142: LIST
103143: LIST
103144: PUSH
103145: LD_VAR 0 1
103149: PUSH
103150: LD_VAR 0 2
103154: PUSH
103155: LD_INT 3
103157: PLUS
103158: PUSH
103159: LD_INT 0
103161: PUSH
103162: EMPTY
103163: LIST
103164: LIST
103165: LIST
103166: PUSH
103167: EMPTY
103168: LIST
103169: LIST
103170: LIST
103171: LIST
103172: LIST
103173: ST_TO_ADDR
// end ; end ;
103174: GO 103177
103176: POP
// result := list ;
103177: LD_ADDR_VAR 0 4
103181: PUSH
103182: LD_VAR 0 5
103186: ST_TO_ADDR
// end ;
103187: LD_VAR 0 4
103191: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
103192: LD_INT 0
103194: PPUSH
103195: PPUSH
103196: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
103197: LD_VAR 0 1
103201: NOT
103202: PUSH
103203: LD_VAR 0 2
103207: PUSH
103208: LD_INT 1
103210: PUSH
103211: LD_INT 2
103213: PUSH
103214: LD_INT 3
103216: PUSH
103217: LD_INT 4
103219: PUSH
103220: EMPTY
103221: LIST
103222: LIST
103223: LIST
103224: LIST
103225: IN
103226: NOT
103227: OR
103228: IFFALSE 103232
// exit ;
103230: GO 103324
// tmp := [ ] ;
103232: LD_ADDR_VAR 0 5
103236: PUSH
103237: EMPTY
103238: ST_TO_ADDR
// for i in units do
103239: LD_ADDR_VAR 0 4
103243: PUSH
103244: LD_VAR 0 1
103248: PUSH
103249: FOR_IN
103250: IFFALSE 103293
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
103252: LD_ADDR_VAR 0 5
103256: PUSH
103257: LD_VAR 0 5
103261: PPUSH
103262: LD_VAR 0 5
103266: PUSH
103267: LD_INT 1
103269: PLUS
103270: PPUSH
103271: LD_VAR 0 4
103275: PPUSH
103276: LD_VAR 0 2
103280: PPUSH
103281: CALL_OW 259
103285: PPUSH
103286: CALL_OW 2
103290: ST_TO_ADDR
103291: GO 103249
103293: POP
103294: POP
// if not tmp then
103295: LD_VAR 0 5
103299: NOT
103300: IFFALSE 103304
// exit ;
103302: GO 103324
// result := SortListByListDesc ( units , tmp ) ;
103304: LD_ADDR_VAR 0 3
103308: PUSH
103309: LD_VAR 0 1
103313: PPUSH
103314: LD_VAR 0 5
103318: PPUSH
103319: CALL_OW 77
103323: ST_TO_ADDR
// end ;
103324: LD_VAR 0 3
103328: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
103329: LD_INT 0
103331: PPUSH
103332: PPUSH
103333: PPUSH
// result := false ;
103334: LD_ADDR_VAR 0 3
103338: PUSH
103339: LD_INT 0
103341: ST_TO_ADDR
// x := GetX ( building ) ;
103342: LD_ADDR_VAR 0 4
103346: PUSH
103347: LD_VAR 0 2
103351: PPUSH
103352: CALL_OW 250
103356: ST_TO_ADDR
// y := GetY ( building ) ;
103357: LD_ADDR_VAR 0 5
103361: PUSH
103362: LD_VAR 0 2
103366: PPUSH
103367: CALL_OW 251
103371: ST_TO_ADDR
// if not building or not x or not y then
103372: LD_VAR 0 2
103376: NOT
103377: PUSH
103378: LD_VAR 0 4
103382: NOT
103383: OR
103384: PUSH
103385: LD_VAR 0 5
103389: NOT
103390: OR
103391: IFFALSE 103395
// exit ;
103393: GO 103487
// if GetTaskList ( unit ) then
103395: LD_VAR 0 1
103399: PPUSH
103400: CALL_OW 437
103404: IFFALSE 103487
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
103406: LD_STRING e
103408: PUSH
103409: LD_VAR 0 1
103413: PPUSH
103414: CALL_OW 437
103418: PUSH
103419: LD_INT 1
103421: ARRAY
103422: PUSH
103423: LD_INT 1
103425: ARRAY
103426: EQUAL
103427: PUSH
103428: LD_VAR 0 4
103432: PUSH
103433: LD_VAR 0 1
103437: PPUSH
103438: CALL_OW 437
103442: PUSH
103443: LD_INT 1
103445: ARRAY
103446: PUSH
103447: LD_INT 2
103449: ARRAY
103450: EQUAL
103451: AND
103452: PUSH
103453: LD_VAR 0 5
103457: PUSH
103458: LD_VAR 0 1
103462: PPUSH
103463: CALL_OW 437
103467: PUSH
103468: LD_INT 1
103470: ARRAY
103471: PUSH
103472: LD_INT 3
103474: ARRAY
103475: EQUAL
103476: AND
103477: IFFALSE 103487
// result := true end ;
103479: LD_ADDR_VAR 0 3
103483: PUSH
103484: LD_INT 1
103486: ST_TO_ADDR
// end ;
103487: LD_VAR 0 3
103491: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
103492: LD_INT 0
103494: PPUSH
// result := false ;
103495: LD_ADDR_VAR 0 4
103499: PUSH
103500: LD_INT 0
103502: ST_TO_ADDR
// if GetTaskList ( unit ) then
103503: LD_VAR 0 1
103507: PPUSH
103508: CALL_OW 437
103512: IFFALSE 103595
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
103514: LD_STRING M
103516: PUSH
103517: LD_VAR 0 1
103521: PPUSH
103522: CALL_OW 437
103526: PUSH
103527: LD_INT 1
103529: ARRAY
103530: PUSH
103531: LD_INT 1
103533: ARRAY
103534: EQUAL
103535: PUSH
103536: LD_VAR 0 2
103540: PUSH
103541: LD_VAR 0 1
103545: PPUSH
103546: CALL_OW 437
103550: PUSH
103551: LD_INT 1
103553: ARRAY
103554: PUSH
103555: LD_INT 2
103557: ARRAY
103558: EQUAL
103559: AND
103560: PUSH
103561: LD_VAR 0 3
103565: PUSH
103566: LD_VAR 0 1
103570: PPUSH
103571: CALL_OW 437
103575: PUSH
103576: LD_INT 1
103578: ARRAY
103579: PUSH
103580: LD_INT 3
103582: ARRAY
103583: EQUAL
103584: AND
103585: IFFALSE 103595
// result := true ;
103587: LD_ADDR_VAR 0 4
103591: PUSH
103592: LD_INT 1
103594: ST_TO_ADDR
// end ; end ;
103595: LD_VAR 0 4
103599: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
103600: LD_INT 0
103602: PPUSH
103603: PPUSH
103604: PPUSH
103605: PPUSH
// if not unit or not area then
103606: LD_VAR 0 1
103610: NOT
103611: PUSH
103612: LD_VAR 0 2
103616: NOT
103617: OR
103618: IFFALSE 103622
// exit ;
103620: GO 103786
// tmp := AreaToList ( area , i ) ;
103622: LD_ADDR_VAR 0 6
103626: PUSH
103627: LD_VAR 0 2
103631: PPUSH
103632: LD_VAR 0 5
103636: PPUSH
103637: CALL_OW 517
103641: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
103642: LD_ADDR_VAR 0 5
103646: PUSH
103647: DOUBLE
103648: LD_INT 1
103650: DEC
103651: ST_TO_ADDR
103652: LD_VAR 0 6
103656: PUSH
103657: LD_INT 1
103659: ARRAY
103660: PUSH
103661: FOR_TO
103662: IFFALSE 103784
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
103664: LD_ADDR_VAR 0 7
103668: PUSH
103669: LD_VAR 0 6
103673: PUSH
103674: LD_INT 1
103676: ARRAY
103677: PUSH
103678: LD_VAR 0 5
103682: ARRAY
103683: PUSH
103684: LD_VAR 0 6
103688: PUSH
103689: LD_INT 2
103691: ARRAY
103692: PUSH
103693: LD_VAR 0 5
103697: ARRAY
103698: PUSH
103699: EMPTY
103700: LIST
103701: LIST
103702: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
103703: LD_VAR 0 7
103707: PUSH
103708: LD_INT 1
103710: ARRAY
103711: PPUSH
103712: LD_VAR 0 7
103716: PUSH
103717: LD_INT 2
103719: ARRAY
103720: PPUSH
103721: CALL_OW 428
103725: PUSH
103726: LD_INT 0
103728: EQUAL
103729: IFFALSE 103782
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
103731: LD_VAR 0 1
103735: PPUSH
103736: LD_VAR 0 7
103740: PUSH
103741: LD_INT 1
103743: ARRAY
103744: PPUSH
103745: LD_VAR 0 7
103749: PUSH
103750: LD_INT 2
103752: ARRAY
103753: PPUSH
103754: LD_VAR 0 3
103758: PPUSH
103759: CALL_OW 48
// result := IsPlaced ( unit ) ;
103763: LD_ADDR_VAR 0 4
103767: PUSH
103768: LD_VAR 0 1
103772: PPUSH
103773: CALL_OW 305
103777: ST_TO_ADDR
// exit ;
103778: POP
103779: POP
103780: GO 103786
// end ; end ;
103782: GO 103661
103784: POP
103785: POP
// end ;
103786: LD_VAR 0 4
103790: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
103791: LD_INT 0
103793: PPUSH
103794: PPUSH
103795: PPUSH
// if not side or side > 8 then
103796: LD_VAR 0 1
103800: NOT
103801: PUSH
103802: LD_VAR 0 1
103806: PUSH
103807: LD_INT 8
103809: GREATER
103810: OR
103811: IFFALSE 103815
// exit ;
103813: GO 104002
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
103815: LD_ADDR_VAR 0 4
103819: PUSH
103820: LD_INT 22
103822: PUSH
103823: LD_VAR 0 1
103827: PUSH
103828: EMPTY
103829: LIST
103830: LIST
103831: PUSH
103832: LD_INT 21
103834: PUSH
103835: LD_INT 3
103837: PUSH
103838: EMPTY
103839: LIST
103840: LIST
103841: PUSH
103842: EMPTY
103843: LIST
103844: LIST
103845: PPUSH
103846: CALL_OW 69
103850: ST_TO_ADDR
// if not tmp then
103851: LD_VAR 0 4
103855: NOT
103856: IFFALSE 103860
// exit ;
103858: GO 104002
// enable_addtolog := true ;
103860: LD_ADDR_OWVAR 81
103864: PUSH
103865: LD_INT 1
103867: ST_TO_ADDR
// AddToLog ( [ ) ;
103868: LD_STRING [
103870: PPUSH
103871: CALL_OW 561
// for i in tmp do
103875: LD_ADDR_VAR 0 3
103879: PUSH
103880: LD_VAR 0 4
103884: PUSH
103885: FOR_IN
103886: IFFALSE 103993
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
103888: LD_STRING [
103890: PUSH
103891: LD_VAR 0 3
103895: PPUSH
103896: CALL_OW 266
103900: STR
103901: PUSH
103902: LD_STRING , 
103904: STR
103905: PUSH
103906: LD_VAR 0 3
103910: PPUSH
103911: CALL_OW 250
103915: STR
103916: PUSH
103917: LD_STRING , 
103919: STR
103920: PUSH
103921: LD_VAR 0 3
103925: PPUSH
103926: CALL_OW 251
103930: STR
103931: PUSH
103932: LD_STRING , 
103934: STR
103935: PUSH
103936: LD_VAR 0 3
103940: PPUSH
103941: CALL_OW 254
103945: STR
103946: PUSH
103947: LD_STRING , 
103949: STR
103950: PUSH
103951: LD_VAR 0 3
103955: PPUSH
103956: LD_INT 1
103958: PPUSH
103959: CALL_OW 268
103963: STR
103964: PUSH
103965: LD_STRING , 
103967: STR
103968: PUSH
103969: LD_VAR 0 3
103973: PPUSH
103974: LD_INT 2
103976: PPUSH
103977: CALL_OW 268
103981: STR
103982: PUSH
103983: LD_STRING ],
103985: STR
103986: PPUSH
103987: CALL_OW 561
// end ;
103991: GO 103885
103993: POP
103994: POP
// AddToLog ( ]; ) ;
103995: LD_STRING ];
103997: PPUSH
103998: CALL_OW 561
// end ;
104002: LD_VAR 0 2
104006: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
104007: LD_INT 0
104009: PPUSH
104010: PPUSH
104011: PPUSH
104012: PPUSH
104013: PPUSH
// if not area or not rate or not max then
104014: LD_VAR 0 1
104018: NOT
104019: PUSH
104020: LD_VAR 0 2
104024: NOT
104025: OR
104026: PUSH
104027: LD_VAR 0 4
104031: NOT
104032: OR
104033: IFFALSE 104037
// exit ;
104035: GO 104226
// while 1 do
104037: LD_INT 1
104039: IFFALSE 104226
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
104041: LD_ADDR_VAR 0 9
104045: PUSH
104046: LD_VAR 0 1
104050: PPUSH
104051: LD_INT 1
104053: PPUSH
104054: CALL_OW 287
104058: PUSH
104059: LD_INT 10
104061: MUL
104062: ST_TO_ADDR
// r := rate / 10 ;
104063: LD_ADDR_VAR 0 7
104067: PUSH
104068: LD_VAR 0 2
104072: PUSH
104073: LD_INT 10
104075: DIVREAL
104076: ST_TO_ADDR
// time := 1 1$00 ;
104077: LD_ADDR_VAR 0 8
104081: PUSH
104082: LD_INT 2100
104084: ST_TO_ADDR
// if amount < min then
104085: LD_VAR 0 9
104089: PUSH
104090: LD_VAR 0 3
104094: LESS
104095: IFFALSE 104113
// r := r * 2 else
104097: LD_ADDR_VAR 0 7
104101: PUSH
104102: LD_VAR 0 7
104106: PUSH
104107: LD_INT 2
104109: MUL
104110: ST_TO_ADDR
104111: GO 104139
// if amount > max then
104113: LD_VAR 0 9
104117: PUSH
104118: LD_VAR 0 4
104122: GREATER
104123: IFFALSE 104139
// r := r / 2 ;
104125: LD_ADDR_VAR 0 7
104129: PUSH
104130: LD_VAR 0 7
104134: PUSH
104135: LD_INT 2
104137: DIVREAL
104138: ST_TO_ADDR
// time := time / r ;
104139: LD_ADDR_VAR 0 8
104143: PUSH
104144: LD_VAR 0 8
104148: PUSH
104149: LD_VAR 0 7
104153: DIVREAL
104154: ST_TO_ADDR
// if time < 0 then
104155: LD_VAR 0 8
104159: PUSH
104160: LD_INT 0
104162: LESS
104163: IFFALSE 104180
// time := time * - 1 ;
104165: LD_ADDR_VAR 0 8
104169: PUSH
104170: LD_VAR 0 8
104174: PUSH
104175: LD_INT 1
104177: NEG
104178: MUL
104179: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
104180: LD_VAR 0 8
104184: PUSH
104185: LD_INT 35
104187: PPUSH
104188: LD_INT 875
104190: PPUSH
104191: CALL_OW 12
104195: PLUS
104196: PPUSH
104197: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
104201: LD_INT 1
104203: PPUSH
104204: LD_INT 5
104206: PPUSH
104207: CALL_OW 12
104211: PPUSH
104212: LD_VAR 0 1
104216: PPUSH
104217: LD_INT 1
104219: PPUSH
104220: CALL_OW 55
// end ;
104224: GO 104037
// end ;
104226: LD_VAR 0 5
104230: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
104231: LD_INT 0
104233: PPUSH
104234: PPUSH
104235: PPUSH
104236: PPUSH
104237: PPUSH
104238: PPUSH
104239: PPUSH
104240: PPUSH
// if not turrets or not factories then
104241: LD_VAR 0 1
104245: NOT
104246: PUSH
104247: LD_VAR 0 2
104251: NOT
104252: OR
104253: IFFALSE 104257
// exit ;
104255: GO 104564
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
104257: LD_ADDR_VAR 0 10
104261: PUSH
104262: LD_INT 5
104264: PUSH
104265: LD_INT 6
104267: PUSH
104268: EMPTY
104269: LIST
104270: LIST
104271: PUSH
104272: LD_INT 2
104274: PUSH
104275: LD_INT 4
104277: PUSH
104278: EMPTY
104279: LIST
104280: LIST
104281: PUSH
104282: LD_INT 3
104284: PUSH
104285: LD_INT 5
104287: PUSH
104288: EMPTY
104289: LIST
104290: LIST
104291: PUSH
104292: EMPTY
104293: LIST
104294: LIST
104295: LIST
104296: PUSH
104297: LD_INT 24
104299: PUSH
104300: LD_INT 25
104302: PUSH
104303: EMPTY
104304: LIST
104305: LIST
104306: PUSH
104307: LD_INT 23
104309: PUSH
104310: LD_INT 27
104312: PUSH
104313: EMPTY
104314: LIST
104315: LIST
104316: PUSH
104317: EMPTY
104318: LIST
104319: LIST
104320: PUSH
104321: LD_INT 42
104323: PUSH
104324: LD_INT 43
104326: PUSH
104327: EMPTY
104328: LIST
104329: LIST
104330: PUSH
104331: LD_INT 44
104333: PUSH
104334: LD_INT 46
104336: PUSH
104337: EMPTY
104338: LIST
104339: LIST
104340: PUSH
104341: LD_INT 45
104343: PUSH
104344: LD_INT 47
104346: PUSH
104347: EMPTY
104348: LIST
104349: LIST
104350: PUSH
104351: EMPTY
104352: LIST
104353: LIST
104354: LIST
104355: PUSH
104356: EMPTY
104357: LIST
104358: LIST
104359: LIST
104360: ST_TO_ADDR
// result := [ ] ;
104361: LD_ADDR_VAR 0 3
104365: PUSH
104366: EMPTY
104367: ST_TO_ADDR
// for i in turrets do
104368: LD_ADDR_VAR 0 4
104372: PUSH
104373: LD_VAR 0 1
104377: PUSH
104378: FOR_IN
104379: IFFALSE 104562
// begin nat := GetNation ( i ) ;
104381: LD_ADDR_VAR 0 7
104385: PUSH
104386: LD_VAR 0 4
104390: PPUSH
104391: CALL_OW 248
104395: ST_TO_ADDR
// weapon := 0 ;
104396: LD_ADDR_VAR 0 8
104400: PUSH
104401: LD_INT 0
104403: ST_TO_ADDR
// if not nat then
104404: LD_VAR 0 7
104408: NOT
104409: IFFALSE 104413
// continue ;
104411: GO 104378
// for j in list [ nat ] do
104413: LD_ADDR_VAR 0 5
104417: PUSH
104418: LD_VAR 0 10
104422: PUSH
104423: LD_VAR 0 7
104427: ARRAY
104428: PUSH
104429: FOR_IN
104430: IFFALSE 104471
// if GetBWeapon ( i ) = j [ 1 ] then
104432: LD_VAR 0 4
104436: PPUSH
104437: CALL_OW 269
104441: PUSH
104442: LD_VAR 0 5
104446: PUSH
104447: LD_INT 1
104449: ARRAY
104450: EQUAL
104451: IFFALSE 104469
// begin weapon := j [ 2 ] ;
104453: LD_ADDR_VAR 0 8
104457: PUSH
104458: LD_VAR 0 5
104462: PUSH
104463: LD_INT 2
104465: ARRAY
104466: ST_TO_ADDR
// break ;
104467: GO 104471
// end ;
104469: GO 104429
104471: POP
104472: POP
// if not weapon then
104473: LD_VAR 0 8
104477: NOT
104478: IFFALSE 104482
// continue ;
104480: GO 104378
// for k in factories do
104482: LD_ADDR_VAR 0 6
104486: PUSH
104487: LD_VAR 0 2
104491: PUSH
104492: FOR_IN
104493: IFFALSE 104558
// begin weapons := AvailableWeaponList ( k ) ;
104495: LD_ADDR_VAR 0 9
104499: PUSH
104500: LD_VAR 0 6
104504: PPUSH
104505: CALL_OW 478
104509: ST_TO_ADDR
// if not weapons then
104510: LD_VAR 0 9
104514: NOT
104515: IFFALSE 104519
// continue ;
104517: GO 104492
// if weapon in weapons then
104519: LD_VAR 0 8
104523: PUSH
104524: LD_VAR 0 9
104528: IN
104529: IFFALSE 104556
// begin result := [ i , weapon ] ;
104531: LD_ADDR_VAR 0 3
104535: PUSH
104536: LD_VAR 0 4
104540: PUSH
104541: LD_VAR 0 8
104545: PUSH
104546: EMPTY
104547: LIST
104548: LIST
104549: ST_TO_ADDR
// exit ;
104550: POP
104551: POP
104552: POP
104553: POP
104554: GO 104564
// end ; end ;
104556: GO 104492
104558: POP
104559: POP
// end ;
104560: GO 104378
104562: POP
104563: POP
// end ;
104564: LD_VAR 0 3
104568: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
104569: LD_INT 0
104571: PPUSH
// if not side or side > 8 then
104572: LD_VAR 0 3
104576: NOT
104577: PUSH
104578: LD_VAR 0 3
104582: PUSH
104583: LD_INT 8
104585: GREATER
104586: OR
104587: IFFALSE 104591
// exit ;
104589: GO 104650
// if not range then
104591: LD_VAR 0 4
104595: NOT
104596: IFFALSE 104607
// range := - 12 ;
104598: LD_ADDR_VAR 0 4
104602: PUSH
104603: LD_INT 12
104605: NEG
104606: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
104607: LD_VAR 0 1
104611: PPUSH
104612: LD_VAR 0 2
104616: PPUSH
104617: LD_VAR 0 3
104621: PPUSH
104622: LD_VAR 0 4
104626: PPUSH
104627: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
104631: LD_VAR 0 1
104635: PPUSH
104636: LD_VAR 0 2
104640: PPUSH
104641: LD_VAR 0 3
104645: PPUSH
104646: CALL_OW 331
// end ;
104650: LD_VAR 0 5
104654: RET
// export function Video ( mode ) ; begin
104655: LD_INT 0
104657: PPUSH
// ingame_video = mode ;
104658: LD_ADDR_OWVAR 52
104662: PUSH
104663: LD_VAR 0 1
104667: ST_TO_ADDR
// interface_hidden = mode ;
104668: LD_ADDR_OWVAR 54
104672: PUSH
104673: LD_VAR 0 1
104677: ST_TO_ADDR
// end ;
104678: LD_VAR 0 2
104682: RET
// export function Join ( array , element ) ; begin
104683: LD_INT 0
104685: PPUSH
// result := Replace ( array , array + 1 , element ) ;
104686: LD_ADDR_VAR 0 3
104690: PUSH
104691: LD_VAR 0 1
104695: PPUSH
104696: LD_VAR 0 1
104700: PUSH
104701: LD_INT 1
104703: PLUS
104704: PPUSH
104705: LD_VAR 0 2
104709: PPUSH
104710: CALL_OW 1
104714: ST_TO_ADDR
// end ;
104715: LD_VAR 0 3
104719: RET
// export function JoinUnion ( array , element ) ; begin
104720: LD_INT 0
104722: PPUSH
// result := array union element ;
104723: LD_ADDR_VAR 0 3
104727: PUSH
104728: LD_VAR 0 1
104732: PUSH
104733: LD_VAR 0 2
104737: UNION
104738: ST_TO_ADDR
// end ;
104739: LD_VAR 0 3
104743: RET
// export function GetBehemoths ( side ) ; begin
104744: LD_INT 0
104746: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
104747: LD_ADDR_VAR 0 2
104751: PUSH
104752: LD_INT 22
104754: PUSH
104755: LD_VAR 0 1
104759: PUSH
104760: EMPTY
104761: LIST
104762: LIST
104763: PUSH
104764: LD_INT 31
104766: PUSH
104767: LD_INT 25
104769: PUSH
104770: EMPTY
104771: LIST
104772: LIST
104773: PUSH
104774: EMPTY
104775: LIST
104776: LIST
104777: PPUSH
104778: CALL_OW 69
104782: ST_TO_ADDR
// end ;
104783: LD_VAR 0 2
104787: RET
// export function Shuffle ( array ) ; var i , index ; begin
104788: LD_INT 0
104790: PPUSH
104791: PPUSH
104792: PPUSH
// result := [ ] ;
104793: LD_ADDR_VAR 0 2
104797: PUSH
104798: EMPTY
104799: ST_TO_ADDR
// if not array then
104800: LD_VAR 0 1
104804: NOT
104805: IFFALSE 104809
// exit ;
104807: GO 104908
// Randomize ;
104809: CALL_OW 10
// for i = array downto 1 do
104813: LD_ADDR_VAR 0 3
104817: PUSH
104818: DOUBLE
104819: LD_VAR 0 1
104823: INC
104824: ST_TO_ADDR
104825: LD_INT 1
104827: PUSH
104828: FOR_DOWNTO
104829: IFFALSE 104906
// begin index := rand ( 1 , array ) ;
104831: LD_ADDR_VAR 0 4
104835: PUSH
104836: LD_INT 1
104838: PPUSH
104839: LD_VAR 0 1
104843: PPUSH
104844: CALL_OW 12
104848: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
104849: LD_ADDR_VAR 0 2
104853: PUSH
104854: LD_VAR 0 2
104858: PPUSH
104859: LD_VAR 0 2
104863: PUSH
104864: LD_INT 1
104866: PLUS
104867: PPUSH
104868: LD_VAR 0 1
104872: PUSH
104873: LD_VAR 0 4
104877: ARRAY
104878: PPUSH
104879: CALL_OW 2
104883: ST_TO_ADDR
// array := Delete ( array , index ) ;
104884: LD_ADDR_VAR 0 1
104888: PUSH
104889: LD_VAR 0 1
104893: PPUSH
104894: LD_VAR 0 4
104898: PPUSH
104899: CALL_OW 3
104903: ST_TO_ADDR
// end ;
104904: GO 104828
104906: POP
104907: POP
// end ;
104908: LD_VAR 0 2
104912: RET
// export function GetBaseMaterials ( base ) ; begin
104913: LD_INT 0
104915: PPUSH
// result := [ 0 , 0 , 0 ] ;
104916: LD_ADDR_VAR 0 2
104920: PUSH
104921: LD_INT 0
104923: PUSH
104924: LD_INT 0
104926: PUSH
104927: LD_INT 0
104929: PUSH
104930: EMPTY
104931: LIST
104932: LIST
104933: LIST
104934: ST_TO_ADDR
// if not base then
104935: LD_VAR 0 1
104939: NOT
104940: IFFALSE 104944
// exit ;
104942: GO 104993
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
104944: LD_ADDR_VAR 0 2
104948: PUSH
104949: LD_VAR 0 1
104953: PPUSH
104954: LD_INT 1
104956: PPUSH
104957: CALL_OW 275
104961: PUSH
104962: LD_VAR 0 1
104966: PPUSH
104967: LD_INT 2
104969: PPUSH
104970: CALL_OW 275
104974: PUSH
104975: LD_VAR 0 1
104979: PPUSH
104980: LD_INT 3
104982: PPUSH
104983: CALL_OW 275
104987: PUSH
104988: EMPTY
104989: LIST
104990: LIST
104991: LIST
104992: ST_TO_ADDR
// end ;
104993: LD_VAR 0 2
104997: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
104998: LD_INT 0
105000: PPUSH
105001: PPUSH
// result := array ;
105002: LD_ADDR_VAR 0 3
105006: PUSH
105007: LD_VAR 0 1
105011: ST_TO_ADDR
// if size >= result then
105012: LD_VAR 0 2
105016: PUSH
105017: LD_VAR 0 3
105021: GREATEREQUAL
105022: IFFALSE 105026
// exit ;
105024: GO 105076
// if size then
105026: LD_VAR 0 2
105030: IFFALSE 105076
// for i := array downto size do
105032: LD_ADDR_VAR 0 4
105036: PUSH
105037: DOUBLE
105038: LD_VAR 0 1
105042: INC
105043: ST_TO_ADDR
105044: LD_VAR 0 2
105048: PUSH
105049: FOR_DOWNTO
105050: IFFALSE 105074
// result := Delete ( result , result ) ;
105052: LD_ADDR_VAR 0 3
105056: PUSH
105057: LD_VAR 0 3
105061: PPUSH
105062: LD_VAR 0 3
105066: PPUSH
105067: CALL_OW 3
105071: ST_TO_ADDR
105072: GO 105049
105074: POP
105075: POP
// end ;
105076: LD_VAR 0 3
105080: RET
// export function ComExit ( unit ) ; var tmp ; begin
105081: LD_INT 0
105083: PPUSH
105084: PPUSH
// if not IsInUnit ( unit ) then
105085: LD_VAR 0 1
105089: PPUSH
105090: CALL_OW 310
105094: NOT
105095: IFFALSE 105099
// exit ;
105097: GO 105159
// tmp := IsInUnit ( unit ) ;
105099: LD_ADDR_VAR 0 3
105103: PUSH
105104: LD_VAR 0 1
105108: PPUSH
105109: CALL_OW 310
105113: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
105114: LD_VAR 0 3
105118: PPUSH
105119: CALL_OW 247
105123: PUSH
105124: LD_INT 2
105126: EQUAL
105127: IFFALSE 105140
// ComExitVehicle ( unit ) else
105129: LD_VAR 0 1
105133: PPUSH
105134: CALL_OW 121
105138: GO 105149
// ComExitBuilding ( unit ) ;
105140: LD_VAR 0 1
105144: PPUSH
105145: CALL_OW 122
// result := tmp ;
105149: LD_ADDR_VAR 0 2
105153: PUSH
105154: LD_VAR 0 3
105158: ST_TO_ADDR
// end ;
105159: LD_VAR 0 2
105163: RET
// export function ComExitAll ( units ) ; var i ; begin
105164: LD_INT 0
105166: PPUSH
105167: PPUSH
// if not units then
105168: LD_VAR 0 1
105172: NOT
105173: IFFALSE 105177
// exit ;
105175: GO 105203
// for i in units do
105177: LD_ADDR_VAR 0 3
105181: PUSH
105182: LD_VAR 0 1
105186: PUSH
105187: FOR_IN
105188: IFFALSE 105201
// ComExit ( i ) ;
105190: LD_VAR 0 3
105194: PPUSH
105195: CALL 105081 0 1
105199: GO 105187
105201: POP
105202: POP
// end ;
105203: LD_VAR 0 2
105207: RET
// export function ResetHc ; begin
105208: LD_INT 0
105210: PPUSH
// InitHc ;
105211: CALL_OW 19
// hc_importance := 0 ;
105215: LD_ADDR_OWVAR 32
105219: PUSH
105220: LD_INT 0
105222: ST_TO_ADDR
// end ;
105223: LD_VAR 0 1
105227: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
105228: LD_INT 0
105230: PPUSH
105231: PPUSH
105232: PPUSH
// _x := ( x1 + x2 ) div 2 ;
105233: LD_ADDR_VAR 0 6
105237: PUSH
105238: LD_VAR 0 1
105242: PUSH
105243: LD_VAR 0 3
105247: PLUS
105248: PUSH
105249: LD_INT 2
105251: DIV
105252: ST_TO_ADDR
// if _x < 0 then
105253: LD_VAR 0 6
105257: PUSH
105258: LD_INT 0
105260: LESS
105261: IFFALSE 105278
// _x := _x * - 1 ;
105263: LD_ADDR_VAR 0 6
105267: PUSH
105268: LD_VAR 0 6
105272: PUSH
105273: LD_INT 1
105275: NEG
105276: MUL
105277: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
105278: LD_ADDR_VAR 0 7
105282: PUSH
105283: LD_VAR 0 2
105287: PUSH
105288: LD_VAR 0 4
105292: PLUS
105293: PUSH
105294: LD_INT 2
105296: DIV
105297: ST_TO_ADDR
// if _y < 0 then
105298: LD_VAR 0 7
105302: PUSH
105303: LD_INT 0
105305: LESS
105306: IFFALSE 105323
// _y := _y * - 1 ;
105308: LD_ADDR_VAR 0 7
105312: PUSH
105313: LD_VAR 0 7
105317: PUSH
105318: LD_INT 1
105320: NEG
105321: MUL
105322: ST_TO_ADDR
// result := [ _x , _y ] ;
105323: LD_ADDR_VAR 0 5
105327: PUSH
105328: LD_VAR 0 6
105332: PUSH
105333: LD_VAR 0 7
105337: PUSH
105338: EMPTY
105339: LIST
105340: LIST
105341: ST_TO_ADDR
// end ;
105342: LD_VAR 0 5
105346: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
105347: LD_INT 0
105349: PPUSH
105350: PPUSH
105351: PPUSH
105352: PPUSH
// task := GetTaskList ( unit ) ;
105353: LD_ADDR_VAR 0 7
105357: PUSH
105358: LD_VAR 0 1
105362: PPUSH
105363: CALL_OW 437
105367: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
105368: LD_VAR 0 7
105372: NOT
105373: PUSH
105374: LD_VAR 0 1
105378: PPUSH
105379: LD_VAR 0 2
105383: PPUSH
105384: CALL_OW 308
105388: NOT
105389: AND
105390: IFFALSE 105394
// exit ;
105392: GO 105512
// if IsInArea ( unit , area ) then
105394: LD_VAR 0 1
105398: PPUSH
105399: LD_VAR 0 2
105403: PPUSH
105404: CALL_OW 308
105408: IFFALSE 105426
// begin ComMoveToArea ( unit , goAway ) ;
105410: LD_VAR 0 1
105414: PPUSH
105415: LD_VAR 0 3
105419: PPUSH
105420: CALL_OW 113
// exit ;
105424: GO 105512
// end ; if task [ 1 ] [ 1 ] <> M then
105426: LD_VAR 0 7
105430: PUSH
105431: LD_INT 1
105433: ARRAY
105434: PUSH
105435: LD_INT 1
105437: ARRAY
105438: PUSH
105439: LD_STRING M
105441: NONEQUAL
105442: IFFALSE 105446
// exit ;
105444: GO 105512
// x := task [ 1 ] [ 2 ] ;
105446: LD_ADDR_VAR 0 5
105450: PUSH
105451: LD_VAR 0 7
105455: PUSH
105456: LD_INT 1
105458: ARRAY
105459: PUSH
105460: LD_INT 2
105462: ARRAY
105463: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
105464: LD_ADDR_VAR 0 6
105468: PUSH
105469: LD_VAR 0 7
105473: PUSH
105474: LD_INT 1
105476: ARRAY
105477: PUSH
105478: LD_INT 3
105480: ARRAY
105481: ST_TO_ADDR
// if InArea ( x , y , area ) then
105482: LD_VAR 0 5
105486: PPUSH
105487: LD_VAR 0 6
105491: PPUSH
105492: LD_VAR 0 2
105496: PPUSH
105497: CALL_OW 309
105501: IFFALSE 105512
// ComStop ( unit ) ;
105503: LD_VAR 0 1
105507: PPUSH
105508: CALL_OW 141
// end ;
105512: LD_VAR 0 4
105516: RET
// export function Abs ( value ) ; begin
105517: LD_INT 0
105519: PPUSH
// result := value ;
105520: LD_ADDR_VAR 0 2
105524: PUSH
105525: LD_VAR 0 1
105529: ST_TO_ADDR
// if value < 0 then
105530: LD_VAR 0 1
105534: PUSH
105535: LD_INT 0
105537: LESS
105538: IFFALSE 105555
// result := value * - 1 ;
105540: LD_ADDR_VAR 0 2
105544: PUSH
105545: LD_VAR 0 1
105549: PUSH
105550: LD_INT 1
105552: NEG
105553: MUL
105554: ST_TO_ADDR
// end ;
105555: LD_VAR 0 2
105559: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
105560: LD_INT 0
105562: PPUSH
105563: PPUSH
105564: PPUSH
105565: PPUSH
105566: PPUSH
105567: PPUSH
105568: PPUSH
105569: PPUSH
// if not unit or not building then
105570: LD_VAR 0 1
105574: NOT
105575: PUSH
105576: LD_VAR 0 2
105580: NOT
105581: OR
105582: IFFALSE 105586
// exit ;
105584: GO 105812
// x := GetX ( building ) ;
105586: LD_ADDR_VAR 0 4
105590: PUSH
105591: LD_VAR 0 2
105595: PPUSH
105596: CALL_OW 250
105600: ST_TO_ADDR
// y := GetY ( building ) ;
105601: LD_ADDR_VAR 0 6
105605: PUSH
105606: LD_VAR 0 2
105610: PPUSH
105611: CALL_OW 251
105615: ST_TO_ADDR
// d := GetDir ( building ) ;
105616: LD_ADDR_VAR 0 8
105620: PUSH
105621: LD_VAR 0 2
105625: PPUSH
105626: CALL_OW 254
105630: ST_TO_ADDR
// r := 4 ;
105631: LD_ADDR_VAR 0 9
105635: PUSH
105636: LD_INT 4
105638: ST_TO_ADDR
// for i := 1 to 5 do
105639: LD_ADDR_VAR 0 10
105643: PUSH
105644: DOUBLE
105645: LD_INT 1
105647: DEC
105648: ST_TO_ADDR
105649: LD_INT 5
105651: PUSH
105652: FOR_TO
105653: IFFALSE 105810
// begin _x := ShiftX ( x , d , r + i ) ;
105655: LD_ADDR_VAR 0 5
105659: PUSH
105660: LD_VAR 0 4
105664: PPUSH
105665: LD_VAR 0 8
105669: PPUSH
105670: LD_VAR 0 9
105674: PUSH
105675: LD_VAR 0 10
105679: PLUS
105680: PPUSH
105681: CALL_OW 272
105685: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
105686: LD_ADDR_VAR 0 7
105690: PUSH
105691: LD_VAR 0 6
105695: PPUSH
105696: LD_VAR 0 8
105700: PPUSH
105701: LD_VAR 0 9
105705: PUSH
105706: LD_VAR 0 10
105710: PLUS
105711: PPUSH
105712: CALL_OW 273
105716: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
105717: LD_VAR 0 5
105721: PPUSH
105722: LD_VAR 0 7
105726: PPUSH
105727: CALL_OW 488
105731: PUSH
105732: LD_VAR 0 5
105736: PPUSH
105737: LD_VAR 0 7
105741: PPUSH
105742: CALL_OW 428
105746: PPUSH
105747: CALL_OW 247
105751: PUSH
105752: LD_INT 3
105754: PUSH
105755: LD_INT 2
105757: PUSH
105758: EMPTY
105759: LIST
105760: LIST
105761: IN
105762: NOT
105763: AND
105764: IFFALSE 105808
// begin ComMoveXY ( unit , _x , _y ) ;
105766: LD_VAR 0 1
105770: PPUSH
105771: LD_VAR 0 5
105775: PPUSH
105776: LD_VAR 0 7
105780: PPUSH
105781: CALL_OW 111
// result := [ _x , _y ] ;
105785: LD_ADDR_VAR 0 3
105789: PUSH
105790: LD_VAR 0 5
105794: PUSH
105795: LD_VAR 0 7
105799: PUSH
105800: EMPTY
105801: LIST
105802: LIST
105803: ST_TO_ADDR
// exit ;
105804: POP
105805: POP
105806: GO 105812
// end ; end ;
105808: GO 105652
105810: POP
105811: POP
// end ;
105812: LD_VAR 0 3
105816: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
105817: LD_INT 0
105819: PPUSH
105820: PPUSH
105821: PPUSH
// result := 0 ;
105822: LD_ADDR_VAR 0 3
105826: PUSH
105827: LD_INT 0
105829: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
105830: LD_VAR 0 1
105834: PUSH
105835: LD_INT 0
105837: LESS
105838: PUSH
105839: LD_VAR 0 1
105843: PUSH
105844: LD_INT 8
105846: GREATER
105847: OR
105848: PUSH
105849: LD_VAR 0 2
105853: PUSH
105854: LD_INT 0
105856: LESS
105857: OR
105858: PUSH
105859: LD_VAR 0 2
105863: PUSH
105864: LD_INT 8
105866: GREATER
105867: OR
105868: IFFALSE 105872
// exit ;
105870: GO 105947
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
105872: LD_ADDR_VAR 0 4
105876: PUSH
105877: LD_INT 22
105879: PUSH
105880: LD_VAR 0 2
105884: PUSH
105885: EMPTY
105886: LIST
105887: LIST
105888: PPUSH
105889: CALL_OW 69
105893: PUSH
105894: FOR_IN
105895: IFFALSE 105945
// begin un := UnitShoot ( i ) ;
105897: LD_ADDR_VAR 0 5
105901: PUSH
105902: LD_VAR 0 4
105906: PPUSH
105907: CALL_OW 504
105911: ST_TO_ADDR
// if GetSide ( un ) = side1 then
105912: LD_VAR 0 5
105916: PPUSH
105917: CALL_OW 255
105921: PUSH
105922: LD_VAR 0 1
105926: EQUAL
105927: IFFALSE 105943
// begin result := un ;
105929: LD_ADDR_VAR 0 3
105933: PUSH
105934: LD_VAR 0 5
105938: ST_TO_ADDR
// exit ;
105939: POP
105940: POP
105941: GO 105947
// end ; end ;
105943: GO 105894
105945: POP
105946: POP
// end ;
105947: LD_VAR 0 3
105951: RET
// export function GetCargoBay ( units ) ; begin
105952: LD_INT 0
105954: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
105955: LD_ADDR_VAR 0 2
105959: PUSH
105960: LD_VAR 0 1
105964: PPUSH
105965: LD_INT 2
105967: PUSH
105968: LD_INT 34
105970: PUSH
105971: LD_INT 12
105973: PUSH
105974: EMPTY
105975: LIST
105976: LIST
105977: PUSH
105978: LD_INT 34
105980: PUSH
105981: LD_INT 51
105983: PUSH
105984: EMPTY
105985: LIST
105986: LIST
105987: PUSH
105988: LD_INT 34
105990: PUSH
105991: LD_INT 32
105993: PUSH
105994: EMPTY
105995: LIST
105996: LIST
105997: PUSH
105998: LD_INT 34
106000: PUSH
106001: LD_INT 89
106003: PUSH
106004: EMPTY
106005: LIST
106006: LIST
106007: PUSH
106008: EMPTY
106009: LIST
106010: LIST
106011: LIST
106012: LIST
106013: LIST
106014: PPUSH
106015: CALL_OW 72
106019: ST_TO_ADDR
// end ;
106020: LD_VAR 0 2
106024: RET
// export function Negate ( value ) ; begin
106025: LD_INT 0
106027: PPUSH
// result := not value ;
106028: LD_ADDR_VAR 0 2
106032: PUSH
106033: LD_VAR 0 1
106037: NOT
106038: ST_TO_ADDR
// end ;
106039: LD_VAR 0 2
106043: RET
// export function Inc ( value ) ; begin
106044: LD_INT 0
106046: PPUSH
// result := value + 1 ;
106047: LD_ADDR_VAR 0 2
106051: PUSH
106052: LD_VAR 0 1
106056: PUSH
106057: LD_INT 1
106059: PLUS
106060: ST_TO_ADDR
// end ;
106061: LD_VAR 0 2
106065: RET
// export function Dec ( value ) ; begin
106066: LD_INT 0
106068: PPUSH
// result := value - 1 ;
106069: LD_ADDR_VAR 0 2
106073: PUSH
106074: LD_VAR 0 1
106078: PUSH
106079: LD_INT 1
106081: MINUS
106082: ST_TO_ADDR
// end ;
106083: LD_VAR 0 2
106087: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
106088: LD_INT 0
106090: PPUSH
106091: PPUSH
106092: PPUSH
106093: PPUSH
106094: PPUSH
106095: PPUSH
106096: PPUSH
106097: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
106098: LD_VAR 0 1
106102: PPUSH
106103: LD_VAR 0 2
106107: PPUSH
106108: CALL_OW 488
106112: NOT
106113: PUSH
106114: LD_VAR 0 3
106118: PPUSH
106119: LD_VAR 0 4
106123: PPUSH
106124: CALL_OW 488
106128: NOT
106129: OR
106130: IFFALSE 106143
// begin result := - 1 ;
106132: LD_ADDR_VAR 0 5
106136: PUSH
106137: LD_INT 1
106139: NEG
106140: ST_TO_ADDR
// exit ;
106141: GO 106378
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
106143: LD_ADDR_VAR 0 12
106147: PUSH
106148: LD_VAR 0 1
106152: PPUSH
106153: LD_VAR 0 2
106157: PPUSH
106158: LD_VAR 0 3
106162: PPUSH
106163: LD_VAR 0 4
106167: PPUSH
106168: CALL 105228 0 4
106172: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
106173: LD_ADDR_VAR 0 11
106177: PUSH
106178: LD_VAR 0 1
106182: PPUSH
106183: LD_VAR 0 2
106187: PPUSH
106188: LD_VAR 0 12
106192: PUSH
106193: LD_INT 1
106195: ARRAY
106196: PPUSH
106197: LD_VAR 0 12
106201: PUSH
106202: LD_INT 2
106204: ARRAY
106205: PPUSH
106206: CALL_OW 298
106210: ST_TO_ADDR
// distance := 9999 ;
106211: LD_ADDR_VAR 0 10
106215: PUSH
106216: LD_INT 9999
106218: ST_TO_ADDR
// for i := 0 to 5 do
106219: LD_ADDR_VAR 0 6
106223: PUSH
106224: DOUBLE
106225: LD_INT 0
106227: DEC
106228: ST_TO_ADDR
106229: LD_INT 5
106231: PUSH
106232: FOR_TO
106233: IFFALSE 106376
// begin _x := ShiftX ( x1 , i , centerDist ) ;
106235: LD_ADDR_VAR 0 7
106239: PUSH
106240: LD_VAR 0 1
106244: PPUSH
106245: LD_VAR 0 6
106249: PPUSH
106250: LD_VAR 0 11
106254: PPUSH
106255: CALL_OW 272
106259: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
106260: LD_ADDR_VAR 0 8
106264: PUSH
106265: LD_VAR 0 2
106269: PPUSH
106270: LD_VAR 0 6
106274: PPUSH
106275: LD_VAR 0 11
106279: PPUSH
106280: CALL_OW 273
106284: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
106285: LD_VAR 0 7
106289: PPUSH
106290: LD_VAR 0 8
106294: PPUSH
106295: CALL_OW 488
106299: NOT
106300: IFFALSE 106304
// continue ;
106302: GO 106232
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
106304: LD_ADDR_VAR 0 9
106308: PUSH
106309: LD_VAR 0 12
106313: PUSH
106314: LD_INT 1
106316: ARRAY
106317: PPUSH
106318: LD_VAR 0 12
106322: PUSH
106323: LD_INT 2
106325: ARRAY
106326: PPUSH
106327: LD_VAR 0 7
106331: PPUSH
106332: LD_VAR 0 8
106336: PPUSH
106337: CALL_OW 298
106341: ST_TO_ADDR
// if tmp < distance then
106342: LD_VAR 0 9
106346: PUSH
106347: LD_VAR 0 10
106351: LESS
106352: IFFALSE 106374
// begin result := i ;
106354: LD_ADDR_VAR 0 5
106358: PUSH
106359: LD_VAR 0 6
106363: ST_TO_ADDR
// distance := tmp ;
106364: LD_ADDR_VAR 0 10
106368: PUSH
106369: LD_VAR 0 9
106373: ST_TO_ADDR
// end ; end ;
106374: GO 106232
106376: POP
106377: POP
// end ;
106378: LD_VAR 0 5
106382: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
106383: LD_INT 0
106385: PPUSH
106386: PPUSH
// if not driver or not IsInUnit ( driver ) then
106387: LD_VAR 0 1
106391: NOT
106392: PUSH
106393: LD_VAR 0 1
106397: PPUSH
106398: CALL_OW 310
106402: NOT
106403: OR
106404: IFFALSE 106408
// exit ;
106406: GO 106498
// vehicle := IsInUnit ( driver ) ;
106408: LD_ADDR_VAR 0 3
106412: PUSH
106413: LD_VAR 0 1
106417: PPUSH
106418: CALL_OW 310
106422: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
106423: LD_VAR 0 1
106427: PPUSH
106428: LD_STRING \
106430: PUSH
106431: LD_INT 0
106433: PUSH
106434: LD_INT 0
106436: PUSH
106437: LD_INT 0
106439: PUSH
106440: LD_INT 0
106442: PUSH
106443: LD_INT 0
106445: PUSH
106446: LD_INT 0
106448: PUSH
106449: EMPTY
106450: LIST
106451: LIST
106452: LIST
106453: LIST
106454: LIST
106455: LIST
106456: LIST
106457: PUSH
106458: LD_STRING E
106460: PUSH
106461: LD_INT 0
106463: PUSH
106464: LD_INT 0
106466: PUSH
106467: LD_VAR 0 3
106471: PUSH
106472: LD_INT 0
106474: PUSH
106475: LD_INT 0
106477: PUSH
106478: LD_INT 0
106480: PUSH
106481: EMPTY
106482: LIST
106483: LIST
106484: LIST
106485: LIST
106486: LIST
106487: LIST
106488: LIST
106489: PUSH
106490: EMPTY
106491: LIST
106492: LIST
106493: PPUSH
106494: CALL_OW 446
// end ;
106498: LD_VAR 0 2
106502: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
106503: LD_INT 0
106505: PPUSH
106506: PPUSH
// if not driver or not IsInUnit ( driver ) then
106507: LD_VAR 0 1
106511: NOT
106512: PUSH
106513: LD_VAR 0 1
106517: PPUSH
106518: CALL_OW 310
106522: NOT
106523: OR
106524: IFFALSE 106528
// exit ;
106526: GO 106618
// vehicle := IsInUnit ( driver ) ;
106528: LD_ADDR_VAR 0 3
106532: PUSH
106533: LD_VAR 0 1
106537: PPUSH
106538: CALL_OW 310
106542: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
106543: LD_VAR 0 1
106547: PPUSH
106548: LD_STRING \
106550: PUSH
106551: LD_INT 0
106553: PUSH
106554: LD_INT 0
106556: PUSH
106557: LD_INT 0
106559: PUSH
106560: LD_INT 0
106562: PUSH
106563: LD_INT 0
106565: PUSH
106566: LD_INT 0
106568: PUSH
106569: EMPTY
106570: LIST
106571: LIST
106572: LIST
106573: LIST
106574: LIST
106575: LIST
106576: LIST
106577: PUSH
106578: LD_STRING E
106580: PUSH
106581: LD_INT 0
106583: PUSH
106584: LD_INT 0
106586: PUSH
106587: LD_VAR 0 3
106591: PUSH
106592: LD_INT 0
106594: PUSH
106595: LD_INT 0
106597: PUSH
106598: LD_INT 0
106600: PUSH
106601: EMPTY
106602: LIST
106603: LIST
106604: LIST
106605: LIST
106606: LIST
106607: LIST
106608: LIST
106609: PUSH
106610: EMPTY
106611: LIST
106612: LIST
106613: PPUSH
106614: CALL_OW 447
// end ;
106618: LD_VAR 0 2
106622: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
106623: LD_INT 0
106625: PPUSH
106626: PPUSH
106627: PPUSH
// tmp := [ ] ;
106628: LD_ADDR_VAR 0 5
106632: PUSH
106633: EMPTY
106634: ST_TO_ADDR
// for i in units do
106635: LD_ADDR_VAR 0 4
106639: PUSH
106640: LD_VAR 0 1
106644: PUSH
106645: FOR_IN
106646: IFFALSE 106684
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
106648: LD_ADDR_VAR 0 5
106652: PUSH
106653: LD_VAR 0 5
106657: PPUSH
106658: LD_VAR 0 5
106662: PUSH
106663: LD_INT 1
106665: PLUS
106666: PPUSH
106667: LD_VAR 0 4
106671: PPUSH
106672: CALL_OW 256
106676: PPUSH
106677: CALL_OW 2
106681: ST_TO_ADDR
106682: GO 106645
106684: POP
106685: POP
// if not tmp then
106686: LD_VAR 0 5
106690: NOT
106691: IFFALSE 106695
// exit ;
106693: GO 106743
// if asc then
106695: LD_VAR 0 2
106699: IFFALSE 106723
// result := SortListByListAsc ( units , tmp ) else
106701: LD_ADDR_VAR 0 3
106705: PUSH
106706: LD_VAR 0 1
106710: PPUSH
106711: LD_VAR 0 5
106715: PPUSH
106716: CALL_OW 76
106720: ST_TO_ADDR
106721: GO 106743
// result := SortListByListDesc ( units , tmp ) ;
106723: LD_ADDR_VAR 0 3
106727: PUSH
106728: LD_VAR 0 1
106732: PPUSH
106733: LD_VAR 0 5
106737: PPUSH
106738: CALL_OW 77
106742: ST_TO_ADDR
// end ;
106743: LD_VAR 0 3
106747: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
106748: LD_INT 0
106750: PPUSH
106751: PPUSH
// task := GetTaskList ( mech ) ;
106752: LD_ADDR_VAR 0 4
106756: PUSH
106757: LD_VAR 0 1
106761: PPUSH
106762: CALL_OW 437
106766: ST_TO_ADDR
// if not task then
106767: LD_VAR 0 4
106771: NOT
106772: IFFALSE 106776
// exit ;
106774: GO 106818
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
106776: LD_ADDR_VAR 0 3
106780: PUSH
106781: LD_VAR 0 4
106785: PUSH
106786: LD_INT 1
106788: ARRAY
106789: PUSH
106790: LD_INT 1
106792: ARRAY
106793: PUSH
106794: LD_STRING r
106796: EQUAL
106797: PUSH
106798: LD_VAR 0 4
106802: PUSH
106803: LD_INT 1
106805: ARRAY
106806: PUSH
106807: LD_INT 4
106809: ARRAY
106810: PUSH
106811: LD_VAR 0 2
106815: EQUAL
106816: AND
106817: ST_TO_ADDR
// end ;
106818: LD_VAR 0 3
106822: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
106823: LD_INT 0
106825: PPUSH
// SetDir ( unit , d ) ;
106826: LD_VAR 0 1
106830: PPUSH
106831: LD_VAR 0 4
106835: PPUSH
106836: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
106840: LD_VAR 0 1
106844: PPUSH
106845: LD_VAR 0 2
106849: PPUSH
106850: LD_VAR 0 3
106854: PPUSH
106855: LD_VAR 0 5
106859: PPUSH
106860: CALL_OW 48
// end ;
106864: LD_VAR 0 6
106868: RET
// export function ToNaturalNumber ( number ) ; begin
106869: LD_INT 0
106871: PPUSH
// result := number div 1 ;
106872: LD_ADDR_VAR 0 2
106876: PUSH
106877: LD_VAR 0 1
106881: PUSH
106882: LD_INT 1
106884: DIV
106885: ST_TO_ADDR
// if number < 0 then
106886: LD_VAR 0 1
106890: PUSH
106891: LD_INT 0
106893: LESS
106894: IFFALSE 106904
// result := 0 ;
106896: LD_ADDR_VAR 0 2
106900: PUSH
106901: LD_INT 0
106903: ST_TO_ADDR
// end ;
106904: LD_VAR 0 2
106908: RET
// export function SortByClass ( units , class ) ; var un ; begin
106909: LD_INT 0
106911: PPUSH
106912: PPUSH
// if not units or not class then
106913: LD_VAR 0 1
106917: NOT
106918: PUSH
106919: LD_VAR 0 2
106923: NOT
106924: OR
106925: IFFALSE 106929
// exit ;
106927: GO 107024
// result := [ ] ;
106929: LD_ADDR_VAR 0 3
106933: PUSH
106934: EMPTY
106935: ST_TO_ADDR
// for un in units do
106936: LD_ADDR_VAR 0 4
106940: PUSH
106941: LD_VAR 0 1
106945: PUSH
106946: FOR_IN
106947: IFFALSE 107022
// if GetClass ( un ) = class then
106949: LD_VAR 0 4
106953: PPUSH
106954: CALL_OW 257
106958: PUSH
106959: LD_VAR 0 2
106963: EQUAL
106964: IFFALSE 106991
// result := Insert ( result , 1 , un ) else
106966: LD_ADDR_VAR 0 3
106970: PUSH
106971: LD_VAR 0 3
106975: PPUSH
106976: LD_INT 1
106978: PPUSH
106979: LD_VAR 0 4
106983: PPUSH
106984: CALL_OW 2
106988: ST_TO_ADDR
106989: GO 107020
// result := Replace ( result , result + 1 , un ) ;
106991: LD_ADDR_VAR 0 3
106995: PUSH
106996: LD_VAR 0 3
107000: PPUSH
107001: LD_VAR 0 3
107005: PUSH
107006: LD_INT 1
107008: PLUS
107009: PPUSH
107010: LD_VAR 0 4
107014: PPUSH
107015: CALL_OW 1
107019: ST_TO_ADDR
107020: GO 106946
107022: POP
107023: POP
// end ;
107024: LD_VAR 0 3
107028: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
107029: LD_INT 0
107031: PPUSH
107032: PPUSH
107033: PPUSH
107034: PPUSH
107035: PPUSH
107036: PPUSH
107037: PPUSH
// result := [ ] ;
107038: LD_ADDR_VAR 0 4
107042: PUSH
107043: EMPTY
107044: ST_TO_ADDR
// if x - r < 0 then
107045: LD_VAR 0 1
107049: PUSH
107050: LD_VAR 0 3
107054: MINUS
107055: PUSH
107056: LD_INT 0
107058: LESS
107059: IFFALSE 107071
// min_x := 0 else
107061: LD_ADDR_VAR 0 8
107065: PUSH
107066: LD_INT 0
107068: ST_TO_ADDR
107069: GO 107087
// min_x := x - r ;
107071: LD_ADDR_VAR 0 8
107075: PUSH
107076: LD_VAR 0 1
107080: PUSH
107081: LD_VAR 0 3
107085: MINUS
107086: ST_TO_ADDR
// if y - r < 0 then
107087: LD_VAR 0 2
107091: PUSH
107092: LD_VAR 0 3
107096: MINUS
107097: PUSH
107098: LD_INT 0
107100: LESS
107101: IFFALSE 107113
// min_y := 0 else
107103: LD_ADDR_VAR 0 7
107107: PUSH
107108: LD_INT 0
107110: ST_TO_ADDR
107111: GO 107129
// min_y := y - r ;
107113: LD_ADDR_VAR 0 7
107117: PUSH
107118: LD_VAR 0 2
107122: PUSH
107123: LD_VAR 0 3
107127: MINUS
107128: ST_TO_ADDR
// max_x := x + r ;
107129: LD_ADDR_VAR 0 9
107133: PUSH
107134: LD_VAR 0 1
107138: PUSH
107139: LD_VAR 0 3
107143: PLUS
107144: ST_TO_ADDR
// max_y := y + r ;
107145: LD_ADDR_VAR 0 10
107149: PUSH
107150: LD_VAR 0 2
107154: PUSH
107155: LD_VAR 0 3
107159: PLUS
107160: ST_TO_ADDR
// for _x = min_x to max_x do
107161: LD_ADDR_VAR 0 5
107165: PUSH
107166: DOUBLE
107167: LD_VAR 0 8
107171: DEC
107172: ST_TO_ADDR
107173: LD_VAR 0 9
107177: PUSH
107178: FOR_TO
107179: IFFALSE 107280
// for _y = min_y to max_y do
107181: LD_ADDR_VAR 0 6
107185: PUSH
107186: DOUBLE
107187: LD_VAR 0 7
107191: DEC
107192: ST_TO_ADDR
107193: LD_VAR 0 10
107197: PUSH
107198: FOR_TO
107199: IFFALSE 107276
// begin if not ValidHex ( _x , _y ) then
107201: LD_VAR 0 5
107205: PPUSH
107206: LD_VAR 0 6
107210: PPUSH
107211: CALL_OW 488
107215: NOT
107216: IFFALSE 107220
// continue ;
107218: GO 107198
// if GetResourceTypeXY ( _x , _y ) then
107220: LD_VAR 0 5
107224: PPUSH
107225: LD_VAR 0 6
107229: PPUSH
107230: CALL_OW 283
107234: IFFALSE 107274
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
107236: LD_ADDR_VAR 0 4
107240: PUSH
107241: LD_VAR 0 4
107245: PPUSH
107246: LD_VAR 0 4
107250: PUSH
107251: LD_INT 1
107253: PLUS
107254: PPUSH
107255: LD_VAR 0 5
107259: PUSH
107260: LD_VAR 0 6
107264: PUSH
107265: EMPTY
107266: LIST
107267: LIST
107268: PPUSH
107269: CALL_OW 1
107273: ST_TO_ADDR
// end ;
107274: GO 107198
107276: POP
107277: POP
107278: GO 107178
107280: POP
107281: POP
// end ;
107282: LD_VAR 0 4
107286: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
107287: LD_INT 0
107289: PPUSH
107290: PPUSH
107291: PPUSH
107292: PPUSH
107293: PPUSH
107294: PPUSH
107295: PPUSH
107296: PPUSH
// if not units then
107297: LD_VAR 0 1
107301: NOT
107302: IFFALSE 107306
// exit ;
107304: GO 107830
// result := UnitFilter ( units , [ f_ok ] ) ;
107306: LD_ADDR_VAR 0 3
107310: PUSH
107311: LD_VAR 0 1
107315: PPUSH
107316: LD_INT 50
107318: PUSH
107319: EMPTY
107320: LIST
107321: PPUSH
107322: CALL_OW 72
107326: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
107327: LD_ADDR_VAR 0 8
107331: PUSH
107332: LD_VAR 0 1
107336: PUSH
107337: LD_INT 1
107339: ARRAY
107340: PPUSH
107341: CALL_OW 255
107345: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
107346: LD_ADDR_VAR 0 10
107350: PUSH
107351: LD_INT 29
107353: PUSH
107354: LD_INT 91
107356: PUSH
107357: LD_INT 49
107359: PUSH
107360: EMPTY
107361: LIST
107362: LIST
107363: LIST
107364: ST_TO_ADDR
// if not result then
107365: LD_VAR 0 3
107369: NOT
107370: IFFALSE 107374
// exit ;
107372: GO 107830
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
107374: LD_ADDR_VAR 0 5
107378: PUSH
107379: LD_INT 81
107381: PUSH
107382: LD_VAR 0 8
107386: PUSH
107387: EMPTY
107388: LIST
107389: LIST
107390: PPUSH
107391: CALL_OW 69
107395: ST_TO_ADDR
// for i in result do
107396: LD_ADDR_VAR 0 4
107400: PUSH
107401: LD_VAR 0 3
107405: PUSH
107406: FOR_IN
107407: IFFALSE 107828
// begin tag := GetTag ( i ) + 1 ;
107409: LD_ADDR_VAR 0 9
107413: PUSH
107414: LD_VAR 0 4
107418: PPUSH
107419: CALL_OW 110
107423: PUSH
107424: LD_INT 1
107426: PLUS
107427: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
107428: LD_ADDR_VAR 0 7
107432: PUSH
107433: LD_VAR 0 4
107437: PPUSH
107438: CALL_OW 250
107442: PPUSH
107443: LD_VAR 0 4
107447: PPUSH
107448: CALL_OW 251
107452: PPUSH
107453: LD_INT 6
107455: PPUSH
107456: CALL 107029 0 3
107460: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
107461: LD_VAR 0 4
107465: PPUSH
107466: CALL_OW 247
107470: PUSH
107471: LD_INT 2
107473: EQUAL
107474: PUSH
107475: LD_VAR 0 7
107479: AND
107480: PUSH
107481: LD_VAR 0 4
107485: PPUSH
107486: CALL_OW 264
107490: PUSH
107491: LD_VAR 0 10
107495: IN
107496: NOT
107497: AND
107498: IFFALSE 107537
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
107500: LD_VAR 0 4
107504: PPUSH
107505: LD_VAR 0 7
107509: PUSH
107510: LD_INT 1
107512: ARRAY
107513: PUSH
107514: LD_INT 1
107516: ARRAY
107517: PPUSH
107518: LD_VAR 0 7
107522: PUSH
107523: LD_INT 1
107525: ARRAY
107526: PUSH
107527: LD_INT 2
107529: ARRAY
107530: PPUSH
107531: CALL_OW 116
107535: GO 107826
// if path > tag then
107537: LD_VAR 0 2
107541: PUSH
107542: LD_VAR 0 9
107546: GREATER
107547: IFFALSE 107755
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
107549: LD_ADDR_VAR 0 6
107553: PUSH
107554: LD_VAR 0 5
107558: PPUSH
107559: LD_INT 91
107561: PUSH
107562: LD_VAR 0 4
107566: PUSH
107567: LD_INT 8
107569: PUSH
107570: EMPTY
107571: LIST
107572: LIST
107573: LIST
107574: PPUSH
107575: CALL_OW 72
107579: ST_TO_ADDR
// if nearEnemy then
107580: LD_VAR 0 6
107584: IFFALSE 107653
// begin if GetWeapon ( i ) = ru_time_lapser then
107586: LD_VAR 0 4
107590: PPUSH
107591: CALL_OW 264
107595: PUSH
107596: LD_INT 49
107598: EQUAL
107599: IFFALSE 107627
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
107601: LD_VAR 0 4
107605: PPUSH
107606: LD_VAR 0 6
107610: PPUSH
107611: LD_VAR 0 4
107615: PPUSH
107616: CALL_OW 74
107620: PPUSH
107621: CALL_OW 112
107625: GO 107651
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
107627: LD_VAR 0 4
107631: PPUSH
107632: LD_VAR 0 6
107636: PPUSH
107637: LD_VAR 0 4
107641: PPUSH
107642: CALL_OW 74
107646: PPUSH
107647: CALL_OW 115
// end else
107651: GO 107753
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
107653: LD_VAR 0 4
107657: PPUSH
107658: LD_VAR 0 2
107662: PUSH
107663: LD_VAR 0 9
107667: ARRAY
107668: PUSH
107669: LD_INT 1
107671: ARRAY
107672: PPUSH
107673: LD_VAR 0 2
107677: PUSH
107678: LD_VAR 0 9
107682: ARRAY
107683: PUSH
107684: LD_INT 2
107686: ARRAY
107687: PPUSH
107688: CALL_OW 297
107692: PUSH
107693: LD_INT 6
107695: GREATER
107696: IFFALSE 107739
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
107698: LD_VAR 0 4
107702: PPUSH
107703: LD_VAR 0 2
107707: PUSH
107708: LD_VAR 0 9
107712: ARRAY
107713: PUSH
107714: LD_INT 1
107716: ARRAY
107717: PPUSH
107718: LD_VAR 0 2
107722: PUSH
107723: LD_VAR 0 9
107727: ARRAY
107728: PUSH
107729: LD_INT 2
107731: ARRAY
107732: PPUSH
107733: CALL_OW 114
107737: GO 107753
// SetTag ( i , tag ) ;
107739: LD_VAR 0 4
107743: PPUSH
107744: LD_VAR 0 9
107748: PPUSH
107749: CALL_OW 109
// end else
107753: GO 107826
// if enemy then
107755: LD_VAR 0 5
107759: IFFALSE 107826
// begin if GetWeapon ( i ) = ru_time_lapser then
107761: LD_VAR 0 4
107765: PPUSH
107766: CALL_OW 264
107770: PUSH
107771: LD_INT 49
107773: EQUAL
107774: IFFALSE 107802
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
107776: LD_VAR 0 4
107780: PPUSH
107781: LD_VAR 0 5
107785: PPUSH
107786: LD_VAR 0 4
107790: PPUSH
107791: CALL_OW 74
107795: PPUSH
107796: CALL_OW 112
107800: GO 107826
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
107802: LD_VAR 0 4
107806: PPUSH
107807: LD_VAR 0 5
107811: PPUSH
107812: LD_VAR 0 4
107816: PPUSH
107817: CALL_OW 74
107821: PPUSH
107822: CALL_OW 115
// end ; end ;
107826: GO 107406
107828: POP
107829: POP
// end ;
107830: LD_VAR 0 3
107834: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
107835: LD_INT 0
107837: PPUSH
107838: PPUSH
107839: PPUSH
// if not unit or IsInUnit ( unit ) then
107840: LD_VAR 0 1
107844: NOT
107845: PUSH
107846: LD_VAR 0 1
107850: PPUSH
107851: CALL_OW 310
107855: OR
107856: IFFALSE 107860
// exit ;
107858: GO 107951
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
107860: LD_ADDR_VAR 0 4
107864: PUSH
107865: LD_VAR 0 1
107869: PPUSH
107870: CALL_OW 250
107874: PPUSH
107875: LD_VAR 0 2
107879: PPUSH
107880: LD_INT 1
107882: PPUSH
107883: CALL_OW 272
107887: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
107888: LD_ADDR_VAR 0 5
107892: PUSH
107893: LD_VAR 0 1
107897: PPUSH
107898: CALL_OW 251
107902: PPUSH
107903: LD_VAR 0 2
107907: PPUSH
107908: LD_INT 1
107910: PPUSH
107911: CALL_OW 273
107915: ST_TO_ADDR
// if ValidHex ( x , y ) then
107916: LD_VAR 0 4
107920: PPUSH
107921: LD_VAR 0 5
107925: PPUSH
107926: CALL_OW 488
107930: IFFALSE 107951
// ComTurnXY ( unit , x , y ) ;
107932: LD_VAR 0 1
107936: PPUSH
107937: LD_VAR 0 4
107941: PPUSH
107942: LD_VAR 0 5
107946: PPUSH
107947: CALL_OW 118
// end ;
107951: LD_VAR 0 3
107955: RET
// export function SeeUnits ( side , units ) ; var i ; begin
107956: LD_INT 0
107958: PPUSH
107959: PPUSH
// result := false ;
107960: LD_ADDR_VAR 0 3
107964: PUSH
107965: LD_INT 0
107967: ST_TO_ADDR
// if not units then
107968: LD_VAR 0 2
107972: NOT
107973: IFFALSE 107977
// exit ;
107975: GO 108022
// for i in units do
107977: LD_ADDR_VAR 0 4
107981: PUSH
107982: LD_VAR 0 2
107986: PUSH
107987: FOR_IN
107988: IFFALSE 108020
// if See ( side , i ) then
107990: LD_VAR 0 1
107994: PPUSH
107995: LD_VAR 0 4
107999: PPUSH
108000: CALL_OW 292
108004: IFFALSE 108018
// begin result := true ;
108006: LD_ADDR_VAR 0 3
108010: PUSH
108011: LD_INT 1
108013: ST_TO_ADDR
// exit ;
108014: POP
108015: POP
108016: GO 108022
// end ;
108018: GO 107987
108020: POP
108021: POP
// end ;
108022: LD_VAR 0 3
108026: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
108027: LD_INT 0
108029: PPUSH
108030: PPUSH
108031: PPUSH
108032: PPUSH
// if not unit or not points then
108033: LD_VAR 0 1
108037: NOT
108038: PUSH
108039: LD_VAR 0 2
108043: NOT
108044: OR
108045: IFFALSE 108049
// exit ;
108047: GO 108139
// dist := 99999 ;
108049: LD_ADDR_VAR 0 5
108053: PUSH
108054: LD_INT 99999
108056: ST_TO_ADDR
// for i in points do
108057: LD_ADDR_VAR 0 4
108061: PUSH
108062: LD_VAR 0 2
108066: PUSH
108067: FOR_IN
108068: IFFALSE 108137
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
108070: LD_ADDR_VAR 0 6
108074: PUSH
108075: LD_VAR 0 1
108079: PPUSH
108080: LD_VAR 0 4
108084: PUSH
108085: LD_INT 1
108087: ARRAY
108088: PPUSH
108089: LD_VAR 0 4
108093: PUSH
108094: LD_INT 2
108096: ARRAY
108097: PPUSH
108098: CALL_OW 297
108102: ST_TO_ADDR
// if tmpDist < dist then
108103: LD_VAR 0 6
108107: PUSH
108108: LD_VAR 0 5
108112: LESS
108113: IFFALSE 108135
// begin result := i ;
108115: LD_ADDR_VAR 0 3
108119: PUSH
108120: LD_VAR 0 4
108124: ST_TO_ADDR
// dist := tmpDist ;
108125: LD_ADDR_VAR 0 5
108129: PUSH
108130: LD_VAR 0 6
108134: ST_TO_ADDR
// end ; end ;
108135: GO 108067
108137: POP
108138: POP
// end ;
108139: LD_VAR 0 3
108143: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
108144: LD_INT 0
108146: PPUSH
// uc_side := side ;
108147: LD_ADDR_OWVAR 20
108151: PUSH
108152: LD_VAR 0 1
108156: ST_TO_ADDR
// uc_nation := 3 ;
108157: LD_ADDR_OWVAR 21
108161: PUSH
108162: LD_INT 3
108164: ST_TO_ADDR
// vc_chassis := 25 ;
108165: LD_ADDR_OWVAR 37
108169: PUSH
108170: LD_INT 25
108172: ST_TO_ADDR
// vc_engine := engine_siberite ;
108173: LD_ADDR_OWVAR 39
108177: PUSH
108178: LD_INT 3
108180: ST_TO_ADDR
// vc_control := control_computer ;
108181: LD_ADDR_OWVAR 38
108185: PUSH
108186: LD_INT 3
108188: ST_TO_ADDR
// vc_weapon := 59 ;
108189: LD_ADDR_OWVAR 40
108193: PUSH
108194: LD_INT 59
108196: ST_TO_ADDR
// result := CreateVehicle ;
108197: LD_ADDR_VAR 0 5
108201: PUSH
108202: CALL_OW 45
108206: ST_TO_ADDR
// SetDir ( result , d ) ;
108207: LD_VAR 0 5
108211: PPUSH
108212: LD_VAR 0 4
108216: PPUSH
108217: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
108221: LD_VAR 0 5
108225: PPUSH
108226: LD_VAR 0 2
108230: PPUSH
108231: LD_VAR 0 3
108235: PPUSH
108236: LD_INT 0
108238: PPUSH
108239: CALL_OW 48
// end ;
108243: LD_VAR 0 5
108247: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
108248: LD_INT 0
108250: PPUSH
108251: PPUSH
108252: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
108253: LD_ADDR_VAR 0 2
108257: PUSH
108258: LD_INT 0
108260: PUSH
108261: LD_INT 0
108263: PUSH
108264: LD_INT 0
108266: PUSH
108267: LD_INT 0
108269: PUSH
108270: EMPTY
108271: LIST
108272: LIST
108273: LIST
108274: LIST
108275: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
108276: LD_VAR 0 1
108280: NOT
108281: PUSH
108282: LD_VAR 0 1
108286: PPUSH
108287: CALL_OW 264
108291: PUSH
108292: LD_INT 12
108294: PUSH
108295: LD_INT 51
108297: PUSH
108298: LD_INT 32
108300: PUSH
108301: LD_INT 89
108303: PUSH
108304: EMPTY
108305: LIST
108306: LIST
108307: LIST
108308: LIST
108309: IN
108310: NOT
108311: OR
108312: IFFALSE 108316
// exit ;
108314: GO 108414
// for i := 1 to 3 do
108316: LD_ADDR_VAR 0 3
108320: PUSH
108321: DOUBLE
108322: LD_INT 1
108324: DEC
108325: ST_TO_ADDR
108326: LD_INT 3
108328: PUSH
108329: FOR_TO
108330: IFFALSE 108412
// begin tmp := GetCargo ( cargo , i ) ;
108332: LD_ADDR_VAR 0 4
108336: PUSH
108337: LD_VAR 0 1
108341: PPUSH
108342: LD_VAR 0 3
108346: PPUSH
108347: CALL_OW 289
108351: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
108352: LD_ADDR_VAR 0 2
108356: PUSH
108357: LD_VAR 0 2
108361: PPUSH
108362: LD_VAR 0 3
108366: PPUSH
108367: LD_VAR 0 4
108371: PPUSH
108372: CALL_OW 1
108376: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
108377: LD_ADDR_VAR 0 2
108381: PUSH
108382: LD_VAR 0 2
108386: PPUSH
108387: LD_INT 4
108389: PPUSH
108390: LD_VAR 0 2
108394: PUSH
108395: LD_INT 4
108397: ARRAY
108398: PUSH
108399: LD_VAR 0 4
108403: PLUS
108404: PPUSH
108405: CALL_OW 1
108409: ST_TO_ADDR
// end ;
108410: GO 108329
108412: POP
108413: POP
// end ;
108414: LD_VAR 0 2
108418: RET
// export function Length ( array ) ; begin
108419: LD_INT 0
108421: PPUSH
// result := array + 0 ;
108422: LD_ADDR_VAR 0 2
108426: PUSH
108427: LD_VAR 0 1
108431: PUSH
108432: LD_INT 0
108434: PLUS
108435: ST_TO_ADDR
// end ;
108436: LD_VAR 0 2
108440: RET
// export function PrepareArray ( array ) ; begin
108441: LD_INT 0
108443: PPUSH
// result := array diff 0 ;
108444: LD_ADDR_VAR 0 2
108448: PUSH
108449: LD_VAR 0 1
108453: PUSH
108454: LD_INT 0
108456: DIFF
108457: ST_TO_ADDR
// if not result [ 1 ] then
108458: LD_VAR 0 2
108462: PUSH
108463: LD_INT 1
108465: ARRAY
108466: NOT
108467: IFFALSE 108487
// result := Delete ( result , 1 ) ;
108469: LD_ADDR_VAR 0 2
108473: PUSH
108474: LD_VAR 0 2
108478: PPUSH
108479: LD_INT 1
108481: PPUSH
108482: CALL_OW 3
108486: ST_TO_ADDR
// end ; end_of_file end_of_file
108487: LD_VAR 0 2
108491: RET
// every 0 0$1 do
108492: GO 108494
108494: DISABLE
// begin enable ;
108495: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
108496: LD_STRING updateTimer(
108498: PUSH
108499: LD_OWVAR 1
108503: STR
108504: PUSH
108505: LD_STRING );
108507: STR
108508: PPUSH
108509: CALL_OW 559
// end ;
108513: END
// export function SOS_MapStart ( ) ; begin
108514: LD_INT 0
108516: PPUSH
// if streamModeActive then
108517: LD_EXP 143
108521: IFFALSE 108530
// DefineStreamItems ( true ) ;
108523: LD_INT 1
108525: PPUSH
108526: CALL 110184 0 1
// UpdateFactoryWaypoints ( ) ;
108530: CALL 123045 0 0
// UpdateWarehouseGatheringPoints ( ) ;
108534: CALL 123302 0 0
// end ;
108538: LD_VAR 0 1
108542: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
108543: LD_INT 0
108545: PPUSH
// if p2 = 100 then
108546: LD_VAR 0 2
108550: PUSH
108551: LD_INT 100
108553: EQUAL
108554: IFFALSE 109557
// begin if not StreamModeActive then
108556: LD_EXP 143
108560: NOT
108561: IFFALSE 108571
// StreamModeActive := true ;
108563: LD_ADDR_EXP 143
108567: PUSH
108568: LD_INT 1
108570: ST_TO_ADDR
// if p3 = 0 then
108571: LD_VAR 0 3
108575: PUSH
108576: LD_INT 0
108578: EQUAL
108579: IFFALSE 108585
// InitStreamMode ;
108581: CALL 109720 0 0
// if p3 = 1 then
108585: LD_VAR 0 3
108589: PUSH
108590: LD_INT 1
108592: EQUAL
108593: IFFALSE 108603
// sRocket := true ;
108595: LD_ADDR_EXP 148
108599: PUSH
108600: LD_INT 1
108602: ST_TO_ADDR
// if p3 = 2 then
108603: LD_VAR 0 3
108607: PUSH
108608: LD_INT 2
108610: EQUAL
108611: IFFALSE 108621
// sSpeed := true ;
108613: LD_ADDR_EXP 147
108617: PUSH
108618: LD_INT 1
108620: ST_TO_ADDR
// if p3 = 3 then
108621: LD_VAR 0 3
108625: PUSH
108626: LD_INT 3
108628: EQUAL
108629: IFFALSE 108639
// sEngine := true ;
108631: LD_ADDR_EXP 149
108635: PUSH
108636: LD_INT 1
108638: ST_TO_ADDR
// if p3 = 4 then
108639: LD_VAR 0 3
108643: PUSH
108644: LD_INT 4
108646: EQUAL
108647: IFFALSE 108657
// sSpec := true ;
108649: LD_ADDR_EXP 146
108653: PUSH
108654: LD_INT 1
108656: ST_TO_ADDR
// if p3 = 5 then
108657: LD_VAR 0 3
108661: PUSH
108662: LD_INT 5
108664: EQUAL
108665: IFFALSE 108675
// sLevel := true ;
108667: LD_ADDR_EXP 150
108671: PUSH
108672: LD_INT 1
108674: ST_TO_ADDR
// if p3 = 6 then
108675: LD_VAR 0 3
108679: PUSH
108680: LD_INT 6
108682: EQUAL
108683: IFFALSE 108693
// sArmoury := true ;
108685: LD_ADDR_EXP 151
108689: PUSH
108690: LD_INT 1
108692: ST_TO_ADDR
// if p3 = 7 then
108693: LD_VAR 0 3
108697: PUSH
108698: LD_INT 7
108700: EQUAL
108701: IFFALSE 108711
// sRadar := true ;
108703: LD_ADDR_EXP 152
108707: PUSH
108708: LD_INT 1
108710: ST_TO_ADDR
// if p3 = 8 then
108711: LD_VAR 0 3
108715: PUSH
108716: LD_INT 8
108718: EQUAL
108719: IFFALSE 108729
// sBunker := true ;
108721: LD_ADDR_EXP 153
108725: PUSH
108726: LD_INT 1
108728: ST_TO_ADDR
// if p3 = 9 then
108729: LD_VAR 0 3
108733: PUSH
108734: LD_INT 9
108736: EQUAL
108737: IFFALSE 108747
// sHack := true ;
108739: LD_ADDR_EXP 154
108743: PUSH
108744: LD_INT 1
108746: ST_TO_ADDR
// if p3 = 10 then
108747: LD_VAR 0 3
108751: PUSH
108752: LD_INT 10
108754: EQUAL
108755: IFFALSE 108765
// sFire := true ;
108757: LD_ADDR_EXP 155
108761: PUSH
108762: LD_INT 1
108764: ST_TO_ADDR
// if p3 = 11 then
108765: LD_VAR 0 3
108769: PUSH
108770: LD_INT 11
108772: EQUAL
108773: IFFALSE 108783
// sRefresh := true ;
108775: LD_ADDR_EXP 156
108779: PUSH
108780: LD_INT 1
108782: ST_TO_ADDR
// if p3 = 12 then
108783: LD_VAR 0 3
108787: PUSH
108788: LD_INT 12
108790: EQUAL
108791: IFFALSE 108801
// sExp := true ;
108793: LD_ADDR_EXP 157
108797: PUSH
108798: LD_INT 1
108800: ST_TO_ADDR
// if p3 = 13 then
108801: LD_VAR 0 3
108805: PUSH
108806: LD_INT 13
108808: EQUAL
108809: IFFALSE 108819
// sDepot := true ;
108811: LD_ADDR_EXP 158
108815: PUSH
108816: LD_INT 1
108818: ST_TO_ADDR
// if p3 = 14 then
108819: LD_VAR 0 3
108823: PUSH
108824: LD_INT 14
108826: EQUAL
108827: IFFALSE 108837
// sFlag := true ;
108829: LD_ADDR_EXP 159
108833: PUSH
108834: LD_INT 1
108836: ST_TO_ADDR
// if p3 = 15 then
108837: LD_VAR 0 3
108841: PUSH
108842: LD_INT 15
108844: EQUAL
108845: IFFALSE 108855
// sKamikadze := true ;
108847: LD_ADDR_EXP 167
108851: PUSH
108852: LD_INT 1
108854: ST_TO_ADDR
// if p3 = 16 then
108855: LD_VAR 0 3
108859: PUSH
108860: LD_INT 16
108862: EQUAL
108863: IFFALSE 108873
// sTroll := true ;
108865: LD_ADDR_EXP 168
108869: PUSH
108870: LD_INT 1
108872: ST_TO_ADDR
// if p3 = 17 then
108873: LD_VAR 0 3
108877: PUSH
108878: LD_INT 17
108880: EQUAL
108881: IFFALSE 108891
// sSlow := true ;
108883: LD_ADDR_EXP 169
108887: PUSH
108888: LD_INT 1
108890: ST_TO_ADDR
// if p3 = 18 then
108891: LD_VAR 0 3
108895: PUSH
108896: LD_INT 18
108898: EQUAL
108899: IFFALSE 108909
// sLack := true ;
108901: LD_ADDR_EXP 170
108905: PUSH
108906: LD_INT 1
108908: ST_TO_ADDR
// if p3 = 19 then
108909: LD_VAR 0 3
108913: PUSH
108914: LD_INT 19
108916: EQUAL
108917: IFFALSE 108927
// sTank := true ;
108919: LD_ADDR_EXP 172
108923: PUSH
108924: LD_INT 1
108926: ST_TO_ADDR
// if p3 = 20 then
108927: LD_VAR 0 3
108931: PUSH
108932: LD_INT 20
108934: EQUAL
108935: IFFALSE 108945
// sRemote := true ;
108937: LD_ADDR_EXP 173
108941: PUSH
108942: LD_INT 1
108944: ST_TO_ADDR
// if p3 = 21 then
108945: LD_VAR 0 3
108949: PUSH
108950: LD_INT 21
108952: EQUAL
108953: IFFALSE 108963
// sPowell := true ;
108955: LD_ADDR_EXP 174
108959: PUSH
108960: LD_INT 1
108962: ST_TO_ADDR
// if p3 = 22 then
108963: LD_VAR 0 3
108967: PUSH
108968: LD_INT 22
108970: EQUAL
108971: IFFALSE 108981
// sTeleport := true ;
108973: LD_ADDR_EXP 177
108977: PUSH
108978: LD_INT 1
108980: ST_TO_ADDR
// if p3 = 23 then
108981: LD_VAR 0 3
108985: PUSH
108986: LD_INT 23
108988: EQUAL
108989: IFFALSE 108999
// sOilTower := true ;
108991: LD_ADDR_EXP 179
108995: PUSH
108996: LD_INT 1
108998: ST_TO_ADDR
// if p3 = 24 then
108999: LD_VAR 0 3
109003: PUSH
109004: LD_INT 24
109006: EQUAL
109007: IFFALSE 109017
// sShovel := true ;
109009: LD_ADDR_EXP 180
109013: PUSH
109014: LD_INT 1
109016: ST_TO_ADDR
// if p3 = 25 then
109017: LD_VAR 0 3
109021: PUSH
109022: LD_INT 25
109024: EQUAL
109025: IFFALSE 109035
// sSheik := true ;
109027: LD_ADDR_EXP 181
109031: PUSH
109032: LD_INT 1
109034: ST_TO_ADDR
// if p3 = 26 then
109035: LD_VAR 0 3
109039: PUSH
109040: LD_INT 26
109042: EQUAL
109043: IFFALSE 109053
// sEarthquake := true ;
109045: LD_ADDR_EXP 183
109049: PUSH
109050: LD_INT 1
109052: ST_TO_ADDR
// if p3 = 27 then
109053: LD_VAR 0 3
109057: PUSH
109058: LD_INT 27
109060: EQUAL
109061: IFFALSE 109071
// sAI := true ;
109063: LD_ADDR_EXP 184
109067: PUSH
109068: LD_INT 1
109070: ST_TO_ADDR
// if p3 = 28 then
109071: LD_VAR 0 3
109075: PUSH
109076: LD_INT 28
109078: EQUAL
109079: IFFALSE 109089
// sCargo := true ;
109081: LD_ADDR_EXP 187
109085: PUSH
109086: LD_INT 1
109088: ST_TO_ADDR
// if p3 = 29 then
109089: LD_VAR 0 3
109093: PUSH
109094: LD_INT 29
109096: EQUAL
109097: IFFALSE 109107
// sDLaser := true ;
109099: LD_ADDR_EXP 188
109103: PUSH
109104: LD_INT 1
109106: ST_TO_ADDR
// if p3 = 30 then
109107: LD_VAR 0 3
109111: PUSH
109112: LD_INT 30
109114: EQUAL
109115: IFFALSE 109125
// sExchange := true ;
109117: LD_ADDR_EXP 189
109121: PUSH
109122: LD_INT 1
109124: ST_TO_ADDR
// if p3 = 31 then
109125: LD_VAR 0 3
109129: PUSH
109130: LD_INT 31
109132: EQUAL
109133: IFFALSE 109143
// sFac := true ;
109135: LD_ADDR_EXP 190
109139: PUSH
109140: LD_INT 1
109142: ST_TO_ADDR
// if p3 = 32 then
109143: LD_VAR 0 3
109147: PUSH
109148: LD_INT 32
109150: EQUAL
109151: IFFALSE 109161
// sPower := true ;
109153: LD_ADDR_EXP 191
109157: PUSH
109158: LD_INT 1
109160: ST_TO_ADDR
// if p3 = 33 then
109161: LD_VAR 0 3
109165: PUSH
109166: LD_INT 33
109168: EQUAL
109169: IFFALSE 109179
// sRandom := true ;
109171: LD_ADDR_EXP 192
109175: PUSH
109176: LD_INT 1
109178: ST_TO_ADDR
// if p3 = 34 then
109179: LD_VAR 0 3
109183: PUSH
109184: LD_INT 34
109186: EQUAL
109187: IFFALSE 109197
// sShield := true ;
109189: LD_ADDR_EXP 193
109193: PUSH
109194: LD_INT 1
109196: ST_TO_ADDR
// if p3 = 35 then
109197: LD_VAR 0 3
109201: PUSH
109202: LD_INT 35
109204: EQUAL
109205: IFFALSE 109215
// sTime := true ;
109207: LD_ADDR_EXP 194
109211: PUSH
109212: LD_INT 1
109214: ST_TO_ADDR
// if p3 = 36 then
109215: LD_VAR 0 3
109219: PUSH
109220: LD_INT 36
109222: EQUAL
109223: IFFALSE 109233
// sTools := true ;
109225: LD_ADDR_EXP 195
109229: PUSH
109230: LD_INT 1
109232: ST_TO_ADDR
// if p3 = 101 then
109233: LD_VAR 0 3
109237: PUSH
109238: LD_INT 101
109240: EQUAL
109241: IFFALSE 109251
// sSold := true ;
109243: LD_ADDR_EXP 160
109247: PUSH
109248: LD_INT 1
109250: ST_TO_ADDR
// if p3 = 102 then
109251: LD_VAR 0 3
109255: PUSH
109256: LD_INT 102
109258: EQUAL
109259: IFFALSE 109269
// sDiff := true ;
109261: LD_ADDR_EXP 161
109265: PUSH
109266: LD_INT 1
109268: ST_TO_ADDR
// if p3 = 103 then
109269: LD_VAR 0 3
109273: PUSH
109274: LD_INT 103
109276: EQUAL
109277: IFFALSE 109287
// sFog := true ;
109279: LD_ADDR_EXP 164
109283: PUSH
109284: LD_INT 1
109286: ST_TO_ADDR
// if p3 = 104 then
109287: LD_VAR 0 3
109291: PUSH
109292: LD_INT 104
109294: EQUAL
109295: IFFALSE 109305
// sReset := true ;
109297: LD_ADDR_EXP 165
109301: PUSH
109302: LD_INT 1
109304: ST_TO_ADDR
// if p3 = 105 then
109305: LD_VAR 0 3
109309: PUSH
109310: LD_INT 105
109312: EQUAL
109313: IFFALSE 109323
// sSun := true ;
109315: LD_ADDR_EXP 166
109319: PUSH
109320: LD_INT 1
109322: ST_TO_ADDR
// if p3 = 106 then
109323: LD_VAR 0 3
109327: PUSH
109328: LD_INT 106
109330: EQUAL
109331: IFFALSE 109341
// sTiger := true ;
109333: LD_ADDR_EXP 162
109337: PUSH
109338: LD_INT 1
109340: ST_TO_ADDR
// if p3 = 107 then
109341: LD_VAR 0 3
109345: PUSH
109346: LD_INT 107
109348: EQUAL
109349: IFFALSE 109359
// sBomb := true ;
109351: LD_ADDR_EXP 163
109355: PUSH
109356: LD_INT 1
109358: ST_TO_ADDR
// if p3 = 108 then
109359: LD_VAR 0 3
109363: PUSH
109364: LD_INT 108
109366: EQUAL
109367: IFFALSE 109377
// sWound := true ;
109369: LD_ADDR_EXP 171
109373: PUSH
109374: LD_INT 1
109376: ST_TO_ADDR
// if p3 = 109 then
109377: LD_VAR 0 3
109381: PUSH
109382: LD_INT 109
109384: EQUAL
109385: IFFALSE 109395
// sBetray := true ;
109387: LD_ADDR_EXP 175
109391: PUSH
109392: LD_INT 1
109394: ST_TO_ADDR
// if p3 = 110 then
109395: LD_VAR 0 3
109399: PUSH
109400: LD_INT 110
109402: EQUAL
109403: IFFALSE 109413
// sContamin := true ;
109405: LD_ADDR_EXP 176
109409: PUSH
109410: LD_INT 1
109412: ST_TO_ADDR
// if p3 = 111 then
109413: LD_VAR 0 3
109417: PUSH
109418: LD_INT 111
109420: EQUAL
109421: IFFALSE 109431
// sOil := true ;
109423: LD_ADDR_EXP 178
109427: PUSH
109428: LD_INT 1
109430: ST_TO_ADDR
// if p3 = 112 then
109431: LD_VAR 0 3
109435: PUSH
109436: LD_INT 112
109438: EQUAL
109439: IFFALSE 109449
// sStu := true ;
109441: LD_ADDR_EXP 182
109445: PUSH
109446: LD_INT 1
109448: ST_TO_ADDR
// if p3 = 113 then
109449: LD_VAR 0 3
109453: PUSH
109454: LD_INT 113
109456: EQUAL
109457: IFFALSE 109467
// sBazooka := true ;
109459: LD_ADDR_EXP 185
109463: PUSH
109464: LD_INT 1
109466: ST_TO_ADDR
// if p3 = 114 then
109467: LD_VAR 0 3
109471: PUSH
109472: LD_INT 114
109474: EQUAL
109475: IFFALSE 109485
// sMortar := true ;
109477: LD_ADDR_EXP 186
109481: PUSH
109482: LD_INT 1
109484: ST_TO_ADDR
// if p3 = 115 then
109485: LD_VAR 0 3
109489: PUSH
109490: LD_INT 115
109492: EQUAL
109493: IFFALSE 109503
// sRanger := true ;
109495: LD_ADDR_EXP 196
109499: PUSH
109500: LD_INT 1
109502: ST_TO_ADDR
// if p3 = 116 then
109503: LD_VAR 0 3
109507: PUSH
109508: LD_INT 116
109510: EQUAL
109511: IFFALSE 109521
// sComputer := true ;
109513: LD_ADDR_EXP 197
109517: PUSH
109518: LD_INT 1
109520: ST_TO_ADDR
// if p3 = 117 then
109521: LD_VAR 0 3
109525: PUSH
109526: LD_INT 117
109528: EQUAL
109529: IFFALSE 109539
// s30 := true ;
109531: LD_ADDR_EXP 198
109535: PUSH
109536: LD_INT 1
109538: ST_TO_ADDR
// if p3 = 118 then
109539: LD_VAR 0 3
109543: PUSH
109544: LD_INT 118
109546: EQUAL
109547: IFFALSE 109557
// s60 := true ;
109549: LD_ADDR_EXP 199
109553: PUSH
109554: LD_INT 1
109556: ST_TO_ADDR
// end ; if p2 = 101 then
109557: LD_VAR 0 2
109561: PUSH
109562: LD_INT 101
109564: EQUAL
109565: IFFALSE 109693
// begin case p3 of 1 :
109567: LD_VAR 0 3
109571: PUSH
109572: LD_INT 1
109574: DOUBLE
109575: EQUAL
109576: IFTRUE 109580
109578: GO 109587
109580: POP
// hHackUnlimitedResources ; 2 :
109581: CALL 121791 0 0
109585: GO 109693
109587: LD_INT 2
109589: DOUBLE
109590: EQUAL
109591: IFTRUE 109595
109593: GO 109602
109595: POP
// hHackSetLevel10 ; 3 :
109596: CALL 121924 0 0
109600: GO 109693
109602: LD_INT 3
109604: DOUBLE
109605: EQUAL
109606: IFTRUE 109610
109608: GO 109617
109610: POP
// hHackSetLevel10YourUnits ; 4 :
109611: CALL 122009 0 0
109615: GO 109693
109617: LD_INT 4
109619: DOUBLE
109620: EQUAL
109621: IFTRUE 109625
109623: GO 109632
109625: POP
// hHackInvincible ; 5 :
109626: CALL 122457 0 0
109630: GO 109693
109632: LD_INT 5
109634: DOUBLE
109635: EQUAL
109636: IFTRUE 109640
109638: GO 109647
109640: POP
// hHackInvisible ; 6 :
109641: CALL 122568 0 0
109645: GO 109693
109647: LD_INT 6
109649: DOUBLE
109650: EQUAL
109651: IFTRUE 109655
109653: GO 109662
109655: POP
// hHackChangeYourSide ; 7 :
109656: CALL 122625 0 0
109660: GO 109693
109662: LD_INT 7
109664: DOUBLE
109665: EQUAL
109666: IFTRUE 109670
109668: GO 109677
109670: POP
// hHackChangeUnitSide ; 8 :
109671: CALL 122667 0 0
109675: GO 109693
109677: LD_INT 8
109679: DOUBLE
109680: EQUAL
109681: IFTRUE 109685
109683: GO 109692
109685: POP
// hHackFog ; end ;
109686: CALL 122768 0 0
109690: GO 109693
109692: POP
// end ; end ;
109693: LD_VAR 0 7
109697: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
109698: GO 109700
109700: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
109701: LD_STRING initStreamRollete();
109703: PPUSH
109704: CALL_OW 559
// InitStreamMode ;
109708: CALL 109720 0 0
// DefineStreamItems ( false ) ;
109712: LD_INT 0
109714: PPUSH
109715: CALL 110184 0 1
// end ;
109719: END
// function InitStreamMode ; begin
109720: LD_INT 0
109722: PPUSH
// streamModeActive := false ;
109723: LD_ADDR_EXP 143
109727: PUSH
109728: LD_INT 0
109730: ST_TO_ADDR
// normalCounter := 36 ;
109731: LD_ADDR_EXP 144
109735: PUSH
109736: LD_INT 36
109738: ST_TO_ADDR
// hardcoreCounter := 18 ;
109739: LD_ADDR_EXP 145
109743: PUSH
109744: LD_INT 18
109746: ST_TO_ADDR
// sRocket := false ;
109747: LD_ADDR_EXP 148
109751: PUSH
109752: LD_INT 0
109754: ST_TO_ADDR
// sSpeed := false ;
109755: LD_ADDR_EXP 147
109759: PUSH
109760: LD_INT 0
109762: ST_TO_ADDR
// sEngine := false ;
109763: LD_ADDR_EXP 149
109767: PUSH
109768: LD_INT 0
109770: ST_TO_ADDR
// sSpec := false ;
109771: LD_ADDR_EXP 146
109775: PUSH
109776: LD_INT 0
109778: ST_TO_ADDR
// sLevel := false ;
109779: LD_ADDR_EXP 150
109783: PUSH
109784: LD_INT 0
109786: ST_TO_ADDR
// sArmoury := false ;
109787: LD_ADDR_EXP 151
109791: PUSH
109792: LD_INT 0
109794: ST_TO_ADDR
// sRadar := false ;
109795: LD_ADDR_EXP 152
109799: PUSH
109800: LD_INT 0
109802: ST_TO_ADDR
// sBunker := false ;
109803: LD_ADDR_EXP 153
109807: PUSH
109808: LD_INT 0
109810: ST_TO_ADDR
// sHack := false ;
109811: LD_ADDR_EXP 154
109815: PUSH
109816: LD_INT 0
109818: ST_TO_ADDR
// sFire := false ;
109819: LD_ADDR_EXP 155
109823: PUSH
109824: LD_INT 0
109826: ST_TO_ADDR
// sRefresh := false ;
109827: LD_ADDR_EXP 156
109831: PUSH
109832: LD_INT 0
109834: ST_TO_ADDR
// sExp := false ;
109835: LD_ADDR_EXP 157
109839: PUSH
109840: LD_INT 0
109842: ST_TO_ADDR
// sDepot := false ;
109843: LD_ADDR_EXP 158
109847: PUSH
109848: LD_INT 0
109850: ST_TO_ADDR
// sFlag := false ;
109851: LD_ADDR_EXP 159
109855: PUSH
109856: LD_INT 0
109858: ST_TO_ADDR
// sKamikadze := false ;
109859: LD_ADDR_EXP 167
109863: PUSH
109864: LD_INT 0
109866: ST_TO_ADDR
// sTroll := false ;
109867: LD_ADDR_EXP 168
109871: PUSH
109872: LD_INT 0
109874: ST_TO_ADDR
// sSlow := false ;
109875: LD_ADDR_EXP 169
109879: PUSH
109880: LD_INT 0
109882: ST_TO_ADDR
// sLack := false ;
109883: LD_ADDR_EXP 170
109887: PUSH
109888: LD_INT 0
109890: ST_TO_ADDR
// sTank := false ;
109891: LD_ADDR_EXP 172
109895: PUSH
109896: LD_INT 0
109898: ST_TO_ADDR
// sRemote := false ;
109899: LD_ADDR_EXP 173
109903: PUSH
109904: LD_INT 0
109906: ST_TO_ADDR
// sPowell := false ;
109907: LD_ADDR_EXP 174
109911: PUSH
109912: LD_INT 0
109914: ST_TO_ADDR
// sTeleport := false ;
109915: LD_ADDR_EXP 177
109919: PUSH
109920: LD_INT 0
109922: ST_TO_ADDR
// sOilTower := false ;
109923: LD_ADDR_EXP 179
109927: PUSH
109928: LD_INT 0
109930: ST_TO_ADDR
// sShovel := false ;
109931: LD_ADDR_EXP 180
109935: PUSH
109936: LD_INT 0
109938: ST_TO_ADDR
// sSheik := false ;
109939: LD_ADDR_EXP 181
109943: PUSH
109944: LD_INT 0
109946: ST_TO_ADDR
// sEarthquake := false ;
109947: LD_ADDR_EXP 183
109951: PUSH
109952: LD_INT 0
109954: ST_TO_ADDR
// sAI := false ;
109955: LD_ADDR_EXP 184
109959: PUSH
109960: LD_INT 0
109962: ST_TO_ADDR
// sCargo := false ;
109963: LD_ADDR_EXP 187
109967: PUSH
109968: LD_INT 0
109970: ST_TO_ADDR
// sDLaser := false ;
109971: LD_ADDR_EXP 188
109975: PUSH
109976: LD_INT 0
109978: ST_TO_ADDR
// sExchange := false ;
109979: LD_ADDR_EXP 189
109983: PUSH
109984: LD_INT 0
109986: ST_TO_ADDR
// sFac := false ;
109987: LD_ADDR_EXP 190
109991: PUSH
109992: LD_INT 0
109994: ST_TO_ADDR
// sPower := false ;
109995: LD_ADDR_EXP 191
109999: PUSH
110000: LD_INT 0
110002: ST_TO_ADDR
// sRandom := false ;
110003: LD_ADDR_EXP 192
110007: PUSH
110008: LD_INT 0
110010: ST_TO_ADDR
// sShield := false ;
110011: LD_ADDR_EXP 193
110015: PUSH
110016: LD_INT 0
110018: ST_TO_ADDR
// sTime := false ;
110019: LD_ADDR_EXP 194
110023: PUSH
110024: LD_INT 0
110026: ST_TO_ADDR
// sTools := false ;
110027: LD_ADDR_EXP 195
110031: PUSH
110032: LD_INT 0
110034: ST_TO_ADDR
// sSold := false ;
110035: LD_ADDR_EXP 160
110039: PUSH
110040: LD_INT 0
110042: ST_TO_ADDR
// sDiff := false ;
110043: LD_ADDR_EXP 161
110047: PUSH
110048: LD_INT 0
110050: ST_TO_ADDR
// sFog := false ;
110051: LD_ADDR_EXP 164
110055: PUSH
110056: LD_INT 0
110058: ST_TO_ADDR
// sReset := false ;
110059: LD_ADDR_EXP 165
110063: PUSH
110064: LD_INT 0
110066: ST_TO_ADDR
// sSun := false ;
110067: LD_ADDR_EXP 166
110071: PUSH
110072: LD_INT 0
110074: ST_TO_ADDR
// sTiger := false ;
110075: LD_ADDR_EXP 162
110079: PUSH
110080: LD_INT 0
110082: ST_TO_ADDR
// sBomb := false ;
110083: LD_ADDR_EXP 163
110087: PUSH
110088: LD_INT 0
110090: ST_TO_ADDR
// sWound := false ;
110091: LD_ADDR_EXP 171
110095: PUSH
110096: LD_INT 0
110098: ST_TO_ADDR
// sBetray := false ;
110099: LD_ADDR_EXP 175
110103: PUSH
110104: LD_INT 0
110106: ST_TO_ADDR
// sContamin := false ;
110107: LD_ADDR_EXP 176
110111: PUSH
110112: LD_INT 0
110114: ST_TO_ADDR
// sOil := false ;
110115: LD_ADDR_EXP 178
110119: PUSH
110120: LD_INT 0
110122: ST_TO_ADDR
// sStu := false ;
110123: LD_ADDR_EXP 182
110127: PUSH
110128: LD_INT 0
110130: ST_TO_ADDR
// sBazooka := false ;
110131: LD_ADDR_EXP 185
110135: PUSH
110136: LD_INT 0
110138: ST_TO_ADDR
// sMortar := false ;
110139: LD_ADDR_EXP 186
110143: PUSH
110144: LD_INT 0
110146: ST_TO_ADDR
// sRanger := false ;
110147: LD_ADDR_EXP 196
110151: PUSH
110152: LD_INT 0
110154: ST_TO_ADDR
// sComputer := false ;
110155: LD_ADDR_EXP 197
110159: PUSH
110160: LD_INT 0
110162: ST_TO_ADDR
// s30 := false ;
110163: LD_ADDR_EXP 198
110167: PUSH
110168: LD_INT 0
110170: ST_TO_ADDR
// s60 := false ;
110171: LD_ADDR_EXP 199
110175: PUSH
110176: LD_INT 0
110178: ST_TO_ADDR
// end ;
110179: LD_VAR 0 1
110183: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
110184: LD_INT 0
110186: PPUSH
110187: PPUSH
110188: PPUSH
110189: PPUSH
110190: PPUSH
110191: PPUSH
110192: PPUSH
// result := [ ] ;
110193: LD_ADDR_VAR 0 2
110197: PUSH
110198: EMPTY
110199: ST_TO_ADDR
// if campaign_id = 1 then
110200: LD_OWVAR 69
110204: PUSH
110205: LD_INT 1
110207: EQUAL
110208: IFFALSE 113374
// begin case mission_number of 1 :
110210: LD_OWVAR 70
110214: PUSH
110215: LD_INT 1
110217: DOUBLE
110218: EQUAL
110219: IFTRUE 110223
110221: GO 110299
110223: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
110224: LD_ADDR_VAR 0 2
110228: PUSH
110229: LD_INT 2
110231: PUSH
110232: LD_INT 4
110234: PUSH
110235: LD_INT 11
110237: PUSH
110238: LD_INT 12
110240: PUSH
110241: LD_INT 15
110243: PUSH
110244: LD_INT 16
110246: PUSH
110247: LD_INT 22
110249: PUSH
110250: LD_INT 23
110252: PUSH
110253: LD_INT 26
110255: PUSH
110256: EMPTY
110257: LIST
110258: LIST
110259: LIST
110260: LIST
110261: LIST
110262: LIST
110263: LIST
110264: LIST
110265: LIST
110266: PUSH
110267: LD_INT 101
110269: PUSH
110270: LD_INT 102
110272: PUSH
110273: LD_INT 106
110275: PUSH
110276: LD_INT 116
110278: PUSH
110279: LD_INT 117
110281: PUSH
110282: LD_INT 118
110284: PUSH
110285: EMPTY
110286: LIST
110287: LIST
110288: LIST
110289: LIST
110290: LIST
110291: LIST
110292: PUSH
110293: EMPTY
110294: LIST
110295: LIST
110296: ST_TO_ADDR
110297: GO 113372
110299: LD_INT 2
110301: DOUBLE
110302: EQUAL
110303: IFTRUE 110307
110305: GO 110391
110307: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
110308: LD_ADDR_VAR 0 2
110312: PUSH
110313: LD_INT 2
110315: PUSH
110316: LD_INT 4
110318: PUSH
110319: LD_INT 11
110321: PUSH
110322: LD_INT 12
110324: PUSH
110325: LD_INT 15
110327: PUSH
110328: LD_INT 16
110330: PUSH
110331: LD_INT 22
110333: PUSH
110334: LD_INT 23
110336: PUSH
110337: LD_INT 26
110339: PUSH
110340: EMPTY
110341: LIST
110342: LIST
110343: LIST
110344: LIST
110345: LIST
110346: LIST
110347: LIST
110348: LIST
110349: LIST
110350: PUSH
110351: LD_INT 101
110353: PUSH
110354: LD_INT 102
110356: PUSH
110357: LD_INT 105
110359: PUSH
110360: LD_INT 106
110362: PUSH
110363: LD_INT 108
110365: PUSH
110366: LD_INT 116
110368: PUSH
110369: LD_INT 117
110371: PUSH
110372: LD_INT 118
110374: PUSH
110375: EMPTY
110376: LIST
110377: LIST
110378: LIST
110379: LIST
110380: LIST
110381: LIST
110382: LIST
110383: LIST
110384: PUSH
110385: EMPTY
110386: LIST
110387: LIST
110388: ST_TO_ADDR
110389: GO 113372
110391: LD_INT 3
110393: DOUBLE
110394: EQUAL
110395: IFTRUE 110399
110397: GO 110487
110399: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
110400: LD_ADDR_VAR 0 2
110404: PUSH
110405: LD_INT 2
110407: PUSH
110408: LD_INT 4
110410: PUSH
110411: LD_INT 5
110413: PUSH
110414: LD_INT 11
110416: PUSH
110417: LD_INT 12
110419: PUSH
110420: LD_INT 15
110422: PUSH
110423: LD_INT 16
110425: PUSH
110426: LD_INT 22
110428: PUSH
110429: LD_INT 26
110431: PUSH
110432: LD_INT 36
110434: PUSH
110435: EMPTY
110436: LIST
110437: LIST
110438: LIST
110439: LIST
110440: LIST
110441: LIST
110442: LIST
110443: LIST
110444: LIST
110445: LIST
110446: PUSH
110447: LD_INT 101
110449: PUSH
110450: LD_INT 102
110452: PUSH
110453: LD_INT 105
110455: PUSH
110456: LD_INT 106
110458: PUSH
110459: LD_INT 108
110461: PUSH
110462: LD_INT 116
110464: PUSH
110465: LD_INT 117
110467: PUSH
110468: LD_INT 118
110470: PUSH
110471: EMPTY
110472: LIST
110473: LIST
110474: LIST
110475: LIST
110476: LIST
110477: LIST
110478: LIST
110479: LIST
110480: PUSH
110481: EMPTY
110482: LIST
110483: LIST
110484: ST_TO_ADDR
110485: GO 113372
110487: LD_INT 4
110489: DOUBLE
110490: EQUAL
110491: IFTRUE 110495
110493: GO 110591
110495: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
110496: LD_ADDR_VAR 0 2
110500: PUSH
110501: LD_INT 2
110503: PUSH
110504: LD_INT 4
110506: PUSH
110507: LD_INT 5
110509: PUSH
110510: LD_INT 8
110512: PUSH
110513: LD_INT 11
110515: PUSH
110516: LD_INT 12
110518: PUSH
110519: LD_INT 15
110521: PUSH
110522: LD_INT 16
110524: PUSH
110525: LD_INT 22
110527: PUSH
110528: LD_INT 23
110530: PUSH
110531: LD_INT 26
110533: PUSH
110534: LD_INT 36
110536: PUSH
110537: EMPTY
110538: LIST
110539: LIST
110540: LIST
110541: LIST
110542: LIST
110543: LIST
110544: LIST
110545: LIST
110546: LIST
110547: LIST
110548: LIST
110549: LIST
110550: PUSH
110551: LD_INT 101
110553: PUSH
110554: LD_INT 102
110556: PUSH
110557: LD_INT 105
110559: PUSH
110560: LD_INT 106
110562: PUSH
110563: LD_INT 108
110565: PUSH
110566: LD_INT 116
110568: PUSH
110569: LD_INT 117
110571: PUSH
110572: LD_INT 118
110574: PUSH
110575: EMPTY
110576: LIST
110577: LIST
110578: LIST
110579: LIST
110580: LIST
110581: LIST
110582: LIST
110583: LIST
110584: PUSH
110585: EMPTY
110586: LIST
110587: LIST
110588: ST_TO_ADDR
110589: GO 113372
110591: LD_INT 5
110593: DOUBLE
110594: EQUAL
110595: IFTRUE 110599
110597: GO 110711
110599: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
110600: LD_ADDR_VAR 0 2
110604: PUSH
110605: LD_INT 2
110607: PUSH
110608: LD_INT 4
110610: PUSH
110611: LD_INT 5
110613: PUSH
110614: LD_INT 6
110616: PUSH
110617: LD_INT 8
110619: PUSH
110620: LD_INT 11
110622: PUSH
110623: LD_INT 12
110625: PUSH
110626: LD_INT 15
110628: PUSH
110629: LD_INT 16
110631: PUSH
110632: LD_INT 22
110634: PUSH
110635: LD_INT 23
110637: PUSH
110638: LD_INT 25
110640: PUSH
110641: LD_INT 26
110643: PUSH
110644: LD_INT 36
110646: PUSH
110647: EMPTY
110648: LIST
110649: LIST
110650: LIST
110651: LIST
110652: LIST
110653: LIST
110654: LIST
110655: LIST
110656: LIST
110657: LIST
110658: LIST
110659: LIST
110660: LIST
110661: LIST
110662: PUSH
110663: LD_INT 101
110665: PUSH
110666: LD_INT 102
110668: PUSH
110669: LD_INT 105
110671: PUSH
110672: LD_INT 106
110674: PUSH
110675: LD_INT 108
110677: PUSH
110678: LD_INT 109
110680: PUSH
110681: LD_INT 112
110683: PUSH
110684: LD_INT 116
110686: PUSH
110687: LD_INT 117
110689: PUSH
110690: LD_INT 118
110692: PUSH
110693: EMPTY
110694: LIST
110695: LIST
110696: LIST
110697: LIST
110698: LIST
110699: LIST
110700: LIST
110701: LIST
110702: LIST
110703: LIST
110704: PUSH
110705: EMPTY
110706: LIST
110707: LIST
110708: ST_TO_ADDR
110709: GO 113372
110711: LD_INT 6
110713: DOUBLE
110714: EQUAL
110715: IFTRUE 110719
110717: GO 110851
110719: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
110720: LD_ADDR_VAR 0 2
110724: PUSH
110725: LD_INT 2
110727: PUSH
110728: LD_INT 4
110730: PUSH
110731: LD_INT 5
110733: PUSH
110734: LD_INT 6
110736: PUSH
110737: LD_INT 8
110739: PUSH
110740: LD_INT 11
110742: PUSH
110743: LD_INT 12
110745: PUSH
110746: LD_INT 15
110748: PUSH
110749: LD_INT 16
110751: PUSH
110752: LD_INT 20
110754: PUSH
110755: LD_INT 21
110757: PUSH
110758: LD_INT 22
110760: PUSH
110761: LD_INT 23
110763: PUSH
110764: LD_INT 25
110766: PUSH
110767: LD_INT 26
110769: PUSH
110770: LD_INT 30
110772: PUSH
110773: LD_INT 31
110775: PUSH
110776: LD_INT 32
110778: PUSH
110779: LD_INT 36
110781: PUSH
110782: EMPTY
110783: LIST
110784: LIST
110785: LIST
110786: LIST
110787: LIST
110788: LIST
110789: LIST
110790: LIST
110791: LIST
110792: LIST
110793: LIST
110794: LIST
110795: LIST
110796: LIST
110797: LIST
110798: LIST
110799: LIST
110800: LIST
110801: LIST
110802: PUSH
110803: LD_INT 101
110805: PUSH
110806: LD_INT 102
110808: PUSH
110809: LD_INT 105
110811: PUSH
110812: LD_INT 106
110814: PUSH
110815: LD_INT 108
110817: PUSH
110818: LD_INT 109
110820: PUSH
110821: LD_INT 112
110823: PUSH
110824: LD_INT 116
110826: PUSH
110827: LD_INT 117
110829: PUSH
110830: LD_INT 118
110832: PUSH
110833: EMPTY
110834: LIST
110835: LIST
110836: LIST
110837: LIST
110838: LIST
110839: LIST
110840: LIST
110841: LIST
110842: LIST
110843: LIST
110844: PUSH
110845: EMPTY
110846: LIST
110847: LIST
110848: ST_TO_ADDR
110849: GO 113372
110851: LD_INT 7
110853: DOUBLE
110854: EQUAL
110855: IFTRUE 110859
110857: GO 110971
110859: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
110860: LD_ADDR_VAR 0 2
110864: PUSH
110865: LD_INT 2
110867: PUSH
110868: LD_INT 4
110870: PUSH
110871: LD_INT 5
110873: PUSH
110874: LD_INT 7
110876: PUSH
110877: LD_INT 11
110879: PUSH
110880: LD_INT 12
110882: PUSH
110883: LD_INT 15
110885: PUSH
110886: LD_INT 16
110888: PUSH
110889: LD_INT 20
110891: PUSH
110892: LD_INT 21
110894: PUSH
110895: LD_INT 22
110897: PUSH
110898: LD_INT 23
110900: PUSH
110901: LD_INT 25
110903: PUSH
110904: LD_INT 26
110906: PUSH
110907: EMPTY
110908: LIST
110909: LIST
110910: LIST
110911: LIST
110912: LIST
110913: LIST
110914: LIST
110915: LIST
110916: LIST
110917: LIST
110918: LIST
110919: LIST
110920: LIST
110921: LIST
110922: PUSH
110923: LD_INT 101
110925: PUSH
110926: LD_INT 102
110928: PUSH
110929: LD_INT 103
110931: PUSH
110932: LD_INT 105
110934: PUSH
110935: LD_INT 106
110937: PUSH
110938: LD_INT 108
110940: PUSH
110941: LD_INT 112
110943: PUSH
110944: LD_INT 116
110946: PUSH
110947: LD_INT 117
110949: PUSH
110950: LD_INT 118
110952: PUSH
110953: EMPTY
110954: LIST
110955: LIST
110956: LIST
110957: LIST
110958: LIST
110959: LIST
110960: LIST
110961: LIST
110962: LIST
110963: LIST
110964: PUSH
110965: EMPTY
110966: LIST
110967: LIST
110968: ST_TO_ADDR
110969: GO 113372
110971: LD_INT 8
110973: DOUBLE
110974: EQUAL
110975: IFTRUE 110979
110977: GO 111119
110979: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
110980: LD_ADDR_VAR 0 2
110984: PUSH
110985: LD_INT 2
110987: PUSH
110988: LD_INT 4
110990: PUSH
110991: LD_INT 5
110993: PUSH
110994: LD_INT 6
110996: PUSH
110997: LD_INT 7
110999: PUSH
111000: LD_INT 8
111002: PUSH
111003: LD_INT 11
111005: PUSH
111006: LD_INT 12
111008: PUSH
111009: LD_INT 15
111011: PUSH
111012: LD_INT 16
111014: PUSH
111015: LD_INT 20
111017: PUSH
111018: LD_INT 21
111020: PUSH
111021: LD_INT 22
111023: PUSH
111024: LD_INT 23
111026: PUSH
111027: LD_INT 25
111029: PUSH
111030: LD_INT 26
111032: PUSH
111033: LD_INT 30
111035: PUSH
111036: LD_INT 31
111038: PUSH
111039: LD_INT 32
111041: PUSH
111042: LD_INT 36
111044: PUSH
111045: EMPTY
111046: LIST
111047: LIST
111048: LIST
111049: LIST
111050: LIST
111051: LIST
111052: LIST
111053: LIST
111054: LIST
111055: LIST
111056: LIST
111057: LIST
111058: LIST
111059: LIST
111060: LIST
111061: LIST
111062: LIST
111063: LIST
111064: LIST
111065: LIST
111066: PUSH
111067: LD_INT 101
111069: PUSH
111070: LD_INT 102
111072: PUSH
111073: LD_INT 103
111075: PUSH
111076: LD_INT 105
111078: PUSH
111079: LD_INT 106
111081: PUSH
111082: LD_INT 108
111084: PUSH
111085: LD_INT 109
111087: PUSH
111088: LD_INT 112
111090: PUSH
111091: LD_INT 116
111093: PUSH
111094: LD_INT 117
111096: PUSH
111097: LD_INT 118
111099: PUSH
111100: EMPTY
111101: LIST
111102: LIST
111103: LIST
111104: LIST
111105: LIST
111106: LIST
111107: LIST
111108: LIST
111109: LIST
111110: LIST
111111: LIST
111112: PUSH
111113: EMPTY
111114: LIST
111115: LIST
111116: ST_TO_ADDR
111117: GO 113372
111119: LD_INT 9
111121: DOUBLE
111122: EQUAL
111123: IFTRUE 111127
111125: GO 111275
111127: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
111128: LD_ADDR_VAR 0 2
111132: PUSH
111133: LD_INT 2
111135: PUSH
111136: LD_INT 4
111138: PUSH
111139: LD_INT 5
111141: PUSH
111142: LD_INT 6
111144: PUSH
111145: LD_INT 7
111147: PUSH
111148: LD_INT 8
111150: PUSH
111151: LD_INT 11
111153: PUSH
111154: LD_INT 12
111156: PUSH
111157: LD_INT 15
111159: PUSH
111160: LD_INT 16
111162: PUSH
111163: LD_INT 20
111165: PUSH
111166: LD_INT 21
111168: PUSH
111169: LD_INT 22
111171: PUSH
111172: LD_INT 23
111174: PUSH
111175: LD_INT 25
111177: PUSH
111178: LD_INT 26
111180: PUSH
111181: LD_INT 28
111183: PUSH
111184: LD_INT 30
111186: PUSH
111187: LD_INT 31
111189: PUSH
111190: LD_INT 32
111192: PUSH
111193: LD_INT 36
111195: PUSH
111196: EMPTY
111197: LIST
111198: LIST
111199: LIST
111200: LIST
111201: LIST
111202: LIST
111203: LIST
111204: LIST
111205: LIST
111206: LIST
111207: LIST
111208: LIST
111209: LIST
111210: LIST
111211: LIST
111212: LIST
111213: LIST
111214: LIST
111215: LIST
111216: LIST
111217: LIST
111218: PUSH
111219: LD_INT 101
111221: PUSH
111222: LD_INT 102
111224: PUSH
111225: LD_INT 103
111227: PUSH
111228: LD_INT 105
111230: PUSH
111231: LD_INT 106
111233: PUSH
111234: LD_INT 108
111236: PUSH
111237: LD_INT 109
111239: PUSH
111240: LD_INT 112
111242: PUSH
111243: LD_INT 114
111245: PUSH
111246: LD_INT 116
111248: PUSH
111249: LD_INT 117
111251: PUSH
111252: LD_INT 118
111254: PUSH
111255: EMPTY
111256: LIST
111257: LIST
111258: LIST
111259: LIST
111260: LIST
111261: LIST
111262: LIST
111263: LIST
111264: LIST
111265: LIST
111266: LIST
111267: LIST
111268: PUSH
111269: EMPTY
111270: LIST
111271: LIST
111272: ST_TO_ADDR
111273: GO 113372
111275: LD_INT 10
111277: DOUBLE
111278: EQUAL
111279: IFTRUE 111283
111281: GO 111479
111283: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
111284: LD_ADDR_VAR 0 2
111288: PUSH
111289: LD_INT 2
111291: PUSH
111292: LD_INT 4
111294: PUSH
111295: LD_INT 5
111297: PUSH
111298: LD_INT 6
111300: PUSH
111301: LD_INT 7
111303: PUSH
111304: LD_INT 8
111306: PUSH
111307: LD_INT 9
111309: PUSH
111310: LD_INT 10
111312: PUSH
111313: LD_INT 11
111315: PUSH
111316: LD_INT 12
111318: PUSH
111319: LD_INT 13
111321: PUSH
111322: LD_INT 14
111324: PUSH
111325: LD_INT 15
111327: PUSH
111328: LD_INT 16
111330: PUSH
111331: LD_INT 17
111333: PUSH
111334: LD_INT 18
111336: PUSH
111337: LD_INT 19
111339: PUSH
111340: LD_INT 20
111342: PUSH
111343: LD_INT 21
111345: PUSH
111346: LD_INT 22
111348: PUSH
111349: LD_INT 23
111351: PUSH
111352: LD_INT 24
111354: PUSH
111355: LD_INT 25
111357: PUSH
111358: LD_INT 26
111360: PUSH
111361: LD_INT 28
111363: PUSH
111364: LD_INT 30
111366: PUSH
111367: LD_INT 31
111369: PUSH
111370: LD_INT 32
111372: PUSH
111373: LD_INT 36
111375: PUSH
111376: EMPTY
111377: LIST
111378: LIST
111379: LIST
111380: LIST
111381: LIST
111382: LIST
111383: LIST
111384: LIST
111385: LIST
111386: LIST
111387: LIST
111388: LIST
111389: LIST
111390: LIST
111391: LIST
111392: LIST
111393: LIST
111394: LIST
111395: LIST
111396: LIST
111397: LIST
111398: LIST
111399: LIST
111400: LIST
111401: LIST
111402: LIST
111403: LIST
111404: LIST
111405: LIST
111406: PUSH
111407: LD_INT 101
111409: PUSH
111410: LD_INT 102
111412: PUSH
111413: LD_INT 103
111415: PUSH
111416: LD_INT 104
111418: PUSH
111419: LD_INT 105
111421: PUSH
111422: LD_INT 106
111424: PUSH
111425: LD_INT 107
111427: PUSH
111428: LD_INT 108
111430: PUSH
111431: LD_INT 109
111433: PUSH
111434: LD_INT 110
111436: PUSH
111437: LD_INT 111
111439: PUSH
111440: LD_INT 112
111442: PUSH
111443: LD_INT 114
111445: PUSH
111446: LD_INT 116
111448: PUSH
111449: LD_INT 117
111451: PUSH
111452: LD_INT 118
111454: PUSH
111455: EMPTY
111456: LIST
111457: LIST
111458: LIST
111459: LIST
111460: LIST
111461: LIST
111462: LIST
111463: LIST
111464: LIST
111465: LIST
111466: LIST
111467: LIST
111468: LIST
111469: LIST
111470: LIST
111471: LIST
111472: PUSH
111473: EMPTY
111474: LIST
111475: LIST
111476: ST_TO_ADDR
111477: GO 113372
111479: LD_INT 11
111481: DOUBLE
111482: EQUAL
111483: IFTRUE 111487
111485: GO 111691
111487: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
111488: LD_ADDR_VAR 0 2
111492: PUSH
111493: LD_INT 2
111495: PUSH
111496: LD_INT 3
111498: PUSH
111499: LD_INT 4
111501: PUSH
111502: LD_INT 5
111504: PUSH
111505: LD_INT 6
111507: PUSH
111508: LD_INT 7
111510: PUSH
111511: LD_INT 8
111513: PUSH
111514: LD_INT 9
111516: PUSH
111517: LD_INT 10
111519: PUSH
111520: LD_INT 11
111522: PUSH
111523: LD_INT 12
111525: PUSH
111526: LD_INT 13
111528: PUSH
111529: LD_INT 14
111531: PUSH
111532: LD_INT 15
111534: PUSH
111535: LD_INT 16
111537: PUSH
111538: LD_INT 17
111540: PUSH
111541: LD_INT 18
111543: PUSH
111544: LD_INT 19
111546: PUSH
111547: LD_INT 20
111549: PUSH
111550: LD_INT 21
111552: PUSH
111553: LD_INT 22
111555: PUSH
111556: LD_INT 23
111558: PUSH
111559: LD_INT 24
111561: PUSH
111562: LD_INT 25
111564: PUSH
111565: LD_INT 26
111567: PUSH
111568: LD_INT 28
111570: PUSH
111571: LD_INT 30
111573: PUSH
111574: LD_INT 31
111576: PUSH
111577: LD_INT 32
111579: PUSH
111580: LD_INT 34
111582: PUSH
111583: LD_INT 36
111585: PUSH
111586: EMPTY
111587: LIST
111588: LIST
111589: LIST
111590: LIST
111591: LIST
111592: LIST
111593: LIST
111594: LIST
111595: LIST
111596: LIST
111597: LIST
111598: LIST
111599: LIST
111600: LIST
111601: LIST
111602: LIST
111603: LIST
111604: LIST
111605: LIST
111606: LIST
111607: LIST
111608: LIST
111609: LIST
111610: LIST
111611: LIST
111612: LIST
111613: LIST
111614: LIST
111615: LIST
111616: LIST
111617: LIST
111618: PUSH
111619: LD_INT 101
111621: PUSH
111622: LD_INT 102
111624: PUSH
111625: LD_INT 103
111627: PUSH
111628: LD_INT 104
111630: PUSH
111631: LD_INT 105
111633: PUSH
111634: LD_INT 106
111636: PUSH
111637: LD_INT 107
111639: PUSH
111640: LD_INT 108
111642: PUSH
111643: LD_INT 109
111645: PUSH
111646: LD_INT 110
111648: PUSH
111649: LD_INT 111
111651: PUSH
111652: LD_INT 112
111654: PUSH
111655: LD_INT 114
111657: PUSH
111658: LD_INT 116
111660: PUSH
111661: LD_INT 117
111663: PUSH
111664: LD_INT 118
111666: PUSH
111667: EMPTY
111668: LIST
111669: LIST
111670: LIST
111671: LIST
111672: LIST
111673: LIST
111674: LIST
111675: LIST
111676: LIST
111677: LIST
111678: LIST
111679: LIST
111680: LIST
111681: LIST
111682: LIST
111683: LIST
111684: PUSH
111685: EMPTY
111686: LIST
111687: LIST
111688: ST_TO_ADDR
111689: GO 113372
111691: LD_INT 12
111693: DOUBLE
111694: EQUAL
111695: IFTRUE 111699
111697: GO 111919
111699: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
111700: LD_ADDR_VAR 0 2
111704: PUSH
111705: LD_INT 1
111707: PUSH
111708: LD_INT 2
111710: PUSH
111711: LD_INT 3
111713: PUSH
111714: LD_INT 4
111716: PUSH
111717: LD_INT 5
111719: PUSH
111720: LD_INT 6
111722: PUSH
111723: LD_INT 7
111725: PUSH
111726: LD_INT 8
111728: PUSH
111729: LD_INT 9
111731: PUSH
111732: LD_INT 10
111734: PUSH
111735: LD_INT 11
111737: PUSH
111738: LD_INT 12
111740: PUSH
111741: LD_INT 13
111743: PUSH
111744: LD_INT 14
111746: PUSH
111747: LD_INT 15
111749: PUSH
111750: LD_INT 16
111752: PUSH
111753: LD_INT 17
111755: PUSH
111756: LD_INT 18
111758: PUSH
111759: LD_INT 19
111761: PUSH
111762: LD_INT 20
111764: PUSH
111765: LD_INT 21
111767: PUSH
111768: LD_INT 22
111770: PUSH
111771: LD_INT 23
111773: PUSH
111774: LD_INT 24
111776: PUSH
111777: LD_INT 25
111779: PUSH
111780: LD_INT 26
111782: PUSH
111783: LD_INT 27
111785: PUSH
111786: LD_INT 28
111788: PUSH
111789: LD_INT 30
111791: PUSH
111792: LD_INT 31
111794: PUSH
111795: LD_INT 32
111797: PUSH
111798: LD_INT 33
111800: PUSH
111801: LD_INT 34
111803: PUSH
111804: LD_INT 36
111806: PUSH
111807: EMPTY
111808: LIST
111809: LIST
111810: LIST
111811: LIST
111812: LIST
111813: LIST
111814: LIST
111815: LIST
111816: LIST
111817: LIST
111818: LIST
111819: LIST
111820: LIST
111821: LIST
111822: LIST
111823: LIST
111824: LIST
111825: LIST
111826: LIST
111827: LIST
111828: LIST
111829: LIST
111830: LIST
111831: LIST
111832: LIST
111833: LIST
111834: LIST
111835: LIST
111836: LIST
111837: LIST
111838: LIST
111839: LIST
111840: LIST
111841: LIST
111842: PUSH
111843: LD_INT 101
111845: PUSH
111846: LD_INT 102
111848: PUSH
111849: LD_INT 103
111851: PUSH
111852: LD_INT 104
111854: PUSH
111855: LD_INT 105
111857: PUSH
111858: LD_INT 106
111860: PUSH
111861: LD_INT 107
111863: PUSH
111864: LD_INT 108
111866: PUSH
111867: LD_INT 109
111869: PUSH
111870: LD_INT 110
111872: PUSH
111873: LD_INT 111
111875: PUSH
111876: LD_INT 112
111878: PUSH
111879: LD_INT 113
111881: PUSH
111882: LD_INT 114
111884: PUSH
111885: LD_INT 116
111887: PUSH
111888: LD_INT 117
111890: PUSH
111891: LD_INT 118
111893: PUSH
111894: EMPTY
111895: LIST
111896: LIST
111897: LIST
111898: LIST
111899: LIST
111900: LIST
111901: LIST
111902: LIST
111903: LIST
111904: LIST
111905: LIST
111906: LIST
111907: LIST
111908: LIST
111909: LIST
111910: LIST
111911: LIST
111912: PUSH
111913: EMPTY
111914: LIST
111915: LIST
111916: ST_TO_ADDR
111917: GO 113372
111919: LD_INT 13
111921: DOUBLE
111922: EQUAL
111923: IFTRUE 111927
111925: GO 112135
111927: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
111928: LD_ADDR_VAR 0 2
111932: PUSH
111933: LD_INT 1
111935: PUSH
111936: LD_INT 2
111938: PUSH
111939: LD_INT 3
111941: PUSH
111942: LD_INT 4
111944: PUSH
111945: LD_INT 5
111947: PUSH
111948: LD_INT 8
111950: PUSH
111951: LD_INT 9
111953: PUSH
111954: LD_INT 10
111956: PUSH
111957: LD_INT 11
111959: PUSH
111960: LD_INT 12
111962: PUSH
111963: LD_INT 14
111965: PUSH
111966: LD_INT 15
111968: PUSH
111969: LD_INT 16
111971: PUSH
111972: LD_INT 17
111974: PUSH
111975: LD_INT 18
111977: PUSH
111978: LD_INT 19
111980: PUSH
111981: LD_INT 20
111983: PUSH
111984: LD_INT 21
111986: PUSH
111987: LD_INT 22
111989: PUSH
111990: LD_INT 23
111992: PUSH
111993: LD_INT 24
111995: PUSH
111996: LD_INT 25
111998: PUSH
111999: LD_INT 26
112001: PUSH
112002: LD_INT 27
112004: PUSH
112005: LD_INT 28
112007: PUSH
112008: LD_INT 30
112010: PUSH
112011: LD_INT 31
112013: PUSH
112014: LD_INT 32
112016: PUSH
112017: LD_INT 33
112019: PUSH
112020: LD_INT 34
112022: PUSH
112023: LD_INT 36
112025: PUSH
112026: EMPTY
112027: LIST
112028: LIST
112029: LIST
112030: LIST
112031: LIST
112032: LIST
112033: LIST
112034: LIST
112035: LIST
112036: LIST
112037: LIST
112038: LIST
112039: LIST
112040: LIST
112041: LIST
112042: LIST
112043: LIST
112044: LIST
112045: LIST
112046: LIST
112047: LIST
112048: LIST
112049: LIST
112050: LIST
112051: LIST
112052: LIST
112053: LIST
112054: LIST
112055: LIST
112056: LIST
112057: LIST
112058: PUSH
112059: LD_INT 101
112061: PUSH
112062: LD_INT 102
112064: PUSH
112065: LD_INT 103
112067: PUSH
112068: LD_INT 104
112070: PUSH
112071: LD_INT 105
112073: PUSH
112074: LD_INT 106
112076: PUSH
112077: LD_INT 107
112079: PUSH
112080: LD_INT 108
112082: PUSH
112083: LD_INT 109
112085: PUSH
112086: LD_INT 110
112088: PUSH
112089: LD_INT 111
112091: PUSH
112092: LD_INT 112
112094: PUSH
112095: LD_INT 113
112097: PUSH
112098: LD_INT 114
112100: PUSH
112101: LD_INT 116
112103: PUSH
112104: LD_INT 117
112106: PUSH
112107: LD_INT 118
112109: PUSH
112110: EMPTY
112111: LIST
112112: LIST
112113: LIST
112114: LIST
112115: LIST
112116: LIST
112117: LIST
112118: LIST
112119: LIST
112120: LIST
112121: LIST
112122: LIST
112123: LIST
112124: LIST
112125: LIST
112126: LIST
112127: LIST
112128: PUSH
112129: EMPTY
112130: LIST
112131: LIST
112132: ST_TO_ADDR
112133: GO 113372
112135: LD_INT 14
112137: DOUBLE
112138: EQUAL
112139: IFTRUE 112143
112141: GO 112367
112143: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
112144: LD_ADDR_VAR 0 2
112148: PUSH
112149: LD_INT 1
112151: PUSH
112152: LD_INT 2
112154: PUSH
112155: LD_INT 3
112157: PUSH
112158: LD_INT 4
112160: PUSH
112161: LD_INT 5
112163: PUSH
112164: LD_INT 6
112166: PUSH
112167: LD_INT 7
112169: PUSH
112170: LD_INT 8
112172: PUSH
112173: LD_INT 9
112175: PUSH
112176: LD_INT 10
112178: PUSH
112179: LD_INT 11
112181: PUSH
112182: LD_INT 12
112184: PUSH
112185: LD_INT 13
112187: PUSH
112188: LD_INT 14
112190: PUSH
112191: LD_INT 15
112193: PUSH
112194: LD_INT 16
112196: PUSH
112197: LD_INT 17
112199: PUSH
112200: LD_INT 18
112202: PUSH
112203: LD_INT 19
112205: PUSH
112206: LD_INT 20
112208: PUSH
112209: LD_INT 21
112211: PUSH
112212: LD_INT 22
112214: PUSH
112215: LD_INT 23
112217: PUSH
112218: LD_INT 24
112220: PUSH
112221: LD_INT 25
112223: PUSH
112224: LD_INT 26
112226: PUSH
112227: LD_INT 27
112229: PUSH
112230: LD_INT 28
112232: PUSH
112233: LD_INT 29
112235: PUSH
112236: LD_INT 30
112238: PUSH
112239: LD_INT 31
112241: PUSH
112242: LD_INT 32
112244: PUSH
112245: LD_INT 33
112247: PUSH
112248: LD_INT 34
112250: PUSH
112251: LD_INT 36
112253: PUSH
112254: EMPTY
112255: LIST
112256: LIST
112257: LIST
112258: LIST
112259: LIST
112260: LIST
112261: LIST
112262: LIST
112263: LIST
112264: LIST
112265: LIST
112266: LIST
112267: LIST
112268: LIST
112269: LIST
112270: LIST
112271: LIST
112272: LIST
112273: LIST
112274: LIST
112275: LIST
112276: LIST
112277: LIST
112278: LIST
112279: LIST
112280: LIST
112281: LIST
112282: LIST
112283: LIST
112284: LIST
112285: LIST
112286: LIST
112287: LIST
112288: LIST
112289: LIST
112290: PUSH
112291: LD_INT 101
112293: PUSH
112294: LD_INT 102
112296: PUSH
112297: LD_INT 103
112299: PUSH
112300: LD_INT 104
112302: PUSH
112303: LD_INT 105
112305: PUSH
112306: LD_INT 106
112308: PUSH
112309: LD_INT 107
112311: PUSH
112312: LD_INT 108
112314: PUSH
112315: LD_INT 109
112317: PUSH
112318: LD_INT 110
112320: PUSH
112321: LD_INT 111
112323: PUSH
112324: LD_INT 112
112326: PUSH
112327: LD_INT 113
112329: PUSH
112330: LD_INT 114
112332: PUSH
112333: LD_INT 116
112335: PUSH
112336: LD_INT 117
112338: PUSH
112339: LD_INT 118
112341: PUSH
112342: EMPTY
112343: LIST
112344: LIST
112345: LIST
112346: LIST
112347: LIST
112348: LIST
112349: LIST
112350: LIST
112351: LIST
112352: LIST
112353: LIST
112354: LIST
112355: LIST
112356: LIST
112357: LIST
112358: LIST
112359: LIST
112360: PUSH
112361: EMPTY
112362: LIST
112363: LIST
112364: ST_TO_ADDR
112365: GO 113372
112367: LD_INT 15
112369: DOUBLE
112370: EQUAL
112371: IFTRUE 112375
112373: GO 112599
112375: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
112376: LD_ADDR_VAR 0 2
112380: PUSH
112381: LD_INT 1
112383: PUSH
112384: LD_INT 2
112386: PUSH
112387: LD_INT 3
112389: PUSH
112390: LD_INT 4
112392: PUSH
112393: LD_INT 5
112395: PUSH
112396: LD_INT 6
112398: PUSH
112399: LD_INT 7
112401: PUSH
112402: LD_INT 8
112404: PUSH
112405: LD_INT 9
112407: PUSH
112408: LD_INT 10
112410: PUSH
112411: LD_INT 11
112413: PUSH
112414: LD_INT 12
112416: PUSH
112417: LD_INT 13
112419: PUSH
112420: LD_INT 14
112422: PUSH
112423: LD_INT 15
112425: PUSH
112426: LD_INT 16
112428: PUSH
112429: LD_INT 17
112431: PUSH
112432: LD_INT 18
112434: PUSH
112435: LD_INT 19
112437: PUSH
112438: LD_INT 20
112440: PUSH
112441: LD_INT 21
112443: PUSH
112444: LD_INT 22
112446: PUSH
112447: LD_INT 23
112449: PUSH
112450: LD_INT 24
112452: PUSH
112453: LD_INT 25
112455: PUSH
112456: LD_INT 26
112458: PUSH
112459: LD_INT 27
112461: PUSH
112462: LD_INT 28
112464: PUSH
112465: LD_INT 29
112467: PUSH
112468: LD_INT 30
112470: PUSH
112471: LD_INT 31
112473: PUSH
112474: LD_INT 32
112476: PUSH
112477: LD_INT 33
112479: PUSH
112480: LD_INT 34
112482: PUSH
112483: LD_INT 36
112485: PUSH
112486: EMPTY
112487: LIST
112488: LIST
112489: LIST
112490: LIST
112491: LIST
112492: LIST
112493: LIST
112494: LIST
112495: LIST
112496: LIST
112497: LIST
112498: LIST
112499: LIST
112500: LIST
112501: LIST
112502: LIST
112503: LIST
112504: LIST
112505: LIST
112506: LIST
112507: LIST
112508: LIST
112509: LIST
112510: LIST
112511: LIST
112512: LIST
112513: LIST
112514: LIST
112515: LIST
112516: LIST
112517: LIST
112518: LIST
112519: LIST
112520: LIST
112521: LIST
112522: PUSH
112523: LD_INT 101
112525: PUSH
112526: LD_INT 102
112528: PUSH
112529: LD_INT 103
112531: PUSH
112532: LD_INT 104
112534: PUSH
112535: LD_INT 105
112537: PUSH
112538: LD_INT 106
112540: PUSH
112541: LD_INT 107
112543: PUSH
112544: LD_INT 108
112546: PUSH
112547: LD_INT 109
112549: PUSH
112550: LD_INT 110
112552: PUSH
112553: LD_INT 111
112555: PUSH
112556: LD_INT 112
112558: PUSH
112559: LD_INT 113
112561: PUSH
112562: LD_INT 114
112564: PUSH
112565: LD_INT 116
112567: PUSH
112568: LD_INT 117
112570: PUSH
112571: LD_INT 118
112573: PUSH
112574: EMPTY
112575: LIST
112576: LIST
112577: LIST
112578: LIST
112579: LIST
112580: LIST
112581: LIST
112582: LIST
112583: LIST
112584: LIST
112585: LIST
112586: LIST
112587: LIST
112588: LIST
112589: LIST
112590: LIST
112591: LIST
112592: PUSH
112593: EMPTY
112594: LIST
112595: LIST
112596: ST_TO_ADDR
112597: GO 113372
112599: LD_INT 16
112601: DOUBLE
112602: EQUAL
112603: IFTRUE 112607
112605: GO 112743
112607: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
112608: LD_ADDR_VAR 0 2
112612: PUSH
112613: LD_INT 2
112615: PUSH
112616: LD_INT 4
112618: PUSH
112619: LD_INT 5
112621: PUSH
112622: LD_INT 7
112624: PUSH
112625: LD_INT 11
112627: PUSH
112628: LD_INT 12
112630: PUSH
112631: LD_INT 15
112633: PUSH
112634: LD_INT 16
112636: PUSH
112637: LD_INT 20
112639: PUSH
112640: LD_INT 21
112642: PUSH
112643: LD_INT 22
112645: PUSH
112646: LD_INT 23
112648: PUSH
112649: LD_INT 25
112651: PUSH
112652: LD_INT 26
112654: PUSH
112655: LD_INT 30
112657: PUSH
112658: LD_INT 31
112660: PUSH
112661: LD_INT 32
112663: PUSH
112664: LD_INT 33
112666: PUSH
112667: LD_INT 34
112669: PUSH
112670: EMPTY
112671: LIST
112672: LIST
112673: LIST
112674: LIST
112675: LIST
112676: LIST
112677: LIST
112678: LIST
112679: LIST
112680: LIST
112681: LIST
112682: LIST
112683: LIST
112684: LIST
112685: LIST
112686: LIST
112687: LIST
112688: LIST
112689: LIST
112690: PUSH
112691: LD_INT 101
112693: PUSH
112694: LD_INT 102
112696: PUSH
112697: LD_INT 103
112699: PUSH
112700: LD_INT 106
112702: PUSH
112703: LD_INT 108
112705: PUSH
112706: LD_INT 112
112708: PUSH
112709: LD_INT 113
112711: PUSH
112712: LD_INT 114
112714: PUSH
112715: LD_INT 116
112717: PUSH
112718: LD_INT 117
112720: PUSH
112721: LD_INT 118
112723: PUSH
112724: EMPTY
112725: LIST
112726: LIST
112727: LIST
112728: LIST
112729: LIST
112730: LIST
112731: LIST
112732: LIST
112733: LIST
112734: LIST
112735: LIST
112736: PUSH
112737: EMPTY
112738: LIST
112739: LIST
112740: ST_TO_ADDR
112741: GO 113372
112743: LD_INT 17
112745: DOUBLE
112746: EQUAL
112747: IFTRUE 112751
112749: GO 112975
112751: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
112752: LD_ADDR_VAR 0 2
112756: PUSH
112757: LD_INT 1
112759: PUSH
112760: LD_INT 2
112762: PUSH
112763: LD_INT 3
112765: PUSH
112766: LD_INT 4
112768: PUSH
112769: LD_INT 5
112771: PUSH
112772: LD_INT 6
112774: PUSH
112775: LD_INT 7
112777: PUSH
112778: LD_INT 8
112780: PUSH
112781: LD_INT 9
112783: PUSH
112784: LD_INT 10
112786: PUSH
112787: LD_INT 11
112789: PUSH
112790: LD_INT 12
112792: PUSH
112793: LD_INT 13
112795: PUSH
112796: LD_INT 14
112798: PUSH
112799: LD_INT 15
112801: PUSH
112802: LD_INT 16
112804: PUSH
112805: LD_INT 17
112807: PUSH
112808: LD_INT 18
112810: PUSH
112811: LD_INT 19
112813: PUSH
112814: LD_INT 20
112816: PUSH
112817: LD_INT 21
112819: PUSH
112820: LD_INT 22
112822: PUSH
112823: LD_INT 23
112825: PUSH
112826: LD_INT 24
112828: PUSH
112829: LD_INT 25
112831: PUSH
112832: LD_INT 26
112834: PUSH
112835: LD_INT 27
112837: PUSH
112838: LD_INT 28
112840: PUSH
112841: LD_INT 29
112843: PUSH
112844: LD_INT 30
112846: PUSH
112847: LD_INT 31
112849: PUSH
112850: LD_INT 32
112852: PUSH
112853: LD_INT 33
112855: PUSH
112856: LD_INT 34
112858: PUSH
112859: LD_INT 36
112861: PUSH
112862: EMPTY
112863: LIST
112864: LIST
112865: LIST
112866: LIST
112867: LIST
112868: LIST
112869: LIST
112870: LIST
112871: LIST
112872: LIST
112873: LIST
112874: LIST
112875: LIST
112876: LIST
112877: LIST
112878: LIST
112879: LIST
112880: LIST
112881: LIST
112882: LIST
112883: LIST
112884: LIST
112885: LIST
112886: LIST
112887: LIST
112888: LIST
112889: LIST
112890: LIST
112891: LIST
112892: LIST
112893: LIST
112894: LIST
112895: LIST
112896: LIST
112897: LIST
112898: PUSH
112899: LD_INT 101
112901: PUSH
112902: LD_INT 102
112904: PUSH
112905: LD_INT 103
112907: PUSH
112908: LD_INT 104
112910: PUSH
112911: LD_INT 105
112913: PUSH
112914: LD_INT 106
112916: PUSH
112917: LD_INT 107
112919: PUSH
112920: LD_INT 108
112922: PUSH
112923: LD_INT 109
112925: PUSH
112926: LD_INT 110
112928: PUSH
112929: LD_INT 111
112931: PUSH
112932: LD_INT 112
112934: PUSH
112935: LD_INT 113
112937: PUSH
112938: LD_INT 114
112940: PUSH
112941: LD_INT 116
112943: PUSH
112944: LD_INT 117
112946: PUSH
112947: LD_INT 118
112949: PUSH
112950: EMPTY
112951: LIST
112952: LIST
112953: LIST
112954: LIST
112955: LIST
112956: LIST
112957: LIST
112958: LIST
112959: LIST
112960: LIST
112961: LIST
112962: LIST
112963: LIST
112964: LIST
112965: LIST
112966: LIST
112967: LIST
112968: PUSH
112969: EMPTY
112970: LIST
112971: LIST
112972: ST_TO_ADDR
112973: GO 113372
112975: LD_INT 18
112977: DOUBLE
112978: EQUAL
112979: IFTRUE 112983
112981: GO 113131
112983: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
112984: LD_ADDR_VAR 0 2
112988: PUSH
112989: LD_INT 2
112991: PUSH
112992: LD_INT 4
112994: PUSH
112995: LD_INT 5
112997: PUSH
112998: LD_INT 7
113000: PUSH
113001: LD_INT 11
113003: PUSH
113004: LD_INT 12
113006: PUSH
113007: LD_INT 15
113009: PUSH
113010: LD_INT 16
113012: PUSH
113013: LD_INT 20
113015: PUSH
113016: LD_INT 21
113018: PUSH
113019: LD_INT 22
113021: PUSH
113022: LD_INT 23
113024: PUSH
113025: LD_INT 25
113027: PUSH
113028: LD_INT 26
113030: PUSH
113031: LD_INT 30
113033: PUSH
113034: LD_INT 31
113036: PUSH
113037: LD_INT 32
113039: PUSH
113040: LD_INT 33
113042: PUSH
113043: LD_INT 34
113045: PUSH
113046: LD_INT 35
113048: PUSH
113049: LD_INT 36
113051: PUSH
113052: EMPTY
113053: LIST
113054: LIST
113055: LIST
113056: LIST
113057: LIST
113058: LIST
113059: LIST
113060: LIST
113061: LIST
113062: LIST
113063: LIST
113064: LIST
113065: LIST
113066: LIST
113067: LIST
113068: LIST
113069: LIST
113070: LIST
113071: LIST
113072: LIST
113073: LIST
113074: PUSH
113075: LD_INT 101
113077: PUSH
113078: LD_INT 102
113080: PUSH
113081: LD_INT 103
113083: PUSH
113084: LD_INT 106
113086: PUSH
113087: LD_INT 108
113089: PUSH
113090: LD_INT 112
113092: PUSH
113093: LD_INT 113
113095: PUSH
113096: LD_INT 114
113098: PUSH
113099: LD_INT 115
113101: PUSH
113102: LD_INT 116
113104: PUSH
113105: LD_INT 117
113107: PUSH
113108: LD_INT 118
113110: PUSH
113111: EMPTY
113112: LIST
113113: LIST
113114: LIST
113115: LIST
113116: LIST
113117: LIST
113118: LIST
113119: LIST
113120: LIST
113121: LIST
113122: LIST
113123: LIST
113124: PUSH
113125: EMPTY
113126: LIST
113127: LIST
113128: ST_TO_ADDR
113129: GO 113372
113131: LD_INT 19
113133: DOUBLE
113134: EQUAL
113135: IFTRUE 113139
113137: GO 113371
113139: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
113140: LD_ADDR_VAR 0 2
113144: PUSH
113145: LD_INT 1
113147: PUSH
113148: LD_INT 2
113150: PUSH
113151: LD_INT 3
113153: PUSH
113154: LD_INT 4
113156: PUSH
113157: LD_INT 5
113159: PUSH
113160: LD_INT 6
113162: PUSH
113163: LD_INT 7
113165: PUSH
113166: LD_INT 8
113168: PUSH
113169: LD_INT 9
113171: PUSH
113172: LD_INT 10
113174: PUSH
113175: LD_INT 11
113177: PUSH
113178: LD_INT 12
113180: PUSH
113181: LD_INT 13
113183: PUSH
113184: LD_INT 14
113186: PUSH
113187: LD_INT 15
113189: PUSH
113190: LD_INT 16
113192: PUSH
113193: LD_INT 17
113195: PUSH
113196: LD_INT 18
113198: PUSH
113199: LD_INT 19
113201: PUSH
113202: LD_INT 20
113204: PUSH
113205: LD_INT 21
113207: PUSH
113208: LD_INT 22
113210: PUSH
113211: LD_INT 23
113213: PUSH
113214: LD_INT 24
113216: PUSH
113217: LD_INT 25
113219: PUSH
113220: LD_INT 26
113222: PUSH
113223: LD_INT 27
113225: PUSH
113226: LD_INT 28
113228: PUSH
113229: LD_INT 29
113231: PUSH
113232: LD_INT 30
113234: PUSH
113235: LD_INT 31
113237: PUSH
113238: LD_INT 32
113240: PUSH
113241: LD_INT 33
113243: PUSH
113244: LD_INT 34
113246: PUSH
113247: LD_INT 35
113249: PUSH
113250: LD_INT 36
113252: PUSH
113253: EMPTY
113254: LIST
113255: LIST
113256: LIST
113257: LIST
113258: LIST
113259: LIST
113260: LIST
113261: LIST
113262: LIST
113263: LIST
113264: LIST
113265: LIST
113266: LIST
113267: LIST
113268: LIST
113269: LIST
113270: LIST
113271: LIST
113272: LIST
113273: LIST
113274: LIST
113275: LIST
113276: LIST
113277: LIST
113278: LIST
113279: LIST
113280: LIST
113281: LIST
113282: LIST
113283: LIST
113284: LIST
113285: LIST
113286: LIST
113287: LIST
113288: LIST
113289: LIST
113290: PUSH
113291: LD_INT 101
113293: PUSH
113294: LD_INT 102
113296: PUSH
113297: LD_INT 103
113299: PUSH
113300: LD_INT 104
113302: PUSH
113303: LD_INT 105
113305: PUSH
113306: LD_INT 106
113308: PUSH
113309: LD_INT 107
113311: PUSH
113312: LD_INT 108
113314: PUSH
113315: LD_INT 109
113317: PUSH
113318: LD_INT 110
113320: PUSH
113321: LD_INT 111
113323: PUSH
113324: LD_INT 112
113326: PUSH
113327: LD_INT 113
113329: PUSH
113330: LD_INT 114
113332: PUSH
113333: LD_INT 115
113335: PUSH
113336: LD_INT 116
113338: PUSH
113339: LD_INT 117
113341: PUSH
113342: LD_INT 118
113344: PUSH
113345: EMPTY
113346: LIST
113347: LIST
113348: LIST
113349: LIST
113350: LIST
113351: LIST
113352: LIST
113353: LIST
113354: LIST
113355: LIST
113356: LIST
113357: LIST
113358: LIST
113359: LIST
113360: LIST
113361: LIST
113362: LIST
113363: LIST
113364: PUSH
113365: EMPTY
113366: LIST
113367: LIST
113368: ST_TO_ADDR
113369: GO 113372
113371: POP
// end else
113372: GO 113603
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
113374: LD_ADDR_VAR 0 2
113378: PUSH
113379: LD_INT 1
113381: PUSH
113382: LD_INT 2
113384: PUSH
113385: LD_INT 3
113387: PUSH
113388: LD_INT 4
113390: PUSH
113391: LD_INT 5
113393: PUSH
113394: LD_INT 6
113396: PUSH
113397: LD_INT 7
113399: PUSH
113400: LD_INT 8
113402: PUSH
113403: LD_INT 9
113405: PUSH
113406: LD_INT 10
113408: PUSH
113409: LD_INT 11
113411: PUSH
113412: LD_INT 12
113414: PUSH
113415: LD_INT 13
113417: PUSH
113418: LD_INT 14
113420: PUSH
113421: LD_INT 15
113423: PUSH
113424: LD_INT 16
113426: PUSH
113427: LD_INT 17
113429: PUSH
113430: LD_INT 18
113432: PUSH
113433: LD_INT 19
113435: PUSH
113436: LD_INT 20
113438: PUSH
113439: LD_INT 21
113441: PUSH
113442: LD_INT 22
113444: PUSH
113445: LD_INT 23
113447: PUSH
113448: LD_INT 24
113450: PUSH
113451: LD_INT 25
113453: PUSH
113454: LD_INT 26
113456: PUSH
113457: LD_INT 27
113459: PUSH
113460: LD_INT 28
113462: PUSH
113463: LD_INT 29
113465: PUSH
113466: LD_INT 30
113468: PUSH
113469: LD_INT 31
113471: PUSH
113472: LD_INT 32
113474: PUSH
113475: LD_INT 33
113477: PUSH
113478: LD_INT 34
113480: PUSH
113481: LD_INT 35
113483: PUSH
113484: LD_INT 36
113486: PUSH
113487: EMPTY
113488: LIST
113489: LIST
113490: LIST
113491: LIST
113492: LIST
113493: LIST
113494: LIST
113495: LIST
113496: LIST
113497: LIST
113498: LIST
113499: LIST
113500: LIST
113501: LIST
113502: LIST
113503: LIST
113504: LIST
113505: LIST
113506: LIST
113507: LIST
113508: LIST
113509: LIST
113510: LIST
113511: LIST
113512: LIST
113513: LIST
113514: LIST
113515: LIST
113516: LIST
113517: LIST
113518: LIST
113519: LIST
113520: LIST
113521: LIST
113522: LIST
113523: LIST
113524: PUSH
113525: LD_INT 101
113527: PUSH
113528: LD_INT 102
113530: PUSH
113531: LD_INT 103
113533: PUSH
113534: LD_INT 104
113536: PUSH
113537: LD_INT 105
113539: PUSH
113540: LD_INT 106
113542: PUSH
113543: LD_INT 107
113545: PUSH
113546: LD_INT 108
113548: PUSH
113549: LD_INT 109
113551: PUSH
113552: LD_INT 110
113554: PUSH
113555: LD_INT 111
113557: PUSH
113558: LD_INT 112
113560: PUSH
113561: LD_INT 113
113563: PUSH
113564: LD_INT 114
113566: PUSH
113567: LD_INT 115
113569: PUSH
113570: LD_INT 116
113572: PUSH
113573: LD_INT 117
113575: PUSH
113576: LD_INT 118
113578: PUSH
113579: EMPTY
113580: LIST
113581: LIST
113582: LIST
113583: LIST
113584: LIST
113585: LIST
113586: LIST
113587: LIST
113588: LIST
113589: LIST
113590: LIST
113591: LIST
113592: LIST
113593: LIST
113594: LIST
113595: LIST
113596: LIST
113597: LIST
113598: PUSH
113599: EMPTY
113600: LIST
113601: LIST
113602: ST_TO_ADDR
// if result then
113603: LD_VAR 0 2
113607: IFFALSE 114393
// begin normal :=  ;
113609: LD_ADDR_VAR 0 5
113613: PUSH
113614: LD_STRING 
113616: ST_TO_ADDR
// hardcore :=  ;
113617: LD_ADDR_VAR 0 6
113621: PUSH
113622: LD_STRING 
113624: ST_TO_ADDR
// active :=  ;
113625: LD_ADDR_VAR 0 7
113629: PUSH
113630: LD_STRING 
113632: ST_TO_ADDR
// for i = 1 to normalCounter do
113633: LD_ADDR_VAR 0 8
113637: PUSH
113638: DOUBLE
113639: LD_INT 1
113641: DEC
113642: ST_TO_ADDR
113643: LD_EXP 144
113647: PUSH
113648: FOR_TO
113649: IFFALSE 113750
// begin tmp := 0 ;
113651: LD_ADDR_VAR 0 3
113655: PUSH
113656: LD_STRING 0
113658: ST_TO_ADDR
// if result [ 1 ] then
113659: LD_VAR 0 2
113663: PUSH
113664: LD_INT 1
113666: ARRAY
113667: IFFALSE 113732
// if result [ 1 ] [ 1 ] = i then
113669: LD_VAR 0 2
113673: PUSH
113674: LD_INT 1
113676: ARRAY
113677: PUSH
113678: LD_INT 1
113680: ARRAY
113681: PUSH
113682: LD_VAR 0 8
113686: EQUAL
113687: IFFALSE 113732
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
113689: LD_ADDR_VAR 0 2
113693: PUSH
113694: LD_VAR 0 2
113698: PPUSH
113699: LD_INT 1
113701: PPUSH
113702: LD_VAR 0 2
113706: PUSH
113707: LD_INT 1
113709: ARRAY
113710: PPUSH
113711: LD_INT 1
113713: PPUSH
113714: CALL_OW 3
113718: PPUSH
113719: CALL_OW 1
113723: ST_TO_ADDR
// tmp := 1 ;
113724: LD_ADDR_VAR 0 3
113728: PUSH
113729: LD_STRING 1
113731: ST_TO_ADDR
// end ; normal := normal & tmp ;
113732: LD_ADDR_VAR 0 5
113736: PUSH
113737: LD_VAR 0 5
113741: PUSH
113742: LD_VAR 0 3
113746: STR
113747: ST_TO_ADDR
// end ;
113748: GO 113648
113750: POP
113751: POP
// for i = 1 to hardcoreCounter do
113752: LD_ADDR_VAR 0 8
113756: PUSH
113757: DOUBLE
113758: LD_INT 1
113760: DEC
113761: ST_TO_ADDR
113762: LD_EXP 145
113766: PUSH
113767: FOR_TO
113768: IFFALSE 113873
// begin tmp := 0 ;
113770: LD_ADDR_VAR 0 3
113774: PUSH
113775: LD_STRING 0
113777: ST_TO_ADDR
// if result [ 2 ] then
113778: LD_VAR 0 2
113782: PUSH
113783: LD_INT 2
113785: ARRAY
113786: IFFALSE 113855
// if result [ 2 ] [ 1 ] = 100 + i then
113788: LD_VAR 0 2
113792: PUSH
113793: LD_INT 2
113795: ARRAY
113796: PUSH
113797: LD_INT 1
113799: ARRAY
113800: PUSH
113801: LD_INT 100
113803: PUSH
113804: LD_VAR 0 8
113808: PLUS
113809: EQUAL
113810: IFFALSE 113855
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
113812: LD_ADDR_VAR 0 2
113816: PUSH
113817: LD_VAR 0 2
113821: PPUSH
113822: LD_INT 2
113824: PPUSH
113825: LD_VAR 0 2
113829: PUSH
113830: LD_INT 2
113832: ARRAY
113833: PPUSH
113834: LD_INT 1
113836: PPUSH
113837: CALL_OW 3
113841: PPUSH
113842: CALL_OW 1
113846: ST_TO_ADDR
// tmp := 1 ;
113847: LD_ADDR_VAR 0 3
113851: PUSH
113852: LD_STRING 1
113854: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
113855: LD_ADDR_VAR 0 6
113859: PUSH
113860: LD_VAR 0 6
113864: PUSH
113865: LD_VAR 0 3
113869: STR
113870: ST_TO_ADDR
// end ;
113871: GO 113767
113873: POP
113874: POP
// if isGameLoad then
113875: LD_VAR 0 1
113879: IFFALSE 114354
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
113881: LD_ADDR_VAR 0 4
113885: PUSH
113886: LD_EXP 148
113890: PUSH
113891: LD_EXP 147
113895: PUSH
113896: LD_EXP 149
113900: PUSH
113901: LD_EXP 146
113905: PUSH
113906: LD_EXP 150
113910: PUSH
113911: LD_EXP 151
113915: PUSH
113916: LD_EXP 152
113920: PUSH
113921: LD_EXP 153
113925: PUSH
113926: LD_EXP 154
113930: PUSH
113931: LD_EXP 155
113935: PUSH
113936: LD_EXP 156
113940: PUSH
113941: LD_EXP 157
113945: PUSH
113946: LD_EXP 158
113950: PUSH
113951: LD_EXP 159
113955: PUSH
113956: LD_EXP 167
113960: PUSH
113961: LD_EXP 168
113965: PUSH
113966: LD_EXP 169
113970: PUSH
113971: LD_EXP 170
113975: PUSH
113976: LD_EXP 172
113980: PUSH
113981: LD_EXP 173
113985: PUSH
113986: LD_EXP 174
113990: PUSH
113991: LD_EXP 177
113995: PUSH
113996: LD_EXP 179
114000: PUSH
114001: LD_EXP 180
114005: PUSH
114006: LD_EXP 181
114010: PUSH
114011: LD_EXP 183
114015: PUSH
114016: LD_EXP 184
114020: PUSH
114021: LD_EXP 187
114025: PUSH
114026: LD_EXP 188
114030: PUSH
114031: LD_EXP 189
114035: PUSH
114036: LD_EXP 190
114040: PUSH
114041: LD_EXP 191
114045: PUSH
114046: LD_EXP 192
114050: PUSH
114051: LD_EXP 193
114055: PUSH
114056: LD_EXP 194
114060: PUSH
114061: LD_EXP 195
114065: PUSH
114066: LD_EXP 160
114070: PUSH
114071: LD_EXP 161
114075: PUSH
114076: LD_EXP 164
114080: PUSH
114081: LD_EXP 165
114085: PUSH
114086: LD_EXP 166
114090: PUSH
114091: LD_EXP 162
114095: PUSH
114096: LD_EXP 163
114100: PUSH
114101: LD_EXP 171
114105: PUSH
114106: LD_EXP 175
114110: PUSH
114111: LD_EXP 176
114115: PUSH
114116: LD_EXP 178
114120: PUSH
114121: LD_EXP 182
114125: PUSH
114126: LD_EXP 185
114130: PUSH
114131: LD_EXP 186
114135: PUSH
114136: LD_EXP 196
114140: PUSH
114141: LD_EXP 197
114145: PUSH
114146: LD_EXP 198
114150: PUSH
114151: LD_EXP 199
114155: PUSH
114156: EMPTY
114157: LIST
114158: LIST
114159: LIST
114160: LIST
114161: LIST
114162: LIST
114163: LIST
114164: LIST
114165: LIST
114166: LIST
114167: LIST
114168: LIST
114169: LIST
114170: LIST
114171: LIST
114172: LIST
114173: LIST
114174: LIST
114175: LIST
114176: LIST
114177: LIST
114178: LIST
114179: LIST
114180: LIST
114181: LIST
114182: LIST
114183: LIST
114184: LIST
114185: LIST
114186: LIST
114187: LIST
114188: LIST
114189: LIST
114190: LIST
114191: LIST
114192: LIST
114193: LIST
114194: LIST
114195: LIST
114196: LIST
114197: LIST
114198: LIST
114199: LIST
114200: LIST
114201: LIST
114202: LIST
114203: LIST
114204: LIST
114205: LIST
114206: LIST
114207: LIST
114208: LIST
114209: LIST
114210: LIST
114211: ST_TO_ADDR
// tmp :=  ;
114212: LD_ADDR_VAR 0 3
114216: PUSH
114217: LD_STRING 
114219: ST_TO_ADDR
// for i = 1 to normalCounter do
114220: LD_ADDR_VAR 0 8
114224: PUSH
114225: DOUBLE
114226: LD_INT 1
114228: DEC
114229: ST_TO_ADDR
114230: LD_EXP 144
114234: PUSH
114235: FOR_TO
114236: IFFALSE 114272
// begin if flags [ i ] then
114238: LD_VAR 0 4
114242: PUSH
114243: LD_VAR 0 8
114247: ARRAY
114248: IFFALSE 114270
// tmp := tmp & i & ; ;
114250: LD_ADDR_VAR 0 3
114254: PUSH
114255: LD_VAR 0 3
114259: PUSH
114260: LD_VAR 0 8
114264: STR
114265: PUSH
114266: LD_STRING ;
114268: STR
114269: ST_TO_ADDR
// end ;
114270: GO 114235
114272: POP
114273: POP
// for i = 1 to hardcoreCounter do
114274: LD_ADDR_VAR 0 8
114278: PUSH
114279: DOUBLE
114280: LD_INT 1
114282: DEC
114283: ST_TO_ADDR
114284: LD_EXP 145
114288: PUSH
114289: FOR_TO
114290: IFFALSE 114336
// begin if flags [ normalCounter + i ] then
114292: LD_VAR 0 4
114296: PUSH
114297: LD_EXP 144
114301: PUSH
114302: LD_VAR 0 8
114306: PLUS
114307: ARRAY
114308: IFFALSE 114334
// tmp := tmp & ( 100 + i ) & ; ;
114310: LD_ADDR_VAR 0 3
114314: PUSH
114315: LD_VAR 0 3
114319: PUSH
114320: LD_INT 100
114322: PUSH
114323: LD_VAR 0 8
114327: PLUS
114328: STR
114329: PUSH
114330: LD_STRING ;
114332: STR
114333: ST_TO_ADDR
// end ;
114334: GO 114289
114336: POP
114337: POP
// if tmp then
114338: LD_VAR 0 3
114342: IFFALSE 114354
// active := tmp ;
114344: LD_ADDR_VAR 0 7
114348: PUSH
114349: LD_VAR 0 3
114353: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
114354: LD_STRING getStreamItemsFromMission("
114356: PUSH
114357: LD_VAR 0 5
114361: STR
114362: PUSH
114363: LD_STRING ","
114365: STR
114366: PUSH
114367: LD_VAR 0 6
114371: STR
114372: PUSH
114373: LD_STRING ","
114375: STR
114376: PUSH
114377: LD_VAR 0 7
114381: STR
114382: PUSH
114383: LD_STRING ")
114385: STR
114386: PPUSH
114387: CALL_OW 559
// end else
114391: GO 114400
// ToLua ( getStreamItemsFromMission("","","") ) ;
114393: LD_STRING getStreamItemsFromMission("","","")
114395: PPUSH
114396: CALL_OW 559
// end ;
114400: LD_VAR 0 2
114404: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
114405: LD_EXP 143
114409: PUSH
114410: LD_EXP 148
114414: AND
114415: IFFALSE 114539
114417: GO 114419
114419: DISABLE
114420: LD_INT 0
114422: PPUSH
114423: PPUSH
// begin enable ;
114424: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
114425: LD_ADDR_VAR 0 2
114429: PUSH
114430: LD_INT 22
114432: PUSH
114433: LD_OWVAR 2
114437: PUSH
114438: EMPTY
114439: LIST
114440: LIST
114441: PUSH
114442: LD_INT 2
114444: PUSH
114445: LD_INT 34
114447: PUSH
114448: LD_INT 7
114450: PUSH
114451: EMPTY
114452: LIST
114453: LIST
114454: PUSH
114455: LD_INT 34
114457: PUSH
114458: LD_INT 45
114460: PUSH
114461: EMPTY
114462: LIST
114463: LIST
114464: PUSH
114465: LD_INT 34
114467: PUSH
114468: LD_INT 28
114470: PUSH
114471: EMPTY
114472: LIST
114473: LIST
114474: PUSH
114475: LD_INT 34
114477: PUSH
114478: LD_INT 47
114480: PUSH
114481: EMPTY
114482: LIST
114483: LIST
114484: PUSH
114485: EMPTY
114486: LIST
114487: LIST
114488: LIST
114489: LIST
114490: LIST
114491: PUSH
114492: EMPTY
114493: LIST
114494: LIST
114495: PPUSH
114496: CALL_OW 69
114500: ST_TO_ADDR
// if not tmp then
114501: LD_VAR 0 2
114505: NOT
114506: IFFALSE 114510
// exit ;
114508: GO 114539
// for i in tmp do
114510: LD_ADDR_VAR 0 1
114514: PUSH
114515: LD_VAR 0 2
114519: PUSH
114520: FOR_IN
114521: IFFALSE 114537
// begin SetLives ( i , 0 ) ;
114523: LD_VAR 0 1
114527: PPUSH
114528: LD_INT 0
114530: PPUSH
114531: CALL_OW 234
// end ;
114535: GO 114520
114537: POP
114538: POP
// end ;
114539: PPOPN 2
114541: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
114542: LD_EXP 143
114546: PUSH
114547: LD_EXP 149
114551: AND
114552: IFFALSE 114636
114554: GO 114556
114556: DISABLE
114557: LD_INT 0
114559: PPUSH
114560: PPUSH
// begin enable ;
114561: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
114562: LD_ADDR_VAR 0 2
114566: PUSH
114567: LD_INT 22
114569: PUSH
114570: LD_OWVAR 2
114574: PUSH
114575: EMPTY
114576: LIST
114577: LIST
114578: PUSH
114579: LD_INT 32
114581: PUSH
114582: LD_INT 3
114584: PUSH
114585: EMPTY
114586: LIST
114587: LIST
114588: PUSH
114589: EMPTY
114590: LIST
114591: LIST
114592: PPUSH
114593: CALL_OW 69
114597: ST_TO_ADDR
// if not tmp then
114598: LD_VAR 0 2
114602: NOT
114603: IFFALSE 114607
// exit ;
114605: GO 114636
// for i in tmp do
114607: LD_ADDR_VAR 0 1
114611: PUSH
114612: LD_VAR 0 2
114616: PUSH
114617: FOR_IN
114618: IFFALSE 114634
// begin SetLives ( i , 0 ) ;
114620: LD_VAR 0 1
114624: PPUSH
114625: LD_INT 0
114627: PPUSH
114628: CALL_OW 234
// end ;
114632: GO 114617
114634: POP
114635: POP
// end ;
114636: PPOPN 2
114638: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
114639: LD_EXP 143
114643: PUSH
114644: LD_EXP 146
114648: AND
114649: IFFALSE 114742
114651: GO 114653
114653: DISABLE
114654: LD_INT 0
114656: PPUSH
// begin enable ;
114657: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
114658: LD_ADDR_VAR 0 1
114662: PUSH
114663: LD_INT 22
114665: PUSH
114666: LD_OWVAR 2
114670: PUSH
114671: EMPTY
114672: LIST
114673: LIST
114674: PUSH
114675: LD_INT 2
114677: PUSH
114678: LD_INT 25
114680: PUSH
114681: LD_INT 5
114683: PUSH
114684: EMPTY
114685: LIST
114686: LIST
114687: PUSH
114688: LD_INT 25
114690: PUSH
114691: LD_INT 9
114693: PUSH
114694: EMPTY
114695: LIST
114696: LIST
114697: PUSH
114698: LD_INT 25
114700: PUSH
114701: LD_INT 8
114703: PUSH
114704: EMPTY
114705: LIST
114706: LIST
114707: PUSH
114708: EMPTY
114709: LIST
114710: LIST
114711: LIST
114712: LIST
114713: PUSH
114714: EMPTY
114715: LIST
114716: LIST
114717: PPUSH
114718: CALL_OW 69
114722: PUSH
114723: FOR_IN
114724: IFFALSE 114740
// begin SetClass ( i , 1 ) ;
114726: LD_VAR 0 1
114730: PPUSH
114731: LD_INT 1
114733: PPUSH
114734: CALL_OW 336
// end ;
114738: GO 114723
114740: POP
114741: POP
// end ;
114742: PPOPN 1
114744: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
114745: LD_EXP 143
114749: PUSH
114750: LD_EXP 147
114754: AND
114755: PUSH
114756: LD_OWVAR 65
114760: PUSH
114761: LD_INT 7
114763: LESS
114764: AND
114765: IFFALSE 114779
114767: GO 114769
114769: DISABLE
// begin enable ;
114770: ENABLE
// game_speed := 7 ;
114771: LD_ADDR_OWVAR 65
114775: PUSH
114776: LD_INT 7
114778: ST_TO_ADDR
// end ;
114779: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
114780: LD_EXP 143
114784: PUSH
114785: LD_EXP 150
114789: AND
114790: IFFALSE 114992
114792: GO 114794
114794: DISABLE
114795: LD_INT 0
114797: PPUSH
114798: PPUSH
114799: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
114800: LD_ADDR_VAR 0 3
114804: PUSH
114805: LD_INT 81
114807: PUSH
114808: LD_OWVAR 2
114812: PUSH
114813: EMPTY
114814: LIST
114815: LIST
114816: PUSH
114817: LD_INT 21
114819: PUSH
114820: LD_INT 1
114822: PUSH
114823: EMPTY
114824: LIST
114825: LIST
114826: PUSH
114827: EMPTY
114828: LIST
114829: LIST
114830: PPUSH
114831: CALL_OW 69
114835: ST_TO_ADDR
// if not tmp then
114836: LD_VAR 0 3
114840: NOT
114841: IFFALSE 114845
// exit ;
114843: GO 114992
// if tmp > 5 then
114845: LD_VAR 0 3
114849: PUSH
114850: LD_INT 5
114852: GREATER
114853: IFFALSE 114865
// k := 5 else
114855: LD_ADDR_VAR 0 2
114859: PUSH
114860: LD_INT 5
114862: ST_TO_ADDR
114863: GO 114875
// k := tmp ;
114865: LD_ADDR_VAR 0 2
114869: PUSH
114870: LD_VAR 0 3
114874: ST_TO_ADDR
// for i := 1 to k do
114875: LD_ADDR_VAR 0 1
114879: PUSH
114880: DOUBLE
114881: LD_INT 1
114883: DEC
114884: ST_TO_ADDR
114885: LD_VAR 0 2
114889: PUSH
114890: FOR_TO
114891: IFFALSE 114990
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
114893: LD_VAR 0 3
114897: PUSH
114898: LD_VAR 0 1
114902: ARRAY
114903: PPUSH
114904: LD_VAR 0 1
114908: PUSH
114909: LD_INT 4
114911: MOD
114912: PUSH
114913: LD_INT 1
114915: PLUS
114916: PPUSH
114917: CALL_OW 259
114921: PUSH
114922: LD_INT 10
114924: LESS
114925: IFFALSE 114988
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
114927: LD_VAR 0 3
114931: PUSH
114932: LD_VAR 0 1
114936: ARRAY
114937: PPUSH
114938: LD_VAR 0 1
114942: PUSH
114943: LD_INT 4
114945: MOD
114946: PUSH
114947: LD_INT 1
114949: PLUS
114950: PPUSH
114951: LD_VAR 0 3
114955: PUSH
114956: LD_VAR 0 1
114960: ARRAY
114961: PPUSH
114962: LD_VAR 0 1
114966: PUSH
114967: LD_INT 4
114969: MOD
114970: PUSH
114971: LD_INT 1
114973: PLUS
114974: PPUSH
114975: CALL_OW 259
114979: PUSH
114980: LD_INT 1
114982: PLUS
114983: PPUSH
114984: CALL_OW 237
114988: GO 114890
114990: POP
114991: POP
// end ;
114992: PPOPN 3
114994: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
114995: LD_EXP 143
114999: PUSH
115000: LD_EXP 151
115004: AND
115005: IFFALSE 115025
115007: GO 115009
115009: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
115010: LD_INT 4
115012: PPUSH
115013: LD_OWVAR 2
115017: PPUSH
115018: LD_INT 0
115020: PPUSH
115021: CALL_OW 324
115025: END
// every 0 0$1 trigger StreamModeActive and sShovel do
115026: LD_EXP 143
115030: PUSH
115031: LD_EXP 180
115035: AND
115036: IFFALSE 115056
115038: GO 115040
115040: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
115041: LD_INT 19
115043: PPUSH
115044: LD_OWVAR 2
115048: PPUSH
115049: LD_INT 0
115051: PPUSH
115052: CALL_OW 324
115056: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
115057: LD_EXP 143
115061: PUSH
115062: LD_EXP 152
115066: AND
115067: IFFALSE 115169
115069: GO 115071
115071: DISABLE
115072: LD_INT 0
115074: PPUSH
115075: PPUSH
// begin enable ;
115076: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
115077: LD_ADDR_VAR 0 2
115081: PUSH
115082: LD_INT 22
115084: PUSH
115085: LD_OWVAR 2
115089: PUSH
115090: EMPTY
115091: LIST
115092: LIST
115093: PUSH
115094: LD_INT 2
115096: PUSH
115097: LD_INT 34
115099: PUSH
115100: LD_INT 11
115102: PUSH
115103: EMPTY
115104: LIST
115105: LIST
115106: PUSH
115107: LD_INT 34
115109: PUSH
115110: LD_INT 30
115112: PUSH
115113: EMPTY
115114: LIST
115115: LIST
115116: PUSH
115117: EMPTY
115118: LIST
115119: LIST
115120: LIST
115121: PUSH
115122: EMPTY
115123: LIST
115124: LIST
115125: PPUSH
115126: CALL_OW 69
115130: ST_TO_ADDR
// if not tmp then
115131: LD_VAR 0 2
115135: NOT
115136: IFFALSE 115140
// exit ;
115138: GO 115169
// for i in tmp do
115140: LD_ADDR_VAR 0 1
115144: PUSH
115145: LD_VAR 0 2
115149: PUSH
115150: FOR_IN
115151: IFFALSE 115167
// begin SetLives ( i , 0 ) ;
115153: LD_VAR 0 1
115157: PPUSH
115158: LD_INT 0
115160: PPUSH
115161: CALL_OW 234
// end ;
115165: GO 115150
115167: POP
115168: POP
// end ;
115169: PPOPN 2
115171: END
// every 0 0$1 trigger StreamModeActive and sBunker do
115172: LD_EXP 143
115176: PUSH
115177: LD_EXP 153
115181: AND
115182: IFFALSE 115202
115184: GO 115186
115186: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
115187: LD_INT 32
115189: PPUSH
115190: LD_OWVAR 2
115194: PPUSH
115195: LD_INT 0
115197: PPUSH
115198: CALL_OW 324
115202: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
115203: LD_EXP 143
115207: PUSH
115208: LD_EXP 154
115212: AND
115213: IFFALSE 115394
115215: GO 115217
115217: DISABLE
115218: LD_INT 0
115220: PPUSH
115221: PPUSH
115222: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
115223: LD_ADDR_VAR 0 2
115227: PUSH
115228: LD_INT 22
115230: PUSH
115231: LD_OWVAR 2
115235: PUSH
115236: EMPTY
115237: LIST
115238: LIST
115239: PUSH
115240: LD_INT 33
115242: PUSH
115243: LD_INT 3
115245: PUSH
115246: EMPTY
115247: LIST
115248: LIST
115249: PUSH
115250: EMPTY
115251: LIST
115252: LIST
115253: PPUSH
115254: CALL_OW 69
115258: ST_TO_ADDR
// if not tmp then
115259: LD_VAR 0 2
115263: NOT
115264: IFFALSE 115268
// exit ;
115266: GO 115394
// side := 0 ;
115268: LD_ADDR_VAR 0 3
115272: PUSH
115273: LD_INT 0
115275: ST_TO_ADDR
// for i := 1 to 8 do
115276: LD_ADDR_VAR 0 1
115280: PUSH
115281: DOUBLE
115282: LD_INT 1
115284: DEC
115285: ST_TO_ADDR
115286: LD_INT 8
115288: PUSH
115289: FOR_TO
115290: IFFALSE 115338
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
115292: LD_OWVAR 2
115296: PUSH
115297: LD_VAR 0 1
115301: NONEQUAL
115302: PUSH
115303: LD_OWVAR 2
115307: PPUSH
115308: LD_VAR 0 1
115312: PPUSH
115313: CALL_OW 81
115317: PUSH
115318: LD_INT 2
115320: EQUAL
115321: AND
115322: IFFALSE 115336
// begin side := i ;
115324: LD_ADDR_VAR 0 3
115328: PUSH
115329: LD_VAR 0 1
115333: ST_TO_ADDR
// break ;
115334: GO 115338
// end ;
115336: GO 115289
115338: POP
115339: POP
// if not side then
115340: LD_VAR 0 3
115344: NOT
115345: IFFALSE 115349
// exit ;
115347: GO 115394
// for i := 1 to tmp do
115349: LD_ADDR_VAR 0 1
115353: PUSH
115354: DOUBLE
115355: LD_INT 1
115357: DEC
115358: ST_TO_ADDR
115359: LD_VAR 0 2
115363: PUSH
115364: FOR_TO
115365: IFFALSE 115392
// if Prob ( 60 ) then
115367: LD_INT 60
115369: PPUSH
115370: CALL_OW 13
115374: IFFALSE 115390
// SetSide ( i , side ) ;
115376: LD_VAR 0 1
115380: PPUSH
115381: LD_VAR 0 3
115385: PPUSH
115386: CALL_OW 235
115390: GO 115364
115392: POP
115393: POP
// end ;
115394: PPOPN 3
115396: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
115397: LD_EXP 143
115401: PUSH
115402: LD_EXP 156
115406: AND
115407: IFFALSE 115526
115409: GO 115411
115411: DISABLE
115412: LD_INT 0
115414: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
115415: LD_ADDR_VAR 0 1
115419: PUSH
115420: LD_INT 22
115422: PUSH
115423: LD_OWVAR 2
115427: PUSH
115428: EMPTY
115429: LIST
115430: LIST
115431: PUSH
115432: LD_INT 21
115434: PUSH
115435: LD_INT 1
115437: PUSH
115438: EMPTY
115439: LIST
115440: LIST
115441: PUSH
115442: LD_INT 3
115444: PUSH
115445: LD_INT 23
115447: PUSH
115448: LD_INT 0
115450: PUSH
115451: EMPTY
115452: LIST
115453: LIST
115454: PUSH
115455: EMPTY
115456: LIST
115457: LIST
115458: PUSH
115459: EMPTY
115460: LIST
115461: LIST
115462: LIST
115463: PPUSH
115464: CALL_OW 69
115468: PUSH
115469: FOR_IN
115470: IFFALSE 115524
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
115472: LD_VAR 0 1
115476: PPUSH
115477: CALL_OW 257
115481: PUSH
115482: LD_INT 1
115484: PUSH
115485: LD_INT 2
115487: PUSH
115488: LD_INT 3
115490: PUSH
115491: LD_INT 4
115493: PUSH
115494: EMPTY
115495: LIST
115496: LIST
115497: LIST
115498: LIST
115499: IN
115500: IFFALSE 115522
// SetClass ( un , rand ( 1 , 4 ) ) ;
115502: LD_VAR 0 1
115506: PPUSH
115507: LD_INT 1
115509: PPUSH
115510: LD_INT 4
115512: PPUSH
115513: CALL_OW 12
115517: PPUSH
115518: CALL_OW 336
115522: GO 115469
115524: POP
115525: POP
// end ;
115526: PPOPN 1
115528: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
115529: LD_EXP 143
115533: PUSH
115534: LD_EXP 155
115538: AND
115539: IFFALSE 115618
115541: GO 115543
115543: DISABLE
115544: LD_INT 0
115546: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
115547: LD_ADDR_VAR 0 1
115551: PUSH
115552: LD_INT 22
115554: PUSH
115555: LD_OWVAR 2
115559: PUSH
115560: EMPTY
115561: LIST
115562: LIST
115563: PUSH
115564: LD_INT 21
115566: PUSH
115567: LD_INT 3
115569: PUSH
115570: EMPTY
115571: LIST
115572: LIST
115573: PUSH
115574: EMPTY
115575: LIST
115576: LIST
115577: PPUSH
115578: CALL_OW 69
115582: ST_TO_ADDR
// if not tmp then
115583: LD_VAR 0 1
115587: NOT
115588: IFFALSE 115592
// exit ;
115590: GO 115618
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
115592: LD_VAR 0 1
115596: PUSH
115597: LD_INT 1
115599: PPUSH
115600: LD_VAR 0 1
115604: PPUSH
115605: CALL_OW 12
115609: ARRAY
115610: PPUSH
115611: LD_INT 100
115613: PPUSH
115614: CALL_OW 234
// end ;
115618: PPOPN 1
115620: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
115621: LD_EXP 143
115625: PUSH
115626: LD_EXP 157
115630: AND
115631: IFFALSE 115729
115633: GO 115635
115635: DISABLE
115636: LD_INT 0
115638: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
115639: LD_ADDR_VAR 0 1
115643: PUSH
115644: LD_INT 22
115646: PUSH
115647: LD_OWVAR 2
115651: PUSH
115652: EMPTY
115653: LIST
115654: LIST
115655: PUSH
115656: LD_INT 21
115658: PUSH
115659: LD_INT 1
115661: PUSH
115662: EMPTY
115663: LIST
115664: LIST
115665: PUSH
115666: EMPTY
115667: LIST
115668: LIST
115669: PPUSH
115670: CALL_OW 69
115674: ST_TO_ADDR
// if not tmp then
115675: LD_VAR 0 1
115679: NOT
115680: IFFALSE 115684
// exit ;
115682: GO 115729
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
115684: LD_VAR 0 1
115688: PUSH
115689: LD_INT 1
115691: PPUSH
115692: LD_VAR 0 1
115696: PPUSH
115697: CALL_OW 12
115701: ARRAY
115702: PPUSH
115703: LD_INT 1
115705: PPUSH
115706: LD_INT 4
115708: PPUSH
115709: CALL_OW 12
115713: PPUSH
115714: LD_INT 3000
115716: PPUSH
115717: LD_INT 9000
115719: PPUSH
115720: CALL_OW 12
115724: PPUSH
115725: CALL_OW 492
// end ;
115729: PPOPN 1
115731: END
// every 0 0$1 trigger StreamModeActive and sDepot do
115732: LD_EXP 143
115736: PUSH
115737: LD_EXP 158
115741: AND
115742: IFFALSE 115762
115744: GO 115746
115746: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
115747: LD_INT 1
115749: PPUSH
115750: LD_OWVAR 2
115754: PPUSH
115755: LD_INT 0
115757: PPUSH
115758: CALL_OW 324
115762: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
115763: LD_EXP 143
115767: PUSH
115768: LD_EXP 159
115772: AND
115773: IFFALSE 115856
115775: GO 115777
115777: DISABLE
115778: LD_INT 0
115780: PPUSH
115781: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
115782: LD_ADDR_VAR 0 2
115786: PUSH
115787: LD_INT 22
115789: PUSH
115790: LD_OWVAR 2
115794: PUSH
115795: EMPTY
115796: LIST
115797: LIST
115798: PUSH
115799: LD_INT 21
115801: PUSH
115802: LD_INT 3
115804: PUSH
115805: EMPTY
115806: LIST
115807: LIST
115808: PUSH
115809: EMPTY
115810: LIST
115811: LIST
115812: PPUSH
115813: CALL_OW 69
115817: ST_TO_ADDR
// if not tmp then
115818: LD_VAR 0 2
115822: NOT
115823: IFFALSE 115827
// exit ;
115825: GO 115856
// for i in tmp do
115827: LD_ADDR_VAR 0 1
115831: PUSH
115832: LD_VAR 0 2
115836: PUSH
115837: FOR_IN
115838: IFFALSE 115854
// SetBLevel ( i , 10 ) ;
115840: LD_VAR 0 1
115844: PPUSH
115845: LD_INT 10
115847: PPUSH
115848: CALL_OW 241
115852: GO 115837
115854: POP
115855: POP
// end ;
115856: PPOPN 2
115858: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
115859: LD_EXP 143
115863: PUSH
115864: LD_EXP 160
115868: AND
115869: IFFALSE 115980
115871: GO 115873
115873: DISABLE
115874: LD_INT 0
115876: PPUSH
115877: PPUSH
115878: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
115879: LD_ADDR_VAR 0 3
115883: PUSH
115884: LD_INT 22
115886: PUSH
115887: LD_OWVAR 2
115891: PUSH
115892: EMPTY
115893: LIST
115894: LIST
115895: PUSH
115896: LD_INT 25
115898: PUSH
115899: LD_INT 1
115901: PUSH
115902: EMPTY
115903: LIST
115904: LIST
115905: PUSH
115906: EMPTY
115907: LIST
115908: LIST
115909: PPUSH
115910: CALL_OW 69
115914: ST_TO_ADDR
// if not tmp then
115915: LD_VAR 0 3
115919: NOT
115920: IFFALSE 115924
// exit ;
115922: GO 115980
// un := tmp [ rand ( 1 , tmp ) ] ;
115924: LD_ADDR_VAR 0 2
115928: PUSH
115929: LD_VAR 0 3
115933: PUSH
115934: LD_INT 1
115936: PPUSH
115937: LD_VAR 0 3
115941: PPUSH
115942: CALL_OW 12
115946: ARRAY
115947: ST_TO_ADDR
// if Crawls ( un ) then
115948: LD_VAR 0 2
115952: PPUSH
115953: CALL_OW 318
115957: IFFALSE 115968
// ComWalk ( un ) ;
115959: LD_VAR 0 2
115963: PPUSH
115964: CALL_OW 138
// SetClass ( un , class_sniper ) ;
115968: LD_VAR 0 2
115972: PPUSH
115973: LD_INT 5
115975: PPUSH
115976: CALL_OW 336
// end ;
115980: PPOPN 3
115982: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
115983: LD_EXP 143
115987: PUSH
115988: LD_EXP 161
115992: AND
115993: PUSH
115994: LD_OWVAR 67
115998: PUSH
115999: LD_INT 4
116001: LESS
116002: AND
116003: IFFALSE 116022
116005: GO 116007
116007: DISABLE
// begin Difficulty := Difficulty + 1 ;
116008: LD_ADDR_OWVAR 67
116012: PUSH
116013: LD_OWVAR 67
116017: PUSH
116018: LD_INT 1
116020: PLUS
116021: ST_TO_ADDR
// end ;
116022: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
116023: LD_EXP 143
116027: PUSH
116028: LD_EXP 162
116032: AND
116033: IFFALSE 116136
116035: GO 116037
116037: DISABLE
116038: LD_INT 0
116040: PPUSH
// begin for i := 1 to 5 do
116041: LD_ADDR_VAR 0 1
116045: PUSH
116046: DOUBLE
116047: LD_INT 1
116049: DEC
116050: ST_TO_ADDR
116051: LD_INT 5
116053: PUSH
116054: FOR_TO
116055: IFFALSE 116134
// begin uc_nation := nation_nature ;
116057: LD_ADDR_OWVAR 21
116061: PUSH
116062: LD_INT 0
116064: ST_TO_ADDR
// uc_side := 0 ;
116065: LD_ADDR_OWVAR 20
116069: PUSH
116070: LD_INT 0
116072: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
116073: LD_ADDR_OWVAR 29
116077: PUSH
116078: LD_INT 12
116080: PUSH
116081: LD_INT 12
116083: PUSH
116084: EMPTY
116085: LIST
116086: LIST
116087: ST_TO_ADDR
// hc_agressivity := 20 ;
116088: LD_ADDR_OWVAR 35
116092: PUSH
116093: LD_INT 20
116095: ST_TO_ADDR
// hc_class := class_tiger ;
116096: LD_ADDR_OWVAR 28
116100: PUSH
116101: LD_INT 14
116103: ST_TO_ADDR
// hc_gallery :=  ;
116104: LD_ADDR_OWVAR 33
116108: PUSH
116109: LD_STRING 
116111: ST_TO_ADDR
// hc_name :=  ;
116112: LD_ADDR_OWVAR 26
116116: PUSH
116117: LD_STRING 
116119: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
116120: CALL_OW 44
116124: PPUSH
116125: LD_INT 0
116127: PPUSH
116128: CALL_OW 51
// end ;
116132: GO 116054
116134: POP
116135: POP
// end ;
116136: PPOPN 1
116138: END
// every 0 0$1 trigger StreamModeActive and sBomb do
116139: LD_EXP 143
116143: PUSH
116144: LD_EXP 163
116148: AND
116149: IFFALSE 116158
116151: GO 116153
116153: DISABLE
// StreamSibBomb ;
116154: CALL 116159 0 0
116158: END
// export function StreamSibBomb ; var i , x , y ; begin
116159: LD_INT 0
116161: PPUSH
116162: PPUSH
116163: PPUSH
116164: PPUSH
// result := false ;
116165: LD_ADDR_VAR 0 1
116169: PUSH
116170: LD_INT 0
116172: ST_TO_ADDR
// for i := 1 to 16 do
116173: LD_ADDR_VAR 0 2
116177: PUSH
116178: DOUBLE
116179: LD_INT 1
116181: DEC
116182: ST_TO_ADDR
116183: LD_INT 16
116185: PUSH
116186: FOR_TO
116187: IFFALSE 116386
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
116189: LD_ADDR_VAR 0 3
116193: PUSH
116194: LD_INT 10
116196: PUSH
116197: LD_INT 20
116199: PUSH
116200: LD_INT 30
116202: PUSH
116203: LD_INT 40
116205: PUSH
116206: LD_INT 50
116208: PUSH
116209: LD_INT 60
116211: PUSH
116212: LD_INT 70
116214: PUSH
116215: LD_INT 80
116217: PUSH
116218: LD_INT 90
116220: PUSH
116221: LD_INT 100
116223: PUSH
116224: LD_INT 110
116226: PUSH
116227: LD_INT 120
116229: PUSH
116230: LD_INT 130
116232: PUSH
116233: LD_INT 140
116235: PUSH
116236: LD_INT 150
116238: PUSH
116239: EMPTY
116240: LIST
116241: LIST
116242: LIST
116243: LIST
116244: LIST
116245: LIST
116246: LIST
116247: LIST
116248: LIST
116249: LIST
116250: LIST
116251: LIST
116252: LIST
116253: LIST
116254: LIST
116255: PUSH
116256: LD_INT 1
116258: PPUSH
116259: LD_INT 15
116261: PPUSH
116262: CALL_OW 12
116266: ARRAY
116267: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
116268: LD_ADDR_VAR 0 4
116272: PUSH
116273: LD_INT 10
116275: PUSH
116276: LD_INT 20
116278: PUSH
116279: LD_INT 30
116281: PUSH
116282: LD_INT 40
116284: PUSH
116285: LD_INT 50
116287: PUSH
116288: LD_INT 60
116290: PUSH
116291: LD_INT 70
116293: PUSH
116294: LD_INT 80
116296: PUSH
116297: LD_INT 90
116299: PUSH
116300: LD_INT 100
116302: PUSH
116303: LD_INT 110
116305: PUSH
116306: LD_INT 120
116308: PUSH
116309: LD_INT 130
116311: PUSH
116312: LD_INT 140
116314: PUSH
116315: LD_INT 150
116317: PUSH
116318: EMPTY
116319: LIST
116320: LIST
116321: LIST
116322: LIST
116323: LIST
116324: LIST
116325: LIST
116326: LIST
116327: LIST
116328: LIST
116329: LIST
116330: LIST
116331: LIST
116332: LIST
116333: LIST
116334: PUSH
116335: LD_INT 1
116337: PPUSH
116338: LD_INT 15
116340: PPUSH
116341: CALL_OW 12
116345: ARRAY
116346: ST_TO_ADDR
// if ValidHex ( x , y ) then
116347: LD_VAR 0 3
116351: PPUSH
116352: LD_VAR 0 4
116356: PPUSH
116357: CALL_OW 488
116361: IFFALSE 116384
// begin result := [ x , y ] ;
116363: LD_ADDR_VAR 0 1
116367: PUSH
116368: LD_VAR 0 3
116372: PUSH
116373: LD_VAR 0 4
116377: PUSH
116378: EMPTY
116379: LIST
116380: LIST
116381: ST_TO_ADDR
// break ;
116382: GO 116386
// end ; end ;
116384: GO 116186
116386: POP
116387: POP
// if result then
116388: LD_VAR 0 1
116392: IFFALSE 116452
// begin ToLua ( playSibBomb() ) ;
116394: LD_STRING playSibBomb()
116396: PPUSH
116397: CALL_OW 559
// wait ( 0 0$14 ) ;
116401: LD_INT 490
116403: PPUSH
116404: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
116408: LD_VAR 0 1
116412: PUSH
116413: LD_INT 1
116415: ARRAY
116416: PPUSH
116417: LD_VAR 0 1
116421: PUSH
116422: LD_INT 2
116424: ARRAY
116425: PPUSH
116426: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
116430: LD_VAR 0 1
116434: PUSH
116435: LD_INT 1
116437: ARRAY
116438: PPUSH
116439: LD_VAR 0 1
116443: PUSH
116444: LD_INT 2
116446: ARRAY
116447: PPUSH
116448: CALL_OW 429
// end ; end ;
116452: LD_VAR 0 1
116456: RET
// every 0 0$1 trigger StreamModeActive and sReset do
116457: LD_EXP 143
116461: PUSH
116462: LD_EXP 165
116466: AND
116467: IFFALSE 116479
116469: GO 116471
116471: DISABLE
// YouLost (  ) ;
116472: LD_STRING 
116474: PPUSH
116475: CALL_OW 104
116479: END
// every 0 0$1 trigger StreamModeActive and sFog do
116480: LD_EXP 143
116484: PUSH
116485: LD_EXP 164
116489: AND
116490: IFFALSE 116504
116492: GO 116494
116494: DISABLE
// FogOff ( your_side ) ;
116495: LD_OWVAR 2
116499: PPUSH
116500: CALL_OW 344
116504: END
// every 0 0$1 trigger StreamModeActive and sSun do
116505: LD_EXP 143
116509: PUSH
116510: LD_EXP 166
116514: AND
116515: IFFALSE 116543
116517: GO 116519
116519: DISABLE
// begin solar_recharge_percent := 0 ;
116520: LD_ADDR_OWVAR 79
116524: PUSH
116525: LD_INT 0
116527: ST_TO_ADDR
// wait ( 5 5$00 ) ;
116528: LD_INT 10500
116530: PPUSH
116531: CALL_OW 67
// solar_recharge_percent := 100 ;
116535: LD_ADDR_OWVAR 79
116539: PUSH
116540: LD_INT 100
116542: ST_TO_ADDR
// end ;
116543: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
116544: LD_EXP 143
116548: PUSH
116549: LD_EXP 167
116553: AND
116554: IFFALSE 116793
116556: GO 116558
116558: DISABLE
116559: LD_INT 0
116561: PPUSH
116562: PPUSH
116563: PPUSH
// begin tmp := [ ] ;
116564: LD_ADDR_VAR 0 3
116568: PUSH
116569: EMPTY
116570: ST_TO_ADDR
// for i := 1 to 6 do
116571: LD_ADDR_VAR 0 1
116575: PUSH
116576: DOUBLE
116577: LD_INT 1
116579: DEC
116580: ST_TO_ADDR
116581: LD_INT 6
116583: PUSH
116584: FOR_TO
116585: IFFALSE 116690
// begin uc_nation := nation_nature ;
116587: LD_ADDR_OWVAR 21
116591: PUSH
116592: LD_INT 0
116594: ST_TO_ADDR
// uc_side := 0 ;
116595: LD_ADDR_OWVAR 20
116599: PUSH
116600: LD_INT 0
116602: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
116603: LD_ADDR_OWVAR 29
116607: PUSH
116608: LD_INT 12
116610: PUSH
116611: LD_INT 12
116613: PUSH
116614: EMPTY
116615: LIST
116616: LIST
116617: ST_TO_ADDR
// hc_agressivity := 20 ;
116618: LD_ADDR_OWVAR 35
116622: PUSH
116623: LD_INT 20
116625: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
116626: LD_ADDR_OWVAR 28
116630: PUSH
116631: LD_INT 17
116633: ST_TO_ADDR
// hc_gallery :=  ;
116634: LD_ADDR_OWVAR 33
116638: PUSH
116639: LD_STRING 
116641: ST_TO_ADDR
// hc_name :=  ;
116642: LD_ADDR_OWVAR 26
116646: PUSH
116647: LD_STRING 
116649: ST_TO_ADDR
// un := CreateHuman ;
116650: LD_ADDR_VAR 0 2
116654: PUSH
116655: CALL_OW 44
116659: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
116660: LD_VAR 0 2
116664: PPUSH
116665: LD_INT 1
116667: PPUSH
116668: CALL_OW 51
// tmp := tmp ^ un ;
116672: LD_ADDR_VAR 0 3
116676: PUSH
116677: LD_VAR 0 3
116681: PUSH
116682: LD_VAR 0 2
116686: ADD
116687: ST_TO_ADDR
// end ;
116688: GO 116584
116690: POP
116691: POP
// repeat wait ( 0 0$1 ) ;
116692: LD_INT 35
116694: PPUSH
116695: CALL_OW 67
// for un in tmp do
116699: LD_ADDR_VAR 0 2
116703: PUSH
116704: LD_VAR 0 3
116708: PUSH
116709: FOR_IN
116710: IFFALSE 116784
// begin if IsDead ( un ) then
116712: LD_VAR 0 2
116716: PPUSH
116717: CALL_OW 301
116721: IFFALSE 116741
// begin tmp := tmp diff un ;
116723: LD_ADDR_VAR 0 3
116727: PUSH
116728: LD_VAR 0 3
116732: PUSH
116733: LD_VAR 0 2
116737: DIFF
116738: ST_TO_ADDR
// continue ;
116739: GO 116709
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
116741: LD_VAR 0 2
116745: PPUSH
116746: LD_INT 3
116748: PUSH
116749: LD_INT 22
116751: PUSH
116752: LD_INT 0
116754: PUSH
116755: EMPTY
116756: LIST
116757: LIST
116758: PUSH
116759: EMPTY
116760: LIST
116761: LIST
116762: PPUSH
116763: CALL_OW 69
116767: PPUSH
116768: LD_VAR 0 2
116772: PPUSH
116773: CALL_OW 74
116777: PPUSH
116778: CALL_OW 115
// end ;
116782: GO 116709
116784: POP
116785: POP
// until not tmp ;
116786: LD_VAR 0 3
116790: NOT
116791: IFFALSE 116692
// end ;
116793: PPOPN 3
116795: END
// every 0 0$1 trigger StreamModeActive and sTroll do
116796: LD_EXP 143
116800: PUSH
116801: LD_EXP 168
116805: AND
116806: IFFALSE 116860
116808: GO 116810
116810: DISABLE
// begin ToLua ( displayTroll(); ) ;
116811: LD_STRING displayTroll();
116813: PPUSH
116814: CALL_OW 559
// wait ( 3 3$00 ) ;
116818: LD_INT 6300
116820: PPUSH
116821: CALL_OW 67
// ToLua ( hideTroll(); ) ;
116825: LD_STRING hideTroll();
116827: PPUSH
116828: CALL_OW 559
// wait ( 1 1$00 ) ;
116832: LD_INT 2100
116834: PPUSH
116835: CALL_OW 67
// ToLua ( displayTroll(); ) ;
116839: LD_STRING displayTroll();
116841: PPUSH
116842: CALL_OW 559
// wait ( 1 1$00 ) ;
116846: LD_INT 2100
116848: PPUSH
116849: CALL_OW 67
// ToLua ( hideTroll(); ) ;
116853: LD_STRING hideTroll();
116855: PPUSH
116856: CALL_OW 559
// end ;
116860: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
116861: LD_EXP 143
116865: PUSH
116866: LD_EXP 169
116870: AND
116871: IFFALSE 116934
116873: GO 116875
116875: DISABLE
116876: LD_INT 0
116878: PPUSH
// begin p := 0 ;
116879: LD_ADDR_VAR 0 1
116883: PUSH
116884: LD_INT 0
116886: ST_TO_ADDR
// repeat game_speed := 1 ;
116887: LD_ADDR_OWVAR 65
116891: PUSH
116892: LD_INT 1
116894: ST_TO_ADDR
// wait ( 0 0$1 ) ;
116895: LD_INT 35
116897: PPUSH
116898: CALL_OW 67
// p := p + 1 ;
116902: LD_ADDR_VAR 0 1
116906: PUSH
116907: LD_VAR 0 1
116911: PUSH
116912: LD_INT 1
116914: PLUS
116915: ST_TO_ADDR
// until p >= 60 ;
116916: LD_VAR 0 1
116920: PUSH
116921: LD_INT 60
116923: GREATEREQUAL
116924: IFFALSE 116887
// game_speed := 4 ;
116926: LD_ADDR_OWVAR 65
116930: PUSH
116931: LD_INT 4
116933: ST_TO_ADDR
// end ;
116934: PPOPN 1
116936: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
116937: LD_EXP 143
116941: PUSH
116942: LD_EXP 170
116946: AND
116947: IFFALSE 117093
116949: GO 116951
116951: DISABLE
116952: LD_INT 0
116954: PPUSH
116955: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
116956: LD_ADDR_VAR 0 1
116960: PUSH
116961: LD_INT 22
116963: PUSH
116964: LD_OWVAR 2
116968: PUSH
116969: EMPTY
116970: LIST
116971: LIST
116972: PUSH
116973: LD_INT 2
116975: PUSH
116976: LD_INT 30
116978: PUSH
116979: LD_INT 0
116981: PUSH
116982: EMPTY
116983: LIST
116984: LIST
116985: PUSH
116986: LD_INT 30
116988: PUSH
116989: LD_INT 1
116991: PUSH
116992: EMPTY
116993: LIST
116994: LIST
116995: PUSH
116996: EMPTY
116997: LIST
116998: LIST
116999: LIST
117000: PUSH
117001: EMPTY
117002: LIST
117003: LIST
117004: PPUSH
117005: CALL_OW 69
117009: ST_TO_ADDR
// if not depot then
117010: LD_VAR 0 1
117014: NOT
117015: IFFALSE 117019
// exit ;
117017: GO 117093
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
117019: LD_ADDR_VAR 0 2
117023: PUSH
117024: LD_VAR 0 1
117028: PUSH
117029: LD_INT 1
117031: PPUSH
117032: LD_VAR 0 1
117036: PPUSH
117037: CALL_OW 12
117041: ARRAY
117042: PPUSH
117043: CALL_OW 274
117047: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
117048: LD_VAR 0 2
117052: PPUSH
117053: LD_INT 1
117055: PPUSH
117056: LD_INT 0
117058: PPUSH
117059: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
117063: LD_VAR 0 2
117067: PPUSH
117068: LD_INT 2
117070: PPUSH
117071: LD_INT 0
117073: PPUSH
117074: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
117078: LD_VAR 0 2
117082: PPUSH
117083: LD_INT 3
117085: PPUSH
117086: LD_INT 0
117088: PPUSH
117089: CALL_OW 277
// end ;
117093: PPOPN 2
117095: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
117096: LD_EXP 143
117100: PUSH
117101: LD_EXP 171
117105: AND
117106: IFFALSE 117203
117108: GO 117110
117110: DISABLE
117111: LD_INT 0
117113: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
117114: LD_ADDR_VAR 0 1
117118: PUSH
117119: LD_INT 22
117121: PUSH
117122: LD_OWVAR 2
117126: PUSH
117127: EMPTY
117128: LIST
117129: LIST
117130: PUSH
117131: LD_INT 21
117133: PUSH
117134: LD_INT 1
117136: PUSH
117137: EMPTY
117138: LIST
117139: LIST
117140: PUSH
117141: LD_INT 3
117143: PUSH
117144: LD_INT 23
117146: PUSH
117147: LD_INT 0
117149: PUSH
117150: EMPTY
117151: LIST
117152: LIST
117153: PUSH
117154: EMPTY
117155: LIST
117156: LIST
117157: PUSH
117158: EMPTY
117159: LIST
117160: LIST
117161: LIST
117162: PPUSH
117163: CALL_OW 69
117167: ST_TO_ADDR
// if not tmp then
117168: LD_VAR 0 1
117172: NOT
117173: IFFALSE 117177
// exit ;
117175: GO 117203
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
117177: LD_VAR 0 1
117181: PUSH
117182: LD_INT 1
117184: PPUSH
117185: LD_VAR 0 1
117189: PPUSH
117190: CALL_OW 12
117194: ARRAY
117195: PPUSH
117196: LD_INT 200
117198: PPUSH
117199: CALL_OW 234
// end ;
117203: PPOPN 1
117205: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
117206: LD_EXP 143
117210: PUSH
117211: LD_EXP 172
117215: AND
117216: IFFALSE 117295
117218: GO 117220
117220: DISABLE
117221: LD_INT 0
117223: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
117224: LD_ADDR_VAR 0 1
117228: PUSH
117229: LD_INT 22
117231: PUSH
117232: LD_OWVAR 2
117236: PUSH
117237: EMPTY
117238: LIST
117239: LIST
117240: PUSH
117241: LD_INT 21
117243: PUSH
117244: LD_INT 2
117246: PUSH
117247: EMPTY
117248: LIST
117249: LIST
117250: PUSH
117251: EMPTY
117252: LIST
117253: LIST
117254: PPUSH
117255: CALL_OW 69
117259: ST_TO_ADDR
// if not tmp then
117260: LD_VAR 0 1
117264: NOT
117265: IFFALSE 117269
// exit ;
117267: GO 117295
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
117269: LD_VAR 0 1
117273: PUSH
117274: LD_INT 1
117276: PPUSH
117277: LD_VAR 0 1
117281: PPUSH
117282: CALL_OW 12
117286: ARRAY
117287: PPUSH
117288: LD_INT 60
117290: PPUSH
117291: CALL_OW 234
// end ;
117295: PPOPN 1
117297: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
117298: LD_EXP 143
117302: PUSH
117303: LD_EXP 173
117307: AND
117308: IFFALSE 117407
117310: GO 117312
117312: DISABLE
117313: LD_INT 0
117315: PPUSH
117316: PPUSH
// begin enable ;
117317: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
117318: LD_ADDR_VAR 0 1
117322: PUSH
117323: LD_INT 22
117325: PUSH
117326: LD_OWVAR 2
117330: PUSH
117331: EMPTY
117332: LIST
117333: LIST
117334: PUSH
117335: LD_INT 61
117337: PUSH
117338: EMPTY
117339: LIST
117340: PUSH
117341: LD_INT 33
117343: PUSH
117344: LD_INT 2
117346: PUSH
117347: EMPTY
117348: LIST
117349: LIST
117350: PUSH
117351: EMPTY
117352: LIST
117353: LIST
117354: LIST
117355: PPUSH
117356: CALL_OW 69
117360: ST_TO_ADDR
// if not tmp then
117361: LD_VAR 0 1
117365: NOT
117366: IFFALSE 117370
// exit ;
117368: GO 117407
// for i in tmp do
117370: LD_ADDR_VAR 0 2
117374: PUSH
117375: LD_VAR 0 1
117379: PUSH
117380: FOR_IN
117381: IFFALSE 117405
// if IsControledBy ( i ) then
117383: LD_VAR 0 2
117387: PPUSH
117388: CALL_OW 312
117392: IFFALSE 117403
// ComUnlink ( i ) ;
117394: LD_VAR 0 2
117398: PPUSH
117399: CALL_OW 136
117403: GO 117380
117405: POP
117406: POP
// end ;
117407: PPOPN 2
117409: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
117410: LD_EXP 143
117414: PUSH
117415: LD_EXP 174
117419: AND
117420: IFFALSE 117560
117422: GO 117424
117424: DISABLE
117425: LD_INT 0
117427: PPUSH
117428: PPUSH
// begin ToLua ( displayPowell(); ) ;
117429: LD_STRING displayPowell();
117431: PPUSH
117432: CALL_OW 559
// uc_side := 0 ;
117436: LD_ADDR_OWVAR 20
117440: PUSH
117441: LD_INT 0
117443: ST_TO_ADDR
// uc_nation := 2 ;
117444: LD_ADDR_OWVAR 21
117448: PUSH
117449: LD_INT 2
117451: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
117452: LD_ADDR_OWVAR 37
117456: PUSH
117457: LD_INT 14
117459: ST_TO_ADDR
// vc_engine := engine_siberite ;
117460: LD_ADDR_OWVAR 39
117464: PUSH
117465: LD_INT 3
117467: ST_TO_ADDR
// vc_control := control_apeman ;
117468: LD_ADDR_OWVAR 38
117472: PUSH
117473: LD_INT 5
117475: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
117476: LD_ADDR_OWVAR 40
117480: PUSH
117481: LD_INT 29
117483: ST_TO_ADDR
// un := CreateVehicle ;
117484: LD_ADDR_VAR 0 2
117488: PUSH
117489: CALL_OW 45
117493: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
117494: LD_VAR 0 2
117498: PPUSH
117499: LD_INT 1
117501: PPUSH
117502: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
117506: LD_INT 35
117508: PPUSH
117509: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
117513: LD_VAR 0 2
117517: PPUSH
117518: LD_INT 22
117520: PUSH
117521: LD_OWVAR 2
117525: PUSH
117526: EMPTY
117527: LIST
117528: LIST
117529: PPUSH
117530: CALL_OW 69
117534: PPUSH
117535: LD_VAR 0 2
117539: PPUSH
117540: CALL_OW 74
117544: PPUSH
117545: CALL_OW 115
// until IsDead ( un ) ;
117549: LD_VAR 0 2
117553: PPUSH
117554: CALL_OW 301
117558: IFFALSE 117506
// end ;
117560: PPOPN 2
117562: END
// every 0 0$1 trigger StreamModeActive and sStu do
117563: LD_EXP 143
117567: PUSH
117568: LD_EXP 182
117572: AND
117573: IFFALSE 117589
117575: GO 117577
117577: DISABLE
// begin ToLua ( displayStucuk(); ) ;
117578: LD_STRING displayStucuk();
117580: PPUSH
117581: CALL_OW 559
// ResetFog ;
117585: CALL_OW 335
// end ;
117589: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
117590: LD_EXP 143
117594: PUSH
117595: LD_EXP 175
117599: AND
117600: IFFALSE 117741
117602: GO 117604
117604: DISABLE
117605: LD_INT 0
117607: PPUSH
117608: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
117609: LD_ADDR_VAR 0 2
117613: PUSH
117614: LD_INT 22
117616: PUSH
117617: LD_OWVAR 2
117621: PUSH
117622: EMPTY
117623: LIST
117624: LIST
117625: PUSH
117626: LD_INT 21
117628: PUSH
117629: LD_INT 1
117631: PUSH
117632: EMPTY
117633: LIST
117634: LIST
117635: PUSH
117636: EMPTY
117637: LIST
117638: LIST
117639: PPUSH
117640: CALL_OW 69
117644: ST_TO_ADDR
// if not tmp then
117645: LD_VAR 0 2
117649: NOT
117650: IFFALSE 117654
// exit ;
117652: GO 117741
// un := tmp [ rand ( 1 , tmp ) ] ;
117654: LD_ADDR_VAR 0 1
117658: PUSH
117659: LD_VAR 0 2
117663: PUSH
117664: LD_INT 1
117666: PPUSH
117667: LD_VAR 0 2
117671: PPUSH
117672: CALL_OW 12
117676: ARRAY
117677: ST_TO_ADDR
// SetSide ( un , 0 ) ;
117678: LD_VAR 0 1
117682: PPUSH
117683: LD_INT 0
117685: PPUSH
117686: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
117690: LD_VAR 0 1
117694: PPUSH
117695: LD_OWVAR 3
117699: PUSH
117700: LD_VAR 0 1
117704: DIFF
117705: PPUSH
117706: LD_VAR 0 1
117710: PPUSH
117711: CALL_OW 74
117715: PPUSH
117716: CALL_OW 115
// wait ( 0 0$20 ) ;
117720: LD_INT 700
117722: PPUSH
117723: CALL_OW 67
// SetSide ( un , your_side ) ;
117727: LD_VAR 0 1
117731: PPUSH
117732: LD_OWVAR 2
117736: PPUSH
117737: CALL_OW 235
// end ;
117741: PPOPN 2
117743: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
117744: LD_EXP 143
117748: PUSH
117749: LD_EXP 176
117753: AND
117754: IFFALSE 117860
117756: GO 117758
117758: DISABLE
117759: LD_INT 0
117761: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
117762: LD_ADDR_VAR 0 1
117766: PUSH
117767: LD_INT 22
117769: PUSH
117770: LD_OWVAR 2
117774: PUSH
117775: EMPTY
117776: LIST
117777: LIST
117778: PUSH
117779: LD_INT 2
117781: PUSH
117782: LD_INT 30
117784: PUSH
117785: LD_INT 0
117787: PUSH
117788: EMPTY
117789: LIST
117790: LIST
117791: PUSH
117792: LD_INT 30
117794: PUSH
117795: LD_INT 1
117797: PUSH
117798: EMPTY
117799: LIST
117800: LIST
117801: PUSH
117802: EMPTY
117803: LIST
117804: LIST
117805: LIST
117806: PUSH
117807: EMPTY
117808: LIST
117809: LIST
117810: PPUSH
117811: CALL_OW 69
117815: ST_TO_ADDR
// if not depot then
117816: LD_VAR 0 1
117820: NOT
117821: IFFALSE 117825
// exit ;
117823: GO 117860
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
117825: LD_VAR 0 1
117829: PUSH
117830: LD_INT 1
117832: ARRAY
117833: PPUSH
117834: CALL_OW 250
117838: PPUSH
117839: LD_VAR 0 1
117843: PUSH
117844: LD_INT 1
117846: ARRAY
117847: PPUSH
117848: CALL_OW 251
117852: PPUSH
117853: LD_INT 70
117855: PPUSH
117856: CALL_OW 495
// end ;
117860: PPOPN 1
117862: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
117863: LD_EXP 143
117867: PUSH
117868: LD_EXP 177
117872: AND
117873: IFFALSE 118084
117875: GO 117877
117877: DISABLE
117878: LD_INT 0
117880: PPUSH
117881: PPUSH
117882: PPUSH
117883: PPUSH
117884: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
117885: LD_ADDR_VAR 0 5
117889: PUSH
117890: LD_INT 22
117892: PUSH
117893: LD_OWVAR 2
117897: PUSH
117898: EMPTY
117899: LIST
117900: LIST
117901: PUSH
117902: LD_INT 21
117904: PUSH
117905: LD_INT 1
117907: PUSH
117908: EMPTY
117909: LIST
117910: LIST
117911: PUSH
117912: EMPTY
117913: LIST
117914: LIST
117915: PPUSH
117916: CALL_OW 69
117920: ST_TO_ADDR
// if not tmp then
117921: LD_VAR 0 5
117925: NOT
117926: IFFALSE 117930
// exit ;
117928: GO 118084
// for i in tmp do
117930: LD_ADDR_VAR 0 1
117934: PUSH
117935: LD_VAR 0 5
117939: PUSH
117940: FOR_IN
117941: IFFALSE 118082
// begin d := rand ( 0 , 5 ) ;
117943: LD_ADDR_VAR 0 4
117947: PUSH
117948: LD_INT 0
117950: PPUSH
117951: LD_INT 5
117953: PPUSH
117954: CALL_OW 12
117958: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
117959: LD_ADDR_VAR 0 2
117963: PUSH
117964: LD_VAR 0 1
117968: PPUSH
117969: CALL_OW 250
117973: PPUSH
117974: LD_VAR 0 4
117978: PPUSH
117979: LD_INT 3
117981: PPUSH
117982: LD_INT 12
117984: PPUSH
117985: CALL_OW 12
117989: PPUSH
117990: CALL_OW 272
117994: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
117995: LD_ADDR_VAR 0 3
117999: PUSH
118000: LD_VAR 0 1
118004: PPUSH
118005: CALL_OW 251
118009: PPUSH
118010: LD_VAR 0 4
118014: PPUSH
118015: LD_INT 3
118017: PPUSH
118018: LD_INT 12
118020: PPUSH
118021: CALL_OW 12
118025: PPUSH
118026: CALL_OW 273
118030: ST_TO_ADDR
// if ValidHex ( x , y ) then
118031: LD_VAR 0 2
118035: PPUSH
118036: LD_VAR 0 3
118040: PPUSH
118041: CALL_OW 488
118045: IFFALSE 118080
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
118047: LD_VAR 0 1
118051: PPUSH
118052: LD_VAR 0 2
118056: PPUSH
118057: LD_VAR 0 3
118061: PPUSH
118062: LD_INT 3
118064: PPUSH
118065: LD_INT 6
118067: PPUSH
118068: CALL_OW 12
118072: PPUSH
118073: LD_INT 1
118075: PPUSH
118076: CALL_OW 483
// end ;
118080: GO 117940
118082: POP
118083: POP
// end ;
118084: PPOPN 5
118086: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
118087: LD_EXP 143
118091: PUSH
118092: LD_EXP 178
118096: AND
118097: IFFALSE 118191
118099: GO 118101
118101: DISABLE
118102: LD_INT 0
118104: PPUSH
118105: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
118106: LD_ADDR_VAR 0 2
118110: PUSH
118111: LD_INT 22
118113: PUSH
118114: LD_OWVAR 2
118118: PUSH
118119: EMPTY
118120: LIST
118121: LIST
118122: PUSH
118123: LD_INT 32
118125: PUSH
118126: LD_INT 1
118128: PUSH
118129: EMPTY
118130: LIST
118131: LIST
118132: PUSH
118133: LD_INT 21
118135: PUSH
118136: LD_INT 2
118138: PUSH
118139: EMPTY
118140: LIST
118141: LIST
118142: PUSH
118143: EMPTY
118144: LIST
118145: LIST
118146: LIST
118147: PPUSH
118148: CALL_OW 69
118152: ST_TO_ADDR
// if not tmp then
118153: LD_VAR 0 2
118157: NOT
118158: IFFALSE 118162
// exit ;
118160: GO 118191
// for i in tmp do
118162: LD_ADDR_VAR 0 1
118166: PUSH
118167: LD_VAR 0 2
118171: PUSH
118172: FOR_IN
118173: IFFALSE 118189
// SetFuel ( i , 0 ) ;
118175: LD_VAR 0 1
118179: PPUSH
118180: LD_INT 0
118182: PPUSH
118183: CALL_OW 240
118187: GO 118172
118189: POP
118190: POP
// end ;
118191: PPOPN 2
118193: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
118194: LD_EXP 143
118198: PUSH
118199: LD_EXP 179
118203: AND
118204: IFFALSE 118270
118206: GO 118208
118208: DISABLE
118209: LD_INT 0
118211: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
118212: LD_ADDR_VAR 0 1
118216: PUSH
118217: LD_INT 22
118219: PUSH
118220: LD_OWVAR 2
118224: PUSH
118225: EMPTY
118226: LIST
118227: LIST
118228: PUSH
118229: LD_INT 30
118231: PUSH
118232: LD_INT 29
118234: PUSH
118235: EMPTY
118236: LIST
118237: LIST
118238: PUSH
118239: EMPTY
118240: LIST
118241: LIST
118242: PPUSH
118243: CALL_OW 69
118247: ST_TO_ADDR
// if not tmp then
118248: LD_VAR 0 1
118252: NOT
118253: IFFALSE 118257
// exit ;
118255: GO 118270
// DestroyUnit ( tmp [ 1 ] ) ;
118257: LD_VAR 0 1
118261: PUSH
118262: LD_INT 1
118264: ARRAY
118265: PPUSH
118266: CALL_OW 65
// end ;
118270: PPOPN 1
118272: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
118273: LD_EXP 143
118277: PUSH
118278: LD_EXP 181
118282: AND
118283: IFFALSE 118412
118285: GO 118287
118287: DISABLE
118288: LD_INT 0
118290: PPUSH
// begin uc_side := 0 ;
118291: LD_ADDR_OWVAR 20
118295: PUSH
118296: LD_INT 0
118298: ST_TO_ADDR
// uc_nation := nation_arabian ;
118299: LD_ADDR_OWVAR 21
118303: PUSH
118304: LD_INT 2
118306: ST_TO_ADDR
// hc_gallery :=  ;
118307: LD_ADDR_OWVAR 33
118311: PUSH
118312: LD_STRING 
118314: ST_TO_ADDR
// hc_name :=  ;
118315: LD_ADDR_OWVAR 26
118319: PUSH
118320: LD_STRING 
118322: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
118323: LD_INT 1
118325: PPUSH
118326: LD_INT 11
118328: PPUSH
118329: LD_INT 10
118331: PPUSH
118332: CALL_OW 380
// un := CreateHuman ;
118336: LD_ADDR_VAR 0 1
118340: PUSH
118341: CALL_OW 44
118345: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
118346: LD_VAR 0 1
118350: PPUSH
118351: LD_INT 1
118353: PPUSH
118354: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
118358: LD_INT 35
118360: PPUSH
118361: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
118365: LD_VAR 0 1
118369: PPUSH
118370: LD_INT 22
118372: PUSH
118373: LD_OWVAR 2
118377: PUSH
118378: EMPTY
118379: LIST
118380: LIST
118381: PPUSH
118382: CALL_OW 69
118386: PPUSH
118387: LD_VAR 0 1
118391: PPUSH
118392: CALL_OW 74
118396: PPUSH
118397: CALL_OW 115
// until IsDead ( un ) ;
118401: LD_VAR 0 1
118405: PPUSH
118406: CALL_OW 301
118410: IFFALSE 118358
// end ;
118412: PPOPN 1
118414: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
118415: LD_EXP 143
118419: PUSH
118420: LD_EXP 183
118424: AND
118425: IFFALSE 118437
118427: GO 118429
118429: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
118430: LD_STRING earthquake(getX(game), 0, 32)
118432: PPUSH
118433: CALL_OW 559
118437: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
118438: LD_EXP 143
118442: PUSH
118443: LD_EXP 184
118447: AND
118448: IFFALSE 118539
118450: GO 118452
118452: DISABLE
118453: LD_INT 0
118455: PPUSH
// begin enable ;
118456: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
118457: LD_ADDR_VAR 0 1
118461: PUSH
118462: LD_INT 22
118464: PUSH
118465: LD_OWVAR 2
118469: PUSH
118470: EMPTY
118471: LIST
118472: LIST
118473: PUSH
118474: LD_INT 21
118476: PUSH
118477: LD_INT 2
118479: PUSH
118480: EMPTY
118481: LIST
118482: LIST
118483: PUSH
118484: LD_INT 33
118486: PUSH
118487: LD_INT 3
118489: PUSH
118490: EMPTY
118491: LIST
118492: LIST
118493: PUSH
118494: EMPTY
118495: LIST
118496: LIST
118497: LIST
118498: PPUSH
118499: CALL_OW 69
118503: ST_TO_ADDR
// if not tmp then
118504: LD_VAR 0 1
118508: NOT
118509: IFFALSE 118513
// exit ;
118511: GO 118539
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
118513: LD_VAR 0 1
118517: PUSH
118518: LD_INT 1
118520: PPUSH
118521: LD_VAR 0 1
118525: PPUSH
118526: CALL_OW 12
118530: ARRAY
118531: PPUSH
118532: LD_INT 1
118534: PPUSH
118535: CALL_OW 234
// end ;
118539: PPOPN 1
118541: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
118542: LD_EXP 143
118546: PUSH
118547: LD_EXP 185
118551: AND
118552: IFFALSE 118693
118554: GO 118556
118556: DISABLE
118557: LD_INT 0
118559: PPUSH
118560: PPUSH
118561: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
118562: LD_ADDR_VAR 0 3
118566: PUSH
118567: LD_INT 22
118569: PUSH
118570: LD_OWVAR 2
118574: PUSH
118575: EMPTY
118576: LIST
118577: LIST
118578: PUSH
118579: LD_INT 25
118581: PUSH
118582: LD_INT 1
118584: PUSH
118585: EMPTY
118586: LIST
118587: LIST
118588: PUSH
118589: EMPTY
118590: LIST
118591: LIST
118592: PPUSH
118593: CALL_OW 69
118597: ST_TO_ADDR
// if not tmp then
118598: LD_VAR 0 3
118602: NOT
118603: IFFALSE 118607
// exit ;
118605: GO 118693
// un := tmp [ rand ( 1 , tmp ) ] ;
118607: LD_ADDR_VAR 0 2
118611: PUSH
118612: LD_VAR 0 3
118616: PUSH
118617: LD_INT 1
118619: PPUSH
118620: LD_VAR 0 3
118624: PPUSH
118625: CALL_OW 12
118629: ARRAY
118630: ST_TO_ADDR
// if Crawls ( un ) then
118631: LD_VAR 0 2
118635: PPUSH
118636: CALL_OW 318
118640: IFFALSE 118651
// ComWalk ( un ) ;
118642: LD_VAR 0 2
118646: PPUSH
118647: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
118651: LD_VAR 0 2
118655: PPUSH
118656: LD_INT 9
118658: PPUSH
118659: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
118663: LD_INT 28
118665: PPUSH
118666: LD_OWVAR 2
118670: PPUSH
118671: LD_INT 2
118673: PPUSH
118674: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
118678: LD_INT 29
118680: PPUSH
118681: LD_OWVAR 2
118685: PPUSH
118686: LD_INT 2
118688: PPUSH
118689: CALL_OW 322
// end ;
118693: PPOPN 3
118695: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
118696: LD_EXP 143
118700: PUSH
118701: LD_EXP 186
118705: AND
118706: IFFALSE 118817
118708: GO 118710
118710: DISABLE
118711: LD_INT 0
118713: PPUSH
118714: PPUSH
118715: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
118716: LD_ADDR_VAR 0 3
118720: PUSH
118721: LD_INT 22
118723: PUSH
118724: LD_OWVAR 2
118728: PUSH
118729: EMPTY
118730: LIST
118731: LIST
118732: PUSH
118733: LD_INT 25
118735: PUSH
118736: LD_INT 1
118738: PUSH
118739: EMPTY
118740: LIST
118741: LIST
118742: PUSH
118743: EMPTY
118744: LIST
118745: LIST
118746: PPUSH
118747: CALL_OW 69
118751: ST_TO_ADDR
// if not tmp then
118752: LD_VAR 0 3
118756: NOT
118757: IFFALSE 118761
// exit ;
118759: GO 118817
// un := tmp [ rand ( 1 , tmp ) ] ;
118761: LD_ADDR_VAR 0 2
118765: PUSH
118766: LD_VAR 0 3
118770: PUSH
118771: LD_INT 1
118773: PPUSH
118774: LD_VAR 0 3
118778: PPUSH
118779: CALL_OW 12
118783: ARRAY
118784: ST_TO_ADDR
// if Crawls ( un ) then
118785: LD_VAR 0 2
118789: PPUSH
118790: CALL_OW 318
118794: IFFALSE 118805
// ComWalk ( un ) ;
118796: LD_VAR 0 2
118800: PPUSH
118801: CALL_OW 138
// SetClass ( un , class_mortar ) ;
118805: LD_VAR 0 2
118809: PPUSH
118810: LD_INT 8
118812: PPUSH
118813: CALL_OW 336
// end ;
118817: PPOPN 3
118819: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
118820: LD_EXP 143
118824: PUSH
118825: LD_EXP 187
118829: AND
118830: IFFALSE 118974
118832: GO 118834
118834: DISABLE
118835: LD_INT 0
118837: PPUSH
118838: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
118839: LD_ADDR_VAR 0 2
118843: PUSH
118844: LD_INT 22
118846: PUSH
118847: LD_OWVAR 2
118851: PUSH
118852: EMPTY
118853: LIST
118854: LIST
118855: PUSH
118856: LD_INT 21
118858: PUSH
118859: LD_INT 2
118861: PUSH
118862: EMPTY
118863: LIST
118864: LIST
118865: PUSH
118866: LD_INT 2
118868: PUSH
118869: LD_INT 34
118871: PUSH
118872: LD_INT 12
118874: PUSH
118875: EMPTY
118876: LIST
118877: LIST
118878: PUSH
118879: LD_INT 34
118881: PUSH
118882: LD_INT 51
118884: PUSH
118885: EMPTY
118886: LIST
118887: LIST
118888: PUSH
118889: LD_INT 34
118891: PUSH
118892: LD_INT 32
118894: PUSH
118895: EMPTY
118896: LIST
118897: LIST
118898: PUSH
118899: EMPTY
118900: LIST
118901: LIST
118902: LIST
118903: LIST
118904: PUSH
118905: EMPTY
118906: LIST
118907: LIST
118908: LIST
118909: PPUSH
118910: CALL_OW 69
118914: ST_TO_ADDR
// if not tmp then
118915: LD_VAR 0 2
118919: NOT
118920: IFFALSE 118924
// exit ;
118922: GO 118974
// for i in tmp do
118924: LD_ADDR_VAR 0 1
118928: PUSH
118929: LD_VAR 0 2
118933: PUSH
118934: FOR_IN
118935: IFFALSE 118972
// if GetCargo ( i , mat_artifact ) = 0 then
118937: LD_VAR 0 1
118941: PPUSH
118942: LD_INT 4
118944: PPUSH
118945: CALL_OW 289
118949: PUSH
118950: LD_INT 0
118952: EQUAL
118953: IFFALSE 118970
// SetCargo ( i , mat_siberit , 100 ) ;
118955: LD_VAR 0 1
118959: PPUSH
118960: LD_INT 3
118962: PPUSH
118963: LD_INT 100
118965: PPUSH
118966: CALL_OW 290
118970: GO 118934
118972: POP
118973: POP
// end ;
118974: PPOPN 2
118976: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
118977: LD_EXP 143
118981: PUSH
118982: LD_EXP 188
118986: AND
118987: IFFALSE 119170
118989: GO 118991
118991: DISABLE
118992: LD_INT 0
118994: PPUSH
118995: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
118996: LD_ADDR_VAR 0 2
119000: PUSH
119001: LD_INT 22
119003: PUSH
119004: LD_OWVAR 2
119008: PUSH
119009: EMPTY
119010: LIST
119011: LIST
119012: PPUSH
119013: CALL_OW 69
119017: ST_TO_ADDR
// if not tmp then
119018: LD_VAR 0 2
119022: NOT
119023: IFFALSE 119027
// exit ;
119025: GO 119170
// for i := 1 to 2 do
119027: LD_ADDR_VAR 0 1
119031: PUSH
119032: DOUBLE
119033: LD_INT 1
119035: DEC
119036: ST_TO_ADDR
119037: LD_INT 2
119039: PUSH
119040: FOR_TO
119041: IFFALSE 119168
// begin uc_side := your_side ;
119043: LD_ADDR_OWVAR 20
119047: PUSH
119048: LD_OWVAR 2
119052: ST_TO_ADDR
// uc_nation := nation_american ;
119053: LD_ADDR_OWVAR 21
119057: PUSH
119058: LD_INT 1
119060: ST_TO_ADDR
// vc_chassis := us_morphling ;
119061: LD_ADDR_OWVAR 37
119065: PUSH
119066: LD_INT 5
119068: ST_TO_ADDR
// vc_engine := engine_siberite ;
119069: LD_ADDR_OWVAR 39
119073: PUSH
119074: LD_INT 3
119076: ST_TO_ADDR
// vc_control := control_computer ;
119077: LD_ADDR_OWVAR 38
119081: PUSH
119082: LD_INT 3
119084: ST_TO_ADDR
// vc_weapon := us_double_laser ;
119085: LD_ADDR_OWVAR 40
119089: PUSH
119090: LD_INT 10
119092: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
119093: LD_VAR 0 2
119097: PUSH
119098: LD_INT 1
119100: ARRAY
119101: PPUSH
119102: CALL_OW 310
119106: NOT
119107: IFFALSE 119154
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
119109: CALL_OW 45
119113: PPUSH
119114: LD_VAR 0 2
119118: PUSH
119119: LD_INT 1
119121: ARRAY
119122: PPUSH
119123: CALL_OW 250
119127: PPUSH
119128: LD_VAR 0 2
119132: PUSH
119133: LD_INT 1
119135: ARRAY
119136: PPUSH
119137: CALL_OW 251
119141: PPUSH
119142: LD_INT 12
119144: PPUSH
119145: LD_INT 1
119147: PPUSH
119148: CALL_OW 50
119152: GO 119166
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
119154: CALL_OW 45
119158: PPUSH
119159: LD_INT 1
119161: PPUSH
119162: CALL_OW 51
// end ;
119166: GO 119040
119168: POP
119169: POP
// end ;
119170: PPOPN 2
119172: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
119173: LD_EXP 143
119177: PUSH
119178: LD_EXP 189
119182: AND
119183: IFFALSE 119405
119185: GO 119187
119187: DISABLE
119188: LD_INT 0
119190: PPUSH
119191: PPUSH
119192: PPUSH
119193: PPUSH
119194: PPUSH
119195: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
119196: LD_ADDR_VAR 0 6
119200: PUSH
119201: LD_INT 22
119203: PUSH
119204: LD_OWVAR 2
119208: PUSH
119209: EMPTY
119210: LIST
119211: LIST
119212: PUSH
119213: LD_INT 21
119215: PUSH
119216: LD_INT 1
119218: PUSH
119219: EMPTY
119220: LIST
119221: LIST
119222: PUSH
119223: LD_INT 3
119225: PUSH
119226: LD_INT 23
119228: PUSH
119229: LD_INT 0
119231: PUSH
119232: EMPTY
119233: LIST
119234: LIST
119235: PUSH
119236: EMPTY
119237: LIST
119238: LIST
119239: PUSH
119240: EMPTY
119241: LIST
119242: LIST
119243: LIST
119244: PPUSH
119245: CALL_OW 69
119249: ST_TO_ADDR
// if not tmp then
119250: LD_VAR 0 6
119254: NOT
119255: IFFALSE 119259
// exit ;
119257: GO 119405
// s1 := rand ( 1 , 4 ) ;
119259: LD_ADDR_VAR 0 2
119263: PUSH
119264: LD_INT 1
119266: PPUSH
119267: LD_INT 4
119269: PPUSH
119270: CALL_OW 12
119274: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
119275: LD_ADDR_VAR 0 4
119279: PUSH
119280: LD_VAR 0 6
119284: PUSH
119285: LD_INT 1
119287: ARRAY
119288: PPUSH
119289: LD_VAR 0 2
119293: PPUSH
119294: CALL_OW 259
119298: ST_TO_ADDR
// if s1 = 1 then
119299: LD_VAR 0 2
119303: PUSH
119304: LD_INT 1
119306: EQUAL
119307: IFFALSE 119327
// s2 := rand ( 2 , 4 ) else
119309: LD_ADDR_VAR 0 3
119313: PUSH
119314: LD_INT 2
119316: PPUSH
119317: LD_INT 4
119319: PPUSH
119320: CALL_OW 12
119324: ST_TO_ADDR
119325: GO 119335
// s2 := 1 ;
119327: LD_ADDR_VAR 0 3
119331: PUSH
119332: LD_INT 1
119334: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
119335: LD_ADDR_VAR 0 5
119339: PUSH
119340: LD_VAR 0 6
119344: PUSH
119345: LD_INT 1
119347: ARRAY
119348: PPUSH
119349: LD_VAR 0 3
119353: PPUSH
119354: CALL_OW 259
119358: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
119359: LD_VAR 0 6
119363: PUSH
119364: LD_INT 1
119366: ARRAY
119367: PPUSH
119368: LD_VAR 0 2
119372: PPUSH
119373: LD_VAR 0 5
119377: PPUSH
119378: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
119382: LD_VAR 0 6
119386: PUSH
119387: LD_INT 1
119389: ARRAY
119390: PPUSH
119391: LD_VAR 0 3
119395: PPUSH
119396: LD_VAR 0 4
119400: PPUSH
119401: CALL_OW 237
// end ;
119405: PPOPN 6
119407: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
119408: LD_EXP 143
119412: PUSH
119413: LD_EXP 190
119417: AND
119418: IFFALSE 119497
119420: GO 119422
119422: DISABLE
119423: LD_INT 0
119425: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
119426: LD_ADDR_VAR 0 1
119430: PUSH
119431: LD_INT 22
119433: PUSH
119434: LD_OWVAR 2
119438: PUSH
119439: EMPTY
119440: LIST
119441: LIST
119442: PUSH
119443: LD_INT 30
119445: PUSH
119446: LD_INT 3
119448: PUSH
119449: EMPTY
119450: LIST
119451: LIST
119452: PUSH
119453: EMPTY
119454: LIST
119455: LIST
119456: PPUSH
119457: CALL_OW 69
119461: ST_TO_ADDR
// if not tmp then
119462: LD_VAR 0 1
119466: NOT
119467: IFFALSE 119471
// exit ;
119469: GO 119497
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
119471: LD_VAR 0 1
119475: PUSH
119476: LD_INT 1
119478: PPUSH
119479: LD_VAR 0 1
119483: PPUSH
119484: CALL_OW 12
119488: ARRAY
119489: PPUSH
119490: LD_INT 1
119492: PPUSH
119493: CALL_OW 234
// end ;
119497: PPOPN 1
119499: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
119500: LD_EXP 143
119504: PUSH
119505: LD_EXP 191
119509: AND
119510: IFFALSE 119622
119512: GO 119514
119514: DISABLE
119515: LD_INT 0
119517: PPUSH
119518: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
119519: LD_ADDR_VAR 0 2
119523: PUSH
119524: LD_INT 22
119526: PUSH
119527: LD_OWVAR 2
119531: PUSH
119532: EMPTY
119533: LIST
119534: LIST
119535: PUSH
119536: LD_INT 2
119538: PUSH
119539: LD_INT 30
119541: PUSH
119542: LD_INT 27
119544: PUSH
119545: EMPTY
119546: LIST
119547: LIST
119548: PUSH
119549: LD_INT 30
119551: PUSH
119552: LD_INT 26
119554: PUSH
119555: EMPTY
119556: LIST
119557: LIST
119558: PUSH
119559: LD_INT 30
119561: PUSH
119562: LD_INT 28
119564: PUSH
119565: EMPTY
119566: LIST
119567: LIST
119568: PUSH
119569: EMPTY
119570: LIST
119571: LIST
119572: LIST
119573: LIST
119574: PUSH
119575: EMPTY
119576: LIST
119577: LIST
119578: PPUSH
119579: CALL_OW 69
119583: ST_TO_ADDR
// if not tmp then
119584: LD_VAR 0 2
119588: NOT
119589: IFFALSE 119593
// exit ;
119591: GO 119622
// for i in tmp do
119593: LD_ADDR_VAR 0 1
119597: PUSH
119598: LD_VAR 0 2
119602: PUSH
119603: FOR_IN
119604: IFFALSE 119620
// SetLives ( i , 1 ) ;
119606: LD_VAR 0 1
119610: PPUSH
119611: LD_INT 1
119613: PPUSH
119614: CALL_OW 234
119618: GO 119603
119620: POP
119621: POP
// end ;
119622: PPOPN 2
119624: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
119625: LD_EXP 143
119629: PUSH
119630: LD_EXP 192
119634: AND
119635: IFFALSE 119922
119637: GO 119639
119639: DISABLE
119640: LD_INT 0
119642: PPUSH
119643: PPUSH
119644: PPUSH
// begin i := rand ( 1 , 7 ) ;
119645: LD_ADDR_VAR 0 1
119649: PUSH
119650: LD_INT 1
119652: PPUSH
119653: LD_INT 7
119655: PPUSH
119656: CALL_OW 12
119660: ST_TO_ADDR
// case i of 1 :
119661: LD_VAR 0 1
119665: PUSH
119666: LD_INT 1
119668: DOUBLE
119669: EQUAL
119670: IFTRUE 119674
119672: GO 119684
119674: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
119675: LD_STRING earthquake(getX(game), 0, 32)
119677: PPUSH
119678: CALL_OW 559
119682: GO 119922
119684: LD_INT 2
119686: DOUBLE
119687: EQUAL
119688: IFTRUE 119692
119690: GO 119706
119692: POP
// begin ToLua ( displayStucuk(); ) ;
119693: LD_STRING displayStucuk();
119695: PPUSH
119696: CALL_OW 559
// ResetFog ;
119700: CALL_OW 335
// end ; 3 :
119704: GO 119922
119706: LD_INT 3
119708: DOUBLE
119709: EQUAL
119710: IFTRUE 119714
119712: GO 119818
119714: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
119715: LD_ADDR_VAR 0 2
119719: PUSH
119720: LD_INT 22
119722: PUSH
119723: LD_OWVAR 2
119727: PUSH
119728: EMPTY
119729: LIST
119730: LIST
119731: PUSH
119732: LD_INT 25
119734: PUSH
119735: LD_INT 1
119737: PUSH
119738: EMPTY
119739: LIST
119740: LIST
119741: PUSH
119742: EMPTY
119743: LIST
119744: LIST
119745: PPUSH
119746: CALL_OW 69
119750: ST_TO_ADDR
// if not tmp then
119751: LD_VAR 0 2
119755: NOT
119756: IFFALSE 119760
// exit ;
119758: GO 119922
// un := tmp [ rand ( 1 , tmp ) ] ;
119760: LD_ADDR_VAR 0 3
119764: PUSH
119765: LD_VAR 0 2
119769: PUSH
119770: LD_INT 1
119772: PPUSH
119773: LD_VAR 0 2
119777: PPUSH
119778: CALL_OW 12
119782: ARRAY
119783: ST_TO_ADDR
// if Crawls ( un ) then
119784: LD_VAR 0 3
119788: PPUSH
119789: CALL_OW 318
119793: IFFALSE 119804
// ComWalk ( un ) ;
119795: LD_VAR 0 3
119799: PPUSH
119800: CALL_OW 138
// SetClass ( un , class_mortar ) ;
119804: LD_VAR 0 3
119808: PPUSH
119809: LD_INT 8
119811: PPUSH
119812: CALL_OW 336
// end ; 4 :
119816: GO 119922
119818: LD_INT 4
119820: DOUBLE
119821: EQUAL
119822: IFTRUE 119826
119824: GO 119900
119826: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
119827: LD_ADDR_VAR 0 2
119831: PUSH
119832: LD_INT 22
119834: PUSH
119835: LD_OWVAR 2
119839: PUSH
119840: EMPTY
119841: LIST
119842: LIST
119843: PUSH
119844: LD_INT 30
119846: PUSH
119847: LD_INT 29
119849: PUSH
119850: EMPTY
119851: LIST
119852: LIST
119853: PUSH
119854: EMPTY
119855: LIST
119856: LIST
119857: PPUSH
119858: CALL_OW 69
119862: ST_TO_ADDR
// if not tmp then
119863: LD_VAR 0 2
119867: NOT
119868: IFFALSE 119872
// exit ;
119870: GO 119922
// CenterNowOnUnits ( tmp [ 1 ] ) ;
119872: LD_VAR 0 2
119876: PUSH
119877: LD_INT 1
119879: ARRAY
119880: PPUSH
119881: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
119885: LD_VAR 0 2
119889: PUSH
119890: LD_INT 1
119892: ARRAY
119893: PPUSH
119894: CALL_OW 65
// end ; 5 .. 7 :
119898: GO 119922
119900: LD_INT 5
119902: DOUBLE
119903: GREATEREQUAL
119904: IFFALSE 119912
119906: LD_INT 7
119908: DOUBLE
119909: LESSEQUAL
119910: IFTRUE 119914
119912: GO 119921
119914: POP
// StreamSibBomb ; end ;
119915: CALL 116159 0 0
119919: GO 119922
119921: POP
// end ;
119922: PPOPN 3
119924: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
119925: LD_EXP 143
119929: PUSH
119930: LD_EXP 193
119934: AND
119935: IFFALSE 120091
119937: GO 119939
119939: DISABLE
119940: LD_INT 0
119942: PPUSH
119943: PPUSH
119944: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
119945: LD_ADDR_VAR 0 2
119949: PUSH
119950: LD_INT 81
119952: PUSH
119953: LD_OWVAR 2
119957: PUSH
119958: EMPTY
119959: LIST
119960: LIST
119961: PUSH
119962: LD_INT 2
119964: PUSH
119965: LD_INT 21
119967: PUSH
119968: LD_INT 1
119970: PUSH
119971: EMPTY
119972: LIST
119973: LIST
119974: PUSH
119975: LD_INT 21
119977: PUSH
119978: LD_INT 2
119980: PUSH
119981: EMPTY
119982: LIST
119983: LIST
119984: PUSH
119985: EMPTY
119986: LIST
119987: LIST
119988: LIST
119989: PUSH
119990: EMPTY
119991: LIST
119992: LIST
119993: PPUSH
119994: CALL_OW 69
119998: ST_TO_ADDR
// if not tmp then
119999: LD_VAR 0 2
120003: NOT
120004: IFFALSE 120008
// exit ;
120006: GO 120091
// p := 0 ;
120008: LD_ADDR_VAR 0 3
120012: PUSH
120013: LD_INT 0
120015: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
120016: LD_INT 35
120018: PPUSH
120019: CALL_OW 67
// p := p + 1 ;
120023: LD_ADDR_VAR 0 3
120027: PUSH
120028: LD_VAR 0 3
120032: PUSH
120033: LD_INT 1
120035: PLUS
120036: ST_TO_ADDR
// for i in tmp do
120037: LD_ADDR_VAR 0 1
120041: PUSH
120042: LD_VAR 0 2
120046: PUSH
120047: FOR_IN
120048: IFFALSE 120079
// if GetLives ( i ) < 1000 then
120050: LD_VAR 0 1
120054: PPUSH
120055: CALL_OW 256
120059: PUSH
120060: LD_INT 1000
120062: LESS
120063: IFFALSE 120077
// SetLives ( i , 1000 ) ;
120065: LD_VAR 0 1
120069: PPUSH
120070: LD_INT 1000
120072: PPUSH
120073: CALL_OW 234
120077: GO 120047
120079: POP
120080: POP
// until p > 20 ;
120081: LD_VAR 0 3
120085: PUSH
120086: LD_INT 20
120088: GREATER
120089: IFFALSE 120016
// end ;
120091: PPOPN 3
120093: END
// every 0 0$1 trigger StreamModeActive and sTime do
120094: LD_EXP 143
120098: PUSH
120099: LD_EXP 194
120103: AND
120104: IFFALSE 120139
120106: GO 120108
120108: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
120109: LD_INT 28
120111: PPUSH
120112: LD_OWVAR 2
120116: PPUSH
120117: LD_INT 2
120119: PPUSH
120120: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
120124: LD_INT 30
120126: PPUSH
120127: LD_OWVAR 2
120131: PPUSH
120132: LD_INT 2
120134: PPUSH
120135: CALL_OW 322
// end ;
120139: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
120140: LD_EXP 143
120144: PUSH
120145: LD_EXP 195
120149: AND
120150: IFFALSE 120271
120152: GO 120154
120154: DISABLE
120155: LD_INT 0
120157: PPUSH
120158: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
120159: LD_ADDR_VAR 0 2
120163: PUSH
120164: LD_INT 22
120166: PUSH
120167: LD_OWVAR 2
120171: PUSH
120172: EMPTY
120173: LIST
120174: LIST
120175: PUSH
120176: LD_INT 21
120178: PUSH
120179: LD_INT 1
120181: PUSH
120182: EMPTY
120183: LIST
120184: LIST
120185: PUSH
120186: LD_INT 3
120188: PUSH
120189: LD_INT 23
120191: PUSH
120192: LD_INT 0
120194: PUSH
120195: EMPTY
120196: LIST
120197: LIST
120198: PUSH
120199: EMPTY
120200: LIST
120201: LIST
120202: PUSH
120203: EMPTY
120204: LIST
120205: LIST
120206: LIST
120207: PPUSH
120208: CALL_OW 69
120212: ST_TO_ADDR
// if not tmp then
120213: LD_VAR 0 2
120217: NOT
120218: IFFALSE 120222
// exit ;
120220: GO 120271
// for i in tmp do
120222: LD_ADDR_VAR 0 1
120226: PUSH
120227: LD_VAR 0 2
120231: PUSH
120232: FOR_IN
120233: IFFALSE 120269
// begin if Crawls ( i ) then
120235: LD_VAR 0 1
120239: PPUSH
120240: CALL_OW 318
120244: IFFALSE 120255
// ComWalk ( i ) ;
120246: LD_VAR 0 1
120250: PPUSH
120251: CALL_OW 138
// SetClass ( i , 2 ) ;
120255: LD_VAR 0 1
120259: PPUSH
120260: LD_INT 2
120262: PPUSH
120263: CALL_OW 336
// end ;
120267: GO 120232
120269: POP
120270: POP
// end ;
120271: PPOPN 2
120273: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
120274: LD_EXP 143
120278: PUSH
120279: LD_EXP 196
120283: AND
120284: IFFALSE 120572
120286: GO 120288
120288: DISABLE
120289: LD_INT 0
120291: PPUSH
120292: PPUSH
120293: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
120294: LD_OWVAR 2
120298: PPUSH
120299: LD_INT 9
120301: PPUSH
120302: LD_INT 1
120304: PPUSH
120305: LD_INT 1
120307: PPUSH
120308: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
120312: LD_INT 9
120314: PPUSH
120315: LD_OWVAR 2
120319: PPUSH
120320: CALL_OW 343
// uc_side := 9 ;
120324: LD_ADDR_OWVAR 20
120328: PUSH
120329: LD_INT 9
120331: ST_TO_ADDR
// uc_nation := 2 ;
120332: LD_ADDR_OWVAR 21
120336: PUSH
120337: LD_INT 2
120339: ST_TO_ADDR
// hc_name := Dark Warrior ;
120340: LD_ADDR_OWVAR 26
120344: PUSH
120345: LD_STRING Dark Warrior
120347: ST_TO_ADDR
// hc_gallery :=  ;
120348: LD_ADDR_OWVAR 33
120352: PUSH
120353: LD_STRING 
120355: ST_TO_ADDR
// hc_noskilllimit := true ;
120356: LD_ADDR_OWVAR 76
120360: PUSH
120361: LD_INT 1
120363: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
120364: LD_ADDR_OWVAR 31
120368: PUSH
120369: LD_INT 30
120371: PUSH
120372: LD_INT 30
120374: PUSH
120375: LD_INT 30
120377: PUSH
120378: LD_INT 30
120380: PUSH
120381: EMPTY
120382: LIST
120383: LIST
120384: LIST
120385: LIST
120386: ST_TO_ADDR
// un := CreateHuman ;
120387: LD_ADDR_VAR 0 3
120391: PUSH
120392: CALL_OW 44
120396: ST_TO_ADDR
// hc_noskilllimit := false ;
120397: LD_ADDR_OWVAR 76
120401: PUSH
120402: LD_INT 0
120404: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
120405: LD_VAR 0 3
120409: PPUSH
120410: LD_INT 1
120412: PPUSH
120413: CALL_OW 51
// ToLua ( playRanger() ) ;
120417: LD_STRING playRanger()
120419: PPUSH
120420: CALL_OW 559
// p := 0 ;
120424: LD_ADDR_VAR 0 2
120428: PUSH
120429: LD_INT 0
120431: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
120432: LD_INT 35
120434: PPUSH
120435: CALL_OW 67
// p := p + 1 ;
120439: LD_ADDR_VAR 0 2
120443: PUSH
120444: LD_VAR 0 2
120448: PUSH
120449: LD_INT 1
120451: PLUS
120452: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
120453: LD_VAR 0 3
120457: PPUSH
120458: CALL_OW 256
120462: PUSH
120463: LD_INT 1000
120465: LESS
120466: IFFALSE 120480
// SetLives ( un , 1000 ) ;
120468: LD_VAR 0 3
120472: PPUSH
120473: LD_INT 1000
120475: PPUSH
120476: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
120480: LD_VAR 0 3
120484: PPUSH
120485: LD_INT 81
120487: PUSH
120488: LD_OWVAR 2
120492: PUSH
120493: EMPTY
120494: LIST
120495: LIST
120496: PUSH
120497: LD_INT 91
120499: PUSH
120500: LD_VAR 0 3
120504: PUSH
120505: LD_INT 30
120507: PUSH
120508: EMPTY
120509: LIST
120510: LIST
120511: LIST
120512: PUSH
120513: EMPTY
120514: LIST
120515: LIST
120516: PPUSH
120517: CALL_OW 69
120521: PPUSH
120522: LD_VAR 0 3
120526: PPUSH
120527: CALL_OW 74
120531: PPUSH
120532: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
120536: LD_VAR 0 2
120540: PUSH
120541: LD_INT 80
120543: GREATER
120544: PUSH
120545: LD_VAR 0 3
120549: PPUSH
120550: CALL_OW 301
120554: OR
120555: IFFALSE 120432
// if un then
120557: LD_VAR 0 3
120561: IFFALSE 120572
// RemoveUnit ( un ) ;
120563: LD_VAR 0 3
120567: PPUSH
120568: CALL_OW 64
// end ;
120572: PPOPN 3
120574: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
120575: LD_EXP 197
120579: IFFALSE 120695
120581: GO 120583
120583: DISABLE
120584: LD_INT 0
120586: PPUSH
120587: PPUSH
120588: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
120589: LD_ADDR_VAR 0 2
120593: PUSH
120594: LD_INT 81
120596: PUSH
120597: LD_OWVAR 2
120601: PUSH
120602: EMPTY
120603: LIST
120604: LIST
120605: PUSH
120606: LD_INT 21
120608: PUSH
120609: LD_INT 1
120611: PUSH
120612: EMPTY
120613: LIST
120614: LIST
120615: PUSH
120616: EMPTY
120617: LIST
120618: LIST
120619: PPUSH
120620: CALL_OW 69
120624: ST_TO_ADDR
// ToLua ( playComputer() ) ;
120625: LD_STRING playComputer()
120627: PPUSH
120628: CALL_OW 559
// if not tmp then
120632: LD_VAR 0 2
120636: NOT
120637: IFFALSE 120641
// exit ;
120639: GO 120695
// for i in tmp do
120641: LD_ADDR_VAR 0 1
120645: PUSH
120646: LD_VAR 0 2
120650: PUSH
120651: FOR_IN
120652: IFFALSE 120693
// for j := 1 to 4 do
120654: LD_ADDR_VAR 0 3
120658: PUSH
120659: DOUBLE
120660: LD_INT 1
120662: DEC
120663: ST_TO_ADDR
120664: LD_INT 4
120666: PUSH
120667: FOR_TO
120668: IFFALSE 120689
// SetSkill ( i , j , 10 ) ;
120670: LD_VAR 0 1
120674: PPUSH
120675: LD_VAR 0 3
120679: PPUSH
120680: LD_INT 10
120682: PPUSH
120683: CALL_OW 237
120687: GO 120667
120689: POP
120690: POP
120691: GO 120651
120693: POP
120694: POP
// end ;
120695: PPOPN 3
120697: END
// every 0 0$1 trigger s30 do var i , tmp ;
120698: LD_EXP 198
120702: IFFALSE 120771
120704: GO 120706
120706: DISABLE
120707: LD_INT 0
120709: PPUSH
120710: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
120711: LD_ADDR_VAR 0 2
120715: PUSH
120716: LD_INT 22
120718: PUSH
120719: LD_OWVAR 2
120723: PUSH
120724: EMPTY
120725: LIST
120726: LIST
120727: PPUSH
120728: CALL_OW 69
120732: ST_TO_ADDR
// if not tmp then
120733: LD_VAR 0 2
120737: NOT
120738: IFFALSE 120742
// exit ;
120740: GO 120771
// for i in tmp do
120742: LD_ADDR_VAR 0 1
120746: PUSH
120747: LD_VAR 0 2
120751: PUSH
120752: FOR_IN
120753: IFFALSE 120769
// SetLives ( i , 300 ) ;
120755: LD_VAR 0 1
120759: PPUSH
120760: LD_INT 300
120762: PPUSH
120763: CALL_OW 234
120767: GO 120752
120769: POP
120770: POP
// end ;
120771: PPOPN 2
120773: END
// every 0 0$1 trigger s60 do var i , tmp ;
120774: LD_EXP 199
120778: IFFALSE 120847
120780: GO 120782
120782: DISABLE
120783: LD_INT 0
120785: PPUSH
120786: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
120787: LD_ADDR_VAR 0 2
120791: PUSH
120792: LD_INT 22
120794: PUSH
120795: LD_OWVAR 2
120799: PUSH
120800: EMPTY
120801: LIST
120802: LIST
120803: PPUSH
120804: CALL_OW 69
120808: ST_TO_ADDR
// if not tmp then
120809: LD_VAR 0 2
120813: NOT
120814: IFFALSE 120818
// exit ;
120816: GO 120847
// for i in tmp do
120818: LD_ADDR_VAR 0 1
120822: PUSH
120823: LD_VAR 0 2
120827: PUSH
120828: FOR_IN
120829: IFFALSE 120845
// SetLives ( i , 600 ) ;
120831: LD_VAR 0 1
120835: PPUSH
120836: LD_INT 600
120838: PPUSH
120839: CALL_OW 234
120843: GO 120828
120845: POP
120846: POP
// end ;
120847: PPOPN 2
120849: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
120850: LD_INT 0
120852: PPUSH
// case cmd of 301 :
120853: LD_VAR 0 1
120857: PUSH
120858: LD_INT 301
120860: DOUBLE
120861: EQUAL
120862: IFTRUE 120866
120864: GO 120898
120866: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
120867: LD_VAR 0 6
120871: PPUSH
120872: LD_VAR 0 7
120876: PPUSH
120877: LD_VAR 0 8
120881: PPUSH
120882: LD_VAR 0 4
120886: PPUSH
120887: LD_VAR 0 5
120891: PPUSH
120892: CALL 122099 0 5
120896: GO 121019
120898: LD_INT 302
120900: DOUBLE
120901: EQUAL
120902: IFTRUE 120906
120904: GO 120943
120906: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
120907: LD_VAR 0 6
120911: PPUSH
120912: LD_VAR 0 7
120916: PPUSH
120917: LD_VAR 0 8
120921: PPUSH
120922: LD_VAR 0 9
120926: PPUSH
120927: LD_VAR 0 4
120931: PPUSH
120932: LD_VAR 0 5
120936: PPUSH
120937: CALL 122190 0 6
120941: GO 121019
120943: LD_INT 303
120945: DOUBLE
120946: EQUAL
120947: IFTRUE 120951
120949: GO 120988
120951: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
120952: LD_VAR 0 6
120956: PPUSH
120957: LD_VAR 0 7
120961: PPUSH
120962: LD_VAR 0 8
120966: PPUSH
120967: LD_VAR 0 9
120971: PPUSH
120972: LD_VAR 0 4
120976: PPUSH
120977: LD_VAR 0 5
120981: PPUSH
120982: CALL 121024 0 6
120986: GO 121019
120988: LD_INT 304
120990: DOUBLE
120991: EQUAL
120992: IFTRUE 120996
120994: GO 121018
120996: POP
// hHackTeleport ( unit , x , y ) ; end ;
120997: LD_VAR 0 2
121001: PPUSH
121002: LD_VAR 0 4
121006: PPUSH
121007: LD_VAR 0 5
121011: PPUSH
121012: CALL 122783 0 3
121016: GO 121019
121018: POP
// end ;
121019: LD_VAR 0 12
121023: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
121024: LD_INT 0
121026: PPUSH
121027: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
121028: LD_VAR 0 1
121032: PUSH
121033: LD_INT 1
121035: LESS
121036: PUSH
121037: LD_VAR 0 1
121041: PUSH
121042: LD_INT 3
121044: GREATER
121045: OR
121046: PUSH
121047: LD_VAR 0 5
121051: PPUSH
121052: LD_VAR 0 6
121056: PPUSH
121057: CALL_OW 428
121061: OR
121062: IFFALSE 121066
// exit ;
121064: GO 121786
// uc_side := your_side ;
121066: LD_ADDR_OWVAR 20
121070: PUSH
121071: LD_OWVAR 2
121075: ST_TO_ADDR
// uc_nation := nation ;
121076: LD_ADDR_OWVAR 21
121080: PUSH
121081: LD_VAR 0 1
121085: ST_TO_ADDR
// bc_level = 1 ;
121086: LD_ADDR_OWVAR 43
121090: PUSH
121091: LD_INT 1
121093: ST_TO_ADDR
// case btype of 1 :
121094: LD_VAR 0 2
121098: PUSH
121099: LD_INT 1
121101: DOUBLE
121102: EQUAL
121103: IFTRUE 121107
121105: GO 121118
121107: POP
// bc_type := b_depot ; 2 :
121108: LD_ADDR_OWVAR 42
121112: PUSH
121113: LD_INT 0
121115: ST_TO_ADDR
121116: GO 121730
121118: LD_INT 2
121120: DOUBLE
121121: EQUAL
121122: IFTRUE 121126
121124: GO 121137
121126: POP
// bc_type := b_warehouse ; 3 :
121127: LD_ADDR_OWVAR 42
121131: PUSH
121132: LD_INT 1
121134: ST_TO_ADDR
121135: GO 121730
121137: LD_INT 3
121139: DOUBLE
121140: EQUAL
121141: IFTRUE 121145
121143: GO 121156
121145: POP
// bc_type := b_lab ; 4 .. 9 :
121146: LD_ADDR_OWVAR 42
121150: PUSH
121151: LD_INT 6
121153: ST_TO_ADDR
121154: GO 121730
121156: LD_INT 4
121158: DOUBLE
121159: GREATEREQUAL
121160: IFFALSE 121168
121162: LD_INT 9
121164: DOUBLE
121165: LESSEQUAL
121166: IFTRUE 121170
121168: GO 121222
121170: POP
// begin bc_type := b_lab_half ;
121171: LD_ADDR_OWVAR 42
121175: PUSH
121176: LD_INT 7
121178: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
121179: LD_ADDR_OWVAR 44
121183: PUSH
121184: LD_INT 10
121186: PUSH
121187: LD_INT 11
121189: PUSH
121190: LD_INT 12
121192: PUSH
121193: LD_INT 15
121195: PUSH
121196: LD_INT 14
121198: PUSH
121199: LD_INT 13
121201: PUSH
121202: EMPTY
121203: LIST
121204: LIST
121205: LIST
121206: LIST
121207: LIST
121208: LIST
121209: PUSH
121210: LD_VAR 0 2
121214: PUSH
121215: LD_INT 3
121217: MINUS
121218: ARRAY
121219: ST_TO_ADDR
// end ; 10 .. 13 :
121220: GO 121730
121222: LD_INT 10
121224: DOUBLE
121225: GREATEREQUAL
121226: IFFALSE 121234
121228: LD_INT 13
121230: DOUBLE
121231: LESSEQUAL
121232: IFTRUE 121236
121234: GO 121313
121236: POP
// begin bc_type := b_lab_full ;
121237: LD_ADDR_OWVAR 42
121241: PUSH
121242: LD_INT 8
121244: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
121245: LD_ADDR_OWVAR 44
121249: PUSH
121250: LD_INT 10
121252: PUSH
121253: LD_INT 12
121255: PUSH
121256: LD_INT 14
121258: PUSH
121259: LD_INT 13
121261: PUSH
121262: EMPTY
121263: LIST
121264: LIST
121265: LIST
121266: LIST
121267: PUSH
121268: LD_VAR 0 2
121272: PUSH
121273: LD_INT 9
121275: MINUS
121276: ARRAY
121277: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
121278: LD_ADDR_OWVAR 45
121282: PUSH
121283: LD_INT 11
121285: PUSH
121286: LD_INT 15
121288: PUSH
121289: LD_INT 12
121291: PUSH
121292: LD_INT 15
121294: PUSH
121295: EMPTY
121296: LIST
121297: LIST
121298: LIST
121299: LIST
121300: PUSH
121301: LD_VAR 0 2
121305: PUSH
121306: LD_INT 9
121308: MINUS
121309: ARRAY
121310: ST_TO_ADDR
// end ; 14 :
121311: GO 121730
121313: LD_INT 14
121315: DOUBLE
121316: EQUAL
121317: IFTRUE 121321
121319: GO 121332
121321: POP
// bc_type := b_workshop ; 15 :
121322: LD_ADDR_OWVAR 42
121326: PUSH
121327: LD_INT 2
121329: ST_TO_ADDR
121330: GO 121730
121332: LD_INT 15
121334: DOUBLE
121335: EQUAL
121336: IFTRUE 121340
121338: GO 121351
121340: POP
// bc_type := b_factory ; 16 :
121341: LD_ADDR_OWVAR 42
121345: PUSH
121346: LD_INT 3
121348: ST_TO_ADDR
121349: GO 121730
121351: LD_INT 16
121353: DOUBLE
121354: EQUAL
121355: IFTRUE 121359
121357: GO 121370
121359: POP
// bc_type := b_ext_gun ; 17 :
121360: LD_ADDR_OWVAR 42
121364: PUSH
121365: LD_INT 17
121367: ST_TO_ADDR
121368: GO 121730
121370: LD_INT 17
121372: DOUBLE
121373: EQUAL
121374: IFTRUE 121378
121376: GO 121406
121378: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
121379: LD_ADDR_OWVAR 42
121383: PUSH
121384: LD_INT 19
121386: PUSH
121387: LD_INT 23
121389: PUSH
121390: LD_INT 19
121392: PUSH
121393: EMPTY
121394: LIST
121395: LIST
121396: LIST
121397: PUSH
121398: LD_VAR 0 1
121402: ARRAY
121403: ST_TO_ADDR
121404: GO 121730
121406: LD_INT 18
121408: DOUBLE
121409: EQUAL
121410: IFTRUE 121414
121412: GO 121425
121414: POP
// bc_type := b_ext_radar ; 19 :
121415: LD_ADDR_OWVAR 42
121419: PUSH
121420: LD_INT 20
121422: ST_TO_ADDR
121423: GO 121730
121425: LD_INT 19
121427: DOUBLE
121428: EQUAL
121429: IFTRUE 121433
121431: GO 121444
121433: POP
// bc_type := b_ext_radio ; 20 :
121434: LD_ADDR_OWVAR 42
121438: PUSH
121439: LD_INT 22
121441: ST_TO_ADDR
121442: GO 121730
121444: LD_INT 20
121446: DOUBLE
121447: EQUAL
121448: IFTRUE 121452
121450: GO 121463
121452: POP
// bc_type := b_ext_siberium ; 21 :
121453: LD_ADDR_OWVAR 42
121457: PUSH
121458: LD_INT 21
121460: ST_TO_ADDR
121461: GO 121730
121463: LD_INT 21
121465: DOUBLE
121466: EQUAL
121467: IFTRUE 121471
121469: GO 121482
121471: POP
// bc_type := b_ext_computer ; 22 :
121472: LD_ADDR_OWVAR 42
121476: PUSH
121477: LD_INT 24
121479: ST_TO_ADDR
121480: GO 121730
121482: LD_INT 22
121484: DOUBLE
121485: EQUAL
121486: IFTRUE 121490
121488: GO 121501
121490: POP
// bc_type := b_ext_track ; 23 :
121491: LD_ADDR_OWVAR 42
121495: PUSH
121496: LD_INT 16
121498: ST_TO_ADDR
121499: GO 121730
121501: LD_INT 23
121503: DOUBLE
121504: EQUAL
121505: IFTRUE 121509
121507: GO 121520
121509: POP
// bc_type := b_ext_laser ; 24 :
121510: LD_ADDR_OWVAR 42
121514: PUSH
121515: LD_INT 25
121517: ST_TO_ADDR
121518: GO 121730
121520: LD_INT 24
121522: DOUBLE
121523: EQUAL
121524: IFTRUE 121528
121526: GO 121539
121528: POP
// bc_type := b_control_tower ; 25 :
121529: LD_ADDR_OWVAR 42
121533: PUSH
121534: LD_INT 36
121536: ST_TO_ADDR
121537: GO 121730
121539: LD_INT 25
121541: DOUBLE
121542: EQUAL
121543: IFTRUE 121547
121545: GO 121558
121547: POP
// bc_type := b_breastwork ; 26 :
121548: LD_ADDR_OWVAR 42
121552: PUSH
121553: LD_INT 31
121555: ST_TO_ADDR
121556: GO 121730
121558: LD_INT 26
121560: DOUBLE
121561: EQUAL
121562: IFTRUE 121566
121564: GO 121577
121566: POP
// bc_type := b_bunker ; 27 :
121567: LD_ADDR_OWVAR 42
121571: PUSH
121572: LD_INT 32
121574: ST_TO_ADDR
121575: GO 121730
121577: LD_INT 27
121579: DOUBLE
121580: EQUAL
121581: IFTRUE 121585
121583: GO 121596
121585: POP
// bc_type := b_turret ; 28 :
121586: LD_ADDR_OWVAR 42
121590: PUSH
121591: LD_INT 33
121593: ST_TO_ADDR
121594: GO 121730
121596: LD_INT 28
121598: DOUBLE
121599: EQUAL
121600: IFTRUE 121604
121602: GO 121615
121604: POP
// bc_type := b_armoury ; 29 :
121605: LD_ADDR_OWVAR 42
121609: PUSH
121610: LD_INT 4
121612: ST_TO_ADDR
121613: GO 121730
121615: LD_INT 29
121617: DOUBLE
121618: EQUAL
121619: IFTRUE 121623
121621: GO 121634
121623: POP
// bc_type := b_barracks ; 30 :
121624: LD_ADDR_OWVAR 42
121628: PUSH
121629: LD_INT 5
121631: ST_TO_ADDR
121632: GO 121730
121634: LD_INT 30
121636: DOUBLE
121637: EQUAL
121638: IFTRUE 121642
121640: GO 121653
121642: POP
// bc_type := b_solar_power ; 31 :
121643: LD_ADDR_OWVAR 42
121647: PUSH
121648: LD_INT 27
121650: ST_TO_ADDR
121651: GO 121730
121653: LD_INT 31
121655: DOUBLE
121656: EQUAL
121657: IFTRUE 121661
121659: GO 121672
121661: POP
// bc_type := b_oil_power ; 32 :
121662: LD_ADDR_OWVAR 42
121666: PUSH
121667: LD_INT 26
121669: ST_TO_ADDR
121670: GO 121730
121672: LD_INT 32
121674: DOUBLE
121675: EQUAL
121676: IFTRUE 121680
121678: GO 121691
121680: POP
// bc_type := b_siberite_power ; 33 :
121681: LD_ADDR_OWVAR 42
121685: PUSH
121686: LD_INT 28
121688: ST_TO_ADDR
121689: GO 121730
121691: LD_INT 33
121693: DOUBLE
121694: EQUAL
121695: IFTRUE 121699
121697: GO 121710
121699: POP
// bc_type := b_oil_mine ; 34 :
121700: LD_ADDR_OWVAR 42
121704: PUSH
121705: LD_INT 29
121707: ST_TO_ADDR
121708: GO 121730
121710: LD_INT 34
121712: DOUBLE
121713: EQUAL
121714: IFTRUE 121718
121716: GO 121729
121718: POP
// bc_type := b_siberite_mine ; end ;
121719: LD_ADDR_OWVAR 42
121723: PUSH
121724: LD_INT 30
121726: ST_TO_ADDR
121727: GO 121730
121729: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
121730: LD_ADDR_VAR 0 8
121734: PUSH
121735: LD_VAR 0 5
121739: PPUSH
121740: LD_VAR 0 6
121744: PPUSH
121745: LD_VAR 0 3
121749: PPUSH
121750: CALL_OW 47
121754: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
121755: LD_OWVAR 42
121759: PUSH
121760: LD_INT 32
121762: PUSH
121763: LD_INT 33
121765: PUSH
121766: EMPTY
121767: LIST
121768: LIST
121769: IN
121770: IFFALSE 121786
// PlaceWeaponTurret ( b , weapon ) ;
121772: LD_VAR 0 8
121776: PPUSH
121777: LD_VAR 0 4
121781: PPUSH
121782: CALL_OW 431
// end ;
121786: LD_VAR 0 7
121790: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
121791: LD_INT 0
121793: PPUSH
121794: PPUSH
121795: PPUSH
121796: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
121797: LD_ADDR_VAR 0 4
121801: PUSH
121802: LD_INT 22
121804: PUSH
121805: LD_OWVAR 2
121809: PUSH
121810: EMPTY
121811: LIST
121812: LIST
121813: PUSH
121814: LD_INT 2
121816: PUSH
121817: LD_INT 30
121819: PUSH
121820: LD_INT 0
121822: PUSH
121823: EMPTY
121824: LIST
121825: LIST
121826: PUSH
121827: LD_INT 30
121829: PUSH
121830: LD_INT 1
121832: PUSH
121833: EMPTY
121834: LIST
121835: LIST
121836: PUSH
121837: EMPTY
121838: LIST
121839: LIST
121840: LIST
121841: PUSH
121842: EMPTY
121843: LIST
121844: LIST
121845: PPUSH
121846: CALL_OW 69
121850: ST_TO_ADDR
// if not tmp then
121851: LD_VAR 0 4
121855: NOT
121856: IFFALSE 121860
// exit ;
121858: GO 121919
// for i in tmp do
121860: LD_ADDR_VAR 0 2
121864: PUSH
121865: LD_VAR 0 4
121869: PUSH
121870: FOR_IN
121871: IFFALSE 121917
// for j = 1 to 3 do
121873: LD_ADDR_VAR 0 3
121877: PUSH
121878: DOUBLE
121879: LD_INT 1
121881: DEC
121882: ST_TO_ADDR
121883: LD_INT 3
121885: PUSH
121886: FOR_TO
121887: IFFALSE 121913
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
121889: LD_VAR 0 2
121893: PPUSH
121894: CALL_OW 274
121898: PPUSH
121899: LD_VAR 0 3
121903: PPUSH
121904: LD_INT 99999
121906: PPUSH
121907: CALL_OW 277
121911: GO 121886
121913: POP
121914: POP
121915: GO 121870
121917: POP
121918: POP
// end ;
121919: LD_VAR 0 1
121923: RET
// export function hHackSetLevel10 ; var i , j ; begin
121924: LD_INT 0
121926: PPUSH
121927: PPUSH
121928: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
121929: LD_ADDR_VAR 0 2
121933: PUSH
121934: LD_INT 21
121936: PUSH
121937: LD_INT 1
121939: PUSH
121940: EMPTY
121941: LIST
121942: LIST
121943: PPUSH
121944: CALL_OW 69
121948: PUSH
121949: FOR_IN
121950: IFFALSE 122002
// if IsSelected ( i ) then
121952: LD_VAR 0 2
121956: PPUSH
121957: CALL_OW 306
121961: IFFALSE 122000
// begin for j := 1 to 4 do
121963: LD_ADDR_VAR 0 3
121967: PUSH
121968: DOUBLE
121969: LD_INT 1
121971: DEC
121972: ST_TO_ADDR
121973: LD_INT 4
121975: PUSH
121976: FOR_TO
121977: IFFALSE 121998
// SetSkill ( i , j , 10 ) ;
121979: LD_VAR 0 2
121983: PPUSH
121984: LD_VAR 0 3
121988: PPUSH
121989: LD_INT 10
121991: PPUSH
121992: CALL_OW 237
121996: GO 121976
121998: POP
121999: POP
// end ;
122000: GO 121949
122002: POP
122003: POP
// end ;
122004: LD_VAR 0 1
122008: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
122009: LD_INT 0
122011: PPUSH
122012: PPUSH
122013: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
122014: LD_ADDR_VAR 0 2
122018: PUSH
122019: LD_INT 22
122021: PUSH
122022: LD_OWVAR 2
122026: PUSH
122027: EMPTY
122028: LIST
122029: LIST
122030: PUSH
122031: LD_INT 21
122033: PUSH
122034: LD_INT 1
122036: PUSH
122037: EMPTY
122038: LIST
122039: LIST
122040: PUSH
122041: EMPTY
122042: LIST
122043: LIST
122044: PPUSH
122045: CALL_OW 69
122049: PUSH
122050: FOR_IN
122051: IFFALSE 122092
// begin for j := 1 to 4 do
122053: LD_ADDR_VAR 0 3
122057: PUSH
122058: DOUBLE
122059: LD_INT 1
122061: DEC
122062: ST_TO_ADDR
122063: LD_INT 4
122065: PUSH
122066: FOR_TO
122067: IFFALSE 122088
// SetSkill ( i , j , 10 ) ;
122069: LD_VAR 0 2
122073: PPUSH
122074: LD_VAR 0 3
122078: PPUSH
122079: LD_INT 10
122081: PPUSH
122082: CALL_OW 237
122086: GO 122066
122088: POP
122089: POP
// end ;
122090: GO 122050
122092: POP
122093: POP
// end ;
122094: LD_VAR 0 1
122098: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
122099: LD_INT 0
122101: PPUSH
// uc_side := your_side ;
122102: LD_ADDR_OWVAR 20
122106: PUSH
122107: LD_OWVAR 2
122111: ST_TO_ADDR
// uc_nation := nation ;
122112: LD_ADDR_OWVAR 21
122116: PUSH
122117: LD_VAR 0 1
122121: ST_TO_ADDR
// InitHc ;
122122: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
122126: LD_INT 0
122128: PPUSH
122129: LD_VAR 0 2
122133: PPUSH
122134: LD_VAR 0 3
122138: PPUSH
122139: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
122143: LD_VAR 0 4
122147: PPUSH
122148: LD_VAR 0 5
122152: PPUSH
122153: CALL_OW 428
122157: PUSH
122158: LD_INT 0
122160: EQUAL
122161: IFFALSE 122185
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
122163: CALL_OW 44
122167: PPUSH
122168: LD_VAR 0 4
122172: PPUSH
122173: LD_VAR 0 5
122177: PPUSH
122178: LD_INT 1
122180: PPUSH
122181: CALL_OW 48
// end ;
122185: LD_VAR 0 6
122189: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
122190: LD_INT 0
122192: PPUSH
122193: PPUSH
// uc_side := your_side ;
122194: LD_ADDR_OWVAR 20
122198: PUSH
122199: LD_OWVAR 2
122203: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
122204: LD_VAR 0 1
122208: PUSH
122209: LD_INT 1
122211: PUSH
122212: LD_INT 2
122214: PUSH
122215: LD_INT 3
122217: PUSH
122218: LD_INT 4
122220: PUSH
122221: LD_INT 5
122223: PUSH
122224: EMPTY
122225: LIST
122226: LIST
122227: LIST
122228: LIST
122229: LIST
122230: IN
122231: IFFALSE 122243
// uc_nation := nation_american else
122233: LD_ADDR_OWVAR 21
122237: PUSH
122238: LD_INT 1
122240: ST_TO_ADDR
122241: GO 122286
// if chassis in [ 11 , 12 , 13 , 14 ] then
122243: LD_VAR 0 1
122247: PUSH
122248: LD_INT 11
122250: PUSH
122251: LD_INT 12
122253: PUSH
122254: LD_INT 13
122256: PUSH
122257: LD_INT 14
122259: PUSH
122260: EMPTY
122261: LIST
122262: LIST
122263: LIST
122264: LIST
122265: IN
122266: IFFALSE 122278
// uc_nation := nation_arabian else
122268: LD_ADDR_OWVAR 21
122272: PUSH
122273: LD_INT 2
122275: ST_TO_ADDR
122276: GO 122286
// uc_nation := nation_russian ;
122278: LD_ADDR_OWVAR 21
122282: PUSH
122283: LD_INT 3
122285: ST_TO_ADDR
// vc_chassis := chassis ;
122286: LD_ADDR_OWVAR 37
122290: PUSH
122291: LD_VAR 0 1
122295: ST_TO_ADDR
// vc_engine := engine ;
122296: LD_ADDR_OWVAR 39
122300: PUSH
122301: LD_VAR 0 2
122305: ST_TO_ADDR
// vc_control := control ;
122306: LD_ADDR_OWVAR 38
122310: PUSH
122311: LD_VAR 0 3
122315: ST_TO_ADDR
// vc_weapon := weapon ;
122316: LD_ADDR_OWVAR 40
122320: PUSH
122321: LD_VAR 0 4
122325: ST_TO_ADDR
// un := CreateVehicle ;
122326: LD_ADDR_VAR 0 8
122330: PUSH
122331: CALL_OW 45
122335: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
122336: LD_VAR 0 8
122340: PPUSH
122341: LD_INT 0
122343: PPUSH
122344: LD_INT 5
122346: PPUSH
122347: CALL_OW 12
122351: PPUSH
122352: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
122356: LD_VAR 0 8
122360: PPUSH
122361: LD_VAR 0 5
122365: PPUSH
122366: LD_VAR 0 6
122370: PPUSH
122371: LD_INT 1
122373: PPUSH
122374: CALL_OW 48
// end ;
122378: LD_VAR 0 7
122382: RET
// export hInvincible ; every 1 do
122383: GO 122385
122385: DISABLE
// hInvincible := [ ] ;
122386: LD_ADDR_EXP 200
122390: PUSH
122391: EMPTY
122392: ST_TO_ADDR
122393: END
// every 10 do var i ;
122394: GO 122396
122396: DISABLE
122397: LD_INT 0
122399: PPUSH
// begin enable ;
122400: ENABLE
// if not hInvincible then
122401: LD_EXP 200
122405: NOT
122406: IFFALSE 122410
// exit ;
122408: GO 122454
// for i in hInvincible do
122410: LD_ADDR_VAR 0 1
122414: PUSH
122415: LD_EXP 200
122419: PUSH
122420: FOR_IN
122421: IFFALSE 122452
// if GetLives ( i ) < 1000 then
122423: LD_VAR 0 1
122427: PPUSH
122428: CALL_OW 256
122432: PUSH
122433: LD_INT 1000
122435: LESS
122436: IFFALSE 122450
// SetLives ( i , 1000 ) ;
122438: LD_VAR 0 1
122442: PPUSH
122443: LD_INT 1000
122445: PPUSH
122446: CALL_OW 234
122450: GO 122420
122452: POP
122453: POP
// end ;
122454: PPOPN 1
122456: END
// export function hHackInvincible ; var i ; begin
122457: LD_INT 0
122459: PPUSH
122460: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
122461: LD_ADDR_VAR 0 2
122465: PUSH
122466: LD_INT 2
122468: PUSH
122469: LD_INT 21
122471: PUSH
122472: LD_INT 1
122474: PUSH
122475: EMPTY
122476: LIST
122477: LIST
122478: PUSH
122479: LD_INT 21
122481: PUSH
122482: LD_INT 2
122484: PUSH
122485: EMPTY
122486: LIST
122487: LIST
122488: PUSH
122489: EMPTY
122490: LIST
122491: LIST
122492: LIST
122493: PPUSH
122494: CALL_OW 69
122498: PUSH
122499: FOR_IN
122500: IFFALSE 122561
// if IsSelected ( i ) then
122502: LD_VAR 0 2
122506: PPUSH
122507: CALL_OW 306
122511: IFFALSE 122559
// begin if i in hInvincible then
122513: LD_VAR 0 2
122517: PUSH
122518: LD_EXP 200
122522: IN
122523: IFFALSE 122543
// hInvincible := hInvincible diff i else
122525: LD_ADDR_EXP 200
122529: PUSH
122530: LD_EXP 200
122534: PUSH
122535: LD_VAR 0 2
122539: DIFF
122540: ST_TO_ADDR
122541: GO 122559
// hInvincible := hInvincible union i ;
122543: LD_ADDR_EXP 200
122547: PUSH
122548: LD_EXP 200
122552: PUSH
122553: LD_VAR 0 2
122557: UNION
122558: ST_TO_ADDR
// end ;
122559: GO 122499
122561: POP
122562: POP
// end ;
122563: LD_VAR 0 1
122567: RET
// export function hHackInvisible ; var i , j ; begin
122568: LD_INT 0
122570: PPUSH
122571: PPUSH
122572: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
122573: LD_ADDR_VAR 0 2
122577: PUSH
122578: LD_INT 21
122580: PUSH
122581: LD_INT 1
122583: PUSH
122584: EMPTY
122585: LIST
122586: LIST
122587: PPUSH
122588: CALL_OW 69
122592: PUSH
122593: FOR_IN
122594: IFFALSE 122618
// if IsSelected ( i ) then
122596: LD_VAR 0 2
122600: PPUSH
122601: CALL_OW 306
122605: IFFALSE 122616
// ComForceInvisible ( i ) ;
122607: LD_VAR 0 2
122611: PPUSH
122612: CALL_OW 496
122616: GO 122593
122618: POP
122619: POP
// end ;
122620: LD_VAR 0 1
122624: RET
// export function hHackChangeYourSide ; begin
122625: LD_INT 0
122627: PPUSH
// if your_side = 8 then
122628: LD_OWVAR 2
122632: PUSH
122633: LD_INT 8
122635: EQUAL
122636: IFFALSE 122648
// your_side := 0 else
122638: LD_ADDR_OWVAR 2
122642: PUSH
122643: LD_INT 0
122645: ST_TO_ADDR
122646: GO 122662
// your_side := your_side + 1 ;
122648: LD_ADDR_OWVAR 2
122652: PUSH
122653: LD_OWVAR 2
122657: PUSH
122658: LD_INT 1
122660: PLUS
122661: ST_TO_ADDR
// end ;
122662: LD_VAR 0 1
122666: RET
// export function hHackChangeUnitSide ; var i , j ; begin
122667: LD_INT 0
122669: PPUSH
122670: PPUSH
122671: PPUSH
// for i in all_units do
122672: LD_ADDR_VAR 0 2
122676: PUSH
122677: LD_OWVAR 3
122681: PUSH
122682: FOR_IN
122683: IFFALSE 122761
// if IsSelected ( i ) then
122685: LD_VAR 0 2
122689: PPUSH
122690: CALL_OW 306
122694: IFFALSE 122759
// begin j := GetSide ( i ) ;
122696: LD_ADDR_VAR 0 3
122700: PUSH
122701: LD_VAR 0 2
122705: PPUSH
122706: CALL_OW 255
122710: ST_TO_ADDR
// if j = 8 then
122711: LD_VAR 0 3
122715: PUSH
122716: LD_INT 8
122718: EQUAL
122719: IFFALSE 122731
// j := 0 else
122721: LD_ADDR_VAR 0 3
122725: PUSH
122726: LD_INT 0
122728: ST_TO_ADDR
122729: GO 122745
// j := j + 1 ;
122731: LD_ADDR_VAR 0 3
122735: PUSH
122736: LD_VAR 0 3
122740: PUSH
122741: LD_INT 1
122743: PLUS
122744: ST_TO_ADDR
// SetSide ( i , j ) ;
122745: LD_VAR 0 2
122749: PPUSH
122750: LD_VAR 0 3
122754: PPUSH
122755: CALL_OW 235
// end ;
122759: GO 122682
122761: POP
122762: POP
// end ;
122763: LD_VAR 0 1
122767: RET
// export function hHackFog ; begin
122768: LD_INT 0
122770: PPUSH
// FogOff ( true ) ;
122771: LD_INT 1
122773: PPUSH
122774: CALL_OW 344
// end ;
122778: LD_VAR 0 1
122782: RET
// export function hHackTeleport ( unit , x , y ) ; begin
122783: LD_INT 0
122785: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
122786: LD_VAR 0 1
122790: PPUSH
122791: LD_VAR 0 2
122795: PPUSH
122796: LD_VAR 0 3
122800: PPUSH
122801: LD_INT 1
122803: PPUSH
122804: LD_INT 1
122806: PPUSH
122807: CALL_OW 483
// CenterOnXY ( x , y ) ;
122811: LD_VAR 0 2
122815: PPUSH
122816: LD_VAR 0 3
122820: PPUSH
122821: CALL_OW 84
// end ;
122825: LD_VAR 0 4
122829: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
122830: LD_INT 0
122832: PPUSH
122833: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
122834: LD_VAR 0 1
122838: NOT
122839: PUSH
122840: LD_VAR 0 2
122844: PPUSH
122845: LD_VAR 0 3
122849: PPUSH
122850: CALL_OW 488
122854: NOT
122855: OR
122856: PUSH
122857: LD_VAR 0 1
122861: PPUSH
122862: CALL_OW 266
122866: PUSH
122867: LD_INT 3
122869: NONEQUAL
122870: PUSH
122871: LD_VAR 0 1
122875: PPUSH
122876: CALL_OW 247
122880: PUSH
122881: LD_INT 1
122883: EQUAL
122884: NOT
122885: AND
122886: OR
122887: IFFALSE 122891
// exit ;
122889: GO 123040
// if GetType ( factory ) = unit_human then
122891: LD_VAR 0 1
122895: PPUSH
122896: CALL_OW 247
122900: PUSH
122901: LD_INT 1
122903: EQUAL
122904: IFFALSE 122921
// factory := IsInUnit ( factory ) ;
122906: LD_ADDR_VAR 0 1
122910: PUSH
122911: LD_VAR 0 1
122915: PPUSH
122916: CALL_OW 310
122920: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
122921: LD_VAR 0 1
122925: PPUSH
122926: CALL_OW 266
122930: PUSH
122931: LD_INT 3
122933: NONEQUAL
122934: IFFALSE 122938
// exit ;
122936: GO 123040
// if HexInfo ( x , y ) = factory then
122938: LD_VAR 0 2
122942: PPUSH
122943: LD_VAR 0 3
122947: PPUSH
122948: CALL_OW 428
122952: PUSH
122953: LD_VAR 0 1
122957: EQUAL
122958: IFFALSE 122985
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
122960: LD_ADDR_EXP 201
122964: PUSH
122965: LD_EXP 201
122969: PPUSH
122970: LD_VAR 0 1
122974: PPUSH
122975: LD_INT 0
122977: PPUSH
122978: CALL_OW 1
122982: ST_TO_ADDR
122983: GO 123036
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
122985: LD_ADDR_EXP 201
122989: PUSH
122990: LD_EXP 201
122994: PPUSH
122995: LD_VAR 0 1
122999: PPUSH
123000: LD_VAR 0 1
123004: PPUSH
123005: CALL_OW 255
123009: PUSH
123010: LD_VAR 0 1
123014: PUSH
123015: LD_VAR 0 2
123019: PUSH
123020: LD_VAR 0 3
123024: PUSH
123025: EMPTY
123026: LIST
123027: LIST
123028: LIST
123029: LIST
123030: PPUSH
123031: CALL_OW 1
123035: ST_TO_ADDR
// UpdateFactoryWaypoints ;
123036: CALL 123045 0 0
// end ;
123040: LD_VAR 0 4
123044: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
123045: LD_INT 0
123047: PPUSH
123048: PPUSH
123049: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
123050: LD_STRING resetFactoryWaypoint();
123052: PPUSH
123053: CALL_OW 559
// if factoryWaypoints then
123057: LD_EXP 201
123061: IFFALSE 123187
// begin list := PrepareArray ( factoryWaypoints ) ;
123063: LD_ADDR_VAR 0 3
123067: PUSH
123068: LD_EXP 201
123072: PPUSH
123073: CALL 108441 0 1
123077: ST_TO_ADDR
// for i := 1 to list do
123078: LD_ADDR_VAR 0 2
123082: PUSH
123083: DOUBLE
123084: LD_INT 1
123086: DEC
123087: ST_TO_ADDR
123088: LD_VAR 0 3
123092: PUSH
123093: FOR_TO
123094: IFFALSE 123185
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
123096: LD_STRING setFactoryWaypointXY(
123098: PUSH
123099: LD_VAR 0 3
123103: PUSH
123104: LD_VAR 0 2
123108: ARRAY
123109: PUSH
123110: LD_INT 1
123112: ARRAY
123113: STR
123114: PUSH
123115: LD_STRING ,
123117: STR
123118: PUSH
123119: LD_VAR 0 3
123123: PUSH
123124: LD_VAR 0 2
123128: ARRAY
123129: PUSH
123130: LD_INT 2
123132: ARRAY
123133: STR
123134: PUSH
123135: LD_STRING ,
123137: STR
123138: PUSH
123139: LD_VAR 0 3
123143: PUSH
123144: LD_VAR 0 2
123148: ARRAY
123149: PUSH
123150: LD_INT 3
123152: ARRAY
123153: STR
123154: PUSH
123155: LD_STRING ,
123157: STR
123158: PUSH
123159: LD_VAR 0 3
123163: PUSH
123164: LD_VAR 0 2
123168: ARRAY
123169: PUSH
123170: LD_INT 4
123172: ARRAY
123173: STR
123174: PUSH
123175: LD_STRING )
123177: STR
123178: PPUSH
123179: CALL_OW 559
123183: GO 123093
123185: POP
123186: POP
// end ; end ;
123187: LD_VAR 0 1
123191: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
123192: LD_INT 0
123194: PPUSH
// if HexInfo ( x , y ) = warehouse then
123195: LD_VAR 0 2
123199: PPUSH
123200: LD_VAR 0 3
123204: PPUSH
123205: CALL_OW 428
123209: PUSH
123210: LD_VAR 0 1
123214: EQUAL
123215: IFFALSE 123242
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
123217: LD_ADDR_EXP 202
123221: PUSH
123222: LD_EXP 202
123226: PPUSH
123227: LD_VAR 0 1
123231: PPUSH
123232: LD_INT 0
123234: PPUSH
123235: CALL_OW 1
123239: ST_TO_ADDR
123240: GO 123293
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
123242: LD_ADDR_EXP 202
123246: PUSH
123247: LD_EXP 202
123251: PPUSH
123252: LD_VAR 0 1
123256: PPUSH
123257: LD_VAR 0 1
123261: PPUSH
123262: CALL_OW 255
123266: PUSH
123267: LD_VAR 0 1
123271: PUSH
123272: LD_VAR 0 2
123276: PUSH
123277: LD_VAR 0 3
123281: PUSH
123282: EMPTY
123283: LIST
123284: LIST
123285: LIST
123286: LIST
123287: PPUSH
123288: CALL_OW 1
123292: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
123293: CALL 123302 0 0
// end ;
123297: LD_VAR 0 4
123301: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
123302: LD_INT 0
123304: PPUSH
123305: PPUSH
123306: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
123307: LD_STRING resetWarehouseGatheringPoints();
123309: PPUSH
123310: CALL_OW 559
// if warehouseGatheringPoints then
123314: LD_EXP 202
123318: IFFALSE 123444
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
123320: LD_ADDR_VAR 0 3
123324: PUSH
123325: LD_EXP 202
123329: PPUSH
123330: CALL 108441 0 1
123334: ST_TO_ADDR
// for i := 1 to list do
123335: LD_ADDR_VAR 0 2
123339: PUSH
123340: DOUBLE
123341: LD_INT 1
123343: DEC
123344: ST_TO_ADDR
123345: LD_VAR 0 3
123349: PUSH
123350: FOR_TO
123351: IFFALSE 123442
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
123353: LD_STRING setWarehouseGatheringPointXY(
123355: PUSH
123356: LD_VAR 0 3
123360: PUSH
123361: LD_VAR 0 2
123365: ARRAY
123366: PUSH
123367: LD_INT 1
123369: ARRAY
123370: STR
123371: PUSH
123372: LD_STRING ,
123374: STR
123375: PUSH
123376: LD_VAR 0 3
123380: PUSH
123381: LD_VAR 0 2
123385: ARRAY
123386: PUSH
123387: LD_INT 2
123389: ARRAY
123390: STR
123391: PUSH
123392: LD_STRING ,
123394: STR
123395: PUSH
123396: LD_VAR 0 3
123400: PUSH
123401: LD_VAR 0 2
123405: ARRAY
123406: PUSH
123407: LD_INT 3
123409: ARRAY
123410: STR
123411: PUSH
123412: LD_STRING ,
123414: STR
123415: PUSH
123416: LD_VAR 0 3
123420: PUSH
123421: LD_VAR 0 2
123425: ARRAY
123426: PUSH
123427: LD_INT 4
123429: ARRAY
123430: STR
123431: PUSH
123432: LD_STRING )
123434: STR
123435: PPUSH
123436: CALL_OW 559
123440: GO 123350
123442: POP
123443: POP
// end ; end ;
123444: LD_VAR 0 1
123448: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
123449: LD_EXP 202
123453: IFFALSE 124138
123455: GO 123457
123457: DISABLE
123458: LD_INT 0
123460: PPUSH
123461: PPUSH
123462: PPUSH
123463: PPUSH
123464: PPUSH
123465: PPUSH
123466: PPUSH
123467: PPUSH
123468: PPUSH
// begin enable ;
123469: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
123470: LD_ADDR_VAR 0 3
123474: PUSH
123475: LD_EXP 202
123479: PPUSH
123480: CALL 108441 0 1
123484: ST_TO_ADDR
// if not list then
123485: LD_VAR 0 3
123489: NOT
123490: IFFALSE 123494
// exit ;
123492: GO 124138
// for i := 1 to list do
123494: LD_ADDR_VAR 0 1
123498: PUSH
123499: DOUBLE
123500: LD_INT 1
123502: DEC
123503: ST_TO_ADDR
123504: LD_VAR 0 3
123508: PUSH
123509: FOR_TO
123510: IFFALSE 124136
// begin depot := list [ i ] [ 2 ] ;
123512: LD_ADDR_VAR 0 8
123516: PUSH
123517: LD_VAR 0 3
123521: PUSH
123522: LD_VAR 0 1
123526: ARRAY
123527: PUSH
123528: LD_INT 2
123530: ARRAY
123531: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
123532: LD_ADDR_VAR 0 5
123536: PUSH
123537: LD_VAR 0 3
123541: PUSH
123542: LD_VAR 0 1
123546: ARRAY
123547: PUSH
123548: LD_INT 1
123550: ARRAY
123551: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
123552: LD_VAR 0 8
123556: PPUSH
123557: CALL_OW 301
123561: PUSH
123562: LD_VAR 0 5
123566: PUSH
123567: LD_VAR 0 8
123571: PPUSH
123572: CALL_OW 255
123576: NONEQUAL
123577: OR
123578: IFFALSE 123607
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
123580: LD_ADDR_EXP 202
123584: PUSH
123585: LD_EXP 202
123589: PPUSH
123590: LD_VAR 0 8
123594: PPUSH
123595: LD_INT 0
123597: PPUSH
123598: CALL_OW 1
123602: ST_TO_ADDR
// exit ;
123603: POP
123604: POP
123605: GO 124138
// end ; x := list [ i ] [ 3 ] ;
123607: LD_ADDR_VAR 0 6
123611: PUSH
123612: LD_VAR 0 3
123616: PUSH
123617: LD_VAR 0 1
123621: ARRAY
123622: PUSH
123623: LD_INT 3
123625: ARRAY
123626: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
123627: LD_ADDR_VAR 0 7
123631: PUSH
123632: LD_VAR 0 3
123636: PUSH
123637: LD_VAR 0 1
123641: ARRAY
123642: PUSH
123643: LD_INT 4
123645: ARRAY
123646: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
123647: LD_ADDR_VAR 0 9
123651: PUSH
123652: LD_VAR 0 6
123656: PPUSH
123657: LD_VAR 0 7
123661: PPUSH
123662: LD_INT 16
123664: PPUSH
123665: CALL 107029 0 3
123669: ST_TO_ADDR
// if not cratesNearbyPoint then
123670: LD_VAR 0 9
123674: NOT
123675: IFFALSE 123681
// exit ;
123677: POP
123678: POP
123679: GO 124138
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
123681: LD_ADDR_VAR 0 4
123685: PUSH
123686: LD_INT 22
123688: PUSH
123689: LD_VAR 0 5
123693: PUSH
123694: EMPTY
123695: LIST
123696: LIST
123697: PUSH
123698: LD_INT 3
123700: PUSH
123701: LD_INT 60
123703: PUSH
123704: EMPTY
123705: LIST
123706: PUSH
123707: EMPTY
123708: LIST
123709: LIST
123710: PUSH
123711: LD_INT 91
123713: PUSH
123714: LD_VAR 0 8
123718: PUSH
123719: LD_INT 6
123721: PUSH
123722: EMPTY
123723: LIST
123724: LIST
123725: LIST
123726: PUSH
123727: LD_INT 2
123729: PUSH
123730: LD_INT 25
123732: PUSH
123733: LD_INT 2
123735: PUSH
123736: EMPTY
123737: LIST
123738: LIST
123739: PUSH
123740: LD_INT 25
123742: PUSH
123743: LD_INT 16
123745: PUSH
123746: EMPTY
123747: LIST
123748: LIST
123749: PUSH
123750: EMPTY
123751: LIST
123752: LIST
123753: LIST
123754: PUSH
123755: EMPTY
123756: LIST
123757: LIST
123758: LIST
123759: LIST
123760: PPUSH
123761: CALL_OW 69
123765: PUSH
123766: LD_VAR 0 8
123770: PPUSH
123771: CALL_OW 313
123775: PPUSH
123776: LD_INT 3
123778: PUSH
123779: LD_INT 60
123781: PUSH
123782: EMPTY
123783: LIST
123784: PUSH
123785: EMPTY
123786: LIST
123787: LIST
123788: PUSH
123789: LD_INT 2
123791: PUSH
123792: LD_INT 25
123794: PUSH
123795: LD_INT 2
123797: PUSH
123798: EMPTY
123799: LIST
123800: LIST
123801: PUSH
123802: LD_INT 25
123804: PUSH
123805: LD_INT 16
123807: PUSH
123808: EMPTY
123809: LIST
123810: LIST
123811: PUSH
123812: EMPTY
123813: LIST
123814: LIST
123815: LIST
123816: PUSH
123817: EMPTY
123818: LIST
123819: LIST
123820: PPUSH
123821: CALL_OW 72
123825: UNION
123826: ST_TO_ADDR
// if tmp then
123827: LD_VAR 0 4
123831: IFFALSE 123911
// begin tmp := ShrinkArray ( tmp , 3 ) ;
123833: LD_ADDR_VAR 0 4
123837: PUSH
123838: LD_VAR 0 4
123842: PPUSH
123843: LD_INT 3
123845: PPUSH
123846: CALL 104998 0 2
123850: ST_TO_ADDR
// for j in tmp do
123851: LD_ADDR_VAR 0 2
123855: PUSH
123856: LD_VAR 0 4
123860: PUSH
123861: FOR_IN
123862: IFFALSE 123905
// begin if IsInUnit ( j ) then
123864: LD_VAR 0 2
123868: PPUSH
123869: CALL_OW 310
123873: IFFALSE 123884
// ComExit ( j ) ;
123875: LD_VAR 0 2
123879: PPUSH
123880: CALL 105081 0 1
// AddComCollect ( j , x , y ) ;
123884: LD_VAR 0 2
123888: PPUSH
123889: LD_VAR 0 6
123893: PPUSH
123894: LD_VAR 0 7
123898: PPUSH
123899: CALL_OW 177
// end ;
123903: GO 123861
123905: POP
123906: POP
// exit ;
123907: POP
123908: POP
123909: GO 124138
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
123911: LD_ADDR_VAR 0 4
123915: PUSH
123916: LD_INT 22
123918: PUSH
123919: LD_VAR 0 5
123923: PUSH
123924: EMPTY
123925: LIST
123926: LIST
123927: PUSH
123928: LD_INT 91
123930: PUSH
123931: LD_VAR 0 8
123935: PUSH
123936: LD_INT 8
123938: PUSH
123939: EMPTY
123940: LIST
123941: LIST
123942: LIST
123943: PUSH
123944: LD_INT 2
123946: PUSH
123947: LD_INT 34
123949: PUSH
123950: LD_INT 12
123952: PUSH
123953: EMPTY
123954: LIST
123955: LIST
123956: PUSH
123957: LD_INT 34
123959: PUSH
123960: LD_INT 51
123962: PUSH
123963: EMPTY
123964: LIST
123965: LIST
123966: PUSH
123967: LD_INT 34
123969: PUSH
123970: LD_INT 32
123972: PUSH
123973: EMPTY
123974: LIST
123975: LIST
123976: PUSH
123977: LD_INT 34
123979: PUSH
123980: LD_INT 89
123982: PUSH
123983: EMPTY
123984: LIST
123985: LIST
123986: PUSH
123987: EMPTY
123988: LIST
123989: LIST
123990: LIST
123991: LIST
123992: LIST
123993: PUSH
123994: EMPTY
123995: LIST
123996: LIST
123997: LIST
123998: PPUSH
123999: CALL_OW 69
124003: ST_TO_ADDR
// if tmp then
124004: LD_VAR 0 4
124008: IFFALSE 124134
// begin for j in tmp do
124010: LD_ADDR_VAR 0 2
124014: PUSH
124015: LD_VAR 0 4
124019: PUSH
124020: FOR_IN
124021: IFFALSE 124132
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
124023: LD_VAR 0 2
124027: PPUSH
124028: CALL_OW 262
124032: PUSH
124033: LD_INT 3
124035: EQUAL
124036: PUSH
124037: LD_VAR 0 2
124041: PPUSH
124042: CALL_OW 261
124046: PUSH
124047: LD_INT 20
124049: GREATER
124050: OR
124051: PUSH
124052: LD_VAR 0 2
124056: PPUSH
124057: CALL_OW 314
124061: NOT
124062: AND
124063: PUSH
124064: LD_VAR 0 2
124068: PPUSH
124069: CALL_OW 263
124073: PUSH
124074: LD_INT 1
124076: NONEQUAL
124077: PUSH
124078: LD_VAR 0 2
124082: PPUSH
124083: CALL_OW 311
124087: OR
124088: AND
124089: IFFALSE 124130
// begin ComCollect ( j , x , y ) ;
124091: LD_VAR 0 2
124095: PPUSH
124096: LD_VAR 0 6
124100: PPUSH
124101: LD_VAR 0 7
124105: PPUSH
124106: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
124110: LD_VAR 0 2
124114: PPUSH
124115: LD_VAR 0 8
124119: PPUSH
124120: CALL_OW 172
// exit ;
124124: POP
124125: POP
124126: POP
124127: POP
124128: GO 124138
// end ;
124130: GO 124020
124132: POP
124133: POP
// end ; end ;
124134: GO 123509
124136: POP
124137: POP
// end ; end_of_file
124138: PPOPN 9
124140: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
124141: LD_INT 0
124143: PPUSH
124144: PPUSH
124145: PPUSH
124146: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
124147: LD_VAR 0 1
124151: PPUSH
124152: CALL_OW 264
124156: PUSH
124157: LD_INT 91
124159: EQUAL
124160: IFFALSE 124232
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
124162: LD_INT 68
124164: PPUSH
124165: LD_VAR 0 1
124169: PPUSH
124170: CALL_OW 255
124174: PPUSH
124175: CALL_OW 321
124179: PUSH
124180: LD_INT 2
124182: EQUAL
124183: IFFALSE 124195
// eff := 70 else
124185: LD_ADDR_VAR 0 4
124189: PUSH
124190: LD_INT 70
124192: ST_TO_ADDR
124193: GO 124203
// eff := 30 ;
124195: LD_ADDR_VAR 0 4
124199: PUSH
124200: LD_INT 30
124202: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
124203: LD_VAR 0 1
124207: PPUSH
124208: CALL_OW 250
124212: PPUSH
124213: LD_VAR 0 1
124217: PPUSH
124218: CALL_OW 251
124222: PPUSH
124223: LD_VAR 0 4
124227: PPUSH
124228: CALL_OW 495
// end ; end ;
124232: LD_VAR 0 2
124236: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
124237: LD_INT 0
124239: PPUSH
// end ;
124240: LD_VAR 0 4
124244: RET
// export function SOS_Command ( cmd ) ; begin
124245: LD_INT 0
124247: PPUSH
// end ;
124248: LD_VAR 0 2
124252: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
124253: LD_INT 0
124255: PPUSH
// end ;
124256: LD_VAR 0 6
124260: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
124261: LD_INT 0
124263: PPUSH
124264: PPUSH
// if not vehicle or not factory then
124265: LD_VAR 0 1
124269: NOT
124270: PUSH
124271: LD_VAR 0 2
124275: NOT
124276: OR
124277: IFFALSE 124281
// exit ;
124279: GO 124512
// if factoryWaypoints >= factory then
124281: LD_EXP 201
124285: PUSH
124286: LD_VAR 0 2
124290: GREATEREQUAL
124291: IFFALSE 124512
// if factoryWaypoints [ factory ] then
124293: LD_EXP 201
124297: PUSH
124298: LD_VAR 0 2
124302: ARRAY
124303: IFFALSE 124512
// begin if GetControl ( vehicle ) = control_manual then
124305: LD_VAR 0 1
124309: PPUSH
124310: CALL_OW 263
124314: PUSH
124315: LD_INT 1
124317: EQUAL
124318: IFFALSE 124399
// begin driver := IsDrivenBy ( vehicle ) ;
124320: LD_ADDR_VAR 0 4
124324: PUSH
124325: LD_VAR 0 1
124329: PPUSH
124330: CALL_OW 311
124334: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
124335: LD_VAR 0 4
124339: PPUSH
124340: LD_EXP 201
124344: PUSH
124345: LD_VAR 0 2
124349: ARRAY
124350: PUSH
124351: LD_INT 3
124353: ARRAY
124354: PPUSH
124355: LD_EXP 201
124359: PUSH
124360: LD_VAR 0 2
124364: ARRAY
124365: PUSH
124366: LD_INT 4
124368: ARRAY
124369: PPUSH
124370: CALL_OW 171
// AddComExitVehicle ( driver ) ;
124374: LD_VAR 0 4
124378: PPUSH
124379: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
124383: LD_VAR 0 4
124387: PPUSH
124388: LD_VAR 0 2
124392: PPUSH
124393: CALL_OW 180
// end else
124397: GO 124512
// if GetControl ( vehicle ) = control_remote then
124399: LD_VAR 0 1
124403: PPUSH
124404: CALL_OW 263
124408: PUSH
124409: LD_INT 2
124411: EQUAL
124412: IFFALSE 124473
// begin wait ( 0 0$2 ) ;
124414: LD_INT 70
124416: PPUSH
124417: CALL_OW 67
// if Connect ( vehicle ) then
124421: LD_VAR 0 1
124425: PPUSH
124426: CALL 75340 0 1
124430: IFFALSE 124471
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
124432: LD_VAR 0 1
124436: PPUSH
124437: LD_EXP 201
124441: PUSH
124442: LD_VAR 0 2
124446: ARRAY
124447: PUSH
124448: LD_INT 3
124450: ARRAY
124451: PPUSH
124452: LD_EXP 201
124456: PUSH
124457: LD_VAR 0 2
124461: ARRAY
124462: PUSH
124463: LD_INT 4
124465: ARRAY
124466: PPUSH
124467: CALL_OW 171
// end else
124471: GO 124512
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
124473: LD_VAR 0 1
124477: PPUSH
124478: LD_EXP 201
124482: PUSH
124483: LD_VAR 0 2
124487: ARRAY
124488: PUSH
124489: LD_INT 3
124491: ARRAY
124492: PPUSH
124493: LD_EXP 201
124497: PUSH
124498: LD_VAR 0 2
124502: ARRAY
124503: PUSH
124504: LD_INT 4
124506: ARRAY
124507: PPUSH
124508: CALL_OW 171
// end ; end ;
124512: LD_VAR 0 3
124516: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
124517: LD_INT 0
124519: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
124520: LD_VAR 0 1
124524: PUSH
124525: LD_INT 250
124527: EQUAL
124528: PUSH
124529: LD_VAR 0 2
124533: PPUSH
124534: CALL_OW 264
124538: PUSH
124539: LD_INT 81
124541: EQUAL
124542: AND
124543: IFFALSE 124564
// MinerPlaceMine ( unit , x , y ) ;
124545: LD_VAR 0 2
124549: PPUSH
124550: LD_VAR 0 4
124554: PPUSH
124555: LD_VAR 0 5
124559: PPUSH
124560: CALL 126949 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
124564: LD_VAR 0 1
124568: PUSH
124569: LD_INT 251
124571: EQUAL
124572: PUSH
124573: LD_VAR 0 2
124577: PPUSH
124578: CALL_OW 264
124582: PUSH
124583: LD_INT 81
124585: EQUAL
124586: AND
124587: IFFALSE 124608
// MinerDetonateMine ( unit , x , y ) ;
124589: LD_VAR 0 2
124593: PPUSH
124594: LD_VAR 0 4
124598: PPUSH
124599: LD_VAR 0 5
124603: PPUSH
124604: CALL 127224 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
124608: LD_VAR 0 1
124612: PUSH
124613: LD_INT 252
124615: EQUAL
124616: PUSH
124617: LD_VAR 0 2
124621: PPUSH
124622: CALL_OW 264
124626: PUSH
124627: LD_INT 81
124629: EQUAL
124630: AND
124631: IFFALSE 124652
// MinerCreateMinefield ( unit , x , y ) ;
124633: LD_VAR 0 2
124637: PPUSH
124638: LD_VAR 0 4
124642: PPUSH
124643: LD_VAR 0 5
124647: PPUSH
124648: CALL 127641 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
124652: LD_VAR 0 1
124656: PUSH
124657: LD_INT 253
124659: EQUAL
124660: PUSH
124661: LD_VAR 0 2
124665: PPUSH
124666: CALL_OW 257
124670: PUSH
124671: LD_INT 5
124673: EQUAL
124674: AND
124675: IFFALSE 124696
// ComBinocular ( unit , x , y ) ;
124677: LD_VAR 0 2
124681: PPUSH
124682: LD_VAR 0 4
124686: PPUSH
124687: LD_VAR 0 5
124691: PPUSH
124692: CALL 128010 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
124696: LD_VAR 0 1
124700: PUSH
124701: LD_INT 254
124703: EQUAL
124704: PUSH
124705: LD_VAR 0 2
124709: PPUSH
124710: CALL_OW 264
124714: PUSH
124715: LD_INT 99
124717: EQUAL
124718: AND
124719: PUSH
124720: LD_VAR 0 3
124724: PPUSH
124725: CALL_OW 263
124729: PUSH
124730: LD_INT 3
124732: EQUAL
124733: AND
124734: IFFALSE 124750
// HackDestroyVehicle ( unit , selectedUnit ) ;
124736: LD_VAR 0 2
124740: PPUSH
124741: LD_VAR 0 3
124745: PPUSH
124746: CALL 126313 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
124750: LD_VAR 0 1
124754: PUSH
124755: LD_INT 255
124757: EQUAL
124758: PUSH
124759: LD_VAR 0 2
124763: PPUSH
124764: CALL_OW 264
124768: PUSH
124769: LD_INT 14
124771: PUSH
124772: LD_INT 53
124774: PUSH
124775: EMPTY
124776: LIST
124777: LIST
124778: IN
124779: AND
124780: PUSH
124781: LD_VAR 0 4
124785: PPUSH
124786: LD_VAR 0 5
124790: PPUSH
124791: CALL_OW 488
124795: AND
124796: IFFALSE 124820
// CutTreeXYR ( unit , x , y , 12 ) ;
124798: LD_VAR 0 2
124802: PPUSH
124803: LD_VAR 0 4
124807: PPUSH
124808: LD_VAR 0 5
124812: PPUSH
124813: LD_INT 12
124815: PPUSH
124816: CALL 124883 0 4
// if cmd = 256 then
124820: LD_VAR 0 1
124824: PUSH
124825: LD_INT 256
124827: EQUAL
124828: IFFALSE 124849
// SetFactoryWaypoint ( unit , x , y ) ;
124830: LD_VAR 0 2
124834: PPUSH
124835: LD_VAR 0 4
124839: PPUSH
124840: LD_VAR 0 5
124844: PPUSH
124845: CALL 122830 0 3
// if cmd = 257 then
124849: LD_VAR 0 1
124853: PUSH
124854: LD_INT 257
124856: EQUAL
124857: IFFALSE 124878
// SetWarehouseGatheringPoint ( unit , x , y ) ;
124859: LD_VAR 0 2
124863: PPUSH
124864: LD_VAR 0 4
124868: PPUSH
124869: LD_VAR 0 5
124873: PPUSH
124874: CALL 123192 0 3
// end ;
124878: LD_VAR 0 6
124882: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
124883: LD_INT 0
124885: PPUSH
124886: PPUSH
124887: PPUSH
124888: PPUSH
124889: PPUSH
124890: PPUSH
124891: PPUSH
124892: PPUSH
124893: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
124894: LD_VAR 0 1
124898: NOT
124899: PUSH
124900: LD_VAR 0 2
124904: PPUSH
124905: LD_VAR 0 3
124909: PPUSH
124910: CALL_OW 488
124914: NOT
124915: OR
124916: PUSH
124917: LD_VAR 0 4
124921: NOT
124922: OR
124923: IFFALSE 124927
// exit ;
124925: GO 125267
// list := [ ] ;
124927: LD_ADDR_VAR 0 13
124931: PUSH
124932: EMPTY
124933: ST_TO_ADDR
// if x - r < 0 then
124934: LD_VAR 0 2
124938: PUSH
124939: LD_VAR 0 4
124943: MINUS
124944: PUSH
124945: LD_INT 0
124947: LESS
124948: IFFALSE 124960
// min_x := 0 else
124950: LD_ADDR_VAR 0 7
124954: PUSH
124955: LD_INT 0
124957: ST_TO_ADDR
124958: GO 124976
// min_x := x - r ;
124960: LD_ADDR_VAR 0 7
124964: PUSH
124965: LD_VAR 0 2
124969: PUSH
124970: LD_VAR 0 4
124974: MINUS
124975: ST_TO_ADDR
// if y - r < 0 then
124976: LD_VAR 0 3
124980: PUSH
124981: LD_VAR 0 4
124985: MINUS
124986: PUSH
124987: LD_INT 0
124989: LESS
124990: IFFALSE 125002
// min_y := 0 else
124992: LD_ADDR_VAR 0 8
124996: PUSH
124997: LD_INT 0
124999: ST_TO_ADDR
125000: GO 125018
// min_y := y - r ;
125002: LD_ADDR_VAR 0 8
125006: PUSH
125007: LD_VAR 0 3
125011: PUSH
125012: LD_VAR 0 4
125016: MINUS
125017: ST_TO_ADDR
// max_x := x + r ;
125018: LD_ADDR_VAR 0 9
125022: PUSH
125023: LD_VAR 0 2
125027: PUSH
125028: LD_VAR 0 4
125032: PLUS
125033: ST_TO_ADDR
// max_y := y + r ;
125034: LD_ADDR_VAR 0 10
125038: PUSH
125039: LD_VAR 0 3
125043: PUSH
125044: LD_VAR 0 4
125048: PLUS
125049: ST_TO_ADDR
// for _x = min_x to max_x do
125050: LD_ADDR_VAR 0 11
125054: PUSH
125055: DOUBLE
125056: LD_VAR 0 7
125060: DEC
125061: ST_TO_ADDR
125062: LD_VAR 0 9
125066: PUSH
125067: FOR_TO
125068: IFFALSE 125185
// for _y = min_y to max_y do
125070: LD_ADDR_VAR 0 12
125074: PUSH
125075: DOUBLE
125076: LD_VAR 0 8
125080: DEC
125081: ST_TO_ADDR
125082: LD_VAR 0 10
125086: PUSH
125087: FOR_TO
125088: IFFALSE 125181
// begin if not ValidHex ( _x , _y ) then
125090: LD_VAR 0 11
125094: PPUSH
125095: LD_VAR 0 12
125099: PPUSH
125100: CALL_OW 488
125104: NOT
125105: IFFALSE 125109
// continue ;
125107: GO 125087
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
125109: LD_VAR 0 11
125113: PPUSH
125114: LD_VAR 0 12
125118: PPUSH
125119: CALL_OW 351
125123: PUSH
125124: LD_VAR 0 11
125128: PPUSH
125129: LD_VAR 0 12
125133: PPUSH
125134: CALL_OW 554
125138: AND
125139: IFFALSE 125179
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
125141: LD_ADDR_VAR 0 13
125145: PUSH
125146: LD_VAR 0 13
125150: PPUSH
125151: LD_VAR 0 13
125155: PUSH
125156: LD_INT 1
125158: PLUS
125159: PPUSH
125160: LD_VAR 0 11
125164: PUSH
125165: LD_VAR 0 12
125169: PUSH
125170: EMPTY
125171: LIST
125172: LIST
125173: PPUSH
125174: CALL_OW 2
125178: ST_TO_ADDR
// end ;
125179: GO 125087
125181: POP
125182: POP
125183: GO 125067
125185: POP
125186: POP
// if not list then
125187: LD_VAR 0 13
125191: NOT
125192: IFFALSE 125196
// exit ;
125194: GO 125267
// for i in list do
125196: LD_ADDR_VAR 0 6
125200: PUSH
125201: LD_VAR 0 13
125205: PUSH
125206: FOR_IN
125207: IFFALSE 125265
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
125209: LD_VAR 0 1
125213: PPUSH
125214: LD_STRING M
125216: PUSH
125217: LD_VAR 0 6
125221: PUSH
125222: LD_INT 1
125224: ARRAY
125225: PUSH
125226: LD_VAR 0 6
125230: PUSH
125231: LD_INT 2
125233: ARRAY
125234: PUSH
125235: LD_INT 0
125237: PUSH
125238: LD_INT 0
125240: PUSH
125241: LD_INT 0
125243: PUSH
125244: LD_INT 0
125246: PUSH
125247: EMPTY
125248: LIST
125249: LIST
125250: LIST
125251: LIST
125252: LIST
125253: LIST
125254: LIST
125255: PUSH
125256: EMPTY
125257: LIST
125258: PPUSH
125259: CALL_OW 447
125263: GO 125206
125265: POP
125266: POP
// end ;
125267: LD_VAR 0 5
125271: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
125272: LD_EXP 204
125276: NOT
125277: IFFALSE 125327
125279: GO 125281
125281: DISABLE
// begin initHack := true ;
125282: LD_ADDR_EXP 204
125286: PUSH
125287: LD_INT 1
125289: ST_TO_ADDR
// hackTanks := [ ] ;
125290: LD_ADDR_EXP 205
125294: PUSH
125295: EMPTY
125296: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
125297: LD_ADDR_EXP 206
125301: PUSH
125302: EMPTY
125303: ST_TO_ADDR
// hackLimit := 3 ;
125304: LD_ADDR_EXP 207
125308: PUSH
125309: LD_INT 3
125311: ST_TO_ADDR
// hackDist := 12 ;
125312: LD_ADDR_EXP 208
125316: PUSH
125317: LD_INT 12
125319: ST_TO_ADDR
// hackCounter := [ ] ;
125320: LD_ADDR_EXP 209
125324: PUSH
125325: EMPTY
125326: ST_TO_ADDR
// end ;
125327: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
125328: LD_EXP 204
125332: PUSH
125333: LD_INT 34
125335: PUSH
125336: LD_INT 99
125338: PUSH
125339: EMPTY
125340: LIST
125341: LIST
125342: PPUSH
125343: CALL_OW 69
125347: AND
125348: IFFALSE 125601
125350: GO 125352
125352: DISABLE
125353: LD_INT 0
125355: PPUSH
125356: PPUSH
// begin enable ;
125357: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
125358: LD_ADDR_VAR 0 1
125362: PUSH
125363: LD_INT 34
125365: PUSH
125366: LD_INT 99
125368: PUSH
125369: EMPTY
125370: LIST
125371: LIST
125372: PPUSH
125373: CALL_OW 69
125377: PUSH
125378: FOR_IN
125379: IFFALSE 125599
// begin if not i in hackTanks then
125381: LD_VAR 0 1
125385: PUSH
125386: LD_EXP 205
125390: IN
125391: NOT
125392: IFFALSE 125475
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
125394: LD_ADDR_EXP 205
125398: PUSH
125399: LD_EXP 205
125403: PPUSH
125404: LD_EXP 205
125408: PUSH
125409: LD_INT 1
125411: PLUS
125412: PPUSH
125413: LD_VAR 0 1
125417: PPUSH
125418: CALL_OW 1
125422: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
125423: LD_ADDR_EXP 206
125427: PUSH
125428: LD_EXP 206
125432: PPUSH
125433: LD_EXP 206
125437: PUSH
125438: LD_INT 1
125440: PLUS
125441: PPUSH
125442: EMPTY
125443: PPUSH
125444: CALL_OW 1
125448: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
125449: LD_ADDR_EXP 209
125453: PUSH
125454: LD_EXP 209
125458: PPUSH
125459: LD_EXP 209
125463: PUSH
125464: LD_INT 1
125466: PLUS
125467: PPUSH
125468: EMPTY
125469: PPUSH
125470: CALL_OW 1
125474: ST_TO_ADDR
// end ; if not IsOk ( i ) then
125475: LD_VAR 0 1
125479: PPUSH
125480: CALL_OW 302
125484: NOT
125485: IFFALSE 125498
// begin HackUnlinkAll ( i ) ;
125487: LD_VAR 0 1
125491: PPUSH
125492: CALL 125604 0 1
// continue ;
125496: GO 125378
// end ; HackCheckCapturedStatus ( i ) ;
125498: LD_VAR 0 1
125502: PPUSH
125503: CALL 126047 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
125507: LD_ADDR_VAR 0 2
125511: PUSH
125512: LD_INT 81
125514: PUSH
125515: LD_VAR 0 1
125519: PPUSH
125520: CALL_OW 255
125524: PUSH
125525: EMPTY
125526: LIST
125527: LIST
125528: PUSH
125529: LD_INT 33
125531: PUSH
125532: LD_INT 3
125534: PUSH
125535: EMPTY
125536: LIST
125537: LIST
125538: PUSH
125539: LD_INT 91
125541: PUSH
125542: LD_VAR 0 1
125546: PUSH
125547: LD_EXP 208
125551: PUSH
125552: EMPTY
125553: LIST
125554: LIST
125555: LIST
125556: PUSH
125557: LD_INT 50
125559: PUSH
125560: EMPTY
125561: LIST
125562: PUSH
125563: EMPTY
125564: LIST
125565: LIST
125566: LIST
125567: LIST
125568: PPUSH
125569: CALL_OW 69
125573: ST_TO_ADDR
// if not tmp then
125574: LD_VAR 0 2
125578: NOT
125579: IFFALSE 125583
// continue ;
125581: GO 125378
// HackLink ( i , tmp ) ;
125583: LD_VAR 0 1
125587: PPUSH
125588: LD_VAR 0 2
125592: PPUSH
125593: CALL 125740 0 2
// end ;
125597: GO 125378
125599: POP
125600: POP
// end ;
125601: PPOPN 2
125603: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
125604: LD_INT 0
125606: PPUSH
125607: PPUSH
125608: PPUSH
// if not hack in hackTanks then
125609: LD_VAR 0 1
125613: PUSH
125614: LD_EXP 205
125618: IN
125619: NOT
125620: IFFALSE 125624
// exit ;
125622: GO 125735
// index := GetElementIndex ( hackTanks , hack ) ;
125624: LD_ADDR_VAR 0 4
125628: PUSH
125629: LD_EXP 205
125633: PPUSH
125634: LD_VAR 0 1
125638: PPUSH
125639: CALL 72156 0 2
125643: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
125644: LD_EXP 206
125648: PUSH
125649: LD_VAR 0 4
125653: ARRAY
125654: IFFALSE 125735
// begin for i in hackTanksCaptured [ index ] do
125656: LD_ADDR_VAR 0 3
125660: PUSH
125661: LD_EXP 206
125665: PUSH
125666: LD_VAR 0 4
125670: ARRAY
125671: PUSH
125672: FOR_IN
125673: IFFALSE 125699
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
125675: LD_VAR 0 3
125679: PUSH
125680: LD_INT 1
125682: ARRAY
125683: PPUSH
125684: LD_VAR 0 3
125688: PUSH
125689: LD_INT 2
125691: ARRAY
125692: PPUSH
125693: CALL_OW 235
125697: GO 125672
125699: POP
125700: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
125701: LD_ADDR_EXP 206
125705: PUSH
125706: LD_EXP 206
125710: PPUSH
125711: LD_VAR 0 4
125715: PPUSH
125716: EMPTY
125717: PPUSH
125718: CALL_OW 1
125722: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
125723: LD_VAR 0 1
125727: PPUSH
125728: LD_INT 0
125730: PPUSH
125731: CALL_OW 505
// end ; end ;
125735: LD_VAR 0 2
125739: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
125740: LD_INT 0
125742: PPUSH
125743: PPUSH
125744: PPUSH
// if not hack in hackTanks or not vehicles then
125745: LD_VAR 0 1
125749: PUSH
125750: LD_EXP 205
125754: IN
125755: NOT
125756: PUSH
125757: LD_VAR 0 2
125761: NOT
125762: OR
125763: IFFALSE 125767
// exit ;
125765: GO 126042
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
125767: LD_ADDR_VAR 0 2
125771: PUSH
125772: LD_VAR 0 1
125776: PPUSH
125777: LD_VAR 0 2
125781: PPUSH
125782: LD_INT 1
125784: PPUSH
125785: LD_INT 1
125787: PPUSH
125788: CALL 72806 0 4
125792: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
125793: LD_ADDR_VAR 0 5
125797: PUSH
125798: LD_EXP 205
125802: PPUSH
125803: LD_VAR 0 1
125807: PPUSH
125808: CALL 72156 0 2
125812: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
125813: LD_EXP 206
125817: PUSH
125818: LD_VAR 0 5
125822: ARRAY
125823: PUSH
125824: LD_EXP 207
125828: LESS
125829: IFFALSE 126018
// begin for i := 1 to vehicles do
125831: LD_ADDR_VAR 0 4
125835: PUSH
125836: DOUBLE
125837: LD_INT 1
125839: DEC
125840: ST_TO_ADDR
125841: LD_VAR 0 2
125845: PUSH
125846: FOR_TO
125847: IFFALSE 126016
// begin if hackTanksCaptured [ index ] = hackLimit then
125849: LD_EXP 206
125853: PUSH
125854: LD_VAR 0 5
125858: ARRAY
125859: PUSH
125860: LD_EXP 207
125864: EQUAL
125865: IFFALSE 125869
// break ;
125867: GO 126016
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
125869: LD_ADDR_EXP 209
125873: PUSH
125874: LD_EXP 209
125878: PPUSH
125879: LD_VAR 0 5
125883: PPUSH
125884: LD_EXP 209
125888: PUSH
125889: LD_VAR 0 5
125893: ARRAY
125894: PUSH
125895: LD_INT 1
125897: PLUS
125898: PPUSH
125899: CALL_OW 1
125903: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
125904: LD_ADDR_EXP 206
125908: PUSH
125909: LD_EXP 206
125913: PPUSH
125914: LD_VAR 0 5
125918: PUSH
125919: LD_EXP 206
125923: PUSH
125924: LD_VAR 0 5
125928: ARRAY
125929: PUSH
125930: LD_INT 1
125932: PLUS
125933: PUSH
125934: EMPTY
125935: LIST
125936: LIST
125937: PPUSH
125938: LD_VAR 0 2
125942: PUSH
125943: LD_VAR 0 4
125947: ARRAY
125948: PUSH
125949: LD_VAR 0 2
125953: PUSH
125954: LD_VAR 0 4
125958: ARRAY
125959: PPUSH
125960: CALL_OW 255
125964: PUSH
125965: EMPTY
125966: LIST
125967: LIST
125968: PPUSH
125969: CALL 72371 0 3
125973: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
125974: LD_VAR 0 2
125978: PUSH
125979: LD_VAR 0 4
125983: ARRAY
125984: PPUSH
125985: LD_VAR 0 1
125989: PPUSH
125990: CALL_OW 255
125994: PPUSH
125995: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
125999: LD_VAR 0 2
126003: PUSH
126004: LD_VAR 0 4
126008: ARRAY
126009: PPUSH
126010: CALL_OW 141
// end ;
126014: GO 125846
126016: POP
126017: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
126018: LD_VAR 0 1
126022: PPUSH
126023: LD_EXP 206
126027: PUSH
126028: LD_VAR 0 5
126032: ARRAY
126033: PUSH
126034: LD_INT 0
126036: PLUS
126037: PPUSH
126038: CALL_OW 505
// end ;
126042: LD_VAR 0 3
126046: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
126047: LD_INT 0
126049: PPUSH
126050: PPUSH
126051: PPUSH
126052: PPUSH
// if not hack in hackTanks then
126053: LD_VAR 0 1
126057: PUSH
126058: LD_EXP 205
126062: IN
126063: NOT
126064: IFFALSE 126068
// exit ;
126066: GO 126308
// index := GetElementIndex ( hackTanks , hack ) ;
126068: LD_ADDR_VAR 0 4
126072: PUSH
126073: LD_EXP 205
126077: PPUSH
126078: LD_VAR 0 1
126082: PPUSH
126083: CALL 72156 0 2
126087: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
126088: LD_ADDR_VAR 0 3
126092: PUSH
126093: DOUBLE
126094: LD_EXP 206
126098: PUSH
126099: LD_VAR 0 4
126103: ARRAY
126104: INC
126105: ST_TO_ADDR
126106: LD_INT 1
126108: PUSH
126109: FOR_DOWNTO
126110: IFFALSE 126282
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
126112: LD_ADDR_VAR 0 5
126116: PUSH
126117: LD_EXP 206
126121: PUSH
126122: LD_VAR 0 4
126126: ARRAY
126127: PUSH
126128: LD_VAR 0 3
126132: ARRAY
126133: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
126134: LD_VAR 0 5
126138: PUSH
126139: LD_INT 1
126141: ARRAY
126142: PPUSH
126143: CALL_OW 302
126147: NOT
126148: PUSH
126149: LD_VAR 0 5
126153: PUSH
126154: LD_INT 1
126156: ARRAY
126157: PPUSH
126158: CALL_OW 255
126162: PUSH
126163: LD_VAR 0 1
126167: PPUSH
126168: CALL_OW 255
126172: NONEQUAL
126173: OR
126174: IFFALSE 126280
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
126176: LD_VAR 0 5
126180: PUSH
126181: LD_INT 1
126183: ARRAY
126184: PPUSH
126185: CALL_OW 305
126189: PUSH
126190: LD_VAR 0 5
126194: PUSH
126195: LD_INT 1
126197: ARRAY
126198: PPUSH
126199: CALL_OW 255
126203: PUSH
126204: LD_VAR 0 1
126208: PPUSH
126209: CALL_OW 255
126213: EQUAL
126214: AND
126215: IFFALSE 126239
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
126217: LD_VAR 0 5
126221: PUSH
126222: LD_INT 1
126224: ARRAY
126225: PPUSH
126226: LD_VAR 0 5
126230: PUSH
126231: LD_INT 2
126233: ARRAY
126234: PPUSH
126235: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
126239: LD_ADDR_EXP 206
126243: PUSH
126244: LD_EXP 206
126248: PPUSH
126249: LD_VAR 0 4
126253: PPUSH
126254: LD_EXP 206
126258: PUSH
126259: LD_VAR 0 4
126263: ARRAY
126264: PPUSH
126265: LD_VAR 0 3
126269: PPUSH
126270: CALL_OW 3
126274: PPUSH
126275: CALL_OW 1
126279: ST_TO_ADDR
// end ; end ;
126280: GO 126109
126282: POP
126283: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
126284: LD_VAR 0 1
126288: PPUSH
126289: LD_EXP 206
126293: PUSH
126294: LD_VAR 0 4
126298: ARRAY
126299: PUSH
126300: LD_INT 0
126302: PLUS
126303: PPUSH
126304: CALL_OW 505
// end ;
126308: LD_VAR 0 2
126312: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
126313: LD_INT 0
126315: PPUSH
126316: PPUSH
126317: PPUSH
126318: PPUSH
// if not hack in hackTanks then
126319: LD_VAR 0 1
126323: PUSH
126324: LD_EXP 205
126328: IN
126329: NOT
126330: IFFALSE 126334
// exit ;
126332: GO 126419
// index := GetElementIndex ( hackTanks , hack ) ;
126334: LD_ADDR_VAR 0 5
126338: PUSH
126339: LD_EXP 205
126343: PPUSH
126344: LD_VAR 0 1
126348: PPUSH
126349: CALL 72156 0 2
126353: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
126354: LD_ADDR_VAR 0 4
126358: PUSH
126359: DOUBLE
126360: LD_INT 1
126362: DEC
126363: ST_TO_ADDR
126364: LD_EXP 206
126368: PUSH
126369: LD_VAR 0 5
126373: ARRAY
126374: PUSH
126375: FOR_TO
126376: IFFALSE 126417
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
126378: LD_EXP 206
126382: PUSH
126383: LD_VAR 0 5
126387: ARRAY
126388: PUSH
126389: LD_VAR 0 4
126393: ARRAY
126394: PUSH
126395: LD_INT 1
126397: ARRAY
126398: PUSH
126399: LD_VAR 0 2
126403: EQUAL
126404: IFFALSE 126415
// KillUnit ( vehicle ) ;
126406: LD_VAR 0 2
126410: PPUSH
126411: CALL_OW 66
126415: GO 126375
126417: POP
126418: POP
// end ;
126419: LD_VAR 0 3
126423: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
126424: LD_EXP 210
126428: NOT
126429: IFFALSE 126464
126431: GO 126433
126433: DISABLE
// begin initMiner := true ;
126434: LD_ADDR_EXP 210
126438: PUSH
126439: LD_INT 1
126441: ST_TO_ADDR
// minersList := [ ] ;
126442: LD_ADDR_EXP 211
126446: PUSH
126447: EMPTY
126448: ST_TO_ADDR
// minerMinesList := [ ] ;
126449: LD_ADDR_EXP 212
126453: PUSH
126454: EMPTY
126455: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
126456: LD_ADDR_EXP 213
126460: PUSH
126461: LD_INT 5
126463: ST_TO_ADDR
// end ;
126464: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
126465: LD_EXP 210
126469: PUSH
126470: LD_INT 34
126472: PUSH
126473: LD_INT 81
126475: PUSH
126476: EMPTY
126477: LIST
126478: LIST
126479: PPUSH
126480: CALL_OW 69
126484: AND
126485: IFFALSE 126946
126487: GO 126489
126489: DISABLE
126490: LD_INT 0
126492: PPUSH
126493: PPUSH
126494: PPUSH
126495: PPUSH
// begin enable ;
126496: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
126497: LD_ADDR_VAR 0 1
126501: PUSH
126502: LD_INT 34
126504: PUSH
126505: LD_INT 81
126507: PUSH
126508: EMPTY
126509: LIST
126510: LIST
126511: PPUSH
126512: CALL_OW 69
126516: PUSH
126517: FOR_IN
126518: IFFALSE 126590
// begin if not i in minersList then
126520: LD_VAR 0 1
126524: PUSH
126525: LD_EXP 211
126529: IN
126530: NOT
126531: IFFALSE 126588
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
126533: LD_ADDR_EXP 211
126537: PUSH
126538: LD_EXP 211
126542: PPUSH
126543: LD_EXP 211
126547: PUSH
126548: LD_INT 1
126550: PLUS
126551: PPUSH
126552: LD_VAR 0 1
126556: PPUSH
126557: CALL_OW 1
126561: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
126562: LD_ADDR_EXP 212
126566: PUSH
126567: LD_EXP 212
126571: PPUSH
126572: LD_EXP 212
126576: PUSH
126577: LD_INT 1
126579: PLUS
126580: PPUSH
126581: EMPTY
126582: PPUSH
126583: CALL_OW 1
126587: ST_TO_ADDR
// end end ;
126588: GO 126517
126590: POP
126591: POP
// for i := minerMinesList downto 1 do
126592: LD_ADDR_VAR 0 1
126596: PUSH
126597: DOUBLE
126598: LD_EXP 212
126602: INC
126603: ST_TO_ADDR
126604: LD_INT 1
126606: PUSH
126607: FOR_DOWNTO
126608: IFFALSE 126944
// begin if IsLive ( minersList [ i ] ) then
126610: LD_EXP 211
126614: PUSH
126615: LD_VAR 0 1
126619: ARRAY
126620: PPUSH
126621: CALL_OW 300
126625: IFFALSE 126653
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
126627: LD_EXP 211
126631: PUSH
126632: LD_VAR 0 1
126636: ARRAY
126637: PPUSH
126638: LD_EXP 212
126642: PUSH
126643: LD_VAR 0 1
126647: ARRAY
126648: PPUSH
126649: CALL_OW 505
// if not minerMinesList [ i ] then
126653: LD_EXP 212
126657: PUSH
126658: LD_VAR 0 1
126662: ARRAY
126663: NOT
126664: IFFALSE 126668
// continue ;
126666: GO 126607
// for j := minerMinesList [ i ] downto 1 do
126668: LD_ADDR_VAR 0 2
126672: PUSH
126673: DOUBLE
126674: LD_EXP 212
126678: PUSH
126679: LD_VAR 0 1
126683: ARRAY
126684: INC
126685: ST_TO_ADDR
126686: LD_INT 1
126688: PUSH
126689: FOR_DOWNTO
126690: IFFALSE 126940
// begin side := GetSide ( minersList [ i ] ) ;
126692: LD_ADDR_VAR 0 3
126696: PUSH
126697: LD_EXP 211
126701: PUSH
126702: LD_VAR 0 1
126706: ARRAY
126707: PPUSH
126708: CALL_OW 255
126712: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
126713: LD_ADDR_VAR 0 4
126717: PUSH
126718: LD_EXP 212
126722: PUSH
126723: LD_VAR 0 1
126727: ARRAY
126728: PUSH
126729: LD_VAR 0 2
126733: ARRAY
126734: PUSH
126735: LD_INT 1
126737: ARRAY
126738: PPUSH
126739: LD_EXP 212
126743: PUSH
126744: LD_VAR 0 1
126748: ARRAY
126749: PUSH
126750: LD_VAR 0 2
126754: ARRAY
126755: PUSH
126756: LD_INT 2
126758: ARRAY
126759: PPUSH
126760: CALL_OW 428
126764: ST_TO_ADDR
// if not tmp then
126765: LD_VAR 0 4
126769: NOT
126770: IFFALSE 126774
// continue ;
126772: GO 126689
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
126774: LD_VAR 0 4
126778: PUSH
126779: LD_INT 81
126781: PUSH
126782: LD_VAR 0 3
126786: PUSH
126787: EMPTY
126788: LIST
126789: LIST
126790: PPUSH
126791: CALL_OW 69
126795: IN
126796: PUSH
126797: LD_EXP 212
126801: PUSH
126802: LD_VAR 0 1
126806: ARRAY
126807: PUSH
126808: LD_VAR 0 2
126812: ARRAY
126813: PUSH
126814: LD_INT 1
126816: ARRAY
126817: PPUSH
126818: LD_EXP 212
126822: PUSH
126823: LD_VAR 0 1
126827: ARRAY
126828: PUSH
126829: LD_VAR 0 2
126833: ARRAY
126834: PUSH
126835: LD_INT 2
126837: ARRAY
126838: PPUSH
126839: CALL_OW 458
126843: AND
126844: IFFALSE 126938
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
126846: LD_EXP 212
126850: PUSH
126851: LD_VAR 0 1
126855: ARRAY
126856: PUSH
126857: LD_VAR 0 2
126861: ARRAY
126862: PUSH
126863: LD_INT 1
126865: ARRAY
126866: PPUSH
126867: LD_EXP 212
126871: PUSH
126872: LD_VAR 0 1
126876: ARRAY
126877: PUSH
126878: LD_VAR 0 2
126882: ARRAY
126883: PUSH
126884: LD_INT 2
126886: ARRAY
126887: PPUSH
126888: LD_VAR 0 3
126892: PPUSH
126893: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
126897: LD_ADDR_EXP 212
126901: PUSH
126902: LD_EXP 212
126906: PPUSH
126907: LD_VAR 0 1
126911: PPUSH
126912: LD_EXP 212
126916: PUSH
126917: LD_VAR 0 1
126921: ARRAY
126922: PPUSH
126923: LD_VAR 0 2
126927: PPUSH
126928: CALL_OW 3
126932: PPUSH
126933: CALL_OW 1
126937: ST_TO_ADDR
// end ; end ;
126938: GO 126689
126940: POP
126941: POP
// end ;
126942: GO 126607
126944: POP
126945: POP
// end ;
126946: PPOPN 4
126948: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
126949: LD_INT 0
126951: PPUSH
126952: PPUSH
// result := false ;
126953: LD_ADDR_VAR 0 4
126957: PUSH
126958: LD_INT 0
126960: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
126961: LD_VAR 0 1
126965: PPUSH
126966: CALL_OW 264
126970: PUSH
126971: LD_INT 81
126973: EQUAL
126974: NOT
126975: IFFALSE 126979
// exit ;
126977: GO 127219
// index := GetElementIndex ( minersList , unit ) ;
126979: LD_ADDR_VAR 0 5
126983: PUSH
126984: LD_EXP 211
126988: PPUSH
126989: LD_VAR 0 1
126993: PPUSH
126994: CALL 72156 0 2
126998: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
126999: LD_EXP 212
127003: PUSH
127004: LD_VAR 0 5
127008: ARRAY
127009: PUSH
127010: LD_EXP 213
127014: GREATEREQUAL
127015: IFFALSE 127019
// exit ;
127017: GO 127219
// ComMoveXY ( unit , x , y ) ;
127019: LD_VAR 0 1
127023: PPUSH
127024: LD_VAR 0 2
127028: PPUSH
127029: LD_VAR 0 3
127033: PPUSH
127034: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
127038: LD_INT 35
127040: PPUSH
127041: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
127045: LD_VAR 0 1
127049: PPUSH
127050: LD_VAR 0 2
127054: PPUSH
127055: LD_VAR 0 3
127059: PPUSH
127060: CALL 103492 0 3
127064: NOT
127065: PUSH
127066: LD_VAR 0 1
127070: PPUSH
127071: CALL_OW 314
127075: AND
127076: IFFALSE 127080
// exit ;
127078: GO 127219
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
127080: LD_VAR 0 2
127084: PPUSH
127085: LD_VAR 0 3
127089: PPUSH
127090: CALL_OW 428
127094: PUSH
127095: LD_VAR 0 1
127099: EQUAL
127100: PUSH
127101: LD_VAR 0 1
127105: PPUSH
127106: CALL_OW 314
127110: NOT
127111: AND
127112: IFFALSE 127038
// PlaySoundXY ( x , y , PlantMine ) ;
127114: LD_VAR 0 2
127118: PPUSH
127119: LD_VAR 0 3
127123: PPUSH
127124: LD_STRING PlantMine
127126: PPUSH
127127: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
127131: LD_VAR 0 2
127135: PPUSH
127136: LD_VAR 0 3
127140: PPUSH
127141: LD_VAR 0 1
127145: PPUSH
127146: CALL_OW 255
127150: PPUSH
127151: LD_INT 0
127153: PPUSH
127154: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
127158: LD_ADDR_EXP 212
127162: PUSH
127163: LD_EXP 212
127167: PPUSH
127168: LD_VAR 0 5
127172: PUSH
127173: LD_EXP 212
127177: PUSH
127178: LD_VAR 0 5
127182: ARRAY
127183: PUSH
127184: LD_INT 1
127186: PLUS
127187: PUSH
127188: EMPTY
127189: LIST
127190: LIST
127191: PPUSH
127192: LD_VAR 0 2
127196: PUSH
127197: LD_VAR 0 3
127201: PUSH
127202: EMPTY
127203: LIST
127204: LIST
127205: PPUSH
127206: CALL 72371 0 3
127210: ST_TO_ADDR
// result := true ;
127211: LD_ADDR_VAR 0 4
127215: PUSH
127216: LD_INT 1
127218: ST_TO_ADDR
// end ;
127219: LD_VAR 0 4
127223: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
127224: LD_INT 0
127226: PPUSH
127227: PPUSH
127228: PPUSH
// if not unit in minersList then
127229: LD_VAR 0 1
127233: PUSH
127234: LD_EXP 211
127238: IN
127239: NOT
127240: IFFALSE 127244
// exit ;
127242: GO 127636
// index := GetElementIndex ( minersList , unit ) ;
127244: LD_ADDR_VAR 0 6
127248: PUSH
127249: LD_EXP 211
127253: PPUSH
127254: LD_VAR 0 1
127258: PPUSH
127259: CALL 72156 0 2
127263: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
127264: LD_ADDR_VAR 0 5
127268: PUSH
127269: DOUBLE
127270: LD_EXP 212
127274: PUSH
127275: LD_VAR 0 6
127279: ARRAY
127280: INC
127281: ST_TO_ADDR
127282: LD_INT 1
127284: PUSH
127285: FOR_DOWNTO
127286: IFFALSE 127447
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
127288: LD_EXP 212
127292: PUSH
127293: LD_VAR 0 6
127297: ARRAY
127298: PUSH
127299: LD_VAR 0 5
127303: ARRAY
127304: PUSH
127305: LD_INT 1
127307: ARRAY
127308: PUSH
127309: LD_VAR 0 2
127313: EQUAL
127314: PUSH
127315: LD_EXP 212
127319: PUSH
127320: LD_VAR 0 6
127324: ARRAY
127325: PUSH
127326: LD_VAR 0 5
127330: ARRAY
127331: PUSH
127332: LD_INT 2
127334: ARRAY
127335: PUSH
127336: LD_VAR 0 3
127340: EQUAL
127341: AND
127342: IFFALSE 127445
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
127344: LD_EXP 212
127348: PUSH
127349: LD_VAR 0 6
127353: ARRAY
127354: PUSH
127355: LD_VAR 0 5
127359: ARRAY
127360: PUSH
127361: LD_INT 1
127363: ARRAY
127364: PPUSH
127365: LD_EXP 212
127369: PUSH
127370: LD_VAR 0 6
127374: ARRAY
127375: PUSH
127376: LD_VAR 0 5
127380: ARRAY
127381: PUSH
127382: LD_INT 2
127384: ARRAY
127385: PPUSH
127386: LD_VAR 0 1
127390: PPUSH
127391: CALL_OW 255
127395: PPUSH
127396: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
127400: LD_ADDR_EXP 212
127404: PUSH
127405: LD_EXP 212
127409: PPUSH
127410: LD_VAR 0 6
127414: PPUSH
127415: LD_EXP 212
127419: PUSH
127420: LD_VAR 0 6
127424: ARRAY
127425: PPUSH
127426: LD_VAR 0 5
127430: PPUSH
127431: CALL_OW 3
127435: PPUSH
127436: CALL_OW 1
127440: ST_TO_ADDR
// exit ;
127441: POP
127442: POP
127443: GO 127636
// end ; end ;
127445: GO 127285
127447: POP
127448: POP
// for i := minerMinesList [ index ] downto 1 do
127449: LD_ADDR_VAR 0 5
127453: PUSH
127454: DOUBLE
127455: LD_EXP 212
127459: PUSH
127460: LD_VAR 0 6
127464: ARRAY
127465: INC
127466: ST_TO_ADDR
127467: LD_INT 1
127469: PUSH
127470: FOR_DOWNTO
127471: IFFALSE 127634
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
127473: LD_EXP 212
127477: PUSH
127478: LD_VAR 0 6
127482: ARRAY
127483: PUSH
127484: LD_VAR 0 5
127488: ARRAY
127489: PUSH
127490: LD_INT 1
127492: ARRAY
127493: PPUSH
127494: LD_EXP 212
127498: PUSH
127499: LD_VAR 0 6
127503: ARRAY
127504: PUSH
127505: LD_VAR 0 5
127509: ARRAY
127510: PUSH
127511: LD_INT 2
127513: ARRAY
127514: PPUSH
127515: LD_VAR 0 2
127519: PPUSH
127520: LD_VAR 0 3
127524: PPUSH
127525: CALL_OW 298
127529: PUSH
127530: LD_INT 6
127532: LESS
127533: IFFALSE 127632
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
127535: LD_EXP 212
127539: PUSH
127540: LD_VAR 0 6
127544: ARRAY
127545: PUSH
127546: LD_VAR 0 5
127550: ARRAY
127551: PUSH
127552: LD_INT 1
127554: ARRAY
127555: PPUSH
127556: LD_EXP 212
127560: PUSH
127561: LD_VAR 0 6
127565: ARRAY
127566: PUSH
127567: LD_VAR 0 5
127571: ARRAY
127572: PUSH
127573: LD_INT 2
127575: ARRAY
127576: PPUSH
127577: LD_VAR 0 1
127581: PPUSH
127582: CALL_OW 255
127586: PPUSH
127587: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
127591: LD_ADDR_EXP 212
127595: PUSH
127596: LD_EXP 212
127600: PPUSH
127601: LD_VAR 0 6
127605: PPUSH
127606: LD_EXP 212
127610: PUSH
127611: LD_VAR 0 6
127615: ARRAY
127616: PPUSH
127617: LD_VAR 0 5
127621: PPUSH
127622: CALL_OW 3
127626: PPUSH
127627: CALL_OW 1
127631: ST_TO_ADDR
// end ; end ;
127632: GO 127470
127634: POP
127635: POP
// end ;
127636: LD_VAR 0 4
127640: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
127641: LD_INT 0
127643: PPUSH
127644: PPUSH
127645: PPUSH
127646: PPUSH
127647: PPUSH
127648: PPUSH
127649: PPUSH
127650: PPUSH
127651: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
127652: LD_VAR 0 1
127656: PPUSH
127657: CALL_OW 264
127661: PUSH
127662: LD_INT 81
127664: EQUAL
127665: NOT
127666: PUSH
127667: LD_VAR 0 1
127671: PUSH
127672: LD_EXP 211
127676: IN
127677: NOT
127678: OR
127679: IFFALSE 127683
// exit ;
127681: GO 128005
// index := GetElementIndex ( minersList , unit ) ;
127683: LD_ADDR_VAR 0 6
127687: PUSH
127688: LD_EXP 211
127692: PPUSH
127693: LD_VAR 0 1
127697: PPUSH
127698: CALL 72156 0 2
127702: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
127703: LD_ADDR_VAR 0 8
127707: PUSH
127708: LD_EXP 213
127712: PUSH
127713: LD_EXP 212
127717: PUSH
127718: LD_VAR 0 6
127722: ARRAY
127723: MINUS
127724: ST_TO_ADDR
// if not minesFreeAmount then
127725: LD_VAR 0 8
127729: NOT
127730: IFFALSE 127734
// exit ;
127732: GO 128005
// tmp := [ ] ;
127734: LD_ADDR_VAR 0 7
127738: PUSH
127739: EMPTY
127740: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
127741: LD_ADDR_VAR 0 5
127745: PUSH
127746: DOUBLE
127747: LD_INT 1
127749: DEC
127750: ST_TO_ADDR
127751: LD_VAR 0 8
127755: PUSH
127756: FOR_TO
127757: IFFALSE 127952
// begin _d := rand ( 0 , 5 ) ;
127759: LD_ADDR_VAR 0 11
127763: PUSH
127764: LD_INT 0
127766: PPUSH
127767: LD_INT 5
127769: PPUSH
127770: CALL_OW 12
127774: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
127775: LD_ADDR_VAR 0 12
127779: PUSH
127780: LD_INT 2
127782: PPUSH
127783: LD_INT 6
127785: PPUSH
127786: CALL_OW 12
127790: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
127791: LD_ADDR_VAR 0 9
127795: PUSH
127796: LD_VAR 0 2
127800: PPUSH
127801: LD_VAR 0 11
127805: PPUSH
127806: LD_VAR 0 12
127810: PPUSH
127811: CALL_OW 272
127815: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
127816: LD_ADDR_VAR 0 10
127820: PUSH
127821: LD_VAR 0 3
127825: PPUSH
127826: LD_VAR 0 11
127830: PPUSH
127831: LD_VAR 0 12
127835: PPUSH
127836: CALL_OW 273
127840: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
127841: LD_VAR 0 9
127845: PPUSH
127846: LD_VAR 0 10
127850: PPUSH
127851: CALL_OW 488
127855: PUSH
127856: LD_VAR 0 9
127860: PUSH
127861: LD_VAR 0 10
127865: PUSH
127866: EMPTY
127867: LIST
127868: LIST
127869: PUSH
127870: LD_VAR 0 7
127874: IN
127875: NOT
127876: AND
127877: PUSH
127878: LD_VAR 0 9
127882: PPUSH
127883: LD_VAR 0 10
127887: PPUSH
127888: CALL_OW 458
127892: NOT
127893: AND
127894: IFFALSE 127936
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
127896: LD_ADDR_VAR 0 7
127900: PUSH
127901: LD_VAR 0 7
127905: PPUSH
127906: LD_VAR 0 7
127910: PUSH
127911: LD_INT 1
127913: PLUS
127914: PPUSH
127915: LD_VAR 0 9
127919: PUSH
127920: LD_VAR 0 10
127924: PUSH
127925: EMPTY
127926: LIST
127927: LIST
127928: PPUSH
127929: CALL_OW 1
127933: ST_TO_ADDR
127934: GO 127950
// i := i - 1 ;
127936: LD_ADDR_VAR 0 5
127940: PUSH
127941: LD_VAR 0 5
127945: PUSH
127946: LD_INT 1
127948: MINUS
127949: ST_TO_ADDR
// end ;
127950: GO 127756
127952: POP
127953: POP
// for i in tmp do
127954: LD_ADDR_VAR 0 5
127958: PUSH
127959: LD_VAR 0 7
127963: PUSH
127964: FOR_IN
127965: IFFALSE 128003
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
127967: LD_VAR 0 1
127971: PPUSH
127972: LD_VAR 0 5
127976: PUSH
127977: LD_INT 1
127979: ARRAY
127980: PPUSH
127981: LD_VAR 0 5
127985: PUSH
127986: LD_INT 2
127988: ARRAY
127989: PPUSH
127990: CALL 126949 0 3
127994: NOT
127995: IFFALSE 128001
// exit ;
127997: POP
127998: POP
127999: GO 128005
128001: GO 127964
128003: POP
128004: POP
// end ;
128005: LD_VAR 0 4
128009: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
128010: LD_INT 0
128012: PPUSH
128013: PPUSH
128014: PPUSH
128015: PPUSH
128016: PPUSH
128017: PPUSH
128018: PPUSH
// if not GetClass ( unit ) = class_sniper then
128019: LD_VAR 0 1
128023: PPUSH
128024: CALL_OW 257
128028: PUSH
128029: LD_INT 5
128031: EQUAL
128032: NOT
128033: IFFALSE 128037
// exit ;
128035: GO 128425
// dist := 8 ;
128037: LD_ADDR_VAR 0 5
128041: PUSH
128042: LD_INT 8
128044: ST_TO_ADDR
// viewRange := 12 ;
128045: LD_ADDR_VAR 0 7
128049: PUSH
128050: LD_INT 12
128052: ST_TO_ADDR
// side := GetSide ( unit ) ;
128053: LD_ADDR_VAR 0 6
128057: PUSH
128058: LD_VAR 0 1
128062: PPUSH
128063: CALL_OW 255
128067: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
128068: LD_INT 61
128070: PPUSH
128071: LD_VAR 0 6
128075: PPUSH
128076: CALL_OW 321
128080: PUSH
128081: LD_INT 2
128083: EQUAL
128084: IFFALSE 128094
// viewRange := 16 ;
128086: LD_ADDR_VAR 0 7
128090: PUSH
128091: LD_INT 16
128093: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
128094: LD_VAR 0 1
128098: PPUSH
128099: LD_VAR 0 2
128103: PPUSH
128104: LD_VAR 0 3
128108: PPUSH
128109: CALL_OW 297
128113: PUSH
128114: LD_VAR 0 5
128118: GREATER
128119: IFFALSE 128198
// begin ComMoveXY ( unit , x , y ) ;
128121: LD_VAR 0 1
128125: PPUSH
128126: LD_VAR 0 2
128130: PPUSH
128131: LD_VAR 0 3
128135: PPUSH
128136: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
128140: LD_INT 35
128142: PPUSH
128143: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
128147: LD_VAR 0 1
128151: PPUSH
128152: LD_VAR 0 2
128156: PPUSH
128157: LD_VAR 0 3
128161: PPUSH
128162: CALL 103492 0 3
128166: NOT
128167: IFFALSE 128171
// exit ;
128169: GO 128425
// until GetDistUnitXY ( unit , x , y ) < dist ;
128171: LD_VAR 0 1
128175: PPUSH
128176: LD_VAR 0 2
128180: PPUSH
128181: LD_VAR 0 3
128185: PPUSH
128186: CALL_OW 297
128190: PUSH
128191: LD_VAR 0 5
128195: LESS
128196: IFFALSE 128140
// end ; ComTurnXY ( unit , x , y ) ;
128198: LD_VAR 0 1
128202: PPUSH
128203: LD_VAR 0 2
128207: PPUSH
128208: LD_VAR 0 3
128212: PPUSH
128213: CALL_OW 118
// wait ( 5 ) ;
128217: LD_INT 5
128219: PPUSH
128220: CALL_OW 67
// _d := GetDir ( unit ) ;
128224: LD_ADDR_VAR 0 10
128228: PUSH
128229: LD_VAR 0 1
128233: PPUSH
128234: CALL_OW 254
128238: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
128239: LD_ADDR_VAR 0 8
128243: PUSH
128244: LD_VAR 0 1
128248: PPUSH
128249: CALL_OW 250
128253: PPUSH
128254: LD_VAR 0 10
128258: PPUSH
128259: LD_VAR 0 5
128263: PPUSH
128264: CALL_OW 272
128268: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
128269: LD_ADDR_VAR 0 9
128273: PUSH
128274: LD_VAR 0 1
128278: PPUSH
128279: CALL_OW 251
128283: PPUSH
128284: LD_VAR 0 10
128288: PPUSH
128289: LD_VAR 0 5
128293: PPUSH
128294: CALL_OW 273
128298: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
128299: LD_VAR 0 8
128303: PPUSH
128304: LD_VAR 0 9
128308: PPUSH
128309: CALL_OW 488
128313: NOT
128314: IFFALSE 128318
// exit ;
128316: GO 128425
// ComAnimCustom ( unit , 1 ) ;
128318: LD_VAR 0 1
128322: PPUSH
128323: LD_INT 1
128325: PPUSH
128326: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
128330: LD_VAR 0 8
128334: PPUSH
128335: LD_VAR 0 9
128339: PPUSH
128340: LD_VAR 0 6
128344: PPUSH
128345: LD_VAR 0 7
128349: PPUSH
128350: CALL_OW 330
// repeat wait ( 1 ) ;
128354: LD_INT 1
128356: PPUSH
128357: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
128361: LD_VAR 0 1
128365: PPUSH
128366: CALL_OW 316
128370: PUSH
128371: LD_VAR 0 1
128375: PPUSH
128376: CALL_OW 314
128380: OR
128381: PUSH
128382: LD_VAR 0 1
128386: PPUSH
128387: CALL_OW 302
128391: NOT
128392: OR
128393: PUSH
128394: LD_VAR 0 1
128398: PPUSH
128399: CALL_OW 301
128403: OR
128404: IFFALSE 128354
// RemoveSeeing ( _x , _y , side ) ;
128406: LD_VAR 0 8
128410: PPUSH
128411: LD_VAR 0 9
128415: PPUSH
128416: LD_VAR 0 6
128420: PPUSH
128421: CALL_OW 331
// end ; end_of_file
128425: LD_VAR 0 4
128429: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
128430: LD_INT 0
128432: PPUSH
128433: PPUSH
128434: PPUSH
128435: PPUSH
128436: PPUSH
128437: PPUSH
128438: PPUSH
128439: PPUSH
128440: PPUSH
128441: PPUSH
128442: PPUSH
128443: PPUSH
128444: PPUSH
128445: PPUSH
128446: PPUSH
128447: PPUSH
128448: PPUSH
128449: PPUSH
128450: PPUSH
128451: PPUSH
128452: PPUSH
128453: PPUSH
128454: PPUSH
128455: PPUSH
128456: PPUSH
128457: PPUSH
128458: PPUSH
128459: PPUSH
128460: PPUSH
128461: PPUSH
128462: PPUSH
128463: PPUSH
128464: PPUSH
128465: PPUSH
// if not list then
128466: LD_VAR 0 1
128470: NOT
128471: IFFALSE 128475
// exit ;
128473: GO 133134
// base := list [ 1 ] ;
128475: LD_ADDR_VAR 0 3
128479: PUSH
128480: LD_VAR 0 1
128484: PUSH
128485: LD_INT 1
128487: ARRAY
128488: ST_TO_ADDR
// group := list [ 2 ] ;
128489: LD_ADDR_VAR 0 4
128493: PUSH
128494: LD_VAR 0 1
128498: PUSH
128499: LD_INT 2
128501: ARRAY
128502: ST_TO_ADDR
// path := list [ 3 ] ;
128503: LD_ADDR_VAR 0 5
128507: PUSH
128508: LD_VAR 0 1
128512: PUSH
128513: LD_INT 3
128515: ARRAY
128516: ST_TO_ADDR
// flags := list [ 4 ] ;
128517: LD_ADDR_VAR 0 6
128521: PUSH
128522: LD_VAR 0 1
128526: PUSH
128527: LD_INT 4
128529: ARRAY
128530: ST_TO_ADDR
// mined := [ ] ;
128531: LD_ADDR_VAR 0 27
128535: PUSH
128536: EMPTY
128537: ST_TO_ADDR
// bombed := [ ] ;
128538: LD_ADDR_VAR 0 28
128542: PUSH
128543: EMPTY
128544: ST_TO_ADDR
// healers := [ ] ;
128545: LD_ADDR_VAR 0 31
128549: PUSH
128550: EMPTY
128551: ST_TO_ADDR
// to_heal := [ ] ;
128552: LD_ADDR_VAR 0 30
128556: PUSH
128557: EMPTY
128558: ST_TO_ADDR
// repairs := [ ] ;
128559: LD_ADDR_VAR 0 33
128563: PUSH
128564: EMPTY
128565: ST_TO_ADDR
// to_repair := [ ] ;
128566: LD_ADDR_VAR 0 32
128570: PUSH
128571: EMPTY
128572: ST_TO_ADDR
// if not group or not path then
128573: LD_VAR 0 4
128577: NOT
128578: PUSH
128579: LD_VAR 0 5
128583: NOT
128584: OR
128585: IFFALSE 128589
// exit ;
128587: GO 133134
// side := GetSide ( group [ 1 ] ) ;
128589: LD_ADDR_VAR 0 35
128593: PUSH
128594: LD_VAR 0 4
128598: PUSH
128599: LD_INT 1
128601: ARRAY
128602: PPUSH
128603: CALL_OW 255
128607: ST_TO_ADDR
// if flags then
128608: LD_VAR 0 6
128612: IFFALSE 128756
// begin f_ignore_area := flags [ 1 ] ;
128614: LD_ADDR_VAR 0 17
128618: PUSH
128619: LD_VAR 0 6
128623: PUSH
128624: LD_INT 1
128626: ARRAY
128627: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
128628: LD_ADDR_VAR 0 18
128632: PUSH
128633: LD_VAR 0 6
128637: PUSH
128638: LD_INT 2
128640: ARRAY
128641: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
128642: LD_ADDR_VAR 0 19
128646: PUSH
128647: LD_VAR 0 6
128651: PUSH
128652: LD_INT 3
128654: ARRAY
128655: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
128656: LD_ADDR_VAR 0 20
128660: PUSH
128661: LD_VAR 0 6
128665: PUSH
128666: LD_INT 4
128668: ARRAY
128669: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
128670: LD_ADDR_VAR 0 21
128674: PUSH
128675: LD_VAR 0 6
128679: PUSH
128680: LD_INT 5
128682: ARRAY
128683: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
128684: LD_ADDR_VAR 0 22
128688: PUSH
128689: LD_VAR 0 6
128693: PUSH
128694: LD_INT 6
128696: ARRAY
128697: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
128698: LD_ADDR_VAR 0 23
128702: PUSH
128703: LD_VAR 0 6
128707: PUSH
128708: LD_INT 7
128710: ARRAY
128711: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
128712: LD_ADDR_VAR 0 24
128716: PUSH
128717: LD_VAR 0 6
128721: PUSH
128722: LD_INT 8
128724: ARRAY
128725: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
128726: LD_ADDR_VAR 0 25
128730: PUSH
128731: LD_VAR 0 6
128735: PUSH
128736: LD_INT 9
128738: ARRAY
128739: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
128740: LD_ADDR_VAR 0 26
128744: PUSH
128745: LD_VAR 0 6
128749: PUSH
128750: LD_INT 10
128752: ARRAY
128753: ST_TO_ADDR
// end else
128754: GO 128836
// begin f_ignore_area := false ;
128756: LD_ADDR_VAR 0 17
128760: PUSH
128761: LD_INT 0
128763: ST_TO_ADDR
// f_capture := false ;
128764: LD_ADDR_VAR 0 18
128768: PUSH
128769: LD_INT 0
128771: ST_TO_ADDR
// f_ignore_civ := false ;
128772: LD_ADDR_VAR 0 19
128776: PUSH
128777: LD_INT 0
128779: ST_TO_ADDR
// f_murder := false ;
128780: LD_ADDR_VAR 0 20
128784: PUSH
128785: LD_INT 0
128787: ST_TO_ADDR
// f_mines := false ;
128788: LD_ADDR_VAR 0 21
128792: PUSH
128793: LD_INT 0
128795: ST_TO_ADDR
// f_repair := false ;
128796: LD_ADDR_VAR 0 22
128800: PUSH
128801: LD_INT 0
128803: ST_TO_ADDR
// f_heal := false ;
128804: LD_ADDR_VAR 0 23
128808: PUSH
128809: LD_INT 0
128811: ST_TO_ADDR
// f_spacetime := false ;
128812: LD_ADDR_VAR 0 24
128816: PUSH
128817: LD_INT 0
128819: ST_TO_ADDR
// f_attack_depot := false ;
128820: LD_ADDR_VAR 0 25
128824: PUSH
128825: LD_INT 0
128827: ST_TO_ADDR
// f_crawl := false ;
128828: LD_ADDR_VAR 0 26
128832: PUSH
128833: LD_INT 0
128835: ST_TO_ADDR
// end ; if f_heal then
128836: LD_VAR 0 23
128840: IFFALSE 128867
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
128842: LD_ADDR_VAR 0 31
128846: PUSH
128847: LD_VAR 0 4
128851: PPUSH
128852: LD_INT 25
128854: PUSH
128855: LD_INT 4
128857: PUSH
128858: EMPTY
128859: LIST
128860: LIST
128861: PPUSH
128862: CALL_OW 72
128866: ST_TO_ADDR
// if f_repair then
128867: LD_VAR 0 22
128871: IFFALSE 128898
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
128873: LD_ADDR_VAR 0 33
128877: PUSH
128878: LD_VAR 0 4
128882: PPUSH
128883: LD_INT 25
128885: PUSH
128886: LD_INT 3
128888: PUSH
128889: EMPTY
128890: LIST
128891: LIST
128892: PPUSH
128893: CALL_OW 72
128897: ST_TO_ADDR
// units_path := [ ] ;
128898: LD_ADDR_VAR 0 16
128902: PUSH
128903: EMPTY
128904: ST_TO_ADDR
// for i = 1 to group do
128905: LD_ADDR_VAR 0 7
128909: PUSH
128910: DOUBLE
128911: LD_INT 1
128913: DEC
128914: ST_TO_ADDR
128915: LD_VAR 0 4
128919: PUSH
128920: FOR_TO
128921: IFFALSE 128950
// units_path := Replace ( units_path , i , path ) ;
128923: LD_ADDR_VAR 0 16
128927: PUSH
128928: LD_VAR 0 16
128932: PPUSH
128933: LD_VAR 0 7
128937: PPUSH
128938: LD_VAR 0 5
128942: PPUSH
128943: CALL_OW 1
128947: ST_TO_ADDR
128948: GO 128920
128950: POP
128951: POP
// repeat for i = group downto 1 do
128952: LD_ADDR_VAR 0 7
128956: PUSH
128957: DOUBLE
128958: LD_VAR 0 4
128962: INC
128963: ST_TO_ADDR
128964: LD_INT 1
128966: PUSH
128967: FOR_DOWNTO
128968: IFFALSE 133090
// begin wait ( 5 ) ;
128970: LD_INT 5
128972: PPUSH
128973: CALL_OW 67
// tmp := [ ] ;
128977: LD_ADDR_VAR 0 14
128981: PUSH
128982: EMPTY
128983: ST_TO_ADDR
// attacking := false ;
128984: LD_ADDR_VAR 0 29
128988: PUSH
128989: LD_INT 0
128991: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
128992: LD_VAR 0 4
128996: PUSH
128997: LD_VAR 0 7
129001: ARRAY
129002: PPUSH
129003: CALL_OW 301
129007: PUSH
129008: LD_VAR 0 4
129012: PUSH
129013: LD_VAR 0 7
129017: ARRAY
129018: NOT
129019: OR
129020: IFFALSE 129129
// begin if GetType ( group [ i ] ) = unit_human then
129022: LD_VAR 0 4
129026: PUSH
129027: LD_VAR 0 7
129031: ARRAY
129032: PPUSH
129033: CALL_OW 247
129037: PUSH
129038: LD_INT 1
129040: EQUAL
129041: IFFALSE 129087
// begin to_heal := to_heal diff group [ i ] ;
129043: LD_ADDR_VAR 0 30
129047: PUSH
129048: LD_VAR 0 30
129052: PUSH
129053: LD_VAR 0 4
129057: PUSH
129058: LD_VAR 0 7
129062: ARRAY
129063: DIFF
129064: ST_TO_ADDR
// healers := healers diff group [ i ] ;
129065: LD_ADDR_VAR 0 31
129069: PUSH
129070: LD_VAR 0 31
129074: PUSH
129075: LD_VAR 0 4
129079: PUSH
129080: LD_VAR 0 7
129084: ARRAY
129085: DIFF
129086: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
129087: LD_ADDR_VAR 0 4
129091: PUSH
129092: LD_VAR 0 4
129096: PPUSH
129097: LD_VAR 0 7
129101: PPUSH
129102: CALL_OW 3
129106: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
129107: LD_ADDR_VAR 0 16
129111: PUSH
129112: LD_VAR 0 16
129116: PPUSH
129117: LD_VAR 0 7
129121: PPUSH
129122: CALL_OW 3
129126: ST_TO_ADDR
// continue ;
129127: GO 128967
// end ; if f_repair then
129129: LD_VAR 0 22
129133: IFFALSE 129622
// begin if GetType ( group [ i ] ) = unit_vehicle then
129135: LD_VAR 0 4
129139: PUSH
129140: LD_VAR 0 7
129144: ARRAY
129145: PPUSH
129146: CALL_OW 247
129150: PUSH
129151: LD_INT 2
129153: EQUAL
129154: IFFALSE 129344
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
129156: LD_VAR 0 4
129160: PUSH
129161: LD_VAR 0 7
129165: ARRAY
129166: PPUSH
129167: CALL_OW 256
129171: PUSH
129172: LD_INT 700
129174: LESS
129175: PUSH
129176: LD_VAR 0 4
129180: PUSH
129181: LD_VAR 0 7
129185: ARRAY
129186: PUSH
129187: LD_VAR 0 32
129191: IN
129192: NOT
129193: AND
129194: IFFALSE 129218
// to_repair := to_repair union group [ i ] ;
129196: LD_ADDR_VAR 0 32
129200: PUSH
129201: LD_VAR 0 32
129205: PUSH
129206: LD_VAR 0 4
129210: PUSH
129211: LD_VAR 0 7
129215: ARRAY
129216: UNION
129217: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
129218: LD_VAR 0 4
129222: PUSH
129223: LD_VAR 0 7
129227: ARRAY
129228: PPUSH
129229: CALL_OW 256
129233: PUSH
129234: LD_INT 1000
129236: EQUAL
129237: PUSH
129238: LD_VAR 0 4
129242: PUSH
129243: LD_VAR 0 7
129247: ARRAY
129248: PUSH
129249: LD_VAR 0 32
129253: IN
129254: AND
129255: IFFALSE 129279
// to_repair := to_repair diff group [ i ] ;
129257: LD_ADDR_VAR 0 32
129261: PUSH
129262: LD_VAR 0 32
129266: PUSH
129267: LD_VAR 0 4
129271: PUSH
129272: LD_VAR 0 7
129276: ARRAY
129277: DIFF
129278: ST_TO_ADDR
// if group [ i ] in to_repair then
129279: LD_VAR 0 4
129283: PUSH
129284: LD_VAR 0 7
129288: ARRAY
129289: PUSH
129290: LD_VAR 0 32
129294: IN
129295: IFFALSE 129342
// begin if not IsInArea ( group [ i ] , f_repair ) then
129297: LD_VAR 0 4
129301: PUSH
129302: LD_VAR 0 7
129306: ARRAY
129307: PPUSH
129308: LD_VAR 0 22
129312: PPUSH
129313: CALL_OW 308
129317: NOT
129318: IFFALSE 129340
// ComMoveToArea ( group [ i ] , f_repair ) ;
129320: LD_VAR 0 4
129324: PUSH
129325: LD_VAR 0 7
129329: ARRAY
129330: PPUSH
129331: LD_VAR 0 22
129335: PPUSH
129336: CALL_OW 113
// continue ;
129340: GO 128967
// end ; end else
129342: GO 129622
// if group [ i ] in repairs then
129344: LD_VAR 0 4
129348: PUSH
129349: LD_VAR 0 7
129353: ARRAY
129354: PUSH
129355: LD_VAR 0 33
129359: IN
129360: IFFALSE 129622
// begin if IsInUnit ( group [ i ] ) then
129362: LD_VAR 0 4
129366: PUSH
129367: LD_VAR 0 7
129371: ARRAY
129372: PPUSH
129373: CALL_OW 310
129377: IFFALSE 129445
// begin z := IsInUnit ( group [ i ] ) ;
129379: LD_ADDR_VAR 0 13
129383: PUSH
129384: LD_VAR 0 4
129388: PUSH
129389: LD_VAR 0 7
129393: ARRAY
129394: PPUSH
129395: CALL_OW 310
129399: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
129400: LD_VAR 0 13
129404: PUSH
129405: LD_VAR 0 32
129409: IN
129410: PUSH
129411: LD_VAR 0 13
129415: PPUSH
129416: LD_VAR 0 22
129420: PPUSH
129421: CALL_OW 308
129425: AND
129426: IFFALSE 129443
// ComExitVehicle ( group [ i ] ) ;
129428: LD_VAR 0 4
129432: PUSH
129433: LD_VAR 0 7
129437: ARRAY
129438: PPUSH
129439: CALL_OW 121
// end else
129443: GO 129622
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
129445: LD_ADDR_VAR 0 13
129449: PUSH
129450: LD_VAR 0 4
129454: PPUSH
129455: LD_INT 95
129457: PUSH
129458: LD_VAR 0 22
129462: PUSH
129463: EMPTY
129464: LIST
129465: LIST
129466: PUSH
129467: LD_INT 58
129469: PUSH
129470: EMPTY
129471: LIST
129472: PUSH
129473: EMPTY
129474: LIST
129475: LIST
129476: PPUSH
129477: CALL_OW 72
129481: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
129482: LD_VAR 0 4
129486: PUSH
129487: LD_VAR 0 7
129491: ARRAY
129492: PPUSH
129493: CALL_OW 314
129497: NOT
129498: IFFALSE 129620
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
129500: LD_ADDR_VAR 0 10
129504: PUSH
129505: LD_VAR 0 13
129509: PPUSH
129510: LD_VAR 0 4
129514: PUSH
129515: LD_VAR 0 7
129519: ARRAY
129520: PPUSH
129521: CALL_OW 74
129525: ST_TO_ADDR
// if not x then
129526: LD_VAR 0 10
129530: NOT
129531: IFFALSE 129535
// continue ;
129533: GO 128967
// if GetLives ( x ) < 1000 then
129535: LD_VAR 0 10
129539: PPUSH
129540: CALL_OW 256
129544: PUSH
129545: LD_INT 1000
129547: LESS
129548: IFFALSE 129572
// ComRepairVehicle ( group [ i ] , x ) else
129550: LD_VAR 0 4
129554: PUSH
129555: LD_VAR 0 7
129559: ARRAY
129560: PPUSH
129561: LD_VAR 0 10
129565: PPUSH
129566: CALL_OW 129
129570: GO 129620
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
129572: LD_VAR 0 23
129576: PUSH
129577: LD_VAR 0 4
129581: PUSH
129582: LD_VAR 0 7
129586: ARRAY
129587: PPUSH
129588: CALL_OW 256
129592: PUSH
129593: LD_INT 1000
129595: LESS
129596: AND
129597: NOT
129598: IFFALSE 129620
// ComEnterUnit ( group [ i ] , x ) ;
129600: LD_VAR 0 4
129604: PUSH
129605: LD_VAR 0 7
129609: ARRAY
129610: PPUSH
129611: LD_VAR 0 10
129615: PPUSH
129616: CALL_OW 120
// end ; continue ;
129620: GO 128967
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
129622: LD_VAR 0 23
129626: PUSH
129627: LD_VAR 0 4
129631: PUSH
129632: LD_VAR 0 7
129636: ARRAY
129637: PPUSH
129638: CALL_OW 247
129642: PUSH
129643: LD_INT 1
129645: EQUAL
129646: AND
129647: IFFALSE 130125
// begin if group [ i ] in healers then
129649: LD_VAR 0 4
129653: PUSH
129654: LD_VAR 0 7
129658: ARRAY
129659: PUSH
129660: LD_VAR 0 31
129664: IN
129665: IFFALSE 129938
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
129667: LD_VAR 0 4
129671: PUSH
129672: LD_VAR 0 7
129676: ARRAY
129677: PPUSH
129678: LD_VAR 0 23
129682: PPUSH
129683: CALL_OW 308
129687: NOT
129688: PUSH
129689: LD_VAR 0 4
129693: PUSH
129694: LD_VAR 0 7
129698: ARRAY
129699: PPUSH
129700: CALL_OW 314
129704: NOT
129705: AND
129706: IFFALSE 129730
// ComMoveToArea ( group [ i ] , f_heal ) else
129708: LD_VAR 0 4
129712: PUSH
129713: LD_VAR 0 7
129717: ARRAY
129718: PPUSH
129719: LD_VAR 0 23
129723: PPUSH
129724: CALL_OW 113
129728: GO 129936
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
129730: LD_VAR 0 4
129734: PUSH
129735: LD_VAR 0 7
129739: ARRAY
129740: PPUSH
129741: CALL 102068 0 1
129745: PPUSH
129746: CALL_OW 256
129750: PUSH
129751: LD_INT 1000
129753: EQUAL
129754: IFFALSE 129773
// ComStop ( group [ i ] ) else
129756: LD_VAR 0 4
129760: PUSH
129761: LD_VAR 0 7
129765: ARRAY
129766: PPUSH
129767: CALL_OW 141
129771: GO 129936
// if not HasTask ( group [ i ] ) and to_heal then
129773: LD_VAR 0 4
129777: PUSH
129778: LD_VAR 0 7
129782: ARRAY
129783: PPUSH
129784: CALL_OW 314
129788: NOT
129789: PUSH
129790: LD_VAR 0 30
129794: AND
129795: IFFALSE 129936
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
129797: LD_ADDR_VAR 0 13
129801: PUSH
129802: LD_VAR 0 30
129806: PPUSH
129807: LD_INT 3
129809: PUSH
129810: LD_INT 54
129812: PUSH
129813: EMPTY
129814: LIST
129815: PUSH
129816: EMPTY
129817: LIST
129818: LIST
129819: PPUSH
129820: CALL_OW 72
129824: PPUSH
129825: LD_VAR 0 4
129829: PUSH
129830: LD_VAR 0 7
129834: ARRAY
129835: PPUSH
129836: CALL_OW 74
129840: ST_TO_ADDR
// if z then
129841: LD_VAR 0 13
129845: IFFALSE 129936
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
129847: LD_INT 91
129849: PUSH
129850: LD_VAR 0 13
129854: PUSH
129855: LD_INT 10
129857: PUSH
129858: EMPTY
129859: LIST
129860: LIST
129861: LIST
129862: PUSH
129863: LD_INT 81
129865: PUSH
129866: LD_VAR 0 13
129870: PPUSH
129871: CALL_OW 255
129875: PUSH
129876: EMPTY
129877: LIST
129878: LIST
129879: PUSH
129880: EMPTY
129881: LIST
129882: LIST
129883: PPUSH
129884: CALL_OW 69
129888: PUSH
129889: LD_INT 0
129891: EQUAL
129892: IFFALSE 129916
// ComHeal ( group [ i ] , z ) else
129894: LD_VAR 0 4
129898: PUSH
129899: LD_VAR 0 7
129903: ARRAY
129904: PPUSH
129905: LD_VAR 0 13
129909: PPUSH
129910: CALL_OW 128
129914: GO 129936
// ComMoveToArea ( group [ i ] , f_heal ) ;
129916: LD_VAR 0 4
129920: PUSH
129921: LD_VAR 0 7
129925: ARRAY
129926: PPUSH
129927: LD_VAR 0 23
129931: PPUSH
129932: CALL_OW 113
// end ; continue ;
129936: GO 128967
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
129938: LD_VAR 0 4
129942: PUSH
129943: LD_VAR 0 7
129947: ARRAY
129948: PPUSH
129949: CALL_OW 256
129953: PUSH
129954: LD_INT 700
129956: LESS
129957: PUSH
129958: LD_VAR 0 4
129962: PUSH
129963: LD_VAR 0 7
129967: ARRAY
129968: PUSH
129969: LD_VAR 0 30
129973: IN
129974: NOT
129975: AND
129976: IFFALSE 130000
// to_heal := to_heal union group [ i ] ;
129978: LD_ADDR_VAR 0 30
129982: PUSH
129983: LD_VAR 0 30
129987: PUSH
129988: LD_VAR 0 4
129992: PUSH
129993: LD_VAR 0 7
129997: ARRAY
129998: UNION
129999: ST_TO_ADDR
// if group [ i ] in to_heal then
130000: LD_VAR 0 4
130004: PUSH
130005: LD_VAR 0 7
130009: ARRAY
130010: PUSH
130011: LD_VAR 0 30
130015: IN
130016: IFFALSE 130125
// begin if GetLives ( group [ i ] ) = 1000 then
130018: LD_VAR 0 4
130022: PUSH
130023: LD_VAR 0 7
130027: ARRAY
130028: PPUSH
130029: CALL_OW 256
130033: PUSH
130034: LD_INT 1000
130036: EQUAL
130037: IFFALSE 130063
// to_heal := to_heal diff group [ i ] else
130039: LD_ADDR_VAR 0 30
130043: PUSH
130044: LD_VAR 0 30
130048: PUSH
130049: LD_VAR 0 4
130053: PUSH
130054: LD_VAR 0 7
130058: ARRAY
130059: DIFF
130060: ST_TO_ADDR
130061: GO 130125
// begin if not IsInArea ( group [ i ] , to_heal ) then
130063: LD_VAR 0 4
130067: PUSH
130068: LD_VAR 0 7
130072: ARRAY
130073: PPUSH
130074: LD_VAR 0 30
130078: PPUSH
130079: CALL_OW 308
130083: NOT
130084: IFFALSE 130108
// ComMoveToArea ( group [ i ] , f_heal ) else
130086: LD_VAR 0 4
130090: PUSH
130091: LD_VAR 0 7
130095: ARRAY
130096: PPUSH
130097: LD_VAR 0 23
130101: PPUSH
130102: CALL_OW 113
130106: GO 130123
// ComHold ( group [ i ] ) ;
130108: LD_VAR 0 4
130112: PUSH
130113: LD_VAR 0 7
130117: ARRAY
130118: PPUSH
130119: CALL_OW 140
// continue ;
130123: GO 128967
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
130125: LD_VAR 0 4
130129: PUSH
130130: LD_VAR 0 7
130134: ARRAY
130135: PPUSH
130136: LD_INT 10
130138: PPUSH
130139: CALL 99865 0 2
130143: NOT
130144: PUSH
130145: LD_VAR 0 16
130149: PUSH
130150: LD_VAR 0 7
130154: ARRAY
130155: PUSH
130156: EMPTY
130157: EQUAL
130158: NOT
130159: AND
130160: IFFALSE 130426
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
130162: LD_VAR 0 4
130166: PUSH
130167: LD_VAR 0 7
130171: ARRAY
130172: PPUSH
130173: CALL_OW 262
130177: PUSH
130178: LD_INT 1
130180: PUSH
130181: LD_INT 2
130183: PUSH
130184: EMPTY
130185: LIST
130186: LIST
130187: IN
130188: IFFALSE 130229
// if GetFuel ( group [ i ] ) < 10 then
130190: LD_VAR 0 4
130194: PUSH
130195: LD_VAR 0 7
130199: ARRAY
130200: PPUSH
130201: CALL_OW 261
130205: PUSH
130206: LD_INT 10
130208: LESS
130209: IFFALSE 130229
// SetFuel ( group [ i ] , 12 ) ;
130211: LD_VAR 0 4
130215: PUSH
130216: LD_VAR 0 7
130220: ARRAY
130221: PPUSH
130222: LD_INT 12
130224: PPUSH
130225: CALL_OW 240
// if units_path [ i ] then
130229: LD_VAR 0 16
130233: PUSH
130234: LD_VAR 0 7
130238: ARRAY
130239: IFFALSE 130424
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
130241: LD_VAR 0 4
130245: PUSH
130246: LD_VAR 0 7
130250: ARRAY
130251: PPUSH
130252: LD_VAR 0 16
130256: PUSH
130257: LD_VAR 0 7
130261: ARRAY
130262: PUSH
130263: LD_INT 1
130265: ARRAY
130266: PUSH
130267: LD_INT 1
130269: ARRAY
130270: PPUSH
130271: LD_VAR 0 16
130275: PUSH
130276: LD_VAR 0 7
130280: ARRAY
130281: PUSH
130282: LD_INT 1
130284: ARRAY
130285: PUSH
130286: LD_INT 2
130288: ARRAY
130289: PPUSH
130290: CALL_OW 297
130294: PUSH
130295: LD_INT 6
130297: GREATER
130298: IFFALSE 130373
// begin if not HasTask ( group [ i ] ) then
130300: LD_VAR 0 4
130304: PUSH
130305: LD_VAR 0 7
130309: ARRAY
130310: PPUSH
130311: CALL_OW 314
130315: NOT
130316: IFFALSE 130371
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
130318: LD_VAR 0 4
130322: PUSH
130323: LD_VAR 0 7
130327: ARRAY
130328: PPUSH
130329: LD_VAR 0 16
130333: PUSH
130334: LD_VAR 0 7
130338: ARRAY
130339: PUSH
130340: LD_INT 1
130342: ARRAY
130343: PUSH
130344: LD_INT 1
130346: ARRAY
130347: PPUSH
130348: LD_VAR 0 16
130352: PUSH
130353: LD_VAR 0 7
130357: ARRAY
130358: PUSH
130359: LD_INT 1
130361: ARRAY
130362: PUSH
130363: LD_INT 2
130365: ARRAY
130366: PPUSH
130367: CALL_OW 114
// end else
130371: GO 130424
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
130373: LD_ADDR_VAR 0 15
130377: PUSH
130378: LD_VAR 0 16
130382: PUSH
130383: LD_VAR 0 7
130387: ARRAY
130388: PPUSH
130389: LD_INT 1
130391: PPUSH
130392: CALL_OW 3
130396: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
130397: LD_ADDR_VAR 0 16
130401: PUSH
130402: LD_VAR 0 16
130406: PPUSH
130407: LD_VAR 0 7
130411: PPUSH
130412: LD_VAR 0 15
130416: PPUSH
130417: CALL_OW 1
130421: ST_TO_ADDR
// continue ;
130422: GO 128967
// end ; end ; end else
130424: GO 133088
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
130426: LD_ADDR_VAR 0 14
130430: PUSH
130431: LD_INT 81
130433: PUSH
130434: LD_VAR 0 4
130438: PUSH
130439: LD_VAR 0 7
130443: ARRAY
130444: PPUSH
130445: CALL_OW 255
130449: PUSH
130450: EMPTY
130451: LIST
130452: LIST
130453: PPUSH
130454: CALL_OW 69
130458: ST_TO_ADDR
// if not tmp then
130459: LD_VAR 0 14
130463: NOT
130464: IFFALSE 130468
// continue ;
130466: GO 128967
// if f_ignore_area then
130468: LD_VAR 0 17
130472: IFFALSE 130560
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
130474: LD_ADDR_VAR 0 15
130478: PUSH
130479: LD_VAR 0 14
130483: PPUSH
130484: LD_INT 3
130486: PUSH
130487: LD_INT 92
130489: PUSH
130490: LD_VAR 0 17
130494: PUSH
130495: LD_INT 1
130497: ARRAY
130498: PUSH
130499: LD_VAR 0 17
130503: PUSH
130504: LD_INT 2
130506: ARRAY
130507: PUSH
130508: LD_VAR 0 17
130512: PUSH
130513: LD_INT 3
130515: ARRAY
130516: PUSH
130517: EMPTY
130518: LIST
130519: LIST
130520: LIST
130521: LIST
130522: PUSH
130523: EMPTY
130524: LIST
130525: LIST
130526: PPUSH
130527: CALL_OW 72
130531: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
130532: LD_VAR 0 14
130536: PUSH
130537: LD_VAR 0 15
130541: DIFF
130542: IFFALSE 130560
// tmp := tmp diff tmp2 ;
130544: LD_ADDR_VAR 0 14
130548: PUSH
130549: LD_VAR 0 14
130553: PUSH
130554: LD_VAR 0 15
130558: DIFF
130559: ST_TO_ADDR
// end ; if not f_murder then
130560: LD_VAR 0 20
130564: NOT
130565: IFFALSE 130623
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
130567: LD_ADDR_VAR 0 15
130571: PUSH
130572: LD_VAR 0 14
130576: PPUSH
130577: LD_INT 3
130579: PUSH
130580: LD_INT 50
130582: PUSH
130583: EMPTY
130584: LIST
130585: PUSH
130586: EMPTY
130587: LIST
130588: LIST
130589: PPUSH
130590: CALL_OW 72
130594: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
130595: LD_VAR 0 14
130599: PUSH
130600: LD_VAR 0 15
130604: DIFF
130605: IFFALSE 130623
// tmp := tmp diff tmp2 ;
130607: LD_ADDR_VAR 0 14
130611: PUSH
130612: LD_VAR 0 14
130616: PUSH
130617: LD_VAR 0 15
130621: DIFF
130622: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
130623: LD_ADDR_VAR 0 14
130627: PUSH
130628: LD_VAR 0 4
130632: PUSH
130633: LD_VAR 0 7
130637: ARRAY
130638: PPUSH
130639: LD_VAR 0 14
130643: PPUSH
130644: LD_INT 1
130646: PPUSH
130647: LD_INT 1
130649: PPUSH
130650: CALL 72806 0 4
130654: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
130655: LD_VAR 0 4
130659: PUSH
130660: LD_VAR 0 7
130664: ARRAY
130665: PPUSH
130666: CALL_OW 257
130670: PUSH
130671: LD_INT 1
130673: EQUAL
130674: IFFALSE 131122
// begin if WantPlant ( group [ i ] ) then
130676: LD_VAR 0 4
130680: PUSH
130681: LD_VAR 0 7
130685: ARRAY
130686: PPUSH
130687: CALL 72307 0 1
130691: IFFALSE 130695
// continue ;
130693: GO 128967
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
130695: LD_VAR 0 18
130699: PUSH
130700: LD_VAR 0 4
130704: PUSH
130705: LD_VAR 0 7
130709: ARRAY
130710: PPUSH
130711: CALL_OW 310
130715: NOT
130716: AND
130717: PUSH
130718: LD_VAR 0 14
130722: PUSH
130723: LD_INT 1
130725: ARRAY
130726: PUSH
130727: LD_VAR 0 14
130731: PPUSH
130732: LD_INT 21
130734: PUSH
130735: LD_INT 2
130737: PUSH
130738: EMPTY
130739: LIST
130740: LIST
130741: PUSH
130742: LD_INT 58
130744: PUSH
130745: EMPTY
130746: LIST
130747: PUSH
130748: EMPTY
130749: LIST
130750: LIST
130751: PPUSH
130752: CALL_OW 72
130756: IN
130757: AND
130758: IFFALSE 130794
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
130760: LD_VAR 0 4
130764: PUSH
130765: LD_VAR 0 7
130769: ARRAY
130770: PPUSH
130771: LD_VAR 0 14
130775: PUSH
130776: LD_INT 1
130778: ARRAY
130779: PPUSH
130780: CALL_OW 120
// attacking := true ;
130784: LD_ADDR_VAR 0 29
130788: PUSH
130789: LD_INT 1
130791: ST_TO_ADDR
// continue ;
130792: GO 128967
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
130794: LD_VAR 0 26
130798: PUSH
130799: LD_VAR 0 4
130803: PUSH
130804: LD_VAR 0 7
130808: ARRAY
130809: PPUSH
130810: CALL_OW 257
130814: PUSH
130815: LD_INT 1
130817: EQUAL
130818: AND
130819: PUSH
130820: LD_VAR 0 4
130824: PUSH
130825: LD_VAR 0 7
130829: ARRAY
130830: PPUSH
130831: CALL_OW 256
130835: PUSH
130836: LD_INT 800
130838: LESS
130839: AND
130840: PUSH
130841: LD_VAR 0 4
130845: PUSH
130846: LD_VAR 0 7
130850: ARRAY
130851: PPUSH
130852: CALL_OW 318
130856: NOT
130857: AND
130858: IFFALSE 130875
// ComCrawl ( group [ i ] ) ;
130860: LD_VAR 0 4
130864: PUSH
130865: LD_VAR 0 7
130869: ARRAY
130870: PPUSH
130871: CALL_OW 137
// if f_mines then
130875: LD_VAR 0 21
130879: IFFALSE 131122
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
130881: LD_VAR 0 14
130885: PUSH
130886: LD_INT 1
130888: ARRAY
130889: PPUSH
130890: CALL_OW 247
130894: PUSH
130895: LD_INT 3
130897: EQUAL
130898: PUSH
130899: LD_VAR 0 14
130903: PUSH
130904: LD_INT 1
130906: ARRAY
130907: PUSH
130908: LD_VAR 0 27
130912: IN
130913: NOT
130914: AND
130915: IFFALSE 131122
// begin x := GetX ( tmp [ 1 ] ) ;
130917: LD_ADDR_VAR 0 10
130921: PUSH
130922: LD_VAR 0 14
130926: PUSH
130927: LD_INT 1
130929: ARRAY
130930: PPUSH
130931: CALL_OW 250
130935: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
130936: LD_ADDR_VAR 0 11
130940: PUSH
130941: LD_VAR 0 14
130945: PUSH
130946: LD_INT 1
130948: ARRAY
130949: PPUSH
130950: CALL_OW 251
130954: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
130955: LD_ADDR_VAR 0 12
130959: PUSH
130960: LD_VAR 0 4
130964: PUSH
130965: LD_VAR 0 7
130969: ARRAY
130970: PPUSH
130971: CALL 99950 0 1
130975: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
130976: LD_VAR 0 4
130980: PUSH
130981: LD_VAR 0 7
130985: ARRAY
130986: PPUSH
130987: LD_VAR 0 10
130991: PPUSH
130992: LD_VAR 0 11
130996: PPUSH
130997: LD_VAR 0 14
131001: PUSH
131002: LD_INT 1
131004: ARRAY
131005: PPUSH
131006: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
131010: LD_VAR 0 4
131014: PUSH
131015: LD_VAR 0 7
131019: ARRAY
131020: PPUSH
131021: LD_VAR 0 10
131025: PPUSH
131026: LD_VAR 0 12
131030: PPUSH
131031: LD_INT 7
131033: PPUSH
131034: CALL_OW 272
131038: PPUSH
131039: LD_VAR 0 11
131043: PPUSH
131044: LD_VAR 0 12
131048: PPUSH
131049: LD_INT 7
131051: PPUSH
131052: CALL_OW 273
131056: PPUSH
131057: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
131061: LD_VAR 0 4
131065: PUSH
131066: LD_VAR 0 7
131070: ARRAY
131071: PPUSH
131072: LD_INT 71
131074: PPUSH
131075: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
131079: LD_ADDR_VAR 0 27
131083: PUSH
131084: LD_VAR 0 27
131088: PPUSH
131089: LD_VAR 0 27
131093: PUSH
131094: LD_INT 1
131096: PLUS
131097: PPUSH
131098: LD_VAR 0 14
131102: PUSH
131103: LD_INT 1
131105: ARRAY
131106: PPUSH
131107: CALL_OW 1
131111: ST_TO_ADDR
// attacking := true ;
131112: LD_ADDR_VAR 0 29
131116: PUSH
131117: LD_INT 1
131119: ST_TO_ADDR
// continue ;
131120: GO 128967
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
131122: LD_VAR 0 4
131126: PUSH
131127: LD_VAR 0 7
131131: ARRAY
131132: PPUSH
131133: CALL_OW 257
131137: PUSH
131138: LD_INT 17
131140: EQUAL
131141: PUSH
131142: LD_VAR 0 4
131146: PUSH
131147: LD_VAR 0 7
131151: ARRAY
131152: PPUSH
131153: CALL_OW 110
131157: PUSH
131158: LD_INT 71
131160: EQUAL
131161: NOT
131162: AND
131163: IFFALSE 131309
// begin attacking := false ;
131165: LD_ADDR_VAR 0 29
131169: PUSH
131170: LD_INT 0
131172: ST_TO_ADDR
// k := 5 ;
131173: LD_ADDR_VAR 0 9
131177: PUSH
131178: LD_INT 5
131180: ST_TO_ADDR
// if tmp < k then
131181: LD_VAR 0 14
131185: PUSH
131186: LD_VAR 0 9
131190: LESS
131191: IFFALSE 131203
// k := tmp ;
131193: LD_ADDR_VAR 0 9
131197: PUSH
131198: LD_VAR 0 14
131202: ST_TO_ADDR
// for j = 1 to k do
131203: LD_ADDR_VAR 0 8
131207: PUSH
131208: DOUBLE
131209: LD_INT 1
131211: DEC
131212: ST_TO_ADDR
131213: LD_VAR 0 9
131217: PUSH
131218: FOR_TO
131219: IFFALSE 131307
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
131221: LD_VAR 0 14
131225: PUSH
131226: LD_VAR 0 8
131230: ARRAY
131231: PUSH
131232: LD_VAR 0 14
131236: PPUSH
131237: LD_INT 58
131239: PUSH
131240: EMPTY
131241: LIST
131242: PPUSH
131243: CALL_OW 72
131247: IN
131248: NOT
131249: IFFALSE 131305
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
131251: LD_VAR 0 4
131255: PUSH
131256: LD_VAR 0 7
131260: ARRAY
131261: PPUSH
131262: LD_VAR 0 14
131266: PUSH
131267: LD_VAR 0 8
131271: ARRAY
131272: PPUSH
131273: CALL_OW 115
// attacking := true ;
131277: LD_ADDR_VAR 0 29
131281: PUSH
131282: LD_INT 1
131284: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
131285: LD_VAR 0 4
131289: PUSH
131290: LD_VAR 0 7
131294: ARRAY
131295: PPUSH
131296: LD_INT 71
131298: PPUSH
131299: CALL_OW 109
// continue ;
131303: GO 131218
// end ; end ;
131305: GO 131218
131307: POP
131308: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
131309: LD_VAR 0 4
131313: PUSH
131314: LD_VAR 0 7
131318: ARRAY
131319: PPUSH
131320: CALL_OW 257
131324: PUSH
131325: LD_INT 8
131327: EQUAL
131328: PUSH
131329: LD_VAR 0 4
131333: PUSH
131334: LD_VAR 0 7
131338: ARRAY
131339: PPUSH
131340: CALL_OW 264
131344: PUSH
131345: LD_INT 28
131347: PUSH
131348: LD_INT 45
131350: PUSH
131351: LD_INT 7
131353: PUSH
131354: LD_INT 47
131356: PUSH
131357: EMPTY
131358: LIST
131359: LIST
131360: LIST
131361: LIST
131362: IN
131363: OR
131364: IFFALSE 131620
// begin attacking := false ;
131366: LD_ADDR_VAR 0 29
131370: PUSH
131371: LD_INT 0
131373: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
131374: LD_VAR 0 14
131378: PUSH
131379: LD_INT 1
131381: ARRAY
131382: PPUSH
131383: CALL_OW 266
131387: PUSH
131388: LD_INT 32
131390: PUSH
131391: LD_INT 31
131393: PUSH
131394: LD_INT 33
131396: PUSH
131397: LD_INT 4
131399: PUSH
131400: LD_INT 5
131402: PUSH
131403: EMPTY
131404: LIST
131405: LIST
131406: LIST
131407: LIST
131408: LIST
131409: IN
131410: IFFALSE 131596
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
131412: LD_ADDR_VAR 0 9
131416: PUSH
131417: LD_VAR 0 14
131421: PUSH
131422: LD_INT 1
131424: ARRAY
131425: PPUSH
131426: CALL_OW 266
131430: PPUSH
131431: LD_VAR 0 14
131435: PUSH
131436: LD_INT 1
131438: ARRAY
131439: PPUSH
131440: CALL_OW 250
131444: PPUSH
131445: LD_VAR 0 14
131449: PUSH
131450: LD_INT 1
131452: ARRAY
131453: PPUSH
131454: CALL_OW 251
131458: PPUSH
131459: LD_VAR 0 14
131463: PUSH
131464: LD_INT 1
131466: ARRAY
131467: PPUSH
131468: CALL_OW 254
131472: PPUSH
131473: LD_VAR 0 14
131477: PUSH
131478: LD_INT 1
131480: ARRAY
131481: PPUSH
131482: CALL_OW 248
131486: PPUSH
131487: LD_INT 0
131489: PPUSH
131490: CALL 81320 0 6
131494: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
131495: LD_ADDR_VAR 0 8
131499: PUSH
131500: LD_VAR 0 4
131504: PUSH
131505: LD_VAR 0 7
131509: ARRAY
131510: PPUSH
131511: LD_VAR 0 9
131515: PPUSH
131516: CALL 100063 0 2
131520: ST_TO_ADDR
// if j then
131521: LD_VAR 0 8
131525: IFFALSE 131594
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
131527: LD_VAR 0 8
131531: PUSH
131532: LD_INT 1
131534: ARRAY
131535: PPUSH
131536: LD_VAR 0 8
131540: PUSH
131541: LD_INT 2
131543: ARRAY
131544: PPUSH
131545: CALL_OW 488
131549: IFFALSE 131594
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
131551: LD_VAR 0 4
131555: PUSH
131556: LD_VAR 0 7
131560: ARRAY
131561: PPUSH
131562: LD_VAR 0 8
131566: PUSH
131567: LD_INT 1
131569: ARRAY
131570: PPUSH
131571: LD_VAR 0 8
131575: PUSH
131576: LD_INT 2
131578: ARRAY
131579: PPUSH
131580: CALL_OW 116
// attacking := true ;
131584: LD_ADDR_VAR 0 29
131588: PUSH
131589: LD_INT 1
131591: ST_TO_ADDR
// continue ;
131592: GO 128967
// end ; end else
131594: GO 131620
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
131596: LD_VAR 0 4
131600: PUSH
131601: LD_VAR 0 7
131605: ARRAY
131606: PPUSH
131607: LD_VAR 0 14
131611: PUSH
131612: LD_INT 1
131614: ARRAY
131615: PPUSH
131616: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
131620: LD_VAR 0 4
131624: PUSH
131625: LD_VAR 0 7
131629: ARRAY
131630: PPUSH
131631: CALL_OW 265
131635: PUSH
131636: LD_INT 11
131638: EQUAL
131639: IFFALSE 131917
// begin k := 10 ;
131641: LD_ADDR_VAR 0 9
131645: PUSH
131646: LD_INT 10
131648: ST_TO_ADDR
// x := 0 ;
131649: LD_ADDR_VAR 0 10
131653: PUSH
131654: LD_INT 0
131656: ST_TO_ADDR
// if tmp < k then
131657: LD_VAR 0 14
131661: PUSH
131662: LD_VAR 0 9
131666: LESS
131667: IFFALSE 131679
// k := tmp ;
131669: LD_ADDR_VAR 0 9
131673: PUSH
131674: LD_VAR 0 14
131678: ST_TO_ADDR
// for j = k downto 1 do
131679: LD_ADDR_VAR 0 8
131683: PUSH
131684: DOUBLE
131685: LD_VAR 0 9
131689: INC
131690: ST_TO_ADDR
131691: LD_INT 1
131693: PUSH
131694: FOR_DOWNTO
131695: IFFALSE 131770
// begin if GetType ( tmp [ j ] ) = unit_human then
131697: LD_VAR 0 14
131701: PUSH
131702: LD_VAR 0 8
131706: ARRAY
131707: PPUSH
131708: CALL_OW 247
131712: PUSH
131713: LD_INT 1
131715: EQUAL
131716: IFFALSE 131768
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
131718: LD_VAR 0 4
131722: PUSH
131723: LD_VAR 0 7
131727: ARRAY
131728: PPUSH
131729: LD_VAR 0 14
131733: PUSH
131734: LD_VAR 0 8
131738: ARRAY
131739: PPUSH
131740: CALL 100317 0 2
// x := tmp [ j ] ;
131744: LD_ADDR_VAR 0 10
131748: PUSH
131749: LD_VAR 0 14
131753: PUSH
131754: LD_VAR 0 8
131758: ARRAY
131759: ST_TO_ADDR
// attacking := true ;
131760: LD_ADDR_VAR 0 29
131764: PUSH
131765: LD_INT 1
131767: ST_TO_ADDR
// end ; end ;
131768: GO 131694
131770: POP
131771: POP
// if not x then
131772: LD_VAR 0 10
131776: NOT
131777: IFFALSE 131917
// begin attacking := true ;
131779: LD_ADDR_VAR 0 29
131783: PUSH
131784: LD_INT 1
131786: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
131787: LD_VAR 0 4
131791: PUSH
131792: LD_VAR 0 7
131796: ARRAY
131797: PPUSH
131798: CALL_OW 250
131802: PPUSH
131803: LD_VAR 0 4
131807: PUSH
131808: LD_VAR 0 7
131812: ARRAY
131813: PPUSH
131814: CALL_OW 251
131818: PPUSH
131819: CALL_OW 546
131823: PUSH
131824: LD_INT 2
131826: ARRAY
131827: PUSH
131828: LD_VAR 0 14
131832: PUSH
131833: LD_INT 1
131835: ARRAY
131836: PPUSH
131837: CALL_OW 250
131841: PPUSH
131842: LD_VAR 0 14
131846: PUSH
131847: LD_INT 1
131849: ARRAY
131850: PPUSH
131851: CALL_OW 251
131855: PPUSH
131856: CALL_OW 546
131860: PUSH
131861: LD_INT 2
131863: ARRAY
131864: EQUAL
131865: IFFALSE 131893
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
131867: LD_VAR 0 4
131871: PUSH
131872: LD_VAR 0 7
131876: ARRAY
131877: PPUSH
131878: LD_VAR 0 14
131882: PUSH
131883: LD_INT 1
131885: ARRAY
131886: PPUSH
131887: CALL 100317 0 2
131891: GO 131917
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
131893: LD_VAR 0 4
131897: PUSH
131898: LD_VAR 0 7
131902: ARRAY
131903: PPUSH
131904: LD_VAR 0 14
131908: PUSH
131909: LD_INT 1
131911: ARRAY
131912: PPUSH
131913: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
131917: LD_VAR 0 4
131921: PUSH
131922: LD_VAR 0 7
131926: ARRAY
131927: PPUSH
131928: CALL_OW 264
131932: PUSH
131933: LD_INT 29
131935: EQUAL
131936: IFFALSE 132302
// begin if WantsToAttack ( group [ i ] ) in bombed then
131938: LD_VAR 0 4
131942: PUSH
131943: LD_VAR 0 7
131947: ARRAY
131948: PPUSH
131949: CALL_OW 319
131953: PUSH
131954: LD_VAR 0 28
131958: IN
131959: IFFALSE 131963
// continue ;
131961: GO 128967
// k := 8 ;
131963: LD_ADDR_VAR 0 9
131967: PUSH
131968: LD_INT 8
131970: ST_TO_ADDR
// x := 0 ;
131971: LD_ADDR_VAR 0 10
131975: PUSH
131976: LD_INT 0
131978: ST_TO_ADDR
// if tmp < k then
131979: LD_VAR 0 14
131983: PUSH
131984: LD_VAR 0 9
131988: LESS
131989: IFFALSE 132001
// k := tmp ;
131991: LD_ADDR_VAR 0 9
131995: PUSH
131996: LD_VAR 0 14
132000: ST_TO_ADDR
// for j = 1 to k do
132001: LD_ADDR_VAR 0 8
132005: PUSH
132006: DOUBLE
132007: LD_INT 1
132009: DEC
132010: ST_TO_ADDR
132011: LD_VAR 0 9
132015: PUSH
132016: FOR_TO
132017: IFFALSE 132149
// begin if GetType ( tmp [ j ] ) = unit_building then
132019: LD_VAR 0 14
132023: PUSH
132024: LD_VAR 0 8
132028: ARRAY
132029: PPUSH
132030: CALL_OW 247
132034: PUSH
132035: LD_INT 3
132037: EQUAL
132038: IFFALSE 132147
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
132040: LD_VAR 0 14
132044: PUSH
132045: LD_VAR 0 8
132049: ARRAY
132050: PUSH
132051: LD_VAR 0 28
132055: IN
132056: NOT
132057: PUSH
132058: LD_VAR 0 14
132062: PUSH
132063: LD_VAR 0 8
132067: ARRAY
132068: PPUSH
132069: CALL_OW 313
132073: AND
132074: IFFALSE 132147
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
132076: LD_VAR 0 4
132080: PUSH
132081: LD_VAR 0 7
132085: ARRAY
132086: PPUSH
132087: LD_VAR 0 14
132091: PUSH
132092: LD_VAR 0 8
132096: ARRAY
132097: PPUSH
132098: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
132102: LD_ADDR_VAR 0 28
132106: PUSH
132107: LD_VAR 0 28
132111: PPUSH
132112: LD_VAR 0 28
132116: PUSH
132117: LD_INT 1
132119: PLUS
132120: PPUSH
132121: LD_VAR 0 14
132125: PUSH
132126: LD_VAR 0 8
132130: ARRAY
132131: PPUSH
132132: CALL_OW 1
132136: ST_TO_ADDR
// attacking := true ;
132137: LD_ADDR_VAR 0 29
132141: PUSH
132142: LD_INT 1
132144: ST_TO_ADDR
// break ;
132145: GO 132149
// end ; end ;
132147: GO 132016
132149: POP
132150: POP
// if not attacking and f_attack_depot then
132151: LD_VAR 0 29
132155: NOT
132156: PUSH
132157: LD_VAR 0 25
132161: AND
132162: IFFALSE 132257
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
132164: LD_ADDR_VAR 0 13
132168: PUSH
132169: LD_VAR 0 14
132173: PPUSH
132174: LD_INT 2
132176: PUSH
132177: LD_INT 30
132179: PUSH
132180: LD_INT 0
132182: PUSH
132183: EMPTY
132184: LIST
132185: LIST
132186: PUSH
132187: LD_INT 30
132189: PUSH
132190: LD_INT 1
132192: PUSH
132193: EMPTY
132194: LIST
132195: LIST
132196: PUSH
132197: EMPTY
132198: LIST
132199: LIST
132200: LIST
132201: PPUSH
132202: CALL_OW 72
132206: ST_TO_ADDR
// if z then
132207: LD_VAR 0 13
132211: IFFALSE 132257
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
132213: LD_VAR 0 4
132217: PUSH
132218: LD_VAR 0 7
132222: ARRAY
132223: PPUSH
132224: LD_VAR 0 13
132228: PPUSH
132229: LD_VAR 0 4
132233: PUSH
132234: LD_VAR 0 7
132238: ARRAY
132239: PPUSH
132240: CALL_OW 74
132244: PPUSH
132245: CALL_OW 115
// attacking := true ;
132249: LD_ADDR_VAR 0 29
132253: PUSH
132254: LD_INT 1
132256: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
132257: LD_VAR 0 4
132261: PUSH
132262: LD_VAR 0 7
132266: ARRAY
132267: PPUSH
132268: CALL_OW 256
132272: PUSH
132273: LD_INT 500
132275: LESS
132276: IFFALSE 132302
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
132278: LD_VAR 0 4
132282: PUSH
132283: LD_VAR 0 7
132287: ARRAY
132288: PPUSH
132289: LD_VAR 0 14
132293: PUSH
132294: LD_INT 1
132296: ARRAY
132297: PPUSH
132298: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
132302: LD_VAR 0 4
132306: PUSH
132307: LD_VAR 0 7
132311: ARRAY
132312: PPUSH
132313: CALL_OW 264
132317: PUSH
132318: LD_INT 49
132320: EQUAL
132321: IFFALSE 132442
// begin if not HasTask ( group [ i ] ) then
132323: LD_VAR 0 4
132327: PUSH
132328: LD_VAR 0 7
132332: ARRAY
132333: PPUSH
132334: CALL_OW 314
132338: NOT
132339: IFFALSE 132442
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
132341: LD_ADDR_VAR 0 9
132345: PUSH
132346: LD_INT 81
132348: PUSH
132349: LD_VAR 0 4
132353: PUSH
132354: LD_VAR 0 7
132358: ARRAY
132359: PPUSH
132360: CALL_OW 255
132364: PUSH
132365: EMPTY
132366: LIST
132367: LIST
132368: PPUSH
132369: CALL_OW 69
132373: PPUSH
132374: LD_VAR 0 4
132378: PUSH
132379: LD_VAR 0 7
132383: ARRAY
132384: PPUSH
132385: CALL_OW 74
132389: ST_TO_ADDR
// if k then
132390: LD_VAR 0 9
132394: IFFALSE 132442
// if GetDistUnits ( group [ i ] , k ) > 10 then
132396: LD_VAR 0 4
132400: PUSH
132401: LD_VAR 0 7
132405: ARRAY
132406: PPUSH
132407: LD_VAR 0 9
132411: PPUSH
132412: CALL_OW 296
132416: PUSH
132417: LD_INT 10
132419: GREATER
132420: IFFALSE 132442
// ComMoveUnit ( group [ i ] , k ) ;
132422: LD_VAR 0 4
132426: PUSH
132427: LD_VAR 0 7
132431: ARRAY
132432: PPUSH
132433: LD_VAR 0 9
132437: PPUSH
132438: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
132442: LD_VAR 0 4
132446: PUSH
132447: LD_VAR 0 7
132451: ARRAY
132452: PPUSH
132453: CALL_OW 256
132457: PUSH
132458: LD_INT 250
132460: LESS
132461: PUSH
132462: LD_VAR 0 4
132466: PUSH
132467: LD_VAR 0 7
132471: ARRAY
132472: PUSH
132473: LD_INT 21
132475: PUSH
132476: LD_INT 2
132478: PUSH
132479: EMPTY
132480: LIST
132481: LIST
132482: PUSH
132483: LD_INT 23
132485: PUSH
132486: LD_INT 2
132488: PUSH
132489: EMPTY
132490: LIST
132491: LIST
132492: PUSH
132493: EMPTY
132494: LIST
132495: LIST
132496: PPUSH
132497: CALL_OW 69
132501: IN
132502: AND
132503: IFFALSE 132628
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
132505: LD_ADDR_VAR 0 9
132509: PUSH
132510: LD_OWVAR 3
132514: PUSH
132515: LD_VAR 0 4
132519: PUSH
132520: LD_VAR 0 7
132524: ARRAY
132525: DIFF
132526: PPUSH
132527: LD_VAR 0 4
132531: PUSH
132532: LD_VAR 0 7
132536: ARRAY
132537: PPUSH
132538: CALL_OW 74
132542: ST_TO_ADDR
// if not k then
132543: LD_VAR 0 9
132547: NOT
132548: IFFALSE 132552
// continue ;
132550: GO 128967
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
132552: LD_VAR 0 9
132556: PUSH
132557: LD_INT 81
132559: PUSH
132560: LD_VAR 0 4
132564: PUSH
132565: LD_VAR 0 7
132569: ARRAY
132570: PPUSH
132571: CALL_OW 255
132575: PUSH
132576: EMPTY
132577: LIST
132578: LIST
132579: PPUSH
132580: CALL_OW 69
132584: IN
132585: PUSH
132586: LD_VAR 0 9
132590: PPUSH
132591: LD_VAR 0 4
132595: PUSH
132596: LD_VAR 0 7
132600: ARRAY
132601: PPUSH
132602: CALL_OW 296
132606: PUSH
132607: LD_INT 5
132609: LESS
132610: AND
132611: IFFALSE 132628
// ComAutodestruct ( group [ i ] ) ;
132613: LD_VAR 0 4
132617: PUSH
132618: LD_VAR 0 7
132622: ARRAY
132623: PPUSH
132624: CALL 100215 0 1
// end ; if f_attack_depot then
132628: LD_VAR 0 25
132632: IFFALSE 132744
// begin k := 6 ;
132634: LD_ADDR_VAR 0 9
132638: PUSH
132639: LD_INT 6
132641: ST_TO_ADDR
// if tmp < k then
132642: LD_VAR 0 14
132646: PUSH
132647: LD_VAR 0 9
132651: LESS
132652: IFFALSE 132664
// k := tmp ;
132654: LD_ADDR_VAR 0 9
132658: PUSH
132659: LD_VAR 0 14
132663: ST_TO_ADDR
// for j = 1 to k do
132664: LD_ADDR_VAR 0 8
132668: PUSH
132669: DOUBLE
132670: LD_INT 1
132672: DEC
132673: ST_TO_ADDR
132674: LD_VAR 0 9
132678: PUSH
132679: FOR_TO
132680: IFFALSE 132742
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
132682: LD_VAR 0 8
132686: PPUSH
132687: CALL_OW 266
132691: PUSH
132692: LD_INT 0
132694: PUSH
132695: LD_INT 1
132697: PUSH
132698: EMPTY
132699: LIST
132700: LIST
132701: IN
132702: IFFALSE 132740
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
132704: LD_VAR 0 4
132708: PUSH
132709: LD_VAR 0 7
132713: ARRAY
132714: PPUSH
132715: LD_VAR 0 14
132719: PUSH
132720: LD_VAR 0 8
132724: ARRAY
132725: PPUSH
132726: CALL_OW 115
// attacking := true ;
132730: LD_ADDR_VAR 0 29
132734: PUSH
132735: LD_INT 1
132737: ST_TO_ADDR
// break ;
132738: GO 132742
// end ;
132740: GO 132679
132742: POP
132743: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
132744: LD_VAR 0 4
132748: PUSH
132749: LD_VAR 0 7
132753: ARRAY
132754: PPUSH
132755: CALL_OW 302
132759: PUSH
132760: LD_VAR 0 29
132764: NOT
132765: AND
132766: IFFALSE 133088
// begin if GetTag ( group [ i ] ) = 71 then
132768: LD_VAR 0 4
132772: PUSH
132773: LD_VAR 0 7
132777: ARRAY
132778: PPUSH
132779: CALL_OW 110
132783: PUSH
132784: LD_INT 71
132786: EQUAL
132787: IFFALSE 132828
// begin if HasTask ( group [ i ] ) then
132789: LD_VAR 0 4
132793: PUSH
132794: LD_VAR 0 7
132798: ARRAY
132799: PPUSH
132800: CALL_OW 314
132804: IFFALSE 132810
// continue else
132806: GO 128967
132808: GO 132828
// SetTag ( group [ i ] , 0 ) ;
132810: LD_VAR 0 4
132814: PUSH
132815: LD_VAR 0 7
132819: ARRAY
132820: PPUSH
132821: LD_INT 0
132823: PPUSH
132824: CALL_OW 109
// end ; k := 8 ;
132828: LD_ADDR_VAR 0 9
132832: PUSH
132833: LD_INT 8
132835: ST_TO_ADDR
// x := 0 ;
132836: LD_ADDR_VAR 0 10
132840: PUSH
132841: LD_INT 0
132843: ST_TO_ADDR
// if tmp < k then
132844: LD_VAR 0 14
132848: PUSH
132849: LD_VAR 0 9
132853: LESS
132854: IFFALSE 132866
// k := tmp ;
132856: LD_ADDR_VAR 0 9
132860: PUSH
132861: LD_VAR 0 14
132865: ST_TO_ADDR
// for j = 1 to k do
132866: LD_ADDR_VAR 0 8
132870: PUSH
132871: DOUBLE
132872: LD_INT 1
132874: DEC
132875: ST_TO_ADDR
132876: LD_VAR 0 9
132880: PUSH
132881: FOR_TO
132882: IFFALSE 132980
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
132884: LD_VAR 0 14
132888: PUSH
132889: LD_VAR 0 8
132893: ARRAY
132894: PPUSH
132895: CALL_OW 247
132899: PUSH
132900: LD_INT 1
132902: EQUAL
132903: PUSH
132904: LD_VAR 0 14
132908: PUSH
132909: LD_VAR 0 8
132913: ARRAY
132914: PPUSH
132915: CALL_OW 256
132919: PUSH
132920: LD_INT 250
132922: LESS
132923: PUSH
132924: LD_VAR 0 20
132928: AND
132929: PUSH
132930: LD_VAR 0 20
132934: NOT
132935: PUSH
132936: LD_VAR 0 14
132940: PUSH
132941: LD_VAR 0 8
132945: ARRAY
132946: PPUSH
132947: CALL_OW 256
132951: PUSH
132952: LD_INT 250
132954: GREATEREQUAL
132955: AND
132956: OR
132957: AND
132958: IFFALSE 132978
// begin x := tmp [ j ] ;
132960: LD_ADDR_VAR 0 10
132964: PUSH
132965: LD_VAR 0 14
132969: PUSH
132970: LD_VAR 0 8
132974: ARRAY
132975: ST_TO_ADDR
// break ;
132976: GO 132980
// end ;
132978: GO 132881
132980: POP
132981: POP
// if x then
132982: LD_VAR 0 10
132986: IFFALSE 133010
// ComAttackUnit ( group [ i ] , x ) else
132988: LD_VAR 0 4
132992: PUSH
132993: LD_VAR 0 7
132997: ARRAY
132998: PPUSH
132999: LD_VAR 0 10
133003: PPUSH
133004: CALL_OW 115
133008: GO 133034
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
133010: LD_VAR 0 4
133014: PUSH
133015: LD_VAR 0 7
133019: ARRAY
133020: PPUSH
133021: LD_VAR 0 14
133025: PUSH
133026: LD_INT 1
133028: ARRAY
133029: PPUSH
133030: CALL_OW 115
// if not HasTask ( group [ i ] ) then
133034: LD_VAR 0 4
133038: PUSH
133039: LD_VAR 0 7
133043: ARRAY
133044: PPUSH
133045: CALL_OW 314
133049: NOT
133050: IFFALSE 133088
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
133052: LD_VAR 0 4
133056: PUSH
133057: LD_VAR 0 7
133061: ARRAY
133062: PPUSH
133063: LD_VAR 0 14
133067: PPUSH
133068: LD_VAR 0 4
133072: PUSH
133073: LD_VAR 0 7
133077: ARRAY
133078: PPUSH
133079: CALL_OW 74
133083: PPUSH
133084: CALL_OW 115
// end ; end ; end ;
133088: GO 128967
133090: POP
133091: POP
// wait ( 0 0$2 ) ;
133092: LD_INT 70
133094: PPUSH
133095: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
133099: LD_VAR 0 4
133103: NOT
133104: PUSH
133105: LD_VAR 0 4
133109: PUSH
133110: EMPTY
133111: EQUAL
133112: OR
133113: PUSH
133114: LD_INT 81
133116: PUSH
133117: LD_VAR 0 35
133121: PUSH
133122: EMPTY
133123: LIST
133124: LIST
133125: PPUSH
133126: CALL_OW 69
133130: NOT
133131: OR
133132: IFFALSE 128952
// end ;
133134: LD_VAR 0 2
133138: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
133139: LD_INT 0
133141: PPUSH
133142: PPUSH
133143: PPUSH
133144: PPUSH
133145: PPUSH
133146: PPUSH
// if not base or not mc_bases [ base ] or not solds then
133147: LD_VAR 0 1
133151: NOT
133152: PUSH
133153: LD_EXP 99
133157: PUSH
133158: LD_VAR 0 1
133162: ARRAY
133163: NOT
133164: OR
133165: PUSH
133166: LD_VAR 0 2
133170: NOT
133171: OR
133172: IFFALSE 133176
// exit ;
133174: GO 133730
// side := mc_sides [ base ] ;
133176: LD_ADDR_VAR 0 6
133180: PUSH
133181: LD_EXP 125
133185: PUSH
133186: LD_VAR 0 1
133190: ARRAY
133191: ST_TO_ADDR
// if not side then
133192: LD_VAR 0 6
133196: NOT
133197: IFFALSE 133201
// exit ;
133199: GO 133730
// for i in solds do
133201: LD_ADDR_VAR 0 7
133205: PUSH
133206: LD_VAR 0 2
133210: PUSH
133211: FOR_IN
133212: IFFALSE 133273
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
133214: LD_VAR 0 7
133218: PPUSH
133219: CALL_OW 310
133223: PPUSH
133224: CALL_OW 266
133228: PUSH
133229: LD_INT 32
133231: PUSH
133232: LD_INT 31
133234: PUSH
133235: EMPTY
133236: LIST
133237: LIST
133238: IN
133239: IFFALSE 133259
// solds := solds diff i else
133241: LD_ADDR_VAR 0 2
133245: PUSH
133246: LD_VAR 0 2
133250: PUSH
133251: LD_VAR 0 7
133255: DIFF
133256: ST_TO_ADDR
133257: GO 133271
// SetTag ( i , 18 ) ;
133259: LD_VAR 0 7
133263: PPUSH
133264: LD_INT 18
133266: PPUSH
133267: CALL_OW 109
133271: GO 133211
133273: POP
133274: POP
// if not solds then
133275: LD_VAR 0 2
133279: NOT
133280: IFFALSE 133284
// exit ;
133282: GO 133730
// repeat wait ( 0 0$2 ) ;
133284: LD_INT 70
133286: PPUSH
133287: CALL_OW 67
// enemy := mc_scan [ base ] ;
133291: LD_ADDR_VAR 0 4
133295: PUSH
133296: LD_EXP 122
133300: PUSH
133301: LD_VAR 0 1
133305: ARRAY
133306: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
133307: LD_EXP 99
133311: PUSH
133312: LD_VAR 0 1
133316: ARRAY
133317: NOT
133318: PUSH
133319: LD_EXP 99
133323: PUSH
133324: LD_VAR 0 1
133328: ARRAY
133329: PUSH
133330: EMPTY
133331: EQUAL
133332: OR
133333: IFFALSE 133370
// begin for i in solds do
133335: LD_ADDR_VAR 0 7
133339: PUSH
133340: LD_VAR 0 2
133344: PUSH
133345: FOR_IN
133346: IFFALSE 133359
// ComStop ( i ) ;
133348: LD_VAR 0 7
133352: PPUSH
133353: CALL_OW 141
133357: GO 133345
133359: POP
133360: POP
// solds := [ ] ;
133361: LD_ADDR_VAR 0 2
133365: PUSH
133366: EMPTY
133367: ST_TO_ADDR
// exit ;
133368: GO 133730
// end ; for i in solds do
133370: LD_ADDR_VAR 0 7
133374: PUSH
133375: LD_VAR 0 2
133379: PUSH
133380: FOR_IN
133381: IFFALSE 133702
// begin if IsInUnit ( i ) then
133383: LD_VAR 0 7
133387: PPUSH
133388: CALL_OW 310
133392: IFFALSE 133403
// ComExitBuilding ( i ) ;
133394: LD_VAR 0 7
133398: PPUSH
133399: CALL_OW 122
// if GetLives ( i ) > 500 then
133403: LD_VAR 0 7
133407: PPUSH
133408: CALL_OW 256
133412: PUSH
133413: LD_INT 500
133415: GREATER
133416: IFFALSE 133469
// begin e := NearestUnitToUnit ( enemy , i ) ;
133418: LD_ADDR_VAR 0 5
133422: PUSH
133423: LD_VAR 0 4
133427: PPUSH
133428: LD_VAR 0 7
133432: PPUSH
133433: CALL_OW 74
133437: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
133438: LD_VAR 0 7
133442: PPUSH
133443: LD_VAR 0 5
133447: PPUSH
133448: CALL_OW 250
133452: PPUSH
133453: LD_VAR 0 5
133457: PPUSH
133458: CALL_OW 251
133462: PPUSH
133463: CALL_OW 114
// end else
133467: GO 133700
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
133469: LD_VAR 0 7
133473: PPUSH
133474: LD_EXP 99
133478: PUSH
133479: LD_VAR 0 1
133483: ARRAY
133484: PPUSH
133485: LD_INT 2
133487: PUSH
133488: LD_INT 30
133490: PUSH
133491: LD_INT 0
133493: PUSH
133494: EMPTY
133495: LIST
133496: LIST
133497: PUSH
133498: LD_INT 30
133500: PUSH
133501: LD_INT 1
133503: PUSH
133504: EMPTY
133505: LIST
133506: LIST
133507: PUSH
133508: LD_INT 30
133510: PUSH
133511: LD_INT 6
133513: PUSH
133514: EMPTY
133515: LIST
133516: LIST
133517: PUSH
133518: EMPTY
133519: LIST
133520: LIST
133521: LIST
133522: LIST
133523: PPUSH
133524: CALL_OW 72
133528: PPUSH
133529: LD_VAR 0 7
133533: PPUSH
133534: CALL_OW 74
133538: PPUSH
133539: CALL_OW 296
133543: PUSH
133544: LD_INT 10
133546: GREATER
133547: IFFALSE 133700
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
133549: LD_ADDR_VAR 0 8
133553: PUSH
133554: LD_EXP 99
133558: PUSH
133559: LD_VAR 0 1
133563: ARRAY
133564: PPUSH
133565: LD_INT 2
133567: PUSH
133568: LD_INT 30
133570: PUSH
133571: LD_INT 0
133573: PUSH
133574: EMPTY
133575: LIST
133576: LIST
133577: PUSH
133578: LD_INT 30
133580: PUSH
133581: LD_INT 1
133583: PUSH
133584: EMPTY
133585: LIST
133586: LIST
133587: PUSH
133588: LD_INT 30
133590: PUSH
133591: LD_INT 6
133593: PUSH
133594: EMPTY
133595: LIST
133596: LIST
133597: PUSH
133598: EMPTY
133599: LIST
133600: LIST
133601: LIST
133602: LIST
133603: PPUSH
133604: CALL_OW 72
133608: PPUSH
133609: LD_VAR 0 7
133613: PPUSH
133614: CALL_OW 74
133618: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
133619: LD_VAR 0 7
133623: PPUSH
133624: LD_VAR 0 8
133628: PPUSH
133629: CALL_OW 250
133633: PPUSH
133634: LD_INT 3
133636: PPUSH
133637: LD_INT 5
133639: PPUSH
133640: CALL_OW 272
133644: PPUSH
133645: LD_VAR 0 8
133649: PPUSH
133650: CALL_OW 251
133654: PPUSH
133655: LD_INT 3
133657: PPUSH
133658: LD_INT 5
133660: PPUSH
133661: CALL_OW 273
133665: PPUSH
133666: CALL_OW 111
// SetTag ( i , 0 ) ;
133670: LD_VAR 0 7
133674: PPUSH
133675: LD_INT 0
133677: PPUSH
133678: CALL_OW 109
// solds := solds diff i ;
133682: LD_ADDR_VAR 0 2
133686: PUSH
133687: LD_VAR 0 2
133691: PUSH
133692: LD_VAR 0 7
133696: DIFF
133697: ST_TO_ADDR
// continue ;
133698: GO 133380
// end ; end ;
133700: GO 133380
133702: POP
133703: POP
// until not solds or not enemy ;
133704: LD_VAR 0 2
133708: NOT
133709: PUSH
133710: LD_VAR 0 4
133714: NOT
133715: OR
133716: IFFALSE 133284
// MC_Reset ( base , 18 ) ;
133718: LD_VAR 0 1
133722: PPUSH
133723: LD_INT 18
133725: PPUSH
133726: CALL 40731 0 2
// end ;
133730: LD_VAR 0 3
133734: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
133735: LD_INT 0
133737: PPUSH
133738: PPUSH
133739: PPUSH
133740: PPUSH
133741: PPUSH
133742: PPUSH
133743: PPUSH
133744: PPUSH
133745: PPUSH
133746: PPUSH
133747: PPUSH
133748: PPUSH
133749: PPUSH
133750: PPUSH
133751: PPUSH
133752: PPUSH
133753: PPUSH
133754: PPUSH
133755: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
133756: LD_ADDR_VAR 0 12
133760: PUSH
133761: LD_EXP 99
133765: PUSH
133766: LD_VAR 0 1
133770: ARRAY
133771: PPUSH
133772: LD_INT 25
133774: PUSH
133775: LD_INT 3
133777: PUSH
133778: EMPTY
133779: LIST
133780: LIST
133781: PPUSH
133782: CALL_OW 72
133786: ST_TO_ADDR
// if mc_remote_driver [ base ] then
133787: LD_EXP 139
133791: PUSH
133792: LD_VAR 0 1
133796: ARRAY
133797: IFFALSE 133821
// mechs := mechs diff mc_remote_driver [ base ] ;
133799: LD_ADDR_VAR 0 12
133803: PUSH
133804: LD_VAR 0 12
133808: PUSH
133809: LD_EXP 139
133813: PUSH
133814: LD_VAR 0 1
133818: ARRAY
133819: DIFF
133820: ST_TO_ADDR
// for i in mechs do
133821: LD_ADDR_VAR 0 4
133825: PUSH
133826: LD_VAR 0 12
133830: PUSH
133831: FOR_IN
133832: IFFALSE 133867
// if GetTag ( i ) > 0 then
133834: LD_VAR 0 4
133838: PPUSH
133839: CALL_OW 110
133843: PUSH
133844: LD_INT 0
133846: GREATER
133847: IFFALSE 133865
// mechs := mechs diff i ;
133849: LD_ADDR_VAR 0 12
133853: PUSH
133854: LD_VAR 0 12
133858: PUSH
133859: LD_VAR 0 4
133863: DIFF
133864: ST_TO_ADDR
133865: GO 133831
133867: POP
133868: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
133869: LD_ADDR_VAR 0 8
133873: PUSH
133874: LD_EXP 99
133878: PUSH
133879: LD_VAR 0 1
133883: ARRAY
133884: PPUSH
133885: LD_INT 2
133887: PUSH
133888: LD_INT 25
133890: PUSH
133891: LD_INT 1
133893: PUSH
133894: EMPTY
133895: LIST
133896: LIST
133897: PUSH
133898: LD_INT 25
133900: PUSH
133901: LD_INT 5
133903: PUSH
133904: EMPTY
133905: LIST
133906: LIST
133907: PUSH
133908: LD_INT 25
133910: PUSH
133911: LD_INT 8
133913: PUSH
133914: EMPTY
133915: LIST
133916: LIST
133917: PUSH
133918: LD_INT 25
133920: PUSH
133921: LD_INT 9
133923: PUSH
133924: EMPTY
133925: LIST
133926: LIST
133927: PUSH
133928: EMPTY
133929: LIST
133930: LIST
133931: LIST
133932: LIST
133933: LIST
133934: PPUSH
133935: CALL_OW 72
133939: ST_TO_ADDR
// if not defenders and not solds then
133940: LD_VAR 0 2
133944: NOT
133945: PUSH
133946: LD_VAR 0 8
133950: NOT
133951: AND
133952: IFFALSE 133956
// exit ;
133954: GO 135726
// depot_under_attack := false ;
133956: LD_ADDR_VAR 0 16
133960: PUSH
133961: LD_INT 0
133963: ST_TO_ADDR
// sold_defenders := [ ] ;
133964: LD_ADDR_VAR 0 17
133968: PUSH
133969: EMPTY
133970: ST_TO_ADDR
// if mechs then
133971: LD_VAR 0 12
133975: IFFALSE 134128
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
133977: LD_ADDR_VAR 0 4
133981: PUSH
133982: LD_VAR 0 2
133986: PPUSH
133987: LD_INT 21
133989: PUSH
133990: LD_INT 2
133992: PUSH
133993: EMPTY
133994: LIST
133995: LIST
133996: PPUSH
133997: CALL_OW 72
134001: PUSH
134002: FOR_IN
134003: IFFALSE 134126
// begin if GetTag ( i ) <> 20 then
134005: LD_VAR 0 4
134009: PPUSH
134010: CALL_OW 110
134014: PUSH
134015: LD_INT 20
134017: NONEQUAL
134018: IFFALSE 134032
// SetTag ( i , 20 ) ;
134020: LD_VAR 0 4
134024: PPUSH
134025: LD_INT 20
134027: PPUSH
134028: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
134032: LD_VAR 0 4
134036: PPUSH
134037: CALL_OW 263
134041: PUSH
134042: LD_INT 1
134044: EQUAL
134045: PUSH
134046: LD_VAR 0 4
134050: PPUSH
134051: CALL_OW 311
134055: NOT
134056: AND
134057: IFFALSE 134124
// begin un := mechs [ 1 ] ;
134059: LD_ADDR_VAR 0 10
134063: PUSH
134064: LD_VAR 0 12
134068: PUSH
134069: LD_INT 1
134071: ARRAY
134072: ST_TO_ADDR
// ComExit ( un ) ;
134073: LD_VAR 0 10
134077: PPUSH
134078: CALL 105081 0 1
// AddComEnterUnit ( un , i ) ;
134082: LD_VAR 0 10
134086: PPUSH
134087: LD_VAR 0 4
134091: PPUSH
134092: CALL_OW 180
// SetTag ( un , 19 ) ;
134096: LD_VAR 0 10
134100: PPUSH
134101: LD_INT 19
134103: PPUSH
134104: CALL_OW 109
// mechs := mechs diff un ;
134108: LD_ADDR_VAR 0 12
134112: PUSH
134113: LD_VAR 0 12
134117: PUSH
134118: LD_VAR 0 10
134122: DIFF
134123: ST_TO_ADDR
// end ; end ;
134124: GO 134002
134126: POP
134127: POP
// if solds then
134128: LD_VAR 0 8
134132: IFFALSE 134191
// for i in solds do
134134: LD_ADDR_VAR 0 4
134138: PUSH
134139: LD_VAR 0 8
134143: PUSH
134144: FOR_IN
134145: IFFALSE 134189
// if not GetTag ( i ) then
134147: LD_VAR 0 4
134151: PPUSH
134152: CALL_OW 110
134156: NOT
134157: IFFALSE 134187
// begin defenders := defenders union i ;
134159: LD_ADDR_VAR 0 2
134163: PUSH
134164: LD_VAR 0 2
134168: PUSH
134169: LD_VAR 0 4
134173: UNION
134174: ST_TO_ADDR
// SetTag ( i , 18 ) ;
134175: LD_VAR 0 4
134179: PPUSH
134180: LD_INT 18
134182: PPUSH
134183: CALL_OW 109
// end ;
134187: GO 134144
134189: POP
134190: POP
// repeat wait ( 0 0$2 ) ;
134191: LD_INT 70
134193: PPUSH
134194: CALL_OW 67
// enemy := mc_scan [ base ] ;
134198: LD_ADDR_VAR 0 21
134202: PUSH
134203: LD_EXP 122
134207: PUSH
134208: LD_VAR 0 1
134212: ARRAY
134213: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
134214: LD_EXP 99
134218: PUSH
134219: LD_VAR 0 1
134223: ARRAY
134224: NOT
134225: PUSH
134226: LD_EXP 99
134230: PUSH
134231: LD_VAR 0 1
134235: ARRAY
134236: PUSH
134237: EMPTY
134238: EQUAL
134239: OR
134240: IFFALSE 134277
// begin for i in defenders do
134242: LD_ADDR_VAR 0 4
134246: PUSH
134247: LD_VAR 0 2
134251: PUSH
134252: FOR_IN
134253: IFFALSE 134266
// ComStop ( i ) ;
134255: LD_VAR 0 4
134259: PPUSH
134260: CALL_OW 141
134264: GO 134252
134266: POP
134267: POP
// defenders := [ ] ;
134268: LD_ADDR_VAR 0 2
134272: PUSH
134273: EMPTY
134274: ST_TO_ADDR
// exit ;
134275: GO 135726
// end ; for i in defenders do
134277: LD_ADDR_VAR 0 4
134281: PUSH
134282: LD_VAR 0 2
134286: PUSH
134287: FOR_IN
134288: IFFALSE 135186
// begin e := NearestUnitToUnit ( enemy , i ) ;
134290: LD_ADDR_VAR 0 13
134294: PUSH
134295: LD_VAR 0 21
134299: PPUSH
134300: LD_VAR 0 4
134304: PPUSH
134305: CALL_OW 74
134309: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
134310: LD_ADDR_VAR 0 7
134314: PUSH
134315: LD_EXP 99
134319: PUSH
134320: LD_VAR 0 1
134324: ARRAY
134325: PPUSH
134326: LD_INT 2
134328: PUSH
134329: LD_INT 30
134331: PUSH
134332: LD_INT 0
134334: PUSH
134335: EMPTY
134336: LIST
134337: LIST
134338: PUSH
134339: LD_INT 30
134341: PUSH
134342: LD_INT 1
134344: PUSH
134345: EMPTY
134346: LIST
134347: LIST
134348: PUSH
134349: EMPTY
134350: LIST
134351: LIST
134352: LIST
134353: PPUSH
134354: CALL_OW 72
134358: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
134359: LD_ADDR_VAR 0 16
134363: PUSH
134364: LD_VAR 0 7
134368: NOT
134369: PUSH
134370: LD_VAR 0 7
134374: PPUSH
134375: LD_INT 3
134377: PUSH
134378: LD_INT 24
134380: PUSH
134381: LD_INT 600
134383: PUSH
134384: EMPTY
134385: LIST
134386: LIST
134387: PUSH
134388: EMPTY
134389: LIST
134390: LIST
134391: PPUSH
134392: CALL_OW 72
134396: OR
134397: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
134398: LD_VAR 0 4
134402: PPUSH
134403: CALL_OW 247
134407: PUSH
134408: LD_INT 2
134410: DOUBLE
134411: EQUAL
134412: IFTRUE 134416
134414: GO 134812
134416: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
134417: LD_VAR 0 4
134421: PPUSH
134422: CALL_OW 256
134426: PUSH
134427: LD_INT 1000
134429: EQUAL
134430: PUSH
134431: LD_VAR 0 4
134435: PPUSH
134436: LD_VAR 0 13
134440: PPUSH
134441: CALL_OW 296
134445: PUSH
134446: LD_INT 40
134448: LESS
134449: PUSH
134450: LD_VAR 0 13
134454: PPUSH
134455: LD_EXP 124
134459: PUSH
134460: LD_VAR 0 1
134464: ARRAY
134465: PPUSH
134466: CALL_OW 308
134470: OR
134471: AND
134472: IFFALSE 134594
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
134474: LD_VAR 0 4
134478: PPUSH
134479: CALL_OW 262
134483: PUSH
134484: LD_INT 1
134486: EQUAL
134487: PUSH
134488: LD_VAR 0 4
134492: PPUSH
134493: CALL_OW 261
134497: PUSH
134498: LD_INT 30
134500: LESS
134501: AND
134502: PUSH
134503: LD_VAR 0 7
134507: AND
134508: IFFALSE 134578
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
134510: LD_VAR 0 4
134514: PPUSH
134515: LD_VAR 0 7
134519: PPUSH
134520: LD_VAR 0 4
134524: PPUSH
134525: CALL_OW 74
134529: PPUSH
134530: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
134534: LD_VAR 0 4
134538: PPUSH
134539: LD_VAR 0 7
134543: PPUSH
134544: LD_VAR 0 4
134548: PPUSH
134549: CALL_OW 74
134553: PPUSH
134554: CALL_OW 296
134558: PUSH
134559: LD_INT 6
134561: LESS
134562: IFFALSE 134576
// SetFuel ( i , 100 ) ;
134564: LD_VAR 0 4
134568: PPUSH
134569: LD_INT 100
134571: PPUSH
134572: CALL_OW 240
// end else
134576: GO 134592
// ComAttackUnit ( i , e ) ;
134578: LD_VAR 0 4
134582: PPUSH
134583: LD_VAR 0 13
134587: PPUSH
134588: CALL_OW 115
// end else
134592: GO 134695
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
134594: LD_VAR 0 13
134598: PPUSH
134599: LD_EXP 124
134603: PUSH
134604: LD_VAR 0 1
134608: ARRAY
134609: PPUSH
134610: CALL_OW 308
134614: NOT
134615: PUSH
134616: LD_VAR 0 4
134620: PPUSH
134621: LD_VAR 0 13
134625: PPUSH
134626: CALL_OW 296
134630: PUSH
134631: LD_INT 40
134633: GREATEREQUAL
134634: AND
134635: PUSH
134636: LD_VAR 0 4
134640: PPUSH
134641: CALL_OW 256
134645: PUSH
134646: LD_INT 650
134648: LESSEQUAL
134649: OR
134650: PUSH
134651: LD_VAR 0 4
134655: PPUSH
134656: LD_EXP 123
134660: PUSH
134661: LD_VAR 0 1
134665: ARRAY
134666: PPUSH
134667: CALL_OW 308
134671: NOT
134672: AND
134673: IFFALSE 134695
// ComMoveToArea ( i , mc_parking [ base ] ) ;
134675: LD_VAR 0 4
134679: PPUSH
134680: LD_EXP 123
134684: PUSH
134685: LD_VAR 0 1
134689: ARRAY
134690: PPUSH
134691: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
134695: LD_VAR 0 4
134699: PPUSH
134700: CALL_OW 256
134704: PUSH
134705: LD_INT 1000
134707: LESS
134708: PUSH
134709: LD_VAR 0 4
134713: PPUSH
134714: CALL_OW 263
134718: PUSH
134719: LD_INT 1
134721: EQUAL
134722: AND
134723: PUSH
134724: LD_VAR 0 4
134728: PPUSH
134729: CALL_OW 311
134733: AND
134734: PUSH
134735: LD_VAR 0 4
134739: PPUSH
134740: LD_EXP 123
134744: PUSH
134745: LD_VAR 0 1
134749: ARRAY
134750: PPUSH
134751: CALL_OW 308
134755: AND
134756: IFFALSE 134810
// begin mech := IsDrivenBy ( i ) ;
134758: LD_ADDR_VAR 0 9
134762: PUSH
134763: LD_VAR 0 4
134767: PPUSH
134768: CALL_OW 311
134772: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
134773: LD_VAR 0 9
134777: PPUSH
134778: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
134782: LD_VAR 0 9
134786: PPUSH
134787: LD_VAR 0 4
134791: PPUSH
134792: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
134796: LD_VAR 0 9
134800: PPUSH
134801: LD_VAR 0 4
134805: PPUSH
134806: CALL_OW 180
// end ; end ; unit_human :
134810: GO 135157
134812: LD_INT 1
134814: DOUBLE
134815: EQUAL
134816: IFTRUE 134820
134818: GO 135156
134820: POP
// begin b := IsInUnit ( i ) ;
134821: LD_ADDR_VAR 0 18
134825: PUSH
134826: LD_VAR 0 4
134830: PPUSH
134831: CALL_OW 310
134835: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
134836: LD_ADDR_VAR 0 19
134840: PUSH
134841: LD_VAR 0 18
134845: NOT
134846: PUSH
134847: LD_VAR 0 18
134851: PPUSH
134852: CALL_OW 266
134856: PUSH
134857: LD_INT 32
134859: PUSH
134860: LD_INT 31
134862: PUSH
134863: EMPTY
134864: LIST
134865: LIST
134866: IN
134867: OR
134868: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
134869: LD_VAR 0 18
134873: PPUSH
134874: CALL_OW 266
134878: PUSH
134879: LD_INT 5
134881: EQUAL
134882: PUSH
134883: LD_VAR 0 4
134887: PPUSH
134888: CALL_OW 257
134892: PUSH
134893: LD_INT 1
134895: PUSH
134896: LD_INT 2
134898: PUSH
134899: LD_INT 3
134901: PUSH
134902: LD_INT 4
134904: PUSH
134905: EMPTY
134906: LIST
134907: LIST
134908: LIST
134909: LIST
134910: IN
134911: AND
134912: IFFALSE 134949
// begin class := AllowSpecClass ( i ) ;
134914: LD_ADDR_VAR 0 20
134918: PUSH
134919: LD_VAR 0 4
134923: PPUSH
134924: CALL 69020 0 1
134928: ST_TO_ADDR
// if class then
134929: LD_VAR 0 20
134933: IFFALSE 134949
// ComChangeProfession ( i , class ) ;
134935: LD_VAR 0 4
134939: PPUSH
134940: LD_VAR 0 20
134944: PPUSH
134945: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
134949: LD_VAR 0 16
134953: PUSH
134954: LD_VAR 0 2
134958: PPUSH
134959: LD_INT 21
134961: PUSH
134962: LD_INT 2
134964: PUSH
134965: EMPTY
134966: LIST
134967: LIST
134968: PPUSH
134969: CALL_OW 72
134973: PUSH
134974: LD_INT 1
134976: LESSEQUAL
134977: OR
134978: PUSH
134979: LD_VAR 0 19
134983: AND
134984: PUSH
134985: LD_VAR 0 4
134989: PUSH
134990: LD_VAR 0 17
134994: IN
134995: NOT
134996: AND
134997: IFFALSE 135090
// begin if b then
134999: LD_VAR 0 18
135003: IFFALSE 135052
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
135005: LD_VAR 0 18
135009: PPUSH
135010: LD_VAR 0 21
135014: PPUSH
135015: LD_VAR 0 18
135019: PPUSH
135020: CALL_OW 74
135024: PPUSH
135025: CALL_OW 296
135029: PUSH
135030: LD_INT 10
135032: LESS
135033: PUSH
135034: LD_VAR 0 18
135038: PPUSH
135039: CALL_OW 461
135043: PUSH
135044: LD_INT 7
135046: NONEQUAL
135047: AND
135048: IFFALSE 135052
// continue ;
135050: GO 134287
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
135052: LD_ADDR_VAR 0 17
135056: PUSH
135057: LD_VAR 0 17
135061: PPUSH
135062: LD_VAR 0 17
135066: PUSH
135067: LD_INT 1
135069: PLUS
135070: PPUSH
135071: LD_VAR 0 4
135075: PPUSH
135076: CALL_OW 1
135080: ST_TO_ADDR
// ComExitBuilding ( i ) ;
135081: LD_VAR 0 4
135085: PPUSH
135086: CALL_OW 122
// end ; if sold_defenders then
135090: LD_VAR 0 17
135094: IFFALSE 135154
// if i in sold_defenders then
135096: LD_VAR 0 4
135100: PUSH
135101: LD_VAR 0 17
135105: IN
135106: IFFALSE 135154
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
135108: LD_VAR 0 4
135112: PPUSH
135113: CALL_OW 314
135117: NOT
135118: PUSH
135119: LD_VAR 0 4
135123: PPUSH
135124: LD_VAR 0 13
135128: PPUSH
135129: CALL_OW 296
135133: PUSH
135134: LD_INT 30
135136: LESS
135137: AND
135138: IFFALSE 135154
// ComAttackUnit ( i , e ) ;
135140: LD_VAR 0 4
135144: PPUSH
135145: LD_VAR 0 13
135149: PPUSH
135150: CALL_OW 115
// end ; end ; end ;
135154: GO 135157
135156: POP
// if IsDead ( i ) then
135157: LD_VAR 0 4
135161: PPUSH
135162: CALL_OW 301
135166: IFFALSE 135184
// defenders := defenders diff i ;
135168: LD_ADDR_VAR 0 2
135172: PUSH
135173: LD_VAR 0 2
135177: PUSH
135178: LD_VAR 0 4
135182: DIFF
135183: ST_TO_ADDR
// end ;
135184: GO 134287
135186: POP
135187: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
135188: LD_VAR 0 21
135192: NOT
135193: PUSH
135194: LD_VAR 0 2
135198: NOT
135199: OR
135200: PUSH
135201: LD_EXP 99
135205: PUSH
135206: LD_VAR 0 1
135210: ARRAY
135211: NOT
135212: OR
135213: IFFALSE 134191
// MC_Reset ( base , 18 ) ;
135215: LD_VAR 0 1
135219: PPUSH
135220: LD_INT 18
135222: PPUSH
135223: CALL 40731 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
135227: LD_ADDR_VAR 0 2
135231: PUSH
135232: LD_VAR 0 2
135236: PUSH
135237: LD_VAR 0 2
135241: PPUSH
135242: LD_INT 2
135244: PUSH
135245: LD_INT 25
135247: PUSH
135248: LD_INT 1
135250: PUSH
135251: EMPTY
135252: LIST
135253: LIST
135254: PUSH
135255: LD_INT 25
135257: PUSH
135258: LD_INT 5
135260: PUSH
135261: EMPTY
135262: LIST
135263: LIST
135264: PUSH
135265: LD_INT 25
135267: PUSH
135268: LD_INT 8
135270: PUSH
135271: EMPTY
135272: LIST
135273: LIST
135274: PUSH
135275: LD_INT 25
135277: PUSH
135278: LD_INT 9
135280: PUSH
135281: EMPTY
135282: LIST
135283: LIST
135284: PUSH
135285: EMPTY
135286: LIST
135287: LIST
135288: LIST
135289: LIST
135290: LIST
135291: PPUSH
135292: CALL_OW 72
135296: DIFF
135297: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
135298: LD_VAR 0 21
135302: NOT
135303: PUSH
135304: LD_VAR 0 2
135308: PPUSH
135309: LD_INT 21
135311: PUSH
135312: LD_INT 2
135314: PUSH
135315: EMPTY
135316: LIST
135317: LIST
135318: PPUSH
135319: CALL_OW 72
135323: AND
135324: IFFALSE 135662
// begin tmp := FilterByTag ( defenders , 19 ) ;
135326: LD_ADDR_VAR 0 11
135330: PUSH
135331: LD_VAR 0 2
135335: PPUSH
135336: LD_INT 19
135338: PPUSH
135339: CALL 102257 0 2
135343: ST_TO_ADDR
// if tmp then
135344: LD_VAR 0 11
135348: IFFALSE 135418
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
135350: LD_ADDR_VAR 0 11
135354: PUSH
135355: LD_VAR 0 11
135359: PPUSH
135360: LD_INT 25
135362: PUSH
135363: LD_INT 3
135365: PUSH
135366: EMPTY
135367: LIST
135368: LIST
135369: PPUSH
135370: CALL_OW 72
135374: ST_TO_ADDR
// if tmp then
135375: LD_VAR 0 11
135379: IFFALSE 135418
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
135381: LD_ADDR_EXP 111
135385: PUSH
135386: LD_EXP 111
135390: PPUSH
135391: LD_VAR 0 1
135395: PPUSH
135396: LD_EXP 111
135400: PUSH
135401: LD_VAR 0 1
135405: ARRAY
135406: PUSH
135407: LD_VAR 0 11
135411: UNION
135412: PPUSH
135413: CALL_OW 1
135417: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
135418: LD_VAR 0 1
135422: PPUSH
135423: LD_INT 19
135425: PPUSH
135426: CALL 40731 0 2
// repeat wait ( 0 0$1 ) ;
135430: LD_INT 35
135432: PPUSH
135433: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
135437: LD_EXP 99
135441: PUSH
135442: LD_VAR 0 1
135446: ARRAY
135447: NOT
135448: PUSH
135449: LD_EXP 99
135453: PUSH
135454: LD_VAR 0 1
135458: ARRAY
135459: PUSH
135460: EMPTY
135461: EQUAL
135462: OR
135463: IFFALSE 135500
// begin for i in defenders do
135465: LD_ADDR_VAR 0 4
135469: PUSH
135470: LD_VAR 0 2
135474: PUSH
135475: FOR_IN
135476: IFFALSE 135489
// ComStop ( i ) ;
135478: LD_VAR 0 4
135482: PPUSH
135483: CALL_OW 141
135487: GO 135475
135489: POP
135490: POP
// defenders := [ ] ;
135491: LD_ADDR_VAR 0 2
135495: PUSH
135496: EMPTY
135497: ST_TO_ADDR
// exit ;
135498: GO 135726
// end ; for i in defenders do
135500: LD_ADDR_VAR 0 4
135504: PUSH
135505: LD_VAR 0 2
135509: PUSH
135510: FOR_IN
135511: IFFALSE 135600
// begin if not IsInArea ( i , mc_parking [ base ] ) then
135513: LD_VAR 0 4
135517: PPUSH
135518: LD_EXP 123
135522: PUSH
135523: LD_VAR 0 1
135527: ARRAY
135528: PPUSH
135529: CALL_OW 308
135533: NOT
135534: IFFALSE 135558
// ComMoveToArea ( i , mc_parking [ base ] ) else
135536: LD_VAR 0 4
135540: PPUSH
135541: LD_EXP 123
135545: PUSH
135546: LD_VAR 0 1
135550: ARRAY
135551: PPUSH
135552: CALL_OW 113
135556: GO 135598
// if GetControl ( i ) = control_manual then
135558: LD_VAR 0 4
135562: PPUSH
135563: CALL_OW 263
135567: PUSH
135568: LD_INT 1
135570: EQUAL
135571: IFFALSE 135598
// if IsDrivenBy ( i ) then
135573: LD_VAR 0 4
135577: PPUSH
135578: CALL_OW 311
135582: IFFALSE 135598
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
135584: LD_VAR 0 4
135588: PPUSH
135589: CALL_OW 311
135593: PPUSH
135594: CALL_OW 121
// end ;
135598: GO 135510
135600: POP
135601: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
135602: LD_VAR 0 2
135606: PPUSH
135607: LD_INT 95
135609: PUSH
135610: LD_EXP 123
135614: PUSH
135615: LD_VAR 0 1
135619: ARRAY
135620: PUSH
135621: EMPTY
135622: LIST
135623: LIST
135624: PPUSH
135625: CALL_OW 72
135629: PUSH
135630: LD_VAR 0 2
135634: EQUAL
135635: PUSH
135636: LD_EXP 122
135640: PUSH
135641: LD_VAR 0 1
135645: ARRAY
135646: OR
135647: PUSH
135648: LD_EXP 99
135652: PUSH
135653: LD_VAR 0 1
135657: ARRAY
135658: NOT
135659: OR
135660: IFFALSE 135430
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
135662: LD_ADDR_EXP 121
135666: PUSH
135667: LD_EXP 121
135671: PPUSH
135672: LD_VAR 0 1
135676: PPUSH
135677: LD_VAR 0 2
135681: PPUSH
135682: LD_INT 21
135684: PUSH
135685: LD_INT 2
135687: PUSH
135688: EMPTY
135689: LIST
135690: LIST
135691: PPUSH
135692: CALL_OW 72
135696: PPUSH
135697: CALL_OW 1
135701: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
135702: LD_VAR 0 1
135706: PPUSH
135707: LD_INT 19
135709: PPUSH
135710: CALL 40731 0 2
// MC_Reset ( base , 20 ) ;
135714: LD_VAR 0 1
135718: PPUSH
135719: LD_INT 20
135721: PPUSH
135722: CALL 40731 0 2
// end ; end_of_file
135726: LD_VAR 0 3
135730: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
135731: LD_VAR 0 1
135735: PUSH
135736: LD_INT 200
135738: DOUBLE
135739: GREATEREQUAL
135740: IFFALSE 135748
135742: LD_INT 299
135744: DOUBLE
135745: LESSEQUAL
135746: IFTRUE 135750
135748: GO 135782
135750: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
135751: LD_VAR 0 1
135755: PPUSH
135756: LD_VAR 0 2
135760: PPUSH
135761: LD_VAR 0 3
135765: PPUSH
135766: LD_VAR 0 4
135770: PPUSH
135771: LD_VAR 0 5
135775: PPUSH
135776: CALL 124517 0 5
135780: GO 135859
135782: LD_INT 300
135784: DOUBLE
135785: GREATEREQUAL
135786: IFFALSE 135794
135788: LD_INT 399
135790: DOUBLE
135791: LESSEQUAL
135792: IFTRUE 135796
135794: GO 135858
135796: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
135797: LD_VAR 0 1
135801: PPUSH
135802: LD_VAR 0 2
135806: PPUSH
135807: LD_VAR 0 3
135811: PPUSH
135812: LD_VAR 0 4
135816: PPUSH
135817: LD_VAR 0 5
135821: PPUSH
135822: LD_VAR 0 6
135826: PPUSH
135827: LD_VAR 0 7
135831: PPUSH
135832: LD_VAR 0 8
135836: PPUSH
135837: LD_VAR 0 9
135841: PPUSH
135842: LD_VAR 0 10
135846: PPUSH
135847: LD_VAR 0 11
135851: PPUSH
135852: CALL 120850 0 11
135856: GO 135859
135858: POP
// end ;
135859: PPOPN 11
135861: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
135862: LD_VAR 0 1
135866: PPUSH
135867: LD_VAR 0 2
135871: PPUSH
135872: LD_VAR 0 3
135876: PPUSH
135877: LD_VAR 0 4
135881: PPUSH
135882: LD_VAR 0 5
135886: PPUSH
135887: CALL 124253 0 5
// end ; end_of_file
135891: PPOPN 5
135893: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
135894: LD_VAR 0 1
135898: PPUSH
135899: LD_VAR 0 2
135903: PPUSH
135904: LD_VAR 0 3
135908: PPUSH
135909: LD_VAR 0 4
135913: PPUSH
135914: LD_VAR 0 5
135918: PPUSH
135919: LD_VAR 0 6
135923: PPUSH
135924: CALL 108543 0 6
// end ;
135928: PPOPN 6
135930: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
135931: LD_INT 0
135933: PPUSH
// begin if not units then
135934: LD_VAR 0 1
135938: NOT
135939: IFFALSE 135943
// exit ;
135941: GO 135943
// end ;
135943: PPOPN 7
135945: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
135946: CALL 108514 0 0
// end ;
135950: PPOPN 1
135952: END
