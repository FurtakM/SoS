// starting begin ResetFog ;
   0: CALL_OW 335
// InitVariables ;
   4: CALL 58 0 0
// InitMacro ;
   8: CALL 33682 0 0
// InitNature ;
  12: CALL 33506 0 0
// if debug then
  16: LD_EXP 1
  20: IFFALSE 29
// FogOff ( 1 ) ;
  22: LD_INT 1
  24: PPUSH
  25: CALL_OW 344
// PrepareAlliance ;
  29: CALL 10785 0 0
// PrepareRussian ;
  33: CALL 6778 0 0
// PrepareLegion ;
  37: CALL 4018 0 0
// PreparePowell ;
  41: CALL 2772 0 0
// PrepareAmerican ;
  45: CALL 1595 0 0
// Action ;
  49: CALL 14692 0 0
// MC_Start ( ) ;
  53: CALL 34829 0 0
// end ;
  57: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans ; export function InitVariables ; begin
  58: LD_INT 0
  60: PPUSH
// debug := false ;
  61: LD_ADDR_EXP 1
  65: PUSH
  66: LD_INT 0
  68: ST_TO_ADDR
// missionStart := false ;
  69: LD_ADDR_EXP 13
  73: PUSH
  74: LD_INT 0
  76: ST_TO_ADDR
// missionTime := 0 0$00 ;
  77: LD_ADDR_EXP 14
  81: PUSH
  82: LD_INT 0
  84: ST_TO_ADDR
// missionStage := 1 ;
  85: LD_ADDR_EXP 15
  89: PUSH
  90: LD_INT 1
  92: ST_TO_ADDR
// activeAttacks := false ;
  93: LD_ADDR_EXP 16
  97: PUSH
  98: LD_INT 0
 100: ST_TO_ADDR
// powellAnger := 0 ;
 101: LD_ADDR_EXP 17
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// powellAllowRetreat := true ;
 109: LD_ADDR_EXP 19
 113: PUSH
 114: LD_INT 1
 116: ST_TO_ADDR
// powellCenterCameraMode := false ;
 117: LD_ADDR_EXP 20
 121: PUSH
 122: LD_INT 0
 124: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 125: LD_ADDR_EXP 18
 129: PUSH
 130: EMPTY
 131: PUSH
 132: EMPTY
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: ST_TO_ADDR
// russianDestroyed := false ;
 138: LD_ADDR_EXP 21
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// legionDestroyed := false ;
 146: LD_ADDR_EXP 22
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// allianceDestroyed := false ;
 154: LD_ADDR_EXP 23
 158: PUSH
 159: LD_INT 0
 161: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 162: LD_ADDR_EXP 2
 166: PUSH
 167: LD_STRING 14_KappaStatus_1
 169: PPUSH
 170: LD_INT 0
 172: PPUSH
 173: CALL_OW 30
 177: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 178: LD_ADDR_EXP 3
 182: PUSH
 183: LD_STRING 06_KurtStatus_1
 185: PPUSH
 186: LD_INT 0
 188: PPUSH
 189: CALL_OW 30
 193: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 194: LD_ADDR_EXP 4
 198: PUSH
 199: LD_STRING 14_JMMVeh_1
 201: PPUSH
 202: LD_INT 0
 204: PPUSH
 205: CALL_OW 30
 209: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 210: LD_ADDR_EXP 5
 214: PUSH
 215: LD_STRING 14_JMMGirlVeh_1
 217: PPUSH
 218: LD_INT 0
 220: PPUSH
 221: CALL_OW 30
 225: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 226: LD_ADDR_EXP 7
 230: PUSH
 231: LD_STRING 14_JMMGirl_1
 233: PPUSH
 234: LD_INT 0
 236: PPUSH
 237: CALL_OW 30
 241: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 242: LD_ADDR_EXP 6
 246: PUSH
 247: LD_STRING 14_JMMGirlStatus_1
 249: PPUSH
 250: LD_INT 0
 252: PPUSH
 253: CALL_OW 30
 257: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 258: LD_ADDR_EXP 8
 262: PUSH
 263: LD_STRING 10_KhatamStatus_1
 265: PPUSH
 266: LD_INT 0
 268: PPUSH
 269: CALL_OW 30
 273: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 274: LD_ADDR_EXP 9
 278: PUSH
 279: LD_STRING 13_BurlakStatus_1
 281: PPUSH
 282: LD_INT 0
 284: PPUSH
 285: CALL_OW 30
 289: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 290: LD_ADDR_EXP 10
 294: PUSH
 295: LD_STRING 13_StevensStatus_1
 297: PPUSH
 298: LD_INT 0
 300: PPUSH
 301: CALL_OW 30
 305: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 306: LD_ADDR_EXP 11
 310: PUSH
 311: LD_STRING 14_FastEnd_1
 313: PPUSH
 314: LD_INT 0
 316: PPUSH
 317: CALL_OW 30
 321: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 322: LD_ADDR_EXP 12
 326: PUSH
 327: LD_STRING 12_MainDepositFake_1
 329: PPUSH
 330: LD_INT 0
 332: PPUSH
 333: CALL_OW 30
 337: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 338: LD_ADDR_EXP 24
 342: PUSH
 343: LD_INT 1
 345: ST_TO_ADDR
// behemothUnderConstruct := false ;
 346: LD_ADDR_EXP 26
 350: PUSH
 351: LD_INT 0
 353: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 354: LD_ADDR_EXP 27
 358: PUSH
 359: LD_INT 0
 361: ST_TO_ADDR
// behemothDone := false ;
 362: LD_ADDR_EXP 28
 366: PUSH
 367: LD_INT 0
 369: ST_TO_ADDR
// allowBehemothConstruct := false ;
 370: LD_ADDR_EXP 25
 374: PUSH
 375: LD_INT 0
 377: ST_TO_ADDR
// seeBehemoth := false ;
 378: LD_ADDR_EXP 29
 382: PUSH
 383: LD_INT 0
 385: ST_TO_ADDR
// platonovHasBomb := false ;
 386: LD_ADDR_EXP 30
 390: PUSH
 391: LD_INT 0
 393: ST_TO_ADDR
// allianceActive := false ;
 394: LD_ADDR_EXP 31
 398: PUSH
 399: LD_INT 0
 401: ST_TO_ADDR
// rothCaptured := false ;
 402: LD_ADDR_EXP 33
 406: PUSH
 407: LD_INT 0
 409: ST_TO_ADDR
// lostCounter := 0 ;
 410: LD_ADDR_EXP 32
 414: PUSH
 415: LD_INT 0
 417: ST_TO_ADDR
// capturedUnit := [ ] ;
 418: LD_ADDR_EXP 34
 422: PUSH
 423: EMPTY
 424: ST_TO_ADDR
// trueAmericans := [ ] ;
 425: LD_ADDR_EXP 35
 429: PUSH
 430: EMPTY
 431: ST_TO_ADDR
// end ;
 432: LD_VAR 0 1
 436: RET
// export function CustomInitMacro ( ) ; begin
 437: LD_INT 0
 439: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 440: LD_ADDR_EXP 123
 444: PUSH
 445: LD_INT 2
 447: PUSH
 448: LD_INT 3
 450: PUSH
 451: LD_INT 6
 453: PUSH
 454: LD_INT 10
 456: PUSH
 457: EMPTY
 458: LIST
 459: LIST
 460: LIST
 461: LIST
 462: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 463: LD_ADDR_EXP 124
 467: PUSH
 468: LD_INT 1
 470: PUSH
 471: LD_INT 4
 473: PUSH
 474: LD_INT 5
 476: PUSH
 477: LD_INT 9
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 486: LD_INT 1
 488: PPUSH
 489: LD_INT 10
 491: PUSH
 492: LD_INT 11
 494: PUSH
 495: LD_INT 12
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: PPUSH
 503: CALL 56627 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 507: LD_INT 1
 509: PPUSH
 510: LD_INT 17
 512: PUSH
 513: EMPTY
 514: LIST
 515: PPUSH
 516: CALL 56720 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 520: LD_INT 1
 522: PPUSH
 523: LD_INT 5
 525: PPUSH
 526: CALL 56133 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 530: LD_INT 1
 532: PPUSH
 533: LD_INT 24
 535: PUSH
 536: LD_INT 3
 538: PUSH
 539: LD_INT 3
 541: PUSH
 542: LD_INT 47
 544: PUSH
 545: EMPTY
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PUSH
 551: LD_INT 24
 553: PUSH
 554: LD_INT 3
 556: PUSH
 557: LD_INT 3
 559: PUSH
 560: LD_INT 47
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: LIST
 568: PUSH
 569: LD_INT 24
 571: PUSH
 572: LD_INT 3
 574: PUSH
 575: LD_INT 3
 577: PUSH
 578: LD_INT 47
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: LIST
 586: PUSH
 587: LD_INT 24
 589: PUSH
 590: LD_INT 3
 592: PUSH
 593: LD_INT 1
 595: PUSH
 596: LD_INT 47
 598: PUSH
 599: EMPTY
 600: LIST
 601: LIST
 602: LIST
 603: LIST
 604: PUSH
 605: LD_INT 24
 607: PUSH
 608: LD_INT 3
 610: PUSH
 611: LD_INT 1
 613: PUSH
 614: LD_INT 47
 616: PUSH
 617: EMPTY
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: LIST
 629: PPUSH
 630: CALL 55948 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 634: LD_INT 2
 636: PPUSH
 637: LD_INT 10
 639: PUSH
 640: LD_INT 11
 642: PUSH
 643: LD_INT 12
 645: PUSH
 646: LD_INT 14
 648: PUSH
 649: EMPTY
 650: LIST
 651: LIST
 652: LIST
 653: LIST
 654: PPUSH
 655: CALL 56627 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 659: LD_INT 2
 661: PPUSH
 662: LD_INT 16
 664: PUSH
 665: EMPTY
 666: LIST
 667: PPUSH
 668: CALL 56720 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 672: LD_INT 2
 674: PPUSH
 675: LD_INT 21
 677: PUSH
 678: LD_INT 3
 680: PUSH
 681: LD_INT 3
 683: PUSH
 684: LD_INT 51
 686: PUSH
 687: EMPTY
 688: LIST
 689: LIST
 690: LIST
 691: LIST
 692: PUSH
 693: LD_INT 24
 695: PUSH
 696: LD_INT 3
 698: PUSH
 699: LD_INT 3
 701: PUSH
 702: LD_INT 47
 704: PUSH
 705: EMPTY
 706: LIST
 707: LIST
 708: LIST
 709: LIST
 710: PUSH
 711: LD_INT 24
 713: PUSH
 714: LD_INT 3
 716: PUSH
 717: LD_INT 3
 719: PUSH
 720: LD_INT 47
 722: PUSH
 723: EMPTY
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: PUSH
 729: LD_INT 24
 731: PUSH
 732: LD_INT 3
 734: PUSH
 735: LD_INT 3
 737: PUSH
 738: LD_INT 47
 740: PUSH
 741: EMPTY
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: PUSH
 747: LD_INT 24
 749: PUSH
 750: LD_INT 3
 752: PUSH
 753: LD_INT 3
 755: PUSH
 756: LD_INT 47
 758: PUSH
 759: EMPTY
 760: LIST
 761: LIST
 762: LIST
 763: LIST
 764: PUSH
 765: LD_INT 24
 767: PUSH
 768: LD_INT 3
 770: PUSH
 771: LD_INT 3
 773: PUSH
 774: LD_INT 47
 776: PUSH
 777: EMPTY
 778: LIST
 779: LIST
 780: LIST
 781: LIST
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: LIST
 789: LIST
 790: PPUSH
 791: CALL 55948 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 795: LD_INT 2
 797: PPUSH
 798: LD_INT 5
 800: PPUSH
 801: CALL 56133 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 805: LD_INT 2
 807: PPUSH
 808: LD_INT 0
 810: PPUSH
 811: CALL 56500 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 815: LD_INT 3
 817: PPUSH
 818: LD_INT 10
 820: PUSH
 821: LD_INT 12
 823: PUSH
 824: LD_INT 15
 826: PUSH
 827: EMPTY
 828: LIST
 829: LIST
 830: LIST
 831: PUSH
 832: LD_OWVAR 67
 836: ARRAY
 837: PPUSH
 838: LD_INT 27
 840: PPUSH
 841: CALL 55630 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 845: LD_INT 3
 847: PPUSH
 848: LD_INT 10
 850: PUSH
 851: LD_INT 11
 853: PUSH
 854: LD_INT 13
 856: PUSH
 857: LD_INT 15
 859: PUSH
 860: EMPTY
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: PPUSH
 866: CALL 56627 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 870: LD_INT 3
 872: PPUSH
 873: LD_INT 15
 875: PUSH
 876: EMPTY
 877: LIST
 878: PPUSH
 879: CALL 56720 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 883: LD_ADDR_EXP 128
 887: PUSH
 888: LD_EXP 128
 892: PPUSH
 893: LD_INT 3
 895: PPUSH
 896: LD_INT 22
 898: PUSH
 899: LD_INT 8
 901: PUSH
 902: EMPTY
 903: LIST
 904: LIST
 905: PUSH
 906: LD_INT 25
 908: PUSH
 909: LD_INT 15
 911: PUSH
 912: EMPTY
 913: LIST
 914: LIST
 915: PUSH
 916: EMPTY
 917: LIST
 918: LIST
 919: PPUSH
 920: CALL_OW 69
 924: PPUSH
 925: CALL_OW 1
 929: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 930: LD_INT 3
 932: PPUSH
 933: LD_INT 13
 935: PUSH
 936: LD_INT 2
 938: PUSH
 939: LD_INT 1
 941: PUSH
 942: LD_INT 31
 944: PUSH
 945: EMPTY
 946: LIST
 947: LIST
 948: LIST
 949: LIST
 950: PUSH
 951: LD_INT 13
 953: PUSH
 954: LD_INT 2
 956: PUSH
 957: LD_INT 1
 959: PUSH
 960: LD_INT 31
 962: PUSH
 963: EMPTY
 964: LIST
 965: LIST
 966: LIST
 967: LIST
 968: PUSH
 969: LD_INT 13
 971: PUSH
 972: LD_INT 3
 974: PUSH
 975: LD_INT 2
 977: PUSH
 978: LD_INT 32
 980: PUSH
 981: EMPTY
 982: LIST
 983: LIST
 984: LIST
 985: LIST
 986: PUSH
 987: EMPTY
 988: LIST
 989: LIST
 990: LIST
 991: PPUSH
 992: CALL 55948 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
 996: LD_INT 4
 998: PPUSH
 999: LD_INT 10
1001: PUSH
1002: LD_INT 12
1004: PUSH
1005: EMPTY
1006: LIST
1007: LIST
1008: PPUSH
1009: CALL 56627 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1013: LD_INT 4
1015: PPUSH
1016: LD_INT 9
1018: PUSH
1019: EMPTY
1020: LIST
1021: PPUSH
1022: CALL 56720 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1026: LD_INT 4
1028: PPUSH
1029: LD_INT 26
1031: PUSH
1032: LD_INT 74
1034: PUSH
1035: LD_INT 107
1037: PUSH
1038: LD_INT 0
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: LIST
1045: LIST
1046: PUSH
1047: LD_INT 32
1049: PUSH
1050: LD_INT 77
1052: PUSH
1053: LD_INT 101
1055: PUSH
1056: LD_INT 4
1058: PUSH
1059: EMPTY
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: PUSH
1065: LD_INT 32
1067: PUSH
1068: LD_INT 69
1070: PUSH
1071: LD_INT 86
1073: PUSH
1074: LD_INT 4
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: PUSH
1083: LD_INT 27
1085: PUSH
1086: LD_INT 77
1088: PUSH
1089: LD_INT 110
1091: PUSH
1092: LD_INT 3
1094: PUSH
1095: EMPTY
1096: LIST
1097: LIST
1098: LIST
1099: LIST
1100: PUSH
1101: LD_INT 27
1103: PUSH
1104: LD_INT 42
1106: PUSH
1107: LD_INT 79
1109: PUSH
1110: LD_INT 5
1112: PUSH
1113: EMPTY
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: PUSH
1119: LD_INT 29
1121: PUSH
1122: LD_INT 86
1124: PUSH
1125: LD_INT 105
1127: PUSH
1128: LD_INT 2
1130: PUSH
1131: EMPTY
1132: LIST
1133: LIST
1134: LIST
1135: LIST
1136: PUSH
1137: LD_INT 30
1139: PUSH
1140: LD_INT 40
1142: PUSH
1143: LD_INT 75
1145: PUSH
1146: LD_INT 1
1148: PUSH
1149: EMPTY
1150: LIST
1151: LIST
1152: LIST
1153: LIST
1154: PUSH
1155: LD_INT 32
1157: PUSH
1158: LD_INT 80
1160: PUSH
1161: LD_INT 106
1163: PUSH
1164: LD_INT 4
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: PUSH
1173: LD_INT 32
1175: PUSH
1176: LD_INT 75
1178: PUSH
1179: LD_INT 114
1181: PUSH
1182: LD_INT 5
1184: PUSH
1185: EMPTY
1186: LIST
1187: LIST
1188: LIST
1189: LIST
1190: PUSH
1191: LD_INT 32
1193: PUSH
1194: LD_INT 82
1196: PUSH
1197: LD_INT 110
1199: PUSH
1200: LD_INT 5
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: LIST
1207: LIST
1208: PUSH
1209: LD_INT 32
1211: PUSH
1212: LD_INT 62
1214: PUSH
1215: LD_INT 78
1217: PUSH
1218: LD_INT 4
1220: PUSH
1221: EMPTY
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PUSH
1227: LD_INT 4
1229: PUSH
1230: LD_INT 39
1232: PUSH
1233: LD_INT 61
1235: PUSH
1236: LD_INT 3
1238: PUSH
1239: EMPTY
1240: LIST
1241: LIST
1242: LIST
1243: LIST
1244: PUSH
1245: EMPTY
1246: LIST
1247: LIST
1248: LIST
1249: LIST
1250: LIST
1251: LIST
1252: LIST
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: PPUSH
1259: CALL 55840 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1263: LD_INT 4
1265: PPUSH
1266: LD_INT 5
1268: PUSH
1269: LD_INT 6
1271: PUSH
1272: LD_INT 7
1274: PUSH
1275: LD_INT 9
1277: PUSH
1278: EMPTY
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: PPUSH
1284: CALL 57038 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1288: LD_INT 4
1290: PPUSH
1291: LD_INT 40
1293: PUSH
1294: LD_INT 75
1296: PUSH
1297: LD_INT 1
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: LIST
1304: PUSH
1305: LD_INT 86
1307: PUSH
1308: LD_INT 105
1310: PUSH
1311: LD_INT 0
1313: PUSH
1314: EMPTY
1315: LIST
1316: LIST
1317: LIST
1318: PUSH
1319: EMPTY
1320: LIST
1321: LIST
1322: PPUSH
1323: CALL 56272 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1327: LD_INT 4
1329: PPUSH
1330: LD_INT 2
1332: PPUSH
1333: CALL 56500 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1337: LD_INT 4
1339: PPUSH
1340: LD_INT 0
1342: PPUSH
1343: CALL 56500 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1347: LD_INT 4
1349: PPUSH
1350: LD_INT 54
1352: PPUSH
1353: LD_INT 85
1355: PPUSH
1356: LD_INT 2
1358: PPUSH
1359: LD_INT 19
1361: PUSH
1362: LD_INT 16
1364: PUSH
1365: LD_INT 17
1367: PUSH
1368: LD_INT 18
1370: PUSH
1371: EMPTY
1372: LIST
1373: LIST
1374: LIST
1375: LIST
1376: PPUSH
1377: CALL 56832 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1381: LD_INT 4
1383: PPUSH
1384: LD_INT 3
1386: PUSH
1387: LD_INT 1
1389: PUSH
1390: LD_INT 1
1392: PUSH
1393: LD_INT 5
1395: PUSH
1396: EMPTY
1397: LIST
1398: LIST
1399: LIST
1400: LIST
1401: PUSH
1402: LD_INT 4
1404: PUSH
1405: LD_INT 1
1407: PUSH
1408: LD_INT 1
1410: PUSH
1411: LD_INT 6
1413: PUSH
1414: EMPTY
1415: LIST
1416: LIST
1417: LIST
1418: LIST
1419: PUSH
1420: LD_INT 4
1422: PUSH
1423: LD_INT 1
1425: PUSH
1426: LD_INT 1
1428: PUSH
1429: LD_INT 7
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PUSH
1438: LD_INT 4
1440: PUSH
1441: LD_INT 1
1443: PUSH
1444: LD_INT 1
1446: PUSH
1447: LD_INT 6
1449: PUSH
1450: EMPTY
1451: LIST
1452: LIST
1453: LIST
1454: LIST
1455: PUSH
1456: EMPTY
1457: LIST
1458: LIST
1459: LIST
1460: LIST
1461: PPUSH
1462: CALL 55948 0 2
// MC_SetTame ( 4 , powellApe ) ;
1466: LD_INT 4
1468: PPUSH
1469: LD_INT 13
1471: PPUSH
1472: CALL 56451 0 2
// end ;
1476: LD_VAR 0 1
1480: RET
// every 0 0$1 trigger debug do var i , tmp ;
1481: LD_EXP 1
1485: IFFALSE 1592
1487: GO 1489
1489: DISABLE
1490: LD_INT 0
1492: PPUSH
1493: PPUSH
// begin enable ;
1494: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1495: LD_ADDR_VAR 0 2
1499: PUSH
1500: LD_INT 22
1502: PUSH
1503: LD_INT 1
1505: PUSH
1506: EMPTY
1507: LIST
1508: LIST
1509: PUSH
1510: LD_INT 3
1512: PUSH
1513: LD_INT 21
1515: PUSH
1516: LD_INT 3
1518: PUSH
1519: EMPTY
1520: LIST
1521: LIST
1522: PUSH
1523: EMPTY
1524: LIST
1525: LIST
1526: PUSH
1527: LD_INT 3
1529: PUSH
1530: LD_INT 24
1532: PUSH
1533: LD_INT 999
1535: PUSH
1536: EMPTY
1537: LIST
1538: LIST
1539: PUSH
1540: EMPTY
1541: LIST
1542: LIST
1543: PUSH
1544: EMPTY
1545: LIST
1546: LIST
1547: LIST
1548: PPUSH
1549: CALL_OW 69
1553: ST_TO_ADDR
// if not tmp then
1554: LD_VAR 0 2
1558: NOT
1559: IFFALSE 1563
// exit ;
1561: GO 1592
// for i in tmp do
1563: LD_ADDR_VAR 0 1
1567: PUSH
1568: LD_VAR 0 2
1572: PUSH
1573: FOR_IN
1574: IFFALSE 1590
// SetLives ( i , 1000 ) ;
1576: LD_VAR 0 1
1580: PPUSH
1581: LD_INT 1000
1583: PPUSH
1584: CALL_OW 234
1588: GO 1573
1590: POP
1591: POP
// end ; end_of_file
1592: PPOPN 2
1594: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1595: LD_INT 0
1597: PPUSH
// uc_side := 1 ;
1598: LD_ADDR_OWVAR 20
1602: PUSH
1603: LD_INT 1
1605: ST_TO_ADDR
// uc_nation := 1 ;
1606: LD_ADDR_OWVAR 21
1610: PUSH
1611: LD_INT 1
1613: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1614: LD_ADDR_EXP 36
1618: PUSH
1619: LD_STRING JMM
1621: PPUSH
1622: LD_EXP 1
1626: NOT
1627: PPUSH
1628: LD_STRING 14_
1630: PPUSH
1631: CALL 61928 0 3
1635: ST_TO_ADDR
// if not JMMVeh then
1636: LD_EXP 4
1640: NOT
1641: IFFALSE 1664
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1643: LD_INT 3
1645: PPUSH
1646: LD_INT 3
1648: PPUSH
1649: LD_INT 1
1651: PPUSH
1652: LD_INT 5
1654: PPUSH
1655: LD_INT 100
1657: PPUSH
1658: CALL 68561 0 5
1662: GO 1723
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1664: LD_EXP 4
1668: PUSH
1669: LD_INT 1
1671: ARRAY
1672: PUSH
1673: LD_INT 1
1675: ARRAY
1676: PPUSH
1677: LD_EXP 4
1681: PUSH
1682: LD_INT 2
1684: ARRAY
1685: PUSH
1686: LD_INT 1
1688: ARRAY
1689: PPUSH
1690: LD_EXP 4
1694: PUSH
1695: LD_INT 3
1697: ARRAY
1698: PUSH
1699: LD_INT 1
1701: ARRAY
1702: PPUSH
1703: LD_EXP 4
1707: PUSH
1708: LD_INT 4
1710: ARRAY
1711: PUSH
1712: LD_INT 1
1714: ARRAY
1715: PPUSH
1716: LD_INT 30
1718: PPUSH
1719: CALL 68561 0 5
// JMMNewVeh := CreateVehicle ;
1723: LD_ADDR_EXP 53
1727: PUSH
1728: CALL_OW 45
1732: ST_TO_ADDR
// SetDir ( JMMNewVeh , 4 ) ;
1733: LD_EXP 53
1737: PPUSH
1738: LD_INT 4
1740: PPUSH
1741: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 75 , 92 , false ) ;
1745: LD_EXP 53
1749: PPUSH
1750: LD_INT 75
1752: PPUSH
1753: LD_INT 92
1755: PPUSH
1756: LD_INT 0
1758: PPUSH
1759: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1763: LD_EXP 36
1767: PPUSH
1768: LD_EXP 53
1772: PPUSH
1773: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1777: LD_EXP 6
1781: PUSH
1782: LD_EXP 2
1786: NOT
1787: AND
1788: IFFALSE 2046
// begin if not JMMGirlVeh then
1790: LD_EXP 5
1794: NOT
1795: IFFALSE 1818
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1797: LD_INT 3
1799: PPUSH
1800: LD_INT 3
1802: PPUSH
1803: LD_INT 1
1805: PPUSH
1806: LD_INT 9
1808: PPUSH
1809: LD_INT 100
1811: PPUSH
1812: CALL 68561 0 5
1816: GO 1877
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1818: LD_EXP 5
1822: PUSH
1823: LD_INT 1
1825: ARRAY
1826: PUSH
1827: LD_INT 1
1829: ARRAY
1830: PPUSH
1831: LD_EXP 5
1835: PUSH
1836: LD_INT 2
1838: ARRAY
1839: PUSH
1840: LD_INT 1
1842: ARRAY
1843: PPUSH
1844: LD_EXP 5
1848: PUSH
1849: LD_INT 3
1851: ARRAY
1852: PUSH
1853: LD_INT 1
1855: ARRAY
1856: PPUSH
1857: LD_EXP 5
1861: PUSH
1862: LD_INT 4
1864: ARRAY
1865: PUSH
1866: LD_INT 1
1868: ARRAY
1869: PPUSH
1870: LD_INT 30
1872: PPUSH
1873: CALL 68561 0 5
// GirlNewVeh := CreateVehicle ;
1877: LD_ADDR_EXP 54
1881: PUSH
1882: CALL_OW 45
1886: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
1887: LD_EXP 54
1891: PPUSH
1892: LD_INT 4
1894: PPUSH
1895: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
1899: LD_EXP 54
1903: PPUSH
1904: LD_INT 82
1906: PPUSH
1907: LD_INT 96
1909: PPUSH
1910: LD_INT 0
1912: PPUSH
1913: CALL_OW 48
// if JMMGirl = 1 then
1917: LD_EXP 7
1921: PUSH
1922: LD_INT 1
1924: EQUAL
1925: IFFALSE 1960
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
1927: LD_ADDR_EXP 37
1931: PUSH
1932: LD_STRING Joan
1934: PPUSH
1935: LD_INT 1
1937: PPUSH
1938: LD_STRING 14_
1940: PPUSH
1941: CALL 61928 0 3
1945: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
1946: LD_EXP 37
1950: PPUSH
1951: LD_EXP 54
1955: PPUSH
1956: CALL_OW 52
// end ; if JMMGirl = 2 then
1960: LD_EXP 7
1964: PUSH
1965: LD_INT 2
1967: EQUAL
1968: IFFALSE 2003
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
1970: LD_ADDR_EXP 39
1974: PUSH
1975: LD_STRING Lisa
1977: PPUSH
1978: LD_INT 1
1980: PPUSH
1981: LD_STRING 14_
1983: PPUSH
1984: CALL 61928 0 3
1988: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
1989: LD_EXP 39
1993: PPUSH
1994: LD_EXP 54
1998: PPUSH
1999: CALL_OW 52
// end ; if JMMGirl = 3 then
2003: LD_EXP 7
2007: PUSH
2008: LD_INT 3
2010: EQUAL
2011: IFFALSE 2046
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2013: LD_ADDR_EXP 51
2017: PUSH
2018: LD_STRING Connie
2020: PPUSH
2021: LD_INT 1
2023: PPUSH
2024: LD_STRING 14_
2026: PPUSH
2027: CALL 61928 0 3
2031: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2032: LD_EXP 51
2036: PPUSH
2037: LD_EXP 54
2041: PPUSH
2042: CALL_OW 52
// end ; end ; end ;
2046: LD_VAR 0 1
2050: RET
// export function PrepareStevensSquad ; var tmp ; begin
2051: LD_INT 0
2053: PPUSH
2054: PPUSH
// uc_side := 1 ;
2055: LD_ADDR_OWVAR 20
2059: PUSH
2060: LD_INT 1
2062: ST_TO_ADDR
// uc_nation := 1 ;
2063: LD_ADDR_OWVAR 21
2067: PUSH
2068: LD_INT 1
2070: ST_TO_ADDR
// tmp := [ ] ;
2071: LD_ADDR_VAR 0 2
2075: PUSH
2076: EMPTY
2077: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2078: LD_ADDR_EXP 38
2082: PUSH
2083: LD_STRING Stevens
2085: PPUSH
2086: LD_EXP 1
2090: NOT
2091: PPUSH
2092: LD_STRING 13f_
2094: PPUSH
2095: CALL 61928 0 3
2099: ST_TO_ADDR
// if not Stevens then
2100: LD_EXP 38
2104: NOT
2105: IFFALSE 2161
// begin hc_name = Baker Smith ;
2107: LD_ADDR_OWVAR 26
2111: PUSH
2112: LD_STRING Baker Smith
2114: ST_TO_ADDR
// hc_gallery =  ;
2115: LD_ADDR_OWVAR 33
2119: PUSH
2120: LD_STRING 
2122: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2123: LD_INT 1
2125: PPUSH
2126: LD_INT 10
2128: PPUSH
2129: CALL_OW 384
// Baker = CreateHuman ;
2133: LD_ADDR_EXP 52
2137: PUSH
2138: CALL_OW 44
2142: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2143: LD_ADDR_VAR 0 2
2147: PUSH
2148: LD_VAR 0 2
2152: PUSH
2153: LD_EXP 52
2157: ADD
2158: ST_TO_ADDR
// end else
2159: GO 2177
// tmp := tmp ^ Stevens ;
2161: LD_ADDR_VAR 0 2
2165: PUSH
2166: LD_VAR 0 2
2170: PUSH
2171: LD_EXP 38
2175: ADD
2176: ST_TO_ADDR
// if not Lisa then
2177: LD_EXP 39
2181: NOT
2182: IFFALSE 2228
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2184: LD_ADDR_EXP 39
2188: PUSH
2189: LD_STRING Lisa
2191: PPUSH
2192: LD_EXP 1
2196: NOT
2197: PPUSH
2198: LD_STRING 13f_
2200: PPUSH
2201: CALL 61928 0 3
2205: ST_TO_ADDR
// if Lisa then
2206: LD_EXP 39
2210: IFFALSE 2228
// tmp := tmp ^ Lisa ;
2212: LD_ADDR_VAR 0 2
2216: PUSH
2217: LD_VAR 0 2
2221: PUSH
2222: LD_EXP 39
2226: ADD
2227: ST_TO_ADDR
// end ; if not Donaldson then
2228: LD_EXP 40
2232: NOT
2233: IFFALSE 2279
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2235: LD_ADDR_EXP 40
2239: PUSH
2240: LD_STRING Donaldson
2242: PPUSH
2243: LD_EXP 1
2247: NOT
2248: PPUSH
2249: LD_STRING 13f_
2251: PPUSH
2252: CALL 61928 0 3
2256: ST_TO_ADDR
// if Donaldson then
2257: LD_EXP 40
2261: IFFALSE 2279
// tmp := tmp ^ Donaldson ;
2263: LD_ADDR_VAR 0 2
2267: PUSH
2268: LD_VAR 0 2
2272: PUSH
2273: LD_EXP 40
2277: ADD
2278: ST_TO_ADDR
// end ; if not Bobby then
2279: LD_EXP 41
2283: NOT
2284: IFFALSE 2330
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2286: LD_ADDR_EXP 41
2290: PUSH
2291: LD_STRING Bobby
2293: PPUSH
2294: LD_EXP 1
2298: NOT
2299: PPUSH
2300: LD_STRING 13f_
2302: PPUSH
2303: CALL 61928 0 3
2307: ST_TO_ADDR
// if Bobby then
2308: LD_EXP 41
2312: IFFALSE 2330
// tmp := tmp ^ Bobby ;
2314: LD_ADDR_VAR 0 2
2318: PUSH
2319: LD_VAR 0 2
2323: PUSH
2324: LD_EXP 41
2328: ADD
2329: ST_TO_ADDR
// end ; if not Cyrus then
2330: LD_EXP 42
2334: NOT
2335: IFFALSE 2381
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2337: LD_ADDR_EXP 42
2341: PUSH
2342: LD_STRING Cyrus
2344: PPUSH
2345: LD_EXP 1
2349: NOT
2350: PPUSH
2351: LD_STRING 13f_
2353: PPUSH
2354: CALL 61928 0 3
2358: ST_TO_ADDR
// if Cyrus then
2359: LD_EXP 42
2363: IFFALSE 2381
// tmp := tmp ^ Cyrus ;
2365: LD_ADDR_VAR 0 2
2369: PUSH
2370: LD_VAR 0 2
2374: PUSH
2375: LD_EXP 42
2379: ADD
2380: ST_TO_ADDR
// end ; if not Brown then
2381: LD_EXP 44
2385: NOT
2386: IFFALSE 2432
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2388: LD_ADDR_EXP 44
2392: PUSH
2393: LD_STRING Brown
2395: PPUSH
2396: LD_EXP 1
2400: NOT
2401: PPUSH
2402: LD_STRING 13f_
2404: PPUSH
2405: CALL 61928 0 3
2409: ST_TO_ADDR
// if Brown then
2410: LD_EXP 44
2414: IFFALSE 2432
// tmp := tmp ^ Brown ;
2416: LD_ADDR_VAR 0 2
2420: PUSH
2421: LD_VAR 0 2
2425: PUSH
2426: LD_EXP 44
2430: ADD
2431: ST_TO_ADDR
// end ; if not Gladstone then
2432: LD_EXP 45
2436: NOT
2437: IFFALSE 2483
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2439: LD_ADDR_EXP 45
2443: PUSH
2444: LD_STRING Gladstone
2446: PPUSH
2447: LD_EXP 1
2451: NOT
2452: PPUSH
2453: LD_STRING 13f_
2455: PPUSH
2456: CALL 61928 0 3
2460: ST_TO_ADDR
// if Gladstone then
2461: LD_EXP 45
2465: IFFALSE 2483
// tmp := tmp ^ Gladstone ;
2467: LD_ADDR_VAR 0 2
2471: PUSH
2472: LD_VAR 0 2
2476: PUSH
2477: LD_EXP 45
2481: ADD
2482: ST_TO_ADDR
// end ; if not Houten then
2483: LD_EXP 46
2487: NOT
2488: IFFALSE 2534
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2490: LD_ADDR_EXP 46
2494: PUSH
2495: LD_STRING Houten
2497: PPUSH
2498: LD_EXP 1
2502: NOT
2503: PPUSH
2504: LD_STRING 13f_
2506: PPUSH
2507: CALL 61928 0 3
2511: ST_TO_ADDR
// if Houten then
2512: LD_EXP 46
2516: IFFALSE 2534
// tmp := tmp ^ Houten ;
2518: LD_ADDR_VAR 0 2
2522: PUSH
2523: LD_VAR 0 2
2527: PUSH
2528: LD_EXP 46
2532: ADD
2533: ST_TO_ADDR
// end ; if not Cornel then
2534: LD_EXP 47
2538: NOT
2539: IFFALSE 2585
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13f_ ) ;
2541: LD_ADDR_EXP 47
2545: PUSH
2546: LD_STRING Cornel
2548: PPUSH
2549: LD_EXP 1
2553: NOT
2554: PPUSH
2555: LD_STRING 13f_
2557: PPUSH
2558: CALL 61928 0 3
2562: ST_TO_ADDR
// if Cornel then
2563: LD_EXP 47
2567: IFFALSE 2585
// tmp := tmp ^ Cornel ;
2569: LD_ADDR_VAR 0 2
2573: PUSH
2574: LD_VAR 0 2
2578: PUSH
2579: LD_EXP 47
2583: ADD
2584: ST_TO_ADDR
// end ; if not Gary then
2585: LD_EXP 48
2589: NOT
2590: IFFALSE 2636
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2592: LD_ADDR_EXP 48
2596: PUSH
2597: LD_STRING Gary
2599: PPUSH
2600: LD_EXP 1
2604: NOT
2605: PPUSH
2606: LD_STRING 13f_
2608: PPUSH
2609: CALL 61928 0 3
2613: ST_TO_ADDR
// if Gary then
2614: LD_EXP 48
2618: IFFALSE 2636
// tmp := tmp ^ Gary ;
2620: LD_ADDR_VAR 0 2
2624: PUSH
2625: LD_VAR 0 2
2629: PUSH
2630: LD_EXP 48
2634: ADD
2635: ST_TO_ADDR
// end ; if not Frank then
2636: LD_EXP 49
2640: NOT
2641: IFFALSE 2687
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2643: LD_ADDR_EXP 49
2647: PUSH
2648: LD_STRING Frank
2650: PPUSH
2651: LD_EXP 1
2655: NOT
2656: PPUSH
2657: LD_STRING 13f_
2659: PPUSH
2660: CALL 61928 0 3
2664: ST_TO_ADDR
// if Frank then
2665: LD_EXP 49
2669: IFFALSE 2687
// tmp := tmp ^ Frank ;
2671: LD_ADDR_VAR 0 2
2675: PUSH
2676: LD_VAR 0 2
2680: PUSH
2681: LD_EXP 49
2685: ADD
2686: ST_TO_ADDR
// end ; if not Kikuchi then
2687: LD_EXP 50
2691: NOT
2692: IFFALSE 2738
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2694: LD_ADDR_EXP 50
2698: PUSH
2699: LD_STRING Kikuchi
2701: PPUSH
2702: LD_EXP 1
2706: NOT
2707: PPUSH
2708: LD_STRING 13f_
2710: PPUSH
2711: CALL 61928 0 3
2715: ST_TO_ADDR
// if Kikuchi then
2716: LD_EXP 50
2720: IFFALSE 2738
// tmp := tmp ^ Kikuchi ;
2722: LD_ADDR_VAR 0 2
2726: PUSH
2727: LD_VAR 0 2
2731: PUSH
2732: LD_EXP 50
2736: ADD
2737: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2738: LD_ADDR_VAR 0 2
2742: PUSH
2743: LD_VAR 0 2
2747: PUSH
2748: LD_STRING 13_other_survivors
2750: PPUSH
2751: CALL_OW 31
2755: UNION
2756: ST_TO_ADDR
// result := tmp ;
2757: LD_ADDR_VAR 0 1
2761: PUSH
2762: LD_VAR 0 2
2766: ST_TO_ADDR
// end ; end_of_file
2767: LD_VAR 0 1
2771: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2772: LD_INT 0
2774: PPUSH
2775: PPUSH
2776: PPUSH
2777: PPUSH
2778: PPUSH
2779: PPUSH
2780: PPUSH
2781: PPUSH
2782: PPUSH
2783: PPUSH
// uc_side := 4 ;
2784: LD_ADDR_OWVAR 20
2788: PUSH
2789: LD_INT 4
2791: ST_TO_ADDR
// uc_nation := 1 ;
2792: LD_ADDR_OWVAR 21
2796: PUSH
2797: LD_INT 1
2799: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2800: LD_INT 387
2802: PPUSH
2803: CALL_OW 274
2807: PPUSH
2808: LD_INT 1
2810: PPUSH
2811: LD_INT 2500
2813: PPUSH
2814: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2818: LD_INT 387
2820: PPUSH
2821: CALL_OW 274
2825: PPUSH
2826: LD_INT 2
2828: PPUSH
2829: LD_INT 400
2831: PPUSH
2832: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2836: LD_INT 387
2838: PPUSH
2839: CALL_OW 274
2843: PPUSH
2844: LD_INT 3
2846: PPUSH
2847: LD_INT 10
2849: PPUSH
2850: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
2854: LD_ADDR_EXP 55
2858: PUSH
2859: LD_STRING Powell
2861: PPUSH
2862: CALL_OW 25
2866: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
2867: LD_EXP 55
2871: PPUSH
2872: LD_INT 57
2874: PPUSH
2875: LD_INT 94
2877: PPUSH
2878: LD_INT 0
2880: PPUSH
2881: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
2885: LD_EXP 55
2889: PPUSH
2890: LD_INT 58
2892: PPUSH
2893: LD_INT 94
2895: PPUSH
2896: CALL_OW 118
// vip := [ ] ;
2900: LD_ADDR_EXP 56
2904: PUSH
2905: EMPTY
2906: ST_TO_ADDR
// tmp := [ ] ;
2907: LD_ADDR_VAR 0 6
2911: PUSH
2912: EMPTY
2913: ST_TO_ADDR
// if JMMGirl <> 2 then
2914: LD_EXP 7
2918: PUSH
2919: LD_INT 2
2921: NONEQUAL
2922: IFFALSE 2946
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
2924: LD_ADDR_EXP 39
2928: PUSH
2929: LD_STRING Lisa
2931: PPUSH
2932: LD_EXP 1
2936: NOT
2937: PPUSH
2938: LD_STRING 13s_
2940: PPUSH
2941: CALL 61928 0 3
2945: ST_TO_ADDR
// if Lisa then
2946: LD_EXP 39
2950: IFFALSE 2968
// tmp := tmp ^ Lisa ;
2952: LD_ADDR_VAR 0 6
2956: PUSH
2957: LD_VAR 0 6
2961: PUSH
2962: LD_EXP 39
2966: ADD
2967: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
2968: LD_ADDR_EXP 40
2972: PUSH
2973: LD_STRING Donaldson
2975: PPUSH
2976: LD_EXP 1
2980: NOT
2981: PPUSH
2982: LD_STRING 13s_
2984: PPUSH
2985: CALL 61928 0 3
2989: ST_TO_ADDR
// if Donaldson then
2990: LD_EXP 40
2994: IFFALSE 3012
// tmp := tmp ^ Donaldson ;
2996: LD_ADDR_VAR 0 6
3000: PUSH
3001: LD_VAR 0 6
3005: PUSH
3006: LD_EXP 40
3010: ADD
3011: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3012: LD_ADDR_EXP 41
3016: PUSH
3017: LD_STRING Bobby
3019: PPUSH
3020: LD_EXP 1
3024: NOT
3025: PPUSH
3026: LD_STRING 13s_
3028: PPUSH
3029: CALL 61928 0 3
3033: ST_TO_ADDR
// if Bobby then
3034: LD_EXP 41
3038: IFFALSE 3056
// tmp := tmp ^ Bobby ;
3040: LD_ADDR_VAR 0 6
3044: PUSH
3045: LD_VAR 0 6
3049: PUSH
3050: LD_EXP 41
3054: ADD
3055: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3056: LD_ADDR_EXP 42
3060: PUSH
3061: LD_STRING Cyrus
3063: PPUSH
3064: LD_EXP 1
3068: NOT
3069: PPUSH
3070: LD_STRING 13s_
3072: PPUSH
3073: CALL 61928 0 3
3077: ST_TO_ADDR
// if Cyrus then
3078: LD_EXP 42
3082: IFFALSE 3100
// tmp := tmp ^ Cyrus ;
3084: LD_ADDR_VAR 0 6
3088: PUSH
3089: LD_VAR 0 6
3093: PUSH
3094: LD_EXP 42
3098: ADD
3099: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3100: LD_ADDR_EXP 43
3104: PUSH
3105: LD_STRING Denis
3107: PPUSH
3108: LD_EXP 1
3112: NOT
3113: PPUSH
3114: LD_STRING 13s_
3116: PPUSH
3117: CALL 61928 0 3
3121: ST_TO_ADDR
// if not Denis then
3122: LD_EXP 43
3126: NOT
3127: IFFALSE 3151
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3129: LD_ADDR_EXP 43
3133: PUSH
3134: LD_STRING Denis
3136: PPUSH
3137: LD_EXP 1
3141: NOT
3142: PPUSH
3143: LD_STRING 13f_
3145: PPUSH
3146: CALL 61928 0 3
3150: ST_TO_ADDR
// if Denis then
3151: LD_EXP 43
3155: IFFALSE 3173
// tmp := tmp ^ Denis ;
3157: LD_ADDR_VAR 0 6
3161: PUSH
3162: LD_VAR 0 6
3166: PUSH
3167: LD_EXP 43
3171: ADD
3172: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3173: LD_ADDR_EXP 44
3177: PUSH
3178: LD_STRING Brown
3180: PPUSH
3181: LD_EXP 1
3185: NOT
3186: PPUSH
3187: LD_STRING 13s_
3189: PPUSH
3190: CALL 61928 0 3
3194: ST_TO_ADDR
// if Brown then
3195: LD_EXP 44
3199: IFFALSE 3217
// tmp := tmp ^ Brown ;
3201: LD_ADDR_VAR 0 6
3205: PUSH
3206: LD_VAR 0 6
3210: PUSH
3211: LD_EXP 44
3215: ADD
3216: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3217: LD_ADDR_EXP 45
3221: PUSH
3222: LD_STRING Gladstone
3224: PPUSH
3225: LD_EXP 1
3229: NOT
3230: PPUSH
3231: LD_STRING 13s_
3233: PPUSH
3234: CALL 61928 0 3
3238: ST_TO_ADDR
// if Gladstone then
3239: LD_EXP 45
3243: IFFALSE 3261
// tmp := tmp ^ Gladstone ;
3245: LD_ADDR_VAR 0 6
3249: PUSH
3250: LD_VAR 0 6
3254: PUSH
3255: LD_EXP 45
3259: ADD
3260: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3261: LD_ADDR_EXP 46
3265: PUSH
3266: LD_STRING Houten
3268: PPUSH
3269: LD_EXP 1
3273: NOT
3274: PPUSH
3275: LD_STRING 13s_
3277: PPUSH
3278: CALL 61928 0 3
3282: ST_TO_ADDR
// if Houten then
3283: LD_EXP 46
3287: IFFALSE 3305
// tmp := tmp ^ Houten ;
3289: LD_ADDR_VAR 0 6
3293: PUSH
3294: LD_VAR 0 6
3298: PUSH
3299: LD_EXP 46
3303: ADD
3304: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3305: LD_ADDR_EXP 47
3309: PUSH
3310: LD_STRING Cornel
3312: PPUSH
3313: LD_EXP 1
3317: NOT
3318: PPUSH
3319: LD_STRING 13s_
3321: PPUSH
3322: CALL 61928 0 3
3326: ST_TO_ADDR
// if Cornel then
3327: LD_EXP 47
3331: IFFALSE 3349
// tmp := tmp ^ Cornel ;
3333: LD_ADDR_VAR 0 6
3337: PUSH
3338: LD_VAR 0 6
3342: PUSH
3343: LD_EXP 47
3347: ADD
3348: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3349: LD_ADDR_EXP 48
3353: PUSH
3354: LD_STRING Gary
3356: PPUSH
3357: LD_EXP 1
3361: NOT
3362: PPUSH
3363: LD_STRING 13s_
3365: PPUSH
3366: CALL 61928 0 3
3370: ST_TO_ADDR
// if Gary then
3371: LD_EXP 48
3375: IFFALSE 3393
// tmp := tmp ^ Gary ;
3377: LD_ADDR_VAR 0 6
3381: PUSH
3382: LD_VAR 0 6
3386: PUSH
3387: LD_EXP 48
3391: ADD
3392: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3393: LD_ADDR_EXP 49
3397: PUSH
3398: LD_STRING Frank
3400: PPUSH
3401: LD_EXP 1
3405: NOT
3406: PPUSH
3407: LD_STRING 13s_
3409: PPUSH
3410: CALL 61928 0 3
3414: ST_TO_ADDR
// if Frank then
3415: LD_EXP 49
3419: IFFALSE 3437
// tmp := tmp ^ Frank ;
3421: LD_ADDR_VAR 0 6
3425: PUSH
3426: LD_VAR 0 6
3430: PUSH
3431: LD_EXP 49
3435: ADD
3436: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3437: LD_ADDR_EXP 50
3441: PUSH
3442: LD_STRING Kikuchi
3444: PPUSH
3445: LD_EXP 1
3449: NOT
3450: PPUSH
3451: LD_STRING 13s_
3453: PPUSH
3454: CALL 61928 0 3
3458: ST_TO_ADDR
// if Kikuchi then
3459: LD_EXP 50
3463: IFFALSE 3481
// tmp := tmp ^ Kikuchi ;
3465: LD_ADDR_VAR 0 6
3469: PUSH
3470: LD_VAR 0 6
3474: PUSH
3475: LD_EXP 50
3479: ADD
3480: ST_TO_ADDR
// vip := tmp ;
3481: LD_ADDR_EXP 56
3485: PUSH
3486: LD_VAR 0 6
3490: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3491: LD_ADDR_VAR 0 6
3495: PUSH
3496: LD_VAR 0 6
3500: PUSH
3501: LD_STRING 13s_others
3503: PPUSH
3504: CALL_OW 31
3508: UNION
3509: ST_TO_ADDR
// if tmp < 20 then
3510: LD_VAR 0 6
3514: PUSH
3515: LD_INT 20
3517: LESS
3518: IFFALSE 3585
// for i = 1 to 20 - tmp do
3520: LD_ADDR_VAR 0 2
3524: PUSH
3525: DOUBLE
3526: LD_INT 1
3528: DEC
3529: ST_TO_ADDR
3530: LD_INT 20
3532: PUSH
3533: LD_VAR 0 6
3537: MINUS
3538: PUSH
3539: FOR_TO
3540: IFFALSE 3583
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3542: LD_INT 1
3544: PPUSH
3545: LD_VAR 0 2
3549: PUSH
3550: LD_INT 4
3552: MOD
3553: PUSH
3554: LD_INT 1
3556: PLUS
3557: PPUSH
3558: LD_INT 5
3560: PPUSH
3561: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3565: LD_ADDR_VAR 0 6
3569: PUSH
3570: LD_VAR 0 6
3574: PUSH
3575: CALL_OW 44
3579: ADD
3580: ST_TO_ADDR
// end ;
3581: GO 3539
3583: POP
3584: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3585: LD_ADDR_VAR 0 7
3589: PUSH
3590: LD_INT 22
3592: PUSH
3593: LD_INT 4
3595: PUSH
3596: EMPTY
3597: LIST
3598: LIST
3599: PUSH
3600: LD_INT 30
3602: PUSH
3603: LD_INT 0
3605: PUSH
3606: EMPTY
3607: LIST
3608: LIST
3609: PUSH
3610: EMPTY
3611: LIST
3612: LIST
3613: PPUSH
3614: CALL_OW 69
3618: PUSH
3619: LD_INT 1
3621: ARRAY
3622: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3623: LD_ADDR_VAR 0 8
3627: PUSH
3628: LD_INT 22
3630: PUSH
3631: LD_INT 4
3633: PUSH
3634: EMPTY
3635: LIST
3636: LIST
3637: PUSH
3638: LD_INT 30
3640: PUSH
3641: LD_INT 6
3643: PUSH
3644: EMPTY
3645: LIST
3646: LIST
3647: PUSH
3648: EMPTY
3649: LIST
3650: LIST
3651: PPUSH
3652: CALL_OW 69
3656: PUSH
3657: LD_INT 1
3659: ARRAY
3660: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3661: LD_ADDR_VAR 0 9
3665: PUSH
3666: LD_INT 22
3668: PUSH
3669: LD_INT 4
3671: PUSH
3672: EMPTY
3673: LIST
3674: LIST
3675: PUSH
3676: LD_INT 30
3678: PUSH
3679: LD_INT 4
3681: PUSH
3682: EMPTY
3683: LIST
3684: LIST
3685: PUSH
3686: EMPTY
3687: LIST
3688: LIST
3689: PPUSH
3690: CALL_OW 69
3694: PUSH
3695: LD_INT 1
3697: ARRAY
3698: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3699: LD_ADDR_VAR 0 10
3703: PUSH
3704: LD_INT 22
3706: PUSH
3707: LD_INT 4
3709: PUSH
3710: EMPTY
3711: LIST
3712: LIST
3713: PUSH
3714: LD_INT 30
3716: PUSH
3717: LD_INT 2
3719: PUSH
3720: EMPTY
3721: LIST
3722: LIST
3723: PUSH
3724: EMPTY
3725: LIST
3726: LIST
3727: PPUSH
3728: CALL_OW 69
3732: PUSH
3733: LD_INT 1
3735: ARRAY
3736: ST_TO_ADDR
// for i in tmp do
3737: LD_ADDR_VAR 0 2
3741: PUSH
3742: LD_VAR 0 6
3746: PUSH
3747: FOR_IN
3748: IFFALSE 3874
// begin cl := GetClass ( i ) ;
3750: LD_ADDR_VAR 0 5
3754: PUSH
3755: LD_VAR 0 2
3759: PPUSH
3760: CALL_OW 257
3764: ST_TO_ADDR
// if cl > 4 then
3765: LD_VAR 0 5
3769: PUSH
3770: LD_INT 4
3772: GREATER
3773: IFFALSE 3783
// cl := 1 ;
3775: LD_ADDR_VAR 0 5
3779: PUSH
3780: LD_INT 1
3782: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3783: LD_ADDR_VAR 0 3
3787: PUSH
3788: LD_VAR 0 9
3792: PUSH
3793: LD_VAR 0 7
3797: PUSH
3798: LD_VAR 0 10
3802: PUSH
3803: LD_VAR 0 8
3807: PUSH
3808: EMPTY
3809: LIST
3810: LIST
3811: LIST
3812: LIST
3813: PUSH
3814: LD_VAR 0 5
3818: ARRAY
3819: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3820: LD_VAR 0 3
3824: PPUSH
3825: CALL_OW 313
3829: PUSH
3830: LD_INT 5
3832: LESS
3833: IFFALSE 3851
// PlaceHumanInUnit ( i , b ) else
3835: LD_VAR 0 2
3839: PPUSH
3840: LD_VAR 0 3
3844: PPUSH
3845: CALL_OW 52
3849: GO 3872
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3851: LD_VAR 0 2
3855: PPUSH
3856: LD_INT 58
3858: PPUSH
3859: LD_INT 91
3861: PPUSH
3862: LD_INT 6
3864: PPUSH
3865: LD_INT 0
3867: PPUSH
3868: CALL_OW 50
// end ;
3872: GO 3747
3874: POP
3875: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
3876: LD_INT 2
3878: PPUSH
3879: LD_INT 1
3881: PPUSH
3882: LD_INT 1
3884: PPUSH
3885: LD_INT 12
3887: PPUSH
3888: LD_INT 100
3890: PPUSH
3891: CALL 68561 0 5
// veh := CreateVehicle ;
3895: LD_ADDR_VAR 0 4
3899: PUSH
3900: CALL_OW 45
3904: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
3905: LD_VAR 0 4
3909: PPUSH
3910: LD_INT 4
3912: PPUSH
3913: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
3917: LD_VAR 0 4
3921: PPUSH
3922: LD_INT 49
3924: PPUSH
3925: LD_INT 88
3927: PPUSH
3928: LD_INT 0
3930: PPUSH
3931: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
3935: LD_VAR 0 4
3939: PPUSH
3940: LD_INT 1
3942: PPUSH
3943: LD_INT 100
3945: PPUSH
3946: CALL_OW 290
// uc_side := 0 ;
3950: LD_ADDR_OWVAR 20
3954: PUSH
3955: LD_INT 0
3957: ST_TO_ADDR
// uc_nation := 0 ;
3958: LD_ADDR_OWVAR 21
3962: PUSH
3963: LD_INT 0
3965: ST_TO_ADDR
// for i = 1 to 4 do
3966: LD_ADDR_VAR 0 2
3970: PUSH
3971: DOUBLE
3972: LD_INT 1
3974: DEC
3975: ST_TO_ADDR
3976: LD_INT 4
3978: PUSH
3979: FOR_TO
3980: IFFALSE 4011
// begin InitHc ;
3982: CALL_OW 19
// hc_class := class_apeman ;
3986: LD_ADDR_OWVAR 28
3990: PUSH
3991: LD_INT 12
3993: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
3994: CALL_OW 44
3998: PPUSH
3999: LD_INT 13
4001: PPUSH
4002: LD_INT 0
4004: PPUSH
4005: CALL_OW 49
// end ;
4009: GO 3979
4011: POP
4012: POP
// end ; end_of_file
4013: LD_VAR 0 1
4017: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4018: LD_INT 0
4020: PPUSH
4021: PPUSH
4022: PPUSH
4023: PPUSH
4024: PPUSH
// side := 8 ;
4025: LD_ADDR_VAR 0 3
4029: PUSH
4030: LD_INT 8
4032: ST_TO_ADDR
// uc_side := side ;
4033: LD_ADDR_OWVAR 20
4037: PUSH
4038: LD_VAR 0 3
4042: ST_TO_ADDR
// uc_nation := 2 ;
4043: LD_ADDR_OWVAR 21
4047: PUSH
4048: LD_INT 2
4050: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4051: LD_ADDR_VAR 0 2
4055: PUSH
4056: LD_INT 22
4058: PUSH
4059: LD_VAR 0 3
4063: PUSH
4064: EMPTY
4065: LIST
4066: LIST
4067: PUSH
4068: LD_INT 21
4070: PUSH
4071: LD_INT 3
4073: PUSH
4074: EMPTY
4075: LIST
4076: LIST
4077: PUSH
4078: EMPTY
4079: LIST
4080: LIST
4081: PPUSH
4082: CALL_OW 69
4086: PUSH
4087: FOR_IN
4088: IFFALSE 4104
// SetBLevel ( i , 10 ) ;
4090: LD_VAR 0 2
4094: PPUSH
4095: LD_INT 10
4097: PPUSH
4098: CALL_OW 241
4102: GO 4087
4104: POP
4105: POP
// if KurtStatus then
4106: LD_EXP 3
4110: IFFALSE 4133
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4112: LD_ADDR_EXP 57
4116: PUSH
4117: LD_STRING Kurt
4119: PPUSH
4120: LD_INT 0
4122: PPUSH
4123: LD_STRING 
4125: PPUSH
4126: CALL 61928 0 3
4130: ST_TO_ADDR
4131: GO 4155
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4133: LD_ADDR_EXP 57
4137: PUSH
4138: LD_STRING AltKurt
4140: PPUSH
4141: LD_EXP 1
4145: NOT
4146: PPUSH
4147: LD_STRING 
4149: PPUSH
4150: CALL 61928 0 3
4154: ST_TO_ADDR
// if not Kurt then
4155: LD_EXP 57
4159: NOT
4160: IFFALSE 4186
// begin InitHc ;
4162: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4166: LD_INT 1
4168: PPUSH
4169: LD_INT 10
4171: PPUSH
4172: CALL_OW 381
// Kurt := CreateHuman ;
4176: LD_ADDR_EXP 57
4180: PUSH
4181: CALL_OW 44
4185: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4186: LD_EXP 57
4190: PPUSH
4191: LD_INT 324
4193: PPUSH
4194: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4198: LD_ADDR_EXP 58
4202: PUSH
4203: LD_STRING Kozlov
4205: PPUSH
4206: LD_INT 0
4208: PPUSH
4209: LD_STRING 
4211: PPUSH
4212: CALL 61928 0 3
4216: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4217: LD_EXP 58
4221: PPUSH
4222: LD_INT 22
4224: PUSH
4225: LD_INT 8
4227: PUSH
4228: EMPTY
4229: LIST
4230: LIST
4231: PUSH
4232: LD_INT 23
4234: PUSH
4235: LD_INT 3
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 30
4244: PUSH
4245: LD_INT 8
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: LIST
4256: PPUSH
4257: CALL_OW 69
4261: PUSH
4262: LD_INT 1
4264: ARRAY
4265: PPUSH
4266: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4270: LD_EXP 58
4274: PPUSH
4275: LD_INT 3
4277: PPUSH
4278: LD_INT 10
4280: PPUSH
4281: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4285: LD_ADDR_VAR 0 5
4289: PUSH
4290: LD_INT 22
4292: PUSH
4293: LD_VAR 0 3
4297: PUSH
4298: EMPTY
4299: LIST
4300: LIST
4301: PUSH
4302: LD_INT 30
4304: PUSH
4305: LD_INT 32
4307: PUSH
4308: EMPTY
4309: LIST
4310: LIST
4311: PUSH
4312: LD_INT 58
4314: PUSH
4315: EMPTY
4316: LIST
4317: PUSH
4318: EMPTY
4319: LIST
4320: LIST
4321: LIST
4322: PPUSH
4323: CALL_OW 69
4327: ST_TO_ADDR
// for i = 1 to 10 do
4328: LD_ADDR_VAR 0 2
4332: PUSH
4333: DOUBLE
4334: LD_INT 1
4336: DEC
4337: ST_TO_ADDR
4338: LD_INT 10
4340: PUSH
4341: FOR_TO
4342: IFFALSE 4414
// begin uc_nation := nation_nature ;
4344: LD_ADDR_OWVAR 21
4348: PUSH
4349: LD_INT 0
4351: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4352: LD_ADDR_OWVAR 28
4356: PUSH
4357: LD_INT 15
4359: ST_TO_ADDR
// hc_gallery :=  ;
4360: LD_ADDR_OWVAR 33
4364: PUSH
4365: LD_STRING 
4367: ST_TO_ADDR
// hc_name :=  ;
4368: LD_ADDR_OWVAR 26
4372: PUSH
4373: LD_STRING 
4375: ST_TO_ADDR
// un := CreateHuman ;
4376: LD_ADDR_VAR 0 4
4380: PUSH
4381: CALL_OW 44
4385: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4386: LD_VAR 0 4
4390: PPUSH
4391: LD_VAR 0 5
4395: PUSH
4396: LD_VAR 0 5
4400: PUSH
4401: LD_VAR 0 2
4405: MINUS
4406: ARRAY
4407: PPUSH
4408: CALL_OW 52
// end ;
4412: GO 4341
4414: POP
4415: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4416: LD_ADDR_VAR 0 5
4420: PUSH
4421: LD_STRING 12_kurt_squad
4423: PPUSH
4424: CALL_OW 31
4428: ST_TO_ADDR
// if tmp then
4429: LD_VAR 0 5
4433: IFFALSE 4467
// for i in tmp do
4435: LD_ADDR_VAR 0 2
4439: PUSH
4440: LD_VAR 0 5
4444: PUSH
4445: FOR_IN
4446: IFFALSE 4465
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4448: LD_VAR 0 2
4452: PPUSH
4453: LD_INT 5
4455: PPUSH
4456: LD_INT 0
4458: PPUSH
4459: CALL_OW 49
4463: GO 4445
4465: POP
4466: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4467: LD_INT 324
4469: PPUSH
4470: LD_INT 5
4472: PPUSH
4473: LD_STRING 
4475: PPUSH
4476: LD_INT 8
4478: PUSH
4479: LD_INT 9
4481: PUSH
4482: LD_INT 10
4484: PUSH
4485: EMPTY
4486: LIST
4487: LIST
4488: LIST
4489: PUSH
4490: LD_OWVAR 67
4494: ARRAY
4495: PPUSH
4496: LD_INT 3000
4498: PUSH
4499: LD_INT 500
4501: PUSH
4502: LD_INT 150
4504: PUSH
4505: EMPTY
4506: LIST
4507: LIST
4508: LIST
4509: PPUSH
4510: LD_INT 16
4512: PUSH
4513: LD_INT 6
4515: PUSH
4516: LD_INT 6
4518: PUSH
4519: LD_INT 8
4521: PUSH
4522: EMPTY
4523: LIST
4524: LIST
4525: LIST
4526: LIST
4527: PPUSH
4528: CALL 71970 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4532: LD_ADDR_EXP 99
4536: PUSH
4537: LD_EXP 99
4541: PPUSH
4542: LD_INT 3
4544: PPUSH
4545: LD_INT 22
4547: PUSH
4548: LD_VAR 0 3
4552: PUSH
4553: EMPTY
4554: LIST
4555: LIST
4556: PUSH
4557: LD_INT 23
4559: PUSH
4560: LD_INT 2
4562: PUSH
4563: EMPTY
4564: LIST
4565: LIST
4566: PUSH
4567: LD_INT 3
4569: PUSH
4570: LD_INT 21
4572: PUSH
4573: LD_INT 2
4575: PUSH
4576: EMPTY
4577: LIST
4578: LIST
4579: PUSH
4580: EMPTY
4581: LIST
4582: LIST
4583: PUSH
4584: EMPTY
4585: LIST
4586: LIST
4587: LIST
4588: PPUSH
4589: CALL_OW 69
4593: PUSH
4594: LD_EXP 57
4598: DIFF
4599: PPUSH
4600: CALL_OW 1
4604: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4605: LD_INT 1
4607: PPUSH
4608: LD_INT 7
4610: PPUSH
4611: CALL_OW 383
// Friend := CreateHuman ;
4615: LD_ADDR_EXP 59
4619: PUSH
4620: CALL_OW 44
4624: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4625: LD_INT 14
4627: PPUSH
4628: LD_INT 3
4630: PPUSH
4631: LD_INT 1
4633: PPUSH
4634: LD_INT 29
4636: PPUSH
4637: LD_INT 100
4639: PPUSH
4640: CALL 68561 0 5
// powellBomb := CreateVehicle ;
4644: LD_ADDR_EXP 60
4648: PUSH
4649: CALL_OW 45
4653: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4654: LD_EXP 60
4658: PPUSH
4659: LD_INT 90
4661: PPUSH
4662: LD_INT 51
4664: PPUSH
4665: LD_INT 0
4667: PPUSH
4668: CALL_OW 48
// end ;
4672: LD_VAR 0 1
4676: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4677: LD_INT 0
4679: PPUSH
4680: PPUSH
4681: PPUSH
// if IsLive ( kozlov_fac ) then
4682: LD_INT 332
4684: PPUSH
4685: CALL_OW 300
4689: IFFALSE 4693
// exit ;
4691: GO 5260
// ComExitBuilding ( Kozlov ) ;
4693: LD_EXP 58
4697: PPUSH
4698: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4702: LD_EXP 58
4706: PPUSH
4707: CALL_OW 257
4711: PUSH
4712: LD_INT 2
4714: NONEQUAL
4715: IFFALSE 4750
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4717: LD_EXP 58
4721: PPUSH
4722: LD_INT 324
4724: PPUSH
4725: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4729: LD_EXP 58
4733: PPUSH
4734: LD_INT 2
4736: PPUSH
4737: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4741: LD_EXP 58
4745: PPUSH
4746: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4750: LD_EXP 58
4754: PPUSH
4755: LD_INT 2
4757: PPUSH
4758: LD_INT 93
4760: PPUSH
4761: LD_INT 32
4763: PPUSH
4764: LD_INT 3
4766: PPUSH
4767: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4771: LD_INT 35
4773: PPUSH
4774: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4778: LD_INT 22
4780: PUSH
4781: LD_INT 8
4783: PUSH
4784: EMPTY
4785: LIST
4786: LIST
4787: PUSH
4788: LD_INT 30
4790: PUSH
4791: LD_INT 3
4793: PUSH
4794: EMPTY
4795: LIST
4796: LIST
4797: PUSH
4798: LD_INT 23
4800: PUSH
4801: LD_INT 3
4803: PUSH
4804: EMPTY
4805: LIST
4806: LIST
4807: PUSH
4808: LD_INT 57
4810: PUSH
4811: EMPTY
4812: LIST
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: LIST
4818: LIST
4819: PPUSH
4820: CALL_OW 69
4824: IFFALSE 4771
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4826: LD_ADDR_VAR 0 2
4830: PUSH
4831: LD_INT 22
4833: PUSH
4834: LD_INT 8
4836: PUSH
4837: EMPTY
4838: LIST
4839: LIST
4840: PUSH
4841: LD_INT 30
4843: PUSH
4844: LD_INT 3
4846: PUSH
4847: EMPTY
4848: LIST
4849: LIST
4850: PUSH
4851: LD_INT 23
4853: PUSH
4854: LD_INT 3
4856: PUSH
4857: EMPTY
4858: LIST
4859: LIST
4860: PUSH
4861: LD_INT 57
4863: PUSH
4864: EMPTY
4865: LIST
4866: PUSH
4867: EMPTY
4868: LIST
4869: LIST
4870: LIST
4871: LIST
4872: PPUSH
4873: CALL_OW 69
4877: PUSH
4878: LD_INT 1
4880: ARRAY
4881: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
4882: LD_INT 22
4884: PUSH
4885: LD_INT 8
4887: PUSH
4888: EMPTY
4889: LIST
4890: LIST
4891: PUSH
4892: LD_INT 23
4894: PUSH
4895: LD_INT 3
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: PUSH
4902: LD_INT 30
4904: PUSH
4905: LD_INT 21
4907: PUSH
4908: EMPTY
4909: LIST
4910: LIST
4911: PUSH
4912: EMPTY
4913: LIST
4914: LIST
4915: LIST
4916: PPUSH
4917: CALL_OW 69
4921: NOT
4922: IFFALSE 5000
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
4924: LD_EXP 58
4928: PPUSH
4929: LD_INT 21
4931: PPUSH
4932: LD_INT 97
4934: PPUSH
4935: LD_INT 36
4937: PPUSH
4938: LD_INT 5
4940: PPUSH
4941: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4945: LD_INT 35
4947: PPUSH
4948: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
4952: LD_INT 22
4954: PUSH
4955: LD_INT 8
4957: PUSH
4958: EMPTY
4959: LIST
4960: LIST
4961: PUSH
4962: LD_INT 23
4964: PUSH
4965: LD_INT 3
4967: PUSH
4968: EMPTY
4969: LIST
4970: LIST
4971: PUSH
4972: LD_INT 30
4974: PUSH
4975: LD_INT 21
4977: PUSH
4978: EMPTY
4979: LIST
4980: LIST
4981: PUSH
4982: LD_INT 57
4984: PUSH
4985: EMPTY
4986: LIST
4987: PUSH
4988: EMPTY
4989: LIST
4990: LIST
4991: LIST
4992: LIST
4993: PPUSH
4994: CALL_OW 69
4998: IFFALSE 4945
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5000: LD_INT 22
5002: PUSH
5003: LD_INT 8
5005: PUSH
5006: EMPTY
5007: LIST
5008: LIST
5009: PUSH
5010: LD_INT 23
5012: PUSH
5013: LD_INT 3
5015: PUSH
5016: EMPTY
5017: LIST
5018: LIST
5019: PUSH
5020: LD_INT 30
5022: PUSH
5023: LD_INT 18
5025: PUSH
5026: EMPTY
5027: LIST
5028: LIST
5029: PUSH
5030: EMPTY
5031: LIST
5032: LIST
5033: LIST
5034: PPUSH
5035: CALL_OW 69
5039: NOT
5040: IFFALSE 5118
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5042: LD_EXP 58
5046: PPUSH
5047: LD_INT 18
5049: PPUSH
5050: LD_INT 89
5052: PPUSH
5053: LD_INT 32
5055: PPUSH
5056: LD_INT 1
5058: PPUSH
5059: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5063: LD_INT 35
5065: PPUSH
5066: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5070: LD_INT 22
5072: PUSH
5073: LD_INT 8
5075: PUSH
5076: EMPTY
5077: LIST
5078: LIST
5079: PUSH
5080: LD_INT 23
5082: PUSH
5083: LD_INT 3
5085: PUSH
5086: EMPTY
5087: LIST
5088: LIST
5089: PUSH
5090: LD_INT 30
5092: PUSH
5093: LD_INT 18
5095: PUSH
5096: EMPTY
5097: LIST
5098: LIST
5099: PUSH
5100: LD_INT 57
5102: PUSH
5103: EMPTY
5104: LIST
5105: PUSH
5106: EMPTY
5107: LIST
5108: LIST
5109: LIST
5110: LIST
5111: PPUSH
5112: CALL_OW 69
5116: IFFALSE 5063
// end ; lab := kozlov_lab ;
5118: LD_ADDR_VAR 0 3
5122: PUSH
5123: LD_INT 336
5125: ST_TO_ADDR
// if not lab then
5126: LD_VAR 0 3
5130: NOT
5131: IFFALSE 5135
// exit ;
5133: GO 5260
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5135: LD_EXP 58
5139: PPUSH
5140: LD_VAR 0 3
5144: PUSH
5145: LD_INT 1
5147: ARRAY
5148: PPUSH
5149: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5153: LD_EXP 58
5157: PPUSH
5158: LD_INT 4
5160: PPUSH
5161: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5165: LD_VAR 0 3
5169: PUSH
5170: LD_INT 1
5172: ARRAY
5173: PPUSH
5174: LD_INT 25
5176: PPUSH
5177: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5181: LD_INT 35
5183: PPUSH
5184: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5188: LD_INT 25
5190: PPUSH
5191: LD_INT 8
5193: PPUSH
5194: CALL_OW 321
5198: PUSH
5199: LD_INT 2
5201: EQUAL
5202: IFFALSE 5181
// ComExitBuilding ( Kozlov ) ;
5204: LD_EXP 58
5208: PPUSH
5209: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5213: LD_EXP 58
5217: PPUSH
5218: LD_VAR 0 2
5222: PPUSH
5223: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5227: LD_EXP 58
5231: PPUSH
5232: LD_INT 3
5234: PPUSH
5235: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5239: LD_VAR 0 2
5243: PPUSH
5244: LD_INT 23
5246: PPUSH
5247: LD_INT 3
5249: PPUSH
5250: LD_INT 1
5252: PPUSH
5253: LD_INT 48
5255: PPUSH
5256: CALL_OW 125
// end ;
5260: LD_VAR 0 1
5264: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5265: LD_EXP 22
5269: NOT
5270: PUSH
5271: LD_EXP 15
5275: PUSH
5276: LD_INT 6
5278: GREATEREQUAL
5279: AND
5280: IFFALSE 5361
5282: GO 5284
5284: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5285: LD_INT 3
5287: PPUSH
5288: LD_INT 3
5290: PPUSH
5291: CALL 56133 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5295: LD_INT 3
5297: PPUSH
5298: LD_INT 14
5300: PUSH
5301: LD_INT 1
5303: PUSH
5304: LD_INT 1
5306: PUSH
5307: LD_INT 28
5309: PUSH
5310: EMPTY
5311: LIST
5312: LIST
5313: LIST
5314: LIST
5315: PUSH
5316: LD_INT 14
5318: PUSH
5319: LD_INT 1
5321: PUSH
5322: LD_INT 1
5324: PUSH
5325: LD_INT 28
5327: PUSH
5328: EMPTY
5329: LIST
5330: LIST
5331: LIST
5332: LIST
5333: PUSH
5334: LD_INT 14
5336: PUSH
5337: LD_INT 1
5339: PUSH
5340: LD_INT 1
5342: PUSH
5343: LD_INT 28
5345: PUSH
5346: EMPTY
5347: LIST
5348: LIST
5349: LIST
5350: LIST
5351: PUSH
5352: EMPTY
5353: LIST
5354: LIST
5355: LIST
5356: PPUSH
5357: CALL 55996 0 2
// end ;
5361: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5362: LD_EXP 22
5366: NOT
5367: PUSH
5368: LD_EXP 15
5372: PUSH
5373: LD_INT 6
5375: GREATEREQUAL
5376: AND
5377: PUSH
5378: LD_INT 3
5380: PPUSH
5381: LD_INT 1
5383: PPUSH
5384: CALL 57351 0 2
5388: NOT
5389: AND
5390: IFFALSE 6230
5392: GO 5394
5394: DISABLE
5395: LD_INT 0
5397: PPUSH
5398: PPUSH
5399: PPUSH
// begin enable ;
5400: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5401: LD_INT 22
5403: PUSH
5404: LD_INT 8
5406: PUSH
5407: EMPTY
5408: LIST
5409: LIST
5410: PUSH
5411: LD_INT 23
5413: PUSH
5414: LD_INT 2
5416: PUSH
5417: EMPTY
5418: LIST
5419: LIST
5420: PUSH
5421: LD_INT 30
5423: PUSH
5424: LD_INT 3
5426: PUSH
5427: EMPTY
5428: LIST
5429: LIST
5430: PUSH
5431: EMPTY
5432: LIST
5433: LIST
5434: LIST
5435: PPUSH
5436: CALL_OW 69
5440: NOT
5441: IFFALSE 5445
// exit ;
5443: GO 6230
// if Prob ( 40 ) then
5445: LD_INT 40
5447: PPUSH
5448: CALL_OW 13
5452: IFFALSE 5579
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5454: LD_INT 3
5456: PPUSH
5457: LD_INT 14
5459: PUSH
5460: LD_INT 1
5462: PUSH
5463: LD_INT 2
5465: PUSH
5466: LD_INT 28
5468: PUSH
5469: EMPTY
5470: LIST
5471: LIST
5472: LIST
5473: LIST
5474: PUSH
5475: LD_INT 14
5477: PUSH
5478: LD_INT 1
5480: PUSH
5481: LD_INT 2
5483: PUSH
5484: LD_INT 28
5486: PUSH
5487: EMPTY
5488: LIST
5489: LIST
5490: LIST
5491: LIST
5492: PUSH
5493: LD_INT 14
5495: PUSH
5496: LD_INT 1
5498: PUSH
5499: LD_INT 2
5501: PUSH
5502: LD_INT 28
5504: PUSH
5505: EMPTY
5506: LIST
5507: LIST
5508: LIST
5509: LIST
5510: PUSH
5511: LD_INT 14
5513: PUSH
5514: LD_INT 1
5516: PUSH
5517: LD_INT 2
5519: PUSH
5520: LD_INT 28
5522: PUSH
5523: EMPTY
5524: LIST
5525: LIST
5526: LIST
5527: LIST
5528: PUSH
5529: LD_INT 14
5531: PUSH
5532: LD_INT 1
5534: PUSH
5535: LD_INT 2
5537: PUSH
5538: LD_INT 28
5540: PUSH
5541: EMPTY
5542: LIST
5543: LIST
5544: LIST
5545: LIST
5546: PUSH
5547: LD_INT 14
5549: PUSH
5550: LD_INT 1
5552: PUSH
5553: LD_INT 2
5555: PUSH
5556: LD_INT 26
5558: PUSH
5559: EMPTY
5560: LIST
5561: LIST
5562: LIST
5563: LIST
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: LIST
5569: LIST
5570: LIST
5571: LIST
5572: PPUSH
5573: CALL 55996 0 2
// end else
5577: GO 5770
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5579: LD_INT 3
5581: PPUSH
5582: LD_INT 14
5584: PUSH
5585: LD_INT 1
5587: PUSH
5588: LD_INT 2
5590: PUSH
5591: LD_INT 27
5593: PUSH
5594: LD_INT 26
5596: PUSH
5597: LD_INT 26
5599: PUSH
5600: EMPTY
5601: LIST
5602: LIST
5603: LIST
5604: PUSH
5605: LD_OWVAR 67
5609: ARRAY
5610: PUSH
5611: EMPTY
5612: LIST
5613: LIST
5614: LIST
5615: LIST
5616: PUSH
5617: LD_INT 14
5619: PUSH
5620: LD_INT 1
5622: PUSH
5623: LD_INT 2
5625: PUSH
5626: LD_INT 27
5628: PUSH
5629: LD_INT 26
5631: PUSH
5632: LD_INT 26
5634: PUSH
5635: EMPTY
5636: LIST
5637: LIST
5638: LIST
5639: PUSH
5640: LD_OWVAR 67
5644: ARRAY
5645: PUSH
5646: EMPTY
5647: LIST
5648: LIST
5649: LIST
5650: LIST
5651: PUSH
5652: LD_INT 14
5654: PUSH
5655: LD_INT 1
5657: PUSH
5658: LD_INT 2
5660: PUSH
5661: LD_INT 26
5663: PUSH
5664: LD_INT 26
5666: PUSH
5667: LD_INT 29
5669: PUSH
5670: EMPTY
5671: LIST
5672: LIST
5673: LIST
5674: PUSH
5675: LD_OWVAR 67
5679: ARRAY
5680: PUSH
5681: EMPTY
5682: LIST
5683: LIST
5684: LIST
5685: LIST
5686: PUSH
5687: LD_INT 13
5689: PUSH
5690: LD_INT 1
5692: PUSH
5693: LD_INT 2
5695: PUSH
5696: LD_INT 26
5698: PUSH
5699: LD_INT 29
5701: PUSH
5702: LD_INT 29
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: LIST
5709: PUSH
5710: LD_OWVAR 67
5714: ARRAY
5715: PUSH
5716: EMPTY
5717: LIST
5718: LIST
5719: LIST
5720: LIST
5721: PUSH
5722: LD_INT 13
5724: PUSH
5725: LD_INT 1
5727: PUSH
5728: LD_INT 2
5730: PUSH
5731: LD_INT 29
5733: PUSH
5734: EMPTY
5735: LIST
5736: LIST
5737: LIST
5738: LIST
5739: PUSH
5740: LD_INT 14
5742: PUSH
5743: LD_INT 1
5745: PUSH
5746: LD_INT 2
5748: PUSH
5749: LD_INT 26
5751: PUSH
5752: EMPTY
5753: LIST
5754: LIST
5755: LIST
5756: LIST
5757: PUSH
5758: EMPTY
5759: LIST
5760: LIST
5761: LIST
5762: LIST
5763: LIST
5764: LIST
5765: PPUSH
5766: CALL 55996 0 2
// end ; repeat wait ( 0 0$1 ) ;
5770: LD_INT 35
5772: PPUSH
5773: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5777: LD_INT 3
5779: PPUSH
5780: LD_INT 1
5782: PPUSH
5783: CALL 57351 0 2
5787: PUSH
5788: LD_INT 6
5790: GREATEREQUAL
5791: IFFALSE 5770
// wait ( 0 0$30 ) ;
5793: LD_INT 1050
5795: PPUSH
5796: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5800: LD_ADDR_VAR 0 2
5804: PUSH
5805: LD_INT 3
5807: PPUSH
5808: LD_INT 1
5810: PPUSH
5811: CALL 57351 0 2
5815: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5816: LD_ADDR_EXP 118
5820: PUSH
5821: LD_EXP 118
5825: PPUSH
5826: LD_INT 3
5828: PPUSH
5829: LD_EXP 118
5833: PUSH
5834: LD_INT 3
5836: ARRAY
5837: PUSH
5838: LD_VAR 0 2
5842: DIFF
5843: PPUSH
5844: CALL_OW 1
5848: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5849: LD_ADDR_VAR 0 3
5853: PUSH
5854: LD_INT 0
5856: PPUSH
5857: LD_INT 2
5859: PPUSH
5860: CALL_OW 12
5864: ST_TO_ADDR
// if target then
5865: LD_VAR 0 3
5869: IFFALSE 5997
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5871: LD_ADDR_VAR 0 2
5875: PUSH
5876: LD_VAR 0 2
5880: PPUSH
5881: LD_INT 24
5883: PUSH
5884: LD_INT 250
5886: PUSH
5887: EMPTY
5888: LIST
5889: LIST
5890: PPUSH
5891: CALL_OW 72
5895: ST_TO_ADDR
// for i in tmp do
5896: LD_ADDR_VAR 0 1
5900: PUSH
5901: LD_VAR 0 2
5905: PUSH
5906: FOR_IN
5907: IFFALSE 5947
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
5909: LD_VAR 0 1
5913: PPUSH
5914: LD_INT 89
5916: PPUSH
5917: LD_INT 71
5919: PPUSH
5920: CALL_OW 297
5924: PUSH
5925: LD_INT 9
5927: GREATER
5928: IFFALSE 5945
// ComMoveXY ( i , 89 , 71 ) ;
5930: LD_VAR 0 1
5934: PPUSH
5935: LD_INT 89
5937: PPUSH
5938: LD_INT 71
5940: PPUSH
5941: CALL_OW 111
5945: GO 5906
5947: POP
5948: POP
// wait ( 0 0$1 ) ;
5949: LD_INT 35
5951: PPUSH
5952: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
5956: LD_VAR 0 2
5960: PPUSH
5961: LD_INT 92
5963: PUSH
5964: LD_INT 89
5966: PUSH
5967: LD_INT 71
5969: PUSH
5970: LD_INT 9
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: LIST
5977: LIST
5978: PPUSH
5979: CALL_OW 72
5983: PUSH
5984: LD_VAR 0 2
5988: PUSH
5989: LD_INT 1
5991: MINUS
5992: GREATEREQUAL
5993: IFFALSE 5871
// end else
5995: GO 6121
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5997: LD_ADDR_VAR 0 2
6001: PUSH
6002: LD_VAR 0 2
6006: PPUSH
6007: LD_INT 24
6009: PUSH
6010: LD_INT 250
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: PPUSH
6017: CALL_OW 72
6021: ST_TO_ADDR
// for i in tmp do
6022: LD_ADDR_VAR 0 1
6026: PUSH
6027: LD_VAR 0 2
6031: PUSH
6032: FOR_IN
6033: IFFALSE 6073
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6035: LD_VAR 0 1
6039: PPUSH
6040: LD_INT 125
6042: PPUSH
6043: LD_INT 129
6045: PPUSH
6046: CALL_OW 297
6050: PUSH
6051: LD_INT 9
6053: GREATER
6054: IFFALSE 6071
// ComMoveXY ( i , 125 , 129 ) ;
6056: LD_VAR 0 1
6060: PPUSH
6061: LD_INT 125
6063: PPUSH
6064: LD_INT 129
6066: PPUSH
6067: CALL_OW 111
6071: GO 6032
6073: POP
6074: POP
// wait ( 0 0$1 ) ;
6075: LD_INT 35
6077: PPUSH
6078: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6082: LD_VAR 0 2
6086: PPUSH
6087: LD_INT 92
6089: PUSH
6090: LD_INT 125
6092: PUSH
6093: LD_INT 129
6095: PUSH
6096: LD_INT 9
6098: PUSH
6099: EMPTY
6100: LIST
6101: LIST
6102: LIST
6103: LIST
6104: PPUSH
6105: CALL_OW 72
6109: PUSH
6110: LD_VAR 0 2
6114: PUSH
6115: LD_INT 1
6117: MINUS
6118: GREATEREQUAL
6119: IFFALSE 5997
// end ; repeat wait ( 0 0$1 ) ;
6121: LD_INT 35
6123: PPUSH
6124: CALL_OW 67
// for i in tmp do
6128: LD_ADDR_VAR 0 1
6132: PUSH
6133: LD_VAR 0 2
6137: PUSH
6138: FOR_IN
6139: IFFALSE 6221
// begin if GetLives ( i ) > 251 then
6141: LD_VAR 0 1
6145: PPUSH
6146: CALL_OW 256
6150: PUSH
6151: LD_INT 251
6153: GREATER
6154: IFFALSE 6192
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6156: LD_VAR 0 1
6160: PPUSH
6161: LD_INT 81
6163: PUSH
6164: LD_INT 8
6166: PUSH
6167: EMPTY
6168: LIST
6169: LIST
6170: PPUSH
6171: CALL_OW 69
6175: PPUSH
6176: LD_VAR 0 1
6180: PPUSH
6181: CALL_OW 74
6185: PPUSH
6186: CALL_OW 115
6190: GO 6219
// if IsDead ( i ) then
6192: LD_VAR 0 1
6196: PPUSH
6197: CALL_OW 301
6201: IFFALSE 6219
// tmp := tmp diff i ;
6203: LD_ADDR_VAR 0 2
6207: PUSH
6208: LD_VAR 0 2
6212: PUSH
6213: LD_VAR 0 1
6217: DIFF
6218: ST_TO_ADDR
// end ;
6219: GO 6138
6221: POP
6222: POP
// until not tmp ;
6223: LD_VAR 0 2
6227: NOT
6228: IFFALSE 6121
// end ;
6230: PPOPN 3
6232: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6233: LD_EXP 22
6237: NOT
6238: PUSH
6239: LD_EXP 15
6243: PUSH
6244: LD_INT 6
6246: GREATEREQUAL
6247: AND
6248: PUSH
6249: LD_OWVAR 67
6253: PUSH
6254: LD_INT 1
6256: GREATER
6257: AND
6258: IFFALSE 6775
6260: GO 6262
6262: DISABLE
6263: LD_INT 0
6265: PPUSH
6266: PPUSH
6267: PPUSH
// begin enable ;
6268: ENABLE
// tmp := [ ] ;
6269: LD_ADDR_VAR 0 3
6273: PUSH
6274: EMPTY
6275: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6276: LD_ADDR_VAR 0 1
6280: PUSH
6281: DOUBLE
6282: LD_INT 1
6284: DEC
6285: ST_TO_ADDR
6286: LD_INT 4
6288: PUSH
6289: LD_INT 6
6291: PUSH
6292: LD_INT 7
6294: PUSH
6295: EMPTY
6296: LIST
6297: LIST
6298: LIST
6299: PUSH
6300: LD_OWVAR 67
6304: ARRAY
6305: PUSH
6306: FOR_TO
6307: IFFALSE 6467
// begin uc_side := 8 ;
6309: LD_ADDR_OWVAR 20
6313: PUSH
6314: LD_INT 8
6316: ST_TO_ADDR
// uc_nation := 2 ;
6317: LD_ADDR_OWVAR 21
6321: PUSH
6322: LD_INT 2
6324: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6325: LD_INT 13
6327: PUSH
6328: LD_INT 14
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: PUSH
6335: LD_INT 1
6337: PPUSH
6338: LD_INT 2
6340: PPUSH
6341: CALL_OW 12
6345: ARRAY
6346: PPUSH
6347: LD_INT 1
6349: PPUSH
6350: LD_INT 5
6352: PPUSH
6353: LD_INT 27
6355: PUSH
6356: LD_INT 28
6358: PUSH
6359: LD_INT 26
6361: PUSH
6362: LD_INT 25
6364: PUSH
6365: EMPTY
6366: LIST
6367: LIST
6368: LIST
6369: LIST
6370: PUSH
6371: LD_INT 1
6373: PPUSH
6374: LD_INT 4
6376: PPUSH
6377: CALL_OW 12
6381: ARRAY
6382: PPUSH
6383: LD_INT 88
6385: PPUSH
6386: CALL 68561 0 5
// un := CreateVehicle ;
6390: LD_ADDR_VAR 0 2
6394: PUSH
6395: CALL_OW 45
6399: ST_TO_ADDR
// tmp := tmp ^ un ;
6400: LD_ADDR_VAR 0 3
6404: PUSH
6405: LD_VAR 0 3
6409: PUSH
6410: LD_VAR 0 2
6414: ADD
6415: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6416: LD_VAR 0 2
6420: PPUSH
6421: LD_INT 3
6423: PPUSH
6424: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6428: LD_VAR 0 2
6432: PPUSH
6433: LD_INT 30
6435: PPUSH
6436: LD_INT 0
6438: PPUSH
6439: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6443: LD_VAR 0 2
6447: PPUSH
6448: LD_INT 16
6450: PPUSH
6451: LD_INT 11
6453: PPUSH
6454: CALL_OW 111
// wait ( 0 0$2 ) ;
6458: LD_INT 70
6460: PPUSH
6461: CALL_OW 67
// end ;
6465: GO 6306
6467: POP
6468: POP
// for i = 1 to Difficulty do
6469: LD_ADDR_VAR 0 1
6473: PUSH
6474: DOUBLE
6475: LD_INT 1
6477: DEC
6478: ST_TO_ADDR
6479: LD_OWVAR 67
6483: PUSH
6484: FOR_TO
6485: IFFALSE 6610
// begin uc_side := 8 ;
6487: LD_ADDR_OWVAR 20
6491: PUSH
6492: LD_INT 8
6494: ST_TO_ADDR
// uc_nation := 2 ;
6495: LD_ADDR_OWVAR 21
6499: PUSH
6500: LD_INT 2
6502: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6503: LD_INT 0
6505: PPUSH
6506: LD_INT 8
6508: PPUSH
6509: LD_INT 8
6511: PUSH
6512: LD_INT 8
6514: PUSH
6515: LD_INT 9
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: LIST
6522: PUSH
6523: LD_OWVAR 67
6527: ARRAY
6528: PPUSH
6529: CALL_OW 380
// un := CreateHuman ;
6533: LD_ADDR_VAR 0 2
6537: PUSH
6538: CALL_OW 44
6542: ST_TO_ADDR
// tmp := tmp ^ un ;
6543: LD_ADDR_VAR 0 3
6547: PUSH
6548: LD_VAR 0 3
6552: PUSH
6553: LD_VAR 0 2
6557: ADD
6558: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6559: LD_VAR 0 2
6563: PPUSH
6564: LD_INT 3
6566: PPUSH
6567: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6571: LD_VAR 0 2
6575: PPUSH
6576: LD_INT 30
6578: PPUSH
6579: LD_INT 0
6581: PPUSH
6582: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6586: LD_VAR 0 2
6590: PPUSH
6591: LD_INT 16
6593: PPUSH
6594: LD_INT 11
6596: PPUSH
6597: CALL_OW 111
// wait ( 0 0$2 ) ;
6601: LD_INT 70
6603: PPUSH
6604: CALL_OW 67
// end ;
6608: GO 6484
6610: POP
6611: POP
// repeat wait ( 0 0$1 ) ;
6612: LD_INT 35
6614: PPUSH
6615: CALL_OW 67
// for i in tmp do
6619: LD_ADDR_VAR 0 1
6623: PUSH
6624: LD_VAR 0 3
6628: PUSH
6629: FOR_IN
6630: IFFALSE 6766
// begin if GetLives ( i ) > 250 then
6632: LD_VAR 0 1
6636: PPUSH
6637: CALL_OW 256
6641: PUSH
6642: LD_INT 250
6644: GREATER
6645: IFFALSE 6737
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6647: LD_INT 81
6649: PUSH
6650: LD_INT 8
6652: PUSH
6653: EMPTY
6654: LIST
6655: LIST
6656: PUSH
6657: LD_INT 91
6659: PUSH
6660: LD_VAR 0 1
6664: PUSH
6665: LD_INT 10
6667: PUSH
6668: EMPTY
6669: LIST
6670: LIST
6671: LIST
6672: PUSH
6673: EMPTY
6674: LIST
6675: LIST
6676: PPUSH
6677: CALL_OW 69
6681: NOT
6682: IFFALSE 6701
// ComAgressiveMove ( i , 67 , 110 ) else
6684: LD_VAR 0 1
6688: PPUSH
6689: LD_INT 67
6691: PPUSH
6692: LD_INT 110
6694: PPUSH
6695: CALL_OW 114
6699: GO 6735
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6701: LD_VAR 0 1
6705: PPUSH
6706: LD_INT 81
6708: PUSH
6709: LD_INT 8
6711: PUSH
6712: EMPTY
6713: LIST
6714: LIST
6715: PPUSH
6716: CALL_OW 69
6720: PPUSH
6721: LD_VAR 0 1
6725: PPUSH
6726: CALL_OW 74
6730: PPUSH
6731: CALL_OW 115
// end else
6735: GO 6764
// if IsDead ( i ) then
6737: LD_VAR 0 1
6741: PPUSH
6742: CALL_OW 301
6746: IFFALSE 6764
// tmp := tmp diff i ;
6748: LD_ADDR_VAR 0 3
6752: PUSH
6753: LD_VAR 0 3
6757: PUSH
6758: LD_VAR 0 1
6762: DIFF
6763: ST_TO_ADDR
// end ;
6764: GO 6629
6766: POP
6767: POP
// until not tmp ;
6768: LD_VAR 0 3
6772: NOT
6773: IFFALSE 6612
// end ; end_of_file
6775: PPOPN 3
6777: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6778: LD_INT 0
6780: PPUSH
6781: PPUSH
6782: PPUSH
6783: PPUSH
6784: PPUSH
6785: PPUSH
6786: PPUSH
6787: PPUSH
6788: PPUSH
// side := 3 ;
6789: LD_ADDR_VAR 0 6
6793: PUSH
6794: LD_INT 3
6796: ST_TO_ADDR
// uc_side := side ;
6797: LD_ADDR_OWVAR 20
6801: PUSH
6802: LD_VAR 0 6
6806: ST_TO_ADDR
// uc_nation := 3 ;
6807: LD_ADDR_OWVAR 21
6811: PUSH
6812: LD_INT 3
6814: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6815: LD_ADDR_VAR 0 2
6819: PUSH
6820: LD_INT 22
6822: PUSH
6823: LD_VAR 0 6
6827: PUSH
6828: EMPTY
6829: LIST
6830: LIST
6831: PUSH
6832: LD_INT 21
6834: PUSH
6835: LD_INT 3
6837: PUSH
6838: EMPTY
6839: LIST
6840: LIST
6841: PUSH
6842: EMPTY
6843: LIST
6844: LIST
6845: PPUSH
6846: CALL_OW 69
6850: PUSH
6851: FOR_IN
6852: IFFALSE 6868
// SetBLevel ( i , 10 ) ;
6854: LD_VAR 0 2
6858: PPUSH
6859: LD_INT 10
6861: PPUSH
6862: CALL_OW 241
6866: GO 6851
6868: POP
6869: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
6870: LD_ADDR_VAR 0 9
6874: PUSH
6875: LD_INT 22
6877: PUSH
6878: LD_VAR 0 6
6882: PUSH
6883: EMPTY
6884: LIST
6885: LIST
6886: PUSH
6887: LD_INT 30
6889: PUSH
6890: LD_INT 34
6892: PUSH
6893: EMPTY
6894: LIST
6895: LIST
6896: PUSH
6897: EMPTY
6898: LIST
6899: LIST
6900: PPUSH
6901: CALL_OW 69
6905: ST_TO_ADDR
// if teleport then
6906: LD_VAR 0 9
6910: IFFALSE 6931
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
6912: LD_VAR 0 9
6916: PUSH
6917: LD_INT 1
6919: ARRAY
6920: PPUSH
6921: LD_INT 123
6923: PPUSH
6924: LD_INT 122
6926: PPUSH
6927: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
6931: LD_ADDR_EXP 61
6935: PUSH
6936: LD_STRING Platonov
6938: PPUSH
6939: CALL_OW 25
6943: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
6944: LD_ADDR_EXP 62
6948: PUSH
6949: LD_STRING Kovalyuk
6951: PPUSH
6952: CALL_OW 25
6956: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
6957: LD_ADDR_EXP 64
6961: PUSH
6962: LD_STRING Yakotich
6964: PPUSH
6965: CALL_OW 25
6969: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
6970: LD_ADDR_EXP 63
6974: PUSH
6975: LD_STRING Bystrov
6977: PPUSH
6978: CALL_OW 25
6982: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
6983: LD_ADDR_EXP 65
6987: PUSH
6988: LD_STRING Gleb
6990: PPUSH
6991: CALL_OW 25
6995: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
6996: LD_STRING 03_Cornel
6998: PPUSH
6999: CALL_OW 28
7003: IFFALSE 7051
// begin Bierezov := NewCharacter ( Mikhail ) ;
7005: LD_ADDR_EXP 66
7009: PUSH
7010: LD_STRING Mikhail
7012: PPUSH
7013: CALL_OW 25
7017: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7018: LD_EXP 66
7022: PPUSH
7023: LD_INT 197
7025: PPUSH
7026: LD_INT 111
7028: PPUSH
7029: LD_INT 9
7031: PPUSH
7032: LD_INT 0
7034: PPUSH
7035: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7039: LD_EXP 66
7043: PPUSH
7044: LD_INT 3
7046: PPUSH
7047: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7051: LD_EXP 61
7055: PPUSH
7056: LD_INT 126
7058: PPUSH
7059: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7063: LD_EXP 62
7067: PPUSH
7068: LD_INT 134
7070: PPUSH
7071: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7075: LD_EXP 64
7079: PPUSH
7080: LD_INT 197
7082: PPUSH
7083: LD_INT 111
7085: PPUSH
7086: LD_INT 9
7088: PPUSH
7089: LD_INT 0
7091: PPUSH
7092: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7096: LD_EXP 63
7100: PPUSH
7101: LD_INT 197
7103: PPUSH
7104: LD_INT 111
7106: PPUSH
7107: LD_INT 9
7109: PPUSH
7110: LD_INT 0
7112: PPUSH
7113: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7117: LD_EXP 65
7121: PPUSH
7122: LD_INT 197
7124: PPUSH
7125: LD_INT 111
7127: PPUSH
7128: LD_INT 9
7130: PPUSH
7131: LD_INT 0
7133: PPUSH
7134: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 99999 , 1000 , 300 ] , [ 12 , 8 , 13 , 8 ] ) ;
7138: LD_ADDR_VAR 0 5
7142: PUSH
7143: LD_INT 126
7145: PPUSH
7146: LD_INT 4
7148: PPUSH
7149: LD_STRING zhukov
7151: PPUSH
7152: LD_INT 9
7154: PUSH
7155: LD_INT 10
7157: PUSH
7158: LD_INT 10
7160: PUSH
7161: EMPTY
7162: LIST
7163: LIST
7164: LIST
7165: PUSH
7166: LD_OWVAR 67
7170: ARRAY
7171: PPUSH
7172: LD_INT 99999
7174: PUSH
7175: LD_INT 1000
7177: PUSH
7178: LD_INT 300
7180: PUSH
7181: EMPTY
7182: LIST
7183: LIST
7184: LIST
7185: PPUSH
7186: LD_INT 12
7188: PUSH
7189: LD_INT 8
7191: PUSH
7192: LD_INT 13
7194: PUSH
7195: LD_INT 8
7197: PUSH
7198: EMPTY
7199: LIST
7200: LIST
7201: LIST
7202: LIST
7203: PPUSH
7204: CALL 71970 0 6
7208: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7209: LD_ADDR_VAR 0 4
7213: PUSH
7214: LD_INT 267
7216: PPUSH
7217: CALL_OW 274
7221: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7222: LD_VAR 0 4
7226: PPUSH
7227: LD_INT 1
7229: PPUSH
7230: LD_INT 5000
7232: PPUSH
7233: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7237: LD_VAR 0 4
7241: PPUSH
7242: LD_INT 2
7244: PPUSH
7245: LD_INT 200
7247: PPUSH
7248: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7252: LD_VAR 0 4
7256: PPUSH
7257: LD_INT 3
7259: PPUSH
7260: LD_INT 200
7262: PPUSH
7263: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7267: LD_ADDR_EXP 99
7271: PUSH
7272: LD_EXP 99
7276: PPUSH
7277: LD_INT 2
7279: PPUSH
7280: LD_VAR 0 5
7284: PUSH
7285: LD_INT 22
7287: PUSH
7288: LD_VAR 0 6
7292: PUSH
7293: EMPTY
7294: LIST
7295: LIST
7296: PUSH
7297: LD_INT 3
7299: PUSH
7300: LD_INT 21
7302: PUSH
7303: LD_INT 2
7305: PUSH
7306: EMPTY
7307: LIST
7308: LIST
7309: PUSH
7310: EMPTY
7311: LIST
7312: LIST
7313: PUSH
7314: EMPTY
7315: LIST
7316: LIST
7317: PPUSH
7318: CALL_OW 69
7322: UNION
7323: PUSH
7324: LD_EXP 61
7328: DIFF
7329: PPUSH
7330: CALL_OW 1
7334: ST_TO_ADDR
// behemoths := [ ] ;
7335: LD_ADDR_EXP 69
7339: PUSH
7340: EMPTY
7341: ST_TO_ADDR
// behemothBuilders := [ ] ;
7342: LD_ADDR_EXP 70
7346: PUSH
7347: EMPTY
7348: ST_TO_ADDR
// if Kovalyuk then
7349: LD_EXP 62
7353: IFFALSE 7375
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7355: LD_ADDR_EXP 70
7359: PUSH
7360: LD_EXP 70
7364: PPUSH
7365: LD_EXP 62
7369: PPUSH
7370: CALL 104244 0 2
7374: ST_TO_ADDR
// j := 3 ;
7375: LD_ADDR_VAR 0 3
7379: PUSH
7380: LD_INT 3
7382: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7383: LD_ADDR_VAR 0 2
7387: PUSH
7388: LD_INT 22
7390: PUSH
7391: LD_INT 3
7393: PUSH
7394: EMPTY
7395: LIST
7396: LIST
7397: PUSH
7398: LD_INT 25
7400: PUSH
7401: LD_INT 3
7403: PUSH
7404: EMPTY
7405: LIST
7406: LIST
7407: PUSH
7408: EMPTY
7409: LIST
7410: LIST
7411: PPUSH
7412: CALL_OW 69
7416: PUSH
7417: LD_EXP 62
7421: DIFF
7422: PUSH
7423: FOR_IN
7424: IFFALSE 7474
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7426: LD_ADDR_EXP 70
7430: PUSH
7431: LD_EXP 70
7435: PPUSH
7436: LD_VAR 0 2
7440: PPUSH
7441: CALL 104244 0 2
7445: ST_TO_ADDR
// j := j - 1 ;
7446: LD_ADDR_VAR 0 3
7450: PUSH
7451: LD_VAR 0 3
7455: PUSH
7456: LD_INT 1
7458: MINUS
7459: ST_TO_ADDR
// if j = 0 then
7460: LD_VAR 0 3
7464: PUSH
7465: LD_INT 0
7467: EQUAL
7468: IFFALSE 7472
// break ;
7470: GO 7474
// end ;
7472: GO 7423
7474: POP
7475: POP
// end ;
7476: LD_VAR 0 1
7480: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7481: LD_INT 0
7483: PPUSH
7484: PPUSH
7485: PPUSH
7486: PPUSH
7487: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7488: LD_ADDR_VAR 0 4
7492: PUSH
7493: LD_INT 209
7495: PUSH
7496: LD_INT 149
7498: PUSH
7499: EMPTY
7500: LIST
7501: LIST
7502: PUSH
7503: LD_INT 219
7505: PUSH
7506: LD_INT 154
7508: PUSH
7509: EMPTY
7510: LIST
7511: LIST
7512: PUSH
7513: LD_INT 223
7515: PUSH
7516: LD_INT 149
7518: PUSH
7519: EMPTY
7520: LIST
7521: LIST
7522: PUSH
7523: LD_INT 232
7525: PUSH
7526: LD_INT 155
7528: PUSH
7529: EMPTY
7530: LIST
7531: LIST
7532: PUSH
7533: EMPTY
7534: LIST
7535: LIST
7536: LIST
7537: LIST
7538: ST_TO_ADDR
// if not behemothBuilders then
7539: LD_EXP 70
7543: NOT
7544: IFFALSE 7548
// exit ;
7546: GO 7652
// j := 1 ;
7548: LD_ADDR_VAR 0 3
7552: PUSH
7553: LD_INT 1
7555: ST_TO_ADDR
// for i in behemothBuilders do
7556: LD_ADDR_VAR 0 2
7560: PUSH
7561: LD_EXP 70
7565: PUSH
7566: FOR_IN
7567: IFFALSE 7650
// begin if IsInUnit ( i ) then
7569: LD_VAR 0 2
7573: PPUSH
7574: CALL_OW 310
7578: IFFALSE 7589
// ComExitBuilding ( i ) ;
7580: LD_VAR 0 2
7584: PPUSH
7585: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7589: LD_VAR 0 2
7593: PPUSH
7594: LD_INT 37
7596: PPUSH
7597: LD_VAR 0 4
7601: PUSH
7602: LD_VAR 0 3
7606: ARRAY
7607: PUSH
7608: LD_INT 1
7610: ARRAY
7611: PPUSH
7612: LD_VAR 0 4
7616: PUSH
7617: LD_VAR 0 3
7621: ARRAY
7622: PUSH
7623: LD_INT 2
7625: ARRAY
7626: PPUSH
7627: LD_INT 0
7629: PPUSH
7630: CALL_OW 230
// j := j + 1 ;
7634: LD_ADDR_VAR 0 3
7638: PUSH
7639: LD_VAR 0 3
7643: PUSH
7644: LD_INT 1
7646: PLUS
7647: ST_TO_ADDR
// end ;
7648: GO 7566
7650: POP
7651: POP
// end ;
7652: LD_VAR 0 1
7656: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7657: LD_INT 24
7659: PPUSH
7660: LD_INT 30
7662: PUSH
7663: LD_INT 37
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: PPUSH
7670: CALL_OW 70
7674: IFFALSE 7687
7676: GO 7678
7678: DISABLE
// behemothUnderConstruct := true ;
7679: LD_ADDR_EXP 26
7683: PUSH
7684: LD_INT 1
7686: ST_TO_ADDR
7687: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7688: LD_INT 3
7690: PPUSH
7691: CALL 104292 0 1
7695: PUSH
7696: LD_INT 22
7698: PUSH
7699: LD_INT 3
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: PUSH
7706: LD_INT 30
7708: PUSH
7709: LD_INT 37
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: PPUSH
7720: CALL_OW 69
7724: NOT
7725: AND
7726: IFFALSE 7912
7728: GO 7730
7730: DISABLE
7731: LD_INT 0
7733: PPUSH
7734: PPUSH
// begin enable ;
7735: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7736: LD_ADDR_VAR 0 2
7740: PUSH
7741: LD_INT 3
7743: PPUSH
7744: CALL 104292 0 1
7748: ST_TO_ADDR
// for i in tmp do
7749: LD_ADDR_VAR 0 1
7753: PUSH
7754: LD_VAR 0 2
7758: PUSH
7759: FOR_IN
7760: IFFALSE 7910
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7762: LD_VAR 0 1
7766: PPUSH
7767: LD_INT 9
7769: PPUSH
7770: CALL_OW 308
7774: PUSH
7775: LD_VAR 0 1
7779: PPUSH
7780: CALL_OW 110
7784: PUSH
7785: LD_INT 2
7787: EQUAL
7788: NOT
7789: AND
7790: IFFALSE 7804
// SetTag ( i , 2 ) ;
7792: LD_VAR 0 1
7796: PPUSH
7797: LD_INT 2
7799: PPUSH
7800: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7804: LD_INT 81
7806: PUSH
7807: LD_INT 3
7809: PUSH
7810: EMPTY
7811: LIST
7812: LIST
7813: PUSH
7814: LD_INT 91
7816: PUSH
7817: LD_VAR 0 1
7821: PUSH
7822: LD_INT 12
7824: PUSH
7825: EMPTY
7826: LIST
7827: LIST
7828: LIST
7829: PUSH
7830: EMPTY
7831: LIST
7832: LIST
7833: PPUSH
7834: CALL_OW 69
7838: NOT
7839: PUSH
7840: LD_VAR 0 1
7844: PPUSH
7845: CALL_OW 110
7849: PUSH
7850: LD_INT 2
7852: EQUAL
7853: NOT
7854: AND
7855: IFFALSE 7874
// ComAgressiveMove ( i , 64 , 93 ) else
7857: LD_VAR 0 1
7861: PPUSH
7862: LD_INT 64
7864: PPUSH
7865: LD_INT 93
7867: PPUSH
7868: CALL_OW 114
7872: GO 7908
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7874: LD_VAR 0 1
7878: PPUSH
7879: LD_INT 81
7881: PUSH
7882: LD_INT 3
7884: PUSH
7885: EMPTY
7886: LIST
7887: LIST
7888: PPUSH
7889: CALL_OW 69
7893: PPUSH
7894: LD_VAR 0 1
7898: PPUSH
7899: CALL_OW 74
7903: PPUSH
7904: CALL_OW 115
// end ;
7908: GO 7759
7910: POP
7911: POP
// end ;
7912: PPOPN 2
7914: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
7915: LD_INT 0
7917: PPUSH
7918: PPUSH
7919: PPUSH
// result := [ ] ;
7920: LD_ADDR_VAR 0 2
7924: PUSH
7925: EMPTY
7926: ST_TO_ADDR
// uc_side := 6 ;
7927: LD_ADDR_OWVAR 20
7931: PUSH
7932: LD_INT 6
7934: ST_TO_ADDR
// uc_nation := 3 ;
7935: LD_ADDR_OWVAR 21
7939: PUSH
7940: LD_INT 3
7942: ST_TO_ADDR
// case strength of 1 :
7943: LD_VAR 0 1
7947: PUSH
7948: LD_INT 1
7950: DOUBLE
7951: EQUAL
7952: IFTRUE 7956
7954: GO 8094
7956: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
7957: LD_ADDR_VAR 0 3
7961: PUSH
7962: DOUBLE
7963: LD_INT 1
7965: DEC
7966: ST_TO_ADDR
7967: LD_INT 4
7969: PUSH
7970: LD_INT 5
7972: PUSH
7973: LD_INT 6
7975: PUSH
7976: EMPTY
7977: LIST
7978: LIST
7979: LIST
7980: PUSH
7981: LD_OWVAR 67
7985: ARRAY
7986: PUSH
7987: FOR_TO
7988: IFFALSE 8090
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
7990: LD_INT 22
7992: PUSH
7993: LD_INT 24
7995: PUSH
7996: EMPTY
7997: LIST
7998: LIST
7999: PUSH
8000: LD_VAR 0 3
8004: PUSH
8005: LD_INT 2
8007: MOD
8008: PUSH
8009: LD_INT 1
8011: PLUS
8012: ARRAY
8013: PPUSH
8014: LD_INT 1
8016: PUSH
8017: LD_INT 3
8019: PUSH
8020: EMPTY
8021: LIST
8022: LIST
8023: PUSH
8024: LD_INT 1
8026: PPUSH
8027: LD_INT 2
8029: PPUSH
8030: CALL_OW 12
8034: ARRAY
8035: PPUSH
8036: LD_INT 3
8038: PPUSH
8039: LD_INT 43
8041: PUSH
8042: LD_INT 44
8044: PUSH
8045: LD_INT 45
8047: PUSH
8048: EMPTY
8049: LIST
8050: LIST
8051: LIST
8052: PUSH
8053: LD_INT 1
8055: PPUSH
8056: LD_INT 3
8058: PPUSH
8059: CALL_OW 12
8063: ARRAY
8064: PPUSH
8065: LD_INT 80
8067: PPUSH
8068: CALL 68561 0 5
// result := result union CreateVehicle ;
8072: LD_ADDR_VAR 0 2
8076: PUSH
8077: LD_VAR 0 2
8081: PUSH
8082: CALL_OW 45
8086: UNION
8087: ST_TO_ADDR
// end ;
8088: GO 7987
8090: POP
8091: POP
// end ; 2 :
8092: GO 9038
8094: LD_INT 2
8096: DOUBLE
8097: EQUAL
8098: IFTRUE 8102
8100: GO 8258
8102: POP
// begin for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
8103: LD_ADDR_VAR 0 3
8107: PUSH
8108: DOUBLE
8109: LD_INT 1
8111: DEC
8112: ST_TO_ADDR
8113: LD_INT 6
8115: PUSH
8116: LD_INT 6
8118: PUSH
8119: LD_INT 7
8121: PUSH
8122: EMPTY
8123: LIST
8124: LIST
8125: LIST
8126: PUSH
8127: LD_OWVAR 67
8131: ARRAY
8132: PUSH
8133: FOR_TO
8134: IFFALSE 8254
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8136: LD_INT 22
8138: PUSH
8139: LD_INT 24
8141: PUSH
8142: LD_INT 24
8144: PUSH
8145: EMPTY
8146: LIST
8147: LIST
8148: LIST
8149: PUSH
8150: LD_VAR 0 3
8154: PUSH
8155: LD_INT 3
8157: MOD
8158: PUSH
8159: LD_INT 1
8161: PLUS
8162: ARRAY
8163: PPUSH
8164: LD_INT 1
8166: PUSH
8167: LD_INT 3
8169: PUSH
8170: EMPTY
8171: LIST
8172: LIST
8173: PUSH
8174: LD_INT 1
8176: PPUSH
8177: LD_INT 2
8179: PPUSH
8180: CALL_OW 12
8184: ARRAY
8185: PPUSH
8186: LD_INT 3
8188: PPUSH
8189: LD_INT 43
8191: PUSH
8192: LD_INT 44
8194: PUSH
8195: LD_INT 45
8197: PUSH
8198: LD_INT 44
8200: PUSH
8201: LD_INT 46
8203: PUSH
8204: LD_INT 46
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: LIST
8211: LIST
8212: LIST
8213: LIST
8214: PUSH
8215: LD_VAR 0 3
8219: PUSH
8220: LD_INT 6
8222: MOD
8223: PUSH
8224: LD_INT 1
8226: PLUS
8227: ARRAY
8228: PPUSH
8229: LD_INT 80
8231: PPUSH
8232: CALL 68561 0 5
// result := result union CreateVehicle ;
8236: LD_ADDR_VAR 0 2
8240: PUSH
8241: LD_VAR 0 2
8245: PUSH
8246: CALL_OW 45
8250: UNION
8251: ST_TO_ADDR
// end ;
8252: GO 8133
8254: POP
8255: POP
// end ; 3 :
8256: GO 9038
8258: LD_INT 3
8260: DOUBLE
8261: EQUAL
8262: IFTRUE 8266
8264: GO 8422
8266: POP
// begin for i = 1 to [ 6 , 7 , 8 ] [ Difficulty ] do
8267: LD_ADDR_VAR 0 3
8271: PUSH
8272: DOUBLE
8273: LD_INT 1
8275: DEC
8276: ST_TO_ADDR
8277: LD_INT 6
8279: PUSH
8280: LD_INT 7
8282: PUSH
8283: LD_INT 8
8285: PUSH
8286: EMPTY
8287: LIST
8288: LIST
8289: LIST
8290: PUSH
8291: LD_OWVAR 67
8295: ARRAY
8296: PUSH
8297: FOR_TO
8298: IFFALSE 8418
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8300: LD_INT 22
8302: PUSH
8303: LD_INT 24
8305: PUSH
8306: LD_INT 24
8308: PUSH
8309: EMPTY
8310: LIST
8311: LIST
8312: LIST
8313: PUSH
8314: LD_VAR 0 3
8318: PUSH
8319: LD_INT 3
8321: MOD
8322: PUSH
8323: LD_INT 1
8325: PLUS
8326: ARRAY
8327: PPUSH
8328: LD_INT 1
8330: PUSH
8331: LD_INT 3
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: PUSH
8338: LD_INT 1
8340: PPUSH
8341: LD_INT 2
8343: PPUSH
8344: CALL_OW 12
8348: ARRAY
8349: PPUSH
8350: LD_INT 3
8352: PPUSH
8353: LD_INT 43
8355: PUSH
8356: LD_INT 47
8358: PUSH
8359: LD_INT 45
8361: PUSH
8362: LD_INT 45
8364: PUSH
8365: LD_INT 46
8367: PUSH
8368: LD_INT 46
8370: PUSH
8371: EMPTY
8372: LIST
8373: LIST
8374: LIST
8375: LIST
8376: LIST
8377: LIST
8378: PUSH
8379: LD_VAR 0 3
8383: PUSH
8384: LD_INT 6
8386: MOD
8387: PUSH
8388: LD_INT 1
8390: PLUS
8391: ARRAY
8392: PPUSH
8393: LD_INT 80
8395: PPUSH
8396: CALL 68561 0 5
// result := result union CreateVehicle ;
8400: LD_ADDR_VAR 0 2
8404: PUSH
8405: LD_VAR 0 2
8409: PUSH
8410: CALL_OW 45
8414: UNION
8415: ST_TO_ADDR
// end ;
8416: GO 8297
8418: POP
8419: POP
// end ; 4 :
8420: GO 9038
8422: LD_INT 4
8424: DOUBLE
8425: EQUAL
8426: IFTRUE 8430
8428: GO 9037
8430: POP
// begin uc_nation := 3 ;
8431: LD_ADDR_OWVAR 21
8435: PUSH
8436: LD_INT 3
8438: ST_TO_ADDR
// for i = 1 to [ 7 , 8 , 9 ] [ Difficulty ] do
8439: LD_ADDR_VAR 0 3
8443: PUSH
8444: DOUBLE
8445: LD_INT 1
8447: DEC
8448: ST_TO_ADDR
8449: LD_INT 7
8451: PUSH
8452: LD_INT 8
8454: PUSH
8455: LD_INT 9
8457: PUSH
8458: EMPTY
8459: LIST
8460: LIST
8461: LIST
8462: PUSH
8463: LD_OWVAR 67
8467: ARRAY
8468: PUSH
8469: FOR_TO
8470: IFFALSE 8590
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8472: LD_INT 22
8474: PUSH
8475: LD_INT 24
8477: PUSH
8478: LD_INT 24
8480: PUSH
8481: EMPTY
8482: LIST
8483: LIST
8484: LIST
8485: PUSH
8486: LD_VAR 0 3
8490: PUSH
8491: LD_INT 3
8493: MOD
8494: PUSH
8495: LD_INT 1
8497: PLUS
8498: ARRAY
8499: PPUSH
8500: LD_INT 1
8502: PUSH
8503: LD_INT 3
8505: PUSH
8506: EMPTY
8507: LIST
8508: LIST
8509: PUSH
8510: LD_INT 1
8512: PPUSH
8513: LD_INT 2
8515: PPUSH
8516: CALL_OW 12
8520: ARRAY
8521: PPUSH
8522: LD_INT 3
8524: PPUSH
8525: LD_INT 45
8527: PUSH
8528: LD_INT 47
8530: PUSH
8531: LD_INT 47
8533: PUSH
8534: LD_INT 45
8536: PUSH
8537: LD_INT 46
8539: PUSH
8540: LD_INT 46
8542: PUSH
8543: EMPTY
8544: LIST
8545: LIST
8546: LIST
8547: LIST
8548: LIST
8549: LIST
8550: PUSH
8551: LD_VAR 0 3
8555: PUSH
8556: LD_INT 6
8558: MOD
8559: PUSH
8560: LD_INT 1
8562: PLUS
8563: ARRAY
8564: PPUSH
8565: LD_INT 80
8567: PPUSH
8568: CALL 68561 0 5
// result := result union CreateVehicle ;
8572: LD_ADDR_VAR 0 2
8576: PUSH
8577: LD_VAR 0 2
8581: PUSH
8582: CALL_OW 45
8586: UNION
8587: ST_TO_ADDR
// end ;
8588: GO 8469
8590: POP
8591: POP
// if not KappaStatus then
8592: LD_EXP 2
8596: NOT
8597: IFFALSE 8832
// begin uc_nation := 1 ;
8599: LD_ADDR_OWVAR 21
8603: PUSH
8604: LD_INT 1
8606: ST_TO_ADDR
// for i = 1 to 3 do
8607: LD_ADDR_VAR 0 3
8611: PUSH
8612: DOUBLE
8613: LD_INT 1
8615: DEC
8616: ST_TO_ADDR
8617: LD_INT 3
8619: PUSH
8620: FOR_TO
8621: IFFALSE 8757
// begin j := rand ( 0 , 1 ) ;
8623: LD_ADDR_VAR 0 4
8627: PUSH
8628: LD_INT 0
8630: PPUSH
8631: LD_INT 1
8633: PPUSH
8634: CALL_OW 12
8638: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8639: LD_INT 3
8641: PUSH
8642: LD_INT 5
8644: PUSH
8645: LD_INT 5
8647: PUSH
8648: LD_INT 4
8650: PUSH
8651: EMPTY
8652: LIST
8653: LIST
8654: LIST
8655: LIST
8656: PUSH
8657: LD_VAR 0 4
8661: PUSH
8662: LD_INT 1
8664: PPUSH
8665: LD_INT 3
8667: PPUSH
8668: CALL_OW 12
8672: PLUS
8673: ARRAY
8674: PPUSH
8675: LD_INT 1
8677: PUSH
8678: LD_INT 3
8680: PUSH
8681: EMPTY
8682: LIST
8683: LIST
8684: PUSH
8685: LD_INT 1
8687: PPUSH
8688: LD_INT 2
8690: PPUSH
8691: CALL_OW 12
8695: ARRAY
8696: PPUSH
8697: LD_INT 3
8699: PPUSH
8700: LD_INT 9
8702: PUSH
8703: LD_INT 7
8705: PUSH
8706: LD_INT 6
8708: PUSH
8709: EMPTY
8710: LIST
8711: LIST
8712: LIST
8713: PUSH
8714: LD_VAR 0 4
8718: PUSH
8719: LD_INT 1
8721: PPUSH
8722: LD_INT 2
8724: PPUSH
8725: CALL_OW 12
8729: PLUS
8730: ARRAY
8731: PPUSH
8732: LD_INT 85
8734: PPUSH
8735: CALL 68561 0 5
// result := result union CreateVehicle ;
8739: LD_ADDR_VAR 0 2
8743: PUSH
8744: LD_VAR 0 2
8748: PUSH
8749: CALL_OW 45
8753: UNION
8754: ST_TO_ADDR
// end ;
8755: GO 8620
8757: POP
8758: POP
// if vsevolodFirstAttack then
8759: LD_EXP 24
8763: IFFALSE 8830
// begin vsevolodFirstAttack := false ;
8765: LD_ADDR_EXP 24
8769: PUSH
8770: LD_INT 0
8772: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8773: LD_INT 5
8775: PPUSH
8776: LD_INT 3
8778: PPUSH
8779: LD_INT 1
8781: PPUSH
8782: LD_INT 6
8784: PPUSH
8785: LD_INT 100
8787: PPUSH
8788: CALL 68561 0 5
// sewiVeh := CreateVehicle ;
8792: LD_ADDR_EXP 68
8796: PUSH
8797: CALL_OW 45
8801: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8802: LD_EXP 68
8806: PPUSH
8807: LD_INT 1
8809: PPUSH
8810: CALL_OW 242
// result := result union sewiVeh ;
8814: LD_ADDR_VAR 0 2
8818: PUSH
8819: LD_VAR 0 2
8823: PUSH
8824: LD_EXP 68
8828: UNION
8829: ST_TO_ADDR
// end ; end else
8830: GO 9035
// if vsevolodFirstAttack then
8832: LD_EXP 24
8836: IFFALSE 9035
// begin vsevolodFirstAttack := false ;
8838: LD_ADDR_EXP 24
8842: PUSH
8843: LD_INT 0
8845: ST_TO_ADDR
// uc_nation := 3 ;
8846: LD_ADDR_OWVAR 21
8850: PUSH
8851: LD_INT 3
8853: ST_TO_ADDR
// for i = 1 to 3 do
8854: LD_ADDR_VAR 0 3
8858: PUSH
8859: DOUBLE
8860: LD_INT 1
8862: DEC
8863: ST_TO_ADDR
8864: LD_INT 3
8866: PUSH
8867: FOR_TO
8868: IFFALSE 8976
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
8870: LD_INT 22
8872: PUSH
8873: LD_INT 24
8875: PUSH
8876: LD_INT 24
8878: PUSH
8879: EMPTY
8880: LIST
8881: LIST
8882: LIST
8883: PUSH
8884: LD_VAR 0 3
8888: PUSH
8889: LD_INT 3
8891: MOD
8892: PUSH
8893: LD_INT 1
8895: PLUS
8896: ARRAY
8897: PPUSH
8898: LD_INT 1
8900: PUSH
8901: LD_INT 3
8903: PUSH
8904: EMPTY
8905: LIST
8906: LIST
8907: PUSH
8908: LD_INT 1
8910: PPUSH
8911: LD_INT 2
8913: PPUSH
8914: CALL_OW 12
8918: ARRAY
8919: PPUSH
8920: LD_INT 3
8922: PPUSH
8923: LD_INT 45
8925: PUSH
8926: LD_INT 47
8928: PUSH
8929: LD_INT 47
8931: PUSH
8932: EMPTY
8933: LIST
8934: LIST
8935: LIST
8936: PUSH
8937: LD_VAR 0 3
8941: PUSH
8942: LD_INT 3
8944: MOD
8945: PUSH
8946: LD_INT 1
8948: PLUS
8949: ARRAY
8950: PPUSH
8951: LD_INT 80
8953: PPUSH
8954: CALL 68561 0 5
// result := result union CreateVehicle ;
8958: LD_ADDR_VAR 0 2
8962: PUSH
8963: LD_VAR 0 2
8967: PUSH
8968: CALL_OW 45
8972: UNION
8973: ST_TO_ADDR
// end ;
8974: GO 8867
8976: POP
8977: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
8978: LD_INT 24
8980: PPUSH
8981: LD_INT 3
8983: PPUSH
8984: LD_INT 1
8986: PPUSH
8987: LD_INT 47
8989: PPUSH
8990: LD_INT 100
8992: PPUSH
8993: CALL 68561 0 5
// sewiVeh := CreateVehicle ;
8997: LD_ADDR_EXP 68
9001: PUSH
9002: CALL_OW 45
9006: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9007: LD_EXP 68
9011: PPUSH
9012: LD_INT 1
9014: PPUSH
9015: CALL_OW 242
// result := result union sewiVeh ;
9019: LD_ADDR_VAR 0 2
9023: PUSH
9024: LD_VAR 0 2
9028: PUSH
9029: LD_EXP 68
9033: UNION
9034: ST_TO_ADDR
// end ; end ; end ;
9035: GO 9038
9037: POP
// end ;
9038: LD_VAR 0 2
9042: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9043: LD_EXP 16
9047: IFFALSE 9795
9049: GO 9051
9051: DISABLE
9052: LD_INT 0
9054: PPUSH
9055: PPUSH
9056: PPUSH
9057: PPUSH
9058: PPUSH
9059: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9060: LD_ADDR_VAR 0 4
9064: PUSH
9065: LD_INT 11
9067: PUSH
9068: LD_INT 12
9070: PUSH
9071: EMPTY
9072: LIST
9073: LIST
9074: ST_TO_ADDR
// time := [ 4 4$00 , 3 3$30 , 3 3$10 ] [ Difficulty ] ;
9075: LD_ADDR_VAR 0 3
9079: PUSH
9080: LD_INT 8400
9082: PUSH
9083: LD_INT 7350
9085: PUSH
9086: LD_INT 6650
9088: PUSH
9089: EMPTY
9090: LIST
9091: LIST
9092: LIST
9093: PUSH
9094: LD_OWVAR 67
9098: ARRAY
9099: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9100: LD_ADDR_VAR 0 6
9104: PUSH
9105: LD_INT 70
9107: PUSH
9108: LD_INT 118
9110: PUSH
9111: EMPTY
9112: LIST
9113: LIST
9114: PUSH
9115: LD_INT 78
9117: PUSH
9118: LD_INT 31
9120: PUSH
9121: EMPTY
9122: LIST
9123: LIST
9124: PUSH
9125: EMPTY
9126: LIST
9127: LIST
9128: ST_TO_ADDR
// repeat if missionStage = 2 then
9129: LD_EXP 15
9133: PUSH
9134: LD_INT 2
9136: EQUAL
9137: IFFALSE 9148
// wait ( 1 1$30 ) else
9139: LD_INT 3150
9141: PPUSH
9142: CALL_OW 67
9146: GO 9157
// wait ( time ) ;
9148: LD_VAR 0 3
9152: PPUSH
9153: CALL_OW 67
// if missionStage = 6 then
9157: LD_EXP 15
9161: PUSH
9162: LD_INT 6
9164: EQUAL
9165: IFFALSE 9193
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9167: LD_INT 51
9169: PPUSH
9170: LD_INT 6
9172: PPUSH
9173: LD_INT 2
9175: PPUSH
9176: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9180: LD_INT 57
9182: PPUSH
9183: LD_INT 6
9185: PPUSH
9186: LD_INT 2
9188: PPUSH
9189: CALL_OW 322
// end ; if missionStage = 8 then
9193: LD_EXP 15
9197: PUSH
9198: LD_INT 8
9200: EQUAL
9201: IFFALSE 9229
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9203: LD_INT 52
9205: PPUSH
9206: LD_INT 6
9208: PPUSH
9209: LD_INT 2
9211: PPUSH
9212: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9216: LD_INT 58
9218: PPUSH
9219: LD_INT 6
9221: PPUSH
9222: LD_INT 2
9224: PPUSH
9225: CALL_OW 322
// end ; if missionStage = 10 then
9229: LD_EXP 15
9233: PUSH
9234: LD_INT 10
9236: EQUAL
9237: IFFALSE 9265
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9239: LD_INT 53
9241: PPUSH
9242: LD_INT 6
9244: PPUSH
9245: LD_INT 2
9247: PPUSH
9248: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9252: LD_INT 59
9254: PPUSH
9255: LD_INT 6
9257: PPUSH
9258: LD_INT 2
9260: PPUSH
9261: CALL_OW 322
// end ; if activeAttacks then
9265: LD_EXP 16
9269: IFFALSE 9789
// begin if missionStage = 2 then
9271: LD_EXP 15
9275: PUSH
9276: LD_INT 2
9278: EQUAL
9279: IFFALSE 9289
// strength := 1 ;
9281: LD_ADDR_VAR 0 5
9285: PUSH
9286: LD_INT 1
9288: ST_TO_ADDR
// if missionStage > 2 then
9289: LD_EXP 15
9293: PUSH
9294: LD_INT 2
9296: GREATER
9297: IFFALSE 9307
// strength := 2 ;
9299: LD_ADDR_VAR 0 5
9303: PUSH
9304: LD_INT 2
9306: ST_TO_ADDR
// if missionStage > 6 then
9307: LD_EXP 15
9311: PUSH
9312: LD_INT 6
9314: GREATER
9315: IFFALSE 9325
// strength := 3 ;
9317: LD_ADDR_VAR 0 5
9321: PUSH
9322: LD_INT 3
9324: ST_TO_ADDR
// if missionStage > 10 then
9325: LD_EXP 15
9329: PUSH
9330: LD_INT 10
9332: GREATER
9333: IFFALSE 9343
// strength := 4 ;
9335: LD_ADDR_VAR 0 5
9339: PUSH
9340: LD_INT 4
9342: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9343: LD_ADDR_VAR 0 2
9347: PUSH
9348: LD_VAR 0 5
9352: PPUSH
9353: CALL 7915 0 1
9357: ST_TO_ADDR
// for i in tmp do
9358: LD_ADDR_VAR 0 1
9362: PUSH
9363: LD_VAR 0 2
9367: PUSH
9368: FOR_IN
9369: IFFALSE 9469
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9371: LD_VAR 0 1
9375: PPUSH
9376: LD_VAR 0 4
9380: PUSH
9381: LD_INT 1
9383: PPUSH
9384: LD_INT 2
9386: PPUSH
9387: CALL_OW 12
9391: ARRAY
9392: PPUSH
9393: LD_INT 0
9395: PPUSH
9396: CALL_OW 49
// if i = sewiVeh then
9400: LD_VAR 0 1
9404: PUSH
9405: LD_EXP 68
9409: EQUAL
9410: IFFALSE 9445
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9412: LD_ADDR_EXP 67
9416: PUSH
9417: LD_STRING Vsevolod
9419: PPUSH
9420: LD_INT 0
9422: PPUSH
9423: LD_STRING 
9425: PPUSH
9426: CALL 61928 0 3
9430: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9431: LD_EXP 67
9435: PPUSH
9436: LD_VAR 0 1
9440: PPUSH
9441: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9445: LD_VAR 0 1
9449: PPUSH
9450: LD_INT 111
9452: PPUSH
9453: LD_INT 197
9455: PPUSH
9456: CALL_OW 111
// wait ( 0 0$2 ) ;
9460: LD_INT 70
9462: PPUSH
9463: CALL_OW 67
// end ;
9467: GO 9368
9469: POP
9470: POP
// repeat wait ( 0 0$1 ) ;
9471: LD_INT 35
9473: PPUSH
9474: CALL_OW 67
// for i in tmp do
9478: LD_ADDR_VAR 0 1
9482: PUSH
9483: LD_VAR 0 2
9487: PUSH
9488: FOR_IN
9489: IFFALSE 9770
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9491: LD_INT 81
9493: PUSH
9494: LD_INT 6
9496: PUSH
9497: EMPTY
9498: LIST
9499: LIST
9500: PUSH
9501: LD_INT 91
9503: PUSH
9504: LD_VAR 0 1
9508: PUSH
9509: LD_INT 12
9511: PUSH
9512: EMPTY
9513: LIST
9514: LIST
9515: LIST
9516: PUSH
9517: EMPTY
9518: LIST
9519: LIST
9520: PPUSH
9521: CALL_OW 69
9525: IFFALSE 9583
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_distxy , i , 12 ] ] ) , i ) ) else
9527: LD_VAR 0 1
9531: PPUSH
9532: LD_INT 81
9534: PUSH
9535: LD_INT 6
9537: PUSH
9538: EMPTY
9539: LIST
9540: LIST
9541: PUSH
9542: LD_INT 92
9544: PUSH
9545: LD_VAR 0 1
9549: PUSH
9550: LD_INT 12
9552: PUSH
9553: EMPTY
9554: LIST
9555: LIST
9556: LIST
9557: PUSH
9558: EMPTY
9559: LIST
9560: LIST
9561: PPUSH
9562: CALL_OW 69
9566: PPUSH
9567: LD_VAR 0 1
9571: PPUSH
9572: CALL_OW 74
9576: PPUSH
9577: CALL_OW 115
9581: GO 9768
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9583: LD_INT 9
9585: PPUSH
9586: LD_INT 81
9588: PUSH
9589: LD_INT 6
9591: PUSH
9592: EMPTY
9593: LIST
9594: LIST
9595: PPUSH
9596: CALL_OW 70
9600: IFFALSE 9734
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9602: LD_VAR 0 1
9606: PPUSH
9607: LD_VAR 0 6
9611: PUSH
9612: LD_INT 1
9614: ARRAY
9615: PUSH
9616: LD_INT 1
9618: ARRAY
9619: PPUSH
9620: LD_VAR 0 6
9624: PUSH
9625: LD_INT 1
9627: ARRAY
9628: PUSH
9629: LD_INT 2
9631: ARRAY
9632: PPUSH
9633: CALL_OW 297
9637: PUSH
9638: LD_INT 10
9640: GREATER
9641: PUSH
9642: LD_VAR 0 1
9646: PPUSH
9647: LD_INT 9
9649: PPUSH
9650: CALL_OW 308
9654: NOT
9655: AND
9656: IFFALSE 9695
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9658: LD_VAR 0 1
9662: PPUSH
9663: LD_VAR 0 6
9667: PUSH
9668: LD_INT 1
9670: ARRAY
9671: PUSH
9672: LD_INT 1
9674: ARRAY
9675: PPUSH
9676: LD_VAR 0 6
9680: PUSH
9681: LD_INT 1
9683: ARRAY
9684: PUSH
9685: LD_INT 2
9687: ARRAY
9688: PPUSH
9689: CALL_OW 114
9693: GO 9732
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9695: LD_VAR 0 1
9699: PPUSH
9700: LD_INT 9
9702: PPUSH
9703: LD_INT 81
9705: PUSH
9706: LD_INT 6
9708: PUSH
9709: EMPTY
9710: LIST
9711: LIST
9712: PPUSH
9713: CALL_OW 70
9717: PPUSH
9718: LD_VAR 0 1
9722: PPUSH
9723: CALL_OW 74
9727: PPUSH
9728: CALL_OW 115
// end else
9732: GO 9768
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9734: LD_VAR 0 1
9738: PPUSH
9739: LD_INT 81
9741: PUSH
9742: LD_INT 6
9744: PUSH
9745: EMPTY
9746: LIST
9747: LIST
9748: PPUSH
9749: CALL_OW 69
9753: PPUSH
9754: LD_VAR 0 1
9758: PPUSH
9759: CALL_OW 74
9763: PPUSH
9764: CALL_OW 115
// end ;
9768: GO 9488
9770: POP
9771: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9772: LD_INT 22
9774: PUSH
9775: LD_INT 6
9777: PUSH
9778: EMPTY
9779: LIST
9780: LIST
9781: PPUSH
9782: CALL_OW 69
9786: NOT
9787: IFFALSE 9471
// end ; until russianDestroyed ;
9789: LD_EXP 21
9793: IFFALSE 9129
// end ;
9795: PPOPN 6
9797: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9798: LD_EXP 21
9802: NOT
9803: PUSH
9804: LD_EXP 15
9808: PUSH
9809: LD_INT 6
9811: GREATEREQUAL
9812: AND
9813: PUSH
9814: LD_INT 2
9816: PPUSH
9817: LD_INT 1
9819: PPUSH
9820: CALL 57351 0 2
9824: NOT
9825: AND
9826: IFFALSE 10782
9828: GO 9830
9830: DISABLE
9831: LD_INT 0
9833: PPUSH
9834: PPUSH
9835: PPUSH
9836: PPUSH
// begin enable ;
9837: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9838: LD_INT 22
9840: PUSH
9841: LD_INT 3
9843: PUSH
9844: EMPTY
9845: LIST
9846: LIST
9847: PUSH
9848: LD_INT 30
9850: PUSH
9851: LD_INT 3
9853: PUSH
9854: EMPTY
9855: LIST
9856: LIST
9857: PUSH
9858: EMPTY
9859: LIST
9860: LIST
9861: PPUSH
9862: CALL_OW 69
9866: NOT
9867: IFFALSE 9871
// exit ;
9869: GO 10782
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9871: LD_ADDR_VAR 0 4
9875: PUSH
9876: LD_INT 22
9878: PUSH
9879: LD_INT 3
9881: PUSH
9882: EMPTY
9883: LIST
9884: LIST
9885: PUSH
9886: LD_INT 30
9888: PUSH
9889: LD_INT 34
9891: PUSH
9892: EMPTY
9893: LIST
9894: LIST
9895: PUSH
9896: EMPTY
9897: LIST
9898: LIST
9899: PPUSH
9900: CALL_OW 69
9904: ST_TO_ADDR
// if Prob ( 40 ) then
9905: LD_INT 40
9907: PPUSH
9908: CALL_OW 13
9912: IFFALSE 10039
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9914: LD_INT 2
9916: PPUSH
9917: LD_INT 22
9919: PUSH
9920: LD_INT 3
9922: PUSH
9923: LD_INT 3
9925: PUSH
9926: LD_INT 49
9928: PUSH
9929: EMPTY
9930: LIST
9931: LIST
9932: LIST
9933: LIST
9934: PUSH
9935: LD_INT 22
9937: PUSH
9938: LD_INT 3
9940: PUSH
9941: LD_INT 3
9943: PUSH
9944: LD_INT 49
9946: PUSH
9947: EMPTY
9948: LIST
9949: LIST
9950: LIST
9951: LIST
9952: PUSH
9953: LD_INT 22
9955: PUSH
9956: LD_INT 3
9958: PUSH
9959: LD_INT 3
9961: PUSH
9962: LD_INT 49
9964: PUSH
9965: EMPTY
9966: LIST
9967: LIST
9968: LIST
9969: LIST
9970: PUSH
9971: LD_INT 24
9973: PUSH
9974: LD_INT 3
9976: PUSH
9977: LD_INT 3
9979: PUSH
9980: LD_INT 46
9982: PUSH
9983: EMPTY
9984: LIST
9985: LIST
9986: LIST
9987: LIST
9988: PUSH
9989: LD_INT 24
9991: PUSH
9992: LD_INT 3
9994: PUSH
9995: LD_INT 3
9997: PUSH
9998: LD_INT 46
10000: PUSH
10001: EMPTY
10002: LIST
10003: LIST
10004: LIST
10005: LIST
10006: PUSH
10007: LD_INT 24
10009: PUSH
10010: LD_INT 3
10012: PUSH
10013: LD_INT 3
10015: PUSH
10016: LD_INT 46
10018: PUSH
10019: EMPTY
10020: LIST
10021: LIST
10022: LIST
10023: LIST
10024: PUSH
10025: EMPTY
10026: LIST
10027: LIST
10028: LIST
10029: LIST
10030: LIST
10031: LIST
10032: PPUSH
10033: CALL 55996 0 2
// end else
10037: GO 10162
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10039: LD_INT 2
10041: PPUSH
10042: LD_INT 24
10044: PUSH
10045: LD_INT 3
10047: PUSH
10048: LD_INT 3
10050: PUSH
10051: LD_INT 47
10053: PUSH
10054: EMPTY
10055: LIST
10056: LIST
10057: LIST
10058: LIST
10059: PUSH
10060: LD_INT 24
10062: PUSH
10063: LD_INT 3
10065: PUSH
10066: LD_INT 3
10068: PUSH
10069: LD_INT 47
10071: PUSH
10072: EMPTY
10073: LIST
10074: LIST
10075: LIST
10076: LIST
10077: PUSH
10078: LD_INT 24
10080: PUSH
10081: LD_INT 3
10083: PUSH
10084: LD_INT 3
10086: PUSH
10087: LD_INT 47
10089: PUSH
10090: EMPTY
10091: LIST
10092: LIST
10093: LIST
10094: LIST
10095: PUSH
10096: LD_INT 24
10098: PUSH
10099: LD_INT 3
10101: PUSH
10102: LD_INT 3
10104: PUSH
10105: LD_INT 46
10107: PUSH
10108: EMPTY
10109: LIST
10110: LIST
10111: LIST
10112: LIST
10113: PUSH
10114: LD_INT 24
10116: PUSH
10117: LD_INT 3
10119: PUSH
10120: LD_INT 3
10122: PUSH
10123: LD_INT 46
10125: PUSH
10126: EMPTY
10127: LIST
10128: LIST
10129: LIST
10130: LIST
10131: PUSH
10132: LD_INT 24
10134: PUSH
10135: LD_INT 3
10137: PUSH
10138: LD_INT 3
10140: PUSH
10141: LD_INT 46
10143: PUSH
10144: EMPTY
10145: LIST
10146: LIST
10147: LIST
10148: LIST
10149: PUSH
10150: EMPTY
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: LIST
10156: LIST
10157: PPUSH
10158: CALL 55996 0 2
// end ; if Difficulty > 1 then
10162: LD_OWVAR 67
10166: PUSH
10167: LD_INT 1
10169: GREATER
10170: IFFALSE 10200
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10172: LD_INT 2
10174: PPUSH
10175: LD_INT 24
10177: PUSH
10178: LD_INT 3
10180: PUSH
10181: LD_INT 3
10183: PUSH
10184: LD_INT 47
10186: PUSH
10187: EMPTY
10188: LIST
10189: LIST
10190: LIST
10191: LIST
10192: PUSH
10193: EMPTY
10194: LIST
10195: PPUSH
10196: CALL 55996 0 2
// repeat wait ( 0 0$1 ) ;
10200: LD_INT 35
10202: PPUSH
10203: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10207: LD_INT 2
10209: PPUSH
10210: LD_INT 1
10212: PPUSH
10213: CALL 57351 0 2
10217: PUSH
10218: LD_INT 6
10220: PUSH
10221: LD_INT 7
10223: PUSH
10224: LD_INT 7
10226: PUSH
10227: EMPTY
10228: LIST
10229: LIST
10230: LIST
10231: PUSH
10232: LD_OWVAR 67
10236: ARRAY
10237: GREATEREQUAL
10238: IFFALSE 10200
// wait ( 0 0$30 ) ;
10240: LD_INT 1050
10242: PPUSH
10243: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10247: LD_ADDR_VAR 0 2
10251: PUSH
10252: LD_INT 2
10254: PPUSH
10255: LD_INT 1
10257: PPUSH
10258: CALL 57351 0 2
10262: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10263: LD_ADDR_EXP 118
10267: PUSH
10268: LD_EXP 118
10272: PPUSH
10273: LD_INT 2
10275: PPUSH
10276: LD_EXP 118
10280: PUSH
10281: LD_INT 2
10283: ARRAY
10284: PUSH
10285: LD_VAR 0 2
10289: DIFF
10290: PPUSH
10291: CALL_OW 1
10295: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10296: LD_ADDR_VAR 0 3
10300: PUSH
10301: LD_INT 0
10303: PPUSH
10304: LD_INT 1
10306: PPUSH
10307: CALL_OW 12
10311: ST_TO_ADDR
// if target then
10312: LD_VAR 0 3
10316: IFFALSE 10444
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10318: LD_ADDR_VAR 0 2
10322: PUSH
10323: LD_VAR 0 2
10327: PPUSH
10328: LD_INT 24
10330: PUSH
10331: LD_INT 250
10333: PUSH
10334: EMPTY
10335: LIST
10336: LIST
10337: PPUSH
10338: CALL_OW 72
10342: ST_TO_ADDR
// for i in tmp do
10343: LD_ADDR_VAR 0 1
10347: PUSH
10348: LD_VAR 0 2
10352: PUSH
10353: FOR_IN
10354: IFFALSE 10394
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10356: LD_VAR 0 1
10360: PPUSH
10361: LD_INT 139
10363: PPUSH
10364: LD_INT 89
10366: PPUSH
10367: CALL_OW 297
10371: PUSH
10372: LD_INT 9
10374: GREATER
10375: IFFALSE 10392
// ComMoveXY ( i , 139 , 89 ) ;
10377: LD_VAR 0 1
10381: PPUSH
10382: LD_INT 139
10384: PPUSH
10385: LD_INT 89
10387: PPUSH
10388: CALL_OW 111
10392: GO 10353
10394: POP
10395: POP
// wait ( 0 0$1 ) ;
10396: LD_INT 35
10398: PPUSH
10399: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10403: LD_VAR 0 2
10407: PPUSH
10408: LD_INT 92
10410: PUSH
10411: LD_INT 139
10413: PUSH
10414: LD_INT 89
10416: PUSH
10417: LD_INT 9
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: LIST
10424: LIST
10425: PPUSH
10426: CALL_OW 72
10430: PUSH
10431: LD_VAR 0 2
10435: PUSH
10436: LD_INT 1
10438: MINUS
10439: GREATEREQUAL
10440: IFFALSE 10318
// end else
10442: GO 10586
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10444: LD_VAR 0 2
10448: PPUSH
10449: LD_VAR 0 4
10453: PUSH
10454: LD_INT 1
10456: ARRAY
10457: PPUSH
10458: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10462: LD_ADDR_VAR 0 2
10466: PUSH
10467: LD_VAR 0 2
10471: PPUSH
10472: LD_INT 24
10474: PUSH
10475: LD_INT 250
10477: PUSH
10478: EMPTY
10479: LIST
10480: LIST
10481: PPUSH
10482: CALL_OW 72
10486: ST_TO_ADDR
// for i in tmp do
10487: LD_ADDR_VAR 0 1
10491: PUSH
10492: LD_VAR 0 2
10496: PUSH
10497: FOR_IN
10498: IFFALSE 10538
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10500: LD_VAR 0 1
10504: PPUSH
10505: LD_INT 124
10507: PPUSH
10508: LD_INT 139
10510: PPUSH
10511: CALL_OW 297
10515: PUSH
10516: LD_INT 9
10518: GREATER
10519: IFFALSE 10536
// ComMoveXY ( i , 124 , 139 ) ;
10521: LD_VAR 0 1
10525: PPUSH
10526: LD_INT 124
10528: PPUSH
10529: LD_INT 139
10531: PPUSH
10532: CALL_OW 111
10536: GO 10497
10538: POP
10539: POP
// wait ( 0 0$1 ) ;
10540: LD_INT 35
10542: PPUSH
10543: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10547: LD_VAR 0 2
10551: PPUSH
10552: LD_INT 92
10554: PUSH
10555: LD_INT 124
10557: PUSH
10558: LD_INT 139
10560: PUSH
10561: LD_INT 9
10563: PUSH
10564: EMPTY
10565: LIST
10566: LIST
10567: LIST
10568: LIST
10569: PPUSH
10570: CALL_OW 72
10574: PUSH
10575: LD_VAR 0 2
10579: PUSH
10580: LD_INT 1
10582: MINUS
10583: GREATEREQUAL
10584: IFFALSE 10462
// end ; repeat wait ( 0 0$1 ) ;
10586: LD_INT 35
10588: PPUSH
10589: CALL_OW 67
// for i in tmp do
10593: LD_ADDR_VAR 0 1
10597: PUSH
10598: LD_VAR 0 2
10602: PUSH
10603: FOR_IN
10604: IFFALSE 10773
// begin if GetLives ( i ) > 251 then
10606: LD_VAR 0 1
10610: PPUSH
10611: CALL_OW 256
10615: PUSH
10616: LD_INT 251
10618: GREATER
10619: IFFALSE 10744
// begin if GetWeapon ( i ) = ru_time_lapser then
10621: LD_VAR 0 1
10625: PPUSH
10626: CALL_OW 264
10630: PUSH
10631: LD_INT 49
10633: EQUAL
10634: IFFALSE 10690
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10636: LD_VAR 0 1
10640: PPUSH
10641: LD_INT 2
10643: PUSH
10644: LD_INT 22
10646: PUSH
10647: LD_INT 1
10649: PUSH
10650: EMPTY
10651: LIST
10652: LIST
10653: PUSH
10654: LD_INT 22
10656: PUSH
10657: LD_INT 8
10659: PUSH
10660: EMPTY
10661: LIST
10662: LIST
10663: PUSH
10664: EMPTY
10665: LIST
10666: LIST
10667: LIST
10668: PPUSH
10669: CALL_OW 69
10673: PPUSH
10674: LD_VAR 0 1
10678: PPUSH
10679: CALL_OW 74
10683: PPUSH
10684: CALL_OW 112
10688: GO 10742
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10690: LD_VAR 0 1
10694: PPUSH
10695: LD_INT 2
10697: PUSH
10698: LD_INT 22
10700: PUSH
10701: LD_INT 1
10703: PUSH
10704: EMPTY
10705: LIST
10706: LIST
10707: PUSH
10708: LD_INT 22
10710: PUSH
10711: LD_INT 8
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: PUSH
10718: EMPTY
10719: LIST
10720: LIST
10721: LIST
10722: PPUSH
10723: CALL_OW 69
10727: PPUSH
10728: LD_VAR 0 1
10732: PPUSH
10733: CALL_OW 74
10737: PPUSH
10738: CALL_OW 115
// end else
10742: GO 10771
// if IsDead ( i ) then
10744: LD_VAR 0 1
10748: PPUSH
10749: CALL_OW 301
10753: IFFALSE 10771
// tmp := tmp diff i ;
10755: LD_ADDR_VAR 0 2
10759: PUSH
10760: LD_VAR 0 2
10764: PUSH
10765: LD_VAR 0 1
10769: DIFF
10770: ST_TO_ADDR
// end ;
10771: GO 10603
10773: POP
10774: POP
// until not tmp ;
10775: LD_VAR 0 2
10779: NOT
10780: IFFALSE 10586
// end ; end_of_file
10782: PPOPN 4
10784: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10785: LD_INT 0
10787: PPUSH
10788: PPUSH
10789: PPUSH
10790: PPUSH
10791: PPUSH
10792: PPUSH
// side := 7 ;
10793: LD_ADDR_VAR 0 5
10797: PUSH
10798: LD_INT 7
10800: ST_TO_ADDR
// uc_side := side ;
10801: LD_ADDR_OWVAR 20
10805: PUSH
10806: LD_VAR 0 5
10810: ST_TO_ADDR
// uc_nation := 1 ;
10811: LD_ADDR_OWVAR 21
10815: PUSH
10816: LD_INT 1
10818: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10819: LD_ADDR_VAR 0 2
10823: PUSH
10824: LD_INT 22
10826: PUSH
10827: LD_VAR 0 5
10831: PUSH
10832: EMPTY
10833: LIST
10834: LIST
10835: PUSH
10836: LD_INT 21
10838: PUSH
10839: LD_INT 3
10841: PUSH
10842: EMPTY
10843: LIST
10844: LIST
10845: PUSH
10846: EMPTY
10847: LIST
10848: LIST
10849: PPUSH
10850: CALL_OW 69
10854: PUSH
10855: FOR_IN
10856: IFFALSE 10872
// SetBLevel ( i , 10 ) ;
10858: LD_VAR 0 2
10862: PPUSH
10863: LD_INT 10
10865: PPUSH
10866: CALL_OW 241
10870: GO 10855
10872: POP
10873: POP
// base := GetBase ( al_depot ) ;
10874: LD_ADDR_VAR 0 4
10878: PUSH
10879: LD_INT 2
10881: PPUSH
10882: CALL_OW 274
10886: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
10887: LD_ADDR_VAR 0 6
10891: PUSH
10892: LD_INT 22
10894: PUSH
10895: LD_VAR 0 5
10899: PUSH
10900: EMPTY
10901: LIST
10902: LIST
10903: PUSH
10904: LD_INT 30
10906: PUSH
10907: LD_INT 34
10909: PUSH
10910: EMPTY
10911: LIST
10912: LIST
10913: PUSH
10914: EMPTY
10915: LIST
10916: LIST
10917: PPUSH
10918: CALL_OW 69
10922: ST_TO_ADDR
// if teleport then
10923: LD_VAR 0 6
10927: IFFALSE 10948
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
10929: LD_VAR 0 6
10933: PUSH
10934: LD_INT 1
10936: ARRAY
10937: PPUSH
10938: LD_INT 262
10940: PPUSH
10941: LD_INT 119
10943: PPUSH
10944: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
10948: LD_VAR 0 4
10952: PPUSH
10953: LD_INT 1
10955: PPUSH
10956: LD_INT 19500
10958: PPUSH
10959: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
10963: LD_VAR 0 4
10967: PPUSH
10968: LD_INT 2
10970: PPUSH
10971: LD_INT 200
10973: PPUSH
10974: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
10978: LD_VAR 0 4
10982: PPUSH
10983: LD_INT 3
10985: PPUSH
10986: LD_INT 650
10988: PPUSH
10989: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
10993: LD_ADDR_EXP 71
10997: PUSH
10998: LD_STRING Roth
11000: PPUSH
11001: CALL_OW 25
11005: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11006: LD_ADDR_EXP 72
11010: PUSH
11011: LD_STRING Simms
11013: PPUSH
11014: LD_EXP 1
11018: NOT
11019: PPUSH
11020: LD_STRING 10c_
11022: PPUSH
11023: CALL 61928 0 3
11027: ST_TO_ADDR
// if not Simms then
11028: LD_EXP 72
11032: NOT
11033: IFFALSE 11063
// begin uc_nation := 1 ;
11035: LD_ADDR_OWVAR 21
11039: PUSH
11040: LD_INT 1
11042: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11043: LD_INT 2
11045: PPUSH
11046: LD_INT 10
11048: PPUSH
11049: CALL_OW 384
// Simms := CreateHuman ;
11053: LD_ADDR_EXP 72
11057: PUSH
11058: CALL_OW 44
11062: ST_TO_ADDR
// end ; uc_nation := 3 ;
11063: LD_ADDR_OWVAR 21
11067: PUSH
11068: LD_INT 3
11070: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11071: LD_ADDR_EXP 73
11075: PUSH
11076: LD_STRING Kirilenkova
11078: PPUSH
11079: CALL_OW 25
11083: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11084: LD_ADDR_EXP 87
11088: PUSH
11089: LD_STRING Oblukov
11091: PPUSH
11092: CALL_OW 25
11096: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11097: LD_ADDR_EXP 74
11101: PUSH
11102: LD_STRING Dolgov
11104: PPUSH
11105: CALL_OW 25
11109: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11110: LD_ADDR_EXP 75
11114: PUSH
11115: LD_STRING Petrosyan
11117: PPUSH
11118: CALL_OW 25
11122: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11123: LD_ADDR_EXP 86
11127: PUSH
11128: LD_STRING Scholtze
11130: PPUSH
11131: CALL_OW 25
11135: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11136: LD_ADDR_EXP 85
11140: PUSH
11141: LD_STRING Kapitsova
11143: PPUSH
11144: CALL_OW 25
11148: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11149: LD_ADDR_EXP 76
11153: PUSH
11154: LD_STRING Petrovova
11156: PPUSH
11157: CALL_OW 25
11161: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11162: LD_ADDR_EXP 77
11166: PUSH
11167: LD_STRING Kuzmov
11169: PPUSH
11170: CALL_OW 25
11174: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11175: LD_ADDR_EXP 84
11179: PUSH
11180: LD_STRING Karamazov
11182: PPUSH
11183: CALL_OW 25
11187: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11188: LD_STRING 13_Lipshchin_1
11190: PPUSH
11191: LD_INT 0
11193: PPUSH
11194: CALL_OW 30
11198: IFFALSE 11213
// Lipshchin := NewCharacter ( Lipshchin ) ;
11200: LD_ADDR_EXP 78
11204: PUSH
11205: LD_STRING Lipshchin
11207: PPUSH
11208: CALL_OW 25
11212: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11213: LD_STRING 13_Titov_1
11215: PPUSH
11216: LD_INT 0
11218: PPUSH
11219: CALL_OW 30
11223: IFFALSE 11238
// Titov := NewCharacter ( Titov ) ;
11225: LD_ADDR_EXP 80
11229: PUSH
11230: LD_STRING Titov
11232: PPUSH
11233: CALL_OW 25
11237: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11238: LD_STRING 13_Gnyevko_1
11240: PPUSH
11241: LD_INT 0
11243: PPUSH
11244: CALL_OW 30
11248: IFFALSE 11263
// Gnyevko := NewCharacter ( Gnyevko ) ;
11250: LD_ADDR_EXP 79
11254: PUSH
11255: LD_STRING Gnyevko
11257: PPUSH
11258: CALL_OW 25
11262: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11263: LD_STRING 13_Xavier_1
11265: PPUSH
11266: LD_INT 0
11268: PPUSH
11269: CALL_OW 30
11273: IFFALSE 11288
// Xavier := NewCharacter ( Xavier2 ) ;
11275: LD_ADDR_EXP 81
11279: PUSH
11280: LD_STRING Xavier2
11282: PPUSH
11283: CALL_OW 25
11287: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11288: LD_STRING 13_Belkov_1
11290: PPUSH
11291: LD_INT 0
11293: PPUSH
11294: CALL_OW 30
11298: IFFALSE 11313
// Belkov := NewCharacter ( Belkov ) ;
11300: LD_ADDR_EXP 82
11304: PUSH
11305: LD_STRING Belkov
11307: PPUSH
11308: CALL_OW 25
11312: ST_TO_ADDR
// if not BurlakStatus then
11313: LD_EXP 9
11317: NOT
11318: IFFALSE 11333
// Burlak = NewCharacter ( Burlak ) ;
11320: LD_ADDR_EXP 83
11324: PUSH
11325: LD_STRING Burlak
11327: PPUSH
11328: CALL_OW 25
11332: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11333: LD_ADDR_VAR 0 3
11337: PUSH
11338: LD_EXP 71
11342: PUSH
11343: LD_EXP 73
11347: PUSH
11348: LD_EXP 87
11352: PUSH
11353: LD_EXP 74
11357: PUSH
11358: LD_EXP 75
11362: PUSH
11363: LD_EXP 86
11367: PUSH
11368: LD_EXP 85
11372: PUSH
11373: LD_EXP 76
11377: PUSH
11378: LD_EXP 77
11382: PUSH
11383: LD_EXP 84
11387: PUSH
11388: EMPTY
11389: LIST
11390: LIST
11391: LIST
11392: LIST
11393: LIST
11394: LIST
11395: LIST
11396: LIST
11397: LIST
11398: LIST
11399: ST_TO_ADDR
// if Simms then
11400: LD_EXP 72
11404: IFFALSE 11422
// tmp := tmp ^ Simms ;
11406: LD_ADDR_VAR 0 3
11410: PUSH
11411: LD_VAR 0 3
11415: PUSH
11416: LD_EXP 72
11420: ADD
11421: ST_TO_ADDR
// if Titov then
11422: LD_EXP 80
11426: IFFALSE 11444
// tmp := tmp ^ Titov ;
11428: LD_ADDR_VAR 0 3
11432: PUSH
11433: LD_VAR 0 3
11437: PUSH
11438: LD_EXP 80
11442: ADD
11443: ST_TO_ADDR
// if Lipshchin then
11444: LD_EXP 78
11448: IFFALSE 11466
// tmp := tmp ^ Lipshchin ;
11450: LD_ADDR_VAR 0 3
11454: PUSH
11455: LD_VAR 0 3
11459: PUSH
11460: LD_EXP 78
11464: ADD
11465: ST_TO_ADDR
// if Gnyevko then
11466: LD_EXP 79
11470: IFFALSE 11488
// tmp := tmp ^ Gnyevko ;
11472: LD_ADDR_VAR 0 3
11476: PUSH
11477: LD_VAR 0 3
11481: PUSH
11482: LD_EXP 79
11486: ADD
11487: ST_TO_ADDR
// if Xavier then
11488: LD_EXP 81
11492: IFFALSE 11510
// tmp := tmp ^ Xavier ;
11494: LD_ADDR_VAR 0 3
11498: PUSH
11499: LD_VAR 0 3
11503: PUSH
11504: LD_EXP 81
11508: ADD
11509: ST_TO_ADDR
// if Belkov then
11510: LD_EXP 82
11514: IFFALSE 11532
// tmp := tmp ^ Belkov ;
11516: LD_ADDR_VAR 0 3
11520: PUSH
11521: LD_VAR 0 3
11525: PUSH
11526: LD_EXP 82
11530: ADD
11531: ST_TO_ADDR
// if Burlak then
11532: LD_EXP 83
11536: IFFALSE 11554
// tmp := tmp ^ Burlak ;
11538: LD_ADDR_VAR 0 3
11542: PUSH
11543: LD_VAR 0 3
11547: PUSH
11548: LD_EXP 83
11552: ADD
11553: ST_TO_ADDR
// for i = 1 to 8 do
11554: LD_ADDR_VAR 0 2
11558: PUSH
11559: DOUBLE
11560: LD_INT 1
11562: DEC
11563: ST_TO_ADDR
11564: LD_INT 8
11566: PUSH
11567: FOR_TO
11568: IFFALSE 11634
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11570: LD_ADDR_OWVAR 21
11574: PUSH
11575: LD_INT 1
11577: PUSH
11578: LD_INT 3
11580: PUSH
11581: EMPTY
11582: LIST
11583: LIST
11584: PUSH
11585: LD_INT 1
11587: PPUSH
11588: LD_INT 2
11590: PPUSH
11591: CALL_OW 12
11595: ARRAY
11596: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11597: LD_INT 0
11599: PPUSH
11600: LD_VAR 0 2
11604: PUSH
11605: LD_INT 2
11607: DIV
11608: PPUSH
11609: LD_INT 10
11611: PPUSH
11612: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11616: LD_ADDR_VAR 0 3
11620: PUSH
11621: LD_VAR 0 3
11625: PUSH
11626: CALL_OW 44
11630: ADD
11631: ST_TO_ADDR
// end ;
11632: GO 11567
11634: POP
11635: POP
// for i in tmp do
11636: LD_ADDR_VAR 0 2
11640: PUSH
11641: LD_VAR 0 3
11645: PUSH
11646: FOR_IN
11647: IFFALSE 11672
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11649: LD_VAR 0 2
11653: PPUSH
11654: LD_INT 260
11656: PPUSH
11657: LD_INT 235
11659: PPUSH
11660: LD_INT 8
11662: PPUSH
11663: LD_INT 0
11665: PPUSH
11666: CALL_OW 50
11670: GO 11646
11672: POP
11673: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11674: LD_ADDR_EXP 99
11678: PUSH
11679: LD_EXP 99
11683: PPUSH
11684: LD_INT 1
11686: PPUSH
11687: LD_INT 22
11689: PUSH
11690: LD_VAR 0 5
11694: PUSH
11695: EMPTY
11696: LIST
11697: LIST
11698: PUSH
11699: LD_INT 3
11701: PUSH
11702: LD_INT 21
11704: PUSH
11705: LD_INT 2
11707: PUSH
11708: EMPTY
11709: LIST
11710: LIST
11711: PUSH
11712: EMPTY
11713: LIST
11714: LIST
11715: PUSH
11716: EMPTY
11717: LIST
11718: LIST
11719: PPUSH
11720: CALL_OW 69
11724: PUSH
11725: LD_EXP 71
11729: PUSH
11730: LD_EXP 72
11734: PUSH
11735: EMPTY
11736: LIST
11737: LIST
11738: DIFF
11739: PPUSH
11740: CALL_OW 1
11744: ST_TO_ADDR
// uc_side := 0 ;
11745: LD_ADDR_OWVAR 20
11749: PUSH
11750: LD_INT 0
11752: ST_TO_ADDR
// uc_nation := 0 ;
11753: LD_ADDR_OWVAR 21
11757: PUSH
11758: LD_INT 0
11760: ST_TO_ADDR
// for i = 1 to 5 do
11761: LD_ADDR_VAR 0 2
11765: PUSH
11766: DOUBLE
11767: LD_INT 1
11769: DEC
11770: ST_TO_ADDR
11771: LD_INT 5
11773: PUSH
11774: FOR_TO
11775: IFFALSE 11812
// begin InitHc ;
11777: CALL_OW 19
// hc_class := class_apeman ;
11781: LD_ADDR_OWVAR 28
11785: PUSH
11786: LD_INT 12
11788: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11789: CALL_OW 44
11793: PPUSH
11794: LD_INT 299
11796: PPUSH
11797: LD_INT 229
11799: PPUSH
11800: LD_INT 10
11802: PPUSH
11803: LD_INT 0
11805: PPUSH
11806: CALL_OW 50
// end ;
11810: GO 11774
11812: POP
11813: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11814: LD_EXP 71
11818: PPUSH
11819: LD_INT 259
11821: PPUSH
11822: LD_INT 235
11824: PPUSH
11825: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11829: LD_EXP 71
11833: PPUSH
11834: LD_INT 262
11836: PPUSH
11837: LD_INT 235
11839: PPUSH
11840: CALL_OW 178
// if Simms then
11844: LD_EXP 72
11848: IFFALSE 11879
// begin ComMoveXY ( Simms , 262 , 235 ) ;
11850: LD_EXP 72
11854: PPUSH
11855: LD_INT 262
11857: PPUSH
11858: LD_INT 235
11860: PPUSH
11861: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
11865: LD_EXP 72
11869: PPUSH
11870: LD_EXP 71
11874: PPUSH
11875: CALL_OW 179
// end ; end ;
11879: LD_VAR 0 1
11883: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
11884: LD_EXP 31
11888: PUSH
11889: LD_EXP 23
11893: NOT
11894: AND
11895: IFFALSE 12071
11897: GO 11899
11899: DISABLE
11900: LD_INT 0
11902: PPUSH
11903: PPUSH
11904: PPUSH
// begin enable ;
11905: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
11906: LD_ADDR_VAR 0 2
11910: PUSH
11911: LD_INT 81
11913: PUSH
11914: LD_INT 7
11916: PUSH
11917: EMPTY
11918: LIST
11919: LIST
11920: PUSH
11921: LD_INT 2
11923: PUSH
11924: LD_INT 32
11926: PUSH
11927: LD_INT 3
11929: PUSH
11930: EMPTY
11931: LIST
11932: LIST
11933: PUSH
11934: LD_INT 30
11936: PUSH
11937: LD_INT 30
11939: PUSH
11940: EMPTY
11941: LIST
11942: LIST
11943: PUSH
11944: LD_INT 30
11946: PUSH
11947: LD_INT 28
11949: PUSH
11950: EMPTY
11951: LIST
11952: LIST
11953: PUSH
11954: LD_INT 34
11956: PUSH
11957: LD_INT 49
11959: PUSH
11960: EMPTY
11961: LIST
11962: LIST
11963: PUSH
11964: LD_INT 34
11966: PUSH
11967: LD_INT 10
11969: PUSH
11970: EMPTY
11971: LIST
11972: LIST
11973: PUSH
11974: LD_INT 34
11976: PUSH
11977: LD_INT 8
11979: PUSH
11980: EMPTY
11981: LIST
11982: LIST
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: LIST
11988: LIST
11989: LIST
11990: LIST
11991: LIST
11992: PUSH
11993: EMPTY
11994: LIST
11995: LIST
11996: PPUSH
11997: CALL_OW 69
12001: ST_TO_ADDR
// if not tmp then
12002: LD_VAR 0 2
12006: NOT
12007: IFFALSE 12011
// exit ;
12009: GO 12071
// target := tmp [ rand ( 1 , tmp ) ] ;
12011: LD_ADDR_VAR 0 3
12015: PUSH
12016: LD_VAR 0 2
12020: PUSH
12021: LD_INT 1
12023: PPUSH
12024: LD_VAR 0 2
12028: PPUSH
12029: CALL_OW 12
12033: ARRAY
12034: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12035: LD_VAR 0 3
12039: PPUSH
12040: CALL_OW 255
12044: PUSH
12045: LD_INT 1
12047: EQUAL
12048: IFFALSE 12059
// CenterNowOnUnits ( target ) ;
12050: LD_VAR 0 3
12054: PPUSH
12055: CALL_OW 87
// SetLives ( target , 0 ) ;
12059: LD_VAR 0 3
12063: PPUSH
12064: LD_INT 0
12066: PPUSH
12067: CALL_OW 234
// end ;
12071: PPOPN 3
12073: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12074: LD_EXP 23
12078: NOT
12079: PUSH
12080: LD_EXP 31
12084: AND
12085: IFFALSE 12607
12087: GO 12089
12089: DISABLE
12090: LD_INT 0
12092: PPUSH
12093: PPUSH
12094: PPUSH
// begin uc_side := 7 ;
12095: LD_ADDR_OWVAR 20
12099: PUSH
12100: LD_INT 7
12102: ST_TO_ADDR
// uc_nation := 1 ;
12103: LD_ADDR_OWVAR 21
12107: PUSH
12108: LD_INT 1
12110: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12111: LD_ADDR_VAR 0 3
12115: PUSH
12116: LD_INT 125
12118: PUSH
12119: LD_INT 163
12121: PUSH
12122: EMPTY
12123: LIST
12124: LIST
12125: PUSH
12126: LD_INT 185
12128: PUSH
12129: LD_INT 168
12131: PUSH
12132: EMPTY
12133: LIST
12134: LIST
12135: PUSH
12136: LD_INT 111
12138: PUSH
12139: LD_INT 97
12141: PUSH
12142: EMPTY
12143: LIST
12144: LIST
12145: PUSH
12146: EMPTY
12147: LIST
12148: LIST
12149: LIST
12150: PPUSH
12151: CALL 104336 0 1
12155: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12156: LD_ADDR_EXP 88
12160: PUSH
12161: EMPTY
12162: ST_TO_ADDR
// for i = 1 to Difficulty do
12163: LD_ADDR_VAR 0 1
12167: PUSH
12168: DOUBLE
12169: LD_INT 1
12171: DEC
12172: ST_TO_ADDR
12173: LD_OWVAR 67
12177: PUSH
12178: FOR_TO
12179: IFFALSE 12337
// begin InitHc ;
12181: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12185: LD_INT 0
12187: PPUSH
12188: LD_INT 8
12190: PPUSH
12191: CALL_OW 381
// un := CreateHuman ;
12195: LD_ADDR_VAR 0 2
12199: PUSH
12200: CALL_OW 44
12204: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12205: LD_VAR 0 2
12209: PPUSH
12210: LD_INT 258
12212: PPUSH
12213: LD_INT 267
12215: PPUSH
12216: LD_INT 4
12218: PPUSH
12219: LD_INT 0
12221: PPUSH
12222: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12226: LD_ADDR_EXP 88
12230: PUSH
12231: LD_EXP 88
12235: PUSH
12236: LD_VAR 0 2
12240: UNION
12241: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12242: LD_VAR 0 2
12246: PPUSH
12247: LD_VAR 0 3
12251: PUSH
12252: LD_VAR 0 1
12256: ARRAY
12257: PUSH
12258: LD_INT 1
12260: ARRAY
12261: PPUSH
12262: LD_VAR 0 3
12266: PUSH
12267: LD_VAR 0 1
12271: ARRAY
12272: PUSH
12273: LD_INT 2
12275: ARRAY
12276: PPUSH
12277: LD_INT 4
12279: PPUSH
12280: LD_INT 1
12282: PPUSH
12283: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12287: LD_VAR 0 2
12291: PPUSH
12292: LD_VAR 0 3
12296: PUSH
12297: LD_VAR 0 1
12301: ARRAY
12302: PUSH
12303: LD_INT 1
12305: ARRAY
12306: PPUSH
12307: LD_VAR 0 3
12311: PUSH
12312: LD_VAR 0 1
12316: ARRAY
12317: PUSH
12318: LD_INT 2
12320: ARRAY
12321: PPUSH
12322: CALL_OW 171
// AddComInvisible ( un ) ;
12326: LD_VAR 0 2
12330: PPUSH
12331: CALL_OW 212
// end ;
12335: GO 12178
12337: POP
12338: POP
// repeat wait ( 0 0$20 ) ;
12339: LD_INT 700
12341: PPUSH
12342: CALL_OW 67
// for i in allianceSpecialForce do
12346: LD_ADDR_VAR 0 1
12350: PUSH
12351: LD_EXP 88
12355: PUSH
12356: FOR_IN
12357: IFFALSE 12592
// begin if IsInvisible ( i ) then
12359: LD_VAR 0 1
12363: PPUSH
12364: CALL_OW 571
12368: IFFALSE 12561
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12370: LD_ADDR_VAR 0 3
12374: PUSH
12375: LD_INT 22
12377: PUSH
12378: LD_INT 1
12380: PUSH
12381: EMPTY
12382: LIST
12383: LIST
12384: PUSH
12385: LD_INT 50
12387: PUSH
12388: EMPTY
12389: LIST
12390: PUSH
12391: LD_INT 56
12393: PUSH
12394: EMPTY
12395: LIST
12396: PUSH
12397: LD_INT 91
12399: PUSH
12400: LD_VAR 0 1
12404: PUSH
12405: LD_INT 25
12407: PUSH
12408: LD_INT 30
12410: PUSH
12411: LD_INT 35
12413: PUSH
12414: EMPTY
12415: LIST
12416: LIST
12417: LIST
12418: PUSH
12419: LD_OWVAR 67
12423: ARRAY
12424: PUSH
12425: EMPTY
12426: LIST
12427: LIST
12428: LIST
12429: PUSH
12430: LD_INT 2
12432: PUSH
12433: LD_INT 25
12435: PUSH
12436: LD_INT 1
12438: PUSH
12439: EMPTY
12440: LIST
12441: LIST
12442: PUSH
12443: LD_INT 25
12445: PUSH
12446: LD_INT 2
12448: PUSH
12449: EMPTY
12450: LIST
12451: LIST
12452: PUSH
12453: LD_INT 25
12455: PUSH
12456: LD_INT 3
12458: PUSH
12459: EMPTY
12460: LIST
12461: LIST
12462: PUSH
12463: LD_INT 25
12465: PUSH
12466: LD_INT 4
12468: PUSH
12469: EMPTY
12470: LIST
12471: LIST
12472: PUSH
12473: LD_INT 25
12475: PUSH
12476: LD_INT 5
12478: PUSH
12479: EMPTY
12480: LIST
12481: LIST
12482: PUSH
12483: LD_INT 25
12485: PUSH
12486: LD_INT 8
12488: PUSH
12489: EMPTY
12490: LIST
12491: LIST
12492: PUSH
12493: EMPTY
12494: LIST
12495: LIST
12496: LIST
12497: LIST
12498: LIST
12499: LIST
12500: LIST
12501: PUSH
12502: EMPTY
12503: LIST
12504: LIST
12505: LIST
12506: LIST
12507: LIST
12508: PPUSH
12509: CALL_OW 69
12513: ST_TO_ADDR
// if not tmp then
12514: LD_VAR 0 3
12518: NOT
12519: IFFALSE 12523
// continue ;
12521: GO 12356
// if Prob ( 30 * Difficulty ) then
12523: LD_INT 30
12525: PUSH
12526: LD_OWVAR 67
12530: MUL
12531: PPUSH
12532: CALL_OW 13
12536: IFFALSE 12561
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12538: LD_VAR 0 3
12542: PUSH
12543: LD_INT 1
12545: PPUSH
12546: LD_VAR 0 3
12550: PPUSH
12551: CALL_OW 12
12555: ARRAY
12556: PPUSH
12557: CALL 30025 0 1
// end ; if IsDead ( i ) then
12561: LD_VAR 0 1
12565: PPUSH
12566: CALL_OW 301
12570: IFFALSE 12590
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12572: LD_ADDR_EXP 88
12576: PUSH
12577: LD_EXP 88
12581: PUSH
12582: LD_VAR 0 1
12586: DIFF
12587: ST_TO_ADDR
// continue ;
12588: GO 12356
// end ; end ;
12590: GO 12356
12592: POP
12593: POP
// until allianceDestroyed or not allianceSpecialForce ;
12594: LD_EXP 23
12598: PUSH
12599: LD_EXP 88
12603: NOT
12604: OR
12605: IFFALSE 12339
// end ;
12607: PPOPN 3
12609: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive and not MC_GetVehicles ( 1 , true ) do var i , tmp , target , teleport ;
12610: LD_EXP 23
12614: NOT
12615: PUSH
12616: LD_EXP 31
12620: AND
12621: PUSH
12622: LD_INT 1
12624: PPUSH
12625: LD_INT 1
12627: PPUSH
12628: CALL 57351 0 2
12632: NOT
12633: AND
12634: IFFALSE 13601
12636: GO 12638
12638: DISABLE
12639: LD_INT 0
12641: PPUSH
12642: PPUSH
12643: PPUSH
12644: PPUSH
// begin enable ;
12645: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12646: LD_INT 22
12648: PUSH
12649: LD_INT 7
12651: PUSH
12652: EMPTY
12653: LIST
12654: LIST
12655: PUSH
12656: LD_INT 30
12658: PUSH
12659: LD_INT 3
12661: PUSH
12662: EMPTY
12663: LIST
12664: LIST
12665: PUSH
12666: EMPTY
12667: LIST
12668: LIST
12669: PPUSH
12670: CALL_OW 69
12674: NOT
12675: IFFALSE 12679
// exit ;
12677: GO 13601
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12679: LD_ADDR_VAR 0 4
12683: PUSH
12684: LD_INT 22
12686: PUSH
12687: LD_INT 7
12689: PUSH
12690: EMPTY
12691: LIST
12692: LIST
12693: PUSH
12694: LD_INT 30
12696: PUSH
12697: LD_INT 34
12699: PUSH
12700: EMPTY
12701: LIST
12702: LIST
12703: PUSH
12704: EMPTY
12705: LIST
12706: LIST
12707: PPUSH
12708: CALL_OW 69
12712: ST_TO_ADDR
// if Prob ( 40 ) then
12713: LD_INT 40
12715: PPUSH
12716: CALL_OW 13
12720: IFFALSE 12847
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12722: LD_INT 1
12724: PPUSH
12725: LD_INT 5
12727: PUSH
12728: LD_INT 3
12730: PUSH
12731: LD_INT 2
12733: PUSH
12734: LD_INT 6
12736: PUSH
12737: EMPTY
12738: LIST
12739: LIST
12740: LIST
12741: LIST
12742: PUSH
12743: LD_INT 5
12745: PUSH
12746: LD_INT 3
12748: PUSH
12749: LD_INT 2
12751: PUSH
12752: LD_INT 6
12754: PUSH
12755: EMPTY
12756: LIST
12757: LIST
12758: LIST
12759: LIST
12760: PUSH
12761: LD_INT 5
12763: PUSH
12764: LD_INT 3
12766: PUSH
12767: LD_INT 2
12769: PUSH
12770: LD_INT 6
12772: PUSH
12773: EMPTY
12774: LIST
12775: LIST
12776: LIST
12777: LIST
12778: PUSH
12779: LD_INT 24
12781: PUSH
12782: LD_INT 3
12784: PUSH
12785: LD_INT 3
12787: PUSH
12788: LD_INT 45
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: LIST
12795: LIST
12796: PUSH
12797: LD_INT 24
12799: PUSH
12800: LD_INT 3
12802: PUSH
12803: LD_INT 3
12805: PUSH
12806: LD_INT 47
12808: PUSH
12809: EMPTY
12810: LIST
12811: LIST
12812: LIST
12813: LIST
12814: PUSH
12815: LD_INT 24
12817: PUSH
12818: LD_INT 3
12820: PUSH
12821: LD_INT 3
12823: PUSH
12824: LD_INT 45
12826: PUSH
12827: EMPTY
12828: LIST
12829: LIST
12830: LIST
12831: LIST
12832: PUSH
12833: EMPTY
12834: LIST
12835: LIST
12836: LIST
12837: LIST
12838: LIST
12839: LIST
12840: PPUSH
12841: CALL 55996 0 2
// end else
12845: GO 12970
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12847: LD_INT 1
12849: PPUSH
12850: LD_INT 24
12852: PUSH
12853: LD_INT 3
12855: PUSH
12856: LD_INT 3
12858: PUSH
12859: LD_INT 47
12861: PUSH
12862: EMPTY
12863: LIST
12864: LIST
12865: LIST
12866: LIST
12867: PUSH
12868: LD_INT 24
12870: PUSH
12871: LD_INT 3
12873: PUSH
12874: LD_INT 3
12876: PUSH
12877: LD_INT 47
12879: PUSH
12880: EMPTY
12881: LIST
12882: LIST
12883: LIST
12884: LIST
12885: PUSH
12886: LD_INT 5
12888: PUSH
12889: LD_INT 3
12891: PUSH
12892: LD_INT 2
12894: PUSH
12895: LD_INT 9
12897: PUSH
12898: EMPTY
12899: LIST
12900: LIST
12901: LIST
12902: LIST
12903: PUSH
12904: LD_INT 5
12906: PUSH
12907: LD_INT 3
12909: PUSH
12910: LD_INT 2
12912: PUSH
12913: LD_INT 9
12915: PUSH
12916: EMPTY
12917: LIST
12918: LIST
12919: LIST
12920: LIST
12921: PUSH
12922: LD_INT 24
12924: PUSH
12925: LD_INT 1
12927: PUSH
12928: LD_INT 3
12930: PUSH
12931: LD_INT 45
12933: PUSH
12934: EMPTY
12935: LIST
12936: LIST
12937: LIST
12938: LIST
12939: PUSH
12940: LD_INT 24
12942: PUSH
12943: LD_INT 1
12945: PUSH
12946: LD_INT 3
12948: PUSH
12949: LD_INT 45
12951: PUSH
12952: EMPTY
12953: LIST
12954: LIST
12955: LIST
12956: LIST
12957: PUSH
12958: EMPTY
12959: LIST
12960: LIST
12961: LIST
12962: LIST
12963: LIST
12964: LIST
12965: PPUSH
12966: CALL 55996 0 2
// end ; if Difficulty > 1 then
12970: LD_OWVAR 67
12974: PUSH
12975: LD_INT 1
12977: GREATER
12978: IFFALSE 13008
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
12980: LD_INT 1
12982: PPUSH
12983: LD_INT 24
12985: PUSH
12986: LD_INT 3
12988: PUSH
12989: LD_INT 3
12991: PUSH
12992: LD_INT 47
12994: PUSH
12995: EMPTY
12996: LIST
12997: LIST
12998: LIST
12999: LIST
13000: PUSH
13001: EMPTY
13002: LIST
13003: PPUSH
13004: CALL 55996 0 2
// repeat wait ( 0 0$1 ) ;
13008: LD_INT 35
13010: PPUSH
13011: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13015: LD_INT 1
13017: PPUSH
13018: LD_INT 1
13020: PPUSH
13021: CALL 57351 0 2
13025: PUSH
13026: LD_INT 6
13028: PUSH
13029: LD_INT 7
13031: PUSH
13032: LD_INT 7
13034: PUSH
13035: EMPTY
13036: LIST
13037: LIST
13038: LIST
13039: PUSH
13040: LD_OWVAR 67
13044: ARRAY
13045: GREATEREQUAL
13046: IFFALSE 13008
// wait ( 0 0$40 ) ;
13048: LD_INT 1400
13050: PPUSH
13051: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13055: LD_ADDR_VAR 0 2
13059: PUSH
13060: LD_INT 1
13062: PPUSH
13063: LD_INT 1
13065: PPUSH
13066: CALL 57351 0 2
13070: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13071: LD_ADDR_EXP 118
13075: PUSH
13076: LD_EXP 118
13080: PPUSH
13081: LD_INT 1
13083: PPUSH
13084: LD_EXP 118
13088: PUSH
13089: LD_INT 1
13091: ARRAY
13092: PUSH
13093: LD_VAR 0 2
13097: DIFF
13098: PPUSH
13099: CALL_OW 1
13103: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13104: LD_ADDR_VAR 0 3
13108: PUSH
13109: LD_INT 0
13111: PPUSH
13112: LD_INT 1
13114: PPUSH
13115: CALL_OW 12
13119: ST_TO_ADDR
// if target then
13120: LD_VAR 0 3
13124: IFFALSE 13290
// begin for i in tmp do
13126: LD_ADDR_VAR 0 1
13130: PUSH
13131: LD_VAR 0 2
13135: PUSH
13136: FOR_IN
13137: IFFALSE 13162
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13139: LD_VAR 0 1
13143: PPUSH
13144: LD_INT 179
13146: PPUSH
13147: LD_INT 209
13149: PPUSH
13150: LD_INT 8
13152: PPUSH
13153: LD_INT 1
13155: PPUSH
13156: CALL_OW 483
13160: GO 13136
13162: POP
13163: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13164: LD_ADDR_VAR 0 2
13168: PUSH
13169: LD_VAR 0 2
13173: PPUSH
13174: LD_INT 24
13176: PUSH
13177: LD_INT 250
13179: PUSH
13180: EMPTY
13181: LIST
13182: LIST
13183: PPUSH
13184: CALL_OW 72
13188: ST_TO_ADDR
// for i in tmp do
13189: LD_ADDR_VAR 0 1
13193: PUSH
13194: LD_VAR 0 2
13198: PUSH
13199: FOR_IN
13200: IFFALSE 13240
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13202: LD_VAR 0 1
13206: PPUSH
13207: LD_INT 179
13209: PPUSH
13210: LD_INT 209
13212: PPUSH
13213: CALL_OW 297
13217: PUSH
13218: LD_INT 9
13220: GREATER
13221: IFFALSE 13238
// ComMoveXY ( i , 179 , 209 ) ;
13223: LD_VAR 0 1
13227: PPUSH
13228: LD_INT 179
13230: PPUSH
13231: LD_INT 209
13233: PPUSH
13234: CALL_OW 111
13238: GO 13199
13240: POP
13241: POP
// wait ( 0 0$1 ) ;
13242: LD_INT 35
13244: PPUSH
13245: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13249: LD_VAR 0 2
13253: PPUSH
13254: LD_INT 92
13256: PUSH
13257: LD_INT 179
13259: PUSH
13260: LD_INT 209
13262: PUSH
13263: LD_INT 9
13265: PUSH
13266: EMPTY
13267: LIST
13268: LIST
13269: LIST
13270: LIST
13271: PPUSH
13272: CALL_OW 72
13276: PUSH
13277: LD_VAR 0 2
13281: PUSH
13282: LD_INT 1
13284: MINUS
13285: GREATEREQUAL
13286: IFFALSE 13164
// end else
13288: GO 13452
// begin for i in tmp do
13290: LD_ADDR_VAR 0 1
13294: PUSH
13295: LD_VAR 0 2
13299: PUSH
13300: FOR_IN
13301: IFFALSE 13326
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13303: LD_VAR 0 1
13307: PPUSH
13308: LD_INT 285
13310: PPUSH
13311: LD_INT 163
13313: PPUSH
13314: LD_INT 8
13316: PPUSH
13317: LD_INT 1
13319: PPUSH
13320: CALL_OW 483
13324: GO 13300
13326: POP
13327: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13328: LD_ADDR_VAR 0 2
13332: PUSH
13333: LD_VAR 0 2
13337: PPUSH
13338: LD_INT 24
13340: PUSH
13341: LD_INT 250
13343: PUSH
13344: EMPTY
13345: LIST
13346: LIST
13347: PPUSH
13348: CALL_OW 72
13352: ST_TO_ADDR
// for i in tmp do
13353: LD_ADDR_VAR 0 1
13357: PUSH
13358: LD_VAR 0 2
13362: PUSH
13363: FOR_IN
13364: IFFALSE 13404
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13366: LD_VAR 0 1
13370: PPUSH
13371: LD_INT 285
13373: PPUSH
13374: LD_INT 163
13376: PPUSH
13377: CALL_OW 297
13381: PUSH
13382: LD_INT 9
13384: GREATER
13385: IFFALSE 13402
// ComMoveXY ( i , 285 , 163 ) ;
13387: LD_VAR 0 1
13391: PPUSH
13392: LD_INT 285
13394: PPUSH
13395: LD_INT 163
13397: PPUSH
13398: CALL_OW 111
13402: GO 13363
13404: POP
13405: POP
// wait ( 0 0$1 ) ;
13406: LD_INT 35
13408: PPUSH
13409: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13413: LD_VAR 0 2
13417: PPUSH
13418: LD_INT 92
13420: PUSH
13421: LD_INT 285
13423: PUSH
13424: LD_INT 163
13426: PUSH
13427: LD_INT 9
13429: PUSH
13430: EMPTY
13431: LIST
13432: LIST
13433: LIST
13434: LIST
13435: PPUSH
13436: CALL_OW 72
13440: PUSH
13441: LD_VAR 0 2
13445: PUSH
13446: LD_INT 1
13448: MINUS
13449: GREATEREQUAL
13450: IFFALSE 13328
// end ; repeat wait ( 0 0$1 ) ;
13452: LD_INT 35
13454: PPUSH
13455: CALL_OW 67
// for i in tmp do
13459: LD_ADDR_VAR 0 1
13463: PUSH
13464: LD_VAR 0 2
13468: PUSH
13469: FOR_IN
13470: IFFALSE 13592
// if GetLives ( i ) > 251 then
13472: LD_VAR 0 1
13476: PPUSH
13477: CALL_OW 256
13481: PUSH
13482: LD_INT 251
13484: GREATER
13485: IFFALSE 13574
// begin if GetWeapon ( i ) = ru_time_lapser then
13487: LD_VAR 0 1
13491: PPUSH
13492: CALL_OW 264
13496: PUSH
13497: LD_INT 49
13499: EQUAL
13500: IFFALSE 13538
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13502: LD_VAR 0 1
13506: PPUSH
13507: LD_INT 81
13509: PUSH
13510: LD_INT 7
13512: PUSH
13513: EMPTY
13514: LIST
13515: LIST
13516: PPUSH
13517: CALL_OW 69
13521: PPUSH
13522: LD_VAR 0 1
13526: PPUSH
13527: CALL_OW 74
13531: PPUSH
13532: CALL_OW 112
13536: GO 13572
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13538: LD_VAR 0 1
13542: PPUSH
13543: LD_INT 81
13545: PUSH
13546: LD_INT 7
13548: PUSH
13549: EMPTY
13550: LIST
13551: LIST
13552: PPUSH
13553: CALL_OW 69
13557: PPUSH
13558: LD_VAR 0 1
13562: PPUSH
13563: CALL_OW 74
13567: PPUSH
13568: CALL_OW 115
// end else
13572: GO 13590
// tmp := tmp diff i ;
13574: LD_ADDR_VAR 0 2
13578: PUSH
13579: LD_VAR 0 2
13583: PUSH
13584: LD_VAR 0 1
13588: DIFF
13589: ST_TO_ADDR
13590: GO 13469
13592: POP
13593: POP
// until not tmp ;
13594: LD_VAR 0 2
13598: NOT
13599: IFFALSE 13452
// end ; end_of_file
13601: PPOPN 4
13603: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13604: LD_INT 0
13606: PPUSH
13607: PPUSH
13608: PPUSH
13609: PPUSH
// missionStage := 13 ;
13610: LD_ADDR_EXP 15
13614: PUSH
13615: LD_INT 13
13617: ST_TO_ADDR
// uc_side := 2 ;
13618: LD_ADDR_OWVAR 20
13622: PUSH
13623: LD_INT 2
13625: ST_TO_ADDR
// uc_nation := 2 ;
13626: LD_ADDR_OWVAR 21
13630: PUSH
13631: LD_INT 2
13633: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13634: LD_ADDR_EXP 89
13638: PUSH
13639: LD_STRING Omar
13641: PPUSH
13642: CALL_OW 25
13646: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13647: LD_EXP 89
13651: PPUSH
13652: LD_INT 4
13654: PPUSH
13655: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13659: LD_EXP 89
13663: PPUSH
13664: LD_INT 242
13666: PPUSH
13667: LD_INT 75
13669: PPUSH
13670: LD_INT 0
13672: PPUSH
13673: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13677: LD_ADDR_EXP 90
13681: PUSH
13682: LD_STRING Heike
13684: PPUSH
13685: CALL_OW 25
13689: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13690: LD_INT 14
13692: PPUSH
13693: LD_INT 3
13695: PPUSH
13696: LD_INT 1
13698: PPUSH
13699: LD_INT 27
13701: PPUSH
13702: LD_INT 100
13704: PPUSH
13705: CALL 68561 0 5
// veh := CreateVehicle ;
13709: LD_ADDR_VAR 0 3
13713: PUSH
13714: CALL_OW 45
13718: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13719: LD_VAR 0 3
13723: PPUSH
13724: LD_INT 1
13726: PPUSH
13727: CALL_OW 242
// SetDir ( veh , 4 ) ;
13731: LD_VAR 0 3
13735: PPUSH
13736: LD_INT 4
13738: PPUSH
13739: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13743: LD_VAR 0 3
13747: PPUSH
13748: LD_INT 241
13750: PPUSH
13751: LD_INT 72
13753: PPUSH
13754: LD_INT 0
13756: PPUSH
13757: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13761: LD_EXP 90
13765: PPUSH
13766: LD_VAR 0 3
13770: PPUSH
13771: CALL_OW 52
// if KhatamStatus then
13775: LD_EXP 8
13779: IFFALSE 13830
// begin Khatam := NewCharacter ( Khatam ) ;
13781: LD_ADDR_EXP 91
13785: PUSH
13786: LD_STRING Khatam
13788: PPUSH
13789: CALL_OW 25
13793: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13794: LD_EXP 91
13798: PPUSH
13799: LD_INT 245
13801: PPUSH
13802: LD_INT 78
13804: PPUSH
13805: LD_INT 3
13807: PPUSH
13808: LD_INT 0
13810: PPUSH
13811: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13815: LD_EXP 91
13819: PPUSH
13820: LD_INT 4
13822: PPUSH
13823: LD_INT 10
13825: PPUSH
13826: CALL_OW 237
// end ; for i = 1 to Difficulty do
13830: LD_ADDR_VAR 0 2
13834: PUSH
13835: DOUBLE
13836: LD_INT 1
13838: DEC
13839: ST_TO_ADDR
13840: LD_OWVAR 67
13844: PUSH
13845: FOR_TO
13846: IFFALSE 13912
// begin PrepareScientist ( false , 7 + Difficulty ) ;
13848: LD_INT 0
13850: PPUSH
13851: LD_INT 7
13853: PUSH
13854: LD_OWVAR 67
13858: PLUS
13859: PPUSH
13860: CALL_OW 384
// un := CreateHuman ;
13864: LD_ADDR_VAR 0 4
13868: PUSH
13869: CALL_OW 44
13873: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
13874: LD_VAR 0 4
13878: PPUSH
13879: LD_INT 28
13881: PUSH
13882: LD_INT 29
13884: PUSH
13885: EMPTY
13886: LIST
13887: LIST
13888: PUSH
13889: LD_VAR 0 2
13893: PUSH
13894: LD_INT 2
13896: MOD
13897: PUSH
13898: LD_INT 1
13900: PLUS
13901: ARRAY
13902: PPUSH
13903: LD_INT 0
13905: PPUSH
13906: CALL_OW 49
// end ;
13910: GO 13845
13912: POP
13913: POP
// for i = 1 to 6 do
13914: LD_ADDR_VAR 0 2
13918: PUSH
13919: DOUBLE
13920: LD_INT 1
13922: DEC
13923: ST_TO_ADDR
13924: LD_INT 6
13926: PUSH
13927: FOR_TO
13928: IFFALSE 13973
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
13930: LD_INT 0
13932: PPUSH
13933: LD_INT 7
13935: PUSH
13936: LD_OWVAR 67
13940: PLUS
13941: PPUSH
13942: CALL_OW 381
// un := CreateHuman ;
13946: LD_ADDR_VAR 0 4
13950: PUSH
13951: CALL_OW 44
13955: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
13956: LD_VAR 0 4
13960: PPUSH
13961: LD_INT 28
13963: PPUSH
13964: LD_INT 0
13966: PPUSH
13967: CALL_OW 49
// end ;
13971: GO 13927
13973: POP
13974: POP
// for i = 1 to 3 do
13975: LD_ADDR_VAR 0 2
13979: PUSH
13980: DOUBLE
13981: LD_INT 1
13983: DEC
13984: ST_TO_ADDR
13985: LD_INT 3
13987: PUSH
13988: FOR_TO
13989: IFFALSE 14037
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
13991: LD_INT 0
13993: PPUSH
13994: LD_INT 8
13996: PPUSH
13997: LD_INT 7
13999: PUSH
14000: LD_OWVAR 67
14004: PLUS
14005: PPUSH
14006: CALL_OW 380
// un := CreateHuman ;
14010: LD_ADDR_VAR 0 4
14014: PUSH
14015: CALL_OW 44
14019: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14020: LD_VAR 0 4
14024: PPUSH
14025: LD_INT 28
14027: PPUSH
14028: LD_INT 0
14030: PPUSH
14031: CALL_OW 49
// end ;
14035: GO 13988
14037: POP
14038: POP
// for i = 1 to 3 do
14039: LD_ADDR_VAR 0 2
14043: PUSH
14044: DOUBLE
14045: LD_INT 1
14047: DEC
14048: ST_TO_ADDR
14049: LD_INT 3
14051: PUSH
14052: FOR_TO
14053: IFFALSE 14143
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14055: LD_INT 14
14057: PPUSH
14058: LD_INT 2
14060: PPUSH
14061: LD_INT 1
14063: PPUSH
14064: LD_INT 28
14066: PPUSH
14067: LD_INT 80
14069: PPUSH
14070: CALL 68561 0 5
// veh := CreateVehicle ;
14074: LD_ADDR_VAR 0 3
14078: PUSH
14079: CALL_OW 45
14083: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14084: LD_VAR 0 3
14088: PPUSH
14089: LD_INT 3
14091: PPUSH
14092: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14096: LD_VAR 0 3
14100: PPUSH
14101: LD_INT 29
14103: PPUSH
14104: LD_INT 0
14106: PPUSH
14107: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14111: LD_INT 0
14113: PPUSH
14114: LD_INT 7
14116: PUSH
14117: LD_OWVAR 67
14121: PLUS
14122: PPUSH
14123: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14127: CALL_OW 44
14131: PPUSH
14132: LD_VAR 0 3
14136: PPUSH
14137: CALL_OW 52
// end ;
14141: GO 14052
14143: POP
14144: POP
// for i = 1 to 5 + Difficulty do
14145: LD_ADDR_VAR 0 2
14149: PUSH
14150: DOUBLE
14151: LD_INT 1
14153: DEC
14154: ST_TO_ADDR
14155: LD_INT 5
14157: PUSH
14158: LD_OWVAR 67
14162: PLUS
14163: PUSH
14164: FOR_TO
14165: IFFALSE 14292
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14167: LD_INT 14
14169: PPUSH
14170: LD_INT 1
14172: PPUSH
14173: LD_INT 3
14175: PPUSH
14176: CALL_OW 12
14180: PPUSH
14181: LD_INT 1
14183: PPUSH
14184: LD_INT 28
14186: PUSH
14187: LD_INT 26
14189: PUSH
14190: LD_INT 27
14192: PUSH
14193: LD_INT 25
14195: PUSH
14196: EMPTY
14197: LIST
14198: LIST
14199: LIST
14200: LIST
14201: PUSH
14202: LD_VAR 0 2
14206: PUSH
14207: LD_INT 4
14209: MOD
14210: PUSH
14211: LD_INT 1
14213: PLUS
14214: ARRAY
14215: PPUSH
14216: LD_INT 80
14218: PPUSH
14219: CALL 68561 0 5
// veh := CreateVehicle ;
14223: LD_ADDR_VAR 0 3
14227: PUSH
14228: CALL_OW 45
14232: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14233: LD_VAR 0 3
14237: PPUSH
14238: LD_INT 4
14240: PPUSH
14241: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14245: LD_VAR 0 3
14249: PPUSH
14250: LD_INT 28
14252: PPUSH
14253: LD_INT 0
14255: PPUSH
14256: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14260: LD_INT 0
14262: PPUSH
14263: LD_INT 7
14265: PUSH
14266: LD_OWVAR 67
14270: PLUS
14271: PPUSH
14272: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14276: CALL_OW 44
14280: PPUSH
14281: LD_VAR 0 3
14285: PPUSH
14286: CALL_OW 52
// end ;
14290: GO 14164
14292: POP
14293: POP
// for i = 1 to 3 do
14294: LD_ADDR_VAR 0 2
14298: PUSH
14299: DOUBLE
14300: LD_INT 1
14302: DEC
14303: ST_TO_ADDR
14304: LD_INT 3
14306: PUSH
14307: FOR_TO
14308: IFFALSE 14368
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14310: LD_INT 14
14312: PPUSH
14313: LD_INT 3
14315: PPUSH
14316: LD_INT 5
14318: PPUSH
14319: LD_INT 29
14321: PPUSH
14322: LD_INT 80
14324: PPUSH
14325: CALL 68561 0 5
// veh := CreateVehicle ;
14329: LD_ADDR_VAR 0 3
14333: PUSH
14334: CALL_OW 45
14338: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14339: LD_VAR 0 3
14343: PPUSH
14344: LD_INT 4
14346: PPUSH
14347: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14351: LD_VAR 0 3
14355: PPUSH
14356: LD_INT 28
14358: PPUSH
14359: LD_INT 0
14361: PPUSH
14362: CALL_OW 49
// end ;
14366: GO 14307
14368: POP
14369: POP
// end ;
14370: LD_VAR 0 1
14374: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14375: LD_INT 22
14377: PUSH
14378: LD_INT 2
14380: PUSH
14381: EMPTY
14382: LIST
14383: LIST
14384: PPUSH
14385: CALL_OW 69
14389: IFFALSE 14689
14391: GO 14393
14393: DISABLE
14394: LD_INT 0
14396: PPUSH
14397: PPUSH
14398: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14399: LD_ADDR_VAR 0 3
14403: PUSH
14404: LD_INT 22
14406: PUSH
14407: LD_INT 2
14409: PUSH
14410: EMPTY
14411: LIST
14412: LIST
14413: PUSH
14414: LD_INT 25
14416: PUSH
14417: LD_INT 4
14419: PUSH
14420: EMPTY
14421: LIST
14422: LIST
14423: PUSH
14424: EMPTY
14425: LIST
14426: LIST
14427: PPUSH
14428: CALL_OW 69
14432: PUSH
14433: LD_EXP 91
14437: DIFF
14438: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14439: LD_ADDR_VAR 0 2
14443: PUSH
14444: LD_INT 22
14446: PUSH
14447: LD_INT 2
14449: PUSH
14450: EMPTY
14451: LIST
14452: LIST
14453: PPUSH
14454: CALL_OW 69
14458: PUSH
14459: LD_EXP 91
14463: PUSH
14464: LD_VAR 0 3
14468: UNION
14469: DIFF
14470: ST_TO_ADDR
// if Khatam then
14471: LD_EXP 91
14475: IFFALSE 14492
// ComMoveXY ( Khatam , 211 , 92 ) ;
14477: LD_EXP 91
14481: PPUSH
14482: LD_INT 211
14484: PPUSH
14485: LD_INT 92
14487: PPUSH
14488: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14492: LD_INT 197
14494: PPUSH
14495: LD_INT 80
14497: PPUSH
14498: LD_INT 2
14500: PPUSH
14501: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14505: LD_INT 213
14507: PPUSH
14508: LD_INT 90
14510: PPUSH
14511: LD_INT 2
14513: PPUSH
14514: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14518: LD_INT 215
14520: PPUSH
14521: LD_INT 129
14523: PPUSH
14524: LD_INT 2
14526: PPUSH
14527: CALL_OW 441
// if sci then
14531: LD_VAR 0 3
14535: IFFALSE 14556
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14537: LD_VAR 0 3
14541: PUSH
14542: LD_INT 1
14544: ARRAY
14545: PPUSH
14546: LD_INT 197
14548: PPUSH
14549: LD_INT 80
14551: PPUSH
14552: CALL_OW 158
// if sci > 1 then
14556: LD_VAR 0 3
14560: PUSH
14561: LD_INT 1
14563: GREATER
14564: IFFALSE 14585
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14566: LD_VAR 0 3
14570: PUSH
14571: LD_INT 2
14573: ARRAY
14574: PPUSH
14575: LD_INT 213
14577: PPUSH
14578: LD_INT 90
14580: PPUSH
14581: CALL_OW 158
// if sci > 2 then
14585: LD_VAR 0 3
14589: PUSH
14590: LD_INT 2
14592: GREATER
14593: IFFALSE 14614
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14595: LD_VAR 0 3
14599: PUSH
14600: LD_INT 3
14602: ARRAY
14603: PPUSH
14604: LD_INT 215
14606: PPUSH
14607: LD_INT 129
14609: PPUSH
14610: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14614: LD_INT 35
14616: PPUSH
14617: CALL_OW 67
// for i in tmp do
14621: LD_ADDR_VAR 0 1
14625: PUSH
14626: LD_VAR 0 2
14630: PUSH
14631: FOR_IN
14632: IFFALSE 14670
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14634: LD_VAR 0 1
14638: PPUSH
14639: LD_INT 81
14641: PUSH
14642: LD_INT 2
14644: PUSH
14645: EMPTY
14646: LIST
14647: LIST
14648: PPUSH
14649: CALL_OW 69
14653: PPUSH
14654: LD_VAR 0 1
14658: PPUSH
14659: CALL_OW 74
14663: PPUSH
14664: CALL_OW 115
14668: GO 14631
14670: POP
14671: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14672: LD_INT 22
14674: PUSH
14675: LD_INT 2
14677: PUSH
14678: EMPTY
14679: LIST
14680: LIST
14681: PPUSH
14682: CALL_OW 69
14686: NOT
14687: IFFALSE 14614
// end ; end_of_file
14689: PPOPN 3
14691: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14692: LD_INT 0
14694: PPUSH
14695: PPUSH
14696: PPUSH
14697: PPUSH
14698: PPUSH
14699: PPUSH
14700: PPUSH
14701: PPUSH
14702: PPUSH
// Video ( true ) ;
14703: LD_INT 1
14705: PPUSH
14706: CALL 104216 0 1
// if debug then
14710: LD_EXP 1
14714: IFFALSE 14724
// dialogue_skipped := true ;
14716: LD_ADDR_OWVAR 59
14720: PUSH
14721: LD_INT 1
14723: ST_TO_ADDR
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14724: LD_ADDR_VAR 0 5
14728: PUSH
14729: LD_INT 7
14731: PPUSH
14732: LD_INT 0
14734: PPUSH
14735: CALL_OW 517
14739: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14740: LD_ADDR_VAR 0 2
14744: PUSH
14745: DOUBLE
14746: LD_INT 1
14748: DEC
14749: ST_TO_ADDR
14750: LD_VAR 0 5
14754: PUSH
14755: LD_INT 1
14757: ARRAY
14758: PUSH
14759: FOR_TO
14760: IFFALSE 14805
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14762: LD_VAR 0 5
14766: PUSH
14767: LD_INT 1
14769: ARRAY
14770: PUSH
14771: LD_VAR 0 2
14775: ARRAY
14776: PPUSH
14777: LD_VAR 0 5
14781: PUSH
14782: LD_INT 2
14784: ARRAY
14785: PUSH
14786: LD_VAR 0 2
14790: ARRAY
14791: PPUSH
14792: LD_INT 1
14794: PPUSH
14795: LD_INT 15
14797: NEG
14798: PPUSH
14799: CALL 104130 0 4
14803: GO 14759
14805: POP
14806: POP
// CenterNowOnUnits ( Powell ) ;
14807: LD_EXP 55
14811: PPUSH
14812: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14816: LD_ADDR_VAR 0 5
14820: PUSH
14821: LD_EXP 53
14825: PUSH
14826: EMPTY
14827: LIST
14828: ST_TO_ADDR
// if GirlNewVeh then
14829: LD_EXP 54
14833: IFFALSE 14851
// tmp := tmp ^ GirlNewVeh ;
14835: LD_ADDR_VAR 0 5
14839: PUSH
14840: LD_VAR 0 5
14844: PUSH
14845: LD_EXP 54
14849: ADD
14850: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
14851: LD_VAR 0 5
14855: PPUSH
14856: LD_INT 60
14858: PPUSH
14859: LD_INT 109
14861: PPUSH
14862: CALL_OW 111
// if KappaStatus then
14866: LD_EXP 2
14870: IFFALSE 14922
// begin Say ( JMM , D1nT-JMM-1 ) ;
14872: LD_EXP 36
14876: PPUSH
14877: LD_STRING D1nT-JMM-1
14879: PPUSH
14880: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14884: LD_EXP 55
14888: PPUSH
14889: LD_STRING D1T-Pow-1
14891: PPUSH
14892: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
14896: LD_EXP 36
14900: PPUSH
14901: LD_STRING D1T-JMM-2
14903: PPUSH
14904: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
14908: LD_EXP 55
14912: PPUSH
14913: LD_STRING D1T-Pow-2
14915: PPUSH
14916: CALL_OW 88
// end else
14920: GO 15128
// if JMMGirlStatus then
14922: LD_EXP 6
14926: IFFALSE 15071
// begin Say ( JMM , D1T-JMM-1 ) ;
14928: LD_EXP 36
14932: PPUSH
14933: LD_STRING D1T-JMM-1
14935: PPUSH
14936: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14940: LD_EXP 55
14944: PPUSH
14945: LD_STRING D1T-Pow-1
14947: PPUSH
14948: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
14952: LD_EXP 36
14956: PPUSH
14957: LD_STRING D1T-JMM-3
14959: PPUSH
14960: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
14964: LD_EXP 55
14968: PPUSH
14969: LD_STRING D1T-Pow-3
14971: PPUSH
14972: CALL_OW 88
// if JMMGirl then
14976: LD_EXP 7
14980: IFFALSE 15069
// begin case JMMGirl of 1 :
14982: LD_EXP 7
14986: PUSH
14987: LD_INT 1
14989: DOUBLE
14990: EQUAL
14991: IFTRUE 14995
14993: GO 15010
14995: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
14996: LD_EXP 37
15000: PPUSH
15001: LD_STRING D1T-Joan-3
15003: PPUSH
15004: CALL_OW 88
15008: GO 15057
15010: LD_INT 2
15012: DOUBLE
15013: EQUAL
15014: IFTRUE 15018
15016: GO 15033
15018: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15019: LD_EXP 39
15023: PPUSH
15024: LD_STRING D1T-Lisa-3
15026: PPUSH
15027: CALL_OW 88
15031: GO 15057
15033: LD_INT 3
15035: DOUBLE
15036: EQUAL
15037: IFTRUE 15041
15039: GO 15056
15041: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15042: LD_EXP 51
15046: PPUSH
15047: LD_STRING D1T-Con-3
15049: PPUSH
15050: CALL_OW 88
15054: GO 15057
15056: POP
// Say ( Powell , D1T-Pow-4 ) ;
15057: LD_EXP 55
15061: PPUSH
15062: LD_STRING D1T-Pow-4
15064: PPUSH
15065: CALL_OW 88
// end ; end else
15069: GO 15128
// if not FastEnd then
15071: LD_EXP 11
15075: NOT
15076: IFFALSE 15104
// begin Say ( JMM , D1T-JMM-4 ) ;
15078: LD_EXP 36
15082: PPUSH
15083: LD_STRING D1T-JMM-4
15085: PPUSH
15086: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15090: LD_EXP 55
15094: PPUSH
15095: LD_STRING D1T-Pow-5
15097: PPUSH
15098: CALL_OW 88
// end else
15102: GO 15128
// begin Say ( JMM , D1nT-JMM-1 ) ;
15104: LD_EXP 36
15108: PPUSH
15109: LD_STRING D1nT-JMM-1
15111: PPUSH
15112: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15116: LD_EXP 55
15120: PPUSH
15121: LD_STRING D1nT-Pow-1
15123: PPUSH
15124: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15128: LD_INT 35
15130: PPUSH
15131: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15135: LD_EXP 53
15139: PPUSH
15140: CALL_OW 314
15144: NOT
15145: IFFALSE 15128
// ComExitVehicle ( JMM ) ;
15147: LD_EXP 36
15151: PPUSH
15152: CALL_OW 121
// wait ( 3 ) ;
15156: LD_INT 3
15158: PPUSH
15159: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15163: LD_EXP 36
15167: PPUSH
15168: LD_INT 60
15170: PPUSH
15171: LD_INT 94
15173: PPUSH
15174: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15178: LD_EXP 36
15182: PPUSH
15183: LD_EXP 55
15187: PPUSH
15188: CALL_OW 179
// if Joan then
15192: LD_EXP 37
15196: IFFALSE 15250
// begin ComExitVehicle ( Joan ) ;
15198: LD_EXP 37
15202: PPUSH
15203: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15207: LD_EXP 37
15211: PPUSH
15212: LD_INT 35
15214: PPUSH
15215: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15219: LD_EXP 37
15223: PPUSH
15224: LD_INT 65
15226: PPUSH
15227: LD_INT 104
15229: PPUSH
15230: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15234: LD_EXP 37
15238: PPUSH
15239: LD_EXP 36
15243: PPUSH
15244: CALL_OW 179
// end else
15248: GO 15384
// if Lisa and JMMGirl = 2 then
15250: LD_EXP 39
15254: PUSH
15255: LD_EXP 7
15259: PUSH
15260: LD_INT 2
15262: EQUAL
15263: AND
15264: IFFALSE 15318
// begin ComExitVehicle ( Lisa ) ;
15266: LD_EXP 39
15270: PPUSH
15271: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15275: LD_EXP 39
15279: PPUSH
15280: LD_INT 35
15282: PPUSH
15283: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15287: LD_EXP 39
15291: PPUSH
15292: LD_INT 65
15294: PPUSH
15295: LD_INT 104
15297: PPUSH
15298: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15302: LD_EXP 39
15306: PPUSH
15307: LD_EXP 36
15311: PPUSH
15312: CALL_OW 179
// end else
15316: GO 15384
// if Connie and JMMGirl = 3 then
15318: LD_EXP 51
15322: PUSH
15323: LD_EXP 7
15327: PUSH
15328: LD_INT 3
15330: EQUAL
15331: AND
15332: IFFALSE 15384
// begin ComExitVehicle ( Connie ) ;
15334: LD_EXP 51
15338: PPUSH
15339: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15343: LD_EXP 51
15347: PPUSH
15348: LD_INT 35
15350: PPUSH
15351: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15355: LD_EXP 51
15359: PPUSH
15360: LD_INT 65
15362: PPUSH
15363: LD_INT 104
15365: PPUSH
15366: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15370: LD_EXP 51
15374: PPUSH
15375: LD_EXP 36
15379: PPUSH
15380: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15384: LD_INT 35
15386: PPUSH
15387: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15391: LD_EXP 36
15395: PPUSH
15396: LD_EXP 55
15400: PPUSH
15401: CALL_OW 296
15405: PUSH
15406: LD_INT 6
15408: LESS
15409: IFFALSE 15384
// wait ( 0 0$0.5 ) ;
15411: LD_INT 18
15413: PPUSH
15414: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15418: LD_EXP 36
15422: PPUSH
15423: LD_STRING D1-JMM-1
15425: PPUSH
15426: CALL_OW 88
// async ;
15430: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15431: LD_EXP 55
15435: PPUSH
15436: LD_STRING D1-Pow-1
15438: PPUSH
15439: CALL_OW 88
// if not dialogue_skipped then
15443: LD_OWVAR 59
15447: NOT
15448: IFFALSE 15457
// wait ( 0 0$2 ) ;
15450: LD_INT 70
15452: PPUSH
15453: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15457: LD_INT 170
15459: PPUSH
15460: LD_INT 99
15462: PPUSH
15463: LD_INT 1
15465: PPUSH
15466: LD_INT 6
15468: NEG
15469: PPUSH
15470: CALL 104130 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15474: LD_INT 174
15476: PPUSH
15477: LD_INT 115
15479: PPUSH
15480: LD_INT 1
15482: PPUSH
15483: LD_INT 6
15485: NEG
15486: PPUSH
15487: CALL 104130 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15491: LD_INT 169
15493: PPUSH
15494: LD_INT 71
15496: PPUSH
15497: LD_INT 1
15499: PPUSH
15500: LD_INT 6
15502: NEG
15503: PPUSH
15504: CALL 104130 0 4
// if not dialogue_skipped then
15508: LD_OWVAR 59
15512: NOT
15513: IFFALSE 15532
// begin CenterOnXY ( 170 , 99 ) ;
15515: LD_INT 170
15517: PPUSH
15518: LD_INT 99
15520: PPUSH
15521: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15525: LD_INT 80
15527: PPUSH
15528: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15532: LD_INT 75
15534: PPUSH
15535: LD_INT 53
15537: PPUSH
15538: LD_INT 1
15540: PPUSH
15541: LD_INT 9
15543: NEG
15544: PPUSH
15545: CALL 104130 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15549: LD_INT 54
15551: PPUSH
15552: LD_INT 42
15554: PPUSH
15555: LD_INT 1
15557: PPUSH
15558: LD_INT 9
15560: NEG
15561: PPUSH
15562: CALL 104130 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15566: LD_INT 62
15568: PPUSH
15569: LD_INT 51
15571: PPUSH
15572: LD_INT 1
15574: PPUSH
15575: LD_INT 9
15577: NEG
15578: PPUSH
15579: CALL 104130 0 4
// if not dialogue_skipped then
15583: LD_OWVAR 59
15587: NOT
15588: IFFALSE 15607
// begin CenterOnXY ( 75 , 53 ) ;
15590: LD_INT 75
15592: PPUSH
15593: LD_INT 53
15595: PPUSH
15596: CALL_OW 84
// wait ( 0 0$4 ) ;
15600: LD_INT 140
15602: PPUSH
15603: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15607: LD_EXP 55
15611: PPUSH
15612: CALL_OW 87
// if not dialogue_skipped then
15616: LD_OWVAR 59
15620: NOT
15621: IFFALSE 15630
// wait ( 0 0$2 ) ;
15623: LD_INT 70
15625: PPUSH
15626: CALL_OW 67
// sync ;
15630: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15631: LD_EXP 36
15635: PPUSH
15636: LD_STRING D1-JMM-2
15638: PPUSH
15639: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15643: LD_EXP 55
15647: PPUSH
15648: LD_STRING D1-Pow-2
15650: PPUSH
15651: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15655: LD_EXP 36
15659: PPUSH
15660: LD_STRING D1-JMM-3
15662: PPUSH
15663: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15667: LD_EXP 55
15671: PPUSH
15672: LD_STRING D1-Pow-3
15674: PPUSH
15675: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15679: LD_EXP 36
15683: PPUSH
15684: LD_STRING D1-JMM-4
15686: PPUSH
15687: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15691: LD_EXP 55
15695: PPUSH
15696: LD_STRING D1-Pow-4
15698: PPUSH
15699: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15703: LD_EXP 36
15707: PPUSH
15708: LD_STRING D1-JMM-5
15710: PPUSH
15711: CALL_OW 88
// async ;
15715: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15716: LD_EXP 55
15720: PPUSH
15721: LD_STRING D1-Pow-5
15723: PPUSH
15724: CALL_OW 88
// if not dialogue_skipped then
15728: LD_OWVAR 59
15732: NOT
15733: IFFALSE 15742
// wait ( 0 0$3.6 ) ;
15735: LD_INT 126
15737: PPUSH
15738: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15742: LD_INT 134
15744: PPUSH
15745: LD_INT 210
15747: PPUSH
15748: LD_INT 1
15750: PPUSH
15751: LD_INT 11
15753: NEG
15754: PPUSH
15755: CALL 104130 0 4
// if not dialogue_skipped then
15759: LD_OWVAR 59
15763: NOT
15764: IFFALSE 15783
// begin CenterOnXY ( 134 , 210 ) ;
15766: LD_INT 134
15768: PPUSH
15769: LD_INT 210
15771: PPUSH
15772: CALL_OW 84
// wait ( 0 0$2 ) ;
15776: LD_INT 70
15778: PPUSH
15779: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15783: LD_INT 101
15785: PPUSH
15786: LD_INT 159
15788: PPUSH
15789: LD_INT 1
15791: PPUSH
15792: LD_INT 10
15794: NEG
15795: PPUSH
15796: CALL 104130 0 4
// if not dialogue_skipped then
15800: LD_OWVAR 59
15804: NOT
15805: IFFALSE 15824
// begin CenterOnXY ( 101 , 159 ) ;
15807: LD_INT 101
15809: PPUSH
15810: LD_INT 159
15812: PPUSH
15813: CALL_OW 84
// wait ( 0 0$2 ) ;
15817: LD_INT 70
15819: PPUSH
15820: CALL_OW 67
// end ; sync ;
15824: SYNC
// CenterNowOnUnits ( Powell ) ;
15825: LD_EXP 55
15829: PPUSH
15830: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15834: LD_ADDR_VAR 0 6
15838: PUSH
15839: LD_INT 1
15841: PUSH
15842: LD_INT 2
15844: PUSH
15845: LD_INT 3
15847: PUSH
15848: LD_INT 4
15850: PUSH
15851: LD_INT 5
15853: PUSH
15854: LD_INT 6
15856: PUSH
15857: EMPTY
15858: LIST
15859: LIST
15860: LIST
15861: LIST
15862: LIST
15863: LIST
15864: ST_TO_ADDR
// if not dialogue_skipped then
15865: LD_OWVAR 59
15869: NOT
15870: IFFALSE 16039
// begin game_speed := 4 ;
15872: LD_ADDR_OWVAR 65
15876: PUSH
15877: LD_INT 4
15879: ST_TO_ADDR
// wait ( 0 0$6 ) ;
15880: LD_INT 210
15882: PPUSH
15883: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
15887: LD_ADDR_VAR 0 7
15891: PUSH
15892: LD_STRING Q1
15894: PPUSH
15895: LD_VAR 0 6
15899: PPUSH
15900: CALL_OW 98
15904: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
15905: LD_ADDR_VAR 0 7
15909: PUSH
15910: LD_STRING Q1
15912: PPUSH
15913: LD_VAR 0 6
15917: PPUSH
15918: CALL_OW 98
15922: ST_TO_ADDR
// options = options diff dec ;
15923: LD_ADDR_VAR 0 6
15927: PUSH
15928: LD_VAR 0 6
15932: PUSH
15933: LD_VAR 0 7
15937: DIFF
15938: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
15939: LD_VAR 0 7
15943: PPUSH
15944: LD_VAR 0 6
15948: PPUSH
15949: CALL 17342 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
15953: LD_VAR 0 7
15957: PUSH
15958: LD_INT 5
15960: PUSH
15961: LD_INT 6
15963: PUSH
15964: EMPTY
15965: LIST
15966: LIST
15967: IN
15968: PUSH
15969: LD_VAR 0 6
15973: PUSH
15974: LD_INT 2
15976: EQUAL
15977: OR
15978: IFFALSE 15905
// if not ( dec in [ 5 , 6 ] ) then
15980: LD_VAR 0 7
15984: PUSH
15985: LD_INT 5
15987: PUSH
15988: LD_INT 6
15990: PUSH
15991: EMPTY
15992: LIST
15993: LIST
15994: IN
15995: NOT
15996: IFFALSE 16039
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
15998: LD_ADDR_VAR 0 7
16002: PUSH
16003: LD_STRING Q1a
16005: PPUSH
16006: LD_INT 1
16008: PUSH
16009: LD_INT 2
16011: PUSH
16012: EMPTY
16013: LIST
16014: LIST
16015: PPUSH
16016: CALL_OW 98
16020: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16021: LD_VAR 0 7
16025: PUSH
16026: LD_INT 4
16028: PLUS
16029: PPUSH
16030: LD_VAR 0 6
16034: PPUSH
16035: CALL 17342 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16039: LD_INT 81
16041: PPUSH
16042: LD_INT 127
16044: PPUSH
16045: CALL_OW 84
// amount := 5 ;
16049: LD_ADDR_VAR 0 8
16053: PUSH
16054: LD_INT 5
16056: ST_TO_ADDR
// macmilan_squad := [ ] ;
16057: LD_ADDR_VAR 0 9
16061: PUSH
16062: EMPTY
16063: ST_TO_ADDR
// if vip < amount then
16064: LD_EXP 56
16068: PUSH
16069: LD_VAR 0 8
16073: LESS
16074: IFFALSE 16118
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16076: LD_ADDR_VAR 0 5
16080: PUSH
16081: LD_EXP 56
16085: PUSH
16086: LD_INT 22
16088: PUSH
16089: LD_INT 4
16091: PUSH
16092: EMPTY
16093: LIST
16094: LIST
16095: PUSH
16096: LD_INT 21
16098: PUSH
16099: LD_INT 1
16101: PUSH
16102: EMPTY
16103: LIST
16104: LIST
16105: PUSH
16106: EMPTY
16107: LIST
16108: LIST
16109: PPUSH
16110: CALL_OW 69
16114: UNION
16115: ST_TO_ADDR
16116: GO 16128
// tmp := vip ;
16118: LD_ADDR_VAR 0 5
16122: PUSH
16123: LD_EXP 56
16127: ST_TO_ADDR
// tmp := tmp diff Powell ;
16128: LD_ADDR_VAR 0 5
16132: PUSH
16133: LD_VAR 0 5
16137: PUSH
16138: LD_EXP 55
16142: DIFF
16143: ST_TO_ADDR
// if tmp < amount then
16144: LD_VAR 0 5
16148: PUSH
16149: LD_VAR 0 8
16153: LESS
16154: IFFALSE 16166
// amount := tmp ;
16156: LD_ADDR_VAR 0 8
16160: PUSH
16161: LD_VAR 0 5
16165: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16166: LD_VAR 0 5
16170: PUSH
16171: LD_INT 1
16173: ARRAY
16174: PPUSH
16175: CALL_OW 257
16179: PUSH
16180: LD_INT 2
16182: NONEQUAL
16183: IFFALSE 16245
// begin if IsInUnit ( tmp [ 1 ] ) then
16185: LD_VAR 0 5
16189: PUSH
16190: LD_INT 1
16192: ARRAY
16193: PPUSH
16194: CALL_OW 310
16198: IFFALSE 16213
// ComExitBuilding ( tmp [ 1 ] ) ;
16200: LD_VAR 0 5
16204: PUSH
16205: LD_INT 1
16207: ARRAY
16208: PPUSH
16209: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16213: LD_VAR 0 5
16217: PUSH
16218: LD_INT 1
16220: ARRAY
16221: PPUSH
16222: LD_INT 387
16224: PPUSH
16225: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16229: LD_VAR 0 5
16233: PUSH
16234: LD_INT 1
16236: ARRAY
16237: PPUSH
16238: LD_INT 2
16240: PPUSH
16241: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16245: LD_EXP 36
16249: PPUSH
16250: LD_INT 82
16252: PPUSH
16253: LD_INT 129
16255: PPUSH
16256: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16260: LD_EXP 36
16264: PPUSH
16265: LD_EXP 55
16269: PPUSH
16270: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16274: LD_INT 22
16276: PUSH
16277: LD_INT 1
16279: PUSH
16280: EMPTY
16281: LIST
16282: LIST
16283: PPUSH
16284: CALL_OW 69
16288: PUSH
16289: LD_EXP 36
16293: DIFF
16294: PPUSH
16295: LD_INT 84
16297: PPUSH
16298: LD_INT 128
16300: PPUSH
16301: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16305: LD_INT 22
16307: PUSH
16308: LD_INT 1
16310: PUSH
16311: EMPTY
16312: LIST
16313: LIST
16314: PPUSH
16315: CALL_OW 69
16319: PUSH
16320: LD_EXP 36
16324: DIFF
16325: PPUSH
16326: LD_EXP 36
16330: PPUSH
16331: CALL_OW 179
// for i = 1 to amount do
16335: LD_ADDR_VAR 0 2
16339: PUSH
16340: DOUBLE
16341: LD_INT 1
16343: DEC
16344: ST_TO_ADDR
16345: LD_VAR 0 8
16349: PUSH
16350: FOR_TO
16351: IFFALSE 16519
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16353: LD_ADDR_VAR 0 9
16357: PUSH
16358: LD_VAR 0 9
16362: PUSH
16363: LD_VAR 0 5
16367: PUSH
16368: LD_VAR 0 2
16372: ARRAY
16373: ADD
16374: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16375: LD_VAR 0 5
16379: PUSH
16380: LD_VAR 0 2
16384: ARRAY
16385: PPUSH
16386: CALL_OW 310
16390: IFFALSE 16407
// AddComExitBuilding ( tmp [ i ] ) ;
16392: LD_VAR 0 5
16396: PUSH
16397: LD_VAR 0 2
16401: ARRAY
16402: PPUSH
16403: CALL_OW 182
// if i = 2 and JMMNewVeh then
16407: LD_VAR 0 2
16411: PUSH
16412: LD_INT 2
16414: EQUAL
16415: PUSH
16416: LD_EXP 53
16420: AND
16421: IFFALSE 16479
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16423: LD_VAR 0 5
16427: PUSH
16428: LD_VAR 0 2
16432: ARRAY
16433: PPUSH
16434: LD_EXP 53
16438: PPUSH
16439: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16443: LD_VAR 0 5
16447: PUSH
16448: LD_VAR 0 2
16452: ARRAY
16453: PPUSH
16454: LD_INT 86
16456: PPUSH
16457: LD_INT 133
16459: PPUSH
16460: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16464: LD_VAR 0 5
16468: PUSH
16469: LD_VAR 0 2
16473: ARRAY
16474: PPUSH
16475: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16479: LD_VAR 0 5
16483: PUSH
16484: LD_VAR 0 2
16488: ARRAY
16489: PPUSH
16490: LD_INT 8
16492: PPUSH
16493: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16497: LD_VAR 0 5
16501: PUSH
16502: LD_VAR 0 2
16506: ARRAY
16507: PPUSH
16508: LD_EXP 36
16512: PPUSH
16513: CALL_OW 179
// end ;
16517: GO 16350
16519: POP
16520: POP
// if GirlNewVeh then
16521: LD_EXP 54
16525: IFFALSE 16539
// SetSide ( GirlNewVeh , 4 ) ;
16527: LD_EXP 54
16531: PPUSH
16532: LD_INT 4
16534: PPUSH
16535: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16539: LD_INT 35
16541: PPUSH
16542: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16546: LD_VAR 0 9
16550: PPUSH
16551: LD_INT 95
16553: PUSH
16554: LD_INT 9
16556: PUSH
16557: EMPTY
16558: LIST
16559: LIST
16560: PPUSH
16561: CALL_OW 72
16565: PUSH
16566: LD_INT 0
16568: EQUAL
16569: PUSH
16570: LD_EXP 36
16574: PPUSH
16575: LD_INT 9
16577: PPUSH
16578: CALL_OW 308
16582: NOT
16583: AND
16584: IFFALSE 16539
// wait ( 0 0$2 ) ;
16586: LD_INT 70
16588: PPUSH
16589: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16593: LD_VAR 0 9
16597: PPUSH
16598: LD_INT 1
16600: PPUSH
16601: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16605: LD_INT 21
16607: PUSH
16608: LD_INT 2
16610: PUSH
16611: EMPTY
16612: LIST
16613: LIST
16614: PUSH
16615: LD_INT 92
16617: PUSH
16618: LD_INT 83
16620: PUSH
16621: LD_INT 130
16623: PUSH
16624: LD_INT 10
16626: PUSH
16627: EMPTY
16628: LIST
16629: LIST
16630: LIST
16631: LIST
16632: PUSH
16633: EMPTY
16634: LIST
16635: LIST
16636: PPUSH
16637: CALL_OW 69
16641: PPUSH
16642: LD_INT 1
16644: PPUSH
16645: CALL_OW 235
// Video ( false ) ;
16649: LD_INT 0
16651: PPUSH
16652: CALL 104216 0 1
// ChangeMissionObjectives ( M1 ) ;
16656: LD_STRING M1
16658: PPUSH
16659: CALL_OW 337
// SaveForQuickRestart ;
16663: CALL_OW 22
// missionStart := true ;
16667: LD_ADDR_EXP 13
16671: PUSH
16672: LD_INT 1
16674: ST_TO_ADDR
// missionStage := 2 ;
16675: LD_ADDR_EXP 15
16679: PUSH
16680: LD_INT 2
16682: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16683: LD_INT 105
16685: PPUSH
16686: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16690: LD_ADDR_VAR 0 5
16694: PUSH
16695: LD_INT 22
16697: PUSH
16698: LD_INT 4
16700: PUSH
16701: EMPTY
16702: LIST
16703: LIST
16704: PUSH
16705: LD_INT 21
16707: PUSH
16708: LD_INT 1
16710: PUSH
16711: EMPTY
16712: LIST
16713: LIST
16714: PUSH
16715: EMPTY
16716: LIST
16717: LIST
16718: PPUSH
16719: CALL_OW 69
16723: PUSH
16724: LD_EXP 55
16728: DIFF
16729: ST_TO_ADDR
// if not tmp then
16730: LD_VAR 0 5
16734: NOT
16735: IFFALSE 16750
// tmp := [ Powell ] ;
16737: LD_ADDR_VAR 0 5
16741: PUSH
16742: LD_EXP 55
16746: PUSH
16747: EMPTY
16748: LIST
16749: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16750: LD_ADDR_EXP 99
16754: PUSH
16755: LD_EXP 99
16759: PPUSH
16760: LD_INT 4
16762: PPUSH
16763: LD_INT 22
16765: PUSH
16766: LD_INT 4
16768: PUSH
16769: EMPTY
16770: LIST
16771: LIST
16772: PUSH
16773: LD_INT 23
16775: PUSH
16776: LD_INT 1
16778: PUSH
16779: EMPTY
16780: LIST
16781: LIST
16782: PUSH
16783: LD_INT 3
16785: PUSH
16786: LD_INT 21
16788: PUSH
16789: LD_INT 2
16791: PUSH
16792: EMPTY
16793: LIST
16794: LIST
16795: PUSH
16796: EMPTY
16797: LIST
16798: LIST
16799: PUSH
16800: EMPTY
16801: LIST
16802: LIST
16803: LIST
16804: PPUSH
16805: CALL_OW 69
16809: PUSH
16810: LD_EXP 55
16814: DIFF
16815: PPUSH
16816: CALL_OW 1
16820: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16821: LD_ADDR_VAR 0 4
16825: PUSH
16826: LD_INT 22
16828: PUSH
16829: LD_INT 4
16831: PUSH
16832: EMPTY
16833: LIST
16834: LIST
16835: PUSH
16836: LD_INT 34
16838: PUSH
16839: LD_INT 12
16841: PUSH
16842: EMPTY
16843: LIST
16844: LIST
16845: PUSH
16846: EMPTY
16847: LIST
16848: LIST
16849: PPUSH
16850: CALL_OW 69
16854: PUSH
16855: LD_INT 1
16857: ARRAY
16858: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
16859: LD_VAR 0 5
16863: PUSH
16864: LD_INT 1
16866: ARRAY
16867: PPUSH
16868: CALL_OW 310
16872: IFFALSE 16887
// ComExitBuilding ( tmp [ 1 ] ) ;
16874: LD_VAR 0 5
16878: PUSH
16879: LD_INT 1
16881: ARRAY
16882: PPUSH
16883: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
16887: LD_VAR 0 5
16891: PUSH
16892: LD_INT 1
16894: ARRAY
16895: PPUSH
16896: LD_VAR 0 4
16900: PPUSH
16901: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
16905: LD_VAR 0 5
16909: PUSH
16910: LD_INT 1
16912: ARRAY
16913: PPUSH
16914: LD_INT 80
16916: PPUSH
16917: LD_INT 136
16919: PPUSH
16920: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
16924: LD_VAR 0 5
16928: PUSH
16929: LD_INT 1
16931: ARRAY
16932: PPUSH
16933: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
16937: LD_VAR 0 5
16941: PUSH
16942: LD_INT 1
16944: ARRAY
16945: PPUSH
16946: LD_INT 59
16948: PPUSH
16949: LD_INT 112
16951: PPUSH
16952: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
16956: LD_VAR 0 5
16960: PUSH
16961: LD_INT 1
16963: ARRAY
16964: PPUSH
16965: CALL_OW 181
// if Lisa in vip and GetSide ( Lisa ) = 1 then
16969: LD_EXP 39
16973: PUSH
16974: LD_EXP 56
16978: IN
16979: PUSH
16980: LD_EXP 39
16984: PPUSH
16985: CALL_OW 255
16989: PUSH
16990: LD_INT 1
16992: EQUAL
16993: AND
16994: IFFALSE 17010
// Say ( Lisa , D3nW-Lisa-1 ) else
16996: LD_EXP 39
17000: PPUSH
17001: LD_STRING D3nW-Lisa-1
17003: PPUSH
17004: CALL_OW 88
17008: GO 17254
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17010: LD_EXP 42
17014: PUSH
17015: LD_EXP 56
17019: IN
17020: PUSH
17021: LD_EXP 42
17025: PPUSH
17026: CALL_OW 255
17030: PUSH
17031: LD_INT 1
17033: EQUAL
17034: AND
17035: IFFALSE 17051
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17037: LD_EXP 42
17041: PPUSH
17042: LD_STRING D3nW-Cyrus-1
17044: PPUSH
17045: CALL_OW 88
17049: GO 17254
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17051: LD_EXP 41
17055: PUSH
17056: LD_EXP 56
17060: IN
17061: PUSH
17062: LD_EXP 41
17066: PPUSH
17067: CALL_OW 255
17071: PUSH
17072: LD_INT 1
17074: EQUAL
17075: AND
17076: IFFALSE 17092
// Say ( Bobby , D3nW-Bobby-1 ) else
17078: LD_EXP 41
17082: PPUSH
17083: LD_STRING D3nW-Bobby-1
17085: PPUSH
17086: CALL_OW 88
17090: GO 17254
// if Gary in vip and GetSide ( Gary ) = 1 then
17092: LD_EXP 48
17096: PUSH
17097: LD_EXP 56
17101: IN
17102: PUSH
17103: LD_EXP 48
17107: PPUSH
17108: CALL_OW 255
17112: PUSH
17113: LD_INT 1
17115: EQUAL
17116: AND
17117: IFFALSE 17133
// Say ( Gary , D3nW-Gary-1 ) else
17119: LD_EXP 48
17123: PPUSH
17124: LD_STRING D3nW-Gary-1
17126: PPUSH
17127: CALL_OW 88
17131: GO 17254
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17133: LD_EXP 40
17137: PUSH
17138: LD_EXP 56
17142: IN
17143: PUSH
17144: LD_EXP 40
17148: PPUSH
17149: CALL_OW 255
17153: PUSH
17154: LD_INT 1
17156: EQUAL
17157: AND
17158: IFFALSE 17174
// Say ( Donaldson , D3nW-Don-1 ) else
17160: LD_EXP 40
17164: PPUSH
17165: LD_STRING D3nW-Don-1
17167: PPUSH
17168: CALL_OW 88
17172: GO 17254
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17174: LD_EXP 47
17178: PUSH
17179: LD_EXP 56
17183: IN
17184: PUSH
17185: LD_EXP 47
17189: PPUSH
17190: CALL_OW 255
17194: PUSH
17195: LD_INT 1
17197: EQUAL
17198: AND
17199: IFFALSE 17215
// Say ( Cornel , D3nW-Corn-1 ) else
17201: LD_EXP 47
17205: PPUSH
17206: LD_STRING D3nW-Corn-1
17208: PPUSH
17209: CALL_OW 88
17213: GO 17254
// if Frank in vip and GetSide ( Frank ) = 1 then
17215: LD_EXP 49
17219: PUSH
17220: LD_EXP 56
17224: IN
17225: PUSH
17226: LD_EXP 49
17230: PPUSH
17231: CALL_OW 255
17235: PUSH
17236: LD_INT 1
17238: EQUAL
17239: AND
17240: IFFALSE 17254
// Say ( Frank , D3nW-Frank-1 ) ;
17242: LD_EXP 49
17246: PPUSH
17247: LD_STRING D3nW-Frank-1
17249: PPUSH
17250: CALL_OW 88
// Say ( JMM , D3nW-JMM-1 ) ;
17254: LD_EXP 36
17258: PPUSH
17259: LD_STRING D3nW-JMM-1
17261: PPUSH
17262: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17266: LD_EXP 36
17270: PPUSH
17271: LD_STRING D3nW-JMM-1a
17273: PPUSH
17274: CALL_OW 88
// t := 0 0$00 ;
17278: LD_ADDR_VAR 0 3
17282: PUSH
17283: LD_INT 0
17285: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17286: LD_INT 35
17288: PPUSH
17289: CALL_OW 67
// t := t + 0 0$1 ;
17293: LD_ADDR_VAR 0 3
17297: PUSH
17298: LD_VAR 0 3
17302: PUSH
17303: LD_INT 35
17305: PLUS
17306: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17307: LD_INT 59
17309: PPUSH
17310: LD_INT 112
17312: PPUSH
17313: CALL_OW 428
17317: PUSH
17318: LD_VAR 0 3
17322: PUSH
17323: LD_INT 2100
17325: GREATER
17326: OR
17327: IFFALSE 17286
// activeAttacks := true ;
17329: LD_ADDR_EXP 16
17333: PUSH
17334: LD_INT 1
17336: ST_TO_ADDR
// end ;
17337: LD_VAR 0 1
17341: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17342: LD_INT 0
17344: PPUSH
// case question of 1 :
17345: LD_VAR 0 1
17349: PUSH
17350: LD_INT 1
17352: DOUBLE
17353: EQUAL
17354: IFTRUE 17358
17356: GO 17409
17358: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17359: LD_EXP 36
17363: PPUSH
17364: LD_STRING D2Mot-JMM-1
17366: PPUSH
17367: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17371: LD_EXP 55
17375: PPUSH
17376: LD_STRING D2Mot-Pow-1
17378: PPUSH
17379: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17383: LD_EXP 36
17387: PPUSH
17388: LD_STRING D2Mot-JMM-2
17390: PPUSH
17391: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17395: LD_EXP 55
17399: PPUSH
17400: LD_STRING D2Mot-Pow-2
17402: PPUSH
17403: CALL_OW 88
// end ; 2 :
17407: GO 17752
17409: LD_INT 2
17411: DOUBLE
17412: EQUAL
17413: IFTRUE 17417
17415: GO 17493
17417: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17418: LD_EXP 36
17422: PPUSH
17423: LD_STRING D2Rus-JMM-1
17425: PPUSH
17426: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17430: LD_EXP 55
17434: PPUSH
17435: LD_STRING D2Rus-Pow-1
17437: PPUSH
17438: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17442: LD_EXP 36
17446: PPUSH
17447: LD_STRING D2Rus-JMM-2
17449: PPUSH
17450: CALL_OW 88
// if not ( 3 in list_of_q ) then
17454: LD_INT 3
17456: PUSH
17457: LD_VAR 0 2
17461: IN
17462: NOT
17463: IFFALSE 17479
// Say ( Powell , D2Rus-Pow-2 ) else
17465: LD_EXP 55
17469: PPUSH
17470: LD_STRING D2Rus-Pow-2
17472: PPUSH
17473: CALL_OW 88
17477: GO 17491
// Say ( Powell , D2Rus-Pow-2a ) ;
17479: LD_EXP 55
17483: PPUSH
17484: LD_STRING D2Rus-Pow-2a
17486: PPUSH
17487: CALL_OW 88
// end ; 3 :
17491: GO 17752
17493: LD_INT 3
17495: DOUBLE
17496: EQUAL
17497: IFTRUE 17501
17499: GO 17586
17501: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17502: LD_EXP 36
17506: PPUSH
17507: LD_STRING D2Leg-JMM-1
17509: PPUSH
17510: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17514: LD_EXP 55
17518: PPUSH
17519: LD_STRING D2Leg-Pow-1
17521: PPUSH
17522: CALL_OW 88
// if 2 in list_of_q then
17526: LD_INT 2
17528: PUSH
17529: LD_VAR 0 2
17533: IN
17534: IFFALSE 17560
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17536: LD_EXP 36
17540: PPUSH
17541: LD_STRING D2Leg-JMM-2
17543: PPUSH
17544: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17548: LD_EXP 55
17552: PPUSH
17553: LD_STRING D2Leg-Pow-2
17555: PPUSH
17556: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17560: LD_EXP 36
17564: PPUSH
17565: LD_STRING D2Leg-JMM-3
17567: PPUSH
17568: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17572: LD_EXP 55
17576: PPUSH
17577: LD_STRING D2Leg-Pow-3
17579: PPUSH
17580: CALL_OW 88
// end ; 4 :
17584: GO 17752
17586: LD_INT 4
17588: DOUBLE
17589: EQUAL
17590: IFTRUE 17594
17592: GO 17669
17594: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17595: LD_EXP 36
17599: PPUSH
17600: LD_STRING D2Ar-JMM-1
17602: PPUSH
17603: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17607: LD_EXP 55
17611: PPUSH
17612: LD_STRING D2Ar-Pow-1
17614: PPUSH
17615: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17619: LD_EXP 36
17623: PPUSH
17624: LD_STRING D2Ar-JMM-2
17626: PPUSH
17627: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17631: LD_EXP 55
17635: PPUSH
17636: LD_STRING D2Ar-Pow-2
17638: PPUSH
17639: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17643: LD_EXP 36
17647: PPUSH
17648: LD_STRING D2Ar-JMM-3
17650: PPUSH
17651: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17655: LD_EXP 55
17659: PPUSH
17660: LD_STRING D2Ar-Pow-3
17662: PPUSH
17663: CALL_OW 88
// end ; 5 :
17667: GO 17752
17669: LD_INT 5
17671: DOUBLE
17672: EQUAL
17673: IFTRUE 17677
17675: GO 17692
17677: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17678: LD_EXP 36
17682: PPUSH
17683: LD_STRING D2Conf-JMM-1
17685: PPUSH
17686: CALL_OW 88
17690: GO 17752
17692: LD_INT 6
17694: DOUBLE
17695: EQUAL
17696: IFTRUE 17700
17698: GO 17751
17700: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
17701: LD_EXP 36
17705: PPUSH
17706: LD_STRING D2Com-JMM-1
17708: PPUSH
17709: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
17713: LD_EXP 55
17717: PPUSH
17718: LD_STRING D2Com-Pow-1
17720: PPUSH
17721: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
17725: LD_EXP 36
17729: PPUSH
17730: LD_STRING D2Com-JMM-2
17732: PPUSH
17733: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
17737: LD_EXP 55
17741: PPUSH
17742: LD_STRING D2Com-Pow-2
17744: PPUSH
17745: CALL_OW 88
// end ; end ;
17749: GO 17752
17751: POP
// end ;
17752: LD_VAR 0 3
17756: RET
// every 0 0$5 trigger missionStart do var tmp ;
17757: LD_EXP 13
17761: IFFALSE 18044
17763: GO 17765
17765: DISABLE
17766: LD_INT 0
17768: PPUSH
// begin repeat wait ( 0 0$1 ) ;
17769: LD_INT 35
17771: PPUSH
17772: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
17776: LD_INT 14
17778: PPUSH
17779: LD_INT 22
17781: PUSH
17782: LD_INT 1
17784: PUSH
17785: EMPTY
17786: LIST
17787: LIST
17788: PPUSH
17789: CALL_OW 70
17793: PUSH
17794: LD_EXP 15
17798: PUSH
17799: LD_INT 2
17801: PUSH
17802: LD_INT 3
17804: PUSH
17805: LD_INT 4
17807: PUSH
17808: LD_INT 5
17810: PUSH
17811: EMPTY
17812: LIST
17813: LIST
17814: LIST
17815: LIST
17816: IN
17817: AND
17818: IFFALSE 18034
// begin powellAnger := powellAnger + 1 ;
17820: LD_ADDR_EXP 17
17824: PUSH
17825: LD_EXP 17
17829: PUSH
17830: LD_INT 1
17832: PLUS
17833: ST_TO_ADDR
// Video ( true ) ;
17834: LD_INT 1
17836: PPUSH
17837: CALL 104216 0 1
// CenterNowOnUnits ( tmp ) ;
17841: LD_VAR 0 1
17845: PPUSH
17846: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
17850: LD_INT 14
17852: PPUSH
17853: LD_INT 22
17855: PUSH
17856: LD_INT 1
17858: PUSH
17859: EMPTY
17860: LIST
17861: LIST
17862: PPUSH
17863: CALL_OW 70
17867: PPUSH
17868: LD_INT 86
17870: PPUSH
17871: LD_INT 133
17873: PPUSH
17874: CALL_OW 111
// async ;
17878: ASYNC
// case powellAnger of 1 :
17879: LD_EXP 17
17883: PUSH
17884: LD_INT 1
17886: DOUBLE
17887: EQUAL
17888: IFTRUE 17892
17890: GO 17907
17892: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
17893: LD_EXP 55
17897: PPUSH
17898: LD_STRING DBack1-Pow-1
17900: PPUSH
17901: CALL_OW 88
17905: GO 17954
17907: LD_INT 2
17909: DOUBLE
17910: EQUAL
17911: IFTRUE 17915
17913: GO 17930
17915: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
17916: LD_EXP 55
17920: PPUSH
17921: LD_STRING DBack2-Pow-1
17923: PPUSH
17924: CALL_OW 88
17928: GO 17954
17930: LD_INT 3
17932: DOUBLE
17933: EQUAL
17934: IFTRUE 17938
17936: GO 17953
17938: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
17939: LD_EXP 55
17943: PPUSH
17944: LD_STRING DBack3-Pow-1
17946: PPUSH
17947: CALL_OW 88
17951: GO 17954
17953: POP
// sync ;
17954: SYNC
// repeat wait ( 0 0$1 ) ;
17955: LD_INT 35
17957: PPUSH
17958: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
17962: LD_INT 14
17964: PPUSH
17965: LD_INT 22
17967: PUSH
17968: LD_INT 1
17970: PUSH
17971: EMPTY
17972: LIST
17973: LIST
17974: PPUSH
17975: CALL_OW 70
17979: PPUSH
17980: LD_INT 86
17982: PPUSH
17983: LD_INT 133
17985: PPUSH
17986: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
17990: LD_INT 14
17992: PPUSH
17993: LD_INT 22
17995: PUSH
17996: LD_INT 1
17998: PUSH
17999: EMPTY
18000: LIST
18001: LIST
18002: PPUSH
18003: CALL_OW 70
18007: NOT
18008: IFFALSE 17955
// if powellAnger >= 3 then
18010: LD_EXP 17
18014: PUSH
18015: LD_INT 3
18017: GREATEREQUAL
18018: IFFALSE 18027
// YouLost ( Dismissed ) ;
18020: LD_STRING Dismissed
18022: PPUSH
18023: CALL_OW 104
// Video ( false ) ;
18027: LD_INT 0
18029: PPUSH
18030: CALL 104216 0 1
// end ; until missionStage > 5 ;
18034: LD_EXP 15
18038: PUSH
18039: LD_INT 5
18041: GREATER
18042: IFFALSE 17769
// end ;
18044: PPOPN 1
18046: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18047: LD_EXP 13
18051: PUSH
18052: LD_INT 22
18054: PUSH
18055: LD_INT 4
18057: PUSH
18058: EMPTY
18059: LIST
18060: LIST
18061: PUSH
18062: LD_INT 21
18064: PUSH
18065: LD_INT 2
18067: PUSH
18068: EMPTY
18069: LIST
18070: LIST
18071: PUSH
18072: EMPTY
18073: LIST
18074: LIST
18075: PPUSH
18076: CALL_OW 69
18080: PUSH
18081: LD_INT 4
18083: GREATEREQUAL
18084: AND
18085: PUSH
18086: LD_EXP 15
18090: PUSH
18091: LD_INT 2
18093: EQUAL
18094: AND
18095: IFFALSE 19918
18097: GO 18099
18099: DISABLE
18100: LD_INT 0
18102: PPUSH
18103: PPUSH
18104: PPUSH
18105: PPUSH
18106: PPUSH
18107: PPUSH
18108: PPUSH
18109: PPUSH
// begin missionStage := 3 ;
18110: LD_ADDR_EXP 15
18114: PUSH
18115: LD_INT 3
18117: ST_TO_ADDR
// retreat := false ;
18118: LD_ADDR_VAR 0 4
18122: PUSH
18123: LD_INT 0
18125: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18126: LD_ADDR_VAR 0 5
18130: PUSH
18131: LD_INT 22
18133: PUSH
18134: LD_INT 4
18136: PUSH
18137: EMPTY
18138: LIST
18139: LIST
18140: PUSH
18141: LD_INT 30
18143: PUSH
18144: LD_INT 4
18146: PUSH
18147: EMPTY
18148: LIST
18149: LIST
18150: PUSH
18151: EMPTY
18152: LIST
18153: LIST
18154: PPUSH
18155: CALL_OW 69
18159: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18160: LD_ADDR_VAR 0 6
18164: PUSH
18165: LD_INT 22
18167: PUSH
18168: LD_INT 4
18170: PUSH
18171: EMPTY
18172: LIST
18173: LIST
18174: PUSH
18175: LD_INT 30
18177: PUSH
18178: LD_INT 5
18180: PUSH
18181: EMPTY
18182: LIST
18183: LIST
18184: PUSH
18185: EMPTY
18186: LIST
18187: LIST
18188: PPUSH
18189: CALL_OW 69
18193: ST_TO_ADDR
// if not bar then
18194: LD_VAR 0 6
18198: NOT
18199: IFFALSE 18252
// begin repeat wait ( 0 0$1 ) ;
18201: LD_INT 35
18203: PPUSH
18204: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18208: LD_INT 22
18210: PUSH
18211: LD_INT 4
18213: PUSH
18214: EMPTY
18215: LIST
18216: LIST
18217: PUSH
18218: LD_INT 3
18220: PUSH
18221: LD_INT 57
18223: PUSH
18224: EMPTY
18225: LIST
18226: PUSH
18227: EMPTY
18228: LIST
18229: LIST
18230: PUSH
18231: LD_INT 30
18233: PUSH
18234: LD_INT 5
18236: PUSH
18237: EMPTY
18238: LIST
18239: LIST
18240: PUSH
18241: EMPTY
18242: LIST
18243: LIST
18244: LIST
18245: PPUSH
18246: CALL_OW 69
18250: IFFALSE 18201
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18252: LD_ADDR_VAR 0 6
18256: PUSH
18257: LD_INT 22
18259: PUSH
18260: LD_INT 4
18262: PUSH
18263: EMPTY
18264: LIST
18265: LIST
18266: PUSH
18267: LD_INT 30
18269: PUSH
18270: LD_INT 5
18272: PUSH
18273: EMPTY
18274: LIST
18275: LIST
18276: PUSH
18277: EMPTY
18278: LIST
18279: LIST
18280: PPUSH
18281: CALL_OW 69
18285: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18286: LD_INT 35
18288: PPUSH
18289: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18293: LD_EXP 118
18297: PUSH
18298: LD_INT 4
18300: ARRAY
18301: PUSH
18302: LD_INT 4
18304: GREATEREQUAL
18305: IFFALSE 18286
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18307: LD_ADDR_VAR 0 2
18311: PUSH
18312: LD_INT 22
18314: PUSH
18315: LD_INT 4
18317: PUSH
18318: EMPTY
18319: LIST
18320: LIST
18321: PUSH
18322: LD_INT 2
18324: PUSH
18325: LD_INT 25
18327: PUSH
18328: LD_INT 1
18330: PUSH
18331: EMPTY
18332: LIST
18333: LIST
18334: PUSH
18335: LD_INT 25
18337: PUSH
18338: LD_INT 2
18340: PUSH
18341: EMPTY
18342: LIST
18343: LIST
18344: PUSH
18345: LD_INT 25
18347: PUSH
18348: LD_INT 3
18350: PUSH
18351: EMPTY
18352: LIST
18353: LIST
18354: PUSH
18355: LD_INT 25
18357: PUSH
18358: LD_INT 4
18360: PUSH
18361: EMPTY
18362: LIST
18363: LIST
18364: PUSH
18365: LD_INT 25
18367: PUSH
18368: LD_INT 5
18370: PUSH
18371: EMPTY
18372: LIST
18373: LIST
18374: PUSH
18375: EMPTY
18376: LIST
18377: LIST
18378: LIST
18379: LIST
18380: LIST
18381: LIST
18382: PUSH
18383: EMPTY
18384: LIST
18385: LIST
18386: PPUSH
18387: CALL_OW 69
18391: PUSH
18392: LD_EXP 55
18396: PUSH
18397: LD_EXP 56
18401: ADD
18402: DIFF
18403: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18404: LD_ADDR_VAR 0 3
18408: PUSH
18409: LD_VAR 0 2
18413: PPUSH
18414: LD_INT 26
18416: PUSH
18417: LD_INT 1
18419: PUSH
18420: EMPTY
18421: LIST
18422: LIST
18423: PPUSH
18424: CALL_OW 72
18428: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18429: LD_ADDR_VAR 0 2
18433: PUSH
18434: LD_VAR 0 2
18438: PUSH
18439: LD_VAR 0 3
18443: DIFF
18444: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18445: LD_ADDR_VAR 0 2
18449: PUSH
18450: LD_VAR 0 2
18454: PPUSH
18455: LD_INT 1
18457: PPUSH
18458: CALL 102868 0 2
18462: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18463: LD_ADDR_VAR 0 3
18467: PUSH
18468: LD_VAR 0 3
18472: PPUSH
18473: LD_INT 1
18475: PPUSH
18476: CALL 102868 0 2
18480: ST_TO_ADDR
// for i = 1 to 4 do
18481: LD_ADDR_VAR 0 1
18485: PUSH
18486: DOUBLE
18487: LD_INT 1
18489: DEC
18490: ST_TO_ADDR
18491: LD_INT 4
18493: PUSH
18494: FOR_TO
18495: IFFALSE 18661
// begin if tmp2 then
18497: LD_VAR 0 3
18501: IFFALSE 18582
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18503: LD_ADDR_EXP 18
18507: PUSH
18508: LD_EXP 18
18512: PPUSH
18513: LD_INT 1
18515: PPUSH
18516: LD_EXP 18
18520: PUSH
18521: LD_INT 1
18523: ARRAY
18524: PUSH
18525: LD_VAR 0 3
18529: PUSH
18530: LD_VAR 0 3
18534: ARRAY
18535: ADD
18536: PPUSH
18537: CALL_OW 1
18541: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18542: LD_VAR 0 3
18546: PUSH
18547: LD_VAR 0 3
18551: ARRAY
18552: PPUSH
18553: LD_INT 1
18555: PPUSH
18556: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18560: LD_ADDR_VAR 0 3
18564: PUSH
18565: LD_VAR 0 3
18569: PPUSH
18570: LD_VAR 0 3
18574: PPUSH
18575: CALL_OW 3
18579: ST_TO_ADDR
// end else
18580: GO 18659
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18582: LD_ADDR_EXP 18
18586: PUSH
18587: LD_EXP 18
18591: PPUSH
18592: LD_INT 1
18594: PPUSH
18595: LD_EXP 18
18599: PUSH
18600: LD_INT 1
18602: ARRAY
18603: PUSH
18604: LD_VAR 0 2
18608: PUSH
18609: LD_VAR 0 2
18613: ARRAY
18614: ADD
18615: PPUSH
18616: CALL_OW 1
18620: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18621: LD_VAR 0 2
18625: PUSH
18626: LD_VAR 0 2
18630: ARRAY
18631: PPUSH
18632: LD_INT 1
18634: PPUSH
18635: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18639: LD_ADDR_VAR 0 2
18643: PUSH
18644: LD_VAR 0 2
18648: PPUSH
18649: LD_VAR 0 2
18653: PPUSH
18654: CALL_OW 3
18658: ST_TO_ADDR
// end ; end ;
18659: GO 18494
18661: POP
18662: POP
// if tmp2 then
18663: LD_VAR 0 3
18667: IFFALSE 18685
// tmp := tmp union tmp2 ;
18669: LD_ADDR_VAR 0 2
18673: PUSH
18674: LD_VAR 0 2
18678: PUSH
18679: LD_VAR 0 3
18683: UNION
18684: ST_TO_ADDR
// for i = 1 to 4 do
18685: LD_ADDR_VAR 0 1
18689: PUSH
18690: DOUBLE
18691: LD_INT 1
18693: DEC
18694: ST_TO_ADDR
18695: LD_INT 4
18697: PUSH
18698: FOR_TO
18699: IFFALSE 18748
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
18701: LD_ADDR_EXP 18
18705: PUSH
18706: LD_EXP 18
18710: PPUSH
18711: LD_INT 2
18713: PPUSH
18714: LD_EXP 18
18718: PUSH
18719: LD_INT 2
18721: ARRAY
18722: PUSH
18723: LD_VAR 0 2
18727: PUSH
18728: LD_VAR 0 2
18732: PUSH
18733: LD_VAR 0 1
18737: MINUS
18738: ARRAY
18739: ADD
18740: PPUSH
18741: CALL_OW 1
18745: ST_TO_ADDR
18746: GO 18698
18748: POP
18749: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
18750: LD_ADDR_EXP 99
18754: PUSH
18755: LD_EXP 99
18759: PPUSH
18760: LD_INT 4
18762: PPUSH
18763: LD_EXP 99
18767: PUSH
18768: LD_INT 4
18770: ARRAY
18771: PUSH
18772: LD_EXP 18
18776: PUSH
18777: LD_INT 1
18779: ARRAY
18780: DIFF
18781: PPUSH
18782: CALL_OW 1
18786: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
18787: LD_VAR 0 5
18791: PUSH
18792: LD_INT 1
18794: ARRAY
18795: PPUSH
18796: CALL_OW 313
18800: IFFALSE 18855
// begin for i in UnitsInside ( arm [ 1 ] ) do
18802: LD_ADDR_VAR 0 1
18806: PUSH
18807: LD_VAR 0 5
18811: PUSH
18812: LD_INT 1
18814: ARRAY
18815: PPUSH
18816: CALL_OW 313
18820: PUSH
18821: FOR_IN
18822: IFFALSE 18853
// begin ComExitBuilding ( i ) ;
18824: LD_VAR 0 1
18828: PPUSH
18829: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
18833: LD_VAR 0 1
18837: PPUSH
18838: LD_VAR 0 6
18842: PUSH
18843: LD_INT 1
18845: ARRAY
18846: PPUSH
18847: CALL_OW 180
// end ;
18851: GO 18821
18853: POP
18854: POP
// end ; wait ( 0 0$3 ) ;
18855: LD_INT 105
18857: PPUSH
18858: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
18862: LD_ADDR_VAR 0 1
18866: PUSH
18867: LD_EXP 18
18871: PUSH
18872: LD_INT 1
18874: ARRAY
18875: PUSH
18876: FOR_IN
18877: IFFALSE 18984
// begin if IsInUnit ( i ) then
18879: LD_VAR 0 1
18883: PPUSH
18884: CALL_OW 310
18888: IFFALSE 18899
// ComExitBuilding ( i ) ;
18890: LD_VAR 0 1
18894: PPUSH
18895: CALL_OW 122
// if GetClass ( i ) <> 1 then
18899: LD_VAR 0 1
18903: PPUSH
18904: CALL_OW 257
18908: PUSH
18909: LD_INT 1
18911: NONEQUAL
18912: IFFALSE 18953
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
18914: LD_VAR 0 1
18918: PPUSH
18919: LD_VAR 0 5
18923: PUSH
18924: LD_INT 1
18926: ARRAY
18927: PPUSH
18928: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
18932: LD_VAR 0 1
18936: PPUSH
18937: LD_INT 1
18939: PPUSH
18940: CALL_OW 183
// AddComExitBuilding ( i ) ;
18944: LD_VAR 0 1
18948: PPUSH
18949: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
18953: LD_VAR 0 1
18957: PPUSH
18958: LD_INT 60
18960: PPUSH
18961: LD_INT 94
18963: PPUSH
18964: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
18968: LD_VAR 0 1
18972: PPUSH
18973: LD_EXP 55
18977: PPUSH
18978: CALL_OW 179
// end ;
18982: GO 18876
18984: POP
18985: POP
// wait ( 0 0$15 ) ;
18986: LD_INT 525
18988: PPUSH
18989: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
18993: LD_EXP 55
18997: PPUSH
18998: LD_STRING D4-Pow-1
19000: PPUSH
19001: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19005: LD_ADDR_VAR 0 2
19009: PUSH
19010: LD_EXP 18
19014: PUSH
19015: LD_INT 1
19017: ARRAY
19018: PPUSH
19019: LD_INT 26
19021: PUSH
19022: LD_INT 1
19024: PUSH
19025: EMPTY
19026: LIST
19027: LIST
19028: PPUSH
19029: CALL_OW 72
19033: ST_TO_ADDR
// if tmp then
19034: LD_VAR 0 2
19038: IFFALSE 19056
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19040: LD_VAR 0 2
19044: PUSH
19045: LD_INT 1
19047: ARRAY
19048: PPUSH
19049: LD_STRING D4-Sol1-1
19051: PPUSH
19052: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19056: LD_EXP 55
19060: PPUSH
19061: LD_STRING D4-Pow-2
19063: PPUSH
19064: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19068: LD_ADDR_VAR 0 1
19072: PUSH
19073: DOUBLE
19074: LD_INT 1
19076: DEC
19077: ST_TO_ADDR
19078: LD_EXP 18
19082: PUSH
19083: LD_INT 1
19085: ARRAY
19086: PUSH
19087: FOR_TO
19088: IFFALSE 19181
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19090: LD_EXP 18
19094: PUSH
19095: LD_INT 1
19097: ARRAY
19098: PUSH
19099: LD_VAR 0 1
19103: ARRAY
19104: PPUSH
19105: LD_EXP 118
19109: PUSH
19110: LD_INT 4
19112: ARRAY
19113: PUSH
19114: LD_INT 1
19116: ARRAY
19117: PPUSH
19118: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19122: LD_ADDR_EXP 118
19126: PUSH
19127: LD_EXP 118
19131: PPUSH
19132: LD_INT 4
19134: PPUSH
19135: LD_EXP 118
19139: PUSH
19140: LD_INT 4
19142: ARRAY
19143: PPUSH
19144: LD_INT 1
19146: PPUSH
19147: CALL_OW 3
19151: PPUSH
19152: CALL_OW 1
19156: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19157: LD_INT 8
19159: PPUSH
19160: LD_EXP 18
19164: PUSH
19165: LD_INT 1
19167: ARRAY
19168: PUSH
19169: LD_VAR 0 1
19173: ARRAY
19174: PPUSH
19175: CALL_OW 471
// end ;
19179: GO 19087
19181: POP
19182: POP
// repeat wait ( 0 0$1 ) ;
19183: LD_INT 35
19185: PPUSH
19186: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19190: LD_EXP 18
19194: PUSH
19195: LD_INT 1
19197: ARRAY
19198: PPUSH
19199: LD_INT 55
19201: PUSH
19202: EMPTY
19203: LIST
19204: PPUSH
19205: CALL_OW 72
19209: PUSH
19210: LD_INT 4
19212: GREATEREQUAL
19213: IFFALSE 19183
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19215: LD_EXP 18
19219: PUSH
19220: LD_INT 1
19222: ARRAY
19223: PPUSH
19224: LD_INT 69
19226: PPUSH
19227: LD_INT 94
19229: PPUSH
19230: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19234: LD_EXP 18
19238: PUSH
19239: LD_INT 1
19241: ARRAY
19242: PPUSH
19243: LD_INT 82
19245: PPUSH
19246: LD_INT 83
19248: PPUSH
19249: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19253: LD_EXP 18
19257: PUSH
19258: LD_INT 1
19260: ARRAY
19261: PPUSH
19262: LD_INT 77
19264: PPUSH
19265: LD_INT 69
19267: PPUSH
19268: CALL_OW 174
// repeat wait ( 3 ) ;
19272: LD_INT 3
19274: PPUSH
19275: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19279: LD_ADDR_VAR 0 1
19283: PUSH
19284: LD_EXP 18
19288: PUSH
19289: LD_INT 1
19291: ARRAY
19292: PUSH
19293: FOR_IN
19294: IFFALSE 19430
// begin if GetLives ( i ) < 990 then
19296: LD_VAR 0 1
19300: PPUSH
19301: CALL_OW 256
19305: PUSH
19306: LD_INT 990
19308: LESS
19309: IFFALSE 19323
// SetLives ( i , 1000 ) ;
19311: LD_VAR 0 1
19315: PPUSH
19316: LD_INT 1000
19318: PPUSH
19319: CALL_OW 234
// if not IsInUnit ( i ) then
19323: LD_VAR 0 1
19327: PPUSH
19328: CALL_OW 310
19332: NOT
19333: IFFALSE 19428
// begin if not HasTask ( i ) then
19335: LD_VAR 0 1
19339: PPUSH
19340: CALL_OW 314
19344: NOT
19345: IFFALSE 19362
// ComMoveXY ( i , 64 , 93 ) ;
19347: LD_VAR 0 1
19351: PPUSH
19352: LD_INT 64
19354: PPUSH
19355: LD_INT 93
19357: PPUSH
19358: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19362: LD_VAR 0 4
19366: NOT
19367: PUSH
19368: LD_VAR 0 1
19372: PPUSH
19373: CALL_OW 258
19377: PUSH
19378: LD_INT 1
19380: EQUAL
19381: AND
19382: IFFALSE 19428
// begin retreat := true ;
19384: LD_ADDR_VAR 0 4
19388: PUSH
19389: LD_INT 1
19391: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19392: LD_VAR 0 1
19396: PPUSH
19397: LD_INT 2
19399: PPUSH
19400: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19404: LD_VAR 0 1
19408: PPUSH
19409: LD_STRING D4a-Sol1-1
19411: PPUSH
19412: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19416: LD_EXP 55
19420: PPUSH
19421: LD_STRING D4a-Pow-1
19423: PPUSH
19424: CALL_OW 88
// end ; end ; end ;
19428: GO 19293
19430: POP
19431: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19432: LD_EXP 18
19436: PUSH
19437: LD_INT 1
19439: ARRAY
19440: PPUSH
19441: LD_INT 95
19443: PUSH
19444: LD_INT 9
19446: PUSH
19447: EMPTY
19448: LIST
19449: LIST
19450: PUSH
19451: LD_INT 3
19453: PUSH
19454: LD_INT 55
19456: PUSH
19457: EMPTY
19458: LIST
19459: PUSH
19460: EMPTY
19461: LIST
19462: LIST
19463: PUSH
19464: EMPTY
19465: LIST
19466: LIST
19467: PPUSH
19468: CALL_OW 72
19472: PUSH
19473: LD_INT 4
19475: GREATEREQUAL
19476: IFFALSE 19272
// for i in powellSquadAttack [ 1 ] do
19478: LD_ADDR_VAR 0 1
19482: PUSH
19483: LD_EXP 18
19487: PUSH
19488: LD_INT 1
19490: ARRAY
19491: PUSH
19492: FOR_IN
19493: IFFALSE 19629
// begin if GetTag ( i ) = 2 then
19495: LD_VAR 0 1
19499: PPUSH
19500: CALL_OW 110
19504: PUSH
19505: LD_INT 2
19507: EQUAL
19508: IFFALSE 19570
// begin ComMoveXY ( i , 60 , 94 ) ;
19510: LD_VAR 0 1
19514: PPUSH
19515: LD_INT 60
19517: PPUSH
19518: LD_INT 94
19520: PPUSH
19521: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19525: LD_VAR 0 1
19529: PPUSH
19530: LD_EXP 55
19534: PPUSH
19535: CALL_OW 179
// wait ( 0 0$3 ) ;
19539: LD_INT 105
19541: PPUSH
19542: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19546: LD_VAR 0 1
19550: PPUSH
19551: LD_STRING D4a-Sol1-2
19553: PPUSH
19554: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19558: LD_EXP 55
19562: PPUSH
19563: LD_STRING D4a-Pow-2
19565: PPUSH
19566: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19570: LD_VAR 0 1
19574: PPUSH
19575: LD_INT 0
19577: PPUSH
19578: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19582: LD_ADDR_EXP 99
19586: PUSH
19587: LD_EXP 99
19591: PPUSH
19592: LD_INT 4
19594: PPUSH
19595: LD_EXP 99
19599: PUSH
19600: LD_INT 4
19602: ARRAY
19603: PUSH
19604: LD_VAR 0 1
19608: UNION
19609: PPUSH
19610: CALL_OW 1
19614: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19615: LD_INT 8
19617: PPUSH
19618: LD_VAR 0 1
19622: PPUSH
19623: CALL_OW 472
// end ;
19627: GO 19492
19629: POP
19630: POP
// wait ( 4 4$00 ) ;
19631: LD_INT 8400
19633: PPUSH
19634: CALL_OW 67
// uc_side := 6 ;
19638: LD_ADDR_OWVAR 20
19642: PUSH
19643: LD_INT 6
19645: ST_TO_ADDR
// uc_nation := 3 ;
19646: LD_ADDR_OWVAR 21
19650: PUSH
19651: LD_INT 3
19653: ST_TO_ADDR
// ru := [ ] ;
19654: LD_ADDR_VAR 0 7
19658: PUSH
19659: EMPTY
19660: ST_TO_ADDR
// for i = 1 to 4 do
19661: LD_ADDR_VAR 0 1
19665: PUSH
19666: DOUBLE
19667: LD_INT 1
19669: DEC
19670: ST_TO_ADDR
19671: LD_INT 4
19673: PUSH
19674: FOR_TO
19675: IFFALSE 19776
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
19677: LD_INT 22
19679: PPUSH
19680: LD_INT 1
19682: PPUSH
19683: LD_INT 3
19685: PPUSH
19686: LD_INT 43
19688: PUSH
19689: LD_INT 44
19691: PUSH
19692: EMPTY
19693: LIST
19694: LIST
19695: PUSH
19696: LD_INT 1
19698: PPUSH
19699: LD_INT 2
19701: PPUSH
19702: CALL_OW 12
19706: ARRAY
19707: PPUSH
19708: LD_INT 89
19710: PPUSH
19711: CALL 68561 0 5
// un := CreateVehicle ;
19715: LD_ADDR_VAR 0 8
19719: PUSH
19720: CALL_OW 45
19724: ST_TO_ADDR
// SetDir ( un , 4 ) ;
19725: LD_VAR 0 8
19729: PPUSH
19730: LD_INT 4
19732: PPUSH
19733: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
19737: LD_VAR 0 8
19741: PPUSH
19742: LD_INT 136
19744: PPUSH
19745: LD_INT 90
19747: PPUSH
19748: LD_INT 8
19750: PPUSH
19751: LD_INT 0
19753: PPUSH
19754: CALL_OW 50
// ru := ru ^ un ;
19758: LD_ADDR_VAR 0 7
19762: PUSH
19763: LD_VAR 0 7
19767: PUSH
19768: LD_VAR 0 8
19772: ADD
19773: ST_TO_ADDR
// end ;
19774: GO 19674
19776: POP
19777: POP
// if ru then
19778: LD_VAR 0 7
19782: IFFALSE 19799
// ComAgressiveMove ( ru , 80 , 92 ) ;
19784: LD_VAR 0 7
19788: PPUSH
19789: LD_INT 80
19791: PPUSH
19792: LD_INT 92
19794: PPUSH
19795: CALL_OW 114
// wait ( 8 8$00 ) ;
19799: LD_INT 16800
19801: PPUSH
19802: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
19806: LD_INT 4
19808: PPUSH
19809: LD_INT 3
19811: PUSH
19812: LD_INT 1
19814: PUSH
19815: LD_INT 1
19817: PUSH
19818: LD_INT 5
19820: PUSH
19821: EMPTY
19822: LIST
19823: LIST
19824: LIST
19825: LIST
19826: PUSH
19827: LD_INT 4
19829: PUSH
19830: LD_INT 1
19832: PUSH
19833: LD_INT 1
19835: PUSH
19836: LD_INT 6
19838: PUSH
19839: EMPTY
19840: LIST
19841: LIST
19842: LIST
19843: LIST
19844: PUSH
19845: LD_INT 4
19847: PUSH
19848: LD_INT 1
19850: PUSH
19851: LD_INT 1
19853: PUSH
19854: LD_INT 7
19856: PUSH
19857: EMPTY
19858: LIST
19859: LIST
19860: LIST
19861: LIST
19862: PUSH
19863: LD_INT 3
19865: PUSH
19866: LD_INT 1
19868: PUSH
19869: LD_INT 1
19871: PUSH
19872: LD_INT 7
19874: PUSH
19875: EMPTY
19876: LIST
19877: LIST
19878: LIST
19879: LIST
19880: PUSH
19881: LD_INT 3
19883: PUSH
19884: LD_INT 1
19886: PUSH
19887: LD_INT 1
19889: PUSH
19890: LD_INT 5
19892: PUSH
19893: EMPTY
19894: LIST
19895: LIST
19896: LIST
19897: LIST
19898: PUSH
19899: EMPTY
19900: LIST
19901: LIST
19902: LIST
19903: LIST
19904: LIST
19905: PPUSH
19906: CALL 55948 0 2
// missionStage := 4 ;
19910: LD_ADDR_EXP 15
19914: PUSH
19915: LD_INT 4
19917: ST_TO_ADDR
// end ;
19918: PPOPN 8
19920: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
19921: LD_EXP 15
19925: PUSH
19926: LD_INT 4
19928: EQUAL
19929: PUSH
19930: LD_INT 22
19932: PUSH
19933: LD_INT 4
19935: PUSH
19936: EMPTY
19937: LIST
19938: LIST
19939: PUSH
19940: LD_INT 21
19942: PUSH
19943: LD_INT 2
19945: PUSH
19946: EMPTY
19947: LIST
19948: LIST
19949: PUSH
19950: EMPTY
19951: LIST
19952: LIST
19953: PPUSH
19954: CALL_OW 69
19958: PUSH
19959: LD_INT 5
19961: GREATEREQUAL
19962: AND
19963: IFFALSE 24049
19965: GO 19967
19967: DISABLE
19968: LD_INT 0
19970: PPUSH
19971: PPUSH
19972: PPUSH
19973: PPUSH
19974: PPUSH
19975: PPUSH
19976: PPUSH
19977: PPUSH
19978: PPUSH
19979: PPUSH
19980: PPUSH
19981: PPUSH
19982: PPUSH
// begin missionStage := 5 ;
19983: LD_ADDR_EXP 15
19987: PUSH
19988: LD_INT 5
19990: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
19991: LD_ADDR_VAR 0 10
19995: PUSH
19996: LD_INT 22
19998: PUSH
19999: LD_INT 4
20001: PUSH
20002: EMPTY
20003: LIST
20004: LIST
20005: PUSH
20006: LD_INT 2
20008: PUSH
20009: LD_INT 30
20011: PUSH
20012: LD_INT 4
20014: PUSH
20015: EMPTY
20016: LIST
20017: LIST
20018: PUSH
20019: LD_INT 30
20021: PUSH
20022: LD_INT 5
20024: PUSH
20025: EMPTY
20026: LIST
20027: LIST
20028: PUSH
20029: EMPTY
20030: LIST
20031: LIST
20032: LIST
20033: PUSH
20034: EMPTY
20035: LIST
20036: LIST
20037: PPUSH
20038: CALL_OW 69
20042: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20043: LD_ADDR_VAR 0 6
20047: PUSH
20048: LD_INT 22
20050: PUSH
20051: LD_INT 4
20053: PUSH
20054: EMPTY
20055: LIST
20056: LIST
20057: PUSH
20058: LD_INT 21
20060: PUSH
20061: LD_INT 1
20063: PUSH
20064: EMPTY
20065: LIST
20066: LIST
20067: PUSH
20068: LD_INT 3
20070: PUSH
20071: LD_INT 25
20073: PUSH
20074: LD_INT 16
20076: PUSH
20077: EMPTY
20078: LIST
20079: LIST
20080: PUSH
20081: EMPTY
20082: LIST
20083: LIST
20084: PUSH
20085: LD_INT 3
20087: PUSH
20088: LD_INT 25
20090: PUSH
20091: LD_INT 12
20093: PUSH
20094: EMPTY
20095: LIST
20096: LIST
20097: PUSH
20098: EMPTY
20099: LIST
20100: LIST
20101: PUSH
20102: EMPTY
20103: LIST
20104: LIST
20105: LIST
20106: LIST
20107: PPUSH
20108: CALL_OW 69
20112: PUSH
20113: LD_EXP 55
20117: DIFF
20118: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20119: LD_ADDR_VAR 0 9
20123: PUSH
20124: LD_INT 22
20126: PUSH
20127: LD_INT 4
20129: PUSH
20130: EMPTY
20131: LIST
20132: LIST
20133: PUSH
20134: LD_INT 30
20136: PUSH
20137: LD_INT 3
20139: PUSH
20140: EMPTY
20141: LIST
20142: LIST
20143: PUSH
20144: EMPTY
20145: LIST
20146: LIST
20147: PPUSH
20148: CALL_OW 69
20152: PUSH
20153: LD_INT 1
20155: ARRAY
20156: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20157: LD_INT 35
20159: PPUSH
20160: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20164: LD_EXP 118
20168: PUSH
20169: LD_INT 4
20171: ARRAY
20172: PUSH
20173: LD_INT 5
20175: GREATEREQUAL
20176: PUSH
20177: LD_EXP 118
20181: PUSH
20182: LD_INT 4
20184: ARRAY
20185: PPUSH
20186: LD_INT 58
20188: PUSH
20189: EMPTY
20190: LIST
20191: PPUSH
20192: CALL_OW 72
20196: PUSH
20197: LD_INT 5
20199: GREATEREQUAL
20200: AND
20201: IFFALSE 20157
// powellAllowRetreat := false ;
20203: LD_ADDR_EXP 19
20207: PUSH
20208: LD_INT 0
20210: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20211: LD_INT 700
20213: PPUSH
20214: CALL_OW 67
// activeAttacks := false ;
20218: LD_ADDR_EXP 16
20222: PUSH
20223: LD_INT 0
20225: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20226: LD_INT 35
20228: PPUSH
20229: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20233: LD_INT 22
20235: PUSH
20236: LD_INT 6
20238: PUSH
20239: EMPTY
20240: LIST
20241: LIST
20242: PPUSH
20243: CALL_OW 69
20247: PUSH
20248: LD_INT 0
20250: EQUAL
20251: IFFALSE 20226
// tmp := mc_vehicles [ 4 ] ;
20253: LD_ADDR_VAR 0 3
20257: PUSH
20258: LD_EXP 118
20262: PUSH
20263: LD_INT 4
20265: ARRAY
20266: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20267: LD_ADDR_VAR 0 1
20271: PUSH
20272: DOUBLE
20273: LD_INT 1
20275: DEC
20276: ST_TO_ADDR
20277: LD_EXP 18
20281: PUSH
20282: FOR_TO
20283: IFFALSE 20544
// begin for j in powellSquadAttack [ i ] do
20285: LD_ADDR_VAR 0 2
20289: PUSH
20290: LD_EXP 18
20294: PUSH
20295: LD_VAR 0 1
20299: ARRAY
20300: PUSH
20301: FOR_IN
20302: IFFALSE 20540
// begin forces := forces diff j ;
20304: LD_ADDR_VAR 0 6
20308: PUSH
20309: LD_VAR 0 6
20313: PUSH
20314: LD_VAR 0 2
20318: DIFF
20319: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20320: LD_VAR 0 2
20324: PPUSH
20325: LD_INT 1
20327: PPUSH
20328: CALL_OW 109
// wait ( 0 0$2 ) ;
20332: LD_INT 70
20334: PPUSH
20335: CALL_OW 67
// if IsInUnit ( j ) then
20339: LD_VAR 0 2
20343: PPUSH
20344: CALL_OW 310
20348: IFFALSE 20359
// ComExitBuilding ( j ) ;
20350: LD_VAR 0 2
20354: PPUSH
20355: CALL_OW 122
// if GetClass ( j ) <> 1 then
20359: LD_VAR 0 2
20363: PPUSH
20364: CALL_OW 257
20368: PUSH
20369: LD_INT 1
20371: NONEQUAL
20372: IFFALSE 20452
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20374: LD_VAR 0 10
20378: PUSH
20379: LD_INT 1
20381: ARRAY
20382: PPUSH
20383: CALL_OW 313
20387: PUSH
20388: LD_INT 5
20390: GREATEREQUAL
20391: IFFALSE 20413
// AddComEnterUnit ( j , arm [ 2 ] ) else
20393: LD_VAR 0 2
20397: PPUSH
20398: LD_VAR 0 10
20402: PUSH
20403: LD_INT 2
20405: ARRAY
20406: PPUSH
20407: CALL_OW 180
20411: GO 20431
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20413: LD_VAR 0 2
20417: PPUSH
20418: LD_VAR 0 10
20422: PUSH
20423: LD_INT 1
20425: ARRAY
20426: PPUSH
20427: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20431: LD_VAR 0 2
20435: PPUSH
20436: LD_INT 1
20438: PPUSH
20439: CALL_OW 183
// AddComExitBuilding ( j ) ;
20443: LD_VAR 0 2
20447: PPUSH
20448: CALL_OW 182
// end ; if i = 2 then
20452: LD_VAR 0 1
20456: PUSH
20457: LD_INT 2
20459: EQUAL
20460: IFFALSE 20477
// AddComMoveXY ( j , 61 , 93 ) ;
20462: LD_VAR 0 2
20466: PPUSH
20467: LD_INT 61
20469: PPUSH
20470: LD_INT 93
20472: PPUSH
20473: CALL_OW 171
// if i = 1 then
20477: LD_VAR 0 1
20481: PUSH
20482: LD_INT 1
20484: EQUAL
20485: IFFALSE 20538
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20487: LD_VAR 0 2
20491: PPUSH
20492: LD_VAR 0 3
20496: PUSH
20497: LD_INT 1
20499: ARRAY
20500: PPUSH
20501: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20505: LD_ADDR_VAR 0 3
20509: PUSH
20510: LD_VAR 0 3
20514: PPUSH
20515: LD_INT 1
20517: PPUSH
20518: CALL_OW 3
20522: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20523: LD_VAR 0 2
20527: PPUSH
20528: LD_INT 69
20530: PPUSH
20531: LD_INT 94
20533: PPUSH
20534: CALL_OW 171
// end ; end ;
20538: GO 20301
20540: POP
20541: POP
// end ;
20542: GO 20282
20544: POP
20545: POP
// wait ( 0 0$55 ) ;
20546: LD_INT 1925
20548: PPUSH
20549: CALL_OW 67
// MC_Kill ( 4 ) ;
20553: LD_INT 4
20555: PPUSH
20556: CALL 33917 0 1
// tmp := UnitsInside ( fac ) ;
20560: LD_ADDR_VAR 0 3
20564: PUSH
20565: LD_VAR 0 9
20569: PPUSH
20570: CALL_OW 313
20574: ST_TO_ADDR
// if tmp then
20575: LD_VAR 0 3
20579: IFFALSE 20700
// for i in tmp do
20581: LD_ADDR_VAR 0 1
20585: PUSH
20586: LD_VAR 0 3
20590: PUSH
20591: FOR_IN
20592: IFFALSE 20698
// begin ComExitBuilding ( i ) ;
20594: LD_VAR 0 1
20598: PPUSH
20599: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20603: LD_VAR 0 10
20607: PUSH
20608: LD_INT 2
20610: ARRAY
20611: PPUSH
20612: CALL_OW 313
20616: PUSH
20617: LD_INT 6
20619: LESS
20620: IFFALSE 20642
// AddComEnterUnit ( i , arm [ 2 ] ) else
20622: LD_VAR 0 1
20626: PPUSH
20627: LD_VAR 0 10
20631: PUSH
20632: LD_INT 2
20634: ARRAY
20635: PPUSH
20636: CALL_OW 180
20640: GO 20696
// if UnitsInside ( arm [ 1 ] ) < 6 then
20642: LD_VAR 0 10
20646: PUSH
20647: LD_INT 1
20649: ARRAY
20650: PPUSH
20651: CALL_OW 313
20655: PUSH
20656: LD_INT 6
20658: LESS
20659: IFFALSE 20681
// AddComEnterUnit ( i , arm [ 1 ] ) else
20661: LD_VAR 0 1
20665: PPUSH
20666: LD_VAR 0 10
20670: PUSH
20671: LD_INT 1
20673: ARRAY
20674: PPUSH
20675: CALL_OW 180
20679: GO 20696
// AddComMoveXY ( i , 37 , 68 ) ;
20681: LD_VAR 0 1
20685: PPUSH
20686: LD_INT 37
20688: PPUSH
20689: LD_INT 68
20691: PPUSH
20692: CALL_OW 171
// end ;
20696: GO 20591
20698: POP
20699: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
20700: LD_ADDR_VAR 0 11
20704: PUSH
20705: LD_VAR 0 6
20709: PPUSH
20710: LD_INT 26
20712: PUSH
20713: LD_INT 1
20715: PUSH
20716: EMPTY
20717: LIST
20718: LIST
20719: PPUSH
20720: CALL_OW 72
20724: PUSH
20725: LD_EXP 56
20729: DIFF
20730: ST_TO_ADDR
// if not speaker then
20731: LD_VAR 0 11
20735: NOT
20736: IFFALSE 20763
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
20738: LD_ADDR_VAR 0 11
20742: PUSH
20743: LD_VAR 0 6
20747: PPUSH
20748: LD_INT 26
20750: PUSH
20751: LD_INT 1
20753: PUSH
20754: EMPTY
20755: LIST
20756: LIST
20757: PPUSH
20758: CALL_OW 72
20762: ST_TO_ADDR
// if speaker then
20763: LD_VAR 0 11
20767: IFFALSE 20783
// speaker := speaker [ 1 ] ;
20769: LD_ADDR_VAR 0 11
20773: PUSH
20774: LD_VAR 0 11
20778: PUSH
20779: LD_INT 1
20781: ARRAY
20782: ST_TO_ADDR
// Video ( true ) ;
20783: LD_INT 1
20785: PPUSH
20786: CALL 104216 0 1
// CenterNowOnUnits ( Powell ) ;
20790: LD_EXP 55
20794: PPUSH
20795: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
20799: LD_ADDR_VAR 0 3
20803: PUSH
20804: LD_VAR 0 6
20808: PPUSH
20809: LD_INT 3
20811: PUSH
20812: LD_INT 25
20814: PUSH
20815: LD_INT 1
20817: PUSH
20818: EMPTY
20819: LIST
20820: LIST
20821: PUSH
20822: EMPTY
20823: LIST
20824: LIST
20825: PPUSH
20826: CALL_OW 72
20830: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
20831: LD_ADDR_VAR 0 12
20835: PUSH
20836: LD_INT 22
20838: PUSH
20839: LD_INT 4
20841: PUSH
20842: EMPTY
20843: LIST
20844: LIST
20845: PUSH
20846: LD_INT 30
20848: PUSH
20849: LD_INT 32
20851: PUSH
20852: EMPTY
20853: LIST
20854: LIST
20855: PUSH
20856: LD_INT 58
20858: PUSH
20859: EMPTY
20860: LIST
20861: PUSH
20862: EMPTY
20863: LIST
20864: LIST
20865: LIST
20866: PPUSH
20867: CALL_OW 69
20871: ST_TO_ADDR
// for i = 1 to 6 do
20872: LD_ADDR_VAR 0 1
20876: PUSH
20877: DOUBLE
20878: LD_INT 1
20880: DEC
20881: ST_TO_ADDR
20882: LD_INT 6
20884: PUSH
20885: FOR_TO
20886: IFFALSE 21027
// begin if IsInUnit ( tmp [ i ] ) then
20888: LD_VAR 0 3
20892: PUSH
20893: LD_VAR 0 1
20897: ARRAY
20898: PPUSH
20899: CALL_OW 310
20903: IFFALSE 20920
// ComExitBuilding ( tmp [ i ] ) ;
20905: LD_VAR 0 3
20909: PUSH
20910: LD_VAR 0 1
20914: ARRAY
20915: PPUSH
20916: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
20920: LD_VAR 0 3
20924: PUSH
20925: LD_VAR 0 1
20929: ARRAY
20930: PPUSH
20931: LD_VAR 0 10
20935: PUSH
20936: LD_INT 1
20938: ARRAY
20939: PPUSH
20940: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
20944: LD_VAR 0 3
20948: PUSH
20949: LD_VAR 0 1
20953: ARRAY
20954: PPUSH
20955: LD_INT 1
20957: PPUSH
20958: CALL_OW 183
// if emp_towers then
20962: LD_VAR 0 12
20966: IFFALSE 21025
// begin AddComExitBuilding ( tmp [ i ] ) ;
20968: LD_VAR 0 3
20972: PUSH
20973: LD_VAR 0 1
20977: ARRAY
20978: PPUSH
20979: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
20983: LD_VAR 0 3
20987: PUSH
20988: LD_VAR 0 1
20992: ARRAY
20993: PPUSH
20994: LD_VAR 0 12
20998: PUSH
20999: LD_INT 1
21001: ARRAY
21002: PPUSH
21003: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21007: LD_ADDR_VAR 0 12
21011: PUSH
21012: LD_VAR 0 12
21016: PPUSH
21017: LD_INT 1
21019: PPUSH
21020: CALL_OW 3
21024: ST_TO_ADDR
// end ; end ;
21025: GO 20885
21027: POP
21028: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21029: LD_ADDR_VAR 0 3
21033: PUSH
21034: LD_EXP 18
21038: PUSH
21039: LD_INT 1
21041: ARRAY
21042: PUSH
21043: LD_EXP 18
21047: PUSH
21048: LD_INT 2
21050: ARRAY
21051: ADD
21052: PPUSH
21053: LD_INT 26
21055: PUSH
21056: LD_INT 1
21058: PUSH
21059: EMPTY
21060: LIST
21061: LIST
21062: PPUSH
21063: CALL_OW 72
21067: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21068: LD_ADDR_VAR 0 1
21072: PUSH
21073: LD_EXP 18
21077: PUSH
21078: LD_INT 2
21080: ARRAY
21081: PUSH
21082: FOR_IN
21083: IFFALSE 21101
// ComTurnUnit ( i , Powell ) ;
21085: LD_VAR 0 1
21089: PPUSH
21090: LD_EXP 55
21094: PPUSH
21095: CALL_OW 119
21099: GO 21082
21101: POP
21102: POP
// Say ( Powell , D5-Pow-1 ) ;
21103: LD_EXP 55
21107: PPUSH
21108: LD_STRING D5-Pow-1
21110: PPUSH
21111: CALL_OW 88
// if tmp then
21115: LD_VAR 0 3
21119: IFFALSE 21137
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21121: LD_VAR 0 3
21125: PUSH
21126: LD_INT 1
21128: ARRAY
21129: PPUSH
21130: LD_STRING D5-Sol2-1
21132: PPUSH
21133: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21137: LD_EXP 55
21141: PPUSH
21142: LD_STRING D5-Pow-2
21144: PPUSH
21145: CALL_OW 88
// if tmp > 1 then
21149: LD_VAR 0 3
21153: PUSH
21154: LD_INT 1
21156: GREATER
21157: IFFALSE 21175
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21159: LD_VAR 0 3
21163: PUSH
21164: LD_INT 2
21166: ARRAY
21167: PPUSH
21168: LD_STRING D5-Sol2-2
21170: PPUSH
21171: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21175: LD_EXP 55
21179: PPUSH
21180: LD_STRING D5-Pow-3
21182: PPUSH
21183: CALL_OW 88
// wait ( 0 0$1 ) ;
21187: LD_INT 35
21189: PPUSH
21190: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21194: LD_ADDR_VAR 0 3
21198: PUSH
21199: LD_EXP 18
21203: PUSH
21204: LD_INT 1
21206: ARRAY
21207: PUSH
21208: LD_EXP 18
21212: PUSH
21213: LD_INT 2
21215: ARRAY
21216: UNION
21217: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21218: LD_VAR 0 3
21222: PPUSH
21223: LD_INT 80
21225: PPUSH
21226: LD_INT 67
21228: PPUSH
21229: CALL_OW 114
// wait ( 0 0$2 ) ;
21233: LD_INT 70
21235: PPUSH
21236: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21240: LD_INT 79
21242: PPUSH
21243: LD_INT 72
21245: PPUSH
21246: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21250: LD_INT 35
21252: PPUSH
21253: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21257: LD_VAR 0 3
21261: PPUSH
21262: LD_INT 3
21264: PUSH
21265: LD_INT 24
21267: PUSH
21268: LD_INT 1000
21270: PUSH
21271: EMPTY
21272: LIST
21273: LIST
21274: PUSH
21275: EMPTY
21276: LIST
21277: LIST
21278: PPUSH
21279: CALL_OW 72
21283: IFFALSE 21250
// Say ( Powell , D5a-Pow-1 ) ;
21285: LD_EXP 55
21289: PPUSH
21290: LD_STRING D5a-Pow-1
21292: PPUSH
21293: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21297: LD_EXP 55
21301: PPUSH
21302: LD_STRING D5a-Pow-1a
21304: PPUSH
21305: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21309: LD_INT 10
21311: PPUSH
21312: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21316: LD_EXP 55
21320: PPUSH
21321: LD_STRING D5a-Pow-1b
21323: PPUSH
21324: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21328: LD_EXP 55
21332: PPUSH
21333: LD_STRING D5a-Pow-1c
21335: PPUSH
21336: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21340: LD_EXP 55
21344: PPUSH
21345: LD_STRING D5a-Pow-1d
21347: PPUSH
21348: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21352: LD_INT 35
21354: PPUSH
21355: CALL_OW 67
// if not HasTask ( tmp ) then
21359: LD_VAR 0 3
21363: PPUSH
21364: CALL_OW 314
21368: NOT
21369: IFFALSE 21386
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21371: LD_VAR 0 3
21375: PPUSH
21376: LD_INT 80
21378: PPUSH
21379: LD_INT 67
21381: PPUSH
21382: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21386: LD_VAR 0 3
21390: PPUSH
21391: LD_INT 24
21393: PUSH
21394: LD_INT 1
21396: PUSH
21397: EMPTY
21398: LIST
21399: LIST
21400: PPUSH
21401: CALL_OW 72
21405: NOT
21406: IFFALSE 21352
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21408: LD_ADDR_VAR 0 3
21412: PUSH
21413: LD_INT 22
21415: PUSH
21416: LD_INT 4
21418: PUSH
21419: EMPTY
21420: LIST
21421: LIST
21422: PUSH
21423: LD_INT 92
21425: PUSH
21426: LD_INT 60
21428: PUSH
21429: LD_INT 93
21431: PUSH
21432: LD_INT 10
21434: PUSH
21435: EMPTY
21436: LIST
21437: LIST
21438: LIST
21439: LIST
21440: PUSH
21441: LD_INT 3
21443: PUSH
21444: LD_INT 54
21446: PUSH
21447: EMPTY
21448: LIST
21449: PUSH
21450: EMPTY
21451: LIST
21452: LIST
21453: PUSH
21454: EMPTY
21455: LIST
21456: LIST
21457: LIST
21458: PPUSH
21459: CALL_OW 69
21463: PUSH
21464: LD_EXP 55
21468: DIFF
21469: ST_TO_ADDR
// if tmp then
21470: LD_VAR 0 3
21474: IFFALSE 21508
// for i in tmp do
21476: LD_ADDR_VAR 0 1
21480: PUSH
21481: LD_VAR 0 3
21485: PUSH
21486: FOR_IN
21487: IFFALSE 21506
// ComMoveXY ( i , 36 , 67 ) ;
21489: LD_VAR 0 1
21493: PPUSH
21494: LD_INT 36
21496: PPUSH
21497: LD_INT 67
21499: PPUSH
21500: CALL_OW 111
21504: GO 21486
21506: POP
21507: POP
// wait ( 0 0$3 ) ;
21508: LD_INT 105
21510: PPUSH
21511: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21515: LD_VAR 0 11
21519: PPUSH
21520: LD_STRING D6-Sol3-1
21522: PPUSH
21523: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21527: LD_EXP 55
21531: PPUSH
21532: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21536: LD_EXP 55
21540: PPUSH
21541: LD_STRING D6-Pow-1
21543: PPUSH
21544: CALL_OW 88
// tmp := [ ] ;
21548: LD_ADDR_VAR 0 3
21552: PUSH
21553: EMPTY
21554: ST_TO_ADDR
// for i = 1 to 2 do
21555: LD_ADDR_VAR 0 1
21559: PUSH
21560: DOUBLE
21561: LD_INT 1
21563: DEC
21564: ST_TO_ADDR
21565: LD_INT 2
21567: PUSH
21568: FOR_TO
21569: IFFALSE 21676
// begin uc_side := 8 ;
21571: LD_ADDR_OWVAR 20
21575: PUSH
21576: LD_INT 8
21578: ST_TO_ADDR
// uc_nation := 2 ;
21579: LD_ADDR_OWVAR 21
21583: PUSH
21584: LD_INT 2
21586: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21587: LD_INT 14
21589: PPUSH
21590: LD_INT 3
21592: PPUSH
21593: LD_INT 2
21595: PPUSH
21596: LD_INT 29
21598: PPUSH
21599: LD_INT 100
21601: PPUSH
21602: CALL 68561 0 5
// veh := CreateVehicle ;
21606: LD_ADDR_VAR 0 13
21610: PUSH
21611: CALL_OW 45
21615: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21616: LD_VAR 0 13
21620: PPUSH
21621: LD_INT 4
21623: PPUSH
21624: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 5 , false ) ;
21628: LD_VAR 0 13
21632: PPUSH
21633: LD_INT 99
21635: PPUSH
21636: LD_INT 83
21638: PPUSH
21639: LD_INT 5
21641: PPUSH
21642: LD_INT 0
21644: PPUSH
21645: CALL_OW 50
// Connect ( veh ) ;
21649: LD_VAR 0 13
21653: PPUSH
21654: CALL 71616 0 1
// tmp := tmp ^ veh ;
21658: LD_ADDR_VAR 0 3
21662: PUSH
21663: LD_VAR 0 3
21667: PUSH
21668: LD_VAR 0 13
21672: ADD
21673: ST_TO_ADDR
// end ;
21674: GO 21568
21676: POP
21677: POP
// wait ( 0 0$1 ) ;
21678: LD_INT 35
21680: PPUSH
21681: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
21685: LD_INT 99
21687: PPUSH
21688: LD_INT 83
21690: PPUSH
21691: LD_INT 1
21693: PPUSH
21694: LD_INT 10
21696: PPUSH
21697: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
21701: LD_INT 99
21703: PPUSH
21704: LD_INT 83
21706: PPUSH
21707: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
21711: LD_VAR 0 11
21715: PPUSH
21716: LD_STRING D6-Sol3-2
21718: PPUSH
21719: CALL_OW 88
// async ;
21723: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
21724: LD_EXP 55
21728: PPUSH
21729: LD_STRING D6-Pow-2
21731: PPUSH
21732: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
21736: LD_VAR 0 3
21740: PUSH
21741: LD_INT 1
21743: ARRAY
21744: PPUSH
21745: LD_VAR 0 9
21749: PPUSH
21750: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
21754: LD_VAR 0 3
21758: PUSH
21759: LD_INT 2
21761: ARRAY
21762: PPUSH
21763: LD_INT 22
21765: PUSH
21766: LD_INT 4
21768: PUSH
21769: EMPTY
21770: LIST
21771: LIST
21772: PUSH
21773: LD_INT 21
21775: PUSH
21776: LD_INT 3
21778: PUSH
21779: EMPTY
21780: LIST
21781: LIST
21782: PUSH
21783: EMPTY
21784: LIST
21785: LIST
21786: PPUSH
21787: CALL_OW 69
21791: PPUSH
21792: LD_VAR 0 3
21796: PUSH
21797: LD_INT 2
21799: ARRAY
21800: PPUSH
21801: CALL_OW 74
21805: PPUSH
21806: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
21810: LD_EXP 55
21814: PPUSH
21815: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
21819: LD_INT 99
21821: PPUSH
21822: LD_INT 83
21824: PPUSH
21825: LD_INT 1
21827: PPUSH
21828: CALL_OW 331
// repeat wait ( 4 ) ;
21832: LD_INT 4
21834: PPUSH
21835: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
21839: LD_VAR 0 3
21843: PUSH
21844: LD_INT 1
21846: ARRAY
21847: PPUSH
21848: CALL_OW 256
21852: PUSH
21853: LD_INT 1000
21855: LESS
21856: IFFALSE 21874
// SetLives ( tmp [ 1 ] , 1000 ) ;
21858: LD_VAR 0 3
21862: PUSH
21863: LD_INT 1
21865: ARRAY
21866: PPUSH
21867: LD_INT 1000
21869: PPUSH
21870: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
21874: LD_INT 22
21876: PUSH
21877: LD_INT 4
21879: PUSH
21880: EMPTY
21881: LIST
21882: LIST
21883: PUSH
21884: LD_INT 30
21886: PUSH
21887: LD_INT 3
21889: PUSH
21890: EMPTY
21891: LIST
21892: LIST
21893: PUSH
21894: EMPTY
21895: LIST
21896: LIST
21897: PPUSH
21898: CALL_OW 69
21902: PUSH
21903: LD_INT 0
21905: EQUAL
21906: IFFALSE 21832
// sync ;
21908: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
21909: LD_EXP 55
21913: PPUSH
21914: LD_STRING D6a-Pow-1
21916: PPUSH
21917: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
21921: LD_VAR 0 11
21925: PPUSH
21926: LD_STRING D6a-Sol3-1
21928: PPUSH
21929: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
21933: LD_EXP 55
21937: PPUSH
21938: LD_STRING D6a-Pow-2
21940: PPUSH
21941: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
21945: LD_VAR 0 11
21949: PPUSH
21950: LD_STRING D6a-Sol3-2
21952: PPUSH
21953: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
21957: LD_EXP 55
21961: PPUSH
21962: LD_STRING D6a-Pow-3
21964: PPUSH
21965: CALL_OW 88
// powellCenterCameraMode := true ;
21969: LD_ADDR_EXP 20
21973: PUSH
21974: LD_INT 1
21976: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
21977: LD_ADDR_VAR 0 1
21981: PUSH
21982: LD_INT 22
21984: PUSH
21985: LD_INT 8
21987: PUSH
21988: EMPTY
21989: LIST
21990: LIST
21991: PUSH
21992: LD_INT 25
21994: PUSH
21995: LD_INT 2
21997: PUSH
21998: EMPTY
21999: LIST
22000: LIST
22001: PUSH
22002: EMPTY
22003: LIST
22004: LIST
22005: PPUSH
22006: CALL_OW 69
22010: PUSH
22011: FOR_IN
22012: IFFALSE 22067
// begin SetTag ( i , 1 ) ;
22014: LD_VAR 0 1
22018: PPUSH
22019: LD_INT 1
22021: PPUSH
22022: CALL_OW 109
// ComExitBuilding ( i ) ;
22026: LD_VAR 0 1
22030: PPUSH
22031: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22035: LD_VAR 0 1
22039: PPUSH
22040: LD_INT 35
22042: PPUSH
22043: LD_INT 6
22045: PPUSH
22046: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22050: LD_VAR 0 1
22054: PPUSH
22055: LD_INT 53
22057: PPUSH
22058: LD_INT 4
22060: PPUSH
22061: CALL_OW 171
// end ;
22065: GO 22011
22067: POP
22068: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22069: LD_ADDR_VAR 0 3
22073: PUSH
22074: LD_INT 22
22076: PUSH
22077: LD_INT 4
22079: PUSH
22080: EMPTY
22081: LIST
22082: LIST
22083: PUSH
22084: LD_INT 21
22086: PUSH
22087: LD_INT 2
22089: PUSH
22090: EMPTY
22091: LIST
22092: LIST
22093: PUSH
22094: LD_INT 3
22096: PUSH
22097: LD_INT 34
22099: PUSH
22100: LD_INT 12
22102: PUSH
22103: EMPTY
22104: LIST
22105: LIST
22106: PUSH
22107: EMPTY
22108: LIST
22109: LIST
22110: PUSH
22111: EMPTY
22112: LIST
22113: LIST
22114: LIST
22115: PPUSH
22116: CALL_OW 69
22120: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22121: LD_EXP 55
22125: PPUSH
22126: LD_VAR 0 3
22130: PPUSH
22131: LD_EXP 55
22135: PPUSH
22136: CALL_OW 74
22140: PPUSH
22141: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22145: LD_EXP 55
22149: PPUSH
22150: LD_INT 100
22152: PPUSH
22153: LD_INT 88
22155: PPUSH
22156: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22160: LD_EXP 55
22164: PPUSH
22165: LD_INT 100
22167: PPUSH
22168: LD_INT 75
22170: PPUSH
22171: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22175: LD_EXP 55
22179: PPUSH
22180: LD_INT 88
22182: PPUSH
22183: LD_INT 53
22185: PPUSH
22186: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22190: LD_INT 8
22192: PPUSH
22193: LD_EXP 55
22197: PPUSH
22198: CALL_OW 471
// repeat wait ( 3 ) ;
22202: LD_INT 3
22204: PPUSH
22205: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22209: LD_INT 22
22211: PUSH
22212: LD_INT 4
22214: PUSH
22215: EMPTY
22216: LIST
22217: LIST
22218: PUSH
22219: LD_INT 92
22221: PUSH
22222: LD_INT 100
22224: PUSH
22225: LD_INT 75
22227: PUSH
22228: LD_INT 6
22230: PUSH
22231: EMPTY
22232: LIST
22233: LIST
22234: LIST
22235: LIST
22236: PUSH
22237: EMPTY
22238: LIST
22239: LIST
22240: PPUSH
22241: CALL_OW 69
22245: IFFALSE 22202
// async ;
22247: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22248: LD_EXP 55
22252: PPUSH
22253: LD_STRING D6b-Pow-1
22255: PPUSH
22256: CALL_OW 88
// repeat wait ( 3 ) ;
22260: LD_INT 3
22262: PPUSH
22263: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22267: LD_EXP 55
22271: PPUSH
22272: CALL_OW 310
22276: PPUSH
22277: CALL_OW 256
22281: PUSH
22282: LD_INT 1000
22284: LESS
22285: IFFALSE 22304
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22287: LD_EXP 55
22291: PPUSH
22292: CALL_OW 310
22296: PPUSH
22297: LD_INT 1000
22299: PPUSH
22300: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22304: LD_EXP 55
22308: PPUSH
22309: CALL_OW 256
22313: PUSH
22314: LD_INT 1000
22316: LESS
22317: IFFALSE 22331
// SetLives ( Powell , 1000 ) ;
22319: LD_EXP 55
22323: PPUSH
22324: LD_INT 1000
22326: PPUSH
22327: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22331: LD_EXP 55
22335: PPUSH
22336: LD_EXP 60
22340: PPUSH
22341: CALL_OW 296
22345: PUSH
22346: LD_INT 5
22348: LESS
22349: PUSH
22350: LD_EXP 55
22354: PPUSH
22355: CALL_OW 310
22359: PPUSH
22360: LD_EXP 60
22364: PPUSH
22365: CALL_OW 296
22369: PUSH
22370: LD_INT 5
22372: LESS
22373: OR
22374: IFFALSE 22393
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22376: LD_EXP 55
22380: PPUSH
22381: CALL_OW 310
22385: PPUSH
22386: LD_INT 100
22388: PPUSH
22389: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22393: LD_EXP 55
22397: PPUSH
22398: CALL_OW 310
22402: NOT
22403: IFFALSE 22260
// game_speed := 4 ;
22405: LD_ADDR_OWVAR 65
22409: PUSH
22410: LD_INT 4
22412: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22413: LD_EXP 55
22417: PPUSH
22418: LD_STRING D6b-Pow-1a
22420: PPUSH
22421: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22425: LD_EXP 55
22429: PPUSH
22430: LD_EXP 60
22434: PPUSH
22435: CALL_OW 180
// sync ;
22439: SYNC
// repeat wait ( 0 0$1 ) ;
22440: LD_INT 35
22442: PPUSH
22443: CALL_OW 67
// until IsInUnit ( Powell ) ;
22447: LD_EXP 55
22451: PPUSH
22452: CALL_OW 310
22456: IFFALSE 22440
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22458: LD_INT 8
22460: PPUSH
22461: LD_EXP 55
22465: PPUSH
22466: CALL_OW 310
22470: PPUSH
22471: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22475: LD_EXP 55
22479: PPUSH
22480: LD_INT 91
22482: PPUSH
22483: LD_INT 44
22485: PPUSH
22486: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22490: LD_EXP 55
22494: PPUSH
22495: LD_INT 96
22497: PPUSH
22498: LD_INT 44
22500: PPUSH
22501: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22505: LD_EXP 55
22509: PPUSH
22510: LD_INT 96
22512: PPUSH
22513: LD_INT 41
22515: PPUSH
22516: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22520: LD_EXP 55
22524: PPUSH
22525: LD_INT 92
22527: PPUSH
22528: LD_INT 39
22530: PPUSH
22531: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22535: LD_EXP 55
22539: PPUSH
22540: LD_INT 88
22542: PPUSH
22543: LD_INT 41
22545: PPUSH
22546: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22550: LD_EXP 55
22554: PPUSH
22555: LD_INT 91
22557: PPUSH
22558: LD_INT 44
22560: PPUSH
22561: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22565: LD_EXP 55
22569: PPUSH
22570: LD_INT 96
22572: PPUSH
22573: LD_INT 44
22575: PPUSH
22576: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22580: LD_EXP 55
22584: PPUSH
22585: LD_INT 96
22587: PPUSH
22588: LD_INT 41
22590: PPUSH
22591: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22595: LD_EXP 55
22599: PPUSH
22600: LD_INT 92
22602: PPUSH
22603: LD_INT 39
22605: PPUSH
22606: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22610: LD_EXP 55
22614: PPUSH
22615: LD_INT 88
22617: PPUSH
22618: LD_INT 41
22620: PPUSH
22621: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22625: LD_EXP 55
22629: PPUSH
22630: LD_INT 91
22632: PPUSH
22633: LD_INT 44
22635: PPUSH
22636: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22640: LD_EXP 55
22644: PPUSH
22645: LD_INT 93
22647: PPUSH
22648: LD_INT 39
22650: PPUSH
22651: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
22655: LD_EXP 55
22659: PPUSH
22660: LD_INT 93
22662: PPUSH
22663: LD_INT 36
22665: PPUSH
22666: CALL_OW 171
// wait ( 0 0$3.5 ) ;
22670: LD_INT 122
22672: PPUSH
22673: CALL_OW 67
// game_speed := 4 ;
22677: LD_ADDR_OWVAR 65
22681: PUSH
22682: LD_INT 4
22684: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
22685: LD_EXP 55
22689: PPUSH
22690: LD_STRING D6b-Pow-1b
22692: PPUSH
22693: CALL_OW 88
// tmp := [ ] ;
22697: LD_ADDR_VAR 0 3
22701: PUSH
22702: EMPTY
22703: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
22704: LD_ADDR_VAR 0 5
22708: PUSH
22709: LD_INT 78
22711: PUSH
22712: LD_INT 47
22714: PUSH
22715: EMPTY
22716: LIST
22717: LIST
22718: PUSH
22719: LD_INT 106
22721: PUSH
22722: LD_INT 53
22724: PUSH
22725: EMPTY
22726: LIST
22727: LIST
22728: PUSH
22729: EMPTY
22730: LIST
22731: LIST
22732: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
22733: LD_ADDR_VAR 0 1
22737: PUSH
22738: LD_INT 22
22740: PUSH
22741: LD_INT 8
22743: PUSH
22744: EMPTY
22745: LIST
22746: LIST
22747: PUSH
22748: LD_INT 21
22750: PUSH
22751: LD_INT 3
22753: PUSH
22754: EMPTY
22755: LIST
22756: LIST
22757: PUSH
22758: LD_INT 92
22760: PUSH
22761: LD_INT 90
22763: PUSH
22764: LD_INT 52
22766: PUSH
22767: LD_INT 12
22769: PUSH
22770: EMPTY
22771: LIST
22772: LIST
22773: LIST
22774: LIST
22775: PUSH
22776: EMPTY
22777: LIST
22778: LIST
22779: LIST
22780: PPUSH
22781: CALL_OW 69
22785: PUSH
22786: FOR_IN
22787: IFFALSE 22812
// tmp := tmp ^ UnitsInside ( i ) ;
22789: LD_ADDR_VAR 0 3
22793: PUSH
22794: LD_VAR 0 3
22798: PUSH
22799: LD_VAR 0 1
22803: PPUSH
22804: CALL_OW 313
22808: ADD
22809: ST_TO_ADDR
22810: GO 22786
22812: POP
22813: POP
// for i in tmp do
22814: LD_ADDR_VAR 0 1
22818: PUSH
22819: LD_VAR 0 3
22823: PUSH
22824: FOR_IN
22825: IFFALSE 22987
// begin dist := 9999 ;
22827: LD_ADDR_VAR 0 8
22831: PUSH
22832: LD_INT 9999
22834: ST_TO_ADDR
// _xy := [ ] ;
22835: LD_ADDR_VAR 0 7
22839: PUSH
22840: EMPTY
22841: ST_TO_ADDR
// SetTag ( i , 1 ) ;
22842: LD_VAR 0 1
22846: PPUSH
22847: LD_INT 1
22849: PPUSH
22850: CALL_OW 109
// ComExitBuilding ( i ) ;
22854: LD_VAR 0 1
22858: PPUSH
22859: CALL_OW 122
// for j in xy do
22863: LD_ADDR_VAR 0 2
22867: PUSH
22868: LD_VAR 0 5
22872: PUSH
22873: FOR_IN
22874: IFFALSE 22956
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
22876: LD_VAR 0 1
22880: PPUSH
22881: LD_VAR 0 2
22885: PUSH
22886: LD_INT 1
22888: ARRAY
22889: PPUSH
22890: LD_VAR 0 2
22894: PUSH
22895: LD_INT 2
22897: ARRAY
22898: PPUSH
22899: CALL_OW 297
22903: PUSH
22904: LD_VAR 0 8
22908: LESS
22909: IFFALSE 22954
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
22911: LD_ADDR_VAR 0 8
22915: PUSH
22916: LD_VAR 0 1
22920: PPUSH
22921: LD_VAR 0 2
22925: PUSH
22926: LD_INT 1
22928: ARRAY
22929: PPUSH
22930: LD_VAR 0 2
22934: PUSH
22935: LD_INT 2
22937: ARRAY
22938: PPUSH
22939: CALL_OW 297
22943: ST_TO_ADDR
// _xy := j ;
22944: LD_ADDR_VAR 0 7
22948: PUSH
22949: LD_VAR 0 2
22953: ST_TO_ADDR
// end ;
22954: GO 22873
22956: POP
22957: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
22958: LD_VAR 0 1
22962: PPUSH
22963: LD_VAR 0 7
22967: PUSH
22968: LD_INT 1
22970: ARRAY
22971: PPUSH
22972: LD_VAR 0 7
22976: PUSH
22977: LD_INT 2
22979: ARRAY
22980: PPUSH
22981: CALL_OW 171
// end ;
22985: GO 22824
22987: POP
22988: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
22989: LD_ADDR_VAR 0 4
22993: PUSH
22994: LD_VAR 0 3
22998: PPUSH
22999: LD_INT 26
23001: PUSH
23002: LD_INT 1
23004: PUSH
23005: EMPTY
23006: LIST
23007: LIST
23008: PUSH
23009: LD_INT 25
23011: PUSH
23012: LD_INT 1
23014: PUSH
23015: EMPTY
23016: LIST
23017: LIST
23018: PUSH
23019: EMPTY
23020: LIST
23021: LIST
23022: PPUSH
23023: CALL_OW 72
23027: ST_TO_ADDR
// if tmp2 < 2 then
23028: LD_VAR 0 4
23032: PUSH
23033: LD_INT 2
23035: LESS
23036: IFFALSE 23105
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23038: LD_ADDR_VAR 0 4
23042: PUSH
23043: LD_INT 22
23045: PUSH
23046: LD_INT 8
23048: PUSH
23049: EMPTY
23050: LIST
23051: LIST
23052: PUSH
23053: LD_INT 26
23055: PUSH
23056: LD_INT 1
23058: PUSH
23059: EMPTY
23060: LIST
23061: LIST
23062: PUSH
23063: LD_INT 3
23065: PUSH
23066: LD_INT 25
23068: PUSH
23069: LD_INT 15
23071: PUSH
23072: EMPTY
23073: LIST
23074: LIST
23075: PUSH
23076: EMPTY
23077: LIST
23078: LIST
23079: PUSH
23080: EMPTY
23081: LIST
23082: LIST
23083: LIST
23084: PPUSH
23085: CALL_OW 69
23089: PUSH
23090: LD_EXP 57
23094: PUSH
23095: LD_EXP 58
23099: PUSH
23100: EMPTY
23101: LIST
23102: LIST
23103: DIFF
23104: ST_TO_ADDR
// if tmp2 then
23105: LD_VAR 0 4
23109: IFFALSE 23127
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23111: LD_VAR 0 4
23115: PUSH
23116: LD_INT 1
23118: ARRAY
23119: PPUSH
23120: LD_STRING D6b-ArSol1-1
23122: PPUSH
23123: CALL_OW 88
// async ;
23127: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23128: LD_EXP 55
23132: PPUSH
23133: LD_STRING D6b-Pow-2
23135: PPUSH
23136: CALL_OW 88
// wait ( 0 0$1 ) ;
23140: LD_INT 35
23142: PPUSH
23143: CALL_OW 67
// if tmp2 > 1 then
23147: LD_VAR 0 4
23151: PUSH
23152: LD_INT 1
23154: GREATER
23155: IFFALSE 23173
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23157: LD_VAR 0 4
23161: PUSH
23162: LD_INT 2
23164: ARRAY
23165: PPUSH
23166: LD_STRING D6b-ArSol2-1
23168: PPUSH
23169: CALL_OW 88
// sync ;
23173: SYNC
// repeat wait ( 5 ) ;
23174: LD_INT 5
23176: PPUSH
23177: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23181: LD_INT 93
23183: PPUSH
23184: LD_INT 36
23186: PPUSH
23187: CALL_OW 428
23191: PPUSH
23192: CALL_OW 255
23196: PUSH
23197: LD_INT 4
23199: EQUAL
23200: IFFALSE 23174
// DialogueOn ;
23202: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23206: LD_INT 10
23208: PPUSH
23209: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23213: LD_EXP 55
23217: PPUSH
23218: LD_STRING D6b-Pow-2a
23220: PPUSH
23221: CALL_OW 88
// DialogueOff ;
23225: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23229: LD_EXP 55
23233: PPUSH
23234: CALL_OW 310
23238: PPUSH
23239: LD_INT 332
23241: PPUSH
23242: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23246: LD_INT 93
23248: PPUSH
23249: LD_INT 35
23251: PPUSH
23252: LD_INT 1
23254: PPUSH
23255: LD_INT 6
23257: NEG
23258: PPUSH
23259: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23263: LD_INT 35
23265: PPUSH
23266: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23270: LD_INT 332
23272: PPUSH
23273: CALL_OW 256
23277: PUSH
23278: LD_INT 1000
23280: LESS
23281: PUSH
23282: LD_INT 332
23284: PPUSH
23285: CALL_OW 300
23289: AND
23290: IFFALSE 23302
// SetLives ( kozlov_fac , 0 ) ;
23292: LD_INT 332
23294: PPUSH
23295: LD_INT 0
23297: PPUSH
23298: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23302: LD_INT 332
23304: PPUSH
23305: CALL_OW 301
23309: PUSH
23310: LD_EXP 55
23314: PPUSH
23315: CALL_OW 301
23319: OR
23320: IFFALSE 23263
// game_speed := 4 ;
23322: LD_ADDR_OWVAR 65
23326: PUSH
23327: LD_INT 4
23329: ST_TO_ADDR
// powellCenterCameraMode := false ;
23330: LD_ADDR_EXP 20
23334: PUSH
23335: LD_INT 0
23337: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23338: LD_ADDR_VAR 0 1
23342: PUSH
23343: LD_VAR 0 3
23347: PUSH
23348: LD_INT 22
23350: PUSH
23351: LD_INT 8
23353: PUSH
23354: EMPTY
23355: LIST
23356: LIST
23357: PUSH
23358: LD_INT 25
23360: PUSH
23361: LD_INT 2
23363: PUSH
23364: EMPTY
23365: LIST
23366: LIST
23367: PUSH
23368: EMPTY
23369: LIST
23370: LIST
23371: PPUSH
23372: CALL_OW 69
23376: UNION
23377: PUSH
23378: FOR_IN
23379: IFFALSE 23395
// SetTag ( i , 0 ) ;
23381: LD_VAR 0 1
23385: PPUSH
23386: LD_INT 0
23388: PPUSH
23389: CALL_OW 109
23393: GO 23378
23395: POP
23396: POP
// wait ( 0 0$3 ) ;
23397: LD_INT 105
23399: PPUSH
23400: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23404: LD_INT 93
23406: PPUSH
23407: LD_INT 35
23409: PPUSH
23410: LD_INT 1
23412: PPUSH
23413: CALL_OW 331
// DialogueOn ;
23417: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23421: LD_VAR 0 11
23425: PPUSH
23426: LD_STRING D6c-Sol3-1
23428: PPUSH
23429: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23433: LD_INT 10
23435: PPUSH
23436: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23440: LD_EXP 36
23444: PPUSH
23445: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23449: LD_EXP 36
23453: PPUSH
23454: LD_STRING D6c-JMM-1
23456: PPUSH
23457: CALL_OW 88
// if Cyrus then
23461: LD_EXP 42
23465: IFFALSE 23479
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23467: LD_EXP 42
23471: PPUSH
23472: LD_STRING D6c-Cyrus-1
23474: PPUSH
23475: CALL_OW 88
// if Bobby then
23479: LD_EXP 41
23483: IFFALSE 23497
// Say ( Bobby , D6c-Bobby-1 ) ;
23485: LD_EXP 41
23489: PPUSH
23490: LD_STRING D6c-Bobby-1
23492: PPUSH
23493: CALL_OW 88
// if Cornel then
23497: LD_EXP 47
23501: IFFALSE 23515
// Say ( Cornel , D6c-Corn-1 ) ;
23503: LD_EXP 47
23507: PPUSH
23508: LD_STRING D6c-Corn-1
23510: PPUSH
23511: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23515: LD_ADDR_VAR 0 4
23519: PUSH
23520: LD_INT 2
23522: PUSH
23523: LD_INT 22
23525: PUSH
23526: LD_INT 1
23528: PUSH
23529: EMPTY
23530: LIST
23531: LIST
23532: PUSH
23533: LD_INT 22
23535: PUSH
23536: LD_INT 4
23538: PUSH
23539: EMPTY
23540: LIST
23541: LIST
23542: PUSH
23543: EMPTY
23544: LIST
23545: LIST
23546: LIST
23547: PUSH
23548: LD_INT 26
23550: PUSH
23551: LD_INT 1
23553: PUSH
23554: EMPTY
23555: LIST
23556: LIST
23557: PUSH
23558: LD_INT 3
23560: PUSH
23561: LD_INT 25
23563: PUSH
23564: LD_INT 16
23566: PUSH
23567: EMPTY
23568: LIST
23569: LIST
23570: PUSH
23571: LD_INT 25
23573: PUSH
23574: LD_INT 12
23576: PUSH
23577: EMPTY
23578: LIST
23579: LIST
23580: PUSH
23581: EMPTY
23582: LIST
23583: LIST
23584: LIST
23585: PUSH
23586: EMPTY
23587: LIST
23588: LIST
23589: LIST
23590: PPUSH
23591: CALL_OW 69
23595: PUSH
23596: LD_VAR 0 11
23600: PUSH
23601: LD_EXP 36
23605: UNION
23606: PUSH
23607: LD_EXP 56
23611: UNION
23612: PUSH
23613: EMPTY
23614: LIST
23615: DIFF
23616: ST_TO_ADDR
// if tmp2 then
23617: LD_VAR 0 4
23621: IFFALSE 23639
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23623: LD_VAR 0 4
23627: PUSH
23628: LD_INT 1
23630: ARRAY
23631: PPUSH
23632: LD_STRING D6c-Sol1-1
23634: PPUSH
23635: CALL_OW 88
// if Lisa then
23639: LD_EXP 39
23643: IFFALSE 23657
// Say ( Lisa , D6c-Lisa-1 ) ;
23645: LD_EXP 39
23649: PPUSH
23650: LD_STRING D6c-Lisa-1
23652: PPUSH
23653: CALL_OW 88
// if Gary then
23657: LD_EXP 48
23661: IFFALSE 23675
// Say ( Gary , D6c-Gary-1 ) ;
23663: LD_EXP 48
23667: PPUSH
23668: LD_STRING D6c-Gary-1
23670: PPUSH
23671: CALL_OW 88
// if Donaldson then
23675: LD_EXP 40
23679: IFFALSE 23693
// Say ( Donaldson , D6c-Don-1 ) ;
23681: LD_EXP 40
23685: PPUSH
23686: LD_STRING D6c-Don-1
23688: PPUSH
23689: CALL_OW 88
// if tmp2 > 1 then
23693: LD_VAR 0 4
23697: PUSH
23698: LD_INT 1
23700: GREATER
23701: IFFALSE 23719
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
23703: LD_VAR 0 4
23707: PUSH
23708: LD_INT 2
23710: ARRAY
23711: PPUSH
23712: LD_STRING D6c-Sol2-1
23714: PPUSH
23715: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
23719: LD_VAR 0 11
23723: PPUSH
23724: LD_STRING D6c-Sol3-2
23726: PPUSH
23727: CALL_OW 88
// dwait ( 0 0$1 ) ;
23731: LD_INT 35
23733: PPUSH
23734: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
23738: LD_EXP 36
23742: PPUSH
23743: LD_STRING D6c-JMM-2
23745: PPUSH
23746: CALL_OW 88
// DialogueOff ;
23750: CALL_OW 7
// Video ( false ) ;
23754: LD_INT 0
23756: PPUSH
23757: CALL 104216 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
23761: LD_INT 22
23763: PUSH
23764: LD_INT 4
23766: PUSH
23767: EMPTY
23768: LIST
23769: LIST
23770: PPUSH
23771: CALL_OW 69
23775: PPUSH
23776: LD_INT 1
23778: PPUSH
23779: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
23783: LD_INT 4
23785: PPUSH
23786: LD_INT 4
23788: PPUSH
23789: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
23793: LD_ADDR_VAR 0 1
23797: PUSH
23798: LD_INT 4
23800: PPUSH
23801: LD_INT 1
23803: PPUSH
23804: LD_INT 2
23806: PPUSH
23807: CALL 61991 0 3
23811: PUSH
23812: FOR_IN
23813: IFFALSE 23850
// if GetTech ( i , 1 ) <> state_researched then
23815: LD_VAR 0 1
23819: PPUSH
23820: LD_INT 1
23822: PPUSH
23823: CALL_OW 321
23827: PUSH
23828: LD_INT 2
23830: NONEQUAL
23831: IFFALSE 23848
// SetTech ( i , 1 , state_researched ) ;
23833: LD_VAR 0 1
23837: PPUSH
23838: LD_INT 1
23840: PPUSH
23841: LD_INT 2
23843: PPUSH
23844: CALL_OW 322
23848: GO 23812
23850: POP
23851: POP
// missionStage := 6 ;
23852: LD_ADDR_EXP 15
23856: PUSH
23857: LD_INT 6
23859: ST_TO_ADDR
// activeAttacks := true ;
23860: LD_ADDR_EXP 16
23864: PUSH
23865: LD_INT 1
23867: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
23868: LD_STRING M2
23870: PPUSH
23871: CALL_OW 337
// SaveForQuickRestart ;
23875: CALL_OW 22
// wait ( 0 0$40 ) ;
23879: LD_INT 1400
23881: PPUSH
23882: CALL_OW 67
// DialogueOn ;
23886: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
23890: LD_EXP 59
23894: PPUSH
23895: LD_STRING D7-Friend-1
23897: PPUSH
23898: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
23902: LD_EXP 36
23906: PPUSH
23907: LD_STRING D7-JMM-1
23909: PPUSH
23910: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
23914: LD_EXP 59
23918: PPUSH
23919: LD_STRING D7-Friend-2
23921: PPUSH
23922: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
23926: LD_EXP 36
23930: PPUSH
23931: LD_STRING D7-JMM-2
23933: PPUSH
23934: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
23938: LD_EXP 59
23942: PPUSH
23943: LD_STRING D7-Friend-3
23945: PPUSH
23946: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
23950: LD_EXP 36
23954: PPUSH
23955: LD_STRING D7-JMM-3
23957: PPUSH
23958: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
23962: LD_EXP 59
23966: PPUSH
23967: LD_STRING D7-Friend-4
23969: PPUSH
23970: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
23974: LD_EXP 36
23978: PPUSH
23979: LD_STRING D7-JMM-4
23981: PPUSH
23982: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
23986: LD_EXP 59
23990: PPUSH
23991: LD_STRING D7-Friend-5
23993: PPUSH
23994: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
23998: LD_EXP 36
24002: PPUSH
24003: LD_STRING D7-JMM-5
24005: PPUSH
24006: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24010: LD_EXP 59
24014: PPUSH
24015: LD_STRING D7-Friend-6
24017: PPUSH
24018: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24022: LD_EXP 36
24026: PPUSH
24027: LD_STRING D7-JMM-6
24029: PPUSH
24030: CALL_OW 88
// DialogueOff ;
24034: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24038: LD_STRING Mlegion
24040: PPUSH
24041: CALL_OW 337
// RebuildKozlovFactory ;
24045: CALL 4677 0 0
// end ;
24049: PPOPN 13
24051: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24052: LD_EXP 20
24056: PUSH
24057: LD_EXP 55
24061: PPUSH
24062: CALL_OW 300
24066: AND
24067: IFFALSE 24109
24069: GO 24071
24071: DISABLE
// begin enable ;
24072: ENABLE
// if IsInUnit ( Powell ) then
24073: LD_EXP 55
24077: PPUSH
24078: CALL_OW 310
24082: IFFALSE 24100
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24084: LD_EXP 55
24088: PPUSH
24089: CALL_OW 310
24093: PPUSH
24094: CALL_OW 85
24098: GO 24109
// CenterOnUnits ( Powell ) ;
24100: LD_EXP 55
24104: PPUSH
24105: CALL_OW 85
// end ;
24109: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24110: LD_INT 22
24112: PUSH
24113: LD_INT 8
24115: PUSH
24116: EMPTY
24117: LIST
24118: LIST
24119: PUSH
24120: LD_INT 34
24122: PUSH
24123: LD_INT 48
24125: PUSH
24126: EMPTY
24127: LIST
24128: LIST
24129: PUSH
24130: EMPTY
24131: LIST
24132: LIST
24133: PPUSH
24134: CALL_OW 69
24138: IFFALSE 24401
24140: GO 24142
24142: DISABLE
24143: LD_INT 0
24145: PPUSH
24146: PPUSH
// begin if missionStage < 9 then
24147: LD_EXP 15
24151: PUSH
24152: LD_INT 9
24154: LESS
24155: IFFALSE 24165
// missionStage := 9 ;
24157: LD_ADDR_EXP 15
24161: PUSH
24162: LD_INT 9
24164: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24165: LD_ADDR_VAR 0 1
24169: PUSH
24170: LD_INT 22
24172: PUSH
24173: LD_INT 8
24175: PUSH
24176: EMPTY
24177: LIST
24178: LIST
24179: PUSH
24180: LD_INT 34
24182: PUSH
24183: LD_INT 48
24185: PUSH
24186: EMPTY
24187: LIST
24188: LIST
24189: PUSH
24190: EMPTY
24191: LIST
24192: LIST
24193: PPUSH
24194: CALL_OW 69
24198: PUSH
24199: LD_INT 1
24201: ARRAY
24202: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24203: LD_INT 175
24205: PPUSH
24206: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24210: LD_EXP 12
24214: PUSH
24215: LD_EXP 3
24219: PUSH
24220: LD_INT 0
24222: PUSH
24223: LD_INT 2
24225: PUSH
24226: EMPTY
24227: LIST
24228: LIST
24229: IN
24230: OR
24231: IFFALSE 24254
// target := [ 68 , 108 , 1 ] else
24233: LD_ADDR_VAR 0 2
24237: PUSH
24238: LD_INT 68
24240: PUSH
24241: LD_INT 108
24243: PUSH
24244: LD_INT 1
24246: PUSH
24247: EMPTY
24248: LIST
24249: LIST
24250: LIST
24251: ST_TO_ADDR
24252: GO 24273
// target := [ 181 , 88 , 2 ] ;
24254: LD_ADDR_VAR 0 2
24258: PUSH
24259: LD_INT 181
24261: PUSH
24262: LD_INT 88
24264: PUSH
24265: LD_INT 2
24267: PUSH
24268: EMPTY
24269: LIST
24270: LIST
24271: LIST
24272: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24273: LD_VAR 0 1
24277: PPUSH
24278: LD_VAR 0 2
24282: PUSH
24283: LD_INT 1
24285: ARRAY
24286: PPUSH
24287: LD_VAR 0 2
24291: PUSH
24292: LD_INT 2
24294: ARRAY
24295: PPUSH
24296: CALL_OW 176
// if target [ 3 ] = 1 then
24300: LD_VAR 0 2
24304: PUSH
24305: LD_INT 3
24307: ARRAY
24308: PUSH
24309: LD_INT 1
24311: EQUAL
24312: IFFALSE 24328
// SayRadio ( Kurt , D12-Kurt-1 ) else
24314: LD_EXP 57
24318: PPUSH
24319: LD_STRING D12-Kurt-1
24321: PPUSH
24322: CALL_OW 94
24326: GO 24352
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24328: LD_EXP 57
24332: PPUSH
24333: LD_STRING D12a-Kurt-1
24335: PPUSH
24336: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24340: LD_EXP 71
24344: PPUSH
24345: LD_STRING D12a-Roth-1
24347: PPUSH
24348: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24352: LD_INT 350
24354: PPUSH
24355: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24359: LD_VAR 0 1
24363: PPUSH
24364: LD_INT 22
24366: PUSH
24367: LD_INT 8
24369: PUSH
24370: EMPTY
24371: LIST
24372: LIST
24373: PUSH
24374: LD_INT 30
24376: PUSH
24377: LD_INT 3
24379: PUSH
24380: EMPTY
24381: LIST
24382: LIST
24383: PUSH
24384: EMPTY
24385: LIST
24386: LIST
24387: PPUSH
24388: CALL_OW 69
24392: PUSH
24393: LD_INT 1
24395: ARRAY
24396: PPUSH
24397: CALL_OW 228
// end ;
24401: PPOPN 2
24403: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 8 , 7 , 6 ] [ Difficulty ] and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) do
24404: LD_INT 22
24406: PUSH
24407: LD_INT 8
24409: PUSH
24410: EMPTY
24411: LIST
24412: LIST
24413: PUSH
24414: LD_INT 21
24416: PUSH
24417: LD_INT 1
24419: PUSH
24420: EMPTY
24421: LIST
24422: LIST
24423: PUSH
24424: LD_INT 23
24426: PUSH
24427: LD_INT 2
24429: PUSH
24430: EMPTY
24431: LIST
24432: LIST
24433: PUSH
24434: EMPTY
24435: LIST
24436: LIST
24437: LIST
24438: PPUSH
24439: CALL_OW 69
24443: PUSH
24444: LD_INT 8
24446: PUSH
24447: LD_INT 7
24449: PUSH
24450: LD_INT 6
24452: PUSH
24453: EMPTY
24454: LIST
24455: LIST
24456: LIST
24457: PUSH
24458: LD_OWVAR 67
24462: ARRAY
24463: LESSEQUAL
24464: PUSH
24465: LD_INT 22
24467: PUSH
24468: LD_INT 8
24470: PUSH
24471: EMPTY
24472: LIST
24473: LIST
24474: PUSH
24475: LD_INT 34
24477: PUSH
24478: LD_INT 48
24480: PUSH
24481: EMPTY
24482: LIST
24483: LIST
24484: PUSH
24485: EMPTY
24486: LIST
24487: LIST
24488: PPUSH
24489: CALL_OW 69
24493: NOT
24494: AND
24495: PUSH
24496: LD_EXP 57
24500: PPUSH
24501: CALL_OW 302
24505: AND
24506: IFFALSE 24823
24508: GO 24510
24510: DISABLE
// begin DialogueOn ;
24511: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24515: LD_EXP 36
24519: PPUSH
24520: LD_STRING D13-JMM-1
24522: PPUSH
24523: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24527: LD_EXP 57
24531: PPUSH
24532: LD_STRING D13-Kurt-1
24534: PPUSH
24535: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24539: LD_EXP 36
24543: PPUSH
24544: LD_STRING D13-JMM-2
24546: PPUSH
24547: CALL_OW 88
// if FakeInfo then
24551: LD_EXP 12
24555: IFFALSE 24575
// begin Say ( Kurt , D13-Kurt-2 ) ;
24557: LD_EXP 57
24561: PPUSH
24562: LD_STRING D13-Kurt-2
24564: PPUSH
24565: CALL_OW 88
// DialogueOff ;
24569: CALL_OW 7
// exit ;
24573: GO 24823
// end ; if not KurtStatus then
24575: LD_EXP 3
24579: NOT
24580: IFFALSE 24596
// Say ( Kurt , D13-Kurt-2b ) else
24582: LD_EXP 57
24586: PPUSH
24587: LD_STRING D13-Kurt-2b
24589: PPUSH
24590: CALL_OW 88
24594: GO 24608
// Say ( Kurt , D13-Kurt-2a ) ;
24596: LD_EXP 57
24600: PPUSH
24601: LD_STRING D13-Kurt-2a
24603: PPUSH
24604: CALL_OW 88
// Say ( Kurt , D13-Kurt-2a ) ;
24608: LD_EXP 57
24612: PPUSH
24613: LD_STRING D13-Kurt-2a
24615: PPUSH
24616: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24620: LD_EXP 36
24624: PPUSH
24625: LD_STRING D13-JMM-3
24627: PPUSH
24628: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
24632: LD_EXP 57
24636: PPUSH
24637: LD_STRING D13-Kurt-3
24639: PPUSH
24640: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
24644: LD_EXP 36
24648: PPUSH
24649: LD_STRING D13-JMM-4
24651: PPUSH
24652: CALL_OW 88
// DialogueOff ;
24656: CALL_OW 7
// MC_Kill ( 3 ) ;
24660: LD_INT 3
24662: PPUSH
24663: CALL 33917 0 1
// KillUnit ( Kozlov ) ;
24667: LD_EXP 58
24671: PPUSH
24672: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24676: LD_INT 22
24678: PUSH
24679: LD_INT 8
24681: PUSH
24682: EMPTY
24683: LIST
24684: LIST
24685: PUSH
24686: LD_INT 21
24688: PUSH
24689: LD_INT 3
24691: PUSH
24692: EMPTY
24693: LIST
24694: LIST
24695: PUSH
24696: LD_INT 23
24698: PUSH
24699: LD_INT 3
24701: PUSH
24702: EMPTY
24703: LIST
24704: LIST
24705: PUSH
24706: LD_INT 30
24708: PUSH
24709: LD_INT 3
24711: PUSH
24712: EMPTY
24713: LIST
24714: LIST
24715: PUSH
24716: EMPTY
24717: LIST
24718: LIST
24719: LIST
24720: LIST
24721: PPUSH
24722: CALL_OW 69
24726: PUSH
24727: LD_INT 1
24729: ARRAY
24730: PPUSH
24731: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
24735: LD_INT 8
24737: PPUSH
24738: LD_INT 1
24740: PPUSH
24741: CALL_OW 343
// SetSide ( FilterAllUnits ( [ f_side , 8 ] ) , 1 ) ;
24745: LD_INT 22
24747: PUSH
24748: LD_INT 8
24750: PUSH
24751: EMPTY
24752: LIST
24753: LIST
24754: PPUSH
24755: CALL_OW 69
24759: PPUSH
24760: LD_INT 1
24762: PPUSH
24763: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
24767: LD_INT 8
24769: PPUSH
24770: LD_INT 1
24772: PPUSH
24773: LD_INT 1
24775: PPUSH
24776: LD_INT 1
24778: PPUSH
24779: CALL_OW 80
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
24783: LD_EXP 59
24787: PPUSH
24788: LD_INT 37
24790: PPUSH
24791: LD_INT 1
24793: PPUSH
24794: LD_INT 0
24796: PPUSH
24797: CALL_OW 48
// wait ( 0 0$1 ) ;
24801: LD_INT 35
24803: PPUSH
24804: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
24808: LD_EXP 59
24812: PPUSH
24813: LD_INT 60
24815: PPUSH
24816: LD_INT 95
24818: PPUSH
24819: CALL_OW 111
// end ;
24823: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
24824: LD_INT 22
24826: PUSH
24827: LD_INT 8
24829: PUSH
24830: EMPTY
24831: LIST
24832: LIST
24833: PUSH
24834: LD_INT 21
24836: PUSH
24837: LD_INT 1
24839: PUSH
24840: EMPTY
24841: LIST
24842: LIST
24843: PUSH
24844: EMPTY
24845: LIST
24846: LIST
24847: PPUSH
24848: CALL_OW 69
24852: PUSH
24853: LD_INT 0
24855: EQUAL
24856: IFFALSE 24876
24858: GO 24860
24860: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
24861: LD_STRING MlegionOut
24863: PPUSH
24864: CALL_OW 337
// legionDestroyed := true ;
24868: LD_ADDR_EXP 22
24872: PUSH
24873: LD_INT 1
24875: ST_TO_ADDR
// end ;
24876: END
// every 0 0$1 trigger See ( 1 , Friend ) do var dec ;
24877: LD_INT 1
24879: PPUSH
24880: LD_EXP 59
24884: PPUSH
24885: CALL_OW 292
24889: IFFALSE 25189
24891: GO 24893
24893: DISABLE
24894: LD_INT 0
24896: PPUSH
// begin CenterNowOnUnits ( Friend ) ;
24897: LD_EXP 59
24901: PPUSH
24902: CALL_OW 87
// DialogueOn ;
24906: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
24910: LD_EXP 36
24914: PPUSH
24915: LD_STRING D14-JMM-1
24917: PPUSH
24918: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
24922: LD_EXP 59
24926: PPUSH
24927: LD_STRING D14-Friend-1
24929: PPUSH
24930: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
24934: LD_EXP 36
24938: PPUSH
24939: LD_STRING D14-JMM-2
24941: PPUSH
24942: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
24946: LD_EXP 59
24950: PPUSH
24951: LD_STRING D14-Friend-2
24953: PPUSH
24954: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
24958: LD_EXP 36
24962: PPUSH
24963: LD_STRING D14-JMM-3
24965: PPUSH
24966: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
24970: LD_EXP 59
24974: PPUSH
24975: LD_STRING D14-Friend-3
24977: PPUSH
24978: CALL_OW 88
// DialogueOff ;
24982: CALL_OW 7
// dec = Query ( Q14 ) ;
24986: LD_ADDR_VAR 0 1
24990: PUSH
24991: LD_STRING Q14
24993: PPUSH
24994: CALL_OW 97
24998: ST_TO_ADDR
// if dec = 1 then
24999: LD_VAR 0 1
25003: PUSH
25004: LD_INT 1
25006: EQUAL
25007: IFFALSE 25041
// begin DialogueOn ;
25009: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25013: LD_EXP 36
25017: PPUSH
25018: LD_STRING D14a-JMM-1
25020: PPUSH
25021: CALL_OW 88
// DialogueOff ;
25025: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25029: LD_EXP 59
25033: PPUSH
25034: LD_INT 1
25036: PPUSH
25037: CALL_OW 235
// end ; if dec = 2 then
25041: LD_VAR 0 1
25045: PUSH
25046: LD_INT 2
25048: EQUAL
25049: IFFALSE 25095
// begin DialogueOn ;
25051: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
25055: LD_EXP 36
25059: PPUSH
25060: LD_STRING D14b-JMM-1
25062: PPUSH
25063: CALL_OW 88
// DialogueOff ;
25067: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
25071: LD_EXP 59
25075: PPUSH
25076: LD_INT 9
25078: PPUSH
25079: LD_INT 2
25081: PPUSH
25082: CALL_OW 111
// AddComHold ( Friend ) ;
25086: LD_EXP 59
25090: PPUSH
25091: CALL_OW 200
// end ; if dec = 3 then
25095: LD_VAR 0 1
25099: PUSH
25100: LD_INT 3
25102: EQUAL
25103: IFFALSE 25189
// begin DialogueOn ;
25105: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
25109: LD_EXP 36
25113: PPUSH
25114: LD_STRING D14c-JMM-1
25116: PPUSH
25117: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
25121: LD_EXP 59
25125: PPUSH
25126: LD_STRING D14c-Friend-1
25128: PPUSH
25129: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
25133: LD_EXP 36
25137: PPUSH
25138: LD_STRING D14c-JMM-2
25140: PPUSH
25141: CALL_OW 88
// DialogueOff ;
25145: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
25149: LD_INT 8
25151: PPUSH
25152: LD_INT 1
25154: PPUSH
25155: LD_INT 2
25157: PPUSH
25158: LD_INT 1
25160: PPUSH
25161: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
25165: LD_EXP 59
25169: PPUSH
25170: LD_INT 9
25172: PPUSH
25173: LD_INT 2
25175: PPUSH
25176: CALL_OW 111
// AddComHold ( Friend ) ;
25180: LD_EXP 59
25184: PPUSH
25185: CALL_OW 200
// end ; end ;
25189: PPOPN 1
25191: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
25192: LD_INT 9
25194: PPUSH
25195: LD_INT 2
25197: PPUSH
25198: CALL_OW 428
25202: PUSH
25203: LD_EXP 59
25207: EQUAL
25208: PUSH
25209: LD_EXP 59
25213: PPUSH
25214: CALL_OW 255
25218: PUSH
25219: LD_INT 8
25221: EQUAL
25222: AND
25223: IFFALSE 25237
25225: GO 25227
25227: DISABLE
// RemoveUnit ( Friend ) ;
25228: LD_EXP 59
25232: PPUSH
25233: CALL_OW 64
25237: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
25238: LD_EXP 14
25242: PUSH
25243: LD_INT 31500
25245: GREATEREQUAL
25246: PUSH
25247: LD_EXP 7
25251: AND
25252: PUSH
25253: LD_EXP 2
25257: AND
25258: IFFALSE 25688
25260: GO 25262
25262: DISABLE
25263: LD_INT 0
25265: PPUSH
25266: PPUSH
25267: PPUSH
// begin missionStage := 7 ;
25268: LD_ADDR_EXP 15
25272: PUSH
25273: LD_INT 7
25275: ST_TO_ADDR
// uc_side = 1 ;
25276: LD_ADDR_OWVAR 20
25280: PUSH
25281: LD_INT 1
25283: ST_TO_ADDR
// uc_nation = 1 ;
25284: LD_ADDR_OWVAR 21
25288: PUSH
25289: LD_INT 1
25291: ST_TO_ADDR
// for i = 1 to 5 do
25292: LD_ADDR_VAR 0 1
25296: PUSH
25297: DOUBLE
25298: LD_INT 1
25300: DEC
25301: ST_TO_ADDR
25302: LD_INT 5
25304: PUSH
25305: FOR_TO
25306: IFFALSE 25402
// begin vc_engine = 3 ;
25308: LD_ADDR_OWVAR 39
25312: PUSH
25313: LD_INT 3
25315: ST_TO_ADDR
// vc_control = 3 ;
25316: LD_ADDR_OWVAR 38
25320: PUSH
25321: LD_INT 3
25323: ST_TO_ADDR
// vc_chassis = 3 ;
25324: LD_ADDR_OWVAR 37
25328: PUSH
25329: LD_INT 3
25331: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25332: LD_ADDR_OWVAR 40
25336: PUSH
25337: LD_INT 5
25339: PUSH
25340: LD_INT 9
25342: PUSH
25343: LD_INT 7
25345: PUSH
25346: EMPTY
25347: LIST
25348: LIST
25349: LIST
25350: PUSH
25351: LD_INT 1
25353: PPUSH
25354: LD_INT 3
25356: PPUSH
25357: CALL_OW 12
25361: ARRAY
25362: ST_TO_ADDR
// veh = CreateVehicle ;
25363: LD_ADDR_VAR 0 2
25367: PUSH
25368: CALL_OW 45
25372: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25373: LD_VAR 0 2
25377: PPUSH
25378: LD_INT 1
25380: PPUSH
25381: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25385: LD_VAR 0 2
25389: PPUSH
25390: LD_INT 19
25392: PPUSH
25393: LD_INT 0
25395: PPUSH
25396: CALL_OW 49
// end ;
25400: GO 25305
25402: POP
25403: POP
// vc_engine = 3 ;
25404: LD_ADDR_OWVAR 39
25408: PUSH
25409: LD_INT 3
25411: ST_TO_ADDR
// vc_control = 1 ;
25412: LD_ADDR_OWVAR 38
25416: PUSH
25417: LD_INT 1
25419: ST_TO_ADDR
// vc_chassis = 3 ;
25420: LD_ADDR_OWVAR 37
25424: PUSH
25425: LD_INT 3
25427: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25428: LD_ADDR_OWVAR 40
25432: PUSH
25433: LD_INT 5
25435: PUSH
25436: LD_INT 9
25438: PUSH
25439: LD_INT 7
25441: PUSH
25442: EMPTY
25443: LIST
25444: LIST
25445: LIST
25446: PUSH
25447: LD_INT 1
25449: PPUSH
25450: LD_INT 3
25452: PPUSH
25453: CALL_OW 12
25457: ARRAY
25458: ST_TO_ADDR
// vehG = CreateVehicle ;
25459: LD_ADDR_VAR 0 3
25463: PUSH
25464: CALL_OW 45
25468: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
25469: LD_VAR 0 3
25473: PPUSH
25474: LD_INT 1
25476: PPUSH
25477: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
25481: LD_VAR 0 3
25485: PPUSH
25486: LD_INT 19
25488: PPUSH
25489: LD_INT 0
25491: PPUSH
25492: CALL_OW 49
// if JMMGirl = 1 then
25496: LD_EXP 7
25500: PUSH
25501: LD_INT 1
25503: EQUAL
25504: IFFALSE 25560
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
25506: LD_ADDR_EXP 37
25510: PUSH
25511: LD_STRING Joan
25513: PPUSH
25514: LD_INT 1
25516: PPUSH
25517: LD_STRING 14_
25519: PPUSH
25520: CALL 61928 0 3
25524: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
25525: LD_EXP 37
25529: PPUSH
25530: LD_VAR 0 3
25534: PPUSH
25535: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25539: LD_VAR 0 3
25543: PPUSH
25544: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
25548: LD_EXP 37
25552: PPUSH
25553: LD_STRING D10BW-Joan-1
25555: PPUSH
25556: CALL_OW 94
// end ; if JMMGirl = 2 then
25560: LD_EXP 7
25564: PUSH
25565: LD_INT 2
25567: EQUAL
25568: IFFALSE 25624
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
25570: LD_ADDR_EXP 39
25574: PUSH
25575: LD_STRING Lisa
25577: PPUSH
25578: LD_INT 1
25580: PPUSH
25581: LD_STRING 14_
25583: PPUSH
25584: CALL 61928 0 3
25588: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
25589: LD_EXP 39
25593: PPUSH
25594: LD_VAR 0 3
25598: PPUSH
25599: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25603: LD_VAR 0 3
25607: PPUSH
25608: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
25612: LD_EXP 39
25616: PPUSH
25617: LD_STRING D10BW-Lisa-1
25619: PPUSH
25620: CALL_OW 94
// end ; if JMMGirl = 3 then
25624: LD_EXP 7
25628: PUSH
25629: LD_INT 3
25631: EQUAL
25632: IFFALSE 25688
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
25634: LD_ADDR_EXP 51
25638: PUSH
25639: LD_STRING Connie
25641: PPUSH
25642: LD_INT 1
25644: PPUSH
25645: LD_STRING 14_
25647: PPUSH
25648: CALL 61928 0 3
25652: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
25653: LD_EXP 51
25657: PPUSH
25658: LD_VAR 0 3
25662: PPUSH
25663: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25667: LD_VAR 0 3
25671: PPUSH
25672: CALL_OW 87
// SayRadio ( Lisa , D10BW-Con-1 ) ;
25676: LD_EXP 39
25680: PPUSH
25681: LD_STRING D10BW-Con-1
25683: PPUSH
25684: CALL_OW 94
// end ; end ;
25688: PPOPN 3
25690: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
25691: LD_EXP 14
25695: PUSH
25696: LD_INT 94500
25698: GREATEREQUAL
25699: IFFALSE 26111
25701: GO 25703
25703: DISABLE
25704: LD_INT 0
25706: PPUSH
25707: PPUSH
25708: PPUSH
// begin tmp := PrepareStevensSquad ;
25709: LD_ADDR_VAR 0 3
25713: PUSH
25714: CALL 2051 0 0
25718: ST_TO_ADDR
// if not tmp then
25719: LD_VAR 0 3
25723: NOT
25724: IFFALSE 25728
// exit ;
25726: GO 26111
// uc_side := 1 ;
25728: LD_ADDR_OWVAR 20
25732: PUSH
25733: LD_INT 1
25735: ST_TO_ADDR
// uc_nation := 1 ;
25736: LD_ADDR_OWVAR 21
25740: PUSH
25741: LD_INT 1
25743: ST_TO_ADDR
// for i in tmp do
25744: LD_ADDR_VAR 0 1
25748: PUSH
25749: LD_VAR 0 3
25753: PUSH
25754: FOR_IN
25755: IFFALSE 25852
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
25757: LD_INT 3
25759: PPUSH
25760: LD_INT 3
25762: PPUSH
25763: LD_INT 1
25765: PPUSH
25766: LD_INT 5
25768: PUSH
25769: LD_INT 9
25771: PUSH
25772: LD_INT 7
25774: PUSH
25775: EMPTY
25776: LIST
25777: LIST
25778: LIST
25779: PUSH
25780: LD_INT 1
25782: PPUSH
25783: LD_INT 3
25785: PPUSH
25786: CALL_OW 12
25790: ARRAY
25791: PPUSH
25792: LD_INT 40
25794: PPUSH
25795: CALL 68561 0 5
// veh := CreateVehicle ;
25799: LD_ADDR_VAR 0 2
25803: PUSH
25804: CALL_OW 45
25808: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25809: LD_VAR 0 2
25813: PPUSH
25814: LD_INT 1
25816: PPUSH
25817: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25821: LD_VAR 0 2
25825: PPUSH
25826: LD_INT 19
25828: PPUSH
25829: LD_INT 0
25831: PPUSH
25832: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
25836: LD_VAR 0 1
25840: PPUSH
25841: LD_VAR 0 2
25845: PPUSH
25846: CALL_OW 52
// end ;
25850: GO 25754
25852: POP
25853: POP
// missionStage := 8 ;
25854: LD_ADDR_EXP 15
25858: PUSH
25859: LD_INT 8
25861: ST_TO_ADDR
// DialogueOn ;
25862: CALL_OW 6
// if Stevens then
25866: LD_EXP 38
25870: IFFALSE 25984
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
25872: LD_EXP 38
25876: PPUSH
25877: CALL_OW 310
25881: PPUSH
25882: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
25886: LD_EXP 38
25890: PPUSH
25891: LD_STRING D8-Huck-1
25893: PPUSH
25894: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
25898: LD_EXP 36
25902: PPUSH
25903: LD_STRING D8-JMM-1
25905: PPUSH
25906: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
25910: LD_EXP 38
25914: PPUSH
25915: LD_STRING D8-Huck-2
25917: PPUSH
25918: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
25922: LD_EXP 36
25926: PPUSH
25927: LD_STRING D8-JMM-2
25929: PPUSH
25930: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
25934: LD_EXP 38
25938: PPUSH
25939: LD_STRING D8-Huck-3
25941: PPUSH
25942: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
25946: LD_EXP 36
25950: PPUSH
25951: LD_STRING D8-JMM-3
25953: PPUSH
25954: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
25958: LD_EXP 38
25962: PPUSH
25963: LD_STRING D8-Huck-4
25965: PPUSH
25966: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
25970: LD_EXP 36
25974: PPUSH
25975: LD_STRING D8-JMM-4
25977: PPUSH
25978: CALL_OW 88
// end else
25982: GO 26094
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
25984: LD_EXP 52
25988: PPUSH
25989: CALL_OW 310
25993: PPUSH
25994: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
25998: LD_EXP 52
26002: PPUSH
26003: LD_STRING D8-Huck-1
26005: PPUSH
26006: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26010: LD_EXP 36
26014: PPUSH
26015: LD_STRING D8-JMM-1a
26017: PPUSH
26018: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26022: LD_EXP 52
26026: PPUSH
26027: LD_STRING D8-Huck-2
26029: PPUSH
26030: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26034: LD_EXP 36
26038: PPUSH
26039: LD_STRING D8-JMM-2
26041: PPUSH
26042: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26046: LD_EXP 52
26050: PPUSH
26051: LD_STRING D8-Huck-3
26053: PPUSH
26054: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26058: LD_EXP 36
26062: PPUSH
26063: LD_STRING D8-JMM-3
26065: PPUSH
26066: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
26070: LD_EXP 52
26074: PPUSH
26075: LD_STRING D8-Huck-4
26077: PPUSH
26078: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26082: LD_EXP 36
26086: PPUSH
26087: LD_STRING D8-JMM-4
26089: PPUSH
26090: CALL_OW 88
// end ; DialogueOff ;
26094: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
26098: LD_INT 25
26100: PPUSH
26101: LD_INT 1
26103: PPUSH
26104: LD_INT 1
26106: PPUSH
26107: CALL_OW 322
// end ;
26111: PPOPN 3
26113: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
26114: LD_INT 1
26116: PPUSH
26117: LD_EXP 68
26121: PPUSH
26122: CALL_OW 292
26126: IFFALSE 26377
26128: GO 26130
26130: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
26131: LD_EXP 68
26135: PPUSH
26136: CALL_OW 87
// DialogueOn ;
26140: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
26144: LD_EXP 36
26148: PPUSH
26149: LD_STRING D10nB-JMM-1
26151: PPUSH
26152: CALL_OW 88
// if BurlakStatus = 1 then
26156: LD_EXP 9
26160: PUSH
26161: LD_INT 1
26163: EQUAL
26164: IFFALSE 26178
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
26166: LD_EXP 67
26170: PPUSH
26171: LD_STRING D10nB-Vse-1a
26173: PPUSH
26174: CALL_OW 94
// end ; if BurlakStatus = 0 then
26178: LD_EXP 9
26182: PUSH
26183: LD_INT 0
26185: EQUAL
26186: IFFALSE 26200
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
26188: LD_EXP 67
26192: PPUSH
26193: LD_STRING D10nB-Vse-1
26195: PPUSH
26196: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
26200: LD_EXP 36
26204: PPUSH
26205: LD_STRING D10nB-JMM-2
26207: PPUSH
26208: CALL_OW 88
// if KappaStatus then
26212: LD_EXP 2
26216: IFFALSE 26230
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
26218: LD_EXP 67
26222: PPUSH
26223: LD_STRING D10nB-Vse-5a
26225: PPUSH
26226: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
26230: LD_EXP 2
26234: NOT
26235: PUSH
26236: LD_EXP 6
26240: PUSH
26241: LD_INT 0
26243: EQUAL
26244: AND
26245: IFFALSE 26373
// begin if JMMGirl = 1 then
26247: LD_EXP 7
26251: PUSH
26252: LD_INT 1
26254: EQUAL
26255: IFFALSE 26305
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
26257: LD_EXP 67
26261: PPUSH
26262: LD_STRING D10nB-Vse-2
26264: PPUSH
26265: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
26269: LD_EXP 36
26273: PPUSH
26274: LD_STRING D10nB-JMM-3
26276: PPUSH
26277: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
26281: LD_EXP 67
26285: PPUSH
26286: LD_STRING D10nB-Vse-3
26288: PPUSH
26289: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
26293: LD_EXP 36
26297: PPUSH
26298: LD_STRING D10nB-JMM-4
26300: PPUSH
26301: CALL_OW 88
// end ; if JMMGirl = 2 then
26305: LD_EXP 7
26309: PUSH
26310: LD_INT 2
26312: EQUAL
26313: IFFALSE 26339
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
26315: LD_EXP 67
26319: PPUSH
26320: LD_STRING D10nB-Vse-4
26322: PPUSH
26323: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
26327: LD_EXP 36
26331: PPUSH
26332: LD_STRING D10nB-JMM-5
26334: PPUSH
26335: CALL_OW 88
// end ; if JMMGirl = 3 then
26339: LD_EXP 7
26343: PUSH
26344: LD_INT 3
26346: EQUAL
26347: IFFALSE 26373
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
26349: LD_EXP 67
26353: PPUSH
26354: LD_STRING D10nB-Vse-5
26356: PPUSH
26357: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
26361: LD_EXP 36
26365: PPUSH
26366: LD_STRING D10nB-JMM-6
26368: PPUSH
26369: CALL_OW 88
// end ; end ; DialogueOff ;
26373: CALL_OW 7
// end ;
26377: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
26378: LD_EXP 14
26382: PUSH
26383: LD_INT 115500
26385: GREATEREQUAL
26386: IFFALSE 26745
26388: GO 26390
26390: DISABLE
26391: LD_INT 0
26393: PPUSH
// begin missionStage := 10 ;
26394: LD_ADDR_EXP 15
26398: PUSH
26399: LD_INT 10
26401: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
26402: LD_ADDR_VAR 0 1
26406: PUSH
26407: LD_INT 22
26409: PUSH
26410: LD_INT 1
26412: PUSH
26413: EMPTY
26414: LIST
26415: LIST
26416: PUSH
26417: LD_INT 26
26419: PUSH
26420: LD_INT 1
26422: PUSH
26423: EMPTY
26424: LIST
26425: LIST
26426: PUSH
26427: LD_INT 3
26429: PUSH
26430: LD_INT 25
26432: PUSH
26433: LD_INT 12
26435: PUSH
26436: EMPTY
26437: LIST
26438: LIST
26439: PUSH
26440: EMPTY
26441: LIST
26442: LIST
26443: PUSH
26444: LD_INT 3
26446: PUSH
26447: LD_INT 25
26449: PUSH
26450: LD_INT 16
26452: PUSH
26453: EMPTY
26454: LIST
26455: LIST
26456: PUSH
26457: EMPTY
26458: LIST
26459: LIST
26460: PUSH
26461: EMPTY
26462: LIST
26463: LIST
26464: LIST
26465: LIST
26466: PPUSH
26467: CALL_OW 69
26471: PUSH
26472: LD_EXP 36
26476: PUSH
26477: LD_EXP 38
26481: PUSH
26482: LD_EXP 52
26486: PUSH
26487: LD_EXP 39
26491: PUSH
26492: LD_EXP 40
26496: PUSH
26497: LD_EXP 41
26501: PUSH
26502: LD_EXP 42
26506: PUSH
26507: LD_EXP 43
26511: PUSH
26512: LD_EXP 44
26516: PUSH
26517: LD_EXP 45
26521: PUSH
26522: LD_EXP 46
26526: PUSH
26527: LD_EXP 47
26531: PUSH
26532: LD_EXP 48
26536: PUSH
26537: LD_EXP 49
26541: PUSH
26542: LD_EXP 50
26546: PUSH
26547: EMPTY
26548: LIST
26549: LIST
26550: LIST
26551: LIST
26552: LIST
26553: LIST
26554: LIST
26555: LIST
26556: LIST
26557: LIST
26558: LIST
26559: LIST
26560: LIST
26561: LIST
26562: LIST
26563: DIFF
26564: ST_TO_ADDR
// if not tmp and Brown then
26565: LD_VAR 0 1
26569: NOT
26570: PUSH
26571: LD_EXP 44
26575: AND
26576: IFFALSE 26591
// tmp := [ Brown ] ;
26578: LD_ADDR_VAR 0 1
26582: PUSH
26583: LD_EXP 44
26587: PUSH
26588: EMPTY
26589: LIST
26590: ST_TO_ADDR
// DialogueOn ;
26591: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
26595: LD_VAR 0 1
26599: PUSH
26600: LD_INT 1
26602: ARRAY
26603: PPUSH
26604: LD_STRING D11-Sol1-1
26606: PPUSH
26607: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
26611: LD_EXP 61
26615: PPUSH
26616: LD_STRING D11-Pla-1
26618: PPUSH
26619: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
26623: LD_EXP 62
26627: PPUSH
26628: LD_STRING D11-Kov-1
26630: PPUSH
26631: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
26635: LD_EXP 61
26639: PPUSH
26640: LD_STRING D11-Pla-2
26642: PPUSH
26643: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
26647: LD_VAR 0 1
26651: PUSH
26652: LD_INT 1
26654: ARRAY
26655: PPUSH
26656: LD_STRING D11-Sol1-2
26658: PPUSH
26659: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
26663: LD_EXP 36
26667: PPUSH
26668: LD_STRING D11-JMM-2
26670: PPUSH
26671: CALL_OW 88
// DialogueOff ;
26675: CALL_OW 7
// allowBehemothConstruct := true ;
26679: LD_ADDR_EXP 25
26683: PUSH
26684: LD_INT 1
26686: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
26687: LD_STRING M4
26689: PPUSH
26690: CALL_OW 337
// BuildBehemoths ;
26694: CALL 7481 0 0
// repeat wait ( 15 15$00 ) ;
26698: LD_INT 31500
26700: PPUSH
26701: CALL_OW 67
// if behemothDestroyedBeforeFinish then
26705: LD_EXP 27
26709: IFFALSE 26713
// break ;
26711: GO 26745
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
26713: LD_INT 267
26715: PPUSH
26716: CALL_OW 274
26720: PPUSH
26721: LD_INT 1
26723: PPUSH
26724: CALL_OW 275
26728: PUSH
26729: LD_INT 1000
26731: GREATEREQUAL
26732: IFFALSE 26738
// BuildBehemoths ;
26734: CALL 7481 0 0
// until not behemothBuilders ;
26738: LD_EXP 70
26742: NOT
26743: IFFALSE 26698
// end ;
26745: PPOPN 1
26747: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
26748: LD_EXP 70
26752: NOT
26753: PUSH
26754: LD_EXP 28
26758: NOT
26759: AND
26760: PUSH
26761: LD_EXP 25
26765: AND
26766: IFFALSE 26786
26768: GO 26770
26770: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
26771: LD_STRING M4a
26773: PPUSH
26774: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
26778: LD_ADDR_EXP 27
26782: PUSH
26783: LD_INT 1
26785: ST_TO_ADDR
// end ;
26786: END
// every 0 0$1 trigger behemothDone do
26787: LD_EXP 28
26791: IFFALSE 26803
26793: GO 26795
26795: DISABLE
// ChangeMissionObjectives ( M4b ) ;
26796: LD_STRING M4b
26798: PPUSH
26799: CALL_OW 337
26803: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
26804: LD_EXP 29
26808: NOT
26809: IFFALSE 27005
26811: GO 26813
26813: DISABLE
26814: LD_INT 0
26816: PPUSH
26817: PPUSH
// begin enable ;
26818: ENABLE
// tmp := GetBehemoths ( 3 ) ;
26819: LD_ADDR_VAR 0 1
26823: PUSH
26824: LD_INT 3
26826: PPUSH
26827: CALL 104292 0 1
26831: ST_TO_ADDR
// if not tmp and not behemothDone then
26832: LD_VAR 0 1
26836: NOT
26837: PUSH
26838: LD_EXP 28
26842: NOT
26843: AND
26844: IFFALSE 26880
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
26846: LD_ADDR_VAR 0 1
26850: PUSH
26851: LD_INT 22
26853: PUSH
26854: LD_INT 3
26856: PUSH
26857: EMPTY
26858: LIST
26859: LIST
26860: PUSH
26861: LD_INT 30
26863: PUSH
26864: LD_INT 37
26866: PUSH
26867: EMPTY
26868: LIST
26869: LIST
26870: PUSH
26871: EMPTY
26872: LIST
26873: LIST
26874: PPUSH
26875: CALL_OW 69
26879: ST_TO_ADDR
// if not tmp then
26880: LD_VAR 0 1
26884: NOT
26885: IFFALSE 26889
// exit ;
26887: GO 27005
// for i in tmp do
26889: LD_ADDR_VAR 0 2
26893: PUSH
26894: LD_VAR 0 1
26898: PUSH
26899: FOR_IN
26900: IFFALSE 27003
// if See ( 1 , i ) then
26902: LD_INT 1
26904: PPUSH
26905: LD_VAR 0 2
26909: PPUSH
26910: CALL_OW 292
26914: IFFALSE 27001
// begin if GetType ( i ) = unit_building then
26916: LD_VAR 0 2
26920: PPUSH
26921: CALL_OW 247
26925: PUSH
26926: LD_INT 3
26928: EQUAL
26929: IFFALSE 26967
// begin CenterNowOnUnits ( i ) ;
26931: LD_VAR 0 2
26935: PPUSH
26936: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
26940: LD_EXP 36
26944: PPUSH
26945: LD_STRING D17a-JMM-1
26947: PPUSH
26948: CALL_OW 88
// seeBehemoth := true ;
26952: LD_ADDR_EXP 29
26956: PUSH
26957: LD_INT 1
26959: ST_TO_ADDR
// disable ;
26960: DISABLE
// exit ;
26961: POP
26962: POP
26963: GO 27005
// end else
26965: GO 27001
// begin CenterNowOnUnits ( i ) ;
26967: LD_VAR 0 2
26971: PPUSH
26972: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
26976: LD_EXP 36
26980: PPUSH
26981: LD_STRING D17b-JMM-1
26983: PPUSH
26984: CALL_OW 88
// seeBehemoth := true ;
26988: LD_ADDR_EXP 29
26992: PUSH
26993: LD_INT 1
26995: ST_TO_ADDR
// disable ;
26996: DISABLE
// exit ;
26997: POP
26998: POP
26999: GO 27005
// end ; end ;
27001: GO 26899
27003: POP
27004: POP
// end ;
27005: PPOPN 2
27007: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27008: LD_EXP 14
27012: PUSH
27013: LD_INT 116550
27015: GREATEREQUAL
27016: IFFALSE 28192
27018: GO 27020
27020: DISABLE
27021: LD_INT 0
27023: PPUSH
27024: PPUSH
27025: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27026: LD_INT 2
27028: PPUSH
27029: LD_INT 23
27031: PUSH
27032: LD_INT 3
27034: PUSH
27035: LD_INT 3
27037: PUSH
27038: LD_INT 48
27040: PUSH
27041: EMPTY
27042: LIST
27043: LIST
27044: LIST
27045: LIST
27046: PUSH
27047: EMPTY
27048: LIST
27049: PPUSH
27050: CALL 55996 0 2
// repeat wait ( 0 0$1 ) ;
27054: LD_INT 35
27056: PPUSH
27057: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
27061: LD_INT 22
27063: PUSH
27064: LD_INT 3
27066: PUSH
27067: EMPTY
27068: LIST
27069: LIST
27070: PUSH
27071: LD_INT 34
27073: PUSH
27074: LD_INT 48
27076: PUSH
27077: EMPTY
27078: LIST
27079: LIST
27080: PUSH
27081: EMPTY
27082: LIST
27083: LIST
27084: PPUSH
27085: CALL_OW 69
27089: IFFALSE 27054
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27091: LD_ADDR_VAR 0 1
27095: PUSH
27096: LD_INT 22
27098: PUSH
27099: LD_INT 3
27101: PUSH
27102: EMPTY
27103: LIST
27104: LIST
27105: PUSH
27106: LD_INT 34
27108: PUSH
27109: LD_INT 48
27111: PUSH
27112: EMPTY
27113: LIST
27114: LIST
27115: PUSH
27116: EMPTY
27117: LIST
27118: LIST
27119: PPUSH
27120: CALL_OW 69
27124: PUSH
27125: LD_INT 1
27127: ARRAY
27128: ST_TO_ADDR
// missionStage := 12 ;
27129: LD_ADDR_EXP 15
27133: PUSH
27134: LD_INT 12
27136: ST_TO_ADDR
// platonovHasBomb := true ;
27137: LD_ADDR_EXP 30
27141: PUSH
27142: LD_INT 1
27144: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
27145: LD_VAR 0 1
27149: PPUSH
27150: LD_INT 181
27152: PPUSH
27153: LD_INT 86
27155: PPUSH
27156: CALL_OW 171
// AddComHold ( bomb ) ;
27160: LD_VAR 0 1
27164: PPUSH
27165: CALL_OW 200
// wait ( 0 0$10 ) ;
27169: LD_INT 350
27171: PPUSH
27172: CALL_OW 67
// DialogueOn ;
27176: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
27180: LD_EXP 61
27184: PPUSH
27185: LD_STRING D15-Pla-1
27187: PPUSH
27188: CALL_OW 94
// dec = Query ( Q15a ) ;
27192: LD_ADDR_VAR 0 2
27196: PUSH
27197: LD_STRING Q15a
27199: PPUSH
27200: CALL_OW 97
27204: ST_TO_ADDR
// if dec = 1 then
27205: LD_VAR 0 2
27209: PUSH
27210: LD_INT 1
27212: EQUAL
27213: IFFALSE 27236
// begin Say ( JMM , D15a-JMM-1 ) ;
27215: LD_EXP 36
27219: PPUSH
27220: LD_STRING D15a-JMM-1
27222: PPUSH
27223: CALL_OW 88
// YouLost ( Surrender ) ;
27227: LD_STRING Surrender
27229: PPUSH
27230: CALL_OW 104
// exit ;
27234: GO 28192
// end ; if dec = 2 then
27236: LD_VAR 0 2
27240: PUSH
27241: LD_INT 2
27243: EQUAL
27244: IFFALSE 27313
// begin Say ( JMM , D15b-JMM-1 ) ;
27246: LD_EXP 36
27250: PPUSH
27251: LD_STRING D15b-JMM-1
27253: PPUSH
27254: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
27258: LD_EXP 61
27262: PPUSH
27263: LD_STRING D15b-Pla-1
27265: PPUSH
27266: CALL_OW 94
// DialogueOff ;
27270: CALL_OW 7
// wait ( 3 3$00 ) ;
27274: LD_INT 6300
27276: PPUSH
27277: CALL_OW 67
// DialogueOn ;
27281: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
27285: LD_EXP 36
27289: PPUSH
27290: LD_STRING D15d-JMM-1a
27292: PPUSH
27293: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27297: LD_EXP 61
27301: PPUSH
27302: LD_STRING D15d-Pla-1
27304: PPUSH
27305: CALL_OW 94
// DialogueOff ;
27309: CALL_OW 7
// end ; if dec = 3 then
27313: LD_VAR 0 2
27317: PUSH
27318: LD_INT 3
27320: EQUAL
27321: IFFALSE 27375
// begin Say ( JMM , D15c-JMM-1 ) ;
27323: LD_EXP 36
27327: PPUSH
27328: LD_STRING D15c-JMM-1
27330: PPUSH
27331: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
27335: LD_EXP 61
27339: PPUSH
27340: LD_STRING D15c-Pla-1
27342: PPUSH
27343: CALL_OW 94
// DialogueOff ;
27347: CALL_OW 7
// wait ( 0 0$15 ) ;
27351: LD_INT 525
27353: PPUSH
27354: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
27358: LD_VAR 0 1
27362: PPUSH
27363: LD_INT 60
27365: PPUSH
27366: LD_INT 95
27368: PPUSH
27369: CALL_OW 116
// exit ;
27373: GO 28192
// end ; if dec = 4 then
27375: LD_VAR 0 2
27379: PUSH
27380: LD_INT 4
27382: EQUAL
27383: IFFALSE 27413
// begin Say ( JMM , D15d-JMM-1 ) ;
27385: LD_EXP 36
27389: PPUSH
27390: LD_STRING D15d-JMM-1
27392: PPUSH
27393: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27397: LD_EXP 61
27401: PPUSH
27402: LD_STRING D15d-Pla-1
27404: PPUSH
27405: CALL_OW 94
// DialogueOff ;
27409: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27413: LD_EXP 59
27417: PPUSH
27418: CALL_OW 302
27422: PUSH
27423: LD_EXP 59
27427: PPUSH
27428: CALL_OW 255
27432: PUSH
27433: LD_INT 1
27435: EQUAL
27436: AND
27437: PUSH
27438: LD_INT 22
27440: PUSH
27441: LD_INT 1
27443: PUSH
27444: EMPTY
27445: LIST
27446: LIST
27447: PUSH
27448: LD_INT 34
27450: PUSH
27451: LD_INT 8
27453: PUSH
27454: EMPTY
27455: LIST
27456: LIST
27457: PUSH
27458: EMPTY
27459: LIST
27460: LIST
27461: PPUSH
27462: CALL_OW 69
27466: NOT
27467: AND
27468: IFFALSE 28093
// begin SetSide ( Friend , 8 ) ;
27470: LD_EXP 59
27474: PPUSH
27475: LD_INT 8
27477: PPUSH
27478: CALL_OW 235
// if IsInUnit ( Friend ) then
27482: LD_EXP 59
27486: PPUSH
27487: CALL_OW 310
27491: IFFALSE 27502
// ComExitBuilding ( Friend ) ;
27493: LD_EXP 59
27497: PPUSH
27498: CALL_OW 122
// if IsDriver ( Friend ) then
27502: LD_EXP 59
27506: PPUSH
27507: CALL 101968 0 1
27511: IFFALSE 27522
// ComExitVehicle ( Friend ) ;
27513: LD_EXP 59
27517: PPUSH
27518: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27522: LD_EXP 59
27526: PPUSH
27527: LD_INT 9
27529: PPUSH
27530: LD_INT 2
27532: PPUSH
27533: CALL_OW 171
// wait ( 0 0$05 ) ;
27537: LD_INT 175
27539: PPUSH
27540: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27544: LD_EXP 59
27548: PPUSH
27549: CALL_OW 87
// DialogueOn ;
27553: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
27557: LD_EXP 36
27561: PPUSH
27562: LD_STRING D16-JMM-1
27564: PPUSH
27565: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
27569: LD_EXP 59
27573: PPUSH
27574: LD_STRING D16-Friend-1
27576: PPUSH
27577: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
27581: LD_EXP 36
27585: PPUSH
27586: LD_STRING D16-JMM-2
27588: PPUSH
27589: CALL_OW 88
// DialogueOff ;
27593: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27597: LD_EXP 59
27601: PPUSH
27602: LD_INT 1
27604: PPUSH
27605: CALL_OW 235
// ComHold ( Friend ) ;
27609: LD_EXP 59
27613: PPUSH
27614: CALL_OW 140
// wait ( 0 0$20 ) ;
27618: LD_INT 700
27620: PPUSH
27621: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
27625: LD_EXP 59
27629: PPUSH
27630: LD_INT 9
27632: PPUSH
27633: LD_INT 2
27635: PPUSH
27636: CALL_OW 297
27640: PUSH
27641: LD_INT 30
27643: LESS
27644: IFFALSE 27713
// begin SetSide ( Friend , 8 ) ;
27646: LD_EXP 59
27650: PPUSH
27651: LD_INT 8
27653: PPUSH
27654: CALL_OW 235
// if IsInUnit ( Friend ) then
27658: LD_EXP 59
27662: PPUSH
27663: CALL_OW 310
27667: IFFALSE 27678
// ComExitBuilding ( Friend ) ;
27669: LD_EXP 59
27673: PPUSH
27674: CALL_OW 122
// if IsDriver ( Friend ) then
27678: LD_EXP 59
27682: PPUSH
27683: CALL 101968 0 1
27687: IFFALSE 27698
// ComExitVehicle ( Friend ) ;
27689: LD_EXP 59
27693: PPUSH
27694: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27698: LD_EXP 59
27702: PPUSH
27703: LD_INT 9
27705: PPUSH
27706: LD_INT 2
27708: PPUSH
27709: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
27713: LD_INT 1050
27715: PPUSH
27716: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27720: LD_INT 22
27722: PUSH
27723: LD_INT 1
27725: PUSH
27726: EMPTY
27727: LIST
27728: LIST
27729: PUSH
27730: LD_INT 34
27732: PUSH
27733: LD_INT 8
27735: PUSH
27736: EMPTY
27737: LIST
27738: LIST
27739: PUSH
27740: EMPTY
27741: LIST
27742: LIST
27743: PPUSH
27744: CALL_OW 69
27748: NOT
27749: IFFALSE 28071
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27751: LD_ADDR_VAR 0 3
27755: PUSH
27756: LD_INT 22
27758: PUSH
27759: LD_INT 1
27761: PUSH
27762: EMPTY
27763: LIST
27764: LIST
27765: PUSH
27766: LD_INT 26
27768: PUSH
27769: LD_INT 1
27771: PUSH
27772: EMPTY
27773: LIST
27774: LIST
27775: PUSH
27776: LD_INT 3
27778: PUSH
27779: LD_INT 25
27781: PUSH
27782: LD_INT 12
27784: PUSH
27785: EMPTY
27786: LIST
27787: LIST
27788: PUSH
27789: LD_INT 25
27791: PUSH
27792: LD_INT 16
27794: PUSH
27795: EMPTY
27796: LIST
27797: LIST
27798: PUSH
27799: EMPTY
27800: LIST
27801: LIST
27802: LIST
27803: PUSH
27804: EMPTY
27805: LIST
27806: LIST
27807: LIST
27808: PPUSH
27809: CALL_OW 69
27813: PUSH
27814: LD_EXP 36
27818: PUSH
27819: LD_EXP 38
27823: PUSH
27824: LD_EXP 52
27828: PUSH
27829: LD_EXP 39
27833: PUSH
27834: LD_EXP 40
27838: PUSH
27839: LD_EXP 41
27843: PUSH
27844: LD_EXP 42
27848: PUSH
27849: LD_EXP 43
27853: PUSH
27854: LD_EXP 44
27858: PUSH
27859: LD_EXP 45
27863: PUSH
27864: LD_EXP 46
27868: PUSH
27869: LD_EXP 47
27873: PUSH
27874: LD_EXP 48
27878: PUSH
27879: LD_EXP 49
27883: PUSH
27884: LD_EXP 50
27888: PUSH
27889: EMPTY
27890: LIST
27891: LIST
27892: LIST
27893: LIST
27894: LIST
27895: LIST
27896: LIST
27897: LIST
27898: LIST
27899: LIST
27900: LIST
27901: LIST
27902: LIST
27903: LIST
27904: LIST
27905: DIFF
27906: ST_TO_ADDR
// DialogueOn ;
27907: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
27911: LD_EXP 61
27915: PPUSH
27916: LD_STRING D16a-Pla-1
27918: PPUSH
27919: CALL_OW 94
// if Stevens then
27923: LD_EXP 38
27927: IFFALSE 27943
// Say ( Stevens , D16a-Huck-1 ) else
27929: LD_EXP 38
27933: PPUSH
27934: LD_STRING D16a-Huck-1
27936: PPUSH
27937: CALL_OW 88
27941: GO 27985
// if Baker then
27943: LD_EXP 52
27947: IFFALSE 27963
// Say ( Baker , D16a-Huck-1 ) else
27949: LD_EXP 52
27953: PPUSH
27954: LD_STRING D16a-Huck-1
27956: PPUSH
27957: CALL_OW 88
27961: GO 27985
// if tmp then
27963: LD_VAR 0 3
27967: IFFALSE 27985
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
27969: LD_VAR 0 3
27973: PUSH
27974: LD_INT 1
27976: ARRAY
27977: PPUSH
27978: LD_STRING D16a-Sol1-1
27980: PPUSH
27981: CALL_OW 88
// if GetSide ( Friend ) = 8 then
27985: LD_EXP 59
27989: PPUSH
27990: CALL_OW 255
27994: PUSH
27995: LD_INT 8
27997: EQUAL
27998: IFFALSE 28014
// Say ( JMM , D16a-JMM-1 ) else
28000: LD_EXP 36
28004: PPUSH
28005: LD_STRING D16a-JMM-1
28007: PPUSH
28008: CALL_OW 88
28012: GO 28050
// begin Say ( JMM , D16a-JMM-1a ) ;
28014: LD_EXP 36
28018: PPUSH
28019: LD_STRING D16a-JMM-1a
28021: PPUSH
28022: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28026: LD_EXP 59
28030: PPUSH
28031: LD_STRING D16a-Friend-1
28033: PPUSH
28034: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28038: LD_EXP 59
28042: PPUSH
28043: LD_INT 3
28045: PPUSH
28046: CALL_OW 235
// end ; DialogueOff ;
28050: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
28054: LD_VAR 0 1
28058: PPUSH
28059: LD_INT 60
28061: PPUSH
28062: LD_INT 95
28064: PPUSH
28065: CALL_OW 116
// end else
28069: GO 28091
// begin DialogueOn ;
28071: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28075: LD_EXP 61
28079: PPUSH
28080: LD_STRING D16c-Pla-
28082: PPUSH
28083: CALL_OW 94
// DialogueOff ;
28087: CALL_OW 7
// end ; end else
28091: GO 28192
// begin wait ( 3 3$00 ) ;
28093: LD_INT 6300
28095: PPUSH
28096: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28100: LD_INT 22
28102: PUSH
28103: LD_INT 1
28105: PUSH
28106: EMPTY
28107: LIST
28108: LIST
28109: PUSH
28110: LD_INT 34
28112: PUSH
28113: LD_INT 8
28115: PUSH
28116: EMPTY
28117: LIST
28118: LIST
28119: PUSH
28120: EMPTY
28121: LIST
28122: LIST
28123: PPUSH
28124: CALL_OW 69
28128: NOT
28129: IFFALSE 28172
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
28131: LD_EXP 61
28135: PPUSH
28136: LD_STRING D16b-Pla-1
28138: PPUSH
28139: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
28143: LD_EXP 36
28147: PPUSH
28148: LD_STRING D16b-JMM-
28150: PPUSH
28151: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
28155: LD_VAR 0 1
28159: PPUSH
28160: LD_INT 60
28162: PPUSH
28163: LD_INT 95
28165: PPUSH
28166: CALL_OW 116
// end else
28170: GO 28192
// begin DialogueOn ;
28172: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28176: LD_EXP 61
28180: PPUSH
28181: LD_STRING D16c-Pla-
28183: PPUSH
28184: CALL_OW 94
// DialogueOff ;
28188: CALL_OW 7
// end ; end ; end ;
28192: PPOPN 3
28194: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
28195: LD_EXP 14
28199: PUSH
28200: LD_INT 126000
28202: GREATEREQUAL
28203: PUSH
28204: LD_EXP 23
28208: NOT
28209: AND
28210: PUSH
28211: LD_EXP 71
28215: PPUSH
28216: CALL_OW 302
28220: AND
28221: IFFALSE 28579
28223: GO 28225
28225: DISABLE
28226: LD_INT 0
28228: PPUSH
// begin missionStage = 11 ;
28229: LD_ADDR_EXP 15
28233: PUSH
28234: LD_INT 11
28236: ST_TO_ADDR
// DialogueOn ;
28237: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
28241: LD_EXP 71
28245: PPUSH
28246: LD_STRING D9-Roth-1
28248: PPUSH
28249: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
28253: LD_EXP 36
28257: PPUSH
28258: LD_STRING D9-JMM-1
28260: PPUSH
28261: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
28265: LD_EXP 71
28269: PPUSH
28270: LD_STRING D9-Roth-2
28272: PPUSH
28273: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
28277: LD_EXP 71
28281: PPUSH
28282: LD_STRING D9-Roth-2a
28284: PPUSH
28285: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
28289: LD_EXP 61
28293: PPUSH
28294: LD_STRING D9-Pla-2
28296: PPUSH
28297: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
28301: LD_EXP 71
28305: PPUSH
28306: LD_STRING D9-Roth-3
28308: PPUSH
28309: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
28313: LD_EXP 61
28317: PPUSH
28318: LD_STRING D9-Pla-3
28320: PPUSH
28321: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
28325: LD_EXP 71
28329: PPUSH
28330: LD_STRING D9-Roth-4
28332: PPUSH
28333: CALL_OW 94
// dec = Query ( Q9 ) ;
28337: LD_ADDR_VAR 0 1
28341: PUSH
28342: LD_STRING Q9
28344: PPUSH
28345: CALL_OW 97
28349: ST_TO_ADDR
// if dec = 1 then
28350: LD_VAR 0 1
28354: PUSH
28355: LD_INT 1
28357: EQUAL
28358: IFFALSE 28372
// SayRadio ( Roth , D9a-Roth-1 ) ;
28360: LD_EXP 71
28364: PPUSH
28365: LD_STRING D9a-Roth-1
28367: PPUSH
28368: CALL_OW 94
// if dec = 2 then
28372: LD_VAR 0 1
28376: PUSH
28377: LD_INT 2
28379: EQUAL
28380: IFFALSE 28406
// begin Say ( JMM , D9b-JMM-1 ) ;
28382: LD_EXP 36
28386: PPUSH
28387: LD_STRING D9b-JMM-1
28389: PPUSH
28390: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
28394: LD_EXP 71
28398: PPUSH
28399: LD_STRING D9b-Roth-1
28401: PPUSH
28402: CALL_OW 94
// end ; if dec = 3 then
28406: LD_VAR 0 1
28410: PUSH
28411: LD_INT 3
28413: EQUAL
28414: IFFALSE 28476
// begin Say ( JMM , D9c-JMM-1 ) ;
28416: LD_EXP 36
28420: PPUSH
28421: LD_STRING D9c-JMM-1
28423: PPUSH
28424: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
28428: LD_EXP 71
28432: PPUSH
28433: LD_STRING D9c-Roth-1
28435: PPUSH
28436: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
28440: LD_EXP 36
28444: PPUSH
28445: LD_STRING D9c-JMM-2
28447: PPUSH
28448: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
28452: LD_EXP 71
28456: PPUSH
28457: LD_STRING D9c-Roth-2
28459: PPUSH
28460: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
28464: LD_EXP 36
28468: PPUSH
28469: LD_STRING D9c-JMM-3
28471: PPUSH
28472: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
28476: LD_EXP 71
28480: PPUSH
28481: LD_STRING D9c-Roth-3
28483: PPUSH
28484: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
28488: LD_EXP 71
28492: PPUSH
28493: LD_STRING D9cont-Roth-1
28495: PPUSH
28496: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
28500: LD_EXP 36
28504: PPUSH
28505: LD_STRING D9cont-JMM-1
28507: PPUSH
28508: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
28512: LD_EXP 71
28516: PPUSH
28517: LD_STRING D9cont-Roth-2
28519: PPUSH
28520: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
28524: LD_EXP 36
28528: PPUSH
28529: LD_STRING D9cont-JMM-2
28531: PPUSH
28532: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
28536: LD_EXP 71
28540: PPUSH
28541: LD_STRING D9cont-Roth-3
28543: PPUSH
28544: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
28548: LD_EXP 36
28552: PPUSH
28553: LD_STRING D9cont-JMM-3
28555: PPUSH
28556: CALL_OW 88
// DialogueOff ;
28560: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
28564: LD_STRING M3
28566: PPUSH
28567: CALL_OW 337
// allianceActive := true ;
28571: LD_ADDR_EXP 31
28575: PUSH
28576: LD_INT 1
28578: ST_TO_ADDR
// end ;
28579: PPOPN 1
28581: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
28582: LD_EXP 61
28586: PPUSH
28587: CALL_OW 301
28591: PUSH
28592: LD_EXP 64
28596: PPUSH
28597: CALL_OW 301
28601: AND
28602: PUSH
28603: LD_INT 22
28605: PUSH
28606: LD_INT 3
28608: PUSH
28609: EMPTY
28610: LIST
28611: LIST
28612: PUSH
28613: LD_INT 21
28615: PUSH
28616: LD_INT 1
28618: PUSH
28619: EMPTY
28620: LIST
28621: LIST
28622: PUSH
28623: LD_INT 50
28625: PUSH
28626: EMPTY
28627: LIST
28628: PUSH
28629: EMPTY
28630: LIST
28631: LIST
28632: LIST
28633: PPUSH
28634: CALL_OW 69
28638: PUSH
28639: LD_INT 7
28641: PUSH
28642: LD_INT 8
28644: PUSH
28645: LD_INT 9
28647: PUSH
28648: EMPTY
28649: LIST
28650: LIST
28651: LIST
28652: PUSH
28653: LD_OWVAR 67
28657: ARRAY
28658: LESS
28659: AND
28660: IFFALSE 29431
28662: GO 28664
28664: DISABLE
28665: LD_INT 0
28667: PPUSH
28668: PPUSH
28669: PPUSH
28670: PPUSH
// begin MC_Kill ( 1 ) ;
28671: LD_INT 1
28673: PPUSH
28674: CALL 33917 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
28678: LD_INT 1
28680: PPUSH
28681: LD_INT 3
28683: PPUSH
28684: LD_INT 1
28686: PPUSH
28687: LD_INT 1
28689: PPUSH
28690: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
28694: LD_ADDR_VAR 0 1
28698: PUSH
28699: LD_INT 22
28701: PUSH
28702: LD_INT 3
28704: PUSH
28705: EMPTY
28706: LIST
28707: LIST
28708: PUSH
28709: LD_INT 21
28711: PUSH
28712: LD_INT 1
28714: PUSH
28715: EMPTY
28716: LIST
28717: LIST
28718: PUSH
28719: LD_INT 24
28721: PUSH
28722: LD_INT 900
28724: PUSH
28725: EMPTY
28726: LIST
28727: LIST
28728: PUSH
28729: EMPTY
28730: LIST
28731: LIST
28732: LIST
28733: PPUSH
28734: CALL_OW 69
28738: PUSH
28739: FOR_IN
28740: IFFALSE 28771
// if GetSex ( i ) = sex_male then
28742: LD_VAR 0 1
28746: PPUSH
28747: CALL_OW 258
28751: PUSH
28752: LD_INT 1
28754: EQUAL
28755: IFFALSE 28769
// begin tmp = i ;
28757: LD_ADDR_VAR 0 2
28761: PUSH
28762: LD_VAR 0 1
28766: ST_TO_ADDR
// break ;
28767: GO 28771
// end ;
28769: GO 28739
28771: POP
28772: POP
// if tmp = 0 then
28773: LD_VAR 0 2
28777: PUSH
28778: LD_INT 0
28780: EQUAL
28781: IFFALSE 28835
// begin uc_side = 3 ;
28783: LD_ADDR_OWVAR 20
28787: PUSH
28788: LD_INT 3
28790: ST_TO_ADDR
// uc_nation = 3 ;
28791: LD_ADDR_OWVAR 21
28795: PUSH
28796: LD_INT 3
28798: ST_TO_ADDR
// hc_name =  ;
28799: LD_ADDR_OWVAR 26
28803: PUSH
28804: LD_STRING 
28806: ST_TO_ADDR
// hc_gallery =  ;
28807: LD_ADDR_OWVAR 33
28811: PUSH
28812: LD_STRING 
28814: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
28815: LD_INT 1
28817: PPUSH
28818: LD_INT 10
28820: PPUSH
28821: CALL_OW 381
// tmp = CreateHuman ;
28825: LD_ADDR_VAR 0 2
28829: PUSH
28830: CALL_OW 44
28834: ST_TO_ADDR
// end ; DialogueOn ;
28835: CALL_OW 6
// Say ( tmp , DSurrenderRussians-RSol1-1a ) ;
28839: LD_VAR 0 2
28843: PPUSH
28844: LD_STRING DSurrenderRussians-RSol1-1a
28846: PPUSH
28847: CALL_OW 88
// DialogueOff ;
28851: CALL_OW 7
// russianDestroyed := true ;
28855: LD_ADDR_EXP 21
28859: PUSH
28860: LD_INT 1
28862: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
28863: LD_INT 22
28865: PUSH
28866: LD_INT 3
28868: PUSH
28869: EMPTY
28870: LIST
28871: LIST
28872: PUSH
28873: LD_INT 21
28875: PUSH
28876: LD_INT 1
28878: PUSH
28879: EMPTY
28880: LIST
28881: LIST
28882: PUSH
28883: EMPTY
28884: LIST
28885: LIST
28886: PPUSH
28887: CALL_OW 69
28891: PPUSH
28892: CALL_OW 122
// wait ( 0 0$1 ) ;
28896: LD_INT 35
28898: PPUSH
28899: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
28903: LD_INT 22
28905: PUSH
28906: LD_INT 3
28908: PUSH
28909: EMPTY
28910: LIST
28911: LIST
28912: PUSH
28913: LD_INT 21
28915: PUSH
28916: LD_INT 1
28918: PUSH
28919: EMPTY
28920: LIST
28921: LIST
28922: PUSH
28923: EMPTY
28924: LIST
28925: LIST
28926: PPUSH
28927: CALL_OW 69
28931: PPUSH
28932: LD_INT 25
28934: PPUSH
28935: CALL_OW 173
// wait ( 0 0$10 ) ;
28939: LD_INT 350
28941: PPUSH
28942: CALL_OW 67
// PrepareOmarInvasion ;
28946: CALL 13604 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
28950: LD_ADDR_VAR 0 2
28954: PUSH
28955: LD_EXP 89
28959: PPUSH
28960: CALL_OW 250
28964: PUSH
28965: LD_EXP 89
28969: PPUSH
28970: CALL_OW 251
28974: PUSH
28975: EMPTY
28976: LIST
28977: LIST
28978: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
28979: LD_VAR 0 2
28983: PUSH
28984: LD_INT 1
28986: ARRAY
28987: PPUSH
28988: LD_VAR 0 2
28992: PUSH
28993: LD_INT 2
28995: ARRAY
28996: PPUSH
28997: LD_INT 1
28999: PPUSH
29000: LD_INT 8
29002: NEG
29003: PPUSH
29004: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29008: LD_EXP 89
29012: PPUSH
29013: CALL_OW 87
// DialogueOn ;
29017: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29021: LD_EXP 36
29025: PPUSH
29026: LD_STRING D19-JMM-1
29028: PPUSH
29029: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29033: LD_ADDR_VAR 0 3
29037: PUSH
29038: LD_INT 22
29040: PUSH
29041: LD_INT 1
29043: PUSH
29044: EMPTY
29045: LIST
29046: LIST
29047: PUSH
29048: LD_INT 26
29050: PUSH
29051: LD_INT 1
29053: PUSH
29054: EMPTY
29055: LIST
29056: LIST
29057: PUSH
29058: LD_INT 2
29060: PUSH
29061: LD_INT 25
29063: PUSH
29064: LD_INT 1
29066: PUSH
29067: EMPTY
29068: LIST
29069: LIST
29070: PUSH
29071: LD_INT 25
29073: PUSH
29074: LD_INT 2
29076: PUSH
29077: EMPTY
29078: LIST
29079: LIST
29080: PUSH
29081: LD_INT 25
29083: PUSH
29084: LD_INT 3
29086: PUSH
29087: EMPTY
29088: LIST
29089: LIST
29090: PUSH
29091: LD_INT 25
29093: PUSH
29094: LD_INT 4
29096: PUSH
29097: EMPTY
29098: LIST
29099: LIST
29100: PUSH
29101: LD_INT 25
29103: PUSH
29104: LD_INT 5
29106: PUSH
29107: EMPTY
29108: LIST
29109: LIST
29110: PUSH
29111: LD_INT 25
29113: PUSH
29114: LD_INT 8
29116: PUSH
29117: EMPTY
29118: LIST
29119: LIST
29120: PUSH
29121: EMPTY
29122: LIST
29123: LIST
29124: LIST
29125: LIST
29126: LIST
29127: LIST
29128: LIST
29129: PUSH
29130: EMPTY
29131: LIST
29132: LIST
29133: LIST
29134: PPUSH
29135: CALL_OW 69
29139: PUSH
29140: LD_EXP 36
29144: PUSH
29145: LD_EXP 37
29149: PUSH
29150: LD_EXP 38
29154: PUSH
29155: LD_EXP 39
29159: PUSH
29160: LD_EXP 40
29164: PUSH
29165: LD_EXP 41
29169: PUSH
29170: LD_EXP 42
29174: PUSH
29175: LD_EXP 43
29179: PUSH
29180: LD_EXP 44
29184: PUSH
29185: LD_EXP 45
29189: PUSH
29190: LD_EXP 46
29194: PUSH
29195: LD_EXP 47
29199: PUSH
29200: LD_EXP 48
29204: PUSH
29205: LD_EXP 49
29209: PUSH
29210: LD_EXP 50
29214: PUSH
29215: LD_EXP 51
29219: PUSH
29220: LD_EXP 52
29224: PUSH
29225: EMPTY
29226: LIST
29227: LIST
29228: LIST
29229: LIST
29230: LIST
29231: LIST
29232: LIST
29233: LIST
29234: LIST
29235: LIST
29236: LIST
29237: LIST
29238: LIST
29239: LIST
29240: LIST
29241: LIST
29242: LIST
29243: DIFF
29244: ST_TO_ADDR
// if tmp2 then
29245: LD_VAR 0 3
29249: IFFALSE 29267
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
29251: LD_VAR 0 3
29255: PUSH
29256: LD_INT 1
29258: ARRAY
29259: PPUSH
29260: LD_STRING D19-Sol1-1
29262: PPUSH
29263: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
29267: LD_EXP 36
29271: PPUSH
29272: LD_STRING D19-JMM-2
29274: PPUSH
29275: CALL_OW 88
// DialogueOff ;
29279: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
29283: LD_VAR 0 2
29287: PUSH
29288: LD_INT 1
29290: ARRAY
29291: PPUSH
29292: LD_VAR 0 2
29296: PUSH
29297: LD_INT 2
29299: ARRAY
29300: PPUSH
29301: LD_INT 1
29303: PPUSH
29304: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
29308: LD_STRING M5
29310: PPUSH
29311: CALL_OW 337
// omarOnMotherLode := false ;
29315: LD_ADDR_VAR 0 4
29319: PUSH
29320: LD_INT 0
29322: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29323: LD_INT 35
29325: PPUSH
29326: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
29330: LD_EXP 89
29334: PPUSH
29335: LD_INT 215
29337: PPUSH
29338: LD_INT 100
29340: PPUSH
29341: CALL_OW 297
29345: PUSH
29346: LD_INT 10
29348: LESS
29349: PUSH
29350: LD_VAR 0 4
29354: NOT
29355: AND
29356: IFFALSE 29390
// begin omarOnMotherLode := true ;
29358: LD_ADDR_VAR 0 4
29362: PUSH
29363: LD_INT 1
29365: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
29366: LD_EXP 36
29370: PPUSH
29371: LD_STRING D19b-JMM-1
29373: PPUSH
29374: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
29378: LD_EXP 89
29382: PPUSH
29383: LD_STRING DOmarContam-Omar-1
29385: PPUSH
29386: CALL_OW 88
// end ; until IsDead ( Omar ) ;
29390: LD_EXP 89
29394: PPUSH
29395: CALL_OW 301
29399: IFFALSE 29323
// Say ( JMM , D19a-JMM-1 ) ;
29401: LD_EXP 36
29405: PPUSH
29406: LD_STRING D19a-JMM-1
29408: PPUSH
29409: CALL_OW 88
// if Heike then
29413: LD_EXP 90
29417: IFFALSE 29431
// Say ( Heike , D19a-Hke-1 ) ;
29419: LD_EXP 90
29423: PPUSH
29424: LD_STRING D19a-Hke-1
29426: PPUSH
29427: CALL_OW 88
// end ;
29431: PPOPN 4
29433: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
29434: LD_INT 22
29436: PUSH
29437: LD_INT 3
29439: PUSH
29440: EMPTY
29441: LIST
29442: LIST
29443: PUSH
29444: LD_INT 21
29446: PUSH
29447: LD_INT 1
29449: PUSH
29450: EMPTY
29451: LIST
29452: LIST
29453: PUSH
29454: EMPTY
29455: LIST
29456: LIST
29457: PPUSH
29458: CALL_OW 69
29462: PUSH
29463: LD_EXP 21
29467: AND
29468: IFFALSE 29536
29470: GO 29472
29472: DISABLE
29473: LD_INT 0
29475: PPUSH
29476: PPUSH
// begin enable ;
29477: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
29478: LD_ADDR_VAR 0 2
29482: PUSH
29483: LD_INT 25
29485: PPUSH
29486: LD_INT 22
29488: PUSH
29489: LD_INT 3
29491: PUSH
29492: EMPTY
29493: LIST
29494: LIST
29495: PPUSH
29496: CALL_OW 70
29500: ST_TO_ADDR
// if not tmp then
29501: LD_VAR 0 2
29505: NOT
29506: IFFALSE 29510
// exit ;
29508: GO 29536
// for i in tmp do
29510: LD_ADDR_VAR 0 1
29514: PUSH
29515: LD_VAR 0 2
29519: PUSH
29520: FOR_IN
29521: IFFALSE 29534
// RemoveUnit ( i ) ;
29523: LD_VAR 0 1
29527: PPUSH
29528: CALL_OW 64
29532: GO 29520
29534: POP
29535: POP
// end ;
29536: PPOPN 2
29538: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
29539: LD_INT 22
29541: PUSH
29542: LD_INT 7
29544: PUSH
29545: EMPTY
29546: LIST
29547: LIST
29548: PUSH
29549: LD_INT 21
29551: PUSH
29552: LD_INT 1
29554: PUSH
29555: EMPTY
29556: LIST
29557: LIST
29558: PUSH
29559: EMPTY
29560: LIST
29561: LIST
29562: PPUSH
29563: CALL_OW 69
29567: PUSH
29568: LD_INT 6
29570: LESS
29571: IFFALSE 30022
29573: GO 29575
29575: DISABLE
29576: LD_INT 0
29578: PPUSH
29579: PPUSH
// begin MC_Kill ( 1 ) ;
29580: LD_INT 1
29582: PPUSH
29583: CALL 33917 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
29587: LD_INT 7
29589: PPUSH
29590: LD_INT 1
29592: PPUSH
29593: LD_INT 1
29595: PPUSH
29596: LD_INT 1
29598: PPUSH
29599: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
29603: LD_ADDR_VAR 0 1
29607: PUSH
29608: LD_INT 22
29610: PUSH
29611: LD_INT 7
29613: PUSH
29614: EMPTY
29615: LIST
29616: LIST
29617: PUSH
29618: LD_INT 26
29620: PUSH
29621: LD_INT 1
29623: PUSH
29624: EMPTY
29625: LIST
29626: LIST
29627: PUSH
29628: EMPTY
29629: LIST
29630: LIST
29631: PPUSH
29632: CALL_OW 69
29636: PUSH
29637: LD_EXP 71
29641: DIFF
29642: ST_TO_ADDR
// if tmp then
29643: LD_VAR 0 1
29647: IFFALSE 29665
// tmp := tmp [ 1 ] else
29649: LD_ADDR_VAR 0 1
29653: PUSH
29654: LD_VAR 0 1
29658: PUSH
29659: LD_INT 1
29661: ARRAY
29662: ST_TO_ADDR
29663: GO 29701
// begin uc_side := 7 ;
29665: LD_ADDR_OWVAR 20
29669: PUSH
29670: LD_INT 7
29672: ST_TO_ADDR
// uc_nation := 1 ;
29673: LD_ADDR_OWVAR 21
29677: PUSH
29678: LD_INT 1
29680: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
29681: LD_INT 1
29683: PPUSH
29684: LD_INT 8
29686: PPUSH
29687: CALL_OW 384
// tmp := CreateHuman ;
29691: LD_ADDR_VAR 0 1
29695: PUSH
29696: CALL_OW 44
29700: ST_TO_ADDR
// end ; DialogueOn ;
29701: CALL_OW 6
// if IsOK ( Roth ) then
29705: LD_EXP 71
29709: PPUSH
29710: CALL_OW 302
29714: IFFALSE 29728
// Say ( JMM , DAb-JMM-1 ) ;
29716: LD_EXP 36
29720: PPUSH
29721: LD_STRING DAb-JMM-1
29723: PPUSH
29724: CALL_OW 88
// if IsOK ( Roth ) then
29728: LD_EXP 71
29732: PPUSH
29733: CALL_OW 302
29737: IFFALSE 29761
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
29739: LD_EXP 71
29743: PPUSH
29744: LD_STRING DSurrenderAlliance-Roth-1
29746: PPUSH
29747: CALL_OW 88
// RothCaptured := true ;
29751: LD_ADDR_EXP 33
29755: PUSH
29756: LD_INT 1
29758: ST_TO_ADDR
// end else
29759: GO 29773
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
29761: LD_VAR 0 1
29765: PPUSH
29766: LD_STRING DSurrenderAlliance-Sci1-1
29768: PPUSH
29769: CALL_OW 88
// DialogueOff ;
29773: CALL_OW 7
// allianceDestroyed := true ;
29777: LD_ADDR_EXP 23
29781: PUSH
29782: LD_INT 1
29784: ST_TO_ADDR
// if trueAmericans then
29785: LD_EXP 35
29789: IFFALSE 29865
// begin if trueAmericans = 1 then
29791: LD_EXP 35
29795: PUSH
29796: LD_INT 1
29798: EQUAL
29799: IFFALSE 29815
// Say ( JMM , DAb-JMM-1a ) else
29801: LD_EXP 36
29805: PPUSH
29806: LD_STRING DAb-JMM-1a
29808: PPUSH
29809: CALL_OW 88
29813: GO 29827
// Say ( JMM , DAb-JMM-1b ) ;
29815: LD_EXP 36
29819: PPUSH
29820: LD_STRING DAb-JMM-1b
29822: PPUSH
29823: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
29827: LD_EXP 35
29831: PPUSH
29832: CALL_OW 87
// for i in trueAmericans do
29836: LD_ADDR_VAR 0 2
29840: PUSH
29841: LD_EXP 35
29845: PUSH
29846: FOR_IN
29847: IFFALSE 29863
// SetSide ( i , 1 ) ;
29849: LD_VAR 0 2
29853: PPUSH
29854: LD_INT 1
29856: PPUSH
29857: CALL_OW 235
29861: GO 29846
29863: POP
29864: POP
// end ; repeat wait ( 0 0$1 ) ;
29865: LD_INT 35
29867: PPUSH
29868: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
29872: LD_ADDR_VAR 0 2
29876: PUSH
29877: LD_INT 22
29879: PUSH
29880: LD_INT 7
29882: PUSH
29883: EMPTY
29884: LIST
29885: LIST
29886: PUSH
29887: LD_INT 21
29889: PUSH
29890: LD_INT 1
29892: PUSH
29893: EMPTY
29894: LIST
29895: LIST
29896: PUSH
29897: EMPTY
29898: LIST
29899: LIST
29900: PPUSH
29901: CALL_OW 69
29905: PUSH
29906: FOR_IN
29907: IFFALSE 29989
// begin if IsInUnit ( i ) then
29909: LD_VAR 0 2
29913: PPUSH
29914: CALL_OW 310
29918: IFFALSE 29929
// ComExitBuilding ( i ) ;
29920: LD_VAR 0 2
29924: PPUSH
29925: CALL_OW 122
// if IsDriver ( i ) then
29929: LD_VAR 0 2
29933: PPUSH
29934: CALL 101968 0 1
29938: IFFALSE 29949
// ComExitVehicle ( i ) ;
29940: LD_VAR 0 2
29944: PPUSH
29945: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
29949: LD_VAR 0 2
29953: PPUSH
29954: LD_INT 26
29956: PPUSH
29957: CALL_OW 308
29961: NOT
29962: IFFALSE 29978
// AddComMoveToArea ( i , allianceEscapeArea ) else
29964: LD_VAR 0 2
29968: PPUSH
29969: LD_INT 26
29971: PPUSH
29972: CALL_OW 173
29976: GO 29987
// RemoveUnit ( i ) ;
29978: LD_VAR 0 2
29982: PPUSH
29983: CALL_OW 64
// end ;
29987: GO 29906
29989: POP
29990: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
29991: LD_INT 22
29993: PUSH
29994: LD_INT 7
29996: PUSH
29997: EMPTY
29998: LIST
29999: LIST
30000: PUSH
30001: LD_INT 21
30003: PUSH
30004: LD_INT 1
30006: PUSH
30007: EMPTY
30008: LIST
30009: LIST
30010: PUSH
30011: EMPTY
30012: LIST
30013: LIST
30014: PPUSH
30015: CALL_OW 69
30019: NOT
30020: IFFALSE 29865
// end ;
30022: PPOPN 2
30024: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
30025: LD_INT 0
30027: PPUSH
30028: PPUSH
// if not unit then
30029: LD_VAR 0 1
30033: NOT
30034: IFFALSE 30038
// exit ;
30036: GO 31536
// DoNotAttack ( 7 , unit ) ;
30038: LD_INT 7
30040: PPUSH
30041: LD_VAR 0 1
30045: PPUSH
30046: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
30050: LD_VAR 0 1
30054: PPUSH
30055: LD_INT 260
30057: PPUSH
30058: LD_INT 235
30060: PPUSH
30061: LD_INT 3
30063: PPUSH
30064: LD_INT 1
30066: PPUSH
30067: CALL_OW 483
// SetSide ( unit , 4 ) ;
30071: LD_VAR 0 1
30075: PPUSH
30076: LD_INT 4
30078: PPUSH
30079: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
30083: LD_ADDR_EXP 34
30087: PUSH
30088: LD_EXP 34
30092: PUSH
30093: LD_INT 1
30095: PLUS
30096: ST_TO_ADDR
// wait ( 0 0$2 ) ;
30097: LD_INT 70
30099: PPUSH
30100: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
30104: LD_INT 260
30106: PPUSH
30107: LD_INT 235
30109: PPUSH
30110: LD_INT 1
30112: PPUSH
30113: LD_INT 8
30115: NEG
30116: PPUSH
30117: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
30121: LD_VAR 0 1
30125: PPUSH
30126: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
30130: LD_VAR 0 1
30134: PPUSH
30135: LD_EXP 71
30139: PPUSH
30140: CALL_OW 119
// DialogueOn ;
30144: CALL_OW 6
// case unit of JMM :
30148: LD_VAR 0 1
30152: PUSH
30153: LD_EXP 36
30157: DOUBLE
30158: EQUAL
30159: IFTRUE 30163
30161: GO 30178
30163: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
30164: LD_EXP 36
30168: PPUSH
30169: LD_STRING DA1-JMM-1
30171: PPUSH
30172: CALL_OW 91
30176: GO 30620
30178: LD_EXP 37
30182: DOUBLE
30183: EQUAL
30184: IFTRUE 30188
30186: GO 30203
30188: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
30189: LD_EXP 37
30193: PPUSH
30194: LD_STRING DA1-Joan-1
30196: PPUSH
30197: CALL_OW 91
30201: GO 30620
30203: LD_EXP 39
30207: DOUBLE
30208: EQUAL
30209: IFTRUE 30213
30211: GO 30228
30213: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
30214: LD_EXP 39
30218: PPUSH
30219: LD_STRING DA1-Lisa-1
30221: PPUSH
30222: CALL_OW 91
30226: GO 30620
30228: LD_EXP 40
30232: DOUBLE
30233: EQUAL
30234: IFTRUE 30238
30236: GO 30253
30238: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
30239: LD_EXP 40
30243: PPUSH
30244: LD_STRING DA1-Don-1
30246: PPUSH
30247: CALL_OW 91
30251: GO 30620
30253: LD_EXP 47
30257: DOUBLE
30258: EQUAL
30259: IFTRUE 30263
30261: GO 30278
30263: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
30264: LD_EXP 47
30268: PPUSH
30269: LD_STRING DA1-Corn-1
30271: PPUSH
30272: CALL_OW 91
30276: GO 30620
30278: LD_EXP 43
30282: DOUBLE
30283: EQUAL
30284: IFTRUE 30288
30286: GO 30303
30288: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
30289: LD_EXP 43
30293: PPUSH
30294: LD_STRING DA1-Den-1
30296: PPUSH
30297: CALL_OW 91
30301: GO 30620
30303: LD_EXP 41
30307: DOUBLE
30308: EQUAL
30309: IFTRUE 30313
30311: GO 30328
30313: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
30314: LD_EXP 41
30318: PPUSH
30319: LD_STRING DA1-Bobby-1
30321: PPUSH
30322: CALL_OW 91
30326: GO 30620
30328: LD_EXP 45
30332: DOUBLE
30333: EQUAL
30334: IFTRUE 30338
30336: GO 30353
30338: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
30339: LD_EXP 45
30343: PPUSH
30344: LD_STRING DA1-Glad-1
30346: PPUSH
30347: CALL_OW 91
30351: GO 30620
30353: LD_EXP 42
30357: DOUBLE
30358: EQUAL
30359: IFTRUE 30363
30361: GO 30378
30363: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
30364: LD_EXP 42
30368: PPUSH
30369: LD_STRING DA1-Cyrus-1
30371: PPUSH
30372: CALL_OW 91
30376: GO 30620
30378: LD_EXP 38
30382: DOUBLE
30383: EQUAL
30384: IFTRUE 30388
30386: GO 30403
30388: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
30389: LD_EXP 38
30393: PPUSH
30394: LD_STRING DA1-Huck-1
30396: PPUSH
30397: CALL_OW 91
30401: GO 30620
30403: LD_EXP 52
30407: DOUBLE
30408: EQUAL
30409: IFTRUE 30413
30411: GO 30428
30413: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
30414: LD_EXP 52
30418: PPUSH
30419: LD_STRING DA1-Huck-1
30421: PPUSH
30422: CALL_OW 91
30426: GO 30620
30428: LD_EXP 44
30432: DOUBLE
30433: EQUAL
30434: IFTRUE 30438
30436: GO 30453
30438: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
30439: LD_EXP 44
30443: PPUSH
30444: LD_STRING DA1-Brown-1
30446: PPUSH
30447: CALL_OW 91
30451: GO 30620
30453: LD_EXP 48
30457: DOUBLE
30458: EQUAL
30459: IFTRUE 30463
30461: GO 30478
30463: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
30464: LD_EXP 48
30468: PPUSH
30469: LD_STRING DA1-Gary-1
30471: PPUSH
30472: CALL_OW 91
30476: GO 30620
30478: LD_EXP 51
30482: DOUBLE
30483: EQUAL
30484: IFTRUE 30488
30486: GO 30503
30488: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
30489: LD_EXP 51
30493: PPUSH
30494: LD_STRING DA1-Con-1
30496: PPUSH
30497: CALL_OW 91
30501: GO 30620
30503: LD_EXP 57
30507: DOUBLE
30508: EQUAL
30509: IFTRUE 30513
30511: GO 30528
30513: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
30514: LD_EXP 57
30518: PPUSH
30519: LD_STRING DA1-Kurt-1
30521: PPUSH
30522: CALL_OW 91
30526: GO 30620
30528: LD_EXP 50
30532: DOUBLE
30533: EQUAL
30534: IFTRUE 30538
30536: GO 30553
30538: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
30539: LD_EXP 50
30543: PPUSH
30544: LD_STRING DA1-Yam-1
30546: PPUSH
30547: CALL_OW 91
30551: GO 30620
30553: LD_EXP 49
30557: DOUBLE
30558: EQUAL
30559: IFTRUE 30563
30561: GO 30578
30563: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
30564: LD_EXP 49
30568: PPUSH
30569: LD_STRING DA1-Frank-1
30571: PPUSH
30572: CALL_OW 91
30576: GO 30620
30578: POP
// begin if GetSex ( unit ) = sex_male then
30579: LD_VAR 0 1
30583: PPUSH
30584: CALL_OW 258
30588: PUSH
30589: LD_INT 1
30591: EQUAL
30592: IFFALSE 30608
// ForceSay ( unit , DA1-Sol1-1 ) else
30594: LD_VAR 0 1
30598: PPUSH
30599: LD_STRING DA1-Sol1-1
30601: PPUSH
30602: CALL_OW 91
30606: GO 30620
// ForceSay ( unit , DA1-FSol1-1 ) ;
30608: LD_VAR 0 1
30612: PPUSH
30613: LD_STRING DA1-FSol1-1
30615: PPUSH
30616: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
30620: LD_EXP 71
30624: PPUSH
30625: LD_STRING DA-Roth-1
30627: PPUSH
30628: CALL_OW 88
// if capturedUnit = 1 then
30632: LD_EXP 34
30636: PUSH
30637: LD_INT 1
30639: EQUAL
30640: IFFALSE 30668
// begin Say ( Simms , DA-Sim-1 ) ;
30642: LD_EXP 72
30646: PPUSH
30647: LD_STRING DA-Sim-1
30649: PPUSH
30650: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
30654: LD_EXP 71
30658: PPUSH
30659: LD_STRING DA-Roth-2
30661: PPUSH
30662: CALL_OW 88
// end else
30666: GO 30680
// Say ( Simms , DA-Sim-2 ) ;
30668: LD_EXP 72
30672: PPUSH
30673: LD_STRING DA-Sim-2
30675: PPUSH
30676: CALL_OW 88
// case unit of JMM :
30680: LD_VAR 0 1
30684: PUSH
30685: LD_EXP 36
30689: DOUBLE
30690: EQUAL
30691: IFTRUE 30695
30693: GO 30710
30695: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
30696: LD_EXP 36
30700: PPUSH
30701: LD_STRING DA1-JMM-1a
30703: PPUSH
30704: CALL_OW 91
30708: GO 31217
30710: LD_EXP 37
30714: DOUBLE
30715: EQUAL
30716: IFTRUE 30720
30718: GO 30735
30720: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
30721: LD_EXP 37
30725: PPUSH
30726: LD_STRING DA1-Joan-1a
30728: PPUSH
30729: CALL_OW 91
30733: GO 31217
30735: LD_EXP 39
30739: DOUBLE
30740: EQUAL
30741: IFTRUE 30745
30743: GO 30760
30745: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
30746: LD_EXP 39
30750: PPUSH
30751: LD_STRING DA1-Lisa-1a
30753: PPUSH
30754: CALL_OW 91
30758: GO 31217
30760: LD_EXP 40
30764: DOUBLE
30765: EQUAL
30766: IFTRUE 30770
30768: GO 30785
30770: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
30771: LD_EXP 40
30775: PPUSH
30776: LD_STRING DA1-Don-1a
30778: PPUSH
30779: CALL_OW 91
30783: GO 31217
30785: LD_EXP 47
30789: DOUBLE
30790: EQUAL
30791: IFTRUE 30795
30793: GO 30810
30795: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
30796: LD_EXP 47
30800: PPUSH
30801: LD_STRING DA1-Corn-1a
30803: PPUSH
30804: CALL_OW 91
30808: GO 31217
30810: LD_EXP 43
30814: DOUBLE
30815: EQUAL
30816: IFTRUE 30820
30818: GO 30835
30820: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
30821: LD_EXP 43
30825: PPUSH
30826: LD_STRING DA1-Den-1a
30828: PPUSH
30829: CALL_OW 91
30833: GO 31217
30835: LD_EXP 41
30839: DOUBLE
30840: EQUAL
30841: IFTRUE 30845
30843: GO 30860
30845: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
30846: LD_EXP 41
30850: PPUSH
30851: LD_STRING DA1-Bobby-1a
30853: PPUSH
30854: CALL_OW 91
30858: GO 31217
30860: LD_EXP 45
30864: DOUBLE
30865: EQUAL
30866: IFTRUE 30870
30868: GO 30885
30870: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
30871: LD_EXP 45
30875: PPUSH
30876: LD_STRING DA1-Glad-1a
30878: PPUSH
30879: CALL_OW 91
30883: GO 31217
30885: LD_EXP 42
30889: DOUBLE
30890: EQUAL
30891: IFTRUE 30895
30893: GO 30910
30895: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
30896: LD_EXP 42
30900: PPUSH
30901: LD_STRING DA1-Cyrus-1a
30903: PPUSH
30904: CALL_OW 91
30908: GO 31217
30910: LD_EXP 38
30914: DOUBLE
30915: EQUAL
30916: IFTRUE 30920
30918: GO 30935
30920: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
30921: LD_EXP 38
30925: PPUSH
30926: LD_STRING DA1-Huck-1a
30928: PPUSH
30929: CALL_OW 91
30933: GO 31217
30935: LD_EXP 52
30939: DOUBLE
30940: EQUAL
30941: IFTRUE 30945
30943: GO 30960
30945: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
30946: LD_EXP 52
30950: PPUSH
30951: LD_STRING DA1-Huck-1a
30953: PPUSH
30954: CALL_OW 91
30958: GO 31217
30960: LD_EXP 44
30964: DOUBLE
30965: EQUAL
30966: IFTRUE 30970
30968: GO 30985
30970: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
30971: LD_EXP 44
30975: PPUSH
30976: LD_STRING DA1-Brown-1a
30978: PPUSH
30979: CALL_OW 91
30983: GO 31217
30985: LD_EXP 48
30989: DOUBLE
30990: EQUAL
30991: IFTRUE 30995
30993: GO 31010
30995: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
30996: LD_EXP 48
31000: PPUSH
31001: LD_STRING DA1-Gary-1a
31003: PPUSH
31004: CALL_OW 91
31008: GO 31217
31010: LD_EXP 51
31014: DOUBLE
31015: EQUAL
31016: IFTRUE 31020
31018: GO 31035
31020: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31021: LD_EXP 51
31025: PPUSH
31026: LD_STRING DA1-Con-1a
31028: PPUSH
31029: CALL_OW 91
31033: GO 31217
31035: LD_EXP 57
31039: DOUBLE
31040: EQUAL
31041: IFTRUE 31045
31043: GO 31060
31045: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
31046: LD_EXP 57
31050: PPUSH
31051: LD_STRING DA1-Kurt-1a
31053: PPUSH
31054: CALL_OW 91
31058: GO 31217
31060: LD_EXP 50
31064: DOUBLE
31065: EQUAL
31066: IFTRUE 31070
31068: GO 31085
31070: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
31071: LD_EXP 50
31075: PPUSH
31076: LD_STRING DA1-Yam-1a
31078: PPUSH
31079: CALL_OW 91
31083: GO 31217
31085: LD_EXP 49
31089: DOUBLE
31090: EQUAL
31091: IFTRUE 31095
31093: GO 31110
31095: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
31096: LD_EXP 49
31100: PPUSH
31101: LD_STRING DA1-Frank-1a
31103: PPUSH
31104: CALL_OW 91
31108: GO 31217
31110: POP
// begin join := rand ( 0 , 1 ) ;
31111: LD_ADDR_VAR 0 3
31115: PUSH
31116: LD_INT 0
31118: PPUSH
31119: LD_INT 1
31121: PPUSH
31122: CALL_OW 12
31126: ST_TO_ADDR
// if join then
31127: LD_VAR 0 3
31131: IFFALSE 31176
// begin if GetSex ( unit ) = sex_male then
31133: LD_VAR 0 1
31137: PPUSH
31138: CALL_OW 258
31142: PUSH
31143: LD_INT 1
31145: EQUAL
31146: IFFALSE 31162
// ForceSay ( unit , DA1-Sol1-1b ) else
31148: LD_VAR 0 1
31152: PPUSH
31153: LD_STRING DA1-Sol1-1b
31155: PPUSH
31156: CALL_OW 91
31160: GO 31174
// ForceSay ( unit , DA1-FSol1-1b ) ;
31162: LD_VAR 0 1
31166: PPUSH
31167: LD_STRING DA1-FSol1-1b
31169: PPUSH
31170: CALL_OW 91
// end else
31174: GO 31217
// begin if GetSex ( unit ) = sex_male then
31176: LD_VAR 0 1
31180: PPUSH
31181: CALL_OW 258
31185: PUSH
31186: LD_INT 1
31188: EQUAL
31189: IFFALSE 31205
// ForceSay ( unit , DA1-Sol1-1a ) else
31191: LD_VAR 0 1
31195: PPUSH
31196: LD_STRING DA1-Sol1-1a
31198: PPUSH
31199: CALL_OW 91
31203: GO 31217
// ForceSay ( unit , DA1-FSol1-1a ) ;
31205: LD_VAR 0 1
31209: PPUSH
31210: LD_STRING DA1-FSol1-1a
31212: PPUSH
31213: CALL_OW 91
// end ; end ; end ; if unit = JMM then
31217: LD_VAR 0 1
31221: PUSH
31222: LD_EXP 36
31226: EQUAL
31227: IFFALSE 31238
// begin YouLost ( JMMCaptured ) ;
31229: LD_STRING JMMCaptured
31231: PPUSH
31232: CALL_OW 104
// exit ;
31236: GO 31536
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
31238: LD_VAR 0 1
31242: PUSH
31243: LD_EXP 40
31247: PUSH
31248: LD_EXP 43
31252: PUSH
31253: LD_EXP 41
31257: PUSH
31258: LD_EXP 38
31262: PUSH
31263: LD_EXP 52
31267: PUSH
31268: LD_EXP 44
31272: PUSH
31273: LD_EXP 50
31277: PUSH
31278: EMPTY
31279: LIST
31280: LIST
31281: LIST
31282: LIST
31283: LIST
31284: LIST
31285: LIST
31286: IN
31287: PUSH
31288: LD_VAR 0 3
31292: OR
31293: IFFALSE 31392
// begin Say ( Roth , DA-Roth-3 ) ;
31295: LD_EXP 71
31299: PPUSH
31300: LD_STRING DA-Roth-3
31302: PPUSH
31303: CALL_OW 88
// SetSide ( unit , 7 ) ;
31307: LD_VAR 0 1
31311: PPUSH
31312: LD_INT 7
31314: PPUSH
31315: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
31319: LD_ADDR_EXP 99
31323: PUSH
31324: LD_EXP 99
31328: PPUSH
31329: LD_INT 1
31331: PPUSH
31332: LD_EXP 99
31336: PUSH
31337: LD_INT 1
31339: ARRAY
31340: PUSH
31341: LD_VAR 0 1
31345: ADD
31346: PPUSH
31347: CALL_OW 1
31351: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31352: LD_INT 260
31354: PPUSH
31355: LD_INT 235
31357: PPUSH
31358: LD_INT 1
31360: PPUSH
31361: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31365: LD_VAR 0 1
31369: PPUSH
31370: LD_INT 1000
31372: PPUSH
31373: CALL_OW 234
// DialogueOff ;
31377: CALL_OW 7
// ComFree ( unit ) ;
31381: LD_VAR 0 1
31385: PPUSH
31386: CALL_OW 139
// end else
31390: GO 31473
// begin Say ( Roth , DA-Roth-3a ) ;
31392: LD_EXP 71
31396: PPUSH
31397: LD_STRING DA-Roth-3a
31399: PPUSH
31400: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
31404: LD_ADDR_EXP 35
31408: PUSH
31409: LD_EXP 35
31413: PUSH
31414: LD_VAR 0 1
31418: ADD
31419: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31420: LD_INT 260
31422: PPUSH
31423: LD_INT 235
31425: PPUSH
31426: LD_INT 1
31428: PPUSH
31429: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31433: LD_VAR 0 1
31437: PPUSH
31438: LD_INT 1000
31440: PPUSH
31441: CALL_OW 234
// DialogueOff ;
31445: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
31449: LD_VAR 0 1
31453: PPUSH
31454: LD_INT 272
31456: PPUSH
31457: LD_INT 254
31459: PPUSH
31460: CALL_OW 111
// AddComHold ( unit ) ;
31464: LD_VAR 0 1
31468: PPUSH
31469: CALL_OW 200
// end ; if capturedUnit = 1 then
31473: LD_EXP 34
31477: PUSH
31478: LD_INT 1
31480: EQUAL
31481: IFFALSE 31536
// begin DialogueOn ;
31483: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31487: LD_EXP 36
31491: PPUSH
31492: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
31496: LD_EXP 36
31500: PPUSH
31501: LD_STRING DAa-JMM-1
31503: PPUSH
31504: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
31508: LD_EXP 36
31512: PPUSH
31513: LD_STRING DAa-JMM-1a
31515: PPUSH
31516: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
31520: LD_EXP 36
31524: PPUSH
31525: LD_STRING DAa-JMM-1b
31527: PPUSH
31528: CALL_OW 88
// DialogueOff ;
31532: CALL_OW 7
// end ; end ;
31536: LD_VAR 0 2
31540: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do
31541: LD_EXP 15
31545: PUSH
31546: LD_INT 13
31548: GREATEREQUAL
31549: PUSH
31550: LD_INT 22
31552: PUSH
31553: LD_INT 2
31555: PUSH
31556: EMPTY
31557: LIST
31558: LIST
31559: PUSH
31560: LD_INT 21
31562: PUSH
31563: LD_INT 1
31565: PUSH
31566: EMPTY
31567: LIST
31568: LIST
31569: PUSH
31570: EMPTY
31571: LIST
31572: LIST
31573: PPUSH
31574: CALL_OW 69
31578: PUSH
31579: LD_INT 0
31581: EQUAL
31582: AND
31583: PUSH
31584: LD_INT 22
31586: PUSH
31587: LD_INT 2
31589: PUSH
31590: EMPTY
31591: LIST
31592: LIST
31593: PUSH
31594: LD_INT 21
31596: PUSH
31597: LD_INT 2
31599: PUSH
31600: EMPTY
31601: LIST
31602: LIST
31603: PUSH
31604: LD_INT 50
31606: PUSH
31607: EMPTY
31608: LIST
31609: PUSH
31610: EMPTY
31611: LIST
31612: LIST
31613: LIST
31614: PPUSH
31615: CALL_OW 69
31619: PUSH
31620: LD_INT 0
31622: EQUAL
31623: AND
31624: PUSH
31625: LD_EXP 21
31629: AND
31630: PUSH
31631: LD_EXP 22
31635: AND
31636: PUSH
31637: LD_EXP 23
31641: AND
31642: IFFALSE 32123
31644: GO 31646
31646: DISABLE
// begin DialogueOn ;
31647: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31651: LD_EXP 36
31655: PPUSH
31656: CALL_OW 87
// Say ( JMM , D20-JMM-1 ) ;
31660: LD_EXP 36
31664: PPUSH
31665: LD_STRING D20-JMM-1
31667: PPUSH
31668: CALL_OW 88
// if IsOK ( Joan ) then
31672: LD_EXP 37
31676: PPUSH
31677: CALL_OW 302
31681: IFFALSE 31695
// Say ( Joan , D20-Joan-1 ) ;
31683: LD_EXP 37
31687: PPUSH
31688: LD_STRING D20-Joan-1
31690: PPUSH
31691: CALL_OW 88
// if IsOk ( Lisa ) then
31695: LD_EXP 39
31699: PPUSH
31700: CALL_OW 302
31704: IFFALSE 31718
// Say ( Lisa , D20-Lisa-1 ) ;
31706: LD_EXP 39
31710: PPUSH
31711: LD_STRING D20-Lisa-1
31713: PPUSH
31714: CALL_OW 88
// if IsOk ( Donaldson ) then
31718: LD_EXP 40
31722: PPUSH
31723: CALL_OW 302
31727: IFFALSE 31741
// Say ( Donaldson , D20-Don-1 ) ;
31729: LD_EXP 40
31733: PPUSH
31734: LD_STRING D20-Don-1
31736: PPUSH
31737: CALL_OW 88
// if IsOK ( Cornel ) then
31741: LD_EXP 47
31745: PPUSH
31746: CALL_OW 302
31750: IFFALSE 31764
// Say ( Cornel , D20-Corn-1 ) ;
31752: LD_EXP 47
31756: PPUSH
31757: LD_STRING D20-Corn-1
31759: PPUSH
31760: CALL_OW 88
// if IsOk ( Denis ) then
31764: LD_EXP 43
31768: PPUSH
31769: CALL_OW 302
31773: IFFALSE 31787
// Say ( Denis , D20-Den-1 ) ;
31775: LD_EXP 43
31779: PPUSH
31780: LD_STRING D20-Den-1
31782: PPUSH
31783: CALL_OW 88
// if IsOk ( Bobby ) then
31787: LD_EXP 41
31791: PPUSH
31792: CALL_OW 302
31796: IFFALSE 31810
// Say ( Bobby , D20-Bobby-1 ) ;
31798: LD_EXP 41
31802: PPUSH
31803: LD_STRING D20-Bobby-1
31805: PPUSH
31806: CALL_OW 88
// if IsOk ( Gladstone ) then
31810: LD_EXP 45
31814: PPUSH
31815: CALL_OW 302
31819: IFFALSE 31833
// Say ( Gladstone , D20-Glad-1 ) ;
31821: LD_EXP 45
31825: PPUSH
31826: LD_STRING D20-Glad-1
31828: PPUSH
31829: CALL_OW 88
// if IsOk ( Cyrus ) then
31833: LD_EXP 42
31837: PPUSH
31838: CALL_OW 302
31842: IFFALSE 31856
// Say ( Cyrus , D20-Cyrus-1 ) ;
31844: LD_EXP 42
31848: PPUSH
31849: LD_STRING D20-Cyrus-1
31851: PPUSH
31852: CALL_OW 88
// if IsOk ( Stevens ) then
31856: LD_EXP 38
31860: PPUSH
31861: CALL_OW 302
31865: IFFALSE 31879
// Say ( Stevens , D20-Huck-1 ) ;
31867: LD_EXP 38
31871: PPUSH
31872: LD_STRING D20-Huck-1
31874: PPUSH
31875: CALL_OW 88
// if IsOk ( Brown ) then
31879: LD_EXP 44
31883: PPUSH
31884: CALL_OW 302
31888: IFFALSE 31902
// Say ( Brown , D20-Brown-1 ) ;
31890: LD_EXP 44
31894: PPUSH
31895: LD_STRING D20-Brown-1
31897: PPUSH
31898: CALL_OW 88
// if IsOk ( Gary ) then
31902: LD_EXP 48
31906: PPUSH
31907: CALL_OW 302
31911: IFFALSE 31925
// Say ( Gary , D20-Gary-1 ) ;
31913: LD_EXP 48
31917: PPUSH
31918: LD_STRING D20-Gary-1
31920: PPUSH
31921: CALL_OW 88
// if IsOk ( Connie ) then
31925: LD_EXP 51
31929: PPUSH
31930: CALL_OW 302
31934: IFFALSE 31948
// Say ( Connie , D20-Con-1 ) ;
31936: LD_EXP 51
31940: PPUSH
31941: LD_STRING D20-Con-1
31943: PPUSH
31944: CALL_OW 88
// if IsOk ( Kurt ) then
31948: LD_EXP 57
31952: PPUSH
31953: CALL_OW 302
31957: IFFALSE 31971
// Say ( Kurt , D20-Kurt-1 ) ;
31959: LD_EXP 57
31963: PPUSH
31964: LD_STRING D20-Kurt-1
31966: PPUSH
31967: CALL_OW 88
// if IsOk ( Kikuchi ) then
31971: LD_EXP 50
31975: PPUSH
31976: CALL_OW 302
31980: IFFALSE 31994
// Say ( Kikuchi , D20-Yam-1 ) ;
31982: LD_EXP 50
31986: PPUSH
31987: LD_STRING D20-Yam-1
31989: PPUSH
31990: CALL_OW 88
// if IsOk ( Frank ) then
31994: LD_EXP 49
31998: PPUSH
31999: CALL_OW 302
32003: IFFALSE 32017
// Say ( Frank , D20-Frank-1 ) ;
32005: LD_EXP 49
32009: PPUSH
32010: LD_STRING D20-Frank-1
32012: PPUSH
32013: CALL_OW 88
// DialogueOff ;
32017: CALL_OW 7
// if RothCaptured then
32021: LD_EXP 33
32025: IFFALSE 32039
// AddMedal ( Roth , 1 ) else
32027: LD_STRING Roth
32029: PPUSH
32030: LD_INT 1
32032: PPUSH
32033: CALL_OW 101
32037: GO 32050
// AddMedal ( Roth , - 1 ) ;
32039: LD_STRING Roth
32041: PPUSH
32042: LD_INT 1
32044: NEG
32045: PPUSH
32046: CALL_OW 101
// if behemothDestroyedBeforeFinish then
32050: LD_EXP 27
32054: IFFALSE 32068
// AddMedal ( Project , 1 ) else
32056: LD_STRING Project
32058: PPUSH
32059: LD_INT 1
32061: PPUSH
32062: CALL_OW 101
32066: GO 32079
// AddMedal ( Project , - 1 ) ;
32068: LD_STRING Project
32070: PPUSH
32071: LD_INT 1
32073: NEG
32074: PPUSH
32075: CALL_OW 101
// if lostCounter = 0 then
32079: LD_EXP 32
32083: PUSH
32084: LD_INT 0
32086: EQUAL
32087: IFFALSE 32101
// AddMedal ( NoLosses , 1 ) else
32089: LD_STRING NoLosses
32091: PPUSH
32092: LD_INT 1
32094: PPUSH
32095: CALL_OW 101
32099: GO 32112
// AddMedal ( NoLosses , - 1 ) ;
32101: LD_STRING NoLosses
32103: PPUSH
32104: LD_INT 1
32106: NEG
32107: PPUSH
32108: CALL_OW 101
// GiveMedals ( MAIN ) ;
32112: LD_STRING MAIN
32114: PPUSH
32115: CALL_OW 102
// YouWin ;
32119: CALL_OW 103
// end ; end_of_file
32123: END
// export function CustomEvent ( event ) ; begin
32124: LD_INT 0
32126: PPUSH
// end ;
32127: LD_VAR 0 2
32131: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
32132: LD_VAR 0 1
32136: PUSH
32137: LD_INT 1
32139: EQUAL
32140: PUSH
32141: LD_VAR 0 2
32145: PUSH
32146: LD_INT 4
32148: EQUAL
32149: AND
32150: PUSH
32151: LD_EXP 55
32155: PPUSH
32156: CALL_OW 300
32160: AND
32161: IFFALSE 32177
// begin wait ( 0 0$2 ) ;
32163: LD_INT 70
32165: PPUSH
32166: CALL_OW 67
// YouLost ( Dismissed ) ;
32170: LD_STRING Dismissed
32172: PPUSH
32173: CALL_OW 104
// end ; end ;
32177: PPOPN 2
32179: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
32180: LD_VAR 0 2
32184: PPUSH
32185: LD_VAR 0 3
32189: PPUSH
32190: LD_INT 18
32192: PPUSH
32193: CALL_OW 309
32197: IFFALSE 32206
// YouLost ( Motherlode3 ) ;
32199: LD_STRING Motherlode3
32201: PPUSH
32202: CALL_OW 104
// end ;
32206: PPOPN 3
32208: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
32209: LD_EXP 27
32213: NOT
32214: IFFALSE 32224
// behemothDone := true ;
32216: LD_ADDR_EXP 28
32220: PUSH
32221: LD_INT 1
32223: ST_TO_ADDR
// end ;
32224: PPOPN 1
32226: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32227: LD_VAR 0 1
32231: PPUSH
32232: CALL_OW 255
32236: PUSH
32237: LD_INT 1
32239: EQUAL
32240: PUSH
32241: LD_EXP 30
32245: AND
32246: PUSH
32247: LD_INT 22
32249: PUSH
32250: LD_INT 3
32252: PUSH
32253: EMPTY
32254: LIST
32255: LIST
32256: PUSH
32257: LD_INT 34
32259: PUSH
32260: LD_INT 48
32262: PUSH
32263: EMPTY
32264: LIST
32265: LIST
32266: PUSH
32267: EMPTY
32268: LIST
32269: LIST
32270: PPUSH
32271: CALL_OW 69
32275: AND
32276: PUSH
32277: LD_INT 22
32279: PUSH
32280: LD_INT 1
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 34
32289: PUSH
32290: LD_INT 8
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: EMPTY
32298: LIST
32299: LIST
32300: PPUSH
32301: CALL_OW 69
32305: NOT
32306: AND
32307: IFFALSE 32359
// begin wait ( 0 0$5 ) ;
32309: LD_INT 175
32311: PPUSH
32312: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
32316: LD_INT 22
32318: PUSH
32319: LD_INT 3
32321: PUSH
32322: EMPTY
32323: LIST
32324: LIST
32325: PUSH
32326: LD_INT 34
32328: PUSH
32329: LD_INT 48
32331: PUSH
32332: EMPTY
32333: LIST
32334: LIST
32335: PUSH
32336: EMPTY
32337: LIST
32338: LIST
32339: PPUSH
32340: CALL_OW 69
32344: PUSH
32345: LD_INT 1
32347: ARRAY
32348: PPUSH
32349: LD_INT 60
32351: PPUSH
32352: LD_INT 95
32354: PPUSH
32355: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
32359: LD_VAR 0 2
32363: PPUSH
32364: LD_VAR 0 3
32368: PPUSH
32369: LD_INT 18
32371: PPUSH
32372: CALL_OW 309
32376: IFFALSE 32436
// begin if GetSide ( unit ) = 1 then
32378: LD_VAR 0 1
32382: PPUSH
32383: CALL_OW 255
32387: PUSH
32388: LD_INT 1
32390: EQUAL
32391: IFFALSE 32407
// begin wait ( 0 0$6 ) ;
32393: LD_INT 210
32395: PPUSH
32396: CALL_OW 67
// YouLost ( Motherlode2 ) ;
32400: LD_STRING Motherlode2
32402: PPUSH
32403: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
32407: LD_VAR 0 1
32411: PPUSH
32412: CALL_OW 255
32416: PUSH
32417: LD_INT 8
32419: EQUAL
32420: IFFALSE 32436
// begin wait ( 0 0$6 ) ;
32422: LD_INT 210
32424: PPUSH
32425: CALL_OW 67
// YouLost ( Motherlode1 ) ;
32429: LD_STRING Motherlode1
32431: PPUSH
32432: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
32436: LD_VAR 0 1
32440: PPUSH
32441: CALL_OW 255
32445: PUSH
32446: LD_INT 3
32448: EQUAL
32449: IFFALSE 32470
// begin wait ( 0 0$5 ) ;
32451: LD_INT 175
32453: PPUSH
32454: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
32458: LD_EXP 61
32462: PPUSH
32463: LD_STRING D18-Pla-1
32465: PPUSH
32466: CALL_OW 94
// end ; end ;
32470: PPOPN 3
32472: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
32473: LD_VAR 0 1
32477: PUSH
32478: LD_EXP 70
32482: IN
32483: IFFALSE 32503
// begin behemothBuilders := behemothBuilders diff un ;
32485: LD_ADDR_EXP 70
32489: PUSH
32490: LD_EXP 70
32494: PUSH
32495: LD_VAR 0 1
32499: DIFF
32500: ST_TO_ADDR
// exit ;
32501: GO 32601
// end ; if un = JMM then
32503: LD_VAR 0 1
32507: PUSH
32508: LD_EXP 36
32512: EQUAL
32513: IFFALSE 32524
// begin YouLost ( JMM ) ;
32515: LD_STRING JMM
32517: PPUSH
32518: CALL_OW 104
// exit ;
32522: GO 32601
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
32524: LD_VAR 0 1
32528: PUSH
32529: LD_INT 22
32531: PUSH
32532: LD_INT 1
32534: PUSH
32535: EMPTY
32536: LIST
32537: LIST
32538: PUSH
32539: LD_INT 3
32541: PUSH
32542: LD_INT 25
32544: PUSH
32545: LD_INT 16
32547: PUSH
32548: EMPTY
32549: LIST
32550: LIST
32551: PUSH
32552: LD_INT 25
32554: PUSH
32555: LD_INT 12
32557: PUSH
32558: EMPTY
32559: LIST
32560: LIST
32561: PUSH
32562: EMPTY
32563: LIST
32564: LIST
32565: LIST
32566: PUSH
32567: EMPTY
32568: LIST
32569: LIST
32570: PPUSH
32571: CALL_OW 69
32575: IN
32576: IFFALSE 32592
// lostCounter := lostCounter + 1 ;
32578: LD_ADDR_EXP 32
32582: PUSH
32583: LD_EXP 32
32587: PUSH
32588: LD_INT 1
32590: PLUS
32591: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
32592: LD_VAR 0 1
32596: PPUSH
32597: CALL 59331 0 1
// end ;
32601: PPOPN 1
32603: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
32604: LD_VAR 0 1
32608: PPUSH
32609: LD_VAR 0 2
32613: PPUSH
32614: CALL 61310 0 2
// end ;
32618: PPOPN 2
32620: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
32621: LD_VAR 0 1
32625: PPUSH
32626: CALL 60378 0 1
// end ;
32630: PPOPN 1
32632: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
32633: LD_VAR 0 1
32637: PUSH
32638: LD_INT 22
32640: PUSH
32641: LD_INT 8
32643: PUSH
32644: EMPTY
32645: LIST
32646: LIST
32647: PUSH
32648: LD_INT 30
32650: PUSH
32651: LD_INT 2
32653: PUSH
32654: EMPTY
32655: LIST
32656: LIST
32657: PUSH
32658: LD_INT 23
32660: PUSH
32661: LD_INT 3
32663: PUSH
32664: EMPTY
32665: LIST
32666: LIST
32667: PUSH
32668: EMPTY
32669: LIST
32670: LIST
32671: LIST
32672: PPUSH
32673: CALL_OW 69
32677: IN
32678: IFFALSE 32705
// begin ComUpgrade ( building ) ;
32680: LD_VAR 0 1
32684: PPUSH
32685: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
32689: LD_EXP 58
32693: PPUSH
32694: LD_VAR 0 1
32698: PPUSH
32699: CALL 71534 0 2
// exit ;
32703: GO 32714
// end ; MCE_BuildingComplete ( building ) ;
32705: LD_VAR 0 1
32709: PPUSH
32710: CALL 60619 0 1
// end ;
32714: PPOPN 1
32716: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
32717: LD_VAR 0 1
32721: PPUSH
32722: LD_VAR 0 2
32726: PPUSH
32727: CALL 59027 0 2
// end ;
32731: PPOPN 2
32733: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
32734: LD_VAR 0 1
32738: PPUSH
32739: LD_VAR 0 2
32743: PPUSH
32744: LD_VAR 0 3
32748: PPUSH
32749: LD_VAR 0 4
32753: PPUSH
32754: LD_VAR 0 5
32758: PPUSH
32759: CALL 58647 0 5
// end ;
32763: PPOPN 5
32765: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
32766: LD_VAR 0 1
32770: PPUSH
32771: LD_VAR 0 2
32775: PPUSH
32776: CALL 58237 0 2
// end ;
32780: PPOPN 2
32782: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
32783: LD_VAR 0 1
32787: PPUSH
32788: LD_VAR 0 2
32792: PPUSH
32793: LD_VAR 0 3
32797: PPUSH
32798: LD_VAR 0 4
32802: PPUSH
32803: CALL 58075 0 4
// end ;
32807: PPOPN 4
32809: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
32810: LD_VAR 0 1
32814: PPUSH
32815: LD_VAR 0 2
32819: PPUSH
32820: LD_VAR 0 3
32824: PPUSH
32825: CALL 57850 0 3
// end ;
32829: PPOPN 3
32831: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
32832: LD_VAR 0 1
32836: PPUSH
32837: LD_VAR 0 2
32841: PPUSH
32842: CALL 57735 0 2
// end ;
32846: PPOPN 2
32848: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
32849: LD_VAR 0 1
32853: PPUSH
32854: LD_VAR 0 2
32858: PPUSH
32859: CALL 61571 0 2
// end ;
32863: PPOPN 2
32865: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
32866: LD_VAR 0 1
32870: PPUSH
32871: CALL_OW 255
32875: PUSH
32876: LD_INT 4
32878: EQUAL
32879: PUSH
32880: LD_VAR 0 1
32884: PUSH
32885: LD_EXP 18
32889: PUSH
32890: LD_INT 1
32892: ARRAY
32893: IN
32894: AND
32895: PUSH
32896: LD_EXP 19
32900: AND
32901: IFFALSE 32920
// begin ComMoveXY ( driver , 61 , 93 ) ;
32903: LD_VAR 0 1
32907: PPUSH
32908: LD_INT 61
32910: PPUSH
32911: LD_INT 93
32913: PPUSH
32914: CALL_OW 111
// exit ;
32918: GO 32944
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
32920: LD_VAR 0 1
32924: PPUSH
32925: LD_VAR 0 2
32929: PPUSH
32930: LD_VAR 0 3
32934: PPUSH
32935: LD_VAR 0 4
32939: PPUSH
32940: CALL 61787 0 4
// end ;
32944: PPOPN 4
32946: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
32947: LD_VAR 0 1
32951: PPUSH
32952: LD_VAR 0 2
32956: PPUSH
32957: CALL 57544 0 2
// end ; end_of_file
32961: PPOPN 2
32963: END
// every 0 0$30 trigger missionStage = 2 do var time ;
32964: LD_EXP 15
32968: PUSH
32969: LD_INT 2
32971: EQUAL
32972: IFFALSE 33451
32974: GO 32976
32976: DISABLE
32977: LD_INT 0
32979: PPUSH
// begin time := 0 0$40 ;
32980: LD_ADDR_VAR 0 1
32984: PUSH
32985: LD_INT 1400
32987: ST_TO_ADDR
// repeat wait ( time ) ;
32988: LD_VAR 0 1
32992: PPUSH
32993: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
32997: LD_INT 1
32999: PPUSH
33000: LD_INT 5
33002: PPUSH
33003: CALL_OW 12
33007: PPUSH
33008: LD_INT 106
33010: PPUSH
33011: LD_INT 150
33013: PPUSH
33014: LD_INT 19
33016: PPUSH
33017: LD_INT 1
33019: PPUSH
33020: CALL_OW 56
// time := time + 0 0$9 ;
33024: LD_ADDR_VAR 0 1
33028: PUSH
33029: LD_VAR 0 1
33033: PUSH
33034: LD_INT 315
33036: PLUS
33037: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
33038: LD_INT 455
33040: PPUSH
33041: LD_INT 840
33043: PPUSH
33044: CALL_OW 12
33048: PPUSH
33049: CALL_OW 67
// if Prob ( 50 ) then
33053: LD_INT 50
33055: PPUSH
33056: CALL_OW 13
33060: IFFALSE 33089
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
33062: LD_INT 1
33064: PPUSH
33065: LD_INT 5
33067: PPUSH
33068: CALL_OW 12
33072: PPUSH
33073: LD_INT 62
33075: PPUSH
33076: LD_INT 108
33078: PPUSH
33079: LD_INT 10
33081: PPUSH
33082: LD_INT 1
33084: PPUSH
33085: CALL_OW 56
// until missionStage > 4 ;
33089: LD_EXP 15
33093: PUSH
33094: LD_INT 4
33096: GREATER
33097: IFFALSE 32988
// repeat wait ( 0 0$1 ) ;
33099: LD_INT 35
33101: PPUSH
33102: CALL_OW 67
// until missionStage = 6 ;
33106: LD_EXP 15
33110: PUSH
33111: LD_INT 6
33113: EQUAL
33114: IFFALSE 33099
// time := 0 0$50 ;
33116: LD_ADDR_VAR 0 1
33120: PUSH
33121: LD_INT 1750
33123: ST_TO_ADDR
// repeat wait ( time ) ;
33124: LD_VAR 0 1
33128: PPUSH
33129: CALL_OW 67
// if Prob ( 50 ) then
33133: LD_INT 50
33135: PPUSH
33136: CALL_OW 13
33140: IFFALSE 33169
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
33142: LD_INT 1
33144: PPUSH
33145: LD_INT 5
33147: PPUSH
33148: CALL_OW 12
33152: PPUSH
33153: LD_INT 106
33155: PPUSH
33156: LD_INT 89
33158: PPUSH
33159: LD_INT 45
33161: PPUSH
33162: LD_INT 1
33164: PPUSH
33165: CALL_OW 56
// time := time + 0 0$3 ;
33169: LD_ADDR_VAR 0 1
33173: PUSH
33174: LD_VAR 0 1
33178: PUSH
33179: LD_INT 105
33181: PLUS
33182: ST_TO_ADDR
// if Prob ( 30 ) then
33183: LD_INT 30
33185: PPUSH
33186: CALL_OW 13
33190: IFFALSE 33236
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
33192: LD_INT 525
33194: PPUSH
33195: LD_INT 735
33197: PPUSH
33198: CALL_OW 12
33202: PPUSH
33203: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
33207: LD_INT 1
33209: PPUSH
33210: LD_INT 5
33212: PPUSH
33213: CALL_OW 12
33217: PPUSH
33218: LD_INT 21
33220: PPUSH
33221: LD_INT 26
33223: PPUSH
33224: LD_INT 12
33226: PPUSH
33227: LD_INT 1
33229: PPUSH
33230: CALL_OW 56
// end else
33234: GO 33272
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
33236: LD_INT 700
33238: PPUSH
33239: LD_INT 1225
33241: PPUSH
33242: CALL_OW 12
33246: PPUSH
33247: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
33251: LD_INT 1
33253: PPUSH
33254: LD_INT 5
33256: PPUSH
33257: CALL_OW 12
33261: PPUSH
33262: LD_INT 16
33264: PPUSH
33265: LD_INT 1
33267: PPUSH
33268: CALL_OW 55
// end ; if Prob ( 50 ) then
33272: LD_INT 50
33274: PPUSH
33275: CALL_OW 13
33279: IFFALSE 33325
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
33281: LD_INT 700
33283: PPUSH
33284: LD_INT 1050
33286: PPUSH
33287: CALL_OW 12
33291: PPUSH
33292: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
33296: LD_INT 1
33298: PPUSH
33299: LD_INT 5
33301: PPUSH
33302: CALL_OW 12
33306: PPUSH
33307: LD_INT 181
33309: PPUSH
33310: LD_INT 218
33312: PPUSH
33313: LD_INT 16
33315: PPUSH
33316: LD_INT 1
33318: PPUSH
33319: CALL_OW 56
// end else
33323: GO 33361
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
33325: LD_INT 350
33327: PPUSH
33328: LD_INT 525
33330: PPUSH
33331: CALL_OW 12
33335: PPUSH
33336: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
33340: LD_INT 1
33342: PPUSH
33343: LD_INT 5
33345: PPUSH
33346: CALL_OW 12
33350: PPUSH
33351: LD_INT 15
33353: PPUSH
33354: LD_INT 1
33356: PPUSH
33357: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
33361: LD_INT 45
33363: PUSH
33364: LD_INT 32
33366: PUSH
33367: LD_INT 25
33369: PUSH
33370: EMPTY
33371: LIST
33372: LIST
33373: LIST
33374: PUSH
33375: LD_OWVAR 67
33379: ARRAY
33380: PPUSH
33381: CALL_OW 13
33385: IFFALSE 33429
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
33387: LD_INT 525
33389: PPUSH
33390: LD_INT 875
33392: PPUSH
33393: CALL_OW 12
33397: PPUSH
33398: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
33402: LD_INT 1
33404: PPUSH
33405: LD_INT 5
33407: PPUSH
33408: CALL_OW 12
33412: PPUSH
33413: LD_INT 103
33415: PPUSH
33416: LD_INT 140
33418: PPUSH
33419: LD_INT 20
33421: PPUSH
33422: LD_INT 1
33424: PPUSH
33425: CALL_OW 56
// end ; if time > 2 2$20 then
33429: LD_VAR 0 1
33433: PUSH
33434: LD_INT 4900
33436: GREATER
33437: IFFALSE 33447
// time := 0 0$50 ;
33439: LD_ADDR_VAR 0 1
33443: PUSH
33444: LD_INT 1750
33446: ST_TO_ADDR
// until false ;
33447: LD_INT 0
33449: IFFALSE 33124
// end ; end_of_file
33451: PPOPN 1
33453: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
33454: LD_EXP 13
33458: PUSH
33459: LD_EXP 15
33463: PUSH
33464: LD_INT 6
33466: GREATEREQUAL
33467: AND
33468: IFFALSE 33505
33470: GO 33472
33472: DISABLE
// begin enable ;
33473: ENABLE
// missionTime := missionTime + 0 0$1 ;
33474: LD_ADDR_EXP 14
33478: PUSH
33479: LD_EXP 14
33483: PUSH
33484: LD_INT 35
33486: PLUS
33487: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
33488: LD_ADDR_OWVAR 47
33492: PUSH
33493: LD_STRING #Am15-1
33495: PUSH
33496: LD_EXP 14
33500: PUSH
33501: EMPTY
33502: LIST
33503: LIST
33504: ST_TO_ADDR
// end ; end_of_file
33505: END
// export function InitNature ; begin
33506: LD_INT 0
33508: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
33509: LD_INT 3
33511: PPUSH
33512: LD_INT 3
33514: PPUSH
33515: LD_INT 2
33517: PPUSH
33518: LD_INT 1
33520: PPUSH
33521: LD_INT 1
33523: PPUSH
33524: LD_INT 0
33526: PPUSH
33527: LD_INT 0
33529: PPUSH
33530: LD_INT 20
33532: PPUSH
33533: LD_INT 0
33535: PPUSH
33536: CALL 96351 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
33540: LD_INT 2
33542: PPUSH
33543: LD_INT 1
33545: PPUSH
33546: LD_INT 1
33548: PPUSH
33549: LD_INT 1
33551: PPUSH
33552: LD_INT 1
33554: PPUSH
33555: LD_INT 0
33557: PPUSH
33558: LD_INT 0
33560: PPUSH
33561: LD_INT 21
33563: PPUSH
33564: LD_INT 0
33566: PPUSH
33567: CALL 96351 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
33571: LD_INT 4
33573: PPUSH
33574: LD_INT 1
33576: PPUSH
33577: LD_INT 2
33579: PPUSH
33580: LD_INT 4
33582: PPUSH
33583: LD_INT 2
33585: PPUSH
33586: LD_INT 1
33588: PPUSH
33589: LD_INT 0
33591: PPUSH
33592: LD_INT 22
33594: PPUSH
33595: LD_INT 0
33597: PPUSH
33598: CALL 96351 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
33602: LD_INT 0
33604: PPUSH
33605: LD_INT 0
33607: PPUSH
33608: LD_INT 0
33610: PPUSH
33611: LD_INT 0
33613: PPUSH
33614: LD_INT 0
33616: PPUSH
33617: LD_INT 0
33619: PPUSH
33620: LD_INT 9
33622: PPUSH
33623: LD_INT 0
33625: PPUSH
33626: LD_INT 23
33628: PPUSH
33629: CALL 96351 0 9
// end ; end_of_file
33633: LD_VAR 0 1
33637: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
33638: GO 33640
33640: DISABLE
// begin ru_radar := 98 ;
33641: LD_ADDR_EXP 92
33645: PUSH
33646: LD_INT 98
33648: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
33649: LD_ADDR_EXP 93
33653: PUSH
33654: LD_INT 89
33656: ST_TO_ADDR
// us_hack := 99 ;
33657: LD_ADDR_EXP 94
33661: PUSH
33662: LD_INT 99
33664: ST_TO_ADDR
// us_artillery := 97 ;
33665: LD_ADDR_EXP 95
33669: PUSH
33670: LD_INT 97
33672: ST_TO_ADDR
// ar_bio_bomb := 91 ;
33673: LD_ADDR_EXP 96
33677: PUSH
33678: LD_INT 91
33680: ST_TO_ADDR
// end ; end_of_file
33681: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
33682: LD_INT 0
33684: PPUSH
33685: PPUSH
// skirmish := false ;
33686: LD_ADDR_EXP 97
33690: PUSH
33691: LD_INT 0
33693: ST_TO_ADDR
// debug_mc := false ;
33694: LD_ADDR_EXP 98
33698: PUSH
33699: LD_INT 0
33701: ST_TO_ADDR
// mc_bases := [ ] ;
33702: LD_ADDR_EXP 99
33706: PUSH
33707: EMPTY
33708: ST_TO_ADDR
// mc_sides := [ ] ;
33709: LD_ADDR_EXP 125
33713: PUSH
33714: EMPTY
33715: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
33716: LD_ADDR_EXP 100
33720: PUSH
33721: EMPTY
33722: ST_TO_ADDR
// mc_building_repairs := [ ] ;
33723: LD_ADDR_EXP 101
33727: PUSH
33728: EMPTY
33729: ST_TO_ADDR
// mc_need_heal := [ ] ;
33730: LD_ADDR_EXP 102
33734: PUSH
33735: EMPTY
33736: ST_TO_ADDR
// mc_healers := [ ] ;
33737: LD_ADDR_EXP 103
33741: PUSH
33742: EMPTY
33743: ST_TO_ADDR
// mc_build_list := [ ] ;
33744: LD_ADDR_EXP 104
33748: PUSH
33749: EMPTY
33750: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
33751: LD_ADDR_EXP 131
33755: PUSH
33756: EMPTY
33757: ST_TO_ADDR
// mc_builders := [ ] ;
33758: LD_ADDR_EXP 105
33762: PUSH
33763: EMPTY
33764: ST_TO_ADDR
// mc_construct_list := [ ] ;
33765: LD_ADDR_EXP 106
33769: PUSH
33770: EMPTY
33771: ST_TO_ADDR
// mc_turret_list := [ ] ;
33772: LD_ADDR_EXP 107
33776: PUSH
33777: EMPTY
33778: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
33779: LD_ADDR_EXP 108
33783: PUSH
33784: EMPTY
33785: ST_TO_ADDR
// mc_miners := [ ] ;
33786: LD_ADDR_EXP 113
33790: PUSH
33791: EMPTY
33792: ST_TO_ADDR
// mc_mines := [ ] ;
33793: LD_ADDR_EXP 112
33797: PUSH
33798: EMPTY
33799: ST_TO_ADDR
// mc_minefields := [ ] ;
33800: LD_ADDR_EXP 114
33804: PUSH
33805: EMPTY
33806: ST_TO_ADDR
// mc_crates := [ ] ;
33807: LD_ADDR_EXP 115
33811: PUSH
33812: EMPTY
33813: ST_TO_ADDR
// mc_crates_collector := [ ] ;
33814: LD_ADDR_EXP 116
33818: PUSH
33819: EMPTY
33820: ST_TO_ADDR
// mc_crates_area := [ ] ;
33821: LD_ADDR_EXP 117
33825: PUSH
33826: EMPTY
33827: ST_TO_ADDR
// mc_vehicles := [ ] ;
33828: LD_ADDR_EXP 118
33832: PUSH
33833: EMPTY
33834: ST_TO_ADDR
// mc_attack := [ ] ;
33835: LD_ADDR_EXP 119
33839: PUSH
33840: EMPTY
33841: ST_TO_ADDR
// mc_produce := [ ] ;
33842: LD_ADDR_EXP 120
33846: PUSH
33847: EMPTY
33848: ST_TO_ADDR
// mc_defender := [ ] ;
33849: LD_ADDR_EXP 121
33853: PUSH
33854: EMPTY
33855: ST_TO_ADDR
// mc_parking := [ ] ;
33856: LD_ADDR_EXP 123
33860: PUSH
33861: EMPTY
33862: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
33863: LD_ADDR_EXP 109
33867: PUSH
33868: EMPTY
33869: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
33870: LD_ADDR_EXP 111
33874: PUSH
33875: EMPTY
33876: ST_TO_ADDR
// mc_scan := [ ] ;
33877: LD_ADDR_EXP 122
33881: PUSH
33882: EMPTY
33883: ST_TO_ADDR
// mc_scan_area := [ ] ;
33884: LD_ADDR_EXP 124
33888: PUSH
33889: EMPTY
33890: ST_TO_ADDR
// mc_tech := [ ] ;
33891: LD_ADDR_EXP 126
33895: PUSH
33896: EMPTY
33897: ST_TO_ADDR
// mc_class := [ ] ;
33898: LD_ADDR_EXP 140
33902: PUSH
33903: EMPTY
33904: ST_TO_ADDR
// mc_class_case_use := [ ] ;
33905: LD_ADDR_EXP 141
33909: PUSH
33910: EMPTY
33911: ST_TO_ADDR
// end ;
33912: LD_VAR 0 1
33916: RET
// export function MC_Kill ( base ) ; begin
33917: LD_INT 0
33919: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
33920: LD_ADDR_EXP 99
33924: PUSH
33925: LD_EXP 99
33929: PPUSH
33930: LD_VAR 0 1
33934: PPUSH
33935: EMPTY
33936: PPUSH
33937: CALL_OW 1
33941: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
33942: LD_ADDR_EXP 100
33946: PUSH
33947: LD_EXP 100
33951: PPUSH
33952: LD_VAR 0 1
33956: PPUSH
33957: EMPTY
33958: PPUSH
33959: CALL_OW 1
33963: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
33964: LD_ADDR_EXP 101
33968: PUSH
33969: LD_EXP 101
33973: PPUSH
33974: LD_VAR 0 1
33978: PPUSH
33979: EMPTY
33980: PPUSH
33981: CALL_OW 1
33985: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
33986: LD_ADDR_EXP 102
33990: PUSH
33991: LD_EXP 102
33995: PPUSH
33996: LD_VAR 0 1
34000: PPUSH
34001: EMPTY
34002: PPUSH
34003: CALL_OW 1
34007: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
34008: LD_ADDR_EXP 103
34012: PUSH
34013: LD_EXP 103
34017: PPUSH
34018: LD_VAR 0 1
34022: PPUSH
34023: EMPTY
34024: PPUSH
34025: CALL_OW 1
34029: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
34030: LD_ADDR_EXP 104
34034: PUSH
34035: LD_EXP 104
34039: PPUSH
34040: LD_VAR 0 1
34044: PPUSH
34045: EMPTY
34046: PPUSH
34047: CALL_OW 1
34051: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
34052: LD_ADDR_EXP 105
34056: PUSH
34057: LD_EXP 105
34061: PPUSH
34062: LD_VAR 0 1
34066: PPUSH
34067: EMPTY
34068: PPUSH
34069: CALL_OW 1
34073: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
34074: LD_ADDR_EXP 106
34078: PUSH
34079: LD_EXP 106
34083: PPUSH
34084: LD_VAR 0 1
34088: PPUSH
34089: EMPTY
34090: PPUSH
34091: CALL_OW 1
34095: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
34096: LD_ADDR_EXP 107
34100: PUSH
34101: LD_EXP 107
34105: PPUSH
34106: LD_VAR 0 1
34110: PPUSH
34111: EMPTY
34112: PPUSH
34113: CALL_OW 1
34117: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
34118: LD_ADDR_EXP 108
34122: PUSH
34123: LD_EXP 108
34127: PPUSH
34128: LD_VAR 0 1
34132: PPUSH
34133: EMPTY
34134: PPUSH
34135: CALL_OW 1
34139: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
34140: LD_ADDR_EXP 109
34144: PUSH
34145: LD_EXP 109
34149: PPUSH
34150: LD_VAR 0 1
34154: PPUSH
34155: EMPTY
34156: PPUSH
34157: CALL_OW 1
34161: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
34162: LD_ADDR_EXP 110
34166: PUSH
34167: LD_EXP 110
34171: PPUSH
34172: LD_VAR 0 1
34176: PPUSH
34177: LD_INT 0
34179: PPUSH
34180: CALL_OW 1
34184: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
34185: LD_ADDR_EXP 111
34189: PUSH
34190: LD_EXP 111
34194: PPUSH
34195: LD_VAR 0 1
34199: PPUSH
34200: EMPTY
34201: PPUSH
34202: CALL_OW 1
34206: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
34207: LD_ADDR_EXP 112
34211: PUSH
34212: LD_EXP 112
34216: PPUSH
34217: LD_VAR 0 1
34221: PPUSH
34222: EMPTY
34223: PPUSH
34224: CALL_OW 1
34228: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
34229: LD_ADDR_EXP 113
34233: PUSH
34234: LD_EXP 113
34238: PPUSH
34239: LD_VAR 0 1
34243: PPUSH
34244: EMPTY
34245: PPUSH
34246: CALL_OW 1
34250: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
34251: LD_ADDR_EXP 114
34255: PUSH
34256: LD_EXP 114
34260: PPUSH
34261: LD_VAR 0 1
34265: PPUSH
34266: EMPTY
34267: PPUSH
34268: CALL_OW 1
34272: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
34273: LD_ADDR_EXP 115
34277: PUSH
34278: LD_EXP 115
34282: PPUSH
34283: LD_VAR 0 1
34287: PPUSH
34288: EMPTY
34289: PPUSH
34290: CALL_OW 1
34294: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
34295: LD_ADDR_EXP 116
34299: PUSH
34300: LD_EXP 116
34304: PPUSH
34305: LD_VAR 0 1
34309: PPUSH
34310: EMPTY
34311: PPUSH
34312: CALL_OW 1
34316: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
34317: LD_ADDR_EXP 117
34321: PUSH
34322: LD_EXP 117
34326: PPUSH
34327: LD_VAR 0 1
34331: PPUSH
34332: EMPTY
34333: PPUSH
34334: CALL_OW 1
34338: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
34339: LD_ADDR_EXP 118
34343: PUSH
34344: LD_EXP 118
34348: PPUSH
34349: LD_VAR 0 1
34353: PPUSH
34354: EMPTY
34355: PPUSH
34356: CALL_OW 1
34360: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
34361: LD_ADDR_EXP 119
34365: PUSH
34366: LD_EXP 119
34370: PPUSH
34371: LD_VAR 0 1
34375: PPUSH
34376: EMPTY
34377: PPUSH
34378: CALL_OW 1
34382: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
34383: LD_ADDR_EXP 120
34387: PUSH
34388: LD_EXP 120
34392: PPUSH
34393: LD_VAR 0 1
34397: PPUSH
34398: EMPTY
34399: PPUSH
34400: CALL_OW 1
34404: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
34405: LD_ADDR_EXP 121
34409: PUSH
34410: LD_EXP 121
34414: PPUSH
34415: LD_VAR 0 1
34419: PPUSH
34420: EMPTY
34421: PPUSH
34422: CALL_OW 1
34426: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
34427: LD_ADDR_EXP 122
34431: PUSH
34432: LD_EXP 122
34436: PPUSH
34437: LD_VAR 0 1
34441: PPUSH
34442: EMPTY
34443: PPUSH
34444: CALL_OW 1
34448: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
34449: LD_ADDR_EXP 123
34453: PUSH
34454: LD_EXP 123
34458: PPUSH
34459: LD_VAR 0 1
34463: PPUSH
34464: EMPTY
34465: PPUSH
34466: CALL_OW 1
34470: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
34471: LD_ADDR_EXP 124
34475: PUSH
34476: LD_EXP 124
34480: PPUSH
34481: LD_VAR 0 1
34485: PPUSH
34486: EMPTY
34487: PPUSH
34488: CALL_OW 1
34492: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
34493: LD_ADDR_EXP 126
34497: PUSH
34498: LD_EXP 126
34502: PPUSH
34503: LD_VAR 0 1
34507: PPUSH
34508: EMPTY
34509: PPUSH
34510: CALL_OW 1
34514: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
34515: LD_ADDR_EXP 128
34519: PUSH
34520: LD_EXP 128
34524: PPUSH
34525: LD_VAR 0 1
34529: PPUSH
34530: EMPTY
34531: PPUSH
34532: CALL_OW 1
34536: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
34537: LD_ADDR_EXP 129
34541: PUSH
34542: LD_EXP 129
34546: PPUSH
34547: LD_VAR 0 1
34551: PPUSH
34552: EMPTY
34553: PPUSH
34554: CALL_OW 1
34558: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
34559: LD_ADDR_EXP 130
34563: PUSH
34564: LD_EXP 130
34568: PPUSH
34569: LD_VAR 0 1
34573: PPUSH
34574: EMPTY
34575: PPUSH
34576: CALL_OW 1
34580: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
34581: LD_ADDR_EXP 131
34585: PUSH
34586: LD_EXP 131
34590: PPUSH
34591: LD_VAR 0 1
34595: PPUSH
34596: EMPTY
34597: PPUSH
34598: CALL_OW 1
34602: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
34603: LD_ADDR_EXP 132
34607: PUSH
34608: LD_EXP 132
34612: PPUSH
34613: LD_VAR 0 1
34617: PPUSH
34618: EMPTY
34619: PPUSH
34620: CALL_OW 1
34624: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
34625: LD_ADDR_EXP 133
34629: PUSH
34630: LD_EXP 133
34634: PPUSH
34635: LD_VAR 0 1
34639: PPUSH
34640: EMPTY
34641: PPUSH
34642: CALL_OW 1
34646: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
34647: LD_ADDR_EXP 134
34651: PUSH
34652: LD_EXP 134
34656: PPUSH
34657: LD_VAR 0 1
34661: PPUSH
34662: EMPTY
34663: PPUSH
34664: CALL_OW 1
34668: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
34669: LD_ADDR_EXP 135
34673: PUSH
34674: LD_EXP 135
34678: PPUSH
34679: LD_VAR 0 1
34683: PPUSH
34684: EMPTY
34685: PPUSH
34686: CALL_OW 1
34690: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
34691: LD_ADDR_EXP 136
34695: PUSH
34696: LD_EXP 136
34700: PPUSH
34701: LD_VAR 0 1
34705: PPUSH
34706: EMPTY
34707: PPUSH
34708: CALL_OW 1
34712: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
34713: LD_ADDR_EXP 137
34717: PUSH
34718: LD_EXP 137
34722: PPUSH
34723: LD_VAR 0 1
34727: PPUSH
34728: EMPTY
34729: PPUSH
34730: CALL_OW 1
34734: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
34735: LD_ADDR_EXP 138
34739: PUSH
34740: LD_EXP 138
34744: PPUSH
34745: LD_VAR 0 1
34749: PPUSH
34750: EMPTY
34751: PPUSH
34752: CALL_OW 1
34756: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
34757: LD_ADDR_EXP 139
34761: PUSH
34762: LD_EXP 139
34766: PPUSH
34767: LD_VAR 0 1
34771: PPUSH
34772: EMPTY
34773: PPUSH
34774: CALL_OW 1
34778: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
34779: LD_ADDR_EXP 140
34783: PUSH
34784: LD_EXP 140
34788: PPUSH
34789: LD_VAR 0 1
34793: PPUSH
34794: EMPTY
34795: PPUSH
34796: CALL_OW 1
34800: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
34801: LD_ADDR_EXP 141
34805: PUSH
34806: LD_EXP 141
34810: PPUSH
34811: LD_VAR 0 1
34815: PPUSH
34816: LD_INT 0
34818: PPUSH
34819: CALL_OW 1
34823: ST_TO_ADDR
// end ;
34824: LD_VAR 0 2
34828: RET
// export function MC_Start ( ) ; var i ; begin
34829: LD_INT 0
34831: PPUSH
34832: PPUSH
// for i = 1 to mc_bases do
34833: LD_ADDR_VAR 0 2
34837: PUSH
34838: DOUBLE
34839: LD_INT 1
34841: DEC
34842: ST_TO_ADDR
34843: LD_EXP 99
34847: PUSH
34848: FOR_TO
34849: IFFALSE 35926
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
34851: LD_ADDR_EXP 99
34855: PUSH
34856: LD_EXP 99
34860: PPUSH
34861: LD_VAR 0 2
34865: PPUSH
34866: LD_EXP 99
34870: PUSH
34871: LD_VAR 0 2
34875: ARRAY
34876: PUSH
34877: LD_INT 0
34879: DIFF
34880: PPUSH
34881: CALL_OW 1
34885: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
34886: LD_ADDR_EXP 100
34890: PUSH
34891: LD_EXP 100
34895: PPUSH
34896: LD_VAR 0 2
34900: PPUSH
34901: EMPTY
34902: PPUSH
34903: CALL_OW 1
34907: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
34908: LD_ADDR_EXP 101
34912: PUSH
34913: LD_EXP 101
34917: PPUSH
34918: LD_VAR 0 2
34922: PPUSH
34923: EMPTY
34924: PPUSH
34925: CALL_OW 1
34929: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
34930: LD_ADDR_EXP 102
34934: PUSH
34935: LD_EXP 102
34939: PPUSH
34940: LD_VAR 0 2
34944: PPUSH
34945: EMPTY
34946: PPUSH
34947: CALL_OW 1
34951: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
34952: LD_ADDR_EXP 103
34956: PUSH
34957: LD_EXP 103
34961: PPUSH
34962: LD_VAR 0 2
34966: PPUSH
34967: EMPTY
34968: PUSH
34969: EMPTY
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PPUSH
34975: CALL_OW 1
34979: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
34980: LD_ADDR_EXP 104
34984: PUSH
34985: LD_EXP 104
34989: PPUSH
34990: LD_VAR 0 2
34994: PPUSH
34995: EMPTY
34996: PPUSH
34997: CALL_OW 1
35001: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
35002: LD_ADDR_EXP 131
35006: PUSH
35007: LD_EXP 131
35011: PPUSH
35012: LD_VAR 0 2
35016: PPUSH
35017: EMPTY
35018: PPUSH
35019: CALL_OW 1
35023: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
35024: LD_ADDR_EXP 105
35028: PUSH
35029: LD_EXP 105
35033: PPUSH
35034: LD_VAR 0 2
35038: PPUSH
35039: EMPTY
35040: PPUSH
35041: CALL_OW 1
35045: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
35046: LD_ADDR_EXP 106
35050: PUSH
35051: LD_EXP 106
35055: PPUSH
35056: LD_VAR 0 2
35060: PPUSH
35061: EMPTY
35062: PPUSH
35063: CALL_OW 1
35067: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
35068: LD_ADDR_EXP 107
35072: PUSH
35073: LD_EXP 107
35077: PPUSH
35078: LD_VAR 0 2
35082: PPUSH
35083: LD_EXP 99
35087: PUSH
35088: LD_VAR 0 2
35092: ARRAY
35093: PPUSH
35094: LD_INT 2
35096: PUSH
35097: LD_INT 30
35099: PUSH
35100: LD_INT 32
35102: PUSH
35103: EMPTY
35104: LIST
35105: LIST
35106: PUSH
35107: LD_INT 30
35109: PUSH
35110: LD_INT 33
35112: PUSH
35113: EMPTY
35114: LIST
35115: LIST
35116: PUSH
35117: EMPTY
35118: LIST
35119: LIST
35120: LIST
35121: PPUSH
35122: CALL_OW 72
35126: PPUSH
35127: CALL_OW 1
35131: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
35132: LD_ADDR_EXP 108
35136: PUSH
35137: LD_EXP 108
35141: PPUSH
35142: LD_VAR 0 2
35146: PPUSH
35147: LD_EXP 99
35151: PUSH
35152: LD_VAR 0 2
35156: ARRAY
35157: PPUSH
35158: LD_INT 2
35160: PUSH
35161: LD_INT 30
35163: PUSH
35164: LD_INT 32
35166: PUSH
35167: EMPTY
35168: LIST
35169: LIST
35170: PUSH
35171: LD_INT 30
35173: PUSH
35174: LD_INT 31
35176: PUSH
35177: EMPTY
35178: LIST
35179: LIST
35180: PUSH
35181: EMPTY
35182: LIST
35183: LIST
35184: LIST
35185: PUSH
35186: LD_INT 58
35188: PUSH
35189: EMPTY
35190: LIST
35191: PUSH
35192: EMPTY
35193: LIST
35194: LIST
35195: PPUSH
35196: CALL_OW 72
35200: PPUSH
35201: CALL_OW 1
35205: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
35206: LD_ADDR_EXP 109
35210: PUSH
35211: LD_EXP 109
35215: PPUSH
35216: LD_VAR 0 2
35220: PPUSH
35221: EMPTY
35222: PPUSH
35223: CALL_OW 1
35227: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
35228: LD_ADDR_EXP 113
35232: PUSH
35233: LD_EXP 113
35237: PPUSH
35238: LD_VAR 0 2
35242: PPUSH
35243: EMPTY
35244: PPUSH
35245: CALL_OW 1
35249: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
35250: LD_ADDR_EXP 112
35254: PUSH
35255: LD_EXP 112
35259: PPUSH
35260: LD_VAR 0 2
35264: PPUSH
35265: EMPTY
35266: PPUSH
35267: CALL_OW 1
35271: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
35272: LD_ADDR_EXP 114
35276: PUSH
35277: LD_EXP 114
35281: PPUSH
35282: LD_VAR 0 2
35286: PPUSH
35287: EMPTY
35288: PPUSH
35289: CALL_OW 1
35293: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
35294: LD_ADDR_EXP 115
35298: PUSH
35299: LD_EXP 115
35303: PPUSH
35304: LD_VAR 0 2
35308: PPUSH
35309: EMPTY
35310: PPUSH
35311: CALL_OW 1
35315: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
35316: LD_ADDR_EXP 116
35320: PUSH
35321: LD_EXP 116
35325: PPUSH
35326: LD_VAR 0 2
35330: PPUSH
35331: EMPTY
35332: PPUSH
35333: CALL_OW 1
35337: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
35338: LD_ADDR_EXP 117
35342: PUSH
35343: LD_EXP 117
35347: PPUSH
35348: LD_VAR 0 2
35352: PPUSH
35353: EMPTY
35354: PPUSH
35355: CALL_OW 1
35359: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
35360: LD_ADDR_EXP 118
35364: PUSH
35365: LD_EXP 118
35369: PPUSH
35370: LD_VAR 0 2
35374: PPUSH
35375: EMPTY
35376: PPUSH
35377: CALL_OW 1
35381: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
35382: LD_ADDR_EXP 119
35386: PUSH
35387: LD_EXP 119
35391: PPUSH
35392: LD_VAR 0 2
35396: PPUSH
35397: EMPTY
35398: PPUSH
35399: CALL_OW 1
35403: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
35404: LD_ADDR_EXP 120
35408: PUSH
35409: LD_EXP 120
35413: PPUSH
35414: LD_VAR 0 2
35418: PPUSH
35419: EMPTY
35420: PPUSH
35421: CALL_OW 1
35425: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
35426: LD_ADDR_EXP 121
35430: PUSH
35431: LD_EXP 121
35435: PPUSH
35436: LD_VAR 0 2
35440: PPUSH
35441: EMPTY
35442: PPUSH
35443: CALL_OW 1
35447: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
35448: LD_ADDR_EXP 110
35452: PUSH
35453: LD_EXP 110
35457: PPUSH
35458: LD_VAR 0 2
35462: PPUSH
35463: LD_INT 0
35465: PPUSH
35466: CALL_OW 1
35470: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
35471: LD_ADDR_EXP 123
35475: PUSH
35476: LD_EXP 123
35480: PPUSH
35481: LD_VAR 0 2
35485: PPUSH
35486: LD_INT 0
35488: PPUSH
35489: CALL_OW 1
35493: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
35494: LD_ADDR_EXP 111
35498: PUSH
35499: LD_EXP 111
35503: PPUSH
35504: LD_VAR 0 2
35508: PPUSH
35509: EMPTY
35510: PPUSH
35511: CALL_OW 1
35515: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
35516: LD_ADDR_EXP 122
35520: PUSH
35521: LD_EXP 122
35525: PPUSH
35526: LD_VAR 0 2
35530: PPUSH
35531: LD_INT 0
35533: PPUSH
35534: CALL_OW 1
35538: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
35539: LD_ADDR_EXP 124
35543: PUSH
35544: LD_EXP 124
35548: PPUSH
35549: LD_VAR 0 2
35553: PPUSH
35554: EMPTY
35555: PPUSH
35556: CALL_OW 1
35560: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
35561: LD_ADDR_EXP 127
35565: PUSH
35566: LD_EXP 127
35570: PPUSH
35571: LD_VAR 0 2
35575: PPUSH
35576: LD_INT 0
35578: PPUSH
35579: CALL_OW 1
35583: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
35584: LD_ADDR_EXP 128
35588: PUSH
35589: LD_EXP 128
35593: PPUSH
35594: LD_VAR 0 2
35598: PPUSH
35599: EMPTY
35600: PPUSH
35601: CALL_OW 1
35605: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
35606: LD_ADDR_EXP 129
35610: PUSH
35611: LD_EXP 129
35615: PPUSH
35616: LD_VAR 0 2
35620: PPUSH
35621: EMPTY
35622: PPUSH
35623: CALL_OW 1
35627: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
35628: LD_ADDR_EXP 130
35632: PUSH
35633: LD_EXP 130
35637: PPUSH
35638: LD_VAR 0 2
35642: PPUSH
35643: EMPTY
35644: PPUSH
35645: CALL_OW 1
35649: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
35650: LD_ADDR_EXP 132
35654: PUSH
35655: LD_EXP 132
35659: PPUSH
35660: LD_VAR 0 2
35664: PPUSH
35665: LD_EXP 99
35669: PUSH
35670: LD_VAR 0 2
35674: ARRAY
35675: PPUSH
35676: LD_INT 2
35678: PUSH
35679: LD_INT 30
35681: PUSH
35682: LD_INT 6
35684: PUSH
35685: EMPTY
35686: LIST
35687: LIST
35688: PUSH
35689: LD_INT 30
35691: PUSH
35692: LD_INT 7
35694: PUSH
35695: EMPTY
35696: LIST
35697: LIST
35698: PUSH
35699: LD_INT 30
35701: PUSH
35702: LD_INT 8
35704: PUSH
35705: EMPTY
35706: LIST
35707: LIST
35708: PUSH
35709: EMPTY
35710: LIST
35711: LIST
35712: LIST
35713: LIST
35714: PPUSH
35715: CALL_OW 72
35719: PPUSH
35720: CALL_OW 1
35724: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
35725: LD_ADDR_EXP 133
35729: PUSH
35730: LD_EXP 133
35734: PPUSH
35735: LD_VAR 0 2
35739: PPUSH
35740: EMPTY
35741: PPUSH
35742: CALL_OW 1
35746: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
35747: LD_ADDR_EXP 134
35751: PUSH
35752: LD_EXP 134
35756: PPUSH
35757: LD_VAR 0 2
35761: PPUSH
35762: EMPTY
35763: PPUSH
35764: CALL_OW 1
35768: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
35769: LD_ADDR_EXP 135
35773: PUSH
35774: LD_EXP 135
35778: PPUSH
35779: LD_VAR 0 2
35783: PPUSH
35784: EMPTY
35785: PPUSH
35786: CALL_OW 1
35790: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
35791: LD_ADDR_EXP 136
35795: PUSH
35796: LD_EXP 136
35800: PPUSH
35801: LD_VAR 0 2
35805: PPUSH
35806: EMPTY
35807: PPUSH
35808: CALL_OW 1
35812: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
35813: LD_ADDR_EXP 137
35817: PUSH
35818: LD_EXP 137
35822: PPUSH
35823: LD_VAR 0 2
35827: PPUSH
35828: EMPTY
35829: PPUSH
35830: CALL_OW 1
35834: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
35835: LD_ADDR_EXP 138
35839: PUSH
35840: LD_EXP 138
35844: PPUSH
35845: LD_VAR 0 2
35849: PPUSH
35850: EMPTY
35851: PPUSH
35852: CALL_OW 1
35856: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
35857: LD_ADDR_EXP 139
35861: PUSH
35862: LD_EXP 139
35866: PPUSH
35867: LD_VAR 0 2
35871: PPUSH
35872: EMPTY
35873: PPUSH
35874: CALL_OW 1
35878: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
35879: LD_ADDR_EXP 140
35883: PUSH
35884: LD_EXP 140
35888: PPUSH
35889: LD_VAR 0 2
35893: PPUSH
35894: EMPTY
35895: PPUSH
35896: CALL_OW 1
35900: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
35901: LD_ADDR_EXP 141
35905: PUSH
35906: LD_EXP 141
35910: PPUSH
35911: LD_VAR 0 2
35915: PPUSH
35916: LD_INT 0
35918: PPUSH
35919: CALL_OW 1
35923: ST_TO_ADDR
// end ;
35924: GO 34848
35926: POP
35927: POP
// MC_InitSides ( ) ;
35928: CALL 36214 0 0
// MC_InitResearch ( ) ;
35932: CALL 35953 0 0
// CustomInitMacro ( ) ;
35936: CALL 437 0 0
// skirmish := true ;
35940: LD_ADDR_EXP 97
35944: PUSH
35945: LD_INT 1
35947: ST_TO_ADDR
// end ;
35948: LD_VAR 0 1
35952: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
35953: LD_INT 0
35955: PPUSH
35956: PPUSH
35957: PPUSH
35958: PPUSH
35959: PPUSH
35960: PPUSH
// if not mc_bases then
35961: LD_EXP 99
35965: NOT
35966: IFFALSE 35970
// exit ;
35968: GO 36209
// for i = 1 to 8 do
35970: LD_ADDR_VAR 0 2
35974: PUSH
35975: DOUBLE
35976: LD_INT 1
35978: DEC
35979: ST_TO_ADDR
35980: LD_INT 8
35982: PUSH
35983: FOR_TO
35984: IFFALSE 36010
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
35986: LD_ADDR_EXP 126
35990: PUSH
35991: LD_EXP 126
35995: PPUSH
35996: LD_VAR 0 2
36000: PPUSH
36001: EMPTY
36002: PPUSH
36003: CALL_OW 1
36007: ST_TO_ADDR
36008: GO 35983
36010: POP
36011: POP
// tmp := [ ] ;
36012: LD_ADDR_VAR 0 5
36016: PUSH
36017: EMPTY
36018: ST_TO_ADDR
// for i = 1 to mc_sides do
36019: LD_ADDR_VAR 0 2
36023: PUSH
36024: DOUBLE
36025: LD_INT 1
36027: DEC
36028: ST_TO_ADDR
36029: LD_EXP 125
36033: PUSH
36034: FOR_TO
36035: IFFALSE 36093
// if not mc_sides [ i ] in tmp then
36037: LD_EXP 125
36041: PUSH
36042: LD_VAR 0 2
36046: ARRAY
36047: PUSH
36048: LD_VAR 0 5
36052: IN
36053: NOT
36054: IFFALSE 36091
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
36056: LD_ADDR_VAR 0 5
36060: PUSH
36061: LD_VAR 0 5
36065: PPUSH
36066: LD_VAR 0 5
36070: PUSH
36071: LD_INT 1
36073: PLUS
36074: PPUSH
36075: LD_EXP 125
36079: PUSH
36080: LD_VAR 0 2
36084: ARRAY
36085: PPUSH
36086: CALL_OW 2
36090: ST_TO_ADDR
36091: GO 36034
36093: POP
36094: POP
// if not tmp then
36095: LD_VAR 0 5
36099: NOT
36100: IFFALSE 36104
// exit ;
36102: GO 36209
// for j in tmp do
36104: LD_ADDR_VAR 0 3
36108: PUSH
36109: LD_VAR 0 5
36113: PUSH
36114: FOR_IN
36115: IFFALSE 36207
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
36117: LD_ADDR_VAR 0 6
36121: PUSH
36122: LD_INT 22
36124: PUSH
36125: LD_VAR 0 3
36129: PUSH
36130: EMPTY
36131: LIST
36132: LIST
36133: PPUSH
36134: CALL_OW 69
36138: ST_TO_ADDR
// if not un then
36139: LD_VAR 0 6
36143: NOT
36144: IFFALSE 36148
// continue ;
36146: GO 36114
// nation := GetNation ( un [ 1 ] ) ;
36148: LD_ADDR_VAR 0 4
36152: PUSH
36153: LD_VAR 0 6
36157: PUSH
36158: LD_INT 1
36160: ARRAY
36161: PPUSH
36162: CALL_OW 248
36166: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
36167: LD_ADDR_EXP 126
36171: PUSH
36172: LD_EXP 126
36176: PPUSH
36177: LD_VAR 0 3
36181: PPUSH
36182: LD_VAR 0 3
36186: PPUSH
36187: LD_VAR 0 4
36191: PPUSH
36192: LD_INT 1
36194: PPUSH
36195: CALL 61991 0 3
36199: PPUSH
36200: CALL_OW 1
36204: ST_TO_ADDR
// end ;
36205: GO 36114
36207: POP
36208: POP
// end ;
36209: LD_VAR 0 1
36213: RET
// export function MC_InitSides ( ) ; var i ; begin
36214: LD_INT 0
36216: PPUSH
36217: PPUSH
// if not mc_bases then
36218: LD_EXP 99
36222: NOT
36223: IFFALSE 36227
// exit ;
36225: GO 36301
// for i = 1 to mc_bases do
36227: LD_ADDR_VAR 0 2
36231: PUSH
36232: DOUBLE
36233: LD_INT 1
36235: DEC
36236: ST_TO_ADDR
36237: LD_EXP 99
36241: PUSH
36242: FOR_TO
36243: IFFALSE 36299
// if mc_bases [ i ] then
36245: LD_EXP 99
36249: PUSH
36250: LD_VAR 0 2
36254: ARRAY
36255: IFFALSE 36297
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
36257: LD_ADDR_EXP 125
36261: PUSH
36262: LD_EXP 125
36266: PPUSH
36267: LD_VAR 0 2
36271: PPUSH
36272: LD_EXP 99
36276: PUSH
36277: LD_VAR 0 2
36281: ARRAY
36282: PUSH
36283: LD_INT 1
36285: ARRAY
36286: PPUSH
36287: CALL_OW 255
36291: PPUSH
36292: CALL_OW 1
36296: ST_TO_ADDR
36297: GO 36242
36299: POP
36300: POP
// end ;
36301: LD_VAR 0 1
36305: RET
// every 0 0$01 trigger skirmish do
36306: LD_EXP 97
36310: IFFALSE 36464
36312: GO 36314
36314: DISABLE
// begin enable ;
36315: ENABLE
// MC_CheckBuildings ( ) ;
36316: CALL 40953 0 0
// MC_CheckPeopleLife ( ) ;
36320: CALL 41078 0 0
// RaiseSailEvent ( 100 ) ;
36324: LD_INT 100
36326: PPUSH
36327: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
36331: LD_INT 103
36333: PPUSH
36334: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
36338: LD_INT 104
36340: PPUSH
36341: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
36345: LD_INT 105
36347: PPUSH
36348: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
36352: LD_INT 106
36354: PPUSH
36355: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
36359: LD_INT 107
36361: PPUSH
36362: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
36366: LD_INT 108
36368: PPUSH
36369: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
36373: LD_INT 109
36375: PPUSH
36376: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
36380: LD_INT 110
36382: PPUSH
36383: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
36387: LD_INT 111
36389: PPUSH
36390: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
36394: LD_INT 112
36396: PPUSH
36397: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
36401: LD_INT 113
36403: PPUSH
36404: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
36408: LD_INT 120
36410: PPUSH
36411: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
36415: LD_INT 121
36417: PPUSH
36418: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
36422: LD_INT 122
36424: PPUSH
36425: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
36429: LD_INT 123
36431: PPUSH
36432: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
36436: LD_INT 124
36438: PPUSH
36439: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
36443: LD_INT 125
36445: PPUSH
36446: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
36450: LD_INT 126
36452: PPUSH
36453: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
36457: LD_INT 200
36459: PPUSH
36460: CALL_OW 427
// end ;
36464: END
// on SailEvent ( event ) do begin if event < 100 then
36465: LD_VAR 0 1
36469: PUSH
36470: LD_INT 100
36472: LESS
36473: IFFALSE 36484
// CustomEvent ( event ) ;
36475: LD_VAR 0 1
36479: PPUSH
36480: CALL 32124 0 1
// if event = 100 then
36484: LD_VAR 0 1
36488: PUSH
36489: LD_INT 100
36491: EQUAL
36492: IFFALSE 36498
// MC_ClassManager ( ) ;
36494: CALL 36890 0 0
// if event = 101 then
36498: LD_VAR 0 1
36502: PUSH
36503: LD_INT 101
36505: EQUAL
36506: IFFALSE 36512
// MC_RepairBuildings ( ) ;
36508: CALL 41674 0 0
// if event = 102 then
36512: LD_VAR 0 1
36516: PUSH
36517: LD_INT 102
36519: EQUAL
36520: IFFALSE 36526
// MC_Heal ( ) ;
36522: CALL 42080 0 0
// if event = 103 then
36526: LD_VAR 0 1
36530: PUSH
36531: LD_INT 103
36533: EQUAL
36534: IFFALSE 36540
// MC_Build ( ) ;
36536: CALL 42502 0 0
// if event = 104 then
36540: LD_VAR 0 1
36544: PUSH
36545: LD_INT 104
36547: EQUAL
36548: IFFALSE 36554
// MC_TurretWeapon ( ) ;
36550: CALL 44115 0 0
// if event = 105 then
36554: LD_VAR 0 1
36558: PUSH
36559: LD_INT 105
36561: EQUAL
36562: IFFALSE 36568
// MC_BuildUpgrade ( ) ;
36564: CALL 43666 0 0
// if event = 106 then
36568: LD_VAR 0 1
36572: PUSH
36573: LD_INT 106
36575: EQUAL
36576: IFFALSE 36582
// MC_PlantMines ( ) ;
36578: CALL 44545 0 0
// if event = 107 then
36582: LD_VAR 0 1
36586: PUSH
36587: LD_INT 107
36589: EQUAL
36590: IFFALSE 36596
// MC_CollectCrates ( ) ;
36592: CALL 45579 0 0
// if event = 108 then
36596: LD_VAR 0 1
36600: PUSH
36601: LD_INT 108
36603: EQUAL
36604: IFFALSE 36610
// MC_LinkRemoteControl ( ) ;
36606: CALL 47336 0 0
// if event = 109 then
36610: LD_VAR 0 1
36614: PUSH
36615: LD_INT 109
36617: EQUAL
36618: IFFALSE 36624
// MC_ProduceVehicle ( ) ;
36620: CALL 47517 0 0
// if event = 110 then
36624: LD_VAR 0 1
36628: PUSH
36629: LD_INT 110
36631: EQUAL
36632: IFFALSE 36638
// MC_SendAttack ( ) ;
36634: CALL 47998 0 0
// if event = 111 then
36638: LD_VAR 0 1
36642: PUSH
36643: LD_INT 111
36645: EQUAL
36646: IFFALSE 36652
// MC_Defend ( ) ;
36648: CALL 48106 0 0
// if event = 112 then
36652: LD_VAR 0 1
36656: PUSH
36657: LD_INT 112
36659: EQUAL
36660: IFFALSE 36666
// MC_Research ( ) ;
36662: CALL 48733 0 0
// if event = 113 then
36666: LD_VAR 0 1
36670: PUSH
36671: LD_INT 113
36673: EQUAL
36674: IFFALSE 36680
// MC_MinesTrigger ( ) ;
36676: CALL 49847 0 0
// if event = 120 then
36680: LD_VAR 0 1
36684: PUSH
36685: LD_INT 120
36687: EQUAL
36688: IFFALSE 36694
// MC_RepairVehicle ( ) ;
36690: CALL 49946 0 0
// if event = 121 then
36694: LD_VAR 0 1
36698: PUSH
36699: LD_INT 121
36701: EQUAL
36702: IFFALSE 36708
// MC_TameApe ( ) ;
36704: CALL 50689 0 0
// if event = 122 then
36708: LD_VAR 0 1
36712: PUSH
36713: LD_INT 122
36715: EQUAL
36716: IFFALSE 36722
// MC_ChangeApeClass ( ) ;
36718: CALL 51518 0 0
// if event = 123 then
36722: LD_VAR 0 1
36726: PUSH
36727: LD_INT 123
36729: EQUAL
36730: IFFALSE 36736
// MC_Bazooka ( ) ;
36732: CALL 52168 0 0
// if event = 124 then
36736: LD_VAR 0 1
36740: PUSH
36741: LD_INT 124
36743: EQUAL
36744: IFFALSE 36750
// MC_TeleportExit ( ) ;
36746: CALL 52366 0 0
// if event = 125 then
36750: LD_VAR 0 1
36754: PUSH
36755: LD_INT 125
36757: EQUAL
36758: IFFALSE 36764
// MC_Deposits ( ) ;
36760: CALL 53013 0 0
// if event = 126 then
36764: LD_VAR 0 1
36768: PUSH
36769: LD_INT 126
36771: EQUAL
36772: IFFALSE 36778
// MC_RemoteDriver ( ) ;
36774: CALL 53638 0 0
// if event = 200 then
36778: LD_VAR 0 1
36782: PUSH
36783: LD_INT 200
36785: EQUAL
36786: IFFALSE 36792
// MC_Idle ( ) ;
36788: CALL 55371 0 0
// end ;
36792: PPOPN 1
36794: END
// export function MC_Reset ( base , tag ) ; var i ; begin
36795: LD_INT 0
36797: PPUSH
36798: PPUSH
// if not mc_bases [ base ] or not tag then
36799: LD_EXP 99
36803: PUSH
36804: LD_VAR 0 1
36808: ARRAY
36809: NOT
36810: PUSH
36811: LD_VAR 0 2
36815: NOT
36816: OR
36817: IFFALSE 36821
// exit ;
36819: GO 36885
// for i in mc_bases [ base ] union mc_ape [ base ] do
36821: LD_ADDR_VAR 0 4
36825: PUSH
36826: LD_EXP 99
36830: PUSH
36831: LD_VAR 0 1
36835: ARRAY
36836: PUSH
36837: LD_EXP 128
36841: PUSH
36842: LD_VAR 0 1
36846: ARRAY
36847: UNION
36848: PUSH
36849: FOR_IN
36850: IFFALSE 36883
// if GetTag ( i ) = tag then
36852: LD_VAR 0 4
36856: PPUSH
36857: CALL_OW 110
36861: PUSH
36862: LD_VAR 0 2
36866: EQUAL
36867: IFFALSE 36881
// SetTag ( i , 0 ) ;
36869: LD_VAR 0 4
36873: PPUSH
36874: LD_INT 0
36876: PPUSH
36877: CALL_OW 109
36881: GO 36849
36883: POP
36884: POP
// end ;
36885: LD_VAR 0 3
36889: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
36890: LD_INT 0
36892: PPUSH
36893: PPUSH
36894: PPUSH
36895: PPUSH
36896: PPUSH
36897: PPUSH
36898: PPUSH
36899: PPUSH
// if not mc_bases then
36900: LD_EXP 99
36904: NOT
36905: IFFALSE 36909
// exit ;
36907: GO 37367
// for i = 1 to mc_bases do
36909: LD_ADDR_VAR 0 2
36913: PUSH
36914: DOUBLE
36915: LD_INT 1
36917: DEC
36918: ST_TO_ADDR
36919: LD_EXP 99
36923: PUSH
36924: FOR_TO
36925: IFFALSE 37365
// begin tmp := MC_ClassCheckReq ( i ) ;
36927: LD_ADDR_VAR 0 4
36931: PUSH
36932: LD_VAR 0 2
36936: PPUSH
36937: CALL 37372 0 1
36941: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
36942: LD_ADDR_EXP 140
36946: PUSH
36947: LD_EXP 140
36951: PPUSH
36952: LD_VAR 0 2
36956: PPUSH
36957: LD_VAR 0 4
36961: PPUSH
36962: CALL_OW 1
36966: ST_TO_ADDR
// if not tmp then
36967: LD_VAR 0 4
36971: NOT
36972: IFFALSE 36976
// continue ;
36974: GO 36924
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
36976: LD_ADDR_VAR 0 6
36980: PUSH
36981: LD_EXP 99
36985: PUSH
36986: LD_VAR 0 2
36990: ARRAY
36991: PPUSH
36992: LD_INT 2
36994: PUSH
36995: LD_INT 30
36997: PUSH
36998: LD_INT 4
37000: PUSH
37001: EMPTY
37002: LIST
37003: LIST
37004: PUSH
37005: LD_INT 30
37007: PUSH
37008: LD_INT 5
37010: PUSH
37011: EMPTY
37012: LIST
37013: LIST
37014: PUSH
37015: EMPTY
37016: LIST
37017: LIST
37018: LIST
37019: PPUSH
37020: CALL_OW 72
37024: PUSH
37025: LD_EXP 99
37029: PUSH
37030: LD_VAR 0 2
37034: ARRAY
37035: PPUSH
37036: LD_INT 2
37038: PUSH
37039: LD_INT 30
37041: PUSH
37042: LD_INT 0
37044: PUSH
37045: EMPTY
37046: LIST
37047: LIST
37048: PUSH
37049: LD_INT 30
37051: PUSH
37052: LD_INT 1
37054: PUSH
37055: EMPTY
37056: LIST
37057: LIST
37058: PUSH
37059: EMPTY
37060: LIST
37061: LIST
37062: LIST
37063: PPUSH
37064: CALL_OW 72
37068: PUSH
37069: LD_EXP 99
37073: PUSH
37074: LD_VAR 0 2
37078: ARRAY
37079: PPUSH
37080: LD_INT 30
37082: PUSH
37083: LD_INT 3
37085: PUSH
37086: EMPTY
37087: LIST
37088: LIST
37089: PPUSH
37090: CALL_OW 72
37094: PUSH
37095: LD_EXP 99
37099: PUSH
37100: LD_VAR 0 2
37104: ARRAY
37105: PPUSH
37106: LD_INT 2
37108: PUSH
37109: LD_INT 30
37111: PUSH
37112: LD_INT 6
37114: PUSH
37115: EMPTY
37116: LIST
37117: LIST
37118: PUSH
37119: LD_INT 30
37121: PUSH
37122: LD_INT 7
37124: PUSH
37125: EMPTY
37126: LIST
37127: LIST
37128: PUSH
37129: LD_INT 30
37131: PUSH
37132: LD_INT 8
37134: PUSH
37135: EMPTY
37136: LIST
37137: LIST
37138: PUSH
37139: EMPTY
37140: LIST
37141: LIST
37142: LIST
37143: LIST
37144: PPUSH
37145: CALL_OW 72
37149: PUSH
37150: EMPTY
37151: LIST
37152: LIST
37153: LIST
37154: LIST
37155: ST_TO_ADDR
// for j = 1 to 4 do
37156: LD_ADDR_VAR 0 3
37160: PUSH
37161: DOUBLE
37162: LD_INT 1
37164: DEC
37165: ST_TO_ADDR
37166: LD_INT 4
37168: PUSH
37169: FOR_TO
37170: IFFALSE 37361
// begin if not tmp [ j ] then
37172: LD_VAR 0 4
37176: PUSH
37177: LD_VAR 0 3
37181: ARRAY
37182: NOT
37183: IFFALSE 37187
// continue ;
37185: GO 37169
// for p in tmp [ j ] do
37187: LD_ADDR_VAR 0 5
37191: PUSH
37192: LD_VAR 0 4
37196: PUSH
37197: LD_VAR 0 3
37201: ARRAY
37202: PUSH
37203: FOR_IN
37204: IFFALSE 37357
// begin if not b [ j ] then
37206: LD_VAR 0 6
37210: PUSH
37211: LD_VAR 0 3
37215: ARRAY
37216: NOT
37217: IFFALSE 37221
// break ;
37219: GO 37357
// e := 0 ;
37221: LD_ADDR_VAR 0 7
37225: PUSH
37226: LD_INT 0
37228: ST_TO_ADDR
// for k in b [ j ] do
37229: LD_ADDR_VAR 0 8
37233: PUSH
37234: LD_VAR 0 6
37238: PUSH
37239: LD_VAR 0 3
37243: ARRAY
37244: PUSH
37245: FOR_IN
37246: IFFALSE 37273
// if IsNotFull ( k ) then
37248: LD_VAR 0 8
37252: PPUSH
37253: CALL 66017 0 1
37257: IFFALSE 37271
// begin e := k ;
37259: LD_ADDR_VAR 0 7
37263: PUSH
37264: LD_VAR 0 8
37268: ST_TO_ADDR
// break ;
37269: GO 37273
// end ;
37271: GO 37245
37273: POP
37274: POP
// if e and not UnitGoingToBuilding ( p , e ) then
37275: LD_VAR 0 7
37279: PUSH
37280: LD_VAR 0 5
37284: PPUSH
37285: LD_VAR 0 7
37289: PPUSH
37290: CALL 103005 0 2
37294: NOT
37295: AND
37296: IFFALSE 37355
// begin if IsInUnit ( p ) then
37298: LD_VAR 0 5
37302: PPUSH
37303: CALL_OW 310
37307: IFFALSE 37318
// ComExitBuilding ( p ) ;
37309: LD_VAR 0 5
37313: PPUSH
37314: CALL_OW 122
// ComEnterUnit ( p , e ) ;
37318: LD_VAR 0 5
37322: PPUSH
37323: LD_VAR 0 7
37327: PPUSH
37328: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
37332: LD_VAR 0 5
37336: PPUSH
37337: LD_VAR 0 3
37341: PPUSH
37342: CALL_OW 183
// AddComExitBuilding ( p ) ;
37346: LD_VAR 0 5
37350: PPUSH
37351: CALL_OW 182
// end ; end ;
37355: GO 37203
37357: POP
37358: POP
// end ;
37359: GO 37169
37361: POP
37362: POP
// end ;
37363: GO 36924
37365: POP
37366: POP
// end ;
37367: LD_VAR 0 1
37371: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
37372: LD_INT 0
37374: PPUSH
37375: PPUSH
37376: PPUSH
37377: PPUSH
37378: PPUSH
37379: PPUSH
37380: PPUSH
37381: PPUSH
37382: PPUSH
37383: PPUSH
37384: PPUSH
37385: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
37386: LD_VAR 0 1
37390: NOT
37391: PUSH
37392: LD_EXP 99
37396: PUSH
37397: LD_VAR 0 1
37401: ARRAY
37402: NOT
37403: OR
37404: PUSH
37405: LD_EXP 99
37409: PUSH
37410: LD_VAR 0 1
37414: ARRAY
37415: PPUSH
37416: LD_INT 2
37418: PUSH
37419: LD_INT 30
37421: PUSH
37422: LD_INT 0
37424: PUSH
37425: EMPTY
37426: LIST
37427: LIST
37428: PUSH
37429: LD_INT 30
37431: PUSH
37432: LD_INT 1
37434: PUSH
37435: EMPTY
37436: LIST
37437: LIST
37438: PUSH
37439: EMPTY
37440: LIST
37441: LIST
37442: LIST
37443: PPUSH
37444: CALL_OW 72
37448: NOT
37449: OR
37450: IFFALSE 37454
// exit ;
37452: GO 40948
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37454: LD_ADDR_VAR 0 4
37458: PUSH
37459: LD_EXP 99
37463: PUSH
37464: LD_VAR 0 1
37468: ARRAY
37469: PPUSH
37470: LD_INT 2
37472: PUSH
37473: LD_INT 25
37475: PUSH
37476: LD_INT 1
37478: PUSH
37479: EMPTY
37480: LIST
37481: LIST
37482: PUSH
37483: LD_INT 25
37485: PUSH
37486: LD_INT 2
37488: PUSH
37489: EMPTY
37490: LIST
37491: LIST
37492: PUSH
37493: LD_INT 25
37495: PUSH
37496: LD_INT 3
37498: PUSH
37499: EMPTY
37500: LIST
37501: LIST
37502: PUSH
37503: LD_INT 25
37505: PUSH
37506: LD_INT 4
37508: PUSH
37509: EMPTY
37510: LIST
37511: LIST
37512: PUSH
37513: LD_INT 25
37515: PUSH
37516: LD_INT 5
37518: PUSH
37519: EMPTY
37520: LIST
37521: LIST
37522: PUSH
37523: LD_INT 25
37525: PUSH
37526: LD_INT 8
37528: PUSH
37529: EMPTY
37530: LIST
37531: LIST
37532: PUSH
37533: LD_INT 25
37535: PUSH
37536: LD_INT 9
37538: PUSH
37539: EMPTY
37540: LIST
37541: LIST
37542: PUSH
37543: EMPTY
37544: LIST
37545: LIST
37546: LIST
37547: LIST
37548: LIST
37549: LIST
37550: LIST
37551: LIST
37552: PPUSH
37553: CALL_OW 72
37557: ST_TO_ADDR
// for i in tmp do
37558: LD_ADDR_VAR 0 3
37562: PUSH
37563: LD_VAR 0 4
37567: PUSH
37568: FOR_IN
37569: IFFALSE 37600
// if GetTag ( i ) then
37571: LD_VAR 0 3
37575: PPUSH
37576: CALL_OW 110
37580: IFFALSE 37598
// tmp := tmp diff i ;
37582: LD_ADDR_VAR 0 4
37586: PUSH
37587: LD_VAR 0 4
37591: PUSH
37592: LD_VAR 0 3
37596: DIFF
37597: ST_TO_ADDR
37598: GO 37568
37600: POP
37601: POP
// if not tmp then
37602: LD_VAR 0 4
37606: NOT
37607: IFFALSE 37611
// exit ;
37609: GO 40948
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37611: LD_ADDR_VAR 0 5
37615: PUSH
37616: LD_EXP 99
37620: PUSH
37621: LD_VAR 0 1
37625: ARRAY
37626: PPUSH
37627: LD_INT 2
37629: PUSH
37630: LD_INT 25
37632: PUSH
37633: LD_INT 1
37635: PUSH
37636: EMPTY
37637: LIST
37638: LIST
37639: PUSH
37640: LD_INT 25
37642: PUSH
37643: LD_INT 5
37645: PUSH
37646: EMPTY
37647: LIST
37648: LIST
37649: PUSH
37650: LD_INT 25
37652: PUSH
37653: LD_INT 8
37655: PUSH
37656: EMPTY
37657: LIST
37658: LIST
37659: PUSH
37660: LD_INT 25
37662: PUSH
37663: LD_INT 9
37665: PUSH
37666: EMPTY
37667: LIST
37668: LIST
37669: PUSH
37670: EMPTY
37671: LIST
37672: LIST
37673: LIST
37674: LIST
37675: LIST
37676: PPUSH
37677: CALL_OW 72
37681: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
37682: LD_ADDR_VAR 0 6
37686: PUSH
37687: LD_EXP 99
37691: PUSH
37692: LD_VAR 0 1
37696: ARRAY
37697: PPUSH
37698: LD_INT 25
37700: PUSH
37701: LD_INT 2
37703: PUSH
37704: EMPTY
37705: LIST
37706: LIST
37707: PPUSH
37708: CALL_OW 72
37712: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
37713: LD_ADDR_VAR 0 7
37717: PUSH
37718: LD_EXP 99
37722: PUSH
37723: LD_VAR 0 1
37727: ARRAY
37728: PPUSH
37729: LD_INT 25
37731: PUSH
37732: LD_INT 3
37734: PUSH
37735: EMPTY
37736: LIST
37737: LIST
37738: PPUSH
37739: CALL_OW 72
37743: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
37744: LD_ADDR_VAR 0 8
37748: PUSH
37749: LD_EXP 99
37753: PUSH
37754: LD_VAR 0 1
37758: ARRAY
37759: PPUSH
37760: LD_INT 25
37762: PUSH
37763: LD_INT 4
37765: PUSH
37766: EMPTY
37767: LIST
37768: LIST
37769: PUSH
37770: LD_INT 24
37772: PUSH
37773: LD_INT 251
37775: PUSH
37776: EMPTY
37777: LIST
37778: LIST
37779: PUSH
37780: EMPTY
37781: LIST
37782: LIST
37783: PPUSH
37784: CALL_OW 72
37788: ST_TO_ADDR
// if mc_scan [ base ] then
37789: LD_EXP 122
37793: PUSH
37794: LD_VAR 0 1
37798: ARRAY
37799: IFFALSE 38260
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
37801: LD_ADDR_EXP 141
37805: PUSH
37806: LD_EXP 141
37810: PPUSH
37811: LD_VAR 0 1
37815: PPUSH
37816: LD_INT 4
37818: PPUSH
37819: CALL_OW 1
37823: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
37824: LD_ADDR_VAR 0 12
37828: PUSH
37829: LD_EXP 99
37833: PUSH
37834: LD_VAR 0 1
37838: ARRAY
37839: PPUSH
37840: LD_INT 2
37842: PUSH
37843: LD_INT 30
37845: PUSH
37846: LD_INT 4
37848: PUSH
37849: EMPTY
37850: LIST
37851: LIST
37852: PUSH
37853: LD_INT 30
37855: PUSH
37856: LD_INT 5
37858: PUSH
37859: EMPTY
37860: LIST
37861: LIST
37862: PUSH
37863: EMPTY
37864: LIST
37865: LIST
37866: LIST
37867: PPUSH
37868: CALL_OW 72
37872: ST_TO_ADDR
// if not b then
37873: LD_VAR 0 12
37877: NOT
37878: IFFALSE 37882
// exit ;
37880: GO 40948
// p := [ ] ;
37882: LD_ADDR_VAR 0 11
37886: PUSH
37887: EMPTY
37888: ST_TO_ADDR
// if sci >= 2 then
37889: LD_VAR 0 8
37893: PUSH
37894: LD_INT 2
37896: GREATEREQUAL
37897: IFFALSE 37928
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
37899: LD_ADDR_VAR 0 8
37903: PUSH
37904: LD_VAR 0 8
37908: PUSH
37909: LD_INT 1
37911: ARRAY
37912: PUSH
37913: LD_VAR 0 8
37917: PUSH
37918: LD_INT 2
37920: ARRAY
37921: PUSH
37922: EMPTY
37923: LIST
37924: LIST
37925: ST_TO_ADDR
37926: GO 37989
// if sci = 1 then
37928: LD_VAR 0 8
37932: PUSH
37933: LD_INT 1
37935: EQUAL
37936: IFFALSE 37957
// sci := [ sci [ 1 ] ] else
37938: LD_ADDR_VAR 0 8
37942: PUSH
37943: LD_VAR 0 8
37947: PUSH
37948: LD_INT 1
37950: ARRAY
37951: PUSH
37952: EMPTY
37953: LIST
37954: ST_TO_ADDR
37955: GO 37989
// if sci = 0 then
37957: LD_VAR 0 8
37961: PUSH
37962: LD_INT 0
37964: EQUAL
37965: IFFALSE 37989
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
37967: LD_ADDR_VAR 0 11
37971: PUSH
37972: LD_VAR 0 4
37976: PPUSH
37977: LD_INT 4
37979: PPUSH
37980: CALL 102868 0 2
37984: PUSH
37985: LD_INT 1
37987: ARRAY
37988: ST_TO_ADDR
// if eng > 4 then
37989: LD_VAR 0 6
37993: PUSH
37994: LD_INT 4
37996: GREATER
37997: IFFALSE 38043
// for i = eng downto 4 do
37999: LD_ADDR_VAR 0 3
38003: PUSH
38004: DOUBLE
38005: LD_VAR 0 6
38009: INC
38010: ST_TO_ADDR
38011: LD_INT 4
38013: PUSH
38014: FOR_DOWNTO
38015: IFFALSE 38041
// eng := eng diff eng [ i ] ;
38017: LD_ADDR_VAR 0 6
38021: PUSH
38022: LD_VAR 0 6
38026: PUSH
38027: LD_VAR 0 6
38031: PUSH
38032: LD_VAR 0 3
38036: ARRAY
38037: DIFF
38038: ST_TO_ADDR
38039: GO 38014
38041: POP
38042: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
38043: LD_ADDR_VAR 0 4
38047: PUSH
38048: LD_VAR 0 4
38052: PUSH
38053: LD_VAR 0 5
38057: PUSH
38058: LD_VAR 0 6
38062: UNION
38063: PUSH
38064: LD_VAR 0 7
38068: UNION
38069: PUSH
38070: LD_VAR 0 8
38074: UNION
38075: DIFF
38076: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
38077: LD_ADDR_VAR 0 13
38081: PUSH
38082: LD_EXP 99
38086: PUSH
38087: LD_VAR 0 1
38091: ARRAY
38092: PPUSH
38093: LD_INT 2
38095: PUSH
38096: LD_INT 30
38098: PUSH
38099: LD_INT 32
38101: PUSH
38102: EMPTY
38103: LIST
38104: LIST
38105: PUSH
38106: LD_INT 30
38108: PUSH
38109: LD_INT 31
38111: PUSH
38112: EMPTY
38113: LIST
38114: LIST
38115: PUSH
38116: EMPTY
38117: LIST
38118: LIST
38119: LIST
38120: PPUSH
38121: CALL_OW 72
38125: PUSH
38126: LD_EXP 99
38130: PUSH
38131: LD_VAR 0 1
38135: ARRAY
38136: PPUSH
38137: LD_INT 2
38139: PUSH
38140: LD_INT 30
38142: PUSH
38143: LD_INT 4
38145: PUSH
38146: EMPTY
38147: LIST
38148: LIST
38149: PUSH
38150: LD_INT 30
38152: PUSH
38153: LD_INT 5
38155: PUSH
38156: EMPTY
38157: LIST
38158: LIST
38159: PUSH
38160: EMPTY
38161: LIST
38162: LIST
38163: LIST
38164: PPUSH
38165: CALL_OW 72
38169: PUSH
38170: LD_INT 6
38172: MUL
38173: PLUS
38174: ST_TO_ADDR
// if bcount < tmp then
38175: LD_VAR 0 13
38179: PUSH
38180: LD_VAR 0 4
38184: LESS
38185: IFFALSE 38231
// for i = tmp downto bcount do
38187: LD_ADDR_VAR 0 3
38191: PUSH
38192: DOUBLE
38193: LD_VAR 0 4
38197: INC
38198: ST_TO_ADDR
38199: LD_VAR 0 13
38203: PUSH
38204: FOR_DOWNTO
38205: IFFALSE 38229
// tmp := Delete ( tmp , tmp ) ;
38207: LD_ADDR_VAR 0 4
38211: PUSH
38212: LD_VAR 0 4
38216: PPUSH
38217: LD_VAR 0 4
38221: PPUSH
38222: CALL_OW 3
38226: ST_TO_ADDR
38227: GO 38204
38229: POP
38230: POP
// result := [ tmp , 0 , 0 , p ] ;
38231: LD_ADDR_VAR 0 2
38235: PUSH
38236: LD_VAR 0 4
38240: PUSH
38241: LD_INT 0
38243: PUSH
38244: LD_INT 0
38246: PUSH
38247: LD_VAR 0 11
38251: PUSH
38252: EMPTY
38253: LIST
38254: LIST
38255: LIST
38256: LIST
38257: ST_TO_ADDR
// exit ;
38258: GO 40948
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
38260: LD_EXP 99
38264: PUSH
38265: LD_VAR 0 1
38269: ARRAY
38270: PPUSH
38271: LD_INT 2
38273: PUSH
38274: LD_INT 30
38276: PUSH
38277: LD_INT 6
38279: PUSH
38280: EMPTY
38281: LIST
38282: LIST
38283: PUSH
38284: LD_INT 30
38286: PUSH
38287: LD_INT 7
38289: PUSH
38290: EMPTY
38291: LIST
38292: LIST
38293: PUSH
38294: LD_INT 30
38296: PUSH
38297: LD_INT 8
38299: PUSH
38300: EMPTY
38301: LIST
38302: LIST
38303: PUSH
38304: EMPTY
38305: LIST
38306: LIST
38307: LIST
38308: LIST
38309: PPUSH
38310: CALL_OW 72
38314: NOT
38315: PUSH
38316: LD_EXP 99
38320: PUSH
38321: LD_VAR 0 1
38325: ARRAY
38326: PPUSH
38327: LD_INT 30
38329: PUSH
38330: LD_INT 3
38332: PUSH
38333: EMPTY
38334: LIST
38335: LIST
38336: PPUSH
38337: CALL_OW 72
38341: NOT
38342: AND
38343: IFFALSE 38415
// begin if eng = tmp then
38345: LD_VAR 0 6
38349: PUSH
38350: LD_VAR 0 4
38354: EQUAL
38355: IFFALSE 38359
// exit ;
38357: GO 40948
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
38359: LD_ADDR_EXP 141
38363: PUSH
38364: LD_EXP 141
38368: PPUSH
38369: LD_VAR 0 1
38373: PPUSH
38374: LD_INT 1
38376: PPUSH
38377: CALL_OW 1
38381: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
38382: LD_ADDR_VAR 0 2
38386: PUSH
38387: LD_INT 0
38389: PUSH
38390: LD_VAR 0 4
38394: PUSH
38395: LD_VAR 0 6
38399: DIFF
38400: PUSH
38401: LD_INT 0
38403: PUSH
38404: LD_INT 0
38406: PUSH
38407: EMPTY
38408: LIST
38409: LIST
38410: LIST
38411: LIST
38412: ST_TO_ADDR
// exit ;
38413: GO 40948
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
38415: LD_EXP 126
38419: PUSH
38420: LD_EXP 125
38424: PUSH
38425: LD_VAR 0 1
38429: ARRAY
38430: ARRAY
38431: PUSH
38432: LD_EXP 99
38436: PUSH
38437: LD_VAR 0 1
38441: ARRAY
38442: PPUSH
38443: LD_INT 2
38445: PUSH
38446: LD_INT 30
38448: PUSH
38449: LD_INT 6
38451: PUSH
38452: EMPTY
38453: LIST
38454: LIST
38455: PUSH
38456: LD_INT 30
38458: PUSH
38459: LD_INT 7
38461: PUSH
38462: EMPTY
38463: LIST
38464: LIST
38465: PUSH
38466: LD_INT 30
38468: PUSH
38469: LD_INT 8
38471: PUSH
38472: EMPTY
38473: LIST
38474: LIST
38475: PUSH
38476: EMPTY
38477: LIST
38478: LIST
38479: LIST
38480: LIST
38481: PPUSH
38482: CALL_OW 72
38486: AND
38487: PUSH
38488: LD_EXP 99
38492: PUSH
38493: LD_VAR 0 1
38497: ARRAY
38498: PPUSH
38499: LD_INT 30
38501: PUSH
38502: LD_INT 3
38504: PUSH
38505: EMPTY
38506: LIST
38507: LIST
38508: PPUSH
38509: CALL_OW 72
38513: NOT
38514: AND
38515: IFFALSE 38729
// begin if sci >= 6 then
38517: LD_VAR 0 8
38521: PUSH
38522: LD_INT 6
38524: GREATEREQUAL
38525: IFFALSE 38529
// exit ;
38527: GO 40948
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
38529: LD_ADDR_EXP 141
38533: PUSH
38534: LD_EXP 141
38538: PPUSH
38539: LD_VAR 0 1
38543: PPUSH
38544: LD_INT 2
38546: PPUSH
38547: CALL_OW 1
38551: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
38552: LD_ADDR_VAR 0 9
38556: PUSH
38557: LD_VAR 0 4
38561: PUSH
38562: LD_VAR 0 8
38566: DIFF
38567: PPUSH
38568: LD_INT 4
38570: PPUSH
38571: CALL 102868 0 2
38575: ST_TO_ADDR
// p := [ ] ;
38576: LD_ADDR_VAR 0 11
38580: PUSH
38581: EMPTY
38582: ST_TO_ADDR
// if sci < 6 and sort > 6 then
38583: LD_VAR 0 8
38587: PUSH
38588: LD_INT 6
38590: LESS
38591: PUSH
38592: LD_VAR 0 9
38596: PUSH
38597: LD_INT 6
38599: GREATER
38600: AND
38601: IFFALSE 38682
// begin for i = 1 to 6 - sci do
38603: LD_ADDR_VAR 0 3
38607: PUSH
38608: DOUBLE
38609: LD_INT 1
38611: DEC
38612: ST_TO_ADDR
38613: LD_INT 6
38615: PUSH
38616: LD_VAR 0 8
38620: MINUS
38621: PUSH
38622: FOR_TO
38623: IFFALSE 38678
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
38625: LD_ADDR_VAR 0 11
38629: PUSH
38630: LD_VAR 0 11
38634: PPUSH
38635: LD_VAR 0 11
38639: PUSH
38640: LD_INT 1
38642: PLUS
38643: PPUSH
38644: LD_VAR 0 9
38648: PUSH
38649: LD_INT 1
38651: ARRAY
38652: PPUSH
38653: CALL_OW 2
38657: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
38658: LD_ADDR_VAR 0 9
38662: PUSH
38663: LD_VAR 0 9
38667: PPUSH
38668: LD_INT 1
38670: PPUSH
38671: CALL_OW 3
38675: ST_TO_ADDR
// end ;
38676: GO 38622
38678: POP
38679: POP
// end else
38680: GO 38702
// if sort then
38682: LD_VAR 0 9
38686: IFFALSE 38702
// p := sort [ 1 ] ;
38688: LD_ADDR_VAR 0 11
38692: PUSH
38693: LD_VAR 0 9
38697: PUSH
38698: LD_INT 1
38700: ARRAY
38701: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
38702: LD_ADDR_VAR 0 2
38706: PUSH
38707: LD_INT 0
38709: PUSH
38710: LD_INT 0
38712: PUSH
38713: LD_INT 0
38715: PUSH
38716: LD_VAR 0 11
38720: PUSH
38721: EMPTY
38722: LIST
38723: LIST
38724: LIST
38725: LIST
38726: ST_TO_ADDR
// exit ;
38727: GO 40948
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
38729: LD_EXP 126
38733: PUSH
38734: LD_EXP 125
38738: PUSH
38739: LD_VAR 0 1
38743: ARRAY
38744: ARRAY
38745: PUSH
38746: LD_EXP 99
38750: PUSH
38751: LD_VAR 0 1
38755: ARRAY
38756: PPUSH
38757: LD_INT 2
38759: PUSH
38760: LD_INT 30
38762: PUSH
38763: LD_INT 6
38765: PUSH
38766: EMPTY
38767: LIST
38768: LIST
38769: PUSH
38770: LD_INT 30
38772: PUSH
38773: LD_INT 7
38775: PUSH
38776: EMPTY
38777: LIST
38778: LIST
38779: PUSH
38780: LD_INT 30
38782: PUSH
38783: LD_INT 8
38785: PUSH
38786: EMPTY
38787: LIST
38788: LIST
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: LIST
38794: LIST
38795: PPUSH
38796: CALL_OW 72
38800: AND
38801: PUSH
38802: LD_EXP 99
38806: PUSH
38807: LD_VAR 0 1
38811: ARRAY
38812: PPUSH
38813: LD_INT 30
38815: PUSH
38816: LD_INT 3
38818: PUSH
38819: EMPTY
38820: LIST
38821: LIST
38822: PPUSH
38823: CALL_OW 72
38827: AND
38828: IFFALSE 39562
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
38830: LD_ADDR_EXP 141
38834: PUSH
38835: LD_EXP 141
38839: PPUSH
38840: LD_VAR 0 1
38844: PPUSH
38845: LD_INT 3
38847: PPUSH
38848: CALL_OW 1
38852: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
38853: LD_ADDR_VAR 0 2
38857: PUSH
38858: LD_INT 0
38860: PUSH
38861: LD_INT 0
38863: PUSH
38864: LD_INT 0
38866: PUSH
38867: LD_INT 0
38869: PUSH
38870: EMPTY
38871: LIST
38872: LIST
38873: LIST
38874: LIST
38875: ST_TO_ADDR
// if not eng then
38876: LD_VAR 0 6
38880: NOT
38881: IFFALSE 38944
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
38883: LD_ADDR_VAR 0 11
38887: PUSH
38888: LD_VAR 0 4
38892: PPUSH
38893: LD_INT 2
38895: PPUSH
38896: CALL 102868 0 2
38900: PUSH
38901: LD_INT 1
38903: ARRAY
38904: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
38905: LD_ADDR_VAR 0 2
38909: PUSH
38910: LD_VAR 0 2
38914: PPUSH
38915: LD_INT 2
38917: PPUSH
38918: LD_VAR 0 11
38922: PPUSH
38923: CALL_OW 1
38927: ST_TO_ADDR
// tmp := tmp diff p ;
38928: LD_ADDR_VAR 0 4
38932: PUSH
38933: LD_VAR 0 4
38937: PUSH
38938: LD_VAR 0 11
38942: DIFF
38943: ST_TO_ADDR
// end ; if tmp and sci < 6 then
38944: LD_VAR 0 4
38948: PUSH
38949: LD_VAR 0 8
38953: PUSH
38954: LD_INT 6
38956: LESS
38957: AND
38958: IFFALSE 39146
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
38960: LD_ADDR_VAR 0 9
38964: PUSH
38965: LD_VAR 0 4
38969: PUSH
38970: LD_VAR 0 8
38974: PUSH
38975: LD_VAR 0 7
38979: UNION
38980: DIFF
38981: PPUSH
38982: LD_INT 4
38984: PPUSH
38985: CALL 102868 0 2
38989: ST_TO_ADDR
// p := [ ] ;
38990: LD_ADDR_VAR 0 11
38994: PUSH
38995: EMPTY
38996: ST_TO_ADDR
// if sort then
38997: LD_VAR 0 9
39001: IFFALSE 39117
// for i = 1 to 6 - sci do
39003: LD_ADDR_VAR 0 3
39007: PUSH
39008: DOUBLE
39009: LD_INT 1
39011: DEC
39012: ST_TO_ADDR
39013: LD_INT 6
39015: PUSH
39016: LD_VAR 0 8
39020: MINUS
39021: PUSH
39022: FOR_TO
39023: IFFALSE 39115
// begin if i = sort then
39025: LD_VAR 0 3
39029: PUSH
39030: LD_VAR 0 9
39034: EQUAL
39035: IFFALSE 39039
// break ;
39037: GO 39115
// if GetClass ( i ) = 4 then
39039: LD_VAR 0 3
39043: PPUSH
39044: CALL_OW 257
39048: PUSH
39049: LD_INT 4
39051: EQUAL
39052: IFFALSE 39056
// continue ;
39054: GO 39022
// p := Insert ( p , p + 1 , sort [ i ] ) ;
39056: LD_ADDR_VAR 0 11
39060: PUSH
39061: LD_VAR 0 11
39065: PPUSH
39066: LD_VAR 0 11
39070: PUSH
39071: LD_INT 1
39073: PLUS
39074: PPUSH
39075: LD_VAR 0 9
39079: PUSH
39080: LD_VAR 0 3
39084: ARRAY
39085: PPUSH
39086: CALL_OW 2
39090: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
39091: LD_ADDR_VAR 0 4
39095: PUSH
39096: LD_VAR 0 4
39100: PUSH
39101: LD_VAR 0 9
39105: PUSH
39106: LD_VAR 0 3
39110: ARRAY
39111: DIFF
39112: ST_TO_ADDR
// end ;
39113: GO 39022
39115: POP
39116: POP
// if p then
39117: LD_VAR 0 11
39121: IFFALSE 39146
// result := Replace ( result , 4 , p ) ;
39123: LD_ADDR_VAR 0 2
39127: PUSH
39128: LD_VAR 0 2
39132: PPUSH
39133: LD_INT 4
39135: PPUSH
39136: LD_VAR 0 11
39140: PPUSH
39141: CALL_OW 1
39145: ST_TO_ADDR
// end ; if tmp and mech < 6 then
39146: LD_VAR 0 4
39150: PUSH
39151: LD_VAR 0 7
39155: PUSH
39156: LD_INT 6
39158: LESS
39159: AND
39160: IFFALSE 39348
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
39162: LD_ADDR_VAR 0 9
39166: PUSH
39167: LD_VAR 0 4
39171: PUSH
39172: LD_VAR 0 8
39176: PUSH
39177: LD_VAR 0 7
39181: UNION
39182: DIFF
39183: PPUSH
39184: LD_INT 3
39186: PPUSH
39187: CALL 102868 0 2
39191: ST_TO_ADDR
// p := [ ] ;
39192: LD_ADDR_VAR 0 11
39196: PUSH
39197: EMPTY
39198: ST_TO_ADDR
// if sort then
39199: LD_VAR 0 9
39203: IFFALSE 39319
// for i = 1 to 6 - mech do
39205: LD_ADDR_VAR 0 3
39209: PUSH
39210: DOUBLE
39211: LD_INT 1
39213: DEC
39214: ST_TO_ADDR
39215: LD_INT 6
39217: PUSH
39218: LD_VAR 0 7
39222: MINUS
39223: PUSH
39224: FOR_TO
39225: IFFALSE 39317
// begin if i = sort then
39227: LD_VAR 0 3
39231: PUSH
39232: LD_VAR 0 9
39236: EQUAL
39237: IFFALSE 39241
// break ;
39239: GO 39317
// if GetClass ( i ) = 3 then
39241: LD_VAR 0 3
39245: PPUSH
39246: CALL_OW 257
39250: PUSH
39251: LD_INT 3
39253: EQUAL
39254: IFFALSE 39258
// continue ;
39256: GO 39224
// p := Insert ( p , p + 1 , sort [ i ] ) ;
39258: LD_ADDR_VAR 0 11
39262: PUSH
39263: LD_VAR 0 11
39267: PPUSH
39268: LD_VAR 0 11
39272: PUSH
39273: LD_INT 1
39275: PLUS
39276: PPUSH
39277: LD_VAR 0 9
39281: PUSH
39282: LD_VAR 0 3
39286: ARRAY
39287: PPUSH
39288: CALL_OW 2
39292: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
39293: LD_ADDR_VAR 0 4
39297: PUSH
39298: LD_VAR 0 4
39302: PUSH
39303: LD_VAR 0 9
39307: PUSH
39308: LD_VAR 0 3
39312: ARRAY
39313: DIFF
39314: ST_TO_ADDR
// end ;
39315: GO 39224
39317: POP
39318: POP
// if p then
39319: LD_VAR 0 11
39323: IFFALSE 39348
// result := Replace ( result , 3 , p ) ;
39325: LD_ADDR_VAR 0 2
39329: PUSH
39330: LD_VAR 0 2
39334: PPUSH
39335: LD_INT 3
39337: PPUSH
39338: LD_VAR 0 11
39342: PPUSH
39343: CALL_OW 1
39347: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
39348: LD_VAR 0 4
39352: PUSH
39353: LD_INT 6
39355: GREATER
39356: PUSH
39357: LD_VAR 0 6
39361: PUSH
39362: LD_INT 6
39364: LESS
39365: AND
39366: IFFALSE 39560
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
39368: LD_ADDR_VAR 0 9
39372: PUSH
39373: LD_VAR 0 4
39377: PUSH
39378: LD_VAR 0 8
39382: PUSH
39383: LD_VAR 0 7
39387: UNION
39388: PUSH
39389: LD_VAR 0 6
39393: UNION
39394: DIFF
39395: PPUSH
39396: LD_INT 2
39398: PPUSH
39399: CALL 102868 0 2
39403: ST_TO_ADDR
// p := [ ] ;
39404: LD_ADDR_VAR 0 11
39408: PUSH
39409: EMPTY
39410: ST_TO_ADDR
// if sort then
39411: LD_VAR 0 9
39415: IFFALSE 39531
// for i = 1 to 6 - eng do
39417: LD_ADDR_VAR 0 3
39421: PUSH
39422: DOUBLE
39423: LD_INT 1
39425: DEC
39426: ST_TO_ADDR
39427: LD_INT 6
39429: PUSH
39430: LD_VAR 0 6
39434: MINUS
39435: PUSH
39436: FOR_TO
39437: IFFALSE 39529
// begin if i = sort then
39439: LD_VAR 0 3
39443: PUSH
39444: LD_VAR 0 9
39448: EQUAL
39449: IFFALSE 39453
// break ;
39451: GO 39529
// if GetClass ( i ) = 2 then
39453: LD_VAR 0 3
39457: PPUSH
39458: CALL_OW 257
39462: PUSH
39463: LD_INT 2
39465: EQUAL
39466: IFFALSE 39470
// continue ;
39468: GO 39436
// p := Insert ( p , p + 1 , sort [ i ] ) ;
39470: LD_ADDR_VAR 0 11
39474: PUSH
39475: LD_VAR 0 11
39479: PPUSH
39480: LD_VAR 0 11
39484: PUSH
39485: LD_INT 1
39487: PLUS
39488: PPUSH
39489: LD_VAR 0 9
39493: PUSH
39494: LD_VAR 0 3
39498: ARRAY
39499: PPUSH
39500: CALL_OW 2
39504: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
39505: LD_ADDR_VAR 0 4
39509: PUSH
39510: LD_VAR 0 4
39514: PUSH
39515: LD_VAR 0 9
39519: PUSH
39520: LD_VAR 0 3
39524: ARRAY
39525: DIFF
39526: ST_TO_ADDR
// end ;
39527: GO 39436
39529: POP
39530: POP
// if p then
39531: LD_VAR 0 11
39535: IFFALSE 39560
// result := Replace ( result , 2 , p ) ;
39537: LD_ADDR_VAR 0 2
39541: PUSH
39542: LD_VAR 0 2
39546: PPUSH
39547: LD_INT 2
39549: PPUSH
39550: LD_VAR 0 11
39554: PPUSH
39555: CALL_OW 1
39559: ST_TO_ADDR
// end ; exit ;
39560: GO 40948
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
39562: LD_EXP 126
39566: PUSH
39567: LD_EXP 125
39571: PUSH
39572: LD_VAR 0 1
39576: ARRAY
39577: ARRAY
39578: NOT
39579: PUSH
39580: LD_EXP 99
39584: PUSH
39585: LD_VAR 0 1
39589: ARRAY
39590: PPUSH
39591: LD_INT 30
39593: PUSH
39594: LD_INT 3
39596: PUSH
39597: EMPTY
39598: LIST
39599: LIST
39600: PPUSH
39601: CALL_OW 72
39605: AND
39606: PUSH
39607: LD_EXP 104
39611: PUSH
39612: LD_VAR 0 1
39616: ARRAY
39617: AND
39618: IFFALSE 40226
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
39620: LD_ADDR_EXP 141
39624: PUSH
39625: LD_EXP 141
39629: PPUSH
39630: LD_VAR 0 1
39634: PPUSH
39635: LD_INT 5
39637: PPUSH
39638: CALL_OW 1
39642: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
39643: LD_ADDR_VAR 0 2
39647: PUSH
39648: LD_INT 0
39650: PUSH
39651: LD_INT 0
39653: PUSH
39654: LD_INT 0
39656: PUSH
39657: LD_INT 0
39659: PUSH
39660: EMPTY
39661: LIST
39662: LIST
39663: LIST
39664: LIST
39665: ST_TO_ADDR
// if sci > 1 then
39666: LD_VAR 0 8
39670: PUSH
39671: LD_INT 1
39673: GREATER
39674: IFFALSE 39702
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
39676: LD_ADDR_VAR 0 4
39680: PUSH
39681: LD_VAR 0 4
39685: PUSH
39686: LD_VAR 0 8
39690: PUSH
39691: LD_VAR 0 8
39695: PUSH
39696: LD_INT 1
39698: ARRAY
39699: DIFF
39700: DIFF
39701: ST_TO_ADDR
// if tmp and not sci then
39702: LD_VAR 0 4
39706: PUSH
39707: LD_VAR 0 8
39711: NOT
39712: AND
39713: IFFALSE 39782
// begin sort := SortBySkill ( tmp , 4 ) ;
39715: LD_ADDR_VAR 0 9
39719: PUSH
39720: LD_VAR 0 4
39724: PPUSH
39725: LD_INT 4
39727: PPUSH
39728: CALL 102868 0 2
39732: ST_TO_ADDR
// if sort then
39733: LD_VAR 0 9
39737: IFFALSE 39753
// p := sort [ 1 ] ;
39739: LD_ADDR_VAR 0 11
39743: PUSH
39744: LD_VAR 0 9
39748: PUSH
39749: LD_INT 1
39751: ARRAY
39752: ST_TO_ADDR
// if p then
39753: LD_VAR 0 11
39757: IFFALSE 39782
// result := Replace ( result , 4 , p ) ;
39759: LD_ADDR_VAR 0 2
39763: PUSH
39764: LD_VAR 0 2
39768: PPUSH
39769: LD_INT 4
39771: PPUSH
39772: LD_VAR 0 11
39776: PPUSH
39777: CALL_OW 1
39781: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
39782: LD_ADDR_VAR 0 4
39786: PUSH
39787: LD_VAR 0 4
39791: PUSH
39792: LD_VAR 0 7
39796: DIFF
39797: ST_TO_ADDR
// if tmp and mech < 6 then
39798: LD_VAR 0 4
39802: PUSH
39803: LD_VAR 0 7
39807: PUSH
39808: LD_INT 6
39810: LESS
39811: AND
39812: IFFALSE 40000
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
39814: LD_ADDR_VAR 0 9
39818: PUSH
39819: LD_VAR 0 4
39823: PUSH
39824: LD_VAR 0 8
39828: PUSH
39829: LD_VAR 0 7
39833: UNION
39834: DIFF
39835: PPUSH
39836: LD_INT 3
39838: PPUSH
39839: CALL 102868 0 2
39843: ST_TO_ADDR
// p := [ ] ;
39844: LD_ADDR_VAR 0 11
39848: PUSH
39849: EMPTY
39850: ST_TO_ADDR
// if sort then
39851: LD_VAR 0 9
39855: IFFALSE 39971
// for i = 1 to 6 - mech do
39857: LD_ADDR_VAR 0 3
39861: PUSH
39862: DOUBLE
39863: LD_INT 1
39865: DEC
39866: ST_TO_ADDR
39867: LD_INT 6
39869: PUSH
39870: LD_VAR 0 7
39874: MINUS
39875: PUSH
39876: FOR_TO
39877: IFFALSE 39969
// begin if i = sort then
39879: LD_VAR 0 3
39883: PUSH
39884: LD_VAR 0 9
39888: EQUAL
39889: IFFALSE 39893
// break ;
39891: GO 39969
// if GetClass ( i ) = 3 then
39893: LD_VAR 0 3
39897: PPUSH
39898: CALL_OW 257
39902: PUSH
39903: LD_INT 3
39905: EQUAL
39906: IFFALSE 39910
// continue ;
39908: GO 39876
// p := Insert ( p , p + 1 , sort [ i ] ) ;
39910: LD_ADDR_VAR 0 11
39914: PUSH
39915: LD_VAR 0 11
39919: PPUSH
39920: LD_VAR 0 11
39924: PUSH
39925: LD_INT 1
39927: PLUS
39928: PPUSH
39929: LD_VAR 0 9
39933: PUSH
39934: LD_VAR 0 3
39938: ARRAY
39939: PPUSH
39940: CALL_OW 2
39944: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
39945: LD_ADDR_VAR 0 4
39949: PUSH
39950: LD_VAR 0 4
39954: PUSH
39955: LD_VAR 0 9
39959: PUSH
39960: LD_VAR 0 3
39964: ARRAY
39965: DIFF
39966: ST_TO_ADDR
// end ;
39967: GO 39876
39969: POP
39970: POP
// if p then
39971: LD_VAR 0 11
39975: IFFALSE 40000
// result := Replace ( result , 3 , p ) ;
39977: LD_ADDR_VAR 0 2
39981: PUSH
39982: LD_VAR 0 2
39986: PPUSH
39987: LD_INT 3
39989: PPUSH
39990: LD_VAR 0 11
39994: PPUSH
39995: CALL_OW 1
39999: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
40000: LD_ADDR_VAR 0 4
40004: PUSH
40005: LD_VAR 0 4
40009: PUSH
40010: LD_VAR 0 6
40014: DIFF
40015: ST_TO_ADDR
// if tmp and eng < 6 then
40016: LD_VAR 0 4
40020: PUSH
40021: LD_VAR 0 6
40025: PUSH
40026: LD_INT 6
40028: LESS
40029: AND
40030: IFFALSE 40224
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
40032: LD_ADDR_VAR 0 9
40036: PUSH
40037: LD_VAR 0 4
40041: PUSH
40042: LD_VAR 0 8
40046: PUSH
40047: LD_VAR 0 7
40051: UNION
40052: PUSH
40053: LD_VAR 0 6
40057: UNION
40058: DIFF
40059: PPUSH
40060: LD_INT 2
40062: PPUSH
40063: CALL 102868 0 2
40067: ST_TO_ADDR
// p := [ ] ;
40068: LD_ADDR_VAR 0 11
40072: PUSH
40073: EMPTY
40074: ST_TO_ADDR
// if sort then
40075: LD_VAR 0 9
40079: IFFALSE 40195
// for i = 1 to 6 - eng do
40081: LD_ADDR_VAR 0 3
40085: PUSH
40086: DOUBLE
40087: LD_INT 1
40089: DEC
40090: ST_TO_ADDR
40091: LD_INT 6
40093: PUSH
40094: LD_VAR 0 6
40098: MINUS
40099: PUSH
40100: FOR_TO
40101: IFFALSE 40193
// begin if i = sort then
40103: LD_VAR 0 3
40107: PUSH
40108: LD_VAR 0 9
40112: EQUAL
40113: IFFALSE 40117
// break ;
40115: GO 40193
// if GetClass ( i ) = 2 then
40117: LD_VAR 0 3
40121: PPUSH
40122: CALL_OW 257
40126: PUSH
40127: LD_INT 2
40129: EQUAL
40130: IFFALSE 40134
// continue ;
40132: GO 40100
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40134: LD_ADDR_VAR 0 11
40138: PUSH
40139: LD_VAR 0 11
40143: PPUSH
40144: LD_VAR 0 11
40148: PUSH
40149: LD_INT 1
40151: PLUS
40152: PPUSH
40153: LD_VAR 0 9
40157: PUSH
40158: LD_VAR 0 3
40162: ARRAY
40163: PPUSH
40164: CALL_OW 2
40168: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40169: LD_ADDR_VAR 0 4
40173: PUSH
40174: LD_VAR 0 4
40178: PUSH
40179: LD_VAR 0 9
40183: PUSH
40184: LD_VAR 0 3
40188: ARRAY
40189: DIFF
40190: ST_TO_ADDR
// end ;
40191: GO 40100
40193: POP
40194: POP
// if p then
40195: LD_VAR 0 11
40199: IFFALSE 40224
// result := Replace ( result , 2 , p ) ;
40201: LD_ADDR_VAR 0 2
40205: PUSH
40206: LD_VAR 0 2
40210: PPUSH
40211: LD_INT 2
40213: PPUSH
40214: LD_VAR 0 11
40218: PPUSH
40219: CALL_OW 1
40223: ST_TO_ADDR
// end ; exit ;
40224: GO 40948
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
40226: LD_EXP 126
40230: PUSH
40231: LD_EXP 125
40235: PUSH
40236: LD_VAR 0 1
40240: ARRAY
40241: ARRAY
40242: NOT
40243: PUSH
40244: LD_EXP 99
40248: PUSH
40249: LD_VAR 0 1
40253: ARRAY
40254: PPUSH
40255: LD_INT 30
40257: PUSH
40258: LD_INT 3
40260: PUSH
40261: EMPTY
40262: LIST
40263: LIST
40264: PPUSH
40265: CALL_OW 72
40269: AND
40270: PUSH
40271: LD_EXP 104
40275: PUSH
40276: LD_VAR 0 1
40280: ARRAY
40281: NOT
40282: AND
40283: IFFALSE 40948
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
40285: LD_ADDR_EXP 141
40289: PUSH
40290: LD_EXP 141
40294: PPUSH
40295: LD_VAR 0 1
40299: PPUSH
40300: LD_INT 6
40302: PPUSH
40303: CALL_OW 1
40307: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40308: LD_ADDR_VAR 0 2
40312: PUSH
40313: LD_INT 0
40315: PUSH
40316: LD_INT 0
40318: PUSH
40319: LD_INT 0
40321: PUSH
40322: LD_INT 0
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: LIST
40329: LIST
40330: ST_TO_ADDR
// if sci >= 1 then
40331: LD_VAR 0 8
40335: PUSH
40336: LD_INT 1
40338: GREATEREQUAL
40339: IFFALSE 40361
// tmp := tmp diff sci [ 1 ] ;
40341: LD_ADDR_VAR 0 4
40345: PUSH
40346: LD_VAR 0 4
40350: PUSH
40351: LD_VAR 0 8
40355: PUSH
40356: LD_INT 1
40358: ARRAY
40359: DIFF
40360: ST_TO_ADDR
// if tmp and not sci then
40361: LD_VAR 0 4
40365: PUSH
40366: LD_VAR 0 8
40370: NOT
40371: AND
40372: IFFALSE 40441
// begin sort := SortBySkill ( tmp , 4 ) ;
40374: LD_ADDR_VAR 0 9
40378: PUSH
40379: LD_VAR 0 4
40383: PPUSH
40384: LD_INT 4
40386: PPUSH
40387: CALL 102868 0 2
40391: ST_TO_ADDR
// if sort then
40392: LD_VAR 0 9
40396: IFFALSE 40412
// p := sort [ 1 ] ;
40398: LD_ADDR_VAR 0 11
40402: PUSH
40403: LD_VAR 0 9
40407: PUSH
40408: LD_INT 1
40410: ARRAY
40411: ST_TO_ADDR
// if p then
40412: LD_VAR 0 11
40416: IFFALSE 40441
// result := Replace ( result , 4 , p ) ;
40418: LD_ADDR_VAR 0 2
40422: PUSH
40423: LD_VAR 0 2
40427: PPUSH
40428: LD_INT 4
40430: PPUSH
40431: LD_VAR 0 11
40435: PPUSH
40436: CALL_OW 1
40440: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
40441: LD_ADDR_VAR 0 4
40445: PUSH
40446: LD_VAR 0 4
40450: PUSH
40451: LD_VAR 0 7
40455: DIFF
40456: ST_TO_ADDR
// if tmp and mech < 6 then
40457: LD_VAR 0 4
40461: PUSH
40462: LD_VAR 0 7
40466: PUSH
40467: LD_INT 6
40469: LESS
40470: AND
40471: IFFALSE 40653
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
40473: LD_ADDR_VAR 0 9
40477: PUSH
40478: LD_VAR 0 4
40482: PUSH
40483: LD_VAR 0 7
40487: DIFF
40488: PPUSH
40489: LD_INT 3
40491: PPUSH
40492: CALL 102868 0 2
40496: ST_TO_ADDR
// p := [ ] ;
40497: LD_ADDR_VAR 0 11
40501: PUSH
40502: EMPTY
40503: ST_TO_ADDR
// if sort then
40504: LD_VAR 0 9
40508: IFFALSE 40624
// for i = 1 to 6 - mech do
40510: LD_ADDR_VAR 0 3
40514: PUSH
40515: DOUBLE
40516: LD_INT 1
40518: DEC
40519: ST_TO_ADDR
40520: LD_INT 6
40522: PUSH
40523: LD_VAR 0 7
40527: MINUS
40528: PUSH
40529: FOR_TO
40530: IFFALSE 40622
// begin if i = sort then
40532: LD_VAR 0 3
40536: PUSH
40537: LD_VAR 0 9
40541: EQUAL
40542: IFFALSE 40546
// break ;
40544: GO 40622
// if GetClass ( i ) = 3 then
40546: LD_VAR 0 3
40550: PPUSH
40551: CALL_OW 257
40555: PUSH
40556: LD_INT 3
40558: EQUAL
40559: IFFALSE 40563
// continue ;
40561: GO 40529
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40563: LD_ADDR_VAR 0 11
40567: PUSH
40568: LD_VAR 0 11
40572: PPUSH
40573: LD_VAR 0 11
40577: PUSH
40578: LD_INT 1
40580: PLUS
40581: PPUSH
40582: LD_VAR 0 9
40586: PUSH
40587: LD_VAR 0 3
40591: ARRAY
40592: PPUSH
40593: CALL_OW 2
40597: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40598: LD_ADDR_VAR 0 4
40602: PUSH
40603: LD_VAR 0 4
40607: PUSH
40608: LD_VAR 0 9
40612: PUSH
40613: LD_VAR 0 3
40617: ARRAY
40618: DIFF
40619: ST_TO_ADDR
// end ;
40620: GO 40529
40622: POP
40623: POP
// if p then
40624: LD_VAR 0 11
40628: IFFALSE 40653
// result := Replace ( result , 3 , p ) ;
40630: LD_ADDR_VAR 0 2
40634: PUSH
40635: LD_VAR 0 2
40639: PPUSH
40640: LD_INT 3
40642: PPUSH
40643: LD_VAR 0 11
40647: PPUSH
40648: CALL_OW 1
40652: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
40653: LD_ADDR_VAR 0 4
40657: PUSH
40658: LD_VAR 0 4
40662: PUSH
40663: LD_VAR 0 6
40667: DIFF
40668: ST_TO_ADDR
// if tmp and eng < 4 then
40669: LD_VAR 0 4
40673: PUSH
40674: LD_VAR 0 6
40678: PUSH
40679: LD_INT 4
40681: LESS
40682: AND
40683: IFFALSE 40873
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
40685: LD_ADDR_VAR 0 9
40689: PUSH
40690: LD_VAR 0 4
40694: PUSH
40695: LD_VAR 0 7
40699: PUSH
40700: LD_VAR 0 6
40704: UNION
40705: DIFF
40706: PPUSH
40707: LD_INT 2
40709: PPUSH
40710: CALL 102868 0 2
40714: ST_TO_ADDR
// p := [ ] ;
40715: LD_ADDR_VAR 0 11
40719: PUSH
40720: EMPTY
40721: ST_TO_ADDR
// if sort then
40722: LD_VAR 0 9
40726: IFFALSE 40842
// for i = 1 to 4 - eng do
40728: LD_ADDR_VAR 0 3
40732: PUSH
40733: DOUBLE
40734: LD_INT 1
40736: DEC
40737: ST_TO_ADDR
40738: LD_INT 4
40740: PUSH
40741: LD_VAR 0 6
40745: MINUS
40746: PUSH
40747: FOR_TO
40748: IFFALSE 40840
// begin if i = sort then
40750: LD_VAR 0 3
40754: PUSH
40755: LD_VAR 0 9
40759: EQUAL
40760: IFFALSE 40764
// break ;
40762: GO 40840
// if GetClass ( i ) = 2 then
40764: LD_VAR 0 3
40768: PPUSH
40769: CALL_OW 257
40773: PUSH
40774: LD_INT 2
40776: EQUAL
40777: IFFALSE 40781
// continue ;
40779: GO 40747
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40781: LD_ADDR_VAR 0 11
40785: PUSH
40786: LD_VAR 0 11
40790: PPUSH
40791: LD_VAR 0 11
40795: PUSH
40796: LD_INT 1
40798: PLUS
40799: PPUSH
40800: LD_VAR 0 9
40804: PUSH
40805: LD_VAR 0 3
40809: ARRAY
40810: PPUSH
40811: CALL_OW 2
40815: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40816: LD_ADDR_VAR 0 4
40820: PUSH
40821: LD_VAR 0 4
40825: PUSH
40826: LD_VAR 0 9
40830: PUSH
40831: LD_VAR 0 3
40835: ARRAY
40836: DIFF
40837: ST_TO_ADDR
// end ;
40838: GO 40747
40840: POP
40841: POP
// if p then
40842: LD_VAR 0 11
40846: IFFALSE 40871
// result := Replace ( result , 2 , p ) ;
40848: LD_ADDR_VAR 0 2
40852: PUSH
40853: LD_VAR 0 2
40857: PPUSH
40858: LD_INT 2
40860: PPUSH
40861: LD_VAR 0 11
40865: PPUSH
40866: CALL_OW 1
40870: ST_TO_ADDR
// end else
40871: GO 40917
// for i = eng downto 5 do
40873: LD_ADDR_VAR 0 3
40877: PUSH
40878: DOUBLE
40879: LD_VAR 0 6
40883: INC
40884: ST_TO_ADDR
40885: LD_INT 5
40887: PUSH
40888: FOR_DOWNTO
40889: IFFALSE 40915
// tmp := tmp union eng [ i ] ;
40891: LD_ADDR_VAR 0 4
40895: PUSH
40896: LD_VAR 0 4
40900: PUSH
40901: LD_VAR 0 6
40905: PUSH
40906: LD_VAR 0 3
40910: ARRAY
40911: UNION
40912: ST_TO_ADDR
40913: GO 40888
40915: POP
40916: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
40917: LD_ADDR_VAR 0 2
40921: PUSH
40922: LD_VAR 0 2
40926: PPUSH
40927: LD_INT 1
40929: PPUSH
40930: LD_VAR 0 4
40934: PUSH
40935: LD_VAR 0 5
40939: DIFF
40940: PPUSH
40941: CALL_OW 1
40945: ST_TO_ADDR
// exit ;
40946: GO 40948
// end ; end ;
40948: LD_VAR 0 2
40952: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
40953: LD_INT 0
40955: PPUSH
40956: PPUSH
40957: PPUSH
// if not mc_bases then
40958: LD_EXP 99
40962: NOT
40963: IFFALSE 40967
// exit ;
40965: GO 41073
// for i = 1 to mc_bases do
40967: LD_ADDR_VAR 0 2
40971: PUSH
40972: DOUBLE
40973: LD_INT 1
40975: DEC
40976: ST_TO_ADDR
40977: LD_EXP 99
40981: PUSH
40982: FOR_TO
40983: IFFALSE 41064
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
40985: LD_ADDR_VAR 0 3
40989: PUSH
40990: LD_EXP 99
40994: PUSH
40995: LD_VAR 0 2
40999: ARRAY
41000: PPUSH
41001: LD_INT 21
41003: PUSH
41004: LD_INT 3
41006: PUSH
41007: EMPTY
41008: LIST
41009: LIST
41010: PUSH
41011: LD_INT 3
41013: PUSH
41014: LD_INT 24
41016: PUSH
41017: LD_INT 1000
41019: PUSH
41020: EMPTY
41021: LIST
41022: LIST
41023: PUSH
41024: EMPTY
41025: LIST
41026: LIST
41027: PUSH
41028: EMPTY
41029: LIST
41030: LIST
41031: PPUSH
41032: CALL_OW 72
41036: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
41037: LD_ADDR_EXP 100
41041: PUSH
41042: LD_EXP 100
41046: PPUSH
41047: LD_VAR 0 2
41051: PPUSH
41052: LD_VAR 0 3
41056: PPUSH
41057: CALL_OW 1
41061: ST_TO_ADDR
// end ;
41062: GO 40982
41064: POP
41065: POP
// RaiseSailEvent ( 101 ) ;
41066: LD_INT 101
41068: PPUSH
41069: CALL_OW 427
// end ;
41073: LD_VAR 0 1
41077: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
41078: LD_INT 0
41080: PPUSH
41081: PPUSH
41082: PPUSH
41083: PPUSH
41084: PPUSH
41085: PPUSH
41086: PPUSH
// if not mc_bases then
41087: LD_EXP 99
41091: NOT
41092: IFFALSE 41096
// exit ;
41094: GO 41669
// for i = 1 to mc_bases do
41096: LD_ADDR_VAR 0 2
41100: PUSH
41101: DOUBLE
41102: LD_INT 1
41104: DEC
41105: ST_TO_ADDR
41106: LD_EXP 99
41110: PUSH
41111: FOR_TO
41112: IFFALSE 41660
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 750 ] ] ] ] ) ;
41114: LD_ADDR_VAR 0 5
41118: PUSH
41119: LD_EXP 99
41123: PUSH
41124: LD_VAR 0 2
41128: ARRAY
41129: PUSH
41130: LD_EXP 128
41134: PUSH
41135: LD_VAR 0 2
41139: ARRAY
41140: UNION
41141: PPUSH
41142: LD_INT 21
41144: PUSH
41145: LD_INT 1
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: PUSH
41152: LD_INT 1
41154: PUSH
41155: LD_INT 3
41157: PUSH
41158: LD_INT 54
41160: PUSH
41161: EMPTY
41162: LIST
41163: PUSH
41164: EMPTY
41165: LIST
41166: LIST
41167: PUSH
41168: LD_INT 3
41170: PUSH
41171: LD_INT 24
41173: PUSH
41174: LD_INT 750
41176: PUSH
41177: EMPTY
41178: LIST
41179: LIST
41180: PUSH
41181: EMPTY
41182: LIST
41183: LIST
41184: PUSH
41185: EMPTY
41186: LIST
41187: LIST
41188: LIST
41189: PUSH
41190: EMPTY
41191: LIST
41192: LIST
41193: PPUSH
41194: CALL_OW 72
41198: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
41199: LD_ADDR_VAR 0 6
41203: PUSH
41204: LD_EXP 99
41208: PUSH
41209: LD_VAR 0 2
41213: ARRAY
41214: PPUSH
41215: LD_INT 21
41217: PUSH
41218: LD_INT 1
41220: PUSH
41221: EMPTY
41222: LIST
41223: LIST
41224: PUSH
41225: LD_INT 1
41227: PUSH
41228: LD_INT 3
41230: PUSH
41231: LD_INT 54
41233: PUSH
41234: EMPTY
41235: LIST
41236: PUSH
41237: EMPTY
41238: LIST
41239: LIST
41240: PUSH
41241: LD_INT 3
41243: PUSH
41244: LD_INT 24
41246: PUSH
41247: LD_INT 250
41249: PUSH
41250: EMPTY
41251: LIST
41252: LIST
41253: PUSH
41254: EMPTY
41255: LIST
41256: LIST
41257: PUSH
41258: EMPTY
41259: LIST
41260: LIST
41261: LIST
41262: PUSH
41263: EMPTY
41264: LIST
41265: LIST
41266: PPUSH
41267: CALL_OW 72
41271: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
41272: LD_ADDR_VAR 0 7
41276: PUSH
41277: LD_VAR 0 5
41281: PUSH
41282: LD_VAR 0 6
41286: DIFF
41287: ST_TO_ADDR
// if not need_heal_1 then
41288: LD_VAR 0 6
41292: NOT
41293: IFFALSE 41326
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
41295: LD_ADDR_EXP 102
41299: PUSH
41300: LD_EXP 102
41304: PPUSH
41305: LD_VAR 0 2
41309: PUSH
41310: LD_INT 1
41312: PUSH
41313: EMPTY
41314: LIST
41315: LIST
41316: PPUSH
41317: EMPTY
41318: PPUSH
41319: CALL 68683 0 3
41323: ST_TO_ADDR
41324: GO 41396
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
41326: LD_ADDR_EXP 102
41330: PUSH
41331: LD_EXP 102
41335: PPUSH
41336: LD_VAR 0 2
41340: PUSH
41341: LD_INT 1
41343: PUSH
41344: EMPTY
41345: LIST
41346: LIST
41347: PPUSH
41348: LD_EXP 102
41352: PUSH
41353: LD_VAR 0 2
41357: ARRAY
41358: PUSH
41359: LD_INT 1
41361: ARRAY
41362: PPUSH
41363: LD_INT 3
41365: PUSH
41366: LD_INT 24
41368: PUSH
41369: LD_INT 1000
41371: PUSH
41372: EMPTY
41373: LIST
41374: LIST
41375: PUSH
41376: EMPTY
41377: LIST
41378: LIST
41379: PPUSH
41380: CALL_OW 72
41384: PUSH
41385: LD_VAR 0 6
41389: UNION
41390: PPUSH
41391: CALL 68683 0 3
41395: ST_TO_ADDR
// if not need_heal_2 then
41396: LD_VAR 0 7
41400: NOT
41401: IFFALSE 41434
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
41403: LD_ADDR_EXP 102
41407: PUSH
41408: LD_EXP 102
41412: PPUSH
41413: LD_VAR 0 2
41417: PUSH
41418: LD_INT 2
41420: PUSH
41421: EMPTY
41422: LIST
41423: LIST
41424: PPUSH
41425: EMPTY
41426: PPUSH
41427: CALL 68683 0 3
41431: ST_TO_ADDR
41432: GO 41466
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
41434: LD_ADDR_EXP 102
41438: PUSH
41439: LD_EXP 102
41443: PPUSH
41444: LD_VAR 0 2
41448: PUSH
41449: LD_INT 2
41451: PUSH
41452: EMPTY
41453: LIST
41454: LIST
41455: PPUSH
41456: LD_VAR 0 7
41460: PPUSH
41461: CALL 68683 0 3
41465: ST_TO_ADDR
// if need_heal_2 then
41466: LD_VAR 0 7
41470: IFFALSE 41642
// for j in need_heal_2 do
41472: LD_ADDR_VAR 0 3
41476: PUSH
41477: LD_VAR 0 7
41481: PUSH
41482: FOR_IN
41483: IFFALSE 41640
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
41485: LD_ADDR_VAR 0 5
41489: PUSH
41490: LD_EXP 99
41494: PUSH
41495: LD_VAR 0 2
41499: ARRAY
41500: PPUSH
41501: LD_INT 2
41503: PUSH
41504: LD_INT 30
41506: PUSH
41507: LD_INT 6
41509: PUSH
41510: EMPTY
41511: LIST
41512: LIST
41513: PUSH
41514: LD_INT 30
41516: PUSH
41517: LD_INT 7
41519: PUSH
41520: EMPTY
41521: LIST
41522: LIST
41523: PUSH
41524: LD_INT 30
41526: PUSH
41527: LD_INT 8
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: PUSH
41534: LD_INT 30
41536: PUSH
41537: LD_INT 0
41539: PUSH
41540: EMPTY
41541: LIST
41542: LIST
41543: PUSH
41544: LD_INT 30
41546: PUSH
41547: LD_INT 1
41549: PUSH
41550: EMPTY
41551: LIST
41552: LIST
41553: PUSH
41554: LD_INT 25
41556: PUSH
41557: LD_INT 4
41559: PUSH
41560: EMPTY
41561: LIST
41562: LIST
41563: PUSH
41564: EMPTY
41565: LIST
41566: LIST
41567: LIST
41568: LIST
41569: LIST
41570: LIST
41571: LIST
41572: PPUSH
41573: CALL_OW 72
41577: ST_TO_ADDR
// if tmp then
41578: LD_VAR 0 5
41582: IFFALSE 41638
// begin k := NearestUnitToUnit ( tmp , j ) ;
41584: LD_ADDR_VAR 0 4
41588: PUSH
41589: LD_VAR 0 5
41593: PPUSH
41594: LD_VAR 0 3
41598: PPUSH
41599: CALL_OW 74
41603: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
41604: LD_VAR 0 3
41608: PPUSH
41609: LD_VAR 0 4
41613: PPUSH
41614: CALL_OW 296
41618: PUSH
41619: LD_INT 7
41621: GREATER
41622: IFFALSE 41638
// ComMoveUnit ( j , k ) ;
41624: LD_VAR 0 3
41628: PPUSH
41629: LD_VAR 0 4
41633: PPUSH
41634: CALL_OW 112
// end ; end ;
41638: GO 41482
41640: POP
41641: POP
// if not need_heal_1 and not need_heal_2 then
41642: LD_VAR 0 6
41646: NOT
41647: PUSH
41648: LD_VAR 0 7
41652: NOT
41653: AND
41654: IFFALSE 41658
// continue ;
41656: GO 41111
// end ;
41658: GO 41111
41660: POP
41661: POP
// RaiseSailEvent ( 102 ) ;
41662: LD_INT 102
41664: PPUSH
41665: CALL_OW 427
// end ;
41669: LD_VAR 0 1
41673: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
41674: LD_INT 0
41676: PPUSH
41677: PPUSH
41678: PPUSH
41679: PPUSH
41680: PPUSH
// if not mc_bases then
41681: LD_EXP 99
41685: NOT
41686: IFFALSE 41690
// exit ;
41688: GO 42075
// for i = 1 to mc_bases do
41690: LD_ADDR_VAR 0 2
41694: PUSH
41695: DOUBLE
41696: LD_INT 1
41698: DEC
41699: ST_TO_ADDR
41700: LD_EXP 99
41704: PUSH
41705: FOR_TO
41706: IFFALSE 42073
// begin if not mc_building_need_repair [ i ] then
41708: LD_EXP 100
41712: PUSH
41713: LD_VAR 0 2
41717: ARRAY
41718: NOT
41719: IFFALSE 41757
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
41721: LD_ADDR_EXP 101
41725: PUSH
41726: LD_EXP 101
41730: PPUSH
41731: LD_VAR 0 2
41735: PPUSH
41736: EMPTY
41737: PPUSH
41738: CALL_OW 1
41742: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
41743: LD_VAR 0 2
41747: PPUSH
41748: LD_INT 101
41750: PPUSH
41751: CALL 36795 0 2
// continue ;
41755: GO 41705
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
41757: LD_ADDR_EXP 105
41761: PUSH
41762: LD_EXP 105
41766: PPUSH
41767: LD_VAR 0 2
41771: PPUSH
41772: EMPTY
41773: PPUSH
41774: CALL_OW 1
41778: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
41779: LD_VAR 0 2
41783: PPUSH
41784: LD_INT 103
41786: PPUSH
41787: CALL 36795 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
41791: LD_ADDR_VAR 0 5
41795: PUSH
41796: LD_EXP 99
41800: PUSH
41801: LD_VAR 0 2
41805: ARRAY
41806: PUSH
41807: LD_EXP 128
41811: PUSH
41812: LD_VAR 0 2
41816: ARRAY
41817: UNION
41818: PPUSH
41819: LD_INT 2
41821: PUSH
41822: LD_INT 25
41824: PUSH
41825: LD_INT 2
41827: PUSH
41828: EMPTY
41829: LIST
41830: LIST
41831: PUSH
41832: LD_INT 25
41834: PUSH
41835: LD_INT 16
41837: PUSH
41838: EMPTY
41839: LIST
41840: LIST
41841: PUSH
41842: EMPTY
41843: LIST
41844: LIST
41845: LIST
41846: PUSH
41847: EMPTY
41848: LIST
41849: PPUSH
41850: CALL_OW 72
41854: ST_TO_ADDR
// if not tmp then
41855: LD_VAR 0 5
41859: NOT
41860: IFFALSE 41864
// continue ;
41862: GO 41705
// for j in tmp do
41864: LD_ADDR_VAR 0 3
41868: PUSH
41869: LD_VAR 0 5
41873: PUSH
41874: FOR_IN
41875: IFFALSE 42069
// begin if mc_need_heal [ i ] then
41877: LD_EXP 102
41881: PUSH
41882: LD_VAR 0 2
41886: ARRAY
41887: IFFALSE 41935
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
41889: LD_VAR 0 3
41893: PUSH
41894: LD_EXP 102
41898: PUSH
41899: LD_VAR 0 2
41903: ARRAY
41904: PUSH
41905: LD_INT 1
41907: ARRAY
41908: IN
41909: PUSH
41910: LD_VAR 0 3
41914: PUSH
41915: LD_EXP 102
41919: PUSH
41920: LD_VAR 0 2
41924: ARRAY
41925: PUSH
41926: LD_INT 2
41928: ARRAY
41929: IN
41930: OR
41931: IFFALSE 41935
// continue ;
41933: GO 41874
// if IsInUnit ( j ) then
41935: LD_VAR 0 3
41939: PPUSH
41940: CALL_OW 310
41944: IFFALSE 41955
// ComExitBuilding ( j ) ;
41946: LD_VAR 0 3
41950: PPUSH
41951: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
41955: LD_VAR 0 3
41959: PUSH
41960: LD_EXP 101
41964: PUSH
41965: LD_VAR 0 2
41969: ARRAY
41970: IN
41971: NOT
41972: IFFALSE 42030
// begin SetTag ( j , 101 ) ;
41974: LD_VAR 0 3
41978: PPUSH
41979: LD_INT 101
41981: PPUSH
41982: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
41986: LD_ADDR_EXP 101
41990: PUSH
41991: LD_EXP 101
41995: PPUSH
41996: LD_VAR 0 2
42000: PUSH
42001: LD_EXP 101
42005: PUSH
42006: LD_VAR 0 2
42010: ARRAY
42011: PUSH
42012: LD_INT 1
42014: PLUS
42015: PUSH
42016: EMPTY
42017: LIST
42018: LIST
42019: PPUSH
42020: LD_VAR 0 3
42024: PPUSH
42025: CALL 68683 0 3
42029: ST_TO_ADDR
// end ; wait ( 1 ) ;
42030: LD_INT 1
42032: PPUSH
42033: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
42037: LD_VAR 0 3
42041: PPUSH
42042: LD_EXP 100
42046: PUSH
42047: LD_VAR 0 2
42051: ARRAY
42052: PPUSH
42053: LD_VAR 0 3
42057: PPUSH
42058: CALL_OW 74
42062: PPUSH
42063: CALL_OW 130
// end ;
42067: GO 41874
42069: POP
42070: POP
// end ;
42071: GO 41705
42073: POP
42074: POP
// end ;
42075: LD_VAR 0 1
42079: RET
// export function MC_Heal ; var i , j , tmp ; begin
42080: LD_INT 0
42082: PPUSH
42083: PPUSH
42084: PPUSH
42085: PPUSH
// if not mc_bases then
42086: LD_EXP 99
42090: NOT
42091: IFFALSE 42095
// exit ;
42093: GO 42497
// for i = 1 to mc_bases do
42095: LD_ADDR_VAR 0 2
42099: PUSH
42100: DOUBLE
42101: LD_INT 1
42103: DEC
42104: ST_TO_ADDR
42105: LD_EXP 99
42109: PUSH
42110: FOR_TO
42111: IFFALSE 42495
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
42113: LD_EXP 102
42117: PUSH
42118: LD_VAR 0 2
42122: ARRAY
42123: PUSH
42124: LD_INT 1
42126: ARRAY
42127: NOT
42128: PUSH
42129: LD_EXP 102
42133: PUSH
42134: LD_VAR 0 2
42138: ARRAY
42139: PUSH
42140: LD_INT 2
42142: ARRAY
42143: NOT
42144: AND
42145: IFFALSE 42183
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
42147: LD_ADDR_EXP 103
42151: PUSH
42152: LD_EXP 103
42156: PPUSH
42157: LD_VAR 0 2
42161: PPUSH
42162: EMPTY
42163: PPUSH
42164: CALL_OW 1
42168: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
42169: LD_VAR 0 2
42173: PPUSH
42174: LD_INT 102
42176: PPUSH
42177: CALL 36795 0 2
// continue ;
42181: GO 42110
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
42183: LD_ADDR_VAR 0 4
42187: PUSH
42188: LD_EXP 99
42192: PUSH
42193: LD_VAR 0 2
42197: ARRAY
42198: PPUSH
42199: LD_INT 25
42201: PUSH
42202: LD_INT 4
42204: PUSH
42205: EMPTY
42206: LIST
42207: LIST
42208: PPUSH
42209: CALL_OW 72
42213: ST_TO_ADDR
// if not tmp then
42214: LD_VAR 0 4
42218: NOT
42219: IFFALSE 42223
// continue ;
42221: GO 42110
// if mc_taming [ i ] then
42223: LD_EXP 130
42227: PUSH
42228: LD_VAR 0 2
42232: ARRAY
42233: IFFALSE 42257
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
42235: LD_ADDR_EXP 130
42239: PUSH
42240: LD_EXP 130
42244: PPUSH
42245: LD_VAR 0 2
42249: PPUSH
42250: EMPTY
42251: PPUSH
42252: CALL_OW 1
42256: ST_TO_ADDR
// for j in tmp do
42257: LD_ADDR_VAR 0 3
42261: PUSH
42262: LD_VAR 0 4
42266: PUSH
42267: FOR_IN
42268: IFFALSE 42491
// begin if IsInUnit ( j ) then
42270: LD_VAR 0 3
42274: PPUSH
42275: CALL_OW 310
42279: IFFALSE 42290
// ComExitBuilding ( j ) ;
42281: LD_VAR 0 3
42285: PPUSH
42286: CALL_OW 122
// if not j in mc_healers [ i ] then
42290: LD_VAR 0 3
42294: PUSH
42295: LD_EXP 103
42299: PUSH
42300: LD_VAR 0 2
42304: ARRAY
42305: IN
42306: NOT
42307: IFFALSE 42353
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
42309: LD_ADDR_EXP 103
42313: PUSH
42314: LD_EXP 103
42318: PPUSH
42319: LD_VAR 0 2
42323: PUSH
42324: LD_EXP 103
42328: PUSH
42329: LD_VAR 0 2
42333: ARRAY
42334: PUSH
42335: LD_INT 1
42337: PLUS
42338: PUSH
42339: EMPTY
42340: LIST
42341: LIST
42342: PPUSH
42343: LD_VAR 0 3
42347: PPUSH
42348: CALL 68683 0 3
42352: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
42353: LD_VAR 0 3
42357: PPUSH
42358: CALL_OW 110
42362: PUSH
42363: LD_INT 102
42365: NONEQUAL
42366: IFFALSE 42380
// SetTag ( j , 102 ) ;
42368: LD_VAR 0 3
42372: PPUSH
42373: LD_INT 102
42375: PPUSH
42376: CALL_OW 109
// Wait ( 3 ) ;
42380: LD_INT 3
42382: PPUSH
42383: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
42387: LD_EXP 102
42391: PUSH
42392: LD_VAR 0 2
42396: ARRAY
42397: PUSH
42398: LD_INT 1
42400: ARRAY
42401: IFFALSE 42433
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
42403: LD_VAR 0 3
42407: PPUSH
42408: LD_EXP 102
42412: PUSH
42413: LD_VAR 0 2
42417: ARRAY
42418: PUSH
42419: LD_INT 1
42421: ARRAY
42422: PUSH
42423: LD_INT 1
42425: ARRAY
42426: PPUSH
42427: CALL_OW 128
42431: GO 42489
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
42433: LD_VAR 0 3
42437: PPUSH
42438: CALL_OW 314
42442: NOT
42443: PUSH
42444: LD_EXP 102
42448: PUSH
42449: LD_VAR 0 2
42453: ARRAY
42454: PUSH
42455: LD_INT 2
42457: ARRAY
42458: AND
42459: IFFALSE 42489
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
42461: LD_VAR 0 3
42465: PPUSH
42466: LD_EXP 102
42470: PUSH
42471: LD_VAR 0 2
42475: ARRAY
42476: PUSH
42477: LD_INT 2
42479: ARRAY
42480: PUSH
42481: LD_INT 1
42483: ARRAY
42484: PPUSH
42485: CALL_OW 128
// end ;
42489: GO 42267
42491: POP
42492: POP
// end ;
42493: GO 42110
42495: POP
42496: POP
// end ;
42497: LD_VAR 0 1
42501: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
42502: LD_INT 0
42504: PPUSH
42505: PPUSH
42506: PPUSH
42507: PPUSH
42508: PPUSH
// if not mc_bases then
42509: LD_EXP 99
42513: NOT
42514: IFFALSE 42518
// exit ;
42516: GO 43661
// for i = 1 to mc_bases do
42518: LD_ADDR_VAR 0 2
42522: PUSH
42523: DOUBLE
42524: LD_INT 1
42526: DEC
42527: ST_TO_ADDR
42528: LD_EXP 99
42532: PUSH
42533: FOR_TO
42534: IFFALSE 43659
// begin if mc_scan [ i ] then
42536: LD_EXP 122
42540: PUSH
42541: LD_VAR 0 2
42545: ARRAY
42546: IFFALSE 42550
// continue ;
42548: GO 42533
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
42550: LD_EXP 104
42554: PUSH
42555: LD_VAR 0 2
42559: ARRAY
42560: NOT
42561: PUSH
42562: LD_EXP 106
42566: PUSH
42567: LD_VAR 0 2
42571: ARRAY
42572: NOT
42573: AND
42574: PUSH
42575: LD_EXP 105
42579: PUSH
42580: LD_VAR 0 2
42584: ARRAY
42585: AND
42586: IFFALSE 42624
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
42588: LD_ADDR_EXP 105
42592: PUSH
42593: LD_EXP 105
42597: PPUSH
42598: LD_VAR 0 2
42602: PPUSH
42603: EMPTY
42604: PPUSH
42605: CALL_OW 1
42609: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
42610: LD_VAR 0 2
42614: PPUSH
42615: LD_INT 103
42617: PPUSH
42618: CALL 36795 0 2
// continue ;
42622: GO 42533
// end ; if mc_construct_list [ i ] then
42624: LD_EXP 106
42628: PUSH
42629: LD_VAR 0 2
42633: ARRAY
42634: IFFALSE 42854
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
42636: LD_ADDR_VAR 0 4
42640: PUSH
42641: LD_EXP 99
42645: PUSH
42646: LD_VAR 0 2
42650: ARRAY
42651: PPUSH
42652: LD_INT 25
42654: PUSH
42655: LD_INT 2
42657: PUSH
42658: EMPTY
42659: LIST
42660: LIST
42661: PPUSH
42662: CALL_OW 72
42666: PUSH
42667: LD_EXP 101
42671: PUSH
42672: LD_VAR 0 2
42676: ARRAY
42677: DIFF
42678: ST_TO_ADDR
// if not tmp then
42679: LD_VAR 0 4
42683: NOT
42684: IFFALSE 42688
// continue ;
42686: GO 42533
// for j in tmp do
42688: LD_ADDR_VAR 0 3
42692: PUSH
42693: LD_VAR 0 4
42697: PUSH
42698: FOR_IN
42699: IFFALSE 42850
// begin if not mc_builders [ i ] then
42701: LD_EXP 105
42705: PUSH
42706: LD_VAR 0 2
42710: ARRAY
42711: NOT
42712: IFFALSE 42770
// begin SetTag ( j , 103 ) ;
42714: LD_VAR 0 3
42718: PPUSH
42719: LD_INT 103
42721: PPUSH
42722: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
42726: LD_ADDR_EXP 105
42730: PUSH
42731: LD_EXP 105
42735: PPUSH
42736: LD_VAR 0 2
42740: PUSH
42741: LD_EXP 105
42745: PUSH
42746: LD_VAR 0 2
42750: ARRAY
42751: PUSH
42752: LD_INT 1
42754: PLUS
42755: PUSH
42756: EMPTY
42757: LIST
42758: LIST
42759: PPUSH
42760: LD_VAR 0 3
42764: PPUSH
42765: CALL 68683 0 3
42769: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
42770: LD_VAR 0 3
42774: PPUSH
42775: CALL_OW 310
42779: IFFALSE 42790
// ComExitBuilding ( j ) ;
42781: LD_VAR 0 3
42785: PPUSH
42786: CALL_OW 122
// wait ( 3 ) ;
42790: LD_INT 3
42792: PPUSH
42793: CALL_OW 67
// if not mc_construct_list [ i ] then
42797: LD_EXP 106
42801: PUSH
42802: LD_VAR 0 2
42806: ARRAY
42807: NOT
42808: IFFALSE 42812
// break ;
42810: GO 42850
// if not HasTask ( j ) then
42812: LD_VAR 0 3
42816: PPUSH
42817: CALL_OW 314
42821: NOT
42822: IFFALSE 42848
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
42824: LD_VAR 0 3
42828: PPUSH
42829: LD_EXP 106
42833: PUSH
42834: LD_VAR 0 2
42838: ARRAY
42839: PUSH
42840: LD_INT 1
42842: ARRAY
42843: PPUSH
42844: CALL 71534 0 2
// end ;
42848: GO 42698
42850: POP
42851: POP
// end else
42852: GO 43657
// if mc_build_list [ i ] then
42854: LD_EXP 104
42858: PUSH
42859: LD_VAR 0 2
42863: ARRAY
42864: IFFALSE 43657
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
42866: LD_ADDR_VAR 0 5
42870: PUSH
42871: LD_EXP 99
42875: PUSH
42876: LD_VAR 0 2
42880: ARRAY
42881: PPUSH
42882: LD_INT 2
42884: PUSH
42885: LD_INT 30
42887: PUSH
42888: LD_INT 0
42890: PUSH
42891: EMPTY
42892: LIST
42893: LIST
42894: PUSH
42895: LD_INT 30
42897: PUSH
42898: LD_INT 1
42900: PUSH
42901: EMPTY
42902: LIST
42903: LIST
42904: PUSH
42905: EMPTY
42906: LIST
42907: LIST
42908: LIST
42909: PPUSH
42910: CALL_OW 72
42914: ST_TO_ADDR
// if depot then
42915: LD_VAR 0 5
42919: IFFALSE 42937
// depot := depot [ 1 ] else
42921: LD_ADDR_VAR 0 5
42925: PUSH
42926: LD_VAR 0 5
42930: PUSH
42931: LD_INT 1
42933: ARRAY
42934: ST_TO_ADDR
42935: GO 42945
// depot := 0 ;
42937: LD_ADDR_VAR 0 5
42941: PUSH
42942: LD_INT 0
42944: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
42945: LD_EXP 104
42949: PUSH
42950: LD_VAR 0 2
42954: ARRAY
42955: PUSH
42956: LD_INT 1
42958: ARRAY
42959: PUSH
42960: LD_INT 1
42962: ARRAY
42963: PPUSH
42964: CALL 71364 0 1
42968: PUSH
42969: LD_EXP 99
42973: PUSH
42974: LD_VAR 0 2
42978: ARRAY
42979: PPUSH
42980: LD_INT 2
42982: PUSH
42983: LD_INT 30
42985: PUSH
42986: LD_INT 2
42988: PUSH
42989: EMPTY
42990: LIST
42991: LIST
42992: PUSH
42993: LD_INT 30
42995: PUSH
42996: LD_INT 3
42998: PUSH
42999: EMPTY
43000: LIST
43001: LIST
43002: PUSH
43003: EMPTY
43004: LIST
43005: LIST
43006: LIST
43007: PPUSH
43008: CALL_OW 72
43012: NOT
43013: AND
43014: IFFALSE 43119
// begin for j = 1 to mc_build_list [ i ] do
43016: LD_ADDR_VAR 0 3
43020: PUSH
43021: DOUBLE
43022: LD_INT 1
43024: DEC
43025: ST_TO_ADDR
43026: LD_EXP 104
43030: PUSH
43031: LD_VAR 0 2
43035: ARRAY
43036: PUSH
43037: FOR_TO
43038: IFFALSE 43117
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
43040: LD_EXP 104
43044: PUSH
43045: LD_VAR 0 2
43049: ARRAY
43050: PUSH
43051: LD_VAR 0 3
43055: ARRAY
43056: PUSH
43057: LD_INT 1
43059: ARRAY
43060: PUSH
43061: LD_INT 2
43063: EQUAL
43064: IFFALSE 43115
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
43066: LD_ADDR_EXP 104
43070: PUSH
43071: LD_EXP 104
43075: PPUSH
43076: LD_VAR 0 2
43080: PPUSH
43081: LD_EXP 104
43085: PUSH
43086: LD_VAR 0 2
43090: ARRAY
43091: PPUSH
43092: LD_VAR 0 3
43096: PPUSH
43097: LD_INT 1
43099: PPUSH
43100: LD_INT 0
43102: PPUSH
43103: CALL 68101 0 4
43107: PPUSH
43108: CALL_OW 1
43112: ST_TO_ADDR
// break ;
43113: GO 43117
// end ;
43115: GO 43037
43117: POP
43118: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilded ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
43119: LD_EXP 104
43123: PUSH
43124: LD_VAR 0 2
43128: ARRAY
43129: PUSH
43130: LD_INT 1
43132: ARRAY
43133: PUSH
43134: LD_INT 1
43136: ARRAY
43137: PUSH
43138: LD_INT 0
43140: EQUAL
43141: PUSH
43142: LD_VAR 0 5
43146: PUSH
43147: LD_VAR 0 5
43151: PPUSH
43152: LD_EXP 104
43156: PUSH
43157: LD_VAR 0 2
43161: ARRAY
43162: PUSH
43163: LD_INT 1
43165: ARRAY
43166: PUSH
43167: LD_INT 1
43169: ARRAY
43170: PPUSH
43171: LD_EXP 104
43175: PUSH
43176: LD_VAR 0 2
43180: ARRAY
43181: PUSH
43182: LD_INT 1
43184: ARRAY
43185: PUSH
43186: LD_INT 2
43188: ARRAY
43189: PPUSH
43190: LD_EXP 104
43194: PUSH
43195: LD_VAR 0 2
43199: ARRAY
43200: PUSH
43201: LD_INT 1
43203: ARRAY
43204: PUSH
43205: LD_INT 3
43207: ARRAY
43208: PPUSH
43209: LD_EXP 104
43213: PUSH
43214: LD_VAR 0 2
43218: ARRAY
43219: PUSH
43220: LD_INT 1
43222: ARRAY
43223: PUSH
43224: LD_INT 4
43226: ARRAY
43227: PPUSH
43228: CALL 76080 0 5
43232: AND
43233: OR
43234: IFFALSE 43515
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
43236: LD_ADDR_VAR 0 4
43240: PUSH
43241: LD_EXP 99
43245: PUSH
43246: LD_VAR 0 2
43250: ARRAY
43251: PPUSH
43252: LD_INT 25
43254: PUSH
43255: LD_INT 2
43257: PUSH
43258: EMPTY
43259: LIST
43260: LIST
43261: PPUSH
43262: CALL_OW 72
43266: PUSH
43267: LD_EXP 101
43271: PUSH
43272: LD_VAR 0 2
43276: ARRAY
43277: DIFF
43278: ST_TO_ADDR
// if not tmp then
43279: LD_VAR 0 4
43283: NOT
43284: IFFALSE 43288
// continue ;
43286: GO 42533
// for j in tmp do
43288: LD_ADDR_VAR 0 3
43292: PUSH
43293: LD_VAR 0 4
43297: PUSH
43298: FOR_IN
43299: IFFALSE 43511
// begin if not mc_builders [ i ] then
43301: LD_EXP 105
43305: PUSH
43306: LD_VAR 0 2
43310: ARRAY
43311: NOT
43312: IFFALSE 43370
// begin SetTag ( j , 103 ) ;
43314: LD_VAR 0 3
43318: PPUSH
43319: LD_INT 103
43321: PPUSH
43322: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
43326: LD_ADDR_EXP 105
43330: PUSH
43331: LD_EXP 105
43335: PPUSH
43336: LD_VAR 0 2
43340: PUSH
43341: LD_EXP 105
43345: PUSH
43346: LD_VAR 0 2
43350: ARRAY
43351: PUSH
43352: LD_INT 1
43354: PLUS
43355: PUSH
43356: EMPTY
43357: LIST
43358: LIST
43359: PPUSH
43360: LD_VAR 0 3
43364: PPUSH
43365: CALL 68683 0 3
43369: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
43370: LD_VAR 0 3
43374: PPUSH
43375: CALL_OW 310
43379: IFFALSE 43390
// ComExitBuilding ( j ) ;
43381: LD_VAR 0 3
43385: PPUSH
43386: CALL_OW 122
// wait ( 3 ) ;
43390: LD_INT 3
43392: PPUSH
43393: CALL_OW 67
// if not mc_build_list [ i ] then
43397: LD_EXP 104
43401: PUSH
43402: LD_VAR 0 2
43406: ARRAY
43407: NOT
43408: IFFALSE 43412
// break ;
43410: GO 43511
// if not HasTask ( j ) then
43412: LD_VAR 0 3
43416: PPUSH
43417: CALL_OW 314
43421: NOT
43422: IFFALSE 43509
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
43424: LD_VAR 0 3
43428: PPUSH
43429: LD_EXP 104
43433: PUSH
43434: LD_VAR 0 2
43438: ARRAY
43439: PUSH
43440: LD_INT 1
43442: ARRAY
43443: PUSH
43444: LD_INT 1
43446: ARRAY
43447: PPUSH
43448: LD_EXP 104
43452: PUSH
43453: LD_VAR 0 2
43457: ARRAY
43458: PUSH
43459: LD_INT 1
43461: ARRAY
43462: PUSH
43463: LD_INT 2
43465: ARRAY
43466: PPUSH
43467: LD_EXP 104
43471: PUSH
43472: LD_VAR 0 2
43476: ARRAY
43477: PUSH
43478: LD_INT 1
43480: ARRAY
43481: PUSH
43482: LD_INT 3
43484: ARRAY
43485: PPUSH
43486: LD_EXP 104
43490: PUSH
43491: LD_VAR 0 2
43495: ARRAY
43496: PUSH
43497: LD_INT 1
43499: ARRAY
43500: PUSH
43501: LD_INT 4
43503: ARRAY
43504: PPUSH
43505: CALL_OW 145
// end ;
43509: GO 43298
43511: POP
43512: POP
// end else
43513: GO 43657
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
43515: LD_EXP 99
43519: PUSH
43520: LD_VAR 0 2
43524: ARRAY
43525: PPUSH
43526: LD_EXP 104
43530: PUSH
43531: LD_VAR 0 2
43535: ARRAY
43536: PUSH
43537: LD_INT 1
43539: ARRAY
43540: PUSH
43541: LD_INT 1
43543: ARRAY
43544: PPUSH
43545: LD_EXP 104
43549: PUSH
43550: LD_VAR 0 2
43554: ARRAY
43555: PUSH
43556: LD_INT 1
43558: ARRAY
43559: PUSH
43560: LD_INT 2
43562: ARRAY
43563: PPUSH
43564: LD_EXP 104
43568: PUSH
43569: LD_VAR 0 2
43573: ARRAY
43574: PUSH
43575: LD_INT 1
43577: ARRAY
43578: PUSH
43579: LD_INT 3
43581: ARRAY
43582: PPUSH
43583: LD_EXP 104
43587: PUSH
43588: LD_VAR 0 2
43592: ARRAY
43593: PUSH
43594: LD_INT 1
43596: ARRAY
43597: PUSH
43598: LD_INT 4
43600: ARRAY
43601: PPUSH
43602: CALL 75434 0 5
43606: NOT
43607: IFFALSE 43657
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
43609: LD_ADDR_EXP 104
43613: PUSH
43614: LD_EXP 104
43618: PPUSH
43619: LD_VAR 0 2
43623: PPUSH
43624: LD_EXP 104
43628: PUSH
43629: LD_VAR 0 2
43633: ARRAY
43634: PPUSH
43635: LD_INT 1
43637: PPUSH
43638: LD_INT 1
43640: NEG
43641: PPUSH
43642: LD_INT 0
43644: PPUSH
43645: CALL 68101 0 4
43649: PPUSH
43650: CALL_OW 1
43654: ST_TO_ADDR
// continue ;
43655: GO 42533
// end ; end ; end ;
43657: GO 42533
43659: POP
43660: POP
// end ;
43661: LD_VAR 0 1
43665: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
43666: LD_INT 0
43668: PPUSH
43669: PPUSH
43670: PPUSH
43671: PPUSH
43672: PPUSH
43673: PPUSH
// if not mc_bases then
43674: LD_EXP 99
43678: NOT
43679: IFFALSE 43683
// exit ;
43681: GO 44110
// for i = 1 to mc_bases do
43683: LD_ADDR_VAR 0 2
43687: PUSH
43688: DOUBLE
43689: LD_INT 1
43691: DEC
43692: ST_TO_ADDR
43693: LD_EXP 99
43697: PUSH
43698: FOR_TO
43699: IFFALSE 44108
// begin tmp := mc_build_upgrade [ i ] ;
43701: LD_ADDR_VAR 0 4
43705: PUSH
43706: LD_EXP 131
43710: PUSH
43711: LD_VAR 0 2
43715: ARRAY
43716: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
43717: LD_ADDR_VAR 0 6
43721: PUSH
43722: LD_EXP 132
43726: PUSH
43727: LD_VAR 0 2
43731: ARRAY
43732: PPUSH
43733: LD_INT 2
43735: PUSH
43736: LD_INT 30
43738: PUSH
43739: LD_INT 6
43741: PUSH
43742: EMPTY
43743: LIST
43744: LIST
43745: PUSH
43746: LD_INT 30
43748: PUSH
43749: LD_INT 7
43751: PUSH
43752: EMPTY
43753: LIST
43754: LIST
43755: PUSH
43756: EMPTY
43757: LIST
43758: LIST
43759: LIST
43760: PPUSH
43761: CALL_OW 72
43765: ST_TO_ADDR
// if not tmp and not lab then
43766: LD_VAR 0 4
43770: NOT
43771: PUSH
43772: LD_VAR 0 6
43776: NOT
43777: AND
43778: IFFALSE 43782
// continue ;
43780: GO 43698
// if tmp then
43782: LD_VAR 0 4
43786: IFFALSE 43906
// for j in tmp do
43788: LD_ADDR_VAR 0 3
43792: PUSH
43793: LD_VAR 0 4
43797: PUSH
43798: FOR_IN
43799: IFFALSE 43904
// begin if UpgradeCost ( j ) then
43801: LD_VAR 0 3
43805: PPUSH
43806: CALL 75094 0 1
43810: IFFALSE 43902
// begin ComUpgrade ( j ) ;
43812: LD_VAR 0 3
43816: PPUSH
43817: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
43821: LD_ADDR_EXP 131
43825: PUSH
43826: LD_EXP 131
43830: PPUSH
43831: LD_VAR 0 2
43835: PPUSH
43836: LD_EXP 131
43840: PUSH
43841: LD_VAR 0 2
43845: ARRAY
43846: PUSH
43847: LD_VAR 0 3
43851: DIFF
43852: PPUSH
43853: CALL_OW 1
43857: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
43858: LD_ADDR_EXP 106
43862: PUSH
43863: LD_EXP 106
43867: PPUSH
43868: LD_VAR 0 2
43872: PUSH
43873: LD_EXP 106
43877: PUSH
43878: LD_VAR 0 2
43882: ARRAY
43883: PUSH
43884: LD_INT 1
43886: PLUS
43887: PUSH
43888: EMPTY
43889: LIST
43890: LIST
43891: PPUSH
43892: LD_VAR 0 3
43896: PPUSH
43897: CALL 68683 0 3
43901: ST_TO_ADDR
// end ; end ;
43902: GO 43798
43904: POP
43905: POP
// if not lab or not mc_lab_upgrade [ i ] then
43906: LD_VAR 0 6
43910: NOT
43911: PUSH
43912: LD_EXP 133
43916: PUSH
43917: LD_VAR 0 2
43921: ARRAY
43922: NOT
43923: OR
43924: IFFALSE 43928
// continue ;
43926: GO 43698
// for j in lab do
43928: LD_ADDR_VAR 0 3
43932: PUSH
43933: LD_VAR 0 6
43937: PUSH
43938: FOR_IN
43939: IFFALSE 44104
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
43941: LD_VAR 0 3
43945: PPUSH
43946: CALL_OW 266
43950: PUSH
43951: LD_INT 6
43953: PUSH
43954: LD_INT 7
43956: PUSH
43957: EMPTY
43958: LIST
43959: LIST
43960: IN
43961: PUSH
43962: LD_VAR 0 3
43966: PPUSH
43967: CALL_OW 461
43971: PUSH
43972: LD_INT 1
43974: NONEQUAL
43975: AND
43976: IFFALSE 44102
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
43978: LD_VAR 0 3
43982: PPUSH
43983: LD_EXP 133
43987: PUSH
43988: LD_VAR 0 2
43992: ARRAY
43993: PUSH
43994: LD_INT 1
43996: ARRAY
43997: PPUSH
43998: CALL 75299 0 2
44002: IFFALSE 44102
// begin ComCancel ( j ) ;
44004: LD_VAR 0 3
44008: PPUSH
44009: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
44013: LD_VAR 0 3
44017: PPUSH
44018: LD_EXP 133
44022: PUSH
44023: LD_VAR 0 2
44027: ARRAY
44028: PUSH
44029: LD_INT 1
44031: ARRAY
44032: PPUSH
44033: CALL_OW 207
// if not j in mc_construct_list [ i ] then
44037: LD_VAR 0 3
44041: PUSH
44042: LD_EXP 106
44046: PUSH
44047: LD_VAR 0 2
44051: ARRAY
44052: IN
44053: NOT
44054: IFFALSE 44100
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
44056: LD_ADDR_EXP 106
44060: PUSH
44061: LD_EXP 106
44065: PPUSH
44066: LD_VAR 0 2
44070: PUSH
44071: LD_EXP 106
44075: PUSH
44076: LD_VAR 0 2
44080: ARRAY
44081: PUSH
44082: LD_INT 1
44084: PLUS
44085: PUSH
44086: EMPTY
44087: LIST
44088: LIST
44089: PPUSH
44090: LD_VAR 0 3
44094: PPUSH
44095: CALL 68683 0 3
44099: ST_TO_ADDR
// break ;
44100: GO 44104
// end ; end ; end ;
44102: GO 43938
44104: POP
44105: POP
// end ;
44106: GO 43698
44108: POP
44109: POP
// end ;
44110: LD_VAR 0 1
44114: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
44115: LD_INT 0
44117: PPUSH
44118: PPUSH
44119: PPUSH
44120: PPUSH
44121: PPUSH
44122: PPUSH
44123: PPUSH
44124: PPUSH
44125: PPUSH
// if not mc_bases then
44126: LD_EXP 99
44130: NOT
44131: IFFALSE 44135
// exit ;
44133: GO 44540
// for i = 1 to mc_bases do
44135: LD_ADDR_VAR 0 2
44139: PUSH
44140: DOUBLE
44141: LD_INT 1
44143: DEC
44144: ST_TO_ADDR
44145: LD_EXP 99
44149: PUSH
44150: FOR_TO
44151: IFFALSE 44538
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
44153: LD_EXP 107
44157: PUSH
44158: LD_VAR 0 2
44162: ARRAY
44163: NOT
44164: PUSH
44165: LD_EXP 99
44169: PUSH
44170: LD_VAR 0 2
44174: ARRAY
44175: PPUSH
44176: LD_INT 30
44178: PUSH
44179: LD_INT 3
44181: PUSH
44182: EMPTY
44183: LIST
44184: LIST
44185: PPUSH
44186: CALL_OW 72
44190: NOT
44191: OR
44192: IFFALSE 44196
// continue ;
44194: GO 44150
// busy := false ;
44196: LD_ADDR_VAR 0 8
44200: PUSH
44201: LD_INT 0
44203: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
44204: LD_ADDR_VAR 0 4
44208: PUSH
44209: LD_EXP 99
44213: PUSH
44214: LD_VAR 0 2
44218: ARRAY
44219: PPUSH
44220: LD_INT 30
44222: PUSH
44223: LD_INT 3
44225: PUSH
44226: EMPTY
44227: LIST
44228: LIST
44229: PPUSH
44230: CALL_OW 72
44234: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
44235: LD_ADDR_VAR 0 6
44239: PUSH
44240: LD_EXP 107
44244: PUSH
44245: LD_VAR 0 2
44249: ARRAY
44250: PPUSH
44251: LD_INT 2
44253: PUSH
44254: LD_INT 30
44256: PUSH
44257: LD_INT 32
44259: PUSH
44260: EMPTY
44261: LIST
44262: LIST
44263: PUSH
44264: LD_INT 30
44266: PUSH
44267: LD_INT 33
44269: PUSH
44270: EMPTY
44271: LIST
44272: LIST
44273: PUSH
44274: EMPTY
44275: LIST
44276: LIST
44277: LIST
44278: PPUSH
44279: CALL_OW 72
44283: ST_TO_ADDR
// if not t then
44284: LD_VAR 0 6
44288: NOT
44289: IFFALSE 44293
// continue ;
44291: GO 44150
// for j in tmp do
44293: LD_ADDR_VAR 0 3
44297: PUSH
44298: LD_VAR 0 4
44302: PUSH
44303: FOR_IN
44304: IFFALSE 44334
// if not BuildingStatus ( j ) = bs_idle then
44306: LD_VAR 0 3
44310: PPUSH
44311: CALL_OW 461
44315: PUSH
44316: LD_INT 2
44318: EQUAL
44319: NOT
44320: IFFALSE 44332
// begin busy := true ;
44322: LD_ADDR_VAR 0 8
44326: PUSH
44327: LD_INT 1
44329: ST_TO_ADDR
// break ;
44330: GO 44334
// end ;
44332: GO 44303
44334: POP
44335: POP
// if busy then
44336: LD_VAR 0 8
44340: IFFALSE 44344
// continue ;
44342: GO 44150
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
44344: LD_ADDR_VAR 0 7
44348: PUSH
44349: LD_VAR 0 6
44353: PPUSH
44354: LD_INT 35
44356: PUSH
44357: LD_INT 0
44359: PUSH
44360: EMPTY
44361: LIST
44362: LIST
44363: PPUSH
44364: CALL_OW 72
44368: ST_TO_ADDR
// if tw then
44369: LD_VAR 0 7
44373: IFFALSE 44450
// begin tw := tw [ 1 ] ;
44375: LD_ADDR_VAR 0 7
44379: PUSH
44380: LD_VAR 0 7
44384: PUSH
44385: LD_INT 1
44387: ARRAY
44388: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
44389: LD_ADDR_VAR 0 9
44393: PUSH
44394: LD_VAR 0 7
44398: PPUSH
44399: LD_EXP 124
44403: PUSH
44404: LD_VAR 0 2
44408: ARRAY
44409: PPUSH
44410: CALL 73653 0 2
44414: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
44415: LD_EXP 138
44419: PUSH
44420: LD_VAR 0 2
44424: ARRAY
44425: IFFALSE 44448
// if not weapon in mc_allowed_tower_weapons [ i ] then
44427: LD_VAR 0 9
44431: PUSH
44432: LD_EXP 138
44436: PUSH
44437: LD_VAR 0 2
44441: ARRAY
44442: IN
44443: NOT
44444: IFFALSE 44448
// continue ;
44446: GO 44150
// end else
44448: GO 44513
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
44450: LD_ADDR_VAR 0 5
44454: PUSH
44455: LD_EXP 107
44459: PUSH
44460: LD_VAR 0 2
44464: ARRAY
44465: PPUSH
44466: LD_VAR 0 4
44470: PPUSH
44471: CALL 103792 0 2
44475: ST_TO_ADDR
// if not tmp2 then
44476: LD_VAR 0 5
44480: NOT
44481: IFFALSE 44485
// continue ;
44483: GO 44150
// tw := tmp2 [ 1 ] ;
44485: LD_ADDR_VAR 0 7
44489: PUSH
44490: LD_VAR 0 5
44494: PUSH
44495: LD_INT 1
44497: ARRAY
44498: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
44499: LD_ADDR_VAR 0 9
44503: PUSH
44504: LD_VAR 0 5
44508: PUSH
44509: LD_INT 2
44511: ARRAY
44512: ST_TO_ADDR
// end ; if not weapon then
44513: LD_VAR 0 9
44517: NOT
44518: IFFALSE 44522
// continue ;
44520: GO 44150
// ComPlaceWeapon ( tw , weapon ) ;
44522: LD_VAR 0 7
44526: PPUSH
44527: LD_VAR 0 9
44531: PPUSH
44532: CALL_OW 148
// end ;
44536: GO 44150
44538: POP
44539: POP
// end ;
44540: LD_VAR 0 1
44544: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
44545: LD_INT 0
44547: PPUSH
44548: PPUSH
44549: PPUSH
44550: PPUSH
44551: PPUSH
44552: PPUSH
// if not mc_bases then
44553: LD_EXP 99
44557: NOT
44558: IFFALSE 44562
// exit ;
44560: GO 45574
// for i = 1 to mc_bases do
44562: LD_ADDR_VAR 0 2
44566: PUSH
44567: DOUBLE
44568: LD_INT 1
44570: DEC
44571: ST_TO_ADDR
44572: LD_EXP 99
44576: PUSH
44577: FOR_TO
44578: IFFALSE 45572
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
44580: LD_EXP 112
44584: PUSH
44585: LD_VAR 0 2
44589: ARRAY
44590: NOT
44591: PUSH
44592: LD_EXP 112
44596: PUSH
44597: LD_VAR 0 2
44601: ARRAY
44602: PUSH
44603: LD_EXP 113
44607: PUSH
44608: LD_VAR 0 2
44612: ARRAY
44613: EQUAL
44614: OR
44615: IFFALSE 44619
// continue ;
44617: GO 44577
// if mc_miners [ i ] then
44619: LD_EXP 113
44623: PUSH
44624: LD_VAR 0 2
44628: ARRAY
44629: IFFALSE 45259
// begin k := 1 ;
44631: LD_ADDR_VAR 0 4
44635: PUSH
44636: LD_INT 1
44638: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
44639: LD_ADDR_VAR 0 3
44643: PUSH
44644: DOUBLE
44645: LD_EXP 113
44649: PUSH
44650: LD_VAR 0 2
44654: ARRAY
44655: INC
44656: ST_TO_ADDR
44657: LD_INT 1
44659: PUSH
44660: FOR_DOWNTO
44661: IFFALSE 45257
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
44663: LD_EXP 113
44667: PUSH
44668: LD_VAR 0 2
44672: ARRAY
44673: PUSH
44674: LD_VAR 0 3
44678: ARRAY
44679: PPUSH
44680: CALL_OW 301
44684: PUSH
44685: LD_EXP 113
44689: PUSH
44690: LD_VAR 0 2
44694: ARRAY
44695: PUSH
44696: LD_VAR 0 3
44700: ARRAY
44701: PPUSH
44702: CALL_OW 257
44706: PUSH
44707: LD_INT 1
44709: NONEQUAL
44710: OR
44711: IFFALSE 44774
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
44713: LD_ADDR_VAR 0 5
44717: PUSH
44718: LD_EXP 113
44722: PUSH
44723: LD_VAR 0 2
44727: ARRAY
44728: PUSH
44729: LD_EXP 113
44733: PUSH
44734: LD_VAR 0 2
44738: ARRAY
44739: PUSH
44740: LD_VAR 0 3
44744: ARRAY
44745: DIFF
44746: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
44747: LD_ADDR_EXP 113
44751: PUSH
44752: LD_EXP 113
44756: PPUSH
44757: LD_VAR 0 2
44761: PPUSH
44762: LD_VAR 0 5
44766: PPUSH
44767: CALL_OW 1
44771: ST_TO_ADDR
// continue ;
44772: GO 44660
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
44774: LD_EXP 113
44778: PUSH
44779: LD_VAR 0 2
44783: ARRAY
44784: PUSH
44785: LD_VAR 0 3
44789: ARRAY
44790: PPUSH
44791: CALL 68619 0 1
44795: PUSH
44796: LD_EXP 113
44800: PUSH
44801: LD_VAR 0 2
44805: ARRAY
44806: PUSH
44807: LD_VAR 0 3
44811: ARRAY
44812: PPUSH
44813: CALL_OW 255
44817: PPUSH
44818: LD_EXP 112
44822: PUSH
44823: LD_VAR 0 2
44827: ARRAY
44828: PUSH
44829: LD_VAR 0 4
44833: ARRAY
44834: PUSH
44835: LD_INT 1
44837: ARRAY
44838: PPUSH
44839: LD_EXP 112
44843: PUSH
44844: LD_VAR 0 2
44848: ARRAY
44849: PUSH
44850: LD_VAR 0 4
44854: ARRAY
44855: PUSH
44856: LD_INT 2
44858: ARRAY
44859: PPUSH
44860: LD_INT 15
44862: PPUSH
44863: CALL 69579 0 4
44867: PUSH
44868: LD_INT 4
44870: ARRAY
44871: PUSH
44872: LD_EXP 113
44876: PUSH
44877: LD_VAR 0 2
44881: ARRAY
44882: PUSH
44883: LD_VAR 0 3
44887: ARRAY
44888: PPUSH
44889: LD_INT 10
44891: PPUSH
44892: CALL 71276 0 2
44896: PUSH
44897: LD_INT 4
44899: ARRAY
44900: OR
44901: AND
44902: IFFALSE 44925
// ComStop ( mc_miners [ i ] [ j ] ) ;
44904: LD_EXP 113
44908: PUSH
44909: LD_VAR 0 2
44913: ARRAY
44914: PUSH
44915: LD_VAR 0 3
44919: ARRAY
44920: PPUSH
44921: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
44925: LD_EXP 113
44929: PUSH
44930: LD_VAR 0 2
44934: ARRAY
44935: PUSH
44936: LD_VAR 0 3
44940: ARRAY
44941: PPUSH
44942: CALL_OW 257
44946: PUSH
44947: LD_INT 1
44949: EQUAL
44950: PUSH
44951: LD_EXP 113
44955: PUSH
44956: LD_VAR 0 2
44960: ARRAY
44961: PUSH
44962: LD_VAR 0 3
44966: ARRAY
44967: PPUSH
44968: CALL_OW 459
44972: NOT
44973: AND
44974: PUSH
44975: LD_EXP 113
44979: PUSH
44980: LD_VAR 0 2
44984: ARRAY
44985: PUSH
44986: LD_VAR 0 3
44990: ARRAY
44991: PPUSH
44992: CALL_OW 255
44996: PPUSH
44997: LD_EXP 112
45001: PUSH
45002: LD_VAR 0 2
45006: ARRAY
45007: PUSH
45008: LD_VAR 0 4
45012: ARRAY
45013: PUSH
45014: LD_INT 1
45016: ARRAY
45017: PPUSH
45018: LD_EXP 112
45022: PUSH
45023: LD_VAR 0 2
45027: ARRAY
45028: PUSH
45029: LD_VAR 0 4
45033: ARRAY
45034: PUSH
45035: LD_INT 2
45037: ARRAY
45038: PPUSH
45039: LD_INT 15
45041: PPUSH
45042: CALL 69579 0 4
45046: PUSH
45047: LD_INT 4
45049: ARRAY
45050: PUSH
45051: LD_INT 0
45053: EQUAL
45054: AND
45055: PUSH
45056: LD_EXP 113
45060: PUSH
45061: LD_VAR 0 2
45065: ARRAY
45066: PUSH
45067: LD_VAR 0 3
45071: ARRAY
45072: PPUSH
45073: CALL_OW 314
45077: NOT
45078: AND
45079: IFFALSE 45255
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
45081: LD_EXP 113
45085: PUSH
45086: LD_VAR 0 2
45090: ARRAY
45091: PUSH
45092: LD_VAR 0 3
45096: ARRAY
45097: PPUSH
45098: CALL_OW 310
45102: IFFALSE 45125
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
45104: LD_EXP 113
45108: PUSH
45109: LD_VAR 0 2
45113: ARRAY
45114: PUSH
45115: LD_VAR 0 3
45119: ARRAY
45120: PPUSH
45121: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
45125: LD_EXP 113
45129: PUSH
45130: LD_VAR 0 2
45134: ARRAY
45135: PUSH
45136: LD_VAR 0 3
45140: ARRAY
45141: PPUSH
45142: CALL_OW 314
45146: NOT
45147: IFFALSE 45215
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
45149: LD_EXP 113
45153: PUSH
45154: LD_VAR 0 2
45158: ARRAY
45159: PUSH
45160: LD_VAR 0 3
45164: ARRAY
45165: PPUSH
45166: LD_EXP 112
45170: PUSH
45171: LD_VAR 0 2
45175: ARRAY
45176: PUSH
45177: LD_VAR 0 4
45181: ARRAY
45182: PUSH
45183: LD_INT 1
45185: ARRAY
45186: PPUSH
45187: LD_EXP 112
45191: PUSH
45192: LD_VAR 0 2
45196: ARRAY
45197: PUSH
45198: LD_VAR 0 4
45202: ARRAY
45203: PUSH
45204: LD_INT 2
45206: ARRAY
45207: PPUSH
45208: LD_INT 0
45210: PPUSH
45211: CALL_OW 193
// k := k + 1 ;
45215: LD_ADDR_VAR 0 4
45219: PUSH
45220: LD_VAR 0 4
45224: PUSH
45225: LD_INT 1
45227: PLUS
45228: ST_TO_ADDR
// if k > mc_mines [ i ] then
45229: LD_VAR 0 4
45233: PUSH
45234: LD_EXP 112
45238: PUSH
45239: LD_VAR 0 2
45243: ARRAY
45244: GREATER
45245: IFFALSE 45255
// k := 1 ;
45247: LD_ADDR_VAR 0 4
45251: PUSH
45252: LD_INT 1
45254: ST_TO_ADDR
// end ; end ;
45255: GO 44660
45257: POP
45258: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
45259: LD_ADDR_VAR 0 5
45263: PUSH
45264: LD_EXP 99
45268: PUSH
45269: LD_VAR 0 2
45273: ARRAY
45274: PPUSH
45275: LD_INT 2
45277: PUSH
45278: LD_INT 30
45280: PUSH
45281: LD_INT 4
45283: PUSH
45284: EMPTY
45285: LIST
45286: LIST
45287: PUSH
45288: LD_INT 30
45290: PUSH
45291: LD_INT 5
45293: PUSH
45294: EMPTY
45295: LIST
45296: LIST
45297: PUSH
45298: LD_INT 30
45300: PUSH
45301: LD_INT 32
45303: PUSH
45304: EMPTY
45305: LIST
45306: LIST
45307: PUSH
45308: EMPTY
45309: LIST
45310: LIST
45311: LIST
45312: LIST
45313: PPUSH
45314: CALL_OW 72
45318: ST_TO_ADDR
// if not tmp then
45319: LD_VAR 0 5
45323: NOT
45324: IFFALSE 45328
// continue ;
45326: GO 44577
// list := [ ] ;
45328: LD_ADDR_VAR 0 6
45332: PUSH
45333: EMPTY
45334: ST_TO_ADDR
// for j in tmp do
45335: LD_ADDR_VAR 0 3
45339: PUSH
45340: LD_VAR 0 5
45344: PUSH
45345: FOR_IN
45346: IFFALSE 45415
// begin for k in UnitsInside ( j ) do
45348: LD_ADDR_VAR 0 4
45352: PUSH
45353: LD_VAR 0 3
45357: PPUSH
45358: CALL_OW 313
45362: PUSH
45363: FOR_IN
45364: IFFALSE 45411
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
45366: LD_VAR 0 4
45370: PPUSH
45371: CALL_OW 257
45375: PUSH
45376: LD_INT 1
45378: EQUAL
45379: PUSH
45380: LD_VAR 0 4
45384: PPUSH
45385: CALL_OW 459
45389: NOT
45390: AND
45391: IFFALSE 45409
// list := list ^ k ;
45393: LD_ADDR_VAR 0 6
45397: PUSH
45398: LD_VAR 0 6
45402: PUSH
45403: LD_VAR 0 4
45407: ADD
45408: ST_TO_ADDR
45409: GO 45363
45411: POP
45412: POP
// end ;
45413: GO 45345
45415: POP
45416: POP
// list := list diff mc_miners [ i ] ;
45417: LD_ADDR_VAR 0 6
45421: PUSH
45422: LD_VAR 0 6
45426: PUSH
45427: LD_EXP 113
45431: PUSH
45432: LD_VAR 0 2
45436: ARRAY
45437: DIFF
45438: ST_TO_ADDR
// if not list then
45439: LD_VAR 0 6
45443: NOT
45444: IFFALSE 45448
// continue ;
45446: GO 44577
// k := mc_mines [ i ] - mc_miners [ i ] ;
45448: LD_ADDR_VAR 0 4
45452: PUSH
45453: LD_EXP 112
45457: PUSH
45458: LD_VAR 0 2
45462: ARRAY
45463: PUSH
45464: LD_EXP 113
45468: PUSH
45469: LD_VAR 0 2
45473: ARRAY
45474: MINUS
45475: ST_TO_ADDR
// if k > list then
45476: LD_VAR 0 4
45480: PUSH
45481: LD_VAR 0 6
45485: GREATER
45486: IFFALSE 45498
// k := list ;
45488: LD_ADDR_VAR 0 4
45492: PUSH
45493: LD_VAR 0 6
45497: ST_TO_ADDR
// for j = 1 to k do
45498: LD_ADDR_VAR 0 3
45502: PUSH
45503: DOUBLE
45504: LD_INT 1
45506: DEC
45507: ST_TO_ADDR
45508: LD_VAR 0 4
45512: PUSH
45513: FOR_TO
45514: IFFALSE 45568
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
45516: LD_ADDR_EXP 113
45520: PUSH
45521: LD_EXP 113
45525: PPUSH
45526: LD_VAR 0 2
45530: PUSH
45531: LD_EXP 113
45535: PUSH
45536: LD_VAR 0 2
45540: ARRAY
45541: PUSH
45542: LD_INT 1
45544: PLUS
45545: PUSH
45546: EMPTY
45547: LIST
45548: LIST
45549: PPUSH
45550: LD_VAR 0 6
45554: PUSH
45555: LD_VAR 0 3
45559: ARRAY
45560: PPUSH
45561: CALL 68683 0 3
45565: ST_TO_ADDR
45566: GO 45513
45568: POP
45569: POP
// end ;
45570: GO 44577
45572: POP
45573: POP
// end ;
45574: LD_VAR 0 1
45578: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
45579: LD_INT 0
45581: PPUSH
45582: PPUSH
45583: PPUSH
45584: PPUSH
45585: PPUSH
45586: PPUSH
45587: PPUSH
45588: PPUSH
45589: PPUSH
45590: PPUSH
// if not mc_bases then
45591: LD_EXP 99
45595: NOT
45596: IFFALSE 45600
// exit ;
45598: GO 47331
// for i = 1 to mc_bases do
45600: LD_ADDR_VAR 0 2
45604: PUSH
45605: DOUBLE
45606: LD_INT 1
45608: DEC
45609: ST_TO_ADDR
45610: LD_EXP 99
45614: PUSH
45615: FOR_TO
45616: IFFALSE 47329
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
45618: LD_EXP 99
45622: PUSH
45623: LD_VAR 0 2
45627: ARRAY
45628: NOT
45629: PUSH
45630: LD_EXP 106
45634: PUSH
45635: LD_VAR 0 2
45639: ARRAY
45640: OR
45641: IFFALSE 45645
// continue ;
45643: GO 45615
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
45645: LD_EXP 115
45649: PUSH
45650: LD_VAR 0 2
45654: ARRAY
45655: NOT
45656: PUSH
45657: LD_EXP 116
45661: PUSH
45662: LD_VAR 0 2
45666: ARRAY
45667: AND
45668: IFFALSE 45706
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
45670: LD_ADDR_EXP 116
45674: PUSH
45675: LD_EXP 116
45679: PPUSH
45680: LD_VAR 0 2
45684: PPUSH
45685: EMPTY
45686: PPUSH
45687: CALL_OW 1
45691: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
45692: LD_VAR 0 2
45696: PPUSH
45697: LD_INT 107
45699: PPUSH
45700: CALL 36795 0 2
// continue ;
45704: GO 45615
// end ; target := [ ] ;
45706: LD_ADDR_VAR 0 6
45710: PUSH
45711: EMPTY
45712: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
45713: LD_ADDR_VAR 0 3
45717: PUSH
45718: DOUBLE
45719: LD_EXP 115
45723: PUSH
45724: LD_VAR 0 2
45728: ARRAY
45729: INC
45730: ST_TO_ADDR
45731: LD_INT 1
45733: PUSH
45734: FOR_DOWNTO
45735: IFFALSE 45995
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
45737: LD_EXP 115
45741: PUSH
45742: LD_VAR 0 2
45746: ARRAY
45747: PUSH
45748: LD_VAR 0 3
45752: ARRAY
45753: PUSH
45754: LD_INT 2
45756: ARRAY
45757: PPUSH
45758: LD_EXP 115
45762: PUSH
45763: LD_VAR 0 2
45767: ARRAY
45768: PUSH
45769: LD_VAR 0 3
45773: ARRAY
45774: PUSH
45775: LD_INT 3
45777: ARRAY
45778: PPUSH
45779: CALL_OW 488
45783: PUSH
45784: LD_EXP 115
45788: PUSH
45789: LD_VAR 0 2
45793: ARRAY
45794: PUSH
45795: LD_VAR 0 3
45799: ARRAY
45800: PUSH
45801: LD_INT 2
45803: ARRAY
45804: PPUSH
45805: LD_EXP 115
45809: PUSH
45810: LD_VAR 0 2
45814: ARRAY
45815: PUSH
45816: LD_VAR 0 3
45820: ARRAY
45821: PUSH
45822: LD_INT 3
45824: ARRAY
45825: PPUSH
45826: CALL_OW 284
45830: PUSH
45831: LD_INT 0
45833: EQUAL
45834: AND
45835: IFFALSE 45890
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
45837: LD_ADDR_VAR 0 5
45841: PUSH
45842: LD_EXP 115
45846: PUSH
45847: LD_VAR 0 2
45851: ARRAY
45852: PPUSH
45853: LD_VAR 0 3
45857: PPUSH
45858: CALL_OW 3
45862: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
45863: LD_ADDR_EXP 115
45867: PUSH
45868: LD_EXP 115
45872: PPUSH
45873: LD_VAR 0 2
45877: PPUSH
45878: LD_VAR 0 5
45882: PPUSH
45883: CALL_OW 1
45887: ST_TO_ADDR
// continue ;
45888: GO 45734
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
45890: LD_EXP 99
45894: PUSH
45895: LD_VAR 0 2
45899: ARRAY
45900: PUSH
45901: LD_INT 1
45903: ARRAY
45904: PPUSH
45905: CALL_OW 255
45909: PPUSH
45910: LD_EXP 115
45914: PUSH
45915: LD_VAR 0 2
45919: ARRAY
45920: PUSH
45921: LD_VAR 0 3
45925: ARRAY
45926: PUSH
45927: LD_INT 2
45929: ARRAY
45930: PPUSH
45931: LD_EXP 115
45935: PUSH
45936: LD_VAR 0 2
45940: ARRAY
45941: PUSH
45942: LD_VAR 0 3
45946: ARRAY
45947: PUSH
45948: LD_INT 3
45950: ARRAY
45951: PPUSH
45952: LD_INT 30
45954: PPUSH
45955: CALL 69579 0 4
45959: PUSH
45960: LD_INT 4
45962: ARRAY
45963: PUSH
45964: LD_INT 0
45966: EQUAL
45967: IFFALSE 45993
// begin target := mc_crates [ i ] [ j ] ;
45969: LD_ADDR_VAR 0 6
45973: PUSH
45974: LD_EXP 115
45978: PUSH
45979: LD_VAR 0 2
45983: ARRAY
45984: PUSH
45985: LD_VAR 0 3
45989: ARRAY
45990: ST_TO_ADDR
// break ;
45991: GO 45995
// end ; end ;
45993: GO 45734
45995: POP
45996: POP
// if not target then
45997: LD_VAR 0 6
46001: NOT
46002: IFFALSE 46006
// continue ;
46004: GO 45615
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
46006: LD_ADDR_VAR 0 7
46010: PUSH
46011: LD_EXP 118
46015: PUSH
46016: LD_VAR 0 2
46020: ARRAY
46021: PPUSH
46022: LD_INT 2
46024: PUSH
46025: LD_INT 3
46027: PUSH
46028: LD_INT 58
46030: PUSH
46031: EMPTY
46032: LIST
46033: PUSH
46034: EMPTY
46035: LIST
46036: LIST
46037: PUSH
46038: LD_INT 61
46040: PUSH
46041: EMPTY
46042: LIST
46043: PUSH
46044: LD_INT 33
46046: PUSH
46047: LD_INT 5
46049: PUSH
46050: EMPTY
46051: LIST
46052: LIST
46053: PUSH
46054: LD_INT 33
46056: PUSH
46057: LD_INT 3
46059: PUSH
46060: EMPTY
46061: LIST
46062: LIST
46063: PUSH
46064: EMPTY
46065: LIST
46066: LIST
46067: LIST
46068: LIST
46069: LIST
46070: PUSH
46071: LD_INT 2
46073: PUSH
46074: LD_INT 34
46076: PUSH
46077: LD_INT 32
46079: PUSH
46080: EMPTY
46081: LIST
46082: LIST
46083: PUSH
46084: LD_INT 34
46086: PUSH
46087: LD_INT 51
46089: PUSH
46090: EMPTY
46091: LIST
46092: LIST
46093: PUSH
46094: LD_INT 34
46096: PUSH
46097: LD_INT 12
46099: PUSH
46100: EMPTY
46101: LIST
46102: LIST
46103: PUSH
46104: EMPTY
46105: LIST
46106: LIST
46107: LIST
46108: LIST
46109: PUSH
46110: EMPTY
46111: LIST
46112: LIST
46113: PPUSH
46114: CALL_OW 72
46118: ST_TO_ADDR
// if not cargo then
46119: LD_VAR 0 7
46123: NOT
46124: IFFALSE 46767
// begin if mc_crates_collector [ i ] < 5 then
46126: LD_EXP 116
46130: PUSH
46131: LD_VAR 0 2
46135: ARRAY
46136: PUSH
46137: LD_INT 5
46139: LESS
46140: IFFALSE 46506
// begin if mc_ape [ i ] then
46142: LD_EXP 128
46146: PUSH
46147: LD_VAR 0 2
46151: ARRAY
46152: IFFALSE 46199
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
46154: LD_ADDR_VAR 0 5
46158: PUSH
46159: LD_EXP 128
46163: PUSH
46164: LD_VAR 0 2
46168: ARRAY
46169: PPUSH
46170: LD_INT 25
46172: PUSH
46173: LD_INT 16
46175: PUSH
46176: EMPTY
46177: LIST
46178: LIST
46179: PUSH
46180: LD_INT 24
46182: PUSH
46183: LD_INT 750
46185: PUSH
46186: EMPTY
46187: LIST
46188: LIST
46189: PUSH
46190: EMPTY
46191: LIST
46192: LIST
46193: PPUSH
46194: CALL_OW 72
46198: ST_TO_ADDR
// if not tmp then
46199: LD_VAR 0 5
46203: NOT
46204: IFFALSE 46251
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
46206: LD_ADDR_VAR 0 5
46210: PUSH
46211: LD_EXP 99
46215: PUSH
46216: LD_VAR 0 2
46220: ARRAY
46221: PPUSH
46222: LD_INT 25
46224: PUSH
46225: LD_INT 2
46227: PUSH
46228: EMPTY
46229: LIST
46230: LIST
46231: PUSH
46232: LD_INT 24
46234: PUSH
46235: LD_INT 750
46237: PUSH
46238: EMPTY
46239: LIST
46240: LIST
46241: PUSH
46242: EMPTY
46243: LIST
46244: LIST
46245: PPUSH
46246: CALL_OW 72
46250: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
46251: LD_EXP 128
46255: PUSH
46256: LD_VAR 0 2
46260: ARRAY
46261: PUSH
46262: LD_EXP 99
46266: PUSH
46267: LD_VAR 0 2
46271: ARRAY
46272: PPUSH
46273: LD_INT 25
46275: PUSH
46276: LD_INT 2
46278: PUSH
46279: EMPTY
46280: LIST
46281: LIST
46282: PUSH
46283: LD_INT 24
46285: PUSH
46286: LD_INT 750
46288: PUSH
46289: EMPTY
46290: LIST
46291: LIST
46292: PUSH
46293: EMPTY
46294: LIST
46295: LIST
46296: PPUSH
46297: CALL_OW 72
46301: AND
46302: PUSH
46303: LD_VAR 0 5
46307: PUSH
46308: LD_INT 5
46310: LESS
46311: AND
46312: IFFALSE 46394
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
46314: LD_ADDR_VAR 0 3
46318: PUSH
46319: LD_EXP 99
46323: PUSH
46324: LD_VAR 0 2
46328: ARRAY
46329: PPUSH
46330: LD_INT 25
46332: PUSH
46333: LD_INT 2
46335: PUSH
46336: EMPTY
46337: LIST
46338: LIST
46339: PUSH
46340: LD_INT 24
46342: PUSH
46343: LD_INT 750
46345: PUSH
46346: EMPTY
46347: LIST
46348: LIST
46349: PUSH
46350: EMPTY
46351: LIST
46352: LIST
46353: PPUSH
46354: CALL_OW 72
46358: PUSH
46359: FOR_IN
46360: IFFALSE 46392
// begin tmp := tmp union j ;
46362: LD_ADDR_VAR 0 5
46366: PUSH
46367: LD_VAR 0 5
46371: PUSH
46372: LD_VAR 0 3
46376: UNION
46377: ST_TO_ADDR
// if tmp >= 5 then
46378: LD_VAR 0 5
46382: PUSH
46383: LD_INT 5
46385: GREATEREQUAL
46386: IFFALSE 46390
// break ;
46388: GO 46392
// end ;
46390: GO 46359
46392: POP
46393: POP
// end ; if not tmp then
46394: LD_VAR 0 5
46398: NOT
46399: IFFALSE 46403
// continue ;
46401: GO 45615
// for j in tmp do
46403: LD_ADDR_VAR 0 3
46407: PUSH
46408: LD_VAR 0 5
46412: PUSH
46413: FOR_IN
46414: IFFALSE 46504
// if not GetTag ( j ) then
46416: LD_VAR 0 3
46420: PPUSH
46421: CALL_OW 110
46425: NOT
46426: IFFALSE 46502
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
46428: LD_ADDR_EXP 116
46432: PUSH
46433: LD_EXP 116
46437: PPUSH
46438: LD_VAR 0 2
46442: PUSH
46443: LD_EXP 116
46447: PUSH
46448: LD_VAR 0 2
46452: ARRAY
46453: PUSH
46454: LD_INT 1
46456: PLUS
46457: PUSH
46458: EMPTY
46459: LIST
46460: LIST
46461: PPUSH
46462: LD_VAR 0 3
46466: PPUSH
46467: CALL 68683 0 3
46471: ST_TO_ADDR
// SetTag ( j , 107 ) ;
46472: LD_VAR 0 3
46476: PPUSH
46477: LD_INT 107
46479: PPUSH
46480: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
46484: LD_EXP 116
46488: PUSH
46489: LD_VAR 0 2
46493: ARRAY
46494: PUSH
46495: LD_INT 5
46497: GREATEREQUAL
46498: IFFALSE 46502
// break ;
46500: GO 46504
// end ;
46502: GO 46413
46504: POP
46505: POP
// end ; if mc_crates_collector [ i ] and target then
46506: LD_EXP 116
46510: PUSH
46511: LD_VAR 0 2
46515: ARRAY
46516: PUSH
46517: LD_VAR 0 6
46521: AND
46522: IFFALSE 46765
// begin if mc_crates_collector [ i ] < target [ 1 ] then
46524: LD_EXP 116
46528: PUSH
46529: LD_VAR 0 2
46533: ARRAY
46534: PUSH
46535: LD_VAR 0 6
46539: PUSH
46540: LD_INT 1
46542: ARRAY
46543: LESS
46544: IFFALSE 46564
// tmp := mc_crates_collector [ i ] else
46546: LD_ADDR_VAR 0 5
46550: PUSH
46551: LD_EXP 116
46555: PUSH
46556: LD_VAR 0 2
46560: ARRAY
46561: ST_TO_ADDR
46562: GO 46578
// tmp := target [ 1 ] ;
46564: LD_ADDR_VAR 0 5
46568: PUSH
46569: LD_VAR 0 6
46573: PUSH
46574: LD_INT 1
46576: ARRAY
46577: ST_TO_ADDR
// k := 0 ;
46578: LD_ADDR_VAR 0 4
46582: PUSH
46583: LD_INT 0
46585: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
46586: LD_ADDR_VAR 0 3
46590: PUSH
46591: LD_EXP 116
46595: PUSH
46596: LD_VAR 0 2
46600: ARRAY
46601: PUSH
46602: FOR_IN
46603: IFFALSE 46763
// begin k := k + 1 ;
46605: LD_ADDR_VAR 0 4
46609: PUSH
46610: LD_VAR 0 4
46614: PUSH
46615: LD_INT 1
46617: PLUS
46618: ST_TO_ADDR
// if k > tmp then
46619: LD_VAR 0 4
46623: PUSH
46624: LD_VAR 0 5
46628: GREATER
46629: IFFALSE 46633
// break ;
46631: GO 46763
// if not GetClass ( j ) in [ 2 , 16 ] then
46633: LD_VAR 0 3
46637: PPUSH
46638: CALL_OW 257
46642: PUSH
46643: LD_INT 2
46645: PUSH
46646: LD_INT 16
46648: PUSH
46649: EMPTY
46650: LIST
46651: LIST
46652: IN
46653: NOT
46654: IFFALSE 46707
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
46656: LD_ADDR_EXP 116
46660: PUSH
46661: LD_EXP 116
46665: PPUSH
46666: LD_VAR 0 2
46670: PPUSH
46671: LD_EXP 116
46675: PUSH
46676: LD_VAR 0 2
46680: ARRAY
46681: PUSH
46682: LD_VAR 0 3
46686: DIFF
46687: PPUSH
46688: CALL_OW 1
46692: ST_TO_ADDR
// SetTag ( j , 0 ) ;
46693: LD_VAR 0 3
46697: PPUSH
46698: LD_INT 0
46700: PPUSH
46701: CALL_OW 109
// continue ;
46705: GO 46602
// end ; if IsInUnit ( j ) then
46707: LD_VAR 0 3
46711: PPUSH
46712: CALL_OW 310
46716: IFFALSE 46727
// ComExitBuilding ( j ) ;
46718: LD_VAR 0 3
46722: PPUSH
46723: CALL_OW 122
// wait ( 3 ) ;
46727: LD_INT 3
46729: PPUSH
46730: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
46734: LD_VAR 0 3
46738: PPUSH
46739: LD_VAR 0 6
46743: PUSH
46744: LD_INT 2
46746: ARRAY
46747: PPUSH
46748: LD_VAR 0 6
46752: PUSH
46753: LD_INT 3
46755: ARRAY
46756: PPUSH
46757: CALL_OW 117
// end ;
46761: GO 46602
46763: POP
46764: POP
// end ; end else
46765: GO 47327
// begin for j in cargo do
46767: LD_ADDR_VAR 0 3
46771: PUSH
46772: LD_VAR 0 7
46776: PUSH
46777: FOR_IN
46778: IFFALSE 47325
// begin if GetTag ( j ) <> 0 then
46780: LD_VAR 0 3
46784: PPUSH
46785: CALL_OW 110
46789: PUSH
46790: LD_INT 0
46792: NONEQUAL
46793: IFFALSE 46797
// continue ;
46795: GO 46777
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
46797: LD_VAR 0 3
46801: PPUSH
46802: CALL_OW 256
46806: PUSH
46807: LD_INT 1000
46809: LESS
46810: PUSH
46811: LD_VAR 0 3
46815: PPUSH
46816: LD_EXP 123
46820: PUSH
46821: LD_VAR 0 2
46825: ARRAY
46826: PPUSH
46827: CALL_OW 308
46831: NOT
46832: AND
46833: IFFALSE 46855
// ComMoveToArea ( j , mc_parking [ i ] ) ;
46835: LD_VAR 0 3
46839: PPUSH
46840: LD_EXP 123
46844: PUSH
46845: LD_VAR 0 2
46849: ARRAY
46850: PPUSH
46851: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
46855: LD_VAR 0 3
46859: PPUSH
46860: CALL_OW 256
46864: PUSH
46865: LD_INT 1000
46867: LESS
46868: PUSH
46869: LD_VAR 0 3
46873: PPUSH
46874: LD_EXP 123
46878: PUSH
46879: LD_VAR 0 2
46883: ARRAY
46884: PPUSH
46885: CALL_OW 308
46889: AND
46890: IFFALSE 46894
// continue ;
46892: GO 46777
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
46894: LD_VAR 0 3
46898: PPUSH
46899: CALL_OW 262
46903: PUSH
46904: LD_INT 2
46906: EQUAL
46907: PUSH
46908: LD_VAR 0 3
46912: PPUSH
46913: CALL_OW 261
46917: PUSH
46918: LD_INT 15
46920: LESS
46921: AND
46922: IFFALSE 46926
// continue ;
46924: GO 46777
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
46926: LD_VAR 0 3
46930: PPUSH
46931: CALL_OW 262
46935: PUSH
46936: LD_INT 1
46938: EQUAL
46939: PUSH
46940: LD_VAR 0 3
46944: PPUSH
46945: CALL_OW 261
46949: PUSH
46950: LD_INT 10
46952: LESS
46953: AND
46954: IFFALSE 47264
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46956: LD_ADDR_VAR 0 8
46960: PUSH
46961: LD_EXP 99
46965: PUSH
46966: LD_VAR 0 2
46970: ARRAY
46971: PPUSH
46972: LD_INT 2
46974: PUSH
46975: LD_INT 30
46977: PUSH
46978: LD_INT 0
46980: PUSH
46981: EMPTY
46982: LIST
46983: LIST
46984: PUSH
46985: LD_INT 30
46987: PUSH
46988: LD_INT 1
46990: PUSH
46991: EMPTY
46992: LIST
46993: LIST
46994: PUSH
46995: EMPTY
46996: LIST
46997: LIST
46998: LIST
46999: PPUSH
47000: CALL_OW 72
47004: ST_TO_ADDR
// if not depot then
47005: LD_VAR 0 8
47009: NOT
47010: IFFALSE 47014
// continue ;
47012: GO 46777
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
47014: LD_VAR 0 3
47018: PPUSH
47019: LD_VAR 0 8
47023: PPUSH
47024: LD_VAR 0 3
47028: PPUSH
47029: CALL_OW 74
47033: PPUSH
47034: CALL_OW 296
47038: PUSH
47039: LD_INT 6
47041: LESS
47042: IFFALSE 47058
// SetFuel ( j , 100 ) else
47044: LD_VAR 0 3
47048: PPUSH
47049: LD_INT 100
47051: PPUSH
47052: CALL_OW 240
47056: GO 47264
// if GetFuel ( j ) = 0 then
47058: LD_VAR 0 3
47062: PPUSH
47063: CALL_OW 261
47067: PUSH
47068: LD_INT 0
47070: EQUAL
47071: IFFALSE 47264
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
47073: LD_ADDR_EXP 118
47077: PUSH
47078: LD_EXP 118
47082: PPUSH
47083: LD_VAR 0 2
47087: PPUSH
47088: LD_EXP 118
47092: PUSH
47093: LD_VAR 0 2
47097: ARRAY
47098: PUSH
47099: LD_VAR 0 3
47103: DIFF
47104: PPUSH
47105: CALL_OW 1
47109: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
47110: LD_VAR 0 3
47114: PPUSH
47115: CALL_OW 263
47119: PUSH
47120: LD_INT 1
47122: EQUAL
47123: IFFALSE 47139
// ComExitVehicle ( IsInUnit ( j ) ) ;
47125: LD_VAR 0 3
47129: PPUSH
47130: CALL_OW 310
47134: PPUSH
47135: CALL_OW 121
// if GetControl ( j ) = control_remote then
47139: LD_VAR 0 3
47143: PPUSH
47144: CALL_OW 263
47148: PUSH
47149: LD_INT 2
47151: EQUAL
47152: IFFALSE 47163
// ComUnlink ( j ) ;
47154: LD_VAR 0 3
47158: PPUSH
47159: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
47163: LD_ADDR_VAR 0 9
47167: PUSH
47168: LD_VAR 0 2
47172: PPUSH
47173: LD_INT 3
47175: PPUSH
47176: CALL 56368 0 2
47180: ST_TO_ADDR
// if fac then
47181: LD_VAR 0 9
47185: IFFALSE 47262
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
47187: LD_ADDR_VAR 0 10
47191: PUSH
47192: LD_VAR 0 9
47196: PPUSH
47197: LD_VAR 0 3
47201: PPUSH
47202: CALL_OW 265
47206: PPUSH
47207: LD_VAR 0 3
47211: PPUSH
47212: CALL_OW 262
47216: PPUSH
47217: LD_VAR 0 3
47221: PPUSH
47222: CALL_OW 263
47226: PPUSH
47227: LD_VAR 0 3
47231: PPUSH
47232: CALL_OW 264
47236: PPUSH
47237: CALL 66283 0 5
47241: ST_TO_ADDR
// if components then
47242: LD_VAR 0 10
47246: IFFALSE 47262
// MC_InsertProduceList ( i , components ) ;
47248: LD_VAR 0 2
47252: PPUSH
47253: LD_VAR 0 10
47257: PPUSH
47258: CALL 55996 0 2
// end ; continue ;
47262: GO 46777
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
47264: LD_VAR 0 3
47268: PPUSH
47269: LD_INT 1
47271: PPUSH
47272: CALL_OW 289
47276: PUSH
47277: LD_INT 100
47279: LESS
47280: PUSH
47281: LD_VAR 0 3
47285: PPUSH
47286: CALL_OW 314
47290: NOT
47291: AND
47292: IFFALSE 47321
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
47294: LD_VAR 0 3
47298: PPUSH
47299: LD_VAR 0 6
47303: PUSH
47304: LD_INT 2
47306: ARRAY
47307: PPUSH
47308: LD_VAR 0 6
47312: PUSH
47313: LD_INT 3
47315: ARRAY
47316: PPUSH
47317: CALL_OW 117
// break ;
47321: GO 47325
// end ;
47323: GO 46777
47325: POP
47326: POP
// end ; end ;
47327: GO 45615
47329: POP
47330: POP
// end ;
47331: LD_VAR 0 1
47335: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
47336: LD_INT 0
47338: PPUSH
47339: PPUSH
47340: PPUSH
47341: PPUSH
// if not mc_bases then
47342: LD_EXP 99
47346: NOT
47347: IFFALSE 47351
// exit ;
47349: GO 47512
// for i = 1 to mc_bases do
47351: LD_ADDR_VAR 0 2
47355: PUSH
47356: DOUBLE
47357: LD_INT 1
47359: DEC
47360: ST_TO_ADDR
47361: LD_EXP 99
47365: PUSH
47366: FOR_TO
47367: IFFALSE 47510
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
47369: LD_ADDR_VAR 0 4
47373: PUSH
47374: LD_EXP 118
47378: PUSH
47379: LD_VAR 0 2
47383: ARRAY
47384: PUSH
47385: LD_EXP 121
47389: PUSH
47390: LD_VAR 0 2
47394: ARRAY
47395: UNION
47396: PPUSH
47397: LD_INT 33
47399: PUSH
47400: LD_INT 2
47402: PUSH
47403: EMPTY
47404: LIST
47405: LIST
47406: PPUSH
47407: CALL_OW 72
47411: ST_TO_ADDR
// if tmp then
47412: LD_VAR 0 4
47416: IFFALSE 47508
// for j in tmp do
47418: LD_ADDR_VAR 0 3
47422: PUSH
47423: LD_VAR 0 4
47427: PUSH
47428: FOR_IN
47429: IFFALSE 47506
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
47431: LD_VAR 0 3
47435: PPUSH
47436: CALL_OW 312
47440: NOT
47441: PUSH
47442: LD_VAR 0 3
47446: PPUSH
47447: CALL_OW 256
47451: PUSH
47452: LD_INT 250
47454: GREATEREQUAL
47455: AND
47456: IFFALSE 47469
// Connect ( j ) else
47458: LD_VAR 0 3
47462: PPUSH
47463: CALL 71616 0 1
47467: GO 47504
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
47469: LD_VAR 0 3
47473: PPUSH
47474: CALL_OW 256
47478: PUSH
47479: LD_INT 250
47481: LESS
47482: PUSH
47483: LD_VAR 0 3
47487: PPUSH
47488: CALL_OW 312
47492: AND
47493: IFFALSE 47504
// ComUnlink ( j ) ;
47495: LD_VAR 0 3
47499: PPUSH
47500: CALL_OW 136
47504: GO 47428
47506: POP
47507: POP
// end ;
47508: GO 47366
47510: POP
47511: POP
// end ;
47512: LD_VAR 0 1
47516: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
47517: LD_INT 0
47519: PPUSH
47520: PPUSH
47521: PPUSH
47522: PPUSH
47523: PPUSH
// if not mc_bases then
47524: LD_EXP 99
47528: NOT
47529: IFFALSE 47533
// exit ;
47531: GO 47993
// for i = 1 to mc_bases do
47533: LD_ADDR_VAR 0 2
47537: PUSH
47538: DOUBLE
47539: LD_INT 1
47541: DEC
47542: ST_TO_ADDR
47543: LD_EXP 99
47547: PUSH
47548: FOR_TO
47549: IFFALSE 47991
// begin if not mc_produce [ i ] then
47551: LD_EXP 120
47555: PUSH
47556: LD_VAR 0 2
47560: ARRAY
47561: NOT
47562: IFFALSE 47566
// continue ;
47564: GO 47548
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
47566: LD_ADDR_VAR 0 5
47570: PUSH
47571: LD_EXP 99
47575: PUSH
47576: LD_VAR 0 2
47580: ARRAY
47581: PPUSH
47582: LD_INT 30
47584: PUSH
47585: LD_INT 3
47587: PUSH
47588: EMPTY
47589: LIST
47590: LIST
47591: PPUSH
47592: CALL_OW 72
47596: ST_TO_ADDR
// if not fac then
47597: LD_VAR 0 5
47601: NOT
47602: IFFALSE 47606
// continue ;
47604: GO 47548
// for j in fac do
47606: LD_ADDR_VAR 0 3
47610: PUSH
47611: LD_VAR 0 5
47615: PUSH
47616: FOR_IN
47617: IFFALSE 47987
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
47619: LD_VAR 0 3
47623: PPUSH
47624: CALL_OW 461
47628: PUSH
47629: LD_INT 2
47631: NONEQUAL
47632: PUSH
47633: LD_VAR 0 3
47637: PPUSH
47638: LD_INT 15
47640: PPUSH
47641: CALL 71276 0 2
47645: PUSH
47646: LD_INT 4
47648: ARRAY
47649: OR
47650: PUSH
47651: LD_VAR 0 3
47655: PPUSH
47656: CALL_OW 313
47660: PUSH
47661: LD_INT 0
47663: EQUAL
47664: OR
47665: IFFALSE 47669
// continue ;
47667: GO 47616
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
47669: LD_VAR 0 3
47673: PPUSH
47674: LD_EXP 120
47678: PUSH
47679: LD_VAR 0 2
47683: ARRAY
47684: PUSH
47685: LD_INT 1
47687: ARRAY
47688: PUSH
47689: LD_INT 1
47691: ARRAY
47692: PPUSH
47693: LD_EXP 120
47697: PUSH
47698: LD_VAR 0 2
47702: ARRAY
47703: PUSH
47704: LD_INT 1
47706: ARRAY
47707: PUSH
47708: LD_INT 2
47710: ARRAY
47711: PPUSH
47712: LD_EXP 120
47716: PUSH
47717: LD_VAR 0 2
47721: ARRAY
47722: PUSH
47723: LD_INT 1
47725: ARRAY
47726: PUSH
47727: LD_INT 3
47729: ARRAY
47730: PPUSH
47731: LD_EXP 120
47735: PUSH
47736: LD_VAR 0 2
47740: ARRAY
47741: PUSH
47742: LD_INT 1
47744: ARRAY
47745: PUSH
47746: LD_INT 4
47748: ARRAY
47749: PPUSH
47750: CALL_OW 448
47754: PUSH
47755: LD_VAR 0 3
47759: PPUSH
47760: LD_EXP 120
47764: PUSH
47765: LD_VAR 0 2
47769: ARRAY
47770: PUSH
47771: LD_INT 1
47773: ARRAY
47774: PUSH
47775: LD_INT 1
47777: ARRAY
47778: PUSH
47779: LD_EXP 120
47783: PUSH
47784: LD_VAR 0 2
47788: ARRAY
47789: PUSH
47790: LD_INT 1
47792: ARRAY
47793: PUSH
47794: LD_INT 2
47796: ARRAY
47797: PUSH
47798: LD_EXP 120
47802: PUSH
47803: LD_VAR 0 2
47807: ARRAY
47808: PUSH
47809: LD_INT 1
47811: ARRAY
47812: PUSH
47813: LD_INT 3
47815: ARRAY
47816: PUSH
47817: LD_EXP 120
47821: PUSH
47822: LD_VAR 0 2
47826: ARRAY
47827: PUSH
47828: LD_INT 1
47830: ARRAY
47831: PUSH
47832: LD_INT 4
47834: ARRAY
47835: PUSH
47836: EMPTY
47837: LIST
47838: LIST
47839: LIST
47840: LIST
47841: PPUSH
47842: CALL 74947 0 2
47846: AND
47847: IFFALSE 47985
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
47849: LD_VAR 0 3
47853: PPUSH
47854: LD_EXP 120
47858: PUSH
47859: LD_VAR 0 2
47863: ARRAY
47864: PUSH
47865: LD_INT 1
47867: ARRAY
47868: PUSH
47869: LD_INT 1
47871: ARRAY
47872: PPUSH
47873: LD_EXP 120
47877: PUSH
47878: LD_VAR 0 2
47882: ARRAY
47883: PUSH
47884: LD_INT 1
47886: ARRAY
47887: PUSH
47888: LD_INT 2
47890: ARRAY
47891: PPUSH
47892: LD_EXP 120
47896: PUSH
47897: LD_VAR 0 2
47901: ARRAY
47902: PUSH
47903: LD_INT 1
47905: ARRAY
47906: PUSH
47907: LD_INT 3
47909: ARRAY
47910: PPUSH
47911: LD_EXP 120
47915: PUSH
47916: LD_VAR 0 2
47920: ARRAY
47921: PUSH
47922: LD_INT 1
47924: ARRAY
47925: PUSH
47926: LD_INT 4
47928: ARRAY
47929: PPUSH
47930: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
47934: LD_ADDR_VAR 0 4
47938: PUSH
47939: LD_EXP 120
47943: PUSH
47944: LD_VAR 0 2
47948: ARRAY
47949: PPUSH
47950: LD_INT 1
47952: PPUSH
47953: CALL_OW 3
47957: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
47958: LD_ADDR_EXP 120
47962: PUSH
47963: LD_EXP 120
47967: PPUSH
47968: LD_VAR 0 2
47972: PPUSH
47973: LD_VAR 0 4
47977: PPUSH
47978: CALL_OW 1
47982: ST_TO_ADDR
// break ;
47983: GO 47987
// end ; end ;
47985: GO 47616
47987: POP
47988: POP
// end ;
47989: GO 47548
47991: POP
47992: POP
// end ;
47993: LD_VAR 0 1
47997: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
47998: LD_INT 0
48000: PPUSH
48001: PPUSH
48002: PPUSH
// if not mc_bases then
48003: LD_EXP 99
48007: NOT
48008: IFFALSE 48012
// exit ;
48010: GO 48101
// for i = 1 to mc_bases do
48012: LD_ADDR_VAR 0 2
48016: PUSH
48017: DOUBLE
48018: LD_INT 1
48020: DEC
48021: ST_TO_ADDR
48022: LD_EXP 99
48026: PUSH
48027: FOR_TO
48028: IFFALSE 48099
// begin if mc_attack [ i ] then
48030: LD_EXP 119
48034: PUSH
48035: LD_VAR 0 2
48039: ARRAY
48040: IFFALSE 48097
// begin tmp := mc_attack [ i ] [ 1 ] ;
48042: LD_ADDR_VAR 0 3
48046: PUSH
48047: LD_EXP 119
48051: PUSH
48052: LD_VAR 0 2
48056: ARRAY
48057: PUSH
48058: LD_INT 1
48060: ARRAY
48061: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
48062: LD_ADDR_EXP 119
48066: PUSH
48067: LD_EXP 119
48071: PPUSH
48072: LD_VAR 0 2
48076: PPUSH
48077: EMPTY
48078: PPUSH
48079: CALL_OW 1
48083: ST_TO_ADDR
// Attack ( tmp ) ;
48084: LD_VAR 0 3
48088: PPUSH
48089: CALL 97136 0 1
// exit ;
48093: POP
48094: POP
48095: GO 48101
// end ; end ;
48097: GO 48027
48099: POP
48100: POP
// end ;
48101: LD_VAR 0 1
48105: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
48106: LD_INT 0
48108: PPUSH
48109: PPUSH
48110: PPUSH
48111: PPUSH
48112: PPUSH
48113: PPUSH
48114: PPUSH
// if not mc_bases then
48115: LD_EXP 99
48119: NOT
48120: IFFALSE 48124
// exit ;
48122: GO 48728
// for i = 1 to mc_bases do
48124: LD_ADDR_VAR 0 2
48128: PUSH
48129: DOUBLE
48130: LD_INT 1
48132: DEC
48133: ST_TO_ADDR
48134: LD_EXP 99
48138: PUSH
48139: FOR_TO
48140: IFFALSE 48726
// begin if not mc_bases [ i ] then
48142: LD_EXP 99
48146: PUSH
48147: LD_VAR 0 2
48151: ARRAY
48152: NOT
48153: IFFALSE 48157
// continue ;
48155: GO 48139
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
48157: LD_ADDR_VAR 0 7
48161: PUSH
48162: LD_EXP 99
48166: PUSH
48167: LD_VAR 0 2
48171: ARRAY
48172: PUSH
48173: LD_INT 1
48175: ARRAY
48176: PPUSH
48177: CALL 65587 0 1
48181: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
48182: LD_ADDR_EXP 122
48186: PUSH
48187: LD_EXP 122
48191: PPUSH
48192: LD_VAR 0 2
48196: PPUSH
48197: LD_EXP 99
48201: PUSH
48202: LD_VAR 0 2
48206: ARRAY
48207: PUSH
48208: LD_INT 1
48210: ARRAY
48211: PPUSH
48212: CALL_OW 255
48216: PPUSH
48217: LD_EXP 124
48221: PUSH
48222: LD_VAR 0 2
48226: ARRAY
48227: PPUSH
48228: CALL 63547 0 2
48232: PPUSH
48233: CALL_OW 1
48237: ST_TO_ADDR
// if not mc_scan [ i ] then
48238: LD_EXP 122
48242: PUSH
48243: LD_VAR 0 2
48247: ARRAY
48248: NOT
48249: IFFALSE 48404
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
48251: LD_ADDR_VAR 0 4
48255: PUSH
48256: LD_EXP 99
48260: PUSH
48261: LD_VAR 0 2
48265: ARRAY
48266: PPUSH
48267: LD_INT 2
48269: PUSH
48270: LD_INT 25
48272: PUSH
48273: LD_INT 5
48275: PUSH
48276: EMPTY
48277: LIST
48278: LIST
48279: PUSH
48280: LD_INT 25
48282: PUSH
48283: LD_INT 8
48285: PUSH
48286: EMPTY
48287: LIST
48288: LIST
48289: PUSH
48290: LD_INT 25
48292: PUSH
48293: LD_INT 9
48295: PUSH
48296: EMPTY
48297: LIST
48298: LIST
48299: PUSH
48300: EMPTY
48301: LIST
48302: LIST
48303: LIST
48304: LIST
48305: PPUSH
48306: CALL_OW 72
48310: ST_TO_ADDR
// if not tmp then
48311: LD_VAR 0 4
48315: NOT
48316: IFFALSE 48320
// continue ;
48318: GO 48139
// for j in tmp do
48320: LD_ADDR_VAR 0 3
48324: PUSH
48325: LD_VAR 0 4
48329: PUSH
48330: FOR_IN
48331: IFFALSE 48402
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
48333: LD_VAR 0 3
48337: PPUSH
48338: CALL_OW 310
48342: PPUSH
48343: CALL_OW 266
48347: PUSH
48348: LD_INT 5
48350: EQUAL
48351: PUSH
48352: LD_VAR 0 3
48356: PPUSH
48357: CALL_OW 257
48361: PUSH
48362: LD_INT 1
48364: EQUAL
48365: AND
48366: PUSH
48367: LD_VAR 0 3
48371: PPUSH
48372: CALL_OW 459
48376: NOT
48377: AND
48378: PUSH
48379: LD_VAR 0 7
48383: AND
48384: IFFALSE 48400
// ComChangeProfession ( j , class ) ;
48386: LD_VAR 0 3
48390: PPUSH
48391: LD_VAR 0 7
48395: PPUSH
48396: CALL_OW 123
48400: GO 48330
48402: POP
48403: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
48404: LD_EXP 122
48408: PUSH
48409: LD_VAR 0 2
48413: ARRAY
48414: PUSH
48415: LD_EXP 121
48419: PUSH
48420: LD_VAR 0 2
48424: ARRAY
48425: NOT
48426: AND
48427: PUSH
48428: LD_EXP 99
48432: PUSH
48433: LD_VAR 0 2
48437: ARRAY
48438: PPUSH
48439: LD_INT 30
48441: PUSH
48442: LD_INT 32
48444: PUSH
48445: EMPTY
48446: LIST
48447: LIST
48448: PPUSH
48449: CALL_OW 72
48453: NOT
48454: AND
48455: PUSH
48456: LD_EXP 99
48460: PUSH
48461: LD_VAR 0 2
48465: ARRAY
48466: PPUSH
48467: LD_INT 2
48469: PUSH
48470: LD_INT 30
48472: PUSH
48473: LD_INT 4
48475: PUSH
48476: EMPTY
48477: LIST
48478: LIST
48479: PUSH
48480: LD_INT 30
48482: PUSH
48483: LD_INT 5
48485: PUSH
48486: EMPTY
48487: LIST
48488: LIST
48489: PUSH
48490: EMPTY
48491: LIST
48492: LIST
48493: LIST
48494: PPUSH
48495: CALL_OW 72
48499: NOT
48500: AND
48501: IFFALSE 48633
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
48503: LD_ADDR_VAR 0 4
48507: PUSH
48508: LD_EXP 99
48512: PUSH
48513: LD_VAR 0 2
48517: ARRAY
48518: PPUSH
48519: LD_INT 2
48521: PUSH
48522: LD_INT 25
48524: PUSH
48525: LD_INT 1
48527: PUSH
48528: EMPTY
48529: LIST
48530: LIST
48531: PUSH
48532: LD_INT 25
48534: PUSH
48535: LD_INT 5
48537: PUSH
48538: EMPTY
48539: LIST
48540: LIST
48541: PUSH
48542: LD_INT 25
48544: PUSH
48545: LD_INT 8
48547: PUSH
48548: EMPTY
48549: LIST
48550: LIST
48551: PUSH
48552: LD_INT 25
48554: PUSH
48555: LD_INT 9
48557: PUSH
48558: EMPTY
48559: LIST
48560: LIST
48561: PUSH
48562: EMPTY
48563: LIST
48564: LIST
48565: LIST
48566: LIST
48567: LIST
48568: PPUSH
48569: CALL_OW 72
48573: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
48574: LD_ADDR_VAR 0 4
48578: PUSH
48579: LD_VAR 0 4
48583: PUSH
48584: LD_VAR 0 4
48588: PPUSH
48589: LD_INT 18
48591: PPUSH
48592: CALL 101880 0 2
48596: DIFF
48597: ST_TO_ADDR
// if tmp then
48598: LD_VAR 0 4
48602: IFFALSE 48633
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
48604: LD_VAR 0 2
48608: PPUSH
48609: LD_VAR 0 4
48613: PPUSH
48614: LD_EXP 124
48618: PUSH
48619: LD_VAR 0 2
48623: ARRAY
48624: PPUSH
48625: CALL 63582 0 3
// exit ;
48629: POP
48630: POP
48631: GO 48728
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
48633: LD_EXP 122
48637: PUSH
48638: LD_VAR 0 2
48642: ARRAY
48643: PUSH
48644: LD_EXP 121
48648: PUSH
48649: LD_VAR 0 2
48653: ARRAY
48654: AND
48655: IFFALSE 48724
// begin tmp := mc_defender [ i ] ;
48657: LD_ADDR_VAR 0 4
48661: PUSH
48662: LD_EXP 121
48666: PUSH
48667: LD_VAR 0 2
48671: ARRAY
48672: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
48673: LD_ADDR_EXP 121
48677: PUSH
48678: LD_EXP 121
48682: PPUSH
48683: LD_VAR 0 2
48687: PPUSH
48688: EMPTY
48689: PPUSH
48690: CALL_OW 1
48694: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
48695: LD_VAR 0 2
48699: PPUSH
48700: LD_VAR 0 4
48704: PPUSH
48705: LD_EXP 122
48709: PUSH
48710: LD_VAR 0 2
48714: ARRAY
48715: PPUSH
48716: CALL 64080 0 3
// exit ;
48720: POP
48721: POP
48722: GO 48728
// end ; end ;
48724: GO 48139
48726: POP
48727: POP
// end ;
48728: LD_VAR 0 1
48732: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
48733: LD_INT 0
48735: PPUSH
48736: PPUSH
48737: PPUSH
48738: PPUSH
48739: PPUSH
48740: PPUSH
48741: PPUSH
48742: PPUSH
48743: PPUSH
48744: PPUSH
48745: PPUSH
// if not mc_bases then
48746: LD_EXP 99
48750: NOT
48751: IFFALSE 48755
// exit ;
48753: GO 49842
// for i = 1 to mc_bases do
48755: LD_ADDR_VAR 0 2
48759: PUSH
48760: DOUBLE
48761: LD_INT 1
48763: DEC
48764: ST_TO_ADDR
48765: LD_EXP 99
48769: PUSH
48770: FOR_TO
48771: IFFALSE 49840
// begin tmp := mc_lab [ i ] ;
48773: LD_ADDR_VAR 0 6
48777: PUSH
48778: LD_EXP 132
48782: PUSH
48783: LD_VAR 0 2
48787: ARRAY
48788: ST_TO_ADDR
// if not tmp then
48789: LD_VAR 0 6
48793: NOT
48794: IFFALSE 48798
// continue ;
48796: GO 48770
// idle_lab := 0 ;
48798: LD_ADDR_VAR 0 11
48802: PUSH
48803: LD_INT 0
48805: ST_TO_ADDR
// for j in tmp do
48806: LD_ADDR_VAR 0 3
48810: PUSH
48811: LD_VAR 0 6
48815: PUSH
48816: FOR_IN
48817: IFFALSE 49836
// begin researching := false ;
48819: LD_ADDR_VAR 0 10
48823: PUSH
48824: LD_INT 0
48826: ST_TO_ADDR
// side := GetSide ( j ) ;
48827: LD_ADDR_VAR 0 4
48831: PUSH
48832: LD_VAR 0 3
48836: PPUSH
48837: CALL_OW 255
48841: ST_TO_ADDR
// if not mc_tech [ side ] then
48842: LD_EXP 126
48846: PUSH
48847: LD_VAR 0 4
48851: ARRAY
48852: NOT
48853: IFFALSE 48857
// continue ;
48855: GO 48816
// if BuildingStatus ( j ) = bs_idle then
48857: LD_VAR 0 3
48861: PPUSH
48862: CALL_OW 461
48866: PUSH
48867: LD_INT 2
48869: EQUAL
48870: IFFALSE 49058
// begin if idle_lab and UnitsInside ( j ) < 6 then
48872: LD_VAR 0 11
48876: PUSH
48877: LD_VAR 0 3
48881: PPUSH
48882: CALL_OW 313
48886: PUSH
48887: LD_INT 6
48889: LESS
48890: AND
48891: IFFALSE 48962
// begin tmp2 := UnitsInside ( idle_lab ) ;
48893: LD_ADDR_VAR 0 9
48897: PUSH
48898: LD_VAR 0 11
48902: PPUSH
48903: CALL_OW 313
48907: ST_TO_ADDR
// if tmp2 then
48908: LD_VAR 0 9
48912: IFFALSE 48954
// for x in tmp2 do
48914: LD_ADDR_VAR 0 7
48918: PUSH
48919: LD_VAR 0 9
48923: PUSH
48924: FOR_IN
48925: IFFALSE 48952
// begin ComExitBuilding ( x ) ;
48927: LD_VAR 0 7
48931: PPUSH
48932: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
48936: LD_VAR 0 7
48940: PPUSH
48941: LD_VAR 0 3
48945: PPUSH
48946: CALL_OW 180
// end ;
48950: GO 48924
48952: POP
48953: POP
// idle_lab := 0 ;
48954: LD_ADDR_VAR 0 11
48958: PUSH
48959: LD_INT 0
48961: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
48962: LD_ADDR_VAR 0 5
48966: PUSH
48967: LD_EXP 126
48971: PUSH
48972: LD_VAR 0 4
48976: ARRAY
48977: PUSH
48978: FOR_IN
48979: IFFALSE 49039
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
48981: LD_VAR 0 3
48985: PPUSH
48986: LD_VAR 0 5
48990: PPUSH
48991: CALL_OW 430
48995: PUSH
48996: LD_VAR 0 4
49000: PPUSH
49001: LD_VAR 0 5
49005: PPUSH
49006: CALL 62652 0 2
49010: AND
49011: IFFALSE 49037
// begin researching := true ;
49013: LD_ADDR_VAR 0 10
49017: PUSH
49018: LD_INT 1
49020: ST_TO_ADDR
// ComResearch ( j , t ) ;
49021: LD_VAR 0 3
49025: PPUSH
49026: LD_VAR 0 5
49030: PPUSH
49031: CALL_OW 124
// break ;
49035: GO 49039
// end ;
49037: GO 48978
49039: POP
49040: POP
// if not researching then
49041: LD_VAR 0 10
49045: NOT
49046: IFFALSE 49058
// idle_lab := j ;
49048: LD_ADDR_VAR 0 11
49052: PUSH
49053: LD_VAR 0 3
49057: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
49058: LD_VAR 0 3
49062: PPUSH
49063: CALL_OW 461
49067: PUSH
49068: LD_INT 10
49070: EQUAL
49071: IFFALSE 49659
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
49073: LD_EXP 128
49077: PUSH
49078: LD_VAR 0 2
49082: ARRAY
49083: NOT
49084: PUSH
49085: LD_EXP 129
49089: PUSH
49090: LD_VAR 0 2
49094: ARRAY
49095: NOT
49096: AND
49097: PUSH
49098: LD_EXP 126
49102: PUSH
49103: LD_VAR 0 4
49107: ARRAY
49108: PUSH
49109: LD_INT 1
49111: GREATER
49112: AND
49113: IFFALSE 49244
// begin ComCancel ( j ) ;
49115: LD_VAR 0 3
49119: PPUSH
49120: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
49124: LD_ADDR_EXP 126
49128: PUSH
49129: LD_EXP 126
49133: PPUSH
49134: LD_VAR 0 4
49138: PPUSH
49139: LD_EXP 126
49143: PUSH
49144: LD_VAR 0 4
49148: ARRAY
49149: PPUSH
49150: LD_EXP 126
49154: PUSH
49155: LD_VAR 0 4
49159: ARRAY
49160: PUSH
49161: LD_INT 1
49163: MINUS
49164: PPUSH
49165: LD_EXP 126
49169: PUSH
49170: LD_VAR 0 4
49174: ARRAY
49175: PPUSH
49176: LD_INT 0
49178: PPUSH
49179: CALL 68101 0 4
49183: PPUSH
49184: CALL_OW 1
49188: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
49189: LD_ADDR_EXP 126
49193: PUSH
49194: LD_EXP 126
49198: PPUSH
49199: LD_VAR 0 4
49203: PPUSH
49204: LD_EXP 126
49208: PUSH
49209: LD_VAR 0 4
49213: ARRAY
49214: PPUSH
49215: LD_EXP 126
49219: PUSH
49220: LD_VAR 0 4
49224: ARRAY
49225: PPUSH
49226: LD_INT 1
49228: PPUSH
49229: LD_INT 0
49231: PPUSH
49232: CALL 68101 0 4
49236: PPUSH
49237: CALL_OW 1
49241: ST_TO_ADDR
// continue ;
49242: GO 48816
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
49244: LD_EXP 128
49248: PUSH
49249: LD_VAR 0 2
49253: ARRAY
49254: PUSH
49255: LD_EXP 129
49259: PUSH
49260: LD_VAR 0 2
49264: ARRAY
49265: NOT
49266: AND
49267: IFFALSE 49394
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
49269: LD_ADDR_EXP 129
49273: PUSH
49274: LD_EXP 129
49278: PPUSH
49279: LD_VAR 0 2
49283: PUSH
49284: LD_EXP 129
49288: PUSH
49289: LD_VAR 0 2
49293: ARRAY
49294: PUSH
49295: LD_INT 1
49297: PLUS
49298: PUSH
49299: EMPTY
49300: LIST
49301: LIST
49302: PPUSH
49303: LD_EXP 128
49307: PUSH
49308: LD_VAR 0 2
49312: ARRAY
49313: PUSH
49314: LD_INT 1
49316: ARRAY
49317: PPUSH
49318: CALL 68683 0 3
49322: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
49323: LD_EXP 128
49327: PUSH
49328: LD_VAR 0 2
49332: ARRAY
49333: PUSH
49334: LD_INT 1
49336: ARRAY
49337: PPUSH
49338: LD_INT 112
49340: PPUSH
49341: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
49345: LD_ADDR_VAR 0 9
49349: PUSH
49350: LD_EXP 128
49354: PUSH
49355: LD_VAR 0 2
49359: ARRAY
49360: PPUSH
49361: LD_INT 1
49363: PPUSH
49364: CALL_OW 3
49368: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
49369: LD_ADDR_EXP 128
49373: PUSH
49374: LD_EXP 128
49378: PPUSH
49379: LD_VAR 0 2
49383: PPUSH
49384: LD_VAR 0 9
49388: PPUSH
49389: CALL_OW 1
49393: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
49394: LD_EXP 128
49398: PUSH
49399: LD_VAR 0 2
49403: ARRAY
49404: PUSH
49405: LD_EXP 129
49409: PUSH
49410: LD_VAR 0 2
49414: ARRAY
49415: AND
49416: PUSH
49417: LD_EXP 129
49421: PUSH
49422: LD_VAR 0 2
49426: ARRAY
49427: PUSH
49428: LD_INT 1
49430: ARRAY
49431: PPUSH
49432: CALL_OW 310
49436: NOT
49437: AND
49438: PUSH
49439: LD_VAR 0 3
49443: PPUSH
49444: CALL_OW 313
49448: PUSH
49449: LD_INT 6
49451: EQUAL
49452: AND
49453: IFFALSE 49509
// begin tmp2 := UnitsInside ( j ) ;
49455: LD_ADDR_VAR 0 9
49459: PUSH
49460: LD_VAR 0 3
49464: PPUSH
49465: CALL_OW 313
49469: ST_TO_ADDR
// if tmp2 = 6 then
49470: LD_VAR 0 9
49474: PUSH
49475: LD_INT 6
49477: EQUAL
49478: IFFALSE 49509
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
49480: LD_VAR 0 9
49484: PUSH
49485: LD_INT 1
49487: ARRAY
49488: PPUSH
49489: LD_INT 112
49491: PPUSH
49492: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
49496: LD_VAR 0 9
49500: PUSH
49501: LD_INT 1
49503: ARRAY
49504: PPUSH
49505: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
49509: LD_EXP 129
49513: PUSH
49514: LD_VAR 0 2
49518: ARRAY
49519: PUSH
49520: LD_EXP 129
49524: PUSH
49525: LD_VAR 0 2
49529: ARRAY
49530: PUSH
49531: LD_INT 1
49533: ARRAY
49534: PPUSH
49535: CALL_OW 314
49539: NOT
49540: AND
49541: PUSH
49542: LD_EXP 129
49546: PUSH
49547: LD_VAR 0 2
49551: ARRAY
49552: PUSH
49553: LD_INT 1
49555: ARRAY
49556: PPUSH
49557: CALL_OW 310
49561: NOT
49562: AND
49563: IFFALSE 49589
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
49565: LD_EXP 129
49569: PUSH
49570: LD_VAR 0 2
49574: ARRAY
49575: PUSH
49576: LD_INT 1
49578: ARRAY
49579: PPUSH
49580: LD_VAR 0 3
49584: PPUSH
49585: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
49589: LD_EXP 129
49593: PUSH
49594: LD_VAR 0 2
49598: ARRAY
49599: PUSH
49600: LD_INT 1
49602: ARRAY
49603: PPUSH
49604: CALL_OW 310
49608: PUSH
49609: LD_EXP 129
49613: PUSH
49614: LD_VAR 0 2
49618: ARRAY
49619: PUSH
49620: LD_INT 1
49622: ARRAY
49623: PPUSH
49624: CALL_OW 310
49628: PPUSH
49629: CALL_OW 461
49633: PUSH
49634: LD_INT 3
49636: NONEQUAL
49637: AND
49638: IFFALSE 49659
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
49640: LD_EXP 129
49644: PUSH
49645: LD_VAR 0 2
49649: ARRAY
49650: PUSH
49651: LD_INT 1
49653: ARRAY
49654: PPUSH
49655: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
49659: LD_VAR 0 3
49663: PPUSH
49664: CALL_OW 461
49668: PUSH
49669: LD_INT 6
49671: EQUAL
49672: PUSH
49673: LD_VAR 0 6
49677: PUSH
49678: LD_INT 1
49680: GREATER
49681: AND
49682: IFFALSE 49834
// begin sci := [ ] ;
49684: LD_ADDR_VAR 0 8
49688: PUSH
49689: EMPTY
49690: ST_TO_ADDR
// for x in ( tmp diff j ) do
49691: LD_ADDR_VAR 0 7
49695: PUSH
49696: LD_VAR 0 6
49700: PUSH
49701: LD_VAR 0 3
49705: DIFF
49706: PUSH
49707: FOR_IN
49708: IFFALSE 49760
// begin if sci = 6 then
49710: LD_VAR 0 8
49714: PUSH
49715: LD_INT 6
49717: EQUAL
49718: IFFALSE 49722
// break ;
49720: GO 49760
// if BuildingStatus ( x ) = bs_idle then
49722: LD_VAR 0 7
49726: PPUSH
49727: CALL_OW 461
49731: PUSH
49732: LD_INT 2
49734: EQUAL
49735: IFFALSE 49758
// sci := sci ^ UnitsInside ( x ) ;
49737: LD_ADDR_VAR 0 8
49741: PUSH
49742: LD_VAR 0 8
49746: PUSH
49747: LD_VAR 0 7
49751: PPUSH
49752: CALL_OW 313
49756: ADD
49757: ST_TO_ADDR
// end ;
49758: GO 49707
49760: POP
49761: POP
// if not sci then
49762: LD_VAR 0 8
49766: NOT
49767: IFFALSE 49771
// continue ;
49769: GO 48816
// for x in sci do
49771: LD_ADDR_VAR 0 7
49775: PUSH
49776: LD_VAR 0 8
49780: PUSH
49781: FOR_IN
49782: IFFALSE 49832
// if IsInUnit ( x ) and not HasTask ( x ) then
49784: LD_VAR 0 7
49788: PPUSH
49789: CALL_OW 310
49793: PUSH
49794: LD_VAR 0 7
49798: PPUSH
49799: CALL_OW 314
49803: NOT
49804: AND
49805: IFFALSE 49830
// begin ComExitBuilding ( x ) ;
49807: LD_VAR 0 7
49811: PPUSH
49812: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
49816: LD_VAR 0 7
49820: PPUSH
49821: LD_VAR 0 3
49825: PPUSH
49826: CALL_OW 180
// end ;
49830: GO 49781
49832: POP
49833: POP
// end ; end ;
49834: GO 48816
49836: POP
49837: POP
// end ;
49838: GO 48770
49840: POP
49841: POP
// end ;
49842: LD_VAR 0 1
49846: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
49847: LD_INT 0
49849: PPUSH
49850: PPUSH
// if not mc_bases then
49851: LD_EXP 99
49855: NOT
49856: IFFALSE 49860
// exit ;
49858: GO 49941
// for i = 1 to mc_bases do
49860: LD_ADDR_VAR 0 2
49864: PUSH
49865: DOUBLE
49866: LD_INT 1
49868: DEC
49869: ST_TO_ADDR
49870: LD_EXP 99
49874: PUSH
49875: FOR_TO
49876: IFFALSE 49939
// if mc_mines [ i ] and mc_miners [ i ] then
49878: LD_EXP 112
49882: PUSH
49883: LD_VAR 0 2
49887: ARRAY
49888: PUSH
49889: LD_EXP 113
49893: PUSH
49894: LD_VAR 0 2
49898: ARRAY
49899: AND
49900: IFFALSE 49937
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
49902: LD_EXP 113
49906: PUSH
49907: LD_VAR 0 2
49911: ARRAY
49912: PUSH
49913: LD_INT 1
49915: ARRAY
49916: PPUSH
49917: CALL_OW 255
49921: PPUSH
49922: LD_EXP 112
49926: PUSH
49927: LD_VAR 0 2
49931: ARRAY
49932: PPUSH
49933: CALL 65740 0 2
49937: GO 49875
49939: POP
49940: POP
// end ;
49941: LD_VAR 0 1
49945: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
49946: LD_INT 0
49948: PPUSH
49949: PPUSH
49950: PPUSH
49951: PPUSH
49952: PPUSH
49953: PPUSH
49954: PPUSH
49955: PPUSH
// if not mc_bases or not mc_parking then
49956: LD_EXP 99
49960: NOT
49961: PUSH
49962: LD_EXP 123
49966: NOT
49967: OR
49968: IFFALSE 49972
// exit ;
49970: GO 50684
// for i = 1 to mc_bases do
49972: LD_ADDR_VAR 0 2
49976: PUSH
49977: DOUBLE
49978: LD_INT 1
49980: DEC
49981: ST_TO_ADDR
49982: LD_EXP 99
49986: PUSH
49987: FOR_TO
49988: IFFALSE 50682
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
49990: LD_EXP 99
49994: PUSH
49995: LD_VAR 0 2
49999: ARRAY
50000: NOT
50001: PUSH
50002: LD_EXP 123
50006: PUSH
50007: LD_VAR 0 2
50011: ARRAY
50012: NOT
50013: OR
50014: IFFALSE 50018
// continue ;
50016: GO 49987
// if mc_scan [ i ] then
50018: LD_EXP 122
50022: PUSH
50023: LD_VAR 0 2
50027: ARRAY
50028: IFFALSE 50054
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
50030: LD_ADDR_EXP 111
50034: PUSH
50035: LD_EXP 111
50039: PPUSH
50040: LD_VAR 0 2
50044: PPUSH
50045: EMPTY
50046: PPUSH
50047: CALL_OW 1
50051: ST_TO_ADDR
// continue ;
50052: GO 49987
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
50054: LD_ADDR_VAR 0 5
50058: PUSH
50059: LD_EXP 99
50063: PUSH
50064: LD_VAR 0 2
50068: ARRAY
50069: PUSH
50070: LD_INT 1
50072: ARRAY
50073: PPUSH
50074: CALL_OW 255
50078: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50079: LD_ADDR_VAR 0 6
50083: PUSH
50084: LD_EXP 99
50088: PUSH
50089: LD_VAR 0 2
50093: ARRAY
50094: PPUSH
50095: LD_INT 30
50097: PUSH
50098: LD_INT 3
50100: PUSH
50101: EMPTY
50102: LIST
50103: LIST
50104: PPUSH
50105: CALL_OW 72
50109: ST_TO_ADDR
// if not fac then
50110: LD_VAR 0 6
50114: NOT
50115: IFFALSE 50166
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50117: LD_ADDR_VAR 0 6
50121: PUSH
50122: LD_EXP 99
50126: PUSH
50127: LD_VAR 0 2
50131: ARRAY
50132: PPUSH
50133: LD_INT 2
50135: PUSH
50136: LD_INT 30
50138: PUSH
50139: LD_INT 0
50141: PUSH
50142: EMPTY
50143: LIST
50144: LIST
50145: PUSH
50146: LD_INT 30
50148: PUSH
50149: LD_INT 1
50151: PUSH
50152: EMPTY
50153: LIST
50154: LIST
50155: PUSH
50156: EMPTY
50157: LIST
50158: LIST
50159: LIST
50160: PPUSH
50161: CALL_OW 72
50165: ST_TO_ADDR
// if not fac then
50166: LD_VAR 0 6
50170: NOT
50171: IFFALSE 50175
// continue ;
50173: GO 49987
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
50175: LD_ADDR_VAR 0 7
50179: PUSH
50180: LD_EXP 123
50184: PUSH
50185: LD_VAR 0 2
50189: ARRAY
50190: PPUSH
50191: LD_INT 22
50193: PUSH
50194: LD_VAR 0 5
50198: PUSH
50199: EMPTY
50200: LIST
50201: LIST
50202: PUSH
50203: LD_INT 21
50205: PUSH
50206: LD_INT 2
50208: PUSH
50209: EMPTY
50210: LIST
50211: LIST
50212: PUSH
50213: LD_INT 3
50215: PUSH
50216: LD_INT 24
50218: PUSH
50219: LD_INT 1000
50221: PUSH
50222: EMPTY
50223: LIST
50224: LIST
50225: PUSH
50226: EMPTY
50227: LIST
50228: LIST
50229: PUSH
50230: EMPTY
50231: LIST
50232: LIST
50233: LIST
50234: PPUSH
50235: CALL_OW 70
50239: PUSH
50240: LD_INT 22
50242: PUSH
50243: LD_VAR 0 5
50247: PUSH
50248: EMPTY
50249: LIST
50250: LIST
50251: PUSH
50252: LD_INT 91
50254: PUSH
50255: LD_VAR 0 6
50259: PUSH
50260: LD_INT 1
50262: ARRAY
50263: PUSH
50264: LD_INT 25
50266: PUSH
50267: EMPTY
50268: LIST
50269: LIST
50270: LIST
50271: PUSH
50272: LD_INT 21
50274: PUSH
50275: LD_INT 2
50277: PUSH
50278: EMPTY
50279: LIST
50280: LIST
50281: PUSH
50282: LD_INT 3
50284: PUSH
50285: LD_INT 24
50287: PUSH
50288: LD_INT 1000
50290: PUSH
50291: EMPTY
50292: LIST
50293: LIST
50294: PUSH
50295: EMPTY
50296: LIST
50297: LIST
50298: PUSH
50299: EMPTY
50300: LIST
50301: LIST
50302: LIST
50303: LIST
50304: PPUSH
50305: CALL_OW 69
50309: UNION
50310: ST_TO_ADDR
// if not vehs then
50311: LD_VAR 0 7
50315: NOT
50316: IFFALSE 50342
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
50318: LD_ADDR_EXP 111
50322: PUSH
50323: LD_EXP 111
50327: PPUSH
50328: LD_VAR 0 2
50332: PPUSH
50333: EMPTY
50334: PPUSH
50335: CALL_OW 1
50339: ST_TO_ADDR
// continue ;
50340: GO 49987
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50342: LD_ADDR_VAR 0 8
50346: PUSH
50347: LD_EXP 99
50351: PUSH
50352: LD_VAR 0 2
50356: ARRAY
50357: PPUSH
50358: LD_INT 30
50360: PUSH
50361: LD_INT 3
50363: PUSH
50364: EMPTY
50365: LIST
50366: LIST
50367: PPUSH
50368: CALL_OW 72
50372: ST_TO_ADDR
// if tmp then
50373: LD_VAR 0 8
50377: IFFALSE 50480
// begin for j in tmp do
50379: LD_ADDR_VAR 0 3
50383: PUSH
50384: LD_VAR 0 8
50388: PUSH
50389: FOR_IN
50390: IFFALSE 50478
// for k in UnitsInside ( j ) do
50392: LD_ADDR_VAR 0 4
50396: PUSH
50397: LD_VAR 0 3
50401: PPUSH
50402: CALL_OW 313
50406: PUSH
50407: FOR_IN
50408: IFFALSE 50474
// if k then
50410: LD_VAR 0 4
50414: IFFALSE 50472
// if not k in mc_repair_vehicle [ i ] then
50416: LD_VAR 0 4
50420: PUSH
50421: LD_EXP 111
50425: PUSH
50426: LD_VAR 0 2
50430: ARRAY
50431: IN
50432: NOT
50433: IFFALSE 50472
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
50435: LD_ADDR_EXP 111
50439: PUSH
50440: LD_EXP 111
50444: PPUSH
50445: LD_VAR 0 2
50449: PPUSH
50450: LD_EXP 111
50454: PUSH
50455: LD_VAR 0 2
50459: ARRAY
50460: PUSH
50461: LD_VAR 0 4
50465: UNION
50466: PPUSH
50467: CALL_OW 1
50471: ST_TO_ADDR
50472: GO 50407
50474: POP
50475: POP
50476: GO 50389
50478: POP
50479: POP
// end ; if not mc_repair_vehicle [ i ] then
50480: LD_EXP 111
50484: PUSH
50485: LD_VAR 0 2
50489: ARRAY
50490: NOT
50491: IFFALSE 50495
// continue ;
50493: GO 49987
// for j in mc_repair_vehicle [ i ] do
50495: LD_ADDR_VAR 0 3
50499: PUSH
50500: LD_EXP 111
50504: PUSH
50505: LD_VAR 0 2
50509: ARRAY
50510: PUSH
50511: FOR_IN
50512: IFFALSE 50678
// begin if GetClass ( j ) <> 3 then
50514: LD_VAR 0 3
50518: PPUSH
50519: CALL_OW 257
50523: PUSH
50524: LD_INT 3
50526: NONEQUAL
50527: IFFALSE 50568
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
50529: LD_ADDR_EXP 111
50533: PUSH
50534: LD_EXP 111
50538: PPUSH
50539: LD_VAR 0 2
50543: PPUSH
50544: LD_EXP 111
50548: PUSH
50549: LD_VAR 0 2
50553: ARRAY
50554: PUSH
50555: LD_VAR 0 3
50559: DIFF
50560: PPUSH
50561: CALL_OW 1
50565: ST_TO_ADDR
// continue ;
50566: GO 50511
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
50568: LD_VAR 0 3
50572: PPUSH
50573: CALL_OW 311
50577: NOT
50578: PUSH
50579: LD_VAR 0 3
50583: PUSH
50584: LD_EXP 102
50588: PUSH
50589: LD_VAR 0 2
50593: ARRAY
50594: PUSH
50595: LD_INT 1
50597: ARRAY
50598: IN
50599: NOT
50600: AND
50601: PUSH
50602: LD_VAR 0 3
50606: PUSH
50607: LD_EXP 102
50611: PUSH
50612: LD_VAR 0 2
50616: ARRAY
50617: PUSH
50618: LD_INT 2
50620: ARRAY
50621: IN
50622: NOT
50623: AND
50624: IFFALSE 50676
// begin if IsInUnit ( j ) then
50626: LD_VAR 0 3
50630: PPUSH
50631: CALL_OW 310
50635: IFFALSE 50646
// ComExitBuilding ( j ) ;
50637: LD_VAR 0 3
50641: PPUSH
50642: CALL_OW 122
// if not HasTask ( j ) then
50646: LD_VAR 0 3
50650: PPUSH
50651: CALL_OW 314
50655: NOT
50656: IFFALSE 50676
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
50658: LD_VAR 0 3
50662: PPUSH
50663: LD_VAR 0 7
50667: PUSH
50668: LD_INT 1
50670: ARRAY
50671: PPUSH
50672: CALL_OW 189
// end ; end ;
50676: GO 50511
50678: POP
50679: POP
// end ;
50680: GO 49987
50682: POP
50683: POP
// end ;
50684: LD_VAR 0 1
50688: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
50689: LD_INT 0
50691: PPUSH
50692: PPUSH
50693: PPUSH
50694: PPUSH
50695: PPUSH
50696: PPUSH
50697: PPUSH
50698: PPUSH
50699: PPUSH
50700: PPUSH
50701: PPUSH
// if not mc_bases then
50702: LD_EXP 99
50706: NOT
50707: IFFALSE 50711
// exit ;
50709: GO 51513
// for i = 1 to mc_bases do
50711: LD_ADDR_VAR 0 2
50715: PUSH
50716: DOUBLE
50717: LD_INT 1
50719: DEC
50720: ST_TO_ADDR
50721: LD_EXP 99
50725: PUSH
50726: FOR_TO
50727: IFFALSE 51511
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
50729: LD_EXP 127
50733: PUSH
50734: LD_VAR 0 2
50738: ARRAY
50739: NOT
50740: PUSH
50741: LD_EXP 102
50745: PUSH
50746: LD_VAR 0 2
50750: ARRAY
50751: PUSH
50752: LD_INT 1
50754: ARRAY
50755: OR
50756: PUSH
50757: LD_EXP 102
50761: PUSH
50762: LD_VAR 0 2
50766: ARRAY
50767: PUSH
50768: LD_INT 2
50770: ARRAY
50771: OR
50772: PUSH
50773: LD_EXP 125
50777: PUSH
50778: LD_VAR 0 2
50782: ARRAY
50783: PPUSH
50784: LD_INT 1
50786: PPUSH
50787: CALL_OW 325
50791: NOT
50792: OR
50793: PUSH
50794: LD_EXP 122
50798: PUSH
50799: LD_VAR 0 2
50803: ARRAY
50804: OR
50805: IFFALSE 50809
// continue ;
50807: GO 50726
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
50809: LD_ADDR_VAR 0 8
50813: PUSH
50814: LD_EXP 99
50818: PUSH
50819: LD_VAR 0 2
50823: ARRAY
50824: PPUSH
50825: LD_INT 25
50827: PUSH
50828: LD_INT 4
50830: PUSH
50831: EMPTY
50832: LIST
50833: LIST
50834: PUSH
50835: LD_INT 50
50837: PUSH
50838: EMPTY
50839: LIST
50840: PUSH
50841: LD_INT 3
50843: PUSH
50844: LD_INT 60
50846: PUSH
50847: EMPTY
50848: LIST
50849: PUSH
50850: EMPTY
50851: LIST
50852: LIST
50853: PUSH
50854: EMPTY
50855: LIST
50856: LIST
50857: LIST
50858: PPUSH
50859: CALL_OW 72
50863: PUSH
50864: LD_EXP 103
50868: PUSH
50869: LD_VAR 0 2
50873: ARRAY
50874: DIFF
50875: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50876: LD_ADDR_VAR 0 9
50880: PUSH
50881: LD_EXP 99
50885: PUSH
50886: LD_VAR 0 2
50890: ARRAY
50891: PPUSH
50892: LD_INT 2
50894: PUSH
50895: LD_INT 30
50897: PUSH
50898: LD_INT 0
50900: PUSH
50901: EMPTY
50902: LIST
50903: LIST
50904: PUSH
50905: LD_INT 30
50907: PUSH
50908: LD_INT 1
50910: PUSH
50911: EMPTY
50912: LIST
50913: LIST
50914: PUSH
50915: EMPTY
50916: LIST
50917: LIST
50918: LIST
50919: PPUSH
50920: CALL_OW 72
50924: ST_TO_ADDR
// if not tmp or not dep then
50925: LD_VAR 0 8
50929: NOT
50930: PUSH
50931: LD_VAR 0 9
50935: NOT
50936: OR
50937: IFFALSE 50941
// continue ;
50939: GO 50726
// side := GetSide ( tmp [ 1 ] ) ;
50941: LD_ADDR_VAR 0 11
50945: PUSH
50946: LD_VAR 0 8
50950: PUSH
50951: LD_INT 1
50953: ARRAY
50954: PPUSH
50955: CALL_OW 255
50959: ST_TO_ADDR
// dep := dep [ 1 ] ;
50960: LD_ADDR_VAR 0 9
50964: PUSH
50965: LD_VAR 0 9
50969: PUSH
50970: LD_INT 1
50972: ARRAY
50973: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
50974: LD_ADDR_VAR 0 7
50978: PUSH
50979: LD_EXP 127
50983: PUSH
50984: LD_VAR 0 2
50988: ARRAY
50989: PPUSH
50990: LD_INT 22
50992: PUSH
50993: LD_INT 0
50995: PUSH
50996: EMPTY
50997: LIST
50998: LIST
50999: PUSH
51000: LD_INT 25
51002: PUSH
51003: LD_INT 12
51005: PUSH
51006: EMPTY
51007: LIST
51008: LIST
51009: PUSH
51010: EMPTY
51011: LIST
51012: LIST
51013: PPUSH
51014: CALL_OW 70
51018: PUSH
51019: LD_INT 22
51021: PUSH
51022: LD_INT 0
51024: PUSH
51025: EMPTY
51026: LIST
51027: LIST
51028: PUSH
51029: LD_INT 25
51031: PUSH
51032: LD_INT 12
51034: PUSH
51035: EMPTY
51036: LIST
51037: LIST
51038: PUSH
51039: LD_INT 91
51041: PUSH
51042: LD_VAR 0 9
51046: PUSH
51047: LD_INT 20
51049: PUSH
51050: EMPTY
51051: LIST
51052: LIST
51053: LIST
51054: PUSH
51055: EMPTY
51056: LIST
51057: LIST
51058: LIST
51059: PPUSH
51060: CALL_OW 69
51064: UNION
51065: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
51066: LD_ADDR_VAR 0 10
51070: PUSH
51071: LD_EXP 127
51075: PUSH
51076: LD_VAR 0 2
51080: ARRAY
51081: PPUSH
51082: LD_INT 81
51084: PUSH
51085: LD_VAR 0 11
51089: PUSH
51090: EMPTY
51091: LIST
51092: LIST
51093: PPUSH
51094: CALL_OW 70
51098: ST_TO_ADDR
// if not apes or danger_at_area then
51099: LD_VAR 0 7
51103: NOT
51104: PUSH
51105: LD_VAR 0 10
51109: OR
51110: IFFALSE 51160
// begin if mc_taming [ i ] then
51112: LD_EXP 130
51116: PUSH
51117: LD_VAR 0 2
51121: ARRAY
51122: IFFALSE 51158
// begin MC_Reset ( i , 121 ) ;
51124: LD_VAR 0 2
51128: PPUSH
51129: LD_INT 121
51131: PPUSH
51132: CALL 36795 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
51136: LD_ADDR_EXP 130
51140: PUSH
51141: LD_EXP 130
51145: PPUSH
51146: LD_VAR 0 2
51150: PPUSH
51151: EMPTY
51152: PPUSH
51153: CALL_OW 1
51157: ST_TO_ADDR
// end ; continue ;
51158: GO 50726
// end ; for j in tmp do
51160: LD_ADDR_VAR 0 3
51164: PUSH
51165: LD_VAR 0 8
51169: PUSH
51170: FOR_IN
51171: IFFALSE 51507
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
51173: LD_VAR 0 3
51177: PUSH
51178: LD_EXP 130
51182: PUSH
51183: LD_VAR 0 2
51187: ARRAY
51188: IN
51189: NOT
51190: PUSH
51191: LD_EXP 130
51195: PUSH
51196: LD_VAR 0 2
51200: ARRAY
51201: PUSH
51202: LD_INT 3
51204: LESS
51205: AND
51206: IFFALSE 51264
// begin SetTag ( j , 121 ) ;
51208: LD_VAR 0 3
51212: PPUSH
51213: LD_INT 121
51215: PPUSH
51216: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
51220: LD_ADDR_EXP 130
51224: PUSH
51225: LD_EXP 130
51229: PPUSH
51230: LD_VAR 0 2
51234: PUSH
51235: LD_EXP 130
51239: PUSH
51240: LD_VAR 0 2
51244: ARRAY
51245: PUSH
51246: LD_INT 1
51248: PLUS
51249: PUSH
51250: EMPTY
51251: LIST
51252: LIST
51253: PPUSH
51254: LD_VAR 0 3
51258: PPUSH
51259: CALL 68683 0 3
51263: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
51264: LD_VAR 0 3
51268: PUSH
51269: LD_EXP 130
51273: PUSH
51274: LD_VAR 0 2
51278: ARRAY
51279: IN
51280: IFFALSE 51505
// begin if GetClass ( j ) <> 4 then
51282: LD_VAR 0 3
51286: PPUSH
51287: CALL_OW 257
51291: PUSH
51292: LD_INT 4
51294: NONEQUAL
51295: IFFALSE 51348
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
51297: LD_ADDR_EXP 130
51301: PUSH
51302: LD_EXP 130
51306: PPUSH
51307: LD_VAR 0 2
51311: PPUSH
51312: LD_EXP 130
51316: PUSH
51317: LD_VAR 0 2
51321: ARRAY
51322: PUSH
51323: LD_VAR 0 3
51327: DIFF
51328: PPUSH
51329: CALL_OW 1
51333: ST_TO_ADDR
// SetTag ( j , 0 ) ;
51334: LD_VAR 0 3
51338: PPUSH
51339: LD_INT 0
51341: PPUSH
51342: CALL_OW 109
// continue ;
51346: GO 51170
// end ; if IsInUnit ( j ) then
51348: LD_VAR 0 3
51352: PPUSH
51353: CALL_OW 310
51357: IFFALSE 51368
// ComExitBuilding ( j ) ;
51359: LD_VAR 0 3
51363: PPUSH
51364: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
51368: LD_ADDR_VAR 0 6
51372: PUSH
51373: LD_VAR 0 7
51377: PPUSH
51378: LD_VAR 0 3
51382: PPUSH
51383: CALL_OW 74
51387: ST_TO_ADDR
// if not ape then
51388: LD_VAR 0 6
51392: NOT
51393: IFFALSE 51397
// break ;
51395: GO 51507
// x := GetX ( ape ) ;
51397: LD_ADDR_VAR 0 4
51401: PUSH
51402: LD_VAR 0 6
51406: PPUSH
51407: CALL_OW 250
51411: ST_TO_ADDR
// y := GetY ( ape ) ;
51412: LD_ADDR_VAR 0 5
51416: PUSH
51417: LD_VAR 0 6
51421: PPUSH
51422: CALL_OW 251
51426: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
51427: LD_VAR 0 4
51431: PPUSH
51432: LD_VAR 0 5
51436: PPUSH
51437: CALL_OW 488
51441: NOT
51442: PUSH
51443: LD_VAR 0 11
51447: PPUSH
51448: LD_VAR 0 4
51452: PPUSH
51453: LD_VAR 0 5
51457: PPUSH
51458: LD_INT 20
51460: PPUSH
51461: CALL 69579 0 4
51465: PUSH
51466: LD_INT 4
51468: ARRAY
51469: OR
51470: IFFALSE 51474
// break ;
51472: GO 51507
// if not HasTask ( j ) then
51474: LD_VAR 0 3
51478: PPUSH
51479: CALL_OW 314
51483: NOT
51484: IFFALSE 51505
// ComTameXY ( j , x , y ) ;
51486: LD_VAR 0 3
51490: PPUSH
51491: LD_VAR 0 4
51495: PPUSH
51496: LD_VAR 0 5
51500: PPUSH
51501: CALL_OW 131
// end ; end ;
51505: GO 51170
51507: POP
51508: POP
// end ;
51509: GO 50726
51511: POP
51512: POP
// end ;
51513: LD_VAR 0 1
51517: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
51518: LD_INT 0
51520: PPUSH
51521: PPUSH
51522: PPUSH
51523: PPUSH
51524: PPUSH
51525: PPUSH
51526: PPUSH
51527: PPUSH
// if not mc_bases then
51528: LD_EXP 99
51532: NOT
51533: IFFALSE 51537
// exit ;
51535: GO 52163
// for i = 1 to mc_bases do
51537: LD_ADDR_VAR 0 2
51541: PUSH
51542: DOUBLE
51543: LD_INT 1
51545: DEC
51546: ST_TO_ADDR
51547: LD_EXP 99
51551: PUSH
51552: FOR_TO
51553: IFFALSE 52161
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
51555: LD_EXP 128
51559: PUSH
51560: LD_VAR 0 2
51564: ARRAY
51565: NOT
51566: PUSH
51567: LD_EXP 128
51571: PUSH
51572: LD_VAR 0 2
51576: ARRAY
51577: PPUSH
51578: LD_INT 25
51580: PUSH
51581: LD_INT 12
51583: PUSH
51584: EMPTY
51585: LIST
51586: LIST
51587: PPUSH
51588: CALL_OW 72
51592: NOT
51593: OR
51594: IFFALSE 51598
// continue ;
51596: GO 51552
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
51598: LD_ADDR_VAR 0 5
51602: PUSH
51603: LD_EXP 128
51607: PUSH
51608: LD_VAR 0 2
51612: ARRAY
51613: PUSH
51614: LD_INT 1
51616: ARRAY
51617: PPUSH
51618: CALL_OW 255
51622: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
51623: LD_VAR 0 5
51627: PPUSH
51628: LD_INT 2
51630: PPUSH
51631: CALL_OW 325
51635: IFFALSE 51888
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
51637: LD_ADDR_VAR 0 4
51641: PUSH
51642: LD_EXP 128
51646: PUSH
51647: LD_VAR 0 2
51651: ARRAY
51652: PPUSH
51653: LD_INT 25
51655: PUSH
51656: LD_INT 16
51658: PUSH
51659: EMPTY
51660: LIST
51661: LIST
51662: PPUSH
51663: CALL_OW 72
51667: ST_TO_ADDR
// if tmp < 6 then
51668: LD_VAR 0 4
51672: PUSH
51673: LD_INT 6
51675: LESS
51676: IFFALSE 51888
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51678: LD_ADDR_VAR 0 6
51682: PUSH
51683: LD_EXP 99
51687: PUSH
51688: LD_VAR 0 2
51692: ARRAY
51693: PPUSH
51694: LD_INT 2
51696: PUSH
51697: LD_INT 30
51699: PUSH
51700: LD_INT 0
51702: PUSH
51703: EMPTY
51704: LIST
51705: LIST
51706: PUSH
51707: LD_INT 30
51709: PUSH
51710: LD_INT 1
51712: PUSH
51713: EMPTY
51714: LIST
51715: LIST
51716: PUSH
51717: EMPTY
51718: LIST
51719: LIST
51720: LIST
51721: PPUSH
51722: CALL_OW 72
51726: ST_TO_ADDR
// if depot then
51727: LD_VAR 0 6
51731: IFFALSE 51888
// begin selected := 0 ;
51733: LD_ADDR_VAR 0 7
51737: PUSH
51738: LD_INT 0
51740: ST_TO_ADDR
// for j in depot do
51741: LD_ADDR_VAR 0 3
51745: PUSH
51746: LD_VAR 0 6
51750: PUSH
51751: FOR_IN
51752: IFFALSE 51783
// begin if UnitsInside ( j ) < 6 then
51754: LD_VAR 0 3
51758: PPUSH
51759: CALL_OW 313
51763: PUSH
51764: LD_INT 6
51766: LESS
51767: IFFALSE 51781
// begin selected := j ;
51769: LD_ADDR_VAR 0 7
51773: PUSH
51774: LD_VAR 0 3
51778: ST_TO_ADDR
// break ;
51779: GO 51783
// end ; end ;
51781: GO 51751
51783: POP
51784: POP
// if selected then
51785: LD_VAR 0 7
51789: IFFALSE 51888
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
51791: LD_ADDR_VAR 0 3
51795: PUSH
51796: LD_EXP 128
51800: PUSH
51801: LD_VAR 0 2
51805: ARRAY
51806: PPUSH
51807: LD_INT 25
51809: PUSH
51810: LD_INT 12
51812: PUSH
51813: EMPTY
51814: LIST
51815: LIST
51816: PPUSH
51817: CALL_OW 72
51821: PUSH
51822: FOR_IN
51823: IFFALSE 51886
// if not HasTask ( j ) then
51825: LD_VAR 0 3
51829: PPUSH
51830: CALL_OW 314
51834: NOT
51835: IFFALSE 51884
// begin if not IsInUnit ( j ) then
51837: LD_VAR 0 3
51841: PPUSH
51842: CALL_OW 310
51846: NOT
51847: IFFALSE 51863
// ComEnterUnit ( j , selected ) ;
51849: LD_VAR 0 3
51853: PPUSH
51854: LD_VAR 0 7
51858: PPUSH
51859: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
51863: LD_VAR 0 3
51867: PPUSH
51868: LD_INT 16
51870: PPUSH
51871: CALL_OW 183
// AddComExitBuilding ( j ) ;
51875: LD_VAR 0 3
51879: PPUSH
51880: CALL_OW 182
// end ;
51884: GO 51822
51886: POP
51887: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
51888: LD_VAR 0 5
51892: PPUSH
51893: LD_INT 11
51895: PPUSH
51896: CALL_OW 325
51900: IFFALSE 52159
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
51902: LD_ADDR_VAR 0 4
51906: PUSH
51907: LD_EXP 128
51911: PUSH
51912: LD_VAR 0 2
51916: ARRAY
51917: PPUSH
51918: LD_INT 25
51920: PUSH
51921: LD_INT 16
51923: PUSH
51924: EMPTY
51925: LIST
51926: LIST
51927: PPUSH
51928: CALL_OW 72
51932: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
51933: LD_VAR 0 4
51937: PUSH
51938: LD_INT 6
51940: GREATEREQUAL
51941: PUSH
51942: LD_VAR 0 5
51946: PPUSH
51947: LD_INT 2
51949: PPUSH
51950: CALL_OW 325
51954: NOT
51955: OR
51956: IFFALSE 52159
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
51958: LD_ADDR_VAR 0 8
51962: PUSH
51963: LD_EXP 99
51967: PUSH
51968: LD_VAR 0 2
51972: ARRAY
51973: PPUSH
51974: LD_INT 2
51976: PUSH
51977: LD_INT 30
51979: PUSH
51980: LD_INT 4
51982: PUSH
51983: EMPTY
51984: LIST
51985: LIST
51986: PUSH
51987: LD_INT 30
51989: PUSH
51990: LD_INT 5
51992: PUSH
51993: EMPTY
51994: LIST
51995: LIST
51996: PUSH
51997: EMPTY
51998: LIST
51999: LIST
52000: LIST
52001: PPUSH
52002: CALL_OW 72
52006: ST_TO_ADDR
// if barracks then
52007: LD_VAR 0 8
52011: IFFALSE 52159
// begin selected := 0 ;
52013: LD_ADDR_VAR 0 7
52017: PUSH
52018: LD_INT 0
52020: ST_TO_ADDR
// for j in barracks do
52021: LD_ADDR_VAR 0 3
52025: PUSH
52026: LD_VAR 0 8
52030: PUSH
52031: FOR_IN
52032: IFFALSE 52063
// begin if UnitsInside ( j ) < 6 then
52034: LD_VAR 0 3
52038: PPUSH
52039: CALL_OW 313
52043: PUSH
52044: LD_INT 6
52046: LESS
52047: IFFALSE 52061
// begin selected := j ;
52049: LD_ADDR_VAR 0 7
52053: PUSH
52054: LD_VAR 0 3
52058: ST_TO_ADDR
// break ;
52059: GO 52063
// end ; end ;
52061: GO 52031
52063: POP
52064: POP
// if selected then
52065: LD_VAR 0 7
52069: IFFALSE 52159
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
52071: LD_ADDR_VAR 0 3
52075: PUSH
52076: LD_EXP 128
52080: PUSH
52081: LD_VAR 0 2
52085: ARRAY
52086: PPUSH
52087: LD_INT 25
52089: PUSH
52090: LD_INT 12
52092: PUSH
52093: EMPTY
52094: LIST
52095: LIST
52096: PPUSH
52097: CALL_OW 72
52101: PUSH
52102: FOR_IN
52103: IFFALSE 52157
// if not IsInUnit ( j ) and not HasTask ( j ) then
52105: LD_VAR 0 3
52109: PPUSH
52110: CALL_OW 310
52114: NOT
52115: PUSH
52116: LD_VAR 0 3
52120: PPUSH
52121: CALL_OW 314
52125: NOT
52126: AND
52127: IFFALSE 52155
// begin ComEnterUnit ( j , selected ) ;
52129: LD_VAR 0 3
52133: PPUSH
52134: LD_VAR 0 7
52138: PPUSH
52139: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
52143: LD_VAR 0 3
52147: PPUSH
52148: LD_INT 15
52150: PPUSH
52151: CALL_OW 183
// end ;
52155: GO 52102
52157: POP
52158: POP
// end ; end ; end ; end ; end ;
52159: GO 51552
52161: POP
52162: POP
// end ;
52163: LD_VAR 0 1
52167: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
52168: LD_INT 0
52170: PPUSH
52171: PPUSH
52172: PPUSH
52173: PPUSH
// if not mc_bases then
52174: LD_EXP 99
52178: NOT
52179: IFFALSE 52183
// exit ;
52181: GO 52361
// for i = 1 to mc_bases do
52183: LD_ADDR_VAR 0 2
52187: PUSH
52188: DOUBLE
52189: LD_INT 1
52191: DEC
52192: ST_TO_ADDR
52193: LD_EXP 99
52197: PUSH
52198: FOR_TO
52199: IFFALSE 52359
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
52201: LD_ADDR_VAR 0 4
52205: PUSH
52206: LD_EXP 99
52210: PUSH
52211: LD_VAR 0 2
52215: ARRAY
52216: PPUSH
52217: LD_INT 25
52219: PUSH
52220: LD_INT 9
52222: PUSH
52223: EMPTY
52224: LIST
52225: LIST
52226: PPUSH
52227: CALL_OW 72
52231: ST_TO_ADDR
// if not tmp then
52232: LD_VAR 0 4
52236: NOT
52237: IFFALSE 52241
// continue ;
52239: GO 52198
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
52241: LD_EXP 125
52245: PUSH
52246: LD_VAR 0 2
52250: ARRAY
52251: PPUSH
52252: LD_INT 29
52254: PPUSH
52255: CALL_OW 325
52259: NOT
52260: PUSH
52261: LD_EXP 125
52265: PUSH
52266: LD_VAR 0 2
52270: ARRAY
52271: PPUSH
52272: LD_INT 28
52274: PPUSH
52275: CALL_OW 325
52279: NOT
52280: AND
52281: IFFALSE 52285
// continue ;
52283: GO 52198
// for j in tmp do
52285: LD_ADDR_VAR 0 3
52289: PUSH
52290: LD_VAR 0 4
52294: PUSH
52295: FOR_IN
52296: IFFALSE 52355
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
52298: LD_VAR 0 3
52302: PUSH
52303: LD_EXP 102
52307: PUSH
52308: LD_VAR 0 2
52312: ARRAY
52313: PUSH
52314: LD_INT 1
52316: ARRAY
52317: IN
52318: NOT
52319: PUSH
52320: LD_VAR 0 3
52324: PUSH
52325: LD_EXP 102
52329: PUSH
52330: LD_VAR 0 2
52334: ARRAY
52335: PUSH
52336: LD_INT 2
52338: ARRAY
52339: IN
52340: NOT
52341: AND
52342: IFFALSE 52353
// ComSpaceTimeShoot ( j ) ;
52344: LD_VAR 0 3
52348: PPUSH
52349: CALL 62743 0 1
52353: GO 52295
52355: POP
52356: POP
// end ;
52357: GO 52198
52359: POP
52360: POP
// end ;
52361: LD_VAR 0 1
52365: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
52366: LD_INT 0
52368: PPUSH
52369: PPUSH
52370: PPUSH
52371: PPUSH
52372: PPUSH
52373: PPUSH
52374: PPUSH
52375: PPUSH
52376: PPUSH
// if not mc_bases then
52377: LD_EXP 99
52381: NOT
52382: IFFALSE 52386
// exit ;
52384: GO 53008
// for i = 1 to mc_bases do
52386: LD_ADDR_VAR 0 2
52390: PUSH
52391: DOUBLE
52392: LD_INT 1
52394: DEC
52395: ST_TO_ADDR
52396: LD_EXP 99
52400: PUSH
52401: FOR_TO
52402: IFFALSE 53006
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
52404: LD_EXP 134
52408: PUSH
52409: LD_VAR 0 2
52413: ARRAY
52414: NOT
52415: PUSH
52416: LD_INT 38
52418: PPUSH
52419: LD_EXP 125
52423: PUSH
52424: LD_VAR 0 2
52428: ARRAY
52429: PPUSH
52430: CALL_OW 321
52434: PUSH
52435: LD_INT 2
52437: NONEQUAL
52438: OR
52439: IFFALSE 52443
// continue ;
52441: GO 52401
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
52443: LD_ADDR_VAR 0 8
52447: PUSH
52448: LD_EXP 99
52452: PUSH
52453: LD_VAR 0 2
52457: ARRAY
52458: PPUSH
52459: LD_INT 30
52461: PUSH
52462: LD_INT 34
52464: PUSH
52465: EMPTY
52466: LIST
52467: LIST
52468: PPUSH
52469: CALL_OW 72
52473: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
52474: LD_ADDR_VAR 0 9
52478: PUSH
52479: LD_EXP 99
52483: PUSH
52484: LD_VAR 0 2
52488: ARRAY
52489: PPUSH
52490: LD_INT 25
52492: PUSH
52493: LD_INT 4
52495: PUSH
52496: EMPTY
52497: LIST
52498: LIST
52499: PPUSH
52500: CALL_OW 72
52504: PPUSH
52505: LD_INT 0
52507: PPUSH
52508: CALL 101880 0 2
52512: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
52513: LD_VAR 0 9
52517: NOT
52518: PUSH
52519: LD_VAR 0 8
52523: NOT
52524: OR
52525: PUSH
52526: LD_EXP 99
52530: PUSH
52531: LD_VAR 0 2
52535: ARRAY
52536: PPUSH
52537: LD_INT 124
52539: PPUSH
52540: CALL 101880 0 2
52544: OR
52545: IFFALSE 52549
// continue ;
52547: GO 52401
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
52549: LD_EXP 135
52553: PUSH
52554: LD_VAR 0 2
52558: ARRAY
52559: PUSH
52560: LD_EXP 134
52564: PUSH
52565: LD_VAR 0 2
52569: ARRAY
52570: LESS
52571: PUSH
52572: LD_EXP 135
52576: PUSH
52577: LD_VAR 0 2
52581: ARRAY
52582: PUSH
52583: LD_VAR 0 8
52587: LESS
52588: AND
52589: IFFALSE 53004
// begin tmp := sci [ 1 ] ;
52591: LD_ADDR_VAR 0 7
52595: PUSH
52596: LD_VAR 0 9
52600: PUSH
52601: LD_INT 1
52603: ARRAY
52604: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
52605: LD_VAR 0 7
52609: PPUSH
52610: LD_INT 124
52612: PPUSH
52613: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
52617: LD_ADDR_VAR 0 3
52621: PUSH
52622: DOUBLE
52623: LD_EXP 134
52627: PUSH
52628: LD_VAR 0 2
52632: ARRAY
52633: INC
52634: ST_TO_ADDR
52635: LD_EXP 134
52639: PUSH
52640: LD_VAR 0 2
52644: ARRAY
52645: PUSH
52646: FOR_DOWNTO
52647: IFFALSE 52990
// begin if IsInUnit ( tmp ) then
52649: LD_VAR 0 7
52653: PPUSH
52654: CALL_OW 310
52658: IFFALSE 52669
// ComExitBuilding ( tmp ) ;
52660: LD_VAR 0 7
52664: PPUSH
52665: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
52669: LD_INT 35
52671: PPUSH
52672: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
52676: LD_VAR 0 7
52680: PPUSH
52681: CALL_OW 310
52685: NOT
52686: PUSH
52687: LD_VAR 0 7
52691: PPUSH
52692: CALL_OW 314
52696: NOT
52697: AND
52698: IFFALSE 52669
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
52700: LD_ADDR_VAR 0 6
52704: PUSH
52705: LD_VAR 0 7
52709: PPUSH
52710: CALL_OW 250
52714: PUSH
52715: LD_VAR 0 7
52719: PPUSH
52720: CALL_OW 251
52724: PUSH
52725: EMPTY
52726: LIST
52727: LIST
52728: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
52729: LD_INT 35
52731: PPUSH
52732: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
52736: LD_ADDR_VAR 0 4
52740: PUSH
52741: LD_EXP 134
52745: PUSH
52746: LD_VAR 0 2
52750: ARRAY
52751: PUSH
52752: LD_VAR 0 3
52756: ARRAY
52757: PUSH
52758: LD_INT 1
52760: ARRAY
52761: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
52762: LD_ADDR_VAR 0 5
52766: PUSH
52767: LD_EXP 134
52771: PUSH
52772: LD_VAR 0 2
52776: ARRAY
52777: PUSH
52778: LD_VAR 0 3
52782: ARRAY
52783: PUSH
52784: LD_INT 2
52786: ARRAY
52787: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
52788: LD_VAR 0 7
52792: PPUSH
52793: LD_INT 10
52795: PPUSH
52796: CALL 71276 0 2
52800: PUSH
52801: LD_INT 4
52803: ARRAY
52804: IFFALSE 52842
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
52806: LD_VAR 0 7
52810: PPUSH
52811: LD_VAR 0 6
52815: PUSH
52816: LD_INT 1
52818: ARRAY
52819: PPUSH
52820: LD_VAR 0 6
52824: PUSH
52825: LD_INT 2
52827: ARRAY
52828: PPUSH
52829: CALL_OW 111
// wait ( 0 0$10 ) ;
52833: LD_INT 350
52835: PPUSH
52836: CALL_OW 67
// end else
52840: GO 52868
// begin ComMoveXY ( tmp , x , y ) ;
52842: LD_VAR 0 7
52846: PPUSH
52847: LD_VAR 0 4
52851: PPUSH
52852: LD_VAR 0 5
52856: PPUSH
52857: CALL_OW 111
// wait ( 0 0$3 ) ;
52861: LD_INT 105
52863: PPUSH
52864: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
52868: LD_VAR 0 7
52872: PPUSH
52873: LD_VAR 0 4
52877: PPUSH
52878: LD_VAR 0 5
52882: PPUSH
52883: CALL_OW 307
52887: IFFALSE 52729
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
52889: LD_VAR 0 7
52893: PPUSH
52894: LD_VAR 0 4
52898: PPUSH
52899: LD_VAR 0 5
52903: PPUSH
52904: LD_VAR 0 8
52908: PUSH
52909: LD_VAR 0 3
52913: ARRAY
52914: PPUSH
52915: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
52919: LD_INT 35
52921: PPUSH
52922: CALL_OW 67
// until not HasTask ( tmp ) ;
52926: LD_VAR 0 7
52930: PPUSH
52931: CALL_OW 314
52935: NOT
52936: IFFALSE 52919
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
52938: LD_ADDR_EXP 135
52942: PUSH
52943: LD_EXP 135
52947: PPUSH
52948: LD_VAR 0 2
52952: PUSH
52953: LD_EXP 135
52957: PUSH
52958: LD_VAR 0 2
52962: ARRAY
52963: PUSH
52964: LD_INT 1
52966: PLUS
52967: PUSH
52968: EMPTY
52969: LIST
52970: LIST
52971: PPUSH
52972: LD_VAR 0 8
52976: PUSH
52977: LD_VAR 0 3
52981: ARRAY
52982: PPUSH
52983: CALL 68683 0 3
52987: ST_TO_ADDR
// end ;
52988: GO 52646
52990: POP
52991: POP
// MC_Reset ( i , 124 ) ;
52992: LD_VAR 0 2
52996: PPUSH
52997: LD_INT 124
52999: PPUSH
53000: CALL 36795 0 2
// end ; end ;
53004: GO 52401
53006: POP
53007: POP
// end ;
53008: LD_VAR 0 1
53012: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
53013: LD_INT 0
53015: PPUSH
53016: PPUSH
53017: PPUSH
// if not mc_bases then
53018: LD_EXP 99
53022: NOT
53023: IFFALSE 53027
// exit ;
53025: GO 53633
// for i = 1 to mc_bases do
53027: LD_ADDR_VAR 0 2
53031: PUSH
53032: DOUBLE
53033: LD_INT 1
53035: DEC
53036: ST_TO_ADDR
53037: LD_EXP 99
53041: PUSH
53042: FOR_TO
53043: IFFALSE 53631
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
53045: LD_ADDR_VAR 0 3
53049: PUSH
53050: LD_EXP 99
53054: PUSH
53055: LD_VAR 0 2
53059: ARRAY
53060: PPUSH
53061: LD_INT 25
53063: PUSH
53064: LD_INT 4
53066: PUSH
53067: EMPTY
53068: LIST
53069: LIST
53070: PPUSH
53071: CALL_OW 72
53075: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
53076: LD_VAR 0 3
53080: NOT
53081: PUSH
53082: LD_EXP 136
53086: PUSH
53087: LD_VAR 0 2
53091: ARRAY
53092: NOT
53093: OR
53094: PUSH
53095: LD_EXP 99
53099: PUSH
53100: LD_VAR 0 2
53104: ARRAY
53105: PPUSH
53106: LD_INT 2
53108: PUSH
53109: LD_INT 30
53111: PUSH
53112: LD_INT 0
53114: PUSH
53115: EMPTY
53116: LIST
53117: LIST
53118: PUSH
53119: LD_INT 30
53121: PUSH
53122: LD_INT 1
53124: PUSH
53125: EMPTY
53126: LIST
53127: LIST
53128: PUSH
53129: EMPTY
53130: LIST
53131: LIST
53132: LIST
53133: PPUSH
53134: CALL_OW 72
53138: NOT
53139: OR
53140: IFFALSE 53190
// begin if mc_deposits_finder [ i ] then
53142: LD_EXP 137
53146: PUSH
53147: LD_VAR 0 2
53151: ARRAY
53152: IFFALSE 53188
// begin MC_Reset ( i , 125 ) ;
53154: LD_VAR 0 2
53158: PPUSH
53159: LD_INT 125
53161: PPUSH
53162: CALL 36795 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
53166: LD_ADDR_EXP 137
53170: PUSH
53171: LD_EXP 137
53175: PPUSH
53176: LD_VAR 0 2
53180: PPUSH
53181: EMPTY
53182: PPUSH
53183: CALL_OW 1
53187: ST_TO_ADDR
// end ; continue ;
53188: GO 53042
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
53190: LD_EXP 136
53194: PUSH
53195: LD_VAR 0 2
53199: ARRAY
53200: PUSH
53201: LD_INT 1
53203: ARRAY
53204: PUSH
53205: LD_INT 3
53207: ARRAY
53208: PUSH
53209: LD_INT 1
53211: EQUAL
53212: PUSH
53213: LD_INT 20
53215: PPUSH
53216: LD_EXP 125
53220: PUSH
53221: LD_VAR 0 2
53225: ARRAY
53226: PPUSH
53227: CALL_OW 321
53231: PUSH
53232: LD_INT 2
53234: NONEQUAL
53235: AND
53236: IFFALSE 53286
// begin if mc_deposits_finder [ i ] then
53238: LD_EXP 137
53242: PUSH
53243: LD_VAR 0 2
53247: ARRAY
53248: IFFALSE 53284
// begin MC_Reset ( i , 125 ) ;
53250: LD_VAR 0 2
53254: PPUSH
53255: LD_INT 125
53257: PPUSH
53258: CALL 36795 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
53262: LD_ADDR_EXP 137
53266: PUSH
53267: LD_EXP 137
53271: PPUSH
53272: LD_VAR 0 2
53276: PPUSH
53277: EMPTY
53278: PPUSH
53279: CALL_OW 1
53283: ST_TO_ADDR
// end ; continue ;
53284: GO 53042
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
53286: LD_EXP 136
53290: PUSH
53291: LD_VAR 0 2
53295: ARRAY
53296: PUSH
53297: LD_INT 1
53299: ARRAY
53300: PUSH
53301: LD_INT 1
53303: ARRAY
53304: PPUSH
53305: LD_EXP 136
53309: PUSH
53310: LD_VAR 0 2
53314: ARRAY
53315: PUSH
53316: LD_INT 1
53318: ARRAY
53319: PUSH
53320: LD_INT 2
53322: ARRAY
53323: PPUSH
53324: LD_EXP 125
53328: PUSH
53329: LD_VAR 0 2
53333: ARRAY
53334: PPUSH
53335: CALL_OW 440
53339: IFFALSE 53382
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
53341: LD_ADDR_EXP 136
53345: PUSH
53346: LD_EXP 136
53350: PPUSH
53351: LD_VAR 0 2
53355: PPUSH
53356: LD_EXP 136
53360: PUSH
53361: LD_VAR 0 2
53365: ARRAY
53366: PPUSH
53367: LD_INT 1
53369: PPUSH
53370: CALL_OW 3
53374: PPUSH
53375: CALL_OW 1
53379: ST_TO_ADDR
53380: GO 53629
// begin if not mc_deposits_finder [ i ] then
53382: LD_EXP 137
53386: PUSH
53387: LD_VAR 0 2
53391: ARRAY
53392: NOT
53393: IFFALSE 53445
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
53395: LD_ADDR_EXP 137
53399: PUSH
53400: LD_EXP 137
53404: PPUSH
53405: LD_VAR 0 2
53409: PPUSH
53410: LD_VAR 0 3
53414: PUSH
53415: LD_INT 1
53417: ARRAY
53418: PUSH
53419: EMPTY
53420: LIST
53421: PPUSH
53422: CALL_OW 1
53426: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
53427: LD_VAR 0 3
53431: PUSH
53432: LD_INT 1
53434: ARRAY
53435: PPUSH
53436: LD_INT 125
53438: PPUSH
53439: CALL_OW 109
// end else
53443: GO 53629
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
53445: LD_EXP 137
53449: PUSH
53450: LD_VAR 0 2
53454: ARRAY
53455: PUSH
53456: LD_INT 1
53458: ARRAY
53459: PPUSH
53460: CALL_OW 310
53464: IFFALSE 53487
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
53466: LD_EXP 137
53470: PUSH
53471: LD_VAR 0 2
53475: ARRAY
53476: PUSH
53477: LD_INT 1
53479: ARRAY
53480: PPUSH
53481: CALL_OW 122
53485: GO 53629
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
53487: LD_EXP 137
53491: PUSH
53492: LD_VAR 0 2
53496: ARRAY
53497: PUSH
53498: LD_INT 1
53500: ARRAY
53501: PPUSH
53502: CALL_OW 314
53506: NOT
53507: PUSH
53508: LD_EXP 137
53512: PUSH
53513: LD_VAR 0 2
53517: ARRAY
53518: PUSH
53519: LD_INT 1
53521: ARRAY
53522: PPUSH
53523: LD_EXP 136
53527: PUSH
53528: LD_VAR 0 2
53532: ARRAY
53533: PUSH
53534: LD_INT 1
53536: ARRAY
53537: PUSH
53538: LD_INT 1
53540: ARRAY
53541: PPUSH
53542: LD_EXP 136
53546: PUSH
53547: LD_VAR 0 2
53551: ARRAY
53552: PUSH
53553: LD_INT 1
53555: ARRAY
53556: PUSH
53557: LD_INT 2
53559: ARRAY
53560: PPUSH
53561: CALL_OW 297
53565: PUSH
53566: LD_INT 6
53568: GREATER
53569: AND
53570: IFFALSE 53629
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
53572: LD_EXP 137
53576: PUSH
53577: LD_VAR 0 2
53581: ARRAY
53582: PUSH
53583: LD_INT 1
53585: ARRAY
53586: PPUSH
53587: LD_EXP 136
53591: PUSH
53592: LD_VAR 0 2
53596: ARRAY
53597: PUSH
53598: LD_INT 1
53600: ARRAY
53601: PUSH
53602: LD_INT 1
53604: ARRAY
53605: PPUSH
53606: LD_EXP 136
53610: PUSH
53611: LD_VAR 0 2
53615: ARRAY
53616: PUSH
53617: LD_INT 1
53619: ARRAY
53620: PUSH
53621: LD_INT 2
53623: ARRAY
53624: PPUSH
53625: CALL_OW 111
// end ; end ; end ;
53629: GO 53042
53631: POP
53632: POP
// end ;
53633: LD_VAR 0 1
53637: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
53638: LD_INT 0
53640: PPUSH
53641: PPUSH
53642: PPUSH
53643: PPUSH
53644: PPUSH
53645: PPUSH
53646: PPUSH
53647: PPUSH
53648: PPUSH
53649: PPUSH
53650: PPUSH
// if not mc_bases then
53651: LD_EXP 99
53655: NOT
53656: IFFALSE 53660
// exit ;
53658: GO 54384
// for i = 1 to mc_bases do
53660: LD_ADDR_VAR 0 2
53664: PUSH
53665: DOUBLE
53666: LD_INT 1
53668: DEC
53669: ST_TO_ADDR
53670: LD_EXP 99
53674: PUSH
53675: FOR_TO
53676: IFFALSE 54382
// begin if not mc_bases [ i ] then
53678: LD_EXP 99
53682: PUSH
53683: LD_VAR 0 2
53687: ARRAY
53688: NOT
53689: IFFALSE 53693
// continue ;
53691: GO 53675
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
53693: LD_ADDR_VAR 0 7
53697: PUSH
53698: LD_EXP 99
53702: PUSH
53703: LD_VAR 0 2
53707: ARRAY
53708: PUSH
53709: LD_INT 1
53711: ARRAY
53712: PPUSH
53713: CALL_OW 248
53717: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
53718: LD_VAR 0 7
53722: PUSH
53723: LD_INT 3
53725: EQUAL
53726: PUSH
53727: LD_EXP 118
53731: PUSH
53732: LD_VAR 0 2
53736: ARRAY
53737: PUSH
53738: LD_EXP 121
53742: PUSH
53743: LD_VAR 0 2
53747: ARRAY
53748: UNION
53749: PPUSH
53750: LD_INT 33
53752: PUSH
53753: LD_INT 2
53755: PUSH
53756: EMPTY
53757: LIST
53758: LIST
53759: PPUSH
53760: CALL_OW 72
53764: NOT
53765: OR
53766: IFFALSE 53770
// continue ;
53768: GO 53675
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
53770: LD_ADDR_VAR 0 9
53774: PUSH
53775: LD_EXP 99
53779: PUSH
53780: LD_VAR 0 2
53784: ARRAY
53785: PPUSH
53786: LD_INT 30
53788: PUSH
53789: LD_INT 36
53791: PUSH
53792: EMPTY
53793: LIST
53794: LIST
53795: PPUSH
53796: CALL_OW 72
53800: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
53801: LD_ADDR_VAR 0 10
53805: PUSH
53806: LD_EXP 118
53810: PUSH
53811: LD_VAR 0 2
53815: ARRAY
53816: PPUSH
53817: LD_INT 34
53819: PUSH
53820: LD_INT 31
53822: PUSH
53823: EMPTY
53824: LIST
53825: LIST
53826: PPUSH
53827: CALL_OW 72
53831: ST_TO_ADDR
// if not cts and not mcts then
53832: LD_VAR 0 9
53836: NOT
53837: PUSH
53838: LD_VAR 0 10
53842: NOT
53843: AND
53844: IFFALSE 53848
// continue ;
53846: GO 53675
// x := cts ;
53848: LD_ADDR_VAR 0 11
53852: PUSH
53853: LD_VAR 0 9
53857: ST_TO_ADDR
// if not x then
53858: LD_VAR 0 11
53862: NOT
53863: IFFALSE 53875
// x := mcts ;
53865: LD_ADDR_VAR 0 11
53869: PUSH
53870: LD_VAR 0 10
53874: ST_TO_ADDR
// if mc_remote_driver [ i ] then
53875: LD_EXP 139
53879: PUSH
53880: LD_VAR 0 2
53884: ARRAY
53885: IFFALSE 54154
// for j in mc_remote_driver [ i ] do
53887: LD_ADDR_VAR 0 3
53891: PUSH
53892: LD_EXP 139
53896: PUSH
53897: LD_VAR 0 2
53901: ARRAY
53902: PUSH
53903: FOR_IN
53904: IFFALSE 54152
// begin if GetClass ( j ) <> 3 then
53906: LD_VAR 0 3
53910: PPUSH
53911: CALL_OW 257
53915: PUSH
53916: LD_INT 3
53918: NONEQUAL
53919: IFFALSE 53972
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
53921: LD_ADDR_EXP 139
53925: PUSH
53926: LD_EXP 139
53930: PPUSH
53931: LD_VAR 0 2
53935: PPUSH
53936: LD_EXP 139
53940: PUSH
53941: LD_VAR 0 2
53945: ARRAY
53946: PUSH
53947: LD_VAR 0 3
53951: DIFF
53952: PPUSH
53953: CALL_OW 1
53957: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53958: LD_VAR 0 3
53962: PPUSH
53963: LD_INT 0
53965: PPUSH
53966: CALL_OW 109
// continue ;
53970: GO 53903
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
53972: LD_VAR 0 3
53976: PPUSH
53977: CALL_OW 310
53981: NOT
53982: PUSH
53983: LD_VAR 0 3
53987: PPUSH
53988: CALL_OW 310
53992: PPUSH
53993: CALL_OW 266
53997: PUSH
53998: LD_INT 36
54000: NONEQUAL
54001: PUSH
54002: LD_VAR 0 3
54006: PPUSH
54007: CALL 101968 0 1
54011: NOT
54012: AND
54013: OR
54014: IFFALSE 54150
// begin if IsInUnit ( j ) then
54016: LD_VAR 0 3
54020: PPUSH
54021: CALL_OW 310
54025: IFFALSE 54036
// ComExitBuilding ( j ) ;
54027: LD_VAR 0 3
54031: PPUSH
54032: CALL_OW 122
// ct := 0 ;
54036: LD_ADDR_VAR 0 8
54040: PUSH
54041: LD_INT 0
54043: ST_TO_ADDR
// for k in x do
54044: LD_ADDR_VAR 0 4
54048: PUSH
54049: LD_VAR 0 11
54053: PUSH
54054: FOR_IN
54055: IFFALSE 54128
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
54057: LD_VAR 0 4
54061: PPUSH
54062: CALL_OW 264
54066: PUSH
54067: LD_INT 31
54069: EQUAL
54070: PUSH
54071: LD_VAR 0 4
54075: PPUSH
54076: CALL_OW 311
54080: NOT
54081: AND
54082: PUSH
54083: LD_VAR 0 4
54087: PPUSH
54088: CALL_OW 266
54092: PUSH
54093: LD_INT 36
54095: EQUAL
54096: PUSH
54097: LD_VAR 0 4
54101: PPUSH
54102: CALL_OW 313
54106: PUSH
54107: LD_INT 3
54109: LESS
54110: AND
54111: OR
54112: IFFALSE 54126
// begin ct := k ;
54114: LD_ADDR_VAR 0 8
54118: PUSH
54119: LD_VAR 0 4
54123: ST_TO_ADDR
// break ;
54124: GO 54128
// end ;
54126: GO 54054
54128: POP
54129: POP
// if ct then
54130: LD_VAR 0 8
54134: IFFALSE 54150
// ComEnterUnit ( j , ct ) ;
54136: LD_VAR 0 3
54140: PPUSH
54141: LD_VAR 0 8
54145: PPUSH
54146: CALL_OW 120
// end ; end ;
54150: GO 53903
54152: POP
54153: POP
// places := 0 ;
54154: LD_ADDR_VAR 0 5
54158: PUSH
54159: LD_INT 0
54161: ST_TO_ADDR
// for j = 1 to x do
54162: LD_ADDR_VAR 0 3
54166: PUSH
54167: DOUBLE
54168: LD_INT 1
54170: DEC
54171: ST_TO_ADDR
54172: LD_VAR 0 11
54176: PUSH
54177: FOR_TO
54178: IFFALSE 54233
// if GetWeapon ( x [ j ] ) = ar_control_tower then
54180: LD_VAR 0 11
54184: PUSH
54185: LD_VAR 0 3
54189: ARRAY
54190: PPUSH
54191: CALL_OW 264
54195: PUSH
54196: LD_INT 31
54198: EQUAL
54199: IFFALSE 54217
// places := places + 1 else
54201: LD_ADDR_VAR 0 5
54205: PUSH
54206: LD_VAR 0 5
54210: PUSH
54211: LD_INT 1
54213: PLUS
54214: ST_TO_ADDR
54215: GO 54231
// places := places + 3 ;
54217: LD_ADDR_VAR 0 5
54221: PUSH
54222: LD_VAR 0 5
54226: PUSH
54227: LD_INT 3
54229: PLUS
54230: ST_TO_ADDR
54231: GO 54177
54233: POP
54234: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
54235: LD_ADDR_VAR 0 6
54239: PUSH
54240: LD_EXP 99
54244: PUSH
54245: LD_VAR 0 2
54249: ARRAY
54250: PPUSH
54251: LD_INT 25
54253: PUSH
54254: LD_INT 3
54256: PUSH
54257: EMPTY
54258: LIST
54259: LIST
54260: PPUSH
54261: CALL_OW 72
54265: PUSH
54266: LD_EXP 139
54270: PUSH
54271: LD_VAR 0 2
54275: ARRAY
54276: DIFF
54277: PPUSH
54278: LD_INT 3
54280: PPUSH
54281: CALL 102868 0 2
54285: ST_TO_ADDR
// if not tmp then
54286: LD_VAR 0 6
54290: NOT
54291: IFFALSE 54295
// continue ;
54293: GO 53675
// places := places - mc_remote_driver [ i ] ;
54295: LD_ADDR_VAR 0 5
54299: PUSH
54300: LD_VAR 0 5
54304: PUSH
54305: LD_EXP 139
54309: PUSH
54310: LD_VAR 0 2
54314: ARRAY
54315: MINUS
54316: ST_TO_ADDR
// if places then
54317: LD_VAR 0 5
54321: IFFALSE 54380
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
54323: LD_ADDR_EXP 139
54327: PUSH
54328: LD_EXP 139
54332: PPUSH
54333: LD_VAR 0 2
54337: PPUSH
54338: LD_EXP 139
54342: PUSH
54343: LD_VAR 0 2
54347: ARRAY
54348: PUSH
54349: LD_VAR 0 6
54353: PUSH
54354: LD_INT 1
54356: ARRAY
54357: UNION
54358: PPUSH
54359: CALL_OW 1
54363: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
54364: LD_VAR 0 6
54368: PUSH
54369: LD_INT 1
54371: ARRAY
54372: PPUSH
54373: LD_INT 126
54375: PPUSH
54376: CALL_OW 109
// end ; end ;
54380: GO 53675
54382: POP
54383: POP
// end ;
54384: LD_VAR 0 1
54388: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
54389: LD_INT 0
54391: PPUSH
54392: PPUSH
54393: PPUSH
54394: PPUSH
54395: PPUSH
54396: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
54397: LD_VAR 0 1
54401: NOT
54402: PUSH
54403: LD_VAR 0 2
54407: NOT
54408: OR
54409: PUSH
54410: LD_VAR 0 3
54414: NOT
54415: OR
54416: PUSH
54417: LD_VAR 0 4
54421: PUSH
54422: LD_INT 1
54424: PUSH
54425: LD_INT 2
54427: PUSH
54428: LD_INT 3
54430: PUSH
54431: LD_INT 4
54433: PUSH
54434: LD_INT 5
54436: PUSH
54437: LD_INT 8
54439: PUSH
54440: LD_INT 9
54442: PUSH
54443: LD_INT 15
54445: PUSH
54446: LD_INT 16
54448: PUSH
54449: EMPTY
54450: LIST
54451: LIST
54452: LIST
54453: LIST
54454: LIST
54455: LIST
54456: LIST
54457: LIST
54458: LIST
54459: IN
54460: NOT
54461: OR
54462: IFFALSE 54466
// exit ;
54464: GO 55366
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
54466: LD_ADDR_VAR 0 2
54470: PUSH
54471: LD_VAR 0 2
54475: PPUSH
54476: LD_INT 21
54478: PUSH
54479: LD_INT 3
54481: PUSH
54482: EMPTY
54483: LIST
54484: LIST
54485: PUSH
54486: LD_INT 24
54488: PUSH
54489: LD_INT 250
54491: PUSH
54492: EMPTY
54493: LIST
54494: LIST
54495: PUSH
54496: EMPTY
54497: LIST
54498: LIST
54499: PPUSH
54500: CALL_OW 72
54504: ST_TO_ADDR
// case class of 1 , 15 :
54505: LD_VAR 0 4
54509: PUSH
54510: LD_INT 1
54512: DOUBLE
54513: EQUAL
54514: IFTRUE 54524
54516: LD_INT 15
54518: DOUBLE
54519: EQUAL
54520: IFTRUE 54524
54522: GO 54609
54524: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
54525: LD_ADDR_VAR 0 8
54529: PUSH
54530: LD_VAR 0 2
54534: PPUSH
54535: LD_INT 2
54537: PUSH
54538: LD_INT 30
54540: PUSH
54541: LD_INT 32
54543: PUSH
54544: EMPTY
54545: LIST
54546: LIST
54547: PUSH
54548: LD_INT 30
54550: PUSH
54551: LD_INT 31
54553: PUSH
54554: EMPTY
54555: LIST
54556: LIST
54557: PUSH
54558: EMPTY
54559: LIST
54560: LIST
54561: LIST
54562: PPUSH
54563: CALL_OW 72
54567: PUSH
54568: LD_VAR 0 2
54572: PPUSH
54573: LD_INT 2
54575: PUSH
54576: LD_INT 30
54578: PUSH
54579: LD_INT 4
54581: PUSH
54582: EMPTY
54583: LIST
54584: LIST
54585: PUSH
54586: LD_INT 30
54588: PUSH
54589: LD_INT 5
54591: PUSH
54592: EMPTY
54593: LIST
54594: LIST
54595: PUSH
54596: EMPTY
54597: LIST
54598: LIST
54599: LIST
54600: PPUSH
54601: CALL_OW 72
54605: ADD
54606: ST_TO_ADDR
54607: GO 54855
54609: LD_INT 2
54611: DOUBLE
54612: EQUAL
54613: IFTRUE 54623
54615: LD_INT 16
54617: DOUBLE
54618: EQUAL
54619: IFTRUE 54623
54621: GO 54669
54623: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
54624: LD_ADDR_VAR 0 8
54628: PUSH
54629: LD_VAR 0 2
54633: PPUSH
54634: LD_INT 2
54636: PUSH
54637: LD_INT 30
54639: PUSH
54640: LD_INT 0
54642: PUSH
54643: EMPTY
54644: LIST
54645: LIST
54646: PUSH
54647: LD_INT 30
54649: PUSH
54650: LD_INT 1
54652: PUSH
54653: EMPTY
54654: LIST
54655: LIST
54656: PUSH
54657: EMPTY
54658: LIST
54659: LIST
54660: LIST
54661: PPUSH
54662: CALL_OW 72
54666: ST_TO_ADDR
54667: GO 54855
54669: LD_INT 3
54671: DOUBLE
54672: EQUAL
54673: IFTRUE 54677
54675: GO 54723
54677: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
54678: LD_ADDR_VAR 0 8
54682: PUSH
54683: LD_VAR 0 2
54687: PPUSH
54688: LD_INT 2
54690: PUSH
54691: LD_INT 30
54693: PUSH
54694: LD_INT 2
54696: PUSH
54697: EMPTY
54698: LIST
54699: LIST
54700: PUSH
54701: LD_INT 30
54703: PUSH
54704: LD_INT 3
54706: PUSH
54707: EMPTY
54708: LIST
54709: LIST
54710: PUSH
54711: EMPTY
54712: LIST
54713: LIST
54714: LIST
54715: PPUSH
54716: CALL_OW 72
54720: ST_TO_ADDR
54721: GO 54855
54723: LD_INT 4
54725: DOUBLE
54726: EQUAL
54727: IFTRUE 54731
54729: GO 54788
54731: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
54732: LD_ADDR_VAR 0 8
54736: PUSH
54737: LD_VAR 0 2
54741: PPUSH
54742: LD_INT 2
54744: PUSH
54745: LD_INT 30
54747: PUSH
54748: LD_INT 6
54750: PUSH
54751: EMPTY
54752: LIST
54753: LIST
54754: PUSH
54755: LD_INT 30
54757: PUSH
54758: LD_INT 7
54760: PUSH
54761: EMPTY
54762: LIST
54763: LIST
54764: PUSH
54765: LD_INT 30
54767: PUSH
54768: LD_INT 8
54770: PUSH
54771: EMPTY
54772: LIST
54773: LIST
54774: PUSH
54775: EMPTY
54776: LIST
54777: LIST
54778: LIST
54779: LIST
54780: PPUSH
54781: CALL_OW 72
54785: ST_TO_ADDR
54786: GO 54855
54788: LD_INT 5
54790: DOUBLE
54791: EQUAL
54792: IFTRUE 54808
54794: LD_INT 8
54796: DOUBLE
54797: EQUAL
54798: IFTRUE 54808
54800: LD_INT 9
54802: DOUBLE
54803: EQUAL
54804: IFTRUE 54808
54806: GO 54854
54808: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
54809: LD_ADDR_VAR 0 8
54813: PUSH
54814: LD_VAR 0 2
54818: PPUSH
54819: LD_INT 2
54821: PUSH
54822: LD_INT 30
54824: PUSH
54825: LD_INT 4
54827: PUSH
54828: EMPTY
54829: LIST
54830: LIST
54831: PUSH
54832: LD_INT 30
54834: PUSH
54835: LD_INT 5
54837: PUSH
54838: EMPTY
54839: LIST
54840: LIST
54841: PUSH
54842: EMPTY
54843: LIST
54844: LIST
54845: LIST
54846: PPUSH
54847: CALL_OW 72
54851: ST_TO_ADDR
54852: GO 54855
54854: POP
// if not tmp then
54855: LD_VAR 0 8
54859: NOT
54860: IFFALSE 54864
// exit ;
54862: GO 55366
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
54864: LD_VAR 0 4
54868: PUSH
54869: LD_INT 1
54871: PUSH
54872: LD_INT 15
54874: PUSH
54875: EMPTY
54876: LIST
54877: LIST
54878: IN
54879: PUSH
54880: LD_EXP 108
54884: PUSH
54885: LD_VAR 0 1
54889: ARRAY
54890: AND
54891: IFFALSE 55047
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
54893: LD_ADDR_VAR 0 9
54897: PUSH
54898: LD_EXP 108
54902: PUSH
54903: LD_VAR 0 1
54907: ARRAY
54908: PUSH
54909: LD_INT 1
54911: ARRAY
54912: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
54913: LD_VAR 0 9
54917: PUSH
54918: LD_EXP 109
54922: PUSH
54923: LD_VAR 0 1
54927: ARRAY
54928: IN
54929: NOT
54930: IFFALSE 55045
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
54932: LD_ADDR_EXP 109
54936: PUSH
54937: LD_EXP 109
54941: PPUSH
54942: LD_VAR 0 1
54946: PUSH
54947: LD_EXP 109
54951: PUSH
54952: LD_VAR 0 1
54956: ARRAY
54957: PUSH
54958: LD_INT 1
54960: PLUS
54961: PUSH
54962: EMPTY
54963: LIST
54964: LIST
54965: PPUSH
54966: LD_VAR 0 9
54970: PPUSH
54971: CALL 68683 0 3
54975: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
54976: LD_ADDR_EXP 108
54980: PUSH
54981: LD_EXP 108
54985: PPUSH
54986: LD_VAR 0 1
54990: PPUSH
54991: LD_EXP 108
54995: PUSH
54996: LD_VAR 0 1
55000: ARRAY
55001: PUSH
55002: LD_VAR 0 9
55006: DIFF
55007: PPUSH
55008: CALL_OW 1
55012: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
55013: LD_VAR 0 3
55017: PPUSH
55018: LD_EXP 109
55022: PUSH
55023: LD_VAR 0 1
55027: ARRAY
55028: PUSH
55029: LD_EXP 109
55033: PUSH
55034: LD_VAR 0 1
55038: ARRAY
55039: ARRAY
55040: PPUSH
55041: CALL_OW 120
// end ; exit ;
55045: GO 55366
// end ; if tmp > 1 then
55047: LD_VAR 0 8
55051: PUSH
55052: LD_INT 1
55054: GREATER
55055: IFFALSE 55159
// for i = 2 to tmp do
55057: LD_ADDR_VAR 0 6
55061: PUSH
55062: DOUBLE
55063: LD_INT 2
55065: DEC
55066: ST_TO_ADDR
55067: LD_VAR 0 8
55071: PUSH
55072: FOR_TO
55073: IFFALSE 55157
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
55075: LD_VAR 0 8
55079: PUSH
55080: LD_VAR 0 6
55084: ARRAY
55085: PPUSH
55086: CALL_OW 461
55090: PUSH
55091: LD_INT 6
55093: EQUAL
55094: IFFALSE 55155
// begin x := tmp [ i ] ;
55096: LD_ADDR_VAR 0 9
55100: PUSH
55101: LD_VAR 0 8
55105: PUSH
55106: LD_VAR 0 6
55110: ARRAY
55111: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
55112: LD_ADDR_VAR 0 8
55116: PUSH
55117: LD_VAR 0 8
55121: PPUSH
55122: LD_VAR 0 6
55126: PPUSH
55127: CALL_OW 3
55131: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
55132: LD_ADDR_VAR 0 8
55136: PUSH
55137: LD_VAR 0 8
55141: PPUSH
55142: LD_INT 1
55144: PPUSH
55145: LD_VAR 0 9
55149: PPUSH
55150: CALL_OW 2
55154: ST_TO_ADDR
// end ;
55155: GO 55072
55157: POP
55158: POP
// for i in tmp do
55159: LD_ADDR_VAR 0 6
55163: PUSH
55164: LD_VAR 0 8
55168: PUSH
55169: FOR_IN
55170: IFFALSE 55239
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
55172: LD_VAR 0 6
55176: PPUSH
55177: CALL_OW 313
55181: PUSH
55182: LD_INT 6
55184: LESS
55185: PUSH
55186: LD_VAR 0 6
55190: PPUSH
55191: CALL_OW 266
55195: PUSH
55196: LD_INT 31
55198: PUSH
55199: LD_INT 32
55201: PUSH
55202: EMPTY
55203: LIST
55204: LIST
55205: IN
55206: NOT
55207: AND
55208: PUSH
55209: LD_VAR 0 6
55213: PPUSH
55214: CALL_OW 313
55218: PUSH
55219: LD_INT 0
55221: EQUAL
55222: OR
55223: IFFALSE 55237
// begin j := i ;
55225: LD_ADDR_VAR 0 7
55229: PUSH
55230: LD_VAR 0 6
55234: ST_TO_ADDR
// break ;
55235: GO 55239
// end ; end ;
55237: GO 55169
55239: POP
55240: POP
// if j then
55241: LD_VAR 0 7
55245: IFFALSE 55263
// ComEnterUnit ( unit , j ) else
55247: LD_VAR 0 3
55251: PPUSH
55252: LD_VAR 0 7
55256: PPUSH
55257: CALL_OW 120
55261: GO 55366
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
55263: LD_ADDR_VAR 0 10
55267: PUSH
55268: LD_VAR 0 2
55272: PPUSH
55273: LD_INT 2
55275: PUSH
55276: LD_INT 30
55278: PUSH
55279: LD_INT 0
55281: PUSH
55282: EMPTY
55283: LIST
55284: LIST
55285: PUSH
55286: LD_INT 30
55288: PUSH
55289: LD_INT 1
55291: PUSH
55292: EMPTY
55293: LIST
55294: LIST
55295: PUSH
55296: EMPTY
55297: LIST
55298: LIST
55299: LIST
55300: PPUSH
55301: CALL_OW 72
55305: ST_TO_ADDR
// if depot then
55306: LD_VAR 0 10
55310: IFFALSE 55366
// begin depot := NearestUnitToUnit ( depot , unit ) ;
55312: LD_ADDR_VAR 0 10
55316: PUSH
55317: LD_VAR 0 10
55321: PPUSH
55322: LD_VAR 0 3
55326: PPUSH
55327: CALL_OW 74
55331: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
55332: LD_VAR 0 3
55336: PPUSH
55337: LD_VAR 0 10
55341: PPUSH
55342: CALL_OW 296
55346: PUSH
55347: LD_INT 10
55349: GREATER
55350: IFFALSE 55366
// ComStandNearbyBuilding ( unit , depot ) ;
55352: LD_VAR 0 3
55356: PPUSH
55357: LD_VAR 0 10
55361: PPUSH
55362: CALL 63360 0 2
// end ; end ; end ;
55366: LD_VAR 0 5
55370: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
55371: LD_INT 0
55373: PPUSH
55374: PPUSH
55375: PPUSH
55376: PPUSH
// if not mc_bases then
55377: LD_EXP 99
55381: NOT
55382: IFFALSE 55386
// exit ;
55384: GO 55625
// for i = 1 to mc_bases do
55386: LD_ADDR_VAR 0 2
55390: PUSH
55391: DOUBLE
55392: LD_INT 1
55394: DEC
55395: ST_TO_ADDR
55396: LD_EXP 99
55400: PUSH
55401: FOR_TO
55402: IFFALSE 55623
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
55404: LD_ADDR_VAR 0 4
55408: PUSH
55409: LD_EXP 99
55413: PUSH
55414: LD_VAR 0 2
55418: ARRAY
55419: PPUSH
55420: LD_INT 21
55422: PUSH
55423: LD_INT 1
55425: PUSH
55426: EMPTY
55427: LIST
55428: LIST
55429: PPUSH
55430: CALL_OW 72
55434: PUSH
55435: LD_EXP 128
55439: PUSH
55440: LD_VAR 0 2
55444: ARRAY
55445: UNION
55446: ST_TO_ADDR
// if not tmp then
55447: LD_VAR 0 4
55451: NOT
55452: IFFALSE 55456
// continue ;
55454: GO 55401
// for j in tmp do
55456: LD_ADDR_VAR 0 3
55460: PUSH
55461: LD_VAR 0 4
55465: PUSH
55466: FOR_IN
55467: IFFALSE 55619
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
55469: LD_VAR 0 3
55473: PPUSH
55474: CALL_OW 110
55478: NOT
55479: PUSH
55480: LD_VAR 0 3
55484: PPUSH
55485: CALL_OW 314
55489: NOT
55490: AND
55491: PUSH
55492: LD_VAR 0 3
55496: PPUSH
55497: CALL_OW 311
55501: NOT
55502: AND
55503: PUSH
55504: LD_VAR 0 3
55508: PPUSH
55509: CALL_OW 310
55513: NOT
55514: AND
55515: PUSH
55516: LD_VAR 0 3
55520: PUSH
55521: LD_EXP 102
55525: PUSH
55526: LD_VAR 0 2
55530: ARRAY
55531: PUSH
55532: LD_INT 1
55534: ARRAY
55535: IN
55536: NOT
55537: AND
55538: PUSH
55539: LD_VAR 0 3
55543: PUSH
55544: LD_EXP 102
55548: PUSH
55549: LD_VAR 0 2
55553: ARRAY
55554: PUSH
55555: LD_INT 2
55557: ARRAY
55558: IN
55559: NOT
55560: AND
55561: PUSH
55562: LD_VAR 0 3
55566: PUSH
55567: LD_EXP 111
55571: PUSH
55572: LD_VAR 0 2
55576: ARRAY
55577: IN
55578: NOT
55579: AND
55580: IFFALSE 55617
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
55582: LD_VAR 0 2
55586: PPUSH
55587: LD_EXP 99
55591: PUSH
55592: LD_VAR 0 2
55596: ARRAY
55597: PPUSH
55598: LD_VAR 0 3
55602: PPUSH
55603: LD_VAR 0 3
55607: PPUSH
55608: CALL_OW 257
55612: PPUSH
55613: CALL 54389 0 4
// end ;
55617: GO 55466
55619: POP
55620: POP
// end ;
55621: GO 55401
55623: POP
55624: POP
// end ;
55625: LD_VAR 0 1
55629: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
55630: LD_INT 0
55632: PPUSH
55633: PPUSH
55634: PPUSH
55635: PPUSH
55636: PPUSH
55637: PPUSH
// if not mc_bases [ base ] then
55638: LD_EXP 99
55642: PUSH
55643: LD_VAR 0 1
55647: ARRAY
55648: NOT
55649: IFFALSE 55653
// exit ;
55651: GO 55835
// tmp := [ ] ;
55653: LD_ADDR_VAR 0 6
55657: PUSH
55658: EMPTY
55659: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
55660: LD_ADDR_VAR 0 7
55664: PUSH
55665: LD_VAR 0 3
55669: PPUSH
55670: LD_INT 0
55672: PPUSH
55673: CALL_OW 517
55677: ST_TO_ADDR
// if not list then
55678: LD_VAR 0 7
55682: NOT
55683: IFFALSE 55687
// exit ;
55685: GO 55835
// for i = 1 to amount do
55687: LD_ADDR_VAR 0 5
55691: PUSH
55692: DOUBLE
55693: LD_INT 1
55695: DEC
55696: ST_TO_ADDR
55697: LD_VAR 0 2
55701: PUSH
55702: FOR_TO
55703: IFFALSE 55783
// begin x := rand ( 1 , list [ 1 ] ) ;
55705: LD_ADDR_VAR 0 8
55709: PUSH
55710: LD_INT 1
55712: PPUSH
55713: LD_VAR 0 7
55717: PUSH
55718: LD_INT 1
55720: ARRAY
55721: PPUSH
55722: CALL_OW 12
55726: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
55727: LD_ADDR_VAR 0 6
55731: PUSH
55732: LD_VAR 0 6
55736: PPUSH
55737: LD_VAR 0 5
55741: PPUSH
55742: LD_VAR 0 7
55746: PUSH
55747: LD_INT 1
55749: ARRAY
55750: PUSH
55751: LD_VAR 0 8
55755: ARRAY
55756: PUSH
55757: LD_VAR 0 7
55761: PUSH
55762: LD_INT 2
55764: ARRAY
55765: PUSH
55766: LD_VAR 0 8
55770: ARRAY
55771: PUSH
55772: EMPTY
55773: LIST
55774: LIST
55775: PPUSH
55776: CALL_OW 1
55780: ST_TO_ADDR
// end ;
55781: GO 55702
55783: POP
55784: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
55785: LD_ADDR_EXP 112
55789: PUSH
55790: LD_EXP 112
55794: PPUSH
55795: LD_VAR 0 1
55799: PPUSH
55800: LD_VAR 0 6
55804: PPUSH
55805: CALL_OW 1
55809: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
55810: LD_ADDR_EXP 114
55814: PUSH
55815: LD_EXP 114
55819: PPUSH
55820: LD_VAR 0 1
55824: PPUSH
55825: LD_VAR 0 3
55829: PPUSH
55830: CALL_OW 1
55834: ST_TO_ADDR
// end ;
55835: LD_VAR 0 4
55839: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
55840: LD_INT 0
55842: PPUSH
// if not mc_bases [ base ] then
55843: LD_EXP 99
55847: PUSH
55848: LD_VAR 0 1
55852: ARRAY
55853: NOT
55854: IFFALSE 55858
// exit ;
55856: GO 55883
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
55858: LD_ADDR_EXP 104
55862: PUSH
55863: LD_EXP 104
55867: PPUSH
55868: LD_VAR 0 1
55872: PPUSH
55873: LD_VAR 0 2
55877: PPUSH
55878: CALL_OW 1
55882: ST_TO_ADDR
// end ;
55883: LD_VAR 0 3
55887: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
55888: LD_INT 0
55890: PPUSH
// if not mc_bases [ base ] then
55891: LD_EXP 99
55895: PUSH
55896: LD_VAR 0 1
55900: ARRAY
55901: NOT
55902: IFFALSE 55906
// exit ;
55904: GO 55943
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
55906: LD_ADDR_EXP 104
55910: PUSH
55911: LD_EXP 104
55915: PPUSH
55916: LD_VAR 0 1
55920: PPUSH
55921: LD_EXP 104
55925: PUSH
55926: LD_VAR 0 1
55930: ARRAY
55931: PUSH
55932: LD_VAR 0 2
55936: UNION
55937: PPUSH
55938: CALL_OW 1
55942: ST_TO_ADDR
// end ;
55943: LD_VAR 0 3
55947: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
55948: LD_INT 0
55950: PPUSH
// if not mc_bases [ base ] then
55951: LD_EXP 99
55955: PUSH
55956: LD_VAR 0 1
55960: ARRAY
55961: NOT
55962: IFFALSE 55966
// exit ;
55964: GO 55991
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
55966: LD_ADDR_EXP 120
55970: PUSH
55971: LD_EXP 120
55975: PPUSH
55976: LD_VAR 0 1
55980: PPUSH
55981: LD_VAR 0 2
55985: PPUSH
55986: CALL_OW 1
55990: ST_TO_ADDR
// end ;
55991: LD_VAR 0 3
55995: RET
// export function MC_InsertProduceList ( base , components ) ; begin
55996: LD_INT 0
55998: PPUSH
// if not mc_bases [ base ] then
55999: LD_EXP 99
56003: PUSH
56004: LD_VAR 0 1
56008: ARRAY
56009: NOT
56010: IFFALSE 56014
// exit ;
56012: GO 56051
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
56014: LD_ADDR_EXP 120
56018: PUSH
56019: LD_EXP 120
56023: PPUSH
56024: LD_VAR 0 1
56028: PPUSH
56029: LD_EXP 120
56033: PUSH
56034: LD_VAR 0 1
56038: ARRAY
56039: PUSH
56040: LD_VAR 0 2
56044: ADD
56045: PPUSH
56046: CALL_OW 1
56050: ST_TO_ADDR
// end ;
56051: LD_VAR 0 3
56055: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
56056: LD_INT 0
56058: PPUSH
// if not mc_bases [ base ] then
56059: LD_EXP 99
56063: PUSH
56064: LD_VAR 0 1
56068: ARRAY
56069: NOT
56070: IFFALSE 56074
// exit ;
56072: GO 56128
// mc_defender := Replace ( mc_defender , base , deflist ) ;
56074: LD_ADDR_EXP 121
56078: PUSH
56079: LD_EXP 121
56083: PPUSH
56084: LD_VAR 0 1
56088: PPUSH
56089: LD_VAR 0 2
56093: PPUSH
56094: CALL_OW 1
56098: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
56099: LD_ADDR_EXP 110
56103: PUSH
56104: LD_EXP 110
56108: PPUSH
56109: LD_VAR 0 1
56113: PPUSH
56114: LD_VAR 0 2
56118: PUSH
56119: LD_INT 0
56121: PLUS
56122: PPUSH
56123: CALL_OW 1
56127: ST_TO_ADDR
// end ;
56128: LD_VAR 0 3
56132: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
56133: LD_INT 0
56135: PPUSH
// if not mc_bases [ base ] then
56136: LD_EXP 99
56140: PUSH
56141: LD_VAR 0 1
56145: ARRAY
56146: NOT
56147: IFFALSE 56151
// exit ;
56149: GO 56176
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
56151: LD_ADDR_EXP 110
56155: PUSH
56156: LD_EXP 110
56160: PPUSH
56161: LD_VAR 0 1
56165: PPUSH
56166: LD_VAR 0 2
56170: PPUSH
56171: CALL_OW 1
56175: ST_TO_ADDR
// end ;
56176: LD_VAR 0 3
56180: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
56181: LD_INT 0
56183: PPUSH
56184: PPUSH
56185: PPUSH
56186: PPUSH
// if not mc_bases [ base ] then
56187: LD_EXP 99
56191: PUSH
56192: LD_VAR 0 1
56196: ARRAY
56197: NOT
56198: IFFALSE 56202
// exit ;
56200: GO 56267
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
56202: LD_ADDR_EXP 119
56206: PUSH
56207: LD_EXP 119
56211: PPUSH
56212: LD_VAR 0 1
56216: PUSH
56217: LD_EXP 119
56221: PUSH
56222: LD_VAR 0 1
56226: ARRAY
56227: PUSH
56228: LD_INT 1
56230: PLUS
56231: PUSH
56232: EMPTY
56233: LIST
56234: LIST
56235: PPUSH
56236: LD_VAR 0 1
56240: PUSH
56241: LD_VAR 0 2
56245: PUSH
56246: LD_VAR 0 3
56250: PUSH
56251: LD_VAR 0 4
56255: PUSH
56256: EMPTY
56257: LIST
56258: LIST
56259: LIST
56260: LIST
56261: PPUSH
56262: CALL 68683 0 3
56266: ST_TO_ADDR
// end ;
56267: LD_VAR 0 5
56271: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
56272: LD_INT 0
56274: PPUSH
// if not mc_bases [ base ] then
56275: LD_EXP 99
56279: PUSH
56280: LD_VAR 0 1
56284: ARRAY
56285: NOT
56286: IFFALSE 56290
// exit ;
56288: GO 56315
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
56290: LD_ADDR_EXP 136
56294: PUSH
56295: LD_EXP 136
56299: PPUSH
56300: LD_VAR 0 1
56304: PPUSH
56305: LD_VAR 0 2
56309: PPUSH
56310: CALL_OW 1
56314: ST_TO_ADDR
// end ;
56315: LD_VAR 0 3
56319: RET
// export function MC_GetMinesField ( base ) ; begin
56320: LD_INT 0
56322: PPUSH
// result := mc_mines [ base ] ;
56323: LD_ADDR_VAR 0 2
56327: PUSH
56328: LD_EXP 112
56332: PUSH
56333: LD_VAR 0 1
56337: ARRAY
56338: ST_TO_ADDR
// end ;
56339: LD_VAR 0 2
56343: RET
// export function MC_GetProduceList ( base ) ; begin
56344: LD_INT 0
56346: PPUSH
// result := mc_produce [ base ] ;
56347: LD_ADDR_VAR 0 2
56351: PUSH
56352: LD_EXP 120
56356: PUSH
56357: LD_VAR 0 1
56361: ARRAY
56362: ST_TO_ADDR
// end ;
56363: LD_VAR 0 2
56367: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
56368: LD_INT 0
56370: PPUSH
56371: PPUSH
// if not mc_bases then
56372: LD_EXP 99
56376: NOT
56377: IFFALSE 56381
// exit ;
56379: GO 56446
// if mc_bases [ base ] then
56381: LD_EXP 99
56385: PUSH
56386: LD_VAR 0 1
56390: ARRAY
56391: IFFALSE 56446
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
56393: LD_ADDR_VAR 0 3
56397: PUSH
56398: LD_EXP 99
56402: PUSH
56403: LD_VAR 0 1
56407: ARRAY
56408: PPUSH
56409: LD_INT 30
56411: PUSH
56412: LD_VAR 0 2
56416: PUSH
56417: EMPTY
56418: LIST
56419: LIST
56420: PPUSH
56421: CALL_OW 72
56425: ST_TO_ADDR
// if result then
56426: LD_VAR 0 3
56430: IFFALSE 56446
// result := result [ 1 ] ;
56432: LD_ADDR_VAR 0 3
56436: PUSH
56437: LD_VAR 0 3
56441: PUSH
56442: LD_INT 1
56444: ARRAY
56445: ST_TO_ADDR
// end ; end ;
56446: LD_VAR 0 3
56450: RET
// export function MC_SetTame ( base , area ) ; begin
56451: LD_INT 0
56453: PPUSH
// if not mc_bases or not base then
56454: LD_EXP 99
56458: NOT
56459: PUSH
56460: LD_VAR 0 1
56464: NOT
56465: OR
56466: IFFALSE 56470
// exit ;
56468: GO 56495
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
56470: LD_ADDR_EXP 127
56474: PUSH
56475: LD_EXP 127
56479: PPUSH
56480: LD_VAR 0 1
56484: PPUSH
56485: LD_VAR 0 2
56489: PPUSH
56490: CALL_OW 1
56494: ST_TO_ADDR
// end ;
56495: LD_VAR 0 3
56499: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
56500: LD_INT 0
56502: PPUSH
56503: PPUSH
// if not mc_bases or not base then
56504: LD_EXP 99
56508: NOT
56509: PUSH
56510: LD_VAR 0 1
56514: NOT
56515: OR
56516: IFFALSE 56520
// exit ;
56518: GO 56622
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
56520: LD_ADDR_VAR 0 4
56524: PUSH
56525: LD_EXP 99
56529: PUSH
56530: LD_VAR 0 1
56534: ARRAY
56535: PPUSH
56536: LD_INT 30
56538: PUSH
56539: LD_VAR 0 2
56543: PUSH
56544: EMPTY
56545: LIST
56546: LIST
56547: PPUSH
56548: CALL_OW 72
56552: ST_TO_ADDR
// if not tmp then
56553: LD_VAR 0 4
56557: NOT
56558: IFFALSE 56562
// exit ;
56560: GO 56622
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
56562: LD_ADDR_EXP 131
56566: PUSH
56567: LD_EXP 131
56571: PPUSH
56572: LD_VAR 0 1
56576: PPUSH
56577: LD_EXP 131
56581: PUSH
56582: LD_VAR 0 1
56586: ARRAY
56587: PPUSH
56588: LD_EXP 131
56592: PUSH
56593: LD_VAR 0 1
56597: ARRAY
56598: PUSH
56599: LD_INT 1
56601: PLUS
56602: PPUSH
56603: LD_VAR 0 4
56607: PUSH
56608: LD_INT 1
56610: ARRAY
56611: PPUSH
56612: CALL_OW 2
56616: PPUSH
56617: CALL_OW 1
56621: ST_TO_ADDR
// end ;
56622: LD_VAR 0 3
56626: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
56627: LD_INT 0
56629: PPUSH
56630: PPUSH
// if not mc_bases or not base or not kinds then
56631: LD_EXP 99
56635: NOT
56636: PUSH
56637: LD_VAR 0 1
56641: NOT
56642: OR
56643: PUSH
56644: LD_VAR 0 2
56648: NOT
56649: OR
56650: IFFALSE 56654
// exit ;
56652: GO 56715
// for i in kinds do
56654: LD_ADDR_VAR 0 4
56658: PUSH
56659: LD_VAR 0 2
56663: PUSH
56664: FOR_IN
56665: IFFALSE 56713
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
56667: LD_ADDR_EXP 133
56671: PUSH
56672: LD_EXP 133
56676: PPUSH
56677: LD_VAR 0 1
56681: PUSH
56682: LD_EXP 133
56686: PUSH
56687: LD_VAR 0 1
56691: ARRAY
56692: PUSH
56693: LD_INT 1
56695: PLUS
56696: PUSH
56697: EMPTY
56698: LIST
56699: LIST
56700: PPUSH
56701: LD_VAR 0 4
56705: PPUSH
56706: CALL 68683 0 3
56710: ST_TO_ADDR
56711: GO 56664
56713: POP
56714: POP
// end ;
56715: LD_VAR 0 3
56719: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
56720: LD_INT 0
56722: PPUSH
// if not mc_bases or not base or not areas then
56723: LD_EXP 99
56727: NOT
56728: PUSH
56729: LD_VAR 0 1
56733: NOT
56734: OR
56735: PUSH
56736: LD_VAR 0 2
56740: NOT
56741: OR
56742: IFFALSE 56746
// exit ;
56744: GO 56771
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
56746: LD_ADDR_EXP 117
56750: PUSH
56751: LD_EXP 117
56755: PPUSH
56756: LD_VAR 0 1
56760: PPUSH
56761: LD_VAR 0 2
56765: PPUSH
56766: CALL_OW 1
56770: ST_TO_ADDR
// end ;
56771: LD_VAR 0 3
56775: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
56776: LD_INT 0
56778: PPUSH
// if not mc_bases or not base or not teleports_exit then
56779: LD_EXP 99
56783: NOT
56784: PUSH
56785: LD_VAR 0 1
56789: NOT
56790: OR
56791: PUSH
56792: LD_VAR 0 2
56796: NOT
56797: OR
56798: IFFALSE 56802
// exit ;
56800: GO 56827
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
56802: LD_ADDR_EXP 134
56806: PUSH
56807: LD_EXP 134
56811: PPUSH
56812: LD_VAR 0 1
56816: PPUSH
56817: LD_VAR 0 2
56821: PPUSH
56822: CALL_OW 1
56826: ST_TO_ADDR
// end ;
56827: LD_VAR 0 3
56831: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
56832: LD_INT 0
56834: PPUSH
56835: PPUSH
56836: PPUSH
// if not mc_bases or not base or not ext_list then
56837: LD_EXP 99
56841: NOT
56842: PUSH
56843: LD_VAR 0 1
56847: NOT
56848: OR
56849: PUSH
56850: LD_VAR 0 5
56854: NOT
56855: OR
56856: IFFALSE 56860
// exit ;
56858: GO 57033
// tmp := GetFacExtXYD ( x , y , d ) ;
56860: LD_ADDR_VAR 0 8
56864: PUSH
56865: LD_VAR 0 2
56869: PPUSH
56870: LD_VAR 0 3
56874: PPUSH
56875: LD_VAR 0 4
56879: PPUSH
56880: CALL 101998 0 3
56884: ST_TO_ADDR
// if not tmp then
56885: LD_VAR 0 8
56889: NOT
56890: IFFALSE 56894
// exit ;
56892: GO 57033
// for i in tmp do
56894: LD_ADDR_VAR 0 7
56898: PUSH
56899: LD_VAR 0 8
56903: PUSH
56904: FOR_IN
56905: IFFALSE 57031
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
56907: LD_ADDR_EXP 104
56911: PUSH
56912: LD_EXP 104
56916: PPUSH
56917: LD_VAR 0 1
56921: PPUSH
56922: LD_EXP 104
56926: PUSH
56927: LD_VAR 0 1
56931: ARRAY
56932: PPUSH
56933: LD_EXP 104
56937: PUSH
56938: LD_VAR 0 1
56942: ARRAY
56943: PUSH
56944: LD_INT 1
56946: PLUS
56947: PPUSH
56948: LD_VAR 0 5
56952: PUSH
56953: LD_INT 1
56955: ARRAY
56956: PUSH
56957: LD_VAR 0 7
56961: PUSH
56962: LD_INT 1
56964: ARRAY
56965: PUSH
56966: LD_VAR 0 7
56970: PUSH
56971: LD_INT 2
56973: ARRAY
56974: PUSH
56975: LD_VAR 0 7
56979: PUSH
56980: LD_INT 3
56982: ARRAY
56983: PUSH
56984: EMPTY
56985: LIST
56986: LIST
56987: LIST
56988: LIST
56989: PPUSH
56990: CALL_OW 2
56994: PPUSH
56995: CALL_OW 1
56999: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
57000: LD_ADDR_VAR 0 5
57004: PUSH
57005: LD_VAR 0 5
57009: PPUSH
57010: LD_INT 1
57012: PPUSH
57013: CALL_OW 3
57017: ST_TO_ADDR
// if not ext_list then
57018: LD_VAR 0 5
57022: NOT
57023: IFFALSE 57029
// exit ;
57025: POP
57026: POP
57027: GO 57033
// end ;
57029: GO 56904
57031: POP
57032: POP
// end ;
57033: LD_VAR 0 6
57037: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
57038: LD_INT 0
57040: PPUSH
// if not mc_bases or not base or not weapon_list then
57041: LD_EXP 99
57045: NOT
57046: PUSH
57047: LD_VAR 0 1
57051: NOT
57052: OR
57053: PUSH
57054: LD_VAR 0 2
57058: NOT
57059: OR
57060: IFFALSE 57064
// exit ;
57062: GO 57089
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
57064: LD_ADDR_EXP 138
57068: PUSH
57069: LD_EXP 138
57073: PPUSH
57074: LD_VAR 0 1
57078: PPUSH
57079: LD_VAR 0 2
57083: PPUSH
57084: CALL_OW 1
57088: ST_TO_ADDR
// end ;
57089: LD_VAR 0 3
57093: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
57094: LD_INT 0
57096: PPUSH
// if not mc_bases or not base or not tech_list then
57097: LD_EXP 99
57101: NOT
57102: PUSH
57103: LD_VAR 0 1
57107: NOT
57108: OR
57109: PUSH
57110: LD_VAR 0 2
57114: NOT
57115: OR
57116: IFFALSE 57120
// exit ;
57118: GO 57145
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
57120: LD_ADDR_EXP 126
57124: PUSH
57125: LD_EXP 126
57129: PPUSH
57130: LD_VAR 0 1
57134: PPUSH
57135: LD_VAR 0 2
57139: PPUSH
57140: CALL_OW 1
57144: ST_TO_ADDR
// end ;
57145: LD_VAR 0 3
57149: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
57150: LD_INT 0
57152: PPUSH
// if not mc_bases or not parking_area or not base then
57153: LD_EXP 99
57157: NOT
57158: PUSH
57159: LD_VAR 0 2
57163: NOT
57164: OR
57165: PUSH
57166: LD_VAR 0 1
57170: NOT
57171: OR
57172: IFFALSE 57176
// exit ;
57174: GO 57201
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
57176: LD_ADDR_EXP 123
57180: PUSH
57181: LD_EXP 123
57185: PPUSH
57186: LD_VAR 0 1
57190: PPUSH
57191: LD_VAR 0 2
57195: PPUSH
57196: CALL_OW 1
57200: ST_TO_ADDR
// end ;
57201: LD_VAR 0 3
57205: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
57206: LD_INT 0
57208: PPUSH
// if not mc_bases or not base or not scan_area then
57209: LD_EXP 99
57213: NOT
57214: PUSH
57215: LD_VAR 0 1
57219: NOT
57220: OR
57221: PUSH
57222: LD_VAR 0 2
57226: NOT
57227: OR
57228: IFFALSE 57232
// exit ;
57230: GO 57257
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
57232: LD_ADDR_EXP 124
57236: PUSH
57237: LD_EXP 124
57241: PPUSH
57242: LD_VAR 0 1
57246: PPUSH
57247: LD_VAR 0 2
57251: PPUSH
57252: CALL_OW 1
57256: ST_TO_ADDR
// end ;
57257: LD_VAR 0 3
57261: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
57262: LD_INT 0
57264: PPUSH
57265: PPUSH
// if not mc_bases or not base then
57266: LD_EXP 99
57270: NOT
57271: PUSH
57272: LD_VAR 0 1
57276: NOT
57277: OR
57278: IFFALSE 57282
// exit ;
57280: GO 57346
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
57282: LD_ADDR_VAR 0 3
57286: PUSH
57287: LD_INT 1
57289: PUSH
57290: LD_INT 2
57292: PUSH
57293: LD_INT 3
57295: PUSH
57296: LD_INT 4
57298: PUSH
57299: LD_INT 11
57301: PUSH
57302: EMPTY
57303: LIST
57304: LIST
57305: LIST
57306: LIST
57307: LIST
57308: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
57309: LD_ADDR_EXP 126
57313: PUSH
57314: LD_EXP 126
57318: PPUSH
57319: LD_VAR 0 1
57323: PPUSH
57324: LD_EXP 126
57328: PUSH
57329: LD_VAR 0 1
57333: ARRAY
57334: PUSH
57335: LD_VAR 0 3
57339: DIFF
57340: PPUSH
57341: CALL_OW 1
57345: ST_TO_ADDR
// end ;
57346: LD_VAR 0 2
57350: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
57351: LD_INT 0
57353: PPUSH
// result := mc_vehicles [ base ] ;
57354: LD_ADDR_VAR 0 3
57358: PUSH
57359: LD_EXP 118
57363: PUSH
57364: LD_VAR 0 1
57368: ARRAY
57369: ST_TO_ADDR
// if onlyCombat then
57370: LD_VAR 0 2
57374: IFFALSE 57539
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
57376: LD_ADDR_VAR 0 3
57380: PUSH
57381: LD_VAR 0 3
57385: PUSH
57386: LD_VAR 0 3
57390: PPUSH
57391: LD_INT 2
57393: PUSH
57394: LD_INT 34
57396: PUSH
57397: LD_INT 12
57399: PUSH
57400: EMPTY
57401: LIST
57402: LIST
57403: PUSH
57404: LD_INT 34
57406: PUSH
57407: LD_INT 51
57409: PUSH
57410: EMPTY
57411: LIST
57412: LIST
57413: PUSH
57414: LD_INT 34
57416: PUSH
57417: LD_EXP 93
57421: PUSH
57422: EMPTY
57423: LIST
57424: LIST
57425: PUSH
57426: LD_INT 34
57428: PUSH
57429: LD_INT 32
57431: PUSH
57432: EMPTY
57433: LIST
57434: LIST
57435: PUSH
57436: LD_INT 34
57438: PUSH
57439: LD_INT 13
57441: PUSH
57442: EMPTY
57443: LIST
57444: LIST
57445: PUSH
57446: LD_INT 34
57448: PUSH
57449: LD_INT 52
57451: PUSH
57452: EMPTY
57453: LIST
57454: LIST
57455: PUSH
57456: LD_INT 34
57458: PUSH
57459: LD_INT 14
57461: PUSH
57462: EMPTY
57463: LIST
57464: LIST
57465: PUSH
57466: LD_INT 34
57468: PUSH
57469: LD_INT 53
57471: PUSH
57472: EMPTY
57473: LIST
57474: LIST
57475: PUSH
57476: LD_INT 34
57478: PUSH
57479: LD_EXP 92
57483: PUSH
57484: EMPTY
57485: LIST
57486: LIST
57487: PUSH
57488: LD_INT 34
57490: PUSH
57491: LD_INT 31
57493: PUSH
57494: EMPTY
57495: LIST
57496: LIST
57497: PUSH
57498: LD_INT 34
57500: PUSH
57501: LD_INT 48
57503: PUSH
57504: EMPTY
57505: LIST
57506: LIST
57507: PUSH
57508: LD_INT 34
57510: PUSH
57511: LD_INT 8
57513: PUSH
57514: EMPTY
57515: LIST
57516: LIST
57517: PUSH
57518: EMPTY
57519: LIST
57520: LIST
57521: LIST
57522: LIST
57523: LIST
57524: LIST
57525: LIST
57526: LIST
57527: LIST
57528: LIST
57529: LIST
57530: LIST
57531: LIST
57532: PPUSH
57533: CALL_OW 72
57537: DIFF
57538: ST_TO_ADDR
// end ; end_of_file
57539: LD_VAR 0 3
57543: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
57544: LD_INT 0
57546: PPUSH
57547: PPUSH
57548: PPUSH
// if not mc_bases or not skirmish then
57549: LD_EXP 99
57553: NOT
57554: PUSH
57555: LD_EXP 97
57559: NOT
57560: OR
57561: IFFALSE 57565
// exit ;
57563: GO 57730
// for i = 1 to mc_bases do
57565: LD_ADDR_VAR 0 4
57569: PUSH
57570: DOUBLE
57571: LD_INT 1
57573: DEC
57574: ST_TO_ADDR
57575: LD_EXP 99
57579: PUSH
57580: FOR_TO
57581: IFFALSE 57728
// begin if sci in mc_bases [ i ] then
57583: LD_VAR 0 2
57587: PUSH
57588: LD_EXP 99
57592: PUSH
57593: LD_VAR 0 4
57597: ARRAY
57598: IN
57599: IFFALSE 57726
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
57601: LD_ADDR_EXP 128
57605: PUSH
57606: LD_EXP 128
57610: PPUSH
57611: LD_VAR 0 4
57615: PUSH
57616: LD_EXP 128
57620: PUSH
57621: LD_VAR 0 4
57625: ARRAY
57626: PUSH
57627: LD_INT 1
57629: PLUS
57630: PUSH
57631: EMPTY
57632: LIST
57633: LIST
57634: PPUSH
57635: LD_VAR 0 1
57639: PPUSH
57640: CALL 68683 0 3
57644: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
57645: LD_ADDR_VAR 0 5
57649: PUSH
57650: LD_EXP 99
57654: PUSH
57655: LD_VAR 0 4
57659: ARRAY
57660: PPUSH
57661: LD_INT 2
57663: PUSH
57664: LD_INT 30
57666: PUSH
57667: LD_INT 0
57669: PUSH
57670: EMPTY
57671: LIST
57672: LIST
57673: PUSH
57674: LD_INT 30
57676: PUSH
57677: LD_INT 1
57679: PUSH
57680: EMPTY
57681: LIST
57682: LIST
57683: PUSH
57684: EMPTY
57685: LIST
57686: LIST
57687: LIST
57688: PPUSH
57689: CALL_OW 72
57693: PPUSH
57694: LD_VAR 0 1
57698: PPUSH
57699: CALL_OW 74
57703: ST_TO_ADDR
// if tmp then
57704: LD_VAR 0 5
57708: IFFALSE 57724
// ComStandNearbyBuilding ( ape , tmp ) ;
57710: LD_VAR 0 1
57714: PPUSH
57715: LD_VAR 0 5
57719: PPUSH
57720: CALL 63360 0 2
// break ;
57724: GO 57728
// end ; end ;
57726: GO 57580
57728: POP
57729: POP
// end ;
57730: LD_VAR 0 3
57734: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
57735: LD_INT 0
57737: PPUSH
57738: PPUSH
57739: PPUSH
// if not mc_bases or not skirmish then
57740: LD_EXP 99
57744: NOT
57745: PUSH
57746: LD_EXP 97
57750: NOT
57751: OR
57752: IFFALSE 57756
// exit ;
57754: GO 57845
// for i = 1 to mc_bases do
57756: LD_ADDR_VAR 0 4
57760: PUSH
57761: DOUBLE
57762: LD_INT 1
57764: DEC
57765: ST_TO_ADDR
57766: LD_EXP 99
57770: PUSH
57771: FOR_TO
57772: IFFALSE 57843
// begin if building in mc_busy_turret_list [ i ] then
57774: LD_VAR 0 1
57778: PUSH
57779: LD_EXP 109
57783: PUSH
57784: LD_VAR 0 4
57788: ARRAY
57789: IN
57790: IFFALSE 57841
// begin tmp := mc_busy_turret_list [ i ] diff building ;
57792: LD_ADDR_VAR 0 5
57796: PUSH
57797: LD_EXP 109
57801: PUSH
57802: LD_VAR 0 4
57806: ARRAY
57807: PUSH
57808: LD_VAR 0 1
57812: DIFF
57813: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
57814: LD_ADDR_EXP 109
57818: PUSH
57819: LD_EXP 109
57823: PPUSH
57824: LD_VAR 0 4
57828: PPUSH
57829: LD_VAR 0 5
57833: PPUSH
57834: CALL_OW 1
57838: ST_TO_ADDR
// break ;
57839: GO 57843
// end ; end ;
57841: GO 57771
57843: POP
57844: POP
// end ;
57845: LD_VAR 0 3
57849: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
57850: LD_INT 0
57852: PPUSH
57853: PPUSH
57854: PPUSH
// if not mc_bases or not skirmish then
57855: LD_EXP 99
57859: NOT
57860: PUSH
57861: LD_EXP 97
57865: NOT
57866: OR
57867: IFFALSE 57871
// exit ;
57869: GO 58070
// for i = 1 to mc_bases do
57871: LD_ADDR_VAR 0 5
57875: PUSH
57876: DOUBLE
57877: LD_INT 1
57879: DEC
57880: ST_TO_ADDR
57881: LD_EXP 99
57885: PUSH
57886: FOR_TO
57887: IFFALSE 58068
// if building in mc_bases [ i ] then
57889: LD_VAR 0 1
57893: PUSH
57894: LD_EXP 99
57898: PUSH
57899: LD_VAR 0 5
57903: ARRAY
57904: IN
57905: IFFALSE 58066
// begin tmp := mc_bases [ i ] diff building ;
57907: LD_ADDR_VAR 0 6
57911: PUSH
57912: LD_EXP 99
57916: PUSH
57917: LD_VAR 0 5
57921: ARRAY
57922: PUSH
57923: LD_VAR 0 1
57927: DIFF
57928: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
57929: LD_ADDR_EXP 99
57933: PUSH
57934: LD_EXP 99
57938: PPUSH
57939: LD_VAR 0 5
57943: PPUSH
57944: LD_VAR 0 6
57948: PPUSH
57949: CALL_OW 1
57953: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
57954: LD_VAR 0 1
57958: PUSH
57959: LD_EXP 107
57963: PUSH
57964: LD_VAR 0 5
57968: ARRAY
57969: IN
57970: IFFALSE 58009
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
57972: LD_ADDR_EXP 107
57976: PUSH
57977: LD_EXP 107
57981: PPUSH
57982: LD_VAR 0 5
57986: PPUSH
57987: LD_EXP 107
57991: PUSH
57992: LD_VAR 0 5
57996: ARRAY
57997: PUSH
57998: LD_VAR 0 1
58002: DIFF
58003: PPUSH
58004: CALL_OW 1
58008: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
58009: LD_VAR 0 1
58013: PUSH
58014: LD_EXP 108
58018: PUSH
58019: LD_VAR 0 5
58023: ARRAY
58024: IN
58025: IFFALSE 58064
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
58027: LD_ADDR_EXP 108
58031: PUSH
58032: LD_EXP 108
58036: PPUSH
58037: LD_VAR 0 5
58041: PPUSH
58042: LD_EXP 108
58046: PUSH
58047: LD_VAR 0 5
58051: ARRAY
58052: PUSH
58053: LD_VAR 0 1
58057: DIFF
58058: PPUSH
58059: CALL_OW 1
58063: ST_TO_ADDR
// break ;
58064: GO 58068
// end ;
58066: GO 57886
58068: POP
58069: POP
// end ;
58070: LD_VAR 0 4
58074: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
58075: LD_INT 0
58077: PPUSH
58078: PPUSH
58079: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
58080: LD_EXP 99
58084: NOT
58085: PUSH
58086: LD_EXP 97
58090: NOT
58091: OR
58092: PUSH
58093: LD_VAR 0 3
58097: PUSH
58098: LD_EXP 125
58102: IN
58103: NOT
58104: OR
58105: IFFALSE 58109
// exit ;
58107: GO 58232
// for i = 1 to mc_vehicles do
58109: LD_ADDR_VAR 0 6
58113: PUSH
58114: DOUBLE
58115: LD_INT 1
58117: DEC
58118: ST_TO_ADDR
58119: LD_EXP 118
58123: PUSH
58124: FOR_TO
58125: IFFALSE 58230
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
58127: LD_VAR 0 2
58131: PUSH
58132: LD_EXP 118
58136: PUSH
58137: LD_VAR 0 6
58141: ARRAY
58142: IN
58143: PUSH
58144: LD_VAR 0 1
58148: PUSH
58149: LD_EXP 118
58153: PUSH
58154: LD_VAR 0 6
58158: ARRAY
58159: IN
58160: OR
58161: IFFALSE 58228
// begin tmp := mc_vehicles [ i ] diff old ;
58163: LD_ADDR_VAR 0 7
58167: PUSH
58168: LD_EXP 118
58172: PUSH
58173: LD_VAR 0 6
58177: ARRAY
58178: PUSH
58179: LD_VAR 0 2
58183: DIFF
58184: ST_TO_ADDR
// tmp := tmp diff new ;
58185: LD_ADDR_VAR 0 7
58189: PUSH
58190: LD_VAR 0 7
58194: PUSH
58195: LD_VAR 0 1
58199: DIFF
58200: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
58201: LD_ADDR_EXP 118
58205: PUSH
58206: LD_EXP 118
58210: PPUSH
58211: LD_VAR 0 6
58215: PPUSH
58216: LD_VAR 0 7
58220: PPUSH
58221: CALL_OW 1
58225: ST_TO_ADDR
// break ;
58226: GO 58230
// end ;
58228: GO 58124
58230: POP
58231: POP
// end ;
58232: LD_VAR 0 5
58236: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
58237: LD_INT 0
58239: PPUSH
58240: PPUSH
58241: PPUSH
58242: PPUSH
// if not mc_bases or not skirmish then
58243: LD_EXP 99
58247: NOT
58248: PUSH
58249: LD_EXP 97
58253: NOT
58254: OR
58255: IFFALSE 58259
// exit ;
58257: GO 58642
// side := GetSide ( vehicle ) ;
58259: LD_ADDR_VAR 0 5
58263: PUSH
58264: LD_VAR 0 1
58268: PPUSH
58269: CALL_OW 255
58273: ST_TO_ADDR
// for i = 1 to mc_bases do
58274: LD_ADDR_VAR 0 4
58278: PUSH
58279: DOUBLE
58280: LD_INT 1
58282: DEC
58283: ST_TO_ADDR
58284: LD_EXP 99
58288: PUSH
58289: FOR_TO
58290: IFFALSE 58640
// begin if factory in mc_bases [ i ] then
58292: LD_VAR 0 2
58296: PUSH
58297: LD_EXP 99
58301: PUSH
58302: LD_VAR 0 4
58306: ARRAY
58307: IN
58308: IFFALSE 58638
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
58310: LD_EXP 121
58314: PUSH
58315: LD_VAR 0 4
58319: ARRAY
58320: PUSH
58321: LD_EXP 110
58325: PUSH
58326: LD_VAR 0 4
58330: ARRAY
58331: LESS
58332: PUSH
58333: LD_VAR 0 1
58337: PPUSH
58338: CALL_OW 264
58342: PUSH
58343: LD_INT 31
58345: PUSH
58346: LD_INT 32
58348: PUSH
58349: LD_INT 51
58351: PUSH
58352: LD_EXP 93
58356: PUSH
58357: LD_INT 12
58359: PUSH
58360: LD_INT 30
58362: PUSH
58363: LD_EXP 92
58367: PUSH
58368: LD_INT 11
58370: PUSH
58371: LD_INT 53
58373: PUSH
58374: LD_INT 14
58376: PUSH
58377: LD_EXP 96
58381: PUSH
58382: LD_INT 29
58384: PUSH
58385: LD_EXP 94
58389: PUSH
58390: LD_INT 13
58392: PUSH
58393: LD_INT 52
58395: PUSH
58396: LD_INT 48
58398: PUSH
58399: LD_INT 8
58401: PUSH
58402: EMPTY
58403: LIST
58404: LIST
58405: LIST
58406: LIST
58407: LIST
58408: LIST
58409: LIST
58410: LIST
58411: LIST
58412: LIST
58413: LIST
58414: LIST
58415: LIST
58416: LIST
58417: LIST
58418: LIST
58419: LIST
58420: IN
58421: NOT
58422: AND
58423: IFFALSE 58464
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
58425: LD_ADDR_EXP 121
58429: PUSH
58430: LD_EXP 121
58434: PPUSH
58435: LD_VAR 0 4
58439: PPUSH
58440: LD_EXP 121
58444: PUSH
58445: LD_VAR 0 4
58449: ARRAY
58450: PUSH
58451: LD_VAR 0 1
58455: ADD
58456: PPUSH
58457: CALL_OW 1
58461: ST_TO_ADDR
58462: GO 58508
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
58464: LD_ADDR_EXP 118
58468: PUSH
58469: LD_EXP 118
58473: PPUSH
58474: LD_VAR 0 4
58478: PUSH
58479: LD_EXP 118
58483: PUSH
58484: LD_VAR 0 4
58488: ARRAY
58489: PUSH
58490: LD_INT 1
58492: PLUS
58493: PUSH
58494: EMPTY
58495: LIST
58496: LIST
58497: PPUSH
58498: LD_VAR 0 1
58502: PPUSH
58503: CALL 68683 0 3
58507: ST_TO_ADDR
// if not mc_scan [ i ] then
58508: LD_EXP 122
58512: PUSH
58513: LD_VAR 0 4
58517: ARRAY
58518: NOT
58519: IFFALSE 58638
// begin if GetControl ( vehicle ) = control_remote then
58521: LD_VAR 0 1
58525: PPUSH
58526: CALL_OW 263
58530: PUSH
58531: LD_INT 2
58533: EQUAL
58534: IFFALSE 58554
// repeat wait ( 0 0$1 ) ;
58536: LD_INT 35
58538: PPUSH
58539: CALL_OW 67
// until IsControledBy ( vehicle ) ;
58543: LD_VAR 0 1
58547: PPUSH
58548: CALL_OW 312
58552: IFFALSE 58536
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
58554: LD_VAR 0 1
58558: PPUSH
58559: LD_EXP 123
58563: PUSH
58564: LD_VAR 0 4
58568: ARRAY
58569: PPUSH
58570: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
58574: LD_VAR 0 1
58578: PPUSH
58579: CALL_OW 263
58583: PUSH
58584: LD_INT 1
58586: NONEQUAL
58587: IFFALSE 58591
// break ;
58589: GO 58640
// repeat wait ( 0 0$1 ) ;
58591: LD_INT 35
58593: PPUSH
58594: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
58598: LD_VAR 0 1
58602: PPUSH
58603: LD_EXP 123
58607: PUSH
58608: LD_VAR 0 4
58612: ARRAY
58613: PPUSH
58614: CALL_OW 308
58618: IFFALSE 58591
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
58620: LD_VAR 0 1
58624: PPUSH
58625: CALL_OW 311
58629: PPUSH
58630: CALL_OW 121
// exit ;
58634: POP
58635: POP
58636: GO 58642
// end ; end ; end ;
58638: GO 58289
58640: POP
58641: POP
// end ;
58642: LD_VAR 0 3
58646: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
58647: LD_INT 0
58649: PPUSH
58650: PPUSH
58651: PPUSH
58652: PPUSH
// if not mc_bases or not skirmish then
58653: LD_EXP 99
58657: NOT
58658: PUSH
58659: LD_EXP 97
58663: NOT
58664: OR
58665: IFFALSE 58669
// exit ;
58667: GO 59022
// repeat wait ( 0 0$1 ) ;
58669: LD_INT 35
58671: PPUSH
58672: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
58676: LD_VAR 0 2
58680: PPUSH
58681: LD_VAR 0 3
58685: PPUSH
58686: CALL_OW 284
58690: IFFALSE 58669
// if GetResourceTypeXY ( x , y ) = mat_artefact then
58692: LD_VAR 0 2
58696: PPUSH
58697: LD_VAR 0 3
58701: PPUSH
58702: CALL_OW 283
58706: PUSH
58707: LD_INT 4
58709: EQUAL
58710: IFFALSE 58714
// exit ;
58712: GO 59022
// for i = 1 to mc_bases do
58714: LD_ADDR_VAR 0 7
58718: PUSH
58719: DOUBLE
58720: LD_INT 1
58722: DEC
58723: ST_TO_ADDR
58724: LD_EXP 99
58728: PUSH
58729: FOR_TO
58730: IFFALSE 59020
// begin if mc_crates_area [ i ] then
58732: LD_EXP 117
58736: PUSH
58737: LD_VAR 0 7
58741: ARRAY
58742: IFFALSE 58853
// for j in mc_crates_area [ i ] do
58744: LD_ADDR_VAR 0 8
58748: PUSH
58749: LD_EXP 117
58753: PUSH
58754: LD_VAR 0 7
58758: ARRAY
58759: PUSH
58760: FOR_IN
58761: IFFALSE 58851
// if InArea ( x , y , j ) then
58763: LD_VAR 0 2
58767: PPUSH
58768: LD_VAR 0 3
58772: PPUSH
58773: LD_VAR 0 8
58777: PPUSH
58778: CALL_OW 309
58782: IFFALSE 58849
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
58784: LD_ADDR_EXP 115
58788: PUSH
58789: LD_EXP 115
58793: PPUSH
58794: LD_VAR 0 7
58798: PUSH
58799: LD_EXP 115
58803: PUSH
58804: LD_VAR 0 7
58808: ARRAY
58809: PUSH
58810: LD_INT 1
58812: PLUS
58813: PUSH
58814: EMPTY
58815: LIST
58816: LIST
58817: PPUSH
58818: LD_VAR 0 4
58822: PUSH
58823: LD_VAR 0 2
58827: PUSH
58828: LD_VAR 0 3
58832: PUSH
58833: EMPTY
58834: LIST
58835: LIST
58836: LIST
58837: PPUSH
58838: CALL 68683 0 3
58842: ST_TO_ADDR
// exit ;
58843: POP
58844: POP
58845: POP
58846: POP
58847: GO 59022
// end ;
58849: GO 58760
58851: POP
58852: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58853: LD_ADDR_VAR 0 9
58857: PUSH
58858: LD_EXP 99
58862: PUSH
58863: LD_VAR 0 7
58867: ARRAY
58868: PPUSH
58869: LD_INT 2
58871: PUSH
58872: LD_INT 30
58874: PUSH
58875: LD_INT 0
58877: PUSH
58878: EMPTY
58879: LIST
58880: LIST
58881: PUSH
58882: LD_INT 30
58884: PUSH
58885: LD_INT 1
58887: PUSH
58888: EMPTY
58889: LIST
58890: LIST
58891: PUSH
58892: EMPTY
58893: LIST
58894: LIST
58895: LIST
58896: PPUSH
58897: CALL_OW 72
58901: ST_TO_ADDR
// if not depot then
58902: LD_VAR 0 9
58906: NOT
58907: IFFALSE 58911
// continue ;
58909: GO 58729
// for j in depot do
58911: LD_ADDR_VAR 0 8
58915: PUSH
58916: LD_VAR 0 9
58920: PUSH
58921: FOR_IN
58922: IFFALSE 59016
// if GetDistUnitXY ( j , x , y ) < 30 then
58924: LD_VAR 0 8
58928: PPUSH
58929: LD_VAR 0 2
58933: PPUSH
58934: LD_VAR 0 3
58938: PPUSH
58939: CALL_OW 297
58943: PUSH
58944: LD_INT 30
58946: LESS
58947: IFFALSE 59014
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
58949: LD_ADDR_EXP 115
58953: PUSH
58954: LD_EXP 115
58958: PPUSH
58959: LD_VAR 0 7
58963: PUSH
58964: LD_EXP 115
58968: PUSH
58969: LD_VAR 0 7
58973: ARRAY
58974: PUSH
58975: LD_INT 1
58977: PLUS
58978: PUSH
58979: EMPTY
58980: LIST
58981: LIST
58982: PPUSH
58983: LD_VAR 0 4
58987: PUSH
58988: LD_VAR 0 2
58992: PUSH
58993: LD_VAR 0 3
58997: PUSH
58998: EMPTY
58999: LIST
59000: LIST
59001: LIST
59002: PPUSH
59003: CALL 68683 0 3
59007: ST_TO_ADDR
// exit ;
59008: POP
59009: POP
59010: POP
59011: POP
59012: GO 59022
// end ;
59014: GO 58921
59016: POP
59017: POP
// end ;
59018: GO 58729
59020: POP
59021: POP
// end ;
59022: LD_VAR 0 6
59026: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
59027: LD_INT 0
59029: PPUSH
59030: PPUSH
59031: PPUSH
59032: PPUSH
// if not mc_bases or not skirmish then
59033: LD_EXP 99
59037: NOT
59038: PUSH
59039: LD_EXP 97
59043: NOT
59044: OR
59045: IFFALSE 59049
// exit ;
59047: GO 59326
// side := GetSide ( lab ) ;
59049: LD_ADDR_VAR 0 4
59053: PUSH
59054: LD_VAR 0 2
59058: PPUSH
59059: CALL_OW 255
59063: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
59064: LD_VAR 0 4
59068: PUSH
59069: LD_EXP 125
59073: IN
59074: NOT
59075: PUSH
59076: LD_EXP 126
59080: NOT
59081: OR
59082: PUSH
59083: LD_EXP 99
59087: NOT
59088: OR
59089: IFFALSE 59093
// exit ;
59091: GO 59326
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
59093: LD_ADDR_EXP 126
59097: PUSH
59098: LD_EXP 126
59102: PPUSH
59103: LD_VAR 0 4
59107: PPUSH
59108: LD_EXP 126
59112: PUSH
59113: LD_VAR 0 4
59117: ARRAY
59118: PUSH
59119: LD_VAR 0 1
59123: DIFF
59124: PPUSH
59125: CALL_OW 1
59129: ST_TO_ADDR
// for i = 1 to mc_bases do
59130: LD_ADDR_VAR 0 5
59134: PUSH
59135: DOUBLE
59136: LD_INT 1
59138: DEC
59139: ST_TO_ADDR
59140: LD_EXP 99
59144: PUSH
59145: FOR_TO
59146: IFFALSE 59324
// begin if lab in mc_bases [ i ] then
59148: LD_VAR 0 2
59152: PUSH
59153: LD_EXP 99
59157: PUSH
59158: LD_VAR 0 5
59162: ARRAY
59163: IN
59164: IFFALSE 59322
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
59166: LD_VAR 0 1
59170: PUSH
59171: LD_INT 11
59173: PUSH
59174: LD_INT 4
59176: PUSH
59177: LD_INT 3
59179: PUSH
59180: LD_INT 2
59182: PUSH
59183: EMPTY
59184: LIST
59185: LIST
59186: LIST
59187: LIST
59188: IN
59189: PUSH
59190: LD_EXP 129
59194: PUSH
59195: LD_VAR 0 5
59199: ARRAY
59200: AND
59201: IFFALSE 59322
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
59203: LD_ADDR_VAR 0 6
59207: PUSH
59208: LD_EXP 129
59212: PUSH
59213: LD_VAR 0 5
59217: ARRAY
59218: PUSH
59219: LD_INT 1
59221: ARRAY
59222: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
59223: LD_ADDR_EXP 129
59227: PUSH
59228: LD_EXP 129
59232: PPUSH
59233: LD_VAR 0 5
59237: PPUSH
59238: EMPTY
59239: PPUSH
59240: CALL_OW 1
59244: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
59245: LD_VAR 0 6
59249: PPUSH
59250: LD_INT 0
59252: PPUSH
59253: CALL_OW 109
// ComExitBuilding ( tmp ) ;
59257: LD_VAR 0 6
59261: PPUSH
59262: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
59266: LD_ADDR_EXP 128
59270: PUSH
59271: LD_EXP 128
59275: PPUSH
59276: LD_VAR 0 5
59280: PPUSH
59281: LD_EXP 128
59285: PUSH
59286: LD_VAR 0 5
59290: ARRAY
59291: PPUSH
59292: LD_INT 1
59294: PPUSH
59295: LD_VAR 0 6
59299: PPUSH
59300: CALL_OW 2
59304: PPUSH
59305: CALL_OW 1
59309: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
59310: LD_VAR 0 5
59314: PPUSH
59315: LD_INT 112
59317: PPUSH
59318: CALL 36795 0 2
// end ; end ; end ;
59322: GO 59145
59324: POP
59325: POP
// end ;
59326: LD_VAR 0 3
59330: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
59331: LD_INT 0
59333: PPUSH
59334: PPUSH
59335: PPUSH
59336: PPUSH
59337: PPUSH
59338: PPUSH
59339: PPUSH
59340: PPUSH
// if not mc_bases or not skirmish then
59341: LD_EXP 99
59345: NOT
59346: PUSH
59347: LD_EXP 97
59351: NOT
59352: OR
59353: IFFALSE 59357
// exit ;
59355: GO 60373
// for i = 1 to mc_bases do
59357: LD_ADDR_VAR 0 3
59361: PUSH
59362: DOUBLE
59363: LD_INT 1
59365: DEC
59366: ST_TO_ADDR
59367: LD_EXP 99
59371: PUSH
59372: FOR_TO
59373: IFFALSE 60371
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
59375: LD_VAR 0 1
59379: PUSH
59380: LD_EXP 99
59384: PUSH
59385: LD_VAR 0 3
59389: ARRAY
59390: IN
59391: PUSH
59392: LD_VAR 0 1
59396: PUSH
59397: LD_EXP 106
59401: PUSH
59402: LD_VAR 0 3
59406: ARRAY
59407: IN
59408: OR
59409: PUSH
59410: LD_VAR 0 1
59414: PUSH
59415: LD_EXP 118
59419: PUSH
59420: LD_VAR 0 3
59424: ARRAY
59425: IN
59426: OR
59427: PUSH
59428: LD_VAR 0 1
59432: PUSH
59433: LD_EXP 128
59437: PUSH
59438: LD_VAR 0 3
59442: ARRAY
59443: IN
59444: OR
59445: PUSH
59446: LD_VAR 0 1
59450: PUSH
59451: LD_EXP 129
59455: PUSH
59456: LD_VAR 0 3
59460: ARRAY
59461: IN
59462: OR
59463: IFFALSE 60369
// begin if un in mc_ape [ i ] then
59465: LD_VAR 0 1
59469: PUSH
59470: LD_EXP 128
59474: PUSH
59475: LD_VAR 0 3
59479: ARRAY
59480: IN
59481: IFFALSE 59520
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
59483: LD_ADDR_EXP 128
59487: PUSH
59488: LD_EXP 128
59492: PPUSH
59493: LD_VAR 0 3
59497: PPUSH
59498: LD_EXP 128
59502: PUSH
59503: LD_VAR 0 3
59507: ARRAY
59508: PUSH
59509: LD_VAR 0 1
59513: DIFF
59514: PPUSH
59515: CALL_OW 1
59519: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
59520: LD_VAR 0 1
59524: PUSH
59525: LD_EXP 129
59529: PUSH
59530: LD_VAR 0 3
59534: ARRAY
59535: IN
59536: IFFALSE 59560
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
59538: LD_ADDR_EXP 129
59542: PUSH
59543: LD_EXP 129
59547: PPUSH
59548: LD_VAR 0 3
59552: PPUSH
59553: EMPTY
59554: PPUSH
59555: CALL_OW 1
59559: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] ) then
59560: LD_VAR 0 1
59564: PPUSH
59565: CALL_OW 247
59569: PUSH
59570: LD_INT 2
59572: EQUAL
59573: PUSH
59574: LD_VAR 0 1
59578: PPUSH
59579: CALL_OW 110
59583: PUSH
59584: LD_INT 20
59586: EQUAL
59587: PUSH
59588: LD_VAR 0 1
59592: PUSH
59593: LD_EXP 121
59597: PUSH
59598: LD_VAR 0 3
59602: ARRAY
59603: IN
59604: OR
59605: AND
59606: IFFALSE 59709
// begin fac := MC_GetBuilding ( i , b_factory ) ;
59608: LD_ADDR_VAR 0 8
59612: PUSH
59613: LD_VAR 0 3
59617: PPUSH
59618: LD_INT 3
59620: PPUSH
59621: CALL 56368 0 2
59625: ST_TO_ADDR
// if fac then
59626: LD_VAR 0 8
59630: IFFALSE 59709
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
59632: LD_ADDR_VAR 0 9
59636: PUSH
59637: LD_VAR 0 8
59641: PPUSH
59642: LD_VAR 0 1
59646: PPUSH
59647: CALL_OW 265
59651: PPUSH
59652: LD_VAR 0 1
59656: PPUSH
59657: CALL_OW 262
59661: PPUSH
59662: LD_VAR 0 1
59666: PPUSH
59667: CALL_OW 263
59671: PPUSH
59672: LD_VAR 0 1
59676: PPUSH
59677: CALL_OW 264
59681: PPUSH
59682: CALL 66283 0 5
59686: ST_TO_ADDR
// if components then
59687: LD_VAR 0 9
59691: IFFALSE 59707
// MC_InsertProduceList ( i , components ) ;
59693: LD_VAR 0 3
59697: PPUSH
59698: LD_VAR 0 9
59702: PPUSH
59703: CALL 55996 0 2
// break ;
59707: GO 60371
// end ; end ; if GetType ( un ) = unit_building then
59709: LD_VAR 0 1
59713: PPUSH
59714: CALL_OW 247
59718: PUSH
59719: LD_INT 3
59721: EQUAL
59722: IFFALSE 60037
// begin btype := GetBType ( un ) ;
59724: LD_ADDR_VAR 0 5
59728: PUSH
59729: LD_VAR 0 1
59733: PPUSH
59734: CALL_OW 266
59738: ST_TO_ADDR
// if btype = b_warehouse then
59739: LD_VAR 0 5
59743: PUSH
59744: LD_INT 1
59746: EQUAL
59747: IFFALSE 59765
// begin btype := b_depot ;
59749: LD_ADDR_VAR 0 5
59753: PUSH
59754: LD_INT 0
59756: ST_TO_ADDR
// pos := 1 ;
59757: LD_ADDR_VAR 0 6
59761: PUSH
59762: LD_INT 1
59764: ST_TO_ADDR
// end ; if btype = b_factory then
59765: LD_VAR 0 5
59769: PUSH
59770: LD_INT 3
59772: EQUAL
59773: IFFALSE 59791
// begin btype := b_workshop ;
59775: LD_ADDR_VAR 0 5
59779: PUSH
59780: LD_INT 2
59782: ST_TO_ADDR
// pos := 1 ;
59783: LD_ADDR_VAR 0 6
59787: PUSH
59788: LD_INT 1
59790: ST_TO_ADDR
// end ; if btype = b_barracks then
59791: LD_VAR 0 5
59795: PUSH
59796: LD_INT 5
59798: EQUAL
59799: IFFALSE 59809
// btype := b_armoury ;
59801: LD_ADDR_VAR 0 5
59805: PUSH
59806: LD_INT 4
59808: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
59809: LD_VAR 0 5
59813: PUSH
59814: LD_INT 7
59816: PUSH
59817: LD_INT 8
59819: PUSH
59820: EMPTY
59821: LIST
59822: LIST
59823: IN
59824: IFFALSE 59834
// btype := b_lab ;
59826: LD_ADDR_VAR 0 5
59830: PUSH
59831: LD_INT 6
59833: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
59834: LD_ADDR_EXP 104
59838: PUSH
59839: LD_EXP 104
59843: PPUSH
59844: LD_VAR 0 3
59848: PUSH
59849: LD_EXP 104
59853: PUSH
59854: LD_VAR 0 3
59858: ARRAY
59859: PUSH
59860: LD_INT 1
59862: PLUS
59863: PUSH
59864: EMPTY
59865: LIST
59866: LIST
59867: PPUSH
59868: LD_VAR 0 5
59872: PUSH
59873: LD_VAR 0 1
59877: PPUSH
59878: CALL_OW 250
59882: PUSH
59883: LD_VAR 0 1
59887: PPUSH
59888: CALL_OW 251
59892: PUSH
59893: LD_VAR 0 1
59897: PPUSH
59898: CALL_OW 254
59902: PUSH
59903: EMPTY
59904: LIST
59905: LIST
59906: LIST
59907: LIST
59908: PPUSH
59909: CALL 68683 0 3
59913: ST_TO_ADDR
// if pos = 1 then
59914: LD_VAR 0 6
59918: PUSH
59919: LD_INT 1
59921: EQUAL
59922: IFFALSE 60037
// begin tmp := mc_build_list [ i ] ;
59924: LD_ADDR_VAR 0 7
59928: PUSH
59929: LD_EXP 104
59933: PUSH
59934: LD_VAR 0 3
59938: ARRAY
59939: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59940: LD_VAR 0 7
59944: PPUSH
59945: LD_INT 2
59947: PUSH
59948: LD_INT 30
59950: PUSH
59951: LD_INT 0
59953: PUSH
59954: EMPTY
59955: LIST
59956: LIST
59957: PUSH
59958: LD_INT 30
59960: PUSH
59961: LD_INT 1
59963: PUSH
59964: EMPTY
59965: LIST
59966: LIST
59967: PUSH
59968: EMPTY
59969: LIST
59970: LIST
59971: LIST
59972: PPUSH
59973: CALL_OW 72
59977: IFFALSE 59987
// pos := 2 ;
59979: LD_ADDR_VAR 0 6
59983: PUSH
59984: LD_INT 2
59986: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
59987: LD_ADDR_VAR 0 7
59991: PUSH
59992: LD_VAR 0 7
59996: PPUSH
59997: LD_VAR 0 6
60001: PPUSH
60002: LD_VAR 0 7
60006: PPUSH
60007: CALL 69009 0 3
60011: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
60012: LD_ADDR_EXP 104
60016: PUSH
60017: LD_EXP 104
60021: PPUSH
60022: LD_VAR 0 3
60026: PPUSH
60027: LD_VAR 0 7
60031: PPUSH
60032: CALL_OW 1
60036: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
60037: LD_VAR 0 1
60041: PUSH
60042: LD_EXP 99
60046: PUSH
60047: LD_VAR 0 3
60051: ARRAY
60052: IN
60053: IFFALSE 60092
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
60055: LD_ADDR_EXP 99
60059: PUSH
60060: LD_EXP 99
60064: PPUSH
60065: LD_VAR 0 3
60069: PPUSH
60070: LD_EXP 99
60074: PUSH
60075: LD_VAR 0 3
60079: ARRAY
60080: PUSH
60081: LD_VAR 0 1
60085: DIFF
60086: PPUSH
60087: CALL_OW 1
60091: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
60092: LD_VAR 0 1
60096: PUSH
60097: LD_EXP 106
60101: PUSH
60102: LD_VAR 0 3
60106: ARRAY
60107: IN
60108: IFFALSE 60147
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
60110: LD_ADDR_EXP 106
60114: PUSH
60115: LD_EXP 106
60119: PPUSH
60120: LD_VAR 0 3
60124: PPUSH
60125: LD_EXP 106
60129: PUSH
60130: LD_VAR 0 3
60134: ARRAY
60135: PUSH
60136: LD_VAR 0 1
60140: DIFF
60141: PPUSH
60142: CALL_OW 1
60146: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
60147: LD_VAR 0 1
60151: PUSH
60152: LD_EXP 118
60156: PUSH
60157: LD_VAR 0 3
60161: ARRAY
60162: IN
60163: IFFALSE 60202
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
60165: LD_ADDR_EXP 118
60169: PUSH
60170: LD_EXP 118
60174: PPUSH
60175: LD_VAR 0 3
60179: PPUSH
60180: LD_EXP 118
60184: PUSH
60185: LD_VAR 0 3
60189: ARRAY
60190: PUSH
60191: LD_VAR 0 1
60195: DIFF
60196: PPUSH
60197: CALL_OW 1
60201: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
60202: LD_VAR 0 1
60206: PUSH
60207: LD_EXP 121
60211: PUSH
60212: LD_VAR 0 3
60216: ARRAY
60217: IN
60218: IFFALSE 60257
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
60220: LD_ADDR_EXP 121
60224: PUSH
60225: LD_EXP 121
60229: PPUSH
60230: LD_VAR 0 3
60234: PPUSH
60235: LD_EXP 121
60239: PUSH
60240: LD_VAR 0 3
60244: ARRAY
60245: PUSH
60246: LD_VAR 0 1
60250: DIFF
60251: PPUSH
60252: CALL_OW 1
60256: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
60257: LD_VAR 0 1
60261: PUSH
60262: LD_EXP 108
60266: PUSH
60267: LD_VAR 0 3
60271: ARRAY
60272: IN
60273: IFFALSE 60312
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
60275: LD_ADDR_EXP 108
60279: PUSH
60280: LD_EXP 108
60284: PPUSH
60285: LD_VAR 0 3
60289: PPUSH
60290: LD_EXP 108
60294: PUSH
60295: LD_VAR 0 3
60299: ARRAY
60300: PUSH
60301: LD_VAR 0 1
60305: DIFF
60306: PPUSH
60307: CALL_OW 1
60311: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
60312: LD_VAR 0 1
60316: PUSH
60317: LD_EXP 107
60321: PUSH
60322: LD_VAR 0 3
60326: ARRAY
60327: IN
60328: IFFALSE 60367
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
60330: LD_ADDR_EXP 107
60334: PUSH
60335: LD_EXP 107
60339: PPUSH
60340: LD_VAR 0 3
60344: PPUSH
60345: LD_EXP 107
60349: PUSH
60350: LD_VAR 0 3
60354: ARRAY
60355: PUSH
60356: LD_VAR 0 1
60360: DIFF
60361: PPUSH
60362: CALL_OW 1
60366: ST_TO_ADDR
// end ; break ;
60367: GO 60371
// end ;
60369: GO 59372
60371: POP
60372: POP
// end ;
60373: LD_VAR 0 2
60377: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
60378: LD_INT 0
60380: PPUSH
60381: PPUSH
60382: PPUSH
// if not mc_bases or not skirmish then
60383: LD_EXP 99
60387: NOT
60388: PUSH
60389: LD_EXP 97
60393: NOT
60394: OR
60395: IFFALSE 60399
// exit ;
60397: GO 60614
// for i = 1 to mc_bases do
60399: LD_ADDR_VAR 0 3
60403: PUSH
60404: DOUBLE
60405: LD_INT 1
60407: DEC
60408: ST_TO_ADDR
60409: LD_EXP 99
60413: PUSH
60414: FOR_TO
60415: IFFALSE 60612
// begin if building in mc_construct_list [ i ] then
60417: LD_VAR 0 1
60421: PUSH
60422: LD_EXP 106
60426: PUSH
60427: LD_VAR 0 3
60431: ARRAY
60432: IN
60433: IFFALSE 60610
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
60435: LD_ADDR_EXP 106
60439: PUSH
60440: LD_EXP 106
60444: PPUSH
60445: LD_VAR 0 3
60449: PPUSH
60450: LD_EXP 106
60454: PUSH
60455: LD_VAR 0 3
60459: ARRAY
60460: PUSH
60461: LD_VAR 0 1
60465: DIFF
60466: PPUSH
60467: CALL_OW 1
60471: ST_TO_ADDR
// if building in mc_lab [ i ] then
60472: LD_VAR 0 1
60476: PUSH
60477: LD_EXP 132
60481: PUSH
60482: LD_VAR 0 3
60486: ARRAY
60487: IN
60488: IFFALSE 60543
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
60490: LD_ADDR_EXP 133
60494: PUSH
60495: LD_EXP 133
60499: PPUSH
60500: LD_VAR 0 3
60504: PPUSH
60505: LD_EXP 133
60509: PUSH
60510: LD_VAR 0 3
60514: ARRAY
60515: PPUSH
60516: LD_INT 1
60518: PPUSH
60519: LD_EXP 133
60523: PUSH
60524: LD_VAR 0 3
60528: ARRAY
60529: PPUSH
60530: LD_INT 0
60532: PPUSH
60533: CALL 68101 0 4
60537: PPUSH
60538: CALL_OW 1
60542: ST_TO_ADDR
// if not building in mc_bases [ i ] then
60543: LD_VAR 0 1
60547: PUSH
60548: LD_EXP 99
60552: PUSH
60553: LD_VAR 0 3
60557: ARRAY
60558: IN
60559: NOT
60560: IFFALSE 60606
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
60562: LD_ADDR_EXP 99
60566: PUSH
60567: LD_EXP 99
60571: PPUSH
60572: LD_VAR 0 3
60576: PUSH
60577: LD_EXP 99
60581: PUSH
60582: LD_VAR 0 3
60586: ARRAY
60587: PUSH
60588: LD_INT 1
60590: PLUS
60591: PUSH
60592: EMPTY
60593: LIST
60594: LIST
60595: PPUSH
60596: LD_VAR 0 1
60600: PPUSH
60601: CALL 68683 0 3
60605: ST_TO_ADDR
// exit ;
60606: POP
60607: POP
60608: GO 60614
// end ; end ;
60610: GO 60414
60612: POP
60613: POP
// end ;
60614: LD_VAR 0 2
60618: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
60619: LD_INT 0
60621: PPUSH
60622: PPUSH
60623: PPUSH
60624: PPUSH
60625: PPUSH
60626: PPUSH
60627: PPUSH
// if not mc_bases or not skirmish then
60628: LD_EXP 99
60632: NOT
60633: PUSH
60634: LD_EXP 97
60638: NOT
60639: OR
60640: IFFALSE 60644
// exit ;
60642: GO 61305
// for i = 1 to mc_bases do
60644: LD_ADDR_VAR 0 3
60648: PUSH
60649: DOUBLE
60650: LD_INT 1
60652: DEC
60653: ST_TO_ADDR
60654: LD_EXP 99
60658: PUSH
60659: FOR_TO
60660: IFFALSE 61303
// begin if building in mc_construct_list [ i ] then
60662: LD_VAR 0 1
60666: PUSH
60667: LD_EXP 106
60671: PUSH
60672: LD_VAR 0 3
60676: ARRAY
60677: IN
60678: IFFALSE 61301
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
60680: LD_ADDR_EXP 106
60684: PUSH
60685: LD_EXP 106
60689: PPUSH
60690: LD_VAR 0 3
60694: PPUSH
60695: LD_EXP 106
60699: PUSH
60700: LD_VAR 0 3
60704: ARRAY
60705: PUSH
60706: LD_VAR 0 1
60710: DIFF
60711: PPUSH
60712: CALL_OW 1
60716: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
60717: LD_ADDR_EXP 99
60721: PUSH
60722: LD_EXP 99
60726: PPUSH
60727: LD_VAR 0 3
60731: PUSH
60732: LD_EXP 99
60736: PUSH
60737: LD_VAR 0 3
60741: ARRAY
60742: PUSH
60743: LD_INT 1
60745: PLUS
60746: PUSH
60747: EMPTY
60748: LIST
60749: LIST
60750: PPUSH
60751: LD_VAR 0 1
60755: PPUSH
60756: CALL 68683 0 3
60760: ST_TO_ADDR
// btype := GetBType ( building ) ;
60761: LD_ADDR_VAR 0 5
60765: PUSH
60766: LD_VAR 0 1
60770: PPUSH
60771: CALL_OW 266
60775: ST_TO_ADDR
// side := GetSide ( building ) ;
60776: LD_ADDR_VAR 0 8
60780: PUSH
60781: LD_VAR 0 1
60785: PPUSH
60786: CALL_OW 255
60790: ST_TO_ADDR
// if btype = b_lab then
60791: LD_VAR 0 5
60795: PUSH
60796: LD_INT 6
60798: EQUAL
60799: IFFALSE 60849
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
60801: LD_ADDR_EXP 132
60805: PUSH
60806: LD_EXP 132
60810: PPUSH
60811: LD_VAR 0 3
60815: PUSH
60816: LD_EXP 132
60820: PUSH
60821: LD_VAR 0 3
60825: ARRAY
60826: PUSH
60827: LD_INT 1
60829: PLUS
60830: PUSH
60831: EMPTY
60832: LIST
60833: LIST
60834: PPUSH
60835: LD_VAR 0 1
60839: PPUSH
60840: CALL 68683 0 3
60844: ST_TO_ADDR
// exit ;
60845: POP
60846: POP
60847: GO 61305
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
60849: LD_VAR 0 5
60853: PUSH
60854: LD_INT 0
60856: PUSH
60857: LD_INT 2
60859: PUSH
60860: LD_INT 4
60862: PUSH
60863: EMPTY
60864: LIST
60865: LIST
60866: LIST
60867: IN
60868: IFFALSE 60992
// begin if btype = b_armoury then
60870: LD_VAR 0 5
60874: PUSH
60875: LD_INT 4
60877: EQUAL
60878: IFFALSE 60888
// btype := b_barracks ;
60880: LD_ADDR_VAR 0 5
60884: PUSH
60885: LD_INT 5
60887: ST_TO_ADDR
// if btype = b_depot then
60888: LD_VAR 0 5
60892: PUSH
60893: LD_INT 0
60895: EQUAL
60896: IFFALSE 60906
// btype := b_warehouse ;
60898: LD_ADDR_VAR 0 5
60902: PUSH
60903: LD_INT 1
60905: ST_TO_ADDR
// if btype = b_workshop then
60906: LD_VAR 0 5
60910: PUSH
60911: LD_INT 2
60913: EQUAL
60914: IFFALSE 60924
// btype := b_factory ;
60916: LD_ADDR_VAR 0 5
60920: PUSH
60921: LD_INT 3
60923: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
60924: LD_VAR 0 5
60928: PPUSH
60929: LD_VAR 0 8
60933: PPUSH
60934: CALL_OW 323
60938: PUSH
60939: LD_INT 1
60941: EQUAL
60942: IFFALSE 60988
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
60944: LD_ADDR_EXP 131
60948: PUSH
60949: LD_EXP 131
60953: PPUSH
60954: LD_VAR 0 3
60958: PUSH
60959: LD_EXP 131
60963: PUSH
60964: LD_VAR 0 3
60968: ARRAY
60969: PUSH
60970: LD_INT 1
60972: PLUS
60973: PUSH
60974: EMPTY
60975: LIST
60976: LIST
60977: PPUSH
60978: LD_VAR 0 1
60982: PPUSH
60983: CALL 68683 0 3
60987: ST_TO_ADDR
// exit ;
60988: POP
60989: POP
60990: GO 61305
// end ; if btype in [ b_bunker , b_turret ] then
60992: LD_VAR 0 5
60996: PUSH
60997: LD_INT 32
60999: PUSH
61000: LD_INT 33
61002: PUSH
61003: EMPTY
61004: LIST
61005: LIST
61006: IN
61007: IFFALSE 61297
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
61009: LD_ADDR_EXP 107
61013: PUSH
61014: LD_EXP 107
61018: PPUSH
61019: LD_VAR 0 3
61023: PUSH
61024: LD_EXP 107
61028: PUSH
61029: LD_VAR 0 3
61033: ARRAY
61034: PUSH
61035: LD_INT 1
61037: PLUS
61038: PUSH
61039: EMPTY
61040: LIST
61041: LIST
61042: PPUSH
61043: LD_VAR 0 1
61047: PPUSH
61048: CALL 68683 0 3
61052: ST_TO_ADDR
// if btype = b_bunker then
61053: LD_VAR 0 5
61057: PUSH
61058: LD_INT 32
61060: EQUAL
61061: IFFALSE 61297
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
61063: LD_ADDR_EXP 108
61067: PUSH
61068: LD_EXP 108
61072: PPUSH
61073: LD_VAR 0 3
61077: PUSH
61078: LD_EXP 108
61082: PUSH
61083: LD_VAR 0 3
61087: ARRAY
61088: PUSH
61089: LD_INT 1
61091: PLUS
61092: PUSH
61093: EMPTY
61094: LIST
61095: LIST
61096: PPUSH
61097: LD_VAR 0 1
61101: PPUSH
61102: CALL 68683 0 3
61106: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
61107: LD_ADDR_VAR 0 6
61111: PUSH
61112: LD_EXP 99
61116: PUSH
61117: LD_VAR 0 3
61121: ARRAY
61122: PPUSH
61123: LD_INT 25
61125: PUSH
61126: LD_INT 1
61128: PUSH
61129: EMPTY
61130: LIST
61131: LIST
61132: PUSH
61133: LD_INT 3
61135: PUSH
61136: LD_INT 54
61138: PUSH
61139: EMPTY
61140: LIST
61141: PUSH
61142: EMPTY
61143: LIST
61144: LIST
61145: PUSH
61146: EMPTY
61147: LIST
61148: LIST
61149: PPUSH
61150: CALL_OW 72
61154: ST_TO_ADDR
// if tmp then
61155: LD_VAR 0 6
61159: IFFALSE 61165
// exit ;
61161: POP
61162: POP
61163: GO 61305
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
61165: LD_ADDR_VAR 0 6
61169: PUSH
61170: LD_EXP 99
61174: PUSH
61175: LD_VAR 0 3
61179: ARRAY
61180: PPUSH
61181: LD_INT 2
61183: PUSH
61184: LD_INT 30
61186: PUSH
61187: LD_INT 4
61189: PUSH
61190: EMPTY
61191: LIST
61192: LIST
61193: PUSH
61194: LD_INT 30
61196: PUSH
61197: LD_INT 5
61199: PUSH
61200: EMPTY
61201: LIST
61202: LIST
61203: PUSH
61204: EMPTY
61205: LIST
61206: LIST
61207: LIST
61208: PPUSH
61209: CALL_OW 72
61213: ST_TO_ADDR
// if not tmp then
61214: LD_VAR 0 6
61218: NOT
61219: IFFALSE 61225
// exit ;
61221: POP
61222: POP
61223: GO 61305
// for j in tmp do
61225: LD_ADDR_VAR 0 4
61229: PUSH
61230: LD_VAR 0 6
61234: PUSH
61235: FOR_IN
61236: IFFALSE 61295
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
61238: LD_ADDR_VAR 0 7
61242: PUSH
61243: LD_VAR 0 4
61247: PPUSH
61248: CALL_OW 313
61252: PPUSH
61253: LD_INT 25
61255: PUSH
61256: LD_INT 1
61258: PUSH
61259: EMPTY
61260: LIST
61261: LIST
61262: PPUSH
61263: CALL_OW 72
61267: ST_TO_ADDR
// if units then
61268: LD_VAR 0 7
61272: IFFALSE 61293
// begin ComExitBuilding ( units [ 1 ] ) ;
61274: LD_VAR 0 7
61278: PUSH
61279: LD_INT 1
61281: ARRAY
61282: PPUSH
61283: CALL_OW 122
// exit ;
61287: POP
61288: POP
61289: POP
61290: POP
61291: GO 61305
// end ; end ;
61293: GO 61235
61295: POP
61296: POP
// end ; end ; exit ;
61297: POP
61298: POP
61299: GO 61305
// end ; end ;
61301: GO 60659
61303: POP
61304: POP
// end ;
61305: LD_VAR 0 2
61309: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
61310: LD_INT 0
61312: PPUSH
61313: PPUSH
61314: PPUSH
61315: PPUSH
61316: PPUSH
61317: PPUSH
61318: PPUSH
// if not mc_bases or not skirmish then
61319: LD_EXP 99
61323: NOT
61324: PUSH
61325: LD_EXP 97
61329: NOT
61330: OR
61331: IFFALSE 61335
// exit ;
61333: GO 61566
// btype := GetBType ( building ) ;
61335: LD_ADDR_VAR 0 6
61339: PUSH
61340: LD_VAR 0 1
61344: PPUSH
61345: CALL_OW 266
61349: ST_TO_ADDR
// x := GetX ( building ) ;
61350: LD_ADDR_VAR 0 7
61354: PUSH
61355: LD_VAR 0 1
61359: PPUSH
61360: CALL_OW 250
61364: ST_TO_ADDR
// y := GetY ( building ) ;
61365: LD_ADDR_VAR 0 8
61369: PUSH
61370: LD_VAR 0 1
61374: PPUSH
61375: CALL_OW 251
61379: ST_TO_ADDR
// d := GetDir ( building ) ;
61380: LD_ADDR_VAR 0 9
61384: PUSH
61385: LD_VAR 0 1
61389: PPUSH
61390: CALL_OW 254
61394: ST_TO_ADDR
// for i = 1 to mc_bases do
61395: LD_ADDR_VAR 0 4
61399: PUSH
61400: DOUBLE
61401: LD_INT 1
61403: DEC
61404: ST_TO_ADDR
61405: LD_EXP 99
61409: PUSH
61410: FOR_TO
61411: IFFALSE 61564
// begin if not mc_build_list [ i ] then
61413: LD_EXP 104
61417: PUSH
61418: LD_VAR 0 4
61422: ARRAY
61423: NOT
61424: IFFALSE 61428
// continue ;
61426: GO 61410
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
61428: LD_VAR 0 6
61432: PUSH
61433: LD_VAR 0 7
61437: PUSH
61438: LD_VAR 0 8
61442: PUSH
61443: LD_VAR 0 9
61447: PUSH
61448: EMPTY
61449: LIST
61450: LIST
61451: LIST
61452: LIST
61453: PPUSH
61454: LD_EXP 104
61458: PUSH
61459: LD_VAR 0 4
61463: ARRAY
61464: PUSH
61465: LD_INT 1
61467: ARRAY
61468: PPUSH
61469: CALL 74852 0 2
61473: IFFALSE 61562
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
61475: LD_ADDR_EXP 104
61479: PUSH
61480: LD_EXP 104
61484: PPUSH
61485: LD_VAR 0 4
61489: PPUSH
61490: LD_EXP 104
61494: PUSH
61495: LD_VAR 0 4
61499: ARRAY
61500: PPUSH
61501: LD_INT 1
61503: PPUSH
61504: CALL_OW 3
61508: PPUSH
61509: CALL_OW 1
61513: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
61514: LD_ADDR_EXP 106
61518: PUSH
61519: LD_EXP 106
61523: PPUSH
61524: LD_VAR 0 4
61528: PUSH
61529: LD_EXP 106
61533: PUSH
61534: LD_VAR 0 4
61538: ARRAY
61539: PUSH
61540: LD_INT 1
61542: PLUS
61543: PUSH
61544: EMPTY
61545: LIST
61546: LIST
61547: PPUSH
61548: LD_VAR 0 1
61552: PPUSH
61553: CALL 68683 0 3
61557: ST_TO_ADDR
// exit ;
61558: POP
61559: POP
61560: GO 61566
// end ; end ;
61562: GO 61410
61564: POP
61565: POP
// end ;
61566: LD_VAR 0 3
61570: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
61571: LD_INT 0
61573: PPUSH
61574: PPUSH
61575: PPUSH
// if not mc_bases or not skirmish then
61576: LD_EXP 99
61580: NOT
61581: PUSH
61582: LD_EXP 97
61586: NOT
61587: OR
61588: IFFALSE 61592
// exit ;
61590: GO 61782
// for i = 1 to mc_bases do
61592: LD_ADDR_VAR 0 4
61596: PUSH
61597: DOUBLE
61598: LD_INT 1
61600: DEC
61601: ST_TO_ADDR
61602: LD_EXP 99
61606: PUSH
61607: FOR_TO
61608: IFFALSE 61695
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
61610: LD_VAR 0 1
61614: PUSH
61615: LD_EXP 107
61619: PUSH
61620: LD_VAR 0 4
61624: ARRAY
61625: IN
61626: PUSH
61627: LD_VAR 0 1
61631: PUSH
61632: LD_EXP 108
61636: PUSH
61637: LD_VAR 0 4
61641: ARRAY
61642: IN
61643: NOT
61644: AND
61645: IFFALSE 61693
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
61647: LD_ADDR_EXP 108
61651: PUSH
61652: LD_EXP 108
61656: PPUSH
61657: LD_VAR 0 4
61661: PUSH
61662: LD_EXP 108
61666: PUSH
61667: LD_VAR 0 4
61671: ARRAY
61672: PUSH
61673: LD_INT 1
61675: PLUS
61676: PUSH
61677: EMPTY
61678: LIST
61679: LIST
61680: PPUSH
61681: LD_VAR 0 1
61685: PPUSH
61686: CALL 68683 0 3
61690: ST_TO_ADDR
// break ;
61691: GO 61695
// end ; end ;
61693: GO 61607
61695: POP
61696: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
61697: LD_VAR 0 1
61701: PPUSH
61702: CALL_OW 257
61706: PUSH
61707: LD_EXP 125
61711: IN
61712: PUSH
61713: LD_VAR 0 1
61717: PPUSH
61718: CALL_OW 266
61722: PUSH
61723: LD_INT 5
61725: EQUAL
61726: AND
61727: PUSH
61728: LD_VAR 0 2
61732: PPUSH
61733: CALL_OW 110
61737: PUSH
61738: LD_INT 18
61740: NONEQUAL
61741: AND
61742: IFFALSE 61782
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
61744: LD_VAR 0 2
61748: PPUSH
61749: CALL_OW 257
61753: PUSH
61754: LD_INT 5
61756: PUSH
61757: LD_INT 8
61759: PUSH
61760: LD_INT 9
61762: PUSH
61763: EMPTY
61764: LIST
61765: LIST
61766: LIST
61767: IN
61768: IFFALSE 61782
// SetClass ( unit , 1 ) ;
61770: LD_VAR 0 2
61774: PPUSH
61775: LD_INT 1
61777: PPUSH
61778: CALL_OW 336
// end ;
61782: LD_VAR 0 3
61786: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
61787: LD_INT 0
61789: PPUSH
61790: PPUSH
// if not mc_bases or not skirmish then
61791: LD_EXP 99
61795: NOT
61796: PUSH
61797: LD_EXP 97
61801: NOT
61802: OR
61803: IFFALSE 61807
// exit ;
61805: GO 61923
// if GetLives ( abandoned_vehicle ) > 250 then
61807: LD_VAR 0 2
61811: PPUSH
61812: CALL_OW 256
61816: PUSH
61817: LD_INT 250
61819: GREATER
61820: IFFALSE 61824
// exit ;
61822: GO 61923
// for i = 1 to mc_bases do
61824: LD_ADDR_VAR 0 6
61828: PUSH
61829: DOUBLE
61830: LD_INT 1
61832: DEC
61833: ST_TO_ADDR
61834: LD_EXP 99
61838: PUSH
61839: FOR_TO
61840: IFFALSE 61921
// begin if driver in mc_bases [ i ] then
61842: LD_VAR 0 1
61846: PUSH
61847: LD_EXP 99
61851: PUSH
61852: LD_VAR 0 6
61856: ARRAY
61857: IN
61858: IFFALSE 61919
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
61860: LD_VAR 0 1
61864: PPUSH
61865: LD_EXP 99
61869: PUSH
61870: LD_VAR 0 6
61874: ARRAY
61875: PPUSH
61876: LD_INT 2
61878: PUSH
61879: LD_INT 30
61881: PUSH
61882: LD_INT 0
61884: PUSH
61885: EMPTY
61886: LIST
61887: LIST
61888: PUSH
61889: LD_INT 30
61891: PUSH
61892: LD_INT 1
61894: PUSH
61895: EMPTY
61896: LIST
61897: LIST
61898: PUSH
61899: EMPTY
61900: LIST
61901: LIST
61902: LIST
61903: PPUSH
61904: CALL_OW 72
61908: PUSH
61909: LD_INT 1
61911: ARRAY
61912: PPUSH
61913: CALL_OW 112
// break ;
61917: GO 61921
// end ; end ;
61919: GO 61839
61921: POP
61922: POP
// end ; end_of_file
61923: LD_VAR 0 5
61927: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
61928: LD_INT 0
61930: PPUSH
61931: PPUSH
// if exist_mode then
61932: LD_VAR 0 2
61936: IFFALSE 61961
// unit := CreateCharacter ( prefix & ident ) else
61938: LD_ADDR_VAR 0 5
61942: PUSH
61943: LD_VAR 0 3
61947: PUSH
61948: LD_VAR 0 1
61952: STR
61953: PPUSH
61954: CALL_OW 34
61958: ST_TO_ADDR
61959: GO 61976
// unit := NewCharacter ( ident ) ;
61961: LD_ADDR_VAR 0 5
61965: PUSH
61966: LD_VAR 0 1
61970: PPUSH
61971: CALL_OW 25
61975: ST_TO_ADDR
// result := unit ;
61976: LD_ADDR_VAR 0 4
61980: PUSH
61981: LD_VAR 0 5
61985: ST_TO_ADDR
// end ;
61986: LD_VAR 0 4
61990: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
61991: LD_INT 0
61993: PPUSH
61994: PPUSH
// if not side or not nation then
61995: LD_VAR 0 1
61999: NOT
62000: PUSH
62001: LD_VAR 0 2
62005: NOT
62006: OR
62007: IFFALSE 62011
// exit ;
62009: GO 62647
// case nation of nation_american :
62011: LD_VAR 0 2
62015: PUSH
62016: LD_INT 1
62018: DOUBLE
62019: EQUAL
62020: IFTRUE 62024
62022: GO 62194
62024: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
62025: LD_ADDR_VAR 0 4
62029: PUSH
62030: LD_INT 35
62032: PUSH
62033: LD_INT 45
62035: PUSH
62036: LD_INT 46
62038: PUSH
62039: LD_INT 47
62041: PUSH
62042: LD_INT 1
62044: PUSH
62045: LD_INT 2
62047: PUSH
62048: LD_INT 6
62050: PUSH
62051: LD_INT 15
62053: PUSH
62054: LD_INT 16
62056: PUSH
62057: LD_INT 7
62059: PUSH
62060: LD_INT 12
62062: PUSH
62063: LD_INT 13
62065: PUSH
62066: LD_INT 10
62068: PUSH
62069: LD_INT 14
62071: PUSH
62072: LD_INT 20
62074: PUSH
62075: LD_INT 21
62077: PUSH
62078: LD_INT 22
62080: PUSH
62081: LD_INT 25
62083: PUSH
62084: LD_INT 32
62086: PUSH
62087: LD_INT 27
62089: PUSH
62090: LD_INT 36
62092: PUSH
62093: LD_INT 69
62095: PUSH
62096: LD_INT 39
62098: PUSH
62099: LD_INT 34
62101: PUSH
62102: LD_INT 40
62104: PUSH
62105: LD_INT 48
62107: PUSH
62108: LD_INT 49
62110: PUSH
62111: LD_INT 50
62113: PUSH
62114: LD_INT 51
62116: PUSH
62117: LD_INT 52
62119: PUSH
62120: LD_INT 53
62122: PUSH
62123: LD_INT 54
62125: PUSH
62126: LD_INT 55
62128: PUSH
62129: LD_INT 56
62131: PUSH
62132: LD_INT 57
62134: PUSH
62135: LD_INT 58
62137: PUSH
62138: LD_INT 59
62140: PUSH
62141: LD_INT 60
62143: PUSH
62144: LD_INT 61
62146: PUSH
62147: LD_INT 62
62149: PUSH
62150: EMPTY
62151: LIST
62152: LIST
62153: LIST
62154: LIST
62155: LIST
62156: LIST
62157: LIST
62158: LIST
62159: LIST
62160: LIST
62161: LIST
62162: LIST
62163: LIST
62164: LIST
62165: LIST
62166: LIST
62167: LIST
62168: LIST
62169: LIST
62170: LIST
62171: LIST
62172: LIST
62173: LIST
62174: LIST
62175: LIST
62176: LIST
62177: LIST
62178: LIST
62179: LIST
62180: LIST
62181: LIST
62182: LIST
62183: LIST
62184: LIST
62185: LIST
62186: LIST
62187: LIST
62188: LIST
62189: LIST
62190: LIST
62191: ST_TO_ADDR
62192: GO 62571
62194: LD_INT 2
62196: DOUBLE
62197: EQUAL
62198: IFTRUE 62202
62200: GO 62380
62202: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
62203: LD_ADDR_VAR 0 4
62207: PUSH
62208: LD_INT 35
62210: PUSH
62211: LD_INT 45
62213: PUSH
62214: LD_INT 46
62216: PUSH
62217: LD_INT 47
62219: PUSH
62220: LD_INT 70
62222: PUSH
62223: LD_INT 1
62225: PUSH
62226: LD_INT 11
62228: PUSH
62229: LD_INT 3
62231: PUSH
62232: LD_INT 4
62234: PUSH
62235: LD_INT 5
62237: PUSH
62238: LD_INT 6
62240: PUSH
62241: LD_INT 15
62243: PUSH
62244: LD_INT 18
62246: PUSH
62247: LD_INT 7
62249: PUSH
62250: LD_INT 17
62252: PUSH
62253: LD_INT 8
62255: PUSH
62256: LD_INT 20
62258: PUSH
62259: LD_INT 21
62261: PUSH
62262: LD_INT 22
62264: PUSH
62265: LD_INT 72
62267: PUSH
62268: LD_INT 26
62270: PUSH
62271: LD_INT 69
62273: PUSH
62274: LD_INT 39
62276: PUSH
62277: LD_INT 40
62279: PUSH
62280: LD_INT 41
62282: PUSH
62283: LD_INT 42
62285: PUSH
62286: LD_INT 43
62288: PUSH
62289: LD_INT 48
62291: PUSH
62292: LD_INT 49
62294: PUSH
62295: LD_INT 50
62297: PUSH
62298: LD_INT 51
62300: PUSH
62301: LD_INT 52
62303: PUSH
62304: LD_INT 53
62306: PUSH
62307: LD_INT 54
62309: PUSH
62310: LD_INT 55
62312: PUSH
62313: LD_INT 56
62315: PUSH
62316: LD_INT 60
62318: PUSH
62319: LD_INT 61
62321: PUSH
62322: LD_INT 62
62324: PUSH
62325: LD_INT 66
62327: PUSH
62328: LD_INT 67
62330: PUSH
62331: LD_INT 68
62333: PUSH
62334: EMPTY
62335: LIST
62336: LIST
62337: LIST
62338: LIST
62339: LIST
62340: LIST
62341: LIST
62342: LIST
62343: LIST
62344: LIST
62345: LIST
62346: LIST
62347: LIST
62348: LIST
62349: LIST
62350: LIST
62351: LIST
62352: LIST
62353: LIST
62354: LIST
62355: LIST
62356: LIST
62357: LIST
62358: LIST
62359: LIST
62360: LIST
62361: LIST
62362: LIST
62363: LIST
62364: LIST
62365: LIST
62366: LIST
62367: LIST
62368: LIST
62369: LIST
62370: LIST
62371: LIST
62372: LIST
62373: LIST
62374: LIST
62375: LIST
62376: LIST
62377: ST_TO_ADDR
62378: GO 62571
62380: LD_INT 3
62382: DOUBLE
62383: EQUAL
62384: IFTRUE 62388
62386: GO 62570
62388: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
62389: LD_ADDR_VAR 0 4
62393: PUSH
62394: LD_INT 46
62396: PUSH
62397: LD_INT 47
62399: PUSH
62400: LD_INT 1
62402: PUSH
62403: LD_INT 2
62405: PUSH
62406: LD_INT 11
62408: PUSH
62409: LD_INT 9
62411: PUSH
62412: LD_INT 20
62414: PUSH
62415: LD_INT 19
62417: PUSH
62418: LD_INT 21
62420: PUSH
62421: LD_INT 24
62423: PUSH
62424: LD_INT 22
62426: PUSH
62427: LD_INT 25
62429: PUSH
62430: LD_INT 28
62432: PUSH
62433: LD_INT 29
62435: PUSH
62436: LD_INT 30
62438: PUSH
62439: LD_INT 31
62441: PUSH
62442: LD_INT 37
62444: PUSH
62445: LD_INT 38
62447: PUSH
62448: LD_INT 32
62450: PUSH
62451: LD_INT 27
62453: PUSH
62454: LD_INT 33
62456: PUSH
62457: LD_INT 69
62459: PUSH
62460: LD_INT 39
62462: PUSH
62463: LD_INT 34
62465: PUSH
62466: LD_INT 40
62468: PUSH
62469: LD_INT 71
62471: PUSH
62472: LD_INT 23
62474: PUSH
62475: LD_INT 44
62477: PUSH
62478: LD_INT 48
62480: PUSH
62481: LD_INT 49
62483: PUSH
62484: LD_INT 50
62486: PUSH
62487: LD_INT 51
62489: PUSH
62490: LD_INT 52
62492: PUSH
62493: LD_INT 53
62495: PUSH
62496: LD_INT 54
62498: PUSH
62499: LD_INT 55
62501: PUSH
62502: LD_INT 56
62504: PUSH
62505: LD_INT 57
62507: PUSH
62508: LD_INT 58
62510: PUSH
62511: LD_INT 59
62513: PUSH
62514: LD_INT 63
62516: PUSH
62517: LD_INT 64
62519: PUSH
62520: LD_INT 65
62522: PUSH
62523: EMPTY
62524: LIST
62525: LIST
62526: LIST
62527: LIST
62528: LIST
62529: LIST
62530: LIST
62531: LIST
62532: LIST
62533: LIST
62534: LIST
62535: LIST
62536: LIST
62537: LIST
62538: LIST
62539: LIST
62540: LIST
62541: LIST
62542: LIST
62543: LIST
62544: LIST
62545: LIST
62546: LIST
62547: LIST
62548: LIST
62549: LIST
62550: LIST
62551: LIST
62552: LIST
62553: LIST
62554: LIST
62555: LIST
62556: LIST
62557: LIST
62558: LIST
62559: LIST
62560: LIST
62561: LIST
62562: LIST
62563: LIST
62564: LIST
62565: LIST
62566: LIST
62567: ST_TO_ADDR
62568: GO 62571
62570: POP
// if state > - 1 and state < 3 then
62571: LD_VAR 0 3
62575: PUSH
62576: LD_INT 1
62578: NEG
62579: GREATER
62580: PUSH
62581: LD_VAR 0 3
62585: PUSH
62586: LD_INT 3
62588: LESS
62589: AND
62590: IFFALSE 62647
// for i in result do
62592: LD_ADDR_VAR 0 5
62596: PUSH
62597: LD_VAR 0 4
62601: PUSH
62602: FOR_IN
62603: IFFALSE 62645
// if GetTech ( i , side ) <> state then
62605: LD_VAR 0 5
62609: PPUSH
62610: LD_VAR 0 1
62614: PPUSH
62615: CALL_OW 321
62619: PUSH
62620: LD_VAR 0 3
62624: NONEQUAL
62625: IFFALSE 62643
// result := result diff i ;
62627: LD_ADDR_VAR 0 4
62631: PUSH
62632: LD_VAR 0 4
62636: PUSH
62637: LD_VAR 0 5
62641: DIFF
62642: ST_TO_ADDR
62643: GO 62602
62645: POP
62646: POP
// end ;
62647: LD_VAR 0 4
62651: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
62652: LD_INT 0
62654: PPUSH
62655: PPUSH
62656: PPUSH
// result := true ;
62657: LD_ADDR_VAR 0 3
62661: PUSH
62662: LD_INT 1
62664: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
62665: LD_ADDR_VAR 0 5
62669: PUSH
62670: LD_VAR 0 2
62674: PPUSH
62675: CALL_OW 480
62679: ST_TO_ADDR
// if not tmp then
62680: LD_VAR 0 5
62684: NOT
62685: IFFALSE 62689
// exit ;
62687: GO 62738
// for i in tmp do
62689: LD_ADDR_VAR 0 4
62693: PUSH
62694: LD_VAR 0 5
62698: PUSH
62699: FOR_IN
62700: IFFALSE 62736
// if GetTech ( i , side ) <> state_researched then
62702: LD_VAR 0 4
62706: PPUSH
62707: LD_VAR 0 1
62711: PPUSH
62712: CALL_OW 321
62716: PUSH
62717: LD_INT 2
62719: NONEQUAL
62720: IFFALSE 62734
// begin result := false ;
62722: LD_ADDR_VAR 0 3
62726: PUSH
62727: LD_INT 0
62729: ST_TO_ADDR
// exit ;
62730: POP
62731: POP
62732: GO 62738
// end ;
62734: GO 62699
62736: POP
62737: POP
// end ;
62738: LD_VAR 0 3
62742: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
62743: LD_INT 0
62745: PPUSH
62746: PPUSH
62747: PPUSH
62748: PPUSH
62749: PPUSH
62750: PPUSH
62751: PPUSH
62752: PPUSH
62753: PPUSH
62754: PPUSH
62755: PPUSH
62756: PPUSH
62757: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
62758: LD_VAR 0 1
62762: NOT
62763: PUSH
62764: LD_VAR 0 1
62768: PPUSH
62769: CALL_OW 257
62773: PUSH
62774: LD_INT 9
62776: NONEQUAL
62777: OR
62778: IFFALSE 62782
// exit ;
62780: GO 63355
// side := GetSide ( unit ) ;
62782: LD_ADDR_VAR 0 9
62786: PUSH
62787: LD_VAR 0 1
62791: PPUSH
62792: CALL_OW 255
62796: ST_TO_ADDR
// tech_space := tech_spacanom ;
62797: LD_ADDR_VAR 0 12
62801: PUSH
62802: LD_INT 29
62804: ST_TO_ADDR
// tech_time := tech_taurad ;
62805: LD_ADDR_VAR 0 13
62809: PUSH
62810: LD_INT 28
62812: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
62813: LD_ADDR_VAR 0 11
62817: PUSH
62818: LD_VAR 0 1
62822: PPUSH
62823: CALL_OW 310
62827: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
62828: LD_VAR 0 11
62832: PPUSH
62833: CALL_OW 247
62837: PUSH
62838: LD_INT 2
62840: EQUAL
62841: IFFALSE 62845
// exit ;
62843: GO 63355
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
62845: LD_ADDR_VAR 0 8
62849: PUSH
62850: LD_INT 81
62852: PUSH
62853: LD_VAR 0 9
62857: PUSH
62858: EMPTY
62859: LIST
62860: LIST
62861: PUSH
62862: LD_INT 3
62864: PUSH
62865: LD_INT 21
62867: PUSH
62868: LD_INT 3
62870: PUSH
62871: EMPTY
62872: LIST
62873: LIST
62874: PUSH
62875: EMPTY
62876: LIST
62877: LIST
62878: PUSH
62879: EMPTY
62880: LIST
62881: LIST
62882: PPUSH
62883: CALL_OW 69
62887: ST_TO_ADDR
// if not tmp then
62888: LD_VAR 0 8
62892: NOT
62893: IFFALSE 62897
// exit ;
62895: GO 63355
// if in_unit then
62897: LD_VAR 0 11
62901: IFFALSE 62925
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
62903: LD_ADDR_VAR 0 10
62907: PUSH
62908: LD_VAR 0 8
62912: PPUSH
62913: LD_VAR 0 11
62917: PPUSH
62918: CALL_OW 74
62922: ST_TO_ADDR
62923: GO 62945
// enemy := NearestUnitToUnit ( tmp , unit ) ;
62925: LD_ADDR_VAR 0 10
62929: PUSH
62930: LD_VAR 0 8
62934: PPUSH
62935: LD_VAR 0 1
62939: PPUSH
62940: CALL_OW 74
62944: ST_TO_ADDR
// if not enemy then
62945: LD_VAR 0 10
62949: NOT
62950: IFFALSE 62954
// exit ;
62952: GO 63355
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
62954: LD_VAR 0 11
62958: PUSH
62959: LD_VAR 0 11
62963: PPUSH
62964: LD_VAR 0 10
62968: PPUSH
62969: CALL_OW 296
62973: PUSH
62974: LD_INT 13
62976: GREATER
62977: AND
62978: PUSH
62979: LD_VAR 0 1
62983: PPUSH
62984: LD_VAR 0 10
62988: PPUSH
62989: CALL_OW 296
62993: PUSH
62994: LD_INT 12
62996: GREATER
62997: OR
62998: IFFALSE 63002
// exit ;
63000: GO 63355
// missile := [ 1 ] ;
63002: LD_ADDR_VAR 0 14
63006: PUSH
63007: LD_INT 1
63009: PUSH
63010: EMPTY
63011: LIST
63012: ST_TO_ADDR
// if Researched ( side , tech_space ) then
63013: LD_VAR 0 9
63017: PPUSH
63018: LD_VAR 0 12
63022: PPUSH
63023: CALL_OW 325
63027: IFFALSE 63056
// missile := Insert ( missile , missile + 1 , 2 ) ;
63029: LD_ADDR_VAR 0 14
63033: PUSH
63034: LD_VAR 0 14
63038: PPUSH
63039: LD_VAR 0 14
63043: PUSH
63044: LD_INT 1
63046: PLUS
63047: PPUSH
63048: LD_INT 2
63050: PPUSH
63051: CALL_OW 2
63055: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
63056: LD_VAR 0 9
63060: PPUSH
63061: LD_VAR 0 13
63065: PPUSH
63066: CALL_OW 325
63070: PUSH
63071: LD_VAR 0 10
63075: PPUSH
63076: CALL_OW 255
63080: PPUSH
63081: LD_VAR 0 13
63085: PPUSH
63086: CALL_OW 325
63090: NOT
63091: AND
63092: IFFALSE 63121
// missile := Insert ( missile , missile + 1 , 3 ) ;
63094: LD_ADDR_VAR 0 14
63098: PUSH
63099: LD_VAR 0 14
63103: PPUSH
63104: LD_VAR 0 14
63108: PUSH
63109: LD_INT 1
63111: PLUS
63112: PPUSH
63113: LD_INT 3
63115: PPUSH
63116: CALL_OW 2
63120: ST_TO_ADDR
// if missile < 2 then
63121: LD_VAR 0 14
63125: PUSH
63126: LD_INT 2
63128: LESS
63129: IFFALSE 63133
// exit ;
63131: GO 63355
// x := GetX ( enemy ) ;
63133: LD_ADDR_VAR 0 4
63137: PUSH
63138: LD_VAR 0 10
63142: PPUSH
63143: CALL_OW 250
63147: ST_TO_ADDR
// y := GetY ( enemy ) ;
63148: LD_ADDR_VAR 0 5
63152: PUSH
63153: LD_VAR 0 10
63157: PPUSH
63158: CALL_OW 251
63162: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
63163: LD_ADDR_VAR 0 6
63167: PUSH
63168: LD_VAR 0 4
63172: PUSH
63173: LD_INT 1
63175: NEG
63176: PPUSH
63177: LD_INT 1
63179: PPUSH
63180: CALL_OW 12
63184: PLUS
63185: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
63186: LD_ADDR_VAR 0 7
63190: PUSH
63191: LD_VAR 0 5
63195: PUSH
63196: LD_INT 1
63198: NEG
63199: PPUSH
63200: LD_INT 1
63202: PPUSH
63203: CALL_OW 12
63207: PLUS
63208: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
63209: LD_VAR 0 6
63213: PPUSH
63214: LD_VAR 0 7
63218: PPUSH
63219: CALL_OW 488
63223: NOT
63224: IFFALSE 63246
// begin _x := x ;
63226: LD_ADDR_VAR 0 6
63230: PUSH
63231: LD_VAR 0 4
63235: ST_TO_ADDR
// _y := y ;
63236: LD_ADDR_VAR 0 7
63240: PUSH
63241: LD_VAR 0 5
63245: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
63246: LD_ADDR_VAR 0 3
63250: PUSH
63251: LD_INT 1
63253: PPUSH
63254: LD_VAR 0 14
63258: PPUSH
63259: CALL_OW 12
63263: ST_TO_ADDR
// case i of 1 :
63264: LD_VAR 0 3
63268: PUSH
63269: LD_INT 1
63271: DOUBLE
63272: EQUAL
63273: IFTRUE 63277
63275: GO 63294
63277: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
63278: LD_VAR 0 1
63282: PPUSH
63283: LD_VAR 0 10
63287: PPUSH
63288: CALL_OW 115
63292: GO 63355
63294: LD_INT 2
63296: DOUBLE
63297: EQUAL
63298: IFTRUE 63302
63300: GO 63324
63302: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
63303: LD_VAR 0 1
63307: PPUSH
63308: LD_VAR 0 6
63312: PPUSH
63313: LD_VAR 0 7
63317: PPUSH
63318: CALL_OW 153
63322: GO 63355
63324: LD_INT 3
63326: DOUBLE
63327: EQUAL
63328: IFTRUE 63332
63330: GO 63354
63332: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
63333: LD_VAR 0 1
63337: PPUSH
63338: LD_VAR 0 6
63342: PPUSH
63343: LD_VAR 0 7
63347: PPUSH
63348: CALL_OW 154
63352: GO 63355
63354: POP
// end ;
63355: LD_VAR 0 2
63359: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
63360: LD_INT 0
63362: PPUSH
63363: PPUSH
63364: PPUSH
63365: PPUSH
63366: PPUSH
63367: PPUSH
// if not unit or not building then
63368: LD_VAR 0 1
63372: NOT
63373: PUSH
63374: LD_VAR 0 2
63378: NOT
63379: OR
63380: IFFALSE 63384
// exit ;
63382: GO 63542
// x := GetX ( building ) ;
63384: LD_ADDR_VAR 0 5
63388: PUSH
63389: LD_VAR 0 2
63393: PPUSH
63394: CALL_OW 250
63398: ST_TO_ADDR
// y := GetY ( building ) ;
63399: LD_ADDR_VAR 0 6
63403: PUSH
63404: LD_VAR 0 2
63408: PPUSH
63409: CALL_OW 251
63413: ST_TO_ADDR
// for i = 0 to 5 do
63414: LD_ADDR_VAR 0 4
63418: PUSH
63419: DOUBLE
63420: LD_INT 0
63422: DEC
63423: ST_TO_ADDR
63424: LD_INT 5
63426: PUSH
63427: FOR_TO
63428: IFFALSE 63540
// begin _x := ShiftX ( x , i , 3 ) ;
63430: LD_ADDR_VAR 0 7
63434: PUSH
63435: LD_VAR 0 5
63439: PPUSH
63440: LD_VAR 0 4
63444: PPUSH
63445: LD_INT 3
63447: PPUSH
63448: CALL_OW 272
63452: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
63453: LD_ADDR_VAR 0 8
63457: PUSH
63458: LD_VAR 0 6
63462: PPUSH
63463: LD_VAR 0 4
63467: PPUSH
63468: LD_INT 3
63470: PPUSH
63471: CALL_OW 273
63475: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
63476: LD_VAR 0 7
63480: PPUSH
63481: LD_VAR 0 8
63485: PPUSH
63486: CALL_OW 488
63490: NOT
63491: IFFALSE 63495
// continue ;
63493: GO 63427
// if HexInfo ( _x , _y ) = 0 then
63495: LD_VAR 0 7
63499: PPUSH
63500: LD_VAR 0 8
63504: PPUSH
63505: CALL_OW 428
63509: PUSH
63510: LD_INT 0
63512: EQUAL
63513: IFFALSE 63538
// begin ComMoveXY ( unit , _x , _y ) ;
63515: LD_VAR 0 1
63519: PPUSH
63520: LD_VAR 0 7
63524: PPUSH
63525: LD_VAR 0 8
63529: PPUSH
63530: CALL_OW 111
// exit ;
63534: POP
63535: POP
63536: GO 63542
// end ; end ;
63538: GO 63427
63540: POP
63541: POP
// end ;
63542: LD_VAR 0 3
63546: RET
// export function ScanBase ( side , base_area ) ; begin
63547: LD_INT 0
63549: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
63550: LD_ADDR_VAR 0 3
63554: PUSH
63555: LD_VAR 0 2
63559: PPUSH
63560: LD_INT 81
63562: PUSH
63563: LD_VAR 0 1
63567: PUSH
63568: EMPTY
63569: LIST
63570: LIST
63571: PPUSH
63572: CALL_OW 70
63576: ST_TO_ADDR
// end ;
63577: LD_VAR 0 3
63581: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
63582: LD_INT 0
63584: PPUSH
63585: PPUSH
63586: PPUSH
63587: PPUSH
63588: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
63589: LD_VAR 0 1
63593: NOT
63594: PUSH
63595: LD_EXP 99
63599: PUSH
63600: LD_VAR 0 1
63604: ARRAY
63605: NOT
63606: OR
63607: PUSH
63608: LD_VAR 0 2
63612: NOT
63613: OR
63614: PUSH
63615: LD_VAR 0 3
63619: NOT
63620: OR
63621: IFFALSE 63625
// exit ;
63623: GO 64075
// side := mc_sides [ base ] ;
63625: LD_ADDR_VAR 0 6
63629: PUSH
63630: LD_EXP 125
63634: PUSH
63635: LD_VAR 0 1
63639: ARRAY
63640: ST_TO_ADDR
// if not side then
63641: LD_VAR 0 6
63645: NOT
63646: IFFALSE 63650
// exit ;
63648: GO 64075
// for i in solds do
63650: LD_ADDR_VAR 0 7
63654: PUSH
63655: LD_VAR 0 2
63659: PUSH
63660: FOR_IN
63661: IFFALSE 63722
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
63663: LD_VAR 0 7
63667: PPUSH
63668: CALL_OW 310
63672: PPUSH
63673: CALL_OW 266
63677: PUSH
63678: LD_INT 32
63680: PUSH
63681: LD_INT 31
63683: PUSH
63684: EMPTY
63685: LIST
63686: LIST
63687: IN
63688: IFFALSE 63708
// solds := solds diff i else
63690: LD_ADDR_VAR 0 2
63694: PUSH
63695: LD_VAR 0 2
63699: PUSH
63700: LD_VAR 0 7
63704: DIFF
63705: ST_TO_ADDR
63706: GO 63720
// SetTag ( i , 18 ) ;
63708: LD_VAR 0 7
63712: PPUSH
63713: LD_INT 18
63715: PPUSH
63716: CALL_OW 109
63720: GO 63660
63722: POP
63723: POP
// if not solds then
63724: LD_VAR 0 2
63728: NOT
63729: IFFALSE 63733
// exit ;
63731: GO 64075
// repeat wait ( 0 0$1 ) ;
63733: LD_INT 35
63735: PPUSH
63736: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
63740: LD_ADDR_VAR 0 5
63744: PUSH
63745: LD_VAR 0 6
63749: PPUSH
63750: LD_VAR 0 3
63754: PPUSH
63755: CALL 63547 0 2
63759: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
63760: LD_VAR 0 5
63764: NOT
63765: PUSH
63766: LD_VAR 0 5
63770: PUSH
63771: LD_INT 3
63773: GREATER
63774: OR
63775: PUSH
63776: LD_EXP 121
63780: PUSH
63781: LD_VAR 0 1
63785: ARRAY
63786: OR
63787: IFFALSE 63828
// begin for i in solds do
63789: LD_ADDR_VAR 0 7
63793: PUSH
63794: LD_VAR 0 2
63798: PUSH
63799: FOR_IN
63800: IFFALSE 63824
// if HasTask ( i ) then
63802: LD_VAR 0 7
63806: PPUSH
63807: CALL_OW 314
63811: IFFALSE 63822
// ComStop ( i ) ;
63813: LD_VAR 0 7
63817: PPUSH
63818: CALL_OW 141
63822: GO 63799
63824: POP
63825: POP
// break ;
63826: GO 64063
// end ; for i in solds do
63828: LD_ADDR_VAR 0 7
63832: PUSH
63833: LD_VAR 0 2
63837: PUSH
63838: FOR_IN
63839: IFFALSE 64055
// begin if IsInUnit ( i ) then
63841: LD_VAR 0 7
63845: PPUSH
63846: CALL_OW 310
63850: IFFALSE 63861
// ComExitBuilding ( i ) ;
63852: LD_VAR 0 7
63856: PPUSH
63857: CALL_OW 122
// if GetLives ( i ) > 333 then
63861: LD_VAR 0 7
63865: PPUSH
63866: CALL_OW 256
63870: PUSH
63871: LD_INT 333
63873: GREATER
63874: IFFALSE 63902
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
63876: LD_VAR 0 7
63880: PPUSH
63881: LD_VAR 0 5
63885: PPUSH
63886: LD_VAR 0 7
63890: PPUSH
63891: CALL_OW 74
63895: PPUSH
63896: CALL_OW 115
63900: GO 64053
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
63902: LD_ADDR_VAR 0 8
63906: PUSH
63907: LD_EXP 99
63911: PUSH
63912: LD_VAR 0 1
63916: ARRAY
63917: PPUSH
63918: LD_INT 2
63920: PUSH
63921: LD_INT 30
63923: PUSH
63924: LD_INT 0
63926: PUSH
63927: EMPTY
63928: LIST
63929: LIST
63930: PUSH
63931: LD_INT 30
63933: PUSH
63934: LD_INT 1
63936: PUSH
63937: EMPTY
63938: LIST
63939: LIST
63940: PUSH
63941: LD_INT 30
63943: PUSH
63944: LD_INT 6
63946: PUSH
63947: EMPTY
63948: LIST
63949: LIST
63950: PUSH
63951: EMPTY
63952: LIST
63953: LIST
63954: LIST
63955: LIST
63956: PPUSH
63957: CALL_OW 72
63961: PPUSH
63962: LD_VAR 0 7
63966: PPUSH
63967: CALL_OW 74
63971: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
63972: LD_VAR 0 7
63976: PPUSH
63977: LD_VAR 0 8
63981: PPUSH
63982: CALL_OW 250
63986: PPUSH
63987: LD_INT 3
63989: PPUSH
63990: LD_INT 5
63992: PPUSH
63993: CALL_OW 272
63997: PPUSH
63998: LD_VAR 0 8
64002: PPUSH
64003: CALL_OW 251
64007: PPUSH
64008: LD_INT 3
64010: PPUSH
64011: LD_INT 5
64013: PPUSH
64014: CALL_OW 273
64018: PPUSH
64019: CALL_OW 111
// SetTag ( i , 0 ) ;
64023: LD_VAR 0 7
64027: PPUSH
64028: LD_INT 0
64030: PPUSH
64031: CALL_OW 109
// solds := solds diff i ;
64035: LD_ADDR_VAR 0 2
64039: PUSH
64040: LD_VAR 0 2
64044: PUSH
64045: LD_VAR 0 7
64049: DIFF
64050: ST_TO_ADDR
// continue ;
64051: GO 63838
// end ; end ;
64053: GO 63838
64055: POP
64056: POP
// until solds ;
64057: LD_VAR 0 2
64061: IFFALSE 63733
// MC_Reset ( base , 18 ) ;
64063: LD_VAR 0 1
64067: PPUSH
64068: LD_INT 18
64070: PPUSH
64071: CALL 36795 0 2
// end ;
64075: LD_VAR 0 4
64079: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
64080: LD_INT 0
64082: PPUSH
64083: PPUSH
64084: PPUSH
64085: PPUSH
64086: PPUSH
64087: PPUSH
64088: PPUSH
64089: PPUSH
64090: PPUSH
64091: PPUSH
64092: PPUSH
64093: PPUSH
64094: PPUSH
64095: PPUSH
64096: PPUSH
64097: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
64098: LD_ADDR_VAR 0 12
64102: PUSH
64103: LD_EXP 99
64107: PUSH
64108: LD_VAR 0 1
64112: ARRAY
64113: PPUSH
64114: LD_INT 25
64116: PUSH
64117: LD_INT 3
64119: PUSH
64120: EMPTY
64121: LIST
64122: LIST
64123: PPUSH
64124: CALL_OW 72
64128: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
64129: LD_ADDR_VAR 0 8
64133: PUSH
64134: LD_EXP 99
64138: PUSH
64139: LD_VAR 0 1
64143: ARRAY
64144: PPUSH
64145: LD_INT 2
64147: PUSH
64148: LD_INT 25
64150: PUSH
64151: LD_INT 1
64153: PUSH
64154: EMPTY
64155: LIST
64156: LIST
64157: PUSH
64158: LD_INT 25
64160: PUSH
64161: LD_INT 5
64163: PUSH
64164: EMPTY
64165: LIST
64166: LIST
64167: PUSH
64168: LD_INT 25
64170: PUSH
64171: LD_INT 8
64173: PUSH
64174: EMPTY
64175: LIST
64176: LIST
64177: PUSH
64178: LD_INT 25
64180: PUSH
64181: LD_INT 9
64183: PUSH
64184: EMPTY
64185: LIST
64186: LIST
64187: PUSH
64188: EMPTY
64189: LIST
64190: LIST
64191: LIST
64192: LIST
64193: LIST
64194: PPUSH
64195: CALL_OW 72
64199: ST_TO_ADDR
// if not defenders and not solds then
64200: LD_VAR 0 2
64204: NOT
64205: PUSH
64206: LD_VAR 0 8
64210: NOT
64211: AND
64212: IFFALSE 64216
// exit ;
64214: GO 65582
// depot_under_attack := false ;
64216: LD_ADDR_VAR 0 16
64220: PUSH
64221: LD_INT 0
64223: ST_TO_ADDR
// sold_defenders := [ ] ;
64224: LD_ADDR_VAR 0 17
64228: PUSH
64229: EMPTY
64230: ST_TO_ADDR
// if mechs then
64231: LD_VAR 0 12
64235: IFFALSE 64364
// for i in defenders do
64237: LD_ADDR_VAR 0 5
64241: PUSH
64242: LD_VAR 0 2
64246: PUSH
64247: FOR_IN
64248: IFFALSE 64362
// begin SetTag ( i , 20 ) ;
64250: LD_VAR 0 5
64254: PPUSH
64255: LD_INT 20
64257: PPUSH
64258: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
64262: LD_VAR 0 5
64266: PPUSH
64267: CALL_OW 263
64271: PUSH
64272: LD_INT 1
64274: EQUAL
64275: PUSH
64276: LD_VAR 0 5
64280: PPUSH
64281: CALL_OW 311
64285: NOT
64286: AND
64287: PUSH
64288: LD_VAR 0 12
64292: AND
64293: IFFALSE 64360
// begin un := mechs [ 1 ] ;
64295: LD_ADDR_VAR 0 10
64299: PUSH
64300: LD_VAR 0 12
64304: PUSH
64305: LD_INT 1
64307: ARRAY
64308: ST_TO_ADDR
// ComExitBuilding ( un ) ;
64309: LD_VAR 0 10
64313: PPUSH
64314: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
64318: LD_VAR 0 10
64322: PPUSH
64323: LD_VAR 0 5
64327: PPUSH
64328: CALL_OW 180
// SetTag ( un , 19 ) ;
64332: LD_VAR 0 10
64336: PPUSH
64337: LD_INT 19
64339: PPUSH
64340: CALL_OW 109
// mechs := mechs diff un ;
64344: LD_ADDR_VAR 0 12
64348: PUSH
64349: LD_VAR 0 12
64353: PUSH
64354: LD_VAR 0 10
64358: DIFF
64359: ST_TO_ADDR
// end ; end ;
64360: GO 64247
64362: POP
64363: POP
// if solds then
64364: LD_VAR 0 8
64368: IFFALSE 64427
// for i in solds do
64370: LD_ADDR_VAR 0 5
64374: PUSH
64375: LD_VAR 0 8
64379: PUSH
64380: FOR_IN
64381: IFFALSE 64425
// if not GetTag ( i ) then
64383: LD_VAR 0 5
64387: PPUSH
64388: CALL_OW 110
64392: NOT
64393: IFFALSE 64423
// begin defenders := defenders union i ;
64395: LD_ADDR_VAR 0 2
64399: PUSH
64400: LD_VAR 0 2
64404: PUSH
64405: LD_VAR 0 5
64409: UNION
64410: ST_TO_ADDR
// SetTag ( i , 18 ) ;
64411: LD_VAR 0 5
64415: PPUSH
64416: LD_INT 18
64418: PPUSH
64419: CALL_OW 109
// end ;
64423: GO 64380
64425: POP
64426: POP
// repeat wait ( 0 0$1 ) ;
64427: LD_INT 35
64429: PPUSH
64430: CALL_OW 67
// enemy := mc_scan [ base ] ;
64434: LD_ADDR_VAR 0 3
64438: PUSH
64439: LD_EXP 122
64443: PUSH
64444: LD_VAR 0 1
64448: ARRAY
64449: ST_TO_ADDR
// for i in defenders do
64450: LD_ADDR_VAR 0 5
64454: PUSH
64455: LD_VAR 0 2
64459: PUSH
64460: FOR_IN
64461: IFFALSE 65146
// begin e := NearestUnitToUnit ( enemy , i ) ;
64463: LD_ADDR_VAR 0 13
64467: PUSH
64468: LD_VAR 0 3
64472: PPUSH
64473: LD_VAR 0 5
64477: PPUSH
64478: CALL_OW 74
64482: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
64483: LD_ADDR_VAR 0 16
64487: PUSH
64488: LD_EXP 99
64492: PUSH
64493: LD_VAR 0 1
64497: ARRAY
64498: PPUSH
64499: LD_INT 2
64501: PUSH
64502: LD_INT 30
64504: PUSH
64505: LD_INT 0
64507: PUSH
64508: EMPTY
64509: LIST
64510: LIST
64511: PUSH
64512: LD_INT 30
64514: PUSH
64515: LD_INT 1
64517: PUSH
64518: EMPTY
64519: LIST
64520: LIST
64521: PUSH
64522: EMPTY
64523: LIST
64524: LIST
64525: LIST
64526: PPUSH
64527: CALL_OW 72
64531: NOT
64532: PUSH
64533: LD_EXP 99
64537: PUSH
64538: LD_VAR 0 1
64542: ARRAY
64543: PPUSH
64544: LD_INT 2
64546: PUSH
64547: LD_INT 30
64549: PUSH
64550: LD_INT 0
64552: PUSH
64553: EMPTY
64554: LIST
64555: LIST
64556: PUSH
64557: LD_INT 30
64559: PUSH
64560: LD_INT 1
64562: PUSH
64563: EMPTY
64564: LIST
64565: LIST
64566: PUSH
64567: EMPTY
64568: LIST
64569: LIST
64570: LIST
64571: PPUSH
64572: CALL_OW 72
64576: PPUSH
64577: CALL_OW 256
64581: PUSH
64582: LD_INT 600
64584: LESS
64585: OR
64586: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
64587: LD_VAR 0 5
64591: PPUSH
64592: CALL_OW 247
64596: PUSH
64597: LD_INT 2
64599: DOUBLE
64600: EQUAL
64601: IFTRUE 64605
64603: GO 64852
64605: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
64606: LD_VAR 0 5
64610: PPUSH
64611: CALL_OW 256
64615: PUSH
64616: LD_INT 650
64618: GREATER
64619: PUSH
64620: LD_VAR 0 5
64624: PPUSH
64625: LD_VAR 0 13
64629: PPUSH
64630: CALL_OW 296
64634: PUSH
64635: LD_INT 40
64637: LESS
64638: AND
64639: IFFALSE 64657
// ComAttackUnit ( i , e ) else
64641: LD_VAR 0 5
64645: PPUSH
64646: LD_VAR 0 13
64650: PPUSH
64651: CALL_OW 115
64655: GO 64735
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
64657: LD_VAR 0 5
64661: PPUSH
64662: LD_VAR 0 13
64666: PPUSH
64667: CALL_OW 296
64671: PUSH
64672: LD_INT 30
64674: GREATEREQUAL
64675: PUSH
64676: LD_VAR 0 5
64680: PPUSH
64681: CALL_OW 256
64685: PUSH
64686: LD_INT 650
64688: LESSEQUAL
64689: OR
64690: PUSH
64691: LD_VAR 0 5
64695: PPUSH
64696: LD_EXP 123
64700: PUSH
64701: LD_VAR 0 1
64705: ARRAY
64706: PPUSH
64707: CALL_OW 308
64711: NOT
64712: AND
64713: IFFALSE 64735
// ComMoveToArea ( i , mc_parking [ base ] ) ;
64715: LD_VAR 0 5
64719: PPUSH
64720: LD_EXP 123
64724: PUSH
64725: LD_VAR 0 1
64729: ARRAY
64730: PPUSH
64731: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
64735: LD_VAR 0 5
64739: PPUSH
64740: CALL_OW 256
64744: PUSH
64745: LD_INT 998
64747: LESS
64748: PUSH
64749: LD_VAR 0 5
64753: PPUSH
64754: CALL_OW 263
64758: PUSH
64759: LD_INT 1
64761: EQUAL
64762: AND
64763: PUSH
64764: LD_VAR 0 5
64768: PPUSH
64769: CALL_OW 311
64773: AND
64774: PUSH
64775: LD_VAR 0 5
64779: PPUSH
64780: LD_EXP 123
64784: PUSH
64785: LD_VAR 0 1
64789: ARRAY
64790: PPUSH
64791: CALL_OW 308
64795: AND
64796: IFFALSE 64850
// begin mech := IsDrivenBy ( i ) ;
64798: LD_ADDR_VAR 0 9
64802: PUSH
64803: LD_VAR 0 5
64807: PPUSH
64808: CALL_OW 311
64812: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
64813: LD_VAR 0 9
64817: PPUSH
64818: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
64822: LD_VAR 0 9
64826: PPUSH
64827: LD_VAR 0 5
64831: PPUSH
64832: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
64836: LD_VAR 0 9
64840: PPUSH
64841: LD_VAR 0 5
64845: PPUSH
64846: CALL_OW 180
// end ; end ; unit_human :
64850: GO 65117
64852: LD_INT 1
64854: DOUBLE
64855: EQUAL
64856: IFTRUE 64860
64858: GO 65116
64860: POP
// begin b := IsInUnit ( i ) ;
64861: LD_ADDR_VAR 0 18
64865: PUSH
64866: LD_VAR 0 5
64870: PPUSH
64871: CALL_OW 310
64875: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
64876: LD_ADDR_VAR 0 19
64880: PUSH
64881: LD_VAR 0 18
64885: NOT
64886: PUSH
64887: LD_VAR 0 18
64891: PPUSH
64892: CALL_OW 266
64896: PUSH
64897: LD_INT 32
64899: PUSH
64900: LD_INT 31
64902: PUSH
64903: EMPTY
64904: LIST
64905: LIST
64906: IN
64907: OR
64908: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
64909: LD_VAR 0 16
64913: PUSH
64914: LD_VAR 0 2
64918: PPUSH
64919: LD_INT 21
64921: PUSH
64922: LD_INT 2
64924: PUSH
64925: EMPTY
64926: LIST
64927: LIST
64928: PPUSH
64929: CALL_OW 72
64933: PUSH
64934: LD_INT 1
64936: LESSEQUAL
64937: OR
64938: PUSH
64939: LD_VAR 0 19
64943: AND
64944: PUSH
64945: LD_VAR 0 5
64949: PUSH
64950: LD_VAR 0 17
64954: IN
64955: NOT
64956: AND
64957: IFFALSE 65050
// begin if b then
64959: LD_VAR 0 18
64963: IFFALSE 65012
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
64965: LD_VAR 0 18
64969: PPUSH
64970: LD_VAR 0 3
64974: PPUSH
64975: LD_VAR 0 18
64979: PPUSH
64980: CALL_OW 74
64984: PPUSH
64985: CALL_OW 296
64989: PUSH
64990: LD_INT 10
64992: LESS
64993: PUSH
64994: LD_VAR 0 18
64998: PPUSH
64999: CALL_OW 461
65003: PUSH
65004: LD_INT 7
65006: NONEQUAL
65007: AND
65008: IFFALSE 65012
// continue ;
65010: GO 64460
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
65012: LD_ADDR_VAR 0 17
65016: PUSH
65017: LD_VAR 0 17
65021: PPUSH
65022: LD_VAR 0 17
65026: PUSH
65027: LD_INT 1
65029: PLUS
65030: PPUSH
65031: LD_VAR 0 5
65035: PPUSH
65036: CALL_OW 1
65040: ST_TO_ADDR
// ComExitBuilding ( i ) ;
65041: LD_VAR 0 5
65045: PPUSH
65046: CALL_OW 122
// end ; if sold_defenders then
65050: LD_VAR 0 17
65054: IFFALSE 65114
// if i in sold_defenders then
65056: LD_VAR 0 5
65060: PUSH
65061: LD_VAR 0 17
65065: IN
65066: IFFALSE 65114
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
65068: LD_VAR 0 5
65072: PPUSH
65073: CALL_OW 314
65077: NOT
65078: PUSH
65079: LD_VAR 0 5
65083: PPUSH
65084: LD_VAR 0 13
65088: PPUSH
65089: CALL_OW 296
65093: PUSH
65094: LD_INT 30
65096: LESS
65097: AND
65098: IFFALSE 65114
// ComAttackUnit ( i , e ) ;
65100: LD_VAR 0 5
65104: PPUSH
65105: LD_VAR 0 13
65109: PPUSH
65110: CALL_OW 115
// end ; end ; end ;
65114: GO 65117
65116: POP
// if IsDead ( i ) then
65117: LD_VAR 0 5
65121: PPUSH
65122: CALL_OW 301
65126: IFFALSE 65144
// defenders := defenders diff i ;
65128: LD_ADDR_VAR 0 2
65132: PUSH
65133: LD_VAR 0 2
65137: PUSH
65138: LD_VAR 0 5
65142: DIFF
65143: ST_TO_ADDR
// end ;
65144: GO 64460
65146: POP
65147: POP
// until not enemy or not defenders ;
65148: LD_VAR 0 3
65152: NOT
65153: PUSH
65154: LD_VAR 0 2
65158: NOT
65159: OR
65160: IFFALSE 64427
// MC_Reset ( base , 18 ) ;
65162: LD_VAR 0 1
65166: PPUSH
65167: LD_INT 18
65169: PPUSH
65170: CALL 36795 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65174: LD_ADDR_VAR 0 2
65178: PUSH
65179: LD_VAR 0 2
65183: PUSH
65184: LD_VAR 0 2
65188: PPUSH
65189: LD_INT 2
65191: PUSH
65192: LD_INT 25
65194: PUSH
65195: LD_INT 1
65197: PUSH
65198: EMPTY
65199: LIST
65200: LIST
65201: PUSH
65202: LD_INT 25
65204: PUSH
65205: LD_INT 5
65207: PUSH
65208: EMPTY
65209: LIST
65210: LIST
65211: PUSH
65212: LD_INT 25
65214: PUSH
65215: LD_INT 8
65217: PUSH
65218: EMPTY
65219: LIST
65220: LIST
65221: PUSH
65222: LD_INT 25
65224: PUSH
65225: LD_INT 9
65227: PUSH
65228: EMPTY
65229: LIST
65230: LIST
65231: PUSH
65232: EMPTY
65233: LIST
65234: LIST
65235: LIST
65236: LIST
65237: LIST
65238: PPUSH
65239: CALL_OW 72
65243: DIFF
65244: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
65245: LD_VAR 0 3
65249: NOT
65250: PUSH
65251: LD_VAR 0 2
65255: PPUSH
65256: LD_INT 21
65258: PUSH
65259: LD_INT 2
65261: PUSH
65262: EMPTY
65263: LIST
65264: LIST
65265: PPUSH
65266: CALL_OW 72
65270: AND
65271: IFFALSE 65533
// begin tmp := FilterByTag ( defenders , 19 ) ;
65273: LD_ADDR_VAR 0 11
65277: PUSH
65278: LD_VAR 0 2
65282: PPUSH
65283: LD_INT 19
65285: PPUSH
65286: CALL 101880 0 2
65290: ST_TO_ADDR
// if tmp then
65291: LD_VAR 0 11
65295: IFFALSE 65365
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
65297: LD_ADDR_VAR 0 11
65301: PUSH
65302: LD_VAR 0 11
65306: PPUSH
65307: LD_INT 25
65309: PUSH
65310: LD_INT 3
65312: PUSH
65313: EMPTY
65314: LIST
65315: LIST
65316: PPUSH
65317: CALL_OW 72
65321: ST_TO_ADDR
// if tmp then
65322: LD_VAR 0 11
65326: IFFALSE 65365
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
65328: LD_ADDR_EXP 111
65332: PUSH
65333: LD_EXP 111
65337: PPUSH
65338: LD_VAR 0 1
65342: PPUSH
65343: LD_EXP 111
65347: PUSH
65348: LD_VAR 0 1
65352: ARRAY
65353: PUSH
65354: LD_VAR 0 11
65358: UNION
65359: PPUSH
65360: CALL_OW 1
65364: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
65365: LD_VAR 0 1
65369: PPUSH
65370: LD_INT 19
65372: PPUSH
65373: CALL 36795 0 2
// repeat wait ( 0 0$1 ) ;
65377: LD_INT 35
65379: PPUSH
65380: CALL_OW 67
// for i in defenders do
65384: LD_ADDR_VAR 0 5
65388: PUSH
65389: LD_VAR 0 2
65393: PUSH
65394: FOR_IN
65395: IFFALSE 65484
// begin if not IsInArea ( i , mc_parking [ base ] ) then
65397: LD_VAR 0 5
65401: PPUSH
65402: LD_EXP 123
65406: PUSH
65407: LD_VAR 0 1
65411: ARRAY
65412: PPUSH
65413: CALL_OW 308
65417: NOT
65418: IFFALSE 65442
// ComMoveToArea ( i , mc_parking [ base ] ) else
65420: LD_VAR 0 5
65424: PPUSH
65425: LD_EXP 123
65429: PUSH
65430: LD_VAR 0 1
65434: ARRAY
65435: PPUSH
65436: CALL_OW 113
65440: GO 65482
// if GetControl ( i ) = control_manual then
65442: LD_VAR 0 5
65446: PPUSH
65447: CALL_OW 263
65451: PUSH
65452: LD_INT 1
65454: EQUAL
65455: IFFALSE 65482
// if IsDrivenBy ( i ) then
65457: LD_VAR 0 5
65461: PPUSH
65462: CALL_OW 311
65466: IFFALSE 65482
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
65468: LD_VAR 0 5
65472: PPUSH
65473: CALL_OW 311
65477: PPUSH
65478: CALL_OW 121
// end ;
65482: GO 65394
65484: POP
65485: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
65486: LD_VAR 0 2
65490: PPUSH
65491: LD_INT 95
65493: PUSH
65494: LD_EXP 123
65498: PUSH
65499: LD_VAR 0 1
65503: ARRAY
65504: PUSH
65505: EMPTY
65506: LIST
65507: LIST
65508: PPUSH
65509: CALL_OW 72
65513: PUSH
65514: LD_VAR 0 2
65518: EQUAL
65519: PUSH
65520: LD_EXP 122
65524: PUSH
65525: LD_VAR 0 1
65529: ARRAY
65530: OR
65531: IFFALSE 65377
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
65533: LD_ADDR_EXP 121
65537: PUSH
65538: LD_EXP 121
65542: PPUSH
65543: LD_VAR 0 1
65547: PPUSH
65548: LD_EXP 121
65552: PUSH
65553: LD_VAR 0 1
65557: ARRAY
65558: PUSH
65559: LD_VAR 0 2
65563: UNION
65564: PPUSH
65565: CALL_OW 1
65569: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
65570: LD_VAR 0 1
65574: PPUSH
65575: LD_INT 20
65577: PPUSH
65578: CALL 36795 0 2
// end ;
65582: LD_VAR 0 4
65586: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
65587: LD_INT 0
65589: PPUSH
65590: PPUSH
65591: PPUSH
65592: PPUSH
// result := false ;
65593: LD_ADDR_VAR 0 2
65597: PUSH
65598: LD_INT 0
65600: ST_TO_ADDR
// side := GetSide ( unit ) ;
65601: LD_ADDR_VAR 0 3
65605: PUSH
65606: LD_VAR 0 1
65610: PPUSH
65611: CALL_OW 255
65615: ST_TO_ADDR
// nat := GetNation ( unit ) ;
65616: LD_ADDR_VAR 0 4
65620: PUSH
65621: LD_VAR 0 1
65625: PPUSH
65626: CALL_OW 248
65630: ST_TO_ADDR
// case nat of 1 :
65631: LD_VAR 0 4
65635: PUSH
65636: LD_INT 1
65638: DOUBLE
65639: EQUAL
65640: IFTRUE 65644
65642: GO 65655
65644: POP
// tech := tech_lassight ; 2 :
65645: LD_ADDR_VAR 0 5
65649: PUSH
65650: LD_INT 12
65652: ST_TO_ADDR
65653: GO 65694
65655: LD_INT 2
65657: DOUBLE
65658: EQUAL
65659: IFTRUE 65663
65661: GO 65674
65663: POP
// tech := tech_mortar ; 3 :
65664: LD_ADDR_VAR 0 5
65668: PUSH
65669: LD_INT 41
65671: ST_TO_ADDR
65672: GO 65694
65674: LD_INT 3
65676: DOUBLE
65677: EQUAL
65678: IFTRUE 65682
65680: GO 65693
65682: POP
// tech := tech_bazooka ; end ;
65683: LD_ADDR_VAR 0 5
65687: PUSH
65688: LD_INT 44
65690: ST_TO_ADDR
65691: GO 65694
65693: POP
// if Researched ( side , tech ) then
65694: LD_VAR 0 3
65698: PPUSH
65699: LD_VAR 0 5
65703: PPUSH
65704: CALL_OW 325
65708: IFFALSE 65735
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
65710: LD_ADDR_VAR 0 2
65714: PUSH
65715: LD_INT 5
65717: PUSH
65718: LD_INT 8
65720: PUSH
65721: LD_INT 9
65723: PUSH
65724: EMPTY
65725: LIST
65726: LIST
65727: LIST
65728: PUSH
65729: LD_VAR 0 4
65733: ARRAY
65734: ST_TO_ADDR
// end ;
65735: LD_VAR 0 2
65739: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
65740: LD_INT 0
65742: PPUSH
65743: PPUSH
65744: PPUSH
// if not mines then
65745: LD_VAR 0 2
65749: NOT
65750: IFFALSE 65754
// exit ;
65752: GO 65898
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65754: LD_ADDR_VAR 0 5
65758: PUSH
65759: LD_INT 81
65761: PUSH
65762: LD_VAR 0 1
65766: PUSH
65767: EMPTY
65768: LIST
65769: LIST
65770: PUSH
65771: LD_INT 3
65773: PUSH
65774: LD_INT 21
65776: PUSH
65777: LD_INT 3
65779: PUSH
65780: EMPTY
65781: LIST
65782: LIST
65783: PUSH
65784: EMPTY
65785: LIST
65786: LIST
65787: PUSH
65788: EMPTY
65789: LIST
65790: LIST
65791: PPUSH
65792: CALL_OW 69
65796: ST_TO_ADDR
// for i in mines do
65797: LD_ADDR_VAR 0 4
65801: PUSH
65802: LD_VAR 0 2
65806: PUSH
65807: FOR_IN
65808: IFFALSE 65896
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
65810: LD_VAR 0 4
65814: PUSH
65815: LD_INT 1
65817: ARRAY
65818: PPUSH
65819: LD_VAR 0 4
65823: PUSH
65824: LD_INT 2
65826: ARRAY
65827: PPUSH
65828: CALL_OW 458
65832: NOT
65833: IFFALSE 65837
// continue ;
65835: GO 65807
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
65837: LD_VAR 0 4
65841: PUSH
65842: LD_INT 1
65844: ARRAY
65845: PPUSH
65846: LD_VAR 0 4
65850: PUSH
65851: LD_INT 2
65853: ARRAY
65854: PPUSH
65855: CALL_OW 428
65859: PUSH
65860: LD_VAR 0 5
65864: IN
65865: IFFALSE 65894
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
65867: LD_VAR 0 4
65871: PUSH
65872: LD_INT 1
65874: ARRAY
65875: PPUSH
65876: LD_VAR 0 4
65880: PUSH
65881: LD_INT 2
65883: ARRAY
65884: PPUSH
65885: LD_VAR 0 1
65889: PPUSH
65890: CALL_OW 456
// end ;
65894: GO 65807
65896: POP
65897: POP
// end ;
65898: LD_VAR 0 3
65902: RET
// export function Count ( array ) ; var i ; begin
65903: LD_INT 0
65905: PPUSH
65906: PPUSH
// result := 0 ;
65907: LD_ADDR_VAR 0 2
65911: PUSH
65912: LD_INT 0
65914: ST_TO_ADDR
// for i in array do
65915: LD_ADDR_VAR 0 3
65919: PUSH
65920: LD_VAR 0 1
65924: PUSH
65925: FOR_IN
65926: IFFALSE 65950
// if i then
65928: LD_VAR 0 3
65932: IFFALSE 65948
// result := result + 1 ;
65934: LD_ADDR_VAR 0 2
65938: PUSH
65939: LD_VAR 0 2
65943: PUSH
65944: LD_INT 1
65946: PLUS
65947: ST_TO_ADDR
65948: GO 65925
65950: POP
65951: POP
// end ;
65952: LD_VAR 0 2
65956: RET
// export function IsEmpty ( building ) ; begin
65957: LD_INT 0
65959: PPUSH
// if not building then
65960: LD_VAR 0 1
65964: NOT
65965: IFFALSE 65969
// exit ;
65967: GO 66012
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
65969: LD_ADDR_VAR 0 2
65973: PUSH
65974: LD_VAR 0 1
65978: PUSH
65979: LD_INT 22
65981: PUSH
65982: LD_VAR 0 1
65986: PPUSH
65987: CALL_OW 255
65991: PUSH
65992: EMPTY
65993: LIST
65994: LIST
65995: PUSH
65996: LD_INT 58
65998: PUSH
65999: EMPTY
66000: LIST
66001: PUSH
66002: EMPTY
66003: LIST
66004: LIST
66005: PPUSH
66006: CALL_OW 69
66010: IN
66011: ST_TO_ADDR
// end ;
66012: LD_VAR 0 2
66016: RET
// export function IsNotFull ( building ) ; begin
66017: LD_INT 0
66019: PPUSH
// if not building then
66020: LD_VAR 0 1
66024: NOT
66025: IFFALSE 66029
// exit ;
66027: GO 66048
// result := UnitsInside ( building ) < 6 ;
66029: LD_ADDR_VAR 0 2
66033: PUSH
66034: LD_VAR 0 1
66038: PPUSH
66039: CALL_OW 313
66043: PUSH
66044: LD_INT 6
66046: LESS
66047: ST_TO_ADDR
// end ;
66048: LD_VAR 0 2
66052: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
66053: LD_INT 0
66055: PPUSH
66056: PPUSH
66057: PPUSH
66058: PPUSH
// tmp := [ ] ;
66059: LD_ADDR_VAR 0 3
66063: PUSH
66064: EMPTY
66065: ST_TO_ADDR
// list := [ ] ;
66066: LD_ADDR_VAR 0 5
66070: PUSH
66071: EMPTY
66072: ST_TO_ADDR
// for i = 16 to 25 do
66073: LD_ADDR_VAR 0 4
66077: PUSH
66078: DOUBLE
66079: LD_INT 16
66081: DEC
66082: ST_TO_ADDR
66083: LD_INT 25
66085: PUSH
66086: FOR_TO
66087: IFFALSE 66160
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
66089: LD_ADDR_VAR 0 3
66093: PUSH
66094: LD_VAR 0 3
66098: PUSH
66099: LD_INT 22
66101: PUSH
66102: LD_VAR 0 1
66106: PPUSH
66107: CALL_OW 255
66111: PUSH
66112: EMPTY
66113: LIST
66114: LIST
66115: PUSH
66116: LD_INT 91
66118: PUSH
66119: LD_VAR 0 1
66123: PUSH
66124: LD_INT 6
66126: PUSH
66127: EMPTY
66128: LIST
66129: LIST
66130: LIST
66131: PUSH
66132: LD_INT 30
66134: PUSH
66135: LD_VAR 0 4
66139: PUSH
66140: EMPTY
66141: LIST
66142: LIST
66143: PUSH
66144: EMPTY
66145: LIST
66146: LIST
66147: LIST
66148: PUSH
66149: EMPTY
66150: LIST
66151: PPUSH
66152: CALL_OW 69
66156: ADD
66157: ST_TO_ADDR
66158: GO 66086
66160: POP
66161: POP
// for i = 1 to tmp do
66162: LD_ADDR_VAR 0 4
66166: PUSH
66167: DOUBLE
66168: LD_INT 1
66170: DEC
66171: ST_TO_ADDR
66172: LD_VAR 0 3
66176: PUSH
66177: FOR_TO
66178: IFFALSE 66266
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
66180: LD_ADDR_VAR 0 5
66184: PUSH
66185: LD_VAR 0 5
66189: PUSH
66190: LD_VAR 0 3
66194: PUSH
66195: LD_VAR 0 4
66199: ARRAY
66200: PPUSH
66201: CALL_OW 266
66205: PUSH
66206: LD_VAR 0 3
66210: PUSH
66211: LD_VAR 0 4
66215: ARRAY
66216: PPUSH
66217: CALL_OW 250
66221: PUSH
66222: LD_VAR 0 3
66226: PUSH
66227: LD_VAR 0 4
66231: ARRAY
66232: PPUSH
66233: CALL_OW 251
66237: PUSH
66238: LD_VAR 0 3
66242: PUSH
66243: LD_VAR 0 4
66247: ARRAY
66248: PPUSH
66249: CALL_OW 254
66253: PUSH
66254: EMPTY
66255: LIST
66256: LIST
66257: LIST
66258: LIST
66259: PUSH
66260: EMPTY
66261: LIST
66262: ADD
66263: ST_TO_ADDR
66264: GO 66177
66266: POP
66267: POP
// result := list ;
66268: LD_ADDR_VAR 0 2
66272: PUSH
66273: LD_VAR 0 5
66277: ST_TO_ADDR
// end ;
66278: LD_VAR 0 2
66282: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
66283: LD_INT 0
66285: PPUSH
66286: PPUSH
66287: PPUSH
66288: PPUSH
66289: PPUSH
66290: PPUSH
66291: PPUSH
// if not factory then
66292: LD_VAR 0 1
66296: NOT
66297: IFFALSE 66301
// exit ;
66299: GO 66826
// if control = control_apeman then
66301: LD_VAR 0 4
66305: PUSH
66306: LD_INT 5
66308: EQUAL
66309: IFFALSE 66418
// begin tmp := UnitsInside ( factory ) ;
66311: LD_ADDR_VAR 0 8
66315: PUSH
66316: LD_VAR 0 1
66320: PPUSH
66321: CALL_OW 313
66325: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
66326: LD_VAR 0 8
66330: PPUSH
66331: LD_INT 25
66333: PUSH
66334: LD_INT 12
66336: PUSH
66337: EMPTY
66338: LIST
66339: LIST
66340: PPUSH
66341: CALL_OW 72
66345: NOT
66346: IFFALSE 66356
// control := control_manual ;
66348: LD_ADDR_VAR 0 4
66352: PUSH
66353: LD_INT 1
66355: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
66356: LD_ADDR_VAR 0 8
66360: PUSH
66361: LD_VAR 0 1
66365: PPUSH
66366: CALL 66053 0 1
66370: ST_TO_ADDR
// if tmp then
66371: LD_VAR 0 8
66375: IFFALSE 66418
// begin for i in tmp do
66377: LD_ADDR_VAR 0 7
66381: PUSH
66382: LD_VAR 0 8
66386: PUSH
66387: FOR_IN
66388: IFFALSE 66416
// if i [ 1 ] = b_ext_radar then
66390: LD_VAR 0 7
66394: PUSH
66395: LD_INT 1
66397: ARRAY
66398: PUSH
66399: LD_INT 20
66401: EQUAL
66402: IFFALSE 66414
// begin control := control_remote ;
66404: LD_ADDR_VAR 0 4
66408: PUSH
66409: LD_INT 2
66411: ST_TO_ADDR
// break ;
66412: GO 66416
// end ;
66414: GO 66387
66416: POP
66417: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
66418: LD_VAR 0 1
66422: PPUSH
66423: LD_VAR 0 2
66427: PPUSH
66428: LD_VAR 0 3
66432: PPUSH
66433: LD_VAR 0 4
66437: PPUSH
66438: LD_VAR 0 5
66442: PPUSH
66443: CALL_OW 448
66447: IFFALSE 66482
// begin result := [ chassis , engine , control , weapon ] ;
66449: LD_ADDR_VAR 0 6
66453: PUSH
66454: LD_VAR 0 2
66458: PUSH
66459: LD_VAR 0 3
66463: PUSH
66464: LD_VAR 0 4
66468: PUSH
66469: LD_VAR 0 5
66473: PUSH
66474: EMPTY
66475: LIST
66476: LIST
66477: LIST
66478: LIST
66479: ST_TO_ADDR
// exit ;
66480: GO 66826
// end ; _chassis := AvailableChassisList ( factory ) ;
66482: LD_ADDR_VAR 0 9
66486: PUSH
66487: LD_VAR 0 1
66491: PPUSH
66492: CALL_OW 475
66496: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
66497: LD_ADDR_VAR 0 11
66501: PUSH
66502: LD_VAR 0 1
66506: PPUSH
66507: CALL_OW 476
66511: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
66512: LD_ADDR_VAR 0 12
66516: PUSH
66517: LD_VAR 0 1
66521: PPUSH
66522: CALL_OW 477
66526: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
66527: LD_ADDR_VAR 0 10
66531: PUSH
66532: LD_VAR 0 1
66536: PPUSH
66537: CALL_OW 478
66541: ST_TO_ADDR
// if not chassis in _chassis then
66542: LD_VAR 0 2
66546: PUSH
66547: LD_VAR 0 9
66551: IN
66552: NOT
66553: IFFALSE 66579
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
66555: LD_ADDR_VAR 0 2
66559: PUSH
66560: LD_VAR 0 9
66564: PUSH
66565: LD_INT 1
66567: PPUSH
66568: LD_VAR 0 9
66572: PPUSH
66573: CALL_OW 12
66577: ARRAY
66578: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
66579: LD_VAR 0 2
66583: PPUSH
66584: LD_VAR 0 3
66588: PPUSH
66589: CALL 66831 0 2
66593: NOT
66594: IFFALSE 66653
// repeat engine := _engine [ 1 ] ;
66596: LD_ADDR_VAR 0 3
66600: PUSH
66601: LD_VAR 0 11
66605: PUSH
66606: LD_INT 1
66608: ARRAY
66609: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
66610: LD_ADDR_VAR 0 11
66614: PUSH
66615: LD_VAR 0 11
66619: PPUSH
66620: LD_INT 1
66622: PPUSH
66623: CALL_OW 3
66627: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
66628: LD_VAR 0 2
66632: PPUSH
66633: LD_VAR 0 3
66637: PPUSH
66638: CALL 66831 0 2
66642: PUSH
66643: LD_VAR 0 11
66647: PUSH
66648: EMPTY
66649: EQUAL
66650: OR
66651: IFFALSE 66596
// if not control in _control then
66653: LD_VAR 0 4
66657: PUSH
66658: LD_VAR 0 12
66662: IN
66663: NOT
66664: IFFALSE 66690
// control := _control [ rand ( 1 , _control ) ] ;
66666: LD_ADDR_VAR 0 4
66670: PUSH
66671: LD_VAR 0 12
66675: PUSH
66676: LD_INT 1
66678: PPUSH
66679: LD_VAR 0 12
66683: PPUSH
66684: CALL_OW 12
66688: ARRAY
66689: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
66690: LD_VAR 0 2
66694: PPUSH
66695: LD_VAR 0 5
66699: PPUSH
66700: CALL 67051 0 2
66704: NOT
66705: IFFALSE 66764
// repeat weapon := _weapon [ 1 ] ;
66707: LD_ADDR_VAR 0 5
66711: PUSH
66712: LD_VAR 0 10
66716: PUSH
66717: LD_INT 1
66719: ARRAY
66720: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
66721: LD_ADDR_VAR 0 10
66725: PUSH
66726: LD_VAR 0 10
66730: PPUSH
66731: LD_INT 1
66733: PPUSH
66734: CALL_OW 3
66738: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
66739: LD_VAR 0 2
66743: PPUSH
66744: LD_VAR 0 5
66748: PPUSH
66749: CALL 67051 0 2
66753: PUSH
66754: LD_VAR 0 10
66758: PUSH
66759: EMPTY
66760: EQUAL
66761: OR
66762: IFFALSE 66707
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
66764: LD_VAR 0 1
66768: PPUSH
66769: LD_VAR 0 2
66773: PPUSH
66774: LD_VAR 0 3
66778: PPUSH
66779: LD_VAR 0 4
66783: PPUSH
66784: LD_VAR 0 5
66788: PPUSH
66789: CALL_OW 448
66793: IFFALSE 66826
// result := [ chassis , engine , control , weapon ] ;
66795: LD_ADDR_VAR 0 6
66799: PUSH
66800: LD_VAR 0 2
66804: PUSH
66805: LD_VAR 0 3
66809: PUSH
66810: LD_VAR 0 4
66814: PUSH
66815: LD_VAR 0 5
66819: PUSH
66820: EMPTY
66821: LIST
66822: LIST
66823: LIST
66824: LIST
66825: ST_TO_ADDR
// end ;
66826: LD_VAR 0 6
66830: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
66831: LD_INT 0
66833: PPUSH
// if not chassis or not engine then
66834: LD_VAR 0 1
66838: NOT
66839: PUSH
66840: LD_VAR 0 2
66844: NOT
66845: OR
66846: IFFALSE 66850
// exit ;
66848: GO 67046
// case engine of engine_solar :
66850: LD_VAR 0 2
66854: PUSH
66855: LD_INT 2
66857: DOUBLE
66858: EQUAL
66859: IFTRUE 66863
66861: GO 66901
66863: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
66864: LD_ADDR_VAR 0 3
66868: PUSH
66869: LD_INT 11
66871: PUSH
66872: LD_INT 12
66874: PUSH
66875: LD_INT 13
66877: PUSH
66878: LD_INT 14
66880: PUSH
66881: LD_INT 1
66883: PUSH
66884: LD_INT 2
66886: PUSH
66887: LD_INT 3
66889: PUSH
66890: EMPTY
66891: LIST
66892: LIST
66893: LIST
66894: LIST
66895: LIST
66896: LIST
66897: LIST
66898: ST_TO_ADDR
66899: GO 67030
66901: LD_INT 1
66903: DOUBLE
66904: EQUAL
66905: IFTRUE 66909
66907: GO 66971
66909: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
66910: LD_ADDR_VAR 0 3
66914: PUSH
66915: LD_INT 11
66917: PUSH
66918: LD_INT 12
66920: PUSH
66921: LD_INT 13
66923: PUSH
66924: LD_INT 14
66926: PUSH
66927: LD_INT 1
66929: PUSH
66930: LD_INT 2
66932: PUSH
66933: LD_INT 3
66935: PUSH
66936: LD_INT 4
66938: PUSH
66939: LD_INT 5
66941: PUSH
66942: LD_INT 21
66944: PUSH
66945: LD_INT 23
66947: PUSH
66948: LD_INT 22
66950: PUSH
66951: LD_INT 24
66953: PUSH
66954: EMPTY
66955: LIST
66956: LIST
66957: LIST
66958: LIST
66959: LIST
66960: LIST
66961: LIST
66962: LIST
66963: LIST
66964: LIST
66965: LIST
66966: LIST
66967: LIST
66968: ST_TO_ADDR
66969: GO 67030
66971: LD_INT 3
66973: DOUBLE
66974: EQUAL
66975: IFTRUE 66979
66977: GO 67029
66979: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
66980: LD_ADDR_VAR 0 3
66984: PUSH
66985: LD_INT 13
66987: PUSH
66988: LD_INT 14
66990: PUSH
66991: LD_INT 2
66993: PUSH
66994: LD_INT 3
66996: PUSH
66997: LD_INT 4
66999: PUSH
67000: LD_INT 5
67002: PUSH
67003: LD_INT 21
67005: PUSH
67006: LD_INT 22
67008: PUSH
67009: LD_INT 23
67011: PUSH
67012: LD_INT 24
67014: PUSH
67015: EMPTY
67016: LIST
67017: LIST
67018: LIST
67019: LIST
67020: LIST
67021: LIST
67022: LIST
67023: LIST
67024: LIST
67025: LIST
67026: ST_TO_ADDR
67027: GO 67030
67029: POP
// result := ( chassis in result ) ;
67030: LD_ADDR_VAR 0 3
67034: PUSH
67035: LD_VAR 0 1
67039: PUSH
67040: LD_VAR 0 3
67044: IN
67045: ST_TO_ADDR
// end ;
67046: LD_VAR 0 3
67050: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
67051: LD_INT 0
67053: PPUSH
// if not chassis or not weapon then
67054: LD_VAR 0 1
67058: NOT
67059: PUSH
67060: LD_VAR 0 2
67064: NOT
67065: OR
67066: IFFALSE 67070
// exit ;
67068: GO 68096
// case weapon of us_machine_gun :
67070: LD_VAR 0 2
67074: PUSH
67075: LD_INT 2
67077: DOUBLE
67078: EQUAL
67079: IFTRUE 67083
67081: GO 67113
67083: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
67084: LD_ADDR_VAR 0 3
67088: PUSH
67089: LD_INT 1
67091: PUSH
67092: LD_INT 2
67094: PUSH
67095: LD_INT 3
67097: PUSH
67098: LD_INT 4
67100: PUSH
67101: LD_INT 5
67103: PUSH
67104: EMPTY
67105: LIST
67106: LIST
67107: LIST
67108: LIST
67109: LIST
67110: ST_TO_ADDR
67111: GO 68080
67113: LD_INT 3
67115: DOUBLE
67116: EQUAL
67117: IFTRUE 67121
67119: GO 67151
67121: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
67122: LD_ADDR_VAR 0 3
67126: PUSH
67127: LD_INT 1
67129: PUSH
67130: LD_INT 2
67132: PUSH
67133: LD_INT 3
67135: PUSH
67136: LD_INT 4
67138: PUSH
67139: LD_INT 5
67141: PUSH
67142: EMPTY
67143: LIST
67144: LIST
67145: LIST
67146: LIST
67147: LIST
67148: ST_TO_ADDR
67149: GO 68080
67151: LD_INT 11
67153: DOUBLE
67154: EQUAL
67155: IFTRUE 67159
67157: GO 67189
67159: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
67160: LD_ADDR_VAR 0 3
67164: PUSH
67165: LD_INT 1
67167: PUSH
67168: LD_INT 2
67170: PUSH
67171: LD_INT 3
67173: PUSH
67174: LD_INT 4
67176: PUSH
67177: LD_INT 5
67179: PUSH
67180: EMPTY
67181: LIST
67182: LIST
67183: LIST
67184: LIST
67185: LIST
67186: ST_TO_ADDR
67187: GO 68080
67189: LD_INT 4
67191: DOUBLE
67192: EQUAL
67193: IFTRUE 67197
67195: GO 67223
67197: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
67198: LD_ADDR_VAR 0 3
67202: PUSH
67203: LD_INT 2
67205: PUSH
67206: LD_INT 3
67208: PUSH
67209: LD_INT 4
67211: PUSH
67212: LD_INT 5
67214: PUSH
67215: EMPTY
67216: LIST
67217: LIST
67218: LIST
67219: LIST
67220: ST_TO_ADDR
67221: GO 68080
67223: LD_INT 5
67225: DOUBLE
67226: EQUAL
67227: IFTRUE 67231
67229: GO 67257
67231: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
67232: LD_ADDR_VAR 0 3
67236: PUSH
67237: LD_INT 2
67239: PUSH
67240: LD_INT 3
67242: PUSH
67243: LD_INT 4
67245: PUSH
67246: LD_INT 5
67248: PUSH
67249: EMPTY
67250: LIST
67251: LIST
67252: LIST
67253: LIST
67254: ST_TO_ADDR
67255: GO 68080
67257: LD_INT 9
67259: DOUBLE
67260: EQUAL
67261: IFTRUE 67265
67263: GO 67291
67265: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
67266: LD_ADDR_VAR 0 3
67270: PUSH
67271: LD_INT 2
67273: PUSH
67274: LD_INT 3
67276: PUSH
67277: LD_INT 4
67279: PUSH
67280: LD_INT 5
67282: PUSH
67283: EMPTY
67284: LIST
67285: LIST
67286: LIST
67287: LIST
67288: ST_TO_ADDR
67289: GO 68080
67291: LD_INT 7
67293: DOUBLE
67294: EQUAL
67295: IFTRUE 67299
67297: GO 67325
67299: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
67300: LD_ADDR_VAR 0 3
67304: PUSH
67305: LD_INT 2
67307: PUSH
67308: LD_INT 3
67310: PUSH
67311: LD_INT 4
67313: PUSH
67314: LD_INT 5
67316: PUSH
67317: EMPTY
67318: LIST
67319: LIST
67320: LIST
67321: LIST
67322: ST_TO_ADDR
67323: GO 68080
67325: LD_INT 12
67327: DOUBLE
67328: EQUAL
67329: IFTRUE 67333
67331: GO 67359
67333: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
67334: LD_ADDR_VAR 0 3
67338: PUSH
67339: LD_INT 2
67341: PUSH
67342: LD_INT 3
67344: PUSH
67345: LD_INT 4
67347: PUSH
67348: LD_INT 5
67350: PUSH
67351: EMPTY
67352: LIST
67353: LIST
67354: LIST
67355: LIST
67356: ST_TO_ADDR
67357: GO 68080
67359: LD_INT 13
67361: DOUBLE
67362: EQUAL
67363: IFTRUE 67367
67365: GO 67393
67367: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
67368: LD_ADDR_VAR 0 3
67372: PUSH
67373: LD_INT 2
67375: PUSH
67376: LD_INT 3
67378: PUSH
67379: LD_INT 4
67381: PUSH
67382: LD_INT 5
67384: PUSH
67385: EMPTY
67386: LIST
67387: LIST
67388: LIST
67389: LIST
67390: ST_TO_ADDR
67391: GO 68080
67393: LD_INT 14
67395: DOUBLE
67396: EQUAL
67397: IFTRUE 67401
67399: GO 67419
67401: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
67402: LD_ADDR_VAR 0 3
67406: PUSH
67407: LD_INT 4
67409: PUSH
67410: LD_INT 5
67412: PUSH
67413: EMPTY
67414: LIST
67415: LIST
67416: ST_TO_ADDR
67417: GO 68080
67419: LD_INT 6
67421: DOUBLE
67422: EQUAL
67423: IFTRUE 67427
67425: GO 67445
67427: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
67428: LD_ADDR_VAR 0 3
67432: PUSH
67433: LD_INT 4
67435: PUSH
67436: LD_INT 5
67438: PUSH
67439: EMPTY
67440: LIST
67441: LIST
67442: ST_TO_ADDR
67443: GO 68080
67445: LD_INT 10
67447: DOUBLE
67448: EQUAL
67449: IFTRUE 67453
67451: GO 67471
67453: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
67454: LD_ADDR_VAR 0 3
67458: PUSH
67459: LD_INT 4
67461: PUSH
67462: LD_INT 5
67464: PUSH
67465: EMPTY
67466: LIST
67467: LIST
67468: ST_TO_ADDR
67469: GO 68080
67471: LD_INT 22
67473: DOUBLE
67474: EQUAL
67475: IFTRUE 67479
67477: GO 67505
67479: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
67480: LD_ADDR_VAR 0 3
67484: PUSH
67485: LD_INT 11
67487: PUSH
67488: LD_INT 12
67490: PUSH
67491: LD_INT 13
67493: PUSH
67494: LD_INT 14
67496: PUSH
67497: EMPTY
67498: LIST
67499: LIST
67500: LIST
67501: LIST
67502: ST_TO_ADDR
67503: GO 68080
67505: LD_INT 23
67507: DOUBLE
67508: EQUAL
67509: IFTRUE 67513
67511: GO 67539
67513: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
67514: LD_ADDR_VAR 0 3
67518: PUSH
67519: LD_INT 11
67521: PUSH
67522: LD_INT 12
67524: PUSH
67525: LD_INT 13
67527: PUSH
67528: LD_INT 14
67530: PUSH
67531: EMPTY
67532: LIST
67533: LIST
67534: LIST
67535: LIST
67536: ST_TO_ADDR
67537: GO 68080
67539: LD_INT 24
67541: DOUBLE
67542: EQUAL
67543: IFTRUE 67547
67545: GO 67573
67547: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
67548: LD_ADDR_VAR 0 3
67552: PUSH
67553: LD_INT 11
67555: PUSH
67556: LD_INT 12
67558: PUSH
67559: LD_INT 13
67561: PUSH
67562: LD_INT 14
67564: PUSH
67565: EMPTY
67566: LIST
67567: LIST
67568: LIST
67569: LIST
67570: ST_TO_ADDR
67571: GO 68080
67573: LD_INT 30
67575: DOUBLE
67576: EQUAL
67577: IFTRUE 67581
67579: GO 67607
67581: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
67582: LD_ADDR_VAR 0 3
67586: PUSH
67587: LD_INT 11
67589: PUSH
67590: LD_INT 12
67592: PUSH
67593: LD_INT 13
67595: PUSH
67596: LD_INT 14
67598: PUSH
67599: EMPTY
67600: LIST
67601: LIST
67602: LIST
67603: LIST
67604: ST_TO_ADDR
67605: GO 68080
67607: LD_INT 25
67609: DOUBLE
67610: EQUAL
67611: IFTRUE 67615
67613: GO 67633
67615: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
67616: LD_ADDR_VAR 0 3
67620: PUSH
67621: LD_INT 13
67623: PUSH
67624: LD_INT 14
67626: PUSH
67627: EMPTY
67628: LIST
67629: LIST
67630: ST_TO_ADDR
67631: GO 68080
67633: LD_INT 27
67635: DOUBLE
67636: EQUAL
67637: IFTRUE 67641
67639: GO 67659
67641: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
67642: LD_ADDR_VAR 0 3
67646: PUSH
67647: LD_INT 13
67649: PUSH
67650: LD_INT 14
67652: PUSH
67653: EMPTY
67654: LIST
67655: LIST
67656: ST_TO_ADDR
67657: GO 68080
67659: LD_INT 28
67661: DOUBLE
67662: EQUAL
67663: IFTRUE 67667
67665: GO 67685
67667: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
67668: LD_ADDR_VAR 0 3
67672: PUSH
67673: LD_INT 13
67675: PUSH
67676: LD_INT 14
67678: PUSH
67679: EMPTY
67680: LIST
67681: LIST
67682: ST_TO_ADDR
67683: GO 68080
67685: LD_INT 29
67687: DOUBLE
67688: EQUAL
67689: IFTRUE 67693
67691: GO 67711
67693: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
67694: LD_ADDR_VAR 0 3
67698: PUSH
67699: LD_INT 13
67701: PUSH
67702: LD_INT 14
67704: PUSH
67705: EMPTY
67706: LIST
67707: LIST
67708: ST_TO_ADDR
67709: GO 68080
67711: LD_INT 31
67713: DOUBLE
67714: EQUAL
67715: IFTRUE 67719
67717: GO 67737
67719: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
67720: LD_ADDR_VAR 0 3
67724: PUSH
67725: LD_INT 13
67727: PUSH
67728: LD_INT 14
67730: PUSH
67731: EMPTY
67732: LIST
67733: LIST
67734: ST_TO_ADDR
67735: GO 68080
67737: LD_INT 26
67739: DOUBLE
67740: EQUAL
67741: IFTRUE 67745
67743: GO 67763
67745: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
67746: LD_ADDR_VAR 0 3
67750: PUSH
67751: LD_INT 13
67753: PUSH
67754: LD_INT 14
67756: PUSH
67757: EMPTY
67758: LIST
67759: LIST
67760: ST_TO_ADDR
67761: GO 68080
67763: LD_INT 42
67765: DOUBLE
67766: EQUAL
67767: IFTRUE 67771
67769: GO 67797
67771: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
67772: LD_ADDR_VAR 0 3
67776: PUSH
67777: LD_INT 21
67779: PUSH
67780: LD_INT 22
67782: PUSH
67783: LD_INT 23
67785: PUSH
67786: LD_INT 24
67788: PUSH
67789: EMPTY
67790: LIST
67791: LIST
67792: LIST
67793: LIST
67794: ST_TO_ADDR
67795: GO 68080
67797: LD_INT 43
67799: DOUBLE
67800: EQUAL
67801: IFTRUE 67805
67803: GO 67831
67805: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
67806: LD_ADDR_VAR 0 3
67810: PUSH
67811: LD_INT 21
67813: PUSH
67814: LD_INT 22
67816: PUSH
67817: LD_INT 23
67819: PUSH
67820: LD_INT 24
67822: PUSH
67823: EMPTY
67824: LIST
67825: LIST
67826: LIST
67827: LIST
67828: ST_TO_ADDR
67829: GO 68080
67831: LD_INT 44
67833: DOUBLE
67834: EQUAL
67835: IFTRUE 67839
67837: GO 67865
67839: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
67840: LD_ADDR_VAR 0 3
67844: PUSH
67845: LD_INT 21
67847: PUSH
67848: LD_INT 22
67850: PUSH
67851: LD_INT 23
67853: PUSH
67854: LD_INT 24
67856: PUSH
67857: EMPTY
67858: LIST
67859: LIST
67860: LIST
67861: LIST
67862: ST_TO_ADDR
67863: GO 68080
67865: LD_INT 45
67867: DOUBLE
67868: EQUAL
67869: IFTRUE 67873
67871: GO 67899
67873: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
67874: LD_ADDR_VAR 0 3
67878: PUSH
67879: LD_INT 21
67881: PUSH
67882: LD_INT 22
67884: PUSH
67885: LD_INT 23
67887: PUSH
67888: LD_INT 24
67890: PUSH
67891: EMPTY
67892: LIST
67893: LIST
67894: LIST
67895: LIST
67896: ST_TO_ADDR
67897: GO 68080
67899: LD_INT 49
67901: DOUBLE
67902: EQUAL
67903: IFTRUE 67907
67905: GO 67933
67907: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
67908: LD_ADDR_VAR 0 3
67912: PUSH
67913: LD_INT 21
67915: PUSH
67916: LD_INT 22
67918: PUSH
67919: LD_INT 23
67921: PUSH
67922: LD_INT 24
67924: PUSH
67925: EMPTY
67926: LIST
67927: LIST
67928: LIST
67929: LIST
67930: ST_TO_ADDR
67931: GO 68080
67933: LD_INT 51
67935: DOUBLE
67936: EQUAL
67937: IFTRUE 67941
67939: GO 67967
67941: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
67942: LD_ADDR_VAR 0 3
67946: PUSH
67947: LD_INT 21
67949: PUSH
67950: LD_INT 22
67952: PUSH
67953: LD_INT 23
67955: PUSH
67956: LD_INT 24
67958: PUSH
67959: EMPTY
67960: LIST
67961: LIST
67962: LIST
67963: LIST
67964: ST_TO_ADDR
67965: GO 68080
67967: LD_INT 52
67969: DOUBLE
67970: EQUAL
67971: IFTRUE 67975
67973: GO 68001
67975: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
67976: LD_ADDR_VAR 0 3
67980: PUSH
67981: LD_INT 21
67983: PUSH
67984: LD_INT 22
67986: PUSH
67987: LD_INT 23
67989: PUSH
67990: LD_INT 24
67992: PUSH
67993: EMPTY
67994: LIST
67995: LIST
67996: LIST
67997: LIST
67998: ST_TO_ADDR
67999: GO 68080
68001: LD_INT 53
68003: DOUBLE
68004: EQUAL
68005: IFTRUE 68009
68007: GO 68027
68009: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
68010: LD_ADDR_VAR 0 3
68014: PUSH
68015: LD_INT 23
68017: PUSH
68018: LD_INT 24
68020: PUSH
68021: EMPTY
68022: LIST
68023: LIST
68024: ST_TO_ADDR
68025: GO 68080
68027: LD_INT 46
68029: DOUBLE
68030: EQUAL
68031: IFTRUE 68035
68033: GO 68053
68035: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
68036: LD_ADDR_VAR 0 3
68040: PUSH
68041: LD_INT 23
68043: PUSH
68044: LD_INT 24
68046: PUSH
68047: EMPTY
68048: LIST
68049: LIST
68050: ST_TO_ADDR
68051: GO 68080
68053: LD_INT 47
68055: DOUBLE
68056: EQUAL
68057: IFTRUE 68061
68059: GO 68079
68061: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
68062: LD_ADDR_VAR 0 3
68066: PUSH
68067: LD_INT 23
68069: PUSH
68070: LD_INT 24
68072: PUSH
68073: EMPTY
68074: LIST
68075: LIST
68076: ST_TO_ADDR
68077: GO 68080
68079: POP
// result := ( chassis in result ) ;
68080: LD_ADDR_VAR 0 3
68084: PUSH
68085: LD_VAR 0 1
68089: PUSH
68090: LD_VAR 0 3
68094: IN
68095: ST_TO_ADDR
// end ;
68096: LD_VAR 0 3
68100: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
68101: LD_INT 0
68103: PPUSH
68104: PPUSH
68105: PPUSH
68106: PPUSH
68107: PPUSH
68108: PPUSH
68109: PPUSH
// result := array ;
68110: LD_ADDR_VAR 0 5
68114: PUSH
68115: LD_VAR 0 1
68119: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
68120: LD_VAR 0 1
68124: NOT
68125: PUSH
68126: LD_VAR 0 2
68130: NOT
68131: OR
68132: PUSH
68133: LD_VAR 0 3
68137: NOT
68138: OR
68139: PUSH
68140: LD_VAR 0 2
68144: PUSH
68145: LD_VAR 0 1
68149: GREATER
68150: OR
68151: PUSH
68152: LD_VAR 0 3
68156: PUSH
68157: LD_VAR 0 1
68161: GREATER
68162: OR
68163: IFFALSE 68167
// exit ;
68165: GO 68463
// if direction then
68167: LD_VAR 0 4
68171: IFFALSE 68235
// begin d := 1 ;
68173: LD_ADDR_VAR 0 9
68177: PUSH
68178: LD_INT 1
68180: ST_TO_ADDR
// if i_from > i_to then
68181: LD_VAR 0 2
68185: PUSH
68186: LD_VAR 0 3
68190: GREATER
68191: IFFALSE 68217
// length := ( array - i_from ) + i_to else
68193: LD_ADDR_VAR 0 11
68197: PUSH
68198: LD_VAR 0 1
68202: PUSH
68203: LD_VAR 0 2
68207: MINUS
68208: PUSH
68209: LD_VAR 0 3
68213: PLUS
68214: ST_TO_ADDR
68215: GO 68233
// length := i_to - i_from ;
68217: LD_ADDR_VAR 0 11
68221: PUSH
68222: LD_VAR 0 3
68226: PUSH
68227: LD_VAR 0 2
68231: MINUS
68232: ST_TO_ADDR
// end else
68233: GO 68296
// begin d := - 1 ;
68235: LD_ADDR_VAR 0 9
68239: PUSH
68240: LD_INT 1
68242: NEG
68243: ST_TO_ADDR
// if i_from > i_to then
68244: LD_VAR 0 2
68248: PUSH
68249: LD_VAR 0 3
68253: GREATER
68254: IFFALSE 68274
// length := i_from - i_to else
68256: LD_ADDR_VAR 0 11
68260: PUSH
68261: LD_VAR 0 2
68265: PUSH
68266: LD_VAR 0 3
68270: MINUS
68271: ST_TO_ADDR
68272: GO 68296
// length := ( array - i_to ) + i_from ;
68274: LD_ADDR_VAR 0 11
68278: PUSH
68279: LD_VAR 0 1
68283: PUSH
68284: LD_VAR 0 3
68288: MINUS
68289: PUSH
68290: LD_VAR 0 2
68294: PLUS
68295: ST_TO_ADDR
// end ; if not length then
68296: LD_VAR 0 11
68300: NOT
68301: IFFALSE 68305
// exit ;
68303: GO 68463
// tmp := array ;
68305: LD_ADDR_VAR 0 10
68309: PUSH
68310: LD_VAR 0 1
68314: ST_TO_ADDR
// for i = 1 to length do
68315: LD_ADDR_VAR 0 6
68319: PUSH
68320: DOUBLE
68321: LD_INT 1
68323: DEC
68324: ST_TO_ADDR
68325: LD_VAR 0 11
68329: PUSH
68330: FOR_TO
68331: IFFALSE 68451
// begin for j = 1 to array do
68333: LD_ADDR_VAR 0 7
68337: PUSH
68338: DOUBLE
68339: LD_INT 1
68341: DEC
68342: ST_TO_ADDR
68343: LD_VAR 0 1
68347: PUSH
68348: FOR_TO
68349: IFFALSE 68437
// begin k := j + d ;
68351: LD_ADDR_VAR 0 8
68355: PUSH
68356: LD_VAR 0 7
68360: PUSH
68361: LD_VAR 0 9
68365: PLUS
68366: ST_TO_ADDR
// if k > array then
68367: LD_VAR 0 8
68371: PUSH
68372: LD_VAR 0 1
68376: GREATER
68377: IFFALSE 68387
// k := 1 ;
68379: LD_ADDR_VAR 0 8
68383: PUSH
68384: LD_INT 1
68386: ST_TO_ADDR
// if not k then
68387: LD_VAR 0 8
68391: NOT
68392: IFFALSE 68404
// k := array ;
68394: LD_ADDR_VAR 0 8
68398: PUSH
68399: LD_VAR 0 1
68403: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
68404: LD_ADDR_VAR 0 10
68408: PUSH
68409: LD_VAR 0 10
68413: PPUSH
68414: LD_VAR 0 8
68418: PPUSH
68419: LD_VAR 0 1
68423: PUSH
68424: LD_VAR 0 7
68428: ARRAY
68429: PPUSH
68430: CALL_OW 1
68434: ST_TO_ADDR
// end ;
68435: GO 68348
68437: POP
68438: POP
// array := tmp ;
68439: LD_ADDR_VAR 0 1
68443: PUSH
68444: LD_VAR 0 10
68448: ST_TO_ADDR
// end ;
68449: GO 68330
68451: POP
68452: POP
// result := array ;
68453: LD_ADDR_VAR 0 5
68457: PUSH
68458: LD_VAR 0 1
68462: ST_TO_ADDR
// end ;
68463: LD_VAR 0 5
68467: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
68468: LD_INT 0
68470: PPUSH
68471: PPUSH
// result := 0 ;
68472: LD_ADDR_VAR 0 3
68476: PUSH
68477: LD_INT 0
68479: ST_TO_ADDR
// if not array or not value in array then
68480: LD_VAR 0 1
68484: NOT
68485: PUSH
68486: LD_VAR 0 2
68490: PUSH
68491: LD_VAR 0 1
68495: IN
68496: NOT
68497: OR
68498: IFFALSE 68502
// exit ;
68500: GO 68556
// for i = 1 to array do
68502: LD_ADDR_VAR 0 4
68506: PUSH
68507: DOUBLE
68508: LD_INT 1
68510: DEC
68511: ST_TO_ADDR
68512: LD_VAR 0 1
68516: PUSH
68517: FOR_TO
68518: IFFALSE 68554
// if value = array [ i ] then
68520: LD_VAR 0 2
68524: PUSH
68525: LD_VAR 0 1
68529: PUSH
68530: LD_VAR 0 4
68534: ARRAY
68535: EQUAL
68536: IFFALSE 68552
// begin result := i ;
68538: LD_ADDR_VAR 0 3
68542: PUSH
68543: LD_VAR 0 4
68547: ST_TO_ADDR
// exit ;
68548: POP
68549: POP
68550: GO 68556
// end ;
68552: GO 68517
68554: POP
68555: POP
// end ;
68556: LD_VAR 0 3
68560: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
68561: LD_INT 0
68563: PPUSH
// vc_chassis := chassis ;
68564: LD_ADDR_OWVAR 37
68568: PUSH
68569: LD_VAR 0 1
68573: ST_TO_ADDR
// vc_engine := engine ;
68574: LD_ADDR_OWVAR 39
68578: PUSH
68579: LD_VAR 0 2
68583: ST_TO_ADDR
// vc_control := control ;
68584: LD_ADDR_OWVAR 38
68588: PUSH
68589: LD_VAR 0 3
68593: ST_TO_ADDR
// vc_weapon := weapon ;
68594: LD_ADDR_OWVAR 40
68598: PUSH
68599: LD_VAR 0 4
68603: ST_TO_ADDR
// vc_fuel_battery := fuel ;
68604: LD_ADDR_OWVAR 41
68608: PUSH
68609: LD_VAR 0 5
68613: ST_TO_ADDR
// end ;
68614: LD_VAR 0 6
68618: RET
// export function WantPlant ( unit ) ; var task ; begin
68619: LD_INT 0
68621: PPUSH
68622: PPUSH
// result := false ;
68623: LD_ADDR_VAR 0 2
68627: PUSH
68628: LD_INT 0
68630: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
68631: LD_ADDR_VAR 0 3
68635: PUSH
68636: LD_VAR 0 1
68640: PPUSH
68641: CALL_OW 437
68645: ST_TO_ADDR
// if task then
68646: LD_VAR 0 3
68650: IFFALSE 68678
// if task [ 1 ] [ 1 ] = p then
68652: LD_VAR 0 3
68656: PUSH
68657: LD_INT 1
68659: ARRAY
68660: PUSH
68661: LD_INT 1
68663: ARRAY
68664: PUSH
68665: LD_STRING p
68667: EQUAL
68668: IFFALSE 68678
// result := true ;
68670: LD_ADDR_VAR 0 2
68674: PUSH
68675: LD_INT 1
68677: ST_TO_ADDR
// end ;
68678: LD_VAR 0 2
68682: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
68683: LD_INT 0
68685: PPUSH
68686: PPUSH
68687: PPUSH
68688: PPUSH
// if pos < 1 then
68689: LD_VAR 0 2
68693: PUSH
68694: LD_INT 1
68696: LESS
68697: IFFALSE 68701
// exit ;
68699: GO 69004
// if pos = 1 then
68701: LD_VAR 0 2
68705: PUSH
68706: LD_INT 1
68708: EQUAL
68709: IFFALSE 68742
// result := Replace ( arr , pos [ 1 ] , value ) else
68711: LD_ADDR_VAR 0 4
68715: PUSH
68716: LD_VAR 0 1
68720: PPUSH
68721: LD_VAR 0 2
68725: PUSH
68726: LD_INT 1
68728: ARRAY
68729: PPUSH
68730: LD_VAR 0 3
68734: PPUSH
68735: CALL_OW 1
68739: ST_TO_ADDR
68740: GO 69004
// begin tmp := arr ;
68742: LD_ADDR_VAR 0 6
68746: PUSH
68747: LD_VAR 0 1
68751: ST_TO_ADDR
// s_arr := [ tmp ] ;
68752: LD_ADDR_VAR 0 7
68756: PUSH
68757: LD_VAR 0 6
68761: PUSH
68762: EMPTY
68763: LIST
68764: ST_TO_ADDR
// for i = 1 to pos - 1 do
68765: LD_ADDR_VAR 0 5
68769: PUSH
68770: DOUBLE
68771: LD_INT 1
68773: DEC
68774: ST_TO_ADDR
68775: LD_VAR 0 2
68779: PUSH
68780: LD_INT 1
68782: MINUS
68783: PUSH
68784: FOR_TO
68785: IFFALSE 68830
// begin tmp := tmp [ pos [ i ] ] ;
68787: LD_ADDR_VAR 0 6
68791: PUSH
68792: LD_VAR 0 6
68796: PUSH
68797: LD_VAR 0 2
68801: PUSH
68802: LD_VAR 0 5
68806: ARRAY
68807: ARRAY
68808: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
68809: LD_ADDR_VAR 0 7
68813: PUSH
68814: LD_VAR 0 7
68818: PUSH
68819: LD_VAR 0 6
68823: PUSH
68824: EMPTY
68825: LIST
68826: ADD
68827: ST_TO_ADDR
// end ;
68828: GO 68784
68830: POP
68831: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
68832: LD_ADDR_VAR 0 6
68836: PUSH
68837: LD_VAR 0 6
68841: PPUSH
68842: LD_VAR 0 2
68846: PUSH
68847: LD_VAR 0 2
68851: ARRAY
68852: PPUSH
68853: LD_VAR 0 3
68857: PPUSH
68858: CALL_OW 1
68862: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
68863: LD_ADDR_VAR 0 7
68867: PUSH
68868: LD_VAR 0 7
68872: PPUSH
68873: LD_VAR 0 7
68877: PPUSH
68878: LD_VAR 0 6
68882: PPUSH
68883: CALL_OW 1
68887: ST_TO_ADDR
// for i = s_arr downto 2 do
68888: LD_ADDR_VAR 0 5
68892: PUSH
68893: DOUBLE
68894: LD_VAR 0 7
68898: INC
68899: ST_TO_ADDR
68900: LD_INT 2
68902: PUSH
68903: FOR_DOWNTO
68904: IFFALSE 68988
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
68906: LD_ADDR_VAR 0 6
68910: PUSH
68911: LD_VAR 0 7
68915: PUSH
68916: LD_VAR 0 5
68920: PUSH
68921: LD_INT 1
68923: MINUS
68924: ARRAY
68925: PPUSH
68926: LD_VAR 0 2
68930: PUSH
68931: LD_VAR 0 5
68935: PUSH
68936: LD_INT 1
68938: MINUS
68939: ARRAY
68940: PPUSH
68941: LD_VAR 0 7
68945: PUSH
68946: LD_VAR 0 5
68950: ARRAY
68951: PPUSH
68952: CALL_OW 1
68956: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
68957: LD_ADDR_VAR 0 7
68961: PUSH
68962: LD_VAR 0 7
68966: PPUSH
68967: LD_VAR 0 5
68971: PUSH
68972: LD_INT 1
68974: MINUS
68975: PPUSH
68976: LD_VAR 0 6
68980: PPUSH
68981: CALL_OW 1
68985: ST_TO_ADDR
// end ;
68986: GO 68903
68988: POP
68989: POP
// result := s_arr [ 1 ] ;
68990: LD_ADDR_VAR 0 4
68994: PUSH
68995: LD_VAR 0 7
68999: PUSH
69000: LD_INT 1
69002: ARRAY
69003: ST_TO_ADDR
// end ; end ;
69004: LD_VAR 0 4
69008: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
69009: LD_INT 0
69011: PPUSH
69012: PPUSH
// if not list then
69013: LD_VAR 0 1
69017: NOT
69018: IFFALSE 69022
// exit ;
69020: GO 69113
// i := list [ pos1 ] ;
69022: LD_ADDR_VAR 0 5
69026: PUSH
69027: LD_VAR 0 1
69031: PUSH
69032: LD_VAR 0 2
69036: ARRAY
69037: ST_TO_ADDR
// if not i then
69038: LD_VAR 0 5
69042: NOT
69043: IFFALSE 69047
// exit ;
69045: GO 69113
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
69047: LD_ADDR_VAR 0 1
69051: PUSH
69052: LD_VAR 0 1
69056: PPUSH
69057: LD_VAR 0 2
69061: PPUSH
69062: LD_VAR 0 1
69066: PUSH
69067: LD_VAR 0 3
69071: ARRAY
69072: PPUSH
69073: CALL_OW 1
69077: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
69078: LD_ADDR_VAR 0 1
69082: PUSH
69083: LD_VAR 0 1
69087: PPUSH
69088: LD_VAR 0 3
69092: PPUSH
69093: LD_VAR 0 5
69097: PPUSH
69098: CALL_OW 1
69102: ST_TO_ADDR
// result := list ;
69103: LD_ADDR_VAR 0 4
69107: PUSH
69108: LD_VAR 0 1
69112: ST_TO_ADDR
// end ;
69113: LD_VAR 0 4
69117: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
69118: LD_INT 0
69120: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
69121: LD_ADDR_VAR 0 5
69125: PUSH
69126: LD_VAR 0 1
69130: PPUSH
69131: CALL_OW 250
69135: PPUSH
69136: LD_VAR 0 1
69140: PPUSH
69141: CALL_OW 251
69145: PPUSH
69146: LD_VAR 0 2
69150: PPUSH
69151: LD_VAR 0 3
69155: PPUSH
69156: LD_VAR 0 4
69160: PPUSH
69161: CALL 69171 0 5
69165: ST_TO_ADDR
// end ;
69166: LD_VAR 0 5
69170: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
69171: LD_INT 0
69173: PPUSH
69174: PPUSH
69175: PPUSH
69176: PPUSH
// if not list then
69177: LD_VAR 0 3
69181: NOT
69182: IFFALSE 69186
// exit ;
69184: GO 69574
// result := [ ] ;
69186: LD_ADDR_VAR 0 6
69190: PUSH
69191: EMPTY
69192: ST_TO_ADDR
// for i in list do
69193: LD_ADDR_VAR 0 7
69197: PUSH
69198: LD_VAR 0 3
69202: PUSH
69203: FOR_IN
69204: IFFALSE 69406
// begin tmp := GetDistUnitXY ( i , x , y ) ;
69206: LD_ADDR_VAR 0 9
69210: PUSH
69211: LD_VAR 0 7
69215: PPUSH
69216: LD_VAR 0 1
69220: PPUSH
69221: LD_VAR 0 2
69225: PPUSH
69226: CALL_OW 297
69230: ST_TO_ADDR
// if not result then
69231: LD_VAR 0 6
69235: NOT
69236: IFFALSE 69262
// result := [ [ i , tmp ] ] else
69238: LD_ADDR_VAR 0 6
69242: PUSH
69243: LD_VAR 0 7
69247: PUSH
69248: LD_VAR 0 9
69252: PUSH
69253: EMPTY
69254: LIST
69255: LIST
69256: PUSH
69257: EMPTY
69258: LIST
69259: ST_TO_ADDR
69260: GO 69404
// begin if result [ result ] [ 2 ] < tmp then
69262: LD_VAR 0 6
69266: PUSH
69267: LD_VAR 0 6
69271: ARRAY
69272: PUSH
69273: LD_INT 2
69275: ARRAY
69276: PUSH
69277: LD_VAR 0 9
69281: LESS
69282: IFFALSE 69324
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
69284: LD_ADDR_VAR 0 6
69288: PUSH
69289: LD_VAR 0 6
69293: PPUSH
69294: LD_VAR 0 6
69298: PUSH
69299: LD_INT 1
69301: PLUS
69302: PPUSH
69303: LD_VAR 0 7
69307: PUSH
69308: LD_VAR 0 9
69312: PUSH
69313: EMPTY
69314: LIST
69315: LIST
69316: PPUSH
69317: CALL_OW 2
69321: ST_TO_ADDR
69322: GO 69404
// for j = 1 to result do
69324: LD_ADDR_VAR 0 8
69328: PUSH
69329: DOUBLE
69330: LD_INT 1
69332: DEC
69333: ST_TO_ADDR
69334: LD_VAR 0 6
69338: PUSH
69339: FOR_TO
69340: IFFALSE 69402
// begin if tmp < result [ j ] [ 2 ] then
69342: LD_VAR 0 9
69346: PUSH
69347: LD_VAR 0 6
69351: PUSH
69352: LD_VAR 0 8
69356: ARRAY
69357: PUSH
69358: LD_INT 2
69360: ARRAY
69361: LESS
69362: IFFALSE 69400
// begin result := Insert ( result , j , [ i , tmp ] ) ;
69364: LD_ADDR_VAR 0 6
69368: PUSH
69369: LD_VAR 0 6
69373: PPUSH
69374: LD_VAR 0 8
69378: PPUSH
69379: LD_VAR 0 7
69383: PUSH
69384: LD_VAR 0 9
69388: PUSH
69389: EMPTY
69390: LIST
69391: LIST
69392: PPUSH
69393: CALL_OW 2
69397: ST_TO_ADDR
// break ;
69398: GO 69402
// end ; end ;
69400: GO 69339
69402: POP
69403: POP
// end ; end ;
69404: GO 69203
69406: POP
69407: POP
// if result and not asc then
69408: LD_VAR 0 6
69412: PUSH
69413: LD_VAR 0 4
69417: NOT
69418: AND
69419: IFFALSE 69494
// begin tmp := result ;
69421: LD_ADDR_VAR 0 9
69425: PUSH
69426: LD_VAR 0 6
69430: ST_TO_ADDR
// for i = tmp downto 1 do
69431: LD_ADDR_VAR 0 7
69435: PUSH
69436: DOUBLE
69437: LD_VAR 0 9
69441: INC
69442: ST_TO_ADDR
69443: LD_INT 1
69445: PUSH
69446: FOR_DOWNTO
69447: IFFALSE 69492
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
69449: LD_ADDR_VAR 0 6
69453: PUSH
69454: LD_VAR 0 6
69458: PPUSH
69459: LD_VAR 0 9
69463: PUSH
69464: LD_VAR 0 7
69468: MINUS
69469: PUSH
69470: LD_INT 1
69472: PLUS
69473: PPUSH
69474: LD_VAR 0 9
69478: PUSH
69479: LD_VAR 0 7
69483: ARRAY
69484: PPUSH
69485: CALL_OW 1
69489: ST_TO_ADDR
69490: GO 69446
69492: POP
69493: POP
// end ; tmp := [ ] ;
69494: LD_ADDR_VAR 0 9
69498: PUSH
69499: EMPTY
69500: ST_TO_ADDR
// if mode then
69501: LD_VAR 0 5
69505: IFFALSE 69574
// begin for i = 1 to result do
69507: LD_ADDR_VAR 0 7
69511: PUSH
69512: DOUBLE
69513: LD_INT 1
69515: DEC
69516: ST_TO_ADDR
69517: LD_VAR 0 6
69521: PUSH
69522: FOR_TO
69523: IFFALSE 69562
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
69525: LD_ADDR_VAR 0 9
69529: PUSH
69530: LD_VAR 0 9
69534: PPUSH
69535: LD_VAR 0 7
69539: PPUSH
69540: LD_VAR 0 6
69544: PUSH
69545: LD_VAR 0 7
69549: ARRAY
69550: PUSH
69551: LD_INT 1
69553: ARRAY
69554: PPUSH
69555: CALL_OW 1
69559: ST_TO_ADDR
69560: GO 69522
69562: POP
69563: POP
// result := tmp ;
69564: LD_ADDR_VAR 0 6
69568: PUSH
69569: LD_VAR 0 9
69573: ST_TO_ADDR
// end ; end ;
69574: LD_VAR 0 6
69578: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
69579: LD_INT 0
69581: PPUSH
69582: PPUSH
69583: PPUSH
69584: PPUSH
69585: PPUSH
69586: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
69587: LD_ADDR_VAR 0 5
69591: PUSH
69592: LD_INT 0
69594: PUSH
69595: LD_INT 0
69597: PUSH
69598: LD_INT 0
69600: PUSH
69601: EMPTY
69602: PUSH
69603: EMPTY
69604: LIST
69605: LIST
69606: LIST
69607: LIST
69608: ST_TO_ADDR
// if not x or not y then
69609: LD_VAR 0 2
69613: NOT
69614: PUSH
69615: LD_VAR 0 3
69619: NOT
69620: OR
69621: IFFALSE 69625
// exit ;
69623: GO 71271
// if not range then
69625: LD_VAR 0 4
69629: NOT
69630: IFFALSE 69640
// range := 10 ;
69632: LD_ADDR_VAR 0 4
69636: PUSH
69637: LD_INT 10
69639: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69640: LD_ADDR_VAR 0 8
69644: PUSH
69645: LD_INT 81
69647: PUSH
69648: LD_VAR 0 1
69652: PUSH
69653: EMPTY
69654: LIST
69655: LIST
69656: PUSH
69657: LD_INT 92
69659: PUSH
69660: LD_VAR 0 2
69664: PUSH
69665: LD_VAR 0 3
69669: PUSH
69670: LD_VAR 0 4
69674: PUSH
69675: EMPTY
69676: LIST
69677: LIST
69678: LIST
69679: LIST
69680: PUSH
69681: LD_INT 3
69683: PUSH
69684: LD_INT 21
69686: PUSH
69687: LD_INT 3
69689: PUSH
69690: EMPTY
69691: LIST
69692: LIST
69693: PUSH
69694: EMPTY
69695: LIST
69696: LIST
69697: PUSH
69698: EMPTY
69699: LIST
69700: LIST
69701: LIST
69702: PPUSH
69703: CALL_OW 69
69707: ST_TO_ADDR
// if not tmp then
69708: LD_VAR 0 8
69712: NOT
69713: IFFALSE 69717
// exit ;
69715: GO 71271
// for i in tmp do
69717: LD_ADDR_VAR 0 6
69721: PUSH
69722: LD_VAR 0 8
69726: PUSH
69727: FOR_IN
69728: IFFALSE 71246
// begin points := [ 0 , 0 , 0 ] ;
69730: LD_ADDR_VAR 0 9
69734: PUSH
69735: LD_INT 0
69737: PUSH
69738: LD_INT 0
69740: PUSH
69741: LD_INT 0
69743: PUSH
69744: EMPTY
69745: LIST
69746: LIST
69747: LIST
69748: ST_TO_ADDR
// bpoints := 1 ;
69749: LD_ADDR_VAR 0 10
69753: PUSH
69754: LD_INT 1
69756: ST_TO_ADDR
// case GetType ( i ) of unit_human :
69757: LD_VAR 0 6
69761: PPUSH
69762: CALL_OW 247
69766: PUSH
69767: LD_INT 1
69769: DOUBLE
69770: EQUAL
69771: IFTRUE 69775
69773: GO 70353
69775: POP
// begin if GetClass ( i ) = 1 then
69776: LD_VAR 0 6
69780: PPUSH
69781: CALL_OW 257
69785: PUSH
69786: LD_INT 1
69788: EQUAL
69789: IFFALSE 69810
// points := [ 10 , 5 , 3 ] ;
69791: LD_ADDR_VAR 0 9
69795: PUSH
69796: LD_INT 10
69798: PUSH
69799: LD_INT 5
69801: PUSH
69802: LD_INT 3
69804: PUSH
69805: EMPTY
69806: LIST
69807: LIST
69808: LIST
69809: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
69810: LD_VAR 0 6
69814: PPUSH
69815: CALL_OW 257
69819: PUSH
69820: LD_INT 2
69822: PUSH
69823: LD_INT 3
69825: PUSH
69826: LD_INT 4
69828: PUSH
69829: EMPTY
69830: LIST
69831: LIST
69832: LIST
69833: IN
69834: IFFALSE 69855
// points := [ 3 , 2 , 1 ] ;
69836: LD_ADDR_VAR 0 9
69840: PUSH
69841: LD_INT 3
69843: PUSH
69844: LD_INT 2
69846: PUSH
69847: LD_INT 1
69849: PUSH
69850: EMPTY
69851: LIST
69852: LIST
69853: LIST
69854: ST_TO_ADDR
// if GetClass ( i ) = 5 then
69855: LD_VAR 0 6
69859: PPUSH
69860: CALL_OW 257
69864: PUSH
69865: LD_INT 5
69867: EQUAL
69868: IFFALSE 69889
// points := [ 130 , 5 , 2 ] ;
69870: LD_ADDR_VAR 0 9
69874: PUSH
69875: LD_INT 130
69877: PUSH
69878: LD_INT 5
69880: PUSH
69881: LD_INT 2
69883: PUSH
69884: EMPTY
69885: LIST
69886: LIST
69887: LIST
69888: ST_TO_ADDR
// if GetClass ( i ) = 8 then
69889: LD_VAR 0 6
69893: PPUSH
69894: CALL_OW 257
69898: PUSH
69899: LD_INT 8
69901: EQUAL
69902: IFFALSE 69923
// points := [ 35 , 35 , 30 ] ;
69904: LD_ADDR_VAR 0 9
69908: PUSH
69909: LD_INT 35
69911: PUSH
69912: LD_INT 35
69914: PUSH
69915: LD_INT 30
69917: PUSH
69918: EMPTY
69919: LIST
69920: LIST
69921: LIST
69922: ST_TO_ADDR
// if GetClass ( i ) = 9 then
69923: LD_VAR 0 6
69927: PPUSH
69928: CALL_OW 257
69932: PUSH
69933: LD_INT 9
69935: EQUAL
69936: IFFALSE 69957
// points := [ 20 , 55 , 40 ] ;
69938: LD_ADDR_VAR 0 9
69942: PUSH
69943: LD_INT 20
69945: PUSH
69946: LD_INT 55
69948: PUSH
69949: LD_INT 40
69951: PUSH
69952: EMPTY
69953: LIST
69954: LIST
69955: LIST
69956: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
69957: LD_VAR 0 6
69961: PPUSH
69962: CALL_OW 257
69966: PUSH
69967: LD_INT 12
69969: PUSH
69970: LD_INT 16
69972: PUSH
69973: EMPTY
69974: LIST
69975: LIST
69976: IN
69977: IFFALSE 69998
// points := [ 5 , 3 , 2 ] ;
69979: LD_ADDR_VAR 0 9
69983: PUSH
69984: LD_INT 5
69986: PUSH
69987: LD_INT 3
69989: PUSH
69990: LD_INT 2
69992: PUSH
69993: EMPTY
69994: LIST
69995: LIST
69996: LIST
69997: ST_TO_ADDR
// if GetClass ( i ) = 17 then
69998: LD_VAR 0 6
70002: PPUSH
70003: CALL_OW 257
70007: PUSH
70008: LD_INT 17
70010: EQUAL
70011: IFFALSE 70032
// points := [ 100 , 50 , 75 ] ;
70013: LD_ADDR_VAR 0 9
70017: PUSH
70018: LD_INT 100
70020: PUSH
70021: LD_INT 50
70023: PUSH
70024: LD_INT 75
70026: PUSH
70027: EMPTY
70028: LIST
70029: LIST
70030: LIST
70031: ST_TO_ADDR
// if GetClass ( i ) = 15 then
70032: LD_VAR 0 6
70036: PPUSH
70037: CALL_OW 257
70041: PUSH
70042: LD_INT 15
70044: EQUAL
70045: IFFALSE 70066
// points := [ 10 , 5 , 3 ] ;
70047: LD_ADDR_VAR 0 9
70051: PUSH
70052: LD_INT 10
70054: PUSH
70055: LD_INT 5
70057: PUSH
70058: LD_INT 3
70060: PUSH
70061: EMPTY
70062: LIST
70063: LIST
70064: LIST
70065: ST_TO_ADDR
// if GetClass ( i ) = 14 then
70066: LD_VAR 0 6
70070: PPUSH
70071: CALL_OW 257
70075: PUSH
70076: LD_INT 14
70078: EQUAL
70079: IFFALSE 70100
// points := [ 10 , 0 , 0 ] ;
70081: LD_ADDR_VAR 0 9
70085: PUSH
70086: LD_INT 10
70088: PUSH
70089: LD_INT 0
70091: PUSH
70092: LD_INT 0
70094: PUSH
70095: EMPTY
70096: LIST
70097: LIST
70098: LIST
70099: ST_TO_ADDR
// if GetClass ( i ) = 11 then
70100: LD_VAR 0 6
70104: PPUSH
70105: CALL_OW 257
70109: PUSH
70110: LD_INT 11
70112: EQUAL
70113: IFFALSE 70134
// points := [ 30 , 10 , 5 ] ;
70115: LD_ADDR_VAR 0 9
70119: PUSH
70120: LD_INT 30
70122: PUSH
70123: LD_INT 10
70125: PUSH
70126: LD_INT 5
70128: PUSH
70129: EMPTY
70130: LIST
70131: LIST
70132: LIST
70133: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
70134: LD_VAR 0 1
70138: PPUSH
70139: LD_INT 5
70141: PPUSH
70142: CALL_OW 321
70146: PUSH
70147: LD_INT 2
70149: EQUAL
70150: IFFALSE 70167
// bpoints := bpoints * 1.8 ;
70152: LD_ADDR_VAR 0 10
70156: PUSH
70157: LD_VAR 0 10
70161: PUSH
70162: LD_REAL  1.80000000000000E+0000
70165: MUL
70166: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
70167: LD_VAR 0 6
70171: PPUSH
70172: CALL_OW 257
70176: PUSH
70177: LD_INT 1
70179: PUSH
70180: LD_INT 2
70182: PUSH
70183: LD_INT 3
70185: PUSH
70186: LD_INT 4
70188: PUSH
70189: EMPTY
70190: LIST
70191: LIST
70192: LIST
70193: LIST
70194: IN
70195: PUSH
70196: LD_VAR 0 1
70200: PPUSH
70201: LD_INT 51
70203: PPUSH
70204: CALL_OW 321
70208: PUSH
70209: LD_INT 2
70211: EQUAL
70212: AND
70213: IFFALSE 70230
// bpoints := bpoints * 1.2 ;
70215: LD_ADDR_VAR 0 10
70219: PUSH
70220: LD_VAR 0 10
70224: PUSH
70225: LD_REAL  1.20000000000000E+0000
70228: MUL
70229: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
70230: LD_VAR 0 6
70234: PPUSH
70235: CALL_OW 257
70239: PUSH
70240: LD_INT 5
70242: PUSH
70243: LD_INT 7
70245: PUSH
70246: LD_INT 9
70248: PUSH
70249: EMPTY
70250: LIST
70251: LIST
70252: LIST
70253: IN
70254: PUSH
70255: LD_VAR 0 1
70259: PPUSH
70260: LD_INT 52
70262: PPUSH
70263: CALL_OW 321
70267: PUSH
70268: LD_INT 2
70270: EQUAL
70271: AND
70272: IFFALSE 70289
// bpoints := bpoints * 1.5 ;
70274: LD_ADDR_VAR 0 10
70278: PUSH
70279: LD_VAR 0 10
70283: PUSH
70284: LD_REAL  1.50000000000000E+0000
70287: MUL
70288: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
70289: LD_VAR 0 1
70293: PPUSH
70294: LD_INT 66
70296: PPUSH
70297: CALL_OW 321
70301: PUSH
70302: LD_INT 2
70304: EQUAL
70305: IFFALSE 70322
// bpoints := bpoints * 1.1 ;
70307: LD_ADDR_VAR 0 10
70311: PUSH
70312: LD_VAR 0 10
70316: PUSH
70317: LD_REAL  1.10000000000000E+0000
70320: MUL
70321: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
70322: LD_ADDR_VAR 0 10
70326: PUSH
70327: LD_VAR 0 10
70331: PUSH
70332: LD_VAR 0 6
70336: PPUSH
70337: LD_INT 1
70339: PPUSH
70340: CALL_OW 259
70344: PUSH
70345: LD_REAL  1.15000000000000E+0000
70348: MUL
70349: MUL
70350: ST_TO_ADDR
// end ; unit_vehicle :
70351: GO 71175
70353: LD_INT 2
70355: DOUBLE
70356: EQUAL
70357: IFTRUE 70361
70359: GO 71163
70361: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
70362: LD_VAR 0 6
70366: PPUSH
70367: CALL_OW 264
70371: PUSH
70372: LD_INT 2
70374: PUSH
70375: LD_INT 42
70377: PUSH
70378: LD_INT 24
70380: PUSH
70381: EMPTY
70382: LIST
70383: LIST
70384: LIST
70385: IN
70386: IFFALSE 70407
// points := [ 25 , 5 , 3 ] ;
70388: LD_ADDR_VAR 0 9
70392: PUSH
70393: LD_INT 25
70395: PUSH
70396: LD_INT 5
70398: PUSH
70399: LD_INT 3
70401: PUSH
70402: EMPTY
70403: LIST
70404: LIST
70405: LIST
70406: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
70407: LD_VAR 0 6
70411: PPUSH
70412: CALL_OW 264
70416: PUSH
70417: LD_INT 4
70419: PUSH
70420: LD_INT 43
70422: PUSH
70423: LD_INT 25
70425: PUSH
70426: EMPTY
70427: LIST
70428: LIST
70429: LIST
70430: IN
70431: IFFALSE 70452
// points := [ 40 , 15 , 5 ] ;
70433: LD_ADDR_VAR 0 9
70437: PUSH
70438: LD_INT 40
70440: PUSH
70441: LD_INT 15
70443: PUSH
70444: LD_INT 5
70446: PUSH
70447: EMPTY
70448: LIST
70449: LIST
70450: LIST
70451: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
70452: LD_VAR 0 6
70456: PPUSH
70457: CALL_OW 264
70461: PUSH
70462: LD_INT 3
70464: PUSH
70465: LD_INT 23
70467: PUSH
70468: EMPTY
70469: LIST
70470: LIST
70471: IN
70472: IFFALSE 70493
// points := [ 7 , 25 , 8 ] ;
70474: LD_ADDR_VAR 0 9
70478: PUSH
70479: LD_INT 7
70481: PUSH
70482: LD_INT 25
70484: PUSH
70485: LD_INT 8
70487: PUSH
70488: EMPTY
70489: LIST
70490: LIST
70491: LIST
70492: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
70493: LD_VAR 0 6
70497: PPUSH
70498: CALL_OW 264
70502: PUSH
70503: LD_INT 5
70505: PUSH
70506: LD_INT 27
70508: PUSH
70509: LD_INT 44
70511: PUSH
70512: EMPTY
70513: LIST
70514: LIST
70515: LIST
70516: IN
70517: IFFALSE 70538
// points := [ 14 , 50 , 16 ] ;
70519: LD_ADDR_VAR 0 9
70523: PUSH
70524: LD_INT 14
70526: PUSH
70527: LD_INT 50
70529: PUSH
70530: LD_INT 16
70532: PUSH
70533: EMPTY
70534: LIST
70535: LIST
70536: LIST
70537: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
70538: LD_VAR 0 6
70542: PPUSH
70543: CALL_OW 264
70547: PUSH
70548: LD_INT 6
70550: PUSH
70551: LD_INT 46
70553: PUSH
70554: EMPTY
70555: LIST
70556: LIST
70557: IN
70558: IFFALSE 70579
// points := [ 32 , 120 , 70 ] ;
70560: LD_ADDR_VAR 0 9
70564: PUSH
70565: LD_INT 32
70567: PUSH
70568: LD_INT 120
70570: PUSH
70571: LD_INT 70
70573: PUSH
70574: EMPTY
70575: LIST
70576: LIST
70577: LIST
70578: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
70579: LD_VAR 0 6
70583: PPUSH
70584: CALL_OW 264
70588: PUSH
70589: LD_INT 7
70591: PUSH
70592: LD_INT 28
70594: PUSH
70595: LD_INT 45
70597: PUSH
70598: EMPTY
70599: LIST
70600: LIST
70601: LIST
70602: IN
70603: IFFALSE 70624
// points := [ 35 , 20 , 45 ] ;
70605: LD_ADDR_VAR 0 9
70609: PUSH
70610: LD_INT 35
70612: PUSH
70613: LD_INT 20
70615: PUSH
70616: LD_INT 45
70618: PUSH
70619: EMPTY
70620: LIST
70621: LIST
70622: LIST
70623: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
70624: LD_VAR 0 6
70628: PPUSH
70629: CALL_OW 264
70633: PUSH
70634: LD_INT 47
70636: PUSH
70637: EMPTY
70638: LIST
70639: IN
70640: IFFALSE 70661
// points := [ 67 , 45 , 75 ] ;
70642: LD_ADDR_VAR 0 9
70646: PUSH
70647: LD_INT 67
70649: PUSH
70650: LD_INT 45
70652: PUSH
70653: LD_INT 75
70655: PUSH
70656: EMPTY
70657: LIST
70658: LIST
70659: LIST
70660: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
70661: LD_VAR 0 6
70665: PPUSH
70666: CALL_OW 264
70670: PUSH
70671: LD_INT 26
70673: PUSH
70674: EMPTY
70675: LIST
70676: IN
70677: IFFALSE 70698
// points := [ 120 , 30 , 80 ] ;
70679: LD_ADDR_VAR 0 9
70683: PUSH
70684: LD_INT 120
70686: PUSH
70687: LD_INT 30
70689: PUSH
70690: LD_INT 80
70692: PUSH
70693: EMPTY
70694: LIST
70695: LIST
70696: LIST
70697: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
70698: LD_VAR 0 6
70702: PPUSH
70703: CALL_OW 264
70707: PUSH
70708: LD_INT 22
70710: PUSH
70711: EMPTY
70712: LIST
70713: IN
70714: IFFALSE 70735
// points := [ 40 , 1 , 1 ] ;
70716: LD_ADDR_VAR 0 9
70720: PUSH
70721: LD_INT 40
70723: PUSH
70724: LD_INT 1
70726: PUSH
70727: LD_INT 1
70729: PUSH
70730: EMPTY
70731: LIST
70732: LIST
70733: LIST
70734: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
70735: LD_VAR 0 6
70739: PPUSH
70740: CALL_OW 264
70744: PUSH
70745: LD_INT 29
70747: PUSH
70748: EMPTY
70749: LIST
70750: IN
70751: IFFALSE 70772
// points := [ 70 , 200 , 400 ] ;
70753: LD_ADDR_VAR 0 9
70757: PUSH
70758: LD_INT 70
70760: PUSH
70761: LD_INT 200
70763: PUSH
70764: LD_INT 400
70766: PUSH
70767: EMPTY
70768: LIST
70769: LIST
70770: LIST
70771: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
70772: LD_VAR 0 6
70776: PPUSH
70777: CALL_OW 264
70781: PUSH
70782: LD_INT 14
70784: PUSH
70785: LD_INT 53
70787: PUSH
70788: EMPTY
70789: LIST
70790: LIST
70791: IN
70792: IFFALSE 70813
// points := [ 40 , 10 , 20 ] ;
70794: LD_ADDR_VAR 0 9
70798: PUSH
70799: LD_INT 40
70801: PUSH
70802: LD_INT 10
70804: PUSH
70805: LD_INT 20
70807: PUSH
70808: EMPTY
70809: LIST
70810: LIST
70811: LIST
70812: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
70813: LD_VAR 0 6
70817: PPUSH
70818: CALL_OW 264
70822: PUSH
70823: LD_INT 9
70825: PUSH
70826: EMPTY
70827: LIST
70828: IN
70829: IFFALSE 70850
// points := [ 5 , 70 , 20 ] ;
70831: LD_ADDR_VAR 0 9
70835: PUSH
70836: LD_INT 5
70838: PUSH
70839: LD_INT 70
70841: PUSH
70842: LD_INT 20
70844: PUSH
70845: EMPTY
70846: LIST
70847: LIST
70848: LIST
70849: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
70850: LD_VAR 0 6
70854: PPUSH
70855: CALL_OW 264
70859: PUSH
70860: LD_INT 10
70862: PUSH
70863: EMPTY
70864: LIST
70865: IN
70866: IFFALSE 70887
// points := [ 35 , 110 , 70 ] ;
70868: LD_ADDR_VAR 0 9
70872: PUSH
70873: LD_INT 35
70875: PUSH
70876: LD_INT 110
70878: PUSH
70879: LD_INT 70
70881: PUSH
70882: EMPTY
70883: LIST
70884: LIST
70885: LIST
70886: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
70887: LD_VAR 0 6
70891: PPUSH
70892: CALL_OW 265
70896: PUSH
70897: LD_INT 25
70899: EQUAL
70900: IFFALSE 70921
// points := [ 80 , 65 , 100 ] ;
70902: LD_ADDR_VAR 0 9
70906: PUSH
70907: LD_INT 80
70909: PUSH
70910: LD_INT 65
70912: PUSH
70913: LD_INT 100
70915: PUSH
70916: EMPTY
70917: LIST
70918: LIST
70919: LIST
70920: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
70921: LD_VAR 0 6
70925: PPUSH
70926: CALL_OW 263
70930: PUSH
70931: LD_INT 1
70933: EQUAL
70934: IFFALSE 70969
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
70936: LD_ADDR_VAR 0 10
70940: PUSH
70941: LD_VAR 0 10
70945: PUSH
70946: LD_VAR 0 6
70950: PPUSH
70951: CALL_OW 311
70955: PPUSH
70956: LD_INT 3
70958: PPUSH
70959: CALL_OW 259
70963: PUSH
70964: LD_INT 4
70966: MUL
70967: MUL
70968: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
70969: LD_VAR 0 6
70973: PPUSH
70974: CALL_OW 263
70978: PUSH
70979: LD_INT 2
70981: EQUAL
70982: IFFALSE 71033
// begin j := IsControledBy ( i ) ;
70984: LD_ADDR_VAR 0 7
70988: PUSH
70989: LD_VAR 0 6
70993: PPUSH
70994: CALL_OW 312
70998: ST_TO_ADDR
// if j then
70999: LD_VAR 0 7
71003: IFFALSE 71033
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
71005: LD_ADDR_VAR 0 10
71009: PUSH
71010: LD_VAR 0 10
71014: PUSH
71015: LD_VAR 0 7
71019: PPUSH
71020: LD_INT 3
71022: PPUSH
71023: CALL_OW 259
71027: PUSH
71028: LD_INT 3
71030: MUL
71031: MUL
71032: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
71033: LD_VAR 0 6
71037: PPUSH
71038: CALL_OW 264
71042: PUSH
71043: LD_INT 5
71045: PUSH
71046: LD_INT 6
71048: PUSH
71049: LD_INT 46
71051: PUSH
71052: LD_INT 44
71054: PUSH
71055: LD_INT 47
71057: PUSH
71058: LD_INT 45
71060: PUSH
71061: LD_INT 28
71063: PUSH
71064: LD_INT 7
71066: PUSH
71067: LD_INT 27
71069: PUSH
71070: LD_INT 29
71072: PUSH
71073: EMPTY
71074: LIST
71075: LIST
71076: LIST
71077: LIST
71078: LIST
71079: LIST
71080: LIST
71081: LIST
71082: LIST
71083: LIST
71084: IN
71085: PUSH
71086: LD_VAR 0 1
71090: PPUSH
71091: LD_INT 52
71093: PPUSH
71094: CALL_OW 321
71098: PUSH
71099: LD_INT 2
71101: EQUAL
71102: AND
71103: IFFALSE 71120
// bpoints := bpoints * 1.2 ;
71105: LD_ADDR_VAR 0 10
71109: PUSH
71110: LD_VAR 0 10
71114: PUSH
71115: LD_REAL  1.20000000000000E+0000
71118: MUL
71119: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
71120: LD_VAR 0 6
71124: PPUSH
71125: CALL_OW 264
71129: PUSH
71130: LD_INT 6
71132: PUSH
71133: LD_INT 46
71135: PUSH
71136: LD_INT 47
71138: PUSH
71139: EMPTY
71140: LIST
71141: LIST
71142: LIST
71143: IN
71144: IFFALSE 71161
// bpoints := bpoints * 1.2 ;
71146: LD_ADDR_VAR 0 10
71150: PUSH
71151: LD_VAR 0 10
71155: PUSH
71156: LD_REAL  1.20000000000000E+0000
71159: MUL
71160: ST_TO_ADDR
// end ; unit_building :
71161: GO 71175
71163: LD_INT 3
71165: DOUBLE
71166: EQUAL
71167: IFTRUE 71171
71169: GO 71174
71171: POP
// ; end ;
71172: GO 71175
71174: POP
// for j = 1 to 3 do
71175: LD_ADDR_VAR 0 7
71179: PUSH
71180: DOUBLE
71181: LD_INT 1
71183: DEC
71184: ST_TO_ADDR
71185: LD_INT 3
71187: PUSH
71188: FOR_TO
71189: IFFALSE 71242
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
71191: LD_ADDR_VAR 0 5
71195: PUSH
71196: LD_VAR 0 5
71200: PPUSH
71201: LD_VAR 0 7
71205: PPUSH
71206: LD_VAR 0 5
71210: PUSH
71211: LD_VAR 0 7
71215: ARRAY
71216: PUSH
71217: LD_VAR 0 9
71221: PUSH
71222: LD_VAR 0 7
71226: ARRAY
71227: PUSH
71228: LD_VAR 0 10
71232: MUL
71233: PLUS
71234: PPUSH
71235: CALL_OW 1
71239: ST_TO_ADDR
71240: GO 71188
71242: POP
71243: POP
// end ;
71244: GO 69727
71246: POP
71247: POP
// result := Replace ( result , 4 , tmp ) ;
71248: LD_ADDR_VAR 0 5
71252: PUSH
71253: LD_VAR 0 5
71257: PPUSH
71258: LD_INT 4
71260: PPUSH
71261: LD_VAR 0 8
71265: PPUSH
71266: CALL_OW 1
71270: ST_TO_ADDR
// end ;
71271: LD_VAR 0 5
71275: RET
// export function DangerAtRange ( unit , range ) ; begin
71276: LD_INT 0
71278: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
71279: LD_ADDR_VAR 0 3
71283: PUSH
71284: LD_VAR 0 1
71288: PPUSH
71289: CALL_OW 255
71293: PPUSH
71294: LD_VAR 0 1
71298: PPUSH
71299: CALL_OW 250
71303: PPUSH
71304: LD_VAR 0 1
71308: PPUSH
71309: CALL_OW 251
71313: PPUSH
71314: LD_VAR 0 2
71318: PPUSH
71319: CALL 69579 0 4
71323: ST_TO_ADDR
// end ;
71324: LD_VAR 0 3
71328: RET
// export function DangerInArea ( side , area ) ; begin
71329: LD_INT 0
71331: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
71332: LD_ADDR_VAR 0 3
71336: PUSH
71337: LD_VAR 0 2
71341: PPUSH
71342: LD_INT 81
71344: PUSH
71345: LD_VAR 0 1
71349: PUSH
71350: EMPTY
71351: LIST
71352: LIST
71353: PPUSH
71354: CALL_OW 70
71358: ST_TO_ADDR
// end ;
71359: LD_VAR 0 3
71363: RET
// export function IsExtension ( b ) ; begin
71364: LD_INT 0
71366: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
71367: LD_ADDR_VAR 0 2
71371: PUSH
71372: LD_VAR 0 1
71376: PUSH
71377: LD_INT 23
71379: PUSH
71380: LD_INT 20
71382: PUSH
71383: LD_INT 22
71385: PUSH
71386: LD_INT 17
71388: PUSH
71389: LD_INT 24
71391: PUSH
71392: LD_INT 21
71394: PUSH
71395: LD_INT 19
71397: PUSH
71398: LD_INT 16
71400: PUSH
71401: LD_INT 25
71403: PUSH
71404: LD_INT 18
71406: PUSH
71407: EMPTY
71408: LIST
71409: LIST
71410: LIST
71411: LIST
71412: LIST
71413: LIST
71414: LIST
71415: LIST
71416: LIST
71417: LIST
71418: IN
71419: ST_TO_ADDR
// end ;
71420: LD_VAR 0 2
71424: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
71425: LD_INT 0
71427: PPUSH
71428: PPUSH
71429: PPUSH
// result := [ ] ;
71430: LD_ADDR_VAR 0 3
71434: PUSH
71435: EMPTY
71436: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
71437: LD_ADDR_VAR 0 4
71441: PUSH
71442: LD_VAR 0 2
71446: PPUSH
71447: LD_INT 21
71449: PUSH
71450: LD_INT 3
71452: PUSH
71453: EMPTY
71454: LIST
71455: LIST
71456: PPUSH
71457: CALL_OW 70
71461: ST_TO_ADDR
// if not tmp then
71462: LD_VAR 0 4
71466: NOT
71467: IFFALSE 71471
// exit ;
71469: GO 71529
// for i in tmp do
71471: LD_ADDR_VAR 0 5
71475: PUSH
71476: LD_VAR 0 4
71480: PUSH
71481: FOR_IN
71482: IFFALSE 71517
// if GetBase ( i ) <> base then
71484: LD_VAR 0 5
71488: PPUSH
71489: CALL_OW 274
71493: PUSH
71494: LD_VAR 0 1
71498: NONEQUAL
71499: IFFALSE 71515
// ComLinkToBase ( base , i ) ;
71501: LD_VAR 0 1
71505: PPUSH
71506: LD_VAR 0 5
71510: PPUSH
71511: CALL_OW 169
71515: GO 71481
71517: POP
71518: POP
// result := tmp ;
71519: LD_ADDR_VAR 0 3
71523: PUSH
71524: LD_VAR 0 4
71528: ST_TO_ADDR
// end ;
71529: LD_VAR 0 3
71533: RET
// export function ComComplete ( unit , b ) ; var i ; begin
71534: LD_INT 0
71536: PPUSH
71537: PPUSH
// if BuildingStatus ( b ) = bs_build then
71538: LD_VAR 0 2
71542: PPUSH
71543: CALL_OW 461
71547: PUSH
71548: LD_INT 1
71550: EQUAL
71551: IFFALSE 71611
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
71553: LD_VAR 0 1
71557: PPUSH
71558: LD_STRING h
71560: PUSH
71561: LD_VAR 0 2
71565: PPUSH
71566: CALL_OW 250
71570: PUSH
71571: LD_VAR 0 2
71575: PPUSH
71576: CALL_OW 251
71580: PUSH
71581: LD_VAR 0 2
71585: PUSH
71586: LD_INT 0
71588: PUSH
71589: LD_INT 0
71591: PUSH
71592: LD_INT 0
71594: PUSH
71595: EMPTY
71596: LIST
71597: LIST
71598: LIST
71599: LIST
71600: LIST
71601: LIST
71602: LIST
71603: PUSH
71604: EMPTY
71605: LIST
71606: PPUSH
71607: CALL_OW 446
// end ;
71611: LD_VAR 0 3
71615: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
71616: LD_INT 0
71618: PPUSH
71619: PPUSH
71620: PPUSH
71621: PPUSH
71622: PPUSH
71623: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
71624: LD_VAR 0 1
71628: NOT
71629: PUSH
71630: LD_VAR 0 1
71634: PPUSH
71635: CALL_OW 263
71639: PUSH
71640: LD_INT 2
71642: EQUAL
71643: NOT
71644: OR
71645: IFFALSE 71649
// exit ;
71647: GO 71965
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
71649: LD_ADDR_VAR 0 6
71653: PUSH
71654: LD_INT 22
71656: PUSH
71657: LD_VAR 0 1
71661: PPUSH
71662: CALL_OW 255
71666: PUSH
71667: EMPTY
71668: LIST
71669: LIST
71670: PUSH
71671: LD_INT 2
71673: PUSH
71674: LD_INT 30
71676: PUSH
71677: LD_INT 36
71679: PUSH
71680: EMPTY
71681: LIST
71682: LIST
71683: PUSH
71684: LD_INT 34
71686: PUSH
71687: LD_INT 31
71689: PUSH
71690: EMPTY
71691: LIST
71692: LIST
71693: PUSH
71694: EMPTY
71695: LIST
71696: LIST
71697: LIST
71698: PUSH
71699: EMPTY
71700: LIST
71701: LIST
71702: PPUSH
71703: CALL_OW 69
71707: ST_TO_ADDR
// if not tmp then
71708: LD_VAR 0 6
71712: NOT
71713: IFFALSE 71717
// exit ;
71715: GO 71965
// result := [ ] ;
71717: LD_ADDR_VAR 0 2
71721: PUSH
71722: EMPTY
71723: ST_TO_ADDR
// for i in tmp do
71724: LD_ADDR_VAR 0 3
71728: PUSH
71729: LD_VAR 0 6
71733: PUSH
71734: FOR_IN
71735: IFFALSE 71806
// begin t := UnitsInside ( i ) ;
71737: LD_ADDR_VAR 0 4
71741: PUSH
71742: LD_VAR 0 3
71746: PPUSH
71747: CALL_OW 313
71751: ST_TO_ADDR
// if t then
71752: LD_VAR 0 4
71756: IFFALSE 71804
// for j in t do
71758: LD_ADDR_VAR 0 7
71762: PUSH
71763: LD_VAR 0 4
71767: PUSH
71768: FOR_IN
71769: IFFALSE 71802
// result := Insert ( result , result + 1 , j ) ;
71771: LD_ADDR_VAR 0 2
71775: PUSH
71776: LD_VAR 0 2
71780: PPUSH
71781: LD_VAR 0 2
71785: PUSH
71786: LD_INT 1
71788: PLUS
71789: PPUSH
71790: LD_VAR 0 7
71794: PPUSH
71795: CALL_OW 2
71799: ST_TO_ADDR
71800: GO 71768
71802: POP
71803: POP
// end ;
71804: GO 71734
71806: POP
71807: POP
// if not result then
71808: LD_VAR 0 2
71812: NOT
71813: IFFALSE 71817
// exit ;
71815: GO 71965
// mech := result [ 1 ] ;
71817: LD_ADDR_VAR 0 5
71821: PUSH
71822: LD_VAR 0 2
71826: PUSH
71827: LD_INT 1
71829: ARRAY
71830: ST_TO_ADDR
// if result > 1 then
71831: LD_VAR 0 2
71835: PUSH
71836: LD_INT 1
71838: GREATER
71839: IFFALSE 71951
// for i = 2 to result do
71841: LD_ADDR_VAR 0 3
71845: PUSH
71846: DOUBLE
71847: LD_INT 2
71849: DEC
71850: ST_TO_ADDR
71851: LD_VAR 0 2
71855: PUSH
71856: FOR_TO
71857: IFFALSE 71949
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
71859: LD_ADDR_VAR 0 4
71863: PUSH
71864: LD_VAR 0 2
71868: PUSH
71869: LD_VAR 0 3
71873: ARRAY
71874: PPUSH
71875: LD_INT 3
71877: PPUSH
71878: CALL_OW 259
71882: PUSH
71883: LD_VAR 0 2
71887: PUSH
71888: LD_VAR 0 3
71892: ARRAY
71893: PPUSH
71894: CALL_OW 432
71898: MINUS
71899: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
71900: LD_VAR 0 4
71904: PUSH
71905: LD_VAR 0 5
71909: PPUSH
71910: LD_INT 3
71912: PPUSH
71913: CALL_OW 259
71917: PUSH
71918: LD_VAR 0 5
71922: PPUSH
71923: CALL_OW 432
71927: MINUS
71928: GREATEREQUAL
71929: IFFALSE 71947
// mech := result [ i ] ;
71931: LD_ADDR_VAR 0 5
71935: PUSH
71936: LD_VAR 0 2
71940: PUSH
71941: LD_VAR 0 3
71945: ARRAY
71946: ST_TO_ADDR
// end ;
71947: GO 71856
71949: POP
71950: POP
// ComLinkTo ( vehicle , mech ) ;
71951: LD_VAR 0 1
71955: PPUSH
71956: LD_VAR 0 5
71960: PPUSH
71961: CALL_OW 135
// end ;
71965: LD_VAR 0 2
71969: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
71970: LD_INT 0
71972: PPUSH
71973: PPUSH
71974: PPUSH
71975: PPUSH
71976: PPUSH
71977: PPUSH
71978: PPUSH
71979: PPUSH
71980: PPUSH
71981: PPUSH
71982: PPUSH
71983: PPUSH
71984: PPUSH
// result := [ ] ;
71985: LD_ADDR_VAR 0 7
71989: PUSH
71990: EMPTY
71991: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
71992: LD_VAR 0 1
71996: PPUSH
71997: CALL_OW 266
72001: PUSH
72002: LD_INT 0
72004: PUSH
72005: LD_INT 1
72007: PUSH
72008: EMPTY
72009: LIST
72010: LIST
72011: IN
72012: NOT
72013: IFFALSE 72017
// exit ;
72015: GO 73648
// if name then
72017: LD_VAR 0 3
72021: IFFALSE 72037
// SetBName ( base_dep , name ) ;
72023: LD_VAR 0 1
72027: PPUSH
72028: LD_VAR 0 3
72032: PPUSH
72033: CALL_OW 500
// base := GetBase ( base_dep ) ;
72037: LD_ADDR_VAR 0 15
72041: PUSH
72042: LD_VAR 0 1
72046: PPUSH
72047: CALL_OW 274
72051: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
72052: LD_ADDR_VAR 0 16
72056: PUSH
72057: LD_VAR 0 1
72061: PPUSH
72062: CALL_OW 255
72066: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
72067: LD_ADDR_VAR 0 17
72071: PUSH
72072: LD_VAR 0 1
72076: PPUSH
72077: CALL_OW 248
72081: ST_TO_ADDR
// if sources then
72082: LD_VAR 0 5
72086: IFFALSE 72133
// for i = 1 to 3 do
72088: LD_ADDR_VAR 0 8
72092: PUSH
72093: DOUBLE
72094: LD_INT 1
72096: DEC
72097: ST_TO_ADDR
72098: LD_INT 3
72100: PUSH
72101: FOR_TO
72102: IFFALSE 72131
// AddResourceType ( base , i , sources [ i ] ) ;
72104: LD_VAR 0 15
72108: PPUSH
72109: LD_VAR 0 8
72113: PPUSH
72114: LD_VAR 0 5
72118: PUSH
72119: LD_VAR 0 8
72123: ARRAY
72124: PPUSH
72125: CALL_OW 276
72129: GO 72101
72131: POP
72132: POP
// buildings := GetBaseBuildings ( base , area ) ;
72133: LD_ADDR_VAR 0 18
72137: PUSH
72138: LD_VAR 0 15
72142: PPUSH
72143: LD_VAR 0 2
72147: PPUSH
72148: CALL 71425 0 2
72152: ST_TO_ADDR
// InitHc ;
72153: CALL_OW 19
// InitUc ;
72157: CALL_OW 18
// uc_side := side ;
72161: LD_ADDR_OWVAR 20
72165: PUSH
72166: LD_VAR 0 16
72170: ST_TO_ADDR
// uc_nation := nation ;
72171: LD_ADDR_OWVAR 21
72175: PUSH
72176: LD_VAR 0 17
72180: ST_TO_ADDR
// if buildings then
72181: LD_VAR 0 18
72185: IFFALSE 73507
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
72187: LD_ADDR_VAR 0 19
72191: PUSH
72192: LD_VAR 0 18
72196: PPUSH
72197: LD_INT 2
72199: PUSH
72200: LD_INT 30
72202: PUSH
72203: LD_INT 29
72205: PUSH
72206: EMPTY
72207: LIST
72208: LIST
72209: PUSH
72210: LD_INT 30
72212: PUSH
72213: LD_INT 30
72215: PUSH
72216: EMPTY
72217: LIST
72218: LIST
72219: PUSH
72220: EMPTY
72221: LIST
72222: LIST
72223: LIST
72224: PPUSH
72225: CALL_OW 72
72229: ST_TO_ADDR
// if tmp then
72230: LD_VAR 0 19
72234: IFFALSE 72282
// for i in tmp do
72236: LD_ADDR_VAR 0 8
72240: PUSH
72241: LD_VAR 0 19
72245: PUSH
72246: FOR_IN
72247: IFFALSE 72280
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
72249: LD_VAR 0 8
72253: PPUSH
72254: CALL_OW 250
72258: PPUSH
72259: LD_VAR 0 8
72263: PPUSH
72264: CALL_OW 251
72268: PPUSH
72269: LD_VAR 0 16
72273: PPUSH
72274: CALL_OW 441
72278: GO 72246
72280: POP
72281: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
72282: LD_VAR 0 18
72286: PPUSH
72287: LD_INT 2
72289: PUSH
72290: LD_INT 30
72292: PUSH
72293: LD_INT 32
72295: PUSH
72296: EMPTY
72297: LIST
72298: LIST
72299: PUSH
72300: LD_INT 30
72302: PUSH
72303: LD_INT 33
72305: PUSH
72306: EMPTY
72307: LIST
72308: LIST
72309: PUSH
72310: EMPTY
72311: LIST
72312: LIST
72313: LIST
72314: PPUSH
72315: CALL_OW 72
72319: IFFALSE 72407
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
72321: LD_ADDR_VAR 0 8
72325: PUSH
72326: LD_VAR 0 18
72330: PPUSH
72331: LD_INT 2
72333: PUSH
72334: LD_INT 30
72336: PUSH
72337: LD_INT 32
72339: PUSH
72340: EMPTY
72341: LIST
72342: LIST
72343: PUSH
72344: LD_INT 30
72346: PUSH
72347: LD_INT 33
72349: PUSH
72350: EMPTY
72351: LIST
72352: LIST
72353: PUSH
72354: EMPTY
72355: LIST
72356: LIST
72357: LIST
72358: PPUSH
72359: CALL_OW 72
72363: PUSH
72364: FOR_IN
72365: IFFALSE 72405
// begin if not GetBWeapon ( i ) then
72367: LD_VAR 0 8
72371: PPUSH
72372: CALL_OW 269
72376: NOT
72377: IFFALSE 72403
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
72379: LD_VAR 0 8
72383: PPUSH
72384: LD_VAR 0 8
72388: PPUSH
72389: LD_VAR 0 2
72393: PPUSH
72394: CALL 73653 0 2
72398: PPUSH
72399: CALL_OW 431
// end ;
72403: GO 72364
72405: POP
72406: POP
// end ; for i = 1 to personel do
72407: LD_ADDR_VAR 0 8
72411: PUSH
72412: DOUBLE
72413: LD_INT 1
72415: DEC
72416: ST_TO_ADDR
72417: LD_VAR 0 6
72421: PUSH
72422: FOR_TO
72423: IFFALSE 73487
// begin if i > 4 then
72425: LD_VAR 0 8
72429: PUSH
72430: LD_INT 4
72432: GREATER
72433: IFFALSE 72437
// break ;
72435: GO 73487
// case i of 1 :
72437: LD_VAR 0 8
72441: PUSH
72442: LD_INT 1
72444: DOUBLE
72445: EQUAL
72446: IFTRUE 72450
72448: GO 72530
72450: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
72451: LD_ADDR_VAR 0 12
72455: PUSH
72456: LD_VAR 0 18
72460: PPUSH
72461: LD_INT 22
72463: PUSH
72464: LD_VAR 0 16
72468: PUSH
72469: EMPTY
72470: LIST
72471: LIST
72472: PUSH
72473: LD_INT 58
72475: PUSH
72476: EMPTY
72477: LIST
72478: PUSH
72479: LD_INT 2
72481: PUSH
72482: LD_INT 30
72484: PUSH
72485: LD_INT 32
72487: PUSH
72488: EMPTY
72489: LIST
72490: LIST
72491: PUSH
72492: LD_INT 30
72494: PUSH
72495: LD_INT 4
72497: PUSH
72498: EMPTY
72499: LIST
72500: LIST
72501: PUSH
72502: LD_INT 30
72504: PUSH
72505: LD_INT 5
72507: PUSH
72508: EMPTY
72509: LIST
72510: LIST
72511: PUSH
72512: EMPTY
72513: LIST
72514: LIST
72515: LIST
72516: LIST
72517: PUSH
72518: EMPTY
72519: LIST
72520: LIST
72521: LIST
72522: PPUSH
72523: CALL_OW 72
72527: ST_TO_ADDR
72528: GO 72752
72530: LD_INT 2
72532: DOUBLE
72533: EQUAL
72534: IFTRUE 72538
72536: GO 72600
72538: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
72539: LD_ADDR_VAR 0 12
72543: PUSH
72544: LD_VAR 0 18
72548: PPUSH
72549: LD_INT 22
72551: PUSH
72552: LD_VAR 0 16
72556: PUSH
72557: EMPTY
72558: LIST
72559: LIST
72560: PUSH
72561: LD_INT 2
72563: PUSH
72564: LD_INT 30
72566: PUSH
72567: LD_INT 0
72569: PUSH
72570: EMPTY
72571: LIST
72572: LIST
72573: PUSH
72574: LD_INT 30
72576: PUSH
72577: LD_INT 1
72579: PUSH
72580: EMPTY
72581: LIST
72582: LIST
72583: PUSH
72584: EMPTY
72585: LIST
72586: LIST
72587: LIST
72588: PUSH
72589: EMPTY
72590: LIST
72591: LIST
72592: PPUSH
72593: CALL_OW 72
72597: ST_TO_ADDR
72598: GO 72752
72600: LD_INT 3
72602: DOUBLE
72603: EQUAL
72604: IFTRUE 72608
72606: GO 72670
72608: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
72609: LD_ADDR_VAR 0 12
72613: PUSH
72614: LD_VAR 0 18
72618: PPUSH
72619: LD_INT 22
72621: PUSH
72622: LD_VAR 0 16
72626: PUSH
72627: EMPTY
72628: LIST
72629: LIST
72630: PUSH
72631: LD_INT 2
72633: PUSH
72634: LD_INT 30
72636: PUSH
72637: LD_INT 2
72639: PUSH
72640: EMPTY
72641: LIST
72642: LIST
72643: PUSH
72644: LD_INT 30
72646: PUSH
72647: LD_INT 3
72649: PUSH
72650: EMPTY
72651: LIST
72652: LIST
72653: PUSH
72654: EMPTY
72655: LIST
72656: LIST
72657: LIST
72658: PUSH
72659: EMPTY
72660: LIST
72661: LIST
72662: PPUSH
72663: CALL_OW 72
72667: ST_TO_ADDR
72668: GO 72752
72670: LD_INT 4
72672: DOUBLE
72673: EQUAL
72674: IFTRUE 72678
72676: GO 72751
72678: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
72679: LD_ADDR_VAR 0 12
72683: PUSH
72684: LD_VAR 0 18
72688: PPUSH
72689: LD_INT 22
72691: PUSH
72692: LD_VAR 0 16
72696: PUSH
72697: EMPTY
72698: LIST
72699: LIST
72700: PUSH
72701: LD_INT 2
72703: PUSH
72704: LD_INT 30
72706: PUSH
72707: LD_INT 6
72709: PUSH
72710: EMPTY
72711: LIST
72712: LIST
72713: PUSH
72714: LD_INT 30
72716: PUSH
72717: LD_INT 7
72719: PUSH
72720: EMPTY
72721: LIST
72722: LIST
72723: PUSH
72724: LD_INT 30
72726: PUSH
72727: LD_INT 8
72729: PUSH
72730: EMPTY
72731: LIST
72732: LIST
72733: PUSH
72734: EMPTY
72735: LIST
72736: LIST
72737: LIST
72738: LIST
72739: PUSH
72740: EMPTY
72741: LIST
72742: LIST
72743: PPUSH
72744: CALL_OW 72
72748: ST_TO_ADDR
72749: GO 72752
72751: POP
// if i = 1 then
72752: LD_VAR 0 8
72756: PUSH
72757: LD_INT 1
72759: EQUAL
72760: IFFALSE 72871
// begin tmp := [ ] ;
72762: LD_ADDR_VAR 0 19
72766: PUSH
72767: EMPTY
72768: ST_TO_ADDR
// for j in f do
72769: LD_ADDR_VAR 0 9
72773: PUSH
72774: LD_VAR 0 12
72778: PUSH
72779: FOR_IN
72780: IFFALSE 72853
// if GetBType ( j ) = b_bunker then
72782: LD_VAR 0 9
72786: PPUSH
72787: CALL_OW 266
72791: PUSH
72792: LD_INT 32
72794: EQUAL
72795: IFFALSE 72822
// tmp := Insert ( tmp , 1 , j ) else
72797: LD_ADDR_VAR 0 19
72801: PUSH
72802: LD_VAR 0 19
72806: PPUSH
72807: LD_INT 1
72809: PPUSH
72810: LD_VAR 0 9
72814: PPUSH
72815: CALL_OW 2
72819: ST_TO_ADDR
72820: GO 72851
// tmp := Insert ( tmp , tmp + 1 , j ) ;
72822: LD_ADDR_VAR 0 19
72826: PUSH
72827: LD_VAR 0 19
72831: PPUSH
72832: LD_VAR 0 19
72836: PUSH
72837: LD_INT 1
72839: PLUS
72840: PPUSH
72841: LD_VAR 0 9
72845: PPUSH
72846: CALL_OW 2
72850: ST_TO_ADDR
72851: GO 72779
72853: POP
72854: POP
// if tmp then
72855: LD_VAR 0 19
72859: IFFALSE 72871
// f := tmp ;
72861: LD_ADDR_VAR 0 12
72865: PUSH
72866: LD_VAR 0 19
72870: ST_TO_ADDR
// end ; x := personel [ i ] ;
72871: LD_ADDR_VAR 0 13
72875: PUSH
72876: LD_VAR 0 6
72880: PUSH
72881: LD_VAR 0 8
72885: ARRAY
72886: ST_TO_ADDR
// if x = - 1 then
72887: LD_VAR 0 13
72891: PUSH
72892: LD_INT 1
72894: NEG
72895: EQUAL
72896: IFFALSE 73105
// begin for j in f do
72898: LD_ADDR_VAR 0 9
72902: PUSH
72903: LD_VAR 0 12
72907: PUSH
72908: FOR_IN
72909: IFFALSE 73101
// repeat InitHc ;
72911: CALL_OW 19
// if GetBType ( j ) = b_barracks then
72915: LD_VAR 0 9
72919: PPUSH
72920: CALL_OW 266
72924: PUSH
72925: LD_INT 5
72927: EQUAL
72928: IFFALSE 72998
// begin if UnitsInside ( j ) < 3 then
72930: LD_VAR 0 9
72934: PPUSH
72935: CALL_OW 313
72939: PUSH
72940: LD_INT 3
72942: LESS
72943: IFFALSE 72979
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
72945: LD_INT 0
72947: PPUSH
72948: LD_INT 5
72950: PUSH
72951: LD_INT 8
72953: PUSH
72954: LD_INT 9
72956: PUSH
72957: EMPTY
72958: LIST
72959: LIST
72960: LIST
72961: PUSH
72962: LD_VAR 0 17
72966: ARRAY
72967: PPUSH
72968: LD_VAR 0 4
72972: PPUSH
72973: CALL_OW 380
72977: GO 72996
// PrepareHuman ( false , i , skill ) ;
72979: LD_INT 0
72981: PPUSH
72982: LD_VAR 0 8
72986: PPUSH
72987: LD_VAR 0 4
72991: PPUSH
72992: CALL_OW 380
// end else
72996: GO 73015
// PrepareHuman ( false , i , skill ) ;
72998: LD_INT 0
73000: PPUSH
73001: LD_VAR 0 8
73005: PPUSH
73006: LD_VAR 0 4
73010: PPUSH
73011: CALL_OW 380
// un := CreateHuman ;
73015: LD_ADDR_VAR 0 14
73019: PUSH
73020: CALL_OW 44
73024: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
73025: LD_ADDR_VAR 0 7
73029: PUSH
73030: LD_VAR 0 7
73034: PPUSH
73035: LD_INT 1
73037: PPUSH
73038: LD_VAR 0 14
73042: PPUSH
73043: CALL_OW 2
73047: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
73048: LD_VAR 0 14
73052: PPUSH
73053: LD_VAR 0 9
73057: PPUSH
73058: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
73062: LD_VAR 0 9
73066: PPUSH
73067: CALL_OW 313
73071: PUSH
73072: LD_INT 6
73074: EQUAL
73075: PUSH
73076: LD_VAR 0 9
73080: PPUSH
73081: CALL_OW 266
73085: PUSH
73086: LD_INT 32
73088: PUSH
73089: LD_INT 31
73091: PUSH
73092: EMPTY
73093: LIST
73094: LIST
73095: IN
73096: OR
73097: IFFALSE 72911
73099: GO 72908
73101: POP
73102: POP
// end else
73103: GO 73485
// for j = 1 to x do
73105: LD_ADDR_VAR 0 9
73109: PUSH
73110: DOUBLE
73111: LD_INT 1
73113: DEC
73114: ST_TO_ADDR
73115: LD_VAR 0 13
73119: PUSH
73120: FOR_TO
73121: IFFALSE 73483
// begin InitHc ;
73123: CALL_OW 19
// if not f then
73127: LD_VAR 0 12
73131: NOT
73132: IFFALSE 73221
// begin PrepareHuman ( false , i , skill ) ;
73134: LD_INT 0
73136: PPUSH
73137: LD_VAR 0 8
73141: PPUSH
73142: LD_VAR 0 4
73146: PPUSH
73147: CALL_OW 380
// un := CreateHuman ;
73151: LD_ADDR_VAR 0 14
73155: PUSH
73156: CALL_OW 44
73160: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
73161: LD_ADDR_VAR 0 7
73165: PUSH
73166: LD_VAR 0 7
73170: PPUSH
73171: LD_INT 1
73173: PPUSH
73174: LD_VAR 0 14
73178: PPUSH
73179: CALL_OW 2
73183: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
73184: LD_VAR 0 14
73188: PPUSH
73189: LD_VAR 0 1
73193: PPUSH
73194: CALL_OW 250
73198: PPUSH
73199: LD_VAR 0 1
73203: PPUSH
73204: CALL_OW 251
73208: PPUSH
73209: LD_INT 10
73211: PPUSH
73212: LD_INT 0
73214: PPUSH
73215: CALL_OW 50
// continue ;
73219: GO 73120
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
73221: LD_VAR 0 12
73225: PUSH
73226: LD_INT 1
73228: ARRAY
73229: PPUSH
73230: CALL_OW 313
73234: PUSH
73235: LD_VAR 0 12
73239: PUSH
73240: LD_INT 1
73242: ARRAY
73243: PPUSH
73244: CALL_OW 266
73248: PUSH
73249: LD_INT 32
73251: PUSH
73252: LD_INT 31
73254: PUSH
73255: EMPTY
73256: LIST
73257: LIST
73258: IN
73259: AND
73260: PUSH
73261: LD_VAR 0 12
73265: PUSH
73266: LD_INT 1
73268: ARRAY
73269: PPUSH
73270: CALL_OW 313
73274: PUSH
73275: LD_INT 6
73277: EQUAL
73278: OR
73279: IFFALSE 73299
// f := Delete ( f , 1 ) ;
73281: LD_ADDR_VAR 0 12
73285: PUSH
73286: LD_VAR 0 12
73290: PPUSH
73291: LD_INT 1
73293: PPUSH
73294: CALL_OW 3
73298: ST_TO_ADDR
// if not f then
73299: LD_VAR 0 12
73303: NOT
73304: IFFALSE 73322
// begin x := x + 2 ;
73306: LD_ADDR_VAR 0 13
73310: PUSH
73311: LD_VAR 0 13
73315: PUSH
73316: LD_INT 2
73318: PLUS
73319: ST_TO_ADDR
// continue ;
73320: GO 73120
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
73322: LD_VAR 0 12
73326: PUSH
73327: LD_INT 1
73329: ARRAY
73330: PPUSH
73331: CALL_OW 266
73335: PUSH
73336: LD_INT 5
73338: EQUAL
73339: IFFALSE 73413
// begin if UnitsInside ( f [ 1 ] ) < 3 then
73341: LD_VAR 0 12
73345: PUSH
73346: LD_INT 1
73348: ARRAY
73349: PPUSH
73350: CALL_OW 313
73354: PUSH
73355: LD_INT 3
73357: LESS
73358: IFFALSE 73394
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
73360: LD_INT 0
73362: PPUSH
73363: LD_INT 5
73365: PUSH
73366: LD_INT 8
73368: PUSH
73369: LD_INT 9
73371: PUSH
73372: EMPTY
73373: LIST
73374: LIST
73375: LIST
73376: PUSH
73377: LD_VAR 0 17
73381: ARRAY
73382: PPUSH
73383: LD_VAR 0 4
73387: PPUSH
73388: CALL_OW 380
73392: GO 73411
// PrepareHuman ( false , i , skill ) ;
73394: LD_INT 0
73396: PPUSH
73397: LD_VAR 0 8
73401: PPUSH
73402: LD_VAR 0 4
73406: PPUSH
73407: CALL_OW 380
// end else
73411: GO 73430
// PrepareHuman ( false , i , skill ) ;
73413: LD_INT 0
73415: PPUSH
73416: LD_VAR 0 8
73420: PPUSH
73421: LD_VAR 0 4
73425: PPUSH
73426: CALL_OW 380
// un := CreateHuman ;
73430: LD_ADDR_VAR 0 14
73434: PUSH
73435: CALL_OW 44
73439: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
73440: LD_ADDR_VAR 0 7
73444: PUSH
73445: LD_VAR 0 7
73449: PPUSH
73450: LD_INT 1
73452: PPUSH
73453: LD_VAR 0 14
73457: PPUSH
73458: CALL_OW 2
73462: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
73463: LD_VAR 0 14
73467: PPUSH
73468: LD_VAR 0 12
73472: PUSH
73473: LD_INT 1
73475: ARRAY
73476: PPUSH
73477: CALL_OW 52
// end ;
73481: GO 73120
73483: POP
73484: POP
// end ;
73485: GO 72422
73487: POP
73488: POP
// result := result ^ buildings ;
73489: LD_ADDR_VAR 0 7
73493: PUSH
73494: LD_VAR 0 7
73498: PUSH
73499: LD_VAR 0 18
73503: ADD
73504: ST_TO_ADDR
// end else
73505: GO 73648
// begin for i = 1 to personel do
73507: LD_ADDR_VAR 0 8
73511: PUSH
73512: DOUBLE
73513: LD_INT 1
73515: DEC
73516: ST_TO_ADDR
73517: LD_VAR 0 6
73521: PUSH
73522: FOR_TO
73523: IFFALSE 73646
// begin if i > 4 then
73525: LD_VAR 0 8
73529: PUSH
73530: LD_INT 4
73532: GREATER
73533: IFFALSE 73537
// break ;
73535: GO 73646
// x := personel [ i ] ;
73537: LD_ADDR_VAR 0 13
73541: PUSH
73542: LD_VAR 0 6
73546: PUSH
73547: LD_VAR 0 8
73551: ARRAY
73552: ST_TO_ADDR
// if x = - 1 then
73553: LD_VAR 0 13
73557: PUSH
73558: LD_INT 1
73560: NEG
73561: EQUAL
73562: IFFALSE 73566
// continue ;
73564: GO 73522
// PrepareHuman ( false , i , skill ) ;
73566: LD_INT 0
73568: PPUSH
73569: LD_VAR 0 8
73573: PPUSH
73574: LD_VAR 0 4
73578: PPUSH
73579: CALL_OW 380
// un := CreateHuman ;
73583: LD_ADDR_VAR 0 14
73587: PUSH
73588: CALL_OW 44
73592: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
73593: LD_VAR 0 14
73597: PPUSH
73598: LD_VAR 0 1
73602: PPUSH
73603: CALL_OW 250
73607: PPUSH
73608: LD_VAR 0 1
73612: PPUSH
73613: CALL_OW 251
73617: PPUSH
73618: LD_INT 10
73620: PPUSH
73621: LD_INT 0
73623: PPUSH
73624: CALL_OW 50
// result := result ^ un ;
73628: LD_ADDR_VAR 0 7
73632: PUSH
73633: LD_VAR 0 7
73637: PUSH
73638: LD_VAR 0 14
73642: ADD
73643: ST_TO_ADDR
// end ;
73644: GO 73522
73646: POP
73647: POP
// end ; end ;
73648: LD_VAR 0 7
73652: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
73653: LD_INT 0
73655: PPUSH
73656: PPUSH
73657: PPUSH
73658: PPUSH
73659: PPUSH
73660: PPUSH
73661: PPUSH
73662: PPUSH
73663: PPUSH
73664: PPUSH
73665: PPUSH
73666: PPUSH
73667: PPUSH
73668: PPUSH
73669: PPUSH
73670: PPUSH
// result := false ;
73671: LD_ADDR_VAR 0 3
73675: PUSH
73676: LD_INT 0
73678: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
73679: LD_VAR 0 1
73683: NOT
73684: PUSH
73685: LD_VAR 0 1
73689: PPUSH
73690: CALL_OW 266
73694: PUSH
73695: LD_INT 32
73697: PUSH
73698: LD_INT 33
73700: PUSH
73701: EMPTY
73702: LIST
73703: LIST
73704: IN
73705: NOT
73706: OR
73707: IFFALSE 73711
// exit ;
73709: GO 74847
// nat := GetNation ( tower ) ;
73711: LD_ADDR_VAR 0 12
73715: PUSH
73716: LD_VAR 0 1
73720: PPUSH
73721: CALL_OW 248
73725: ST_TO_ADDR
// side := GetSide ( tower ) ;
73726: LD_ADDR_VAR 0 16
73730: PUSH
73731: LD_VAR 0 1
73735: PPUSH
73736: CALL_OW 255
73740: ST_TO_ADDR
// x := GetX ( tower ) ;
73741: LD_ADDR_VAR 0 10
73745: PUSH
73746: LD_VAR 0 1
73750: PPUSH
73751: CALL_OW 250
73755: ST_TO_ADDR
// y := GetY ( tower ) ;
73756: LD_ADDR_VAR 0 11
73760: PUSH
73761: LD_VAR 0 1
73765: PPUSH
73766: CALL_OW 251
73770: ST_TO_ADDR
// if not x or not y then
73771: LD_VAR 0 10
73775: NOT
73776: PUSH
73777: LD_VAR 0 11
73781: NOT
73782: OR
73783: IFFALSE 73787
// exit ;
73785: GO 74847
// weapon := 0 ;
73787: LD_ADDR_VAR 0 18
73791: PUSH
73792: LD_INT 0
73794: ST_TO_ADDR
// fac_list := [ ] ;
73795: LD_ADDR_VAR 0 17
73799: PUSH
73800: EMPTY
73801: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
73802: LD_ADDR_VAR 0 6
73806: PUSH
73807: LD_VAR 0 1
73811: PPUSH
73812: CALL_OW 274
73816: PPUSH
73817: LD_VAR 0 2
73821: PPUSH
73822: CALL 71425 0 2
73826: PPUSH
73827: LD_INT 30
73829: PUSH
73830: LD_INT 3
73832: PUSH
73833: EMPTY
73834: LIST
73835: LIST
73836: PPUSH
73837: CALL_OW 72
73841: ST_TO_ADDR
// if not factories then
73842: LD_VAR 0 6
73846: NOT
73847: IFFALSE 73851
// exit ;
73849: GO 74847
// for i in factories do
73851: LD_ADDR_VAR 0 8
73855: PUSH
73856: LD_VAR 0 6
73860: PUSH
73861: FOR_IN
73862: IFFALSE 73887
// fac_list := fac_list union AvailableWeaponList ( i ) ;
73864: LD_ADDR_VAR 0 17
73868: PUSH
73869: LD_VAR 0 17
73873: PUSH
73874: LD_VAR 0 8
73878: PPUSH
73879: CALL_OW 478
73883: UNION
73884: ST_TO_ADDR
73885: GO 73861
73887: POP
73888: POP
// if not fac_list then
73889: LD_VAR 0 17
73893: NOT
73894: IFFALSE 73898
// exit ;
73896: GO 74847
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
73898: LD_ADDR_VAR 0 5
73902: PUSH
73903: LD_INT 4
73905: PUSH
73906: LD_INT 5
73908: PUSH
73909: LD_INT 9
73911: PUSH
73912: LD_INT 10
73914: PUSH
73915: LD_INT 6
73917: PUSH
73918: LD_INT 7
73920: PUSH
73921: LD_INT 11
73923: PUSH
73924: EMPTY
73925: LIST
73926: LIST
73927: LIST
73928: LIST
73929: LIST
73930: LIST
73931: LIST
73932: PUSH
73933: LD_INT 27
73935: PUSH
73936: LD_INT 28
73938: PUSH
73939: LD_INT 26
73941: PUSH
73942: LD_INT 30
73944: PUSH
73945: EMPTY
73946: LIST
73947: LIST
73948: LIST
73949: LIST
73950: PUSH
73951: LD_INT 43
73953: PUSH
73954: LD_INT 44
73956: PUSH
73957: LD_INT 46
73959: PUSH
73960: LD_INT 45
73962: PUSH
73963: LD_INT 47
73965: PUSH
73966: LD_INT 49
73968: PUSH
73969: EMPTY
73970: LIST
73971: LIST
73972: LIST
73973: LIST
73974: LIST
73975: LIST
73976: PUSH
73977: EMPTY
73978: LIST
73979: LIST
73980: LIST
73981: PUSH
73982: LD_VAR 0 12
73986: ARRAY
73987: ST_TO_ADDR
// for i in list do
73988: LD_ADDR_VAR 0 8
73992: PUSH
73993: LD_VAR 0 5
73997: PUSH
73998: FOR_IN
73999: IFFALSE 74032
// if not i in fac_list then
74001: LD_VAR 0 8
74005: PUSH
74006: LD_VAR 0 17
74010: IN
74011: NOT
74012: IFFALSE 74030
// list := list diff i ;
74014: LD_ADDR_VAR 0 5
74018: PUSH
74019: LD_VAR 0 5
74023: PUSH
74024: LD_VAR 0 8
74028: DIFF
74029: ST_TO_ADDR
74030: GO 73998
74032: POP
74033: POP
// if not list then
74034: LD_VAR 0 5
74038: NOT
74039: IFFALSE 74043
// exit ;
74041: GO 74847
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
74043: LD_VAR 0 12
74047: PUSH
74048: LD_INT 3
74050: EQUAL
74051: PUSH
74052: LD_INT 49
74054: PUSH
74055: LD_VAR 0 5
74059: IN
74060: AND
74061: PUSH
74062: LD_INT 31
74064: PPUSH
74065: LD_VAR 0 16
74069: PPUSH
74070: CALL_OW 321
74074: PUSH
74075: LD_INT 2
74077: EQUAL
74078: AND
74079: IFFALSE 74139
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
74081: LD_INT 22
74083: PUSH
74084: LD_VAR 0 16
74088: PUSH
74089: EMPTY
74090: LIST
74091: LIST
74092: PUSH
74093: LD_INT 35
74095: PUSH
74096: LD_INT 49
74098: PUSH
74099: EMPTY
74100: LIST
74101: LIST
74102: PUSH
74103: LD_INT 91
74105: PUSH
74106: LD_VAR 0 1
74110: PUSH
74111: LD_INT 10
74113: PUSH
74114: EMPTY
74115: LIST
74116: LIST
74117: LIST
74118: PUSH
74119: EMPTY
74120: LIST
74121: LIST
74122: LIST
74123: PPUSH
74124: CALL_OW 69
74128: NOT
74129: IFFALSE 74139
// weapon := ru_time_lapser ;
74131: LD_ADDR_VAR 0 18
74135: PUSH
74136: LD_INT 49
74138: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
74139: LD_VAR 0 12
74143: PUSH
74144: LD_INT 1
74146: PUSH
74147: LD_INT 2
74149: PUSH
74150: EMPTY
74151: LIST
74152: LIST
74153: IN
74154: PUSH
74155: LD_INT 11
74157: PUSH
74158: LD_VAR 0 5
74162: IN
74163: PUSH
74164: LD_INT 30
74166: PUSH
74167: LD_VAR 0 5
74171: IN
74172: OR
74173: AND
74174: PUSH
74175: LD_INT 6
74177: PPUSH
74178: LD_VAR 0 16
74182: PPUSH
74183: CALL_OW 321
74187: PUSH
74188: LD_INT 2
74190: EQUAL
74191: AND
74192: IFFALSE 74357
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
74194: LD_INT 22
74196: PUSH
74197: LD_VAR 0 16
74201: PUSH
74202: EMPTY
74203: LIST
74204: LIST
74205: PUSH
74206: LD_INT 2
74208: PUSH
74209: LD_INT 35
74211: PUSH
74212: LD_INT 11
74214: PUSH
74215: EMPTY
74216: LIST
74217: LIST
74218: PUSH
74219: LD_INT 35
74221: PUSH
74222: LD_INT 30
74224: PUSH
74225: EMPTY
74226: LIST
74227: LIST
74228: PUSH
74229: EMPTY
74230: LIST
74231: LIST
74232: LIST
74233: PUSH
74234: LD_INT 91
74236: PUSH
74237: LD_VAR 0 1
74241: PUSH
74242: LD_INT 18
74244: PUSH
74245: EMPTY
74246: LIST
74247: LIST
74248: LIST
74249: PUSH
74250: EMPTY
74251: LIST
74252: LIST
74253: LIST
74254: PPUSH
74255: CALL_OW 69
74259: NOT
74260: PUSH
74261: LD_INT 22
74263: PUSH
74264: LD_VAR 0 16
74268: PUSH
74269: EMPTY
74270: LIST
74271: LIST
74272: PUSH
74273: LD_INT 2
74275: PUSH
74276: LD_INT 30
74278: PUSH
74279: LD_INT 32
74281: PUSH
74282: EMPTY
74283: LIST
74284: LIST
74285: PUSH
74286: LD_INT 30
74288: PUSH
74289: LD_INT 33
74291: PUSH
74292: EMPTY
74293: LIST
74294: LIST
74295: PUSH
74296: EMPTY
74297: LIST
74298: LIST
74299: LIST
74300: PUSH
74301: LD_INT 91
74303: PUSH
74304: LD_VAR 0 1
74308: PUSH
74309: LD_INT 12
74311: PUSH
74312: EMPTY
74313: LIST
74314: LIST
74315: LIST
74316: PUSH
74317: EMPTY
74318: LIST
74319: LIST
74320: LIST
74321: PUSH
74322: EMPTY
74323: LIST
74324: PPUSH
74325: CALL_OW 69
74329: PUSH
74330: LD_INT 2
74332: GREATER
74333: AND
74334: IFFALSE 74357
// weapon := [ us_radar , ar_radar ] [ nat ] ;
74336: LD_ADDR_VAR 0 18
74340: PUSH
74341: LD_INT 11
74343: PUSH
74344: LD_INT 30
74346: PUSH
74347: EMPTY
74348: LIST
74349: LIST
74350: PUSH
74351: LD_VAR 0 12
74355: ARRAY
74356: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
74357: LD_VAR 0 18
74361: NOT
74362: PUSH
74363: LD_INT 40
74365: PPUSH
74366: LD_VAR 0 16
74370: PPUSH
74371: CALL_OW 321
74375: PUSH
74376: LD_INT 2
74378: EQUAL
74379: AND
74380: PUSH
74381: LD_INT 7
74383: PUSH
74384: LD_VAR 0 5
74388: IN
74389: PUSH
74390: LD_INT 28
74392: PUSH
74393: LD_VAR 0 5
74397: IN
74398: OR
74399: PUSH
74400: LD_INT 45
74402: PUSH
74403: LD_VAR 0 5
74407: IN
74408: OR
74409: AND
74410: IFFALSE 74664
// begin hex := GetHexInfo ( x , y ) ;
74412: LD_ADDR_VAR 0 4
74416: PUSH
74417: LD_VAR 0 10
74421: PPUSH
74422: LD_VAR 0 11
74426: PPUSH
74427: CALL_OW 546
74431: ST_TO_ADDR
// if hex [ 1 ] then
74432: LD_VAR 0 4
74436: PUSH
74437: LD_INT 1
74439: ARRAY
74440: IFFALSE 74444
// exit ;
74442: GO 74847
// height := hex [ 2 ] ;
74444: LD_ADDR_VAR 0 15
74448: PUSH
74449: LD_VAR 0 4
74453: PUSH
74454: LD_INT 2
74456: ARRAY
74457: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
74458: LD_ADDR_VAR 0 14
74462: PUSH
74463: LD_INT 0
74465: PUSH
74466: LD_INT 2
74468: PUSH
74469: LD_INT 3
74471: PUSH
74472: LD_INT 5
74474: PUSH
74475: EMPTY
74476: LIST
74477: LIST
74478: LIST
74479: LIST
74480: ST_TO_ADDR
// for i in tmp do
74481: LD_ADDR_VAR 0 8
74485: PUSH
74486: LD_VAR 0 14
74490: PUSH
74491: FOR_IN
74492: IFFALSE 74662
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
74494: LD_ADDR_VAR 0 9
74498: PUSH
74499: LD_VAR 0 10
74503: PPUSH
74504: LD_VAR 0 8
74508: PPUSH
74509: LD_INT 5
74511: PPUSH
74512: CALL_OW 272
74516: PUSH
74517: LD_VAR 0 11
74521: PPUSH
74522: LD_VAR 0 8
74526: PPUSH
74527: LD_INT 5
74529: PPUSH
74530: CALL_OW 273
74534: PUSH
74535: EMPTY
74536: LIST
74537: LIST
74538: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
74539: LD_VAR 0 9
74543: PUSH
74544: LD_INT 1
74546: ARRAY
74547: PPUSH
74548: LD_VAR 0 9
74552: PUSH
74553: LD_INT 2
74555: ARRAY
74556: PPUSH
74557: CALL_OW 488
74561: IFFALSE 74660
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
74563: LD_ADDR_VAR 0 4
74567: PUSH
74568: LD_VAR 0 9
74572: PUSH
74573: LD_INT 1
74575: ARRAY
74576: PPUSH
74577: LD_VAR 0 9
74581: PUSH
74582: LD_INT 2
74584: ARRAY
74585: PPUSH
74586: CALL_OW 546
74590: ST_TO_ADDR
// if hex [ 1 ] then
74591: LD_VAR 0 4
74595: PUSH
74596: LD_INT 1
74598: ARRAY
74599: IFFALSE 74603
// continue ;
74601: GO 74491
// h := hex [ 2 ] ;
74603: LD_ADDR_VAR 0 13
74607: PUSH
74608: LD_VAR 0 4
74612: PUSH
74613: LD_INT 2
74615: ARRAY
74616: ST_TO_ADDR
// if h + 7 < height then
74617: LD_VAR 0 13
74621: PUSH
74622: LD_INT 7
74624: PLUS
74625: PUSH
74626: LD_VAR 0 15
74630: LESS
74631: IFFALSE 74660
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
74633: LD_ADDR_VAR 0 18
74637: PUSH
74638: LD_INT 7
74640: PUSH
74641: LD_INT 28
74643: PUSH
74644: LD_INT 45
74646: PUSH
74647: EMPTY
74648: LIST
74649: LIST
74650: LIST
74651: PUSH
74652: LD_VAR 0 12
74656: ARRAY
74657: ST_TO_ADDR
// break ;
74658: GO 74662
// end ; end ; end ;
74660: GO 74491
74662: POP
74663: POP
// end ; if not weapon then
74664: LD_VAR 0 18
74668: NOT
74669: IFFALSE 74729
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
74671: LD_ADDR_VAR 0 5
74675: PUSH
74676: LD_VAR 0 5
74680: PUSH
74681: LD_INT 11
74683: PUSH
74684: LD_INT 30
74686: PUSH
74687: LD_INT 49
74689: PUSH
74690: EMPTY
74691: LIST
74692: LIST
74693: LIST
74694: DIFF
74695: ST_TO_ADDR
// if not list then
74696: LD_VAR 0 5
74700: NOT
74701: IFFALSE 74705
// exit ;
74703: GO 74847
// weapon := list [ rand ( 1 , list ) ] ;
74705: LD_ADDR_VAR 0 18
74709: PUSH
74710: LD_VAR 0 5
74714: PUSH
74715: LD_INT 1
74717: PPUSH
74718: LD_VAR 0 5
74722: PPUSH
74723: CALL_OW 12
74727: ARRAY
74728: ST_TO_ADDR
// end ; if weapon then
74729: LD_VAR 0 18
74733: IFFALSE 74847
// begin tmp := CostOfWeapon ( weapon ) ;
74735: LD_ADDR_VAR 0 14
74739: PUSH
74740: LD_VAR 0 18
74744: PPUSH
74745: CALL_OW 451
74749: ST_TO_ADDR
// j := GetBase ( tower ) ;
74750: LD_ADDR_VAR 0 9
74754: PUSH
74755: LD_VAR 0 1
74759: PPUSH
74760: CALL_OW 274
74764: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
74765: LD_VAR 0 9
74769: PPUSH
74770: LD_INT 1
74772: PPUSH
74773: CALL_OW 275
74777: PUSH
74778: LD_VAR 0 14
74782: PUSH
74783: LD_INT 1
74785: ARRAY
74786: GREATEREQUAL
74787: PUSH
74788: LD_VAR 0 9
74792: PPUSH
74793: LD_INT 2
74795: PPUSH
74796: CALL_OW 275
74800: PUSH
74801: LD_VAR 0 14
74805: PUSH
74806: LD_INT 2
74808: ARRAY
74809: GREATEREQUAL
74810: AND
74811: PUSH
74812: LD_VAR 0 9
74816: PPUSH
74817: LD_INT 3
74819: PPUSH
74820: CALL_OW 275
74824: PUSH
74825: LD_VAR 0 14
74829: PUSH
74830: LD_INT 3
74832: ARRAY
74833: GREATEREQUAL
74834: AND
74835: IFFALSE 74847
// result := weapon ;
74837: LD_ADDR_VAR 0 3
74841: PUSH
74842: LD_VAR 0 18
74846: ST_TO_ADDR
// end ; end ;
74847: LD_VAR 0 3
74851: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
74852: LD_INT 0
74854: PPUSH
74855: PPUSH
// result := true ;
74856: LD_ADDR_VAR 0 3
74860: PUSH
74861: LD_INT 1
74863: ST_TO_ADDR
// if array1 = array2 then
74864: LD_VAR 0 1
74868: PUSH
74869: LD_VAR 0 2
74873: EQUAL
74874: IFFALSE 74934
// begin for i = 1 to array1 do
74876: LD_ADDR_VAR 0 4
74880: PUSH
74881: DOUBLE
74882: LD_INT 1
74884: DEC
74885: ST_TO_ADDR
74886: LD_VAR 0 1
74890: PUSH
74891: FOR_TO
74892: IFFALSE 74930
// if array1 [ i ] <> array2 [ i ] then
74894: LD_VAR 0 1
74898: PUSH
74899: LD_VAR 0 4
74903: ARRAY
74904: PUSH
74905: LD_VAR 0 2
74909: PUSH
74910: LD_VAR 0 4
74914: ARRAY
74915: NONEQUAL
74916: IFFALSE 74928
// begin result := false ;
74918: LD_ADDR_VAR 0 3
74922: PUSH
74923: LD_INT 0
74925: ST_TO_ADDR
// break ;
74926: GO 74930
// end ;
74928: GO 74891
74930: POP
74931: POP
// end else
74932: GO 74942
// result := false ;
74934: LD_ADDR_VAR 0 3
74938: PUSH
74939: LD_INT 0
74941: ST_TO_ADDR
// end ;
74942: LD_VAR 0 3
74946: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
74947: LD_INT 0
74949: PPUSH
74950: PPUSH
74951: PPUSH
// pom := GetBase ( fac ) ;
74952: LD_ADDR_VAR 0 5
74956: PUSH
74957: LD_VAR 0 1
74961: PPUSH
74962: CALL_OW 274
74966: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
74967: LD_ADDR_VAR 0 4
74971: PUSH
74972: LD_VAR 0 2
74976: PUSH
74977: LD_INT 1
74979: ARRAY
74980: PPUSH
74981: LD_VAR 0 2
74985: PUSH
74986: LD_INT 2
74988: ARRAY
74989: PPUSH
74990: LD_VAR 0 2
74994: PUSH
74995: LD_INT 3
74997: ARRAY
74998: PPUSH
74999: LD_VAR 0 2
75003: PUSH
75004: LD_INT 4
75006: ARRAY
75007: PPUSH
75008: CALL_OW 449
75012: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
75013: LD_ADDR_VAR 0 3
75017: PUSH
75018: LD_VAR 0 5
75022: PPUSH
75023: LD_INT 1
75025: PPUSH
75026: CALL_OW 275
75030: PUSH
75031: LD_VAR 0 4
75035: PUSH
75036: LD_INT 1
75038: ARRAY
75039: GREATEREQUAL
75040: PUSH
75041: LD_VAR 0 5
75045: PPUSH
75046: LD_INT 2
75048: PPUSH
75049: CALL_OW 275
75053: PUSH
75054: LD_VAR 0 4
75058: PUSH
75059: LD_INT 2
75061: ARRAY
75062: GREATEREQUAL
75063: AND
75064: PUSH
75065: LD_VAR 0 5
75069: PPUSH
75070: LD_INT 3
75072: PPUSH
75073: CALL_OW 275
75077: PUSH
75078: LD_VAR 0 4
75082: PUSH
75083: LD_INT 3
75085: ARRAY
75086: GREATEREQUAL
75087: AND
75088: ST_TO_ADDR
// end ;
75089: LD_VAR 0 3
75093: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
75094: LD_INT 0
75096: PPUSH
75097: PPUSH
75098: PPUSH
75099: PPUSH
// pom := GetBase ( building ) ;
75100: LD_ADDR_VAR 0 3
75104: PUSH
75105: LD_VAR 0 1
75109: PPUSH
75110: CALL_OW 274
75114: ST_TO_ADDR
// if not pom then
75115: LD_VAR 0 3
75119: NOT
75120: IFFALSE 75124
// exit ;
75122: GO 75294
// btype := GetBType ( building ) ;
75124: LD_ADDR_VAR 0 5
75128: PUSH
75129: LD_VAR 0 1
75133: PPUSH
75134: CALL_OW 266
75138: ST_TO_ADDR
// if btype = b_armoury then
75139: LD_VAR 0 5
75143: PUSH
75144: LD_INT 4
75146: EQUAL
75147: IFFALSE 75157
// btype := b_barracks ;
75149: LD_ADDR_VAR 0 5
75153: PUSH
75154: LD_INT 5
75156: ST_TO_ADDR
// if btype = b_depot then
75157: LD_VAR 0 5
75161: PUSH
75162: LD_INT 0
75164: EQUAL
75165: IFFALSE 75175
// btype := b_warehouse ;
75167: LD_ADDR_VAR 0 5
75171: PUSH
75172: LD_INT 1
75174: ST_TO_ADDR
// if btype = b_workshop then
75175: LD_VAR 0 5
75179: PUSH
75180: LD_INT 2
75182: EQUAL
75183: IFFALSE 75193
// btype := b_factory ;
75185: LD_ADDR_VAR 0 5
75189: PUSH
75190: LD_INT 3
75192: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
75193: LD_ADDR_VAR 0 4
75197: PUSH
75198: LD_VAR 0 5
75202: PPUSH
75203: LD_VAR 0 1
75207: PPUSH
75208: CALL_OW 248
75212: PPUSH
75213: CALL_OW 450
75217: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
75218: LD_ADDR_VAR 0 2
75222: PUSH
75223: LD_VAR 0 3
75227: PPUSH
75228: LD_INT 1
75230: PPUSH
75231: CALL_OW 275
75235: PUSH
75236: LD_VAR 0 4
75240: PUSH
75241: LD_INT 1
75243: ARRAY
75244: GREATEREQUAL
75245: PUSH
75246: LD_VAR 0 3
75250: PPUSH
75251: LD_INT 2
75253: PPUSH
75254: CALL_OW 275
75258: PUSH
75259: LD_VAR 0 4
75263: PUSH
75264: LD_INT 2
75266: ARRAY
75267: GREATEREQUAL
75268: AND
75269: PUSH
75270: LD_VAR 0 3
75274: PPUSH
75275: LD_INT 3
75277: PPUSH
75278: CALL_OW 275
75282: PUSH
75283: LD_VAR 0 4
75287: PUSH
75288: LD_INT 3
75290: ARRAY
75291: GREATEREQUAL
75292: AND
75293: ST_TO_ADDR
// end ;
75294: LD_VAR 0 2
75298: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
75299: LD_INT 0
75301: PPUSH
75302: PPUSH
75303: PPUSH
// pom := GetBase ( building ) ;
75304: LD_ADDR_VAR 0 4
75308: PUSH
75309: LD_VAR 0 1
75313: PPUSH
75314: CALL_OW 274
75318: ST_TO_ADDR
// if not pom then
75319: LD_VAR 0 4
75323: NOT
75324: IFFALSE 75328
// exit ;
75326: GO 75429
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
75328: LD_ADDR_VAR 0 5
75332: PUSH
75333: LD_VAR 0 2
75337: PPUSH
75338: LD_VAR 0 1
75342: PPUSH
75343: CALL_OW 248
75347: PPUSH
75348: CALL_OW 450
75352: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
75353: LD_ADDR_VAR 0 3
75357: PUSH
75358: LD_VAR 0 4
75362: PPUSH
75363: LD_INT 1
75365: PPUSH
75366: CALL_OW 275
75370: PUSH
75371: LD_VAR 0 5
75375: PUSH
75376: LD_INT 1
75378: ARRAY
75379: GREATEREQUAL
75380: PUSH
75381: LD_VAR 0 4
75385: PPUSH
75386: LD_INT 2
75388: PPUSH
75389: CALL_OW 275
75393: PUSH
75394: LD_VAR 0 5
75398: PUSH
75399: LD_INT 2
75401: ARRAY
75402: GREATEREQUAL
75403: AND
75404: PUSH
75405: LD_VAR 0 4
75409: PPUSH
75410: LD_INT 3
75412: PPUSH
75413: CALL_OW 275
75417: PUSH
75418: LD_VAR 0 5
75422: PUSH
75423: LD_INT 3
75425: ARRAY
75426: GREATEREQUAL
75427: AND
75428: ST_TO_ADDR
// end ;
75429: LD_VAR 0 3
75433: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
75434: LD_INT 0
75436: PPUSH
75437: PPUSH
75438: PPUSH
75439: PPUSH
75440: PPUSH
75441: PPUSH
75442: PPUSH
75443: PPUSH
75444: PPUSH
75445: PPUSH
// result := false ;
75446: LD_ADDR_VAR 0 6
75450: PUSH
75451: LD_INT 0
75453: ST_TO_ADDR
// if not base or not btype or not x or not y then
75454: LD_VAR 0 1
75458: NOT
75459: PUSH
75460: LD_VAR 0 2
75464: NOT
75465: OR
75466: PUSH
75467: LD_VAR 0 3
75471: NOT
75472: OR
75473: PUSH
75474: LD_VAR 0 4
75478: NOT
75479: OR
75480: IFFALSE 75484
// exit ;
75482: GO 76075
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
75484: LD_ADDR_VAR 0 12
75488: PUSH
75489: LD_VAR 0 2
75493: PPUSH
75494: LD_VAR 0 3
75498: PPUSH
75499: LD_VAR 0 4
75503: PPUSH
75504: LD_VAR 0 5
75508: PPUSH
75509: LD_VAR 0 1
75513: PUSH
75514: LD_INT 1
75516: ARRAY
75517: PPUSH
75518: CALL_OW 248
75522: PPUSH
75523: LD_INT 0
75525: PPUSH
75526: CALL 76912 0 6
75530: ST_TO_ADDR
// if not hexes then
75531: LD_VAR 0 12
75535: NOT
75536: IFFALSE 75540
// exit ;
75538: GO 76075
// for i = 1 to hexes do
75540: LD_ADDR_VAR 0 7
75544: PUSH
75545: DOUBLE
75546: LD_INT 1
75548: DEC
75549: ST_TO_ADDR
75550: LD_VAR 0 12
75554: PUSH
75555: FOR_TO
75556: IFFALSE 76073
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
75558: LD_ADDR_VAR 0 11
75562: PUSH
75563: LD_VAR 0 12
75567: PUSH
75568: LD_VAR 0 7
75572: ARRAY
75573: PUSH
75574: LD_INT 1
75576: ARRAY
75577: PPUSH
75578: LD_VAR 0 12
75582: PUSH
75583: LD_VAR 0 7
75587: ARRAY
75588: PUSH
75589: LD_INT 2
75591: ARRAY
75592: PPUSH
75593: CALL_OW 428
75597: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
75598: LD_VAR 0 12
75602: PUSH
75603: LD_VAR 0 7
75607: ARRAY
75608: PUSH
75609: LD_INT 1
75611: ARRAY
75612: PPUSH
75613: LD_VAR 0 12
75617: PUSH
75618: LD_VAR 0 7
75622: ARRAY
75623: PUSH
75624: LD_INT 2
75626: ARRAY
75627: PPUSH
75628: CALL_OW 351
75632: PUSH
75633: LD_VAR 0 12
75637: PUSH
75638: LD_VAR 0 7
75642: ARRAY
75643: PUSH
75644: LD_INT 1
75646: ARRAY
75647: PPUSH
75648: LD_VAR 0 12
75652: PUSH
75653: LD_VAR 0 7
75657: ARRAY
75658: PUSH
75659: LD_INT 2
75661: ARRAY
75662: PPUSH
75663: CALL_OW 488
75667: NOT
75668: OR
75669: PUSH
75670: LD_VAR 0 11
75674: PPUSH
75675: CALL_OW 247
75679: PUSH
75680: LD_INT 3
75682: EQUAL
75683: OR
75684: IFFALSE 75690
// exit ;
75686: POP
75687: POP
75688: GO 76075
// if not tmp then
75690: LD_VAR 0 11
75694: NOT
75695: IFFALSE 75699
// continue ;
75697: GO 75555
// result := true ;
75699: LD_ADDR_VAR 0 6
75703: PUSH
75704: LD_INT 1
75706: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
75707: LD_ADDR_VAR 0 15
75711: PUSH
75712: LD_INT 22
75714: PUSH
75715: LD_VAR 0 11
75719: PPUSH
75720: CALL_OW 255
75724: PUSH
75725: EMPTY
75726: LIST
75727: LIST
75728: PUSH
75729: LD_INT 2
75731: PUSH
75732: LD_INT 30
75734: PUSH
75735: LD_INT 0
75737: PUSH
75738: EMPTY
75739: LIST
75740: LIST
75741: PUSH
75742: LD_INT 30
75744: PUSH
75745: LD_INT 1
75747: PUSH
75748: EMPTY
75749: LIST
75750: LIST
75751: PUSH
75752: EMPTY
75753: LIST
75754: LIST
75755: LIST
75756: PUSH
75757: EMPTY
75758: LIST
75759: LIST
75760: PPUSH
75761: CALL_OW 69
75765: ST_TO_ADDR
// if dep then
75766: LD_VAR 0 15
75770: IFFALSE 75906
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
75772: LD_ADDR_VAR 0 14
75776: PUSH
75777: LD_VAR 0 15
75781: PUSH
75782: LD_INT 1
75784: ARRAY
75785: PPUSH
75786: CALL_OW 250
75790: PPUSH
75791: LD_VAR 0 15
75795: PUSH
75796: LD_INT 1
75798: ARRAY
75799: PPUSH
75800: CALL_OW 254
75804: PPUSH
75805: LD_INT 5
75807: PPUSH
75808: CALL_OW 272
75812: PUSH
75813: LD_VAR 0 15
75817: PUSH
75818: LD_INT 1
75820: ARRAY
75821: PPUSH
75822: CALL_OW 251
75826: PPUSH
75827: LD_VAR 0 15
75831: PUSH
75832: LD_INT 1
75834: ARRAY
75835: PPUSH
75836: CALL_OW 254
75840: PPUSH
75841: LD_INT 5
75843: PPUSH
75844: CALL_OW 273
75848: PUSH
75849: EMPTY
75850: LIST
75851: LIST
75852: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
75853: LD_VAR 0 14
75857: PUSH
75858: LD_INT 1
75860: ARRAY
75861: PPUSH
75862: LD_VAR 0 14
75866: PUSH
75867: LD_INT 2
75869: ARRAY
75870: PPUSH
75871: CALL_OW 488
75875: IFFALSE 75906
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
75877: LD_VAR 0 11
75881: PPUSH
75882: LD_VAR 0 14
75886: PUSH
75887: LD_INT 1
75889: ARRAY
75890: PPUSH
75891: LD_VAR 0 14
75895: PUSH
75896: LD_INT 2
75898: ARRAY
75899: PPUSH
75900: CALL_OW 111
// continue ;
75904: GO 75555
// end ; end ; r := GetDir ( tmp ) ;
75906: LD_ADDR_VAR 0 13
75910: PUSH
75911: LD_VAR 0 11
75915: PPUSH
75916: CALL_OW 254
75920: ST_TO_ADDR
// if r = 5 then
75921: LD_VAR 0 13
75925: PUSH
75926: LD_INT 5
75928: EQUAL
75929: IFFALSE 75939
// r := 0 ;
75931: LD_ADDR_VAR 0 13
75935: PUSH
75936: LD_INT 0
75938: ST_TO_ADDR
// for j = r to 5 do
75939: LD_ADDR_VAR 0 8
75943: PUSH
75944: DOUBLE
75945: LD_VAR 0 13
75949: DEC
75950: ST_TO_ADDR
75951: LD_INT 5
75953: PUSH
75954: FOR_TO
75955: IFFALSE 76069
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
75957: LD_ADDR_VAR 0 9
75961: PUSH
75962: LD_VAR 0 11
75966: PPUSH
75967: CALL_OW 250
75971: PPUSH
75972: LD_VAR 0 8
75976: PPUSH
75977: LD_INT 2
75979: PPUSH
75980: CALL_OW 272
75984: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
75985: LD_ADDR_VAR 0 10
75989: PUSH
75990: LD_VAR 0 11
75994: PPUSH
75995: CALL_OW 251
75999: PPUSH
76000: LD_VAR 0 8
76004: PPUSH
76005: LD_INT 2
76007: PPUSH
76008: CALL_OW 273
76012: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
76013: LD_VAR 0 9
76017: PPUSH
76018: LD_VAR 0 10
76022: PPUSH
76023: CALL_OW 488
76027: PUSH
76028: LD_VAR 0 9
76032: PPUSH
76033: LD_VAR 0 10
76037: PPUSH
76038: CALL_OW 428
76042: NOT
76043: AND
76044: IFFALSE 76067
// begin ComMoveXY ( tmp , _x , _y ) ;
76046: LD_VAR 0 11
76050: PPUSH
76051: LD_VAR 0 9
76055: PPUSH
76056: LD_VAR 0 10
76060: PPUSH
76061: CALL_OW 111
// break ;
76065: GO 76069
// end ; end ;
76067: GO 75954
76069: POP
76070: POP
// end ;
76071: GO 75555
76073: POP
76074: POP
// end ;
76075: LD_VAR 0 6
76079: RET
// export function CanBeBuilded ( bdepot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
76080: LD_INT 0
76082: PPUSH
76083: PPUSH
76084: PPUSH
76085: PPUSH
76086: PPUSH
76087: PPUSH
76088: PPUSH
76089: PPUSH
76090: PPUSH
76091: PPUSH
// result := false ;
76092: LD_ADDR_VAR 0 6
76096: PUSH
76097: LD_INT 0
76099: ST_TO_ADDR
// if not bdepot or not GetBType ( bdepot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
76100: LD_VAR 0 1
76104: NOT
76105: PUSH
76106: LD_VAR 0 1
76110: PPUSH
76111: CALL_OW 266
76115: PUSH
76116: LD_INT 0
76118: PUSH
76119: LD_INT 1
76121: PUSH
76122: EMPTY
76123: LIST
76124: LIST
76125: IN
76126: NOT
76127: OR
76128: PUSH
76129: LD_VAR 0 2
76133: NOT
76134: OR
76135: PUSH
76136: LD_VAR 0 5
76140: PUSH
76141: LD_INT 0
76143: PUSH
76144: LD_INT 1
76146: PUSH
76147: LD_INT 2
76149: PUSH
76150: LD_INT 3
76152: PUSH
76153: LD_INT 4
76155: PUSH
76156: LD_INT 5
76158: PUSH
76159: EMPTY
76160: LIST
76161: LIST
76162: LIST
76163: LIST
76164: LIST
76165: LIST
76166: IN
76167: NOT
76168: OR
76169: PUSH
76170: LD_VAR 0 3
76174: PPUSH
76175: LD_VAR 0 4
76179: PPUSH
76180: CALL_OW 488
76184: NOT
76185: OR
76186: IFFALSE 76190
// exit ;
76188: GO 76907
// pom := GetBase ( bdepot ) ;
76190: LD_ADDR_VAR 0 10
76194: PUSH
76195: LD_VAR 0 1
76199: PPUSH
76200: CALL_OW 274
76204: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
76205: LD_ADDR_VAR 0 11
76209: PUSH
76210: LD_VAR 0 2
76214: PPUSH
76215: LD_VAR 0 1
76219: PPUSH
76220: CALL_OW 248
76224: PPUSH
76225: CALL_OW 450
76229: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
76230: LD_VAR 0 10
76234: PPUSH
76235: LD_INT 1
76237: PPUSH
76238: CALL_OW 275
76242: PUSH
76243: LD_VAR 0 11
76247: PUSH
76248: LD_INT 1
76250: ARRAY
76251: GREATEREQUAL
76252: PUSH
76253: LD_VAR 0 10
76257: PPUSH
76258: LD_INT 2
76260: PPUSH
76261: CALL_OW 275
76265: PUSH
76266: LD_VAR 0 11
76270: PUSH
76271: LD_INT 2
76273: ARRAY
76274: GREATEREQUAL
76275: AND
76276: PUSH
76277: LD_VAR 0 10
76281: PPUSH
76282: LD_INT 3
76284: PPUSH
76285: CALL_OW 275
76289: PUSH
76290: LD_VAR 0 11
76294: PUSH
76295: LD_INT 3
76297: ARRAY
76298: GREATEREQUAL
76299: AND
76300: NOT
76301: IFFALSE 76305
// exit ;
76303: GO 76907
// if GetBType ( bdepot ) = b_depot then
76305: LD_VAR 0 1
76309: PPUSH
76310: CALL_OW 266
76314: PUSH
76315: LD_INT 0
76317: EQUAL
76318: IFFALSE 76330
// dist := 28 else
76320: LD_ADDR_VAR 0 14
76324: PUSH
76325: LD_INT 28
76327: ST_TO_ADDR
76328: GO 76338
// dist := 36 ;
76330: LD_ADDR_VAR 0 14
76334: PUSH
76335: LD_INT 36
76337: ST_TO_ADDR
// if GetDistUnitXY ( bdepot , x , y ) > dist then
76338: LD_VAR 0 1
76342: PPUSH
76343: LD_VAR 0 3
76347: PPUSH
76348: LD_VAR 0 4
76352: PPUSH
76353: CALL_OW 297
76357: PUSH
76358: LD_VAR 0 14
76362: GREATER
76363: IFFALSE 76367
// exit ;
76365: GO 76907
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( bdepot ) , 0 ) ;
76367: LD_ADDR_VAR 0 12
76371: PUSH
76372: LD_VAR 0 2
76376: PPUSH
76377: LD_VAR 0 3
76381: PPUSH
76382: LD_VAR 0 4
76386: PPUSH
76387: LD_VAR 0 5
76391: PPUSH
76392: LD_VAR 0 1
76396: PPUSH
76397: CALL_OW 248
76401: PPUSH
76402: LD_INT 0
76404: PPUSH
76405: CALL 76912 0 6
76409: ST_TO_ADDR
// if not hexes then
76410: LD_VAR 0 12
76414: NOT
76415: IFFALSE 76419
// exit ;
76417: GO 76907
// hex := GetHexInfo ( x , y ) ;
76419: LD_ADDR_VAR 0 15
76423: PUSH
76424: LD_VAR 0 3
76428: PPUSH
76429: LD_VAR 0 4
76433: PPUSH
76434: CALL_OW 546
76438: ST_TO_ADDR
// if hex [ 1 ] then
76439: LD_VAR 0 15
76443: PUSH
76444: LD_INT 1
76446: ARRAY
76447: IFFALSE 76451
// exit ;
76449: GO 76907
// height := hex [ 2 ] ;
76451: LD_ADDR_VAR 0 13
76455: PUSH
76456: LD_VAR 0 15
76460: PUSH
76461: LD_INT 2
76463: ARRAY
76464: ST_TO_ADDR
// for i = 1 to hexes do
76465: LD_ADDR_VAR 0 7
76469: PUSH
76470: DOUBLE
76471: LD_INT 1
76473: DEC
76474: ST_TO_ADDR
76475: LD_VAR 0 12
76479: PUSH
76480: FOR_TO
76481: IFFALSE 76811
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
76483: LD_VAR 0 12
76487: PUSH
76488: LD_VAR 0 7
76492: ARRAY
76493: PUSH
76494: LD_INT 1
76496: ARRAY
76497: PPUSH
76498: LD_VAR 0 12
76502: PUSH
76503: LD_VAR 0 7
76507: ARRAY
76508: PUSH
76509: LD_INT 2
76511: ARRAY
76512: PPUSH
76513: CALL_OW 488
76517: NOT
76518: PUSH
76519: LD_VAR 0 12
76523: PUSH
76524: LD_VAR 0 7
76528: ARRAY
76529: PUSH
76530: LD_INT 1
76532: ARRAY
76533: PPUSH
76534: LD_VAR 0 12
76538: PUSH
76539: LD_VAR 0 7
76543: ARRAY
76544: PUSH
76545: LD_INT 2
76547: ARRAY
76548: PPUSH
76549: CALL_OW 428
76553: PUSH
76554: LD_INT 0
76556: GREATER
76557: OR
76558: PUSH
76559: LD_VAR 0 12
76563: PUSH
76564: LD_VAR 0 7
76568: ARRAY
76569: PUSH
76570: LD_INT 1
76572: ARRAY
76573: PPUSH
76574: LD_VAR 0 12
76578: PUSH
76579: LD_VAR 0 7
76583: ARRAY
76584: PUSH
76585: LD_INT 2
76587: ARRAY
76588: PPUSH
76589: CALL_OW 351
76593: OR
76594: IFFALSE 76600
// exit ;
76596: POP
76597: POP
76598: GO 76907
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
76600: LD_ADDR_VAR 0 8
76604: PUSH
76605: LD_VAR 0 12
76609: PUSH
76610: LD_VAR 0 7
76614: ARRAY
76615: PUSH
76616: LD_INT 1
76618: ARRAY
76619: PPUSH
76620: LD_VAR 0 12
76624: PUSH
76625: LD_VAR 0 7
76629: ARRAY
76630: PUSH
76631: LD_INT 2
76633: ARRAY
76634: PPUSH
76635: CALL_OW 546
76639: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
76640: LD_VAR 0 8
76644: PUSH
76645: LD_INT 1
76647: ARRAY
76648: PUSH
76649: LD_VAR 0 8
76653: PUSH
76654: LD_INT 2
76656: ARRAY
76657: PUSH
76658: LD_VAR 0 13
76662: PUSH
76663: LD_INT 2
76665: PLUS
76666: GREATER
76667: OR
76668: PUSH
76669: LD_VAR 0 8
76673: PUSH
76674: LD_INT 2
76676: ARRAY
76677: PUSH
76678: LD_VAR 0 13
76682: PUSH
76683: LD_INT 2
76685: MINUS
76686: LESS
76687: OR
76688: PUSH
76689: LD_VAR 0 8
76693: PUSH
76694: LD_INT 3
76696: ARRAY
76697: PUSH
76698: LD_INT 0
76700: PUSH
76701: LD_INT 8
76703: PUSH
76704: LD_INT 9
76706: PUSH
76707: LD_INT 10
76709: PUSH
76710: LD_INT 11
76712: PUSH
76713: LD_INT 12
76715: PUSH
76716: LD_INT 13
76718: PUSH
76719: LD_INT 16
76721: PUSH
76722: LD_INT 17
76724: PUSH
76725: LD_INT 18
76727: PUSH
76728: LD_INT 19
76730: PUSH
76731: LD_INT 20
76733: PUSH
76734: LD_INT 21
76736: PUSH
76737: EMPTY
76738: LIST
76739: LIST
76740: LIST
76741: LIST
76742: LIST
76743: LIST
76744: LIST
76745: LIST
76746: LIST
76747: LIST
76748: LIST
76749: LIST
76750: LIST
76751: IN
76752: NOT
76753: OR
76754: PUSH
76755: LD_VAR 0 8
76759: PUSH
76760: LD_INT 5
76762: ARRAY
76763: NOT
76764: OR
76765: PUSH
76766: LD_VAR 0 8
76770: PUSH
76771: LD_INT 6
76773: ARRAY
76774: PUSH
76775: LD_INT 1
76777: PUSH
76778: LD_INT 2
76780: PUSH
76781: LD_INT 7
76783: PUSH
76784: LD_INT 9
76786: PUSH
76787: LD_INT 10
76789: PUSH
76790: LD_INT 11
76792: PUSH
76793: EMPTY
76794: LIST
76795: LIST
76796: LIST
76797: LIST
76798: LIST
76799: LIST
76800: IN
76801: NOT
76802: OR
76803: IFFALSE 76809
// exit ;
76805: POP
76806: POP
76807: GO 76907
// end ;
76809: GO 76480
76811: POP
76812: POP
// side := GetSide ( bdepot ) ;
76813: LD_ADDR_VAR 0 9
76817: PUSH
76818: LD_VAR 0 1
76822: PPUSH
76823: CALL_OW 255
76827: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
76828: LD_VAR 0 9
76832: PPUSH
76833: LD_VAR 0 3
76837: PPUSH
76838: LD_VAR 0 4
76842: PPUSH
76843: LD_INT 20
76845: PPUSH
76846: CALL 69579 0 4
76850: PUSH
76851: LD_INT 4
76853: ARRAY
76854: IFFALSE 76858
// exit ;
76856: GO 76907
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
76858: LD_VAR 0 2
76862: PUSH
76863: LD_INT 29
76865: PUSH
76866: LD_INT 30
76868: PUSH
76869: EMPTY
76870: LIST
76871: LIST
76872: IN
76873: PUSH
76874: LD_VAR 0 3
76878: PPUSH
76879: LD_VAR 0 4
76883: PPUSH
76884: LD_VAR 0 9
76888: PPUSH
76889: CALL_OW 440
76893: NOT
76894: AND
76895: IFFALSE 76899
// exit ;
76897: GO 76907
// result := true ;
76899: LD_ADDR_VAR 0 6
76903: PUSH
76904: LD_INT 1
76906: ST_TO_ADDR
// end ;
76907: LD_VAR 0 6
76911: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
76912: LD_INT 0
76914: PPUSH
76915: PPUSH
76916: PPUSH
76917: PPUSH
76918: PPUSH
76919: PPUSH
76920: PPUSH
76921: PPUSH
76922: PPUSH
76923: PPUSH
76924: PPUSH
76925: PPUSH
76926: PPUSH
76927: PPUSH
76928: PPUSH
76929: PPUSH
76930: PPUSH
76931: PPUSH
76932: PPUSH
76933: PPUSH
76934: PPUSH
76935: PPUSH
76936: PPUSH
76937: PPUSH
76938: PPUSH
76939: PPUSH
76940: PPUSH
76941: PPUSH
76942: PPUSH
76943: PPUSH
76944: PPUSH
76945: PPUSH
76946: PPUSH
76947: PPUSH
76948: PPUSH
76949: PPUSH
76950: PPUSH
76951: PPUSH
76952: PPUSH
76953: PPUSH
76954: PPUSH
76955: PPUSH
76956: PPUSH
76957: PPUSH
76958: PPUSH
76959: PPUSH
76960: PPUSH
76961: PPUSH
76962: PPUSH
76963: PPUSH
76964: PPUSH
76965: PPUSH
76966: PPUSH
76967: PPUSH
76968: PPUSH
76969: PPUSH
76970: PPUSH
76971: PPUSH
// result = [ ] ;
76972: LD_ADDR_VAR 0 7
76976: PUSH
76977: EMPTY
76978: ST_TO_ADDR
// temp_list = [ ] ;
76979: LD_ADDR_VAR 0 9
76983: PUSH
76984: EMPTY
76985: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
76986: LD_VAR 0 4
76990: PUSH
76991: LD_INT 0
76993: PUSH
76994: LD_INT 1
76996: PUSH
76997: LD_INT 2
76999: PUSH
77000: LD_INT 3
77002: PUSH
77003: LD_INT 4
77005: PUSH
77006: LD_INT 5
77008: PUSH
77009: EMPTY
77010: LIST
77011: LIST
77012: LIST
77013: LIST
77014: LIST
77015: LIST
77016: IN
77017: NOT
77018: PUSH
77019: LD_VAR 0 1
77023: PUSH
77024: LD_INT 0
77026: PUSH
77027: LD_INT 1
77029: PUSH
77030: EMPTY
77031: LIST
77032: LIST
77033: IN
77034: PUSH
77035: LD_VAR 0 5
77039: PUSH
77040: LD_INT 1
77042: PUSH
77043: LD_INT 2
77045: PUSH
77046: LD_INT 3
77048: PUSH
77049: EMPTY
77050: LIST
77051: LIST
77052: LIST
77053: IN
77054: NOT
77055: AND
77056: OR
77057: IFFALSE 77061
// exit ;
77059: GO 95446
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
77061: LD_VAR 0 1
77065: PUSH
77066: LD_INT 6
77068: PUSH
77069: LD_INT 7
77071: PUSH
77072: LD_INT 8
77074: PUSH
77075: LD_INT 13
77077: PUSH
77078: LD_INT 12
77080: PUSH
77081: LD_INT 15
77083: PUSH
77084: LD_INT 11
77086: PUSH
77087: LD_INT 14
77089: PUSH
77090: LD_INT 10
77092: PUSH
77093: EMPTY
77094: LIST
77095: LIST
77096: LIST
77097: LIST
77098: LIST
77099: LIST
77100: LIST
77101: LIST
77102: LIST
77103: IN
77104: IFFALSE 77114
// btype = b_lab ;
77106: LD_ADDR_VAR 0 1
77110: PUSH
77111: LD_INT 6
77113: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
77114: LD_VAR 0 6
77118: PUSH
77119: LD_INT 0
77121: PUSH
77122: LD_INT 1
77124: PUSH
77125: LD_INT 2
77127: PUSH
77128: EMPTY
77129: LIST
77130: LIST
77131: LIST
77132: IN
77133: NOT
77134: PUSH
77135: LD_VAR 0 1
77139: PUSH
77140: LD_INT 0
77142: PUSH
77143: LD_INT 1
77145: PUSH
77146: LD_INT 2
77148: PUSH
77149: LD_INT 3
77151: PUSH
77152: LD_INT 6
77154: PUSH
77155: LD_INT 36
77157: PUSH
77158: LD_INT 4
77160: PUSH
77161: LD_INT 5
77163: PUSH
77164: LD_INT 31
77166: PUSH
77167: LD_INT 32
77169: PUSH
77170: LD_INT 33
77172: PUSH
77173: EMPTY
77174: LIST
77175: LIST
77176: LIST
77177: LIST
77178: LIST
77179: LIST
77180: LIST
77181: LIST
77182: LIST
77183: LIST
77184: LIST
77185: IN
77186: NOT
77187: PUSH
77188: LD_VAR 0 6
77192: PUSH
77193: LD_INT 1
77195: EQUAL
77196: AND
77197: OR
77198: PUSH
77199: LD_VAR 0 1
77203: PUSH
77204: LD_INT 2
77206: PUSH
77207: LD_INT 3
77209: PUSH
77210: EMPTY
77211: LIST
77212: LIST
77213: IN
77214: NOT
77215: PUSH
77216: LD_VAR 0 6
77220: PUSH
77221: LD_INT 2
77223: EQUAL
77224: AND
77225: OR
77226: IFFALSE 77236
// mode = 0 ;
77228: LD_ADDR_VAR 0 6
77232: PUSH
77233: LD_INT 0
77235: ST_TO_ADDR
// case mode of 0 :
77236: LD_VAR 0 6
77240: PUSH
77241: LD_INT 0
77243: DOUBLE
77244: EQUAL
77245: IFTRUE 77249
77247: GO 88702
77249: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77250: LD_ADDR_VAR 0 11
77254: PUSH
77255: LD_INT 0
77257: PUSH
77258: LD_INT 0
77260: PUSH
77261: EMPTY
77262: LIST
77263: LIST
77264: PUSH
77265: LD_INT 0
77267: PUSH
77268: LD_INT 1
77270: NEG
77271: PUSH
77272: EMPTY
77273: LIST
77274: LIST
77275: PUSH
77276: LD_INT 1
77278: PUSH
77279: LD_INT 0
77281: PUSH
77282: EMPTY
77283: LIST
77284: LIST
77285: PUSH
77286: LD_INT 1
77288: PUSH
77289: LD_INT 1
77291: PUSH
77292: EMPTY
77293: LIST
77294: LIST
77295: PUSH
77296: LD_INT 0
77298: PUSH
77299: LD_INT 1
77301: PUSH
77302: EMPTY
77303: LIST
77304: LIST
77305: PUSH
77306: LD_INT 1
77308: NEG
77309: PUSH
77310: LD_INT 0
77312: PUSH
77313: EMPTY
77314: LIST
77315: LIST
77316: PUSH
77317: LD_INT 1
77319: NEG
77320: PUSH
77321: LD_INT 1
77323: NEG
77324: PUSH
77325: EMPTY
77326: LIST
77327: LIST
77328: PUSH
77329: LD_INT 1
77331: NEG
77332: PUSH
77333: LD_INT 2
77335: NEG
77336: PUSH
77337: EMPTY
77338: LIST
77339: LIST
77340: PUSH
77341: LD_INT 0
77343: PUSH
77344: LD_INT 2
77346: NEG
77347: PUSH
77348: EMPTY
77349: LIST
77350: LIST
77351: PUSH
77352: LD_INT 1
77354: PUSH
77355: LD_INT 1
77357: NEG
77358: PUSH
77359: EMPTY
77360: LIST
77361: LIST
77362: PUSH
77363: LD_INT 1
77365: PUSH
77366: LD_INT 2
77368: PUSH
77369: EMPTY
77370: LIST
77371: LIST
77372: PUSH
77373: LD_INT 0
77375: PUSH
77376: LD_INT 2
77378: PUSH
77379: EMPTY
77380: LIST
77381: LIST
77382: PUSH
77383: LD_INT 1
77385: NEG
77386: PUSH
77387: LD_INT 1
77389: PUSH
77390: EMPTY
77391: LIST
77392: LIST
77393: PUSH
77394: LD_INT 1
77396: PUSH
77397: LD_INT 3
77399: PUSH
77400: EMPTY
77401: LIST
77402: LIST
77403: PUSH
77404: LD_INT 0
77406: PUSH
77407: LD_INT 3
77409: PUSH
77410: EMPTY
77411: LIST
77412: LIST
77413: PUSH
77414: LD_INT 1
77416: NEG
77417: PUSH
77418: LD_INT 2
77420: PUSH
77421: EMPTY
77422: LIST
77423: LIST
77424: PUSH
77425: EMPTY
77426: LIST
77427: LIST
77428: LIST
77429: LIST
77430: LIST
77431: LIST
77432: LIST
77433: LIST
77434: LIST
77435: LIST
77436: LIST
77437: LIST
77438: LIST
77439: LIST
77440: LIST
77441: LIST
77442: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77443: LD_ADDR_VAR 0 12
77447: PUSH
77448: LD_INT 0
77450: PUSH
77451: LD_INT 0
77453: PUSH
77454: EMPTY
77455: LIST
77456: LIST
77457: PUSH
77458: LD_INT 0
77460: PUSH
77461: LD_INT 1
77463: NEG
77464: PUSH
77465: EMPTY
77466: LIST
77467: LIST
77468: PUSH
77469: LD_INT 1
77471: PUSH
77472: LD_INT 0
77474: PUSH
77475: EMPTY
77476: LIST
77477: LIST
77478: PUSH
77479: LD_INT 1
77481: PUSH
77482: LD_INT 1
77484: PUSH
77485: EMPTY
77486: LIST
77487: LIST
77488: PUSH
77489: LD_INT 0
77491: PUSH
77492: LD_INT 1
77494: PUSH
77495: EMPTY
77496: LIST
77497: LIST
77498: PUSH
77499: LD_INT 1
77501: NEG
77502: PUSH
77503: LD_INT 0
77505: PUSH
77506: EMPTY
77507: LIST
77508: LIST
77509: PUSH
77510: LD_INT 1
77512: NEG
77513: PUSH
77514: LD_INT 1
77516: NEG
77517: PUSH
77518: EMPTY
77519: LIST
77520: LIST
77521: PUSH
77522: LD_INT 1
77524: PUSH
77525: LD_INT 1
77527: NEG
77528: PUSH
77529: EMPTY
77530: LIST
77531: LIST
77532: PUSH
77533: LD_INT 2
77535: PUSH
77536: LD_INT 0
77538: PUSH
77539: EMPTY
77540: LIST
77541: LIST
77542: PUSH
77543: LD_INT 2
77545: PUSH
77546: LD_INT 1
77548: PUSH
77549: EMPTY
77550: LIST
77551: LIST
77552: PUSH
77553: LD_INT 1
77555: NEG
77556: PUSH
77557: LD_INT 1
77559: PUSH
77560: EMPTY
77561: LIST
77562: LIST
77563: PUSH
77564: LD_INT 2
77566: NEG
77567: PUSH
77568: LD_INT 0
77570: PUSH
77571: EMPTY
77572: LIST
77573: LIST
77574: PUSH
77575: LD_INT 2
77577: NEG
77578: PUSH
77579: LD_INT 1
77581: NEG
77582: PUSH
77583: EMPTY
77584: LIST
77585: LIST
77586: PUSH
77587: LD_INT 2
77589: NEG
77590: PUSH
77591: LD_INT 1
77593: PUSH
77594: EMPTY
77595: LIST
77596: LIST
77597: PUSH
77598: LD_INT 3
77600: NEG
77601: PUSH
77602: LD_INT 0
77604: PUSH
77605: EMPTY
77606: LIST
77607: LIST
77608: PUSH
77609: LD_INT 3
77611: NEG
77612: PUSH
77613: LD_INT 1
77615: NEG
77616: PUSH
77617: EMPTY
77618: LIST
77619: LIST
77620: PUSH
77621: EMPTY
77622: LIST
77623: LIST
77624: LIST
77625: LIST
77626: LIST
77627: LIST
77628: LIST
77629: LIST
77630: LIST
77631: LIST
77632: LIST
77633: LIST
77634: LIST
77635: LIST
77636: LIST
77637: LIST
77638: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77639: LD_ADDR_VAR 0 13
77643: PUSH
77644: LD_INT 0
77646: PUSH
77647: LD_INT 0
77649: PUSH
77650: EMPTY
77651: LIST
77652: LIST
77653: PUSH
77654: LD_INT 0
77656: PUSH
77657: LD_INT 1
77659: NEG
77660: PUSH
77661: EMPTY
77662: LIST
77663: LIST
77664: PUSH
77665: LD_INT 1
77667: PUSH
77668: LD_INT 0
77670: PUSH
77671: EMPTY
77672: LIST
77673: LIST
77674: PUSH
77675: LD_INT 1
77677: PUSH
77678: LD_INT 1
77680: PUSH
77681: EMPTY
77682: LIST
77683: LIST
77684: PUSH
77685: LD_INT 0
77687: PUSH
77688: LD_INT 1
77690: PUSH
77691: EMPTY
77692: LIST
77693: LIST
77694: PUSH
77695: LD_INT 1
77697: NEG
77698: PUSH
77699: LD_INT 0
77701: PUSH
77702: EMPTY
77703: LIST
77704: LIST
77705: PUSH
77706: LD_INT 1
77708: NEG
77709: PUSH
77710: LD_INT 1
77712: NEG
77713: PUSH
77714: EMPTY
77715: LIST
77716: LIST
77717: PUSH
77718: LD_INT 1
77720: NEG
77721: PUSH
77722: LD_INT 2
77724: NEG
77725: PUSH
77726: EMPTY
77727: LIST
77728: LIST
77729: PUSH
77730: LD_INT 2
77732: PUSH
77733: LD_INT 1
77735: PUSH
77736: EMPTY
77737: LIST
77738: LIST
77739: PUSH
77740: LD_INT 2
77742: PUSH
77743: LD_INT 2
77745: PUSH
77746: EMPTY
77747: LIST
77748: LIST
77749: PUSH
77750: LD_INT 1
77752: PUSH
77753: LD_INT 2
77755: PUSH
77756: EMPTY
77757: LIST
77758: LIST
77759: PUSH
77760: LD_INT 2
77762: NEG
77763: PUSH
77764: LD_INT 1
77766: NEG
77767: PUSH
77768: EMPTY
77769: LIST
77770: LIST
77771: PUSH
77772: LD_INT 2
77774: NEG
77775: PUSH
77776: LD_INT 2
77778: NEG
77779: PUSH
77780: EMPTY
77781: LIST
77782: LIST
77783: PUSH
77784: LD_INT 2
77786: NEG
77787: PUSH
77788: LD_INT 3
77790: NEG
77791: PUSH
77792: EMPTY
77793: LIST
77794: LIST
77795: PUSH
77796: LD_INT 3
77798: NEG
77799: PUSH
77800: LD_INT 2
77802: NEG
77803: PUSH
77804: EMPTY
77805: LIST
77806: LIST
77807: PUSH
77808: LD_INT 3
77810: NEG
77811: PUSH
77812: LD_INT 3
77814: NEG
77815: PUSH
77816: EMPTY
77817: LIST
77818: LIST
77819: PUSH
77820: EMPTY
77821: LIST
77822: LIST
77823: LIST
77824: LIST
77825: LIST
77826: LIST
77827: LIST
77828: LIST
77829: LIST
77830: LIST
77831: LIST
77832: LIST
77833: LIST
77834: LIST
77835: LIST
77836: LIST
77837: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77838: LD_ADDR_VAR 0 14
77842: PUSH
77843: LD_INT 0
77845: PUSH
77846: LD_INT 0
77848: PUSH
77849: EMPTY
77850: LIST
77851: LIST
77852: PUSH
77853: LD_INT 0
77855: PUSH
77856: LD_INT 1
77858: NEG
77859: PUSH
77860: EMPTY
77861: LIST
77862: LIST
77863: PUSH
77864: LD_INT 1
77866: PUSH
77867: LD_INT 0
77869: PUSH
77870: EMPTY
77871: LIST
77872: LIST
77873: PUSH
77874: LD_INT 1
77876: PUSH
77877: LD_INT 1
77879: PUSH
77880: EMPTY
77881: LIST
77882: LIST
77883: PUSH
77884: LD_INT 0
77886: PUSH
77887: LD_INT 1
77889: PUSH
77890: EMPTY
77891: LIST
77892: LIST
77893: PUSH
77894: LD_INT 1
77896: NEG
77897: PUSH
77898: LD_INT 0
77900: PUSH
77901: EMPTY
77902: LIST
77903: LIST
77904: PUSH
77905: LD_INT 1
77907: NEG
77908: PUSH
77909: LD_INT 1
77911: NEG
77912: PUSH
77913: EMPTY
77914: LIST
77915: LIST
77916: PUSH
77917: LD_INT 1
77919: NEG
77920: PUSH
77921: LD_INT 2
77923: NEG
77924: PUSH
77925: EMPTY
77926: LIST
77927: LIST
77928: PUSH
77929: LD_INT 0
77931: PUSH
77932: LD_INT 2
77934: NEG
77935: PUSH
77936: EMPTY
77937: LIST
77938: LIST
77939: PUSH
77940: LD_INT 1
77942: PUSH
77943: LD_INT 1
77945: NEG
77946: PUSH
77947: EMPTY
77948: LIST
77949: LIST
77950: PUSH
77951: LD_INT 1
77953: PUSH
77954: LD_INT 2
77956: PUSH
77957: EMPTY
77958: LIST
77959: LIST
77960: PUSH
77961: LD_INT 0
77963: PUSH
77964: LD_INT 2
77966: PUSH
77967: EMPTY
77968: LIST
77969: LIST
77970: PUSH
77971: LD_INT 1
77973: NEG
77974: PUSH
77975: LD_INT 1
77977: PUSH
77978: EMPTY
77979: LIST
77980: LIST
77981: PUSH
77982: LD_INT 1
77984: NEG
77985: PUSH
77986: LD_INT 3
77988: NEG
77989: PUSH
77990: EMPTY
77991: LIST
77992: LIST
77993: PUSH
77994: LD_INT 0
77996: PUSH
77997: LD_INT 3
77999: NEG
78000: PUSH
78001: EMPTY
78002: LIST
78003: LIST
78004: PUSH
78005: LD_INT 1
78007: PUSH
78008: LD_INT 2
78010: NEG
78011: PUSH
78012: EMPTY
78013: LIST
78014: LIST
78015: PUSH
78016: EMPTY
78017: LIST
78018: LIST
78019: LIST
78020: LIST
78021: LIST
78022: LIST
78023: LIST
78024: LIST
78025: LIST
78026: LIST
78027: LIST
78028: LIST
78029: LIST
78030: LIST
78031: LIST
78032: LIST
78033: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78034: LD_ADDR_VAR 0 15
78038: PUSH
78039: LD_INT 0
78041: PUSH
78042: LD_INT 0
78044: PUSH
78045: EMPTY
78046: LIST
78047: LIST
78048: PUSH
78049: LD_INT 0
78051: PUSH
78052: LD_INT 1
78054: NEG
78055: PUSH
78056: EMPTY
78057: LIST
78058: LIST
78059: PUSH
78060: LD_INT 1
78062: PUSH
78063: LD_INT 0
78065: PUSH
78066: EMPTY
78067: LIST
78068: LIST
78069: PUSH
78070: LD_INT 1
78072: PUSH
78073: LD_INT 1
78075: PUSH
78076: EMPTY
78077: LIST
78078: LIST
78079: PUSH
78080: LD_INT 0
78082: PUSH
78083: LD_INT 1
78085: PUSH
78086: EMPTY
78087: LIST
78088: LIST
78089: PUSH
78090: LD_INT 1
78092: NEG
78093: PUSH
78094: LD_INT 0
78096: PUSH
78097: EMPTY
78098: LIST
78099: LIST
78100: PUSH
78101: LD_INT 1
78103: NEG
78104: PUSH
78105: LD_INT 1
78107: NEG
78108: PUSH
78109: EMPTY
78110: LIST
78111: LIST
78112: PUSH
78113: LD_INT 1
78115: PUSH
78116: LD_INT 1
78118: NEG
78119: PUSH
78120: EMPTY
78121: LIST
78122: LIST
78123: PUSH
78124: LD_INT 2
78126: PUSH
78127: LD_INT 0
78129: PUSH
78130: EMPTY
78131: LIST
78132: LIST
78133: PUSH
78134: LD_INT 2
78136: PUSH
78137: LD_INT 1
78139: PUSH
78140: EMPTY
78141: LIST
78142: LIST
78143: PUSH
78144: LD_INT 1
78146: NEG
78147: PUSH
78148: LD_INT 1
78150: PUSH
78151: EMPTY
78152: LIST
78153: LIST
78154: PUSH
78155: LD_INT 2
78157: NEG
78158: PUSH
78159: LD_INT 0
78161: PUSH
78162: EMPTY
78163: LIST
78164: LIST
78165: PUSH
78166: LD_INT 2
78168: NEG
78169: PUSH
78170: LD_INT 1
78172: NEG
78173: PUSH
78174: EMPTY
78175: LIST
78176: LIST
78177: PUSH
78178: LD_INT 2
78180: PUSH
78181: LD_INT 1
78183: NEG
78184: PUSH
78185: EMPTY
78186: LIST
78187: LIST
78188: PUSH
78189: LD_INT 3
78191: PUSH
78192: LD_INT 0
78194: PUSH
78195: EMPTY
78196: LIST
78197: LIST
78198: PUSH
78199: LD_INT 3
78201: PUSH
78202: LD_INT 1
78204: PUSH
78205: EMPTY
78206: LIST
78207: LIST
78208: PUSH
78209: EMPTY
78210: LIST
78211: LIST
78212: LIST
78213: LIST
78214: LIST
78215: LIST
78216: LIST
78217: LIST
78218: LIST
78219: LIST
78220: LIST
78221: LIST
78222: LIST
78223: LIST
78224: LIST
78225: LIST
78226: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78227: LD_ADDR_VAR 0 16
78231: PUSH
78232: LD_INT 0
78234: PUSH
78235: LD_INT 0
78237: PUSH
78238: EMPTY
78239: LIST
78240: LIST
78241: PUSH
78242: LD_INT 0
78244: PUSH
78245: LD_INT 1
78247: NEG
78248: PUSH
78249: EMPTY
78250: LIST
78251: LIST
78252: PUSH
78253: LD_INT 1
78255: PUSH
78256: LD_INT 0
78258: PUSH
78259: EMPTY
78260: LIST
78261: LIST
78262: PUSH
78263: LD_INT 1
78265: PUSH
78266: LD_INT 1
78268: PUSH
78269: EMPTY
78270: LIST
78271: LIST
78272: PUSH
78273: LD_INT 0
78275: PUSH
78276: LD_INT 1
78278: PUSH
78279: EMPTY
78280: LIST
78281: LIST
78282: PUSH
78283: LD_INT 1
78285: NEG
78286: PUSH
78287: LD_INT 0
78289: PUSH
78290: EMPTY
78291: LIST
78292: LIST
78293: PUSH
78294: LD_INT 1
78296: NEG
78297: PUSH
78298: LD_INT 1
78300: NEG
78301: PUSH
78302: EMPTY
78303: LIST
78304: LIST
78305: PUSH
78306: LD_INT 1
78308: NEG
78309: PUSH
78310: LD_INT 2
78312: NEG
78313: PUSH
78314: EMPTY
78315: LIST
78316: LIST
78317: PUSH
78318: LD_INT 2
78320: PUSH
78321: LD_INT 1
78323: PUSH
78324: EMPTY
78325: LIST
78326: LIST
78327: PUSH
78328: LD_INT 2
78330: PUSH
78331: LD_INT 2
78333: PUSH
78334: EMPTY
78335: LIST
78336: LIST
78337: PUSH
78338: LD_INT 1
78340: PUSH
78341: LD_INT 2
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: PUSH
78348: LD_INT 2
78350: NEG
78351: PUSH
78352: LD_INT 1
78354: NEG
78355: PUSH
78356: EMPTY
78357: LIST
78358: LIST
78359: PUSH
78360: LD_INT 2
78362: NEG
78363: PUSH
78364: LD_INT 2
78366: NEG
78367: PUSH
78368: EMPTY
78369: LIST
78370: LIST
78371: PUSH
78372: LD_INT 3
78374: PUSH
78375: LD_INT 2
78377: PUSH
78378: EMPTY
78379: LIST
78380: LIST
78381: PUSH
78382: LD_INT 3
78384: PUSH
78385: LD_INT 3
78387: PUSH
78388: EMPTY
78389: LIST
78390: LIST
78391: PUSH
78392: LD_INT 2
78394: PUSH
78395: LD_INT 3
78397: PUSH
78398: EMPTY
78399: LIST
78400: LIST
78401: PUSH
78402: EMPTY
78403: LIST
78404: LIST
78405: LIST
78406: LIST
78407: LIST
78408: LIST
78409: LIST
78410: LIST
78411: LIST
78412: LIST
78413: LIST
78414: LIST
78415: LIST
78416: LIST
78417: LIST
78418: LIST
78419: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78420: LD_ADDR_VAR 0 17
78424: PUSH
78425: LD_INT 0
78427: PUSH
78428: LD_INT 0
78430: PUSH
78431: EMPTY
78432: LIST
78433: LIST
78434: PUSH
78435: LD_INT 0
78437: PUSH
78438: LD_INT 1
78440: NEG
78441: PUSH
78442: EMPTY
78443: LIST
78444: LIST
78445: PUSH
78446: LD_INT 1
78448: PUSH
78449: LD_INT 0
78451: PUSH
78452: EMPTY
78453: LIST
78454: LIST
78455: PUSH
78456: LD_INT 1
78458: PUSH
78459: LD_INT 1
78461: PUSH
78462: EMPTY
78463: LIST
78464: LIST
78465: PUSH
78466: LD_INT 0
78468: PUSH
78469: LD_INT 1
78471: PUSH
78472: EMPTY
78473: LIST
78474: LIST
78475: PUSH
78476: LD_INT 1
78478: NEG
78479: PUSH
78480: LD_INT 0
78482: PUSH
78483: EMPTY
78484: LIST
78485: LIST
78486: PUSH
78487: LD_INT 1
78489: NEG
78490: PUSH
78491: LD_INT 1
78493: NEG
78494: PUSH
78495: EMPTY
78496: LIST
78497: LIST
78498: PUSH
78499: LD_INT 1
78501: NEG
78502: PUSH
78503: LD_INT 2
78505: NEG
78506: PUSH
78507: EMPTY
78508: LIST
78509: LIST
78510: PUSH
78511: LD_INT 0
78513: PUSH
78514: LD_INT 2
78516: NEG
78517: PUSH
78518: EMPTY
78519: LIST
78520: LIST
78521: PUSH
78522: LD_INT 1
78524: PUSH
78525: LD_INT 1
78527: NEG
78528: PUSH
78529: EMPTY
78530: LIST
78531: LIST
78532: PUSH
78533: LD_INT 2
78535: PUSH
78536: LD_INT 0
78538: PUSH
78539: EMPTY
78540: LIST
78541: LIST
78542: PUSH
78543: LD_INT 2
78545: PUSH
78546: LD_INT 1
78548: PUSH
78549: EMPTY
78550: LIST
78551: LIST
78552: PUSH
78553: LD_INT 2
78555: PUSH
78556: LD_INT 2
78558: PUSH
78559: EMPTY
78560: LIST
78561: LIST
78562: PUSH
78563: LD_INT 1
78565: PUSH
78566: LD_INT 2
78568: PUSH
78569: EMPTY
78570: LIST
78571: LIST
78572: PUSH
78573: LD_INT 0
78575: PUSH
78576: LD_INT 2
78578: PUSH
78579: EMPTY
78580: LIST
78581: LIST
78582: PUSH
78583: LD_INT 1
78585: NEG
78586: PUSH
78587: LD_INT 1
78589: PUSH
78590: EMPTY
78591: LIST
78592: LIST
78593: PUSH
78594: LD_INT 2
78596: NEG
78597: PUSH
78598: LD_INT 0
78600: PUSH
78601: EMPTY
78602: LIST
78603: LIST
78604: PUSH
78605: LD_INT 2
78607: NEG
78608: PUSH
78609: LD_INT 1
78611: NEG
78612: PUSH
78613: EMPTY
78614: LIST
78615: LIST
78616: PUSH
78617: LD_INT 2
78619: NEG
78620: PUSH
78621: LD_INT 2
78623: NEG
78624: PUSH
78625: EMPTY
78626: LIST
78627: LIST
78628: PUSH
78629: EMPTY
78630: LIST
78631: LIST
78632: LIST
78633: LIST
78634: LIST
78635: LIST
78636: LIST
78637: LIST
78638: LIST
78639: LIST
78640: LIST
78641: LIST
78642: LIST
78643: LIST
78644: LIST
78645: LIST
78646: LIST
78647: LIST
78648: LIST
78649: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78650: LD_ADDR_VAR 0 18
78654: PUSH
78655: LD_INT 0
78657: PUSH
78658: LD_INT 0
78660: PUSH
78661: EMPTY
78662: LIST
78663: LIST
78664: PUSH
78665: LD_INT 0
78667: PUSH
78668: LD_INT 1
78670: NEG
78671: PUSH
78672: EMPTY
78673: LIST
78674: LIST
78675: PUSH
78676: LD_INT 1
78678: PUSH
78679: LD_INT 0
78681: PUSH
78682: EMPTY
78683: LIST
78684: LIST
78685: PUSH
78686: LD_INT 1
78688: PUSH
78689: LD_INT 1
78691: PUSH
78692: EMPTY
78693: LIST
78694: LIST
78695: PUSH
78696: LD_INT 0
78698: PUSH
78699: LD_INT 1
78701: PUSH
78702: EMPTY
78703: LIST
78704: LIST
78705: PUSH
78706: LD_INT 1
78708: NEG
78709: PUSH
78710: LD_INT 0
78712: PUSH
78713: EMPTY
78714: LIST
78715: LIST
78716: PUSH
78717: LD_INT 1
78719: NEG
78720: PUSH
78721: LD_INT 1
78723: NEG
78724: PUSH
78725: EMPTY
78726: LIST
78727: LIST
78728: PUSH
78729: LD_INT 1
78731: NEG
78732: PUSH
78733: LD_INT 2
78735: NEG
78736: PUSH
78737: EMPTY
78738: LIST
78739: LIST
78740: PUSH
78741: LD_INT 0
78743: PUSH
78744: LD_INT 2
78746: NEG
78747: PUSH
78748: EMPTY
78749: LIST
78750: LIST
78751: PUSH
78752: LD_INT 1
78754: PUSH
78755: LD_INT 1
78757: NEG
78758: PUSH
78759: EMPTY
78760: LIST
78761: LIST
78762: PUSH
78763: LD_INT 2
78765: PUSH
78766: LD_INT 0
78768: PUSH
78769: EMPTY
78770: LIST
78771: LIST
78772: PUSH
78773: LD_INT 2
78775: PUSH
78776: LD_INT 1
78778: PUSH
78779: EMPTY
78780: LIST
78781: LIST
78782: PUSH
78783: LD_INT 2
78785: PUSH
78786: LD_INT 2
78788: PUSH
78789: EMPTY
78790: LIST
78791: LIST
78792: PUSH
78793: LD_INT 1
78795: PUSH
78796: LD_INT 2
78798: PUSH
78799: EMPTY
78800: LIST
78801: LIST
78802: PUSH
78803: LD_INT 0
78805: PUSH
78806: LD_INT 2
78808: PUSH
78809: EMPTY
78810: LIST
78811: LIST
78812: PUSH
78813: LD_INT 1
78815: NEG
78816: PUSH
78817: LD_INT 1
78819: PUSH
78820: EMPTY
78821: LIST
78822: LIST
78823: PUSH
78824: LD_INT 2
78826: NEG
78827: PUSH
78828: LD_INT 0
78830: PUSH
78831: EMPTY
78832: LIST
78833: LIST
78834: PUSH
78835: LD_INT 2
78837: NEG
78838: PUSH
78839: LD_INT 1
78841: NEG
78842: PUSH
78843: EMPTY
78844: LIST
78845: LIST
78846: PUSH
78847: LD_INT 2
78849: NEG
78850: PUSH
78851: LD_INT 2
78853: NEG
78854: PUSH
78855: EMPTY
78856: LIST
78857: LIST
78858: PUSH
78859: EMPTY
78860: LIST
78861: LIST
78862: LIST
78863: LIST
78864: LIST
78865: LIST
78866: LIST
78867: LIST
78868: LIST
78869: LIST
78870: LIST
78871: LIST
78872: LIST
78873: LIST
78874: LIST
78875: LIST
78876: LIST
78877: LIST
78878: LIST
78879: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78880: LD_ADDR_VAR 0 19
78884: PUSH
78885: LD_INT 0
78887: PUSH
78888: LD_INT 0
78890: PUSH
78891: EMPTY
78892: LIST
78893: LIST
78894: PUSH
78895: LD_INT 0
78897: PUSH
78898: LD_INT 1
78900: NEG
78901: PUSH
78902: EMPTY
78903: LIST
78904: LIST
78905: PUSH
78906: LD_INT 1
78908: PUSH
78909: LD_INT 0
78911: PUSH
78912: EMPTY
78913: LIST
78914: LIST
78915: PUSH
78916: LD_INT 1
78918: PUSH
78919: LD_INT 1
78921: PUSH
78922: EMPTY
78923: LIST
78924: LIST
78925: PUSH
78926: LD_INT 0
78928: PUSH
78929: LD_INT 1
78931: PUSH
78932: EMPTY
78933: LIST
78934: LIST
78935: PUSH
78936: LD_INT 1
78938: NEG
78939: PUSH
78940: LD_INT 0
78942: PUSH
78943: EMPTY
78944: LIST
78945: LIST
78946: PUSH
78947: LD_INT 1
78949: NEG
78950: PUSH
78951: LD_INT 1
78953: NEG
78954: PUSH
78955: EMPTY
78956: LIST
78957: LIST
78958: PUSH
78959: LD_INT 1
78961: NEG
78962: PUSH
78963: LD_INT 2
78965: NEG
78966: PUSH
78967: EMPTY
78968: LIST
78969: LIST
78970: PUSH
78971: LD_INT 0
78973: PUSH
78974: LD_INT 2
78976: NEG
78977: PUSH
78978: EMPTY
78979: LIST
78980: LIST
78981: PUSH
78982: LD_INT 1
78984: PUSH
78985: LD_INT 1
78987: NEG
78988: PUSH
78989: EMPTY
78990: LIST
78991: LIST
78992: PUSH
78993: LD_INT 2
78995: PUSH
78996: LD_INT 0
78998: PUSH
78999: EMPTY
79000: LIST
79001: LIST
79002: PUSH
79003: LD_INT 2
79005: PUSH
79006: LD_INT 1
79008: PUSH
79009: EMPTY
79010: LIST
79011: LIST
79012: PUSH
79013: LD_INT 2
79015: PUSH
79016: LD_INT 2
79018: PUSH
79019: EMPTY
79020: LIST
79021: LIST
79022: PUSH
79023: LD_INT 1
79025: PUSH
79026: LD_INT 2
79028: PUSH
79029: EMPTY
79030: LIST
79031: LIST
79032: PUSH
79033: LD_INT 0
79035: PUSH
79036: LD_INT 2
79038: PUSH
79039: EMPTY
79040: LIST
79041: LIST
79042: PUSH
79043: LD_INT 1
79045: NEG
79046: PUSH
79047: LD_INT 1
79049: PUSH
79050: EMPTY
79051: LIST
79052: LIST
79053: PUSH
79054: LD_INT 2
79056: NEG
79057: PUSH
79058: LD_INT 0
79060: PUSH
79061: EMPTY
79062: LIST
79063: LIST
79064: PUSH
79065: LD_INT 2
79067: NEG
79068: PUSH
79069: LD_INT 1
79071: NEG
79072: PUSH
79073: EMPTY
79074: LIST
79075: LIST
79076: PUSH
79077: LD_INT 2
79079: NEG
79080: PUSH
79081: LD_INT 2
79083: NEG
79084: PUSH
79085: EMPTY
79086: LIST
79087: LIST
79088: PUSH
79089: EMPTY
79090: LIST
79091: LIST
79092: LIST
79093: LIST
79094: LIST
79095: LIST
79096: LIST
79097: LIST
79098: LIST
79099: LIST
79100: LIST
79101: LIST
79102: LIST
79103: LIST
79104: LIST
79105: LIST
79106: LIST
79107: LIST
79108: LIST
79109: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79110: LD_ADDR_VAR 0 20
79114: PUSH
79115: LD_INT 0
79117: PUSH
79118: LD_INT 0
79120: PUSH
79121: EMPTY
79122: LIST
79123: LIST
79124: PUSH
79125: LD_INT 0
79127: PUSH
79128: LD_INT 1
79130: NEG
79131: PUSH
79132: EMPTY
79133: LIST
79134: LIST
79135: PUSH
79136: LD_INT 1
79138: PUSH
79139: LD_INT 0
79141: PUSH
79142: EMPTY
79143: LIST
79144: LIST
79145: PUSH
79146: LD_INT 1
79148: PUSH
79149: LD_INT 1
79151: PUSH
79152: EMPTY
79153: LIST
79154: LIST
79155: PUSH
79156: LD_INT 0
79158: PUSH
79159: LD_INT 1
79161: PUSH
79162: EMPTY
79163: LIST
79164: LIST
79165: PUSH
79166: LD_INT 1
79168: NEG
79169: PUSH
79170: LD_INT 0
79172: PUSH
79173: EMPTY
79174: LIST
79175: LIST
79176: PUSH
79177: LD_INT 1
79179: NEG
79180: PUSH
79181: LD_INT 1
79183: NEG
79184: PUSH
79185: EMPTY
79186: LIST
79187: LIST
79188: PUSH
79189: LD_INT 1
79191: NEG
79192: PUSH
79193: LD_INT 2
79195: NEG
79196: PUSH
79197: EMPTY
79198: LIST
79199: LIST
79200: PUSH
79201: LD_INT 0
79203: PUSH
79204: LD_INT 2
79206: NEG
79207: PUSH
79208: EMPTY
79209: LIST
79210: LIST
79211: PUSH
79212: LD_INT 1
79214: PUSH
79215: LD_INT 1
79217: NEG
79218: PUSH
79219: EMPTY
79220: LIST
79221: LIST
79222: PUSH
79223: LD_INT 2
79225: PUSH
79226: LD_INT 0
79228: PUSH
79229: EMPTY
79230: LIST
79231: LIST
79232: PUSH
79233: LD_INT 2
79235: PUSH
79236: LD_INT 1
79238: PUSH
79239: EMPTY
79240: LIST
79241: LIST
79242: PUSH
79243: LD_INT 2
79245: PUSH
79246: LD_INT 2
79248: PUSH
79249: EMPTY
79250: LIST
79251: LIST
79252: PUSH
79253: LD_INT 1
79255: PUSH
79256: LD_INT 2
79258: PUSH
79259: EMPTY
79260: LIST
79261: LIST
79262: PUSH
79263: LD_INT 0
79265: PUSH
79266: LD_INT 2
79268: PUSH
79269: EMPTY
79270: LIST
79271: LIST
79272: PUSH
79273: LD_INT 1
79275: NEG
79276: PUSH
79277: LD_INT 1
79279: PUSH
79280: EMPTY
79281: LIST
79282: LIST
79283: PUSH
79284: LD_INT 2
79286: NEG
79287: PUSH
79288: LD_INT 0
79290: PUSH
79291: EMPTY
79292: LIST
79293: LIST
79294: PUSH
79295: LD_INT 2
79297: NEG
79298: PUSH
79299: LD_INT 1
79301: NEG
79302: PUSH
79303: EMPTY
79304: LIST
79305: LIST
79306: PUSH
79307: LD_INT 2
79309: NEG
79310: PUSH
79311: LD_INT 2
79313: NEG
79314: PUSH
79315: EMPTY
79316: LIST
79317: LIST
79318: PUSH
79319: EMPTY
79320: LIST
79321: LIST
79322: LIST
79323: LIST
79324: LIST
79325: LIST
79326: LIST
79327: LIST
79328: LIST
79329: LIST
79330: LIST
79331: LIST
79332: LIST
79333: LIST
79334: LIST
79335: LIST
79336: LIST
79337: LIST
79338: LIST
79339: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79340: LD_ADDR_VAR 0 21
79344: PUSH
79345: LD_INT 0
79347: PUSH
79348: LD_INT 0
79350: PUSH
79351: EMPTY
79352: LIST
79353: LIST
79354: PUSH
79355: LD_INT 0
79357: PUSH
79358: LD_INT 1
79360: NEG
79361: PUSH
79362: EMPTY
79363: LIST
79364: LIST
79365: PUSH
79366: LD_INT 1
79368: PUSH
79369: LD_INT 0
79371: PUSH
79372: EMPTY
79373: LIST
79374: LIST
79375: PUSH
79376: LD_INT 1
79378: PUSH
79379: LD_INT 1
79381: PUSH
79382: EMPTY
79383: LIST
79384: LIST
79385: PUSH
79386: LD_INT 0
79388: PUSH
79389: LD_INT 1
79391: PUSH
79392: EMPTY
79393: LIST
79394: LIST
79395: PUSH
79396: LD_INT 1
79398: NEG
79399: PUSH
79400: LD_INT 0
79402: PUSH
79403: EMPTY
79404: LIST
79405: LIST
79406: PUSH
79407: LD_INT 1
79409: NEG
79410: PUSH
79411: LD_INT 1
79413: NEG
79414: PUSH
79415: EMPTY
79416: LIST
79417: LIST
79418: PUSH
79419: LD_INT 1
79421: NEG
79422: PUSH
79423: LD_INT 2
79425: NEG
79426: PUSH
79427: EMPTY
79428: LIST
79429: LIST
79430: PUSH
79431: LD_INT 0
79433: PUSH
79434: LD_INT 2
79436: NEG
79437: PUSH
79438: EMPTY
79439: LIST
79440: LIST
79441: PUSH
79442: LD_INT 1
79444: PUSH
79445: LD_INT 1
79447: NEG
79448: PUSH
79449: EMPTY
79450: LIST
79451: LIST
79452: PUSH
79453: LD_INT 2
79455: PUSH
79456: LD_INT 0
79458: PUSH
79459: EMPTY
79460: LIST
79461: LIST
79462: PUSH
79463: LD_INT 2
79465: PUSH
79466: LD_INT 1
79468: PUSH
79469: EMPTY
79470: LIST
79471: LIST
79472: PUSH
79473: LD_INT 2
79475: PUSH
79476: LD_INT 2
79478: PUSH
79479: EMPTY
79480: LIST
79481: LIST
79482: PUSH
79483: LD_INT 1
79485: PUSH
79486: LD_INT 2
79488: PUSH
79489: EMPTY
79490: LIST
79491: LIST
79492: PUSH
79493: LD_INT 0
79495: PUSH
79496: LD_INT 2
79498: PUSH
79499: EMPTY
79500: LIST
79501: LIST
79502: PUSH
79503: LD_INT 1
79505: NEG
79506: PUSH
79507: LD_INT 1
79509: PUSH
79510: EMPTY
79511: LIST
79512: LIST
79513: PUSH
79514: LD_INT 2
79516: NEG
79517: PUSH
79518: LD_INT 0
79520: PUSH
79521: EMPTY
79522: LIST
79523: LIST
79524: PUSH
79525: LD_INT 2
79527: NEG
79528: PUSH
79529: LD_INT 1
79531: NEG
79532: PUSH
79533: EMPTY
79534: LIST
79535: LIST
79536: PUSH
79537: LD_INT 2
79539: NEG
79540: PUSH
79541: LD_INT 2
79543: NEG
79544: PUSH
79545: EMPTY
79546: LIST
79547: LIST
79548: PUSH
79549: EMPTY
79550: LIST
79551: LIST
79552: LIST
79553: LIST
79554: LIST
79555: LIST
79556: LIST
79557: LIST
79558: LIST
79559: LIST
79560: LIST
79561: LIST
79562: LIST
79563: LIST
79564: LIST
79565: LIST
79566: LIST
79567: LIST
79568: LIST
79569: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79570: LD_ADDR_VAR 0 22
79574: PUSH
79575: LD_INT 0
79577: PUSH
79578: LD_INT 0
79580: PUSH
79581: EMPTY
79582: LIST
79583: LIST
79584: PUSH
79585: LD_INT 0
79587: PUSH
79588: LD_INT 1
79590: NEG
79591: PUSH
79592: EMPTY
79593: LIST
79594: LIST
79595: PUSH
79596: LD_INT 1
79598: PUSH
79599: LD_INT 0
79601: PUSH
79602: EMPTY
79603: LIST
79604: LIST
79605: PUSH
79606: LD_INT 1
79608: PUSH
79609: LD_INT 1
79611: PUSH
79612: EMPTY
79613: LIST
79614: LIST
79615: PUSH
79616: LD_INT 0
79618: PUSH
79619: LD_INT 1
79621: PUSH
79622: EMPTY
79623: LIST
79624: LIST
79625: PUSH
79626: LD_INT 1
79628: NEG
79629: PUSH
79630: LD_INT 0
79632: PUSH
79633: EMPTY
79634: LIST
79635: LIST
79636: PUSH
79637: LD_INT 1
79639: NEG
79640: PUSH
79641: LD_INT 1
79643: NEG
79644: PUSH
79645: EMPTY
79646: LIST
79647: LIST
79648: PUSH
79649: LD_INT 1
79651: NEG
79652: PUSH
79653: LD_INT 2
79655: NEG
79656: PUSH
79657: EMPTY
79658: LIST
79659: LIST
79660: PUSH
79661: LD_INT 0
79663: PUSH
79664: LD_INT 2
79666: NEG
79667: PUSH
79668: EMPTY
79669: LIST
79670: LIST
79671: PUSH
79672: LD_INT 1
79674: PUSH
79675: LD_INT 1
79677: NEG
79678: PUSH
79679: EMPTY
79680: LIST
79681: LIST
79682: PUSH
79683: LD_INT 2
79685: PUSH
79686: LD_INT 0
79688: PUSH
79689: EMPTY
79690: LIST
79691: LIST
79692: PUSH
79693: LD_INT 2
79695: PUSH
79696: LD_INT 1
79698: PUSH
79699: EMPTY
79700: LIST
79701: LIST
79702: PUSH
79703: LD_INT 2
79705: PUSH
79706: LD_INT 2
79708: PUSH
79709: EMPTY
79710: LIST
79711: LIST
79712: PUSH
79713: LD_INT 1
79715: PUSH
79716: LD_INT 2
79718: PUSH
79719: EMPTY
79720: LIST
79721: LIST
79722: PUSH
79723: LD_INT 0
79725: PUSH
79726: LD_INT 2
79728: PUSH
79729: EMPTY
79730: LIST
79731: LIST
79732: PUSH
79733: LD_INT 1
79735: NEG
79736: PUSH
79737: LD_INT 1
79739: PUSH
79740: EMPTY
79741: LIST
79742: LIST
79743: PUSH
79744: LD_INT 2
79746: NEG
79747: PUSH
79748: LD_INT 0
79750: PUSH
79751: EMPTY
79752: LIST
79753: LIST
79754: PUSH
79755: LD_INT 2
79757: NEG
79758: PUSH
79759: LD_INT 1
79761: NEG
79762: PUSH
79763: EMPTY
79764: LIST
79765: LIST
79766: PUSH
79767: LD_INT 2
79769: NEG
79770: PUSH
79771: LD_INT 2
79773: NEG
79774: PUSH
79775: EMPTY
79776: LIST
79777: LIST
79778: PUSH
79779: EMPTY
79780: LIST
79781: LIST
79782: LIST
79783: LIST
79784: LIST
79785: LIST
79786: LIST
79787: LIST
79788: LIST
79789: LIST
79790: LIST
79791: LIST
79792: LIST
79793: LIST
79794: LIST
79795: LIST
79796: LIST
79797: LIST
79798: LIST
79799: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79800: LD_ADDR_VAR 0 23
79804: PUSH
79805: LD_INT 0
79807: PUSH
79808: LD_INT 0
79810: PUSH
79811: EMPTY
79812: LIST
79813: LIST
79814: PUSH
79815: LD_INT 0
79817: PUSH
79818: LD_INT 1
79820: NEG
79821: PUSH
79822: EMPTY
79823: LIST
79824: LIST
79825: PUSH
79826: LD_INT 1
79828: PUSH
79829: LD_INT 0
79831: PUSH
79832: EMPTY
79833: LIST
79834: LIST
79835: PUSH
79836: LD_INT 1
79838: PUSH
79839: LD_INT 1
79841: PUSH
79842: EMPTY
79843: LIST
79844: LIST
79845: PUSH
79846: LD_INT 0
79848: PUSH
79849: LD_INT 1
79851: PUSH
79852: EMPTY
79853: LIST
79854: LIST
79855: PUSH
79856: LD_INT 1
79858: NEG
79859: PUSH
79860: LD_INT 0
79862: PUSH
79863: EMPTY
79864: LIST
79865: LIST
79866: PUSH
79867: LD_INT 1
79869: NEG
79870: PUSH
79871: LD_INT 1
79873: NEG
79874: PUSH
79875: EMPTY
79876: LIST
79877: LIST
79878: PUSH
79879: LD_INT 1
79881: NEG
79882: PUSH
79883: LD_INT 2
79885: NEG
79886: PUSH
79887: EMPTY
79888: LIST
79889: LIST
79890: PUSH
79891: LD_INT 0
79893: PUSH
79894: LD_INT 2
79896: NEG
79897: PUSH
79898: EMPTY
79899: LIST
79900: LIST
79901: PUSH
79902: LD_INT 1
79904: PUSH
79905: LD_INT 1
79907: NEG
79908: PUSH
79909: EMPTY
79910: LIST
79911: LIST
79912: PUSH
79913: LD_INT 2
79915: PUSH
79916: LD_INT 0
79918: PUSH
79919: EMPTY
79920: LIST
79921: LIST
79922: PUSH
79923: LD_INT 2
79925: PUSH
79926: LD_INT 1
79928: PUSH
79929: EMPTY
79930: LIST
79931: LIST
79932: PUSH
79933: LD_INT 2
79935: PUSH
79936: LD_INT 2
79938: PUSH
79939: EMPTY
79940: LIST
79941: LIST
79942: PUSH
79943: LD_INT 1
79945: PUSH
79946: LD_INT 2
79948: PUSH
79949: EMPTY
79950: LIST
79951: LIST
79952: PUSH
79953: LD_INT 0
79955: PUSH
79956: LD_INT 2
79958: PUSH
79959: EMPTY
79960: LIST
79961: LIST
79962: PUSH
79963: LD_INT 1
79965: NEG
79966: PUSH
79967: LD_INT 1
79969: PUSH
79970: EMPTY
79971: LIST
79972: LIST
79973: PUSH
79974: LD_INT 2
79976: NEG
79977: PUSH
79978: LD_INT 0
79980: PUSH
79981: EMPTY
79982: LIST
79983: LIST
79984: PUSH
79985: LD_INT 2
79987: NEG
79988: PUSH
79989: LD_INT 1
79991: NEG
79992: PUSH
79993: EMPTY
79994: LIST
79995: LIST
79996: PUSH
79997: LD_INT 2
79999: NEG
80000: PUSH
80001: LD_INT 2
80003: NEG
80004: PUSH
80005: EMPTY
80006: LIST
80007: LIST
80008: PUSH
80009: LD_INT 2
80011: NEG
80012: PUSH
80013: LD_INT 3
80015: NEG
80016: PUSH
80017: EMPTY
80018: LIST
80019: LIST
80020: PUSH
80021: LD_INT 1
80023: NEG
80024: PUSH
80025: LD_INT 3
80027: NEG
80028: PUSH
80029: EMPTY
80030: LIST
80031: LIST
80032: PUSH
80033: LD_INT 1
80035: PUSH
80036: LD_INT 2
80038: NEG
80039: PUSH
80040: EMPTY
80041: LIST
80042: LIST
80043: PUSH
80044: LD_INT 2
80046: PUSH
80047: LD_INT 1
80049: NEG
80050: PUSH
80051: EMPTY
80052: LIST
80053: LIST
80054: PUSH
80055: EMPTY
80056: LIST
80057: LIST
80058: LIST
80059: LIST
80060: LIST
80061: LIST
80062: LIST
80063: LIST
80064: LIST
80065: LIST
80066: LIST
80067: LIST
80068: LIST
80069: LIST
80070: LIST
80071: LIST
80072: LIST
80073: LIST
80074: LIST
80075: LIST
80076: LIST
80077: LIST
80078: LIST
80079: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
80080: LD_ADDR_VAR 0 24
80084: PUSH
80085: LD_INT 0
80087: PUSH
80088: LD_INT 0
80090: PUSH
80091: EMPTY
80092: LIST
80093: LIST
80094: PUSH
80095: LD_INT 0
80097: PUSH
80098: LD_INT 1
80100: NEG
80101: PUSH
80102: EMPTY
80103: LIST
80104: LIST
80105: PUSH
80106: LD_INT 1
80108: PUSH
80109: LD_INT 0
80111: PUSH
80112: EMPTY
80113: LIST
80114: LIST
80115: PUSH
80116: LD_INT 1
80118: PUSH
80119: LD_INT 1
80121: PUSH
80122: EMPTY
80123: LIST
80124: LIST
80125: PUSH
80126: LD_INT 0
80128: PUSH
80129: LD_INT 1
80131: PUSH
80132: EMPTY
80133: LIST
80134: LIST
80135: PUSH
80136: LD_INT 1
80138: NEG
80139: PUSH
80140: LD_INT 0
80142: PUSH
80143: EMPTY
80144: LIST
80145: LIST
80146: PUSH
80147: LD_INT 1
80149: NEG
80150: PUSH
80151: LD_INT 1
80153: NEG
80154: PUSH
80155: EMPTY
80156: LIST
80157: LIST
80158: PUSH
80159: LD_INT 1
80161: NEG
80162: PUSH
80163: LD_INT 2
80165: NEG
80166: PUSH
80167: EMPTY
80168: LIST
80169: LIST
80170: PUSH
80171: LD_INT 0
80173: PUSH
80174: LD_INT 2
80176: NEG
80177: PUSH
80178: EMPTY
80179: LIST
80180: LIST
80181: PUSH
80182: LD_INT 1
80184: PUSH
80185: LD_INT 1
80187: NEG
80188: PUSH
80189: EMPTY
80190: LIST
80191: LIST
80192: PUSH
80193: LD_INT 2
80195: PUSH
80196: LD_INT 0
80198: PUSH
80199: EMPTY
80200: LIST
80201: LIST
80202: PUSH
80203: LD_INT 2
80205: PUSH
80206: LD_INT 1
80208: PUSH
80209: EMPTY
80210: LIST
80211: LIST
80212: PUSH
80213: LD_INT 2
80215: PUSH
80216: LD_INT 2
80218: PUSH
80219: EMPTY
80220: LIST
80221: LIST
80222: PUSH
80223: LD_INT 1
80225: PUSH
80226: LD_INT 2
80228: PUSH
80229: EMPTY
80230: LIST
80231: LIST
80232: PUSH
80233: LD_INT 0
80235: PUSH
80236: LD_INT 2
80238: PUSH
80239: EMPTY
80240: LIST
80241: LIST
80242: PUSH
80243: LD_INT 1
80245: NEG
80246: PUSH
80247: LD_INT 1
80249: PUSH
80250: EMPTY
80251: LIST
80252: LIST
80253: PUSH
80254: LD_INT 2
80256: NEG
80257: PUSH
80258: LD_INT 0
80260: PUSH
80261: EMPTY
80262: LIST
80263: LIST
80264: PUSH
80265: LD_INT 2
80267: NEG
80268: PUSH
80269: LD_INT 1
80271: NEG
80272: PUSH
80273: EMPTY
80274: LIST
80275: LIST
80276: PUSH
80277: LD_INT 2
80279: NEG
80280: PUSH
80281: LD_INT 2
80283: NEG
80284: PUSH
80285: EMPTY
80286: LIST
80287: LIST
80288: PUSH
80289: LD_INT 1
80291: PUSH
80292: LD_INT 2
80294: NEG
80295: PUSH
80296: EMPTY
80297: LIST
80298: LIST
80299: PUSH
80300: LD_INT 2
80302: PUSH
80303: LD_INT 1
80305: NEG
80306: PUSH
80307: EMPTY
80308: LIST
80309: LIST
80310: PUSH
80311: LD_INT 3
80313: PUSH
80314: LD_INT 1
80316: PUSH
80317: EMPTY
80318: LIST
80319: LIST
80320: PUSH
80321: LD_INT 3
80323: PUSH
80324: LD_INT 2
80326: PUSH
80327: EMPTY
80328: LIST
80329: LIST
80330: PUSH
80331: EMPTY
80332: LIST
80333: LIST
80334: LIST
80335: LIST
80336: LIST
80337: LIST
80338: LIST
80339: LIST
80340: LIST
80341: LIST
80342: LIST
80343: LIST
80344: LIST
80345: LIST
80346: LIST
80347: LIST
80348: LIST
80349: LIST
80350: LIST
80351: LIST
80352: LIST
80353: LIST
80354: LIST
80355: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
80356: LD_ADDR_VAR 0 25
80360: PUSH
80361: LD_INT 0
80363: PUSH
80364: LD_INT 0
80366: PUSH
80367: EMPTY
80368: LIST
80369: LIST
80370: PUSH
80371: LD_INT 0
80373: PUSH
80374: LD_INT 1
80376: NEG
80377: PUSH
80378: EMPTY
80379: LIST
80380: LIST
80381: PUSH
80382: LD_INT 1
80384: PUSH
80385: LD_INT 0
80387: PUSH
80388: EMPTY
80389: LIST
80390: LIST
80391: PUSH
80392: LD_INT 1
80394: PUSH
80395: LD_INT 1
80397: PUSH
80398: EMPTY
80399: LIST
80400: LIST
80401: PUSH
80402: LD_INT 0
80404: PUSH
80405: LD_INT 1
80407: PUSH
80408: EMPTY
80409: LIST
80410: LIST
80411: PUSH
80412: LD_INT 1
80414: NEG
80415: PUSH
80416: LD_INT 0
80418: PUSH
80419: EMPTY
80420: LIST
80421: LIST
80422: PUSH
80423: LD_INT 1
80425: NEG
80426: PUSH
80427: LD_INT 1
80429: NEG
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: PUSH
80435: LD_INT 1
80437: NEG
80438: PUSH
80439: LD_INT 2
80441: NEG
80442: PUSH
80443: EMPTY
80444: LIST
80445: LIST
80446: PUSH
80447: LD_INT 0
80449: PUSH
80450: LD_INT 2
80452: NEG
80453: PUSH
80454: EMPTY
80455: LIST
80456: LIST
80457: PUSH
80458: LD_INT 1
80460: PUSH
80461: LD_INT 1
80463: NEG
80464: PUSH
80465: EMPTY
80466: LIST
80467: LIST
80468: PUSH
80469: LD_INT 2
80471: PUSH
80472: LD_INT 0
80474: PUSH
80475: EMPTY
80476: LIST
80477: LIST
80478: PUSH
80479: LD_INT 2
80481: PUSH
80482: LD_INT 1
80484: PUSH
80485: EMPTY
80486: LIST
80487: LIST
80488: PUSH
80489: LD_INT 2
80491: PUSH
80492: LD_INT 2
80494: PUSH
80495: EMPTY
80496: LIST
80497: LIST
80498: PUSH
80499: LD_INT 1
80501: PUSH
80502: LD_INT 2
80504: PUSH
80505: EMPTY
80506: LIST
80507: LIST
80508: PUSH
80509: LD_INT 0
80511: PUSH
80512: LD_INT 2
80514: PUSH
80515: EMPTY
80516: LIST
80517: LIST
80518: PUSH
80519: LD_INT 1
80521: NEG
80522: PUSH
80523: LD_INT 1
80525: PUSH
80526: EMPTY
80527: LIST
80528: LIST
80529: PUSH
80530: LD_INT 2
80532: NEG
80533: PUSH
80534: LD_INT 0
80536: PUSH
80537: EMPTY
80538: LIST
80539: LIST
80540: PUSH
80541: LD_INT 2
80543: NEG
80544: PUSH
80545: LD_INT 1
80547: NEG
80548: PUSH
80549: EMPTY
80550: LIST
80551: LIST
80552: PUSH
80553: LD_INT 2
80555: NEG
80556: PUSH
80557: LD_INT 2
80559: NEG
80560: PUSH
80561: EMPTY
80562: LIST
80563: LIST
80564: PUSH
80565: LD_INT 3
80567: PUSH
80568: LD_INT 1
80570: PUSH
80571: EMPTY
80572: LIST
80573: LIST
80574: PUSH
80575: LD_INT 3
80577: PUSH
80578: LD_INT 2
80580: PUSH
80581: EMPTY
80582: LIST
80583: LIST
80584: PUSH
80585: LD_INT 2
80587: PUSH
80588: LD_INT 3
80590: PUSH
80591: EMPTY
80592: LIST
80593: LIST
80594: PUSH
80595: LD_INT 1
80597: PUSH
80598: LD_INT 3
80600: PUSH
80601: EMPTY
80602: LIST
80603: LIST
80604: PUSH
80605: EMPTY
80606: LIST
80607: LIST
80608: LIST
80609: LIST
80610: LIST
80611: LIST
80612: LIST
80613: LIST
80614: LIST
80615: LIST
80616: LIST
80617: LIST
80618: LIST
80619: LIST
80620: LIST
80621: LIST
80622: LIST
80623: LIST
80624: LIST
80625: LIST
80626: LIST
80627: LIST
80628: LIST
80629: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
80630: LD_ADDR_VAR 0 26
80634: PUSH
80635: LD_INT 0
80637: PUSH
80638: LD_INT 0
80640: PUSH
80641: EMPTY
80642: LIST
80643: LIST
80644: PUSH
80645: LD_INT 0
80647: PUSH
80648: LD_INT 1
80650: NEG
80651: PUSH
80652: EMPTY
80653: LIST
80654: LIST
80655: PUSH
80656: LD_INT 1
80658: PUSH
80659: LD_INT 0
80661: PUSH
80662: EMPTY
80663: LIST
80664: LIST
80665: PUSH
80666: LD_INT 1
80668: PUSH
80669: LD_INT 1
80671: PUSH
80672: EMPTY
80673: LIST
80674: LIST
80675: PUSH
80676: LD_INT 0
80678: PUSH
80679: LD_INT 1
80681: PUSH
80682: EMPTY
80683: LIST
80684: LIST
80685: PUSH
80686: LD_INT 1
80688: NEG
80689: PUSH
80690: LD_INT 0
80692: PUSH
80693: EMPTY
80694: LIST
80695: LIST
80696: PUSH
80697: LD_INT 1
80699: NEG
80700: PUSH
80701: LD_INT 1
80703: NEG
80704: PUSH
80705: EMPTY
80706: LIST
80707: LIST
80708: PUSH
80709: LD_INT 1
80711: NEG
80712: PUSH
80713: LD_INT 2
80715: NEG
80716: PUSH
80717: EMPTY
80718: LIST
80719: LIST
80720: PUSH
80721: LD_INT 0
80723: PUSH
80724: LD_INT 2
80726: NEG
80727: PUSH
80728: EMPTY
80729: LIST
80730: LIST
80731: PUSH
80732: LD_INT 1
80734: PUSH
80735: LD_INT 1
80737: NEG
80738: PUSH
80739: EMPTY
80740: LIST
80741: LIST
80742: PUSH
80743: LD_INT 2
80745: PUSH
80746: LD_INT 0
80748: PUSH
80749: EMPTY
80750: LIST
80751: LIST
80752: PUSH
80753: LD_INT 2
80755: PUSH
80756: LD_INT 1
80758: PUSH
80759: EMPTY
80760: LIST
80761: LIST
80762: PUSH
80763: LD_INT 2
80765: PUSH
80766: LD_INT 2
80768: PUSH
80769: EMPTY
80770: LIST
80771: LIST
80772: PUSH
80773: LD_INT 1
80775: PUSH
80776: LD_INT 2
80778: PUSH
80779: EMPTY
80780: LIST
80781: LIST
80782: PUSH
80783: LD_INT 0
80785: PUSH
80786: LD_INT 2
80788: PUSH
80789: EMPTY
80790: LIST
80791: LIST
80792: PUSH
80793: LD_INT 1
80795: NEG
80796: PUSH
80797: LD_INT 1
80799: PUSH
80800: EMPTY
80801: LIST
80802: LIST
80803: PUSH
80804: LD_INT 2
80806: NEG
80807: PUSH
80808: LD_INT 0
80810: PUSH
80811: EMPTY
80812: LIST
80813: LIST
80814: PUSH
80815: LD_INT 2
80817: NEG
80818: PUSH
80819: LD_INT 1
80821: NEG
80822: PUSH
80823: EMPTY
80824: LIST
80825: LIST
80826: PUSH
80827: LD_INT 2
80829: NEG
80830: PUSH
80831: LD_INT 2
80833: NEG
80834: PUSH
80835: EMPTY
80836: LIST
80837: LIST
80838: PUSH
80839: LD_INT 2
80841: PUSH
80842: LD_INT 3
80844: PUSH
80845: EMPTY
80846: LIST
80847: LIST
80848: PUSH
80849: LD_INT 1
80851: PUSH
80852: LD_INT 3
80854: PUSH
80855: EMPTY
80856: LIST
80857: LIST
80858: PUSH
80859: LD_INT 1
80861: NEG
80862: PUSH
80863: LD_INT 2
80865: PUSH
80866: EMPTY
80867: LIST
80868: LIST
80869: PUSH
80870: LD_INT 2
80872: NEG
80873: PUSH
80874: LD_INT 1
80876: PUSH
80877: EMPTY
80878: LIST
80879: LIST
80880: PUSH
80881: EMPTY
80882: LIST
80883: LIST
80884: LIST
80885: LIST
80886: LIST
80887: LIST
80888: LIST
80889: LIST
80890: LIST
80891: LIST
80892: LIST
80893: LIST
80894: LIST
80895: LIST
80896: LIST
80897: LIST
80898: LIST
80899: LIST
80900: LIST
80901: LIST
80902: LIST
80903: LIST
80904: LIST
80905: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
80906: LD_ADDR_VAR 0 27
80910: PUSH
80911: LD_INT 0
80913: PUSH
80914: LD_INT 0
80916: PUSH
80917: EMPTY
80918: LIST
80919: LIST
80920: PUSH
80921: LD_INT 0
80923: PUSH
80924: LD_INT 1
80926: NEG
80927: PUSH
80928: EMPTY
80929: LIST
80930: LIST
80931: PUSH
80932: LD_INT 1
80934: PUSH
80935: LD_INT 0
80937: PUSH
80938: EMPTY
80939: LIST
80940: LIST
80941: PUSH
80942: LD_INT 1
80944: PUSH
80945: LD_INT 1
80947: PUSH
80948: EMPTY
80949: LIST
80950: LIST
80951: PUSH
80952: LD_INT 0
80954: PUSH
80955: LD_INT 1
80957: PUSH
80958: EMPTY
80959: LIST
80960: LIST
80961: PUSH
80962: LD_INT 1
80964: NEG
80965: PUSH
80966: LD_INT 0
80968: PUSH
80969: EMPTY
80970: LIST
80971: LIST
80972: PUSH
80973: LD_INT 1
80975: NEG
80976: PUSH
80977: LD_INT 1
80979: NEG
80980: PUSH
80981: EMPTY
80982: LIST
80983: LIST
80984: PUSH
80985: LD_INT 1
80987: NEG
80988: PUSH
80989: LD_INT 2
80991: NEG
80992: PUSH
80993: EMPTY
80994: LIST
80995: LIST
80996: PUSH
80997: LD_INT 0
80999: PUSH
81000: LD_INT 2
81002: NEG
81003: PUSH
81004: EMPTY
81005: LIST
81006: LIST
81007: PUSH
81008: LD_INT 1
81010: PUSH
81011: LD_INT 1
81013: NEG
81014: PUSH
81015: EMPTY
81016: LIST
81017: LIST
81018: PUSH
81019: LD_INT 2
81021: PUSH
81022: LD_INT 0
81024: PUSH
81025: EMPTY
81026: LIST
81027: LIST
81028: PUSH
81029: LD_INT 2
81031: PUSH
81032: LD_INT 1
81034: PUSH
81035: EMPTY
81036: LIST
81037: LIST
81038: PUSH
81039: LD_INT 2
81041: PUSH
81042: LD_INT 2
81044: PUSH
81045: EMPTY
81046: LIST
81047: LIST
81048: PUSH
81049: LD_INT 1
81051: PUSH
81052: LD_INT 2
81054: PUSH
81055: EMPTY
81056: LIST
81057: LIST
81058: PUSH
81059: LD_INT 0
81061: PUSH
81062: LD_INT 2
81064: PUSH
81065: EMPTY
81066: LIST
81067: LIST
81068: PUSH
81069: LD_INT 1
81071: NEG
81072: PUSH
81073: LD_INT 1
81075: PUSH
81076: EMPTY
81077: LIST
81078: LIST
81079: PUSH
81080: LD_INT 2
81082: NEG
81083: PUSH
81084: LD_INT 0
81086: PUSH
81087: EMPTY
81088: LIST
81089: LIST
81090: PUSH
81091: LD_INT 2
81093: NEG
81094: PUSH
81095: LD_INT 1
81097: NEG
81098: PUSH
81099: EMPTY
81100: LIST
81101: LIST
81102: PUSH
81103: LD_INT 2
81105: NEG
81106: PUSH
81107: LD_INT 2
81109: NEG
81110: PUSH
81111: EMPTY
81112: LIST
81113: LIST
81114: PUSH
81115: LD_INT 1
81117: NEG
81118: PUSH
81119: LD_INT 2
81121: PUSH
81122: EMPTY
81123: LIST
81124: LIST
81125: PUSH
81126: LD_INT 2
81128: NEG
81129: PUSH
81130: LD_INT 1
81132: PUSH
81133: EMPTY
81134: LIST
81135: LIST
81136: PUSH
81137: LD_INT 3
81139: NEG
81140: PUSH
81141: LD_INT 1
81143: NEG
81144: PUSH
81145: EMPTY
81146: LIST
81147: LIST
81148: PUSH
81149: LD_INT 3
81151: NEG
81152: PUSH
81153: LD_INT 2
81155: NEG
81156: PUSH
81157: EMPTY
81158: LIST
81159: LIST
81160: PUSH
81161: EMPTY
81162: LIST
81163: LIST
81164: LIST
81165: LIST
81166: LIST
81167: LIST
81168: LIST
81169: LIST
81170: LIST
81171: LIST
81172: LIST
81173: LIST
81174: LIST
81175: LIST
81176: LIST
81177: LIST
81178: LIST
81179: LIST
81180: LIST
81181: LIST
81182: LIST
81183: LIST
81184: LIST
81185: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81186: LD_ADDR_VAR 0 28
81190: PUSH
81191: LD_INT 0
81193: PUSH
81194: LD_INT 0
81196: PUSH
81197: EMPTY
81198: LIST
81199: LIST
81200: PUSH
81201: LD_INT 0
81203: PUSH
81204: LD_INT 1
81206: NEG
81207: PUSH
81208: EMPTY
81209: LIST
81210: LIST
81211: PUSH
81212: LD_INT 1
81214: PUSH
81215: LD_INT 0
81217: PUSH
81218: EMPTY
81219: LIST
81220: LIST
81221: PUSH
81222: LD_INT 1
81224: PUSH
81225: LD_INT 1
81227: PUSH
81228: EMPTY
81229: LIST
81230: LIST
81231: PUSH
81232: LD_INT 0
81234: PUSH
81235: LD_INT 1
81237: PUSH
81238: EMPTY
81239: LIST
81240: LIST
81241: PUSH
81242: LD_INT 1
81244: NEG
81245: PUSH
81246: LD_INT 0
81248: PUSH
81249: EMPTY
81250: LIST
81251: LIST
81252: PUSH
81253: LD_INT 1
81255: NEG
81256: PUSH
81257: LD_INT 1
81259: NEG
81260: PUSH
81261: EMPTY
81262: LIST
81263: LIST
81264: PUSH
81265: LD_INT 1
81267: NEG
81268: PUSH
81269: LD_INT 2
81271: NEG
81272: PUSH
81273: EMPTY
81274: LIST
81275: LIST
81276: PUSH
81277: LD_INT 0
81279: PUSH
81280: LD_INT 2
81282: NEG
81283: PUSH
81284: EMPTY
81285: LIST
81286: LIST
81287: PUSH
81288: LD_INT 1
81290: PUSH
81291: LD_INT 1
81293: NEG
81294: PUSH
81295: EMPTY
81296: LIST
81297: LIST
81298: PUSH
81299: LD_INT 2
81301: PUSH
81302: LD_INT 0
81304: PUSH
81305: EMPTY
81306: LIST
81307: LIST
81308: PUSH
81309: LD_INT 2
81311: PUSH
81312: LD_INT 1
81314: PUSH
81315: EMPTY
81316: LIST
81317: LIST
81318: PUSH
81319: LD_INT 2
81321: PUSH
81322: LD_INT 2
81324: PUSH
81325: EMPTY
81326: LIST
81327: LIST
81328: PUSH
81329: LD_INT 1
81331: PUSH
81332: LD_INT 2
81334: PUSH
81335: EMPTY
81336: LIST
81337: LIST
81338: PUSH
81339: LD_INT 0
81341: PUSH
81342: LD_INT 2
81344: PUSH
81345: EMPTY
81346: LIST
81347: LIST
81348: PUSH
81349: LD_INT 1
81351: NEG
81352: PUSH
81353: LD_INT 1
81355: PUSH
81356: EMPTY
81357: LIST
81358: LIST
81359: PUSH
81360: LD_INT 2
81362: NEG
81363: PUSH
81364: LD_INT 0
81366: PUSH
81367: EMPTY
81368: LIST
81369: LIST
81370: PUSH
81371: LD_INT 2
81373: NEG
81374: PUSH
81375: LD_INT 1
81377: NEG
81378: PUSH
81379: EMPTY
81380: LIST
81381: LIST
81382: PUSH
81383: LD_INT 2
81385: NEG
81386: PUSH
81387: LD_INT 2
81389: NEG
81390: PUSH
81391: EMPTY
81392: LIST
81393: LIST
81394: PUSH
81395: LD_INT 2
81397: NEG
81398: PUSH
81399: LD_INT 3
81401: NEG
81402: PUSH
81403: EMPTY
81404: LIST
81405: LIST
81406: PUSH
81407: LD_INT 1
81409: NEG
81410: PUSH
81411: LD_INT 3
81413: NEG
81414: PUSH
81415: EMPTY
81416: LIST
81417: LIST
81418: PUSH
81419: LD_INT 3
81421: NEG
81422: PUSH
81423: LD_INT 1
81425: NEG
81426: PUSH
81427: EMPTY
81428: LIST
81429: LIST
81430: PUSH
81431: LD_INT 3
81433: NEG
81434: PUSH
81435: LD_INT 2
81437: NEG
81438: PUSH
81439: EMPTY
81440: LIST
81441: LIST
81442: PUSH
81443: EMPTY
81444: LIST
81445: LIST
81446: LIST
81447: LIST
81448: LIST
81449: LIST
81450: LIST
81451: LIST
81452: LIST
81453: LIST
81454: LIST
81455: LIST
81456: LIST
81457: LIST
81458: LIST
81459: LIST
81460: LIST
81461: LIST
81462: LIST
81463: LIST
81464: LIST
81465: LIST
81466: LIST
81467: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
81468: LD_ADDR_VAR 0 29
81472: PUSH
81473: LD_INT 0
81475: PUSH
81476: LD_INT 0
81478: PUSH
81479: EMPTY
81480: LIST
81481: LIST
81482: PUSH
81483: LD_INT 0
81485: PUSH
81486: LD_INT 1
81488: NEG
81489: PUSH
81490: EMPTY
81491: LIST
81492: LIST
81493: PUSH
81494: LD_INT 1
81496: PUSH
81497: LD_INT 0
81499: PUSH
81500: EMPTY
81501: LIST
81502: LIST
81503: PUSH
81504: LD_INT 1
81506: PUSH
81507: LD_INT 1
81509: PUSH
81510: EMPTY
81511: LIST
81512: LIST
81513: PUSH
81514: LD_INT 0
81516: PUSH
81517: LD_INT 1
81519: PUSH
81520: EMPTY
81521: LIST
81522: LIST
81523: PUSH
81524: LD_INT 1
81526: NEG
81527: PUSH
81528: LD_INT 0
81530: PUSH
81531: EMPTY
81532: LIST
81533: LIST
81534: PUSH
81535: LD_INT 1
81537: NEG
81538: PUSH
81539: LD_INT 1
81541: NEG
81542: PUSH
81543: EMPTY
81544: LIST
81545: LIST
81546: PUSH
81547: LD_INT 1
81549: NEG
81550: PUSH
81551: LD_INT 2
81553: NEG
81554: PUSH
81555: EMPTY
81556: LIST
81557: LIST
81558: PUSH
81559: LD_INT 0
81561: PUSH
81562: LD_INT 2
81564: NEG
81565: PUSH
81566: EMPTY
81567: LIST
81568: LIST
81569: PUSH
81570: LD_INT 1
81572: PUSH
81573: LD_INT 1
81575: NEG
81576: PUSH
81577: EMPTY
81578: LIST
81579: LIST
81580: PUSH
81581: LD_INT 2
81583: PUSH
81584: LD_INT 0
81586: PUSH
81587: EMPTY
81588: LIST
81589: LIST
81590: PUSH
81591: LD_INT 2
81593: PUSH
81594: LD_INT 1
81596: PUSH
81597: EMPTY
81598: LIST
81599: LIST
81600: PUSH
81601: LD_INT 1
81603: PUSH
81604: LD_INT 2
81606: PUSH
81607: EMPTY
81608: LIST
81609: LIST
81610: PUSH
81611: LD_INT 0
81613: PUSH
81614: LD_INT 2
81616: PUSH
81617: EMPTY
81618: LIST
81619: LIST
81620: PUSH
81621: LD_INT 1
81623: NEG
81624: PUSH
81625: LD_INT 1
81627: PUSH
81628: EMPTY
81629: LIST
81630: LIST
81631: PUSH
81632: LD_INT 2
81634: NEG
81635: PUSH
81636: LD_INT 1
81638: NEG
81639: PUSH
81640: EMPTY
81641: LIST
81642: LIST
81643: PUSH
81644: LD_INT 2
81646: NEG
81647: PUSH
81648: LD_INT 2
81650: NEG
81651: PUSH
81652: EMPTY
81653: LIST
81654: LIST
81655: PUSH
81656: LD_INT 2
81658: NEG
81659: PUSH
81660: LD_INT 3
81662: NEG
81663: PUSH
81664: EMPTY
81665: LIST
81666: LIST
81667: PUSH
81668: LD_INT 2
81670: PUSH
81671: LD_INT 1
81673: NEG
81674: PUSH
81675: EMPTY
81676: LIST
81677: LIST
81678: PUSH
81679: LD_INT 3
81681: PUSH
81682: LD_INT 1
81684: PUSH
81685: EMPTY
81686: LIST
81687: LIST
81688: PUSH
81689: LD_INT 1
81691: PUSH
81692: LD_INT 3
81694: PUSH
81695: EMPTY
81696: LIST
81697: LIST
81698: PUSH
81699: LD_INT 1
81701: NEG
81702: PUSH
81703: LD_INT 2
81705: PUSH
81706: EMPTY
81707: LIST
81708: LIST
81709: PUSH
81710: LD_INT 3
81712: NEG
81713: PUSH
81714: LD_INT 2
81716: NEG
81717: PUSH
81718: EMPTY
81719: LIST
81720: LIST
81721: PUSH
81722: EMPTY
81723: LIST
81724: LIST
81725: LIST
81726: LIST
81727: LIST
81728: LIST
81729: LIST
81730: LIST
81731: LIST
81732: LIST
81733: LIST
81734: LIST
81735: LIST
81736: LIST
81737: LIST
81738: LIST
81739: LIST
81740: LIST
81741: LIST
81742: LIST
81743: LIST
81744: LIST
81745: LIST
81746: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
81747: LD_ADDR_VAR 0 30
81751: PUSH
81752: LD_INT 0
81754: PUSH
81755: LD_INT 0
81757: PUSH
81758: EMPTY
81759: LIST
81760: LIST
81761: PUSH
81762: LD_INT 0
81764: PUSH
81765: LD_INT 1
81767: NEG
81768: PUSH
81769: EMPTY
81770: LIST
81771: LIST
81772: PUSH
81773: LD_INT 1
81775: PUSH
81776: LD_INT 0
81778: PUSH
81779: EMPTY
81780: LIST
81781: LIST
81782: PUSH
81783: LD_INT 1
81785: PUSH
81786: LD_INT 1
81788: PUSH
81789: EMPTY
81790: LIST
81791: LIST
81792: PUSH
81793: LD_INT 0
81795: PUSH
81796: LD_INT 1
81798: PUSH
81799: EMPTY
81800: LIST
81801: LIST
81802: PUSH
81803: LD_INT 1
81805: NEG
81806: PUSH
81807: LD_INT 0
81809: PUSH
81810: EMPTY
81811: LIST
81812: LIST
81813: PUSH
81814: LD_INT 1
81816: NEG
81817: PUSH
81818: LD_INT 1
81820: NEG
81821: PUSH
81822: EMPTY
81823: LIST
81824: LIST
81825: PUSH
81826: LD_INT 1
81828: NEG
81829: PUSH
81830: LD_INT 2
81832: NEG
81833: PUSH
81834: EMPTY
81835: LIST
81836: LIST
81837: PUSH
81838: LD_INT 0
81840: PUSH
81841: LD_INT 2
81843: NEG
81844: PUSH
81845: EMPTY
81846: LIST
81847: LIST
81848: PUSH
81849: LD_INT 1
81851: PUSH
81852: LD_INT 1
81854: NEG
81855: PUSH
81856: EMPTY
81857: LIST
81858: LIST
81859: PUSH
81860: LD_INT 2
81862: PUSH
81863: LD_INT 0
81865: PUSH
81866: EMPTY
81867: LIST
81868: LIST
81869: PUSH
81870: LD_INT 2
81872: PUSH
81873: LD_INT 1
81875: PUSH
81876: EMPTY
81877: LIST
81878: LIST
81879: PUSH
81880: LD_INT 2
81882: PUSH
81883: LD_INT 2
81885: PUSH
81886: EMPTY
81887: LIST
81888: LIST
81889: PUSH
81890: LD_INT 1
81892: PUSH
81893: LD_INT 2
81895: PUSH
81896: EMPTY
81897: LIST
81898: LIST
81899: PUSH
81900: LD_INT 1
81902: NEG
81903: PUSH
81904: LD_INT 1
81906: PUSH
81907: EMPTY
81908: LIST
81909: LIST
81910: PUSH
81911: LD_INT 2
81913: NEG
81914: PUSH
81915: LD_INT 0
81917: PUSH
81918: EMPTY
81919: LIST
81920: LIST
81921: PUSH
81922: LD_INT 2
81924: NEG
81925: PUSH
81926: LD_INT 1
81928: NEG
81929: PUSH
81930: EMPTY
81931: LIST
81932: LIST
81933: PUSH
81934: LD_INT 1
81936: NEG
81937: PUSH
81938: LD_INT 3
81940: NEG
81941: PUSH
81942: EMPTY
81943: LIST
81944: LIST
81945: PUSH
81946: LD_INT 1
81948: PUSH
81949: LD_INT 2
81951: NEG
81952: PUSH
81953: EMPTY
81954: LIST
81955: LIST
81956: PUSH
81957: LD_INT 3
81959: PUSH
81960: LD_INT 2
81962: PUSH
81963: EMPTY
81964: LIST
81965: LIST
81966: PUSH
81967: LD_INT 2
81969: PUSH
81970: LD_INT 3
81972: PUSH
81973: EMPTY
81974: LIST
81975: LIST
81976: PUSH
81977: LD_INT 2
81979: NEG
81980: PUSH
81981: LD_INT 1
81983: PUSH
81984: EMPTY
81985: LIST
81986: LIST
81987: PUSH
81988: LD_INT 3
81990: NEG
81991: PUSH
81992: LD_INT 1
81994: NEG
81995: PUSH
81996: EMPTY
81997: LIST
81998: LIST
81999: PUSH
82000: EMPTY
82001: LIST
82002: LIST
82003: LIST
82004: LIST
82005: LIST
82006: LIST
82007: LIST
82008: LIST
82009: LIST
82010: LIST
82011: LIST
82012: LIST
82013: LIST
82014: LIST
82015: LIST
82016: LIST
82017: LIST
82018: LIST
82019: LIST
82020: LIST
82021: LIST
82022: LIST
82023: LIST
82024: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82025: LD_ADDR_VAR 0 31
82029: PUSH
82030: LD_INT 0
82032: PUSH
82033: LD_INT 0
82035: PUSH
82036: EMPTY
82037: LIST
82038: LIST
82039: PUSH
82040: LD_INT 0
82042: PUSH
82043: LD_INT 1
82045: NEG
82046: PUSH
82047: EMPTY
82048: LIST
82049: LIST
82050: PUSH
82051: LD_INT 1
82053: PUSH
82054: LD_INT 0
82056: PUSH
82057: EMPTY
82058: LIST
82059: LIST
82060: PUSH
82061: LD_INT 1
82063: PUSH
82064: LD_INT 1
82066: PUSH
82067: EMPTY
82068: LIST
82069: LIST
82070: PUSH
82071: LD_INT 0
82073: PUSH
82074: LD_INT 1
82076: PUSH
82077: EMPTY
82078: LIST
82079: LIST
82080: PUSH
82081: LD_INT 1
82083: NEG
82084: PUSH
82085: LD_INT 0
82087: PUSH
82088: EMPTY
82089: LIST
82090: LIST
82091: PUSH
82092: LD_INT 1
82094: NEG
82095: PUSH
82096: LD_INT 1
82098: NEG
82099: PUSH
82100: EMPTY
82101: LIST
82102: LIST
82103: PUSH
82104: LD_INT 1
82106: NEG
82107: PUSH
82108: LD_INT 2
82110: NEG
82111: PUSH
82112: EMPTY
82113: LIST
82114: LIST
82115: PUSH
82116: LD_INT 1
82118: PUSH
82119: LD_INT 1
82121: NEG
82122: PUSH
82123: EMPTY
82124: LIST
82125: LIST
82126: PUSH
82127: LD_INT 2
82129: PUSH
82130: LD_INT 0
82132: PUSH
82133: EMPTY
82134: LIST
82135: LIST
82136: PUSH
82137: LD_INT 2
82139: PUSH
82140: LD_INT 1
82142: PUSH
82143: EMPTY
82144: LIST
82145: LIST
82146: PUSH
82147: LD_INT 2
82149: PUSH
82150: LD_INT 2
82152: PUSH
82153: EMPTY
82154: LIST
82155: LIST
82156: PUSH
82157: LD_INT 1
82159: PUSH
82160: LD_INT 2
82162: PUSH
82163: EMPTY
82164: LIST
82165: LIST
82166: PUSH
82167: LD_INT 0
82169: PUSH
82170: LD_INT 2
82172: PUSH
82173: EMPTY
82174: LIST
82175: LIST
82176: PUSH
82177: LD_INT 1
82179: NEG
82180: PUSH
82181: LD_INT 1
82183: PUSH
82184: EMPTY
82185: LIST
82186: LIST
82187: PUSH
82188: LD_INT 2
82190: NEG
82191: PUSH
82192: LD_INT 1
82194: NEG
82195: PUSH
82196: EMPTY
82197: LIST
82198: LIST
82199: PUSH
82200: LD_INT 2
82202: NEG
82203: PUSH
82204: LD_INT 2
82206: NEG
82207: PUSH
82208: EMPTY
82209: LIST
82210: LIST
82211: PUSH
82212: LD_INT 2
82214: NEG
82215: PUSH
82216: LD_INT 3
82218: NEG
82219: PUSH
82220: EMPTY
82221: LIST
82222: LIST
82223: PUSH
82224: LD_INT 2
82226: PUSH
82227: LD_INT 1
82229: NEG
82230: PUSH
82231: EMPTY
82232: LIST
82233: LIST
82234: PUSH
82235: LD_INT 3
82237: PUSH
82238: LD_INT 1
82240: PUSH
82241: EMPTY
82242: LIST
82243: LIST
82244: PUSH
82245: LD_INT 1
82247: PUSH
82248: LD_INT 3
82250: PUSH
82251: EMPTY
82252: LIST
82253: LIST
82254: PUSH
82255: LD_INT 1
82257: NEG
82258: PUSH
82259: LD_INT 2
82261: PUSH
82262: EMPTY
82263: LIST
82264: LIST
82265: PUSH
82266: LD_INT 3
82268: NEG
82269: PUSH
82270: LD_INT 2
82272: NEG
82273: PUSH
82274: EMPTY
82275: LIST
82276: LIST
82277: PUSH
82278: EMPTY
82279: LIST
82280: LIST
82281: LIST
82282: LIST
82283: LIST
82284: LIST
82285: LIST
82286: LIST
82287: LIST
82288: LIST
82289: LIST
82290: LIST
82291: LIST
82292: LIST
82293: LIST
82294: LIST
82295: LIST
82296: LIST
82297: LIST
82298: LIST
82299: LIST
82300: LIST
82301: LIST
82302: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82303: LD_ADDR_VAR 0 32
82307: PUSH
82308: LD_INT 0
82310: PUSH
82311: LD_INT 0
82313: PUSH
82314: EMPTY
82315: LIST
82316: LIST
82317: PUSH
82318: LD_INT 0
82320: PUSH
82321: LD_INT 1
82323: NEG
82324: PUSH
82325: EMPTY
82326: LIST
82327: LIST
82328: PUSH
82329: LD_INT 1
82331: PUSH
82332: LD_INT 0
82334: PUSH
82335: EMPTY
82336: LIST
82337: LIST
82338: PUSH
82339: LD_INT 1
82341: PUSH
82342: LD_INT 1
82344: PUSH
82345: EMPTY
82346: LIST
82347: LIST
82348: PUSH
82349: LD_INT 0
82351: PUSH
82352: LD_INT 1
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: PUSH
82359: LD_INT 1
82361: NEG
82362: PUSH
82363: LD_INT 0
82365: PUSH
82366: EMPTY
82367: LIST
82368: LIST
82369: PUSH
82370: LD_INT 1
82372: NEG
82373: PUSH
82374: LD_INT 1
82376: NEG
82377: PUSH
82378: EMPTY
82379: LIST
82380: LIST
82381: PUSH
82382: LD_INT 1
82384: NEG
82385: PUSH
82386: LD_INT 2
82388: NEG
82389: PUSH
82390: EMPTY
82391: LIST
82392: LIST
82393: PUSH
82394: LD_INT 0
82396: PUSH
82397: LD_INT 2
82399: NEG
82400: PUSH
82401: EMPTY
82402: LIST
82403: LIST
82404: PUSH
82405: LD_INT 1
82407: PUSH
82408: LD_INT 1
82410: NEG
82411: PUSH
82412: EMPTY
82413: LIST
82414: LIST
82415: PUSH
82416: LD_INT 2
82418: PUSH
82419: LD_INT 1
82421: PUSH
82422: EMPTY
82423: LIST
82424: LIST
82425: PUSH
82426: LD_INT 2
82428: PUSH
82429: LD_INT 2
82431: PUSH
82432: EMPTY
82433: LIST
82434: LIST
82435: PUSH
82436: LD_INT 1
82438: PUSH
82439: LD_INT 2
82441: PUSH
82442: EMPTY
82443: LIST
82444: LIST
82445: PUSH
82446: LD_INT 0
82448: PUSH
82449: LD_INT 2
82451: PUSH
82452: EMPTY
82453: LIST
82454: LIST
82455: PUSH
82456: LD_INT 1
82458: NEG
82459: PUSH
82460: LD_INT 1
82462: PUSH
82463: EMPTY
82464: LIST
82465: LIST
82466: PUSH
82467: LD_INT 2
82469: NEG
82470: PUSH
82471: LD_INT 0
82473: PUSH
82474: EMPTY
82475: LIST
82476: LIST
82477: PUSH
82478: LD_INT 2
82480: NEG
82481: PUSH
82482: LD_INT 1
82484: NEG
82485: PUSH
82486: EMPTY
82487: LIST
82488: LIST
82489: PUSH
82490: LD_INT 1
82492: NEG
82493: PUSH
82494: LD_INT 3
82496: NEG
82497: PUSH
82498: EMPTY
82499: LIST
82500: LIST
82501: PUSH
82502: LD_INT 1
82504: PUSH
82505: LD_INT 2
82507: NEG
82508: PUSH
82509: EMPTY
82510: LIST
82511: LIST
82512: PUSH
82513: LD_INT 3
82515: PUSH
82516: LD_INT 2
82518: PUSH
82519: EMPTY
82520: LIST
82521: LIST
82522: PUSH
82523: LD_INT 2
82525: PUSH
82526: LD_INT 3
82528: PUSH
82529: EMPTY
82530: LIST
82531: LIST
82532: PUSH
82533: LD_INT 2
82535: NEG
82536: PUSH
82537: LD_INT 1
82539: PUSH
82540: EMPTY
82541: LIST
82542: LIST
82543: PUSH
82544: LD_INT 3
82546: NEG
82547: PUSH
82548: LD_INT 1
82550: NEG
82551: PUSH
82552: EMPTY
82553: LIST
82554: LIST
82555: PUSH
82556: EMPTY
82557: LIST
82558: LIST
82559: LIST
82560: LIST
82561: LIST
82562: LIST
82563: LIST
82564: LIST
82565: LIST
82566: LIST
82567: LIST
82568: LIST
82569: LIST
82570: LIST
82571: LIST
82572: LIST
82573: LIST
82574: LIST
82575: LIST
82576: LIST
82577: LIST
82578: LIST
82579: LIST
82580: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82581: LD_ADDR_VAR 0 33
82585: PUSH
82586: LD_INT 0
82588: PUSH
82589: LD_INT 0
82591: PUSH
82592: EMPTY
82593: LIST
82594: LIST
82595: PUSH
82596: LD_INT 0
82598: PUSH
82599: LD_INT 1
82601: NEG
82602: PUSH
82603: EMPTY
82604: LIST
82605: LIST
82606: PUSH
82607: LD_INT 1
82609: PUSH
82610: LD_INT 0
82612: PUSH
82613: EMPTY
82614: LIST
82615: LIST
82616: PUSH
82617: LD_INT 1
82619: PUSH
82620: LD_INT 1
82622: PUSH
82623: EMPTY
82624: LIST
82625: LIST
82626: PUSH
82627: LD_INT 0
82629: PUSH
82630: LD_INT 1
82632: PUSH
82633: EMPTY
82634: LIST
82635: LIST
82636: PUSH
82637: LD_INT 1
82639: NEG
82640: PUSH
82641: LD_INT 0
82643: PUSH
82644: EMPTY
82645: LIST
82646: LIST
82647: PUSH
82648: LD_INT 1
82650: NEG
82651: PUSH
82652: LD_INT 1
82654: NEG
82655: PUSH
82656: EMPTY
82657: LIST
82658: LIST
82659: PUSH
82660: LD_INT 1
82662: NEG
82663: PUSH
82664: LD_INT 2
82666: NEG
82667: PUSH
82668: EMPTY
82669: LIST
82670: LIST
82671: PUSH
82672: LD_INT 1
82674: PUSH
82675: LD_INT 1
82677: NEG
82678: PUSH
82679: EMPTY
82680: LIST
82681: LIST
82682: PUSH
82683: LD_INT 2
82685: PUSH
82686: LD_INT 0
82688: PUSH
82689: EMPTY
82690: LIST
82691: LIST
82692: PUSH
82693: LD_INT 2
82695: PUSH
82696: LD_INT 1
82698: PUSH
82699: EMPTY
82700: LIST
82701: LIST
82702: PUSH
82703: LD_INT 1
82705: PUSH
82706: LD_INT 2
82708: PUSH
82709: EMPTY
82710: LIST
82711: LIST
82712: PUSH
82713: LD_INT 0
82715: PUSH
82716: LD_INT 2
82718: PUSH
82719: EMPTY
82720: LIST
82721: LIST
82722: PUSH
82723: LD_INT 1
82725: NEG
82726: PUSH
82727: LD_INT 1
82729: PUSH
82730: EMPTY
82731: LIST
82732: LIST
82733: PUSH
82734: LD_INT 2
82736: NEG
82737: PUSH
82738: LD_INT 0
82740: PUSH
82741: EMPTY
82742: LIST
82743: LIST
82744: PUSH
82745: LD_INT 2
82747: NEG
82748: PUSH
82749: LD_INT 1
82751: NEG
82752: PUSH
82753: EMPTY
82754: LIST
82755: LIST
82756: PUSH
82757: LD_INT 2
82759: NEG
82760: PUSH
82761: LD_INT 2
82763: NEG
82764: PUSH
82765: EMPTY
82766: LIST
82767: LIST
82768: PUSH
82769: LD_INT 2
82771: NEG
82772: PUSH
82773: LD_INT 3
82775: NEG
82776: PUSH
82777: EMPTY
82778: LIST
82779: LIST
82780: PUSH
82781: LD_INT 2
82783: PUSH
82784: LD_INT 1
82786: NEG
82787: PUSH
82788: EMPTY
82789: LIST
82790: LIST
82791: PUSH
82792: LD_INT 3
82794: PUSH
82795: LD_INT 1
82797: PUSH
82798: EMPTY
82799: LIST
82800: LIST
82801: PUSH
82802: LD_INT 1
82804: PUSH
82805: LD_INT 3
82807: PUSH
82808: EMPTY
82809: LIST
82810: LIST
82811: PUSH
82812: LD_INT 1
82814: NEG
82815: PUSH
82816: LD_INT 2
82818: PUSH
82819: EMPTY
82820: LIST
82821: LIST
82822: PUSH
82823: LD_INT 3
82825: NEG
82826: PUSH
82827: LD_INT 2
82829: NEG
82830: PUSH
82831: EMPTY
82832: LIST
82833: LIST
82834: PUSH
82835: EMPTY
82836: LIST
82837: LIST
82838: LIST
82839: LIST
82840: LIST
82841: LIST
82842: LIST
82843: LIST
82844: LIST
82845: LIST
82846: LIST
82847: LIST
82848: LIST
82849: LIST
82850: LIST
82851: LIST
82852: LIST
82853: LIST
82854: LIST
82855: LIST
82856: LIST
82857: LIST
82858: LIST
82859: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82860: LD_ADDR_VAR 0 34
82864: PUSH
82865: LD_INT 0
82867: PUSH
82868: LD_INT 0
82870: PUSH
82871: EMPTY
82872: LIST
82873: LIST
82874: PUSH
82875: LD_INT 0
82877: PUSH
82878: LD_INT 1
82880: NEG
82881: PUSH
82882: EMPTY
82883: LIST
82884: LIST
82885: PUSH
82886: LD_INT 1
82888: PUSH
82889: LD_INT 0
82891: PUSH
82892: EMPTY
82893: LIST
82894: LIST
82895: PUSH
82896: LD_INT 1
82898: PUSH
82899: LD_INT 1
82901: PUSH
82902: EMPTY
82903: LIST
82904: LIST
82905: PUSH
82906: LD_INT 0
82908: PUSH
82909: LD_INT 1
82911: PUSH
82912: EMPTY
82913: LIST
82914: LIST
82915: PUSH
82916: LD_INT 1
82918: NEG
82919: PUSH
82920: LD_INT 0
82922: PUSH
82923: EMPTY
82924: LIST
82925: LIST
82926: PUSH
82927: LD_INT 1
82929: NEG
82930: PUSH
82931: LD_INT 1
82933: NEG
82934: PUSH
82935: EMPTY
82936: LIST
82937: LIST
82938: PUSH
82939: LD_INT 1
82941: NEG
82942: PUSH
82943: LD_INT 2
82945: NEG
82946: PUSH
82947: EMPTY
82948: LIST
82949: LIST
82950: PUSH
82951: LD_INT 0
82953: PUSH
82954: LD_INT 2
82956: NEG
82957: PUSH
82958: EMPTY
82959: LIST
82960: LIST
82961: PUSH
82962: LD_INT 1
82964: PUSH
82965: LD_INT 1
82967: NEG
82968: PUSH
82969: EMPTY
82970: LIST
82971: LIST
82972: PUSH
82973: LD_INT 2
82975: PUSH
82976: LD_INT 1
82978: PUSH
82979: EMPTY
82980: LIST
82981: LIST
82982: PUSH
82983: LD_INT 2
82985: PUSH
82986: LD_INT 2
82988: PUSH
82989: EMPTY
82990: LIST
82991: LIST
82992: PUSH
82993: LD_INT 1
82995: PUSH
82996: LD_INT 2
82998: PUSH
82999: EMPTY
83000: LIST
83001: LIST
83002: PUSH
83003: LD_INT 1
83005: NEG
83006: PUSH
83007: LD_INT 1
83009: PUSH
83010: EMPTY
83011: LIST
83012: LIST
83013: PUSH
83014: LD_INT 2
83016: NEG
83017: PUSH
83018: LD_INT 0
83020: PUSH
83021: EMPTY
83022: LIST
83023: LIST
83024: PUSH
83025: LD_INT 2
83027: NEG
83028: PUSH
83029: LD_INT 1
83031: NEG
83032: PUSH
83033: EMPTY
83034: LIST
83035: LIST
83036: PUSH
83037: LD_INT 2
83039: NEG
83040: PUSH
83041: LD_INT 2
83043: NEG
83044: PUSH
83045: EMPTY
83046: LIST
83047: LIST
83048: PUSH
83049: LD_INT 1
83051: NEG
83052: PUSH
83053: LD_INT 3
83055: NEG
83056: PUSH
83057: EMPTY
83058: LIST
83059: LIST
83060: PUSH
83061: LD_INT 1
83063: PUSH
83064: LD_INT 2
83066: NEG
83067: PUSH
83068: EMPTY
83069: LIST
83070: LIST
83071: PUSH
83072: LD_INT 3
83074: PUSH
83075: LD_INT 2
83077: PUSH
83078: EMPTY
83079: LIST
83080: LIST
83081: PUSH
83082: LD_INT 2
83084: PUSH
83085: LD_INT 3
83087: PUSH
83088: EMPTY
83089: LIST
83090: LIST
83091: PUSH
83092: LD_INT 2
83094: NEG
83095: PUSH
83096: LD_INT 1
83098: PUSH
83099: EMPTY
83100: LIST
83101: LIST
83102: PUSH
83103: LD_INT 3
83105: NEG
83106: PUSH
83107: LD_INT 1
83109: NEG
83110: PUSH
83111: EMPTY
83112: LIST
83113: LIST
83114: PUSH
83115: EMPTY
83116: LIST
83117: LIST
83118: LIST
83119: LIST
83120: LIST
83121: LIST
83122: LIST
83123: LIST
83124: LIST
83125: LIST
83126: LIST
83127: LIST
83128: LIST
83129: LIST
83130: LIST
83131: LIST
83132: LIST
83133: LIST
83134: LIST
83135: LIST
83136: LIST
83137: LIST
83138: LIST
83139: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
83140: LD_ADDR_VAR 0 35
83144: PUSH
83145: LD_INT 0
83147: PUSH
83148: LD_INT 0
83150: PUSH
83151: EMPTY
83152: LIST
83153: LIST
83154: PUSH
83155: LD_INT 0
83157: PUSH
83158: LD_INT 1
83160: NEG
83161: PUSH
83162: EMPTY
83163: LIST
83164: LIST
83165: PUSH
83166: LD_INT 1
83168: PUSH
83169: LD_INT 0
83171: PUSH
83172: EMPTY
83173: LIST
83174: LIST
83175: PUSH
83176: LD_INT 1
83178: PUSH
83179: LD_INT 1
83181: PUSH
83182: EMPTY
83183: LIST
83184: LIST
83185: PUSH
83186: LD_INT 0
83188: PUSH
83189: LD_INT 1
83191: PUSH
83192: EMPTY
83193: LIST
83194: LIST
83195: PUSH
83196: LD_INT 1
83198: NEG
83199: PUSH
83200: LD_INT 0
83202: PUSH
83203: EMPTY
83204: LIST
83205: LIST
83206: PUSH
83207: LD_INT 1
83209: NEG
83210: PUSH
83211: LD_INT 1
83213: NEG
83214: PUSH
83215: EMPTY
83216: LIST
83217: LIST
83218: PUSH
83219: LD_INT 2
83221: PUSH
83222: LD_INT 1
83224: PUSH
83225: EMPTY
83226: LIST
83227: LIST
83228: PUSH
83229: LD_INT 2
83231: NEG
83232: PUSH
83233: LD_INT 1
83235: NEG
83236: PUSH
83237: EMPTY
83238: LIST
83239: LIST
83240: PUSH
83241: EMPTY
83242: LIST
83243: LIST
83244: LIST
83245: LIST
83246: LIST
83247: LIST
83248: LIST
83249: LIST
83250: LIST
83251: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
83252: LD_ADDR_VAR 0 36
83256: PUSH
83257: LD_INT 0
83259: PUSH
83260: LD_INT 0
83262: PUSH
83263: EMPTY
83264: LIST
83265: LIST
83266: PUSH
83267: LD_INT 0
83269: PUSH
83270: LD_INT 1
83272: NEG
83273: PUSH
83274: EMPTY
83275: LIST
83276: LIST
83277: PUSH
83278: LD_INT 1
83280: PUSH
83281: LD_INT 0
83283: PUSH
83284: EMPTY
83285: LIST
83286: LIST
83287: PUSH
83288: LD_INT 1
83290: PUSH
83291: LD_INT 1
83293: PUSH
83294: EMPTY
83295: LIST
83296: LIST
83297: PUSH
83298: LD_INT 0
83300: PUSH
83301: LD_INT 1
83303: PUSH
83304: EMPTY
83305: LIST
83306: LIST
83307: PUSH
83308: LD_INT 1
83310: NEG
83311: PUSH
83312: LD_INT 0
83314: PUSH
83315: EMPTY
83316: LIST
83317: LIST
83318: PUSH
83319: LD_INT 1
83321: NEG
83322: PUSH
83323: LD_INT 1
83325: NEG
83326: PUSH
83327: EMPTY
83328: LIST
83329: LIST
83330: PUSH
83331: LD_INT 1
83333: NEG
83334: PUSH
83335: LD_INT 2
83337: NEG
83338: PUSH
83339: EMPTY
83340: LIST
83341: LIST
83342: PUSH
83343: LD_INT 1
83345: PUSH
83346: LD_INT 2
83348: PUSH
83349: EMPTY
83350: LIST
83351: LIST
83352: PUSH
83353: EMPTY
83354: LIST
83355: LIST
83356: LIST
83357: LIST
83358: LIST
83359: LIST
83360: LIST
83361: LIST
83362: LIST
83363: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
83364: LD_ADDR_VAR 0 37
83368: PUSH
83369: LD_INT 0
83371: PUSH
83372: LD_INT 0
83374: PUSH
83375: EMPTY
83376: LIST
83377: LIST
83378: PUSH
83379: LD_INT 0
83381: PUSH
83382: LD_INT 1
83384: NEG
83385: PUSH
83386: EMPTY
83387: LIST
83388: LIST
83389: PUSH
83390: LD_INT 1
83392: PUSH
83393: LD_INT 0
83395: PUSH
83396: EMPTY
83397: LIST
83398: LIST
83399: PUSH
83400: LD_INT 1
83402: PUSH
83403: LD_INT 1
83405: PUSH
83406: EMPTY
83407: LIST
83408: LIST
83409: PUSH
83410: LD_INT 0
83412: PUSH
83413: LD_INT 1
83415: PUSH
83416: EMPTY
83417: LIST
83418: LIST
83419: PUSH
83420: LD_INT 1
83422: NEG
83423: PUSH
83424: LD_INT 0
83426: PUSH
83427: EMPTY
83428: LIST
83429: LIST
83430: PUSH
83431: LD_INT 1
83433: NEG
83434: PUSH
83435: LD_INT 1
83437: NEG
83438: PUSH
83439: EMPTY
83440: LIST
83441: LIST
83442: PUSH
83443: LD_INT 1
83445: PUSH
83446: LD_INT 1
83448: NEG
83449: PUSH
83450: EMPTY
83451: LIST
83452: LIST
83453: PUSH
83454: LD_INT 1
83456: NEG
83457: PUSH
83458: LD_INT 1
83460: PUSH
83461: EMPTY
83462: LIST
83463: LIST
83464: PUSH
83465: EMPTY
83466: LIST
83467: LIST
83468: LIST
83469: LIST
83470: LIST
83471: LIST
83472: LIST
83473: LIST
83474: LIST
83475: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
83476: LD_ADDR_VAR 0 38
83480: PUSH
83481: LD_INT 0
83483: PUSH
83484: LD_INT 0
83486: PUSH
83487: EMPTY
83488: LIST
83489: LIST
83490: PUSH
83491: LD_INT 0
83493: PUSH
83494: LD_INT 1
83496: NEG
83497: PUSH
83498: EMPTY
83499: LIST
83500: LIST
83501: PUSH
83502: LD_INT 1
83504: PUSH
83505: LD_INT 0
83507: PUSH
83508: EMPTY
83509: LIST
83510: LIST
83511: PUSH
83512: LD_INT 1
83514: PUSH
83515: LD_INT 1
83517: PUSH
83518: EMPTY
83519: LIST
83520: LIST
83521: PUSH
83522: LD_INT 0
83524: PUSH
83525: LD_INT 1
83527: PUSH
83528: EMPTY
83529: LIST
83530: LIST
83531: PUSH
83532: LD_INT 1
83534: NEG
83535: PUSH
83536: LD_INT 0
83538: PUSH
83539: EMPTY
83540: LIST
83541: LIST
83542: PUSH
83543: LD_INT 1
83545: NEG
83546: PUSH
83547: LD_INT 1
83549: NEG
83550: PUSH
83551: EMPTY
83552: LIST
83553: LIST
83554: PUSH
83555: LD_INT 2
83557: PUSH
83558: LD_INT 1
83560: PUSH
83561: EMPTY
83562: LIST
83563: LIST
83564: PUSH
83565: LD_INT 2
83567: NEG
83568: PUSH
83569: LD_INT 1
83571: NEG
83572: PUSH
83573: EMPTY
83574: LIST
83575: LIST
83576: PUSH
83577: EMPTY
83578: LIST
83579: LIST
83580: LIST
83581: LIST
83582: LIST
83583: LIST
83584: LIST
83585: LIST
83586: LIST
83587: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
83588: LD_ADDR_VAR 0 39
83592: PUSH
83593: LD_INT 0
83595: PUSH
83596: LD_INT 0
83598: PUSH
83599: EMPTY
83600: LIST
83601: LIST
83602: PUSH
83603: LD_INT 0
83605: PUSH
83606: LD_INT 1
83608: NEG
83609: PUSH
83610: EMPTY
83611: LIST
83612: LIST
83613: PUSH
83614: LD_INT 1
83616: PUSH
83617: LD_INT 0
83619: PUSH
83620: EMPTY
83621: LIST
83622: LIST
83623: PUSH
83624: LD_INT 1
83626: PUSH
83627: LD_INT 1
83629: PUSH
83630: EMPTY
83631: LIST
83632: LIST
83633: PUSH
83634: LD_INT 0
83636: PUSH
83637: LD_INT 1
83639: PUSH
83640: EMPTY
83641: LIST
83642: LIST
83643: PUSH
83644: LD_INT 1
83646: NEG
83647: PUSH
83648: LD_INT 0
83650: PUSH
83651: EMPTY
83652: LIST
83653: LIST
83654: PUSH
83655: LD_INT 1
83657: NEG
83658: PUSH
83659: LD_INT 1
83661: NEG
83662: PUSH
83663: EMPTY
83664: LIST
83665: LIST
83666: PUSH
83667: LD_INT 1
83669: NEG
83670: PUSH
83671: LD_INT 2
83673: NEG
83674: PUSH
83675: EMPTY
83676: LIST
83677: LIST
83678: PUSH
83679: LD_INT 1
83681: PUSH
83682: LD_INT 2
83684: PUSH
83685: EMPTY
83686: LIST
83687: LIST
83688: PUSH
83689: EMPTY
83690: LIST
83691: LIST
83692: LIST
83693: LIST
83694: LIST
83695: LIST
83696: LIST
83697: LIST
83698: LIST
83699: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
83700: LD_ADDR_VAR 0 40
83704: PUSH
83705: LD_INT 0
83707: PUSH
83708: LD_INT 0
83710: PUSH
83711: EMPTY
83712: LIST
83713: LIST
83714: PUSH
83715: LD_INT 0
83717: PUSH
83718: LD_INT 1
83720: NEG
83721: PUSH
83722: EMPTY
83723: LIST
83724: LIST
83725: PUSH
83726: LD_INT 1
83728: PUSH
83729: LD_INT 0
83731: PUSH
83732: EMPTY
83733: LIST
83734: LIST
83735: PUSH
83736: LD_INT 1
83738: PUSH
83739: LD_INT 1
83741: PUSH
83742: EMPTY
83743: LIST
83744: LIST
83745: PUSH
83746: LD_INT 0
83748: PUSH
83749: LD_INT 1
83751: PUSH
83752: EMPTY
83753: LIST
83754: LIST
83755: PUSH
83756: LD_INT 1
83758: NEG
83759: PUSH
83760: LD_INT 0
83762: PUSH
83763: EMPTY
83764: LIST
83765: LIST
83766: PUSH
83767: LD_INT 1
83769: NEG
83770: PUSH
83771: LD_INT 1
83773: NEG
83774: PUSH
83775: EMPTY
83776: LIST
83777: LIST
83778: PUSH
83779: LD_INT 1
83781: PUSH
83782: LD_INT 1
83784: NEG
83785: PUSH
83786: EMPTY
83787: LIST
83788: LIST
83789: PUSH
83790: LD_INT 1
83792: NEG
83793: PUSH
83794: LD_INT 1
83796: PUSH
83797: EMPTY
83798: LIST
83799: LIST
83800: PUSH
83801: EMPTY
83802: LIST
83803: LIST
83804: LIST
83805: LIST
83806: LIST
83807: LIST
83808: LIST
83809: LIST
83810: LIST
83811: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
83812: LD_ADDR_VAR 0 41
83816: PUSH
83817: LD_INT 0
83819: PUSH
83820: LD_INT 0
83822: PUSH
83823: EMPTY
83824: LIST
83825: LIST
83826: PUSH
83827: LD_INT 0
83829: PUSH
83830: LD_INT 1
83832: NEG
83833: PUSH
83834: EMPTY
83835: LIST
83836: LIST
83837: PUSH
83838: LD_INT 1
83840: PUSH
83841: LD_INT 0
83843: PUSH
83844: EMPTY
83845: LIST
83846: LIST
83847: PUSH
83848: LD_INT 1
83850: PUSH
83851: LD_INT 1
83853: PUSH
83854: EMPTY
83855: LIST
83856: LIST
83857: PUSH
83858: LD_INT 0
83860: PUSH
83861: LD_INT 1
83863: PUSH
83864: EMPTY
83865: LIST
83866: LIST
83867: PUSH
83868: LD_INT 1
83870: NEG
83871: PUSH
83872: LD_INT 0
83874: PUSH
83875: EMPTY
83876: LIST
83877: LIST
83878: PUSH
83879: LD_INT 1
83881: NEG
83882: PUSH
83883: LD_INT 1
83885: NEG
83886: PUSH
83887: EMPTY
83888: LIST
83889: LIST
83890: PUSH
83891: LD_INT 1
83893: NEG
83894: PUSH
83895: LD_INT 2
83897: NEG
83898: PUSH
83899: EMPTY
83900: LIST
83901: LIST
83902: PUSH
83903: LD_INT 1
83905: PUSH
83906: LD_INT 1
83908: NEG
83909: PUSH
83910: EMPTY
83911: LIST
83912: LIST
83913: PUSH
83914: LD_INT 2
83916: PUSH
83917: LD_INT 0
83919: PUSH
83920: EMPTY
83921: LIST
83922: LIST
83923: PUSH
83924: LD_INT 2
83926: PUSH
83927: LD_INT 1
83929: PUSH
83930: EMPTY
83931: LIST
83932: LIST
83933: PUSH
83934: LD_INT 2
83936: PUSH
83937: LD_INT 2
83939: PUSH
83940: EMPTY
83941: LIST
83942: LIST
83943: PUSH
83944: LD_INT 1
83946: PUSH
83947: LD_INT 2
83949: PUSH
83950: EMPTY
83951: LIST
83952: LIST
83953: PUSH
83954: LD_INT 1
83956: NEG
83957: PUSH
83958: LD_INT 1
83960: PUSH
83961: EMPTY
83962: LIST
83963: LIST
83964: PUSH
83965: LD_INT 2
83967: NEG
83968: PUSH
83969: LD_INT 0
83971: PUSH
83972: EMPTY
83973: LIST
83974: LIST
83975: PUSH
83976: LD_INT 2
83978: NEG
83979: PUSH
83980: LD_INT 1
83982: NEG
83983: PUSH
83984: EMPTY
83985: LIST
83986: LIST
83987: PUSH
83988: LD_INT 2
83990: NEG
83991: PUSH
83992: LD_INT 2
83994: NEG
83995: PUSH
83996: EMPTY
83997: LIST
83998: LIST
83999: PUSH
84000: LD_INT 2
84002: NEG
84003: PUSH
84004: LD_INT 3
84006: NEG
84007: PUSH
84008: EMPTY
84009: LIST
84010: LIST
84011: PUSH
84012: LD_INT 2
84014: PUSH
84015: LD_INT 1
84017: NEG
84018: PUSH
84019: EMPTY
84020: LIST
84021: LIST
84022: PUSH
84023: LD_INT 3
84025: PUSH
84026: LD_INT 0
84028: PUSH
84029: EMPTY
84030: LIST
84031: LIST
84032: PUSH
84033: LD_INT 3
84035: PUSH
84036: LD_INT 1
84038: PUSH
84039: EMPTY
84040: LIST
84041: LIST
84042: PUSH
84043: LD_INT 3
84045: PUSH
84046: LD_INT 2
84048: PUSH
84049: EMPTY
84050: LIST
84051: LIST
84052: PUSH
84053: LD_INT 3
84055: PUSH
84056: LD_INT 3
84058: PUSH
84059: EMPTY
84060: LIST
84061: LIST
84062: PUSH
84063: LD_INT 2
84065: PUSH
84066: LD_INT 3
84068: PUSH
84069: EMPTY
84070: LIST
84071: LIST
84072: PUSH
84073: LD_INT 2
84075: NEG
84076: PUSH
84077: LD_INT 1
84079: PUSH
84080: EMPTY
84081: LIST
84082: LIST
84083: PUSH
84084: LD_INT 3
84086: NEG
84087: PUSH
84088: LD_INT 0
84090: PUSH
84091: EMPTY
84092: LIST
84093: LIST
84094: PUSH
84095: LD_INT 3
84097: NEG
84098: PUSH
84099: LD_INT 1
84101: NEG
84102: PUSH
84103: EMPTY
84104: LIST
84105: LIST
84106: PUSH
84107: LD_INT 3
84109: NEG
84110: PUSH
84111: LD_INT 2
84113: NEG
84114: PUSH
84115: EMPTY
84116: LIST
84117: LIST
84118: PUSH
84119: LD_INT 3
84121: NEG
84122: PUSH
84123: LD_INT 3
84125: NEG
84126: PUSH
84127: EMPTY
84128: LIST
84129: LIST
84130: PUSH
84131: EMPTY
84132: LIST
84133: LIST
84134: LIST
84135: LIST
84136: LIST
84137: LIST
84138: LIST
84139: LIST
84140: LIST
84141: LIST
84142: LIST
84143: LIST
84144: LIST
84145: LIST
84146: LIST
84147: LIST
84148: LIST
84149: LIST
84150: LIST
84151: LIST
84152: LIST
84153: LIST
84154: LIST
84155: LIST
84156: LIST
84157: LIST
84158: LIST
84159: LIST
84160: LIST
84161: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84162: LD_ADDR_VAR 0 42
84166: PUSH
84167: LD_INT 0
84169: PUSH
84170: LD_INT 0
84172: PUSH
84173: EMPTY
84174: LIST
84175: LIST
84176: PUSH
84177: LD_INT 0
84179: PUSH
84180: LD_INT 1
84182: NEG
84183: PUSH
84184: EMPTY
84185: LIST
84186: LIST
84187: PUSH
84188: LD_INT 1
84190: PUSH
84191: LD_INT 0
84193: PUSH
84194: EMPTY
84195: LIST
84196: LIST
84197: PUSH
84198: LD_INT 1
84200: PUSH
84201: LD_INT 1
84203: PUSH
84204: EMPTY
84205: LIST
84206: LIST
84207: PUSH
84208: LD_INT 0
84210: PUSH
84211: LD_INT 1
84213: PUSH
84214: EMPTY
84215: LIST
84216: LIST
84217: PUSH
84218: LD_INT 1
84220: NEG
84221: PUSH
84222: LD_INT 0
84224: PUSH
84225: EMPTY
84226: LIST
84227: LIST
84228: PUSH
84229: LD_INT 1
84231: NEG
84232: PUSH
84233: LD_INT 1
84235: NEG
84236: PUSH
84237: EMPTY
84238: LIST
84239: LIST
84240: PUSH
84241: LD_INT 1
84243: NEG
84244: PUSH
84245: LD_INT 2
84247: NEG
84248: PUSH
84249: EMPTY
84250: LIST
84251: LIST
84252: PUSH
84253: LD_INT 0
84255: PUSH
84256: LD_INT 2
84258: NEG
84259: PUSH
84260: EMPTY
84261: LIST
84262: LIST
84263: PUSH
84264: LD_INT 1
84266: PUSH
84267: LD_INT 1
84269: NEG
84270: PUSH
84271: EMPTY
84272: LIST
84273: LIST
84274: PUSH
84275: LD_INT 2
84277: PUSH
84278: LD_INT 1
84280: PUSH
84281: EMPTY
84282: LIST
84283: LIST
84284: PUSH
84285: LD_INT 2
84287: PUSH
84288: LD_INT 2
84290: PUSH
84291: EMPTY
84292: LIST
84293: LIST
84294: PUSH
84295: LD_INT 1
84297: PUSH
84298: LD_INT 2
84300: PUSH
84301: EMPTY
84302: LIST
84303: LIST
84304: PUSH
84305: LD_INT 0
84307: PUSH
84308: LD_INT 2
84310: PUSH
84311: EMPTY
84312: LIST
84313: LIST
84314: PUSH
84315: LD_INT 1
84317: NEG
84318: PUSH
84319: LD_INT 1
84321: PUSH
84322: EMPTY
84323: LIST
84324: LIST
84325: PUSH
84326: LD_INT 2
84328: NEG
84329: PUSH
84330: LD_INT 1
84332: NEG
84333: PUSH
84334: EMPTY
84335: LIST
84336: LIST
84337: PUSH
84338: LD_INT 2
84340: NEG
84341: PUSH
84342: LD_INT 2
84344: NEG
84345: PUSH
84346: EMPTY
84347: LIST
84348: LIST
84349: PUSH
84350: LD_INT 2
84352: NEG
84353: PUSH
84354: LD_INT 3
84356: NEG
84357: PUSH
84358: EMPTY
84359: LIST
84360: LIST
84361: PUSH
84362: LD_INT 1
84364: NEG
84365: PUSH
84366: LD_INT 3
84368: NEG
84369: PUSH
84370: EMPTY
84371: LIST
84372: LIST
84373: PUSH
84374: LD_INT 0
84376: PUSH
84377: LD_INT 3
84379: NEG
84380: PUSH
84381: EMPTY
84382: LIST
84383: LIST
84384: PUSH
84385: LD_INT 1
84387: PUSH
84388: LD_INT 2
84390: NEG
84391: PUSH
84392: EMPTY
84393: LIST
84394: LIST
84395: PUSH
84396: LD_INT 3
84398: PUSH
84399: LD_INT 2
84401: PUSH
84402: EMPTY
84403: LIST
84404: LIST
84405: PUSH
84406: LD_INT 3
84408: PUSH
84409: LD_INT 3
84411: PUSH
84412: EMPTY
84413: LIST
84414: LIST
84415: PUSH
84416: LD_INT 2
84418: PUSH
84419: LD_INT 3
84421: PUSH
84422: EMPTY
84423: LIST
84424: LIST
84425: PUSH
84426: LD_INT 1
84428: PUSH
84429: LD_INT 3
84431: PUSH
84432: EMPTY
84433: LIST
84434: LIST
84435: PUSH
84436: LD_INT 0
84438: PUSH
84439: LD_INT 3
84441: PUSH
84442: EMPTY
84443: LIST
84444: LIST
84445: PUSH
84446: LD_INT 1
84448: NEG
84449: PUSH
84450: LD_INT 2
84452: PUSH
84453: EMPTY
84454: LIST
84455: LIST
84456: PUSH
84457: LD_INT 3
84459: NEG
84460: PUSH
84461: LD_INT 2
84463: NEG
84464: PUSH
84465: EMPTY
84466: LIST
84467: LIST
84468: PUSH
84469: LD_INT 3
84471: NEG
84472: PUSH
84473: LD_INT 3
84475: NEG
84476: PUSH
84477: EMPTY
84478: LIST
84479: LIST
84480: PUSH
84481: EMPTY
84482: LIST
84483: LIST
84484: LIST
84485: LIST
84486: LIST
84487: LIST
84488: LIST
84489: LIST
84490: LIST
84491: LIST
84492: LIST
84493: LIST
84494: LIST
84495: LIST
84496: LIST
84497: LIST
84498: LIST
84499: LIST
84500: LIST
84501: LIST
84502: LIST
84503: LIST
84504: LIST
84505: LIST
84506: LIST
84507: LIST
84508: LIST
84509: LIST
84510: LIST
84511: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
84512: LD_ADDR_VAR 0 43
84516: PUSH
84517: LD_INT 0
84519: PUSH
84520: LD_INT 0
84522: PUSH
84523: EMPTY
84524: LIST
84525: LIST
84526: PUSH
84527: LD_INT 0
84529: PUSH
84530: LD_INT 1
84532: NEG
84533: PUSH
84534: EMPTY
84535: LIST
84536: LIST
84537: PUSH
84538: LD_INT 1
84540: PUSH
84541: LD_INT 0
84543: PUSH
84544: EMPTY
84545: LIST
84546: LIST
84547: PUSH
84548: LD_INT 1
84550: PUSH
84551: LD_INT 1
84553: PUSH
84554: EMPTY
84555: LIST
84556: LIST
84557: PUSH
84558: LD_INT 0
84560: PUSH
84561: LD_INT 1
84563: PUSH
84564: EMPTY
84565: LIST
84566: LIST
84567: PUSH
84568: LD_INT 1
84570: NEG
84571: PUSH
84572: LD_INT 0
84574: PUSH
84575: EMPTY
84576: LIST
84577: LIST
84578: PUSH
84579: LD_INT 1
84581: NEG
84582: PUSH
84583: LD_INT 1
84585: NEG
84586: PUSH
84587: EMPTY
84588: LIST
84589: LIST
84590: PUSH
84591: LD_INT 1
84593: NEG
84594: PUSH
84595: LD_INT 2
84597: NEG
84598: PUSH
84599: EMPTY
84600: LIST
84601: LIST
84602: PUSH
84603: LD_INT 0
84605: PUSH
84606: LD_INT 2
84608: NEG
84609: PUSH
84610: EMPTY
84611: LIST
84612: LIST
84613: PUSH
84614: LD_INT 1
84616: PUSH
84617: LD_INT 1
84619: NEG
84620: PUSH
84621: EMPTY
84622: LIST
84623: LIST
84624: PUSH
84625: LD_INT 2
84627: PUSH
84628: LD_INT 0
84630: PUSH
84631: EMPTY
84632: LIST
84633: LIST
84634: PUSH
84635: LD_INT 2
84637: PUSH
84638: LD_INT 1
84640: PUSH
84641: EMPTY
84642: LIST
84643: LIST
84644: PUSH
84645: LD_INT 1
84647: PUSH
84648: LD_INT 2
84650: PUSH
84651: EMPTY
84652: LIST
84653: LIST
84654: PUSH
84655: LD_INT 0
84657: PUSH
84658: LD_INT 2
84660: PUSH
84661: EMPTY
84662: LIST
84663: LIST
84664: PUSH
84665: LD_INT 1
84667: NEG
84668: PUSH
84669: LD_INT 1
84671: PUSH
84672: EMPTY
84673: LIST
84674: LIST
84675: PUSH
84676: LD_INT 2
84678: NEG
84679: PUSH
84680: LD_INT 0
84682: PUSH
84683: EMPTY
84684: LIST
84685: LIST
84686: PUSH
84687: LD_INT 2
84689: NEG
84690: PUSH
84691: LD_INT 1
84693: NEG
84694: PUSH
84695: EMPTY
84696: LIST
84697: LIST
84698: PUSH
84699: LD_INT 1
84701: NEG
84702: PUSH
84703: LD_INT 3
84705: NEG
84706: PUSH
84707: EMPTY
84708: LIST
84709: LIST
84710: PUSH
84711: LD_INT 0
84713: PUSH
84714: LD_INT 3
84716: NEG
84717: PUSH
84718: EMPTY
84719: LIST
84720: LIST
84721: PUSH
84722: LD_INT 1
84724: PUSH
84725: LD_INT 2
84727: NEG
84728: PUSH
84729: EMPTY
84730: LIST
84731: LIST
84732: PUSH
84733: LD_INT 2
84735: PUSH
84736: LD_INT 1
84738: NEG
84739: PUSH
84740: EMPTY
84741: LIST
84742: LIST
84743: PUSH
84744: LD_INT 3
84746: PUSH
84747: LD_INT 0
84749: PUSH
84750: EMPTY
84751: LIST
84752: LIST
84753: PUSH
84754: LD_INT 3
84756: PUSH
84757: LD_INT 1
84759: PUSH
84760: EMPTY
84761: LIST
84762: LIST
84763: PUSH
84764: LD_INT 1
84766: PUSH
84767: LD_INT 3
84769: PUSH
84770: EMPTY
84771: LIST
84772: LIST
84773: PUSH
84774: LD_INT 0
84776: PUSH
84777: LD_INT 3
84779: PUSH
84780: EMPTY
84781: LIST
84782: LIST
84783: PUSH
84784: LD_INT 1
84786: NEG
84787: PUSH
84788: LD_INT 2
84790: PUSH
84791: EMPTY
84792: LIST
84793: LIST
84794: PUSH
84795: LD_INT 2
84797: NEG
84798: PUSH
84799: LD_INT 1
84801: PUSH
84802: EMPTY
84803: LIST
84804: LIST
84805: PUSH
84806: LD_INT 3
84808: NEG
84809: PUSH
84810: LD_INT 0
84812: PUSH
84813: EMPTY
84814: LIST
84815: LIST
84816: PUSH
84817: LD_INT 3
84819: NEG
84820: PUSH
84821: LD_INT 1
84823: NEG
84824: PUSH
84825: EMPTY
84826: LIST
84827: LIST
84828: PUSH
84829: EMPTY
84830: LIST
84831: LIST
84832: LIST
84833: LIST
84834: LIST
84835: LIST
84836: LIST
84837: LIST
84838: LIST
84839: LIST
84840: LIST
84841: LIST
84842: LIST
84843: LIST
84844: LIST
84845: LIST
84846: LIST
84847: LIST
84848: LIST
84849: LIST
84850: LIST
84851: LIST
84852: LIST
84853: LIST
84854: LIST
84855: LIST
84856: LIST
84857: LIST
84858: LIST
84859: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84860: LD_ADDR_VAR 0 44
84864: PUSH
84865: LD_INT 0
84867: PUSH
84868: LD_INT 0
84870: PUSH
84871: EMPTY
84872: LIST
84873: LIST
84874: PUSH
84875: LD_INT 0
84877: PUSH
84878: LD_INT 1
84880: NEG
84881: PUSH
84882: EMPTY
84883: LIST
84884: LIST
84885: PUSH
84886: LD_INT 1
84888: PUSH
84889: LD_INT 0
84891: PUSH
84892: EMPTY
84893: LIST
84894: LIST
84895: PUSH
84896: LD_INT 1
84898: PUSH
84899: LD_INT 1
84901: PUSH
84902: EMPTY
84903: LIST
84904: LIST
84905: PUSH
84906: LD_INT 0
84908: PUSH
84909: LD_INT 1
84911: PUSH
84912: EMPTY
84913: LIST
84914: LIST
84915: PUSH
84916: LD_INT 1
84918: NEG
84919: PUSH
84920: LD_INT 0
84922: PUSH
84923: EMPTY
84924: LIST
84925: LIST
84926: PUSH
84927: LD_INT 1
84929: NEG
84930: PUSH
84931: LD_INT 1
84933: NEG
84934: PUSH
84935: EMPTY
84936: LIST
84937: LIST
84938: PUSH
84939: LD_INT 1
84941: NEG
84942: PUSH
84943: LD_INT 2
84945: NEG
84946: PUSH
84947: EMPTY
84948: LIST
84949: LIST
84950: PUSH
84951: LD_INT 1
84953: PUSH
84954: LD_INT 1
84956: NEG
84957: PUSH
84958: EMPTY
84959: LIST
84960: LIST
84961: PUSH
84962: LD_INT 2
84964: PUSH
84965: LD_INT 0
84967: PUSH
84968: EMPTY
84969: LIST
84970: LIST
84971: PUSH
84972: LD_INT 2
84974: PUSH
84975: LD_INT 1
84977: PUSH
84978: EMPTY
84979: LIST
84980: LIST
84981: PUSH
84982: LD_INT 2
84984: PUSH
84985: LD_INT 2
84987: PUSH
84988: EMPTY
84989: LIST
84990: LIST
84991: PUSH
84992: LD_INT 1
84994: PUSH
84995: LD_INT 2
84997: PUSH
84998: EMPTY
84999: LIST
85000: LIST
85001: PUSH
85002: LD_INT 1
85004: NEG
85005: PUSH
85006: LD_INT 1
85008: PUSH
85009: EMPTY
85010: LIST
85011: LIST
85012: PUSH
85013: LD_INT 2
85015: NEG
85016: PUSH
85017: LD_INT 0
85019: PUSH
85020: EMPTY
85021: LIST
85022: LIST
85023: PUSH
85024: LD_INT 2
85026: NEG
85027: PUSH
85028: LD_INT 1
85030: NEG
85031: PUSH
85032: EMPTY
85033: LIST
85034: LIST
85035: PUSH
85036: LD_INT 2
85038: NEG
85039: PUSH
85040: LD_INT 2
85042: NEG
85043: PUSH
85044: EMPTY
85045: LIST
85046: LIST
85047: PUSH
85048: LD_INT 2
85050: NEG
85051: PUSH
85052: LD_INT 3
85054: NEG
85055: PUSH
85056: EMPTY
85057: LIST
85058: LIST
85059: PUSH
85060: LD_INT 2
85062: PUSH
85063: LD_INT 1
85065: NEG
85066: PUSH
85067: EMPTY
85068: LIST
85069: LIST
85070: PUSH
85071: LD_INT 3
85073: PUSH
85074: LD_INT 0
85076: PUSH
85077: EMPTY
85078: LIST
85079: LIST
85080: PUSH
85081: LD_INT 3
85083: PUSH
85084: LD_INT 1
85086: PUSH
85087: EMPTY
85088: LIST
85089: LIST
85090: PUSH
85091: LD_INT 3
85093: PUSH
85094: LD_INT 2
85096: PUSH
85097: EMPTY
85098: LIST
85099: LIST
85100: PUSH
85101: LD_INT 3
85103: PUSH
85104: LD_INT 3
85106: PUSH
85107: EMPTY
85108: LIST
85109: LIST
85110: PUSH
85111: LD_INT 2
85113: PUSH
85114: LD_INT 3
85116: PUSH
85117: EMPTY
85118: LIST
85119: LIST
85120: PUSH
85121: LD_INT 2
85123: NEG
85124: PUSH
85125: LD_INT 1
85127: PUSH
85128: EMPTY
85129: LIST
85130: LIST
85131: PUSH
85132: LD_INT 3
85134: NEG
85135: PUSH
85136: LD_INT 0
85138: PUSH
85139: EMPTY
85140: LIST
85141: LIST
85142: PUSH
85143: LD_INT 3
85145: NEG
85146: PUSH
85147: LD_INT 1
85149: NEG
85150: PUSH
85151: EMPTY
85152: LIST
85153: LIST
85154: PUSH
85155: LD_INT 3
85157: NEG
85158: PUSH
85159: LD_INT 2
85161: NEG
85162: PUSH
85163: EMPTY
85164: LIST
85165: LIST
85166: PUSH
85167: LD_INT 3
85169: NEG
85170: PUSH
85171: LD_INT 3
85173: NEG
85174: PUSH
85175: EMPTY
85176: LIST
85177: LIST
85178: PUSH
85179: EMPTY
85180: LIST
85181: LIST
85182: LIST
85183: LIST
85184: LIST
85185: LIST
85186: LIST
85187: LIST
85188: LIST
85189: LIST
85190: LIST
85191: LIST
85192: LIST
85193: LIST
85194: LIST
85195: LIST
85196: LIST
85197: LIST
85198: LIST
85199: LIST
85200: LIST
85201: LIST
85202: LIST
85203: LIST
85204: LIST
85205: LIST
85206: LIST
85207: LIST
85208: LIST
85209: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85210: LD_ADDR_VAR 0 45
85214: PUSH
85215: LD_INT 0
85217: PUSH
85218: LD_INT 0
85220: PUSH
85221: EMPTY
85222: LIST
85223: LIST
85224: PUSH
85225: LD_INT 0
85227: PUSH
85228: LD_INT 1
85230: NEG
85231: PUSH
85232: EMPTY
85233: LIST
85234: LIST
85235: PUSH
85236: LD_INT 1
85238: PUSH
85239: LD_INT 0
85241: PUSH
85242: EMPTY
85243: LIST
85244: LIST
85245: PUSH
85246: LD_INT 1
85248: PUSH
85249: LD_INT 1
85251: PUSH
85252: EMPTY
85253: LIST
85254: LIST
85255: PUSH
85256: LD_INT 0
85258: PUSH
85259: LD_INT 1
85261: PUSH
85262: EMPTY
85263: LIST
85264: LIST
85265: PUSH
85266: LD_INT 1
85268: NEG
85269: PUSH
85270: LD_INT 0
85272: PUSH
85273: EMPTY
85274: LIST
85275: LIST
85276: PUSH
85277: LD_INT 1
85279: NEG
85280: PUSH
85281: LD_INT 1
85283: NEG
85284: PUSH
85285: EMPTY
85286: LIST
85287: LIST
85288: PUSH
85289: LD_INT 1
85291: NEG
85292: PUSH
85293: LD_INT 2
85295: NEG
85296: PUSH
85297: EMPTY
85298: LIST
85299: LIST
85300: PUSH
85301: LD_INT 0
85303: PUSH
85304: LD_INT 2
85306: NEG
85307: PUSH
85308: EMPTY
85309: LIST
85310: LIST
85311: PUSH
85312: LD_INT 1
85314: PUSH
85315: LD_INT 1
85317: NEG
85318: PUSH
85319: EMPTY
85320: LIST
85321: LIST
85322: PUSH
85323: LD_INT 2
85325: PUSH
85326: LD_INT 1
85328: PUSH
85329: EMPTY
85330: LIST
85331: LIST
85332: PUSH
85333: LD_INT 2
85335: PUSH
85336: LD_INT 2
85338: PUSH
85339: EMPTY
85340: LIST
85341: LIST
85342: PUSH
85343: LD_INT 1
85345: PUSH
85346: LD_INT 2
85348: PUSH
85349: EMPTY
85350: LIST
85351: LIST
85352: PUSH
85353: LD_INT 0
85355: PUSH
85356: LD_INT 2
85358: PUSH
85359: EMPTY
85360: LIST
85361: LIST
85362: PUSH
85363: LD_INT 1
85365: NEG
85366: PUSH
85367: LD_INT 1
85369: PUSH
85370: EMPTY
85371: LIST
85372: LIST
85373: PUSH
85374: LD_INT 2
85376: NEG
85377: PUSH
85378: LD_INT 1
85380: NEG
85381: PUSH
85382: EMPTY
85383: LIST
85384: LIST
85385: PUSH
85386: LD_INT 2
85388: NEG
85389: PUSH
85390: LD_INT 2
85392: NEG
85393: PUSH
85394: EMPTY
85395: LIST
85396: LIST
85397: PUSH
85398: LD_INT 2
85400: NEG
85401: PUSH
85402: LD_INT 3
85404: NEG
85405: PUSH
85406: EMPTY
85407: LIST
85408: LIST
85409: PUSH
85410: LD_INT 1
85412: NEG
85413: PUSH
85414: LD_INT 3
85416: NEG
85417: PUSH
85418: EMPTY
85419: LIST
85420: LIST
85421: PUSH
85422: LD_INT 0
85424: PUSH
85425: LD_INT 3
85427: NEG
85428: PUSH
85429: EMPTY
85430: LIST
85431: LIST
85432: PUSH
85433: LD_INT 1
85435: PUSH
85436: LD_INT 2
85438: NEG
85439: PUSH
85440: EMPTY
85441: LIST
85442: LIST
85443: PUSH
85444: LD_INT 3
85446: PUSH
85447: LD_INT 2
85449: PUSH
85450: EMPTY
85451: LIST
85452: LIST
85453: PUSH
85454: LD_INT 3
85456: PUSH
85457: LD_INT 3
85459: PUSH
85460: EMPTY
85461: LIST
85462: LIST
85463: PUSH
85464: LD_INT 2
85466: PUSH
85467: LD_INT 3
85469: PUSH
85470: EMPTY
85471: LIST
85472: LIST
85473: PUSH
85474: LD_INT 1
85476: PUSH
85477: LD_INT 3
85479: PUSH
85480: EMPTY
85481: LIST
85482: LIST
85483: PUSH
85484: LD_INT 0
85486: PUSH
85487: LD_INT 3
85489: PUSH
85490: EMPTY
85491: LIST
85492: LIST
85493: PUSH
85494: LD_INT 1
85496: NEG
85497: PUSH
85498: LD_INT 2
85500: PUSH
85501: EMPTY
85502: LIST
85503: LIST
85504: PUSH
85505: LD_INT 3
85507: NEG
85508: PUSH
85509: LD_INT 2
85511: NEG
85512: PUSH
85513: EMPTY
85514: LIST
85515: LIST
85516: PUSH
85517: LD_INT 3
85519: NEG
85520: PUSH
85521: LD_INT 3
85523: NEG
85524: PUSH
85525: EMPTY
85526: LIST
85527: LIST
85528: PUSH
85529: EMPTY
85530: LIST
85531: LIST
85532: LIST
85533: LIST
85534: LIST
85535: LIST
85536: LIST
85537: LIST
85538: LIST
85539: LIST
85540: LIST
85541: LIST
85542: LIST
85543: LIST
85544: LIST
85545: LIST
85546: LIST
85547: LIST
85548: LIST
85549: LIST
85550: LIST
85551: LIST
85552: LIST
85553: LIST
85554: LIST
85555: LIST
85556: LIST
85557: LIST
85558: LIST
85559: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85560: LD_ADDR_VAR 0 46
85564: PUSH
85565: LD_INT 0
85567: PUSH
85568: LD_INT 0
85570: PUSH
85571: EMPTY
85572: LIST
85573: LIST
85574: PUSH
85575: LD_INT 0
85577: PUSH
85578: LD_INT 1
85580: NEG
85581: PUSH
85582: EMPTY
85583: LIST
85584: LIST
85585: PUSH
85586: LD_INT 1
85588: PUSH
85589: LD_INT 0
85591: PUSH
85592: EMPTY
85593: LIST
85594: LIST
85595: PUSH
85596: LD_INT 1
85598: PUSH
85599: LD_INT 1
85601: PUSH
85602: EMPTY
85603: LIST
85604: LIST
85605: PUSH
85606: LD_INT 0
85608: PUSH
85609: LD_INT 1
85611: PUSH
85612: EMPTY
85613: LIST
85614: LIST
85615: PUSH
85616: LD_INT 1
85618: NEG
85619: PUSH
85620: LD_INT 0
85622: PUSH
85623: EMPTY
85624: LIST
85625: LIST
85626: PUSH
85627: LD_INT 1
85629: NEG
85630: PUSH
85631: LD_INT 1
85633: NEG
85634: PUSH
85635: EMPTY
85636: LIST
85637: LIST
85638: PUSH
85639: LD_INT 1
85641: NEG
85642: PUSH
85643: LD_INT 2
85645: NEG
85646: PUSH
85647: EMPTY
85648: LIST
85649: LIST
85650: PUSH
85651: LD_INT 0
85653: PUSH
85654: LD_INT 2
85656: NEG
85657: PUSH
85658: EMPTY
85659: LIST
85660: LIST
85661: PUSH
85662: LD_INT 1
85664: PUSH
85665: LD_INT 1
85667: NEG
85668: PUSH
85669: EMPTY
85670: LIST
85671: LIST
85672: PUSH
85673: LD_INT 2
85675: PUSH
85676: LD_INT 0
85678: PUSH
85679: EMPTY
85680: LIST
85681: LIST
85682: PUSH
85683: LD_INT 2
85685: PUSH
85686: LD_INT 1
85688: PUSH
85689: EMPTY
85690: LIST
85691: LIST
85692: PUSH
85693: LD_INT 1
85695: PUSH
85696: LD_INT 2
85698: PUSH
85699: EMPTY
85700: LIST
85701: LIST
85702: PUSH
85703: LD_INT 0
85705: PUSH
85706: LD_INT 2
85708: PUSH
85709: EMPTY
85710: LIST
85711: LIST
85712: PUSH
85713: LD_INT 1
85715: NEG
85716: PUSH
85717: LD_INT 1
85719: PUSH
85720: EMPTY
85721: LIST
85722: LIST
85723: PUSH
85724: LD_INT 2
85726: NEG
85727: PUSH
85728: LD_INT 0
85730: PUSH
85731: EMPTY
85732: LIST
85733: LIST
85734: PUSH
85735: LD_INT 2
85737: NEG
85738: PUSH
85739: LD_INT 1
85741: NEG
85742: PUSH
85743: EMPTY
85744: LIST
85745: LIST
85746: PUSH
85747: LD_INT 1
85749: NEG
85750: PUSH
85751: LD_INT 3
85753: NEG
85754: PUSH
85755: EMPTY
85756: LIST
85757: LIST
85758: PUSH
85759: LD_INT 0
85761: PUSH
85762: LD_INT 3
85764: NEG
85765: PUSH
85766: EMPTY
85767: LIST
85768: LIST
85769: PUSH
85770: LD_INT 1
85772: PUSH
85773: LD_INT 2
85775: NEG
85776: PUSH
85777: EMPTY
85778: LIST
85779: LIST
85780: PUSH
85781: LD_INT 2
85783: PUSH
85784: LD_INT 1
85786: NEG
85787: PUSH
85788: EMPTY
85789: LIST
85790: LIST
85791: PUSH
85792: LD_INT 3
85794: PUSH
85795: LD_INT 0
85797: PUSH
85798: EMPTY
85799: LIST
85800: LIST
85801: PUSH
85802: LD_INT 3
85804: PUSH
85805: LD_INT 1
85807: PUSH
85808: EMPTY
85809: LIST
85810: LIST
85811: PUSH
85812: LD_INT 1
85814: PUSH
85815: LD_INT 3
85817: PUSH
85818: EMPTY
85819: LIST
85820: LIST
85821: PUSH
85822: LD_INT 0
85824: PUSH
85825: LD_INT 3
85827: PUSH
85828: EMPTY
85829: LIST
85830: LIST
85831: PUSH
85832: LD_INT 1
85834: NEG
85835: PUSH
85836: LD_INT 2
85838: PUSH
85839: EMPTY
85840: LIST
85841: LIST
85842: PUSH
85843: LD_INT 2
85845: NEG
85846: PUSH
85847: LD_INT 1
85849: PUSH
85850: EMPTY
85851: LIST
85852: LIST
85853: PUSH
85854: LD_INT 3
85856: NEG
85857: PUSH
85858: LD_INT 0
85860: PUSH
85861: EMPTY
85862: LIST
85863: LIST
85864: PUSH
85865: LD_INT 3
85867: NEG
85868: PUSH
85869: LD_INT 1
85871: NEG
85872: PUSH
85873: EMPTY
85874: LIST
85875: LIST
85876: PUSH
85877: EMPTY
85878: LIST
85879: LIST
85880: LIST
85881: LIST
85882: LIST
85883: LIST
85884: LIST
85885: LIST
85886: LIST
85887: LIST
85888: LIST
85889: LIST
85890: LIST
85891: LIST
85892: LIST
85893: LIST
85894: LIST
85895: LIST
85896: LIST
85897: LIST
85898: LIST
85899: LIST
85900: LIST
85901: LIST
85902: LIST
85903: LIST
85904: LIST
85905: LIST
85906: LIST
85907: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85908: LD_ADDR_VAR 0 47
85912: PUSH
85913: LD_INT 0
85915: PUSH
85916: LD_INT 0
85918: PUSH
85919: EMPTY
85920: LIST
85921: LIST
85922: PUSH
85923: LD_INT 0
85925: PUSH
85926: LD_INT 1
85928: NEG
85929: PUSH
85930: EMPTY
85931: LIST
85932: LIST
85933: PUSH
85934: LD_INT 1
85936: PUSH
85937: LD_INT 0
85939: PUSH
85940: EMPTY
85941: LIST
85942: LIST
85943: PUSH
85944: LD_INT 1
85946: PUSH
85947: LD_INT 1
85949: PUSH
85950: EMPTY
85951: LIST
85952: LIST
85953: PUSH
85954: LD_INT 0
85956: PUSH
85957: LD_INT 1
85959: PUSH
85960: EMPTY
85961: LIST
85962: LIST
85963: PUSH
85964: LD_INT 1
85966: NEG
85967: PUSH
85968: LD_INT 0
85970: PUSH
85971: EMPTY
85972: LIST
85973: LIST
85974: PUSH
85975: LD_INT 1
85977: NEG
85978: PUSH
85979: LD_INT 1
85981: NEG
85982: PUSH
85983: EMPTY
85984: LIST
85985: LIST
85986: PUSH
85987: LD_INT 1
85989: NEG
85990: PUSH
85991: LD_INT 2
85993: NEG
85994: PUSH
85995: EMPTY
85996: LIST
85997: LIST
85998: PUSH
85999: LD_INT 0
86001: PUSH
86002: LD_INT 2
86004: NEG
86005: PUSH
86006: EMPTY
86007: LIST
86008: LIST
86009: PUSH
86010: LD_INT 1
86012: PUSH
86013: LD_INT 1
86015: NEG
86016: PUSH
86017: EMPTY
86018: LIST
86019: LIST
86020: PUSH
86021: LD_INT 2
86023: NEG
86024: PUSH
86025: LD_INT 1
86027: NEG
86028: PUSH
86029: EMPTY
86030: LIST
86031: LIST
86032: PUSH
86033: LD_INT 2
86035: NEG
86036: PUSH
86037: LD_INT 2
86039: NEG
86040: PUSH
86041: EMPTY
86042: LIST
86043: LIST
86044: PUSH
86045: EMPTY
86046: LIST
86047: LIST
86048: LIST
86049: LIST
86050: LIST
86051: LIST
86052: LIST
86053: LIST
86054: LIST
86055: LIST
86056: LIST
86057: LIST
86058: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
86059: LD_ADDR_VAR 0 48
86063: PUSH
86064: LD_INT 0
86066: PUSH
86067: LD_INT 0
86069: PUSH
86070: EMPTY
86071: LIST
86072: LIST
86073: PUSH
86074: LD_INT 0
86076: PUSH
86077: LD_INT 1
86079: NEG
86080: PUSH
86081: EMPTY
86082: LIST
86083: LIST
86084: PUSH
86085: LD_INT 1
86087: PUSH
86088: LD_INT 0
86090: PUSH
86091: EMPTY
86092: LIST
86093: LIST
86094: PUSH
86095: LD_INT 1
86097: PUSH
86098: LD_INT 1
86100: PUSH
86101: EMPTY
86102: LIST
86103: LIST
86104: PUSH
86105: LD_INT 0
86107: PUSH
86108: LD_INT 1
86110: PUSH
86111: EMPTY
86112: LIST
86113: LIST
86114: PUSH
86115: LD_INT 1
86117: NEG
86118: PUSH
86119: LD_INT 0
86121: PUSH
86122: EMPTY
86123: LIST
86124: LIST
86125: PUSH
86126: LD_INT 1
86128: NEG
86129: PUSH
86130: LD_INT 1
86132: NEG
86133: PUSH
86134: EMPTY
86135: LIST
86136: LIST
86137: PUSH
86138: LD_INT 1
86140: NEG
86141: PUSH
86142: LD_INT 2
86144: NEG
86145: PUSH
86146: EMPTY
86147: LIST
86148: LIST
86149: PUSH
86150: LD_INT 0
86152: PUSH
86153: LD_INT 2
86155: NEG
86156: PUSH
86157: EMPTY
86158: LIST
86159: LIST
86160: PUSH
86161: LD_INT 1
86163: PUSH
86164: LD_INT 1
86166: NEG
86167: PUSH
86168: EMPTY
86169: LIST
86170: LIST
86171: PUSH
86172: LD_INT 2
86174: PUSH
86175: LD_INT 0
86177: PUSH
86178: EMPTY
86179: LIST
86180: LIST
86181: PUSH
86182: LD_INT 2
86184: PUSH
86185: LD_INT 1
86187: PUSH
86188: EMPTY
86189: LIST
86190: LIST
86191: PUSH
86192: EMPTY
86193: LIST
86194: LIST
86195: LIST
86196: LIST
86197: LIST
86198: LIST
86199: LIST
86200: LIST
86201: LIST
86202: LIST
86203: LIST
86204: LIST
86205: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
86206: LD_ADDR_VAR 0 49
86210: PUSH
86211: LD_INT 0
86213: PUSH
86214: LD_INT 0
86216: PUSH
86217: EMPTY
86218: LIST
86219: LIST
86220: PUSH
86221: LD_INT 0
86223: PUSH
86224: LD_INT 1
86226: NEG
86227: PUSH
86228: EMPTY
86229: LIST
86230: LIST
86231: PUSH
86232: LD_INT 1
86234: PUSH
86235: LD_INT 0
86237: PUSH
86238: EMPTY
86239: LIST
86240: LIST
86241: PUSH
86242: LD_INT 1
86244: PUSH
86245: LD_INT 1
86247: PUSH
86248: EMPTY
86249: LIST
86250: LIST
86251: PUSH
86252: LD_INT 0
86254: PUSH
86255: LD_INT 1
86257: PUSH
86258: EMPTY
86259: LIST
86260: LIST
86261: PUSH
86262: LD_INT 1
86264: NEG
86265: PUSH
86266: LD_INT 0
86268: PUSH
86269: EMPTY
86270: LIST
86271: LIST
86272: PUSH
86273: LD_INT 1
86275: NEG
86276: PUSH
86277: LD_INT 1
86279: NEG
86280: PUSH
86281: EMPTY
86282: LIST
86283: LIST
86284: PUSH
86285: LD_INT 1
86287: PUSH
86288: LD_INT 1
86290: NEG
86291: PUSH
86292: EMPTY
86293: LIST
86294: LIST
86295: PUSH
86296: LD_INT 2
86298: PUSH
86299: LD_INT 0
86301: PUSH
86302: EMPTY
86303: LIST
86304: LIST
86305: PUSH
86306: LD_INT 2
86308: PUSH
86309: LD_INT 1
86311: PUSH
86312: EMPTY
86313: LIST
86314: LIST
86315: PUSH
86316: LD_INT 2
86318: PUSH
86319: LD_INT 2
86321: PUSH
86322: EMPTY
86323: LIST
86324: LIST
86325: PUSH
86326: LD_INT 1
86328: PUSH
86329: LD_INT 2
86331: PUSH
86332: EMPTY
86333: LIST
86334: LIST
86335: PUSH
86336: EMPTY
86337: LIST
86338: LIST
86339: LIST
86340: LIST
86341: LIST
86342: LIST
86343: LIST
86344: LIST
86345: LIST
86346: LIST
86347: LIST
86348: LIST
86349: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
86350: LD_ADDR_VAR 0 50
86354: PUSH
86355: LD_INT 0
86357: PUSH
86358: LD_INT 0
86360: PUSH
86361: EMPTY
86362: LIST
86363: LIST
86364: PUSH
86365: LD_INT 0
86367: PUSH
86368: LD_INT 1
86370: NEG
86371: PUSH
86372: EMPTY
86373: LIST
86374: LIST
86375: PUSH
86376: LD_INT 1
86378: PUSH
86379: LD_INT 0
86381: PUSH
86382: EMPTY
86383: LIST
86384: LIST
86385: PUSH
86386: LD_INT 1
86388: PUSH
86389: LD_INT 1
86391: PUSH
86392: EMPTY
86393: LIST
86394: LIST
86395: PUSH
86396: LD_INT 0
86398: PUSH
86399: LD_INT 1
86401: PUSH
86402: EMPTY
86403: LIST
86404: LIST
86405: PUSH
86406: LD_INT 1
86408: NEG
86409: PUSH
86410: LD_INT 0
86412: PUSH
86413: EMPTY
86414: LIST
86415: LIST
86416: PUSH
86417: LD_INT 1
86419: NEG
86420: PUSH
86421: LD_INT 1
86423: NEG
86424: PUSH
86425: EMPTY
86426: LIST
86427: LIST
86428: PUSH
86429: LD_INT 2
86431: PUSH
86432: LD_INT 1
86434: PUSH
86435: EMPTY
86436: LIST
86437: LIST
86438: PUSH
86439: LD_INT 2
86441: PUSH
86442: LD_INT 2
86444: PUSH
86445: EMPTY
86446: LIST
86447: LIST
86448: PUSH
86449: LD_INT 1
86451: PUSH
86452: LD_INT 2
86454: PUSH
86455: EMPTY
86456: LIST
86457: LIST
86458: PUSH
86459: LD_INT 0
86461: PUSH
86462: LD_INT 2
86464: PUSH
86465: EMPTY
86466: LIST
86467: LIST
86468: PUSH
86469: LD_INT 1
86471: NEG
86472: PUSH
86473: LD_INT 1
86475: PUSH
86476: EMPTY
86477: LIST
86478: LIST
86479: PUSH
86480: EMPTY
86481: LIST
86482: LIST
86483: LIST
86484: LIST
86485: LIST
86486: LIST
86487: LIST
86488: LIST
86489: LIST
86490: LIST
86491: LIST
86492: LIST
86493: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
86494: LD_ADDR_VAR 0 51
86498: PUSH
86499: LD_INT 0
86501: PUSH
86502: LD_INT 0
86504: PUSH
86505: EMPTY
86506: LIST
86507: LIST
86508: PUSH
86509: LD_INT 0
86511: PUSH
86512: LD_INT 1
86514: NEG
86515: PUSH
86516: EMPTY
86517: LIST
86518: LIST
86519: PUSH
86520: LD_INT 1
86522: PUSH
86523: LD_INT 0
86525: PUSH
86526: EMPTY
86527: LIST
86528: LIST
86529: PUSH
86530: LD_INT 1
86532: PUSH
86533: LD_INT 1
86535: PUSH
86536: EMPTY
86537: LIST
86538: LIST
86539: PUSH
86540: LD_INT 0
86542: PUSH
86543: LD_INT 1
86545: PUSH
86546: EMPTY
86547: LIST
86548: LIST
86549: PUSH
86550: LD_INT 1
86552: NEG
86553: PUSH
86554: LD_INT 0
86556: PUSH
86557: EMPTY
86558: LIST
86559: LIST
86560: PUSH
86561: LD_INT 1
86563: NEG
86564: PUSH
86565: LD_INT 1
86567: NEG
86568: PUSH
86569: EMPTY
86570: LIST
86571: LIST
86572: PUSH
86573: LD_INT 1
86575: PUSH
86576: LD_INT 2
86578: PUSH
86579: EMPTY
86580: LIST
86581: LIST
86582: PUSH
86583: LD_INT 0
86585: PUSH
86586: LD_INT 2
86588: PUSH
86589: EMPTY
86590: LIST
86591: LIST
86592: PUSH
86593: LD_INT 1
86595: NEG
86596: PUSH
86597: LD_INT 1
86599: PUSH
86600: EMPTY
86601: LIST
86602: LIST
86603: PUSH
86604: LD_INT 2
86606: NEG
86607: PUSH
86608: LD_INT 0
86610: PUSH
86611: EMPTY
86612: LIST
86613: LIST
86614: PUSH
86615: LD_INT 2
86617: NEG
86618: PUSH
86619: LD_INT 1
86621: NEG
86622: PUSH
86623: EMPTY
86624: LIST
86625: LIST
86626: PUSH
86627: EMPTY
86628: LIST
86629: LIST
86630: LIST
86631: LIST
86632: LIST
86633: LIST
86634: LIST
86635: LIST
86636: LIST
86637: LIST
86638: LIST
86639: LIST
86640: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86641: LD_ADDR_VAR 0 52
86645: PUSH
86646: LD_INT 0
86648: PUSH
86649: LD_INT 0
86651: PUSH
86652: EMPTY
86653: LIST
86654: LIST
86655: PUSH
86656: LD_INT 0
86658: PUSH
86659: LD_INT 1
86661: NEG
86662: PUSH
86663: EMPTY
86664: LIST
86665: LIST
86666: PUSH
86667: LD_INT 1
86669: PUSH
86670: LD_INT 0
86672: PUSH
86673: EMPTY
86674: LIST
86675: LIST
86676: PUSH
86677: LD_INT 1
86679: PUSH
86680: LD_INT 1
86682: PUSH
86683: EMPTY
86684: LIST
86685: LIST
86686: PUSH
86687: LD_INT 0
86689: PUSH
86690: LD_INT 1
86692: PUSH
86693: EMPTY
86694: LIST
86695: LIST
86696: PUSH
86697: LD_INT 1
86699: NEG
86700: PUSH
86701: LD_INT 0
86703: PUSH
86704: EMPTY
86705: LIST
86706: LIST
86707: PUSH
86708: LD_INT 1
86710: NEG
86711: PUSH
86712: LD_INT 1
86714: NEG
86715: PUSH
86716: EMPTY
86717: LIST
86718: LIST
86719: PUSH
86720: LD_INT 1
86722: NEG
86723: PUSH
86724: LD_INT 2
86726: NEG
86727: PUSH
86728: EMPTY
86729: LIST
86730: LIST
86731: PUSH
86732: LD_INT 1
86734: NEG
86735: PUSH
86736: LD_INT 1
86738: PUSH
86739: EMPTY
86740: LIST
86741: LIST
86742: PUSH
86743: LD_INT 2
86745: NEG
86746: PUSH
86747: LD_INT 0
86749: PUSH
86750: EMPTY
86751: LIST
86752: LIST
86753: PUSH
86754: LD_INT 2
86756: NEG
86757: PUSH
86758: LD_INT 1
86760: NEG
86761: PUSH
86762: EMPTY
86763: LIST
86764: LIST
86765: PUSH
86766: LD_INT 2
86768: NEG
86769: PUSH
86770: LD_INT 2
86772: NEG
86773: PUSH
86774: EMPTY
86775: LIST
86776: LIST
86777: PUSH
86778: EMPTY
86779: LIST
86780: LIST
86781: LIST
86782: LIST
86783: LIST
86784: LIST
86785: LIST
86786: LIST
86787: LIST
86788: LIST
86789: LIST
86790: LIST
86791: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86792: LD_ADDR_VAR 0 53
86796: PUSH
86797: LD_INT 0
86799: PUSH
86800: LD_INT 0
86802: PUSH
86803: EMPTY
86804: LIST
86805: LIST
86806: PUSH
86807: LD_INT 0
86809: PUSH
86810: LD_INT 1
86812: NEG
86813: PUSH
86814: EMPTY
86815: LIST
86816: LIST
86817: PUSH
86818: LD_INT 1
86820: PUSH
86821: LD_INT 0
86823: PUSH
86824: EMPTY
86825: LIST
86826: LIST
86827: PUSH
86828: LD_INT 1
86830: PUSH
86831: LD_INT 1
86833: PUSH
86834: EMPTY
86835: LIST
86836: LIST
86837: PUSH
86838: LD_INT 0
86840: PUSH
86841: LD_INT 1
86843: PUSH
86844: EMPTY
86845: LIST
86846: LIST
86847: PUSH
86848: LD_INT 1
86850: NEG
86851: PUSH
86852: LD_INT 0
86854: PUSH
86855: EMPTY
86856: LIST
86857: LIST
86858: PUSH
86859: LD_INT 1
86861: NEG
86862: PUSH
86863: LD_INT 1
86865: NEG
86866: PUSH
86867: EMPTY
86868: LIST
86869: LIST
86870: PUSH
86871: LD_INT 1
86873: NEG
86874: PUSH
86875: LD_INT 2
86877: NEG
86878: PUSH
86879: EMPTY
86880: LIST
86881: LIST
86882: PUSH
86883: LD_INT 0
86885: PUSH
86886: LD_INT 2
86888: NEG
86889: PUSH
86890: EMPTY
86891: LIST
86892: LIST
86893: PUSH
86894: LD_INT 1
86896: PUSH
86897: LD_INT 1
86899: NEG
86900: PUSH
86901: EMPTY
86902: LIST
86903: LIST
86904: PUSH
86905: LD_INT 2
86907: PUSH
86908: LD_INT 0
86910: PUSH
86911: EMPTY
86912: LIST
86913: LIST
86914: PUSH
86915: LD_INT 2
86917: PUSH
86918: LD_INT 1
86920: PUSH
86921: EMPTY
86922: LIST
86923: LIST
86924: PUSH
86925: LD_INT 2
86927: PUSH
86928: LD_INT 2
86930: PUSH
86931: EMPTY
86932: LIST
86933: LIST
86934: PUSH
86935: LD_INT 1
86937: PUSH
86938: LD_INT 2
86940: PUSH
86941: EMPTY
86942: LIST
86943: LIST
86944: PUSH
86945: LD_INT 0
86947: PUSH
86948: LD_INT 2
86950: PUSH
86951: EMPTY
86952: LIST
86953: LIST
86954: PUSH
86955: LD_INT 1
86957: NEG
86958: PUSH
86959: LD_INT 1
86961: PUSH
86962: EMPTY
86963: LIST
86964: LIST
86965: PUSH
86966: LD_INT 2
86968: NEG
86969: PUSH
86970: LD_INT 0
86972: PUSH
86973: EMPTY
86974: LIST
86975: LIST
86976: PUSH
86977: LD_INT 2
86979: NEG
86980: PUSH
86981: LD_INT 1
86983: NEG
86984: PUSH
86985: EMPTY
86986: LIST
86987: LIST
86988: PUSH
86989: LD_INT 2
86991: NEG
86992: PUSH
86993: LD_INT 2
86995: NEG
86996: PUSH
86997: EMPTY
86998: LIST
86999: LIST
87000: PUSH
87001: EMPTY
87002: LIST
87003: LIST
87004: LIST
87005: LIST
87006: LIST
87007: LIST
87008: LIST
87009: LIST
87010: LIST
87011: LIST
87012: LIST
87013: LIST
87014: LIST
87015: LIST
87016: LIST
87017: LIST
87018: LIST
87019: LIST
87020: LIST
87021: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87022: LD_ADDR_VAR 0 54
87026: PUSH
87027: LD_INT 0
87029: PUSH
87030: LD_INT 0
87032: PUSH
87033: EMPTY
87034: LIST
87035: LIST
87036: PUSH
87037: LD_INT 0
87039: PUSH
87040: LD_INT 1
87042: NEG
87043: PUSH
87044: EMPTY
87045: LIST
87046: LIST
87047: PUSH
87048: LD_INT 1
87050: PUSH
87051: LD_INT 0
87053: PUSH
87054: EMPTY
87055: LIST
87056: LIST
87057: PUSH
87058: LD_INT 1
87060: PUSH
87061: LD_INT 1
87063: PUSH
87064: EMPTY
87065: LIST
87066: LIST
87067: PUSH
87068: LD_INT 0
87070: PUSH
87071: LD_INT 1
87073: PUSH
87074: EMPTY
87075: LIST
87076: LIST
87077: PUSH
87078: LD_INT 1
87080: NEG
87081: PUSH
87082: LD_INT 0
87084: PUSH
87085: EMPTY
87086: LIST
87087: LIST
87088: PUSH
87089: LD_INT 1
87091: NEG
87092: PUSH
87093: LD_INT 1
87095: NEG
87096: PUSH
87097: EMPTY
87098: LIST
87099: LIST
87100: PUSH
87101: LD_INT 1
87103: NEG
87104: PUSH
87105: LD_INT 2
87107: NEG
87108: PUSH
87109: EMPTY
87110: LIST
87111: LIST
87112: PUSH
87113: LD_INT 0
87115: PUSH
87116: LD_INT 2
87118: NEG
87119: PUSH
87120: EMPTY
87121: LIST
87122: LIST
87123: PUSH
87124: LD_INT 1
87126: PUSH
87127: LD_INT 1
87129: NEG
87130: PUSH
87131: EMPTY
87132: LIST
87133: LIST
87134: PUSH
87135: LD_INT 2
87137: PUSH
87138: LD_INT 0
87140: PUSH
87141: EMPTY
87142: LIST
87143: LIST
87144: PUSH
87145: LD_INT 2
87147: PUSH
87148: LD_INT 1
87150: PUSH
87151: EMPTY
87152: LIST
87153: LIST
87154: PUSH
87155: LD_INT 2
87157: PUSH
87158: LD_INT 2
87160: PUSH
87161: EMPTY
87162: LIST
87163: LIST
87164: PUSH
87165: LD_INT 1
87167: PUSH
87168: LD_INT 2
87170: PUSH
87171: EMPTY
87172: LIST
87173: LIST
87174: PUSH
87175: LD_INT 0
87177: PUSH
87178: LD_INT 2
87180: PUSH
87181: EMPTY
87182: LIST
87183: LIST
87184: PUSH
87185: LD_INT 1
87187: NEG
87188: PUSH
87189: LD_INT 1
87191: PUSH
87192: EMPTY
87193: LIST
87194: LIST
87195: PUSH
87196: LD_INT 2
87198: NEG
87199: PUSH
87200: LD_INT 0
87202: PUSH
87203: EMPTY
87204: LIST
87205: LIST
87206: PUSH
87207: LD_INT 2
87209: NEG
87210: PUSH
87211: LD_INT 1
87213: NEG
87214: PUSH
87215: EMPTY
87216: LIST
87217: LIST
87218: PUSH
87219: LD_INT 2
87221: NEG
87222: PUSH
87223: LD_INT 2
87225: NEG
87226: PUSH
87227: EMPTY
87228: LIST
87229: LIST
87230: PUSH
87231: EMPTY
87232: LIST
87233: LIST
87234: LIST
87235: LIST
87236: LIST
87237: LIST
87238: LIST
87239: LIST
87240: LIST
87241: LIST
87242: LIST
87243: LIST
87244: LIST
87245: LIST
87246: LIST
87247: LIST
87248: LIST
87249: LIST
87250: LIST
87251: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87252: LD_ADDR_VAR 0 55
87256: PUSH
87257: LD_INT 0
87259: PUSH
87260: LD_INT 0
87262: PUSH
87263: EMPTY
87264: LIST
87265: LIST
87266: PUSH
87267: LD_INT 0
87269: PUSH
87270: LD_INT 1
87272: NEG
87273: PUSH
87274: EMPTY
87275: LIST
87276: LIST
87277: PUSH
87278: LD_INT 1
87280: PUSH
87281: LD_INT 0
87283: PUSH
87284: EMPTY
87285: LIST
87286: LIST
87287: PUSH
87288: LD_INT 1
87290: PUSH
87291: LD_INT 1
87293: PUSH
87294: EMPTY
87295: LIST
87296: LIST
87297: PUSH
87298: LD_INT 0
87300: PUSH
87301: LD_INT 1
87303: PUSH
87304: EMPTY
87305: LIST
87306: LIST
87307: PUSH
87308: LD_INT 1
87310: NEG
87311: PUSH
87312: LD_INT 0
87314: PUSH
87315: EMPTY
87316: LIST
87317: LIST
87318: PUSH
87319: LD_INT 1
87321: NEG
87322: PUSH
87323: LD_INT 1
87325: NEG
87326: PUSH
87327: EMPTY
87328: LIST
87329: LIST
87330: PUSH
87331: LD_INT 1
87333: NEG
87334: PUSH
87335: LD_INT 2
87337: NEG
87338: PUSH
87339: EMPTY
87340: LIST
87341: LIST
87342: PUSH
87343: LD_INT 0
87345: PUSH
87346: LD_INT 2
87348: NEG
87349: PUSH
87350: EMPTY
87351: LIST
87352: LIST
87353: PUSH
87354: LD_INT 1
87356: PUSH
87357: LD_INT 1
87359: NEG
87360: PUSH
87361: EMPTY
87362: LIST
87363: LIST
87364: PUSH
87365: LD_INT 2
87367: PUSH
87368: LD_INT 0
87370: PUSH
87371: EMPTY
87372: LIST
87373: LIST
87374: PUSH
87375: LD_INT 2
87377: PUSH
87378: LD_INT 1
87380: PUSH
87381: EMPTY
87382: LIST
87383: LIST
87384: PUSH
87385: LD_INT 2
87387: PUSH
87388: LD_INT 2
87390: PUSH
87391: EMPTY
87392: LIST
87393: LIST
87394: PUSH
87395: LD_INT 1
87397: PUSH
87398: LD_INT 2
87400: PUSH
87401: EMPTY
87402: LIST
87403: LIST
87404: PUSH
87405: LD_INT 0
87407: PUSH
87408: LD_INT 2
87410: PUSH
87411: EMPTY
87412: LIST
87413: LIST
87414: PUSH
87415: LD_INT 1
87417: NEG
87418: PUSH
87419: LD_INT 1
87421: PUSH
87422: EMPTY
87423: LIST
87424: LIST
87425: PUSH
87426: LD_INT 2
87428: NEG
87429: PUSH
87430: LD_INT 0
87432: PUSH
87433: EMPTY
87434: LIST
87435: LIST
87436: PUSH
87437: LD_INT 2
87439: NEG
87440: PUSH
87441: LD_INT 1
87443: NEG
87444: PUSH
87445: EMPTY
87446: LIST
87447: LIST
87448: PUSH
87449: LD_INT 2
87451: NEG
87452: PUSH
87453: LD_INT 2
87455: NEG
87456: PUSH
87457: EMPTY
87458: LIST
87459: LIST
87460: PUSH
87461: EMPTY
87462: LIST
87463: LIST
87464: LIST
87465: LIST
87466: LIST
87467: LIST
87468: LIST
87469: LIST
87470: LIST
87471: LIST
87472: LIST
87473: LIST
87474: LIST
87475: LIST
87476: LIST
87477: LIST
87478: LIST
87479: LIST
87480: LIST
87481: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87482: LD_ADDR_VAR 0 56
87486: PUSH
87487: LD_INT 0
87489: PUSH
87490: LD_INT 0
87492: PUSH
87493: EMPTY
87494: LIST
87495: LIST
87496: PUSH
87497: LD_INT 0
87499: PUSH
87500: LD_INT 1
87502: NEG
87503: PUSH
87504: EMPTY
87505: LIST
87506: LIST
87507: PUSH
87508: LD_INT 1
87510: PUSH
87511: LD_INT 0
87513: PUSH
87514: EMPTY
87515: LIST
87516: LIST
87517: PUSH
87518: LD_INT 1
87520: PUSH
87521: LD_INT 1
87523: PUSH
87524: EMPTY
87525: LIST
87526: LIST
87527: PUSH
87528: LD_INT 0
87530: PUSH
87531: LD_INT 1
87533: PUSH
87534: EMPTY
87535: LIST
87536: LIST
87537: PUSH
87538: LD_INT 1
87540: NEG
87541: PUSH
87542: LD_INT 0
87544: PUSH
87545: EMPTY
87546: LIST
87547: LIST
87548: PUSH
87549: LD_INT 1
87551: NEG
87552: PUSH
87553: LD_INT 1
87555: NEG
87556: PUSH
87557: EMPTY
87558: LIST
87559: LIST
87560: PUSH
87561: LD_INT 1
87563: NEG
87564: PUSH
87565: LD_INT 2
87567: NEG
87568: PUSH
87569: EMPTY
87570: LIST
87571: LIST
87572: PUSH
87573: LD_INT 0
87575: PUSH
87576: LD_INT 2
87578: NEG
87579: PUSH
87580: EMPTY
87581: LIST
87582: LIST
87583: PUSH
87584: LD_INT 1
87586: PUSH
87587: LD_INT 1
87589: NEG
87590: PUSH
87591: EMPTY
87592: LIST
87593: LIST
87594: PUSH
87595: LD_INT 2
87597: PUSH
87598: LD_INT 0
87600: PUSH
87601: EMPTY
87602: LIST
87603: LIST
87604: PUSH
87605: LD_INT 2
87607: PUSH
87608: LD_INT 1
87610: PUSH
87611: EMPTY
87612: LIST
87613: LIST
87614: PUSH
87615: LD_INT 2
87617: PUSH
87618: LD_INT 2
87620: PUSH
87621: EMPTY
87622: LIST
87623: LIST
87624: PUSH
87625: LD_INT 1
87627: PUSH
87628: LD_INT 2
87630: PUSH
87631: EMPTY
87632: LIST
87633: LIST
87634: PUSH
87635: LD_INT 0
87637: PUSH
87638: LD_INT 2
87640: PUSH
87641: EMPTY
87642: LIST
87643: LIST
87644: PUSH
87645: LD_INT 1
87647: NEG
87648: PUSH
87649: LD_INT 1
87651: PUSH
87652: EMPTY
87653: LIST
87654: LIST
87655: PUSH
87656: LD_INT 2
87658: NEG
87659: PUSH
87660: LD_INT 0
87662: PUSH
87663: EMPTY
87664: LIST
87665: LIST
87666: PUSH
87667: LD_INT 2
87669: NEG
87670: PUSH
87671: LD_INT 1
87673: NEG
87674: PUSH
87675: EMPTY
87676: LIST
87677: LIST
87678: PUSH
87679: LD_INT 2
87681: NEG
87682: PUSH
87683: LD_INT 2
87685: NEG
87686: PUSH
87687: EMPTY
87688: LIST
87689: LIST
87690: PUSH
87691: EMPTY
87692: LIST
87693: LIST
87694: LIST
87695: LIST
87696: LIST
87697: LIST
87698: LIST
87699: LIST
87700: LIST
87701: LIST
87702: LIST
87703: LIST
87704: LIST
87705: LIST
87706: LIST
87707: LIST
87708: LIST
87709: LIST
87710: LIST
87711: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87712: LD_ADDR_VAR 0 57
87716: PUSH
87717: LD_INT 0
87719: PUSH
87720: LD_INT 0
87722: PUSH
87723: EMPTY
87724: LIST
87725: LIST
87726: PUSH
87727: LD_INT 0
87729: PUSH
87730: LD_INT 1
87732: NEG
87733: PUSH
87734: EMPTY
87735: LIST
87736: LIST
87737: PUSH
87738: LD_INT 1
87740: PUSH
87741: LD_INT 0
87743: PUSH
87744: EMPTY
87745: LIST
87746: LIST
87747: PUSH
87748: LD_INT 1
87750: PUSH
87751: LD_INT 1
87753: PUSH
87754: EMPTY
87755: LIST
87756: LIST
87757: PUSH
87758: LD_INT 0
87760: PUSH
87761: LD_INT 1
87763: PUSH
87764: EMPTY
87765: LIST
87766: LIST
87767: PUSH
87768: LD_INT 1
87770: NEG
87771: PUSH
87772: LD_INT 0
87774: PUSH
87775: EMPTY
87776: LIST
87777: LIST
87778: PUSH
87779: LD_INT 1
87781: NEG
87782: PUSH
87783: LD_INT 1
87785: NEG
87786: PUSH
87787: EMPTY
87788: LIST
87789: LIST
87790: PUSH
87791: LD_INT 1
87793: NEG
87794: PUSH
87795: LD_INT 2
87797: NEG
87798: PUSH
87799: EMPTY
87800: LIST
87801: LIST
87802: PUSH
87803: LD_INT 0
87805: PUSH
87806: LD_INT 2
87808: NEG
87809: PUSH
87810: EMPTY
87811: LIST
87812: LIST
87813: PUSH
87814: LD_INT 1
87816: PUSH
87817: LD_INT 1
87819: NEG
87820: PUSH
87821: EMPTY
87822: LIST
87823: LIST
87824: PUSH
87825: LD_INT 2
87827: PUSH
87828: LD_INT 0
87830: PUSH
87831: EMPTY
87832: LIST
87833: LIST
87834: PUSH
87835: LD_INT 2
87837: PUSH
87838: LD_INT 1
87840: PUSH
87841: EMPTY
87842: LIST
87843: LIST
87844: PUSH
87845: LD_INT 2
87847: PUSH
87848: LD_INT 2
87850: PUSH
87851: EMPTY
87852: LIST
87853: LIST
87854: PUSH
87855: LD_INT 1
87857: PUSH
87858: LD_INT 2
87860: PUSH
87861: EMPTY
87862: LIST
87863: LIST
87864: PUSH
87865: LD_INT 0
87867: PUSH
87868: LD_INT 2
87870: PUSH
87871: EMPTY
87872: LIST
87873: LIST
87874: PUSH
87875: LD_INT 1
87877: NEG
87878: PUSH
87879: LD_INT 1
87881: PUSH
87882: EMPTY
87883: LIST
87884: LIST
87885: PUSH
87886: LD_INT 2
87888: NEG
87889: PUSH
87890: LD_INT 0
87892: PUSH
87893: EMPTY
87894: LIST
87895: LIST
87896: PUSH
87897: LD_INT 2
87899: NEG
87900: PUSH
87901: LD_INT 1
87903: NEG
87904: PUSH
87905: EMPTY
87906: LIST
87907: LIST
87908: PUSH
87909: LD_INT 2
87911: NEG
87912: PUSH
87913: LD_INT 2
87915: NEG
87916: PUSH
87917: EMPTY
87918: LIST
87919: LIST
87920: PUSH
87921: EMPTY
87922: LIST
87923: LIST
87924: LIST
87925: LIST
87926: LIST
87927: LIST
87928: LIST
87929: LIST
87930: LIST
87931: LIST
87932: LIST
87933: LIST
87934: LIST
87935: LIST
87936: LIST
87937: LIST
87938: LIST
87939: LIST
87940: LIST
87941: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87942: LD_ADDR_VAR 0 58
87946: PUSH
87947: LD_INT 0
87949: PUSH
87950: LD_INT 0
87952: PUSH
87953: EMPTY
87954: LIST
87955: LIST
87956: PUSH
87957: LD_INT 0
87959: PUSH
87960: LD_INT 1
87962: NEG
87963: PUSH
87964: EMPTY
87965: LIST
87966: LIST
87967: PUSH
87968: LD_INT 1
87970: PUSH
87971: LD_INT 0
87973: PUSH
87974: EMPTY
87975: LIST
87976: LIST
87977: PUSH
87978: LD_INT 1
87980: PUSH
87981: LD_INT 1
87983: PUSH
87984: EMPTY
87985: LIST
87986: LIST
87987: PUSH
87988: LD_INT 0
87990: PUSH
87991: LD_INT 1
87993: PUSH
87994: EMPTY
87995: LIST
87996: LIST
87997: PUSH
87998: LD_INT 1
88000: NEG
88001: PUSH
88002: LD_INT 0
88004: PUSH
88005: EMPTY
88006: LIST
88007: LIST
88008: PUSH
88009: LD_INT 1
88011: NEG
88012: PUSH
88013: LD_INT 1
88015: NEG
88016: PUSH
88017: EMPTY
88018: LIST
88019: LIST
88020: PUSH
88021: LD_INT 1
88023: NEG
88024: PUSH
88025: LD_INT 2
88027: NEG
88028: PUSH
88029: EMPTY
88030: LIST
88031: LIST
88032: PUSH
88033: LD_INT 0
88035: PUSH
88036: LD_INT 2
88038: NEG
88039: PUSH
88040: EMPTY
88041: LIST
88042: LIST
88043: PUSH
88044: LD_INT 1
88046: PUSH
88047: LD_INT 1
88049: NEG
88050: PUSH
88051: EMPTY
88052: LIST
88053: LIST
88054: PUSH
88055: LD_INT 2
88057: PUSH
88058: LD_INT 0
88060: PUSH
88061: EMPTY
88062: LIST
88063: LIST
88064: PUSH
88065: LD_INT 2
88067: PUSH
88068: LD_INT 1
88070: PUSH
88071: EMPTY
88072: LIST
88073: LIST
88074: PUSH
88075: LD_INT 2
88077: PUSH
88078: LD_INT 2
88080: PUSH
88081: EMPTY
88082: LIST
88083: LIST
88084: PUSH
88085: LD_INT 1
88087: PUSH
88088: LD_INT 2
88090: PUSH
88091: EMPTY
88092: LIST
88093: LIST
88094: PUSH
88095: LD_INT 0
88097: PUSH
88098: LD_INT 2
88100: PUSH
88101: EMPTY
88102: LIST
88103: LIST
88104: PUSH
88105: LD_INT 1
88107: NEG
88108: PUSH
88109: LD_INT 1
88111: PUSH
88112: EMPTY
88113: LIST
88114: LIST
88115: PUSH
88116: LD_INT 2
88118: NEG
88119: PUSH
88120: LD_INT 0
88122: PUSH
88123: EMPTY
88124: LIST
88125: LIST
88126: PUSH
88127: LD_INT 2
88129: NEG
88130: PUSH
88131: LD_INT 1
88133: NEG
88134: PUSH
88135: EMPTY
88136: LIST
88137: LIST
88138: PUSH
88139: LD_INT 2
88141: NEG
88142: PUSH
88143: LD_INT 2
88145: NEG
88146: PUSH
88147: EMPTY
88148: LIST
88149: LIST
88150: PUSH
88151: EMPTY
88152: LIST
88153: LIST
88154: LIST
88155: LIST
88156: LIST
88157: LIST
88158: LIST
88159: LIST
88160: LIST
88161: LIST
88162: LIST
88163: LIST
88164: LIST
88165: LIST
88166: LIST
88167: LIST
88168: LIST
88169: LIST
88170: LIST
88171: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88172: LD_ADDR_VAR 0 59
88176: PUSH
88177: LD_INT 0
88179: PUSH
88180: LD_INT 0
88182: PUSH
88183: EMPTY
88184: LIST
88185: LIST
88186: PUSH
88187: LD_INT 0
88189: PUSH
88190: LD_INT 1
88192: NEG
88193: PUSH
88194: EMPTY
88195: LIST
88196: LIST
88197: PUSH
88198: LD_INT 1
88200: PUSH
88201: LD_INT 0
88203: PUSH
88204: EMPTY
88205: LIST
88206: LIST
88207: PUSH
88208: LD_INT 1
88210: PUSH
88211: LD_INT 1
88213: PUSH
88214: EMPTY
88215: LIST
88216: LIST
88217: PUSH
88218: LD_INT 0
88220: PUSH
88221: LD_INT 1
88223: PUSH
88224: EMPTY
88225: LIST
88226: LIST
88227: PUSH
88228: LD_INT 1
88230: NEG
88231: PUSH
88232: LD_INT 0
88234: PUSH
88235: EMPTY
88236: LIST
88237: LIST
88238: PUSH
88239: LD_INT 1
88241: NEG
88242: PUSH
88243: LD_INT 1
88245: NEG
88246: PUSH
88247: EMPTY
88248: LIST
88249: LIST
88250: PUSH
88251: EMPTY
88252: LIST
88253: LIST
88254: LIST
88255: LIST
88256: LIST
88257: LIST
88258: LIST
88259: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88260: LD_ADDR_VAR 0 60
88264: PUSH
88265: LD_INT 0
88267: PUSH
88268: LD_INT 0
88270: PUSH
88271: EMPTY
88272: LIST
88273: LIST
88274: PUSH
88275: LD_INT 0
88277: PUSH
88278: LD_INT 1
88280: NEG
88281: PUSH
88282: EMPTY
88283: LIST
88284: LIST
88285: PUSH
88286: LD_INT 1
88288: PUSH
88289: LD_INT 0
88291: PUSH
88292: EMPTY
88293: LIST
88294: LIST
88295: PUSH
88296: LD_INT 1
88298: PUSH
88299: LD_INT 1
88301: PUSH
88302: EMPTY
88303: LIST
88304: LIST
88305: PUSH
88306: LD_INT 0
88308: PUSH
88309: LD_INT 1
88311: PUSH
88312: EMPTY
88313: LIST
88314: LIST
88315: PUSH
88316: LD_INT 1
88318: NEG
88319: PUSH
88320: LD_INT 0
88322: PUSH
88323: EMPTY
88324: LIST
88325: LIST
88326: PUSH
88327: LD_INT 1
88329: NEG
88330: PUSH
88331: LD_INT 1
88333: NEG
88334: PUSH
88335: EMPTY
88336: LIST
88337: LIST
88338: PUSH
88339: EMPTY
88340: LIST
88341: LIST
88342: LIST
88343: LIST
88344: LIST
88345: LIST
88346: LIST
88347: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88348: LD_ADDR_VAR 0 61
88352: PUSH
88353: LD_INT 0
88355: PUSH
88356: LD_INT 0
88358: PUSH
88359: EMPTY
88360: LIST
88361: LIST
88362: PUSH
88363: LD_INT 0
88365: PUSH
88366: LD_INT 1
88368: NEG
88369: PUSH
88370: EMPTY
88371: LIST
88372: LIST
88373: PUSH
88374: LD_INT 1
88376: PUSH
88377: LD_INT 0
88379: PUSH
88380: EMPTY
88381: LIST
88382: LIST
88383: PUSH
88384: LD_INT 1
88386: PUSH
88387: LD_INT 1
88389: PUSH
88390: EMPTY
88391: LIST
88392: LIST
88393: PUSH
88394: LD_INT 0
88396: PUSH
88397: LD_INT 1
88399: PUSH
88400: EMPTY
88401: LIST
88402: LIST
88403: PUSH
88404: LD_INT 1
88406: NEG
88407: PUSH
88408: LD_INT 0
88410: PUSH
88411: EMPTY
88412: LIST
88413: LIST
88414: PUSH
88415: LD_INT 1
88417: NEG
88418: PUSH
88419: LD_INT 1
88421: NEG
88422: PUSH
88423: EMPTY
88424: LIST
88425: LIST
88426: PUSH
88427: EMPTY
88428: LIST
88429: LIST
88430: LIST
88431: LIST
88432: LIST
88433: LIST
88434: LIST
88435: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88436: LD_ADDR_VAR 0 62
88440: PUSH
88441: LD_INT 0
88443: PUSH
88444: LD_INT 0
88446: PUSH
88447: EMPTY
88448: LIST
88449: LIST
88450: PUSH
88451: LD_INT 0
88453: PUSH
88454: LD_INT 1
88456: NEG
88457: PUSH
88458: EMPTY
88459: LIST
88460: LIST
88461: PUSH
88462: LD_INT 1
88464: PUSH
88465: LD_INT 0
88467: PUSH
88468: EMPTY
88469: LIST
88470: LIST
88471: PUSH
88472: LD_INT 1
88474: PUSH
88475: LD_INT 1
88477: PUSH
88478: EMPTY
88479: LIST
88480: LIST
88481: PUSH
88482: LD_INT 0
88484: PUSH
88485: LD_INT 1
88487: PUSH
88488: EMPTY
88489: LIST
88490: LIST
88491: PUSH
88492: LD_INT 1
88494: NEG
88495: PUSH
88496: LD_INT 0
88498: PUSH
88499: EMPTY
88500: LIST
88501: LIST
88502: PUSH
88503: LD_INT 1
88505: NEG
88506: PUSH
88507: LD_INT 1
88509: NEG
88510: PUSH
88511: EMPTY
88512: LIST
88513: LIST
88514: PUSH
88515: EMPTY
88516: LIST
88517: LIST
88518: LIST
88519: LIST
88520: LIST
88521: LIST
88522: LIST
88523: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88524: LD_ADDR_VAR 0 63
88528: PUSH
88529: LD_INT 0
88531: PUSH
88532: LD_INT 0
88534: PUSH
88535: EMPTY
88536: LIST
88537: LIST
88538: PUSH
88539: LD_INT 0
88541: PUSH
88542: LD_INT 1
88544: NEG
88545: PUSH
88546: EMPTY
88547: LIST
88548: LIST
88549: PUSH
88550: LD_INT 1
88552: PUSH
88553: LD_INT 0
88555: PUSH
88556: EMPTY
88557: LIST
88558: LIST
88559: PUSH
88560: LD_INT 1
88562: PUSH
88563: LD_INT 1
88565: PUSH
88566: EMPTY
88567: LIST
88568: LIST
88569: PUSH
88570: LD_INT 0
88572: PUSH
88573: LD_INT 1
88575: PUSH
88576: EMPTY
88577: LIST
88578: LIST
88579: PUSH
88580: LD_INT 1
88582: NEG
88583: PUSH
88584: LD_INT 0
88586: PUSH
88587: EMPTY
88588: LIST
88589: LIST
88590: PUSH
88591: LD_INT 1
88593: NEG
88594: PUSH
88595: LD_INT 1
88597: NEG
88598: PUSH
88599: EMPTY
88600: LIST
88601: LIST
88602: PUSH
88603: EMPTY
88604: LIST
88605: LIST
88606: LIST
88607: LIST
88608: LIST
88609: LIST
88610: LIST
88611: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88612: LD_ADDR_VAR 0 64
88616: PUSH
88617: LD_INT 0
88619: PUSH
88620: LD_INT 0
88622: PUSH
88623: EMPTY
88624: LIST
88625: LIST
88626: PUSH
88627: LD_INT 0
88629: PUSH
88630: LD_INT 1
88632: NEG
88633: PUSH
88634: EMPTY
88635: LIST
88636: LIST
88637: PUSH
88638: LD_INT 1
88640: PUSH
88641: LD_INT 0
88643: PUSH
88644: EMPTY
88645: LIST
88646: LIST
88647: PUSH
88648: LD_INT 1
88650: PUSH
88651: LD_INT 1
88653: PUSH
88654: EMPTY
88655: LIST
88656: LIST
88657: PUSH
88658: LD_INT 0
88660: PUSH
88661: LD_INT 1
88663: PUSH
88664: EMPTY
88665: LIST
88666: LIST
88667: PUSH
88668: LD_INT 1
88670: NEG
88671: PUSH
88672: LD_INT 0
88674: PUSH
88675: EMPTY
88676: LIST
88677: LIST
88678: PUSH
88679: LD_INT 1
88681: NEG
88682: PUSH
88683: LD_INT 1
88685: NEG
88686: PUSH
88687: EMPTY
88688: LIST
88689: LIST
88690: PUSH
88691: EMPTY
88692: LIST
88693: LIST
88694: LIST
88695: LIST
88696: LIST
88697: LIST
88698: LIST
88699: ST_TO_ADDR
// end ; 1 :
88700: GO 94597
88702: LD_INT 1
88704: DOUBLE
88705: EQUAL
88706: IFTRUE 88710
88708: GO 91333
88710: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
88711: LD_ADDR_VAR 0 11
88715: PUSH
88716: LD_INT 1
88718: NEG
88719: PUSH
88720: LD_INT 3
88722: NEG
88723: PUSH
88724: EMPTY
88725: LIST
88726: LIST
88727: PUSH
88728: LD_INT 0
88730: PUSH
88731: LD_INT 3
88733: NEG
88734: PUSH
88735: EMPTY
88736: LIST
88737: LIST
88738: PUSH
88739: LD_INT 1
88741: PUSH
88742: LD_INT 2
88744: NEG
88745: PUSH
88746: EMPTY
88747: LIST
88748: LIST
88749: PUSH
88750: EMPTY
88751: LIST
88752: LIST
88753: LIST
88754: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
88755: LD_ADDR_VAR 0 12
88759: PUSH
88760: LD_INT 2
88762: PUSH
88763: LD_INT 1
88765: NEG
88766: PUSH
88767: EMPTY
88768: LIST
88769: LIST
88770: PUSH
88771: LD_INT 3
88773: PUSH
88774: LD_INT 0
88776: PUSH
88777: EMPTY
88778: LIST
88779: LIST
88780: PUSH
88781: LD_INT 3
88783: PUSH
88784: LD_INT 1
88786: PUSH
88787: EMPTY
88788: LIST
88789: LIST
88790: PUSH
88791: EMPTY
88792: LIST
88793: LIST
88794: LIST
88795: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
88796: LD_ADDR_VAR 0 13
88800: PUSH
88801: LD_INT 3
88803: PUSH
88804: LD_INT 2
88806: PUSH
88807: EMPTY
88808: LIST
88809: LIST
88810: PUSH
88811: LD_INT 3
88813: PUSH
88814: LD_INT 3
88816: PUSH
88817: EMPTY
88818: LIST
88819: LIST
88820: PUSH
88821: LD_INT 2
88823: PUSH
88824: LD_INT 3
88826: PUSH
88827: EMPTY
88828: LIST
88829: LIST
88830: PUSH
88831: EMPTY
88832: LIST
88833: LIST
88834: LIST
88835: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
88836: LD_ADDR_VAR 0 14
88840: PUSH
88841: LD_INT 1
88843: PUSH
88844: LD_INT 3
88846: PUSH
88847: EMPTY
88848: LIST
88849: LIST
88850: PUSH
88851: LD_INT 0
88853: PUSH
88854: LD_INT 3
88856: PUSH
88857: EMPTY
88858: LIST
88859: LIST
88860: PUSH
88861: LD_INT 1
88863: NEG
88864: PUSH
88865: LD_INT 2
88867: PUSH
88868: EMPTY
88869: LIST
88870: LIST
88871: PUSH
88872: EMPTY
88873: LIST
88874: LIST
88875: LIST
88876: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88877: LD_ADDR_VAR 0 15
88881: PUSH
88882: LD_INT 2
88884: NEG
88885: PUSH
88886: LD_INT 1
88888: PUSH
88889: EMPTY
88890: LIST
88891: LIST
88892: PUSH
88893: LD_INT 3
88895: NEG
88896: PUSH
88897: LD_INT 0
88899: PUSH
88900: EMPTY
88901: LIST
88902: LIST
88903: PUSH
88904: LD_INT 3
88906: NEG
88907: PUSH
88908: LD_INT 1
88910: NEG
88911: PUSH
88912: EMPTY
88913: LIST
88914: LIST
88915: PUSH
88916: EMPTY
88917: LIST
88918: LIST
88919: LIST
88920: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88921: LD_ADDR_VAR 0 16
88925: PUSH
88926: LD_INT 2
88928: NEG
88929: PUSH
88930: LD_INT 3
88932: NEG
88933: PUSH
88934: EMPTY
88935: LIST
88936: LIST
88937: PUSH
88938: LD_INT 3
88940: NEG
88941: PUSH
88942: LD_INT 2
88944: NEG
88945: PUSH
88946: EMPTY
88947: LIST
88948: LIST
88949: PUSH
88950: LD_INT 3
88952: NEG
88953: PUSH
88954: LD_INT 3
88956: NEG
88957: PUSH
88958: EMPTY
88959: LIST
88960: LIST
88961: PUSH
88962: EMPTY
88963: LIST
88964: LIST
88965: LIST
88966: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
88967: LD_ADDR_VAR 0 17
88971: PUSH
88972: LD_INT 1
88974: NEG
88975: PUSH
88976: LD_INT 3
88978: NEG
88979: PUSH
88980: EMPTY
88981: LIST
88982: LIST
88983: PUSH
88984: LD_INT 0
88986: PUSH
88987: LD_INT 3
88989: NEG
88990: PUSH
88991: EMPTY
88992: LIST
88993: LIST
88994: PUSH
88995: LD_INT 1
88997: PUSH
88998: LD_INT 2
89000: NEG
89001: PUSH
89002: EMPTY
89003: LIST
89004: LIST
89005: PUSH
89006: EMPTY
89007: LIST
89008: LIST
89009: LIST
89010: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89011: LD_ADDR_VAR 0 18
89015: PUSH
89016: LD_INT 2
89018: PUSH
89019: LD_INT 1
89021: NEG
89022: PUSH
89023: EMPTY
89024: LIST
89025: LIST
89026: PUSH
89027: LD_INT 3
89029: PUSH
89030: LD_INT 0
89032: PUSH
89033: EMPTY
89034: LIST
89035: LIST
89036: PUSH
89037: LD_INT 3
89039: PUSH
89040: LD_INT 1
89042: PUSH
89043: EMPTY
89044: LIST
89045: LIST
89046: PUSH
89047: EMPTY
89048: LIST
89049: LIST
89050: LIST
89051: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
89052: LD_ADDR_VAR 0 19
89056: PUSH
89057: LD_INT 3
89059: PUSH
89060: LD_INT 2
89062: PUSH
89063: EMPTY
89064: LIST
89065: LIST
89066: PUSH
89067: LD_INT 3
89069: PUSH
89070: LD_INT 3
89072: PUSH
89073: EMPTY
89074: LIST
89075: LIST
89076: PUSH
89077: LD_INT 2
89079: PUSH
89080: LD_INT 3
89082: PUSH
89083: EMPTY
89084: LIST
89085: LIST
89086: PUSH
89087: EMPTY
89088: LIST
89089: LIST
89090: LIST
89091: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
89092: LD_ADDR_VAR 0 20
89096: PUSH
89097: LD_INT 1
89099: PUSH
89100: LD_INT 3
89102: PUSH
89103: EMPTY
89104: LIST
89105: LIST
89106: PUSH
89107: LD_INT 0
89109: PUSH
89110: LD_INT 3
89112: PUSH
89113: EMPTY
89114: LIST
89115: LIST
89116: PUSH
89117: LD_INT 1
89119: NEG
89120: PUSH
89121: LD_INT 2
89123: PUSH
89124: EMPTY
89125: LIST
89126: LIST
89127: PUSH
89128: EMPTY
89129: LIST
89130: LIST
89131: LIST
89132: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89133: LD_ADDR_VAR 0 21
89137: PUSH
89138: LD_INT 2
89140: NEG
89141: PUSH
89142: LD_INT 1
89144: PUSH
89145: EMPTY
89146: LIST
89147: LIST
89148: PUSH
89149: LD_INT 3
89151: NEG
89152: PUSH
89153: LD_INT 0
89155: PUSH
89156: EMPTY
89157: LIST
89158: LIST
89159: PUSH
89160: LD_INT 3
89162: NEG
89163: PUSH
89164: LD_INT 1
89166: NEG
89167: PUSH
89168: EMPTY
89169: LIST
89170: LIST
89171: PUSH
89172: EMPTY
89173: LIST
89174: LIST
89175: LIST
89176: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89177: LD_ADDR_VAR 0 22
89181: PUSH
89182: LD_INT 2
89184: NEG
89185: PUSH
89186: LD_INT 3
89188: NEG
89189: PUSH
89190: EMPTY
89191: LIST
89192: LIST
89193: PUSH
89194: LD_INT 3
89196: NEG
89197: PUSH
89198: LD_INT 2
89200: NEG
89201: PUSH
89202: EMPTY
89203: LIST
89204: LIST
89205: PUSH
89206: LD_INT 3
89208: NEG
89209: PUSH
89210: LD_INT 3
89212: NEG
89213: PUSH
89214: EMPTY
89215: LIST
89216: LIST
89217: PUSH
89218: EMPTY
89219: LIST
89220: LIST
89221: LIST
89222: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
89223: LD_ADDR_VAR 0 23
89227: PUSH
89228: LD_INT 0
89230: PUSH
89231: LD_INT 3
89233: NEG
89234: PUSH
89235: EMPTY
89236: LIST
89237: LIST
89238: PUSH
89239: LD_INT 1
89241: NEG
89242: PUSH
89243: LD_INT 4
89245: NEG
89246: PUSH
89247: EMPTY
89248: LIST
89249: LIST
89250: PUSH
89251: LD_INT 1
89253: PUSH
89254: LD_INT 3
89256: NEG
89257: PUSH
89258: EMPTY
89259: LIST
89260: LIST
89261: PUSH
89262: EMPTY
89263: LIST
89264: LIST
89265: LIST
89266: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
89267: LD_ADDR_VAR 0 24
89271: PUSH
89272: LD_INT 3
89274: PUSH
89275: LD_INT 0
89277: PUSH
89278: EMPTY
89279: LIST
89280: LIST
89281: PUSH
89282: LD_INT 3
89284: PUSH
89285: LD_INT 1
89287: NEG
89288: PUSH
89289: EMPTY
89290: LIST
89291: LIST
89292: PUSH
89293: LD_INT 4
89295: PUSH
89296: LD_INT 1
89298: PUSH
89299: EMPTY
89300: LIST
89301: LIST
89302: PUSH
89303: EMPTY
89304: LIST
89305: LIST
89306: LIST
89307: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
89308: LD_ADDR_VAR 0 25
89312: PUSH
89313: LD_INT 3
89315: PUSH
89316: LD_INT 3
89318: PUSH
89319: EMPTY
89320: LIST
89321: LIST
89322: PUSH
89323: LD_INT 4
89325: PUSH
89326: LD_INT 3
89328: PUSH
89329: EMPTY
89330: LIST
89331: LIST
89332: PUSH
89333: LD_INT 3
89335: PUSH
89336: LD_INT 4
89338: PUSH
89339: EMPTY
89340: LIST
89341: LIST
89342: PUSH
89343: EMPTY
89344: LIST
89345: LIST
89346: LIST
89347: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
89348: LD_ADDR_VAR 0 26
89352: PUSH
89353: LD_INT 0
89355: PUSH
89356: LD_INT 3
89358: PUSH
89359: EMPTY
89360: LIST
89361: LIST
89362: PUSH
89363: LD_INT 1
89365: PUSH
89366: LD_INT 4
89368: PUSH
89369: EMPTY
89370: LIST
89371: LIST
89372: PUSH
89373: LD_INT 1
89375: NEG
89376: PUSH
89377: LD_INT 3
89379: PUSH
89380: EMPTY
89381: LIST
89382: LIST
89383: PUSH
89384: EMPTY
89385: LIST
89386: LIST
89387: LIST
89388: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
89389: LD_ADDR_VAR 0 27
89393: PUSH
89394: LD_INT 3
89396: NEG
89397: PUSH
89398: LD_INT 0
89400: PUSH
89401: EMPTY
89402: LIST
89403: LIST
89404: PUSH
89405: LD_INT 3
89407: NEG
89408: PUSH
89409: LD_INT 1
89411: PUSH
89412: EMPTY
89413: LIST
89414: LIST
89415: PUSH
89416: LD_INT 4
89418: NEG
89419: PUSH
89420: LD_INT 1
89422: NEG
89423: PUSH
89424: EMPTY
89425: LIST
89426: LIST
89427: PUSH
89428: EMPTY
89429: LIST
89430: LIST
89431: LIST
89432: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
89433: LD_ADDR_VAR 0 28
89437: PUSH
89438: LD_INT 3
89440: NEG
89441: PUSH
89442: LD_INT 3
89444: NEG
89445: PUSH
89446: EMPTY
89447: LIST
89448: LIST
89449: PUSH
89450: LD_INT 3
89452: NEG
89453: PUSH
89454: LD_INT 4
89456: NEG
89457: PUSH
89458: EMPTY
89459: LIST
89460: LIST
89461: PUSH
89462: LD_INT 4
89464: NEG
89465: PUSH
89466: LD_INT 3
89468: NEG
89469: PUSH
89470: EMPTY
89471: LIST
89472: LIST
89473: PUSH
89474: EMPTY
89475: LIST
89476: LIST
89477: LIST
89478: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
89479: LD_ADDR_VAR 0 29
89483: PUSH
89484: LD_INT 1
89486: NEG
89487: PUSH
89488: LD_INT 3
89490: NEG
89491: PUSH
89492: EMPTY
89493: LIST
89494: LIST
89495: PUSH
89496: LD_INT 0
89498: PUSH
89499: LD_INT 3
89501: NEG
89502: PUSH
89503: EMPTY
89504: LIST
89505: LIST
89506: PUSH
89507: LD_INT 1
89509: PUSH
89510: LD_INT 2
89512: NEG
89513: PUSH
89514: EMPTY
89515: LIST
89516: LIST
89517: PUSH
89518: LD_INT 1
89520: NEG
89521: PUSH
89522: LD_INT 4
89524: NEG
89525: PUSH
89526: EMPTY
89527: LIST
89528: LIST
89529: PUSH
89530: LD_INT 0
89532: PUSH
89533: LD_INT 4
89535: NEG
89536: PUSH
89537: EMPTY
89538: LIST
89539: LIST
89540: PUSH
89541: LD_INT 1
89543: PUSH
89544: LD_INT 3
89546: NEG
89547: PUSH
89548: EMPTY
89549: LIST
89550: LIST
89551: PUSH
89552: LD_INT 1
89554: NEG
89555: PUSH
89556: LD_INT 5
89558: NEG
89559: PUSH
89560: EMPTY
89561: LIST
89562: LIST
89563: PUSH
89564: LD_INT 0
89566: PUSH
89567: LD_INT 5
89569: NEG
89570: PUSH
89571: EMPTY
89572: LIST
89573: LIST
89574: PUSH
89575: LD_INT 1
89577: PUSH
89578: LD_INT 4
89580: NEG
89581: PUSH
89582: EMPTY
89583: LIST
89584: LIST
89585: PUSH
89586: LD_INT 1
89588: NEG
89589: PUSH
89590: LD_INT 6
89592: NEG
89593: PUSH
89594: EMPTY
89595: LIST
89596: LIST
89597: PUSH
89598: LD_INT 0
89600: PUSH
89601: LD_INT 6
89603: NEG
89604: PUSH
89605: EMPTY
89606: LIST
89607: LIST
89608: PUSH
89609: LD_INT 1
89611: PUSH
89612: LD_INT 5
89614: NEG
89615: PUSH
89616: EMPTY
89617: LIST
89618: LIST
89619: PUSH
89620: EMPTY
89621: LIST
89622: LIST
89623: LIST
89624: LIST
89625: LIST
89626: LIST
89627: LIST
89628: LIST
89629: LIST
89630: LIST
89631: LIST
89632: LIST
89633: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
89634: LD_ADDR_VAR 0 30
89638: PUSH
89639: LD_INT 2
89641: PUSH
89642: LD_INT 1
89644: NEG
89645: PUSH
89646: EMPTY
89647: LIST
89648: LIST
89649: PUSH
89650: LD_INT 3
89652: PUSH
89653: LD_INT 0
89655: PUSH
89656: EMPTY
89657: LIST
89658: LIST
89659: PUSH
89660: LD_INT 3
89662: PUSH
89663: LD_INT 1
89665: PUSH
89666: EMPTY
89667: LIST
89668: LIST
89669: PUSH
89670: LD_INT 3
89672: PUSH
89673: LD_INT 1
89675: NEG
89676: PUSH
89677: EMPTY
89678: LIST
89679: LIST
89680: PUSH
89681: LD_INT 4
89683: PUSH
89684: LD_INT 0
89686: PUSH
89687: EMPTY
89688: LIST
89689: LIST
89690: PUSH
89691: LD_INT 4
89693: PUSH
89694: LD_INT 1
89696: PUSH
89697: EMPTY
89698: LIST
89699: LIST
89700: PUSH
89701: LD_INT 4
89703: PUSH
89704: LD_INT 1
89706: NEG
89707: PUSH
89708: EMPTY
89709: LIST
89710: LIST
89711: PUSH
89712: LD_INT 5
89714: PUSH
89715: LD_INT 0
89717: PUSH
89718: EMPTY
89719: LIST
89720: LIST
89721: PUSH
89722: LD_INT 5
89724: PUSH
89725: LD_INT 1
89727: PUSH
89728: EMPTY
89729: LIST
89730: LIST
89731: PUSH
89732: LD_INT 5
89734: PUSH
89735: LD_INT 1
89737: NEG
89738: PUSH
89739: EMPTY
89740: LIST
89741: LIST
89742: PUSH
89743: LD_INT 6
89745: PUSH
89746: LD_INT 0
89748: PUSH
89749: EMPTY
89750: LIST
89751: LIST
89752: PUSH
89753: LD_INT 6
89755: PUSH
89756: LD_INT 1
89758: PUSH
89759: EMPTY
89760: LIST
89761: LIST
89762: PUSH
89763: EMPTY
89764: LIST
89765: LIST
89766: LIST
89767: LIST
89768: LIST
89769: LIST
89770: LIST
89771: LIST
89772: LIST
89773: LIST
89774: LIST
89775: LIST
89776: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
89777: LD_ADDR_VAR 0 31
89781: PUSH
89782: LD_INT 3
89784: PUSH
89785: LD_INT 2
89787: PUSH
89788: EMPTY
89789: LIST
89790: LIST
89791: PUSH
89792: LD_INT 3
89794: PUSH
89795: LD_INT 3
89797: PUSH
89798: EMPTY
89799: LIST
89800: LIST
89801: PUSH
89802: LD_INT 2
89804: PUSH
89805: LD_INT 3
89807: PUSH
89808: EMPTY
89809: LIST
89810: LIST
89811: PUSH
89812: LD_INT 4
89814: PUSH
89815: LD_INT 3
89817: PUSH
89818: EMPTY
89819: LIST
89820: LIST
89821: PUSH
89822: LD_INT 4
89824: PUSH
89825: LD_INT 4
89827: PUSH
89828: EMPTY
89829: LIST
89830: LIST
89831: PUSH
89832: LD_INT 3
89834: PUSH
89835: LD_INT 4
89837: PUSH
89838: EMPTY
89839: LIST
89840: LIST
89841: PUSH
89842: LD_INT 5
89844: PUSH
89845: LD_INT 4
89847: PUSH
89848: EMPTY
89849: LIST
89850: LIST
89851: PUSH
89852: LD_INT 5
89854: PUSH
89855: LD_INT 5
89857: PUSH
89858: EMPTY
89859: LIST
89860: LIST
89861: PUSH
89862: LD_INT 4
89864: PUSH
89865: LD_INT 5
89867: PUSH
89868: EMPTY
89869: LIST
89870: LIST
89871: PUSH
89872: LD_INT 6
89874: PUSH
89875: LD_INT 5
89877: PUSH
89878: EMPTY
89879: LIST
89880: LIST
89881: PUSH
89882: LD_INT 6
89884: PUSH
89885: LD_INT 6
89887: PUSH
89888: EMPTY
89889: LIST
89890: LIST
89891: PUSH
89892: LD_INT 5
89894: PUSH
89895: LD_INT 6
89897: PUSH
89898: EMPTY
89899: LIST
89900: LIST
89901: PUSH
89902: EMPTY
89903: LIST
89904: LIST
89905: LIST
89906: LIST
89907: LIST
89908: LIST
89909: LIST
89910: LIST
89911: LIST
89912: LIST
89913: LIST
89914: LIST
89915: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
89916: LD_ADDR_VAR 0 32
89920: PUSH
89921: LD_INT 1
89923: PUSH
89924: LD_INT 3
89926: PUSH
89927: EMPTY
89928: LIST
89929: LIST
89930: PUSH
89931: LD_INT 0
89933: PUSH
89934: LD_INT 3
89936: PUSH
89937: EMPTY
89938: LIST
89939: LIST
89940: PUSH
89941: LD_INT 1
89943: NEG
89944: PUSH
89945: LD_INT 2
89947: PUSH
89948: EMPTY
89949: LIST
89950: LIST
89951: PUSH
89952: LD_INT 1
89954: PUSH
89955: LD_INT 4
89957: PUSH
89958: EMPTY
89959: LIST
89960: LIST
89961: PUSH
89962: LD_INT 0
89964: PUSH
89965: LD_INT 4
89967: PUSH
89968: EMPTY
89969: LIST
89970: LIST
89971: PUSH
89972: LD_INT 1
89974: NEG
89975: PUSH
89976: LD_INT 3
89978: PUSH
89979: EMPTY
89980: LIST
89981: LIST
89982: PUSH
89983: LD_INT 1
89985: PUSH
89986: LD_INT 5
89988: PUSH
89989: EMPTY
89990: LIST
89991: LIST
89992: PUSH
89993: LD_INT 0
89995: PUSH
89996: LD_INT 5
89998: PUSH
89999: EMPTY
90000: LIST
90001: LIST
90002: PUSH
90003: LD_INT 1
90005: NEG
90006: PUSH
90007: LD_INT 4
90009: PUSH
90010: EMPTY
90011: LIST
90012: LIST
90013: PUSH
90014: LD_INT 1
90016: PUSH
90017: LD_INT 6
90019: PUSH
90020: EMPTY
90021: LIST
90022: LIST
90023: PUSH
90024: LD_INT 0
90026: PUSH
90027: LD_INT 6
90029: PUSH
90030: EMPTY
90031: LIST
90032: LIST
90033: PUSH
90034: LD_INT 1
90036: NEG
90037: PUSH
90038: LD_INT 5
90040: PUSH
90041: EMPTY
90042: LIST
90043: LIST
90044: PUSH
90045: EMPTY
90046: LIST
90047: LIST
90048: LIST
90049: LIST
90050: LIST
90051: LIST
90052: LIST
90053: LIST
90054: LIST
90055: LIST
90056: LIST
90057: LIST
90058: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
90059: LD_ADDR_VAR 0 33
90063: PUSH
90064: LD_INT 2
90066: NEG
90067: PUSH
90068: LD_INT 1
90070: PUSH
90071: EMPTY
90072: LIST
90073: LIST
90074: PUSH
90075: LD_INT 3
90077: NEG
90078: PUSH
90079: LD_INT 0
90081: PUSH
90082: EMPTY
90083: LIST
90084: LIST
90085: PUSH
90086: LD_INT 3
90088: NEG
90089: PUSH
90090: LD_INT 1
90092: NEG
90093: PUSH
90094: EMPTY
90095: LIST
90096: LIST
90097: PUSH
90098: LD_INT 3
90100: NEG
90101: PUSH
90102: LD_INT 1
90104: PUSH
90105: EMPTY
90106: LIST
90107: LIST
90108: PUSH
90109: LD_INT 4
90111: NEG
90112: PUSH
90113: LD_INT 0
90115: PUSH
90116: EMPTY
90117: LIST
90118: LIST
90119: PUSH
90120: LD_INT 4
90122: NEG
90123: PUSH
90124: LD_INT 1
90126: NEG
90127: PUSH
90128: EMPTY
90129: LIST
90130: LIST
90131: PUSH
90132: LD_INT 4
90134: NEG
90135: PUSH
90136: LD_INT 1
90138: PUSH
90139: EMPTY
90140: LIST
90141: LIST
90142: PUSH
90143: LD_INT 5
90145: NEG
90146: PUSH
90147: LD_INT 0
90149: PUSH
90150: EMPTY
90151: LIST
90152: LIST
90153: PUSH
90154: LD_INT 5
90156: NEG
90157: PUSH
90158: LD_INT 1
90160: NEG
90161: PUSH
90162: EMPTY
90163: LIST
90164: LIST
90165: PUSH
90166: LD_INT 5
90168: NEG
90169: PUSH
90170: LD_INT 1
90172: PUSH
90173: EMPTY
90174: LIST
90175: LIST
90176: PUSH
90177: LD_INT 6
90179: NEG
90180: PUSH
90181: LD_INT 0
90183: PUSH
90184: EMPTY
90185: LIST
90186: LIST
90187: PUSH
90188: LD_INT 6
90190: NEG
90191: PUSH
90192: LD_INT 1
90194: NEG
90195: PUSH
90196: EMPTY
90197: LIST
90198: LIST
90199: PUSH
90200: EMPTY
90201: LIST
90202: LIST
90203: LIST
90204: LIST
90205: LIST
90206: LIST
90207: LIST
90208: LIST
90209: LIST
90210: LIST
90211: LIST
90212: LIST
90213: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
90214: LD_ADDR_VAR 0 34
90218: PUSH
90219: LD_INT 2
90221: NEG
90222: PUSH
90223: LD_INT 3
90225: NEG
90226: PUSH
90227: EMPTY
90228: LIST
90229: LIST
90230: PUSH
90231: LD_INT 3
90233: NEG
90234: PUSH
90235: LD_INT 2
90237: NEG
90238: PUSH
90239: EMPTY
90240: LIST
90241: LIST
90242: PUSH
90243: LD_INT 3
90245: NEG
90246: PUSH
90247: LD_INT 3
90249: NEG
90250: PUSH
90251: EMPTY
90252: LIST
90253: LIST
90254: PUSH
90255: LD_INT 3
90257: NEG
90258: PUSH
90259: LD_INT 4
90261: NEG
90262: PUSH
90263: EMPTY
90264: LIST
90265: LIST
90266: PUSH
90267: LD_INT 4
90269: NEG
90270: PUSH
90271: LD_INT 3
90273: NEG
90274: PUSH
90275: EMPTY
90276: LIST
90277: LIST
90278: PUSH
90279: LD_INT 4
90281: NEG
90282: PUSH
90283: LD_INT 4
90285: NEG
90286: PUSH
90287: EMPTY
90288: LIST
90289: LIST
90290: PUSH
90291: LD_INT 4
90293: NEG
90294: PUSH
90295: LD_INT 5
90297: NEG
90298: PUSH
90299: EMPTY
90300: LIST
90301: LIST
90302: PUSH
90303: LD_INT 5
90305: NEG
90306: PUSH
90307: LD_INT 4
90309: NEG
90310: PUSH
90311: EMPTY
90312: LIST
90313: LIST
90314: PUSH
90315: LD_INT 5
90317: NEG
90318: PUSH
90319: LD_INT 5
90321: NEG
90322: PUSH
90323: EMPTY
90324: LIST
90325: LIST
90326: PUSH
90327: LD_INT 5
90329: NEG
90330: PUSH
90331: LD_INT 6
90333: NEG
90334: PUSH
90335: EMPTY
90336: LIST
90337: LIST
90338: PUSH
90339: LD_INT 6
90341: NEG
90342: PUSH
90343: LD_INT 5
90345: NEG
90346: PUSH
90347: EMPTY
90348: LIST
90349: LIST
90350: PUSH
90351: LD_INT 6
90353: NEG
90354: PUSH
90355: LD_INT 6
90357: NEG
90358: PUSH
90359: EMPTY
90360: LIST
90361: LIST
90362: PUSH
90363: EMPTY
90364: LIST
90365: LIST
90366: LIST
90367: LIST
90368: LIST
90369: LIST
90370: LIST
90371: LIST
90372: LIST
90373: LIST
90374: LIST
90375: LIST
90376: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
90377: LD_ADDR_VAR 0 41
90381: PUSH
90382: LD_INT 0
90384: PUSH
90385: LD_INT 2
90387: NEG
90388: PUSH
90389: EMPTY
90390: LIST
90391: LIST
90392: PUSH
90393: LD_INT 1
90395: NEG
90396: PUSH
90397: LD_INT 3
90399: NEG
90400: PUSH
90401: EMPTY
90402: LIST
90403: LIST
90404: PUSH
90405: LD_INT 1
90407: PUSH
90408: LD_INT 2
90410: NEG
90411: PUSH
90412: EMPTY
90413: LIST
90414: LIST
90415: PUSH
90416: EMPTY
90417: LIST
90418: LIST
90419: LIST
90420: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
90421: LD_ADDR_VAR 0 42
90425: PUSH
90426: LD_INT 2
90428: PUSH
90429: LD_INT 0
90431: PUSH
90432: EMPTY
90433: LIST
90434: LIST
90435: PUSH
90436: LD_INT 2
90438: PUSH
90439: LD_INT 1
90441: NEG
90442: PUSH
90443: EMPTY
90444: LIST
90445: LIST
90446: PUSH
90447: LD_INT 3
90449: PUSH
90450: LD_INT 1
90452: PUSH
90453: EMPTY
90454: LIST
90455: LIST
90456: PUSH
90457: EMPTY
90458: LIST
90459: LIST
90460: LIST
90461: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
90462: LD_ADDR_VAR 0 43
90466: PUSH
90467: LD_INT 2
90469: PUSH
90470: LD_INT 2
90472: PUSH
90473: EMPTY
90474: LIST
90475: LIST
90476: PUSH
90477: LD_INT 3
90479: PUSH
90480: LD_INT 2
90482: PUSH
90483: EMPTY
90484: LIST
90485: LIST
90486: PUSH
90487: LD_INT 2
90489: PUSH
90490: LD_INT 3
90492: PUSH
90493: EMPTY
90494: LIST
90495: LIST
90496: PUSH
90497: EMPTY
90498: LIST
90499: LIST
90500: LIST
90501: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
90502: LD_ADDR_VAR 0 44
90506: PUSH
90507: LD_INT 0
90509: PUSH
90510: LD_INT 2
90512: PUSH
90513: EMPTY
90514: LIST
90515: LIST
90516: PUSH
90517: LD_INT 1
90519: PUSH
90520: LD_INT 3
90522: PUSH
90523: EMPTY
90524: LIST
90525: LIST
90526: PUSH
90527: LD_INT 1
90529: NEG
90530: PUSH
90531: LD_INT 2
90533: PUSH
90534: EMPTY
90535: LIST
90536: LIST
90537: PUSH
90538: EMPTY
90539: LIST
90540: LIST
90541: LIST
90542: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
90543: LD_ADDR_VAR 0 45
90547: PUSH
90548: LD_INT 2
90550: NEG
90551: PUSH
90552: LD_INT 0
90554: PUSH
90555: EMPTY
90556: LIST
90557: LIST
90558: PUSH
90559: LD_INT 2
90561: NEG
90562: PUSH
90563: LD_INT 1
90565: PUSH
90566: EMPTY
90567: LIST
90568: LIST
90569: PUSH
90570: LD_INT 3
90572: NEG
90573: PUSH
90574: LD_INT 1
90576: NEG
90577: PUSH
90578: EMPTY
90579: LIST
90580: LIST
90581: PUSH
90582: EMPTY
90583: LIST
90584: LIST
90585: LIST
90586: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
90587: LD_ADDR_VAR 0 46
90591: PUSH
90592: LD_INT 2
90594: NEG
90595: PUSH
90596: LD_INT 2
90598: NEG
90599: PUSH
90600: EMPTY
90601: LIST
90602: LIST
90603: PUSH
90604: LD_INT 2
90606: NEG
90607: PUSH
90608: LD_INT 3
90610: NEG
90611: PUSH
90612: EMPTY
90613: LIST
90614: LIST
90615: PUSH
90616: LD_INT 3
90618: NEG
90619: PUSH
90620: LD_INT 2
90622: NEG
90623: PUSH
90624: EMPTY
90625: LIST
90626: LIST
90627: PUSH
90628: EMPTY
90629: LIST
90630: LIST
90631: LIST
90632: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
90633: LD_ADDR_VAR 0 47
90637: PUSH
90638: LD_INT 2
90640: NEG
90641: PUSH
90642: LD_INT 3
90644: NEG
90645: PUSH
90646: EMPTY
90647: LIST
90648: LIST
90649: PUSH
90650: LD_INT 1
90652: NEG
90653: PUSH
90654: LD_INT 3
90656: NEG
90657: PUSH
90658: EMPTY
90659: LIST
90660: LIST
90661: PUSH
90662: EMPTY
90663: LIST
90664: LIST
90665: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
90666: LD_ADDR_VAR 0 48
90670: PUSH
90671: LD_INT 1
90673: PUSH
90674: LD_INT 2
90676: NEG
90677: PUSH
90678: EMPTY
90679: LIST
90680: LIST
90681: PUSH
90682: LD_INT 2
90684: PUSH
90685: LD_INT 1
90687: NEG
90688: PUSH
90689: EMPTY
90690: LIST
90691: LIST
90692: PUSH
90693: EMPTY
90694: LIST
90695: LIST
90696: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
90697: LD_ADDR_VAR 0 49
90701: PUSH
90702: LD_INT 3
90704: PUSH
90705: LD_INT 1
90707: PUSH
90708: EMPTY
90709: LIST
90710: LIST
90711: PUSH
90712: LD_INT 3
90714: PUSH
90715: LD_INT 2
90717: PUSH
90718: EMPTY
90719: LIST
90720: LIST
90721: PUSH
90722: EMPTY
90723: LIST
90724: LIST
90725: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
90726: LD_ADDR_VAR 0 50
90730: PUSH
90731: LD_INT 2
90733: PUSH
90734: LD_INT 3
90736: PUSH
90737: EMPTY
90738: LIST
90739: LIST
90740: PUSH
90741: LD_INT 1
90743: PUSH
90744: LD_INT 3
90746: PUSH
90747: EMPTY
90748: LIST
90749: LIST
90750: PUSH
90751: EMPTY
90752: LIST
90753: LIST
90754: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
90755: LD_ADDR_VAR 0 51
90759: PUSH
90760: LD_INT 1
90762: NEG
90763: PUSH
90764: LD_INT 2
90766: PUSH
90767: EMPTY
90768: LIST
90769: LIST
90770: PUSH
90771: LD_INT 2
90773: NEG
90774: PUSH
90775: LD_INT 1
90777: PUSH
90778: EMPTY
90779: LIST
90780: LIST
90781: PUSH
90782: EMPTY
90783: LIST
90784: LIST
90785: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
90786: LD_ADDR_VAR 0 52
90790: PUSH
90791: LD_INT 3
90793: NEG
90794: PUSH
90795: LD_INT 1
90797: NEG
90798: PUSH
90799: EMPTY
90800: LIST
90801: LIST
90802: PUSH
90803: LD_INT 3
90805: NEG
90806: PUSH
90807: LD_INT 2
90809: NEG
90810: PUSH
90811: EMPTY
90812: LIST
90813: LIST
90814: PUSH
90815: EMPTY
90816: LIST
90817: LIST
90818: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90819: LD_ADDR_VAR 0 53
90823: PUSH
90824: LD_INT 1
90826: NEG
90827: PUSH
90828: LD_INT 3
90830: NEG
90831: PUSH
90832: EMPTY
90833: LIST
90834: LIST
90835: PUSH
90836: LD_INT 0
90838: PUSH
90839: LD_INT 3
90841: NEG
90842: PUSH
90843: EMPTY
90844: LIST
90845: LIST
90846: PUSH
90847: LD_INT 1
90849: PUSH
90850: LD_INT 2
90852: NEG
90853: PUSH
90854: EMPTY
90855: LIST
90856: LIST
90857: PUSH
90858: EMPTY
90859: LIST
90860: LIST
90861: LIST
90862: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90863: LD_ADDR_VAR 0 54
90867: PUSH
90868: LD_INT 2
90870: PUSH
90871: LD_INT 1
90873: NEG
90874: PUSH
90875: EMPTY
90876: LIST
90877: LIST
90878: PUSH
90879: LD_INT 3
90881: PUSH
90882: LD_INT 0
90884: PUSH
90885: EMPTY
90886: LIST
90887: LIST
90888: PUSH
90889: LD_INT 3
90891: PUSH
90892: LD_INT 1
90894: PUSH
90895: EMPTY
90896: LIST
90897: LIST
90898: PUSH
90899: EMPTY
90900: LIST
90901: LIST
90902: LIST
90903: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90904: LD_ADDR_VAR 0 55
90908: PUSH
90909: LD_INT 3
90911: PUSH
90912: LD_INT 2
90914: PUSH
90915: EMPTY
90916: LIST
90917: LIST
90918: PUSH
90919: LD_INT 3
90921: PUSH
90922: LD_INT 3
90924: PUSH
90925: EMPTY
90926: LIST
90927: LIST
90928: PUSH
90929: LD_INT 2
90931: PUSH
90932: LD_INT 3
90934: PUSH
90935: EMPTY
90936: LIST
90937: LIST
90938: PUSH
90939: EMPTY
90940: LIST
90941: LIST
90942: LIST
90943: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90944: LD_ADDR_VAR 0 56
90948: PUSH
90949: LD_INT 1
90951: PUSH
90952: LD_INT 3
90954: PUSH
90955: EMPTY
90956: LIST
90957: LIST
90958: PUSH
90959: LD_INT 0
90961: PUSH
90962: LD_INT 3
90964: PUSH
90965: EMPTY
90966: LIST
90967: LIST
90968: PUSH
90969: LD_INT 1
90971: NEG
90972: PUSH
90973: LD_INT 2
90975: PUSH
90976: EMPTY
90977: LIST
90978: LIST
90979: PUSH
90980: EMPTY
90981: LIST
90982: LIST
90983: LIST
90984: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90985: LD_ADDR_VAR 0 57
90989: PUSH
90990: LD_INT 2
90992: NEG
90993: PUSH
90994: LD_INT 1
90996: PUSH
90997: EMPTY
90998: LIST
90999: LIST
91000: PUSH
91001: LD_INT 3
91003: NEG
91004: PUSH
91005: LD_INT 0
91007: PUSH
91008: EMPTY
91009: LIST
91010: LIST
91011: PUSH
91012: LD_INT 3
91014: NEG
91015: PUSH
91016: LD_INT 1
91018: NEG
91019: PUSH
91020: EMPTY
91021: LIST
91022: LIST
91023: PUSH
91024: EMPTY
91025: LIST
91026: LIST
91027: LIST
91028: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91029: LD_ADDR_VAR 0 58
91033: PUSH
91034: LD_INT 2
91036: NEG
91037: PUSH
91038: LD_INT 3
91040: NEG
91041: PUSH
91042: EMPTY
91043: LIST
91044: LIST
91045: PUSH
91046: LD_INT 3
91048: NEG
91049: PUSH
91050: LD_INT 2
91052: NEG
91053: PUSH
91054: EMPTY
91055: LIST
91056: LIST
91057: PUSH
91058: LD_INT 3
91060: NEG
91061: PUSH
91062: LD_INT 3
91064: NEG
91065: PUSH
91066: EMPTY
91067: LIST
91068: LIST
91069: PUSH
91070: EMPTY
91071: LIST
91072: LIST
91073: LIST
91074: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
91075: LD_ADDR_VAR 0 59
91079: PUSH
91080: LD_INT 1
91082: NEG
91083: PUSH
91084: LD_INT 2
91086: NEG
91087: PUSH
91088: EMPTY
91089: LIST
91090: LIST
91091: PUSH
91092: LD_INT 0
91094: PUSH
91095: LD_INT 2
91097: NEG
91098: PUSH
91099: EMPTY
91100: LIST
91101: LIST
91102: PUSH
91103: LD_INT 1
91105: PUSH
91106: LD_INT 1
91108: NEG
91109: PUSH
91110: EMPTY
91111: LIST
91112: LIST
91113: PUSH
91114: EMPTY
91115: LIST
91116: LIST
91117: LIST
91118: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
91119: LD_ADDR_VAR 0 60
91123: PUSH
91124: LD_INT 1
91126: PUSH
91127: LD_INT 1
91129: NEG
91130: PUSH
91131: EMPTY
91132: LIST
91133: LIST
91134: PUSH
91135: LD_INT 2
91137: PUSH
91138: LD_INT 0
91140: PUSH
91141: EMPTY
91142: LIST
91143: LIST
91144: PUSH
91145: LD_INT 2
91147: PUSH
91148: LD_INT 1
91150: PUSH
91151: EMPTY
91152: LIST
91153: LIST
91154: PUSH
91155: EMPTY
91156: LIST
91157: LIST
91158: LIST
91159: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
91160: LD_ADDR_VAR 0 61
91164: PUSH
91165: LD_INT 2
91167: PUSH
91168: LD_INT 1
91170: PUSH
91171: EMPTY
91172: LIST
91173: LIST
91174: PUSH
91175: LD_INT 2
91177: PUSH
91178: LD_INT 2
91180: PUSH
91181: EMPTY
91182: LIST
91183: LIST
91184: PUSH
91185: LD_INT 1
91187: PUSH
91188: LD_INT 2
91190: PUSH
91191: EMPTY
91192: LIST
91193: LIST
91194: PUSH
91195: EMPTY
91196: LIST
91197: LIST
91198: LIST
91199: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
91200: LD_ADDR_VAR 0 62
91204: PUSH
91205: LD_INT 1
91207: PUSH
91208: LD_INT 2
91210: PUSH
91211: EMPTY
91212: LIST
91213: LIST
91214: PUSH
91215: LD_INT 0
91217: PUSH
91218: LD_INT 2
91220: PUSH
91221: EMPTY
91222: LIST
91223: LIST
91224: PUSH
91225: LD_INT 1
91227: NEG
91228: PUSH
91229: LD_INT 1
91231: PUSH
91232: EMPTY
91233: LIST
91234: LIST
91235: PUSH
91236: EMPTY
91237: LIST
91238: LIST
91239: LIST
91240: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
91241: LD_ADDR_VAR 0 63
91245: PUSH
91246: LD_INT 1
91248: NEG
91249: PUSH
91250: LD_INT 1
91252: PUSH
91253: EMPTY
91254: LIST
91255: LIST
91256: PUSH
91257: LD_INT 2
91259: NEG
91260: PUSH
91261: LD_INT 0
91263: PUSH
91264: EMPTY
91265: LIST
91266: LIST
91267: PUSH
91268: LD_INT 2
91270: NEG
91271: PUSH
91272: LD_INT 1
91274: NEG
91275: PUSH
91276: EMPTY
91277: LIST
91278: LIST
91279: PUSH
91280: EMPTY
91281: LIST
91282: LIST
91283: LIST
91284: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91285: LD_ADDR_VAR 0 64
91289: PUSH
91290: LD_INT 1
91292: NEG
91293: PUSH
91294: LD_INT 2
91296: NEG
91297: PUSH
91298: EMPTY
91299: LIST
91300: LIST
91301: PUSH
91302: LD_INT 2
91304: NEG
91305: PUSH
91306: LD_INT 1
91308: NEG
91309: PUSH
91310: EMPTY
91311: LIST
91312: LIST
91313: PUSH
91314: LD_INT 2
91316: NEG
91317: PUSH
91318: LD_INT 2
91320: NEG
91321: PUSH
91322: EMPTY
91323: LIST
91324: LIST
91325: PUSH
91326: EMPTY
91327: LIST
91328: LIST
91329: LIST
91330: ST_TO_ADDR
// end ; 2 :
91331: GO 94597
91333: LD_INT 2
91335: DOUBLE
91336: EQUAL
91337: IFTRUE 91341
91339: GO 94596
91341: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
91342: LD_ADDR_VAR 0 29
91346: PUSH
91347: LD_INT 4
91349: PUSH
91350: LD_INT 0
91352: PUSH
91353: EMPTY
91354: LIST
91355: LIST
91356: PUSH
91357: LD_INT 4
91359: PUSH
91360: LD_INT 1
91362: NEG
91363: PUSH
91364: EMPTY
91365: LIST
91366: LIST
91367: PUSH
91368: LD_INT 5
91370: PUSH
91371: LD_INT 0
91373: PUSH
91374: EMPTY
91375: LIST
91376: LIST
91377: PUSH
91378: LD_INT 5
91380: PUSH
91381: LD_INT 1
91383: PUSH
91384: EMPTY
91385: LIST
91386: LIST
91387: PUSH
91388: LD_INT 4
91390: PUSH
91391: LD_INT 1
91393: PUSH
91394: EMPTY
91395: LIST
91396: LIST
91397: PUSH
91398: LD_INT 3
91400: PUSH
91401: LD_INT 0
91403: PUSH
91404: EMPTY
91405: LIST
91406: LIST
91407: PUSH
91408: LD_INT 3
91410: PUSH
91411: LD_INT 1
91413: NEG
91414: PUSH
91415: EMPTY
91416: LIST
91417: LIST
91418: PUSH
91419: LD_INT 3
91421: PUSH
91422: LD_INT 2
91424: NEG
91425: PUSH
91426: EMPTY
91427: LIST
91428: LIST
91429: PUSH
91430: LD_INT 5
91432: PUSH
91433: LD_INT 2
91435: PUSH
91436: EMPTY
91437: LIST
91438: LIST
91439: PUSH
91440: LD_INT 3
91442: PUSH
91443: LD_INT 3
91445: PUSH
91446: EMPTY
91447: LIST
91448: LIST
91449: PUSH
91450: LD_INT 3
91452: PUSH
91453: LD_INT 2
91455: PUSH
91456: EMPTY
91457: LIST
91458: LIST
91459: PUSH
91460: LD_INT 4
91462: PUSH
91463: LD_INT 3
91465: PUSH
91466: EMPTY
91467: LIST
91468: LIST
91469: PUSH
91470: LD_INT 4
91472: PUSH
91473: LD_INT 4
91475: PUSH
91476: EMPTY
91477: LIST
91478: LIST
91479: PUSH
91480: LD_INT 3
91482: PUSH
91483: LD_INT 4
91485: PUSH
91486: EMPTY
91487: LIST
91488: LIST
91489: PUSH
91490: LD_INT 2
91492: PUSH
91493: LD_INT 3
91495: PUSH
91496: EMPTY
91497: LIST
91498: LIST
91499: PUSH
91500: LD_INT 2
91502: PUSH
91503: LD_INT 2
91505: PUSH
91506: EMPTY
91507: LIST
91508: LIST
91509: PUSH
91510: LD_INT 4
91512: PUSH
91513: LD_INT 2
91515: PUSH
91516: EMPTY
91517: LIST
91518: LIST
91519: PUSH
91520: LD_INT 2
91522: PUSH
91523: LD_INT 4
91525: PUSH
91526: EMPTY
91527: LIST
91528: LIST
91529: PUSH
91530: LD_INT 0
91532: PUSH
91533: LD_INT 4
91535: PUSH
91536: EMPTY
91537: LIST
91538: LIST
91539: PUSH
91540: LD_INT 0
91542: PUSH
91543: LD_INT 3
91545: PUSH
91546: EMPTY
91547: LIST
91548: LIST
91549: PUSH
91550: LD_INT 1
91552: PUSH
91553: LD_INT 4
91555: PUSH
91556: EMPTY
91557: LIST
91558: LIST
91559: PUSH
91560: LD_INT 1
91562: PUSH
91563: LD_INT 5
91565: PUSH
91566: EMPTY
91567: LIST
91568: LIST
91569: PUSH
91570: LD_INT 0
91572: PUSH
91573: LD_INT 5
91575: PUSH
91576: EMPTY
91577: LIST
91578: LIST
91579: PUSH
91580: LD_INT 1
91582: NEG
91583: PUSH
91584: LD_INT 4
91586: PUSH
91587: EMPTY
91588: LIST
91589: LIST
91590: PUSH
91591: LD_INT 1
91593: NEG
91594: PUSH
91595: LD_INT 3
91597: PUSH
91598: EMPTY
91599: LIST
91600: LIST
91601: PUSH
91602: LD_INT 2
91604: PUSH
91605: LD_INT 5
91607: PUSH
91608: EMPTY
91609: LIST
91610: LIST
91611: PUSH
91612: LD_INT 2
91614: NEG
91615: PUSH
91616: LD_INT 3
91618: PUSH
91619: EMPTY
91620: LIST
91621: LIST
91622: PUSH
91623: LD_INT 3
91625: NEG
91626: PUSH
91627: LD_INT 0
91629: PUSH
91630: EMPTY
91631: LIST
91632: LIST
91633: PUSH
91634: LD_INT 3
91636: NEG
91637: PUSH
91638: LD_INT 1
91640: NEG
91641: PUSH
91642: EMPTY
91643: LIST
91644: LIST
91645: PUSH
91646: LD_INT 2
91648: NEG
91649: PUSH
91650: LD_INT 0
91652: PUSH
91653: EMPTY
91654: LIST
91655: LIST
91656: PUSH
91657: LD_INT 2
91659: NEG
91660: PUSH
91661: LD_INT 1
91663: PUSH
91664: EMPTY
91665: LIST
91666: LIST
91667: PUSH
91668: LD_INT 3
91670: NEG
91671: PUSH
91672: LD_INT 1
91674: PUSH
91675: EMPTY
91676: LIST
91677: LIST
91678: PUSH
91679: LD_INT 4
91681: NEG
91682: PUSH
91683: LD_INT 0
91685: PUSH
91686: EMPTY
91687: LIST
91688: LIST
91689: PUSH
91690: LD_INT 4
91692: NEG
91693: PUSH
91694: LD_INT 1
91696: NEG
91697: PUSH
91698: EMPTY
91699: LIST
91700: LIST
91701: PUSH
91702: LD_INT 4
91704: NEG
91705: PUSH
91706: LD_INT 2
91708: NEG
91709: PUSH
91710: EMPTY
91711: LIST
91712: LIST
91713: PUSH
91714: LD_INT 2
91716: NEG
91717: PUSH
91718: LD_INT 2
91720: PUSH
91721: EMPTY
91722: LIST
91723: LIST
91724: PUSH
91725: LD_INT 4
91727: NEG
91728: PUSH
91729: LD_INT 4
91731: NEG
91732: PUSH
91733: EMPTY
91734: LIST
91735: LIST
91736: PUSH
91737: LD_INT 4
91739: NEG
91740: PUSH
91741: LD_INT 5
91743: NEG
91744: PUSH
91745: EMPTY
91746: LIST
91747: LIST
91748: PUSH
91749: LD_INT 3
91751: NEG
91752: PUSH
91753: LD_INT 4
91755: NEG
91756: PUSH
91757: EMPTY
91758: LIST
91759: LIST
91760: PUSH
91761: LD_INT 3
91763: NEG
91764: PUSH
91765: LD_INT 3
91767: NEG
91768: PUSH
91769: EMPTY
91770: LIST
91771: LIST
91772: PUSH
91773: LD_INT 4
91775: NEG
91776: PUSH
91777: LD_INT 3
91779: NEG
91780: PUSH
91781: EMPTY
91782: LIST
91783: LIST
91784: PUSH
91785: LD_INT 5
91787: NEG
91788: PUSH
91789: LD_INT 4
91791: NEG
91792: PUSH
91793: EMPTY
91794: LIST
91795: LIST
91796: PUSH
91797: LD_INT 5
91799: NEG
91800: PUSH
91801: LD_INT 5
91803: NEG
91804: PUSH
91805: EMPTY
91806: LIST
91807: LIST
91808: PUSH
91809: LD_INT 3
91811: NEG
91812: PUSH
91813: LD_INT 5
91815: NEG
91816: PUSH
91817: EMPTY
91818: LIST
91819: LIST
91820: PUSH
91821: LD_INT 5
91823: NEG
91824: PUSH
91825: LD_INT 3
91827: NEG
91828: PUSH
91829: EMPTY
91830: LIST
91831: LIST
91832: PUSH
91833: EMPTY
91834: LIST
91835: LIST
91836: LIST
91837: LIST
91838: LIST
91839: LIST
91840: LIST
91841: LIST
91842: LIST
91843: LIST
91844: LIST
91845: LIST
91846: LIST
91847: LIST
91848: LIST
91849: LIST
91850: LIST
91851: LIST
91852: LIST
91853: LIST
91854: LIST
91855: LIST
91856: LIST
91857: LIST
91858: LIST
91859: LIST
91860: LIST
91861: LIST
91862: LIST
91863: LIST
91864: LIST
91865: LIST
91866: LIST
91867: LIST
91868: LIST
91869: LIST
91870: LIST
91871: LIST
91872: LIST
91873: LIST
91874: LIST
91875: LIST
91876: LIST
91877: LIST
91878: LIST
91879: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
91880: LD_ADDR_VAR 0 30
91884: PUSH
91885: LD_INT 4
91887: PUSH
91888: LD_INT 4
91890: PUSH
91891: EMPTY
91892: LIST
91893: LIST
91894: PUSH
91895: LD_INT 4
91897: PUSH
91898: LD_INT 3
91900: PUSH
91901: EMPTY
91902: LIST
91903: LIST
91904: PUSH
91905: LD_INT 5
91907: PUSH
91908: LD_INT 4
91910: PUSH
91911: EMPTY
91912: LIST
91913: LIST
91914: PUSH
91915: LD_INT 5
91917: PUSH
91918: LD_INT 5
91920: PUSH
91921: EMPTY
91922: LIST
91923: LIST
91924: PUSH
91925: LD_INT 4
91927: PUSH
91928: LD_INT 5
91930: PUSH
91931: EMPTY
91932: LIST
91933: LIST
91934: PUSH
91935: LD_INT 3
91937: PUSH
91938: LD_INT 4
91940: PUSH
91941: EMPTY
91942: LIST
91943: LIST
91944: PUSH
91945: LD_INT 3
91947: PUSH
91948: LD_INT 3
91950: PUSH
91951: EMPTY
91952: LIST
91953: LIST
91954: PUSH
91955: LD_INT 5
91957: PUSH
91958: LD_INT 3
91960: PUSH
91961: EMPTY
91962: LIST
91963: LIST
91964: PUSH
91965: LD_INT 3
91967: PUSH
91968: LD_INT 5
91970: PUSH
91971: EMPTY
91972: LIST
91973: LIST
91974: PUSH
91975: LD_INT 0
91977: PUSH
91978: LD_INT 3
91980: PUSH
91981: EMPTY
91982: LIST
91983: LIST
91984: PUSH
91985: LD_INT 0
91987: PUSH
91988: LD_INT 2
91990: PUSH
91991: EMPTY
91992: LIST
91993: LIST
91994: PUSH
91995: LD_INT 1
91997: PUSH
91998: LD_INT 3
92000: PUSH
92001: EMPTY
92002: LIST
92003: LIST
92004: PUSH
92005: LD_INT 1
92007: PUSH
92008: LD_INT 4
92010: PUSH
92011: EMPTY
92012: LIST
92013: LIST
92014: PUSH
92015: LD_INT 0
92017: PUSH
92018: LD_INT 4
92020: PUSH
92021: EMPTY
92022: LIST
92023: LIST
92024: PUSH
92025: LD_INT 1
92027: NEG
92028: PUSH
92029: LD_INT 3
92031: PUSH
92032: EMPTY
92033: LIST
92034: LIST
92035: PUSH
92036: LD_INT 1
92038: NEG
92039: PUSH
92040: LD_INT 2
92042: PUSH
92043: EMPTY
92044: LIST
92045: LIST
92046: PUSH
92047: LD_INT 2
92049: PUSH
92050: LD_INT 4
92052: PUSH
92053: EMPTY
92054: LIST
92055: LIST
92056: PUSH
92057: LD_INT 2
92059: NEG
92060: PUSH
92061: LD_INT 2
92063: PUSH
92064: EMPTY
92065: LIST
92066: LIST
92067: PUSH
92068: LD_INT 4
92070: NEG
92071: PUSH
92072: LD_INT 0
92074: PUSH
92075: EMPTY
92076: LIST
92077: LIST
92078: PUSH
92079: LD_INT 4
92081: NEG
92082: PUSH
92083: LD_INT 1
92085: NEG
92086: PUSH
92087: EMPTY
92088: LIST
92089: LIST
92090: PUSH
92091: LD_INT 3
92093: NEG
92094: PUSH
92095: LD_INT 0
92097: PUSH
92098: EMPTY
92099: LIST
92100: LIST
92101: PUSH
92102: LD_INT 3
92104: NEG
92105: PUSH
92106: LD_INT 1
92108: PUSH
92109: EMPTY
92110: LIST
92111: LIST
92112: PUSH
92113: LD_INT 4
92115: NEG
92116: PUSH
92117: LD_INT 1
92119: PUSH
92120: EMPTY
92121: LIST
92122: LIST
92123: PUSH
92124: LD_INT 5
92126: NEG
92127: PUSH
92128: LD_INT 0
92130: PUSH
92131: EMPTY
92132: LIST
92133: LIST
92134: PUSH
92135: LD_INT 5
92137: NEG
92138: PUSH
92139: LD_INT 1
92141: NEG
92142: PUSH
92143: EMPTY
92144: LIST
92145: LIST
92146: PUSH
92147: LD_INT 5
92149: NEG
92150: PUSH
92151: LD_INT 2
92153: NEG
92154: PUSH
92155: EMPTY
92156: LIST
92157: LIST
92158: PUSH
92159: LD_INT 3
92161: NEG
92162: PUSH
92163: LD_INT 2
92165: PUSH
92166: EMPTY
92167: LIST
92168: LIST
92169: PUSH
92170: LD_INT 3
92172: NEG
92173: PUSH
92174: LD_INT 3
92176: NEG
92177: PUSH
92178: EMPTY
92179: LIST
92180: LIST
92181: PUSH
92182: LD_INT 3
92184: NEG
92185: PUSH
92186: LD_INT 4
92188: NEG
92189: PUSH
92190: EMPTY
92191: LIST
92192: LIST
92193: PUSH
92194: LD_INT 2
92196: NEG
92197: PUSH
92198: LD_INT 3
92200: NEG
92201: PUSH
92202: EMPTY
92203: LIST
92204: LIST
92205: PUSH
92206: LD_INT 2
92208: NEG
92209: PUSH
92210: LD_INT 2
92212: NEG
92213: PUSH
92214: EMPTY
92215: LIST
92216: LIST
92217: PUSH
92218: LD_INT 3
92220: NEG
92221: PUSH
92222: LD_INT 2
92224: NEG
92225: PUSH
92226: EMPTY
92227: LIST
92228: LIST
92229: PUSH
92230: LD_INT 4
92232: NEG
92233: PUSH
92234: LD_INT 3
92236: NEG
92237: PUSH
92238: EMPTY
92239: LIST
92240: LIST
92241: PUSH
92242: LD_INT 4
92244: NEG
92245: PUSH
92246: LD_INT 4
92248: NEG
92249: PUSH
92250: EMPTY
92251: LIST
92252: LIST
92253: PUSH
92254: LD_INT 2
92256: NEG
92257: PUSH
92258: LD_INT 4
92260: NEG
92261: PUSH
92262: EMPTY
92263: LIST
92264: LIST
92265: PUSH
92266: LD_INT 4
92268: NEG
92269: PUSH
92270: LD_INT 2
92272: NEG
92273: PUSH
92274: EMPTY
92275: LIST
92276: LIST
92277: PUSH
92278: LD_INT 0
92280: PUSH
92281: LD_INT 4
92283: NEG
92284: PUSH
92285: EMPTY
92286: LIST
92287: LIST
92288: PUSH
92289: LD_INT 0
92291: PUSH
92292: LD_INT 5
92294: NEG
92295: PUSH
92296: EMPTY
92297: LIST
92298: LIST
92299: PUSH
92300: LD_INT 1
92302: PUSH
92303: LD_INT 4
92305: NEG
92306: PUSH
92307: EMPTY
92308: LIST
92309: LIST
92310: PUSH
92311: LD_INT 1
92313: PUSH
92314: LD_INT 3
92316: NEG
92317: PUSH
92318: EMPTY
92319: LIST
92320: LIST
92321: PUSH
92322: LD_INT 0
92324: PUSH
92325: LD_INT 3
92327: NEG
92328: PUSH
92329: EMPTY
92330: LIST
92331: LIST
92332: PUSH
92333: LD_INT 1
92335: NEG
92336: PUSH
92337: LD_INT 4
92339: NEG
92340: PUSH
92341: EMPTY
92342: LIST
92343: LIST
92344: PUSH
92345: LD_INT 1
92347: NEG
92348: PUSH
92349: LD_INT 5
92351: NEG
92352: PUSH
92353: EMPTY
92354: LIST
92355: LIST
92356: PUSH
92357: LD_INT 2
92359: PUSH
92360: LD_INT 3
92362: NEG
92363: PUSH
92364: EMPTY
92365: LIST
92366: LIST
92367: PUSH
92368: LD_INT 2
92370: NEG
92371: PUSH
92372: LD_INT 5
92374: NEG
92375: PUSH
92376: EMPTY
92377: LIST
92378: LIST
92379: PUSH
92380: EMPTY
92381: LIST
92382: LIST
92383: LIST
92384: LIST
92385: LIST
92386: LIST
92387: LIST
92388: LIST
92389: LIST
92390: LIST
92391: LIST
92392: LIST
92393: LIST
92394: LIST
92395: LIST
92396: LIST
92397: LIST
92398: LIST
92399: LIST
92400: LIST
92401: LIST
92402: LIST
92403: LIST
92404: LIST
92405: LIST
92406: LIST
92407: LIST
92408: LIST
92409: LIST
92410: LIST
92411: LIST
92412: LIST
92413: LIST
92414: LIST
92415: LIST
92416: LIST
92417: LIST
92418: LIST
92419: LIST
92420: LIST
92421: LIST
92422: LIST
92423: LIST
92424: LIST
92425: LIST
92426: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
92427: LD_ADDR_VAR 0 31
92431: PUSH
92432: LD_INT 0
92434: PUSH
92435: LD_INT 4
92437: PUSH
92438: EMPTY
92439: LIST
92440: LIST
92441: PUSH
92442: LD_INT 0
92444: PUSH
92445: LD_INT 3
92447: PUSH
92448: EMPTY
92449: LIST
92450: LIST
92451: PUSH
92452: LD_INT 1
92454: PUSH
92455: LD_INT 4
92457: PUSH
92458: EMPTY
92459: LIST
92460: LIST
92461: PUSH
92462: LD_INT 1
92464: PUSH
92465: LD_INT 5
92467: PUSH
92468: EMPTY
92469: LIST
92470: LIST
92471: PUSH
92472: LD_INT 0
92474: PUSH
92475: LD_INT 5
92477: PUSH
92478: EMPTY
92479: LIST
92480: LIST
92481: PUSH
92482: LD_INT 1
92484: NEG
92485: PUSH
92486: LD_INT 4
92488: PUSH
92489: EMPTY
92490: LIST
92491: LIST
92492: PUSH
92493: LD_INT 1
92495: NEG
92496: PUSH
92497: LD_INT 3
92499: PUSH
92500: EMPTY
92501: LIST
92502: LIST
92503: PUSH
92504: LD_INT 2
92506: PUSH
92507: LD_INT 5
92509: PUSH
92510: EMPTY
92511: LIST
92512: LIST
92513: PUSH
92514: LD_INT 2
92516: NEG
92517: PUSH
92518: LD_INT 3
92520: PUSH
92521: EMPTY
92522: LIST
92523: LIST
92524: PUSH
92525: LD_INT 3
92527: NEG
92528: PUSH
92529: LD_INT 0
92531: PUSH
92532: EMPTY
92533: LIST
92534: LIST
92535: PUSH
92536: LD_INT 3
92538: NEG
92539: PUSH
92540: LD_INT 1
92542: NEG
92543: PUSH
92544: EMPTY
92545: LIST
92546: LIST
92547: PUSH
92548: LD_INT 2
92550: NEG
92551: PUSH
92552: LD_INT 0
92554: PUSH
92555: EMPTY
92556: LIST
92557: LIST
92558: PUSH
92559: LD_INT 2
92561: NEG
92562: PUSH
92563: LD_INT 1
92565: PUSH
92566: EMPTY
92567: LIST
92568: LIST
92569: PUSH
92570: LD_INT 3
92572: NEG
92573: PUSH
92574: LD_INT 1
92576: PUSH
92577: EMPTY
92578: LIST
92579: LIST
92580: PUSH
92581: LD_INT 4
92583: NEG
92584: PUSH
92585: LD_INT 0
92587: PUSH
92588: EMPTY
92589: LIST
92590: LIST
92591: PUSH
92592: LD_INT 4
92594: NEG
92595: PUSH
92596: LD_INT 1
92598: NEG
92599: PUSH
92600: EMPTY
92601: LIST
92602: LIST
92603: PUSH
92604: LD_INT 4
92606: NEG
92607: PUSH
92608: LD_INT 2
92610: NEG
92611: PUSH
92612: EMPTY
92613: LIST
92614: LIST
92615: PUSH
92616: LD_INT 2
92618: NEG
92619: PUSH
92620: LD_INT 2
92622: PUSH
92623: EMPTY
92624: LIST
92625: LIST
92626: PUSH
92627: LD_INT 4
92629: NEG
92630: PUSH
92631: LD_INT 4
92633: NEG
92634: PUSH
92635: EMPTY
92636: LIST
92637: LIST
92638: PUSH
92639: LD_INT 4
92641: NEG
92642: PUSH
92643: LD_INT 5
92645: NEG
92646: PUSH
92647: EMPTY
92648: LIST
92649: LIST
92650: PUSH
92651: LD_INT 3
92653: NEG
92654: PUSH
92655: LD_INT 4
92657: NEG
92658: PUSH
92659: EMPTY
92660: LIST
92661: LIST
92662: PUSH
92663: LD_INT 3
92665: NEG
92666: PUSH
92667: LD_INT 3
92669: NEG
92670: PUSH
92671: EMPTY
92672: LIST
92673: LIST
92674: PUSH
92675: LD_INT 4
92677: NEG
92678: PUSH
92679: LD_INT 3
92681: NEG
92682: PUSH
92683: EMPTY
92684: LIST
92685: LIST
92686: PUSH
92687: LD_INT 5
92689: NEG
92690: PUSH
92691: LD_INT 4
92693: NEG
92694: PUSH
92695: EMPTY
92696: LIST
92697: LIST
92698: PUSH
92699: LD_INT 5
92701: NEG
92702: PUSH
92703: LD_INT 5
92705: NEG
92706: PUSH
92707: EMPTY
92708: LIST
92709: LIST
92710: PUSH
92711: LD_INT 3
92713: NEG
92714: PUSH
92715: LD_INT 5
92717: NEG
92718: PUSH
92719: EMPTY
92720: LIST
92721: LIST
92722: PUSH
92723: LD_INT 5
92725: NEG
92726: PUSH
92727: LD_INT 3
92729: NEG
92730: PUSH
92731: EMPTY
92732: LIST
92733: LIST
92734: PUSH
92735: LD_INT 0
92737: PUSH
92738: LD_INT 3
92740: NEG
92741: PUSH
92742: EMPTY
92743: LIST
92744: LIST
92745: PUSH
92746: LD_INT 0
92748: PUSH
92749: LD_INT 4
92751: NEG
92752: PUSH
92753: EMPTY
92754: LIST
92755: LIST
92756: PUSH
92757: LD_INT 1
92759: PUSH
92760: LD_INT 3
92762: NEG
92763: PUSH
92764: EMPTY
92765: LIST
92766: LIST
92767: PUSH
92768: LD_INT 1
92770: PUSH
92771: LD_INT 2
92773: NEG
92774: PUSH
92775: EMPTY
92776: LIST
92777: LIST
92778: PUSH
92779: LD_INT 0
92781: PUSH
92782: LD_INT 2
92784: NEG
92785: PUSH
92786: EMPTY
92787: LIST
92788: LIST
92789: PUSH
92790: LD_INT 1
92792: NEG
92793: PUSH
92794: LD_INT 3
92796: NEG
92797: PUSH
92798: EMPTY
92799: LIST
92800: LIST
92801: PUSH
92802: LD_INT 1
92804: NEG
92805: PUSH
92806: LD_INT 4
92808: NEG
92809: PUSH
92810: EMPTY
92811: LIST
92812: LIST
92813: PUSH
92814: LD_INT 2
92816: PUSH
92817: LD_INT 2
92819: NEG
92820: PUSH
92821: EMPTY
92822: LIST
92823: LIST
92824: PUSH
92825: LD_INT 2
92827: NEG
92828: PUSH
92829: LD_INT 4
92831: NEG
92832: PUSH
92833: EMPTY
92834: LIST
92835: LIST
92836: PUSH
92837: LD_INT 4
92839: PUSH
92840: LD_INT 0
92842: PUSH
92843: EMPTY
92844: LIST
92845: LIST
92846: PUSH
92847: LD_INT 4
92849: PUSH
92850: LD_INT 1
92852: NEG
92853: PUSH
92854: EMPTY
92855: LIST
92856: LIST
92857: PUSH
92858: LD_INT 5
92860: PUSH
92861: LD_INT 0
92863: PUSH
92864: EMPTY
92865: LIST
92866: LIST
92867: PUSH
92868: LD_INT 5
92870: PUSH
92871: LD_INT 1
92873: PUSH
92874: EMPTY
92875: LIST
92876: LIST
92877: PUSH
92878: LD_INT 4
92880: PUSH
92881: LD_INT 1
92883: PUSH
92884: EMPTY
92885: LIST
92886: LIST
92887: PUSH
92888: LD_INT 3
92890: PUSH
92891: LD_INT 0
92893: PUSH
92894: EMPTY
92895: LIST
92896: LIST
92897: PUSH
92898: LD_INT 3
92900: PUSH
92901: LD_INT 1
92903: NEG
92904: PUSH
92905: EMPTY
92906: LIST
92907: LIST
92908: PUSH
92909: LD_INT 3
92911: PUSH
92912: LD_INT 2
92914: NEG
92915: PUSH
92916: EMPTY
92917: LIST
92918: LIST
92919: PUSH
92920: LD_INT 5
92922: PUSH
92923: LD_INT 2
92925: PUSH
92926: EMPTY
92927: LIST
92928: LIST
92929: PUSH
92930: EMPTY
92931: LIST
92932: LIST
92933: LIST
92934: LIST
92935: LIST
92936: LIST
92937: LIST
92938: LIST
92939: LIST
92940: LIST
92941: LIST
92942: LIST
92943: LIST
92944: LIST
92945: LIST
92946: LIST
92947: LIST
92948: LIST
92949: LIST
92950: LIST
92951: LIST
92952: LIST
92953: LIST
92954: LIST
92955: LIST
92956: LIST
92957: LIST
92958: LIST
92959: LIST
92960: LIST
92961: LIST
92962: LIST
92963: LIST
92964: LIST
92965: LIST
92966: LIST
92967: LIST
92968: LIST
92969: LIST
92970: LIST
92971: LIST
92972: LIST
92973: LIST
92974: LIST
92975: LIST
92976: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
92977: LD_ADDR_VAR 0 32
92981: PUSH
92982: LD_INT 4
92984: NEG
92985: PUSH
92986: LD_INT 0
92988: PUSH
92989: EMPTY
92990: LIST
92991: LIST
92992: PUSH
92993: LD_INT 4
92995: NEG
92996: PUSH
92997: LD_INT 1
92999: NEG
93000: PUSH
93001: EMPTY
93002: LIST
93003: LIST
93004: PUSH
93005: LD_INT 3
93007: NEG
93008: PUSH
93009: LD_INT 0
93011: PUSH
93012: EMPTY
93013: LIST
93014: LIST
93015: PUSH
93016: LD_INT 3
93018: NEG
93019: PUSH
93020: LD_INT 1
93022: PUSH
93023: EMPTY
93024: LIST
93025: LIST
93026: PUSH
93027: LD_INT 4
93029: NEG
93030: PUSH
93031: LD_INT 1
93033: PUSH
93034: EMPTY
93035: LIST
93036: LIST
93037: PUSH
93038: LD_INT 5
93040: NEG
93041: PUSH
93042: LD_INT 0
93044: PUSH
93045: EMPTY
93046: LIST
93047: LIST
93048: PUSH
93049: LD_INT 5
93051: NEG
93052: PUSH
93053: LD_INT 1
93055: NEG
93056: PUSH
93057: EMPTY
93058: LIST
93059: LIST
93060: PUSH
93061: LD_INT 5
93063: NEG
93064: PUSH
93065: LD_INT 2
93067: NEG
93068: PUSH
93069: EMPTY
93070: LIST
93071: LIST
93072: PUSH
93073: LD_INT 3
93075: NEG
93076: PUSH
93077: LD_INT 2
93079: PUSH
93080: EMPTY
93081: LIST
93082: LIST
93083: PUSH
93084: LD_INT 3
93086: NEG
93087: PUSH
93088: LD_INT 3
93090: NEG
93091: PUSH
93092: EMPTY
93093: LIST
93094: LIST
93095: PUSH
93096: LD_INT 3
93098: NEG
93099: PUSH
93100: LD_INT 4
93102: NEG
93103: PUSH
93104: EMPTY
93105: LIST
93106: LIST
93107: PUSH
93108: LD_INT 2
93110: NEG
93111: PUSH
93112: LD_INT 3
93114: NEG
93115: PUSH
93116: EMPTY
93117: LIST
93118: LIST
93119: PUSH
93120: LD_INT 2
93122: NEG
93123: PUSH
93124: LD_INT 2
93126: NEG
93127: PUSH
93128: EMPTY
93129: LIST
93130: LIST
93131: PUSH
93132: LD_INT 3
93134: NEG
93135: PUSH
93136: LD_INT 2
93138: NEG
93139: PUSH
93140: EMPTY
93141: LIST
93142: LIST
93143: PUSH
93144: LD_INT 4
93146: NEG
93147: PUSH
93148: LD_INT 3
93150: NEG
93151: PUSH
93152: EMPTY
93153: LIST
93154: LIST
93155: PUSH
93156: LD_INT 4
93158: NEG
93159: PUSH
93160: LD_INT 4
93162: NEG
93163: PUSH
93164: EMPTY
93165: LIST
93166: LIST
93167: PUSH
93168: LD_INT 2
93170: NEG
93171: PUSH
93172: LD_INT 4
93174: NEG
93175: PUSH
93176: EMPTY
93177: LIST
93178: LIST
93179: PUSH
93180: LD_INT 4
93182: NEG
93183: PUSH
93184: LD_INT 2
93186: NEG
93187: PUSH
93188: EMPTY
93189: LIST
93190: LIST
93191: PUSH
93192: LD_INT 0
93194: PUSH
93195: LD_INT 4
93197: NEG
93198: PUSH
93199: EMPTY
93200: LIST
93201: LIST
93202: PUSH
93203: LD_INT 0
93205: PUSH
93206: LD_INT 5
93208: NEG
93209: PUSH
93210: EMPTY
93211: LIST
93212: LIST
93213: PUSH
93214: LD_INT 1
93216: PUSH
93217: LD_INT 4
93219: NEG
93220: PUSH
93221: EMPTY
93222: LIST
93223: LIST
93224: PUSH
93225: LD_INT 1
93227: PUSH
93228: LD_INT 3
93230: NEG
93231: PUSH
93232: EMPTY
93233: LIST
93234: LIST
93235: PUSH
93236: LD_INT 0
93238: PUSH
93239: LD_INT 3
93241: NEG
93242: PUSH
93243: EMPTY
93244: LIST
93245: LIST
93246: PUSH
93247: LD_INT 1
93249: NEG
93250: PUSH
93251: LD_INT 4
93253: NEG
93254: PUSH
93255: EMPTY
93256: LIST
93257: LIST
93258: PUSH
93259: LD_INT 1
93261: NEG
93262: PUSH
93263: LD_INT 5
93265: NEG
93266: PUSH
93267: EMPTY
93268: LIST
93269: LIST
93270: PUSH
93271: LD_INT 2
93273: PUSH
93274: LD_INT 3
93276: NEG
93277: PUSH
93278: EMPTY
93279: LIST
93280: LIST
93281: PUSH
93282: LD_INT 2
93284: NEG
93285: PUSH
93286: LD_INT 5
93288: NEG
93289: PUSH
93290: EMPTY
93291: LIST
93292: LIST
93293: PUSH
93294: LD_INT 3
93296: PUSH
93297: LD_INT 0
93299: PUSH
93300: EMPTY
93301: LIST
93302: LIST
93303: PUSH
93304: LD_INT 3
93306: PUSH
93307: LD_INT 1
93309: NEG
93310: PUSH
93311: EMPTY
93312: LIST
93313: LIST
93314: PUSH
93315: LD_INT 4
93317: PUSH
93318: LD_INT 0
93320: PUSH
93321: EMPTY
93322: LIST
93323: LIST
93324: PUSH
93325: LD_INT 4
93327: PUSH
93328: LD_INT 1
93330: PUSH
93331: EMPTY
93332: LIST
93333: LIST
93334: PUSH
93335: LD_INT 3
93337: PUSH
93338: LD_INT 1
93340: PUSH
93341: EMPTY
93342: LIST
93343: LIST
93344: PUSH
93345: LD_INT 2
93347: PUSH
93348: LD_INT 0
93350: PUSH
93351: EMPTY
93352: LIST
93353: LIST
93354: PUSH
93355: LD_INT 2
93357: PUSH
93358: LD_INT 1
93360: NEG
93361: PUSH
93362: EMPTY
93363: LIST
93364: LIST
93365: PUSH
93366: LD_INT 2
93368: PUSH
93369: LD_INT 2
93371: NEG
93372: PUSH
93373: EMPTY
93374: LIST
93375: LIST
93376: PUSH
93377: LD_INT 4
93379: PUSH
93380: LD_INT 2
93382: PUSH
93383: EMPTY
93384: LIST
93385: LIST
93386: PUSH
93387: LD_INT 4
93389: PUSH
93390: LD_INT 4
93392: PUSH
93393: EMPTY
93394: LIST
93395: LIST
93396: PUSH
93397: LD_INT 4
93399: PUSH
93400: LD_INT 3
93402: PUSH
93403: EMPTY
93404: LIST
93405: LIST
93406: PUSH
93407: LD_INT 5
93409: PUSH
93410: LD_INT 4
93412: PUSH
93413: EMPTY
93414: LIST
93415: LIST
93416: PUSH
93417: LD_INT 5
93419: PUSH
93420: LD_INT 5
93422: PUSH
93423: EMPTY
93424: LIST
93425: LIST
93426: PUSH
93427: LD_INT 4
93429: PUSH
93430: LD_INT 5
93432: PUSH
93433: EMPTY
93434: LIST
93435: LIST
93436: PUSH
93437: LD_INT 3
93439: PUSH
93440: LD_INT 4
93442: PUSH
93443: EMPTY
93444: LIST
93445: LIST
93446: PUSH
93447: LD_INT 3
93449: PUSH
93450: LD_INT 3
93452: PUSH
93453: EMPTY
93454: LIST
93455: LIST
93456: PUSH
93457: LD_INT 5
93459: PUSH
93460: LD_INT 3
93462: PUSH
93463: EMPTY
93464: LIST
93465: LIST
93466: PUSH
93467: LD_INT 3
93469: PUSH
93470: LD_INT 5
93472: PUSH
93473: EMPTY
93474: LIST
93475: LIST
93476: PUSH
93477: EMPTY
93478: LIST
93479: LIST
93480: LIST
93481: LIST
93482: LIST
93483: LIST
93484: LIST
93485: LIST
93486: LIST
93487: LIST
93488: LIST
93489: LIST
93490: LIST
93491: LIST
93492: LIST
93493: LIST
93494: LIST
93495: LIST
93496: LIST
93497: LIST
93498: LIST
93499: LIST
93500: LIST
93501: LIST
93502: LIST
93503: LIST
93504: LIST
93505: LIST
93506: LIST
93507: LIST
93508: LIST
93509: LIST
93510: LIST
93511: LIST
93512: LIST
93513: LIST
93514: LIST
93515: LIST
93516: LIST
93517: LIST
93518: LIST
93519: LIST
93520: LIST
93521: LIST
93522: LIST
93523: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
93524: LD_ADDR_VAR 0 33
93528: PUSH
93529: LD_INT 4
93531: NEG
93532: PUSH
93533: LD_INT 4
93535: NEG
93536: PUSH
93537: EMPTY
93538: LIST
93539: LIST
93540: PUSH
93541: LD_INT 4
93543: NEG
93544: PUSH
93545: LD_INT 5
93547: NEG
93548: PUSH
93549: EMPTY
93550: LIST
93551: LIST
93552: PUSH
93553: LD_INT 3
93555: NEG
93556: PUSH
93557: LD_INT 4
93559: NEG
93560: PUSH
93561: EMPTY
93562: LIST
93563: LIST
93564: PUSH
93565: LD_INT 3
93567: NEG
93568: PUSH
93569: LD_INT 3
93571: NEG
93572: PUSH
93573: EMPTY
93574: LIST
93575: LIST
93576: PUSH
93577: LD_INT 4
93579: NEG
93580: PUSH
93581: LD_INT 3
93583: NEG
93584: PUSH
93585: EMPTY
93586: LIST
93587: LIST
93588: PUSH
93589: LD_INT 5
93591: NEG
93592: PUSH
93593: LD_INT 4
93595: NEG
93596: PUSH
93597: EMPTY
93598: LIST
93599: LIST
93600: PUSH
93601: LD_INT 5
93603: NEG
93604: PUSH
93605: LD_INT 5
93607: NEG
93608: PUSH
93609: EMPTY
93610: LIST
93611: LIST
93612: PUSH
93613: LD_INT 3
93615: NEG
93616: PUSH
93617: LD_INT 5
93619: NEG
93620: PUSH
93621: EMPTY
93622: LIST
93623: LIST
93624: PUSH
93625: LD_INT 5
93627: NEG
93628: PUSH
93629: LD_INT 3
93631: NEG
93632: PUSH
93633: EMPTY
93634: LIST
93635: LIST
93636: PUSH
93637: LD_INT 0
93639: PUSH
93640: LD_INT 3
93642: NEG
93643: PUSH
93644: EMPTY
93645: LIST
93646: LIST
93647: PUSH
93648: LD_INT 0
93650: PUSH
93651: LD_INT 4
93653: NEG
93654: PUSH
93655: EMPTY
93656: LIST
93657: LIST
93658: PUSH
93659: LD_INT 1
93661: PUSH
93662: LD_INT 3
93664: NEG
93665: PUSH
93666: EMPTY
93667: LIST
93668: LIST
93669: PUSH
93670: LD_INT 1
93672: PUSH
93673: LD_INT 2
93675: NEG
93676: PUSH
93677: EMPTY
93678: LIST
93679: LIST
93680: PUSH
93681: LD_INT 0
93683: PUSH
93684: LD_INT 2
93686: NEG
93687: PUSH
93688: EMPTY
93689: LIST
93690: LIST
93691: PUSH
93692: LD_INT 1
93694: NEG
93695: PUSH
93696: LD_INT 3
93698: NEG
93699: PUSH
93700: EMPTY
93701: LIST
93702: LIST
93703: PUSH
93704: LD_INT 1
93706: NEG
93707: PUSH
93708: LD_INT 4
93710: NEG
93711: PUSH
93712: EMPTY
93713: LIST
93714: LIST
93715: PUSH
93716: LD_INT 2
93718: PUSH
93719: LD_INT 2
93721: NEG
93722: PUSH
93723: EMPTY
93724: LIST
93725: LIST
93726: PUSH
93727: LD_INT 2
93729: NEG
93730: PUSH
93731: LD_INT 4
93733: NEG
93734: PUSH
93735: EMPTY
93736: LIST
93737: LIST
93738: PUSH
93739: LD_INT 4
93741: PUSH
93742: LD_INT 0
93744: PUSH
93745: EMPTY
93746: LIST
93747: LIST
93748: PUSH
93749: LD_INT 4
93751: PUSH
93752: LD_INT 1
93754: NEG
93755: PUSH
93756: EMPTY
93757: LIST
93758: LIST
93759: PUSH
93760: LD_INT 5
93762: PUSH
93763: LD_INT 0
93765: PUSH
93766: EMPTY
93767: LIST
93768: LIST
93769: PUSH
93770: LD_INT 5
93772: PUSH
93773: LD_INT 1
93775: PUSH
93776: EMPTY
93777: LIST
93778: LIST
93779: PUSH
93780: LD_INT 4
93782: PUSH
93783: LD_INT 1
93785: PUSH
93786: EMPTY
93787: LIST
93788: LIST
93789: PUSH
93790: LD_INT 3
93792: PUSH
93793: LD_INT 0
93795: PUSH
93796: EMPTY
93797: LIST
93798: LIST
93799: PUSH
93800: LD_INT 3
93802: PUSH
93803: LD_INT 1
93805: NEG
93806: PUSH
93807: EMPTY
93808: LIST
93809: LIST
93810: PUSH
93811: LD_INT 3
93813: PUSH
93814: LD_INT 2
93816: NEG
93817: PUSH
93818: EMPTY
93819: LIST
93820: LIST
93821: PUSH
93822: LD_INT 5
93824: PUSH
93825: LD_INT 2
93827: PUSH
93828: EMPTY
93829: LIST
93830: LIST
93831: PUSH
93832: LD_INT 3
93834: PUSH
93835: LD_INT 3
93837: PUSH
93838: EMPTY
93839: LIST
93840: LIST
93841: PUSH
93842: LD_INT 3
93844: PUSH
93845: LD_INT 2
93847: PUSH
93848: EMPTY
93849: LIST
93850: LIST
93851: PUSH
93852: LD_INT 4
93854: PUSH
93855: LD_INT 3
93857: PUSH
93858: EMPTY
93859: LIST
93860: LIST
93861: PUSH
93862: LD_INT 4
93864: PUSH
93865: LD_INT 4
93867: PUSH
93868: EMPTY
93869: LIST
93870: LIST
93871: PUSH
93872: LD_INT 3
93874: PUSH
93875: LD_INT 4
93877: PUSH
93878: EMPTY
93879: LIST
93880: LIST
93881: PUSH
93882: LD_INT 2
93884: PUSH
93885: LD_INT 3
93887: PUSH
93888: EMPTY
93889: LIST
93890: LIST
93891: PUSH
93892: LD_INT 2
93894: PUSH
93895: LD_INT 2
93897: PUSH
93898: EMPTY
93899: LIST
93900: LIST
93901: PUSH
93902: LD_INT 4
93904: PUSH
93905: LD_INT 2
93907: PUSH
93908: EMPTY
93909: LIST
93910: LIST
93911: PUSH
93912: LD_INT 2
93914: PUSH
93915: LD_INT 4
93917: PUSH
93918: EMPTY
93919: LIST
93920: LIST
93921: PUSH
93922: LD_INT 0
93924: PUSH
93925: LD_INT 4
93927: PUSH
93928: EMPTY
93929: LIST
93930: LIST
93931: PUSH
93932: LD_INT 0
93934: PUSH
93935: LD_INT 3
93937: PUSH
93938: EMPTY
93939: LIST
93940: LIST
93941: PUSH
93942: LD_INT 1
93944: PUSH
93945: LD_INT 4
93947: PUSH
93948: EMPTY
93949: LIST
93950: LIST
93951: PUSH
93952: LD_INT 1
93954: PUSH
93955: LD_INT 5
93957: PUSH
93958: EMPTY
93959: LIST
93960: LIST
93961: PUSH
93962: LD_INT 0
93964: PUSH
93965: LD_INT 5
93967: PUSH
93968: EMPTY
93969: LIST
93970: LIST
93971: PUSH
93972: LD_INT 1
93974: NEG
93975: PUSH
93976: LD_INT 4
93978: PUSH
93979: EMPTY
93980: LIST
93981: LIST
93982: PUSH
93983: LD_INT 1
93985: NEG
93986: PUSH
93987: LD_INT 3
93989: PUSH
93990: EMPTY
93991: LIST
93992: LIST
93993: PUSH
93994: LD_INT 2
93996: PUSH
93997: LD_INT 5
93999: PUSH
94000: EMPTY
94001: LIST
94002: LIST
94003: PUSH
94004: LD_INT 2
94006: NEG
94007: PUSH
94008: LD_INT 3
94010: PUSH
94011: EMPTY
94012: LIST
94013: LIST
94014: PUSH
94015: EMPTY
94016: LIST
94017: LIST
94018: LIST
94019: LIST
94020: LIST
94021: LIST
94022: LIST
94023: LIST
94024: LIST
94025: LIST
94026: LIST
94027: LIST
94028: LIST
94029: LIST
94030: LIST
94031: LIST
94032: LIST
94033: LIST
94034: LIST
94035: LIST
94036: LIST
94037: LIST
94038: LIST
94039: LIST
94040: LIST
94041: LIST
94042: LIST
94043: LIST
94044: LIST
94045: LIST
94046: LIST
94047: LIST
94048: LIST
94049: LIST
94050: LIST
94051: LIST
94052: LIST
94053: LIST
94054: LIST
94055: LIST
94056: LIST
94057: LIST
94058: LIST
94059: LIST
94060: LIST
94061: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
94062: LD_ADDR_VAR 0 34
94066: PUSH
94067: LD_INT 0
94069: PUSH
94070: LD_INT 4
94072: NEG
94073: PUSH
94074: EMPTY
94075: LIST
94076: LIST
94077: PUSH
94078: LD_INT 0
94080: PUSH
94081: LD_INT 5
94083: NEG
94084: PUSH
94085: EMPTY
94086: LIST
94087: LIST
94088: PUSH
94089: LD_INT 1
94091: PUSH
94092: LD_INT 4
94094: NEG
94095: PUSH
94096: EMPTY
94097: LIST
94098: LIST
94099: PUSH
94100: LD_INT 1
94102: PUSH
94103: LD_INT 3
94105: NEG
94106: PUSH
94107: EMPTY
94108: LIST
94109: LIST
94110: PUSH
94111: LD_INT 0
94113: PUSH
94114: LD_INT 3
94116: NEG
94117: PUSH
94118: EMPTY
94119: LIST
94120: LIST
94121: PUSH
94122: LD_INT 1
94124: NEG
94125: PUSH
94126: LD_INT 4
94128: NEG
94129: PUSH
94130: EMPTY
94131: LIST
94132: LIST
94133: PUSH
94134: LD_INT 1
94136: NEG
94137: PUSH
94138: LD_INT 5
94140: NEG
94141: PUSH
94142: EMPTY
94143: LIST
94144: LIST
94145: PUSH
94146: LD_INT 2
94148: PUSH
94149: LD_INT 3
94151: NEG
94152: PUSH
94153: EMPTY
94154: LIST
94155: LIST
94156: PUSH
94157: LD_INT 2
94159: NEG
94160: PUSH
94161: LD_INT 5
94163: NEG
94164: PUSH
94165: EMPTY
94166: LIST
94167: LIST
94168: PUSH
94169: LD_INT 3
94171: PUSH
94172: LD_INT 0
94174: PUSH
94175: EMPTY
94176: LIST
94177: LIST
94178: PUSH
94179: LD_INT 3
94181: PUSH
94182: LD_INT 1
94184: NEG
94185: PUSH
94186: EMPTY
94187: LIST
94188: LIST
94189: PUSH
94190: LD_INT 4
94192: PUSH
94193: LD_INT 0
94195: PUSH
94196: EMPTY
94197: LIST
94198: LIST
94199: PUSH
94200: LD_INT 4
94202: PUSH
94203: LD_INT 1
94205: PUSH
94206: EMPTY
94207: LIST
94208: LIST
94209: PUSH
94210: LD_INT 3
94212: PUSH
94213: LD_INT 1
94215: PUSH
94216: EMPTY
94217: LIST
94218: LIST
94219: PUSH
94220: LD_INT 2
94222: PUSH
94223: LD_INT 0
94225: PUSH
94226: EMPTY
94227: LIST
94228: LIST
94229: PUSH
94230: LD_INT 2
94232: PUSH
94233: LD_INT 1
94235: NEG
94236: PUSH
94237: EMPTY
94238: LIST
94239: LIST
94240: PUSH
94241: LD_INT 2
94243: PUSH
94244: LD_INT 2
94246: NEG
94247: PUSH
94248: EMPTY
94249: LIST
94250: LIST
94251: PUSH
94252: LD_INT 4
94254: PUSH
94255: LD_INT 2
94257: PUSH
94258: EMPTY
94259: LIST
94260: LIST
94261: PUSH
94262: LD_INT 4
94264: PUSH
94265: LD_INT 4
94267: PUSH
94268: EMPTY
94269: LIST
94270: LIST
94271: PUSH
94272: LD_INT 4
94274: PUSH
94275: LD_INT 3
94277: PUSH
94278: EMPTY
94279: LIST
94280: LIST
94281: PUSH
94282: LD_INT 5
94284: PUSH
94285: LD_INT 4
94287: PUSH
94288: EMPTY
94289: LIST
94290: LIST
94291: PUSH
94292: LD_INT 5
94294: PUSH
94295: LD_INT 5
94297: PUSH
94298: EMPTY
94299: LIST
94300: LIST
94301: PUSH
94302: LD_INT 4
94304: PUSH
94305: LD_INT 5
94307: PUSH
94308: EMPTY
94309: LIST
94310: LIST
94311: PUSH
94312: LD_INT 3
94314: PUSH
94315: LD_INT 4
94317: PUSH
94318: EMPTY
94319: LIST
94320: LIST
94321: PUSH
94322: LD_INT 3
94324: PUSH
94325: LD_INT 3
94327: PUSH
94328: EMPTY
94329: LIST
94330: LIST
94331: PUSH
94332: LD_INT 5
94334: PUSH
94335: LD_INT 3
94337: PUSH
94338: EMPTY
94339: LIST
94340: LIST
94341: PUSH
94342: LD_INT 3
94344: PUSH
94345: LD_INT 5
94347: PUSH
94348: EMPTY
94349: LIST
94350: LIST
94351: PUSH
94352: LD_INT 0
94354: PUSH
94355: LD_INT 3
94357: PUSH
94358: EMPTY
94359: LIST
94360: LIST
94361: PUSH
94362: LD_INT 0
94364: PUSH
94365: LD_INT 2
94367: PUSH
94368: EMPTY
94369: LIST
94370: LIST
94371: PUSH
94372: LD_INT 1
94374: PUSH
94375: LD_INT 3
94377: PUSH
94378: EMPTY
94379: LIST
94380: LIST
94381: PUSH
94382: LD_INT 1
94384: PUSH
94385: LD_INT 4
94387: PUSH
94388: EMPTY
94389: LIST
94390: LIST
94391: PUSH
94392: LD_INT 0
94394: PUSH
94395: LD_INT 4
94397: PUSH
94398: EMPTY
94399: LIST
94400: LIST
94401: PUSH
94402: LD_INT 1
94404: NEG
94405: PUSH
94406: LD_INT 3
94408: PUSH
94409: EMPTY
94410: LIST
94411: LIST
94412: PUSH
94413: LD_INT 1
94415: NEG
94416: PUSH
94417: LD_INT 2
94419: PUSH
94420: EMPTY
94421: LIST
94422: LIST
94423: PUSH
94424: LD_INT 2
94426: PUSH
94427: LD_INT 4
94429: PUSH
94430: EMPTY
94431: LIST
94432: LIST
94433: PUSH
94434: LD_INT 2
94436: NEG
94437: PUSH
94438: LD_INT 2
94440: PUSH
94441: EMPTY
94442: LIST
94443: LIST
94444: PUSH
94445: LD_INT 4
94447: NEG
94448: PUSH
94449: LD_INT 0
94451: PUSH
94452: EMPTY
94453: LIST
94454: LIST
94455: PUSH
94456: LD_INT 4
94458: NEG
94459: PUSH
94460: LD_INT 1
94462: NEG
94463: PUSH
94464: EMPTY
94465: LIST
94466: LIST
94467: PUSH
94468: LD_INT 3
94470: NEG
94471: PUSH
94472: LD_INT 0
94474: PUSH
94475: EMPTY
94476: LIST
94477: LIST
94478: PUSH
94479: LD_INT 3
94481: NEG
94482: PUSH
94483: LD_INT 1
94485: PUSH
94486: EMPTY
94487: LIST
94488: LIST
94489: PUSH
94490: LD_INT 4
94492: NEG
94493: PUSH
94494: LD_INT 1
94496: PUSH
94497: EMPTY
94498: LIST
94499: LIST
94500: PUSH
94501: LD_INT 5
94503: NEG
94504: PUSH
94505: LD_INT 0
94507: PUSH
94508: EMPTY
94509: LIST
94510: LIST
94511: PUSH
94512: LD_INT 5
94514: NEG
94515: PUSH
94516: LD_INT 1
94518: NEG
94519: PUSH
94520: EMPTY
94521: LIST
94522: LIST
94523: PUSH
94524: LD_INT 5
94526: NEG
94527: PUSH
94528: LD_INT 2
94530: NEG
94531: PUSH
94532: EMPTY
94533: LIST
94534: LIST
94535: PUSH
94536: LD_INT 3
94538: NEG
94539: PUSH
94540: LD_INT 2
94542: PUSH
94543: EMPTY
94544: LIST
94545: LIST
94546: PUSH
94547: EMPTY
94548: LIST
94549: LIST
94550: LIST
94551: LIST
94552: LIST
94553: LIST
94554: LIST
94555: LIST
94556: LIST
94557: LIST
94558: LIST
94559: LIST
94560: LIST
94561: LIST
94562: LIST
94563: LIST
94564: LIST
94565: LIST
94566: LIST
94567: LIST
94568: LIST
94569: LIST
94570: LIST
94571: LIST
94572: LIST
94573: LIST
94574: LIST
94575: LIST
94576: LIST
94577: LIST
94578: LIST
94579: LIST
94580: LIST
94581: LIST
94582: LIST
94583: LIST
94584: LIST
94585: LIST
94586: LIST
94587: LIST
94588: LIST
94589: LIST
94590: LIST
94591: LIST
94592: LIST
94593: ST_TO_ADDR
// end ; end ;
94594: GO 94597
94596: POP
// case btype of b_depot , b_warehouse :
94597: LD_VAR 0 1
94601: PUSH
94602: LD_INT 0
94604: DOUBLE
94605: EQUAL
94606: IFTRUE 94616
94608: LD_INT 1
94610: DOUBLE
94611: EQUAL
94612: IFTRUE 94616
94614: GO 94817
94616: POP
// case nation of nation_american :
94617: LD_VAR 0 5
94621: PUSH
94622: LD_INT 1
94624: DOUBLE
94625: EQUAL
94626: IFTRUE 94630
94628: GO 94686
94630: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
94631: LD_ADDR_VAR 0 9
94635: PUSH
94636: LD_VAR 0 11
94640: PUSH
94641: LD_VAR 0 12
94645: PUSH
94646: LD_VAR 0 13
94650: PUSH
94651: LD_VAR 0 14
94655: PUSH
94656: LD_VAR 0 15
94660: PUSH
94661: LD_VAR 0 16
94665: PUSH
94666: EMPTY
94667: LIST
94668: LIST
94669: LIST
94670: LIST
94671: LIST
94672: LIST
94673: PUSH
94674: LD_VAR 0 4
94678: PUSH
94679: LD_INT 1
94681: PLUS
94682: ARRAY
94683: ST_TO_ADDR
94684: GO 94815
94686: LD_INT 2
94688: DOUBLE
94689: EQUAL
94690: IFTRUE 94694
94692: GO 94750
94694: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
94695: LD_ADDR_VAR 0 9
94699: PUSH
94700: LD_VAR 0 17
94704: PUSH
94705: LD_VAR 0 18
94709: PUSH
94710: LD_VAR 0 19
94714: PUSH
94715: LD_VAR 0 20
94719: PUSH
94720: LD_VAR 0 21
94724: PUSH
94725: LD_VAR 0 22
94729: PUSH
94730: EMPTY
94731: LIST
94732: LIST
94733: LIST
94734: LIST
94735: LIST
94736: LIST
94737: PUSH
94738: LD_VAR 0 4
94742: PUSH
94743: LD_INT 1
94745: PLUS
94746: ARRAY
94747: ST_TO_ADDR
94748: GO 94815
94750: LD_INT 3
94752: DOUBLE
94753: EQUAL
94754: IFTRUE 94758
94756: GO 94814
94758: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
94759: LD_ADDR_VAR 0 9
94763: PUSH
94764: LD_VAR 0 23
94768: PUSH
94769: LD_VAR 0 24
94773: PUSH
94774: LD_VAR 0 25
94778: PUSH
94779: LD_VAR 0 26
94783: PUSH
94784: LD_VAR 0 27
94788: PUSH
94789: LD_VAR 0 28
94793: PUSH
94794: EMPTY
94795: LIST
94796: LIST
94797: LIST
94798: LIST
94799: LIST
94800: LIST
94801: PUSH
94802: LD_VAR 0 4
94806: PUSH
94807: LD_INT 1
94809: PLUS
94810: ARRAY
94811: ST_TO_ADDR
94812: GO 94815
94814: POP
94815: GO 95364
94817: LD_INT 2
94819: DOUBLE
94820: EQUAL
94821: IFTRUE 94831
94823: LD_INT 3
94825: DOUBLE
94826: EQUAL
94827: IFTRUE 94831
94829: GO 94887
94831: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
94832: LD_ADDR_VAR 0 9
94836: PUSH
94837: LD_VAR 0 29
94841: PUSH
94842: LD_VAR 0 30
94846: PUSH
94847: LD_VAR 0 31
94851: PUSH
94852: LD_VAR 0 32
94856: PUSH
94857: LD_VAR 0 33
94861: PUSH
94862: LD_VAR 0 34
94866: PUSH
94867: EMPTY
94868: LIST
94869: LIST
94870: LIST
94871: LIST
94872: LIST
94873: LIST
94874: PUSH
94875: LD_VAR 0 4
94879: PUSH
94880: LD_INT 1
94882: PLUS
94883: ARRAY
94884: ST_TO_ADDR
94885: GO 95364
94887: LD_INT 16
94889: DOUBLE
94890: EQUAL
94891: IFTRUE 94943
94893: LD_INT 17
94895: DOUBLE
94896: EQUAL
94897: IFTRUE 94943
94899: LD_INT 18
94901: DOUBLE
94902: EQUAL
94903: IFTRUE 94943
94905: LD_INT 19
94907: DOUBLE
94908: EQUAL
94909: IFTRUE 94943
94911: LD_INT 20
94913: DOUBLE
94914: EQUAL
94915: IFTRUE 94943
94917: LD_INT 21
94919: DOUBLE
94920: EQUAL
94921: IFTRUE 94943
94923: LD_INT 23
94925: DOUBLE
94926: EQUAL
94927: IFTRUE 94943
94929: LD_INT 24
94931: DOUBLE
94932: EQUAL
94933: IFTRUE 94943
94935: LD_INT 25
94937: DOUBLE
94938: EQUAL
94939: IFTRUE 94943
94941: GO 94999
94943: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
94944: LD_ADDR_VAR 0 9
94948: PUSH
94949: LD_VAR 0 35
94953: PUSH
94954: LD_VAR 0 36
94958: PUSH
94959: LD_VAR 0 37
94963: PUSH
94964: LD_VAR 0 38
94968: PUSH
94969: LD_VAR 0 39
94973: PUSH
94974: LD_VAR 0 40
94978: PUSH
94979: EMPTY
94980: LIST
94981: LIST
94982: LIST
94983: LIST
94984: LIST
94985: LIST
94986: PUSH
94987: LD_VAR 0 4
94991: PUSH
94992: LD_INT 1
94994: PLUS
94995: ARRAY
94996: ST_TO_ADDR
94997: GO 95364
94999: LD_INT 6
95001: DOUBLE
95002: EQUAL
95003: IFTRUE 95055
95005: LD_INT 7
95007: DOUBLE
95008: EQUAL
95009: IFTRUE 95055
95011: LD_INT 8
95013: DOUBLE
95014: EQUAL
95015: IFTRUE 95055
95017: LD_INT 13
95019: DOUBLE
95020: EQUAL
95021: IFTRUE 95055
95023: LD_INT 12
95025: DOUBLE
95026: EQUAL
95027: IFTRUE 95055
95029: LD_INT 15
95031: DOUBLE
95032: EQUAL
95033: IFTRUE 95055
95035: LD_INT 11
95037: DOUBLE
95038: EQUAL
95039: IFTRUE 95055
95041: LD_INT 14
95043: DOUBLE
95044: EQUAL
95045: IFTRUE 95055
95047: LD_INT 10
95049: DOUBLE
95050: EQUAL
95051: IFTRUE 95055
95053: GO 95111
95055: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
95056: LD_ADDR_VAR 0 9
95060: PUSH
95061: LD_VAR 0 41
95065: PUSH
95066: LD_VAR 0 42
95070: PUSH
95071: LD_VAR 0 43
95075: PUSH
95076: LD_VAR 0 44
95080: PUSH
95081: LD_VAR 0 45
95085: PUSH
95086: LD_VAR 0 46
95090: PUSH
95091: EMPTY
95092: LIST
95093: LIST
95094: LIST
95095: LIST
95096: LIST
95097: LIST
95098: PUSH
95099: LD_VAR 0 4
95103: PUSH
95104: LD_INT 1
95106: PLUS
95107: ARRAY
95108: ST_TO_ADDR
95109: GO 95364
95111: LD_INT 36
95113: DOUBLE
95114: EQUAL
95115: IFTRUE 95119
95117: GO 95175
95119: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
95120: LD_ADDR_VAR 0 9
95124: PUSH
95125: LD_VAR 0 47
95129: PUSH
95130: LD_VAR 0 48
95134: PUSH
95135: LD_VAR 0 49
95139: PUSH
95140: LD_VAR 0 50
95144: PUSH
95145: LD_VAR 0 51
95149: PUSH
95150: LD_VAR 0 52
95154: PUSH
95155: EMPTY
95156: LIST
95157: LIST
95158: LIST
95159: LIST
95160: LIST
95161: LIST
95162: PUSH
95163: LD_VAR 0 4
95167: PUSH
95168: LD_INT 1
95170: PLUS
95171: ARRAY
95172: ST_TO_ADDR
95173: GO 95364
95175: LD_INT 4
95177: DOUBLE
95178: EQUAL
95179: IFTRUE 95201
95181: LD_INT 5
95183: DOUBLE
95184: EQUAL
95185: IFTRUE 95201
95187: LD_INT 34
95189: DOUBLE
95190: EQUAL
95191: IFTRUE 95201
95193: LD_INT 37
95195: DOUBLE
95196: EQUAL
95197: IFTRUE 95201
95199: GO 95257
95201: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
95202: LD_ADDR_VAR 0 9
95206: PUSH
95207: LD_VAR 0 53
95211: PUSH
95212: LD_VAR 0 54
95216: PUSH
95217: LD_VAR 0 55
95221: PUSH
95222: LD_VAR 0 56
95226: PUSH
95227: LD_VAR 0 57
95231: PUSH
95232: LD_VAR 0 58
95236: PUSH
95237: EMPTY
95238: LIST
95239: LIST
95240: LIST
95241: LIST
95242: LIST
95243: LIST
95244: PUSH
95245: LD_VAR 0 4
95249: PUSH
95250: LD_INT 1
95252: PLUS
95253: ARRAY
95254: ST_TO_ADDR
95255: GO 95364
95257: LD_INT 31
95259: DOUBLE
95260: EQUAL
95261: IFTRUE 95307
95263: LD_INT 32
95265: DOUBLE
95266: EQUAL
95267: IFTRUE 95307
95269: LD_INT 33
95271: DOUBLE
95272: EQUAL
95273: IFTRUE 95307
95275: LD_INT 27
95277: DOUBLE
95278: EQUAL
95279: IFTRUE 95307
95281: LD_INT 26
95283: DOUBLE
95284: EQUAL
95285: IFTRUE 95307
95287: LD_INT 28
95289: DOUBLE
95290: EQUAL
95291: IFTRUE 95307
95293: LD_INT 29
95295: DOUBLE
95296: EQUAL
95297: IFTRUE 95307
95299: LD_INT 30
95301: DOUBLE
95302: EQUAL
95303: IFTRUE 95307
95305: GO 95363
95307: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
95308: LD_ADDR_VAR 0 9
95312: PUSH
95313: LD_VAR 0 59
95317: PUSH
95318: LD_VAR 0 60
95322: PUSH
95323: LD_VAR 0 61
95327: PUSH
95328: LD_VAR 0 62
95332: PUSH
95333: LD_VAR 0 63
95337: PUSH
95338: LD_VAR 0 64
95342: PUSH
95343: EMPTY
95344: LIST
95345: LIST
95346: LIST
95347: LIST
95348: LIST
95349: LIST
95350: PUSH
95351: LD_VAR 0 4
95355: PUSH
95356: LD_INT 1
95358: PLUS
95359: ARRAY
95360: ST_TO_ADDR
95361: GO 95364
95363: POP
// temp_list2 = [ ] ;
95364: LD_ADDR_VAR 0 10
95368: PUSH
95369: EMPTY
95370: ST_TO_ADDR
// for i in temp_list do
95371: LD_ADDR_VAR 0 8
95375: PUSH
95376: LD_VAR 0 9
95380: PUSH
95381: FOR_IN
95382: IFFALSE 95434
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
95384: LD_ADDR_VAR 0 10
95388: PUSH
95389: LD_VAR 0 10
95393: PUSH
95394: LD_VAR 0 8
95398: PUSH
95399: LD_INT 1
95401: ARRAY
95402: PUSH
95403: LD_VAR 0 2
95407: PLUS
95408: PUSH
95409: LD_VAR 0 8
95413: PUSH
95414: LD_INT 2
95416: ARRAY
95417: PUSH
95418: LD_VAR 0 3
95422: PLUS
95423: PUSH
95424: EMPTY
95425: LIST
95426: LIST
95427: PUSH
95428: EMPTY
95429: LIST
95430: ADD
95431: ST_TO_ADDR
95432: GO 95381
95434: POP
95435: POP
// result = temp_list2 ;
95436: LD_ADDR_VAR 0 7
95440: PUSH
95441: LD_VAR 0 10
95445: ST_TO_ADDR
// end ;
95446: LD_VAR 0 7
95450: RET
// export function EnemyInRange ( unit , dist ) ; begin
95451: LD_INT 0
95453: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
95454: LD_ADDR_VAR 0 3
95458: PUSH
95459: LD_VAR 0 1
95463: PPUSH
95464: CALL_OW 255
95468: PPUSH
95469: LD_VAR 0 1
95473: PPUSH
95474: CALL_OW 250
95478: PPUSH
95479: LD_VAR 0 1
95483: PPUSH
95484: CALL_OW 251
95488: PPUSH
95489: LD_VAR 0 2
95493: PPUSH
95494: CALL 69579 0 4
95498: PUSH
95499: LD_INT 4
95501: ARRAY
95502: ST_TO_ADDR
// end ;
95503: LD_VAR 0 3
95507: RET
// export function PlayerSeeMe ( unit ) ; begin
95508: LD_INT 0
95510: PPUSH
// result := See ( your_side , unit ) ;
95511: LD_ADDR_VAR 0 2
95515: PUSH
95516: LD_OWVAR 2
95520: PPUSH
95521: LD_VAR 0 1
95525: PPUSH
95526: CALL_OW 292
95530: ST_TO_ADDR
// end ;
95531: LD_VAR 0 2
95535: RET
// export function ReverseDir ( unit ) ; begin
95536: LD_INT 0
95538: PPUSH
// if not unit then
95539: LD_VAR 0 1
95543: NOT
95544: IFFALSE 95548
// exit ;
95546: GO 95594
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
95548: LD_ADDR_VAR 0 2
95552: PUSH
95553: LD_INT 3
95555: PUSH
95556: LD_INT 4
95558: PUSH
95559: LD_INT 5
95561: PUSH
95562: LD_INT 0
95564: PUSH
95565: LD_INT 1
95567: PUSH
95568: LD_INT 2
95570: PUSH
95571: EMPTY
95572: LIST
95573: LIST
95574: LIST
95575: LIST
95576: LIST
95577: LIST
95578: PUSH
95579: LD_VAR 0 1
95583: PPUSH
95584: CALL_OW 254
95588: PUSH
95589: LD_INT 1
95591: PLUS
95592: ARRAY
95593: ST_TO_ADDR
// end ;
95594: LD_VAR 0 2
95598: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
95599: LD_INT 0
95601: PPUSH
95602: PPUSH
95603: PPUSH
95604: PPUSH
95605: PPUSH
// if not hexes then
95606: LD_VAR 0 2
95610: NOT
95611: IFFALSE 95615
// exit ;
95613: GO 95763
// dist := 9999 ;
95615: LD_ADDR_VAR 0 5
95619: PUSH
95620: LD_INT 9999
95622: ST_TO_ADDR
// for i = 1 to hexes do
95623: LD_ADDR_VAR 0 4
95627: PUSH
95628: DOUBLE
95629: LD_INT 1
95631: DEC
95632: ST_TO_ADDR
95633: LD_VAR 0 2
95637: PUSH
95638: FOR_TO
95639: IFFALSE 95751
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
95641: LD_VAR 0 1
95645: PPUSH
95646: LD_VAR 0 2
95650: PUSH
95651: LD_VAR 0 4
95655: ARRAY
95656: PUSH
95657: LD_INT 1
95659: ARRAY
95660: PPUSH
95661: LD_VAR 0 2
95665: PUSH
95666: LD_VAR 0 4
95670: ARRAY
95671: PUSH
95672: LD_INT 2
95674: ARRAY
95675: PPUSH
95676: CALL_OW 297
95680: PUSH
95681: LD_VAR 0 5
95685: LESS
95686: IFFALSE 95749
// begin hex := hexes [ i ] ;
95688: LD_ADDR_VAR 0 7
95692: PUSH
95693: LD_VAR 0 2
95697: PUSH
95698: LD_VAR 0 4
95702: ARRAY
95703: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
95704: LD_ADDR_VAR 0 5
95708: PUSH
95709: LD_VAR 0 1
95713: PPUSH
95714: LD_VAR 0 2
95718: PUSH
95719: LD_VAR 0 4
95723: ARRAY
95724: PUSH
95725: LD_INT 1
95727: ARRAY
95728: PPUSH
95729: LD_VAR 0 2
95733: PUSH
95734: LD_VAR 0 4
95738: ARRAY
95739: PUSH
95740: LD_INT 2
95742: ARRAY
95743: PPUSH
95744: CALL_OW 297
95748: ST_TO_ADDR
// end ; end ;
95749: GO 95638
95751: POP
95752: POP
// result := hex ;
95753: LD_ADDR_VAR 0 3
95757: PUSH
95758: LD_VAR 0 7
95762: ST_TO_ADDR
// end ;
95763: LD_VAR 0 3
95767: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
95768: LD_INT 0
95770: PPUSH
95771: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
95772: LD_VAR 0 1
95776: NOT
95777: PUSH
95778: LD_VAR 0 1
95782: PUSH
95783: LD_INT 21
95785: PUSH
95786: LD_INT 2
95788: PUSH
95789: EMPTY
95790: LIST
95791: LIST
95792: PUSH
95793: LD_INT 23
95795: PUSH
95796: LD_INT 2
95798: PUSH
95799: EMPTY
95800: LIST
95801: LIST
95802: PUSH
95803: EMPTY
95804: LIST
95805: LIST
95806: PPUSH
95807: CALL_OW 69
95811: IN
95812: NOT
95813: OR
95814: IFFALSE 95818
// exit ;
95816: GO 95865
// for i = 1 to 3 do
95818: LD_ADDR_VAR 0 3
95822: PUSH
95823: DOUBLE
95824: LD_INT 1
95826: DEC
95827: ST_TO_ADDR
95828: LD_INT 3
95830: PUSH
95831: FOR_TO
95832: IFFALSE 95863
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
95834: LD_VAR 0 1
95838: PPUSH
95839: CALL_OW 250
95843: PPUSH
95844: LD_VAR 0 1
95848: PPUSH
95849: CALL_OW 251
95853: PPUSH
95854: LD_INT 1
95856: PPUSH
95857: CALL_OW 453
95861: GO 95831
95863: POP
95864: POP
// end ;
95865: LD_VAR 0 2
95869: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
95870: LD_INT 0
95872: PPUSH
95873: PPUSH
95874: PPUSH
95875: PPUSH
95876: PPUSH
95877: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
95878: LD_VAR 0 1
95882: NOT
95883: PUSH
95884: LD_VAR 0 2
95888: NOT
95889: OR
95890: PUSH
95891: LD_VAR 0 1
95895: PPUSH
95896: CALL_OW 314
95900: OR
95901: IFFALSE 95905
// exit ;
95903: GO 96346
// x := GetX ( enemy_unit ) ;
95905: LD_ADDR_VAR 0 7
95909: PUSH
95910: LD_VAR 0 2
95914: PPUSH
95915: CALL_OW 250
95919: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
95920: LD_ADDR_VAR 0 8
95924: PUSH
95925: LD_VAR 0 2
95929: PPUSH
95930: CALL_OW 251
95934: ST_TO_ADDR
// if not x or not y then
95935: LD_VAR 0 7
95939: NOT
95940: PUSH
95941: LD_VAR 0 8
95945: NOT
95946: OR
95947: IFFALSE 95951
// exit ;
95949: GO 96346
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
95951: LD_ADDR_VAR 0 6
95955: PUSH
95956: LD_VAR 0 7
95960: PPUSH
95961: LD_INT 0
95963: PPUSH
95964: LD_INT 4
95966: PPUSH
95967: CALL_OW 272
95971: PUSH
95972: LD_VAR 0 8
95976: PPUSH
95977: LD_INT 0
95979: PPUSH
95980: LD_INT 4
95982: PPUSH
95983: CALL_OW 273
95987: PUSH
95988: EMPTY
95989: LIST
95990: LIST
95991: PUSH
95992: LD_VAR 0 7
95996: PPUSH
95997: LD_INT 1
95999: PPUSH
96000: LD_INT 4
96002: PPUSH
96003: CALL_OW 272
96007: PUSH
96008: LD_VAR 0 8
96012: PPUSH
96013: LD_INT 1
96015: PPUSH
96016: LD_INT 4
96018: PPUSH
96019: CALL_OW 273
96023: PUSH
96024: EMPTY
96025: LIST
96026: LIST
96027: PUSH
96028: LD_VAR 0 7
96032: PPUSH
96033: LD_INT 2
96035: PPUSH
96036: LD_INT 4
96038: PPUSH
96039: CALL_OW 272
96043: PUSH
96044: LD_VAR 0 8
96048: PPUSH
96049: LD_INT 2
96051: PPUSH
96052: LD_INT 4
96054: PPUSH
96055: CALL_OW 273
96059: PUSH
96060: EMPTY
96061: LIST
96062: LIST
96063: PUSH
96064: LD_VAR 0 7
96068: PPUSH
96069: LD_INT 3
96071: PPUSH
96072: LD_INT 4
96074: PPUSH
96075: CALL_OW 272
96079: PUSH
96080: LD_VAR 0 8
96084: PPUSH
96085: LD_INT 3
96087: PPUSH
96088: LD_INT 4
96090: PPUSH
96091: CALL_OW 273
96095: PUSH
96096: EMPTY
96097: LIST
96098: LIST
96099: PUSH
96100: LD_VAR 0 7
96104: PPUSH
96105: LD_INT 4
96107: PPUSH
96108: LD_INT 4
96110: PPUSH
96111: CALL_OW 272
96115: PUSH
96116: LD_VAR 0 8
96120: PPUSH
96121: LD_INT 4
96123: PPUSH
96124: LD_INT 4
96126: PPUSH
96127: CALL_OW 273
96131: PUSH
96132: EMPTY
96133: LIST
96134: LIST
96135: PUSH
96136: LD_VAR 0 7
96140: PPUSH
96141: LD_INT 5
96143: PPUSH
96144: LD_INT 4
96146: PPUSH
96147: CALL_OW 272
96151: PUSH
96152: LD_VAR 0 8
96156: PPUSH
96157: LD_INT 5
96159: PPUSH
96160: LD_INT 4
96162: PPUSH
96163: CALL_OW 273
96167: PUSH
96168: EMPTY
96169: LIST
96170: LIST
96171: PUSH
96172: EMPTY
96173: LIST
96174: LIST
96175: LIST
96176: LIST
96177: LIST
96178: LIST
96179: ST_TO_ADDR
// for i = tmp downto 1 do
96180: LD_ADDR_VAR 0 4
96184: PUSH
96185: DOUBLE
96186: LD_VAR 0 6
96190: INC
96191: ST_TO_ADDR
96192: LD_INT 1
96194: PUSH
96195: FOR_DOWNTO
96196: IFFALSE 96297
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
96198: LD_VAR 0 6
96202: PUSH
96203: LD_VAR 0 4
96207: ARRAY
96208: PUSH
96209: LD_INT 1
96211: ARRAY
96212: PPUSH
96213: LD_VAR 0 6
96217: PUSH
96218: LD_VAR 0 4
96222: ARRAY
96223: PUSH
96224: LD_INT 2
96226: ARRAY
96227: PPUSH
96228: CALL_OW 488
96232: NOT
96233: PUSH
96234: LD_VAR 0 6
96238: PUSH
96239: LD_VAR 0 4
96243: ARRAY
96244: PUSH
96245: LD_INT 1
96247: ARRAY
96248: PPUSH
96249: LD_VAR 0 6
96253: PUSH
96254: LD_VAR 0 4
96258: ARRAY
96259: PUSH
96260: LD_INT 2
96262: ARRAY
96263: PPUSH
96264: CALL_OW 428
96268: PUSH
96269: LD_INT 0
96271: NONEQUAL
96272: OR
96273: IFFALSE 96295
// tmp := Delete ( tmp , i ) ;
96275: LD_ADDR_VAR 0 6
96279: PUSH
96280: LD_VAR 0 6
96284: PPUSH
96285: LD_VAR 0 4
96289: PPUSH
96290: CALL_OW 3
96294: ST_TO_ADDR
96295: GO 96195
96297: POP
96298: POP
// j := GetClosestHex ( unit , tmp ) ;
96299: LD_ADDR_VAR 0 5
96303: PUSH
96304: LD_VAR 0 1
96308: PPUSH
96309: LD_VAR 0 6
96313: PPUSH
96314: CALL 95599 0 2
96318: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
96319: LD_VAR 0 1
96323: PPUSH
96324: LD_VAR 0 5
96328: PUSH
96329: LD_INT 1
96331: ARRAY
96332: PPUSH
96333: LD_VAR 0 5
96337: PUSH
96338: LD_INT 2
96340: ARRAY
96341: PPUSH
96342: CALL_OW 111
// end ;
96346: LD_VAR 0 3
96350: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
96351: LD_INT 0
96353: PPUSH
96354: PPUSH
96355: PPUSH
// uc_side = 0 ;
96356: LD_ADDR_OWVAR 20
96360: PUSH
96361: LD_INT 0
96363: ST_TO_ADDR
// uc_nation = 0 ;
96364: LD_ADDR_OWVAR 21
96368: PUSH
96369: LD_INT 0
96371: ST_TO_ADDR
// InitHc ;
96372: CALL_OW 19
// InitVc ;
96376: CALL_OW 20
// if mastodonts then
96380: LD_VAR 0 6
96384: IFFALSE 96451
// for i = 1 to mastodonts do
96386: LD_ADDR_VAR 0 11
96390: PUSH
96391: DOUBLE
96392: LD_INT 1
96394: DEC
96395: ST_TO_ADDR
96396: LD_VAR 0 6
96400: PUSH
96401: FOR_TO
96402: IFFALSE 96449
// begin vc_chassis := 31 ;
96404: LD_ADDR_OWVAR 37
96408: PUSH
96409: LD_INT 31
96411: ST_TO_ADDR
// vc_control := control_rider ;
96412: LD_ADDR_OWVAR 38
96416: PUSH
96417: LD_INT 4
96419: ST_TO_ADDR
// animal := CreateVehicle ;
96420: LD_ADDR_VAR 0 12
96424: PUSH
96425: CALL_OW 45
96429: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96430: LD_VAR 0 12
96434: PPUSH
96435: LD_VAR 0 8
96439: PPUSH
96440: LD_INT 0
96442: PPUSH
96443: CALL 103157 0 3
// end ;
96447: GO 96401
96449: POP
96450: POP
// if horses then
96451: LD_VAR 0 5
96455: IFFALSE 96522
// for i = 1 to horses do
96457: LD_ADDR_VAR 0 11
96461: PUSH
96462: DOUBLE
96463: LD_INT 1
96465: DEC
96466: ST_TO_ADDR
96467: LD_VAR 0 5
96471: PUSH
96472: FOR_TO
96473: IFFALSE 96520
// begin hc_class := 21 ;
96475: LD_ADDR_OWVAR 28
96479: PUSH
96480: LD_INT 21
96482: ST_TO_ADDR
// hc_gallery :=  ;
96483: LD_ADDR_OWVAR 33
96487: PUSH
96488: LD_STRING 
96490: ST_TO_ADDR
// animal := CreateHuman ;
96491: LD_ADDR_VAR 0 12
96495: PUSH
96496: CALL_OW 44
96500: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96501: LD_VAR 0 12
96505: PPUSH
96506: LD_VAR 0 8
96510: PPUSH
96511: LD_INT 0
96513: PPUSH
96514: CALL 103157 0 3
// end ;
96518: GO 96472
96520: POP
96521: POP
// if birds then
96522: LD_VAR 0 1
96526: IFFALSE 96593
// for i = 1 to birds do
96528: LD_ADDR_VAR 0 11
96532: PUSH
96533: DOUBLE
96534: LD_INT 1
96536: DEC
96537: ST_TO_ADDR
96538: LD_VAR 0 1
96542: PUSH
96543: FOR_TO
96544: IFFALSE 96591
// begin hc_class = 18 ;
96546: LD_ADDR_OWVAR 28
96550: PUSH
96551: LD_INT 18
96553: ST_TO_ADDR
// hc_gallery =  ;
96554: LD_ADDR_OWVAR 33
96558: PUSH
96559: LD_STRING 
96561: ST_TO_ADDR
// animal := CreateHuman ;
96562: LD_ADDR_VAR 0 12
96566: PUSH
96567: CALL_OW 44
96571: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96572: LD_VAR 0 12
96576: PPUSH
96577: LD_VAR 0 8
96581: PPUSH
96582: LD_INT 0
96584: PPUSH
96585: CALL 103157 0 3
// end ;
96589: GO 96543
96591: POP
96592: POP
// if tigers then
96593: LD_VAR 0 2
96597: IFFALSE 96681
// for i = 1 to tigers do
96599: LD_ADDR_VAR 0 11
96603: PUSH
96604: DOUBLE
96605: LD_INT 1
96607: DEC
96608: ST_TO_ADDR
96609: LD_VAR 0 2
96613: PUSH
96614: FOR_TO
96615: IFFALSE 96679
// begin hc_class = class_tiger ;
96617: LD_ADDR_OWVAR 28
96621: PUSH
96622: LD_INT 14
96624: ST_TO_ADDR
// hc_gallery =  ;
96625: LD_ADDR_OWVAR 33
96629: PUSH
96630: LD_STRING 
96632: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
96633: LD_ADDR_OWVAR 35
96637: PUSH
96638: LD_INT 7
96640: NEG
96641: PPUSH
96642: LD_INT 7
96644: PPUSH
96645: CALL_OW 12
96649: ST_TO_ADDR
// animal := CreateHuman ;
96650: LD_ADDR_VAR 0 12
96654: PUSH
96655: CALL_OW 44
96659: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96660: LD_VAR 0 12
96664: PPUSH
96665: LD_VAR 0 8
96669: PPUSH
96670: LD_INT 0
96672: PPUSH
96673: CALL 103157 0 3
// end ;
96677: GO 96614
96679: POP
96680: POP
// if apemans then
96681: LD_VAR 0 3
96685: IFFALSE 96808
// for i = 1 to apemans do
96687: LD_ADDR_VAR 0 11
96691: PUSH
96692: DOUBLE
96693: LD_INT 1
96695: DEC
96696: ST_TO_ADDR
96697: LD_VAR 0 3
96701: PUSH
96702: FOR_TO
96703: IFFALSE 96806
// begin hc_class = class_apeman ;
96705: LD_ADDR_OWVAR 28
96709: PUSH
96710: LD_INT 12
96712: ST_TO_ADDR
// hc_gallery =  ;
96713: LD_ADDR_OWVAR 33
96717: PUSH
96718: LD_STRING 
96720: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
96721: LD_ADDR_OWVAR 35
96725: PUSH
96726: LD_INT 5
96728: NEG
96729: PPUSH
96730: LD_INT 5
96732: PPUSH
96733: CALL_OW 12
96737: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
96738: LD_ADDR_OWVAR 31
96742: PUSH
96743: LD_INT 1
96745: PPUSH
96746: LD_INT 3
96748: PPUSH
96749: CALL_OW 12
96753: PUSH
96754: LD_INT 1
96756: PPUSH
96757: LD_INT 3
96759: PPUSH
96760: CALL_OW 12
96764: PUSH
96765: LD_INT 0
96767: PUSH
96768: LD_INT 0
96770: PUSH
96771: EMPTY
96772: LIST
96773: LIST
96774: LIST
96775: LIST
96776: ST_TO_ADDR
// animal := CreateHuman ;
96777: LD_ADDR_VAR 0 12
96781: PUSH
96782: CALL_OW 44
96786: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96787: LD_VAR 0 12
96791: PPUSH
96792: LD_VAR 0 8
96796: PPUSH
96797: LD_INT 0
96799: PPUSH
96800: CALL 103157 0 3
// end ;
96804: GO 96702
96806: POP
96807: POP
// if enchidnas then
96808: LD_VAR 0 4
96812: IFFALSE 96879
// for i = 1 to enchidnas do
96814: LD_ADDR_VAR 0 11
96818: PUSH
96819: DOUBLE
96820: LD_INT 1
96822: DEC
96823: ST_TO_ADDR
96824: LD_VAR 0 4
96828: PUSH
96829: FOR_TO
96830: IFFALSE 96877
// begin hc_class = 13 ;
96832: LD_ADDR_OWVAR 28
96836: PUSH
96837: LD_INT 13
96839: ST_TO_ADDR
// hc_gallery =  ;
96840: LD_ADDR_OWVAR 33
96844: PUSH
96845: LD_STRING 
96847: ST_TO_ADDR
// animal := CreateHuman ;
96848: LD_ADDR_VAR 0 12
96852: PUSH
96853: CALL_OW 44
96857: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96858: LD_VAR 0 12
96862: PPUSH
96863: LD_VAR 0 8
96867: PPUSH
96868: LD_INT 0
96870: PPUSH
96871: CALL 103157 0 3
// end ;
96875: GO 96829
96877: POP
96878: POP
// if fishes then
96879: LD_VAR 0 7
96883: IFFALSE 96950
// for i = 1 to fishes do
96885: LD_ADDR_VAR 0 11
96889: PUSH
96890: DOUBLE
96891: LD_INT 1
96893: DEC
96894: ST_TO_ADDR
96895: LD_VAR 0 7
96899: PUSH
96900: FOR_TO
96901: IFFALSE 96948
// begin hc_class = 20 ;
96903: LD_ADDR_OWVAR 28
96907: PUSH
96908: LD_INT 20
96910: ST_TO_ADDR
// hc_gallery =  ;
96911: LD_ADDR_OWVAR 33
96915: PUSH
96916: LD_STRING 
96918: ST_TO_ADDR
// animal := CreateHuman ;
96919: LD_ADDR_VAR 0 12
96923: PUSH
96924: CALL_OW 44
96928: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
96929: LD_VAR 0 12
96933: PPUSH
96934: LD_VAR 0 9
96938: PPUSH
96939: LD_INT 0
96941: PPUSH
96942: CALL 103157 0 3
// end ;
96946: GO 96900
96948: POP
96949: POP
// end ;
96950: LD_VAR 0 10
96954: RET
// export function WantHeal ( sci , unit ) ; begin
96955: LD_INT 0
96957: PPUSH
// if GetTaskList ( sci ) > 0 then
96958: LD_VAR 0 1
96962: PPUSH
96963: CALL_OW 437
96967: PUSH
96968: LD_INT 0
96970: GREATER
96971: IFFALSE 97041
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
96973: LD_VAR 0 1
96977: PPUSH
96978: CALL_OW 437
96982: PUSH
96983: LD_INT 1
96985: ARRAY
96986: PUSH
96987: LD_INT 1
96989: ARRAY
96990: PUSH
96991: LD_STRING l
96993: EQUAL
96994: PUSH
96995: LD_VAR 0 1
96999: PPUSH
97000: CALL_OW 437
97004: PUSH
97005: LD_INT 1
97007: ARRAY
97008: PUSH
97009: LD_INT 4
97011: ARRAY
97012: PUSH
97013: LD_VAR 0 2
97017: EQUAL
97018: AND
97019: IFFALSE 97031
// result := true else
97021: LD_ADDR_VAR 0 3
97025: PUSH
97026: LD_INT 1
97028: ST_TO_ADDR
97029: GO 97039
// result := false ;
97031: LD_ADDR_VAR 0 3
97035: PUSH
97036: LD_INT 0
97038: ST_TO_ADDR
// end else
97039: GO 97049
// result := false ;
97041: LD_ADDR_VAR 0 3
97045: PUSH
97046: LD_INT 0
97048: ST_TO_ADDR
// end ;
97049: LD_VAR 0 3
97053: RET
// export function HealTarget ( sci ) ; begin
97054: LD_INT 0
97056: PPUSH
// if not sci then
97057: LD_VAR 0 1
97061: NOT
97062: IFFALSE 97066
// exit ;
97064: GO 97131
// result := 0 ;
97066: LD_ADDR_VAR 0 2
97070: PUSH
97071: LD_INT 0
97073: ST_TO_ADDR
// if GetTaskList ( sci ) then
97074: LD_VAR 0 1
97078: PPUSH
97079: CALL_OW 437
97083: IFFALSE 97131
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
97085: LD_VAR 0 1
97089: PPUSH
97090: CALL_OW 437
97094: PUSH
97095: LD_INT 1
97097: ARRAY
97098: PUSH
97099: LD_INT 1
97101: ARRAY
97102: PUSH
97103: LD_STRING l
97105: EQUAL
97106: IFFALSE 97131
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
97108: LD_ADDR_VAR 0 2
97112: PUSH
97113: LD_VAR 0 1
97117: PPUSH
97118: CALL_OW 437
97122: PUSH
97123: LD_INT 1
97125: ARRAY
97126: PUSH
97127: LD_INT 4
97129: ARRAY
97130: ST_TO_ADDR
// end ;
97131: LD_VAR 0 2
97135: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs ; begin
97136: LD_INT 0
97138: PPUSH
97139: PPUSH
97140: PPUSH
97141: PPUSH
97142: PPUSH
97143: PPUSH
97144: PPUSH
97145: PPUSH
97146: PPUSH
97147: PPUSH
97148: PPUSH
97149: PPUSH
97150: PPUSH
97151: PPUSH
97152: PPUSH
97153: PPUSH
97154: PPUSH
97155: PPUSH
97156: PPUSH
97157: PPUSH
97158: PPUSH
97159: PPUSH
97160: PPUSH
97161: PPUSH
97162: PPUSH
97163: PPUSH
97164: PPUSH
97165: PPUSH
97166: PPUSH
97167: PPUSH
97168: PPUSH
97169: PPUSH
97170: PPUSH
// if not list then
97171: LD_VAR 0 1
97175: NOT
97176: IFFALSE 97180
// exit ;
97178: GO 101768
// base := list [ 1 ] ;
97180: LD_ADDR_VAR 0 3
97184: PUSH
97185: LD_VAR 0 1
97189: PUSH
97190: LD_INT 1
97192: ARRAY
97193: ST_TO_ADDR
// group := list [ 2 ] ;
97194: LD_ADDR_VAR 0 4
97198: PUSH
97199: LD_VAR 0 1
97203: PUSH
97204: LD_INT 2
97206: ARRAY
97207: ST_TO_ADDR
// path := list [ 3 ] ;
97208: LD_ADDR_VAR 0 5
97212: PUSH
97213: LD_VAR 0 1
97217: PUSH
97218: LD_INT 3
97220: ARRAY
97221: ST_TO_ADDR
// flags := list [ 4 ] ;
97222: LD_ADDR_VAR 0 6
97226: PUSH
97227: LD_VAR 0 1
97231: PUSH
97232: LD_INT 4
97234: ARRAY
97235: ST_TO_ADDR
// mined := [ ] ;
97236: LD_ADDR_VAR 0 27
97240: PUSH
97241: EMPTY
97242: ST_TO_ADDR
// bombed := [ ] ;
97243: LD_ADDR_VAR 0 28
97247: PUSH
97248: EMPTY
97249: ST_TO_ADDR
// healers := [ ] ;
97250: LD_ADDR_VAR 0 31
97254: PUSH
97255: EMPTY
97256: ST_TO_ADDR
// to_heal := [ ] ;
97257: LD_ADDR_VAR 0 30
97261: PUSH
97262: EMPTY
97263: ST_TO_ADDR
// repairs := [ ] ;
97264: LD_ADDR_VAR 0 33
97268: PUSH
97269: EMPTY
97270: ST_TO_ADDR
// to_repair := [ ] ;
97271: LD_ADDR_VAR 0 32
97275: PUSH
97276: EMPTY
97277: ST_TO_ADDR
// if not group or not path then
97278: LD_VAR 0 4
97282: NOT
97283: PUSH
97284: LD_VAR 0 5
97288: NOT
97289: OR
97290: IFFALSE 97294
// exit ;
97292: GO 101768
// if flags then
97294: LD_VAR 0 6
97298: IFFALSE 97442
// begin f_ignore_area := flags [ 1 ] ;
97300: LD_ADDR_VAR 0 17
97304: PUSH
97305: LD_VAR 0 6
97309: PUSH
97310: LD_INT 1
97312: ARRAY
97313: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
97314: LD_ADDR_VAR 0 18
97318: PUSH
97319: LD_VAR 0 6
97323: PUSH
97324: LD_INT 2
97326: ARRAY
97327: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
97328: LD_ADDR_VAR 0 19
97332: PUSH
97333: LD_VAR 0 6
97337: PUSH
97338: LD_INT 3
97340: ARRAY
97341: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
97342: LD_ADDR_VAR 0 20
97346: PUSH
97347: LD_VAR 0 6
97351: PUSH
97352: LD_INT 4
97354: ARRAY
97355: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
97356: LD_ADDR_VAR 0 21
97360: PUSH
97361: LD_VAR 0 6
97365: PUSH
97366: LD_INT 5
97368: ARRAY
97369: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
97370: LD_ADDR_VAR 0 22
97374: PUSH
97375: LD_VAR 0 6
97379: PUSH
97380: LD_INT 6
97382: ARRAY
97383: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
97384: LD_ADDR_VAR 0 23
97388: PUSH
97389: LD_VAR 0 6
97393: PUSH
97394: LD_INT 7
97396: ARRAY
97397: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
97398: LD_ADDR_VAR 0 24
97402: PUSH
97403: LD_VAR 0 6
97407: PUSH
97408: LD_INT 8
97410: ARRAY
97411: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
97412: LD_ADDR_VAR 0 25
97416: PUSH
97417: LD_VAR 0 6
97421: PUSH
97422: LD_INT 9
97424: ARRAY
97425: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
97426: LD_ADDR_VAR 0 26
97430: PUSH
97431: LD_VAR 0 6
97435: PUSH
97436: LD_INT 10
97438: ARRAY
97439: ST_TO_ADDR
// end else
97440: GO 97522
// begin f_ignore_area := false ;
97442: LD_ADDR_VAR 0 17
97446: PUSH
97447: LD_INT 0
97449: ST_TO_ADDR
// f_capture := false ;
97450: LD_ADDR_VAR 0 18
97454: PUSH
97455: LD_INT 0
97457: ST_TO_ADDR
// f_ignore_civ := false ;
97458: LD_ADDR_VAR 0 19
97462: PUSH
97463: LD_INT 0
97465: ST_TO_ADDR
// f_murder := false ;
97466: LD_ADDR_VAR 0 20
97470: PUSH
97471: LD_INT 0
97473: ST_TO_ADDR
// f_mines := false ;
97474: LD_ADDR_VAR 0 21
97478: PUSH
97479: LD_INT 0
97481: ST_TO_ADDR
// f_repair := false ;
97482: LD_ADDR_VAR 0 22
97486: PUSH
97487: LD_INT 0
97489: ST_TO_ADDR
// f_heal := false ;
97490: LD_ADDR_VAR 0 23
97494: PUSH
97495: LD_INT 0
97497: ST_TO_ADDR
// f_spacetime := false ;
97498: LD_ADDR_VAR 0 24
97502: PUSH
97503: LD_INT 0
97505: ST_TO_ADDR
// f_attack_depot := false ;
97506: LD_ADDR_VAR 0 25
97510: PUSH
97511: LD_INT 0
97513: ST_TO_ADDR
// f_crawl := false ;
97514: LD_ADDR_VAR 0 26
97518: PUSH
97519: LD_INT 0
97521: ST_TO_ADDR
// end ; if f_heal then
97522: LD_VAR 0 23
97526: IFFALSE 97553
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
97528: LD_ADDR_VAR 0 31
97532: PUSH
97533: LD_VAR 0 4
97537: PPUSH
97538: LD_INT 25
97540: PUSH
97541: LD_INT 4
97543: PUSH
97544: EMPTY
97545: LIST
97546: LIST
97547: PPUSH
97548: CALL_OW 72
97552: ST_TO_ADDR
// if f_repair then
97553: LD_VAR 0 22
97557: IFFALSE 97584
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
97559: LD_ADDR_VAR 0 33
97563: PUSH
97564: LD_VAR 0 4
97568: PPUSH
97569: LD_INT 25
97571: PUSH
97572: LD_INT 3
97574: PUSH
97575: EMPTY
97576: LIST
97577: LIST
97578: PPUSH
97579: CALL_OW 72
97583: ST_TO_ADDR
// units_path := [ ] ;
97584: LD_ADDR_VAR 0 16
97588: PUSH
97589: EMPTY
97590: ST_TO_ADDR
// for i = 1 to group do
97591: LD_ADDR_VAR 0 7
97595: PUSH
97596: DOUBLE
97597: LD_INT 1
97599: DEC
97600: ST_TO_ADDR
97601: LD_VAR 0 4
97605: PUSH
97606: FOR_TO
97607: IFFALSE 97636
// units_path := Replace ( units_path , i , path ) ;
97609: LD_ADDR_VAR 0 16
97613: PUSH
97614: LD_VAR 0 16
97618: PPUSH
97619: LD_VAR 0 7
97623: PPUSH
97624: LD_VAR 0 5
97628: PPUSH
97629: CALL_OW 1
97633: ST_TO_ADDR
97634: GO 97606
97636: POP
97637: POP
// repeat for i = group downto 1 do
97638: LD_ADDR_VAR 0 7
97642: PUSH
97643: DOUBLE
97644: LD_VAR 0 4
97648: INC
97649: ST_TO_ADDR
97650: LD_INT 1
97652: PUSH
97653: FOR_DOWNTO
97654: IFFALSE 101750
// begin wait ( 5 ) ;
97656: LD_INT 5
97658: PPUSH
97659: CALL_OW 67
// tmp := [ ] ;
97663: LD_ADDR_VAR 0 14
97667: PUSH
97668: EMPTY
97669: ST_TO_ADDR
// attacking := false ;
97670: LD_ADDR_VAR 0 29
97674: PUSH
97675: LD_INT 0
97677: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
97678: LD_VAR 0 4
97682: PUSH
97683: LD_VAR 0 7
97687: ARRAY
97688: PPUSH
97689: CALL_OW 301
97693: PUSH
97694: LD_VAR 0 4
97698: PUSH
97699: LD_VAR 0 7
97703: ARRAY
97704: NOT
97705: OR
97706: IFFALSE 97815
// begin if GetType ( group [ i ] ) = unit_human then
97708: LD_VAR 0 4
97712: PUSH
97713: LD_VAR 0 7
97717: ARRAY
97718: PPUSH
97719: CALL_OW 247
97723: PUSH
97724: LD_INT 1
97726: EQUAL
97727: IFFALSE 97773
// begin to_heal := to_heal diff group [ i ] ;
97729: LD_ADDR_VAR 0 30
97733: PUSH
97734: LD_VAR 0 30
97738: PUSH
97739: LD_VAR 0 4
97743: PUSH
97744: LD_VAR 0 7
97748: ARRAY
97749: DIFF
97750: ST_TO_ADDR
// healers := healers diff group [ i ] ;
97751: LD_ADDR_VAR 0 31
97755: PUSH
97756: LD_VAR 0 31
97760: PUSH
97761: LD_VAR 0 4
97765: PUSH
97766: LD_VAR 0 7
97770: ARRAY
97771: DIFF
97772: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
97773: LD_ADDR_VAR 0 4
97777: PUSH
97778: LD_VAR 0 4
97782: PPUSH
97783: LD_VAR 0 7
97787: PPUSH
97788: CALL_OW 3
97792: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
97793: LD_ADDR_VAR 0 16
97797: PUSH
97798: LD_VAR 0 16
97802: PPUSH
97803: LD_VAR 0 7
97807: PPUSH
97808: CALL_OW 3
97812: ST_TO_ADDR
// continue ;
97813: GO 97653
// end ; if f_repair then
97815: LD_VAR 0 22
97819: IFFALSE 98308
// begin if GetType ( group [ i ] ) = unit_vehicle then
97821: LD_VAR 0 4
97825: PUSH
97826: LD_VAR 0 7
97830: ARRAY
97831: PPUSH
97832: CALL_OW 247
97836: PUSH
97837: LD_INT 2
97839: EQUAL
97840: IFFALSE 98030
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
97842: LD_VAR 0 4
97846: PUSH
97847: LD_VAR 0 7
97851: ARRAY
97852: PPUSH
97853: CALL_OW 256
97857: PUSH
97858: LD_INT 700
97860: LESS
97861: PUSH
97862: LD_VAR 0 4
97866: PUSH
97867: LD_VAR 0 7
97871: ARRAY
97872: PUSH
97873: LD_VAR 0 32
97877: IN
97878: NOT
97879: AND
97880: IFFALSE 97904
// to_repair := to_repair union group [ i ] ;
97882: LD_ADDR_VAR 0 32
97886: PUSH
97887: LD_VAR 0 32
97891: PUSH
97892: LD_VAR 0 4
97896: PUSH
97897: LD_VAR 0 7
97901: ARRAY
97902: UNION
97903: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
97904: LD_VAR 0 4
97908: PUSH
97909: LD_VAR 0 7
97913: ARRAY
97914: PPUSH
97915: CALL_OW 256
97919: PUSH
97920: LD_INT 1000
97922: EQUAL
97923: PUSH
97924: LD_VAR 0 4
97928: PUSH
97929: LD_VAR 0 7
97933: ARRAY
97934: PUSH
97935: LD_VAR 0 32
97939: IN
97940: AND
97941: IFFALSE 97965
// to_repair := to_repair diff group [ i ] ;
97943: LD_ADDR_VAR 0 32
97947: PUSH
97948: LD_VAR 0 32
97952: PUSH
97953: LD_VAR 0 4
97957: PUSH
97958: LD_VAR 0 7
97962: ARRAY
97963: DIFF
97964: ST_TO_ADDR
// if group [ i ] in to_repair then
97965: LD_VAR 0 4
97969: PUSH
97970: LD_VAR 0 7
97974: ARRAY
97975: PUSH
97976: LD_VAR 0 32
97980: IN
97981: IFFALSE 98028
// begin if not IsInArea ( group [ i ] , f_repair ) then
97983: LD_VAR 0 4
97987: PUSH
97988: LD_VAR 0 7
97992: ARRAY
97993: PPUSH
97994: LD_VAR 0 22
97998: PPUSH
97999: CALL_OW 308
98003: NOT
98004: IFFALSE 98026
// ComMoveToArea ( group [ i ] , f_repair ) ;
98006: LD_VAR 0 4
98010: PUSH
98011: LD_VAR 0 7
98015: ARRAY
98016: PPUSH
98017: LD_VAR 0 22
98021: PPUSH
98022: CALL_OW 113
// continue ;
98026: GO 97653
// end ; end else
98028: GO 98308
// if group [ i ] in repairs then
98030: LD_VAR 0 4
98034: PUSH
98035: LD_VAR 0 7
98039: ARRAY
98040: PUSH
98041: LD_VAR 0 33
98045: IN
98046: IFFALSE 98308
// begin if IsInUnit ( group [ i ] ) then
98048: LD_VAR 0 4
98052: PUSH
98053: LD_VAR 0 7
98057: ARRAY
98058: PPUSH
98059: CALL_OW 310
98063: IFFALSE 98131
// begin z := IsInUnit ( group [ i ] ) ;
98065: LD_ADDR_VAR 0 13
98069: PUSH
98070: LD_VAR 0 4
98074: PUSH
98075: LD_VAR 0 7
98079: ARRAY
98080: PPUSH
98081: CALL_OW 310
98085: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
98086: LD_VAR 0 13
98090: PUSH
98091: LD_VAR 0 32
98095: IN
98096: PUSH
98097: LD_VAR 0 13
98101: PPUSH
98102: LD_VAR 0 22
98106: PPUSH
98107: CALL_OW 308
98111: AND
98112: IFFALSE 98129
// ComExitVehicle ( group [ i ] ) ;
98114: LD_VAR 0 4
98118: PUSH
98119: LD_VAR 0 7
98123: ARRAY
98124: PPUSH
98125: CALL_OW 121
// end else
98129: GO 98308
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
98131: LD_ADDR_VAR 0 13
98135: PUSH
98136: LD_VAR 0 4
98140: PPUSH
98141: LD_INT 95
98143: PUSH
98144: LD_VAR 0 22
98148: PUSH
98149: EMPTY
98150: LIST
98151: LIST
98152: PUSH
98153: LD_INT 58
98155: PUSH
98156: EMPTY
98157: LIST
98158: PUSH
98159: EMPTY
98160: LIST
98161: LIST
98162: PPUSH
98163: CALL_OW 72
98167: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
98168: LD_VAR 0 4
98172: PUSH
98173: LD_VAR 0 7
98177: ARRAY
98178: PPUSH
98179: CALL_OW 314
98183: NOT
98184: IFFALSE 98306
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
98186: LD_ADDR_VAR 0 10
98190: PUSH
98191: LD_VAR 0 13
98195: PPUSH
98196: LD_VAR 0 4
98200: PUSH
98201: LD_VAR 0 7
98205: ARRAY
98206: PPUSH
98207: CALL_OW 74
98211: ST_TO_ADDR
// if not x then
98212: LD_VAR 0 10
98216: NOT
98217: IFFALSE 98221
// continue ;
98219: GO 97653
// if GetLives ( x ) < 1000 then
98221: LD_VAR 0 10
98225: PPUSH
98226: CALL_OW 256
98230: PUSH
98231: LD_INT 1000
98233: LESS
98234: IFFALSE 98258
// ComRepairVehicle ( group [ i ] , x ) else
98236: LD_VAR 0 4
98240: PUSH
98241: LD_VAR 0 7
98245: ARRAY
98246: PPUSH
98247: LD_VAR 0 10
98251: PPUSH
98252: CALL_OW 129
98256: GO 98306
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
98258: LD_VAR 0 23
98262: PUSH
98263: LD_VAR 0 4
98267: PUSH
98268: LD_VAR 0 7
98272: ARRAY
98273: PPUSH
98274: CALL_OW 256
98278: PUSH
98279: LD_INT 1000
98281: LESS
98282: AND
98283: NOT
98284: IFFALSE 98306
// ComEnterUnit ( group [ i ] , x ) ;
98286: LD_VAR 0 4
98290: PUSH
98291: LD_VAR 0 7
98295: ARRAY
98296: PPUSH
98297: LD_VAR 0 10
98301: PPUSH
98302: CALL_OW 120
// end ; continue ;
98306: GO 97653
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
98308: LD_VAR 0 23
98312: PUSH
98313: LD_VAR 0 4
98317: PUSH
98318: LD_VAR 0 7
98322: ARRAY
98323: PPUSH
98324: CALL_OW 247
98328: PUSH
98329: LD_INT 1
98331: EQUAL
98332: AND
98333: IFFALSE 98811
// begin if group [ i ] in healers then
98335: LD_VAR 0 4
98339: PUSH
98340: LD_VAR 0 7
98344: ARRAY
98345: PUSH
98346: LD_VAR 0 31
98350: IN
98351: IFFALSE 98624
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
98353: LD_VAR 0 4
98357: PUSH
98358: LD_VAR 0 7
98362: ARRAY
98363: PPUSH
98364: LD_VAR 0 23
98368: PPUSH
98369: CALL_OW 308
98373: NOT
98374: PUSH
98375: LD_VAR 0 4
98379: PUSH
98380: LD_VAR 0 7
98384: ARRAY
98385: PPUSH
98386: CALL_OW 314
98390: NOT
98391: AND
98392: IFFALSE 98416
// ComMoveToArea ( group [ i ] , f_heal ) else
98394: LD_VAR 0 4
98398: PUSH
98399: LD_VAR 0 7
98403: ARRAY
98404: PPUSH
98405: LD_VAR 0 23
98409: PPUSH
98410: CALL_OW 113
98414: GO 98622
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
98416: LD_VAR 0 4
98420: PUSH
98421: LD_VAR 0 7
98425: ARRAY
98426: PPUSH
98427: CALL 97054 0 1
98431: PPUSH
98432: CALL_OW 256
98436: PUSH
98437: LD_INT 1000
98439: EQUAL
98440: IFFALSE 98459
// ComStop ( group [ i ] ) else
98442: LD_VAR 0 4
98446: PUSH
98447: LD_VAR 0 7
98451: ARRAY
98452: PPUSH
98453: CALL_OW 141
98457: GO 98622
// if not HasTask ( group [ i ] ) and to_heal then
98459: LD_VAR 0 4
98463: PUSH
98464: LD_VAR 0 7
98468: ARRAY
98469: PPUSH
98470: CALL_OW 314
98474: NOT
98475: PUSH
98476: LD_VAR 0 30
98480: AND
98481: IFFALSE 98622
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
98483: LD_ADDR_VAR 0 13
98487: PUSH
98488: LD_VAR 0 30
98492: PPUSH
98493: LD_INT 3
98495: PUSH
98496: LD_INT 54
98498: PUSH
98499: EMPTY
98500: LIST
98501: PUSH
98502: EMPTY
98503: LIST
98504: LIST
98505: PPUSH
98506: CALL_OW 72
98510: PPUSH
98511: LD_VAR 0 4
98515: PUSH
98516: LD_VAR 0 7
98520: ARRAY
98521: PPUSH
98522: CALL_OW 74
98526: ST_TO_ADDR
// if z then
98527: LD_VAR 0 13
98531: IFFALSE 98622
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
98533: LD_INT 91
98535: PUSH
98536: LD_VAR 0 13
98540: PUSH
98541: LD_INT 10
98543: PUSH
98544: EMPTY
98545: LIST
98546: LIST
98547: LIST
98548: PUSH
98549: LD_INT 81
98551: PUSH
98552: LD_VAR 0 13
98556: PPUSH
98557: CALL_OW 255
98561: PUSH
98562: EMPTY
98563: LIST
98564: LIST
98565: PUSH
98566: EMPTY
98567: LIST
98568: LIST
98569: PPUSH
98570: CALL_OW 69
98574: PUSH
98575: LD_INT 0
98577: EQUAL
98578: IFFALSE 98602
// ComHeal ( group [ i ] , z ) else
98580: LD_VAR 0 4
98584: PUSH
98585: LD_VAR 0 7
98589: ARRAY
98590: PPUSH
98591: LD_VAR 0 13
98595: PPUSH
98596: CALL_OW 128
98600: GO 98622
// ComMoveToArea ( group [ i ] , f_heal ) ;
98602: LD_VAR 0 4
98606: PUSH
98607: LD_VAR 0 7
98611: ARRAY
98612: PPUSH
98613: LD_VAR 0 23
98617: PPUSH
98618: CALL_OW 113
// end ; continue ;
98622: GO 97653
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
98624: LD_VAR 0 4
98628: PUSH
98629: LD_VAR 0 7
98633: ARRAY
98634: PPUSH
98635: CALL_OW 256
98639: PUSH
98640: LD_INT 700
98642: LESS
98643: PUSH
98644: LD_VAR 0 4
98648: PUSH
98649: LD_VAR 0 7
98653: ARRAY
98654: PUSH
98655: LD_VAR 0 30
98659: IN
98660: NOT
98661: AND
98662: IFFALSE 98686
// to_heal := to_heal union group [ i ] ;
98664: LD_ADDR_VAR 0 30
98668: PUSH
98669: LD_VAR 0 30
98673: PUSH
98674: LD_VAR 0 4
98678: PUSH
98679: LD_VAR 0 7
98683: ARRAY
98684: UNION
98685: ST_TO_ADDR
// if group [ i ] in to_heal then
98686: LD_VAR 0 4
98690: PUSH
98691: LD_VAR 0 7
98695: ARRAY
98696: PUSH
98697: LD_VAR 0 30
98701: IN
98702: IFFALSE 98811
// begin if GetLives ( group [ i ] ) = 1000 then
98704: LD_VAR 0 4
98708: PUSH
98709: LD_VAR 0 7
98713: ARRAY
98714: PPUSH
98715: CALL_OW 256
98719: PUSH
98720: LD_INT 1000
98722: EQUAL
98723: IFFALSE 98749
// to_heal := to_heal diff group [ i ] else
98725: LD_ADDR_VAR 0 30
98729: PUSH
98730: LD_VAR 0 30
98734: PUSH
98735: LD_VAR 0 4
98739: PUSH
98740: LD_VAR 0 7
98744: ARRAY
98745: DIFF
98746: ST_TO_ADDR
98747: GO 98811
// begin if not IsInArea ( group [ i ] , to_heal ) then
98749: LD_VAR 0 4
98753: PUSH
98754: LD_VAR 0 7
98758: ARRAY
98759: PPUSH
98760: LD_VAR 0 30
98764: PPUSH
98765: CALL_OW 308
98769: NOT
98770: IFFALSE 98794
// ComMoveToArea ( group [ i ] , f_heal ) else
98772: LD_VAR 0 4
98776: PUSH
98777: LD_VAR 0 7
98781: ARRAY
98782: PPUSH
98783: LD_VAR 0 23
98787: PPUSH
98788: CALL_OW 113
98792: GO 98809
// ComHold ( group [ i ] ) ;
98794: LD_VAR 0 4
98798: PUSH
98799: LD_VAR 0 7
98803: ARRAY
98804: PPUSH
98805: CALL_OW 140
// continue ;
98809: GO 97653
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
98811: LD_VAR 0 4
98815: PUSH
98816: LD_VAR 0 7
98820: ARRAY
98821: PPUSH
98822: LD_INT 10
98824: PPUSH
98825: CALL 95451 0 2
98829: NOT
98830: PUSH
98831: LD_VAR 0 16
98835: PUSH
98836: LD_VAR 0 7
98840: ARRAY
98841: PUSH
98842: EMPTY
98843: EQUAL
98844: NOT
98845: AND
98846: IFFALSE 99112
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
98848: LD_VAR 0 4
98852: PUSH
98853: LD_VAR 0 7
98857: ARRAY
98858: PPUSH
98859: CALL_OW 262
98863: PUSH
98864: LD_INT 1
98866: PUSH
98867: LD_INT 2
98869: PUSH
98870: EMPTY
98871: LIST
98872: LIST
98873: IN
98874: IFFALSE 98915
// if GetFuel ( group [ i ] ) < 10 then
98876: LD_VAR 0 4
98880: PUSH
98881: LD_VAR 0 7
98885: ARRAY
98886: PPUSH
98887: CALL_OW 261
98891: PUSH
98892: LD_INT 10
98894: LESS
98895: IFFALSE 98915
// SetFuel ( group [ i ] , 12 ) ;
98897: LD_VAR 0 4
98901: PUSH
98902: LD_VAR 0 7
98906: ARRAY
98907: PPUSH
98908: LD_INT 12
98910: PPUSH
98911: CALL_OW 240
// if units_path [ i ] then
98915: LD_VAR 0 16
98919: PUSH
98920: LD_VAR 0 7
98924: ARRAY
98925: IFFALSE 99110
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
98927: LD_VAR 0 4
98931: PUSH
98932: LD_VAR 0 7
98936: ARRAY
98937: PPUSH
98938: LD_VAR 0 16
98942: PUSH
98943: LD_VAR 0 7
98947: ARRAY
98948: PUSH
98949: LD_INT 1
98951: ARRAY
98952: PUSH
98953: LD_INT 1
98955: ARRAY
98956: PPUSH
98957: LD_VAR 0 16
98961: PUSH
98962: LD_VAR 0 7
98966: ARRAY
98967: PUSH
98968: LD_INT 1
98970: ARRAY
98971: PUSH
98972: LD_INT 2
98974: ARRAY
98975: PPUSH
98976: CALL_OW 297
98980: PUSH
98981: LD_INT 6
98983: GREATER
98984: IFFALSE 99059
// begin if not HasTask ( group [ i ] ) then
98986: LD_VAR 0 4
98990: PUSH
98991: LD_VAR 0 7
98995: ARRAY
98996: PPUSH
98997: CALL_OW 314
99001: NOT
99002: IFFALSE 99057
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
99004: LD_VAR 0 4
99008: PUSH
99009: LD_VAR 0 7
99013: ARRAY
99014: PPUSH
99015: LD_VAR 0 16
99019: PUSH
99020: LD_VAR 0 7
99024: ARRAY
99025: PUSH
99026: LD_INT 1
99028: ARRAY
99029: PUSH
99030: LD_INT 1
99032: ARRAY
99033: PPUSH
99034: LD_VAR 0 16
99038: PUSH
99039: LD_VAR 0 7
99043: ARRAY
99044: PUSH
99045: LD_INT 1
99047: ARRAY
99048: PUSH
99049: LD_INT 2
99051: ARRAY
99052: PPUSH
99053: CALL_OW 114
// end else
99057: GO 99110
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
99059: LD_ADDR_VAR 0 15
99063: PUSH
99064: LD_VAR 0 16
99068: PUSH
99069: LD_VAR 0 7
99073: ARRAY
99074: PPUSH
99075: LD_INT 1
99077: PPUSH
99078: CALL_OW 3
99082: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
99083: LD_ADDR_VAR 0 16
99087: PUSH
99088: LD_VAR 0 16
99092: PPUSH
99093: LD_VAR 0 7
99097: PPUSH
99098: LD_VAR 0 15
99102: PPUSH
99103: CALL_OW 1
99107: ST_TO_ADDR
// continue ;
99108: GO 97653
// end ; end ; end else
99110: GO 101748
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
99112: LD_ADDR_VAR 0 14
99116: PUSH
99117: LD_INT 81
99119: PUSH
99120: LD_VAR 0 4
99124: PUSH
99125: LD_VAR 0 7
99129: ARRAY
99130: PPUSH
99131: CALL_OW 255
99135: PUSH
99136: EMPTY
99137: LIST
99138: LIST
99139: PPUSH
99140: CALL_OW 69
99144: ST_TO_ADDR
// if not tmp then
99145: LD_VAR 0 14
99149: NOT
99150: IFFALSE 99154
// continue ;
99152: GO 97653
// if f_ignore_area then
99154: LD_VAR 0 17
99158: IFFALSE 99246
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
99160: LD_ADDR_VAR 0 15
99164: PUSH
99165: LD_VAR 0 14
99169: PPUSH
99170: LD_INT 3
99172: PUSH
99173: LD_INT 92
99175: PUSH
99176: LD_VAR 0 17
99180: PUSH
99181: LD_INT 1
99183: ARRAY
99184: PUSH
99185: LD_VAR 0 17
99189: PUSH
99190: LD_INT 2
99192: ARRAY
99193: PUSH
99194: LD_VAR 0 17
99198: PUSH
99199: LD_INT 3
99201: ARRAY
99202: PUSH
99203: EMPTY
99204: LIST
99205: LIST
99206: LIST
99207: LIST
99208: PUSH
99209: EMPTY
99210: LIST
99211: LIST
99212: PPUSH
99213: CALL_OW 72
99217: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
99218: LD_VAR 0 14
99222: PUSH
99223: LD_VAR 0 15
99227: DIFF
99228: IFFALSE 99246
// tmp := tmp diff tmp2 ;
99230: LD_ADDR_VAR 0 14
99234: PUSH
99235: LD_VAR 0 14
99239: PUSH
99240: LD_VAR 0 15
99244: DIFF
99245: ST_TO_ADDR
// end ; if not f_murder then
99246: LD_VAR 0 20
99250: NOT
99251: IFFALSE 99309
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
99253: LD_ADDR_VAR 0 15
99257: PUSH
99258: LD_VAR 0 14
99262: PPUSH
99263: LD_INT 3
99265: PUSH
99266: LD_INT 50
99268: PUSH
99269: EMPTY
99270: LIST
99271: PUSH
99272: EMPTY
99273: LIST
99274: LIST
99275: PPUSH
99276: CALL_OW 72
99280: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
99281: LD_VAR 0 14
99285: PUSH
99286: LD_VAR 0 15
99290: DIFF
99291: IFFALSE 99309
// tmp := tmp diff tmp2 ;
99293: LD_ADDR_VAR 0 14
99297: PUSH
99298: LD_VAR 0 14
99302: PUSH
99303: LD_VAR 0 15
99307: DIFF
99308: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
99309: LD_ADDR_VAR 0 14
99313: PUSH
99314: LD_VAR 0 4
99318: PUSH
99319: LD_VAR 0 7
99323: ARRAY
99324: PPUSH
99325: LD_VAR 0 14
99329: PPUSH
99330: LD_INT 1
99332: PPUSH
99333: LD_INT 1
99335: PPUSH
99336: CALL 69118 0 4
99340: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
99341: LD_VAR 0 4
99345: PUSH
99346: LD_VAR 0 7
99350: ARRAY
99351: PPUSH
99352: CALL_OW 257
99356: PUSH
99357: LD_INT 1
99359: EQUAL
99360: IFFALSE 99808
// begin if WantPlant ( group [ i ] ) then
99362: LD_VAR 0 4
99366: PUSH
99367: LD_VAR 0 7
99371: ARRAY
99372: PPUSH
99373: CALL 68619 0 1
99377: IFFALSE 99381
// continue ;
99379: GO 97653
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
99381: LD_VAR 0 18
99385: PUSH
99386: LD_VAR 0 4
99390: PUSH
99391: LD_VAR 0 7
99395: ARRAY
99396: PPUSH
99397: CALL_OW 310
99401: NOT
99402: AND
99403: PUSH
99404: LD_VAR 0 14
99408: PUSH
99409: LD_INT 1
99411: ARRAY
99412: PUSH
99413: LD_VAR 0 14
99417: PPUSH
99418: LD_INT 21
99420: PUSH
99421: LD_INT 2
99423: PUSH
99424: EMPTY
99425: LIST
99426: LIST
99427: PUSH
99428: LD_INT 58
99430: PUSH
99431: EMPTY
99432: LIST
99433: PUSH
99434: EMPTY
99435: LIST
99436: LIST
99437: PPUSH
99438: CALL_OW 72
99442: IN
99443: AND
99444: IFFALSE 99480
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
99446: LD_VAR 0 4
99450: PUSH
99451: LD_VAR 0 7
99455: ARRAY
99456: PPUSH
99457: LD_VAR 0 14
99461: PUSH
99462: LD_INT 1
99464: ARRAY
99465: PPUSH
99466: CALL_OW 120
// attacking := true ;
99470: LD_ADDR_VAR 0 29
99474: PUSH
99475: LD_INT 1
99477: ST_TO_ADDR
// continue ;
99478: GO 97653
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
99480: LD_VAR 0 26
99484: PUSH
99485: LD_VAR 0 4
99489: PUSH
99490: LD_VAR 0 7
99494: ARRAY
99495: PPUSH
99496: CALL_OW 257
99500: PUSH
99501: LD_INT 1
99503: EQUAL
99504: AND
99505: PUSH
99506: LD_VAR 0 4
99510: PUSH
99511: LD_VAR 0 7
99515: ARRAY
99516: PPUSH
99517: CALL_OW 256
99521: PUSH
99522: LD_INT 800
99524: LESS
99525: AND
99526: PUSH
99527: LD_VAR 0 4
99531: PUSH
99532: LD_VAR 0 7
99536: ARRAY
99537: PPUSH
99538: CALL_OW 318
99542: NOT
99543: AND
99544: IFFALSE 99561
// ComCrawl ( group [ i ] ) ;
99546: LD_VAR 0 4
99550: PUSH
99551: LD_VAR 0 7
99555: ARRAY
99556: PPUSH
99557: CALL_OW 137
// if f_mines then
99561: LD_VAR 0 21
99565: IFFALSE 99808
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
99567: LD_VAR 0 14
99571: PUSH
99572: LD_INT 1
99574: ARRAY
99575: PPUSH
99576: CALL_OW 247
99580: PUSH
99581: LD_INT 3
99583: EQUAL
99584: PUSH
99585: LD_VAR 0 14
99589: PUSH
99590: LD_INT 1
99592: ARRAY
99593: PUSH
99594: LD_VAR 0 27
99598: IN
99599: NOT
99600: AND
99601: IFFALSE 99808
// begin x := GetX ( tmp [ 1 ] ) ;
99603: LD_ADDR_VAR 0 10
99607: PUSH
99608: LD_VAR 0 14
99612: PUSH
99613: LD_INT 1
99615: ARRAY
99616: PPUSH
99617: CALL_OW 250
99621: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
99622: LD_ADDR_VAR 0 11
99626: PUSH
99627: LD_VAR 0 14
99631: PUSH
99632: LD_INT 1
99634: ARRAY
99635: PPUSH
99636: CALL_OW 251
99640: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
99641: LD_ADDR_VAR 0 12
99645: PUSH
99646: LD_VAR 0 4
99650: PUSH
99651: LD_VAR 0 7
99655: ARRAY
99656: PPUSH
99657: CALL 95536 0 1
99661: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
99662: LD_VAR 0 4
99666: PUSH
99667: LD_VAR 0 7
99671: ARRAY
99672: PPUSH
99673: LD_VAR 0 10
99677: PPUSH
99678: LD_VAR 0 11
99682: PPUSH
99683: LD_VAR 0 14
99687: PUSH
99688: LD_INT 1
99690: ARRAY
99691: PPUSH
99692: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
99696: LD_VAR 0 4
99700: PUSH
99701: LD_VAR 0 7
99705: ARRAY
99706: PPUSH
99707: LD_VAR 0 10
99711: PPUSH
99712: LD_VAR 0 12
99716: PPUSH
99717: LD_INT 7
99719: PPUSH
99720: CALL_OW 272
99724: PPUSH
99725: LD_VAR 0 11
99729: PPUSH
99730: LD_VAR 0 12
99734: PPUSH
99735: LD_INT 7
99737: PPUSH
99738: CALL_OW 273
99742: PPUSH
99743: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
99747: LD_VAR 0 4
99751: PUSH
99752: LD_VAR 0 7
99756: ARRAY
99757: PPUSH
99758: LD_INT 71
99760: PPUSH
99761: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
99765: LD_ADDR_VAR 0 27
99769: PUSH
99770: LD_VAR 0 27
99774: PPUSH
99775: LD_VAR 0 27
99779: PUSH
99780: LD_INT 1
99782: PLUS
99783: PPUSH
99784: LD_VAR 0 14
99788: PUSH
99789: LD_INT 1
99791: ARRAY
99792: PPUSH
99793: CALL_OW 1
99797: ST_TO_ADDR
// attacking := true ;
99798: LD_ADDR_VAR 0 29
99802: PUSH
99803: LD_INT 1
99805: ST_TO_ADDR
// continue ;
99806: GO 97653
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
99808: LD_VAR 0 4
99812: PUSH
99813: LD_VAR 0 7
99817: ARRAY
99818: PPUSH
99819: CALL_OW 257
99823: PUSH
99824: LD_INT 17
99826: EQUAL
99827: PUSH
99828: LD_VAR 0 4
99832: PUSH
99833: LD_VAR 0 7
99837: ARRAY
99838: PPUSH
99839: CALL_OW 110
99843: PUSH
99844: LD_INT 71
99846: EQUAL
99847: NOT
99848: AND
99849: IFFALSE 99995
// begin attacking := false ;
99851: LD_ADDR_VAR 0 29
99855: PUSH
99856: LD_INT 0
99858: ST_TO_ADDR
// k := 5 ;
99859: LD_ADDR_VAR 0 9
99863: PUSH
99864: LD_INT 5
99866: ST_TO_ADDR
// if tmp < k then
99867: LD_VAR 0 14
99871: PUSH
99872: LD_VAR 0 9
99876: LESS
99877: IFFALSE 99889
// k := tmp ;
99879: LD_ADDR_VAR 0 9
99883: PUSH
99884: LD_VAR 0 14
99888: ST_TO_ADDR
// for j = 1 to k do
99889: LD_ADDR_VAR 0 8
99893: PUSH
99894: DOUBLE
99895: LD_INT 1
99897: DEC
99898: ST_TO_ADDR
99899: LD_VAR 0 9
99903: PUSH
99904: FOR_TO
99905: IFFALSE 99993
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
99907: LD_VAR 0 14
99911: PUSH
99912: LD_VAR 0 8
99916: ARRAY
99917: PUSH
99918: LD_VAR 0 14
99922: PPUSH
99923: LD_INT 58
99925: PUSH
99926: EMPTY
99927: LIST
99928: PPUSH
99929: CALL_OW 72
99933: IN
99934: NOT
99935: IFFALSE 99991
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
99937: LD_VAR 0 4
99941: PUSH
99942: LD_VAR 0 7
99946: ARRAY
99947: PPUSH
99948: LD_VAR 0 14
99952: PUSH
99953: LD_VAR 0 8
99957: ARRAY
99958: PPUSH
99959: CALL_OW 115
// attacking := true ;
99963: LD_ADDR_VAR 0 29
99967: PUSH
99968: LD_INT 1
99970: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
99971: LD_VAR 0 4
99975: PUSH
99976: LD_VAR 0 7
99980: ARRAY
99981: PPUSH
99982: LD_INT 71
99984: PPUSH
99985: CALL_OW 109
// continue ;
99989: GO 99904
// end ; end ;
99991: GO 99904
99993: POP
99994: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
99995: LD_VAR 0 4
99999: PUSH
100000: LD_VAR 0 7
100004: ARRAY
100005: PPUSH
100006: CALL_OW 257
100010: PUSH
100011: LD_INT 8
100013: EQUAL
100014: PUSH
100015: LD_VAR 0 4
100019: PUSH
100020: LD_VAR 0 7
100024: ARRAY
100025: PPUSH
100026: CALL_OW 264
100030: PUSH
100031: LD_INT 28
100033: PUSH
100034: LD_INT 45
100036: PUSH
100037: LD_INT 7
100039: PUSH
100040: LD_INT 47
100042: PUSH
100043: EMPTY
100044: LIST
100045: LIST
100046: LIST
100047: LIST
100048: IN
100049: OR
100050: IFFALSE 100280
// begin attacking := false ;
100052: LD_ADDR_VAR 0 29
100056: PUSH
100057: LD_INT 0
100059: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
100060: LD_VAR 0 14
100064: PUSH
100065: LD_INT 1
100067: ARRAY
100068: PPUSH
100069: CALL_OW 266
100073: PUSH
100074: LD_INT 32
100076: PUSH
100077: LD_INT 31
100079: PUSH
100080: LD_INT 33
100082: PUSH
100083: LD_INT 4
100085: PUSH
100086: LD_INT 5
100088: PUSH
100089: EMPTY
100090: LIST
100091: LIST
100092: LIST
100093: LIST
100094: LIST
100095: IN
100096: IFFALSE 100280
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
100098: LD_ADDR_VAR 0 9
100102: PUSH
100103: LD_VAR 0 14
100107: PUSH
100108: LD_INT 1
100110: ARRAY
100111: PPUSH
100112: CALL_OW 266
100116: PPUSH
100117: LD_VAR 0 14
100121: PUSH
100122: LD_INT 1
100124: ARRAY
100125: PPUSH
100126: CALL_OW 250
100130: PPUSH
100131: LD_VAR 0 14
100135: PUSH
100136: LD_INT 1
100138: ARRAY
100139: PPUSH
100140: CALL_OW 251
100144: PPUSH
100145: LD_VAR 0 14
100149: PUSH
100150: LD_INT 1
100152: ARRAY
100153: PPUSH
100154: CALL_OW 254
100158: PPUSH
100159: LD_VAR 0 14
100163: PUSH
100164: LD_INT 1
100166: ARRAY
100167: PPUSH
100168: CALL_OW 248
100172: PPUSH
100173: LD_INT 0
100175: PPUSH
100176: CALL 76912 0 6
100180: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
100181: LD_ADDR_VAR 0 8
100185: PUSH
100186: LD_VAR 0 4
100190: PUSH
100191: LD_VAR 0 7
100195: ARRAY
100196: PPUSH
100197: LD_VAR 0 9
100201: PPUSH
100202: CALL 95599 0 2
100206: ST_TO_ADDR
// if j then
100207: LD_VAR 0 8
100211: IFFALSE 100280
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
100213: LD_VAR 0 8
100217: PUSH
100218: LD_INT 1
100220: ARRAY
100221: PPUSH
100222: LD_VAR 0 8
100226: PUSH
100227: LD_INT 2
100229: ARRAY
100230: PPUSH
100231: CALL_OW 488
100235: IFFALSE 100280
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
100237: LD_VAR 0 4
100241: PUSH
100242: LD_VAR 0 7
100246: ARRAY
100247: PPUSH
100248: LD_VAR 0 8
100252: PUSH
100253: LD_INT 1
100255: ARRAY
100256: PPUSH
100257: LD_VAR 0 8
100261: PUSH
100262: LD_INT 2
100264: ARRAY
100265: PPUSH
100266: CALL_OW 116
// attacking := true ;
100270: LD_ADDR_VAR 0 29
100274: PUSH
100275: LD_INT 1
100277: ST_TO_ADDR
// continue ;
100278: GO 97653
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
100280: LD_VAR 0 4
100284: PUSH
100285: LD_VAR 0 7
100289: ARRAY
100290: PPUSH
100291: CALL_OW 265
100295: PUSH
100296: LD_INT 11
100298: EQUAL
100299: IFFALSE 100577
// begin k := 10 ;
100301: LD_ADDR_VAR 0 9
100305: PUSH
100306: LD_INT 10
100308: ST_TO_ADDR
// x := 0 ;
100309: LD_ADDR_VAR 0 10
100313: PUSH
100314: LD_INT 0
100316: ST_TO_ADDR
// if tmp < k then
100317: LD_VAR 0 14
100321: PUSH
100322: LD_VAR 0 9
100326: LESS
100327: IFFALSE 100339
// k := tmp ;
100329: LD_ADDR_VAR 0 9
100333: PUSH
100334: LD_VAR 0 14
100338: ST_TO_ADDR
// for j = k downto 1 do
100339: LD_ADDR_VAR 0 8
100343: PUSH
100344: DOUBLE
100345: LD_VAR 0 9
100349: INC
100350: ST_TO_ADDR
100351: LD_INT 1
100353: PUSH
100354: FOR_DOWNTO
100355: IFFALSE 100430
// begin if GetType ( tmp [ j ] ) = unit_human then
100357: LD_VAR 0 14
100361: PUSH
100362: LD_VAR 0 8
100366: ARRAY
100367: PPUSH
100368: CALL_OW 247
100372: PUSH
100373: LD_INT 1
100375: EQUAL
100376: IFFALSE 100428
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
100378: LD_VAR 0 4
100382: PUSH
100383: LD_VAR 0 7
100387: ARRAY
100388: PPUSH
100389: LD_VAR 0 14
100393: PUSH
100394: LD_VAR 0 8
100398: ARRAY
100399: PPUSH
100400: CALL 95870 0 2
// x := tmp [ j ] ;
100404: LD_ADDR_VAR 0 10
100408: PUSH
100409: LD_VAR 0 14
100413: PUSH
100414: LD_VAR 0 8
100418: ARRAY
100419: ST_TO_ADDR
// attacking := true ;
100420: LD_ADDR_VAR 0 29
100424: PUSH
100425: LD_INT 1
100427: ST_TO_ADDR
// end ; end ;
100428: GO 100354
100430: POP
100431: POP
// if not x then
100432: LD_VAR 0 10
100436: NOT
100437: IFFALSE 100577
// begin attacking := true ;
100439: LD_ADDR_VAR 0 29
100443: PUSH
100444: LD_INT 1
100446: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
100447: LD_VAR 0 4
100451: PUSH
100452: LD_VAR 0 7
100456: ARRAY
100457: PPUSH
100458: CALL_OW 250
100462: PPUSH
100463: LD_VAR 0 4
100467: PUSH
100468: LD_VAR 0 7
100472: ARRAY
100473: PPUSH
100474: CALL_OW 251
100478: PPUSH
100479: CALL_OW 546
100483: PUSH
100484: LD_INT 2
100486: ARRAY
100487: PUSH
100488: LD_VAR 0 14
100492: PUSH
100493: LD_INT 1
100495: ARRAY
100496: PPUSH
100497: CALL_OW 250
100501: PPUSH
100502: LD_VAR 0 14
100506: PUSH
100507: LD_INT 1
100509: ARRAY
100510: PPUSH
100511: CALL_OW 251
100515: PPUSH
100516: CALL_OW 546
100520: PUSH
100521: LD_INT 2
100523: ARRAY
100524: EQUAL
100525: IFFALSE 100553
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
100527: LD_VAR 0 4
100531: PUSH
100532: LD_VAR 0 7
100536: ARRAY
100537: PPUSH
100538: LD_VAR 0 14
100542: PUSH
100543: LD_INT 1
100545: ARRAY
100546: PPUSH
100547: CALL 95870 0 2
100551: GO 100577
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
100553: LD_VAR 0 4
100557: PUSH
100558: LD_VAR 0 7
100562: ARRAY
100563: PPUSH
100564: LD_VAR 0 14
100568: PUSH
100569: LD_INT 1
100571: ARRAY
100572: PPUSH
100573: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
100577: LD_VAR 0 4
100581: PUSH
100582: LD_VAR 0 7
100586: ARRAY
100587: PPUSH
100588: CALL_OW 264
100592: PUSH
100593: LD_INT 29
100595: EQUAL
100596: IFFALSE 100962
// begin if WantsToAttack ( group [ i ] ) in bombed then
100598: LD_VAR 0 4
100602: PUSH
100603: LD_VAR 0 7
100607: ARRAY
100608: PPUSH
100609: CALL_OW 319
100613: PUSH
100614: LD_VAR 0 28
100618: IN
100619: IFFALSE 100623
// continue ;
100621: GO 97653
// k := 8 ;
100623: LD_ADDR_VAR 0 9
100627: PUSH
100628: LD_INT 8
100630: ST_TO_ADDR
// x := 0 ;
100631: LD_ADDR_VAR 0 10
100635: PUSH
100636: LD_INT 0
100638: ST_TO_ADDR
// if tmp < k then
100639: LD_VAR 0 14
100643: PUSH
100644: LD_VAR 0 9
100648: LESS
100649: IFFALSE 100661
// k := tmp ;
100651: LD_ADDR_VAR 0 9
100655: PUSH
100656: LD_VAR 0 14
100660: ST_TO_ADDR
// for j = 1 to k do
100661: LD_ADDR_VAR 0 8
100665: PUSH
100666: DOUBLE
100667: LD_INT 1
100669: DEC
100670: ST_TO_ADDR
100671: LD_VAR 0 9
100675: PUSH
100676: FOR_TO
100677: IFFALSE 100809
// begin if GetType ( tmp [ j ] ) = unit_building then
100679: LD_VAR 0 14
100683: PUSH
100684: LD_VAR 0 8
100688: ARRAY
100689: PPUSH
100690: CALL_OW 247
100694: PUSH
100695: LD_INT 3
100697: EQUAL
100698: IFFALSE 100807
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
100700: LD_VAR 0 14
100704: PUSH
100705: LD_VAR 0 8
100709: ARRAY
100710: PUSH
100711: LD_VAR 0 28
100715: IN
100716: NOT
100717: PUSH
100718: LD_VAR 0 14
100722: PUSH
100723: LD_VAR 0 8
100727: ARRAY
100728: PPUSH
100729: CALL_OW 313
100733: AND
100734: IFFALSE 100807
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
100736: LD_VAR 0 4
100740: PUSH
100741: LD_VAR 0 7
100745: ARRAY
100746: PPUSH
100747: LD_VAR 0 14
100751: PUSH
100752: LD_VAR 0 8
100756: ARRAY
100757: PPUSH
100758: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
100762: LD_ADDR_VAR 0 28
100766: PUSH
100767: LD_VAR 0 28
100771: PPUSH
100772: LD_VAR 0 28
100776: PUSH
100777: LD_INT 1
100779: PLUS
100780: PPUSH
100781: LD_VAR 0 14
100785: PUSH
100786: LD_VAR 0 8
100790: ARRAY
100791: PPUSH
100792: CALL_OW 1
100796: ST_TO_ADDR
// attacking := true ;
100797: LD_ADDR_VAR 0 29
100801: PUSH
100802: LD_INT 1
100804: ST_TO_ADDR
// break ;
100805: GO 100809
// end ; end ;
100807: GO 100676
100809: POP
100810: POP
// if not attacking and f_attack_depot then
100811: LD_VAR 0 29
100815: NOT
100816: PUSH
100817: LD_VAR 0 25
100821: AND
100822: IFFALSE 100917
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
100824: LD_ADDR_VAR 0 13
100828: PUSH
100829: LD_VAR 0 14
100833: PPUSH
100834: LD_INT 2
100836: PUSH
100837: LD_INT 30
100839: PUSH
100840: LD_INT 0
100842: PUSH
100843: EMPTY
100844: LIST
100845: LIST
100846: PUSH
100847: LD_INT 30
100849: PUSH
100850: LD_INT 1
100852: PUSH
100853: EMPTY
100854: LIST
100855: LIST
100856: PUSH
100857: EMPTY
100858: LIST
100859: LIST
100860: LIST
100861: PPUSH
100862: CALL_OW 72
100866: ST_TO_ADDR
// if z then
100867: LD_VAR 0 13
100871: IFFALSE 100917
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
100873: LD_VAR 0 4
100877: PUSH
100878: LD_VAR 0 7
100882: ARRAY
100883: PPUSH
100884: LD_VAR 0 13
100888: PPUSH
100889: LD_VAR 0 4
100893: PUSH
100894: LD_VAR 0 7
100898: ARRAY
100899: PPUSH
100900: CALL_OW 74
100904: PPUSH
100905: CALL_OW 115
// attacking := true ;
100909: LD_ADDR_VAR 0 29
100913: PUSH
100914: LD_INT 1
100916: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
100917: LD_VAR 0 4
100921: PUSH
100922: LD_VAR 0 7
100926: ARRAY
100927: PPUSH
100928: CALL_OW 256
100932: PUSH
100933: LD_INT 500
100935: LESS
100936: IFFALSE 100962
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
100938: LD_VAR 0 4
100942: PUSH
100943: LD_VAR 0 7
100947: ARRAY
100948: PPUSH
100949: LD_VAR 0 14
100953: PUSH
100954: LD_INT 1
100956: ARRAY
100957: PPUSH
100958: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
100962: LD_VAR 0 4
100966: PUSH
100967: LD_VAR 0 7
100971: ARRAY
100972: PPUSH
100973: CALL_OW 264
100977: PUSH
100978: LD_INT 49
100980: EQUAL
100981: IFFALSE 101102
// begin if not HasTask ( group [ i ] ) then
100983: LD_VAR 0 4
100987: PUSH
100988: LD_VAR 0 7
100992: ARRAY
100993: PPUSH
100994: CALL_OW 314
100998: NOT
100999: IFFALSE 101102
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
101001: LD_ADDR_VAR 0 9
101005: PUSH
101006: LD_INT 81
101008: PUSH
101009: LD_VAR 0 4
101013: PUSH
101014: LD_VAR 0 7
101018: ARRAY
101019: PPUSH
101020: CALL_OW 255
101024: PUSH
101025: EMPTY
101026: LIST
101027: LIST
101028: PPUSH
101029: CALL_OW 69
101033: PPUSH
101034: LD_VAR 0 4
101038: PUSH
101039: LD_VAR 0 7
101043: ARRAY
101044: PPUSH
101045: CALL_OW 74
101049: ST_TO_ADDR
// if k then
101050: LD_VAR 0 9
101054: IFFALSE 101102
// if GetDistUnits ( group [ i ] , k ) > 10 then
101056: LD_VAR 0 4
101060: PUSH
101061: LD_VAR 0 7
101065: ARRAY
101066: PPUSH
101067: LD_VAR 0 9
101071: PPUSH
101072: CALL_OW 296
101076: PUSH
101077: LD_INT 10
101079: GREATER
101080: IFFALSE 101102
// ComMoveUnit ( group [ i ] , k ) ;
101082: LD_VAR 0 4
101086: PUSH
101087: LD_VAR 0 7
101091: ARRAY
101092: PPUSH
101093: LD_VAR 0 9
101097: PPUSH
101098: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
101102: LD_VAR 0 4
101106: PUSH
101107: LD_VAR 0 7
101111: ARRAY
101112: PPUSH
101113: CALL_OW 256
101117: PUSH
101118: LD_INT 250
101120: LESS
101121: PUSH
101122: LD_VAR 0 4
101126: PUSH
101127: LD_VAR 0 7
101131: ARRAY
101132: PUSH
101133: LD_INT 21
101135: PUSH
101136: LD_INT 2
101138: PUSH
101139: EMPTY
101140: LIST
101141: LIST
101142: PUSH
101143: LD_INT 23
101145: PUSH
101146: LD_INT 2
101148: PUSH
101149: EMPTY
101150: LIST
101151: LIST
101152: PUSH
101153: EMPTY
101154: LIST
101155: LIST
101156: PPUSH
101157: CALL_OW 69
101161: IN
101162: AND
101163: IFFALSE 101288
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
101165: LD_ADDR_VAR 0 9
101169: PUSH
101170: LD_OWVAR 3
101174: PUSH
101175: LD_VAR 0 4
101179: PUSH
101180: LD_VAR 0 7
101184: ARRAY
101185: DIFF
101186: PPUSH
101187: LD_VAR 0 4
101191: PUSH
101192: LD_VAR 0 7
101196: ARRAY
101197: PPUSH
101198: CALL_OW 74
101202: ST_TO_ADDR
// if not k then
101203: LD_VAR 0 9
101207: NOT
101208: IFFALSE 101212
// continue ;
101210: GO 97653
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
101212: LD_VAR 0 9
101216: PUSH
101217: LD_INT 81
101219: PUSH
101220: LD_VAR 0 4
101224: PUSH
101225: LD_VAR 0 7
101229: ARRAY
101230: PPUSH
101231: CALL_OW 255
101235: PUSH
101236: EMPTY
101237: LIST
101238: LIST
101239: PPUSH
101240: CALL_OW 69
101244: IN
101245: PUSH
101246: LD_VAR 0 9
101250: PPUSH
101251: LD_VAR 0 4
101255: PUSH
101256: LD_VAR 0 7
101260: ARRAY
101261: PPUSH
101262: CALL_OW 296
101266: PUSH
101267: LD_INT 5
101269: LESS
101270: AND
101271: IFFALSE 101288
// ComAutodestruct ( group [ i ] ) ;
101273: LD_VAR 0 4
101277: PUSH
101278: LD_VAR 0 7
101282: ARRAY
101283: PPUSH
101284: CALL 95768 0 1
// end ; if f_attack_depot then
101288: LD_VAR 0 25
101292: IFFALSE 101404
// begin k := 6 ;
101294: LD_ADDR_VAR 0 9
101298: PUSH
101299: LD_INT 6
101301: ST_TO_ADDR
// if tmp < k then
101302: LD_VAR 0 14
101306: PUSH
101307: LD_VAR 0 9
101311: LESS
101312: IFFALSE 101324
// k := tmp ;
101314: LD_ADDR_VAR 0 9
101318: PUSH
101319: LD_VAR 0 14
101323: ST_TO_ADDR
// for j = 1 to k do
101324: LD_ADDR_VAR 0 8
101328: PUSH
101329: DOUBLE
101330: LD_INT 1
101332: DEC
101333: ST_TO_ADDR
101334: LD_VAR 0 9
101338: PUSH
101339: FOR_TO
101340: IFFALSE 101402
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
101342: LD_VAR 0 8
101346: PPUSH
101347: CALL_OW 266
101351: PUSH
101352: LD_INT 0
101354: PUSH
101355: LD_INT 1
101357: PUSH
101358: EMPTY
101359: LIST
101360: LIST
101361: IN
101362: IFFALSE 101400
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
101364: LD_VAR 0 4
101368: PUSH
101369: LD_VAR 0 7
101373: ARRAY
101374: PPUSH
101375: LD_VAR 0 14
101379: PUSH
101380: LD_VAR 0 8
101384: ARRAY
101385: PPUSH
101386: CALL_OW 115
// attacking := true ;
101390: LD_ADDR_VAR 0 29
101394: PUSH
101395: LD_INT 1
101397: ST_TO_ADDR
// break ;
101398: GO 101402
// end ;
101400: GO 101339
101402: POP
101403: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
101404: LD_VAR 0 4
101408: PUSH
101409: LD_VAR 0 7
101413: ARRAY
101414: PPUSH
101415: CALL_OW 302
101419: PUSH
101420: LD_VAR 0 29
101424: NOT
101425: AND
101426: IFFALSE 101748
// begin if GetTag ( group [ i ] ) = 71 then
101428: LD_VAR 0 4
101432: PUSH
101433: LD_VAR 0 7
101437: ARRAY
101438: PPUSH
101439: CALL_OW 110
101443: PUSH
101444: LD_INT 71
101446: EQUAL
101447: IFFALSE 101488
// begin if HasTask ( group [ i ] ) then
101449: LD_VAR 0 4
101453: PUSH
101454: LD_VAR 0 7
101458: ARRAY
101459: PPUSH
101460: CALL_OW 314
101464: IFFALSE 101470
// continue else
101466: GO 97653
101468: GO 101488
// SetTag ( group [ i ] , 0 ) ;
101470: LD_VAR 0 4
101474: PUSH
101475: LD_VAR 0 7
101479: ARRAY
101480: PPUSH
101481: LD_INT 0
101483: PPUSH
101484: CALL_OW 109
// end ; k := 8 ;
101488: LD_ADDR_VAR 0 9
101492: PUSH
101493: LD_INT 8
101495: ST_TO_ADDR
// x := 0 ;
101496: LD_ADDR_VAR 0 10
101500: PUSH
101501: LD_INT 0
101503: ST_TO_ADDR
// if tmp < k then
101504: LD_VAR 0 14
101508: PUSH
101509: LD_VAR 0 9
101513: LESS
101514: IFFALSE 101526
// k := tmp ;
101516: LD_ADDR_VAR 0 9
101520: PUSH
101521: LD_VAR 0 14
101525: ST_TO_ADDR
// for j = 1 to k do
101526: LD_ADDR_VAR 0 8
101530: PUSH
101531: DOUBLE
101532: LD_INT 1
101534: DEC
101535: ST_TO_ADDR
101536: LD_VAR 0 9
101540: PUSH
101541: FOR_TO
101542: IFFALSE 101640
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
101544: LD_VAR 0 14
101548: PUSH
101549: LD_VAR 0 8
101553: ARRAY
101554: PPUSH
101555: CALL_OW 247
101559: PUSH
101560: LD_INT 1
101562: EQUAL
101563: PUSH
101564: LD_VAR 0 14
101568: PUSH
101569: LD_VAR 0 8
101573: ARRAY
101574: PPUSH
101575: CALL_OW 256
101579: PUSH
101580: LD_INT 250
101582: LESS
101583: PUSH
101584: LD_VAR 0 20
101588: AND
101589: PUSH
101590: LD_VAR 0 20
101594: NOT
101595: PUSH
101596: LD_VAR 0 14
101600: PUSH
101601: LD_VAR 0 8
101605: ARRAY
101606: PPUSH
101607: CALL_OW 256
101611: PUSH
101612: LD_INT 250
101614: GREATEREQUAL
101615: AND
101616: OR
101617: AND
101618: IFFALSE 101638
// begin x := tmp [ j ] ;
101620: LD_ADDR_VAR 0 10
101624: PUSH
101625: LD_VAR 0 14
101629: PUSH
101630: LD_VAR 0 8
101634: ARRAY
101635: ST_TO_ADDR
// break ;
101636: GO 101640
// end ;
101638: GO 101541
101640: POP
101641: POP
// if x then
101642: LD_VAR 0 10
101646: IFFALSE 101670
// ComAttackUnit ( group [ i ] , x ) else
101648: LD_VAR 0 4
101652: PUSH
101653: LD_VAR 0 7
101657: ARRAY
101658: PPUSH
101659: LD_VAR 0 10
101663: PPUSH
101664: CALL_OW 115
101668: GO 101694
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101670: LD_VAR 0 4
101674: PUSH
101675: LD_VAR 0 7
101679: ARRAY
101680: PPUSH
101681: LD_VAR 0 14
101685: PUSH
101686: LD_INT 1
101688: ARRAY
101689: PPUSH
101690: CALL_OW 115
// if not HasTask ( group [ i ] ) then
101694: LD_VAR 0 4
101698: PUSH
101699: LD_VAR 0 7
101703: ARRAY
101704: PPUSH
101705: CALL_OW 314
101709: NOT
101710: IFFALSE 101748
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
101712: LD_VAR 0 4
101716: PUSH
101717: LD_VAR 0 7
101721: ARRAY
101722: PPUSH
101723: LD_VAR 0 14
101727: PPUSH
101728: LD_VAR 0 4
101732: PUSH
101733: LD_VAR 0 7
101737: ARRAY
101738: PPUSH
101739: CALL_OW 74
101743: PPUSH
101744: CALL_OW 115
// end ; end ; end ;
101748: GO 97653
101750: POP
101751: POP
// wait ( 0 0$1 ) ;
101752: LD_INT 35
101754: PPUSH
101755: CALL_OW 67
// until group = [ ] ;
101759: LD_VAR 0 4
101763: PUSH
101764: EMPTY
101765: EQUAL
101766: IFFALSE 97638
// end ;
101768: LD_VAR 0 2
101772: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
101773: LD_INT 0
101775: PPUSH
101776: PPUSH
101777: PPUSH
101778: PPUSH
// if not base_units then
101779: LD_VAR 0 1
101783: NOT
101784: IFFALSE 101788
// exit ;
101786: GO 101875
// result := false ;
101788: LD_ADDR_VAR 0 2
101792: PUSH
101793: LD_INT 0
101795: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
101796: LD_ADDR_VAR 0 5
101800: PUSH
101801: LD_VAR 0 1
101805: PPUSH
101806: LD_INT 21
101808: PUSH
101809: LD_INT 3
101811: PUSH
101812: EMPTY
101813: LIST
101814: LIST
101815: PPUSH
101816: CALL_OW 72
101820: ST_TO_ADDR
// if not tmp then
101821: LD_VAR 0 5
101825: NOT
101826: IFFALSE 101830
// exit ;
101828: GO 101875
// for i in tmp do
101830: LD_ADDR_VAR 0 3
101834: PUSH
101835: LD_VAR 0 5
101839: PUSH
101840: FOR_IN
101841: IFFALSE 101873
// begin result := EnemyInRange ( i , 22 ) ;
101843: LD_ADDR_VAR 0 2
101847: PUSH
101848: LD_VAR 0 3
101852: PPUSH
101853: LD_INT 22
101855: PPUSH
101856: CALL 95451 0 2
101860: ST_TO_ADDR
// if result then
101861: LD_VAR 0 2
101865: IFFALSE 101871
// exit ;
101867: POP
101868: POP
101869: GO 101875
// end ;
101871: GO 101840
101873: POP
101874: POP
// end ;
101875: LD_VAR 0 2
101879: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
101880: LD_INT 0
101882: PPUSH
101883: PPUSH
// if not units then
101884: LD_VAR 0 1
101888: NOT
101889: IFFALSE 101893
// exit ;
101891: GO 101963
// result := [ ] ;
101893: LD_ADDR_VAR 0 3
101897: PUSH
101898: EMPTY
101899: ST_TO_ADDR
// for i in units do
101900: LD_ADDR_VAR 0 4
101904: PUSH
101905: LD_VAR 0 1
101909: PUSH
101910: FOR_IN
101911: IFFALSE 101961
// if GetTag ( i ) = tag then
101913: LD_VAR 0 4
101917: PPUSH
101918: CALL_OW 110
101922: PUSH
101923: LD_VAR 0 2
101927: EQUAL
101928: IFFALSE 101959
// result := Insert ( result , result + 1 , i ) ;
101930: LD_ADDR_VAR 0 3
101934: PUSH
101935: LD_VAR 0 3
101939: PPUSH
101940: LD_VAR 0 3
101944: PUSH
101945: LD_INT 1
101947: PLUS
101948: PPUSH
101949: LD_VAR 0 4
101953: PPUSH
101954: CALL_OW 2
101958: ST_TO_ADDR
101959: GO 101910
101961: POP
101962: POP
// end ;
101963: LD_VAR 0 3
101967: RET
// export function IsDriver ( un ) ; begin
101968: LD_INT 0
101970: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
101971: LD_ADDR_VAR 0 2
101975: PUSH
101976: LD_VAR 0 1
101980: PUSH
101981: LD_INT 55
101983: PUSH
101984: EMPTY
101985: LIST
101986: PPUSH
101987: CALL_OW 69
101991: IN
101992: ST_TO_ADDR
// end ;
101993: LD_VAR 0 2
101997: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
101998: LD_INT 0
102000: PPUSH
102001: PPUSH
// list := [ ] ;
102002: LD_ADDR_VAR 0 5
102006: PUSH
102007: EMPTY
102008: ST_TO_ADDR
// case d of 0 :
102009: LD_VAR 0 3
102013: PUSH
102014: LD_INT 0
102016: DOUBLE
102017: EQUAL
102018: IFTRUE 102022
102020: GO 102155
102022: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
102023: LD_ADDR_VAR 0 5
102027: PUSH
102028: LD_VAR 0 1
102032: PUSH
102033: LD_INT 4
102035: MINUS
102036: PUSH
102037: LD_VAR 0 2
102041: PUSH
102042: LD_INT 4
102044: MINUS
102045: PUSH
102046: LD_INT 2
102048: PUSH
102049: EMPTY
102050: LIST
102051: LIST
102052: LIST
102053: PUSH
102054: LD_VAR 0 1
102058: PUSH
102059: LD_INT 3
102061: MINUS
102062: PUSH
102063: LD_VAR 0 2
102067: PUSH
102068: LD_INT 1
102070: PUSH
102071: EMPTY
102072: LIST
102073: LIST
102074: LIST
102075: PUSH
102076: LD_VAR 0 1
102080: PUSH
102081: LD_INT 4
102083: PLUS
102084: PUSH
102085: LD_VAR 0 2
102089: PUSH
102090: LD_INT 4
102092: PUSH
102093: EMPTY
102094: LIST
102095: LIST
102096: LIST
102097: PUSH
102098: LD_VAR 0 1
102102: PUSH
102103: LD_INT 3
102105: PLUS
102106: PUSH
102107: LD_VAR 0 2
102111: PUSH
102112: LD_INT 3
102114: PLUS
102115: PUSH
102116: LD_INT 5
102118: PUSH
102119: EMPTY
102120: LIST
102121: LIST
102122: LIST
102123: PUSH
102124: LD_VAR 0 1
102128: PUSH
102129: LD_VAR 0 2
102133: PUSH
102134: LD_INT 4
102136: PLUS
102137: PUSH
102138: LD_INT 0
102140: PUSH
102141: EMPTY
102142: LIST
102143: LIST
102144: LIST
102145: PUSH
102146: EMPTY
102147: LIST
102148: LIST
102149: LIST
102150: LIST
102151: LIST
102152: ST_TO_ADDR
// end ; 1 :
102153: GO 102853
102155: LD_INT 1
102157: DOUBLE
102158: EQUAL
102159: IFTRUE 102163
102161: GO 102296
102163: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
102164: LD_ADDR_VAR 0 5
102168: PUSH
102169: LD_VAR 0 1
102173: PUSH
102174: LD_VAR 0 2
102178: PUSH
102179: LD_INT 4
102181: MINUS
102182: PUSH
102183: LD_INT 3
102185: PUSH
102186: EMPTY
102187: LIST
102188: LIST
102189: LIST
102190: PUSH
102191: LD_VAR 0 1
102195: PUSH
102196: LD_INT 3
102198: MINUS
102199: PUSH
102200: LD_VAR 0 2
102204: PUSH
102205: LD_INT 3
102207: MINUS
102208: PUSH
102209: LD_INT 2
102211: PUSH
102212: EMPTY
102213: LIST
102214: LIST
102215: LIST
102216: PUSH
102217: LD_VAR 0 1
102221: PUSH
102222: LD_INT 4
102224: MINUS
102225: PUSH
102226: LD_VAR 0 2
102230: PUSH
102231: LD_INT 1
102233: PUSH
102234: EMPTY
102235: LIST
102236: LIST
102237: LIST
102238: PUSH
102239: LD_VAR 0 1
102243: PUSH
102244: LD_VAR 0 2
102248: PUSH
102249: LD_INT 3
102251: PLUS
102252: PUSH
102253: LD_INT 0
102255: PUSH
102256: EMPTY
102257: LIST
102258: LIST
102259: LIST
102260: PUSH
102261: LD_VAR 0 1
102265: PUSH
102266: LD_INT 4
102268: PLUS
102269: PUSH
102270: LD_VAR 0 2
102274: PUSH
102275: LD_INT 4
102277: PLUS
102278: PUSH
102279: LD_INT 5
102281: PUSH
102282: EMPTY
102283: LIST
102284: LIST
102285: LIST
102286: PUSH
102287: EMPTY
102288: LIST
102289: LIST
102290: LIST
102291: LIST
102292: LIST
102293: ST_TO_ADDR
// end ; 2 :
102294: GO 102853
102296: LD_INT 2
102298: DOUBLE
102299: EQUAL
102300: IFTRUE 102304
102302: GO 102433
102304: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
102305: LD_ADDR_VAR 0 5
102309: PUSH
102310: LD_VAR 0 1
102314: PUSH
102315: LD_VAR 0 2
102319: PUSH
102320: LD_INT 3
102322: MINUS
102323: PUSH
102324: LD_INT 3
102326: PUSH
102327: EMPTY
102328: LIST
102329: LIST
102330: LIST
102331: PUSH
102332: LD_VAR 0 1
102336: PUSH
102337: LD_INT 4
102339: PLUS
102340: PUSH
102341: LD_VAR 0 2
102345: PUSH
102346: LD_INT 4
102348: PUSH
102349: EMPTY
102350: LIST
102351: LIST
102352: LIST
102353: PUSH
102354: LD_VAR 0 1
102358: PUSH
102359: LD_VAR 0 2
102363: PUSH
102364: LD_INT 4
102366: PLUS
102367: PUSH
102368: LD_INT 0
102370: PUSH
102371: EMPTY
102372: LIST
102373: LIST
102374: LIST
102375: PUSH
102376: LD_VAR 0 1
102380: PUSH
102381: LD_INT 3
102383: MINUS
102384: PUSH
102385: LD_VAR 0 2
102389: PUSH
102390: LD_INT 1
102392: PUSH
102393: EMPTY
102394: LIST
102395: LIST
102396: LIST
102397: PUSH
102398: LD_VAR 0 1
102402: PUSH
102403: LD_INT 4
102405: MINUS
102406: PUSH
102407: LD_VAR 0 2
102411: PUSH
102412: LD_INT 4
102414: MINUS
102415: PUSH
102416: LD_INT 2
102418: PUSH
102419: EMPTY
102420: LIST
102421: LIST
102422: LIST
102423: PUSH
102424: EMPTY
102425: LIST
102426: LIST
102427: LIST
102428: LIST
102429: LIST
102430: ST_TO_ADDR
// end ; 3 :
102431: GO 102853
102433: LD_INT 3
102435: DOUBLE
102436: EQUAL
102437: IFTRUE 102441
102439: GO 102574
102441: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
102442: LD_ADDR_VAR 0 5
102446: PUSH
102447: LD_VAR 0 1
102451: PUSH
102452: LD_INT 3
102454: PLUS
102455: PUSH
102456: LD_VAR 0 2
102460: PUSH
102461: LD_INT 4
102463: PUSH
102464: EMPTY
102465: LIST
102466: LIST
102467: LIST
102468: PUSH
102469: LD_VAR 0 1
102473: PUSH
102474: LD_INT 4
102476: PLUS
102477: PUSH
102478: LD_VAR 0 2
102482: PUSH
102483: LD_INT 4
102485: PLUS
102486: PUSH
102487: LD_INT 5
102489: PUSH
102490: EMPTY
102491: LIST
102492: LIST
102493: LIST
102494: PUSH
102495: LD_VAR 0 1
102499: PUSH
102500: LD_INT 4
102502: MINUS
102503: PUSH
102504: LD_VAR 0 2
102508: PUSH
102509: LD_INT 1
102511: PUSH
102512: EMPTY
102513: LIST
102514: LIST
102515: LIST
102516: PUSH
102517: LD_VAR 0 1
102521: PUSH
102522: LD_VAR 0 2
102526: PUSH
102527: LD_INT 4
102529: MINUS
102530: PUSH
102531: LD_INT 3
102533: PUSH
102534: EMPTY
102535: LIST
102536: LIST
102537: LIST
102538: PUSH
102539: LD_VAR 0 1
102543: PUSH
102544: LD_INT 3
102546: MINUS
102547: PUSH
102548: LD_VAR 0 2
102552: PUSH
102553: LD_INT 3
102555: MINUS
102556: PUSH
102557: LD_INT 2
102559: PUSH
102560: EMPTY
102561: LIST
102562: LIST
102563: LIST
102564: PUSH
102565: EMPTY
102566: LIST
102567: LIST
102568: LIST
102569: LIST
102570: LIST
102571: ST_TO_ADDR
// end ; 4 :
102572: GO 102853
102574: LD_INT 4
102576: DOUBLE
102577: EQUAL
102578: IFTRUE 102582
102580: GO 102715
102582: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
102583: LD_ADDR_VAR 0 5
102587: PUSH
102588: LD_VAR 0 1
102592: PUSH
102593: LD_VAR 0 2
102597: PUSH
102598: LD_INT 4
102600: PLUS
102601: PUSH
102602: LD_INT 0
102604: PUSH
102605: EMPTY
102606: LIST
102607: LIST
102608: LIST
102609: PUSH
102610: LD_VAR 0 1
102614: PUSH
102615: LD_INT 3
102617: PLUS
102618: PUSH
102619: LD_VAR 0 2
102623: PUSH
102624: LD_INT 3
102626: PLUS
102627: PUSH
102628: LD_INT 5
102630: PUSH
102631: EMPTY
102632: LIST
102633: LIST
102634: LIST
102635: PUSH
102636: LD_VAR 0 1
102640: PUSH
102641: LD_INT 4
102643: PLUS
102644: PUSH
102645: LD_VAR 0 2
102649: PUSH
102650: LD_INT 4
102652: PUSH
102653: EMPTY
102654: LIST
102655: LIST
102656: LIST
102657: PUSH
102658: LD_VAR 0 1
102662: PUSH
102663: LD_VAR 0 2
102667: PUSH
102668: LD_INT 3
102670: MINUS
102671: PUSH
102672: LD_INT 3
102674: PUSH
102675: EMPTY
102676: LIST
102677: LIST
102678: LIST
102679: PUSH
102680: LD_VAR 0 1
102684: PUSH
102685: LD_INT 4
102687: MINUS
102688: PUSH
102689: LD_VAR 0 2
102693: PUSH
102694: LD_INT 4
102696: MINUS
102697: PUSH
102698: LD_INT 2
102700: PUSH
102701: EMPTY
102702: LIST
102703: LIST
102704: LIST
102705: PUSH
102706: EMPTY
102707: LIST
102708: LIST
102709: LIST
102710: LIST
102711: LIST
102712: ST_TO_ADDR
// end ; 5 :
102713: GO 102853
102715: LD_INT 5
102717: DOUBLE
102718: EQUAL
102719: IFTRUE 102723
102721: GO 102852
102723: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
102724: LD_ADDR_VAR 0 5
102728: PUSH
102729: LD_VAR 0 1
102733: PUSH
102734: LD_INT 4
102736: MINUS
102737: PUSH
102738: LD_VAR 0 2
102742: PUSH
102743: LD_INT 1
102745: PUSH
102746: EMPTY
102747: LIST
102748: LIST
102749: LIST
102750: PUSH
102751: LD_VAR 0 1
102755: PUSH
102756: LD_VAR 0 2
102760: PUSH
102761: LD_INT 4
102763: MINUS
102764: PUSH
102765: LD_INT 3
102767: PUSH
102768: EMPTY
102769: LIST
102770: LIST
102771: LIST
102772: PUSH
102773: LD_VAR 0 1
102777: PUSH
102778: LD_INT 4
102780: PLUS
102781: PUSH
102782: LD_VAR 0 2
102786: PUSH
102787: LD_INT 4
102789: PLUS
102790: PUSH
102791: LD_INT 5
102793: PUSH
102794: EMPTY
102795: LIST
102796: LIST
102797: LIST
102798: PUSH
102799: LD_VAR 0 1
102803: PUSH
102804: LD_INT 3
102806: PLUS
102807: PUSH
102808: LD_VAR 0 2
102812: PUSH
102813: LD_INT 4
102815: PUSH
102816: EMPTY
102817: LIST
102818: LIST
102819: LIST
102820: PUSH
102821: LD_VAR 0 1
102825: PUSH
102826: LD_VAR 0 2
102830: PUSH
102831: LD_INT 3
102833: PLUS
102834: PUSH
102835: LD_INT 0
102837: PUSH
102838: EMPTY
102839: LIST
102840: LIST
102841: LIST
102842: PUSH
102843: EMPTY
102844: LIST
102845: LIST
102846: LIST
102847: LIST
102848: LIST
102849: ST_TO_ADDR
// end ; end ;
102850: GO 102853
102852: POP
// result := list ;
102853: LD_ADDR_VAR 0 4
102857: PUSH
102858: LD_VAR 0 5
102862: ST_TO_ADDR
// end ;
102863: LD_VAR 0 4
102867: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
102868: LD_INT 0
102870: PPUSH
102871: PPUSH
102872: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
102873: LD_VAR 0 1
102877: NOT
102878: PUSH
102879: LD_VAR 0 2
102883: PUSH
102884: LD_INT 1
102886: PUSH
102887: LD_INT 2
102889: PUSH
102890: LD_INT 3
102892: PUSH
102893: LD_INT 4
102895: PUSH
102896: EMPTY
102897: LIST
102898: LIST
102899: LIST
102900: LIST
102901: IN
102902: NOT
102903: OR
102904: IFFALSE 102908
// exit ;
102906: GO 103000
// tmp := [ ] ;
102908: LD_ADDR_VAR 0 5
102912: PUSH
102913: EMPTY
102914: ST_TO_ADDR
// for i in units do
102915: LD_ADDR_VAR 0 4
102919: PUSH
102920: LD_VAR 0 1
102924: PUSH
102925: FOR_IN
102926: IFFALSE 102969
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
102928: LD_ADDR_VAR 0 5
102932: PUSH
102933: LD_VAR 0 5
102937: PPUSH
102938: LD_VAR 0 5
102942: PUSH
102943: LD_INT 1
102945: PLUS
102946: PPUSH
102947: LD_VAR 0 4
102951: PPUSH
102952: LD_VAR 0 2
102956: PPUSH
102957: CALL_OW 259
102961: PPUSH
102962: CALL_OW 2
102966: ST_TO_ADDR
102967: GO 102925
102969: POP
102970: POP
// if not tmp then
102971: LD_VAR 0 5
102975: NOT
102976: IFFALSE 102980
// exit ;
102978: GO 103000
// result := SortListByListDesc ( units , tmp ) ;
102980: LD_ADDR_VAR 0 3
102984: PUSH
102985: LD_VAR 0 1
102989: PPUSH
102990: LD_VAR 0 5
102994: PPUSH
102995: CALL_OW 77
102999: ST_TO_ADDR
// end ;
103000: LD_VAR 0 3
103004: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
103005: LD_INT 0
103007: PPUSH
103008: PPUSH
103009: PPUSH
// x := GetX ( building ) ;
103010: LD_ADDR_VAR 0 4
103014: PUSH
103015: LD_VAR 0 2
103019: PPUSH
103020: CALL_OW 250
103024: ST_TO_ADDR
// y := GetY ( building ) ;
103025: LD_ADDR_VAR 0 5
103029: PUSH
103030: LD_VAR 0 2
103034: PPUSH
103035: CALL_OW 251
103039: ST_TO_ADDR
// if GetTaskList ( unit ) then
103040: LD_VAR 0 1
103044: PPUSH
103045: CALL_OW 437
103049: IFFALSE 103144
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
103051: LD_STRING e
103053: PUSH
103054: LD_VAR 0 1
103058: PPUSH
103059: CALL_OW 437
103063: PUSH
103064: LD_INT 1
103066: ARRAY
103067: PUSH
103068: LD_INT 1
103070: ARRAY
103071: EQUAL
103072: PUSH
103073: LD_VAR 0 4
103077: PUSH
103078: LD_VAR 0 1
103082: PPUSH
103083: CALL_OW 437
103087: PUSH
103088: LD_INT 1
103090: ARRAY
103091: PUSH
103092: LD_INT 2
103094: ARRAY
103095: EQUAL
103096: AND
103097: PUSH
103098: LD_VAR 0 5
103102: PUSH
103103: LD_VAR 0 1
103107: PPUSH
103108: CALL_OW 437
103112: PUSH
103113: LD_INT 1
103115: ARRAY
103116: PUSH
103117: LD_INT 3
103119: ARRAY
103120: EQUAL
103121: AND
103122: IFFALSE 103134
// result := true else
103124: LD_ADDR_VAR 0 3
103128: PUSH
103129: LD_INT 1
103131: ST_TO_ADDR
103132: GO 103142
// result := false ;
103134: LD_ADDR_VAR 0 3
103138: PUSH
103139: LD_INT 0
103141: ST_TO_ADDR
// end else
103142: GO 103152
// result := false ;
103144: LD_ADDR_VAR 0 3
103148: PUSH
103149: LD_INT 0
103151: ST_TO_ADDR
// end ;
103152: LD_VAR 0 3
103156: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
103157: LD_INT 0
103159: PPUSH
103160: PPUSH
103161: PPUSH
103162: PPUSH
// if not unit or not area then
103163: LD_VAR 0 1
103167: NOT
103168: PUSH
103169: LD_VAR 0 2
103173: NOT
103174: OR
103175: IFFALSE 103179
// exit ;
103177: GO 103344
// tmp := AreaToList ( area , i ) ;
103179: LD_ADDR_VAR 0 6
103183: PUSH
103184: LD_VAR 0 2
103188: PPUSH
103189: LD_VAR 0 5
103193: PPUSH
103194: CALL_OW 517
103198: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
103199: LD_ADDR_VAR 0 5
103203: PUSH
103204: DOUBLE
103205: LD_INT 1
103207: DEC
103208: ST_TO_ADDR
103209: LD_VAR 0 6
103213: PUSH
103214: LD_INT 1
103216: ARRAY
103217: PUSH
103218: FOR_TO
103219: IFFALSE 103334
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
103221: LD_ADDR_VAR 0 7
103225: PUSH
103226: LD_VAR 0 6
103230: PUSH
103231: LD_INT 1
103233: ARRAY
103234: PUSH
103235: LD_VAR 0 5
103239: ARRAY
103240: PUSH
103241: LD_VAR 0 6
103245: PUSH
103246: LD_INT 2
103248: ARRAY
103249: PUSH
103250: LD_VAR 0 5
103254: ARRAY
103255: PUSH
103256: EMPTY
103257: LIST
103258: LIST
103259: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
103260: LD_VAR 0 7
103264: PUSH
103265: LD_INT 1
103267: ARRAY
103268: PPUSH
103269: LD_VAR 0 7
103273: PUSH
103274: LD_INT 2
103276: ARRAY
103277: PPUSH
103278: CALL_OW 428
103282: PUSH
103283: LD_INT 0
103285: EQUAL
103286: IFFALSE 103332
// begin result := true ;
103288: LD_ADDR_VAR 0 4
103292: PUSH
103293: LD_INT 1
103295: ST_TO_ADDR
// PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
103296: LD_VAR 0 1
103300: PPUSH
103301: LD_VAR 0 7
103305: PUSH
103306: LD_INT 1
103308: ARRAY
103309: PPUSH
103310: LD_VAR 0 7
103314: PUSH
103315: LD_INT 2
103317: ARRAY
103318: PPUSH
103319: LD_VAR 0 3
103323: PPUSH
103324: CALL_OW 48
// exit ;
103328: POP
103329: POP
103330: GO 103344
// end ; end ;
103332: GO 103218
103334: POP
103335: POP
// result := false ;
103336: LD_ADDR_VAR 0 4
103340: PUSH
103341: LD_INT 0
103343: ST_TO_ADDR
// end ;
103344: LD_VAR 0 4
103348: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
103349: LD_INT 0
103351: PPUSH
103352: PPUSH
103353: PPUSH
// if not side or side > 8 then
103354: LD_VAR 0 1
103358: NOT
103359: PUSH
103360: LD_VAR 0 1
103364: PUSH
103365: LD_INT 8
103367: GREATER
103368: OR
103369: IFFALSE 103373
// exit ;
103371: GO 103560
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
103373: LD_ADDR_VAR 0 4
103377: PUSH
103378: LD_INT 22
103380: PUSH
103381: LD_VAR 0 1
103385: PUSH
103386: EMPTY
103387: LIST
103388: LIST
103389: PUSH
103390: LD_INT 21
103392: PUSH
103393: LD_INT 3
103395: PUSH
103396: EMPTY
103397: LIST
103398: LIST
103399: PUSH
103400: EMPTY
103401: LIST
103402: LIST
103403: PPUSH
103404: CALL_OW 69
103408: ST_TO_ADDR
// if not tmp then
103409: LD_VAR 0 4
103413: NOT
103414: IFFALSE 103418
// exit ;
103416: GO 103560
// enable_addtolog := true ;
103418: LD_ADDR_OWVAR 81
103422: PUSH
103423: LD_INT 1
103425: ST_TO_ADDR
// AddToLog ( [ ) ;
103426: LD_STRING [
103428: PPUSH
103429: CALL_OW 561
// for i in tmp do
103433: LD_ADDR_VAR 0 3
103437: PUSH
103438: LD_VAR 0 4
103442: PUSH
103443: FOR_IN
103444: IFFALSE 103551
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
103446: LD_STRING [
103448: PUSH
103449: LD_VAR 0 3
103453: PPUSH
103454: CALL_OW 266
103458: STR
103459: PUSH
103460: LD_STRING , 
103462: STR
103463: PUSH
103464: LD_VAR 0 3
103468: PPUSH
103469: CALL_OW 250
103473: STR
103474: PUSH
103475: LD_STRING , 
103477: STR
103478: PUSH
103479: LD_VAR 0 3
103483: PPUSH
103484: CALL_OW 251
103488: STR
103489: PUSH
103490: LD_STRING , 
103492: STR
103493: PUSH
103494: LD_VAR 0 3
103498: PPUSH
103499: CALL_OW 254
103503: STR
103504: PUSH
103505: LD_STRING , 
103507: STR
103508: PUSH
103509: LD_VAR 0 3
103513: PPUSH
103514: LD_INT 1
103516: PPUSH
103517: CALL_OW 268
103521: STR
103522: PUSH
103523: LD_STRING , 
103525: STR
103526: PUSH
103527: LD_VAR 0 3
103531: PPUSH
103532: LD_INT 2
103534: PPUSH
103535: CALL_OW 268
103539: STR
103540: PUSH
103541: LD_STRING ],
103543: STR
103544: PPUSH
103545: CALL_OW 561
// end ;
103549: GO 103443
103551: POP
103552: POP
// AddToLog ( ]; ) ;
103553: LD_STRING ];
103555: PPUSH
103556: CALL_OW 561
// end ;
103560: LD_VAR 0 2
103564: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
103565: LD_INT 0
103567: PPUSH
103568: PPUSH
103569: PPUSH
103570: PPUSH
103571: PPUSH
// if not area or not rate or not max then
103572: LD_VAR 0 1
103576: NOT
103577: PUSH
103578: LD_VAR 0 2
103582: NOT
103583: OR
103584: PUSH
103585: LD_VAR 0 4
103589: NOT
103590: OR
103591: IFFALSE 103595
// exit ;
103593: GO 103787
// while 1 do
103595: LD_INT 1
103597: IFFALSE 103787
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
103599: LD_ADDR_VAR 0 9
103603: PUSH
103604: LD_VAR 0 1
103608: PPUSH
103609: LD_INT 1
103611: PPUSH
103612: CALL_OW 287
103616: PUSH
103617: LD_INT 10
103619: MUL
103620: ST_TO_ADDR
// r := rate / 10 ;
103621: LD_ADDR_VAR 0 7
103625: PUSH
103626: LD_VAR 0 2
103630: PUSH
103631: LD_INT 10
103633: DIVREAL
103634: ST_TO_ADDR
// time := 1 1$00 ;
103635: LD_ADDR_VAR 0 8
103639: PUSH
103640: LD_INT 2100
103642: ST_TO_ADDR
// if amount < min then
103643: LD_VAR 0 9
103647: PUSH
103648: LD_VAR 0 3
103652: LESS
103653: IFFALSE 103671
// r := r * 2 else
103655: LD_ADDR_VAR 0 7
103659: PUSH
103660: LD_VAR 0 7
103664: PUSH
103665: LD_INT 2
103667: MUL
103668: ST_TO_ADDR
103669: GO 103697
// if amount > max then
103671: LD_VAR 0 9
103675: PUSH
103676: LD_VAR 0 4
103680: GREATER
103681: IFFALSE 103697
// r := r / 2 ;
103683: LD_ADDR_VAR 0 7
103687: PUSH
103688: LD_VAR 0 7
103692: PUSH
103693: LD_INT 2
103695: DIVREAL
103696: ST_TO_ADDR
// time := time / r ;
103697: LD_ADDR_VAR 0 8
103701: PUSH
103702: LD_VAR 0 8
103706: PUSH
103707: LD_VAR 0 7
103711: DIVREAL
103712: ST_TO_ADDR
// if time < 0 then
103713: LD_VAR 0 8
103717: PUSH
103718: LD_INT 0
103720: LESS
103721: IFFALSE 103738
// time := time * - 1 ;
103723: LD_ADDR_VAR 0 8
103727: PUSH
103728: LD_VAR 0 8
103732: PUSH
103733: LD_INT 1
103735: NEG
103736: MUL
103737: ST_TO_ADDR
// wait ( time ) ;
103738: LD_VAR 0 8
103742: PPUSH
103743: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
103747: LD_INT 35
103749: PPUSH
103750: LD_INT 875
103752: PPUSH
103753: CALL_OW 12
103757: PPUSH
103758: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
103762: LD_INT 1
103764: PPUSH
103765: LD_INT 5
103767: PPUSH
103768: CALL_OW 12
103772: PPUSH
103773: LD_VAR 0 1
103777: PPUSH
103778: LD_INT 1
103780: PPUSH
103781: CALL_OW 55
// end ;
103785: GO 103595
// end ;
103787: LD_VAR 0 5
103791: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
103792: LD_INT 0
103794: PPUSH
103795: PPUSH
103796: PPUSH
103797: PPUSH
103798: PPUSH
103799: PPUSH
103800: PPUSH
103801: PPUSH
// if not turrets or not factories then
103802: LD_VAR 0 1
103806: NOT
103807: PUSH
103808: LD_VAR 0 2
103812: NOT
103813: OR
103814: IFFALSE 103818
// exit ;
103816: GO 104125
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
103818: LD_ADDR_VAR 0 10
103822: PUSH
103823: LD_INT 5
103825: PUSH
103826: LD_INT 6
103828: PUSH
103829: EMPTY
103830: LIST
103831: LIST
103832: PUSH
103833: LD_INT 2
103835: PUSH
103836: LD_INT 4
103838: PUSH
103839: EMPTY
103840: LIST
103841: LIST
103842: PUSH
103843: LD_INT 3
103845: PUSH
103846: LD_INT 5
103848: PUSH
103849: EMPTY
103850: LIST
103851: LIST
103852: PUSH
103853: EMPTY
103854: LIST
103855: LIST
103856: LIST
103857: PUSH
103858: LD_INT 24
103860: PUSH
103861: LD_INT 25
103863: PUSH
103864: EMPTY
103865: LIST
103866: LIST
103867: PUSH
103868: LD_INT 23
103870: PUSH
103871: LD_INT 27
103873: PUSH
103874: EMPTY
103875: LIST
103876: LIST
103877: PUSH
103878: EMPTY
103879: LIST
103880: LIST
103881: PUSH
103882: LD_INT 42
103884: PUSH
103885: LD_INT 43
103887: PUSH
103888: EMPTY
103889: LIST
103890: LIST
103891: PUSH
103892: LD_INT 44
103894: PUSH
103895: LD_INT 46
103897: PUSH
103898: EMPTY
103899: LIST
103900: LIST
103901: PUSH
103902: LD_INT 45
103904: PUSH
103905: LD_INT 47
103907: PUSH
103908: EMPTY
103909: LIST
103910: LIST
103911: PUSH
103912: EMPTY
103913: LIST
103914: LIST
103915: LIST
103916: PUSH
103917: EMPTY
103918: LIST
103919: LIST
103920: LIST
103921: ST_TO_ADDR
// result := [ ] ;
103922: LD_ADDR_VAR 0 3
103926: PUSH
103927: EMPTY
103928: ST_TO_ADDR
// for i in turrets do
103929: LD_ADDR_VAR 0 4
103933: PUSH
103934: LD_VAR 0 1
103938: PUSH
103939: FOR_IN
103940: IFFALSE 104123
// begin nat := GetNation ( i ) ;
103942: LD_ADDR_VAR 0 7
103946: PUSH
103947: LD_VAR 0 4
103951: PPUSH
103952: CALL_OW 248
103956: ST_TO_ADDR
// weapon := 0 ;
103957: LD_ADDR_VAR 0 8
103961: PUSH
103962: LD_INT 0
103964: ST_TO_ADDR
// if not nat then
103965: LD_VAR 0 7
103969: NOT
103970: IFFALSE 103974
// continue ;
103972: GO 103939
// for j in list [ nat ] do
103974: LD_ADDR_VAR 0 5
103978: PUSH
103979: LD_VAR 0 10
103983: PUSH
103984: LD_VAR 0 7
103988: ARRAY
103989: PUSH
103990: FOR_IN
103991: IFFALSE 104032
// if GetBWeapon ( i ) = j [ 1 ] then
103993: LD_VAR 0 4
103997: PPUSH
103998: CALL_OW 269
104002: PUSH
104003: LD_VAR 0 5
104007: PUSH
104008: LD_INT 1
104010: ARRAY
104011: EQUAL
104012: IFFALSE 104030
// begin weapon := j [ 2 ] ;
104014: LD_ADDR_VAR 0 8
104018: PUSH
104019: LD_VAR 0 5
104023: PUSH
104024: LD_INT 2
104026: ARRAY
104027: ST_TO_ADDR
// break ;
104028: GO 104032
// end ;
104030: GO 103990
104032: POP
104033: POP
// if not weapon then
104034: LD_VAR 0 8
104038: NOT
104039: IFFALSE 104043
// continue ;
104041: GO 103939
// for k in factories do
104043: LD_ADDR_VAR 0 6
104047: PUSH
104048: LD_VAR 0 2
104052: PUSH
104053: FOR_IN
104054: IFFALSE 104119
// begin weapons := AvailableWeaponList ( k ) ;
104056: LD_ADDR_VAR 0 9
104060: PUSH
104061: LD_VAR 0 6
104065: PPUSH
104066: CALL_OW 478
104070: ST_TO_ADDR
// if not weapons then
104071: LD_VAR 0 9
104075: NOT
104076: IFFALSE 104080
// continue ;
104078: GO 104053
// if weapon in weapons then
104080: LD_VAR 0 8
104084: PUSH
104085: LD_VAR 0 9
104089: IN
104090: IFFALSE 104117
// begin result := [ i , weapon ] ;
104092: LD_ADDR_VAR 0 3
104096: PUSH
104097: LD_VAR 0 4
104101: PUSH
104102: LD_VAR 0 8
104106: PUSH
104107: EMPTY
104108: LIST
104109: LIST
104110: ST_TO_ADDR
// exit ;
104111: POP
104112: POP
104113: POP
104114: POP
104115: GO 104125
// end ; end ;
104117: GO 104053
104119: POP
104120: POP
// end ;
104121: GO 103939
104123: POP
104124: POP
// end ;
104125: LD_VAR 0 3
104129: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
104130: LD_INT 0
104132: PPUSH
// if not side or side > 8 then
104133: LD_VAR 0 3
104137: NOT
104138: PUSH
104139: LD_VAR 0 3
104143: PUSH
104144: LD_INT 8
104146: GREATER
104147: OR
104148: IFFALSE 104152
// exit ;
104150: GO 104211
// if not range then
104152: LD_VAR 0 4
104156: NOT
104157: IFFALSE 104168
// range := - 12 ;
104159: LD_ADDR_VAR 0 4
104163: PUSH
104164: LD_INT 12
104166: NEG
104167: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
104168: LD_VAR 0 1
104172: PPUSH
104173: LD_VAR 0 2
104177: PPUSH
104178: LD_VAR 0 3
104182: PPUSH
104183: LD_VAR 0 4
104187: PPUSH
104188: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
104192: LD_VAR 0 1
104196: PPUSH
104197: LD_VAR 0 2
104201: PPUSH
104202: LD_VAR 0 3
104206: PPUSH
104207: CALL_OW 331
// end ;
104211: LD_VAR 0 5
104215: RET
// export function Video ( mode ) ; begin
104216: LD_INT 0
104218: PPUSH
// ingame_video = mode ;
104219: LD_ADDR_OWVAR 52
104223: PUSH
104224: LD_VAR 0 1
104228: ST_TO_ADDR
// interface_hidden = mode ;
104229: LD_ADDR_OWVAR 54
104233: PUSH
104234: LD_VAR 0 1
104238: ST_TO_ADDR
// end ;
104239: LD_VAR 0 2
104243: RET
// export function Join ( array , element ) ; begin
104244: LD_INT 0
104246: PPUSH
// result := array ^ element ;
104247: LD_ADDR_VAR 0 3
104251: PUSH
104252: LD_VAR 0 1
104256: PUSH
104257: LD_VAR 0 2
104261: ADD
104262: ST_TO_ADDR
// end ;
104263: LD_VAR 0 3
104267: RET
// export function JoinUnion ( array , element ) ; begin
104268: LD_INT 0
104270: PPUSH
// result := array union element ;
104271: LD_ADDR_VAR 0 3
104275: PUSH
104276: LD_VAR 0 1
104280: PUSH
104281: LD_VAR 0 2
104285: UNION
104286: ST_TO_ADDR
// end ;
104287: LD_VAR 0 3
104291: RET
// export function GetBehemoths ( side ) ; begin
104292: LD_INT 0
104294: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
104295: LD_ADDR_VAR 0 2
104299: PUSH
104300: LD_INT 22
104302: PUSH
104303: LD_VAR 0 1
104307: PUSH
104308: EMPTY
104309: LIST
104310: LIST
104311: PUSH
104312: LD_INT 31
104314: PUSH
104315: LD_INT 25
104317: PUSH
104318: EMPTY
104319: LIST
104320: LIST
104321: PUSH
104322: EMPTY
104323: LIST
104324: LIST
104325: PPUSH
104326: CALL_OW 69
104330: ST_TO_ADDR
// end ;
104331: LD_VAR 0 2
104335: RET
// export function Shuffle ( array ) ; var i , index ; begin
104336: LD_INT 0
104338: PPUSH
104339: PPUSH
104340: PPUSH
// result := [ ] ;
104341: LD_ADDR_VAR 0 2
104345: PUSH
104346: EMPTY
104347: ST_TO_ADDR
// if not array then
104348: LD_VAR 0 1
104352: NOT
104353: IFFALSE 104357
// exit ;
104355: GO 104456
// Randomize ;
104357: CALL_OW 10
// for i = array downto 1 do
104361: LD_ADDR_VAR 0 3
104365: PUSH
104366: DOUBLE
104367: LD_VAR 0 1
104371: INC
104372: ST_TO_ADDR
104373: LD_INT 1
104375: PUSH
104376: FOR_DOWNTO
104377: IFFALSE 104454
// begin index := rand ( 1 , array ) ;
104379: LD_ADDR_VAR 0 4
104383: PUSH
104384: LD_INT 1
104386: PPUSH
104387: LD_VAR 0 1
104391: PPUSH
104392: CALL_OW 12
104396: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
104397: LD_ADDR_VAR 0 2
104401: PUSH
104402: LD_VAR 0 2
104406: PPUSH
104407: LD_VAR 0 2
104411: PUSH
104412: LD_INT 1
104414: PLUS
104415: PPUSH
104416: LD_VAR 0 1
104420: PUSH
104421: LD_VAR 0 4
104425: ARRAY
104426: PPUSH
104427: CALL_OW 2
104431: ST_TO_ADDR
// array := Delete ( array , index ) ;
104432: LD_ADDR_VAR 0 1
104436: PUSH
104437: LD_VAR 0 1
104441: PPUSH
104442: LD_VAR 0 4
104446: PPUSH
104447: CALL_OW 3
104451: ST_TO_ADDR
// end ;
104452: GO 104376
104454: POP
104455: POP
// end ;
104456: LD_VAR 0 2
104460: RET
