// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 34855 0 0
// InitNature ;
  19: CALL 34679 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 11057 0 0
// PrepareRussian ;
  40: CALL 6941 0 0
// PrepareLegion ;
  44: CALL 4181 0 0
// PreparePowell ;
  48: CALL 2918 0 0
// PrepareAmerican ;
  52: CALL 1690 0 0
// Action ;
  56: CALL 14951 0 0
// MC_Start ( ) ;
  60: CALL 36967 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// end ;
 462: LD_VAR 0 1
 466: RET
// export function CustomInitMacro ( ) ; begin
 467: LD_INT 0
 469: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 470: LD_ADDR_EXP 126
 474: PUSH
 475: LD_INT 2
 477: PUSH
 478: LD_INT 3
 480: PUSH
 481: LD_INT 6
 483: PUSH
 484: LD_INT 10
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 493: LD_ADDR_EXP 127
 497: PUSH
 498: LD_INT 1
 500: PUSH
 501: LD_INT 4
 503: PUSH
 504: LD_INT 5
 506: PUSH
 507: LD_INT 9
 509: PUSH
 510: EMPTY
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 516: LD_INT 1
 518: PPUSH
 519: LD_INT 10
 521: PUSH
 522: LD_INT 11
 524: PUSH
 525: LD_INT 12
 527: PUSH
 528: EMPTY
 529: LIST
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 59244 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 17
 542: PUSH
 543: EMPTY
 544: LIST
 545: PPUSH
 546: CALL 59337 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 550: LD_INT 1
 552: PPUSH
 553: LD_INT 5
 555: PPUSH
 556: CALL 58687 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 560: LD_INT 1
 562: PPUSH
 563: LD_INT 24
 565: PUSH
 566: LD_INT 3
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 47
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: LD_INT 24
 583: PUSH
 584: LD_INT 3
 586: PUSH
 587: LD_INT 3
 589: PUSH
 590: LD_INT 47
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: LIST
 597: LIST
 598: PUSH
 599: LD_INT 24
 601: PUSH
 602: LD_INT 3
 604: PUSH
 605: LD_INT 3
 607: PUSH
 608: LD_INT 47
 610: PUSH
 611: EMPTY
 612: LIST
 613: LIST
 614: LIST
 615: LIST
 616: PUSH
 617: LD_INT 24
 619: PUSH
 620: LD_INT 3
 622: PUSH
 623: LD_INT 1
 625: PUSH
 626: LD_INT 47
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: LIST
 634: PUSH
 635: LD_INT 24
 637: PUSH
 638: LD_INT 3
 640: PUSH
 641: LD_INT 1
 643: PUSH
 644: LD_INT 47
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: LIST
 659: PPUSH
 660: CALL 58502 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 664: LD_INT 2
 666: PPUSH
 667: LD_INT 10
 669: PUSH
 670: LD_INT 11
 672: PUSH
 673: LD_INT 12
 675: PUSH
 676: LD_INT 14
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: CALL 59244 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 689: LD_INT 2
 691: PPUSH
 692: LD_INT 16
 694: PUSH
 695: EMPTY
 696: LIST
 697: PPUSH
 698: CALL 59337 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 702: LD_INT 2
 704: PPUSH
 705: LD_INT 21
 707: PUSH
 708: LD_INT 3
 710: PUSH
 711: LD_INT 3
 713: PUSH
 714: LD_INT 51
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: LIST
 722: PUSH
 723: LD_INT 22
 725: PUSH
 726: LD_INT 3
 728: PUSH
 729: LD_INT 3
 731: PUSH
 732: LD_INT 52
 734: PUSH
 735: EMPTY
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: PUSH
 741: LD_INT 22
 743: PUSH
 744: LD_INT 3
 746: PUSH
 747: LD_INT 3
 749: PUSH
 750: LD_INT 52
 752: PUSH
 753: EMPTY
 754: LIST
 755: LIST
 756: LIST
 757: LIST
 758: PUSH
 759: LD_INT 24
 761: PUSH
 762: LD_INT 3
 764: PUSH
 765: LD_INT 3
 767: PUSH
 768: LD_INT 47
 770: PUSH
 771: EMPTY
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: PUSH
 777: LD_INT 24
 779: PUSH
 780: LD_INT 3
 782: PUSH
 783: LD_INT 3
 785: PUSH
 786: LD_INT 47
 788: PUSH
 789: EMPTY
 790: LIST
 791: LIST
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 24
 797: PUSH
 798: LD_INT 3
 800: PUSH
 801: LD_INT 3
 803: PUSH
 804: LD_INT 47
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: PUSH
 813: LD_INT 24
 815: PUSH
 816: LD_INT 3
 818: PUSH
 819: LD_INT 3
 821: PUSH
 822: LD_INT 47
 824: PUSH
 825: EMPTY
 826: LIST
 827: LIST
 828: LIST
 829: LIST
 830: PUSH
 831: LD_INT 24
 833: PUSH
 834: LD_INT 3
 836: PUSH
 837: LD_INT 3
 839: PUSH
 840: LD_INT 47
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: LIST
 853: LIST
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: PPUSH
 859: CALL 58502 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 863: LD_INT 2
 865: PPUSH
 866: LD_INT 5
 868: PPUSH
 869: CALL 58687 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 873: LD_INT 2
 875: PPUSH
 876: LD_INT 0
 878: PPUSH
 879: CALL 59117 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 883: LD_INT 3
 885: PPUSH
 886: LD_INT 10
 888: PUSH
 889: LD_INT 12
 891: PUSH
 892: LD_INT 15
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: PUSH
 900: LD_OWVAR 67
 904: ARRAY
 905: PPUSH
 906: LD_INT 27
 908: PPUSH
 909: CALL 58184 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 913: LD_INT 3
 915: PPUSH
 916: LD_INT 10
 918: PUSH
 919: LD_INT 11
 921: PUSH
 922: LD_INT 13
 924: PUSH
 925: LD_INT 15
 927: PUSH
 928: EMPTY
 929: LIST
 930: LIST
 931: LIST
 932: LIST
 933: PPUSH
 934: CALL 59244 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 938: LD_INT 3
 940: PPUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: PPUSH
 947: CALL 59337 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 951: LD_ADDR_EXP 131
 955: PUSH
 956: LD_EXP 131
 960: PPUSH
 961: LD_INT 3
 963: PPUSH
 964: LD_INT 22
 966: PUSH
 967: LD_INT 8
 969: PUSH
 970: EMPTY
 971: LIST
 972: LIST
 973: PUSH
 974: LD_INT 25
 976: PUSH
 977: LD_INT 15
 979: PUSH
 980: EMPTY
 981: LIST
 982: LIST
 983: PUSH
 984: EMPTY
 985: LIST
 986: LIST
 987: PPUSH
 988: CALL_OW 69
 992: PPUSH
 993: CALL_OW 1
 997: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 998: LD_INT 3
1000: PPUSH
1001: LD_INT 13
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_INT 1
1009: PUSH
1010: LD_INT 31
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: PUSH
1019: LD_INT 13
1021: PUSH
1022: LD_INT 2
1024: PUSH
1025: LD_INT 1
1027: PUSH
1028: LD_INT 31
1030: PUSH
1031: EMPTY
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: LD_INT 13
1039: PUSH
1040: LD_INT 3
1042: PUSH
1043: LD_INT 2
1045: PUSH
1046: LD_INT 32
1048: PUSH
1049: EMPTY
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: PUSH
1055: EMPTY
1056: LIST
1057: LIST
1058: LIST
1059: PPUSH
1060: CALL 58502 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1064: LD_INT 4
1066: PPUSH
1067: LD_INT 10
1069: PUSH
1070: LD_INT 12
1072: PUSH
1073: EMPTY
1074: LIST
1075: LIST
1076: PPUSH
1077: CALL 59244 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1081: LD_INT 4
1083: PPUSH
1084: LD_INT 9
1086: PUSH
1087: EMPTY
1088: LIST
1089: PPUSH
1090: CALL 59337 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1094: LD_INT 4
1096: PPUSH
1097: LD_INT 26
1099: PUSH
1100: LD_INT 74
1102: PUSH
1103: LD_INT 107
1105: PUSH
1106: LD_INT 0
1108: PUSH
1109: EMPTY
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: PUSH
1115: LD_INT 32
1117: PUSH
1118: LD_INT 77
1120: PUSH
1121: LD_INT 101
1123: PUSH
1124: LD_INT 4
1126: PUSH
1127: EMPTY
1128: LIST
1129: LIST
1130: LIST
1131: LIST
1132: PUSH
1133: LD_INT 32
1135: PUSH
1136: LD_INT 69
1138: PUSH
1139: LD_INT 86
1141: PUSH
1142: LD_INT 4
1144: PUSH
1145: EMPTY
1146: LIST
1147: LIST
1148: LIST
1149: LIST
1150: PUSH
1151: LD_INT 27
1153: PUSH
1154: LD_INT 77
1156: PUSH
1157: LD_INT 110
1159: PUSH
1160: LD_INT 3
1162: PUSH
1163: EMPTY
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: PUSH
1169: LD_INT 27
1171: PUSH
1172: LD_INT 42
1174: PUSH
1175: LD_INT 79
1177: PUSH
1178: LD_INT 5
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: LIST
1185: LIST
1186: PUSH
1187: LD_INT 29
1189: PUSH
1190: LD_INT 86
1192: PUSH
1193: LD_INT 105
1195: PUSH
1196: LD_INT 2
1198: PUSH
1199: EMPTY
1200: LIST
1201: LIST
1202: LIST
1203: LIST
1204: PUSH
1205: LD_INT 30
1207: PUSH
1208: LD_INT 40
1210: PUSH
1211: LD_INT 75
1213: PUSH
1214: LD_INT 1
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: PUSH
1223: LD_INT 32
1225: PUSH
1226: LD_INT 80
1228: PUSH
1229: LD_INT 106
1231: PUSH
1232: LD_INT 4
1234: PUSH
1235: EMPTY
1236: LIST
1237: LIST
1238: LIST
1239: LIST
1240: PUSH
1241: LD_INT 32
1243: PUSH
1244: LD_INT 75
1246: PUSH
1247: LD_INT 114
1249: PUSH
1250: LD_INT 5
1252: PUSH
1253: EMPTY
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: PUSH
1259: LD_INT 32
1261: PUSH
1262: LD_INT 82
1264: PUSH
1265: LD_INT 110
1267: PUSH
1268: LD_INT 5
1270: PUSH
1271: EMPTY
1272: LIST
1273: LIST
1274: LIST
1275: LIST
1276: PUSH
1277: LD_INT 32
1279: PUSH
1280: LD_INT 62
1282: PUSH
1283: LD_INT 78
1285: PUSH
1286: LD_INT 4
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: PUSH
1295: LD_INT 4
1297: PUSH
1298: LD_INT 39
1300: PUSH
1301: LD_INT 61
1303: PUSH
1304: LD_INT 3
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: LIST
1312: PUSH
1313: EMPTY
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: LIST
1324: LIST
1325: LIST
1326: PPUSH
1327: CALL 58394 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1331: LD_INT 4
1333: PPUSH
1334: LD_INT 5
1336: PUSH
1337: LD_INT 6
1339: PUSH
1340: LD_INT 7
1342: PUSH
1343: LD_INT 9
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: PPUSH
1352: CALL 59655 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1356: LD_INT 4
1358: PPUSH
1359: LD_INT 40
1361: PUSH
1362: LD_INT 75
1364: PUSH
1365: LD_INT 1
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: PUSH
1373: LD_INT 86
1375: PUSH
1376: LD_INT 105
1378: PUSH
1379: LD_INT 0
1381: PUSH
1382: EMPTY
1383: LIST
1384: LIST
1385: LIST
1386: PUSH
1387: EMPTY
1388: LIST
1389: LIST
1390: PPUSH
1391: CALL 58826 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1395: LD_INT 4
1397: PPUSH
1398: LD_INT 2
1400: PPUSH
1401: CALL 59117 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1405: LD_INT 4
1407: PPUSH
1408: LD_INT 0
1410: PPUSH
1411: CALL 59117 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1415: LD_INT 4
1417: PPUSH
1418: LD_INT 54
1420: PPUSH
1421: LD_INT 85
1423: PPUSH
1424: LD_INT 2
1426: PPUSH
1427: LD_INT 19
1429: PUSH
1430: LD_INT 16
1432: PUSH
1433: LD_INT 17
1435: PUSH
1436: LD_INT 18
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: PPUSH
1445: CALL 59449 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1449: LD_INT 4
1451: PPUSH
1452: LD_INT 3
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 1
1460: PUSH
1461: LD_INT 5
1463: PUSH
1464: EMPTY
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: PUSH
1470: LD_INT 4
1472: PUSH
1473: LD_INT 1
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 6
1481: PUSH
1482: EMPTY
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: PUSH
1488: LD_INT 4
1490: PUSH
1491: LD_INT 1
1493: PUSH
1494: LD_INT 1
1496: PUSH
1497: LD_INT 7
1499: PUSH
1500: EMPTY
1501: LIST
1502: LIST
1503: LIST
1504: LIST
1505: PUSH
1506: LD_INT 4
1508: PUSH
1509: LD_INT 1
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: LD_INT 6
1517: PUSH
1518: EMPTY
1519: LIST
1520: LIST
1521: LIST
1522: LIST
1523: PUSH
1524: EMPTY
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: PPUSH
1530: CALL 58502 0 2
// MC_SetTame ( 4 , powellApe ) ;
1534: LD_INT 4
1536: PPUSH
1537: LD_INT 13
1539: PPUSH
1540: CALL 59068 0 2
// end ;
1544: LD_VAR 0 1
1548: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1549: LD_EXP 36
1553: PUSH
1554: LD_EXP 17
1558: PUSH
1559: LD_INT 2
1561: GREATEREQUAL
1562: AND
1563: IFFALSE 1575
1565: GO 1567
1567: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1568: LD_STRING ACH_POWELL
1570: PPUSH
1571: CALL_OW 543
1575: END
// every 0 0$1 trigger debug do var i , tmp ;
1576: LD_EXP 1
1580: IFFALSE 1687
1582: GO 1584
1584: DISABLE
1585: LD_INT 0
1587: PPUSH
1588: PPUSH
// begin enable ;
1589: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1590: LD_ADDR_VAR 0 2
1594: PUSH
1595: LD_INT 22
1597: PUSH
1598: LD_INT 1
1600: PUSH
1601: EMPTY
1602: LIST
1603: LIST
1604: PUSH
1605: LD_INT 3
1607: PUSH
1608: LD_INT 21
1610: PUSH
1611: LD_INT 3
1613: PUSH
1614: EMPTY
1615: LIST
1616: LIST
1617: PUSH
1618: EMPTY
1619: LIST
1620: LIST
1621: PUSH
1622: LD_INT 3
1624: PUSH
1625: LD_INT 24
1627: PUSH
1628: LD_INT 999
1630: PUSH
1631: EMPTY
1632: LIST
1633: LIST
1634: PUSH
1635: EMPTY
1636: LIST
1637: LIST
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: PPUSH
1644: CALL_OW 69
1648: ST_TO_ADDR
// if not tmp then
1649: LD_VAR 0 2
1653: NOT
1654: IFFALSE 1658
// exit ;
1656: GO 1687
// for i in tmp do
1658: LD_ADDR_VAR 0 1
1662: PUSH
1663: LD_VAR 0 2
1667: PUSH
1668: FOR_IN
1669: IFFALSE 1685
// SetLives ( i , 1000 ) ;
1671: LD_VAR 0 1
1675: PPUSH
1676: LD_INT 1000
1678: PPUSH
1679: CALL_OW 234
1683: GO 1668
1685: POP
1686: POP
// end ; end_of_file
1687: PPOPN 2
1689: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1690: LD_INT 0
1692: PPUSH
// uc_side := 1 ;
1693: LD_ADDR_OWVAR 20
1697: PUSH
1698: LD_INT 1
1700: ST_TO_ADDR
// uc_nation := 1 ;
1701: LD_ADDR_OWVAR 21
1705: PUSH
1706: LD_INT 1
1708: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1709: LD_ADDR_EXP 39
1713: PUSH
1714: LD_STRING JMM
1716: PPUSH
1717: LD_EXP 1
1721: NOT
1722: PPUSH
1723: LD_STRING 14_
1725: PPUSH
1726: CALL 64894 0 3
1730: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1731: LD_EXP 4
1735: NOT
1736: PUSH
1737: LD_EXP 4
1741: PUSH
1742: LD_INT 1
1744: ARRAY
1745: PUSH
1746: LD_INT 1
1748: ARRAY
1749: NOT
1750: OR
1751: IFFALSE 1774
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1753: LD_INT 5
1755: PPUSH
1756: LD_INT 3
1758: PPUSH
1759: LD_INT 1
1761: PPUSH
1762: LD_INT 9
1764: PPUSH
1765: LD_INT 100
1767: PPUSH
1768: CALL 72009 0 5
1772: GO 1833
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1774: LD_EXP 4
1778: PUSH
1779: LD_INT 1
1781: ARRAY
1782: PUSH
1783: LD_INT 1
1785: ARRAY
1786: PPUSH
1787: LD_EXP 4
1791: PUSH
1792: LD_INT 2
1794: ARRAY
1795: PUSH
1796: LD_INT 1
1798: ARRAY
1799: PPUSH
1800: LD_EXP 4
1804: PUSH
1805: LD_INT 3
1807: ARRAY
1808: PUSH
1809: LD_INT 1
1811: ARRAY
1812: PPUSH
1813: LD_EXP 4
1817: PUSH
1818: LD_INT 4
1820: ARRAY
1821: PUSH
1822: LD_INT 1
1824: ARRAY
1825: PPUSH
1826: LD_INT 30
1828: PPUSH
1829: CALL 72009 0 5
// JMMNewVeh := CreateVehicle ;
1833: LD_ADDR_EXP 56
1837: PUSH
1838: CALL_OW 45
1842: ST_TO_ADDR
// if not JMMNewVeh then
1843: LD_EXP 56
1847: NOT
1848: IFFALSE 1879
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1850: LD_INT 5
1852: PPUSH
1853: LD_INT 3
1855: PPUSH
1856: LD_INT 1
1858: PPUSH
1859: LD_INT 9
1861: PPUSH
1862: LD_INT 100
1864: PPUSH
1865: CALL 72009 0 5
// JMMNewVeh := CreateVehicle ;
1869: LD_ADDR_EXP 56
1873: PUSH
1874: CALL_OW 45
1878: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1879: LD_EXP 56
1883: PPUSH
1884: LD_INT 4
1886: PPUSH
1887: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1891: LD_EXP 56
1895: PPUSH
1896: LD_INT 79
1898: PPUSH
1899: LD_INT 91
1901: PPUSH
1902: LD_INT 0
1904: PPUSH
1905: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1909: LD_EXP 39
1913: PPUSH
1914: LD_EXP 56
1918: PPUSH
1919: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1923: LD_EXP 6
1927: PUSH
1928: LD_EXP 2
1932: NOT
1933: AND
1934: IFFALSE 2192
// begin if not JMMGirlVeh then
1936: LD_EXP 5
1940: NOT
1941: IFFALSE 1964
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1943: LD_INT 3
1945: PPUSH
1946: LD_INT 3
1948: PPUSH
1949: LD_INT 1
1951: PPUSH
1952: LD_INT 9
1954: PPUSH
1955: LD_INT 100
1957: PPUSH
1958: CALL 72009 0 5
1962: GO 2023
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1964: LD_EXP 5
1968: PUSH
1969: LD_INT 1
1971: ARRAY
1972: PUSH
1973: LD_INT 1
1975: ARRAY
1976: PPUSH
1977: LD_EXP 5
1981: PUSH
1982: LD_INT 2
1984: ARRAY
1985: PUSH
1986: LD_INT 1
1988: ARRAY
1989: PPUSH
1990: LD_EXP 5
1994: PUSH
1995: LD_INT 3
1997: ARRAY
1998: PUSH
1999: LD_INT 1
2001: ARRAY
2002: PPUSH
2003: LD_EXP 5
2007: PUSH
2008: LD_INT 4
2010: ARRAY
2011: PUSH
2012: LD_INT 1
2014: ARRAY
2015: PPUSH
2016: LD_INT 30
2018: PPUSH
2019: CALL 72009 0 5
// GirlNewVeh := CreateVehicle ;
2023: LD_ADDR_EXP 57
2027: PUSH
2028: CALL_OW 45
2032: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2033: LD_EXP 57
2037: PPUSH
2038: LD_INT 4
2040: PPUSH
2041: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2045: LD_EXP 57
2049: PPUSH
2050: LD_INT 82
2052: PPUSH
2053: LD_INT 96
2055: PPUSH
2056: LD_INT 0
2058: PPUSH
2059: CALL_OW 48
// if JMMGirl = 1 then
2063: LD_EXP 7
2067: PUSH
2068: LD_INT 1
2070: EQUAL
2071: IFFALSE 2106
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2073: LD_ADDR_EXP 40
2077: PUSH
2078: LD_STRING Joan
2080: PPUSH
2081: LD_INT 1
2083: PPUSH
2084: LD_STRING 14_
2086: PPUSH
2087: CALL 64894 0 3
2091: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2092: LD_EXP 40
2096: PPUSH
2097: LD_EXP 57
2101: PPUSH
2102: CALL_OW 52
// end ; if JMMGirl = 2 then
2106: LD_EXP 7
2110: PUSH
2111: LD_INT 2
2113: EQUAL
2114: IFFALSE 2149
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2116: LD_ADDR_EXP 42
2120: PUSH
2121: LD_STRING Lisa
2123: PPUSH
2124: LD_INT 1
2126: PPUSH
2127: LD_STRING 14_
2129: PPUSH
2130: CALL 64894 0 3
2134: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2135: LD_EXP 42
2139: PPUSH
2140: LD_EXP 57
2144: PPUSH
2145: CALL_OW 52
// end ; if JMMGirl = 3 then
2149: LD_EXP 7
2153: PUSH
2154: LD_INT 3
2156: EQUAL
2157: IFFALSE 2192
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2159: LD_ADDR_EXP 54
2163: PUSH
2164: LD_STRING Connie
2166: PPUSH
2167: LD_INT 1
2169: PPUSH
2170: LD_STRING 14_
2172: PPUSH
2173: CALL 64894 0 3
2177: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2178: LD_EXP 54
2182: PPUSH
2183: LD_EXP 57
2187: PPUSH
2188: CALL_OW 52
// end ; end ; end ;
2192: LD_VAR 0 1
2196: RET
// export function PrepareStevensSquad ; var tmp ; begin
2197: LD_INT 0
2199: PPUSH
2200: PPUSH
// uc_side := 1 ;
2201: LD_ADDR_OWVAR 20
2205: PUSH
2206: LD_INT 1
2208: ST_TO_ADDR
// uc_nation := 1 ;
2209: LD_ADDR_OWVAR 21
2213: PUSH
2214: LD_INT 1
2216: ST_TO_ADDR
// tmp := [ ] ;
2217: LD_ADDR_VAR 0 2
2221: PUSH
2222: EMPTY
2223: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2224: LD_ADDR_EXP 41
2228: PUSH
2229: LD_STRING Stevens
2231: PPUSH
2232: LD_EXP 1
2236: NOT
2237: PPUSH
2238: LD_STRING 13f_
2240: PPUSH
2241: CALL 64894 0 3
2245: ST_TO_ADDR
// if not Stevens then
2246: LD_EXP 41
2250: NOT
2251: IFFALSE 2307
// begin hc_name = Baker Smith ;
2253: LD_ADDR_OWVAR 26
2257: PUSH
2258: LD_STRING Baker Smith
2260: ST_TO_ADDR
// hc_gallery =  ;
2261: LD_ADDR_OWVAR 33
2265: PUSH
2266: LD_STRING 
2268: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2269: LD_INT 1
2271: PPUSH
2272: LD_INT 10
2274: PPUSH
2275: CALL_OW 384
// Baker = CreateHuman ;
2279: LD_ADDR_EXP 55
2283: PUSH
2284: CALL_OW 44
2288: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2289: LD_ADDR_VAR 0 2
2293: PUSH
2294: LD_VAR 0 2
2298: PUSH
2299: LD_EXP 55
2303: ADD
2304: ST_TO_ADDR
// end else
2305: GO 2323
// tmp := tmp ^ Stevens ;
2307: LD_ADDR_VAR 0 2
2311: PUSH
2312: LD_VAR 0 2
2316: PUSH
2317: LD_EXP 41
2321: ADD
2322: ST_TO_ADDR
// if not Lisa then
2323: LD_EXP 42
2327: NOT
2328: IFFALSE 2374
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2330: LD_ADDR_EXP 42
2334: PUSH
2335: LD_STRING Lisa
2337: PPUSH
2338: LD_EXP 1
2342: NOT
2343: PPUSH
2344: LD_STRING 13f_
2346: PPUSH
2347: CALL 64894 0 3
2351: ST_TO_ADDR
// if Lisa then
2352: LD_EXP 42
2356: IFFALSE 2374
// tmp := tmp ^ Lisa ;
2358: LD_ADDR_VAR 0 2
2362: PUSH
2363: LD_VAR 0 2
2367: PUSH
2368: LD_EXP 42
2372: ADD
2373: ST_TO_ADDR
// end ; if not Donaldson then
2374: LD_EXP 43
2378: NOT
2379: IFFALSE 2425
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2381: LD_ADDR_EXP 43
2385: PUSH
2386: LD_STRING Donaldson
2388: PPUSH
2389: LD_EXP 1
2393: NOT
2394: PPUSH
2395: LD_STRING 13f_
2397: PPUSH
2398: CALL 64894 0 3
2402: ST_TO_ADDR
// if Donaldson then
2403: LD_EXP 43
2407: IFFALSE 2425
// tmp := tmp ^ Donaldson ;
2409: LD_ADDR_VAR 0 2
2413: PUSH
2414: LD_VAR 0 2
2418: PUSH
2419: LD_EXP 43
2423: ADD
2424: ST_TO_ADDR
// end ; if not Bobby then
2425: LD_EXP 44
2429: NOT
2430: IFFALSE 2476
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2432: LD_ADDR_EXP 44
2436: PUSH
2437: LD_STRING Bobby
2439: PPUSH
2440: LD_EXP 1
2444: NOT
2445: PPUSH
2446: LD_STRING 13f_
2448: PPUSH
2449: CALL 64894 0 3
2453: ST_TO_ADDR
// if Bobby then
2454: LD_EXP 44
2458: IFFALSE 2476
// tmp := tmp ^ Bobby ;
2460: LD_ADDR_VAR 0 2
2464: PUSH
2465: LD_VAR 0 2
2469: PUSH
2470: LD_EXP 44
2474: ADD
2475: ST_TO_ADDR
// end ; if not Cyrus then
2476: LD_EXP 45
2480: NOT
2481: IFFALSE 2527
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2483: LD_ADDR_EXP 45
2487: PUSH
2488: LD_STRING Cyrus
2490: PPUSH
2491: LD_EXP 1
2495: NOT
2496: PPUSH
2497: LD_STRING 13f_
2499: PPUSH
2500: CALL 64894 0 3
2504: ST_TO_ADDR
// if Cyrus then
2505: LD_EXP 45
2509: IFFALSE 2527
// tmp := tmp ^ Cyrus ;
2511: LD_ADDR_VAR 0 2
2515: PUSH
2516: LD_VAR 0 2
2520: PUSH
2521: LD_EXP 45
2525: ADD
2526: ST_TO_ADDR
// end ; if not Brown then
2527: LD_EXP 47
2531: NOT
2532: IFFALSE 2578
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2534: LD_ADDR_EXP 47
2538: PUSH
2539: LD_STRING Brown
2541: PPUSH
2542: LD_EXP 1
2546: NOT
2547: PPUSH
2548: LD_STRING 13f_
2550: PPUSH
2551: CALL 64894 0 3
2555: ST_TO_ADDR
// if Brown then
2556: LD_EXP 47
2560: IFFALSE 2578
// tmp := tmp ^ Brown ;
2562: LD_ADDR_VAR 0 2
2566: PUSH
2567: LD_VAR 0 2
2571: PUSH
2572: LD_EXP 47
2576: ADD
2577: ST_TO_ADDR
// end ; if not Gladstone then
2578: LD_EXP 48
2582: NOT
2583: IFFALSE 2629
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2585: LD_ADDR_EXP 48
2589: PUSH
2590: LD_STRING Gladstone
2592: PPUSH
2593: LD_EXP 1
2597: NOT
2598: PPUSH
2599: LD_STRING 13f_
2601: PPUSH
2602: CALL 64894 0 3
2606: ST_TO_ADDR
// if Gladstone then
2607: LD_EXP 48
2611: IFFALSE 2629
// tmp := tmp ^ Gladstone ;
2613: LD_ADDR_VAR 0 2
2617: PUSH
2618: LD_VAR 0 2
2622: PUSH
2623: LD_EXP 48
2627: ADD
2628: ST_TO_ADDR
// end ; if not Houten then
2629: LD_EXP 49
2633: NOT
2634: IFFALSE 2680
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2636: LD_ADDR_EXP 49
2640: PUSH
2641: LD_STRING Houten
2643: PPUSH
2644: LD_EXP 1
2648: NOT
2649: PPUSH
2650: LD_STRING 13f_
2652: PPUSH
2653: CALL 64894 0 3
2657: ST_TO_ADDR
// if Houten then
2658: LD_EXP 49
2662: IFFALSE 2680
// tmp := tmp ^ Houten ;
2664: LD_ADDR_VAR 0 2
2668: PUSH
2669: LD_VAR 0 2
2673: PUSH
2674: LD_EXP 49
2678: ADD
2679: ST_TO_ADDR
// end ; if not Cornel then
2680: LD_EXP 50
2684: NOT
2685: IFFALSE 2731
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2687: LD_ADDR_EXP 50
2691: PUSH
2692: LD_STRING Cornell
2694: PPUSH
2695: LD_EXP 1
2699: NOT
2700: PPUSH
2701: LD_STRING 13f_
2703: PPUSH
2704: CALL 64894 0 3
2708: ST_TO_ADDR
// if Cornel then
2709: LD_EXP 50
2713: IFFALSE 2731
// tmp := tmp ^ Cornel ;
2715: LD_ADDR_VAR 0 2
2719: PUSH
2720: LD_VAR 0 2
2724: PUSH
2725: LD_EXP 50
2729: ADD
2730: ST_TO_ADDR
// end ; if not Gary then
2731: LD_EXP 51
2735: NOT
2736: IFFALSE 2782
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2738: LD_ADDR_EXP 51
2742: PUSH
2743: LD_STRING Gary
2745: PPUSH
2746: LD_EXP 1
2750: NOT
2751: PPUSH
2752: LD_STRING 13f_
2754: PPUSH
2755: CALL 64894 0 3
2759: ST_TO_ADDR
// if Gary then
2760: LD_EXP 51
2764: IFFALSE 2782
// tmp := tmp ^ Gary ;
2766: LD_ADDR_VAR 0 2
2770: PUSH
2771: LD_VAR 0 2
2775: PUSH
2776: LD_EXP 51
2780: ADD
2781: ST_TO_ADDR
// end ; if not Frank then
2782: LD_EXP 52
2786: NOT
2787: IFFALSE 2833
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2789: LD_ADDR_EXP 52
2793: PUSH
2794: LD_STRING Frank
2796: PPUSH
2797: LD_EXP 1
2801: NOT
2802: PPUSH
2803: LD_STRING 13f_
2805: PPUSH
2806: CALL 64894 0 3
2810: ST_TO_ADDR
// if Frank then
2811: LD_EXP 52
2815: IFFALSE 2833
// tmp := tmp ^ Frank ;
2817: LD_ADDR_VAR 0 2
2821: PUSH
2822: LD_VAR 0 2
2826: PUSH
2827: LD_EXP 52
2831: ADD
2832: ST_TO_ADDR
// end ; if not Kikuchi then
2833: LD_EXP 53
2837: NOT
2838: IFFALSE 2884
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2840: LD_ADDR_EXP 53
2844: PUSH
2845: LD_STRING Kikuchi
2847: PPUSH
2848: LD_EXP 1
2852: NOT
2853: PPUSH
2854: LD_STRING 13f_
2856: PPUSH
2857: CALL 64894 0 3
2861: ST_TO_ADDR
// if Kikuchi then
2862: LD_EXP 53
2866: IFFALSE 2884
// tmp := tmp ^ Kikuchi ;
2868: LD_ADDR_VAR 0 2
2872: PUSH
2873: LD_VAR 0 2
2877: PUSH
2878: LD_EXP 53
2882: ADD
2883: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2884: LD_ADDR_VAR 0 2
2888: PUSH
2889: LD_VAR 0 2
2893: PUSH
2894: LD_STRING 13_other_survivors
2896: PPUSH
2897: CALL_OW 31
2901: UNION
2902: ST_TO_ADDR
// result := tmp ;
2903: LD_ADDR_VAR 0 1
2907: PUSH
2908: LD_VAR 0 2
2912: ST_TO_ADDR
// end ; end_of_file
2913: LD_VAR 0 1
2917: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2918: LD_INT 0
2920: PPUSH
2921: PPUSH
2922: PPUSH
2923: PPUSH
2924: PPUSH
2925: PPUSH
2926: PPUSH
2927: PPUSH
2928: PPUSH
2929: PPUSH
// uc_side := 4 ;
2930: LD_ADDR_OWVAR 20
2934: PUSH
2935: LD_INT 4
2937: ST_TO_ADDR
// uc_nation := 1 ;
2938: LD_ADDR_OWVAR 21
2942: PUSH
2943: LD_INT 1
2945: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 ] [ Difficulty ] ) ;
2946: LD_INT 387
2948: PPUSH
2949: CALL_OW 274
2953: PPUSH
2954: LD_INT 1
2956: PPUSH
2957: LD_INT 3500
2959: PUSH
2960: LD_INT 3000
2962: PUSH
2963: LD_INT 2500
2965: PUSH
2966: EMPTY
2967: LIST
2968: LIST
2969: LIST
2970: PUSH
2971: LD_OWVAR 67
2975: ARRAY
2976: PPUSH
2977: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2981: LD_INT 387
2983: PPUSH
2984: CALL_OW 274
2988: PPUSH
2989: LD_INT 2
2991: PPUSH
2992: LD_INT 400
2994: PPUSH
2995: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2999: LD_INT 387
3001: PPUSH
3002: CALL_OW 274
3006: PPUSH
3007: LD_INT 3
3009: PPUSH
3010: LD_INT 10
3012: PPUSH
3013: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3017: LD_ADDR_EXP 58
3021: PUSH
3022: LD_STRING Powell
3024: PPUSH
3025: CALL_OW 25
3029: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3030: LD_EXP 58
3034: PPUSH
3035: LD_INT 57
3037: PPUSH
3038: LD_INT 94
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3048: LD_EXP 58
3052: PPUSH
3053: LD_INT 58
3055: PPUSH
3056: LD_INT 94
3058: PPUSH
3059: CALL_OW 118
// vip := [ ] ;
3063: LD_ADDR_EXP 59
3067: PUSH
3068: EMPTY
3069: ST_TO_ADDR
// tmp := [ ] ;
3070: LD_ADDR_VAR 0 6
3074: PUSH
3075: EMPTY
3076: ST_TO_ADDR
// if JMMGirl <> 2 then
3077: LD_EXP 7
3081: PUSH
3082: LD_INT 2
3084: NONEQUAL
3085: IFFALSE 3109
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3087: LD_ADDR_EXP 42
3091: PUSH
3092: LD_STRING Lisa
3094: PPUSH
3095: LD_EXP 1
3099: NOT
3100: PPUSH
3101: LD_STRING 13s_
3103: PPUSH
3104: CALL 64894 0 3
3108: ST_TO_ADDR
// if Lisa then
3109: LD_EXP 42
3113: IFFALSE 3131
// tmp := tmp ^ Lisa ;
3115: LD_ADDR_VAR 0 6
3119: PUSH
3120: LD_VAR 0 6
3124: PUSH
3125: LD_EXP 42
3129: ADD
3130: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3131: LD_ADDR_EXP 43
3135: PUSH
3136: LD_STRING Donaldson
3138: PPUSH
3139: LD_EXP 1
3143: NOT
3144: PPUSH
3145: LD_STRING 13s_
3147: PPUSH
3148: CALL 64894 0 3
3152: ST_TO_ADDR
// if Donaldson then
3153: LD_EXP 43
3157: IFFALSE 3175
// tmp := tmp ^ Donaldson ;
3159: LD_ADDR_VAR 0 6
3163: PUSH
3164: LD_VAR 0 6
3168: PUSH
3169: LD_EXP 43
3173: ADD
3174: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3175: LD_ADDR_EXP 44
3179: PUSH
3180: LD_STRING Bobby
3182: PPUSH
3183: LD_EXP 1
3187: NOT
3188: PPUSH
3189: LD_STRING 13s_
3191: PPUSH
3192: CALL 64894 0 3
3196: ST_TO_ADDR
// if Bobby then
3197: LD_EXP 44
3201: IFFALSE 3219
// tmp := tmp ^ Bobby ;
3203: LD_ADDR_VAR 0 6
3207: PUSH
3208: LD_VAR 0 6
3212: PUSH
3213: LD_EXP 44
3217: ADD
3218: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3219: LD_ADDR_EXP 45
3223: PUSH
3224: LD_STRING Cyrus
3226: PPUSH
3227: LD_EXP 1
3231: NOT
3232: PPUSH
3233: LD_STRING 13s_
3235: PPUSH
3236: CALL 64894 0 3
3240: ST_TO_ADDR
// if Cyrus then
3241: LD_EXP 45
3245: IFFALSE 3263
// tmp := tmp ^ Cyrus ;
3247: LD_ADDR_VAR 0 6
3251: PUSH
3252: LD_VAR 0 6
3256: PUSH
3257: LD_EXP 45
3261: ADD
3262: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3263: LD_ADDR_EXP 46
3267: PUSH
3268: LD_STRING Denis
3270: PPUSH
3271: LD_EXP 1
3275: NOT
3276: PPUSH
3277: LD_STRING 13s_
3279: PPUSH
3280: CALL 64894 0 3
3284: ST_TO_ADDR
// if not Denis then
3285: LD_EXP 46
3289: NOT
3290: IFFALSE 3314
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3292: LD_ADDR_EXP 46
3296: PUSH
3297: LD_STRING Denis
3299: PPUSH
3300: LD_EXP 1
3304: NOT
3305: PPUSH
3306: LD_STRING 13f_
3308: PPUSH
3309: CALL 64894 0 3
3313: ST_TO_ADDR
// if Denis then
3314: LD_EXP 46
3318: IFFALSE 3336
// tmp := tmp ^ Denis ;
3320: LD_ADDR_VAR 0 6
3324: PUSH
3325: LD_VAR 0 6
3329: PUSH
3330: LD_EXP 46
3334: ADD
3335: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3336: LD_ADDR_EXP 47
3340: PUSH
3341: LD_STRING Brown
3343: PPUSH
3344: LD_EXP 1
3348: NOT
3349: PPUSH
3350: LD_STRING 13s_
3352: PPUSH
3353: CALL 64894 0 3
3357: ST_TO_ADDR
// if Brown then
3358: LD_EXP 47
3362: IFFALSE 3380
// tmp := tmp ^ Brown ;
3364: LD_ADDR_VAR 0 6
3368: PUSH
3369: LD_VAR 0 6
3373: PUSH
3374: LD_EXP 47
3378: ADD
3379: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3380: LD_ADDR_EXP 48
3384: PUSH
3385: LD_STRING Gladstone
3387: PPUSH
3388: LD_EXP 1
3392: NOT
3393: PPUSH
3394: LD_STRING 13s_
3396: PPUSH
3397: CALL 64894 0 3
3401: ST_TO_ADDR
// if Gladstone then
3402: LD_EXP 48
3406: IFFALSE 3424
// tmp := tmp ^ Gladstone ;
3408: LD_ADDR_VAR 0 6
3412: PUSH
3413: LD_VAR 0 6
3417: PUSH
3418: LD_EXP 48
3422: ADD
3423: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3424: LD_ADDR_EXP 49
3428: PUSH
3429: LD_STRING Houten
3431: PPUSH
3432: LD_EXP 1
3436: NOT
3437: PPUSH
3438: LD_STRING 13s_
3440: PPUSH
3441: CALL 64894 0 3
3445: ST_TO_ADDR
// if Houten then
3446: LD_EXP 49
3450: IFFALSE 3468
// tmp := tmp ^ Houten ;
3452: LD_ADDR_VAR 0 6
3456: PUSH
3457: LD_VAR 0 6
3461: PUSH
3462: LD_EXP 49
3466: ADD
3467: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3468: LD_ADDR_EXP 50
3472: PUSH
3473: LD_STRING Cornel
3475: PPUSH
3476: LD_EXP 1
3480: NOT
3481: PPUSH
3482: LD_STRING 13s_
3484: PPUSH
3485: CALL 64894 0 3
3489: ST_TO_ADDR
// if Cornel then
3490: LD_EXP 50
3494: IFFALSE 3512
// tmp := tmp ^ Cornel ;
3496: LD_ADDR_VAR 0 6
3500: PUSH
3501: LD_VAR 0 6
3505: PUSH
3506: LD_EXP 50
3510: ADD
3511: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3512: LD_ADDR_EXP 51
3516: PUSH
3517: LD_STRING Gary
3519: PPUSH
3520: LD_EXP 1
3524: NOT
3525: PPUSH
3526: LD_STRING 13s_
3528: PPUSH
3529: CALL 64894 0 3
3533: ST_TO_ADDR
// if Gary then
3534: LD_EXP 51
3538: IFFALSE 3556
// tmp := tmp ^ Gary ;
3540: LD_ADDR_VAR 0 6
3544: PUSH
3545: LD_VAR 0 6
3549: PUSH
3550: LD_EXP 51
3554: ADD
3555: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3556: LD_ADDR_EXP 52
3560: PUSH
3561: LD_STRING Frank
3563: PPUSH
3564: LD_EXP 1
3568: NOT
3569: PPUSH
3570: LD_STRING 13s_
3572: PPUSH
3573: CALL 64894 0 3
3577: ST_TO_ADDR
// if Frank then
3578: LD_EXP 52
3582: IFFALSE 3600
// tmp := tmp ^ Frank ;
3584: LD_ADDR_VAR 0 6
3588: PUSH
3589: LD_VAR 0 6
3593: PUSH
3594: LD_EXP 52
3598: ADD
3599: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3600: LD_ADDR_EXP 53
3604: PUSH
3605: LD_STRING Kikuchi
3607: PPUSH
3608: LD_EXP 1
3612: NOT
3613: PPUSH
3614: LD_STRING 13s_
3616: PPUSH
3617: CALL 64894 0 3
3621: ST_TO_ADDR
// if Kikuchi then
3622: LD_EXP 53
3626: IFFALSE 3644
// tmp := tmp ^ Kikuchi ;
3628: LD_ADDR_VAR 0 6
3632: PUSH
3633: LD_VAR 0 6
3637: PUSH
3638: LD_EXP 53
3642: ADD
3643: ST_TO_ADDR
// vip := tmp ;
3644: LD_ADDR_EXP 59
3648: PUSH
3649: LD_VAR 0 6
3653: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3654: LD_ADDR_VAR 0 6
3658: PUSH
3659: LD_VAR 0 6
3663: PUSH
3664: LD_STRING 13s_others
3666: PPUSH
3667: CALL_OW 31
3671: UNION
3672: ST_TO_ADDR
// if tmp < 20 then
3673: LD_VAR 0 6
3677: PUSH
3678: LD_INT 20
3680: LESS
3681: IFFALSE 3748
// for i = 1 to 20 - tmp do
3683: LD_ADDR_VAR 0 2
3687: PUSH
3688: DOUBLE
3689: LD_INT 1
3691: DEC
3692: ST_TO_ADDR
3693: LD_INT 20
3695: PUSH
3696: LD_VAR 0 6
3700: MINUS
3701: PUSH
3702: FOR_TO
3703: IFFALSE 3746
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3705: LD_INT 1
3707: PPUSH
3708: LD_VAR 0 2
3712: PUSH
3713: LD_INT 4
3715: MOD
3716: PUSH
3717: LD_INT 1
3719: PLUS
3720: PPUSH
3721: LD_INT 5
3723: PPUSH
3724: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3728: LD_ADDR_VAR 0 6
3732: PUSH
3733: LD_VAR 0 6
3737: PUSH
3738: CALL_OW 44
3742: ADD
3743: ST_TO_ADDR
// end ;
3744: GO 3702
3746: POP
3747: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3748: LD_ADDR_VAR 0 7
3752: PUSH
3753: LD_INT 22
3755: PUSH
3756: LD_INT 4
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: PUSH
3763: LD_INT 30
3765: PUSH
3766: LD_INT 0
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: PPUSH
3777: CALL_OW 69
3781: PUSH
3782: LD_INT 1
3784: ARRAY
3785: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3786: LD_ADDR_VAR 0 8
3790: PUSH
3791: LD_INT 22
3793: PUSH
3794: LD_INT 4
3796: PUSH
3797: EMPTY
3798: LIST
3799: LIST
3800: PUSH
3801: LD_INT 30
3803: PUSH
3804: LD_INT 6
3806: PUSH
3807: EMPTY
3808: LIST
3809: LIST
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: PPUSH
3815: CALL_OW 69
3819: PUSH
3820: LD_INT 1
3822: ARRAY
3823: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3824: LD_ADDR_VAR 0 9
3828: PUSH
3829: LD_INT 22
3831: PUSH
3832: LD_INT 4
3834: PUSH
3835: EMPTY
3836: LIST
3837: LIST
3838: PUSH
3839: LD_INT 30
3841: PUSH
3842: LD_INT 4
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: PPUSH
3853: CALL_OW 69
3857: PUSH
3858: LD_INT 1
3860: ARRAY
3861: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3862: LD_ADDR_VAR 0 10
3866: PUSH
3867: LD_INT 22
3869: PUSH
3870: LD_INT 4
3872: PUSH
3873: EMPTY
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 30
3879: PUSH
3880: LD_INT 2
3882: PUSH
3883: EMPTY
3884: LIST
3885: LIST
3886: PUSH
3887: EMPTY
3888: LIST
3889: LIST
3890: PPUSH
3891: CALL_OW 69
3895: PUSH
3896: LD_INT 1
3898: ARRAY
3899: ST_TO_ADDR
// for i in tmp do
3900: LD_ADDR_VAR 0 2
3904: PUSH
3905: LD_VAR 0 6
3909: PUSH
3910: FOR_IN
3911: IFFALSE 4037
// begin cl := GetClass ( i ) ;
3913: LD_ADDR_VAR 0 5
3917: PUSH
3918: LD_VAR 0 2
3922: PPUSH
3923: CALL_OW 257
3927: ST_TO_ADDR
// if cl > 4 then
3928: LD_VAR 0 5
3932: PUSH
3933: LD_INT 4
3935: GREATER
3936: IFFALSE 3946
// cl := 1 ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_INT 1
3945: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3946: LD_ADDR_VAR 0 3
3950: PUSH
3951: LD_VAR 0 9
3955: PUSH
3956: LD_VAR 0 7
3960: PUSH
3961: LD_VAR 0 10
3965: PUSH
3966: LD_VAR 0 8
3970: PUSH
3971: EMPTY
3972: LIST
3973: LIST
3974: LIST
3975: LIST
3976: PUSH
3977: LD_VAR 0 5
3981: ARRAY
3982: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3983: LD_VAR 0 3
3987: PPUSH
3988: CALL_OW 313
3992: PUSH
3993: LD_INT 5
3995: LESS
3996: IFFALSE 4014
// PlaceHumanInUnit ( i , b ) else
3998: LD_VAR 0 2
4002: PPUSH
4003: LD_VAR 0 3
4007: PPUSH
4008: CALL_OW 52
4012: GO 4035
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
4014: LD_VAR 0 2
4018: PPUSH
4019: LD_INT 58
4021: PPUSH
4022: LD_INT 91
4024: PPUSH
4025: LD_INT 6
4027: PPUSH
4028: LD_INT 0
4030: PPUSH
4031: CALL_OW 50
// end ;
4035: GO 3910
4037: POP
4038: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4039: LD_INT 2
4041: PPUSH
4042: LD_INT 1
4044: PPUSH
4045: LD_INT 1
4047: PPUSH
4048: LD_INT 12
4050: PPUSH
4051: LD_INT 100
4053: PPUSH
4054: CALL 72009 0 5
// veh := CreateVehicle ;
4058: LD_ADDR_VAR 0 4
4062: PUSH
4063: CALL_OW 45
4067: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4068: LD_VAR 0 4
4072: PPUSH
4073: LD_INT 4
4075: PPUSH
4076: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4080: LD_VAR 0 4
4084: PPUSH
4085: LD_INT 49
4087: PPUSH
4088: LD_INT 88
4090: PPUSH
4091: LD_INT 0
4093: PPUSH
4094: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4098: LD_VAR 0 4
4102: PPUSH
4103: LD_INT 1
4105: PPUSH
4106: LD_INT 100
4108: PPUSH
4109: CALL_OW 290
// uc_side := 0 ;
4113: LD_ADDR_OWVAR 20
4117: PUSH
4118: LD_INT 0
4120: ST_TO_ADDR
// uc_nation := 0 ;
4121: LD_ADDR_OWVAR 21
4125: PUSH
4126: LD_INT 0
4128: ST_TO_ADDR
// for i = 1 to 4 do
4129: LD_ADDR_VAR 0 2
4133: PUSH
4134: DOUBLE
4135: LD_INT 1
4137: DEC
4138: ST_TO_ADDR
4139: LD_INT 4
4141: PUSH
4142: FOR_TO
4143: IFFALSE 4174
// begin InitHc ;
4145: CALL_OW 19
// hc_class := class_apeman ;
4149: LD_ADDR_OWVAR 28
4153: PUSH
4154: LD_INT 12
4156: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4157: CALL_OW 44
4161: PPUSH
4162: LD_INT 13
4164: PPUSH
4165: LD_INT 0
4167: PPUSH
4168: CALL_OW 49
// end ;
4172: GO 4142
4174: POP
4175: POP
// end ; end_of_file
4176: LD_VAR 0 1
4180: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4181: LD_INT 0
4183: PPUSH
4184: PPUSH
4185: PPUSH
4186: PPUSH
4187: PPUSH
// side := 8 ;
4188: LD_ADDR_VAR 0 3
4192: PUSH
4193: LD_INT 8
4195: ST_TO_ADDR
// uc_side := side ;
4196: LD_ADDR_OWVAR 20
4200: PUSH
4201: LD_VAR 0 3
4205: ST_TO_ADDR
// uc_nation := 2 ;
4206: LD_ADDR_OWVAR 21
4210: PUSH
4211: LD_INT 2
4213: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4214: LD_ADDR_VAR 0 2
4218: PUSH
4219: LD_INT 22
4221: PUSH
4222: LD_VAR 0 3
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: PUSH
4231: LD_INT 21
4233: PUSH
4234: LD_INT 3
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: PPUSH
4245: CALL_OW 69
4249: PUSH
4250: FOR_IN
4251: IFFALSE 4267
// SetBLevel ( i , 10 ) ;
4253: LD_VAR 0 2
4257: PPUSH
4258: LD_INT 10
4260: PPUSH
4261: CALL_OW 241
4265: GO 4250
4267: POP
4268: POP
// if KurtStatus then
4269: LD_EXP 3
4273: IFFALSE 4296
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4275: LD_ADDR_EXP 60
4279: PUSH
4280: LD_STRING Kurt
4282: PPUSH
4283: LD_INT 0
4285: PPUSH
4286: LD_STRING 
4288: PPUSH
4289: CALL 64894 0 3
4293: ST_TO_ADDR
4294: GO 4318
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4296: LD_ADDR_EXP 60
4300: PUSH
4301: LD_STRING AltKurt
4303: PPUSH
4304: LD_EXP 1
4308: NOT
4309: PPUSH
4310: LD_STRING 
4312: PPUSH
4313: CALL 64894 0 3
4317: ST_TO_ADDR
// if not Kurt then
4318: LD_EXP 60
4322: NOT
4323: IFFALSE 4349
// begin InitHc ;
4325: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4329: LD_INT 1
4331: PPUSH
4332: LD_INT 10
4334: PPUSH
4335: CALL_OW 381
// Kurt := CreateHuman ;
4339: LD_ADDR_EXP 60
4343: PUSH
4344: CALL_OW 44
4348: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4349: LD_EXP 60
4353: PPUSH
4354: LD_INT 324
4356: PPUSH
4357: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4361: LD_ADDR_EXP 61
4365: PUSH
4366: LD_STRING Kozlov
4368: PPUSH
4369: LD_INT 0
4371: PPUSH
4372: LD_STRING 
4374: PPUSH
4375: CALL 64894 0 3
4379: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4380: LD_EXP 61
4384: PPUSH
4385: LD_INT 22
4387: PUSH
4388: LD_INT 8
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: LD_INT 23
4397: PUSH
4398: LD_INT 3
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: PUSH
4405: LD_INT 30
4407: PUSH
4408: LD_INT 8
4410: PUSH
4411: EMPTY
4412: LIST
4413: LIST
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PPUSH
4420: CALL_OW 69
4424: PUSH
4425: LD_INT 1
4427: ARRAY
4428: PPUSH
4429: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4433: LD_EXP 61
4437: PPUSH
4438: LD_INT 3
4440: PPUSH
4441: LD_INT 10
4443: PPUSH
4444: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4448: LD_ADDR_VAR 0 5
4452: PUSH
4453: LD_INT 22
4455: PUSH
4456: LD_VAR 0 3
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: PUSH
4465: LD_INT 30
4467: PUSH
4468: LD_INT 32
4470: PUSH
4471: EMPTY
4472: LIST
4473: LIST
4474: PUSH
4475: LD_INT 58
4477: PUSH
4478: EMPTY
4479: LIST
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: LIST
4485: PPUSH
4486: CALL_OW 69
4490: ST_TO_ADDR
// for i = 1 to 10 do
4491: LD_ADDR_VAR 0 2
4495: PUSH
4496: DOUBLE
4497: LD_INT 1
4499: DEC
4500: ST_TO_ADDR
4501: LD_INT 10
4503: PUSH
4504: FOR_TO
4505: IFFALSE 4577
// begin uc_nation := nation_nature ;
4507: LD_ADDR_OWVAR 21
4511: PUSH
4512: LD_INT 0
4514: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4515: LD_ADDR_OWVAR 28
4519: PUSH
4520: LD_INT 15
4522: ST_TO_ADDR
// hc_gallery :=  ;
4523: LD_ADDR_OWVAR 33
4527: PUSH
4528: LD_STRING 
4530: ST_TO_ADDR
// hc_name :=  ;
4531: LD_ADDR_OWVAR 26
4535: PUSH
4536: LD_STRING 
4538: ST_TO_ADDR
// un := CreateHuman ;
4539: LD_ADDR_VAR 0 4
4543: PUSH
4544: CALL_OW 44
4548: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4549: LD_VAR 0 4
4553: PPUSH
4554: LD_VAR 0 5
4558: PUSH
4559: LD_VAR 0 5
4563: PUSH
4564: LD_VAR 0 2
4568: MINUS
4569: ARRAY
4570: PPUSH
4571: CALL_OW 52
// end ;
4575: GO 4504
4577: POP
4578: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4579: LD_ADDR_VAR 0 5
4583: PUSH
4584: LD_STRING 12_kurt_squad
4586: PPUSH
4587: CALL_OW 31
4591: ST_TO_ADDR
// if tmp then
4592: LD_VAR 0 5
4596: IFFALSE 4630
// for i in tmp do
4598: LD_ADDR_VAR 0 2
4602: PUSH
4603: LD_VAR 0 5
4607: PUSH
4608: FOR_IN
4609: IFFALSE 4628
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4611: LD_VAR 0 2
4615: PPUSH
4616: LD_INT 5
4618: PPUSH
4619: LD_INT 0
4621: PPUSH
4622: CALL_OW 49
4626: GO 4608
4628: POP
4629: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4630: LD_INT 324
4632: PPUSH
4633: LD_INT 5
4635: PPUSH
4636: LD_STRING 
4638: PPUSH
4639: LD_INT 8
4641: PUSH
4642: LD_INT 9
4644: PUSH
4645: LD_INT 10
4647: PUSH
4648: EMPTY
4649: LIST
4650: LIST
4651: LIST
4652: PUSH
4653: LD_OWVAR 67
4657: ARRAY
4658: PPUSH
4659: LD_INT 3000
4661: PUSH
4662: LD_INT 500
4664: PUSH
4665: LD_INT 150
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: LIST
4672: PPUSH
4673: LD_INT 16
4675: PUSH
4676: LD_INT 6
4678: PUSH
4679: LD_INT 6
4681: PUSH
4682: LD_INT 8
4684: PUSH
4685: EMPTY
4686: LIST
4687: LIST
4688: LIST
4689: LIST
4690: PPUSH
4691: CALL 75418 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4695: LD_ADDR_EXP 102
4699: PUSH
4700: LD_EXP 102
4704: PPUSH
4705: LD_INT 3
4707: PPUSH
4708: LD_INT 22
4710: PUSH
4711: LD_VAR 0 3
4715: PUSH
4716: EMPTY
4717: LIST
4718: LIST
4719: PUSH
4720: LD_INT 23
4722: PUSH
4723: LD_INT 2
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: LD_INT 3
4732: PUSH
4733: LD_INT 21
4735: PUSH
4736: LD_INT 2
4738: PUSH
4739: EMPTY
4740: LIST
4741: LIST
4742: PUSH
4743: EMPTY
4744: LIST
4745: LIST
4746: PUSH
4747: EMPTY
4748: LIST
4749: LIST
4750: LIST
4751: PPUSH
4752: CALL_OW 69
4756: PUSH
4757: LD_EXP 60
4761: DIFF
4762: PPUSH
4763: CALL_OW 1
4767: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4768: LD_INT 1
4770: PPUSH
4771: LD_INT 7
4773: PPUSH
4774: CALL_OW 383
// Friend := CreateHuman ;
4778: LD_ADDR_EXP 62
4782: PUSH
4783: CALL_OW 44
4787: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4788: LD_INT 14
4790: PPUSH
4791: LD_INT 3
4793: PPUSH
4794: LD_INT 1
4796: PPUSH
4797: LD_INT 29
4799: PPUSH
4800: LD_INT 100
4802: PPUSH
4803: CALL 72009 0 5
// powellBomb := CreateVehicle ;
4807: LD_ADDR_EXP 63
4811: PUSH
4812: CALL_OW 45
4816: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4817: LD_EXP 63
4821: PPUSH
4822: LD_INT 90
4824: PPUSH
4825: LD_INT 51
4827: PPUSH
4828: LD_INT 0
4830: PPUSH
4831: CALL_OW 48
// end ;
4835: LD_VAR 0 1
4839: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4840: LD_INT 0
4842: PPUSH
4843: PPUSH
4844: PPUSH
// if IsLive ( kozlov_fac ) then
4845: LD_INT 332
4847: PPUSH
4848: CALL_OW 300
4852: IFFALSE 4856
// exit ;
4854: GO 5423
// ComExitBuilding ( Kozlov ) ;
4856: LD_EXP 61
4860: PPUSH
4861: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4865: LD_EXP 61
4869: PPUSH
4870: CALL_OW 257
4874: PUSH
4875: LD_INT 2
4877: NONEQUAL
4878: IFFALSE 4913
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4880: LD_EXP 61
4884: PPUSH
4885: LD_INT 324
4887: PPUSH
4888: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4892: LD_EXP 61
4896: PPUSH
4897: LD_INT 2
4899: PPUSH
4900: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4904: LD_EXP 61
4908: PPUSH
4909: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4913: LD_EXP 61
4917: PPUSH
4918: LD_INT 2
4920: PPUSH
4921: LD_INT 93
4923: PPUSH
4924: LD_INT 32
4926: PPUSH
4927: LD_INT 3
4929: PPUSH
4930: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4934: LD_INT 35
4936: PPUSH
4937: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4941: LD_INT 22
4943: PUSH
4944: LD_INT 8
4946: PUSH
4947: EMPTY
4948: LIST
4949: LIST
4950: PUSH
4951: LD_INT 30
4953: PUSH
4954: LD_INT 3
4956: PUSH
4957: EMPTY
4958: LIST
4959: LIST
4960: PUSH
4961: LD_INT 23
4963: PUSH
4964: LD_INT 3
4966: PUSH
4967: EMPTY
4968: LIST
4969: LIST
4970: PUSH
4971: LD_INT 57
4973: PUSH
4974: EMPTY
4975: LIST
4976: PUSH
4977: EMPTY
4978: LIST
4979: LIST
4980: LIST
4981: LIST
4982: PPUSH
4983: CALL_OW 69
4987: IFFALSE 4934
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4989: LD_ADDR_VAR 0 2
4993: PUSH
4994: LD_INT 22
4996: PUSH
4997: LD_INT 8
4999: PUSH
5000: EMPTY
5001: LIST
5002: LIST
5003: PUSH
5004: LD_INT 30
5006: PUSH
5007: LD_INT 3
5009: PUSH
5010: EMPTY
5011: LIST
5012: LIST
5013: PUSH
5014: LD_INT 23
5016: PUSH
5017: LD_INT 3
5019: PUSH
5020: EMPTY
5021: LIST
5022: LIST
5023: PUSH
5024: LD_INT 57
5026: PUSH
5027: EMPTY
5028: LIST
5029: PUSH
5030: EMPTY
5031: LIST
5032: LIST
5033: LIST
5034: LIST
5035: PPUSH
5036: CALL_OW 69
5040: PUSH
5041: LD_INT 1
5043: ARRAY
5044: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5045: LD_INT 22
5047: PUSH
5048: LD_INT 8
5050: PUSH
5051: EMPTY
5052: LIST
5053: LIST
5054: PUSH
5055: LD_INT 23
5057: PUSH
5058: LD_INT 3
5060: PUSH
5061: EMPTY
5062: LIST
5063: LIST
5064: PUSH
5065: LD_INT 30
5067: PUSH
5068: LD_INT 21
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: PUSH
5075: EMPTY
5076: LIST
5077: LIST
5078: LIST
5079: PPUSH
5080: CALL_OW 69
5084: NOT
5085: IFFALSE 5163
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5087: LD_EXP 61
5091: PPUSH
5092: LD_INT 21
5094: PPUSH
5095: LD_INT 97
5097: PPUSH
5098: LD_INT 36
5100: PPUSH
5101: LD_INT 5
5103: PPUSH
5104: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5108: LD_INT 35
5110: PPUSH
5111: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5115: LD_INT 22
5117: PUSH
5118: LD_INT 8
5120: PUSH
5121: EMPTY
5122: LIST
5123: LIST
5124: PUSH
5125: LD_INT 23
5127: PUSH
5128: LD_INT 3
5130: PUSH
5131: EMPTY
5132: LIST
5133: LIST
5134: PUSH
5135: LD_INT 30
5137: PUSH
5138: LD_INT 21
5140: PUSH
5141: EMPTY
5142: LIST
5143: LIST
5144: PUSH
5145: LD_INT 57
5147: PUSH
5148: EMPTY
5149: LIST
5150: PUSH
5151: EMPTY
5152: LIST
5153: LIST
5154: LIST
5155: LIST
5156: PPUSH
5157: CALL_OW 69
5161: IFFALSE 5108
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5163: LD_INT 22
5165: PUSH
5166: LD_INT 8
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: PUSH
5173: LD_INT 23
5175: PUSH
5176: LD_INT 3
5178: PUSH
5179: EMPTY
5180: LIST
5181: LIST
5182: PUSH
5183: LD_INT 30
5185: PUSH
5186: LD_INT 18
5188: PUSH
5189: EMPTY
5190: LIST
5191: LIST
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: LIST
5197: PPUSH
5198: CALL_OW 69
5202: NOT
5203: IFFALSE 5281
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5205: LD_EXP 61
5209: PPUSH
5210: LD_INT 18
5212: PPUSH
5213: LD_INT 89
5215: PPUSH
5216: LD_INT 32
5218: PPUSH
5219: LD_INT 1
5221: PPUSH
5222: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5226: LD_INT 35
5228: PPUSH
5229: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5233: LD_INT 22
5235: PUSH
5236: LD_INT 8
5238: PUSH
5239: EMPTY
5240: LIST
5241: LIST
5242: PUSH
5243: LD_INT 23
5245: PUSH
5246: LD_INT 3
5248: PUSH
5249: EMPTY
5250: LIST
5251: LIST
5252: PUSH
5253: LD_INT 30
5255: PUSH
5256: LD_INT 18
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: PUSH
5263: LD_INT 57
5265: PUSH
5266: EMPTY
5267: LIST
5268: PUSH
5269: EMPTY
5270: LIST
5271: LIST
5272: LIST
5273: LIST
5274: PPUSH
5275: CALL_OW 69
5279: IFFALSE 5226
// end ; lab := kozlov_lab ;
5281: LD_ADDR_VAR 0 3
5285: PUSH
5286: LD_INT 336
5288: ST_TO_ADDR
// if not lab then
5289: LD_VAR 0 3
5293: NOT
5294: IFFALSE 5298
// exit ;
5296: GO 5423
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5298: LD_EXP 61
5302: PPUSH
5303: LD_VAR 0 3
5307: PUSH
5308: LD_INT 1
5310: ARRAY
5311: PPUSH
5312: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5316: LD_EXP 61
5320: PPUSH
5321: LD_INT 4
5323: PPUSH
5324: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5328: LD_VAR 0 3
5332: PUSH
5333: LD_INT 1
5335: ARRAY
5336: PPUSH
5337: LD_INT 25
5339: PPUSH
5340: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5344: LD_INT 35
5346: PPUSH
5347: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5351: LD_INT 25
5353: PPUSH
5354: LD_INT 8
5356: PPUSH
5357: CALL_OW 321
5361: PUSH
5362: LD_INT 2
5364: EQUAL
5365: IFFALSE 5344
// ComExitBuilding ( Kozlov ) ;
5367: LD_EXP 61
5371: PPUSH
5372: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5376: LD_EXP 61
5380: PPUSH
5381: LD_VAR 0 2
5385: PPUSH
5386: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5390: LD_EXP 61
5394: PPUSH
5395: LD_INT 3
5397: PPUSH
5398: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5402: LD_VAR 0 2
5406: PPUSH
5407: LD_INT 23
5409: PPUSH
5410: LD_INT 3
5412: PPUSH
5413: LD_INT 1
5415: PPUSH
5416: LD_INT 48
5418: PPUSH
5419: CALL_OW 125
// end ;
5423: LD_VAR 0 1
5427: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5428: LD_EXP 22
5432: NOT
5433: PUSH
5434: LD_EXP 15
5438: PUSH
5439: LD_INT 6
5441: GREATEREQUAL
5442: AND
5443: IFFALSE 5524
5445: GO 5447
5447: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5448: LD_INT 3
5450: PPUSH
5451: LD_INT 3
5453: PPUSH
5454: CALL 58687 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5458: LD_INT 3
5460: PPUSH
5461: LD_INT 14
5463: PUSH
5464: LD_INT 1
5466: PUSH
5467: LD_INT 1
5469: PUSH
5470: LD_INT 28
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: LIST
5477: LIST
5478: PUSH
5479: LD_INT 14
5481: PUSH
5482: LD_INT 1
5484: PUSH
5485: LD_INT 1
5487: PUSH
5488: LD_INT 28
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: LIST
5495: LIST
5496: PUSH
5497: LD_INT 14
5499: PUSH
5500: LD_INT 1
5502: PUSH
5503: LD_INT 1
5505: PUSH
5506: LD_INT 28
5508: PUSH
5509: EMPTY
5510: LIST
5511: LIST
5512: LIST
5513: LIST
5514: PUSH
5515: EMPTY
5516: LIST
5517: LIST
5518: LIST
5519: PPUSH
5520: CALL 58550 0 2
// end ;
5524: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5525: LD_EXP 22
5529: NOT
5530: PUSH
5531: LD_EXP 15
5535: PUSH
5536: LD_INT 6
5538: GREATEREQUAL
5539: AND
5540: PUSH
5541: LD_INT 3
5543: PPUSH
5544: LD_INT 1
5546: PPUSH
5547: CALL 59968 0 2
5551: NOT
5552: AND
5553: IFFALSE 6393
5555: GO 5557
5557: DISABLE
5558: LD_INT 0
5560: PPUSH
5561: PPUSH
5562: PPUSH
// begin enable ;
5563: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5564: LD_INT 22
5566: PUSH
5567: LD_INT 8
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: PUSH
5574: LD_INT 23
5576: PUSH
5577: LD_INT 2
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: PUSH
5584: LD_INT 30
5586: PUSH
5587: LD_INT 3
5589: PUSH
5590: EMPTY
5591: LIST
5592: LIST
5593: PUSH
5594: EMPTY
5595: LIST
5596: LIST
5597: LIST
5598: PPUSH
5599: CALL_OW 69
5603: NOT
5604: IFFALSE 5608
// exit ;
5606: GO 6393
// if Prob ( 40 ) then
5608: LD_INT 40
5610: PPUSH
5611: CALL_OW 13
5615: IFFALSE 5742
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5617: LD_INT 3
5619: PPUSH
5620: LD_INT 14
5622: PUSH
5623: LD_INT 1
5625: PUSH
5626: LD_INT 2
5628: PUSH
5629: LD_INT 28
5631: PUSH
5632: EMPTY
5633: LIST
5634: LIST
5635: LIST
5636: LIST
5637: PUSH
5638: LD_INT 14
5640: PUSH
5641: LD_INT 1
5643: PUSH
5644: LD_INT 2
5646: PUSH
5647: LD_INT 28
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: LIST
5654: LIST
5655: PUSH
5656: LD_INT 14
5658: PUSH
5659: LD_INT 1
5661: PUSH
5662: LD_INT 2
5664: PUSH
5665: LD_INT 28
5667: PUSH
5668: EMPTY
5669: LIST
5670: LIST
5671: LIST
5672: LIST
5673: PUSH
5674: LD_INT 14
5676: PUSH
5677: LD_INT 1
5679: PUSH
5680: LD_INT 2
5682: PUSH
5683: LD_INT 28
5685: PUSH
5686: EMPTY
5687: LIST
5688: LIST
5689: LIST
5690: LIST
5691: PUSH
5692: LD_INT 14
5694: PUSH
5695: LD_INT 1
5697: PUSH
5698: LD_INT 2
5700: PUSH
5701: LD_INT 28
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: LIST
5708: LIST
5709: PUSH
5710: LD_INT 14
5712: PUSH
5713: LD_INT 1
5715: PUSH
5716: LD_INT 2
5718: PUSH
5719: LD_INT 26
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: LIST
5726: LIST
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: LIST
5732: LIST
5733: LIST
5734: LIST
5735: PPUSH
5736: CALL 58550 0 2
// end else
5740: GO 5933
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5742: LD_INT 3
5744: PPUSH
5745: LD_INT 14
5747: PUSH
5748: LD_INT 1
5750: PUSH
5751: LD_INT 2
5753: PUSH
5754: LD_INT 27
5756: PUSH
5757: LD_INT 26
5759: PUSH
5760: LD_INT 26
5762: PUSH
5763: EMPTY
5764: LIST
5765: LIST
5766: LIST
5767: PUSH
5768: LD_OWVAR 67
5772: ARRAY
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: LIST
5778: LIST
5779: PUSH
5780: LD_INT 14
5782: PUSH
5783: LD_INT 1
5785: PUSH
5786: LD_INT 2
5788: PUSH
5789: LD_INT 27
5791: PUSH
5792: LD_INT 26
5794: PUSH
5795: LD_INT 26
5797: PUSH
5798: EMPTY
5799: LIST
5800: LIST
5801: LIST
5802: PUSH
5803: LD_OWVAR 67
5807: ARRAY
5808: PUSH
5809: EMPTY
5810: LIST
5811: LIST
5812: LIST
5813: LIST
5814: PUSH
5815: LD_INT 14
5817: PUSH
5818: LD_INT 1
5820: PUSH
5821: LD_INT 2
5823: PUSH
5824: LD_INT 26
5826: PUSH
5827: LD_INT 26
5829: PUSH
5830: LD_INT 29
5832: PUSH
5833: EMPTY
5834: LIST
5835: LIST
5836: LIST
5837: PUSH
5838: LD_OWVAR 67
5842: ARRAY
5843: PUSH
5844: EMPTY
5845: LIST
5846: LIST
5847: LIST
5848: LIST
5849: PUSH
5850: LD_INT 13
5852: PUSH
5853: LD_INT 1
5855: PUSH
5856: LD_INT 2
5858: PUSH
5859: LD_INT 26
5861: PUSH
5862: LD_INT 29
5864: PUSH
5865: LD_INT 29
5867: PUSH
5868: EMPTY
5869: LIST
5870: LIST
5871: LIST
5872: PUSH
5873: LD_OWVAR 67
5877: ARRAY
5878: PUSH
5879: EMPTY
5880: LIST
5881: LIST
5882: LIST
5883: LIST
5884: PUSH
5885: LD_INT 13
5887: PUSH
5888: LD_INT 1
5890: PUSH
5891: LD_INT 2
5893: PUSH
5894: LD_INT 29
5896: PUSH
5897: EMPTY
5898: LIST
5899: LIST
5900: LIST
5901: LIST
5902: PUSH
5903: LD_INT 14
5905: PUSH
5906: LD_INT 1
5908: PUSH
5909: LD_INT 2
5911: PUSH
5912: LD_INT 26
5914: PUSH
5915: EMPTY
5916: LIST
5917: LIST
5918: LIST
5919: LIST
5920: PUSH
5921: EMPTY
5922: LIST
5923: LIST
5924: LIST
5925: LIST
5926: LIST
5927: LIST
5928: PPUSH
5929: CALL 58550 0 2
// end ; repeat wait ( 0 0$1 ) ;
5933: LD_INT 35
5935: PPUSH
5936: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5940: LD_INT 3
5942: PPUSH
5943: LD_INT 1
5945: PPUSH
5946: CALL 59968 0 2
5950: PUSH
5951: LD_INT 6
5953: GREATEREQUAL
5954: IFFALSE 5933
// wait ( 0 0$30 ) ;
5956: LD_INT 1050
5958: PPUSH
5959: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5963: LD_ADDR_VAR 0 2
5967: PUSH
5968: LD_INT 3
5970: PPUSH
5971: LD_INT 1
5973: PPUSH
5974: CALL 59968 0 2
5978: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5979: LD_ADDR_EXP 121
5983: PUSH
5984: LD_EXP 121
5988: PPUSH
5989: LD_INT 3
5991: PPUSH
5992: LD_EXP 121
5996: PUSH
5997: LD_INT 3
5999: ARRAY
6000: PUSH
6001: LD_VAR 0 2
6005: DIFF
6006: PPUSH
6007: CALL_OW 1
6011: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6012: LD_ADDR_VAR 0 3
6016: PUSH
6017: LD_INT 0
6019: PPUSH
6020: LD_INT 2
6022: PPUSH
6023: CALL_OW 12
6027: ST_TO_ADDR
// if target then
6028: LD_VAR 0 3
6032: IFFALSE 6160
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6034: LD_ADDR_VAR 0 2
6038: PUSH
6039: LD_VAR 0 2
6043: PPUSH
6044: LD_INT 24
6046: PUSH
6047: LD_INT 250
6049: PUSH
6050: EMPTY
6051: LIST
6052: LIST
6053: PPUSH
6054: CALL_OW 72
6058: ST_TO_ADDR
// for i in tmp do
6059: LD_ADDR_VAR 0 1
6063: PUSH
6064: LD_VAR 0 2
6068: PUSH
6069: FOR_IN
6070: IFFALSE 6110
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6072: LD_VAR 0 1
6076: PPUSH
6077: LD_INT 89
6079: PPUSH
6080: LD_INT 71
6082: PPUSH
6083: CALL_OW 297
6087: PUSH
6088: LD_INT 9
6090: GREATER
6091: IFFALSE 6108
// ComMoveXY ( i , 89 , 71 ) ;
6093: LD_VAR 0 1
6097: PPUSH
6098: LD_INT 89
6100: PPUSH
6101: LD_INT 71
6103: PPUSH
6104: CALL_OW 111
6108: GO 6069
6110: POP
6111: POP
// wait ( 0 0$1 ) ;
6112: LD_INT 35
6114: PPUSH
6115: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6119: LD_VAR 0 2
6123: PPUSH
6124: LD_INT 92
6126: PUSH
6127: LD_INT 89
6129: PUSH
6130: LD_INT 71
6132: PUSH
6133: LD_INT 9
6135: PUSH
6136: EMPTY
6137: LIST
6138: LIST
6139: LIST
6140: LIST
6141: PPUSH
6142: CALL_OW 72
6146: PUSH
6147: LD_VAR 0 2
6151: PUSH
6152: LD_INT 1
6154: MINUS
6155: GREATEREQUAL
6156: IFFALSE 6034
// end else
6158: GO 6284
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6160: LD_ADDR_VAR 0 2
6164: PUSH
6165: LD_VAR 0 2
6169: PPUSH
6170: LD_INT 24
6172: PUSH
6173: LD_INT 250
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: PPUSH
6180: CALL_OW 72
6184: ST_TO_ADDR
// for i in tmp do
6185: LD_ADDR_VAR 0 1
6189: PUSH
6190: LD_VAR 0 2
6194: PUSH
6195: FOR_IN
6196: IFFALSE 6236
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6198: LD_VAR 0 1
6202: PPUSH
6203: LD_INT 125
6205: PPUSH
6206: LD_INT 129
6208: PPUSH
6209: CALL_OW 297
6213: PUSH
6214: LD_INT 9
6216: GREATER
6217: IFFALSE 6234
// ComMoveXY ( i , 125 , 129 ) ;
6219: LD_VAR 0 1
6223: PPUSH
6224: LD_INT 125
6226: PPUSH
6227: LD_INT 129
6229: PPUSH
6230: CALL_OW 111
6234: GO 6195
6236: POP
6237: POP
// wait ( 0 0$1 ) ;
6238: LD_INT 35
6240: PPUSH
6241: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6245: LD_VAR 0 2
6249: PPUSH
6250: LD_INT 92
6252: PUSH
6253: LD_INT 125
6255: PUSH
6256: LD_INT 129
6258: PUSH
6259: LD_INT 9
6261: PUSH
6262: EMPTY
6263: LIST
6264: LIST
6265: LIST
6266: LIST
6267: PPUSH
6268: CALL_OW 72
6272: PUSH
6273: LD_VAR 0 2
6277: PUSH
6278: LD_INT 1
6280: MINUS
6281: GREATEREQUAL
6282: IFFALSE 6160
// end ; repeat wait ( 0 0$1 ) ;
6284: LD_INT 35
6286: PPUSH
6287: CALL_OW 67
// for i in tmp do
6291: LD_ADDR_VAR 0 1
6295: PUSH
6296: LD_VAR 0 2
6300: PUSH
6301: FOR_IN
6302: IFFALSE 6384
// begin if GetLives ( i ) > 251 then
6304: LD_VAR 0 1
6308: PPUSH
6309: CALL_OW 256
6313: PUSH
6314: LD_INT 251
6316: GREATER
6317: IFFALSE 6355
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6319: LD_VAR 0 1
6323: PPUSH
6324: LD_INT 81
6326: PUSH
6327: LD_INT 8
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: PPUSH
6334: CALL_OW 69
6338: PPUSH
6339: LD_VAR 0 1
6343: PPUSH
6344: CALL_OW 74
6348: PPUSH
6349: CALL_OW 115
6353: GO 6382
// if IsDead ( i ) then
6355: LD_VAR 0 1
6359: PPUSH
6360: CALL_OW 301
6364: IFFALSE 6382
// tmp := tmp diff i ;
6366: LD_ADDR_VAR 0 2
6370: PUSH
6371: LD_VAR 0 2
6375: PUSH
6376: LD_VAR 0 1
6380: DIFF
6381: ST_TO_ADDR
// end ;
6382: GO 6301
6384: POP
6385: POP
// until not tmp ;
6386: LD_VAR 0 2
6390: NOT
6391: IFFALSE 6284
// end ;
6393: PPOPN 3
6395: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6396: LD_EXP 22
6400: NOT
6401: PUSH
6402: LD_EXP 15
6406: PUSH
6407: LD_INT 6
6409: GREATEREQUAL
6410: AND
6411: PUSH
6412: LD_OWVAR 67
6416: PUSH
6417: LD_INT 1
6419: GREATER
6420: AND
6421: IFFALSE 6938
6423: GO 6425
6425: DISABLE
6426: LD_INT 0
6428: PPUSH
6429: PPUSH
6430: PPUSH
// begin enable ;
6431: ENABLE
// tmp := [ ] ;
6432: LD_ADDR_VAR 0 3
6436: PUSH
6437: EMPTY
6438: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6439: LD_ADDR_VAR 0 1
6443: PUSH
6444: DOUBLE
6445: LD_INT 1
6447: DEC
6448: ST_TO_ADDR
6449: LD_INT 4
6451: PUSH
6452: LD_INT 6
6454: PUSH
6455: LD_INT 7
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: LIST
6462: PUSH
6463: LD_OWVAR 67
6467: ARRAY
6468: PUSH
6469: FOR_TO
6470: IFFALSE 6630
// begin uc_side := 8 ;
6472: LD_ADDR_OWVAR 20
6476: PUSH
6477: LD_INT 8
6479: ST_TO_ADDR
// uc_nation := 2 ;
6480: LD_ADDR_OWVAR 21
6484: PUSH
6485: LD_INT 2
6487: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6488: LD_INT 13
6490: PUSH
6491: LD_INT 14
6493: PUSH
6494: EMPTY
6495: LIST
6496: LIST
6497: PUSH
6498: LD_INT 1
6500: PPUSH
6501: LD_INT 2
6503: PPUSH
6504: CALL_OW 12
6508: ARRAY
6509: PPUSH
6510: LD_INT 1
6512: PPUSH
6513: LD_INT 5
6515: PPUSH
6516: LD_INT 27
6518: PUSH
6519: LD_INT 28
6521: PUSH
6522: LD_INT 26
6524: PUSH
6525: LD_INT 25
6527: PUSH
6528: EMPTY
6529: LIST
6530: LIST
6531: LIST
6532: LIST
6533: PUSH
6534: LD_INT 1
6536: PPUSH
6537: LD_INT 4
6539: PPUSH
6540: CALL_OW 12
6544: ARRAY
6545: PPUSH
6546: LD_INT 88
6548: PPUSH
6549: CALL 72009 0 5
// un := CreateVehicle ;
6553: LD_ADDR_VAR 0 2
6557: PUSH
6558: CALL_OW 45
6562: ST_TO_ADDR
// tmp := tmp ^ un ;
6563: LD_ADDR_VAR 0 3
6567: PUSH
6568: LD_VAR 0 3
6572: PUSH
6573: LD_VAR 0 2
6577: ADD
6578: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6579: LD_VAR 0 2
6583: PPUSH
6584: LD_INT 3
6586: PPUSH
6587: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6591: LD_VAR 0 2
6595: PPUSH
6596: LD_INT 30
6598: PPUSH
6599: LD_INT 0
6601: PPUSH
6602: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6606: LD_VAR 0 2
6610: PPUSH
6611: LD_INT 16
6613: PPUSH
6614: LD_INT 11
6616: PPUSH
6617: CALL_OW 111
// wait ( 0 0$2 ) ;
6621: LD_INT 70
6623: PPUSH
6624: CALL_OW 67
// end ;
6628: GO 6469
6630: POP
6631: POP
// for i = 1 to Difficulty do
6632: LD_ADDR_VAR 0 1
6636: PUSH
6637: DOUBLE
6638: LD_INT 1
6640: DEC
6641: ST_TO_ADDR
6642: LD_OWVAR 67
6646: PUSH
6647: FOR_TO
6648: IFFALSE 6773
// begin uc_side := 8 ;
6650: LD_ADDR_OWVAR 20
6654: PUSH
6655: LD_INT 8
6657: ST_TO_ADDR
// uc_nation := 2 ;
6658: LD_ADDR_OWVAR 21
6662: PUSH
6663: LD_INT 2
6665: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6666: LD_INT 0
6668: PPUSH
6669: LD_INT 8
6671: PPUSH
6672: LD_INT 8
6674: PUSH
6675: LD_INT 8
6677: PUSH
6678: LD_INT 9
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: PUSH
6686: LD_OWVAR 67
6690: ARRAY
6691: PPUSH
6692: CALL_OW 380
// un := CreateHuman ;
6696: LD_ADDR_VAR 0 2
6700: PUSH
6701: CALL_OW 44
6705: ST_TO_ADDR
// tmp := tmp ^ un ;
6706: LD_ADDR_VAR 0 3
6710: PUSH
6711: LD_VAR 0 3
6715: PUSH
6716: LD_VAR 0 2
6720: ADD
6721: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6722: LD_VAR 0 2
6726: PPUSH
6727: LD_INT 3
6729: PPUSH
6730: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6734: LD_VAR 0 2
6738: PPUSH
6739: LD_INT 30
6741: PPUSH
6742: LD_INT 0
6744: PPUSH
6745: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6749: LD_VAR 0 2
6753: PPUSH
6754: LD_INT 16
6756: PPUSH
6757: LD_INT 11
6759: PPUSH
6760: CALL_OW 111
// wait ( 0 0$2 ) ;
6764: LD_INT 70
6766: PPUSH
6767: CALL_OW 67
// end ;
6771: GO 6647
6773: POP
6774: POP
// repeat wait ( 0 0$1 ) ;
6775: LD_INT 35
6777: PPUSH
6778: CALL_OW 67
// for i in tmp do
6782: LD_ADDR_VAR 0 1
6786: PUSH
6787: LD_VAR 0 3
6791: PUSH
6792: FOR_IN
6793: IFFALSE 6929
// begin if GetLives ( i ) > 250 then
6795: LD_VAR 0 1
6799: PPUSH
6800: CALL_OW 256
6804: PUSH
6805: LD_INT 250
6807: GREATER
6808: IFFALSE 6900
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6810: LD_INT 81
6812: PUSH
6813: LD_INT 8
6815: PUSH
6816: EMPTY
6817: LIST
6818: LIST
6819: PUSH
6820: LD_INT 91
6822: PUSH
6823: LD_VAR 0 1
6827: PUSH
6828: LD_INT 10
6830: PUSH
6831: EMPTY
6832: LIST
6833: LIST
6834: LIST
6835: PUSH
6836: EMPTY
6837: LIST
6838: LIST
6839: PPUSH
6840: CALL_OW 69
6844: NOT
6845: IFFALSE 6864
// ComAgressiveMove ( i , 67 , 110 ) else
6847: LD_VAR 0 1
6851: PPUSH
6852: LD_INT 67
6854: PPUSH
6855: LD_INT 110
6857: PPUSH
6858: CALL_OW 114
6862: GO 6898
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6864: LD_VAR 0 1
6868: PPUSH
6869: LD_INT 81
6871: PUSH
6872: LD_INT 8
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: PPUSH
6879: CALL_OW 69
6883: PPUSH
6884: LD_VAR 0 1
6888: PPUSH
6889: CALL_OW 74
6893: PPUSH
6894: CALL_OW 115
// end else
6898: GO 6927
// if IsDead ( i ) then
6900: LD_VAR 0 1
6904: PPUSH
6905: CALL_OW 301
6909: IFFALSE 6927
// tmp := tmp diff i ;
6911: LD_ADDR_VAR 0 3
6915: PUSH
6916: LD_VAR 0 3
6920: PUSH
6921: LD_VAR 0 1
6925: DIFF
6926: ST_TO_ADDR
// end ;
6927: GO 6792
6929: POP
6930: POP
// until not tmp ;
6931: LD_VAR 0 3
6935: NOT
6936: IFFALSE 6775
// end ; end_of_file
6938: PPOPN 3
6940: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6941: LD_INT 0
6943: PPUSH
6944: PPUSH
6945: PPUSH
6946: PPUSH
6947: PPUSH
6948: PPUSH
6949: PPUSH
6950: PPUSH
6951: PPUSH
// side := 3 ;
6952: LD_ADDR_VAR 0 6
6956: PUSH
6957: LD_INT 3
6959: ST_TO_ADDR
// uc_side := side ;
6960: LD_ADDR_OWVAR 20
6964: PUSH
6965: LD_VAR 0 6
6969: ST_TO_ADDR
// uc_nation := 3 ;
6970: LD_ADDR_OWVAR 21
6974: PUSH
6975: LD_INT 3
6977: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6978: LD_ADDR_VAR 0 2
6982: PUSH
6983: LD_INT 22
6985: PUSH
6986: LD_VAR 0 6
6990: PUSH
6991: EMPTY
6992: LIST
6993: LIST
6994: PUSH
6995: LD_INT 21
6997: PUSH
6998: LD_INT 3
7000: PUSH
7001: EMPTY
7002: LIST
7003: LIST
7004: PUSH
7005: EMPTY
7006: LIST
7007: LIST
7008: PPUSH
7009: CALL_OW 69
7013: PUSH
7014: FOR_IN
7015: IFFALSE 7031
// SetBLevel ( i , 10 ) ;
7017: LD_VAR 0 2
7021: PPUSH
7022: LD_INT 10
7024: PPUSH
7025: CALL_OW 241
7029: GO 7014
7031: POP
7032: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7033: LD_ADDR_VAR 0 9
7037: PUSH
7038: LD_INT 22
7040: PUSH
7041: LD_VAR 0 6
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: PUSH
7050: LD_INT 30
7052: PUSH
7053: LD_INT 34
7055: PUSH
7056: EMPTY
7057: LIST
7058: LIST
7059: PUSH
7060: EMPTY
7061: LIST
7062: LIST
7063: PPUSH
7064: CALL_OW 69
7068: ST_TO_ADDR
// if teleport then
7069: LD_VAR 0 9
7073: IFFALSE 7094
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7075: LD_VAR 0 9
7079: PUSH
7080: LD_INT 1
7082: ARRAY
7083: PPUSH
7084: LD_INT 123
7086: PPUSH
7087: LD_INT 122
7089: PPUSH
7090: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7094: LD_ADDR_EXP 64
7098: PUSH
7099: LD_STRING Platonov
7101: PPUSH
7102: CALL_OW 25
7106: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7107: LD_ADDR_EXP 65
7111: PUSH
7112: LD_STRING Kovalyuk
7114: PPUSH
7115: CALL_OW 25
7119: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7120: LD_ADDR_EXP 67
7124: PUSH
7125: LD_STRING Yakotich
7127: PPUSH
7128: LD_EXP 1
7132: NOT
7133: PPUSH
7134: LD_STRING 09_
7136: PPUSH
7137: CALL 64894 0 3
7141: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7142: LD_ADDR_EXP 66
7146: PUSH
7147: LD_STRING Bystrov
7149: PPUSH
7150: CALL_OW 25
7154: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7155: LD_ADDR_EXP 68
7159: PUSH
7160: LD_STRING Gleb
7162: PPUSH
7163: CALL_OW 25
7167: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7168: LD_STRING 03_Cornel
7170: PPUSH
7171: CALL_OW 28
7175: IFFALSE 7223
// begin Bierezov := NewCharacter ( Mikhail ) ;
7177: LD_ADDR_EXP 69
7181: PUSH
7182: LD_STRING Mikhail
7184: PPUSH
7185: CALL_OW 25
7189: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7190: LD_EXP 69
7194: PPUSH
7195: LD_INT 197
7197: PPUSH
7198: LD_INT 111
7200: PPUSH
7201: LD_INT 9
7203: PPUSH
7204: LD_INT 0
7206: PPUSH
7207: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7211: LD_EXP 69
7215: PPUSH
7216: LD_INT 3
7218: PPUSH
7219: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7223: LD_EXP 64
7227: PPUSH
7228: LD_INT 126
7230: PPUSH
7231: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7235: LD_EXP 65
7239: PPUSH
7240: LD_INT 134
7242: PPUSH
7243: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7247: LD_EXP 67
7251: PPUSH
7252: LD_INT 197
7254: PPUSH
7255: LD_INT 111
7257: PPUSH
7258: LD_INT 9
7260: PPUSH
7261: LD_INT 0
7263: PPUSH
7264: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7268: LD_EXP 66
7272: PPUSH
7273: LD_INT 197
7275: PPUSH
7276: LD_INT 111
7278: PPUSH
7279: LD_INT 9
7281: PPUSH
7282: LD_INT 0
7284: PPUSH
7285: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7289: LD_EXP 68
7293: PPUSH
7294: LD_INT 197
7296: PPUSH
7297: LD_INT 111
7299: PPUSH
7300: LD_INT 9
7302: PPUSH
7303: LD_INT 0
7305: PPUSH
7306: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7310: LD_ADDR_VAR 0 5
7314: PUSH
7315: LD_INT 126
7317: PPUSH
7318: LD_INT 4
7320: PPUSH
7321: LD_STRING zhukov
7323: PPUSH
7324: LD_INT 9
7326: PUSH
7327: LD_INT 10
7329: PUSH
7330: LD_INT 10
7332: PUSH
7333: EMPTY
7334: LIST
7335: LIST
7336: LIST
7337: PUSH
7338: LD_OWVAR 67
7342: ARRAY
7343: PPUSH
7344: LD_INT 90000
7346: PUSH
7347: LD_INT 1000
7349: PUSH
7350: LD_INT 300
7352: PUSH
7353: EMPTY
7354: LIST
7355: LIST
7356: LIST
7357: PPUSH
7358: LD_INT 18
7360: PUSH
7361: LD_INT 8
7363: PUSH
7364: LD_INT 13
7366: PUSH
7367: LD_INT 8
7369: PUSH
7370: EMPTY
7371: LIST
7372: LIST
7373: LIST
7374: LIST
7375: PPUSH
7376: CALL 75418 0 6
7380: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7381: LD_ADDR_VAR 0 4
7385: PUSH
7386: LD_INT 267
7388: PPUSH
7389: CALL_OW 274
7393: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7394: LD_VAR 0 4
7398: PPUSH
7399: LD_INT 1
7401: PPUSH
7402: LD_INT 5000
7404: PPUSH
7405: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7409: LD_VAR 0 4
7413: PPUSH
7414: LD_INT 2
7416: PPUSH
7417: LD_INT 200
7419: PPUSH
7420: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7424: LD_VAR 0 4
7428: PPUSH
7429: LD_INT 3
7431: PPUSH
7432: LD_INT 200
7434: PPUSH
7435: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7439: LD_ADDR_EXP 102
7443: PUSH
7444: LD_EXP 102
7448: PPUSH
7449: LD_INT 2
7451: PPUSH
7452: LD_VAR 0 5
7456: PUSH
7457: LD_INT 22
7459: PUSH
7460: LD_VAR 0 6
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: PUSH
7469: LD_INT 3
7471: PUSH
7472: LD_INT 21
7474: PUSH
7475: LD_INT 2
7477: PUSH
7478: EMPTY
7479: LIST
7480: LIST
7481: PUSH
7482: EMPTY
7483: LIST
7484: LIST
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: PPUSH
7490: CALL_OW 69
7494: UNION
7495: PUSH
7496: LD_EXP 64
7500: DIFF
7501: PPUSH
7502: CALL_OW 1
7506: ST_TO_ADDR
// behemoths := [ ] ;
7507: LD_ADDR_EXP 72
7511: PUSH
7512: EMPTY
7513: ST_TO_ADDR
// behemothBuilders := [ ] ;
7514: LD_ADDR_EXP 73
7518: PUSH
7519: EMPTY
7520: ST_TO_ADDR
// if Kovalyuk then
7521: LD_EXP 65
7525: IFFALSE 7547
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7527: LD_ADDR_EXP 73
7531: PUSH
7532: LD_EXP 73
7536: PPUSH
7537: LD_EXP 65
7541: PPUSH
7542: CALL 107764 0 2
7546: ST_TO_ADDR
// j := 3 ;
7547: LD_ADDR_VAR 0 3
7551: PUSH
7552: LD_INT 3
7554: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7555: LD_ADDR_VAR 0 2
7559: PUSH
7560: LD_INT 22
7562: PUSH
7563: LD_INT 3
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: PUSH
7570: LD_INT 25
7572: PUSH
7573: LD_INT 3
7575: PUSH
7576: EMPTY
7577: LIST
7578: LIST
7579: PUSH
7580: EMPTY
7581: LIST
7582: LIST
7583: PPUSH
7584: CALL_OW 69
7588: PUSH
7589: LD_EXP 65
7593: DIFF
7594: PUSH
7595: FOR_IN
7596: IFFALSE 7646
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7598: LD_ADDR_EXP 73
7602: PUSH
7603: LD_EXP 73
7607: PPUSH
7608: LD_VAR 0 2
7612: PPUSH
7613: CALL 107764 0 2
7617: ST_TO_ADDR
// j := j - 1 ;
7618: LD_ADDR_VAR 0 3
7622: PUSH
7623: LD_VAR 0 3
7627: PUSH
7628: LD_INT 1
7630: MINUS
7631: ST_TO_ADDR
// if j = 0 then
7632: LD_VAR 0 3
7636: PUSH
7637: LD_INT 0
7639: EQUAL
7640: IFFALSE 7644
// break ;
7642: GO 7646
// end ;
7644: GO 7595
7646: POP
7647: POP
// end ;
7648: LD_VAR 0 1
7652: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7653: LD_INT 0
7655: PPUSH
7656: PPUSH
7657: PPUSH
7658: PPUSH
7659: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7660: LD_ADDR_VAR 0 4
7664: PUSH
7665: LD_INT 209
7667: PUSH
7668: LD_INT 149
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: PUSH
7675: LD_INT 219
7677: PUSH
7678: LD_INT 154
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: PUSH
7685: LD_INT 223
7687: PUSH
7688: LD_INT 149
7690: PUSH
7691: EMPTY
7692: LIST
7693: LIST
7694: PUSH
7695: LD_INT 232
7697: PUSH
7698: LD_INT 155
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: PUSH
7705: EMPTY
7706: LIST
7707: LIST
7708: LIST
7709: LIST
7710: ST_TO_ADDR
// if not behemothBuilders then
7711: LD_EXP 73
7715: NOT
7716: IFFALSE 7720
// exit ;
7718: GO 7824
// j := 1 ;
7720: LD_ADDR_VAR 0 3
7724: PUSH
7725: LD_INT 1
7727: ST_TO_ADDR
// for i in behemothBuilders do
7728: LD_ADDR_VAR 0 2
7732: PUSH
7733: LD_EXP 73
7737: PUSH
7738: FOR_IN
7739: IFFALSE 7822
// begin if IsInUnit ( i ) then
7741: LD_VAR 0 2
7745: PPUSH
7746: CALL_OW 310
7750: IFFALSE 7761
// ComExitBuilding ( i ) ;
7752: LD_VAR 0 2
7756: PPUSH
7757: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7761: LD_VAR 0 2
7765: PPUSH
7766: LD_INT 37
7768: PPUSH
7769: LD_VAR 0 4
7773: PUSH
7774: LD_VAR 0 3
7778: ARRAY
7779: PUSH
7780: LD_INT 1
7782: ARRAY
7783: PPUSH
7784: LD_VAR 0 4
7788: PUSH
7789: LD_VAR 0 3
7793: ARRAY
7794: PUSH
7795: LD_INT 2
7797: ARRAY
7798: PPUSH
7799: LD_INT 0
7801: PPUSH
7802: CALL_OW 230
// j := j + 1 ;
7806: LD_ADDR_VAR 0 3
7810: PUSH
7811: LD_VAR 0 3
7815: PUSH
7816: LD_INT 1
7818: PLUS
7819: ST_TO_ADDR
// end ;
7820: GO 7738
7822: POP
7823: POP
// end ;
7824: LD_VAR 0 1
7828: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7829: LD_INT 24
7831: PPUSH
7832: LD_INT 30
7834: PUSH
7835: LD_INT 37
7837: PUSH
7838: EMPTY
7839: LIST
7840: LIST
7841: PPUSH
7842: CALL_OW 70
7846: IFFALSE 7859
7848: GO 7850
7850: DISABLE
// behemothUnderConstruct := true ;
7851: LD_ADDR_EXP 26
7855: PUSH
7856: LD_INT 1
7858: ST_TO_ADDR
7859: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7860: LD_INT 3
7862: PPUSH
7863: CALL 107812 0 1
7867: PUSH
7868: LD_INT 22
7870: PUSH
7871: LD_INT 3
7873: PUSH
7874: EMPTY
7875: LIST
7876: LIST
7877: PUSH
7878: LD_INT 30
7880: PUSH
7881: LD_INT 37
7883: PUSH
7884: EMPTY
7885: LIST
7886: LIST
7887: PUSH
7888: EMPTY
7889: LIST
7890: LIST
7891: PPUSH
7892: CALL_OW 69
7896: NOT
7897: AND
7898: IFFALSE 8084
7900: GO 7902
7902: DISABLE
7903: LD_INT 0
7905: PPUSH
7906: PPUSH
// begin enable ;
7907: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7908: LD_ADDR_VAR 0 2
7912: PUSH
7913: LD_INT 3
7915: PPUSH
7916: CALL 107812 0 1
7920: ST_TO_ADDR
// for i in tmp do
7921: LD_ADDR_VAR 0 1
7925: PUSH
7926: LD_VAR 0 2
7930: PUSH
7931: FOR_IN
7932: IFFALSE 8082
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7934: LD_VAR 0 1
7938: PPUSH
7939: LD_INT 9
7941: PPUSH
7942: CALL_OW 308
7946: PUSH
7947: LD_VAR 0 1
7951: PPUSH
7952: CALL_OW 110
7956: PUSH
7957: LD_INT 2
7959: EQUAL
7960: NOT
7961: AND
7962: IFFALSE 7976
// SetTag ( i , 2 ) ;
7964: LD_VAR 0 1
7968: PPUSH
7969: LD_INT 2
7971: PPUSH
7972: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7976: LD_INT 81
7978: PUSH
7979: LD_INT 3
7981: PUSH
7982: EMPTY
7983: LIST
7984: LIST
7985: PUSH
7986: LD_INT 91
7988: PUSH
7989: LD_VAR 0 1
7993: PUSH
7994: LD_INT 12
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: LIST
8001: PUSH
8002: EMPTY
8003: LIST
8004: LIST
8005: PPUSH
8006: CALL_OW 69
8010: NOT
8011: PUSH
8012: LD_VAR 0 1
8016: PPUSH
8017: CALL_OW 110
8021: PUSH
8022: LD_INT 2
8024: EQUAL
8025: NOT
8026: AND
8027: IFFALSE 8046
// ComAgressiveMove ( i , 64 , 93 ) else
8029: LD_VAR 0 1
8033: PPUSH
8034: LD_INT 64
8036: PPUSH
8037: LD_INT 93
8039: PPUSH
8040: CALL_OW 114
8044: GO 8080
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8046: LD_VAR 0 1
8050: PPUSH
8051: LD_INT 81
8053: PUSH
8054: LD_INT 3
8056: PUSH
8057: EMPTY
8058: LIST
8059: LIST
8060: PPUSH
8061: CALL_OW 69
8065: PPUSH
8066: LD_VAR 0 1
8070: PPUSH
8071: CALL_OW 74
8075: PPUSH
8076: CALL_OW 115
// end ;
8080: GO 7931
8082: POP
8083: POP
// end ;
8084: PPOPN 2
8086: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8087: LD_INT 0
8089: PPUSH
8090: PPUSH
8091: PPUSH
// result := [ ] ;
8092: LD_ADDR_VAR 0 2
8096: PUSH
8097: EMPTY
8098: ST_TO_ADDR
// uc_side := 6 ;
8099: LD_ADDR_OWVAR 20
8103: PUSH
8104: LD_INT 6
8106: ST_TO_ADDR
// uc_nation := 3 ;
8107: LD_ADDR_OWVAR 21
8111: PUSH
8112: LD_INT 3
8114: ST_TO_ADDR
// case strength of 1 :
8115: LD_VAR 0 1
8119: PUSH
8120: LD_INT 1
8122: DOUBLE
8123: EQUAL
8124: IFTRUE 8128
8126: GO 8266
8128: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8129: LD_ADDR_VAR 0 3
8133: PUSH
8134: DOUBLE
8135: LD_INT 1
8137: DEC
8138: ST_TO_ADDR
8139: LD_INT 4
8141: PUSH
8142: LD_INT 5
8144: PUSH
8145: LD_INT 6
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: LIST
8152: PUSH
8153: LD_OWVAR 67
8157: ARRAY
8158: PUSH
8159: FOR_TO
8160: IFFALSE 8262
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8162: LD_INT 22
8164: PUSH
8165: LD_INT 24
8167: PUSH
8168: EMPTY
8169: LIST
8170: LIST
8171: PUSH
8172: LD_VAR 0 3
8176: PUSH
8177: LD_INT 2
8179: MOD
8180: PUSH
8181: LD_INT 1
8183: PLUS
8184: ARRAY
8185: PPUSH
8186: LD_INT 1
8188: PUSH
8189: LD_INT 3
8191: PUSH
8192: EMPTY
8193: LIST
8194: LIST
8195: PUSH
8196: LD_INT 1
8198: PPUSH
8199: LD_INT 2
8201: PPUSH
8202: CALL_OW 12
8206: ARRAY
8207: PPUSH
8208: LD_INT 3
8210: PPUSH
8211: LD_INT 43
8213: PUSH
8214: LD_INT 44
8216: PUSH
8217: LD_INT 45
8219: PUSH
8220: EMPTY
8221: LIST
8222: LIST
8223: LIST
8224: PUSH
8225: LD_INT 1
8227: PPUSH
8228: LD_INT 3
8230: PPUSH
8231: CALL_OW 12
8235: ARRAY
8236: PPUSH
8237: LD_INT 80
8239: PPUSH
8240: CALL 72009 0 5
// result := result union CreateVehicle ;
8244: LD_ADDR_VAR 0 2
8248: PUSH
8249: LD_VAR 0 2
8253: PUSH
8254: CALL_OW 45
8258: UNION
8259: ST_TO_ADDR
// end ;
8260: GO 8159
8262: POP
8263: POP
// end ; 2 :
8264: GO 9217
8266: LD_INT 2
8268: DOUBLE
8269: EQUAL
8270: IFTRUE 8274
8272: GO 8430
8274: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8275: LD_ADDR_VAR 0 3
8279: PUSH
8280: DOUBLE
8281: LD_INT 1
8283: DEC
8284: ST_TO_ADDR
8285: LD_INT 5
8287: PUSH
8288: LD_INT 6
8290: PUSH
8291: LD_INT 7
8293: PUSH
8294: EMPTY
8295: LIST
8296: LIST
8297: LIST
8298: PUSH
8299: LD_OWVAR 67
8303: ARRAY
8304: PUSH
8305: FOR_TO
8306: IFFALSE 8426
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8308: LD_INT 22
8310: PUSH
8311: LD_INT 24
8313: PUSH
8314: LD_INT 24
8316: PUSH
8317: EMPTY
8318: LIST
8319: LIST
8320: LIST
8321: PUSH
8322: LD_VAR 0 3
8326: PUSH
8327: LD_INT 3
8329: MOD
8330: PUSH
8331: LD_INT 1
8333: PLUS
8334: ARRAY
8335: PPUSH
8336: LD_INT 1
8338: PUSH
8339: LD_INT 3
8341: PUSH
8342: EMPTY
8343: LIST
8344: LIST
8345: PUSH
8346: LD_INT 1
8348: PPUSH
8349: LD_INT 2
8351: PPUSH
8352: CALL_OW 12
8356: ARRAY
8357: PPUSH
8358: LD_INT 3
8360: PPUSH
8361: LD_INT 43
8363: PUSH
8364: LD_INT 44
8366: PUSH
8367: LD_INT 45
8369: PUSH
8370: LD_INT 44
8372: PUSH
8373: LD_INT 46
8375: PUSH
8376: LD_INT 46
8378: PUSH
8379: EMPTY
8380: LIST
8381: LIST
8382: LIST
8383: LIST
8384: LIST
8385: LIST
8386: PUSH
8387: LD_VAR 0 3
8391: PUSH
8392: LD_INT 6
8394: MOD
8395: PUSH
8396: LD_INT 1
8398: PLUS
8399: ARRAY
8400: PPUSH
8401: LD_INT 80
8403: PPUSH
8404: CALL 72009 0 5
// result := result union CreateVehicle ;
8408: LD_ADDR_VAR 0 2
8412: PUSH
8413: LD_VAR 0 2
8417: PUSH
8418: CALL_OW 45
8422: UNION
8423: ST_TO_ADDR
// end ;
8424: GO 8305
8426: POP
8427: POP
// end ; 3 :
8428: GO 9217
8430: LD_INT 3
8432: DOUBLE
8433: EQUAL
8434: IFTRUE 8438
8436: GO 8594
8438: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8439: LD_ADDR_VAR 0 3
8443: PUSH
8444: DOUBLE
8445: LD_INT 1
8447: DEC
8448: ST_TO_ADDR
8449: LD_INT 5
8451: PUSH
8452: LD_INT 7
8454: PUSH
8455: LD_INT 8
8457: PUSH
8458: EMPTY
8459: LIST
8460: LIST
8461: LIST
8462: PUSH
8463: LD_OWVAR 67
8467: ARRAY
8468: PUSH
8469: FOR_TO
8470: IFFALSE 8590
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8472: LD_INT 22
8474: PUSH
8475: LD_INT 24
8477: PUSH
8478: LD_INT 24
8480: PUSH
8481: EMPTY
8482: LIST
8483: LIST
8484: LIST
8485: PUSH
8486: LD_VAR 0 3
8490: PUSH
8491: LD_INT 3
8493: MOD
8494: PUSH
8495: LD_INT 1
8497: PLUS
8498: ARRAY
8499: PPUSH
8500: LD_INT 1
8502: PUSH
8503: LD_INT 3
8505: PUSH
8506: EMPTY
8507: LIST
8508: LIST
8509: PUSH
8510: LD_INT 1
8512: PPUSH
8513: LD_INT 2
8515: PPUSH
8516: CALL_OW 12
8520: ARRAY
8521: PPUSH
8522: LD_INT 3
8524: PPUSH
8525: LD_INT 43
8527: PUSH
8528: LD_INT 47
8530: PUSH
8531: LD_INT 45
8533: PUSH
8534: LD_INT 45
8536: PUSH
8537: LD_INT 46
8539: PUSH
8540: LD_INT 46
8542: PUSH
8543: EMPTY
8544: LIST
8545: LIST
8546: LIST
8547: LIST
8548: LIST
8549: LIST
8550: PUSH
8551: LD_VAR 0 3
8555: PUSH
8556: LD_INT 6
8558: MOD
8559: PUSH
8560: LD_INT 1
8562: PLUS
8563: ARRAY
8564: PPUSH
8565: LD_INT 80
8567: PPUSH
8568: CALL 72009 0 5
// result := result union CreateVehicle ;
8572: LD_ADDR_VAR 0 2
8576: PUSH
8577: LD_VAR 0 2
8581: PUSH
8582: CALL_OW 45
8586: UNION
8587: ST_TO_ADDR
// end ;
8588: GO 8469
8590: POP
8591: POP
// end ; 4 :
8592: GO 9217
8594: LD_INT 4
8596: DOUBLE
8597: EQUAL
8598: IFTRUE 8602
8600: GO 9216
8602: POP
// begin uc_nation := 3 ;
8603: LD_ADDR_OWVAR 21
8607: PUSH
8608: LD_INT 3
8610: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8611: LD_ADDR_VAR 0 3
8615: PUSH
8616: DOUBLE
8617: LD_INT 1
8619: DEC
8620: ST_TO_ADDR
8621: LD_INT 6
8623: PUSH
8624: LD_INT 8
8626: PUSH
8627: LD_INT 9
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: LIST
8634: PUSH
8635: LD_OWVAR 67
8639: ARRAY
8640: PUSH
8641: FOR_TO
8642: IFFALSE 8762
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8644: LD_INT 22
8646: PUSH
8647: LD_INT 24
8649: PUSH
8650: LD_INT 24
8652: PUSH
8653: EMPTY
8654: LIST
8655: LIST
8656: LIST
8657: PUSH
8658: LD_VAR 0 3
8662: PUSH
8663: LD_INT 3
8665: MOD
8666: PUSH
8667: LD_INT 1
8669: PLUS
8670: ARRAY
8671: PPUSH
8672: LD_INT 1
8674: PUSH
8675: LD_INT 3
8677: PUSH
8678: EMPTY
8679: LIST
8680: LIST
8681: PUSH
8682: LD_INT 1
8684: PPUSH
8685: LD_INT 2
8687: PPUSH
8688: CALL_OW 12
8692: ARRAY
8693: PPUSH
8694: LD_INT 3
8696: PPUSH
8697: LD_INT 45
8699: PUSH
8700: LD_INT 47
8702: PUSH
8703: LD_INT 47
8705: PUSH
8706: LD_INT 45
8708: PUSH
8709: LD_INT 46
8711: PUSH
8712: LD_INT 46
8714: PUSH
8715: EMPTY
8716: LIST
8717: LIST
8718: LIST
8719: LIST
8720: LIST
8721: LIST
8722: PUSH
8723: LD_VAR 0 3
8727: PUSH
8728: LD_INT 6
8730: MOD
8731: PUSH
8732: LD_INT 1
8734: PLUS
8735: ARRAY
8736: PPUSH
8737: LD_INT 80
8739: PPUSH
8740: CALL 72009 0 5
// result := result union CreateVehicle ;
8744: LD_ADDR_VAR 0 2
8748: PUSH
8749: LD_VAR 0 2
8753: PUSH
8754: CALL_OW 45
8758: UNION
8759: ST_TO_ADDR
// end ;
8760: GO 8641
8762: POP
8763: POP
// if not KappaStatus then
8764: LD_EXP 2
8768: NOT
8769: IFFALSE 9004
// begin uc_nation := 1 ;
8771: LD_ADDR_OWVAR 21
8775: PUSH
8776: LD_INT 1
8778: ST_TO_ADDR
// for i = 1 to 3 do
8779: LD_ADDR_VAR 0 3
8783: PUSH
8784: DOUBLE
8785: LD_INT 1
8787: DEC
8788: ST_TO_ADDR
8789: LD_INT 3
8791: PUSH
8792: FOR_TO
8793: IFFALSE 8929
// begin j := rand ( 0 , 1 ) ;
8795: LD_ADDR_VAR 0 4
8799: PUSH
8800: LD_INT 0
8802: PPUSH
8803: LD_INT 1
8805: PPUSH
8806: CALL_OW 12
8810: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8811: LD_INT 3
8813: PUSH
8814: LD_INT 5
8816: PUSH
8817: LD_INT 5
8819: PUSH
8820: LD_INT 4
8822: PUSH
8823: EMPTY
8824: LIST
8825: LIST
8826: LIST
8827: LIST
8828: PUSH
8829: LD_VAR 0 4
8833: PUSH
8834: LD_INT 1
8836: PPUSH
8837: LD_INT 3
8839: PPUSH
8840: CALL_OW 12
8844: PLUS
8845: ARRAY
8846: PPUSH
8847: LD_INT 1
8849: PUSH
8850: LD_INT 3
8852: PUSH
8853: EMPTY
8854: LIST
8855: LIST
8856: PUSH
8857: LD_INT 1
8859: PPUSH
8860: LD_INT 2
8862: PPUSH
8863: CALL_OW 12
8867: ARRAY
8868: PPUSH
8869: LD_INT 3
8871: PPUSH
8872: LD_INT 9
8874: PUSH
8875: LD_INT 7
8877: PUSH
8878: LD_INT 6
8880: PUSH
8881: EMPTY
8882: LIST
8883: LIST
8884: LIST
8885: PUSH
8886: LD_VAR 0 4
8890: PUSH
8891: LD_INT 1
8893: PPUSH
8894: LD_INT 2
8896: PPUSH
8897: CALL_OW 12
8901: PLUS
8902: ARRAY
8903: PPUSH
8904: LD_INT 85
8906: PPUSH
8907: CALL 72009 0 5
// result := result union CreateVehicle ;
8911: LD_ADDR_VAR 0 2
8915: PUSH
8916: LD_VAR 0 2
8920: PUSH
8921: CALL_OW 45
8925: UNION
8926: ST_TO_ADDR
// end ;
8927: GO 8792
8929: POP
8930: POP
// if vsevolodFirstAttack then
8931: LD_EXP 24
8935: IFFALSE 9002
// begin vsevolodFirstAttack := false ;
8937: LD_ADDR_EXP 24
8941: PUSH
8942: LD_INT 0
8944: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8945: LD_INT 5
8947: PPUSH
8948: LD_INT 3
8950: PPUSH
8951: LD_INT 1
8953: PPUSH
8954: LD_INT 6
8956: PPUSH
8957: LD_INT 100
8959: PPUSH
8960: CALL 72009 0 5
// sewiVeh := CreateVehicle ;
8964: LD_ADDR_EXP 71
8968: PUSH
8969: CALL_OW 45
8973: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8974: LD_EXP 71
8978: PPUSH
8979: LD_INT 1
8981: PPUSH
8982: CALL_OW 242
// result := result union sewiVeh ;
8986: LD_ADDR_VAR 0 2
8990: PUSH
8991: LD_VAR 0 2
8995: PUSH
8996: LD_EXP 71
9000: UNION
9001: ST_TO_ADDR
// end ; end else
9002: GO 9214
// if vsevolodFirstAttack then
9004: LD_EXP 24
9008: IFFALSE 9214
// begin vsevolodFirstAttack := false ;
9010: LD_ADDR_EXP 24
9014: PUSH
9015: LD_INT 0
9017: ST_TO_ADDR
// uc_nation := 3 ;
9018: LD_ADDR_OWVAR 21
9022: PUSH
9023: LD_INT 3
9025: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9026: LD_ADDR_VAR 0 3
9030: PUSH
9031: DOUBLE
9032: LD_INT 1
9034: DEC
9035: ST_TO_ADDR
9036: LD_INT 2
9038: PUSH
9039: LD_OWVAR 67
9043: PLUS
9044: PUSH
9045: FOR_TO
9046: IFFALSE 9154
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9048: LD_INT 22
9050: PUSH
9051: LD_INT 24
9053: PUSH
9054: LD_INT 24
9056: PUSH
9057: EMPTY
9058: LIST
9059: LIST
9060: LIST
9061: PUSH
9062: LD_VAR 0 3
9066: PUSH
9067: LD_INT 3
9069: MOD
9070: PUSH
9071: LD_INT 1
9073: PLUS
9074: ARRAY
9075: PPUSH
9076: LD_INT 1
9078: PUSH
9079: LD_INT 3
9081: PUSH
9082: EMPTY
9083: LIST
9084: LIST
9085: PUSH
9086: LD_INT 1
9088: PPUSH
9089: LD_INT 2
9091: PPUSH
9092: CALL_OW 12
9096: ARRAY
9097: PPUSH
9098: LD_INT 1
9100: PPUSH
9101: LD_INT 45
9103: PUSH
9104: LD_INT 47
9106: PUSH
9107: LD_INT 47
9109: PUSH
9110: EMPTY
9111: LIST
9112: LIST
9113: LIST
9114: PUSH
9115: LD_VAR 0 3
9119: PUSH
9120: LD_INT 3
9122: MOD
9123: PUSH
9124: LD_INT 1
9126: PLUS
9127: ARRAY
9128: PPUSH
9129: LD_INT 80
9131: PPUSH
9132: CALL 72009 0 5
// result := result union CreateVehicle ;
9136: LD_ADDR_VAR 0 2
9140: PUSH
9141: LD_VAR 0 2
9145: PUSH
9146: CALL_OW 45
9150: UNION
9151: ST_TO_ADDR
// end ;
9152: GO 9045
9154: POP
9155: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9156: LD_INT 24
9158: PPUSH
9159: LD_INT 3
9161: PPUSH
9162: LD_INT 1
9164: PPUSH
9165: LD_INT 47
9167: PPUSH
9168: LD_INT 100
9170: PPUSH
9171: CALL 72009 0 5
// sewiVeh := CreateVehicle ;
9175: LD_ADDR_EXP 71
9179: PUSH
9180: CALL_OW 45
9184: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9185: LD_EXP 71
9189: PPUSH
9190: LD_INT 6
9192: NEG
9193: PPUSH
9194: CALL_OW 242
// result := result union sewiVeh ;
9198: LD_ADDR_VAR 0 2
9202: PUSH
9203: LD_VAR 0 2
9207: PUSH
9208: LD_EXP 71
9212: UNION
9213: ST_TO_ADDR
// end ; end ; end ;
9214: GO 9217
9216: POP
// end ;
9217: LD_VAR 0 2
9221: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9222: LD_EXP 16
9226: IFFALSE 10067
9228: GO 9230
9230: DISABLE
9231: LD_INT 0
9233: PPUSH
9234: PPUSH
9235: PPUSH
9236: PPUSH
9237: PPUSH
9238: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9239: LD_ADDR_VAR 0 4
9243: PUSH
9244: LD_INT 11
9246: PUSH
9247: LD_INT 12
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 ] [ Difficulty ] ;
9254: LD_ADDR_VAR 0 3
9258: PUSH
9259: LD_INT 11550
9261: PUSH
9262: LD_INT 10150
9264: PUSH
9265: LD_INT 9800
9267: PUSH
9268: EMPTY
9269: LIST
9270: LIST
9271: LIST
9272: PUSH
9273: LD_OWVAR 67
9277: ARRAY
9278: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9279: LD_ADDR_VAR 0 6
9283: PUSH
9284: LD_INT 70
9286: PUSH
9287: LD_INT 118
9289: PUSH
9290: EMPTY
9291: LIST
9292: LIST
9293: PUSH
9294: LD_INT 78
9296: PUSH
9297: LD_INT 31
9299: PUSH
9300: EMPTY
9301: LIST
9302: LIST
9303: PUSH
9304: EMPTY
9305: LIST
9306: LIST
9307: ST_TO_ADDR
// repeat if missionStage = 2 then
9308: LD_EXP 15
9312: PUSH
9313: LD_INT 2
9315: EQUAL
9316: IFFALSE 9327
// wait ( 1 1$30 ) else
9318: LD_INT 3150
9320: PPUSH
9321: CALL_OW 67
9325: GO 9336
// wait ( time ) ;
9327: LD_VAR 0 3
9331: PPUSH
9332: CALL_OW 67
// if missionStage = 6 then
9336: LD_EXP 15
9340: PUSH
9341: LD_INT 6
9343: EQUAL
9344: IFFALSE 9372
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9346: LD_INT 51
9348: PPUSH
9349: LD_INT 6
9351: PPUSH
9352: LD_INT 2
9354: PPUSH
9355: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9359: LD_INT 57
9361: PPUSH
9362: LD_INT 6
9364: PPUSH
9365: LD_INT 2
9367: PPUSH
9368: CALL_OW 322
// end ; if missionStage = 8 then
9372: LD_EXP 15
9376: PUSH
9377: LD_INT 8
9379: EQUAL
9380: IFFALSE 9408
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9382: LD_INT 52
9384: PPUSH
9385: LD_INT 6
9387: PPUSH
9388: LD_INT 2
9390: PPUSH
9391: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9395: LD_INT 58
9397: PPUSH
9398: LD_INT 6
9400: PPUSH
9401: LD_INT 2
9403: PPUSH
9404: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9408: LD_EXP 15
9412: PUSH
9413: LD_INT 10
9415: EQUAL
9416: PUSH
9417: LD_OWVAR 67
9421: PUSH
9422: LD_INT 1
9424: GREATER
9425: AND
9426: IFFALSE 9454
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9428: LD_INT 53
9430: PPUSH
9431: LD_INT 6
9433: PPUSH
9434: LD_INT 2
9436: PPUSH
9437: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9441: LD_INT 59
9443: PPUSH
9444: LD_INT 6
9446: PPUSH
9447: LD_INT 2
9449: PPUSH
9450: CALL_OW 322
// end ; if activeAttacks then
9454: LD_EXP 16
9458: IFFALSE 10061
// begin if missionStage = 2 then
9460: LD_EXP 15
9464: PUSH
9465: LD_INT 2
9467: EQUAL
9468: IFFALSE 9478
// strength := 1 ;
9470: LD_ADDR_VAR 0 5
9474: PUSH
9475: LD_INT 1
9477: ST_TO_ADDR
// if missionStage > 2 then
9478: LD_EXP 15
9482: PUSH
9483: LD_INT 2
9485: GREATER
9486: IFFALSE 9496
// strength := 2 ;
9488: LD_ADDR_VAR 0 5
9492: PUSH
9493: LD_INT 2
9495: ST_TO_ADDR
// if missionStage > 6 then
9496: LD_EXP 15
9500: PUSH
9501: LD_INT 6
9503: GREATER
9504: IFFALSE 9514
// strength := 3 ;
9506: LD_ADDR_VAR 0 5
9510: PUSH
9511: LD_INT 3
9513: ST_TO_ADDR
// if missionStage > 10 then
9514: LD_EXP 15
9518: PUSH
9519: LD_INT 10
9521: GREATER
9522: IFFALSE 9532
// strength := 4 ;
9524: LD_ADDR_VAR 0 5
9528: PUSH
9529: LD_INT 4
9531: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9532: LD_ADDR_VAR 0 2
9536: PUSH
9537: LD_VAR 0 5
9541: PPUSH
9542: CALL 8087 0 1
9546: ST_TO_ADDR
// for i in tmp do
9547: LD_ADDR_VAR 0 1
9551: PUSH
9552: LD_VAR 0 2
9556: PUSH
9557: FOR_IN
9558: IFFALSE 9741
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9560: LD_VAR 0 1
9564: PPUSH
9565: LD_VAR 0 4
9569: PUSH
9570: LD_INT 1
9572: PPUSH
9573: LD_INT 2
9575: PPUSH
9576: CALL_OW 12
9580: ARRAY
9581: PPUSH
9582: LD_INT 0
9584: PPUSH
9585: CALL_OW 49
// if i = sewiVeh then
9589: LD_VAR 0 1
9593: PUSH
9594: LD_EXP 71
9598: EQUAL
9599: IFFALSE 9636
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9601: LD_ADDR_EXP 70
9605: PUSH
9606: LD_STRING Vsevolod
9608: PPUSH
9609: LD_INT 0
9611: PPUSH
9612: LD_STRING 
9614: PPUSH
9615: CALL 64894 0 3
9619: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9620: LD_EXP 70
9624: PPUSH
9625: LD_VAR 0 1
9629: PPUSH
9630: CALL_OW 52
// end else
9634: GO 9717
// if GetControl ( i ) = control_manual then
9636: LD_VAR 0 1
9640: PPUSH
9641: CALL_OW 263
9645: PUSH
9646: LD_INT 1
9648: EQUAL
9649: IFFALSE 9717
// begin uc_side := 6 ;
9651: LD_ADDR_OWVAR 20
9655: PUSH
9656: LD_INT 6
9658: ST_TO_ADDR
// uc_nation := 3 ;
9659: LD_ADDR_OWVAR 21
9663: PUSH
9664: LD_INT 3
9666: ST_TO_ADDR
// hc_gallery :=  ;
9667: LD_ADDR_OWVAR 33
9671: PUSH
9672: LD_STRING 
9674: ST_TO_ADDR
// hc_name :=  ;
9675: LD_ADDR_OWVAR 26
9679: PUSH
9680: LD_STRING 
9682: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9683: LD_INT 0
9685: PPUSH
9686: LD_INT 3
9688: PPUSH
9689: LD_INT 10
9691: PPUSH
9692: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9696: CALL_OW 44
9700: PPUSH
9701: LD_VAR 0 1
9705: PPUSH
9706: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9710: LD_INT 10
9712: PPUSH
9713: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9717: LD_VAR 0 1
9721: PPUSH
9722: LD_INT 111
9724: PPUSH
9725: LD_INT 197
9727: PPUSH
9728: CALL_OW 111
// wait ( 0 0$2 ) ;
9732: LD_INT 70
9734: PPUSH
9735: CALL_OW 67
// end ;
9739: GO 9557
9741: POP
9742: POP
// repeat wait ( 0 0$1 ) ;
9743: LD_INT 35
9745: PPUSH
9746: CALL_OW 67
// for i in tmp do
9750: LD_ADDR_VAR 0 1
9754: PUSH
9755: LD_VAR 0 2
9759: PUSH
9760: FOR_IN
9761: IFFALSE 10042
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9763: LD_INT 81
9765: PUSH
9766: LD_INT 6
9768: PUSH
9769: EMPTY
9770: LIST
9771: LIST
9772: PUSH
9773: LD_INT 91
9775: PUSH
9776: LD_VAR 0 1
9780: PUSH
9781: LD_INT 12
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: LIST
9788: PUSH
9789: EMPTY
9790: LIST
9791: LIST
9792: PPUSH
9793: CALL_OW 69
9797: IFFALSE 9855
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9799: LD_VAR 0 1
9803: PPUSH
9804: LD_INT 81
9806: PUSH
9807: LD_INT 6
9809: PUSH
9810: EMPTY
9811: LIST
9812: LIST
9813: PUSH
9814: LD_INT 91
9816: PUSH
9817: LD_VAR 0 1
9821: PUSH
9822: LD_INT 12
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: LIST
9829: PUSH
9830: EMPTY
9831: LIST
9832: LIST
9833: PPUSH
9834: CALL_OW 69
9838: PPUSH
9839: LD_VAR 0 1
9843: PPUSH
9844: CALL_OW 74
9848: PPUSH
9849: CALL_OW 115
9853: GO 10040
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9855: LD_INT 9
9857: PPUSH
9858: LD_INT 81
9860: PUSH
9861: LD_INT 6
9863: PUSH
9864: EMPTY
9865: LIST
9866: LIST
9867: PPUSH
9868: CALL_OW 70
9872: IFFALSE 10006
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9874: LD_VAR 0 1
9878: PPUSH
9879: LD_VAR 0 6
9883: PUSH
9884: LD_INT 1
9886: ARRAY
9887: PUSH
9888: LD_INT 1
9890: ARRAY
9891: PPUSH
9892: LD_VAR 0 6
9896: PUSH
9897: LD_INT 1
9899: ARRAY
9900: PUSH
9901: LD_INT 2
9903: ARRAY
9904: PPUSH
9905: CALL_OW 297
9909: PUSH
9910: LD_INT 10
9912: GREATER
9913: PUSH
9914: LD_VAR 0 1
9918: PPUSH
9919: LD_INT 9
9921: PPUSH
9922: CALL_OW 308
9926: NOT
9927: AND
9928: IFFALSE 9967
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9930: LD_VAR 0 1
9934: PPUSH
9935: LD_VAR 0 6
9939: PUSH
9940: LD_INT 1
9942: ARRAY
9943: PUSH
9944: LD_INT 1
9946: ARRAY
9947: PPUSH
9948: LD_VAR 0 6
9952: PUSH
9953: LD_INT 1
9955: ARRAY
9956: PUSH
9957: LD_INT 2
9959: ARRAY
9960: PPUSH
9961: CALL_OW 114
9965: GO 10004
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9967: LD_VAR 0 1
9971: PPUSH
9972: LD_INT 9
9974: PPUSH
9975: LD_INT 81
9977: PUSH
9978: LD_INT 6
9980: PUSH
9981: EMPTY
9982: LIST
9983: LIST
9984: PPUSH
9985: CALL_OW 70
9989: PPUSH
9990: LD_VAR 0 1
9994: PPUSH
9995: CALL_OW 74
9999: PPUSH
10000: CALL_OW 115
// end else
10004: GO 10040
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10006: LD_VAR 0 1
10010: PPUSH
10011: LD_INT 81
10013: PUSH
10014: LD_INT 6
10016: PUSH
10017: EMPTY
10018: LIST
10019: LIST
10020: PPUSH
10021: CALL_OW 69
10025: PPUSH
10026: LD_VAR 0 1
10030: PPUSH
10031: CALL_OW 74
10035: PPUSH
10036: CALL_OW 115
// end ;
10040: GO 9760
10042: POP
10043: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10044: LD_INT 22
10046: PUSH
10047: LD_INT 6
10049: PUSH
10050: EMPTY
10051: LIST
10052: LIST
10053: PPUSH
10054: CALL_OW 69
10058: NOT
10059: IFFALSE 9743
// end ; until russianDestroyed ;
10061: LD_EXP 21
10065: IFFALSE 9308
// end ;
10067: PPOPN 6
10069: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10070: LD_EXP 21
10074: NOT
10075: PUSH
10076: LD_EXP 15
10080: PUSH
10081: LD_INT 6
10083: GREATEREQUAL
10084: AND
10085: PUSH
10086: LD_INT 2
10088: PPUSH
10089: LD_INT 1
10091: PPUSH
10092: CALL 59968 0 2
10096: NOT
10097: AND
10098: IFFALSE 11054
10100: GO 10102
10102: DISABLE
10103: LD_INT 0
10105: PPUSH
10106: PPUSH
10107: PPUSH
10108: PPUSH
// begin enable ;
10109: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10110: LD_INT 22
10112: PUSH
10113: LD_INT 3
10115: PUSH
10116: EMPTY
10117: LIST
10118: LIST
10119: PUSH
10120: LD_INT 30
10122: PUSH
10123: LD_INT 3
10125: PUSH
10126: EMPTY
10127: LIST
10128: LIST
10129: PUSH
10130: EMPTY
10131: LIST
10132: LIST
10133: PPUSH
10134: CALL_OW 69
10138: NOT
10139: IFFALSE 10143
// exit ;
10141: GO 11054
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10143: LD_ADDR_VAR 0 4
10147: PUSH
10148: LD_INT 22
10150: PUSH
10151: LD_INT 3
10153: PUSH
10154: EMPTY
10155: LIST
10156: LIST
10157: PUSH
10158: LD_INT 30
10160: PUSH
10161: LD_INT 34
10163: PUSH
10164: EMPTY
10165: LIST
10166: LIST
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: PPUSH
10172: CALL_OW 69
10176: ST_TO_ADDR
// if Prob ( 40 ) then
10177: LD_INT 40
10179: PPUSH
10180: CALL_OW 13
10184: IFFALSE 10311
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10186: LD_INT 2
10188: PPUSH
10189: LD_INT 22
10191: PUSH
10192: LD_INT 3
10194: PUSH
10195: LD_INT 3
10197: PUSH
10198: LD_INT 49
10200: PUSH
10201: EMPTY
10202: LIST
10203: LIST
10204: LIST
10205: LIST
10206: PUSH
10207: LD_INT 22
10209: PUSH
10210: LD_INT 3
10212: PUSH
10213: LD_INT 3
10215: PUSH
10216: LD_INT 49
10218: PUSH
10219: EMPTY
10220: LIST
10221: LIST
10222: LIST
10223: LIST
10224: PUSH
10225: LD_INT 22
10227: PUSH
10228: LD_INT 3
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: LD_INT 49
10236: PUSH
10237: EMPTY
10238: LIST
10239: LIST
10240: LIST
10241: LIST
10242: PUSH
10243: LD_INT 24
10245: PUSH
10246: LD_INT 3
10248: PUSH
10249: LD_INT 3
10251: PUSH
10252: LD_INT 46
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: LIST
10259: LIST
10260: PUSH
10261: LD_INT 24
10263: PUSH
10264: LD_INT 3
10266: PUSH
10267: LD_INT 3
10269: PUSH
10270: LD_INT 46
10272: PUSH
10273: EMPTY
10274: LIST
10275: LIST
10276: LIST
10277: LIST
10278: PUSH
10279: LD_INT 24
10281: PUSH
10282: LD_INT 3
10284: PUSH
10285: LD_INT 3
10287: PUSH
10288: LD_INT 46
10290: PUSH
10291: EMPTY
10292: LIST
10293: LIST
10294: LIST
10295: LIST
10296: PUSH
10297: EMPTY
10298: LIST
10299: LIST
10300: LIST
10301: LIST
10302: LIST
10303: LIST
10304: PPUSH
10305: CALL 58550 0 2
// end else
10309: GO 10434
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10311: LD_INT 2
10313: PPUSH
10314: LD_INT 24
10316: PUSH
10317: LD_INT 3
10319: PUSH
10320: LD_INT 3
10322: PUSH
10323: LD_INT 47
10325: PUSH
10326: EMPTY
10327: LIST
10328: LIST
10329: LIST
10330: LIST
10331: PUSH
10332: LD_INT 24
10334: PUSH
10335: LD_INT 3
10337: PUSH
10338: LD_INT 3
10340: PUSH
10341: LD_INT 47
10343: PUSH
10344: EMPTY
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: PUSH
10350: LD_INT 24
10352: PUSH
10353: LD_INT 3
10355: PUSH
10356: LD_INT 3
10358: PUSH
10359: LD_INT 47
10361: PUSH
10362: EMPTY
10363: LIST
10364: LIST
10365: LIST
10366: LIST
10367: PUSH
10368: LD_INT 24
10370: PUSH
10371: LD_INT 3
10373: PUSH
10374: LD_INT 3
10376: PUSH
10377: LD_INT 46
10379: PUSH
10380: EMPTY
10381: LIST
10382: LIST
10383: LIST
10384: LIST
10385: PUSH
10386: LD_INT 24
10388: PUSH
10389: LD_INT 3
10391: PUSH
10392: LD_INT 3
10394: PUSH
10395: LD_INT 46
10397: PUSH
10398: EMPTY
10399: LIST
10400: LIST
10401: LIST
10402: LIST
10403: PUSH
10404: LD_INT 24
10406: PUSH
10407: LD_INT 3
10409: PUSH
10410: LD_INT 3
10412: PUSH
10413: LD_INT 46
10415: PUSH
10416: EMPTY
10417: LIST
10418: LIST
10419: LIST
10420: LIST
10421: PUSH
10422: EMPTY
10423: LIST
10424: LIST
10425: LIST
10426: LIST
10427: LIST
10428: LIST
10429: PPUSH
10430: CALL 58550 0 2
// end ; if Difficulty > 1 then
10434: LD_OWVAR 67
10438: PUSH
10439: LD_INT 1
10441: GREATER
10442: IFFALSE 10472
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10444: LD_INT 2
10446: PPUSH
10447: LD_INT 24
10449: PUSH
10450: LD_INT 3
10452: PUSH
10453: LD_INT 3
10455: PUSH
10456: LD_INT 47
10458: PUSH
10459: EMPTY
10460: LIST
10461: LIST
10462: LIST
10463: LIST
10464: PUSH
10465: EMPTY
10466: LIST
10467: PPUSH
10468: CALL 58550 0 2
// repeat wait ( 0 0$1 ) ;
10472: LD_INT 35
10474: PPUSH
10475: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10479: LD_INT 2
10481: PPUSH
10482: LD_INT 1
10484: PPUSH
10485: CALL 59968 0 2
10489: PUSH
10490: LD_INT 6
10492: PUSH
10493: LD_INT 7
10495: PUSH
10496: LD_INT 7
10498: PUSH
10499: EMPTY
10500: LIST
10501: LIST
10502: LIST
10503: PUSH
10504: LD_OWVAR 67
10508: ARRAY
10509: GREATEREQUAL
10510: IFFALSE 10472
// wait ( 0 0$30 ) ;
10512: LD_INT 1050
10514: PPUSH
10515: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10519: LD_ADDR_VAR 0 2
10523: PUSH
10524: LD_INT 2
10526: PPUSH
10527: LD_INT 1
10529: PPUSH
10530: CALL 59968 0 2
10534: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10535: LD_ADDR_EXP 121
10539: PUSH
10540: LD_EXP 121
10544: PPUSH
10545: LD_INT 2
10547: PPUSH
10548: LD_EXP 121
10552: PUSH
10553: LD_INT 2
10555: ARRAY
10556: PUSH
10557: LD_VAR 0 2
10561: DIFF
10562: PPUSH
10563: CALL_OW 1
10567: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10568: LD_ADDR_VAR 0 3
10572: PUSH
10573: LD_INT 0
10575: PPUSH
10576: LD_INT 1
10578: PPUSH
10579: CALL_OW 12
10583: ST_TO_ADDR
// if target then
10584: LD_VAR 0 3
10588: IFFALSE 10716
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10590: LD_ADDR_VAR 0 2
10594: PUSH
10595: LD_VAR 0 2
10599: PPUSH
10600: LD_INT 24
10602: PUSH
10603: LD_INT 250
10605: PUSH
10606: EMPTY
10607: LIST
10608: LIST
10609: PPUSH
10610: CALL_OW 72
10614: ST_TO_ADDR
// for i in tmp do
10615: LD_ADDR_VAR 0 1
10619: PUSH
10620: LD_VAR 0 2
10624: PUSH
10625: FOR_IN
10626: IFFALSE 10666
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10628: LD_VAR 0 1
10632: PPUSH
10633: LD_INT 139
10635: PPUSH
10636: LD_INT 89
10638: PPUSH
10639: CALL_OW 297
10643: PUSH
10644: LD_INT 9
10646: GREATER
10647: IFFALSE 10664
// ComMoveXY ( i , 139 , 89 ) ;
10649: LD_VAR 0 1
10653: PPUSH
10654: LD_INT 139
10656: PPUSH
10657: LD_INT 89
10659: PPUSH
10660: CALL_OW 111
10664: GO 10625
10666: POP
10667: POP
// wait ( 0 0$1 ) ;
10668: LD_INT 35
10670: PPUSH
10671: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10675: LD_VAR 0 2
10679: PPUSH
10680: LD_INT 92
10682: PUSH
10683: LD_INT 139
10685: PUSH
10686: LD_INT 89
10688: PUSH
10689: LD_INT 9
10691: PUSH
10692: EMPTY
10693: LIST
10694: LIST
10695: LIST
10696: LIST
10697: PPUSH
10698: CALL_OW 72
10702: PUSH
10703: LD_VAR 0 2
10707: PUSH
10708: LD_INT 1
10710: MINUS
10711: GREATEREQUAL
10712: IFFALSE 10590
// end else
10714: GO 10858
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10716: LD_VAR 0 2
10720: PPUSH
10721: LD_VAR 0 4
10725: PUSH
10726: LD_INT 1
10728: ARRAY
10729: PPUSH
10730: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10734: LD_ADDR_VAR 0 2
10738: PUSH
10739: LD_VAR 0 2
10743: PPUSH
10744: LD_INT 24
10746: PUSH
10747: LD_INT 250
10749: PUSH
10750: EMPTY
10751: LIST
10752: LIST
10753: PPUSH
10754: CALL_OW 72
10758: ST_TO_ADDR
// for i in tmp do
10759: LD_ADDR_VAR 0 1
10763: PUSH
10764: LD_VAR 0 2
10768: PUSH
10769: FOR_IN
10770: IFFALSE 10810
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10772: LD_VAR 0 1
10776: PPUSH
10777: LD_INT 124
10779: PPUSH
10780: LD_INT 139
10782: PPUSH
10783: CALL_OW 297
10787: PUSH
10788: LD_INT 9
10790: GREATER
10791: IFFALSE 10808
// ComMoveXY ( i , 124 , 139 ) ;
10793: LD_VAR 0 1
10797: PPUSH
10798: LD_INT 124
10800: PPUSH
10801: LD_INT 139
10803: PPUSH
10804: CALL_OW 111
10808: GO 10769
10810: POP
10811: POP
// wait ( 0 0$1 ) ;
10812: LD_INT 35
10814: PPUSH
10815: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10819: LD_VAR 0 2
10823: PPUSH
10824: LD_INT 92
10826: PUSH
10827: LD_INT 124
10829: PUSH
10830: LD_INT 139
10832: PUSH
10833: LD_INT 9
10835: PUSH
10836: EMPTY
10837: LIST
10838: LIST
10839: LIST
10840: LIST
10841: PPUSH
10842: CALL_OW 72
10846: PUSH
10847: LD_VAR 0 2
10851: PUSH
10852: LD_INT 1
10854: MINUS
10855: GREATEREQUAL
10856: IFFALSE 10734
// end ; repeat wait ( 0 0$1 ) ;
10858: LD_INT 35
10860: PPUSH
10861: CALL_OW 67
// for i in tmp do
10865: LD_ADDR_VAR 0 1
10869: PUSH
10870: LD_VAR 0 2
10874: PUSH
10875: FOR_IN
10876: IFFALSE 11045
// begin if GetLives ( i ) > 251 then
10878: LD_VAR 0 1
10882: PPUSH
10883: CALL_OW 256
10887: PUSH
10888: LD_INT 251
10890: GREATER
10891: IFFALSE 11016
// begin if GetWeapon ( i ) = ru_time_lapser then
10893: LD_VAR 0 1
10897: PPUSH
10898: CALL_OW 264
10902: PUSH
10903: LD_INT 49
10905: EQUAL
10906: IFFALSE 10962
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10908: LD_VAR 0 1
10912: PPUSH
10913: LD_INT 2
10915: PUSH
10916: LD_INT 22
10918: PUSH
10919: LD_INT 1
10921: PUSH
10922: EMPTY
10923: LIST
10924: LIST
10925: PUSH
10926: LD_INT 22
10928: PUSH
10929: LD_INT 8
10931: PUSH
10932: EMPTY
10933: LIST
10934: LIST
10935: PUSH
10936: EMPTY
10937: LIST
10938: LIST
10939: LIST
10940: PPUSH
10941: CALL_OW 69
10945: PPUSH
10946: LD_VAR 0 1
10950: PPUSH
10951: CALL_OW 74
10955: PPUSH
10956: CALL_OW 112
10960: GO 11014
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10962: LD_VAR 0 1
10966: PPUSH
10967: LD_INT 2
10969: PUSH
10970: LD_INT 22
10972: PUSH
10973: LD_INT 1
10975: PUSH
10976: EMPTY
10977: LIST
10978: LIST
10979: PUSH
10980: LD_INT 22
10982: PUSH
10983: LD_INT 8
10985: PUSH
10986: EMPTY
10987: LIST
10988: LIST
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: LIST
10994: PPUSH
10995: CALL_OW 69
10999: PPUSH
11000: LD_VAR 0 1
11004: PPUSH
11005: CALL_OW 74
11009: PPUSH
11010: CALL_OW 115
// end else
11014: GO 11043
// if IsDead ( i ) then
11016: LD_VAR 0 1
11020: PPUSH
11021: CALL_OW 301
11025: IFFALSE 11043
// tmp := tmp diff i ;
11027: LD_ADDR_VAR 0 2
11031: PUSH
11032: LD_VAR 0 2
11036: PUSH
11037: LD_VAR 0 1
11041: DIFF
11042: ST_TO_ADDR
// end ;
11043: GO 10875
11045: POP
11046: POP
// until not tmp ;
11047: LD_VAR 0 2
11051: NOT
11052: IFFALSE 10858
// end ; end_of_file
11054: PPOPN 4
11056: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11057: LD_INT 0
11059: PPUSH
11060: PPUSH
11061: PPUSH
11062: PPUSH
11063: PPUSH
11064: PPUSH
// side := 7 ;
11065: LD_ADDR_VAR 0 5
11069: PUSH
11070: LD_INT 7
11072: ST_TO_ADDR
// uc_side := side ;
11073: LD_ADDR_OWVAR 20
11077: PUSH
11078: LD_VAR 0 5
11082: ST_TO_ADDR
// uc_nation := 1 ;
11083: LD_ADDR_OWVAR 21
11087: PUSH
11088: LD_INT 1
11090: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11091: LD_ADDR_VAR 0 2
11095: PUSH
11096: LD_INT 22
11098: PUSH
11099: LD_VAR 0 5
11103: PUSH
11104: EMPTY
11105: LIST
11106: LIST
11107: PUSH
11108: LD_INT 21
11110: PUSH
11111: LD_INT 3
11113: PUSH
11114: EMPTY
11115: LIST
11116: LIST
11117: PUSH
11118: EMPTY
11119: LIST
11120: LIST
11121: PPUSH
11122: CALL_OW 69
11126: PUSH
11127: FOR_IN
11128: IFFALSE 11144
// SetBLevel ( i , 10 ) ;
11130: LD_VAR 0 2
11134: PPUSH
11135: LD_INT 10
11137: PPUSH
11138: CALL_OW 241
11142: GO 11127
11144: POP
11145: POP
// base := GetBase ( al_depot ) ;
11146: LD_ADDR_VAR 0 4
11150: PUSH
11151: LD_INT 2
11153: PPUSH
11154: CALL_OW 274
11158: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11159: LD_ADDR_VAR 0 6
11163: PUSH
11164: LD_INT 22
11166: PUSH
11167: LD_VAR 0 5
11171: PUSH
11172: EMPTY
11173: LIST
11174: LIST
11175: PUSH
11176: LD_INT 30
11178: PUSH
11179: LD_INT 34
11181: PUSH
11182: EMPTY
11183: LIST
11184: LIST
11185: PUSH
11186: EMPTY
11187: LIST
11188: LIST
11189: PPUSH
11190: CALL_OW 69
11194: ST_TO_ADDR
// if teleport then
11195: LD_VAR 0 6
11199: IFFALSE 11220
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11201: LD_VAR 0 6
11205: PUSH
11206: LD_INT 1
11208: ARRAY
11209: PPUSH
11210: LD_INT 262
11212: PPUSH
11213: LD_INT 119
11215: PPUSH
11216: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11220: LD_VAR 0 4
11224: PPUSH
11225: LD_INT 1
11227: PPUSH
11228: LD_INT 19500
11230: PPUSH
11231: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11235: LD_VAR 0 4
11239: PPUSH
11240: LD_INT 2
11242: PPUSH
11243: LD_INT 200
11245: PPUSH
11246: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11250: LD_VAR 0 4
11254: PPUSH
11255: LD_INT 3
11257: PPUSH
11258: LD_INT 650
11260: PPUSH
11261: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11265: LD_ADDR_EXP 74
11269: PUSH
11270: LD_STRING Roth
11272: PPUSH
11273: CALL_OW 25
11277: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11278: LD_ADDR_EXP 75
11282: PUSH
11283: LD_STRING Simms
11285: PPUSH
11286: LD_EXP 1
11290: NOT
11291: PPUSH
11292: LD_STRING 10c_
11294: PPUSH
11295: CALL 64894 0 3
11299: ST_TO_ADDR
// if not Simms then
11300: LD_EXP 75
11304: NOT
11305: IFFALSE 11335
// begin uc_nation := 1 ;
11307: LD_ADDR_OWVAR 21
11311: PUSH
11312: LD_INT 1
11314: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11315: LD_INT 2
11317: PPUSH
11318: LD_INT 10
11320: PPUSH
11321: CALL_OW 384
// Simms := CreateHuman ;
11325: LD_ADDR_EXP 75
11329: PUSH
11330: CALL_OW 44
11334: ST_TO_ADDR
// end ; uc_nation := 3 ;
11335: LD_ADDR_OWVAR 21
11339: PUSH
11340: LD_INT 3
11342: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11343: LD_ADDR_EXP 76
11347: PUSH
11348: LD_STRING Kirilenkova
11350: PPUSH
11351: CALL_OW 25
11355: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11356: LD_ADDR_EXP 90
11360: PUSH
11361: LD_STRING Oblukov
11363: PPUSH
11364: CALL_OW 25
11368: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11369: LD_ADDR_EXP 77
11373: PUSH
11374: LD_STRING Dolgov
11376: PPUSH
11377: CALL_OW 25
11381: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11382: LD_ADDR_EXP 78
11386: PUSH
11387: LD_STRING Petrosyan
11389: PPUSH
11390: CALL_OW 25
11394: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11395: LD_ADDR_EXP 89
11399: PUSH
11400: LD_STRING Scholtze
11402: PPUSH
11403: CALL_OW 25
11407: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11408: LD_ADDR_EXP 88
11412: PUSH
11413: LD_STRING Kapitsova
11415: PPUSH
11416: CALL_OW 25
11420: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11421: LD_ADDR_EXP 79
11425: PUSH
11426: LD_STRING Petrovova
11428: PPUSH
11429: CALL_OW 25
11433: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11434: LD_ADDR_EXP 80
11438: PUSH
11439: LD_STRING Kuzmov
11441: PPUSH
11442: CALL_OW 25
11446: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11447: LD_ADDR_EXP 87
11451: PUSH
11452: LD_STRING Karamazov
11454: PPUSH
11455: CALL_OW 25
11459: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11460: LD_STRING 13_Lipshchin_1
11462: PPUSH
11463: LD_INT 0
11465: PPUSH
11466: CALL_OW 30
11470: IFFALSE 11485
// Lipshchin := NewCharacter ( Lipshchin ) ;
11472: LD_ADDR_EXP 81
11476: PUSH
11477: LD_STRING Lipshchin
11479: PPUSH
11480: CALL_OW 25
11484: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11485: LD_STRING 13_Titov_1
11487: PPUSH
11488: LD_INT 0
11490: PPUSH
11491: CALL_OW 30
11495: IFFALSE 11510
// Titov := NewCharacter ( Titov ) ;
11497: LD_ADDR_EXP 83
11501: PUSH
11502: LD_STRING Titov
11504: PPUSH
11505: CALL_OW 25
11509: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11510: LD_STRING 13_Gnyevko_1
11512: PPUSH
11513: LD_INT 0
11515: PPUSH
11516: CALL_OW 30
11520: IFFALSE 11535
// Gnyevko := NewCharacter ( Gnyevko ) ;
11522: LD_ADDR_EXP 82
11526: PUSH
11527: LD_STRING Gnyevko
11529: PPUSH
11530: CALL_OW 25
11534: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11535: LD_STRING 13_Xavier_1
11537: PPUSH
11538: LD_INT 0
11540: PPUSH
11541: CALL_OW 30
11545: IFFALSE 11560
// Xavier := NewCharacter ( Xavier2 ) ;
11547: LD_ADDR_EXP 84
11551: PUSH
11552: LD_STRING Xavier2
11554: PPUSH
11555: CALL_OW 25
11559: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11560: LD_STRING 13_Belkov_1
11562: PPUSH
11563: LD_INT 0
11565: PPUSH
11566: CALL_OW 30
11570: IFFALSE 11585
// Belkov := NewCharacter ( Belkov ) ;
11572: LD_ADDR_EXP 85
11576: PUSH
11577: LD_STRING Belkov
11579: PPUSH
11580: CALL_OW 25
11584: ST_TO_ADDR
// if not BurlakStatus then
11585: LD_EXP 9
11589: NOT
11590: IFFALSE 11605
// Burlak = NewCharacter ( Burlak ) ;
11592: LD_ADDR_EXP 86
11596: PUSH
11597: LD_STRING Burlak
11599: PPUSH
11600: CALL_OW 25
11604: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11605: LD_ADDR_VAR 0 3
11609: PUSH
11610: LD_EXP 74
11614: PUSH
11615: LD_EXP 76
11619: PUSH
11620: LD_EXP 90
11624: PUSH
11625: LD_EXP 77
11629: PUSH
11630: LD_EXP 78
11634: PUSH
11635: LD_EXP 89
11639: PUSH
11640: LD_EXP 88
11644: PUSH
11645: LD_EXP 79
11649: PUSH
11650: LD_EXP 80
11654: PUSH
11655: LD_EXP 87
11659: PUSH
11660: EMPTY
11661: LIST
11662: LIST
11663: LIST
11664: LIST
11665: LIST
11666: LIST
11667: LIST
11668: LIST
11669: LIST
11670: LIST
11671: ST_TO_ADDR
// if Simms then
11672: LD_EXP 75
11676: IFFALSE 11694
// tmp := tmp ^ Simms ;
11678: LD_ADDR_VAR 0 3
11682: PUSH
11683: LD_VAR 0 3
11687: PUSH
11688: LD_EXP 75
11692: ADD
11693: ST_TO_ADDR
// if Titov then
11694: LD_EXP 83
11698: IFFALSE 11716
// tmp := tmp ^ Titov ;
11700: LD_ADDR_VAR 0 3
11704: PUSH
11705: LD_VAR 0 3
11709: PUSH
11710: LD_EXP 83
11714: ADD
11715: ST_TO_ADDR
// if Lipshchin then
11716: LD_EXP 81
11720: IFFALSE 11738
// tmp := tmp ^ Lipshchin ;
11722: LD_ADDR_VAR 0 3
11726: PUSH
11727: LD_VAR 0 3
11731: PUSH
11732: LD_EXP 81
11736: ADD
11737: ST_TO_ADDR
// if Gnyevko then
11738: LD_EXP 82
11742: IFFALSE 11760
// tmp := tmp ^ Gnyevko ;
11744: LD_ADDR_VAR 0 3
11748: PUSH
11749: LD_VAR 0 3
11753: PUSH
11754: LD_EXP 82
11758: ADD
11759: ST_TO_ADDR
// if Xavier then
11760: LD_EXP 84
11764: IFFALSE 11782
// tmp := tmp ^ Xavier ;
11766: LD_ADDR_VAR 0 3
11770: PUSH
11771: LD_VAR 0 3
11775: PUSH
11776: LD_EXP 84
11780: ADD
11781: ST_TO_ADDR
// if Belkov then
11782: LD_EXP 85
11786: IFFALSE 11804
// tmp := tmp ^ Belkov ;
11788: LD_ADDR_VAR 0 3
11792: PUSH
11793: LD_VAR 0 3
11797: PUSH
11798: LD_EXP 85
11802: ADD
11803: ST_TO_ADDR
// if Burlak then
11804: LD_EXP 86
11808: IFFALSE 11826
// tmp := tmp ^ Burlak ;
11810: LD_ADDR_VAR 0 3
11814: PUSH
11815: LD_VAR 0 3
11819: PUSH
11820: LD_EXP 86
11824: ADD
11825: ST_TO_ADDR
// for i = 1 to 11 do
11826: LD_ADDR_VAR 0 2
11830: PUSH
11831: DOUBLE
11832: LD_INT 1
11834: DEC
11835: ST_TO_ADDR
11836: LD_INT 11
11838: PUSH
11839: FOR_TO
11840: IFFALSE 11906
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11842: LD_ADDR_OWVAR 21
11846: PUSH
11847: LD_INT 1
11849: PUSH
11850: LD_INT 3
11852: PUSH
11853: EMPTY
11854: LIST
11855: LIST
11856: PUSH
11857: LD_INT 1
11859: PPUSH
11860: LD_INT 2
11862: PPUSH
11863: CALL_OW 12
11867: ARRAY
11868: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11869: LD_INT 0
11871: PPUSH
11872: LD_VAR 0 2
11876: PUSH
11877: LD_INT 2
11879: DIV
11880: PPUSH
11881: LD_INT 10
11883: PPUSH
11884: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11888: LD_ADDR_VAR 0 3
11892: PUSH
11893: LD_VAR 0 3
11897: PUSH
11898: CALL_OW 44
11902: ADD
11903: ST_TO_ADDR
// end ;
11904: GO 11839
11906: POP
11907: POP
// for i in tmp do
11908: LD_ADDR_VAR 0 2
11912: PUSH
11913: LD_VAR 0 3
11917: PUSH
11918: FOR_IN
11919: IFFALSE 11944
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11921: LD_VAR 0 2
11925: PPUSH
11926: LD_INT 260
11928: PPUSH
11929: LD_INT 235
11931: PPUSH
11932: LD_INT 8
11934: PPUSH
11935: LD_INT 0
11937: PPUSH
11938: CALL_OW 50
11942: GO 11918
11944: POP
11945: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11946: LD_ADDR_EXP 102
11950: PUSH
11951: LD_EXP 102
11955: PPUSH
11956: LD_INT 1
11958: PPUSH
11959: LD_INT 22
11961: PUSH
11962: LD_VAR 0 5
11966: PUSH
11967: EMPTY
11968: LIST
11969: LIST
11970: PUSH
11971: LD_INT 3
11973: PUSH
11974: LD_INT 21
11976: PUSH
11977: LD_INT 2
11979: PUSH
11980: EMPTY
11981: LIST
11982: LIST
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: PUSH
11988: EMPTY
11989: LIST
11990: LIST
11991: PPUSH
11992: CALL_OW 69
11996: PUSH
11997: LD_EXP 74
12001: PUSH
12002: LD_EXP 75
12006: PUSH
12007: EMPTY
12008: LIST
12009: LIST
12010: DIFF
12011: PPUSH
12012: CALL_OW 1
12016: ST_TO_ADDR
// uc_side := 0 ;
12017: LD_ADDR_OWVAR 20
12021: PUSH
12022: LD_INT 0
12024: ST_TO_ADDR
// uc_nation := 0 ;
12025: LD_ADDR_OWVAR 21
12029: PUSH
12030: LD_INT 0
12032: ST_TO_ADDR
// for i = 1 to 5 do
12033: LD_ADDR_VAR 0 2
12037: PUSH
12038: DOUBLE
12039: LD_INT 1
12041: DEC
12042: ST_TO_ADDR
12043: LD_INT 5
12045: PUSH
12046: FOR_TO
12047: IFFALSE 12084
// begin InitHc ;
12049: CALL_OW 19
// hc_class := class_apeman ;
12053: LD_ADDR_OWVAR 28
12057: PUSH
12058: LD_INT 12
12060: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12061: CALL_OW 44
12065: PPUSH
12066: LD_INT 299
12068: PPUSH
12069: LD_INT 229
12071: PPUSH
12072: LD_INT 10
12074: PPUSH
12075: LD_INT 0
12077: PPUSH
12078: CALL_OW 50
// end ;
12082: GO 12046
12084: POP
12085: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12086: LD_EXP 74
12090: PPUSH
12091: LD_INT 259
12093: PPUSH
12094: LD_INT 235
12096: PPUSH
12097: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12101: LD_EXP 74
12105: PPUSH
12106: LD_INT 262
12108: PPUSH
12109: LD_INT 235
12111: PPUSH
12112: CALL_OW 178
// if Simms then
12116: LD_EXP 75
12120: IFFALSE 12151
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12122: LD_EXP 75
12126: PPUSH
12127: LD_INT 262
12129: PPUSH
12130: LD_INT 235
12132: PPUSH
12133: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12137: LD_EXP 75
12141: PPUSH
12142: LD_EXP 74
12146: PPUSH
12147: CALL_OW 179
// end ; end ;
12151: LD_VAR 0 1
12155: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12156: LD_EXP 31
12160: PUSH
12161: LD_EXP 23
12165: NOT
12166: AND
12167: IFFALSE 12343
12169: GO 12171
12171: DISABLE
12172: LD_INT 0
12174: PPUSH
12175: PPUSH
12176: PPUSH
// begin enable ;
12177: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12178: LD_ADDR_VAR 0 2
12182: PUSH
12183: LD_INT 81
12185: PUSH
12186: LD_INT 7
12188: PUSH
12189: EMPTY
12190: LIST
12191: LIST
12192: PUSH
12193: LD_INT 2
12195: PUSH
12196: LD_INT 32
12198: PUSH
12199: LD_INT 3
12201: PUSH
12202: EMPTY
12203: LIST
12204: LIST
12205: PUSH
12206: LD_INT 30
12208: PUSH
12209: LD_INT 30
12211: PUSH
12212: EMPTY
12213: LIST
12214: LIST
12215: PUSH
12216: LD_INT 30
12218: PUSH
12219: LD_INT 28
12221: PUSH
12222: EMPTY
12223: LIST
12224: LIST
12225: PUSH
12226: LD_INT 34
12228: PUSH
12229: LD_INT 49
12231: PUSH
12232: EMPTY
12233: LIST
12234: LIST
12235: PUSH
12236: LD_INT 34
12238: PUSH
12239: LD_INT 10
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: PUSH
12246: LD_INT 34
12248: PUSH
12249: LD_INT 8
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: PUSH
12256: EMPTY
12257: LIST
12258: LIST
12259: LIST
12260: LIST
12261: LIST
12262: LIST
12263: LIST
12264: PUSH
12265: EMPTY
12266: LIST
12267: LIST
12268: PPUSH
12269: CALL_OW 69
12273: ST_TO_ADDR
// if not tmp then
12274: LD_VAR 0 2
12278: NOT
12279: IFFALSE 12283
// exit ;
12281: GO 12343
// target := tmp [ rand ( 1 , tmp ) ] ;
12283: LD_ADDR_VAR 0 3
12287: PUSH
12288: LD_VAR 0 2
12292: PUSH
12293: LD_INT 1
12295: PPUSH
12296: LD_VAR 0 2
12300: PPUSH
12301: CALL_OW 12
12305: ARRAY
12306: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12307: LD_VAR 0 3
12311: PPUSH
12312: CALL_OW 255
12316: PUSH
12317: LD_INT 1
12319: EQUAL
12320: IFFALSE 12331
// CenterNowOnUnits ( target ) ;
12322: LD_VAR 0 3
12326: PPUSH
12327: CALL_OW 87
// SetLives ( target , 0 ) ;
12331: LD_VAR 0 3
12335: PPUSH
12336: LD_INT 0
12338: PPUSH
12339: CALL_OW 234
// end ;
12343: PPOPN 3
12345: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12346: LD_EXP 23
12350: NOT
12351: PUSH
12352: LD_EXP 31
12356: AND
12357: IFFALSE 12879
12359: GO 12361
12361: DISABLE
12362: LD_INT 0
12364: PPUSH
12365: PPUSH
12366: PPUSH
// begin uc_side := 7 ;
12367: LD_ADDR_OWVAR 20
12371: PUSH
12372: LD_INT 7
12374: ST_TO_ADDR
// uc_nation := 1 ;
12375: LD_ADDR_OWVAR 21
12379: PUSH
12380: LD_INT 1
12382: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12383: LD_ADDR_VAR 0 3
12387: PUSH
12388: LD_INT 125
12390: PUSH
12391: LD_INT 163
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PUSH
12398: LD_INT 185
12400: PUSH
12401: LD_INT 168
12403: PUSH
12404: EMPTY
12405: LIST
12406: LIST
12407: PUSH
12408: LD_INT 111
12410: PUSH
12411: LD_INT 97
12413: PUSH
12414: EMPTY
12415: LIST
12416: LIST
12417: PUSH
12418: EMPTY
12419: LIST
12420: LIST
12421: LIST
12422: PPUSH
12423: CALL 107856 0 1
12427: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12428: LD_ADDR_EXP 91
12432: PUSH
12433: EMPTY
12434: ST_TO_ADDR
// for i = 1 to Difficulty do
12435: LD_ADDR_VAR 0 1
12439: PUSH
12440: DOUBLE
12441: LD_INT 1
12443: DEC
12444: ST_TO_ADDR
12445: LD_OWVAR 67
12449: PUSH
12450: FOR_TO
12451: IFFALSE 12609
// begin InitHc ;
12453: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12457: LD_INT 0
12459: PPUSH
12460: LD_INT 8
12462: PPUSH
12463: CALL_OW 381
// un := CreateHuman ;
12467: LD_ADDR_VAR 0 2
12471: PUSH
12472: CALL_OW 44
12476: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12477: LD_VAR 0 2
12481: PPUSH
12482: LD_INT 258
12484: PPUSH
12485: LD_INT 267
12487: PPUSH
12488: LD_INT 4
12490: PPUSH
12491: LD_INT 0
12493: PPUSH
12494: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12498: LD_ADDR_EXP 91
12502: PUSH
12503: LD_EXP 91
12507: PUSH
12508: LD_VAR 0 2
12512: UNION
12513: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12514: LD_VAR 0 2
12518: PPUSH
12519: LD_VAR 0 3
12523: PUSH
12524: LD_VAR 0 1
12528: ARRAY
12529: PUSH
12530: LD_INT 1
12532: ARRAY
12533: PPUSH
12534: LD_VAR 0 3
12538: PUSH
12539: LD_VAR 0 1
12543: ARRAY
12544: PUSH
12545: LD_INT 2
12547: ARRAY
12548: PPUSH
12549: LD_INT 4
12551: PPUSH
12552: LD_INT 1
12554: PPUSH
12555: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12559: LD_VAR 0 2
12563: PPUSH
12564: LD_VAR 0 3
12568: PUSH
12569: LD_VAR 0 1
12573: ARRAY
12574: PUSH
12575: LD_INT 1
12577: ARRAY
12578: PPUSH
12579: LD_VAR 0 3
12583: PUSH
12584: LD_VAR 0 1
12588: ARRAY
12589: PUSH
12590: LD_INT 2
12592: ARRAY
12593: PPUSH
12594: CALL_OW 171
// AddComInvisible ( un ) ;
12598: LD_VAR 0 2
12602: PPUSH
12603: CALL_OW 212
// end ;
12607: GO 12450
12609: POP
12610: POP
// repeat wait ( 0 0$20 ) ;
12611: LD_INT 700
12613: PPUSH
12614: CALL_OW 67
// for i in allianceSpecialForce do
12618: LD_ADDR_VAR 0 1
12622: PUSH
12623: LD_EXP 91
12627: PUSH
12628: FOR_IN
12629: IFFALSE 12864
// begin if IsInvisible ( i ) then
12631: LD_VAR 0 1
12635: PPUSH
12636: CALL_OW 571
12640: IFFALSE 12833
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12642: LD_ADDR_VAR 0 3
12646: PUSH
12647: LD_INT 22
12649: PUSH
12650: LD_INT 1
12652: PUSH
12653: EMPTY
12654: LIST
12655: LIST
12656: PUSH
12657: LD_INT 50
12659: PUSH
12660: EMPTY
12661: LIST
12662: PUSH
12663: LD_INT 56
12665: PUSH
12666: EMPTY
12667: LIST
12668: PUSH
12669: LD_INT 91
12671: PUSH
12672: LD_VAR 0 1
12676: PUSH
12677: LD_INT 25
12679: PUSH
12680: LD_INT 30
12682: PUSH
12683: LD_INT 35
12685: PUSH
12686: EMPTY
12687: LIST
12688: LIST
12689: LIST
12690: PUSH
12691: LD_OWVAR 67
12695: ARRAY
12696: PUSH
12697: EMPTY
12698: LIST
12699: LIST
12700: LIST
12701: PUSH
12702: LD_INT 2
12704: PUSH
12705: LD_INT 25
12707: PUSH
12708: LD_INT 1
12710: PUSH
12711: EMPTY
12712: LIST
12713: LIST
12714: PUSH
12715: LD_INT 25
12717: PUSH
12718: LD_INT 2
12720: PUSH
12721: EMPTY
12722: LIST
12723: LIST
12724: PUSH
12725: LD_INT 25
12727: PUSH
12728: LD_INT 3
12730: PUSH
12731: EMPTY
12732: LIST
12733: LIST
12734: PUSH
12735: LD_INT 25
12737: PUSH
12738: LD_INT 4
12740: PUSH
12741: EMPTY
12742: LIST
12743: LIST
12744: PUSH
12745: LD_INT 25
12747: PUSH
12748: LD_INT 5
12750: PUSH
12751: EMPTY
12752: LIST
12753: LIST
12754: PUSH
12755: LD_INT 25
12757: PUSH
12758: LD_INT 8
12760: PUSH
12761: EMPTY
12762: LIST
12763: LIST
12764: PUSH
12765: EMPTY
12766: LIST
12767: LIST
12768: LIST
12769: LIST
12770: LIST
12771: LIST
12772: LIST
12773: PUSH
12774: EMPTY
12775: LIST
12776: LIST
12777: LIST
12778: LIST
12779: LIST
12780: PPUSH
12781: CALL_OW 69
12785: ST_TO_ADDR
// if not tmp then
12786: LD_VAR 0 3
12790: NOT
12791: IFFALSE 12795
// continue ;
12793: GO 12628
// if Prob ( 30 * Difficulty ) then
12795: LD_INT 30
12797: PUSH
12798: LD_OWVAR 67
12802: MUL
12803: PPUSH
12804: CALL_OW 13
12808: IFFALSE 12833
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12810: LD_VAR 0 3
12814: PUSH
12815: LD_INT 1
12817: PPUSH
12818: LD_VAR 0 3
12822: PPUSH
12823: CALL_OW 12
12827: ARRAY
12828: PPUSH
12829: CALL 31000 0 1
// end ; if IsDead ( i ) then
12833: LD_VAR 0 1
12837: PPUSH
12838: CALL_OW 301
12842: IFFALSE 12862
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12844: LD_ADDR_EXP 91
12848: PUSH
12849: LD_EXP 91
12853: PUSH
12854: LD_VAR 0 1
12858: DIFF
12859: ST_TO_ADDR
// continue ;
12860: GO 12628
// end ; end ;
12862: GO 12628
12864: POP
12865: POP
// until allianceDestroyed or not allianceSpecialForce ;
12866: LD_EXP 23
12870: PUSH
12871: LD_EXP 91
12875: NOT
12876: OR
12877: IFFALSE 12611
// end ;
12879: PPOPN 3
12881: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12882: LD_EXP 23
12886: NOT
12887: PUSH
12888: LD_EXP 31
12892: AND
12893: IFFALSE 13860
12895: GO 12897
12897: DISABLE
12898: LD_INT 0
12900: PPUSH
12901: PPUSH
12902: PPUSH
12903: PPUSH
// begin enable ;
12904: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12905: LD_INT 22
12907: PUSH
12908: LD_INT 7
12910: PUSH
12911: EMPTY
12912: LIST
12913: LIST
12914: PUSH
12915: LD_INT 30
12917: PUSH
12918: LD_INT 3
12920: PUSH
12921: EMPTY
12922: LIST
12923: LIST
12924: PUSH
12925: EMPTY
12926: LIST
12927: LIST
12928: PPUSH
12929: CALL_OW 69
12933: NOT
12934: IFFALSE 12938
// exit ;
12936: GO 13860
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12938: LD_ADDR_VAR 0 4
12942: PUSH
12943: LD_INT 22
12945: PUSH
12946: LD_INT 7
12948: PUSH
12949: EMPTY
12950: LIST
12951: LIST
12952: PUSH
12953: LD_INT 30
12955: PUSH
12956: LD_INT 34
12958: PUSH
12959: EMPTY
12960: LIST
12961: LIST
12962: PUSH
12963: EMPTY
12964: LIST
12965: LIST
12966: PPUSH
12967: CALL_OW 69
12971: ST_TO_ADDR
// if Prob ( 40 ) then
12972: LD_INT 40
12974: PPUSH
12975: CALL_OW 13
12979: IFFALSE 13106
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12981: LD_INT 1
12983: PPUSH
12984: LD_INT 5
12986: PUSH
12987: LD_INT 3
12989: PUSH
12990: LD_INT 2
12992: PUSH
12993: LD_INT 6
12995: PUSH
12996: EMPTY
12997: LIST
12998: LIST
12999: LIST
13000: LIST
13001: PUSH
13002: LD_INT 5
13004: PUSH
13005: LD_INT 3
13007: PUSH
13008: LD_INT 2
13010: PUSH
13011: LD_INT 6
13013: PUSH
13014: EMPTY
13015: LIST
13016: LIST
13017: LIST
13018: LIST
13019: PUSH
13020: LD_INT 5
13022: PUSH
13023: LD_INT 3
13025: PUSH
13026: LD_INT 2
13028: PUSH
13029: LD_INT 6
13031: PUSH
13032: EMPTY
13033: LIST
13034: LIST
13035: LIST
13036: LIST
13037: PUSH
13038: LD_INT 24
13040: PUSH
13041: LD_INT 3
13043: PUSH
13044: LD_INT 3
13046: PUSH
13047: LD_INT 45
13049: PUSH
13050: EMPTY
13051: LIST
13052: LIST
13053: LIST
13054: LIST
13055: PUSH
13056: LD_INT 24
13058: PUSH
13059: LD_INT 3
13061: PUSH
13062: LD_INT 3
13064: PUSH
13065: LD_INT 47
13067: PUSH
13068: EMPTY
13069: LIST
13070: LIST
13071: LIST
13072: LIST
13073: PUSH
13074: LD_INT 24
13076: PUSH
13077: LD_INT 3
13079: PUSH
13080: LD_INT 3
13082: PUSH
13083: LD_INT 45
13085: PUSH
13086: EMPTY
13087: LIST
13088: LIST
13089: LIST
13090: LIST
13091: PUSH
13092: EMPTY
13093: LIST
13094: LIST
13095: LIST
13096: LIST
13097: LIST
13098: LIST
13099: PPUSH
13100: CALL 58550 0 2
// end else
13104: GO 13229
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13106: LD_INT 1
13108: PPUSH
13109: LD_INT 24
13111: PUSH
13112: LD_INT 3
13114: PUSH
13115: LD_INT 3
13117: PUSH
13118: LD_INT 47
13120: PUSH
13121: EMPTY
13122: LIST
13123: LIST
13124: LIST
13125: LIST
13126: PUSH
13127: LD_INT 24
13129: PUSH
13130: LD_INT 3
13132: PUSH
13133: LD_INT 3
13135: PUSH
13136: LD_INT 47
13138: PUSH
13139: EMPTY
13140: LIST
13141: LIST
13142: LIST
13143: LIST
13144: PUSH
13145: LD_INT 5
13147: PUSH
13148: LD_INT 3
13150: PUSH
13151: LD_INT 2
13153: PUSH
13154: LD_INT 9
13156: PUSH
13157: EMPTY
13158: LIST
13159: LIST
13160: LIST
13161: LIST
13162: PUSH
13163: LD_INT 5
13165: PUSH
13166: LD_INT 3
13168: PUSH
13169: LD_INT 2
13171: PUSH
13172: LD_INT 9
13174: PUSH
13175: EMPTY
13176: LIST
13177: LIST
13178: LIST
13179: LIST
13180: PUSH
13181: LD_INT 24
13183: PUSH
13184: LD_INT 1
13186: PUSH
13187: LD_INT 3
13189: PUSH
13190: LD_INT 45
13192: PUSH
13193: EMPTY
13194: LIST
13195: LIST
13196: LIST
13197: LIST
13198: PUSH
13199: LD_INT 24
13201: PUSH
13202: LD_INT 1
13204: PUSH
13205: LD_INT 3
13207: PUSH
13208: LD_INT 45
13210: PUSH
13211: EMPTY
13212: LIST
13213: LIST
13214: LIST
13215: LIST
13216: PUSH
13217: EMPTY
13218: LIST
13219: LIST
13220: LIST
13221: LIST
13222: LIST
13223: LIST
13224: PPUSH
13225: CALL 58550 0 2
// end ; if Difficulty > 1 then
13229: LD_OWVAR 67
13233: PUSH
13234: LD_INT 1
13236: GREATER
13237: IFFALSE 13267
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13239: LD_INT 1
13241: PPUSH
13242: LD_INT 24
13244: PUSH
13245: LD_INT 3
13247: PUSH
13248: LD_INT 3
13250: PUSH
13251: LD_INT 47
13253: PUSH
13254: EMPTY
13255: LIST
13256: LIST
13257: LIST
13258: LIST
13259: PUSH
13260: EMPTY
13261: LIST
13262: PPUSH
13263: CALL 58550 0 2
// repeat wait ( 0 0$1 ) ;
13267: LD_INT 35
13269: PPUSH
13270: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13274: LD_INT 1
13276: PPUSH
13277: LD_INT 1
13279: PPUSH
13280: CALL 59968 0 2
13284: PUSH
13285: LD_INT 6
13287: PUSH
13288: LD_INT 7
13290: PUSH
13291: LD_INT 7
13293: PUSH
13294: EMPTY
13295: LIST
13296: LIST
13297: LIST
13298: PUSH
13299: LD_OWVAR 67
13303: ARRAY
13304: GREATEREQUAL
13305: IFFALSE 13267
// wait ( 0 0$40 ) ;
13307: LD_INT 1400
13309: PPUSH
13310: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13314: LD_ADDR_VAR 0 2
13318: PUSH
13319: LD_INT 1
13321: PPUSH
13322: LD_INT 1
13324: PPUSH
13325: CALL 59968 0 2
13329: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13330: LD_ADDR_EXP 121
13334: PUSH
13335: LD_EXP 121
13339: PPUSH
13340: LD_INT 1
13342: PPUSH
13343: LD_EXP 121
13347: PUSH
13348: LD_INT 1
13350: ARRAY
13351: PUSH
13352: LD_VAR 0 2
13356: DIFF
13357: PPUSH
13358: CALL_OW 1
13362: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13363: LD_ADDR_VAR 0 3
13367: PUSH
13368: LD_INT 0
13370: PPUSH
13371: LD_INT 1
13373: PPUSH
13374: CALL_OW 12
13378: ST_TO_ADDR
// if target then
13379: LD_VAR 0 3
13383: IFFALSE 13549
// begin for i in tmp do
13385: LD_ADDR_VAR 0 1
13389: PUSH
13390: LD_VAR 0 2
13394: PUSH
13395: FOR_IN
13396: IFFALSE 13421
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13398: LD_VAR 0 1
13402: PPUSH
13403: LD_INT 179
13405: PPUSH
13406: LD_INT 209
13408: PPUSH
13409: LD_INT 8
13411: PPUSH
13412: LD_INT 1
13414: PPUSH
13415: CALL_OW 483
13419: GO 13395
13421: POP
13422: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13423: LD_ADDR_VAR 0 2
13427: PUSH
13428: LD_VAR 0 2
13432: PPUSH
13433: LD_INT 24
13435: PUSH
13436: LD_INT 250
13438: PUSH
13439: EMPTY
13440: LIST
13441: LIST
13442: PPUSH
13443: CALL_OW 72
13447: ST_TO_ADDR
// for i in tmp do
13448: LD_ADDR_VAR 0 1
13452: PUSH
13453: LD_VAR 0 2
13457: PUSH
13458: FOR_IN
13459: IFFALSE 13499
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13461: LD_VAR 0 1
13465: PPUSH
13466: LD_INT 179
13468: PPUSH
13469: LD_INT 209
13471: PPUSH
13472: CALL_OW 297
13476: PUSH
13477: LD_INT 9
13479: GREATER
13480: IFFALSE 13497
// ComMoveXY ( i , 179 , 209 ) ;
13482: LD_VAR 0 1
13486: PPUSH
13487: LD_INT 179
13489: PPUSH
13490: LD_INT 209
13492: PPUSH
13493: CALL_OW 111
13497: GO 13458
13499: POP
13500: POP
// wait ( 0 0$1 ) ;
13501: LD_INT 35
13503: PPUSH
13504: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13508: LD_VAR 0 2
13512: PPUSH
13513: LD_INT 92
13515: PUSH
13516: LD_INT 179
13518: PUSH
13519: LD_INT 209
13521: PUSH
13522: LD_INT 9
13524: PUSH
13525: EMPTY
13526: LIST
13527: LIST
13528: LIST
13529: LIST
13530: PPUSH
13531: CALL_OW 72
13535: PUSH
13536: LD_VAR 0 2
13540: PUSH
13541: LD_INT 1
13543: MINUS
13544: GREATEREQUAL
13545: IFFALSE 13423
// end else
13547: GO 13711
// begin for i in tmp do
13549: LD_ADDR_VAR 0 1
13553: PUSH
13554: LD_VAR 0 2
13558: PUSH
13559: FOR_IN
13560: IFFALSE 13585
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13562: LD_VAR 0 1
13566: PPUSH
13567: LD_INT 285
13569: PPUSH
13570: LD_INT 163
13572: PPUSH
13573: LD_INT 8
13575: PPUSH
13576: LD_INT 1
13578: PPUSH
13579: CALL_OW 483
13583: GO 13559
13585: POP
13586: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13587: LD_ADDR_VAR 0 2
13591: PUSH
13592: LD_VAR 0 2
13596: PPUSH
13597: LD_INT 24
13599: PUSH
13600: LD_INT 250
13602: PUSH
13603: EMPTY
13604: LIST
13605: LIST
13606: PPUSH
13607: CALL_OW 72
13611: ST_TO_ADDR
// for i in tmp do
13612: LD_ADDR_VAR 0 1
13616: PUSH
13617: LD_VAR 0 2
13621: PUSH
13622: FOR_IN
13623: IFFALSE 13663
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13625: LD_VAR 0 1
13629: PPUSH
13630: LD_INT 285
13632: PPUSH
13633: LD_INT 163
13635: PPUSH
13636: CALL_OW 297
13640: PUSH
13641: LD_INT 9
13643: GREATER
13644: IFFALSE 13661
// ComMoveXY ( i , 285 , 163 ) ;
13646: LD_VAR 0 1
13650: PPUSH
13651: LD_INT 285
13653: PPUSH
13654: LD_INT 163
13656: PPUSH
13657: CALL_OW 111
13661: GO 13622
13663: POP
13664: POP
// wait ( 0 0$1 ) ;
13665: LD_INT 35
13667: PPUSH
13668: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13672: LD_VAR 0 2
13676: PPUSH
13677: LD_INT 92
13679: PUSH
13680: LD_INT 285
13682: PUSH
13683: LD_INT 163
13685: PUSH
13686: LD_INT 9
13688: PUSH
13689: EMPTY
13690: LIST
13691: LIST
13692: LIST
13693: LIST
13694: PPUSH
13695: CALL_OW 72
13699: PUSH
13700: LD_VAR 0 2
13704: PUSH
13705: LD_INT 1
13707: MINUS
13708: GREATEREQUAL
13709: IFFALSE 13587
// end ; repeat wait ( 0 0$1 ) ;
13711: LD_INT 35
13713: PPUSH
13714: CALL_OW 67
// for i in tmp do
13718: LD_ADDR_VAR 0 1
13722: PUSH
13723: LD_VAR 0 2
13727: PUSH
13728: FOR_IN
13729: IFFALSE 13851
// if GetLives ( i ) > 251 then
13731: LD_VAR 0 1
13735: PPUSH
13736: CALL_OW 256
13740: PUSH
13741: LD_INT 251
13743: GREATER
13744: IFFALSE 13833
// begin if GetWeapon ( i ) = ru_time_lapser then
13746: LD_VAR 0 1
13750: PPUSH
13751: CALL_OW 264
13755: PUSH
13756: LD_INT 49
13758: EQUAL
13759: IFFALSE 13797
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13761: LD_VAR 0 1
13765: PPUSH
13766: LD_INT 81
13768: PUSH
13769: LD_INT 7
13771: PUSH
13772: EMPTY
13773: LIST
13774: LIST
13775: PPUSH
13776: CALL_OW 69
13780: PPUSH
13781: LD_VAR 0 1
13785: PPUSH
13786: CALL_OW 74
13790: PPUSH
13791: CALL_OW 112
13795: GO 13831
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13797: LD_VAR 0 1
13801: PPUSH
13802: LD_INT 81
13804: PUSH
13805: LD_INT 7
13807: PUSH
13808: EMPTY
13809: LIST
13810: LIST
13811: PPUSH
13812: CALL_OW 69
13816: PPUSH
13817: LD_VAR 0 1
13821: PPUSH
13822: CALL_OW 74
13826: PPUSH
13827: CALL_OW 115
// end else
13831: GO 13849
// tmp := tmp diff i ;
13833: LD_ADDR_VAR 0 2
13837: PUSH
13838: LD_VAR 0 2
13842: PUSH
13843: LD_VAR 0 1
13847: DIFF
13848: ST_TO_ADDR
13849: GO 13728
13851: POP
13852: POP
// until not tmp ;
13853: LD_VAR 0 2
13857: NOT
13858: IFFALSE 13711
// end ; end_of_file
13860: PPOPN 4
13862: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13863: LD_INT 0
13865: PPUSH
13866: PPUSH
13867: PPUSH
13868: PPUSH
// missionStage := 13 ;
13869: LD_ADDR_EXP 15
13873: PUSH
13874: LD_INT 13
13876: ST_TO_ADDR
// uc_side := 2 ;
13877: LD_ADDR_OWVAR 20
13881: PUSH
13882: LD_INT 2
13884: ST_TO_ADDR
// uc_nation := 2 ;
13885: LD_ADDR_OWVAR 21
13889: PUSH
13890: LD_INT 2
13892: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13893: LD_ADDR_EXP 92
13897: PUSH
13898: LD_STRING Omar
13900: PPUSH
13901: CALL_OW 25
13905: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13906: LD_EXP 92
13910: PPUSH
13911: LD_INT 4
13913: PPUSH
13914: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13918: LD_EXP 92
13922: PPUSH
13923: LD_INT 242
13925: PPUSH
13926: LD_INT 75
13928: PPUSH
13929: LD_INT 0
13931: PPUSH
13932: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13936: LD_ADDR_EXP 93
13940: PUSH
13941: LD_STRING Heike
13943: PPUSH
13944: CALL_OW 25
13948: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13949: LD_INT 14
13951: PPUSH
13952: LD_INT 3
13954: PPUSH
13955: LD_INT 1
13957: PPUSH
13958: LD_INT 27
13960: PPUSH
13961: LD_INT 100
13963: PPUSH
13964: CALL 72009 0 5
// veh := CreateVehicle ;
13968: LD_ADDR_VAR 0 3
13972: PUSH
13973: CALL_OW 45
13977: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13978: LD_VAR 0 3
13982: PPUSH
13983: LD_INT 1
13985: PPUSH
13986: CALL_OW 242
// SetDir ( veh , 4 ) ;
13990: LD_VAR 0 3
13994: PPUSH
13995: LD_INT 4
13997: PPUSH
13998: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14002: LD_VAR 0 3
14006: PPUSH
14007: LD_INT 241
14009: PPUSH
14010: LD_INT 72
14012: PPUSH
14013: LD_INT 0
14015: PPUSH
14016: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14020: LD_EXP 93
14024: PPUSH
14025: LD_VAR 0 3
14029: PPUSH
14030: CALL_OW 52
// if KhatamStatus then
14034: LD_EXP 8
14038: IFFALSE 14089
// begin Khatam := NewCharacter ( Khatam ) ;
14040: LD_ADDR_EXP 94
14044: PUSH
14045: LD_STRING Khatam
14047: PPUSH
14048: CALL_OW 25
14052: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14053: LD_EXP 94
14057: PPUSH
14058: LD_INT 245
14060: PPUSH
14061: LD_INT 78
14063: PPUSH
14064: LD_INT 3
14066: PPUSH
14067: LD_INT 0
14069: PPUSH
14070: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14074: LD_EXP 94
14078: PPUSH
14079: LD_INT 4
14081: PPUSH
14082: LD_INT 10
14084: PPUSH
14085: CALL_OW 237
// end ; for i = 1 to Difficulty do
14089: LD_ADDR_VAR 0 2
14093: PUSH
14094: DOUBLE
14095: LD_INT 1
14097: DEC
14098: ST_TO_ADDR
14099: LD_OWVAR 67
14103: PUSH
14104: FOR_TO
14105: IFFALSE 14171
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14107: LD_INT 0
14109: PPUSH
14110: LD_INT 7
14112: PUSH
14113: LD_OWVAR 67
14117: PLUS
14118: PPUSH
14119: CALL_OW 384
// un := CreateHuman ;
14123: LD_ADDR_VAR 0 4
14127: PUSH
14128: CALL_OW 44
14132: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14133: LD_VAR 0 4
14137: PPUSH
14138: LD_INT 28
14140: PUSH
14141: LD_INT 29
14143: PUSH
14144: EMPTY
14145: LIST
14146: LIST
14147: PUSH
14148: LD_VAR 0 2
14152: PUSH
14153: LD_INT 2
14155: MOD
14156: PUSH
14157: LD_INT 1
14159: PLUS
14160: ARRAY
14161: PPUSH
14162: LD_INT 0
14164: PPUSH
14165: CALL_OW 49
// end ;
14169: GO 14104
14171: POP
14172: POP
// for i = 1 to 6 do
14173: LD_ADDR_VAR 0 2
14177: PUSH
14178: DOUBLE
14179: LD_INT 1
14181: DEC
14182: ST_TO_ADDR
14183: LD_INT 6
14185: PUSH
14186: FOR_TO
14187: IFFALSE 14232
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14189: LD_INT 0
14191: PPUSH
14192: LD_INT 7
14194: PUSH
14195: LD_OWVAR 67
14199: PLUS
14200: PPUSH
14201: CALL_OW 381
// un := CreateHuman ;
14205: LD_ADDR_VAR 0 4
14209: PUSH
14210: CALL_OW 44
14214: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14215: LD_VAR 0 4
14219: PPUSH
14220: LD_INT 28
14222: PPUSH
14223: LD_INT 0
14225: PPUSH
14226: CALL_OW 49
// end ;
14230: GO 14186
14232: POP
14233: POP
// for i = 1 to 3 do
14234: LD_ADDR_VAR 0 2
14238: PUSH
14239: DOUBLE
14240: LD_INT 1
14242: DEC
14243: ST_TO_ADDR
14244: LD_INT 3
14246: PUSH
14247: FOR_TO
14248: IFFALSE 14296
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14250: LD_INT 0
14252: PPUSH
14253: LD_INT 8
14255: PPUSH
14256: LD_INT 7
14258: PUSH
14259: LD_OWVAR 67
14263: PLUS
14264: PPUSH
14265: CALL_OW 380
// un := CreateHuman ;
14269: LD_ADDR_VAR 0 4
14273: PUSH
14274: CALL_OW 44
14278: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14279: LD_VAR 0 4
14283: PPUSH
14284: LD_INT 28
14286: PPUSH
14287: LD_INT 0
14289: PPUSH
14290: CALL_OW 49
// end ;
14294: GO 14247
14296: POP
14297: POP
// for i = 1 to 3 do
14298: LD_ADDR_VAR 0 2
14302: PUSH
14303: DOUBLE
14304: LD_INT 1
14306: DEC
14307: ST_TO_ADDR
14308: LD_INT 3
14310: PUSH
14311: FOR_TO
14312: IFFALSE 14402
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14314: LD_INT 14
14316: PPUSH
14317: LD_INT 2
14319: PPUSH
14320: LD_INT 1
14322: PPUSH
14323: LD_INT 28
14325: PPUSH
14326: LD_INT 80
14328: PPUSH
14329: CALL 72009 0 5
// veh := CreateVehicle ;
14333: LD_ADDR_VAR 0 3
14337: PUSH
14338: CALL_OW 45
14342: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14343: LD_VAR 0 3
14347: PPUSH
14348: LD_INT 3
14350: PPUSH
14351: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14355: LD_VAR 0 3
14359: PPUSH
14360: LD_INT 29
14362: PPUSH
14363: LD_INT 0
14365: PPUSH
14366: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14370: LD_INT 0
14372: PPUSH
14373: LD_INT 7
14375: PUSH
14376: LD_OWVAR 67
14380: PLUS
14381: PPUSH
14382: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14386: CALL_OW 44
14390: PPUSH
14391: LD_VAR 0 3
14395: PPUSH
14396: CALL_OW 52
// end ;
14400: GO 14311
14402: POP
14403: POP
// for i = 1 to 5 + Difficulty do
14404: LD_ADDR_VAR 0 2
14408: PUSH
14409: DOUBLE
14410: LD_INT 1
14412: DEC
14413: ST_TO_ADDR
14414: LD_INT 5
14416: PUSH
14417: LD_OWVAR 67
14421: PLUS
14422: PUSH
14423: FOR_TO
14424: IFFALSE 14551
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14426: LD_INT 14
14428: PPUSH
14429: LD_INT 1
14431: PPUSH
14432: LD_INT 3
14434: PPUSH
14435: CALL_OW 12
14439: PPUSH
14440: LD_INT 1
14442: PPUSH
14443: LD_INT 28
14445: PUSH
14446: LD_INT 26
14448: PUSH
14449: LD_INT 27
14451: PUSH
14452: LD_INT 25
14454: PUSH
14455: EMPTY
14456: LIST
14457: LIST
14458: LIST
14459: LIST
14460: PUSH
14461: LD_VAR 0 2
14465: PUSH
14466: LD_INT 4
14468: MOD
14469: PUSH
14470: LD_INT 1
14472: PLUS
14473: ARRAY
14474: PPUSH
14475: LD_INT 80
14477: PPUSH
14478: CALL 72009 0 5
// veh := CreateVehicle ;
14482: LD_ADDR_VAR 0 3
14486: PUSH
14487: CALL_OW 45
14491: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14492: LD_VAR 0 3
14496: PPUSH
14497: LD_INT 4
14499: PPUSH
14500: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14504: LD_VAR 0 3
14508: PPUSH
14509: LD_INT 28
14511: PPUSH
14512: LD_INT 0
14514: PPUSH
14515: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14519: LD_INT 0
14521: PPUSH
14522: LD_INT 7
14524: PUSH
14525: LD_OWVAR 67
14529: PLUS
14530: PPUSH
14531: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14535: CALL_OW 44
14539: PPUSH
14540: LD_VAR 0 3
14544: PPUSH
14545: CALL_OW 52
// end ;
14549: GO 14423
14551: POP
14552: POP
// for i = 1 to 3 do
14553: LD_ADDR_VAR 0 2
14557: PUSH
14558: DOUBLE
14559: LD_INT 1
14561: DEC
14562: ST_TO_ADDR
14563: LD_INT 3
14565: PUSH
14566: FOR_TO
14567: IFFALSE 14627
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14569: LD_INT 14
14571: PPUSH
14572: LD_INT 3
14574: PPUSH
14575: LD_INT 5
14577: PPUSH
14578: LD_INT 29
14580: PPUSH
14581: LD_INT 80
14583: PPUSH
14584: CALL 72009 0 5
// veh := CreateVehicle ;
14588: LD_ADDR_VAR 0 3
14592: PUSH
14593: CALL_OW 45
14597: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14598: LD_VAR 0 3
14602: PPUSH
14603: LD_INT 4
14605: PPUSH
14606: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14610: LD_VAR 0 3
14614: PPUSH
14615: LD_INT 28
14617: PPUSH
14618: LD_INT 0
14620: PPUSH
14621: CALL_OW 49
// end ;
14625: GO 14566
14627: POP
14628: POP
// end ;
14629: LD_VAR 0 1
14633: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14634: LD_INT 22
14636: PUSH
14637: LD_INT 2
14639: PUSH
14640: EMPTY
14641: LIST
14642: LIST
14643: PPUSH
14644: CALL_OW 69
14648: IFFALSE 14948
14650: GO 14652
14652: DISABLE
14653: LD_INT 0
14655: PPUSH
14656: PPUSH
14657: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14658: LD_ADDR_VAR 0 3
14662: PUSH
14663: LD_INT 22
14665: PUSH
14666: LD_INT 2
14668: PUSH
14669: EMPTY
14670: LIST
14671: LIST
14672: PUSH
14673: LD_INT 25
14675: PUSH
14676: LD_INT 4
14678: PUSH
14679: EMPTY
14680: LIST
14681: LIST
14682: PUSH
14683: EMPTY
14684: LIST
14685: LIST
14686: PPUSH
14687: CALL_OW 69
14691: PUSH
14692: LD_EXP 94
14696: DIFF
14697: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14698: LD_ADDR_VAR 0 2
14702: PUSH
14703: LD_INT 22
14705: PUSH
14706: LD_INT 2
14708: PUSH
14709: EMPTY
14710: LIST
14711: LIST
14712: PPUSH
14713: CALL_OW 69
14717: PUSH
14718: LD_EXP 94
14722: PUSH
14723: LD_VAR 0 3
14727: UNION
14728: DIFF
14729: ST_TO_ADDR
// if Khatam then
14730: LD_EXP 94
14734: IFFALSE 14751
// ComMoveXY ( Khatam , 211 , 92 ) ;
14736: LD_EXP 94
14740: PPUSH
14741: LD_INT 211
14743: PPUSH
14744: LD_INT 92
14746: PPUSH
14747: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14751: LD_INT 197
14753: PPUSH
14754: LD_INT 80
14756: PPUSH
14757: LD_INT 2
14759: PPUSH
14760: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14764: LD_INT 213
14766: PPUSH
14767: LD_INT 90
14769: PPUSH
14770: LD_INT 2
14772: PPUSH
14773: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14777: LD_INT 215
14779: PPUSH
14780: LD_INT 129
14782: PPUSH
14783: LD_INT 2
14785: PPUSH
14786: CALL_OW 441
// if sci then
14790: LD_VAR 0 3
14794: IFFALSE 14815
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14796: LD_VAR 0 3
14800: PUSH
14801: LD_INT 1
14803: ARRAY
14804: PPUSH
14805: LD_INT 197
14807: PPUSH
14808: LD_INT 80
14810: PPUSH
14811: CALL_OW 158
// if sci > 1 then
14815: LD_VAR 0 3
14819: PUSH
14820: LD_INT 1
14822: GREATER
14823: IFFALSE 14844
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14825: LD_VAR 0 3
14829: PUSH
14830: LD_INT 2
14832: ARRAY
14833: PPUSH
14834: LD_INT 213
14836: PPUSH
14837: LD_INT 90
14839: PPUSH
14840: CALL_OW 158
// if sci > 2 then
14844: LD_VAR 0 3
14848: PUSH
14849: LD_INT 2
14851: GREATER
14852: IFFALSE 14873
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14854: LD_VAR 0 3
14858: PUSH
14859: LD_INT 3
14861: ARRAY
14862: PPUSH
14863: LD_INT 215
14865: PPUSH
14866: LD_INT 129
14868: PPUSH
14869: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14873: LD_INT 35
14875: PPUSH
14876: CALL_OW 67
// for i in tmp do
14880: LD_ADDR_VAR 0 1
14884: PUSH
14885: LD_VAR 0 2
14889: PUSH
14890: FOR_IN
14891: IFFALSE 14929
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14893: LD_VAR 0 1
14897: PPUSH
14898: LD_INT 81
14900: PUSH
14901: LD_INT 2
14903: PUSH
14904: EMPTY
14905: LIST
14906: LIST
14907: PPUSH
14908: CALL_OW 69
14912: PPUSH
14913: LD_VAR 0 1
14917: PPUSH
14918: CALL_OW 74
14922: PPUSH
14923: CALL_OW 115
14927: GO 14890
14929: POP
14930: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14931: LD_INT 22
14933: PUSH
14934: LD_INT 2
14936: PUSH
14937: EMPTY
14938: LIST
14939: LIST
14940: PPUSH
14941: CALL_OW 69
14945: NOT
14946: IFFALSE 14873
// end ; end_of_file
14948: PPOPN 3
14950: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14951: LD_INT 0
14953: PPUSH
14954: PPUSH
14955: PPUSH
14956: PPUSH
14957: PPUSH
14958: PPUSH
14959: PPUSH
14960: PPUSH
14961: PPUSH
// Video ( true ) ;
14962: LD_INT 1
14964: PPUSH
14965: CALL 107736 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14969: LD_ADDR_VAR 0 5
14973: PUSH
14974: LD_INT 7
14976: PPUSH
14977: LD_INT 0
14979: PPUSH
14980: CALL_OW 517
14984: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14985: LD_ADDR_VAR 0 2
14989: PUSH
14990: DOUBLE
14991: LD_INT 1
14993: DEC
14994: ST_TO_ADDR
14995: LD_VAR 0 5
14999: PUSH
15000: LD_INT 1
15002: ARRAY
15003: PUSH
15004: FOR_TO
15005: IFFALSE 15050
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15007: LD_VAR 0 5
15011: PUSH
15012: LD_INT 1
15014: ARRAY
15015: PUSH
15016: LD_VAR 0 2
15020: ARRAY
15021: PPUSH
15022: LD_VAR 0 5
15026: PUSH
15027: LD_INT 2
15029: ARRAY
15030: PUSH
15031: LD_VAR 0 2
15035: ARRAY
15036: PPUSH
15037: LD_INT 1
15039: PPUSH
15040: LD_INT 15
15042: NEG
15043: PPUSH
15044: CALL 107650 0 4
15048: GO 15004
15050: POP
15051: POP
// CenterNowOnUnits ( Powell ) ;
15052: LD_EXP 58
15056: PPUSH
15057: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15061: LD_ADDR_VAR 0 5
15065: PUSH
15066: LD_EXP 56
15070: PUSH
15071: EMPTY
15072: LIST
15073: ST_TO_ADDR
// if GirlNewVeh then
15074: LD_EXP 57
15078: IFFALSE 15096
// tmp := tmp ^ GirlNewVeh ;
15080: LD_ADDR_VAR 0 5
15084: PUSH
15085: LD_VAR 0 5
15089: PUSH
15090: LD_EXP 57
15094: ADD
15095: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15096: LD_VAR 0 5
15100: PPUSH
15101: LD_INT 60
15103: PPUSH
15104: LD_INT 109
15106: PPUSH
15107: CALL_OW 111
// if KappaStatus then
15111: LD_EXP 2
15115: IFFALSE 15167
// begin Say ( JMM , D1nT-JMM-1 ) ;
15117: LD_EXP 39
15121: PPUSH
15122: LD_STRING D1nT-JMM-1
15124: PPUSH
15125: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15129: LD_EXP 58
15133: PPUSH
15134: LD_STRING D1T-Pow-1
15136: PPUSH
15137: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15141: LD_EXP 39
15145: PPUSH
15146: LD_STRING D1T-JMM-2
15148: PPUSH
15149: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15153: LD_EXP 58
15157: PPUSH
15158: LD_STRING D1T-Pow-2
15160: PPUSH
15161: CALL_OW 88
// end else
15165: GO 15373
// if JMMGirlStatus then
15167: LD_EXP 6
15171: IFFALSE 15316
// begin Say ( JMM , D1T-JMM-1 ) ;
15173: LD_EXP 39
15177: PPUSH
15178: LD_STRING D1T-JMM-1
15180: PPUSH
15181: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15185: LD_EXP 58
15189: PPUSH
15190: LD_STRING D1T-Pow-1
15192: PPUSH
15193: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15197: LD_EXP 39
15201: PPUSH
15202: LD_STRING D1T-JMM-3
15204: PPUSH
15205: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15209: LD_EXP 58
15213: PPUSH
15214: LD_STRING D1T-Pow-3
15216: PPUSH
15217: CALL_OW 88
// if JMMGirl then
15221: LD_EXP 7
15225: IFFALSE 15314
// begin case JMMGirl of 1 :
15227: LD_EXP 7
15231: PUSH
15232: LD_INT 1
15234: DOUBLE
15235: EQUAL
15236: IFTRUE 15240
15238: GO 15255
15240: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15241: LD_EXP 40
15245: PPUSH
15246: LD_STRING D1T-Joan-3
15248: PPUSH
15249: CALL_OW 88
15253: GO 15302
15255: LD_INT 2
15257: DOUBLE
15258: EQUAL
15259: IFTRUE 15263
15261: GO 15278
15263: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15264: LD_EXP 42
15268: PPUSH
15269: LD_STRING D1T-Lisa-3
15271: PPUSH
15272: CALL_OW 88
15276: GO 15302
15278: LD_INT 3
15280: DOUBLE
15281: EQUAL
15282: IFTRUE 15286
15284: GO 15301
15286: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15287: LD_EXP 54
15291: PPUSH
15292: LD_STRING D1T-Con-3
15294: PPUSH
15295: CALL_OW 88
15299: GO 15302
15301: POP
// Say ( Powell , D1T-Pow-4 ) ;
15302: LD_EXP 58
15306: PPUSH
15307: LD_STRING D1T-Pow-4
15309: PPUSH
15310: CALL_OW 88
// end ; end else
15314: GO 15373
// if not FastEnd then
15316: LD_EXP 11
15320: NOT
15321: IFFALSE 15349
// begin Say ( JMM , D1T-JMM-4 ) ;
15323: LD_EXP 39
15327: PPUSH
15328: LD_STRING D1T-JMM-4
15330: PPUSH
15331: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15335: LD_EXP 58
15339: PPUSH
15340: LD_STRING D1T-Pow-5
15342: PPUSH
15343: CALL_OW 88
// end else
15347: GO 15373
// begin Say ( JMM , D1nT-JMM-1 ) ;
15349: LD_EXP 39
15353: PPUSH
15354: LD_STRING D1nT-JMM-1
15356: PPUSH
15357: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15361: LD_EXP 58
15365: PPUSH
15366: LD_STRING D1nT-Pow-1
15368: PPUSH
15369: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15373: LD_INT 35
15375: PPUSH
15376: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15380: LD_EXP 56
15384: PPUSH
15385: CALL_OW 314
15389: NOT
15390: IFFALSE 15373
// ComExitVehicle ( JMM ) ;
15392: LD_EXP 39
15396: PPUSH
15397: CALL_OW 121
// wait ( 3 ) ;
15401: LD_INT 3
15403: PPUSH
15404: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15408: LD_EXP 39
15412: PPUSH
15413: LD_INT 60
15415: PPUSH
15416: LD_INT 94
15418: PPUSH
15419: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15423: LD_EXP 39
15427: PPUSH
15428: LD_EXP 58
15432: PPUSH
15433: CALL_OW 179
// if Joan then
15437: LD_EXP 40
15441: IFFALSE 15495
// begin ComExitVehicle ( Joan ) ;
15443: LD_EXP 40
15447: PPUSH
15448: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15452: LD_EXP 40
15456: PPUSH
15457: LD_INT 35
15459: PPUSH
15460: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15464: LD_EXP 40
15468: PPUSH
15469: LD_INT 65
15471: PPUSH
15472: LD_INT 104
15474: PPUSH
15475: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15479: LD_EXP 40
15483: PPUSH
15484: LD_EXP 39
15488: PPUSH
15489: CALL_OW 179
// end else
15493: GO 15629
// if Lisa and JMMGirl = 2 then
15495: LD_EXP 42
15499: PUSH
15500: LD_EXP 7
15504: PUSH
15505: LD_INT 2
15507: EQUAL
15508: AND
15509: IFFALSE 15563
// begin ComExitVehicle ( Lisa ) ;
15511: LD_EXP 42
15515: PPUSH
15516: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15520: LD_EXP 42
15524: PPUSH
15525: LD_INT 35
15527: PPUSH
15528: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15532: LD_EXP 42
15536: PPUSH
15537: LD_INT 65
15539: PPUSH
15540: LD_INT 104
15542: PPUSH
15543: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15547: LD_EXP 42
15551: PPUSH
15552: LD_EXP 39
15556: PPUSH
15557: CALL_OW 179
// end else
15561: GO 15629
// if Connie and JMMGirl = 3 then
15563: LD_EXP 54
15567: PUSH
15568: LD_EXP 7
15572: PUSH
15573: LD_INT 3
15575: EQUAL
15576: AND
15577: IFFALSE 15629
// begin ComExitVehicle ( Connie ) ;
15579: LD_EXP 54
15583: PPUSH
15584: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15588: LD_EXP 54
15592: PPUSH
15593: LD_INT 35
15595: PPUSH
15596: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15600: LD_EXP 54
15604: PPUSH
15605: LD_INT 65
15607: PPUSH
15608: LD_INT 104
15610: PPUSH
15611: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15615: LD_EXP 54
15619: PPUSH
15620: LD_EXP 39
15624: PPUSH
15625: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15629: LD_INT 35
15631: PPUSH
15632: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15636: LD_EXP 39
15640: PPUSH
15641: LD_EXP 58
15645: PPUSH
15646: CALL_OW 296
15650: PUSH
15651: LD_INT 6
15653: LESS
15654: IFFALSE 15629
// wait ( 0 0$0.5 ) ;
15656: LD_INT 18
15658: PPUSH
15659: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15663: LD_EXP 39
15667: PPUSH
15668: LD_STRING D1-JMM-1
15670: PPUSH
15671: CALL_OW 88
// async ;
15675: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15676: LD_EXP 58
15680: PPUSH
15681: LD_STRING D1-Pow-1
15683: PPUSH
15684: CALL_OW 88
// if not dialogue_skipped then
15688: LD_OWVAR 59
15692: NOT
15693: IFFALSE 15702
// wait ( 0 0$2 ) ;
15695: LD_INT 70
15697: PPUSH
15698: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15702: LD_INT 170
15704: PPUSH
15705: LD_INT 99
15707: PPUSH
15708: LD_INT 1
15710: PPUSH
15711: LD_INT 6
15713: NEG
15714: PPUSH
15715: CALL 107650 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15719: LD_INT 174
15721: PPUSH
15722: LD_INT 115
15724: PPUSH
15725: LD_INT 1
15727: PPUSH
15728: LD_INT 6
15730: NEG
15731: PPUSH
15732: CALL 107650 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15736: LD_INT 169
15738: PPUSH
15739: LD_INT 71
15741: PPUSH
15742: LD_INT 1
15744: PPUSH
15745: LD_INT 6
15747: NEG
15748: PPUSH
15749: CALL 107650 0 4
// if not dialogue_skipped then
15753: LD_OWVAR 59
15757: NOT
15758: IFFALSE 15777
// begin CenterOnXY ( 170 , 99 ) ;
15760: LD_INT 170
15762: PPUSH
15763: LD_INT 99
15765: PPUSH
15766: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15770: LD_INT 80
15772: PPUSH
15773: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15777: LD_INT 75
15779: PPUSH
15780: LD_INT 53
15782: PPUSH
15783: LD_INT 1
15785: PPUSH
15786: LD_INT 9
15788: NEG
15789: PPUSH
15790: CALL 107650 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15794: LD_INT 54
15796: PPUSH
15797: LD_INT 42
15799: PPUSH
15800: LD_INT 1
15802: PPUSH
15803: LD_INT 9
15805: NEG
15806: PPUSH
15807: CALL 107650 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15811: LD_INT 62
15813: PPUSH
15814: LD_INT 51
15816: PPUSH
15817: LD_INT 1
15819: PPUSH
15820: LD_INT 9
15822: NEG
15823: PPUSH
15824: CALL 107650 0 4
// if not dialogue_skipped then
15828: LD_OWVAR 59
15832: NOT
15833: IFFALSE 15852
// begin CenterOnXY ( 75 , 53 ) ;
15835: LD_INT 75
15837: PPUSH
15838: LD_INT 53
15840: PPUSH
15841: CALL_OW 84
// wait ( 0 0$4 ) ;
15845: LD_INT 140
15847: PPUSH
15848: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15852: LD_EXP 58
15856: PPUSH
15857: CALL_OW 87
// if not dialogue_skipped then
15861: LD_OWVAR 59
15865: NOT
15866: IFFALSE 15875
// wait ( 0 0$2 ) ;
15868: LD_INT 70
15870: PPUSH
15871: CALL_OW 67
// sync ;
15875: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15876: LD_EXP 39
15880: PPUSH
15881: LD_STRING D1-JMM-2
15883: PPUSH
15884: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15888: LD_EXP 58
15892: PPUSH
15893: LD_STRING D1-Pow-2
15895: PPUSH
15896: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15900: LD_EXP 39
15904: PPUSH
15905: LD_STRING D1-JMM-3
15907: PPUSH
15908: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15912: LD_EXP 58
15916: PPUSH
15917: LD_STRING D1-Pow-3
15919: PPUSH
15920: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15924: LD_EXP 39
15928: PPUSH
15929: LD_STRING D1-JMM-4
15931: PPUSH
15932: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15936: LD_EXP 58
15940: PPUSH
15941: LD_STRING D1-Pow-4
15943: PPUSH
15944: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15948: LD_EXP 39
15952: PPUSH
15953: LD_STRING D1-JMM-5
15955: PPUSH
15956: CALL_OW 88
// async ;
15960: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15961: LD_EXP 58
15965: PPUSH
15966: LD_STRING D1-Pow-5
15968: PPUSH
15969: CALL_OW 88
// if not dialogue_skipped then
15973: LD_OWVAR 59
15977: NOT
15978: IFFALSE 15987
// wait ( 0 0$3.6 ) ;
15980: LD_INT 126
15982: PPUSH
15983: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15987: LD_INT 134
15989: PPUSH
15990: LD_INT 210
15992: PPUSH
15993: LD_INT 1
15995: PPUSH
15996: LD_INT 11
15998: NEG
15999: PPUSH
16000: CALL 107650 0 4
// if not dialogue_skipped then
16004: LD_OWVAR 59
16008: NOT
16009: IFFALSE 16028
// begin CenterOnXY ( 134 , 210 ) ;
16011: LD_INT 134
16013: PPUSH
16014: LD_INT 210
16016: PPUSH
16017: CALL_OW 84
// wait ( 0 0$2 ) ;
16021: LD_INT 70
16023: PPUSH
16024: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16028: LD_INT 101
16030: PPUSH
16031: LD_INT 159
16033: PPUSH
16034: LD_INT 1
16036: PPUSH
16037: LD_INT 10
16039: NEG
16040: PPUSH
16041: CALL 107650 0 4
// if not dialogue_skipped then
16045: LD_OWVAR 59
16049: NOT
16050: IFFALSE 16069
// begin CenterOnXY ( 101 , 159 ) ;
16052: LD_INT 101
16054: PPUSH
16055: LD_INT 159
16057: PPUSH
16058: CALL_OW 84
// wait ( 0 0$2 ) ;
16062: LD_INT 70
16064: PPUSH
16065: CALL_OW 67
// end ; sync ;
16069: SYNC
// CenterNowOnUnits ( Powell ) ;
16070: LD_EXP 58
16074: PPUSH
16075: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16079: LD_ADDR_VAR 0 6
16083: PUSH
16084: LD_INT 1
16086: PUSH
16087: LD_INT 2
16089: PUSH
16090: LD_INT 3
16092: PUSH
16093: LD_INT 4
16095: PUSH
16096: LD_INT 5
16098: PUSH
16099: LD_INT 6
16101: PUSH
16102: EMPTY
16103: LIST
16104: LIST
16105: LIST
16106: LIST
16107: LIST
16108: LIST
16109: ST_TO_ADDR
// if not dialogue_skipped then
16110: LD_OWVAR 59
16114: NOT
16115: IFFALSE 16284
// begin game_speed := 4 ;
16117: LD_ADDR_OWVAR 65
16121: PUSH
16122: LD_INT 4
16124: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16125: LD_INT 210
16127: PPUSH
16128: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16132: LD_ADDR_VAR 0 7
16136: PUSH
16137: LD_STRING Q1
16139: PPUSH
16140: LD_VAR 0 6
16144: PPUSH
16145: CALL_OW 98
16149: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16150: LD_ADDR_VAR 0 7
16154: PUSH
16155: LD_STRING Q1
16157: PPUSH
16158: LD_VAR 0 6
16162: PPUSH
16163: CALL_OW 98
16167: ST_TO_ADDR
// options = options diff dec ;
16168: LD_ADDR_VAR 0 6
16172: PUSH
16173: LD_VAR 0 6
16177: PUSH
16178: LD_VAR 0 7
16182: DIFF
16183: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16184: LD_VAR 0 7
16188: PPUSH
16189: LD_VAR 0 6
16193: PPUSH
16194: CALL 17756 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16198: LD_VAR 0 7
16202: PUSH
16203: LD_INT 5
16205: PUSH
16206: LD_INT 6
16208: PUSH
16209: EMPTY
16210: LIST
16211: LIST
16212: IN
16213: PUSH
16214: LD_VAR 0 6
16218: PUSH
16219: LD_INT 2
16221: EQUAL
16222: OR
16223: IFFALSE 16150
// if not ( dec in [ 5 , 6 ] ) then
16225: LD_VAR 0 7
16229: PUSH
16230: LD_INT 5
16232: PUSH
16233: LD_INT 6
16235: PUSH
16236: EMPTY
16237: LIST
16238: LIST
16239: IN
16240: NOT
16241: IFFALSE 16284
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16243: LD_ADDR_VAR 0 7
16247: PUSH
16248: LD_STRING Q1a
16250: PPUSH
16251: LD_INT 1
16253: PUSH
16254: LD_INT 2
16256: PUSH
16257: EMPTY
16258: LIST
16259: LIST
16260: PPUSH
16261: CALL_OW 98
16265: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16266: LD_VAR 0 7
16270: PUSH
16271: LD_INT 4
16273: PLUS
16274: PPUSH
16275: LD_VAR 0 6
16279: PPUSH
16280: CALL 17756 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16284: LD_INT 81
16286: PPUSH
16287: LD_INT 127
16289: PPUSH
16290: CALL_OW 84
// amount := 5 ;
16294: LD_ADDR_VAR 0 8
16298: PUSH
16299: LD_INT 5
16301: ST_TO_ADDR
// macmilan_squad := [ ] ;
16302: LD_ADDR_VAR 0 9
16306: PUSH
16307: EMPTY
16308: ST_TO_ADDR
// if vip < amount then
16309: LD_EXP 59
16313: PUSH
16314: LD_VAR 0 8
16318: LESS
16319: IFFALSE 16363
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16321: LD_ADDR_VAR 0 5
16325: PUSH
16326: LD_EXP 59
16330: PUSH
16331: LD_INT 22
16333: PUSH
16334: LD_INT 4
16336: PUSH
16337: EMPTY
16338: LIST
16339: LIST
16340: PUSH
16341: LD_INT 21
16343: PUSH
16344: LD_INT 1
16346: PUSH
16347: EMPTY
16348: LIST
16349: LIST
16350: PUSH
16351: EMPTY
16352: LIST
16353: LIST
16354: PPUSH
16355: CALL_OW 69
16359: UNION
16360: ST_TO_ADDR
16361: GO 16373
// tmp := vip ;
16363: LD_ADDR_VAR 0 5
16367: PUSH
16368: LD_EXP 59
16372: ST_TO_ADDR
// tmp := tmp diff Powell ;
16373: LD_ADDR_VAR 0 5
16377: PUSH
16378: LD_VAR 0 5
16382: PUSH
16383: LD_EXP 58
16387: DIFF
16388: ST_TO_ADDR
// if tmp < amount then
16389: LD_VAR 0 5
16393: PUSH
16394: LD_VAR 0 8
16398: LESS
16399: IFFALSE 16411
// amount := tmp ;
16401: LD_ADDR_VAR 0 8
16405: PUSH
16406: LD_VAR 0 5
16410: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16411: LD_VAR 0 5
16415: PUSH
16416: LD_INT 1
16418: ARRAY
16419: PPUSH
16420: CALL_OW 257
16424: PUSH
16425: LD_INT 2
16427: NONEQUAL
16428: IFFALSE 16490
// begin if IsInUnit ( tmp [ 1 ] ) then
16430: LD_VAR 0 5
16434: PUSH
16435: LD_INT 1
16437: ARRAY
16438: PPUSH
16439: CALL_OW 310
16443: IFFALSE 16458
// ComExitBuilding ( tmp [ 1 ] ) ;
16445: LD_VAR 0 5
16449: PUSH
16450: LD_INT 1
16452: ARRAY
16453: PPUSH
16454: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16458: LD_VAR 0 5
16462: PUSH
16463: LD_INT 1
16465: ARRAY
16466: PPUSH
16467: LD_INT 387
16469: PPUSH
16470: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16474: LD_VAR 0 5
16478: PUSH
16479: LD_INT 1
16481: ARRAY
16482: PPUSH
16483: LD_INT 2
16485: PPUSH
16486: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16490: LD_EXP 39
16494: PPUSH
16495: LD_INT 82
16497: PPUSH
16498: LD_INT 129
16500: PPUSH
16501: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16505: LD_EXP 39
16509: PPUSH
16510: LD_EXP 58
16514: PPUSH
16515: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16519: LD_INT 22
16521: PUSH
16522: LD_INT 1
16524: PUSH
16525: EMPTY
16526: LIST
16527: LIST
16528: PPUSH
16529: CALL_OW 69
16533: PUSH
16534: LD_EXP 39
16538: DIFF
16539: PPUSH
16540: LD_INT 84
16542: PPUSH
16543: LD_INT 128
16545: PPUSH
16546: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16550: LD_INT 22
16552: PUSH
16553: LD_INT 1
16555: PUSH
16556: EMPTY
16557: LIST
16558: LIST
16559: PPUSH
16560: CALL_OW 69
16564: PUSH
16565: LD_EXP 39
16569: DIFF
16570: PPUSH
16571: LD_EXP 39
16575: PPUSH
16576: CALL_OW 179
// for i = 1 to amount do
16580: LD_ADDR_VAR 0 2
16584: PUSH
16585: DOUBLE
16586: LD_INT 1
16588: DEC
16589: ST_TO_ADDR
16590: LD_VAR 0 8
16594: PUSH
16595: FOR_TO
16596: IFFALSE 16764
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16598: LD_ADDR_VAR 0 9
16602: PUSH
16603: LD_VAR 0 9
16607: PUSH
16608: LD_VAR 0 5
16612: PUSH
16613: LD_VAR 0 2
16617: ARRAY
16618: ADD
16619: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16620: LD_VAR 0 5
16624: PUSH
16625: LD_VAR 0 2
16629: ARRAY
16630: PPUSH
16631: CALL_OW 310
16635: IFFALSE 16652
// AddComExitBuilding ( tmp [ i ] ) ;
16637: LD_VAR 0 5
16641: PUSH
16642: LD_VAR 0 2
16646: ARRAY
16647: PPUSH
16648: CALL_OW 182
// if i = 2 and JMMNewVeh then
16652: LD_VAR 0 2
16656: PUSH
16657: LD_INT 2
16659: EQUAL
16660: PUSH
16661: LD_EXP 56
16665: AND
16666: IFFALSE 16724
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16668: LD_VAR 0 5
16672: PUSH
16673: LD_VAR 0 2
16677: ARRAY
16678: PPUSH
16679: LD_EXP 56
16683: PPUSH
16684: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16688: LD_VAR 0 5
16692: PUSH
16693: LD_VAR 0 2
16697: ARRAY
16698: PPUSH
16699: LD_INT 86
16701: PPUSH
16702: LD_INT 133
16704: PPUSH
16705: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16709: LD_VAR 0 5
16713: PUSH
16714: LD_VAR 0 2
16718: ARRAY
16719: PPUSH
16720: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16724: LD_VAR 0 5
16728: PUSH
16729: LD_VAR 0 2
16733: ARRAY
16734: PPUSH
16735: LD_INT 8
16737: PPUSH
16738: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16742: LD_VAR 0 5
16746: PUSH
16747: LD_VAR 0 2
16751: ARRAY
16752: PPUSH
16753: LD_EXP 39
16757: PPUSH
16758: CALL_OW 179
// end ;
16762: GO 16595
16764: POP
16765: POP
// if GirlNewVeh then
16766: LD_EXP 57
16770: IFFALSE 16784
// SetSide ( GirlNewVeh , 4 ) ;
16772: LD_EXP 57
16776: PPUSH
16777: LD_INT 4
16779: PPUSH
16780: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16784: LD_INT 35
16786: PPUSH
16787: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16791: LD_VAR 0 9
16795: PPUSH
16796: LD_INT 95
16798: PUSH
16799: LD_INT 9
16801: PUSH
16802: EMPTY
16803: LIST
16804: LIST
16805: PPUSH
16806: CALL_OW 72
16810: PUSH
16811: LD_INT 0
16813: EQUAL
16814: PUSH
16815: LD_EXP 39
16819: PPUSH
16820: LD_INT 9
16822: PPUSH
16823: CALL_OW 308
16827: NOT
16828: AND
16829: IFFALSE 16784
// wait ( 0 0$2 ) ;
16831: LD_INT 70
16833: PPUSH
16834: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16838: LD_VAR 0 9
16842: PPUSH
16843: LD_INT 1
16845: PPUSH
16846: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16850: LD_INT 21
16852: PUSH
16853: LD_INT 2
16855: PUSH
16856: EMPTY
16857: LIST
16858: LIST
16859: PUSH
16860: LD_INT 92
16862: PUSH
16863: LD_INT 83
16865: PUSH
16866: LD_INT 130
16868: PUSH
16869: LD_INT 10
16871: PUSH
16872: EMPTY
16873: LIST
16874: LIST
16875: LIST
16876: LIST
16877: PUSH
16878: EMPTY
16879: LIST
16880: LIST
16881: PPUSH
16882: CALL_OW 69
16886: PPUSH
16887: LD_INT 1
16889: PPUSH
16890: CALL_OW 235
// Video ( false ) ;
16894: LD_INT 0
16896: PPUSH
16897: CALL 107736 0 1
// ChangeMissionObjectives ( M1 ) ;
16901: LD_STRING M1
16903: PPUSH
16904: CALL_OW 337
// SaveForQuickRestart ;
16908: CALL_OW 22
// missionStart := true ;
16912: LD_ADDR_EXP 13
16916: PUSH
16917: LD_INT 1
16919: ST_TO_ADDR
// missionStage := 2 ;
16920: LD_ADDR_EXP 15
16924: PUSH
16925: LD_INT 2
16927: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16928: LD_INT 105
16930: PPUSH
16931: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16935: LD_ADDR_VAR 0 5
16939: PUSH
16940: LD_INT 22
16942: PUSH
16943: LD_INT 4
16945: PUSH
16946: EMPTY
16947: LIST
16948: LIST
16949: PUSH
16950: LD_INT 21
16952: PUSH
16953: LD_INT 1
16955: PUSH
16956: EMPTY
16957: LIST
16958: LIST
16959: PUSH
16960: EMPTY
16961: LIST
16962: LIST
16963: PPUSH
16964: CALL_OW 69
16968: PUSH
16969: LD_EXP 58
16973: DIFF
16974: ST_TO_ADDR
// if not tmp then
16975: LD_VAR 0 5
16979: NOT
16980: IFFALSE 16995
// tmp := [ Powell ] ;
16982: LD_ADDR_VAR 0 5
16986: PUSH
16987: LD_EXP 58
16991: PUSH
16992: EMPTY
16993: LIST
16994: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16995: LD_ADDR_EXP 102
16999: PUSH
17000: LD_EXP 102
17004: PPUSH
17005: LD_INT 4
17007: PPUSH
17008: LD_INT 22
17010: PUSH
17011: LD_INT 4
17013: PUSH
17014: EMPTY
17015: LIST
17016: LIST
17017: PUSH
17018: LD_INT 23
17020: PUSH
17021: LD_INT 1
17023: PUSH
17024: EMPTY
17025: LIST
17026: LIST
17027: PUSH
17028: LD_INT 3
17030: PUSH
17031: LD_INT 21
17033: PUSH
17034: LD_INT 2
17036: PUSH
17037: EMPTY
17038: LIST
17039: LIST
17040: PUSH
17041: EMPTY
17042: LIST
17043: LIST
17044: PUSH
17045: EMPTY
17046: LIST
17047: LIST
17048: LIST
17049: PPUSH
17050: CALL_OW 69
17054: PUSH
17055: LD_EXP 58
17059: DIFF
17060: PPUSH
17061: CALL_OW 1
17065: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17066: LD_ADDR_VAR 0 4
17070: PUSH
17071: LD_INT 22
17073: PUSH
17074: LD_INT 4
17076: PUSH
17077: EMPTY
17078: LIST
17079: LIST
17080: PUSH
17081: LD_INT 34
17083: PUSH
17084: LD_INT 12
17086: PUSH
17087: EMPTY
17088: LIST
17089: LIST
17090: PUSH
17091: EMPTY
17092: LIST
17093: LIST
17094: PPUSH
17095: CALL_OW 69
17099: PUSH
17100: LD_INT 1
17102: ARRAY
17103: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17104: LD_VAR 0 5
17108: PUSH
17109: LD_INT 1
17111: ARRAY
17112: PPUSH
17113: CALL_OW 310
17117: IFFALSE 17132
// ComExitBuilding ( tmp [ 1 ] ) ;
17119: LD_VAR 0 5
17123: PUSH
17124: LD_INT 1
17126: ARRAY
17127: PPUSH
17128: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17132: LD_VAR 0 5
17136: PUSH
17137: LD_INT 1
17139: ARRAY
17140: PPUSH
17141: LD_VAR 0 4
17145: PPUSH
17146: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17150: LD_VAR 0 5
17154: PUSH
17155: LD_INT 1
17157: ARRAY
17158: PPUSH
17159: LD_INT 80
17161: PPUSH
17162: LD_INT 136
17164: PPUSH
17165: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17169: LD_VAR 0 5
17173: PUSH
17174: LD_INT 1
17176: ARRAY
17177: PPUSH
17178: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17182: LD_VAR 0 5
17186: PUSH
17187: LD_INT 1
17189: ARRAY
17190: PPUSH
17191: LD_INT 59
17193: PPUSH
17194: LD_INT 112
17196: PPUSH
17197: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17201: LD_VAR 0 5
17205: PUSH
17206: LD_INT 1
17208: ARRAY
17209: PPUSH
17210: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17214: LD_EXP 40
17218: PUSH
17219: LD_EXP 40
17223: PPUSH
17224: CALL_OW 255
17228: PUSH
17229: LD_INT 1
17231: EQUAL
17232: AND
17233: IFFALSE 17259
// begin Say ( Joan , D3W-Joan-1 ) ;
17235: LD_EXP 40
17239: PPUSH
17240: LD_STRING D3W-Joan-1
17242: PPUSH
17243: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17247: LD_EXP 39
17251: PPUSH
17252: LD_STRING D3W-JMM-1
17254: PPUSH
17255: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17259: LD_EXP 42
17263: PUSH
17264: LD_EXP 42
17268: PPUSH
17269: CALL_OW 255
17273: PUSH
17274: LD_INT 1
17276: EQUAL
17277: AND
17278: PUSH
17279: LD_EXP 42
17283: PUSH
17284: LD_EXP 59
17288: IN
17289: NOT
17290: AND
17291: IFFALSE 17317
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17293: LD_EXP 42
17297: PPUSH
17298: LD_STRING D3W-Lisa-1
17300: PPUSH
17301: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17305: LD_EXP 39
17309: PPUSH
17310: LD_STRING D3W-JMM-1
17312: PPUSH
17313: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17317: LD_EXP 54
17321: PUSH
17322: LD_EXP 54
17326: PPUSH
17327: CALL_OW 255
17331: PUSH
17332: LD_INT 1
17334: EQUAL
17335: AND
17336: IFFALSE 17362
// begin Say ( Connie , D3W-Con-1 ) ;
17338: LD_EXP 54
17342: PPUSH
17343: LD_STRING D3W-Con-1
17345: PPUSH
17346: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17350: LD_EXP 39
17354: PPUSH
17355: LD_STRING D3W-JMM-1
17357: PPUSH
17358: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17362: LD_EXP 42
17366: PUSH
17367: LD_EXP 59
17371: IN
17372: PUSH
17373: LD_EXP 42
17377: PPUSH
17378: CALL_OW 255
17382: PUSH
17383: LD_INT 1
17385: EQUAL
17386: AND
17387: IFFALSE 17403
// Say ( Lisa , D3nW-Lisa-1 ) else
17389: LD_EXP 42
17393: PPUSH
17394: LD_STRING D3nW-Lisa-1
17396: PPUSH
17397: CALL_OW 88
17401: GO 17647
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17403: LD_EXP 45
17407: PUSH
17408: LD_EXP 59
17412: IN
17413: PUSH
17414: LD_EXP 45
17418: PPUSH
17419: CALL_OW 255
17423: PUSH
17424: LD_INT 1
17426: EQUAL
17427: AND
17428: IFFALSE 17444
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17430: LD_EXP 45
17434: PPUSH
17435: LD_STRING D3nW-Cyrus-1
17437: PPUSH
17438: CALL_OW 88
17442: GO 17647
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17444: LD_EXP 44
17448: PUSH
17449: LD_EXP 59
17453: IN
17454: PUSH
17455: LD_EXP 44
17459: PPUSH
17460: CALL_OW 255
17464: PUSH
17465: LD_INT 1
17467: EQUAL
17468: AND
17469: IFFALSE 17485
// Say ( Bobby , D3nW-Bobby-1 ) else
17471: LD_EXP 44
17475: PPUSH
17476: LD_STRING D3nW-Bobby-1
17478: PPUSH
17479: CALL_OW 88
17483: GO 17647
// if Gary in vip and GetSide ( Gary ) = 1 then
17485: LD_EXP 51
17489: PUSH
17490: LD_EXP 59
17494: IN
17495: PUSH
17496: LD_EXP 51
17500: PPUSH
17501: CALL_OW 255
17505: PUSH
17506: LD_INT 1
17508: EQUAL
17509: AND
17510: IFFALSE 17526
// Say ( Gary , D3nW-Gary-1 ) else
17512: LD_EXP 51
17516: PPUSH
17517: LD_STRING D3nW-Gary-1
17519: PPUSH
17520: CALL_OW 88
17524: GO 17647
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17526: LD_EXP 43
17530: PUSH
17531: LD_EXP 59
17535: IN
17536: PUSH
17537: LD_EXP 43
17541: PPUSH
17542: CALL_OW 255
17546: PUSH
17547: LD_INT 1
17549: EQUAL
17550: AND
17551: IFFALSE 17567
// Say ( Donaldson , D3nW-Don-1 ) else
17553: LD_EXP 43
17557: PPUSH
17558: LD_STRING D3nW-Don-1
17560: PPUSH
17561: CALL_OW 88
17565: GO 17647
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17567: LD_EXP 50
17571: PUSH
17572: LD_EXP 59
17576: IN
17577: PUSH
17578: LD_EXP 50
17582: PPUSH
17583: CALL_OW 255
17587: PUSH
17588: LD_INT 1
17590: EQUAL
17591: AND
17592: IFFALSE 17608
// Say ( Cornel , D3nW-Corn-1 ) else
17594: LD_EXP 50
17598: PPUSH
17599: LD_STRING D3nW-Corn-1
17601: PPUSH
17602: CALL_OW 88
17606: GO 17647
// if Frank in vip and GetSide ( Frank ) = 1 then
17608: LD_EXP 52
17612: PUSH
17613: LD_EXP 59
17617: IN
17618: PUSH
17619: LD_EXP 52
17623: PPUSH
17624: CALL_OW 255
17628: PUSH
17629: LD_INT 1
17631: EQUAL
17632: AND
17633: IFFALSE 17647
// Say ( Frank , D3nW-Frank-1 ) ;
17635: LD_EXP 52
17639: PPUSH
17640: LD_STRING D3nW-Frank-1
17642: PPUSH
17643: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17647: LD_EXP 59
17651: PPUSH
17652: LD_INT 22
17654: PUSH
17655: LD_INT 1
17657: PUSH
17658: EMPTY
17659: LIST
17660: LIST
17661: PPUSH
17662: CALL_OW 72
17666: IFFALSE 17692
// begin Say ( JMM , D3nW-JMM-1 ) ;
17668: LD_EXP 39
17672: PPUSH
17673: LD_STRING D3nW-JMM-1
17675: PPUSH
17676: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17680: LD_EXP 39
17684: PPUSH
17685: LD_STRING D3nW-JMM-1a
17687: PPUSH
17688: CALL_OW 88
// end ; t := 0 0$00 ;
17692: LD_ADDR_VAR 0 3
17696: PUSH
17697: LD_INT 0
17699: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17700: LD_INT 35
17702: PPUSH
17703: CALL_OW 67
// t := t + 0 0$1 ;
17707: LD_ADDR_VAR 0 3
17711: PUSH
17712: LD_VAR 0 3
17716: PUSH
17717: LD_INT 35
17719: PLUS
17720: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17721: LD_INT 59
17723: PPUSH
17724: LD_INT 112
17726: PPUSH
17727: CALL_OW 428
17731: PUSH
17732: LD_VAR 0 3
17736: PUSH
17737: LD_INT 2100
17739: GREATER
17740: OR
17741: IFFALSE 17700
// activeAttacks := true ;
17743: LD_ADDR_EXP 16
17747: PUSH
17748: LD_INT 1
17750: ST_TO_ADDR
// end ;
17751: LD_VAR 0 1
17755: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17756: LD_INT 0
17758: PPUSH
// case question of 1 :
17759: LD_VAR 0 1
17763: PUSH
17764: LD_INT 1
17766: DOUBLE
17767: EQUAL
17768: IFTRUE 17772
17770: GO 17823
17772: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17773: LD_EXP 39
17777: PPUSH
17778: LD_STRING D2Mot-JMM-1
17780: PPUSH
17781: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17785: LD_EXP 58
17789: PPUSH
17790: LD_STRING D2Mot-Pow-1
17792: PPUSH
17793: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17797: LD_EXP 39
17801: PPUSH
17802: LD_STRING D2Mot-JMM-2
17804: PPUSH
17805: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17809: LD_EXP 58
17813: PPUSH
17814: LD_STRING D2Mot-Pow-2
17816: PPUSH
17817: CALL_OW 88
// end ; 2 :
17821: GO 18174
17823: LD_INT 2
17825: DOUBLE
17826: EQUAL
17827: IFTRUE 17831
17829: GO 17907
17831: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17832: LD_EXP 39
17836: PPUSH
17837: LD_STRING D2Rus-JMM-1
17839: PPUSH
17840: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17844: LD_EXP 58
17848: PPUSH
17849: LD_STRING D2Rus-Pow-1
17851: PPUSH
17852: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17856: LD_EXP 39
17860: PPUSH
17861: LD_STRING D2Rus-JMM-2
17863: PPUSH
17864: CALL_OW 88
// if not ( 3 in list_of_q ) then
17868: LD_INT 3
17870: PUSH
17871: LD_VAR 0 2
17875: IN
17876: NOT
17877: IFFALSE 17893
// Say ( Powell , D2Rus-Pow-2 ) else
17879: LD_EXP 58
17883: PPUSH
17884: LD_STRING D2Rus-Pow-2
17886: PPUSH
17887: CALL_OW 88
17891: GO 17905
// Say ( Powell , D2Rus-Pow-2a ) ;
17893: LD_EXP 58
17897: PPUSH
17898: LD_STRING D2Rus-Pow-2a
17900: PPUSH
17901: CALL_OW 88
// end ; 3 :
17905: GO 18174
17907: LD_INT 3
17909: DOUBLE
17910: EQUAL
17911: IFTRUE 17915
17913: GO 18000
17915: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17916: LD_EXP 39
17920: PPUSH
17921: LD_STRING D2Leg-JMM-1
17923: PPUSH
17924: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17928: LD_EXP 58
17932: PPUSH
17933: LD_STRING D2Leg-Pow-1
17935: PPUSH
17936: CALL_OW 88
// if 2 in list_of_q then
17940: LD_INT 2
17942: PUSH
17943: LD_VAR 0 2
17947: IN
17948: IFFALSE 17974
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17950: LD_EXP 39
17954: PPUSH
17955: LD_STRING D2Leg-JMM-2
17957: PPUSH
17958: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17962: LD_EXP 58
17966: PPUSH
17967: LD_STRING D2Leg-Pow-2
17969: PPUSH
17970: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17974: LD_EXP 39
17978: PPUSH
17979: LD_STRING D2Leg-JMM-3
17981: PPUSH
17982: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17986: LD_EXP 58
17990: PPUSH
17991: LD_STRING D2Leg-Pow-3
17993: PPUSH
17994: CALL_OW 88
// end ; 4 :
17998: GO 18174
18000: LD_INT 4
18002: DOUBLE
18003: EQUAL
18004: IFTRUE 18008
18006: GO 18083
18008: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18009: LD_EXP 39
18013: PPUSH
18014: LD_STRING D2Ar-JMM-1
18016: PPUSH
18017: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18021: LD_EXP 58
18025: PPUSH
18026: LD_STRING D2Ar-Pow-1
18028: PPUSH
18029: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18033: LD_EXP 39
18037: PPUSH
18038: LD_STRING D2Ar-JMM-2
18040: PPUSH
18041: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18045: LD_EXP 58
18049: PPUSH
18050: LD_STRING D2Ar-Pow-2
18052: PPUSH
18053: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18057: LD_EXP 39
18061: PPUSH
18062: LD_STRING D2Ar-JMM-3
18064: PPUSH
18065: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18069: LD_EXP 58
18073: PPUSH
18074: LD_STRING D2Ar-Pow-3
18076: PPUSH
18077: CALL_OW 88
// end ; 5 :
18081: GO 18174
18083: LD_INT 5
18085: DOUBLE
18086: EQUAL
18087: IFTRUE 18091
18089: GO 18106
18091: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18092: LD_EXP 39
18096: PPUSH
18097: LD_STRING D2Conf-JMM-1
18099: PPUSH
18100: CALL_OW 88
18104: GO 18174
18106: LD_INT 6
18108: DOUBLE
18109: EQUAL
18110: IFTRUE 18114
18112: GO 18173
18114: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18115: LD_EXP 39
18119: PPUSH
18120: LD_STRING D2Com-JMM-1
18122: PPUSH
18123: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18127: LD_EXP 58
18131: PPUSH
18132: LD_STRING D2Com-Pow-1
18134: PPUSH
18135: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18139: LD_EXP 39
18143: PPUSH
18144: LD_STRING D2Com-JMM-2
18146: PPUSH
18147: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18151: LD_EXP 58
18155: PPUSH
18156: LD_STRING D2Com-Pow-2
18158: PPUSH
18159: CALL_OW 88
// powellAngerQuery := true ;
18163: LD_ADDR_EXP 36
18167: PUSH
18168: LD_INT 1
18170: ST_TO_ADDR
// end ; end ;
18171: GO 18174
18173: POP
// end ;
18174: LD_VAR 0 3
18178: RET
// every 0 0$5 trigger missionStart do var tmp ;
18179: LD_EXP 13
18183: IFFALSE 18466
18185: GO 18187
18187: DISABLE
18188: LD_INT 0
18190: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18191: LD_INT 35
18193: PPUSH
18194: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18198: LD_INT 14
18200: PPUSH
18201: LD_INT 22
18203: PUSH
18204: LD_INT 1
18206: PUSH
18207: EMPTY
18208: LIST
18209: LIST
18210: PPUSH
18211: CALL_OW 70
18215: PUSH
18216: LD_EXP 15
18220: PUSH
18221: LD_INT 2
18223: PUSH
18224: LD_INT 3
18226: PUSH
18227: LD_INT 4
18229: PUSH
18230: LD_INT 5
18232: PUSH
18233: EMPTY
18234: LIST
18235: LIST
18236: LIST
18237: LIST
18238: IN
18239: AND
18240: IFFALSE 18456
// begin powellAnger := powellAnger + 1 ;
18242: LD_ADDR_EXP 17
18246: PUSH
18247: LD_EXP 17
18251: PUSH
18252: LD_INT 1
18254: PLUS
18255: ST_TO_ADDR
// Video ( true ) ;
18256: LD_INT 1
18258: PPUSH
18259: CALL 107736 0 1
// CenterNowOnUnits ( tmp ) ;
18263: LD_VAR 0 1
18267: PPUSH
18268: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18272: LD_INT 14
18274: PPUSH
18275: LD_INT 22
18277: PUSH
18278: LD_INT 1
18280: PUSH
18281: EMPTY
18282: LIST
18283: LIST
18284: PPUSH
18285: CALL_OW 70
18289: PPUSH
18290: LD_INT 86
18292: PPUSH
18293: LD_INT 133
18295: PPUSH
18296: CALL_OW 111
// async ;
18300: ASYNC
// case powellAnger of 1 :
18301: LD_EXP 17
18305: PUSH
18306: LD_INT 1
18308: DOUBLE
18309: EQUAL
18310: IFTRUE 18314
18312: GO 18329
18314: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18315: LD_EXP 58
18319: PPUSH
18320: LD_STRING DBack1-Pow-1
18322: PPUSH
18323: CALL_OW 88
18327: GO 18376
18329: LD_INT 2
18331: DOUBLE
18332: EQUAL
18333: IFTRUE 18337
18335: GO 18352
18337: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18338: LD_EXP 58
18342: PPUSH
18343: LD_STRING DBack2-Pow-1
18345: PPUSH
18346: CALL_OW 88
18350: GO 18376
18352: LD_INT 3
18354: DOUBLE
18355: EQUAL
18356: IFTRUE 18360
18358: GO 18375
18360: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18361: LD_EXP 58
18365: PPUSH
18366: LD_STRING DBack3-Pow-1
18368: PPUSH
18369: CALL_OW 88
18373: GO 18376
18375: POP
// sync ;
18376: SYNC
// repeat wait ( 0 0$1 ) ;
18377: LD_INT 35
18379: PPUSH
18380: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18384: LD_INT 14
18386: PPUSH
18387: LD_INT 22
18389: PUSH
18390: LD_INT 1
18392: PUSH
18393: EMPTY
18394: LIST
18395: LIST
18396: PPUSH
18397: CALL_OW 70
18401: PPUSH
18402: LD_INT 86
18404: PPUSH
18405: LD_INT 133
18407: PPUSH
18408: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18412: LD_INT 14
18414: PPUSH
18415: LD_INT 22
18417: PUSH
18418: LD_INT 1
18420: PUSH
18421: EMPTY
18422: LIST
18423: LIST
18424: PPUSH
18425: CALL_OW 70
18429: NOT
18430: IFFALSE 18377
// if powellAnger >= 3 then
18432: LD_EXP 17
18436: PUSH
18437: LD_INT 3
18439: GREATEREQUAL
18440: IFFALSE 18449
// YouLost ( Dismissed ) ;
18442: LD_STRING Dismissed
18444: PPUSH
18445: CALL_OW 104
// Video ( false ) ;
18449: LD_INT 0
18451: PPUSH
18452: CALL 107736 0 1
// end ; until missionStage > 5 ;
18456: LD_EXP 15
18460: PUSH
18461: LD_INT 5
18463: GREATER
18464: IFFALSE 18191
// end ;
18466: PPOPN 1
18468: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18469: LD_EXP 13
18473: PUSH
18474: LD_INT 22
18476: PUSH
18477: LD_INT 4
18479: PUSH
18480: EMPTY
18481: LIST
18482: LIST
18483: PUSH
18484: LD_INT 21
18486: PUSH
18487: LD_INT 2
18489: PUSH
18490: EMPTY
18491: LIST
18492: LIST
18493: PUSH
18494: EMPTY
18495: LIST
18496: LIST
18497: PPUSH
18498: CALL_OW 69
18502: PUSH
18503: LD_INT 4
18505: GREATEREQUAL
18506: AND
18507: PUSH
18508: LD_EXP 15
18512: PUSH
18513: LD_INT 2
18515: EQUAL
18516: AND
18517: IFFALSE 20340
18519: GO 18521
18521: DISABLE
18522: LD_INT 0
18524: PPUSH
18525: PPUSH
18526: PPUSH
18527: PPUSH
18528: PPUSH
18529: PPUSH
18530: PPUSH
18531: PPUSH
// begin missionStage := 3 ;
18532: LD_ADDR_EXP 15
18536: PUSH
18537: LD_INT 3
18539: ST_TO_ADDR
// retreat := false ;
18540: LD_ADDR_VAR 0 4
18544: PUSH
18545: LD_INT 0
18547: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18548: LD_ADDR_VAR 0 5
18552: PUSH
18553: LD_INT 22
18555: PUSH
18556: LD_INT 4
18558: PUSH
18559: EMPTY
18560: LIST
18561: LIST
18562: PUSH
18563: LD_INT 30
18565: PUSH
18566: LD_INT 4
18568: PUSH
18569: EMPTY
18570: LIST
18571: LIST
18572: PUSH
18573: EMPTY
18574: LIST
18575: LIST
18576: PPUSH
18577: CALL_OW 69
18581: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18582: LD_ADDR_VAR 0 6
18586: PUSH
18587: LD_INT 22
18589: PUSH
18590: LD_INT 4
18592: PUSH
18593: EMPTY
18594: LIST
18595: LIST
18596: PUSH
18597: LD_INT 30
18599: PUSH
18600: LD_INT 5
18602: PUSH
18603: EMPTY
18604: LIST
18605: LIST
18606: PUSH
18607: EMPTY
18608: LIST
18609: LIST
18610: PPUSH
18611: CALL_OW 69
18615: ST_TO_ADDR
// if not bar then
18616: LD_VAR 0 6
18620: NOT
18621: IFFALSE 18674
// begin repeat wait ( 0 0$1 ) ;
18623: LD_INT 35
18625: PPUSH
18626: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18630: LD_INT 22
18632: PUSH
18633: LD_INT 4
18635: PUSH
18636: EMPTY
18637: LIST
18638: LIST
18639: PUSH
18640: LD_INT 3
18642: PUSH
18643: LD_INT 57
18645: PUSH
18646: EMPTY
18647: LIST
18648: PUSH
18649: EMPTY
18650: LIST
18651: LIST
18652: PUSH
18653: LD_INT 30
18655: PUSH
18656: LD_INT 5
18658: PUSH
18659: EMPTY
18660: LIST
18661: LIST
18662: PUSH
18663: EMPTY
18664: LIST
18665: LIST
18666: LIST
18667: PPUSH
18668: CALL_OW 69
18672: IFFALSE 18623
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18674: LD_ADDR_VAR 0 6
18678: PUSH
18679: LD_INT 22
18681: PUSH
18682: LD_INT 4
18684: PUSH
18685: EMPTY
18686: LIST
18687: LIST
18688: PUSH
18689: LD_INT 30
18691: PUSH
18692: LD_INT 5
18694: PUSH
18695: EMPTY
18696: LIST
18697: LIST
18698: PUSH
18699: EMPTY
18700: LIST
18701: LIST
18702: PPUSH
18703: CALL_OW 69
18707: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18708: LD_INT 35
18710: PPUSH
18711: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18715: LD_EXP 121
18719: PUSH
18720: LD_INT 4
18722: ARRAY
18723: PUSH
18724: LD_INT 4
18726: GREATEREQUAL
18727: IFFALSE 18708
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18729: LD_ADDR_VAR 0 2
18733: PUSH
18734: LD_INT 22
18736: PUSH
18737: LD_INT 4
18739: PUSH
18740: EMPTY
18741: LIST
18742: LIST
18743: PUSH
18744: LD_INT 2
18746: PUSH
18747: LD_INT 25
18749: PUSH
18750: LD_INT 1
18752: PUSH
18753: EMPTY
18754: LIST
18755: LIST
18756: PUSH
18757: LD_INT 25
18759: PUSH
18760: LD_INT 2
18762: PUSH
18763: EMPTY
18764: LIST
18765: LIST
18766: PUSH
18767: LD_INT 25
18769: PUSH
18770: LD_INT 3
18772: PUSH
18773: EMPTY
18774: LIST
18775: LIST
18776: PUSH
18777: LD_INT 25
18779: PUSH
18780: LD_INT 4
18782: PUSH
18783: EMPTY
18784: LIST
18785: LIST
18786: PUSH
18787: LD_INT 25
18789: PUSH
18790: LD_INT 5
18792: PUSH
18793: EMPTY
18794: LIST
18795: LIST
18796: PUSH
18797: EMPTY
18798: LIST
18799: LIST
18800: LIST
18801: LIST
18802: LIST
18803: LIST
18804: PUSH
18805: EMPTY
18806: LIST
18807: LIST
18808: PPUSH
18809: CALL_OW 69
18813: PUSH
18814: LD_EXP 58
18818: PUSH
18819: LD_EXP 59
18823: ADD
18824: DIFF
18825: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18826: LD_ADDR_VAR 0 3
18830: PUSH
18831: LD_VAR 0 2
18835: PPUSH
18836: LD_INT 26
18838: PUSH
18839: LD_INT 1
18841: PUSH
18842: EMPTY
18843: LIST
18844: LIST
18845: PPUSH
18846: CALL_OW 72
18850: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18851: LD_ADDR_VAR 0 2
18855: PUSH
18856: LD_VAR 0 2
18860: PUSH
18861: LD_VAR 0 3
18865: DIFF
18866: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18867: LD_ADDR_VAR 0 2
18871: PUSH
18872: LD_VAR 0 2
18876: PPUSH
18877: LD_INT 1
18879: PPUSH
18880: CALL 106389 0 2
18884: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18885: LD_ADDR_VAR 0 3
18889: PUSH
18890: LD_VAR 0 3
18894: PPUSH
18895: LD_INT 1
18897: PPUSH
18898: CALL 106389 0 2
18902: ST_TO_ADDR
// for i = 1 to 4 do
18903: LD_ADDR_VAR 0 1
18907: PUSH
18908: DOUBLE
18909: LD_INT 1
18911: DEC
18912: ST_TO_ADDR
18913: LD_INT 4
18915: PUSH
18916: FOR_TO
18917: IFFALSE 19083
// begin if tmp2 then
18919: LD_VAR 0 3
18923: IFFALSE 19004
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18925: LD_ADDR_EXP 18
18929: PUSH
18930: LD_EXP 18
18934: PPUSH
18935: LD_INT 1
18937: PPUSH
18938: LD_EXP 18
18942: PUSH
18943: LD_INT 1
18945: ARRAY
18946: PUSH
18947: LD_VAR 0 3
18951: PUSH
18952: LD_VAR 0 3
18956: ARRAY
18957: ADD
18958: PPUSH
18959: CALL_OW 1
18963: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18964: LD_VAR 0 3
18968: PUSH
18969: LD_VAR 0 3
18973: ARRAY
18974: PPUSH
18975: LD_INT 1
18977: PPUSH
18978: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18982: LD_ADDR_VAR 0 3
18986: PUSH
18987: LD_VAR 0 3
18991: PPUSH
18992: LD_VAR 0 3
18996: PPUSH
18997: CALL_OW 3
19001: ST_TO_ADDR
// end else
19002: GO 19081
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19004: LD_ADDR_EXP 18
19008: PUSH
19009: LD_EXP 18
19013: PPUSH
19014: LD_INT 1
19016: PPUSH
19017: LD_EXP 18
19021: PUSH
19022: LD_INT 1
19024: ARRAY
19025: PUSH
19026: LD_VAR 0 2
19030: PUSH
19031: LD_VAR 0 2
19035: ARRAY
19036: ADD
19037: PPUSH
19038: CALL_OW 1
19042: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19043: LD_VAR 0 2
19047: PUSH
19048: LD_VAR 0 2
19052: ARRAY
19053: PPUSH
19054: LD_INT 1
19056: PPUSH
19057: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19061: LD_ADDR_VAR 0 2
19065: PUSH
19066: LD_VAR 0 2
19070: PPUSH
19071: LD_VAR 0 2
19075: PPUSH
19076: CALL_OW 3
19080: ST_TO_ADDR
// end ; end ;
19081: GO 18916
19083: POP
19084: POP
// if tmp2 then
19085: LD_VAR 0 3
19089: IFFALSE 19107
// tmp := tmp union tmp2 ;
19091: LD_ADDR_VAR 0 2
19095: PUSH
19096: LD_VAR 0 2
19100: PUSH
19101: LD_VAR 0 3
19105: UNION
19106: ST_TO_ADDR
// for i = 1 to 4 do
19107: LD_ADDR_VAR 0 1
19111: PUSH
19112: DOUBLE
19113: LD_INT 1
19115: DEC
19116: ST_TO_ADDR
19117: LD_INT 4
19119: PUSH
19120: FOR_TO
19121: IFFALSE 19170
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19123: LD_ADDR_EXP 18
19127: PUSH
19128: LD_EXP 18
19132: PPUSH
19133: LD_INT 2
19135: PPUSH
19136: LD_EXP 18
19140: PUSH
19141: LD_INT 2
19143: ARRAY
19144: PUSH
19145: LD_VAR 0 2
19149: PUSH
19150: LD_VAR 0 2
19154: PUSH
19155: LD_VAR 0 1
19159: MINUS
19160: ARRAY
19161: ADD
19162: PPUSH
19163: CALL_OW 1
19167: ST_TO_ADDR
19168: GO 19120
19170: POP
19171: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19172: LD_ADDR_EXP 102
19176: PUSH
19177: LD_EXP 102
19181: PPUSH
19182: LD_INT 4
19184: PPUSH
19185: LD_EXP 102
19189: PUSH
19190: LD_INT 4
19192: ARRAY
19193: PUSH
19194: LD_EXP 18
19198: PUSH
19199: LD_INT 1
19201: ARRAY
19202: DIFF
19203: PPUSH
19204: CALL_OW 1
19208: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19209: LD_VAR 0 5
19213: PUSH
19214: LD_INT 1
19216: ARRAY
19217: PPUSH
19218: CALL_OW 313
19222: IFFALSE 19277
// begin for i in UnitsInside ( arm [ 1 ] ) do
19224: LD_ADDR_VAR 0 1
19228: PUSH
19229: LD_VAR 0 5
19233: PUSH
19234: LD_INT 1
19236: ARRAY
19237: PPUSH
19238: CALL_OW 313
19242: PUSH
19243: FOR_IN
19244: IFFALSE 19275
// begin ComExitBuilding ( i ) ;
19246: LD_VAR 0 1
19250: PPUSH
19251: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19255: LD_VAR 0 1
19259: PPUSH
19260: LD_VAR 0 6
19264: PUSH
19265: LD_INT 1
19267: ARRAY
19268: PPUSH
19269: CALL_OW 180
// end ;
19273: GO 19243
19275: POP
19276: POP
// end ; wait ( 0 0$3 ) ;
19277: LD_INT 105
19279: PPUSH
19280: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19284: LD_ADDR_VAR 0 1
19288: PUSH
19289: LD_EXP 18
19293: PUSH
19294: LD_INT 1
19296: ARRAY
19297: PUSH
19298: FOR_IN
19299: IFFALSE 19406
// begin if IsInUnit ( i ) then
19301: LD_VAR 0 1
19305: PPUSH
19306: CALL_OW 310
19310: IFFALSE 19321
// ComExitBuilding ( i ) ;
19312: LD_VAR 0 1
19316: PPUSH
19317: CALL_OW 122
// if GetClass ( i ) <> 1 then
19321: LD_VAR 0 1
19325: PPUSH
19326: CALL_OW 257
19330: PUSH
19331: LD_INT 1
19333: NONEQUAL
19334: IFFALSE 19375
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19336: LD_VAR 0 1
19340: PPUSH
19341: LD_VAR 0 5
19345: PUSH
19346: LD_INT 1
19348: ARRAY
19349: PPUSH
19350: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19354: LD_VAR 0 1
19358: PPUSH
19359: LD_INT 1
19361: PPUSH
19362: CALL_OW 183
// AddComExitBuilding ( i ) ;
19366: LD_VAR 0 1
19370: PPUSH
19371: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19375: LD_VAR 0 1
19379: PPUSH
19380: LD_INT 60
19382: PPUSH
19383: LD_INT 94
19385: PPUSH
19386: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19390: LD_VAR 0 1
19394: PPUSH
19395: LD_EXP 58
19399: PPUSH
19400: CALL_OW 179
// end ;
19404: GO 19298
19406: POP
19407: POP
// wait ( 0 0$15 ) ;
19408: LD_INT 525
19410: PPUSH
19411: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19415: LD_EXP 58
19419: PPUSH
19420: LD_STRING D4-Pow-1
19422: PPUSH
19423: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19427: LD_ADDR_VAR 0 2
19431: PUSH
19432: LD_EXP 18
19436: PUSH
19437: LD_INT 1
19439: ARRAY
19440: PPUSH
19441: LD_INT 26
19443: PUSH
19444: LD_INT 1
19446: PUSH
19447: EMPTY
19448: LIST
19449: LIST
19450: PPUSH
19451: CALL_OW 72
19455: ST_TO_ADDR
// if tmp then
19456: LD_VAR 0 2
19460: IFFALSE 19478
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19462: LD_VAR 0 2
19466: PUSH
19467: LD_INT 1
19469: ARRAY
19470: PPUSH
19471: LD_STRING D4-Sol1-1
19473: PPUSH
19474: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19478: LD_EXP 58
19482: PPUSH
19483: LD_STRING D4-Pow-2
19485: PPUSH
19486: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19490: LD_ADDR_VAR 0 1
19494: PUSH
19495: DOUBLE
19496: LD_INT 1
19498: DEC
19499: ST_TO_ADDR
19500: LD_EXP 18
19504: PUSH
19505: LD_INT 1
19507: ARRAY
19508: PUSH
19509: FOR_TO
19510: IFFALSE 19603
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19512: LD_EXP 18
19516: PUSH
19517: LD_INT 1
19519: ARRAY
19520: PUSH
19521: LD_VAR 0 1
19525: ARRAY
19526: PPUSH
19527: LD_EXP 121
19531: PUSH
19532: LD_INT 4
19534: ARRAY
19535: PUSH
19536: LD_INT 1
19538: ARRAY
19539: PPUSH
19540: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19544: LD_ADDR_EXP 121
19548: PUSH
19549: LD_EXP 121
19553: PPUSH
19554: LD_INT 4
19556: PPUSH
19557: LD_EXP 121
19561: PUSH
19562: LD_INT 4
19564: ARRAY
19565: PPUSH
19566: LD_INT 1
19568: PPUSH
19569: CALL_OW 3
19573: PPUSH
19574: CALL_OW 1
19578: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19579: LD_INT 8
19581: PPUSH
19582: LD_EXP 18
19586: PUSH
19587: LD_INT 1
19589: ARRAY
19590: PUSH
19591: LD_VAR 0 1
19595: ARRAY
19596: PPUSH
19597: CALL_OW 471
// end ;
19601: GO 19509
19603: POP
19604: POP
// repeat wait ( 0 0$1 ) ;
19605: LD_INT 35
19607: PPUSH
19608: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19612: LD_EXP 18
19616: PUSH
19617: LD_INT 1
19619: ARRAY
19620: PPUSH
19621: LD_INT 55
19623: PUSH
19624: EMPTY
19625: LIST
19626: PPUSH
19627: CALL_OW 72
19631: PUSH
19632: LD_INT 4
19634: GREATEREQUAL
19635: IFFALSE 19605
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19637: LD_EXP 18
19641: PUSH
19642: LD_INT 1
19644: ARRAY
19645: PPUSH
19646: LD_INT 69
19648: PPUSH
19649: LD_INT 94
19651: PPUSH
19652: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19656: LD_EXP 18
19660: PUSH
19661: LD_INT 1
19663: ARRAY
19664: PPUSH
19665: LD_INT 82
19667: PPUSH
19668: LD_INT 83
19670: PPUSH
19671: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19675: LD_EXP 18
19679: PUSH
19680: LD_INT 1
19682: ARRAY
19683: PPUSH
19684: LD_INT 77
19686: PPUSH
19687: LD_INT 69
19689: PPUSH
19690: CALL_OW 174
// repeat wait ( 3 ) ;
19694: LD_INT 3
19696: PPUSH
19697: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19701: LD_ADDR_VAR 0 1
19705: PUSH
19706: LD_EXP 18
19710: PUSH
19711: LD_INT 1
19713: ARRAY
19714: PUSH
19715: FOR_IN
19716: IFFALSE 19852
// begin if GetLives ( i ) < 990 then
19718: LD_VAR 0 1
19722: PPUSH
19723: CALL_OW 256
19727: PUSH
19728: LD_INT 990
19730: LESS
19731: IFFALSE 19745
// SetLives ( i , 1000 ) ;
19733: LD_VAR 0 1
19737: PPUSH
19738: LD_INT 1000
19740: PPUSH
19741: CALL_OW 234
// if not IsInUnit ( i ) then
19745: LD_VAR 0 1
19749: PPUSH
19750: CALL_OW 310
19754: NOT
19755: IFFALSE 19850
// begin if not HasTask ( i ) then
19757: LD_VAR 0 1
19761: PPUSH
19762: CALL_OW 314
19766: NOT
19767: IFFALSE 19784
// ComMoveXY ( i , 64 , 93 ) ;
19769: LD_VAR 0 1
19773: PPUSH
19774: LD_INT 64
19776: PPUSH
19777: LD_INT 93
19779: PPUSH
19780: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19784: LD_VAR 0 4
19788: NOT
19789: PUSH
19790: LD_VAR 0 1
19794: PPUSH
19795: CALL_OW 258
19799: PUSH
19800: LD_INT 1
19802: EQUAL
19803: AND
19804: IFFALSE 19850
// begin retreat := true ;
19806: LD_ADDR_VAR 0 4
19810: PUSH
19811: LD_INT 1
19813: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19814: LD_VAR 0 1
19818: PPUSH
19819: LD_INT 2
19821: PPUSH
19822: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19826: LD_VAR 0 1
19830: PPUSH
19831: LD_STRING D4a-Sol1-1
19833: PPUSH
19834: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19838: LD_EXP 58
19842: PPUSH
19843: LD_STRING D4a-Pow-1
19845: PPUSH
19846: CALL_OW 88
// end ; end ; end ;
19850: GO 19715
19852: POP
19853: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19854: LD_EXP 18
19858: PUSH
19859: LD_INT 1
19861: ARRAY
19862: PPUSH
19863: LD_INT 95
19865: PUSH
19866: LD_INT 9
19868: PUSH
19869: EMPTY
19870: LIST
19871: LIST
19872: PUSH
19873: LD_INT 3
19875: PUSH
19876: LD_INT 55
19878: PUSH
19879: EMPTY
19880: LIST
19881: PUSH
19882: EMPTY
19883: LIST
19884: LIST
19885: PUSH
19886: EMPTY
19887: LIST
19888: LIST
19889: PPUSH
19890: CALL_OW 72
19894: PUSH
19895: LD_INT 4
19897: GREATEREQUAL
19898: IFFALSE 19694
// for i in powellSquadAttack [ 1 ] do
19900: LD_ADDR_VAR 0 1
19904: PUSH
19905: LD_EXP 18
19909: PUSH
19910: LD_INT 1
19912: ARRAY
19913: PUSH
19914: FOR_IN
19915: IFFALSE 20051
// begin if GetTag ( i ) = 2 then
19917: LD_VAR 0 1
19921: PPUSH
19922: CALL_OW 110
19926: PUSH
19927: LD_INT 2
19929: EQUAL
19930: IFFALSE 19992
// begin ComMoveXY ( i , 60 , 94 ) ;
19932: LD_VAR 0 1
19936: PPUSH
19937: LD_INT 60
19939: PPUSH
19940: LD_INT 94
19942: PPUSH
19943: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19947: LD_VAR 0 1
19951: PPUSH
19952: LD_EXP 58
19956: PPUSH
19957: CALL_OW 179
// wait ( 0 0$3 ) ;
19961: LD_INT 105
19963: PPUSH
19964: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19968: LD_VAR 0 1
19972: PPUSH
19973: LD_STRING D4a-Sol1-2
19975: PPUSH
19976: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19980: LD_EXP 58
19984: PPUSH
19985: LD_STRING D4a-Pow-2
19987: PPUSH
19988: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19992: LD_VAR 0 1
19996: PPUSH
19997: LD_INT 0
19999: PPUSH
20000: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20004: LD_ADDR_EXP 102
20008: PUSH
20009: LD_EXP 102
20013: PPUSH
20014: LD_INT 4
20016: PPUSH
20017: LD_EXP 102
20021: PUSH
20022: LD_INT 4
20024: ARRAY
20025: PUSH
20026: LD_VAR 0 1
20030: UNION
20031: PPUSH
20032: CALL_OW 1
20036: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20037: LD_INT 8
20039: PPUSH
20040: LD_VAR 0 1
20044: PPUSH
20045: CALL_OW 472
// end ;
20049: GO 19914
20051: POP
20052: POP
// wait ( 4 4$00 ) ;
20053: LD_INT 8400
20055: PPUSH
20056: CALL_OW 67
// uc_side := 6 ;
20060: LD_ADDR_OWVAR 20
20064: PUSH
20065: LD_INT 6
20067: ST_TO_ADDR
// uc_nation := 3 ;
20068: LD_ADDR_OWVAR 21
20072: PUSH
20073: LD_INT 3
20075: ST_TO_ADDR
// ru := [ ] ;
20076: LD_ADDR_VAR 0 7
20080: PUSH
20081: EMPTY
20082: ST_TO_ADDR
// for i = 1 to 4 do
20083: LD_ADDR_VAR 0 1
20087: PUSH
20088: DOUBLE
20089: LD_INT 1
20091: DEC
20092: ST_TO_ADDR
20093: LD_INT 4
20095: PUSH
20096: FOR_TO
20097: IFFALSE 20198
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20099: LD_INT 22
20101: PPUSH
20102: LD_INT 1
20104: PPUSH
20105: LD_INT 3
20107: PPUSH
20108: LD_INT 43
20110: PUSH
20111: LD_INT 44
20113: PUSH
20114: EMPTY
20115: LIST
20116: LIST
20117: PUSH
20118: LD_INT 1
20120: PPUSH
20121: LD_INT 2
20123: PPUSH
20124: CALL_OW 12
20128: ARRAY
20129: PPUSH
20130: LD_INT 89
20132: PPUSH
20133: CALL 72009 0 5
// un := CreateVehicle ;
20137: LD_ADDR_VAR 0 8
20141: PUSH
20142: CALL_OW 45
20146: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20147: LD_VAR 0 8
20151: PPUSH
20152: LD_INT 4
20154: PPUSH
20155: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20159: LD_VAR 0 8
20163: PPUSH
20164: LD_INT 136
20166: PPUSH
20167: LD_INT 90
20169: PPUSH
20170: LD_INT 8
20172: PPUSH
20173: LD_INT 0
20175: PPUSH
20176: CALL_OW 50
// ru := ru ^ un ;
20180: LD_ADDR_VAR 0 7
20184: PUSH
20185: LD_VAR 0 7
20189: PUSH
20190: LD_VAR 0 8
20194: ADD
20195: ST_TO_ADDR
// end ;
20196: GO 20096
20198: POP
20199: POP
// if ru then
20200: LD_VAR 0 7
20204: IFFALSE 20221
// ComAgressiveMove ( ru , 80 , 92 ) ;
20206: LD_VAR 0 7
20210: PPUSH
20211: LD_INT 80
20213: PPUSH
20214: LD_INT 92
20216: PPUSH
20217: CALL_OW 114
// wait ( 8 8$00 ) ;
20221: LD_INT 16800
20223: PPUSH
20224: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20228: LD_INT 4
20230: PPUSH
20231: LD_INT 3
20233: PUSH
20234: LD_INT 1
20236: PUSH
20237: LD_INT 1
20239: PUSH
20240: LD_INT 5
20242: PUSH
20243: EMPTY
20244: LIST
20245: LIST
20246: LIST
20247: LIST
20248: PUSH
20249: LD_INT 4
20251: PUSH
20252: LD_INT 1
20254: PUSH
20255: LD_INT 1
20257: PUSH
20258: LD_INT 6
20260: PUSH
20261: EMPTY
20262: LIST
20263: LIST
20264: LIST
20265: LIST
20266: PUSH
20267: LD_INT 4
20269: PUSH
20270: LD_INT 1
20272: PUSH
20273: LD_INT 1
20275: PUSH
20276: LD_INT 7
20278: PUSH
20279: EMPTY
20280: LIST
20281: LIST
20282: LIST
20283: LIST
20284: PUSH
20285: LD_INT 3
20287: PUSH
20288: LD_INT 1
20290: PUSH
20291: LD_INT 1
20293: PUSH
20294: LD_INT 7
20296: PUSH
20297: EMPTY
20298: LIST
20299: LIST
20300: LIST
20301: LIST
20302: PUSH
20303: LD_INT 3
20305: PUSH
20306: LD_INT 1
20308: PUSH
20309: LD_INT 1
20311: PUSH
20312: LD_INT 5
20314: PUSH
20315: EMPTY
20316: LIST
20317: LIST
20318: LIST
20319: LIST
20320: PUSH
20321: EMPTY
20322: LIST
20323: LIST
20324: LIST
20325: LIST
20326: LIST
20327: PPUSH
20328: CALL 58502 0 2
// missionStage := 4 ;
20332: LD_ADDR_EXP 15
20336: PUSH
20337: LD_INT 4
20339: ST_TO_ADDR
// end ;
20340: PPOPN 8
20342: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20343: LD_EXP 15
20347: PUSH
20348: LD_INT 4
20350: EQUAL
20351: PUSH
20352: LD_INT 22
20354: PUSH
20355: LD_INT 4
20357: PUSH
20358: EMPTY
20359: LIST
20360: LIST
20361: PUSH
20362: LD_INT 21
20364: PUSH
20365: LD_INT 2
20367: PUSH
20368: EMPTY
20369: LIST
20370: LIST
20371: PUSH
20372: EMPTY
20373: LIST
20374: LIST
20375: PPUSH
20376: CALL_OW 69
20380: PUSH
20381: LD_INT 5
20383: GREATEREQUAL
20384: AND
20385: IFFALSE 24490
20387: GO 20389
20389: DISABLE
20390: LD_INT 0
20392: PPUSH
20393: PPUSH
20394: PPUSH
20395: PPUSH
20396: PPUSH
20397: PPUSH
20398: PPUSH
20399: PPUSH
20400: PPUSH
20401: PPUSH
20402: PPUSH
20403: PPUSH
20404: PPUSH
// begin missionStage := 5 ;
20405: LD_ADDR_EXP 15
20409: PUSH
20410: LD_INT 5
20412: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20413: LD_ADDR_VAR 0 10
20417: PUSH
20418: LD_INT 22
20420: PUSH
20421: LD_INT 4
20423: PUSH
20424: EMPTY
20425: LIST
20426: LIST
20427: PUSH
20428: LD_INT 2
20430: PUSH
20431: LD_INT 30
20433: PUSH
20434: LD_INT 4
20436: PUSH
20437: EMPTY
20438: LIST
20439: LIST
20440: PUSH
20441: LD_INT 30
20443: PUSH
20444: LD_INT 5
20446: PUSH
20447: EMPTY
20448: LIST
20449: LIST
20450: PUSH
20451: EMPTY
20452: LIST
20453: LIST
20454: LIST
20455: PUSH
20456: EMPTY
20457: LIST
20458: LIST
20459: PPUSH
20460: CALL_OW 69
20464: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20465: LD_ADDR_VAR 0 6
20469: PUSH
20470: LD_INT 22
20472: PUSH
20473: LD_INT 4
20475: PUSH
20476: EMPTY
20477: LIST
20478: LIST
20479: PUSH
20480: LD_INT 21
20482: PUSH
20483: LD_INT 1
20485: PUSH
20486: EMPTY
20487: LIST
20488: LIST
20489: PUSH
20490: LD_INT 3
20492: PUSH
20493: LD_INT 25
20495: PUSH
20496: LD_INT 16
20498: PUSH
20499: EMPTY
20500: LIST
20501: LIST
20502: PUSH
20503: EMPTY
20504: LIST
20505: LIST
20506: PUSH
20507: LD_INT 3
20509: PUSH
20510: LD_INT 25
20512: PUSH
20513: LD_INT 12
20515: PUSH
20516: EMPTY
20517: LIST
20518: LIST
20519: PUSH
20520: EMPTY
20521: LIST
20522: LIST
20523: PUSH
20524: EMPTY
20525: LIST
20526: LIST
20527: LIST
20528: LIST
20529: PPUSH
20530: CALL_OW 69
20534: PUSH
20535: LD_EXP 58
20539: DIFF
20540: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20541: LD_ADDR_VAR 0 9
20545: PUSH
20546: LD_INT 22
20548: PUSH
20549: LD_INT 4
20551: PUSH
20552: EMPTY
20553: LIST
20554: LIST
20555: PUSH
20556: LD_INT 30
20558: PUSH
20559: LD_INT 3
20561: PUSH
20562: EMPTY
20563: LIST
20564: LIST
20565: PUSH
20566: EMPTY
20567: LIST
20568: LIST
20569: PPUSH
20570: CALL_OW 69
20574: PUSH
20575: LD_INT 1
20577: ARRAY
20578: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20579: LD_INT 35
20581: PPUSH
20582: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20586: LD_EXP 121
20590: PUSH
20591: LD_INT 4
20593: ARRAY
20594: PUSH
20595: LD_INT 5
20597: GREATEREQUAL
20598: PUSH
20599: LD_EXP 121
20603: PUSH
20604: LD_INT 4
20606: ARRAY
20607: PPUSH
20608: LD_INT 58
20610: PUSH
20611: EMPTY
20612: LIST
20613: PPUSH
20614: CALL_OW 72
20618: PUSH
20619: LD_INT 5
20621: GREATEREQUAL
20622: AND
20623: IFFALSE 20579
// powellAllowRetreat := false ;
20625: LD_ADDR_EXP 19
20629: PUSH
20630: LD_INT 0
20632: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20633: LD_INT 700
20635: PPUSH
20636: CALL_OW 67
// activeAttacks := false ;
20640: LD_ADDR_EXP 16
20644: PUSH
20645: LD_INT 0
20647: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20648: LD_INT 35
20650: PPUSH
20651: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20655: LD_INT 22
20657: PUSH
20658: LD_INT 6
20660: PUSH
20661: EMPTY
20662: LIST
20663: LIST
20664: PPUSH
20665: CALL_OW 69
20669: PUSH
20670: LD_INT 0
20672: EQUAL
20673: IFFALSE 20648
// tmp := mc_vehicles [ 4 ] ;
20675: LD_ADDR_VAR 0 3
20679: PUSH
20680: LD_EXP 121
20684: PUSH
20685: LD_INT 4
20687: ARRAY
20688: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20689: LD_ADDR_VAR 0 1
20693: PUSH
20694: DOUBLE
20695: LD_INT 1
20697: DEC
20698: ST_TO_ADDR
20699: LD_EXP 18
20703: PUSH
20704: FOR_TO
20705: IFFALSE 20966
// begin for j in powellSquadAttack [ i ] do
20707: LD_ADDR_VAR 0 2
20711: PUSH
20712: LD_EXP 18
20716: PUSH
20717: LD_VAR 0 1
20721: ARRAY
20722: PUSH
20723: FOR_IN
20724: IFFALSE 20962
// begin forces := forces diff j ;
20726: LD_ADDR_VAR 0 6
20730: PUSH
20731: LD_VAR 0 6
20735: PUSH
20736: LD_VAR 0 2
20740: DIFF
20741: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20742: LD_VAR 0 2
20746: PPUSH
20747: LD_INT 1
20749: PPUSH
20750: CALL_OW 109
// wait ( 0 0$2 ) ;
20754: LD_INT 70
20756: PPUSH
20757: CALL_OW 67
// if IsInUnit ( j ) then
20761: LD_VAR 0 2
20765: PPUSH
20766: CALL_OW 310
20770: IFFALSE 20781
// ComExitBuilding ( j ) ;
20772: LD_VAR 0 2
20776: PPUSH
20777: CALL_OW 122
// if GetClass ( j ) <> 1 then
20781: LD_VAR 0 2
20785: PPUSH
20786: CALL_OW 257
20790: PUSH
20791: LD_INT 1
20793: NONEQUAL
20794: IFFALSE 20874
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20796: LD_VAR 0 10
20800: PUSH
20801: LD_INT 1
20803: ARRAY
20804: PPUSH
20805: CALL_OW 313
20809: PUSH
20810: LD_INT 5
20812: GREATEREQUAL
20813: IFFALSE 20835
// AddComEnterUnit ( j , arm [ 2 ] ) else
20815: LD_VAR 0 2
20819: PPUSH
20820: LD_VAR 0 10
20824: PUSH
20825: LD_INT 2
20827: ARRAY
20828: PPUSH
20829: CALL_OW 180
20833: GO 20853
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20835: LD_VAR 0 2
20839: PPUSH
20840: LD_VAR 0 10
20844: PUSH
20845: LD_INT 1
20847: ARRAY
20848: PPUSH
20849: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20853: LD_VAR 0 2
20857: PPUSH
20858: LD_INT 1
20860: PPUSH
20861: CALL_OW 183
// AddComExitBuilding ( j ) ;
20865: LD_VAR 0 2
20869: PPUSH
20870: CALL_OW 182
// end ; if i = 2 then
20874: LD_VAR 0 1
20878: PUSH
20879: LD_INT 2
20881: EQUAL
20882: IFFALSE 20899
// AddComMoveXY ( j , 61 , 93 ) ;
20884: LD_VAR 0 2
20888: PPUSH
20889: LD_INT 61
20891: PPUSH
20892: LD_INT 93
20894: PPUSH
20895: CALL_OW 171
// if i = 1 then
20899: LD_VAR 0 1
20903: PUSH
20904: LD_INT 1
20906: EQUAL
20907: IFFALSE 20960
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20909: LD_VAR 0 2
20913: PPUSH
20914: LD_VAR 0 3
20918: PUSH
20919: LD_INT 1
20921: ARRAY
20922: PPUSH
20923: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20927: LD_ADDR_VAR 0 3
20931: PUSH
20932: LD_VAR 0 3
20936: PPUSH
20937: LD_INT 1
20939: PPUSH
20940: CALL_OW 3
20944: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20945: LD_VAR 0 2
20949: PPUSH
20950: LD_INT 69
20952: PPUSH
20953: LD_INT 94
20955: PPUSH
20956: CALL_OW 171
// end ; end ;
20960: GO 20723
20962: POP
20963: POP
// end ;
20964: GO 20704
20966: POP
20967: POP
// wait ( 0 0$55 ) ;
20968: LD_INT 1925
20970: PPUSH
20971: CALL_OW 67
// MC_Kill ( 4 ) ;
20975: LD_INT 4
20977: PPUSH
20978: CALL 35090 0 1
// tmp := UnitsInside ( fac ) ;
20982: LD_ADDR_VAR 0 3
20986: PUSH
20987: LD_VAR 0 9
20991: PPUSH
20992: CALL_OW 313
20996: ST_TO_ADDR
// if tmp then
20997: LD_VAR 0 3
21001: IFFALSE 21122
// for i in tmp do
21003: LD_ADDR_VAR 0 1
21007: PUSH
21008: LD_VAR 0 3
21012: PUSH
21013: FOR_IN
21014: IFFALSE 21120
// begin ComExitBuilding ( i ) ;
21016: LD_VAR 0 1
21020: PPUSH
21021: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21025: LD_VAR 0 10
21029: PUSH
21030: LD_INT 2
21032: ARRAY
21033: PPUSH
21034: CALL_OW 313
21038: PUSH
21039: LD_INT 6
21041: LESS
21042: IFFALSE 21064
// AddComEnterUnit ( i , arm [ 2 ] ) else
21044: LD_VAR 0 1
21048: PPUSH
21049: LD_VAR 0 10
21053: PUSH
21054: LD_INT 2
21056: ARRAY
21057: PPUSH
21058: CALL_OW 180
21062: GO 21118
// if UnitsInside ( arm [ 1 ] ) < 6 then
21064: LD_VAR 0 10
21068: PUSH
21069: LD_INT 1
21071: ARRAY
21072: PPUSH
21073: CALL_OW 313
21077: PUSH
21078: LD_INT 6
21080: LESS
21081: IFFALSE 21103
// AddComEnterUnit ( i , arm [ 1 ] ) else
21083: LD_VAR 0 1
21087: PPUSH
21088: LD_VAR 0 10
21092: PUSH
21093: LD_INT 1
21095: ARRAY
21096: PPUSH
21097: CALL_OW 180
21101: GO 21118
// AddComMoveXY ( i , 37 , 68 ) ;
21103: LD_VAR 0 1
21107: PPUSH
21108: LD_INT 37
21110: PPUSH
21111: LD_INT 68
21113: PPUSH
21114: CALL_OW 171
// end ;
21118: GO 21013
21120: POP
21121: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21122: LD_ADDR_VAR 0 11
21126: PUSH
21127: LD_VAR 0 6
21131: PPUSH
21132: LD_INT 26
21134: PUSH
21135: LD_INT 1
21137: PUSH
21138: EMPTY
21139: LIST
21140: LIST
21141: PPUSH
21142: CALL_OW 72
21146: PUSH
21147: LD_EXP 59
21151: DIFF
21152: ST_TO_ADDR
// if not speaker then
21153: LD_VAR 0 11
21157: NOT
21158: IFFALSE 21185
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21160: LD_ADDR_VAR 0 11
21164: PUSH
21165: LD_VAR 0 6
21169: PPUSH
21170: LD_INT 26
21172: PUSH
21173: LD_INT 1
21175: PUSH
21176: EMPTY
21177: LIST
21178: LIST
21179: PPUSH
21180: CALL_OW 72
21184: ST_TO_ADDR
// if speaker then
21185: LD_VAR 0 11
21189: IFFALSE 21205
// speaker := speaker [ 1 ] ;
21191: LD_ADDR_VAR 0 11
21195: PUSH
21196: LD_VAR 0 11
21200: PUSH
21201: LD_INT 1
21203: ARRAY
21204: ST_TO_ADDR
// Video ( true ) ;
21205: LD_INT 1
21207: PPUSH
21208: CALL 107736 0 1
// CenterNowOnUnits ( Powell ) ;
21212: LD_EXP 58
21216: PPUSH
21217: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21221: LD_ADDR_VAR 0 3
21225: PUSH
21226: LD_VAR 0 6
21230: PPUSH
21231: LD_INT 3
21233: PUSH
21234: LD_INT 25
21236: PUSH
21237: LD_INT 1
21239: PUSH
21240: EMPTY
21241: LIST
21242: LIST
21243: PUSH
21244: EMPTY
21245: LIST
21246: LIST
21247: PPUSH
21248: CALL_OW 72
21252: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21253: LD_ADDR_VAR 0 12
21257: PUSH
21258: LD_INT 22
21260: PUSH
21261: LD_INT 4
21263: PUSH
21264: EMPTY
21265: LIST
21266: LIST
21267: PUSH
21268: LD_INT 30
21270: PUSH
21271: LD_INT 32
21273: PUSH
21274: EMPTY
21275: LIST
21276: LIST
21277: PUSH
21278: LD_INT 58
21280: PUSH
21281: EMPTY
21282: LIST
21283: PUSH
21284: EMPTY
21285: LIST
21286: LIST
21287: LIST
21288: PPUSH
21289: CALL_OW 69
21293: ST_TO_ADDR
// for i = 1 to 6 do
21294: LD_ADDR_VAR 0 1
21298: PUSH
21299: DOUBLE
21300: LD_INT 1
21302: DEC
21303: ST_TO_ADDR
21304: LD_INT 6
21306: PUSH
21307: FOR_TO
21308: IFFALSE 21449
// begin if IsInUnit ( tmp [ i ] ) then
21310: LD_VAR 0 3
21314: PUSH
21315: LD_VAR 0 1
21319: ARRAY
21320: PPUSH
21321: CALL_OW 310
21325: IFFALSE 21342
// ComExitBuilding ( tmp [ i ] ) ;
21327: LD_VAR 0 3
21331: PUSH
21332: LD_VAR 0 1
21336: ARRAY
21337: PPUSH
21338: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21342: LD_VAR 0 3
21346: PUSH
21347: LD_VAR 0 1
21351: ARRAY
21352: PPUSH
21353: LD_VAR 0 10
21357: PUSH
21358: LD_INT 1
21360: ARRAY
21361: PPUSH
21362: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21366: LD_VAR 0 3
21370: PUSH
21371: LD_VAR 0 1
21375: ARRAY
21376: PPUSH
21377: LD_INT 1
21379: PPUSH
21380: CALL_OW 183
// if emp_towers then
21384: LD_VAR 0 12
21388: IFFALSE 21447
// begin AddComExitBuilding ( tmp [ i ] ) ;
21390: LD_VAR 0 3
21394: PUSH
21395: LD_VAR 0 1
21399: ARRAY
21400: PPUSH
21401: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21405: LD_VAR 0 3
21409: PUSH
21410: LD_VAR 0 1
21414: ARRAY
21415: PPUSH
21416: LD_VAR 0 12
21420: PUSH
21421: LD_INT 1
21423: ARRAY
21424: PPUSH
21425: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21429: LD_ADDR_VAR 0 12
21433: PUSH
21434: LD_VAR 0 12
21438: PPUSH
21439: LD_INT 1
21441: PPUSH
21442: CALL_OW 3
21446: ST_TO_ADDR
// end ; end ;
21447: GO 21307
21449: POP
21450: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21451: LD_ADDR_VAR 0 3
21455: PUSH
21456: LD_EXP 18
21460: PUSH
21461: LD_INT 1
21463: ARRAY
21464: PUSH
21465: LD_EXP 18
21469: PUSH
21470: LD_INT 2
21472: ARRAY
21473: ADD
21474: PPUSH
21475: LD_INT 26
21477: PUSH
21478: LD_INT 1
21480: PUSH
21481: EMPTY
21482: LIST
21483: LIST
21484: PPUSH
21485: CALL_OW 72
21489: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21490: LD_ADDR_VAR 0 1
21494: PUSH
21495: LD_EXP 18
21499: PUSH
21500: LD_INT 2
21502: ARRAY
21503: PUSH
21504: FOR_IN
21505: IFFALSE 21523
// ComTurnUnit ( i , Powell ) ;
21507: LD_VAR 0 1
21511: PPUSH
21512: LD_EXP 58
21516: PPUSH
21517: CALL_OW 119
21521: GO 21504
21523: POP
21524: POP
// Say ( Powell , D5-Pow-1 ) ;
21525: LD_EXP 58
21529: PPUSH
21530: LD_STRING D5-Pow-1
21532: PPUSH
21533: CALL_OW 88
// if tmp then
21537: LD_VAR 0 3
21541: IFFALSE 21559
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21543: LD_VAR 0 3
21547: PUSH
21548: LD_INT 1
21550: ARRAY
21551: PPUSH
21552: LD_STRING D5-Sol2-1
21554: PPUSH
21555: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21559: LD_EXP 58
21563: PPUSH
21564: LD_STRING D5-Pow-2
21566: PPUSH
21567: CALL_OW 88
// if tmp > 1 then
21571: LD_VAR 0 3
21575: PUSH
21576: LD_INT 1
21578: GREATER
21579: IFFALSE 21597
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21581: LD_VAR 0 3
21585: PUSH
21586: LD_INT 2
21588: ARRAY
21589: PPUSH
21590: LD_STRING D5-Sol2-2
21592: PPUSH
21593: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21597: LD_EXP 58
21601: PPUSH
21602: LD_STRING D5-Pow-3
21604: PPUSH
21605: CALL_OW 88
// wait ( 0 0$1 ) ;
21609: LD_INT 35
21611: PPUSH
21612: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21616: LD_ADDR_VAR 0 3
21620: PUSH
21621: LD_EXP 18
21625: PUSH
21626: LD_INT 1
21628: ARRAY
21629: PUSH
21630: LD_EXP 18
21634: PUSH
21635: LD_INT 2
21637: ARRAY
21638: UNION
21639: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21640: LD_VAR 0 3
21644: PPUSH
21645: LD_INT 80
21647: PPUSH
21648: LD_INT 67
21650: PPUSH
21651: CALL_OW 114
// wait ( 0 0$2 ) ;
21655: LD_INT 70
21657: PPUSH
21658: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21662: LD_INT 79
21664: PPUSH
21665: LD_INT 72
21667: PPUSH
21668: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21672: LD_INT 35
21674: PPUSH
21675: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21679: LD_VAR 0 3
21683: PPUSH
21684: LD_INT 3
21686: PUSH
21687: LD_INT 24
21689: PUSH
21690: LD_INT 1000
21692: PUSH
21693: EMPTY
21694: LIST
21695: LIST
21696: PUSH
21697: EMPTY
21698: LIST
21699: LIST
21700: PPUSH
21701: CALL_OW 72
21705: IFFALSE 21672
// Say ( Powell , D5a-Pow-1 ) ;
21707: LD_EXP 58
21711: PPUSH
21712: LD_STRING D5a-Pow-1
21714: PPUSH
21715: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21719: LD_EXP 58
21723: PPUSH
21724: LD_STRING D5a-Pow-1a
21726: PPUSH
21727: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21731: LD_INT 10
21733: PPUSH
21734: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21738: LD_EXP 58
21742: PPUSH
21743: LD_STRING D5a-Pow-1b
21745: PPUSH
21746: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21750: LD_EXP 58
21754: PPUSH
21755: LD_STRING D5a-Pow-1c
21757: PPUSH
21758: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21762: LD_EXP 58
21766: PPUSH
21767: LD_STRING D5a-Pow-1d
21769: PPUSH
21770: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21774: LD_INT 35
21776: PPUSH
21777: CALL_OW 67
// if not HasTask ( tmp ) then
21781: LD_VAR 0 3
21785: PPUSH
21786: CALL_OW 314
21790: NOT
21791: IFFALSE 21808
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21793: LD_VAR 0 3
21797: PPUSH
21798: LD_INT 80
21800: PPUSH
21801: LD_INT 67
21803: PPUSH
21804: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21808: LD_VAR 0 3
21812: PPUSH
21813: LD_INT 24
21815: PUSH
21816: LD_INT 1
21818: PUSH
21819: EMPTY
21820: LIST
21821: LIST
21822: PPUSH
21823: CALL_OW 72
21827: NOT
21828: IFFALSE 21774
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21830: LD_ADDR_VAR 0 3
21834: PUSH
21835: LD_INT 22
21837: PUSH
21838: LD_INT 4
21840: PUSH
21841: EMPTY
21842: LIST
21843: LIST
21844: PUSH
21845: LD_INT 92
21847: PUSH
21848: LD_INT 60
21850: PUSH
21851: LD_INT 93
21853: PUSH
21854: LD_INT 10
21856: PUSH
21857: EMPTY
21858: LIST
21859: LIST
21860: LIST
21861: LIST
21862: PUSH
21863: LD_INT 3
21865: PUSH
21866: LD_INT 54
21868: PUSH
21869: EMPTY
21870: LIST
21871: PUSH
21872: EMPTY
21873: LIST
21874: LIST
21875: PUSH
21876: EMPTY
21877: LIST
21878: LIST
21879: LIST
21880: PPUSH
21881: CALL_OW 69
21885: PUSH
21886: LD_EXP 58
21890: DIFF
21891: ST_TO_ADDR
// if tmp then
21892: LD_VAR 0 3
21896: IFFALSE 21930
// for i in tmp do
21898: LD_ADDR_VAR 0 1
21902: PUSH
21903: LD_VAR 0 3
21907: PUSH
21908: FOR_IN
21909: IFFALSE 21928
// ComMoveXY ( i , 36 , 67 ) ;
21911: LD_VAR 0 1
21915: PPUSH
21916: LD_INT 36
21918: PPUSH
21919: LD_INT 67
21921: PPUSH
21922: CALL_OW 111
21926: GO 21908
21928: POP
21929: POP
// wait ( 0 0$3 ) ;
21930: LD_INT 105
21932: PPUSH
21933: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21937: LD_VAR 0 11
21941: PPUSH
21942: LD_STRING D6-Sol3-1
21944: PPUSH
21945: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21949: LD_EXP 58
21953: PPUSH
21954: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21958: LD_EXP 58
21962: PPUSH
21963: LD_STRING D6-Pow-1
21965: PPUSH
21966: CALL_OW 88
// tmp := [ ] ;
21970: LD_ADDR_VAR 0 3
21974: PUSH
21975: EMPTY
21976: ST_TO_ADDR
// for i = 1 to 2 do
21977: LD_ADDR_VAR 0 1
21981: PUSH
21982: DOUBLE
21983: LD_INT 1
21985: DEC
21986: ST_TO_ADDR
21987: LD_INT 2
21989: PUSH
21990: FOR_TO
21991: IFFALSE 22105
// begin uc_side := 8 ;
21993: LD_ADDR_OWVAR 20
21997: PUSH
21998: LD_INT 8
22000: ST_TO_ADDR
// uc_nation := 2 ;
22001: LD_ADDR_OWVAR 21
22005: PUSH
22006: LD_INT 2
22008: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22009: LD_INT 14
22011: PPUSH
22012: LD_INT 3
22014: PPUSH
22015: LD_INT 2
22017: PPUSH
22018: LD_INT 29
22020: PPUSH
22021: LD_INT 100
22023: PPUSH
22024: CALL 72009 0 5
// veh := CreateVehicle ;
22028: LD_ADDR_VAR 0 13
22032: PUSH
22033: CALL_OW 45
22037: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22038: LD_VAR 0 13
22042: PPUSH
22043: LD_INT 4
22045: PPUSH
22046: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22050: LD_VAR 0 13
22054: PPUSH
22055: LD_INT 99
22057: PPUSH
22058: LD_INT 83
22060: PPUSH
22061: LD_INT 6
22063: PPUSH
22064: LD_INT 0
22066: PPUSH
22067: CALL_OW 50
// wait ( 3 ) ;
22071: LD_INT 3
22073: PPUSH
22074: CALL_OW 67
// Connect ( veh ) ;
22078: LD_VAR 0 13
22082: PPUSH
22083: CALL 75064 0 1
// tmp := tmp ^ veh ;
22087: LD_ADDR_VAR 0 3
22091: PUSH
22092: LD_VAR 0 3
22096: PUSH
22097: LD_VAR 0 13
22101: ADD
22102: ST_TO_ADDR
// end ;
22103: GO 21990
22105: POP
22106: POP
// wait ( 0 0$1 ) ;
22107: LD_INT 35
22109: PPUSH
22110: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22114: LD_INT 99
22116: PPUSH
22117: LD_INT 83
22119: PPUSH
22120: LD_INT 1
22122: PPUSH
22123: LD_INT 10
22125: PPUSH
22126: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22130: LD_INT 99
22132: PPUSH
22133: LD_INT 83
22135: PPUSH
22136: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22140: LD_VAR 0 11
22144: PPUSH
22145: LD_STRING D6-Sol3-2
22147: PPUSH
22148: CALL_OW 88
// async ;
22152: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22153: LD_EXP 58
22157: PPUSH
22158: LD_STRING D6-Pow-2
22160: PPUSH
22161: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22165: LD_VAR 0 3
22169: PUSH
22170: LD_INT 1
22172: ARRAY
22173: PPUSH
22174: LD_VAR 0 9
22178: PPUSH
22179: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22183: LD_VAR 0 3
22187: PUSH
22188: LD_INT 2
22190: ARRAY
22191: PPUSH
22192: LD_INT 22
22194: PUSH
22195: LD_INT 4
22197: PUSH
22198: EMPTY
22199: LIST
22200: LIST
22201: PUSH
22202: LD_INT 21
22204: PUSH
22205: LD_INT 3
22207: PUSH
22208: EMPTY
22209: LIST
22210: LIST
22211: PUSH
22212: EMPTY
22213: LIST
22214: LIST
22215: PPUSH
22216: CALL_OW 69
22220: PPUSH
22221: LD_VAR 0 3
22225: PUSH
22226: LD_INT 2
22228: ARRAY
22229: PPUSH
22230: CALL_OW 74
22234: PPUSH
22235: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22239: LD_EXP 58
22243: PPUSH
22244: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22248: LD_INT 99
22250: PPUSH
22251: LD_INT 83
22253: PPUSH
22254: LD_INT 1
22256: PPUSH
22257: CALL_OW 331
// repeat wait ( 4 ) ;
22261: LD_INT 4
22263: PPUSH
22264: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22268: LD_VAR 0 3
22272: PUSH
22273: LD_INT 1
22275: ARRAY
22276: PPUSH
22277: CALL_OW 256
22281: PUSH
22282: LD_INT 1000
22284: LESS
22285: IFFALSE 22303
// SetLives ( tmp [ 1 ] , 1000 ) ;
22287: LD_VAR 0 3
22291: PUSH
22292: LD_INT 1
22294: ARRAY
22295: PPUSH
22296: LD_INT 1000
22298: PPUSH
22299: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22303: LD_INT 22
22305: PUSH
22306: LD_INT 4
22308: PUSH
22309: EMPTY
22310: LIST
22311: LIST
22312: PUSH
22313: LD_INT 30
22315: PUSH
22316: LD_INT 3
22318: PUSH
22319: EMPTY
22320: LIST
22321: LIST
22322: PUSH
22323: EMPTY
22324: LIST
22325: LIST
22326: PPUSH
22327: CALL_OW 69
22331: PUSH
22332: LD_INT 0
22334: EQUAL
22335: IFFALSE 22261
// sync ;
22337: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22338: LD_EXP 58
22342: PPUSH
22343: LD_STRING D6a-Pow-1
22345: PPUSH
22346: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22350: LD_VAR 0 11
22354: PPUSH
22355: LD_STRING D6a-Sol3-1
22357: PPUSH
22358: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22362: LD_EXP 58
22366: PPUSH
22367: LD_STRING D6a-Pow-2
22369: PPUSH
22370: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22374: LD_VAR 0 11
22378: PPUSH
22379: LD_STRING D6a-Sol3-2
22381: PPUSH
22382: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22386: LD_EXP 58
22390: PPUSH
22391: LD_STRING D6a-Pow-3
22393: PPUSH
22394: CALL_OW 88
// powellCenterCameraMode := true ;
22398: LD_ADDR_EXP 20
22402: PUSH
22403: LD_INT 1
22405: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22406: LD_ADDR_VAR 0 1
22410: PUSH
22411: LD_INT 22
22413: PUSH
22414: LD_INT 8
22416: PUSH
22417: EMPTY
22418: LIST
22419: LIST
22420: PUSH
22421: LD_INT 25
22423: PUSH
22424: LD_INT 2
22426: PUSH
22427: EMPTY
22428: LIST
22429: LIST
22430: PUSH
22431: EMPTY
22432: LIST
22433: LIST
22434: PPUSH
22435: CALL_OW 69
22439: PUSH
22440: FOR_IN
22441: IFFALSE 22496
// begin SetTag ( i , 1 ) ;
22443: LD_VAR 0 1
22447: PPUSH
22448: LD_INT 1
22450: PPUSH
22451: CALL_OW 109
// ComExitBuilding ( i ) ;
22455: LD_VAR 0 1
22459: PPUSH
22460: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22464: LD_VAR 0 1
22468: PPUSH
22469: LD_INT 35
22471: PPUSH
22472: LD_INT 6
22474: PPUSH
22475: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22479: LD_VAR 0 1
22483: PPUSH
22484: LD_INT 53
22486: PPUSH
22487: LD_INT 4
22489: PPUSH
22490: CALL_OW 171
// end ;
22494: GO 22440
22496: POP
22497: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22498: LD_ADDR_VAR 0 3
22502: PUSH
22503: LD_INT 22
22505: PUSH
22506: LD_INT 4
22508: PUSH
22509: EMPTY
22510: LIST
22511: LIST
22512: PUSH
22513: LD_INT 21
22515: PUSH
22516: LD_INT 2
22518: PUSH
22519: EMPTY
22520: LIST
22521: LIST
22522: PUSH
22523: LD_INT 3
22525: PUSH
22526: LD_INT 34
22528: PUSH
22529: LD_INT 12
22531: PUSH
22532: EMPTY
22533: LIST
22534: LIST
22535: PUSH
22536: EMPTY
22537: LIST
22538: LIST
22539: PUSH
22540: EMPTY
22541: LIST
22542: LIST
22543: LIST
22544: PPUSH
22545: CALL_OW 69
22549: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22550: LD_EXP 58
22554: PPUSH
22555: LD_VAR 0 3
22559: PPUSH
22560: LD_EXP 58
22564: PPUSH
22565: CALL_OW 74
22569: PPUSH
22570: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22574: LD_EXP 58
22578: PPUSH
22579: LD_INT 100
22581: PPUSH
22582: LD_INT 88
22584: PPUSH
22585: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22589: LD_EXP 58
22593: PPUSH
22594: LD_INT 100
22596: PPUSH
22597: LD_INT 75
22599: PPUSH
22600: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22604: LD_EXP 58
22608: PPUSH
22609: LD_INT 88
22611: PPUSH
22612: LD_INT 53
22614: PPUSH
22615: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22619: LD_INT 8
22621: PPUSH
22622: LD_EXP 58
22626: PPUSH
22627: CALL_OW 471
// repeat wait ( 3 ) ;
22631: LD_INT 3
22633: PPUSH
22634: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22638: LD_INT 22
22640: PUSH
22641: LD_INT 4
22643: PUSH
22644: EMPTY
22645: LIST
22646: LIST
22647: PUSH
22648: LD_INT 92
22650: PUSH
22651: LD_INT 100
22653: PUSH
22654: LD_INT 75
22656: PUSH
22657: LD_INT 6
22659: PUSH
22660: EMPTY
22661: LIST
22662: LIST
22663: LIST
22664: LIST
22665: PUSH
22666: EMPTY
22667: LIST
22668: LIST
22669: PPUSH
22670: CALL_OW 69
22674: IFFALSE 22631
// async ;
22676: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22677: LD_EXP 58
22681: PPUSH
22682: LD_STRING D6b-Pow-1
22684: PPUSH
22685: CALL_OW 88
// repeat wait ( 3 ) ;
22689: LD_INT 3
22691: PPUSH
22692: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22696: LD_EXP 58
22700: PPUSH
22701: CALL_OW 310
22705: PPUSH
22706: CALL_OW 256
22710: PUSH
22711: LD_INT 1000
22713: LESS
22714: IFFALSE 22733
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22716: LD_EXP 58
22720: PPUSH
22721: CALL_OW 310
22725: PPUSH
22726: LD_INT 1000
22728: PPUSH
22729: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22733: LD_EXP 58
22737: PPUSH
22738: CALL_OW 256
22742: PUSH
22743: LD_INT 1000
22745: LESS
22746: IFFALSE 22760
// SetLives ( Powell , 1000 ) ;
22748: LD_EXP 58
22752: PPUSH
22753: LD_INT 1000
22755: PPUSH
22756: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22760: LD_EXP 58
22764: PPUSH
22765: LD_EXP 63
22769: PPUSH
22770: CALL_OW 296
22774: PUSH
22775: LD_INT 5
22777: LESS
22778: PUSH
22779: LD_EXP 58
22783: PPUSH
22784: CALL_OW 310
22788: PPUSH
22789: LD_EXP 63
22793: PPUSH
22794: CALL_OW 296
22798: PUSH
22799: LD_INT 5
22801: LESS
22802: OR
22803: IFFALSE 22822
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22805: LD_EXP 58
22809: PPUSH
22810: CALL_OW 310
22814: PPUSH
22815: LD_INT 100
22817: PPUSH
22818: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22822: LD_EXP 58
22826: PPUSH
22827: CALL_OW 310
22831: NOT
22832: IFFALSE 22689
// DoNotAttack ( 8 , powellBomb ) ;
22834: LD_INT 8
22836: PPUSH
22837: LD_EXP 63
22841: PPUSH
22842: CALL_OW 471
// game_speed := 4 ;
22846: LD_ADDR_OWVAR 65
22850: PUSH
22851: LD_INT 4
22853: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22854: LD_EXP 58
22858: PPUSH
22859: LD_STRING D6b-Pow-1a
22861: PPUSH
22862: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22866: LD_EXP 58
22870: PPUSH
22871: LD_EXP 63
22875: PPUSH
22876: CALL_OW 180
// sync ;
22880: SYNC
// repeat wait ( 0 0$1 ) ;
22881: LD_INT 35
22883: PPUSH
22884: CALL_OW 67
// until IsInUnit ( Powell ) ;
22888: LD_EXP 58
22892: PPUSH
22893: CALL_OW 310
22897: IFFALSE 22881
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22899: LD_INT 8
22901: PPUSH
22902: LD_EXP 58
22906: PPUSH
22907: CALL_OW 310
22911: PPUSH
22912: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22916: LD_EXP 58
22920: PPUSH
22921: LD_INT 91
22923: PPUSH
22924: LD_INT 44
22926: PPUSH
22927: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22931: LD_EXP 58
22935: PPUSH
22936: LD_INT 96
22938: PPUSH
22939: LD_INT 44
22941: PPUSH
22942: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22946: LD_EXP 58
22950: PPUSH
22951: LD_INT 96
22953: PPUSH
22954: LD_INT 41
22956: PPUSH
22957: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22961: LD_EXP 58
22965: PPUSH
22966: LD_INT 92
22968: PPUSH
22969: LD_INT 39
22971: PPUSH
22972: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22976: LD_EXP 58
22980: PPUSH
22981: LD_INT 88
22983: PPUSH
22984: LD_INT 41
22986: PPUSH
22987: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22991: LD_EXP 58
22995: PPUSH
22996: LD_INT 91
22998: PPUSH
22999: LD_INT 44
23001: PPUSH
23002: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23006: LD_EXP 58
23010: PPUSH
23011: LD_INT 96
23013: PPUSH
23014: LD_INT 44
23016: PPUSH
23017: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23021: LD_EXP 58
23025: PPUSH
23026: LD_INT 96
23028: PPUSH
23029: LD_INT 41
23031: PPUSH
23032: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23036: LD_EXP 58
23040: PPUSH
23041: LD_INT 92
23043: PPUSH
23044: LD_INT 39
23046: PPUSH
23047: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23051: LD_EXP 58
23055: PPUSH
23056: LD_INT 88
23058: PPUSH
23059: LD_INT 41
23061: PPUSH
23062: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23066: LD_EXP 58
23070: PPUSH
23071: LD_INT 91
23073: PPUSH
23074: LD_INT 44
23076: PPUSH
23077: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23081: LD_EXP 58
23085: PPUSH
23086: LD_INT 93
23088: PPUSH
23089: LD_INT 39
23091: PPUSH
23092: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23096: LD_EXP 58
23100: PPUSH
23101: LD_INT 93
23103: PPUSH
23104: LD_INT 36
23106: PPUSH
23107: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23111: LD_INT 122
23113: PPUSH
23114: CALL_OW 67
// game_speed := 4 ;
23118: LD_ADDR_OWVAR 65
23122: PUSH
23123: LD_INT 4
23125: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23126: LD_EXP 58
23130: PPUSH
23131: LD_STRING D6b-Pow-1b
23133: PPUSH
23134: CALL_OW 88
// tmp := [ ] ;
23138: LD_ADDR_VAR 0 3
23142: PUSH
23143: EMPTY
23144: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23145: LD_ADDR_VAR 0 5
23149: PUSH
23150: LD_INT 78
23152: PUSH
23153: LD_INT 47
23155: PUSH
23156: EMPTY
23157: LIST
23158: LIST
23159: PUSH
23160: LD_INT 106
23162: PUSH
23163: LD_INT 53
23165: PUSH
23166: EMPTY
23167: LIST
23168: LIST
23169: PUSH
23170: EMPTY
23171: LIST
23172: LIST
23173: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23174: LD_ADDR_VAR 0 1
23178: PUSH
23179: LD_INT 22
23181: PUSH
23182: LD_INT 8
23184: PUSH
23185: EMPTY
23186: LIST
23187: LIST
23188: PUSH
23189: LD_INT 21
23191: PUSH
23192: LD_INT 3
23194: PUSH
23195: EMPTY
23196: LIST
23197: LIST
23198: PUSH
23199: LD_INT 92
23201: PUSH
23202: LD_INT 90
23204: PUSH
23205: LD_INT 52
23207: PUSH
23208: LD_INT 12
23210: PUSH
23211: EMPTY
23212: LIST
23213: LIST
23214: LIST
23215: LIST
23216: PUSH
23217: EMPTY
23218: LIST
23219: LIST
23220: LIST
23221: PPUSH
23222: CALL_OW 69
23226: PUSH
23227: FOR_IN
23228: IFFALSE 23253
// tmp := tmp ^ UnitsInside ( i ) ;
23230: LD_ADDR_VAR 0 3
23234: PUSH
23235: LD_VAR 0 3
23239: PUSH
23240: LD_VAR 0 1
23244: PPUSH
23245: CALL_OW 313
23249: ADD
23250: ST_TO_ADDR
23251: GO 23227
23253: POP
23254: POP
// for i in tmp do
23255: LD_ADDR_VAR 0 1
23259: PUSH
23260: LD_VAR 0 3
23264: PUSH
23265: FOR_IN
23266: IFFALSE 23428
// begin dist := 9999 ;
23268: LD_ADDR_VAR 0 8
23272: PUSH
23273: LD_INT 9999
23275: ST_TO_ADDR
// _xy := [ ] ;
23276: LD_ADDR_VAR 0 7
23280: PUSH
23281: EMPTY
23282: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23283: LD_VAR 0 1
23287: PPUSH
23288: LD_INT 1
23290: PPUSH
23291: CALL_OW 109
// ComExitBuilding ( i ) ;
23295: LD_VAR 0 1
23299: PPUSH
23300: CALL_OW 122
// for j in xy do
23304: LD_ADDR_VAR 0 2
23308: PUSH
23309: LD_VAR 0 5
23313: PUSH
23314: FOR_IN
23315: IFFALSE 23397
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23317: LD_VAR 0 1
23321: PPUSH
23322: LD_VAR 0 2
23326: PUSH
23327: LD_INT 1
23329: ARRAY
23330: PPUSH
23331: LD_VAR 0 2
23335: PUSH
23336: LD_INT 2
23338: ARRAY
23339: PPUSH
23340: CALL_OW 297
23344: PUSH
23345: LD_VAR 0 8
23349: LESS
23350: IFFALSE 23395
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23352: LD_ADDR_VAR 0 8
23356: PUSH
23357: LD_VAR 0 1
23361: PPUSH
23362: LD_VAR 0 2
23366: PUSH
23367: LD_INT 1
23369: ARRAY
23370: PPUSH
23371: LD_VAR 0 2
23375: PUSH
23376: LD_INT 2
23378: ARRAY
23379: PPUSH
23380: CALL_OW 297
23384: ST_TO_ADDR
// _xy := j ;
23385: LD_ADDR_VAR 0 7
23389: PUSH
23390: LD_VAR 0 2
23394: ST_TO_ADDR
// end ;
23395: GO 23314
23397: POP
23398: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23399: LD_VAR 0 1
23403: PPUSH
23404: LD_VAR 0 7
23408: PUSH
23409: LD_INT 1
23411: ARRAY
23412: PPUSH
23413: LD_VAR 0 7
23417: PUSH
23418: LD_INT 2
23420: ARRAY
23421: PPUSH
23422: CALL_OW 171
// end ;
23426: GO 23265
23428: POP
23429: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23430: LD_ADDR_VAR 0 4
23434: PUSH
23435: LD_VAR 0 3
23439: PPUSH
23440: LD_INT 26
23442: PUSH
23443: LD_INT 1
23445: PUSH
23446: EMPTY
23447: LIST
23448: LIST
23449: PUSH
23450: LD_INT 25
23452: PUSH
23453: LD_INT 1
23455: PUSH
23456: EMPTY
23457: LIST
23458: LIST
23459: PUSH
23460: EMPTY
23461: LIST
23462: LIST
23463: PPUSH
23464: CALL_OW 72
23468: ST_TO_ADDR
// if tmp2 < 2 then
23469: LD_VAR 0 4
23473: PUSH
23474: LD_INT 2
23476: LESS
23477: IFFALSE 23546
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23479: LD_ADDR_VAR 0 4
23483: PUSH
23484: LD_INT 22
23486: PUSH
23487: LD_INT 8
23489: PUSH
23490: EMPTY
23491: LIST
23492: LIST
23493: PUSH
23494: LD_INT 26
23496: PUSH
23497: LD_INT 1
23499: PUSH
23500: EMPTY
23501: LIST
23502: LIST
23503: PUSH
23504: LD_INT 3
23506: PUSH
23507: LD_INT 25
23509: PUSH
23510: LD_INT 15
23512: PUSH
23513: EMPTY
23514: LIST
23515: LIST
23516: PUSH
23517: EMPTY
23518: LIST
23519: LIST
23520: PUSH
23521: EMPTY
23522: LIST
23523: LIST
23524: LIST
23525: PPUSH
23526: CALL_OW 69
23530: PUSH
23531: LD_EXP 60
23535: PUSH
23536: LD_EXP 61
23540: PUSH
23541: EMPTY
23542: LIST
23543: LIST
23544: DIFF
23545: ST_TO_ADDR
// if tmp2 then
23546: LD_VAR 0 4
23550: IFFALSE 23568
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23552: LD_VAR 0 4
23556: PUSH
23557: LD_INT 1
23559: ARRAY
23560: PPUSH
23561: LD_STRING D6b-ArSol1-1
23563: PPUSH
23564: CALL_OW 88
// async ;
23568: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23569: LD_EXP 58
23573: PPUSH
23574: LD_STRING D6b-Pow-2
23576: PPUSH
23577: CALL_OW 88
// wait ( 0 0$1 ) ;
23581: LD_INT 35
23583: PPUSH
23584: CALL_OW 67
// if tmp2 > 1 then
23588: LD_VAR 0 4
23592: PUSH
23593: LD_INT 1
23595: GREATER
23596: IFFALSE 23614
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23598: LD_VAR 0 4
23602: PUSH
23603: LD_INT 2
23605: ARRAY
23606: PPUSH
23607: LD_STRING D6b-ArSol2-1
23609: PPUSH
23610: CALL_OW 88
// sync ;
23614: SYNC
// repeat wait ( 5 ) ;
23615: LD_INT 5
23617: PPUSH
23618: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23622: LD_INT 93
23624: PPUSH
23625: LD_INT 36
23627: PPUSH
23628: CALL_OW 428
23632: PPUSH
23633: CALL_OW 255
23637: PUSH
23638: LD_INT 4
23640: EQUAL
23641: IFFALSE 23615
// DialogueOn ;
23643: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23647: LD_INT 10
23649: PPUSH
23650: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23654: LD_EXP 58
23658: PPUSH
23659: LD_STRING D6b-Pow-2a
23661: PPUSH
23662: CALL_OW 88
// DialogueOff ;
23666: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23670: LD_EXP 58
23674: PPUSH
23675: CALL_OW 310
23679: PPUSH
23680: LD_INT 332
23682: PPUSH
23683: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23687: LD_INT 93
23689: PPUSH
23690: LD_INT 35
23692: PPUSH
23693: LD_INT 1
23695: PPUSH
23696: LD_INT 6
23698: NEG
23699: PPUSH
23700: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23704: LD_INT 35
23706: PPUSH
23707: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23711: LD_INT 332
23713: PPUSH
23714: CALL_OW 256
23718: PUSH
23719: LD_INT 1000
23721: LESS
23722: PUSH
23723: LD_INT 332
23725: PPUSH
23726: CALL_OW 300
23730: AND
23731: IFFALSE 23743
// SetLives ( kozlov_fac , 0 ) ;
23733: LD_INT 332
23735: PPUSH
23736: LD_INT 0
23738: PPUSH
23739: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23743: LD_INT 332
23745: PPUSH
23746: CALL_OW 301
23750: PUSH
23751: LD_EXP 58
23755: PPUSH
23756: CALL_OW 301
23760: OR
23761: IFFALSE 23704
// game_speed := 4 ;
23763: LD_ADDR_OWVAR 65
23767: PUSH
23768: LD_INT 4
23770: ST_TO_ADDR
// powellCenterCameraMode := false ;
23771: LD_ADDR_EXP 20
23775: PUSH
23776: LD_INT 0
23778: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23779: LD_ADDR_VAR 0 1
23783: PUSH
23784: LD_VAR 0 3
23788: PUSH
23789: LD_INT 22
23791: PUSH
23792: LD_INT 8
23794: PUSH
23795: EMPTY
23796: LIST
23797: LIST
23798: PUSH
23799: LD_INT 25
23801: PUSH
23802: LD_INT 2
23804: PUSH
23805: EMPTY
23806: LIST
23807: LIST
23808: PUSH
23809: EMPTY
23810: LIST
23811: LIST
23812: PPUSH
23813: CALL_OW 69
23817: UNION
23818: PUSH
23819: FOR_IN
23820: IFFALSE 23836
// SetTag ( i , 0 ) ;
23822: LD_VAR 0 1
23826: PPUSH
23827: LD_INT 0
23829: PPUSH
23830: CALL_OW 109
23834: GO 23819
23836: POP
23837: POP
// wait ( 0 0$3 ) ;
23838: LD_INT 105
23840: PPUSH
23841: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23845: LD_INT 93
23847: PPUSH
23848: LD_INT 35
23850: PPUSH
23851: LD_INT 1
23853: PPUSH
23854: CALL_OW 331
// DialogueOn ;
23858: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23862: LD_VAR 0 11
23866: PPUSH
23867: LD_STRING D6c-Sol3-1
23869: PPUSH
23870: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23874: LD_INT 10
23876: PPUSH
23877: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23881: LD_EXP 39
23885: PPUSH
23886: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23890: LD_EXP 39
23894: PPUSH
23895: LD_STRING D6c-JMM-1
23897: PPUSH
23898: CALL_OW 88
// if Cyrus then
23902: LD_EXP 45
23906: IFFALSE 23920
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23908: LD_EXP 45
23912: PPUSH
23913: LD_STRING D6c-Cyrus-1
23915: PPUSH
23916: CALL_OW 88
// if Bobby then
23920: LD_EXP 44
23924: IFFALSE 23938
// Say ( Bobby , D6c-Bobby-1 ) ;
23926: LD_EXP 44
23930: PPUSH
23931: LD_STRING D6c-Bobby-1
23933: PPUSH
23934: CALL_OW 88
// if Cornel then
23938: LD_EXP 50
23942: IFFALSE 23956
// Say ( Cornel , D6c-Corn-1 ) ;
23944: LD_EXP 50
23948: PPUSH
23949: LD_STRING D6c-Corn-1
23951: PPUSH
23952: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23956: LD_ADDR_VAR 0 4
23960: PUSH
23961: LD_INT 2
23963: PUSH
23964: LD_INT 22
23966: PUSH
23967: LD_INT 1
23969: PUSH
23970: EMPTY
23971: LIST
23972: LIST
23973: PUSH
23974: LD_INT 22
23976: PUSH
23977: LD_INT 4
23979: PUSH
23980: EMPTY
23981: LIST
23982: LIST
23983: PUSH
23984: EMPTY
23985: LIST
23986: LIST
23987: LIST
23988: PUSH
23989: LD_INT 26
23991: PUSH
23992: LD_INT 1
23994: PUSH
23995: EMPTY
23996: LIST
23997: LIST
23998: PUSH
23999: LD_INT 3
24001: PUSH
24002: LD_INT 25
24004: PUSH
24005: LD_INT 16
24007: PUSH
24008: EMPTY
24009: LIST
24010: LIST
24011: PUSH
24012: LD_INT 25
24014: PUSH
24015: LD_INT 12
24017: PUSH
24018: EMPTY
24019: LIST
24020: LIST
24021: PUSH
24022: EMPTY
24023: LIST
24024: LIST
24025: LIST
24026: PUSH
24027: EMPTY
24028: LIST
24029: LIST
24030: LIST
24031: PPUSH
24032: CALL_OW 69
24036: PUSH
24037: LD_VAR 0 11
24041: PUSH
24042: LD_EXP 39
24046: UNION
24047: PUSH
24048: LD_EXP 59
24052: UNION
24053: PUSH
24054: EMPTY
24055: LIST
24056: DIFF
24057: ST_TO_ADDR
// if tmp2 then
24058: LD_VAR 0 4
24062: IFFALSE 24080
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24064: LD_VAR 0 4
24068: PUSH
24069: LD_INT 1
24071: ARRAY
24072: PPUSH
24073: LD_STRING D6c-Sol1-1
24075: PPUSH
24076: CALL_OW 88
// if Lisa then
24080: LD_EXP 42
24084: IFFALSE 24098
// Say ( Lisa , D6c-Lisa-1 ) ;
24086: LD_EXP 42
24090: PPUSH
24091: LD_STRING D6c-Lisa-1
24093: PPUSH
24094: CALL_OW 88
// if Gary then
24098: LD_EXP 51
24102: IFFALSE 24116
// Say ( Gary , D6c-Gary-1 ) ;
24104: LD_EXP 51
24108: PPUSH
24109: LD_STRING D6c-Gary-1
24111: PPUSH
24112: CALL_OW 88
// if Donaldson then
24116: LD_EXP 43
24120: IFFALSE 24134
// Say ( Donaldson , D6c-Don-1 ) ;
24122: LD_EXP 43
24126: PPUSH
24127: LD_STRING D6c-Don-1
24129: PPUSH
24130: CALL_OW 88
// if tmp2 > 1 then
24134: LD_VAR 0 4
24138: PUSH
24139: LD_INT 1
24141: GREATER
24142: IFFALSE 24160
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24144: LD_VAR 0 4
24148: PUSH
24149: LD_INT 2
24151: ARRAY
24152: PPUSH
24153: LD_STRING D6c-Sol2-1
24155: PPUSH
24156: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24160: LD_VAR 0 11
24164: PPUSH
24165: LD_STRING D6c-Sol3-2
24167: PPUSH
24168: CALL_OW 88
// dwait ( 0 0$1 ) ;
24172: LD_INT 35
24174: PPUSH
24175: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24179: LD_EXP 39
24183: PPUSH
24184: LD_STRING D6c-JMM-2
24186: PPUSH
24187: CALL_OW 88
// DialogueOff ;
24191: CALL_OW 7
// Video ( false ) ;
24195: LD_INT 0
24197: PPUSH
24198: CALL 107736 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24202: LD_INT 22
24204: PUSH
24205: LD_INT 4
24207: PUSH
24208: EMPTY
24209: LIST
24210: LIST
24211: PPUSH
24212: CALL_OW 69
24216: PPUSH
24217: LD_INT 1
24219: PPUSH
24220: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24224: LD_INT 4
24226: PPUSH
24227: LD_INT 4
24229: PPUSH
24230: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24234: LD_ADDR_VAR 0 1
24238: PUSH
24239: LD_INT 4
24241: PPUSH
24242: LD_INT 1
24244: PPUSH
24245: LD_INT 2
24247: PPUSH
24248: CALL 64957 0 3
24252: PUSH
24253: FOR_IN
24254: IFFALSE 24291
// if GetTech ( i , 1 ) <> state_researched then
24256: LD_VAR 0 1
24260: PPUSH
24261: LD_INT 1
24263: PPUSH
24264: CALL_OW 321
24268: PUSH
24269: LD_INT 2
24271: NONEQUAL
24272: IFFALSE 24289
// SetTech ( i , 1 , state_researched ) ;
24274: LD_VAR 0 1
24278: PPUSH
24279: LD_INT 1
24281: PPUSH
24282: LD_INT 2
24284: PPUSH
24285: CALL_OW 322
24289: GO 24253
24291: POP
24292: POP
// missionStage := 6 ;
24293: LD_ADDR_EXP 15
24297: PUSH
24298: LD_INT 6
24300: ST_TO_ADDR
// activeAttacks := true ;
24301: LD_ADDR_EXP 16
24305: PUSH
24306: LD_INT 1
24308: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24309: LD_STRING M2
24311: PPUSH
24312: CALL_OW 337
// SaveForQuickRestart ;
24316: CALL_OW 22
// wait ( 0 0$40 ) ;
24320: LD_INT 1400
24322: PPUSH
24323: CALL_OW 67
// DialogueOn ;
24327: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24331: LD_EXP 62
24335: PPUSH
24336: LD_STRING D7-Friend-1
24338: PPUSH
24339: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24343: LD_EXP 39
24347: PPUSH
24348: LD_STRING D7-JMM-1
24350: PPUSH
24351: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24355: LD_EXP 62
24359: PPUSH
24360: LD_STRING D7-Friend-2
24362: PPUSH
24363: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24367: LD_EXP 39
24371: PPUSH
24372: LD_STRING D7-JMM-2
24374: PPUSH
24375: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24379: LD_EXP 62
24383: PPUSH
24384: LD_STRING D7-Friend-3
24386: PPUSH
24387: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24391: LD_EXP 39
24395: PPUSH
24396: LD_STRING D7-JMM-3
24398: PPUSH
24399: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24403: LD_EXP 62
24407: PPUSH
24408: LD_STRING D7-Friend-4
24410: PPUSH
24411: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24415: LD_EXP 39
24419: PPUSH
24420: LD_STRING D7-JMM-4
24422: PPUSH
24423: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24427: LD_EXP 62
24431: PPUSH
24432: LD_STRING D7-Friend-5
24434: PPUSH
24435: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24439: LD_EXP 39
24443: PPUSH
24444: LD_STRING D7-JMM-5
24446: PPUSH
24447: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24451: LD_EXP 62
24455: PPUSH
24456: LD_STRING D7-Friend-6
24458: PPUSH
24459: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24463: LD_EXP 39
24467: PPUSH
24468: LD_STRING D7-JMM-6
24470: PPUSH
24471: CALL_OW 88
// DialogueOff ;
24475: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24479: LD_STRING Mlegion
24481: PPUSH
24482: CALL_OW 337
// RebuildKozlovFactory ;
24486: CALL 4840 0 0
// end ;
24490: PPOPN 13
24492: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24493: LD_EXP 20
24497: PUSH
24498: LD_EXP 58
24502: PPUSH
24503: CALL_OW 300
24507: AND
24508: IFFALSE 24550
24510: GO 24512
24512: DISABLE
// begin enable ;
24513: ENABLE
// if IsInUnit ( Powell ) then
24514: LD_EXP 58
24518: PPUSH
24519: CALL_OW 310
24523: IFFALSE 24541
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24525: LD_EXP 58
24529: PPUSH
24530: CALL_OW 310
24534: PPUSH
24535: CALL_OW 85
24539: GO 24550
// CenterOnUnits ( Powell ) ;
24541: LD_EXP 58
24545: PPUSH
24546: CALL_OW 85
// end ;
24550: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24551: LD_INT 22
24553: PUSH
24554: LD_INT 8
24556: PUSH
24557: EMPTY
24558: LIST
24559: LIST
24560: PUSH
24561: LD_INT 34
24563: PUSH
24564: LD_INT 48
24566: PUSH
24567: EMPTY
24568: LIST
24569: LIST
24570: PUSH
24571: EMPTY
24572: LIST
24573: LIST
24574: PPUSH
24575: CALL_OW 69
24579: IFFALSE 24853
24581: GO 24583
24583: DISABLE
24584: LD_INT 0
24586: PPUSH
24587: PPUSH
// begin if missionStage < 9 then
24588: LD_EXP 15
24592: PUSH
24593: LD_INT 9
24595: LESS
24596: IFFALSE 24606
// missionStage := 9 ;
24598: LD_ADDR_EXP 15
24602: PUSH
24603: LD_INT 9
24605: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24606: LD_ADDR_VAR 0 1
24610: PUSH
24611: LD_INT 22
24613: PUSH
24614: LD_INT 8
24616: PUSH
24617: EMPTY
24618: LIST
24619: LIST
24620: PUSH
24621: LD_INT 34
24623: PUSH
24624: LD_INT 48
24626: PUSH
24627: EMPTY
24628: LIST
24629: LIST
24630: PUSH
24631: EMPTY
24632: LIST
24633: LIST
24634: PPUSH
24635: CALL_OW 69
24639: PUSH
24640: LD_INT 1
24642: ARRAY
24643: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24644: LD_INT 175
24646: PPUSH
24647: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24651: LD_EXP 12
24655: PUSH
24656: LD_EXP 3
24660: PUSH
24661: LD_INT 0
24663: PUSH
24664: LD_INT 2
24666: PUSH
24667: EMPTY
24668: LIST
24669: LIST
24670: IN
24671: OR
24672: IFFALSE 24695
// target := [ 68 , 108 , 1 ] else
24674: LD_ADDR_VAR 0 2
24678: PUSH
24679: LD_INT 68
24681: PUSH
24682: LD_INT 108
24684: PUSH
24685: LD_INT 1
24687: PUSH
24688: EMPTY
24689: LIST
24690: LIST
24691: LIST
24692: ST_TO_ADDR
24693: GO 24714
// target := [ 181 , 88 , 2 ] ;
24695: LD_ADDR_VAR 0 2
24699: PUSH
24700: LD_INT 181
24702: PUSH
24703: LD_INT 88
24705: PUSH
24706: LD_INT 2
24708: PUSH
24709: EMPTY
24710: LIST
24711: LIST
24712: LIST
24713: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24714: LD_VAR 0 1
24718: PPUSH
24719: LD_VAR 0 2
24723: PUSH
24724: LD_INT 1
24726: ARRAY
24727: PPUSH
24728: LD_VAR 0 2
24732: PUSH
24733: LD_INT 2
24735: ARRAY
24736: PPUSH
24737: CALL_OW 176
// if target [ 3 ] = 1 then
24741: LD_VAR 0 2
24745: PUSH
24746: LD_INT 3
24748: ARRAY
24749: PUSH
24750: LD_INT 1
24752: EQUAL
24753: IFFALSE 24769
// SayRadio ( Kurt , D12-Kurt-1 ) else
24755: LD_EXP 60
24759: PPUSH
24760: LD_STRING D12-Kurt-1
24762: PPUSH
24763: CALL_OW 94
24767: GO 24793
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24769: LD_EXP 60
24773: PPUSH
24774: LD_STRING D12a-Kurt-1
24776: PPUSH
24777: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24781: LD_EXP 74
24785: PPUSH
24786: LD_STRING D12a-Roth-1
24788: PPUSH
24789: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24793: LD_INT 350
24795: PPUSH
24796: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24800: LD_VAR 0 1
24804: PPUSH
24805: LD_INT 22
24807: PUSH
24808: LD_INT 8
24810: PUSH
24811: EMPTY
24812: LIST
24813: LIST
24814: PUSH
24815: LD_INT 23
24817: PUSH
24818: LD_INT 2
24820: PUSH
24821: EMPTY
24822: LIST
24823: LIST
24824: PUSH
24825: LD_INT 30
24827: PUSH
24828: LD_INT 3
24830: PUSH
24831: EMPTY
24832: LIST
24833: LIST
24834: PUSH
24835: EMPTY
24836: LIST
24837: LIST
24838: LIST
24839: PPUSH
24840: CALL_OW 69
24844: PUSH
24845: LD_INT 1
24847: ARRAY
24848: PPUSH
24849: CALL_OW 228
// end ;
24853: PPOPN 2
24855: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24856: LD_EXP 60
24860: PPUSH
24861: CALL_OW 256
24865: PUSH
24866: LD_INT 999
24868: LESS
24869: PUSH
24870: LD_INT 22
24872: PUSH
24873: LD_INT 8
24875: PUSH
24876: EMPTY
24877: LIST
24878: LIST
24879: PUSH
24880: LD_INT 21
24882: PUSH
24883: LD_INT 1
24885: PUSH
24886: EMPTY
24887: LIST
24888: LIST
24889: PUSH
24890: LD_INT 23
24892: PUSH
24893: LD_INT 2
24895: PUSH
24896: EMPTY
24897: LIST
24898: LIST
24899: PUSH
24900: EMPTY
24901: LIST
24902: LIST
24903: LIST
24904: PPUSH
24905: CALL_OW 69
24909: PUSH
24910: LD_INT 9
24912: PUSH
24913: LD_INT 8
24915: PUSH
24916: LD_INT 7
24918: PUSH
24919: EMPTY
24920: LIST
24921: LIST
24922: LIST
24923: PUSH
24924: LD_OWVAR 67
24928: ARRAY
24929: LESSEQUAL
24930: OR
24931: PUSH
24932: LD_INT 22
24934: PUSH
24935: LD_INT 8
24937: PUSH
24938: EMPTY
24939: LIST
24940: LIST
24941: PUSH
24942: LD_INT 34
24944: PUSH
24945: LD_INT 48
24947: PUSH
24948: EMPTY
24949: LIST
24950: LIST
24951: PUSH
24952: EMPTY
24953: LIST
24954: LIST
24955: PPUSH
24956: CALL_OW 69
24960: NOT
24961: AND
24962: PUSH
24963: LD_EXP 60
24967: PPUSH
24968: CALL_OW 302
24972: AND
24973: PUSH
24974: LD_INT 5
24976: PPUSH
24977: LD_INT 22
24979: PUSH
24980: LD_INT 1
24982: PUSH
24983: EMPTY
24984: LIST
24985: LIST
24986: PPUSH
24987: CALL_OW 70
24991: AND
24992: IFFALSE 25682
24994: GO 24996
24996: DISABLE
24997: LD_INT 0
24999: PPUSH
25000: PPUSH
25001: PPUSH
// begin DialogueOn ;
25002: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25006: LD_EXP 39
25010: PPUSH
25011: LD_STRING D13-JMM-1
25013: PPUSH
25014: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25018: LD_EXP 60
25022: PPUSH
25023: LD_STRING D13-Kurt-1
25025: PPUSH
25026: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25030: LD_EXP 39
25034: PPUSH
25035: LD_STRING D13-JMM-2
25037: PPUSH
25038: CALL_OW 88
// if FakeInfo then
25042: LD_EXP 12
25046: IFFALSE 25066
// begin Say ( Kurt , D13-Kurt-2 ) ;
25048: LD_EXP 60
25052: PPUSH
25053: LD_STRING D13-Kurt-2
25055: PPUSH
25056: CALL_OW 88
// DialogueOff ;
25060: CALL_OW 7
// exit ;
25064: GO 25682
// end ; if not KurtStatus then
25066: LD_EXP 3
25070: NOT
25071: IFFALSE 25087
// Say ( Kurt , D13-Kurt-2b ) else
25073: LD_EXP 60
25077: PPUSH
25078: LD_STRING D13-Kurt-2b
25080: PPUSH
25081: CALL_OW 88
25085: GO 25099
// Say ( Kurt , D13-Kurt-2a ) ;
25087: LD_EXP 60
25091: PPUSH
25092: LD_STRING D13-Kurt-2a
25094: PPUSH
25095: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25099: LD_EXP 39
25103: PPUSH
25104: LD_STRING D13-JMM-3
25106: PPUSH
25107: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25111: LD_EXP 60
25115: PPUSH
25116: LD_STRING D13-Kurt-3
25118: PPUSH
25119: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25123: LD_EXP 39
25127: PPUSH
25128: LD_STRING D13-JMM-4
25130: PPUSH
25131: CALL_OW 88
// DialogueOff ;
25135: CALL_OW 7
// MC_Kill ( 3 ) ;
25139: LD_INT 3
25141: PPUSH
25142: CALL 35090 0 1
// KillUnit ( Kozlov ) ;
25146: LD_EXP 61
25150: PPUSH
25151: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25155: LD_ADDR_VAR 0 1
25159: PUSH
25160: LD_INT 22
25162: PUSH
25163: LD_INT 8
25165: PUSH
25166: EMPTY
25167: LIST
25168: LIST
25169: PUSH
25170: LD_INT 23
25172: PUSH
25173: LD_INT 3
25175: PUSH
25176: EMPTY
25177: LIST
25178: LIST
25179: PUSH
25180: LD_INT 3
25182: PUSH
25183: LD_INT 21
25185: PUSH
25186: LD_INT 33
25188: PUSH
25189: EMPTY
25190: LIST
25191: LIST
25192: PUSH
25193: EMPTY
25194: LIST
25195: LIST
25196: PUSH
25197: EMPTY
25198: LIST
25199: LIST
25200: LIST
25201: PPUSH
25202: CALL_OW 69
25206: PUSH
25207: FOR_IN
25208: IFFALSE 25221
// KillUnit ( i ) ;
25210: LD_VAR 0 1
25214: PPUSH
25215: CALL_OW 66
25219: GO 25207
25221: POP
25222: POP
// ChangeSideFog ( 8 , 1 ) ;
25223: LD_INT 8
25225: PPUSH
25226: LD_INT 1
25228: PPUSH
25229: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25233: LD_ADDR_VAR 0 2
25237: PUSH
25238: LD_INT 22
25240: PUSH
25241: LD_INT 8
25243: PUSH
25244: EMPTY
25245: LIST
25246: LIST
25247: PUSH
25248: LD_INT 21
25250: PUSH
25251: LD_INT 1
25253: PUSH
25254: EMPTY
25255: LIST
25256: LIST
25257: PUSH
25258: EMPTY
25259: LIST
25260: LIST
25261: PPUSH
25262: CALL_OW 69
25266: PUSH
25267: LD_EXP 61
25271: PUSH
25272: LD_EXP 60
25276: PUSH
25277: EMPTY
25278: LIST
25279: LIST
25280: DIFF
25281: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 ] [ Difficulty ] then
25282: LD_VAR 0 2
25286: PUSH
25287: LD_INT 6
25289: PUSH
25290: LD_INT 5
25292: PUSH
25293: LD_INT 4
25295: PUSH
25296: EMPTY
25297: LIST
25298: LIST
25299: LIST
25300: PUSH
25301: LD_OWVAR 67
25305: ARRAY
25306: GREATEREQUAL
25307: IFFALSE 25481
// begin x := [ 6 , 5 , 4 ] [ Difficulty ] ;
25309: LD_ADDR_VAR 0 3
25313: PUSH
25314: LD_INT 6
25316: PUSH
25317: LD_INT 5
25319: PUSH
25320: LD_INT 4
25322: PUSH
25323: EMPTY
25324: LIST
25325: LIST
25326: LIST
25327: PUSH
25328: LD_OWVAR 67
25332: ARRAY
25333: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25334: LD_ADDR_VAR 0 1
25338: PUSH
25339: DOUBLE
25340: LD_VAR 0 2
25344: PUSH
25345: LD_VAR 0 3
25349: PUSH
25350: LD_INT 1
25352: PLUS
25353: MINUS
25354: INC
25355: ST_TO_ADDR
25356: LD_INT 1
25358: PUSH
25359: FOR_DOWNTO
25360: IFFALSE 25477
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25362: LD_ADDR_EXP 38
25366: PUSH
25367: LD_EXP 38
25371: PUSH
25372: LD_VAR 0 2
25376: PUSH
25377: LD_VAR 0 1
25381: ARRAY
25382: ADD
25383: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25384: LD_VAR 0 2
25388: PUSH
25389: LD_VAR 0 1
25393: ARRAY
25394: PPUSH
25395: CALL_OW 310
25399: IFFALSE 25416
// ComExitBuilding ( tmp [ i ] ) ;
25401: LD_VAR 0 2
25405: PUSH
25406: LD_VAR 0 1
25410: ARRAY
25411: PPUSH
25412: CALL_OW 122
// if IsInUnit ( i ) then
25416: LD_VAR 0 1
25420: PPUSH
25421: CALL_OW 310
25425: IFFALSE 25442
// ComExitVehicle ( tmp [ i ] ) ;
25427: LD_VAR 0 2
25431: PUSH
25432: LD_VAR 0 1
25436: ARRAY
25437: PPUSH
25438: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25442: LD_VAR 0 2
25446: PUSH
25447: LD_VAR 0 1
25451: ARRAY
25452: PPUSH
25453: LD_INT 34
25455: PUSH
25456: LD_INT 0
25458: PPUSH
25459: LD_INT 6
25461: PPUSH
25462: CALL_OW 12
25466: PLUS
25467: PPUSH
25468: LD_INT 1
25470: PPUSH
25471: CALL_OW 171
// end ;
25475: GO 25359
25477: POP
25478: POP
// end else
25479: GO 25491
// x := tmp ;
25481: LD_ADDR_VAR 0 3
25485: PUSH
25486: LD_VAR 0 2
25490: ST_TO_ADDR
// for i := tmp downto tmp - x do
25491: LD_ADDR_VAR 0 1
25495: PUSH
25496: DOUBLE
25497: LD_VAR 0 2
25501: INC
25502: ST_TO_ADDR
25503: LD_VAR 0 2
25507: PUSH
25508: LD_VAR 0 3
25512: MINUS
25513: PUSH
25514: FOR_DOWNTO
25515: IFFALSE 25569
// begin if IsInUnit ( tmp [ i ] ) then
25517: LD_VAR 0 2
25521: PUSH
25522: LD_VAR 0 1
25526: ARRAY
25527: PPUSH
25528: CALL_OW 310
25532: IFFALSE 25549
// ComExitVehicle ( tmp [ i ] ) ;
25534: LD_VAR 0 2
25538: PUSH
25539: LD_VAR 0 1
25543: ARRAY
25544: PPUSH
25545: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25549: LD_VAR 0 2
25553: PUSH
25554: LD_VAR 0 1
25558: ARRAY
25559: PPUSH
25560: LD_INT 1
25562: PPUSH
25563: CALL_OW 235
// end ;
25567: GO 25514
25569: POP
25570: POP
// SetSide ( Kurt , 1 ) ;
25571: LD_EXP 60
25575: PPUSH
25576: LD_INT 1
25578: PPUSH
25579: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25583: LD_INT 22
25585: PUSH
25586: LD_INT 8
25588: PUSH
25589: EMPTY
25590: LIST
25591: LIST
25592: PUSH
25593: LD_INT 21
25595: PUSH
25596: LD_INT 3
25598: PUSH
25599: EMPTY
25600: LIST
25601: LIST
25602: PUSH
25603: EMPTY
25604: LIST
25605: LIST
25606: PPUSH
25607: CALL_OW 69
25611: PPUSH
25612: LD_INT 1
25614: PPUSH
25615: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25619: LD_INT 8
25621: PPUSH
25622: LD_INT 1
25624: PPUSH
25625: LD_INT 1
25627: PPUSH
25628: LD_INT 1
25630: PPUSH
25631: CALL_OW 80
// wait ( 1 1$20 ) ;
25635: LD_INT 2800
25637: PPUSH
25638: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25642: LD_EXP 62
25646: PPUSH
25647: LD_INT 37
25649: PPUSH
25650: LD_INT 1
25652: PPUSH
25653: LD_INT 0
25655: PPUSH
25656: CALL_OW 48
// wait ( 0 0$1 ) ;
25660: LD_INT 35
25662: PPUSH
25663: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25667: LD_EXP 62
25671: PPUSH
25672: LD_INT 60
25674: PPUSH
25675: LD_INT 95
25677: PPUSH
25678: CALL_OW 111
// end ;
25682: PPOPN 3
25684: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25685: LD_EXP 38
25689: IFFALSE 25764
25691: GO 25693
25693: DISABLE
25694: LD_INT 0
25696: PPUSH
// begin enable ;
25697: ENABLE
// for i in legionEscapeUnits do
25698: LD_ADDR_VAR 0 1
25702: PUSH
25703: LD_EXP 38
25707: PUSH
25708: FOR_IN
25709: IFFALSE 25762
// begin if IsInArea ( i , legionEscapeArea ) then
25711: LD_VAR 0 1
25715: PPUSH
25716: LD_INT 31
25718: PPUSH
25719: CALL_OW 308
25723: IFFALSE 25736
// RemoveUnit ( i ) else
25725: LD_VAR 0 1
25729: PPUSH
25730: CALL_OW 64
25734: GO 25760
// if not HasTask ( i ) then
25736: LD_VAR 0 1
25740: PPUSH
25741: CALL_OW 314
25745: NOT
25746: IFFALSE 25760
// ComMoveToArea ( i , legionEscapeArea ) ;
25748: LD_VAR 0 1
25752: PPUSH
25753: LD_INT 31
25755: PPUSH
25756: CALL_OW 113
// end ;
25760: GO 25708
25762: POP
25763: POP
// end ;
25764: PPOPN 1
25766: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25767: LD_INT 22
25769: PUSH
25770: LD_INT 8
25772: PUSH
25773: EMPTY
25774: LIST
25775: LIST
25776: PUSH
25777: LD_INT 21
25779: PUSH
25780: LD_INT 1
25782: PUSH
25783: EMPTY
25784: LIST
25785: LIST
25786: PUSH
25787: EMPTY
25788: LIST
25789: LIST
25790: PPUSH
25791: CALL_OW 69
25795: PUSH
25796: LD_INT 0
25798: EQUAL
25799: IFFALSE 25819
25801: GO 25803
25803: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
25804: LD_STRING MlegionOut
25806: PPUSH
25807: CALL_OW 337
// legionDestroyed := true ;
25811: LD_ADDR_EXP 22
25815: PUSH
25816: LD_INT 1
25818: ST_TO_ADDR
// end ;
25819: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25820: LD_INT 1
25822: PPUSH
25823: LD_EXP 62
25827: PPUSH
25828: CALL_OW 292
25832: IFFALSE 26130
25834: GO 25836
25836: DISABLE
25837: LD_INT 0
25839: PPUSH
// begin wait ( 0 0$2 ) ;
25840: LD_INT 70
25842: PPUSH
25843: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25847: LD_EXP 62
25851: PPUSH
25852: CALL_OW 87
// DialogueOn ;
25856: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25860: LD_EXP 39
25864: PPUSH
25865: LD_STRING D14-JMM-1
25867: PPUSH
25868: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25872: LD_EXP 62
25876: PPUSH
25877: LD_STRING D14-Friend-1
25879: PPUSH
25880: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25884: LD_EXP 39
25888: PPUSH
25889: LD_STRING D14-JMM-2
25891: PPUSH
25892: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25896: LD_EXP 62
25900: PPUSH
25901: LD_STRING D14-Friend-2
25903: PPUSH
25904: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25908: LD_EXP 39
25912: PPUSH
25913: LD_STRING D14-JMM-3
25915: PPUSH
25916: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25920: LD_EXP 62
25924: PPUSH
25925: LD_STRING D14-Friend-3
25927: PPUSH
25928: CALL_OW 88
// DialogueOff ;
25932: CALL_OW 7
// dec = Query ( Q14 ) ;
25936: LD_ADDR_VAR 0 1
25940: PUSH
25941: LD_STRING Q14
25943: PPUSH
25944: CALL_OW 97
25948: ST_TO_ADDR
// if dec = 1 then
25949: LD_VAR 0 1
25953: PUSH
25954: LD_INT 1
25956: EQUAL
25957: IFFALSE 25991
// begin DialogueOn ;
25959: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25963: LD_EXP 39
25967: PPUSH
25968: LD_STRING D14a-JMM-1
25970: PPUSH
25971: CALL_OW 88
// DialogueOff ;
25975: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25979: LD_EXP 62
25983: PPUSH
25984: LD_INT 1
25986: PPUSH
25987: CALL_OW 235
// end ; if dec = 2 then
25991: LD_VAR 0 1
25995: PUSH
25996: LD_INT 2
25998: EQUAL
25999: IFFALSE 26052
// begin DialogueOn ;
26001: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26005: LD_EXP 39
26009: PPUSH
26010: LD_STRING D14b-JMM-1
26012: PPUSH
26013: CALL_OW 88
// DialogueOff ;
26017: CALL_OW 7
// wait ( 0 0$1 ) ;
26021: LD_INT 35
26023: PPUSH
26024: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26028: LD_EXP 62
26032: PPUSH
26033: LD_INT 9
26035: PPUSH
26036: LD_INT 2
26038: PPUSH
26039: CALL_OW 111
// AddComHold ( Friend ) ;
26043: LD_EXP 62
26047: PPUSH
26048: CALL_OW 200
// end ; if dec = 3 then
26052: LD_VAR 0 1
26056: PUSH
26057: LD_INT 3
26059: EQUAL
26060: IFFALSE 26130
// begin DialogueOn ;
26062: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26066: LD_EXP 39
26070: PPUSH
26071: LD_STRING D14c-JMM-1
26073: PPUSH
26074: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26078: LD_EXP 62
26082: PPUSH
26083: LD_STRING D14c-Friend-1
26085: PPUSH
26086: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26090: LD_EXP 39
26094: PPUSH
26095: LD_STRING D14c-JMM-2
26097: PPUSH
26098: CALL_OW 88
// DialogueOff ;
26102: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26106: LD_EXP 62
26110: PPUSH
26111: LD_INT 9
26113: PPUSH
26114: LD_INT 2
26116: PPUSH
26117: CALL_OW 111
// AddComHold ( Friend ) ;
26121: LD_EXP 62
26125: PPUSH
26126: CALL_OW 200
// end ; end ;
26130: PPOPN 1
26132: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26133: LD_INT 9
26135: PPUSH
26136: LD_INT 2
26138: PPUSH
26139: CALL_OW 428
26143: PUSH
26144: LD_EXP 62
26148: EQUAL
26149: PUSH
26150: LD_EXP 62
26154: PPUSH
26155: CALL_OW 255
26159: PUSH
26160: LD_INT 8
26162: EQUAL
26163: AND
26164: IFFALSE 26178
26166: GO 26168
26168: DISABLE
// RemoveUnit ( Friend ) ;
26169: LD_EXP 62
26173: PPUSH
26174: CALL_OW 64
26178: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26179: LD_EXP 14
26183: PUSH
26184: LD_INT 31500
26186: GREATEREQUAL
26187: PUSH
26188: LD_EXP 7
26192: AND
26193: PUSH
26194: LD_EXP 2
26198: AND
26199: IFFALSE 26629
26201: GO 26203
26203: DISABLE
26204: LD_INT 0
26206: PPUSH
26207: PPUSH
26208: PPUSH
// begin missionStage := 7 ;
26209: LD_ADDR_EXP 15
26213: PUSH
26214: LD_INT 7
26216: ST_TO_ADDR
// uc_side = 1 ;
26217: LD_ADDR_OWVAR 20
26221: PUSH
26222: LD_INT 1
26224: ST_TO_ADDR
// uc_nation = 1 ;
26225: LD_ADDR_OWVAR 21
26229: PUSH
26230: LD_INT 1
26232: ST_TO_ADDR
// for i = 1 to 5 do
26233: LD_ADDR_VAR 0 1
26237: PUSH
26238: DOUBLE
26239: LD_INT 1
26241: DEC
26242: ST_TO_ADDR
26243: LD_INT 5
26245: PUSH
26246: FOR_TO
26247: IFFALSE 26343
// begin vc_engine = 3 ;
26249: LD_ADDR_OWVAR 39
26253: PUSH
26254: LD_INT 3
26256: ST_TO_ADDR
// vc_control = 3 ;
26257: LD_ADDR_OWVAR 38
26261: PUSH
26262: LD_INT 3
26264: ST_TO_ADDR
// vc_chassis = 3 ;
26265: LD_ADDR_OWVAR 37
26269: PUSH
26270: LD_INT 3
26272: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26273: LD_ADDR_OWVAR 40
26277: PUSH
26278: LD_INT 5
26280: PUSH
26281: LD_INT 9
26283: PUSH
26284: LD_INT 7
26286: PUSH
26287: EMPTY
26288: LIST
26289: LIST
26290: LIST
26291: PUSH
26292: LD_INT 1
26294: PPUSH
26295: LD_INT 3
26297: PPUSH
26298: CALL_OW 12
26302: ARRAY
26303: ST_TO_ADDR
// veh = CreateVehicle ;
26304: LD_ADDR_VAR 0 2
26308: PUSH
26309: CALL_OW 45
26313: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26314: LD_VAR 0 2
26318: PPUSH
26319: LD_INT 1
26321: PPUSH
26322: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26326: LD_VAR 0 2
26330: PPUSH
26331: LD_INT 19
26333: PPUSH
26334: LD_INT 0
26336: PPUSH
26337: CALL_OW 49
// end ;
26341: GO 26246
26343: POP
26344: POP
// vc_engine = 3 ;
26345: LD_ADDR_OWVAR 39
26349: PUSH
26350: LD_INT 3
26352: ST_TO_ADDR
// vc_control = 1 ;
26353: LD_ADDR_OWVAR 38
26357: PUSH
26358: LD_INT 1
26360: ST_TO_ADDR
// vc_chassis = 3 ;
26361: LD_ADDR_OWVAR 37
26365: PUSH
26366: LD_INT 3
26368: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26369: LD_ADDR_OWVAR 40
26373: PUSH
26374: LD_INT 5
26376: PUSH
26377: LD_INT 9
26379: PUSH
26380: LD_INT 7
26382: PUSH
26383: EMPTY
26384: LIST
26385: LIST
26386: LIST
26387: PUSH
26388: LD_INT 1
26390: PPUSH
26391: LD_INT 3
26393: PPUSH
26394: CALL_OW 12
26398: ARRAY
26399: ST_TO_ADDR
// vehG = CreateVehicle ;
26400: LD_ADDR_VAR 0 3
26404: PUSH
26405: CALL_OW 45
26409: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26410: LD_VAR 0 3
26414: PPUSH
26415: LD_INT 1
26417: PPUSH
26418: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26422: LD_VAR 0 3
26426: PPUSH
26427: LD_INT 19
26429: PPUSH
26430: LD_INT 0
26432: PPUSH
26433: CALL_OW 49
// if JMMGirl = 1 then
26437: LD_EXP 7
26441: PUSH
26442: LD_INT 1
26444: EQUAL
26445: IFFALSE 26501
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26447: LD_ADDR_EXP 40
26451: PUSH
26452: LD_STRING Joan
26454: PPUSH
26455: LD_INT 1
26457: PPUSH
26458: LD_STRING 14_
26460: PPUSH
26461: CALL 64894 0 3
26465: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26466: LD_EXP 40
26470: PPUSH
26471: LD_VAR 0 3
26475: PPUSH
26476: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26480: LD_VAR 0 3
26484: PPUSH
26485: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26489: LD_EXP 40
26493: PPUSH
26494: LD_STRING D10BW-Joan-1
26496: PPUSH
26497: CALL_OW 94
// end ; if JMMGirl = 2 then
26501: LD_EXP 7
26505: PUSH
26506: LD_INT 2
26508: EQUAL
26509: IFFALSE 26565
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26511: LD_ADDR_EXP 42
26515: PUSH
26516: LD_STRING Lisa
26518: PPUSH
26519: LD_INT 1
26521: PPUSH
26522: LD_STRING 14_
26524: PPUSH
26525: CALL 64894 0 3
26529: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26530: LD_EXP 42
26534: PPUSH
26535: LD_VAR 0 3
26539: PPUSH
26540: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26544: LD_VAR 0 3
26548: PPUSH
26549: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26553: LD_EXP 42
26557: PPUSH
26558: LD_STRING D10BW-Lisa-1
26560: PPUSH
26561: CALL_OW 94
// end ; if JMMGirl = 3 then
26565: LD_EXP 7
26569: PUSH
26570: LD_INT 3
26572: EQUAL
26573: IFFALSE 26629
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26575: LD_ADDR_EXP 54
26579: PUSH
26580: LD_STRING Connie
26582: PPUSH
26583: LD_INT 1
26585: PPUSH
26586: LD_STRING 14_
26588: PPUSH
26589: CALL 64894 0 3
26593: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26594: LD_EXP 54
26598: PPUSH
26599: LD_VAR 0 3
26603: PPUSH
26604: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26608: LD_VAR 0 3
26612: PPUSH
26613: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26617: LD_EXP 54
26621: PPUSH
26622: LD_STRING D10BW-Con-1
26624: PPUSH
26625: CALL_OW 94
// end ; end ;
26629: PPOPN 3
26631: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26632: LD_EXP 14
26636: PUSH
26637: LD_INT 94500
26639: GREATEREQUAL
26640: IFFALSE 27052
26642: GO 26644
26644: DISABLE
26645: LD_INT 0
26647: PPUSH
26648: PPUSH
26649: PPUSH
// begin tmp := PrepareStevensSquad ;
26650: LD_ADDR_VAR 0 3
26654: PUSH
26655: CALL 2197 0 0
26659: ST_TO_ADDR
// if not tmp then
26660: LD_VAR 0 3
26664: NOT
26665: IFFALSE 26669
// exit ;
26667: GO 27052
// uc_side := 1 ;
26669: LD_ADDR_OWVAR 20
26673: PUSH
26674: LD_INT 1
26676: ST_TO_ADDR
// uc_nation := 1 ;
26677: LD_ADDR_OWVAR 21
26681: PUSH
26682: LD_INT 1
26684: ST_TO_ADDR
// for i in tmp do
26685: LD_ADDR_VAR 0 1
26689: PUSH
26690: LD_VAR 0 3
26694: PUSH
26695: FOR_IN
26696: IFFALSE 26793
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26698: LD_INT 3
26700: PPUSH
26701: LD_INT 3
26703: PPUSH
26704: LD_INT 1
26706: PPUSH
26707: LD_INT 5
26709: PUSH
26710: LD_INT 9
26712: PUSH
26713: LD_INT 7
26715: PUSH
26716: EMPTY
26717: LIST
26718: LIST
26719: LIST
26720: PUSH
26721: LD_INT 1
26723: PPUSH
26724: LD_INT 3
26726: PPUSH
26727: CALL_OW 12
26731: ARRAY
26732: PPUSH
26733: LD_INT 40
26735: PPUSH
26736: CALL 72009 0 5
// veh := CreateVehicle ;
26740: LD_ADDR_VAR 0 2
26744: PUSH
26745: CALL_OW 45
26749: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26750: LD_VAR 0 2
26754: PPUSH
26755: LD_INT 1
26757: PPUSH
26758: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26762: LD_VAR 0 2
26766: PPUSH
26767: LD_INT 19
26769: PPUSH
26770: LD_INT 0
26772: PPUSH
26773: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26777: LD_VAR 0 1
26781: PPUSH
26782: LD_VAR 0 2
26786: PPUSH
26787: CALL_OW 52
// end ;
26791: GO 26695
26793: POP
26794: POP
// missionStage := 8 ;
26795: LD_ADDR_EXP 15
26799: PUSH
26800: LD_INT 8
26802: ST_TO_ADDR
// DialogueOn ;
26803: CALL_OW 6
// if Stevens then
26807: LD_EXP 41
26811: IFFALSE 26925
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26813: LD_EXP 41
26817: PPUSH
26818: CALL_OW 310
26822: PPUSH
26823: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26827: LD_EXP 41
26831: PPUSH
26832: LD_STRING D8-Huck-1
26834: PPUSH
26835: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26839: LD_EXP 39
26843: PPUSH
26844: LD_STRING D8-JMM-1
26846: PPUSH
26847: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26851: LD_EXP 41
26855: PPUSH
26856: LD_STRING D8-Huck-2
26858: PPUSH
26859: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26863: LD_EXP 39
26867: PPUSH
26868: LD_STRING D8-JMM-2
26870: PPUSH
26871: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26875: LD_EXP 41
26879: PPUSH
26880: LD_STRING D8-Huck-3
26882: PPUSH
26883: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26887: LD_EXP 39
26891: PPUSH
26892: LD_STRING D8-JMM-3
26894: PPUSH
26895: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26899: LD_EXP 41
26903: PPUSH
26904: LD_STRING D8-Huck-4
26906: PPUSH
26907: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26911: LD_EXP 39
26915: PPUSH
26916: LD_STRING D8-JMM-4
26918: PPUSH
26919: CALL_OW 88
// end else
26923: GO 27035
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26925: LD_EXP 55
26929: PPUSH
26930: CALL_OW 310
26934: PPUSH
26935: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26939: LD_EXP 55
26943: PPUSH
26944: LD_STRING D8-Huck-1
26946: PPUSH
26947: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26951: LD_EXP 39
26955: PPUSH
26956: LD_STRING D8-JMM-1a
26958: PPUSH
26959: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26963: LD_EXP 55
26967: PPUSH
26968: LD_STRING D8-Huck-2
26970: PPUSH
26971: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26975: LD_EXP 39
26979: PPUSH
26980: LD_STRING D8-JMM-2
26982: PPUSH
26983: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26987: LD_EXP 55
26991: PPUSH
26992: LD_STRING D8-Huck-3
26994: PPUSH
26995: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26999: LD_EXP 39
27003: PPUSH
27004: LD_STRING D8-JMM-3
27006: PPUSH
27007: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27011: LD_EXP 55
27015: PPUSH
27016: LD_STRING D8-Huck-4
27018: PPUSH
27019: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27023: LD_EXP 39
27027: PPUSH
27028: LD_STRING D8-JMM-4
27030: PPUSH
27031: CALL_OW 88
// end ; DialogueOff ;
27035: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27039: LD_INT 25
27041: PPUSH
27042: LD_INT 1
27044: PPUSH
27045: LD_INT 1
27047: PPUSH
27048: CALL_OW 322
// end ;
27052: PPOPN 3
27054: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27055: LD_INT 1
27057: PPUSH
27058: LD_EXP 71
27062: PPUSH
27063: CALL_OW 292
27067: IFFALSE 27318
27069: GO 27071
27071: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27072: LD_EXP 71
27076: PPUSH
27077: CALL_OW 87
// DialogueOn ;
27081: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27085: LD_EXP 39
27089: PPUSH
27090: LD_STRING D10nB-JMM-1
27092: PPUSH
27093: CALL_OW 88
// if BurlakStatus = 1 then
27097: LD_EXP 9
27101: PUSH
27102: LD_INT 1
27104: EQUAL
27105: IFFALSE 27119
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27107: LD_EXP 70
27111: PPUSH
27112: LD_STRING D10nB-Vse-1a
27114: PPUSH
27115: CALL_OW 94
// end ; if BurlakStatus = 0 then
27119: LD_EXP 9
27123: PUSH
27124: LD_INT 0
27126: EQUAL
27127: IFFALSE 27141
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27129: LD_EXP 70
27133: PPUSH
27134: LD_STRING D10nB-Vse-1
27136: PPUSH
27137: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27141: LD_EXP 39
27145: PPUSH
27146: LD_STRING D10nB-JMM-2
27148: PPUSH
27149: CALL_OW 88
// if KappaStatus then
27153: LD_EXP 2
27157: IFFALSE 27171
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27159: LD_EXP 70
27163: PPUSH
27164: LD_STRING D10nB-Vse-5a
27166: PPUSH
27167: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27171: LD_EXP 2
27175: NOT
27176: PUSH
27177: LD_EXP 6
27181: PUSH
27182: LD_INT 0
27184: EQUAL
27185: AND
27186: IFFALSE 27314
// begin if JMMGirl = 1 then
27188: LD_EXP 7
27192: PUSH
27193: LD_INT 1
27195: EQUAL
27196: IFFALSE 27246
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27198: LD_EXP 70
27202: PPUSH
27203: LD_STRING D10nB-Vse-2
27205: PPUSH
27206: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27210: LD_EXP 39
27214: PPUSH
27215: LD_STRING D10nB-JMM-3
27217: PPUSH
27218: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27222: LD_EXP 70
27226: PPUSH
27227: LD_STRING D10nB-Vse-3
27229: PPUSH
27230: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27234: LD_EXP 39
27238: PPUSH
27239: LD_STRING D10nB-JMM-4
27241: PPUSH
27242: CALL_OW 88
// end ; if JMMGirl = 2 then
27246: LD_EXP 7
27250: PUSH
27251: LD_INT 2
27253: EQUAL
27254: IFFALSE 27280
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27256: LD_EXP 70
27260: PPUSH
27261: LD_STRING D10nB-Vse-4
27263: PPUSH
27264: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27268: LD_EXP 39
27272: PPUSH
27273: LD_STRING D10nB-JMM-5
27275: PPUSH
27276: CALL_OW 88
// end ; if JMMGirl = 3 then
27280: LD_EXP 7
27284: PUSH
27285: LD_INT 3
27287: EQUAL
27288: IFFALSE 27314
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27290: LD_EXP 70
27294: PPUSH
27295: LD_STRING D10nB-Vse-5
27297: PPUSH
27298: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27302: LD_EXP 39
27306: PPUSH
27307: LD_STRING D10nB-JMM-6
27309: PPUSH
27310: CALL_OW 88
// end ; end ; DialogueOff ;
27314: CALL_OW 7
// end ;
27318: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27319: LD_EXP 14
27323: PUSH
27324: LD_INT 115500
27326: GREATEREQUAL
27327: IFFALSE 27703
27329: GO 27331
27331: DISABLE
27332: LD_INT 0
27334: PPUSH
// begin missionStage := 10 ;
27335: LD_ADDR_EXP 15
27339: PUSH
27340: LD_INT 10
27342: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27343: LD_ADDR_VAR 0 1
27347: PUSH
27348: LD_INT 22
27350: PUSH
27351: LD_INT 1
27353: PUSH
27354: EMPTY
27355: LIST
27356: LIST
27357: PUSH
27358: LD_INT 23
27360: PUSH
27361: LD_INT 1
27363: PUSH
27364: EMPTY
27365: LIST
27366: LIST
27367: PUSH
27368: LD_INT 26
27370: PUSH
27371: LD_INT 1
27373: PUSH
27374: EMPTY
27375: LIST
27376: LIST
27377: PUSH
27378: LD_INT 3
27380: PUSH
27381: LD_INT 25
27383: PUSH
27384: LD_INT 12
27386: PUSH
27387: EMPTY
27388: LIST
27389: LIST
27390: PUSH
27391: EMPTY
27392: LIST
27393: LIST
27394: PUSH
27395: LD_INT 3
27397: PUSH
27398: LD_INT 25
27400: PUSH
27401: LD_INT 16
27403: PUSH
27404: EMPTY
27405: LIST
27406: LIST
27407: PUSH
27408: EMPTY
27409: LIST
27410: LIST
27411: PUSH
27412: EMPTY
27413: LIST
27414: LIST
27415: LIST
27416: LIST
27417: LIST
27418: PPUSH
27419: CALL_OW 69
27423: PUSH
27424: LD_EXP 39
27428: PUSH
27429: LD_EXP 60
27433: PUSH
27434: LD_EXP 41
27438: PUSH
27439: LD_EXP 55
27443: PUSH
27444: LD_EXP 42
27448: PUSH
27449: LD_EXP 43
27453: PUSH
27454: LD_EXP 44
27458: PUSH
27459: LD_EXP 45
27463: PUSH
27464: LD_EXP 46
27468: PUSH
27469: LD_EXP 47
27473: PUSH
27474: LD_EXP 48
27478: PUSH
27479: LD_EXP 49
27483: PUSH
27484: LD_EXP 50
27488: PUSH
27489: LD_EXP 51
27493: PUSH
27494: LD_EXP 52
27498: PUSH
27499: LD_EXP 53
27503: PUSH
27504: EMPTY
27505: LIST
27506: LIST
27507: LIST
27508: LIST
27509: LIST
27510: LIST
27511: LIST
27512: LIST
27513: LIST
27514: LIST
27515: LIST
27516: LIST
27517: LIST
27518: LIST
27519: LIST
27520: LIST
27521: DIFF
27522: ST_TO_ADDR
// if not tmp and Brown then
27523: LD_VAR 0 1
27527: NOT
27528: PUSH
27529: LD_EXP 47
27533: AND
27534: IFFALSE 27549
// tmp := [ Brown ] ;
27536: LD_ADDR_VAR 0 1
27540: PUSH
27541: LD_EXP 47
27545: PUSH
27546: EMPTY
27547: LIST
27548: ST_TO_ADDR
// DialogueOn ;
27549: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27553: LD_VAR 0 1
27557: PUSH
27558: LD_INT 1
27560: ARRAY
27561: PPUSH
27562: LD_STRING D11-Sol1-1
27564: PPUSH
27565: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27569: LD_EXP 64
27573: PPUSH
27574: LD_STRING D11-Pla-1
27576: PPUSH
27577: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27581: LD_EXP 65
27585: PPUSH
27586: LD_STRING D11-Kov-1
27588: PPUSH
27589: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27593: LD_EXP 64
27597: PPUSH
27598: LD_STRING D11-Pla-2
27600: PPUSH
27601: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27605: LD_VAR 0 1
27609: PUSH
27610: LD_INT 1
27612: ARRAY
27613: PPUSH
27614: LD_STRING D11-Sol1-2
27616: PPUSH
27617: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27621: LD_EXP 39
27625: PPUSH
27626: LD_STRING D11-JMM-2
27628: PPUSH
27629: CALL_OW 88
// DialogueOff ;
27633: CALL_OW 7
// allowBehemothConstruct := true ;
27637: LD_ADDR_EXP 25
27641: PUSH
27642: LD_INT 1
27644: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27645: LD_STRING M4
27647: PPUSH
27648: CALL_OW 337
// BuildBehemoths ;
27652: CALL 7653 0 0
// repeat wait ( 15 15$00 ) ;
27656: LD_INT 31500
27658: PPUSH
27659: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27663: LD_EXP 27
27667: IFFALSE 27671
// break ;
27669: GO 27703
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27671: LD_INT 267
27673: PPUSH
27674: CALL_OW 274
27678: PPUSH
27679: LD_INT 1
27681: PPUSH
27682: CALL_OW 275
27686: PUSH
27687: LD_INT 1000
27689: GREATEREQUAL
27690: IFFALSE 27696
// BuildBehemoths ;
27692: CALL 7653 0 0
// until not behemothBuilders ;
27696: LD_EXP 73
27700: NOT
27701: IFFALSE 27656
// end ;
27703: PPOPN 1
27705: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27706: LD_EXP 73
27710: NOT
27711: PUSH
27712: LD_EXP 28
27716: NOT
27717: AND
27718: PUSH
27719: LD_EXP 25
27723: AND
27724: IFFALSE 27744
27726: GO 27728
27728: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27729: LD_STRING M4a
27731: PPUSH
27732: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27736: LD_ADDR_EXP 27
27740: PUSH
27741: LD_INT 1
27743: ST_TO_ADDR
// end ;
27744: END
// every 0 0$1 trigger behemothDone do
27745: LD_EXP 28
27749: IFFALSE 27761
27751: GO 27753
27753: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27754: LD_STRING M4b
27756: PPUSH
27757: CALL_OW 337
27761: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27762: LD_EXP 29
27766: NOT
27767: IFFALSE 27963
27769: GO 27771
27771: DISABLE
27772: LD_INT 0
27774: PPUSH
27775: PPUSH
// begin enable ;
27776: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27777: LD_ADDR_VAR 0 1
27781: PUSH
27782: LD_INT 3
27784: PPUSH
27785: CALL 107812 0 1
27789: ST_TO_ADDR
// if not tmp and not behemothDone then
27790: LD_VAR 0 1
27794: NOT
27795: PUSH
27796: LD_EXP 28
27800: NOT
27801: AND
27802: IFFALSE 27838
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27804: LD_ADDR_VAR 0 1
27808: PUSH
27809: LD_INT 22
27811: PUSH
27812: LD_INT 3
27814: PUSH
27815: EMPTY
27816: LIST
27817: LIST
27818: PUSH
27819: LD_INT 30
27821: PUSH
27822: LD_INT 37
27824: PUSH
27825: EMPTY
27826: LIST
27827: LIST
27828: PUSH
27829: EMPTY
27830: LIST
27831: LIST
27832: PPUSH
27833: CALL_OW 69
27837: ST_TO_ADDR
// if not tmp then
27838: LD_VAR 0 1
27842: NOT
27843: IFFALSE 27847
// exit ;
27845: GO 27963
// for i in tmp do
27847: LD_ADDR_VAR 0 2
27851: PUSH
27852: LD_VAR 0 1
27856: PUSH
27857: FOR_IN
27858: IFFALSE 27961
// if See ( 1 , i ) then
27860: LD_INT 1
27862: PPUSH
27863: LD_VAR 0 2
27867: PPUSH
27868: CALL_OW 292
27872: IFFALSE 27959
// begin if GetType ( i ) = unit_building then
27874: LD_VAR 0 2
27878: PPUSH
27879: CALL_OW 247
27883: PUSH
27884: LD_INT 3
27886: EQUAL
27887: IFFALSE 27925
// begin CenterNowOnUnits ( i ) ;
27889: LD_VAR 0 2
27893: PPUSH
27894: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27898: LD_EXP 39
27902: PPUSH
27903: LD_STRING D17a-JMM-1
27905: PPUSH
27906: CALL_OW 88
// seeBehemoth := true ;
27910: LD_ADDR_EXP 29
27914: PUSH
27915: LD_INT 1
27917: ST_TO_ADDR
// disable ;
27918: DISABLE
// exit ;
27919: POP
27920: POP
27921: GO 27963
// end else
27923: GO 27959
// begin CenterNowOnUnits ( i ) ;
27925: LD_VAR 0 2
27929: PPUSH
27930: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27934: LD_EXP 39
27938: PPUSH
27939: LD_STRING D17b-JMM-1
27941: PPUSH
27942: CALL_OW 88
// seeBehemoth := true ;
27946: LD_ADDR_EXP 29
27950: PUSH
27951: LD_INT 1
27953: ST_TO_ADDR
// disable ;
27954: DISABLE
// exit ;
27955: POP
27956: POP
27957: GO 27963
// end ; end ;
27959: GO 27857
27961: POP
27962: POP
// end ;
27963: PPOPN 2
27965: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27966: LD_EXP 14
27970: PUSH
27971: LD_INT 116550
27973: GREATEREQUAL
27974: IFFALSE 29150
27976: GO 27978
27978: DISABLE
27979: LD_INT 0
27981: PPUSH
27982: PPUSH
27983: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27984: LD_INT 2
27986: PPUSH
27987: LD_INT 23
27989: PUSH
27990: LD_INT 3
27992: PUSH
27993: LD_INT 3
27995: PUSH
27996: LD_INT 48
27998: PUSH
27999: EMPTY
28000: LIST
28001: LIST
28002: LIST
28003: LIST
28004: PUSH
28005: EMPTY
28006: LIST
28007: PPUSH
28008: CALL 58550 0 2
// repeat wait ( 0 0$1 ) ;
28012: LD_INT 35
28014: PPUSH
28015: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28019: LD_INT 22
28021: PUSH
28022: LD_INT 3
28024: PUSH
28025: EMPTY
28026: LIST
28027: LIST
28028: PUSH
28029: LD_INT 34
28031: PUSH
28032: LD_INT 48
28034: PUSH
28035: EMPTY
28036: LIST
28037: LIST
28038: PUSH
28039: EMPTY
28040: LIST
28041: LIST
28042: PPUSH
28043: CALL_OW 69
28047: IFFALSE 28012
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28049: LD_ADDR_VAR 0 1
28053: PUSH
28054: LD_INT 22
28056: PUSH
28057: LD_INT 3
28059: PUSH
28060: EMPTY
28061: LIST
28062: LIST
28063: PUSH
28064: LD_INT 34
28066: PUSH
28067: LD_INT 48
28069: PUSH
28070: EMPTY
28071: LIST
28072: LIST
28073: PUSH
28074: EMPTY
28075: LIST
28076: LIST
28077: PPUSH
28078: CALL_OW 69
28082: PUSH
28083: LD_INT 1
28085: ARRAY
28086: ST_TO_ADDR
// missionStage := 12 ;
28087: LD_ADDR_EXP 15
28091: PUSH
28092: LD_INT 12
28094: ST_TO_ADDR
// platonovHasBomb := true ;
28095: LD_ADDR_EXP 30
28099: PUSH
28100: LD_INT 1
28102: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28103: LD_VAR 0 1
28107: PPUSH
28108: LD_INT 181
28110: PPUSH
28111: LD_INT 86
28113: PPUSH
28114: CALL_OW 171
// AddComHold ( bomb ) ;
28118: LD_VAR 0 1
28122: PPUSH
28123: CALL_OW 200
// wait ( 0 0$10 ) ;
28127: LD_INT 350
28129: PPUSH
28130: CALL_OW 67
// DialogueOn ;
28134: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28138: LD_EXP 64
28142: PPUSH
28143: LD_STRING D15-Pla-1
28145: PPUSH
28146: CALL_OW 94
// dec = Query ( Q15a ) ;
28150: LD_ADDR_VAR 0 2
28154: PUSH
28155: LD_STRING Q15a
28157: PPUSH
28158: CALL_OW 97
28162: ST_TO_ADDR
// if dec = 1 then
28163: LD_VAR 0 2
28167: PUSH
28168: LD_INT 1
28170: EQUAL
28171: IFFALSE 28194
// begin Say ( JMM , D15a-JMM-1 ) ;
28173: LD_EXP 39
28177: PPUSH
28178: LD_STRING D15a-JMM-1
28180: PPUSH
28181: CALL_OW 88
// YouLost ( Surrender ) ;
28185: LD_STRING Surrender
28187: PPUSH
28188: CALL_OW 104
// exit ;
28192: GO 29150
// end ; if dec = 2 then
28194: LD_VAR 0 2
28198: PUSH
28199: LD_INT 2
28201: EQUAL
28202: IFFALSE 28271
// begin Say ( JMM , D15b-JMM-1 ) ;
28204: LD_EXP 39
28208: PPUSH
28209: LD_STRING D15b-JMM-1
28211: PPUSH
28212: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28216: LD_EXP 64
28220: PPUSH
28221: LD_STRING D15b-Pla-1
28223: PPUSH
28224: CALL_OW 94
// DialogueOff ;
28228: CALL_OW 7
// wait ( 3 3$00 ) ;
28232: LD_INT 6300
28234: PPUSH
28235: CALL_OW 67
// DialogueOn ;
28239: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28243: LD_EXP 39
28247: PPUSH
28248: LD_STRING D15d-JMM-1a
28250: PPUSH
28251: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28255: LD_EXP 64
28259: PPUSH
28260: LD_STRING D15d-Pla-1
28262: PPUSH
28263: CALL_OW 94
// DialogueOff ;
28267: CALL_OW 7
// end ; if dec = 3 then
28271: LD_VAR 0 2
28275: PUSH
28276: LD_INT 3
28278: EQUAL
28279: IFFALSE 28333
// begin Say ( JMM , D15c-JMM-1 ) ;
28281: LD_EXP 39
28285: PPUSH
28286: LD_STRING D15c-JMM-1
28288: PPUSH
28289: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28293: LD_EXP 64
28297: PPUSH
28298: LD_STRING D15c-Pla-1
28300: PPUSH
28301: CALL_OW 94
// DialogueOff ;
28305: CALL_OW 7
// wait ( 0 0$15 ) ;
28309: LD_INT 525
28311: PPUSH
28312: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28316: LD_VAR 0 1
28320: PPUSH
28321: LD_INT 60
28323: PPUSH
28324: LD_INT 95
28326: PPUSH
28327: CALL_OW 116
// exit ;
28331: GO 29150
// end ; if dec = 4 then
28333: LD_VAR 0 2
28337: PUSH
28338: LD_INT 4
28340: EQUAL
28341: IFFALSE 28371
// begin Say ( JMM , D15d-JMM-1 ) ;
28343: LD_EXP 39
28347: PPUSH
28348: LD_STRING D15d-JMM-1
28350: PPUSH
28351: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28355: LD_EXP 64
28359: PPUSH
28360: LD_STRING D15d-Pla-1
28362: PPUSH
28363: CALL_OW 94
// DialogueOff ;
28367: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28371: LD_EXP 62
28375: PPUSH
28376: CALL_OW 302
28380: PUSH
28381: LD_EXP 62
28385: PPUSH
28386: CALL_OW 255
28390: PUSH
28391: LD_INT 1
28393: EQUAL
28394: AND
28395: PUSH
28396: LD_INT 22
28398: PUSH
28399: LD_INT 1
28401: PUSH
28402: EMPTY
28403: LIST
28404: LIST
28405: PUSH
28406: LD_INT 34
28408: PUSH
28409: LD_INT 8
28411: PUSH
28412: EMPTY
28413: LIST
28414: LIST
28415: PUSH
28416: EMPTY
28417: LIST
28418: LIST
28419: PPUSH
28420: CALL_OW 69
28424: NOT
28425: AND
28426: IFFALSE 29051
// begin SetSide ( Friend , 8 ) ;
28428: LD_EXP 62
28432: PPUSH
28433: LD_INT 8
28435: PPUSH
28436: CALL_OW 235
// if IsInUnit ( Friend ) then
28440: LD_EXP 62
28444: PPUSH
28445: CALL_OW 310
28449: IFFALSE 28460
// ComExitBuilding ( Friend ) ;
28451: LD_EXP 62
28455: PPUSH
28456: CALL_OW 122
// if IsDriver ( Friend ) then
28460: LD_EXP 62
28464: PPUSH
28465: CALL 105489 0 1
28469: IFFALSE 28480
// ComExitVehicle ( Friend ) ;
28471: LD_EXP 62
28475: PPUSH
28476: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28480: LD_EXP 62
28484: PPUSH
28485: LD_INT 9
28487: PPUSH
28488: LD_INT 2
28490: PPUSH
28491: CALL_OW 171
// wait ( 0 0$05 ) ;
28495: LD_INT 175
28497: PPUSH
28498: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28502: LD_EXP 62
28506: PPUSH
28507: CALL_OW 87
// DialogueOn ;
28511: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28515: LD_EXP 39
28519: PPUSH
28520: LD_STRING D16-JMM-1
28522: PPUSH
28523: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28527: LD_EXP 62
28531: PPUSH
28532: LD_STRING D16-Friend-1
28534: PPUSH
28535: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28539: LD_EXP 39
28543: PPUSH
28544: LD_STRING D16-JMM-2
28546: PPUSH
28547: CALL_OW 88
// DialogueOff ;
28551: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28555: LD_EXP 62
28559: PPUSH
28560: LD_INT 1
28562: PPUSH
28563: CALL_OW 235
// ComHold ( Friend ) ;
28567: LD_EXP 62
28571: PPUSH
28572: CALL_OW 140
// wait ( 0 0$20 ) ;
28576: LD_INT 700
28578: PPUSH
28579: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28583: LD_EXP 62
28587: PPUSH
28588: LD_INT 9
28590: PPUSH
28591: LD_INT 2
28593: PPUSH
28594: CALL_OW 297
28598: PUSH
28599: LD_INT 30
28601: LESS
28602: IFFALSE 28671
// begin SetSide ( Friend , 8 ) ;
28604: LD_EXP 62
28608: PPUSH
28609: LD_INT 8
28611: PPUSH
28612: CALL_OW 235
// if IsInUnit ( Friend ) then
28616: LD_EXP 62
28620: PPUSH
28621: CALL_OW 310
28625: IFFALSE 28636
// ComExitBuilding ( Friend ) ;
28627: LD_EXP 62
28631: PPUSH
28632: CALL_OW 122
// if IsDriver ( Friend ) then
28636: LD_EXP 62
28640: PPUSH
28641: CALL 105489 0 1
28645: IFFALSE 28656
// ComExitVehicle ( Friend ) ;
28647: LD_EXP 62
28651: PPUSH
28652: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28656: LD_EXP 62
28660: PPUSH
28661: LD_INT 9
28663: PPUSH
28664: LD_INT 2
28666: PPUSH
28667: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28671: LD_INT 1050
28673: PPUSH
28674: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28678: LD_INT 22
28680: PUSH
28681: LD_INT 1
28683: PUSH
28684: EMPTY
28685: LIST
28686: LIST
28687: PUSH
28688: LD_INT 34
28690: PUSH
28691: LD_INT 8
28693: PUSH
28694: EMPTY
28695: LIST
28696: LIST
28697: PUSH
28698: EMPTY
28699: LIST
28700: LIST
28701: PPUSH
28702: CALL_OW 69
28706: NOT
28707: IFFALSE 29029
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28709: LD_ADDR_VAR 0 3
28713: PUSH
28714: LD_INT 22
28716: PUSH
28717: LD_INT 1
28719: PUSH
28720: EMPTY
28721: LIST
28722: LIST
28723: PUSH
28724: LD_INT 26
28726: PUSH
28727: LD_INT 1
28729: PUSH
28730: EMPTY
28731: LIST
28732: LIST
28733: PUSH
28734: LD_INT 3
28736: PUSH
28737: LD_INT 25
28739: PUSH
28740: LD_INT 12
28742: PUSH
28743: EMPTY
28744: LIST
28745: LIST
28746: PUSH
28747: LD_INT 25
28749: PUSH
28750: LD_INT 16
28752: PUSH
28753: EMPTY
28754: LIST
28755: LIST
28756: PUSH
28757: EMPTY
28758: LIST
28759: LIST
28760: LIST
28761: PUSH
28762: EMPTY
28763: LIST
28764: LIST
28765: LIST
28766: PPUSH
28767: CALL_OW 69
28771: PUSH
28772: LD_EXP 39
28776: PUSH
28777: LD_EXP 41
28781: PUSH
28782: LD_EXP 55
28786: PUSH
28787: LD_EXP 42
28791: PUSH
28792: LD_EXP 43
28796: PUSH
28797: LD_EXP 44
28801: PUSH
28802: LD_EXP 45
28806: PUSH
28807: LD_EXP 46
28811: PUSH
28812: LD_EXP 47
28816: PUSH
28817: LD_EXP 48
28821: PUSH
28822: LD_EXP 49
28826: PUSH
28827: LD_EXP 50
28831: PUSH
28832: LD_EXP 51
28836: PUSH
28837: LD_EXP 52
28841: PUSH
28842: LD_EXP 53
28846: PUSH
28847: EMPTY
28848: LIST
28849: LIST
28850: LIST
28851: LIST
28852: LIST
28853: LIST
28854: LIST
28855: LIST
28856: LIST
28857: LIST
28858: LIST
28859: LIST
28860: LIST
28861: LIST
28862: LIST
28863: DIFF
28864: ST_TO_ADDR
// DialogueOn ;
28865: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28869: LD_EXP 64
28873: PPUSH
28874: LD_STRING D16a-Pla-1
28876: PPUSH
28877: CALL_OW 94
// if Stevens then
28881: LD_EXP 41
28885: IFFALSE 28901
// Say ( Stevens , D16a-Huck-1 ) else
28887: LD_EXP 41
28891: PPUSH
28892: LD_STRING D16a-Huck-1
28894: PPUSH
28895: CALL_OW 88
28899: GO 28943
// if Baker then
28901: LD_EXP 55
28905: IFFALSE 28921
// Say ( Baker , D16a-Huck-1 ) else
28907: LD_EXP 55
28911: PPUSH
28912: LD_STRING D16a-Huck-1
28914: PPUSH
28915: CALL_OW 88
28919: GO 28943
// if tmp then
28921: LD_VAR 0 3
28925: IFFALSE 28943
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28927: LD_VAR 0 3
28931: PUSH
28932: LD_INT 1
28934: ARRAY
28935: PPUSH
28936: LD_STRING D16a-Sol1-1
28938: PPUSH
28939: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28943: LD_EXP 62
28947: PPUSH
28948: CALL_OW 255
28952: PUSH
28953: LD_INT 8
28955: EQUAL
28956: IFFALSE 28972
// Say ( JMM , D16a-JMM-1 ) else
28958: LD_EXP 39
28962: PPUSH
28963: LD_STRING D16a-JMM-1
28965: PPUSH
28966: CALL_OW 88
28970: GO 29008
// begin Say ( JMM , D16a-JMM-1a ) ;
28972: LD_EXP 39
28976: PPUSH
28977: LD_STRING D16a-JMM-1a
28979: PPUSH
28980: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28984: LD_EXP 62
28988: PPUSH
28989: LD_STRING D16a-Friend-1
28991: PPUSH
28992: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28996: LD_EXP 62
29000: PPUSH
29001: LD_INT 3
29003: PPUSH
29004: CALL_OW 235
// end ; DialogueOff ;
29008: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29012: LD_VAR 0 1
29016: PPUSH
29017: LD_INT 60
29019: PPUSH
29020: LD_INT 95
29022: PPUSH
29023: CALL_OW 116
// end else
29027: GO 29049
// begin DialogueOn ;
29029: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29033: LD_EXP 64
29037: PPUSH
29038: LD_STRING D16c-Pla-
29040: PPUSH
29041: CALL_OW 94
// DialogueOff ;
29045: CALL_OW 7
// end ; end else
29049: GO 29150
// begin wait ( 3 3$00 ) ;
29051: LD_INT 6300
29053: PPUSH
29054: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29058: LD_INT 22
29060: PUSH
29061: LD_INT 1
29063: PUSH
29064: EMPTY
29065: LIST
29066: LIST
29067: PUSH
29068: LD_INT 34
29070: PUSH
29071: LD_INT 8
29073: PUSH
29074: EMPTY
29075: LIST
29076: LIST
29077: PUSH
29078: EMPTY
29079: LIST
29080: LIST
29081: PPUSH
29082: CALL_OW 69
29086: NOT
29087: IFFALSE 29130
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29089: LD_EXP 64
29093: PPUSH
29094: LD_STRING D16b-Pla-1
29096: PPUSH
29097: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29101: LD_EXP 39
29105: PPUSH
29106: LD_STRING D16b-JMM-
29108: PPUSH
29109: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29113: LD_VAR 0 1
29117: PPUSH
29118: LD_INT 60
29120: PPUSH
29121: LD_INT 95
29123: PPUSH
29124: CALL_OW 116
// end else
29128: GO 29150
// begin DialogueOn ;
29130: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29134: LD_EXP 64
29138: PPUSH
29139: LD_STRING D16c-Pla-
29141: PPUSH
29142: CALL_OW 94
// DialogueOff ;
29146: CALL_OW 7
// end ; end ; end ;
29150: PPOPN 3
29152: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29153: LD_EXP 14
29157: PUSH
29158: LD_INT 126000
29160: GREATEREQUAL
29161: PUSH
29162: LD_EXP 23
29166: NOT
29167: AND
29168: PUSH
29169: LD_EXP 74
29173: PPUSH
29174: CALL_OW 302
29178: AND
29179: IFFALSE 29537
29181: GO 29183
29183: DISABLE
29184: LD_INT 0
29186: PPUSH
// begin missionStage = 11 ;
29187: LD_ADDR_EXP 15
29191: PUSH
29192: LD_INT 11
29194: ST_TO_ADDR
// DialogueOn ;
29195: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29199: LD_EXP 74
29203: PPUSH
29204: LD_STRING D9-Roth-1
29206: PPUSH
29207: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29211: LD_EXP 39
29215: PPUSH
29216: LD_STRING D9-JMM-1
29218: PPUSH
29219: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29223: LD_EXP 74
29227: PPUSH
29228: LD_STRING D9-Roth-2
29230: PPUSH
29231: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29235: LD_EXP 74
29239: PPUSH
29240: LD_STRING D9-Roth-2a
29242: PPUSH
29243: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29247: LD_EXP 64
29251: PPUSH
29252: LD_STRING D9-Pla-2
29254: PPUSH
29255: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29259: LD_EXP 74
29263: PPUSH
29264: LD_STRING D9-Roth-3
29266: PPUSH
29267: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29271: LD_EXP 64
29275: PPUSH
29276: LD_STRING D9-Pla-3
29278: PPUSH
29279: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29283: LD_EXP 74
29287: PPUSH
29288: LD_STRING D9-Roth-4
29290: PPUSH
29291: CALL_OW 94
// dec = Query ( Q9 ) ;
29295: LD_ADDR_VAR 0 1
29299: PUSH
29300: LD_STRING Q9
29302: PPUSH
29303: CALL_OW 97
29307: ST_TO_ADDR
// if dec = 1 then
29308: LD_VAR 0 1
29312: PUSH
29313: LD_INT 1
29315: EQUAL
29316: IFFALSE 29330
// SayRadio ( Roth , D9a-Roth-1 ) ;
29318: LD_EXP 74
29322: PPUSH
29323: LD_STRING D9a-Roth-1
29325: PPUSH
29326: CALL_OW 94
// if dec = 2 then
29330: LD_VAR 0 1
29334: PUSH
29335: LD_INT 2
29337: EQUAL
29338: IFFALSE 29364
// begin Say ( JMM , D9b-JMM-1 ) ;
29340: LD_EXP 39
29344: PPUSH
29345: LD_STRING D9b-JMM-1
29347: PPUSH
29348: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29352: LD_EXP 74
29356: PPUSH
29357: LD_STRING D9b-Roth-1
29359: PPUSH
29360: CALL_OW 94
// end ; if dec = 3 then
29364: LD_VAR 0 1
29368: PUSH
29369: LD_INT 3
29371: EQUAL
29372: IFFALSE 29434
// begin Say ( JMM , D9c-JMM-1 ) ;
29374: LD_EXP 39
29378: PPUSH
29379: LD_STRING D9c-JMM-1
29381: PPUSH
29382: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29386: LD_EXP 74
29390: PPUSH
29391: LD_STRING D9c-Roth-1
29393: PPUSH
29394: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29398: LD_EXP 39
29402: PPUSH
29403: LD_STRING D9c-JMM-2
29405: PPUSH
29406: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29410: LD_EXP 74
29414: PPUSH
29415: LD_STRING D9c-Roth-2
29417: PPUSH
29418: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29422: LD_EXP 39
29426: PPUSH
29427: LD_STRING D9c-JMM-3
29429: PPUSH
29430: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29434: LD_EXP 74
29438: PPUSH
29439: LD_STRING D9c-Roth-3
29441: PPUSH
29442: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29446: LD_EXP 74
29450: PPUSH
29451: LD_STRING D9cont-Roth-1
29453: PPUSH
29454: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29458: LD_EXP 39
29462: PPUSH
29463: LD_STRING D9cont-JMM-1
29465: PPUSH
29466: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29470: LD_EXP 74
29474: PPUSH
29475: LD_STRING D9cont-Roth-2
29477: PPUSH
29478: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29482: LD_EXP 39
29486: PPUSH
29487: LD_STRING D9cont-JMM-2
29489: PPUSH
29490: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29494: LD_EXP 74
29498: PPUSH
29499: LD_STRING D9cont-Roth-3
29501: PPUSH
29502: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29506: LD_EXP 39
29510: PPUSH
29511: LD_STRING D9cont-JMM-3
29513: PPUSH
29514: CALL_OW 88
// DialogueOff ;
29518: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29522: LD_STRING M3
29524: PPUSH
29525: CALL_OW 337
// allianceActive := true ;
29529: LD_ADDR_EXP 31
29533: PUSH
29534: LD_INT 1
29536: ST_TO_ADDR
// end ;
29537: PPOPN 1
29539: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29540: LD_EXP 64
29544: PPUSH
29545: CALL_OW 301
29549: PUSH
29550: LD_EXP 67
29554: PPUSH
29555: CALL_OW 301
29559: AND
29560: PUSH
29561: LD_INT 22
29563: PUSH
29564: LD_INT 3
29566: PUSH
29567: EMPTY
29568: LIST
29569: LIST
29570: PUSH
29571: LD_INT 21
29573: PUSH
29574: LD_INT 1
29576: PUSH
29577: EMPTY
29578: LIST
29579: LIST
29580: PUSH
29581: LD_INT 50
29583: PUSH
29584: EMPTY
29585: LIST
29586: PUSH
29587: EMPTY
29588: LIST
29589: LIST
29590: LIST
29591: PPUSH
29592: CALL_OW 69
29596: PUSH
29597: LD_INT 7
29599: PUSH
29600: LD_INT 8
29602: PUSH
29603: LD_INT 9
29605: PUSH
29606: EMPTY
29607: LIST
29608: LIST
29609: LIST
29610: PUSH
29611: LD_OWVAR 67
29615: ARRAY
29616: LESS
29617: AND
29618: IFFALSE 30389
29620: GO 29622
29622: DISABLE
29623: LD_INT 0
29625: PPUSH
29626: PPUSH
29627: PPUSH
29628: PPUSH
// begin MC_Kill ( 1 ) ;
29629: LD_INT 1
29631: PPUSH
29632: CALL 35090 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29636: LD_INT 1
29638: PPUSH
29639: LD_INT 3
29641: PPUSH
29642: LD_INT 1
29644: PPUSH
29645: LD_INT 1
29647: PPUSH
29648: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29652: LD_ADDR_VAR 0 1
29656: PUSH
29657: LD_INT 22
29659: PUSH
29660: LD_INT 3
29662: PUSH
29663: EMPTY
29664: LIST
29665: LIST
29666: PUSH
29667: LD_INT 21
29669: PUSH
29670: LD_INT 1
29672: PUSH
29673: EMPTY
29674: LIST
29675: LIST
29676: PUSH
29677: LD_INT 24
29679: PUSH
29680: LD_INT 900
29682: PUSH
29683: EMPTY
29684: LIST
29685: LIST
29686: PUSH
29687: EMPTY
29688: LIST
29689: LIST
29690: LIST
29691: PPUSH
29692: CALL_OW 69
29696: PUSH
29697: FOR_IN
29698: IFFALSE 29729
// if GetSex ( i ) = sex_male then
29700: LD_VAR 0 1
29704: PPUSH
29705: CALL_OW 258
29709: PUSH
29710: LD_INT 1
29712: EQUAL
29713: IFFALSE 29727
// begin tmp = i ;
29715: LD_ADDR_VAR 0 2
29719: PUSH
29720: LD_VAR 0 1
29724: ST_TO_ADDR
// break ;
29725: GO 29729
// end ;
29727: GO 29697
29729: POP
29730: POP
// if tmp = 0 then
29731: LD_VAR 0 2
29735: PUSH
29736: LD_INT 0
29738: EQUAL
29739: IFFALSE 29793
// begin uc_side = 3 ;
29741: LD_ADDR_OWVAR 20
29745: PUSH
29746: LD_INT 3
29748: ST_TO_ADDR
// uc_nation = 3 ;
29749: LD_ADDR_OWVAR 21
29753: PUSH
29754: LD_INT 3
29756: ST_TO_ADDR
// hc_name =  ;
29757: LD_ADDR_OWVAR 26
29761: PUSH
29762: LD_STRING 
29764: ST_TO_ADDR
// hc_gallery =  ;
29765: LD_ADDR_OWVAR 33
29769: PUSH
29770: LD_STRING 
29772: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29773: LD_INT 1
29775: PPUSH
29776: LD_INT 10
29778: PPUSH
29779: CALL_OW 381
// tmp = CreateHuman ;
29783: LD_ADDR_VAR 0 2
29787: PUSH
29788: CALL_OW 44
29792: ST_TO_ADDR
// end ; DialogueOn ;
29793: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29797: LD_VAR 0 2
29801: PPUSH
29802: LD_STRING DSurrenderRussians-RSol1-1a
29804: PPUSH
29805: CALL_OW 94
// DialogueOff ;
29809: CALL_OW 7
// russianDestroyed := true ;
29813: LD_ADDR_EXP 21
29817: PUSH
29818: LD_INT 1
29820: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29821: LD_INT 22
29823: PUSH
29824: LD_INT 3
29826: PUSH
29827: EMPTY
29828: LIST
29829: LIST
29830: PUSH
29831: LD_INT 21
29833: PUSH
29834: LD_INT 1
29836: PUSH
29837: EMPTY
29838: LIST
29839: LIST
29840: PUSH
29841: EMPTY
29842: LIST
29843: LIST
29844: PPUSH
29845: CALL_OW 69
29849: PPUSH
29850: CALL_OW 122
// wait ( 0 0$1 ) ;
29854: LD_INT 35
29856: PPUSH
29857: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
29861: LD_INT 22
29863: PUSH
29864: LD_INT 3
29866: PUSH
29867: EMPTY
29868: LIST
29869: LIST
29870: PUSH
29871: LD_INT 21
29873: PUSH
29874: LD_INT 1
29876: PUSH
29877: EMPTY
29878: LIST
29879: LIST
29880: PUSH
29881: EMPTY
29882: LIST
29883: LIST
29884: PPUSH
29885: CALL_OW 69
29889: PPUSH
29890: LD_INT 25
29892: PPUSH
29893: CALL_OW 173
// wait ( 0 0$10 ) ;
29897: LD_INT 350
29899: PPUSH
29900: CALL_OW 67
// PrepareOmarInvasion ;
29904: CALL 13863 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
29908: LD_ADDR_VAR 0 2
29912: PUSH
29913: LD_EXP 92
29917: PPUSH
29918: CALL_OW 250
29922: PUSH
29923: LD_EXP 92
29927: PPUSH
29928: CALL_OW 251
29932: PUSH
29933: EMPTY
29934: LIST
29935: LIST
29936: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
29937: LD_VAR 0 2
29941: PUSH
29942: LD_INT 1
29944: ARRAY
29945: PPUSH
29946: LD_VAR 0 2
29950: PUSH
29951: LD_INT 2
29953: ARRAY
29954: PPUSH
29955: LD_INT 1
29957: PPUSH
29958: LD_INT 8
29960: NEG
29961: PPUSH
29962: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29966: LD_EXP 92
29970: PPUSH
29971: CALL_OW 87
// DialogueOn ;
29975: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29979: LD_EXP 39
29983: PPUSH
29984: LD_STRING D19-JMM-1
29986: PPUSH
29987: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29991: LD_ADDR_VAR 0 3
29995: PUSH
29996: LD_INT 22
29998: PUSH
29999: LD_INT 1
30001: PUSH
30002: EMPTY
30003: LIST
30004: LIST
30005: PUSH
30006: LD_INT 26
30008: PUSH
30009: LD_INT 1
30011: PUSH
30012: EMPTY
30013: LIST
30014: LIST
30015: PUSH
30016: LD_INT 2
30018: PUSH
30019: LD_INT 25
30021: PUSH
30022: LD_INT 1
30024: PUSH
30025: EMPTY
30026: LIST
30027: LIST
30028: PUSH
30029: LD_INT 25
30031: PUSH
30032: LD_INT 2
30034: PUSH
30035: EMPTY
30036: LIST
30037: LIST
30038: PUSH
30039: LD_INT 25
30041: PUSH
30042: LD_INT 3
30044: PUSH
30045: EMPTY
30046: LIST
30047: LIST
30048: PUSH
30049: LD_INT 25
30051: PUSH
30052: LD_INT 4
30054: PUSH
30055: EMPTY
30056: LIST
30057: LIST
30058: PUSH
30059: LD_INT 25
30061: PUSH
30062: LD_INT 5
30064: PUSH
30065: EMPTY
30066: LIST
30067: LIST
30068: PUSH
30069: LD_INT 25
30071: PUSH
30072: LD_INT 8
30074: PUSH
30075: EMPTY
30076: LIST
30077: LIST
30078: PUSH
30079: EMPTY
30080: LIST
30081: LIST
30082: LIST
30083: LIST
30084: LIST
30085: LIST
30086: LIST
30087: PUSH
30088: EMPTY
30089: LIST
30090: LIST
30091: LIST
30092: PPUSH
30093: CALL_OW 69
30097: PUSH
30098: LD_EXP 39
30102: PUSH
30103: LD_EXP 40
30107: PUSH
30108: LD_EXP 41
30112: PUSH
30113: LD_EXP 42
30117: PUSH
30118: LD_EXP 43
30122: PUSH
30123: LD_EXP 44
30127: PUSH
30128: LD_EXP 45
30132: PUSH
30133: LD_EXP 46
30137: PUSH
30138: LD_EXP 47
30142: PUSH
30143: LD_EXP 48
30147: PUSH
30148: LD_EXP 49
30152: PUSH
30153: LD_EXP 50
30157: PUSH
30158: LD_EXP 51
30162: PUSH
30163: LD_EXP 52
30167: PUSH
30168: LD_EXP 53
30172: PUSH
30173: LD_EXP 54
30177: PUSH
30178: LD_EXP 55
30182: PUSH
30183: EMPTY
30184: LIST
30185: LIST
30186: LIST
30187: LIST
30188: LIST
30189: LIST
30190: LIST
30191: LIST
30192: LIST
30193: LIST
30194: LIST
30195: LIST
30196: LIST
30197: LIST
30198: LIST
30199: LIST
30200: LIST
30201: DIFF
30202: ST_TO_ADDR
// if tmp2 then
30203: LD_VAR 0 3
30207: IFFALSE 30225
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30209: LD_VAR 0 3
30213: PUSH
30214: LD_INT 1
30216: ARRAY
30217: PPUSH
30218: LD_STRING D19-Sol1-1
30220: PPUSH
30221: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30225: LD_EXP 39
30229: PPUSH
30230: LD_STRING D19-JMM-2
30232: PPUSH
30233: CALL_OW 88
// DialogueOff ;
30237: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30241: LD_VAR 0 2
30245: PUSH
30246: LD_INT 1
30248: ARRAY
30249: PPUSH
30250: LD_VAR 0 2
30254: PUSH
30255: LD_INT 2
30257: ARRAY
30258: PPUSH
30259: LD_INT 1
30261: PPUSH
30262: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30266: LD_STRING M5
30268: PPUSH
30269: CALL_OW 337
// omarOnMotherLode := false ;
30273: LD_ADDR_VAR 0 4
30277: PUSH
30278: LD_INT 0
30280: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30281: LD_INT 35
30283: PPUSH
30284: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30288: LD_EXP 92
30292: PPUSH
30293: LD_INT 215
30295: PPUSH
30296: LD_INT 100
30298: PPUSH
30299: CALL_OW 297
30303: PUSH
30304: LD_INT 10
30306: LESS
30307: PUSH
30308: LD_VAR 0 4
30312: NOT
30313: AND
30314: IFFALSE 30348
// begin omarOnMotherLode := true ;
30316: LD_ADDR_VAR 0 4
30320: PUSH
30321: LD_INT 1
30323: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30324: LD_EXP 39
30328: PPUSH
30329: LD_STRING D19b-JMM-1
30331: PPUSH
30332: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30336: LD_EXP 92
30340: PPUSH
30341: LD_STRING DOmarContam-Omar-1
30343: PPUSH
30344: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30348: LD_EXP 92
30352: PPUSH
30353: CALL_OW 301
30357: IFFALSE 30281
// Say ( JMM , D19a-JMM-1 ) ;
30359: LD_EXP 39
30363: PPUSH
30364: LD_STRING D19a-JMM-1
30366: PPUSH
30367: CALL_OW 88
// if Heike then
30371: LD_EXP 93
30375: IFFALSE 30389
// Say ( Heike , D19a-Hke-1 ) ;
30377: LD_EXP 93
30381: PPUSH
30382: LD_STRING D19a-Hke-1
30384: PPUSH
30385: CALL_OW 88
// end ;
30389: PPOPN 4
30391: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30392: LD_INT 22
30394: PUSH
30395: LD_INT 3
30397: PUSH
30398: EMPTY
30399: LIST
30400: LIST
30401: PUSH
30402: LD_INT 21
30404: PUSH
30405: LD_INT 1
30407: PUSH
30408: EMPTY
30409: LIST
30410: LIST
30411: PUSH
30412: EMPTY
30413: LIST
30414: LIST
30415: PPUSH
30416: CALL_OW 69
30420: PUSH
30421: LD_EXP 21
30425: AND
30426: IFFALSE 30494
30428: GO 30430
30430: DISABLE
30431: LD_INT 0
30433: PPUSH
30434: PPUSH
// begin enable ;
30435: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30436: LD_ADDR_VAR 0 2
30440: PUSH
30441: LD_INT 25
30443: PPUSH
30444: LD_INT 22
30446: PUSH
30447: LD_INT 3
30449: PUSH
30450: EMPTY
30451: LIST
30452: LIST
30453: PPUSH
30454: CALL_OW 70
30458: ST_TO_ADDR
// if not tmp then
30459: LD_VAR 0 2
30463: NOT
30464: IFFALSE 30468
// exit ;
30466: GO 30494
// for i in tmp do
30468: LD_ADDR_VAR 0 1
30472: PUSH
30473: LD_VAR 0 2
30477: PUSH
30478: FOR_IN
30479: IFFALSE 30492
// RemoveUnit ( i ) ;
30481: LD_VAR 0 1
30485: PPUSH
30486: CALL_OW 64
30490: GO 30478
30492: POP
30493: POP
// end ;
30494: PPOPN 2
30496: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30497: LD_INT 22
30499: PUSH
30500: LD_INT 7
30502: PUSH
30503: EMPTY
30504: LIST
30505: LIST
30506: PUSH
30507: LD_INT 21
30509: PUSH
30510: LD_INT 1
30512: PUSH
30513: EMPTY
30514: LIST
30515: LIST
30516: PUSH
30517: EMPTY
30518: LIST
30519: LIST
30520: PPUSH
30521: CALL_OW 69
30525: PUSH
30526: LD_INT 6
30528: LESS
30529: IFFALSE 30997
30531: GO 30533
30533: DISABLE
30534: LD_INT 0
30536: PPUSH
30537: PPUSH
// begin MC_Kill ( 1 ) ;
30538: LD_INT 1
30540: PPUSH
30541: CALL 35090 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30545: LD_INT 7
30547: PPUSH
30548: LD_INT 1
30550: PPUSH
30551: LD_INT 1
30553: PPUSH
30554: LD_INT 1
30556: PPUSH
30557: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30561: LD_ADDR_VAR 0 1
30565: PUSH
30566: LD_INT 22
30568: PUSH
30569: LD_INT 7
30571: PUSH
30572: EMPTY
30573: LIST
30574: LIST
30575: PUSH
30576: LD_INT 26
30578: PUSH
30579: LD_INT 1
30581: PUSH
30582: EMPTY
30583: LIST
30584: LIST
30585: PUSH
30586: EMPTY
30587: LIST
30588: LIST
30589: PPUSH
30590: CALL_OW 69
30594: PUSH
30595: LD_EXP 74
30599: DIFF
30600: ST_TO_ADDR
// if tmp then
30601: LD_VAR 0 1
30605: IFFALSE 30623
// tmp := tmp [ 1 ] else
30607: LD_ADDR_VAR 0 1
30611: PUSH
30612: LD_VAR 0 1
30616: PUSH
30617: LD_INT 1
30619: ARRAY
30620: ST_TO_ADDR
30621: GO 30659
// begin uc_side := 7 ;
30623: LD_ADDR_OWVAR 20
30627: PUSH
30628: LD_INT 7
30630: ST_TO_ADDR
// uc_nation := 1 ;
30631: LD_ADDR_OWVAR 21
30635: PUSH
30636: LD_INT 1
30638: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30639: LD_INT 1
30641: PPUSH
30642: LD_INT 8
30644: PPUSH
30645: CALL_OW 384
// tmp := CreateHuman ;
30649: LD_ADDR_VAR 0 1
30653: PUSH
30654: CALL_OW 44
30658: ST_TO_ADDR
// end ; DialogueOn ;
30659: CALL_OW 6
// if IsOK ( Roth ) then
30663: LD_EXP 74
30667: PPUSH
30668: CALL_OW 302
30672: IFFALSE 30686
// Say ( JMM , DAb-JMM-1 ) ;
30674: LD_EXP 39
30678: PPUSH
30679: LD_STRING DAb-JMM-1
30681: PPUSH
30682: CALL_OW 88
// if IsOK ( Roth ) then
30686: LD_EXP 74
30690: PPUSH
30691: CALL_OW 302
30695: IFFALSE 30719
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30697: LD_EXP 74
30701: PPUSH
30702: LD_STRING DSurrenderAlliance-Roth-1
30704: PPUSH
30705: CALL_OW 88
// RothCaptured := true ;
30709: LD_ADDR_EXP 33
30713: PUSH
30714: LD_INT 1
30716: ST_TO_ADDR
// end else
30717: GO 30731
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30719: LD_VAR 0 1
30723: PPUSH
30724: LD_STRING DSurrenderAlliance-Sci1-1
30726: PPUSH
30727: CALL_OW 88
// DialogueOff ;
30731: CALL_OW 7
// allianceDestroyed := true ;
30735: LD_ADDR_EXP 23
30739: PUSH
30740: LD_INT 1
30742: ST_TO_ADDR
// if capturedUnit = 0 then
30743: LD_EXP 34
30747: PUSH
30748: LD_INT 0
30750: EQUAL
30751: IFFALSE 30760
// SetAchievement ( ACH_ALLIANCE ) ;
30753: LD_STRING ACH_ALLIANCE
30755: PPUSH
30756: CALL_OW 543
// if trueAmericans then
30760: LD_EXP 35
30764: IFFALSE 30840
// begin if trueAmericans = 1 then
30766: LD_EXP 35
30770: PUSH
30771: LD_INT 1
30773: EQUAL
30774: IFFALSE 30790
// Say ( JMM , DAb-JMM-1a ) else
30776: LD_EXP 39
30780: PPUSH
30781: LD_STRING DAb-JMM-1a
30783: PPUSH
30784: CALL_OW 88
30788: GO 30802
// Say ( JMM , DAb-JMM-1b ) ;
30790: LD_EXP 39
30794: PPUSH
30795: LD_STRING DAb-JMM-1b
30797: PPUSH
30798: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30802: LD_EXP 35
30806: PPUSH
30807: CALL_OW 87
// for i in trueAmericans do
30811: LD_ADDR_VAR 0 2
30815: PUSH
30816: LD_EXP 35
30820: PUSH
30821: FOR_IN
30822: IFFALSE 30838
// SetSide ( i , 1 ) ;
30824: LD_VAR 0 2
30828: PPUSH
30829: LD_INT 1
30831: PPUSH
30832: CALL_OW 235
30836: GO 30821
30838: POP
30839: POP
// end ; repeat wait ( 0 0$1 ) ;
30840: LD_INT 35
30842: PPUSH
30843: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
30847: LD_ADDR_VAR 0 2
30851: PUSH
30852: LD_INT 22
30854: PUSH
30855: LD_INT 7
30857: PUSH
30858: EMPTY
30859: LIST
30860: LIST
30861: PUSH
30862: LD_INT 21
30864: PUSH
30865: LD_INT 1
30867: PUSH
30868: EMPTY
30869: LIST
30870: LIST
30871: PUSH
30872: EMPTY
30873: LIST
30874: LIST
30875: PPUSH
30876: CALL_OW 69
30880: PUSH
30881: FOR_IN
30882: IFFALSE 30964
// begin if IsInUnit ( i ) then
30884: LD_VAR 0 2
30888: PPUSH
30889: CALL_OW 310
30893: IFFALSE 30904
// ComExitBuilding ( i ) ;
30895: LD_VAR 0 2
30899: PPUSH
30900: CALL_OW 122
// if IsDriver ( i ) then
30904: LD_VAR 0 2
30908: PPUSH
30909: CALL 105489 0 1
30913: IFFALSE 30924
// ComExitVehicle ( i ) ;
30915: LD_VAR 0 2
30919: PPUSH
30920: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
30924: LD_VAR 0 2
30928: PPUSH
30929: LD_INT 26
30931: PPUSH
30932: CALL_OW 308
30936: NOT
30937: IFFALSE 30953
// AddComMoveToArea ( i , allianceEscapeArea ) else
30939: LD_VAR 0 2
30943: PPUSH
30944: LD_INT 26
30946: PPUSH
30947: CALL_OW 173
30951: GO 30962
// RemoveUnit ( i ) ;
30953: LD_VAR 0 2
30957: PPUSH
30958: CALL_OW 64
// end ;
30962: GO 30881
30964: POP
30965: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
30966: LD_INT 22
30968: PUSH
30969: LD_INT 7
30971: PUSH
30972: EMPTY
30973: LIST
30974: LIST
30975: PUSH
30976: LD_INT 21
30978: PUSH
30979: LD_INT 1
30981: PUSH
30982: EMPTY
30983: LIST
30984: LIST
30985: PUSH
30986: EMPTY
30987: LIST
30988: LIST
30989: PPUSH
30990: CALL_OW 69
30994: NOT
30995: IFFALSE 30840
// end ;
30997: PPOPN 2
30999: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31000: LD_INT 0
31002: PPUSH
31003: PPUSH
// if not unit then
31004: LD_VAR 0 1
31008: NOT
31009: IFFALSE 31013
// exit ;
31011: GO 32511
// DoNotAttack ( 7 , unit ) ;
31013: LD_INT 7
31015: PPUSH
31016: LD_VAR 0 1
31020: PPUSH
31021: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31025: LD_VAR 0 1
31029: PPUSH
31030: LD_INT 260
31032: PPUSH
31033: LD_INT 235
31035: PPUSH
31036: LD_INT 3
31038: PPUSH
31039: LD_INT 1
31041: PPUSH
31042: CALL_OW 483
// SetSide ( unit , 4 ) ;
31046: LD_VAR 0 1
31050: PPUSH
31051: LD_INT 4
31053: PPUSH
31054: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31058: LD_ADDR_EXP 34
31062: PUSH
31063: LD_EXP 34
31067: PUSH
31068: LD_INT 1
31070: PLUS
31071: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31072: LD_INT 70
31074: PPUSH
31075: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31079: LD_INT 260
31081: PPUSH
31082: LD_INT 235
31084: PPUSH
31085: LD_INT 1
31087: PPUSH
31088: LD_INT 8
31090: NEG
31091: PPUSH
31092: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31096: LD_VAR 0 1
31100: PPUSH
31101: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31105: LD_VAR 0 1
31109: PPUSH
31110: LD_EXP 74
31114: PPUSH
31115: CALL_OW 119
// DialogueOn ;
31119: CALL_OW 6
// case unit of JMM :
31123: LD_VAR 0 1
31127: PUSH
31128: LD_EXP 39
31132: DOUBLE
31133: EQUAL
31134: IFTRUE 31138
31136: GO 31153
31138: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31139: LD_EXP 39
31143: PPUSH
31144: LD_STRING DA1-JMM-1
31146: PPUSH
31147: CALL_OW 91
31151: GO 31595
31153: LD_EXP 40
31157: DOUBLE
31158: EQUAL
31159: IFTRUE 31163
31161: GO 31178
31163: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31164: LD_EXP 40
31168: PPUSH
31169: LD_STRING DA1-Joan-1
31171: PPUSH
31172: CALL_OW 91
31176: GO 31595
31178: LD_EXP 42
31182: DOUBLE
31183: EQUAL
31184: IFTRUE 31188
31186: GO 31203
31188: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31189: LD_EXP 42
31193: PPUSH
31194: LD_STRING DA1-Lisa-1
31196: PPUSH
31197: CALL_OW 91
31201: GO 31595
31203: LD_EXP 43
31207: DOUBLE
31208: EQUAL
31209: IFTRUE 31213
31211: GO 31228
31213: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31214: LD_EXP 43
31218: PPUSH
31219: LD_STRING DA1-Don-1
31221: PPUSH
31222: CALL_OW 91
31226: GO 31595
31228: LD_EXP 50
31232: DOUBLE
31233: EQUAL
31234: IFTRUE 31238
31236: GO 31253
31238: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31239: LD_EXP 50
31243: PPUSH
31244: LD_STRING DA1-Corn-1
31246: PPUSH
31247: CALL_OW 91
31251: GO 31595
31253: LD_EXP 46
31257: DOUBLE
31258: EQUAL
31259: IFTRUE 31263
31261: GO 31278
31263: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31264: LD_EXP 46
31268: PPUSH
31269: LD_STRING DA1-Den-1
31271: PPUSH
31272: CALL_OW 91
31276: GO 31595
31278: LD_EXP 44
31282: DOUBLE
31283: EQUAL
31284: IFTRUE 31288
31286: GO 31303
31288: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31289: LD_EXP 44
31293: PPUSH
31294: LD_STRING DA1-Bobby-1
31296: PPUSH
31297: CALL_OW 91
31301: GO 31595
31303: LD_EXP 48
31307: DOUBLE
31308: EQUAL
31309: IFTRUE 31313
31311: GO 31328
31313: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31314: LD_EXP 48
31318: PPUSH
31319: LD_STRING DA1-Glad-1
31321: PPUSH
31322: CALL_OW 91
31326: GO 31595
31328: LD_EXP 45
31332: DOUBLE
31333: EQUAL
31334: IFTRUE 31338
31336: GO 31353
31338: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31339: LD_EXP 45
31343: PPUSH
31344: LD_STRING DA1-Cyrus-1
31346: PPUSH
31347: CALL_OW 91
31351: GO 31595
31353: LD_EXP 41
31357: DOUBLE
31358: EQUAL
31359: IFTRUE 31363
31361: GO 31378
31363: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31364: LD_EXP 41
31368: PPUSH
31369: LD_STRING DA1-Huck-1
31371: PPUSH
31372: CALL_OW 91
31376: GO 31595
31378: LD_EXP 55
31382: DOUBLE
31383: EQUAL
31384: IFTRUE 31388
31386: GO 31403
31388: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31389: LD_EXP 55
31393: PPUSH
31394: LD_STRING DA1-Huck-1
31396: PPUSH
31397: CALL_OW 91
31401: GO 31595
31403: LD_EXP 47
31407: DOUBLE
31408: EQUAL
31409: IFTRUE 31413
31411: GO 31428
31413: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31414: LD_EXP 47
31418: PPUSH
31419: LD_STRING DA1-Brown-1
31421: PPUSH
31422: CALL_OW 91
31426: GO 31595
31428: LD_EXP 51
31432: DOUBLE
31433: EQUAL
31434: IFTRUE 31438
31436: GO 31453
31438: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31439: LD_EXP 51
31443: PPUSH
31444: LD_STRING DA1-Gary-1
31446: PPUSH
31447: CALL_OW 91
31451: GO 31595
31453: LD_EXP 54
31457: DOUBLE
31458: EQUAL
31459: IFTRUE 31463
31461: GO 31478
31463: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31464: LD_EXP 54
31468: PPUSH
31469: LD_STRING DA1-Con-1
31471: PPUSH
31472: CALL_OW 91
31476: GO 31595
31478: LD_EXP 60
31482: DOUBLE
31483: EQUAL
31484: IFTRUE 31488
31486: GO 31503
31488: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31489: LD_EXP 60
31493: PPUSH
31494: LD_STRING DA1-Kurt-1
31496: PPUSH
31497: CALL_OW 91
31501: GO 31595
31503: LD_EXP 53
31507: DOUBLE
31508: EQUAL
31509: IFTRUE 31513
31511: GO 31528
31513: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31514: LD_EXP 53
31518: PPUSH
31519: LD_STRING DA1-Yam-1
31521: PPUSH
31522: CALL_OW 91
31526: GO 31595
31528: LD_EXP 52
31532: DOUBLE
31533: EQUAL
31534: IFTRUE 31538
31536: GO 31553
31538: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31539: LD_EXP 52
31543: PPUSH
31544: LD_STRING DA1-Frank-1
31546: PPUSH
31547: CALL_OW 91
31551: GO 31595
31553: POP
// begin if GetSex ( unit ) = sex_male then
31554: LD_VAR 0 1
31558: PPUSH
31559: CALL_OW 258
31563: PUSH
31564: LD_INT 1
31566: EQUAL
31567: IFFALSE 31583
// ForceSay ( unit , DA1-Sol1-1 ) else
31569: LD_VAR 0 1
31573: PPUSH
31574: LD_STRING DA1-Sol1-1
31576: PPUSH
31577: CALL_OW 91
31581: GO 31595
// ForceSay ( unit , DA1-FSol1-1 ) ;
31583: LD_VAR 0 1
31587: PPUSH
31588: LD_STRING DA1-FSol1-1
31590: PPUSH
31591: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31595: LD_EXP 74
31599: PPUSH
31600: LD_STRING DA-Roth-1
31602: PPUSH
31603: CALL_OW 88
// if capturedUnit = 1 then
31607: LD_EXP 34
31611: PUSH
31612: LD_INT 1
31614: EQUAL
31615: IFFALSE 31643
// begin Say ( Simms , DA-Sim-1 ) ;
31617: LD_EXP 75
31621: PPUSH
31622: LD_STRING DA-Sim-1
31624: PPUSH
31625: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31629: LD_EXP 74
31633: PPUSH
31634: LD_STRING DA-Roth-2
31636: PPUSH
31637: CALL_OW 88
// end else
31641: GO 31655
// Say ( Simms , DA-Sim-2 ) ;
31643: LD_EXP 75
31647: PPUSH
31648: LD_STRING DA-Sim-2
31650: PPUSH
31651: CALL_OW 88
// case unit of JMM :
31655: LD_VAR 0 1
31659: PUSH
31660: LD_EXP 39
31664: DOUBLE
31665: EQUAL
31666: IFTRUE 31670
31668: GO 31685
31670: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31671: LD_EXP 39
31675: PPUSH
31676: LD_STRING DA1-JMM-1a
31678: PPUSH
31679: CALL_OW 91
31683: GO 32192
31685: LD_EXP 40
31689: DOUBLE
31690: EQUAL
31691: IFTRUE 31695
31693: GO 31710
31695: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31696: LD_EXP 40
31700: PPUSH
31701: LD_STRING DA1-Joan-1a
31703: PPUSH
31704: CALL_OW 91
31708: GO 32192
31710: LD_EXP 42
31714: DOUBLE
31715: EQUAL
31716: IFTRUE 31720
31718: GO 31735
31720: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31721: LD_EXP 42
31725: PPUSH
31726: LD_STRING DA1-Lisa-1a
31728: PPUSH
31729: CALL_OW 91
31733: GO 32192
31735: LD_EXP 43
31739: DOUBLE
31740: EQUAL
31741: IFTRUE 31745
31743: GO 31760
31745: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31746: LD_EXP 43
31750: PPUSH
31751: LD_STRING DA1-Don-1a
31753: PPUSH
31754: CALL_OW 91
31758: GO 32192
31760: LD_EXP 50
31764: DOUBLE
31765: EQUAL
31766: IFTRUE 31770
31768: GO 31785
31770: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31771: LD_EXP 50
31775: PPUSH
31776: LD_STRING DA1-Corn-1a
31778: PPUSH
31779: CALL_OW 91
31783: GO 32192
31785: LD_EXP 46
31789: DOUBLE
31790: EQUAL
31791: IFTRUE 31795
31793: GO 31810
31795: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31796: LD_EXP 46
31800: PPUSH
31801: LD_STRING DA1-Den-1a
31803: PPUSH
31804: CALL_OW 91
31808: GO 32192
31810: LD_EXP 44
31814: DOUBLE
31815: EQUAL
31816: IFTRUE 31820
31818: GO 31835
31820: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31821: LD_EXP 44
31825: PPUSH
31826: LD_STRING DA1-Bobby-1a
31828: PPUSH
31829: CALL_OW 91
31833: GO 32192
31835: LD_EXP 48
31839: DOUBLE
31840: EQUAL
31841: IFTRUE 31845
31843: GO 31860
31845: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
31846: LD_EXP 48
31850: PPUSH
31851: LD_STRING DA1-Glad-1a
31853: PPUSH
31854: CALL_OW 91
31858: GO 32192
31860: LD_EXP 45
31864: DOUBLE
31865: EQUAL
31866: IFTRUE 31870
31868: GO 31885
31870: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
31871: LD_EXP 45
31875: PPUSH
31876: LD_STRING DA1-Cyrus-1a
31878: PPUSH
31879: CALL_OW 91
31883: GO 32192
31885: LD_EXP 41
31889: DOUBLE
31890: EQUAL
31891: IFTRUE 31895
31893: GO 31910
31895: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
31896: LD_EXP 41
31900: PPUSH
31901: LD_STRING DA1-Huck-1a
31903: PPUSH
31904: CALL_OW 91
31908: GO 32192
31910: LD_EXP 55
31914: DOUBLE
31915: EQUAL
31916: IFTRUE 31920
31918: GO 31935
31920: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
31921: LD_EXP 55
31925: PPUSH
31926: LD_STRING DA1-Huck-1a
31928: PPUSH
31929: CALL_OW 91
31933: GO 32192
31935: LD_EXP 47
31939: DOUBLE
31940: EQUAL
31941: IFTRUE 31945
31943: GO 31960
31945: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
31946: LD_EXP 47
31950: PPUSH
31951: LD_STRING DA1-Brown-1a
31953: PPUSH
31954: CALL_OW 91
31958: GO 32192
31960: LD_EXP 51
31964: DOUBLE
31965: EQUAL
31966: IFTRUE 31970
31968: GO 31985
31970: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31971: LD_EXP 51
31975: PPUSH
31976: LD_STRING DA1-Gary-1a
31978: PPUSH
31979: CALL_OW 91
31983: GO 32192
31985: LD_EXP 54
31989: DOUBLE
31990: EQUAL
31991: IFTRUE 31995
31993: GO 32010
31995: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31996: LD_EXP 54
32000: PPUSH
32001: LD_STRING DA1-Con-1a
32003: PPUSH
32004: CALL_OW 91
32008: GO 32192
32010: LD_EXP 60
32014: DOUBLE
32015: EQUAL
32016: IFTRUE 32020
32018: GO 32035
32020: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32021: LD_EXP 60
32025: PPUSH
32026: LD_STRING DA1-Kurt-1a
32028: PPUSH
32029: CALL_OW 91
32033: GO 32192
32035: LD_EXP 53
32039: DOUBLE
32040: EQUAL
32041: IFTRUE 32045
32043: GO 32060
32045: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32046: LD_EXP 53
32050: PPUSH
32051: LD_STRING DA1-Yam-1a
32053: PPUSH
32054: CALL_OW 91
32058: GO 32192
32060: LD_EXP 52
32064: DOUBLE
32065: EQUAL
32066: IFTRUE 32070
32068: GO 32085
32070: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32071: LD_EXP 52
32075: PPUSH
32076: LD_STRING DA1-Frank-1a
32078: PPUSH
32079: CALL_OW 91
32083: GO 32192
32085: POP
// begin join := rand ( 0 , 1 ) ;
32086: LD_ADDR_VAR 0 3
32090: PUSH
32091: LD_INT 0
32093: PPUSH
32094: LD_INT 1
32096: PPUSH
32097: CALL_OW 12
32101: ST_TO_ADDR
// if join then
32102: LD_VAR 0 3
32106: IFFALSE 32151
// begin if GetSex ( unit ) = sex_male then
32108: LD_VAR 0 1
32112: PPUSH
32113: CALL_OW 258
32117: PUSH
32118: LD_INT 1
32120: EQUAL
32121: IFFALSE 32137
// ForceSay ( unit , DA1-Sol1-1b ) else
32123: LD_VAR 0 1
32127: PPUSH
32128: LD_STRING DA1-Sol1-1b
32130: PPUSH
32131: CALL_OW 91
32135: GO 32149
// ForceSay ( unit , DA1-FSol1-1b ) ;
32137: LD_VAR 0 1
32141: PPUSH
32142: LD_STRING DA1-FSol1-1b
32144: PPUSH
32145: CALL_OW 91
// end else
32149: GO 32192
// begin if GetSex ( unit ) = sex_male then
32151: LD_VAR 0 1
32155: PPUSH
32156: CALL_OW 258
32160: PUSH
32161: LD_INT 1
32163: EQUAL
32164: IFFALSE 32180
// ForceSay ( unit , DA1-Sol1-1a ) else
32166: LD_VAR 0 1
32170: PPUSH
32171: LD_STRING DA1-Sol1-1a
32173: PPUSH
32174: CALL_OW 91
32178: GO 32192
// ForceSay ( unit , DA1-FSol1-1a ) ;
32180: LD_VAR 0 1
32184: PPUSH
32185: LD_STRING DA1-FSol1-1a
32187: PPUSH
32188: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32192: LD_VAR 0 1
32196: PUSH
32197: LD_EXP 39
32201: EQUAL
32202: IFFALSE 32213
// begin YouLost ( JMMCaptured ) ;
32204: LD_STRING JMMCaptured
32206: PPUSH
32207: CALL_OW 104
// exit ;
32211: GO 32511
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32213: LD_VAR 0 1
32217: PUSH
32218: LD_EXP 43
32222: PUSH
32223: LD_EXP 46
32227: PUSH
32228: LD_EXP 44
32232: PUSH
32233: LD_EXP 41
32237: PUSH
32238: LD_EXP 55
32242: PUSH
32243: LD_EXP 47
32247: PUSH
32248: LD_EXP 53
32252: PUSH
32253: EMPTY
32254: LIST
32255: LIST
32256: LIST
32257: LIST
32258: LIST
32259: LIST
32260: LIST
32261: IN
32262: PUSH
32263: LD_VAR 0 3
32267: OR
32268: IFFALSE 32367
// begin Say ( Roth , DA-Roth-3 ) ;
32270: LD_EXP 74
32274: PPUSH
32275: LD_STRING DA-Roth-3
32277: PPUSH
32278: CALL_OW 88
// SetSide ( unit , 7 ) ;
32282: LD_VAR 0 1
32286: PPUSH
32287: LD_INT 7
32289: PPUSH
32290: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32294: LD_ADDR_EXP 102
32298: PUSH
32299: LD_EXP 102
32303: PPUSH
32304: LD_INT 1
32306: PPUSH
32307: LD_EXP 102
32311: PUSH
32312: LD_INT 1
32314: ARRAY
32315: PUSH
32316: LD_VAR 0 1
32320: ADD
32321: PPUSH
32322: CALL_OW 1
32326: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32327: LD_INT 260
32329: PPUSH
32330: LD_INT 235
32332: PPUSH
32333: LD_INT 1
32335: PPUSH
32336: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32340: LD_VAR 0 1
32344: PPUSH
32345: LD_INT 1000
32347: PPUSH
32348: CALL_OW 234
// DialogueOff ;
32352: CALL_OW 7
// ComFree ( unit ) ;
32356: LD_VAR 0 1
32360: PPUSH
32361: CALL_OW 139
// end else
32365: GO 32448
// begin Say ( Roth , DA-Roth-3a ) ;
32367: LD_EXP 74
32371: PPUSH
32372: LD_STRING DA-Roth-3a
32374: PPUSH
32375: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32379: LD_ADDR_EXP 35
32383: PUSH
32384: LD_EXP 35
32388: PUSH
32389: LD_VAR 0 1
32393: ADD
32394: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32395: LD_INT 260
32397: PPUSH
32398: LD_INT 235
32400: PPUSH
32401: LD_INT 1
32403: PPUSH
32404: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32408: LD_VAR 0 1
32412: PPUSH
32413: LD_INT 1000
32415: PPUSH
32416: CALL_OW 234
// DialogueOff ;
32420: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32424: LD_VAR 0 1
32428: PPUSH
32429: LD_INT 272
32431: PPUSH
32432: LD_INT 254
32434: PPUSH
32435: CALL_OW 111
// AddComHold ( unit ) ;
32439: LD_VAR 0 1
32443: PPUSH
32444: CALL_OW 200
// end ; if capturedUnit = 1 then
32448: LD_EXP 34
32452: PUSH
32453: LD_INT 1
32455: EQUAL
32456: IFFALSE 32511
// begin DialogueOn ;
32458: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32462: LD_EXP 39
32466: PPUSH
32467: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32471: LD_EXP 39
32475: PPUSH
32476: LD_STRING DAa-JMM-1
32478: PPUSH
32479: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32483: LD_EXP 39
32487: PPUSH
32488: LD_STRING DAa-JMM-1a
32490: PPUSH
32491: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32495: LD_EXP 39
32499: PPUSH
32500: LD_STRING DAa-JMM-1b
32502: PPUSH
32503: CALL_OW 88
// DialogueOff ;
32507: CALL_OW 7
// end ; end ;
32511: LD_VAR 0 2
32515: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32516: LD_EXP 15
32520: PUSH
32521: LD_INT 13
32523: GREATEREQUAL
32524: PUSH
32525: LD_INT 22
32527: PUSH
32528: LD_INT 2
32530: PUSH
32531: EMPTY
32532: LIST
32533: LIST
32534: PUSH
32535: LD_INT 21
32537: PUSH
32538: LD_INT 1
32540: PUSH
32541: EMPTY
32542: LIST
32543: LIST
32544: PUSH
32545: EMPTY
32546: LIST
32547: LIST
32548: PPUSH
32549: CALL_OW 69
32553: PUSH
32554: LD_INT 0
32556: EQUAL
32557: AND
32558: PUSH
32559: LD_INT 22
32561: PUSH
32562: LD_INT 2
32564: PUSH
32565: EMPTY
32566: LIST
32567: LIST
32568: PUSH
32569: LD_INT 21
32571: PUSH
32572: LD_INT 2
32574: PUSH
32575: EMPTY
32576: LIST
32577: LIST
32578: PUSH
32579: LD_INT 50
32581: PUSH
32582: EMPTY
32583: LIST
32584: PUSH
32585: EMPTY
32586: LIST
32587: LIST
32588: LIST
32589: PPUSH
32590: CALL_OW 69
32594: PUSH
32595: LD_INT 0
32597: EQUAL
32598: AND
32599: PUSH
32600: LD_EXP 21
32604: AND
32605: PUSH
32606: LD_EXP 22
32610: AND
32611: PUSH
32612: LD_EXP 23
32616: AND
32617: IFFALSE 33259
32619: GO 32621
32621: DISABLE
32622: LD_INT 0
32624: PPUSH
32625: PPUSH
32626: PPUSH
// begin m1 := false ;
32627: LD_ADDR_VAR 0 1
32631: PUSH
32632: LD_INT 0
32634: ST_TO_ADDR
// m2 := false ;
32635: LD_ADDR_VAR 0 2
32639: PUSH
32640: LD_INT 0
32642: ST_TO_ADDR
// m3 := false ;
32643: LD_ADDR_VAR 0 3
32647: PUSH
32648: LD_INT 0
32650: ST_TO_ADDR
// if not bombExploded then
32651: LD_EXP 37
32655: NOT
32656: IFFALSE 32665
// SetAchievement ( ACH_SIBROCKET ) ;
32658: LD_STRING ACH_SIBROCKET
32660: PPUSH
32661: CALL_OW 543
// if tick <= 120 120$00 then
32665: LD_OWVAR 1
32669: PUSH
32670: LD_INT 252000
32672: LESSEQUAL
32673: IFFALSE 32689
// begin wait ( 3 ) ;
32675: LD_INT 3
32677: PPUSH
32678: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32682: LD_STRING ACH_ASPEED_15
32684: PPUSH
32685: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32689: LD_EXP 39
32693: PPUSH
32694: CALL_OW 87
// music_class := 5 ;
32698: LD_ADDR_OWVAR 72
32702: PUSH
32703: LD_INT 5
32705: ST_TO_ADDR
// music_nat := 5 ;
32706: LD_ADDR_OWVAR 71
32710: PUSH
32711: LD_INT 5
32713: ST_TO_ADDR
// DialogueOn ;
32714: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32718: LD_EXP 39
32722: PPUSH
32723: LD_STRING D20-JMM-1
32725: PPUSH
32726: CALL_OW 88
// if IsOK ( Joan ) then
32730: LD_EXP 40
32734: PPUSH
32735: CALL_OW 302
32739: IFFALSE 32753
// Say ( Joan , D20-Joan-1 ) ;
32741: LD_EXP 40
32745: PPUSH
32746: LD_STRING D20-Joan-1
32748: PPUSH
32749: CALL_OW 88
// if IsOk ( Lisa ) then
32753: LD_EXP 42
32757: PPUSH
32758: CALL_OW 302
32762: IFFALSE 32776
// Say ( Lisa , D20-Lisa-1 ) ;
32764: LD_EXP 42
32768: PPUSH
32769: LD_STRING D20-Lisa-1
32771: PPUSH
32772: CALL_OW 88
// if IsOk ( Donaldson ) then
32776: LD_EXP 43
32780: PPUSH
32781: CALL_OW 302
32785: IFFALSE 32799
// Say ( Donaldson , D20-Don-1 ) ;
32787: LD_EXP 43
32791: PPUSH
32792: LD_STRING D20-Don-1
32794: PPUSH
32795: CALL_OW 88
// if IsOK ( Cornel ) then
32799: LD_EXP 50
32803: PPUSH
32804: CALL_OW 302
32808: IFFALSE 32822
// Say ( Cornel , D20-Corn-1 ) ;
32810: LD_EXP 50
32814: PPUSH
32815: LD_STRING D20-Corn-1
32817: PPUSH
32818: CALL_OW 88
// if IsOk ( Denis ) then
32822: LD_EXP 46
32826: PPUSH
32827: CALL_OW 302
32831: IFFALSE 32845
// Say ( Denis , D20-Den-1 ) ;
32833: LD_EXP 46
32837: PPUSH
32838: LD_STRING D20-Den-1
32840: PPUSH
32841: CALL_OW 88
// if IsOk ( Bobby ) then
32845: LD_EXP 44
32849: PPUSH
32850: CALL_OW 302
32854: IFFALSE 32868
// Say ( Bobby , D20-Bobby-1 ) ;
32856: LD_EXP 44
32860: PPUSH
32861: LD_STRING D20-Bobby-1
32863: PPUSH
32864: CALL_OW 88
// if IsOk ( Gladstone ) then
32868: LD_EXP 48
32872: PPUSH
32873: CALL_OW 302
32877: IFFALSE 32891
// Say ( Gladstone , D20-Glad-1 ) ;
32879: LD_EXP 48
32883: PPUSH
32884: LD_STRING D20-Glad-1
32886: PPUSH
32887: CALL_OW 88
// if IsOk ( Cyrus ) then
32891: LD_EXP 45
32895: PPUSH
32896: CALL_OW 302
32900: IFFALSE 32914
// Say ( Cyrus , D20-Cyrus-1 ) ;
32902: LD_EXP 45
32906: PPUSH
32907: LD_STRING D20-Cyrus-1
32909: PPUSH
32910: CALL_OW 88
// if IsOk ( Stevens ) then
32914: LD_EXP 41
32918: PPUSH
32919: CALL_OW 302
32923: IFFALSE 32937
// Say ( Stevens , D20-Huck-1 ) ;
32925: LD_EXP 41
32929: PPUSH
32930: LD_STRING D20-Huck-1
32932: PPUSH
32933: CALL_OW 88
// if IsOk ( Brown ) then
32937: LD_EXP 47
32941: PPUSH
32942: CALL_OW 302
32946: IFFALSE 32960
// Say ( Brown , D20-Brown-1 ) ;
32948: LD_EXP 47
32952: PPUSH
32953: LD_STRING D20-Brown-1
32955: PPUSH
32956: CALL_OW 88
// if IsOk ( Gary ) then
32960: LD_EXP 51
32964: PPUSH
32965: CALL_OW 302
32969: IFFALSE 32983
// Say ( Gary , D20-Gary-1 ) ;
32971: LD_EXP 51
32975: PPUSH
32976: LD_STRING D20-Gary-1
32978: PPUSH
32979: CALL_OW 88
// if IsOk ( Connie ) then
32983: LD_EXP 54
32987: PPUSH
32988: CALL_OW 302
32992: IFFALSE 33006
// Say ( Connie , D20-Con-1 ) ;
32994: LD_EXP 54
32998: PPUSH
32999: LD_STRING D20-Con-1
33001: PPUSH
33002: CALL_OW 88
// if IsOk ( Kurt ) then
33006: LD_EXP 60
33010: PPUSH
33011: CALL_OW 302
33015: IFFALSE 33029
// Say ( Kurt , D20-Kurt-1 ) ;
33017: LD_EXP 60
33021: PPUSH
33022: LD_STRING D20-Kurt-1
33024: PPUSH
33025: CALL_OW 88
// if IsOk ( Kikuchi ) then
33029: LD_EXP 53
33033: PPUSH
33034: CALL_OW 302
33038: IFFALSE 33052
// Say ( Kikuchi , D20-Yam-1 ) ;
33040: LD_EXP 53
33044: PPUSH
33045: LD_STRING D20-Yam-1
33047: PPUSH
33048: CALL_OW 88
// if IsOk ( Frank ) then
33052: LD_EXP 52
33056: PPUSH
33057: CALL_OW 302
33061: IFFALSE 33075
// Say ( Frank , D20-Frank-1 ) ;
33063: LD_EXP 52
33067: PPUSH
33068: LD_STRING D20-Frank-1
33070: PPUSH
33071: CALL_OW 88
// DialogueOff ;
33075: CALL_OW 7
// if RothCaptured then
33079: LD_EXP 33
33083: IFFALSE 33105
// begin m1 := true ;
33085: LD_ADDR_VAR 0 1
33089: PUSH
33090: LD_INT 1
33092: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33093: LD_STRING Roth
33095: PPUSH
33096: LD_INT 1
33098: PPUSH
33099: CALL_OW 101
// end else
33103: GO 33116
// AddMedal ( Roth , - 1 ) ;
33105: LD_STRING Roth
33107: PPUSH
33108: LD_INT 1
33110: NEG
33111: PPUSH
33112: CALL_OW 101
// if behemothDestroyedBeforeFinish then
33116: LD_EXP 27
33120: IFFALSE 33142
// begin m2 := true ;
33122: LD_ADDR_VAR 0 2
33126: PUSH
33127: LD_INT 1
33129: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33130: LD_STRING Project
33132: PPUSH
33133: LD_INT 1
33135: PPUSH
33136: CALL_OW 101
// end else
33140: GO 33153
// AddMedal ( Project , - 1 ) ;
33142: LD_STRING Project
33144: PPUSH
33145: LD_INT 1
33147: NEG
33148: PPUSH
33149: CALL_OW 101
// if lostCounter = 0 then
33153: LD_EXP 32
33157: PUSH
33158: LD_INT 0
33160: EQUAL
33161: IFFALSE 33183
// begin m3 := true ;
33163: LD_ADDR_VAR 0 3
33167: PUSH
33168: LD_INT 1
33170: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33171: LD_STRING NoLosses
33173: PPUSH
33174: LD_INT 1
33176: PPUSH
33177: CALL_OW 101
// end else
33181: GO 33194
// AddMedal ( NoLosses , - 1 ) ;
33183: LD_STRING NoLosses
33185: PPUSH
33186: LD_INT 1
33188: NEG
33189: PPUSH
33190: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
33194: LD_VAR 0 1
33198: PUSH
33199: LD_VAR 0 2
33203: AND
33204: PUSH
33205: LD_VAR 0 3
33209: AND
33210: PUSH
33211: LD_OWVAR 67
33215: PUSH
33216: LD_INT 3
33218: EQUAL
33219: AND
33220: IFFALSE 33232
// SetAchievementEX ( ACH_AMER , 15 ) ;
33222: LD_STRING ACH_AMER
33224: PPUSH
33225: LD_INT 15
33227: PPUSH
33228: CALL_OW 564
// GiveMedals ( MAIN ) ;
33232: LD_STRING MAIN
33234: PPUSH
33235: CALL_OW 102
// music_class := 4 ;
33239: LD_ADDR_OWVAR 72
33243: PUSH
33244: LD_INT 4
33246: ST_TO_ADDR
// music_nat := 1 ;
33247: LD_ADDR_OWVAR 71
33251: PUSH
33252: LD_INT 1
33254: ST_TO_ADDR
// YouWin ;
33255: CALL_OW 103
// end ; end_of_file
33259: PPOPN 3
33261: END
// export function CustomEvent ( event ) ; begin
33262: LD_INT 0
33264: PPUSH
// end ;
33265: LD_VAR 0 2
33269: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33270: LD_VAR 0 1
33274: PUSH
33275: LD_INT 1
33277: EQUAL
33278: PUSH
33279: LD_VAR 0 2
33283: PUSH
33284: LD_INT 4
33286: EQUAL
33287: AND
33288: PUSH
33289: LD_EXP 58
33293: PPUSH
33294: CALL_OW 300
33298: AND
33299: IFFALSE 33315
// begin wait ( 0 0$2 ) ;
33301: LD_INT 70
33303: PPUSH
33304: CALL_OW 67
// YouLost ( Dismissed ) ;
33308: LD_STRING Dismissed
33310: PPUSH
33311: CALL_OW 104
// end ; end ;
33315: PPOPN 2
33317: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33318: LD_VAR 0 2
33322: PPUSH
33323: LD_VAR 0 3
33327: PPUSH
33328: LD_INT 18
33330: PPUSH
33331: CALL_OW 309
33335: IFFALSE 33344
// YouLost ( Motherlode3 ) ;
33337: LD_STRING Motherlode3
33339: PPUSH
33340: CALL_OW 104
// end ;
33344: PPOPN 3
33346: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33347: LD_EXP 27
33351: NOT
33352: IFFALSE 33362
// behemothDone := true ;
33354: LD_ADDR_EXP 28
33358: PUSH
33359: LD_INT 1
33361: ST_TO_ADDR
// end ;
33362: PPOPN 1
33364: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33365: LD_VAR 0 1
33369: PPUSH
33370: CALL_OW 255
33374: PUSH
33375: LD_INT 1
33377: EQUAL
33378: IFFALSE 33388
// bombExploded := true ;
33380: LD_ADDR_EXP 37
33384: PUSH
33385: LD_INT 1
33387: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33388: LD_VAR 0 1
33392: PPUSH
33393: CALL_OW 255
33397: PUSH
33398: LD_INT 1
33400: EQUAL
33401: PUSH
33402: LD_EXP 30
33406: AND
33407: PUSH
33408: LD_INT 22
33410: PUSH
33411: LD_INT 3
33413: PUSH
33414: EMPTY
33415: LIST
33416: LIST
33417: PUSH
33418: LD_INT 34
33420: PUSH
33421: LD_INT 48
33423: PUSH
33424: EMPTY
33425: LIST
33426: LIST
33427: PUSH
33428: EMPTY
33429: LIST
33430: LIST
33431: PPUSH
33432: CALL_OW 69
33436: AND
33437: PUSH
33438: LD_INT 22
33440: PUSH
33441: LD_INT 1
33443: PUSH
33444: EMPTY
33445: LIST
33446: LIST
33447: PUSH
33448: LD_INT 34
33450: PUSH
33451: LD_INT 8
33453: PUSH
33454: EMPTY
33455: LIST
33456: LIST
33457: PUSH
33458: EMPTY
33459: LIST
33460: LIST
33461: PPUSH
33462: CALL_OW 69
33466: NOT
33467: AND
33468: IFFALSE 33520
// begin wait ( 0 0$5 ) ;
33470: LD_INT 175
33472: PPUSH
33473: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33477: LD_INT 22
33479: PUSH
33480: LD_INT 3
33482: PUSH
33483: EMPTY
33484: LIST
33485: LIST
33486: PUSH
33487: LD_INT 34
33489: PUSH
33490: LD_INT 48
33492: PUSH
33493: EMPTY
33494: LIST
33495: LIST
33496: PUSH
33497: EMPTY
33498: LIST
33499: LIST
33500: PPUSH
33501: CALL_OW 69
33505: PUSH
33506: LD_INT 1
33508: ARRAY
33509: PPUSH
33510: LD_INT 60
33512: PPUSH
33513: LD_INT 95
33515: PPUSH
33516: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33520: LD_VAR 0 2
33524: PPUSH
33525: LD_VAR 0 3
33529: PPUSH
33530: LD_INT 18
33532: PPUSH
33533: CALL_OW 309
33537: IFFALSE 33597
// begin if GetSide ( unit ) = 1 then
33539: LD_VAR 0 1
33543: PPUSH
33544: CALL_OW 255
33548: PUSH
33549: LD_INT 1
33551: EQUAL
33552: IFFALSE 33568
// begin wait ( 0 0$6 ) ;
33554: LD_INT 210
33556: PPUSH
33557: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33561: LD_STRING Motherlode2
33563: PPUSH
33564: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
33568: LD_VAR 0 1
33572: PPUSH
33573: CALL_OW 255
33577: PUSH
33578: LD_INT 8
33580: EQUAL
33581: IFFALSE 33597
// begin wait ( 0 0$6 ) ;
33583: LD_INT 210
33585: PPUSH
33586: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33590: LD_STRING Motherlode1
33592: PPUSH
33593: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33597: LD_VAR 0 1
33601: PPUSH
33602: CALL_OW 255
33606: PUSH
33607: LD_INT 3
33609: EQUAL
33610: IFFALSE 33631
// begin wait ( 0 0$5 ) ;
33612: LD_INT 175
33614: PPUSH
33615: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33619: LD_EXP 64
33623: PPUSH
33624: LD_STRING D18-Pla-1
33626: PPUSH
33627: CALL_OW 94
// end ; end ;
33631: PPOPN 3
33633: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
33634: LD_VAR 0 1
33638: PUSH
33639: LD_EXP 73
33643: IN
33644: IFFALSE 33664
// begin behemothBuilders := behemothBuilders diff un ;
33646: LD_ADDR_EXP 73
33650: PUSH
33651: LD_EXP 73
33655: PUSH
33656: LD_VAR 0 1
33660: DIFF
33661: ST_TO_ADDR
// exit ;
33662: GO 33762
// end ; if un = JMM then
33664: LD_VAR 0 1
33668: PUSH
33669: LD_EXP 39
33673: EQUAL
33674: IFFALSE 33685
// begin YouLost ( JMM ) ;
33676: LD_STRING JMM
33678: PPUSH
33679: CALL_OW 104
// exit ;
33683: GO 33762
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
33685: LD_VAR 0 1
33689: PUSH
33690: LD_INT 22
33692: PUSH
33693: LD_INT 1
33695: PUSH
33696: EMPTY
33697: LIST
33698: LIST
33699: PUSH
33700: LD_INT 3
33702: PUSH
33703: LD_INT 25
33705: PUSH
33706: LD_INT 16
33708: PUSH
33709: EMPTY
33710: LIST
33711: LIST
33712: PUSH
33713: LD_INT 25
33715: PUSH
33716: LD_INT 12
33718: PUSH
33719: EMPTY
33720: LIST
33721: LIST
33722: PUSH
33723: EMPTY
33724: LIST
33725: LIST
33726: LIST
33727: PUSH
33728: EMPTY
33729: LIST
33730: LIST
33731: PPUSH
33732: CALL_OW 69
33736: IN
33737: IFFALSE 33753
// lostCounter := lostCounter + 1 ;
33739: LD_ADDR_EXP 32
33743: PUSH
33744: LD_EXP 32
33748: PUSH
33749: LD_INT 1
33751: PLUS
33752: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
33753: LD_VAR 0 1
33757: PPUSH
33758: CALL 61942 0 1
// end ;
33762: PPOPN 1
33764: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33765: LD_VAR 0 1
33769: PPUSH
33770: LD_VAR 0 2
33774: PPUSH
33775: CALL 64276 0 2
// end ;
33779: PPOPN 2
33781: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33782: LD_VAR 0 1
33786: PPUSH
33787: CALL 63344 0 1
// end ;
33791: PPOPN 1
33793: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33794: LD_VAR 0 1
33798: PUSH
33799: LD_INT 22
33801: PUSH
33802: LD_INT 8
33804: PUSH
33805: EMPTY
33806: LIST
33807: LIST
33808: PUSH
33809: LD_INT 30
33811: PUSH
33812: LD_INT 2
33814: PUSH
33815: EMPTY
33816: LIST
33817: LIST
33818: PUSH
33819: LD_INT 23
33821: PUSH
33822: LD_INT 3
33824: PUSH
33825: EMPTY
33826: LIST
33827: LIST
33828: PUSH
33829: EMPTY
33830: LIST
33831: LIST
33832: LIST
33833: PPUSH
33834: CALL_OW 69
33838: IN
33839: IFFALSE 33866
// begin ComUpgrade ( building ) ;
33841: LD_VAR 0 1
33845: PPUSH
33846: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
33850: LD_EXP 61
33854: PPUSH
33855: LD_VAR 0 1
33859: PPUSH
33860: CALL 74982 0 2
// exit ;
33864: GO 33875
// end ; MCE_BuildingComplete ( building ) ;
33866: LD_VAR 0 1
33870: PPUSH
33871: CALL 63585 0 1
// end ;
33875: PPOPN 1
33877: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
33878: LD_VAR 0 1
33882: PPUSH
33883: LD_VAR 0 2
33887: PPUSH
33888: CALL 61638 0 2
// end ;
33892: PPOPN 2
33894: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
33895: LD_VAR 0 1
33899: PPUSH
33900: LD_VAR 0 2
33904: PPUSH
33905: LD_VAR 0 3
33909: PPUSH
33910: LD_VAR 0 4
33914: PPUSH
33915: LD_VAR 0 5
33919: PPUSH
33920: CALL 61258 0 5
// end ;
33924: PPOPN 5
33926: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
33927: LD_VAR 0 1
33931: PPUSH
33932: LD_VAR 0 2
33936: PPUSH
33937: CALL 60854 0 2
// end ;
33941: PPOPN 2
33943: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
33944: LD_VAR 0 1
33948: PPUSH
33949: LD_VAR 0 2
33953: PPUSH
33954: LD_VAR 0 3
33958: PPUSH
33959: LD_VAR 0 4
33963: PPUSH
33964: CALL 60692 0 4
// end ;
33968: PPOPN 4
33970: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
33971: LD_VAR 0 1
33975: PPUSH
33976: LD_VAR 0 2
33980: PPUSH
33981: LD_VAR 0 3
33985: PPUSH
33986: CALL 60467 0 3
// end ;
33990: PPOPN 3
33992: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
33993: LD_VAR 0 1
33997: PPUSH
33998: LD_VAR 0 2
34002: PPUSH
34003: CALL 60352 0 2
// end ;
34007: PPOPN 2
34009: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34010: LD_VAR 0 1
34014: PPUSH
34015: LD_VAR 0 2
34019: PPUSH
34020: CALL 64537 0 2
// end ;
34024: PPOPN 2
34026: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34027: LD_VAR 0 1
34031: PPUSH
34032: CALL_OW 255
34036: PUSH
34037: LD_INT 4
34039: EQUAL
34040: PUSH
34041: LD_VAR 0 1
34045: PUSH
34046: LD_EXP 18
34050: PUSH
34051: LD_INT 1
34053: ARRAY
34054: IN
34055: AND
34056: PUSH
34057: LD_EXP 19
34061: AND
34062: IFFALSE 34081
// begin ComMoveXY ( driver , 61 , 93 ) ;
34064: LD_VAR 0 1
34068: PPUSH
34069: LD_INT 61
34071: PPUSH
34072: LD_INT 93
34074: PPUSH
34075: CALL_OW 111
// exit ;
34079: GO 34105
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34081: LD_VAR 0 1
34085: PPUSH
34086: LD_VAR 0 2
34090: PPUSH
34091: LD_VAR 0 3
34095: PPUSH
34096: LD_VAR 0 4
34100: PPUSH
34101: CALL 64753 0 4
// end ;
34105: PPOPN 4
34107: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34108: LD_VAR 0 1
34112: PPUSH
34113: LD_VAR 0 2
34117: PPUSH
34118: CALL 60161 0 2
// end ;
34122: PPOPN 2
34124: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34125: LD_VAR 0 1
34129: PPUSH
34130: CALL 119003 0 1
// end ; end_of_file
34134: PPOPN 1
34136: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34137: LD_EXP 15
34141: PUSH
34142: LD_INT 2
34144: EQUAL
34145: IFFALSE 34624
34147: GO 34149
34149: DISABLE
34150: LD_INT 0
34152: PPUSH
// begin time := 0 0$40 ;
34153: LD_ADDR_VAR 0 1
34157: PUSH
34158: LD_INT 1400
34160: ST_TO_ADDR
// repeat wait ( time ) ;
34161: LD_VAR 0 1
34165: PPUSH
34166: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34170: LD_INT 1
34172: PPUSH
34173: LD_INT 5
34175: PPUSH
34176: CALL_OW 12
34180: PPUSH
34181: LD_INT 106
34183: PPUSH
34184: LD_INT 150
34186: PPUSH
34187: LD_INT 19
34189: PPUSH
34190: LD_INT 1
34192: PPUSH
34193: CALL_OW 56
// time := time + 0 0$9 ;
34197: LD_ADDR_VAR 0 1
34201: PUSH
34202: LD_VAR 0 1
34206: PUSH
34207: LD_INT 315
34209: PLUS
34210: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34211: LD_INT 455
34213: PPUSH
34214: LD_INT 840
34216: PPUSH
34217: CALL_OW 12
34221: PPUSH
34222: CALL_OW 67
// if Prob ( 50 ) then
34226: LD_INT 50
34228: PPUSH
34229: CALL_OW 13
34233: IFFALSE 34262
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34235: LD_INT 1
34237: PPUSH
34238: LD_INT 5
34240: PPUSH
34241: CALL_OW 12
34245: PPUSH
34246: LD_INT 62
34248: PPUSH
34249: LD_INT 108
34251: PPUSH
34252: LD_INT 10
34254: PPUSH
34255: LD_INT 1
34257: PPUSH
34258: CALL_OW 56
// until missionStage > 4 ;
34262: LD_EXP 15
34266: PUSH
34267: LD_INT 4
34269: GREATER
34270: IFFALSE 34161
// repeat wait ( 0 0$1 ) ;
34272: LD_INT 35
34274: PPUSH
34275: CALL_OW 67
// until missionStage = 6 ;
34279: LD_EXP 15
34283: PUSH
34284: LD_INT 6
34286: EQUAL
34287: IFFALSE 34272
// time := 0 0$50 ;
34289: LD_ADDR_VAR 0 1
34293: PUSH
34294: LD_INT 1750
34296: ST_TO_ADDR
// repeat wait ( time ) ;
34297: LD_VAR 0 1
34301: PPUSH
34302: CALL_OW 67
// if Prob ( 50 ) then
34306: LD_INT 50
34308: PPUSH
34309: CALL_OW 13
34313: IFFALSE 34342
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34315: LD_INT 1
34317: PPUSH
34318: LD_INT 5
34320: PPUSH
34321: CALL_OW 12
34325: PPUSH
34326: LD_INT 106
34328: PPUSH
34329: LD_INT 89
34331: PPUSH
34332: LD_INT 45
34334: PPUSH
34335: LD_INT 1
34337: PPUSH
34338: CALL_OW 56
// time := time + 0 0$2 ;
34342: LD_ADDR_VAR 0 1
34346: PUSH
34347: LD_VAR 0 1
34351: PUSH
34352: LD_INT 70
34354: PLUS
34355: ST_TO_ADDR
// if Prob ( 30 ) then
34356: LD_INT 30
34358: PPUSH
34359: CALL_OW 13
34363: IFFALSE 34409
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34365: LD_INT 385
34367: PPUSH
34368: LD_INT 945
34370: PPUSH
34371: CALL_OW 12
34375: PPUSH
34376: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34380: LD_INT 1
34382: PPUSH
34383: LD_INT 5
34385: PPUSH
34386: CALL_OW 12
34390: PPUSH
34391: LD_INT 21
34393: PPUSH
34394: LD_INT 26
34396: PPUSH
34397: LD_INT 12
34399: PPUSH
34400: LD_INT 1
34402: PPUSH
34403: CALL_OW 56
// end else
34407: GO 34445
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34409: LD_INT 700
34411: PPUSH
34412: LD_INT 1225
34414: PPUSH
34415: CALL_OW 12
34419: PPUSH
34420: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34424: LD_INT 1
34426: PPUSH
34427: LD_INT 5
34429: PPUSH
34430: CALL_OW 12
34434: PPUSH
34435: LD_INT 16
34437: PPUSH
34438: LD_INT 1
34440: PPUSH
34441: CALL_OW 55
// end ; if Prob ( 50 ) then
34445: LD_INT 50
34447: PPUSH
34448: CALL_OW 13
34452: IFFALSE 34498
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34454: LD_INT 700
34456: PPUSH
34457: LD_INT 1050
34459: PPUSH
34460: CALL_OW 12
34464: PPUSH
34465: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34469: LD_INT 1
34471: PPUSH
34472: LD_INT 5
34474: PPUSH
34475: CALL_OW 12
34479: PPUSH
34480: LD_INT 181
34482: PPUSH
34483: LD_INT 218
34485: PPUSH
34486: LD_INT 16
34488: PPUSH
34489: LD_INT 1
34491: PPUSH
34492: CALL_OW 56
// end else
34496: GO 34534
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34498: LD_INT 350
34500: PPUSH
34501: LD_INT 525
34503: PPUSH
34504: CALL_OW 12
34508: PPUSH
34509: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34513: LD_INT 1
34515: PPUSH
34516: LD_INT 5
34518: PPUSH
34519: CALL_OW 12
34523: PPUSH
34524: LD_INT 15
34526: PPUSH
34527: LD_INT 1
34529: PPUSH
34530: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
34534: LD_INT 45
34536: PUSH
34537: LD_INT 32
34539: PUSH
34540: LD_INT 25
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: LIST
34547: PUSH
34548: LD_OWVAR 67
34552: ARRAY
34553: PPUSH
34554: CALL_OW 13
34558: IFFALSE 34602
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34560: LD_INT 175
34562: PPUSH
34563: LD_INT 315
34565: PPUSH
34566: CALL_OW 12
34570: PPUSH
34571: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34575: LD_INT 1
34577: PPUSH
34578: LD_INT 5
34580: PPUSH
34581: CALL_OW 12
34585: PPUSH
34586: LD_INT 103
34588: PPUSH
34589: LD_INT 140
34591: PPUSH
34592: LD_INT 20
34594: PPUSH
34595: LD_INT 1
34597: PPUSH
34598: CALL_OW 56
// end ; if time > 1 1$20 then
34602: LD_VAR 0 1
34606: PUSH
34607: LD_INT 2800
34609: GREATER
34610: IFFALSE 34620
// time := 0 0$30 ;
34612: LD_ADDR_VAR 0 1
34616: PUSH
34617: LD_INT 1050
34619: ST_TO_ADDR
// until false ;
34620: LD_INT 0
34622: IFFALSE 34297
// end ; end_of_file
34624: PPOPN 1
34626: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34627: LD_EXP 13
34631: PUSH
34632: LD_EXP 15
34636: PUSH
34637: LD_INT 6
34639: GREATEREQUAL
34640: AND
34641: IFFALSE 34678
34643: GO 34645
34645: DISABLE
// begin enable ;
34646: ENABLE
// missionTime := missionTime + 0 0$1 ;
34647: LD_ADDR_EXP 14
34651: PUSH
34652: LD_EXP 14
34656: PUSH
34657: LD_INT 35
34659: PLUS
34660: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34661: LD_ADDR_OWVAR 47
34665: PUSH
34666: LD_STRING #Am15-1
34668: PUSH
34669: LD_EXP 14
34673: PUSH
34674: EMPTY
34675: LIST
34676: LIST
34677: ST_TO_ADDR
// end ; end_of_file
34678: END
// export function InitNature ; begin
34679: LD_INT 0
34681: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34682: LD_INT 3
34684: PPUSH
34685: LD_INT 3
34687: PPUSH
34688: LD_INT 2
34690: PPUSH
34691: LD_INT 1
34693: PPUSH
34694: LD_INT 1
34696: PPUSH
34697: LD_INT 0
34699: PPUSH
34700: LD_INT 0
34702: PPUSH
34703: LD_INT 20
34705: PPUSH
34706: LD_INT 0
34708: PPUSH
34709: CALL 99800 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34713: LD_INT 2
34715: PPUSH
34716: LD_INT 1
34718: PPUSH
34719: LD_INT 1
34721: PPUSH
34722: LD_INT 1
34724: PPUSH
34725: LD_INT 1
34727: PPUSH
34728: LD_INT 0
34730: PPUSH
34731: LD_INT 0
34733: PPUSH
34734: LD_INT 21
34736: PPUSH
34737: LD_INT 0
34739: PPUSH
34740: CALL 99800 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34744: LD_INT 4
34746: PPUSH
34747: LD_INT 1
34749: PPUSH
34750: LD_INT 2
34752: PPUSH
34753: LD_INT 4
34755: PPUSH
34756: LD_INT 2
34758: PPUSH
34759: LD_INT 1
34761: PPUSH
34762: LD_INT 0
34764: PPUSH
34765: LD_INT 22
34767: PPUSH
34768: LD_INT 0
34770: PPUSH
34771: CALL 99800 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34775: LD_INT 0
34777: PPUSH
34778: LD_INT 0
34780: PPUSH
34781: LD_INT 0
34783: PPUSH
34784: LD_INT 0
34786: PPUSH
34787: LD_INT 0
34789: PPUSH
34790: LD_INT 0
34792: PPUSH
34793: LD_INT 9
34795: PPUSH
34796: LD_INT 0
34798: PPUSH
34799: LD_INT 23
34801: PPUSH
34802: CALL 99800 0 9
// end ; end_of_file
34806: LD_VAR 0 1
34810: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
34811: GO 34813
34813: DISABLE
// begin ru_radar := 98 ;
34814: LD_ADDR_EXP 95
34818: PUSH
34819: LD_INT 98
34821: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34822: LD_ADDR_EXP 96
34826: PUSH
34827: LD_INT 89
34829: ST_TO_ADDR
// us_hack := 99 ;
34830: LD_ADDR_EXP 97
34834: PUSH
34835: LD_INT 99
34837: ST_TO_ADDR
// us_artillery := 97 ;
34838: LD_ADDR_EXP 98
34842: PUSH
34843: LD_INT 97
34845: ST_TO_ADDR
// ar_bio_bomb := 91 ;
34846: LD_ADDR_EXP 99
34850: PUSH
34851: LD_INT 91
34853: ST_TO_ADDR
// end ; end_of_file
34854: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
34855: LD_INT 0
34857: PPUSH
34858: PPUSH
// skirmish := false ;
34859: LD_ADDR_EXP 100
34863: PUSH
34864: LD_INT 0
34866: ST_TO_ADDR
// debug_mc := false ;
34867: LD_ADDR_EXP 101
34871: PUSH
34872: LD_INT 0
34874: ST_TO_ADDR
// mc_bases := [ ] ;
34875: LD_ADDR_EXP 102
34879: PUSH
34880: EMPTY
34881: ST_TO_ADDR
// mc_sides := [ ] ;
34882: LD_ADDR_EXP 128
34886: PUSH
34887: EMPTY
34888: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
34889: LD_ADDR_EXP 103
34893: PUSH
34894: EMPTY
34895: ST_TO_ADDR
// mc_building_repairs := [ ] ;
34896: LD_ADDR_EXP 104
34900: PUSH
34901: EMPTY
34902: ST_TO_ADDR
// mc_need_heal := [ ] ;
34903: LD_ADDR_EXP 105
34907: PUSH
34908: EMPTY
34909: ST_TO_ADDR
// mc_healers := [ ] ;
34910: LD_ADDR_EXP 106
34914: PUSH
34915: EMPTY
34916: ST_TO_ADDR
// mc_build_list := [ ] ;
34917: LD_ADDR_EXP 107
34921: PUSH
34922: EMPTY
34923: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
34924: LD_ADDR_EXP 134
34928: PUSH
34929: EMPTY
34930: ST_TO_ADDR
// mc_builders := [ ] ;
34931: LD_ADDR_EXP 108
34935: PUSH
34936: EMPTY
34937: ST_TO_ADDR
// mc_construct_list := [ ] ;
34938: LD_ADDR_EXP 109
34942: PUSH
34943: EMPTY
34944: ST_TO_ADDR
// mc_turret_list := [ ] ;
34945: LD_ADDR_EXP 110
34949: PUSH
34950: EMPTY
34951: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
34952: LD_ADDR_EXP 111
34956: PUSH
34957: EMPTY
34958: ST_TO_ADDR
// mc_miners := [ ] ;
34959: LD_ADDR_EXP 116
34963: PUSH
34964: EMPTY
34965: ST_TO_ADDR
// mc_mines := [ ] ;
34966: LD_ADDR_EXP 115
34970: PUSH
34971: EMPTY
34972: ST_TO_ADDR
// mc_minefields := [ ] ;
34973: LD_ADDR_EXP 117
34977: PUSH
34978: EMPTY
34979: ST_TO_ADDR
// mc_crates := [ ] ;
34980: LD_ADDR_EXP 118
34984: PUSH
34985: EMPTY
34986: ST_TO_ADDR
// mc_crates_collector := [ ] ;
34987: LD_ADDR_EXP 119
34991: PUSH
34992: EMPTY
34993: ST_TO_ADDR
// mc_crates_area := [ ] ;
34994: LD_ADDR_EXP 120
34998: PUSH
34999: EMPTY
35000: ST_TO_ADDR
// mc_vehicles := [ ] ;
35001: LD_ADDR_EXP 121
35005: PUSH
35006: EMPTY
35007: ST_TO_ADDR
// mc_attack := [ ] ;
35008: LD_ADDR_EXP 122
35012: PUSH
35013: EMPTY
35014: ST_TO_ADDR
// mc_produce := [ ] ;
35015: LD_ADDR_EXP 123
35019: PUSH
35020: EMPTY
35021: ST_TO_ADDR
// mc_defender := [ ] ;
35022: LD_ADDR_EXP 124
35026: PUSH
35027: EMPTY
35028: ST_TO_ADDR
// mc_parking := [ ] ;
35029: LD_ADDR_EXP 126
35033: PUSH
35034: EMPTY
35035: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35036: LD_ADDR_EXP 112
35040: PUSH
35041: EMPTY
35042: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35043: LD_ADDR_EXP 114
35047: PUSH
35048: EMPTY
35049: ST_TO_ADDR
// mc_scan := [ ] ;
35050: LD_ADDR_EXP 125
35054: PUSH
35055: EMPTY
35056: ST_TO_ADDR
// mc_scan_area := [ ] ;
35057: LD_ADDR_EXP 127
35061: PUSH
35062: EMPTY
35063: ST_TO_ADDR
// mc_tech := [ ] ;
35064: LD_ADDR_EXP 129
35068: PUSH
35069: EMPTY
35070: ST_TO_ADDR
// mc_class := [ ] ;
35071: LD_ADDR_EXP 143
35075: PUSH
35076: EMPTY
35077: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35078: LD_ADDR_EXP 144
35082: PUSH
35083: EMPTY
35084: ST_TO_ADDR
// end ;
35085: LD_VAR 0 1
35089: RET
// export function MC_Kill ( base ) ; begin
35090: LD_INT 0
35092: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35093: LD_ADDR_EXP 102
35097: PUSH
35098: LD_EXP 102
35102: PPUSH
35103: LD_VAR 0 1
35107: PPUSH
35108: EMPTY
35109: PPUSH
35110: CALL_OW 1
35114: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35115: LD_ADDR_EXP 103
35119: PUSH
35120: LD_EXP 103
35124: PPUSH
35125: LD_VAR 0 1
35129: PPUSH
35130: EMPTY
35131: PPUSH
35132: CALL_OW 1
35136: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35137: LD_ADDR_EXP 104
35141: PUSH
35142: LD_EXP 104
35146: PPUSH
35147: LD_VAR 0 1
35151: PPUSH
35152: EMPTY
35153: PPUSH
35154: CALL_OW 1
35158: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35159: LD_ADDR_EXP 105
35163: PUSH
35164: LD_EXP 105
35168: PPUSH
35169: LD_VAR 0 1
35173: PPUSH
35174: EMPTY
35175: PPUSH
35176: CALL_OW 1
35180: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35181: LD_ADDR_EXP 106
35185: PUSH
35186: LD_EXP 106
35190: PPUSH
35191: LD_VAR 0 1
35195: PPUSH
35196: EMPTY
35197: PPUSH
35198: CALL_OW 1
35202: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35203: LD_ADDR_EXP 107
35207: PUSH
35208: LD_EXP 107
35212: PPUSH
35213: LD_VAR 0 1
35217: PPUSH
35218: EMPTY
35219: PPUSH
35220: CALL_OW 1
35224: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35225: LD_ADDR_EXP 108
35229: PUSH
35230: LD_EXP 108
35234: PPUSH
35235: LD_VAR 0 1
35239: PPUSH
35240: EMPTY
35241: PPUSH
35242: CALL_OW 1
35246: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35247: LD_ADDR_EXP 109
35251: PUSH
35252: LD_EXP 109
35256: PPUSH
35257: LD_VAR 0 1
35261: PPUSH
35262: EMPTY
35263: PPUSH
35264: CALL_OW 1
35268: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35269: LD_ADDR_EXP 110
35273: PUSH
35274: LD_EXP 110
35278: PPUSH
35279: LD_VAR 0 1
35283: PPUSH
35284: EMPTY
35285: PPUSH
35286: CALL_OW 1
35290: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35291: LD_ADDR_EXP 111
35295: PUSH
35296: LD_EXP 111
35300: PPUSH
35301: LD_VAR 0 1
35305: PPUSH
35306: EMPTY
35307: PPUSH
35308: CALL_OW 1
35312: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35313: LD_ADDR_EXP 112
35317: PUSH
35318: LD_EXP 112
35322: PPUSH
35323: LD_VAR 0 1
35327: PPUSH
35328: EMPTY
35329: PPUSH
35330: CALL_OW 1
35334: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35335: LD_ADDR_EXP 113
35339: PUSH
35340: LD_EXP 113
35344: PPUSH
35345: LD_VAR 0 1
35349: PPUSH
35350: LD_INT 0
35352: PPUSH
35353: CALL_OW 1
35357: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35358: LD_ADDR_EXP 114
35362: PUSH
35363: LD_EXP 114
35367: PPUSH
35368: LD_VAR 0 1
35372: PPUSH
35373: EMPTY
35374: PPUSH
35375: CALL_OW 1
35379: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35380: LD_ADDR_EXP 115
35384: PUSH
35385: LD_EXP 115
35389: PPUSH
35390: LD_VAR 0 1
35394: PPUSH
35395: EMPTY
35396: PPUSH
35397: CALL_OW 1
35401: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35402: LD_ADDR_EXP 116
35406: PUSH
35407: LD_EXP 116
35411: PPUSH
35412: LD_VAR 0 1
35416: PPUSH
35417: EMPTY
35418: PPUSH
35419: CALL_OW 1
35423: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35424: LD_ADDR_EXP 117
35428: PUSH
35429: LD_EXP 117
35433: PPUSH
35434: LD_VAR 0 1
35438: PPUSH
35439: EMPTY
35440: PPUSH
35441: CALL_OW 1
35445: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35446: LD_ADDR_EXP 118
35450: PUSH
35451: LD_EXP 118
35455: PPUSH
35456: LD_VAR 0 1
35460: PPUSH
35461: EMPTY
35462: PPUSH
35463: CALL_OW 1
35467: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35468: LD_ADDR_EXP 119
35472: PUSH
35473: LD_EXP 119
35477: PPUSH
35478: LD_VAR 0 1
35482: PPUSH
35483: EMPTY
35484: PPUSH
35485: CALL_OW 1
35489: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35490: LD_ADDR_EXP 120
35494: PUSH
35495: LD_EXP 120
35499: PPUSH
35500: LD_VAR 0 1
35504: PPUSH
35505: EMPTY
35506: PPUSH
35507: CALL_OW 1
35511: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35512: LD_ADDR_EXP 121
35516: PUSH
35517: LD_EXP 121
35521: PPUSH
35522: LD_VAR 0 1
35526: PPUSH
35527: EMPTY
35528: PPUSH
35529: CALL_OW 1
35533: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35534: LD_ADDR_EXP 122
35538: PUSH
35539: LD_EXP 122
35543: PPUSH
35544: LD_VAR 0 1
35548: PPUSH
35549: EMPTY
35550: PPUSH
35551: CALL_OW 1
35555: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35556: LD_ADDR_EXP 123
35560: PUSH
35561: LD_EXP 123
35565: PPUSH
35566: LD_VAR 0 1
35570: PPUSH
35571: EMPTY
35572: PPUSH
35573: CALL_OW 1
35577: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35578: LD_ADDR_EXP 124
35582: PUSH
35583: LD_EXP 124
35587: PPUSH
35588: LD_VAR 0 1
35592: PPUSH
35593: EMPTY
35594: PPUSH
35595: CALL_OW 1
35599: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35600: LD_ADDR_EXP 125
35604: PUSH
35605: LD_EXP 125
35609: PPUSH
35610: LD_VAR 0 1
35614: PPUSH
35615: EMPTY
35616: PPUSH
35617: CALL_OW 1
35621: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35622: LD_ADDR_EXP 126
35626: PUSH
35627: LD_EXP 126
35631: PPUSH
35632: LD_VAR 0 1
35636: PPUSH
35637: EMPTY
35638: PPUSH
35639: CALL_OW 1
35643: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35644: LD_ADDR_EXP 127
35648: PUSH
35649: LD_EXP 127
35653: PPUSH
35654: LD_VAR 0 1
35658: PPUSH
35659: EMPTY
35660: PPUSH
35661: CALL_OW 1
35665: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35666: LD_ADDR_EXP 129
35670: PUSH
35671: LD_EXP 129
35675: PPUSH
35676: LD_VAR 0 1
35680: PPUSH
35681: EMPTY
35682: PPUSH
35683: CALL_OW 1
35687: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35688: LD_ADDR_EXP 131
35692: PUSH
35693: LD_EXP 131
35697: PPUSH
35698: LD_VAR 0 1
35702: PPUSH
35703: EMPTY
35704: PPUSH
35705: CALL_OW 1
35709: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35710: LD_ADDR_EXP 132
35714: PUSH
35715: LD_EXP 132
35719: PPUSH
35720: LD_VAR 0 1
35724: PPUSH
35725: EMPTY
35726: PPUSH
35727: CALL_OW 1
35731: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35732: LD_ADDR_EXP 133
35736: PUSH
35737: LD_EXP 133
35741: PPUSH
35742: LD_VAR 0 1
35746: PPUSH
35747: EMPTY
35748: PPUSH
35749: CALL_OW 1
35753: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35754: LD_ADDR_EXP 134
35758: PUSH
35759: LD_EXP 134
35763: PPUSH
35764: LD_VAR 0 1
35768: PPUSH
35769: EMPTY
35770: PPUSH
35771: CALL_OW 1
35775: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35776: LD_ADDR_EXP 135
35780: PUSH
35781: LD_EXP 135
35785: PPUSH
35786: LD_VAR 0 1
35790: PPUSH
35791: EMPTY
35792: PPUSH
35793: CALL_OW 1
35797: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35798: LD_ADDR_EXP 136
35802: PUSH
35803: LD_EXP 136
35807: PPUSH
35808: LD_VAR 0 1
35812: PPUSH
35813: EMPTY
35814: PPUSH
35815: CALL_OW 1
35819: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35820: LD_ADDR_EXP 137
35824: PUSH
35825: LD_EXP 137
35829: PPUSH
35830: LD_VAR 0 1
35834: PPUSH
35835: EMPTY
35836: PPUSH
35837: CALL_OW 1
35841: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35842: LD_ADDR_EXP 138
35846: PUSH
35847: LD_EXP 138
35851: PPUSH
35852: LD_VAR 0 1
35856: PPUSH
35857: EMPTY
35858: PPUSH
35859: CALL_OW 1
35863: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35864: LD_ADDR_EXP 139
35868: PUSH
35869: LD_EXP 139
35873: PPUSH
35874: LD_VAR 0 1
35878: PPUSH
35879: EMPTY
35880: PPUSH
35881: CALL_OW 1
35885: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35886: LD_ADDR_EXP 140
35890: PUSH
35891: LD_EXP 140
35895: PPUSH
35896: LD_VAR 0 1
35900: PPUSH
35901: EMPTY
35902: PPUSH
35903: CALL_OW 1
35907: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35908: LD_ADDR_EXP 141
35912: PUSH
35913: LD_EXP 141
35917: PPUSH
35918: LD_VAR 0 1
35922: PPUSH
35923: EMPTY
35924: PPUSH
35925: CALL_OW 1
35929: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35930: LD_ADDR_EXP 142
35934: PUSH
35935: LD_EXP 142
35939: PPUSH
35940: LD_VAR 0 1
35944: PPUSH
35945: EMPTY
35946: PPUSH
35947: CALL_OW 1
35951: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35952: LD_ADDR_EXP 143
35956: PUSH
35957: LD_EXP 143
35961: PPUSH
35962: LD_VAR 0 1
35966: PPUSH
35967: EMPTY
35968: PPUSH
35969: CALL_OW 1
35973: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35974: LD_ADDR_EXP 144
35978: PUSH
35979: LD_EXP 144
35983: PPUSH
35984: LD_VAR 0 1
35988: PPUSH
35989: LD_INT 0
35991: PPUSH
35992: CALL_OW 1
35996: ST_TO_ADDR
// end ;
35997: LD_VAR 0 2
36001: RET
// export function MC_Add ( side , units ) ; var base ; begin
36002: LD_INT 0
36004: PPUSH
36005: PPUSH
// base := mc_bases + 1 ;
36006: LD_ADDR_VAR 0 4
36010: PUSH
36011: LD_EXP 102
36015: PUSH
36016: LD_INT 1
36018: PLUS
36019: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36020: LD_ADDR_EXP 128
36024: PUSH
36025: LD_EXP 128
36029: PPUSH
36030: LD_VAR 0 4
36034: PPUSH
36035: LD_VAR 0 1
36039: PPUSH
36040: CALL_OW 1
36044: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36045: LD_ADDR_EXP 102
36049: PUSH
36050: LD_EXP 102
36054: PPUSH
36055: LD_VAR 0 4
36059: PPUSH
36060: LD_VAR 0 2
36064: PPUSH
36065: CALL_OW 1
36069: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36070: LD_ADDR_EXP 103
36074: PUSH
36075: LD_EXP 103
36079: PPUSH
36080: LD_VAR 0 4
36084: PPUSH
36085: EMPTY
36086: PPUSH
36087: CALL_OW 1
36091: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36092: LD_ADDR_EXP 104
36096: PUSH
36097: LD_EXP 104
36101: PPUSH
36102: LD_VAR 0 4
36106: PPUSH
36107: EMPTY
36108: PPUSH
36109: CALL_OW 1
36113: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36114: LD_ADDR_EXP 105
36118: PUSH
36119: LD_EXP 105
36123: PPUSH
36124: LD_VAR 0 4
36128: PPUSH
36129: EMPTY
36130: PPUSH
36131: CALL_OW 1
36135: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36136: LD_ADDR_EXP 106
36140: PUSH
36141: LD_EXP 106
36145: PPUSH
36146: LD_VAR 0 4
36150: PPUSH
36151: EMPTY
36152: PPUSH
36153: CALL_OW 1
36157: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36158: LD_ADDR_EXP 107
36162: PUSH
36163: LD_EXP 107
36167: PPUSH
36168: LD_VAR 0 4
36172: PPUSH
36173: EMPTY
36174: PPUSH
36175: CALL_OW 1
36179: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36180: LD_ADDR_EXP 108
36184: PUSH
36185: LD_EXP 108
36189: PPUSH
36190: LD_VAR 0 4
36194: PPUSH
36195: EMPTY
36196: PPUSH
36197: CALL_OW 1
36201: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36202: LD_ADDR_EXP 109
36206: PUSH
36207: LD_EXP 109
36211: PPUSH
36212: LD_VAR 0 4
36216: PPUSH
36217: EMPTY
36218: PPUSH
36219: CALL_OW 1
36223: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36224: LD_ADDR_EXP 110
36228: PUSH
36229: LD_EXP 110
36233: PPUSH
36234: LD_VAR 0 4
36238: PPUSH
36239: EMPTY
36240: PPUSH
36241: CALL_OW 1
36245: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36246: LD_ADDR_EXP 111
36250: PUSH
36251: LD_EXP 111
36255: PPUSH
36256: LD_VAR 0 4
36260: PPUSH
36261: EMPTY
36262: PPUSH
36263: CALL_OW 1
36267: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36268: LD_ADDR_EXP 112
36272: PUSH
36273: LD_EXP 112
36277: PPUSH
36278: LD_VAR 0 4
36282: PPUSH
36283: EMPTY
36284: PPUSH
36285: CALL_OW 1
36289: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36290: LD_ADDR_EXP 113
36294: PUSH
36295: LD_EXP 113
36299: PPUSH
36300: LD_VAR 0 4
36304: PPUSH
36305: LD_INT 0
36307: PPUSH
36308: CALL_OW 1
36312: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36313: LD_ADDR_EXP 114
36317: PUSH
36318: LD_EXP 114
36322: PPUSH
36323: LD_VAR 0 4
36327: PPUSH
36328: EMPTY
36329: PPUSH
36330: CALL_OW 1
36334: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36335: LD_ADDR_EXP 115
36339: PUSH
36340: LD_EXP 115
36344: PPUSH
36345: LD_VAR 0 4
36349: PPUSH
36350: EMPTY
36351: PPUSH
36352: CALL_OW 1
36356: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36357: LD_ADDR_EXP 116
36361: PUSH
36362: LD_EXP 116
36366: PPUSH
36367: LD_VAR 0 4
36371: PPUSH
36372: EMPTY
36373: PPUSH
36374: CALL_OW 1
36378: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36379: LD_ADDR_EXP 117
36383: PUSH
36384: LD_EXP 117
36388: PPUSH
36389: LD_VAR 0 4
36393: PPUSH
36394: EMPTY
36395: PPUSH
36396: CALL_OW 1
36400: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36401: LD_ADDR_EXP 118
36405: PUSH
36406: LD_EXP 118
36410: PPUSH
36411: LD_VAR 0 4
36415: PPUSH
36416: EMPTY
36417: PPUSH
36418: CALL_OW 1
36422: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36423: LD_ADDR_EXP 119
36427: PUSH
36428: LD_EXP 119
36432: PPUSH
36433: LD_VAR 0 4
36437: PPUSH
36438: EMPTY
36439: PPUSH
36440: CALL_OW 1
36444: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36445: LD_ADDR_EXP 120
36449: PUSH
36450: LD_EXP 120
36454: PPUSH
36455: LD_VAR 0 4
36459: PPUSH
36460: EMPTY
36461: PPUSH
36462: CALL_OW 1
36466: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36467: LD_ADDR_EXP 121
36471: PUSH
36472: LD_EXP 121
36476: PPUSH
36477: LD_VAR 0 4
36481: PPUSH
36482: EMPTY
36483: PPUSH
36484: CALL_OW 1
36488: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36489: LD_ADDR_EXP 122
36493: PUSH
36494: LD_EXP 122
36498: PPUSH
36499: LD_VAR 0 4
36503: PPUSH
36504: EMPTY
36505: PPUSH
36506: CALL_OW 1
36510: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36511: LD_ADDR_EXP 123
36515: PUSH
36516: LD_EXP 123
36520: PPUSH
36521: LD_VAR 0 4
36525: PPUSH
36526: EMPTY
36527: PPUSH
36528: CALL_OW 1
36532: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36533: LD_ADDR_EXP 124
36537: PUSH
36538: LD_EXP 124
36542: PPUSH
36543: LD_VAR 0 4
36547: PPUSH
36548: EMPTY
36549: PPUSH
36550: CALL_OW 1
36554: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36555: LD_ADDR_EXP 125
36559: PUSH
36560: LD_EXP 125
36564: PPUSH
36565: LD_VAR 0 4
36569: PPUSH
36570: EMPTY
36571: PPUSH
36572: CALL_OW 1
36576: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36577: LD_ADDR_EXP 126
36581: PUSH
36582: LD_EXP 126
36586: PPUSH
36587: LD_VAR 0 4
36591: PPUSH
36592: EMPTY
36593: PPUSH
36594: CALL_OW 1
36598: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36599: LD_ADDR_EXP 127
36603: PUSH
36604: LD_EXP 127
36608: PPUSH
36609: LD_VAR 0 4
36613: PPUSH
36614: EMPTY
36615: PPUSH
36616: CALL_OW 1
36620: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36621: LD_ADDR_EXP 129
36625: PUSH
36626: LD_EXP 129
36630: PPUSH
36631: LD_VAR 0 4
36635: PPUSH
36636: EMPTY
36637: PPUSH
36638: CALL_OW 1
36642: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36643: LD_ADDR_EXP 131
36647: PUSH
36648: LD_EXP 131
36652: PPUSH
36653: LD_VAR 0 4
36657: PPUSH
36658: EMPTY
36659: PPUSH
36660: CALL_OW 1
36664: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36665: LD_ADDR_EXP 132
36669: PUSH
36670: LD_EXP 132
36674: PPUSH
36675: LD_VAR 0 4
36679: PPUSH
36680: EMPTY
36681: PPUSH
36682: CALL_OW 1
36686: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36687: LD_ADDR_EXP 133
36691: PUSH
36692: LD_EXP 133
36696: PPUSH
36697: LD_VAR 0 4
36701: PPUSH
36702: EMPTY
36703: PPUSH
36704: CALL_OW 1
36708: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36709: LD_ADDR_EXP 134
36713: PUSH
36714: LD_EXP 134
36718: PPUSH
36719: LD_VAR 0 4
36723: PPUSH
36724: EMPTY
36725: PPUSH
36726: CALL_OW 1
36730: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36731: LD_ADDR_EXP 135
36735: PUSH
36736: LD_EXP 135
36740: PPUSH
36741: LD_VAR 0 4
36745: PPUSH
36746: EMPTY
36747: PPUSH
36748: CALL_OW 1
36752: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36753: LD_ADDR_EXP 136
36757: PUSH
36758: LD_EXP 136
36762: PPUSH
36763: LD_VAR 0 4
36767: PPUSH
36768: EMPTY
36769: PPUSH
36770: CALL_OW 1
36774: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36775: LD_ADDR_EXP 137
36779: PUSH
36780: LD_EXP 137
36784: PPUSH
36785: LD_VAR 0 4
36789: PPUSH
36790: EMPTY
36791: PPUSH
36792: CALL_OW 1
36796: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36797: LD_ADDR_EXP 138
36801: PUSH
36802: LD_EXP 138
36806: PPUSH
36807: LD_VAR 0 4
36811: PPUSH
36812: EMPTY
36813: PPUSH
36814: CALL_OW 1
36818: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36819: LD_ADDR_EXP 139
36823: PUSH
36824: LD_EXP 139
36828: PPUSH
36829: LD_VAR 0 4
36833: PPUSH
36834: EMPTY
36835: PPUSH
36836: CALL_OW 1
36840: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36841: LD_ADDR_EXP 140
36845: PUSH
36846: LD_EXP 140
36850: PPUSH
36851: LD_VAR 0 4
36855: PPUSH
36856: EMPTY
36857: PPUSH
36858: CALL_OW 1
36862: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36863: LD_ADDR_EXP 141
36867: PUSH
36868: LD_EXP 141
36872: PPUSH
36873: LD_VAR 0 4
36877: PPUSH
36878: EMPTY
36879: PPUSH
36880: CALL_OW 1
36884: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36885: LD_ADDR_EXP 142
36889: PUSH
36890: LD_EXP 142
36894: PPUSH
36895: LD_VAR 0 4
36899: PPUSH
36900: EMPTY
36901: PPUSH
36902: CALL_OW 1
36906: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36907: LD_ADDR_EXP 143
36911: PUSH
36912: LD_EXP 143
36916: PPUSH
36917: LD_VAR 0 4
36921: PPUSH
36922: EMPTY
36923: PPUSH
36924: CALL_OW 1
36928: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36929: LD_ADDR_EXP 144
36933: PUSH
36934: LD_EXP 144
36938: PPUSH
36939: LD_VAR 0 4
36943: PPUSH
36944: LD_INT 0
36946: PPUSH
36947: CALL_OW 1
36951: ST_TO_ADDR
// result := base ;
36952: LD_ADDR_VAR 0 3
36956: PUSH
36957: LD_VAR 0 4
36961: ST_TO_ADDR
// end ;
36962: LD_VAR 0 3
36966: RET
// export function MC_Start ( ) ; var i ; begin
36967: LD_INT 0
36969: PPUSH
36970: PPUSH
// for i = 1 to mc_bases do
36971: LD_ADDR_VAR 0 2
36975: PUSH
36976: DOUBLE
36977: LD_INT 1
36979: DEC
36980: ST_TO_ADDR
36981: LD_EXP 102
36985: PUSH
36986: FOR_TO
36987: IFFALSE 38064
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
36989: LD_ADDR_EXP 102
36993: PUSH
36994: LD_EXP 102
36998: PPUSH
36999: LD_VAR 0 2
37003: PPUSH
37004: LD_EXP 102
37008: PUSH
37009: LD_VAR 0 2
37013: ARRAY
37014: PUSH
37015: LD_INT 0
37017: DIFF
37018: PPUSH
37019: CALL_OW 1
37023: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37024: LD_ADDR_EXP 103
37028: PUSH
37029: LD_EXP 103
37033: PPUSH
37034: LD_VAR 0 2
37038: PPUSH
37039: EMPTY
37040: PPUSH
37041: CALL_OW 1
37045: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37046: LD_ADDR_EXP 104
37050: PUSH
37051: LD_EXP 104
37055: PPUSH
37056: LD_VAR 0 2
37060: PPUSH
37061: EMPTY
37062: PPUSH
37063: CALL_OW 1
37067: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37068: LD_ADDR_EXP 105
37072: PUSH
37073: LD_EXP 105
37077: PPUSH
37078: LD_VAR 0 2
37082: PPUSH
37083: EMPTY
37084: PPUSH
37085: CALL_OW 1
37089: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37090: LD_ADDR_EXP 106
37094: PUSH
37095: LD_EXP 106
37099: PPUSH
37100: LD_VAR 0 2
37104: PPUSH
37105: EMPTY
37106: PUSH
37107: EMPTY
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PPUSH
37113: CALL_OW 1
37117: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37118: LD_ADDR_EXP 107
37122: PUSH
37123: LD_EXP 107
37127: PPUSH
37128: LD_VAR 0 2
37132: PPUSH
37133: EMPTY
37134: PPUSH
37135: CALL_OW 1
37139: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37140: LD_ADDR_EXP 134
37144: PUSH
37145: LD_EXP 134
37149: PPUSH
37150: LD_VAR 0 2
37154: PPUSH
37155: EMPTY
37156: PPUSH
37157: CALL_OW 1
37161: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37162: LD_ADDR_EXP 108
37166: PUSH
37167: LD_EXP 108
37171: PPUSH
37172: LD_VAR 0 2
37176: PPUSH
37177: EMPTY
37178: PPUSH
37179: CALL_OW 1
37183: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37184: LD_ADDR_EXP 109
37188: PUSH
37189: LD_EXP 109
37193: PPUSH
37194: LD_VAR 0 2
37198: PPUSH
37199: EMPTY
37200: PPUSH
37201: CALL_OW 1
37205: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37206: LD_ADDR_EXP 110
37210: PUSH
37211: LD_EXP 110
37215: PPUSH
37216: LD_VAR 0 2
37220: PPUSH
37221: LD_EXP 102
37225: PUSH
37226: LD_VAR 0 2
37230: ARRAY
37231: PPUSH
37232: LD_INT 2
37234: PUSH
37235: LD_INT 30
37237: PUSH
37238: LD_INT 32
37240: PUSH
37241: EMPTY
37242: LIST
37243: LIST
37244: PUSH
37245: LD_INT 30
37247: PUSH
37248: LD_INT 33
37250: PUSH
37251: EMPTY
37252: LIST
37253: LIST
37254: PUSH
37255: EMPTY
37256: LIST
37257: LIST
37258: LIST
37259: PPUSH
37260: CALL_OW 72
37264: PPUSH
37265: CALL_OW 1
37269: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37270: LD_ADDR_EXP 111
37274: PUSH
37275: LD_EXP 111
37279: PPUSH
37280: LD_VAR 0 2
37284: PPUSH
37285: LD_EXP 102
37289: PUSH
37290: LD_VAR 0 2
37294: ARRAY
37295: PPUSH
37296: LD_INT 2
37298: PUSH
37299: LD_INT 30
37301: PUSH
37302: LD_INT 32
37304: PUSH
37305: EMPTY
37306: LIST
37307: LIST
37308: PUSH
37309: LD_INT 30
37311: PUSH
37312: LD_INT 31
37314: PUSH
37315: EMPTY
37316: LIST
37317: LIST
37318: PUSH
37319: EMPTY
37320: LIST
37321: LIST
37322: LIST
37323: PUSH
37324: LD_INT 58
37326: PUSH
37327: EMPTY
37328: LIST
37329: PUSH
37330: EMPTY
37331: LIST
37332: LIST
37333: PPUSH
37334: CALL_OW 72
37338: PPUSH
37339: CALL_OW 1
37343: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37344: LD_ADDR_EXP 112
37348: PUSH
37349: LD_EXP 112
37353: PPUSH
37354: LD_VAR 0 2
37358: PPUSH
37359: EMPTY
37360: PPUSH
37361: CALL_OW 1
37365: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37366: LD_ADDR_EXP 116
37370: PUSH
37371: LD_EXP 116
37375: PPUSH
37376: LD_VAR 0 2
37380: PPUSH
37381: EMPTY
37382: PPUSH
37383: CALL_OW 1
37387: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37388: LD_ADDR_EXP 115
37392: PUSH
37393: LD_EXP 115
37397: PPUSH
37398: LD_VAR 0 2
37402: PPUSH
37403: EMPTY
37404: PPUSH
37405: CALL_OW 1
37409: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37410: LD_ADDR_EXP 117
37414: PUSH
37415: LD_EXP 117
37419: PPUSH
37420: LD_VAR 0 2
37424: PPUSH
37425: EMPTY
37426: PPUSH
37427: CALL_OW 1
37431: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37432: LD_ADDR_EXP 118
37436: PUSH
37437: LD_EXP 118
37441: PPUSH
37442: LD_VAR 0 2
37446: PPUSH
37447: EMPTY
37448: PPUSH
37449: CALL_OW 1
37453: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37454: LD_ADDR_EXP 119
37458: PUSH
37459: LD_EXP 119
37463: PPUSH
37464: LD_VAR 0 2
37468: PPUSH
37469: EMPTY
37470: PPUSH
37471: CALL_OW 1
37475: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37476: LD_ADDR_EXP 120
37480: PUSH
37481: LD_EXP 120
37485: PPUSH
37486: LD_VAR 0 2
37490: PPUSH
37491: EMPTY
37492: PPUSH
37493: CALL_OW 1
37497: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37498: LD_ADDR_EXP 121
37502: PUSH
37503: LD_EXP 121
37507: PPUSH
37508: LD_VAR 0 2
37512: PPUSH
37513: EMPTY
37514: PPUSH
37515: CALL_OW 1
37519: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37520: LD_ADDR_EXP 122
37524: PUSH
37525: LD_EXP 122
37529: PPUSH
37530: LD_VAR 0 2
37534: PPUSH
37535: EMPTY
37536: PPUSH
37537: CALL_OW 1
37541: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37542: LD_ADDR_EXP 123
37546: PUSH
37547: LD_EXP 123
37551: PPUSH
37552: LD_VAR 0 2
37556: PPUSH
37557: EMPTY
37558: PPUSH
37559: CALL_OW 1
37563: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37564: LD_ADDR_EXP 124
37568: PUSH
37569: LD_EXP 124
37573: PPUSH
37574: LD_VAR 0 2
37578: PPUSH
37579: EMPTY
37580: PPUSH
37581: CALL_OW 1
37585: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
37586: LD_ADDR_EXP 113
37590: PUSH
37591: LD_EXP 113
37595: PPUSH
37596: LD_VAR 0 2
37600: PPUSH
37601: LD_INT 0
37603: PPUSH
37604: CALL_OW 1
37608: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
37609: LD_ADDR_EXP 126
37613: PUSH
37614: LD_EXP 126
37618: PPUSH
37619: LD_VAR 0 2
37623: PPUSH
37624: LD_INT 0
37626: PPUSH
37627: CALL_OW 1
37631: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37632: LD_ADDR_EXP 114
37636: PUSH
37637: LD_EXP 114
37641: PPUSH
37642: LD_VAR 0 2
37646: PPUSH
37647: EMPTY
37648: PPUSH
37649: CALL_OW 1
37653: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37654: LD_ADDR_EXP 125
37658: PUSH
37659: LD_EXP 125
37663: PPUSH
37664: LD_VAR 0 2
37668: PPUSH
37669: LD_INT 0
37671: PPUSH
37672: CALL_OW 1
37676: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
37677: LD_ADDR_EXP 127
37681: PUSH
37682: LD_EXP 127
37686: PPUSH
37687: LD_VAR 0 2
37691: PPUSH
37692: EMPTY
37693: PPUSH
37694: CALL_OW 1
37698: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
37699: LD_ADDR_EXP 130
37703: PUSH
37704: LD_EXP 130
37708: PPUSH
37709: LD_VAR 0 2
37713: PPUSH
37714: LD_INT 0
37716: PPUSH
37717: CALL_OW 1
37721: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
37722: LD_ADDR_EXP 131
37726: PUSH
37727: LD_EXP 131
37731: PPUSH
37732: LD_VAR 0 2
37736: PPUSH
37737: EMPTY
37738: PPUSH
37739: CALL_OW 1
37743: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
37744: LD_ADDR_EXP 132
37748: PUSH
37749: LD_EXP 132
37753: PPUSH
37754: LD_VAR 0 2
37758: PPUSH
37759: EMPTY
37760: PPUSH
37761: CALL_OW 1
37765: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37766: LD_ADDR_EXP 133
37770: PUSH
37771: LD_EXP 133
37775: PPUSH
37776: LD_VAR 0 2
37780: PPUSH
37781: EMPTY
37782: PPUSH
37783: CALL_OW 1
37787: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
37788: LD_ADDR_EXP 135
37792: PUSH
37793: LD_EXP 135
37797: PPUSH
37798: LD_VAR 0 2
37802: PPUSH
37803: LD_EXP 102
37807: PUSH
37808: LD_VAR 0 2
37812: ARRAY
37813: PPUSH
37814: LD_INT 2
37816: PUSH
37817: LD_INT 30
37819: PUSH
37820: LD_INT 6
37822: PUSH
37823: EMPTY
37824: LIST
37825: LIST
37826: PUSH
37827: LD_INT 30
37829: PUSH
37830: LD_INT 7
37832: PUSH
37833: EMPTY
37834: LIST
37835: LIST
37836: PUSH
37837: LD_INT 30
37839: PUSH
37840: LD_INT 8
37842: PUSH
37843: EMPTY
37844: LIST
37845: LIST
37846: PUSH
37847: EMPTY
37848: LIST
37849: LIST
37850: LIST
37851: LIST
37852: PPUSH
37853: CALL_OW 72
37857: PPUSH
37858: CALL_OW 1
37862: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
37863: LD_ADDR_EXP 136
37867: PUSH
37868: LD_EXP 136
37872: PPUSH
37873: LD_VAR 0 2
37877: PPUSH
37878: EMPTY
37879: PPUSH
37880: CALL_OW 1
37884: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
37885: LD_ADDR_EXP 137
37889: PUSH
37890: LD_EXP 137
37894: PPUSH
37895: LD_VAR 0 2
37899: PPUSH
37900: EMPTY
37901: PPUSH
37902: CALL_OW 1
37906: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
37907: LD_ADDR_EXP 138
37911: PUSH
37912: LD_EXP 138
37916: PPUSH
37917: LD_VAR 0 2
37921: PPUSH
37922: EMPTY
37923: PPUSH
37924: CALL_OW 1
37928: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
37929: LD_ADDR_EXP 139
37933: PUSH
37934: LD_EXP 139
37938: PPUSH
37939: LD_VAR 0 2
37943: PPUSH
37944: EMPTY
37945: PPUSH
37946: CALL_OW 1
37950: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37951: LD_ADDR_EXP 140
37955: PUSH
37956: LD_EXP 140
37960: PPUSH
37961: LD_VAR 0 2
37965: PPUSH
37966: EMPTY
37967: PPUSH
37968: CALL_OW 1
37972: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
37973: LD_ADDR_EXP 141
37977: PUSH
37978: LD_EXP 141
37982: PPUSH
37983: LD_VAR 0 2
37987: PPUSH
37988: EMPTY
37989: PPUSH
37990: CALL_OW 1
37994: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
37995: LD_ADDR_EXP 142
37999: PUSH
38000: LD_EXP 142
38004: PPUSH
38005: LD_VAR 0 2
38009: PPUSH
38010: EMPTY
38011: PPUSH
38012: CALL_OW 1
38016: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38017: LD_ADDR_EXP 143
38021: PUSH
38022: LD_EXP 143
38026: PPUSH
38027: LD_VAR 0 2
38031: PPUSH
38032: EMPTY
38033: PPUSH
38034: CALL_OW 1
38038: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38039: LD_ADDR_EXP 144
38043: PUSH
38044: LD_EXP 144
38048: PPUSH
38049: LD_VAR 0 2
38053: PPUSH
38054: LD_INT 0
38056: PPUSH
38057: CALL_OW 1
38061: ST_TO_ADDR
// end ;
38062: GO 36986
38064: POP
38065: POP
// MC_InitSides ( ) ;
38066: CALL 38352 0 0
// MC_InitResearch ( ) ;
38070: CALL 38091 0 0
// CustomInitMacro ( ) ;
38074: CALL 467 0 0
// skirmish := true ;
38078: LD_ADDR_EXP 100
38082: PUSH
38083: LD_INT 1
38085: ST_TO_ADDR
// end ;
38086: LD_VAR 0 1
38090: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38091: LD_INT 0
38093: PPUSH
38094: PPUSH
38095: PPUSH
38096: PPUSH
38097: PPUSH
38098: PPUSH
// if not mc_bases then
38099: LD_EXP 102
38103: NOT
38104: IFFALSE 38108
// exit ;
38106: GO 38347
// for i = 1 to 8 do
38108: LD_ADDR_VAR 0 2
38112: PUSH
38113: DOUBLE
38114: LD_INT 1
38116: DEC
38117: ST_TO_ADDR
38118: LD_INT 8
38120: PUSH
38121: FOR_TO
38122: IFFALSE 38148
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38124: LD_ADDR_EXP 129
38128: PUSH
38129: LD_EXP 129
38133: PPUSH
38134: LD_VAR 0 2
38138: PPUSH
38139: EMPTY
38140: PPUSH
38141: CALL_OW 1
38145: ST_TO_ADDR
38146: GO 38121
38148: POP
38149: POP
// tmp := [ ] ;
38150: LD_ADDR_VAR 0 5
38154: PUSH
38155: EMPTY
38156: ST_TO_ADDR
// for i = 1 to mc_sides do
38157: LD_ADDR_VAR 0 2
38161: PUSH
38162: DOUBLE
38163: LD_INT 1
38165: DEC
38166: ST_TO_ADDR
38167: LD_EXP 128
38171: PUSH
38172: FOR_TO
38173: IFFALSE 38231
// if not mc_sides [ i ] in tmp then
38175: LD_EXP 128
38179: PUSH
38180: LD_VAR 0 2
38184: ARRAY
38185: PUSH
38186: LD_VAR 0 5
38190: IN
38191: NOT
38192: IFFALSE 38229
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38194: LD_ADDR_VAR 0 5
38198: PUSH
38199: LD_VAR 0 5
38203: PPUSH
38204: LD_VAR 0 5
38208: PUSH
38209: LD_INT 1
38211: PLUS
38212: PPUSH
38213: LD_EXP 128
38217: PUSH
38218: LD_VAR 0 2
38222: ARRAY
38223: PPUSH
38224: CALL_OW 2
38228: ST_TO_ADDR
38229: GO 38172
38231: POP
38232: POP
// if not tmp then
38233: LD_VAR 0 5
38237: NOT
38238: IFFALSE 38242
// exit ;
38240: GO 38347
// for j in tmp do
38242: LD_ADDR_VAR 0 3
38246: PUSH
38247: LD_VAR 0 5
38251: PUSH
38252: FOR_IN
38253: IFFALSE 38345
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38255: LD_ADDR_VAR 0 6
38259: PUSH
38260: LD_INT 22
38262: PUSH
38263: LD_VAR 0 3
38267: PUSH
38268: EMPTY
38269: LIST
38270: LIST
38271: PPUSH
38272: CALL_OW 69
38276: ST_TO_ADDR
// if not un then
38277: LD_VAR 0 6
38281: NOT
38282: IFFALSE 38286
// continue ;
38284: GO 38252
// nation := GetNation ( un [ 1 ] ) ;
38286: LD_ADDR_VAR 0 4
38290: PUSH
38291: LD_VAR 0 6
38295: PUSH
38296: LD_INT 1
38298: ARRAY
38299: PPUSH
38300: CALL_OW 248
38304: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38305: LD_ADDR_EXP 129
38309: PUSH
38310: LD_EXP 129
38314: PPUSH
38315: LD_VAR 0 3
38319: PPUSH
38320: LD_VAR 0 3
38324: PPUSH
38325: LD_VAR 0 4
38329: PPUSH
38330: LD_INT 1
38332: PPUSH
38333: CALL 64957 0 3
38337: PPUSH
38338: CALL_OW 1
38342: ST_TO_ADDR
// end ;
38343: GO 38252
38345: POP
38346: POP
// end ;
38347: LD_VAR 0 1
38351: RET
// export function MC_InitSides ( ) ; var i ; begin
38352: LD_INT 0
38354: PPUSH
38355: PPUSH
// if not mc_bases then
38356: LD_EXP 102
38360: NOT
38361: IFFALSE 38365
// exit ;
38363: GO 38439
// for i = 1 to mc_bases do
38365: LD_ADDR_VAR 0 2
38369: PUSH
38370: DOUBLE
38371: LD_INT 1
38373: DEC
38374: ST_TO_ADDR
38375: LD_EXP 102
38379: PUSH
38380: FOR_TO
38381: IFFALSE 38437
// if mc_bases [ i ] then
38383: LD_EXP 102
38387: PUSH
38388: LD_VAR 0 2
38392: ARRAY
38393: IFFALSE 38435
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38395: LD_ADDR_EXP 128
38399: PUSH
38400: LD_EXP 128
38404: PPUSH
38405: LD_VAR 0 2
38409: PPUSH
38410: LD_EXP 102
38414: PUSH
38415: LD_VAR 0 2
38419: ARRAY
38420: PUSH
38421: LD_INT 1
38423: ARRAY
38424: PPUSH
38425: CALL_OW 255
38429: PPUSH
38430: CALL_OW 1
38434: ST_TO_ADDR
38435: GO 38380
38437: POP
38438: POP
// end ;
38439: LD_VAR 0 1
38443: RET
// every 0 0$01 trigger skirmish do
38444: LD_EXP 100
38448: IFFALSE 38602
38450: GO 38452
38452: DISABLE
// begin enable ;
38453: ENABLE
// MC_CheckBuildings ( ) ;
38454: CALL 43100 0 0
// MC_CheckPeopleLife ( ) ;
38458: CALL 43225 0 0
// RaiseSailEvent ( 100 ) ;
38462: LD_INT 100
38464: PPUSH
38465: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38469: LD_INT 103
38471: PPUSH
38472: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38476: LD_INT 104
38478: PPUSH
38479: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38483: LD_INT 105
38485: PPUSH
38486: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38490: LD_INT 106
38492: PPUSH
38493: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38497: LD_INT 107
38499: PPUSH
38500: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38504: LD_INT 108
38506: PPUSH
38507: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38511: LD_INT 109
38513: PPUSH
38514: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38518: LD_INT 110
38520: PPUSH
38521: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38525: LD_INT 111
38527: PPUSH
38528: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
38532: LD_INT 112
38534: PPUSH
38535: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
38539: LD_INT 113
38541: PPUSH
38542: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
38546: LD_INT 120
38548: PPUSH
38549: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
38553: LD_INT 121
38555: PPUSH
38556: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
38560: LD_INT 122
38562: PPUSH
38563: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
38567: LD_INT 123
38569: PPUSH
38570: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
38574: LD_INT 124
38576: PPUSH
38577: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
38581: LD_INT 125
38583: PPUSH
38584: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
38588: LD_INT 126
38590: PPUSH
38591: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
38595: LD_INT 200
38597: PPUSH
38598: CALL_OW 427
// end ;
38602: END
// on SailEvent ( event ) do begin if event < 100 then
38603: LD_VAR 0 1
38607: PUSH
38608: LD_INT 100
38610: LESS
38611: IFFALSE 38622
// CustomEvent ( event ) ;
38613: LD_VAR 0 1
38617: PPUSH
38618: CALL 33262 0 1
// if event = 100 then
38622: LD_VAR 0 1
38626: PUSH
38627: LD_INT 100
38629: EQUAL
38630: IFFALSE 38636
// MC_ClassManager ( ) ;
38632: CALL 39028 0 0
// if event = 101 then
38636: LD_VAR 0 1
38640: PUSH
38641: LD_INT 101
38643: EQUAL
38644: IFFALSE 38650
// MC_RepairBuildings ( ) ;
38646: CALL 43821 0 0
// if event = 102 then
38650: LD_VAR 0 1
38654: PUSH
38655: LD_INT 102
38657: EQUAL
38658: IFFALSE 38664
// MC_Heal ( ) ;
38660: CALL 44685 0 0
// if event = 103 then
38664: LD_VAR 0 1
38668: PUSH
38669: LD_INT 103
38671: EQUAL
38672: IFFALSE 38678
// MC_Build ( ) ;
38674: CALL 45107 0 0
// if event = 104 then
38678: LD_VAR 0 1
38682: PUSH
38683: LD_INT 104
38685: EQUAL
38686: IFFALSE 38692
// MC_TurretWeapon ( ) ;
38688: CALL 46720 0 0
// if event = 105 then
38692: LD_VAR 0 1
38696: PUSH
38697: LD_INT 105
38699: EQUAL
38700: IFFALSE 38706
// MC_BuildUpgrade ( ) ;
38702: CALL 46271 0 0
// if event = 106 then
38706: LD_VAR 0 1
38710: PUSH
38711: LD_INT 106
38713: EQUAL
38714: IFFALSE 38720
// MC_PlantMines ( ) ;
38716: CALL 47150 0 0
// if event = 107 then
38720: LD_VAR 0 1
38724: PUSH
38725: LD_INT 107
38727: EQUAL
38728: IFFALSE 38734
// MC_CollectCrates ( ) ;
38730: CALL 47948 0 0
// if event = 108 then
38734: LD_VAR 0 1
38738: PUSH
38739: LD_INT 108
38741: EQUAL
38742: IFFALSE 38748
// MC_LinkRemoteControl ( ) ;
38744: CALL 49724 0 0
// if event = 109 then
38748: LD_VAR 0 1
38752: PUSH
38753: LD_INT 109
38755: EQUAL
38756: IFFALSE 38762
// MC_ProduceVehicle ( ) ;
38758: CALL 49905 0 0
// if event = 110 then
38762: LD_VAR 0 1
38766: PUSH
38767: LD_INT 110
38769: EQUAL
38770: IFFALSE 38776
// MC_SendAttack ( ) ;
38772: CALL 50371 0 0
// if event = 111 then
38776: LD_VAR 0 1
38780: PUSH
38781: LD_INT 111
38783: EQUAL
38784: IFFALSE 38790
// MC_Defend ( ) ;
38786: CALL 50479 0 0
// if event = 112 then
38790: LD_VAR 0 1
38794: PUSH
38795: LD_INT 112
38797: EQUAL
38798: IFFALSE 38804
// MC_Research ( ) ;
38800: CALL 51084 0 0
// if event = 113 then
38804: LD_VAR 0 1
38808: PUSH
38809: LD_INT 113
38811: EQUAL
38812: IFFALSE 38818
// MC_MinesTrigger ( ) ;
38814: CALL 52198 0 0
// if event = 120 then
38818: LD_VAR 0 1
38822: PUSH
38823: LD_INT 120
38825: EQUAL
38826: IFFALSE 38832
// MC_RepairVehicle ( ) ;
38828: CALL 52297 0 0
// if event = 121 then
38832: LD_VAR 0 1
38836: PUSH
38837: LD_INT 121
38839: EQUAL
38840: IFFALSE 38846
// MC_TameApe ( ) ;
38842: CALL 53027 0 0
// if event = 122 then
38846: LD_VAR 0 1
38850: PUSH
38851: LD_INT 122
38853: EQUAL
38854: IFFALSE 38860
// MC_ChangeApeClass ( ) ;
38856: CALL 53856 0 0
// if event = 123 then
38860: LD_VAR 0 1
38864: PUSH
38865: LD_INT 123
38867: EQUAL
38868: IFFALSE 38874
// MC_Bazooka ( ) ;
38870: CALL 54506 0 0
// if event = 124 then
38874: LD_VAR 0 1
38878: PUSH
38879: LD_INT 124
38881: EQUAL
38882: IFFALSE 38888
// MC_TeleportExit ( ) ;
38884: CALL 54704 0 0
// if event = 125 then
38888: LD_VAR 0 1
38892: PUSH
38893: LD_INT 125
38895: EQUAL
38896: IFFALSE 38902
// MC_Deposits ( ) ;
38898: CALL 55351 0 0
// if event = 126 then
38902: LD_VAR 0 1
38906: PUSH
38907: LD_INT 126
38909: EQUAL
38910: IFFALSE 38916
// MC_RemoteDriver ( ) ;
38912: CALL 55976 0 0
// if event = 200 then
38916: LD_VAR 0 1
38920: PUSH
38921: LD_INT 200
38923: EQUAL
38924: IFFALSE 38930
// MC_Idle ( ) ;
38926: CALL 57925 0 0
// end ;
38930: PPOPN 1
38932: END
// export function MC_Reset ( base , tag ) ; var i ; begin
38933: LD_INT 0
38935: PPUSH
38936: PPUSH
// if not mc_bases [ base ] or not tag then
38937: LD_EXP 102
38941: PUSH
38942: LD_VAR 0 1
38946: ARRAY
38947: NOT
38948: PUSH
38949: LD_VAR 0 2
38953: NOT
38954: OR
38955: IFFALSE 38959
// exit ;
38957: GO 39023
// for i in mc_bases [ base ] union mc_ape [ base ] do
38959: LD_ADDR_VAR 0 4
38963: PUSH
38964: LD_EXP 102
38968: PUSH
38969: LD_VAR 0 1
38973: ARRAY
38974: PUSH
38975: LD_EXP 131
38979: PUSH
38980: LD_VAR 0 1
38984: ARRAY
38985: UNION
38986: PUSH
38987: FOR_IN
38988: IFFALSE 39021
// if GetTag ( i ) = tag then
38990: LD_VAR 0 4
38994: PPUSH
38995: CALL_OW 110
38999: PUSH
39000: LD_VAR 0 2
39004: EQUAL
39005: IFFALSE 39019
// SetTag ( i , 0 ) ;
39007: LD_VAR 0 4
39011: PPUSH
39012: LD_INT 0
39014: PPUSH
39015: CALL_OW 109
39019: GO 38987
39021: POP
39022: POP
// end ;
39023: LD_VAR 0 3
39027: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39028: LD_INT 0
39030: PPUSH
39031: PPUSH
39032: PPUSH
39033: PPUSH
39034: PPUSH
39035: PPUSH
39036: PPUSH
39037: PPUSH
// if not mc_bases then
39038: LD_EXP 102
39042: NOT
39043: IFFALSE 39047
// exit ;
39045: GO 39505
// for i = 1 to mc_bases do
39047: LD_ADDR_VAR 0 2
39051: PUSH
39052: DOUBLE
39053: LD_INT 1
39055: DEC
39056: ST_TO_ADDR
39057: LD_EXP 102
39061: PUSH
39062: FOR_TO
39063: IFFALSE 39503
// begin tmp := MC_ClassCheckReq ( i ) ;
39065: LD_ADDR_VAR 0 4
39069: PUSH
39070: LD_VAR 0 2
39074: PPUSH
39075: CALL 39510 0 1
39079: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39080: LD_ADDR_EXP 143
39084: PUSH
39085: LD_EXP 143
39089: PPUSH
39090: LD_VAR 0 2
39094: PPUSH
39095: LD_VAR 0 4
39099: PPUSH
39100: CALL_OW 1
39104: ST_TO_ADDR
// if not tmp then
39105: LD_VAR 0 4
39109: NOT
39110: IFFALSE 39114
// continue ;
39112: GO 39062
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39114: LD_ADDR_VAR 0 6
39118: PUSH
39119: LD_EXP 102
39123: PUSH
39124: LD_VAR 0 2
39128: ARRAY
39129: PPUSH
39130: LD_INT 2
39132: PUSH
39133: LD_INT 30
39135: PUSH
39136: LD_INT 4
39138: PUSH
39139: EMPTY
39140: LIST
39141: LIST
39142: PUSH
39143: LD_INT 30
39145: PUSH
39146: LD_INT 5
39148: PUSH
39149: EMPTY
39150: LIST
39151: LIST
39152: PUSH
39153: EMPTY
39154: LIST
39155: LIST
39156: LIST
39157: PPUSH
39158: CALL_OW 72
39162: PUSH
39163: LD_EXP 102
39167: PUSH
39168: LD_VAR 0 2
39172: ARRAY
39173: PPUSH
39174: LD_INT 2
39176: PUSH
39177: LD_INT 30
39179: PUSH
39180: LD_INT 0
39182: PUSH
39183: EMPTY
39184: LIST
39185: LIST
39186: PUSH
39187: LD_INT 30
39189: PUSH
39190: LD_INT 1
39192: PUSH
39193: EMPTY
39194: LIST
39195: LIST
39196: PUSH
39197: EMPTY
39198: LIST
39199: LIST
39200: LIST
39201: PPUSH
39202: CALL_OW 72
39206: PUSH
39207: LD_EXP 102
39211: PUSH
39212: LD_VAR 0 2
39216: ARRAY
39217: PPUSH
39218: LD_INT 30
39220: PUSH
39221: LD_INT 3
39223: PUSH
39224: EMPTY
39225: LIST
39226: LIST
39227: PPUSH
39228: CALL_OW 72
39232: PUSH
39233: LD_EXP 102
39237: PUSH
39238: LD_VAR 0 2
39242: ARRAY
39243: PPUSH
39244: LD_INT 2
39246: PUSH
39247: LD_INT 30
39249: PUSH
39250: LD_INT 6
39252: PUSH
39253: EMPTY
39254: LIST
39255: LIST
39256: PUSH
39257: LD_INT 30
39259: PUSH
39260: LD_INT 7
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: PUSH
39267: LD_INT 30
39269: PUSH
39270: LD_INT 8
39272: PUSH
39273: EMPTY
39274: LIST
39275: LIST
39276: PUSH
39277: EMPTY
39278: LIST
39279: LIST
39280: LIST
39281: LIST
39282: PPUSH
39283: CALL_OW 72
39287: PUSH
39288: EMPTY
39289: LIST
39290: LIST
39291: LIST
39292: LIST
39293: ST_TO_ADDR
// for j = 1 to 4 do
39294: LD_ADDR_VAR 0 3
39298: PUSH
39299: DOUBLE
39300: LD_INT 1
39302: DEC
39303: ST_TO_ADDR
39304: LD_INT 4
39306: PUSH
39307: FOR_TO
39308: IFFALSE 39499
// begin if not tmp [ j ] then
39310: LD_VAR 0 4
39314: PUSH
39315: LD_VAR 0 3
39319: ARRAY
39320: NOT
39321: IFFALSE 39325
// continue ;
39323: GO 39307
// for p in tmp [ j ] do
39325: LD_ADDR_VAR 0 5
39329: PUSH
39330: LD_VAR 0 4
39334: PUSH
39335: LD_VAR 0 3
39339: ARRAY
39340: PUSH
39341: FOR_IN
39342: IFFALSE 39495
// begin if not b [ j ] then
39344: LD_VAR 0 6
39348: PUSH
39349: LD_VAR 0 3
39353: ARRAY
39354: NOT
39355: IFFALSE 39359
// break ;
39357: GO 39495
// e := 0 ;
39359: LD_ADDR_VAR 0 7
39363: PUSH
39364: LD_INT 0
39366: ST_TO_ADDR
// for k in b [ j ] do
39367: LD_ADDR_VAR 0 8
39371: PUSH
39372: LD_VAR 0 6
39376: PUSH
39377: LD_VAR 0 3
39381: ARRAY
39382: PUSH
39383: FOR_IN
39384: IFFALSE 39411
// if IsNotFull ( k ) then
39386: LD_VAR 0 8
39390: PPUSH
39391: CALL 69397 0 1
39395: IFFALSE 39409
// begin e := k ;
39397: LD_ADDR_VAR 0 7
39401: PUSH
39402: LD_VAR 0 8
39406: ST_TO_ADDR
// break ;
39407: GO 39411
// end ;
39409: GO 39383
39411: POP
39412: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39413: LD_VAR 0 7
39417: PUSH
39418: LD_VAR 0 5
39422: PPUSH
39423: LD_VAR 0 7
39427: PPUSH
39428: CALL 106526 0 2
39432: NOT
39433: AND
39434: IFFALSE 39493
// begin if IsInUnit ( p ) then
39436: LD_VAR 0 5
39440: PPUSH
39441: CALL_OW 310
39445: IFFALSE 39456
// ComExitBuilding ( p ) ;
39447: LD_VAR 0 5
39451: PPUSH
39452: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39456: LD_VAR 0 5
39460: PPUSH
39461: LD_VAR 0 7
39465: PPUSH
39466: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39470: LD_VAR 0 5
39474: PPUSH
39475: LD_VAR 0 3
39479: PPUSH
39480: CALL_OW 183
// AddComExitBuilding ( p ) ;
39484: LD_VAR 0 5
39488: PPUSH
39489: CALL_OW 182
// end ; end ;
39493: GO 39341
39495: POP
39496: POP
// end ;
39497: GO 39307
39499: POP
39500: POP
// end ;
39501: GO 39062
39503: POP
39504: POP
// end ;
39505: LD_VAR 0 1
39509: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39510: LD_INT 0
39512: PPUSH
39513: PPUSH
39514: PPUSH
39515: PPUSH
39516: PPUSH
39517: PPUSH
39518: PPUSH
39519: PPUSH
39520: PPUSH
39521: PPUSH
39522: PPUSH
39523: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39524: LD_VAR 0 1
39528: NOT
39529: PUSH
39530: LD_EXP 102
39534: PUSH
39535: LD_VAR 0 1
39539: ARRAY
39540: NOT
39541: OR
39542: PUSH
39543: LD_EXP 102
39547: PUSH
39548: LD_VAR 0 1
39552: ARRAY
39553: PPUSH
39554: LD_INT 2
39556: PUSH
39557: LD_INT 30
39559: PUSH
39560: LD_INT 0
39562: PUSH
39563: EMPTY
39564: LIST
39565: LIST
39566: PUSH
39567: LD_INT 30
39569: PUSH
39570: LD_INT 1
39572: PUSH
39573: EMPTY
39574: LIST
39575: LIST
39576: PUSH
39577: EMPTY
39578: LIST
39579: LIST
39580: LIST
39581: PPUSH
39582: CALL_OW 72
39586: NOT
39587: OR
39588: IFFALSE 39592
// exit ;
39590: GO 43095
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39592: LD_ADDR_VAR 0 4
39596: PUSH
39597: LD_EXP 102
39601: PUSH
39602: LD_VAR 0 1
39606: ARRAY
39607: PPUSH
39608: LD_INT 2
39610: PUSH
39611: LD_INT 25
39613: PUSH
39614: LD_INT 1
39616: PUSH
39617: EMPTY
39618: LIST
39619: LIST
39620: PUSH
39621: LD_INT 25
39623: PUSH
39624: LD_INT 2
39626: PUSH
39627: EMPTY
39628: LIST
39629: LIST
39630: PUSH
39631: LD_INT 25
39633: PUSH
39634: LD_INT 3
39636: PUSH
39637: EMPTY
39638: LIST
39639: LIST
39640: PUSH
39641: LD_INT 25
39643: PUSH
39644: LD_INT 4
39646: PUSH
39647: EMPTY
39648: LIST
39649: LIST
39650: PUSH
39651: LD_INT 25
39653: PUSH
39654: LD_INT 5
39656: PUSH
39657: EMPTY
39658: LIST
39659: LIST
39660: PUSH
39661: LD_INT 25
39663: PUSH
39664: LD_INT 8
39666: PUSH
39667: EMPTY
39668: LIST
39669: LIST
39670: PUSH
39671: LD_INT 25
39673: PUSH
39674: LD_INT 9
39676: PUSH
39677: EMPTY
39678: LIST
39679: LIST
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: LIST
39685: LIST
39686: LIST
39687: LIST
39688: LIST
39689: LIST
39690: PPUSH
39691: CALL_OW 72
39695: ST_TO_ADDR
// if not tmp then
39696: LD_VAR 0 4
39700: NOT
39701: IFFALSE 39705
// exit ;
39703: GO 43095
// for i in tmp do
39705: LD_ADDR_VAR 0 3
39709: PUSH
39710: LD_VAR 0 4
39714: PUSH
39715: FOR_IN
39716: IFFALSE 39747
// if GetTag ( i ) then
39718: LD_VAR 0 3
39722: PPUSH
39723: CALL_OW 110
39727: IFFALSE 39745
// tmp := tmp diff i ;
39729: LD_ADDR_VAR 0 4
39733: PUSH
39734: LD_VAR 0 4
39738: PUSH
39739: LD_VAR 0 3
39743: DIFF
39744: ST_TO_ADDR
39745: GO 39715
39747: POP
39748: POP
// if not tmp then
39749: LD_VAR 0 4
39753: NOT
39754: IFFALSE 39758
// exit ;
39756: GO 43095
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39758: LD_ADDR_VAR 0 5
39762: PUSH
39763: LD_EXP 102
39767: PUSH
39768: LD_VAR 0 1
39772: ARRAY
39773: PPUSH
39774: LD_INT 2
39776: PUSH
39777: LD_INT 25
39779: PUSH
39780: LD_INT 1
39782: PUSH
39783: EMPTY
39784: LIST
39785: LIST
39786: PUSH
39787: LD_INT 25
39789: PUSH
39790: LD_INT 5
39792: PUSH
39793: EMPTY
39794: LIST
39795: LIST
39796: PUSH
39797: LD_INT 25
39799: PUSH
39800: LD_INT 8
39802: PUSH
39803: EMPTY
39804: LIST
39805: LIST
39806: PUSH
39807: LD_INT 25
39809: PUSH
39810: LD_INT 9
39812: PUSH
39813: EMPTY
39814: LIST
39815: LIST
39816: PUSH
39817: EMPTY
39818: LIST
39819: LIST
39820: LIST
39821: LIST
39822: LIST
39823: PPUSH
39824: CALL_OW 72
39828: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
39829: LD_ADDR_VAR 0 6
39833: PUSH
39834: LD_EXP 102
39838: PUSH
39839: LD_VAR 0 1
39843: ARRAY
39844: PPUSH
39845: LD_INT 25
39847: PUSH
39848: LD_INT 2
39850: PUSH
39851: EMPTY
39852: LIST
39853: LIST
39854: PPUSH
39855: CALL_OW 72
39859: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
39860: LD_ADDR_VAR 0 7
39864: PUSH
39865: LD_EXP 102
39869: PUSH
39870: LD_VAR 0 1
39874: ARRAY
39875: PPUSH
39876: LD_INT 25
39878: PUSH
39879: LD_INT 3
39881: PUSH
39882: EMPTY
39883: LIST
39884: LIST
39885: PPUSH
39886: CALL_OW 72
39890: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
39891: LD_ADDR_VAR 0 8
39895: PUSH
39896: LD_EXP 102
39900: PUSH
39901: LD_VAR 0 1
39905: ARRAY
39906: PPUSH
39907: LD_INT 25
39909: PUSH
39910: LD_INT 4
39912: PUSH
39913: EMPTY
39914: LIST
39915: LIST
39916: PUSH
39917: LD_INT 24
39919: PUSH
39920: LD_INT 251
39922: PUSH
39923: EMPTY
39924: LIST
39925: LIST
39926: PUSH
39927: EMPTY
39928: LIST
39929: LIST
39930: PPUSH
39931: CALL_OW 72
39935: ST_TO_ADDR
// if mc_scan [ base ] then
39936: LD_EXP 125
39940: PUSH
39941: LD_VAR 0 1
39945: ARRAY
39946: IFFALSE 40407
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
39948: LD_ADDR_EXP 144
39952: PUSH
39953: LD_EXP 144
39957: PPUSH
39958: LD_VAR 0 1
39962: PPUSH
39963: LD_INT 4
39965: PPUSH
39966: CALL_OW 1
39970: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39971: LD_ADDR_VAR 0 12
39975: PUSH
39976: LD_EXP 102
39980: PUSH
39981: LD_VAR 0 1
39985: ARRAY
39986: PPUSH
39987: LD_INT 2
39989: PUSH
39990: LD_INT 30
39992: PUSH
39993: LD_INT 4
39995: PUSH
39996: EMPTY
39997: LIST
39998: LIST
39999: PUSH
40000: LD_INT 30
40002: PUSH
40003: LD_INT 5
40005: PUSH
40006: EMPTY
40007: LIST
40008: LIST
40009: PUSH
40010: EMPTY
40011: LIST
40012: LIST
40013: LIST
40014: PPUSH
40015: CALL_OW 72
40019: ST_TO_ADDR
// if not b then
40020: LD_VAR 0 12
40024: NOT
40025: IFFALSE 40029
// exit ;
40027: GO 43095
// p := [ ] ;
40029: LD_ADDR_VAR 0 11
40033: PUSH
40034: EMPTY
40035: ST_TO_ADDR
// if sci >= 2 then
40036: LD_VAR 0 8
40040: PUSH
40041: LD_INT 2
40043: GREATEREQUAL
40044: IFFALSE 40075
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40046: LD_ADDR_VAR 0 8
40050: PUSH
40051: LD_VAR 0 8
40055: PUSH
40056: LD_INT 1
40058: ARRAY
40059: PUSH
40060: LD_VAR 0 8
40064: PUSH
40065: LD_INT 2
40067: ARRAY
40068: PUSH
40069: EMPTY
40070: LIST
40071: LIST
40072: ST_TO_ADDR
40073: GO 40136
// if sci = 1 then
40075: LD_VAR 0 8
40079: PUSH
40080: LD_INT 1
40082: EQUAL
40083: IFFALSE 40104
// sci := [ sci [ 1 ] ] else
40085: LD_ADDR_VAR 0 8
40089: PUSH
40090: LD_VAR 0 8
40094: PUSH
40095: LD_INT 1
40097: ARRAY
40098: PUSH
40099: EMPTY
40100: LIST
40101: ST_TO_ADDR
40102: GO 40136
// if sci = 0 then
40104: LD_VAR 0 8
40108: PUSH
40109: LD_INT 0
40111: EQUAL
40112: IFFALSE 40136
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40114: LD_ADDR_VAR 0 11
40118: PUSH
40119: LD_VAR 0 4
40123: PPUSH
40124: LD_INT 4
40126: PPUSH
40127: CALL 106389 0 2
40131: PUSH
40132: LD_INT 1
40134: ARRAY
40135: ST_TO_ADDR
// if eng > 4 then
40136: LD_VAR 0 6
40140: PUSH
40141: LD_INT 4
40143: GREATER
40144: IFFALSE 40190
// for i = eng downto 4 do
40146: LD_ADDR_VAR 0 3
40150: PUSH
40151: DOUBLE
40152: LD_VAR 0 6
40156: INC
40157: ST_TO_ADDR
40158: LD_INT 4
40160: PUSH
40161: FOR_DOWNTO
40162: IFFALSE 40188
// eng := eng diff eng [ i ] ;
40164: LD_ADDR_VAR 0 6
40168: PUSH
40169: LD_VAR 0 6
40173: PUSH
40174: LD_VAR 0 6
40178: PUSH
40179: LD_VAR 0 3
40183: ARRAY
40184: DIFF
40185: ST_TO_ADDR
40186: GO 40161
40188: POP
40189: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40190: LD_ADDR_VAR 0 4
40194: PUSH
40195: LD_VAR 0 4
40199: PUSH
40200: LD_VAR 0 5
40204: PUSH
40205: LD_VAR 0 6
40209: UNION
40210: PUSH
40211: LD_VAR 0 7
40215: UNION
40216: PUSH
40217: LD_VAR 0 8
40221: UNION
40222: DIFF
40223: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40224: LD_ADDR_VAR 0 13
40228: PUSH
40229: LD_EXP 102
40233: PUSH
40234: LD_VAR 0 1
40238: ARRAY
40239: PPUSH
40240: LD_INT 2
40242: PUSH
40243: LD_INT 30
40245: PUSH
40246: LD_INT 32
40248: PUSH
40249: EMPTY
40250: LIST
40251: LIST
40252: PUSH
40253: LD_INT 30
40255: PUSH
40256: LD_INT 31
40258: PUSH
40259: EMPTY
40260: LIST
40261: LIST
40262: PUSH
40263: EMPTY
40264: LIST
40265: LIST
40266: LIST
40267: PPUSH
40268: CALL_OW 72
40272: PUSH
40273: LD_EXP 102
40277: PUSH
40278: LD_VAR 0 1
40282: ARRAY
40283: PPUSH
40284: LD_INT 2
40286: PUSH
40287: LD_INT 30
40289: PUSH
40290: LD_INT 4
40292: PUSH
40293: EMPTY
40294: LIST
40295: LIST
40296: PUSH
40297: LD_INT 30
40299: PUSH
40300: LD_INT 5
40302: PUSH
40303: EMPTY
40304: LIST
40305: LIST
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: LIST
40311: PPUSH
40312: CALL_OW 72
40316: PUSH
40317: LD_INT 6
40319: MUL
40320: PLUS
40321: ST_TO_ADDR
// if bcount < tmp then
40322: LD_VAR 0 13
40326: PUSH
40327: LD_VAR 0 4
40331: LESS
40332: IFFALSE 40378
// for i = tmp downto bcount do
40334: LD_ADDR_VAR 0 3
40338: PUSH
40339: DOUBLE
40340: LD_VAR 0 4
40344: INC
40345: ST_TO_ADDR
40346: LD_VAR 0 13
40350: PUSH
40351: FOR_DOWNTO
40352: IFFALSE 40376
// tmp := Delete ( tmp , tmp ) ;
40354: LD_ADDR_VAR 0 4
40358: PUSH
40359: LD_VAR 0 4
40363: PPUSH
40364: LD_VAR 0 4
40368: PPUSH
40369: CALL_OW 3
40373: ST_TO_ADDR
40374: GO 40351
40376: POP
40377: POP
// result := [ tmp , 0 , 0 , p ] ;
40378: LD_ADDR_VAR 0 2
40382: PUSH
40383: LD_VAR 0 4
40387: PUSH
40388: LD_INT 0
40390: PUSH
40391: LD_INT 0
40393: PUSH
40394: LD_VAR 0 11
40398: PUSH
40399: EMPTY
40400: LIST
40401: LIST
40402: LIST
40403: LIST
40404: ST_TO_ADDR
// exit ;
40405: GO 43095
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40407: LD_EXP 102
40411: PUSH
40412: LD_VAR 0 1
40416: ARRAY
40417: PPUSH
40418: LD_INT 2
40420: PUSH
40421: LD_INT 30
40423: PUSH
40424: LD_INT 6
40426: PUSH
40427: EMPTY
40428: LIST
40429: LIST
40430: PUSH
40431: LD_INT 30
40433: PUSH
40434: LD_INT 7
40436: PUSH
40437: EMPTY
40438: LIST
40439: LIST
40440: PUSH
40441: LD_INT 30
40443: PUSH
40444: LD_INT 8
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: PUSH
40451: EMPTY
40452: LIST
40453: LIST
40454: LIST
40455: LIST
40456: PPUSH
40457: CALL_OW 72
40461: NOT
40462: PUSH
40463: LD_EXP 102
40467: PUSH
40468: LD_VAR 0 1
40472: ARRAY
40473: PPUSH
40474: LD_INT 30
40476: PUSH
40477: LD_INT 3
40479: PUSH
40480: EMPTY
40481: LIST
40482: LIST
40483: PPUSH
40484: CALL_OW 72
40488: NOT
40489: AND
40490: IFFALSE 40562
// begin if eng = tmp then
40492: LD_VAR 0 6
40496: PUSH
40497: LD_VAR 0 4
40501: EQUAL
40502: IFFALSE 40506
// exit ;
40504: GO 43095
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40506: LD_ADDR_EXP 144
40510: PUSH
40511: LD_EXP 144
40515: PPUSH
40516: LD_VAR 0 1
40520: PPUSH
40521: LD_INT 1
40523: PPUSH
40524: CALL_OW 1
40528: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
40529: LD_ADDR_VAR 0 2
40533: PUSH
40534: LD_INT 0
40536: PUSH
40537: LD_VAR 0 4
40541: PUSH
40542: LD_VAR 0 6
40546: DIFF
40547: PUSH
40548: LD_INT 0
40550: PUSH
40551: LD_INT 0
40553: PUSH
40554: EMPTY
40555: LIST
40556: LIST
40557: LIST
40558: LIST
40559: ST_TO_ADDR
// exit ;
40560: GO 43095
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40562: LD_EXP 129
40566: PUSH
40567: LD_EXP 128
40571: PUSH
40572: LD_VAR 0 1
40576: ARRAY
40577: ARRAY
40578: PUSH
40579: LD_EXP 102
40583: PUSH
40584: LD_VAR 0 1
40588: ARRAY
40589: PPUSH
40590: LD_INT 2
40592: PUSH
40593: LD_INT 30
40595: PUSH
40596: LD_INT 6
40598: PUSH
40599: EMPTY
40600: LIST
40601: LIST
40602: PUSH
40603: LD_INT 30
40605: PUSH
40606: LD_INT 7
40608: PUSH
40609: EMPTY
40610: LIST
40611: LIST
40612: PUSH
40613: LD_INT 30
40615: PUSH
40616: LD_INT 8
40618: PUSH
40619: EMPTY
40620: LIST
40621: LIST
40622: PUSH
40623: EMPTY
40624: LIST
40625: LIST
40626: LIST
40627: LIST
40628: PPUSH
40629: CALL_OW 72
40633: AND
40634: PUSH
40635: LD_EXP 102
40639: PUSH
40640: LD_VAR 0 1
40644: ARRAY
40645: PPUSH
40646: LD_INT 30
40648: PUSH
40649: LD_INT 3
40651: PUSH
40652: EMPTY
40653: LIST
40654: LIST
40655: PPUSH
40656: CALL_OW 72
40660: NOT
40661: AND
40662: IFFALSE 40876
// begin if sci >= 6 then
40664: LD_VAR 0 8
40668: PUSH
40669: LD_INT 6
40671: GREATEREQUAL
40672: IFFALSE 40676
// exit ;
40674: GO 43095
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
40676: LD_ADDR_EXP 144
40680: PUSH
40681: LD_EXP 144
40685: PPUSH
40686: LD_VAR 0 1
40690: PPUSH
40691: LD_INT 2
40693: PPUSH
40694: CALL_OW 1
40698: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
40699: LD_ADDR_VAR 0 9
40703: PUSH
40704: LD_VAR 0 4
40708: PUSH
40709: LD_VAR 0 8
40713: DIFF
40714: PPUSH
40715: LD_INT 4
40717: PPUSH
40718: CALL 106389 0 2
40722: ST_TO_ADDR
// p := [ ] ;
40723: LD_ADDR_VAR 0 11
40727: PUSH
40728: EMPTY
40729: ST_TO_ADDR
// if sci < 6 and sort > 6 then
40730: LD_VAR 0 8
40734: PUSH
40735: LD_INT 6
40737: LESS
40738: PUSH
40739: LD_VAR 0 9
40743: PUSH
40744: LD_INT 6
40746: GREATER
40747: AND
40748: IFFALSE 40829
// begin for i = 1 to 6 - sci do
40750: LD_ADDR_VAR 0 3
40754: PUSH
40755: DOUBLE
40756: LD_INT 1
40758: DEC
40759: ST_TO_ADDR
40760: LD_INT 6
40762: PUSH
40763: LD_VAR 0 8
40767: MINUS
40768: PUSH
40769: FOR_TO
40770: IFFALSE 40825
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
40772: LD_ADDR_VAR 0 11
40776: PUSH
40777: LD_VAR 0 11
40781: PPUSH
40782: LD_VAR 0 11
40786: PUSH
40787: LD_INT 1
40789: PLUS
40790: PPUSH
40791: LD_VAR 0 9
40795: PUSH
40796: LD_INT 1
40798: ARRAY
40799: PPUSH
40800: CALL_OW 2
40804: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
40805: LD_ADDR_VAR 0 9
40809: PUSH
40810: LD_VAR 0 9
40814: PPUSH
40815: LD_INT 1
40817: PPUSH
40818: CALL_OW 3
40822: ST_TO_ADDR
// end ;
40823: GO 40769
40825: POP
40826: POP
// end else
40827: GO 40849
// if sort then
40829: LD_VAR 0 9
40833: IFFALSE 40849
// p := sort [ 1 ] ;
40835: LD_ADDR_VAR 0 11
40839: PUSH
40840: LD_VAR 0 9
40844: PUSH
40845: LD_INT 1
40847: ARRAY
40848: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
40849: LD_ADDR_VAR 0 2
40853: PUSH
40854: LD_INT 0
40856: PUSH
40857: LD_INT 0
40859: PUSH
40860: LD_INT 0
40862: PUSH
40863: LD_VAR 0 11
40867: PUSH
40868: EMPTY
40869: LIST
40870: LIST
40871: LIST
40872: LIST
40873: ST_TO_ADDR
// exit ;
40874: GO 43095
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40876: LD_EXP 129
40880: PUSH
40881: LD_EXP 128
40885: PUSH
40886: LD_VAR 0 1
40890: ARRAY
40891: ARRAY
40892: PUSH
40893: LD_EXP 102
40897: PUSH
40898: LD_VAR 0 1
40902: ARRAY
40903: PPUSH
40904: LD_INT 2
40906: PUSH
40907: LD_INT 30
40909: PUSH
40910: LD_INT 6
40912: PUSH
40913: EMPTY
40914: LIST
40915: LIST
40916: PUSH
40917: LD_INT 30
40919: PUSH
40920: LD_INT 7
40922: PUSH
40923: EMPTY
40924: LIST
40925: LIST
40926: PUSH
40927: LD_INT 30
40929: PUSH
40930: LD_INT 8
40932: PUSH
40933: EMPTY
40934: LIST
40935: LIST
40936: PUSH
40937: EMPTY
40938: LIST
40939: LIST
40940: LIST
40941: LIST
40942: PPUSH
40943: CALL_OW 72
40947: AND
40948: PUSH
40949: LD_EXP 102
40953: PUSH
40954: LD_VAR 0 1
40958: ARRAY
40959: PPUSH
40960: LD_INT 30
40962: PUSH
40963: LD_INT 3
40965: PUSH
40966: EMPTY
40967: LIST
40968: LIST
40969: PPUSH
40970: CALL_OW 72
40974: AND
40975: IFFALSE 41709
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
40977: LD_ADDR_EXP 144
40981: PUSH
40982: LD_EXP 144
40986: PPUSH
40987: LD_VAR 0 1
40991: PPUSH
40992: LD_INT 3
40994: PPUSH
40995: CALL_OW 1
40999: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41000: LD_ADDR_VAR 0 2
41004: PUSH
41005: LD_INT 0
41007: PUSH
41008: LD_INT 0
41010: PUSH
41011: LD_INT 0
41013: PUSH
41014: LD_INT 0
41016: PUSH
41017: EMPTY
41018: LIST
41019: LIST
41020: LIST
41021: LIST
41022: ST_TO_ADDR
// if not eng then
41023: LD_VAR 0 6
41027: NOT
41028: IFFALSE 41091
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41030: LD_ADDR_VAR 0 11
41034: PUSH
41035: LD_VAR 0 4
41039: PPUSH
41040: LD_INT 2
41042: PPUSH
41043: CALL 106389 0 2
41047: PUSH
41048: LD_INT 1
41050: ARRAY
41051: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41052: LD_ADDR_VAR 0 2
41056: PUSH
41057: LD_VAR 0 2
41061: PPUSH
41062: LD_INT 2
41064: PPUSH
41065: LD_VAR 0 11
41069: PPUSH
41070: CALL_OW 1
41074: ST_TO_ADDR
// tmp := tmp diff p ;
41075: LD_ADDR_VAR 0 4
41079: PUSH
41080: LD_VAR 0 4
41084: PUSH
41085: LD_VAR 0 11
41089: DIFF
41090: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41091: LD_VAR 0 4
41095: PUSH
41096: LD_VAR 0 8
41100: PUSH
41101: LD_INT 6
41103: LESS
41104: AND
41105: IFFALSE 41293
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41107: LD_ADDR_VAR 0 9
41111: PUSH
41112: LD_VAR 0 4
41116: PUSH
41117: LD_VAR 0 8
41121: PUSH
41122: LD_VAR 0 7
41126: UNION
41127: DIFF
41128: PPUSH
41129: LD_INT 4
41131: PPUSH
41132: CALL 106389 0 2
41136: ST_TO_ADDR
// p := [ ] ;
41137: LD_ADDR_VAR 0 11
41141: PUSH
41142: EMPTY
41143: ST_TO_ADDR
// if sort then
41144: LD_VAR 0 9
41148: IFFALSE 41264
// for i = 1 to 6 - sci do
41150: LD_ADDR_VAR 0 3
41154: PUSH
41155: DOUBLE
41156: LD_INT 1
41158: DEC
41159: ST_TO_ADDR
41160: LD_INT 6
41162: PUSH
41163: LD_VAR 0 8
41167: MINUS
41168: PUSH
41169: FOR_TO
41170: IFFALSE 41262
// begin if i = sort then
41172: LD_VAR 0 3
41176: PUSH
41177: LD_VAR 0 9
41181: EQUAL
41182: IFFALSE 41186
// break ;
41184: GO 41262
// if GetClass ( i ) = 4 then
41186: LD_VAR 0 3
41190: PPUSH
41191: CALL_OW 257
41195: PUSH
41196: LD_INT 4
41198: EQUAL
41199: IFFALSE 41203
// continue ;
41201: GO 41169
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41203: LD_ADDR_VAR 0 11
41207: PUSH
41208: LD_VAR 0 11
41212: PPUSH
41213: LD_VAR 0 11
41217: PUSH
41218: LD_INT 1
41220: PLUS
41221: PPUSH
41222: LD_VAR 0 9
41226: PUSH
41227: LD_VAR 0 3
41231: ARRAY
41232: PPUSH
41233: CALL_OW 2
41237: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41238: LD_ADDR_VAR 0 4
41242: PUSH
41243: LD_VAR 0 4
41247: PUSH
41248: LD_VAR 0 9
41252: PUSH
41253: LD_VAR 0 3
41257: ARRAY
41258: DIFF
41259: ST_TO_ADDR
// end ;
41260: GO 41169
41262: POP
41263: POP
// if p then
41264: LD_VAR 0 11
41268: IFFALSE 41293
// result := Replace ( result , 4 , p ) ;
41270: LD_ADDR_VAR 0 2
41274: PUSH
41275: LD_VAR 0 2
41279: PPUSH
41280: LD_INT 4
41282: PPUSH
41283: LD_VAR 0 11
41287: PPUSH
41288: CALL_OW 1
41292: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41293: LD_VAR 0 4
41297: PUSH
41298: LD_VAR 0 7
41302: PUSH
41303: LD_INT 6
41305: LESS
41306: AND
41307: IFFALSE 41495
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41309: LD_ADDR_VAR 0 9
41313: PUSH
41314: LD_VAR 0 4
41318: PUSH
41319: LD_VAR 0 8
41323: PUSH
41324: LD_VAR 0 7
41328: UNION
41329: DIFF
41330: PPUSH
41331: LD_INT 3
41333: PPUSH
41334: CALL 106389 0 2
41338: ST_TO_ADDR
// p := [ ] ;
41339: LD_ADDR_VAR 0 11
41343: PUSH
41344: EMPTY
41345: ST_TO_ADDR
// if sort then
41346: LD_VAR 0 9
41350: IFFALSE 41466
// for i = 1 to 6 - mech do
41352: LD_ADDR_VAR 0 3
41356: PUSH
41357: DOUBLE
41358: LD_INT 1
41360: DEC
41361: ST_TO_ADDR
41362: LD_INT 6
41364: PUSH
41365: LD_VAR 0 7
41369: MINUS
41370: PUSH
41371: FOR_TO
41372: IFFALSE 41464
// begin if i = sort then
41374: LD_VAR 0 3
41378: PUSH
41379: LD_VAR 0 9
41383: EQUAL
41384: IFFALSE 41388
// break ;
41386: GO 41464
// if GetClass ( i ) = 3 then
41388: LD_VAR 0 3
41392: PPUSH
41393: CALL_OW 257
41397: PUSH
41398: LD_INT 3
41400: EQUAL
41401: IFFALSE 41405
// continue ;
41403: GO 41371
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41405: LD_ADDR_VAR 0 11
41409: PUSH
41410: LD_VAR 0 11
41414: PPUSH
41415: LD_VAR 0 11
41419: PUSH
41420: LD_INT 1
41422: PLUS
41423: PPUSH
41424: LD_VAR 0 9
41428: PUSH
41429: LD_VAR 0 3
41433: ARRAY
41434: PPUSH
41435: CALL_OW 2
41439: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41440: LD_ADDR_VAR 0 4
41444: PUSH
41445: LD_VAR 0 4
41449: PUSH
41450: LD_VAR 0 9
41454: PUSH
41455: LD_VAR 0 3
41459: ARRAY
41460: DIFF
41461: ST_TO_ADDR
// end ;
41462: GO 41371
41464: POP
41465: POP
// if p then
41466: LD_VAR 0 11
41470: IFFALSE 41495
// result := Replace ( result , 3 , p ) ;
41472: LD_ADDR_VAR 0 2
41476: PUSH
41477: LD_VAR 0 2
41481: PPUSH
41482: LD_INT 3
41484: PPUSH
41485: LD_VAR 0 11
41489: PPUSH
41490: CALL_OW 1
41494: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41495: LD_VAR 0 4
41499: PUSH
41500: LD_INT 6
41502: GREATER
41503: PUSH
41504: LD_VAR 0 6
41508: PUSH
41509: LD_INT 6
41511: LESS
41512: AND
41513: IFFALSE 41707
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41515: LD_ADDR_VAR 0 9
41519: PUSH
41520: LD_VAR 0 4
41524: PUSH
41525: LD_VAR 0 8
41529: PUSH
41530: LD_VAR 0 7
41534: UNION
41535: PUSH
41536: LD_VAR 0 6
41540: UNION
41541: DIFF
41542: PPUSH
41543: LD_INT 2
41545: PPUSH
41546: CALL 106389 0 2
41550: ST_TO_ADDR
// p := [ ] ;
41551: LD_ADDR_VAR 0 11
41555: PUSH
41556: EMPTY
41557: ST_TO_ADDR
// if sort then
41558: LD_VAR 0 9
41562: IFFALSE 41678
// for i = 1 to 6 - eng do
41564: LD_ADDR_VAR 0 3
41568: PUSH
41569: DOUBLE
41570: LD_INT 1
41572: DEC
41573: ST_TO_ADDR
41574: LD_INT 6
41576: PUSH
41577: LD_VAR 0 6
41581: MINUS
41582: PUSH
41583: FOR_TO
41584: IFFALSE 41676
// begin if i = sort then
41586: LD_VAR 0 3
41590: PUSH
41591: LD_VAR 0 9
41595: EQUAL
41596: IFFALSE 41600
// break ;
41598: GO 41676
// if GetClass ( i ) = 2 then
41600: LD_VAR 0 3
41604: PPUSH
41605: CALL_OW 257
41609: PUSH
41610: LD_INT 2
41612: EQUAL
41613: IFFALSE 41617
// continue ;
41615: GO 41583
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41617: LD_ADDR_VAR 0 11
41621: PUSH
41622: LD_VAR 0 11
41626: PPUSH
41627: LD_VAR 0 11
41631: PUSH
41632: LD_INT 1
41634: PLUS
41635: PPUSH
41636: LD_VAR 0 9
41640: PUSH
41641: LD_VAR 0 3
41645: ARRAY
41646: PPUSH
41647: CALL_OW 2
41651: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41652: LD_ADDR_VAR 0 4
41656: PUSH
41657: LD_VAR 0 4
41661: PUSH
41662: LD_VAR 0 9
41666: PUSH
41667: LD_VAR 0 3
41671: ARRAY
41672: DIFF
41673: ST_TO_ADDR
// end ;
41674: GO 41583
41676: POP
41677: POP
// if p then
41678: LD_VAR 0 11
41682: IFFALSE 41707
// result := Replace ( result , 2 , p ) ;
41684: LD_ADDR_VAR 0 2
41688: PUSH
41689: LD_VAR 0 2
41693: PPUSH
41694: LD_INT 2
41696: PPUSH
41697: LD_VAR 0 11
41701: PPUSH
41702: CALL_OW 1
41706: ST_TO_ADDR
// end ; exit ;
41707: GO 43095
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
41709: LD_EXP 129
41713: PUSH
41714: LD_EXP 128
41718: PUSH
41719: LD_VAR 0 1
41723: ARRAY
41724: ARRAY
41725: NOT
41726: PUSH
41727: LD_EXP 102
41731: PUSH
41732: LD_VAR 0 1
41736: ARRAY
41737: PPUSH
41738: LD_INT 30
41740: PUSH
41741: LD_INT 3
41743: PUSH
41744: EMPTY
41745: LIST
41746: LIST
41747: PPUSH
41748: CALL_OW 72
41752: AND
41753: PUSH
41754: LD_EXP 107
41758: PUSH
41759: LD_VAR 0 1
41763: ARRAY
41764: AND
41765: IFFALSE 42373
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
41767: LD_ADDR_EXP 144
41771: PUSH
41772: LD_EXP 144
41776: PPUSH
41777: LD_VAR 0 1
41781: PPUSH
41782: LD_INT 5
41784: PPUSH
41785: CALL_OW 1
41789: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41790: LD_ADDR_VAR 0 2
41794: PUSH
41795: LD_INT 0
41797: PUSH
41798: LD_INT 0
41800: PUSH
41801: LD_INT 0
41803: PUSH
41804: LD_INT 0
41806: PUSH
41807: EMPTY
41808: LIST
41809: LIST
41810: LIST
41811: LIST
41812: ST_TO_ADDR
// if sci > 1 then
41813: LD_VAR 0 8
41817: PUSH
41818: LD_INT 1
41820: GREATER
41821: IFFALSE 41849
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
41823: LD_ADDR_VAR 0 4
41827: PUSH
41828: LD_VAR 0 4
41832: PUSH
41833: LD_VAR 0 8
41837: PUSH
41838: LD_VAR 0 8
41842: PUSH
41843: LD_INT 1
41845: ARRAY
41846: DIFF
41847: DIFF
41848: ST_TO_ADDR
// if tmp and not sci then
41849: LD_VAR 0 4
41853: PUSH
41854: LD_VAR 0 8
41858: NOT
41859: AND
41860: IFFALSE 41929
// begin sort := SortBySkill ( tmp , 4 ) ;
41862: LD_ADDR_VAR 0 9
41866: PUSH
41867: LD_VAR 0 4
41871: PPUSH
41872: LD_INT 4
41874: PPUSH
41875: CALL 106389 0 2
41879: ST_TO_ADDR
// if sort then
41880: LD_VAR 0 9
41884: IFFALSE 41900
// p := sort [ 1 ] ;
41886: LD_ADDR_VAR 0 11
41890: PUSH
41891: LD_VAR 0 9
41895: PUSH
41896: LD_INT 1
41898: ARRAY
41899: ST_TO_ADDR
// if p then
41900: LD_VAR 0 11
41904: IFFALSE 41929
// result := Replace ( result , 4 , p ) ;
41906: LD_ADDR_VAR 0 2
41910: PUSH
41911: LD_VAR 0 2
41915: PPUSH
41916: LD_INT 4
41918: PPUSH
41919: LD_VAR 0 11
41923: PPUSH
41924: CALL_OW 1
41928: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41929: LD_ADDR_VAR 0 4
41933: PUSH
41934: LD_VAR 0 4
41938: PUSH
41939: LD_VAR 0 7
41943: DIFF
41944: ST_TO_ADDR
// if tmp and mech < 6 then
41945: LD_VAR 0 4
41949: PUSH
41950: LD_VAR 0 7
41954: PUSH
41955: LD_INT 6
41957: LESS
41958: AND
41959: IFFALSE 42147
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41961: LD_ADDR_VAR 0 9
41965: PUSH
41966: LD_VAR 0 4
41970: PUSH
41971: LD_VAR 0 8
41975: PUSH
41976: LD_VAR 0 7
41980: UNION
41981: DIFF
41982: PPUSH
41983: LD_INT 3
41985: PPUSH
41986: CALL 106389 0 2
41990: ST_TO_ADDR
// p := [ ] ;
41991: LD_ADDR_VAR 0 11
41995: PUSH
41996: EMPTY
41997: ST_TO_ADDR
// if sort then
41998: LD_VAR 0 9
42002: IFFALSE 42118
// for i = 1 to 6 - mech do
42004: LD_ADDR_VAR 0 3
42008: PUSH
42009: DOUBLE
42010: LD_INT 1
42012: DEC
42013: ST_TO_ADDR
42014: LD_INT 6
42016: PUSH
42017: LD_VAR 0 7
42021: MINUS
42022: PUSH
42023: FOR_TO
42024: IFFALSE 42116
// begin if i = sort then
42026: LD_VAR 0 3
42030: PUSH
42031: LD_VAR 0 9
42035: EQUAL
42036: IFFALSE 42040
// break ;
42038: GO 42116
// if GetClass ( i ) = 3 then
42040: LD_VAR 0 3
42044: PPUSH
42045: CALL_OW 257
42049: PUSH
42050: LD_INT 3
42052: EQUAL
42053: IFFALSE 42057
// continue ;
42055: GO 42023
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42057: LD_ADDR_VAR 0 11
42061: PUSH
42062: LD_VAR 0 11
42066: PPUSH
42067: LD_VAR 0 11
42071: PUSH
42072: LD_INT 1
42074: PLUS
42075: PPUSH
42076: LD_VAR 0 9
42080: PUSH
42081: LD_VAR 0 3
42085: ARRAY
42086: PPUSH
42087: CALL_OW 2
42091: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42092: LD_ADDR_VAR 0 4
42096: PUSH
42097: LD_VAR 0 4
42101: PUSH
42102: LD_VAR 0 9
42106: PUSH
42107: LD_VAR 0 3
42111: ARRAY
42112: DIFF
42113: ST_TO_ADDR
// end ;
42114: GO 42023
42116: POP
42117: POP
// if p then
42118: LD_VAR 0 11
42122: IFFALSE 42147
// result := Replace ( result , 3 , p ) ;
42124: LD_ADDR_VAR 0 2
42128: PUSH
42129: LD_VAR 0 2
42133: PPUSH
42134: LD_INT 3
42136: PPUSH
42137: LD_VAR 0 11
42141: PPUSH
42142: CALL_OW 1
42146: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42147: LD_ADDR_VAR 0 4
42151: PUSH
42152: LD_VAR 0 4
42156: PUSH
42157: LD_VAR 0 6
42161: DIFF
42162: ST_TO_ADDR
// if tmp and eng < 6 then
42163: LD_VAR 0 4
42167: PUSH
42168: LD_VAR 0 6
42172: PUSH
42173: LD_INT 6
42175: LESS
42176: AND
42177: IFFALSE 42371
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42179: LD_ADDR_VAR 0 9
42183: PUSH
42184: LD_VAR 0 4
42188: PUSH
42189: LD_VAR 0 8
42193: PUSH
42194: LD_VAR 0 7
42198: UNION
42199: PUSH
42200: LD_VAR 0 6
42204: UNION
42205: DIFF
42206: PPUSH
42207: LD_INT 2
42209: PPUSH
42210: CALL 106389 0 2
42214: ST_TO_ADDR
// p := [ ] ;
42215: LD_ADDR_VAR 0 11
42219: PUSH
42220: EMPTY
42221: ST_TO_ADDR
// if sort then
42222: LD_VAR 0 9
42226: IFFALSE 42342
// for i = 1 to 6 - eng do
42228: LD_ADDR_VAR 0 3
42232: PUSH
42233: DOUBLE
42234: LD_INT 1
42236: DEC
42237: ST_TO_ADDR
42238: LD_INT 6
42240: PUSH
42241: LD_VAR 0 6
42245: MINUS
42246: PUSH
42247: FOR_TO
42248: IFFALSE 42340
// begin if i = sort then
42250: LD_VAR 0 3
42254: PUSH
42255: LD_VAR 0 9
42259: EQUAL
42260: IFFALSE 42264
// break ;
42262: GO 42340
// if GetClass ( i ) = 2 then
42264: LD_VAR 0 3
42268: PPUSH
42269: CALL_OW 257
42273: PUSH
42274: LD_INT 2
42276: EQUAL
42277: IFFALSE 42281
// continue ;
42279: GO 42247
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42281: LD_ADDR_VAR 0 11
42285: PUSH
42286: LD_VAR 0 11
42290: PPUSH
42291: LD_VAR 0 11
42295: PUSH
42296: LD_INT 1
42298: PLUS
42299: PPUSH
42300: LD_VAR 0 9
42304: PUSH
42305: LD_VAR 0 3
42309: ARRAY
42310: PPUSH
42311: CALL_OW 2
42315: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42316: LD_ADDR_VAR 0 4
42320: PUSH
42321: LD_VAR 0 4
42325: PUSH
42326: LD_VAR 0 9
42330: PUSH
42331: LD_VAR 0 3
42335: ARRAY
42336: DIFF
42337: ST_TO_ADDR
// end ;
42338: GO 42247
42340: POP
42341: POP
// if p then
42342: LD_VAR 0 11
42346: IFFALSE 42371
// result := Replace ( result , 2 , p ) ;
42348: LD_ADDR_VAR 0 2
42352: PUSH
42353: LD_VAR 0 2
42357: PPUSH
42358: LD_INT 2
42360: PPUSH
42361: LD_VAR 0 11
42365: PPUSH
42366: CALL_OW 1
42370: ST_TO_ADDR
// end ; exit ;
42371: GO 43095
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42373: LD_EXP 129
42377: PUSH
42378: LD_EXP 128
42382: PUSH
42383: LD_VAR 0 1
42387: ARRAY
42388: ARRAY
42389: NOT
42390: PUSH
42391: LD_EXP 102
42395: PUSH
42396: LD_VAR 0 1
42400: ARRAY
42401: PPUSH
42402: LD_INT 30
42404: PUSH
42405: LD_INT 3
42407: PUSH
42408: EMPTY
42409: LIST
42410: LIST
42411: PPUSH
42412: CALL_OW 72
42416: AND
42417: PUSH
42418: LD_EXP 107
42422: PUSH
42423: LD_VAR 0 1
42427: ARRAY
42428: NOT
42429: AND
42430: IFFALSE 43095
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42432: LD_ADDR_EXP 144
42436: PUSH
42437: LD_EXP 144
42441: PPUSH
42442: LD_VAR 0 1
42446: PPUSH
42447: LD_INT 6
42449: PPUSH
42450: CALL_OW 1
42454: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42455: LD_ADDR_VAR 0 2
42459: PUSH
42460: LD_INT 0
42462: PUSH
42463: LD_INT 0
42465: PUSH
42466: LD_INT 0
42468: PUSH
42469: LD_INT 0
42471: PUSH
42472: EMPTY
42473: LIST
42474: LIST
42475: LIST
42476: LIST
42477: ST_TO_ADDR
// if sci >= 1 then
42478: LD_VAR 0 8
42482: PUSH
42483: LD_INT 1
42485: GREATEREQUAL
42486: IFFALSE 42508
// tmp := tmp diff sci [ 1 ] ;
42488: LD_ADDR_VAR 0 4
42492: PUSH
42493: LD_VAR 0 4
42497: PUSH
42498: LD_VAR 0 8
42502: PUSH
42503: LD_INT 1
42505: ARRAY
42506: DIFF
42507: ST_TO_ADDR
// if tmp and not sci then
42508: LD_VAR 0 4
42512: PUSH
42513: LD_VAR 0 8
42517: NOT
42518: AND
42519: IFFALSE 42588
// begin sort := SortBySkill ( tmp , 4 ) ;
42521: LD_ADDR_VAR 0 9
42525: PUSH
42526: LD_VAR 0 4
42530: PPUSH
42531: LD_INT 4
42533: PPUSH
42534: CALL 106389 0 2
42538: ST_TO_ADDR
// if sort then
42539: LD_VAR 0 9
42543: IFFALSE 42559
// p := sort [ 1 ] ;
42545: LD_ADDR_VAR 0 11
42549: PUSH
42550: LD_VAR 0 9
42554: PUSH
42555: LD_INT 1
42557: ARRAY
42558: ST_TO_ADDR
// if p then
42559: LD_VAR 0 11
42563: IFFALSE 42588
// result := Replace ( result , 4 , p ) ;
42565: LD_ADDR_VAR 0 2
42569: PUSH
42570: LD_VAR 0 2
42574: PPUSH
42575: LD_INT 4
42577: PPUSH
42578: LD_VAR 0 11
42582: PPUSH
42583: CALL_OW 1
42587: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42588: LD_ADDR_VAR 0 4
42592: PUSH
42593: LD_VAR 0 4
42597: PUSH
42598: LD_VAR 0 7
42602: DIFF
42603: ST_TO_ADDR
// if tmp and mech < 6 then
42604: LD_VAR 0 4
42608: PUSH
42609: LD_VAR 0 7
42613: PUSH
42614: LD_INT 6
42616: LESS
42617: AND
42618: IFFALSE 42800
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
42620: LD_ADDR_VAR 0 9
42624: PUSH
42625: LD_VAR 0 4
42629: PUSH
42630: LD_VAR 0 7
42634: DIFF
42635: PPUSH
42636: LD_INT 3
42638: PPUSH
42639: CALL 106389 0 2
42643: ST_TO_ADDR
// p := [ ] ;
42644: LD_ADDR_VAR 0 11
42648: PUSH
42649: EMPTY
42650: ST_TO_ADDR
// if sort then
42651: LD_VAR 0 9
42655: IFFALSE 42771
// for i = 1 to 6 - mech do
42657: LD_ADDR_VAR 0 3
42661: PUSH
42662: DOUBLE
42663: LD_INT 1
42665: DEC
42666: ST_TO_ADDR
42667: LD_INT 6
42669: PUSH
42670: LD_VAR 0 7
42674: MINUS
42675: PUSH
42676: FOR_TO
42677: IFFALSE 42769
// begin if i = sort then
42679: LD_VAR 0 3
42683: PUSH
42684: LD_VAR 0 9
42688: EQUAL
42689: IFFALSE 42693
// break ;
42691: GO 42769
// if GetClass ( i ) = 3 then
42693: LD_VAR 0 3
42697: PPUSH
42698: CALL_OW 257
42702: PUSH
42703: LD_INT 3
42705: EQUAL
42706: IFFALSE 42710
// continue ;
42708: GO 42676
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42710: LD_ADDR_VAR 0 11
42714: PUSH
42715: LD_VAR 0 11
42719: PPUSH
42720: LD_VAR 0 11
42724: PUSH
42725: LD_INT 1
42727: PLUS
42728: PPUSH
42729: LD_VAR 0 9
42733: PUSH
42734: LD_VAR 0 3
42738: ARRAY
42739: PPUSH
42740: CALL_OW 2
42744: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42745: LD_ADDR_VAR 0 4
42749: PUSH
42750: LD_VAR 0 4
42754: PUSH
42755: LD_VAR 0 9
42759: PUSH
42760: LD_VAR 0 3
42764: ARRAY
42765: DIFF
42766: ST_TO_ADDR
// end ;
42767: GO 42676
42769: POP
42770: POP
// if p then
42771: LD_VAR 0 11
42775: IFFALSE 42800
// result := Replace ( result , 3 , p ) ;
42777: LD_ADDR_VAR 0 2
42781: PUSH
42782: LD_VAR 0 2
42786: PPUSH
42787: LD_INT 3
42789: PPUSH
42790: LD_VAR 0 11
42794: PPUSH
42795: CALL_OW 1
42799: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42800: LD_ADDR_VAR 0 4
42804: PUSH
42805: LD_VAR 0 4
42809: PUSH
42810: LD_VAR 0 6
42814: DIFF
42815: ST_TO_ADDR
// if tmp and eng < 4 then
42816: LD_VAR 0 4
42820: PUSH
42821: LD_VAR 0 6
42825: PUSH
42826: LD_INT 4
42828: LESS
42829: AND
42830: IFFALSE 43020
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
42832: LD_ADDR_VAR 0 9
42836: PUSH
42837: LD_VAR 0 4
42841: PUSH
42842: LD_VAR 0 7
42846: PUSH
42847: LD_VAR 0 6
42851: UNION
42852: DIFF
42853: PPUSH
42854: LD_INT 2
42856: PPUSH
42857: CALL 106389 0 2
42861: ST_TO_ADDR
// p := [ ] ;
42862: LD_ADDR_VAR 0 11
42866: PUSH
42867: EMPTY
42868: ST_TO_ADDR
// if sort then
42869: LD_VAR 0 9
42873: IFFALSE 42989
// for i = 1 to 4 - eng do
42875: LD_ADDR_VAR 0 3
42879: PUSH
42880: DOUBLE
42881: LD_INT 1
42883: DEC
42884: ST_TO_ADDR
42885: LD_INT 4
42887: PUSH
42888: LD_VAR 0 6
42892: MINUS
42893: PUSH
42894: FOR_TO
42895: IFFALSE 42987
// begin if i = sort then
42897: LD_VAR 0 3
42901: PUSH
42902: LD_VAR 0 9
42906: EQUAL
42907: IFFALSE 42911
// break ;
42909: GO 42987
// if GetClass ( i ) = 2 then
42911: LD_VAR 0 3
42915: PPUSH
42916: CALL_OW 257
42920: PUSH
42921: LD_INT 2
42923: EQUAL
42924: IFFALSE 42928
// continue ;
42926: GO 42894
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42928: LD_ADDR_VAR 0 11
42932: PUSH
42933: LD_VAR 0 11
42937: PPUSH
42938: LD_VAR 0 11
42942: PUSH
42943: LD_INT 1
42945: PLUS
42946: PPUSH
42947: LD_VAR 0 9
42951: PUSH
42952: LD_VAR 0 3
42956: ARRAY
42957: PPUSH
42958: CALL_OW 2
42962: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42963: LD_ADDR_VAR 0 4
42967: PUSH
42968: LD_VAR 0 4
42972: PUSH
42973: LD_VAR 0 9
42977: PUSH
42978: LD_VAR 0 3
42982: ARRAY
42983: DIFF
42984: ST_TO_ADDR
// end ;
42985: GO 42894
42987: POP
42988: POP
// if p then
42989: LD_VAR 0 11
42993: IFFALSE 43018
// result := Replace ( result , 2 , p ) ;
42995: LD_ADDR_VAR 0 2
42999: PUSH
43000: LD_VAR 0 2
43004: PPUSH
43005: LD_INT 2
43007: PPUSH
43008: LD_VAR 0 11
43012: PPUSH
43013: CALL_OW 1
43017: ST_TO_ADDR
// end else
43018: GO 43064
// for i = eng downto 5 do
43020: LD_ADDR_VAR 0 3
43024: PUSH
43025: DOUBLE
43026: LD_VAR 0 6
43030: INC
43031: ST_TO_ADDR
43032: LD_INT 5
43034: PUSH
43035: FOR_DOWNTO
43036: IFFALSE 43062
// tmp := tmp union eng [ i ] ;
43038: LD_ADDR_VAR 0 4
43042: PUSH
43043: LD_VAR 0 4
43047: PUSH
43048: LD_VAR 0 6
43052: PUSH
43053: LD_VAR 0 3
43057: ARRAY
43058: UNION
43059: ST_TO_ADDR
43060: GO 43035
43062: POP
43063: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43064: LD_ADDR_VAR 0 2
43068: PUSH
43069: LD_VAR 0 2
43073: PPUSH
43074: LD_INT 1
43076: PPUSH
43077: LD_VAR 0 4
43081: PUSH
43082: LD_VAR 0 5
43086: DIFF
43087: PPUSH
43088: CALL_OW 1
43092: ST_TO_ADDR
// exit ;
43093: GO 43095
// end ; end ;
43095: LD_VAR 0 2
43099: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43100: LD_INT 0
43102: PPUSH
43103: PPUSH
43104: PPUSH
// if not mc_bases then
43105: LD_EXP 102
43109: NOT
43110: IFFALSE 43114
// exit ;
43112: GO 43220
// for i = 1 to mc_bases do
43114: LD_ADDR_VAR 0 2
43118: PUSH
43119: DOUBLE
43120: LD_INT 1
43122: DEC
43123: ST_TO_ADDR
43124: LD_EXP 102
43128: PUSH
43129: FOR_TO
43130: IFFALSE 43211
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43132: LD_ADDR_VAR 0 3
43136: PUSH
43137: LD_EXP 102
43141: PUSH
43142: LD_VAR 0 2
43146: ARRAY
43147: PPUSH
43148: LD_INT 21
43150: PUSH
43151: LD_INT 3
43153: PUSH
43154: EMPTY
43155: LIST
43156: LIST
43157: PUSH
43158: LD_INT 3
43160: PUSH
43161: LD_INT 24
43163: PUSH
43164: LD_INT 1000
43166: PUSH
43167: EMPTY
43168: LIST
43169: LIST
43170: PUSH
43171: EMPTY
43172: LIST
43173: LIST
43174: PUSH
43175: EMPTY
43176: LIST
43177: LIST
43178: PPUSH
43179: CALL_OW 72
43183: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43184: LD_ADDR_EXP 103
43188: PUSH
43189: LD_EXP 103
43193: PPUSH
43194: LD_VAR 0 2
43198: PPUSH
43199: LD_VAR 0 3
43203: PPUSH
43204: CALL_OW 1
43208: ST_TO_ADDR
// end ;
43209: GO 43129
43211: POP
43212: POP
// RaiseSailEvent ( 101 ) ;
43213: LD_INT 101
43215: PPUSH
43216: CALL_OW 427
// end ;
43220: LD_VAR 0 1
43224: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43225: LD_INT 0
43227: PPUSH
43228: PPUSH
43229: PPUSH
43230: PPUSH
43231: PPUSH
43232: PPUSH
43233: PPUSH
// if not mc_bases then
43234: LD_EXP 102
43238: NOT
43239: IFFALSE 43243
// exit ;
43241: GO 43816
// for i = 1 to mc_bases do
43243: LD_ADDR_VAR 0 2
43247: PUSH
43248: DOUBLE
43249: LD_INT 1
43251: DEC
43252: ST_TO_ADDR
43253: LD_EXP 102
43257: PUSH
43258: FOR_TO
43259: IFFALSE 43807
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
43261: LD_ADDR_VAR 0 5
43265: PUSH
43266: LD_EXP 102
43270: PUSH
43271: LD_VAR 0 2
43275: ARRAY
43276: PUSH
43277: LD_EXP 131
43281: PUSH
43282: LD_VAR 0 2
43286: ARRAY
43287: UNION
43288: PPUSH
43289: LD_INT 21
43291: PUSH
43292: LD_INT 1
43294: PUSH
43295: EMPTY
43296: LIST
43297: LIST
43298: PUSH
43299: LD_INT 1
43301: PUSH
43302: LD_INT 3
43304: PUSH
43305: LD_INT 54
43307: PUSH
43308: EMPTY
43309: LIST
43310: PUSH
43311: EMPTY
43312: LIST
43313: LIST
43314: PUSH
43315: LD_INT 3
43317: PUSH
43318: LD_INT 24
43320: PUSH
43321: LD_INT 800
43323: PUSH
43324: EMPTY
43325: LIST
43326: LIST
43327: PUSH
43328: EMPTY
43329: LIST
43330: LIST
43331: PUSH
43332: EMPTY
43333: LIST
43334: LIST
43335: LIST
43336: PUSH
43337: EMPTY
43338: LIST
43339: LIST
43340: PPUSH
43341: CALL_OW 72
43345: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43346: LD_ADDR_VAR 0 6
43350: PUSH
43351: LD_EXP 102
43355: PUSH
43356: LD_VAR 0 2
43360: ARRAY
43361: PPUSH
43362: LD_INT 21
43364: PUSH
43365: LD_INT 1
43367: PUSH
43368: EMPTY
43369: LIST
43370: LIST
43371: PUSH
43372: LD_INT 1
43374: PUSH
43375: LD_INT 3
43377: PUSH
43378: LD_INT 54
43380: PUSH
43381: EMPTY
43382: LIST
43383: PUSH
43384: EMPTY
43385: LIST
43386: LIST
43387: PUSH
43388: LD_INT 3
43390: PUSH
43391: LD_INT 24
43393: PUSH
43394: LD_INT 250
43396: PUSH
43397: EMPTY
43398: LIST
43399: LIST
43400: PUSH
43401: EMPTY
43402: LIST
43403: LIST
43404: PUSH
43405: EMPTY
43406: LIST
43407: LIST
43408: LIST
43409: PUSH
43410: EMPTY
43411: LIST
43412: LIST
43413: PPUSH
43414: CALL_OW 72
43418: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43419: LD_ADDR_VAR 0 7
43423: PUSH
43424: LD_VAR 0 5
43428: PUSH
43429: LD_VAR 0 6
43433: DIFF
43434: ST_TO_ADDR
// if not need_heal_1 then
43435: LD_VAR 0 6
43439: NOT
43440: IFFALSE 43473
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43442: LD_ADDR_EXP 105
43446: PUSH
43447: LD_EXP 105
43451: PPUSH
43452: LD_VAR 0 2
43456: PUSH
43457: LD_INT 1
43459: PUSH
43460: EMPTY
43461: LIST
43462: LIST
43463: PPUSH
43464: EMPTY
43465: PPUSH
43466: CALL 72131 0 3
43470: ST_TO_ADDR
43471: GO 43543
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43473: LD_ADDR_EXP 105
43477: PUSH
43478: LD_EXP 105
43482: PPUSH
43483: LD_VAR 0 2
43487: PUSH
43488: LD_INT 1
43490: PUSH
43491: EMPTY
43492: LIST
43493: LIST
43494: PPUSH
43495: LD_EXP 105
43499: PUSH
43500: LD_VAR 0 2
43504: ARRAY
43505: PUSH
43506: LD_INT 1
43508: ARRAY
43509: PPUSH
43510: LD_INT 3
43512: PUSH
43513: LD_INT 24
43515: PUSH
43516: LD_INT 1000
43518: PUSH
43519: EMPTY
43520: LIST
43521: LIST
43522: PUSH
43523: EMPTY
43524: LIST
43525: LIST
43526: PPUSH
43527: CALL_OW 72
43531: PUSH
43532: LD_VAR 0 6
43536: UNION
43537: PPUSH
43538: CALL 72131 0 3
43542: ST_TO_ADDR
// if not need_heal_2 then
43543: LD_VAR 0 7
43547: NOT
43548: IFFALSE 43581
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
43550: LD_ADDR_EXP 105
43554: PUSH
43555: LD_EXP 105
43559: PPUSH
43560: LD_VAR 0 2
43564: PUSH
43565: LD_INT 2
43567: PUSH
43568: EMPTY
43569: LIST
43570: LIST
43571: PPUSH
43572: EMPTY
43573: PPUSH
43574: CALL 72131 0 3
43578: ST_TO_ADDR
43579: GO 43613
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
43581: LD_ADDR_EXP 105
43585: PUSH
43586: LD_EXP 105
43590: PPUSH
43591: LD_VAR 0 2
43595: PUSH
43596: LD_INT 2
43598: PUSH
43599: EMPTY
43600: LIST
43601: LIST
43602: PPUSH
43603: LD_VAR 0 7
43607: PPUSH
43608: CALL 72131 0 3
43612: ST_TO_ADDR
// if need_heal_2 then
43613: LD_VAR 0 7
43617: IFFALSE 43789
// for j in need_heal_2 do
43619: LD_ADDR_VAR 0 3
43623: PUSH
43624: LD_VAR 0 7
43628: PUSH
43629: FOR_IN
43630: IFFALSE 43787
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
43632: LD_ADDR_VAR 0 5
43636: PUSH
43637: LD_EXP 102
43641: PUSH
43642: LD_VAR 0 2
43646: ARRAY
43647: PPUSH
43648: LD_INT 2
43650: PUSH
43651: LD_INT 30
43653: PUSH
43654: LD_INT 6
43656: PUSH
43657: EMPTY
43658: LIST
43659: LIST
43660: PUSH
43661: LD_INT 30
43663: PUSH
43664: LD_INT 7
43666: PUSH
43667: EMPTY
43668: LIST
43669: LIST
43670: PUSH
43671: LD_INT 30
43673: PUSH
43674: LD_INT 8
43676: PUSH
43677: EMPTY
43678: LIST
43679: LIST
43680: PUSH
43681: LD_INT 30
43683: PUSH
43684: LD_INT 0
43686: PUSH
43687: EMPTY
43688: LIST
43689: LIST
43690: PUSH
43691: LD_INT 30
43693: PUSH
43694: LD_INT 1
43696: PUSH
43697: EMPTY
43698: LIST
43699: LIST
43700: PUSH
43701: LD_INT 25
43703: PUSH
43704: LD_INT 4
43706: PUSH
43707: EMPTY
43708: LIST
43709: LIST
43710: PUSH
43711: EMPTY
43712: LIST
43713: LIST
43714: LIST
43715: LIST
43716: LIST
43717: LIST
43718: LIST
43719: PPUSH
43720: CALL_OW 72
43724: ST_TO_ADDR
// if tmp then
43725: LD_VAR 0 5
43729: IFFALSE 43785
// begin k := NearestUnitToUnit ( tmp , j ) ;
43731: LD_ADDR_VAR 0 4
43735: PUSH
43736: LD_VAR 0 5
43740: PPUSH
43741: LD_VAR 0 3
43745: PPUSH
43746: CALL_OW 74
43750: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
43751: LD_VAR 0 3
43755: PPUSH
43756: LD_VAR 0 4
43760: PPUSH
43761: CALL_OW 296
43765: PUSH
43766: LD_INT 7
43768: GREATER
43769: IFFALSE 43785
// ComMoveUnit ( j , k ) ;
43771: LD_VAR 0 3
43775: PPUSH
43776: LD_VAR 0 4
43780: PPUSH
43781: CALL_OW 112
// end ; end ;
43785: GO 43629
43787: POP
43788: POP
// if not need_heal_1 and not need_heal_2 then
43789: LD_VAR 0 6
43793: NOT
43794: PUSH
43795: LD_VAR 0 7
43799: NOT
43800: AND
43801: IFFALSE 43805
// continue ;
43803: GO 43258
// end ;
43805: GO 43258
43807: POP
43808: POP
// RaiseSailEvent ( 102 ) ;
43809: LD_INT 102
43811: PPUSH
43812: CALL_OW 427
// end ;
43816: LD_VAR 0 1
43820: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
43821: LD_INT 0
43823: PPUSH
43824: PPUSH
43825: PPUSH
43826: PPUSH
43827: PPUSH
43828: PPUSH
43829: PPUSH
43830: PPUSH
// if not mc_bases then
43831: LD_EXP 102
43835: NOT
43836: IFFALSE 43840
// exit ;
43838: GO 44680
// for i = 1 to mc_bases do
43840: LD_ADDR_VAR 0 2
43844: PUSH
43845: DOUBLE
43846: LD_INT 1
43848: DEC
43849: ST_TO_ADDR
43850: LD_EXP 102
43854: PUSH
43855: FOR_TO
43856: IFFALSE 44678
// begin if not mc_building_need_repair [ i ] then
43858: LD_EXP 103
43862: PUSH
43863: LD_VAR 0 2
43867: ARRAY
43868: NOT
43869: IFFALSE 44043
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
43871: LD_ADDR_VAR 0 6
43875: PUSH
43876: LD_EXP 121
43880: PUSH
43881: LD_VAR 0 2
43885: ARRAY
43886: PPUSH
43887: LD_INT 3
43889: PUSH
43890: LD_INT 24
43892: PUSH
43893: LD_INT 1000
43895: PUSH
43896: EMPTY
43897: LIST
43898: LIST
43899: PUSH
43900: EMPTY
43901: LIST
43902: LIST
43903: PUSH
43904: LD_INT 2
43906: PUSH
43907: LD_INT 34
43909: PUSH
43910: LD_INT 13
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PUSH
43917: LD_INT 34
43919: PUSH
43920: LD_INT 52
43922: PUSH
43923: EMPTY
43924: LIST
43925: LIST
43926: PUSH
43927: EMPTY
43928: LIST
43929: LIST
43930: LIST
43931: PUSH
43932: EMPTY
43933: LIST
43934: LIST
43935: PPUSH
43936: CALL_OW 72
43940: ST_TO_ADDR
// if cranes then
43941: LD_VAR 0 6
43945: IFFALSE 44007
// for j in cranes do
43947: LD_ADDR_VAR 0 3
43951: PUSH
43952: LD_VAR 0 6
43956: PUSH
43957: FOR_IN
43958: IFFALSE 44005
// if not IsInArea ( j , mc_parking [ i ] ) then
43960: LD_VAR 0 3
43964: PPUSH
43965: LD_EXP 126
43969: PUSH
43970: LD_VAR 0 2
43974: ARRAY
43975: PPUSH
43976: CALL_OW 308
43980: NOT
43981: IFFALSE 44003
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43983: LD_VAR 0 3
43987: PPUSH
43988: LD_EXP 126
43992: PUSH
43993: LD_VAR 0 2
43997: ARRAY
43998: PPUSH
43999: CALL_OW 113
44003: GO 43957
44005: POP
44006: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44007: LD_ADDR_EXP 104
44011: PUSH
44012: LD_EXP 104
44016: PPUSH
44017: LD_VAR 0 2
44021: PPUSH
44022: EMPTY
44023: PPUSH
44024: CALL_OW 1
44028: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44029: LD_VAR 0 2
44033: PPUSH
44034: LD_INT 101
44036: PPUSH
44037: CALL 38933 0 2
// continue ;
44041: GO 43855
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44043: LD_ADDR_EXP 108
44047: PUSH
44048: LD_EXP 108
44052: PPUSH
44053: LD_VAR 0 2
44057: PPUSH
44058: EMPTY
44059: PPUSH
44060: CALL_OW 1
44064: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44065: LD_VAR 0 2
44069: PPUSH
44070: LD_INT 103
44072: PPUSH
44073: CALL 38933 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
44077: LD_ADDR_VAR 0 5
44081: PUSH
44082: LD_EXP 102
44086: PUSH
44087: LD_VAR 0 2
44091: ARRAY
44092: PUSH
44093: LD_EXP 131
44097: PUSH
44098: LD_VAR 0 2
44102: ARRAY
44103: UNION
44104: PPUSH
44105: LD_INT 2
44107: PUSH
44108: LD_INT 25
44110: PUSH
44111: LD_INT 2
44113: PUSH
44114: EMPTY
44115: LIST
44116: LIST
44117: PUSH
44118: LD_INT 25
44120: PUSH
44121: LD_INT 16
44123: PUSH
44124: EMPTY
44125: LIST
44126: LIST
44127: PUSH
44128: EMPTY
44129: LIST
44130: LIST
44131: LIST
44132: PUSH
44133: EMPTY
44134: LIST
44135: PPUSH
44136: CALL_OW 72
44140: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
44141: LD_ADDR_VAR 0 6
44145: PUSH
44146: LD_EXP 121
44150: PUSH
44151: LD_VAR 0 2
44155: ARRAY
44156: PPUSH
44157: LD_INT 2
44159: PUSH
44160: LD_INT 34
44162: PUSH
44163: LD_INT 13
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: PUSH
44170: LD_INT 34
44172: PUSH
44173: LD_INT 52
44175: PUSH
44176: EMPTY
44177: LIST
44178: LIST
44179: PUSH
44180: EMPTY
44181: LIST
44182: LIST
44183: LIST
44184: PPUSH
44185: CALL_OW 72
44189: ST_TO_ADDR
// if cranes then
44190: LD_VAR 0 6
44194: IFFALSE 44330
// begin for j in cranes do
44196: LD_ADDR_VAR 0 3
44200: PUSH
44201: LD_VAR 0 6
44205: PUSH
44206: FOR_IN
44207: IFFALSE 44328
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
44209: LD_VAR 0 3
44213: PPUSH
44214: CALL_OW 256
44218: PUSH
44219: LD_INT 500
44221: GREATEREQUAL
44222: PUSH
44223: LD_VAR 0 3
44227: PPUSH
44228: CALL_OW 314
44232: NOT
44233: AND
44234: IFFALSE 44268
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44236: LD_VAR 0 3
44240: PPUSH
44241: LD_EXP 103
44245: PUSH
44246: LD_VAR 0 2
44250: ARRAY
44251: PPUSH
44252: LD_VAR 0 3
44256: PPUSH
44257: CALL_OW 74
44261: PPUSH
44262: CALL_OW 130
44266: GO 44326
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44268: LD_VAR 0 3
44272: PPUSH
44273: CALL_OW 256
44277: PUSH
44278: LD_INT 500
44280: LESS
44281: PUSH
44282: LD_VAR 0 3
44286: PPUSH
44287: LD_EXP 126
44291: PUSH
44292: LD_VAR 0 2
44296: ARRAY
44297: PPUSH
44298: CALL_OW 308
44302: NOT
44303: AND
44304: IFFALSE 44326
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44306: LD_VAR 0 3
44310: PPUSH
44311: LD_EXP 126
44315: PUSH
44316: LD_VAR 0 2
44320: ARRAY
44321: PPUSH
44322: CALL_OW 113
44326: GO 44206
44328: POP
44329: POP
// end ; if not tmp then
44330: LD_VAR 0 5
44334: NOT
44335: IFFALSE 44339
// continue ;
44337: GO 43855
// for j in tmp do
44339: LD_ADDR_VAR 0 3
44343: PUSH
44344: LD_VAR 0 5
44348: PUSH
44349: FOR_IN
44350: IFFALSE 44674
// begin if mc_need_heal [ i ] then
44352: LD_EXP 105
44356: PUSH
44357: LD_VAR 0 2
44361: ARRAY
44362: IFFALSE 44410
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
44364: LD_VAR 0 3
44368: PUSH
44369: LD_EXP 105
44373: PUSH
44374: LD_VAR 0 2
44378: ARRAY
44379: PUSH
44380: LD_INT 1
44382: ARRAY
44383: IN
44384: PUSH
44385: LD_VAR 0 3
44389: PUSH
44390: LD_EXP 105
44394: PUSH
44395: LD_VAR 0 2
44399: ARRAY
44400: PUSH
44401: LD_INT 2
44403: ARRAY
44404: IN
44405: OR
44406: IFFALSE 44410
// continue ;
44408: GO 44349
// if IsInUnit ( j ) then
44410: LD_VAR 0 3
44414: PPUSH
44415: CALL_OW 310
44419: IFFALSE 44430
// ComExitBuilding ( j ) ;
44421: LD_VAR 0 3
44425: PPUSH
44426: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44430: LD_VAR 0 3
44434: PUSH
44435: LD_EXP 104
44439: PUSH
44440: LD_VAR 0 2
44444: ARRAY
44445: IN
44446: NOT
44447: IFFALSE 44505
// begin SetTag ( j , 101 ) ;
44449: LD_VAR 0 3
44453: PPUSH
44454: LD_INT 101
44456: PPUSH
44457: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
44461: LD_ADDR_EXP 104
44465: PUSH
44466: LD_EXP 104
44470: PPUSH
44471: LD_VAR 0 2
44475: PUSH
44476: LD_EXP 104
44480: PUSH
44481: LD_VAR 0 2
44485: ARRAY
44486: PUSH
44487: LD_INT 1
44489: PLUS
44490: PUSH
44491: EMPTY
44492: LIST
44493: LIST
44494: PPUSH
44495: LD_VAR 0 3
44499: PPUSH
44500: CALL 72131 0 3
44504: ST_TO_ADDR
// end ; wait ( 1 ) ;
44505: LD_INT 1
44507: PPUSH
44508: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
44512: LD_ADDR_VAR 0 7
44516: PUSH
44517: LD_EXP 103
44521: PUSH
44522: LD_VAR 0 2
44526: ARRAY
44527: ST_TO_ADDR
// if mc_scan [ i ] then
44528: LD_EXP 125
44532: PUSH
44533: LD_VAR 0 2
44537: ARRAY
44538: IFFALSE 44607
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
44540: LD_ADDR_VAR 0 7
44544: PUSH
44545: LD_EXP 103
44549: PUSH
44550: LD_VAR 0 2
44554: ARRAY
44555: PPUSH
44556: LD_INT 3
44558: PUSH
44559: LD_INT 2
44561: PUSH
44562: LD_INT 30
44564: PUSH
44565: LD_INT 32
44567: PUSH
44568: EMPTY
44569: LIST
44570: LIST
44571: PUSH
44572: LD_INT 30
44574: PUSH
44575: LD_INT 33
44577: PUSH
44578: EMPTY
44579: LIST
44580: LIST
44581: PUSH
44582: LD_INT 30
44584: PUSH
44585: LD_INT 31
44587: PUSH
44588: EMPTY
44589: LIST
44590: LIST
44591: PUSH
44592: EMPTY
44593: LIST
44594: LIST
44595: LIST
44596: LIST
44597: PUSH
44598: EMPTY
44599: LIST
44600: LIST
44601: PPUSH
44602: CALL_OW 72
44606: ST_TO_ADDR
// if not to_repair_tmp then
44607: LD_VAR 0 7
44611: NOT
44612: IFFALSE 44616
// continue ;
44614: GO 44349
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
44616: LD_ADDR_VAR 0 8
44620: PUSH
44621: LD_VAR 0 7
44625: PPUSH
44626: LD_VAR 0 3
44630: PPUSH
44631: CALL_OW 74
44635: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
44636: LD_VAR 0 8
44640: PPUSH
44641: LD_INT 14
44643: PPUSH
44644: CALL 74724 0 2
44648: PUSH
44649: LD_INT 4
44651: ARRAY
44652: PUSH
44653: LD_INT 5
44655: LESS
44656: IFFALSE 44672
// ComRepairBuilding ( j , to_repair ) ;
44658: LD_VAR 0 3
44662: PPUSH
44663: LD_VAR 0 8
44667: PPUSH
44668: CALL_OW 130
// end ;
44672: GO 44349
44674: POP
44675: POP
// end ;
44676: GO 43855
44678: POP
44679: POP
// end ;
44680: LD_VAR 0 1
44684: RET
// export function MC_Heal ; var i , j , tmp ; begin
44685: LD_INT 0
44687: PPUSH
44688: PPUSH
44689: PPUSH
44690: PPUSH
// if not mc_bases then
44691: LD_EXP 102
44695: NOT
44696: IFFALSE 44700
// exit ;
44698: GO 45102
// for i = 1 to mc_bases do
44700: LD_ADDR_VAR 0 2
44704: PUSH
44705: DOUBLE
44706: LD_INT 1
44708: DEC
44709: ST_TO_ADDR
44710: LD_EXP 102
44714: PUSH
44715: FOR_TO
44716: IFFALSE 45100
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
44718: LD_EXP 105
44722: PUSH
44723: LD_VAR 0 2
44727: ARRAY
44728: PUSH
44729: LD_INT 1
44731: ARRAY
44732: NOT
44733: PUSH
44734: LD_EXP 105
44738: PUSH
44739: LD_VAR 0 2
44743: ARRAY
44744: PUSH
44745: LD_INT 2
44747: ARRAY
44748: NOT
44749: AND
44750: IFFALSE 44788
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
44752: LD_ADDR_EXP 106
44756: PUSH
44757: LD_EXP 106
44761: PPUSH
44762: LD_VAR 0 2
44766: PPUSH
44767: EMPTY
44768: PPUSH
44769: CALL_OW 1
44773: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
44774: LD_VAR 0 2
44778: PPUSH
44779: LD_INT 102
44781: PPUSH
44782: CALL 38933 0 2
// continue ;
44786: GO 44715
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
44788: LD_ADDR_VAR 0 4
44792: PUSH
44793: LD_EXP 102
44797: PUSH
44798: LD_VAR 0 2
44802: ARRAY
44803: PPUSH
44804: LD_INT 25
44806: PUSH
44807: LD_INT 4
44809: PUSH
44810: EMPTY
44811: LIST
44812: LIST
44813: PPUSH
44814: CALL_OW 72
44818: ST_TO_ADDR
// if not tmp then
44819: LD_VAR 0 4
44823: NOT
44824: IFFALSE 44828
// continue ;
44826: GO 44715
// if mc_taming [ i ] then
44828: LD_EXP 133
44832: PUSH
44833: LD_VAR 0 2
44837: ARRAY
44838: IFFALSE 44862
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
44840: LD_ADDR_EXP 133
44844: PUSH
44845: LD_EXP 133
44849: PPUSH
44850: LD_VAR 0 2
44854: PPUSH
44855: EMPTY
44856: PPUSH
44857: CALL_OW 1
44861: ST_TO_ADDR
// for j in tmp do
44862: LD_ADDR_VAR 0 3
44866: PUSH
44867: LD_VAR 0 4
44871: PUSH
44872: FOR_IN
44873: IFFALSE 45096
// begin if IsInUnit ( j ) then
44875: LD_VAR 0 3
44879: PPUSH
44880: CALL_OW 310
44884: IFFALSE 44895
// ComExitBuilding ( j ) ;
44886: LD_VAR 0 3
44890: PPUSH
44891: CALL_OW 122
// if not j in mc_healers [ i ] then
44895: LD_VAR 0 3
44899: PUSH
44900: LD_EXP 106
44904: PUSH
44905: LD_VAR 0 2
44909: ARRAY
44910: IN
44911: NOT
44912: IFFALSE 44958
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
44914: LD_ADDR_EXP 106
44918: PUSH
44919: LD_EXP 106
44923: PPUSH
44924: LD_VAR 0 2
44928: PUSH
44929: LD_EXP 106
44933: PUSH
44934: LD_VAR 0 2
44938: ARRAY
44939: PUSH
44940: LD_INT 1
44942: PLUS
44943: PUSH
44944: EMPTY
44945: LIST
44946: LIST
44947: PPUSH
44948: LD_VAR 0 3
44952: PPUSH
44953: CALL 72131 0 3
44957: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
44958: LD_VAR 0 3
44962: PPUSH
44963: CALL_OW 110
44967: PUSH
44968: LD_INT 102
44970: NONEQUAL
44971: IFFALSE 44985
// SetTag ( j , 102 ) ;
44973: LD_VAR 0 3
44977: PPUSH
44978: LD_INT 102
44980: PPUSH
44981: CALL_OW 109
// Wait ( 3 ) ;
44985: LD_INT 3
44987: PPUSH
44988: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
44992: LD_EXP 105
44996: PUSH
44997: LD_VAR 0 2
45001: ARRAY
45002: PUSH
45003: LD_INT 1
45005: ARRAY
45006: IFFALSE 45038
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45008: LD_VAR 0 3
45012: PPUSH
45013: LD_EXP 105
45017: PUSH
45018: LD_VAR 0 2
45022: ARRAY
45023: PUSH
45024: LD_INT 1
45026: ARRAY
45027: PUSH
45028: LD_INT 1
45030: ARRAY
45031: PPUSH
45032: CALL_OW 128
45036: GO 45094
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45038: LD_VAR 0 3
45042: PPUSH
45043: CALL_OW 314
45047: NOT
45048: PUSH
45049: LD_EXP 105
45053: PUSH
45054: LD_VAR 0 2
45058: ARRAY
45059: PUSH
45060: LD_INT 2
45062: ARRAY
45063: AND
45064: IFFALSE 45094
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45066: LD_VAR 0 3
45070: PPUSH
45071: LD_EXP 105
45075: PUSH
45076: LD_VAR 0 2
45080: ARRAY
45081: PUSH
45082: LD_INT 2
45084: ARRAY
45085: PUSH
45086: LD_INT 1
45088: ARRAY
45089: PPUSH
45090: CALL_OW 128
// end ;
45094: GO 44872
45096: POP
45097: POP
// end ;
45098: GO 44715
45100: POP
45101: POP
// end ;
45102: LD_VAR 0 1
45106: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45107: LD_INT 0
45109: PPUSH
45110: PPUSH
45111: PPUSH
45112: PPUSH
45113: PPUSH
// if not mc_bases then
45114: LD_EXP 102
45118: NOT
45119: IFFALSE 45123
// exit ;
45121: GO 46266
// for i = 1 to mc_bases do
45123: LD_ADDR_VAR 0 2
45127: PUSH
45128: DOUBLE
45129: LD_INT 1
45131: DEC
45132: ST_TO_ADDR
45133: LD_EXP 102
45137: PUSH
45138: FOR_TO
45139: IFFALSE 46264
// begin if mc_scan [ i ] then
45141: LD_EXP 125
45145: PUSH
45146: LD_VAR 0 2
45150: ARRAY
45151: IFFALSE 45155
// continue ;
45153: GO 45138
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45155: LD_EXP 107
45159: PUSH
45160: LD_VAR 0 2
45164: ARRAY
45165: NOT
45166: PUSH
45167: LD_EXP 109
45171: PUSH
45172: LD_VAR 0 2
45176: ARRAY
45177: NOT
45178: AND
45179: PUSH
45180: LD_EXP 108
45184: PUSH
45185: LD_VAR 0 2
45189: ARRAY
45190: AND
45191: IFFALSE 45229
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45193: LD_ADDR_EXP 108
45197: PUSH
45198: LD_EXP 108
45202: PPUSH
45203: LD_VAR 0 2
45207: PPUSH
45208: EMPTY
45209: PPUSH
45210: CALL_OW 1
45214: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45215: LD_VAR 0 2
45219: PPUSH
45220: LD_INT 103
45222: PPUSH
45223: CALL 38933 0 2
// continue ;
45227: GO 45138
// end ; if mc_construct_list [ i ] then
45229: LD_EXP 109
45233: PUSH
45234: LD_VAR 0 2
45238: ARRAY
45239: IFFALSE 45459
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45241: LD_ADDR_VAR 0 4
45245: PUSH
45246: LD_EXP 102
45250: PUSH
45251: LD_VAR 0 2
45255: ARRAY
45256: PPUSH
45257: LD_INT 25
45259: PUSH
45260: LD_INT 2
45262: PUSH
45263: EMPTY
45264: LIST
45265: LIST
45266: PPUSH
45267: CALL_OW 72
45271: PUSH
45272: LD_EXP 104
45276: PUSH
45277: LD_VAR 0 2
45281: ARRAY
45282: DIFF
45283: ST_TO_ADDR
// if not tmp then
45284: LD_VAR 0 4
45288: NOT
45289: IFFALSE 45293
// continue ;
45291: GO 45138
// for j in tmp do
45293: LD_ADDR_VAR 0 3
45297: PUSH
45298: LD_VAR 0 4
45302: PUSH
45303: FOR_IN
45304: IFFALSE 45455
// begin if not mc_builders [ i ] then
45306: LD_EXP 108
45310: PUSH
45311: LD_VAR 0 2
45315: ARRAY
45316: NOT
45317: IFFALSE 45375
// begin SetTag ( j , 103 ) ;
45319: LD_VAR 0 3
45323: PPUSH
45324: LD_INT 103
45326: PPUSH
45327: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45331: LD_ADDR_EXP 108
45335: PUSH
45336: LD_EXP 108
45340: PPUSH
45341: LD_VAR 0 2
45345: PUSH
45346: LD_EXP 108
45350: PUSH
45351: LD_VAR 0 2
45355: ARRAY
45356: PUSH
45357: LD_INT 1
45359: PLUS
45360: PUSH
45361: EMPTY
45362: LIST
45363: LIST
45364: PPUSH
45365: LD_VAR 0 3
45369: PPUSH
45370: CALL 72131 0 3
45374: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45375: LD_VAR 0 3
45379: PPUSH
45380: CALL_OW 310
45384: IFFALSE 45395
// ComExitBuilding ( j ) ;
45386: LD_VAR 0 3
45390: PPUSH
45391: CALL_OW 122
// wait ( 3 ) ;
45395: LD_INT 3
45397: PPUSH
45398: CALL_OW 67
// if not mc_construct_list [ i ] then
45402: LD_EXP 109
45406: PUSH
45407: LD_VAR 0 2
45411: ARRAY
45412: NOT
45413: IFFALSE 45417
// break ;
45415: GO 45455
// if not HasTask ( j ) then
45417: LD_VAR 0 3
45421: PPUSH
45422: CALL_OW 314
45426: NOT
45427: IFFALSE 45453
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45429: LD_VAR 0 3
45433: PPUSH
45434: LD_EXP 109
45438: PUSH
45439: LD_VAR 0 2
45443: ARRAY
45444: PUSH
45445: LD_INT 1
45447: ARRAY
45448: PPUSH
45449: CALL 74982 0 2
// end ;
45453: GO 45303
45455: POP
45456: POP
// end else
45457: GO 46262
// if mc_build_list [ i ] then
45459: LD_EXP 107
45463: PUSH
45464: LD_VAR 0 2
45468: ARRAY
45469: IFFALSE 46262
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45471: LD_ADDR_VAR 0 5
45475: PUSH
45476: LD_EXP 102
45480: PUSH
45481: LD_VAR 0 2
45485: ARRAY
45486: PPUSH
45487: LD_INT 2
45489: PUSH
45490: LD_INT 30
45492: PUSH
45493: LD_INT 0
45495: PUSH
45496: EMPTY
45497: LIST
45498: LIST
45499: PUSH
45500: LD_INT 30
45502: PUSH
45503: LD_INT 1
45505: PUSH
45506: EMPTY
45507: LIST
45508: LIST
45509: PUSH
45510: EMPTY
45511: LIST
45512: LIST
45513: LIST
45514: PPUSH
45515: CALL_OW 72
45519: ST_TO_ADDR
// if depot then
45520: LD_VAR 0 5
45524: IFFALSE 45542
// depot := depot [ 1 ] else
45526: LD_ADDR_VAR 0 5
45530: PUSH
45531: LD_VAR 0 5
45535: PUSH
45536: LD_INT 1
45538: ARRAY
45539: ST_TO_ADDR
45540: GO 45550
// depot := 0 ;
45542: LD_ADDR_VAR 0 5
45546: PUSH
45547: LD_INT 0
45549: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
45550: LD_EXP 107
45554: PUSH
45555: LD_VAR 0 2
45559: ARRAY
45560: PUSH
45561: LD_INT 1
45563: ARRAY
45564: PUSH
45565: LD_INT 1
45567: ARRAY
45568: PPUSH
45569: CALL 74812 0 1
45573: PUSH
45574: LD_EXP 102
45578: PUSH
45579: LD_VAR 0 2
45583: ARRAY
45584: PPUSH
45585: LD_INT 2
45587: PUSH
45588: LD_INT 30
45590: PUSH
45591: LD_INT 2
45593: PUSH
45594: EMPTY
45595: LIST
45596: LIST
45597: PUSH
45598: LD_INT 30
45600: PUSH
45601: LD_INT 3
45603: PUSH
45604: EMPTY
45605: LIST
45606: LIST
45607: PUSH
45608: EMPTY
45609: LIST
45610: LIST
45611: LIST
45612: PPUSH
45613: CALL_OW 72
45617: NOT
45618: AND
45619: IFFALSE 45724
// begin for j = 1 to mc_build_list [ i ] do
45621: LD_ADDR_VAR 0 3
45625: PUSH
45626: DOUBLE
45627: LD_INT 1
45629: DEC
45630: ST_TO_ADDR
45631: LD_EXP 107
45635: PUSH
45636: LD_VAR 0 2
45640: ARRAY
45641: PUSH
45642: FOR_TO
45643: IFFALSE 45722
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
45645: LD_EXP 107
45649: PUSH
45650: LD_VAR 0 2
45654: ARRAY
45655: PUSH
45656: LD_VAR 0 3
45660: ARRAY
45661: PUSH
45662: LD_INT 1
45664: ARRAY
45665: PUSH
45666: LD_INT 2
45668: EQUAL
45669: IFFALSE 45720
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
45671: LD_ADDR_EXP 107
45675: PUSH
45676: LD_EXP 107
45680: PPUSH
45681: LD_VAR 0 2
45685: PPUSH
45686: LD_EXP 107
45690: PUSH
45691: LD_VAR 0 2
45695: ARRAY
45696: PPUSH
45697: LD_VAR 0 3
45701: PPUSH
45702: LD_INT 1
45704: PPUSH
45705: LD_INT 0
45707: PPUSH
45708: CALL 71549 0 4
45712: PPUSH
45713: CALL_OW 1
45717: ST_TO_ADDR
// break ;
45718: GO 45722
// end ;
45720: GO 45642
45722: POP
45723: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
45724: LD_EXP 107
45728: PUSH
45729: LD_VAR 0 2
45733: ARRAY
45734: PUSH
45735: LD_INT 1
45737: ARRAY
45738: PUSH
45739: LD_INT 1
45741: ARRAY
45742: PUSH
45743: LD_INT 0
45745: EQUAL
45746: PUSH
45747: LD_VAR 0 5
45751: PUSH
45752: LD_VAR 0 5
45756: PPUSH
45757: LD_EXP 107
45761: PUSH
45762: LD_VAR 0 2
45766: ARRAY
45767: PUSH
45768: LD_INT 1
45770: ARRAY
45771: PUSH
45772: LD_INT 1
45774: ARRAY
45775: PPUSH
45776: LD_EXP 107
45780: PUSH
45781: LD_VAR 0 2
45785: ARRAY
45786: PUSH
45787: LD_INT 1
45789: ARRAY
45790: PUSH
45791: LD_INT 2
45793: ARRAY
45794: PPUSH
45795: LD_EXP 107
45799: PUSH
45800: LD_VAR 0 2
45804: ARRAY
45805: PUSH
45806: LD_INT 1
45808: ARRAY
45809: PUSH
45810: LD_INT 3
45812: ARRAY
45813: PPUSH
45814: LD_EXP 107
45818: PUSH
45819: LD_VAR 0 2
45823: ARRAY
45824: PUSH
45825: LD_INT 1
45827: ARRAY
45828: PUSH
45829: LD_INT 4
45831: ARRAY
45832: PPUSH
45833: CALL 79546 0 5
45837: AND
45838: OR
45839: IFFALSE 46120
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45841: LD_ADDR_VAR 0 4
45845: PUSH
45846: LD_EXP 102
45850: PUSH
45851: LD_VAR 0 2
45855: ARRAY
45856: PPUSH
45857: LD_INT 25
45859: PUSH
45860: LD_INT 2
45862: PUSH
45863: EMPTY
45864: LIST
45865: LIST
45866: PPUSH
45867: CALL_OW 72
45871: PUSH
45872: LD_EXP 104
45876: PUSH
45877: LD_VAR 0 2
45881: ARRAY
45882: DIFF
45883: ST_TO_ADDR
// if not tmp then
45884: LD_VAR 0 4
45888: NOT
45889: IFFALSE 45893
// continue ;
45891: GO 45138
// for j in tmp do
45893: LD_ADDR_VAR 0 3
45897: PUSH
45898: LD_VAR 0 4
45902: PUSH
45903: FOR_IN
45904: IFFALSE 46116
// begin if not mc_builders [ i ] then
45906: LD_EXP 108
45910: PUSH
45911: LD_VAR 0 2
45915: ARRAY
45916: NOT
45917: IFFALSE 45975
// begin SetTag ( j , 103 ) ;
45919: LD_VAR 0 3
45923: PPUSH
45924: LD_INT 103
45926: PPUSH
45927: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45931: LD_ADDR_EXP 108
45935: PUSH
45936: LD_EXP 108
45940: PPUSH
45941: LD_VAR 0 2
45945: PUSH
45946: LD_EXP 108
45950: PUSH
45951: LD_VAR 0 2
45955: ARRAY
45956: PUSH
45957: LD_INT 1
45959: PLUS
45960: PUSH
45961: EMPTY
45962: LIST
45963: LIST
45964: PPUSH
45965: LD_VAR 0 3
45969: PPUSH
45970: CALL 72131 0 3
45974: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45975: LD_VAR 0 3
45979: PPUSH
45980: CALL_OW 310
45984: IFFALSE 45995
// ComExitBuilding ( j ) ;
45986: LD_VAR 0 3
45990: PPUSH
45991: CALL_OW 122
// wait ( 3 ) ;
45995: LD_INT 3
45997: PPUSH
45998: CALL_OW 67
// if not mc_build_list [ i ] then
46002: LD_EXP 107
46006: PUSH
46007: LD_VAR 0 2
46011: ARRAY
46012: NOT
46013: IFFALSE 46017
// break ;
46015: GO 46116
// if not HasTask ( j ) then
46017: LD_VAR 0 3
46021: PPUSH
46022: CALL_OW 314
46026: NOT
46027: IFFALSE 46114
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46029: LD_VAR 0 3
46033: PPUSH
46034: LD_EXP 107
46038: PUSH
46039: LD_VAR 0 2
46043: ARRAY
46044: PUSH
46045: LD_INT 1
46047: ARRAY
46048: PUSH
46049: LD_INT 1
46051: ARRAY
46052: PPUSH
46053: LD_EXP 107
46057: PUSH
46058: LD_VAR 0 2
46062: ARRAY
46063: PUSH
46064: LD_INT 1
46066: ARRAY
46067: PUSH
46068: LD_INT 2
46070: ARRAY
46071: PPUSH
46072: LD_EXP 107
46076: PUSH
46077: LD_VAR 0 2
46081: ARRAY
46082: PUSH
46083: LD_INT 1
46085: ARRAY
46086: PUSH
46087: LD_INT 3
46089: ARRAY
46090: PPUSH
46091: LD_EXP 107
46095: PUSH
46096: LD_VAR 0 2
46100: ARRAY
46101: PUSH
46102: LD_INT 1
46104: ARRAY
46105: PUSH
46106: LD_INT 4
46108: ARRAY
46109: PPUSH
46110: CALL_OW 145
// end ;
46114: GO 45903
46116: POP
46117: POP
// end else
46118: GO 46262
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
46120: LD_EXP 102
46124: PUSH
46125: LD_VAR 0 2
46129: ARRAY
46130: PPUSH
46131: LD_EXP 107
46135: PUSH
46136: LD_VAR 0 2
46140: ARRAY
46141: PUSH
46142: LD_INT 1
46144: ARRAY
46145: PUSH
46146: LD_INT 1
46148: ARRAY
46149: PPUSH
46150: LD_EXP 107
46154: PUSH
46155: LD_VAR 0 2
46159: ARRAY
46160: PUSH
46161: LD_INT 1
46163: ARRAY
46164: PUSH
46165: LD_INT 2
46167: ARRAY
46168: PPUSH
46169: LD_EXP 107
46173: PUSH
46174: LD_VAR 0 2
46178: ARRAY
46179: PUSH
46180: LD_INT 1
46182: ARRAY
46183: PUSH
46184: LD_INT 3
46186: ARRAY
46187: PPUSH
46188: LD_EXP 107
46192: PUSH
46193: LD_VAR 0 2
46197: ARRAY
46198: PUSH
46199: LD_INT 1
46201: ARRAY
46202: PUSH
46203: LD_INT 4
46205: ARRAY
46206: PPUSH
46207: CALL 78882 0 5
46211: NOT
46212: IFFALSE 46262
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46214: LD_ADDR_EXP 107
46218: PUSH
46219: LD_EXP 107
46223: PPUSH
46224: LD_VAR 0 2
46228: PPUSH
46229: LD_EXP 107
46233: PUSH
46234: LD_VAR 0 2
46238: ARRAY
46239: PPUSH
46240: LD_INT 1
46242: PPUSH
46243: LD_INT 1
46245: NEG
46246: PPUSH
46247: LD_INT 0
46249: PPUSH
46250: CALL 71549 0 4
46254: PPUSH
46255: CALL_OW 1
46259: ST_TO_ADDR
// continue ;
46260: GO 45138
// end ; end ; end ;
46262: GO 45138
46264: POP
46265: POP
// end ;
46266: LD_VAR 0 1
46270: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46271: LD_INT 0
46273: PPUSH
46274: PPUSH
46275: PPUSH
46276: PPUSH
46277: PPUSH
46278: PPUSH
// if not mc_bases then
46279: LD_EXP 102
46283: NOT
46284: IFFALSE 46288
// exit ;
46286: GO 46715
// for i = 1 to mc_bases do
46288: LD_ADDR_VAR 0 2
46292: PUSH
46293: DOUBLE
46294: LD_INT 1
46296: DEC
46297: ST_TO_ADDR
46298: LD_EXP 102
46302: PUSH
46303: FOR_TO
46304: IFFALSE 46713
// begin tmp := mc_build_upgrade [ i ] ;
46306: LD_ADDR_VAR 0 4
46310: PUSH
46311: LD_EXP 134
46315: PUSH
46316: LD_VAR 0 2
46320: ARRAY
46321: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46322: LD_ADDR_VAR 0 6
46326: PUSH
46327: LD_EXP 135
46331: PUSH
46332: LD_VAR 0 2
46336: ARRAY
46337: PPUSH
46338: LD_INT 2
46340: PUSH
46341: LD_INT 30
46343: PUSH
46344: LD_INT 6
46346: PUSH
46347: EMPTY
46348: LIST
46349: LIST
46350: PUSH
46351: LD_INT 30
46353: PUSH
46354: LD_INT 7
46356: PUSH
46357: EMPTY
46358: LIST
46359: LIST
46360: PUSH
46361: EMPTY
46362: LIST
46363: LIST
46364: LIST
46365: PPUSH
46366: CALL_OW 72
46370: ST_TO_ADDR
// if not tmp and not lab then
46371: LD_VAR 0 4
46375: NOT
46376: PUSH
46377: LD_VAR 0 6
46381: NOT
46382: AND
46383: IFFALSE 46387
// continue ;
46385: GO 46303
// if tmp then
46387: LD_VAR 0 4
46391: IFFALSE 46511
// for j in tmp do
46393: LD_ADDR_VAR 0 3
46397: PUSH
46398: LD_VAR 0 4
46402: PUSH
46403: FOR_IN
46404: IFFALSE 46509
// begin if UpgradeCost ( j ) then
46406: LD_VAR 0 3
46410: PPUSH
46411: CALL 78542 0 1
46415: IFFALSE 46507
// begin ComUpgrade ( j ) ;
46417: LD_VAR 0 3
46421: PPUSH
46422: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46426: LD_ADDR_EXP 134
46430: PUSH
46431: LD_EXP 134
46435: PPUSH
46436: LD_VAR 0 2
46440: PPUSH
46441: LD_EXP 134
46445: PUSH
46446: LD_VAR 0 2
46450: ARRAY
46451: PUSH
46452: LD_VAR 0 3
46456: DIFF
46457: PPUSH
46458: CALL_OW 1
46462: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46463: LD_ADDR_EXP 109
46467: PUSH
46468: LD_EXP 109
46472: PPUSH
46473: LD_VAR 0 2
46477: PUSH
46478: LD_EXP 109
46482: PUSH
46483: LD_VAR 0 2
46487: ARRAY
46488: PUSH
46489: LD_INT 1
46491: PLUS
46492: PUSH
46493: EMPTY
46494: LIST
46495: LIST
46496: PPUSH
46497: LD_VAR 0 3
46501: PPUSH
46502: CALL 72131 0 3
46506: ST_TO_ADDR
// end ; end ;
46507: GO 46403
46509: POP
46510: POP
// if not lab or not mc_lab_upgrade [ i ] then
46511: LD_VAR 0 6
46515: NOT
46516: PUSH
46517: LD_EXP 136
46521: PUSH
46522: LD_VAR 0 2
46526: ARRAY
46527: NOT
46528: OR
46529: IFFALSE 46533
// continue ;
46531: GO 46303
// for j in lab do
46533: LD_ADDR_VAR 0 3
46537: PUSH
46538: LD_VAR 0 6
46542: PUSH
46543: FOR_IN
46544: IFFALSE 46709
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
46546: LD_VAR 0 3
46550: PPUSH
46551: CALL_OW 266
46555: PUSH
46556: LD_INT 6
46558: PUSH
46559: LD_INT 7
46561: PUSH
46562: EMPTY
46563: LIST
46564: LIST
46565: IN
46566: PUSH
46567: LD_VAR 0 3
46571: PPUSH
46572: CALL_OW 461
46576: PUSH
46577: LD_INT 1
46579: NONEQUAL
46580: AND
46581: IFFALSE 46707
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
46583: LD_VAR 0 3
46587: PPUSH
46588: LD_EXP 136
46592: PUSH
46593: LD_VAR 0 2
46597: ARRAY
46598: PUSH
46599: LD_INT 1
46601: ARRAY
46602: PPUSH
46603: CALL 78747 0 2
46607: IFFALSE 46707
// begin ComCancel ( j ) ;
46609: LD_VAR 0 3
46613: PPUSH
46614: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
46618: LD_VAR 0 3
46622: PPUSH
46623: LD_EXP 136
46627: PUSH
46628: LD_VAR 0 2
46632: ARRAY
46633: PUSH
46634: LD_INT 1
46636: ARRAY
46637: PPUSH
46638: CALL_OW 207
// if not j in mc_construct_list [ i ] then
46642: LD_VAR 0 3
46646: PUSH
46647: LD_EXP 109
46651: PUSH
46652: LD_VAR 0 2
46656: ARRAY
46657: IN
46658: NOT
46659: IFFALSE 46705
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46661: LD_ADDR_EXP 109
46665: PUSH
46666: LD_EXP 109
46670: PPUSH
46671: LD_VAR 0 2
46675: PUSH
46676: LD_EXP 109
46680: PUSH
46681: LD_VAR 0 2
46685: ARRAY
46686: PUSH
46687: LD_INT 1
46689: PLUS
46690: PUSH
46691: EMPTY
46692: LIST
46693: LIST
46694: PPUSH
46695: LD_VAR 0 3
46699: PPUSH
46700: CALL 72131 0 3
46704: ST_TO_ADDR
// break ;
46705: GO 46709
// end ; end ; end ;
46707: GO 46543
46709: POP
46710: POP
// end ;
46711: GO 46303
46713: POP
46714: POP
// end ;
46715: LD_VAR 0 1
46719: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
46720: LD_INT 0
46722: PPUSH
46723: PPUSH
46724: PPUSH
46725: PPUSH
46726: PPUSH
46727: PPUSH
46728: PPUSH
46729: PPUSH
46730: PPUSH
// if not mc_bases then
46731: LD_EXP 102
46735: NOT
46736: IFFALSE 46740
// exit ;
46738: GO 47145
// for i = 1 to mc_bases do
46740: LD_ADDR_VAR 0 2
46744: PUSH
46745: DOUBLE
46746: LD_INT 1
46748: DEC
46749: ST_TO_ADDR
46750: LD_EXP 102
46754: PUSH
46755: FOR_TO
46756: IFFALSE 47143
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
46758: LD_EXP 110
46762: PUSH
46763: LD_VAR 0 2
46767: ARRAY
46768: NOT
46769: PUSH
46770: LD_EXP 102
46774: PUSH
46775: LD_VAR 0 2
46779: ARRAY
46780: PPUSH
46781: LD_INT 30
46783: PUSH
46784: LD_INT 3
46786: PUSH
46787: EMPTY
46788: LIST
46789: LIST
46790: PPUSH
46791: CALL_OW 72
46795: NOT
46796: OR
46797: IFFALSE 46801
// continue ;
46799: GO 46755
// busy := false ;
46801: LD_ADDR_VAR 0 8
46805: PUSH
46806: LD_INT 0
46808: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
46809: LD_ADDR_VAR 0 4
46813: PUSH
46814: LD_EXP 102
46818: PUSH
46819: LD_VAR 0 2
46823: ARRAY
46824: PPUSH
46825: LD_INT 30
46827: PUSH
46828: LD_INT 3
46830: PUSH
46831: EMPTY
46832: LIST
46833: LIST
46834: PPUSH
46835: CALL_OW 72
46839: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
46840: LD_ADDR_VAR 0 6
46844: PUSH
46845: LD_EXP 110
46849: PUSH
46850: LD_VAR 0 2
46854: ARRAY
46855: PPUSH
46856: LD_INT 2
46858: PUSH
46859: LD_INT 30
46861: PUSH
46862: LD_INT 32
46864: PUSH
46865: EMPTY
46866: LIST
46867: LIST
46868: PUSH
46869: LD_INT 30
46871: PUSH
46872: LD_INT 33
46874: PUSH
46875: EMPTY
46876: LIST
46877: LIST
46878: PUSH
46879: EMPTY
46880: LIST
46881: LIST
46882: LIST
46883: PPUSH
46884: CALL_OW 72
46888: ST_TO_ADDR
// if not t then
46889: LD_VAR 0 6
46893: NOT
46894: IFFALSE 46898
// continue ;
46896: GO 46755
// for j in tmp do
46898: LD_ADDR_VAR 0 3
46902: PUSH
46903: LD_VAR 0 4
46907: PUSH
46908: FOR_IN
46909: IFFALSE 46939
// if not BuildingStatus ( j ) = bs_idle then
46911: LD_VAR 0 3
46915: PPUSH
46916: CALL_OW 461
46920: PUSH
46921: LD_INT 2
46923: EQUAL
46924: NOT
46925: IFFALSE 46937
// begin busy := true ;
46927: LD_ADDR_VAR 0 8
46931: PUSH
46932: LD_INT 1
46934: ST_TO_ADDR
// break ;
46935: GO 46939
// end ;
46937: GO 46908
46939: POP
46940: POP
// if busy then
46941: LD_VAR 0 8
46945: IFFALSE 46949
// continue ;
46947: GO 46755
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
46949: LD_ADDR_VAR 0 7
46953: PUSH
46954: LD_VAR 0 6
46958: PPUSH
46959: LD_INT 35
46961: PUSH
46962: LD_INT 0
46964: PUSH
46965: EMPTY
46966: LIST
46967: LIST
46968: PPUSH
46969: CALL_OW 72
46973: ST_TO_ADDR
// if tw then
46974: LD_VAR 0 7
46978: IFFALSE 47055
// begin tw := tw [ 1 ] ;
46980: LD_ADDR_VAR 0 7
46984: PUSH
46985: LD_VAR 0 7
46989: PUSH
46990: LD_INT 1
46992: ARRAY
46993: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
46994: LD_ADDR_VAR 0 9
46998: PUSH
46999: LD_VAR 0 7
47003: PPUSH
47004: LD_EXP 127
47008: PUSH
47009: LD_VAR 0 2
47013: ARRAY
47014: PPUSH
47015: CALL 77101 0 2
47019: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47020: LD_EXP 141
47024: PUSH
47025: LD_VAR 0 2
47029: ARRAY
47030: IFFALSE 47053
// if not weapon in mc_allowed_tower_weapons [ i ] then
47032: LD_VAR 0 9
47036: PUSH
47037: LD_EXP 141
47041: PUSH
47042: LD_VAR 0 2
47046: ARRAY
47047: IN
47048: NOT
47049: IFFALSE 47053
// continue ;
47051: GO 46755
// end else
47053: GO 47118
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47055: LD_ADDR_VAR 0 5
47059: PUSH
47060: LD_EXP 110
47064: PUSH
47065: LD_VAR 0 2
47069: ARRAY
47070: PPUSH
47071: LD_VAR 0 4
47075: PPUSH
47076: CALL 107312 0 2
47080: ST_TO_ADDR
// if not tmp2 then
47081: LD_VAR 0 5
47085: NOT
47086: IFFALSE 47090
// continue ;
47088: GO 46755
// tw := tmp2 [ 1 ] ;
47090: LD_ADDR_VAR 0 7
47094: PUSH
47095: LD_VAR 0 5
47099: PUSH
47100: LD_INT 1
47102: ARRAY
47103: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47104: LD_ADDR_VAR 0 9
47108: PUSH
47109: LD_VAR 0 5
47113: PUSH
47114: LD_INT 2
47116: ARRAY
47117: ST_TO_ADDR
// end ; if not weapon then
47118: LD_VAR 0 9
47122: NOT
47123: IFFALSE 47127
// continue ;
47125: GO 46755
// ComPlaceWeapon ( tw , weapon ) ;
47127: LD_VAR 0 7
47131: PPUSH
47132: LD_VAR 0 9
47136: PPUSH
47137: CALL_OW 148
// end ;
47141: GO 46755
47143: POP
47144: POP
// end ;
47145: LD_VAR 0 1
47149: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
47150: LD_INT 0
47152: PPUSH
47153: PPUSH
47154: PPUSH
47155: PPUSH
47156: PPUSH
47157: PPUSH
// if not mc_bases then
47158: LD_EXP 102
47162: NOT
47163: IFFALSE 47167
// exit ;
47165: GO 47943
// for i = 1 to mc_bases do
47167: LD_ADDR_VAR 0 2
47171: PUSH
47172: DOUBLE
47173: LD_INT 1
47175: DEC
47176: ST_TO_ADDR
47177: LD_EXP 102
47181: PUSH
47182: FOR_TO
47183: IFFALSE 47941
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47185: LD_EXP 115
47189: PUSH
47190: LD_VAR 0 2
47194: ARRAY
47195: NOT
47196: PUSH
47197: LD_EXP 115
47201: PUSH
47202: LD_VAR 0 2
47206: ARRAY
47207: PUSH
47208: LD_EXP 116
47212: PUSH
47213: LD_VAR 0 2
47217: ARRAY
47218: EQUAL
47219: OR
47220: PUSH
47221: LD_EXP 125
47225: PUSH
47226: LD_VAR 0 2
47230: ARRAY
47231: OR
47232: IFFALSE 47236
// continue ;
47234: GO 47182
// if mc_miners [ i ] then
47236: LD_EXP 116
47240: PUSH
47241: LD_VAR 0 2
47245: ARRAY
47246: IFFALSE 47628
// begin for j = mc_miners [ i ] downto 1 do
47248: LD_ADDR_VAR 0 3
47252: PUSH
47253: DOUBLE
47254: LD_EXP 116
47258: PUSH
47259: LD_VAR 0 2
47263: ARRAY
47264: INC
47265: ST_TO_ADDR
47266: LD_INT 1
47268: PUSH
47269: FOR_DOWNTO
47270: IFFALSE 47626
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47272: LD_EXP 116
47276: PUSH
47277: LD_VAR 0 2
47281: ARRAY
47282: PUSH
47283: LD_VAR 0 3
47287: ARRAY
47288: PPUSH
47289: CALL_OW 301
47293: PUSH
47294: LD_EXP 116
47298: PUSH
47299: LD_VAR 0 2
47303: ARRAY
47304: PUSH
47305: LD_VAR 0 3
47309: ARRAY
47310: PPUSH
47311: CALL_OW 257
47315: PUSH
47316: LD_INT 1
47318: NONEQUAL
47319: OR
47320: IFFALSE 47383
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47322: LD_ADDR_VAR 0 5
47326: PUSH
47327: LD_EXP 116
47331: PUSH
47332: LD_VAR 0 2
47336: ARRAY
47337: PUSH
47338: LD_EXP 116
47342: PUSH
47343: LD_VAR 0 2
47347: ARRAY
47348: PUSH
47349: LD_VAR 0 3
47353: ARRAY
47354: DIFF
47355: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47356: LD_ADDR_EXP 116
47360: PUSH
47361: LD_EXP 116
47365: PPUSH
47366: LD_VAR 0 2
47370: PPUSH
47371: LD_VAR 0 5
47375: PPUSH
47376: CALL_OW 1
47380: ST_TO_ADDR
// continue ;
47381: GO 47269
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47383: LD_EXP 116
47387: PUSH
47388: LD_VAR 0 2
47392: ARRAY
47393: PUSH
47394: LD_VAR 0 3
47398: ARRAY
47399: PPUSH
47400: CALL_OW 257
47404: PUSH
47405: LD_INT 1
47407: EQUAL
47408: PUSH
47409: LD_EXP 116
47413: PUSH
47414: LD_VAR 0 2
47418: ARRAY
47419: PUSH
47420: LD_VAR 0 3
47424: ARRAY
47425: PPUSH
47426: CALL_OW 459
47430: NOT
47431: AND
47432: PUSH
47433: LD_EXP 116
47437: PUSH
47438: LD_VAR 0 2
47442: ARRAY
47443: PUSH
47444: LD_VAR 0 3
47448: ARRAY
47449: PPUSH
47450: CALL_OW 314
47454: NOT
47455: AND
47456: IFFALSE 47624
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
47458: LD_EXP 116
47462: PUSH
47463: LD_VAR 0 2
47467: ARRAY
47468: PUSH
47469: LD_VAR 0 3
47473: ARRAY
47474: PPUSH
47475: CALL_OW 310
47479: IFFALSE 47502
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
47481: LD_EXP 116
47485: PUSH
47486: LD_VAR 0 2
47490: ARRAY
47491: PUSH
47492: LD_VAR 0 3
47496: ARRAY
47497: PPUSH
47498: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
47502: LD_EXP 116
47506: PUSH
47507: LD_VAR 0 2
47511: ARRAY
47512: PUSH
47513: LD_VAR 0 3
47517: ARRAY
47518: PPUSH
47519: CALL_OW 314
47523: NOT
47524: IFFALSE 47624
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
47526: LD_EXP 116
47530: PUSH
47531: LD_VAR 0 2
47535: ARRAY
47536: PUSH
47537: LD_VAR 0 3
47541: ARRAY
47542: PPUSH
47543: LD_EXP 115
47547: PUSH
47548: LD_VAR 0 2
47552: ARRAY
47553: PUSH
47554: LD_VAR 0 3
47558: PUSH
47559: LD_EXP 115
47563: PUSH
47564: LD_VAR 0 2
47568: ARRAY
47569: MOD
47570: PUSH
47571: LD_INT 1
47573: PLUS
47574: ARRAY
47575: PUSH
47576: LD_INT 1
47578: ARRAY
47579: PPUSH
47580: LD_EXP 115
47584: PUSH
47585: LD_VAR 0 2
47589: ARRAY
47590: PUSH
47591: LD_VAR 0 3
47595: PUSH
47596: LD_EXP 115
47600: PUSH
47601: LD_VAR 0 2
47605: ARRAY
47606: MOD
47607: PUSH
47608: LD_INT 1
47610: PLUS
47611: ARRAY
47612: PUSH
47613: LD_INT 2
47615: ARRAY
47616: PPUSH
47617: LD_INT 0
47619: PPUSH
47620: CALL_OW 193
// end ; end ;
47624: GO 47269
47626: POP
47627: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
47628: LD_ADDR_VAR 0 5
47632: PUSH
47633: LD_EXP 102
47637: PUSH
47638: LD_VAR 0 2
47642: ARRAY
47643: PPUSH
47644: LD_INT 2
47646: PUSH
47647: LD_INT 30
47649: PUSH
47650: LD_INT 4
47652: PUSH
47653: EMPTY
47654: LIST
47655: LIST
47656: PUSH
47657: LD_INT 30
47659: PUSH
47660: LD_INT 5
47662: PUSH
47663: EMPTY
47664: LIST
47665: LIST
47666: PUSH
47667: LD_INT 30
47669: PUSH
47670: LD_INT 32
47672: PUSH
47673: EMPTY
47674: LIST
47675: LIST
47676: PUSH
47677: EMPTY
47678: LIST
47679: LIST
47680: LIST
47681: LIST
47682: PPUSH
47683: CALL_OW 72
47687: ST_TO_ADDR
// if not tmp then
47688: LD_VAR 0 5
47692: NOT
47693: IFFALSE 47697
// continue ;
47695: GO 47182
// list := [ ] ;
47697: LD_ADDR_VAR 0 6
47701: PUSH
47702: EMPTY
47703: ST_TO_ADDR
// for j in tmp do
47704: LD_ADDR_VAR 0 3
47708: PUSH
47709: LD_VAR 0 5
47713: PUSH
47714: FOR_IN
47715: IFFALSE 47784
// begin for k in UnitsInside ( j ) do
47717: LD_ADDR_VAR 0 4
47721: PUSH
47722: LD_VAR 0 3
47726: PPUSH
47727: CALL_OW 313
47731: PUSH
47732: FOR_IN
47733: IFFALSE 47780
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
47735: LD_VAR 0 4
47739: PPUSH
47740: CALL_OW 257
47744: PUSH
47745: LD_INT 1
47747: EQUAL
47748: PUSH
47749: LD_VAR 0 4
47753: PPUSH
47754: CALL_OW 459
47758: NOT
47759: AND
47760: IFFALSE 47778
// list := list ^ k ;
47762: LD_ADDR_VAR 0 6
47766: PUSH
47767: LD_VAR 0 6
47771: PUSH
47772: LD_VAR 0 4
47776: ADD
47777: ST_TO_ADDR
47778: GO 47732
47780: POP
47781: POP
// end ;
47782: GO 47714
47784: POP
47785: POP
// list := list diff mc_miners [ i ] ;
47786: LD_ADDR_VAR 0 6
47790: PUSH
47791: LD_VAR 0 6
47795: PUSH
47796: LD_EXP 116
47800: PUSH
47801: LD_VAR 0 2
47805: ARRAY
47806: DIFF
47807: ST_TO_ADDR
// if not list then
47808: LD_VAR 0 6
47812: NOT
47813: IFFALSE 47817
// continue ;
47815: GO 47182
// k := mc_mines [ i ] - mc_miners [ i ] ;
47817: LD_ADDR_VAR 0 4
47821: PUSH
47822: LD_EXP 115
47826: PUSH
47827: LD_VAR 0 2
47831: ARRAY
47832: PUSH
47833: LD_EXP 116
47837: PUSH
47838: LD_VAR 0 2
47842: ARRAY
47843: MINUS
47844: ST_TO_ADDR
// if k > list then
47845: LD_VAR 0 4
47849: PUSH
47850: LD_VAR 0 6
47854: GREATER
47855: IFFALSE 47867
// k := list ;
47857: LD_ADDR_VAR 0 4
47861: PUSH
47862: LD_VAR 0 6
47866: ST_TO_ADDR
// for j = 1 to k do
47867: LD_ADDR_VAR 0 3
47871: PUSH
47872: DOUBLE
47873: LD_INT 1
47875: DEC
47876: ST_TO_ADDR
47877: LD_VAR 0 4
47881: PUSH
47882: FOR_TO
47883: IFFALSE 47937
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
47885: LD_ADDR_EXP 116
47889: PUSH
47890: LD_EXP 116
47894: PPUSH
47895: LD_VAR 0 2
47899: PUSH
47900: LD_EXP 116
47904: PUSH
47905: LD_VAR 0 2
47909: ARRAY
47910: PUSH
47911: LD_INT 1
47913: PLUS
47914: PUSH
47915: EMPTY
47916: LIST
47917: LIST
47918: PPUSH
47919: LD_VAR 0 6
47923: PUSH
47924: LD_VAR 0 3
47928: ARRAY
47929: PPUSH
47930: CALL 72131 0 3
47934: ST_TO_ADDR
47935: GO 47882
47937: POP
47938: POP
// end ;
47939: GO 47182
47941: POP
47942: POP
// end ;
47943: LD_VAR 0 1
47947: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
47948: LD_INT 0
47950: PPUSH
47951: PPUSH
47952: PPUSH
47953: PPUSH
47954: PPUSH
47955: PPUSH
47956: PPUSH
47957: PPUSH
47958: PPUSH
47959: PPUSH
// if not mc_bases then
47960: LD_EXP 102
47964: NOT
47965: IFFALSE 47969
// exit ;
47967: GO 49719
// for i = 1 to mc_bases do
47969: LD_ADDR_VAR 0 2
47973: PUSH
47974: DOUBLE
47975: LD_INT 1
47977: DEC
47978: ST_TO_ADDR
47979: LD_EXP 102
47983: PUSH
47984: FOR_TO
47985: IFFALSE 49717
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
47987: LD_EXP 102
47991: PUSH
47992: LD_VAR 0 2
47996: ARRAY
47997: NOT
47998: PUSH
47999: LD_EXP 109
48003: PUSH
48004: LD_VAR 0 2
48008: ARRAY
48009: OR
48010: IFFALSE 48014
// continue ;
48012: GO 47984
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48014: LD_EXP 118
48018: PUSH
48019: LD_VAR 0 2
48023: ARRAY
48024: NOT
48025: PUSH
48026: LD_EXP 119
48030: PUSH
48031: LD_VAR 0 2
48035: ARRAY
48036: AND
48037: IFFALSE 48075
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48039: LD_ADDR_EXP 119
48043: PUSH
48044: LD_EXP 119
48048: PPUSH
48049: LD_VAR 0 2
48053: PPUSH
48054: EMPTY
48055: PPUSH
48056: CALL_OW 1
48060: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48061: LD_VAR 0 2
48065: PPUSH
48066: LD_INT 107
48068: PPUSH
48069: CALL 38933 0 2
// continue ;
48073: GO 47984
// end ; target := [ ] ;
48075: LD_ADDR_VAR 0 6
48079: PUSH
48080: EMPTY
48081: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48082: LD_ADDR_VAR 0 3
48086: PUSH
48087: DOUBLE
48088: LD_EXP 118
48092: PUSH
48093: LD_VAR 0 2
48097: ARRAY
48098: INC
48099: ST_TO_ADDR
48100: LD_INT 1
48102: PUSH
48103: FOR_DOWNTO
48104: IFFALSE 48364
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48106: LD_EXP 118
48110: PUSH
48111: LD_VAR 0 2
48115: ARRAY
48116: PUSH
48117: LD_VAR 0 3
48121: ARRAY
48122: PUSH
48123: LD_INT 2
48125: ARRAY
48126: PPUSH
48127: LD_EXP 118
48131: PUSH
48132: LD_VAR 0 2
48136: ARRAY
48137: PUSH
48138: LD_VAR 0 3
48142: ARRAY
48143: PUSH
48144: LD_INT 3
48146: ARRAY
48147: PPUSH
48148: CALL_OW 488
48152: PUSH
48153: LD_EXP 118
48157: PUSH
48158: LD_VAR 0 2
48162: ARRAY
48163: PUSH
48164: LD_VAR 0 3
48168: ARRAY
48169: PUSH
48170: LD_INT 2
48172: ARRAY
48173: PPUSH
48174: LD_EXP 118
48178: PUSH
48179: LD_VAR 0 2
48183: ARRAY
48184: PUSH
48185: LD_VAR 0 3
48189: ARRAY
48190: PUSH
48191: LD_INT 3
48193: ARRAY
48194: PPUSH
48195: CALL_OW 284
48199: PUSH
48200: LD_INT 0
48202: EQUAL
48203: AND
48204: IFFALSE 48259
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48206: LD_ADDR_VAR 0 5
48210: PUSH
48211: LD_EXP 118
48215: PUSH
48216: LD_VAR 0 2
48220: ARRAY
48221: PPUSH
48222: LD_VAR 0 3
48226: PPUSH
48227: CALL_OW 3
48231: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48232: LD_ADDR_EXP 118
48236: PUSH
48237: LD_EXP 118
48241: PPUSH
48242: LD_VAR 0 2
48246: PPUSH
48247: LD_VAR 0 5
48251: PPUSH
48252: CALL_OW 1
48256: ST_TO_ADDR
// continue ;
48257: GO 48103
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48259: LD_EXP 102
48263: PUSH
48264: LD_VAR 0 2
48268: ARRAY
48269: PUSH
48270: LD_INT 1
48272: ARRAY
48273: PPUSH
48274: CALL_OW 255
48278: PPUSH
48279: LD_EXP 118
48283: PUSH
48284: LD_VAR 0 2
48288: ARRAY
48289: PUSH
48290: LD_VAR 0 3
48294: ARRAY
48295: PUSH
48296: LD_INT 2
48298: ARRAY
48299: PPUSH
48300: LD_EXP 118
48304: PUSH
48305: LD_VAR 0 2
48309: ARRAY
48310: PUSH
48311: LD_VAR 0 3
48315: ARRAY
48316: PUSH
48317: LD_INT 3
48319: ARRAY
48320: PPUSH
48321: LD_INT 30
48323: PPUSH
48324: CALL 73027 0 4
48328: PUSH
48329: LD_INT 4
48331: ARRAY
48332: PUSH
48333: LD_INT 0
48335: EQUAL
48336: IFFALSE 48362
// begin target := mc_crates [ i ] [ j ] ;
48338: LD_ADDR_VAR 0 6
48342: PUSH
48343: LD_EXP 118
48347: PUSH
48348: LD_VAR 0 2
48352: ARRAY
48353: PUSH
48354: LD_VAR 0 3
48358: ARRAY
48359: ST_TO_ADDR
// break ;
48360: GO 48364
// end ; end ;
48362: GO 48103
48364: POP
48365: POP
// if not target then
48366: LD_VAR 0 6
48370: NOT
48371: IFFALSE 48375
// continue ;
48373: GO 47984
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48375: LD_ADDR_VAR 0 7
48379: PUSH
48380: LD_EXP 121
48384: PUSH
48385: LD_VAR 0 2
48389: ARRAY
48390: PPUSH
48391: LD_INT 2
48393: PUSH
48394: LD_INT 3
48396: PUSH
48397: LD_INT 58
48399: PUSH
48400: EMPTY
48401: LIST
48402: PUSH
48403: EMPTY
48404: LIST
48405: LIST
48406: PUSH
48407: LD_INT 61
48409: PUSH
48410: EMPTY
48411: LIST
48412: PUSH
48413: LD_INT 33
48415: PUSH
48416: LD_INT 5
48418: PUSH
48419: EMPTY
48420: LIST
48421: LIST
48422: PUSH
48423: LD_INT 33
48425: PUSH
48426: LD_INT 3
48428: PUSH
48429: EMPTY
48430: LIST
48431: LIST
48432: PUSH
48433: EMPTY
48434: LIST
48435: LIST
48436: LIST
48437: LIST
48438: LIST
48439: PUSH
48440: LD_INT 2
48442: PUSH
48443: LD_INT 34
48445: PUSH
48446: LD_INT 32
48448: PUSH
48449: EMPTY
48450: LIST
48451: LIST
48452: PUSH
48453: LD_INT 34
48455: PUSH
48456: LD_INT 51
48458: PUSH
48459: EMPTY
48460: LIST
48461: LIST
48462: PUSH
48463: LD_INT 34
48465: PUSH
48466: LD_INT 12
48468: PUSH
48469: EMPTY
48470: LIST
48471: LIST
48472: PUSH
48473: EMPTY
48474: LIST
48475: LIST
48476: LIST
48477: LIST
48478: PUSH
48479: EMPTY
48480: LIST
48481: LIST
48482: PPUSH
48483: CALL_OW 72
48487: ST_TO_ADDR
// if not cargo then
48488: LD_VAR 0 7
48492: NOT
48493: IFFALSE 49136
// begin if mc_crates_collector [ i ] < 5 then
48495: LD_EXP 119
48499: PUSH
48500: LD_VAR 0 2
48504: ARRAY
48505: PUSH
48506: LD_INT 5
48508: LESS
48509: IFFALSE 48875
// begin if mc_ape [ i ] then
48511: LD_EXP 131
48515: PUSH
48516: LD_VAR 0 2
48520: ARRAY
48521: IFFALSE 48568
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
48523: LD_ADDR_VAR 0 5
48527: PUSH
48528: LD_EXP 131
48532: PUSH
48533: LD_VAR 0 2
48537: ARRAY
48538: PPUSH
48539: LD_INT 25
48541: PUSH
48542: LD_INT 16
48544: PUSH
48545: EMPTY
48546: LIST
48547: LIST
48548: PUSH
48549: LD_INT 24
48551: PUSH
48552: LD_INT 750
48554: PUSH
48555: EMPTY
48556: LIST
48557: LIST
48558: PUSH
48559: EMPTY
48560: LIST
48561: LIST
48562: PPUSH
48563: CALL_OW 72
48567: ST_TO_ADDR
// if not tmp then
48568: LD_VAR 0 5
48572: NOT
48573: IFFALSE 48620
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
48575: LD_ADDR_VAR 0 5
48579: PUSH
48580: LD_EXP 102
48584: PUSH
48585: LD_VAR 0 2
48589: ARRAY
48590: PPUSH
48591: LD_INT 25
48593: PUSH
48594: LD_INT 2
48596: PUSH
48597: EMPTY
48598: LIST
48599: LIST
48600: PUSH
48601: LD_INT 24
48603: PUSH
48604: LD_INT 750
48606: PUSH
48607: EMPTY
48608: LIST
48609: LIST
48610: PUSH
48611: EMPTY
48612: LIST
48613: LIST
48614: PPUSH
48615: CALL_OW 72
48619: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
48620: LD_EXP 131
48624: PUSH
48625: LD_VAR 0 2
48629: ARRAY
48630: PUSH
48631: LD_EXP 102
48635: PUSH
48636: LD_VAR 0 2
48640: ARRAY
48641: PPUSH
48642: LD_INT 25
48644: PUSH
48645: LD_INT 2
48647: PUSH
48648: EMPTY
48649: LIST
48650: LIST
48651: PUSH
48652: LD_INT 24
48654: PUSH
48655: LD_INT 750
48657: PUSH
48658: EMPTY
48659: LIST
48660: LIST
48661: PUSH
48662: EMPTY
48663: LIST
48664: LIST
48665: PPUSH
48666: CALL_OW 72
48670: AND
48671: PUSH
48672: LD_VAR 0 5
48676: PUSH
48677: LD_INT 5
48679: LESS
48680: AND
48681: IFFALSE 48763
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
48683: LD_ADDR_VAR 0 3
48687: PUSH
48688: LD_EXP 102
48692: PUSH
48693: LD_VAR 0 2
48697: ARRAY
48698: PPUSH
48699: LD_INT 25
48701: PUSH
48702: LD_INT 2
48704: PUSH
48705: EMPTY
48706: LIST
48707: LIST
48708: PUSH
48709: LD_INT 24
48711: PUSH
48712: LD_INT 750
48714: PUSH
48715: EMPTY
48716: LIST
48717: LIST
48718: PUSH
48719: EMPTY
48720: LIST
48721: LIST
48722: PPUSH
48723: CALL_OW 72
48727: PUSH
48728: FOR_IN
48729: IFFALSE 48761
// begin tmp := tmp union j ;
48731: LD_ADDR_VAR 0 5
48735: PUSH
48736: LD_VAR 0 5
48740: PUSH
48741: LD_VAR 0 3
48745: UNION
48746: ST_TO_ADDR
// if tmp >= 5 then
48747: LD_VAR 0 5
48751: PUSH
48752: LD_INT 5
48754: GREATEREQUAL
48755: IFFALSE 48759
// break ;
48757: GO 48761
// end ;
48759: GO 48728
48761: POP
48762: POP
// end ; if not tmp then
48763: LD_VAR 0 5
48767: NOT
48768: IFFALSE 48772
// continue ;
48770: GO 47984
// for j in tmp do
48772: LD_ADDR_VAR 0 3
48776: PUSH
48777: LD_VAR 0 5
48781: PUSH
48782: FOR_IN
48783: IFFALSE 48873
// if not GetTag ( j ) then
48785: LD_VAR 0 3
48789: PPUSH
48790: CALL_OW 110
48794: NOT
48795: IFFALSE 48871
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
48797: LD_ADDR_EXP 119
48801: PUSH
48802: LD_EXP 119
48806: PPUSH
48807: LD_VAR 0 2
48811: PUSH
48812: LD_EXP 119
48816: PUSH
48817: LD_VAR 0 2
48821: ARRAY
48822: PUSH
48823: LD_INT 1
48825: PLUS
48826: PUSH
48827: EMPTY
48828: LIST
48829: LIST
48830: PPUSH
48831: LD_VAR 0 3
48835: PPUSH
48836: CALL 72131 0 3
48840: ST_TO_ADDR
// SetTag ( j , 107 ) ;
48841: LD_VAR 0 3
48845: PPUSH
48846: LD_INT 107
48848: PPUSH
48849: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
48853: LD_EXP 119
48857: PUSH
48858: LD_VAR 0 2
48862: ARRAY
48863: PUSH
48864: LD_INT 5
48866: GREATEREQUAL
48867: IFFALSE 48871
// break ;
48869: GO 48873
// end ;
48871: GO 48782
48873: POP
48874: POP
// end ; if mc_crates_collector [ i ] and target then
48875: LD_EXP 119
48879: PUSH
48880: LD_VAR 0 2
48884: ARRAY
48885: PUSH
48886: LD_VAR 0 6
48890: AND
48891: IFFALSE 49134
// begin if mc_crates_collector [ i ] < target [ 1 ] then
48893: LD_EXP 119
48897: PUSH
48898: LD_VAR 0 2
48902: ARRAY
48903: PUSH
48904: LD_VAR 0 6
48908: PUSH
48909: LD_INT 1
48911: ARRAY
48912: LESS
48913: IFFALSE 48933
// tmp := mc_crates_collector [ i ] else
48915: LD_ADDR_VAR 0 5
48919: PUSH
48920: LD_EXP 119
48924: PUSH
48925: LD_VAR 0 2
48929: ARRAY
48930: ST_TO_ADDR
48931: GO 48947
// tmp := target [ 1 ] ;
48933: LD_ADDR_VAR 0 5
48937: PUSH
48938: LD_VAR 0 6
48942: PUSH
48943: LD_INT 1
48945: ARRAY
48946: ST_TO_ADDR
// k := 0 ;
48947: LD_ADDR_VAR 0 4
48951: PUSH
48952: LD_INT 0
48954: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
48955: LD_ADDR_VAR 0 3
48959: PUSH
48960: LD_EXP 119
48964: PUSH
48965: LD_VAR 0 2
48969: ARRAY
48970: PUSH
48971: FOR_IN
48972: IFFALSE 49132
// begin k := k + 1 ;
48974: LD_ADDR_VAR 0 4
48978: PUSH
48979: LD_VAR 0 4
48983: PUSH
48984: LD_INT 1
48986: PLUS
48987: ST_TO_ADDR
// if k > tmp then
48988: LD_VAR 0 4
48992: PUSH
48993: LD_VAR 0 5
48997: GREATER
48998: IFFALSE 49002
// break ;
49000: GO 49132
// if not GetClass ( j ) in [ 2 , 16 ] then
49002: LD_VAR 0 3
49006: PPUSH
49007: CALL_OW 257
49011: PUSH
49012: LD_INT 2
49014: PUSH
49015: LD_INT 16
49017: PUSH
49018: EMPTY
49019: LIST
49020: LIST
49021: IN
49022: NOT
49023: IFFALSE 49076
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49025: LD_ADDR_EXP 119
49029: PUSH
49030: LD_EXP 119
49034: PPUSH
49035: LD_VAR 0 2
49039: PPUSH
49040: LD_EXP 119
49044: PUSH
49045: LD_VAR 0 2
49049: ARRAY
49050: PUSH
49051: LD_VAR 0 3
49055: DIFF
49056: PPUSH
49057: CALL_OW 1
49061: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49062: LD_VAR 0 3
49066: PPUSH
49067: LD_INT 0
49069: PPUSH
49070: CALL_OW 109
// continue ;
49074: GO 48971
// end ; if IsInUnit ( j ) then
49076: LD_VAR 0 3
49080: PPUSH
49081: CALL_OW 310
49085: IFFALSE 49096
// ComExitBuilding ( j ) ;
49087: LD_VAR 0 3
49091: PPUSH
49092: CALL_OW 122
// wait ( 3 ) ;
49096: LD_INT 3
49098: PPUSH
49099: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49103: LD_VAR 0 3
49107: PPUSH
49108: LD_VAR 0 6
49112: PUSH
49113: LD_INT 2
49115: ARRAY
49116: PPUSH
49117: LD_VAR 0 6
49121: PUSH
49122: LD_INT 3
49124: ARRAY
49125: PPUSH
49126: CALL_OW 117
// end ;
49130: GO 48971
49132: POP
49133: POP
// end ; end else
49134: GO 49715
// begin for j in cargo do
49136: LD_ADDR_VAR 0 3
49140: PUSH
49141: LD_VAR 0 7
49145: PUSH
49146: FOR_IN
49147: IFFALSE 49713
// begin if GetTag ( j ) <> 0 then
49149: LD_VAR 0 3
49153: PPUSH
49154: CALL_OW 110
49158: PUSH
49159: LD_INT 0
49161: NONEQUAL
49162: IFFALSE 49166
// continue ;
49164: GO 49146
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49166: LD_VAR 0 3
49170: PPUSH
49171: CALL_OW 256
49175: PUSH
49176: LD_INT 1000
49178: LESS
49179: PUSH
49180: LD_VAR 0 3
49184: PPUSH
49185: LD_EXP 126
49189: PUSH
49190: LD_VAR 0 2
49194: ARRAY
49195: PPUSH
49196: CALL_OW 308
49200: NOT
49201: AND
49202: IFFALSE 49224
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49204: LD_VAR 0 3
49208: PPUSH
49209: LD_EXP 126
49213: PUSH
49214: LD_VAR 0 2
49218: ARRAY
49219: PPUSH
49220: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49224: LD_VAR 0 3
49228: PPUSH
49229: CALL_OW 256
49233: PUSH
49234: LD_INT 1000
49236: LESS
49237: PUSH
49238: LD_VAR 0 3
49242: PPUSH
49243: LD_EXP 126
49247: PUSH
49248: LD_VAR 0 2
49252: ARRAY
49253: PPUSH
49254: CALL_OW 308
49258: AND
49259: IFFALSE 49263
// continue ;
49261: GO 49146
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49263: LD_VAR 0 3
49267: PPUSH
49268: CALL_OW 262
49272: PUSH
49273: LD_INT 2
49275: EQUAL
49276: PUSH
49277: LD_VAR 0 3
49281: PPUSH
49282: CALL_OW 261
49286: PUSH
49287: LD_INT 15
49289: LESS
49290: AND
49291: IFFALSE 49295
// continue ;
49293: GO 49146
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49295: LD_VAR 0 3
49299: PPUSH
49300: CALL_OW 262
49304: PUSH
49305: LD_INT 1
49307: EQUAL
49308: PUSH
49309: LD_VAR 0 3
49313: PPUSH
49314: CALL_OW 261
49318: PUSH
49319: LD_INT 10
49321: LESS
49322: AND
49323: IFFALSE 49652
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49325: LD_ADDR_VAR 0 8
49329: PUSH
49330: LD_EXP 102
49334: PUSH
49335: LD_VAR 0 2
49339: ARRAY
49340: PPUSH
49341: LD_INT 2
49343: PUSH
49344: LD_INT 30
49346: PUSH
49347: LD_INT 0
49349: PUSH
49350: EMPTY
49351: LIST
49352: LIST
49353: PUSH
49354: LD_INT 30
49356: PUSH
49357: LD_INT 1
49359: PUSH
49360: EMPTY
49361: LIST
49362: LIST
49363: PUSH
49364: EMPTY
49365: LIST
49366: LIST
49367: LIST
49368: PPUSH
49369: CALL_OW 72
49373: ST_TO_ADDR
// if not depot then
49374: LD_VAR 0 8
49378: NOT
49379: IFFALSE 49383
// continue ;
49381: GO 49146
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
49383: LD_VAR 0 3
49387: PPUSH
49388: LD_VAR 0 8
49392: PPUSH
49393: LD_VAR 0 3
49397: PPUSH
49398: CALL_OW 74
49402: PPUSH
49403: CALL_OW 296
49407: PUSH
49408: LD_INT 6
49410: LESS
49411: IFFALSE 49427
// SetFuel ( j , 100 ) else
49413: LD_VAR 0 3
49417: PPUSH
49418: LD_INT 100
49420: PPUSH
49421: CALL_OW 240
49425: GO 49652
// if GetFuel ( j ) = 0 then
49427: LD_VAR 0 3
49431: PPUSH
49432: CALL_OW 261
49436: PUSH
49437: LD_INT 0
49439: EQUAL
49440: IFFALSE 49652
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
49442: LD_ADDR_EXP 121
49446: PUSH
49447: LD_EXP 121
49451: PPUSH
49452: LD_VAR 0 2
49456: PPUSH
49457: LD_EXP 121
49461: PUSH
49462: LD_VAR 0 2
49466: ARRAY
49467: PUSH
49468: LD_VAR 0 3
49472: DIFF
49473: PPUSH
49474: CALL_OW 1
49478: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
49479: LD_VAR 0 3
49483: PPUSH
49484: CALL_OW 263
49488: PUSH
49489: LD_INT 1
49491: EQUAL
49492: IFFALSE 49508
// ComExitVehicle ( IsInUnit ( j ) ) ;
49494: LD_VAR 0 3
49498: PPUSH
49499: CALL_OW 310
49503: PPUSH
49504: CALL_OW 121
// if GetControl ( j ) = control_remote then
49508: LD_VAR 0 3
49512: PPUSH
49513: CALL_OW 263
49517: PUSH
49518: LD_INT 2
49520: EQUAL
49521: IFFALSE 49532
// ComUnlink ( j ) ;
49523: LD_VAR 0 3
49527: PPUSH
49528: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
49532: LD_ADDR_VAR 0 9
49536: PUSH
49537: LD_VAR 0 2
49541: PPUSH
49542: LD_INT 3
49544: PPUSH
49545: CALL 59005 0 2
49549: ST_TO_ADDR
// if fac then
49550: LD_VAR 0 9
49554: IFFALSE 49650
// begin for k in fac do
49556: LD_ADDR_VAR 0 4
49560: PUSH
49561: LD_VAR 0 9
49565: PUSH
49566: FOR_IN
49567: IFFALSE 49648
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
49569: LD_ADDR_VAR 0 10
49573: PUSH
49574: LD_VAR 0 9
49578: PPUSH
49579: LD_VAR 0 3
49583: PPUSH
49584: CALL_OW 265
49588: PPUSH
49589: LD_VAR 0 3
49593: PPUSH
49594: CALL_OW 262
49598: PPUSH
49599: LD_VAR 0 3
49603: PPUSH
49604: CALL_OW 263
49608: PPUSH
49609: LD_VAR 0 3
49613: PPUSH
49614: CALL_OW 264
49618: PPUSH
49619: CALL 69663 0 5
49623: ST_TO_ADDR
// if components then
49624: LD_VAR 0 10
49628: IFFALSE 49646
// begin MC_InsertProduceList ( i , components ) ;
49630: LD_VAR 0 2
49634: PPUSH
49635: LD_VAR 0 10
49639: PPUSH
49640: CALL 58550 0 2
// break ;
49644: GO 49648
// end ; end ;
49646: GO 49566
49648: POP
49649: POP
// end ; continue ;
49650: GO 49146
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
49652: LD_VAR 0 3
49656: PPUSH
49657: LD_INT 1
49659: PPUSH
49660: CALL_OW 289
49664: PUSH
49665: LD_INT 100
49667: LESS
49668: PUSH
49669: LD_VAR 0 3
49673: PPUSH
49674: CALL_OW 314
49678: NOT
49679: AND
49680: IFFALSE 49709
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49682: LD_VAR 0 3
49686: PPUSH
49687: LD_VAR 0 6
49691: PUSH
49692: LD_INT 2
49694: ARRAY
49695: PPUSH
49696: LD_VAR 0 6
49700: PUSH
49701: LD_INT 3
49703: ARRAY
49704: PPUSH
49705: CALL_OW 117
// break ;
49709: GO 49713
// end ;
49711: GO 49146
49713: POP
49714: POP
// end ; end ;
49715: GO 47984
49717: POP
49718: POP
// end ;
49719: LD_VAR 0 1
49723: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
49724: LD_INT 0
49726: PPUSH
49727: PPUSH
49728: PPUSH
49729: PPUSH
// if not mc_bases then
49730: LD_EXP 102
49734: NOT
49735: IFFALSE 49739
// exit ;
49737: GO 49900
// for i = 1 to mc_bases do
49739: LD_ADDR_VAR 0 2
49743: PUSH
49744: DOUBLE
49745: LD_INT 1
49747: DEC
49748: ST_TO_ADDR
49749: LD_EXP 102
49753: PUSH
49754: FOR_TO
49755: IFFALSE 49898
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
49757: LD_ADDR_VAR 0 4
49761: PUSH
49762: LD_EXP 121
49766: PUSH
49767: LD_VAR 0 2
49771: ARRAY
49772: PUSH
49773: LD_EXP 124
49777: PUSH
49778: LD_VAR 0 2
49782: ARRAY
49783: UNION
49784: PPUSH
49785: LD_INT 33
49787: PUSH
49788: LD_INT 2
49790: PUSH
49791: EMPTY
49792: LIST
49793: LIST
49794: PPUSH
49795: CALL_OW 72
49799: ST_TO_ADDR
// if tmp then
49800: LD_VAR 0 4
49804: IFFALSE 49896
// for j in tmp do
49806: LD_ADDR_VAR 0 3
49810: PUSH
49811: LD_VAR 0 4
49815: PUSH
49816: FOR_IN
49817: IFFALSE 49894
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
49819: LD_VAR 0 3
49823: PPUSH
49824: CALL_OW 312
49828: NOT
49829: PUSH
49830: LD_VAR 0 3
49834: PPUSH
49835: CALL_OW 256
49839: PUSH
49840: LD_INT 250
49842: GREATEREQUAL
49843: AND
49844: IFFALSE 49857
// Connect ( j ) else
49846: LD_VAR 0 3
49850: PPUSH
49851: CALL 75064 0 1
49855: GO 49892
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
49857: LD_VAR 0 3
49861: PPUSH
49862: CALL_OW 256
49866: PUSH
49867: LD_INT 250
49869: LESS
49870: PUSH
49871: LD_VAR 0 3
49875: PPUSH
49876: CALL_OW 312
49880: AND
49881: IFFALSE 49892
// ComUnlink ( j ) ;
49883: LD_VAR 0 3
49887: PPUSH
49888: CALL_OW 136
49892: GO 49816
49894: POP
49895: POP
// end ;
49896: GO 49754
49898: POP
49899: POP
// end ;
49900: LD_VAR 0 1
49904: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
49905: LD_INT 0
49907: PPUSH
49908: PPUSH
49909: PPUSH
49910: PPUSH
49911: PPUSH
// if not mc_bases then
49912: LD_EXP 102
49916: NOT
49917: IFFALSE 49921
// exit ;
49919: GO 50366
// for i = 1 to mc_bases do
49921: LD_ADDR_VAR 0 2
49925: PUSH
49926: DOUBLE
49927: LD_INT 1
49929: DEC
49930: ST_TO_ADDR
49931: LD_EXP 102
49935: PUSH
49936: FOR_TO
49937: IFFALSE 50364
// begin if not mc_produce [ i ] then
49939: LD_EXP 123
49943: PUSH
49944: LD_VAR 0 2
49948: ARRAY
49949: NOT
49950: IFFALSE 49954
// continue ;
49952: GO 49936
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49954: LD_ADDR_VAR 0 5
49958: PUSH
49959: LD_EXP 102
49963: PUSH
49964: LD_VAR 0 2
49968: ARRAY
49969: PPUSH
49970: LD_INT 30
49972: PUSH
49973: LD_INT 3
49975: PUSH
49976: EMPTY
49977: LIST
49978: LIST
49979: PPUSH
49980: CALL_OW 72
49984: ST_TO_ADDR
// if not fac then
49985: LD_VAR 0 5
49989: NOT
49990: IFFALSE 49994
// continue ;
49992: GO 49936
// for j in fac do
49994: LD_ADDR_VAR 0 3
49998: PUSH
49999: LD_VAR 0 5
50003: PUSH
50004: FOR_IN
50005: IFFALSE 50360
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50007: LD_VAR 0 3
50011: PPUSH
50012: CALL_OW 461
50016: PUSH
50017: LD_INT 2
50019: NONEQUAL
50020: PUSH
50021: LD_VAR 0 3
50025: PPUSH
50026: LD_INT 15
50028: PPUSH
50029: CALL 74724 0 2
50033: PUSH
50034: LD_INT 4
50036: ARRAY
50037: OR
50038: IFFALSE 50042
// continue ;
50040: GO 50004
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50042: LD_VAR 0 3
50046: PPUSH
50047: LD_EXP 123
50051: PUSH
50052: LD_VAR 0 2
50056: ARRAY
50057: PUSH
50058: LD_INT 1
50060: ARRAY
50061: PUSH
50062: LD_INT 1
50064: ARRAY
50065: PPUSH
50066: LD_EXP 123
50070: PUSH
50071: LD_VAR 0 2
50075: ARRAY
50076: PUSH
50077: LD_INT 1
50079: ARRAY
50080: PUSH
50081: LD_INT 2
50083: ARRAY
50084: PPUSH
50085: LD_EXP 123
50089: PUSH
50090: LD_VAR 0 2
50094: ARRAY
50095: PUSH
50096: LD_INT 1
50098: ARRAY
50099: PUSH
50100: LD_INT 3
50102: ARRAY
50103: PPUSH
50104: LD_EXP 123
50108: PUSH
50109: LD_VAR 0 2
50113: ARRAY
50114: PUSH
50115: LD_INT 1
50117: ARRAY
50118: PUSH
50119: LD_INT 4
50121: ARRAY
50122: PPUSH
50123: CALL_OW 448
50127: PUSH
50128: LD_VAR 0 3
50132: PPUSH
50133: LD_EXP 123
50137: PUSH
50138: LD_VAR 0 2
50142: ARRAY
50143: PUSH
50144: LD_INT 1
50146: ARRAY
50147: PUSH
50148: LD_INT 1
50150: ARRAY
50151: PUSH
50152: LD_EXP 123
50156: PUSH
50157: LD_VAR 0 2
50161: ARRAY
50162: PUSH
50163: LD_INT 1
50165: ARRAY
50166: PUSH
50167: LD_INT 2
50169: ARRAY
50170: PUSH
50171: LD_EXP 123
50175: PUSH
50176: LD_VAR 0 2
50180: ARRAY
50181: PUSH
50182: LD_INT 1
50184: ARRAY
50185: PUSH
50186: LD_INT 3
50188: ARRAY
50189: PUSH
50190: LD_EXP 123
50194: PUSH
50195: LD_VAR 0 2
50199: ARRAY
50200: PUSH
50201: LD_INT 1
50203: ARRAY
50204: PUSH
50205: LD_INT 4
50207: ARRAY
50208: PUSH
50209: EMPTY
50210: LIST
50211: LIST
50212: LIST
50213: LIST
50214: PPUSH
50215: CALL 78395 0 2
50219: AND
50220: IFFALSE 50358
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50222: LD_VAR 0 3
50226: PPUSH
50227: LD_EXP 123
50231: PUSH
50232: LD_VAR 0 2
50236: ARRAY
50237: PUSH
50238: LD_INT 1
50240: ARRAY
50241: PUSH
50242: LD_INT 1
50244: ARRAY
50245: PPUSH
50246: LD_EXP 123
50250: PUSH
50251: LD_VAR 0 2
50255: ARRAY
50256: PUSH
50257: LD_INT 1
50259: ARRAY
50260: PUSH
50261: LD_INT 2
50263: ARRAY
50264: PPUSH
50265: LD_EXP 123
50269: PUSH
50270: LD_VAR 0 2
50274: ARRAY
50275: PUSH
50276: LD_INT 1
50278: ARRAY
50279: PUSH
50280: LD_INT 3
50282: ARRAY
50283: PPUSH
50284: LD_EXP 123
50288: PUSH
50289: LD_VAR 0 2
50293: ARRAY
50294: PUSH
50295: LD_INT 1
50297: ARRAY
50298: PUSH
50299: LD_INT 4
50301: ARRAY
50302: PPUSH
50303: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50307: LD_ADDR_VAR 0 4
50311: PUSH
50312: LD_EXP 123
50316: PUSH
50317: LD_VAR 0 2
50321: ARRAY
50322: PPUSH
50323: LD_INT 1
50325: PPUSH
50326: CALL_OW 3
50330: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50331: LD_ADDR_EXP 123
50335: PUSH
50336: LD_EXP 123
50340: PPUSH
50341: LD_VAR 0 2
50345: PPUSH
50346: LD_VAR 0 4
50350: PPUSH
50351: CALL_OW 1
50355: ST_TO_ADDR
// break ;
50356: GO 50360
// end ; end ;
50358: GO 50004
50360: POP
50361: POP
// end ;
50362: GO 49936
50364: POP
50365: POP
// end ;
50366: LD_VAR 0 1
50370: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
50371: LD_INT 0
50373: PPUSH
50374: PPUSH
50375: PPUSH
// if not mc_bases then
50376: LD_EXP 102
50380: NOT
50381: IFFALSE 50385
// exit ;
50383: GO 50474
// for i = 1 to mc_bases do
50385: LD_ADDR_VAR 0 2
50389: PUSH
50390: DOUBLE
50391: LD_INT 1
50393: DEC
50394: ST_TO_ADDR
50395: LD_EXP 102
50399: PUSH
50400: FOR_TO
50401: IFFALSE 50472
// begin if mc_attack [ i ] then
50403: LD_EXP 122
50407: PUSH
50408: LD_VAR 0 2
50412: ARRAY
50413: IFFALSE 50470
// begin tmp := mc_attack [ i ] [ 1 ] ;
50415: LD_ADDR_VAR 0 3
50419: PUSH
50420: LD_EXP 122
50424: PUSH
50425: LD_VAR 0 2
50429: ARRAY
50430: PUSH
50431: LD_INT 1
50433: ARRAY
50434: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50435: LD_ADDR_EXP 122
50439: PUSH
50440: LD_EXP 122
50444: PPUSH
50445: LD_VAR 0 2
50449: PPUSH
50450: EMPTY
50451: PPUSH
50452: CALL_OW 1
50456: ST_TO_ADDR
// Attack ( tmp ) ;
50457: LD_VAR 0 3
50461: PPUSH
50462: CALL 100585 0 1
// exit ;
50466: POP
50467: POP
50468: GO 50474
// end ; end ;
50470: GO 50400
50472: POP
50473: POP
// end ;
50474: LD_VAR 0 1
50478: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
50479: LD_INT 0
50481: PPUSH
50482: PPUSH
50483: PPUSH
50484: PPUSH
50485: PPUSH
50486: PPUSH
50487: PPUSH
// if not mc_bases then
50488: LD_EXP 102
50492: NOT
50493: IFFALSE 50497
// exit ;
50495: GO 51079
// for i = 1 to mc_bases do
50497: LD_ADDR_VAR 0 2
50501: PUSH
50502: DOUBLE
50503: LD_INT 1
50505: DEC
50506: ST_TO_ADDR
50507: LD_EXP 102
50511: PUSH
50512: FOR_TO
50513: IFFALSE 51077
// begin if not mc_bases [ i ] then
50515: LD_EXP 102
50519: PUSH
50520: LD_VAR 0 2
50524: ARRAY
50525: NOT
50526: IFFALSE 50530
// continue ;
50528: GO 50512
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
50530: LD_ADDR_VAR 0 7
50534: PUSH
50535: LD_EXP 102
50539: PUSH
50540: LD_VAR 0 2
50544: ARRAY
50545: PUSH
50546: LD_INT 1
50548: ARRAY
50549: PPUSH
50550: CALL 68967 0 1
50554: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
50555: LD_ADDR_EXP 125
50559: PUSH
50560: LD_EXP 125
50564: PPUSH
50565: LD_VAR 0 2
50569: PPUSH
50570: LD_EXP 102
50574: PUSH
50575: LD_VAR 0 2
50579: ARRAY
50580: PUSH
50581: LD_INT 1
50583: ARRAY
50584: PPUSH
50585: CALL_OW 255
50589: PPUSH
50590: LD_EXP 127
50594: PUSH
50595: LD_VAR 0 2
50599: ARRAY
50600: PPUSH
50601: CALL 66521 0 2
50605: PPUSH
50606: CALL_OW 1
50610: ST_TO_ADDR
// if not mc_scan [ i ] then
50611: LD_EXP 125
50615: PUSH
50616: LD_VAR 0 2
50620: ARRAY
50621: NOT
50622: IFFALSE 50777
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50624: LD_ADDR_VAR 0 4
50628: PUSH
50629: LD_EXP 102
50633: PUSH
50634: LD_VAR 0 2
50638: ARRAY
50639: PPUSH
50640: LD_INT 2
50642: PUSH
50643: LD_INT 25
50645: PUSH
50646: LD_INT 5
50648: PUSH
50649: EMPTY
50650: LIST
50651: LIST
50652: PUSH
50653: LD_INT 25
50655: PUSH
50656: LD_INT 8
50658: PUSH
50659: EMPTY
50660: LIST
50661: LIST
50662: PUSH
50663: LD_INT 25
50665: PUSH
50666: LD_INT 9
50668: PUSH
50669: EMPTY
50670: LIST
50671: LIST
50672: PUSH
50673: EMPTY
50674: LIST
50675: LIST
50676: LIST
50677: LIST
50678: PPUSH
50679: CALL_OW 72
50683: ST_TO_ADDR
// if not tmp then
50684: LD_VAR 0 4
50688: NOT
50689: IFFALSE 50693
// continue ;
50691: GO 50512
// for j in tmp do
50693: LD_ADDR_VAR 0 3
50697: PUSH
50698: LD_VAR 0 4
50702: PUSH
50703: FOR_IN
50704: IFFALSE 50775
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
50706: LD_VAR 0 3
50710: PPUSH
50711: CALL_OW 310
50715: PPUSH
50716: CALL_OW 266
50720: PUSH
50721: LD_INT 5
50723: EQUAL
50724: PUSH
50725: LD_VAR 0 3
50729: PPUSH
50730: CALL_OW 257
50734: PUSH
50735: LD_INT 1
50737: EQUAL
50738: AND
50739: PUSH
50740: LD_VAR 0 3
50744: PPUSH
50745: CALL_OW 459
50749: NOT
50750: AND
50751: PUSH
50752: LD_VAR 0 7
50756: AND
50757: IFFALSE 50773
// ComChangeProfession ( j , class ) ;
50759: LD_VAR 0 3
50763: PPUSH
50764: LD_VAR 0 7
50768: PPUSH
50769: CALL_OW 123
50773: GO 50703
50775: POP
50776: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
50777: LD_EXP 125
50781: PUSH
50782: LD_VAR 0 2
50786: ARRAY
50787: PUSH
50788: LD_EXP 124
50792: PUSH
50793: LD_VAR 0 2
50797: ARRAY
50798: NOT
50799: AND
50800: PUSH
50801: LD_EXP 102
50805: PUSH
50806: LD_VAR 0 2
50810: ARRAY
50811: PPUSH
50812: LD_INT 30
50814: PUSH
50815: LD_INT 32
50817: PUSH
50818: EMPTY
50819: LIST
50820: LIST
50821: PPUSH
50822: CALL_OW 72
50826: NOT
50827: AND
50828: PUSH
50829: LD_EXP 102
50833: PUSH
50834: LD_VAR 0 2
50838: ARRAY
50839: PPUSH
50840: LD_INT 2
50842: PUSH
50843: LD_INT 30
50845: PUSH
50846: LD_INT 4
50848: PUSH
50849: EMPTY
50850: LIST
50851: LIST
50852: PUSH
50853: LD_INT 30
50855: PUSH
50856: LD_INT 5
50858: PUSH
50859: EMPTY
50860: LIST
50861: LIST
50862: PUSH
50863: EMPTY
50864: LIST
50865: LIST
50866: LIST
50867: PPUSH
50868: CALL_OW 72
50872: NOT
50873: AND
50874: IFFALSE 51006
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50876: LD_ADDR_VAR 0 4
50880: PUSH
50881: LD_EXP 102
50885: PUSH
50886: LD_VAR 0 2
50890: ARRAY
50891: PPUSH
50892: LD_INT 2
50894: PUSH
50895: LD_INT 25
50897: PUSH
50898: LD_INT 1
50900: PUSH
50901: EMPTY
50902: LIST
50903: LIST
50904: PUSH
50905: LD_INT 25
50907: PUSH
50908: LD_INT 5
50910: PUSH
50911: EMPTY
50912: LIST
50913: LIST
50914: PUSH
50915: LD_INT 25
50917: PUSH
50918: LD_INT 8
50920: PUSH
50921: EMPTY
50922: LIST
50923: LIST
50924: PUSH
50925: LD_INT 25
50927: PUSH
50928: LD_INT 9
50930: PUSH
50931: EMPTY
50932: LIST
50933: LIST
50934: PUSH
50935: EMPTY
50936: LIST
50937: LIST
50938: LIST
50939: LIST
50940: LIST
50941: PPUSH
50942: CALL_OW 72
50946: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
50947: LD_ADDR_VAR 0 4
50951: PUSH
50952: LD_VAR 0 4
50956: PUSH
50957: LD_VAR 0 4
50961: PPUSH
50962: LD_INT 18
50964: PPUSH
50965: CALL 105401 0 2
50969: DIFF
50970: ST_TO_ADDR
// if tmp then
50971: LD_VAR 0 4
50975: IFFALSE 51006
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
50977: LD_VAR 0 2
50981: PPUSH
50982: LD_VAR 0 4
50986: PPUSH
50987: LD_EXP 127
50991: PUSH
50992: LD_VAR 0 2
50996: ARRAY
50997: PPUSH
50998: CALL 66556 0 3
// exit ;
51002: POP
51003: POP
51004: GO 51079
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
51006: LD_EXP 125
51010: PUSH
51011: LD_VAR 0 2
51015: ARRAY
51016: PUSH
51017: LD_EXP 124
51021: PUSH
51022: LD_VAR 0 2
51026: ARRAY
51027: AND
51028: IFFALSE 51075
// begin tmp := mc_defender [ i ] ;
51030: LD_ADDR_VAR 0 4
51034: PUSH
51035: LD_EXP 124
51039: PUSH
51040: LD_VAR 0 2
51044: ARRAY
51045: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
51046: LD_VAR 0 2
51050: PPUSH
51051: LD_VAR 0 4
51055: PPUSH
51056: LD_EXP 125
51060: PUSH
51061: LD_VAR 0 2
51065: ARRAY
51066: PPUSH
51067: CALL 67117 0 3
// exit ;
51071: POP
51072: POP
51073: GO 51079
// end ; end ;
51075: GO 50512
51077: POP
51078: POP
// end ;
51079: LD_VAR 0 1
51083: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
51084: LD_INT 0
51086: PPUSH
51087: PPUSH
51088: PPUSH
51089: PPUSH
51090: PPUSH
51091: PPUSH
51092: PPUSH
51093: PPUSH
51094: PPUSH
51095: PPUSH
51096: PPUSH
// if not mc_bases then
51097: LD_EXP 102
51101: NOT
51102: IFFALSE 51106
// exit ;
51104: GO 52193
// for i = 1 to mc_bases do
51106: LD_ADDR_VAR 0 2
51110: PUSH
51111: DOUBLE
51112: LD_INT 1
51114: DEC
51115: ST_TO_ADDR
51116: LD_EXP 102
51120: PUSH
51121: FOR_TO
51122: IFFALSE 52191
// begin tmp := mc_lab [ i ] ;
51124: LD_ADDR_VAR 0 6
51128: PUSH
51129: LD_EXP 135
51133: PUSH
51134: LD_VAR 0 2
51138: ARRAY
51139: ST_TO_ADDR
// if not tmp then
51140: LD_VAR 0 6
51144: NOT
51145: IFFALSE 51149
// continue ;
51147: GO 51121
// idle_lab := 0 ;
51149: LD_ADDR_VAR 0 11
51153: PUSH
51154: LD_INT 0
51156: ST_TO_ADDR
// for j in tmp do
51157: LD_ADDR_VAR 0 3
51161: PUSH
51162: LD_VAR 0 6
51166: PUSH
51167: FOR_IN
51168: IFFALSE 52187
// begin researching := false ;
51170: LD_ADDR_VAR 0 10
51174: PUSH
51175: LD_INT 0
51177: ST_TO_ADDR
// side := GetSide ( j ) ;
51178: LD_ADDR_VAR 0 4
51182: PUSH
51183: LD_VAR 0 3
51187: PPUSH
51188: CALL_OW 255
51192: ST_TO_ADDR
// if not mc_tech [ side ] then
51193: LD_EXP 129
51197: PUSH
51198: LD_VAR 0 4
51202: ARRAY
51203: NOT
51204: IFFALSE 51208
// continue ;
51206: GO 51167
// if BuildingStatus ( j ) = bs_idle then
51208: LD_VAR 0 3
51212: PPUSH
51213: CALL_OW 461
51217: PUSH
51218: LD_INT 2
51220: EQUAL
51221: IFFALSE 51409
// begin if idle_lab and UnitsInside ( j ) < 6 then
51223: LD_VAR 0 11
51227: PUSH
51228: LD_VAR 0 3
51232: PPUSH
51233: CALL_OW 313
51237: PUSH
51238: LD_INT 6
51240: LESS
51241: AND
51242: IFFALSE 51313
// begin tmp2 := UnitsInside ( idle_lab ) ;
51244: LD_ADDR_VAR 0 9
51248: PUSH
51249: LD_VAR 0 11
51253: PPUSH
51254: CALL_OW 313
51258: ST_TO_ADDR
// if tmp2 then
51259: LD_VAR 0 9
51263: IFFALSE 51305
// for x in tmp2 do
51265: LD_ADDR_VAR 0 7
51269: PUSH
51270: LD_VAR 0 9
51274: PUSH
51275: FOR_IN
51276: IFFALSE 51303
// begin ComExitBuilding ( x ) ;
51278: LD_VAR 0 7
51282: PPUSH
51283: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51287: LD_VAR 0 7
51291: PPUSH
51292: LD_VAR 0 3
51296: PPUSH
51297: CALL_OW 180
// end ;
51301: GO 51275
51303: POP
51304: POP
// idle_lab := 0 ;
51305: LD_ADDR_VAR 0 11
51309: PUSH
51310: LD_INT 0
51312: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
51313: LD_ADDR_VAR 0 5
51317: PUSH
51318: LD_EXP 129
51322: PUSH
51323: LD_VAR 0 4
51327: ARRAY
51328: PUSH
51329: FOR_IN
51330: IFFALSE 51390
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
51332: LD_VAR 0 3
51336: PPUSH
51337: LD_VAR 0 5
51341: PPUSH
51342: CALL_OW 430
51346: PUSH
51347: LD_VAR 0 4
51351: PPUSH
51352: LD_VAR 0 5
51356: PPUSH
51357: CALL 65626 0 2
51361: AND
51362: IFFALSE 51388
// begin researching := true ;
51364: LD_ADDR_VAR 0 10
51368: PUSH
51369: LD_INT 1
51371: ST_TO_ADDR
// ComResearch ( j , t ) ;
51372: LD_VAR 0 3
51376: PPUSH
51377: LD_VAR 0 5
51381: PPUSH
51382: CALL_OW 124
// break ;
51386: GO 51390
// end ;
51388: GO 51329
51390: POP
51391: POP
// if not researching then
51392: LD_VAR 0 10
51396: NOT
51397: IFFALSE 51409
// idle_lab := j ;
51399: LD_ADDR_VAR 0 11
51403: PUSH
51404: LD_VAR 0 3
51408: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
51409: LD_VAR 0 3
51413: PPUSH
51414: CALL_OW 461
51418: PUSH
51419: LD_INT 10
51421: EQUAL
51422: IFFALSE 52010
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
51424: LD_EXP 131
51428: PUSH
51429: LD_VAR 0 2
51433: ARRAY
51434: NOT
51435: PUSH
51436: LD_EXP 132
51440: PUSH
51441: LD_VAR 0 2
51445: ARRAY
51446: NOT
51447: AND
51448: PUSH
51449: LD_EXP 129
51453: PUSH
51454: LD_VAR 0 4
51458: ARRAY
51459: PUSH
51460: LD_INT 1
51462: GREATER
51463: AND
51464: IFFALSE 51595
// begin ComCancel ( j ) ;
51466: LD_VAR 0 3
51470: PPUSH
51471: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
51475: LD_ADDR_EXP 129
51479: PUSH
51480: LD_EXP 129
51484: PPUSH
51485: LD_VAR 0 4
51489: PPUSH
51490: LD_EXP 129
51494: PUSH
51495: LD_VAR 0 4
51499: ARRAY
51500: PPUSH
51501: LD_EXP 129
51505: PUSH
51506: LD_VAR 0 4
51510: ARRAY
51511: PUSH
51512: LD_INT 1
51514: MINUS
51515: PPUSH
51516: LD_EXP 129
51520: PUSH
51521: LD_VAR 0 4
51525: ARRAY
51526: PPUSH
51527: LD_INT 0
51529: PPUSH
51530: CALL 71549 0 4
51534: PPUSH
51535: CALL_OW 1
51539: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
51540: LD_ADDR_EXP 129
51544: PUSH
51545: LD_EXP 129
51549: PPUSH
51550: LD_VAR 0 4
51554: PPUSH
51555: LD_EXP 129
51559: PUSH
51560: LD_VAR 0 4
51564: ARRAY
51565: PPUSH
51566: LD_EXP 129
51570: PUSH
51571: LD_VAR 0 4
51575: ARRAY
51576: PPUSH
51577: LD_INT 1
51579: PPUSH
51580: LD_INT 0
51582: PPUSH
51583: CALL 71549 0 4
51587: PPUSH
51588: CALL_OW 1
51592: ST_TO_ADDR
// continue ;
51593: GO 51167
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
51595: LD_EXP 131
51599: PUSH
51600: LD_VAR 0 2
51604: ARRAY
51605: PUSH
51606: LD_EXP 132
51610: PUSH
51611: LD_VAR 0 2
51615: ARRAY
51616: NOT
51617: AND
51618: IFFALSE 51745
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
51620: LD_ADDR_EXP 132
51624: PUSH
51625: LD_EXP 132
51629: PPUSH
51630: LD_VAR 0 2
51634: PUSH
51635: LD_EXP 132
51639: PUSH
51640: LD_VAR 0 2
51644: ARRAY
51645: PUSH
51646: LD_INT 1
51648: PLUS
51649: PUSH
51650: EMPTY
51651: LIST
51652: LIST
51653: PPUSH
51654: LD_EXP 131
51658: PUSH
51659: LD_VAR 0 2
51663: ARRAY
51664: PUSH
51665: LD_INT 1
51667: ARRAY
51668: PPUSH
51669: CALL 72131 0 3
51673: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
51674: LD_EXP 131
51678: PUSH
51679: LD_VAR 0 2
51683: ARRAY
51684: PUSH
51685: LD_INT 1
51687: ARRAY
51688: PPUSH
51689: LD_INT 112
51691: PPUSH
51692: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
51696: LD_ADDR_VAR 0 9
51700: PUSH
51701: LD_EXP 131
51705: PUSH
51706: LD_VAR 0 2
51710: ARRAY
51711: PPUSH
51712: LD_INT 1
51714: PPUSH
51715: CALL_OW 3
51719: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
51720: LD_ADDR_EXP 131
51724: PUSH
51725: LD_EXP 131
51729: PPUSH
51730: LD_VAR 0 2
51734: PPUSH
51735: LD_VAR 0 9
51739: PPUSH
51740: CALL_OW 1
51744: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
51745: LD_EXP 131
51749: PUSH
51750: LD_VAR 0 2
51754: ARRAY
51755: PUSH
51756: LD_EXP 132
51760: PUSH
51761: LD_VAR 0 2
51765: ARRAY
51766: AND
51767: PUSH
51768: LD_EXP 132
51772: PUSH
51773: LD_VAR 0 2
51777: ARRAY
51778: PUSH
51779: LD_INT 1
51781: ARRAY
51782: PPUSH
51783: CALL_OW 310
51787: NOT
51788: AND
51789: PUSH
51790: LD_VAR 0 3
51794: PPUSH
51795: CALL_OW 313
51799: PUSH
51800: LD_INT 6
51802: EQUAL
51803: AND
51804: IFFALSE 51860
// begin tmp2 := UnitsInside ( j ) ;
51806: LD_ADDR_VAR 0 9
51810: PUSH
51811: LD_VAR 0 3
51815: PPUSH
51816: CALL_OW 313
51820: ST_TO_ADDR
// if tmp2 = 6 then
51821: LD_VAR 0 9
51825: PUSH
51826: LD_INT 6
51828: EQUAL
51829: IFFALSE 51860
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
51831: LD_VAR 0 9
51835: PUSH
51836: LD_INT 1
51838: ARRAY
51839: PPUSH
51840: LD_INT 112
51842: PPUSH
51843: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
51847: LD_VAR 0 9
51851: PUSH
51852: LD_INT 1
51854: ARRAY
51855: PPUSH
51856: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
51860: LD_EXP 132
51864: PUSH
51865: LD_VAR 0 2
51869: ARRAY
51870: PUSH
51871: LD_EXP 132
51875: PUSH
51876: LD_VAR 0 2
51880: ARRAY
51881: PUSH
51882: LD_INT 1
51884: ARRAY
51885: PPUSH
51886: CALL_OW 314
51890: NOT
51891: AND
51892: PUSH
51893: LD_EXP 132
51897: PUSH
51898: LD_VAR 0 2
51902: ARRAY
51903: PUSH
51904: LD_INT 1
51906: ARRAY
51907: PPUSH
51908: CALL_OW 310
51912: NOT
51913: AND
51914: IFFALSE 51940
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
51916: LD_EXP 132
51920: PUSH
51921: LD_VAR 0 2
51925: ARRAY
51926: PUSH
51927: LD_INT 1
51929: ARRAY
51930: PPUSH
51931: LD_VAR 0 3
51935: PPUSH
51936: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
51940: LD_EXP 132
51944: PUSH
51945: LD_VAR 0 2
51949: ARRAY
51950: PUSH
51951: LD_INT 1
51953: ARRAY
51954: PPUSH
51955: CALL_OW 310
51959: PUSH
51960: LD_EXP 132
51964: PUSH
51965: LD_VAR 0 2
51969: ARRAY
51970: PUSH
51971: LD_INT 1
51973: ARRAY
51974: PPUSH
51975: CALL_OW 310
51979: PPUSH
51980: CALL_OW 461
51984: PUSH
51985: LD_INT 3
51987: NONEQUAL
51988: AND
51989: IFFALSE 52010
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
51991: LD_EXP 132
51995: PUSH
51996: LD_VAR 0 2
52000: ARRAY
52001: PUSH
52002: LD_INT 1
52004: ARRAY
52005: PPUSH
52006: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52010: LD_VAR 0 3
52014: PPUSH
52015: CALL_OW 461
52019: PUSH
52020: LD_INT 6
52022: EQUAL
52023: PUSH
52024: LD_VAR 0 6
52028: PUSH
52029: LD_INT 1
52031: GREATER
52032: AND
52033: IFFALSE 52185
// begin sci := [ ] ;
52035: LD_ADDR_VAR 0 8
52039: PUSH
52040: EMPTY
52041: ST_TO_ADDR
// for x in ( tmp diff j ) do
52042: LD_ADDR_VAR 0 7
52046: PUSH
52047: LD_VAR 0 6
52051: PUSH
52052: LD_VAR 0 3
52056: DIFF
52057: PUSH
52058: FOR_IN
52059: IFFALSE 52111
// begin if sci = 6 then
52061: LD_VAR 0 8
52065: PUSH
52066: LD_INT 6
52068: EQUAL
52069: IFFALSE 52073
// break ;
52071: GO 52111
// if BuildingStatus ( x ) = bs_idle then
52073: LD_VAR 0 7
52077: PPUSH
52078: CALL_OW 461
52082: PUSH
52083: LD_INT 2
52085: EQUAL
52086: IFFALSE 52109
// sci := sci ^ UnitsInside ( x ) ;
52088: LD_ADDR_VAR 0 8
52092: PUSH
52093: LD_VAR 0 8
52097: PUSH
52098: LD_VAR 0 7
52102: PPUSH
52103: CALL_OW 313
52107: ADD
52108: ST_TO_ADDR
// end ;
52109: GO 52058
52111: POP
52112: POP
// if not sci then
52113: LD_VAR 0 8
52117: NOT
52118: IFFALSE 52122
// continue ;
52120: GO 51167
// for x in sci do
52122: LD_ADDR_VAR 0 7
52126: PUSH
52127: LD_VAR 0 8
52131: PUSH
52132: FOR_IN
52133: IFFALSE 52183
// if IsInUnit ( x ) and not HasTask ( x ) then
52135: LD_VAR 0 7
52139: PPUSH
52140: CALL_OW 310
52144: PUSH
52145: LD_VAR 0 7
52149: PPUSH
52150: CALL_OW 314
52154: NOT
52155: AND
52156: IFFALSE 52181
// begin ComExitBuilding ( x ) ;
52158: LD_VAR 0 7
52162: PPUSH
52163: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52167: LD_VAR 0 7
52171: PPUSH
52172: LD_VAR 0 3
52176: PPUSH
52177: CALL_OW 180
// end ;
52181: GO 52132
52183: POP
52184: POP
// end ; end ;
52185: GO 51167
52187: POP
52188: POP
// end ;
52189: GO 51121
52191: POP
52192: POP
// end ;
52193: LD_VAR 0 1
52197: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
52198: LD_INT 0
52200: PPUSH
52201: PPUSH
// if not mc_bases then
52202: LD_EXP 102
52206: NOT
52207: IFFALSE 52211
// exit ;
52209: GO 52292
// for i = 1 to mc_bases do
52211: LD_ADDR_VAR 0 2
52215: PUSH
52216: DOUBLE
52217: LD_INT 1
52219: DEC
52220: ST_TO_ADDR
52221: LD_EXP 102
52225: PUSH
52226: FOR_TO
52227: IFFALSE 52290
// if mc_mines [ i ] and mc_miners [ i ] then
52229: LD_EXP 115
52233: PUSH
52234: LD_VAR 0 2
52238: ARRAY
52239: PUSH
52240: LD_EXP 116
52244: PUSH
52245: LD_VAR 0 2
52249: ARRAY
52250: AND
52251: IFFALSE 52288
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
52253: LD_EXP 116
52257: PUSH
52258: LD_VAR 0 2
52262: ARRAY
52263: PUSH
52264: LD_INT 1
52266: ARRAY
52267: PPUSH
52268: CALL_OW 255
52272: PPUSH
52273: LD_EXP 115
52277: PUSH
52278: LD_VAR 0 2
52282: ARRAY
52283: PPUSH
52284: CALL 69120 0 2
52288: GO 52226
52290: POP
52291: POP
// end ;
52292: LD_VAR 0 1
52296: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
52297: LD_INT 0
52299: PPUSH
52300: PPUSH
52301: PPUSH
52302: PPUSH
52303: PPUSH
52304: PPUSH
52305: PPUSH
52306: PPUSH
// if not mc_bases or not mc_parking then
52307: LD_EXP 102
52311: NOT
52312: PUSH
52313: LD_EXP 126
52317: NOT
52318: OR
52319: IFFALSE 52323
// exit ;
52321: GO 53022
// for i = 1 to mc_bases do
52323: LD_ADDR_VAR 0 2
52327: PUSH
52328: DOUBLE
52329: LD_INT 1
52331: DEC
52332: ST_TO_ADDR
52333: LD_EXP 102
52337: PUSH
52338: FOR_TO
52339: IFFALSE 53020
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
52341: LD_EXP 102
52345: PUSH
52346: LD_VAR 0 2
52350: ARRAY
52351: NOT
52352: PUSH
52353: LD_EXP 126
52357: PUSH
52358: LD_VAR 0 2
52362: ARRAY
52363: NOT
52364: OR
52365: IFFALSE 52369
// continue ;
52367: GO 52338
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52369: LD_ADDR_VAR 0 5
52373: PUSH
52374: LD_EXP 102
52378: PUSH
52379: LD_VAR 0 2
52383: ARRAY
52384: PUSH
52385: LD_INT 1
52387: ARRAY
52388: PPUSH
52389: CALL_OW 255
52393: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52394: LD_ADDR_VAR 0 6
52398: PUSH
52399: LD_EXP 102
52403: PUSH
52404: LD_VAR 0 2
52408: ARRAY
52409: PPUSH
52410: LD_INT 30
52412: PUSH
52413: LD_INT 3
52415: PUSH
52416: EMPTY
52417: LIST
52418: LIST
52419: PPUSH
52420: CALL_OW 72
52424: ST_TO_ADDR
// if not fac then
52425: LD_VAR 0 6
52429: NOT
52430: IFFALSE 52481
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52432: LD_ADDR_VAR 0 6
52436: PUSH
52437: LD_EXP 102
52441: PUSH
52442: LD_VAR 0 2
52446: ARRAY
52447: PPUSH
52448: LD_INT 2
52450: PUSH
52451: LD_INT 30
52453: PUSH
52454: LD_INT 0
52456: PUSH
52457: EMPTY
52458: LIST
52459: LIST
52460: PUSH
52461: LD_INT 30
52463: PUSH
52464: LD_INT 1
52466: PUSH
52467: EMPTY
52468: LIST
52469: LIST
52470: PUSH
52471: EMPTY
52472: LIST
52473: LIST
52474: LIST
52475: PPUSH
52476: CALL_OW 72
52480: ST_TO_ADDR
// if not fac then
52481: LD_VAR 0 6
52485: NOT
52486: IFFALSE 52490
// continue ;
52488: GO 52338
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52490: LD_ADDR_VAR 0 7
52494: PUSH
52495: LD_EXP 126
52499: PUSH
52500: LD_VAR 0 2
52504: ARRAY
52505: PPUSH
52506: LD_INT 22
52508: PUSH
52509: LD_VAR 0 5
52513: PUSH
52514: EMPTY
52515: LIST
52516: LIST
52517: PUSH
52518: LD_INT 21
52520: PUSH
52521: LD_INT 2
52523: PUSH
52524: EMPTY
52525: LIST
52526: LIST
52527: PUSH
52528: LD_INT 3
52530: PUSH
52531: LD_INT 24
52533: PUSH
52534: LD_INT 1000
52536: PUSH
52537: EMPTY
52538: LIST
52539: LIST
52540: PUSH
52541: EMPTY
52542: LIST
52543: LIST
52544: PUSH
52545: EMPTY
52546: LIST
52547: LIST
52548: LIST
52549: PPUSH
52550: CALL_OW 70
52554: ST_TO_ADDR
// for j in fac do
52555: LD_ADDR_VAR 0 3
52559: PUSH
52560: LD_VAR 0 6
52564: PUSH
52565: FOR_IN
52566: IFFALSE 52647
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52568: LD_ADDR_VAR 0 7
52572: PUSH
52573: LD_VAR 0 7
52577: PUSH
52578: LD_INT 22
52580: PUSH
52581: LD_VAR 0 5
52585: PUSH
52586: EMPTY
52587: LIST
52588: LIST
52589: PUSH
52590: LD_INT 91
52592: PUSH
52593: LD_VAR 0 3
52597: PUSH
52598: LD_INT 15
52600: PUSH
52601: EMPTY
52602: LIST
52603: LIST
52604: LIST
52605: PUSH
52606: LD_INT 21
52608: PUSH
52609: LD_INT 2
52611: PUSH
52612: EMPTY
52613: LIST
52614: LIST
52615: PUSH
52616: LD_INT 3
52618: PUSH
52619: LD_INT 24
52621: PUSH
52622: LD_INT 1000
52624: PUSH
52625: EMPTY
52626: LIST
52627: LIST
52628: PUSH
52629: EMPTY
52630: LIST
52631: LIST
52632: PUSH
52633: EMPTY
52634: LIST
52635: LIST
52636: LIST
52637: LIST
52638: PPUSH
52639: CALL_OW 69
52643: UNION
52644: ST_TO_ADDR
52645: GO 52565
52647: POP
52648: POP
// if not vehs then
52649: LD_VAR 0 7
52653: NOT
52654: IFFALSE 52680
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52656: LD_ADDR_EXP 114
52660: PUSH
52661: LD_EXP 114
52665: PPUSH
52666: LD_VAR 0 2
52670: PPUSH
52671: EMPTY
52672: PPUSH
52673: CALL_OW 1
52677: ST_TO_ADDR
// continue ;
52678: GO 52338
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52680: LD_ADDR_VAR 0 8
52684: PUSH
52685: LD_EXP 102
52689: PUSH
52690: LD_VAR 0 2
52694: ARRAY
52695: PPUSH
52696: LD_INT 30
52698: PUSH
52699: LD_INT 3
52701: PUSH
52702: EMPTY
52703: LIST
52704: LIST
52705: PPUSH
52706: CALL_OW 72
52710: ST_TO_ADDR
// if tmp then
52711: LD_VAR 0 8
52715: IFFALSE 52818
// begin for j in tmp do
52717: LD_ADDR_VAR 0 3
52721: PUSH
52722: LD_VAR 0 8
52726: PUSH
52727: FOR_IN
52728: IFFALSE 52816
// for k in UnitsInside ( j ) do
52730: LD_ADDR_VAR 0 4
52734: PUSH
52735: LD_VAR 0 3
52739: PPUSH
52740: CALL_OW 313
52744: PUSH
52745: FOR_IN
52746: IFFALSE 52812
// if k then
52748: LD_VAR 0 4
52752: IFFALSE 52810
// if not k in mc_repair_vehicle [ i ] then
52754: LD_VAR 0 4
52758: PUSH
52759: LD_EXP 114
52763: PUSH
52764: LD_VAR 0 2
52768: ARRAY
52769: IN
52770: NOT
52771: IFFALSE 52810
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
52773: LD_ADDR_EXP 114
52777: PUSH
52778: LD_EXP 114
52782: PPUSH
52783: LD_VAR 0 2
52787: PPUSH
52788: LD_EXP 114
52792: PUSH
52793: LD_VAR 0 2
52797: ARRAY
52798: PUSH
52799: LD_VAR 0 4
52803: UNION
52804: PPUSH
52805: CALL_OW 1
52809: ST_TO_ADDR
52810: GO 52745
52812: POP
52813: POP
52814: GO 52727
52816: POP
52817: POP
// end ; if not mc_repair_vehicle [ i ] then
52818: LD_EXP 114
52822: PUSH
52823: LD_VAR 0 2
52827: ARRAY
52828: NOT
52829: IFFALSE 52833
// continue ;
52831: GO 52338
// for j in mc_repair_vehicle [ i ] do
52833: LD_ADDR_VAR 0 3
52837: PUSH
52838: LD_EXP 114
52842: PUSH
52843: LD_VAR 0 2
52847: ARRAY
52848: PUSH
52849: FOR_IN
52850: IFFALSE 53016
// begin if GetClass ( j ) <> 3 then
52852: LD_VAR 0 3
52856: PPUSH
52857: CALL_OW 257
52861: PUSH
52862: LD_INT 3
52864: NONEQUAL
52865: IFFALSE 52906
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
52867: LD_ADDR_EXP 114
52871: PUSH
52872: LD_EXP 114
52876: PPUSH
52877: LD_VAR 0 2
52881: PPUSH
52882: LD_EXP 114
52886: PUSH
52887: LD_VAR 0 2
52891: ARRAY
52892: PUSH
52893: LD_VAR 0 3
52897: DIFF
52898: PPUSH
52899: CALL_OW 1
52903: ST_TO_ADDR
// continue ;
52904: GO 52849
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
52906: LD_VAR 0 3
52910: PPUSH
52911: CALL_OW 311
52915: NOT
52916: PUSH
52917: LD_VAR 0 3
52921: PUSH
52922: LD_EXP 105
52926: PUSH
52927: LD_VAR 0 2
52931: ARRAY
52932: PUSH
52933: LD_INT 1
52935: ARRAY
52936: IN
52937: NOT
52938: AND
52939: PUSH
52940: LD_VAR 0 3
52944: PUSH
52945: LD_EXP 105
52949: PUSH
52950: LD_VAR 0 2
52954: ARRAY
52955: PUSH
52956: LD_INT 2
52958: ARRAY
52959: IN
52960: NOT
52961: AND
52962: IFFALSE 53014
// begin if IsInUnit ( j ) then
52964: LD_VAR 0 3
52968: PPUSH
52969: CALL_OW 310
52973: IFFALSE 52984
// ComExitBuilding ( j ) ;
52975: LD_VAR 0 3
52979: PPUSH
52980: CALL_OW 122
// if not HasTask ( j ) then
52984: LD_VAR 0 3
52988: PPUSH
52989: CALL_OW 314
52993: NOT
52994: IFFALSE 53014
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
52996: LD_VAR 0 3
53000: PPUSH
53001: LD_VAR 0 7
53005: PUSH
53006: LD_INT 1
53008: ARRAY
53009: PPUSH
53010: CALL_OW 189
// end ; end ;
53014: GO 52849
53016: POP
53017: POP
// end ;
53018: GO 52338
53020: POP
53021: POP
// end ;
53022: LD_VAR 0 1
53026: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53027: LD_INT 0
53029: PPUSH
53030: PPUSH
53031: PPUSH
53032: PPUSH
53033: PPUSH
53034: PPUSH
53035: PPUSH
53036: PPUSH
53037: PPUSH
53038: PPUSH
53039: PPUSH
// if not mc_bases then
53040: LD_EXP 102
53044: NOT
53045: IFFALSE 53049
// exit ;
53047: GO 53851
// for i = 1 to mc_bases do
53049: LD_ADDR_VAR 0 2
53053: PUSH
53054: DOUBLE
53055: LD_INT 1
53057: DEC
53058: ST_TO_ADDR
53059: LD_EXP 102
53063: PUSH
53064: FOR_TO
53065: IFFALSE 53849
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
53067: LD_EXP 130
53071: PUSH
53072: LD_VAR 0 2
53076: ARRAY
53077: NOT
53078: PUSH
53079: LD_EXP 105
53083: PUSH
53084: LD_VAR 0 2
53088: ARRAY
53089: PUSH
53090: LD_INT 1
53092: ARRAY
53093: OR
53094: PUSH
53095: LD_EXP 105
53099: PUSH
53100: LD_VAR 0 2
53104: ARRAY
53105: PUSH
53106: LD_INT 2
53108: ARRAY
53109: OR
53110: PUSH
53111: LD_EXP 128
53115: PUSH
53116: LD_VAR 0 2
53120: ARRAY
53121: PPUSH
53122: LD_INT 1
53124: PPUSH
53125: CALL_OW 325
53129: NOT
53130: OR
53131: PUSH
53132: LD_EXP 125
53136: PUSH
53137: LD_VAR 0 2
53141: ARRAY
53142: OR
53143: IFFALSE 53147
// continue ;
53145: GO 53064
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
53147: LD_ADDR_VAR 0 8
53151: PUSH
53152: LD_EXP 102
53156: PUSH
53157: LD_VAR 0 2
53161: ARRAY
53162: PPUSH
53163: LD_INT 25
53165: PUSH
53166: LD_INT 4
53168: PUSH
53169: EMPTY
53170: LIST
53171: LIST
53172: PUSH
53173: LD_INT 50
53175: PUSH
53176: EMPTY
53177: LIST
53178: PUSH
53179: LD_INT 3
53181: PUSH
53182: LD_INT 60
53184: PUSH
53185: EMPTY
53186: LIST
53187: PUSH
53188: EMPTY
53189: LIST
53190: LIST
53191: PUSH
53192: EMPTY
53193: LIST
53194: LIST
53195: LIST
53196: PPUSH
53197: CALL_OW 72
53201: PUSH
53202: LD_EXP 106
53206: PUSH
53207: LD_VAR 0 2
53211: ARRAY
53212: DIFF
53213: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53214: LD_ADDR_VAR 0 9
53218: PUSH
53219: LD_EXP 102
53223: PUSH
53224: LD_VAR 0 2
53228: ARRAY
53229: PPUSH
53230: LD_INT 2
53232: PUSH
53233: LD_INT 30
53235: PUSH
53236: LD_INT 0
53238: PUSH
53239: EMPTY
53240: LIST
53241: LIST
53242: PUSH
53243: LD_INT 30
53245: PUSH
53246: LD_INT 1
53248: PUSH
53249: EMPTY
53250: LIST
53251: LIST
53252: PUSH
53253: EMPTY
53254: LIST
53255: LIST
53256: LIST
53257: PPUSH
53258: CALL_OW 72
53262: ST_TO_ADDR
// if not tmp or not dep then
53263: LD_VAR 0 8
53267: NOT
53268: PUSH
53269: LD_VAR 0 9
53273: NOT
53274: OR
53275: IFFALSE 53279
// continue ;
53277: GO 53064
// side := GetSide ( tmp [ 1 ] ) ;
53279: LD_ADDR_VAR 0 11
53283: PUSH
53284: LD_VAR 0 8
53288: PUSH
53289: LD_INT 1
53291: ARRAY
53292: PPUSH
53293: CALL_OW 255
53297: ST_TO_ADDR
// dep := dep [ 1 ] ;
53298: LD_ADDR_VAR 0 9
53302: PUSH
53303: LD_VAR 0 9
53307: PUSH
53308: LD_INT 1
53310: ARRAY
53311: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
53312: LD_ADDR_VAR 0 7
53316: PUSH
53317: LD_EXP 130
53321: PUSH
53322: LD_VAR 0 2
53326: ARRAY
53327: PPUSH
53328: LD_INT 22
53330: PUSH
53331: LD_INT 0
53333: PUSH
53334: EMPTY
53335: LIST
53336: LIST
53337: PUSH
53338: LD_INT 25
53340: PUSH
53341: LD_INT 12
53343: PUSH
53344: EMPTY
53345: LIST
53346: LIST
53347: PUSH
53348: EMPTY
53349: LIST
53350: LIST
53351: PPUSH
53352: CALL_OW 70
53356: PUSH
53357: LD_INT 22
53359: PUSH
53360: LD_INT 0
53362: PUSH
53363: EMPTY
53364: LIST
53365: LIST
53366: PUSH
53367: LD_INT 25
53369: PUSH
53370: LD_INT 12
53372: PUSH
53373: EMPTY
53374: LIST
53375: LIST
53376: PUSH
53377: LD_INT 91
53379: PUSH
53380: LD_VAR 0 9
53384: PUSH
53385: LD_INT 20
53387: PUSH
53388: EMPTY
53389: LIST
53390: LIST
53391: LIST
53392: PUSH
53393: EMPTY
53394: LIST
53395: LIST
53396: LIST
53397: PPUSH
53398: CALL_OW 69
53402: UNION
53403: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
53404: LD_ADDR_VAR 0 10
53408: PUSH
53409: LD_EXP 130
53413: PUSH
53414: LD_VAR 0 2
53418: ARRAY
53419: PPUSH
53420: LD_INT 81
53422: PUSH
53423: LD_VAR 0 11
53427: PUSH
53428: EMPTY
53429: LIST
53430: LIST
53431: PPUSH
53432: CALL_OW 70
53436: ST_TO_ADDR
// if not apes or danger_at_area then
53437: LD_VAR 0 7
53441: NOT
53442: PUSH
53443: LD_VAR 0 10
53447: OR
53448: IFFALSE 53498
// begin if mc_taming [ i ] then
53450: LD_EXP 133
53454: PUSH
53455: LD_VAR 0 2
53459: ARRAY
53460: IFFALSE 53496
// begin MC_Reset ( i , 121 ) ;
53462: LD_VAR 0 2
53466: PPUSH
53467: LD_INT 121
53469: PPUSH
53470: CALL 38933 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53474: LD_ADDR_EXP 133
53478: PUSH
53479: LD_EXP 133
53483: PPUSH
53484: LD_VAR 0 2
53488: PPUSH
53489: EMPTY
53490: PPUSH
53491: CALL_OW 1
53495: ST_TO_ADDR
// end ; continue ;
53496: GO 53064
// end ; for j in tmp do
53498: LD_ADDR_VAR 0 3
53502: PUSH
53503: LD_VAR 0 8
53507: PUSH
53508: FOR_IN
53509: IFFALSE 53845
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
53511: LD_VAR 0 3
53515: PUSH
53516: LD_EXP 133
53520: PUSH
53521: LD_VAR 0 2
53525: ARRAY
53526: IN
53527: NOT
53528: PUSH
53529: LD_EXP 133
53533: PUSH
53534: LD_VAR 0 2
53538: ARRAY
53539: PUSH
53540: LD_INT 3
53542: LESS
53543: AND
53544: IFFALSE 53602
// begin SetTag ( j , 121 ) ;
53546: LD_VAR 0 3
53550: PPUSH
53551: LD_INT 121
53553: PPUSH
53554: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
53558: LD_ADDR_EXP 133
53562: PUSH
53563: LD_EXP 133
53567: PPUSH
53568: LD_VAR 0 2
53572: PUSH
53573: LD_EXP 133
53577: PUSH
53578: LD_VAR 0 2
53582: ARRAY
53583: PUSH
53584: LD_INT 1
53586: PLUS
53587: PUSH
53588: EMPTY
53589: LIST
53590: LIST
53591: PPUSH
53592: LD_VAR 0 3
53596: PPUSH
53597: CALL 72131 0 3
53601: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
53602: LD_VAR 0 3
53606: PUSH
53607: LD_EXP 133
53611: PUSH
53612: LD_VAR 0 2
53616: ARRAY
53617: IN
53618: IFFALSE 53843
// begin if GetClass ( j ) <> 4 then
53620: LD_VAR 0 3
53624: PPUSH
53625: CALL_OW 257
53629: PUSH
53630: LD_INT 4
53632: NONEQUAL
53633: IFFALSE 53686
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
53635: LD_ADDR_EXP 133
53639: PUSH
53640: LD_EXP 133
53644: PPUSH
53645: LD_VAR 0 2
53649: PPUSH
53650: LD_EXP 133
53654: PUSH
53655: LD_VAR 0 2
53659: ARRAY
53660: PUSH
53661: LD_VAR 0 3
53665: DIFF
53666: PPUSH
53667: CALL_OW 1
53671: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53672: LD_VAR 0 3
53676: PPUSH
53677: LD_INT 0
53679: PPUSH
53680: CALL_OW 109
// continue ;
53684: GO 53508
// end ; if IsInUnit ( j ) then
53686: LD_VAR 0 3
53690: PPUSH
53691: CALL_OW 310
53695: IFFALSE 53706
// ComExitBuilding ( j ) ;
53697: LD_VAR 0 3
53701: PPUSH
53702: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
53706: LD_ADDR_VAR 0 6
53710: PUSH
53711: LD_VAR 0 7
53715: PPUSH
53716: LD_VAR 0 3
53720: PPUSH
53721: CALL_OW 74
53725: ST_TO_ADDR
// if not ape then
53726: LD_VAR 0 6
53730: NOT
53731: IFFALSE 53735
// break ;
53733: GO 53845
// x := GetX ( ape ) ;
53735: LD_ADDR_VAR 0 4
53739: PUSH
53740: LD_VAR 0 6
53744: PPUSH
53745: CALL_OW 250
53749: ST_TO_ADDR
// y := GetY ( ape ) ;
53750: LD_ADDR_VAR 0 5
53754: PUSH
53755: LD_VAR 0 6
53759: PPUSH
53760: CALL_OW 251
53764: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
53765: LD_VAR 0 4
53769: PPUSH
53770: LD_VAR 0 5
53774: PPUSH
53775: CALL_OW 488
53779: NOT
53780: PUSH
53781: LD_VAR 0 11
53785: PPUSH
53786: LD_VAR 0 4
53790: PPUSH
53791: LD_VAR 0 5
53795: PPUSH
53796: LD_INT 20
53798: PPUSH
53799: CALL 73027 0 4
53803: PUSH
53804: LD_INT 4
53806: ARRAY
53807: OR
53808: IFFALSE 53812
// break ;
53810: GO 53845
// if not HasTask ( j ) then
53812: LD_VAR 0 3
53816: PPUSH
53817: CALL_OW 314
53821: NOT
53822: IFFALSE 53843
// ComTameXY ( j , x , y ) ;
53824: LD_VAR 0 3
53828: PPUSH
53829: LD_VAR 0 4
53833: PPUSH
53834: LD_VAR 0 5
53838: PPUSH
53839: CALL_OW 131
// end ; end ;
53843: GO 53508
53845: POP
53846: POP
// end ;
53847: GO 53064
53849: POP
53850: POP
// end ;
53851: LD_VAR 0 1
53855: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
53856: LD_INT 0
53858: PPUSH
53859: PPUSH
53860: PPUSH
53861: PPUSH
53862: PPUSH
53863: PPUSH
53864: PPUSH
53865: PPUSH
// if not mc_bases then
53866: LD_EXP 102
53870: NOT
53871: IFFALSE 53875
// exit ;
53873: GO 54501
// for i = 1 to mc_bases do
53875: LD_ADDR_VAR 0 2
53879: PUSH
53880: DOUBLE
53881: LD_INT 1
53883: DEC
53884: ST_TO_ADDR
53885: LD_EXP 102
53889: PUSH
53890: FOR_TO
53891: IFFALSE 54499
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
53893: LD_EXP 131
53897: PUSH
53898: LD_VAR 0 2
53902: ARRAY
53903: NOT
53904: PUSH
53905: LD_EXP 131
53909: PUSH
53910: LD_VAR 0 2
53914: ARRAY
53915: PPUSH
53916: LD_INT 25
53918: PUSH
53919: LD_INT 12
53921: PUSH
53922: EMPTY
53923: LIST
53924: LIST
53925: PPUSH
53926: CALL_OW 72
53930: NOT
53931: OR
53932: IFFALSE 53936
// continue ;
53934: GO 53890
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
53936: LD_ADDR_VAR 0 5
53940: PUSH
53941: LD_EXP 131
53945: PUSH
53946: LD_VAR 0 2
53950: ARRAY
53951: PUSH
53952: LD_INT 1
53954: ARRAY
53955: PPUSH
53956: CALL_OW 255
53960: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
53961: LD_VAR 0 5
53965: PPUSH
53966: LD_INT 2
53968: PPUSH
53969: CALL_OW 325
53973: IFFALSE 54226
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53975: LD_ADDR_VAR 0 4
53979: PUSH
53980: LD_EXP 131
53984: PUSH
53985: LD_VAR 0 2
53989: ARRAY
53990: PPUSH
53991: LD_INT 25
53993: PUSH
53994: LD_INT 16
53996: PUSH
53997: EMPTY
53998: LIST
53999: LIST
54000: PPUSH
54001: CALL_OW 72
54005: ST_TO_ADDR
// if tmp < 6 then
54006: LD_VAR 0 4
54010: PUSH
54011: LD_INT 6
54013: LESS
54014: IFFALSE 54226
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54016: LD_ADDR_VAR 0 6
54020: PUSH
54021: LD_EXP 102
54025: PUSH
54026: LD_VAR 0 2
54030: ARRAY
54031: PPUSH
54032: LD_INT 2
54034: PUSH
54035: LD_INT 30
54037: PUSH
54038: LD_INT 0
54040: PUSH
54041: EMPTY
54042: LIST
54043: LIST
54044: PUSH
54045: LD_INT 30
54047: PUSH
54048: LD_INT 1
54050: PUSH
54051: EMPTY
54052: LIST
54053: LIST
54054: PUSH
54055: EMPTY
54056: LIST
54057: LIST
54058: LIST
54059: PPUSH
54060: CALL_OW 72
54064: ST_TO_ADDR
// if depot then
54065: LD_VAR 0 6
54069: IFFALSE 54226
// begin selected := 0 ;
54071: LD_ADDR_VAR 0 7
54075: PUSH
54076: LD_INT 0
54078: ST_TO_ADDR
// for j in depot do
54079: LD_ADDR_VAR 0 3
54083: PUSH
54084: LD_VAR 0 6
54088: PUSH
54089: FOR_IN
54090: IFFALSE 54121
// begin if UnitsInside ( j ) < 6 then
54092: LD_VAR 0 3
54096: PPUSH
54097: CALL_OW 313
54101: PUSH
54102: LD_INT 6
54104: LESS
54105: IFFALSE 54119
// begin selected := j ;
54107: LD_ADDR_VAR 0 7
54111: PUSH
54112: LD_VAR 0 3
54116: ST_TO_ADDR
// break ;
54117: GO 54121
// end ; end ;
54119: GO 54089
54121: POP
54122: POP
// if selected then
54123: LD_VAR 0 7
54127: IFFALSE 54226
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54129: LD_ADDR_VAR 0 3
54133: PUSH
54134: LD_EXP 131
54138: PUSH
54139: LD_VAR 0 2
54143: ARRAY
54144: PPUSH
54145: LD_INT 25
54147: PUSH
54148: LD_INT 12
54150: PUSH
54151: EMPTY
54152: LIST
54153: LIST
54154: PPUSH
54155: CALL_OW 72
54159: PUSH
54160: FOR_IN
54161: IFFALSE 54224
// if not HasTask ( j ) then
54163: LD_VAR 0 3
54167: PPUSH
54168: CALL_OW 314
54172: NOT
54173: IFFALSE 54222
// begin if not IsInUnit ( j ) then
54175: LD_VAR 0 3
54179: PPUSH
54180: CALL_OW 310
54184: NOT
54185: IFFALSE 54201
// ComEnterUnit ( j , selected ) ;
54187: LD_VAR 0 3
54191: PPUSH
54192: LD_VAR 0 7
54196: PPUSH
54197: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
54201: LD_VAR 0 3
54205: PPUSH
54206: LD_INT 16
54208: PPUSH
54209: CALL_OW 183
// AddComExitBuilding ( j ) ;
54213: LD_VAR 0 3
54217: PPUSH
54218: CALL_OW 182
// end ;
54222: GO 54160
54224: POP
54225: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
54226: LD_VAR 0 5
54230: PPUSH
54231: LD_INT 11
54233: PPUSH
54234: CALL_OW 325
54238: IFFALSE 54497
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54240: LD_ADDR_VAR 0 4
54244: PUSH
54245: LD_EXP 131
54249: PUSH
54250: LD_VAR 0 2
54254: ARRAY
54255: PPUSH
54256: LD_INT 25
54258: PUSH
54259: LD_INT 16
54261: PUSH
54262: EMPTY
54263: LIST
54264: LIST
54265: PPUSH
54266: CALL_OW 72
54270: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
54271: LD_VAR 0 4
54275: PUSH
54276: LD_INT 6
54278: GREATEREQUAL
54279: PUSH
54280: LD_VAR 0 5
54284: PPUSH
54285: LD_INT 2
54287: PPUSH
54288: CALL_OW 325
54292: NOT
54293: OR
54294: IFFALSE 54497
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
54296: LD_ADDR_VAR 0 8
54300: PUSH
54301: LD_EXP 102
54305: PUSH
54306: LD_VAR 0 2
54310: ARRAY
54311: PPUSH
54312: LD_INT 2
54314: PUSH
54315: LD_INT 30
54317: PUSH
54318: LD_INT 4
54320: PUSH
54321: EMPTY
54322: LIST
54323: LIST
54324: PUSH
54325: LD_INT 30
54327: PUSH
54328: LD_INT 5
54330: PUSH
54331: EMPTY
54332: LIST
54333: LIST
54334: PUSH
54335: EMPTY
54336: LIST
54337: LIST
54338: LIST
54339: PPUSH
54340: CALL_OW 72
54344: ST_TO_ADDR
// if barracks then
54345: LD_VAR 0 8
54349: IFFALSE 54497
// begin selected := 0 ;
54351: LD_ADDR_VAR 0 7
54355: PUSH
54356: LD_INT 0
54358: ST_TO_ADDR
// for j in barracks do
54359: LD_ADDR_VAR 0 3
54363: PUSH
54364: LD_VAR 0 8
54368: PUSH
54369: FOR_IN
54370: IFFALSE 54401
// begin if UnitsInside ( j ) < 6 then
54372: LD_VAR 0 3
54376: PPUSH
54377: CALL_OW 313
54381: PUSH
54382: LD_INT 6
54384: LESS
54385: IFFALSE 54399
// begin selected := j ;
54387: LD_ADDR_VAR 0 7
54391: PUSH
54392: LD_VAR 0 3
54396: ST_TO_ADDR
// break ;
54397: GO 54401
// end ; end ;
54399: GO 54369
54401: POP
54402: POP
// if selected then
54403: LD_VAR 0 7
54407: IFFALSE 54497
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54409: LD_ADDR_VAR 0 3
54413: PUSH
54414: LD_EXP 131
54418: PUSH
54419: LD_VAR 0 2
54423: ARRAY
54424: PPUSH
54425: LD_INT 25
54427: PUSH
54428: LD_INT 12
54430: PUSH
54431: EMPTY
54432: LIST
54433: LIST
54434: PPUSH
54435: CALL_OW 72
54439: PUSH
54440: FOR_IN
54441: IFFALSE 54495
// if not IsInUnit ( j ) and not HasTask ( j ) then
54443: LD_VAR 0 3
54447: PPUSH
54448: CALL_OW 310
54452: NOT
54453: PUSH
54454: LD_VAR 0 3
54458: PPUSH
54459: CALL_OW 314
54463: NOT
54464: AND
54465: IFFALSE 54493
// begin ComEnterUnit ( j , selected ) ;
54467: LD_VAR 0 3
54471: PPUSH
54472: LD_VAR 0 7
54476: PPUSH
54477: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
54481: LD_VAR 0 3
54485: PPUSH
54486: LD_INT 15
54488: PPUSH
54489: CALL_OW 183
// end ;
54493: GO 54440
54495: POP
54496: POP
// end ; end ; end ; end ; end ;
54497: GO 53890
54499: POP
54500: POP
// end ;
54501: LD_VAR 0 1
54505: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
54506: LD_INT 0
54508: PPUSH
54509: PPUSH
54510: PPUSH
54511: PPUSH
// if not mc_bases then
54512: LD_EXP 102
54516: NOT
54517: IFFALSE 54521
// exit ;
54519: GO 54699
// for i = 1 to mc_bases do
54521: LD_ADDR_VAR 0 2
54525: PUSH
54526: DOUBLE
54527: LD_INT 1
54529: DEC
54530: ST_TO_ADDR
54531: LD_EXP 102
54535: PUSH
54536: FOR_TO
54537: IFFALSE 54697
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
54539: LD_ADDR_VAR 0 4
54543: PUSH
54544: LD_EXP 102
54548: PUSH
54549: LD_VAR 0 2
54553: ARRAY
54554: PPUSH
54555: LD_INT 25
54557: PUSH
54558: LD_INT 9
54560: PUSH
54561: EMPTY
54562: LIST
54563: LIST
54564: PPUSH
54565: CALL_OW 72
54569: ST_TO_ADDR
// if not tmp then
54570: LD_VAR 0 4
54574: NOT
54575: IFFALSE 54579
// continue ;
54577: GO 54536
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
54579: LD_EXP 128
54583: PUSH
54584: LD_VAR 0 2
54588: ARRAY
54589: PPUSH
54590: LD_INT 29
54592: PPUSH
54593: CALL_OW 325
54597: NOT
54598: PUSH
54599: LD_EXP 128
54603: PUSH
54604: LD_VAR 0 2
54608: ARRAY
54609: PPUSH
54610: LD_INT 28
54612: PPUSH
54613: CALL_OW 325
54617: NOT
54618: AND
54619: IFFALSE 54623
// continue ;
54621: GO 54536
// for j in tmp do
54623: LD_ADDR_VAR 0 3
54627: PUSH
54628: LD_VAR 0 4
54632: PUSH
54633: FOR_IN
54634: IFFALSE 54693
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
54636: LD_VAR 0 3
54640: PUSH
54641: LD_EXP 105
54645: PUSH
54646: LD_VAR 0 2
54650: ARRAY
54651: PUSH
54652: LD_INT 1
54654: ARRAY
54655: IN
54656: NOT
54657: PUSH
54658: LD_VAR 0 3
54662: PUSH
54663: LD_EXP 105
54667: PUSH
54668: LD_VAR 0 2
54672: ARRAY
54673: PUSH
54674: LD_INT 2
54676: ARRAY
54677: IN
54678: NOT
54679: AND
54680: IFFALSE 54691
// ComSpaceTimeShoot ( j ) ;
54682: LD_VAR 0 3
54686: PPUSH
54687: CALL 65717 0 1
54691: GO 54633
54693: POP
54694: POP
// end ;
54695: GO 54536
54697: POP
54698: POP
// end ;
54699: LD_VAR 0 1
54703: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
54704: LD_INT 0
54706: PPUSH
54707: PPUSH
54708: PPUSH
54709: PPUSH
54710: PPUSH
54711: PPUSH
54712: PPUSH
54713: PPUSH
54714: PPUSH
// if not mc_bases then
54715: LD_EXP 102
54719: NOT
54720: IFFALSE 54724
// exit ;
54722: GO 55346
// for i = 1 to mc_bases do
54724: LD_ADDR_VAR 0 2
54728: PUSH
54729: DOUBLE
54730: LD_INT 1
54732: DEC
54733: ST_TO_ADDR
54734: LD_EXP 102
54738: PUSH
54739: FOR_TO
54740: IFFALSE 55344
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
54742: LD_EXP 137
54746: PUSH
54747: LD_VAR 0 2
54751: ARRAY
54752: NOT
54753: PUSH
54754: LD_INT 38
54756: PPUSH
54757: LD_EXP 128
54761: PUSH
54762: LD_VAR 0 2
54766: ARRAY
54767: PPUSH
54768: CALL_OW 321
54772: PUSH
54773: LD_INT 2
54775: NONEQUAL
54776: OR
54777: IFFALSE 54781
// continue ;
54779: GO 54739
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
54781: LD_ADDR_VAR 0 8
54785: PUSH
54786: LD_EXP 102
54790: PUSH
54791: LD_VAR 0 2
54795: ARRAY
54796: PPUSH
54797: LD_INT 30
54799: PUSH
54800: LD_INT 34
54802: PUSH
54803: EMPTY
54804: LIST
54805: LIST
54806: PPUSH
54807: CALL_OW 72
54811: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
54812: LD_ADDR_VAR 0 9
54816: PUSH
54817: LD_EXP 102
54821: PUSH
54822: LD_VAR 0 2
54826: ARRAY
54827: PPUSH
54828: LD_INT 25
54830: PUSH
54831: LD_INT 4
54833: PUSH
54834: EMPTY
54835: LIST
54836: LIST
54837: PPUSH
54838: CALL_OW 72
54842: PPUSH
54843: LD_INT 0
54845: PPUSH
54846: CALL 105401 0 2
54850: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
54851: LD_VAR 0 9
54855: NOT
54856: PUSH
54857: LD_VAR 0 8
54861: NOT
54862: OR
54863: PUSH
54864: LD_EXP 102
54868: PUSH
54869: LD_VAR 0 2
54873: ARRAY
54874: PPUSH
54875: LD_INT 124
54877: PPUSH
54878: CALL 105401 0 2
54882: OR
54883: IFFALSE 54887
// continue ;
54885: GO 54739
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
54887: LD_EXP 138
54891: PUSH
54892: LD_VAR 0 2
54896: ARRAY
54897: PUSH
54898: LD_EXP 137
54902: PUSH
54903: LD_VAR 0 2
54907: ARRAY
54908: LESS
54909: PUSH
54910: LD_EXP 138
54914: PUSH
54915: LD_VAR 0 2
54919: ARRAY
54920: PUSH
54921: LD_VAR 0 8
54925: LESS
54926: AND
54927: IFFALSE 55342
// begin tmp := sci [ 1 ] ;
54929: LD_ADDR_VAR 0 7
54933: PUSH
54934: LD_VAR 0 9
54938: PUSH
54939: LD_INT 1
54941: ARRAY
54942: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
54943: LD_VAR 0 7
54947: PPUSH
54948: LD_INT 124
54950: PPUSH
54951: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
54955: LD_ADDR_VAR 0 3
54959: PUSH
54960: DOUBLE
54961: LD_EXP 137
54965: PUSH
54966: LD_VAR 0 2
54970: ARRAY
54971: INC
54972: ST_TO_ADDR
54973: LD_EXP 137
54977: PUSH
54978: LD_VAR 0 2
54982: ARRAY
54983: PUSH
54984: FOR_DOWNTO
54985: IFFALSE 55328
// begin if IsInUnit ( tmp ) then
54987: LD_VAR 0 7
54991: PPUSH
54992: CALL_OW 310
54996: IFFALSE 55007
// ComExitBuilding ( tmp ) ;
54998: LD_VAR 0 7
55002: PPUSH
55003: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55007: LD_INT 35
55009: PPUSH
55010: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55014: LD_VAR 0 7
55018: PPUSH
55019: CALL_OW 310
55023: NOT
55024: PUSH
55025: LD_VAR 0 7
55029: PPUSH
55030: CALL_OW 314
55034: NOT
55035: AND
55036: IFFALSE 55007
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
55038: LD_ADDR_VAR 0 6
55042: PUSH
55043: LD_VAR 0 7
55047: PPUSH
55048: CALL_OW 250
55052: PUSH
55053: LD_VAR 0 7
55057: PPUSH
55058: CALL_OW 251
55062: PUSH
55063: EMPTY
55064: LIST
55065: LIST
55066: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55067: LD_INT 35
55069: PPUSH
55070: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
55074: LD_ADDR_VAR 0 4
55078: PUSH
55079: LD_EXP 137
55083: PUSH
55084: LD_VAR 0 2
55088: ARRAY
55089: PUSH
55090: LD_VAR 0 3
55094: ARRAY
55095: PUSH
55096: LD_INT 1
55098: ARRAY
55099: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
55100: LD_ADDR_VAR 0 5
55104: PUSH
55105: LD_EXP 137
55109: PUSH
55110: LD_VAR 0 2
55114: ARRAY
55115: PUSH
55116: LD_VAR 0 3
55120: ARRAY
55121: PUSH
55122: LD_INT 2
55124: ARRAY
55125: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
55126: LD_VAR 0 7
55130: PPUSH
55131: LD_INT 10
55133: PPUSH
55134: CALL 74724 0 2
55138: PUSH
55139: LD_INT 4
55141: ARRAY
55142: IFFALSE 55180
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
55144: LD_VAR 0 7
55148: PPUSH
55149: LD_VAR 0 6
55153: PUSH
55154: LD_INT 1
55156: ARRAY
55157: PPUSH
55158: LD_VAR 0 6
55162: PUSH
55163: LD_INT 2
55165: ARRAY
55166: PPUSH
55167: CALL_OW 111
// wait ( 0 0$10 ) ;
55171: LD_INT 350
55173: PPUSH
55174: CALL_OW 67
// end else
55178: GO 55206
// begin ComMoveXY ( tmp , x , y ) ;
55180: LD_VAR 0 7
55184: PPUSH
55185: LD_VAR 0 4
55189: PPUSH
55190: LD_VAR 0 5
55194: PPUSH
55195: CALL_OW 111
// wait ( 0 0$3 ) ;
55199: LD_INT 105
55201: PPUSH
55202: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
55206: LD_VAR 0 7
55210: PPUSH
55211: LD_VAR 0 4
55215: PPUSH
55216: LD_VAR 0 5
55220: PPUSH
55221: CALL_OW 307
55225: IFFALSE 55067
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
55227: LD_VAR 0 7
55231: PPUSH
55232: LD_VAR 0 4
55236: PPUSH
55237: LD_VAR 0 5
55241: PPUSH
55242: LD_VAR 0 8
55246: PUSH
55247: LD_VAR 0 3
55251: ARRAY
55252: PPUSH
55253: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
55257: LD_INT 35
55259: PPUSH
55260: CALL_OW 67
// until not HasTask ( tmp ) ;
55264: LD_VAR 0 7
55268: PPUSH
55269: CALL_OW 314
55273: NOT
55274: IFFALSE 55257
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
55276: LD_ADDR_EXP 138
55280: PUSH
55281: LD_EXP 138
55285: PPUSH
55286: LD_VAR 0 2
55290: PUSH
55291: LD_EXP 138
55295: PUSH
55296: LD_VAR 0 2
55300: ARRAY
55301: PUSH
55302: LD_INT 1
55304: PLUS
55305: PUSH
55306: EMPTY
55307: LIST
55308: LIST
55309: PPUSH
55310: LD_VAR 0 8
55314: PUSH
55315: LD_VAR 0 3
55319: ARRAY
55320: PPUSH
55321: CALL 72131 0 3
55325: ST_TO_ADDR
// end ;
55326: GO 54984
55328: POP
55329: POP
// MC_Reset ( i , 124 ) ;
55330: LD_VAR 0 2
55334: PPUSH
55335: LD_INT 124
55337: PPUSH
55338: CALL 38933 0 2
// end ; end ;
55342: GO 54739
55344: POP
55345: POP
// end ;
55346: LD_VAR 0 1
55350: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
55351: LD_INT 0
55353: PPUSH
55354: PPUSH
55355: PPUSH
// if not mc_bases then
55356: LD_EXP 102
55360: NOT
55361: IFFALSE 55365
// exit ;
55363: GO 55971
// for i = 1 to mc_bases do
55365: LD_ADDR_VAR 0 2
55369: PUSH
55370: DOUBLE
55371: LD_INT 1
55373: DEC
55374: ST_TO_ADDR
55375: LD_EXP 102
55379: PUSH
55380: FOR_TO
55381: IFFALSE 55969
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
55383: LD_ADDR_VAR 0 3
55387: PUSH
55388: LD_EXP 102
55392: PUSH
55393: LD_VAR 0 2
55397: ARRAY
55398: PPUSH
55399: LD_INT 25
55401: PUSH
55402: LD_INT 4
55404: PUSH
55405: EMPTY
55406: LIST
55407: LIST
55408: PPUSH
55409: CALL_OW 72
55413: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55414: LD_VAR 0 3
55418: NOT
55419: PUSH
55420: LD_EXP 139
55424: PUSH
55425: LD_VAR 0 2
55429: ARRAY
55430: NOT
55431: OR
55432: PUSH
55433: LD_EXP 102
55437: PUSH
55438: LD_VAR 0 2
55442: ARRAY
55443: PPUSH
55444: LD_INT 2
55446: PUSH
55447: LD_INT 30
55449: PUSH
55450: LD_INT 0
55452: PUSH
55453: EMPTY
55454: LIST
55455: LIST
55456: PUSH
55457: LD_INT 30
55459: PUSH
55460: LD_INT 1
55462: PUSH
55463: EMPTY
55464: LIST
55465: LIST
55466: PUSH
55467: EMPTY
55468: LIST
55469: LIST
55470: LIST
55471: PPUSH
55472: CALL_OW 72
55476: NOT
55477: OR
55478: IFFALSE 55528
// begin if mc_deposits_finder [ i ] then
55480: LD_EXP 140
55484: PUSH
55485: LD_VAR 0 2
55489: ARRAY
55490: IFFALSE 55526
// begin MC_Reset ( i , 125 ) ;
55492: LD_VAR 0 2
55496: PPUSH
55497: LD_INT 125
55499: PPUSH
55500: CALL 38933 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55504: LD_ADDR_EXP 140
55508: PUSH
55509: LD_EXP 140
55513: PPUSH
55514: LD_VAR 0 2
55518: PPUSH
55519: EMPTY
55520: PPUSH
55521: CALL_OW 1
55525: ST_TO_ADDR
// end ; continue ;
55526: GO 55380
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
55528: LD_EXP 139
55532: PUSH
55533: LD_VAR 0 2
55537: ARRAY
55538: PUSH
55539: LD_INT 1
55541: ARRAY
55542: PUSH
55543: LD_INT 3
55545: ARRAY
55546: PUSH
55547: LD_INT 1
55549: EQUAL
55550: PUSH
55551: LD_INT 20
55553: PPUSH
55554: LD_EXP 128
55558: PUSH
55559: LD_VAR 0 2
55563: ARRAY
55564: PPUSH
55565: CALL_OW 321
55569: PUSH
55570: LD_INT 2
55572: NONEQUAL
55573: AND
55574: IFFALSE 55624
// begin if mc_deposits_finder [ i ] then
55576: LD_EXP 140
55580: PUSH
55581: LD_VAR 0 2
55585: ARRAY
55586: IFFALSE 55622
// begin MC_Reset ( i , 125 ) ;
55588: LD_VAR 0 2
55592: PPUSH
55593: LD_INT 125
55595: PPUSH
55596: CALL 38933 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55600: LD_ADDR_EXP 140
55604: PUSH
55605: LD_EXP 140
55609: PPUSH
55610: LD_VAR 0 2
55614: PPUSH
55615: EMPTY
55616: PPUSH
55617: CALL_OW 1
55621: ST_TO_ADDR
// end ; continue ;
55622: GO 55380
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
55624: LD_EXP 139
55628: PUSH
55629: LD_VAR 0 2
55633: ARRAY
55634: PUSH
55635: LD_INT 1
55637: ARRAY
55638: PUSH
55639: LD_INT 1
55641: ARRAY
55642: PPUSH
55643: LD_EXP 139
55647: PUSH
55648: LD_VAR 0 2
55652: ARRAY
55653: PUSH
55654: LD_INT 1
55656: ARRAY
55657: PUSH
55658: LD_INT 2
55660: ARRAY
55661: PPUSH
55662: LD_EXP 128
55666: PUSH
55667: LD_VAR 0 2
55671: ARRAY
55672: PPUSH
55673: CALL_OW 440
55677: IFFALSE 55720
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
55679: LD_ADDR_EXP 139
55683: PUSH
55684: LD_EXP 139
55688: PPUSH
55689: LD_VAR 0 2
55693: PPUSH
55694: LD_EXP 139
55698: PUSH
55699: LD_VAR 0 2
55703: ARRAY
55704: PPUSH
55705: LD_INT 1
55707: PPUSH
55708: CALL_OW 3
55712: PPUSH
55713: CALL_OW 1
55717: ST_TO_ADDR
55718: GO 55967
// begin if not mc_deposits_finder [ i ] then
55720: LD_EXP 140
55724: PUSH
55725: LD_VAR 0 2
55729: ARRAY
55730: NOT
55731: IFFALSE 55783
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
55733: LD_ADDR_EXP 140
55737: PUSH
55738: LD_EXP 140
55742: PPUSH
55743: LD_VAR 0 2
55747: PPUSH
55748: LD_VAR 0 3
55752: PUSH
55753: LD_INT 1
55755: ARRAY
55756: PUSH
55757: EMPTY
55758: LIST
55759: PPUSH
55760: CALL_OW 1
55764: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
55765: LD_VAR 0 3
55769: PUSH
55770: LD_INT 1
55772: ARRAY
55773: PPUSH
55774: LD_INT 125
55776: PPUSH
55777: CALL_OW 109
// end else
55781: GO 55967
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
55783: LD_EXP 140
55787: PUSH
55788: LD_VAR 0 2
55792: ARRAY
55793: PUSH
55794: LD_INT 1
55796: ARRAY
55797: PPUSH
55798: CALL_OW 310
55802: IFFALSE 55825
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
55804: LD_EXP 140
55808: PUSH
55809: LD_VAR 0 2
55813: ARRAY
55814: PUSH
55815: LD_INT 1
55817: ARRAY
55818: PPUSH
55819: CALL_OW 122
55823: GO 55967
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
55825: LD_EXP 140
55829: PUSH
55830: LD_VAR 0 2
55834: ARRAY
55835: PUSH
55836: LD_INT 1
55838: ARRAY
55839: PPUSH
55840: CALL_OW 314
55844: NOT
55845: PUSH
55846: LD_EXP 140
55850: PUSH
55851: LD_VAR 0 2
55855: ARRAY
55856: PUSH
55857: LD_INT 1
55859: ARRAY
55860: PPUSH
55861: LD_EXP 139
55865: PUSH
55866: LD_VAR 0 2
55870: ARRAY
55871: PUSH
55872: LD_INT 1
55874: ARRAY
55875: PUSH
55876: LD_INT 1
55878: ARRAY
55879: PPUSH
55880: LD_EXP 139
55884: PUSH
55885: LD_VAR 0 2
55889: ARRAY
55890: PUSH
55891: LD_INT 1
55893: ARRAY
55894: PUSH
55895: LD_INT 2
55897: ARRAY
55898: PPUSH
55899: CALL_OW 297
55903: PUSH
55904: LD_INT 6
55906: GREATER
55907: AND
55908: IFFALSE 55967
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
55910: LD_EXP 140
55914: PUSH
55915: LD_VAR 0 2
55919: ARRAY
55920: PUSH
55921: LD_INT 1
55923: ARRAY
55924: PPUSH
55925: LD_EXP 139
55929: PUSH
55930: LD_VAR 0 2
55934: ARRAY
55935: PUSH
55936: LD_INT 1
55938: ARRAY
55939: PUSH
55940: LD_INT 1
55942: ARRAY
55943: PPUSH
55944: LD_EXP 139
55948: PUSH
55949: LD_VAR 0 2
55953: ARRAY
55954: PUSH
55955: LD_INT 1
55957: ARRAY
55958: PUSH
55959: LD_INT 2
55961: ARRAY
55962: PPUSH
55963: CALL_OW 111
// end ; end ; end ;
55967: GO 55380
55969: POP
55970: POP
// end ;
55971: LD_VAR 0 1
55975: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
55976: LD_INT 0
55978: PPUSH
55979: PPUSH
55980: PPUSH
55981: PPUSH
55982: PPUSH
55983: PPUSH
55984: PPUSH
55985: PPUSH
55986: PPUSH
55987: PPUSH
55988: PPUSH
// if not mc_bases then
55989: LD_EXP 102
55993: NOT
55994: IFFALSE 55998
// exit ;
55996: GO 56938
// for i = 1 to mc_bases do
55998: LD_ADDR_VAR 0 2
56002: PUSH
56003: DOUBLE
56004: LD_INT 1
56006: DEC
56007: ST_TO_ADDR
56008: LD_EXP 102
56012: PUSH
56013: FOR_TO
56014: IFFALSE 56936
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56016: LD_EXP 102
56020: PUSH
56021: LD_VAR 0 2
56025: ARRAY
56026: NOT
56027: PUSH
56028: LD_EXP 125
56032: PUSH
56033: LD_VAR 0 2
56037: ARRAY
56038: OR
56039: IFFALSE 56043
// continue ;
56041: GO 56013
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
56043: LD_ADDR_VAR 0 7
56047: PUSH
56048: LD_EXP 102
56052: PUSH
56053: LD_VAR 0 2
56057: ARRAY
56058: PUSH
56059: LD_INT 1
56061: ARRAY
56062: PPUSH
56063: CALL_OW 248
56067: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
56068: LD_VAR 0 7
56072: PUSH
56073: LD_INT 3
56075: EQUAL
56076: PUSH
56077: LD_EXP 121
56081: PUSH
56082: LD_VAR 0 2
56086: ARRAY
56087: PUSH
56088: LD_EXP 124
56092: PUSH
56093: LD_VAR 0 2
56097: ARRAY
56098: UNION
56099: PPUSH
56100: LD_INT 33
56102: PUSH
56103: LD_INT 2
56105: PUSH
56106: EMPTY
56107: LIST
56108: LIST
56109: PPUSH
56110: CALL_OW 72
56114: NOT
56115: OR
56116: IFFALSE 56120
// continue ;
56118: GO 56013
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
56120: LD_ADDR_VAR 0 9
56124: PUSH
56125: LD_EXP 102
56129: PUSH
56130: LD_VAR 0 2
56134: ARRAY
56135: PPUSH
56136: LD_INT 30
56138: PUSH
56139: LD_INT 36
56141: PUSH
56142: EMPTY
56143: LIST
56144: LIST
56145: PPUSH
56146: CALL_OW 72
56150: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
56151: LD_ADDR_VAR 0 10
56155: PUSH
56156: LD_EXP 121
56160: PUSH
56161: LD_VAR 0 2
56165: ARRAY
56166: PPUSH
56167: LD_INT 34
56169: PUSH
56170: LD_INT 31
56172: PUSH
56173: EMPTY
56174: LIST
56175: LIST
56176: PPUSH
56177: CALL_OW 72
56181: ST_TO_ADDR
// if not cts and not mcts then
56182: LD_VAR 0 9
56186: NOT
56187: PUSH
56188: LD_VAR 0 10
56192: NOT
56193: AND
56194: IFFALSE 56198
// continue ;
56196: GO 56013
// x := cts ;
56198: LD_ADDR_VAR 0 11
56202: PUSH
56203: LD_VAR 0 9
56207: ST_TO_ADDR
// if not x then
56208: LD_VAR 0 11
56212: NOT
56213: IFFALSE 56225
// x := mcts ;
56215: LD_ADDR_VAR 0 11
56219: PUSH
56220: LD_VAR 0 10
56224: ST_TO_ADDR
// if not x then
56225: LD_VAR 0 11
56229: NOT
56230: IFFALSE 56234
// continue ;
56232: GO 56013
// if mc_remote_driver [ i ] then
56234: LD_EXP 142
56238: PUSH
56239: LD_VAR 0 2
56243: ARRAY
56244: IFFALSE 56631
// for j in mc_remote_driver [ i ] do
56246: LD_ADDR_VAR 0 3
56250: PUSH
56251: LD_EXP 142
56255: PUSH
56256: LD_VAR 0 2
56260: ARRAY
56261: PUSH
56262: FOR_IN
56263: IFFALSE 56629
// begin if GetClass ( j ) <> 3 then
56265: LD_VAR 0 3
56269: PPUSH
56270: CALL_OW 257
56274: PUSH
56275: LD_INT 3
56277: NONEQUAL
56278: IFFALSE 56331
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
56280: LD_ADDR_EXP 142
56284: PUSH
56285: LD_EXP 142
56289: PPUSH
56290: LD_VAR 0 2
56294: PPUSH
56295: LD_EXP 142
56299: PUSH
56300: LD_VAR 0 2
56304: ARRAY
56305: PUSH
56306: LD_VAR 0 3
56310: DIFF
56311: PPUSH
56312: CALL_OW 1
56316: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56317: LD_VAR 0 3
56321: PPUSH
56322: LD_INT 0
56324: PPUSH
56325: CALL_OW 109
// continue ;
56329: GO 56262
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
56331: LD_EXP 121
56335: PUSH
56336: LD_VAR 0 2
56340: ARRAY
56341: PPUSH
56342: LD_INT 34
56344: PUSH
56345: LD_INT 31
56347: PUSH
56348: EMPTY
56349: LIST
56350: LIST
56351: PUSH
56352: LD_INT 58
56354: PUSH
56355: EMPTY
56356: LIST
56357: PUSH
56358: EMPTY
56359: LIST
56360: LIST
56361: PPUSH
56362: CALL_OW 72
56366: PUSH
56367: LD_VAR 0 3
56371: PPUSH
56372: CALL 105489 0 1
56376: NOT
56377: AND
56378: IFFALSE 56449
// begin if IsInUnit ( j ) then
56380: LD_VAR 0 3
56384: PPUSH
56385: CALL_OW 310
56389: IFFALSE 56400
// ComExitBuilding ( j ) ;
56391: LD_VAR 0 3
56395: PPUSH
56396: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
56400: LD_VAR 0 3
56404: PPUSH
56405: LD_EXP 121
56409: PUSH
56410: LD_VAR 0 2
56414: ARRAY
56415: PPUSH
56416: LD_INT 34
56418: PUSH
56419: LD_INT 31
56421: PUSH
56422: EMPTY
56423: LIST
56424: LIST
56425: PUSH
56426: LD_INT 58
56428: PUSH
56429: EMPTY
56430: LIST
56431: PUSH
56432: EMPTY
56433: LIST
56434: LIST
56435: PPUSH
56436: CALL_OW 72
56440: PUSH
56441: LD_INT 1
56443: ARRAY
56444: PPUSH
56445: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
56449: LD_VAR 0 3
56453: PPUSH
56454: CALL_OW 310
56458: NOT
56459: PUSH
56460: LD_VAR 0 3
56464: PPUSH
56465: CALL_OW 310
56469: PPUSH
56470: CALL_OW 266
56474: PUSH
56475: LD_INT 36
56477: NONEQUAL
56478: PUSH
56479: LD_VAR 0 3
56483: PPUSH
56484: CALL 105489 0 1
56488: NOT
56489: AND
56490: OR
56491: IFFALSE 56627
// begin if IsInUnit ( j ) then
56493: LD_VAR 0 3
56497: PPUSH
56498: CALL_OW 310
56502: IFFALSE 56513
// ComExitBuilding ( j ) ;
56504: LD_VAR 0 3
56508: PPUSH
56509: CALL_OW 122
// ct := 0 ;
56513: LD_ADDR_VAR 0 8
56517: PUSH
56518: LD_INT 0
56520: ST_TO_ADDR
// for k in x do
56521: LD_ADDR_VAR 0 4
56525: PUSH
56526: LD_VAR 0 11
56530: PUSH
56531: FOR_IN
56532: IFFALSE 56605
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
56534: LD_VAR 0 4
56538: PPUSH
56539: CALL_OW 264
56543: PUSH
56544: LD_INT 31
56546: EQUAL
56547: PUSH
56548: LD_VAR 0 4
56552: PPUSH
56553: CALL_OW 311
56557: NOT
56558: AND
56559: PUSH
56560: LD_VAR 0 4
56564: PPUSH
56565: CALL_OW 266
56569: PUSH
56570: LD_INT 36
56572: EQUAL
56573: PUSH
56574: LD_VAR 0 4
56578: PPUSH
56579: CALL_OW 313
56583: PUSH
56584: LD_INT 3
56586: LESS
56587: AND
56588: OR
56589: IFFALSE 56603
// begin ct := k ;
56591: LD_ADDR_VAR 0 8
56595: PUSH
56596: LD_VAR 0 4
56600: ST_TO_ADDR
// break ;
56601: GO 56605
// end ;
56603: GO 56531
56605: POP
56606: POP
// if ct then
56607: LD_VAR 0 8
56611: IFFALSE 56627
// ComEnterUnit ( j , ct ) ;
56613: LD_VAR 0 3
56617: PPUSH
56618: LD_VAR 0 8
56622: PPUSH
56623: CALL_OW 120
// end ; end ;
56627: GO 56262
56629: POP
56630: POP
// places := 0 ;
56631: LD_ADDR_VAR 0 5
56635: PUSH
56636: LD_INT 0
56638: ST_TO_ADDR
// for j = 1 to x do
56639: LD_ADDR_VAR 0 3
56643: PUSH
56644: DOUBLE
56645: LD_INT 1
56647: DEC
56648: ST_TO_ADDR
56649: LD_VAR 0 11
56653: PUSH
56654: FOR_TO
56655: IFFALSE 56731
// if GetWeapon ( x [ j ] ) = ar_control_tower then
56657: LD_VAR 0 11
56661: PUSH
56662: LD_VAR 0 3
56666: ARRAY
56667: PPUSH
56668: CALL_OW 264
56672: PUSH
56673: LD_INT 31
56675: EQUAL
56676: IFFALSE 56694
// places := places + 1 else
56678: LD_ADDR_VAR 0 5
56682: PUSH
56683: LD_VAR 0 5
56687: PUSH
56688: LD_INT 1
56690: PLUS
56691: ST_TO_ADDR
56692: GO 56729
// if GetBType ( x [ j ] ) = b_control_tower then
56694: LD_VAR 0 11
56698: PUSH
56699: LD_VAR 0 3
56703: ARRAY
56704: PPUSH
56705: CALL_OW 266
56709: PUSH
56710: LD_INT 36
56712: EQUAL
56713: IFFALSE 56729
// places := places + 3 ;
56715: LD_ADDR_VAR 0 5
56719: PUSH
56720: LD_VAR 0 5
56724: PUSH
56725: LD_INT 3
56727: PLUS
56728: ST_TO_ADDR
56729: GO 56654
56731: POP
56732: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
56733: LD_VAR 0 5
56737: PUSH
56738: LD_INT 0
56740: EQUAL
56741: PUSH
56742: LD_VAR 0 5
56746: PUSH
56747: LD_EXP 142
56751: PUSH
56752: LD_VAR 0 2
56756: ARRAY
56757: LESSEQUAL
56758: OR
56759: IFFALSE 56763
// continue ;
56761: GO 56013
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
56763: LD_ADDR_VAR 0 6
56767: PUSH
56768: LD_EXP 102
56772: PUSH
56773: LD_VAR 0 2
56777: ARRAY
56778: PPUSH
56779: LD_INT 25
56781: PUSH
56782: LD_INT 3
56784: PUSH
56785: EMPTY
56786: LIST
56787: LIST
56788: PPUSH
56789: CALL_OW 72
56793: PUSH
56794: LD_EXP 142
56798: PUSH
56799: LD_VAR 0 2
56803: ARRAY
56804: DIFF
56805: PPUSH
56806: LD_INT 3
56808: PPUSH
56809: CALL 106389 0 2
56813: ST_TO_ADDR
// for j in tmp do
56814: LD_ADDR_VAR 0 3
56818: PUSH
56819: LD_VAR 0 6
56823: PUSH
56824: FOR_IN
56825: IFFALSE 56860
// if GetTag ( j ) > 0 then
56827: LD_VAR 0 3
56831: PPUSH
56832: CALL_OW 110
56836: PUSH
56837: LD_INT 0
56839: GREATER
56840: IFFALSE 56858
// tmp := tmp diff j ;
56842: LD_ADDR_VAR 0 6
56846: PUSH
56847: LD_VAR 0 6
56851: PUSH
56852: LD_VAR 0 3
56856: DIFF
56857: ST_TO_ADDR
56858: GO 56824
56860: POP
56861: POP
// if not tmp then
56862: LD_VAR 0 6
56866: NOT
56867: IFFALSE 56871
// continue ;
56869: GO 56013
// if places then
56871: LD_VAR 0 5
56875: IFFALSE 56934
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
56877: LD_ADDR_EXP 142
56881: PUSH
56882: LD_EXP 142
56886: PPUSH
56887: LD_VAR 0 2
56891: PPUSH
56892: LD_EXP 142
56896: PUSH
56897: LD_VAR 0 2
56901: ARRAY
56902: PUSH
56903: LD_VAR 0 6
56907: PUSH
56908: LD_INT 1
56910: ARRAY
56911: UNION
56912: PPUSH
56913: CALL_OW 1
56917: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
56918: LD_VAR 0 6
56922: PUSH
56923: LD_INT 1
56925: ARRAY
56926: PPUSH
56927: LD_INT 126
56929: PPUSH
56930: CALL_OW 109
// end ; end ;
56934: GO 56013
56936: POP
56937: POP
// end ;
56938: LD_VAR 0 1
56942: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
56943: LD_INT 0
56945: PPUSH
56946: PPUSH
56947: PPUSH
56948: PPUSH
56949: PPUSH
56950: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
56951: LD_VAR 0 1
56955: NOT
56956: PUSH
56957: LD_VAR 0 2
56961: NOT
56962: OR
56963: PUSH
56964: LD_VAR 0 3
56968: NOT
56969: OR
56970: PUSH
56971: LD_VAR 0 4
56975: PUSH
56976: LD_INT 1
56978: PUSH
56979: LD_INT 2
56981: PUSH
56982: LD_INT 3
56984: PUSH
56985: LD_INT 4
56987: PUSH
56988: LD_INT 5
56990: PUSH
56991: LD_INT 8
56993: PUSH
56994: LD_INT 9
56996: PUSH
56997: LD_INT 15
56999: PUSH
57000: LD_INT 16
57002: PUSH
57003: EMPTY
57004: LIST
57005: LIST
57006: LIST
57007: LIST
57008: LIST
57009: LIST
57010: LIST
57011: LIST
57012: LIST
57013: IN
57014: NOT
57015: OR
57016: IFFALSE 57020
// exit ;
57018: GO 57920
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57020: LD_ADDR_VAR 0 2
57024: PUSH
57025: LD_VAR 0 2
57029: PPUSH
57030: LD_INT 21
57032: PUSH
57033: LD_INT 3
57035: PUSH
57036: EMPTY
57037: LIST
57038: LIST
57039: PUSH
57040: LD_INT 24
57042: PUSH
57043: LD_INT 250
57045: PUSH
57046: EMPTY
57047: LIST
57048: LIST
57049: PUSH
57050: EMPTY
57051: LIST
57052: LIST
57053: PPUSH
57054: CALL_OW 72
57058: ST_TO_ADDR
// case class of 1 , 15 :
57059: LD_VAR 0 4
57063: PUSH
57064: LD_INT 1
57066: DOUBLE
57067: EQUAL
57068: IFTRUE 57078
57070: LD_INT 15
57072: DOUBLE
57073: EQUAL
57074: IFTRUE 57078
57076: GO 57163
57078: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
57079: LD_ADDR_VAR 0 8
57083: PUSH
57084: LD_VAR 0 2
57088: PPUSH
57089: LD_INT 2
57091: PUSH
57092: LD_INT 30
57094: PUSH
57095: LD_INT 32
57097: PUSH
57098: EMPTY
57099: LIST
57100: LIST
57101: PUSH
57102: LD_INT 30
57104: PUSH
57105: LD_INT 31
57107: PUSH
57108: EMPTY
57109: LIST
57110: LIST
57111: PUSH
57112: EMPTY
57113: LIST
57114: LIST
57115: LIST
57116: PPUSH
57117: CALL_OW 72
57121: PUSH
57122: LD_VAR 0 2
57126: PPUSH
57127: LD_INT 2
57129: PUSH
57130: LD_INT 30
57132: PUSH
57133: LD_INT 4
57135: PUSH
57136: EMPTY
57137: LIST
57138: LIST
57139: PUSH
57140: LD_INT 30
57142: PUSH
57143: LD_INT 5
57145: PUSH
57146: EMPTY
57147: LIST
57148: LIST
57149: PUSH
57150: EMPTY
57151: LIST
57152: LIST
57153: LIST
57154: PPUSH
57155: CALL_OW 72
57159: ADD
57160: ST_TO_ADDR
57161: GO 57409
57163: LD_INT 2
57165: DOUBLE
57166: EQUAL
57167: IFTRUE 57177
57169: LD_INT 16
57171: DOUBLE
57172: EQUAL
57173: IFTRUE 57177
57175: GO 57223
57177: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
57178: LD_ADDR_VAR 0 8
57182: PUSH
57183: LD_VAR 0 2
57187: PPUSH
57188: LD_INT 2
57190: PUSH
57191: LD_INT 30
57193: PUSH
57194: LD_INT 0
57196: PUSH
57197: EMPTY
57198: LIST
57199: LIST
57200: PUSH
57201: LD_INT 30
57203: PUSH
57204: LD_INT 1
57206: PUSH
57207: EMPTY
57208: LIST
57209: LIST
57210: PUSH
57211: EMPTY
57212: LIST
57213: LIST
57214: LIST
57215: PPUSH
57216: CALL_OW 72
57220: ST_TO_ADDR
57221: GO 57409
57223: LD_INT 3
57225: DOUBLE
57226: EQUAL
57227: IFTRUE 57231
57229: GO 57277
57231: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
57232: LD_ADDR_VAR 0 8
57236: PUSH
57237: LD_VAR 0 2
57241: PPUSH
57242: LD_INT 2
57244: PUSH
57245: LD_INT 30
57247: PUSH
57248: LD_INT 2
57250: PUSH
57251: EMPTY
57252: LIST
57253: LIST
57254: PUSH
57255: LD_INT 30
57257: PUSH
57258: LD_INT 3
57260: PUSH
57261: EMPTY
57262: LIST
57263: LIST
57264: PUSH
57265: EMPTY
57266: LIST
57267: LIST
57268: LIST
57269: PPUSH
57270: CALL_OW 72
57274: ST_TO_ADDR
57275: GO 57409
57277: LD_INT 4
57279: DOUBLE
57280: EQUAL
57281: IFTRUE 57285
57283: GO 57342
57285: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
57286: LD_ADDR_VAR 0 8
57290: PUSH
57291: LD_VAR 0 2
57295: PPUSH
57296: LD_INT 2
57298: PUSH
57299: LD_INT 30
57301: PUSH
57302: LD_INT 6
57304: PUSH
57305: EMPTY
57306: LIST
57307: LIST
57308: PUSH
57309: LD_INT 30
57311: PUSH
57312: LD_INT 7
57314: PUSH
57315: EMPTY
57316: LIST
57317: LIST
57318: PUSH
57319: LD_INT 30
57321: PUSH
57322: LD_INT 8
57324: PUSH
57325: EMPTY
57326: LIST
57327: LIST
57328: PUSH
57329: EMPTY
57330: LIST
57331: LIST
57332: LIST
57333: LIST
57334: PPUSH
57335: CALL_OW 72
57339: ST_TO_ADDR
57340: GO 57409
57342: LD_INT 5
57344: DOUBLE
57345: EQUAL
57346: IFTRUE 57362
57348: LD_INT 8
57350: DOUBLE
57351: EQUAL
57352: IFTRUE 57362
57354: LD_INT 9
57356: DOUBLE
57357: EQUAL
57358: IFTRUE 57362
57360: GO 57408
57362: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
57363: LD_ADDR_VAR 0 8
57367: PUSH
57368: LD_VAR 0 2
57372: PPUSH
57373: LD_INT 2
57375: PUSH
57376: LD_INT 30
57378: PUSH
57379: LD_INT 4
57381: PUSH
57382: EMPTY
57383: LIST
57384: LIST
57385: PUSH
57386: LD_INT 30
57388: PUSH
57389: LD_INT 5
57391: PUSH
57392: EMPTY
57393: LIST
57394: LIST
57395: PUSH
57396: EMPTY
57397: LIST
57398: LIST
57399: LIST
57400: PPUSH
57401: CALL_OW 72
57405: ST_TO_ADDR
57406: GO 57409
57408: POP
// if not tmp then
57409: LD_VAR 0 8
57413: NOT
57414: IFFALSE 57418
// exit ;
57416: GO 57920
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
57418: LD_VAR 0 4
57422: PUSH
57423: LD_INT 1
57425: PUSH
57426: LD_INT 15
57428: PUSH
57429: EMPTY
57430: LIST
57431: LIST
57432: IN
57433: PUSH
57434: LD_EXP 111
57438: PUSH
57439: LD_VAR 0 1
57443: ARRAY
57444: AND
57445: IFFALSE 57601
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
57447: LD_ADDR_VAR 0 9
57451: PUSH
57452: LD_EXP 111
57456: PUSH
57457: LD_VAR 0 1
57461: ARRAY
57462: PUSH
57463: LD_INT 1
57465: ARRAY
57466: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
57467: LD_VAR 0 9
57471: PUSH
57472: LD_EXP 112
57476: PUSH
57477: LD_VAR 0 1
57481: ARRAY
57482: IN
57483: NOT
57484: IFFALSE 57599
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
57486: LD_ADDR_EXP 112
57490: PUSH
57491: LD_EXP 112
57495: PPUSH
57496: LD_VAR 0 1
57500: PUSH
57501: LD_EXP 112
57505: PUSH
57506: LD_VAR 0 1
57510: ARRAY
57511: PUSH
57512: LD_INT 1
57514: PLUS
57515: PUSH
57516: EMPTY
57517: LIST
57518: LIST
57519: PPUSH
57520: LD_VAR 0 9
57524: PPUSH
57525: CALL 72131 0 3
57529: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
57530: LD_ADDR_EXP 111
57534: PUSH
57535: LD_EXP 111
57539: PPUSH
57540: LD_VAR 0 1
57544: PPUSH
57545: LD_EXP 111
57549: PUSH
57550: LD_VAR 0 1
57554: ARRAY
57555: PUSH
57556: LD_VAR 0 9
57560: DIFF
57561: PPUSH
57562: CALL_OW 1
57566: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
57567: LD_VAR 0 3
57571: PPUSH
57572: LD_EXP 112
57576: PUSH
57577: LD_VAR 0 1
57581: ARRAY
57582: PUSH
57583: LD_EXP 112
57587: PUSH
57588: LD_VAR 0 1
57592: ARRAY
57593: ARRAY
57594: PPUSH
57595: CALL_OW 120
// end ; exit ;
57599: GO 57920
// end ; if tmp > 1 then
57601: LD_VAR 0 8
57605: PUSH
57606: LD_INT 1
57608: GREATER
57609: IFFALSE 57713
// for i = 2 to tmp do
57611: LD_ADDR_VAR 0 6
57615: PUSH
57616: DOUBLE
57617: LD_INT 2
57619: DEC
57620: ST_TO_ADDR
57621: LD_VAR 0 8
57625: PUSH
57626: FOR_TO
57627: IFFALSE 57711
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
57629: LD_VAR 0 8
57633: PUSH
57634: LD_VAR 0 6
57638: ARRAY
57639: PPUSH
57640: CALL_OW 461
57644: PUSH
57645: LD_INT 6
57647: EQUAL
57648: IFFALSE 57709
// begin x := tmp [ i ] ;
57650: LD_ADDR_VAR 0 9
57654: PUSH
57655: LD_VAR 0 8
57659: PUSH
57660: LD_VAR 0 6
57664: ARRAY
57665: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
57666: LD_ADDR_VAR 0 8
57670: PUSH
57671: LD_VAR 0 8
57675: PPUSH
57676: LD_VAR 0 6
57680: PPUSH
57681: CALL_OW 3
57685: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
57686: LD_ADDR_VAR 0 8
57690: PUSH
57691: LD_VAR 0 8
57695: PPUSH
57696: LD_INT 1
57698: PPUSH
57699: LD_VAR 0 9
57703: PPUSH
57704: CALL_OW 2
57708: ST_TO_ADDR
// end ;
57709: GO 57626
57711: POP
57712: POP
// for i in tmp do
57713: LD_ADDR_VAR 0 6
57717: PUSH
57718: LD_VAR 0 8
57722: PUSH
57723: FOR_IN
57724: IFFALSE 57793
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
57726: LD_VAR 0 6
57730: PPUSH
57731: CALL_OW 313
57735: PUSH
57736: LD_INT 6
57738: LESS
57739: PUSH
57740: LD_VAR 0 6
57744: PPUSH
57745: CALL_OW 266
57749: PUSH
57750: LD_INT 31
57752: PUSH
57753: LD_INT 32
57755: PUSH
57756: EMPTY
57757: LIST
57758: LIST
57759: IN
57760: NOT
57761: AND
57762: PUSH
57763: LD_VAR 0 6
57767: PPUSH
57768: CALL_OW 313
57772: PUSH
57773: LD_INT 0
57775: EQUAL
57776: OR
57777: IFFALSE 57791
// begin j := i ;
57779: LD_ADDR_VAR 0 7
57783: PUSH
57784: LD_VAR 0 6
57788: ST_TO_ADDR
// break ;
57789: GO 57793
// end ; end ;
57791: GO 57723
57793: POP
57794: POP
// if j then
57795: LD_VAR 0 7
57799: IFFALSE 57817
// ComEnterUnit ( unit , j ) else
57801: LD_VAR 0 3
57805: PPUSH
57806: LD_VAR 0 7
57810: PPUSH
57811: CALL_OW 120
57815: GO 57920
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57817: LD_ADDR_VAR 0 10
57821: PUSH
57822: LD_VAR 0 2
57826: PPUSH
57827: LD_INT 2
57829: PUSH
57830: LD_INT 30
57832: PUSH
57833: LD_INT 0
57835: PUSH
57836: EMPTY
57837: LIST
57838: LIST
57839: PUSH
57840: LD_INT 30
57842: PUSH
57843: LD_INT 1
57845: PUSH
57846: EMPTY
57847: LIST
57848: LIST
57849: PUSH
57850: EMPTY
57851: LIST
57852: LIST
57853: LIST
57854: PPUSH
57855: CALL_OW 72
57859: ST_TO_ADDR
// if depot then
57860: LD_VAR 0 10
57864: IFFALSE 57920
// begin depot := NearestUnitToUnit ( depot , unit ) ;
57866: LD_ADDR_VAR 0 10
57870: PUSH
57871: LD_VAR 0 10
57875: PPUSH
57876: LD_VAR 0 3
57880: PPUSH
57881: CALL_OW 74
57885: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
57886: LD_VAR 0 3
57890: PPUSH
57891: LD_VAR 0 10
57895: PPUSH
57896: CALL_OW 296
57900: PUSH
57901: LD_INT 10
57903: GREATER
57904: IFFALSE 57920
// ComStandNearbyBuilding ( unit , depot ) ;
57906: LD_VAR 0 3
57910: PPUSH
57911: LD_VAR 0 10
57915: PPUSH
57916: CALL 66334 0 2
// end ; end ; end ;
57920: LD_VAR 0 5
57924: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
57925: LD_INT 0
57927: PPUSH
57928: PPUSH
57929: PPUSH
57930: PPUSH
// if not mc_bases then
57931: LD_EXP 102
57935: NOT
57936: IFFALSE 57940
// exit ;
57938: GO 58179
// for i = 1 to mc_bases do
57940: LD_ADDR_VAR 0 2
57944: PUSH
57945: DOUBLE
57946: LD_INT 1
57948: DEC
57949: ST_TO_ADDR
57950: LD_EXP 102
57954: PUSH
57955: FOR_TO
57956: IFFALSE 58177
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
57958: LD_ADDR_VAR 0 4
57962: PUSH
57963: LD_EXP 102
57967: PUSH
57968: LD_VAR 0 2
57972: ARRAY
57973: PPUSH
57974: LD_INT 21
57976: PUSH
57977: LD_INT 1
57979: PUSH
57980: EMPTY
57981: LIST
57982: LIST
57983: PPUSH
57984: CALL_OW 72
57988: PUSH
57989: LD_EXP 131
57993: PUSH
57994: LD_VAR 0 2
57998: ARRAY
57999: UNION
58000: ST_TO_ADDR
// if not tmp then
58001: LD_VAR 0 4
58005: NOT
58006: IFFALSE 58010
// continue ;
58008: GO 57955
// for j in tmp do
58010: LD_ADDR_VAR 0 3
58014: PUSH
58015: LD_VAR 0 4
58019: PUSH
58020: FOR_IN
58021: IFFALSE 58173
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58023: LD_VAR 0 3
58027: PPUSH
58028: CALL_OW 110
58032: NOT
58033: PUSH
58034: LD_VAR 0 3
58038: PPUSH
58039: CALL_OW 314
58043: NOT
58044: AND
58045: PUSH
58046: LD_VAR 0 3
58050: PPUSH
58051: CALL_OW 311
58055: NOT
58056: AND
58057: PUSH
58058: LD_VAR 0 3
58062: PPUSH
58063: CALL_OW 310
58067: NOT
58068: AND
58069: PUSH
58070: LD_VAR 0 3
58074: PUSH
58075: LD_EXP 105
58079: PUSH
58080: LD_VAR 0 2
58084: ARRAY
58085: PUSH
58086: LD_INT 1
58088: ARRAY
58089: IN
58090: NOT
58091: AND
58092: PUSH
58093: LD_VAR 0 3
58097: PUSH
58098: LD_EXP 105
58102: PUSH
58103: LD_VAR 0 2
58107: ARRAY
58108: PUSH
58109: LD_INT 2
58111: ARRAY
58112: IN
58113: NOT
58114: AND
58115: PUSH
58116: LD_VAR 0 3
58120: PUSH
58121: LD_EXP 114
58125: PUSH
58126: LD_VAR 0 2
58130: ARRAY
58131: IN
58132: NOT
58133: AND
58134: IFFALSE 58171
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
58136: LD_VAR 0 2
58140: PPUSH
58141: LD_EXP 102
58145: PUSH
58146: LD_VAR 0 2
58150: ARRAY
58151: PPUSH
58152: LD_VAR 0 3
58156: PPUSH
58157: LD_VAR 0 3
58161: PPUSH
58162: CALL_OW 257
58166: PPUSH
58167: CALL 56943 0 4
// end ;
58171: GO 58020
58173: POP
58174: POP
// end ;
58175: GO 57955
58177: POP
58178: POP
// end ;
58179: LD_VAR 0 1
58183: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
58184: LD_INT 0
58186: PPUSH
58187: PPUSH
58188: PPUSH
58189: PPUSH
58190: PPUSH
58191: PPUSH
// if not mc_bases [ base ] then
58192: LD_EXP 102
58196: PUSH
58197: LD_VAR 0 1
58201: ARRAY
58202: NOT
58203: IFFALSE 58207
// exit ;
58205: GO 58389
// tmp := [ ] ;
58207: LD_ADDR_VAR 0 6
58211: PUSH
58212: EMPTY
58213: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
58214: LD_ADDR_VAR 0 7
58218: PUSH
58219: LD_VAR 0 3
58223: PPUSH
58224: LD_INT 0
58226: PPUSH
58227: CALL_OW 517
58231: ST_TO_ADDR
// if not list then
58232: LD_VAR 0 7
58236: NOT
58237: IFFALSE 58241
// exit ;
58239: GO 58389
// for i = 1 to amount do
58241: LD_ADDR_VAR 0 5
58245: PUSH
58246: DOUBLE
58247: LD_INT 1
58249: DEC
58250: ST_TO_ADDR
58251: LD_VAR 0 2
58255: PUSH
58256: FOR_TO
58257: IFFALSE 58337
// begin x := rand ( 1 , list [ 1 ] ) ;
58259: LD_ADDR_VAR 0 8
58263: PUSH
58264: LD_INT 1
58266: PPUSH
58267: LD_VAR 0 7
58271: PUSH
58272: LD_INT 1
58274: ARRAY
58275: PPUSH
58276: CALL_OW 12
58280: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
58281: LD_ADDR_VAR 0 6
58285: PUSH
58286: LD_VAR 0 6
58290: PPUSH
58291: LD_VAR 0 5
58295: PPUSH
58296: LD_VAR 0 7
58300: PUSH
58301: LD_INT 1
58303: ARRAY
58304: PUSH
58305: LD_VAR 0 8
58309: ARRAY
58310: PUSH
58311: LD_VAR 0 7
58315: PUSH
58316: LD_INT 2
58318: ARRAY
58319: PUSH
58320: LD_VAR 0 8
58324: ARRAY
58325: PUSH
58326: EMPTY
58327: LIST
58328: LIST
58329: PPUSH
58330: CALL_OW 1
58334: ST_TO_ADDR
// end ;
58335: GO 58256
58337: POP
58338: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
58339: LD_ADDR_EXP 115
58343: PUSH
58344: LD_EXP 115
58348: PPUSH
58349: LD_VAR 0 1
58353: PPUSH
58354: LD_VAR 0 6
58358: PPUSH
58359: CALL_OW 1
58363: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
58364: LD_ADDR_EXP 117
58368: PUSH
58369: LD_EXP 117
58373: PPUSH
58374: LD_VAR 0 1
58378: PPUSH
58379: LD_VAR 0 3
58383: PPUSH
58384: CALL_OW 1
58388: ST_TO_ADDR
// end ;
58389: LD_VAR 0 4
58393: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
58394: LD_INT 0
58396: PPUSH
// if not mc_bases [ base ] then
58397: LD_EXP 102
58401: PUSH
58402: LD_VAR 0 1
58406: ARRAY
58407: NOT
58408: IFFALSE 58412
// exit ;
58410: GO 58437
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
58412: LD_ADDR_EXP 107
58416: PUSH
58417: LD_EXP 107
58421: PPUSH
58422: LD_VAR 0 1
58426: PPUSH
58427: LD_VAR 0 2
58431: PPUSH
58432: CALL_OW 1
58436: ST_TO_ADDR
// end ;
58437: LD_VAR 0 3
58441: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
58442: LD_INT 0
58444: PPUSH
// if not mc_bases [ base ] then
58445: LD_EXP 102
58449: PUSH
58450: LD_VAR 0 1
58454: ARRAY
58455: NOT
58456: IFFALSE 58460
// exit ;
58458: GO 58497
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
58460: LD_ADDR_EXP 107
58464: PUSH
58465: LD_EXP 107
58469: PPUSH
58470: LD_VAR 0 1
58474: PPUSH
58475: LD_EXP 107
58479: PUSH
58480: LD_VAR 0 1
58484: ARRAY
58485: PUSH
58486: LD_VAR 0 2
58490: UNION
58491: PPUSH
58492: CALL_OW 1
58496: ST_TO_ADDR
// end ;
58497: LD_VAR 0 3
58501: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
58502: LD_INT 0
58504: PPUSH
// if not mc_bases [ base ] then
58505: LD_EXP 102
58509: PUSH
58510: LD_VAR 0 1
58514: ARRAY
58515: NOT
58516: IFFALSE 58520
// exit ;
58518: GO 58545
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
58520: LD_ADDR_EXP 123
58524: PUSH
58525: LD_EXP 123
58529: PPUSH
58530: LD_VAR 0 1
58534: PPUSH
58535: LD_VAR 0 2
58539: PPUSH
58540: CALL_OW 1
58544: ST_TO_ADDR
// end ;
58545: LD_VAR 0 3
58549: RET
// export function MC_InsertProduceList ( base , components ) ; begin
58550: LD_INT 0
58552: PPUSH
// if not mc_bases [ base ] then
58553: LD_EXP 102
58557: PUSH
58558: LD_VAR 0 1
58562: ARRAY
58563: NOT
58564: IFFALSE 58568
// exit ;
58566: GO 58605
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
58568: LD_ADDR_EXP 123
58572: PUSH
58573: LD_EXP 123
58577: PPUSH
58578: LD_VAR 0 1
58582: PPUSH
58583: LD_EXP 123
58587: PUSH
58588: LD_VAR 0 1
58592: ARRAY
58593: PUSH
58594: LD_VAR 0 2
58598: ADD
58599: PPUSH
58600: CALL_OW 1
58604: ST_TO_ADDR
// end ;
58605: LD_VAR 0 3
58609: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
58610: LD_INT 0
58612: PPUSH
// if not mc_bases [ base ] then
58613: LD_EXP 102
58617: PUSH
58618: LD_VAR 0 1
58622: ARRAY
58623: NOT
58624: IFFALSE 58628
// exit ;
58626: GO 58682
// mc_defender := Replace ( mc_defender , base , deflist ) ;
58628: LD_ADDR_EXP 124
58632: PUSH
58633: LD_EXP 124
58637: PPUSH
58638: LD_VAR 0 1
58642: PPUSH
58643: LD_VAR 0 2
58647: PPUSH
58648: CALL_OW 1
58652: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
58653: LD_ADDR_EXP 113
58657: PUSH
58658: LD_EXP 113
58662: PPUSH
58663: LD_VAR 0 1
58667: PPUSH
58668: LD_VAR 0 2
58672: PUSH
58673: LD_INT 0
58675: PLUS
58676: PPUSH
58677: CALL_OW 1
58681: ST_TO_ADDR
// end ;
58682: LD_VAR 0 3
58686: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
58687: LD_INT 0
58689: PPUSH
// if not mc_bases [ base ] then
58690: LD_EXP 102
58694: PUSH
58695: LD_VAR 0 1
58699: ARRAY
58700: NOT
58701: IFFALSE 58705
// exit ;
58703: GO 58730
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
58705: LD_ADDR_EXP 113
58709: PUSH
58710: LD_EXP 113
58714: PPUSH
58715: LD_VAR 0 1
58719: PPUSH
58720: LD_VAR 0 2
58724: PPUSH
58725: CALL_OW 1
58729: ST_TO_ADDR
// end ;
58730: LD_VAR 0 3
58734: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
58735: LD_INT 0
58737: PPUSH
58738: PPUSH
58739: PPUSH
58740: PPUSH
// if not mc_bases [ base ] then
58741: LD_EXP 102
58745: PUSH
58746: LD_VAR 0 1
58750: ARRAY
58751: NOT
58752: IFFALSE 58756
// exit ;
58754: GO 58821
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
58756: LD_ADDR_EXP 122
58760: PUSH
58761: LD_EXP 122
58765: PPUSH
58766: LD_VAR 0 1
58770: PUSH
58771: LD_EXP 122
58775: PUSH
58776: LD_VAR 0 1
58780: ARRAY
58781: PUSH
58782: LD_INT 1
58784: PLUS
58785: PUSH
58786: EMPTY
58787: LIST
58788: LIST
58789: PPUSH
58790: LD_VAR 0 1
58794: PUSH
58795: LD_VAR 0 2
58799: PUSH
58800: LD_VAR 0 3
58804: PUSH
58805: LD_VAR 0 4
58809: PUSH
58810: EMPTY
58811: LIST
58812: LIST
58813: LIST
58814: LIST
58815: PPUSH
58816: CALL 72131 0 3
58820: ST_TO_ADDR
// end ;
58821: LD_VAR 0 5
58825: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
58826: LD_INT 0
58828: PPUSH
// if not mc_bases [ base ] then
58829: LD_EXP 102
58833: PUSH
58834: LD_VAR 0 1
58838: ARRAY
58839: NOT
58840: IFFALSE 58844
// exit ;
58842: GO 58869
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
58844: LD_ADDR_EXP 139
58848: PUSH
58849: LD_EXP 139
58853: PPUSH
58854: LD_VAR 0 1
58858: PPUSH
58859: LD_VAR 0 2
58863: PPUSH
58864: CALL_OW 1
58868: ST_TO_ADDR
// end ;
58869: LD_VAR 0 3
58873: RET
// export function MC_GetMinesField ( base ) ; begin
58874: LD_INT 0
58876: PPUSH
// result := mc_mines [ base ] ;
58877: LD_ADDR_VAR 0 2
58881: PUSH
58882: LD_EXP 115
58886: PUSH
58887: LD_VAR 0 1
58891: ARRAY
58892: ST_TO_ADDR
// end ;
58893: LD_VAR 0 2
58897: RET
// export function MC_GetProduceList ( base ) ; begin
58898: LD_INT 0
58900: PPUSH
// result := mc_produce [ base ] ;
58901: LD_ADDR_VAR 0 2
58905: PUSH
58906: LD_EXP 123
58910: PUSH
58911: LD_VAR 0 1
58915: ARRAY
58916: ST_TO_ADDR
// end ;
58917: LD_VAR 0 2
58921: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
58922: LD_INT 0
58924: PPUSH
58925: PPUSH
// if not mc_bases then
58926: LD_EXP 102
58930: NOT
58931: IFFALSE 58935
// exit ;
58933: GO 59000
// if mc_bases [ base ] then
58935: LD_EXP 102
58939: PUSH
58940: LD_VAR 0 1
58944: ARRAY
58945: IFFALSE 59000
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58947: LD_ADDR_VAR 0 3
58951: PUSH
58952: LD_EXP 102
58956: PUSH
58957: LD_VAR 0 1
58961: ARRAY
58962: PPUSH
58963: LD_INT 30
58965: PUSH
58966: LD_VAR 0 2
58970: PUSH
58971: EMPTY
58972: LIST
58973: LIST
58974: PPUSH
58975: CALL_OW 72
58979: ST_TO_ADDR
// if result then
58980: LD_VAR 0 3
58984: IFFALSE 59000
// result := result [ 1 ] ;
58986: LD_ADDR_VAR 0 3
58990: PUSH
58991: LD_VAR 0 3
58995: PUSH
58996: LD_INT 1
58998: ARRAY
58999: ST_TO_ADDR
// end ; end ;
59000: LD_VAR 0 3
59004: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59005: LD_INT 0
59007: PPUSH
59008: PPUSH
// if not mc_bases then
59009: LD_EXP 102
59013: NOT
59014: IFFALSE 59018
// exit ;
59016: GO 59063
// if mc_bases [ base ] then
59018: LD_EXP 102
59022: PUSH
59023: LD_VAR 0 1
59027: ARRAY
59028: IFFALSE 59063
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59030: LD_ADDR_VAR 0 3
59034: PUSH
59035: LD_EXP 102
59039: PUSH
59040: LD_VAR 0 1
59044: ARRAY
59045: PPUSH
59046: LD_INT 30
59048: PUSH
59049: LD_VAR 0 2
59053: PUSH
59054: EMPTY
59055: LIST
59056: LIST
59057: PPUSH
59058: CALL_OW 72
59062: ST_TO_ADDR
// end ;
59063: LD_VAR 0 3
59067: RET
// export function MC_SetTame ( base , area ) ; begin
59068: LD_INT 0
59070: PPUSH
// if not mc_bases or not base then
59071: LD_EXP 102
59075: NOT
59076: PUSH
59077: LD_VAR 0 1
59081: NOT
59082: OR
59083: IFFALSE 59087
// exit ;
59085: GO 59112
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
59087: LD_ADDR_EXP 130
59091: PUSH
59092: LD_EXP 130
59096: PPUSH
59097: LD_VAR 0 1
59101: PPUSH
59102: LD_VAR 0 2
59106: PPUSH
59107: CALL_OW 1
59111: ST_TO_ADDR
// end ;
59112: LD_VAR 0 3
59116: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
59117: LD_INT 0
59119: PPUSH
59120: PPUSH
// if not mc_bases or not base then
59121: LD_EXP 102
59125: NOT
59126: PUSH
59127: LD_VAR 0 1
59131: NOT
59132: OR
59133: IFFALSE 59137
// exit ;
59135: GO 59239
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59137: LD_ADDR_VAR 0 4
59141: PUSH
59142: LD_EXP 102
59146: PUSH
59147: LD_VAR 0 1
59151: ARRAY
59152: PPUSH
59153: LD_INT 30
59155: PUSH
59156: LD_VAR 0 2
59160: PUSH
59161: EMPTY
59162: LIST
59163: LIST
59164: PPUSH
59165: CALL_OW 72
59169: ST_TO_ADDR
// if not tmp then
59170: LD_VAR 0 4
59174: NOT
59175: IFFALSE 59179
// exit ;
59177: GO 59239
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
59179: LD_ADDR_EXP 134
59183: PUSH
59184: LD_EXP 134
59188: PPUSH
59189: LD_VAR 0 1
59193: PPUSH
59194: LD_EXP 134
59198: PUSH
59199: LD_VAR 0 1
59203: ARRAY
59204: PPUSH
59205: LD_EXP 134
59209: PUSH
59210: LD_VAR 0 1
59214: ARRAY
59215: PUSH
59216: LD_INT 1
59218: PLUS
59219: PPUSH
59220: LD_VAR 0 4
59224: PUSH
59225: LD_INT 1
59227: ARRAY
59228: PPUSH
59229: CALL_OW 2
59233: PPUSH
59234: CALL_OW 1
59238: ST_TO_ADDR
// end ;
59239: LD_VAR 0 3
59243: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
59244: LD_INT 0
59246: PPUSH
59247: PPUSH
// if not mc_bases or not base or not kinds then
59248: LD_EXP 102
59252: NOT
59253: PUSH
59254: LD_VAR 0 1
59258: NOT
59259: OR
59260: PUSH
59261: LD_VAR 0 2
59265: NOT
59266: OR
59267: IFFALSE 59271
// exit ;
59269: GO 59332
// for i in kinds do
59271: LD_ADDR_VAR 0 4
59275: PUSH
59276: LD_VAR 0 2
59280: PUSH
59281: FOR_IN
59282: IFFALSE 59330
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
59284: LD_ADDR_EXP 136
59288: PUSH
59289: LD_EXP 136
59293: PPUSH
59294: LD_VAR 0 1
59298: PUSH
59299: LD_EXP 136
59303: PUSH
59304: LD_VAR 0 1
59308: ARRAY
59309: PUSH
59310: LD_INT 1
59312: PLUS
59313: PUSH
59314: EMPTY
59315: LIST
59316: LIST
59317: PPUSH
59318: LD_VAR 0 4
59322: PPUSH
59323: CALL 72131 0 3
59327: ST_TO_ADDR
59328: GO 59281
59330: POP
59331: POP
// end ;
59332: LD_VAR 0 3
59336: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
59337: LD_INT 0
59339: PPUSH
// if not mc_bases or not base or not areas then
59340: LD_EXP 102
59344: NOT
59345: PUSH
59346: LD_VAR 0 1
59350: NOT
59351: OR
59352: PUSH
59353: LD_VAR 0 2
59357: NOT
59358: OR
59359: IFFALSE 59363
// exit ;
59361: GO 59388
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
59363: LD_ADDR_EXP 120
59367: PUSH
59368: LD_EXP 120
59372: PPUSH
59373: LD_VAR 0 1
59377: PPUSH
59378: LD_VAR 0 2
59382: PPUSH
59383: CALL_OW 1
59387: ST_TO_ADDR
// end ;
59388: LD_VAR 0 3
59392: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
59393: LD_INT 0
59395: PPUSH
// if not mc_bases or not base or not teleports_exit then
59396: LD_EXP 102
59400: NOT
59401: PUSH
59402: LD_VAR 0 1
59406: NOT
59407: OR
59408: PUSH
59409: LD_VAR 0 2
59413: NOT
59414: OR
59415: IFFALSE 59419
// exit ;
59417: GO 59444
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
59419: LD_ADDR_EXP 137
59423: PUSH
59424: LD_EXP 137
59428: PPUSH
59429: LD_VAR 0 1
59433: PPUSH
59434: LD_VAR 0 2
59438: PPUSH
59439: CALL_OW 1
59443: ST_TO_ADDR
// end ;
59444: LD_VAR 0 3
59448: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
59449: LD_INT 0
59451: PPUSH
59452: PPUSH
59453: PPUSH
// if not mc_bases or not base or not ext_list then
59454: LD_EXP 102
59458: NOT
59459: PUSH
59460: LD_VAR 0 1
59464: NOT
59465: OR
59466: PUSH
59467: LD_VAR 0 5
59471: NOT
59472: OR
59473: IFFALSE 59477
// exit ;
59475: GO 59650
// tmp := GetFacExtXYD ( x , y , d ) ;
59477: LD_ADDR_VAR 0 8
59481: PUSH
59482: LD_VAR 0 2
59486: PPUSH
59487: LD_VAR 0 3
59491: PPUSH
59492: LD_VAR 0 4
59496: PPUSH
59497: CALL 105519 0 3
59501: ST_TO_ADDR
// if not tmp then
59502: LD_VAR 0 8
59506: NOT
59507: IFFALSE 59511
// exit ;
59509: GO 59650
// for i in tmp do
59511: LD_ADDR_VAR 0 7
59515: PUSH
59516: LD_VAR 0 8
59520: PUSH
59521: FOR_IN
59522: IFFALSE 59648
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
59524: LD_ADDR_EXP 107
59528: PUSH
59529: LD_EXP 107
59533: PPUSH
59534: LD_VAR 0 1
59538: PPUSH
59539: LD_EXP 107
59543: PUSH
59544: LD_VAR 0 1
59548: ARRAY
59549: PPUSH
59550: LD_EXP 107
59554: PUSH
59555: LD_VAR 0 1
59559: ARRAY
59560: PUSH
59561: LD_INT 1
59563: PLUS
59564: PPUSH
59565: LD_VAR 0 5
59569: PUSH
59570: LD_INT 1
59572: ARRAY
59573: PUSH
59574: LD_VAR 0 7
59578: PUSH
59579: LD_INT 1
59581: ARRAY
59582: PUSH
59583: LD_VAR 0 7
59587: PUSH
59588: LD_INT 2
59590: ARRAY
59591: PUSH
59592: LD_VAR 0 7
59596: PUSH
59597: LD_INT 3
59599: ARRAY
59600: PUSH
59601: EMPTY
59602: LIST
59603: LIST
59604: LIST
59605: LIST
59606: PPUSH
59607: CALL_OW 2
59611: PPUSH
59612: CALL_OW 1
59616: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
59617: LD_ADDR_VAR 0 5
59621: PUSH
59622: LD_VAR 0 5
59626: PPUSH
59627: LD_INT 1
59629: PPUSH
59630: CALL_OW 3
59634: ST_TO_ADDR
// if not ext_list then
59635: LD_VAR 0 5
59639: NOT
59640: IFFALSE 59646
// exit ;
59642: POP
59643: POP
59644: GO 59650
// end ;
59646: GO 59521
59648: POP
59649: POP
// end ;
59650: LD_VAR 0 6
59654: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
59655: LD_INT 0
59657: PPUSH
// if not mc_bases or not base or not weapon_list then
59658: LD_EXP 102
59662: NOT
59663: PUSH
59664: LD_VAR 0 1
59668: NOT
59669: OR
59670: PUSH
59671: LD_VAR 0 2
59675: NOT
59676: OR
59677: IFFALSE 59681
// exit ;
59679: GO 59706
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
59681: LD_ADDR_EXP 141
59685: PUSH
59686: LD_EXP 141
59690: PPUSH
59691: LD_VAR 0 1
59695: PPUSH
59696: LD_VAR 0 2
59700: PPUSH
59701: CALL_OW 1
59705: ST_TO_ADDR
// end ;
59706: LD_VAR 0 3
59710: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
59711: LD_INT 0
59713: PPUSH
// if not mc_bases or not base or not tech_list then
59714: LD_EXP 102
59718: NOT
59719: PUSH
59720: LD_VAR 0 1
59724: NOT
59725: OR
59726: PUSH
59727: LD_VAR 0 2
59731: NOT
59732: OR
59733: IFFALSE 59737
// exit ;
59735: GO 59762
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
59737: LD_ADDR_EXP 129
59741: PUSH
59742: LD_EXP 129
59746: PPUSH
59747: LD_VAR 0 1
59751: PPUSH
59752: LD_VAR 0 2
59756: PPUSH
59757: CALL_OW 1
59761: ST_TO_ADDR
// end ;
59762: LD_VAR 0 3
59766: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
59767: LD_INT 0
59769: PPUSH
// if not mc_bases or not parking_area or not base then
59770: LD_EXP 102
59774: NOT
59775: PUSH
59776: LD_VAR 0 2
59780: NOT
59781: OR
59782: PUSH
59783: LD_VAR 0 1
59787: NOT
59788: OR
59789: IFFALSE 59793
// exit ;
59791: GO 59818
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
59793: LD_ADDR_EXP 126
59797: PUSH
59798: LD_EXP 126
59802: PPUSH
59803: LD_VAR 0 1
59807: PPUSH
59808: LD_VAR 0 2
59812: PPUSH
59813: CALL_OW 1
59817: ST_TO_ADDR
// end ;
59818: LD_VAR 0 3
59822: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
59823: LD_INT 0
59825: PPUSH
// if not mc_bases or not base or not scan_area then
59826: LD_EXP 102
59830: NOT
59831: PUSH
59832: LD_VAR 0 1
59836: NOT
59837: OR
59838: PUSH
59839: LD_VAR 0 2
59843: NOT
59844: OR
59845: IFFALSE 59849
// exit ;
59847: GO 59874
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
59849: LD_ADDR_EXP 127
59853: PUSH
59854: LD_EXP 127
59858: PPUSH
59859: LD_VAR 0 1
59863: PPUSH
59864: LD_VAR 0 2
59868: PPUSH
59869: CALL_OW 1
59873: ST_TO_ADDR
// end ;
59874: LD_VAR 0 3
59878: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
59879: LD_INT 0
59881: PPUSH
59882: PPUSH
// if not mc_bases or not base then
59883: LD_EXP 102
59887: NOT
59888: PUSH
59889: LD_VAR 0 1
59893: NOT
59894: OR
59895: IFFALSE 59899
// exit ;
59897: GO 59963
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
59899: LD_ADDR_VAR 0 3
59903: PUSH
59904: LD_INT 1
59906: PUSH
59907: LD_INT 2
59909: PUSH
59910: LD_INT 3
59912: PUSH
59913: LD_INT 4
59915: PUSH
59916: LD_INT 11
59918: PUSH
59919: EMPTY
59920: LIST
59921: LIST
59922: LIST
59923: LIST
59924: LIST
59925: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
59926: LD_ADDR_EXP 129
59930: PUSH
59931: LD_EXP 129
59935: PPUSH
59936: LD_VAR 0 1
59940: PPUSH
59941: LD_EXP 129
59945: PUSH
59946: LD_VAR 0 1
59950: ARRAY
59951: PUSH
59952: LD_VAR 0 3
59956: DIFF
59957: PPUSH
59958: CALL_OW 1
59962: ST_TO_ADDR
// end ;
59963: LD_VAR 0 2
59967: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
59968: LD_INT 0
59970: PPUSH
// result := mc_vehicles [ base ] ;
59971: LD_ADDR_VAR 0 3
59975: PUSH
59976: LD_EXP 121
59980: PUSH
59981: LD_VAR 0 1
59985: ARRAY
59986: ST_TO_ADDR
// if onlyCombat then
59987: LD_VAR 0 2
59991: IFFALSE 60156
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
59993: LD_ADDR_VAR 0 3
59997: PUSH
59998: LD_VAR 0 3
60002: PUSH
60003: LD_VAR 0 3
60007: PPUSH
60008: LD_INT 2
60010: PUSH
60011: LD_INT 34
60013: PUSH
60014: LD_INT 12
60016: PUSH
60017: EMPTY
60018: LIST
60019: LIST
60020: PUSH
60021: LD_INT 34
60023: PUSH
60024: LD_INT 51
60026: PUSH
60027: EMPTY
60028: LIST
60029: LIST
60030: PUSH
60031: LD_INT 34
60033: PUSH
60034: LD_EXP 96
60038: PUSH
60039: EMPTY
60040: LIST
60041: LIST
60042: PUSH
60043: LD_INT 34
60045: PUSH
60046: LD_INT 32
60048: PUSH
60049: EMPTY
60050: LIST
60051: LIST
60052: PUSH
60053: LD_INT 34
60055: PUSH
60056: LD_INT 13
60058: PUSH
60059: EMPTY
60060: LIST
60061: LIST
60062: PUSH
60063: LD_INT 34
60065: PUSH
60066: LD_INT 52
60068: PUSH
60069: EMPTY
60070: LIST
60071: LIST
60072: PUSH
60073: LD_INT 34
60075: PUSH
60076: LD_INT 14
60078: PUSH
60079: EMPTY
60080: LIST
60081: LIST
60082: PUSH
60083: LD_INT 34
60085: PUSH
60086: LD_INT 53
60088: PUSH
60089: EMPTY
60090: LIST
60091: LIST
60092: PUSH
60093: LD_INT 34
60095: PUSH
60096: LD_EXP 95
60100: PUSH
60101: EMPTY
60102: LIST
60103: LIST
60104: PUSH
60105: LD_INT 34
60107: PUSH
60108: LD_INT 31
60110: PUSH
60111: EMPTY
60112: LIST
60113: LIST
60114: PUSH
60115: LD_INT 34
60117: PUSH
60118: LD_INT 48
60120: PUSH
60121: EMPTY
60122: LIST
60123: LIST
60124: PUSH
60125: LD_INT 34
60127: PUSH
60128: LD_INT 8
60130: PUSH
60131: EMPTY
60132: LIST
60133: LIST
60134: PUSH
60135: EMPTY
60136: LIST
60137: LIST
60138: LIST
60139: LIST
60140: LIST
60141: LIST
60142: LIST
60143: LIST
60144: LIST
60145: LIST
60146: LIST
60147: LIST
60148: LIST
60149: PPUSH
60150: CALL_OW 72
60154: DIFF
60155: ST_TO_ADDR
// end ; end_of_file
60156: LD_VAR 0 3
60160: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
60161: LD_INT 0
60163: PPUSH
60164: PPUSH
60165: PPUSH
// if not mc_bases or not skirmish then
60166: LD_EXP 102
60170: NOT
60171: PUSH
60172: LD_EXP 100
60176: NOT
60177: OR
60178: IFFALSE 60182
// exit ;
60180: GO 60347
// for i = 1 to mc_bases do
60182: LD_ADDR_VAR 0 4
60186: PUSH
60187: DOUBLE
60188: LD_INT 1
60190: DEC
60191: ST_TO_ADDR
60192: LD_EXP 102
60196: PUSH
60197: FOR_TO
60198: IFFALSE 60345
// begin if sci in mc_bases [ i ] then
60200: LD_VAR 0 2
60204: PUSH
60205: LD_EXP 102
60209: PUSH
60210: LD_VAR 0 4
60214: ARRAY
60215: IN
60216: IFFALSE 60343
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
60218: LD_ADDR_EXP 131
60222: PUSH
60223: LD_EXP 131
60227: PPUSH
60228: LD_VAR 0 4
60232: PUSH
60233: LD_EXP 131
60237: PUSH
60238: LD_VAR 0 4
60242: ARRAY
60243: PUSH
60244: LD_INT 1
60246: PLUS
60247: PUSH
60248: EMPTY
60249: LIST
60250: LIST
60251: PPUSH
60252: LD_VAR 0 1
60256: PPUSH
60257: CALL 72131 0 3
60261: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
60262: LD_ADDR_VAR 0 5
60266: PUSH
60267: LD_EXP 102
60271: PUSH
60272: LD_VAR 0 4
60276: ARRAY
60277: PPUSH
60278: LD_INT 2
60280: PUSH
60281: LD_INT 30
60283: PUSH
60284: LD_INT 0
60286: PUSH
60287: EMPTY
60288: LIST
60289: LIST
60290: PUSH
60291: LD_INT 30
60293: PUSH
60294: LD_INT 1
60296: PUSH
60297: EMPTY
60298: LIST
60299: LIST
60300: PUSH
60301: EMPTY
60302: LIST
60303: LIST
60304: LIST
60305: PPUSH
60306: CALL_OW 72
60310: PPUSH
60311: LD_VAR 0 1
60315: PPUSH
60316: CALL_OW 74
60320: ST_TO_ADDR
// if tmp then
60321: LD_VAR 0 5
60325: IFFALSE 60341
// ComStandNearbyBuilding ( ape , tmp ) ;
60327: LD_VAR 0 1
60331: PPUSH
60332: LD_VAR 0 5
60336: PPUSH
60337: CALL 66334 0 2
// break ;
60341: GO 60345
// end ; end ;
60343: GO 60197
60345: POP
60346: POP
// end ;
60347: LD_VAR 0 3
60351: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
60352: LD_INT 0
60354: PPUSH
60355: PPUSH
60356: PPUSH
// if not mc_bases or not skirmish then
60357: LD_EXP 102
60361: NOT
60362: PUSH
60363: LD_EXP 100
60367: NOT
60368: OR
60369: IFFALSE 60373
// exit ;
60371: GO 60462
// for i = 1 to mc_bases do
60373: LD_ADDR_VAR 0 4
60377: PUSH
60378: DOUBLE
60379: LD_INT 1
60381: DEC
60382: ST_TO_ADDR
60383: LD_EXP 102
60387: PUSH
60388: FOR_TO
60389: IFFALSE 60460
// begin if building in mc_busy_turret_list [ i ] then
60391: LD_VAR 0 1
60395: PUSH
60396: LD_EXP 112
60400: PUSH
60401: LD_VAR 0 4
60405: ARRAY
60406: IN
60407: IFFALSE 60458
// begin tmp := mc_busy_turret_list [ i ] diff building ;
60409: LD_ADDR_VAR 0 5
60413: PUSH
60414: LD_EXP 112
60418: PUSH
60419: LD_VAR 0 4
60423: ARRAY
60424: PUSH
60425: LD_VAR 0 1
60429: DIFF
60430: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
60431: LD_ADDR_EXP 112
60435: PUSH
60436: LD_EXP 112
60440: PPUSH
60441: LD_VAR 0 4
60445: PPUSH
60446: LD_VAR 0 5
60450: PPUSH
60451: CALL_OW 1
60455: ST_TO_ADDR
// break ;
60456: GO 60460
// end ; end ;
60458: GO 60388
60460: POP
60461: POP
// end ;
60462: LD_VAR 0 3
60466: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
60467: LD_INT 0
60469: PPUSH
60470: PPUSH
60471: PPUSH
// if not mc_bases or not skirmish then
60472: LD_EXP 102
60476: NOT
60477: PUSH
60478: LD_EXP 100
60482: NOT
60483: OR
60484: IFFALSE 60488
// exit ;
60486: GO 60687
// for i = 1 to mc_bases do
60488: LD_ADDR_VAR 0 5
60492: PUSH
60493: DOUBLE
60494: LD_INT 1
60496: DEC
60497: ST_TO_ADDR
60498: LD_EXP 102
60502: PUSH
60503: FOR_TO
60504: IFFALSE 60685
// if building in mc_bases [ i ] then
60506: LD_VAR 0 1
60510: PUSH
60511: LD_EXP 102
60515: PUSH
60516: LD_VAR 0 5
60520: ARRAY
60521: IN
60522: IFFALSE 60683
// begin tmp := mc_bases [ i ] diff building ;
60524: LD_ADDR_VAR 0 6
60528: PUSH
60529: LD_EXP 102
60533: PUSH
60534: LD_VAR 0 5
60538: ARRAY
60539: PUSH
60540: LD_VAR 0 1
60544: DIFF
60545: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
60546: LD_ADDR_EXP 102
60550: PUSH
60551: LD_EXP 102
60555: PPUSH
60556: LD_VAR 0 5
60560: PPUSH
60561: LD_VAR 0 6
60565: PPUSH
60566: CALL_OW 1
60570: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
60571: LD_VAR 0 1
60575: PUSH
60576: LD_EXP 110
60580: PUSH
60581: LD_VAR 0 5
60585: ARRAY
60586: IN
60587: IFFALSE 60626
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
60589: LD_ADDR_EXP 110
60593: PUSH
60594: LD_EXP 110
60598: PPUSH
60599: LD_VAR 0 5
60603: PPUSH
60604: LD_EXP 110
60608: PUSH
60609: LD_VAR 0 5
60613: ARRAY
60614: PUSH
60615: LD_VAR 0 1
60619: DIFF
60620: PPUSH
60621: CALL_OW 1
60625: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
60626: LD_VAR 0 1
60630: PUSH
60631: LD_EXP 111
60635: PUSH
60636: LD_VAR 0 5
60640: ARRAY
60641: IN
60642: IFFALSE 60681
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
60644: LD_ADDR_EXP 111
60648: PUSH
60649: LD_EXP 111
60653: PPUSH
60654: LD_VAR 0 5
60658: PPUSH
60659: LD_EXP 111
60663: PUSH
60664: LD_VAR 0 5
60668: ARRAY
60669: PUSH
60670: LD_VAR 0 1
60674: DIFF
60675: PPUSH
60676: CALL_OW 1
60680: ST_TO_ADDR
// break ;
60681: GO 60685
// end ;
60683: GO 60503
60685: POP
60686: POP
// end ;
60687: LD_VAR 0 4
60691: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
60692: LD_INT 0
60694: PPUSH
60695: PPUSH
60696: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
60697: LD_EXP 102
60701: NOT
60702: PUSH
60703: LD_EXP 100
60707: NOT
60708: OR
60709: PUSH
60710: LD_VAR 0 3
60714: PUSH
60715: LD_EXP 128
60719: IN
60720: NOT
60721: OR
60722: IFFALSE 60726
// exit ;
60724: GO 60849
// for i = 1 to mc_vehicles do
60726: LD_ADDR_VAR 0 6
60730: PUSH
60731: DOUBLE
60732: LD_INT 1
60734: DEC
60735: ST_TO_ADDR
60736: LD_EXP 121
60740: PUSH
60741: FOR_TO
60742: IFFALSE 60847
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
60744: LD_VAR 0 2
60748: PUSH
60749: LD_EXP 121
60753: PUSH
60754: LD_VAR 0 6
60758: ARRAY
60759: IN
60760: PUSH
60761: LD_VAR 0 1
60765: PUSH
60766: LD_EXP 121
60770: PUSH
60771: LD_VAR 0 6
60775: ARRAY
60776: IN
60777: OR
60778: IFFALSE 60845
// begin tmp := mc_vehicles [ i ] diff old ;
60780: LD_ADDR_VAR 0 7
60784: PUSH
60785: LD_EXP 121
60789: PUSH
60790: LD_VAR 0 6
60794: ARRAY
60795: PUSH
60796: LD_VAR 0 2
60800: DIFF
60801: ST_TO_ADDR
// tmp := tmp diff new ;
60802: LD_ADDR_VAR 0 7
60806: PUSH
60807: LD_VAR 0 7
60811: PUSH
60812: LD_VAR 0 1
60816: DIFF
60817: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
60818: LD_ADDR_EXP 121
60822: PUSH
60823: LD_EXP 121
60827: PPUSH
60828: LD_VAR 0 6
60832: PPUSH
60833: LD_VAR 0 7
60837: PPUSH
60838: CALL_OW 1
60842: ST_TO_ADDR
// break ;
60843: GO 60847
// end ;
60845: GO 60741
60847: POP
60848: POP
// end ;
60849: LD_VAR 0 5
60853: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
60854: LD_INT 0
60856: PPUSH
60857: PPUSH
60858: PPUSH
60859: PPUSH
// if not mc_bases or not skirmish then
60860: LD_EXP 102
60864: NOT
60865: PUSH
60866: LD_EXP 100
60870: NOT
60871: OR
60872: IFFALSE 60876
// exit ;
60874: GO 61253
// side := GetSide ( vehicle ) ;
60876: LD_ADDR_VAR 0 5
60880: PUSH
60881: LD_VAR 0 1
60885: PPUSH
60886: CALL_OW 255
60890: ST_TO_ADDR
// for i = 1 to mc_bases do
60891: LD_ADDR_VAR 0 4
60895: PUSH
60896: DOUBLE
60897: LD_INT 1
60899: DEC
60900: ST_TO_ADDR
60901: LD_EXP 102
60905: PUSH
60906: FOR_TO
60907: IFFALSE 61251
// begin if factory in mc_bases [ i ] then
60909: LD_VAR 0 2
60913: PUSH
60914: LD_EXP 102
60918: PUSH
60919: LD_VAR 0 4
60923: ARRAY
60924: IN
60925: IFFALSE 61249
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
60927: LD_EXP 124
60931: PUSH
60932: LD_VAR 0 4
60936: ARRAY
60937: PUSH
60938: LD_EXP 113
60942: PUSH
60943: LD_VAR 0 4
60947: ARRAY
60948: LESS
60949: PUSH
60950: LD_VAR 0 1
60954: PPUSH
60955: CALL_OW 264
60959: PUSH
60960: LD_INT 31
60962: PUSH
60963: LD_INT 32
60965: PUSH
60966: LD_INT 51
60968: PUSH
60969: LD_EXP 96
60973: PUSH
60974: LD_INT 12
60976: PUSH
60977: LD_INT 30
60979: PUSH
60980: LD_EXP 95
60984: PUSH
60985: LD_INT 11
60987: PUSH
60988: LD_INT 53
60990: PUSH
60991: LD_INT 14
60993: PUSH
60994: LD_EXP 99
60998: PUSH
60999: LD_INT 29
61001: PUSH
61002: LD_EXP 97
61006: PUSH
61007: LD_INT 13
61009: PUSH
61010: LD_INT 52
61012: PUSH
61013: LD_INT 48
61015: PUSH
61016: LD_INT 8
61018: PUSH
61019: EMPTY
61020: LIST
61021: LIST
61022: LIST
61023: LIST
61024: LIST
61025: LIST
61026: LIST
61027: LIST
61028: LIST
61029: LIST
61030: LIST
61031: LIST
61032: LIST
61033: LIST
61034: LIST
61035: LIST
61036: LIST
61037: IN
61038: NOT
61039: AND
61040: IFFALSE 61088
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
61042: LD_ADDR_EXP 124
61046: PUSH
61047: LD_EXP 124
61051: PPUSH
61052: LD_VAR 0 4
61056: PUSH
61057: LD_EXP 124
61061: PUSH
61062: LD_VAR 0 4
61066: ARRAY
61067: PUSH
61068: LD_INT 1
61070: PLUS
61071: PUSH
61072: EMPTY
61073: LIST
61074: LIST
61075: PPUSH
61076: LD_VAR 0 1
61080: PPUSH
61081: CALL 72131 0 3
61085: ST_TO_ADDR
61086: GO 61132
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
61088: LD_ADDR_EXP 121
61092: PUSH
61093: LD_EXP 121
61097: PPUSH
61098: LD_VAR 0 4
61102: PUSH
61103: LD_EXP 121
61107: PUSH
61108: LD_VAR 0 4
61112: ARRAY
61113: PUSH
61114: LD_INT 1
61116: PLUS
61117: PUSH
61118: EMPTY
61119: LIST
61120: LIST
61121: PPUSH
61122: LD_VAR 0 1
61126: PPUSH
61127: CALL 72131 0 3
61131: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
61132: LD_VAR 0 1
61136: PPUSH
61137: CALL_OW 263
61141: PUSH
61142: LD_INT 2
61144: EQUAL
61145: IFFALSE 61165
// begin repeat wait ( 0 0$1 ) ;
61147: LD_INT 35
61149: PPUSH
61150: CALL_OW 67
// until IsControledBy ( vehicle ) ;
61154: LD_VAR 0 1
61158: PPUSH
61159: CALL_OW 312
61163: IFFALSE 61147
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
61165: LD_VAR 0 1
61169: PPUSH
61170: LD_EXP 126
61174: PUSH
61175: LD_VAR 0 4
61179: ARRAY
61180: PPUSH
61181: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
61185: LD_VAR 0 1
61189: PPUSH
61190: CALL_OW 263
61194: PUSH
61195: LD_INT 1
61197: NONEQUAL
61198: IFFALSE 61202
// break ;
61200: GO 61251
// repeat wait ( 0 0$1 ) ;
61202: LD_INT 35
61204: PPUSH
61205: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
61209: LD_VAR 0 1
61213: PPUSH
61214: LD_EXP 126
61218: PUSH
61219: LD_VAR 0 4
61223: ARRAY
61224: PPUSH
61225: CALL_OW 308
61229: IFFALSE 61202
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
61231: LD_VAR 0 1
61235: PPUSH
61236: CALL_OW 311
61240: PPUSH
61241: CALL_OW 121
// exit ;
61245: POP
61246: POP
61247: GO 61253
// end ; end ;
61249: GO 60906
61251: POP
61252: POP
// end ;
61253: LD_VAR 0 3
61257: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
61258: LD_INT 0
61260: PPUSH
61261: PPUSH
61262: PPUSH
61263: PPUSH
// if not mc_bases or not skirmish then
61264: LD_EXP 102
61268: NOT
61269: PUSH
61270: LD_EXP 100
61274: NOT
61275: OR
61276: IFFALSE 61280
// exit ;
61278: GO 61633
// repeat wait ( 0 0$1 ) ;
61280: LD_INT 35
61282: PPUSH
61283: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
61287: LD_VAR 0 2
61291: PPUSH
61292: LD_VAR 0 3
61296: PPUSH
61297: CALL_OW 284
61301: IFFALSE 61280
// if GetResourceTypeXY ( x , y ) = mat_artefact then
61303: LD_VAR 0 2
61307: PPUSH
61308: LD_VAR 0 3
61312: PPUSH
61313: CALL_OW 283
61317: PUSH
61318: LD_INT 4
61320: EQUAL
61321: IFFALSE 61325
// exit ;
61323: GO 61633
// for i = 1 to mc_bases do
61325: LD_ADDR_VAR 0 7
61329: PUSH
61330: DOUBLE
61331: LD_INT 1
61333: DEC
61334: ST_TO_ADDR
61335: LD_EXP 102
61339: PUSH
61340: FOR_TO
61341: IFFALSE 61631
// begin if mc_crates_area [ i ] then
61343: LD_EXP 120
61347: PUSH
61348: LD_VAR 0 7
61352: ARRAY
61353: IFFALSE 61464
// for j in mc_crates_area [ i ] do
61355: LD_ADDR_VAR 0 8
61359: PUSH
61360: LD_EXP 120
61364: PUSH
61365: LD_VAR 0 7
61369: ARRAY
61370: PUSH
61371: FOR_IN
61372: IFFALSE 61462
// if InArea ( x , y , j ) then
61374: LD_VAR 0 2
61378: PPUSH
61379: LD_VAR 0 3
61383: PPUSH
61384: LD_VAR 0 8
61388: PPUSH
61389: CALL_OW 309
61393: IFFALSE 61460
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61395: LD_ADDR_EXP 118
61399: PUSH
61400: LD_EXP 118
61404: PPUSH
61405: LD_VAR 0 7
61409: PUSH
61410: LD_EXP 118
61414: PUSH
61415: LD_VAR 0 7
61419: ARRAY
61420: PUSH
61421: LD_INT 1
61423: PLUS
61424: PUSH
61425: EMPTY
61426: LIST
61427: LIST
61428: PPUSH
61429: LD_VAR 0 4
61433: PUSH
61434: LD_VAR 0 2
61438: PUSH
61439: LD_VAR 0 3
61443: PUSH
61444: EMPTY
61445: LIST
61446: LIST
61447: LIST
61448: PPUSH
61449: CALL 72131 0 3
61453: ST_TO_ADDR
// exit ;
61454: POP
61455: POP
61456: POP
61457: POP
61458: GO 61633
// end ;
61460: GO 61371
61462: POP
61463: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61464: LD_ADDR_VAR 0 9
61468: PUSH
61469: LD_EXP 102
61473: PUSH
61474: LD_VAR 0 7
61478: ARRAY
61479: PPUSH
61480: LD_INT 2
61482: PUSH
61483: LD_INT 30
61485: PUSH
61486: LD_INT 0
61488: PUSH
61489: EMPTY
61490: LIST
61491: LIST
61492: PUSH
61493: LD_INT 30
61495: PUSH
61496: LD_INT 1
61498: PUSH
61499: EMPTY
61500: LIST
61501: LIST
61502: PUSH
61503: EMPTY
61504: LIST
61505: LIST
61506: LIST
61507: PPUSH
61508: CALL_OW 72
61512: ST_TO_ADDR
// if not depot then
61513: LD_VAR 0 9
61517: NOT
61518: IFFALSE 61522
// continue ;
61520: GO 61340
// for j in depot do
61522: LD_ADDR_VAR 0 8
61526: PUSH
61527: LD_VAR 0 9
61531: PUSH
61532: FOR_IN
61533: IFFALSE 61627
// if GetDistUnitXY ( j , x , y ) < 30 then
61535: LD_VAR 0 8
61539: PPUSH
61540: LD_VAR 0 2
61544: PPUSH
61545: LD_VAR 0 3
61549: PPUSH
61550: CALL_OW 297
61554: PUSH
61555: LD_INT 30
61557: LESS
61558: IFFALSE 61625
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61560: LD_ADDR_EXP 118
61564: PUSH
61565: LD_EXP 118
61569: PPUSH
61570: LD_VAR 0 7
61574: PUSH
61575: LD_EXP 118
61579: PUSH
61580: LD_VAR 0 7
61584: ARRAY
61585: PUSH
61586: LD_INT 1
61588: PLUS
61589: PUSH
61590: EMPTY
61591: LIST
61592: LIST
61593: PPUSH
61594: LD_VAR 0 4
61598: PUSH
61599: LD_VAR 0 2
61603: PUSH
61604: LD_VAR 0 3
61608: PUSH
61609: EMPTY
61610: LIST
61611: LIST
61612: LIST
61613: PPUSH
61614: CALL 72131 0 3
61618: ST_TO_ADDR
// exit ;
61619: POP
61620: POP
61621: POP
61622: POP
61623: GO 61633
// end ;
61625: GO 61532
61627: POP
61628: POP
// end ;
61629: GO 61340
61631: POP
61632: POP
// end ;
61633: LD_VAR 0 6
61637: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
61638: LD_INT 0
61640: PPUSH
61641: PPUSH
61642: PPUSH
61643: PPUSH
// if not mc_bases or not skirmish then
61644: LD_EXP 102
61648: NOT
61649: PUSH
61650: LD_EXP 100
61654: NOT
61655: OR
61656: IFFALSE 61660
// exit ;
61658: GO 61937
// side := GetSide ( lab ) ;
61660: LD_ADDR_VAR 0 4
61664: PUSH
61665: LD_VAR 0 2
61669: PPUSH
61670: CALL_OW 255
61674: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
61675: LD_VAR 0 4
61679: PUSH
61680: LD_EXP 128
61684: IN
61685: NOT
61686: PUSH
61687: LD_EXP 129
61691: NOT
61692: OR
61693: PUSH
61694: LD_EXP 102
61698: NOT
61699: OR
61700: IFFALSE 61704
// exit ;
61702: GO 61937
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
61704: LD_ADDR_EXP 129
61708: PUSH
61709: LD_EXP 129
61713: PPUSH
61714: LD_VAR 0 4
61718: PPUSH
61719: LD_EXP 129
61723: PUSH
61724: LD_VAR 0 4
61728: ARRAY
61729: PUSH
61730: LD_VAR 0 1
61734: DIFF
61735: PPUSH
61736: CALL_OW 1
61740: ST_TO_ADDR
// for i = 1 to mc_bases do
61741: LD_ADDR_VAR 0 5
61745: PUSH
61746: DOUBLE
61747: LD_INT 1
61749: DEC
61750: ST_TO_ADDR
61751: LD_EXP 102
61755: PUSH
61756: FOR_TO
61757: IFFALSE 61935
// begin if lab in mc_bases [ i ] then
61759: LD_VAR 0 2
61763: PUSH
61764: LD_EXP 102
61768: PUSH
61769: LD_VAR 0 5
61773: ARRAY
61774: IN
61775: IFFALSE 61933
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
61777: LD_VAR 0 1
61781: PUSH
61782: LD_INT 11
61784: PUSH
61785: LD_INT 4
61787: PUSH
61788: LD_INT 3
61790: PUSH
61791: LD_INT 2
61793: PUSH
61794: EMPTY
61795: LIST
61796: LIST
61797: LIST
61798: LIST
61799: IN
61800: PUSH
61801: LD_EXP 132
61805: PUSH
61806: LD_VAR 0 5
61810: ARRAY
61811: AND
61812: IFFALSE 61933
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
61814: LD_ADDR_VAR 0 6
61818: PUSH
61819: LD_EXP 132
61823: PUSH
61824: LD_VAR 0 5
61828: ARRAY
61829: PUSH
61830: LD_INT 1
61832: ARRAY
61833: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61834: LD_ADDR_EXP 132
61838: PUSH
61839: LD_EXP 132
61843: PPUSH
61844: LD_VAR 0 5
61848: PPUSH
61849: EMPTY
61850: PPUSH
61851: CALL_OW 1
61855: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
61856: LD_VAR 0 6
61860: PPUSH
61861: LD_INT 0
61863: PPUSH
61864: CALL_OW 109
// ComExitBuilding ( tmp ) ;
61868: LD_VAR 0 6
61872: PPUSH
61873: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
61877: LD_ADDR_EXP 131
61881: PUSH
61882: LD_EXP 131
61886: PPUSH
61887: LD_VAR 0 5
61891: PPUSH
61892: LD_EXP 131
61896: PUSH
61897: LD_VAR 0 5
61901: ARRAY
61902: PPUSH
61903: LD_INT 1
61905: PPUSH
61906: LD_VAR 0 6
61910: PPUSH
61911: CALL_OW 2
61915: PPUSH
61916: CALL_OW 1
61920: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
61921: LD_VAR 0 5
61925: PPUSH
61926: LD_INT 112
61928: PPUSH
61929: CALL 38933 0 2
// end ; end ; end ;
61933: GO 61756
61935: POP
61936: POP
// end ;
61937: LD_VAR 0 3
61941: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
61942: LD_INT 0
61944: PPUSH
61945: PPUSH
61946: PPUSH
61947: PPUSH
61948: PPUSH
61949: PPUSH
61950: PPUSH
61951: PPUSH
// if not mc_bases or not skirmish then
61952: LD_EXP 102
61956: NOT
61957: PUSH
61958: LD_EXP 100
61962: NOT
61963: OR
61964: IFFALSE 61968
// exit ;
61966: GO 63339
// for i = 1 to mc_bases do
61968: LD_ADDR_VAR 0 3
61972: PUSH
61973: DOUBLE
61974: LD_INT 1
61976: DEC
61977: ST_TO_ADDR
61978: LD_EXP 102
61982: PUSH
61983: FOR_TO
61984: IFFALSE 63337
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
61986: LD_VAR 0 1
61990: PUSH
61991: LD_EXP 102
61995: PUSH
61996: LD_VAR 0 3
62000: ARRAY
62001: IN
62002: PUSH
62003: LD_VAR 0 1
62007: PUSH
62008: LD_EXP 109
62012: PUSH
62013: LD_VAR 0 3
62017: ARRAY
62018: IN
62019: OR
62020: PUSH
62021: LD_VAR 0 1
62025: PUSH
62026: LD_EXP 124
62030: PUSH
62031: LD_VAR 0 3
62035: ARRAY
62036: IN
62037: OR
62038: PUSH
62039: LD_VAR 0 1
62043: PUSH
62044: LD_EXP 121
62048: PUSH
62049: LD_VAR 0 3
62053: ARRAY
62054: IN
62055: OR
62056: PUSH
62057: LD_VAR 0 1
62061: PUSH
62062: LD_EXP 131
62066: PUSH
62067: LD_VAR 0 3
62071: ARRAY
62072: IN
62073: OR
62074: PUSH
62075: LD_VAR 0 1
62079: PUSH
62080: LD_EXP 132
62084: PUSH
62085: LD_VAR 0 3
62089: ARRAY
62090: IN
62091: OR
62092: IFFALSE 63335
// begin if un in mc_ape [ i ] then
62094: LD_VAR 0 1
62098: PUSH
62099: LD_EXP 131
62103: PUSH
62104: LD_VAR 0 3
62108: ARRAY
62109: IN
62110: IFFALSE 62149
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
62112: LD_ADDR_EXP 131
62116: PUSH
62117: LD_EXP 131
62121: PPUSH
62122: LD_VAR 0 3
62126: PPUSH
62127: LD_EXP 131
62131: PUSH
62132: LD_VAR 0 3
62136: ARRAY
62137: PUSH
62138: LD_VAR 0 1
62142: DIFF
62143: PPUSH
62144: CALL_OW 1
62148: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
62149: LD_VAR 0 1
62153: PUSH
62154: LD_EXP 132
62158: PUSH
62159: LD_VAR 0 3
62163: ARRAY
62164: IN
62165: IFFALSE 62189
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62167: LD_ADDR_EXP 132
62171: PUSH
62172: LD_EXP 132
62176: PPUSH
62177: LD_VAR 0 3
62181: PPUSH
62182: EMPTY
62183: PPUSH
62184: CALL_OW 1
62188: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
62189: LD_VAR 0 1
62193: PPUSH
62194: CALL_OW 247
62198: PUSH
62199: LD_INT 2
62201: EQUAL
62202: PUSH
62203: LD_VAR 0 1
62207: PPUSH
62208: CALL_OW 110
62212: PUSH
62213: LD_INT 20
62215: EQUAL
62216: PUSH
62217: LD_VAR 0 1
62221: PUSH
62222: LD_EXP 124
62226: PUSH
62227: LD_VAR 0 3
62231: ARRAY
62232: IN
62233: OR
62234: PUSH
62235: LD_VAR 0 1
62239: PPUSH
62240: CALL_OW 264
62244: PUSH
62245: LD_INT 12
62247: PUSH
62248: LD_INT 51
62250: PUSH
62251: LD_EXP 96
62255: PUSH
62256: LD_INT 32
62258: PUSH
62259: LD_INT 13
62261: PUSH
62262: LD_INT 52
62264: PUSH
62265: LD_INT 31
62267: PUSH
62268: EMPTY
62269: LIST
62270: LIST
62271: LIST
62272: LIST
62273: LIST
62274: LIST
62275: LIST
62276: IN
62277: OR
62278: AND
62279: IFFALSE 62587
// begin if un in mc_defender [ i ] then
62281: LD_VAR 0 1
62285: PUSH
62286: LD_EXP 124
62290: PUSH
62291: LD_VAR 0 3
62295: ARRAY
62296: IN
62297: IFFALSE 62336
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62299: LD_ADDR_EXP 124
62303: PUSH
62304: LD_EXP 124
62308: PPUSH
62309: LD_VAR 0 3
62313: PPUSH
62314: LD_EXP 124
62318: PUSH
62319: LD_VAR 0 3
62323: ARRAY
62324: PUSH
62325: LD_VAR 0 1
62329: DIFF
62330: PPUSH
62331: CALL_OW 1
62335: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
62336: LD_ADDR_VAR 0 8
62340: PUSH
62341: LD_VAR 0 3
62345: PPUSH
62346: LD_INT 3
62348: PPUSH
62349: CALL 59005 0 2
62353: ST_TO_ADDR
// if fac then
62354: LD_VAR 0 8
62358: IFFALSE 62587
// begin for j in fac do
62360: LD_ADDR_VAR 0 4
62364: PUSH
62365: LD_VAR 0 8
62369: PUSH
62370: FOR_IN
62371: IFFALSE 62585
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
62373: LD_ADDR_VAR 0 9
62377: PUSH
62378: LD_VAR 0 8
62382: PPUSH
62383: LD_VAR 0 1
62387: PPUSH
62388: CALL_OW 265
62392: PPUSH
62393: LD_VAR 0 1
62397: PPUSH
62398: CALL_OW 262
62402: PPUSH
62403: LD_VAR 0 1
62407: PPUSH
62408: CALL_OW 263
62412: PPUSH
62413: LD_VAR 0 1
62417: PPUSH
62418: CALL_OW 264
62422: PPUSH
62423: CALL 69663 0 5
62427: ST_TO_ADDR
// if components then
62428: LD_VAR 0 9
62432: IFFALSE 62583
// begin if GetWeapon ( un ) = ar_control_tower then
62434: LD_VAR 0 1
62438: PPUSH
62439: CALL_OW 264
62443: PUSH
62444: LD_INT 31
62446: EQUAL
62447: IFFALSE 62564
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
62449: LD_VAR 0 1
62453: PPUSH
62454: CALL_OW 311
62458: PPUSH
62459: LD_INT 0
62461: PPUSH
62462: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
62466: LD_ADDR_EXP 142
62470: PUSH
62471: LD_EXP 142
62475: PPUSH
62476: LD_VAR 0 3
62480: PPUSH
62481: LD_EXP 142
62485: PUSH
62486: LD_VAR 0 3
62490: ARRAY
62491: PUSH
62492: LD_VAR 0 1
62496: PPUSH
62497: CALL_OW 311
62501: DIFF
62502: PPUSH
62503: CALL_OW 1
62507: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
62508: LD_ADDR_VAR 0 7
62512: PUSH
62513: LD_EXP 123
62517: PUSH
62518: LD_VAR 0 3
62522: ARRAY
62523: PPUSH
62524: LD_INT 1
62526: PPUSH
62527: LD_VAR 0 9
62531: PPUSH
62532: CALL_OW 2
62536: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62537: LD_ADDR_EXP 123
62541: PUSH
62542: LD_EXP 123
62546: PPUSH
62547: LD_VAR 0 3
62551: PPUSH
62552: LD_VAR 0 7
62556: PPUSH
62557: CALL_OW 1
62561: ST_TO_ADDR
// end else
62562: GO 62581
// MC_InsertProduceList ( i , [ components ] ) ;
62564: LD_VAR 0 3
62568: PPUSH
62569: LD_VAR 0 9
62573: PUSH
62574: EMPTY
62575: LIST
62576: PPUSH
62577: CALL 58550 0 2
// break ;
62581: GO 62585
// end ; end ;
62583: GO 62370
62585: POP
62586: POP
// end ; end ; if GetType ( un ) = unit_building then
62587: LD_VAR 0 1
62591: PPUSH
62592: CALL_OW 247
62596: PUSH
62597: LD_INT 3
62599: EQUAL
62600: IFFALSE 63003
// begin btype := GetBType ( un ) ;
62602: LD_ADDR_VAR 0 5
62606: PUSH
62607: LD_VAR 0 1
62611: PPUSH
62612: CALL_OW 266
62616: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
62617: LD_VAR 0 5
62621: PUSH
62622: LD_INT 29
62624: PUSH
62625: LD_INT 30
62627: PUSH
62628: EMPTY
62629: LIST
62630: LIST
62631: IN
62632: IFFALSE 62705
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
62634: LD_VAR 0 1
62638: PPUSH
62639: CALL_OW 250
62643: PPUSH
62644: LD_VAR 0 1
62648: PPUSH
62649: CALL_OW 251
62653: PPUSH
62654: LD_VAR 0 1
62658: PPUSH
62659: CALL_OW 255
62663: PPUSH
62664: CALL_OW 440
62668: NOT
62669: IFFALSE 62705
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
62671: LD_VAR 0 1
62675: PPUSH
62676: CALL_OW 250
62680: PPUSH
62681: LD_VAR 0 1
62685: PPUSH
62686: CALL_OW 251
62690: PPUSH
62691: LD_VAR 0 1
62695: PPUSH
62696: CALL_OW 255
62700: PPUSH
62701: CALL_OW 441
// end ; if btype = b_warehouse then
62705: LD_VAR 0 5
62709: PUSH
62710: LD_INT 1
62712: EQUAL
62713: IFFALSE 62731
// begin btype := b_depot ;
62715: LD_ADDR_VAR 0 5
62719: PUSH
62720: LD_INT 0
62722: ST_TO_ADDR
// pos := 1 ;
62723: LD_ADDR_VAR 0 6
62727: PUSH
62728: LD_INT 1
62730: ST_TO_ADDR
// end ; if btype = b_factory then
62731: LD_VAR 0 5
62735: PUSH
62736: LD_INT 3
62738: EQUAL
62739: IFFALSE 62757
// begin btype := b_workshop ;
62741: LD_ADDR_VAR 0 5
62745: PUSH
62746: LD_INT 2
62748: ST_TO_ADDR
// pos := 1 ;
62749: LD_ADDR_VAR 0 6
62753: PUSH
62754: LD_INT 1
62756: ST_TO_ADDR
// end ; if btype = b_barracks then
62757: LD_VAR 0 5
62761: PUSH
62762: LD_INT 5
62764: EQUAL
62765: IFFALSE 62775
// btype := b_armoury ;
62767: LD_ADDR_VAR 0 5
62771: PUSH
62772: LD_INT 4
62774: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
62775: LD_VAR 0 5
62779: PUSH
62780: LD_INT 7
62782: PUSH
62783: LD_INT 8
62785: PUSH
62786: EMPTY
62787: LIST
62788: LIST
62789: IN
62790: IFFALSE 62800
// btype := b_lab ;
62792: LD_ADDR_VAR 0 5
62796: PUSH
62797: LD_INT 6
62799: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
62800: LD_ADDR_EXP 107
62804: PUSH
62805: LD_EXP 107
62809: PPUSH
62810: LD_VAR 0 3
62814: PUSH
62815: LD_EXP 107
62819: PUSH
62820: LD_VAR 0 3
62824: ARRAY
62825: PUSH
62826: LD_INT 1
62828: PLUS
62829: PUSH
62830: EMPTY
62831: LIST
62832: LIST
62833: PPUSH
62834: LD_VAR 0 5
62838: PUSH
62839: LD_VAR 0 1
62843: PPUSH
62844: CALL_OW 250
62848: PUSH
62849: LD_VAR 0 1
62853: PPUSH
62854: CALL_OW 251
62858: PUSH
62859: LD_VAR 0 1
62863: PPUSH
62864: CALL_OW 254
62868: PUSH
62869: EMPTY
62870: LIST
62871: LIST
62872: LIST
62873: LIST
62874: PPUSH
62875: CALL 72131 0 3
62879: ST_TO_ADDR
// if pos = 1 then
62880: LD_VAR 0 6
62884: PUSH
62885: LD_INT 1
62887: EQUAL
62888: IFFALSE 63003
// begin tmp := mc_build_list [ i ] ;
62890: LD_ADDR_VAR 0 7
62894: PUSH
62895: LD_EXP 107
62899: PUSH
62900: LD_VAR 0 3
62904: ARRAY
62905: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62906: LD_VAR 0 7
62910: PPUSH
62911: LD_INT 2
62913: PUSH
62914: LD_INT 30
62916: PUSH
62917: LD_INT 0
62919: PUSH
62920: EMPTY
62921: LIST
62922: LIST
62923: PUSH
62924: LD_INT 30
62926: PUSH
62927: LD_INT 1
62929: PUSH
62930: EMPTY
62931: LIST
62932: LIST
62933: PUSH
62934: EMPTY
62935: LIST
62936: LIST
62937: LIST
62938: PPUSH
62939: CALL_OW 72
62943: IFFALSE 62953
// pos := 2 ;
62945: LD_ADDR_VAR 0 6
62949: PUSH
62950: LD_INT 2
62952: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
62953: LD_ADDR_VAR 0 7
62957: PUSH
62958: LD_VAR 0 7
62962: PPUSH
62963: LD_VAR 0 6
62967: PPUSH
62968: LD_VAR 0 7
62972: PPUSH
62973: CALL 72457 0 3
62977: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
62978: LD_ADDR_EXP 107
62982: PUSH
62983: LD_EXP 107
62987: PPUSH
62988: LD_VAR 0 3
62992: PPUSH
62993: LD_VAR 0 7
62997: PPUSH
62998: CALL_OW 1
63002: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63003: LD_VAR 0 1
63007: PUSH
63008: LD_EXP 102
63012: PUSH
63013: LD_VAR 0 3
63017: ARRAY
63018: IN
63019: IFFALSE 63058
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
63021: LD_ADDR_EXP 102
63025: PUSH
63026: LD_EXP 102
63030: PPUSH
63031: LD_VAR 0 3
63035: PPUSH
63036: LD_EXP 102
63040: PUSH
63041: LD_VAR 0 3
63045: ARRAY
63046: PUSH
63047: LD_VAR 0 1
63051: DIFF
63052: PPUSH
63053: CALL_OW 1
63057: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
63058: LD_VAR 0 1
63062: PUSH
63063: LD_EXP 109
63067: PUSH
63068: LD_VAR 0 3
63072: ARRAY
63073: IN
63074: IFFALSE 63113
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
63076: LD_ADDR_EXP 109
63080: PUSH
63081: LD_EXP 109
63085: PPUSH
63086: LD_VAR 0 3
63090: PPUSH
63091: LD_EXP 109
63095: PUSH
63096: LD_VAR 0 3
63100: ARRAY
63101: PUSH
63102: LD_VAR 0 1
63106: DIFF
63107: PPUSH
63108: CALL_OW 1
63112: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
63113: LD_VAR 0 1
63117: PUSH
63118: LD_EXP 121
63122: PUSH
63123: LD_VAR 0 3
63127: ARRAY
63128: IN
63129: IFFALSE 63168
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
63131: LD_ADDR_EXP 121
63135: PUSH
63136: LD_EXP 121
63140: PPUSH
63141: LD_VAR 0 3
63145: PPUSH
63146: LD_EXP 121
63150: PUSH
63151: LD_VAR 0 3
63155: ARRAY
63156: PUSH
63157: LD_VAR 0 1
63161: DIFF
63162: PPUSH
63163: CALL_OW 1
63167: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
63168: LD_VAR 0 1
63172: PUSH
63173: LD_EXP 124
63177: PUSH
63178: LD_VAR 0 3
63182: ARRAY
63183: IN
63184: IFFALSE 63223
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63186: LD_ADDR_EXP 124
63190: PUSH
63191: LD_EXP 124
63195: PPUSH
63196: LD_VAR 0 3
63200: PPUSH
63201: LD_EXP 124
63205: PUSH
63206: LD_VAR 0 3
63210: ARRAY
63211: PUSH
63212: LD_VAR 0 1
63216: DIFF
63217: PPUSH
63218: CALL_OW 1
63222: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
63223: LD_VAR 0 1
63227: PUSH
63228: LD_EXP 111
63232: PUSH
63233: LD_VAR 0 3
63237: ARRAY
63238: IN
63239: IFFALSE 63278
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
63241: LD_ADDR_EXP 111
63245: PUSH
63246: LD_EXP 111
63250: PPUSH
63251: LD_VAR 0 3
63255: PPUSH
63256: LD_EXP 111
63260: PUSH
63261: LD_VAR 0 3
63265: ARRAY
63266: PUSH
63267: LD_VAR 0 1
63271: DIFF
63272: PPUSH
63273: CALL_OW 1
63277: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
63278: LD_VAR 0 1
63282: PUSH
63283: LD_EXP 110
63287: PUSH
63288: LD_VAR 0 3
63292: ARRAY
63293: IN
63294: IFFALSE 63333
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
63296: LD_ADDR_EXP 110
63300: PUSH
63301: LD_EXP 110
63305: PPUSH
63306: LD_VAR 0 3
63310: PPUSH
63311: LD_EXP 110
63315: PUSH
63316: LD_VAR 0 3
63320: ARRAY
63321: PUSH
63322: LD_VAR 0 1
63326: DIFF
63327: PPUSH
63328: CALL_OW 1
63332: ST_TO_ADDR
// end ; break ;
63333: GO 63337
// end ;
63335: GO 61983
63337: POP
63338: POP
// end ;
63339: LD_VAR 0 2
63343: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
63344: LD_INT 0
63346: PPUSH
63347: PPUSH
63348: PPUSH
// if not mc_bases or not skirmish then
63349: LD_EXP 102
63353: NOT
63354: PUSH
63355: LD_EXP 100
63359: NOT
63360: OR
63361: IFFALSE 63365
// exit ;
63363: GO 63580
// for i = 1 to mc_bases do
63365: LD_ADDR_VAR 0 3
63369: PUSH
63370: DOUBLE
63371: LD_INT 1
63373: DEC
63374: ST_TO_ADDR
63375: LD_EXP 102
63379: PUSH
63380: FOR_TO
63381: IFFALSE 63578
// begin if building in mc_construct_list [ i ] then
63383: LD_VAR 0 1
63387: PUSH
63388: LD_EXP 109
63392: PUSH
63393: LD_VAR 0 3
63397: ARRAY
63398: IN
63399: IFFALSE 63576
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63401: LD_ADDR_EXP 109
63405: PUSH
63406: LD_EXP 109
63410: PPUSH
63411: LD_VAR 0 3
63415: PPUSH
63416: LD_EXP 109
63420: PUSH
63421: LD_VAR 0 3
63425: ARRAY
63426: PUSH
63427: LD_VAR 0 1
63431: DIFF
63432: PPUSH
63433: CALL_OW 1
63437: ST_TO_ADDR
// if building in mc_lab [ i ] then
63438: LD_VAR 0 1
63442: PUSH
63443: LD_EXP 135
63447: PUSH
63448: LD_VAR 0 3
63452: ARRAY
63453: IN
63454: IFFALSE 63509
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
63456: LD_ADDR_EXP 136
63460: PUSH
63461: LD_EXP 136
63465: PPUSH
63466: LD_VAR 0 3
63470: PPUSH
63471: LD_EXP 136
63475: PUSH
63476: LD_VAR 0 3
63480: ARRAY
63481: PPUSH
63482: LD_INT 1
63484: PPUSH
63485: LD_EXP 136
63489: PUSH
63490: LD_VAR 0 3
63494: ARRAY
63495: PPUSH
63496: LD_INT 0
63498: PPUSH
63499: CALL 71549 0 4
63503: PPUSH
63504: CALL_OW 1
63508: ST_TO_ADDR
// if not building in mc_bases [ i ] then
63509: LD_VAR 0 1
63513: PUSH
63514: LD_EXP 102
63518: PUSH
63519: LD_VAR 0 3
63523: ARRAY
63524: IN
63525: NOT
63526: IFFALSE 63572
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63528: LD_ADDR_EXP 102
63532: PUSH
63533: LD_EXP 102
63537: PPUSH
63538: LD_VAR 0 3
63542: PUSH
63543: LD_EXP 102
63547: PUSH
63548: LD_VAR 0 3
63552: ARRAY
63553: PUSH
63554: LD_INT 1
63556: PLUS
63557: PUSH
63558: EMPTY
63559: LIST
63560: LIST
63561: PPUSH
63562: LD_VAR 0 1
63566: PPUSH
63567: CALL 72131 0 3
63571: ST_TO_ADDR
// exit ;
63572: POP
63573: POP
63574: GO 63580
// end ; end ;
63576: GO 63380
63578: POP
63579: POP
// end ;
63580: LD_VAR 0 2
63584: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
63585: LD_INT 0
63587: PPUSH
63588: PPUSH
63589: PPUSH
63590: PPUSH
63591: PPUSH
63592: PPUSH
63593: PPUSH
// if not mc_bases or not skirmish then
63594: LD_EXP 102
63598: NOT
63599: PUSH
63600: LD_EXP 100
63604: NOT
63605: OR
63606: IFFALSE 63610
// exit ;
63608: GO 64271
// for i = 1 to mc_bases do
63610: LD_ADDR_VAR 0 3
63614: PUSH
63615: DOUBLE
63616: LD_INT 1
63618: DEC
63619: ST_TO_ADDR
63620: LD_EXP 102
63624: PUSH
63625: FOR_TO
63626: IFFALSE 64269
// begin if building in mc_construct_list [ i ] then
63628: LD_VAR 0 1
63632: PUSH
63633: LD_EXP 109
63637: PUSH
63638: LD_VAR 0 3
63642: ARRAY
63643: IN
63644: IFFALSE 64267
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63646: LD_ADDR_EXP 109
63650: PUSH
63651: LD_EXP 109
63655: PPUSH
63656: LD_VAR 0 3
63660: PPUSH
63661: LD_EXP 109
63665: PUSH
63666: LD_VAR 0 3
63670: ARRAY
63671: PUSH
63672: LD_VAR 0 1
63676: DIFF
63677: PPUSH
63678: CALL_OW 1
63682: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63683: LD_ADDR_EXP 102
63687: PUSH
63688: LD_EXP 102
63692: PPUSH
63693: LD_VAR 0 3
63697: PUSH
63698: LD_EXP 102
63702: PUSH
63703: LD_VAR 0 3
63707: ARRAY
63708: PUSH
63709: LD_INT 1
63711: PLUS
63712: PUSH
63713: EMPTY
63714: LIST
63715: LIST
63716: PPUSH
63717: LD_VAR 0 1
63721: PPUSH
63722: CALL 72131 0 3
63726: ST_TO_ADDR
// btype := GetBType ( building ) ;
63727: LD_ADDR_VAR 0 5
63731: PUSH
63732: LD_VAR 0 1
63736: PPUSH
63737: CALL_OW 266
63741: ST_TO_ADDR
// side := GetSide ( building ) ;
63742: LD_ADDR_VAR 0 8
63746: PUSH
63747: LD_VAR 0 1
63751: PPUSH
63752: CALL_OW 255
63756: ST_TO_ADDR
// if btype = b_lab then
63757: LD_VAR 0 5
63761: PUSH
63762: LD_INT 6
63764: EQUAL
63765: IFFALSE 63815
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
63767: LD_ADDR_EXP 135
63771: PUSH
63772: LD_EXP 135
63776: PPUSH
63777: LD_VAR 0 3
63781: PUSH
63782: LD_EXP 135
63786: PUSH
63787: LD_VAR 0 3
63791: ARRAY
63792: PUSH
63793: LD_INT 1
63795: PLUS
63796: PUSH
63797: EMPTY
63798: LIST
63799: LIST
63800: PPUSH
63801: LD_VAR 0 1
63805: PPUSH
63806: CALL 72131 0 3
63810: ST_TO_ADDR
// exit ;
63811: POP
63812: POP
63813: GO 64271
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
63815: LD_VAR 0 5
63819: PUSH
63820: LD_INT 0
63822: PUSH
63823: LD_INT 2
63825: PUSH
63826: LD_INT 4
63828: PUSH
63829: EMPTY
63830: LIST
63831: LIST
63832: LIST
63833: IN
63834: IFFALSE 63958
// begin if btype = b_armoury then
63836: LD_VAR 0 5
63840: PUSH
63841: LD_INT 4
63843: EQUAL
63844: IFFALSE 63854
// btype := b_barracks ;
63846: LD_ADDR_VAR 0 5
63850: PUSH
63851: LD_INT 5
63853: ST_TO_ADDR
// if btype = b_depot then
63854: LD_VAR 0 5
63858: PUSH
63859: LD_INT 0
63861: EQUAL
63862: IFFALSE 63872
// btype := b_warehouse ;
63864: LD_ADDR_VAR 0 5
63868: PUSH
63869: LD_INT 1
63871: ST_TO_ADDR
// if btype = b_workshop then
63872: LD_VAR 0 5
63876: PUSH
63877: LD_INT 2
63879: EQUAL
63880: IFFALSE 63890
// btype := b_factory ;
63882: LD_ADDR_VAR 0 5
63886: PUSH
63887: LD_INT 3
63889: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
63890: LD_VAR 0 5
63894: PPUSH
63895: LD_VAR 0 8
63899: PPUSH
63900: CALL_OW 323
63904: PUSH
63905: LD_INT 1
63907: EQUAL
63908: IFFALSE 63954
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
63910: LD_ADDR_EXP 134
63914: PUSH
63915: LD_EXP 134
63919: PPUSH
63920: LD_VAR 0 3
63924: PUSH
63925: LD_EXP 134
63929: PUSH
63930: LD_VAR 0 3
63934: ARRAY
63935: PUSH
63936: LD_INT 1
63938: PLUS
63939: PUSH
63940: EMPTY
63941: LIST
63942: LIST
63943: PPUSH
63944: LD_VAR 0 1
63948: PPUSH
63949: CALL 72131 0 3
63953: ST_TO_ADDR
// exit ;
63954: POP
63955: POP
63956: GO 64271
// end ; if btype in [ b_bunker , b_turret ] then
63958: LD_VAR 0 5
63962: PUSH
63963: LD_INT 32
63965: PUSH
63966: LD_INT 33
63968: PUSH
63969: EMPTY
63970: LIST
63971: LIST
63972: IN
63973: IFFALSE 64263
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
63975: LD_ADDR_EXP 110
63979: PUSH
63980: LD_EXP 110
63984: PPUSH
63985: LD_VAR 0 3
63989: PUSH
63990: LD_EXP 110
63994: PUSH
63995: LD_VAR 0 3
63999: ARRAY
64000: PUSH
64001: LD_INT 1
64003: PLUS
64004: PUSH
64005: EMPTY
64006: LIST
64007: LIST
64008: PPUSH
64009: LD_VAR 0 1
64013: PPUSH
64014: CALL 72131 0 3
64018: ST_TO_ADDR
// if btype = b_bunker then
64019: LD_VAR 0 5
64023: PUSH
64024: LD_INT 32
64026: EQUAL
64027: IFFALSE 64263
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64029: LD_ADDR_EXP 111
64033: PUSH
64034: LD_EXP 111
64038: PPUSH
64039: LD_VAR 0 3
64043: PUSH
64044: LD_EXP 111
64048: PUSH
64049: LD_VAR 0 3
64053: ARRAY
64054: PUSH
64055: LD_INT 1
64057: PLUS
64058: PUSH
64059: EMPTY
64060: LIST
64061: LIST
64062: PPUSH
64063: LD_VAR 0 1
64067: PPUSH
64068: CALL 72131 0 3
64072: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
64073: LD_ADDR_VAR 0 6
64077: PUSH
64078: LD_EXP 102
64082: PUSH
64083: LD_VAR 0 3
64087: ARRAY
64088: PPUSH
64089: LD_INT 25
64091: PUSH
64092: LD_INT 1
64094: PUSH
64095: EMPTY
64096: LIST
64097: LIST
64098: PUSH
64099: LD_INT 3
64101: PUSH
64102: LD_INT 54
64104: PUSH
64105: EMPTY
64106: LIST
64107: PUSH
64108: EMPTY
64109: LIST
64110: LIST
64111: PUSH
64112: EMPTY
64113: LIST
64114: LIST
64115: PPUSH
64116: CALL_OW 72
64120: ST_TO_ADDR
// if tmp then
64121: LD_VAR 0 6
64125: IFFALSE 64131
// exit ;
64127: POP
64128: POP
64129: GO 64271
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64131: LD_ADDR_VAR 0 6
64135: PUSH
64136: LD_EXP 102
64140: PUSH
64141: LD_VAR 0 3
64145: ARRAY
64146: PPUSH
64147: LD_INT 2
64149: PUSH
64150: LD_INT 30
64152: PUSH
64153: LD_INT 4
64155: PUSH
64156: EMPTY
64157: LIST
64158: LIST
64159: PUSH
64160: LD_INT 30
64162: PUSH
64163: LD_INT 5
64165: PUSH
64166: EMPTY
64167: LIST
64168: LIST
64169: PUSH
64170: EMPTY
64171: LIST
64172: LIST
64173: LIST
64174: PPUSH
64175: CALL_OW 72
64179: ST_TO_ADDR
// if not tmp then
64180: LD_VAR 0 6
64184: NOT
64185: IFFALSE 64191
// exit ;
64187: POP
64188: POP
64189: GO 64271
// for j in tmp do
64191: LD_ADDR_VAR 0 4
64195: PUSH
64196: LD_VAR 0 6
64200: PUSH
64201: FOR_IN
64202: IFFALSE 64261
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
64204: LD_ADDR_VAR 0 7
64208: PUSH
64209: LD_VAR 0 4
64213: PPUSH
64214: CALL_OW 313
64218: PPUSH
64219: LD_INT 25
64221: PUSH
64222: LD_INT 1
64224: PUSH
64225: EMPTY
64226: LIST
64227: LIST
64228: PPUSH
64229: CALL_OW 72
64233: ST_TO_ADDR
// if units then
64234: LD_VAR 0 7
64238: IFFALSE 64259
// begin ComExitBuilding ( units [ 1 ] ) ;
64240: LD_VAR 0 7
64244: PUSH
64245: LD_INT 1
64247: ARRAY
64248: PPUSH
64249: CALL_OW 122
// exit ;
64253: POP
64254: POP
64255: POP
64256: POP
64257: GO 64271
// end ; end ;
64259: GO 64201
64261: POP
64262: POP
// end ; end ; exit ;
64263: POP
64264: POP
64265: GO 64271
// end ; end ;
64267: GO 63625
64269: POP
64270: POP
// end ;
64271: LD_VAR 0 2
64275: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
64276: LD_INT 0
64278: PPUSH
64279: PPUSH
64280: PPUSH
64281: PPUSH
64282: PPUSH
64283: PPUSH
64284: PPUSH
// if not mc_bases or not skirmish then
64285: LD_EXP 102
64289: NOT
64290: PUSH
64291: LD_EXP 100
64295: NOT
64296: OR
64297: IFFALSE 64301
// exit ;
64299: GO 64532
// btype := GetBType ( building ) ;
64301: LD_ADDR_VAR 0 6
64305: PUSH
64306: LD_VAR 0 1
64310: PPUSH
64311: CALL_OW 266
64315: ST_TO_ADDR
// x := GetX ( building ) ;
64316: LD_ADDR_VAR 0 7
64320: PUSH
64321: LD_VAR 0 1
64325: PPUSH
64326: CALL_OW 250
64330: ST_TO_ADDR
// y := GetY ( building ) ;
64331: LD_ADDR_VAR 0 8
64335: PUSH
64336: LD_VAR 0 1
64340: PPUSH
64341: CALL_OW 251
64345: ST_TO_ADDR
// d := GetDir ( building ) ;
64346: LD_ADDR_VAR 0 9
64350: PUSH
64351: LD_VAR 0 1
64355: PPUSH
64356: CALL_OW 254
64360: ST_TO_ADDR
// for i = 1 to mc_bases do
64361: LD_ADDR_VAR 0 4
64365: PUSH
64366: DOUBLE
64367: LD_INT 1
64369: DEC
64370: ST_TO_ADDR
64371: LD_EXP 102
64375: PUSH
64376: FOR_TO
64377: IFFALSE 64530
// begin if not mc_build_list [ i ] then
64379: LD_EXP 107
64383: PUSH
64384: LD_VAR 0 4
64388: ARRAY
64389: NOT
64390: IFFALSE 64394
// continue ;
64392: GO 64376
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
64394: LD_VAR 0 6
64398: PUSH
64399: LD_VAR 0 7
64403: PUSH
64404: LD_VAR 0 8
64408: PUSH
64409: LD_VAR 0 9
64413: PUSH
64414: EMPTY
64415: LIST
64416: LIST
64417: LIST
64418: LIST
64419: PPUSH
64420: LD_EXP 107
64424: PUSH
64425: LD_VAR 0 4
64429: ARRAY
64430: PUSH
64431: LD_INT 1
64433: ARRAY
64434: PPUSH
64435: CALL 78300 0 2
64439: IFFALSE 64528
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
64441: LD_ADDR_EXP 107
64445: PUSH
64446: LD_EXP 107
64450: PPUSH
64451: LD_VAR 0 4
64455: PPUSH
64456: LD_EXP 107
64460: PUSH
64461: LD_VAR 0 4
64465: ARRAY
64466: PPUSH
64467: LD_INT 1
64469: PPUSH
64470: CALL_OW 3
64474: PPUSH
64475: CALL_OW 1
64479: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
64480: LD_ADDR_EXP 109
64484: PUSH
64485: LD_EXP 109
64489: PPUSH
64490: LD_VAR 0 4
64494: PUSH
64495: LD_EXP 109
64499: PUSH
64500: LD_VAR 0 4
64504: ARRAY
64505: PUSH
64506: LD_INT 1
64508: PLUS
64509: PUSH
64510: EMPTY
64511: LIST
64512: LIST
64513: PPUSH
64514: LD_VAR 0 1
64518: PPUSH
64519: CALL 72131 0 3
64523: ST_TO_ADDR
// exit ;
64524: POP
64525: POP
64526: GO 64532
// end ; end ;
64528: GO 64376
64530: POP
64531: POP
// end ;
64532: LD_VAR 0 3
64536: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
64537: LD_INT 0
64539: PPUSH
64540: PPUSH
64541: PPUSH
// if not mc_bases or not skirmish then
64542: LD_EXP 102
64546: NOT
64547: PUSH
64548: LD_EXP 100
64552: NOT
64553: OR
64554: IFFALSE 64558
// exit ;
64556: GO 64748
// for i = 1 to mc_bases do
64558: LD_ADDR_VAR 0 4
64562: PUSH
64563: DOUBLE
64564: LD_INT 1
64566: DEC
64567: ST_TO_ADDR
64568: LD_EXP 102
64572: PUSH
64573: FOR_TO
64574: IFFALSE 64661
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
64576: LD_VAR 0 1
64580: PUSH
64581: LD_EXP 110
64585: PUSH
64586: LD_VAR 0 4
64590: ARRAY
64591: IN
64592: PUSH
64593: LD_VAR 0 1
64597: PUSH
64598: LD_EXP 111
64602: PUSH
64603: LD_VAR 0 4
64607: ARRAY
64608: IN
64609: NOT
64610: AND
64611: IFFALSE 64659
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64613: LD_ADDR_EXP 111
64617: PUSH
64618: LD_EXP 111
64622: PPUSH
64623: LD_VAR 0 4
64627: PUSH
64628: LD_EXP 111
64632: PUSH
64633: LD_VAR 0 4
64637: ARRAY
64638: PUSH
64639: LD_INT 1
64641: PLUS
64642: PUSH
64643: EMPTY
64644: LIST
64645: LIST
64646: PPUSH
64647: LD_VAR 0 1
64651: PPUSH
64652: CALL 72131 0 3
64656: ST_TO_ADDR
// break ;
64657: GO 64661
// end ; end ;
64659: GO 64573
64661: POP
64662: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
64663: LD_VAR 0 1
64667: PPUSH
64668: CALL_OW 257
64672: PUSH
64673: LD_EXP 128
64677: IN
64678: PUSH
64679: LD_VAR 0 1
64683: PPUSH
64684: CALL_OW 266
64688: PUSH
64689: LD_INT 5
64691: EQUAL
64692: AND
64693: PUSH
64694: LD_VAR 0 2
64698: PPUSH
64699: CALL_OW 110
64703: PUSH
64704: LD_INT 18
64706: NONEQUAL
64707: AND
64708: IFFALSE 64748
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
64710: LD_VAR 0 2
64714: PPUSH
64715: CALL_OW 257
64719: PUSH
64720: LD_INT 5
64722: PUSH
64723: LD_INT 8
64725: PUSH
64726: LD_INT 9
64728: PUSH
64729: EMPTY
64730: LIST
64731: LIST
64732: LIST
64733: IN
64734: IFFALSE 64748
// SetClass ( unit , 1 ) ;
64736: LD_VAR 0 2
64740: PPUSH
64741: LD_INT 1
64743: PPUSH
64744: CALL_OW 336
// end ;
64748: LD_VAR 0 3
64752: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
64753: LD_INT 0
64755: PPUSH
64756: PPUSH
// if not mc_bases or not skirmish then
64757: LD_EXP 102
64761: NOT
64762: PUSH
64763: LD_EXP 100
64767: NOT
64768: OR
64769: IFFALSE 64773
// exit ;
64771: GO 64889
// if GetLives ( abandoned_vehicle ) > 250 then
64773: LD_VAR 0 2
64777: PPUSH
64778: CALL_OW 256
64782: PUSH
64783: LD_INT 250
64785: GREATER
64786: IFFALSE 64790
// exit ;
64788: GO 64889
// for i = 1 to mc_bases do
64790: LD_ADDR_VAR 0 6
64794: PUSH
64795: DOUBLE
64796: LD_INT 1
64798: DEC
64799: ST_TO_ADDR
64800: LD_EXP 102
64804: PUSH
64805: FOR_TO
64806: IFFALSE 64887
// begin if driver in mc_bases [ i ] then
64808: LD_VAR 0 1
64812: PUSH
64813: LD_EXP 102
64817: PUSH
64818: LD_VAR 0 6
64822: ARRAY
64823: IN
64824: IFFALSE 64885
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
64826: LD_VAR 0 1
64830: PPUSH
64831: LD_EXP 102
64835: PUSH
64836: LD_VAR 0 6
64840: ARRAY
64841: PPUSH
64842: LD_INT 2
64844: PUSH
64845: LD_INT 30
64847: PUSH
64848: LD_INT 0
64850: PUSH
64851: EMPTY
64852: LIST
64853: LIST
64854: PUSH
64855: LD_INT 30
64857: PUSH
64858: LD_INT 1
64860: PUSH
64861: EMPTY
64862: LIST
64863: LIST
64864: PUSH
64865: EMPTY
64866: LIST
64867: LIST
64868: LIST
64869: PPUSH
64870: CALL_OW 72
64874: PUSH
64875: LD_INT 1
64877: ARRAY
64878: PPUSH
64879: CALL_OW 112
// break ;
64883: GO 64887
// end ; end ;
64885: GO 64805
64887: POP
64888: POP
// end ; end_of_file
64889: LD_VAR 0 5
64893: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
64894: LD_INT 0
64896: PPUSH
64897: PPUSH
// if exist_mode then
64898: LD_VAR 0 2
64902: IFFALSE 64927
// unit := CreateCharacter ( prefix & ident ) else
64904: LD_ADDR_VAR 0 5
64908: PUSH
64909: LD_VAR 0 3
64913: PUSH
64914: LD_VAR 0 1
64918: STR
64919: PPUSH
64920: CALL_OW 34
64924: ST_TO_ADDR
64925: GO 64942
// unit := NewCharacter ( ident ) ;
64927: LD_ADDR_VAR 0 5
64931: PUSH
64932: LD_VAR 0 1
64936: PPUSH
64937: CALL_OW 25
64941: ST_TO_ADDR
// result := unit ;
64942: LD_ADDR_VAR 0 4
64946: PUSH
64947: LD_VAR 0 5
64951: ST_TO_ADDR
// end ;
64952: LD_VAR 0 4
64956: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
64957: LD_INT 0
64959: PPUSH
64960: PPUSH
// if not side or not nation then
64961: LD_VAR 0 1
64965: NOT
64966: PUSH
64967: LD_VAR 0 2
64971: NOT
64972: OR
64973: IFFALSE 64977
// exit ;
64975: GO 65621
// case nation of nation_american :
64977: LD_VAR 0 2
64981: PUSH
64982: LD_INT 1
64984: DOUBLE
64985: EQUAL
64986: IFTRUE 64990
64988: GO 65164
64990: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
64991: LD_ADDR_VAR 0 4
64995: PUSH
64996: LD_INT 35
64998: PUSH
64999: LD_INT 45
65001: PUSH
65002: LD_INT 46
65004: PUSH
65005: LD_INT 47
65007: PUSH
65008: LD_INT 1
65010: PUSH
65011: LD_INT 2
65013: PUSH
65014: LD_INT 6
65016: PUSH
65017: LD_INT 15
65019: PUSH
65020: LD_INT 16
65022: PUSH
65023: LD_INT 7
65025: PUSH
65026: LD_INT 12
65028: PUSH
65029: LD_INT 13
65031: PUSH
65032: LD_INT 10
65034: PUSH
65035: LD_INT 14
65037: PUSH
65038: LD_INT 20
65040: PUSH
65041: LD_INT 21
65043: PUSH
65044: LD_INT 22
65046: PUSH
65047: LD_INT 25
65049: PUSH
65050: LD_INT 32
65052: PUSH
65053: LD_INT 27
65055: PUSH
65056: LD_INT 36
65058: PUSH
65059: LD_INT 69
65061: PUSH
65062: LD_INT 39
65064: PUSH
65065: LD_INT 34
65067: PUSH
65068: LD_INT 40
65070: PUSH
65071: LD_INT 48
65073: PUSH
65074: LD_INT 49
65076: PUSH
65077: LD_INT 50
65079: PUSH
65080: LD_INT 51
65082: PUSH
65083: LD_INT 52
65085: PUSH
65086: LD_INT 53
65088: PUSH
65089: LD_INT 54
65091: PUSH
65092: LD_INT 55
65094: PUSH
65095: LD_INT 56
65097: PUSH
65098: LD_INT 57
65100: PUSH
65101: LD_INT 58
65103: PUSH
65104: LD_INT 59
65106: PUSH
65107: LD_INT 60
65109: PUSH
65110: LD_INT 61
65112: PUSH
65113: LD_INT 62
65115: PUSH
65116: LD_INT 80
65118: PUSH
65119: EMPTY
65120: LIST
65121: LIST
65122: LIST
65123: LIST
65124: LIST
65125: LIST
65126: LIST
65127: LIST
65128: LIST
65129: LIST
65130: LIST
65131: LIST
65132: LIST
65133: LIST
65134: LIST
65135: LIST
65136: LIST
65137: LIST
65138: LIST
65139: LIST
65140: LIST
65141: LIST
65142: LIST
65143: LIST
65144: LIST
65145: LIST
65146: LIST
65147: LIST
65148: LIST
65149: LIST
65150: LIST
65151: LIST
65152: LIST
65153: LIST
65154: LIST
65155: LIST
65156: LIST
65157: LIST
65158: LIST
65159: LIST
65160: LIST
65161: ST_TO_ADDR
65162: GO 65545
65164: LD_INT 2
65166: DOUBLE
65167: EQUAL
65168: IFTRUE 65172
65170: GO 65354
65172: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
65173: LD_ADDR_VAR 0 4
65177: PUSH
65178: LD_INT 35
65180: PUSH
65181: LD_INT 45
65183: PUSH
65184: LD_INT 46
65186: PUSH
65187: LD_INT 47
65189: PUSH
65190: LD_INT 70
65192: PUSH
65193: LD_INT 1
65195: PUSH
65196: LD_INT 11
65198: PUSH
65199: LD_INT 3
65201: PUSH
65202: LD_INT 4
65204: PUSH
65205: LD_INT 5
65207: PUSH
65208: LD_INT 6
65210: PUSH
65211: LD_INT 15
65213: PUSH
65214: LD_INT 18
65216: PUSH
65217: LD_INT 7
65219: PUSH
65220: LD_INT 17
65222: PUSH
65223: LD_INT 8
65225: PUSH
65226: LD_INT 20
65228: PUSH
65229: LD_INT 21
65231: PUSH
65232: LD_INT 22
65234: PUSH
65235: LD_INT 72
65237: PUSH
65238: LD_INT 26
65240: PUSH
65241: LD_INT 69
65243: PUSH
65244: LD_INT 39
65246: PUSH
65247: LD_INT 40
65249: PUSH
65250: LD_INT 41
65252: PUSH
65253: LD_INT 42
65255: PUSH
65256: LD_INT 43
65258: PUSH
65259: LD_INT 48
65261: PUSH
65262: LD_INT 49
65264: PUSH
65265: LD_INT 50
65267: PUSH
65268: LD_INT 51
65270: PUSH
65271: LD_INT 52
65273: PUSH
65274: LD_INT 53
65276: PUSH
65277: LD_INT 54
65279: PUSH
65280: LD_INT 55
65282: PUSH
65283: LD_INT 56
65285: PUSH
65286: LD_INT 60
65288: PUSH
65289: LD_INT 61
65291: PUSH
65292: LD_INT 62
65294: PUSH
65295: LD_INT 66
65297: PUSH
65298: LD_INT 67
65300: PUSH
65301: LD_INT 68
65303: PUSH
65304: LD_INT 81
65306: PUSH
65307: EMPTY
65308: LIST
65309: LIST
65310: LIST
65311: LIST
65312: LIST
65313: LIST
65314: LIST
65315: LIST
65316: LIST
65317: LIST
65318: LIST
65319: LIST
65320: LIST
65321: LIST
65322: LIST
65323: LIST
65324: LIST
65325: LIST
65326: LIST
65327: LIST
65328: LIST
65329: LIST
65330: LIST
65331: LIST
65332: LIST
65333: LIST
65334: LIST
65335: LIST
65336: LIST
65337: LIST
65338: LIST
65339: LIST
65340: LIST
65341: LIST
65342: LIST
65343: LIST
65344: LIST
65345: LIST
65346: LIST
65347: LIST
65348: LIST
65349: LIST
65350: LIST
65351: ST_TO_ADDR
65352: GO 65545
65354: LD_INT 3
65356: DOUBLE
65357: EQUAL
65358: IFTRUE 65362
65360: GO 65544
65362: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
65363: LD_ADDR_VAR 0 4
65367: PUSH
65368: LD_INT 46
65370: PUSH
65371: LD_INT 47
65373: PUSH
65374: LD_INT 1
65376: PUSH
65377: LD_INT 2
65379: PUSH
65380: LD_INT 11
65382: PUSH
65383: LD_INT 9
65385: PUSH
65386: LD_INT 20
65388: PUSH
65389: LD_INT 19
65391: PUSH
65392: LD_INT 21
65394: PUSH
65395: LD_INT 24
65397: PUSH
65398: LD_INT 22
65400: PUSH
65401: LD_INT 25
65403: PUSH
65404: LD_INT 28
65406: PUSH
65407: LD_INT 29
65409: PUSH
65410: LD_INT 30
65412: PUSH
65413: LD_INT 31
65415: PUSH
65416: LD_INT 37
65418: PUSH
65419: LD_INT 38
65421: PUSH
65422: LD_INT 32
65424: PUSH
65425: LD_INT 27
65427: PUSH
65428: LD_INT 33
65430: PUSH
65431: LD_INT 69
65433: PUSH
65434: LD_INT 39
65436: PUSH
65437: LD_INT 34
65439: PUSH
65440: LD_INT 40
65442: PUSH
65443: LD_INT 71
65445: PUSH
65446: LD_INT 23
65448: PUSH
65449: LD_INT 44
65451: PUSH
65452: LD_INT 48
65454: PUSH
65455: LD_INT 49
65457: PUSH
65458: LD_INT 50
65460: PUSH
65461: LD_INT 51
65463: PUSH
65464: LD_INT 52
65466: PUSH
65467: LD_INT 53
65469: PUSH
65470: LD_INT 54
65472: PUSH
65473: LD_INT 55
65475: PUSH
65476: LD_INT 56
65478: PUSH
65479: LD_INT 57
65481: PUSH
65482: LD_INT 58
65484: PUSH
65485: LD_INT 59
65487: PUSH
65488: LD_INT 63
65490: PUSH
65491: LD_INT 64
65493: PUSH
65494: LD_INT 65
65496: PUSH
65497: EMPTY
65498: LIST
65499: LIST
65500: LIST
65501: LIST
65502: LIST
65503: LIST
65504: LIST
65505: LIST
65506: LIST
65507: LIST
65508: LIST
65509: LIST
65510: LIST
65511: LIST
65512: LIST
65513: LIST
65514: LIST
65515: LIST
65516: LIST
65517: LIST
65518: LIST
65519: LIST
65520: LIST
65521: LIST
65522: LIST
65523: LIST
65524: LIST
65525: LIST
65526: LIST
65527: LIST
65528: LIST
65529: LIST
65530: LIST
65531: LIST
65532: LIST
65533: LIST
65534: LIST
65535: LIST
65536: LIST
65537: LIST
65538: LIST
65539: LIST
65540: LIST
65541: ST_TO_ADDR
65542: GO 65545
65544: POP
// if state > - 1 and state < 3 then
65545: LD_VAR 0 3
65549: PUSH
65550: LD_INT 1
65552: NEG
65553: GREATER
65554: PUSH
65555: LD_VAR 0 3
65559: PUSH
65560: LD_INT 3
65562: LESS
65563: AND
65564: IFFALSE 65621
// for i in result do
65566: LD_ADDR_VAR 0 5
65570: PUSH
65571: LD_VAR 0 4
65575: PUSH
65576: FOR_IN
65577: IFFALSE 65619
// if GetTech ( i , side ) <> state then
65579: LD_VAR 0 5
65583: PPUSH
65584: LD_VAR 0 1
65588: PPUSH
65589: CALL_OW 321
65593: PUSH
65594: LD_VAR 0 3
65598: NONEQUAL
65599: IFFALSE 65617
// result := result diff i ;
65601: LD_ADDR_VAR 0 4
65605: PUSH
65606: LD_VAR 0 4
65610: PUSH
65611: LD_VAR 0 5
65615: DIFF
65616: ST_TO_ADDR
65617: GO 65576
65619: POP
65620: POP
// end ;
65621: LD_VAR 0 4
65625: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
65626: LD_INT 0
65628: PPUSH
65629: PPUSH
65630: PPUSH
// result := true ;
65631: LD_ADDR_VAR 0 3
65635: PUSH
65636: LD_INT 1
65638: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
65639: LD_ADDR_VAR 0 5
65643: PUSH
65644: LD_VAR 0 2
65648: PPUSH
65649: CALL_OW 480
65653: ST_TO_ADDR
// if not tmp then
65654: LD_VAR 0 5
65658: NOT
65659: IFFALSE 65663
// exit ;
65661: GO 65712
// for i in tmp do
65663: LD_ADDR_VAR 0 4
65667: PUSH
65668: LD_VAR 0 5
65672: PUSH
65673: FOR_IN
65674: IFFALSE 65710
// if GetTech ( i , side ) <> state_researched then
65676: LD_VAR 0 4
65680: PPUSH
65681: LD_VAR 0 1
65685: PPUSH
65686: CALL_OW 321
65690: PUSH
65691: LD_INT 2
65693: NONEQUAL
65694: IFFALSE 65708
// begin result := false ;
65696: LD_ADDR_VAR 0 3
65700: PUSH
65701: LD_INT 0
65703: ST_TO_ADDR
// exit ;
65704: POP
65705: POP
65706: GO 65712
// end ;
65708: GO 65673
65710: POP
65711: POP
// end ;
65712: LD_VAR 0 3
65716: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
65717: LD_INT 0
65719: PPUSH
65720: PPUSH
65721: PPUSH
65722: PPUSH
65723: PPUSH
65724: PPUSH
65725: PPUSH
65726: PPUSH
65727: PPUSH
65728: PPUSH
65729: PPUSH
65730: PPUSH
65731: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
65732: LD_VAR 0 1
65736: NOT
65737: PUSH
65738: LD_VAR 0 1
65742: PPUSH
65743: CALL_OW 257
65747: PUSH
65748: LD_INT 9
65750: NONEQUAL
65751: OR
65752: IFFALSE 65756
// exit ;
65754: GO 66329
// side := GetSide ( unit ) ;
65756: LD_ADDR_VAR 0 9
65760: PUSH
65761: LD_VAR 0 1
65765: PPUSH
65766: CALL_OW 255
65770: ST_TO_ADDR
// tech_space := tech_spacanom ;
65771: LD_ADDR_VAR 0 12
65775: PUSH
65776: LD_INT 29
65778: ST_TO_ADDR
// tech_time := tech_taurad ;
65779: LD_ADDR_VAR 0 13
65783: PUSH
65784: LD_INT 28
65786: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
65787: LD_ADDR_VAR 0 11
65791: PUSH
65792: LD_VAR 0 1
65796: PPUSH
65797: CALL_OW 310
65801: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
65802: LD_VAR 0 11
65806: PPUSH
65807: CALL_OW 247
65811: PUSH
65812: LD_INT 2
65814: EQUAL
65815: IFFALSE 65819
// exit ;
65817: GO 66329
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65819: LD_ADDR_VAR 0 8
65823: PUSH
65824: LD_INT 81
65826: PUSH
65827: LD_VAR 0 9
65831: PUSH
65832: EMPTY
65833: LIST
65834: LIST
65835: PUSH
65836: LD_INT 3
65838: PUSH
65839: LD_INT 21
65841: PUSH
65842: LD_INT 3
65844: PUSH
65845: EMPTY
65846: LIST
65847: LIST
65848: PUSH
65849: EMPTY
65850: LIST
65851: LIST
65852: PUSH
65853: EMPTY
65854: LIST
65855: LIST
65856: PPUSH
65857: CALL_OW 69
65861: ST_TO_ADDR
// if not tmp then
65862: LD_VAR 0 8
65866: NOT
65867: IFFALSE 65871
// exit ;
65869: GO 66329
// if in_unit then
65871: LD_VAR 0 11
65875: IFFALSE 65899
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
65877: LD_ADDR_VAR 0 10
65881: PUSH
65882: LD_VAR 0 8
65886: PPUSH
65887: LD_VAR 0 11
65891: PPUSH
65892: CALL_OW 74
65896: ST_TO_ADDR
65897: GO 65919
// enemy := NearestUnitToUnit ( tmp , unit ) ;
65899: LD_ADDR_VAR 0 10
65903: PUSH
65904: LD_VAR 0 8
65908: PPUSH
65909: LD_VAR 0 1
65913: PPUSH
65914: CALL_OW 74
65918: ST_TO_ADDR
// if not enemy then
65919: LD_VAR 0 10
65923: NOT
65924: IFFALSE 65928
// exit ;
65926: GO 66329
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
65928: LD_VAR 0 11
65932: PUSH
65933: LD_VAR 0 11
65937: PPUSH
65938: LD_VAR 0 10
65942: PPUSH
65943: CALL_OW 296
65947: PUSH
65948: LD_INT 13
65950: GREATER
65951: AND
65952: PUSH
65953: LD_VAR 0 1
65957: PPUSH
65958: LD_VAR 0 10
65962: PPUSH
65963: CALL_OW 296
65967: PUSH
65968: LD_INT 12
65970: GREATER
65971: OR
65972: IFFALSE 65976
// exit ;
65974: GO 66329
// missile := [ 1 ] ;
65976: LD_ADDR_VAR 0 14
65980: PUSH
65981: LD_INT 1
65983: PUSH
65984: EMPTY
65985: LIST
65986: ST_TO_ADDR
// if Researched ( side , tech_space ) then
65987: LD_VAR 0 9
65991: PPUSH
65992: LD_VAR 0 12
65996: PPUSH
65997: CALL_OW 325
66001: IFFALSE 66030
// missile := Insert ( missile , missile + 1 , 2 ) ;
66003: LD_ADDR_VAR 0 14
66007: PUSH
66008: LD_VAR 0 14
66012: PPUSH
66013: LD_VAR 0 14
66017: PUSH
66018: LD_INT 1
66020: PLUS
66021: PPUSH
66022: LD_INT 2
66024: PPUSH
66025: CALL_OW 2
66029: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
66030: LD_VAR 0 9
66034: PPUSH
66035: LD_VAR 0 13
66039: PPUSH
66040: CALL_OW 325
66044: PUSH
66045: LD_VAR 0 10
66049: PPUSH
66050: CALL_OW 255
66054: PPUSH
66055: LD_VAR 0 13
66059: PPUSH
66060: CALL_OW 325
66064: NOT
66065: AND
66066: IFFALSE 66095
// missile := Insert ( missile , missile + 1 , 3 ) ;
66068: LD_ADDR_VAR 0 14
66072: PUSH
66073: LD_VAR 0 14
66077: PPUSH
66078: LD_VAR 0 14
66082: PUSH
66083: LD_INT 1
66085: PLUS
66086: PPUSH
66087: LD_INT 3
66089: PPUSH
66090: CALL_OW 2
66094: ST_TO_ADDR
// if missile < 2 then
66095: LD_VAR 0 14
66099: PUSH
66100: LD_INT 2
66102: LESS
66103: IFFALSE 66107
// exit ;
66105: GO 66329
// x := GetX ( enemy ) ;
66107: LD_ADDR_VAR 0 4
66111: PUSH
66112: LD_VAR 0 10
66116: PPUSH
66117: CALL_OW 250
66121: ST_TO_ADDR
// y := GetY ( enemy ) ;
66122: LD_ADDR_VAR 0 5
66126: PUSH
66127: LD_VAR 0 10
66131: PPUSH
66132: CALL_OW 251
66136: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
66137: LD_ADDR_VAR 0 6
66141: PUSH
66142: LD_VAR 0 4
66146: PUSH
66147: LD_INT 1
66149: NEG
66150: PPUSH
66151: LD_INT 1
66153: PPUSH
66154: CALL_OW 12
66158: PLUS
66159: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
66160: LD_ADDR_VAR 0 7
66164: PUSH
66165: LD_VAR 0 5
66169: PUSH
66170: LD_INT 1
66172: NEG
66173: PPUSH
66174: LD_INT 1
66176: PPUSH
66177: CALL_OW 12
66181: PLUS
66182: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66183: LD_VAR 0 6
66187: PPUSH
66188: LD_VAR 0 7
66192: PPUSH
66193: CALL_OW 488
66197: NOT
66198: IFFALSE 66220
// begin _x := x ;
66200: LD_ADDR_VAR 0 6
66204: PUSH
66205: LD_VAR 0 4
66209: ST_TO_ADDR
// _y := y ;
66210: LD_ADDR_VAR 0 7
66214: PUSH
66215: LD_VAR 0 5
66219: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
66220: LD_ADDR_VAR 0 3
66224: PUSH
66225: LD_INT 1
66227: PPUSH
66228: LD_VAR 0 14
66232: PPUSH
66233: CALL_OW 12
66237: ST_TO_ADDR
// case i of 1 :
66238: LD_VAR 0 3
66242: PUSH
66243: LD_INT 1
66245: DOUBLE
66246: EQUAL
66247: IFTRUE 66251
66249: GO 66268
66251: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
66252: LD_VAR 0 1
66256: PPUSH
66257: LD_VAR 0 10
66261: PPUSH
66262: CALL_OW 115
66266: GO 66329
66268: LD_INT 2
66270: DOUBLE
66271: EQUAL
66272: IFTRUE 66276
66274: GO 66298
66276: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
66277: LD_VAR 0 1
66281: PPUSH
66282: LD_VAR 0 6
66286: PPUSH
66287: LD_VAR 0 7
66291: PPUSH
66292: CALL_OW 153
66296: GO 66329
66298: LD_INT 3
66300: DOUBLE
66301: EQUAL
66302: IFTRUE 66306
66304: GO 66328
66306: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
66307: LD_VAR 0 1
66311: PPUSH
66312: LD_VAR 0 6
66316: PPUSH
66317: LD_VAR 0 7
66321: PPUSH
66322: CALL_OW 154
66326: GO 66329
66328: POP
// end ;
66329: LD_VAR 0 2
66333: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
66334: LD_INT 0
66336: PPUSH
66337: PPUSH
66338: PPUSH
66339: PPUSH
66340: PPUSH
66341: PPUSH
// if not unit or not building then
66342: LD_VAR 0 1
66346: NOT
66347: PUSH
66348: LD_VAR 0 2
66352: NOT
66353: OR
66354: IFFALSE 66358
// exit ;
66356: GO 66516
// x := GetX ( building ) ;
66358: LD_ADDR_VAR 0 5
66362: PUSH
66363: LD_VAR 0 2
66367: PPUSH
66368: CALL_OW 250
66372: ST_TO_ADDR
// y := GetY ( building ) ;
66373: LD_ADDR_VAR 0 6
66377: PUSH
66378: LD_VAR 0 2
66382: PPUSH
66383: CALL_OW 251
66387: ST_TO_ADDR
// for i = 0 to 5 do
66388: LD_ADDR_VAR 0 4
66392: PUSH
66393: DOUBLE
66394: LD_INT 0
66396: DEC
66397: ST_TO_ADDR
66398: LD_INT 5
66400: PUSH
66401: FOR_TO
66402: IFFALSE 66514
// begin _x := ShiftX ( x , i , 3 ) ;
66404: LD_ADDR_VAR 0 7
66408: PUSH
66409: LD_VAR 0 5
66413: PPUSH
66414: LD_VAR 0 4
66418: PPUSH
66419: LD_INT 3
66421: PPUSH
66422: CALL_OW 272
66426: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
66427: LD_ADDR_VAR 0 8
66431: PUSH
66432: LD_VAR 0 6
66436: PPUSH
66437: LD_VAR 0 4
66441: PPUSH
66442: LD_INT 3
66444: PPUSH
66445: CALL_OW 273
66449: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66450: LD_VAR 0 7
66454: PPUSH
66455: LD_VAR 0 8
66459: PPUSH
66460: CALL_OW 488
66464: NOT
66465: IFFALSE 66469
// continue ;
66467: GO 66401
// if HexInfo ( _x , _y ) = 0 then
66469: LD_VAR 0 7
66473: PPUSH
66474: LD_VAR 0 8
66478: PPUSH
66479: CALL_OW 428
66483: PUSH
66484: LD_INT 0
66486: EQUAL
66487: IFFALSE 66512
// begin ComMoveXY ( unit , _x , _y ) ;
66489: LD_VAR 0 1
66493: PPUSH
66494: LD_VAR 0 7
66498: PPUSH
66499: LD_VAR 0 8
66503: PPUSH
66504: CALL_OW 111
// exit ;
66508: POP
66509: POP
66510: GO 66516
// end ; end ;
66512: GO 66401
66514: POP
66515: POP
// end ;
66516: LD_VAR 0 3
66520: RET
// export function ScanBase ( side , base_area ) ; begin
66521: LD_INT 0
66523: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
66524: LD_ADDR_VAR 0 3
66528: PUSH
66529: LD_VAR 0 2
66533: PPUSH
66534: LD_INT 81
66536: PUSH
66537: LD_VAR 0 1
66541: PUSH
66542: EMPTY
66543: LIST
66544: LIST
66545: PPUSH
66546: CALL_OW 70
66550: ST_TO_ADDR
// end ;
66551: LD_VAR 0 3
66555: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
66556: LD_INT 0
66558: PPUSH
66559: PPUSH
66560: PPUSH
66561: PPUSH
66562: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
66563: LD_VAR 0 1
66567: NOT
66568: PUSH
66569: LD_EXP 102
66573: PUSH
66574: LD_VAR 0 1
66578: ARRAY
66579: NOT
66580: OR
66581: PUSH
66582: LD_VAR 0 2
66586: NOT
66587: OR
66588: PUSH
66589: LD_VAR 0 3
66593: NOT
66594: OR
66595: IFFALSE 66599
// exit ;
66597: GO 67112
// side := mc_sides [ base ] ;
66599: LD_ADDR_VAR 0 6
66603: PUSH
66604: LD_EXP 128
66608: PUSH
66609: LD_VAR 0 1
66613: ARRAY
66614: ST_TO_ADDR
// if not side then
66615: LD_VAR 0 6
66619: NOT
66620: IFFALSE 66624
// exit ;
66622: GO 67112
// for i in solds do
66624: LD_ADDR_VAR 0 7
66628: PUSH
66629: LD_VAR 0 2
66633: PUSH
66634: FOR_IN
66635: IFFALSE 66696
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
66637: LD_VAR 0 7
66641: PPUSH
66642: CALL_OW 310
66646: PPUSH
66647: CALL_OW 266
66651: PUSH
66652: LD_INT 32
66654: PUSH
66655: LD_INT 31
66657: PUSH
66658: EMPTY
66659: LIST
66660: LIST
66661: IN
66662: IFFALSE 66682
// solds := solds diff i else
66664: LD_ADDR_VAR 0 2
66668: PUSH
66669: LD_VAR 0 2
66673: PUSH
66674: LD_VAR 0 7
66678: DIFF
66679: ST_TO_ADDR
66680: GO 66694
// SetTag ( i , 18 ) ;
66682: LD_VAR 0 7
66686: PPUSH
66687: LD_INT 18
66689: PPUSH
66690: CALL_OW 109
66694: GO 66634
66696: POP
66697: POP
// if not solds then
66698: LD_VAR 0 2
66702: NOT
66703: IFFALSE 66707
// exit ;
66705: GO 67112
// repeat wait ( 0 0$1 ) ;
66707: LD_INT 35
66709: PPUSH
66710: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
66714: LD_ADDR_VAR 0 5
66718: PUSH
66719: LD_VAR 0 6
66723: PPUSH
66724: LD_VAR 0 3
66728: PPUSH
66729: CALL 66521 0 2
66733: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
66734: LD_EXP 102
66738: PUSH
66739: LD_VAR 0 1
66743: ARRAY
66744: NOT
66745: PUSH
66746: LD_EXP 102
66750: PUSH
66751: LD_VAR 0 1
66755: ARRAY
66756: PUSH
66757: EMPTY
66758: EQUAL
66759: OR
66760: IFFALSE 66797
// begin for i in solds do
66762: LD_ADDR_VAR 0 7
66766: PUSH
66767: LD_VAR 0 2
66771: PUSH
66772: FOR_IN
66773: IFFALSE 66786
// ComStop ( i ) ;
66775: LD_VAR 0 7
66779: PPUSH
66780: CALL_OW 141
66784: GO 66772
66786: POP
66787: POP
// solds := [ ] ;
66788: LD_ADDR_VAR 0 2
66792: PUSH
66793: EMPTY
66794: ST_TO_ADDR
// exit ;
66795: GO 67112
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
66797: LD_VAR 0 5
66801: NOT
66802: PUSH
66803: LD_VAR 0 5
66807: PUSH
66808: LD_INT 3
66810: GREATER
66811: OR
66812: PUSH
66813: LD_EXP 124
66817: PUSH
66818: LD_VAR 0 1
66822: ARRAY
66823: OR
66824: IFFALSE 66865
// begin for i in solds do
66826: LD_ADDR_VAR 0 7
66830: PUSH
66831: LD_VAR 0 2
66835: PUSH
66836: FOR_IN
66837: IFFALSE 66861
// if HasTask ( i ) then
66839: LD_VAR 0 7
66843: PPUSH
66844: CALL_OW 314
66848: IFFALSE 66859
// ComStop ( i ) ;
66850: LD_VAR 0 7
66854: PPUSH
66855: CALL_OW 141
66859: GO 66836
66861: POP
66862: POP
// break ;
66863: GO 67100
// end ; for i in solds do
66865: LD_ADDR_VAR 0 7
66869: PUSH
66870: LD_VAR 0 2
66874: PUSH
66875: FOR_IN
66876: IFFALSE 67092
// begin if IsInUnit ( i ) then
66878: LD_VAR 0 7
66882: PPUSH
66883: CALL_OW 310
66887: IFFALSE 66898
// ComExitBuilding ( i ) ;
66889: LD_VAR 0 7
66893: PPUSH
66894: CALL_OW 122
// if GetLives ( i ) > 333 then
66898: LD_VAR 0 7
66902: PPUSH
66903: CALL_OW 256
66907: PUSH
66908: LD_INT 333
66910: GREATER
66911: IFFALSE 66939
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
66913: LD_VAR 0 7
66917: PPUSH
66918: LD_VAR 0 5
66922: PPUSH
66923: LD_VAR 0 7
66927: PPUSH
66928: CALL_OW 74
66932: PPUSH
66933: CALL_OW 115
66937: GO 67090
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
66939: LD_ADDR_VAR 0 8
66943: PUSH
66944: LD_EXP 102
66948: PUSH
66949: LD_VAR 0 1
66953: ARRAY
66954: PPUSH
66955: LD_INT 2
66957: PUSH
66958: LD_INT 30
66960: PUSH
66961: LD_INT 0
66963: PUSH
66964: EMPTY
66965: LIST
66966: LIST
66967: PUSH
66968: LD_INT 30
66970: PUSH
66971: LD_INT 1
66973: PUSH
66974: EMPTY
66975: LIST
66976: LIST
66977: PUSH
66978: LD_INT 30
66980: PUSH
66981: LD_INT 6
66983: PUSH
66984: EMPTY
66985: LIST
66986: LIST
66987: PUSH
66988: EMPTY
66989: LIST
66990: LIST
66991: LIST
66992: LIST
66993: PPUSH
66994: CALL_OW 72
66998: PPUSH
66999: LD_VAR 0 7
67003: PPUSH
67004: CALL_OW 74
67008: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
67009: LD_VAR 0 7
67013: PPUSH
67014: LD_VAR 0 8
67018: PPUSH
67019: CALL_OW 250
67023: PPUSH
67024: LD_INT 3
67026: PPUSH
67027: LD_INT 5
67029: PPUSH
67030: CALL_OW 272
67034: PPUSH
67035: LD_VAR 0 8
67039: PPUSH
67040: CALL_OW 251
67044: PPUSH
67045: LD_INT 3
67047: PPUSH
67048: LD_INT 5
67050: PPUSH
67051: CALL_OW 273
67055: PPUSH
67056: CALL_OW 111
// SetTag ( i , 0 ) ;
67060: LD_VAR 0 7
67064: PPUSH
67065: LD_INT 0
67067: PPUSH
67068: CALL_OW 109
// solds := solds diff i ;
67072: LD_ADDR_VAR 0 2
67076: PUSH
67077: LD_VAR 0 2
67081: PUSH
67082: LD_VAR 0 7
67086: DIFF
67087: ST_TO_ADDR
// continue ;
67088: GO 66875
// end ; end ;
67090: GO 66875
67092: POP
67093: POP
// until solds ;
67094: LD_VAR 0 2
67098: IFFALSE 66707
// MC_Reset ( base , 18 ) ;
67100: LD_VAR 0 1
67104: PPUSH
67105: LD_INT 18
67107: PPUSH
67108: CALL 38933 0 2
// end ;
67112: LD_VAR 0 4
67116: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
67117: LD_INT 0
67119: PPUSH
67120: PPUSH
67121: PPUSH
67122: PPUSH
67123: PPUSH
67124: PPUSH
67125: PPUSH
67126: PPUSH
67127: PPUSH
67128: PPUSH
67129: PPUSH
67130: PPUSH
67131: PPUSH
67132: PPUSH
67133: PPUSH
67134: PPUSH
67135: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
67136: LD_ADDR_VAR 0 13
67140: PUSH
67141: LD_EXP 102
67145: PUSH
67146: LD_VAR 0 1
67150: ARRAY
67151: PPUSH
67152: LD_INT 25
67154: PUSH
67155: LD_INT 3
67157: PUSH
67158: EMPTY
67159: LIST
67160: LIST
67161: PPUSH
67162: CALL_OW 72
67166: ST_TO_ADDR
// if mc_remote_driver [ base ] then
67167: LD_EXP 142
67171: PUSH
67172: LD_VAR 0 1
67176: ARRAY
67177: IFFALSE 67201
// mechs := mechs diff mc_remote_driver [ base ] ;
67179: LD_ADDR_VAR 0 13
67183: PUSH
67184: LD_VAR 0 13
67188: PUSH
67189: LD_EXP 142
67193: PUSH
67194: LD_VAR 0 1
67198: ARRAY
67199: DIFF
67200: ST_TO_ADDR
// for i in mechs do
67201: LD_ADDR_VAR 0 5
67205: PUSH
67206: LD_VAR 0 13
67210: PUSH
67211: FOR_IN
67212: IFFALSE 67247
// if GetTag ( i ) > 0 then
67214: LD_VAR 0 5
67218: PPUSH
67219: CALL_OW 110
67223: PUSH
67224: LD_INT 0
67226: GREATER
67227: IFFALSE 67245
// mechs := mechs diff i ;
67229: LD_ADDR_VAR 0 13
67233: PUSH
67234: LD_VAR 0 13
67238: PUSH
67239: LD_VAR 0 5
67243: DIFF
67244: ST_TO_ADDR
67245: GO 67211
67247: POP
67248: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67249: LD_ADDR_VAR 0 9
67253: PUSH
67254: LD_EXP 102
67258: PUSH
67259: LD_VAR 0 1
67263: ARRAY
67264: PPUSH
67265: LD_INT 2
67267: PUSH
67268: LD_INT 25
67270: PUSH
67271: LD_INT 1
67273: PUSH
67274: EMPTY
67275: LIST
67276: LIST
67277: PUSH
67278: LD_INT 25
67280: PUSH
67281: LD_INT 5
67283: PUSH
67284: EMPTY
67285: LIST
67286: LIST
67287: PUSH
67288: LD_INT 25
67290: PUSH
67291: LD_INT 8
67293: PUSH
67294: EMPTY
67295: LIST
67296: LIST
67297: PUSH
67298: LD_INT 25
67300: PUSH
67301: LD_INT 9
67303: PUSH
67304: EMPTY
67305: LIST
67306: LIST
67307: PUSH
67308: EMPTY
67309: LIST
67310: LIST
67311: LIST
67312: LIST
67313: LIST
67314: PPUSH
67315: CALL_OW 72
67319: ST_TO_ADDR
// if not defenders and not solds then
67320: LD_VAR 0 2
67324: NOT
67325: PUSH
67326: LD_VAR 0 9
67330: NOT
67331: AND
67332: IFFALSE 67336
// exit ;
67334: GO 68962
// depot_under_attack := false ;
67336: LD_ADDR_VAR 0 17
67340: PUSH
67341: LD_INT 0
67343: ST_TO_ADDR
// sold_defenders := [ ] ;
67344: LD_ADDR_VAR 0 18
67348: PUSH
67349: EMPTY
67350: ST_TO_ADDR
// if mechs then
67351: LD_VAR 0 13
67355: IFFALSE 67484
// for i in defenders do
67357: LD_ADDR_VAR 0 5
67361: PUSH
67362: LD_VAR 0 2
67366: PUSH
67367: FOR_IN
67368: IFFALSE 67482
// begin SetTag ( i , 20 ) ;
67370: LD_VAR 0 5
67374: PPUSH
67375: LD_INT 20
67377: PPUSH
67378: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
67382: LD_VAR 0 5
67386: PPUSH
67387: CALL_OW 263
67391: PUSH
67392: LD_INT 1
67394: EQUAL
67395: PUSH
67396: LD_VAR 0 5
67400: PPUSH
67401: CALL_OW 311
67405: NOT
67406: AND
67407: PUSH
67408: LD_VAR 0 13
67412: AND
67413: IFFALSE 67480
// begin un := mechs [ 1 ] ;
67415: LD_ADDR_VAR 0 11
67419: PUSH
67420: LD_VAR 0 13
67424: PUSH
67425: LD_INT 1
67427: ARRAY
67428: ST_TO_ADDR
// ComExitBuilding ( un ) ;
67429: LD_VAR 0 11
67433: PPUSH
67434: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
67438: LD_VAR 0 11
67442: PPUSH
67443: LD_VAR 0 5
67447: PPUSH
67448: CALL_OW 180
// SetTag ( un , 19 ) ;
67452: LD_VAR 0 11
67456: PPUSH
67457: LD_INT 19
67459: PPUSH
67460: CALL_OW 109
// mechs := mechs diff un ;
67464: LD_ADDR_VAR 0 13
67468: PUSH
67469: LD_VAR 0 13
67473: PUSH
67474: LD_VAR 0 11
67478: DIFF
67479: ST_TO_ADDR
// end ; end ;
67480: GO 67367
67482: POP
67483: POP
// if solds then
67484: LD_VAR 0 9
67488: IFFALSE 67547
// for i in solds do
67490: LD_ADDR_VAR 0 5
67494: PUSH
67495: LD_VAR 0 9
67499: PUSH
67500: FOR_IN
67501: IFFALSE 67545
// if not GetTag ( i ) then
67503: LD_VAR 0 5
67507: PPUSH
67508: CALL_OW 110
67512: NOT
67513: IFFALSE 67543
// begin defenders := defenders union i ;
67515: LD_ADDR_VAR 0 2
67519: PUSH
67520: LD_VAR 0 2
67524: PUSH
67525: LD_VAR 0 5
67529: UNION
67530: ST_TO_ADDR
// SetTag ( i , 18 ) ;
67531: LD_VAR 0 5
67535: PPUSH
67536: LD_INT 18
67538: PPUSH
67539: CALL_OW 109
// end ;
67543: GO 67500
67545: POP
67546: POP
// repeat wait ( 0 0$1 ) ;
67547: LD_INT 35
67549: PPUSH
67550: CALL_OW 67
// enemy := mc_scan [ base ] ;
67554: LD_ADDR_VAR 0 3
67558: PUSH
67559: LD_EXP 125
67563: PUSH
67564: LD_VAR 0 1
67568: ARRAY
67569: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
67570: LD_EXP 102
67574: PUSH
67575: LD_VAR 0 1
67579: ARRAY
67580: NOT
67581: PUSH
67582: LD_EXP 102
67586: PUSH
67587: LD_VAR 0 1
67591: ARRAY
67592: PUSH
67593: EMPTY
67594: EQUAL
67595: OR
67596: IFFALSE 67633
// begin for i in defenders do
67598: LD_ADDR_VAR 0 5
67602: PUSH
67603: LD_VAR 0 2
67607: PUSH
67608: FOR_IN
67609: IFFALSE 67622
// ComStop ( i ) ;
67611: LD_VAR 0 5
67615: PPUSH
67616: CALL_OW 141
67620: GO 67608
67622: POP
67623: POP
// defenders := [ ] ;
67624: LD_ADDR_VAR 0 2
67628: PUSH
67629: EMPTY
67630: ST_TO_ADDR
// exit ;
67631: GO 68962
// end ; for i in defenders do
67633: LD_ADDR_VAR 0 5
67637: PUSH
67638: LD_VAR 0 2
67642: PUSH
67643: FOR_IN
67644: IFFALSE 68462
// begin e := NearestUnitToUnit ( enemy , i ) ;
67646: LD_ADDR_VAR 0 14
67650: PUSH
67651: LD_VAR 0 3
67655: PPUSH
67656: LD_VAR 0 5
67660: PPUSH
67661: CALL_OW 74
67665: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67666: LD_ADDR_VAR 0 8
67670: PUSH
67671: LD_EXP 102
67675: PUSH
67676: LD_VAR 0 1
67680: ARRAY
67681: PPUSH
67682: LD_INT 2
67684: PUSH
67685: LD_INT 30
67687: PUSH
67688: LD_INT 0
67690: PUSH
67691: EMPTY
67692: LIST
67693: LIST
67694: PUSH
67695: LD_INT 30
67697: PUSH
67698: LD_INT 1
67700: PUSH
67701: EMPTY
67702: LIST
67703: LIST
67704: PUSH
67705: EMPTY
67706: LIST
67707: LIST
67708: LIST
67709: PPUSH
67710: CALL_OW 72
67714: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
67715: LD_ADDR_VAR 0 17
67719: PUSH
67720: LD_VAR 0 8
67724: NOT
67725: PUSH
67726: LD_VAR 0 8
67730: PPUSH
67731: LD_INT 3
67733: PUSH
67734: LD_INT 24
67736: PUSH
67737: LD_INT 600
67739: PUSH
67740: EMPTY
67741: LIST
67742: LIST
67743: PUSH
67744: EMPTY
67745: LIST
67746: LIST
67747: PPUSH
67748: CALL_OW 72
67752: OR
67753: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
67754: LD_VAR 0 5
67758: PPUSH
67759: CALL_OW 247
67763: PUSH
67764: LD_INT 2
67766: DOUBLE
67767: EQUAL
67768: IFTRUE 67772
67770: GO 68168
67772: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
67773: LD_VAR 0 5
67777: PPUSH
67778: CALL_OW 256
67782: PUSH
67783: LD_INT 650
67785: GREATER
67786: PUSH
67787: LD_VAR 0 5
67791: PPUSH
67792: LD_VAR 0 14
67796: PPUSH
67797: CALL_OW 296
67801: PUSH
67802: LD_INT 40
67804: LESS
67805: PUSH
67806: LD_VAR 0 14
67810: PPUSH
67811: LD_EXP 127
67815: PUSH
67816: LD_VAR 0 1
67820: ARRAY
67821: PPUSH
67822: CALL_OW 308
67826: OR
67827: AND
67828: IFFALSE 67950
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
67830: LD_VAR 0 5
67834: PPUSH
67835: CALL_OW 262
67839: PUSH
67840: LD_INT 1
67842: EQUAL
67843: PUSH
67844: LD_VAR 0 5
67848: PPUSH
67849: CALL_OW 261
67853: PUSH
67854: LD_INT 30
67856: LESS
67857: AND
67858: PUSH
67859: LD_VAR 0 8
67863: AND
67864: IFFALSE 67934
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
67866: LD_VAR 0 5
67870: PPUSH
67871: LD_VAR 0 8
67875: PPUSH
67876: LD_VAR 0 5
67880: PPUSH
67881: CALL_OW 74
67885: PPUSH
67886: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
67890: LD_VAR 0 5
67894: PPUSH
67895: LD_VAR 0 8
67899: PPUSH
67900: LD_VAR 0 5
67904: PPUSH
67905: CALL_OW 74
67909: PPUSH
67910: CALL_OW 296
67914: PUSH
67915: LD_INT 6
67917: LESS
67918: IFFALSE 67932
// SetFuel ( i , 100 ) ;
67920: LD_VAR 0 5
67924: PPUSH
67925: LD_INT 100
67927: PPUSH
67928: CALL_OW 240
// end else
67932: GO 67948
// ComAttackUnit ( i , e ) ;
67934: LD_VAR 0 5
67938: PPUSH
67939: LD_VAR 0 14
67943: PPUSH
67944: CALL_OW 115
// end else
67948: GO 68051
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
67950: LD_VAR 0 14
67954: PPUSH
67955: LD_EXP 127
67959: PUSH
67960: LD_VAR 0 1
67964: ARRAY
67965: PPUSH
67966: CALL_OW 308
67970: NOT
67971: PUSH
67972: LD_VAR 0 5
67976: PPUSH
67977: LD_VAR 0 14
67981: PPUSH
67982: CALL_OW 296
67986: PUSH
67987: LD_INT 40
67989: GREATEREQUAL
67990: AND
67991: PUSH
67992: LD_VAR 0 5
67996: PPUSH
67997: CALL_OW 256
68001: PUSH
68002: LD_INT 650
68004: LESSEQUAL
68005: OR
68006: PUSH
68007: LD_VAR 0 5
68011: PPUSH
68012: LD_EXP 126
68016: PUSH
68017: LD_VAR 0 1
68021: ARRAY
68022: PPUSH
68023: CALL_OW 308
68027: NOT
68028: AND
68029: IFFALSE 68051
// ComMoveToArea ( i , mc_parking [ base ] ) ;
68031: LD_VAR 0 5
68035: PPUSH
68036: LD_EXP 126
68040: PUSH
68041: LD_VAR 0 1
68045: ARRAY
68046: PPUSH
68047: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
68051: LD_VAR 0 5
68055: PPUSH
68056: CALL_OW 256
68060: PUSH
68061: LD_INT 998
68063: LESS
68064: PUSH
68065: LD_VAR 0 5
68069: PPUSH
68070: CALL_OW 263
68074: PUSH
68075: LD_INT 1
68077: EQUAL
68078: AND
68079: PUSH
68080: LD_VAR 0 5
68084: PPUSH
68085: CALL_OW 311
68089: AND
68090: PUSH
68091: LD_VAR 0 5
68095: PPUSH
68096: LD_EXP 126
68100: PUSH
68101: LD_VAR 0 1
68105: ARRAY
68106: PPUSH
68107: CALL_OW 308
68111: AND
68112: IFFALSE 68166
// begin mech := IsDrivenBy ( i ) ;
68114: LD_ADDR_VAR 0 10
68118: PUSH
68119: LD_VAR 0 5
68123: PPUSH
68124: CALL_OW 311
68128: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
68129: LD_VAR 0 10
68133: PPUSH
68134: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
68138: LD_VAR 0 10
68142: PPUSH
68143: LD_VAR 0 5
68147: PPUSH
68148: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
68152: LD_VAR 0 10
68156: PPUSH
68157: LD_VAR 0 5
68161: PPUSH
68162: CALL_OW 180
// end ; end ; unit_human :
68166: GO 68433
68168: LD_INT 1
68170: DOUBLE
68171: EQUAL
68172: IFTRUE 68176
68174: GO 68432
68176: POP
// begin b := IsInUnit ( i ) ;
68177: LD_ADDR_VAR 0 19
68181: PUSH
68182: LD_VAR 0 5
68186: PPUSH
68187: CALL_OW 310
68191: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
68192: LD_ADDR_VAR 0 20
68196: PUSH
68197: LD_VAR 0 19
68201: NOT
68202: PUSH
68203: LD_VAR 0 19
68207: PPUSH
68208: CALL_OW 266
68212: PUSH
68213: LD_INT 32
68215: PUSH
68216: LD_INT 31
68218: PUSH
68219: EMPTY
68220: LIST
68221: LIST
68222: IN
68223: OR
68224: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
68225: LD_VAR 0 17
68229: PUSH
68230: LD_VAR 0 2
68234: PPUSH
68235: LD_INT 21
68237: PUSH
68238: LD_INT 2
68240: PUSH
68241: EMPTY
68242: LIST
68243: LIST
68244: PPUSH
68245: CALL_OW 72
68249: PUSH
68250: LD_INT 1
68252: LESSEQUAL
68253: OR
68254: PUSH
68255: LD_VAR 0 20
68259: AND
68260: PUSH
68261: LD_VAR 0 5
68265: PUSH
68266: LD_VAR 0 18
68270: IN
68271: NOT
68272: AND
68273: IFFALSE 68366
// begin if b then
68275: LD_VAR 0 19
68279: IFFALSE 68328
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
68281: LD_VAR 0 19
68285: PPUSH
68286: LD_VAR 0 3
68290: PPUSH
68291: LD_VAR 0 19
68295: PPUSH
68296: CALL_OW 74
68300: PPUSH
68301: CALL_OW 296
68305: PUSH
68306: LD_INT 10
68308: LESS
68309: PUSH
68310: LD_VAR 0 19
68314: PPUSH
68315: CALL_OW 461
68319: PUSH
68320: LD_INT 7
68322: NONEQUAL
68323: AND
68324: IFFALSE 68328
// continue ;
68326: GO 67643
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
68328: LD_ADDR_VAR 0 18
68332: PUSH
68333: LD_VAR 0 18
68337: PPUSH
68338: LD_VAR 0 18
68342: PUSH
68343: LD_INT 1
68345: PLUS
68346: PPUSH
68347: LD_VAR 0 5
68351: PPUSH
68352: CALL_OW 1
68356: ST_TO_ADDR
// ComExitBuilding ( i ) ;
68357: LD_VAR 0 5
68361: PPUSH
68362: CALL_OW 122
// end ; if sold_defenders then
68366: LD_VAR 0 18
68370: IFFALSE 68430
// if i in sold_defenders then
68372: LD_VAR 0 5
68376: PUSH
68377: LD_VAR 0 18
68381: IN
68382: IFFALSE 68430
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
68384: LD_VAR 0 5
68388: PPUSH
68389: CALL_OW 314
68393: NOT
68394: PUSH
68395: LD_VAR 0 5
68399: PPUSH
68400: LD_VAR 0 14
68404: PPUSH
68405: CALL_OW 296
68409: PUSH
68410: LD_INT 30
68412: LESS
68413: AND
68414: IFFALSE 68430
// ComAttackUnit ( i , e ) ;
68416: LD_VAR 0 5
68420: PPUSH
68421: LD_VAR 0 14
68425: PPUSH
68426: CALL_OW 115
// end ; end ; end ;
68430: GO 68433
68432: POP
// if IsDead ( i ) then
68433: LD_VAR 0 5
68437: PPUSH
68438: CALL_OW 301
68442: IFFALSE 68460
// defenders := defenders diff i ;
68444: LD_ADDR_VAR 0 2
68448: PUSH
68449: LD_VAR 0 2
68453: PUSH
68454: LD_VAR 0 5
68458: DIFF
68459: ST_TO_ADDR
// end ;
68460: GO 67643
68462: POP
68463: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
68464: LD_VAR 0 3
68468: NOT
68469: PUSH
68470: LD_VAR 0 2
68474: NOT
68475: OR
68476: PUSH
68477: LD_EXP 102
68481: PUSH
68482: LD_VAR 0 1
68486: ARRAY
68487: NOT
68488: OR
68489: IFFALSE 67547
// MC_Reset ( base , 18 ) ;
68491: LD_VAR 0 1
68495: PPUSH
68496: LD_INT 18
68498: PPUSH
68499: CALL 38933 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68503: LD_ADDR_VAR 0 2
68507: PUSH
68508: LD_VAR 0 2
68512: PUSH
68513: LD_VAR 0 2
68517: PPUSH
68518: LD_INT 2
68520: PUSH
68521: LD_INT 25
68523: PUSH
68524: LD_INT 1
68526: PUSH
68527: EMPTY
68528: LIST
68529: LIST
68530: PUSH
68531: LD_INT 25
68533: PUSH
68534: LD_INT 5
68536: PUSH
68537: EMPTY
68538: LIST
68539: LIST
68540: PUSH
68541: LD_INT 25
68543: PUSH
68544: LD_INT 8
68546: PUSH
68547: EMPTY
68548: LIST
68549: LIST
68550: PUSH
68551: LD_INT 25
68553: PUSH
68554: LD_INT 9
68556: PUSH
68557: EMPTY
68558: LIST
68559: LIST
68560: PUSH
68561: EMPTY
68562: LIST
68563: LIST
68564: LIST
68565: LIST
68566: LIST
68567: PPUSH
68568: CALL_OW 72
68572: DIFF
68573: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
68574: LD_VAR 0 3
68578: NOT
68579: PUSH
68580: LD_VAR 0 2
68584: PPUSH
68585: LD_INT 21
68587: PUSH
68588: LD_INT 2
68590: PUSH
68591: EMPTY
68592: LIST
68593: LIST
68594: PPUSH
68595: CALL_OW 72
68599: AND
68600: IFFALSE 68938
// begin tmp := FilterByTag ( defenders , 19 ) ;
68602: LD_ADDR_VAR 0 12
68606: PUSH
68607: LD_VAR 0 2
68611: PPUSH
68612: LD_INT 19
68614: PPUSH
68615: CALL 105401 0 2
68619: ST_TO_ADDR
// if tmp then
68620: LD_VAR 0 12
68624: IFFALSE 68694
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
68626: LD_ADDR_VAR 0 12
68630: PUSH
68631: LD_VAR 0 12
68635: PPUSH
68636: LD_INT 25
68638: PUSH
68639: LD_INT 3
68641: PUSH
68642: EMPTY
68643: LIST
68644: LIST
68645: PPUSH
68646: CALL_OW 72
68650: ST_TO_ADDR
// if tmp then
68651: LD_VAR 0 12
68655: IFFALSE 68694
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
68657: LD_ADDR_EXP 114
68661: PUSH
68662: LD_EXP 114
68666: PPUSH
68667: LD_VAR 0 1
68671: PPUSH
68672: LD_EXP 114
68676: PUSH
68677: LD_VAR 0 1
68681: ARRAY
68682: PUSH
68683: LD_VAR 0 12
68687: UNION
68688: PPUSH
68689: CALL_OW 1
68693: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
68694: LD_VAR 0 1
68698: PPUSH
68699: LD_INT 19
68701: PPUSH
68702: CALL 38933 0 2
// repeat wait ( 0 0$1 ) ;
68706: LD_INT 35
68708: PPUSH
68709: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
68713: LD_EXP 102
68717: PUSH
68718: LD_VAR 0 1
68722: ARRAY
68723: NOT
68724: PUSH
68725: LD_EXP 102
68729: PUSH
68730: LD_VAR 0 1
68734: ARRAY
68735: PUSH
68736: EMPTY
68737: EQUAL
68738: OR
68739: IFFALSE 68776
// begin for i in defenders do
68741: LD_ADDR_VAR 0 5
68745: PUSH
68746: LD_VAR 0 2
68750: PUSH
68751: FOR_IN
68752: IFFALSE 68765
// ComStop ( i ) ;
68754: LD_VAR 0 5
68758: PPUSH
68759: CALL_OW 141
68763: GO 68751
68765: POP
68766: POP
// defenders := [ ] ;
68767: LD_ADDR_VAR 0 2
68771: PUSH
68772: EMPTY
68773: ST_TO_ADDR
// exit ;
68774: GO 68962
// end ; for i in defenders do
68776: LD_ADDR_VAR 0 5
68780: PUSH
68781: LD_VAR 0 2
68785: PUSH
68786: FOR_IN
68787: IFFALSE 68876
// begin if not IsInArea ( i , mc_parking [ base ] ) then
68789: LD_VAR 0 5
68793: PPUSH
68794: LD_EXP 126
68798: PUSH
68799: LD_VAR 0 1
68803: ARRAY
68804: PPUSH
68805: CALL_OW 308
68809: NOT
68810: IFFALSE 68834
// ComMoveToArea ( i , mc_parking [ base ] ) else
68812: LD_VAR 0 5
68816: PPUSH
68817: LD_EXP 126
68821: PUSH
68822: LD_VAR 0 1
68826: ARRAY
68827: PPUSH
68828: CALL_OW 113
68832: GO 68874
// if GetControl ( i ) = control_manual then
68834: LD_VAR 0 5
68838: PPUSH
68839: CALL_OW 263
68843: PUSH
68844: LD_INT 1
68846: EQUAL
68847: IFFALSE 68874
// if IsDrivenBy ( i ) then
68849: LD_VAR 0 5
68853: PPUSH
68854: CALL_OW 311
68858: IFFALSE 68874
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
68860: LD_VAR 0 5
68864: PPUSH
68865: CALL_OW 311
68869: PPUSH
68870: CALL_OW 121
// end ;
68874: GO 68786
68876: POP
68877: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
68878: LD_VAR 0 2
68882: PPUSH
68883: LD_INT 95
68885: PUSH
68886: LD_EXP 126
68890: PUSH
68891: LD_VAR 0 1
68895: ARRAY
68896: PUSH
68897: EMPTY
68898: LIST
68899: LIST
68900: PPUSH
68901: CALL_OW 72
68905: PUSH
68906: LD_VAR 0 2
68910: EQUAL
68911: PUSH
68912: LD_EXP 125
68916: PUSH
68917: LD_VAR 0 1
68921: ARRAY
68922: OR
68923: PUSH
68924: LD_EXP 102
68928: PUSH
68929: LD_VAR 0 1
68933: ARRAY
68934: NOT
68935: OR
68936: IFFALSE 68706
// end ; MC_Reset ( base , 19 ) ;
68938: LD_VAR 0 1
68942: PPUSH
68943: LD_INT 19
68945: PPUSH
68946: CALL 38933 0 2
// MC_Reset ( base , 20 ) ;
68950: LD_VAR 0 1
68954: PPUSH
68955: LD_INT 20
68957: PPUSH
68958: CALL 38933 0 2
// end ;
68962: LD_VAR 0 4
68966: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
68967: LD_INT 0
68969: PPUSH
68970: PPUSH
68971: PPUSH
68972: PPUSH
// result := false ;
68973: LD_ADDR_VAR 0 2
68977: PUSH
68978: LD_INT 0
68980: ST_TO_ADDR
// side := GetSide ( unit ) ;
68981: LD_ADDR_VAR 0 3
68985: PUSH
68986: LD_VAR 0 1
68990: PPUSH
68991: CALL_OW 255
68995: ST_TO_ADDR
// nat := GetNation ( unit ) ;
68996: LD_ADDR_VAR 0 4
69000: PUSH
69001: LD_VAR 0 1
69005: PPUSH
69006: CALL_OW 248
69010: ST_TO_ADDR
// case nat of 1 :
69011: LD_VAR 0 4
69015: PUSH
69016: LD_INT 1
69018: DOUBLE
69019: EQUAL
69020: IFTRUE 69024
69022: GO 69035
69024: POP
// tech := tech_lassight ; 2 :
69025: LD_ADDR_VAR 0 5
69029: PUSH
69030: LD_INT 12
69032: ST_TO_ADDR
69033: GO 69074
69035: LD_INT 2
69037: DOUBLE
69038: EQUAL
69039: IFTRUE 69043
69041: GO 69054
69043: POP
// tech := tech_mortar ; 3 :
69044: LD_ADDR_VAR 0 5
69048: PUSH
69049: LD_INT 41
69051: ST_TO_ADDR
69052: GO 69074
69054: LD_INT 3
69056: DOUBLE
69057: EQUAL
69058: IFTRUE 69062
69060: GO 69073
69062: POP
// tech := tech_bazooka ; end ;
69063: LD_ADDR_VAR 0 5
69067: PUSH
69068: LD_INT 44
69070: ST_TO_ADDR
69071: GO 69074
69073: POP
// if Researched ( side , tech ) then
69074: LD_VAR 0 3
69078: PPUSH
69079: LD_VAR 0 5
69083: PPUSH
69084: CALL_OW 325
69088: IFFALSE 69115
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
69090: LD_ADDR_VAR 0 2
69094: PUSH
69095: LD_INT 5
69097: PUSH
69098: LD_INT 8
69100: PUSH
69101: LD_INT 9
69103: PUSH
69104: EMPTY
69105: LIST
69106: LIST
69107: LIST
69108: PUSH
69109: LD_VAR 0 4
69113: ARRAY
69114: ST_TO_ADDR
// end ;
69115: LD_VAR 0 2
69119: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
69120: LD_INT 0
69122: PPUSH
69123: PPUSH
69124: PPUSH
// if not mines then
69125: LD_VAR 0 2
69129: NOT
69130: IFFALSE 69134
// exit ;
69132: GO 69278
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69134: LD_ADDR_VAR 0 5
69138: PUSH
69139: LD_INT 81
69141: PUSH
69142: LD_VAR 0 1
69146: PUSH
69147: EMPTY
69148: LIST
69149: LIST
69150: PUSH
69151: LD_INT 3
69153: PUSH
69154: LD_INT 21
69156: PUSH
69157: LD_INT 3
69159: PUSH
69160: EMPTY
69161: LIST
69162: LIST
69163: PUSH
69164: EMPTY
69165: LIST
69166: LIST
69167: PUSH
69168: EMPTY
69169: LIST
69170: LIST
69171: PPUSH
69172: CALL_OW 69
69176: ST_TO_ADDR
// for i in mines do
69177: LD_ADDR_VAR 0 4
69181: PUSH
69182: LD_VAR 0 2
69186: PUSH
69187: FOR_IN
69188: IFFALSE 69276
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
69190: LD_VAR 0 4
69194: PUSH
69195: LD_INT 1
69197: ARRAY
69198: PPUSH
69199: LD_VAR 0 4
69203: PUSH
69204: LD_INT 2
69206: ARRAY
69207: PPUSH
69208: CALL_OW 458
69212: NOT
69213: IFFALSE 69217
// continue ;
69215: GO 69187
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
69217: LD_VAR 0 4
69221: PUSH
69222: LD_INT 1
69224: ARRAY
69225: PPUSH
69226: LD_VAR 0 4
69230: PUSH
69231: LD_INT 2
69233: ARRAY
69234: PPUSH
69235: CALL_OW 428
69239: PUSH
69240: LD_VAR 0 5
69244: IN
69245: IFFALSE 69274
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
69247: LD_VAR 0 4
69251: PUSH
69252: LD_INT 1
69254: ARRAY
69255: PPUSH
69256: LD_VAR 0 4
69260: PUSH
69261: LD_INT 2
69263: ARRAY
69264: PPUSH
69265: LD_VAR 0 1
69269: PPUSH
69270: CALL_OW 456
// end ;
69274: GO 69187
69276: POP
69277: POP
// end ;
69278: LD_VAR 0 3
69282: RET
// export function Count ( array ) ; var i ; begin
69283: LD_INT 0
69285: PPUSH
69286: PPUSH
// result := 0 ;
69287: LD_ADDR_VAR 0 2
69291: PUSH
69292: LD_INT 0
69294: ST_TO_ADDR
// for i in array do
69295: LD_ADDR_VAR 0 3
69299: PUSH
69300: LD_VAR 0 1
69304: PUSH
69305: FOR_IN
69306: IFFALSE 69330
// if i then
69308: LD_VAR 0 3
69312: IFFALSE 69328
// result := result + 1 ;
69314: LD_ADDR_VAR 0 2
69318: PUSH
69319: LD_VAR 0 2
69323: PUSH
69324: LD_INT 1
69326: PLUS
69327: ST_TO_ADDR
69328: GO 69305
69330: POP
69331: POP
// end ;
69332: LD_VAR 0 2
69336: RET
// export function IsEmpty ( building ) ; begin
69337: LD_INT 0
69339: PPUSH
// if not building then
69340: LD_VAR 0 1
69344: NOT
69345: IFFALSE 69349
// exit ;
69347: GO 69392
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
69349: LD_ADDR_VAR 0 2
69353: PUSH
69354: LD_VAR 0 1
69358: PUSH
69359: LD_INT 22
69361: PUSH
69362: LD_VAR 0 1
69366: PPUSH
69367: CALL_OW 255
69371: PUSH
69372: EMPTY
69373: LIST
69374: LIST
69375: PUSH
69376: LD_INT 58
69378: PUSH
69379: EMPTY
69380: LIST
69381: PUSH
69382: EMPTY
69383: LIST
69384: LIST
69385: PPUSH
69386: CALL_OW 69
69390: IN
69391: ST_TO_ADDR
// end ;
69392: LD_VAR 0 2
69396: RET
// export function IsNotFull ( building ) ; begin
69397: LD_INT 0
69399: PPUSH
// if not building then
69400: LD_VAR 0 1
69404: NOT
69405: IFFALSE 69409
// exit ;
69407: GO 69428
// result := UnitsInside ( building ) < 6 ;
69409: LD_ADDR_VAR 0 2
69413: PUSH
69414: LD_VAR 0 1
69418: PPUSH
69419: CALL_OW 313
69423: PUSH
69424: LD_INT 6
69426: LESS
69427: ST_TO_ADDR
// end ;
69428: LD_VAR 0 2
69432: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
69433: LD_INT 0
69435: PPUSH
69436: PPUSH
69437: PPUSH
69438: PPUSH
// tmp := [ ] ;
69439: LD_ADDR_VAR 0 3
69443: PUSH
69444: EMPTY
69445: ST_TO_ADDR
// list := [ ] ;
69446: LD_ADDR_VAR 0 5
69450: PUSH
69451: EMPTY
69452: ST_TO_ADDR
// for i = 16 to 25 do
69453: LD_ADDR_VAR 0 4
69457: PUSH
69458: DOUBLE
69459: LD_INT 16
69461: DEC
69462: ST_TO_ADDR
69463: LD_INT 25
69465: PUSH
69466: FOR_TO
69467: IFFALSE 69540
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
69469: LD_ADDR_VAR 0 3
69473: PUSH
69474: LD_VAR 0 3
69478: PUSH
69479: LD_INT 22
69481: PUSH
69482: LD_VAR 0 1
69486: PPUSH
69487: CALL_OW 255
69491: PUSH
69492: EMPTY
69493: LIST
69494: LIST
69495: PUSH
69496: LD_INT 91
69498: PUSH
69499: LD_VAR 0 1
69503: PUSH
69504: LD_INT 6
69506: PUSH
69507: EMPTY
69508: LIST
69509: LIST
69510: LIST
69511: PUSH
69512: LD_INT 30
69514: PUSH
69515: LD_VAR 0 4
69519: PUSH
69520: EMPTY
69521: LIST
69522: LIST
69523: PUSH
69524: EMPTY
69525: LIST
69526: LIST
69527: LIST
69528: PUSH
69529: EMPTY
69530: LIST
69531: PPUSH
69532: CALL_OW 69
69536: ADD
69537: ST_TO_ADDR
69538: GO 69466
69540: POP
69541: POP
// for i = 1 to tmp do
69542: LD_ADDR_VAR 0 4
69546: PUSH
69547: DOUBLE
69548: LD_INT 1
69550: DEC
69551: ST_TO_ADDR
69552: LD_VAR 0 3
69556: PUSH
69557: FOR_TO
69558: IFFALSE 69646
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
69560: LD_ADDR_VAR 0 5
69564: PUSH
69565: LD_VAR 0 5
69569: PUSH
69570: LD_VAR 0 3
69574: PUSH
69575: LD_VAR 0 4
69579: ARRAY
69580: PPUSH
69581: CALL_OW 266
69585: PUSH
69586: LD_VAR 0 3
69590: PUSH
69591: LD_VAR 0 4
69595: ARRAY
69596: PPUSH
69597: CALL_OW 250
69601: PUSH
69602: LD_VAR 0 3
69606: PUSH
69607: LD_VAR 0 4
69611: ARRAY
69612: PPUSH
69613: CALL_OW 251
69617: PUSH
69618: LD_VAR 0 3
69622: PUSH
69623: LD_VAR 0 4
69627: ARRAY
69628: PPUSH
69629: CALL_OW 254
69633: PUSH
69634: EMPTY
69635: LIST
69636: LIST
69637: LIST
69638: LIST
69639: PUSH
69640: EMPTY
69641: LIST
69642: ADD
69643: ST_TO_ADDR
69644: GO 69557
69646: POP
69647: POP
// result := list ;
69648: LD_ADDR_VAR 0 2
69652: PUSH
69653: LD_VAR 0 5
69657: ST_TO_ADDR
// end ;
69658: LD_VAR 0 2
69662: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
69663: LD_INT 0
69665: PPUSH
69666: PPUSH
69667: PPUSH
69668: PPUSH
69669: PPUSH
69670: PPUSH
69671: PPUSH
// if not factory then
69672: LD_VAR 0 1
69676: NOT
69677: IFFALSE 69681
// exit ;
69679: GO 70274
// if control = control_apeman then
69681: LD_VAR 0 4
69685: PUSH
69686: LD_INT 5
69688: EQUAL
69689: IFFALSE 69798
// begin tmp := UnitsInside ( factory ) ;
69691: LD_ADDR_VAR 0 8
69695: PUSH
69696: LD_VAR 0 1
69700: PPUSH
69701: CALL_OW 313
69705: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
69706: LD_VAR 0 8
69710: PPUSH
69711: LD_INT 25
69713: PUSH
69714: LD_INT 12
69716: PUSH
69717: EMPTY
69718: LIST
69719: LIST
69720: PPUSH
69721: CALL_OW 72
69725: NOT
69726: IFFALSE 69736
// control := control_manual ;
69728: LD_ADDR_VAR 0 4
69732: PUSH
69733: LD_INT 1
69735: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
69736: LD_ADDR_VAR 0 8
69740: PUSH
69741: LD_VAR 0 1
69745: PPUSH
69746: CALL 69433 0 1
69750: ST_TO_ADDR
// if tmp then
69751: LD_VAR 0 8
69755: IFFALSE 69798
// begin for i in tmp do
69757: LD_ADDR_VAR 0 7
69761: PUSH
69762: LD_VAR 0 8
69766: PUSH
69767: FOR_IN
69768: IFFALSE 69796
// if i [ 1 ] = b_ext_radio then
69770: LD_VAR 0 7
69774: PUSH
69775: LD_INT 1
69777: ARRAY
69778: PUSH
69779: LD_INT 22
69781: EQUAL
69782: IFFALSE 69794
// begin control := control_remote ;
69784: LD_ADDR_VAR 0 4
69788: PUSH
69789: LD_INT 2
69791: ST_TO_ADDR
// break ;
69792: GO 69796
// end ;
69794: GO 69767
69796: POP
69797: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69798: LD_VAR 0 1
69802: PPUSH
69803: LD_VAR 0 2
69807: PPUSH
69808: LD_VAR 0 3
69812: PPUSH
69813: LD_VAR 0 4
69817: PPUSH
69818: LD_VAR 0 5
69822: PPUSH
69823: CALL_OW 448
69827: IFFALSE 69862
// begin result := [ chassis , engine , control , weapon ] ;
69829: LD_ADDR_VAR 0 6
69833: PUSH
69834: LD_VAR 0 2
69838: PUSH
69839: LD_VAR 0 3
69843: PUSH
69844: LD_VAR 0 4
69848: PUSH
69849: LD_VAR 0 5
69853: PUSH
69854: EMPTY
69855: LIST
69856: LIST
69857: LIST
69858: LIST
69859: ST_TO_ADDR
// exit ;
69860: GO 70274
// end ; _chassis := AvailableChassisList ( factory ) ;
69862: LD_ADDR_VAR 0 9
69866: PUSH
69867: LD_VAR 0 1
69871: PPUSH
69872: CALL_OW 475
69876: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
69877: LD_ADDR_VAR 0 11
69881: PUSH
69882: LD_VAR 0 1
69886: PPUSH
69887: CALL_OW 476
69891: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
69892: LD_ADDR_VAR 0 12
69896: PUSH
69897: LD_VAR 0 1
69901: PPUSH
69902: CALL_OW 477
69906: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
69907: LD_ADDR_VAR 0 10
69911: PUSH
69912: LD_VAR 0 1
69916: PPUSH
69917: CALL_OW 478
69921: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
69922: LD_VAR 0 9
69926: NOT
69927: PUSH
69928: LD_VAR 0 11
69932: NOT
69933: OR
69934: PUSH
69935: LD_VAR 0 12
69939: NOT
69940: OR
69941: PUSH
69942: LD_VAR 0 10
69946: NOT
69947: OR
69948: IFFALSE 69983
// begin result := [ chassis , engine , control , weapon ] ;
69950: LD_ADDR_VAR 0 6
69954: PUSH
69955: LD_VAR 0 2
69959: PUSH
69960: LD_VAR 0 3
69964: PUSH
69965: LD_VAR 0 4
69969: PUSH
69970: LD_VAR 0 5
69974: PUSH
69975: EMPTY
69976: LIST
69977: LIST
69978: LIST
69979: LIST
69980: ST_TO_ADDR
// exit ;
69981: GO 70274
// end ; if not chassis in _chassis then
69983: LD_VAR 0 2
69987: PUSH
69988: LD_VAR 0 9
69992: IN
69993: NOT
69994: IFFALSE 70020
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
69996: LD_ADDR_VAR 0 2
70000: PUSH
70001: LD_VAR 0 9
70005: PUSH
70006: LD_INT 1
70008: PPUSH
70009: LD_VAR 0 9
70013: PPUSH
70014: CALL_OW 12
70018: ARRAY
70019: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
70020: LD_VAR 0 2
70024: PPUSH
70025: LD_VAR 0 3
70029: PPUSH
70030: CALL 70279 0 2
70034: NOT
70035: IFFALSE 70094
// repeat engine := _engine [ 1 ] ;
70037: LD_ADDR_VAR 0 3
70041: PUSH
70042: LD_VAR 0 11
70046: PUSH
70047: LD_INT 1
70049: ARRAY
70050: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
70051: LD_ADDR_VAR 0 11
70055: PUSH
70056: LD_VAR 0 11
70060: PPUSH
70061: LD_INT 1
70063: PPUSH
70064: CALL_OW 3
70068: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
70069: LD_VAR 0 2
70073: PPUSH
70074: LD_VAR 0 3
70078: PPUSH
70079: CALL 70279 0 2
70083: PUSH
70084: LD_VAR 0 11
70088: PUSH
70089: EMPTY
70090: EQUAL
70091: OR
70092: IFFALSE 70037
// if not control in _control then
70094: LD_VAR 0 4
70098: PUSH
70099: LD_VAR 0 12
70103: IN
70104: NOT
70105: IFFALSE 70131
// control := _control [ rand ( 1 , _control ) ] ;
70107: LD_ADDR_VAR 0 4
70111: PUSH
70112: LD_VAR 0 12
70116: PUSH
70117: LD_INT 1
70119: PPUSH
70120: LD_VAR 0 12
70124: PPUSH
70125: CALL_OW 12
70129: ARRAY
70130: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
70131: LD_VAR 0 2
70135: PPUSH
70136: LD_VAR 0 5
70140: PPUSH
70141: CALL 70499 0 2
70145: NOT
70146: IFFALSE 70205
// repeat weapon := _weapon [ 1 ] ;
70148: LD_ADDR_VAR 0 5
70152: PUSH
70153: LD_VAR 0 10
70157: PUSH
70158: LD_INT 1
70160: ARRAY
70161: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
70162: LD_ADDR_VAR 0 10
70166: PUSH
70167: LD_VAR 0 10
70171: PPUSH
70172: LD_INT 1
70174: PPUSH
70175: CALL_OW 3
70179: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
70180: LD_VAR 0 2
70184: PPUSH
70185: LD_VAR 0 5
70189: PPUSH
70190: CALL 70499 0 2
70194: PUSH
70195: LD_VAR 0 10
70199: PUSH
70200: EMPTY
70201: EQUAL
70202: OR
70203: IFFALSE 70148
// result := [ ] ;
70205: LD_ADDR_VAR 0 6
70209: PUSH
70210: EMPTY
70211: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70212: LD_VAR 0 1
70216: PPUSH
70217: LD_VAR 0 2
70221: PPUSH
70222: LD_VAR 0 3
70226: PPUSH
70227: LD_VAR 0 4
70231: PPUSH
70232: LD_VAR 0 5
70236: PPUSH
70237: CALL_OW 448
70241: IFFALSE 70274
// result := [ chassis , engine , control , weapon ] ;
70243: LD_ADDR_VAR 0 6
70247: PUSH
70248: LD_VAR 0 2
70252: PUSH
70253: LD_VAR 0 3
70257: PUSH
70258: LD_VAR 0 4
70262: PUSH
70263: LD_VAR 0 5
70267: PUSH
70268: EMPTY
70269: LIST
70270: LIST
70271: LIST
70272: LIST
70273: ST_TO_ADDR
// end ;
70274: LD_VAR 0 6
70278: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
70279: LD_INT 0
70281: PPUSH
// if not chassis or not engine then
70282: LD_VAR 0 1
70286: NOT
70287: PUSH
70288: LD_VAR 0 2
70292: NOT
70293: OR
70294: IFFALSE 70298
// exit ;
70296: GO 70494
// case engine of engine_solar :
70298: LD_VAR 0 2
70302: PUSH
70303: LD_INT 2
70305: DOUBLE
70306: EQUAL
70307: IFTRUE 70311
70309: GO 70349
70311: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
70312: LD_ADDR_VAR 0 3
70316: PUSH
70317: LD_INT 11
70319: PUSH
70320: LD_INT 12
70322: PUSH
70323: LD_INT 13
70325: PUSH
70326: LD_INT 14
70328: PUSH
70329: LD_INT 1
70331: PUSH
70332: LD_INT 2
70334: PUSH
70335: LD_INT 3
70337: PUSH
70338: EMPTY
70339: LIST
70340: LIST
70341: LIST
70342: LIST
70343: LIST
70344: LIST
70345: LIST
70346: ST_TO_ADDR
70347: GO 70478
70349: LD_INT 1
70351: DOUBLE
70352: EQUAL
70353: IFTRUE 70357
70355: GO 70419
70357: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
70358: LD_ADDR_VAR 0 3
70362: PUSH
70363: LD_INT 11
70365: PUSH
70366: LD_INT 12
70368: PUSH
70369: LD_INT 13
70371: PUSH
70372: LD_INT 14
70374: PUSH
70375: LD_INT 1
70377: PUSH
70378: LD_INT 2
70380: PUSH
70381: LD_INT 3
70383: PUSH
70384: LD_INT 4
70386: PUSH
70387: LD_INT 5
70389: PUSH
70390: LD_INT 21
70392: PUSH
70393: LD_INT 23
70395: PUSH
70396: LD_INT 22
70398: PUSH
70399: LD_INT 24
70401: PUSH
70402: EMPTY
70403: LIST
70404: LIST
70405: LIST
70406: LIST
70407: LIST
70408: LIST
70409: LIST
70410: LIST
70411: LIST
70412: LIST
70413: LIST
70414: LIST
70415: LIST
70416: ST_TO_ADDR
70417: GO 70478
70419: LD_INT 3
70421: DOUBLE
70422: EQUAL
70423: IFTRUE 70427
70425: GO 70477
70427: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70428: LD_ADDR_VAR 0 3
70432: PUSH
70433: LD_INT 13
70435: PUSH
70436: LD_INT 14
70438: PUSH
70439: LD_INT 2
70441: PUSH
70442: LD_INT 3
70444: PUSH
70445: LD_INT 4
70447: PUSH
70448: LD_INT 5
70450: PUSH
70451: LD_INT 21
70453: PUSH
70454: LD_INT 22
70456: PUSH
70457: LD_INT 23
70459: PUSH
70460: LD_INT 24
70462: PUSH
70463: EMPTY
70464: LIST
70465: LIST
70466: LIST
70467: LIST
70468: LIST
70469: LIST
70470: LIST
70471: LIST
70472: LIST
70473: LIST
70474: ST_TO_ADDR
70475: GO 70478
70477: POP
// result := ( chassis in result ) ;
70478: LD_ADDR_VAR 0 3
70482: PUSH
70483: LD_VAR 0 1
70487: PUSH
70488: LD_VAR 0 3
70492: IN
70493: ST_TO_ADDR
// end ;
70494: LD_VAR 0 3
70498: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
70499: LD_INT 0
70501: PPUSH
// if not chassis or not weapon then
70502: LD_VAR 0 1
70506: NOT
70507: PUSH
70508: LD_VAR 0 2
70512: NOT
70513: OR
70514: IFFALSE 70518
// exit ;
70516: GO 71544
// case weapon of us_machine_gun :
70518: LD_VAR 0 2
70522: PUSH
70523: LD_INT 2
70525: DOUBLE
70526: EQUAL
70527: IFTRUE 70531
70529: GO 70561
70531: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
70532: LD_ADDR_VAR 0 3
70536: PUSH
70537: LD_INT 1
70539: PUSH
70540: LD_INT 2
70542: PUSH
70543: LD_INT 3
70545: PUSH
70546: LD_INT 4
70548: PUSH
70549: LD_INT 5
70551: PUSH
70552: EMPTY
70553: LIST
70554: LIST
70555: LIST
70556: LIST
70557: LIST
70558: ST_TO_ADDR
70559: GO 71528
70561: LD_INT 3
70563: DOUBLE
70564: EQUAL
70565: IFTRUE 70569
70567: GO 70599
70569: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
70570: LD_ADDR_VAR 0 3
70574: PUSH
70575: LD_INT 1
70577: PUSH
70578: LD_INT 2
70580: PUSH
70581: LD_INT 3
70583: PUSH
70584: LD_INT 4
70586: PUSH
70587: LD_INT 5
70589: PUSH
70590: EMPTY
70591: LIST
70592: LIST
70593: LIST
70594: LIST
70595: LIST
70596: ST_TO_ADDR
70597: GO 71528
70599: LD_INT 11
70601: DOUBLE
70602: EQUAL
70603: IFTRUE 70607
70605: GO 70637
70607: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
70608: LD_ADDR_VAR 0 3
70612: PUSH
70613: LD_INT 1
70615: PUSH
70616: LD_INT 2
70618: PUSH
70619: LD_INT 3
70621: PUSH
70622: LD_INT 4
70624: PUSH
70625: LD_INT 5
70627: PUSH
70628: EMPTY
70629: LIST
70630: LIST
70631: LIST
70632: LIST
70633: LIST
70634: ST_TO_ADDR
70635: GO 71528
70637: LD_INT 4
70639: DOUBLE
70640: EQUAL
70641: IFTRUE 70645
70643: GO 70671
70645: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
70646: LD_ADDR_VAR 0 3
70650: PUSH
70651: LD_INT 2
70653: PUSH
70654: LD_INT 3
70656: PUSH
70657: LD_INT 4
70659: PUSH
70660: LD_INT 5
70662: PUSH
70663: EMPTY
70664: LIST
70665: LIST
70666: LIST
70667: LIST
70668: ST_TO_ADDR
70669: GO 71528
70671: LD_INT 5
70673: DOUBLE
70674: EQUAL
70675: IFTRUE 70679
70677: GO 70705
70679: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
70680: LD_ADDR_VAR 0 3
70684: PUSH
70685: LD_INT 2
70687: PUSH
70688: LD_INT 3
70690: PUSH
70691: LD_INT 4
70693: PUSH
70694: LD_INT 5
70696: PUSH
70697: EMPTY
70698: LIST
70699: LIST
70700: LIST
70701: LIST
70702: ST_TO_ADDR
70703: GO 71528
70705: LD_INT 9
70707: DOUBLE
70708: EQUAL
70709: IFTRUE 70713
70711: GO 70739
70713: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
70714: LD_ADDR_VAR 0 3
70718: PUSH
70719: LD_INT 2
70721: PUSH
70722: LD_INT 3
70724: PUSH
70725: LD_INT 4
70727: PUSH
70728: LD_INT 5
70730: PUSH
70731: EMPTY
70732: LIST
70733: LIST
70734: LIST
70735: LIST
70736: ST_TO_ADDR
70737: GO 71528
70739: LD_INT 7
70741: DOUBLE
70742: EQUAL
70743: IFTRUE 70747
70745: GO 70773
70747: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
70748: LD_ADDR_VAR 0 3
70752: PUSH
70753: LD_INT 2
70755: PUSH
70756: LD_INT 3
70758: PUSH
70759: LD_INT 4
70761: PUSH
70762: LD_INT 5
70764: PUSH
70765: EMPTY
70766: LIST
70767: LIST
70768: LIST
70769: LIST
70770: ST_TO_ADDR
70771: GO 71528
70773: LD_INT 12
70775: DOUBLE
70776: EQUAL
70777: IFTRUE 70781
70779: GO 70807
70781: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
70782: LD_ADDR_VAR 0 3
70786: PUSH
70787: LD_INT 2
70789: PUSH
70790: LD_INT 3
70792: PUSH
70793: LD_INT 4
70795: PUSH
70796: LD_INT 5
70798: PUSH
70799: EMPTY
70800: LIST
70801: LIST
70802: LIST
70803: LIST
70804: ST_TO_ADDR
70805: GO 71528
70807: LD_INT 13
70809: DOUBLE
70810: EQUAL
70811: IFTRUE 70815
70813: GO 70841
70815: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
70816: LD_ADDR_VAR 0 3
70820: PUSH
70821: LD_INT 2
70823: PUSH
70824: LD_INT 3
70826: PUSH
70827: LD_INT 4
70829: PUSH
70830: LD_INT 5
70832: PUSH
70833: EMPTY
70834: LIST
70835: LIST
70836: LIST
70837: LIST
70838: ST_TO_ADDR
70839: GO 71528
70841: LD_INT 14
70843: DOUBLE
70844: EQUAL
70845: IFTRUE 70849
70847: GO 70867
70849: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
70850: LD_ADDR_VAR 0 3
70854: PUSH
70855: LD_INT 4
70857: PUSH
70858: LD_INT 5
70860: PUSH
70861: EMPTY
70862: LIST
70863: LIST
70864: ST_TO_ADDR
70865: GO 71528
70867: LD_INT 6
70869: DOUBLE
70870: EQUAL
70871: IFTRUE 70875
70873: GO 70893
70875: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
70876: LD_ADDR_VAR 0 3
70880: PUSH
70881: LD_INT 4
70883: PUSH
70884: LD_INT 5
70886: PUSH
70887: EMPTY
70888: LIST
70889: LIST
70890: ST_TO_ADDR
70891: GO 71528
70893: LD_INT 10
70895: DOUBLE
70896: EQUAL
70897: IFTRUE 70901
70899: GO 70919
70901: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
70902: LD_ADDR_VAR 0 3
70906: PUSH
70907: LD_INT 4
70909: PUSH
70910: LD_INT 5
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: ST_TO_ADDR
70917: GO 71528
70919: LD_INT 22
70921: DOUBLE
70922: EQUAL
70923: IFTRUE 70927
70925: GO 70953
70927: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
70928: LD_ADDR_VAR 0 3
70932: PUSH
70933: LD_INT 11
70935: PUSH
70936: LD_INT 12
70938: PUSH
70939: LD_INT 13
70941: PUSH
70942: LD_INT 14
70944: PUSH
70945: EMPTY
70946: LIST
70947: LIST
70948: LIST
70949: LIST
70950: ST_TO_ADDR
70951: GO 71528
70953: LD_INT 23
70955: DOUBLE
70956: EQUAL
70957: IFTRUE 70961
70959: GO 70987
70961: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
70962: LD_ADDR_VAR 0 3
70966: PUSH
70967: LD_INT 11
70969: PUSH
70970: LD_INT 12
70972: PUSH
70973: LD_INT 13
70975: PUSH
70976: LD_INT 14
70978: PUSH
70979: EMPTY
70980: LIST
70981: LIST
70982: LIST
70983: LIST
70984: ST_TO_ADDR
70985: GO 71528
70987: LD_INT 24
70989: DOUBLE
70990: EQUAL
70991: IFTRUE 70995
70993: GO 71021
70995: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
70996: LD_ADDR_VAR 0 3
71000: PUSH
71001: LD_INT 11
71003: PUSH
71004: LD_INT 12
71006: PUSH
71007: LD_INT 13
71009: PUSH
71010: LD_INT 14
71012: PUSH
71013: EMPTY
71014: LIST
71015: LIST
71016: LIST
71017: LIST
71018: ST_TO_ADDR
71019: GO 71528
71021: LD_INT 30
71023: DOUBLE
71024: EQUAL
71025: IFTRUE 71029
71027: GO 71055
71029: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
71030: LD_ADDR_VAR 0 3
71034: PUSH
71035: LD_INT 11
71037: PUSH
71038: LD_INT 12
71040: PUSH
71041: LD_INT 13
71043: PUSH
71044: LD_INT 14
71046: PUSH
71047: EMPTY
71048: LIST
71049: LIST
71050: LIST
71051: LIST
71052: ST_TO_ADDR
71053: GO 71528
71055: LD_INT 25
71057: DOUBLE
71058: EQUAL
71059: IFTRUE 71063
71061: GO 71081
71063: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
71064: LD_ADDR_VAR 0 3
71068: PUSH
71069: LD_INT 13
71071: PUSH
71072: LD_INT 14
71074: PUSH
71075: EMPTY
71076: LIST
71077: LIST
71078: ST_TO_ADDR
71079: GO 71528
71081: LD_INT 27
71083: DOUBLE
71084: EQUAL
71085: IFTRUE 71089
71087: GO 71107
71089: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
71090: LD_ADDR_VAR 0 3
71094: PUSH
71095: LD_INT 13
71097: PUSH
71098: LD_INT 14
71100: PUSH
71101: EMPTY
71102: LIST
71103: LIST
71104: ST_TO_ADDR
71105: GO 71528
71107: LD_INT 28
71109: DOUBLE
71110: EQUAL
71111: IFTRUE 71115
71113: GO 71133
71115: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
71116: LD_ADDR_VAR 0 3
71120: PUSH
71121: LD_INT 13
71123: PUSH
71124: LD_INT 14
71126: PUSH
71127: EMPTY
71128: LIST
71129: LIST
71130: ST_TO_ADDR
71131: GO 71528
71133: LD_INT 29
71135: DOUBLE
71136: EQUAL
71137: IFTRUE 71141
71139: GO 71159
71141: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
71142: LD_ADDR_VAR 0 3
71146: PUSH
71147: LD_INT 13
71149: PUSH
71150: LD_INT 14
71152: PUSH
71153: EMPTY
71154: LIST
71155: LIST
71156: ST_TO_ADDR
71157: GO 71528
71159: LD_INT 31
71161: DOUBLE
71162: EQUAL
71163: IFTRUE 71167
71165: GO 71185
71167: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
71168: LD_ADDR_VAR 0 3
71172: PUSH
71173: LD_INT 13
71175: PUSH
71176: LD_INT 14
71178: PUSH
71179: EMPTY
71180: LIST
71181: LIST
71182: ST_TO_ADDR
71183: GO 71528
71185: LD_INT 26
71187: DOUBLE
71188: EQUAL
71189: IFTRUE 71193
71191: GO 71211
71193: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
71194: LD_ADDR_VAR 0 3
71198: PUSH
71199: LD_INT 13
71201: PUSH
71202: LD_INT 14
71204: PUSH
71205: EMPTY
71206: LIST
71207: LIST
71208: ST_TO_ADDR
71209: GO 71528
71211: LD_INT 42
71213: DOUBLE
71214: EQUAL
71215: IFTRUE 71219
71217: GO 71245
71219: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
71220: LD_ADDR_VAR 0 3
71224: PUSH
71225: LD_INT 21
71227: PUSH
71228: LD_INT 22
71230: PUSH
71231: LD_INT 23
71233: PUSH
71234: LD_INT 24
71236: PUSH
71237: EMPTY
71238: LIST
71239: LIST
71240: LIST
71241: LIST
71242: ST_TO_ADDR
71243: GO 71528
71245: LD_INT 43
71247: DOUBLE
71248: EQUAL
71249: IFTRUE 71253
71251: GO 71279
71253: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
71254: LD_ADDR_VAR 0 3
71258: PUSH
71259: LD_INT 21
71261: PUSH
71262: LD_INT 22
71264: PUSH
71265: LD_INT 23
71267: PUSH
71268: LD_INT 24
71270: PUSH
71271: EMPTY
71272: LIST
71273: LIST
71274: LIST
71275: LIST
71276: ST_TO_ADDR
71277: GO 71528
71279: LD_INT 44
71281: DOUBLE
71282: EQUAL
71283: IFTRUE 71287
71285: GO 71313
71287: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
71288: LD_ADDR_VAR 0 3
71292: PUSH
71293: LD_INT 21
71295: PUSH
71296: LD_INT 22
71298: PUSH
71299: LD_INT 23
71301: PUSH
71302: LD_INT 24
71304: PUSH
71305: EMPTY
71306: LIST
71307: LIST
71308: LIST
71309: LIST
71310: ST_TO_ADDR
71311: GO 71528
71313: LD_INT 45
71315: DOUBLE
71316: EQUAL
71317: IFTRUE 71321
71319: GO 71347
71321: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
71322: LD_ADDR_VAR 0 3
71326: PUSH
71327: LD_INT 21
71329: PUSH
71330: LD_INT 22
71332: PUSH
71333: LD_INT 23
71335: PUSH
71336: LD_INT 24
71338: PUSH
71339: EMPTY
71340: LIST
71341: LIST
71342: LIST
71343: LIST
71344: ST_TO_ADDR
71345: GO 71528
71347: LD_INT 49
71349: DOUBLE
71350: EQUAL
71351: IFTRUE 71355
71353: GO 71381
71355: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
71356: LD_ADDR_VAR 0 3
71360: PUSH
71361: LD_INT 21
71363: PUSH
71364: LD_INT 22
71366: PUSH
71367: LD_INT 23
71369: PUSH
71370: LD_INT 24
71372: PUSH
71373: EMPTY
71374: LIST
71375: LIST
71376: LIST
71377: LIST
71378: ST_TO_ADDR
71379: GO 71528
71381: LD_INT 51
71383: DOUBLE
71384: EQUAL
71385: IFTRUE 71389
71387: GO 71415
71389: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
71390: LD_ADDR_VAR 0 3
71394: PUSH
71395: LD_INT 21
71397: PUSH
71398: LD_INT 22
71400: PUSH
71401: LD_INT 23
71403: PUSH
71404: LD_INT 24
71406: PUSH
71407: EMPTY
71408: LIST
71409: LIST
71410: LIST
71411: LIST
71412: ST_TO_ADDR
71413: GO 71528
71415: LD_INT 52
71417: DOUBLE
71418: EQUAL
71419: IFTRUE 71423
71421: GO 71449
71423: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
71424: LD_ADDR_VAR 0 3
71428: PUSH
71429: LD_INT 21
71431: PUSH
71432: LD_INT 22
71434: PUSH
71435: LD_INT 23
71437: PUSH
71438: LD_INT 24
71440: PUSH
71441: EMPTY
71442: LIST
71443: LIST
71444: LIST
71445: LIST
71446: ST_TO_ADDR
71447: GO 71528
71449: LD_INT 53
71451: DOUBLE
71452: EQUAL
71453: IFTRUE 71457
71455: GO 71475
71457: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
71458: LD_ADDR_VAR 0 3
71462: PUSH
71463: LD_INT 23
71465: PUSH
71466: LD_INT 24
71468: PUSH
71469: EMPTY
71470: LIST
71471: LIST
71472: ST_TO_ADDR
71473: GO 71528
71475: LD_INT 46
71477: DOUBLE
71478: EQUAL
71479: IFTRUE 71483
71481: GO 71501
71483: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
71484: LD_ADDR_VAR 0 3
71488: PUSH
71489: LD_INT 23
71491: PUSH
71492: LD_INT 24
71494: PUSH
71495: EMPTY
71496: LIST
71497: LIST
71498: ST_TO_ADDR
71499: GO 71528
71501: LD_INT 47
71503: DOUBLE
71504: EQUAL
71505: IFTRUE 71509
71507: GO 71527
71509: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
71510: LD_ADDR_VAR 0 3
71514: PUSH
71515: LD_INT 23
71517: PUSH
71518: LD_INT 24
71520: PUSH
71521: EMPTY
71522: LIST
71523: LIST
71524: ST_TO_ADDR
71525: GO 71528
71527: POP
// result := ( chassis in result ) ;
71528: LD_ADDR_VAR 0 3
71532: PUSH
71533: LD_VAR 0 1
71537: PUSH
71538: LD_VAR 0 3
71542: IN
71543: ST_TO_ADDR
// end ;
71544: LD_VAR 0 3
71548: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
71549: LD_INT 0
71551: PPUSH
71552: PPUSH
71553: PPUSH
71554: PPUSH
71555: PPUSH
71556: PPUSH
71557: PPUSH
// result := array ;
71558: LD_ADDR_VAR 0 5
71562: PUSH
71563: LD_VAR 0 1
71567: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
71568: LD_VAR 0 1
71572: NOT
71573: PUSH
71574: LD_VAR 0 2
71578: NOT
71579: OR
71580: PUSH
71581: LD_VAR 0 3
71585: NOT
71586: OR
71587: PUSH
71588: LD_VAR 0 2
71592: PUSH
71593: LD_VAR 0 1
71597: GREATER
71598: OR
71599: PUSH
71600: LD_VAR 0 3
71604: PUSH
71605: LD_VAR 0 1
71609: GREATER
71610: OR
71611: IFFALSE 71615
// exit ;
71613: GO 71911
// if direction then
71615: LD_VAR 0 4
71619: IFFALSE 71683
// begin d := 1 ;
71621: LD_ADDR_VAR 0 9
71625: PUSH
71626: LD_INT 1
71628: ST_TO_ADDR
// if i_from > i_to then
71629: LD_VAR 0 2
71633: PUSH
71634: LD_VAR 0 3
71638: GREATER
71639: IFFALSE 71665
// length := ( array - i_from ) + i_to else
71641: LD_ADDR_VAR 0 11
71645: PUSH
71646: LD_VAR 0 1
71650: PUSH
71651: LD_VAR 0 2
71655: MINUS
71656: PUSH
71657: LD_VAR 0 3
71661: PLUS
71662: ST_TO_ADDR
71663: GO 71681
// length := i_to - i_from ;
71665: LD_ADDR_VAR 0 11
71669: PUSH
71670: LD_VAR 0 3
71674: PUSH
71675: LD_VAR 0 2
71679: MINUS
71680: ST_TO_ADDR
// end else
71681: GO 71744
// begin d := - 1 ;
71683: LD_ADDR_VAR 0 9
71687: PUSH
71688: LD_INT 1
71690: NEG
71691: ST_TO_ADDR
// if i_from > i_to then
71692: LD_VAR 0 2
71696: PUSH
71697: LD_VAR 0 3
71701: GREATER
71702: IFFALSE 71722
// length := i_from - i_to else
71704: LD_ADDR_VAR 0 11
71708: PUSH
71709: LD_VAR 0 2
71713: PUSH
71714: LD_VAR 0 3
71718: MINUS
71719: ST_TO_ADDR
71720: GO 71744
// length := ( array - i_to ) + i_from ;
71722: LD_ADDR_VAR 0 11
71726: PUSH
71727: LD_VAR 0 1
71731: PUSH
71732: LD_VAR 0 3
71736: MINUS
71737: PUSH
71738: LD_VAR 0 2
71742: PLUS
71743: ST_TO_ADDR
// end ; if not length then
71744: LD_VAR 0 11
71748: NOT
71749: IFFALSE 71753
// exit ;
71751: GO 71911
// tmp := array ;
71753: LD_ADDR_VAR 0 10
71757: PUSH
71758: LD_VAR 0 1
71762: ST_TO_ADDR
// for i = 1 to length do
71763: LD_ADDR_VAR 0 6
71767: PUSH
71768: DOUBLE
71769: LD_INT 1
71771: DEC
71772: ST_TO_ADDR
71773: LD_VAR 0 11
71777: PUSH
71778: FOR_TO
71779: IFFALSE 71899
// begin for j = 1 to array do
71781: LD_ADDR_VAR 0 7
71785: PUSH
71786: DOUBLE
71787: LD_INT 1
71789: DEC
71790: ST_TO_ADDR
71791: LD_VAR 0 1
71795: PUSH
71796: FOR_TO
71797: IFFALSE 71885
// begin k := j + d ;
71799: LD_ADDR_VAR 0 8
71803: PUSH
71804: LD_VAR 0 7
71808: PUSH
71809: LD_VAR 0 9
71813: PLUS
71814: ST_TO_ADDR
// if k > array then
71815: LD_VAR 0 8
71819: PUSH
71820: LD_VAR 0 1
71824: GREATER
71825: IFFALSE 71835
// k := 1 ;
71827: LD_ADDR_VAR 0 8
71831: PUSH
71832: LD_INT 1
71834: ST_TO_ADDR
// if not k then
71835: LD_VAR 0 8
71839: NOT
71840: IFFALSE 71852
// k := array ;
71842: LD_ADDR_VAR 0 8
71846: PUSH
71847: LD_VAR 0 1
71851: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
71852: LD_ADDR_VAR 0 10
71856: PUSH
71857: LD_VAR 0 10
71861: PPUSH
71862: LD_VAR 0 8
71866: PPUSH
71867: LD_VAR 0 1
71871: PUSH
71872: LD_VAR 0 7
71876: ARRAY
71877: PPUSH
71878: CALL_OW 1
71882: ST_TO_ADDR
// end ;
71883: GO 71796
71885: POP
71886: POP
// array := tmp ;
71887: LD_ADDR_VAR 0 1
71891: PUSH
71892: LD_VAR 0 10
71896: ST_TO_ADDR
// end ;
71897: GO 71778
71899: POP
71900: POP
// result := array ;
71901: LD_ADDR_VAR 0 5
71905: PUSH
71906: LD_VAR 0 1
71910: ST_TO_ADDR
// end ;
71911: LD_VAR 0 5
71915: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
71916: LD_INT 0
71918: PPUSH
71919: PPUSH
// result := 0 ;
71920: LD_ADDR_VAR 0 3
71924: PUSH
71925: LD_INT 0
71927: ST_TO_ADDR
// if not array or not value in array then
71928: LD_VAR 0 1
71932: NOT
71933: PUSH
71934: LD_VAR 0 2
71938: PUSH
71939: LD_VAR 0 1
71943: IN
71944: NOT
71945: OR
71946: IFFALSE 71950
// exit ;
71948: GO 72004
// for i = 1 to array do
71950: LD_ADDR_VAR 0 4
71954: PUSH
71955: DOUBLE
71956: LD_INT 1
71958: DEC
71959: ST_TO_ADDR
71960: LD_VAR 0 1
71964: PUSH
71965: FOR_TO
71966: IFFALSE 72002
// if value = array [ i ] then
71968: LD_VAR 0 2
71972: PUSH
71973: LD_VAR 0 1
71977: PUSH
71978: LD_VAR 0 4
71982: ARRAY
71983: EQUAL
71984: IFFALSE 72000
// begin result := i ;
71986: LD_ADDR_VAR 0 3
71990: PUSH
71991: LD_VAR 0 4
71995: ST_TO_ADDR
// exit ;
71996: POP
71997: POP
71998: GO 72004
// end ;
72000: GO 71965
72002: POP
72003: POP
// end ;
72004: LD_VAR 0 3
72008: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
72009: LD_INT 0
72011: PPUSH
// vc_chassis := chassis ;
72012: LD_ADDR_OWVAR 37
72016: PUSH
72017: LD_VAR 0 1
72021: ST_TO_ADDR
// vc_engine := engine ;
72022: LD_ADDR_OWVAR 39
72026: PUSH
72027: LD_VAR 0 2
72031: ST_TO_ADDR
// vc_control := control ;
72032: LD_ADDR_OWVAR 38
72036: PUSH
72037: LD_VAR 0 3
72041: ST_TO_ADDR
// vc_weapon := weapon ;
72042: LD_ADDR_OWVAR 40
72046: PUSH
72047: LD_VAR 0 4
72051: ST_TO_ADDR
// vc_fuel_battery := fuel ;
72052: LD_ADDR_OWVAR 41
72056: PUSH
72057: LD_VAR 0 5
72061: ST_TO_ADDR
// end ;
72062: LD_VAR 0 6
72066: RET
// export function WantPlant ( unit ) ; var task ; begin
72067: LD_INT 0
72069: PPUSH
72070: PPUSH
// result := false ;
72071: LD_ADDR_VAR 0 2
72075: PUSH
72076: LD_INT 0
72078: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
72079: LD_ADDR_VAR 0 3
72083: PUSH
72084: LD_VAR 0 1
72088: PPUSH
72089: CALL_OW 437
72093: ST_TO_ADDR
// if task then
72094: LD_VAR 0 3
72098: IFFALSE 72126
// if task [ 1 ] [ 1 ] = p then
72100: LD_VAR 0 3
72104: PUSH
72105: LD_INT 1
72107: ARRAY
72108: PUSH
72109: LD_INT 1
72111: ARRAY
72112: PUSH
72113: LD_STRING p
72115: EQUAL
72116: IFFALSE 72126
// result := true ;
72118: LD_ADDR_VAR 0 2
72122: PUSH
72123: LD_INT 1
72125: ST_TO_ADDR
// end ;
72126: LD_VAR 0 2
72130: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
72131: LD_INT 0
72133: PPUSH
72134: PPUSH
72135: PPUSH
72136: PPUSH
// if pos < 1 then
72137: LD_VAR 0 2
72141: PUSH
72142: LD_INT 1
72144: LESS
72145: IFFALSE 72149
// exit ;
72147: GO 72452
// if pos = 1 then
72149: LD_VAR 0 2
72153: PUSH
72154: LD_INT 1
72156: EQUAL
72157: IFFALSE 72190
// result := Replace ( arr , pos [ 1 ] , value ) else
72159: LD_ADDR_VAR 0 4
72163: PUSH
72164: LD_VAR 0 1
72168: PPUSH
72169: LD_VAR 0 2
72173: PUSH
72174: LD_INT 1
72176: ARRAY
72177: PPUSH
72178: LD_VAR 0 3
72182: PPUSH
72183: CALL_OW 1
72187: ST_TO_ADDR
72188: GO 72452
// begin tmp := arr ;
72190: LD_ADDR_VAR 0 6
72194: PUSH
72195: LD_VAR 0 1
72199: ST_TO_ADDR
// s_arr := [ tmp ] ;
72200: LD_ADDR_VAR 0 7
72204: PUSH
72205: LD_VAR 0 6
72209: PUSH
72210: EMPTY
72211: LIST
72212: ST_TO_ADDR
// for i = 1 to pos - 1 do
72213: LD_ADDR_VAR 0 5
72217: PUSH
72218: DOUBLE
72219: LD_INT 1
72221: DEC
72222: ST_TO_ADDR
72223: LD_VAR 0 2
72227: PUSH
72228: LD_INT 1
72230: MINUS
72231: PUSH
72232: FOR_TO
72233: IFFALSE 72278
// begin tmp := tmp [ pos [ i ] ] ;
72235: LD_ADDR_VAR 0 6
72239: PUSH
72240: LD_VAR 0 6
72244: PUSH
72245: LD_VAR 0 2
72249: PUSH
72250: LD_VAR 0 5
72254: ARRAY
72255: ARRAY
72256: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
72257: LD_ADDR_VAR 0 7
72261: PUSH
72262: LD_VAR 0 7
72266: PUSH
72267: LD_VAR 0 6
72271: PUSH
72272: EMPTY
72273: LIST
72274: ADD
72275: ST_TO_ADDR
// end ;
72276: GO 72232
72278: POP
72279: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
72280: LD_ADDR_VAR 0 6
72284: PUSH
72285: LD_VAR 0 6
72289: PPUSH
72290: LD_VAR 0 2
72294: PUSH
72295: LD_VAR 0 2
72299: ARRAY
72300: PPUSH
72301: LD_VAR 0 3
72305: PPUSH
72306: CALL_OW 1
72310: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
72311: LD_ADDR_VAR 0 7
72315: PUSH
72316: LD_VAR 0 7
72320: PPUSH
72321: LD_VAR 0 7
72325: PPUSH
72326: LD_VAR 0 6
72330: PPUSH
72331: CALL_OW 1
72335: ST_TO_ADDR
// for i = s_arr downto 2 do
72336: LD_ADDR_VAR 0 5
72340: PUSH
72341: DOUBLE
72342: LD_VAR 0 7
72346: INC
72347: ST_TO_ADDR
72348: LD_INT 2
72350: PUSH
72351: FOR_DOWNTO
72352: IFFALSE 72436
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
72354: LD_ADDR_VAR 0 6
72358: PUSH
72359: LD_VAR 0 7
72363: PUSH
72364: LD_VAR 0 5
72368: PUSH
72369: LD_INT 1
72371: MINUS
72372: ARRAY
72373: PPUSH
72374: LD_VAR 0 2
72378: PUSH
72379: LD_VAR 0 5
72383: PUSH
72384: LD_INT 1
72386: MINUS
72387: ARRAY
72388: PPUSH
72389: LD_VAR 0 7
72393: PUSH
72394: LD_VAR 0 5
72398: ARRAY
72399: PPUSH
72400: CALL_OW 1
72404: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
72405: LD_ADDR_VAR 0 7
72409: PUSH
72410: LD_VAR 0 7
72414: PPUSH
72415: LD_VAR 0 5
72419: PUSH
72420: LD_INT 1
72422: MINUS
72423: PPUSH
72424: LD_VAR 0 6
72428: PPUSH
72429: CALL_OW 1
72433: ST_TO_ADDR
// end ;
72434: GO 72351
72436: POP
72437: POP
// result := s_arr [ 1 ] ;
72438: LD_ADDR_VAR 0 4
72442: PUSH
72443: LD_VAR 0 7
72447: PUSH
72448: LD_INT 1
72450: ARRAY
72451: ST_TO_ADDR
// end ; end ;
72452: LD_VAR 0 4
72456: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
72457: LD_INT 0
72459: PPUSH
72460: PPUSH
// if not list then
72461: LD_VAR 0 1
72465: NOT
72466: IFFALSE 72470
// exit ;
72468: GO 72561
// i := list [ pos1 ] ;
72470: LD_ADDR_VAR 0 5
72474: PUSH
72475: LD_VAR 0 1
72479: PUSH
72480: LD_VAR 0 2
72484: ARRAY
72485: ST_TO_ADDR
// if not i then
72486: LD_VAR 0 5
72490: NOT
72491: IFFALSE 72495
// exit ;
72493: GO 72561
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
72495: LD_ADDR_VAR 0 1
72499: PUSH
72500: LD_VAR 0 1
72504: PPUSH
72505: LD_VAR 0 2
72509: PPUSH
72510: LD_VAR 0 1
72514: PUSH
72515: LD_VAR 0 3
72519: ARRAY
72520: PPUSH
72521: CALL_OW 1
72525: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
72526: LD_ADDR_VAR 0 1
72530: PUSH
72531: LD_VAR 0 1
72535: PPUSH
72536: LD_VAR 0 3
72540: PPUSH
72541: LD_VAR 0 5
72545: PPUSH
72546: CALL_OW 1
72550: ST_TO_ADDR
// result := list ;
72551: LD_ADDR_VAR 0 4
72555: PUSH
72556: LD_VAR 0 1
72560: ST_TO_ADDR
// end ;
72561: LD_VAR 0 4
72565: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
72566: LD_INT 0
72568: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
72569: LD_ADDR_VAR 0 5
72573: PUSH
72574: LD_VAR 0 1
72578: PPUSH
72579: CALL_OW 250
72583: PPUSH
72584: LD_VAR 0 1
72588: PPUSH
72589: CALL_OW 251
72593: PPUSH
72594: LD_VAR 0 2
72598: PPUSH
72599: LD_VAR 0 3
72603: PPUSH
72604: LD_VAR 0 4
72608: PPUSH
72609: CALL 72619 0 5
72613: ST_TO_ADDR
// end ;
72614: LD_VAR 0 5
72618: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
72619: LD_INT 0
72621: PPUSH
72622: PPUSH
72623: PPUSH
72624: PPUSH
// if not list then
72625: LD_VAR 0 3
72629: NOT
72630: IFFALSE 72634
// exit ;
72632: GO 73022
// result := [ ] ;
72634: LD_ADDR_VAR 0 6
72638: PUSH
72639: EMPTY
72640: ST_TO_ADDR
// for i in list do
72641: LD_ADDR_VAR 0 7
72645: PUSH
72646: LD_VAR 0 3
72650: PUSH
72651: FOR_IN
72652: IFFALSE 72854
// begin tmp := GetDistUnitXY ( i , x , y ) ;
72654: LD_ADDR_VAR 0 9
72658: PUSH
72659: LD_VAR 0 7
72663: PPUSH
72664: LD_VAR 0 1
72668: PPUSH
72669: LD_VAR 0 2
72673: PPUSH
72674: CALL_OW 297
72678: ST_TO_ADDR
// if not result then
72679: LD_VAR 0 6
72683: NOT
72684: IFFALSE 72710
// result := [ [ i , tmp ] ] else
72686: LD_ADDR_VAR 0 6
72690: PUSH
72691: LD_VAR 0 7
72695: PUSH
72696: LD_VAR 0 9
72700: PUSH
72701: EMPTY
72702: LIST
72703: LIST
72704: PUSH
72705: EMPTY
72706: LIST
72707: ST_TO_ADDR
72708: GO 72852
// begin if result [ result ] [ 2 ] < tmp then
72710: LD_VAR 0 6
72714: PUSH
72715: LD_VAR 0 6
72719: ARRAY
72720: PUSH
72721: LD_INT 2
72723: ARRAY
72724: PUSH
72725: LD_VAR 0 9
72729: LESS
72730: IFFALSE 72772
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
72732: LD_ADDR_VAR 0 6
72736: PUSH
72737: LD_VAR 0 6
72741: PPUSH
72742: LD_VAR 0 6
72746: PUSH
72747: LD_INT 1
72749: PLUS
72750: PPUSH
72751: LD_VAR 0 7
72755: PUSH
72756: LD_VAR 0 9
72760: PUSH
72761: EMPTY
72762: LIST
72763: LIST
72764: PPUSH
72765: CALL_OW 2
72769: ST_TO_ADDR
72770: GO 72852
// for j = 1 to result do
72772: LD_ADDR_VAR 0 8
72776: PUSH
72777: DOUBLE
72778: LD_INT 1
72780: DEC
72781: ST_TO_ADDR
72782: LD_VAR 0 6
72786: PUSH
72787: FOR_TO
72788: IFFALSE 72850
// begin if tmp < result [ j ] [ 2 ] then
72790: LD_VAR 0 9
72794: PUSH
72795: LD_VAR 0 6
72799: PUSH
72800: LD_VAR 0 8
72804: ARRAY
72805: PUSH
72806: LD_INT 2
72808: ARRAY
72809: LESS
72810: IFFALSE 72848
// begin result := Insert ( result , j , [ i , tmp ] ) ;
72812: LD_ADDR_VAR 0 6
72816: PUSH
72817: LD_VAR 0 6
72821: PPUSH
72822: LD_VAR 0 8
72826: PPUSH
72827: LD_VAR 0 7
72831: PUSH
72832: LD_VAR 0 9
72836: PUSH
72837: EMPTY
72838: LIST
72839: LIST
72840: PPUSH
72841: CALL_OW 2
72845: ST_TO_ADDR
// break ;
72846: GO 72850
// end ; end ;
72848: GO 72787
72850: POP
72851: POP
// end ; end ;
72852: GO 72651
72854: POP
72855: POP
// if result and not asc then
72856: LD_VAR 0 6
72860: PUSH
72861: LD_VAR 0 4
72865: NOT
72866: AND
72867: IFFALSE 72942
// begin tmp := result ;
72869: LD_ADDR_VAR 0 9
72873: PUSH
72874: LD_VAR 0 6
72878: ST_TO_ADDR
// for i = tmp downto 1 do
72879: LD_ADDR_VAR 0 7
72883: PUSH
72884: DOUBLE
72885: LD_VAR 0 9
72889: INC
72890: ST_TO_ADDR
72891: LD_INT 1
72893: PUSH
72894: FOR_DOWNTO
72895: IFFALSE 72940
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
72897: LD_ADDR_VAR 0 6
72901: PUSH
72902: LD_VAR 0 6
72906: PPUSH
72907: LD_VAR 0 9
72911: PUSH
72912: LD_VAR 0 7
72916: MINUS
72917: PUSH
72918: LD_INT 1
72920: PLUS
72921: PPUSH
72922: LD_VAR 0 9
72926: PUSH
72927: LD_VAR 0 7
72931: ARRAY
72932: PPUSH
72933: CALL_OW 1
72937: ST_TO_ADDR
72938: GO 72894
72940: POP
72941: POP
// end ; tmp := [ ] ;
72942: LD_ADDR_VAR 0 9
72946: PUSH
72947: EMPTY
72948: ST_TO_ADDR
// if mode then
72949: LD_VAR 0 5
72953: IFFALSE 73022
// begin for i = 1 to result do
72955: LD_ADDR_VAR 0 7
72959: PUSH
72960: DOUBLE
72961: LD_INT 1
72963: DEC
72964: ST_TO_ADDR
72965: LD_VAR 0 6
72969: PUSH
72970: FOR_TO
72971: IFFALSE 73010
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
72973: LD_ADDR_VAR 0 9
72977: PUSH
72978: LD_VAR 0 9
72982: PPUSH
72983: LD_VAR 0 7
72987: PPUSH
72988: LD_VAR 0 6
72992: PUSH
72993: LD_VAR 0 7
72997: ARRAY
72998: PUSH
72999: LD_INT 1
73001: ARRAY
73002: PPUSH
73003: CALL_OW 1
73007: ST_TO_ADDR
73008: GO 72970
73010: POP
73011: POP
// result := tmp ;
73012: LD_ADDR_VAR 0 6
73016: PUSH
73017: LD_VAR 0 9
73021: ST_TO_ADDR
// end ; end ;
73022: LD_VAR 0 6
73026: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
73027: LD_INT 0
73029: PPUSH
73030: PPUSH
73031: PPUSH
73032: PPUSH
73033: PPUSH
73034: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
73035: LD_ADDR_VAR 0 5
73039: PUSH
73040: LD_INT 0
73042: PUSH
73043: LD_INT 0
73045: PUSH
73046: LD_INT 0
73048: PUSH
73049: EMPTY
73050: PUSH
73051: EMPTY
73052: LIST
73053: LIST
73054: LIST
73055: LIST
73056: ST_TO_ADDR
// if not x or not y then
73057: LD_VAR 0 2
73061: NOT
73062: PUSH
73063: LD_VAR 0 3
73067: NOT
73068: OR
73069: IFFALSE 73073
// exit ;
73071: GO 74719
// if not range then
73073: LD_VAR 0 4
73077: NOT
73078: IFFALSE 73088
// range := 10 ;
73080: LD_ADDR_VAR 0 4
73084: PUSH
73085: LD_INT 10
73087: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
73088: LD_ADDR_VAR 0 8
73092: PUSH
73093: LD_INT 81
73095: PUSH
73096: LD_VAR 0 1
73100: PUSH
73101: EMPTY
73102: LIST
73103: LIST
73104: PUSH
73105: LD_INT 92
73107: PUSH
73108: LD_VAR 0 2
73112: PUSH
73113: LD_VAR 0 3
73117: PUSH
73118: LD_VAR 0 4
73122: PUSH
73123: EMPTY
73124: LIST
73125: LIST
73126: LIST
73127: LIST
73128: PUSH
73129: LD_INT 3
73131: PUSH
73132: LD_INT 21
73134: PUSH
73135: LD_INT 3
73137: PUSH
73138: EMPTY
73139: LIST
73140: LIST
73141: PUSH
73142: EMPTY
73143: LIST
73144: LIST
73145: PUSH
73146: EMPTY
73147: LIST
73148: LIST
73149: LIST
73150: PPUSH
73151: CALL_OW 69
73155: ST_TO_ADDR
// if not tmp then
73156: LD_VAR 0 8
73160: NOT
73161: IFFALSE 73165
// exit ;
73163: GO 74719
// for i in tmp do
73165: LD_ADDR_VAR 0 6
73169: PUSH
73170: LD_VAR 0 8
73174: PUSH
73175: FOR_IN
73176: IFFALSE 74694
// begin points := [ 0 , 0 , 0 ] ;
73178: LD_ADDR_VAR 0 9
73182: PUSH
73183: LD_INT 0
73185: PUSH
73186: LD_INT 0
73188: PUSH
73189: LD_INT 0
73191: PUSH
73192: EMPTY
73193: LIST
73194: LIST
73195: LIST
73196: ST_TO_ADDR
// bpoints := 1 ;
73197: LD_ADDR_VAR 0 10
73201: PUSH
73202: LD_INT 1
73204: ST_TO_ADDR
// case GetType ( i ) of unit_human :
73205: LD_VAR 0 6
73209: PPUSH
73210: CALL_OW 247
73214: PUSH
73215: LD_INT 1
73217: DOUBLE
73218: EQUAL
73219: IFTRUE 73223
73221: GO 73801
73223: POP
// begin if GetClass ( i ) = 1 then
73224: LD_VAR 0 6
73228: PPUSH
73229: CALL_OW 257
73233: PUSH
73234: LD_INT 1
73236: EQUAL
73237: IFFALSE 73258
// points := [ 10 , 5 , 3 ] ;
73239: LD_ADDR_VAR 0 9
73243: PUSH
73244: LD_INT 10
73246: PUSH
73247: LD_INT 5
73249: PUSH
73250: LD_INT 3
73252: PUSH
73253: EMPTY
73254: LIST
73255: LIST
73256: LIST
73257: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
73258: LD_VAR 0 6
73262: PPUSH
73263: CALL_OW 257
73267: PUSH
73268: LD_INT 2
73270: PUSH
73271: LD_INT 3
73273: PUSH
73274: LD_INT 4
73276: PUSH
73277: EMPTY
73278: LIST
73279: LIST
73280: LIST
73281: IN
73282: IFFALSE 73303
// points := [ 3 , 2 , 1 ] ;
73284: LD_ADDR_VAR 0 9
73288: PUSH
73289: LD_INT 3
73291: PUSH
73292: LD_INT 2
73294: PUSH
73295: LD_INT 1
73297: PUSH
73298: EMPTY
73299: LIST
73300: LIST
73301: LIST
73302: ST_TO_ADDR
// if GetClass ( i ) = 5 then
73303: LD_VAR 0 6
73307: PPUSH
73308: CALL_OW 257
73312: PUSH
73313: LD_INT 5
73315: EQUAL
73316: IFFALSE 73337
// points := [ 130 , 5 , 2 ] ;
73318: LD_ADDR_VAR 0 9
73322: PUSH
73323: LD_INT 130
73325: PUSH
73326: LD_INT 5
73328: PUSH
73329: LD_INT 2
73331: PUSH
73332: EMPTY
73333: LIST
73334: LIST
73335: LIST
73336: ST_TO_ADDR
// if GetClass ( i ) = 8 then
73337: LD_VAR 0 6
73341: PPUSH
73342: CALL_OW 257
73346: PUSH
73347: LD_INT 8
73349: EQUAL
73350: IFFALSE 73371
// points := [ 35 , 35 , 30 ] ;
73352: LD_ADDR_VAR 0 9
73356: PUSH
73357: LD_INT 35
73359: PUSH
73360: LD_INT 35
73362: PUSH
73363: LD_INT 30
73365: PUSH
73366: EMPTY
73367: LIST
73368: LIST
73369: LIST
73370: ST_TO_ADDR
// if GetClass ( i ) = 9 then
73371: LD_VAR 0 6
73375: PPUSH
73376: CALL_OW 257
73380: PUSH
73381: LD_INT 9
73383: EQUAL
73384: IFFALSE 73405
// points := [ 20 , 55 , 40 ] ;
73386: LD_ADDR_VAR 0 9
73390: PUSH
73391: LD_INT 20
73393: PUSH
73394: LD_INT 55
73396: PUSH
73397: LD_INT 40
73399: PUSH
73400: EMPTY
73401: LIST
73402: LIST
73403: LIST
73404: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
73405: LD_VAR 0 6
73409: PPUSH
73410: CALL_OW 257
73414: PUSH
73415: LD_INT 12
73417: PUSH
73418: LD_INT 16
73420: PUSH
73421: EMPTY
73422: LIST
73423: LIST
73424: IN
73425: IFFALSE 73446
// points := [ 5 , 3 , 2 ] ;
73427: LD_ADDR_VAR 0 9
73431: PUSH
73432: LD_INT 5
73434: PUSH
73435: LD_INT 3
73437: PUSH
73438: LD_INT 2
73440: PUSH
73441: EMPTY
73442: LIST
73443: LIST
73444: LIST
73445: ST_TO_ADDR
// if GetClass ( i ) = 17 then
73446: LD_VAR 0 6
73450: PPUSH
73451: CALL_OW 257
73455: PUSH
73456: LD_INT 17
73458: EQUAL
73459: IFFALSE 73480
// points := [ 100 , 50 , 75 ] ;
73461: LD_ADDR_VAR 0 9
73465: PUSH
73466: LD_INT 100
73468: PUSH
73469: LD_INT 50
73471: PUSH
73472: LD_INT 75
73474: PUSH
73475: EMPTY
73476: LIST
73477: LIST
73478: LIST
73479: ST_TO_ADDR
// if GetClass ( i ) = 15 then
73480: LD_VAR 0 6
73484: PPUSH
73485: CALL_OW 257
73489: PUSH
73490: LD_INT 15
73492: EQUAL
73493: IFFALSE 73514
// points := [ 10 , 5 , 3 ] ;
73495: LD_ADDR_VAR 0 9
73499: PUSH
73500: LD_INT 10
73502: PUSH
73503: LD_INT 5
73505: PUSH
73506: LD_INT 3
73508: PUSH
73509: EMPTY
73510: LIST
73511: LIST
73512: LIST
73513: ST_TO_ADDR
// if GetClass ( i ) = 14 then
73514: LD_VAR 0 6
73518: PPUSH
73519: CALL_OW 257
73523: PUSH
73524: LD_INT 14
73526: EQUAL
73527: IFFALSE 73548
// points := [ 10 , 0 , 0 ] ;
73529: LD_ADDR_VAR 0 9
73533: PUSH
73534: LD_INT 10
73536: PUSH
73537: LD_INT 0
73539: PUSH
73540: LD_INT 0
73542: PUSH
73543: EMPTY
73544: LIST
73545: LIST
73546: LIST
73547: ST_TO_ADDR
// if GetClass ( i ) = 11 then
73548: LD_VAR 0 6
73552: PPUSH
73553: CALL_OW 257
73557: PUSH
73558: LD_INT 11
73560: EQUAL
73561: IFFALSE 73582
// points := [ 30 , 10 , 5 ] ;
73563: LD_ADDR_VAR 0 9
73567: PUSH
73568: LD_INT 30
73570: PUSH
73571: LD_INT 10
73573: PUSH
73574: LD_INT 5
73576: PUSH
73577: EMPTY
73578: LIST
73579: LIST
73580: LIST
73581: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
73582: LD_VAR 0 1
73586: PPUSH
73587: LD_INT 5
73589: PPUSH
73590: CALL_OW 321
73594: PUSH
73595: LD_INT 2
73597: EQUAL
73598: IFFALSE 73615
// bpoints := bpoints * 1.8 ;
73600: LD_ADDR_VAR 0 10
73604: PUSH
73605: LD_VAR 0 10
73609: PUSH
73610: LD_REAL  1.80000000000000E+0000
73613: MUL
73614: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
73615: LD_VAR 0 6
73619: PPUSH
73620: CALL_OW 257
73624: PUSH
73625: LD_INT 1
73627: PUSH
73628: LD_INT 2
73630: PUSH
73631: LD_INT 3
73633: PUSH
73634: LD_INT 4
73636: PUSH
73637: EMPTY
73638: LIST
73639: LIST
73640: LIST
73641: LIST
73642: IN
73643: PUSH
73644: LD_VAR 0 1
73648: PPUSH
73649: LD_INT 51
73651: PPUSH
73652: CALL_OW 321
73656: PUSH
73657: LD_INT 2
73659: EQUAL
73660: AND
73661: IFFALSE 73678
// bpoints := bpoints * 1.2 ;
73663: LD_ADDR_VAR 0 10
73667: PUSH
73668: LD_VAR 0 10
73672: PUSH
73673: LD_REAL  1.20000000000000E+0000
73676: MUL
73677: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
73678: LD_VAR 0 6
73682: PPUSH
73683: CALL_OW 257
73687: PUSH
73688: LD_INT 5
73690: PUSH
73691: LD_INT 7
73693: PUSH
73694: LD_INT 9
73696: PUSH
73697: EMPTY
73698: LIST
73699: LIST
73700: LIST
73701: IN
73702: PUSH
73703: LD_VAR 0 1
73707: PPUSH
73708: LD_INT 52
73710: PPUSH
73711: CALL_OW 321
73715: PUSH
73716: LD_INT 2
73718: EQUAL
73719: AND
73720: IFFALSE 73737
// bpoints := bpoints * 1.5 ;
73722: LD_ADDR_VAR 0 10
73726: PUSH
73727: LD_VAR 0 10
73731: PUSH
73732: LD_REAL  1.50000000000000E+0000
73735: MUL
73736: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
73737: LD_VAR 0 1
73741: PPUSH
73742: LD_INT 66
73744: PPUSH
73745: CALL_OW 321
73749: PUSH
73750: LD_INT 2
73752: EQUAL
73753: IFFALSE 73770
// bpoints := bpoints * 1.1 ;
73755: LD_ADDR_VAR 0 10
73759: PUSH
73760: LD_VAR 0 10
73764: PUSH
73765: LD_REAL  1.10000000000000E+0000
73768: MUL
73769: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
73770: LD_ADDR_VAR 0 10
73774: PUSH
73775: LD_VAR 0 10
73779: PUSH
73780: LD_VAR 0 6
73784: PPUSH
73785: LD_INT 1
73787: PPUSH
73788: CALL_OW 259
73792: PUSH
73793: LD_REAL  1.15000000000000E+0000
73796: MUL
73797: MUL
73798: ST_TO_ADDR
// end ; unit_vehicle :
73799: GO 74623
73801: LD_INT 2
73803: DOUBLE
73804: EQUAL
73805: IFTRUE 73809
73807: GO 74611
73809: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
73810: LD_VAR 0 6
73814: PPUSH
73815: CALL_OW 264
73819: PUSH
73820: LD_INT 2
73822: PUSH
73823: LD_INT 42
73825: PUSH
73826: LD_INT 24
73828: PUSH
73829: EMPTY
73830: LIST
73831: LIST
73832: LIST
73833: IN
73834: IFFALSE 73855
// points := [ 25 , 5 , 3 ] ;
73836: LD_ADDR_VAR 0 9
73840: PUSH
73841: LD_INT 25
73843: PUSH
73844: LD_INT 5
73846: PUSH
73847: LD_INT 3
73849: PUSH
73850: EMPTY
73851: LIST
73852: LIST
73853: LIST
73854: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
73855: LD_VAR 0 6
73859: PPUSH
73860: CALL_OW 264
73864: PUSH
73865: LD_INT 4
73867: PUSH
73868: LD_INT 43
73870: PUSH
73871: LD_INT 25
73873: PUSH
73874: EMPTY
73875: LIST
73876: LIST
73877: LIST
73878: IN
73879: IFFALSE 73900
// points := [ 40 , 15 , 5 ] ;
73881: LD_ADDR_VAR 0 9
73885: PUSH
73886: LD_INT 40
73888: PUSH
73889: LD_INT 15
73891: PUSH
73892: LD_INT 5
73894: PUSH
73895: EMPTY
73896: LIST
73897: LIST
73898: LIST
73899: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
73900: LD_VAR 0 6
73904: PPUSH
73905: CALL_OW 264
73909: PUSH
73910: LD_INT 3
73912: PUSH
73913: LD_INT 23
73915: PUSH
73916: EMPTY
73917: LIST
73918: LIST
73919: IN
73920: IFFALSE 73941
// points := [ 7 , 25 , 8 ] ;
73922: LD_ADDR_VAR 0 9
73926: PUSH
73927: LD_INT 7
73929: PUSH
73930: LD_INT 25
73932: PUSH
73933: LD_INT 8
73935: PUSH
73936: EMPTY
73937: LIST
73938: LIST
73939: LIST
73940: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
73941: LD_VAR 0 6
73945: PPUSH
73946: CALL_OW 264
73950: PUSH
73951: LD_INT 5
73953: PUSH
73954: LD_INT 27
73956: PUSH
73957: LD_INT 44
73959: PUSH
73960: EMPTY
73961: LIST
73962: LIST
73963: LIST
73964: IN
73965: IFFALSE 73986
// points := [ 14 , 50 , 16 ] ;
73967: LD_ADDR_VAR 0 9
73971: PUSH
73972: LD_INT 14
73974: PUSH
73975: LD_INT 50
73977: PUSH
73978: LD_INT 16
73980: PUSH
73981: EMPTY
73982: LIST
73983: LIST
73984: LIST
73985: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
73986: LD_VAR 0 6
73990: PPUSH
73991: CALL_OW 264
73995: PUSH
73996: LD_INT 6
73998: PUSH
73999: LD_INT 46
74001: PUSH
74002: EMPTY
74003: LIST
74004: LIST
74005: IN
74006: IFFALSE 74027
// points := [ 32 , 120 , 70 ] ;
74008: LD_ADDR_VAR 0 9
74012: PUSH
74013: LD_INT 32
74015: PUSH
74016: LD_INT 120
74018: PUSH
74019: LD_INT 70
74021: PUSH
74022: EMPTY
74023: LIST
74024: LIST
74025: LIST
74026: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
74027: LD_VAR 0 6
74031: PPUSH
74032: CALL_OW 264
74036: PUSH
74037: LD_INT 7
74039: PUSH
74040: LD_INT 28
74042: PUSH
74043: LD_INT 45
74045: PUSH
74046: EMPTY
74047: LIST
74048: LIST
74049: LIST
74050: IN
74051: IFFALSE 74072
// points := [ 35 , 20 , 45 ] ;
74053: LD_ADDR_VAR 0 9
74057: PUSH
74058: LD_INT 35
74060: PUSH
74061: LD_INT 20
74063: PUSH
74064: LD_INT 45
74066: PUSH
74067: EMPTY
74068: LIST
74069: LIST
74070: LIST
74071: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
74072: LD_VAR 0 6
74076: PPUSH
74077: CALL_OW 264
74081: PUSH
74082: LD_INT 47
74084: PUSH
74085: EMPTY
74086: LIST
74087: IN
74088: IFFALSE 74109
// points := [ 67 , 45 , 75 ] ;
74090: LD_ADDR_VAR 0 9
74094: PUSH
74095: LD_INT 67
74097: PUSH
74098: LD_INT 45
74100: PUSH
74101: LD_INT 75
74103: PUSH
74104: EMPTY
74105: LIST
74106: LIST
74107: LIST
74108: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
74109: LD_VAR 0 6
74113: PPUSH
74114: CALL_OW 264
74118: PUSH
74119: LD_INT 26
74121: PUSH
74122: EMPTY
74123: LIST
74124: IN
74125: IFFALSE 74146
// points := [ 120 , 30 , 80 ] ;
74127: LD_ADDR_VAR 0 9
74131: PUSH
74132: LD_INT 120
74134: PUSH
74135: LD_INT 30
74137: PUSH
74138: LD_INT 80
74140: PUSH
74141: EMPTY
74142: LIST
74143: LIST
74144: LIST
74145: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
74146: LD_VAR 0 6
74150: PPUSH
74151: CALL_OW 264
74155: PUSH
74156: LD_INT 22
74158: PUSH
74159: EMPTY
74160: LIST
74161: IN
74162: IFFALSE 74183
// points := [ 40 , 1 , 1 ] ;
74164: LD_ADDR_VAR 0 9
74168: PUSH
74169: LD_INT 40
74171: PUSH
74172: LD_INT 1
74174: PUSH
74175: LD_INT 1
74177: PUSH
74178: EMPTY
74179: LIST
74180: LIST
74181: LIST
74182: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
74183: LD_VAR 0 6
74187: PPUSH
74188: CALL_OW 264
74192: PUSH
74193: LD_INT 29
74195: PUSH
74196: EMPTY
74197: LIST
74198: IN
74199: IFFALSE 74220
// points := [ 70 , 200 , 400 ] ;
74201: LD_ADDR_VAR 0 9
74205: PUSH
74206: LD_INT 70
74208: PUSH
74209: LD_INT 200
74211: PUSH
74212: LD_INT 400
74214: PUSH
74215: EMPTY
74216: LIST
74217: LIST
74218: LIST
74219: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
74220: LD_VAR 0 6
74224: PPUSH
74225: CALL_OW 264
74229: PUSH
74230: LD_INT 14
74232: PUSH
74233: LD_INT 53
74235: PUSH
74236: EMPTY
74237: LIST
74238: LIST
74239: IN
74240: IFFALSE 74261
// points := [ 40 , 10 , 20 ] ;
74242: LD_ADDR_VAR 0 9
74246: PUSH
74247: LD_INT 40
74249: PUSH
74250: LD_INT 10
74252: PUSH
74253: LD_INT 20
74255: PUSH
74256: EMPTY
74257: LIST
74258: LIST
74259: LIST
74260: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
74261: LD_VAR 0 6
74265: PPUSH
74266: CALL_OW 264
74270: PUSH
74271: LD_INT 9
74273: PUSH
74274: EMPTY
74275: LIST
74276: IN
74277: IFFALSE 74298
// points := [ 5 , 70 , 20 ] ;
74279: LD_ADDR_VAR 0 9
74283: PUSH
74284: LD_INT 5
74286: PUSH
74287: LD_INT 70
74289: PUSH
74290: LD_INT 20
74292: PUSH
74293: EMPTY
74294: LIST
74295: LIST
74296: LIST
74297: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
74298: LD_VAR 0 6
74302: PPUSH
74303: CALL_OW 264
74307: PUSH
74308: LD_INT 10
74310: PUSH
74311: EMPTY
74312: LIST
74313: IN
74314: IFFALSE 74335
// points := [ 35 , 110 , 70 ] ;
74316: LD_ADDR_VAR 0 9
74320: PUSH
74321: LD_INT 35
74323: PUSH
74324: LD_INT 110
74326: PUSH
74327: LD_INT 70
74329: PUSH
74330: EMPTY
74331: LIST
74332: LIST
74333: LIST
74334: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
74335: LD_VAR 0 6
74339: PPUSH
74340: CALL_OW 265
74344: PUSH
74345: LD_INT 25
74347: EQUAL
74348: IFFALSE 74369
// points := [ 80 , 65 , 100 ] ;
74350: LD_ADDR_VAR 0 9
74354: PUSH
74355: LD_INT 80
74357: PUSH
74358: LD_INT 65
74360: PUSH
74361: LD_INT 100
74363: PUSH
74364: EMPTY
74365: LIST
74366: LIST
74367: LIST
74368: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
74369: LD_VAR 0 6
74373: PPUSH
74374: CALL_OW 263
74378: PUSH
74379: LD_INT 1
74381: EQUAL
74382: IFFALSE 74417
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
74384: LD_ADDR_VAR 0 10
74388: PUSH
74389: LD_VAR 0 10
74393: PUSH
74394: LD_VAR 0 6
74398: PPUSH
74399: CALL_OW 311
74403: PPUSH
74404: LD_INT 3
74406: PPUSH
74407: CALL_OW 259
74411: PUSH
74412: LD_INT 4
74414: MUL
74415: MUL
74416: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
74417: LD_VAR 0 6
74421: PPUSH
74422: CALL_OW 263
74426: PUSH
74427: LD_INT 2
74429: EQUAL
74430: IFFALSE 74481
// begin j := IsControledBy ( i ) ;
74432: LD_ADDR_VAR 0 7
74436: PUSH
74437: LD_VAR 0 6
74441: PPUSH
74442: CALL_OW 312
74446: ST_TO_ADDR
// if j then
74447: LD_VAR 0 7
74451: IFFALSE 74481
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
74453: LD_ADDR_VAR 0 10
74457: PUSH
74458: LD_VAR 0 10
74462: PUSH
74463: LD_VAR 0 7
74467: PPUSH
74468: LD_INT 3
74470: PPUSH
74471: CALL_OW 259
74475: PUSH
74476: LD_INT 3
74478: MUL
74479: MUL
74480: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
74481: LD_VAR 0 6
74485: PPUSH
74486: CALL_OW 264
74490: PUSH
74491: LD_INT 5
74493: PUSH
74494: LD_INT 6
74496: PUSH
74497: LD_INT 46
74499: PUSH
74500: LD_INT 44
74502: PUSH
74503: LD_INT 47
74505: PUSH
74506: LD_INT 45
74508: PUSH
74509: LD_INT 28
74511: PUSH
74512: LD_INT 7
74514: PUSH
74515: LD_INT 27
74517: PUSH
74518: LD_INT 29
74520: PUSH
74521: EMPTY
74522: LIST
74523: LIST
74524: LIST
74525: LIST
74526: LIST
74527: LIST
74528: LIST
74529: LIST
74530: LIST
74531: LIST
74532: IN
74533: PUSH
74534: LD_VAR 0 1
74538: PPUSH
74539: LD_INT 52
74541: PPUSH
74542: CALL_OW 321
74546: PUSH
74547: LD_INT 2
74549: EQUAL
74550: AND
74551: IFFALSE 74568
// bpoints := bpoints * 1.2 ;
74553: LD_ADDR_VAR 0 10
74557: PUSH
74558: LD_VAR 0 10
74562: PUSH
74563: LD_REAL  1.20000000000000E+0000
74566: MUL
74567: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
74568: LD_VAR 0 6
74572: PPUSH
74573: CALL_OW 264
74577: PUSH
74578: LD_INT 6
74580: PUSH
74581: LD_INT 46
74583: PUSH
74584: LD_INT 47
74586: PUSH
74587: EMPTY
74588: LIST
74589: LIST
74590: LIST
74591: IN
74592: IFFALSE 74609
// bpoints := bpoints * 1.2 ;
74594: LD_ADDR_VAR 0 10
74598: PUSH
74599: LD_VAR 0 10
74603: PUSH
74604: LD_REAL  1.20000000000000E+0000
74607: MUL
74608: ST_TO_ADDR
// end ; unit_building :
74609: GO 74623
74611: LD_INT 3
74613: DOUBLE
74614: EQUAL
74615: IFTRUE 74619
74617: GO 74622
74619: POP
// ; end ;
74620: GO 74623
74622: POP
// for j = 1 to 3 do
74623: LD_ADDR_VAR 0 7
74627: PUSH
74628: DOUBLE
74629: LD_INT 1
74631: DEC
74632: ST_TO_ADDR
74633: LD_INT 3
74635: PUSH
74636: FOR_TO
74637: IFFALSE 74690
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
74639: LD_ADDR_VAR 0 5
74643: PUSH
74644: LD_VAR 0 5
74648: PPUSH
74649: LD_VAR 0 7
74653: PPUSH
74654: LD_VAR 0 5
74658: PUSH
74659: LD_VAR 0 7
74663: ARRAY
74664: PUSH
74665: LD_VAR 0 9
74669: PUSH
74670: LD_VAR 0 7
74674: ARRAY
74675: PUSH
74676: LD_VAR 0 10
74680: MUL
74681: PLUS
74682: PPUSH
74683: CALL_OW 1
74687: ST_TO_ADDR
74688: GO 74636
74690: POP
74691: POP
// end ;
74692: GO 73175
74694: POP
74695: POP
// result := Replace ( result , 4 , tmp ) ;
74696: LD_ADDR_VAR 0 5
74700: PUSH
74701: LD_VAR 0 5
74705: PPUSH
74706: LD_INT 4
74708: PPUSH
74709: LD_VAR 0 8
74713: PPUSH
74714: CALL_OW 1
74718: ST_TO_ADDR
// end ;
74719: LD_VAR 0 5
74723: RET
// export function DangerAtRange ( unit , range ) ; begin
74724: LD_INT 0
74726: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
74727: LD_ADDR_VAR 0 3
74731: PUSH
74732: LD_VAR 0 1
74736: PPUSH
74737: CALL_OW 255
74741: PPUSH
74742: LD_VAR 0 1
74746: PPUSH
74747: CALL_OW 250
74751: PPUSH
74752: LD_VAR 0 1
74756: PPUSH
74757: CALL_OW 251
74761: PPUSH
74762: LD_VAR 0 2
74766: PPUSH
74767: CALL 73027 0 4
74771: ST_TO_ADDR
// end ;
74772: LD_VAR 0 3
74776: RET
// export function DangerInArea ( side , area ) ; begin
74777: LD_INT 0
74779: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
74780: LD_ADDR_VAR 0 3
74784: PUSH
74785: LD_VAR 0 2
74789: PPUSH
74790: LD_INT 81
74792: PUSH
74793: LD_VAR 0 1
74797: PUSH
74798: EMPTY
74799: LIST
74800: LIST
74801: PPUSH
74802: CALL_OW 70
74806: ST_TO_ADDR
// end ;
74807: LD_VAR 0 3
74811: RET
// export function IsExtension ( b ) ; begin
74812: LD_INT 0
74814: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
74815: LD_ADDR_VAR 0 2
74819: PUSH
74820: LD_VAR 0 1
74824: PUSH
74825: LD_INT 23
74827: PUSH
74828: LD_INT 20
74830: PUSH
74831: LD_INT 22
74833: PUSH
74834: LD_INT 17
74836: PUSH
74837: LD_INT 24
74839: PUSH
74840: LD_INT 21
74842: PUSH
74843: LD_INT 19
74845: PUSH
74846: LD_INT 16
74848: PUSH
74849: LD_INT 25
74851: PUSH
74852: LD_INT 18
74854: PUSH
74855: EMPTY
74856: LIST
74857: LIST
74858: LIST
74859: LIST
74860: LIST
74861: LIST
74862: LIST
74863: LIST
74864: LIST
74865: LIST
74866: IN
74867: ST_TO_ADDR
// end ;
74868: LD_VAR 0 2
74872: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
74873: LD_INT 0
74875: PPUSH
74876: PPUSH
74877: PPUSH
// result := [ ] ;
74878: LD_ADDR_VAR 0 3
74882: PUSH
74883: EMPTY
74884: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
74885: LD_ADDR_VAR 0 4
74889: PUSH
74890: LD_VAR 0 2
74894: PPUSH
74895: LD_INT 21
74897: PUSH
74898: LD_INT 3
74900: PUSH
74901: EMPTY
74902: LIST
74903: LIST
74904: PPUSH
74905: CALL_OW 70
74909: ST_TO_ADDR
// if not tmp then
74910: LD_VAR 0 4
74914: NOT
74915: IFFALSE 74919
// exit ;
74917: GO 74977
// for i in tmp do
74919: LD_ADDR_VAR 0 5
74923: PUSH
74924: LD_VAR 0 4
74928: PUSH
74929: FOR_IN
74930: IFFALSE 74965
// if GetBase ( i ) <> base then
74932: LD_VAR 0 5
74936: PPUSH
74937: CALL_OW 274
74941: PUSH
74942: LD_VAR 0 1
74946: NONEQUAL
74947: IFFALSE 74963
// ComLinkToBase ( base , i ) ;
74949: LD_VAR 0 1
74953: PPUSH
74954: LD_VAR 0 5
74958: PPUSH
74959: CALL_OW 169
74963: GO 74929
74965: POP
74966: POP
// result := tmp ;
74967: LD_ADDR_VAR 0 3
74971: PUSH
74972: LD_VAR 0 4
74976: ST_TO_ADDR
// end ;
74977: LD_VAR 0 3
74981: RET
// export function ComComplete ( unit , b ) ; var i ; begin
74982: LD_INT 0
74984: PPUSH
74985: PPUSH
// if BuildingStatus ( b ) = bs_build then
74986: LD_VAR 0 2
74990: PPUSH
74991: CALL_OW 461
74995: PUSH
74996: LD_INT 1
74998: EQUAL
74999: IFFALSE 75059
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
75001: LD_VAR 0 1
75005: PPUSH
75006: LD_STRING h
75008: PUSH
75009: LD_VAR 0 2
75013: PPUSH
75014: CALL_OW 250
75018: PUSH
75019: LD_VAR 0 2
75023: PPUSH
75024: CALL_OW 251
75028: PUSH
75029: LD_VAR 0 2
75033: PUSH
75034: LD_INT 0
75036: PUSH
75037: LD_INT 0
75039: PUSH
75040: LD_INT 0
75042: PUSH
75043: EMPTY
75044: LIST
75045: LIST
75046: LIST
75047: LIST
75048: LIST
75049: LIST
75050: LIST
75051: PUSH
75052: EMPTY
75053: LIST
75054: PPUSH
75055: CALL_OW 446
// end ;
75059: LD_VAR 0 3
75063: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
75064: LD_INT 0
75066: PPUSH
75067: PPUSH
75068: PPUSH
75069: PPUSH
75070: PPUSH
75071: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
75072: LD_VAR 0 1
75076: NOT
75077: PUSH
75078: LD_VAR 0 1
75082: PPUSH
75083: CALL_OW 263
75087: PUSH
75088: LD_INT 2
75090: EQUAL
75091: NOT
75092: OR
75093: IFFALSE 75097
// exit ;
75095: GO 75413
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
75097: LD_ADDR_VAR 0 6
75101: PUSH
75102: LD_INT 22
75104: PUSH
75105: LD_VAR 0 1
75109: PPUSH
75110: CALL_OW 255
75114: PUSH
75115: EMPTY
75116: LIST
75117: LIST
75118: PUSH
75119: LD_INT 2
75121: PUSH
75122: LD_INT 30
75124: PUSH
75125: LD_INT 36
75127: PUSH
75128: EMPTY
75129: LIST
75130: LIST
75131: PUSH
75132: LD_INT 34
75134: PUSH
75135: LD_INT 31
75137: PUSH
75138: EMPTY
75139: LIST
75140: LIST
75141: PUSH
75142: EMPTY
75143: LIST
75144: LIST
75145: LIST
75146: PUSH
75147: EMPTY
75148: LIST
75149: LIST
75150: PPUSH
75151: CALL_OW 69
75155: ST_TO_ADDR
// if not tmp then
75156: LD_VAR 0 6
75160: NOT
75161: IFFALSE 75165
// exit ;
75163: GO 75413
// result := [ ] ;
75165: LD_ADDR_VAR 0 2
75169: PUSH
75170: EMPTY
75171: ST_TO_ADDR
// for i in tmp do
75172: LD_ADDR_VAR 0 3
75176: PUSH
75177: LD_VAR 0 6
75181: PUSH
75182: FOR_IN
75183: IFFALSE 75254
// begin t := UnitsInside ( i ) ;
75185: LD_ADDR_VAR 0 4
75189: PUSH
75190: LD_VAR 0 3
75194: PPUSH
75195: CALL_OW 313
75199: ST_TO_ADDR
// if t then
75200: LD_VAR 0 4
75204: IFFALSE 75252
// for j in t do
75206: LD_ADDR_VAR 0 7
75210: PUSH
75211: LD_VAR 0 4
75215: PUSH
75216: FOR_IN
75217: IFFALSE 75250
// result := Insert ( result , result + 1 , j ) ;
75219: LD_ADDR_VAR 0 2
75223: PUSH
75224: LD_VAR 0 2
75228: PPUSH
75229: LD_VAR 0 2
75233: PUSH
75234: LD_INT 1
75236: PLUS
75237: PPUSH
75238: LD_VAR 0 7
75242: PPUSH
75243: CALL_OW 2
75247: ST_TO_ADDR
75248: GO 75216
75250: POP
75251: POP
// end ;
75252: GO 75182
75254: POP
75255: POP
// if not result then
75256: LD_VAR 0 2
75260: NOT
75261: IFFALSE 75265
// exit ;
75263: GO 75413
// mech := result [ 1 ] ;
75265: LD_ADDR_VAR 0 5
75269: PUSH
75270: LD_VAR 0 2
75274: PUSH
75275: LD_INT 1
75277: ARRAY
75278: ST_TO_ADDR
// if result > 1 then
75279: LD_VAR 0 2
75283: PUSH
75284: LD_INT 1
75286: GREATER
75287: IFFALSE 75399
// for i = 2 to result do
75289: LD_ADDR_VAR 0 3
75293: PUSH
75294: DOUBLE
75295: LD_INT 2
75297: DEC
75298: ST_TO_ADDR
75299: LD_VAR 0 2
75303: PUSH
75304: FOR_TO
75305: IFFALSE 75397
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
75307: LD_ADDR_VAR 0 4
75311: PUSH
75312: LD_VAR 0 2
75316: PUSH
75317: LD_VAR 0 3
75321: ARRAY
75322: PPUSH
75323: LD_INT 3
75325: PPUSH
75326: CALL_OW 259
75330: PUSH
75331: LD_VAR 0 2
75335: PUSH
75336: LD_VAR 0 3
75340: ARRAY
75341: PPUSH
75342: CALL_OW 432
75346: MINUS
75347: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
75348: LD_VAR 0 4
75352: PUSH
75353: LD_VAR 0 5
75357: PPUSH
75358: LD_INT 3
75360: PPUSH
75361: CALL_OW 259
75365: PUSH
75366: LD_VAR 0 5
75370: PPUSH
75371: CALL_OW 432
75375: MINUS
75376: GREATEREQUAL
75377: IFFALSE 75395
// mech := result [ i ] ;
75379: LD_ADDR_VAR 0 5
75383: PUSH
75384: LD_VAR 0 2
75388: PUSH
75389: LD_VAR 0 3
75393: ARRAY
75394: ST_TO_ADDR
// end ;
75395: GO 75304
75397: POP
75398: POP
// ComLinkTo ( vehicle , mech ) ;
75399: LD_VAR 0 1
75403: PPUSH
75404: LD_VAR 0 5
75408: PPUSH
75409: CALL_OW 135
// end ;
75413: LD_VAR 0 2
75417: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
75418: LD_INT 0
75420: PPUSH
75421: PPUSH
75422: PPUSH
75423: PPUSH
75424: PPUSH
75425: PPUSH
75426: PPUSH
75427: PPUSH
75428: PPUSH
75429: PPUSH
75430: PPUSH
75431: PPUSH
75432: PPUSH
// result := [ ] ;
75433: LD_ADDR_VAR 0 7
75437: PUSH
75438: EMPTY
75439: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
75440: LD_VAR 0 1
75444: PPUSH
75445: CALL_OW 266
75449: PUSH
75450: LD_INT 0
75452: PUSH
75453: LD_INT 1
75455: PUSH
75456: EMPTY
75457: LIST
75458: LIST
75459: IN
75460: NOT
75461: IFFALSE 75465
// exit ;
75463: GO 77096
// if name then
75465: LD_VAR 0 3
75469: IFFALSE 75485
// SetBName ( base_dep , name ) ;
75471: LD_VAR 0 1
75475: PPUSH
75476: LD_VAR 0 3
75480: PPUSH
75481: CALL_OW 500
// base := GetBase ( base_dep ) ;
75485: LD_ADDR_VAR 0 15
75489: PUSH
75490: LD_VAR 0 1
75494: PPUSH
75495: CALL_OW 274
75499: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
75500: LD_ADDR_VAR 0 16
75504: PUSH
75505: LD_VAR 0 1
75509: PPUSH
75510: CALL_OW 255
75514: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
75515: LD_ADDR_VAR 0 17
75519: PUSH
75520: LD_VAR 0 1
75524: PPUSH
75525: CALL_OW 248
75529: ST_TO_ADDR
// if sources then
75530: LD_VAR 0 5
75534: IFFALSE 75581
// for i = 1 to 3 do
75536: LD_ADDR_VAR 0 8
75540: PUSH
75541: DOUBLE
75542: LD_INT 1
75544: DEC
75545: ST_TO_ADDR
75546: LD_INT 3
75548: PUSH
75549: FOR_TO
75550: IFFALSE 75579
// AddResourceType ( base , i , sources [ i ] ) ;
75552: LD_VAR 0 15
75556: PPUSH
75557: LD_VAR 0 8
75561: PPUSH
75562: LD_VAR 0 5
75566: PUSH
75567: LD_VAR 0 8
75571: ARRAY
75572: PPUSH
75573: CALL_OW 276
75577: GO 75549
75579: POP
75580: POP
// buildings := GetBaseBuildings ( base , area ) ;
75581: LD_ADDR_VAR 0 18
75585: PUSH
75586: LD_VAR 0 15
75590: PPUSH
75591: LD_VAR 0 2
75595: PPUSH
75596: CALL 74873 0 2
75600: ST_TO_ADDR
// InitHc ;
75601: CALL_OW 19
// InitUc ;
75605: CALL_OW 18
// uc_side := side ;
75609: LD_ADDR_OWVAR 20
75613: PUSH
75614: LD_VAR 0 16
75618: ST_TO_ADDR
// uc_nation := nation ;
75619: LD_ADDR_OWVAR 21
75623: PUSH
75624: LD_VAR 0 17
75628: ST_TO_ADDR
// if buildings then
75629: LD_VAR 0 18
75633: IFFALSE 76955
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
75635: LD_ADDR_VAR 0 19
75639: PUSH
75640: LD_VAR 0 18
75644: PPUSH
75645: LD_INT 2
75647: PUSH
75648: LD_INT 30
75650: PUSH
75651: LD_INT 29
75653: PUSH
75654: EMPTY
75655: LIST
75656: LIST
75657: PUSH
75658: LD_INT 30
75660: PUSH
75661: LD_INT 30
75663: PUSH
75664: EMPTY
75665: LIST
75666: LIST
75667: PUSH
75668: EMPTY
75669: LIST
75670: LIST
75671: LIST
75672: PPUSH
75673: CALL_OW 72
75677: ST_TO_ADDR
// if tmp then
75678: LD_VAR 0 19
75682: IFFALSE 75730
// for i in tmp do
75684: LD_ADDR_VAR 0 8
75688: PUSH
75689: LD_VAR 0 19
75693: PUSH
75694: FOR_IN
75695: IFFALSE 75728
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
75697: LD_VAR 0 8
75701: PPUSH
75702: CALL_OW 250
75706: PPUSH
75707: LD_VAR 0 8
75711: PPUSH
75712: CALL_OW 251
75716: PPUSH
75717: LD_VAR 0 16
75721: PPUSH
75722: CALL_OW 441
75726: GO 75694
75728: POP
75729: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
75730: LD_VAR 0 18
75734: PPUSH
75735: LD_INT 2
75737: PUSH
75738: LD_INT 30
75740: PUSH
75741: LD_INT 32
75743: PUSH
75744: EMPTY
75745: LIST
75746: LIST
75747: PUSH
75748: LD_INT 30
75750: PUSH
75751: LD_INT 33
75753: PUSH
75754: EMPTY
75755: LIST
75756: LIST
75757: PUSH
75758: EMPTY
75759: LIST
75760: LIST
75761: LIST
75762: PPUSH
75763: CALL_OW 72
75767: IFFALSE 75855
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
75769: LD_ADDR_VAR 0 8
75773: PUSH
75774: LD_VAR 0 18
75778: PPUSH
75779: LD_INT 2
75781: PUSH
75782: LD_INT 30
75784: PUSH
75785: LD_INT 32
75787: PUSH
75788: EMPTY
75789: LIST
75790: LIST
75791: PUSH
75792: LD_INT 30
75794: PUSH
75795: LD_INT 33
75797: PUSH
75798: EMPTY
75799: LIST
75800: LIST
75801: PUSH
75802: EMPTY
75803: LIST
75804: LIST
75805: LIST
75806: PPUSH
75807: CALL_OW 72
75811: PUSH
75812: FOR_IN
75813: IFFALSE 75853
// begin if not GetBWeapon ( i ) then
75815: LD_VAR 0 8
75819: PPUSH
75820: CALL_OW 269
75824: NOT
75825: IFFALSE 75851
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
75827: LD_VAR 0 8
75831: PPUSH
75832: LD_VAR 0 8
75836: PPUSH
75837: LD_VAR 0 2
75841: PPUSH
75842: CALL 77101 0 2
75846: PPUSH
75847: CALL_OW 431
// end ;
75851: GO 75812
75853: POP
75854: POP
// end ; for i = 1 to personel do
75855: LD_ADDR_VAR 0 8
75859: PUSH
75860: DOUBLE
75861: LD_INT 1
75863: DEC
75864: ST_TO_ADDR
75865: LD_VAR 0 6
75869: PUSH
75870: FOR_TO
75871: IFFALSE 76935
// begin if i > 4 then
75873: LD_VAR 0 8
75877: PUSH
75878: LD_INT 4
75880: GREATER
75881: IFFALSE 75885
// break ;
75883: GO 76935
// case i of 1 :
75885: LD_VAR 0 8
75889: PUSH
75890: LD_INT 1
75892: DOUBLE
75893: EQUAL
75894: IFTRUE 75898
75896: GO 75978
75898: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
75899: LD_ADDR_VAR 0 12
75903: PUSH
75904: LD_VAR 0 18
75908: PPUSH
75909: LD_INT 22
75911: PUSH
75912: LD_VAR 0 16
75916: PUSH
75917: EMPTY
75918: LIST
75919: LIST
75920: PUSH
75921: LD_INT 58
75923: PUSH
75924: EMPTY
75925: LIST
75926: PUSH
75927: LD_INT 2
75929: PUSH
75930: LD_INT 30
75932: PUSH
75933: LD_INT 32
75935: PUSH
75936: EMPTY
75937: LIST
75938: LIST
75939: PUSH
75940: LD_INT 30
75942: PUSH
75943: LD_INT 4
75945: PUSH
75946: EMPTY
75947: LIST
75948: LIST
75949: PUSH
75950: LD_INT 30
75952: PUSH
75953: LD_INT 5
75955: PUSH
75956: EMPTY
75957: LIST
75958: LIST
75959: PUSH
75960: EMPTY
75961: LIST
75962: LIST
75963: LIST
75964: LIST
75965: PUSH
75966: EMPTY
75967: LIST
75968: LIST
75969: LIST
75970: PPUSH
75971: CALL_OW 72
75975: ST_TO_ADDR
75976: GO 76200
75978: LD_INT 2
75980: DOUBLE
75981: EQUAL
75982: IFTRUE 75986
75984: GO 76048
75986: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
75987: LD_ADDR_VAR 0 12
75991: PUSH
75992: LD_VAR 0 18
75996: PPUSH
75997: LD_INT 22
75999: PUSH
76000: LD_VAR 0 16
76004: PUSH
76005: EMPTY
76006: LIST
76007: LIST
76008: PUSH
76009: LD_INT 2
76011: PUSH
76012: LD_INT 30
76014: PUSH
76015: LD_INT 0
76017: PUSH
76018: EMPTY
76019: LIST
76020: LIST
76021: PUSH
76022: LD_INT 30
76024: PUSH
76025: LD_INT 1
76027: PUSH
76028: EMPTY
76029: LIST
76030: LIST
76031: PUSH
76032: EMPTY
76033: LIST
76034: LIST
76035: LIST
76036: PUSH
76037: EMPTY
76038: LIST
76039: LIST
76040: PPUSH
76041: CALL_OW 72
76045: ST_TO_ADDR
76046: GO 76200
76048: LD_INT 3
76050: DOUBLE
76051: EQUAL
76052: IFTRUE 76056
76054: GO 76118
76056: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
76057: LD_ADDR_VAR 0 12
76061: PUSH
76062: LD_VAR 0 18
76066: PPUSH
76067: LD_INT 22
76069: PUSH
76070: LD_VAR 0 16
76074: PUSH
76075: EMPTY
76076: LIST
76077: LIST
76078: PUSH
76079: LD_INT 2
76081: PUSH
76082: LD_INT 30
76084: PUSH
76085: LD_INT 2
76087: PUSH
76088: EMPTY
76089: LIST
76090: LIST
76091: PUSH
76092: LD_INT 30
76094: PUSH
76095: LD_INT 3
76097: PUSH
76098: EMPTY
76099: LIST
76100: LIST
76101: PUSH
76102: EMPTY
76103: LIST
76104: LIST
76105: LIST
76106: PUSH
76107: EMPTY
76108: LIST
76109: LIST
76110: PPUSH
76111: CALL_OW 72
76115: ST_TO_ADDR
76116: GO 76200
76118: LD_INT 4
76120: DOUBLE
76121: EQUAL
76122: IFTRUE 76126
76124: GO 76199
76126: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
76127: LD_ADDR_VAR 0 12
76131: PUSH
76132: LD_VAR 0 18
76136: PPUSH
76137: LD_INT 22
76139: PUSH
76140: LD_VAR 0 16
76144: PUSH
76145: EMPTY
76146: LIST
76147: LIST
76148: PUSH
76149: LD_INT 2
76151: PUSH
76152: LD_INT 30
76154: PUSH
76155: LD_INT 6
76157: PUSH
76158: EMPTY
76159: LIST
76160: LIST
76161: PUSH
76162: LD_INT 30
76164: PUSH
76165: LD_INT 7
76167: PUSH
76168: EMPTY
76169: LIST
76170: LIST
76171: PUSH
76172: LD_INT 30
76174: PUSH
76175: LD_INT 8
76177: PUSH
76178: EMPTY
76179: LIST
76180: LIST
76181: PUSH
76182: EMPTY
76183: LIST
76184: LIST
76185: LIST
76186: LIST
76187: PUSH
76188: EMPTY
76189: LIST
76190: LIST
76191: PPUSH
76192: CALL_OW 72
76196: ST_TO_ADDR
76197: GO 76200
76199: POP
// if i = 1 then
76200: LD_VAR 0 8
76204: PUSH
76205: LD_INT 1
76207: EQUAL
76208: IFFALSE 76319
// begin tmp := [ ] ;
76210: LD_ADDR_VAR 0 19
76214: PUSH
76215: EMPTY
76216: ST_TO_ADDR
// for j in f do
76217: LD_ADDR_VAR 0 9
76221: PUSH
76222: LD_VAR 0 12
76226: PUSH
76227: FOR_IN
76228: IFFALSE 76301
// if GetBType ( j ) = b_bunker then
76230: LD_VAR 0 9
76234: PPUSH
76235: CALL_OW 266
76239: PUSH
76240: LD_INT 32
76242: EQUAL
76243: IFFALSE 76270
// tmp := Insert ( tmp , 1 , j ) else
76245: LD_ADDR_VAR 0 19
76249: PUSH
76250: LD_VAR 0 19
76254: PPUSH
76255: LD_INT 1
76257: PPUSH
76258: LD_VAR 0 9
76262: PPUSH
76263: CALL_OW 2
76267: ST_TO_ADDR
76268: GO 76299
// tmp := Insert ( tmp , tmp + 1 , j ) ;
76270: LD_ADDR_VAR 0 19
76274: PUSH
76275: LD_VAR 0 19
76279: PPUSH
76280: LD_VAR 0 19
76284: PUSH
76285: LD_INT 1
76287: PLUS
76288: PPUSH
76289: LD_VAR 0 9
76293: PPUSH
76294: CALL_OW 2
76298: ST_TO_ADDR
76299: GO 76227
76301: POP
76302: POP
// if tmp then
76303: LD_VAR 0 19
76307: IFFALSE 76319
// f := tmp ;
76309: LD_ADDR_VAR 0 12
76313: PUSH
76314: LD_VAR 0 19
76318: ST_TO_ADDR
// end ; x := personel [ i ] ;
76319: LD_ADDR_VAR 0 13
76323: PUSH
76324: LD_VAR 0 6
76328: PUSH
76329: LD_VAR 0 8
76333: ARRAY
76334: ST_TO_ADDR
// if x = - 1 then
76335: LD_VAR 0 13
76339: PUSH
76340: LD_INT 1
76342: NEG
76343: EQUAL
76344: IFFALSE 76553
// begin for j in f do
76346: LD_ADDR_VAR 0 9
76350: PUSH
76351: LD_VAR 0 12
76355: PUSH
76356: FOR_IN
76357: IFFALSE 76549
// repeat InitHc ;
76359: CALL_OW 19
// if GetBType ( j ) = b_barracks then
76363: LD_VAR 0 9
76367: PPUSH
76368: CALL_OW 266
76372: PUSH
76373: LD_INT 5
76375: EQUAL
76376: IFFALSE 76446
// begin if UnitsInside ( j ) < 3 then
76378: LD_VAR 0 9
76382: PPUSH
76383: CALL_OW 313
76387: PUSH
76388: LD_INT 3
76390: LESS
76391: IFFALSE 76427
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76393: LD_INT 0
76395: PPUSH
76396: LD_INT 5
76398: PUSH
76399: LD_INT 8
76401: PUSH
76402: LD_INT 9
76404: PUSH
76405: EMPTY
76406: LIST
76407: LIST
76408: LIST
76409: PUSH
76410: LD_VAR 0 17
76414: ARRAY
76415: PPUSH
76416: LD_VAR 0 4
76420: PPUSH
76421: CALL_OW 380
76425: GO 76444
// PrepareHuman ( false , i , skill ) ;
76427: LD_INT 0
76429: PPUSH
76430: LD_VAR 0 8
76434: PPUSH
76435: LD_VAR 0 4
76439: PPUSH
76440: CALL_OW 380
// end else
76444: GO 76463
// PrepareHuman ( false , i , skill ) ;
76446: LD_INT 0
76448: PPUSH
76449: LD_VAR 0 8
76453: PPUSH
76454: LD_VAR 0 4
76458: PPUSH
76459: CALL_OW 380
// un := CreateHuman ;
76463: LD_ADDR_VAR 0 14
76467: PUSH
76468: CALL_OW 44
76472: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76473: LD_ADDR_VAR 0 7
76477: PUSH
76478: LD_VAR 0 7
76482: PPUSH
76483: LD_INT 1
76485: PPUSH
76486: LD_VAR 0 14
76490: PPUSH
76491: CALL_OW 2
76495: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
76496: LD_VAR 0 14
76500: PPUSH
76501: LD_VAR 0 9
76505: PPUSH
76506: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
76510: LD_VAR 0 9
76514: PPUSH
76515: CALL_OW 313
76519: PUSH
76520: LD_INT 6
76522: EQUAL
76523: PUSH
76524: LD_VAR 0 9
76528: PPUSH
76529: CALL_OW 266
76533: PUSH
76534: LD_INT 32
76536: PUSH
76537: LD_INT 31
76539: PUSH
76540: EMPTY
76541: LIST
76542: LIST
76543: IN
76544: OR
76545: IFFALSE 76359
76547: GO 76356
76549: POP
76550: POP
// end else
76551: GO 76933
// for j = 1 to x do
76553: LD_ADDR_VAR 0 9
76557: PUSH
76558: DOUBLE
76559: LD_INT 1
76561: DEC
76562: ST_TO_ADDR
76563: LD_VAR 0 13
76567: PUSH
76568: FOR_TO
76569: IFFALSE 76931
// begin InitHc ;
76571: CALL_OW 19
// if not f then
76575: LD_VAR 0 12
76579: NOT
76580: IFFALSE 76669
// begin PrepareHuman ( false , i , skill ) ;
76582: LD_INT 0
76584: PPUSH
76585: LD_VAR 0 8
76589: PPUSH
76590: LD_VAR 0 4
76594: PPUSH
76595: CALL_OW 380
// un := CreateHuman ;
76599: LD_ADDR_VAR 0 14
76603: PUSH
76604: CALL_OW 44
76608: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76609: LD_ADDR_VAR 0 7
76613: PUSH
76614: LD_VAR 0 7
76618: PPUSH
76619: LD_INT 1
76621: PPUSH
76622: LD_VAR 0 14
76626: PPUSH
76627: CALL_OW 2
76631: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76632: LD_VAR 0 14
76636: PPUSH
76637: LD_VAR 0 1
76641: PPUSH
76642: CALL_OW 250
76646: PPUSH
76647: LD_VAR 0 1
76651: PPUSH
76652: CALL_OW 251
76656: PPUSH
76657: LD_INT 10
76659: PPUSH
76660: LD_INT 0
76662: PPUSH
76663: CALL_OW 50
// continue ;
76667: GO 76568
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
76669: LD_VAR 0 12
76673: PUSH
76674: LD_INT 1
76676: ARRAY
76677: PPUSH
76678: CALL_OW 313
76682: PUSH
76683: LD_VAR 0 12
76687: PUSH
76688: LD_INT 1
76690: ARRAY
76691: PPUSH
76692: CALL_OW 266
76696: PUSH
76697: LD_INT 32
76699: PUSH
76700: LD_INT 31
76702: PUSH
76703: EMPTY
76704: LIST
76705: LIST
76706: IN
76707: AND
76708: PUSH
76709: LD_VAR 0 12
76713: PUSH
76714: LD_INT 1
76716: ARRAY
76717: PPUSH
76718: CALL_OW 313
76722: PUSH
76723: LD_INT 6
76725: EQUAL
76726: OR
76727: IFFALSE 76747
// f := Delete ( f , 1 ) ;
76729: LD_ADDR_VAR 0 12
76733: PUSH
76734: LD_VAR 0 12
76738: PPUSH
76739: LD_INT 1
76741: PPUSH
76742: CALL_OW 3
76746: ST_TO_ADDR
// if not f then
76747: LD_VAR 0 12
76751: NOT
76752: IFFALSE 76770
// begin x := x + 2 ;
76754: LD_ADDR_VAR 0 13
76758: PUSH
76759: LD_VAR 0 13
76763: PUSH
76764: LD_INT 2
76766: PLUS
76767: ST_TO_ADDR
// continue ;
76768: GO 76568
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
76770: LD_VAR 0 12
76774: PUSH
76775: LD_INT 1
76777: ARRAY
76778: PPUSH
76779: CALL_OW 266
76783: PUSH
76784: LD_INT 5
76786: EQUAL
76787: IFFALSE 76861
// begin if UnitsInside ( f [ 1 ] ) < 3 then
76789: LD_VAR 0 12
76793: PUSH
76794: LD_INT 1
76796: ARRAY
76797: PPUSH
76798: CALL_OW 313
76802: PUSH
76803: LD_INT 3
76805: LESS
76806: IFFALSE 76842
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76808: LD_INT 0
76810: PPUSH
76811: LD_INT 5
76813: PUSH
76814: LD_INT 8
76816: PUSH
76817: LD_INT 9
76819: PUSH
76820: EMPTY
76821: LIST
76822: LIST
76823: LIST
76824: PUSH
76825: LD_VAR 0 17
76829: ARRAY
76830: PPUSH
76831: LD_VAR 0 4
76835: PPUSH
76836: CALL_OW 380
76840: GO 76859
// PrepareHuman ( false , i , skill ) ;
76842: LD_INT 0
76844: PPUSH
76845: LD_VAR 0 8
76849: PPUSH
76850: LD_VAR 0 4
76854: PPUSH
76855: CALL_OW 380
// end else
76859: GO 76878
// PrepareHuman ( false , i , skill ) ;
76861: LD_INT 0
76863: PPUSH
76864: LD_VAR 0 8
76868: PPUSH
76869: LD_VAR 0 4
76873: PPUSH
76874: CALL_OW 380
// un := CreateHuman ;
76878: LD_ADDR_VAR 0 14
76882: PUSH
76883: CALL_OW 44
76887: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76888: LD_ADDR_VAR 0 7
76892: PUSH
76893: LD_VAR 0 7
76897: PPUSH
76898: LD_INT 1
76900: PPUSH
76901: LD_VAR 0 14
76905: PPUSH
76906: CALL_OW 2
76910: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
76911: LD_VAR 0 14
76915: PPUSH
76916: LD_VAR 0 12
76920: PUSH
76921: LD_INT 1
76923: ARRAY
76924: PPUSH
76925: CALL_OW 52
// end ;
76929: GO 76568
76931: POP
76932: POP
// end ;
76933: GO 75870
76935: POP
76936: POP
// result := result ^ buildings ;
76937: LD_ADDR_VAR 0 7
76941: PUSH
76942: LD_VAR 0 7
76946: PUSH
76947: LD_VAR 0 18
76951: ADD
76952: ST_TO_ADDR
// end else
76953: GO 77096
// begin for i = 1 to personel do
76955: LD_ADDR_VAR 0 8
76959: PUSH
76960: DOUBLE
76961: LD_INT 1
76963: DEC
76964: ST_TO_ADDR
76965: LD_VAR 0 6
76969: PUSH
76970: FOR_TO
76971: IFFALSE 77094
// begin if i > 4 then
76973: LD_VAR 0 8
76977: PUSH
76978: LD_INT 4
76980: GREATER
76981: IFFALSE 76985
// break ;
76983: GO 77094
// x := personel [ i ] ;
76985: LD_ADDR_VAR 0 13
76989: PUSH
76990: LD_VAR 0 6
76994: PUSH
76995: LD_VAR 0 8
76999: ARRAY
77000: ST_TO_ADDR
// if x = - 1 then
77001: LD_VAR 0 13
77005: PUSH
77006: LD_INT 1
77008: NEG
77009: EQUAL
77010: IFFALSE 77014
// continue ;
77012: GO 76970
// PrepareHuman ( false , i , skill ) ;
77014: LD_INT 0
77016: PPUSH
77017: LD_VAR 0 8
77021: PPUSH
77022: LD_VAR 0 4
77026: PPUSH
77027: CALL_OW 380
// un := CreateHuman ;
77031: LD_ADDR_VAR 0 14
77035: PUSH
77036: CALL_OW 44
77040: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
77041: LD_VAR 0 14
77045: PPUSH
77046: LD_VAR 0 1
77050: PPUSH
77051: CALL_OW 250
77055: PPUSH
77056: LD_VAR 0 1
77060: PPUSH
77061: CALL_OW 251
77065: PPUSH
77066: LD_INT 10
77068: PPUSH
77069: LD_INT 0
77071: PPUSH
77072: CALL_OW 50
// result := result ^ un ;
77076: LD_ADDR_VAR 0 7
77080: PUSH
77081: LD_VAR 0 7
77085: PUSH
77086: LD_VAR 0 14
77090: ADD
77091: ST_TO_ADDR
// end ;
77092: GO 76970
77094: POP
77095: POP
// end ; end ;
77096: LD_VAR 0 7
77100: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
77101: LD_INT 0
77103: PPUSH
77104: PPUSH
77105: PPUSH
77106: PPUSH
77107: PPUSH
77108: PPUSH
77109: PPUSH
77110: PPUSH
77111: PPUSH
77112: PPUSH
77113: PPUSH
77114: PPUSH
77115: PPUSH
77116: PPUSH
77117: PPUSH
77118: PPUSH
// result := false ;
77119: LD_ADDR_VAR 0 3
77123: PUSH
77124: LD_INT 0
77126: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
77127: LD_VAR 0 1
77131: NOT
77132: PUSH
77133: LD_VAR 0 1
77137: PPUSH
77138: CALL_OW 266
77142: PUSH
77143: LD_INT 32
77145: PUSH
77146: LD_INT 33
77148: PUSH
77149: EMPTY
77150: LIST
77151: LIST
77152: IN
77153: NOT
77154: OR
77155: IFFALSE 77159
// exit ;
77157: GO 78295
// nat := GetNation ( tower ) ;
77159: LD_ADDR_VAR 0 12
77163: PUSH
77164: LD_VAR 0 1
77168: PPUSH
77169: CALL_OW 248
77173: ST_TO_ADDR
// side := GetSide ( tower ) ;
77174: LD_ADDR_VAR 0 16
77178: PUSH
77179: LD_VAR 0 1
77183: PPUSH
77184: CALL_OW 255
77188: ST_TO_ADDR
// x := GetX ( tower ) ;
77189: LD_ADDR_VAR 0 10
77193: PUSH
77194: LD_VAR 0 1
77198: PPUSH
77199: CALL_OW 250
77203: ST_TO_ADDR
// y := GetY ( tower ) ;
77204: LD_ADDR_VAR 0 11
77208: PUSH
77209: LD_VAR 0 1
77213: PPUSH
77214: CALL_OW 251
77218: ST_TO_ADDR
// if not x or not y then
77219: LD_VAR 0 10
77223: NOT
77224: PUSH
77225: LD_VAR 0 11
77229: NOT
77230: OR
77231: IFFALSE 77235
// exit ;
77233: GO 78295
// weapon := 0 ;
77235: LD_ADDR_VAR 0 18
77239: PUSH
77240: LD_INT 0
77242: ST_TO_ADDR
// fac_list := [ ] ;
77243: LD_ADDR_VAR 0 17
77247: PUSH
77248: EMPTY
77249: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
77250: LD_ADDR_VAR 0 6
77254: PUSH
77255: LD_VAR 0 1
77259: PPUSH
77260: CALL_OW 274
77264: PPUSH
77265: LD_VAR 0 2
77269: PPUSH
77270: CALL 74873 0 2
77274: PPUSH
77275: LD_INT 30
77277: PUSH
77278: LD_INT 3
77280: PUSH
77281: EMPTY
77282: LIST
77283: LIST
77284: PPUSH
77285: CALL_OW 72
77289: ST_TO_ADDR
// if not factories then
77290: LD_VAR 0 6
77294: NOT
77295: IFFALSE 77299
// exit ;
77297: GO 78295
// for i in factories do
77299: LD_ADDR_VAR 0 8
77303: PUSH
77304: LD_VAR 0 6
77308: PUSH
77309: FOR_IN
77310: IFFALSE 77335
// fac_list := fac_list union AvailableWeaponList ( i ) ;
77312: LD_ADDR_VAR 0 17
77316: PUSH
77317: LD_VAR 0 17
77321: PUSH
77322: LD_VAR 0 8
77326: PPUSH
77327: CALL_OW 478
77331: UNION
77332: ST_TO_ADDR
77333: GO 77309
77335: POP
77336: POP
// if not fac_list then
77337: LD_VAR 0 17
77341: NOT
77342: IFFALSE 77346
// exit ;
77344: GO 78295
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
77346: LD_ADDR_VAR 0 5
77350: PUSH
77351: LD_INT 4
77353: PUSH
77354: LD_INT 5
77356: PUSH
77357: LD_INT 9
77359: PUSH
77360: LD_INT 10
77362: PUSH
77363: LD_INT 6
77365: PUSH
77366: LD_INT 7
77368: PUSH
77369: LD_INT 11
77371: PUSH
77372: EMPTY
77373: LIST
77374: LIST
77375: LIST
77376: LIST
77377: LIST
77378: LIST
77379: LIST
77380: PUSH
77381: LD_INT 27
77383: PUSH
77384: LD_INT 28
77386: PUSH
77387: LD_INT 26
77389: PUSH
77390: LD_INT 30
77392: PUSH
77393: EMPTY
77394: LIST
77395: LIST
77396: LIST
77397: LIST
77398: PUSH
77399: LD_INT 43
77401: PUSH
77402: LD_INT 44
77404: PUSH
77405: LD_INT 46
77407: PUSH
77408: LD_INT 45
77410: PUSH
77411: LD_INT 47
77413: PUSH
77414: LD_INT 49
77416: PUSH
77417: EMPTY
77418: LIST
77419: LIST
77420: LIST
77421: LIST
77422: LIST
77423: LIST
77424: PUSH
77425: EMPTY
77426: LIST
77427: LIST
77428: LIST
77429: PUSH
77430: LD_VAR 0 12
77434: ARRAY
77435: ST_TO_ADDR
// for i in list do
77436: LD_ADDR_VAR 0 8
77440: PUSH
77441: LD_VAR 0 5
77445: PUSH
77446: FOR_IN
77447: IFFALSE 77480
// if not i in fac_list then
77449: LD_VAR 0 8
77453: PUSH
77454: LD_VAR 0 17
77458: IN
77459: NOT
77460: IFFALSE 77478
// list := list diff i ;
77462: LD_ADDR_VAR 0 5
77466: PUSH
77467: LD_VAR 0 5
77471: PUSH
77472: LD_VAR 0 8
77476: DIFF
77477: ST_TO_ADDR
77478: GO 77446
77480: POP
77481: POP
// if not list then
77482: LD_VAR 0 5
77486: NOT
77487: IFFALSE 77491
// exit ;
77489: GO 78295
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
77491: LD_VAR 0 12
77495: PUSH
77496: LD_INT 3
77498: EQUAL
77499: PUSH
77500: LD_INT 49
77502: PUSH
77503: LD_VAR 0 5
77507: IN
77508: AND
77509: PUSH
77510: LD_INT 31
77512: PPUSH
77513: LD_VAR 0 16
77517: PPUSH
77518: CALL_OW 321
77522: PUSH
77523: LD_INT 2
77525: EQUAL
77526: AND
77527: IFFALSE 77587
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
77529: LD_INT 22
77531: PUSH
77532: LD_VAR 0 16
77536: PUSH
77537: EMPTY
77538: LIST
77539: LIST
77540: PUSH
77541: LD_INT 35
77543: PUSH
77544: LD_INT 49
77546: PUSH
77547: EMPTY
77548: LIST
77549: LIST
77550: PUSH
77551: LD_INT 91
77553: PUSH
77554: LD_VAR 0 1
77558: PUSH
77559: LD_INT 10
77561: PUSH
77562: EMPTY
77563: LIST
77564: LIST
77565: LIST
77566: PUSH
77567: EMPTY
77568: LIST
77569: LIST
77570: LIST
77571: PPUSH
77572: CALL_OW 69
77576: NOT
77577: IFFALSE 77587
// weapon := ru_time_lapser ;
77579: LD_ADDR_VAR 0 18
77583: PUSH
77584: LD_INT 49
77586: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
77587: LD_VAR 0 12
77591: PUSH
77592: LD_INT 1
77594: PUSH
77595: LD_INT 2
77597: PUSH
77598: EMPTY
77599: LIST
77600: LIST
77601: IN
77602: PUSH
77603: LD_INT 11
77605: PUSH
77606: LD_VAR 0 5
77610: IN
77611: PUSH
77612: LD_INT 30
77614: PUSH
77615: LD_VAR 0 5
77619: IN
77620: OR
77621: AND
77622: PUSH
77623: LD_INT 6
77625: PPUSH
77626: LD_VAR 0 16
77630: PPUSH
77631: CALL_OW 321
77635: PUSH
77636: LD_INT 2
77638: EQUAL
77639: AND
77640: IFFALSE 77805
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
77642: LD_INT 22
77644: PUSH
77645: LD_VAR 0 16
77649: PUSH
77650: EMPTY
77651: LIST
77652: LIST
77653: PUSH
77654: LD_INT 2
77656: PUSH
77657: LD_INT 35
77659: PUSH
77660: LD_INT 11
77662: PUSH
77663: EMPTY
77664: LIST
77665: LIST
77666: PUSH
77667: LD_INT 35
77669: PUSH
77670: LD_INT 30
77672: PUSH
77673: EMPTY
77674: LIST
77675: LIST
77676: PUSH
77677: EMPTY
77678: LIST
77679: LIST
77680: LIST
77681: PUSH
77682: LD_INT 91
77684: PUSH
77685: LD_VAR 0 1
77689: PUSH
77690: LD_INT 18
77692: PUSH
77693: EMPTY
77694: LIST
77695: LIST
77696: LIST
77697: PUSH
77698: EMPTY
77699: LIST
77700: LIST
77701: LIST
77702: PPUSH
77703: CALL_OW 69
77707: NOT
77708: PUSH
77709: LD_INT 22
77711: PUSH
77712: LD_VAR 0 16
77716: PUSH
77717: EMPTY
77718: LIST
77719: LIST
77720: PUSH
77721: LD_INT 2
77723: PUSH
77724: LD_INT 30
77726: PUSH
77727: LD_INT 32
77729: PUSH
77730: EMPTY
77731: LIST
77732: LIST
77733: PUSH
77734: LD_INT 30
77736: PUSH
77737: LD_INT 33
77739: PUSH
77740: EMPTY
77741: LIST
77742: LIST
77743: PUSH
77744: EMPTY
77745: LIST
77746: LIST
77747: LIST
77748: PUSH
77749: LD_INT 91
77751: PUSH
77752: LD_VAR 0 1
77756: PUSH
77757: LD_INT 12
77759: PUSH
77760: EMPTY
77761: LIST
77762: LIST
77763: LIST
77764: PUSH
77765: EMPTY
77766: LIST
77767: LIST
77768: LIST
77769: PUSH
77770: EMPTY
77771: LIST
77772: PPUSH
77773: CALL_OW 69
77777: PUSH
77778: LD_INT 2
77780: GREATER
77781: AND
77782: IFFALSE 77805
// weapon := [ us_radar , ar_radar ] [ nat ] ;
77784: LD_ADDR_VAR 0 18
77788: PUSH
77789: LD_INT 11
77791: PUSH
77792: LD_INT 30
77794: PUSH
77795: EMPTY
77796: LIST
77797: LIST
77798: PUSH
77799: LD_VAR 0 12
77803: ARRAY
77804: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
77805: LD_VAR 0 18
77809: NOT
77810: PUSH
77811: LD_INT 40
77813: PPUSH
77814: LD_VAR 0 16
77818: PPUSH
77819: CALL_OW 321
77823: PUSH
77824: LD_INT 2
77826: EQUAL
77827: AND
77828: PUSH
77829: LD_INT 7
77831: PUSH
77832: LD_VAR 0 5
77836: IN
77837: PUSH
77838: LD_INT 28
77840: PUSH
77841: LD_VAR 0 5
77845: IN
77846: OR
77847: PUSH
77848: LD_INT 45
77850: PUSH
77851: LD_VAR 0 5
77855: IN
77856: OR
77857: AND
77858: IFFALSE 78112
// begin hex := GetHexInfo ( x , y ) ;
77860: LD_ADDR_VAR 0 4
77864: PUSH
77865: LD_VAR 0 10
77869: PPUSH
77870: LD_VAR 0 11
77874: PPUSH
77875: CALL_OW 546
77879: ST_TO_ADDR
// if hex [ 1 ] then
77880: LD_VAR 0 4
77884: PUSH
77885: LD_INT 1
77887: ARRAY
77888: IFFALSE 77892
// exit ;
77890: GO 78295
// height := hex [ 2 ] ;
77892: LD_ADDR_VAR 0 15
77896: PUSH
77897: LD_VAR 0 4
77901: PUSH
77902: LD_INT 2
77904: ARRAY
77905: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
77906: LD_ADDR_VAR 0 14
77910: PUSH
77911: LD_INT 0
77913: PUSH
77914: LD_INT 2
77916: PUSH
77917: LD_INT 3
77919: PUSH
77920: LD_INT 5
77922: PUSH
77923: EMPTY
77924: LIST
77925: LIST
77926: LIST
77927: LIST
77928: ST_TO_ADDR
// for i in tmp do
77929: LD_ADDR_VAR 0 8
77933: PUSH
77934: LD_VAR 0 14
77938: PUSH
77939: FOR_IN
77940: IFFALSE 78110
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
77942: LD_ADDR_VAR 0 9
77946: PUSH
77947: LD_VAR 0 10
77951: PPUSH
77952: LD_VAR 0 8
77956: PPUSH
77957: LD_INT 5
77959: PPUSH
77960: CALL_OW 272
77964: PUSH
77965: LD_VAR 0 11
77969: PPUSH
77970: LD_VAR 0 8
77974: PPUSH
77975: LD_INT 5
77977: PPUSH
77978: CALL_OW 273
77982: PUSH
77983: EMPTY
77984: LIST
77985: LIST
77986: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
77987: LD_VAR 0 9
77991: PUSH
77992: LD_INT 1
77994: ARRAY
77995: PPUSH
77996: LD_VAR 0 9
78000: PUSH
78001: LD_INT 2
78003: ARRAY
78004: PPUSH
78005: CALL_OW 488
78009: IFFALSE 78108
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
78011: LD_ADDR_VAR 0 4
78015: PUSH
78016: LD_VAR 0 9
78020: PUSH
78021: LD_INT 1
78023: ARRAY
78024: PPUSH
78025: LD_VAR 0 9
78029: PUSH
78030: LD_INT 2
78032: ARRAY
78033: PPUSH
78034: CALL_OW 546
78038: ST_TO_ADDR
// if hex [ 1 ] then
78039: LD_VAR 0 4
78043: PUSH
78044: LD_INT 1
78046: ARRAY
78047: IFFALSE 78051
// continue ;
78049: GO 77939
// h := hex [ 2 ] ;
78051: LD_ADDR_VAR 0 13
78055: PUSH
78056: LD_VAR 0 4
78060: PUSH
78061: LD_INT 2
78063: ARRAY
78064: ST_TO_ADDR
// if h + 7 < height then
78065: LD_VAR 0 13
78069: PUSH
78070: LD_INT 7
78072: PLUS
78073: PUSH
78074: LD_VAR 0 15
78078: LESS
78079: IFFALSE 78108
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
78081: LD_ADDR_VAR 0 18
78085: PUSH
78086: LD_INT 7
78088: PUSH
78089: LD_INT 28
78091: PUSH
78092: LD_INT 45
78094: PUSH
78095: EMPTY
78096: LIST
78097: LIST
78098: LIST
78099: PUSH
78100: LD_VAR 0 12
78104: ARRAY
78105: ST_TO_ADDR
// break ;
78106: GO 78110
// end ; end ; end ;
78108: GO 77939
78110: POP
78111: POP
// end ; if not weapon then
78112: LD_VAR 0 18
78116: NOT
78117: IFFALSE 78177
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
78119: LD_ADDR_VAR 0 5
78123: PUSH
78124: LD_VAR 0 5
78128: PUSH
78129: LD_INT 11
78131: PUSH
78132: LD_INT 30
78134: PUSH
78135: LD_INT 49
78137: PUSH
78138: EMPTY
78139: LIST
78140: LIST
78141: LIST
78142: DIFF
78143: ST_TO_ADDR
// if not list then
78144: LD_VAR 0 5
78148: NOT
78149: IFFALSE 78153
// exit ;
78151: GO 78295
// weapon := list [ rand ( 1 , list ) ] ;
78153: LD_ADDR_VAR 0 18
78157: PUSH
78158: LD_VAR 0 5
78162: PUSH
78163: LD_INT 1
78165: PPUSH
78166: LD_VAR 0 5
78170: PPUSH
78171: CALL_OW 12
78175: ARRAY
78176: ST_TO_ADDR
// end ; if weapon then
78177: LD_VAR 0 18
78181: IFFALSE 78295
// begin tmp := CostOfWeapon ( weapon ) ;
78183: LD_ADDR_VAR 0 14
78187: PUSH
78188: LD_VAR 0 18
78192: PPUSH
78193: CALL_OW 451
78197: ST_TO_ADDR
// j := GetBase ( tower ) ;
78198: LD_ADDR_VAR 0 9
78202: PUSH
78203: LD_VAR 0 1
78207: PPUSH
78208: CALL_OW 274
78212: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
78213: LD_VAR 0 9
78217: PPUSH
78218: LD_INT 1
78220: PPUSH
78221: CALL_OW 275
78225: PUSH
78226: LD_VAR 0 14
78230: PUSH
78231: LD_INT 1
78233: ARRAY
78234: GREATEREQUAL
78235: PUSH
78236: LD_VAR 0 9
78240: PPUSH
78241: LD_INT 2
78243: PPUSH
78244: CALL_OW 275
78248: PUSH
78249: LD_VAR 0 14
78253: PUSH
78254: LD_INT 2
78256: ARRAY
78257: GREATEREQUAL
78258: AND
78259: PUSH
78260: LD_VAR 0 9
78264: PPUSH
78265: LD_INT 3
78267: PPUSH
78268: CALL_OW 275
78272: PUSH
78273: LD_VAR 0 14
78277: PUSH
78278: LD_INT 3
78280: ARRAY
78281: GREATEREQUAL
78282: AND
78283: IFFALSE 78295
// result := weapon ;
78285: LD_ADDR_VAR 0 3
78289: PUSH
78290: LD_VAR 0 18
78294: ST_TO_ADDR
// end ; end ;
78295: LD_VAR 0 3
78299: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
78300: LD_INT 0
78302: PPUSH
78303: PPUSH
// result := true ;
78304: LD_ADDR_VAR 0 3
78308: PUSH
78309: LD_INT 1
78311: ST_TO_ADDR
// if array1 = array2 then
78312: LD_VAR 0 1
78316: PUSH
78317: LD_VAR 0 2
78321: EQUAL
78322: IFFALSE 78382
// begin for i = 1 to array1 do
78324: LD_ADDR_VAR 0 4
78328: PUSH
78329: DOUBLE
78330: LD_INT 1
78332: DEC
78333: ST_TO_ADDR
78334: LD_VAR 0 1
78338: PUSH
78339: FOR_TO
78340: IFFALSE 78378
// if array1 [ i ] <> array2 [ i ] then
78342: LD_VAR 0 1
78346: PUSH
78347: LD_VAR 0 4
78351: ARRAY
78352: PUSH
78353: LD_VAR 0 2
78357: PUSH
78358: LD_VAR 0 4
78362: ARRAY
78363: NONEQUAL
78364: IFFALSE 78376
// begin result := false ;
78366: LD_ADDR_VAR 0 3
78370: PUSH
78371: LD_INT 0
78373: ST_TO_ADDR
// break ;
78374: GO 78378
// end ;
78376: GO 78339
78378: POP
78379: POP
// end else
78380: GO 78390
// result := false ;
78382: LD_ADDR_VAR 0 3
78386: PUSH
78387: LD_INT 0
78389: ST_TO_ADDR
// end ;
78390: LD_VAR 0 3
78394: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
78395: LD_INT 0
78397: PPUSH
78398: PPUSH
78399: PPUSH
// pom := GetBase ( fac ) ;
78400: LD_ADDR_VAR 0 5
78404: PUSH
78405: LD_VAR 0 1
78409: PPUSH
78410: CALL_OW 274
78414: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
78415: LD_ADDR_VAR 0 4
78419: PUSH
78420: LD_VAR 0 2
78424: PUSH
78425: LD_INT 1
78427: ARRAY
78428: PPUSH
78429: LD_VAR 0 2
78433: PUSH
78434: LD_INT 2
78436: ARRAY
78437: PPUSH
78438: LD_VAR 0 2
78442: PUSH
78443: LD_INT 3
78445: ARRAY
78446: PPUSH
78447: LD_VAR 0 2
78451: PUSH
78452: LD_INT 4
78454: ARRAY
78455: PPUSH
78456: CALL_OW 449
78460: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78461: LD_ADDR_VAR 0 3
78465: PUSH
78466: LD_VAR 0 5
78470: PPUSH
78471: LD_INT 1
78473: PPUSH
78474: CALL_OW 275
78478: PUSH
78479: LD_VAR 0 4
78483: PUSH
78484: LD_INT 1
78486: ARRAY
78487: GREATEREQUAL
78488: PUSH
78489: LD_VAR 0 5
78493: PPUSH
78494: LD_INT 2
78496: PPUSH
78497: CALL_OW 275
78501: PUSH
78502: LD_VAR 0 4
78506: PUSH
78507: LD_INT 2
78509: ARRAY
78510: GREATEREQUAL
78511: AND
78512: PUSH
78513: LD_VAR 0 5
78517: PPUSH
78518: LD_INT 3
78520: PPUSH
78521: CALL_OW 275
78525: PUSH
78526: LD_VAR 0 4
78530: PUSH
78531: LD_INT 3
78533: ARRAY
78534: GREATEREQUAL
78535: AND
78536: ST_TO_ADDR
// end ;
78537: LD_VAR 0 3
78541: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
78542: LD_INT 0
78544: PPUSH
78545: PPUSH
78546: PPUSH
78547: PPUSH
// pom := GetBase ( building ) ;
78548: LD_ADDR_VAR 0 3
78552: PUSH
78553: LD_VAR 0 1
78557: PPUSH
78558: CALL_OW 274
78562: ST_TO_ADDR
// if not pom then
78563: LD_VAR 0 3
78567: NOT
78568: IFFALSE 78572
// exit ;
78570: GO 78742
// btype := GetBType ( building ) ;
78572: LD_ADDR_VAR 0 5
78576: PUSH
78577: LD_VAR 0 1
78581: PPUSH
78582: CALL_OW 266
78586: ST_TO_ADDR
// if btype = b_armoury then
78587: LD_VAR 0 5
78591: PUSH
78592: LD_INT 4
78594: EQUAL
78595: IFFALSE 78605
// btype := b_barracks ;
78597: LD_ADDR_VAR 0 5
78601: PUSH
78602: LD_INT 5
78604: ST_TO_ADDR
// if btype = b_depot then
78605: LD_VAR 0 5
78609: PUSH
78610: LD_INT 0
78612: EQUAL
78613: IFFALSE 78623
// btype := b_warehouse ;
78615: LD_ADDR_VAR 0 5
78619: PUSH
78620: LD_INT 1
78622: ST_TO_ADDR
// if btype = b_workshop then
78623: LD_VAR 0 5
78627: PUSH
78628: LD_INT 2
78630: EQUAL
78631: IFFALSE 78641
// btype := b_factory ;
78633: LD_ADDR_VAR 0 5
78637: PUSH
78638: LD_INT 3
78640: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78641: LD_ADDR_VAR 0 4
78645: PUSH
78646: LD_VAR 0 5
78650: PPUSH
78651: LD_VAR 0 1
78655: PPUSH
78656: CALL_OW 248
78660: PPUSH
78661: CALL_OW 450
78665: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78666: LD_ADDR_VAR 0 2
78670: PUSH
78671: LD_VAR 0 3
78675: PPUSH
78676: LD_INT 1
78678: PPUSH
78679: CALL_OW 275
78683: PUSH
78684: LD_VAR 0 4
78688: PUSH
78689: LD_INT 1
78691: ARRAY
78692: GREATEREQUAL
78693: PUSH
78694: LD_VAR 0 3
78698: PPUSH
78699: LD_INT 2
78701: PPUSH
78702: CALL_OW 275
78706: PUSH
78707: LD_VAR 0 4
78711: PUSH
78712: LD_INT 2
78714: ARRAY
78715: GREATEREQUAL
78716: AND
78717: PUSH
78718: LD_VAR 0 3
78722: PPUSH
78723: LD_INT 3
78725: PPUSH
78726: CALL_OW 275
78730: PUSH
78731: LD_VAR 0 4
78735: PUSH
78736: LD_INT 3
78738: ARRAY
78739: GREATEREQUAL
78740: AND
78741: ST_TO_ADDR
// end ;
78742: LD_VAR 0 2
78746: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
78747: LD_INT 0
78749: PPUSH
78750: PPUSH
78751: PPUSH
// pom := GetBase ( building ) ;
78752: LD_ADDR_VAR 0 4
78756: PUSH
78757: LD_VAR 0 1
78761: PPUSH
78762: CALL_OW 274
78766: ST_TO_ADDR
// if not pom then
78767: LD_VAR 0 4
78771: NOT
78772: IFFALSE 78776
// exit ;
78774: GO 78877
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78776: LD_ADDR_VAR 0 5
78780: PUSH
78781: LD_VAR 0 2
78785: PPUSH
78786: LD_VAR 0 1
78790: PPUSH
78791: CALL_OW 248
78795: PPUSH
78796: CALL_OW 450
78800: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78801: LD_ADDR_VAR 0 3
78805: PUSH
78806: LD_VAR 0 4
78810: PPUSH
78811: LD_INT 1
78813: PPUSH
78814: CALL_OW 275
78818: PUSH
78819: LD_VAR 0 5
78823: PUSH
78824: LD_INT 1
78826: ARRAY
78827: GREATEREQUAL
78828: PUSH
78829: LD_VAR 0 4
78833: PPUSH
78834: LD_INT 2
78836: PPUSH
78837: CALL_OW 275
78841: PUSH
78842: LD_VAR 0 5
78846: PUSH
78847: LD_INT 2
78849: ARRAY
78850: GREATEREQUAL
78851: AND
78852: PUSH
78853: LD_VAR 0 4
78857: PPUSH
78858: LD_INT 3
78860: PPUSH
78861: CALL_OW 275
78865: PUSH
78866: LD_VAR 0 5
78870: PUSH
78871: LD_INT 3
78873: ARRAY
78874: GREATEREQUAL
78875: AND
78876: ST_TO_ADDR
// end ;
78877: LD_VAR 0 3
78881: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
78882: LD_INT 0
78884: PPUSH
78885: PPUSH
78886: PPUSH
78887: PPUSH
78888: PPUSH
78889: PPUSH
78890: PPUSH
78891: PPUSH
78892: PPUSH
78893: PPUSH
// result := false ;
78894: LD_ADDR_VAR 0 6
78898: PUSH
78899: LD_INT 0
78901: ST_TO_ADDR
// if not base or not btype or not x or not y then
78902: LD_VAR 0 1
78906: NOT
78907: PUSH
78908: LD_VAR 0 2
78912: NOT
78913: OR
78914: PUSH
78915: LD_VAR 0 3
78919: NOT
78920: OR
78921: PUSH
78922: LD_VAR 0 4
78926: NOT
78927: OR
78928: IFFALSE 78932
// exit ;
78930: GO 79541
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
78932: LD_ADDR_VAR 0 12
78936: PUSH
78937: LD_VAR 0 2
78941: PPUSH
78942: LD_VAR 0 3
78946: PPUSH
78947: LD_VAR 0 4
78951: PPUSH
78952: LD_VAR 0 5
78956: PPUSH
78957: LD_VAR 0 1
78961: PUSH
78962: LD_INT 1
78964: ARRAY
78965: PPUSH
78966: CALL_OW 248
78970: PPUSH
78971: LD_INT 0
78973: PPUSH
78974: CALL 80378 0 6
78978: ST_TO_ADDR
// if not hexes then
78979: LD_VAR 0 12
78983: NOT
78984: IFFALSE 78988
// exit ;
78986: GO 79541
// for i = 1 to hexes do
78988: LD_ADDR_VAR 0 7
78992: PUSH
78993: DOUBLE
78994: LD_INT 1
78996: DEC
78997: ST_TO_ADDR
78998: LD_VAR 0 12
79002: PUSH
79003: FOR_TO
79004: IFFALSE 79539
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79006: LD_ADDR_VAR 0 11
79010: PUSH
79011: LD_VAR 0 12
79015: PUSH
79016: LD_VAR 0 7
79020: ARRAY
79021: PUSH
79022: LD_INT 1
79024: ARRAY
79025: PPUSH
79026: LD_VAR 0 12
79030: PUSH
79031: LD_VAR 0 7
79035: ARRAY
79036: PUSH
79037: LD_INT 2
79039: ARRAY
79040: PPUSH
79041: CALL_OW 428
79045: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
79046: LD_VAR 0 12
79050: PUSH
79051: LD_VAR 0 7
79055: ARRAY
79056: PUSH
79057: LD_INT 1
79059: ARRAY
79060: PPUSH
79061: LD_VAR 0 12
79065: PUSH
79066: LD_VAR 0 7
79070: ARRAY
79071: PUSH
79072: LD_INT 2
79074: ARRAY
79075: PPUSH
79076: CALL_OW 351
79080: PUSH
79081: LD_VAR 0 12
79085: PUSH
79086: LD_VAR 0 7
79090: ARRAY
79091: PUSH
79092: LD_INT 1
79094: ARRAY
79095: PPUSH
79096: LD_VAR 0 12
79100: PUSH
79101: LD_VAR 0 7
79105: ARRAY
79106: PUSH
79107: LD_INT 2
79109: ARRAY
79110: PPUSH
79111: CALL_OW 488
79115: NOT
79116: OR
79117: PUSH
79118: LD_VAR 0 11
79122: PPUSH
79123: CALL_OW 247
79127: PUSH
79128: LD_INT 3
79130: EQUAL
79131: OR
79132: IFFALSE 79138
// exit ;
79134: POP
79135: POP
79136: GO 79541
// if not tmp or not tmp in base then
79138: LD_VAR 0 11
79142: NOT
79143: PUSH
79144: LD_VAR 0 11
79148: PUSH
79149: LD_VAR 0 1
79153: IN
79154: NOT
79155: OR
79156: IFFALSE 79160
// continue ;
79158: GO 79003
// result := true ;
79160: LD_ADDR_VAR 0 6
79164: PUSH
79165: LD_INT 1
79167: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
79168: LD_ADDR_VAR 0 15
79172: PUSH
79173: LD_VAR 0 1
79177: PPUSH
79178: LD_INT 22
79180: PUSH
79181: LD_VAR 0 11
79185: PPUSH
79186: CALL_OW 255
79190: PUSH
79191: EMPTY
79192: LIST
79193: LIST
79194: PUSH
79195: LD_INT 2
79197: PUSH
79198: LD_INT 30
79200: PUSH
79201: LD_INT 0
79203: PUSH
79204: EMPTY
79205: LIST
79206: LIST
79207: PUSH
79208: LD_INT 30
79210: PUSH
79211: LD_INT 1
79213: PUSH
79214: EMPTY
79215: LIST
79216: LIST
79217: PUSH
79218: EMPTY
79219: LIST
79220: LIST
79221: LIST
79222: PUSH
79223: EMPTY
79224: LIST
79225: LIST
79226: PPUSH
79227: CALL_OW 72
79231: ST_TO_ADDR
// if dep then
79232: LD_VAR 0 15
79236: IFFALSE 79372
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
79238: LD_ADDR_VAR 0 14
79242: PUSH
79243: LD_VAR 0 15
79247: PUSH
79248: LD_INT 1
79250: ARRAY
79251: PPUSH
79252: CALL_OW 250
79256: PPUSH
79257: LD_VAR 0 15
79261: PUSH
79262: LD_INT 1
79264: ARRAY
79265: PPUSH
79266: CALL_OW 254
79270: PPUSH
79271: LD_INT 5
79273: PPUSH
79274: CALL_OW 272
79278: PUSH
79279: LD_VAR 0 15
79283: PUSH
79284: LD_INT 1
79286: ARRAY
79287: PPUSH
79288: CALL_OW 251
79292: PPUSH
79293: LD_VAR 0 15
79297: PUSH
79298: LD_INT 1
79300: ARRAY
79301: PPUSH
79302: CALL_OW 254
79306: PPUSH
79307: LD_INT 5
79309: PPUSH
79310: CALL_OW 273
79314: PUSH
79315: EMPTY
79316: LIST
79317: LIST
79318: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
79319: LD_VAR 0 14
79323: PUSH
79324: LD_INT 1
79326: ARRAY
79327: PPUSH
79328: LD_VAR 0 14
79332: PUSH
79333: LD_INT 2
79335: ARRAY
79336: PPUSH
79337: CALL_OW 488
79341: IFFALSE 79372
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
79343: LD_VAR 0 11
79347: PPUSH
79348: LD_VAR 0 14
79352: PUSH
79353: LD_INT 1
79355: ARRAY
79356: PPUSH
79357: LD_VAR 0 14
79361: PUSH
79362: LD_INT 2
79364: ARRAY
79365: PPUSH
79366: CALL_OW 111
// continue ;
79370: GO 79003
// end ; end ; r := GetDir ( tmp ) ;
79372: LD_ADDR_VAR 0 13
79376: PUSH
79377: LD_VAR 0 11
79381: PPUSH
79382: CALL_OW 254
79386: ST_TO_ADDR
// if r = 5 then
79387: LD_VAR 0 13
79391: PUSH
79392: LD_INT 5
79394: EQUAL
79395: IFFALSE 79405
// r := 0 ;
79397: LD_ADDR_VAR 0 13
79401: PUSH
79402: LD_INT 0
79404: ST_TO_ADDR
// for j = r to 5 do
79405: LD_ADDR_VAR 0 8
79409: PUSH
79410: DOUBLE
79411: LD_VAR 0 13
79415: DEC
79416: ST_TO_ADDR
79417: LD_INT 5
79419: PUSH
79420: FOR_TO
79421: IFFALSE 79535
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
79423: LD_ADDR_VAR 0 9
79427: PUSH
79428: LD_VAR 0 11
79432: PPUSH
79433: CALL_OW 250
79437: PPUSH
79438: LD_VAR 0 8
79442: PPUSH
79443: LD_INT 2
79445: PPUSH
79446: CALL_OW 272
79450: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
79451: LD_ADDR_VAR 0 10
79455: PUSH
79456: LD_VAR 0 11
79460: PPUSH
79461: CALL_OW 251
79465: PPUSH
79466: LD_VAR 0 8
79470: PPUSH
79471: LD_INT 2
79473: PPUSH
79474: CALL_OW 273
79478: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
79479: LD_VAR 0 9
79483: PPUSH
79484: LD_VAR 0 10
79488: PPUSH
79489: CALL_OW 488
79493: PUSH
79494: LD_VAR 0 9
79498: PPUSH
79499: LD_VAR 0 10
79503: PPUSH
79504: CALL_OW 428
79508: NOT
79509: AND
79510: IFFALSE 79533
// begin ComMoveXY ( tmp , _x , _y ) ;
79512: LD_VAR 0 11
79516: PPUSH
79517: LD_VAR 0 9
79521: PPUSH
79522: LD_VAR 0 10
79526: PPUSH
79527: CALL_OW 111
// break ;
79531: GO 79535
// end ; end ;
79533: GO 79420
79535: POP
79536: POP
// end ;
79537: GO 79003
79539: POP
79540: POP
// end ;
79541: LD_VAR 0 6
79545: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
79546: LD_INT 0
79548: PPUSH
79549: PPUSH
79550: PPUSH
79551: PPUSH
79552: PPUSH
79553: PPUSH
79554: PPUSH
79555: PPUSH
79556: PPUSH
79557: PPUSH
// result := false ;
79558: LD_ADDR_VAR 0 6
79562: PUSH
79563: LD_INT 0
79565: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
79566: LD_VAR 0 1
79570: NOT
79571: PUSH
79572: LD_VAR 0 1
79576: PPUSH
79577: CALL_OW 266
79581: PUSH
79582: LD_INT 0
79584: PUSH
79585: LD_INT 1
79587: PUSH
79588: EMPTY
79589: LIST
79590: LIST
79591: IN
79592: NOT
79593: OR
79594: PUSH
79595: LD_VAR 0 2
79599: NOT
79600: OR
79601: PUSH
79602: LD_VAR 0 5
79606: PUSH
79607: LD_INT 0
79609: PUSH
79610: LD_INT 1
79612: PUSH
79613: LD_INT 2
79615: PUSH
79616: LD_INT 3
79618: PUSH
79619: LD_INT 4
79621: PUSH
79622: LD_INT 5
79624: PUSH
79625: EMPTY
79626: LIST
79627: LIST
79628: LIST
79629: LIST
79630: LIST
79631: LIST
79632: IN
79633: NOT
79634: OR
79635: PUSH
79636: LD_VAR 0 3
79640: PPUSH
79641: LD_VAR 0 4
79645: PPUSH
79646: CALL_OW 488
79650: NOT
79651: OR
79652: IFFALSE 79656
// exit ;
79654: GO 80373
// pom := GetBase ( depot ) ;
79656: LD_ADDR_VAR 0 10
79660: PUSH
79661: LD_VAR 0 1
79665: PPUSH
79666: CALL_OW 274
79670: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
79671: LD_ADDR_VAR 0 11
79675: PUSH
79676: LD_VAR 0 2
79680: PPUSH
79681: LD_VAR 0 1
79685: PPUSH
79686: CALL_OW 248
79690: PPUSH
79691: CALL_OW 450
79695: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
79696: LD_VAR 0 10
79700: PPUSH
79701: LD_INT 1
79703: PPUSH
79704: CALL_OW 275
79708: PUSH
79709: LD_VAR 0 11
79713: PUSH
79714: LD_INT 1
79716: ARRAY
79717: GREATEREQUAL
79718: PUSH
79719: LD_VAR 0 10
79723: PPUSH
79724: LD_INT 2
79726: PPUSH
79727: CALL_OW 275
79731: PUSH
79732: LD_VAR 0 11
79736: PUSH
79737: LD_INT 2
79739: ARRAY
79740: GREATEREQUAL
79741: AND
79742: PUSH
79743: LD_VAR 0 10
79747: PPUSH
79748: LD_INT 3
79750: PPUSH
79751: CALL_OW 275
79755: PUSH
79756: LD_VAR 0 11
79760: PUSH
79761: LD_INT 3
79763: ARRAY
79764: GREATEREQUAL
79765: AND
79766: NOT
79767: IFFALSE 79771
// exit ;
79769: GO 80373
// if GetBType ( depot ) = b_depot then
79771: LD_VAR 0 1
79775: PPUSH
79776: CALL_OW 266
79780: PUSH
79781: LD_INT 0
79783: EQUAL
79784: IFFALSE 79796
// dist := 28 else
79786: LD_ADDR_VAR 0 14
79790: PUSH
79791: LD_INT 28
79793: ST_TO_ADDR
79794: GO 79804
// dist := 36 ;
79796: LD_ADDR_VAR 0 14
79800: PUSH
79801: LD_INT 36
79803: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
79804: LD_VAR 0 1
79808: PPUSH
79809: LD_VAR 0 3
79813: PPUSH
79814: LD_VAR 0 4
79818: PPUSH
79819: CALL_OW 297
79823: PUSH
79824: LD_VAR 0 14
79828: GREATER
79829: IFFALSE 79833
// exit ;
79831: GO 80373
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
79833: LD_ADDR_VAR 0 12
79837: PUSH
79838: LD_VAR 0 2
79842: PPUSH
79843: LD_VAR 0 3
79847: PPUSH
79848: LD_VAR 0 4
79852: PPUSH
79853: LD_VAR 0 5
79857: PPUSH
79858: LD_VAR 0 1
79862: PPUSH
79863: CALL_OW 248
79867: PPUSH
79868: LD_INT 0
79870: PPUSH
79871: CALL 80378 0 6
79875: ST_TO_ADDR
// if not hexes then
79876: LD_VAR 0 12
79880: NOT
79881: IFFALSE 79885
// exit ;
79883: GO 80373
// hex := GetHexInfo ( x , y ) ;
79885: LD_ADDR_VAR 0 15
79889: PUSH
79890: LD_VAR 0 3
79894: PPUSH
79895: LD_VAR 0 4
79899: PPUSH
79900: CALL_OW 546
79904: ST_TO_ADDR
// if hex [ 1 ] then
79905: LD_VAR 0 15
79909: PUSH
79910: LD_INT 1
79912: ARRAY
79913: IFFALSE 79917
// exit ;
79915: GO 80373
// height := hex [ 2 ] ;
79917: LD_ADDR_VAR 0 13
79921: PUSH
79922: LD_VAR 0 15
79926: PUSH
79927: LD_INT 2
79929: ARRAY
79930: ST_TO_ADDR
// for i = 1 to hexes do
79931: LD_ADDR_VAR 0 7
79935: PUSH
79936: DOUBLE
79937: LD_INT 1
79939: DEC
79940: ST_TO_ADDR
79941: LD_VAR 0 12
79945: PUSH
79946: FOR_TO
79947: IFFALSE 80277
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79949: LD_VAR 0 12
79953: PUSH
79954: LD_VAR 0 7
79958: ARRAY
79959: PUSH
79960: LD_INT 1
79962: ARRAY
79963: PPUSH
79964: LD_VAR 0 12
79968: PUSH
79969: LD_VAR 0 7
79973: ARRAY
79974: PUSH
79975: LD_INT 2
79977: ARRAY
79978: PPUSH
79979: CALL_OW 488
79983: NOT
79984: PUSH
79985: LD_VAR 0 12
79989: PUSH
79990: LD_VAR 0 7
79994: ARRAY
79995: PUSH
79996: LD_INT 1
79998: ARRAY
79999: PPUSH
80000: LD_VAR 0 12
80004: PUSH
80005: LD_VAR 0 7
80009: ARRAY
80010: PUSH
80011: LD_INT 2
80013: ARRAY
80014: PPUSH
80015: CALL_OW 428
80019: PUSH
80020: LD_INT 0
80022: GREATER
80023: OR
80024: PUSH
80025: LD_VAR 0 12
80029: PUSH
80030: LD_VAR 0 7
80034: ARRAY
80035: PUSH
80036: LD_INT 1
80038: ARRAY
80039: PPUSH
80040: LD_VAR 0 12
80044: PUSH
80045: LD_VAR 0 7
80049: ARRAY
80050: PUSH
80051: LD_INT 2
80053: ARRAY
80054: PPUSH
80055: CALL_OW 351
80059: OR
80060: IFFALSE 80066
// exit ;
80062: POP
80063: POP
80064: GO 80373
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
80066: LD_ADDR_VAR 0 8
80070: PUSH
80071: LD_VAR 0 12
80075: PUSH
80076: LD_VAR 0 7
80080: ARRAY
80081: PUSH
80082: LD_INT 1
80084: ARRAY
80085: PPUSH
80086: LD_VAR 0 12
80090: PUSH
80091: LD_VAR 0 7
80095: ARRAY
80096: PUSH
80097: LD_INT 2
80099: ARRAY
80100: PPUSH
80101: CALL_OW 546
80105: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
80106: LD_VAR 0 8
80110: PUSH
80111: LD_INT 1
80113: ARRAY
80114: PUSH
80115: LD_VAR 0 8
80119: PUSH
80120: LD_INT 2
80122: ARRAY
80123: PUSH
80124: LD_VAR 0 13
80128: PUSH
80129: LD_INT 2
80131: PLUS
80132: GREATER
80133: OR
80134: PUSH
80135: LD_VAR 0 8
80139: PUSH
80140: LD_INT 2
80142: ARRAY
80143: PUSH
80144: LD_VAR 0 13
80148: PUSH
80149: LD_INT 2
80151: MINUS
80152: LESS
80153: OR
80154: PUSH
80155: LD_VAR 0 8
80159: PUSH
80160: LD_INT 3
80162: ARRAY
80163: PUSH
80164: LD_INT 0
80166: PUSH
80167: LD_INT 8
80169: PUSH
80170: LD_INT 9
80172: PUSH
80173: LD_INT 10
80175: PUSH
80176: LD_INT 11
80178: PUSH
80179: LD_INT 12
80181: PUSH
80182: LD_INT 13
80184: PUSH
80185: LD_INT 16
80187: PUSH
80188: LD_INT 17
80190: PUSH
80191: LD_INT 18
80193: PUSH
80194: LD_INT 19
80196: PUSH
80197: LD_INT 20
80199: PUSH
80200: LD_INT 21
80202: PUSH
80203: EMPTY
80204: LIST
80205: LIST
80206: LIST
80207: LIST
80208: LIST
80209: LIST
80210: LIST
80211: LIST
80212: LIST
80213: LIST
80214: LIST
80215: LIST
80216: LIST
80217: IN
80218: NOT
80219: OR
80220: PUSH
80221: LD_VAR 0 8
80225: PUSH
80226: LD_INT 5
80228: ARRAY
80229: NOT
80230: OR
80231: PUSH
80232: LD_VAR 0 8
80236: PUSH
80237: LD_INT 6
80239: ARRAY
80240: PUSH
80241: LD_INT 1
80243: PUSH
80244: LD_INT 2
80246: PUSH
80247: LD_INT 7
80249: PUSH
80250: LD_INT 9
80252: PUSH
80253: LD_INT 10
80255: PUSH
80256: LD_INT 11
80258: PUSH
80259: EMPTY
80260: LIST
80261: LIST
80262: LIST
80263: LIST
80264: LIST
80265: LIST
80266: IN
80267: NOT
80268: OR
80269: IFFALSE 80275
// exit ;
80271: POP
80272: POP
80273: GO 80373
// end ;
80275: GO 79946
80277: POP
80278: POP
// side := GetSide ( depot ) ;
80279: LD_ADDR_VAR 0 9
80283: PUSH
80284: LD_VAR 0 1
80288: PPUSH
80289: CALL_OW 255
80293: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
80294: LD_VAR 0 9
80298: PPUSH
80299: LD_VAR 0 3
80303: PPUSH
80304: LD_VAR 0 4
80308: PPUSH
80309: LD_INT 20
80311: PPUSH
80312: CALL 73027 0 4
80316: PUSH
80317: LD_INT 4
80319: ARRAY
80320: IFFALSE 80324
// exit ;
80322: GO 80373
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
80324: LD_VAR 0 2
80328: PUSH
80329: LD_INT 29
80331: PUSH
80332: LD_INT 30
80334: PUSH
80335: EMPTY
80336: LIST
80337: LIST
80338: IN
80339: PUSH
80340: LD_VAR 0 3
80344: PPUSH
80345: LD_VAR 0 4
80349: PPUSH
80350: LD_VAR 0 9
80354: PPUSH
80355: CALL_OW 440
80359: NOT
80360: AND
80361: IFFALSE 80365
// exit ;
80363: GO 80373
// result := true ;
80365: LD_ADDR_VAR 0 6
80369: PUSH
80370: LD_INT 1
80372: ST_TO_ADDR
// end ;
80373: LD_VAR 0 6
80377: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
80378: LD_INT 0
80380: PPUSH
80381: PPUSH
80382: PPUSH
80383: PPUSH
80384: PPUSH
80385: PPUSH
80386: PPUSH
80387: PPUSH
80388: PPUSH
80389: PPUSH
80390: PPUSH
80391: PPUSH
80392: PPUSH
80393: PPUSH
80394: PPUSH
80395: PPUSH
80396: PPUSH
80397: PPUSH
80398: PPUSH
80399: PPUSH
80400: PPUSH
80401: PPUSH
80402: PPUSH
80403: PPUSH
80404: PPUSH
80405: PPUSH
80406: PPUSH
80407: PPUSH
80408: PPUSH
80409: PPUSH
80410: PPUSH
80411: PPUSH
80412: PPUSH
80413: PPUSH
80414: PPUSH
80415: PPUSH
80416: PPUSH
80417: PPUSH
80418: PPUSH
80419: PPUSH
80420: PPUSH
80421: PPUSH
80422: PPUSH
80423: PPUSH
80424: PPUSH
80425: PPUSH
80426: PPUSH
80427: PPUSH
80428: PPUSH
80429: PPUSH
80430: PPUSH
80431: PPUSH
80432: PPUSH
80433: PPUSH
80434: PPUSH
80435: PPUSH
80436: PPUSH
80437: PPUSH
// result = [ ] ;
80438: LD_ADDR_VAR 0 7
80442: PUSH
80443: EMPTY
80444: ST_TO_ADDR
// temp_list = [ ] ;
80445: LD_ADDR_VAR 0 9
80449: PUSH
80450: EMPTY
80451: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
80452: LD_VAR 0 4
80456: PUSH
80457: LD_INT 0
80459: PUSH
80460: LD_INT 1
80462: PUSH
80463: LD_INT 2
80465: PUSH
80466: LD_INT 3
80468: PUSH
80469: LD_INT 4
80471: PUSH
80472: LD_INT 5
80474: PUSH
80475: EMPTY
80476: LIST
80477: LIST
80478: LIST
80479: LIST
80480: LIST
80481: LIST
80482: IN
80483: NOT
80484: PUSH
80485: LD_VAR 0 1
80489: PUSH
80490: LD_INT 0
80492: PUSH
80493: LD_INT 1
80495: PUSH
80496: EMPTY
80497: LIST
80498: LIST
80499: IN
80500: PUSH
80501: LD_VAR 0 5
80505: PUSH
80506: LD_INT 1
80508: PUSH
80509: LD_INT 2
80511: PUSH
80512: LD_INT 3
80514: PUSH
80515: EMPTY
80516: LIST
80517: LIST
80518: LIST
80519: IN
80520: NOT
80521: AND
80522: OR
80523: IFFALSE 80527
// exit ;
80525: GO 98918
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
80527: LD_VAR 0 1
80531: PUSH
80532: LD_INT 6
80534: PUSH
80535: LD_INT 7
80537: PUSH
80538: LD_INT 8
80540: PUSH
80541: LD_INT 13
80543: PUSH
80544: LD_INT 12
80546: PUSH
80547: LD_INT 15
80549: PUSH
80550: LD_INT 11
80552: PUSH
80553: LD_INT 14
80555: PUSH
80556: LD_INT 10
80558: PUSH
80559: EMPTY
80560: LIST
80561: LIST
80562: LIST
80563: LIST
80564: LIST
80565: LIST
80566: LIST
80567: LIST
80568: LIST
80569: IN
80570: IFFALSE 80580
// btype = b_lab ;
80572: LD_ADDR_VAR 0 1
80576: PUSH
80577: LD_INT 6
80579: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
80580: LD_VAR 0 6
80584: PUSH
80585: LD_INT 0
80587: PUSH
80588: LD_INT 1
80590: PUSH
80591: LD_INT 2
80593: PUSH
80594: EMPTY
80595: LIST
80596: LIST
80597: LIST
80598: IN
80599: NOT
80600: PUSH
80601: LD_VAR 0 1
80605: PUSH
80606: LD_INT 0
80608: PUSH
80609: LD_INT 1
80611: PUSH
80612: LD_INT 2
80614: PUSH
80615: LD_INT 3
80617: PUSH
80618: LD_INT 6
80620: PUSH
80621: LD_INT 36
80623: PUSH
80624: LD_INT 4
80626: PUSH
80627: LD_INT 5
80629: PUSH
80630: LD_INT 31
80632: PUSH
80633: LD_INT 32
80635: PUSH
80636: LD_INT 33
80638: PUSH
80639: EMPTY
80640: LIST
80641: LIST
80642: LIST
80643: LIST
80644: LIST
80645: LIST
80646: LIST
80647: LIST
80648: LIST
80649: LIST
80650: LIST
80651: IN
80652: NOT
80653: PUSH
80654: LD_VAR 0 6
80658: PUSH
80659: LD_INT 1
80661: EQUAL
80662: AND
80663: OR
80664: PUSH
80665: LD_VAR 0 1
80669: PUSH
80670: LD_INT 2
80672: PUSH
80673: LD_INT 3
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: IN
80680: NOT
80681: PUSH
80682: LD_VAR 0 6
80686: PUSH
80687: LD_INT 2
80689: EQUAL
80690: AND
80691: OR
80692: IFFALSE 80702
// mode = 0 ;
80694: LD_ADDR_VAR 0 6
80698: PUSH
80699: LD_INT 0
80701: ST_TO_ADDR
// case mode of 0 :
80702: LD_VAR 0 6
80706: PUSH
80707: LD_INT 0
80709: DOUBLE
80710: EQUAL
80711: IFTRUE 80715
80713: GO 92168
80715: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80716: LD_ADDR_VAR 0 11
80720: PUSH
80721: LD_INT 0
80723: PUSH
80724: LD_INT 0
80726: PUSH
80727: EMPTY
80728: LIST
80729: LIST
80730: PUSH
80731: LD_INT 0
80733: PUSH
80734: LD_INT 1
80736: NEG
80737: PUSH
80738: EMPTY
80739: LIST
80740: LIST
80741: PUSH
80742: LD_INT 1
80744: PUSH
80745: LD_INT 0
80747: PUSH
80748: EMPTY
80749: LIST
80750: LIST
80751: PUSH
80752: LD_INT 1
80754: PUSH
80755: LD_INT 1
80757: PUSH
80758: EMPTY
80759: LIST
80760: LIST
80761: PUSH
80762: LD_INT 0
80764: PUSH
80765: LD_INT 1
80767: PUSH
80768: EMPTY
80769: LIST
80770: LIST
80771: PUSH
80772: LD_INT 1
80774: NEG
80775: PUSH
80776: LD_INT 0
80778: PUSH
80779: EMPTY
80780: LIST
80781: LIST
80782: PUSH
80783: LD_INT 1
80785: NEG
80786: PUSH
80787: LD_INT 1
80789: NEG
80790: PUSH
80791: EMPTY
80792: LIST
80793: LIST
80794: PUSH
80795: LD_INT 1
80797: NEG
80798: PUSH
80799: LD_INT 2
80801: NEG
80802: PUSH
80803: EMPTY
80804: LIST
80805: LIST
80806: PUSH
80807: LD_INT 0
80809: PUSH
80810: LD_INT 2
80812: NEG
80813: PUSH
80814: EMPTY
80815: LIST
80816: LIST
80817: PUSH
80818: LD_INT 1
80820: PUSH
80821: LD_INT 1
80823: NEG
80824: PUSH
80825: EMPTY
80826: LIST
80827: LIST
80828: PUSH
80829: LD_INT 1
80831: PUSH
80832: LD_INT 2
80834: PUSH
80835: EMPTY
80836: LIST
80837: LIST
80838: PUSH
80839: LD_INT 0
80841: PUSH
80842: LD_INT 2
80844: PUSH
80845: EMPTY
80846: LIST
80847: LIST
80848: PUSH
80849: LD_INT 1
80851: NEG
80852: PUSH
80853: LD_INT 1
80855: PUSH
80856: EMPTY
80857: LIST
80858: LIST
80859: PUSH
80860: LD_INT 1
80862: PUSH
80863: LD_INT 3
80865: PUSH
80866: EMPTY
80867: LIST
80868: LIST
80869: PUSH
80870: LD_INT 0
80872: PUSH
80873: LD_INT 3
80875: PUSH
80876: EMPTY
80877: LIST
80878: LIST
80879: PUSH
80880: LD_INT 1
80882: NEG
80883: PUSH
80884: LD_INT 2
80886: PUSH
80887: EMPTY
80888: LIST
80889: LIST
80890: PUSH
80891: EMPTY
80892: LIST
80893: LIST
80894: LIST
80895: LIST
80896: LIST
80897: LIST
80898: LIST
80899: LIST
80900: LIST
80901: LIST
80902: LIST
80903: LIST
80904: LIST
80905: LIST
80906: LIST
80907: LIST
80908: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80909: LD_ADDR_VAR 0 12
80913: PUSH
80914: LD_INT 0
80916: PUSH
80917: LD_INT 0
80919: PUSH
80920: EMPTY
80921: LIST
80922: LIST
80923: PUSH
80924: LD_INT 0
80926: PUSH
80927: LD_INT 1
80929: NEG
80930: PUSH
80931: EMPTY
80932: LIST
80933: LIST
80934: PUSH
80935: LD_INT 1
80937: PUSH
80938: LD_INT 0
80940: PUSH
80941: EMPTY
80942: LIST
80943: LIST
80944: PUSH
80945: LD_INT 1
80947: PUSH
80948: LD_INT 1
80950: PUSH
80951: EMPTY
80952: LIST
80953: LIST
80954: PUSH
80955: LD_INT 0
80957: PUSH
80958: LD_INT 1
80960: PUSH
80961: EMPTY
80962: LIST
80963: LIST
80964: PUSH
80965: LD_INT 1
80967: NEG
80968: PUSH
80969: LD_INT 0
80971: PUSH
80972: EMPTY
80973: LIST
80974: LIST
80975: PUSH
80976: LD_INT 1
80978: NEG
80979: PUSH
80980: LD_INT 1
80982: NEG
80983: PUSH
80984: EMPTY
80985: LIST
80986: LIST
80987: PUSH
80988: LD_INT 1
80990: PUSH
80991: LD_INT 1
80993: NEG
80994: PUSH
80995: EMPTY
80996: LIST
80997: LIST
80998: PUSH
80999: LD_INT 2
81001: PUSH
81002: LD_INT 0
81004: PUSH
81005: EMPTY
81006: LIST
81007: LIST
81008: PUSH
81009: LD_INT 2
81011: PUSH
81012: LD_INT 1
81014: PUSH
81015: EMPTY
81016: LIST
81017: LIST
81018: PUSH
81019: LD_INT 1
81021: NEG
81022: PUSH
81023: LD_INT 1
81025: PUSH
81026: EMPTY
81027: LIST
81028: LIST
81029: PUSH
81030: LD_INT 2
81032: NEG
81033: PUSH
81034: LD_INT 0
81036: PUSH
81037: EMPTY
81038: LIST
81039: LIST
81040: PUSH
81041: LD_INT 2
81043: NEG
81044: PUSH
81045: LD_INT 1
81047: NEG
81048: PUSH
81049: EMPTY
81050: LIST
81051: LIST
81052: PUSH
81053: LD_INT 2
81055: NEG
81056: PUSH
81057: LD_INT 1
81059: PUSH
81060: EMPTY
81061: LIST
81062: LIST
81063: PUSH
81064: LD_INT 3
81066: NEG
81067: PUSH
81068: LD_INT 0
81070: PUSH
81071: EMPTY
81072: LIST
81073: LIST
81074: PUSH
81075: LD_INT 3
81077: NEG
81078: PUSH
81079: LD_INT 1
81081: NEG
81082: PUSH
81083: EMPTY
81084: LIST
81085: LIST
81086: PUSH
81087: EMPTY
81088: LIST
81089: LIST
81090: LIST
81091: LIST
81092: LIST
81093: LIST
81094: LIST
81095: LIST
81096: LIST
81097: LIST
81098: LIST
81099: LIST
81100: LIST
81101: LIST
81102: LIST
81103: LIST
81104: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81105: LD_ADDR_VAR 0 13
81109: PUSH
81110: LD_INT 0
81112: PUSH
81113: LD_INT 0
81115: PUSH
81116: EMPTY
81117: LIST
81118: LIST
81119: PUSH
81120: LD_INT 0
81122: PUSH
81123: LD_INT 1
81125: NEG
81126: PUSH
81127: EMPTY
81128: LIST
81129: LIST
81130: PUSH
81131: LD_INT 1
81133: PUSH
81134: LD_INT 0
81136: PUSH
81137: EMPTY
81138: LIST
81139: LIST
81140: PUSH
81141: LD_INT 1
81143: PUSH
81144: LD_INT 1
81146: PUSH
81147: EMPTY
81148: LIST
81149: LIST
81150: PUSH
81151: LD_INT 0
81153: PUSH
81154: LD_INT 1
81156: PUSH
81157: EMPTY
81158: LIST
81159: LIST
81160: PUSH
81161: LD_INT 1
81163: NEG
81164: PUSH
81165: LD_INT 0
81167: PUSH
81168: EMPTY
81169: LIST
81170: LIST
81171: PUSH
81172: LD_INT 1
81174: NEG
81175: PUSH
81176: LD_INT 1
81178: NEG
81179: PUSH
81180: EMPTY
81181: LIST
81182: LIST
81183: PUSH
81184: LD_INT 1
81186: NEG
81187: PUSH
81188: LD_INT 2
81190: NEG
81191: PUSH
81192: EMPTY
81193: LIST
81194: LIST
81195: PUSH
81196: LD_INT 2
81198: PUSH
81199: LD_INT 1
81201: PUSH
81202: EMPTY
81203: LIST
81204: LIST
81205: PUSH
81206: LD_INT 2
81208: PUSH
81209: LD_INT 2
81211: PUSH
81212: EMPTY
81213: LIST
81214: LIST
81215: PUSH
81216: LD_INT 1
81218: PUSH
81219: LD_INT 2
81221: PUSH
81222: EMPTY
81223: LIST
81224: LIST
81225: PUSH
81226: LD_INT 2
81228: NEG
81229: PUSH
81230: LD_INT 1
81232: NEG
81233: PUSH
81234: EMPTY
81235: LIST
81236: LIST
81237: PUSH
81238: LD_INT 2
81240: NEG
81241: PUSH
81242: LD_INT 2
81244: NEG
81245: PUSH
81246: EMPTY
81247: LIST
81248: LIST
81249: PUSH
81250: LD_INT 2
81252: NEG
81253: PUSH
81254: LD_INT 3
81256: NEG
81257: PUSH
81258: EMPTY
81259: LIST
81260: LIST
81261: PUSH
81262: LD_INT 3
81264: NEG
81265: PUSH
81266: LD_INT 2
81268: NEG
81269: PUSH
81270: EMPTY
81271: LIST
81272: LIST
81273: PUSH
81274: LD_INT 3
81276: NEG
81277: PUSH
81278: LD_INT 3
81280: NEG
81281: PUSH
81282: EMPTY
81283: LIST
81284: LIST
81285: PUSH
81286: EMPTY
81287: LIST
81288: LIST
81289: LIST
81290: LIST
81291: LIST
81292: LIST
81293: LIST
81294: LIST
81295: LIST
81296: LIST
81297: LIST
81298: LIST
81299: LIST
81300: LIST
81301: LIST
81302: LIST
81303: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
81304: LD_ADDR_VAR 0 14
81308: PUSH
81309: LD_INT 0
81311: PUSH
81312: LD_INT 0
81314: PUSH
81315: EMPTY
81316: LIST
81317: LIST
81318: PUSH
81319: LD_INT 0
81321: PUSH
81322: LD_INT 1
81324: NEG
81325: PUSH
81326: EMPTY
81327: LIST
81328: LIST
81329: PUSH
81330: LD_INT 1
81332: PUSH
81333: LD_INT 0
81335: PUSH
81336: EMPTY
81337: LIST
81338: LIST
81339: PUSH
81340: LD_INT 1
81342: PUSH
81343: LD_INT 1
81345: PUSH
81346: EMPTY
81347: LIST
81348: LIST
81349: PUSH
81350: LD_INT 0
81352: PUSH
81353: LD_INT 1
81355: PUSH
81356: EMPTY
81357: LIST
81358: LIST
81359: PUSH
81360: LD_INT 1
81362: NEG
81363: PUSH
81364: LD_INT 0
81366: PUSH
81367: EMPTY
81368: LIST
81369: LIST
81370: PUSH
81371: LD_INT 1
81373: NEG
81374: PUSH
81375: LD_INT 1
81377: NEG
81378: PUSH
81379: EMPTY
81380: LIST
81381: LIST
81382: PUSH
81383: LD_INT 1
81385: NEG
81386: PUSH
81387: LD_INT 2
81389: NEG
81390: PUSH
81391: EMPTY
81392: LIST
81393: LIST
81394: PUSH
81395: LD_INT 0
81397: PUSH
81398: LD_INT 2
81400: NEG
81401: PUSH
81402: EMPTY
81403: LIST
81404: LIST
81405: PUSH
81406: LD_INT 1
81408: PUSH
81409: LD_INT 1
81411: NEG
81412: PUSH
81413: EMPTY
81414: LIST
81415: LIST
81416: PUSH
81417: LD_INT 1
81419: PUSH
81420: LD_INT 2
81422: PUSH
81423: EMPTY
81424: LIST
81425: LIST
81426: PUSH
81427: LD_INT 0
81429: PUSH
81430: LD_INT 2
81432: PUSH
81433: EMPTY
81434: LIST
81435: LIST
81436: PUSH
81437: LD_INT 1
81439: NEG
81440: PUSH
81441: LD_INT 1
81443: PUSH
81444: EMPTY
81445: LIST
81446: LIST
81447: PUSH
81448: LD_INT 1
81450: NEG
81451: PUSH
81452: LD_INT 3
81454: NEG
81455: PUSH
81456: EMPTY
81457: LIST
81458: LIST
81459: PUSH
81460: LD_INT 0
81462: PUSH
81463: LD_INT 3
81465: NEG
81466: PUSH
81467: EMPTY
81468: LIST
81469: LIST
81470: PUSH
81471: LD_INT 1
81473: PUSH
81474: LD_INT 2
81476: NEG
81477: PUSH
81478: EMPTY
81479: LIST
81480: LIST
81481: PUSH
81482: EMPTY
81483: LIST
81484: LIST
81485: LIST
81486: LIST
81487: LIST
81488: LIST
81489: LIST
81490: LIST
81491: LIST
81492: LIST
81493: LIST
81494: LIST
81495: LIST
81496: LIST
81497: LIST
81498: LIST
81499: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
81500: LD_ADDR_VAR 0 15
81504: PUSH
81505: LD_INT 0
81507: PUSH
81508: LD_INT 0
81510: PUSH
81511: EMPTY
81512: LIST
81513: LIST
81514: PUSH
81515: LD_INT 0
81517: PUSH
81518: LD_INT 1
81520: NEG
81521: PUSH
81522: EMPTY
81523: LIST
81524: LIST
81525: PUSH
81526: LD_INT 1
81528: PUSH
81529: LD_INT 0
81531: PUSH
81532: EMPTY
81533: LIST
81534: LIST
81535: PUSH
81536: LD_INT 1
81538: PUSH
81539: LD_INT 1
81541: PUSH
81542: EMPTY
81543: LIST
81544: LIST
81545: PUSH
81546: LD_INT 0
81548: PUSH
81549: LD_INT 1
81551: PUSH
81552: EMPTY
81553: LIST
81554: LIST
81555: PUSH
81556: LD_INT 1
81558: NEG
81559: PUSH
81560: LD_INT 0
81562: PUSH
81563: EMPTY
81564: LIST
81565: LIST
81566: PUSH
81567: LD_INT 1
81569: NEG
81570: PUSH
81571: LD_INT 1
81573: NEG
81574: PUSH
81575: EMPTY
81576: LIST
81577: LIST
81578: PUSH
81579: LD_INT 1
81581: PUSH
81582: LD_INT 1
81584: NEG
81585: PUSH
81586: EMPTY
81587: LIST
81588: LIST
81589: PUSH
81590: LD_INT 2
81592: PUSH
81593: LD_INT 0
81595: PUSH
81596: EMPTY
81597: LIST
81598: LIST
81599: PUSH
81600: LD_INT 2
81602: PUSH
81603: LD_INT 1
81605: PUSH
81606: EMPTY
81607: LIST
81608: LIST
81609: PUSH
81610: LD_INT 1
81612: NEG
81613: PUSH
81614: LD_INT 1
81616: PUSH
81617: EMPTY
81618: LIST
81619: LIST
81620: PUSH
81621: LD_INT 2
81623: NEG
81624: PUSH
81625: LD_INT 0
81627: PUSH
81628: EMPTY
81629: LIST
81630: LIST
81631: PUSH
81632: LD_INT 2
81634: NEG
81635: PUSH
81636: LD_INT 1
81638: NEG
81639: PUSH
81640: EMPTY
81641: LIST
81642: LIST
81643: PUSH
81644: LD_INT 2
81646: PUSH
81647: LD_INT 1
81649: NEG
81650: PUSH
81651: EMPTY
81652: LIST
81653: LIST
81654: PUSH
81655: LD_INT 3
81657: PUSH
81658: LD_INT 0
81660: PUSH
81661: EMPTY
81662: LIST
81663: LIST
81664: PUSH
81665: LD_INT 3
81667: PUSH
81668: LD_INT 1
81670: PUSH
81671: EMPTY
81672: LIST
81673: LIST
81674: PUSH
81675: EMPTY
81676: LIST
81677: LIST
81678: LIST
81679: LIST
81680: LIST
81681: LIST
81682: LIST
81683: LIST
81684: LIST
81685: LIST
81686: LIST
81687: LIST
81688: LIST
81689: LIST
81690: LIST
81691: LIST
81692: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81693: LD_ADDR_VAR 0 16
81697: PUSH
81698: LD_INT 0
81700: PUSH
81701: LD_INT 0
81703: PUSH
81704: EMPTY
81705: LIST
81706: LIST
81707: PUSH
81708: LD_INT 0
81710: PUSH
81711: LD_INT 1
81713: NEG
81714: PUSH
81715: EMPTY
81716: LIST
81717: LIST
81718: PUSH
81719: LD_INT 1
81721: PUSH
81722: LD_INT 0
81724: PUSH
81725: EMPTY
81726: LIST
81727: LIST
81728: PUSH
81729: LD_INT 1
81731: PUSH
81732: LD_INT 1
81734: PUSH
81735: EMPTY
81736: LIST
81737: LIST
81738: PUSH
81739: LD_INT 0
81741: PUSH
81742: LD_INT 1
81744: PUSH
81745: EMPTY
81746: LIST
81747: LIST
81748: PUSH
81749: LD_INT 1
81751: NEG
81752: PUSH
81753: LD_INT 0
81755: PUSH
81756: EMPTY
81757: LIST
81758: LIST
81759: PUSH
81760: LD_INT 1
81762: NEG
81763: PUSH
81764: LD_INT 1
81766: NEG
81767: PUSH
81768: EMPTY
81769: LIST
81770: LIST
81771: PUSH
81772: LD_INT 1
81774: NEG
81775: PUSH
81776: LD_INT 2
81778: NEG
81779: PUSH
81780: EMPTY
81781: LIST
81782: LIST
81783: PUSH
81784: LD_INT 2
81786: PUSH
81787: LD_INT 1
81789: PUSH
81790: EMPTY
81791: LIST
81792: LIST
81793: PUSH
81794: LD_INT 2
81796: PUSH
81797: LD_INT 2
81799: PUSH
81800: EMPTY
81801: LIST
81802: LIST
81803: PUSH
81804: LD_INT 1
81806: PUSH
81807: LD_INT 2
81809: PUSH
81810: EMPTY
81811: LIST
81812: LIST
81813: PUSH
81814: LD_INT 2
81816: NEG
81817: PUSH
81818: LD_INT 1
81820: NEG
81821: PUSH
81822: EMPTY
81823: LIST
81824: LIST
81825: PUSH
81826: LD_INT 2
81828: NEG
81829: PUSH
81830: LD_INT 2
81832: NEG
81833: PUSH
81834: EMPTY
81835: LIST
81836: LIST
81837: PUSH
81838: LD_INT 3
81840: PUSH
81841: LD_INT 2
81843: PUSH
81844: EMPTY
81845: LIST
81846: LIST
81847: PUSH
81848: LD_INT 3
81850: PUSH
81851: LD_INT 3
81853: PUSH
81854: EMPTY
81855: LIST
81856: LIST
81857: PUSH
81858: LD_INT 2
81860: PUSH
81861: LD_INT 3
81863: PUSH
81864: EMPTY
81865: LIST
81866: LIST
81867: PUSH
81868: EMPTY
81869: LIST
81870: LIST
81871: LIST
81872: LIST
81873: LIST
81874: LIST
81875: LIST
81876: LIST
81877: LIST
81878: LIST
81879: LIST
81880: LIST
81881: LIST
81882: LIST
81883: LIST
81884: LIST
81885: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81886: LD_ADDR_VAR 0 17
81890: PUSH
81891: LD_INT 0
81893: PUSH
81894: LD_INT 0
81896: PUSH
81897: EMPTY
81898: LIST
81899: LIST
81900: PUSH
81901: LD_INT 0
81903: PUSH
81904: LD_INT 1
81906: NEG
81907: PUSH
81908: EMPTY
81909: LIST
81910: LIST
81911: PUSH
81912: LD_INT 1
81914: PUSH
81915: LD_INT 0
81917: PUSH
81918: EMPTY
81919: LIST
81920: LIST
81921: PUSH
81922: LD_INT 1
81924: PUSH
81925: LD_INT 1
81927: PUSH
81928: EMPTY
81929: LIST
81930: LIST
81931: PUSH
81932: LD_INT 0
81934: PUSH
81935: LD_INT 1
81937: PUSH
81938: EMPTY
81939: LIST
81940: LIST
81941: PUSH
81942: LD_INT 1
81944: NEG
81945: PUSH
81946: LD_INT 0
81948: PUSH
81949: EMPTY
81950: LIST
81951: LIST
81952: PUSH
81953: LD_INT 1
81955: NEG
81956: PUSH
81957: LD_INT 1
81959: NEG
81960: PUSH
81961: EMPTY
81962: LIST
81963: LIST
81964: PUSH
81965: LD_INT 1
81967: NEG
81968: PUSH
81969: LD_INT 2
81971: NEG
81972: PUSH
81973: EMPTY
81974: LIST
81975: LIST
81976: PUSH
81977: LD_INT 0
81979: PUSH
81980: LD_INT 2
81982: NEG
81983: PUSH
81984: EMPTY
81985: LIST
81986: LIST
81987: PUSH
81988: LD_INT 1
81990: PUSH
81991: LD_INT 1
81993: NEG
81994: PUSH
81995: EMPTY
81996: LIST
81997: LIST
81998: PUSH
81999: LD_INT 2
82001: PUSH
82002: LD_INT 0
82004: PUSH
82005: EMPTY
82006: LIST
82007: LIST
82008: PUSH
82009: LD_INT 2
82011: PUSH
82012: LD_INT 1
82014: PUSH
82015: EMPTY
82016: LIST
82017: LIST
82018: PUSH
82019: LD_INT 2
82021: PUSH
82022: LD_INT 2
82024: PUSH
82025: EMPTY
82026: LIST
82027: LIST
82028: PUSH
82029: LD_INT 1
82031: PUSH
82032: LD_INT 2
82034: PUSH
82035: EMPTY
82036: LIST
82037: LIST
82038: PUSH
82039: LD_INT 0
82041: PUSH
82042: LD_INT 2
82044: PUSH
82045: EMPTY
82046: LIST
82047: LIST
82048: PUSH
82049: LD_INT 1
82051: NEG
82052: PUSH
82053: LD_INT 1
82055: PUSH
82056: EMPTY
82057: LIST
82058: LIST
82059: PUSH
82060: LD_INT 2
82062: NEG
82063: PUSH
82064: LD_INT 0
82066: PUSH
82067: EMPTY
82068: LIST
82069: LIST
82070: PUSH
82071: LD_INT 2
82073: NEG
82074: PUSH
82075: LD_INT 1
82077: NEG
82078: PUSH
82079: EMPTY
82080: LIST
82081: LIST
82082: PUSH
82083: LD_INT 2
82085: NEG
82086: PUSH
82087: LD_INT 2
82089: NEG
82090: PUSH
82091: EMPTY
82092: LIST
82093: LIST
82094: PUSH
82095: EMPTY
82096: LIST
82097: LIST
82098: LIST
82099: LIST
82100: LIST
82101: LIST
82102: LIST
82103: LIST
82104: LIST
82105: LIST
82106: LIST
82107: LIST
82108: LIST
82109: LIST
82110: LIST
82111: LIST
82112: LIST
82113: LIST
82114: LIST
82115: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82116: LD_ADDR_VAR 0 18
82120: PUSH
82121: LD_INT 0
82123: PUSH
82124: LD_INT 0
82126: PUSH
82127: EMPTY
82128: LIST
82129: LIST
82130: PUSH
82131: LD_INT 0
82133: PUSH
82134: LD_INT 1
82136: NEG
82137: PUSH
82138: EMPTY
82139: LIST
82140: LIST
82141: PUSH
82142: LD_INT 1
82144: PUSH
82145: LD_INT 0
82147: PUSH
82148: EMPTY
82149: LIST
82150: LIST
82151: PUSH
82152: LD_INT 1
82154: PUSH
82155: LD_INT 1
82157: PUSH
82158: EMPTY
82159: LIST
82160: LIST
82161: PUSH
82162: LD_INT 0
82164: PUSH
82165: LD_INT 1
82167: PUSH
82168: EMPTY
82169: LIST
82170: LIST
82171: PUSH
82172: LD_INT 1
82174: NEG
82175: PUSH
82176: LD_INT 0
82178: PUSH
82179: EMPTY
82180: LIST
82181: LIST
82182: PUSH
82183: LD_INT 1
82185: NEG
82186: PUSH
82187: LD_INT 1
82189: NEG
82190: PUSH
82191: EMPTY
82192: LIST
82193: LIST
82194: PUSH
82195: LD_INT 1
82197: NEG
82198: PUSH
82199: LD_INT 2
82201: NEG
82202: PUSH
82203: EMPTY
82204: LIST
82205: LIST
82206: PUSH
82207: LD_INT 0
82209: PUSH
82210: LD_INT 2
82212: NEG
82213: PUSH
82214: EMPTY
82215: LIST
82216: LIST
82217: PUSH
82218: LD_INT 1
82220: PUSH
82221: LD_INT 1
82223: NEG
82224: PUSH
82225: EMPTY
82226: LIST
82227: LIST
82228: PUSH
82229: LD_INT 2
82231: PUSH
82232: LD_INT 0
82234: PUSH
82235: EMPTY
82236: LIST
82237: LIST
82238: PUSH
82239: LD_INT 2
82241: PUSH
82242: LD_INT 1
82244: PUSH
82245: EMPTY
82246: LIST
82247: LIST
82248: PUSH
82249: LD_INT 2
82251: PUSH
82252: LD_INT 2
82254: PUSH
82255: EMPTY
82256: LIST
82257: LIST
82258: PUSH
82259: LD_INT 1
82261: PUSH
82262: LD_INT 2
82264: PUSH
82265: EMPTY
82266: LIST
82267: LIST
82268: PUSH
82269: LD_INT 0
82271: PUSH
82272: LD_INT 2
82274: PUSH
82275: EMPTY
82276: LIST
82277: LIST
82278: PUSH
82279: LD_INT 1
82281: NEG
82282: PUSH
82283: LD_INT 1
82285: PUSH
82286: EMPTY
82287: LIST
82288: LIST
82289: PUSH
82290: LD_INT 2
82292: NEG
82293: PUSH
82294: LD_INT 0
82296: PUSH
82297: EMPTY
82298: LIST
82299: LIST
82300: PUSH
82301: LD_INT 2
82303: NEG
82304: PUSH
82305: LD_INT 1
82307: NEG
82308: PUSH
82309: EMPTY
82310: LIST
82311: LIST
82312: PUSH
82313: LD_INT 2
82315: NEG
82316: PUSH
82317: LD_INT 2
82319: NEG
82320: PUSH
82321: EMPTY
82322: LIST
82323: LIST
82324: PUSH
82325: EMPTY
82326: LIST
82327: LIST
82328: LIST
82329: LIST
82330: LIST
82331: LIST
82332: LIST
82333: LIST
82334: LIST
82335: LIST
82336: LIST
82337: LIST
82338: LIST
82339: LIST
82340: LIST
82341: LIST
82342: LIST
82343: LIST
82344: LIST
82345: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82346: LD_ADDR_VAR 0 19
82350: PUSH
82351: LD_INT 0
82353: PUSH
82354: LD_INT 0
82356: PUSH
82357: EMPTY
82358: LIST
82359: LIST
82360: PUSH
82361: LD_INT 0
82363: PUSH
82364: LD_INT 1
82366: NEG
82367: PUSH
82368: EMPTY
82369: LIST
82370: LIST
82371: PUSH
82372: LD_INT 1
82374: PUSH
82375: LD_INT 0
82377: PUSH
82378: EMPTY
82379: LIST
82380: LIST
82381: PUSH
82382: LD_INT 1
82384: PUSH
82385: LD_INT 1
82387: PUSH
82388: EMPTY
82389: LIST
82390: LIST
82391: PUSH
82392: LD_INT 0
82394: PUSH
82395: LD_INT 1
82397: PUSH
82398: EMPTY
82399: LIST
82400: LIST
82401: PUSH
82402: LD_INT 1
82404: NEG
82405: PUSH
82406: LD_INT 0
82408: PUSH
82409: EMPTY
82410: LIST
82411: LIST
82412: PUSH
82413: LD_INT 1
82415: NEG
82416: PUSH
82417: LD_INT 1
82419: NEG
82420: PUSH
82421: EMPTY
82422: LIST
82423: LIST
82424: PUSH
82425: LD_INT 1
82427: NEG
82428: PUSH
82429: LD_INT 2
82431: NEG
82432: PUSH
82433: EMPTY
82434: LIST
82435: LIST
82436: PUSH
82437: LD_INT 0
82439: PUSH
82440: LD_INT 2
82442: NEG
82443: PUSH
82444: EMPTY
82445: LIST
82446: LIST
82447: PUSH
82448: LD_INT 1
82450: PUSH
82451: LD_INT 1
82453: NEG
82454: PUSH
82455: EMPTY
82456: LIST
82457: LIST
82458: PUSH
82459: LD_INT 2
82461: PUSH
82462: LD_INT 0
82464: PUSH
82465: EMPTY
82466: LIST
82467: LIST
82468: PUSH
82469: LD_INT 2
82471: PUSH
82472: LD_INT 1
82474: PUSH
82475: EMPTY
82476: LIST
82477: LIST
82478: PUSH
82479: LD_INT 2
82481: PUSH
82482: LD_INT 2
82484: PUSH
82485: EMPTY
82486: LIST
82487: LIST
82488: PUSH
82489: LD_INT 1
82491: PUSH
82492: LD_INT 2
82494: PUSH
82495: EMPTY
82496: LIST
82497: LIST
82498: PUSH
82499: LD_INT 0
82501: PUSH
82502: LD_INT 2
82504: PUSH
82505: EMPTY
82506: LIST
82507: LIST
82508: PUSH
82509: LD_INT 1
82511: NEG
82512: PUSH
82513: LD_INT 1
82515: PUSH
82516: EMPTY
82517: LIST
82518: LIST
82519: PUSH
82520: LD_INT 2
82522: NEG
82523: PUSH
82524: LD_INT 0
82526: PUSH
82527: EMPTY
82528: LIST
82529: LIST
82530: PUSH
82531: LD_INT 2
82533: NEG
82534: PUSH
82535: LD_INT 1
82537: NEG
82538: PUSH
82539: EMPTY
82540: LIST
82541: LIST
82542: PUSH
82543: LD_INT 2
82545: NEG
82546: PUSH
82547: LD_INT 2
82549: NEG
82550: PUSH
82551: EMPTY
82552: LIST
82553: LIST
82554: PUSH
82555: EMPTY
82556: LIST
82557: LIST
82558: LIST
82559: LIST
82560: LIST
82561: LIST
82562: LIST
82563: LIST
82564: LIST
82565: LIST
82566: LIST
82567: LIST
82568: LIST
82569: LIST
82570: LIST
82571: LIST
82572: LIST
82573: LIST
82574: LIST
82575: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82576: LD_ADDR_VAR 0 20
82580: PUSH
82581: LD_INT 0
82583: PUSH
82584: LD_INT 0
82586: PUSH
82587: EMPTY
82588: LIST
82589: LIST
82590: PUSH
82591: LD_INT 0
82593: PUSH
82594: LD_INT 1
82596: NEG
82597: PUSH
82598: EMPTY
82599: LIST
82600: LIST
82601: PUSH
82602: LD_INT 1
82604: PUSH
82605: LD_INT 0
82607: PUSH
82608: EMPTY
82609: LIST
82610: LIST
82611: PUSH
82612: LD_INT 1
82614: PUSH
82615: LD_INT 1
82617: PUSH
82618: EMPTY
82619: LIST
82620: LIST
82621: PUSH
82622: LD_INT 0
82624: PUSH
82625: LD_INT 1
82627: PUSH
82628: EMPTY
82629: LIST
82630: LIST
82631: PUSH
82632: LD_INT 1
82634: NEG
82635: PUSH
82636: LD_INT 0
82638: PUSH
82639: EMPTY
82640: LIST
82641: LIST
82642: PUSH
82643: LD_INT 1
82645: NEG
82646: PUSH
82647: LD_INT 1
82649: NEG
82650: PUSH
82651: EMPTY
82652: LIST
82653: LIST
82654: PUSH
82655: LD_INT 1
82657: NEG
82658: PUSH
82659: LD_INT 2
82661: NEG
82662: PUSH
82663: EMPTY
82664: LIST
82665: LIST
82666: PUSH
82667: LD_INT 0
82669: PUSH
82670: LD_INT 2
82672: NEG
82673: PUSH
82674: EMPTY
82675: LIST
82676: LIST
82677: PUSH
82678: LD_INT 1
82680: PUSH
82681: LD_INT 1
82683: NEG
82684: PUSH
82685: EMPTY
82686: LIST
82687: LIST
82688: PUSH
82689: LD_INT 2
82691: PUSH
82692: LD_INT 0
82694: PUSH
82695: EMPTY
82696: LIST
82697: LIST
82698: PUSH
82699: LD_INT 2
82701: PUSH
82702: LD_INT 1
82704: PUSH
82705: EMPTY
82706: LIST
82707: LIST
82708: PUSH
82709: LD_INT 2
82711: PUSH
82712: LD_INT 2
82714: PUSH
82715: EMPTY
82716: LIST
82717: LIST
82718: PUSH
82719: LD_INT 1
82721: PUSH
82722: LD_INT 2
82724: PUSH
82725: EMPTY
82726: LIST
82727: LIST
82728: PUSH
82729: LD_INT 0
82731: PUSH
82732: LD_INT 2
82734: PUSH
82735: EMPTY
82736: LIST
82737: LIST
82738: PUSH
82739: LD_INT 1
82741: NEG
82742: PUSH
82743: LD_INT 1
82745: PUSH
82746: EMPTY
82747: LIST
82748: LIST
82749: PUSH
82750: LD_INT 2
82752: NEG
82753: PUSH
82754: LD_INT 0
82756: PUSH
82757: EMPTY
82758: LIST
82759: LIST
82760: PUSH
82761: LD_INT 2
82763: NEG
82764: PUSH
82765: LD_INT 1
82767: NEG
82768: PUSH
82769: EMPTY
82770: LIST
82771: LIST
82772: PUSH
82773: LD_INT 2
82775: NEG
82776: PUSH
82777: LD_INT 2
82779: NEG
82780: PUSH
82781: EMPTY
82782: LIST
82783: LIST
82784: PUSH
82785: EMPTY
82786: LIST
82787: LIST
82788: LIST
82789: LIST
82790: LIST
82791: LIST
82792: LIST
82793: LIST
82794: LIST
82795: LIST
82796: LIST
82797: LIST
82798: LIST
82799: LIST
82800: LIST
82801: LIST
82802: LIST
82803: LIST
82804: LIST
82805: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82806: LD_ADDR_VAR 0 21
82810: PUSH
82811: LD_INT 0
82813: PUSH
82814: LD_INT 0
82816: PUSH
82817: EMPTY
82818: LIST
82819: LIST
82820: PUSH
82821: LD_INT 0
82823: PUSH
82824: LD_INT 1
82826: NEG
82827: PUSH
82828: EMPTY
82829: LIST
82830: LIST
82831: PUSH
82832: LD_INT 1
82834: PUSH
82835: LD_INT 0
82837: PUSH
82838: EMPTY
82839: LIST
82840: LIST
82841: PUSH
82842: LD_INT 1
82844: PUSH
82845: LD_INT 1
82847: PUSH
82848: EMPTY
82849: LIST
82850: LIST
82851: PUSH
82852: LD_INT 0
82854: PUSH
82855: LD_INT 1
82857: PUSH
82858: EMPTY
82859: LIST
82860: LIST
82861: PUSH
82862: LD_INT 1
82864: NEG
82865: PUSH
82866: LD_INT 0
82868: PUSH
82869: EMPTY
82870: LIST
82871: LIST
82872: PUSH
82873: LD_INT 1
82875: NEG
82876: PUSH
82877: LD_INT 1
82879: NEG
82880: PUSH
82881: EMPTY
82882: LIST
82883: LIST
82884: PUSH
82885: LD_INT 1
82887: NEG
82888: PUSH
82889: LD_INT 2
82891: NEG
82892: PUSH
82893: EMPTY
82894: LIST
82895: LIST
82896: PUSH
82897: LD_INT 0
82899: PUSH
82900: LD_INT 2
82902: NEG
82903: PUSH
82904: EMPTY
82905: LIST
82906: LIST
82907: PUSH
82908: LD_INT 1
82910: PUSH
82911: LD_INT 1
82913: NEG
82914: PUSH
82915: EMPTY
82916: LIST
82917: LIST
82918: PUSH
82919: LD_INT 2
82921: PUSH
82922: LD_INT 0
82924: PUSH
82925: EMPTY
82926: LIST
82927: LIST
82928: PUSH
82929: LD_INT 2
82931: PUSH
82932: LD_INT 1
82934: PUSH
82935: EMPTY
82936: LIST
82937: LIST
82938: PUSH
82939: LD_INT 2
82941: PUSH
82942: LD_INT 2
82944: PUSH
82945: EMPTY
82946: LIST
82947: LIST
82948: PUSH
82949: LD_INT 1
82951: PUSH
82952: LD_INT 2
82954: PUSH
82955: EMPTY
82956: LIST
82957: LIST
82958: PUSH
82959: LD_INT 0
82961: PUSH
82962: LD_INT 2
82964: PUSH
82965: EMPTY
82966: LIST
82967: LIST
82968: PUSH
82969: LD_INT 1
82971: NEG
82972: PUSH
82973: LD_INT 1
82975: PUSH
82976: EMPTY
82977: LIST
82978: LIST
82979: PUSH
82980: LD_INT 2
82982: NEG
82983: PUSH
82984: LD_INT 0
82986: PUSH
82987: EMPTY
82988: LIST
82989: LIST
82990: PUSH
82991: LD_INT 2
82993: NEG
82994: PUSH
82995: LD_INT 1
82997: NEG
82998: PUSH
82999: EMPTY
83000: LIST
83001: LIST
83002: PUSH
83003: LD_INT 2
83005: NEG
83006: PUSH
83007: LD_INT 2
83009: NEG
83010: PUSH
83011: EMPTY
83012: LIST
83013: LIST
83014: PUSH
83015: EMPTY
83016: LIST
83017: LIST
83018: LIST
83019: LIST
83020: LIST
83021: LIST
83022: LIST
83023: LIST
83024: LIST
83025: LIST
83026: LIST
83027: LIST
83028: LIST
83029: LIST
83030: LIST
83031: LIST
83032: LIST
83033: LIST
83034: LIST
83035: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83036: LD_ADDR_VAR 0 22
83040: PUSH
83041: LD_INT 0
83043: PUSH
83044: LD_INT 0
83046: PUSH
83047: EMPTY
83048: LIST
83049: LIST
83050: PUSH
83051: LD_INT 0
83053: PUSH
83054: LD_INT 1
83056: NEG
83057: PUSH
83058: EMPTY
83059: LIST
83060: LIST
83061: PUSH
83062: LD_INT 1
83064: PUSH
83065: LD_INT 0
83067: PUSH
83068: EMPTY
83069: LIST
83070: LIST
83071: PUSH
83072: LD_INT 1
83074: PUSH
83075: LD_INT 1
83077: PUSH
83078: EMPTY
83079: LIST
83080: LIST
83081: PUSH
83082: LD_INT 0
83084: PUSH
83085: LD_INT 1
83087: PUSH
83088: EMPTY
83089: LIST
83090: LIST
83091: PUSH
83092: LD_INT 1
83094: NEG
83095: PUSH
83096: LD_INT 0
83098: PUSH
83099: EMPTY
83100: LIST
83101: LIST
83102: PUSH
83103: LD_INT 1
83105: NEG
83106: PUSH
83107: LD_INT 1
83109: NEG
83110: PUSH
83111: EMPTY
83112: LIST
83113: LIST
83114: PUSH
83115: LD_INT 1
83117: NEG
83118: PUSH
83119: LD_INT 2
83121: NEG
83122: PUSH
83123: EMPTY
83124: LIST
83125: LIST
83126: PUSH
83127: LD_INT 0
83129: PUSH
83130: LD_INT 2
83132: NEG
83133: PUSH
83134: EMPTY
83135: LIST
83136: LIST
83137: PUSH
83138: LD_INT 1
83140: PUSH
83141: LD_INT 1
83143: NEG
83144: PUSH
83145: EMPTY
83146: LIST
83147: LIST
83148: PUSH
83149: LD_INT 2
83151: PUSH
83152: LD_INT 0
83154: PUSH
83155: EMPTY
83156: LIST
83157: LIST
83158: PUSH
83159: LD_INT 2
83161: PUSH
83162: LD_INT 1
83164: PUSH
83165: EMPTY
83166: LIST
83167: LIST
83168: PUSH
83169: LD_INT 2
83171: PUSH
83172: LD_INT 2
83174: PUSH
83175: EMPTY
83176: LIST
83177: LIST
83178: PUSH
83179: LD_INT 1
83181: PUSH
83182: LD_INT 2
83184: PUSH
83185: EMPTY
83186: LIST
83187: LIST
83188: PUSH
83189: LD_INT 0
83191: PUSH
83192: LD_INT 2
83194: PUSH
83195: EMPTY
83196: LIST
83197: LIST
83198: PUSH
83199: LD_INT 1
83201: NEG
83202: PUSH
83203: LD_INT 1
83205: PUSH
83206: EMPTY
83207: LIST
83208: LIST
83209: PUSH
83210: LD_INT 2
83212: NEG
83213: PUSH
83214: LD_INT 0
83216: PUSH
83217: EMPTY
83218: LIST
83219: LIST
83220: PUSH
83221: LD_INT 2
83223: NEG
83224: PUSH
83225: LD_INT 1
83227: NEG
83228: PUSH
83229: EMPTY
83230: LIST
83231: LIST
83232: PUSH
83233: LD_INT 2
83235: NEG
83236: PUSH
83237: LD_INT 2
83239: NEG
83240: PUSH
83241: EMPTY
83242: LIST
83243: LIST
83244: PUSH
83245: EMPTY
83246: LIST
83247: LIST
83248: LIST
83249: LIST
83250: LIST
83251: LIST
83252: LIST
83253: LIST
83254: LIST
83255: LIST
83256: LIST
83257: LIST
83258: LIST
83259: LIST
83260: LIST
83261: LIST
83262: LIST
83263: LIST
83264: LIST
83265: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
83266: LD_ADDR_VAR 0 23
83270: PUSH
83271: LD_INT 0
83273: PUSH
83274: LD_INT 0
83276: PUSH
83277: EMPTY
83278: LIST
83279: LIST
83280: PUSH
83281: LD_INT 0
83283: PUSH
83284: LD_INT 1
83286: NEG
83287: PUSH
83288: EMPTY
83289: LIST
83290: LIST
83291: PUSH
83292: LD_INT 1
83294: PUSH
83295: LD_INT 0
83297: PUSH
83298: EMPTY
83299: LIST
83300: LIST
83301: PUSH
83302: LD_INT 1
83304: PUSH
83305: LD_INT 1
83307: PUSH
83308: EMPTY
83309: LIST
83310: LIST
83311: PUSH
83312: LD_INT 0
83314: PUSH
83315: LD_INT 1
83317: PUSH
83318: EMPTY
83319: LIST
83320: LIST
83321: PUSH
83322: LD_INT 1
83324: NEG
83325: PUSH
83326: LD_INT 0
83328: PUSH
83329: EMPTY
83330: LIST
83331: LIST
83332: PUSH
83333: LD_INT 1
83335: NEG
83336: PUSH
83337: LD_INT 1
83339: NEG
83340: PUSH
83341: EMPTY
83342: LIST
83343: LIST
83344: PUSH
83345: LD_INT 1
83347: NEG
83348: PUSH
83349: LD_INT 2
83351: NEG
83352: PUSH
83353: EMPTY
83354: LIST
83355: LIST
83356: PUSH
83357: LD_INT 0
83359: PUSH
83360: LD_INT 2
83362: NEG
83363: PUSH
83364: EMPTY
83365: LIST
83366: LIST
83367: PUSH
83368: LD_INT 1
83370: PUSH
83371: LD_INT 1
83373: NEG
83374: PUSH
83375: EMPTY
83376: LIST
83377: LIST
83378: PUSH
83379: LD_INT 2
83381: PUSH
83382: LD_INT 0
83384: PUSH
83385: EMPTY
83386: LIST
83387: LIST
83388: PUSH
83389: LD_INT 2
83391: PUSH
83392: LD_INT 1
83394: PUSH
83395: EMPTY
83396: LIST
83397: LIST
83398: PUSH
83399: LD_INT 2
83401: PUSH
83402: LD_INT 2
83404: PUSH
83405: EMPTY
83406: LIST
83407: LIST
83408: PUSH
83409: LD_INT 1
83411: PUSH
83412: LD_INT 2
83414: PUSH
83415: EMPTY
83416: LIST
83417: LIST
83418: PUSH
83419: LD_INT 0
83421: PUSH
83422: LD_INT 2
83424: PUSH
83425: EMPTY
83426: LIST
83427: LIST
83428: PUSH
83429: LD_INT 1
83431: NEG
83432: PUSH
83433: LD_INT 1
83435: PUSH
83436: EMPTY
83437: LIST
83438: LIST
83439: PUSH
83440: LD_INT 2
83442: NEG
83443: PUSH
83444: LD_INT 0
83446: PUSH
83447: EMPTY
83448: LIST
83449: LIST
83450: PUSH
83451: LD_INT 2
83453: NEG
83454: PUSH
83455: LD_INT 1
83457: NEG
83458: PUSH
83459: EMPTY
83460: LIST
83461: LIST
83462: PUSH
83463: LD_INT 2
83465: NEG
83466: PUSH
83467: LD_INT 2
83469: NEG
83470: PUSH
83471: EMPTY
83472: LIST
83473: LIST
83474: PUSH
83475: LD_INT 2
83477: NEG
83478: PUSH
83479: LD_INT 3
83481: NEG
83482: PUSH
83483: EMPTY
83484: LIST
83485: LIST
83486: PUSH
83487: LD_INT 1
83489: NEG
83490: PUSH
83491: LD_INT 3
83493: NEG
83494: PUSH
83495: EMPTY
83496: LIST
83497: LIST
83498: PUSH
83499: LD_INT 1
83501: PUSH
83502: LD_INT 2
83504: NEG
83505: PUSH
83506: EMPTY
83507: LIST
83508: LIST
83509: PUSH
83510: LD_INT 2
83512: PUSH
83513: LD_INT 1
83515: NEG
83516: PUSH
83517: EMPTY
83518: LIST
83519: LIST
83520: PUSH
83521: EMPTY
83522: LIST
83523: LIST
83524: LIST
83525: LIST
83526: LIST
83527: LIST
83528: LIST
83529: LIST
83530: LIST
83531: LIST
83532: LIST
83533: LIST
83534: LIST
83535: LIST
83536: LIST
83537: LIST
83538: LIST
83539: LIST
83540: LIST
83541: LIST
83542: LIST
83543: LIST
83544: LIST
83545: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
83546: LD_ADDR_VAR 0 24
83550: PUSH
83551: LD_INT 0
83553: PUSH
83554: LD_INT 0
83556: PUSH
83557: EMPTY
83558: LIST
83559: LIST
83560: PUSH
83561: LD_INT 0
83563: PUSH
83564: LD_INT 1
83566: NEG
83567: PUSH
83568: EMPTY
83569: LIST
83570: LIST
83571: PUSH
83572: LD_INT 1
83574: PUSH
83575: LD_INT 0
83577: PUSH
83578: EMPTY
83579: LIST
83580: LIST
83581: PUSH
83582: LD_INT 1
83584: PUSH
83585: LD_INT 1
83587: PUSH
83588: EMPTY
83589: LIST
83590: LIST
83591: PUSH
83592: LD_INT 0
83594: PUSH
83595: LD_INT 1
83597: PUSH
83598: EMPTY
83599: LIST
83600: LIST
83601: PUSH
83602: LD_INT 1
83604: NEG
83605: PUSH
83606: LD_INT 0
83608: PUSH
83609: EMPTY
83610: LIST
83611: LIST
83612: PUSH
83613: LD_INT 1
83615: NEG
83616: PUSH
83617: LD_INT 1
83619: NEG
83620: PUSH
83621: EMPTY
83622: LIST
83623: LIST
83624: PUSH
83625: LD_INT 1
83627: NEG
83628: PUSH
83629: LD_INT 2
83631: NEG
83632: PUSH
83633: EMPTY
83634: LIST
83635: LIST
83636: PUSH
83637: LD_INT 0
83639: PUSH
83640: LD_INT 2
83642: NEG
83643: PUSH
83644: EMPTY
83645: LIST
83646: LIST
83647: PUSH
83648: LD_INT 1
83650: PUSH
83651: LD_INT 1
83653: NEG
83654: PUSH
83655: EMPTY
83656: LIST
83657: LIST
83658: PUSH
83659: LD_INT 2
83661: PUSH
83662: LD_INT 0
83664: PUSH
83665: EMPTY
83666: LIST
83667: LIST
83668: PUSH
83669: LD_INT 2
83671: PUSH
83672: LD_INT 1
83674: PUSH
83675: EMPTY
83676: LIST
83677: LIST
83678: PUSH
83679: LD_INT 2
83681: PUSH
83682: LD_INT 2
83684: PUSH
83685: EMPTY
83686: LIST
83687: LIST
83688: PUSH
83689: LD_INT 1
83691: PUSH
83692: LD_INT 2
83694: PUSH
83695: EMPTY
83696: LIST
83697: LIST
83698: PUSH
83699: LD_INT 0
83701: PUSH
83702: LD_INT 2
83704: PUSH
83705: EMPTY
83706: LIST
83707: LIST
83708: PUSH
83709: LD_INT 1
83711: NEG
83712: PUSH
83713: LD_INT 1
83715: PUSH
83716: EMPTY
83717: LIST
83718: LIST
83719: PUSH
83720: LD_INT 2
83722: NEG
83723: PUSH
83724: LD_INT 0
83726: PUSH
83727: EMPTY
83728: LIST
83729: LIST
83730: PUSH
83731: LD_INT 2
83733: NEG
83734: PUSH
83735: LD_INT 1
83737: NEG
83738: PUSH
83739: EMPTY
83740: LIST
83741: LIST
83742: PUSH
83743: LD_INT 2
83745: NEG
83746: PUSH
83747: LD_INT 2
83749: NEG
83750: PUSH
83751: EMPTY
83752: LIST
83753: LIST
83754: PUSH
83755: LD_INT 1
83757: PUSH
83758: LD_INT 2
83760: NEG
83761: PUSH
83762: EMPTY
83763: LIST
83764: LIST
83765: PUSH
83766: LD_INT 2
83768: PUSH
83769: LD_INT 1
83771: NEG
83772: PUSH
83773: EMPTY
83774: LIST
83775: LIST
83776: PUSH
83777: LD_INT 3
83779: PUSH
83780: LD_INT 1
83782: PUSH
83783: EMPTY
83784: LIST
83785: LIST
83786: PUSH
83787: LD_INT 3
83789: PUSH
83790: LD_INT 2
83792: PUSH
83793: EMPTY
83794: LIST
83795: LIST
83796: PUSH
83797: EMPTY
83798: LIST
83799: LIST
83800: LIST
83801: LIST
83802: LIST
83803: LIST
83804: LIST
83805: LIST
83806: LIST
83807: LIST
83808: LIST
83809: LIST
83810: LIST
83811: LIST
83812: LIST
83813: LIST
83814: LIST
83815: LIST
83816: LIST
83817: LIST
83818: LIST
83819: LIST
83820: LIST
83821: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
83822: LD_ADDR_VAR 0 25
83826: PUSH
83827: LD_INT 0
83829: PUSH
83830: LD_INT 0
83832: PUSH
83833: EMPTY
83834: LIST
83835: LIST
83836: PUSH
83837: LD_INT 0
83839: PUSH
83840: LD_INT 1
83842: NEG
83843: PUSH
83844: EMPTY
83845: LIST
83846: LIST
83847: PUSH
83848: LD_INT 1
83850: PUSH
83851: LD_INT 0
83853: PUSH
83854: EMPTY
83855: LIST
83856: LIST
83857: PUSH
83858: LD_INT 1
83860: PUSH
83861: LD_INT 1
83863: PUSH
83864: EMPTY
83865: LIST
83866: LIST
83867: PUSH
83868: LD_INT 0
83870: PUSH
83871: LD_INT 1
83873: PUSH
83874: EMPTY
83875: LIST
83876: LIST
83877: PUSH
83878: LD_INT 1
83880: NEG
83881: PUSH
83882: LD_INT 0
83884: PUSH
83885: EMPTY
83886: LIST
83887: LIST
83888: PUSH
83889: LD_INT 1
83891: NEG
83892: PUSH
83893: LD_INT 1
83895: NEG
83896: PUSH
83897: EMPTY
83898: LIST
83899: LIST
83900: PUSH
83901: LD_INT 1
83903: NEG
83904: PUSH
83905: LD_INT 2
83907: NEG
83908: PUSH
83909: EMPTY
83910: LIST
83911: LIST
83912: PUSH
83913: LD_INT 0
83915: PUSH
83916: LD_INT 2
83918: NEG
83919: PUSH
83920: EMPTY
83921: LIST
83922: LIST
83923: PUSH
83924: LD_INT 1
83926: PUSH
83927: LD_INT 1
83929: NEG
83930: PUSH
83931: EMPTY
83932: LIST
83933: LIST
83934: PUSH
83935: LD_INT 2
83937: PUSH
83938: LD_INT 0
83940: PUSH
83941: EMPTY
83942: LIST
83943: LIST
83944: PUSH
83945: LD_INT 2
83947: PUSH
83948: LD_INT 1
83950: PUSH
83951: EMPTY
83952: LIST
83953: LIST
83954: PUSH
83955: LD_INT 2
83957: PUSH
83958: LD_INT 2
83960: PUSH
83961: EMPTY
83962: LIST
83963: LIST
83964: PUSH
83965: LD_INT 1
83967: PUSH
83968: LD_INT 2
83970: PUSH
83971: EMPTY
83972: LIST
83973: LIST
83974: PUSH
83975: LD_INT 0
83977: PUSH
83978: LD_INT 2
83980: PUSH
83981: EMPTY
83982: LIST
83983: LIST
83984: PUSH
83985: LD_INT 1
83987: NEG
83988: PUSH
83989: LD_INT 1
83991: PUSH
83992: EMPTY
83993: LIST
83994: LIST
83995: PUSH
83996: LD_INT 2
83998: NEG
83999: PUSH
84000: LD_INT 0
84002: PUSH
84003: EMPTY
84004: LIST
84005: LIST
84006: PUSH
84007: LD_INT 2
84009: NEG
84010: PUSH
84011: LD_INT 1
84013: NEG
84014: PUSH
84015: EMPTY
84016: LIST
84017: LIST
84018: PUSH
84019: LD_INT 2
84021: NEG
84022: PUSH
84023: LD_INT 2
84025: NEG
84026: PUSH
84027: EMPTY
84028: LIST
84029: LIST
84030: PUSH
84031: LD_INT 3
84033: PUSH
84034: LD_INT 1
84036: PUSH
84037: EMPTY
84038: LIST
84039: LIST
84040: PUSH
84041: LD_INT 3
84043: PUSH
84044: LD_INT 2
84046: PUSH
84047: EMPTY
84048: LIST
84049: LIST
84050: PUSH
84051: LD_INT 2
84053: PUSH
84054: LD_INT 3
84056: PUSH
84057: EMPTY
84058: LIST
84059: LIST
84060: PUSH
84061: LD_INT 1
84063: PUSH
84064: LD_INT 3
84066: PUSH
84067: EMPTY
84068: LIST
84069: LIST
84070: PUSH
84071: EMPTY
84072: LIST
84073: LIST
84074: LIST
84075: LIST
84076: LIST
84077: LIST
84078: LIST
84079: LIST
84080: LIST
84081: LIST
84082: LIST
84083: LIST
84084: LIST
84085: LIST
84086: LIST
84087: LIST
84088: LIST
84089: LIST
84090: LIST
84091: LIST
84092: LIST
84093: LIST
84094: LIST
84095: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
84096: LD_ADDR_VAR 0 26
84100: PUSH
84101: LD_INT 0
84103: PUSH
84104: LD_INT 0
84106: PUSH
84107: EMPTY
84108: LIST
84109: LIST
84110: PUSH
84111: LD_INT 0
84113: PUSH
84114: LD_INT 1
84116: NEG
84117: PUSH
84118: EMPTY
84119: LIST
84120: LIST
84121: PUSH
84122: LD_INT 1
84124: PUSH
84125: LD_INT 0
84127: PUSH
84128: EMPTY
84129: LIST
84130: LIST
84131: PUSH
84132: LD_INT 1
84134: PUSH
84135: LD_INT 1
84137: PUSH
84138: EMPTY
84139: LIST
84140: LIST
84141: PUSH
84142: LD_INT 0
84144: PUSH
84145: LD_INT 1
84147: PUSH
84148: EMPTY
84149: LIST
84150: LIST
84151: PUSH
84152: LD_INT 1
84154: NEG
84155: PUSH
84156: LD_INT 0
84158: PUSH
84159: EMPTY
84160: LIST
84161: LIST
84162: PUSH
84163: LD_INT 1
84165: NEG
84166: PUSH
84167: LD_INT 1
84169: NEG
84170: PUSH
84171: EMPTY
84172: LIST
84173: LIST
84174: PUSH
84175: LD_INT 1
84177: NEG
84178: PUSH
84179: LD_INT 2
84181: NEG
84182: PUSH
84183: EMPTY
84184: LIST
84185: LIST
84186: PUSH
84187: LD_INT 0
84189: PUSH
84190: LD_INT 2
84192: NEG
84193: PUSH
84194: EMPTY
84195: LIST
84196: LIST
84197: PUSH
84198: LD_INT 1
84200: PUSH
84201: LD_INT 1
84203: NEG
84204: PUSH
84205: EMPTY
84206: LIST
84207: LIST
84208: PUSH
84209: LD_INT 2
84211: PUSH
84212: LD_INT 0
84214: PUSH
84215: EMPTY
84216: LIST
84217: LIST
84218: PUSH
84219: LD_INT 2
84221: PUSH
84222: LD_INT 1
84224: PUSH
84225: EMPTY
84226: LIST
84227: LIST
84228: PUSH
84229: LD_INT 2
84231: PUSH
84232: LD_INT 2
84234: PUSH
84235: EMPTY
84236: LIST
84237: LIST
84238: PUSH
84239: LD_INT 1
84241: PUSH
84242: LD_INT 2
84244: PUSH
84245: EMPTY
84246: LIST
84247: LIST
84248: PUSH
84249: LD_INT 0
84251: PUSH
84252: LD_INT 2
84254: PUSH
84255: EMPTY
84256: LIST
84257: LIST
84258: PUSH
84259: LD_INT 1
84261: NEG
84262: PUSH
84263: LD_INT 1
84265: PUSH
84266: EMPTY
84267: LIST
84268: LIST
84269: PUSH
84270: LD_INT 2
84272: NEG
84273: PUSH
84274: LD_INT 0
84276: PUSH
84277: EMPTY
84278: LIST
84279: LIST
84280: PUSH
84281: LD_INT 2
84283: NEG
84284: PUSH
84285: LD_INT 1
84287: NEG
84288: PUSH
84289: EMPTY
84290: LIST
84291: LIST
84292: PUSH
84293: LD_INT 2
84295: NEG
84296: PUSH
84297: LD_INT 2
84299: NEG
84300: PUSH
84301: EMPTY
84302: LIST
84303: LIST
84304: PUSH
84305: LD_INT 2
84307: PUSH
84308: LD_INT 3
84310: PUSH
84311: EMPTY
84312: LIST
84313: LIST
84314: PUSH
84315: LD_INT 1
84317: PUSH
84318: LD_INT 3
84320: PUSH
84321: EMPTY
84322: LIST
84323: LIST
84324: PUSH
84325: LD_INT 1
84327: NEG
84328: PUSH
84329: LD_INT 2
84331: PUSH
84332: EMPTY
84333: LIST
84334: LIST
84335: PUSH
84336: LD_INT 2
84338: NEG
84339: PUSH
84340: LD_INT 1
84342: PUSH
84343: EMPTY
84344: LIST
84345: LIST
84346: PUSH
84347: EMPTY
84348: LIST
84349: LIST
84350: LIST
84351: LIST
84352: LIST
84353: LIST
84354: LIST
84355: LIST
84356: LIST
84357: LIST
84358: LIST
84359: LIST
84360: LIST
84361: LIST
84362: LIST
84363: LIST
84364: LIST
84365: LIST
84366: LIST
84367: LIST
84368: LIST
84369: LIST
84370: LIST
84371: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84372: LD_ADDR_VAR 0 27
84376: PUSH
84377: LD_INT 0
84379: PUSH
84380: LD_INT 0
84382: PUSH
84383: EMPTY
84384: LIST
84385: LIST
84386: PUSH
84387: LD_INT 0
84389: PUSH
84390: LD_INT 1
84392: NEG
84393: PUSH
84394: EMPTY
84395: LIST
84396: LIST
84397: PUSH
84398: LD_INT 1
84400: PUSH
84401: LD_INT 0
84403: PUSH
84404: EMPTY
84405: LIST
84406: LIST
84407: PUSH
84408: LD_INT 1
84410: PUSH
84411: LD_INT 1
84413: PUSH
84414: EMPTY
84415: LIST
84416: LIST
84417: PUSH
84418: LD_INT 0
84420: PUSH
84421: LD_INT 1
84423: PUSH
84424: EMPTY
84425: LIST
84426: LIST
84427: PUSH
84428: LD_INT 1
84430: NEG
84431: PUSH
84432: LD_INT 0
84434: PUSH
84435: EMPTY
84436: LIST
84437: LIST
84438: PUSH
84439: LD_INT 1
84441: NEG
84442: PUSH
84443: LD_INT 1
84445: NEG
84446: PUSH
84447: EMPTY
84448: LIST
84449: LIST
84450: PUSH
84451: LD_INT 1
84453: NEG
84454: PUSH
84455: LD_INT 2
84457: NEG
84458: PUSH
84459: EMPTY
84460: LIST
84461: LIST
84462: PUSH
84463: LD_INT 0
84465: PUSH
84466: LD_INT 2
84468: NEG
84469: PUSH
84470: EMPTY
84471: LIST
84472: LIST
84473: PUSH
84474: LD_INT 1
84476: PUSH
84477: LD_INT 1
84479: NEG
84480: PUSH
84481: EMPTY
84482: LIST
84483: LIST
84484: PUSH
84485: LD_INT 2
84487: PUSH
84488: LD_INT 0
84490: PUSH
84491: EMPTY
84492: LIST
84493: LIST
84494: PUSH
84495: LD_INT 2
84497: PUSH
84498: LD_INT 1
84500: PUSH
84501: EMPTY
84502: LIST
84503: LIST
84504: PUSH
84505: LD_INT 2
84507: PUSH
84508: LD_INT 2
84510: PUSH
84511: EMPTY
84512: LIST
84513: LIST
84514: PUSH
84515: LD_INT 1
84517: PUSH
84518: LD_INT 2
84520: PUSH
84521: EMPTY
84522: LIST
84523: LIST
84524: PUSH
84525: LD_INT 0
84527: PUSH
84528: LD_INT 2
84530: PUSH
84531: EMPTY
84532: LIST
84533: LIST
84534: PUSH
84535: LD_INT 1
84537: NEG
84538: PUSH
84539: LD_INT 1
84541: PUSH
84542: EMPTY
84543: LIST
84544: LIST
84545: PUSH
84546: LD_INT 2
84548: NEG
84549: PUSH
84550: LD_INT 0
84552: PUSH
84553: EMPTY
84554: LIST
84555: LIST
84556: PUSH
84557: LD_INT 2
84559: NEG
84560: PUSH
84561: LD_INT 1
84563: NEG
84564: PUSH
84565: EMPTY
84566: LIST
84567: LIST
84568: PUSH
84569: LD_INT 2
84571: NEG
84572: PUSH
84573: LD_INT 2
84575: NEG
84576: PUSH
84577: EMPTY
84578: LIST
84579: LIST
84580: PUSH
84581: LD_INT 1
84583: NEG
84584: PUSH
84585: LD_INT 2
84587: PUSH
84588: EMPTY
84589: LIST
84590: LIST
84591: PUSH
84592: LD_INT 2
84594: NEG
84595: PUSH
84596: LD_INT 1
84598: PUSH
84599: EMPTY
84600: LIST
84601: LIST
84602: PUSH
84603: LD_INT 3
84605: NEG
84606: PUSH
84607: LD_INT 1
84609: NEG
84610: PUSH
84611: EMPTY
84612: LIST
84613: LIST
84614: PUSH
84615: LD_INT 3
84617: NEG
84618: PUSH
84619: LD_INT 2
84621: NEG
84622: PUSH
84623: EMPTY
84624: LIST
84625: LIST
84626: PUSH
84627: EMPTY
84628: LIST
84629: LIST
84630: LIST
84631: LIST
84632: LIST
84633: LIST
84634: LIST
84635: LIST
84636: LIST
84637: LIST
84638: LIST
84639: LIST
84640: LIST
84641: LIST
84642: LIST
84643: LIST
84644: LIST
84645: LIST
84646: LIST
84647: LIST
84648: LIST
84649: LIST
84650: LIST
84651: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84652: LD_ADDR_VAR 0 28
84656: PUSH
84657: LD_INT 0
84659: PUSH
84660: LD_INT 0
84662: PUSH
84663: EMPTY
84664: LIST
84665: LIST
84666: PUSH
84667: LD_INT 0
84669: PUSH
84670: LD_INT 1
84672: NEG
84673: PUSH
84674: EMPTY
84675: LIST
84676: LIST
84677: PUSH
84678: LD_INT 1
84680: PUSH
84681: LD_INT 0
84683: PUSH
84684: EMPTY
84685: LIST
84686: LIST
84687: PUSH
84688: LD_INT 1
84690: PUSH
84691: LD_INT 1
84693: PUSH
84694: EMPTY
84695: LIST
84696: LIST
84697: PUSH
84698: LD_INT 0
84700: PUSH
84701: LD_INT 1
84703: PUSH
84704: EMPTY
84705: LIST
84706: LIST
84707: PUSH
84708: LD_INT 1
84710: NEG
84711: PUSH
84712: LD_INT 0
84714: PUSH
84715: EMPTY
84716: LIST
84717: LIST
84718: PUSH
84719: LD_INT 1
84721: NEG
84722: PUSH
84723: LD_INT 1
84725: NEG
84726: PUSH
84727: EMPTY
84728: LIST
84729: LIST
84730: PUSH
84731: LD_INT 1
84733: NEG
84734: PUSH
84735: LD_INT 2
84737: NEG
84738: PUSH
84739: EMPTY
84740: LIST
84741: LIST
84742: PUSH
84743: LD_INT 0
84745: PUSH
84746: LD_INT 2
84748: NEG
84749: PUSH
84750: EMPTY
84751: LIST
84752: LIST
84753: PUSH
84754: LD_INT 1
84756: PUSH
84757: LD_INT 1
84759: NEG
84760: PUSH
84761: EMPTY
84762: LIST
84763: LIST
84764: PUSH
84765: LD_INT 2
84767: PUSH
84768: LD_INT 0
84770: PUSH
84771: EMPTY
84772: LIST
84773: LIST
84774: PUSH
84775: LD_INT 2
84777: PUSH
84778: LD_INT 1
84780: PUSH
84781: EMPTY
84782: LIST
84783: LIST
84784: PUSH
84785: LD_INT 2
84787: PUSH
84788: LD_INT 2
84790: PUSH
84791: EMPTY
84792: LIST
84793: LIST
84794: PUSH
84795: LD_INT 1
84797: PUSH
84798: LD_INT 2
84800: PUSH
84801: EMPTY
84802: LIST
84803: LIST
84804: PUSH
84805: LD_INT 0
84807: PUSH
84808: LD_INT 2
84810: PUSH
84811: EMPTY
84812: LIST
84813: LIST
84814: PUSH
84815: LD_INT 1
84817: NEG
84818: PUSH
84819: LD_INT 1
84821: PUSH
84822: EMPTY
84823: LIST
84824: LIST
84825: PUSH
84826: LD_INT 2
84828: NEG
84829: PUSH
84830: LD_INT 0
84832: PUSH
84833: EMPTY
84834: LIST
84835: LIST
84836: PUSH
84837: LD_INT 2
84839: NEG
84840: PUSH
84841: LD_INT 1
84843: NEG
84844: PUSH
84845: EMPTY
84846: LIST
84847: LIST
84848: PUSH
84849: LD_INT 2
84851: NEG
84852: PUSH
84853: LD_INT 2
84855: NEG
84856: PUSH
84857: EMPTY
84858: LIST
84859: LIST
84860: PUSH
84861: LD_INT 2
84863: NEG
84864: PUSH
84865: LD_INT 3
84867: NEG
84868: PUSH
84869: EMPTY
84870: LIST
84871: LIST
84872: PUSH
84873: LD_INT 1
84875: NEG
84876: PUSH
84877: LD_INT 3
84879: NEG
84880: PUSH
84881: EMPTY
84882: LIST
84883: LIST
84884: PUSH
84885: LD_INT 3
84887: NEG
84888: PUSH
84889: LD_INT 1
84891: NEG
84892: PUSH
84893: EMPTY
84894: LIST
84895: LIST
84896: PUSH
84897: LD_INT 3
84899: NEG
84900: PUSH
84901: LD_INT 2
84903: NEG
84904: PUSH
84905: EMPTY
84906: LIST
84907: LIST
84908: PUSH
84909: EMPTY
84910: LIST
84911: LIST
84912: LIST
84913: LIST
84914: LIST
84915: LIST
84916: LIST
84917: LIST
84918: LIST
84919: LIST
84920: LIST
84921: LIST
84922: LIST
84923: LIST
84924: LIST
84925: LIST
84926: LIST
84927: LIST
84928: LIST
84929: LIST
84930: LIST
84931: LIST
84932: LIST
84933: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84934: LD_ADDR_VAR 0 29
84938: PUSH
84939: LD_INT 0
84941: PUSH
84942: LD_INT 0
84944: PUSH
84945: EMPTY
84946: LIST
84947: LIST
84948: PUSH
84949: LD_INT 0
84951: PUSH
84952: LD_INT 1
84954: NEG
84955: PUSH
84956: EMPTY
84957: LIST
84958: LIST
84959: PUSH
84960: LD_INT 1
84962: PUSH
84963: LD_INT 0
84965: PUSH
84966: EMPTY
84967: LIST
84968: LIST
84969: PUSH
84970: LD_INT 1
84972: PUSH
84973: LD_INT 1
84975: PUSH
84976: EMPTY
84977: LIST
84978: LIST
84979: PUSH
84980: LD_INT 0
84982: PUSH
84983: LD_INT 1
84985: PUSH
84986: EMPTY
84987: LIST
84988: LIST
84989: PUSH
84990: LD_INT 1
84992: NEG
84993: PUSH
84994: LD_INT 0
84996: PUSH
84997: EMPTY
84998: LIST
84999: LIST
85000: PUSH
85001: LD_INT 1
85003: NEG
85004: PUSH
85005: LD_INT 1
85007: NEG
85008: PUSH
85009: EMPTY
85010: LIST
85011: LIST
85012: PUSH
85013: LD_INT 1
85015: NEG
85016: PUSH
85017: LD_INT 2
85019: NEG
85020: PUSH
85021: EMPTY
85022: LIST
85023: LIST
85024: PUSH
85025: LD_INT 0
85027: PUSH
85028: LD_INT 2
85030: NEG
85031: PUSH
85032: EMPTY
85033: LIST
85034: LIST
85035: PUSH
85036: LD_INT 1
85038: PUSH
85039: LD_INT 1
85041: NEG
85042: PUSH
85043: EMPTY
85044: LIST
85045: LIST
85046: PUSH
85047: LD_INT 2
85049: PUSH
85050: LD_INT 0
85052: PUSH
85053: EMPTY
85054: LIST
85055: LIST
85056: PUSH
85057: LD_INT 2
85059: PUSH
85060: LD_INT 1
85062: PUSH
85063: EMPTY
85064: LIST
85065: LIST
85066: PUSH
85067: LD_INT 1
85069: PUSH
85070: LD_INT 2
85072: PUSH
85073: EMPTY
85074: LIST
85075: LIST
85076: PUSH
85077: LD_INT 0
85079: PUSH
85080: LD_INT 2
85082: PUSH
85083: EMPTY
85084: LIST
85085: LIST
85086: PUSH
85087: LD_INT 1
85089: NEG
85090: PUSH
85091: LD_INT 1
85093: PUSH
85094: EMPTY
85095: LIST
85096: LIST
85097: PUSH
85098: LD_INT 2
85100: NEG
85101: PUSH
85102: LD_INT 1
85104: NEG
85105: PUSH
85106: EMPTY
85107: LIST
85108: LIST
85109: PUSH
85110: LD_INT 2
85112: NEG
85113: PUSH
85114: LD_INT 2
85116: NEG
85117: PUSH
85118: EMPTY
85119: LIST
85120: LIST
85121: PUSH
85122: LD_INT 2
85124: NEG
85125: PUSH
85126: LD_INT 3
85128: NEG
85129: PUSH
85130: EMPTY
85131: LIST
85132: LIST
85133: PUSH
85134: LD_INT 2
85136: PUSH
85137: LD_INT 1
85139: NEG
85140: PUSH
85141: EMPTY
85142: LIST
85143: LIST
85144: PUSH
85145: LD_INT 3
85147: PUSH
85148: LD_INT 1
85150: PUSH
85151: EMPTY
85152: LIST
85153: LIST
85154: PUSH
85155: LD_INT 1
85157: PUSH
85158: LD_INT 3
85160: PUSH
85161: EMPTY
85162: LIST
85163: LIST
85164: PUSH
85165: LD_INT 1
85167: NEG
85168: PUSH
85169: LD_INT 2
85171: PUSH
85172: EMPTY
85173: LIST
85174: LIST
85175: PUSH
85176: LD_INT 3
85178: NEG
85179: PUSH
85180: LD_INT 2
85182: NEG
85183: PUSH
85184: EMPTY
85185: LIST
85186: LIST
85187: PUSH
85188: EMPTY
85189: LIST
85190: LIST
85191: LIST
85192: LIST
85193: LIST
85194: LIST
85195: LIST
85196: LIST
85197: LIST
85198: LIST
85199: LIST
85200: LIST
85201: LIST
85202: LIST
85203: LIST
85204: LIST
85205: LIST
85206: LIST
85207: LIST
85208: LIST
85209: LIST
85210: LIST
85211: LIST
85212: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85213: LD_ADDR_VAR 0 30
85217: PUSH
85218: LD_INT 0
85220: PUSH
85221: LD_INT 0
85223: PUSH
85224: EMPTY
85225: LIST
85226: LIST
85227: PUSH
85228: LD_INT 0
85230: PUSH
85231: LD_INT 1
85233: NEG
85234: PUSH
85235: EMPTY
85236: LIST
85237: LIST
85238: PUSH
85239: LD_INT 1
85241: PUSH
85242: LD_INT 0
85244: PUSH
85245: EMPTY
85246: LIST
85247: LIST
85248: PUSH
85249: LD_INT 1
85251: PUSH
85252: LD_INT 1
85254: PUSH
85255: EMPTY
85256: LIST
85257: LIST
85258: PUSH
85259: LD_INT 0
85261: PUSH
85262: LD_INT 1
85264: PUSH
85265: EMPTY
85266: LIST
85267: LIST
85268: PUSH
85269: LD_INT 1
85271: NEG
85272: PUSH
85273: LD_INT 0
85275: PUSH
85276: EMPTY
85277: LIST
85278: LIST
85279: PUSH
85280: LD_INT 1
85282: NEG
85283: PUSH
85284: LD_INT 1
85286: NEG
85287: PUSH
85288: EMPTY
85289: LIST
85290: LIST
85291: PUSH
85292: LD_INT 1
85294: NEG
85295: PUSH
85296: LD_INT 2
85298: NEG
85299: PUSH
85300: EMPTY
85301: LIST
85302: LIST
85303: PUSH
85304: LD_INT 0
85306: PUSH
85307: LD_INT 2
85309: NEG
85310: PUSH
85311: EMPTY
85312: LIST
85313: LIST
85314: PUSH
85315: LD_INT 1
85317: PUSH
85318: LD_INT 1
85320: NEG
85321: PUSH
85322: EMPTY
85323: LIST
85324: LIST
85325: PUSH
85326: LD_INT 2
85328: PUSH
85329: LD_INT 0
85331: PUSH
85332: EMPTY
85333: LIST
85334: LIST
85335: PUSH
85336: LD_INT 2
85338: PUSH
85339: LD_INT 1
85341: PUSH
85342: EMPTY
85343: LIST
85344: LIST
85345: PUSH
85346: LD_INT 2
85348: PUSH
85349: LD_INT 2
85351: PUSH
85352: EMPTY
85353: LIST
85354: LIST
85355: PUSH
85356: LD_INT 1
85358: PUSH
85359: LD_INT 2
85361: PUSH
85362: EMPTY
85363: LIST
85364: LIST
85365: PUSH
85366: LD_INT 1
85368: NEG
85369: PUSH
85370: LD_INT 1
85372: PUSH
85373: EMPTY
85374: LIST
85375: LIST
85376: PUSH
85377: LD_INT 2
85379: NEG
85380: PUSH
85381: LD_INT 0
85383: PUSH
85384: EMPTY
85385: LIST
85386: LIST
85387: PUSH
85388: LD_INT 2
85390: NEG
85391: PUSH
85392: LD_INT 1
85394: NEG
85395: PUSH
85396: EMPTY
85397: LIST
85398: LIST
85399: PUSH
85400: LD_INT 1
85402: NEG
85403: PUSH
85404: LD_INT 3
85406: NEG
85407: PUSH
85408: EMPTY
85409: LIST
85410: LIST
85411: PUSH
85412: LD_INT 1
85414: PUSH
85415: LD_INT 2
85417: NEG
85418: PUSH
85419: EMPTY
85420: LIST
85421: LIST
85422: PUSH
85423: LD_INT 3
85425: PUSH
85426: LD_INT 2
85428: PUSH
85429: EMPTY
85430: LIST
85431: LIST
85432: PUSH
85433: LD_INT 2
85435: PUSH
85436: LD_INT 3
85438: PUSH
85439: EMPTY
85440: LIST
85441: LIST
85442: PUSH
85443: LD_INT 2
85445: NEG
85446: PUSH
85447: LD_INT 1
85449: PUSH
85450: EMPTY
85451: LIST
85452: LIST
85453: PUSH
85454: LD_INT 3
85456: NEG
85457: PUSH
85458: LD_INT 1
85460: NEG
85461: PUSH
85462: EMPTY
85463: LIST
85464: LIST
85465: PUSH
85466: EMPTY
85467: LIST
85468: LIST
85469: LIST
85470: LIST
85471: LIST
85472: LIST
85473: LIST
85474: LIST
85475: LIST
85476: LIST
85477: LIST
85478: LIST
85479: LIST
85480: LIST
85481: LIST
85482: LIST
85483: LIST
85484: LIST
85485: LIST
85486: LIST
85487: LIST
85488: LIST
85489: LIST
85490: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85491: LD_ADDR_VAR 0 31
85495: PUSH
85496: LD_INT 0
85498: PUSH
85499: LD_INT 0
85501: PUSH
85502: EMPTY
85503: LIST
85504: LIST
85505: PUSH
85506: LD_INT 0
85508: PUSH
85509: LD_INT 1
85511: NEG
85512: PUSH
85513: EMPTY
85514: LIST
85515: LIST
85516: PUSH
85517: LD_INT 1
85519: PUSH
85520: LD_INT 0
85522: PUSH
85523: EMPTY
85524: LIST
85525: LIST
85526: PUSH
85527: LD_INT 1
85529: PUSH
85530: LD_INT 1
85532: PUSH
85533: EMPTY
85534: LIST
85535: LIST
85536: PUSH
85537: LD_INT 0
85539: PUSH
85540: LD_INT 1
85542: PUSH
85543: EMPTY
85544: LIST
85545: LIST
85546: PUSH
85547: LD_INT 1
85549: NEG
85550: PUSH
85551: LD_INT 0
85553: PUSH
85554: EMPTY
85555: LIST
85556: LIST
85557: PUSH
85558: LD_INT 1
85560: NEG
85561: PUSH
85562: LD_INT 1
85564: NEG
85565: PUSH
85566: EMPTY
85567: LIST
85568: LIST
85569: PUSH
85570: LD_INT 1
85572: NEG
85573: PUSH
85574: LD_INT 2
85576: NEG
85577: PUSH
85578: EMPTY
85579: LIST
85580: LIST
85581: PUSH
85582: LD_INT 1
85584: PUSH
85585: LD_INT 1
85587: NEG
85588: PUSH
85589: EMPTY
85590: LIST
85591: LIST
85592: PUSH
85593: LD_INT 2
85595: PUSH
85596: LD_INT 0
85598: PUSH
85599: EMPTY
85600: LIST
85601: LIST
85602: PUSH
85603: LD_INT 2
85605: PUSH
85606: LD_INT 1
85608: PUSH
85609: EMPTY
85610: LIST
85611: LIST
85612: PUSH
85613: LD_INT 2
85615: PUSH
85616: LD_INT 2
85618: PUSH
85619: EMPTY
85620: LIST
85621: LIST
85622: PUSH
85623: LD_INT 1
85625: PUSH
85626: LD_INT 2
85628: PUSH
85629: EMPTY
85630: LIST
85631: LIST
85632: PUSH
85633: LD_INT 0
85635: PUSH
85636: LD_INT 2
85638: PUSH
85639: EMPTY
85640: LIST
85641: LIST
85642: PUSH
85643: LD_INT 1
85645: NEG
85646: PUSH
85647: LD_INT 1
85649: PUSH
85650: EMPTY
85651: LIST
85652: LIST
85653: PUSH
85654: LD_INT 2
85656: NEG
85657: PUSH
85658: LD_INT 1
85660: NEG
85661: PUSH
85662: EMPTY
85663: LIST
85664: LIST
85665: PUSH
85666: LD_INT 2
85668: NEG
85669: PUSH
85670: LD_INT 2
85672: NEG
85673: PUSH
85674: EMPTY
85675: LIST
85676: LIST
85677: PUSH
85678: LD_INT 2
85680: NEG
85681: PUSH
85682: LD_INT 3
85684: NEG
85685: PUSH
85686: EMPTY
85687: LIST
85688: LIST
85689: PUSH
85690: LD_INT 2
85692: PUSH
85693: LD_INT 1
85695: NEG
85696: PUSH
85697: EMPTY
85698: LIST
85699: LIST
85700: PUSH
85701: LD_INT 3
85703: PUSH
85704: LD_INT 1
85706: PUSH
85707: EMPTY
85708: LIST
85709: LIST
85710: PUSH
85711: LD_INT 1
85713: PUSH
85714: LD_INT 3
85716: PUSH
85717: EMPTY
85718: LIST
85719: LIST
85720: PUSH
85721: LD_INT 1
85723: NEG
85724: PUSH
85725: LD_INT 2
85727: PUSH
85728: EMPTY
85729: LIST
85730: LIST
85731: PUSH
85732: LD_INT 3
85734: NEG
85735: PUSH
85736: LD_INT 2
85738: NEG
85739: PUSH
85740: EMPTY
85741: LIST
85742: LIST
85743: PUSH
85744: EMPTY
85745: LIST
85746: LIST
85747: LIST
85748: LIST
85749: LIST
85750: LIST
85751: LIST
85752: LIST
85753: LIST
85754: LIST
85755: LIST
85756: LIST
85757: LIST
85758: LIST
85759: LIST
85760: LIST
85761: LIST
85762: LIST
85763: LIST
85764: LIST
85765: LIST
85766: LIST
85767: LIST
85768: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85769: LD_ADDR_VAR 0 32
85773: PUSH
85774: LD_INT 0
85776: PUSH
85777: LD_INT 0
85779: PUSH
85780: EMPTY
85781: LIST
85782: LIST
85783: PUSH
85784: LD_INT 0
85786: PUSH
85787: LD_INT 1
85789: NEG
85790: PUSH
85791: EMPTY
85792: LIST
85793: LIST
85794: PUSH
85795: LD_INT 1
85797: PUSH
85798: LD_INT 0
85800: PUSH
85801: EMPTY
85802: LIST
85803: LIST
85804: PUSH
85805: LD_INT 1
85807: PUSH
85808: LD_INT 1
85810: PUSH
85811: EMPTY
85812: LIST
85813: LIST
85814: PUSH
85815: LD_INT 0
85817: PUSH
85818: LD_INT 1
85820: PUSH
85821: EMPTY
85822: LIST
85823: LIST
85824: PUSH
85825: LD_INT 1
85827: NEG
85828: PUSH
85829: LD_INT 0
85831: PUSH
85832: EMPTY
85833: LIST
85834: LIST
85835: PUSH
85836: LD_INT 1
85838: NEG
85839: PUSH
85840: LD_INT 1
85842: NEG
85843: PUSH
85844: EMPTY
85845: LIST
85846: LIST
85847: PUSH
85848: LD_INT 1
85850: NEG
85851: PUSH
85852: LD_INT 2
85854: NEG
85855: PUSH
85856: EMPTY
85857: LIST
85858: LIST
85859: PUSH
85860: LD_INT 0
85862: PUSH
85863: LD_INT 2
85865: NEG
85866: PUSH
85867: EMPTY
85868: LIST
85869: LIST
85870: PUSH
85871: LD_INT 1
85873: PUSH
85874: LD_INT 1
85876: NEG
85877: PUSH
85878: EMPTY
85879: LIST
85880: LIST
85881: PUSH
85882: LD_INT 2
85884: PUSH
85885: LD_INT 1
85887: PUSH
85888: EMPTY
85889: LIST
85890: LIST
85891: PUSH
85892: LD_INT 2
85894: PUSH
85895: LD_INT 2
85897: PUSH
85898: EMPTY
85899: LIST
85900: LIST
85901: PUSH
85902: LD_INT 1
85904: PUSH
85905: LD_INT 2
85907: PUSH
85908: EMPTY
85909: LIST
85910: LIST
85911: PUSH
85912: LD_INT 0
85914: PUSH
85915: LD_INT 2
85917: PUSH
85918: EMPTY
85919: LIST
85920: LIST
85921: PUSH
85922: LD_INT 1
85924: NEG
85925: PUSH
85926: LD_INT 1
85928: PUSH
85929: EMPTY
85930: LIST
85931: LIST
85932: PUSH
85933: LD_INT 2
85935: NEG
85936: PUSH
85937: LD_INT 0
85939: PUSH
85940: EMPTY
85941: LIST
85942: LIST
85943: PUSH
85944: LD_INT 2
85946: NEG
85947: PUSH
85948: LD_INT 1
85950: NEG
85951: PUSH
85952: EMPTY
85953: LIST
85954: LIST
85955: PUSH
85956: LD_INT 1
85958: NEG
85959: PUSH
85960: LD_INT 3
85962: NEG
85963: PUSH
85964: EMPTY
85965: LIST
85966: LIST
85967: PUSH
85968: LD_INT 1
85970: PUSH
85971: LD_INT 2
85973: NEG
85974: PUSH
85975: EMPTY
85976: LIST
85977: LIST
85978: PUSH
85979: LD_INT 3
85981: PUSH
85982: LD_INT 2
85984: PUSH
85985: EMPTY
85986: LIST
85987: LIST
85988: PUSH
85989: LD_INT 2
85991: PUSH
85992: LD_INT 3
85994: PUSH
85995: EMPTY
85996: LIST
85997: LIST
85998: PUSH
85999: LD_INT 2
86001: NEG
86002: PUSH
86003: LD_INT 1
86005: PUSH
86006: EMPTY
86007: LIST
86008: LIST
86009: PUSH
86010: LD_INT 3
86012: NEG
86013: PUSH
86014: LD_INT 1
86016: NEG
86017: PUSH
86018: EMPTY
86019: LIST
86020: LIST
86021: PUSH
86022: EMPTY
86023: LIST
86024: LIST
86025: LIST
86026: LIST
86027: LIST
86028: LIST
86029: LIST
86030: LIST
86031: LIST
86032: LIST
86033: LIST
86034: LIST
86035: LIST
86036: LIST
86037: LIST
86038: LIST
86039: LIST
86040: LIST
86041: LIST
86042: LIST
86043: LIST
86044: LIST
86045: LIST
86046: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
86047: LD_ADDR_VAR 0 33
86051: PUSH
86052: LD_INT 0
86054: PUSH
86055: LD_INT 0
86057: PUSH
86058: EMPTY
86059: LIST
86060: LIST
86061: PUSH
86062: LD_INT 0
86064: PUSH
86065: LD_INT 1
86067: NEG
86068: PUSH
86069: EMPTY
86070: LIST
86071: LIST
86072: PUSH
86073: LD_INT 1
86075: PUSH
86076: LD_INT 0
86078: PUSH
86079: EMPTY
86080: LIST
86081: LIST
86082: PUSH
86083: LD_INT 1
86085: PUSH
86086: LD_INT 1
86088: PUSH
86089: EMPTY
86090: LIST
86091: LIST
86092: PUSH
86093: LD_INT 0
86095: PUSH
86096: LD_INT 1
86098: PUSH
86099: EMPTY
86100: LIST
86101: LIST
86102: PUSH
86103: LD_INT 1
86105: NEG
86106: PUSH
86107: LD_INT 0
86109: PUSH
86110: EMPTY
86111: LIST
86112: LIST
86113: PUSH
86114: LD_INT 1
86116: NEG
86117: PUSH
86118: LD_INT 1
86120: NEG
86121: PUSH
86122: EMPTY
86123: LIST
86124: LIST
86125: PUSH
86126: LD_INT 1
86128: NEG
86129: PUSH
86130: LD_INT 2
86132: NEG
86133: PUSH
86134: EMPTY
86135: LIST
86136: LIST
86137: PUSH
86138: LD_INT 1
86140: PUSH
86141: LD_INT 1
86143: NEG
86144: PUSH
86145: EMPTY
86146: LIST
86147: LIST
86148: PUSH
86149: LD_INT 2
86151: PUSH
86152: LD_INT 0
86154: PUSH
86155: EMPTY
86156: LIST
86157: LIST
86158: PUSH
86159: LD_INT 2
86161: PUSH
86162: LD_INT 1
86164: PUSH
86165: EMPTY
86166: LIST
86167: LIST
86168: PUSH
86169: LD_INT 1
86171: PUSH
86172: LD_INT 2
86174: PUSH
86175: EMPTY
86176: LIST
86177: LIST
86178: PUSH
86179: LD_INT 0
86181: PUSH
86182: LD_INT 2
86184: PUSH
86185: EMPTY
86186: LIST
86187: LIST
86188: PUSH
86189: LD_INT 1
86191: NEG
86192: PUSH
86193: LD_INT 1
86195: PUSH
86196: EMPTY
86197: LIST
86198: LIST
86199: PUSH
86200: LD_INT 2
86202: NEG
86203: PUSH
86204: LD_INT 0
86206: PUSH
86207: EMPTY
86208: LIST
86209: LIST
86210: PUSH
86211: LD_INT 2
86213: NEG
86214: PUSH
86215: LD_INT 1
86217: NEG
86218: PUSH
86219: EMPTY
86220: LIST
86221: LIST
86222: PUSH
86223: LD_INT 2
86225: NEG
86226: PUSH
86227: LD_INT 2
86229: NEG
86230: PUSH
86231: EMPTY
86232: LIST
86233: LIST
86234: PUSH
86235: LD_INT 2
86237: NEG
86238: PUSH
86239: LD_INT 3
86241: NEG
86242: PUSH
86243: EMPTY
86244: LIST
86245: LIST
86246: PUSH
86247: LD_INT 2
86249: PUSH
86250: LD_INT 1
86252: NEG
86253: PUSH
86254: EMPTY
86255: LIST
86256: LIST
86257: PUSH
86258: LD_INT 3
86260: PUSH
86261: LD_INT 1
86263: PUSH
86264: EMPTY
86265: LIST
86266: LIST
86267: PUSH
86268: LD_INT 1
86270: PUSH
86271: LD_INT 3
86273: PUSH
86274: EMPTY
86275: LIST
86276: LIST
86277: PUSH
86278: LD_INT 1
86280: NEG
86281: PUSH
86282: LD_INT 2
86284: PUSH
86285: EMPTY
86286: LIST
86287: LIST
86288: PUSH
86289: LD_INT 3
86291: NEG
86292: PUSH
86293: LD_INT 2
86295: NEG
86296: PUSH
86297: EMPTY
86298: LIST
86299: LIST
86300: PUSH
86301: EMPTY
86302: LIST
86303: LIST
86304: LIST
86305: LIST
86306: LIST
86307: LIST
86308: LIST
86309: LIST
86310: LIST
86311: LIST
86312: LIST
86313: LIST
86314: LIST
86315: LIST
86316: LIST
86317: LIST
86318: LIST
86319: LIST
86320: LIST
86321: LIST
86322: LIST
86323: LIST
86324: LIST
86325: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86326: LD_ADDR_VAR 0 34
86330: PUSH
86331: LD_INT 0
86333: PUSH
86334: LD_INT 0
86336: PUSH
86337: EMPTY
86338: LIST
86339: LIST
86340: PUSH
86341: LD_INT 0
86343: PUSH
86344: LD_INT 1
86346: NEG
86347: PUSH
86348: EMPTY
86349: LIST
86350: LIST
86351: PUSH
86352: LD_INT 1
86354: PUSH
86355: LD_INT 0
86357: PUSH
86358: EMPTY
86359: LIST
86360: LIST
86361: PUSH
86362: LD_INT 1
86364: PUSH
86365: LD_INT 1
86367: PUSH
86368: EMPTY
86369: LIST
86370: LIST
86371: PUSH
86372: LD_INT 0
86374: PUSH
86375: LD_INT 1
86377: PUSH
86378: EMPTY
86379: LIST
86380: LIST
86381: PUSH
86382: LD_INT 1
86384: NEG
86385: PUSH
86386: LD_INT 0
86388: PUSH
86389: EMPTY
86390: LIST
86391: LIST
86392: PUSH
86393: LD_INT 1
86395: NEG
86396: PUSH
86397: LD_INT 1
86399: NEG
86400: PUSH
86401: EMPTY
86402: LIST
86403: LIST
86404: PUSH
86405: LD_INT 1
86407: NEG
86408: PUSH
86409: LD_INT 2
86411: NEG
86412: PUSH
86413: EMPTY
86414: LIST
86415: LIST
86416: PUSH
86417: LD_INT 0
86419: PUSH
86420: LD_INT 2
86422: NEG
86423: PUSH
86424: EMPTY
86425: LIST
86426: LIST
86427: PUSH
86428: LD_INT 1
86430: PUSH
86431: LD_INT 1
86433: NEG
86434: PUSH
86435: EMPTY
86436: LIST
86437: LIST
86438: PUSH
86439: LD_INT 2
86441: PUSH
86442: LD_INT 1
86444: PUSH
86445: EMPTY
86446: LIST
86447: LIST
86448: PUSH
86449: LD_INT 2
86451: PUSH
86452: LD_INT 2
86454: PUSH
86455: EMPTY
86456: LIST
86457: LIST
86458: PUSH
86459: LD_INT 1
86461: PUSH
86462: LD_INT 2
86464: PUSH
86465: EMPTY
86466: LIST
86467: LIST
86468: PUSH
86469: LD_INT 1
86471: NEG
86472: PUSH
86473: LD_INT 1
86475: PUSH
86476: EMPTY
86477: LIST
86478: LIST
86479: PUSH
86480: LD_INT 2
86482: NEG
86483: PUSH
86484: LD_INT 0
86486: PUSH
86487: EMPTY
86488: LIST
86489: LIST
86490: PUSH
86491: LD_INT 2
86493: NEG
86494: PUSH
86495: LD_INT 1
86497: NEG
86498: PUSH
86499: EMPTY
86500: LIST
86501: LIST
86502: PUSH
86503: LD_INT 2
86505: NEG
86506: PUSH
86507: LD_INT 2
86509: NEG
86510: PUSH
86511: EMPTY
86512: LIST
86513: LIST
86514: PUSH
86515: LD_INT 1
86517: NEG
86518: PUSH
86519: LD_INT 3
86521: NEG
86522: PUSH
86523: EMPTY
86524: LIST
86525: LIST
86526: PUSH
86527: LD_INT 1
86529: PUSH
86530: LD_INT 2
86532: NEG
86533: PUSH
86534: EMPTY
86535: LIST
86536: LIST
86537: PUSH
86538: LD_INT 3
86540: PUSH
86541: LD_INT 2
86543: PUSH
86544: EMPTY
86545: LIST
86546: LIST
86547: PUSH
86548: LD_INT 2
86550: PUSH
86551: LD_INT 3
86553: PUSH
86554: EMPTY
86555: LIST
86556: LIST
86557: PUSH
86558: LD_INT 2
86560: NEG
86561: PUSH
86562: LD_INT 1
86564: PUSH
86565: EMPTY
86566: LIST
86567: LIST
86568: PUSH
86569: LD_INT 3
86571: NEG
86572: PUSH
86573: LD_INT 1
86575: NEG
86576: PUSH
86577: EMPTY
86578: LIST
86579: LIST
86580: PUSH
86581: EMPTY
86582: LIST
86583: LIST
86584: LIST
86585: LIST
86586: LIST
86587: LIST
86588: LIST
86589: LIST
86590: LIST
86591: LIST
86592: LIST
86593: LIST
86594: LIST
86595: LIST
86596: LIST
86597: LIST
86598: LIST
86599: LIST
86600: LIST
86601: LIST
86602: LIST
86603: LIST
86604: LIST
86605: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86606: LD_ADDR_VAR 0 35
86610: PUSH
86611: LD_INT 0
86613: PUSH
86614: LD_INT 0
86616: PUSH
86617: EMPTY
86618: LIST
86619: LIST
86620: PUSH
86621: LD_INT 0
86623: PUSH
86624: LD_INT 1
86626: NEG
86627: PUSH
86628: EMPTY
86629: LIST
86630: LIST
86631: PUSH
86632: LD_INT 1
86634: PUSH
86635: LD_INT 0
86637: PUSH
86638: EMPTY
86639: LIST
86640: LIST
86641: PUSH
86642: LD_INT 1
86644: PUSH
86645: LD_INT 1
86647: PUSH
86648: EMPTY
86649: LIST
86650: LIST
86651: PUSH
86652: LD_INT 0
86654: PUSH
86655: LD_INT 1
86657: PUSH
86658: EMPTY
86659: LIST
86660: LIST
86661: PUSH
86662: LD_INT 1
86664: NEG
86665: PUSH
86666: LD_INT 0
86668: PUSH
86669: EMPTY
86670: LIST
86671: LIST
86672: PUSH
86673: LD_INT 1
86675: NEG
86676: PUSH
86677: LD_INT 1
86679: NEG
86680: PUSH
86681: EMPTY
86682: LIST
86683: LIST
86684: PUSH
86685: LD_INT 2
86687: PUSH
86688: LD_INT 1
86690: PUSH
86691: EMPTY
86692: LIST
86693: LIST
86694: PUSH
86695: LD_INT 2
86697: NEG
86698: PUSH
86699: LD_INT 1
86701: NEG
86702: PUSH
86703: EMPTY
86704: LIST
86705: LIST
86706: PUSH
86707: EMPTY
86708: LIST
86709: LIST
86710: LIST
86711: LIST
86712: LIST
86713: LIST
86714: LIST
86715: LIST
86716: LIST
86717: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86718: LD_ADDR_VAR 0 36
86722: PUSH
86723: LD_INT 0
86725: PUSH
86726: LD_INT 0
86728: PUSH
86729: EMPTY
86730: LIST
86731: LIST
86732: PUSH
86733: LD_INT 0
86735: PUSH
86736: LD_INT 1
86738: NEG
86739: PUSH
86740: EMPTY
86741: LIST
86742: LIST
86743: PUSH
86744: LD_INT 1
86746: PUSH
86747: LD_INT 0
86749: PUSH
86750: EMPTY
86751: LIST
86752: LIST
86753: PUSH
86754: LD_INT 1
86756: PUSH
86757: LD_INT 1
86759: PUSH
86760: EMPTY
86761: LIST
86762: LIST
86763: PUSH
86764: LD_INT 0
86766: PUSH
86767: LD_INT 1
86769: PUSH
86770: EMPTY
86771: LIST
86772: LIST
86773: PUSH
86774: LD_INT 1
86776: NEG
86777: PUSH
86778: LD_INT 0
86780: PUSH
86781: EMPTY
86782: LIST
86783: LIST
86784: PUSH
86785: LD_INT 1
86787: NEG
86788: PUSH
86789: LD_INT 1
86791: NEG
86792: PUSH
86793: EMPTY
86794: LIST
86795: LIST
86796: PUSH
86797: LD_INT 1
86799: NEG
86800: PUSH
86801: LD_INT 2
86803: NEG
86804: PUSH
86805: EMPTY
86806: LIST
86807: LIST
86808: PUSH
86809: LD_INT 1
86811: PUSH
86812: LD_INT 2
86814: PUSH
86815: EMPTY
86816: LIST
86817: LIST
86818: PUSH
86819: EMPTY
86820: LIST
86821: LIST
86822: LIST
86823: LIST
86824: LIST
86825: LIST
86826: LIST
86827: LIST
86828: LIST
86829: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86830: LD_ADDR_VAR 0 37
86834: PUSH
86835: LD_INT 0
86837: PUSH
86838: LD_INT 0
86840: PUSH
86841: EMPTY
86842: LIST
86843: LIST
86844: PUSH
86845: LD_INT 0
86847: PUSH
86848: LD_INT 1
86850: NEG
86851: PUSH
86852: EMPTY
86853: LIST
86854: LIST
86855: PUSH
86856: LD_INT 1
86858: PUSH
86859: LD_INT 0
86861: PUSH
86862: EMPTY
86863: LIST
86864: LIST
86865: PUSH
86866: LD_INT 1
86868: PUSH
86869: LD_INT 1
86871: PUSH
86872: EMPTY
86873: LIST
86874: LIST
86875: PUSH
86876: LD_INT 0
86878: PUSH
86879: LD_INT 1
86881: PUSH
86882: EMPTY
86883: LIST
86884: LIST
86885: PUSH
86886: LD_INT 1
86888: NEG
86889: PUSH
86890: LD_INT 0
86892: PUSH
86893: EMPTY
86894: LIST
86895: LIST
86896: PUSH
86897: LD_INT 1
86899: NEG
86900: PUSH
86901: LD_INT 1
86903: NEG
86904: PUSH
86905: EMPTY
86906: LIST
86907: LIST
86908: PUSH
86909: LD_INT 1
86911: PUSH
86912: LD_INT 1
86914: NEG
86915: PUSH
86916: EMPTY
86917: LIST
86918: LIST
86919: PUSH
86920: LD_INT 1
86922: NEG
86923: PUSH
86924: LD_INT 1
86926: PUSH
86927: EMPTY
86928: LIST
86929: LIST
86930: PUSH
86931: EMPTY
86932: LIST
86933: LIST
86934: LIST
86935: LIST
86936: LIST
86937: LIST
86938: LIST
86939: LIST
86940: LIST
86941: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86942: LD_ADDR_VAR 0 38
86946: PUSH
86947: LD_INT 0
86949: PUSH
86950: LD_INT 0
86952: PUSH
86953: EMPTY
86954: LIST
86955: LIST
86956: PUSH
86957: LD_INT 0
86959: PUSH
86960: LD_INT 1
86962: NEG
86963: PUSH
86964: EMPTY
86965: LIST
86966: LIST
86967: PUSH
86968: LD_INT 1
86970: PUSH
86971: LD_INT 0
86973: PUSH
86974: EMPTY
86975: LIST
86976: LIST
86977: PUSH
86978: LD_INT 1
86980: PUSH
86981: LD_INT 1
86983: PUSH
86984: EMPTY
86985: LIST
86986: LIST
86987: PUSH
86988: LD_INT 0
86990: PUSH
86991: LD_INT 1
86993: PUSH
86994: EMPTY
86995: LIST
86996: LIST
86997: PUSH
86998: LD_INT 1
87000: NEG
87001: PUSH
87002: LD_INT 0
87004: PUSH
87005: EMPTY
87006: LIST
87007: LIST
87008: PUSH
87009: LD_INT 1
87011: NEG
87012: PUSH
87013: LD_INT 1
87015: NEG
87016: PUSH
87017: EMPTY
87018: LIST
87019: LIST
87020: PUSH
87021: LD_INT 2
87023: PUSH
87024: LD_INT 1
87026: PUSH
87027: EMPTY
87028: LIST
87029: LIST
87030: PUSH
87031: LD_INT 2
87033: NEG
87034: PUSH
87035: LD_INT 1
87037: NEG
87038: PUSH
87039: EMPTY
87040: LIST
87041: LIST
87042: PUSH
87043: EMPTY
87044: LIST
87045: LIST
87046: LIST
87047: LIST
87048: LIST
87049: LIST
87050: LIST
87051: LIST
87052: LIST
87053: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
87054: LD_ADDR_VAR 0 39
87058: PUSH
87059: LD_INT 0
87061: PUSH
87062: LD_INT 0
87064: PUSH
87065: EMPTY
87066: LIST
87067: LIST
87068: PUSH
87069: LD_INT 0
87071: PUSH
87072: LD_INT 1
87074: NEG
87075: PUSH
87076: EMPTY
87077: LIST
87078: LIST
87079: PUSH
87080: LD_INT 1
87082: PUSH
87083: LD_INT 0
87085: PUSH
87086: EMPTY
87087: LIST
87088: LIST
87089: PUSH
87090: LD_INT 1
87092: PUSH
87093: LD_INT 1
87095: PUSH
87096: EMPTY
87097: LIST
87098: LIST
87099: PUSH
87100: LD_INT 0
87102: PUSH
87103: LD_INT 1
87105: PUSH
87106: EMPTY
87107: LIST
87108: LIST
87109: PUSH
87110: LD_INT 1
87112: NEG
87113: PUSH
87114: LD_INT 0
87116: PUSH
87117: EMPTY
87118: LIST
87119: LIST
87120: PUSH
87121: LD_INT 1
87123: NEG
87124: PUSH
87125: LD_INT 1
87127: NEG
87128: PUSH
87129: EMPTY
87130: LIST
87131: LIST
87132: PUSH
87133: LD_INT 1
87135: NEG
87136: PUSH
87137: LD_INT 2
87139: NEG
87140: PUSH
87141: EMPTY
87142: LIST
87143: LIST
87144: PUSH
87145: LD_INT 1
87147: PUSH
87148: LD_INT 2
87150: PUSH
87151: EMPTY
87152: LIST
87153: LIST
87154: PUSH
87155: EMPTY
87156: LIST
87157: LIST
87158: LIST
87159: LIST
87160: LIST
87161: LIST
87162: LIST
87163: LIST
87164: LIST
87165: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
87166: LD_ADDR_VAR 0 40
87170: PUSH
87171: LD_INT 0
87173: PUSH
87174: LD_INT 0
87176: PUSH
87177: EMPTY
87178: LIST
87179: LIST
87180: PUSH
87181: LD_INT 0
87183: PUSH
87184: LD_INT 1
87186: NEG
87187: PUSH
87188: EMPTY
87189: LIST
87190: LIST
87191: PUSH
87192: LD_INT 1
87194: PUSH
87195: LD_INT 0
87197: PUSH
87198: EMPTY
87199: LIST
87200: LIST
87201: PUSH
87202: LD_INT 1
87204: PUSH
87205: LD_INT 1
87207: PUSH
87208: EMPTY
87209: LIST
87210: LIST
87211: PUSH
87212: LD_INT 0
87214: PUSH
87215: LD_INT 1
87217: PUSH
87218: EMPTY
87219: LIST
87220: LIST
87221: PUSH
87222: LD_INT 1
87224: NEG
87225: PUSH
87226: LD_INT 0
87228: PUSH
87229: EMPTY
87230: LIST
87231: LIST
87232: PUSH
87233: LD_INT 1
87235: NEG
87236: PUSH
87237: LD_INT 1
87239: NEG
87240: PUSH
87241: EMPTY
87242: LIST
87243: LIST
87244: PUSH
87245: LD_INT 1
87247: PUSH
87248: LD_INT 1
87250: NEG
87251: PUSH
87252: EMPTY
87253: LIST
87254: LIST
87255: PUSH
87256: LD_INT 1
87258: NEG
87259: PUSH
87260: LD_INT 1
87262: PUSH
87263: EMPTY
87264: LIST
87265: LIST
87266: PUSH
87267: EMPTY
87268: LIST
87269: LIST
87270: LIST
87271: LIST
87272: LIST
87273: LIST
87274: LIST
87275: LIST
87276: LIST
87277: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87278: LD_ADDR_VAR 0 41
87282: PUSH
87283: LD_INT 0
87285: PUSH
87286: LD_INT 0
87288: PUSH
87289: EMPTY
87290: LIST
87291: LIST
87292: PUSH
87293: LD_INT 0
87295: PUSH
87296: LD_INT 1
87298: NEG
87299: PUSH
87300: EMPTY
87301: LIST
87302: LIST
87303: PUSH
87304: LD_INT 1
87306: PUSH
87307: LD_INT 0
87309: PUSH
87310: EMPTY
87311: LIST
87312: LIST
87313: PUSH
87314: LD_INT 1
87316: PUSH
87317: LD_INT 1
87319: PUSH
87320: EMPTY
87321: LIST
87322: LIST
87323: PUSH
87324: LD_INT 0
87326: PUSH
87327: LD_INT 1
87329: PUSH
87330: EMPTY
87331: LIST
87332: LIST
87333: PUSH
87334: LD_INT 1
87336: NEG
87337: PUSH
87338: LD_INT 0
87340: PUSH
87341: EMPTY
87342: LIST
87343: LIST
87344: PUSH
87345: LD_INT 1
87347: NEG
87348: PUSH
87349: LD_INT 1
87351: NEG
87352: PUSH
87353: EMPTY
87354: LIST
87355: LIST
87356: PUSH
87357: LD_INT 1
87359: NEG
87360: PUSH
87361: LD_INT 2
87363: NEG
87364: PUSH
87365: EMPTY
87366: LIST
87367: LIST
87368: PUSH
87369: LD_INT 1
87371: PUSH
87372: LD_INT 1
87374: NEG
87375: PUSH
87376: EMPTY
87377: LIST
87378: LIST
87379: PUSH
87380: LD_INT 2
87382: PUSH
87383: LD_INT 0
87385: PUSH
87386: EMPTY
87387: LIST
87388: LIST
87389: PUSH
87390: LD_INT 2
87392: PUSH
87393: LD_INT 1
87395: PUSH
87396: EMPTY
87397: LIST
87398: LIST
87399: PUSH
87400: LD_INT 2
87402: PUSH
87403: LD_INT 2
87405: PUSH
87406: EMPTY
87407: LIST
87408: LIST
87409: PUSH
87410: LD_INT 1
87412: PUSH
87413: LD_INT 2
87415: PUSH
87416: EMPTY
87417: LIST
87418: LIST
87419: PUSH
87420: LD_INT 1
87422: NEG
87423: PUSH
87424: LD_INT 1
87426: PUSH
87427: EMPTY
87428: LIST
87429: LIST
87430: PUSH
87431: LD_INT 2
87433: NEG
87434: PUSH
87435: LD_INT 0
87437: PUSH
87438: EMPTY
87439: LIST
87440: LIST
87441: PUSH
87442: LD_INT 2
87444: NEG
87445: PUSH
87446: LD_INT 1
87448: NEG
87449: PUSH
87450: EMPTY
87451: LIST
87452: LIST
87453: PUSH
87454: LD_INT 2
87456: NEG
87457: PUSH
87458: LD_INT 2
87460: NEG
87461: PUSH
87462: EMPTY
87463: LIST
87464: LIST
87465: PUSH
87466: LD_INT 2
87468: NEG
87469: PUSH
87470: LD_INT 3
87472: NEG
87473: PUSH
87474: EMPTY
87475: LIST
87476: LIST
87477: PUSH
87478: LD_INT 2
87480: PUSH
87481: LD_INT 1
87483: NEG
87484: PUSH
87485: EMPTY
87486: LIST
87487: LIST
87488: PUSH
87489: LD_INT 3
87491: PUSH
87492: LD_INT 0
87494: PUSH
87495: EMPTY
87496: LIST
87497: LIST
87498: PUSH
87499: LD_INT 3
87501: PUSH
87502: LD_INT 1
87504: PUSH
87505: EMPTY
87506: LIST
87507: LIST
87508: PUSH
87509: LD_INT 3
87511: PUSH
87512: LD_INT 2
87514: PUSH
87515: EMPTY
87516: LIST
87517: LIST
87518: PUSH
87519: LD_INT 3
87521: PUSH
87522: LD_INT 3
87524: PUSH
87525: EMPTY
87526: LIST
87527: LIST
87528: PUSH
87529: LD_INT 2
87531: PUSH
87532: LD_INT 3
87534: PUSH
87535: EMPTY
87536: LIST
87537: LIST
87538: PUSH
87539: LD_INT 2
87541: NEG
87542: PUSH
87543: LD_INT 1
87545: PUSH
87546: EMPTY
87547: LIST
87548: LIST
87549: PUSH
87550: LD_INT 3
87552: NEG
87553: PUSH
87554: LD_INT 0
87556: PUSH
87557: EMPTY
87558: LIST
87559: LIST
87560: PUSH
87561: LD_INT 3
87563: NEG
87564: PUSH
87565: LD_INT 1
87567: NEG
87568: PUSH
87569: EMPTY
87570: LIST
87571: LIST
87572: PUSH
87573: LD_INT 3
87575: NEG
87576: PUSH
87577: LD_INT 2
87579: NEG
87580: PUSH
87581: EMPTY
87582: LIST
87583: LIST
87584: PUSH
87585: LD_INT 3
87587: NEG
87588: PUSH
87589: LD_INT 3
87591: NEG
87592: PUSH
87593: EMPTY
87594: LIST
87595: LIST
87596: PUSH
87597: EMPTY
87598: LIST
87599: LIST
87600: LIST
87601: LIST
87602: LIST
87603: LIST
87604: LIST
87605: LIST
87606: LIST
87607: LIST
87608: LIST
87609: LIST
87610: LIST
87611: LIST
87612: LIST
87613: LIST
87614: LIST
87615: LIST
87616: LIST
87617: LIST
87618: LIST
87619: LIST
87620: LIST
87621: LIST
87622: LIST
87623: LIST
87624: LIST
87625: LIST
87626: LIST
87627: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87628: LD_ADDR_VAR 0 42
87632: PUSH
87633: LD_INT 0
87635: PUSH
87636: LD_INT 0
87638: PUSH
87639: EMPTY
87640: LIST
87641: LIST
87642: PUSH
87643: LD_INT 0
87645: PUSH
87646: LD_INT 1
87648: NEG
87649: PUSH
87650: EMPTY
87651: LIST
87652: LIST
87653: PUSH
87654: LD_INT 1
87656: PUSH
87657: LD_INT 0
87659: PUSH
87660: EMPTY
87661: LIST
87662: LIST
87663: PUSH
87664: LD_INT 1
87666: PUSH
87667: LD_INT 1
87669: PUSH
87670: EMPTY
87671: LIST
87672: LIST
87673: PUSH
87674: LD_INT 0
87676: PUSH
87677: LD_INT 1
87679: PUSH
87680: EMPTY
87681: LIST
87682: LIST
87683: PUSH
87684: LD_INT 1
87686: NEG
87687: PUSH
87688: LD_INT 0
87690: PUSH
87691: EMPTY
87692: LIST
87693: LIST
87694: PUSH
87695: LD_INT 1
87697: NEG
87698: PUSH
87699: LD_INT 1
87701: NEG
87702: PUSH
87703: EMPTY
87704: LIST
87705: LIST
87706: PUSH
87707: LD_INT 1
87709: NEG
87710: PUSH
87711: LD_INT 2
87713: NEG
87714: PUSH
87715: EMPTY
87716: LIST
87717: LIST
87718: PUSH
87719: LD_INT 0
87721: PUSH
87722: LD_INT 2
87724: NEG
87725: PUSH
87726: EMPTY
87727: LIST
87728: LIST
87729: PUSH
87730: LD_INT 1
87732: PUSH
87733: LD_INT 1
87735: NEG
87736: PUSH
87737: EMPTY
87738: LIST
87739: LIST
87740: PUSH
87741: LD_INT 2
87743: PUSH
87744: LD_INT 1
87746: PUSH
87747: EMPTY
87748: LIST
87749: LIST
87750: PUSH
87751: LD_INT 2
87753: PUSH
87754: LD_INT 2
87756: PUSH
87757: EMPTY
87758: LIST
87759: LIST
87760: PUSH
87761: LD_INT 1
87763: PUSH
87764: LD_INT 2
87766: PUSH
87767: EMPTY
87768: LIST
87769: LIST
87770: PUSH
87771: LD_INT 0
87773: PUSH
87774: LD_INT 2
87776: PUSH
87777: EMPTY
87778: LIST
87779: LIST
87780: PUSH
87781: LD_INT 1
87783: NEG
87784: PUSH
87785: LD_INT 1
87787: PUSH
87788: EMPTY
87789: LIST
87790: LIST
87791: PUSH
87792: LD_INT 2
87794: NEG
87795: PUSH
87796: LD_INT 1
87798: NEG
87799: PUSH
87800: EMPTY
87801: LIST
87802: LIST
87803: PUSH
87804: LD_INT 2
87806: NEG
87807: PUSH
87808: LD_INT 2
87810: NEG
87811: PUSH
87812: EMPTY
87813: LIST
87814: LIST
87815: PUSH
87816: LD_INT 2
87818: NEG
87819: PUSH
87820: LD_INT 3
87822: NEG
87823: PUSH
87824: EMPTY
87825: LIST
87826: LIST
87827: PUSH
87828: LD_INT 1
87830: NEG
87831: PUSH
87832: LD_INT 3
87834: NEG
87835: PUSH
87836: EMPTY
87837: LIST
87838: LIST
87839: PUSH
87840: LD_INT 0
87842: PUSH
87843: LD_INT 3
87845: NEG
87846: PUSH
87847: EMPTY
87848: LIST
87849: LIST
87850: PUSH
87851: LD_INT 1
87853: PUSH
87854: LD_INT 2
87856: NEG
87857: PUSH
87858: EMPTY
87859: LIST
87860: LIST
87861: PUSH
87862: LD_INT 3
87864: PUSH
87865: LD_INT 2
87867: PUSH
87868: EMPTY
87869: LIST
87870: LIST
87871: PUSH
87872: LD_INT 3
87874: PUSH
87875: LD_INT 3
87877: PUSH
87878: EMPTY
87879: LIST
87880: LIST
87881: PUSH
87882: LD_INT 2
87884: PUSH
87885: LD_INT 3
87887: PUSH
87888: EMPTY
87889: LIST
87890: LIST
87891: PUSH
87892: LD_INT 1
87894: PUSH
87895: LD_INT 3
87897: PUSH
87898: EMPTY
87899: LIST
87900: LIST
87901: PUSH
87902: LD_INT 0
87904: PUSH
87905: LD_INT 3
87907: PUSH
87908: EMPTY
87909: LIST
87910: LIST
87911: PUSH
87912: LD_INT 1
87914: NEG
87915: PUSH
87916: LD_INT 2
87918: PUSH
87919: EMPTY
87920: LIST
87921: LIST
87922: PUSH
87923: LD_INT 3
87925: NEG
87926: PUSH
87927: LD_INT 2
87929: NEG
87930: PUSH
87931: EMPTY
87932: LIST
87933: LIST
87934: PUSH
87935: LD_INT 3
87937: NEG
87938: PUSH
87939: LD_INT 3
87941: NEG
87942: PUSH
87943: EMPTY
87944: LIST
87945: LIST
87946: PUSH
87947: EMPTY
87948: LIST
87949: LIST
87950: LIST
87951: LIST
87952: LIST
87953: LIST
87954: LIST
87955: LIST
87956: LIST
87957: LIST
87958: LIST
87959: LIST
87960: LIST
87961: LIST
87962: LIST
87963: LIST
87964: LIST
87965: LIST
87966: LIST
87967: LIST
87968: LIST
87969: LIST
87970: LIST
87971: LIST
87972: LIST
87973: LIST
87974: LIST
87975: LIST
87976: LIST
87977: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87978: LD_ADDR_VAR 0 43
87982: PUSH
87983: LD_INT 0
87985: PUSH
87986: LD_INT 0
87988: PUSH
87989: EMPTY
87990: LIST
87991: LIST
87992: PUSH
87993: LD_INT 0
87995: PUSH
87996: LD_INT 1
87998: NEG
87999: PUSH
88000: EMPTY
88001: LIST
88002: LIST
88003: PUSH
88004: LD_INT 1
88006: PUSH
88007: LD_INT 0
88009: PUSH
88010: EMPTY
88011: LIST
88012: LIST
88013: PUSH
88014: LD_INT 1
88016: PUSH
88017: LD_INT 1
88019: PUSH
88020: EMPTY
88021: LIST
88022: LIST
88023: PUSH
88024: LD_INT 0
88026: PUSH
88027: LD_INT 1
88029: PUSH
88030: EMPTY
88031: LIST
88032: LIST
88033: PUSH
88034: LD_INT 1
88036: NEG
88037: PUSH
88038: LD_INT 0
88040: PUSH
88041: EMPTY
88042: LIST
88043: LIST
88044: PUSH
88045: LD_INT 1
88047: NEG
88048: PUSH
88049: LD_INT 1
88051: NEG
88052: PUSH
88053: EMPTY
88054: LIST
88055: LIST
88056: PUSH
88057: LD_INT 1
88059: NEG
88060: PUSH
88061: LD_INT 2
88063: NEG
88064: PUSH
88065: EMPTY
88066: LIST
88067: LIST
88068: PUSH
88069: LD_INT 0
88071: PUSH
88072: LD_INT 2
88074: NEG
88075: PUSH
88076: EMPTY
88077: LIST
88078: LIST
88079: PUSH
88080: LD_INT 1
88082: PUSH
88083: LD_INT 1
88085: NEG
88086: PUSH
88087: EMPTY
88088: LIST
88089: LIST
88090: PUSH
88091: LD_INT 2
88093: PUSH
88094: LD_INT 0
88096: PUSH
88097: EMPTY
88098: LIST
88099: LIST
88100: PUSH
88101: LD_INT 2
88103: PUSH
88104: LD_INT 1
88106: PUSH
88107: EMPTY
88108: LIST
88109: LIST
88110: PUSH
88111: LD_INT 1
88113: PUSH
88114: LD_INT 2
88116: PUSH
88117: EMPTY
88118: LIST
88119: LIST
88120: PUSH
88121: LD_INT 0
88123: PUSH
88124: LD_INT 2
88126: PUSH
88127: EMPTY
88128: LIST
88129: LIST
88130: PUSH
88131: LD_INT 1
88133: NEG
88134: PUSH
88135: LD_INT 1
88137: PUSH
88138: EMPTY
88139: LIST
88140: LIST
88141: PUSH
88142: LD_INT 2
88144: NEG
88145: PUSH
88146: LD_INT 0
88148: PUSH
88149: EMPTY
88150: LIST
88151: LIST
88152: PUSH
88153: LD_INT 2
88155: NEG
88156: PUSH
88157: LD_INT 1
88159: NEG
88160: PUSH
88161: EMPTY
88162: LIST
88163: LIST
88164: PUSH
88165: LD_INT 1
88167: NEG
88168: PUSH
88169: LD_INT 3
88171: NEG
88172: PUSH
88173: EMPTY
88174: LIST
88175: LIST
88176: PUSH
88177: LD_INT 0
88179: PUSH
88180: LD_INT 3
88182: NEG
88183: PUSH
88184: EMPTY
88185: LIST
88186: LIST
88187: PUSH
88188: LD_INT 1
88190: PUSH
88191: LD_INT 2
88193: NEG
88194: PUSH
88195: EMPTY
88196: LIST
88197: LIST
88198: PUSH
88199: LD_INT 2
88201: PUSH
88202: LD_INT 1
88204: NEG
88205: PUSH
88206: EMPTY
88207: LIST
88208: LIST
88209: PUSH
88210: LD_INT 3
88212: PUSH
88213: LD_INT 0
88215: PUSH
88216: EMPTY
88217: LIST
88218: LIST
88219: PUSH
88220: LD_INT 3
88222: PUSH
88223: LD_INT 1
88225: PUSH
88226: EMPTY
88227: LIST
88228: LIST
88229: PUSH
88230: LD_INT 1
88232: PUSH
88233: LD_INT 3
88235: PUSH
88236: EMPTY
88237: LIST
88238: LIST
88239: PUSH
88240: LD_INT 0
88242: PUSH
88243: LD_INT 3
88245: PUSH
88246: EMPTY
88247: LIST
88248: LIST
88249: PUSH
88250: LD_INT 1
88252: NEG
88253: PUSH
88254: LD_INT 2
88256: PUSH
88257: EMPTY
88258: LIST
88259: LIST
88260: PUSH
88261: LD_INT 2
88263: NEG
88264: PUSH
88265: LD_INT 1
88267: PUSH
88268: EMPTY
88269: LIST
88270: LIST
88271: PUSH
88272: LD_INT 3
88274: NEG
88275: PUSH
88276: LD_INT 0
88278: PUSH
88279: EMPTY
88280: LIST
88281: LIST
88282: PUSH
88283: LD_INT 3
88285: NEG
88286: PUSH
88287: LD_INT 1
88289: NEG
88290: PUSH
88291: EMPTY
88292: LIST
88293: LIST
88294: PUSH
88295: EMPTY
88296: LIST
88297: LIST
88298: LIST
88299: LIST
88300: LIST
88301: LIST
88302: LIST
88303: LIST
88304: LIST
88305: LIST
88306: LIST
88307: LIST
88308: LIST
88309: LIST
88310: LIST
88311: LIST
88312: LIST
88313: LIST
88314: LIST
88315: LIST
88316: LIST
88317: LIST
88318: LIST
88319: LIST
88320: LIST
88321: LIST
88322: LIST
88323: LIST
88324: LIST
88325: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88326: LD_ADDR_VAR 0 44
88330: PUSH
88331: LD_INT 0
88333: PUSH
88334: LD_INT 0
88336: PUSH
88337: EMPTY
88338: LIST
88339: LIST
88340: PUSH
88341: LD_INT 0
88343: PUSH
88344: LD_INT 1
88346: NEG
88347: PUSH
88348: EMPTY
88349: LIST
88350: LIST
88351: PUSH
88352: LD_INT 1
88354: PUSH
88355: LD_INT 0
88357: PUSH
88358: EMPTY
88359: LIST
88360: LIST
88361: PUSH
88362: LD_INT 1
88364: PUSH
88365: LD_INT 1
88367: PUSH
88368: EMPTY
88369: LIST
88370: LIST
88371: PUSH
88372: LD_INT 0
88374: PUSH
88375: LD_INT 1
88377: PUSH
88378: EMPTY
88379: LIST
88380: LIST
88381: PUSH
88382: LD_INT 1
88384: NEG
88385: PUSH
88386: LD_INT 0
88388: PUSH
88389: EMPTY
88390: LIST
88391: LIST
88392: PUSH
88393: LD_INT 1
88395: NEG
88396: PUSH
88397: LD_INT 1
88399: NEG
88400: PUSH
88401: EMPTY
88402: LIST
88403: LIST
88404: PUSH
88405: LD_INT 1
88407: NEG
88408: PUSH
88409: LD_INT 2
88411: NEG
88412: PUSH
88413: EMPTY
88414: LIST
88415: LIST
88416: PUSH
88417: LD_INT 1
88419: PUSH
88420: LD_INT 1
88422: NEG
88423: PUSH
88424: EMPTY
88425: LIST
88426: LIST
88427: PUSH
88428: LD_INT 2
88430: PUSH
88431: LD_INT 0
88433: PUSH
88434: EMPTY
88435: LIST
88436: LIST
88437: PUSH
88438: LD_INT 2
88440: PUSH
88441: LD_INT 1
88443: PUSH
88444: EMPTY
88445: LIST
88446: LIST
88447: PUSH
88448: LD_INT 2
88450: PUSH
88451: LD_INT 2
88453: PUSH
88454: EMPTY
88455: LIST
88456: LIST
88457: PUSH
88458: LD_INT 1
88460: PUSH
88461: LD_INT 2
88463: PUSH
88464: EMPTY
88465: LIST
88466: LIST
88467: PUSH
88468: LD_INT 1
88470: NEG
88471: PUSH
88472: LD_INT 1
88474: PUSH
88475: EMPTY
88476: LIST
88477: LIST
88478: PUSH
88479: LD_INT 2
88481: NEG
88482: PUSH
88483: LD_INT 0
88485: PUSH
88486: EMPTY
88487: LIST
88488: LIST
88489: PUSH
88490: LD_INT 2
88492: NEG
88493: PUSH
88494: LD_INT 1
88496: NEG
88497: PUSH
88498: EMPTY
88499: LIST
88500: LIST
88501: PUSH
88502: LD_INT 2
88504: NEG
88505: PUSH
88506: LD_INT 2
88508: NEG
88509: PUSH
88510: EMPTY
88511: LIST
88512: LIST
88513: PUSH
88514: LD_INT 2
88516: NEG
88517: PUSH
88518: LD_INT 3
88520: NEG
88521: PUSH
88522: EMPTY
88523: LIST
88524: LIST
88525: PUSH
88526: LD_INT 2
88528: PUSH
88529: LD_INT 1
88531: NEG
88532: PUSH
88533: EMPTY
88534: LIST
88535: LIST
88536: PUSH
88537: LD_INT 3
88539: PUSH
88540: LD_INT 0
88542: PUSH
88543: EMPTY
88544: LIST
88545: LIST
88546: PUSH
88547: LD_INT 3
88549: PUSH
88550: LD_INT 1
88552: PUSH
88553: EMPTY
88554: LIST
88555: LIST
88556: PUSH
88557: LD_INT 3
88559: PUSH
88560: LD_INT 2
88562: PUSH
88563: EMPTY
88564: LIST
88565: LIST
88566: PUSH
88567: LD_INT 3
88569: PUSH
88570: LD_INT 3
88572: PUSH
88573: EMPTY
88574: LIST
88575: LIST
88576: PUSH
88577: LD_INT 2
88579: PUSH
88580: LD_INT 3
88582: PUSH
88583: EMPTY
88584: LIST
88585: LIST
88586: PUSH
88587: LD_INT 2
88589: NEG
88590: PUSH
88591: LD_INT 1
88593: PUSH
88594: EMPTY
88595: LIST
88596: LIST
88597: PUSH
88598: LD_INT 3
88600: NEG
88601: PUSH
88602: LD_INT 0
88604: PUSH
88605: EMPTY
88606: LIST
88607: LIST
88608: PUSH
88609: LD_INT 3
88611: NEG
88612: PUSH
88613: LD_INT 1
88615: NEG
88616: PUSH
88617: EMPTY
88618: LIST
88619: LIST
88620: PUSH
88621: LD_INT 3
88623: NEG
88624: PUSH
88625: LD_INT 2
88627: NEG
88628: PUSH
88629: EMPTY
88630: LIST
88631: LIST
88632: PUSH
88633: LD_INT 3
88635: NEG
88636: PUSH
88637: LD_INT 3
88639: NEG
88640: PUSH
88641: EMPTY
88642: LIST
88643: LIST
88644: PUSH
88645: EMPTY
88646: LIST
88647: LIST
88648: LIST
88649: LIST
88650: LIST
88651: LIST
88652: LIST
88653: LIST
88654: LIST
88655: LIST
88656: LIST
88657: LIST
88658: LIST
88659: LIST
88660: LIST
88661: LIST
88662: LIST
88663: LIST
88664: LIST
88665: LIST
88666: LIST
88667: LIST
88668: LIST
88669: LIST
88670: LIST
88671: LIST
88672: LIST
88673: LIST
88674: LIST
88675: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88676: LD_ADDR_VAR 0 45
88680: PUSH
88681: LD_INT 0
88683: PUSH
88684: LD_INT 0
88686: PUSH
88687: EMPTY
88688: LIST
88689: LIST
88690: PUSH
88691: LD_INT 0
88693: PUSH
88694: LD_INT 1
88696: NEG
88697: PUSH
88698: EMPTY
88699: LIST
88700: LIST
88701: PUSH
88702: LD_INT 1
88704: PUSH
88705: LD_INT 0
88707: PUSH
88708: EMPTY
88709: LIST
88710: LIST
88711: PUSH
88712: LD_INT 1
88714: PUSH
88715: LD_INT 1
88717: PUSH
88718: EMPTY
88719: LIST
88720: LIST
88721: PUSH
88722: LD_INT 0
88724: PUSH
88725: LD_INT 1
88727: PUSH
88728: EMPTY
88729: LIST
88730: LIST
88731: PUSH
88732: LD_INT 1
88734: NEG
88735: PUSH
88736: LD_INT 0
88738: PUSH
88739: EMPTY
88740: LIST
88741: LIST
88742: PUSH
88743: LD_INT 1
88745: NEG
88746: PUSH
88747: LD_INT 1
88749: NEG
88750: PUSH
88751: EMPTY
88752: LIST
88753: LIST
88754: PUSH
88755: LD_INT 1
88757: NEG
88758: PUSH
88759: LD_INT 2
88761: NEG
88762: PUSH
88763: EMPTY
88764: LIST
88765: LIST
88766: PUSH
88767: LD_INT 0
88769: PUSH
88770: LD_INT 2
88772: NEG
88773: PUSH
88774: EMPTY
88775: LIST
88776: LIST
88777: PUSH
88778: LD_INT 1
88780: PUSH
88781: LD_INT 1
88783: NEG
88784: PUSH
88785: EMPTY
88786: LIST
88787: LIST
88788: PUSH
88789: LD_INT 2
88791: PUSH
88792: LD_INT 1
88794: PUSH
88795: EMPTY
88796: LIST
88797: LIST
88798: PUSH
88799: LD_INT 2
88801: PUSH
88802: LD_INT 2
88804: PUSH
88805: EMPTY
88806: LIST
88807: LIST
88808: PUSH
88809: LD_INT 1
88811: PUSH
88812: LD_INT 2
88814: PUSH
88815: EMPTY
88816: LIST
88817: LIST
88818: PUSH
88819: LD_INT 0
88821: PUSH
88822: LD_INT 2
88824: PUSH
88825: EMPTY
88826: LIST
88827: LIST
88828: PUSH
88829: LD_INT 1
88831: NEG
88832: PUSH
88833: LD_INT 1
88835: PUSH
88836: EMPTY
88837: LIST
88838: LIST
88839: PUSH
88840: LD_INT 2
88842: NEG
88843: PUSH
88844: LD_INT 1
88846: NEG
88847: PUSH
88848: EMPTY
88849: LIST
88850: LIST
88851: PUSH
88852: LD_INT 2
88854: NEG
88855: PUSH
88856: LD_INT 2
88858: NEG
88859: PUSH
88860: EMPTY
88861: LIST
88862: LIST
88863: PUSH
88864: LD_INT 2
88866: NEG
88867: PUSH
88868: LD_INT 3
88870: NEG
88871: PUSH
88872: EMPTY
88873: LIST
88874: LIST
88875: PUSH
88876: LD_INT 1
88878: NEG
88879: PUSH
88880: LD_INT 3
88882: NEG
88883: PUSH
88884: EMPTY
88885: LIST
88886: LIST
88887: PUSH
88888: LD_INT 0
88890: PUSH
88891: LD_INT 3
88893: NEG
88894: PUSH
88895: EMPTY
88896: LIST
88897: LIST
88898: PUSH
88899: LD_INT 1
88901: PUSH
88902: LD_INT 2
88904: NEG
88905: PUSH
88906: EMPTY
88907: LIST
88908: LIST
88909: PUSH
88910: LD_INT 3
88912: PUSH
88913: LD_INT 2
88915: PUSH
88916: EMPTY
88917: LIST
88918: LIST
88919: PUSH
88920: LD_INT 3
88922: PUSH
88923: LD_INT 3
88925: PUSH
88926: EMPTY
88927: LIST
88928: LIST
88929: PUSH
88930: LD_INT 2
88932: PUSH
88933: LD_INT 3
88935: PUSH
88936: EMPTY
88937: LIST
88938: LIST
88939: PUSH
88940: LD_INT 1
88942: PUSH
88943: LD_INT 3
88945: PUSH
88946: EMPTY
88947: LIST
88948: LIST
88949: PUSH
88950: LD_INT 0
88952: PUSH
88953: LD_INT 3
88955: PUSH
88956: EMPTY
88957: LIST
88958: LIST
88959: PUSH
88960: LD_INT 1
88962: NEG
88963: PUSH
88964: LD_INT 2
88966: PUSH
88967: EMPTY
88968: LIST
88969: LIST
88970: PUSH
88971: LD_INT 3
88973: NEG
88974: PUSH
88975: LD_INT 2
88977: NEG
88978: PUSH
88979: EMPTY
88980: LIST
88981: LIST
88982: PUSH
88983: LD_INT 3
88985: NEG
88986: PUSH
88987: LD_INT 3
88989: NEG
88990: PUSH
88991: EMPTY
88992: LIST
88993: LIST
88994: PUSH
88995: EMPTY
88996: LIST
88997: LIST
88998: LIST
88999: LIST
89000: LIST
89001: LIST
89002: LIST
89003: LIST
89004: LIST
89005: LIST
89006: LIST
89007: LIST
89008: LIST
89009: LIST
89010: LIST
89011: LIST
89012: LIST
89013: LIST
89014: LIST
89015: LIST
89016: LIST
89017: LIST
89018: LIST
89019: LIST
89020: LIST
89021: LIST
89022: LIST
89023: LIST
89024: LIST
89025: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89026: LD_ADDR_VAR 0 46
89030: PUSH
89031: LD_INT 0
89033: PUSH
89034: LD_INT 0
89036: PUSH
89037: EMPTY
89038: LIST
89039: LIST
89040: PUSH
89041: LD_INT 0
89043: PUSH
89044: LD_INT 1
89046: NEG
89047: PUSH
89048: EMPTY
89049: LIST
89050: LIST
89051: PUSH
89052: LD_INT 1
89054: PUSH
89055: LD_INT 0
89057: PUSH
89058: EMPTY
89059: LIST
89060: LIST
89061: PUSH
89062: LD_INT 1
89064: PUSH
89065: LD_INT 1
89067: PUSH
89068: EMPTY
89069: LIST
89070: LIST
89071: PUSH
89072: LD_INT 0
89074: PUSH
89075: LD_INT 1
89077: PUSH
89078: EMPTY
89079: LIST
89080: LIST
89081: PUSH
89082: LD_INT 1
89084: NEG
89085: PUSH
89086: LD_INT 0
89088: PUSH
89089: EMPTY
89090: LIST
89091: LIST
89092: PUSH
89093: LD_INT 1
89095: NEG
89096: PUSH
89097: LD_INT 1
89099: NEG
89100: PUSH
89101: EMPTY
89102: LIST
89103: LIST
89104: PUSH
89105: LD_INT 1
89107: NEG
89108: PUSH
89109: LD_INT 2
89111: NEG
89112: PUSH
89113: EMPTY
89114: LIST
89115: LIST
89116: PUSH
89117: LD_INT 0
89119: PUSH
89120: LD_INT 2
89122: NEG
89123: PUSH
89124: EMPTY
89125: LIST
89126: LIST
89127: PUSH
89128: LD_INT 1
89130: PUSH
89131: LD_INT 1
89133: NEG
89134: PUSH
89135: EMPTY
89136: LIST
89137: LIST
89138: PUSH
89139: LD_INT 2
89141: PUSH
89142: LD_INT 0
89144: PUSH
89145: EMPTY
89146: LIST
89147: LIST
89148: PUSH
89149: LD_INT 2
89151: PUSH
89152: LD_INT 1
89154: PUSH
89155: EMPTY
89156: LIST
89157: LIST
89158: PUSH
89159: LD_INT 1
89161: PUSH
89162: LD_INT 2
89164: PUSH
89165: EMPTY
89166: LIST
89167: LIST
89168: PUSH
89169: LD_INT 0
89171: PUSH
89172: LD_INT 2
89174: PUSH
89175: EMPTY
89176: LIST
89177: LIST
89178: PUSH
89179: LD_INT 1
89181: NEG
89182: PUSH
89183: LD_INT 1
89185: PUSH
89186: EMPTY
89187: LIST
89188: LIST
89189: PUSH
89190: LD_INT 2
89192: NEG
89193: PUSH
89194: LD_INT 0
89196: PUSH
89197: EMPTY
89198: LIST
89199: LIST
89200: PUSH
89201: LD_INT 2
89203: NEG
89204: PUSH
89205: LD_INT 1
89207: NEG
89208: PUSH
89209: EMPTY
89210: LIST
89211: LIST
89212: PUSH
89213: LD_INT 1
89215: NEG
89216: PUSH
89217: LD_INT 3
89219: NEG
89220: PUSH
89221: EMPTY
89222: LIST
89223: LIST
89224: PUSH
89225: LD_INT 0
89227: PUSH
89228: LD_INT 3
89230: NEG
89231: PUSH
89232: EMPTY
89233: LIST
89234: LIST
89235: PUSH
89236: LD_INT 1
89238: PUSH
89239: LD_INT 2
89241: NEG
89242: PUSH
89243: EMPTY
89244: LIST
89245: LIST
89246: PUSH
89247: LD_INT 2
89249: PUSH
89250: LD_INT 1
89252: NEG
89253: PUSH
89254: EMPTY
89255: LIST
89256: LIST
89257: PUSH
89258: LD_INT 3
89260: PUSH
89261: LD_INT 0
89263: PUSH
89264: EMPTY
89265: LIST
89266: LIST
89267: PUSH
89268: LD_INT 3
89270: PUSH
89271: LD_INT 1
89273: PUSH
89274: EMPTY
89275: LIST
89276: LIST
89277: PUSH
89278: LD_INT 1
89280: PUSH
89281: LD_INT 3
89283: PUSH
89284: EMPTY
89285: LIST
89286: LIST
89287: PUSH
89288: LD_INT 0
89290: PUSH
89291: LD_INT 3
89293: PUSH
89294: EMPTY
89295: LIST
89296: LIST
89297: PUSH
89298: LD_INT 1
89300: NEG
89301: PUSH
89302: LD_INT 2
89304: PUSH
89305: EMPTY
89306: LIST
89307: LIST
89308: PUSH
89309: LD_INT 2
89311: NEG
89312: PUSH
89313: LD_INT 1
89315: PUSH
89316: EMPTY
89317: LIST
89318: LIST
89319: PUSH
89320: LD_INT 3
89322: NEG
89323: PUSH
89324: LD_INT 0
89326: PUSH
89327: EMPTY
89328: LIST
89329: LIST
89330: PUSH
89331: LD_INT 3
89333: NEG
89334: PUSH
89335: LD_INT 1
89337: NEG
89338: PUSH
89339: EMPTY
89340: LIST
89341: LIST
89342: PUSH
89343: EMPTY
89344: LIST
89345: LIST
89346: LIST
89347: LIST
89348: LIST
89349: LIST
89350: LIST
89351: LIST
89352: LIST
89353: LIST
89354: LIST
89355: LIST
89356: LIST
89357: LIST
89358: LIST
89359: LIST
89360: LIST
89361: LIST
89362: LIST
89363: LIST
89364: LIST
89365: LIST
89366: LIST
89367: LIST
89368: LIST
89369: LIST
89370: LIST
89371: LIST
89372: LIST
89373: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89374: LD_ADDR_VAR 0 47
89378: PUSH
89379: LD_INT 0
89381: PUSH
89382: LD_INT 0
89384: PUSH
89385: EMPTY
89386: LIST
89387: LIST
89388: PUSH
89389: LD_INT 0
89391: PUSH
89392: LD_INT 1
89394: NEG
89395: PUSH
89396: EMPTY
89397: LIST
89398: LIST
89399: PUSH
89400: LD_INT 1
89402: PUSH
89403: LD_INT 0
89405: PUSH
89406: EMPTY
89407: LIST
89408: LIST
89409: PUSH
89410: LD_INT 1
89412: PUSH
89413: LD_INT 1
89415: PUSH
89416: EMPTY
89417: LIST
89418: LIST
89419: PUSH
89420: LD_INT 0
89422: PUSH
89423: LD_INT 1
89425: PUSH
89426: EMPTY
89427: LIST
89428: LIST
89429: PUSH
89430: LD_INT 1
89432: NEG
89433: PUSH
89434: LD_INT 0
89436: PUSH
89437: EMPTY
89438: LIST
89439: LIST
89440: PUSH
89441: LD_INT 1
89443: NEG
89444: PUSH
89445: LD_INT 1
89447: NEG
89448: PUSH
89449: EMPTY
89450: LIST
89451: LIST
89452: PUSH
89453: LD_INT 1
89455: NEG
89456: PUSH
89457: LD_INT 2
89459: NEG
89460: PUSH
89461: EMPTY
89462: LIST
89463: LIST
89464: PUSH
89465: LD_INT 0
89467: PUSH
89468: LD_INT 2
89470: NEG
89471: PUSH
89472: EMPTY
89473: LIST
89474: LIST
89475: PUSH
89476: LD_INT 1
89478: PUSH
89479: LD_INT 1
89481: NEG
89482: PUSH
89483: EMPTY
89484: LIST
89485: LIST
89486: PUSH
89487: LD_INT 2
89489: NEG
89490: PUSH
89491: LD_INT 1
89493: NEG
89494: PUSH
89495: EMPTY
89496: LIST
89497: LIST
89498: PUSH
89499: LD_INT 2
89501: NEG
89502: PUSH
89503: LD_INT 2
89505: NEG
89506: PUSH
89507: EMPTY
89508: LIST
89509: LIST
89510: PUSH
89511: EMPTY
89512: LIST
89513: LIST
89514: LIST
89515: LIST
89516: LIST
89517: LIST
89518: LIST
89519: LIST
89520: LIST
89521: LIST
89522: LIST
89523: LIST
89524: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
89525: LD_ADDR_VAR 0 48
89529: PUSH
89530: LD_INT 0
89532: PUSH
89533: LD_INT 0
89535: PUSH
89536: EMPTY
89537: LIST
89538: LIST
89539: PUSH
89540: LD_INT 0
89542: PUSH
89543: LD_INT 1
89545: NEG
89546: PUSH
89547: EMPTY
89548: LIST
89549: LIST
89550: PUSH
89551: LD_INT 1
89553: PUSH
89554: LD_INT 0
89556: PUSH
89557: EMPTY
89558: LIST
89559: LIST
89560: PUSH
89561: LD_INT 1
89563: PUSH
89564: LD_INT 1
89566: PUSH
89567: EMPTY
89568: LIST
89569: LIST
89570: PUSH
89571: LD_INT 0
89573: PUSH
89574: LD_INT 1
89576: PUSH
89577: EMPTY
89578: LIST
89579: LIST
89580: PUSH
89581: LD_INT 1
89583: NEG
89584: PUSH
89585: LD_INT 0
89587: PUSH
89588: EMPTY
89589: LIST
89590: LIST
89591: PUSH
89592: LD_INT 1
89594: NEG
89595: PUSH
89596: LD_INT 1
89598: NEG
89599: PUSH
89600: EMPTY
89601: LIST
89602: LIST
89603: PUSH
89604: LD_INT 1
89606: NEG
89607: PUSH
89608: LD_INT 2
89610: NEG
89611: PUSH
89612: EMPTY
89613: LIST
89614: LIST
89615: PUSH
89616: LD_INT 0
89618: PUSH
89619: LD_INT 2
89621: NEG
89622: PUSH
89623: EMPTY
89624: LIST
89625: LIST
89626: PUSH
89627: LD_INT 1
89629: PUSH
89630: LD_INT 1
89632: NEG
89633: PUSH
89634: EMPTY
89635: LIST
89636: LIST
89637: PUSH
89638: LD_INT 2
89640: PUSH
89641: LD_INT 0
89643: PUSH
89644: EMPTY
89645: LIST
89646: LIST
89647: PUSH
89648: LD_INT 2
89650: PUSH
89651: LD_INT 1
89653: PUSH
89654: EMPTY
89655: LIST
89656: LIST
89657: PUSH
89658: EMPTY
89659: LIST
89660: LIST
89661: LIST
89662: LIST
89663: LIST
89664: LIST
89665: LIST
89666: LIST
89667: LIST
89668: LIST
89669: LIST
89670: LIST
89671: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
89672: LD_ADDR_VAR 0 49
89676: PUSH
89677: LD_INT 0
89679: PUSH
89680: LD_INT 0
89682: PUSH
89683: EMPTY
89684: LIST
89685: LIST
89686: PUSH
89687: LD_INT 0
89689: PUSH
89690: LD_INT 1
89692: NEG
89693: PUSH
89694: EMPTY
89695: LIST
89696: LIST
89697: PUSH
89698: LD_INT 1
89700: PUSH
89701: LD_INT 0
89703: PUSH
89704: EMPTY
89705: LIST
89706: LIST
89707: PUSH
89708: LD_INT 1
89710: PUSH
89711: LD_INT 1
89713: PUSH
89714: EMPTY
89715: LIST
89716: LIST
89717: PUSH
89718: LD_INT 0
89720: PUSH
89721: LD_INT 1
89723: PUSH
89724: EMPTY
89725: LIST
89726: LIST
89727: PUSH
89728: LD_INT 1
89730: NEG
89731: PUSH
89732: LD_INT 0
89734: PUSH
89735: EMPTY
89736: LIST
89737: LIST
89738: PUSH
89739: LD_INT 1
89741: NEG
89742: PUSH
89743: LD_INT 1
89745: NEG
89746: PUSH
89747: EMPTY
89748: LIST
89749: LIST
89750: PUSH
89751: LD_INT 1
89753: PUSH
89754: LD_INT 1
89756: NEG
89757: PUSH
89758: EMPTY
89759: LIST
89760: LIST
89761: PUSH
89762: LD_INT 2
89764: PUSH
89765: LD_INT 0
89767: PUSH
89768: EMPTY
89769: LIST
89770: LIST
89771: PUSH
89772: LD_INT 2
89774: PUSH
89775: LD_INT 1
89777: PUSH
89778: EMPTY
89779: LIST
89780: LIST
89781: PUSH
89782: LD_INT 2
89784: PUSH
89785: LD_INT 2
89787: PUSH
89788: EMPTY
89789: LIST
89790: LIST
89791: PUSH
89792: LD_INT 1
89794: PUSH
89795: LD_INT 2
89797: PUSH
89798: EMPTY
89799: LIST
89800: LIST
89801: PUSH
89802: EMPTY
89803: LIST
89804: LIST
89805: LIST
89806: LIST
89807: LIST
89808: LIST
89809: LIST
89810: LIST
89811: LIST
89812: LIST
89813: LIST
89814: LIST
89815: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
89816: LD_ADDR_VAR 0 50
89820: PUSH
89821: LD_INT 0
89823: PUSH
89824: LD_INT 0
89826: PUSH
89827: EMPTY
89828: LIST
89829: LIST
89830: PUSH
89831: LD_INT 0
89833: PUSH
89834: LD_INT 1
89836: NEG
89837: PUSH
89838: EMPTY
89839: LIST
89840: LIST
89841: PUSH
89842: LD_INT 1
89844: PUSH
89845: LD_INT 0
89847: PUSH
89848: EMPTY
89849: LIST
89850: LIST
89851: PUSH
89852: LD_INT 1
89854: PUSH
89855: LD_INT 1
89857: PUSH
89858: EMPTY
89859: LIST
89860: LIST
89861: PUSH
89862: LD_INT 0
89864: PUSH
89865: LD_INT 1
89867: PUSH
89868: EMPTY
89869: LIST
89870: LIST
89871: PUSH
89872: LD_INT 1
89874: NEG
89875: PUSH
89876: LD_INT 0
89878: PUSH
89879: EMPTY
89880: LIST
89881: LIST
89882: PUSH
89883: LD_INT 1
89885: NEG
89886: PUSH
89887: LD_INT 1
89889: NEG
89890: PUSH
89891: EMPTY
89892: LIST
89893: LIST
89894: PUSH
89895: LD_INT 2
89897: PUSH
89898: LD_INT 1
89900: PUSH
89901: EMPTY
89902: LIST
89903: LIST
89904: PUSH
89905: LD_INT 2
89907: PUSH
89908: LD_INT 2
89910: PUSH
89911: EMPTY
89912: LIST
89913: LIST
89914: PUSH
89915: LD_INT 1
89917: PUSH
89918: LD_INT 2
89920: PUSH
89921: EMPTY
89922: LIST
89923: LIST
89924: PUSH
89925: LD_INT 0
89927: PUSH
89928: LD_INT 2
89930: PUSH
89931: EMPTY
89932: LIST
89933: LIST
89934: PUSH
89935: LD_INT 1
89937: NEG
89938: PUSH
89939: LD_INT 1
89941: PUSH
89942: EMPTY
89943: LIST
89944: LIST
89945: PUSH
89946: EMPTY
89947: LIST
89948: LIST
89949: LIST
89950: LIST
89951: LIST
89952: LIST
89953: LIST
89954: LIST
89955: LIST
89956: LIST
89957: LIST
89958: LIST
89959: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89960: LD_ADDR_VAR 0 51
89964: PUSH
89965: LD_INT 0
89967: PUSH
89968: LD_INT 0
89970: PUSH
89971: EMPTY
89972: LIST
89973: LIST
89974: PUSH
89975: LD_INT 0
89977: PUSH
89978: LD_INT 1
89980: NEG
89981: PUSH
89982: EMPTY
89983: LIST
89984: LIST
89985: PUSH
89986: LD_INT 1
89988: PUSH
89989: LD_INT 0
89991: PUSH
89992: EMPTY
89993: LIST
89994: LIST
89995: PUSH
89996: LD_INT 1
89998: PUSH
89999: LD_INT 1
90001: PUSH
90002: EMPTY
90003: LIST
90004: LIST
90005: PUSH
90006: LD_INT 0
90008: PUSH
90009: LD_INT 1
90011: PUSH
90012: EMPTY
90013: LIST
90014: LIST
90015: PUSH
90016: LD_INT 1
90018: NEG
90019: PUSH
90020: LD_INT 0
90022: PUSH
90023: EMPTY
90024: LIST
90025: LIST
90026: PUSH
90027: LD_INT 1
90029: NEG
90030: PUSH
90031: LD_INT 1
90033: NEG
90034: PUSH
90035: EMPTY
90036: LIST
90037: LIST
90038: PUSH
90039: LD_INT 1
90041: PUSH
90042: LD_INT 2
90044: PUSH
90045: EMPTY
90046: LIST
90047: LIST
90048: PUSH
90049: LD_INT 0
90051: PUSH
90052: LD_INT 2
90054: PUSH
90055: EMPTY
90056: LIST
90057: LIST
90058: PUSH
90059: LD_INT 1
90061: NEG
90062: PUSH
90063: LD_INT 1
90065: PUSH
90066: EMPTY
90067: LIST
90068: LIST
90069: PUSH
90070: LD_INT 2
90072: NEG
90073: PUSH
90074: LD_INT 0
90076: PUSH
90077: EMPTY
90078: LIST
90079: LIST
90080: PUSH
90081: LD_INT 2
90083: NEG
90084: PUSH
90085: LD_INT 1
90087: NEG
90088: PUSH
90089: EMPTY
90090: LIST
90091: LIST
90092: PUSH
90093: EMPTY
90094: LIST
90095: LIST
90096: LIST
90097: LIST
90098: LIST
90099: LIST
90100: LIST
90101: LIST
90102: LIST
90103: LIST
90104: LIST
90105: LIST
90106: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90107: LD_ADDR_VAR 0 52
90111: PUSH
90112: LD_INT 0
90114: PUSH
90115: LD_INT 0
90117: PUSH
90118: EMPTY
90119: LIST
90120: LIST
90121: PUSH
90122: LD_INT 0
90124: PUSH
90125: LD_INT 1
90127: NEG
90128: PUSH
90129: EMPTY
90130: LIST
90131: LIST
90132: PUSH
90133: LD_INT 1
90135: PUSH
90136: LD_INT 0
90138: PUSH
90139: EMPTY
90140: LIST
90141: LIST
90142: PUSH
90143: LD_INT 1
90145: PUSH
90146: LD_INT 1
90148: PUSH
90149: EMPTY
90150: LIST
90151: LIST
90152: PUSH
90153: LD_INT 0
90155: PUSH
90156: LD_INT 1
90158: PUSH
90159: EMPTY
90160: LIST
90161: LIST
90162: PUSH
90163: LD_INT 1
90165: NEG
90166: PUSH
90167: LD_INT 0
90169: PUSH
90170: EMPTY
90171: LIST
90172: LIST
90173: PUSH
90174: LD_INT 1
90176: NEG
90177: PUSH
90178: LD_INT 1
90180: NEG
90181: PUSH
90182: EMPTY
90183: LIST
90184: LIST
90185: PUSH
90186: LD_INT 1
90188: NEG
90189: PUSH
90190: LD_INT 2
90192: NEG
90193: PUSH
90194: EMPTY
90195: LIST
90196: LIST
90197: PUSH
90198: LD_INT 1
90200: NEG
90201: PUSH
90202: LD_INT 1
90204: PUSH
90205: EMPTY
90206: LIST
90207: LIST
90208: PUSH
90209: LD_INT 2
90211: NEG
90212: PUSH
90213: LD_INT 0
90215: PUSH
90216: EMPTY
90217: LIST
90218: LIST
90219: PUSH
90220: LD_INT 2
90222: NEG
90223: PUSH
90224: LD_INT 1
90226: NEG
90227: PUSH
90228: EMPTY
90229: LIST
90230: LIST
90231: PUSH
90232: LD_INT 2
90234: NEG
90235: PUSH
90236: LD_INT 2
90238: NEG
90239: PUSH
90240: EMPTY
90241: LIST
90242: LIST
90243: PUSH
90244: EMPTY
90245: LIST
90246: LIST
90247: LIST
90248: LIST
90249: LIST
90250: LIST
90251: LIST
90252: LIST
90253: LIST
90254: LIST
90255: LIST
90256: LIST
90257: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90258: LD_ADDR_VAR 0 53
90262: PUSH
90263: LD_INT 0
90265: PUSH
90266: LD_INT 0
90268: PUSH
90269: EMPTY
90270: LIST
90271: LIST
90272: PUSH
90273: LD_INT 0
90275: PUSH
90276: LD_INT 1
90278: NEG
90279: PUSH
90280: EMPTY
90281: LIST
90282: LIST
90283: PUSH
90284: LD_INT 1
90286: PUSH
90287: LD_INT 0
90289: PUSH
90290: EMPTY
90291: LIST
90292: LIST
90293: PUSH
90294: LD_INT 1
90296: PUSH
90297: LD_INT 1
90299: PUSH
90300: EMPTY
90301: LIST
90302: LIST
90303: PUSH
90304: LD_INT 0
90306: PUSH
90307: LD_INT 1
90309: PUSH
90310: EMPTY
90311: LIST
90312: LIST
90313: PUSH
90314: LD_INT 1
90316: NEG
90317: PUSH
90318: LD_INT 0
90320: PUSH
90321: EMPTY
90322: LIST
90323: LIST
90324: PUSH
90325: LD_INT 1
90327: NEG
90328: PUSH
90329: LD_INT 1
90331: NEG
90332: PUSH
90333: EMPTY
90334: LIST
90335: LIST
90336: PUSH
90337: LD_INT 1
90339: NEG
90340: PUSH
90341: LD_INT 2
90343: NEG
90344: PUSH
90345: EMPTY
90346: LIST
90347: LIST
90348: PUSH
90349: LD_INT 0
90351: PUSH
90352: LD_INT 2
90354: NEG
90355: PUSH
90356: EMPTY
90357: LIST
90358: LIST
90359: PUSH
90360: LD_INT 1
90362: PUSH
90363: LD_INT 1
90365: NEG
90366: PUSH
90367: EMPTY
90368: LIST
90369: LIST
90370: PUSH
90371: LD_INT 2
90373: PUSH
90374: LD_INT 0
90376: PUSH
90377: EMPTY
90378: LIST
90379: LIST
90380: PUSH
90381: LD_INT 2
90383: PUSH
90384: LD_INT 1
90386: PUSH
90387: EMPTY
90388: LIST
90389: LIST
90390: PUSH
90391: LD_INT 2
90393: PUSH
90394: LD_INT 2
90396: PUSH
90397: EMPTY
90398: LIST
90399: LIST
90400: PUSH
90401: LD_INT 1
90403: PUSH
90404: LD_INT 2
90406: PUSH
90407: EMPTY
90408: LIST
90409: LIST
90410: PUSH
90411: LD_INT 0
90413: PUSH
90414: LD_INT 2
90416: PUSH
90417: EMPTY
90418: LIST
90419: LIST
90420: PUSH
90421: LD_INT 1
90423: NEG
90424: PUSH
90425: LD_INT 1
90427: PUSH
90428: EMPTY
90429: LIST
90430: LIST
90431: PUSH
90432: LD_INT 2
90434: NEG
90435: PUSH
90436: LD_INT 0
90438: PUSH
90439: EMPTY
90440: LIST
90441: LIST
90442: PUSH
90443: LD_INT 2
90445: NEG
90446: PUSH
90447: LD_INT 1
90449: NEG
90450: PUSH
90451: EMPTY
90452: LIST
90453: LIST
90454: PUSH
90455: LD_INT 2
90457: NEG
90458: PUSH
90459: LD_INT 2
90461: NEG
90462: PUSH
90463: EMPTY
90464: LIST
90465: LIST
90466: PUSH
90467: EMPTY
90468: LIST
90469: LIST
90470: LIST
90471: LIST
90472: LIST
90473: LIST
90474: LIST
90475: LIST
90476: LIST
90477: LIST
90478: LIST
90479: LIST
90480: LIST
90481: LIST
90482: LIST
90483: LIST
90484: LIST
90485: LIST
90486: LIST
90487: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90488: LD_ADDR_VAR 0 54
90492: PUSH
90493: LD_INT 0
90495: PUSH
90496: LD_INT 0
90498: PUSH
90499: EMPTY
90500: LIST
90501: LIST
90502: PUSH
90503: LD_INT 0
90505: PUSH
90506: LD_INT 1
90508: NEG
90509: PUSH
90510: EMPTY
90511: LIST
90512: LIST
90513: PUSH
90514: LD_INT 1
90516: PUSH
90517: LD_INT 0
90519: PUSH
90520: EMPTY
90521: LIST
90522: LIST
90523: PUSH
90524: LD_INT 1
90526: PUSH
90527: LD_INT 1
90529: PUSH
90530: EMPTY
90531: LIST
90532: LIST
90533: PUSH
90534: LD_INT 0
90536: PUSH
90537: LD_INT 1
90539: PUSH
90540: EMPTY
90541: LIST
90542: LIST
90543: PUSH
90544: LD_INT 1
90546: NEG
90547: PUSH
90548: LD_INT 0
90550: PUSH
90551: EMPTY
90552: LIST
90553: LIST
90554: PUSH
90555: LD_INT 1
90557: NEG
90558: PUSH
90559: LD_INT 1
90561: NEG
90562: PUSH
90563: EMPTY
90564: LIST
90565: LIST
90566: PUSH
90567: LD_INT 1
90569: NEG
90570: PUSH
90571: LD_INT 2
90573: NEG
90574: PUSH
90575: EMPTY
90576: LIST
90577: LIST
90578: PUSH
90579: LD_INT 0
90581: PUSH
90582: LD_INT 2
90584: NEG
90585: PUSH
90586: EMPTY
90587: LIST
90588: LIST
90589: PUSH
90590: LD_INT 1
90592: PUSH
90593: LD_INT 1
90595: NEG
90596: PUSH
90597: EMPTY
90598: LIST
90599: LIST
90600: PUSH
90601: LD_INT 2
90603: PUSH
90604: LD_INT 0
90606: PUSH
90607: EMPTY
90608: LIST
90609: LIST
90610: PUSH
90611: LD_INT 2
90613: PUSH
90614: LD_INT 1
90616: PUSH
90617: EMPTY
90618: LIST
90619: LIST
90620: PUSH
90621: LD_INT 2
90623: PUSH
90624: LD_INT 2
90626: PUSH
90627: EMPTY
90628: LIST
90629: LIST
90630: PUSH
90631: LD_INT 1
90633: PUSH
90634: LD_INT 2
90636: PUSH
90637: EMPTY
90638: LIST
90639: LIST
90640: PUSH
90641: LD_INT 0
90643: PUSH
90644: LD_INT 2
90646: PUSH
90647: EMPTY
90648: LIST
90649: LIST
90650: PUSH
90651: LD_INT 1
90653: NEG
90654: PUSH
90655: LD_INT 1
90657: PUSH
90658: EMPTY
90659: LIST
90660: LIST
90661: PUSH
90662: LD_INT 2
90664: NEG
90665: PUSH
90666: LD_INT 0
90668: PUSH
90669: EMPTY
90670: LIST
90671: LIST
90672: PUSH
90673: LD_INT 2
90675: NEG
90676: PUSH
90677: LD_INT 1
90679: NEG
90680: PUSH
90681: EMPTY
90682: LIST
90683: LIST
90684: PUSH
90685: LD_INT 2
90687: NEG
90688: PUSH
90689: LD_INT 2
90691: NEG
90692: PUSH
90693: EMPTY
90694: LIST
90695: LIST
90696: PUSH
90697: EMPTY
90698: LIST
90699: LIST
90700: LIST
90701: LIST
90702: LIST
90703: LIST
90704: LIST
90705: LIST
90706: LIST
90707: LIST
90708: LIST
90709: LIST
90710: LIST
90711: LIST
90712: LIST
90713: LIST
90714: LIST
90715: LIST
90716: LIST
90717: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90718: LD_ADDR_VAR 0 55
90722: PUSH
90723: LD_INT 0
90725: PUSH
90726: LD_INT 0
90728: PUSH
90729: EMPTY
90730: LIST
90731: LIST
90732: PUSH
90733: LD_INT 0
90735: PUSH
90736: LD_INT 1
90738: NEG
90739: PUSH
90740: EMPTY
90741: LIST
90742: LIST
90743: PUSH
90744: LD_INT 1
90746: PUSH
90747: LD_INT 0
90749: PUSH
90750: EMPTY
90751: LIST
90752: LIST
90753: PUSH
90754: LD_INT 1
90756: PUSH
90757: LD_INT 1
90759: PUSH
90760: EMPTY
90761: LIST
90762: LIST
90763: PUSH
90764: LD_INT 0
90766: PUSH
90767: LD_INT 1
90769: PUSH
90770: EMPTY
90771: LIST
90772: LIST
90773: PUSH
90774: LD_INT 1
90776: NEG
90777: PUSH
90778: LD_INT 0
90780: PUSH
90781: EMPTY
90782: LIST
90783: LIST
90784: PUSH
90785: LD_INT 1
90787: NEG
90788: PUSH
90789: LD_INT 1
90791: NEG
90792: PUSH
90793: EMPTY
90794: LIST
90795: LIST
90796: PUSH
90797: LD_INT 1
90799: NEG
90800: PUSH
90801: LD_INT 2
90803: NEG
90804: PUSH
90805: EMPTY
90806: LIST
90807: LIST
90808: PUSH
90809: LD_INT 0
90811: PUSH
90812: LD_INT 2
90814: NEG
90815: PUSH
90816: EMPTY
90817: LIST
90818: LIST
90819: PUSH
90820: LD_INT 1
90822: PUSH
90823: LD_INT 1
90825: NEG
90826: PUSH
90827: EMPTY
90828: LIST
90829: LIST
90830: PUSH
90831: LD_INT 2
90833: PUSH
90834: LD_INT 0
90836: PUSH
90837: EMPTY
90838: LIST
90839: LIST
90840: PUSH
90841: LD_INT 2
90843: PUSH
90844: LD_INT 1
90846: PUSH
90847: EMPTY
90848: LIST
90849: LIST
90850: PUSH
90851: LD_INT 2
90853: PUSH
90854: LD_INT 2
90856: PUSH
90857: EMPTY
90858: LIST
90859: LIST
90860: PUSH
90861: LD_INT 1
90863: PUSH
90864: LD_INT 2
90866: PUSH
90867: EMPTY
90868: LIST
90869: LIST
90870: PUSH
90871: LD_INT 0
90873: PUSH
90874: LD_INT 2
90876: PUSH
90877: EMPTY
90878: LIST
90879: LIST
90880: PUSH
90881: LD_INT 1
90883: NEG
90884: PUSH
90885: LD_INT 1
90887: PUSH
90888: EMPTY
90889: LIST
90890: LIST
90891: PUSH
90892: LD_INT 2
90894: NEG
90895: PUSH
90896: LD_INT 0
90898: PUSH
90899: EMPTY
90900: LIST
90901: LIST
90902: PUSH
90903: LD_INT 2
90905: NEG
90906: PUSH
90907: LD_INT 1
90909: NEG
90910: PUSH
90911: EMPTY
90912: LIST
90913: LIST
90914: PUSH
90915: LD_INT 2
90917: NEG
90918: PUSH
90919: LD_INT 2
90921: NEG
90922: PUSH
90923: EMPTY
90924: LIST
90925: LIST
90926: PUSH
90927: EMPTY
90928: LIST
90929: LIST
90930: LIST
90931: LIST
90932: LIST
90933: LIST
90934: LIST
90935: LIST
90936: LIST
90937: LIST
90938: LIST
90939: LIST
90940: LIST
90941: LIST
90942: LIST
90943: LIST
90944: LIST
90945: LIST
90946: LIST
90947: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90948: LD_ADDR_VAR 0 56
90952: PUSH
90953: LD_INT 0
90955: PUSH
90956: LD_INT 0
90958: PUSH
90959: EMPTY
90960: LIST
90961: LIST
90962: PUSH
90963: LD_INT 0
90965: PUSH
90966: LD_INT 1
90968: NEG
90969: PUSH
90970: EMPTY
90971: LIST
90972: LIST
90973: PUSH
90974: LD_INT 1
90976: PUSH
90977: LD_INT 0
90979: PUSH
90980: EMPTY
90981: LIST
90982: LIST
90983: PUSH
90984: LD_INT 1
90986: PUSH
90987: LD_INT 1
90989: PUSH
90990: EMPTY
90991: LIST
90992: LIST
90993: PUSH
90994: LD_INT 0
90996: PUSH
90997: LD_INT 1
90999: PUSH
91000: EMPTY
91001: LIST
91002: LIST
91003: PUSH
91004: LD_INT 1
91006: NEG
91007: PUSH
91008: LD_INT 0
91010: PUSH
91011: EMPTY
91012: LIST
91013: LIST
91014: PUSH
91015: LD_INT 1
91017: NEG
91018: PUSH
91019: LD_INT 1
91021: NEG
91022: PUSH
91023: EMPTY
91024: LIST
91025: LIST
91026: PUSH
91027: LD_INT 1
91029: NEG
91030: PUSH
91031: LD_INT 2
91033: NEG
91034: PUSH
91035: EMPTY
91036: LIST
91037: LIST
91038: PUSH
91039: LD_INT 0
91041: PUSH
91042: LD_INT 2
91044: NEG
91045: PUSH
91046: EMPTY
91047: LIST
91048: LIST
91049: PUSH
91050: LD_INT 1
91052: PUSH
91053: LD_INT 1
91055: NEG
91056: PUSH
91057: EMPTY
91058: LIST
91059: LIST
91060: PUSH
91061: LD_INT 2
91063: PUSH
91064: LD_INT 0
91066: PUSH
91067: EMPTY
91068: LIST
91069: LIST
91070: PUSH
91071: LD_INT 2
91073: PUSH
91074: LD_INT 1
91076: PUSH
91077: EMPTY
91078: LIST
91079: LIST
91080: PUSH
91081: LD_INT 2
91083: PUSH
91084: LD_INT 2
91086: PUSH
91087: EMPTY
91088: LIST
91089: LIST
91090: PUSH
91091: LD_INT 1
91093: PUSH
91094: LD_INT 2
91096: PUSH
91097: EMPTY
91098: LIST
91099: LIST
91100: PUSH
91101: LD_INT 0
91103: PUSH
91104: LD_INT 2
91106: PUSH
91107: EMPTY
91108: LIST
91109: LIST
91110: PUSH
91111: LD_INT 1
91113: NEG
91114: PUSH
91115: LD_INT 1
91117: PUSH
91118: EMPTY
91119: LIST
91120: LIST
91121: PUSH
91122: LD_INT 2
91124: NEG
91125: PUSH
91126: LD_INT 0
91128: PUSH
91129: EMPTY
91130: LIST
91131: LIST
91132: PUSH
91133: LD_INT 2
91135: NEG
91136: PUSH
91137: LD_INT 1
91139: NEG
91140: PUSH
91141: EMPTY
91142: LIST
91143: LIST
91144: PUSH
91145: LD_INT 2
91147: NEG
91148: PUSH
91149: LD_INT 2
91151: NEG
91152: PUSH
91153: EMPTY
91154: LIST
91155: LIST
91156: PUSH
91157: EMPTY
91158: LIST
91159: LIST
91160: LIST
91161: LIST
91162: LIST
91163: LIST
91164: LIST
91165: LIST
91166: LIST
91167: LIST
91168: LIST
91169: LIST
91170: LIST
91171: LIST
91172: LIST
91173: LIST
91174: LIST
91175: LIST
91176: LIST
91177: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91178: LD_ADDR_VAR 0 57
91182: PUSH
91183: LD_INT 0
91185: PUSH
91186: LD_INT 0
91188: PUSH
91189: EMPTY
91190: LIST
91191: LIST
91192: PUSH
91193: LD_INT 0
91195: PUSH
91196: LD_INT 1
91198: NEG
91199: PUSH
91200: EMPTY
91201: LIST
91202: LIST
91203: PUSH
91204: LD_INT 1
91206: PUSH
91207: LD_INT 0
91209: PUSH
91210: EMPTY
91211: LIST
91212: LIST
91213: PUSH
91214: LD_INT 1
91216: PUSH
91217: LD_INT 1
91219: PUSH
91220: EMPTY
91221: LIST
91222: LIST
91223: PUSH
91224: LD_INT 0
91226: PUSH
91227: LD_INT 1
91229: PUSH
91230: EMPTY
91231: LIST
91232: LIST
91233: PUSH
91234: LD_INT 1
91236: NEG
91237: PUSH
91238: LD_INT 0
91240: PUSH
91241: EMPTY
91242: LIST
91243: LIST
91244: PUSH
91245: LD_INT 1
91247: NEG
91248: PUSH
91249: LD_INT 1
91251: NEG
91252: PUSH
91253: EMPTY
91254: LIST
91255: LIST
91256: PUSH
91257: LD_INT 1
91259: NEG
91260: PUSH
91261: LD_INT 2
91263: NEG
91264: PUSH
91265: EMPTY
91266: LIST
91267: LIST
91268: PUSH
91269: LD_INT 0
91271: PUSH
91272: LD_INT 2
91274: NEG
91275: PUSH
91276: EMPTY
91277: LIST
91278: LIST
91279: PUSH
91280: LD_INT 1
91282: PUSH
91283: LD_INT 1
91285: NEG
91286: PUSH
91287: EMPTY
91288: LIST
91289: LIST
91290: PUSH
91291: LD_INT 2
91293: PUSH
91294: LD_INT 0
91296: PUSH
91297: EMPTY
91298: LIST
91299: LIST
91300: PUSH
91301: LD_INT 2
91303: PUSH
91304: LD_INT 1
91306: PUSH
91307: EMPTY
91308: LIST
91309: LIST
91310: PUSH
91311: LD_INT 2
91313: PUSH
91314: LD_INT 2
91316: PUSH
91317: EMPTY
91318: LIST
91319: LIST
91320: PUSH
91321: LD_INT 1
91323: PUSH
91324: LD_INT 2
91326: PUSH
91327: EMPTY
91328: LIST
91329: LIST
91330: PUSH
91331: LD_INT 0
91333: PUSH
91334: LD_INT 2
91336: PUSH
91337: EMPTY
91338: LIST
91339: LIST
91340: PUSH
91341: LD_INT 1
91343: NEG
91344: PUSH
91345: LD_INT 1
91347: PUSH
91348: EMPTY
91349: LIST
91350: LIST
91351: PUSH
91352: LD_INT 2
91354: NEG
91355: PUSH
91356: LD_INT 0
91358: PUSH
91359: EMPTY
91360: LIST
91361: LIST
91362: PUSH
91363: LD_INT 2
91365: NEG
91366: PUSH
91367: LD_INT 1
91369: NEG
91370: PUSH
91371: EMPTY
91372: LIST
91373: LIST
91374: PUSH
91375: LD_INT 2
91377: NEG
91378: PUSH
91379: LD_INT 2
91381: NEG
91382: PUSH
91383: EMPTY
91384: LIST
91385: LIST
91386: PUSH
91387: EMPTY
91388: LIST
91389: LIST
91390: LIST
91391: LIST
91392: LIST
91393: LIST
91394: LIST
91395: LIST
91396: LIST
91397: LIST
91398: LIST
91399: LIST
91400: LIST
91401: LIST
91402: LIST
91403: LIST
91404: LIST
91405: LIST
91406: LIST
91407: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91408: LD_ADDR_VAR 0 58
91412: PUSH
91413: LD_INT 0
91415: PUSH
91416: LD_INT 0
91418: PUSH
91419: EMPTY
91420: LIST
91421: LIST
91422: PUSH
91423: LD_INT 0
91425: PUSH
91426: LD_INT 1
91428: NEG
91429: PUSH
91430: EMPTY
91431: LIST
91432: LIST
91433: PUSH
91434: LD_INT 1
91436: PUSH
91437: LD_INT 0
91439: PUSH
91440: EMPTY
91441: LIST
91442: LIST
91443: PUSH
91444: LD_INT 1
91446: PUSH
91447: LD_INT 1
91449: PUSH
91450: EMPTY
91451: LIST
91452: LIST
91453: PUSH
91454: LD_INT 0
91456: PUSH
91457: LD_INT 1
91459: PUSH
91460: EMPTY
91461: LIST
91462: LIST
91463: PUSH
91464: LD_INT 1
91466: NEG
91467: PUSH
91468: LD_INT 0
91470: PUSH
91471: EMPTY
91472: LIST
91473: LIST
91474: PUSH
91475: LD_INT 1
91477: NEG
91478: PUSH
91479: LD_INT 1
91481: NEG
91482: PUSH
91483: EMPTY
91484: LIST
91485: LIST
91486: PUSH
91487: LD_INT 1
91489: NEG
91490: PUSH
91491: LD_INT 2
91493: NEG
91494: PUSH
91495: EMPTY
91496: LIST
91497: LIST
91498: PUSH
91499: LD_INT 0
91501: PUSH
91502: LD_INT 2
91504: NEG
91505: PUSH
91506: EMPTY
91507: LIST
91508: LIST
91509: PUSH
91510: LD_INT 1
91512: PUSH
91513: LD_INT 1
91515: NEG
91516: PUSH
91517: EMPTY
91518: LIST
91519: LIST
91520: PUSH
91521: LD_INT 2
91523: PUSH
91524: LD_INT 0
91526: PUSH
91527: EMPTY
91528: LIST
91529: LIST
91530: PUSH
91531: LD_INT 2
91533: PUSH
91534: LD_INT 1
91536: PUSH
91537: EMPTY
91538: LIST
91539: LIST
91540: PUSH
91541: LD_INT 2
91543: PUSH
91544: LD_INT 2
91546: PUSH
91547: EMPTY
91548: LIST
91549: LIST
91550: PUSH
91551: LD_INT 1
91553: PUSH
91554: LD_INT 2
91556: PUSH
91557: EMPTY
91558: LIST
91559: LIST
91560: PUSH
91561: LD_INT 0
91563: PUSH
91564: LD_INT 2
91566: PUSH
91567: EMPTY
91568: LIST
91569: LIST
91570: PUSH
91571: LD_INT 1
91573: NEG
91574: PUSH
91575: LD_INT 1
91577: PUSH
91578: EMPTY
91579: LIST
91580: LIST
91581: PUSH
91582: LD_INT 2
91584: NEG
91585: PUSH
91586: LD_INT 0
91588: PUSH
91589: EMPTY
91590: LIST
91591: LIST
91592: PUSH
91593: LD_INT 2
91595: NEG
91596: PUSH
91597: LD_INT 1
91599: NEG
91600: PUSH
91601: EMPTY
91602: LIST
91603: LIST
91604: PUSH
91605: LD_INT 2
91607: NEG
91608: PUSH
91609: LD_INT 2
91611: NEG
91612: PUSH
91613: EMPTY
91614: LIST
91615: LIST
91616: PUSH
91617: EMPTY
91618: LIST
91619: LIST
91620: LIST
91621: LIST
91622: LIST
91623: LIST
91624: LIST
91625: LIST
91626: LIST
91627: LIST
91628: LIST
91629: LIST
91630: LIST
91631: LIST
91632: LIST
91633: LIST
91634: LIST
91635: LIST
91636: LIST
91637: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91638: LD_ADDR_VAR 0 59
91642: PUSH
91643: LD_INT 0
91645: PUSH
91646: LD_INT 0
91648: PUSH
91649: EMPTY
91650: LIST
91651: LIST
91652: PUSH
91653: LD_INT 0
91655: PUSH
91656: LD_INT 1
91658: NEG
91659: PUSH
91660: EMPTY
91661: LIST
91662: LIST
91663: PUSH
91664: LD_INT 1
91666: PUSH
91667: LD_INT 0
91669: PUSH
91670: EMPTY
91671: LIST
91672: LIST
91673: PUSH
91674: LD_INT 1
91676: PUSH
91677: LD_INT 1
91679: PUSH
91680: EMPTY
91681: LIST
91682: LIST
91683: PUSH
91684: LD_INT 0
91686: PUSH
91687: LD_INT 1
91689: PUSH
91690: EMPTY
91691: LIST
91692: LIST
91693: PUSH
91694: LD_INT 1
91696: NEG
91697: PUSH
91698: LD_INT 0
91700: PUSH
91701: EMPTY
91702: LIST
91703: LIST
91704: PUSH
91705: LD_INT 1
91707: NEG
91708: PUSH
91709: LD_INT 1
91711: NEG
91712: PUSH
91713: EMPTY
91714: LIST
91715: LIST
91716: PUSH
91717: EMPTY
91718: LIST
91719: LIST
91720: LIST
91721: LIST
91722: LIST
91723: LIST
91724: LIST
91725: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91726: LD_ADDR_VAR 0 60
91730: PUSH
91731: LD_INT 0
91733: PUSH
91734: LD_INT 0
91736: PUSH
91737: EMPTY
91738: LIST
91739: LIST
91740: PUSH
91741: LD_INT 0
91743: PUSH
91744: LD_INT 1
91746: NEG
91747: PUSH
91748: EMPTY
91749: LIST
91750: LIST
91751: PUSH
91752: LD_INT 1
91754: PUSH
91755: LD_INT 0
91757: PUSH
91758: EMPTY
91759: LIST
91760: LIST
91761: PUSH
91762: LD_INT 1
91764: PUSH
91765: LD_INT 1
91767: PUSH
91768: EMPTY
91769: LIST
91770: LIST
91771: PUSH
91772: LD_INT 0
91774: PUSH
91775: LD_INT 1
91777: PUSH
91778: EMPTY
91779: LIST
91780: LIST
91781: PUSH
91782: LD_INT 1
91784: NEG
91785: PUSH
91786: LD_INT 0
91788: PUSH
91789: EMPTY
91790: LIST
91791: LIST
91792: PUSH
91793: LD_INT 1
91795: NEG
91796: PUSH
91797: LD_INT 1
91799: NEG
91800: PUSH
91801: EMPTY
91802: LIST
91803: LIST
91804: PUSH
91805: EMPTY
91806: LIST
91807: LIST
91808: LIST
91809: LIST
91810: LIST
91811: LIST
91812: LIST
91813: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91814: LD_ADDR_VAR 0 61
91818: PUSH
91819: LD_INT 0
91821: PUSH
91822: LD_INT 0
91824: PUSH
91825: EMPTY
91826: LIST
91827: LIST
91828: PUSH
91829: LD_INT 0
91831: PUSH
91832: LD_INT 1
91834: NEG
91835: PUSH
91836: EMPTY
91837: LIST
91838: LIST
91839: PUSH
91840: LD_INT 1
91842: PUSH
91843: LD_INT 0
91845: PUSH
91846: EMPTY
91847: LIST
91848: LIST
91849: PUSH
91850: LD_INT 1
91852: PUSH
91853: LD_INT 1
91855: PUSH
91856: EMPTY
91857: LIST
91858: LIST
91859: PUSH
91860: LD_INT 0
91862: PUSH
91863: LD_INT 1
91865: PUSH
91866: EMPTY
91867: LIST
91868: LIST
91869: PUSH
91870: LD_INT 1
91872: NEG
91873: PUSH
91874: LD_INT 0
91876: PUSH
91877: EMPTY
91878: LIST
91879: LIST
91880: PUSH
91881: LD_INT 1
91883: NEG
91884: PUSH
91885: LD_INT 1
91887: NEG
91888: PUSH
91889: EMPTY
91890: LIST
91891: LIST
91892: PUSH
91893: EMPTY
91894: LIST
91895: LIST
91896: LIST
91897: LIST
91898: LIST
91899: LIST
91900: LIST
91901: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91902: LD_ADDR_VAR 0 62
91906: PUSH
91907: LD_INT 0
91909: PUSH
91910: LD_INT 0
91912: PUSH
91913: EMPTY
91914: LIST
91915: LIST
91916: PUSH
91917: LD_INT 0
91919: PUSH
91920: LD_INT 1
91922: NEG
91923: PUSH
91924: EMPTY
91925: LIST
91926: LIST
91927: PUSH
91928: LD_INT 1
91930: PUSH
91931: LD_INT 0
91933: PUSH
91934: EMPTY
91935: LIST
91936: LIST
91937: PUSH
91938: LD_INT 1
91940: PUSH
91941: LD_INT 1
91943: PUSH
91944: EMPTY
91945: LIST
91946: LIST
91947: PUSH
91948: LD_INT 0
91950: PUSH
91951: LD_INT 1
91953: PUSH
91954: EMPTY
91955: LIST
91956: LIST
91957: PUSH
91958: LD_INT 1
91960: NEG
91961: PUSH
91962: LD_INT 0
91964: PUSH
91965: EMPTY
91966: LIST
91967: LIST
91968: PUSH
91969: LD_INT 1
91971: NEG
91972: PUSH
91973: LD_INT 1
91975: NEG
91976: PUSH
91977: EMPTY
91978: LIST
91979: LIST
91980: PUSH
91981: EMPTY
91982: LIST
91983: LIST
91984: LIST
91985: LIST
91986: LIST
91987: LIST
91988: LIST
91989: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91990: LD_ADDR_VAR 0 63
91994: PUSH
91995: LD_INT 0
91997: PUSH
91998: LD_INT 0
92000: PUSH
92001: EMPTY
92002: LIST
92003: LIST
92004: PUSH
92005: LD_INT 0
92007: PUSH
92008: LD_INT 1
92010: NEG
92011: PUSH
92012: EMPTY
92013: LIST
92014: LIST
92015: PUSH
92016: LD_INT 1
92018: PUSH
92019: LD_INT 0
92021: PUSH
92022: EMPTY
92023: LIST
92024: LIST
92025: PUSH
92026: LD_INT 1
92028: PUSH
92029: LD_INT 1
92031: PUSH
92032: EMPTY
92033: LIST
92034: LIST
92035: PUSH
92036: LD_INT 0
92038: PUSH
92039: LD_INT 1
92041: PUSH
92042: EMPTY
92043: LIST
92044: LIST
92045: PUSH
92046: LD_INT 1
92048: NEG
92049: PUSH
92050: LD_INT 0
92052: PUSH
92053: EMPTY
92054: LIST
92055: LIST
92056: PUSH
92057: LD_INT 1
92059: NEG
92060: PUSH
92061: LD_INT 1
92063: NEG
92064: PUSH
92065: EMPTY
92066: LIST
92067: LIST
92068: PUSH
92069: EMPTY
92070: LIST
92071: LIST
92072: LIST
92073: LIST
92074: LIST
92075: LIST
92076: LIST
92077: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92078: LD_ADDR_VAR 0 64
92082: PUSH
92083: LD_INT 0
92085: PUSH
92086: LD_INT 0
92088: PUSH
92089: EMPTY
92090: LIST
92091: LIST
92092: PUSH
92093: LD_INT 0
92095: PUSH
92096: LD_INT 1
92098: NEG
92099: PUSH
92100: EMPTY
92101: LIST
92102: LIST
92103: PUSH
92104: LD_INT 1
92106: PUSH
92107: LD_INT 0
92109: PUSH
92110: EMPTY
92111: LIST
92112: LIST
92113: PUSH
92114: LD_INT 1
92116: PUSH
92117: LD_INT 1
92119: PUSH
92120: EMPTY
92121: LIST
92122: LIST
92123: PUSH
92124: LD_INT 0
92126: PUSH
92127: LD_INT 1
92129: PUSH
92130: EMPTY
92131: LIST
92132: LIST
92133: PUSH
92134: LD_INT 1
92136: NEG
92137: PUSH
92138: LD_INT 0
92140: PUSH
92141: EMPTY
92142: LIST
92143: LIST
92144: PUSH
92145: LD_INT 1
92147: NEG
92148: PUSH
92149: LD_INT 1
92151: NEG
92152: PUSH
92153: EMPTY
92154: LIST
92155: LIST
92156: PUSH
92157: EMPTY
92158: LIST
92159: LIST
92160: LIST
92161: LIST
92162: LIST
92163: LIST
92164: LIST
92165: ST_TO_ADDR
// end ; 1 :
92166: GO 98063
92168: LD_INT 1
92170: DOUBLE
92171: EQUAL
92172: IFTRUE 92176
92174: GO 94799
92176: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92177: LD_ADDR_VAR 0 11
92181: PUSH
92182: LD_INT 1
92184: NEG
92185: PUSH
92186: LD_INT 3
92188: NEG
92189: PUSH
92190: EMPTY
92191: LIST
92192: LIST
92193: PUSH
92194: LD_INT 0
92196: PUSH
92197: LD_INT 3
92199: NEG
92200: PUSH
92201: EMPTY
92202: LIST
92203: LIST
92204: PUSH
92205: LD_INT 1
92207: PUSH
92208: LD_INT 2
92210: NEG
92211: PUSH
92212: EMPTY
92213: LIST
92214: LIST
92215: PUSH
92216: EMPTY
92217: LIST
92218: LIST
92219: LIST
92220: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92221: LD_ADDR_VAR 0 12
92225: PUSH
92226: LD_INT 2
92228: PUSH
92229: LD_INT 1
92231: NEG
92232: PUSH
92233: EMPTY
92234: LIST
92235: LIST
92236: PUSH
92237: LD_INT 3
92239: PUSH
92240: LD_INT 0
92242: PUSH
92243: EMPTY
92244: LIST
92245: LIST
92246: PUSH
92247: LD_INT 3
92249: PUSH
92250: LD_INT 1
92252: PUSH
92253: EMPTY
92254: LIST
92255: LIST
92256: PUSH
92257: EMPTY
92258: LIST
92259: LIST
92260: LIST
92261: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92262: LD_ADDR_VAR 0 13
92266: PUSH
92267: LD_INT 3
92269: PUSH
92270: LD_INT 2
92272: PUSH
92273: EMPTY
92274: LIST
92275: LIST
92276: PUSH
92277: LD_INT 3
92279: PUSH
92280: LD_INT 3
92282: PUSH
92283: EMPTY
92284: LIST
92285: LIST
92286: PUSH
92287: LD_INT 2
92289: PUSH
92290: LD_INT 3
92292: PUSH
92293: EMPTY
92294: LIST
92295: LIST
92296: PUSH
92297: EMPTY
92298: LIST
92299: LIST
92300: LIST
92301: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92302: LD_ADDR_VAR 0 14
92306: PUSH
92307: LD_INT 1
92309: PUSH
92310: LD_INT 3
92312: PUSH
92313: EMPTY
92314: LIST
92315: LIST
92316: PUSH
92317: LD_INT 0
92319: PUSH
92320: LD_INT 3
92322: PUSH
92323: EMPTY
92324: LIST
92325: LIST
92326: PUSH
92327: LD_INT 1
92329: NEG
92330: PUSH
92331: LD_INT 2
92333: PUSH
92334: EMPTY
92335: LIST
92336: LIST
92337: PUSH
92338: EMPTY
92339: LIST
92340: LIST
92341: LIST
92342: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92343: LD_ADDR_VAR 0 15
92347: PUSH
92348: LD_INT 2
92350: NEG
92351: PUSH
92352: LD_INT 1
92354: PUSH
92355: EMPTY
92356: LIST
92357: LIST
92358: PUSH
92359: LD_INT 3
92361: NEG
92362: PUSH
92363: LD_INT 0
92365: PUSH
92366: EMPTY
92367: LIST
92368: LIST
92369: PUSH
92370: LD_INT 3
92372: NEG
92373: PUSH
92374: LD_INT 1
92376: NEG
92377: PUSH
92378: EMPTY
92379: LIST
92380: LIST
92381: PUSH
92382: EMPTY
92383: LIST
92384: LIST
92385: LIST
92386: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92387: LD_ADDR_VAR 0 16
92391: PUSH
92392: LD_INT 2
92394: NEG
92395: PUSH
92396: LD_INT 3
92398: NEG
92399: PUSH
92400: EMPTY
92401: LIST
92402: LIST
92403: PUSH
92404: LD_INT 3
92406: NEG
92407: PUSH
92408: LD_INT 2
92410: NEG
92411: PUSH
92412: EMPTY
92413: LIST
92414: LIST
92415: PUSH
92416: LD_INT 3
92418: NEG
92419: PUSH
92420: LD_INT 3
92422: NEG
92423: PUSH
92424: EMPTY
92425: LIST
92426: LIST
92427: PUSH
92428: EMPTY
92429: LIST
92430: LIST
92431: LIST
92432: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92433: LD_ADDR_VAR 0 17
92437: PUSH
92438: LD_INT 1
92440: NEG
92441: PUSH
92442: LD_INT 3
92444: NEG
92445: PUSH
92446: EMPTY
92447: LIST
92448: LIST
92449: PUSH
92450: LD_INT 0
92452: PUSH
92453: LD_INT 3
92455: NEG
92456: PUSH
92457: EMPTY
92458: LIST
92459: LIST
92460: PUSH
92461: LD_INT 1
92463: PUSH
92464: LD_INT 2
92466: NEG
92467: PUSH
92468: EMPTY
92469: LIST
92470: LIST
92471: PUSH
92472: EMPTY
92473: LIST
92474: LIST
92475: LIST
92476: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92477: LD_ADDR_VAR 0 18
92481: PUSH
92482: LD_INT 2
92484: PUSH
92485: LD_INT 1
92487: NEG
92488: PUSH
92489: EMPTY
92490: LIST
92491: LIST
92492: PUSH
92493: LD_INT 3
92495: PUSH
92496: LD_INT 0
92498: PUSH
92499: EMPTY
92500: LIST
92501: LIST
92502: PUSH
92503: LD_INT 3
92505: PUSH
92506: LD_INT 1
92508: PUSH
92509: EMPTY
92510: LIST
92511: LIST
92512: PUSH
92513: EMPTY
92514: LIST
92515: LIST
92516: LIST
92517: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92518: LD_ADDR_VAR 0 19
92522: PUSH
92523: LD_INT 3
92525: PUSH
92526: LD_INT 2
92528: PUSH
92529: EMPTY
92530: LIST
92531: LIST
92532: PUSH
92533: LD_INT 3
92535: PUSH
92536: LD_INT 3
92538: PUSH
92539: EMPTY
92540: LIST
92541: LIST
92542: PUSH
92543: LD_INT 2
92545: PUSH
92546: LD_INT 3
92548: PUSH
92549: EMPTY
92550: LIST
92551: LIST
92552: PUSH
92553: EMPTY
92554: LIST
92555: LIST
92556: LIST
92557: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92558: LD_ADDR_VAR 0 20
92562: PUSH
92563: LD_INT 1
92565: PUSH
92566: LD_INT 3
92568: PUSH
92569: EMPTY
92570: LIST
92571: LIST
92572: PUSH
92573: LD_INT 0
92575: PUSH
92576: LD_INT 3
92578: PUSH
92579: EMPTY
92580: LIST
92581: LIST
92582: PUSH
92583: LD_INT 1
92585: NEG
92586: PUSH
92587: LD_INT 2
92589: PUSH
92590: EMPTY
92591: LIST
92592: LIST
92593: PUSH
92594: EMPTY
92595: LIST
92596: LIST
92597: LIST
92598: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92599: LD_ADDR_VAR 0 21
92603: PUSH
92604: LD_INT 2
92606: NEG
92607: PUSH
92608: LD_INT 1
92610: PUSH
92611: EMPTY
92612: LIST
92613: LIST
92614: PUSH
92615: LD_INT 3
92617: NEG
92618: PUSH
92619: LD_INT 0
92621: PUSH
92622: EMPTY
92623: LIST
92624: LIST
92625: PUSH
92626: LD_INT 3
92628: NEG
92629: PUSH
92630: LD_INT 1
92632: NEG
92633: PUSH
92634: EMPTY
92635: LIST
92636: LIST
92637: PUSH
92638: EMPTY
92639: LIST
92640: LIST
92641: LIST
92642: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92643: LD_ADDR_VAR 0 22
92647: PUSH
92648: LD_INT 2
92650: NEG
92651: PUSH
92652: LD_INT 3
92654: NEG
92655: PUSH
92656: EMPTY
92657: LIST
92658: LIST
92659: PUSH
92660: LD_INT 3
92662: NEG
92663: PUSH
92664: LD_INT 2
92666: NEG
92667: PUSH
92668: EMPTY
92669: LIST
92670: LIST
92671: PUSH
92672: LD_INT 3
92674: NEG
92675: PUSH
92676: LD_INT 3
92678: NEG
92679: PUSH
92680: EMPTY
92681: LIST
92682: LIST
92683: PUSH
92684: EMPTY
92685: LIST
92686: LIST
92687: LIST
92688: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
92689: LD_ADDR_VAR 0 23
92693: PUSH
92694: LD_INT 0
92696: PUSH
92697: LD_INT 3
92699: NEG
92700: PUSH
92701: EMPTY
92702: LIST
92703: LIST
92704: PUSH
92705: LD_INT 1
92707: NEG
92708: PUSH
92709: LD_INT 4
92711: NEG
92712: PUSH
92713: EMPTY
92714: LIST
92715: LIST
92716: PUSH
92717: LD_INT 1
92719: PUSH
92720: LD_INT 3
92722: NEG
92723: PUSH
92724: EMPTY
92725: LIST
92726: LIST
92727: PUSH
92728: EMPTY
92729: LIST
92730: LIST
92731: LIST
92732: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
92733: LD_ADDR_VAR 0 24
92737: PUSH
92738: LD_INT 3
92740: PUSH
92741: LD_INT 0
92743: PUSH
92744: EMPTY
92745: LIST
92746: LIST
92747: PUSH
92748: LD_INT 3
92750: PUSH
92751: LD_INT 1
92753: NEG
92754: PUSH
92755: EMPTY
92756: LIST
92757: LIST
92758: PUSH
92759: LD_INT 4
92761: PUSH
92762: LD_INT 1
92764: PUSH
92765: EMPTY
92766: LIST
92767: LIST
92768: PUSH
92769: EMPTY
92770: LIST
92771: LIST
92772: LIST
92773: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
92774: LD_ADDR_VAR 0 25
92778: PUSH
92779: LD_INT 3
92781: PUSH
92782: LD_INT 3
92784: PUSH
92785: EMPTY
92786: LIST
92787: LIST
92788: PUSH
92789: LD_INT 4
92791: PUSH
92792: LD_INT 3
92794: PUSH
92795: EMPTY
92796: LIST
92797: LIST
92798: PUSH
92799: LD_INT 3
92801: PUSH
92802: LD_INT 4
92804: PUSH
92805: EMPTY
92806: LIST
92807: LIST
92808: PUSH
92809: EMPTY
92810: LIST
92811: LIST
92812: LIST
92813: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
92814: LD_ADDR_VAR 0 26
92818: PUSH
92819: LD_INT 0
92821: PUSH
92822: LD_INT 3
92824: PUSH
92825: EMPTY
92826: LIST
92827: LIST
92828: PUSH
92829: LD_INT 1
92831: PUSH
92832: LD_INT 4
92834: PUSH
92835: EMPTY
92836: LIST
92837: LIST
92838: PUSH
92839: LD_INT 1
92841: NEG
92842: PUSH
92843: LD_INT 3
92845: PUSH
92846: EMPTY
92847: LIST
92848: LIST
92849: PUSH
92850: EMPTY
92851: LIST
92852: LIST
92853: LIST
92854: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
92855: LD_ADDR_VAR 0 27
92859: PUSH
92860: LD_INT 3
92862: NEG
92863: PUSH
92864: LD_INT 0
92866: PUSH
92867: EMPTY
92868: LIST
92869: LIST
92870: PUSH
92871: LD_INT 3
92873: NEG
92874: PUSH
92875: LD_INT 1
92877: PUSH
92878: EMPTY
92879: LIST
92880: LIST
92881: PUSH
92882: LD_INT 4
92884: NEG
92885: PUSH
92886: LD_INT 1
92888: NEG
92889: PUSH
92890: EMPTY
92891: LIST
92892: LIST
92893: PUSH
92894: EMPTY
92895: LIST
92896: LIST
92897: LIST
92898: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
92899: LD_ADDR_VAR 0 28
92903: PUSH
92904: LD_INT 3
92906: NEG
92907: PUSH
92908: LD_INT 3
92910: NEG
92911: PUSH
92912: EMPTY
92913: LIST
92914: LIST
92915: PUSH
92916: LD_INT 3
92918: NEG
92919: PUSH
92920: LD_INT 4
92922: NEG
92923: PUSH
92924: EMPTY
92925: LIST
92926: LIST
92927: PUSH
92928: LD_INT 4
92930: NEG
92931: PUSH
92932: LD_INT 3
92934: NEG
92935: PUSH
92936: EMPTY
92937: LIST
92938: LIST
92939: PUSH
92940: EMPTY
92941: LIST
92942: LIST
92943: LIST
92944: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92945: LD_ADDR_VAR 0 29
92949: PUSH
92950: LD_INT 1
92952: NEG
92953: PUSH
92954: LD_INT 3
92956: NEG
92957: PUSH
92958: EMPTY
92959: LIST
92960: LIST
92961: PUSH
92962: LD_INT 0
92964: PUSH
92965: LD_INT 3
92967: NEG
92968: PUSH
92969: EMPTY
92970: LIST
92971: LIST
92972: PUSH
92973: LD_INT 1
92975: PUSH
92976: LD_INT 2
92978: NEG
92979: PUSH
92980: EMPTY
92981: LIST
92982: LIST
92983: PUSH
92984: LD_INT 1
92986: NEG
92987: PUSH
92988: LD_INT 4
92990: NEG
92991: PUSH
92992: EMPTY
92993: LIST
92994: LIST
92995: PUSH
92996: LD_INT 0
92998: PUSH
92999: LD_INT 4
93001: NEG
93002: PUSH
93003: EMPTY
93004: LIST
93005: LIST
93006: PUSH
93007: LD_INT 1
93009: PUSH
93010: LD_INT 3
93012: NEG
93013: PUSH
93014: EMPTY
93015: LIST
93016: LIST
93017: PUSH
93018: LD_INT 1
93020: NEG
93021: PUSH
93022: LD_INT 5
93024: NEG
93025: PUSH
93026: EMPTY
93027: LIST
93028: LIST
93029: PUSH
93030: LD_INT 0
93032: PUSH
93033: LD_INT 5
93035: NEG
93036: PUSH
93037: EMPTY
93038: LIST
93039: LIST
93040: PUSH
93041: LD_INT 1
93043: PUSH
93044: LD_INT 4
93046: NEG
93047: PUSH
93048: EMPTY
93049: LIST
93050: LIST
93051: PUSH
93052: LD_INT 1
93054: NEG
93055: PUSH
93056: LD_INT 6
93058: NEG
93059: PUSH
93060: EMPTY
93061: LIST
93062: LIST
93063: PUSH
93064: LD_INT 0
93066: PUSH
93067: LD_INT 6
93069: NEG
93070: PUSH
93071: EMPTY
93072: LIST
93073: LIST
93074: PUSH
93075: LD_INT 1
93077: PUSH
93078: LD_INT 5
93080: NEG
93081: PUSH
93082: EMPTY
93083: LIST
93084: LIST
93085: PUSH
93086: EMPTY
93087: LIST
93088: LIST
93089: LIST
93090: LIST
93091: LIST
93092: LIST
93093: LIST
93094: LIST
93095: LIST
93096: LIST
93097: LIST
93098: LIST
93099: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
93100: LD_ADDR_VAR 0 30
93104: PUSH
93105: LD_INT 2
93107: PUSH
93108: LD_INT 1
93110: NEG
93111: PUSH
93112: EMPTY
93113: LIST
93114: LIST
93115: PUSH
93116: LD_INT 3
93118: PUSH
93119: LD_INT 0
93121: PUSH
93122: EMPTY
93123: LIST
93124: LIST
93125: PUSH
93126: LD_INT 3
93128: PUSH
93129: LD_INT 1
93131: PUSH
93132: EMPTY
93133: LIST
93134: LIST
93135: PUSH
93136: LD_INT 3
93138: PUSH
93139: LD_INT 1
93141: NEG
93142: PUSH
93143: EMPTY
93144: LIST
93145: LIST
93146: PUSH
93147: LD_INT 4
93149: PUSH
93150: LD_INT 0
93152: PUSH
93153: EMPTY
93154: LIST
93155: LIST
93156: PUSH
93157: LD_INT 4
93159: PUSH
93160: LD_INT 1
93162: PUSH
93163: EMPTY
93164: LIST
93165: LIST
93166: PUSH
93167: LD_INT 4
93169: PUSH
93170: LD_INT 1
93172: NEG
93173: PUSH
93174: EMPTY
93175: LIST
93176: LIST
93177: PUSH
93178: LD_INT 5
93180: PUSH
93181: LD_INT 0
93183: PUSH
93184: EMPTY
93185: LIST
93186: LIST
93187: PUSH
93188: LD_INT 5
93190: PUSH
93191: LD_INT 1
93193: PUSH
93194: EMPTY
93195: LIST
93196: LIST
93197: PUSH
93198: LD_INT 5
93200: PUSH
93201: LD_INT 1
93203: NEG
93204: PUSH
93205: EMPTY
93206: LIST
93207: LIST
93208: PUSH
93209: LD_INT 6
93211: PUSH
93212: LD_INT 0
93214: PUSH
93215: EMPTY
93216: LIST
93217: LIST
93218: PUSH
93219: LD_INT 6
93221: PUSH
93222: LD_INT 1
93224: PUSH
93225: EMPTY
93226: LIST
93227: LIST
93228: PUSH
93229: EMPTY
93230: LIST
93231: LIST
93232: LIST
93233: LIST
93234: LIST
93235: LIST
93236: LIST
93237: LIST
93238: LIST
93239: LIST
93240: LIST
93241: LIST
93242: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
93243: LD_ADDR_VAR 0 31
93247: PUSH
93248: LD_INT 3
93250: PUSH
93251: LD_INT 2
93253: PUSH
93254: EMPTY
93255: LIST
93256: LIST
93257: PUSH
93258: LD_INT 3
93260: PUSH
93261: LD_INT 3
93263: PUSH
93264: EMPTY
93265: LIST
93266: LIST
93267: PUSH
93268: LD_INT 2
93270: PUSH
93271: LD_INT 3
93273: PUSH
93274: EMPTY
93275: LIST
93276: LIST
93277: PUSH
93278: LD_INT 4
93280: PUSH
93281: LD_INT 3
93283: PUSH
93284: EMPTY
93285: LIST
93286: LIST
93287: PUSH
93288: LD_INT 4
93290: PUSH
93291: LD_INT 4
93293: PUSH
93294: EMPTY
93295: LIST
93296: LIST
93297: PUSH
93298: LD_INT 3
93300: PUSH
93301: LD_INT 4
93303: PUSH
93304: EMPTY
93305: LIST
93306: LIST
93307: PUSH
93308: LD_INT 5
93310: PUSH
93311: LD_INT 4
93313: PUSH
93314: EMPTY
93315: LIST
93316: LIST
93317: PUSH
93318: LD_INT 5
93320: PUSH
93321: LD_INT 5
93323: PUSH
93324: EMPTY
93325: LIST
93326: LIST
93327: PUSH
93328: LD_INT 4
93330: PUSH
93331: LD_INT 5
93333: PUSH
93334: EMPTY
93335: LIST
93336: LIST
93337: PUSH
93338: LD_INT 6
93340: PUSH
93341: LD_INT 5
93343: PUSH
93344: EMPTY
93345: LIST
93346: LIST
93347: PUSH
93348: LD_INT 6
93350: PUSH
93351: LD_INT 6
93353: PUSH
93354: EMPTY
93355: LIST
93356: LIST
93357: PUSH
93358: LD_INT 5
93360: PUSH
93361: LD_INT 6
93363: PUSH
93364: EMPTY
93365: LIST
93366: LIST
93367: PUSH
93368: EMPTY
93369: LIST
93370: LIST
93371: LIST
93372: LIST
93373: LIST
93374: LIST
93375: LIST
93376: LIST
93377: LIST
93378: LIST
93379: LIST
93380: LIST
93381: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
93382: LD_ADDR_VAR 0 32
93386: PUSH
93387: LD_INT 1
93389: PUSH
93390: LD_INT 3
93392: PUSH
93393: EMPTY
93394: LIST
93395: LIST
93396: PUSH
93397: LD_INT 0
93399: PUSH
93400: LD_INT 3
93402: PUSH
93403: EMPTY
93404: LIST
93405: LIST
93406: PUSH
93407: LD_INT 1
93409: NEG
93410: PUSH
93411: LD_INT 2
93413: PUSH
93414: EMPTY
93415: LIST
93416: LIST
93417: PUSH
93418: LD_INT 1
93420: PUSH
93421: LD_INT 4
93423: PUSH
93424: EMPTY
93425: LIST
93426: LIST
93427: PUSH
93428: LD_INT 0
93430: PUSH
93431: LD_INT 4
93433: PUSH
93434: EMPTY
93435: LIST
93436: LIST
93437: PUSH
93438: LD_INT 1
93440: NEG
93441: PUSH
93442: LD_INT 3
93444: PUSH
93445: EMPTY
93446: LIST
93447: LIST
93448: PUSH
93449: LD_INT 1
93451: PUSH
93452: LD_INT 5
93454: PUSH
93455: EMPTY
93456: LIST
93457: LIST
93458: PUSH
93459: LD_INT 0
93461: PUSH
93462: LD_INT 5
93464: PUSH
93465: EMPTY
93466: LIST
93467: LIST
93468: PUSH
93469: LD_INT 1
93471: NEG
93472: PUSH
93473: LD_INT 4
93475: PUSH
93476: EMPTY
93477: LIST
93478: LIST
93479: PUSH
93480: LD_INT 1
93482: PUSH
93483: LD_INT 6
93485: PUSH
93486: EMPTY
93487: LIST
93488: LIST
93489: PUSH
93490: LD_INT 0
93492: PUSH
93493: LD_INT 6
93495: PUSH
93496: EMPTY
93497: LIST
93498: LIST
93499: PUSH
93500: LD_INT 1
93502: NEG
93503: PUSH
93504: LD_INT 5
93506: PUSH
93507: EMPTY
93508: LIST
93509: LIST
93510: PUSH
93511: EMPTY
93512: LIST
93513: LIST
93514: LIST
93515: LIST
93516: LIST
93517: LIST
93518: LIST
93519: LIST
93520: LIST
93521: LIST
93522: LIST
93523: LIST
93524: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
93525: LD_ADDR_VAR 0 33
93529: PUSH
93530: LD_INT 2
93532: NEG
93533: PUSH
93534: LD_INT 1
93536: PUSH
93537: EMPTY
93538: LIST
93539: LIST
93540: PUSH
93541: LD_INT 3
93543: NEG
93544: PUSH
93545: LD_INT 0
93547: PUSH
93548: EMPTY
93549: LIST
93550: LIST
93551: PUSH
93552: LD_INT 3
93554: NEG
93555: PUSH
93556: LD_INT 1
93558: NEG
93559: PUSH
93560: EMPTY
93561: LIST
93562: LIST
93563: PUSH
93564: LD_INT 3
93566: NEG
93567: PUSH
93568: LD_INT 1
93570: PUSH
93571: EMPTY
93572: LIST
93573: LIST
93574: PUSH
93575: LD_INT 4
93577: NEG
93578: PUSH
93579: LD_INT 0
93581: PUSH
93582: EMPTY
93583: LIST
93584: LIST
93585: PUSH
93586: LD_INT 4
93588: NEG
93589: PUSH
93590: LD_INT 1
93592: NEG
93593: PUSH
93594: EMPTY
93595: LIST
93596: LIST
93597: PUSH
93598: LD_INT 4
93600: NEG
93601: PUSH
93602: LD_INT 1
93604: PUSH
93605: EMPTY
93606: LIST
93607: LIST
93608: PUSH
93609: LD_INT 5
93611: NEG
93612: PUSH
93613: LD_INT 0
93615: PUSH
93616: EMPTY
93617: LIST
93618: LIST
93619: PUSH
93620: LD_INT 5
93622: NEG
93623: PUSH
93624: LD_INT 1
93626: NEG
93627: PUSH
93628: EMPTY
93629: LIST
93630: LIST
93631: PUSH
93632: LD_INT 5
93634: NEG
93635: PUSH
93636: LD_INT 1
93638: PUSH
93639: EMPTY
93640: LIST
93641: LIST
93642: PUSH
93643: LD_INT 6
93645: NEG
93646: PUSH
93647: LD_INT 0
93649: PUSH
93650: EMPTY
93651: LIST
93652: LIST
93653: PUSH
93654: LD_INT 6
93656: NEG
93657: PUSH
93658: LD_INT 1
93660: NEG
93661: PUSH
93662: EMPTY
93663: LIST
93664: LIST
93665: PUSH
93666: EMPTY
93667: LIST
93668: LIST
93669: LIST
93670: LIST
93671: LIST
93672: LIST
93673: LIST
93674: LIST
93675: LIST
93676: LIST
93677: LIST
93678: LIST
93679: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
93680: LD_ADDR_VAR 0 34
93684: PUSH
93685: LD_INT 2
93687: NEG
93688: PUSH
93689: LD_INT 3
93691: NEG
93692: PUSH
93693: EMPTY
93694: LIST
93695: LIST
93696: PUSH
93697: LD_INT 3
93699: NEG
93700: PUSH
93701: LD_INT 2
93703: NEG
93704: PUSH
93705: EMPTY
93706: LIST
93707: LIST
93708: PUSH
93709: LD_INT 3
93711: NEG
93712: PUSH
93713: LD_INT 3
93715: NEG
93716: PUSH
93717: EMPTY
93718: LIST
93719: LIST
93720: PUSH
93721: LD_INT 3
93723: NEG
93724: PUSH
93725: LD_INT 4
93727: NEG
93728: PUSH
93729: EMPTY
93730: LIST
93731: LIST
93732: PUSH
93733: LD_INT 4
93735: NEG
93736: PUSH
93737: LD_INT 3
93739: NEG
93740: PUSH
93741: EMPTY
93742: LIST
93743: LIST
93744: PUSH
93745: LD_INT 4
93747: NEG
93748: PUSH
93749: LD_INT 4
93751: NEG
93752: PUSH
93753: EMPTY
93754: LIST
93755: LIST
93756: PUSH
93757: LD_INT 4
93759: NEG
93760: PUSH
93761: LD_INT 5
93763: NEG
93764: PUSH
93765: EMPTY
93766: LIST
93767: LIST
93768: PUSH
93769: LD_INT 5
93771: NEG
93772: PUSH
93773: LD_INT 4
93775: NEG
93776: PUSH
93777: EMPTY
93778: LIST
93779: LIST
93780: PUSH
93781: LD_INT 5
93783: NEG
93784: PUSH
93785: LD_INT 5
93787: NEG
93788: PUSH
93789: EMPTY
93790: LIST
93791: LIST
93792: PUSH
93793: LD_INT 5
93795: NEG
93796: PUSH
93797: LD_INT 6
93799: NEG
93800: PUSH
93801: EMPTY
93802: LIST
93803: LIST
93804: PUSH
93805: LD_INT 6
93807: NEG
93808: PUSH
93809: LD_INT 5
93811: NEG
93812: PUSH
93813: EMPTY
93814: LIST
93815: LIST
93816: PUSH
93817: LD_INT 6
93819: NEG
93820: PUSH
93821: LD_INT 6
93823: NEG
93824: PUSH
93825: EMPTY
93826: LIST
93827: LIST
93828: PUSH
93829: EMPTY
93830: LIST
93831: LIST
93832: LIST
93833: LIST
93834: LIST
93835: LIST
93836: LIST
93837: LIST
93838: LIST
93839: LIST
93840: LIST
93841: LIST
93842: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
93843: LD_ADDR_VAR 0 41
93847: PUSH
93848: LD_INT 0
93850: PUSH
93851: LD_INT 2
93853: NEG
93854: PUSH
93855: EMPTY
93856: LIST
93857: LIST
93858: PUSH
93859: LD_INT 1
93861: NEG
93862: PUSH
93863: LD_INT 3
93865: NEG
93866: PUSH
93867: EMPTY
93868: LIST
93869: LIST
93870: PUSH
93871: LD_INT 1
93873: PUSH
93874: LD_INT 2
93876: NEG
93877: PUSH
93878: EMPTY
93879: LIST
93880: LIST
93881: PUSH
93882: EMPTY
93883: LIST
93884: LIST
93885: LIST
93886: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
93887: LD_ADDR_VAR 0 42
93891: PUSH
93892: LD_INT 2
93894: PUSH
93895: LD_INT 0
93897: PUSH
93898: EMPTY
93899: LIST
93900: LIST
93901: PUSH
93902: LD_INT 2
93904: PUSH
93905: LD_INT 1
93907: NEG
93908: PUSH
93909: EMPTY
93910: LIST
93911: LIST
93912: PUSH
93913: LD_INT 3
93915: PUSH
93916: LD_INT 1
93918: PUSH
93919: EMPTY
93920: LIST
93921: LIST
93922: PUSH
93923: EMPTY
93924: LIST
93925: LIST
93926: LIST
93927: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93928: LD_ADDR_VAR 0 43
93932: PUSH
93933: LD_INT 2
93935: PUSH
93936: LD_INT 2
93938: PUSH
93939: EMPTY
93940: LIST
93941: LIST
93942: PUSH
93943: LD_INT 3
93945: PUSH
93946: LD_INT 2
93948: PUSH
93949: EMPTY
93950: LIST
93951: LIST
93952: PUSH
93953: LD_INT 2
93955: PUSH
93956: LD_INT 3
93958: PUSH
93959: EMPTY
93960: LIST
93961: LIST
93962: PUSH
93963: EMPTY
93964: LIST
93965: LIST
93966: LIST
93967: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93968: LD_ADDR_VAR 0 44
93972: PUSH
93973: LD_INT 0
93975: PUSH
93976: LD_INT 2
93978: PUSH
93979: EMPTY
93980: LIST
93981: LIST
93982: PUSH
93983: LD_INT 1
93985: PUSH
93986: LD_INT 3
93988: PUSH
93989: EMPTY
93990: LIST
93991: LIST
93992: PUSH
93993: LD_INT 1
93995: NEG
93996: PUSH
93997: LD_INT 2
93999: PUSH
94000: EMPTY
94001: LIST
94002: LIST
94003: PUSH
94004: EMPTY
94005: LIST
94006: LIST
94007: LIST
94008: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
94009: LD_ADDR_VAR 0 45
94013: PUSH
94014: LD_INT 2
94016: NEG
94017: PUSH
94018: LD_INT 0
94020: PUSH
94021: EMPTY
94022: LIST
94023: LIST
94024: PUSH
94025: LD_INT 2
94027: NEG
94028: PUSH
94029: LD_INT 1
94031: PUSH
94032: EMPTY
94033: LIST
94034: LIST
94035: PUSH
94036: LD_INT 3
94038: NEG
94039: PUSH
94040: LD_INT 1
94042: NEG
94043: PUSH
94044: EMPTY
94045: LIST
94046: LIST
94047: PUSH
94048: EMPTY
94049: LIST
94050: LIST
94051: LIST
94052: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
94053: LD_ADDR_VAR 0 46
94057: PUSH
94058: LD_INT 2
94060: NEG
94061: PUSH
94062: LD_INT 2
94064: NEG
94065: PUSH
94066: EMPTY
94067: LIST
94068: LIST
94069: PUSH
94070: LD_INT 2
94072: NEG
94073: PUSH
94074: LD_INT 3
94076: NEG
94077: PUSH
94078: EMPTY
94079: LIST
94080: LIST
94081: PUSH
94082: LD_INT 3
94084: NEG
94085: PUSH
94086: LD_INT 2
94088: NEG
94089: PUSH
94090: EMPTY
94091: LIST
94092: LIST
94093: PUSH
94094: EMPTY
94095: LIST
94096: LIST
94097: LIST
94098: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
94099: LD_ADDR_VAR 0 47
94103: PUSH
94104: LD_INT 2
94106: NEG
94107: PUSH
94108: LD_INT 3
94110: NEG
94111: PUSH
94112: EMPTY
94113: LIST
94114: LIST
94115: PUSH
94116: LD_INT 1
94118: NEG
94119: PUSH
94120: LD_INT 3
94122: NEG
94123: PUSH
94124: EMPTY
94125: LIST
94126: LIST
94127: PUSH
94128: EMPTY
94129: LIST
94130: LIST
94131: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
94132: LD_ADDR_VAR 0 48
94136: PUSH
94137: LD_INT 1
94139: PUSH
94140: LD_INT 2
94142: NEG
94143: PUSH
94144: EMPTY
94145: LIST
94146: LIST
94147: PUSH
94148: LD_INT 2
94150: PUSH
94151: LD_INT 1
94153: NEG
94154: PUSH
94155: EMPTY
94156: LIST
94157: LIST
94158: PUSH
94159: EMPTY
94160: LIST
94161: LIST
94162: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
94163: LD_ADDR_VAR 0 49
94167: PUSH
94168: LD_INT 3
94170: PUSH
94171: LD_INT 1
94173: PUSH
94174: EMPTY
94175: LIST
94176: LIST
94177: PUSH
94178: LD_INT 3
94180: PUSH
94181: LD_INT 2
94183: PUSH
94184: EMPTY
94185: LIST
94186: LIST
94187: PUSH
94188: EMPTY
94189: LIST
94190: LIST
94191: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
94192: LD_ADDR_VAR 0 50
94196: PUSH
94197: LD_INT 2
94199: PUSH
94200: LD_INT 3
94202: PUSH
94203: EMPTY
94204: LIST
94205: LIST
94206: PUSH
94207: LD_INT 1
94209: PUSH
94210: LD_INT 3
94212: PUSH
94213: EMPTY
94214: LIST
94215: LIST
94216: PUSH
94217: EMPTY
94218: LIST
94219: LIST
94220: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
94221: LD_ADDR_VAR 0 51
94225: PUSH
94226: LD_INT 1
94228: NEG
94229: PUSH
94230: LD_INT 2
94232: PUSH
94233: EMPTY
94234: LIST
94235: LIST
94236: PUSH
94237: LD_INT 2
94239: NEG
94240: PUSH
94241: LD_INT 1
94243: PUSH
94244: EMPTY
94245: LIST
94246: LIST
94247: PUSH
94248: EMPTY
94249: LIST
94250: LIST
94251: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
94252: LD_ADDR_VAR 0 52
94256: PUSH
94257: LD_INT 3
94259: NEG
94260: PUSH
94261: LD_INT 1
94263: NEG
94264: PUSH
94265: EMPTY
94266: LIST
94267: LIST
94268: PUSH
94269: LD_INT 3
94271: NEG
94272: PUSH
94273: LD_INT 2
94275: NEG
94276: PUSH
94277: EMPTY
94278: LIST
94279: LIST
94280: PUSH
94281: EMPTY
94282: LIST
94283: LIST
94284: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
94285: LD_ADDR_VAR 0 53
94289: PUSH
94290: LD_INT 1
94292: NEG
94293: PUSH
94294: LD_INT 3
94296: NEG
94297: PUSH
94298: EMPTY
94299: LIST
94300: LIST
94301: PUSH
94302: LD_INT 0
94304: PUSH
94305: LD_INT 3
94307: NEG
94308: PUSH
94309: EMPTY
94310: LIST
94311: LIST
94312: PUSH
94313: LD_INT 1
94315: PUSH
94316: LD_INT 2
94318: NEG
94319: PUSH
94320: EMPTY
94321: LIST
94322: LIST
94323: PUSH
94324: EMPTY
94325: LIST
94326: LIST
94327: LIST
94328: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
94329: LD_ADDR_VAR 0 54
94333: PUSH
94334: LD_INT 2
94336: PUSH
94337: LD_INT 1
94339: NEG
94340: PUSH
94341: EMPTY
94342: LIST
94343: LIST
94344: PUSH
94345: LD_INT 3
94347: PUSH
94348: LD_INT 0
94350: PUSH
94351: EMPTY
94352: LIST
94353: LIST
94354: PUSH
94355: LD_INT 3
94357: PUSH
94358: LD_INT 1
94360: PUSH
94361: EMPTY
94362: LIST
94363: LIST
94364: PUSH
94365: EMPTY
94366: LIST
94367: LIST
94368: LIST
94369: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
94370: LD_ADDR_VAR 0 55
94374: PUSH
94375: LD_INT 3
94377: PUSH
94378: LD_INT 2
94380: PUSH
94381: EMPTY
94382: LIST
94383: LIST
94384: PUSH
94385: LD_INT 3
94387: PUSH
94388: LD_INT 3
94390: PUSH
94391: EMPTY
94392: LIST
94393: LIST
94394: PUSH
94395: LD_INT 2
94397: PUSH
94398: LD_INT 3
94400: PUSH
94401: EMPTY
94402: LIST
94403: LIST
94404: PUSH
94405: EMPTY
94406: LIST
94407: LIST
94408: LIST
94409: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
94410: LD_ADDR_VAR 0 56
94414: PUSH
94415: LD_INT 1
94417: PUSH
94418: LD_INT 3
94420: PUSH
94421: EMPTY
94422: LIST
94423: LIST
94424: PUSH
94425: LD_INT 0
94427: PUSH
94428: LD_INT 3
94430: PUSH
94431: EMPTY
94432: LIST
94433: LIST
94434: PUSH
94435: LD_INT 1
94437: NEG
94438: PUSH
94439: LD_INT 2
94441: PUSH
94442: EMPTY
94443: LIST
94444: LIST
94445: PUSH
94446: EMPTY
94447: LIST
94448: LIST
94449: LIST
94450: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
94451: LD_ADDR_VAR 0 57
94455: PUSH
94456: LD_INT 2
94458: NEG
94459: PUSH
94460: LD_INT 1
94462: PUSH
94463: EMPTY
94464: LIST
94465: LIST
94466: PUSH
94467: LD_INT 3
94469: NEG
94470: PUSH
94471: LD_INT 0
94473: PUSH
94474: EMPTY
94475: LIST
94476: LIST
94477: PUSH
94478: LD_INT 3
94480: NEG
94481: PUSH
94482: LD_INT 1
94484: NEG
94485: PUSH
94486: EMPTY
94487: LIST
94488: LIST
94489: PUSH
94490: EMPTY
94491: LIST
94492: LIST
94493: LIST
94494: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
94495: LD_ADDR_VAR 0 58
94499: PUSH
94500: LD_INT 2
94502: NEG
94503: PUSH
94504: LD_INT 3
94506: NEG
94507: PUSH
94508: EMPTY
94509: LIST
94510: LIST
94511: PUSH
94512: LD_INT 3
94514: NEG
94515: PUSH
94516: LD_INT 2
94518: NEG
94519: PUSH
94520: EMPTY
94521: LIST
94522: LIST
94523: PUSH
94524: LD_INT 3
94526: NEG
94527: PUSH
94528: LD_INT 3
94530: NEG
94531: PUSH
94532: EMPTY
94533: LIST
94534: LIST
94535: PUSH
94536: EMPTY
94537: LIST
94538: LIST
94539: LIST
94540: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
94541: LD_ADDR_VAR 0 59
94545: PUSH
94546: LD_INT 1
94548: NEG
94549: PUSH
94550: LD_INT 2
94552: NEG
94553: PUSH
94554: EMPTY
94555: LIST
94556: LIST
94557: PUSH
94558: LD_INT 0
94560: PUSH
94561: LD_INT 2
94563: NEG
94564: PUSH
94565: EMPTY
94566: LIST
94567: LIST
94568: PUSH
94569: LD_INT 1
94571: PUSH
94572: LD_INT 1
94574: NEG
94575: PUSH
94576: EMPTY
94577: LIST
94578: LIST
94579: PUSH
94580: EMPTY
94581: LIST
94582: LIST
94583: LIST
94584: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
94585: LD_ADDR_VAR 0 60
94589: PUSH
94590: LD_INT 1
94592: PUSH
94593: LD_INT 1
94595: NEG
94596: PUSH
94597: EMPTY
94598: LIST
94599: LIST
94600: PUSH
94601: LD_INT 2
94603: PUSH
94604: LD_INT 0
94606: PUSH
94607: EMPTY
94608: LIST
94609: LIST
94610: PUSH
94611: LD_INT 2
94613: PUSH
94614: LD_INT 1
94616: PUSH
94617: EMPTY
94618: LIST
94619: LIST
94620: PUSH
94621: EMPTY
94622: LIST
94623: LIST
94624: LIST
94625: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
94626: LD_ADDR_VAR 0 61
94630: PUSH
94631: LD_INT 2
94633: PUSH
94634: LD_INT 1
94636: PUSH
94637: EMPTY
94638: LIST
94639: LIST
94640: PUSH
94641: LD_INT 2
94643: PUSH
94644: LD_INT 2
94646: PUSH
94647: EMPTY
94648: LIST
94649: LIST
94650: PUSH
94651: LD_INT 1
94653: PUSH
94654: LD_INT 2
94656: PUSH
94657: EMPTY
94658: LIST
94659: LIST
94660: PUSH
94661: EMPTY
94662: LIST
94663: LIST
94664: LIST
94665: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94666: LD_ADDR_VAR 0 62
94670: PUSH
94671: LD_INT 1
94673: PUSH
94674: LD_INT 2
94676: PUSH
94677: EMPTY
94678: LIST
94679: LIST
94680: PUSH
94681: LD_INT 0
94683: PUSH
94684: LD_INT 2
94686: PUSH
94687: EMPTY
94688: LIST
94689: LIST
94690: PUSH
94691: LD_INT 1
94693: NEG
94694: PUSH
94695: LD_INT 1
94697: PUSH
94698: EMPTY
94699: LIST
94700: LIST
94701: PUSH
94702: EMPTY
94703: LIST
94704: LIST
94705: LIST
94706: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94707: LD_ADDR_VAR 0 63
94711: PUSH
94712: LD_INT 1
94714: NEG
94715: PUSH
94716: LD_INT 1
94718: PUSH
94719: EMPTY
94720: LIST
94721: LIST
94722: PUSH
94723: LD_INT 2
94725: NEG
94726: PUSH
94727: LD_INT 0
94729: PUSH
94730: EMPTY
94731: LIST
94732: LIST
94733: PUSH
94734: LD_INT 2
94736: NEG
94737: PUSH
94738: LD_INT 1
94740: NEG
94741: PUSH
94742: EMPTY
94743: LIST
94744: LIST
94745: PUSH
94746: EMPTY
94747: LIST
94748: LIST
94749: LIST
94750: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94751: LD_ADDR_VAR 0 64
94755: PUSH
94756: LD_INT 1
94758: NEG
94759: PUSH
94760: LD_INT 2
94762: NEG
94763: PUSH
94764: EMPTY
94765: LIST
94766: LIST
94767: PUSH
94768: LD_INT 2
94770: NEG
94771: PUSH
94772: LD_INT 1
94774: NEG
94775: PUSH
94776: EMPTY
94777: LIST
94778: LIST
94779: PUSH
94780: LD_INT 2
94782: NEG
94783: PUSH
94784: LD_INT 2
94786: NEG
94787: PUSH
94788: EMPTY
94789: LIST
94790: LIST
94791: PUSH
94792: EMPTY
94793: LIST
94794: LIST
94795: LIST
94796: ST_TO_ADDR
// end ; 2 :
94797: GO 98063
94799: LD_INT 2
94801: DOUBLE
94802: EQUAL
94803: IFTRUE 94807
94805: GO 98062
94807: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
94808: LD_ADDR_VAR 0 29
94812: PUSH
94813: LD_INT 4
94815: PUSH
94816: LD_INT 0
94818: PUSH
94819: EMPTY
94820: LIST
94821: LIST
94822: PUSH
94823: LD_INT 4
94825: PUSH
94826: LD_INT 1
94828: NEG
94829: PUSH
94830: EMPTY
94831: LIST
94832: LIST
94833: PUSH
94834: LD_INT 5
94836: PUSH
94837: LD_INT 0
94839: PUSH
94840: EMPTY
94841: LIST
94842: LIST
94843: PUSH
94844: LD_INT 5
94846: PUSH
94847: LD_INT 1
94849: PUSH
94850: EMPTY
94851: LIST
94852: LIST
94853: PUSH
94854: LD_INT 4
94856: PUSH
94857: LD_INT 1
94859: PUSH
94860: EMPTY
94861: LIST
94862: LIST
94863: PUSH
94864: LD_INT 3
94866: PUSH
94867: LD_INT 0
94869: PUSH
94870: EMPTY
94871: LIST
94872: LIST
94873: PUSH
94874: LD_INT 3
94876: PUSH
94877: LD_INT 1
94879: NEG
94880: PUSH
94881: EMPTY
94882: LIST
94883: LIST
94884: PUSH
94885: LD_INT 3
94887: PUSH
94888: LD_INT 2
94890: NEG
94891: PUSH
94892: EMPTY
94893: LIST
94894: LIST
94895: PUSH
94896: LD_INT 5
94898: PUSH
94899: LD_INT 2
94901: PUSH
94902: EMPTY
94903: LIST
94904: LIST
94905: PUSH
94906: LD_INT 3
94908: PUSH
94909: LD_INT 3
94911: PUSH
94912: EMPTY
94913: LIST
94914: LIST
94915: PUSH
94916: LD_INT 3
94918: PUSH
94919: LD_INT 2
94921: PUSH
94922: EMPTY
94923: LIST
94924: LIST
94925: PUSH
94926: LD_INT 4
94928: PUSH
94929: LD_INT 3
94931: PUSH
94932: EMPTY
94933: LIST
94934: LIST
94935: PUSH
94936: LD_INT 4
94938: PUSH
94939: LD_INT 4
94941: PUSH
94942: EMPTY
94943: LIST
94944: LIST
94945: PUSH
94946: LD_INT 3
94948: PUSH
94949: LD_INT 4
94951: PUSH
94952: EMPTY
94953: LIST
94954: LIST
94955: PUSH
94956: LD_INT 2
94958: PUSH
94959: LD_INT 3
94961: PUSH
94962: EMPTY
94963: LIST
94964: LIST
94965: PUSH
94966: LD_INT 2
94968: PUSH
94969: LD_INT 2
94971: PUSH
94972: EMPTY
94973: LIST
94974: LIST
94975: PUSH
94976: LD_INT 4
94978: PUSH
94979: LD_INT 2
94981: PUSH
94982: EMPTY
94983: LIST
94984: LIST
94985: PUSH
94986: LD_INT 2
94988: PUSH
94989: LD_INT 4
94991: PUSH
94992: EMPTY
94993: LIST
94994: LIST
94995: PUSH
94996: LD_INT 0
94998: PUSH
94999: LD_INT 4
95001: PUSH
95002: EMPTY
95003: LIST
95004: LIST
95005: PUSH
95006: LD_INT 0
95008: PUSH
95009: LD_INT 3
95011: PUSH
95012: EMPTY
95013: LIST
95014: LIST
95015: PUSH
95016: LD_INT 1
95018: PUSH
95019: LD_INT 4
95021: PUSH
95022: EMPTY
95023: LIST
95024: LIST
95025: PUSH
95026: LD_INT 1
95028: PUSH
95029: LD_INT 5
95031: PUSH
95032: EMPTY
95033: LIST
95034: LIST
95035: PUSH
95036: LD_INT 0
95038: PUSH
95039: LD_INT 5
95041: PUSH
95042: EMPTY
95043: LIST
95044: LIST
95045: PUSH
95046: LD_INT 1
95048: NEG
95049: PUSH
95050: LD_INT 4
95052: PUSH
95053: EMPTY
95054: LIST
95055: LIST
95056: PUSH
95057: LD_INT 1
95059: NEG
95060: PUSH
95061: LD_INT 3
95063: PUSH
95064: EMPTY
95065: LIST
95066: LIST
95067: PUSH
95068: LD_INT 2
95070: PUSH
95071: LD_INT 5
95073: PUSH
95074: EMPTY
95075: LIST
95076: LIST
95077: PUSH
95078: LD_INT 2
95080: NEG
95081: PUSH
95082: LD_INT 3
95084: PUSH
95085: EMPTY
95086: LIST
95087: LIST
95088: PUSH
95089: LD_INT 3
95091: NEG
95092: PUSH
95093: LD_INT 0
95095: PUSH
95096: EMPTY
95097: LIST
95098: LIST
95099: PUSH
95100: LD_INT 3
95102: NEG
95103: PUSH
95104: LD_INT 1
95106: NEG
95107: PUSH
95108: EMPTY
95109: LIST
95110: LIST
95111: PUSH
95112: LD_INT 2
95114: NEG
95115: PUSH
95116: LD_INT 0
95118: PUSH
95119: EMPTY
95120: LIST
95121: LIST
95122: PUSH
95123: LD_INT 2
95125: NEG
95126: PUSH
95127: LD_INT 1
95129: PUSH
95130: EMPTY
95131: LIST
95132: LIST
95133: PUSH
95134: LD_INT 3
95136: NEG
95137: PUSH
95138: LD_INT 1
95140: PUSH
95141: EMPTY
95142: LIST
95143: LIST
95144: PUSH
95145: LD_INT 4
95147: NEG
95148: PUSH
95149: LD_INT 0
95151: PUSH
95152: EMPTY
95153: LIST
95154: LIST
95155: PUSH
95156: LD_INT 4
95158: NEG
95159: PUSH
95160: LD_INT 1
95162: NEG
95163: PUSH
95164: EMPTY
95165: LIST
95166: LIST
95167: PUSH
95168: LD_INT 4
95170: NEG
95171: PUSH
95172: LD_INT 2
95174: NEG
95175: PUSH
95176: EMPTY
95177: LIST
95178: LIST
95179: PUSH
95180: LD_INT 2
95182: NEG
95183: PUSH
95184: LD_INT 2
95186: PUSH
95187: EMPTY
95188: LIST
95189: LIST
95190: PUSH
95191: LD_INT 4
95193: NEG
95194: PUSH
95195: LD_INT 4
95197: NEG
95198: PUSH
95199: EMPTY
95200: LIST
95201: LIST
95202: PUSH
95203: LD_INT 4
95205: NEG
95206: PUSH
95207: LD_INT 5
95209: NEG
95210: PUSH
95211: EMPTY
95212: LIST
95213: LIST
95214: PUSH
95215: LD_INT 3
95217: NEG
95218: PUSH
95219: LD_INT 4
95221: NEG
95222: PUSH
95223: EMPTY
95224: LIST
95225: LIST
95226: PUSH
95227: LD_INT 3
95229: NEG
95230: PUSH
95231: LD_INT 3
95233: NEG
95234: PUSH
95235: EMPTY
95236: LIST
95237: LIST
95238: PUSH
95239: LD_INT 4
95241: NEG
95242: PUSH
95243: LD_INT 3
95245: NEG
95246: PUSH
95247: EMPTY
95248: LIST
95249: LIST
95250: PUSH
95251: LD_INT 5
95253: NEG
95254: PUSH
95255: LD_INT 4
95257: NEG
95258: PUSH
95259: EMPTY
95260: LIST
95261: LIST
95262: PUSH
95263: LD_INT 5
95265: NEG
95266: PUSH
95267: LD_INT 5
95269: NEG
95270: PUSH
95271: EMPTY
95272: LIST
95273: LIST
95274: PUSH
95275: LD_INT 3
95277: NEG
95278: PUSH
95279: LD_INT 5
95281: NEG
95282: PUSH
95283: EMPTY
95284: LIST
95285: LIST
95286: PUSH
95287: LD_INT 5
95289: NEG
95290: PUSH
95291: LD_INT 3
95293: NEG
95294: PUSH
95295: EMPTY
95296: LIST
95297: LIST
95298: PUSH
95299: EMPTY
95300: LIST
95301: LIST
95302: LIST
95303: LIST
95304: LIST
95305: LIST
95306: LIST
95307: LIST
95308: LIST
95309: LIST
95310: LIST
95311: LIST
95312: LIST
95313: LIST
95314: LIST
95315: LIST
95316: LIST
95317: LIST
95318: LIST
95319: LIST
95320: LIST
95321: LIST
95322: LIST
95323: LIST
95324: LIST
95325: LIST
95326: LIST
95327: LIST
95328: LIST
95329: LIST
95330: LIST
95331: LIST
95332: LIST
95333: LIST
95334: LIST
95335: LIST
95336: LIST
95337: LIST
95338: LIST
95339: LIST
95340: LIST
95341: LIST
95342: LIST
95343: LIST
95344: LIST
95345: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
95346: LD_ADDR_VAR 0 30
95350: PUSH
95351: LD_INT 4
95353: PUSH
95354: LD_INT 4
95356: PUSH
95357: EMPTY
95358: LIST
95359: LIST
95360: PUSH
95361: LD_INT 4
95363: PUSH
95364: LD_INT 3
95366: PUSH
95367: EMPTY
95368: LIST
95369: LIST
95370: PUSH
95371: LD_INT 5
95373: PUSH
95374: LD_INT 4
95376: PUSH
95377: EMPTY
95378: LIST
95379: LIST
95380: PUSH
95381: LD_INT 5
95383: PUSH
95384: LD_INT 5
95386: PUSH
95387: EMPTY
95388: LIST
95389: LIST
95390: PUSH
95391: LD_INT 4
95393: PUSH
95394: LD_INT 5
95396: PUSH
95397: EMPTY
95398: LIST
95399: LIST
95400: PUSH
95401: LD_INT 3
95403: PUSH
95404: LD_INT 4
95406: PUSH
95407: EMPTY
95408: LIST
95409: LIST
95410: PUSH
95411: LD_INT 3
95413: PUSH
95414: LD_INT 3
95416: PUSH
95417: EMPTY
95418: LIST
95419: LIST
95420: PUSH
95421: LD_INT 5
95423: PUSH
95424: LD_INT 3
95426: PUSH
95427: EMPTY
95428: LIST
95429: LIST
95430: PUSH
95431: LD_INT 3
95433: PUSH
95434: LD_INT 5
95436: PUSH
95437: EMPTY
95438: LIST
95439: LIST
95440: PUSH
95441: LD_INT 0
95443: PUSH
95444: LD_INT 3
95446: PUSH
95447: EMPTY
95448: LIST
95449: LIST
95450: PUSH
95451: LD_INT 0
95453: PUSH
95454: LD_INT 2
95456: PUSH
95457: EMPTY
95458: LIST
95459: LIST
95460: PUSH
95461: LD_INT 1
95463: PUSH
95464: LD_INT 3
95466: PUSH
95467: EMPTY
95468: LIST
95469: LIST
95470: PUSH
95471: LD_INT 1
95473: PUSH
95474: LD_INT 4
95476: PUSH
95477: EMPTY
95478: LIST
95479: LIST
95480: PUSH
95481: LD_INT 0
95483: PUSH
95484: LD_INT 4
95486: PUSH
95487: EMPTY
95488: LIST
95489: LIST
95490: PUSH
95491: LD_INT 1
95493: NEG
95494: PUSH
95495: LD_INT 3
95497: PUSH
95498: EMPTY
95499: LIST
95500: LIST
95501: PUSH
95502: LD_INT 1
95504: NEG
95505: PUSH
95506: LD_INT 2
95508: PUSH
95509: EMPTY
95510: LIST
95511: LIST
95512: PUSH
95513: LD_INT 2
95515: PUSH
95516: LD_INT 4
95518: PUSH
95519: EMPTY
95520: LIST
95521: LIST
95522: PUSH
95523: LD_INT 2
95525: NEG
95526: PUSH
95527: LD_INT 2
95529: PUSH
95530: EMPTY
95531: LIST
95532: LIST
95533: PUSH
95534: LD_INT 4
95536: NEG
95537: PUSH
95538: LD_INT 0
95540: PUSH
95541: EMPTY
95542: LIST
95543: LIST
95544: PUSH
95545: LD_INT 4
95547: NEG
95548: PUSH
95549: LD_INT 1
95551: NEG
95552: PUSH
95553: EMPTY
95554: LIST
95555: LIST
95556: PUSH
95557: LD_INT 3
95559: NEG
95560: PUSH
95561: LD_INT 0
95563: PUSH
95564: EMPTY
95565: LIST
95566: LIST
95567: PUSH
95568: LD_INT 3
95570: NEG
95571: PUSH
95572: LD_INT 1
95574: PUSH
95575: EMPTY
95576: LIST
95577: LIST
95578: PUSH
95579: LD_INT 4
95581: NEG
95582: PUSH
95583: LD_INT 1
95585: PUSH
95586: EMPTY
95587: LIST
95588: LIST
95589: PUSH
95590: LD_INT 5
95592: NEG
95593: PUSH
95594: LD_INT 0
95596: PUSH
95597: EMPTY
95598: LIST
95599: LIST
95600: PUSH
95601: LD_INT 5
95603: NEG
95604: PUSH
95605: LD_INT 1
95607: NEG
95608: PUSH
95609: EMPTY
95610: LIST
95611: LIST
95612: PUSH
95613: LD_INT 5
95615: NEG
95616: PUSH
95617: LD_INT 2
95619: NEG
95620: PUSH
95621: EMPTY
95622: LIST
95623: LIST
95624: PUSH
95625: LD_INT 3
95627: NEG
95628: PUSH
95629: LD_INT 2
95631: PUSH
95632: EMPTY
95633: LIST
95634: LIST
95635: PUSH
95636: LD_INT 3
95638: NEG
95639: PUSH
95640: LD_INT 3
95642: NEG
95643: PUSH
95644: EMPTY
95645: LIST
95646: LIST
95647: PUSH
95648: LD_INT 3
95650: NEG
95651: PUSH
95652: LD_INT 4
95654: NEG
95655: PUSH
95656: EMPTY
95657: LIST
95658: LIST
95659: PUSH
95660: LD_INT 2
95662: NEG
95663: PUSH
95664: LD_INT 3
95666: NEG
95667: PUSH
95668: EMPTY
95669: LIST
95670: LIST
95671: PUSH
95672: LD_INT 2
95674: NEG
95675: PUSH
95676: LD_INT 2
95678: NEG
95679: PUSH
95680: EMPTY
95681: LIST
95682: LIST
95683: PUSH
95684: LD_INT 3
95686: NEG
95687: PUSH
95688: LD_INT 2
95690: NEG
95691: PUSH
95692: EMPTY
95693: LIST
95694: LIST
95695: PUSH
95696: LD_INT 4
95698: NEG
95699: PUSH
95700: LD_INT 3
95702: NEG
95703: PUSH
95704: EMPTY
95705: LIST
95706: LIST
95707: PUSH
95708: LD_INT 4
95710: NEG
95711: PUSH
95712: LD_INT 4
95714: NEG
95715: PUSH
95716: EMPTY
95717: LIST
95718: LIST
95719: PUSH
95720: LD_INT 2
95722: NEG
95723: PUSH
95724: LD_INT 4
95726: NEG
95727: PUSH
95728: EMPTY
95729: LIST
95730: LIST
95731: PUSH
95732: LD_INT 4
95734: NEG
95735: PUSH
95736: LD_INT 2
95738: NEG
95739: PUSH
95740: EMPTY
95741: LIST
95742: LIST
95743: PUSH
95744: LD_INT 0
95746: PUSH
95747: LD_INT 4
95749: NEG
95750: PUSH
95751: EMPTY
95752: LIST
95753: LIST
95754: PUSH
95755: LD_INT 0
95757: PUSH
95758: LD_INT 5
95760: NEG
95761: PUSH
95762: EMPTY
95763: LIST
95764: LIST
95765: PUSH
95766: LD_INT 1
95768: PUSH
95769: LD_INT 4
95771: NEG
95772: PUSH
95773: EMPTY
95774: LIST
95775: LIST
95776: PUSH
95777: LD_INT 1
95779: PUSH
95780: LD_INT 3
95782: NEG
95783: PUSH
95784: EMPTY
95785: LIST
95786: LIST
95787: PUSH
95788: LD_INT 0
95790: PUSH
95791: LD_INT 3
95793: NEG
95794: PUSH
95795: EMPTY
95796: LIST
95797: LIST
95798: PUSH
95799: LD_INT 1
95801: NEG
95802: PUSH
95803: LD_INT 4
95805: NEG
95806: PUSH
95807: EMPTY
95808: LIST
95809: LIST
95810: PUSH
95811: LD_INT 1
95813: NEG
95814: PUSH
95815: LD_INT 5
95817: NEG
95818: PUSH
95819: EMPTY
95820: LIST
95821: LIST
95822: PUSH
95823: LD_INT 2
95825: PUSH
95826: LD_INT 3
95828: NEG
95829: PUSH
95830: EMPTY
95831: LIST
95832: LIST
95833: PUSH
95834: LD_INT 2
95836: NEG
95837: PUSH
95838: LD_INT 5
95840: NEG
95841: PUSH
95842: EMPTY
95843: LIST
95844: LIST
95845: PUSH
95846: EMPTY
95847: LIST
95848: LIST
95849: LIST
95850: LIST
95851: LIST
95852: LIST
95853: LIST
95854: LIST
95855: LIST
95856: LIST
95857: LIST
95858: LIST
95859: LIST
95860: LIST
95861: LIST
95862: LIST
95863: LIST
95864: LIST
95865: LIST
95866: LIST
95867: LIST
95868: LIST
95869: LIST
95870: LIST
95871: LIST
95872: LIST
95873: LIST
95874: LIST
95875: LIST
95876: LIST
95877: LIST
95878: LIST
95879: LIST
95880: LIST
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
95893: LD_ADDR_VAR 0 31
95897: PUSH
95898: LD_INT 0
95900: PUSH
95901: LD_INT 4
95903: PUSH
95904: EMPTY
95905: LIST
95906: LIST
95907: PUSH
95908: LD_INT 0
95910: PUSH
95911: LD_INT 3
95913: PUSH
95914: EMPTY
95915: LIST
95916: LIST
95917: PUSH
95918: LD_INT 1
95920: PUSH
95921: LD_INT 4
95923: PUSH
95924: EMPTY
95925: LIST
95926: LIST
95927: PUSH
95928: LD_INT 1
95930: PUSH
95931: LD_INT 5
95933: PUSH
95934: EMPTY
95935: LIST
95936: LIST
95937: PUSH
95938: LD_INT 0
95940: PUSH
95941: LD_INT 5
95943: PUSH
95944: EMPTY
95945: LIST
95946: LIST
95947: PUSH
95948: LD_INT 1
95950: NEG
95951: PUSH
95952: LD_INT 4
95954: PUSH
95955: EMPTY
95956: LIST
95957: LIST
95958: PUSH
95959: LD_INT 1
95961: NEG
95962: PUSH
95963: LD_INT 3
95965: PUSH
95966: EMPTY
95967: LIST
95968: LIST
95969: PUSH
95970: LD_INT 2
95972: PUSH
95973: LD_INT 5
95975: PUSH
95976: EMPTY
95977: LIST
95978: LIST
95979: PUSH
95980: LD_INT 2
95982: NEG
95983: PUSH
95984: LD_INT 3
95986: PUSH
95987: EMPTY
95988: LIST
95989: LIST
95990: PUSH
95991: LD_INT 3
95993: NEG
95994: PUSH
95995: LD_INT 0
95997: PUSH
95998: EMPTY
95999: LIST
96000: LIST
96001: PUSH
96002: LD_INT 3
96004: NEG
96005: PUSH
96006: LD_INT 1
96008: NEG
96009: PUSH
96010: EMPTY
96011: LIST
96012: LIST
96013: PUSH
96014: LD_INT 2
96016: NEG
96017: PUSH
96018: LD_INT 0
96020: PUSH
96021: EMPTY
96022: LIST
96023: LIST
96024: PUSH
96025: LD_INT 2
96027: NEG
96028: PUSH
96029: LD_INT 1
96031: PUSH
96032: EMPTY
96033: LIST
96034: LIST
96035: PUSH
96036: LD_INT 3
96038: NEG
96039: PUSH
96040: LD_INT 1
96042: PUSH
96043: EMPTY
96044: LIST
96045: LIST
96046: PUSH
96047: LD_INT 4
96049: NEG
96050: PUSH
96051: LD_INT 0
96053: PUSH
96054: EMPTY
96055: LIST
96056: LIST
96057: PUSH
96058: LD_INT 4
96060: NEG
96061: PUSH
96062: LD_INT 1
96064: NEG
96065: PUSH
96066: EMPTY
96067: LIST
96068: LIST
96069: PUSH
96070: LD_INT 4
96072: NEG
96073: PUSH
96074: LD_INT 2
96076: NEG
96077: PUSH
96078: EMPTY
96079: LIST
96080: LIST
96081: PUSH
96082: LD_INT 2
96084: NEG
96085: PUSH
96086: LD_INT 2
96088: PUSH
96089: EMPTY
96090: LIST
96091: LIST
96092: PUSH
96093: LD_INT 4
96095: NEG
96096: PUSH
96097: LD_INT 4
96099: NEG
96100: PUSH
96101: EMPTY
96102: LIST
96103: LIST
96104: PUSH
96105: LD_INT 4
96107: NEG
96108: PUSH
96109: LD_INT 5
96111: NEG
96112: PUSH
96113: EMPTY
96114: LIST
96115: LIST
96116: PUSH
96117: LD_INT 3
96119: NEG
96120: PUSH
96121: LD_INT 4
96123: NEG
96124: PUSH
96125: EMPTY
96126: LIST
96127: LIST
96128: PUSH
96129: LD_INT 3
96131: NEG
96132: PUSH
96133: LD_INT 3
96135: NEG
96136: PUSH
96137: EMPTY
96138: LIST
96139: LIST
96140: PUSH
96141: LD_INT 4
96143: NEG
96144: PUSH
96145: LD_INT 3
96147: NEG
96148: PUSH
96149: EMPTY
96150: LIST
96151: LIST
96152: PUSH
96153: LD_INT 5
96155: NEG
96156: PUSH
96157: LD_INT 4
96159: NEG
96160: PUSH
96161: EMPTY
96162: LIST
96163: LIST
96164: PUSH
96165: LD_INT 5
96167: NEG
96168: PUSH
96169: LD_INT 5
96171: NEG
96172: PUSH
96173: EMPTY
96174: LIST
96175: LIST
96176: PUSH
96177: LD_INT 3
96179: NEG
96180: PUSH
96181: LD_INT 5
96183: NEG
96184: PUSH
96185: EMPTY
96186: LIST
96187: LIST
96188: PUSH
96189: LD_INT 5
96191: NEG
96192: PUSH
96193: LD_INT 3
96195: NEG
96196: PUSH
96197: EMPTY
96198: LIST
96199: LIST
96200: PUSH
96201: LD_INT 0
96203: PUSH
96204: LD_INT 3
96206: NEG
96207: PUSH
96208: EMPTY
96209: LIST
96210: LIST
96211: PUSH
96212: LD_INT 0
96214: PUSH
96215: LD_INT 4
96217: NEG
96218: PUSH
96219: EMPTY
96220: LIST
96221: LIST
96222: PUSH
96223: LD_INT 1
96225: PUSH
96226: LD_INT 3
96228: NEG
96229: PUSH
96230: EMPTY
96231: LIST
96232: LIST
96233: PUSH
96234: LD_INT 1
96236: PUSH
96237: LD_INT 2
96239: NEG
96240: PUSH
96241: EMPTY
96242: LIST
96243: LIST
96244: PUSH
96245: LD_INT 0
96247: PUSH
96248: LD_INT 2
96250: NEG
96251: PUSH
96252: EMPTY
96253: LIST
96254: LIST
96255: PUSH
96256: LD_INT 1
96258: NEG
96259: PUSH
96260: LD_INT 3
96262: NEG
96263: PUSH
96264: EMPTY
96265: LIST
96266: LIST
96267: PUSH
96268: LD_INT 1
96270: NEG
96271: PUSH
96272: LD_INT 4
96274: NEG
96275: PUSH
96276: EMPTY
96277: LIST
96278: LIST
96279: PUSH
96280: LD_INT 2
96282: PUSH
96283: LD_INT 2
96285: NEG
96286: PUSH
96287: EMPTY
96288: LIST
96289: LIST
96290: PUSH
96291: LD_INT 2
96293: NEG
96294: PUSH
96295: LD_INT 4
96297: NEG
96298: PUSH
96299: EMPTY
96300: LIST
96301: LIST
96302: PUSH
96303: LD_INT 4
96305: PUSH
96306: LD_INT 0
96308: PUSH
96309: EMPTY
96310: LIST
96311: LIST
96312: PUSH
96313: LD_INT 4
96315: PUSH
96316: LD_INT 1
96318: NEG
96319: PUSH
96320: EMPTY
96321: LIST
96322: LIST
96323: PUSH
96324: LD_INT 5
96326: PUSH
96327: LD_INT 0
96329: PUSH
96330: EMPTY
96331: LIST
96332: LIST
96333: PUSH
96334: LD_INT 5
96336: PUSH
96337: LD_INT 1
96339: PUSH
96340: EMPTY
96341: LIST
96342: LIST
96343: PUSH
96344: LD_INT 4
96346: PUSH
96347: LD_INT 1
96349: PUSH
96350: EMPTY
96351: LIST
96352: LIST
96353: PUSH
96354: LD_INT 3
96356: PUSH
96357: LD_INT 0
96359: PUSH
96360: EMPTY
96361: LIST
96362: LIST
96363: PUSH
96364: LD_INT 3
96366: PUSH
96367: LD_INT 1
96369: NEG
96370: PUSH
96371: EMPTY
96372: LIST
96373: LIST
96374: PUSH
96375: LD_INT 3
96377: PUSH
96378: LD_INT 2
96380: NEG
96381: PUSH
96382: EMPTY
96383: LIST
96384: LIST
96385: PUSH
96386: LD_INT 5
96388: PUSH
96389: LD_INT 2
96391: PUSH
96392: EMPTY
96393: LIST
96394: LIST
96395: PUSH
96396: EMPTY
96397: LIST
96398: LIST
96399: LIST
96400: LIST
96401: LIST
96402: LIST
96403: LIST
96404: LIST
96405: LIST
96406: LIST
96407: LIST
96408: LIST
96409: LIST
96410: LIST
96411: LIST
96412: LIST
96413: LIST
96414: LIST
96415: LIST
96416: LIST
96417: LIST
96418: LIST
96419: LIST
96420: LIST
96421: LIST
96422: LIST
96423: LIST
96424: LIST
96425: LIST
96426: LIST
96427: LIST
96428: LIST
96429: LIST
96430: LIST
96431: LIST
96432: LIST
96433: LIST
96434: LIST
96435: LIST
96436: LIST
96437: LIST
96438: LIST
96439: LIST
96440: LIST
96441: LIST
96442: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
96443: LD_ADDR_VAR 0 32
96447: PUSH
96448: LD_INT 4
96450: NEG
96451: PUSH
96452: LD_INT 0
96454: PUSH
96455: EMPTY
96456: LIST
96457: LIST
96458: PUSH
96459: LD_INT 4
96461: NEG
96462: PUSH
96463: LD_INT 1
96465: NEG
96466: PUSH
96467: EMPTY
96468: LIST
96469: LIST
96470: PUSH
96471: LD_INT 3
96473: NEG
96474: PUSH
96475: LD_INT 0
96477: PUSH
96478: EMPTY
96479: LIST
96480: LIST
96481: PUSH
96482: LD_INT 3
96484: NEG
96485: PUSH
96486: LD_INT 1
96488: PUSH
96489: EMPTY
96490: LIST
96491: LIST
96492: PUSH
96493: LD_INT 4
96495: NEG
96496: PUSH
96497: LD_INT 1
96499: PUSH
96500: EMPTY
96501: LIST
96502: LIST
96503: PUSH
96504: LD_INT 5
96506: NEG
96507: PUSH
96508: LD_INT 0
96510: PUSH
96511: EMPTY
96512: LIST
96513: LIST
96514: PUSH
96515: LD_INT 5
96517: NEG
96518: PUSH
96519: LD_INT 1
96521: NEG
96522: PUSH
96523: EMPTY
96524: LIST
96525: LIST
96526: PUSH
96527: LD_INT 5
96529: NEG
96530: PUSH
96531: LD_INT 2
96533: NEG
96534: PUSH
96535: EMPTY
96536: LIST
96537: LIST
96538: PUSH
96539: LD_INT 3
96541: NEG
96542: PUSH
96543: LD_INT 2
96545: PUSH
96546: EMPTY
96547: LIST
96548: LIST
96549: PUSH
96550: LD_INT 3
96552: NEG
96553: PUSH
96554: LD_INT 3
96556: NEG
96557: PUSH
96558: EMPTY
96559: LIST
96560: LIST
96561: PUSH
96562: LD_INT 3
96564: NEG
96565: PUSH
96566: LD_INT 4
96568: NEG
96569: PUSH
96570: EMPTY
96571: LIST
96572: LIST
96573: PUSH
96574: LD_INT 2
96576: NEG
96577: PUSH
96578: LD_INT 3
96580: NEG
96581: PUSH
96582: EMPTY
96583: LIST
96584: LIST
96585: PUSH
96586: LD_INT 2
96588: NEG
96589: PUSH
96590: LD_INT 2
96592: NEG
96593: PUSH
96594: EMPTY
96595: LIST
96596: LIST
96597: PUSH
96598: LD_INT 3
96600: NEG
96601: PUSH
96602: LD_INT 2
96604: NEG
96605: PUSH
96606: EMPTY
96607: LIST
96608: LIST
96609: PUSH
96610: LD_INT 4
96612: NEG
96613: PUSH
96614: LD_INT 3
96616: NEG
96617: PUSH
96618: EMPTY
96619: LIST
96620: LIST
96621: PUSH
96622: LD_INT 4
96624: NEG
96625: PUSH
96626: LD_INT 4
96628: NEG
96629: PUSH
96630: EMPTY
96631: LIST
96632: LIST
96633: PUSH
96634: LD_INT 2
96636: NEG
96637: PUSH
96638: LD_INT 4
96640: NEG
96641: PUSH
96642: EMPTY
96643: LIST
96644: LIST
96645: PUSH
96646: LD_INT 4
96648: NEG
96649: PUSH
96650: LD_INT 2
96652: NEG
96653: PUSH
96654: EMPTY
96655: LIST
96656: LIST
96657: PUSH
96658: LD_INT 0
96660: PUSH
96661: LD_INT 4
96663: NEG
96664: PUSH
96665: EMPTY
96666: LIST
96667: LIST
96668: PUSH
96669: LD_INT 0
96671: PUSH
96672: LD_INT 5
96674: NEG
96675: PUSH
96676: EMPTY
96677: LIST
96678: LIST
96679: PUSH
96680: LD_INT 1
96682: PUSH
96683: LD_INT 4
96685: NEG
96686: PUSH
96687: EMPTY
96688: LIST
96689: LIST
96690: PUSH
96691: LD_INT 1
96693: PUSH
96694: LD_INT 3
96696: NEG
96697: PUSH
96698: EMPTY
96699: LIST
96700: LIST
96701: PUSH
96702: LD_INT 0
96704: PUSH
96705: LD_INT 3
96707: NEG
96708: PUSH
96709: EMPTY
96710: LIST
96711: LIST
96712: PUSH
96713: LD_INT 1
96715: NEG
96716: PUSH
96717: LD_INT 4
96719: NEG
96720: PUSH
96721: EMPTY
96722: LIST
96723: LIST
96724: PUSH
96725: LD_INT 1
96727: NEG
96728: PUSH
96729: LD_INT 5
96731: NEG
96732: PUSH
96733: EMPTY
96734: LIST
96735: LIST
96736: PUSH
96737: LD_INT 2
96739: PUSH
96740: LD_INT 3
96742: NEG
96743: PUSH
96744: EMPTY
96745: LIST
96746: LIST
96747: PUSH
96748: LD_INT 2
96750: NEG
96751: PUSH
96752: LD_INT 5
96754: NEG
96755: PUSH
96756: EMPTY
96757: LIST
96758: LIST
96759: PUSH
96760: LD_INT 3
96762: PUSH
96763: LD_INT 0
96765: PUSH
96766: EMPTY
96767: LIST
96768: LIST
96769: PUSH
96770: LD_INT 3
96772: PUSH
96773: LD_INT 1
96775: NEG
96776: PUSH
96777: EMPTY
96778: LIST
96779: LIST
96780: PUSH
96781: LD_INT 4
96783: PUSH
96784: LD_INT 0
96786: PUSH
96787: EMPTY
96788: LIST
96789: LIST
96790: PUSH
96791: LD_INT 4
96793: PUSH
96794: LD_INT 1
96796: PUSH
96797: EMPTY
96798: LIST
96799: LIST
96800: PUSH
96801: LD_INT 3
96803: PUSH
96804: LD_INT 1
96806: PUSH
96807: EMPTY
96808: LIST
96809: LIST
96810: PUSH
96811: LD_INT 2
96813: PUSH
96814: LD_INT 0
96816: PUSH
96817: EMPTY
96818: LIST
96819: LIST
96820: PUSH
96821: LD_INT 2
96823: PUSH
96824: LD_INT 1
96826: NEG
96827: PUSH
96828: EMPTY
96829: LIST
96830: LIST
96831: PUSH
96832: LD_INT 2
96834: PUSH
96835: LD_INT 2
96837: NEG
96838: PUSH
96839: EMPTY
96840: LIST
96841: LIST
96842: PUSH
96843: LD_INT 4
96845: PUSH
96846: LD_INT 2
96848: PUSH
96849: EMPTY
96850: LIST
96851: LIST
96852: PUSH
96853: LD_INT 4
96855: PUSH
96856: LD_INT 4
96858: PUSH
96859: EMPTY
96860: LIST
96861: LIST
96862: PUSH
96863: LD_INT 4
96865: PUSH
96866: LD_INT 3
96868: PUSH
96869: EMPTY
96870: LIST
96871: LIST
96872: PUSH
96873: LD_INT 5
96875: PUSH
96876: LD_INT 4
96878: PUSH
96879: EMPTY
96880: LIST
96881: LIST
96882: PUSH
96883: LD_INT 5
96885: PUSH
96886: LD_INT 5
96888: PUSH
96889: EMPTY
96890: LIST
96891: LIST
96892: PUSH
96893: LD_INT 4
96895: PUSH
96896: LD_INT 5
96898: PUSH
96899: EMPTY
96900: LIST
96901: LIST
96902: PUSH
96903: LD_INT 3
96905: PUSH
96906: LD_INT 4
96908: PUSH
96909: EMPTY
96910: LIST
96911: LIST
96912: PUSH
96913: LD_INT 3
96915: PUSH
96916: LD_INT 3
96918: PUSH
96919: EMPTY
96920: LIST
96921: LIST
96922: PUSH
96923: LD_INT 5
96925: PUSH
96926: LD_INT 3
96928: PUSH
96929: EMPTY
96930: LIST
96931: LIST
96932: PUSH
96933: LD_INT 3
96935: PUSH
96936: LD_INT 5
96938: PUSH
96939: EMPTY
96940: LIST
96941: LIST
96942: PUSH
96943: EMPTY
96944: LIST
96945: LIST
96946: LIST
96947: LIST
96948: LIST
96949: LIST
96950: LIST
96951: LIST
96952: LIST
96953: LIST
96954: LIST
96955: LIST
96956: LIST
96957: LIST
96958: LIST
96959: LIST
96960: LIST
96961: LIST
96962: LIST
96963: LIST
96964: LIST
96965: LIST
96966: LIST
96967: LIST
96968: LIST
96969: LIST
96970: LIST
96971: LIST
96972: LIST
96973: LIST
96974: LIST
96975: LIST
96976: LIST
96977: LIST
96978: LIST
96979: LIST
96980: LIST
96981: LIST
96982: LIST
96983: LIST
96984: LIST
96985: LIST
96986: LIST
96987: LIST
96988: LIST
96989: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96990: LD_ADDR_VAR 0 33
96994: PUSH
96995: LD_INT 4
96997: NEG
96998: PUSH
96999: LD_INT 4
97001: NEG
97002: PUSH
97003: EMPTY
97004: LIST
97005: LIST
97006: PUSH
97007: LD_INT 4
97009: NEG
97010: PUSH
97011: LD_INT 5
97013: NEG
97014: PUSH
97015: EMPTY
97016: LIST
97017: LIST
97018: PUSH
97019: LD_INT 3
97021: NEG
97022: PUSH
97023: LD_INT 4
97025: NEG
97026: PUSH
97027: EMPTY
97028: LIST
97029: LIST
97030: PUSH
97031: LD_INT 3
97033: NEG
97034: PUSH
97035: LD_INT 3
97037: NEG
97038: PUSH
97039: EMPTY
97040: LIST
97041: LIST
97042: PUSH
97043: LD_INT 4
97045: NEG
97046: PUSH
97047: LD_INT 3
97049: NEG
97050: PUSH
97051: EMPTY
97052: LIST
97053: LIST
97054: PUSH
97055: LD_INT 5
97057: NEG
97058: PUSH
97059: LD_INT 4
97061: NEG
97062: PUSH
97063: EMPTY
97064: LIST
97065: LIST
97066: PUSH
97067: LD_INT 5
97069: NEG
97070: PUSH
97071: LD_INT 5
97073: NEG
97074: PUSH
97075: EMPTY
97076: LIST
97077: LIST
97078: PUSH
97079: LD_INT 3
97081: NEG
97082: PUSH
97083: LD_INT 5
97085: NEG
97086: PUSH
97087: EMPTY
97088: LIST
97089: LIST
97090: PUSH
97091: LD_INT 5
97093: NEG
97094: PUSH
97095: LD_INT 3
97097: NEG
97098: PUSH
97099: EMPTY
97100: LIST
97101: LIST
97102: PUSH
97103: LD_INT 0
97105: PUSH
97106: LD_INT 3
97108: NEG
97109: PUSH
97110: EMPTY
97111: LIST
97112: LIST
97113: PUSH
97114: LD_INT 0
97116: PUSH
97117: LD_INT 4
97119: NEG
97120: PUSH
97121: EMPTY
97122: LIST
97123: LIST
97124: PUSH
97125: LD_INT 1
97127: PUSH
97128: LD_INT 3
97130: NEG
97131: PUSH
97132: EMPTY
97133: LIST
97134: LIST
97135: PUSH
97136: LD_INT 1
97138: PUSH
97139: LD_INT 2
97141: NEG
97142: PUSH
97143: EMPTY
97144: LIST
97145: LIST
97146: PUSH
97147: LD_INT 0
97149: PUSH
97150: LD_INT 2
97152: NEG
97153: PUSH
97154: EMPTY
97155: LIST
97156: LIST
97157: PUSH
97158: LD_INT 1
97160: NEG
97161: PUSH
97162: LD_INT 3
97164: NEG
97165: PUSH
97166: EMPTY
97167: LIST
97168: LIST
97169: PUSH
97170: LD_INT 1
97172: NEG
97173: PUSH
97174: LD_INT 4
97176: NEG
97177: PUSH
97178: EMPTY
97179: LIST
97180: LIST
97181: PUSH
97182: LD_INT 2
97184: PUSH
97185: LD_INT 2
97187: NEG
97188: PUSH
97189: EMPTY
97190: LIST
97191: LIST
97192: PUSH
97193: LD_INT 2
97195: NEG
97196: PUSH
97197: LD_INT 4
97199: NEG
97200: PUSH
97201: EMPTY
97202: LIST
97203: LIST
97204: PUSH
97205: LD_INT 4
97207: PUSH
97208: LD_INT 0
97210: PUSH
97211: EMPTY
97212: LIST
97213: LIST
97214: PUSH
97215: LD_INT 4
97217: PUSH
97218: LD_INT 1
97220: NEG
97221: PUSH
97222: EMPTY
97223: LIST
97224: LIST
97225: PUSH
97226: LD_INT 5
97228: PUSH
97229: LD_INT 0
97231: PUSH
97232: EMPTY
97233: LIST
97234: LIST
97235: PUSH
97236: LD_INT 5
97238: PUSH
97239: LD_INT 1
97241: PUSH
97242: EMPTY
97243: LIST
97244: LIST
97245: PUSH
97246: LD_INT 4
97248: PUSH
97249: LD_INT 1
97251: PUSH
97252: EMPTY
97253: LIST
97254: LIST
97255: PUSH
97256: LD_INT 3
97258: PUSH
97259: LD_INT 0
97261: PUSH
97262: EMPTY
97263: LIST
97264: LIST
97265: PUSH
97266: LD_INT 3
97268: PUSH
97269: LD_INT 1
97271: NEG
97272: PUSH
97273: EMPTY
97274: LIST
97275: LIST
97276: PUSH
97277: LD_INT 3
97279: PUSH
97280: LD_INT 2
97282: NEG
97283: PUSH
97284: EMPTY
97285: LIST
97286: LIST
97287: PUSH
97288: LD_INT 5
97290: PUSH
97291: LD_INT 2
97293: PUSH
97294: EMPTY
97295: LIST
97296: LIST
97297: PUSH
97298: LD_INT 3
97300: PUSH
97301: LD_INT 3
97303: PUSH
97304: EMPTY
97305: LIST
97306: LIST
97307: PUSH
97308: LD_INT 3
97310: PUSH
97311: LD_INT 2
97313: PUSH
97314: EMPTY
97315: LIST
97316: LIST
97317: PUSH
97318: LD_INT 4
97320: PUSH
97321: LD_INT 3
97323: PUSH
97324: EMPTY
97325: LIST
97326: LIST
97327: PUSH
97328: LD_INT 4
97330: PUSH
97331: LD_INT 4
97333: PUSH
97334: EMPTY
97335: LIST
97336: LIST
97337: PUSH
97338: LD_INT 3
97340: PUSH
97341: LD_INT 4
97343: PUSH
97344: EMPTY
97345: LIST
97346: LIST
97347: PUSH
97348: LD_INT 2
97350: PUSH
97351: LD_INT 3
97353: PUSH
97354: EMPTY
97355: LIST
97356: LIST
97357: PUSH
97358: LD_INT 2
97360: PUSH
97361: LD_INT 2
97363: PUSH
97364: EMPTY
97365: LIST
97366: LIST
97367: PUSH
97368: LD_INT 4
97370: PUSH
97371: LD_INT 2
97373: PUSH
97374: EMPTY
97375: LIST
97376: LIST
97377: PUSH
97378: LD_INT 2
97380: PUSH
97381: LD_INT 4
97383: PUSH
97384: EMPTY
97385: LIST
97386: LIST
97387: PUSH
97388: LD_INT 0
97390: PUSH
97391: LD_INT 4
97393: PUSH
97394: EMPTY
97395: LIST
97396: LIST
97397: PUSH
97398: LD_INT 0
97400: PUSH
97401: LD_INT 3
97403: PUSH
97404: EMPTY
97405: LIST
97406: LIST
97407: PUSH
97408: LD_INT 1
97410: PUSH
97411: LD_INT 4
97413: PUSH
97414: EMPTY
97415: LIST
97416: LIST
97417: PUSH
97418: LD_INT 1
97420: PUSH
97421: LD_INT 5
97423: PUSH
97424: EMPTY
97425: LIST
97426: LIST
97427: PUSH
97428: LD_INT 0
97430: PUSH
97431: LD_INT 5
97433: PUSH
97434: EMPTY
97435: LIST
97436: LIST
97437: PUSH
97438: LD_INT 1
97440: NEG
97441: PUSH
97442: LD_INT 4
97444: PUSH
97445: EMPTY
97446: LIST
97447: LIST
97448: PUSH
97449: LD_INT 1
97451: NEG
97452: PUSH
97453: LD_INT 3
97455: PUSH
97456: EMPTY
97457: LIST
97458: LIST
97459: PUSH
97460: LD_INT 2
97462: PUSH
97463: LD_INT 5
97465: PUSH
97466: EMPTY
97467: LIST
97468: LIST
97469: PUSH
97470: LD_INT 2
97472: NEG
97473: PUSH
97474: LD_INT 3
97476: PUSH
97477: EMPTY
97478: LIST
97479: LIST
97480: PUSH
97481: EMPTY
97482: LIST
97483: LIST
97484: LIST
97485: LIST
97486: LIST
97487: LIST
97488: LIST
97489: LIST
97490: LIST
97491: LIST
97492: LIST
97493: LIST
97494: LIST
97495: LIST
97496: LIST
97497: LIST
97498: LIST
97499: LIST
97500: LIST
97501: LIST
97502: LIST
97503: LIST
97504: LIST
97505: LIST
97506: LIST
97507: LIST
97508: LIST
97509: LIST
97510: LIST
97511: LIST
97512: LIST
97513: LIST
97514: LIST
97515: LIST
97516: LIST
97517: LIST
97518: LIST
97519: LIST
97520: LIST
97521: LIST
97522: LIST
97523: LIST
97524: LIST
97525: LIST
97526: LIST
97527: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
97528: LD_ADDR_VAR 0 34
97532: PUSH
97533: LD_INT 0
97535: PUSH
97536: LD_INT 4
97538: NEG
97539: PUSH
97540: EMPTY
97541: LIST
97542: LIST
97543: PUSH
97544: LD_INT 0
97546: PUSH
97547: LD_INT 5
97549: NEG
97550: PUSH
97551: EMPTY
97552: LIST
97553: LIST
97554: PUSH
97555: LD_INT 1
97557: PUSH
97558: LD_INT 4
97560: NEG
97561: PUSH
97562: EMPTY
97563: LIST
97564: LIST
97565: PUSH
97566: LD_INT 1
97568: PUSH
97569: LD_INT 3
97571: NEG
97572: PUSH
97573: EMPTY
97574: LIST
97575: LIST
97576: PUSH
97577: LD_INT 0
97579: PUSH
97580: LD_INT 3
97582: NEG
97583: PUSH
97584: EMPTY
97585: LIST
97586: LIST
97587: PUSH
97588: LD_INT 1
97590: NEG
97591: PUSH
97592: LD_INT 4
97594: NEG
97595: PUSH
97596: EMPTY
97597: LIST
97598: LIST
97599: PUSH
97600: LD_INT 1
97602: NEG
97603: PUSH
97604: LD_INT 5
97606: NEG
97607: PUSH
97608: EMPTY
97609: LIST
97610: LIST
97611: PUSH
97612: LD_INT 2
97614: PUSH
97615: LD_INT 3
97617: NEG
97618: PUSH
97619: EMPTY
97620: LIST
97621: LIST
97622: PUSH
97623: LD_INT 2
97625: NEG
97626: PUSH
97627: LD_INT 5
97629: NEG
97630: PUSH
97631: EMPTY
97632: LIST
97633: LIST
97634: PUSH
97635: LD_INT 3
97637: PUSH
97638: LD_INT 0
97640: PUSH
97641: EMPTY
97642: LIST
97643: LIST
97644: PUSH
97645: LD_INT 3
97647: PUSH
97648: LD_INT 1
97650: NEG
97651: PUSH
97652: EMPTY
97653: LIST
97654: LIST
97655: PUSH
97656: LD_INT 4
97658: PUSH
97659: LD_INT 0
97661: PUSH
97662: EMPTY
97663: LIST
97664: LIST
97665: PUSH
97666: LD_INT 4
97668: PUSH
97669: LD_INT 1
97671: PUSH
97672: EMPTY
97673: LIST
97674: LIST
97675: PUSH
97676: LD_INT 3
97678: PUSH
97679: LD_INT 1
97681: PUSH
97682: EMPTY
97683: LIST
97684: LIST
97685: PUSH
97686: LD_INT 2
97688: PUSH
97689: LD_INT 0
97691: PUSH
97692: EMPTY
97693: LIST
97694: LIST
97695: PUSH
97696: LD_INT 2
97698: PUSH
97699: LD_INT 1
97701: NEG
97702: PUSH
97703: EMPTY
97704: LIST
97705: LIST
97706: PUSH
97707: LD_INT 2
97709: PUSH
97710: LD_INT 2
97712: NEG
97713: PUSH
97714: EMPTY
97715: LIST
97716: LIST
97717: PUSH
97718: LD_INT 4
97720: PUSH
97721: LD_INT 2
97723: PUSH
97724: EMPTY
97725: LIST
97726: LIST
97727: PUSH
97728: LD_INT 4
97730: PUSH
97731: LD_INT 4
97733: PUSH
97734: EMPTY
97735: LIST
97736: LIST
97737: PUSH
97738: LD_INT 4
97740: PUSH
97741: LD_INT 3
97743: PUSH
97744: EMPTY
97745: LIST
97746: LIST
97747: PUSH
97748: LD_INT 5
97750: PUSH
97751: LD_INT 4
97753: PUSH
97754: EMPTY
97755: LIST
97756: LIST
97757: PUSH
97758: LD_INT 5
97760: PUSH
97761: LD_INT 5
97763: PUSH
97764: EMPTY
97765: LIST
97766: LIST
97767: PUSH
97768: LD_INT 4
97770: PUSH
97771: LD_INT 5
97773: PUSH
97774: EMPTY
97775: LIST
97776: LIST
97777: PUSH
97778: LD_INT 3
97780: PUSH
97781: LD_INT 4
97783: PUSH
97784: EMPTY
97785: LIST
97786: LIST
97787: PUSH
97788: LD_INT 3
97790: PUSH
97791: LD_INT 3
97793: PUSH
97794: EMPTY
97795: LIST
97796: LIST
97797: PUSH
97798: LD_INT 5
97800: PUSH
97801: LD_INT 3
97803: PUSH
97804: EMPTY
97805: LIST
97806: LIST
97807: PUSH
97808: LD_INT 3
97810: PUSH
97811: LD_INT 5
97813: PUSH
97814: EMPTY
97815: LIST
97816: LIST
97817: PUSH
97818: LD_INT 0
97820: PUSH
97821: LD_INT 3
97823: PUSH
97824: EMPTY
97825: LIST
97826: LIST
97827: PUSH
97828: LD_INT 0
97830: PUSH
97831: LD_INT 2
97833: PUSH
97834: EMPTY
97835: LIST
97836: LIST
97837: PUSH
97838: LD_INT 1
97840: PUSH
97841: LD_INT 3
97843: PUSH
97844: EMPTY
97845: LIST
97846: LIST
97847: PUSH
97848: LD_INT 1
97850: PUSH
97851: LD_INT 4
97853: PUSH
97854: EMPTY
97855: LIST
97856: LIST
97857: PUSH
97858: LD_INT 0
97860: PUSH
97861: LD_INT 4
97863: PUSH
97864: EMPTY
97865: LIST
97866: LIST
97867: PUSH
97868: LD_INT 1
97870: NEG
97871: PUSH
97872: LD_INT 3
97874: PUSH
97875: EMPTY
97876: LIST
97877: LIST
97878: PUSH
97879: LD_INT 1
97881: NEG
97882: PUSH
97883: LD_INT 2
97885: PUSH
97886: EMPTY
97887: LIST
97888: LIST
97889: PUSH
97890: LD_INT 2
97892: PUSH
97893: LD_INT 4
97895: PUSH
97896: EMPTY
97897: LIST
97898: LIST
97899: PUSH
97900: LD_INT 2
97902: NEG
97903: PUSH
97904: LD_INT 2
97906: PUSH
97907: EMPTY
97908: LIST
97909: LIST
97910: PUSH
97911: LD_INT 4
97913: NEG
97914: PUSH
97915: LD_INT 0
97917: PUSH
97918: EMPTY
97919: LIST
97920: LIST
97921: PUSH
97922: LD_INT 4
97924: NEG
97925: PUSH
97926: LD_INT 1
97928: NEG
97929: PUSH
97930: EMPTY
97931: LIST
97932: LIST
97933: PUSH
97934: LD_INT 3
97936: NEG
97937: PUSH
97938: LD_INT 0
97940: PUSH
97941: EMPTY
97942: LIST
97943: LIST
97944: PUSH
97945: LD_INT 3
97947: NEG
97948: PUSH
97949: LD_INT 1
97951: PUSH
97952: EMPTY
97953: LIST
97954: LIST
97955: PUSH
97956: LD_INT 4
97958: NEG
97959: PUSH
97960: LD_INT 1
97962: PUSH
97963: EMPTY
97964: LIST
97965: LIST
97966: PUSH
97967: LD_INT 5
97969: NEG
97970: PUSH
97971: LD_INT 0
97973: PUSH
97974: EMPTY
97975: LIST
97976: LIST
97977: PUSH
97978: LD_INT 5
97980: NEG
97981: PUSH
97982: LD_INT 1
97984: NEG
97985: PUSH
97986: EMPTY
97987: LIST
97988: LIST
97989: PUSH
97990: LD_INT 5
97992: NEG
97993: PUSH
97994: LD_INT 2
97996: NEG
97997: PUSH
97998: EMPTY
97999: LIST
98000: LIST
98001: PUSH
98002: LD_INT 3
98004: NEG
98005: PUSH
98006: LD_INT 2
98008: PUSH
98009: EMPTY
98010: LIST
98011: LIST
98012: PUSH
98013: EMPTY
98014: LIST
98015: LIST
98016: LIST
98017: LIST
98018: LIST
98019: LIST
98020: LIST
98021: LIST
98022: LIST
98023: LIST
98024: LIST
98025: LIST
98026: LIST
98027: LIST
98028: LIST
98029: LIST
98030: LIST
98031: LIST
98032: LIST
98033: LIST
98034: LIST
98035: LIST
98036: LIST
98037: LIST
98038: LIST
98039: LIST
98040: LIST
98041: LIST
98042: LIST
98043: LIST
98044: LIST
98045: LIST
98046: LIST
98047: LIST
98048: LIST
98049: LIST
98050: LIST
98051: LIST
98052: LIST
98053: LIST
98054: LIST
98055: LIST
98056: LIST
98057: LIST
98058: LIST
98059: ST_TO_ADDR
// end ; end ;
98060: GO 98063
98062: POP
// case btype of b_depot , b_warehouse :
98063: LD_VAR 0 1
98067: PUSH
98068: LD_INT 0
98070: DOUBLE
98071: EQUAL
98072: IFTRUE 98082
98074: LD_INT 1
98076: DOUBLE
98077: EQUAL
98078: IFTRUE 98082
98080: GO 98283
98082: POP
// case nation of nation_american :
98083: LD_VAR 0 5
98087: PUSH
98088: LD_INT 1
98090: DOUBLE
98091: EQUAL
98092: IFTRUE 98096
98094: GO 98152
98096: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
98097: LD_ADDR_VAR 0 9
98101: PUSH
98102: LD_VAR 0 11
98106: PUSH
98107: LD_VAR 0 12
98111: PUSH
98112: LD_VAR 0 13
98116: PUSH
98117: LD_VAR 0 14
98121: PUSH
98122: LD_VAR 0 15
98126: PUSH
98127: LD_VAR 0 16
98131: PUSH
98132: EMPTY
98133: LIST
98134: LIST
98135: LIST
98136: LIST
98137: LIST
98138: LIST
98139: PUSH
98140: LD_VAR 0 4
98144: PUSH
98145: LD_INT 1
98147: PLUS
98148: ARRAY
98149: ST_TO_ADDR
98150: GO 98281
98152: LD_INT 2
98154: DOUBLE
98155: EQUAL
98156: IFTRUE 98160
98158: GO 98216
98160: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
98161: LD_ADDR_VAR 0 9
98165: PUSH
98166: LD_VAR 0 17
98170: PUSH
98171: LD_VAR 0 18
98175: PUSH
98176: LD_VAR 0 19
98180: PUSH
98181: LD_VAR 0 20
98185: PUSH
98186: LD_VAR 0 21
98190: PUSH
98191: LD_VAR 0 22
98195: PUSH
98196: EMPTY
98197: LIST
98198: LIST
98199: LIST
98200: LIST
98201: LIST
98202: LIST
98203: PUSH
98204: LD_VAR 0 4
98208: PUSH
98209: LD_INT 1
98211: PLUS
98212: ARRAY
98213: ST_TO_ADDR
98214: GO 98281
98216: LD_INT 3
98218: DOUBLE
98219: EQUAL
98220: IFTRUE 98224
98222: GO 98280
98224: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
98225: LD_ADDR_VAR 0 9
98229: PUSH
98230: LD_VAR 0 23
98234: PUSH
98235: LD_VAR 0 24
98239: PUSH
98240: LD_VAR 0 25
98244: PUSH
98245: LD_VAR 0 26
98249: PUSH
98250: LD_VAR 0 27
98254: PUSH
98255: LD_VAR 0 28
98259: PUSH
98260: EMPTY
98261: LIST
98262: LIST
98263: LIST
98264: LIST
98265: LIST
98266: LIST
98267: PUSH
98268: LD_VAR 0 4
98272: PUSH
98273: LD_INT 1
98275: PLUS
98276: ARRAY
98277: ST_TO_ADDR
98278: GO 98281
98280: POP
98281: GO 98836
98283: LD_INT 2
98285: DOUBLE
98286: EQUAL
98287: IFTRUE 98297
98289: LD_INT 3
98291: DOUBLE
98292: EQUAL
98293: IFTRUE 98297
98295: GO 98353
98297: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
98298: LD_ADDR_VAR 0 9
98302: PUSH
98303: LD_VAR 0 29
98307: PUSH
98308: LD_VAR 0 30
98312: PUSH
98313: LD_VAR 0 31
98317: PUSH
98318: LD_VAR 0 32
98322: PUSH
98323: LD_VAR 0 33
98327: PUSH
98328: LD_VAR 0 34
98332: PUSH
98333: EMPTY
98334: LIST
98335: LIST
98336: LIST
98337: LIST
98338: LIST
98339: LIST
98340: PUSH
98341: LD_VAR 0 4
98345: PUSH
98346: LD_INT 1
98348: PLUS
98349: ARRAY
98350: ST_TO_ADDR
98351: GO 98836
98353: LD_INT 16
98355: DOUBLE
98356: EQUAL
98357: IFTRUE 98415
98359: LD_INT 17
98361: DOUBLE
98362: EQUAL
98363: IFTRUE 98415
98365: LD_INT 18
98367: DOUBLE
98368: EQUAL
98369: IFTRUE 98415
98371: LD_INT 19
98373: DOUBLE
98374: EQUAL
98375: IFTRUE 98415
98377: LD_INT 22
98379: DOUBLE
98380: EQUAL
98381: IFTRUE 98415
98383: LD_INT 20
98385: DOUBLE
98386: EQUAL
98387: IFTRUE 98415
98389: LD_INT 21
98391: DOUBLE
98392: EQUAL
98393: IFTRUE 98415
98395: LD_INT 23
98397: DOUBLE
98398: EQUAL
98399: IFTRUE 98415
98401: LD_INT 24
98403: DOUBLE
98404: EQUAL
98405: IFTRUE 98415
98407: LD_INT 25
98409: DOUBLE
98410: EQUAL
98411: IFTRUE 98415
98413: GO 98471
98415: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
98416: LD_ADDR_VAR 0 9
98420: PUSH
98421: LD_VAR 0 35
98425: PUSH
98426: LD_VAR 0 36
98430: PUSH
98431: LD_VAR 0 37
98435: PUSH
98436: LD_VAR 0 38
98440: PUSH
98441: LD_VAR 0 39
98445: PUSH
98446: LD_VAR 0 40
98450: PUSH
98451: EMPTY
98452: LIST
98453: LIST
98454: LIST
98455: LIST
98456: LIST
98457: LIST
98458: PUSH
98459: LD_VAR 0 4
98463: PUSH
98464: LD_INT 1
98466: PLUS
98467: ARRAY
98468: ST_TO_ADDR
98469: GO 98836
98471: LD_INT 6
98473: DOUBLE
98474: EQUAL
98475: IFTRUE 98527
98477: LD_INT 7
98479: DOUBLE
98480: EQUAL
98481: IFTRUE 98527
98483: LD_INT 8
98485: DOUBLE
98486: EQUAL
98487: IFTRUE 98527
98489: LD_INT 13
98491: DOUBLE
98492: EQUAL
98493: IFTRUE 98527
98495: LD_INT 12
98497: DOUBLE
98498: EQUAL
98499: IFTRUE 98527
98501: LD_INT 15
98503: DOUBLE
98504: EQUAL
98505: IFTRUE 98527
98507: LD_INT 11
98509: DOUBLE
98510: EQUAL
98511: IFTRUE 98527
98513: LD_INT 14
98515: DOUBLE
98516: EQUAL
98517: IFTRUE 98527
98519: LD_INT 10
98521: DOUBLE
98522: EQUAL
98523: IFTRUE 98527
98525: GO 98583
98527: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
98528: LD_ADDR_VAR 0 9
98532: PUSH
98533: LD_VAR 0 41
98537: PUSH
98538: LD_VAR 0 42
98542: PUSH
98543: LD_VAR 0 43
98547: PUSH
98548: LD_VAR 0 44
98552: PUSH
98553: LD_VAR 0 45
98557: PUSH
98558: LD_VAR 0 46
98562: PUSH
98563: EMPTY
98564: LIST
98565: LIST
98566: LIST
98567: LIST
98568: LIST
98569: LIST
98570: PUSH
98571: LD_VAR 0 4
98575: PUSH
98576: LD_INT 1
98578: PLUS
98579: ARRAY
98580: ST_TO_ADDR
98581: GO 98836
98583: LD_INT 36
98585: DOUBLE
98586: EQUAL
98587: IFTRUE 98591
98589: GO 98647
98591: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
98592: LD_ADDR_VAR 0 9
98596: PUSH
98597: LD_VAR 0 47
98601: PUSH
98602: LD_VAR 0 48
98606: PUSH
98607: LD_VAR 0 49
98611: PUSH
98612: LD_VAR 0 50
98616: PUSH
98617: LD_VAR 0 51
98621: PUSH
98622: LD_VAR 0 52
98626: PUSH
98627: EMPTY
98628: LIST
98629: LIST
98630: LIST
98631: LIST
98632: LIST
98633: LIST
98634: PUSH
98635: LD_VAR 0 4
98639: PUSH
98640: LD_INT 1
98642: PLUS
98643: ARRAY
98644: ST_TO_ADDR
98645: GO 98836
98647: LD_INT 4
98649: DOUBLE
98650: EQUAL
98651: IFTRUE 98673
98653: LD_INT 5
98655: DOUBLE
98656: EQUAL
98657: IFTRUE 98673
98659: LD_INT 34
98661: DOUBLE
98662: EQUAL
98663: IFTRUE 98673
98665: LD_INT 37
98667: DOUBLE
98668: EQUAL
98669: IFTRUE 98673
98671: GO 98729
98673: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
98674: LD_ADDR_VAR 0 9
98678: PUSH
98679: LD_VAR 0 53
98683: PUSH
98684: LD_VAR 0 54
98688: PUSH
98689: LD_VAR 0 55
98693: PUSH
98694: LD_VAR 0 56
98698: PUSH
98699: LD_VAR 0 57
98703: PUSH
98704: LD_VAR 0 58
98708: PUSH
98709: EMPTY
98710: LIST
98711: LIST
98712: LIST
98713: LIST
98714: LIST
98715: LIST
98716: PUSH
98717: LD_VAR 0 4
98721: PUSH
98722: LD_INT 1
98724: PLUS
98725: ARRAY
98726: ST_TO_ADDR
98727: GO 98836
98729: LD_INT 31
98731: DOUBLE
98732: EQUAL
98733: IFTRUE 98779
98735: LD_INT 32
98737: DOUBLE
98738: EQUAL
98739: IFTRUE 98779
98741: LD_INT 33
98743: DOUBLE
98744: EQUAL
98745: IFTRUE 98779
98747: LD_INT 27
98749: DOUBLE
98750: EQUAL
98751: IFTRUE 98779
98753: LD_INT 26
98755: DOUBLE
98756: EQUAL
98757: IFTRUE 98779
98759: LD_INT 28
98761: DOUBLE
98762: EQUAL
98763: IFTRUE 98779
98765: LD_INT 29
98767: DOUBLE
98768: EQUAL
98769: IFTRUE 98779
98771: LD_INT 30
98773: DOUBLE
98774: EQUAL
98775: IFTRUE 98779
98777: GO 98835
98779: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
98780: LD_ADDR_VAR 0 9
98784: PUSH
98785: LD_VAR 0 59
98789: PUSH
98790: LD_VAR 0 60
98794: PUSH
98795: LD_VAR 0 61
98799: PUSH
98800: LD_VAR 0 62
98804: PUSH
98805: LD_VAR 0 63
98809: PUSH
98810: LD_VAR 0 64
98814: PUSH
98815: EMPTY
98816: LIST
98817: LIST
98818: LIST
98819: LIST
98820: LIST
98821: LIST
98822: PUSH
98823: LD_VAR 0 4
98827: PUSH
98828: LD_INT 1
98830: PLUS
98831: ARRAY
98832: ST_TO_ADDR
98833: GO 98836
98835: POP
// temp_list2 = [ ] ;
98836: LD_ADDR_VAR 0 10
98840: PUSH
98841: EMPTY
98842: ST_TO_ADDR
// for i in temp_list do
98843: LD_ADDR_VAR 0 8
98847: PUSH
98848: LD_VAR 0 9
98852: PUSH
98853: FOR_IN
98854: IFFALSE 98906
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
98856: LD_ADDR_VAR 0 10
98860: PUSH
98861: LD_VAR 0 10
98865: PUSH
98866: LD_VAR 0 8
98870: PUSH
98871: LD_INT 1
98873: ARRAY
98874: PUSH
98875: LD_VAR 0 2
98879: PLUS
98880: PUSH
98881: LD_VAR 0 8
98885: PUSH
98886: LD_INT 2
98888: ARRAY
98889: PUSH
98890: LD_VAR 0 3
98894: PLUS
98895: PUSH
98896: EMPTY
98897: LIST
98898: LIST
98899: PUSH
98900: EMPTY
98901: LIST
98902: ADD
98903: ST_TO_ADDR
98904: GO 98853
98906: POP
98907: POP
// result = temp_list2 ;
98908: LD_ADDR_VAR 0 7
98912: PUSH
98913: LD_VAR 0 10
98917: ST_TO_ADDR
// end ;
98918: LD_VAR 0 7
98922: RET
// export function EnemyInRange ( unit , dist ) ; begin
98923: LD_INT 0
98925: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98926: LD_ADDR_VAR 0 3
98930: PUSH
98931: LD_VAR 0 1
98935: PPUSH
98936: CALL_OW 255
98940: PPUSH
98941: LD_VAR 0 1
98945: PPUSH
98946: CALL_OW 250
98950: PPUSH
98951: LD_VAR 0 1
98955: PPUSH
98956: CALL_OW 251
98960: PPUSH
98961: LD_VAR 0 2
98965: PPUSH
98966: CALL 73027 0 4
98970: PUSH
98971: LD_INT 4
98973: ARRAY
98974: ST_TO_ADDR
// end ;
98975: LD_VAR 0 3
98979: RET
// export function PlayerSeeMe ( unit ) ; begin
98980: LD_INT 0
98982: PPUSH
// result := See ( your_side , unit ) ;
98983: LD_ADDR_VAR 0 2
98987: PUSH
98988: LD_OWVAR 2
98992: PPUSH
98993: LD_VAR 0 1
98997: PPUSH
98998: CALL_OW 292
99002: ST_TO_ADDR
// end ;
99003: LD_VAR 0 2
99007: RET
// export function ReverseDir ( unit ) ; begin
99008: LD_INT 0
99010: PPUSH
// if not unit then
99011: LD_VAR 0 1
99015: NOT
99016: IFFALSE 99020
// exit ;
99018: GO 99043
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
99020: LD_ADDR_VAR 0 2
99024: PUSH
99025: LD_VAR 0 1
99029: PPUSH
99030: CALL_OW 254
99034: PUSH
99035: LD_INT 3
99037: PLUS
99038: PUSH
99039: LD_INT 6
99041: MOD
99042: ST_TO_ADDR
// end ;
99043: LD_VAR 0 2
99047: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
99048: LD_INT 0
99050: PPUSH
99051: PPUSH
99052: PPUSH
99053: PPUSH
99054: PPUSH
// if not hexes then
99055: LD_VAR 0 2
99059: NOT
99060: IFFALSE 99064
// exit ;
99062: GO 99212
// dist := 9999 ;
99064: LD_ADDR_VAR 0 5
99068: PUSH
99069: LD_INT 9999
99071: ST_TO_ADDR
// for i = 1 to hexes do
99072: LD_ADDR_VAR 0 4
99076: PUSH
99077: DOUBLE
99078: LD_INT 1
99080: DEC
99081: ST_TO_ADDR
99082: LD_VAR 0 2
99086: PUSH
99087: FOR_TO
99088: IFFALSE 99200
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
99090: LD_VAR 0 1
99094: PPUSH
99095: LD_VAR 0 2
99099: PUSH
99100: LD_VAR 0 4
99104: ARRAY
99105: PUSH
99106: LD_INT 1
99108: ARRAY
99109: PPUSH
99110: LD_VAR 0 2
99114: PUSH
99115: LD_VAR 0 4
99119: ARRAY
99120: PUSH
99121: LD_INT 2
99123: ARRAY
99124: PPUSH
99125: CALL_OW 297
99129: PUSH
99130: LD_VAR 0 5
99134: LESS
99135: IFFALSE 99198
// begin hex := hexes [ i ] ;
99137: LD_ADDR_VAR 0 7
99141: PUSH
99142: LD_VAR 0 2
99146: PUSH
99147: LD_VAR 0 4
99151: ARRAY
99152: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
99153: LD_ADDR_VAR 0 5
99157: PUSH
99158: LD_VAR 0 1
99162: PPUSH
99163: LD_VAR 0 2
99167: PUSH
99168: LD_VAR 0 4
99172: ARRAY
99173: PUSH
99174: LD_INT 1
99176: ARRAY
99177: PPUSH
99178: LD_VAR 0 2
99182: PUSH
99183: LD_VAR 0 4
99187: ARRAY
99188: PUSH
99189: LD_INT 2
99191: ARRAY
99192: PPUSH
99193: CALL_OW 297
99197: ST_TO_ADDR
// end ; end ;
99198: GO 99087
99200: POP
99201: POP
// result := hex ;
99202: LD_ADDR_VAR 0 3
99206: PUSH
99207: LD_VAR 0 7
99211: ST_TO_ADDR
// end ;
99212: LD_VAR 0 3
99216: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
99217: LD_INT 0
99219: PPUSH
99220: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
99221: LD_VAR 0 1
99225: NOT
99226: PUSH
99227: LD_VAR 0 1
99231: PUSH
99232: LD_INT 21
99234: PUSH
99235: LD_INT 2
99237: PUSH
99238: EMPTY
99239: LIST
99240: LIST
99241: PUSH
99242: LD_INT 23
99244: PUSH
99245: LD_INT 2
99247: PUSH
99248: EMPTY
99249: LIST
99250: LIST
99251: PUSH
99252: EMPTY
99253: LIST
99254: LIST
99255: PPUSH
99256: CALL_OW 69
99260: IN
99261: NOT
99262: OR
99263: IFFALSE 99267
// exit ;
99265: GO 99314
// for i = 1 to 3 do
99267: LD_ADDR_VAR 0 3
99271: PUSH
99272: DOUBLE
99273: LD_INT 1
99275: DEC
99276: ST_TO_ADDR
99277: LD_INT 3
99279: PUSH
99280: FOR_TO
99281: IFFALSE 99312
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
99283: LD_VAR 0 1
99287: PPUSH
99288: CALL_OW 250
99292: PPUSH
99293: LD_VAR 0 1
99297: PPUSH
99298: CALL_OW 251
99302: PPUSH
99303: LD_INT 1
99305: PPUSH
99306: CALL_OW 453
99310: GO 99280
99312: POP
99313: POP
// end ;
99314: LD_VAR 0 2
99318: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
99319: LD_INT 0
99321: PPUSH
99322: PPUSH
99323: PPUSH
99324: PPUSH
99325: PPUSH
99326: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
99327: LD_VAR 0 1
99331: NOT
99332: PUSH
99333: LD_VAR 0 2
99337: NOT
99338: OR
99339: PUSH
99340: LD_VAR 0 1
99344: PPUSH
99345: CALL_OW 314
99349: OR
99350: IFFALSE 99354
// exit ;
99352: GO 99795
// x := GetX ( enemy_unit ) ;
99354: LD_ADDR_VAR 0 7
99358: PUSH
99359: LD_VAR 0 2
99363: PPUSH
99364: CALL_OW 250
99368: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
99369: LD_ADDR_VAR 0 8
99373: PUSH
99374: LD_VAR 0 2
99378: PPUSH
99379: CALL_OW 251
99383: ST_TO_ADDR
// if not x or not y then
99384: LD_VAR 0 7
99388: NOT
99389: PUSH
99390: LD_VAR 0 8
99394: NOT
99395: OR
99396: IFFALSE 99400
// exit ;
99398: GO 99795
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
99400: LD_ADDR_VAR 0 6
99404: PUSH
99405: LD_VAR 0 7
99409: PPUSH
99410: LD_INT 0
99412: PPUSH
99413: LD_INT 4
99415: PPUSH
99416: CALL_OW 272
99420: PUSH
99421: LD_VAR 0 8
99425: PPUSH
99426: LD_INT 0
99428: PPUSH
99429: LD_INT 4
99431: PPUSH
99432: CALL_OW 273
99436: PUSH
99437: EMPTY
99438: LIST
99439: LIST
99440: PUSH
99441: LD_VAR 0 7
99445: PPUSH
99446: LD_INT 1
99448: PPUSH
99449: LD_INT 4
99451: PPUSH
99452: CALL_OW 272
99456: PUSH
99457: LD_VAR 0 8
99461: PPUSH
99462: LD_INT 1
99464: PPUSH
99465: LD_INT 4
99467: PPUSH
99468: CALL_OW 273
99472: PUSH
99473: EMPTY
99474: LIST
99475: LIST
99476: PUSH
99477: LD_VAR 0 7
99481: PPUSH
99482: LD_INT 2
99484: PPUSH
99485: LD_INT 4
99487: PPUSH
99488: CALL_OW 272
99492: PUSH
99493: LD_VAR 0 8
99497: PPUSH
99498: LD_INT 2
99500: PPUSH
99501: LD_INT 4
99503: PPUSH
99504: CALL_OW 273
99508: PUSH
99509: EMPTY
99510: LIST
99511: LIST
99512: PUSH
99513: LD_VAR 0 7
99517: PPUSH
99518: LD_INT 3
99520: PPUSH
99521: LD_INT 4
99523: PPUSH
99524: CALL_OW 272
99528: PUSH
99529: LD_VAR 0 8
99533: PPUSH
99534: LD_INT 3
99536: PPUSH
99537: LD_INT 4
99539: PPUSH
99540: CALL_OW 273
99544: PUSH
99545: EMPTY
99546: LIST
99547: LIST
99548: PUSH
99549: LD_VAR 0 7
99553: PPUSH
99554: LD_INT 4
99556: PPUSH
99557: LD_INT 4
99559: PPUSH
99560: CALL_OW 272
99564: PUSH
99565: LD_VAR 0 8
99569: PPUSH
99570: LD_INT 4
99572: PPUSH
99573: LD_INT 4
99575: PPUSH
99576: CALL_OW 273
99580: PUSH
99581: EMPTY
99582: LIST
99583: LIST
99584: PUSH
99585: LD_VAR 0 7
99589: PPUSH
99590: LD_INT 5
99592: PPUSH
99593: LD_INT 4
99595: PPUSH
99596: CALL_OW 272
99600: PUSH
99601: LD_VAR 0 8
99605: PPUSH
99606: LD_INT 5
99608: PPUSH
99609: LD_INT 4
99611: PPUSH
99612: CALL_OW 273
99616: PUSH
99617: EMPTY
99618: LIST
99619: LIST
99620: PUSH
99621: EMPTY
99622: LIST
99623: LIST
99624: LIST
99625: LIST
99626: LIST
99627: LIST
99628: ST_TO_ADDR
// for i = tmp downto 1 do
99629: LD_ADDR_VAR 0 4
99633: PUSH
99634: DOUBLE
99635: LD_VAR 0 6
99639: INC
99640: ST_TO_ADDR
99641: LD_INT 1
99643: PUSH
99644: FOR_DOWNTO
99645: IFFALSE 99746
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
99647: LD_VAR 0 6
99651: PUSH
99652: LD_VAR 0 4
99656: ARRAY
99657: PUSH
99658: LD_INT 1
99660: ARRAY
99661: PPUSH
99662: LD_VAR 0 6
99666: PUSH
99667: LD_VAR 0 4
99671: ARRAY
99672: PUSH
99673: LD_INT 2
99675: ARRAY
99676: PPUSH
99677: CALL_OW 488
99681: NOT
99682: PUSH
99683: LD_VAR 0 6
99687: PUSH
99688: LD_VAR 0 4
99692: ARRAY
99693: PUSH
99694: LD_INT 1
99696: ARRAY
99697: PPUSH
99698: LD_VAR 0 6
99702: PUSH
99703: LD_VAR 0 4
99707: ARRAY
99708: PUSH
99709: LD_INT 2
99711: ARRAY
99712: PPUSH
99713: CALL_OW 428
99717: PUSH
99718: LD_INT 0
99720: NONEQUAL
99721: OR
99722: IFFALSE 99744
// tmp := Delete ( tmp , i ) ;
99724: LD_ADDR_VAR 0 6
99728: PUSH
99729: LD_VAR 0 6
99733: PPUSH
99734: LD_VAR 0 4
99738: PPUSH
99739: CALL_OW 3
99743: ST_TO_ADDR
99744: GO 99644
99746: POP
99747: POP
// j := GetClosestHex ( unit , tmp ) ;
99748: LD_ADDR_VAR 0 5
99752: PUSH
99753: LD_VAR 0 1
99757: PPUSH
99758: LD_VAR 0 6
99762: PPUSH
99763: CALL 99048 0 2
99767: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
99768: LD_VAR 0 1
99772: PPUSH
99773: LD_VAR 0 5
99777: PUSH
99778: LD_INT 1
99780: ARRAY
99781: PPUSH
99782: LD_VAR 0 5
99786: PUSH
99787: LD_INT 2
99789: ARRAY
99790: PPUSH
99791: CALL_OW 111
// end ;
99795: LD_VAR 0 3
99799: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
99800: LD_INT 0
99802: PPUSH
99803: PPUSH
99804: PPUSH
// uc_side = 0 ;
99805: LD_ADDR_OWVAR 20
99809: PUSH
99810: LD_INT 0
99812: ST_TO_ADDR
// uc_nation = 0 ;
99813: LD_ADDR_OWVAR 21
99817: PUSH
99818: LD_INT 0
99820: ST_TO_ADDR
// InitHc ;
99821: CALL_OW 19
// InitVc ;
99825: CALL_OW 20
// if mastodonts then
99829: LD_VAR 0 6
99833: IFFALSE 99900
// for i = 1 to mastodonts do
99835: LD_ADDR_VAR 0 11
99839: PUSH
99840: DOUBLE
99841: LD_INT 1
99843: DEC
99844: ST_TO_ADDR
99845: LD_VAR 0 6
99849: PUSH
99850: FOR_TO
99851: IFFALSE 99898
// begin vc_chassis := 31 ;
99853: LD_ADDR_OWVAR 37
99857: PUSH
99858: LD_INT 31
99860: ST_TO_ADDR
// vc_control := control_rider ;
99861: LD_ADDR_OWVAR 38
99865: PUSH
99866: LD_INT 4
99868: ST_TO_ADDR
// animal := CreateVehicle ;
99869: LD_ADDR_VAR 0 12
99873: PUSH
99874: CALL_OW 45
99878: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99879: LD_VAR 0 12
99883: PPUSH
99884: LD_VAR 0 8
99888: PPUSH
99889: LD_INT 0
99891: PPUSH
99892: CALL 106678 0 3
// end ;
99896: GO 99850
99898: POP
99899: POP
// if horses then
99900: LD_VAR 0 5
99904: IFFALSE 99971
// for i = 1 to horses do
99906: LD_ADDR_VAR 0 11
99910: PUSH
99911: DOUBLE
99912: LD_INT 1
99914: DEC
99915: ST_TO_ADDR
99916: LD_VAR 0 5
99920: PUSH
99921: FOR_TO
99922: IFFALSE 99969
// begin hc_class := 21 ;
99924: LD_ADDR_OWVAR 28
99928: PUSH
99929: LD_INT 21
99931: ST_TO_ADDR
// hc_gallery :=  ;
99932: LD_ADDR_OWVAR 33
99936: PUSH
99937: LD_STRING 
99939: ST_TO_ADDR
// animal := CreateHuman ;
99940: LD_ADDR_VAR 0 12
99944: PUSH
99945: CALL_OW 44
99949: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99950: LD_VAR 0 12
99954: PPUSH
99955: LD_VAR 0 8
99959: PPUSH
99960: LD_INT 0
99962: PPUSH
99963: CALL 106678 0 3
// end ;
99967: GO 99921
99969: POP
99970: POP
// if birds then
99971: LD_VAR 0 1
99975: IFFALSE 100042
// for i = 1 to birds do
99977: LD_ADDR_VAR 0 11
99981: PUSH
99982: DOUBLE
99983: LD_INT 1
99985: DEC
99986: ST_TO_ADDR
99987: LD_VAR 0 1
99991: PUSH
99992: FOR_TO
99993: IFFALSE 100040
// begin hc_class = 18 ;
99995: LD_ADDR_OWVAR 28
99999: PUSH
100000: LD_INT 18
100002: ST_TO_ADDR
// hc_gallery =  ;
100003: LD_ADDR_OWVAR 33
100007: PUSH
100008: LD_STRING 
100010: ST_TO_ADDR
// animal := CreateHuman ;
100011: LD_ADDR_VAR 0 12
100015: PUSH
100016: CALL_OW 44
100020: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100021: LD_VAR 0 12
100025: PPUSH
100026: LD_VAR 0 8
100030: PPUSH
100031: LD_INT 0
100033: PPUSH
100034: CALL 106678 0 3
// end ;
100038: GO 99992
100040: POP
100041: POP
// if tigers then
100042: LD_VAR 0 2
100046: IFFALSE 100130
// for i = 1 to tigers do
100048: LD_ADDR_VAR 0 11
100052: PUSH
100053: DOUBLE
100054: LD_INT 1
100056: DEC
100057: ST_TO_ADDR
100058: LD_VAR 0 2
100062: PUSH
100063: FOR_TO
100064: IFFALSE 100128
// begin hc_class = class_tiger ;
100066: LD_ADDR_OWVAR 28
100070: PUSH
100071: LD_INT 14
100073: ST_TO_ADDR
// hc_gallery =  ;
100074: LD_ADDR_OWVAR 33
100078: PUSH
100079: LD_STRING 
100081: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
100082: LD_ADDR_OWVAR 35
100086: PUSH
100087: LD_INT 7
100089: NEG
100090: PPUSH
100091: LD_INT 7
100093: PPUSH
100094: CALL_OW 12
100098: ST_TO_ADDR
// animal := CreateHuman ;
100099: LD_ADDR_VAR 0 12
100103: PUSH
100104: CALL_OW 44
100108: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100109: LD_VAR 0 12
100113: PPUSH
100114: LD_VAR 0 8
100118: PPUSH
100119: LD_INT 0
100121: PPUSH
100122: CALL 106678 0 3
// end ;
100126: GO 100063
100128: POP
100129: POP
// if apemans then
100130: LD_VAR 0 3
100134: IFFALSE 100257
// for i = 1 to apemans do
100136: LD_ADDR_VAR 0 11
100140: PUSH
100141: DOUBLE
100142: LD_INT 1
100144: DEC
100145: ST_TO_ADDR
100146: LD_VAR 0 3
100150: PUSH
100151: FOR_TO
100152: IFFALSE 100255
// begin hc_class = class_apeman ;
100154: LD_ADDR_OWVAR 28
100158: PUSH
100159: LD_INT 12
100161: ST_TO_ADDR
// hc_gallery =  ;
100162: LD_ADDR_OWVAR 33
100166: PUSH
100167: LD_STRING 
100169: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
100170: LD_ADDR_OWVAR 35
100174: PUSH
100175: LD_INT 5
100177: NEG
100178: PPUSH
100179: LD_INT 5
100181: PPUSH
100182: CALL_OW 12
100186: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
100187: LD_ADDR_OWVAR 31
100191: PUSH
100192: LD_INT 1
100194: PPUSH
100195: LD_INT 3
100197: PPUSH
100198: CALL_OW 12
100202: PUSH
100203: LD_INT 1
100205: PPUSH
100206: LD_INT 3
100208: PPUSH
100209: CALL_OW 12
100213: PUSH
100214: LD_INT 0
100216: PUSH
100217: LD_INT 0
100219: PUSH
100220: EMPTY
100221: LIST
100222: LIST
100223: LIST
100224: LIST
100225: ST_TO_ADDR
// animal := CreateHuman ;
100226: LD_ADDR_VAR 0 12
100230: PUSH
100231: CALL_OW 44
100235: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100236: LD_VAR 0 12
100240: PPUSH
100241: LD_VAR 0 8
100245: PPUSH
100246: LD_INT 0
100248: PPUSH
100249: CALL 106678 0 3
// end ;
100253: GO 100151
100255: POP
100256: POP
// if enchidnas then
100257: LD_VAR 0 4
100261: IFFALSE 100328
// for i = 1 to enchidnas do
100263: LD_ADDR_VAR 0 11
100267: PUSH
100268: DOUBLE
100269: LD_INT 1
100271: DEC
100272: ST_TO_ADDR
100273: LD_VAR 0 4
100277: PUSH
100278: FOR_TO
100279: IFFALSE 100326
// begin hc_class = 13 ;
100281: LD_ADDR_OWVAR 28
100285: PUSH
100286: LD_INT 13
100288: ST_TO_ADDR
// hc_gallery =  ;
100289: LD_ADDR_OWVAR 33
100293: PUSH
100294: LD_STRING 
100296: ST_TO_ADDR
// animal := CreateHuman ;
100297: LD_ADDR_VAR 0 12
100301: PUSH
100302: CALL_OW 44
100306: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100307: LD_VAR 0 12
100311: PPUSH
100312: LD_VAR 0 8
100316: PPUSH
100317: LD_INT 0
100319: PPUSH
100320: CALL 106678 0 3
// end ;
100324: GO 100278
100326: POP
100327: POP
// if fishes then
100328: LD_VAR 0 7
100332: IFFALSE 100399
// for i = 1 to fishes do
100334: LD_ADDR_VAR 0 11
100338: PUSH
100339: DOUBLE
100340: LD_INT 1
100342: DEC
100343: ST_TO_ADDR
100344: LD_VAR 0 7
100348: PUSH
100349: FOR_TO
100350: IFFALSE 100397
// begin hc_class = 20 ;
100352: LD_ADDR_OWVAR 28
100356: PUSH
100357: LD_INT 20
100359: ST_TO_ADDR
// hc_gallery =  ;
100360: LD_ADDR_OWVAR 33
100364: PUSH
100365: LD_STRING 
100367: ST_TO_ADDR
// animal := CreateHuman ;
100368: LD_ADDR_VAR 0 12
100372: PUSH
100373: CALL_OW 44
100377: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
100378: LD_VAR 0 12
100382: PPUSH
100383: LD_VAR 0 9
100387: PPUSH
100388: LD_INT 0
100390: PPUSH
100391: CALL 106678 0 3
// end ;
100395: GO 100349
100397: POP
100398: POP
// end ;
100399: LD_VAR 0 10
100403: RET
// export function WantHeal ( sci , unit ) ; begin
100404: LD_INT 0
100406: PPUSH
// if GetTaskList ( sci ) > 0 then
100407: LD_VAR 0 1
100411: PPUSH
100412: CALL_OW 437
100416: PUSH
100417: LD_INT 0
100419: GREATER
100420: IFFALSE 100490
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
100422: LD_VAR 0 1
100426: PPUSH
100427: CALL_OW 437
100431: PUSH
100432: LD_INT 1
100434: ARRAY
100435: PUSH
100436: LD_INT 1
100438: ARRAY
100439: PUSH
100440: LD_STRING l
100442: EQUAL
100443: PUSH
100444: LD_VAR 0 1
100448: PPUSH
100449: CALL_OW 437
100453: PUSH
100454: LD_INT 1
100456: ARRAY
100457: PUSH
100458: LD_INT 4
100460: ARRAY
100461: PUSH
100462: LD_VAR 0 2
100466: EQUAL
100467: AND
100468: IFFALSE 100480
// result := true else
100470: LD_ADDR_VAR 0 3
100474: PUSH
100475: LD_INT 1
100477: ST_TO_ADDR
100478: GO 100488
// result := false ;
100480: LD_ADDR_VAR 0 3
100484: PUSH
100485: LD_INT 0
100487: ST_TO_ADDR
// end else
100488: GO 100498
// result := false ;
100490: LD_ADDR_VAR 0 3
100494: PUSH
100495: LD_INT 0
100497: ST_TO_ADDR
// end ;
100498: LD_VAR 0 3
100502: RET
// export function HealTarget ( sci ) ; begin
100503: LD_INT 0
100505: PPUSH
// if not sci then
100506: LD_VAR 0 1
100510: NOT
100511: IFFALSE 100515
// exit ;
100513: GO 100580
// result := 0 ;
100515: LD_ADDR_VAR 0 2
100519: PUSH
100520: LD_INT 0
100522: ST_TO_ADDR
// if GetTaskList ( sci ) then
100523: LD_VAR 0 1
100527: PPUSH
100528: CALL_OW 437
100532: IFFALSE 100580
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
100534: LD_VAR 0 1
100538: PPUSH
100539: CALL_OW 437
100543: PUSH
100544: LD_INT 1
100546: ARRAY
100547: PUSH
100548: LD_INT 1
100550: ARRAY
100551: PUSH
100552: LD_STRING l
100554: EQUAL
100555: IFFALSE 100580
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
100557: LD_ADDR_VAR 0 2
100561: PUSH
100562: LD_VAR 0 1
100566: PPUSH
100567: CALL_OW 437
100571: PUSH
100572: LD_INT 1
100574: ARRAY
100575: PUSH
100576: LD_INT 4
100578: ARRAY
100579: ST_TO_ADDR
// end ;
100580: LD_VAR 0 2
100584: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
100585: LD_INT 0
100587: PPUSH
100588: PPUSH
100589: PPUSH
100590: PPUSH
100591: PPUSH
100592: PPUSH
100593: PPUSH
100594: PPUSH
100595: PPUSH
100596: PPUSH
100597: PPUSH
100598: PPUSH
100599: PPUSH
100600: PPUSH
100601: PPUSH
100602: PPUSH
100603: PPUSH
100604: PPUSH
100605: PPUSH
100606: PPUSH
100607: PPUSH
100608: PPUSH
100609: PPUSH
100610: PPUSH
100611: PPUSH
100612: PPUSH
100613: PPUSH
100614: PPUSH
100615: PPUSH
100616: PPUSH
100617: PPUSH
100618: PPUSH
100619: PPUSH
100620: PPUSH
// if not list then
100621: LD_VAR 0 1
100625: NOT
100626: IFFALSE 100630
// exit ;
100628: GO 105289
// base := list [ 1 ] ;
100630: LD_ADDR_VAR 0 3
100634: PUSH
100635: LD_VAR 0 1
100639: PUSH
100640: LD_INT 1
100642: ARRAY
100643: ST_TO_ADDR
// group := list [ 2 ] ;
100644: LD_ADDR_VAR 0 4
100648: PUSH
100649: LD_VAR 0 1
100653: PUSH
100654: LD_INT 2
100656: ARRAY
100657: ST_TO_ADDR
// path := list [ 3 ] ;
100658: LD_ADDR_VAR 0 5
100662: PUSH
100663: LD_VAR 0 1
100667: PUSH
100668: LD_INT 3
100670: ARRAY
100671: ST_TO_ADDR
// flags := list [ 4 ] ;
100672: LD_ADDR_VAR 0 6
100676: PUSH
100677: LD_VAR 0 1
100681: PUSH
100682: LD_INT 4
100684: ARRAY
100685: ST_TO_ADDR
// mined := [ ] ;
100686: LD_ADDR_VAR 0 27
100690: PUSH
100691: EMPTY
100692: ST_TO_ADDR
// bombed := [ ] ;
100693: LD_ADDR_VAR 0 28
100697: PUSH
100698: EMPTY
100699: ST_TO_ADDR
// healers := [ ] ;
100700: LD_ADDR_VAR 0 31
100704: PUSH
100705: EMPTY
100706: ST_TO_ADDR
// to_heal := [ ] ;
100707: LD_ADDR_VAR 0 30
100711: PUSH
100712: EMPTY
100713: ST_TO_ADDR
// repairs := [ ] ;
100714: LD_ADDR_VAR 0 33
100718: PUSH
100719: EMPTY
100720: ST_TO_ADDR
// to_repair := [ ] ;
100721: LD_ADDR_VAR 0 32
100725: PUSH
100726: EMPTY
100727: ST_TO_ADDR
// if not group or not path then
100728: LD_VAR 0 4
100732: NOT
100733: PUSH
100734: LD_VAR 0 5
100738: NOT
100739: OR
100740: IFFALSE 100744
// exit ;
100742: GO 105289
// side := GetSide ( group [ 1 ] ) ;
100744: LD_ADDR_VAR 0 35
100748: PUSH
100749: LD_VAR 0 4
100753: PUSH
100754: LD_INT 1
100756: ARRAY
100757: PPUSH
100758: CALL_OW 255
100762: ST_TO_ADDR
// if flags then
100763: LD_VAR 0 6
100767: IFFALSE 100911
// begin f_ignore_area := flags [ 1 ] ;
100769: LD_ADDR_VAR 0 17
100773: PUSH
100774: LD_VAR 0 6
100778: PUSH
100779: LD_INT 1
100781: ARRAY
100782: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
100783: LD_ADDR_VAR 0 18
100787: PUSH
100788: LD_VAR 0 6
100792: PUSH
100793: LD_INT 2
100795: ARRAY
100796: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
100797: LD_ADDR_VAR 0 19
100801: PUSH
100802: LD_VAR 0 6
100806: PUSH
100807: LD_INT 3
100809: ARRAY
100810: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
100811: LD_ADDR_VAR 0 20
100815: PUSH
100816: LD_VAR 0 6
100820: PUSH
100821: LD_INT 4
100823: ARRAY
100824: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
100825: LD_ADDR_VAR 0 21
100829: PUSH
100830: LD_VAR 0 6
100834: PUSH
100835: LD_INT 5
100837: ARRAY
100838: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
100839: LD_ADDR_VAR 0 22
100843: PUSH
100844: LD_VAR 0 6
100848: PUSH
100849: LD_INT 6
100851: ARRAY
100852: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
100853: LD_ADDR_VAR 0 23
100857: PUSH
100858: LD_VAR 0 6
100862: PUSH
100863: LD_INT 7
100865: ARRAY
100866: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
100867: LD_ADDR_VAR 0 24
100871: PUSH
100872: LD_VAR 0 6
100876: PUSH
100877: LD_INT 8
100879: ARRAY
100880: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
100881: LD_ADDR_VAR 0 25
100885: PUSH
100886: LD_VAR 0 6
100890: PUSH
100891: LD_INT 9
100893: ARRAY
100894: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
100895: LD_ADDR_VAR 0 26
100899: PUSH
100900: LD_VAR 0 6
100904: PUSH
100905: LD_INT 10
100907: ARRAY
100908: ST_TO_ADDR
// end else
100909: GO 100991
// begin f_ignore_area := false ;
100911: LD_ADDR_VAR 0 17
100915: PUSH
100916: LD_INT 0
100918: ST_TO_ADDR
// f_capture := false ;
100919: LD_ADDR_VAR 0 18
100923: PUSH
100924: LD_INT 0
100926: ST_TO_ADDR
// f_ignore_civ := false ;
100927: LD_ADDR_VAR 0 19
100931: PUSH
100932: LD_INT 0
100934: ST_TO_ADDR
// f_murder := false ;
100935: LD_ADDR_VAR 0 20
100939: PUSH
100940: LD_INT 0
100942: ST_TO_ADDR
// f_mines := false ;
100943: LD_ADDR_VAR 0 21
100947: PUSH
100948: LD_INT 0
100950: ST_TO_ADDR
// f_repair := false ;
100951: LD_ADDR_VAR 0 22
100955: PUSH
100956: LD_INT 0
100958: ST_TO_ADDR
// f_heal := false ;
100959: LD_ADDR_VAR 0 23
100963: PUSH
100964: LD_INT 0
100966: ST_TO_ADDR
// f_spacetime := false ;
100967: LD_ADDR_VAR 0 24
100971: PUSH
100972: LD_INT 0
100974: ST_TO_ADDR
// f_attack_depot := false ;
100975: LD_ADDR_VAR 0 25
100979: PUSH
100980: LD_INT 0
100982: ST_TO_ADDR
// f_crawl := false ;
100983: LD_ADDR_VAR 0 26
100987: PUSH
100988: LD_INT 0
100990: ST_TO_ADDR
// end ; if f_heal then
100991: LD_VAR 0 23
100995: IFFALSE 101022
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
100997: LD_ADDR_VAR 0 31
101001: PUSH
101002: LD_VAR 0 4
101006: PPUSH
101007: LD_INT 25
101009: PUSH
101010: LD_INT 4
101012: PUSH
101013: EMPTY
101014: LIST
101015: LIST
101016: PPUSH
101017: CALL_OW 72
101021: ST_TO_ADDR
// if f_repair then
101022: LD_VAR 0 22
101026: IFFALSE 101053
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
101028: LD_ADDR_VAR 0 33
101032: PUSH
101033: LD_VAR 0 4
101037: PPUSH
101038: LD_INT 25
101040: PUSH
101041: LD_INT 3
101043: PUSH
101044: EMPTY
101045: LIST
101046: LIST
101047: PPUSH
101048: CALL_OW 72
101052: ST_TO_ADDR
// units_path := [ ] ;
101053: LD_ADDR_VAR 0 16
101057: PUSH
101058: EMPTY
101059: ST_TO_ADDR
// for i = 1 to group do
101060: LD_ADDR_VAR 0 7
101064: PUSH
101065: DOUBLE
101066: LD_INT 1
101068: DEC
101069: ST_TO_ADDR
101070: LD_VAR 0 4
101074: PUSH
101075: FOR_TO
101076: IFFALSE 101105
// units_path := Replace ( units_path , i , path ) ;
101078: LD_ADDR_VAR 0 16
101082: PUSH
101083: LD_VAR 0 16
101087: PPUSH
101088: LD_VAR 0 7
101092: PPUSH
101093: LD_VAR 0 5
101097: PPUSH
101098: CALL_OW 1
101102: ST_TO_ADDR
101103: GO 101075
101105: POP
101106: POP
// repeat for i = group downto 1 do
101107: LD_ADDR_VAR 0 7
101111: PUSH
101112: DOUBLE
101113: LD_VAR 0 4
101117: INC
101118: ST_TO_ADDR
101119: LD_INT 1
101121: PUSH
101122: FOR_DOWNTO
101123: IFFALSE 105245
// begin wait ( 5 ) ;
101125: LD_INT 5
101127: PPUSH
101128: CALL_OW 67
// tmp := [ ] ;
101132: LD_ADDR_VAR 0 14
101136: PUSH
101137: EMPTY
101138: ST_TO_ADDR
// attacking := false ;
101139: LD_ADDR_VAR 0 29
101143: PUSH
101144: LD_INT 0
101146: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
101147: LD_VAR 0 4
101151: PUSH
101152: LD_VAR 0 7
101156: ARRAY
101157: PPUSH
101158: CALL_OW 301
101162: PUSH
101163: LD_VAR 0 4
101167: PUSH
101168: LD_VAR 0 7
101172: ARRAY
101173: NOT
101174: OR
101175: IFFALSE 101284
// begin if GetType ( group [ i ] ) = unit_human then
101177: LD_VAR 0 4
101181: PUSH
101182: LD_VAR 0 7
101186: ARRAY
101187: PPUSH
101188: CALL_OW 247
101192: PUSH
101193: LD_INT 1
101195: EQUAL
101196: IFFALSE 101242
// begin to_heal := to_heal diff group [ i ] ;
101198: LD_ADDR_VAR 0 30
101202: PUSH
101203: LD_VAR 0 30
101207: PUSH
101208: LD_VAR 0 4
101212: PUSH
101213: LD_VAR 0 7
101217: ARRAY
101218: DIFF
101219: ST_TO_ADDR
// healers := healers diff group [ i ] ;
101220: LD_ADDR_VAR 0 31
101224: PUSH
101225: LD_VAR 0 31
101229: PUSH
101230: LD_VAR 0 4
101234: PUSH
101235: LD_VAR 0 7
101239: ARRAY
101240: DIFF
101241: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
101242: LD_ADDR_VAR 0 4
101246: PUSH
101247: LD_VAR 0 4
101251: PPUSH
101252: LD_VAR 0 7
101256: PPUSH
101257: CALL_OW 3
101261: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
101262: LD_ADDR_VAR 0 16
101266: PUSH
101267: LD_VAR 0 16
101271: PPUSH
101272: LD_VAR 0 7
101276: PPUSH
101277: CALL_OW 3
101281: ST_TO_ADDR
// continue ;
101282: GO 101122
// end ; if f_repair then
101284: LD_VAR 0 22
101288: IFFALSE 101777
// begin if GetType ( group [ i ] ) = unit_vehicle then
101290: LD_VAR 0 4
101294: PUSH
101295: LD_VAR 0 7
101299: ARRAY
101300: PPUSH
101301: CALL_OW 247
101305: PUSH
101306: LD_INT 2
101308: EQUAL
101309: IFFALSE 101499
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
101311: LD_VAR 0 4
101315: PUSH
101316: LD_VAR 0 7
101320: ARRAY
101321: PPUSH
101322: CALL_OW 256
101326: PUSH
101327: LD_INT 700
101329: LESS
101330: PUSH
101331: LD_VAR 0 4
101335: PUSH
101336: LD_VAR 0 7
101340: ARRAY
101341: PUSH
101342: LD_VAR 0 32
101346: IN
101347: NOT
101348: AND
101349: IFFALSE 101373
// to_repair := to_repair union group [ i ] ;
101351: LD_ADDR_VAR 0 32
101355: PUSH
101356: LD_VAR 0 32
101360: PUSH
101361: LD_VAR 0 4
101365: PUSH
101366: LD_VAR 0 7
101370: ARRAY
101371: UNION
101372: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
101373: LD_VAR 0 4
101377: PUSH
101378: LD_VAR 0 7
101382: ARRAY
101383: PPUSH
101384: CALL_OW 256
101388: PUSH
101389: LD_INT 1000
101391: EQUAL
101392: PUSH
101393: LD_VAR 0 4
101397: PUSH
101398: LD_VAR 0 7
101402: ARRAY
101403: PUSH
101404: LD_VAR 0 32
101408: IN
101409: AND
101410: IFFALSE 101434
// to_repair := to_repair diff group [ i ] ;
101412: LD_ADDR_VAR 0 32
101416: PUSH
101417: LD_VAR 0 32
101421: PUSH
101422: LD_VAR 0 4
101426: PUSH
101427: LD_VAR 0 7
101431: ARRAY
101432: DIFF
101433: ST_TO_ADDR
// if group [ i ] in to_repair then
101434: LD_VAR 0 4
101438: PUSH
101439: LD_VAR 0 7
101443: ARRAY
101444: PUSH
101445: LD_VAR 0 32
101449: IN
101450: IFFALSE 101497
// begin if not IsInArea ( group [ i ] , f_repair ) then
101452: LD_VAR 0 4
101456: PUSH
101457: LD_VAR 0 7
101461: ARRAY
101462: PPUSH
101463: LD_VAR 0 22
101467: PPUSH
101468: CALL_OW 308
101472: NOT
101473: IFFALSE 101495
// ComMoveToArea ( group [ i ] , f_repair ) ;
101475: LD_VAR 0 4
101479: PUSH
101480: LD_VAR 0 7
101484: ARRAY
101485: PPUSH
101486: LD_VAR 0 22
101490: PPUSH
101491: CALL_OW 113
// continue ;
101495: GO 101122
// end ; end else
101497: GO 101777
// if group [ i ] in repairs then
101499: LD_VAR 0 4
101503: PUSH
101504: LD_VAR 0 7
101508: ARRAY
101509: PUSH
101510: LD_VAR 0 33
101514: IN
101515: IFFALSE 101777
// begin if IsInUnit ( group [ i ] ) then
101517: LD_VAR 0 4
101521: PUSH
101522: LD_VAR 0 7
101526: ARRAY
101527: PPUSH
101528: CALL_OW 310
101532: IFFALSE 101600
// begin z := IsInUnit ( group [ i ] ) ;
101534: LD_ADDR_VAR 0 13
101538: PUSH
101539: LD_VAR 0 4
101543: PUSH
101544: LD_VAR 0 7
101548: ARRAY
101549: PPUSH
101550: CALL_OW 310
101554: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
101555: LD_VAR 0 13
101559: PUSH
101560: LD_VAR 0 32
101564: IN
101565: PUSH
101566: LD_VAR 0 13
101570: PPUSH
101571: LD_VAR 0 22
101575: PPUSH
101576: CALL_OW 308
101580: AND
101581: IFFALSE 101598
// ComExitVehicle ( group [ i ] ) ;
101583: LD_VAR 0 4
101587: PUSH
101588: LD_VAR 0 7
101592: ARRAY
101593: PPUSH
101594: CALL_OW 121
// end else
101598: GO 101777
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
101600: LD_ADDR_VAR 0 13
101604: PUSH
101605: LD_VAR 0 4
101609: PPUSH
101610: LD_INT 95
101612: PUSH
101613: LD_VAR 0 22
101617: PUSH
101618: EMPTY
101619: LIST
101620: LIST
101621: PUSH
101622: LD_INT 58
101624: PUSH
101625: EMPTY
101626: LIST
101627: PUSH
101628: EMPTY
101629: LIST
101630: LIST
101631: PPUSH
101632: CALL_OW 72
101636: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
101637: LD_VAR 0 4
101641: PUSH
101642: LD_VAR 0 7
101646: ARRAY
101647: PPUSH
101648: CALL_OW 314
101652: NOT
101653: IFFALSE 101775
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
101655: LD_ADDR_VAR 0 10
101659: PUSH
101660: LD_VAR 0 13
101664: PPUSH
101665: LD_VAR 0 4
101669: PUSH
101670: LD_VAR 0 7
101674: ARRAY
101675: PPUSH
101676: CALL_OW 74
101680: ST_TO_ADDR
// if not x then
101681: LD_VAR 0 10
101685: NOT
101686: IFFALSE 101690
// continue ;
101688: GO 101122
// if GetLives ( x ) < 1000 then
101690: LD_VAR 0 10
101694: PPUSH
101695: CALL_OW 256
101699: PUSH
101700: LD_INT 1000
101702: LESS
101703: IFFALSE 101727
// ComRepairVehicle ( group [ i ] , x ) else
101705: LD_VAR 0 4
101709: PUSH
101710: LD_VAR 0 7
101714: ARRAY
101715: PPUSH
101716: LD_VAR 0 10
101720: PPUSH
101721: CALL_OW 129
101725: GO 101775
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
101727: LD_VAR 0 23
101731: PUSH
101732: LD_VAR 0 4
101736: PUSH
101737: LD_VAR 0 7
101741: ARRAY
101742: PPUSH
101743: CALL_OW 256
101747: PUSH
101748: LD_INT 1000
101750: LESS
101751: AND
101752: NOT
101753: IFFALSE 101775
// ComEnterUnit ( group [ i ] , x ) ;
101755: LD_VAR 0 4
101759: PUSH
101760: LD_VAR 0 7
101764: ARRAY
101765: PPUSH
101766: LD_VAR 0 10
101770: PPUSH
101771: CALL_OW 120
// end ; continue ;
101775: GO 101122
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
101777: LD_VAR 0 23
101781: PUSH
101782: LD_VAR 0 4
101786: PUSH
101787: LD_VAR 0 7
101791: ARRAY
101792: PPUSH
101793: CALL_OW 247
101797: PUSH
101798: LD_INT 1
101800: EQUAL
101801: AND
101802: IFFALSE 102280
// begin if group [ i ] in healers then
101804: LD_VAR 0 4
101808: PUSH
101809: LD_VAR 0 7
101813: ARRAY
101814: PUSH
101815: LD_VAR 0 31
101819: IN
101820: IFFALSE 102093
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
101822: LD_VAR 0 4
101826: PUSH
101827: LD_VAR 0 7
101831: ARRAY
101832: PPUSH
101833: LD_VAR 0 23
101837: PPUSH
101838: CALL_OW 308
101842: NOT
101843: PUSH
101844: LD_VAR 0 4
101848: PUSH
101849: LD_VAR 0 7
101853: ARRAY
101854: PPUSH
101855: CALL_OW 314
101859: NOT
101860: AND
101861: IFFALSE 101885
// ComMoveToArea ( group [ i ] , f_heal ) else
101863: LD_VAR 0 4
101867: PUSH
101868: LD_VAR 0 7
101872: ARRAY
101873: PPUSH
101874: LD_VAR 0 23
101878: PPUSH
101879: CALL_OW 113
101883: GO 102091
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
101885: LD_VAR 0 4
101889: PUSH
101890: LD_VAR 0 7
101894: ARRAY
101895: PPUSH
101896: CALL 100503 0 1
101900: PPUSH
101901: CALL_OW 256
101905: PUSH
101906: LD_INT 1000
101908: EQUAL
101909: IFFALSE 101928
// ComStop ( group [ i ] ) else
101911: LD_VAR 0 4
101915: PUSH
101916: LD_VAR 0 7
101920: ARRAY
101921: PPUSH
101922: CALL_OW 141
101926: GO 102091
// if not HasTask ( group [ i ] ) and to_heal then
101928: LD_VAR 0 4
101932: PUSH
101933: LD_VAR 0 7
101937: ARRAY
101938: PPUSH
101939: CALL_OW 314
101943: NOT
101944: PUSH
101945: LD_VAR 0 30
101949: AND
101950: IFFALSE 102091
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
101952: LD_ADDR_VAR 0 13
101956: PUSH
101957: LD_VAR 0 30
101961: PPUSH
101962: LD_INT 3
101964: PUSH
101965: LD_INT 54
101967: PUSH
101968: EMPTY
101969: LIST
101970: PUSH
101971: EMPTY
101972: LIST
101973: LIST
101974: PPUSH
101975: CALL_OW 72
101979: PPUSH
101980: LD_VAR 0 4
101984: PUSH
101985: LD_VAR 0 7
101989: ARRAY
101990: PPUSH
101991: CALL_OW 74
101995: ST_TO_ADDR
// if z then
101996: LD_VAR 0 13
102000: IFFALSE 102091
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
102002: LD_INT 91
102004: PUSH
102005: LD_VAR 0 13
102009: PUSH
102010: LD_INT 10
102012: PUSH
102013: EMPTY
102014: LIST
102015: LIST
102016: LIST
102017: PUSH
102018: LD_INT 81
102020: PUSH
102021: LD_VAR 0 13
102025: PPUSH
102026: CALL_OW 255
102030: PUSH
102031: EMPTY
102032: LIST
102033: LIST
102034: PUSH
102035: EMPTY
102036: LIST
102037: LIST
102038: PPUSH
102039: CALL_OW 69
102043: PUSH
102044: LD_INT 0
102046: EQUAL
102047: IFFALSE 102071
// ComHeal ( group [ i ] , z ) else
102049: LD_VAR 0 4
102053: PUSH
102054: LD_VAR 0 7
102058: ARRAY
102059: PPUSH
102060: LD_VAR 0 13
102064: PPUSH
102065: CALL_OW 128
102069: GO 102091
// ComMoveToArea ( group [ i ] , f_heal ) ;
102071: LD_VAR 0 4
102075: PUSH
102076: LD_VAR 0 7
102080: ARRAY
102081: PPUSH
102082: LD_VAR 0 23
102086: PPUSH
102087: CALL_OW 113
// end ; continue ;
102091: GO 101122
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
102093: LD_VAR 0 4
102097: PUSH
102098: LD_VAR 0 7
102102: ARRAY
102103: PPUSH
102104: CALL_OW 256
102108: PUSH
102109: LD_INT 700
102111: LESS
102112: PUSH
102113: LD_VAR 0 4
102117: PUSH
102118: LD_VAR 0 7
102122: ARRAY
102123: PUSH
102124: LD_VAR 0 30
102128: IN
102129: NOT
102130: AND
102131: IFFALSE 102155
// to_heal := to_heal union group [ i ] ;
102133: LD_ADDR_VAR 0 30
102137: PUSH
102138: LD_VAR 0 30
102142: PUSH
102143: LD_VAR 0 4
102147: PUSH
102148: LD_VAR 0 7
102152: ARRAY
102153: UNION
102154: ST_TO_ADDR
// if group [ i ] in to_heal then
102155: LD_VAR 0 4
102159: PUSH
102160: LD_VAR 0 7
102164: ARRAY
102165: PUSH
102166: LD_VAR 0 30
102170: IN
102171: IFFALSE 102280
// begin if GetLives ( group [ i ] ) = 1000 then
102173: LD_VAR 0 4
102177: PUSH
102178: LD_VAR 0 7
102182: ARRAY
102183: PPUSH
102184: CALL_OW 256
102188: PUSH
102189: LD_INT 1000
102191: EQUAL
102192: IFFALSE 102218
// to_heal := to_heal diff group [ i ] else
102194: LD_ADDR_VAR 0 30
102198: PUSH
102199: LD_VAR 0 30
102203: PUSH
102204: LD_VAR 0 4
102208: PUSH
102209: LD_VAR 0 7
102213: ARRAY
102214: DIFF
102215: ST_TO_ADDR
102216: GO 102280
// begin if not IsInArea ( group [ i ] , to_heal ) then
102218: LD_VAR 0 4
102222: PUSH
102223: LD_VAR 0 7
102227: ARRAY
102228: PPUSH
102229: LD_VAR 0 30
102233: PPUSH
102234: CALL_OW 308
102238: NOT
102239: IFFALSE 102263
// ComMoveToArea ( group [ i ] , f_heal ) else
102241: LD_VAR 0 4
102245: PUSH
102246: LD_VAR 0 7
102250: ARRAY
102251: PPUSH
102252: LD_VAR 0 23
102256: PPUSH
102257: CALL_OW 113
102261: GO 102278
// ComHold ( group [ i ] ) ;
102263: LD_VAR 0 4
102267: PUSH
102268: LD_VAR 0 7
102272: ARRAY
102273: PPUSH
102274: CALL_OW 140
// continue ;
102278: GO 101122
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
102280: LD_VAR 0 4
102284: PUSH
102285: LD_VAR 0 7
102289: ARRAY
102290: PPUSH
102291: LD_INT 10
102293: PPUSH
102294: CALL 98923 0 2
102298: NOT
102299: PUSH
102300: LD_VAR 0 16
102304: PUSH
102305: LD_VAR 0 7
102309: ARRAY
102310: PUSH
102311: EMPTY
102312: EQUAL
102313: NOT
102314: AND
102315: IFFALSE 102581
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
102317: LD_VAR 0 4
102321: PUSH
102322: LD_VAR 0 7
102326: ARRAY
102327: PPUSH
102328: CALL_OW 262
102332: PUSH
102333: LD_INT 1
102335: PUSH
102336: LD_INT 2
102338: PUSH
102339: EMPTY
102340: LIST
102341: LIST
102342: IN
102343: IFFALSE 102384
// if GetFuel ( group [ i ] ) < 10 then
102345: LD_VAR 0 4
102349: PUSH
102350: LD_VAR 0 7
102354: ARRAY
102355: PPUSH
102356: CALL_OW 261
102360: PUSH
102361: LD_INT 10
102363: LESS
102364: IFFALSE 102384
// SetFuel ( group [ i ] , 12 ) ;
102366: LD_VAR 0 4
102370: PUSH
102371: LD_VAR 0 7
102375: ARRAY
102376: PPUSH
102377: LD_INT 12
102379: PPUSH
102380: CALL_OW 240
// if units_path [ i ] then
102384: LD_VAR 0 16
102388: PUSH
102389: LD_VAR 0 7
102393: ARRAY
102394: IFFALSE 102579
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
102396: LD_VAR 0 4
102400: PUSH
102401: LD_VAR 0 7
102405: ARRAY
102406: PPUSH
102407: LD_VAR 0 16
102411: PUSH
102412: LD_VAR 0 7
102416: ARRAY
102417: PUSH
102418: LD_INT 1
102420: ARRAY
102421: PUSH
102422: LD_INT 1
102424: ARRAY
102425: PPUSH
102426: LD_VAR 0 16
102430: PUSH
102431: LD_VAR 0 7
102435: ARRAY
102436: PUSH
102437: LD_INT 1
102439: ARRAY
102440: PUSH
102441: LD_INT 2
102443: ARRAY
102444: PPUSH
102445: CALL_OW 297
102449: PUSH
102450: LD_INT 6
102452: GREATER
102453: IFFALSE 102528
// begin if not HasTask ( group [ i ] ) then
102455: LD_VAR 0 4
102459: PUSH
102460: LD_VAR 0 7
102464: ARRAY
102465: PPUSH
102466: CALL_OW 314
102470: NOT
102471: IFFALSE 102526
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
102473: LD_VAR 0 4
102477: PUSH
102478: LD_VAR 0 7
102482: ARRAY
102483: PPUSH
102484: LD_VAR 0 16
102488: PUSH
102489: LD_VAR 0 7
102493: ARRAY
102494: PUSH
102495: LD_INT 1
102497: ARRAY
102498: PUSH
102499: LD_INT 1
102501: ARRAY
102502: PPUSH
102503: LD_VAR 0 16
102507: PUSH
102508: LD_VAR 0 7
102512: ARRAY
102513: PUSH
102514: LD_INT 1
102516: ARRAY
102517: PUSH
102518: LD_INT 2
102520: ARRAY
102521: PPUSH
102522: CALL_OW 114
// end else
102526: GO 102579
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
102528: LD_ADDR_VAR 0 15
102532: PUSH
102533: LD_VAR 0 16
102537: PUSH
102538: LD_VAR 0 7
102542: ARRAY
102543: PPUSH
102544: LD_INT 1
102546: PPUSH
102547: CALL_OW 3
102551: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
102552: LD_ADDR_VAR 0 16
102556: PUSH
102557: LD_VAR 0 16
102561: PPUSH
102562: LD_VAR 0 7
102566: PPUSH
102567: LD_VAR 0 15
102571: PPUSH
102572: CALL_OW 1
102576: ST_TO_ADDR
// continue ;
102577: GO 101122
// end ; end ; end else
102579: GO 105243
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
102581: LD_ADDR_VAR 0 14
102585: PUSH
102586: LD_INT 81
102588: PUSH
102589: LD_VAR 0 4
102593: PUSH
102594: LD_VAR 0 7
102598: ARRAY
102599: PPUSH
102600: CALL_OW 255
102604: PUSH
102605: EMPTY
102606: LIST
102607: LIST
102608: PPUSH
102609: CALL_OW 69
102613: ST_TO_ADDR
// if not tmp then
102614: LD_VAR 0 14
102618: NOT
102619: IFFALSE 102623
// continue ;
102621: GO 101122
// if f_ignore_area then
102623: LD_VAR 0 17
102627: IFFALSE 102715
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
102629: LD_ADDR_VAR 0 15
102633: PUSH
102634: LD_VAR 0 14
102638: PPUSH
102639: LD_INT 3
102641: PUSH
102642: LD_INT 92
102644: PUSH
102645: LD_VAR 0 17
102649: PUSH
102650: LD_INT 1
102652: ARRAY
102653: PUSH
102654: LD_VAR 0 17
102658: PUSH
102659: LD_INT 2
102661: ARRAY
102662: PUSH
102663: LD_VAR 0 17
102667: PUSH
102668: LD_INT 3
102670: ARRAY
102671: PUSH
102672: EMPTY
102673: LIST
102674: LIST
102675: LIST
102676: LIST
102677: PUSH
102678: EMPTY
102679: LIST
102680: LIST
102681: PPUSH
102682: CALL_OW 72
102686: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102687: LD_VAR 0 14
102691: PUSH
102692: LD_VAR 0 15
102696: DIFF
102697: IFFALSE 102715
// tmp := tmp diff tmp2 ;
102699: LD_ADDR_VAR 0 14
102703: PUSH
102704: LD_VAR 0 14
102708: PUSH
102709: LD_VAR 0 15
102713: DIFF
102714: ST_TO_ADDR
// end ; if not f_murder then
102715: LD_VAR 0 20
102719: NOT
102720: IFFALSE 102778
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
102722: LD_ADDR_VAR 0 15
102726: PUSH
102727: LD_VAR 0 14
102731: PPUSH
102732: LD_INT 3
102734: PUSH
102735: LD_INT 50
102737: PUSH
102738: EMPTY
102739: LIST
102740: PUSH
102741: EMPTY
102742: LIST
102743: LIST
102744: PPUSH
102745: CALL_OW 72
102749: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102750: LD_VAR 0 14
102754: PUSH
102755: LD_VAR 0 15
102759: DIFF
102760: IFFALSE 102778
// tmp := tmp diff tmp2 ;
102762: LD_ADDR_VAR 0 14
102766: PUSH
102767: LD_VAR 0 14
102771: PUSH
102772: LD_VAR 0 15
102776: DIFF
102777: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
102778: LD_ADDR_VAR 0 14
102782: PUSH
102783: LD_VAR 0 4
102787: PUSH
102788: LD_VAR 0 7
102792: ARRAY
102793: PPUSH
102794: LD_VAR 0 14
102798: PPUSH
102799: LD_INT 1
102801: PPUSH
102802: LD_INT 1
102804: PPUSH
102805: CALL 72566 0 4
102809: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
102810: LD_VAR 0 4
102814: PUSH
102815: LD_VAR 0 7
102819: ARRAY
102820: PPUSH
102821: CALL_OW 257
102825: PUSH
102826: LD_INT 1
102828: EQUAL
102829: IFFALSE 103277
// begin if WantPlant ( group [ i ] ) then
102831: LD_VAR 0 4
102835: PUSH
102836: LD_VAR 0 7
102840: ARRAY
102841: PPUSH
102842: CALL 72067 0 1
102846: IFFALSE 102850
// continue ;
102848: GO 101122
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
102850: LD_VAR 0 18
102854: PUSH
102855: LD_VAR 0 4
102859: PUSH
102860: LD_VAR 0 7
102864: ARRAY
102865: PPUSH
102866: CALL_OW 310
102870: NOT
102871: AND
102872: PUSH
102873: LD_VAR 0 14
102877: PUSH
102878: LD_INT 1
102880: ARRAY
102881: PUSH
102882: LD_VAR 0 14
102886: PPUSH
102887: LD_INT 21
102889: PUSH
102890: LD_INT 2
102892: PUSH
102893: EMPTY
102894: LIST
102895: LIST
102896: PUSH
102897: LD_INT 58
102899: PUSH
102900: EMPTY
102901: LIST
102902: PUSH
102903: EMPTY
102904: LIST
102905: LIST
102906: PPUSH
102907: CALL_OW 72
102911: IN
102912: AND
102913: IFFALSE 102949
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
102915: LD_VAR 0 4
102919: PUSH
102920: LD_VAR 0 7
102924: ARRAY
102925: PPUSH
102926: LD_VAR 0 14
102930: PUSH
102931: LD_INT 1
102933: ARRAY
102934: PPUSH
102935: CALL_OW 120
// attacking := true ;
102939: LD_ADDR_VAR 0 29
102943: PUSH
102944: LD_INT 1
102946: ST_TO_ADDR
// continue ;
102947: GO 101122
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
102949: LD_VAR 0 26
102953: PUSH
102954: LD_VAR 0 4
102958: PUSH
102959: LD_VAR 0 7
102963: ARRAY
102964: PPUSH
102965: CALL_OW 257
102969: PUSH
102970: LD_INT 1
102972: EQUAL
102973: AND
102974: PUSH
102975: LD_VAR 0 4
102979: PUSH
102980: LD_VAR 0 7
102984: ARRAY
102985: PPUSH
102986: CALL_OW 256
102990: PUSH
102991: LD_INT 800
102993: LESS
102994: AND
102995: PUSH
102996: LD_VAR 0 4
103000: PUSH
103001: LD_VAR 0 7
103005: ARRAY
103006: PPUSH
103007: CALL_OW 318
103011: NOT
103012: AND
103013: IFFALSE 103030
// ComCrawl ( group [ i ] ) ;
103015: LD_VAR 0 4
103019: PUSH
103020: LD_VAR 0 7
103024: ARRAY
103025: PPUSH
103026: CALL_OW 137
// if f_mines then
103030: LD_VAR 0 21
103034: IFFALSE 103277
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
103036: LD_VAR 0 14
103040: PUSH
103041: LD_INT 1
103043: ARRAY
103044: PPUSH
103045: CALL_OW 247
103049: PUSH
103050: LD_INT 3
103052: EQUAL
103053: PUSH
103054: LD_VAR 0 14
103058: PUSH
103059: LD_INT 1
103061: ARRAY
103062: PUSH
103063: LD_VAR 0 27
103067: IN
103068: NOT
103069: AND
103070: IFFALSE 103277
// begin x := GetX ( tmp [ 1 ] ) ;
103072: LD_ADDR_VAR 0 10
103076: PUSH
103077: LD_VAR 0 14
103081: PUSH
103082: LD_INT 1
103084: ARRAY
103085: PPUSH
103086: CALL_OW 250
103090: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
103091: LD_ADDR_VAR 0 11
103095: PUSH
103096: LD_VAR 0 14
103100: PUSH
103101: LD_INT 1
103103: ARRAY
103104: PPUSH
103105: CALL_OW 251
103109: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
103110: LD_ADDR_VAR 0 12
103114: PUSH
103115: LD_VAR 0 4
103119: PUSH
103120: LD_VAR 0 7
103124: ARRAY
103125: PPUSH
103126: CALL 99008 0 1
103130: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
103131: LD_VAR 0 4
103135: PUSH
103136: LD_VAR 0 7
103140: ARRAY
103141: PPUSH
103142: LD_VAR 0 10
103146: PPUSH
103147: LD_VAR 0 11
103151: PPUSH
103152: LD_VAR 0 14
103156: PUSH
103157: LD_INT 1
103159: ARRAY
103160: PPUSH
103161: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
103165: LD_VAR 0 4
103169: PUSH
103170: LD_VAR 0 7
103174: ARRAY
103175: PPUSH
103176: LD_VAR 0 10
103180: PPUSH
103181: LD_VAR 0 12
103185: PPUSH
103186: LD_INT 7
103188: PPUSH
103189: CALL_OW 272
103193: PPUSH
103194: LD_VAR 0 11
103198: PPUSH
103199: LD_VAR 0 12
103203: PPUSH
103204: LD_INT 7
103206: PPUSH
103207: CALL_OW 273
103211: PPUSH
103212: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
103216: LD_VAR 0 4
103220: PUSH
103221: LD_VAR 0 7
103225: ARRAY
103226: PPUSH
103227: LD_INT 71
103229: PPUSH
103230: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
103234: LD_ADDR_VAR 0 27
103238: PUSH
103239: LD_VAR 0 27
103243: PPUSH
103244: LD_VAR 0 27
103248: PUSH
103249: LD_INT 1
103251: PLUS
103252: PPUSH
103253: LD_VAR 0 14
103257: PUSH
103258: LD_INT 1
103260: ARRAY
103261: PPUSH
103262: CALL_OW 1
103266: ST_TO_ADDR
// attacking := true ;
103267: LD_ADDR_VAR 0 29
103271: PUSH
103272: LD_INT 1
103274: ST_TO_ADDR
// continue ;
103275: GO 101122
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
103277: LD_VAR 0 4
103281: PUSH
103282: LD_VAR 0 7
103286: ARRAY
103287: PPUSH
103288: CALL_OW 257
103292: PUSH
103293: LD_INT 17
103295: EQUAL
103296: PUSH
103297: LD_VAR 0 4
103301: PUSH
103302: LD_VAR 0 7
103306: ARRAY
103307: PPUSH
103308: CALL_OW 110
103312: PUSH
103313: LD_INT 71
103315: EQUAL
103316: NOT
103317: AND
103318: IFFALSE 103464
// begin attacking := false ;
103320: LD_ADDR_VAR 0 29
103324: PUSH
103325: LD_INT 0
103327: ST_TO_ADDR
// k := 5 ;
103328: LD_ADDR_VAR 0 9
103332: PUSH
103333: LD_INT 5
103335: ST_TO_ADDR
// if tmp < k then
103336: LD_VAR 0 14
103340: PUSH
103341: LD_VAR 0 9
103345: LESS
103346: IFFALSE 103358
// k := tmp ;
103348: LD_ADDR_VAR 0 9
103352: PUSH
103353: LD_VAR 0 14
103357: ST_TO_ADDR
// for j = 1 to k do
103358: LD_ADDR_VAR 0 8
103362: PUSH
103363: DOUBLE
103364: LD_INT 1
103366: DEC
103367: ST_TO_ADDR
103368: LD_VAR 0 9
103372: PUSH
103373: FOR_TO
103374: IFFALSE 103462
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
103376: LD_VAR 0 14
103380: PUSH
103381: LD_VAR 0 8
103385: ARRAY
103386: PUSH
103387: LD_VAR 0 14
103391: PPUSH
103392: LD_INT 58
103394: PUSH
103395: EMPTY
103396: LIST
103397: PPUSH
103398: CALL_OW 72
103402: IN
103403: NOT
103404: IFFALSE 103460
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103406: LD_VAR 0 4
103410: PUSH
103411: LD_VAR 0 7
103415: ARRAY
103416: PPUSH
103417: LD_VAR 0 14
103421: PUSH
103422: LD_VAR 0 8
103426: ARRAY
103427: PPUSH
103428: CALL_OW 115
// attacking := true ;
103432: LD_ADDR_VAR 0 29
103436: PUSH
103437: LD_INT 1
103439: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
103440: LD_VAR 0 4
103444: PUSH
103445: LD_VAR 0 7
103449: ARRAY
103450: PPUSH
103451: LD_INT 71
103453: PPUSH
103454: CALL_OW 109
// continue ;
103458: GO 103373
// end ; end ;
103460: GO 103373
103462: POP
103463: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
103464: LD_VAR 0 4
103468: PUSH
103469: LD_VAR 0 7
103473: ARRAY
103474: PPUSH
103475: CALL_OW 257
103479: PUSH
103480: LD_INT 8
103482: EQUAL
103483: PUSH
103484: LD_VAR 0 4
103488: PUSH
103489: LD_VAR 0 7
103493: ARRAY
103494: PPUSH
103495: CALL_OW 264
103499: PUSH
103500: LD_INT 28
103502: PUSH
103503: LD_INT 45
103505: PUSH
103506: LD_INT 7
103508: PUSH
103509: LD_INT 47
103511: PUSH
103512: EMPTY
103513: LIST
103514: LIST
103515: LIST
103516: LIST
103517: IN
103518: OR
103519: IFFALSE 103775
// begin attacking := false ;
103521: LD_ADDR_VAR 0 29
103525: PUSH
103526: LD_INT 0
103528: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
103529: LD_VAR 0 14
103533: PUSH
103534: LD_INT 1
103536: ARRAY
103537: PPUSH
103538: CALL_OW 266
103542: PUSH
103543: LD_INT 32
103545: PUSH
103546: LD_INT 31
103548: PUSH
103549: LD_INT 33
103551: PUSH
103552: LD_INT 4
103554: PUSH
103555: LD_INT 5
103557: PUSH
103558: EMPTY
103559: LIST
103560: LIST
103561: LIST
103562: LIST
103563: LIST
103564: IN
103565: IFFALSE 103751
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
103567: LD_ADDR_VAR 0 9
103571: PUSH
103572: LD_VAR 0 14
103576: PUSH
103577: LD_INT 1
103579: ARRAY
103580: PPUSH
103581: CALL_OW 266
103585: PPUSH
103586: LD_VAR 0 14
103590: PUSH
103591: LD_INT 1
103593: ARRAY
103594: PPUSH
103595: CALL_OW 250
103599: PPUSH
103600: LD_VAR 0 14
103604: PUSH
103605: LD_INT 1
103607: ARRAY
103608: PPUSH
103609: CALL_OW 251
103613: PPUSH
103614: LD_VAR 0 14
103618: PUSH
103619: LD_INT 1
103621: ARRAY
103622: PPUSH
103623: CALL_OW 254
103627: PPUSH
103628: LD_VAR 0 14
103632: PUSH
103633: LD_INT 1
103635: ARRAY
103636: PPUSH
103637: CALL_OW 248
103641: PPUSH
103642: LD_INT 0
103644: PPUSH
103645: CALL 80378 0 6
103649: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
103650: LD_ADDR_VAR 0 8
103654: PUSH
103655: LD_VAR 0 4
103659: PUSH
103660: LD_VAR 0 7
103664: ARRAY
103665: PPUSH
103666: LD_VAR 0 9
103670: PPUSH
103671: CALL 99048 0 2
103675: ST_TO_ADDR
// if j then
103676: LD_VAR 0 8
103680: IFFALSE 103749
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
103682: LD_VAR 0 8
103686: PUSH
103687: LD_INT 1
103689: ARRAY
103690: PPUSH
103691: LD_VAR 0 8
103695: PUSH
103696: LD_INT 2
103698: ARRAY
103699: PPUSH
103700: CALL_OW 488
103704: IFFALSE 103749
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
103706: LD_VAR 0 4
103710: PUSH
103711: LD_VAR 0 7
103715: ARRAY
103716: PPUSH
103717: LD_VAR 0 8
103721: PUSH
103722: LD_INT 1
103724: ARRAY
103725: PPUSH
103726: LD_VAR 0 8
103730: PUSH
103731: LD_INT 2
103733: ARRAY
103734: PPUSH
103735: CALL_OW 116
// attacking := true ;
103739: LD_ADDR_VAR 0 29
103743: PUSH
103744: LD_INT 1
103746: ST_TO_ADDR
// continue ;
103747: GO 101122
// end ; end else
103749: GO 103775
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103751: LD_VAR 0 4
103755: PUSH
103756: LD_VAR 0 7
103760: ARRAY
103761: PPUSH
103762: LD_VAR 0 14
103766: PUSH
103767: LD_INT 1
103769: ARRAY
103770: PPUSH
103771: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
103775: LD_VAR 0 4
103779: PUSH
103780: LD_VAR 0 7
103784: ARRAY
103785: PPUSH
103786: CALL_OW 265
103790: PUSH
103791: LD_INT 11
103793: EQUAL
103794: IFFALSE 104072
// begin k := 10 ;
103796: LD_ADDR_VAR 0 9
103800: PUSH
103801: LD_INT 10
103803: ST_TO_ADDR
// x := 0 ;
103804: LD_ADDR_VAR 0 10
103808: PUSH
103809: LD_INT 0
103811: ST_TO_ADDR
// if tmp < k then
103812: LD_VAR 0 14
103816: PUSH
103817: LD_VAR 0 9
103821: LESS
103822: IFFALSE 103834
// k := tmp ;
103824: LD_ADDR_VAR 0 9
103828: PUSH
103829: LD_VAR 0 14
103833: ST_TO_ADDR
// for j = k downto 1 do
103834: LD_ADDR_VAR 0 8
103838: PUSH
103839: DOUBLE
103840: LD_VAR 0 9
103844: INC
103845: ST_TO_ADDR
103846: LD_INT 1
103848: PUSH
103849: FOR_DOWNTO
103850: IFFALSE 103925
// begin if GetType ( tmp [ j ] ) = unit_human then
103852: LD_VAR 0 14
103856: PUSH
103857: LD_VAR 0 8
103861: ARRAY
103862: PPUSH
103863: CALL_OW 247
103867: PUSH
103868: LD_INT 1
103870: EQUAL
103871: IFFALSE 103923
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
103873: LD_VAR 0 4
103877: PUSH
103878: LD_VAR 0 7
103882: ARRAY
103883: PPUSH
103884: LD_VAR 0 14
103888: PUSH
103889: LD_VAR 0 8
103893: ARRAY
103894: PPUSH
103895: CALL 99319 0 2
// x := tmp [ j ] ;
103899: LD_ADDR_VAR 0 10
103903: PUSH
103904: LD_VAR 0 14
103908: PUSH
103909: LD_VAR 0 8
103913: ARRAY
103914: ST_TO_ADDR
// attacking := true ;
103915: LD_ADDR_VAR 0 29
103919: PUSH
103920: LD_INT 1
103922: ST_TO_ADDR
// end ; end ;
103923: GO 103849
103925: POP
103926: POP
// if not x then
103927: LD_VAR 0 10
103931: NOT
103932: IFFALSE 104072
// begin attacking := true ;
103934: LD_ADDR_VAR 0 29
103938: PUSH
103939: LD_INT 1
103941: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
103942: LD_VAR 0 4
103946: PUSH
103947: LD_VAR 0 7
103951: ARRAY
103952: PPUSH
103953: CALL_OW 250
103957: PPUSH
103958: LD_VAR 0 4
103962: PUSH
103963: LD_VAR 0 7
103967: ARRAY
103968: PPUSH
103969: CALL_OW 251
103973: PPUSH
103974: CALL_OW 546
103978: PUSH
103979: LD_INT 2
103981: ARRAY
103982: PUSH
103983: LD_VAR 0 14
103987: PUSH
103988: LD_INT 1
103990: ARRAY
103991: PPUSH
103992: CALL_OW 250
103996: PPUSH
103997: LD_VAR 0 14
104001: PUSH
104002: LD_INT 1
104004: ARRAY
104005: PPUSH
104006: CALL_OW 251
104010: PPUSH
104011: CALL_OW 546
104015: PUSH
104016: LD_INT 2
104018: ARRAY
104019: EQUAL
104020: IFFALSE 104048
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
104022: LD_VAR 0 4
104026: PUSH
104027: LD_VAR 0 7
104031: ARRAY
104032: PPUSH
104033: LD_VAR 0 14
104037: PUSH
104038: LD_INT 1
104040: ARRAY
104041: PPUSH
104042: CALL 99319 0 2
104046: GO 104072
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104048: LD_VAR 0 4
104052: PUSH
104053: LD_VAR 0 7
104057: ARRAY
104058: PPUSH
104059: LD_VAR 0 14
104063: PUSH
104064: LD_INT 1
104066: ARRAY
104067: PPUSH
104068: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
104072: LD_VAR 0 4
104076: PUSH
104077: LD_VAR 0 7
104081: ARRAY
104082: PPUSH
104083: CALL_OW 264
104087: PUSH
104088: LD_INT 29
104090: EQUAL
104091: IFFALSE 104457
// begin if WantsToAttack ( group [ i ] ) in bombed then
104093: LD_VAR 0 4
104097: PUSH
104098: LD_VAR 0 7
104102: ARRAY
104103: PPUSH
104104: CALL_OW 319
104108: PUSH
104109: LD_VAR 0 28
104113: IN
104114: IFFALSE 104118
// continue ;
104116: GO 101122
// k := 8 ;
104118: LD_ADDR_VAR 0 9
104122: PUSH
104123: LD_INT 8
104125: ST_TO_ADDR
// x := 0 ;
104126: LD_ADDR_VAR 0 10
104130: PUSH
104131: LD_INT 0
104133: ST_TO_ADDR
// if tmp < k then
104134: LD_VAR 0 14
104138: PUSH
104139: LD_VAR 0 9
104143: LESS
104144: IFFALSE 104156
// k := tmp ;
104146: LD_ADDR_VAR 0 9
104150: PUSH
104151: LD_VAR 0 14
104155: ST_TO_ADDR
// for j = 1 to k do
104156: LD_ADDR_VAR 0 8
104160: PUSH
104161: DOUBLE
104162: LD_INT 1
104164: DEC
104165: ST_TO_ADDR
104166: LD_VAR 0 9
104170: PUSH
104171: FOR_TO
104172: IFFALSE 104304
// begin if GetType ( tmp [ j ] ) = unit_building then
104174: LD_VAR 0 14
104178: PUSH
104179: LD_VAR 0 8
104183: ARRAY
104184: PPUSH
104185: CALL_OW 247
104189: PUSH
104190: LD_INT 3
104192: EQUAL
104193: IFFALSE 104302
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
104195: LD_VAR 0 14
104199: PUSH
104200: LD_VAR 0 8
104204: ARRAY
104205: PUSH
104206: LD_VAR 0 28
104210: IN
104211: NOT
104212: PUSH
104213: LD_VAR 0 14
104217: PUSH
104218: LD_VAR 0 8
104222: ARRAY
104223: PPUSH
104224: CALL_OW 313
104228: AND
104229: IFFALSE 104302
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104231: LD_VAR 0 4
104235: PUSH
104236: LD_VAR 0 7
104240: ARRAY
104241: PPUSH
104242: LD_VAR 0 14
104246: PUSH
104247: LD_VAR 0 8
104251: ARRAY
104252: PPUSH
104253: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
104257: LD_ADDR_VAR 0 28
104261: PUSH
104262: LD_VAR 0 28
104266: PPUSH
104267: LD_VAR 0 28
104271: PUSH
104272: LD_INT 1
104274: PLUS
104275: PPUSH
104276: LD_VAR 0 14
104280: PUSH
104281: LD_VAR 0 8
104285: ARRAY
104286: PPUSH
104287: CALL_OW 1
104291: ST_TO_ADDR
// attacking := true ;
104292: LD_ADDR_VAR 0 29
104296: PUSH
104297: LD_INT 1
104299: ST_TO_ADDR
// break ;
104300: GO 104304
// end ; end ;
104302: GO 104171
104304: POP
104305: POP
// if not attacking and f_attack_depot then
104306: LD_VAR 0 29
104310: NOT
104311: PUSH
104312: LD_VAR 0 25
104316: AND
104317: IFFALSE 104412
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
104319: LD_ADDR_VAR 0 13
104323: PUSH
104324: LD_VAR 0 14
104328: PPUSH
104329: LD_INT 2
104331: PUSH
104332: LD_INT 30
104334: PUSH
104335: LD_INT 0
104337: PUSH
104338: EMPTY
104339: LIST
104340: LIST
104341: PUSH
104342: LD_INT 30
104344: PUSH
104345: LD_INT 1
104347: PUSH
104348: EMPTY
104349: LIST
104350: LIST
104351: PUSH
104352: EMPTY
104353: LIST
104354: LIST
104355: LIST
104356: PPUSH
104357: CALL_OW 72
104361: ST_TO_ADDR
// if z then
104362: LD_VAR 0 13
104366: IFFALSE 104412
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
104368: LD_VAR 0 4
104372: PUSH
104373: LD_VAR 0 7
104377: ARRAY
104378: PPUSH
104379: LD_VAR 0 13
104383: PPUSH
104384: LD_VAR 0 4
104388: PUSH
104389: LD_VAR 0 7
104393: ARRAY
104394: PPUSH
104395: CALL_OW 74
104399: PPUSH
104400: CALL_OW 115
// attacking := true ;
104404: LD_ADDR_VAR 0 29
104408: PUSH
104409: LD_INT 1
104411: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
104412: LD_VAR 0 4
104416: PUSH
104417: LD_VAR 0 7
104421: ARRAY
104422: PPUSH
104423: CALL_OW 256
104427: PUSH
104428: LD_INT 500
104430: LESS
104431: IFFALSE 104457
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104433: LD_VAR 0 4
104437: PUSH
104438: LD_VAR 0 7
104442: ARRAY
104443: PPUSH
104444: LD_VAR 0 14
104448: PUSH
104449: LD_INT 1
104451: ARRAY
104452: PPUSH
104453: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
104457: LD_VAR 0 4
104461: PUSH
104462: LD_VAR 0 7
104466: ARRAY
104467: PPUSH
104468: CALL_OW 264
104472: PUSH
104473: LD_INT 49
104475: EQUAL
104476: IFFALSE 104597
// begin if not HasTask ( group [ i ] ) then
104478: LD_VAR 0 4
104482: PUSH
104483: LD_VAR 0 7
104487: ARRAY
104488: PPUSH
104489: CALL_OW 314
104493: NOT
104494: IFFALSE 104597
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
104496: LD_ADDR_VAR 0 9
104500: PUSH
104501: LD_INT 81
104503: PUSH
104504: LD_VAR 0 4
104508: PUSH
104509: LD_VAR 0 7
104513: ARRAY
104514: PPUSH
104515: CALL_OW 255
104519: PUSH
104520: EMPTY
104521: LIST
104522: LIST
104523: PPUSH
104524: CALL_OW 69
104528: PPUSH
104529: LD_VAR 0 4
104533: PUSH
104534: LD_VAR 0 7
104538: ARRAY
104539: PPUSH
104540: CALL_OW 74
104544: ST_TO_ADDR
// if k then
104545: LD_VAR 0 9
104549: IFFALSE 104597
// if GetDistUnits ( group [ i ] , k ) > 10 then
104551: LD_VAR 0 4
104555: PUSH
104556: LD_VAR 0 7
104560: ARRAY
104561: PPUSH
104562: LD_VAR 0 9
104566: PPUSH
104567: CALL_OW 296
104571: PUSH
104572: LD_INT 10
104574: GREATER
104575: IFFALSE 104597
// ComMoveUnit ( group [ i ] , k ) ;
104577: LD_VAR 0 4
104581: PUSH
104582: LD_VAR 0 7
104586: ARRAY
104587: PPUSH
104588: LD_VAR 0 9
104592: PPUSH
104593: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
104597: LD_VAR 0 4
104601: PUSH
104602: LD_VAR 0 7
104606: ARRAY
104607: PPUSH
104608: CALL_OW 256
104612: PUSH
104613: LD_INT 250
104615: LESS
104616: PUSH
104617: LD_VAR 0 4
104621: PUSH
104622: LD_VAR 0 7
104626: ARRAY
104627: PUSH
104628: LD_INT 21
104630: PUSH
104631: LD_INT 2
104633: PUSH
104634: EMPTY
104635: LIST
104636: LIST
104637: PUSH
104638: LD_INT 23
104640: PUSH
104641: LD_INT 2
104643: PUSH
104644: EMPTY
104645: LIST
104646: LIST
104647: PUSH
104648: EMPTY
104649: LIST
104650: LIST
104651: PPUSH
104652: CALL_OW 69
104656: IN
104657: AND
104658: IFFALSE 104783
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
104660: LD_ADDR_VAR 0 9
104664: PUSH
104665: LD_OWVAR 3
104669: PUSH
104670: LD_VAR 0 4
104674: PUSH
104675: LD_VAR 0 7
104679: ARRAY
104680: DIFF
104681: PPUSH
104682: LD_VAR 0 4
104686: PUSH
104687: LD_VAR 0 7
104691: ARRAY
104692: PPUSH
104693: CALL_OW 74
104697: ST_TO_ADDR
// if not k then
104698: LD_VAR 0 9
104702: NOT
104703: IFFALSE 104707
// continue ;
104705: GO 101122
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
104707: LD_VAR 0 9
104711: PUSH
104712: LD_INT 81
104714: PUSH
104715: LD_VAR 0 4
104719: PUSH
104720: LD_VAR 0 7
104724: ARRAY
104725: PPUSH
104726: CALL_OW 255
104730: PUSH
104731: EMPTY
104732: LIST
104733: LIST
104734: PPUSH
104735: CALL_OW 69
104739: IN
104740: PUSH
104741: LD_VAR 0 9
104745: PPUSH
104746: LD_VAR 0 4
104750: PUSH
104751: LD_VAR 0 7
104755: ARRAY
104756: PPUSH
104757: CALL_OW 296
104761: PUSH
104762: LD_INT 5
104764: LESS
104765: AND
104766: IFFALSE 104783
// ComAutodestruct ( group [ i ] ) ;
104768: LD_VAR 0 4
104772: PUSH
104773: LD_VAR 0 7
104777: ARRAY
104778: PPUSH
104779: CALL 99217 0 1
// end ; if f_attack_depot then
104783: LD_VAR 0 25
104787: IFFALSE 104899
// begin k := 6 ;
104789: LD_ADDR_VAR 0 9
104793: PUSH
104794: LD_INT 6
104796: ST_TO_ADDR
// if tmp < k then
104797: LD_VAR 0 14
104801: PUSH
104802: LD_VAR 0 9
104806: LESS
104807: IFFALSE 104819
// k := tmp ;
104809: LD_ADDR_VAR 0 9
104813: PUSH
104814: LD_VAR 0 14
104818: ST_TO_ADDR
// for j = 1 to k do
104819: LD_ADDR_VAR 0 8
104823: PUSH
104824: DOUBLE
104825: LD_INT 1
104827: DEC
104828: ST_TO_ADDR
104829: LD_VAR 0 9
104833: PUSH
104834: FOR_TO
104835: IFFALSE 104897
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
104837: LD_VAR 0 8
104841: PPUSH
104842: CALL_OW 266
104846: PUSH
104847: LD_INT 0
104849: PUSH
104850: LD_INT 1
104852: PUSH
104853: EMPTY
104854: LIST
104855: LIST
104856: IN
104857: IFFALSE 104895
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104859: LD_VAR 0 4
104863: PUSH
104864: LD_VAR 0 7
104868: ARRAY
104869: PPUSH
104870: LD_VAR 0 14
104874: PUSH
104875: LD_VAR 0 8
104879: ARRAY
104880: PPUSH
104881: CALL_OW 115
// attacking := true ;
104885: LD_ADDR_VAR 0 29
104889: PUSH
104890: LD_INT 1
104892: ST_TO_ADDR
// break ;
104893: GO 104897
// end ;
104895: GO 104834
104897: POP
104898: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
104899: LD_VAR 0 4
104903: PUSH
104904: LD_VAR 0 7
104908: ARRAY
104909: PPUSH
104910: CALL_OW 302
104914: PUSH
104915: LD_VAR 0 29
104919: NOT
104920: AND
104921: IFFALSE 105243
// begin if GetTag ( group [ i ] ) = 71 then
104923: LD_VAR 0 4
104927: PUSH
104928: LD_VAR 0 7
104932: ARRAY
104933: PPUSH
104934: CALL_OW 110
104938: PUSH
104939: LD_INT 71
104941: EQUAL
104942: IFFALSE 104983
// begin if HasTask ( group [ i ] ) then
104944: LD_VAR 0 4
104948: PUSH
104949: LD_VAR 0 7
104953: ARRAY
104954: PPUSH
104955: CALL_OW 314
104959: IFFALSE 104965
// continue else
104961: GO 101122
104963: GO 104983
// SetTag ( group [ i ] , 0 ) ;
104965: LD_VAR 0 4
104969: PUSH
104970: LD_VAR 0 7
104974: ARRAY
104975: PPUSH
104976: LD_INT 0
104978: PPUSH
104979: CALL_OW 109
// end ; k := 8 ;
104983: LD_ADDR_VAR 0 9
104987: PUSH
104988: LD_INT 8
104990: ST_TO_ADDR
// x := 0 ;
104991: LD_ADDR_VAR 0 10
104995: PUSH
104996: LD_INT 0
104998: ST_TO_ADDR
// if tmp < k then
104999: LD_VAR 0 14
105003: PUSH
105004: LD_VAR 0 9
105008: LESS
105009: IFFALSE 105021
// k := tmp ;
105011: LD_ADDR_VAR 0 9
105015: PUSH
105016: LD_VAR 0 14
105020: ST_TO_ADDR
// for j = 1 to k do
105021: LD_ADDR_VAR 0 8
105025: PUSH
105026: DOUBLE
105027: LD_INT 1
105029: DEC
105030: ST_TO_ADDR
105031: LD_VAR 0 9
105035: PUSH
105036: FOR_TO
105037: IFFALSE 105135
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
105039: LD_VAR 0 14
105043: PUSH
105044: LD_VAR 0 8
105048: ARRAY
105049: PPUSH
105050: CALL_OW 247
105054: PUSH
105055: LD_INT 1
105057: EQUAL
105058: PUSH
105059: LD_VAR 0 14
105063: PUSH
105064: LD_VAR 0 8
105068: ARRAY
105069: PPUSH
105070: CALL_OW 256
105074: PUSH
105075: LD_INT 250
105077: LESS
105078: PUSH
105079: LD_VAR 0 20
105083: AND
105084: PUSH
105085: LD_VAR 0 20
105089: NOT
105090: PUSH
105091: LD_VAR 0 14
105095: PUSH
105096: LD_VAR 0 8
105100: ARRAY
105101: PPUSH
105102: CALL_OW 256
105106: PUSH
105107: LD_INT 250
105109: GREATEREQUAL
105110: AND
105111: OR
105112: AND
105113: IFFALSE 105133
// begin x := tmp [ j ] ;
105115: LD_ADDR_VAR 0 10
105119: PUSH
105120: LD_VAR 0 14
105124: PUSH
105125: LD_VAR 0 8
105129: ARRAY
105130: ST_TO_ADDR
// break ;
105131: GO 105135
// end ;
105133: GO 105036
105135: POP
105136: POP
// if x then
105137: LD_VAR 0 10
105141: IFFALSE 105165
// ComAttackUnit ( group [ i ] , x ) else
105143: LD_VAR 0 4
105147: PUSH
105148: LD_VAR 0 7
105152: ARRAY
105153: PPUSH
105154: LD_VAR 0 10
105158: PPUSH
105159: CALL_OW 115
105163: GO 105189
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105165: LD_VAR 0 4
105169: PUSH
105170: LD_VAR 0 7
105174: ARRAY
105175: PPUSH
105176: LD_VAR 0 14
105180: PUSH
105181: LD_INT 1
105183: ARRAY
105184: PPUSH
105185: CALL_OW 115
// if not HasTask ( group [ i ] ) then
105189: LD_VAR 0 4
105193: PUSH
105194: LD_VAR 0 7
105198: ARRAY
105199: PPUSH
105200: CALL_OW 314
105204: NOT
105205: IFFALSE 105243
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
105207: LD_VAR 0 4
105211: PUSH
105212: LD_VAR 0 7
105216: ARRAY
105217: PPUSH
105218: LD_VAR 0 14
105222: PPUSH
105223: LD_VAR 0 4
105227: PUSH
105228: LD_VAR 0 7
105232: ARRAY
105233: PPUSH
105234: CALL_OW 74
105238: PPUSH
105239: CALL_OW 115
// end ; end ; end ;
105243: GO 101122
105245: POP
105246: POP
// wait ( 0 0$2 ) ;
105247: LD_INT 70
105249: PPUSH
105250: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
105254: LD_VAR 0 4
105258: NOT
105259: PUSH
105260: LD_VAR 0 4
105264: PUSH
105265: EMPTY
105266: EQUAL
105267: OR
105268: PUSH
105269: LD_INT 81
105271: PUSH
105272: LD_VAR 0 35
105276: PUSH
105277: EMPTY
105278: LIST
105279: LIST
105280: PPUSH
105281: CALL_OW 69
105285: NOT
105286: OR
105287: IFFALSE 101107
// end ;
105289: LD_VAR 0 2
105293: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
105294: LD_INT 0
105296: PPUSH
105297: PPUSH
105298: PPUSH
105299: PPUSH
// if not base_units then
105300: LD_VAR 0 1
105304: NOT
105305: IFFALSE 105309
// exit ;
105307: GO 105396
// result := false ;
105309: LD_ADDR_VAR 0 2
105313: PUSH
105314: LD_INT 0
105316: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
105317: LD_ADDR_VAR 0 5
105321: PUSH
105322: LD_VAR 0 1
105326: PPUSH
105327: LD_INT 21
105329: PUSH
105330: LD_INT 3
105332: PUSH
105333: EMPTY
105334: LIST
105335: LIST
105336: PPUSH
105337: CALL_OW 72
105341: ST_TO_ADDR
// if not tmp then
105342: LD_VAR 0 5
105346: NOT
105347: IFFALSE 105351
// exit ;
105349: GO 105396
// for i in tmp do
105351: LD_ADDR_VAR 0 3
105355: PUSH
105356: LD_VAR 0 5
105360: PUSH
105361: FOR_IN
105362: IFFALSE 105394
// begin result := EnemyInRange ( i , 22 ) ;
105364: LD_ADDR_VAR 0 2
105368: PUSH
105369: LD_VAR 0 3
105373: PPUSH
105374: LD_INT 22
105376: PPUSH
105377: CALL 98923 0 2
105381: ST_TO_ADDR
// if result then
105382: LD_VAR 0 2
105386: IFFALSE 105392
// exit ;
105388: POP
105389: POP
105390: GO 105396
// end ;
105392: GO 105361
105394: POP
105395: POP
// end ;
105396: LD_VAR 0 2
105400: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
105401: LD_INT 0
105403: PPUSH
105404: PPUSH
// if not units then
105405: LD_VAR 0 1
105409: NOT
105410: IFFALSE 105414
// exit ;
105412: GO 105484
// result := [ ] ;
105414: LD_ADDR_VAR 0 3
105418: PUSH
105419: EMPTY
105420: ST_TO_ADDR
// for i in units do
105421: LD_ADDR_VAR 0 4
105425: PUSH
105426: LD_VAR 0 1
105430: PUSH
105431: FOR_IN
105432: IFFALSE 105482
// if GetTag ( i ) = tag then
105434: LD_VAR 0 4
105438: PPUSH
105439: CALL_OW 110
105443: PUSH
105444: LD_VAR 0 2
105448: EQUAL
105449: IFFALSE 105480
// result := Insert ( result , result + 1 , i ) ;
105451: LD_ADDR_VAR 0 3
105455: PUSH
105456: LD_VAR 0 3
105460: PPUSH
105461: LD_VAR 0 3
105465: PUSH
105466: LD_INT 1
105468: PLUS
105469: PPUSH
105470: LD_VAR 0 4
105474: PPUSH
105475: CALL_OW 2
105479: ST_TO_ADDR
105480: GO 105431
105482: POP
105483: POP
// end ;
105484: LD_VAR 0 3
105488: RET
// export function IsDriver ( un ) ; begin
105489: LD_INT 0
105491: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
105492: LD_ADDR_VAR 0 2
105496: PUSH
105497: LD_VAR 0 1
105501: PUSH
105502: LD_INT 55
105504: PUSH
105505: EMPTY
105506: LIST
105507: PPUSH
105508: CALL_OW 69
105512: IN
105513: ST_TO_ADDR
// end ;
105514: LD_VAR 0 2
105518: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
105519: LD_INT 0
105521: PPUSH
105522: PPUSH
// list := [ ] ;
105523: LD_ADDR_VAR 0 5
105527: PUSH
105528: EMPTY
105529: ST_TO_ADDR
// case d of 0 :
105530: LD_VAR 0 3
105534: PUSH
105535: LD_INT 0
105537: DOUBLE
105538: EQUAL
105539: IFTRUE 105543
105541: GO 105676
105543: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
105544: LD_ADDR_VAR 0 5
105548: PUSH
105549: LD_VAR 0 1
105553: PUSH
105554: LD_INT 4
105556: MINUS
105557: PUSH
105558: LD_VAR 0 2
105562: PUSH
105563: LD_INT 4
105565: MINUS
105566: PUSH
105567: LD_INT 2
105569: PUSH
105570: EMPTY
105571: LIST
105572: LIST
105573: LIST
105574: PUSH
105575: LD_VAR 0 1
105579: PUSH
105580: LD_INT 3
105582: MINUS
105583: PUSH
105584: LD_VAR 0 2
105588: PUSH
105589: LD_INT 1
105591: PUSH
105592: EMPTY
105593: LIST
105594: LIST
105595: LIST
105596: PUSH
105597: LD_VAR 0 1
105601: PUSH
105602: LD_INT 4
105604: PLUS
105605: PUSH
105606: LD_VAR 0 2
105610: PUSH
105611: LD_INT 4
105613: PUSH
105614: EMPTY
105615: LIST
105616: LIST
105617: LIST
105618: PUSH
105619: LD_VAR 0 1
105623: PUSH
105624: LD_INT 3
105626: PLUS
105627: PUSH
105628: LD_VAR 0 2
105632: PUSH
105633: LD_INT 3
105635: PLUS
105636: PUSH
105637: LD_INT 5
105639: PUSH
105640: EMPTY
105641: LIST
105642: LIST
105643: LIST
105644: PUSH
105645: LD_VAR 0 1
105649: PUSH
105650: LD_VAR 0 2
105654: PUSH
105655: LD_INT 4
105657: PLUS
105658: PUSH
105659: LD_INT 0
105661: PUSH
105662: EMPTY
105663: LIST
105664: LIST
105665: LIST
105666: PUSH
105667: EMPTY
105668: LIST
105669: LIST
105670: LIST
105671: LIST
105672: LIST
105673: ST_TO_ADDR
// end ; 1 :
105674: GO 106374
105676: LD_INT 1
105678: DOUBLE
105679: EQUAL
105680: IFTRUE 105684
105682: GO 105817
105684: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
105685: LD_ADDR_VAR 0 5
105689: PUSH
105690: LD_VAR 0 1
105694: PUSH
105695: LD_VAR 0 2
105699: PUSH
105700: LD_INT 4
105702: MINUS
105703: PUSH
105704: LD_INT 3
105706: PUSH
105707: EMPTY
105708: LIST
105709: LIST
105710: LIST
105711: PUSH
105712: LD_VAR 0 1
105716: PUSH
105717: LD_INT 3
105719: MINUS
105720: PUSH
105721: LD_VAR 0 2
105725: PUSH
105726: LD_INT 3
105728: MINUS
105729: PUSH
105730: LD_INT 2
105732: PUSH
105733: EMPTY
105734: LIST
105735: LIST
105736: LIST
105737: PUSH
105738: LD_VAR 0 1
105742: PUSH
105743: LD_INT 4
105745: MINUS
105746: PUSH
105747: LD_VAR 0 2
105751: PUSH
105752: LD_INT 1
105754: PUSH
105755: EMPTY
105756: LIST
105757: LIST
105758: LIST
105759: PUSH
105760: LD_VAR 0 1
105764: PUSH
105765: LD_VAR 0 2
105769: PUSH
105770: LD_INT 3
105772: PLUS
105773: PUSH
105774: LD_INT 0
105776: PUSH
105777: EMPTY
105778: LIST
105779: LIST
105780: LIST
105781: PUSH
105782: LD_VAR 0 1
105786: PUSH
105787: LD_INT 4
105789: PLUS
105790: PUSH
105791: LD_VAR 0 2
105795: PUSH
105796: LD_INT 4
105798: PLUS
105799: PUSH
105800: LD_INT 5
105802: PUSH
105803: EMPTY
105804: LIST
105805: LIST
105806: LIST
105807: PUSH
105808: EMPTY
105809: LIST
105810: LIST
105811: LIST
105812: LIST
105813: LIST
105814: ST_TO_ADDR
// end ; 2 :
105815: GO 106374
105817: LD_INT 2
105819: DOUBLE
105820: EQUAL
105821: IFTRUE 105825
105823: GO 105954
105825: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
105826: LD_ADDR_VAR 0 5
105830: PUSH
105831: LD_VAR 0 1
105835: PUSH
105836: LD_VAR 0 2
105840: PUSH
105841: LD_INT 3
105843: MINUS
105844: PUSH
105845: LD_INT 3
105847: PUSH
105848: EMPTY
105849: LIST
105850: LIST
105851: LIST
105852: PUSH
105853: LD_VAR 0 1
105857: PUSH
105858: LD_INT 4
105860: PLUS
105861: PUSH
105862: LD_VAR 0 2
105866: PUSH
105867: LD_INT 4
105869: PUSH
105870: EMPTY
105871: LIST
105872: LIST
105873: LIST
105874: PUSH
105875: LD_VAR 0 1
105879: PUSH
105880: LD_VAR 0 2
105884: PUSH
105885: LD_INT 4
105887: PLUS
105888: PUSH
105889: LD_INT 0
105891: PUSH
105892: EMPTY
105893: LIST
105894: LIST
105895: LIST
105896: PUSH
105897: LD_VAR 0 1
105901: PUSH
105902: LD_INT 3
105904: MINUS
105905: PUSH
105906: LD_VAR 0 2
105910: PUSH
105911: LD_INT 1
105913: PUSH
105914: EMPTY
105915: LIST
105916: LIST
105917: LIST
105918: PUSH
105919: LD_VAR 0 1
105923: PUSH
105924: LD_INT 4
105926: MINUS
105927: PUSH
105928: LD_VAR 0 2
105932: PUSH
105933: LD_INT 4
105935: MINUS
105936: PUSH
105937: LD_INT 2
105939: PUSH
105940: EMPTY
105941: LIST
105942: LIST
105943: LIST
105944: PUSH
105945: EMPTY
105946: LIST
105947: LIST
105948: LIST
105949: LIST
105950: LIST
105951: ST_TO_ADDR
// end ; 3 :
105952: GO 106374
105954: LD_INT 3
105956: DOUBLE
105957: EQUAL
105958: IFTRUE 105962
105960: GO 106095
105962: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
105963: LD_ADDR_VAR 0 5
105967: PUSH
105968: LD_VAR 0 1
105972: PUSH
105973: LD_INT 3
105975: PLUS
105976: PUSH
105977: LD_VAR 0 2
105981: PUSH
105982: LD_INT 4
105984: PUSH
105985: EMPTY
105986: LIST
105987: LIST
105988: LIST
105989: PUSH
105990: LD_VAR 0 1
105994: PUSH
105995: LD_INT 4
105997: PLUS
105998: PUSH
105999: LD_VAR 0 2
106003: PUSH
106004: LD_INT 4
106006: PLUS
106007: PUSH
106008: LD_INT 5
106010: PUSH
106011: EMPTY
106012: LIST
106013: LIST
106014: LIST
106015: PUSH
106016: LD_VAR 0 1
106020: PUSH
106021: LD_INT 4
106023: MINUS
106024: PUSH
106025: LD_VAR 0 2
106029: PUSH
106030: LD_INT 1
106032: PUSH
106033: EMPTY
106034: LIST
106035: LIST
106036: LIST
106037: PUSH
106038: LD_VAR 0 1
106042: PUSH
106043: LD_VAR 0 2
106047: PUSH
106048: LD_INT 4
106050: MINUS
106051: PUSH
106052: LD_INT 3
106054: PUSH
106055: EMPTY
106056: LIST
106057: LIST
106058: LIST
106059: PUSH
106060: LD_VAR 0 1
106064: PUSH
106065: LD_INT 3
106067: MINUS
106068: PUSH
106069: LD_VAR 0 2
106073: PUSH
106074: LD_INT 3
106076: MINUS
106077: PUSH
106078: LD_INT 2
106080: PUSH
106081: EMPTY
106082: LIST
106083: LIST
106084: LIST
106085: PUSH
106086: EMPTY
106087: LIST
106088: LIST
106089: LIST
106090: LIST
106091: LIST
106092: ST_TO_ADDR
// end ; 4 :
106093: GO 106374
106095: LD_INT 4
106097: DOUBLE
106098: EQUAL
106099: IFTRUE 106103
106101: GO 106236
106103: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
106104: LD_ADDR_VAR 0 5
106108: PUSH
106109: LD_VAR 0 1
106113: PUSH
106114: LD_VAR 0 2
106118: PUSH
106119: LD_INT 4
106121: PLUS
106122: PUSH
106123: LD_INT 0
106125: PUSH
106126: EMPTY
106127: LIST
106128: LIST
106129: LIST
106130: PUSH
106131: LD_VAR 0 1
106135: PUSH
106136: LD_INT 3
106138: PLUS
106139: PUSH
106140: LD_VAR 0 2
106144: PUSH
106145: LD_INT 3
106147: PLUS
106148: PUSH
106149: LD_INT 5
106151: PUSH
106152: EMPTY
106153: LIST
106154: LIST
106155: LIST
106156: PUSH
106157: LD_VAR 0 1
106161: PUSH
106162: LD_INT 4
106164: PLUS
106165: PUSH
106166: LD_VAR 0 2
106170: PUSH
106171: LD_INT 4
106173: PUSH
106174: EMPTY
106175: LIST
106176: LIST
106177: LIST
106178: PUSH
106179: LD_VAR 0 1
106183: PUSH
106184: LD_VAR 0 2
106188: PUSH
106189: LD_INT 3
106191: MINUS
106192: PUSH
106193: LD_INT 3
106195: PUSH
106196: EMPTY
106197: LIST
106198: LIST
106199: LIST
106200: PUSH
106201: LD_VAR 0 1
106205: PUSH
106206: LD_INT 4
106208: MINUS
106209: PUSH
106210: LD_VAR 0 2
106214: PUSH
106215: LD_INT 4
106217: MINUS
106218: PUSH
106219: LD_INT 2
106221: PUSH
106222: EMPTY
106223: LIST
106224: LIST
106225: LIST
106226: PUSH
106227: EMPTY
106228: LIST
106229: LIST
106230: LIST
106231: LIST
106232: LIST
106233: ST_TO_ADDR
// end ; 5 :
106234: GO 106374
106236: LD_INT 5
106238: DOUBLE
106239: EQUAL
106240: IFTRUE 106244
106242: GO 106373
106244: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
106245: LD_ADDR_VAR 0 5
106249: PUSH
106250: LD_VAR 0 1
106254: PUSH
106255: LD_INT 4
106257: MINUS
106258: PUSH
106259: LD_VAR 0 2
106263: PUSH
106264: LD_INT 1
106266: PUSH
106267: EMPTY
106268: LIST
106269: LIST
106270: LIST
106271: PUSH
106272: LD_VAR 0 1
106276: PUSH
106277: LD_VAR 0 2
106281: PUSH
106282: LD_INT 4
106284: MINUS
106285: PUSH
106286: LD_INT 3
106288: PUSH
106289: EMPTY
106290: LIST
106291: LIST
106292: LIST
106293: PUSH
106294: LD_VAR 0 1
106298: PUSH
106299: LD_INT 4
106301: PLUS
106302: PUSH
106303: LD_VAR 0 2
106307: PUSH
106308: LD_INT 4
106310: PLUS
106311: PUSH
106312: LD_INT 5
106314: PUSH
106315: EMPTY
106316: LIST
106317: LIST
106318: LIST
106319: PUSH
106320: LD_VAR 0 1
106324: PUSH
106325: LD_INT 3
106327: PLUS
106328: PUSH
106329: LD_VAR 0 2
106333: PUSH
106334: LD_INT 4
106336: PUSH
106337: EMPTY
106338: LIST
106339: LIST
106340: LIST
106341: PUSH
106342: LD_VAR 0 1
106346: PUSH
106347: LD_VAR 0 2
106351: PUSH
106352: LD_INT 3
106354: PLUS
106355: PUSH
106356: LD_INT 0
106358: PUSH
106359: EMPTY
106360: LIST
106361: LIST
106362: LIST
106363: PUSH
106364: EMPTY
106365: LIST
106366: LIST
106367: LIST
106368: LIST
106369: LIST
106370: ST_TO_ADDR
// end ; end ;
106371: GO 106374
106373: POP
// result := list ;
106374: LD_ADDR_VAR 0 4
106378: PUSH
106379: LD_VAR 0 5
106383: ST_TO_ADDR
// end ;
106384: LD_VAR 0 4
106388: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
106389: LD_INT 0
106391: PPUSH
106392: PPUSH
106393: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
106394: LD_VAR 0 1
106398: NOT
106399: PUSH
106400: LD_VAR 0 2
106404: PUSH
106405: LD_INT 1
106407: PUSH
106408: LD_INT 2
106410: PUSH
106411: LD_INT 3
106413: PUSH
106414: LD_INT 4
106416: PUSH
106417: EMPTY
106418: LIST
106419: LIST
106420: LIST
106421: LIST
106422: IN
106423: NOT
106424: OR
106425: IFFALSE 106429
// exit ;
106427: GO 106521
// tmp := [ ] ;
106429: LD_ADDR_VAR 0 5
106433: PUSH
106434: EMPTY
106435: ST_TO_ADDR
// for i in units do
106436: LD_ADDR_VAR 0 4
106440: PUSH
106441: LD_VAR 0 1
106445: PUSH
106446: FOR_IN
106447: IFFALSE 106490
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
106449: LD_ADDR_VAR 0 5
106453: PUSH
106454: LD_VAR 0 5
106458: PPUSH
106459: LD_VAR 0 5
106463: PUSH
106464: LD_INT 1
106466: PLUS
106467: PPUSH
106468: LD_VAR 0 4
106472: PPUSH
106473: LD_VAR 0 2
106477: PPUSH
106478: CALL_OW 259
106482: PPUSH
106483: CALL_OW 2
106487: ST_TO_ADDR
106488: GO 106446
106490: POP
106491: POP
// if not tmp then
106492: LD_VAR 0 5
106496: NOT
106497: IFFALSE 106501
// exit ;
106499: GO 106521
// result := SortListByListDesc ( units , tmp ) ;
106501: LD_ADDR_VAR 0 3
106505: PUSH
106506: LD_VAR 0 1
106510: PPUSH
106511: LD_VAR 0 5
106515: PPUSH
106516: CALL_OW 77
106520: ST_TO_ADDR
// end ;
106521: LD_VAR 0 3
106525: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
106526: LD_INT 0
106528: PPUSH
106529: PPUSH
106530: PPUSH
// x := GetX ( building ) ;
106531: LD_ADDR_VAR 0 4
106535: PUSH
106536: LD_VAR 0 2
106540: PPUSH
106541: CALL_OW 250
106545: ST_TO_ADDR
// y := GetY ( building ) ;
106546: LD_ADDR_VAR 0 5
106550: PUSH
106551: LD_VAR 0 2
106555: PPUSH
106556: CALL_OW 251
106560: ST_TO_ADDR
// if GetTaskList ( unit ) then
106561: LD_VAR 0 1
106565: PPUSH
106566: CALL_OW 437
106570: IFFALSE 106665
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106572: LD_STRING e
106574: PUSH
106575: LD_VAR 0 1
106579: PPUSH
106580: CALL_OW 437
106584: PUSH
106585: LD_INT 1
106587: ARRAY
106588: PUSH
106589: LD_INT 1
106591: ARRAY
106592: EQUAL
106593: PUSH
106594: LD_VAR 0 4
106598: PUSH
106599: LD_VAR 0 1
106603: PPUSH
106604: CALL_OW 437
106608: PUSH
106609: LD_INT 1
106611: ARRAY
106612: PUSH
106613: LD_INT 2
106615: ARRAY
106616: EQUAL
106617: AND
106618: PUSH
106619: LD_VAR 0 5
106623: PUSH
106624: LD_VAR 0 1
106628: PPUSH
106629: CALL_OW 437
106633: PUSH
106634: LD_INT 1
106636: ARRAY
106637: PUSH
106638: LD_INT 3
106640: ARRAY
106641: EQUAL
106642: AND
106643: IFFALSE 106655
// result := true else
106645: LD_ADDR_VAR 0 3
106649: PUSH
106650: LD_INT 1
106652: ST_TO_ADDR
106653: GO 106663
// result := false ;
106655: LD_ADDR_VAR 0 3
106659: PUSH
106660: LD_INT 0
106662: ST_TO_ADDR
// end else
106663: GO 106673
// result := false ;
106665: LD_ADDR_VAR 0 3
106669: PUSH
106670: LD_INT 0
106672: ST_TO_ADDR
// end ;
106673: LD_VAR 0 3
106677: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
106678: LD_INT 0
106680: PPUSH
106681: PPUSH
106682: PPUSH
106683: PPUSH
// if not unit or not area then
106684: LD_VAR 0 1
106688: NOT
106689: PUSH
106690: LD_VAR 0 2
106694: NOT
106695: OR
106696: IFFALSE 106700
// exit ;
106698: GO 106864
// tmp := AreaToList ( area , i ) ;
106700: LD_ADDR_VAR 0 6
106704: PUSH
106705: LD_VAR 0 2
106709: PPUSH
106710: LD_VAR 0 5
106714: PPUSH
106715: CALL_OW 517
106719: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
106720: LD_ADDR_VAR 0 5
106724: PUSH
106725: DOUBLE
106726: LD_INT 1
106728: DEC
106729: ST_TO_ADDR
106730: LD_VAR 0 6
106734: PUSH
106735: LD_INT 1
106737: ARRAY
106738: PUSH
106739: FOR_TO
106740: IFFALSE 106862
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
106742: LD_ADDR_VAR 0 7
106746: PUSH
106747: LD_VAR 0 6
106751: PUSH
106752: LD_INT 1
106754: ARRAY
106755: PUSH
106756: LD_VAR 0 5
106760: ARRAY
106761: PUSH
106762: LD_VAR 0 6
106766: PUSH
106767: LD_INT 2
106769: ARRAY
106770: PUSH
106771: LD_VAR 0 5
106775: ARRAY
106776: PUSH
106777: EMPTY
106778: LIST
106779: LIST
106780: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
106781: LD_VAR 0 7
106785: PUSH
106786: LD_INT 1
106788: ARRAY
106789: PPUSH
106790: LD_VAR 0 7
106794: PUSH
106795: LD_INT 2
106797: ARRAY
106798: PPUSH
106799: CALL_OW 428
106803: PUSH
106804: LD_INT 0
106806: EQUAL
106807: IFFALSE 106860
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
106809: LD_VAR 0 1
106813: PPUSH
106814: LD_VAR 0 7
106818: PUSH
106819: LD_INT 1
106821: ARRAY
106822: PPUSH
106823: LD_VAR 0 7
106827: PUSH
106828: LD_INT 2
106830: ARRAY
106831: PPUSH
106832: LD_VAR 0 3
106836: PPUSH
106837: CALL_OW 48
// result := IsPlaced ( unit ) ;
106841: LD_ADDR_VAR 0 4
106845: PUSH
106846: LD_VAR 0 1
106850: PPUSH
106851: CALL_OW 305
106855: ST_TO_ADDR
// exit ;
106856: POP
106857: POP
106858: GO 106864
// end ; end ;
106860: GO 106739
106862: POP
106863: POP
// end ;
106864: LD_VAR 0 4
106868: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
106869: LD_INT 0
106871: PPUSH
106872: PPUSH
106873: PPUSH
// if not side or side > 8 then
106874: LD_VAR 0 1
106878: NOT
106879: PUSH
106880: LD_VAR 0 1
106884: PUSH
106885: LD_INT 8
106887: GREATER
106888: OR
106889: IFFALSE 106893
// exit ;
106891: GO 107080
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
106893: LD_ADDR_VAR 0 4
106897: PUSH
106898: LD_INT 22
106900: PUSH
106901: LD_VAR 0 1
106905: PUSH
106906: EMPTY
106907: LIST
106908: LIST
106909: PUSH
106910: LD_INT 21
106912: PUSH
106913: LD_INT 3
106915: PUSH
106916: EMPTY
106917: LIST
106918: LIST
106919: PUSH
106920: EMPTY
106921: LIST
106922: LIST
106923: PPUSH
106924: CALL_OW 69
106928: ST_TO_ADDR
// if not tmp then
106929: LD_VAR 0 4
106933: NOT
106934: IFFALSE 106938
// exit ;
106936: GO 107080
// enable_addtolog := true ;
106938: LD_ADDR_OWVAR 81
106942: PUSH
106943: LD_INT 1
106945: ST_TO_ADDR
// AddToLog ( [ ) ;
106946: LD_STRING [
106948: PPUSH
106949: CALL_OW 561
// for i in tmp do
106953: LD_ADDR_VAR 0 3
106957: PUSH
106958: LD_VAR 0 4
106962: PUSH
106963: FOR_IN
106964: IFFALSE 107071
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
106966: LD_STRING [
106968: PUSH
106969: LD_VAR 0 3
106973: PPUSH
106974: CALL_OW 266
106978: STR
106979: PUSH
106980: LD_STRING , 
106982: STR
106983: PUSH
106984: LD_VAR 0 3
106988: PPUSH
106989: CALL_OW 250
106993: STR
106994: PUSH
106995: LD_STRING , 
106997: STR
106998: PUSH
106999: LD_VAR 0 3
107003: PPUSH
107004: CALL_OW 251
107008: STR
107009: PUSH
107010: LD_STRING , 
107012: STR
107013: PUSH
107014: LD_VAR 0 3
107018: PPUSH
107019: CALL_OW 254
107023: STR
107024: PUSH
107025: LD_STRING , 
107027: STR
107028: PUSH
107029: LD_VAR 0 3
107033: PPUSH
107034: LD_INT 1
107036: PPUSH
107037: CALL_OW 268
107041: STR
107042: PUSH
107043: LD_STRING , 
107045: STR
107046: PUSH
107047: LD_VAR 0 3
107051: PPUSH
107052: LD_INT 2
107054: PPUSH
107055: CALL_OW 268
107059: STR
107060: PUSH
107061: LD_STRING ],
107063: STR
107064: PPUSH
107065: CALL_OW 561
// end ;
107069: GO 106963
107071: POP
107072: POP
// AddToLog ( ]; ) ;
107073: LD_STRING ];
107075: PPUSH
107076: CALL_OW 561
// end ;
107080: LD_VAR 0 2
107084: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
107085: LD_INT 0
107087: PPUSH
107088: PPUSH
107089: PPUSH
107090: PPUSH
107091: PPUSH
// if not area or not rate or not max then
107092: LD_VAR 0 1
107096: NOT
107097: PUSH
107098: LD_VAR 0 2
107102: NOT
107103: OR
107104: PUSH
107105: LD_VAR 0 4
107109: NOT
107110: OR
107111: IFFALSE 107115
// exit ;
107113: GO 107307
// while 1 do
107115: LD_INT 1
107117: IFFALSE 107307
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
107119: LD_ADDR_VAR 0 9
107123: PUSH
107124: LD_VAR 0 1
107128: PPUSH
107129: LD_INT 1
107131: PPUSH
107132: CALL_OW 287
107136: PUSH
107137: LD_INT 10
107139: MUL
107140: ST_TO_ADDR
// r := rate / 10 ;
107141: LD_ADDR_VAR 0 7
107145: PUSH
107146: LD_VAR 0 2
107150: PUSH
107151: LD_INT 10
107153: DIVREAL
107154: ST_TO_ADDR
// time := 1 1$00 ;
107155: LD_ADDR_VAR 0 8
107159: PUSH
107160: LD_INT 2100
107162: ST_TO_ADDR
// if amount < min then
107163: LD_VAR 0 9
107167: PUSH
107168: LD_VAR 0 3
107172: LESS
107173: IFFALSE 107191
// r := r * 2 else
107175: LD_ADDR_VAR 0 7
107179: PUSH
107180: LD_VAR 0 7
107184: PUSH
107185: LD_INT 2
107187: MUL
107188: ST_TO_ADDR
107189: GO 107217
// if amount > max then
107191: LD_VAR 0 9
107195: PUSH
107196: LD_VAR 0 4
107200: GREATER
107201: IFFALSE 107217
// r := r / 2 ;
107203: LD_ADDR_VAR 0 7
107207: PUSH
107208: LD_VAR 0 7
107212: PUSH
107213: LD_INT 2
107215: DIVREAL
107216: ST_TO_ADDR
// time := time / r ;
107217: LD_ADDR_VAR 0 8
107221: PUSH
107222: LD_VAR 0 8
107226: PUSH
107227: LD_VAR 0 7
107231: DIVREAL
107232: ST_TO_ADDR
// if time < 0 then
107233: LD_VAR 0 8
107237: PUSH
107238: LD_INT 0
107240: LESS
107241: IFFALSE 107258
// time := time * - 1 ;
107243: LD_ADDR_VAR 0 8
107247: PUSH
107248: LD_VAR 0 8
107252: PUSH
107253: LD_INT 1
107255: NEG
107256: MUL
107257: ST_TO_ADDR
// wait ( time ) ;
107258: LD_VAR 0 8
107262: PPUSH
107263: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
107267: LD_INT 35
107269: PPUSH
107270: LD_INT 875
107272: PPUSH
107273: CALL_OW 12
107277: PPUSH
107278: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
107282: LD_INT 1
107284: PPUSH
107285: LD_INT 5
107287: PPUSH
107288: CALL_OW 12
107292: PPUSH
107293: LD_VAR 0 1
107297: PPUSH
107298: LD_INT 1
107300: PPUSH
107301: CALL_OW 55
// end ;
107305: GO 107115
// end ;
107307: LD_VAR 0 5
107311: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
107312: LD_INT 0
107314: PPUSH
107315: PPUSH
107316: PPUSH
107317: PPUSH
107318: PPUSH
107319: PPUSH
107320: PPUSH
107321: PPUSH
// if not turrets or not factories then
107322: LD_VAR 0 1
107326: NOT
107327: PUSH
107328: LD_VAR 0 2
107332: NOT
107333: OR
107334: IFFALSE 107338
// exit ;
107336: GO 107645
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
107338: LD_ADDR_VAR 0 10
107342: PUSH
107343: LD_INT 5
107345: PUSH
107346: LD_INT 6
107348: PUSH
107349: EMPTY
107350: LIST
107351: LIST
107352: PUSH
107353: LD_INT 2
107355: PUSH
107356: LD_INT 4
107358: PUSH
107359: EMPTY
107360: LIST
107361: LIST
107362: PUSH
107363: LD_INT 3
107365: PUSH
107366: LD_INT 5
107368: PUSH
107369: EMPTY
107370: LIST
107371: LIST
107372: PUSH
107373: EMPTY
107374: LIST
107375: LIST
107376: LIST
107377: PUSH
107378: LD_INT 24
107380: PUSH
107381: LD_INT 25
107383: PUSH
107384: EMPTY
107385: LIST
107386: LIST
107387: PUSH
107388: LD_INT 23
107390: PUSH
107391: LD_INT 27
107393: PUSH
107394: EMPTY
107395: LIST
107396: LIST
107397: PUSH
107398: EMPTY
107399: LIST
107400: LIST
107401: PUSH
107402: LD_INT 42
107404: PUSH
107405: LD_INT 43
107407: PUSH
107408: EMPTY
107409: LIST
107410: LIST
107411: PUSH
107412: LD_INT 44
107414: PUSH
107415: LD_INT 46
107417: PUSH
107418: EMPTY
107419: LIST
107420: LIST
107421: PUSH
107422: LD_INT 45
107424: PUSH
107425: LD_INT 47
107427: PUSH
107428: EMPTY
107429: LIST
107430: LIST
107431: PUSH
107432: EMPTY
107433: LIST
107434: LIST
107435: LIST
107436: PUSH
107437: EMPTY
107438: LIST
107439: LIST
107440: LIST
107441: ST_TO_ADDR
// result := [ ] ;
107442: LD_ADDR_VAR 0 3
107446: PUSH
107447: EMPTY
107448: ST_TO_ADDR
// for i in turrets do
107449: LD_ADDR_VAR 0 4
107453: PUSH
107454: LD_VAR 0 1
107458: PUSH
107459: FOR_IN
107460: IFFALSE 107643
// begin nat := GetNation ( i ) ;
107462: LD_ADDR_VAR 0 7
107466: PUSH
107467: LD_VAR 0 4
107471: PPUSH
107472: CALL_OW 248
107476: ST_TO_ADDR
// weapon := 0 ;
107477: LD_ADDR_VAR 0 8
107481: PUSH
107482: LD_INT 0
107484: ST_TO_ADDR
// if not nat then
107485: LD_VAR 0 7
107489: NOT
107490: IFFALSE 107494
// continue ;
107492: GO 107459
// for j in list [ nat ] do
107494: LD_ADDR_VAR 0 5
107498: PUSH
107499: LD_VAR 0 10
107503: PUSH
107504: LD_VAR 0 7
107508: ARRAY
107509: PUSH
107510: FOR_IN
107511: IFFALSE 107552
// if GetBWeapon ( i ) = j [ 1 ] then
107513: LD_VAR 0 4
107517: PPUSH
107518: CALL_OW 269
107522: PUSH
107523: LD_VAR 0 5
107527: PUSH
107528: LD_INT 1
107530: ARRAY
107531: EQUAL
107532: IFFALSE 107550
// begin weapon := j [ 2 ] ;
107534: LD_ADDR_VAR 0 8
107538: PUSH
107539: LD_VAR 0 5
107543: PUSH
107544: LD_INT 2
107546: ARRAY
107547: ST_TO_ADDR
// break ;
107548: GO 107552
// end ;
107550: GO 107510
107552: POP
107553: POP
// if not weapon then
107554: LD_VAR 0 8
107558: NOT
107559: IFFALSE 107563
// continue ;
107561: GO 107459
// for k in factories do
107563: LD_ADDR_VAR 0 6
107567: PUSH
107568: LD_VAR 0 2
107572: PUSH
107573: FOR_IN
107574: IFFALSE 107639
// begin weapons := AvailableWeaponList ( k ) ;
107576: LD_ADDR_VAR 0 9
107580: PUSH
107581: LD_VAR 0 6
107585: PPUSH
107586: CALL_OW 478
107590: ST_TO_ADDR
// if not weapons then
107591: LD_VAR 0 9
107595: NOT
107596: IFFALSE 107600
// continue ;
107598: GO 107573
// if weapon in weapons then
107600: LD_VAR 0 8
107604: PUSH
107605: LD_VAR 0 9
107609: IN
107610: IFFALSE 107637
// begin result := [ i , weapon ] ;
107612: LD_ADDR_VAR 0 3
107616: PUSH
107617: LD_VAR 0 4
107621: PUSH
107622: LD_VAR 0 8
107626: PUSH
107627: EMPTY
107628: LIST
107629: LIST
107630: ST_TO_ADDR
// exit ;
107631: POP
107632: POP
107633: POP
107634: POP
107635: GO 107645
// end ; end ;
107637: GO 107573
107639: POP
107640: POP
// end ;
107641: GO 107459
107643: POP
107644: POP
// end ;
107645: LD_VAR 0 3
107649: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
107650: LD_INT 0
107652: PPUSH
// if not side or side > 8 then
107653: LD_VAR 0 3
107657: NOT
107658: PUSH
107659: LD_VAR 0 3
107663: PUSH
107664: LD_INT 8
107666: GREATER
107667: OR
107668: IFFALSE 107672
// exit ;
107670: GO 107731
// if not range then
107672: LD_VAR 0 4
107676: NOT
107677: IFFALSE 107688
// range := - 12 ;
107679: LD_ADDR_VAR 0 4
107683: PUSH
107684: LD_INT 12
107686: NEG
107687: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
107688: LD_VAR 0 1
107692: PPUSH
107693: LD_VAR 0 2
107697: PPUSH
107698: LD_VAR 0 3
107702: PPUSH
107703: LD_VAR 0 4
107707: PPUSH
107708: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
107712: LD_VAR 0 1
107716: PPUSH
107717: LD_VAR 0 2
107721: PPUSH
107722: LD_VAR 0 3
107726: PPUSH
107727: CALL_OW 331
// end ;
107731: LD_VAR 0 5
107735: RET
// export function Video ( mode ) ; begin
107736: LD_INT 0
107738: PPUSH
// ingame_video = mode ;
107739: LD_ADDR_OWVAR 52
107743: PUSH
107744: LD_VAR 0 1
107748: ST_TO_ADDR
// interface_hidden = mode ;
107749: LD_ADDR_OWVAR 54
107753: PUSH
107754: LD_VAR 0 1
107758: ST_TO_ADDR
// end ;
107759: LD_VAR 0 2
107763: RET
// export function Join ( array , element ) ; begin
107764: LD_INT 0
107766: PPUSH
// result := array ^ element ;
107767: LD_ADDR_VAR 0 3
107771: PUSH
107772: LD_VAR 0 1
107776: PUSH
107777: LD_VAR 0 2
107781: ADD
107782: ST_TO_ADDR
// end ;
107783: LD_VAR 0 3
107787: RET
// export function JoinUnion ( array , element ) ; begin
107788: LD_INT 0
107790: PPUSH
// result := array union element ;
107791: LD_ADDR_VAR 0 3
107795: PUSH
107796: LD_VAR 0 1
107800: PUSH
107801: LD_VAR 0 2
107805: UNION
107806: ST_TO_ADDR
// end ;
107807: LD_VAR 0 3
107811: RET
// export function GetBehemoths ( side ) ; begin
107812: LD_INT 0
107814: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
107815: LD_ADDR_VAR 0 2
107819: PUSH
107820: LD_INT 22
107822: PUSH
107823: LD_VAR 0 1
107827: PUSH
107828: EMPTY
107829: LIST
107830: LIST
107831: PUSH
107832: LD_INT 31
107834: PUSH
107835: LD_INT 25
107837: PUSH
107838: EMPTY
107839: LIST
107840: LIST
107841: PUSH
107842: EMPTY
107843: LIST
107844: LIST
107845: PPUSH
107846: CALL_OW 69
107850: ST_TO_ADDR
// end ;
107851: LD_VAR 0 2
107855: RET
// export function Shuffle ( array ) ; var i , index ; begin
107856: LD_INT 0
107858: PPUSH
107859: PPUSH
107860: PPUSH
// result := [ ] ;
107861: LD_ADDR_VAR 0 2
107865: PUSH
107866: EMPTY
107867: ST_TO_ADDR
// if not array then
107868: LD_VAR 0 1
107872: NOT
107873: IFFALSE 107877
// exit ;
107875: GO 107976
// Randomize ;
107877: CALL_OW 10
// for i = array downto 1 do
107881: LD_ADDR_VAR 0 3
107885: PUSH
107886: DOUBLE
107887: LD_VAR 0 1
107891: INC
107892: ST_TO_ADDR
107893: LD_INT 1
107895: PUSH
107896: FOR_DOWNTO
107897: IFFALSE 107974
// begin index := rand ( 1 , array ) ;
107899: LD_ADDR_VAR 0 4
107903: PUSH
107904: LD_INT 1
107906: PPUSH
107907: LD_VAR 0 1
107911: PPUSH
107912: CALL_OW 12
107916: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
107917: LD_ADDR_VAR 0 2
107921: PUSH
107922: LD_VAR 0 2
107926: PPUSH
107927: LD_VAR 0 2
107931: PUSH
107932: LD_INT 1
107934: PLUS
107935: PPUSH
107936: LD_VAR 0 1
107940: PUSH
107941: LD_VAR 0 4
107945: ARRAY
107946: PPUSH
107947: CALL_OW 2
107951: ST_TO_ADDR
// array := Delete ( array , index ) ;
107952: LD_ADDR_VAR 0 1
107956: PUSH
107957: LD_VAR 0 1
107961: PPUSH
107962: LD_VAR 0 4
107966: PPUSH
107967: CALL_OW 3
107971: ST_TO_ADDR
// end ;
107972: GO 107896
107974: POP
107975: POP
// end ;
107976: LD_VAR 0 2
107980: RET
// export function GetBaseMaterials ( base ) ; begin
107981: LD_INT 0
107983: PPUSH
// result := [ 0 , 0 , 0 ] ;
107984: LD_ADDR_VAR 0 2
107988: PUSH
107989: LD_INT 0
107991: PUSH
107992: LD_INT 0
107994: PUSH
107995: LD_INT 0
107997: PUSH
107998: EMPTY
107999: LIST
108000: LIST
108001: LIST
108002: ST_TO_ADDR
// if not base then
108003: LD_VAR 0 1
108007: NOT
108008: IFFALSE 108012
// exit ;
108010: GO 108061
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
108012: LD_ADDR_VAR 0 2
108016: PUSH
108017: LD_VAR 0 1
108021: PPUSH
108022: LD_INT 1
108024: PPUSH
108025: CALL_OW 275
108029: PUSH
108030: LD_VAR 0 1
108034: PPUSH
108035: LD_INT 2
108037: PPUSH
108038: CALL_OW 275
108042: PUSH
108043: LD_VAR 0 1
108047: PPUSH
108048: LD_INT 3
108050: PPUSH
108051: CALL_OW 275
108055: PUSH
108056: EMPTY
108057: LIST
108058: LIST
108059: LIST
108060: ST_TO_ADDR
// end ; end_of_file end_of_file
108061: LD_VAR 0 2
108065: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
108066: GO 108068
108068: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
108069: LD_STRING initStreamRollete();
108071: PPUSH
108072: CALL_OW 559
// InitStreamMode ;
108076: CALL 108085 0 0
// DefineStreamItems ( ) ;
108080: CALL 108525 0 0
// end ;
108084: END
// function InitStreamMode ; begin
108085: LD_INT 0
108087: PPUSH
// streamModeActive := false ;
108088: LD_ADDR_EXP 145
108092: PUSH
108093: LD_INT 0
108095: ST_TO_ADDR
// normalCounter := 36 ;
108096: LD_ADDR_EXP 146
108100: PUSH
108101: LD_INT 36
108103: ST_TO_ADDR
// hardcoreCounter := 16 ;
108104: LD_ADDR_EXP 147
108108: PUSH
108109: LD_INT 16
108111: ST_TO_ADDR
// sRocket := false ;
108112: LD_ADDR_EXP 150
108116: PUSH
108117: LD_INT 0
108119: ST_TO_ADDR
// sSpeed := false ;
108120: LD_ADDR_EXP 149
108124: PUSH
108125: LD_INT 0
108127: ST_TO_ADDR
// sEngine := false ;
108128: LD_ADDR_EXP 151
108132: PUSH
108133: LD_INT 0
108135: ST_TO_ADDR
// sSpec := false ;
108136: LD_ADDR_EXP 148
108140: PUSH
108141: LD_INT 0
108143: ST_TO_ADDR
// sLevel := false ;
108144: LD_ADDR_EXP 152
108148: PUSH
108149: LD_INT 0
108151: ST_TO_ADDR
// sArmoury := false ;
108152: LD_ADDR_EXP 153
108156: PUSH
108157: LD_INT 0
108159: ST_TO_ADDR
// sRadar := false ;
108160: LD_ADDR_EXP 154
108164: PUSH
108165: LD_INT 0
108167: ST_TO_ADDR
// sBunker := false ;
108168: LD_ADDR_EXP 155
108172: PUSH
108173: LD_INT 0
108175: ST_TO_ADDR
// sHack := false ;
108176: LD_ADDR_EXP 156
108180: PUSH
108181: LD_INT 0
108183: ST_TO_ADDR
// sFire := false ;
108184: LD_ADDR_EXP 157
108188: PUSH
108189: LD_INT 0
108191: ST_TO_ADDR
// sRefresh := false ;
108192: LD_ADDR_EXP 158
108196: PUSH
108197: LD_INT 0
108199: ST_TO_ADDR
// sExp := false ;
108200: LD_ADDR_EXP 159
108204: PUSH
108205: LD_INT 0
108207: ST_TO_ADDR
// sDepot := false ;
108208: LD_ADDR_EXP 160
108212: PUSH
108213: LD_INT 0
108215: ST_TO_ADDR
// sFlag := false ;
108216: LD_ADDR_EXP 161
108220: PUSH
108221: LD_INT 0
108223: ST_TO_ADDR
// sKamikadze := false ;
108224: LD_ADDR_EXP 169
108228: PUSH
108229: LD_INT 0
108231: ST_TO_ADDR
// sTroll := false ;
108232: LD_ADDR_EXP 170
108236: PUSH
108237: LD_INT 0
108239: ST_TO_ADDR
// sSlow := false ;
108240: LD_ADDR_EXP 171
108244: PUSH
108245: LD_INT 0
108247: ST_TO_ADDR
// sLack := false ;
108248: LD_ADDR_EXP 172
108252: PUSH
108253: LD_INT 0
108255: ST_TO_ADDR
// sTank := false ;
108256: LD_ADDR_EXP 174
108260: PUSH
108261: LD_INT 0
108263: ST_TO_ADDR
// sRemote := false ;
108264: LD_ADDR_EXP 175
108268: PUSH
108269: LD_INT 0
108271: ST_TO_ADDR
// sPowell := false ;
108272: LD_ADDR_EXP 176
108276: PUSH
108277: LD_INT 0
108279: ST_TO_ADDR
// sTeleport := false ;
108280: LD_ADDR_EXP 179
108284: PUSH
108285: LD_INT 0
108287: ST_TO_ADDR
// sOilTower := false ;
108288: LD_ADDR_EXP 181
108292: PUSH
108293: LD_INT 0
108295: ST_TO_ADDR
// sShovel := false ;
108296: LD_ADDR_EXP 182
108300: PUSH
108301: LD_INT 0
108303: ST_TO_ADDR
// sSheik := false ;
108304: LD_ADDR_EXP 183
108308: PUSH
108309: LD_INT 0
108311: ST_TO_ADDR
// sEarthquake := false ;
108312: LD_ADDR_EXP 185
108316: PUSH
108317: LD_INT 0
108319: ST_TO_ADDR
// sAI := false ;
108320: LD_ADDR_EXP 186
108324: PUSH
108325: LD_INT 0
108327: ST_TO_ADDR
// sCargo := false ;
108328: LD_ADDR_EXP 189
108332: PUSH
108333: LD_INT 0
108335: ST_TO_ADDR
// sDLaser := false ;
108336: LD_ADDR_EXP 190
108340: PUSH
108341: LD_INT 0
108343: ST_TO_ADDR
// sExchange := false ;
108344: LD_ADDR_EXP 191
108348: PUSH
108349: LD_INT 0
108351: ST_TO_ADDR
// sFac := false ;
108352: LD_ADDR_EXP 192
108356: PUSH
108357: LD_INT 0
108359: ST_TO_ADDR
// sPower := false ;
108360: LD_ADDR_EXP 193
108364: PUSH
108365: LD_INT 0
108367: ST_TO_ADDR
// sRandom := false ;
108368: LD_ADDR_EXP 194
108372: PUSH
108373: LD_INT 0
108375: ST_TO_ADDR
// sShield := false ;
108376: LD_ADDR_EXP 195
108380: PUSH
108381: LD_INT 0
108383: ST_TO_ADDR
// sTime := false ;
108384: LD_ADDR_EXP 196
108388: PUSH
108389: LD_INT 0
108391: ST_TO_ADDR
// sTools := false ;
108392: LD_ADDR_EXP 197
108396: PUSH
108397: LD_INT 0
108399: ST_TO_ADDR
// sSold := false ;
108400: LD_ADDR_EXP 162
108404: PUSH
108405: LD_INT 0
108407: ST_TO_ADDR
// sDiff := false ;
108408: LD_ADDR_EXP 163
108412: PUSH
108413: LD_INT 0
108415: ST_TO_ADDR
// sFog := false ;
108416: LD_ADDR_EXP 166
108420: PUSH
108421: LD_INT 0
108423: ST_TO_ADDR
// sReset := false ;
108424: LD_ADDR_EXP 167
108428: PUSH
108429: LD_INT 0
108431: ST_TO_ADDR
// sSun := false ;
108432: LD_ADDR_EXP 168
108436: PUSH
108437: LD_INT 0
108439: ST_TO_ADDR
// sTiger := false ;
108440: LD_ADDR_EXP 164
108444: PUSH
108445: LD_INT 0
108447: ST_TO_ADDR
// sBomb := false ;
108448: LD_ADDR_EXP 165
108452: PUSH
108453: LD_INT 0
108455: ST_TO_ADDR
// sWound := false ;
108456: LD_ADDR_EXP 173
108460: PUSH
108461: LD_INT 0
108463: ST_TO_ADDR
// sBetray := false ;
108464: LD_ADDR_EXP 177
108468: PUSH
108469: LD_INT 0
108471: ST_TO_ADDR
// sContamin := false ;
108472: LD_ADDR_EXP 178
108476: PUSH
108477: LD_INT 0
108479: ST_TO_ADDR
// sOil := false ;
108480: LD_ADDR_EXP 180
108484: PUSH
108485: LD_INT 0
108487: ST_TO_ADDR
// sStu := false ;
108488: LD_ADDR_EXP 184
108492: PUSH
108493: LD_INT 0
108495: ST_TO_ADDR
// sBazooka := false ;
108496: LD_ADDR_EXP 187
108500: PUSH
108501: LD_INT 0
108503: ST_TO_ADDR
// sMortar := false ;
108504: LD_ADDR_EXP 188
108508: PUSH
108509: LD_INT 0
108511: ST_TO_ADDR
// sRanger := false ;
108512: LD_ADDR_EXP 198
108516: PUSH
108517: LD_INT 0
108519: ST_TO_ADDR
// end ;
108520: LD_VAR 0 1
108524: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
108525: LD_INT 0
108527: PPUSH
108528: PPUSH
108529: PPUSH
108530: PPUSH
108531: PPUSH
// result := [ ] ;
108532: LD_ADDR_VAR 0 1
108536: PUSH
108537: EMPTY
108538: ST_TO_ADDR
// if campaign_id = 1 then
108539: LD_OWVAR 69
108543: PUSH
108544: LD_INT 1
108546: EQUAL
108547: IFFALSE 111485
// begin case mission_number of 1 :
108549: LD_OWVAR 70
108553: PUSH
108554: LD_INT 1
108556: DOUBLE
108557: EQUAL
108558: IFTRUE 108562
108560: GO 108626
108562: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
108563: LD_ADDR_VAR 0 1
108567: PUSH
108568: LD_INT 2
108570: PUSH
108571: LD_INT 4
108573: PUSH
108574: LD_INT 11
108576: PUSH
108577: LD_INT 12
108579: PUSH
108580: LD_INT 15
108582: PUSH
108583: LD_INT 16
108585: PUSH
108586: LD_INT 22
108588: PUSH
108589: LD_INT 23
108591: PUSH
108592: LD_INT 26
108594: PUSH
108595: EMPTY
108596: LIST
108597: LIST
108598: LIST
108599: LIST
108600: LIST
108601: LIST
108602: LIST
108603: LIST
108604: LIST
108605: PUSH
108606: LD_INT 101
108608: PUSH
108609: LD_INT 102
108611: PUSH
108612: LD_INT 106
108614: PUSH
108615: EMPTY
108616: LIST
108617: LIST
108618: LIST
108619: PUSH
108620: EMPTY
108621: LIST
108622: LIST
108623: ST_TO_ADDR
108624: GO 111483
108626: LD_INT 2
108628: DOUBLE
108629: EQUAL
108630: IFTRUE 108634
108632: GO 108706
108634: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
108635: LD_ADDR_VAR 0 1
108639: PUSH
108640: LD_INT 2
108642: PUSH
108643: LD_INT 4
108645: PUSH
108646: LD_INT 11
108648: PUSH
108649: LD_INT 12
108651: PUSH
108652: LD_INT 15
108654: PUSH
108655: LD_INT 16
108657: PUSH
108658: LD_INT 22
108660: PUSH
108661: LD_INT 23
108663: PUSH
108664: LD_INT 26
108666: PUSH
108667: EMPTY
108668: LIST
108669: LIST
108670: LIST
108671: LIST
108672: LIST
108673: LIST
108674: LIST
108675: LIST
108676: LIST
108677: PUSH
108678: LD_INT 101
108680: PUSH
108681: LD_INT 102
108683: PUSH
108684: LD_INT 105
108686: PUSH
108687: LD_INT 106
108689: PUSH
108690: LD_INT 108
108692: PUSH
108693: EMPTY
108694: LIST
108695: LIST
108696: LIST
108697: LIST
108698: LIST
108699: PUSH
108700: EMPTY
108701: LIST
108702: LIST
108703: ST_TO_ADDR
108704: GO 111483
108706: LD_INT 3
108708: DOUBLE
108709: EQUAL
108710: IFTRUE 108714
108712: GO 108790
108714: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
108715: LD_ADDR_VAR 0 1
108719: PUSH
108720: LD_INT 2
108722: PUSH
108723: LD_INT 4
108725: PUSH
108726: LD_INT 5
108728: PUSH
108729: LD_INT 11
108731: PUSH
108732: LD_INT 12
108734: PUSH
108735: LD_INT 15
108737: PUSH
108738: LD_INT 16
108740: PUSH
108741: LD_INT 22
108743: PUSH
108744: LD_INT 26
108746: PUSH
108747: LD_INT 36
108749: PUSH
108750: EMPTY
108751: LIST
108752: LIST
108753: LIST
108754: LIST
108755: LIST
108756: LIST
108757: LIST
108758: LIST
108759: LIST
108760: LIST
108761: PUSH
108762: LD_INT 101
108764: PUSH
108765: LD_INT 102
108767: PUSH
108768: LD_INT 105
108770: PUSH
108771: LD_INT 106
108773: PUSH
108774: LD_INT 108
108776: PUSH
108777: EMPTY
108778: LIST
108779: LIST
108780: LIST
108781: LIST
108782: LIST
108783: PUSH
108784: EMPTY
108785: LIST
108786: LIST
108787: ST_TO_ADDR
108788: GO 111483
108790: LD_INT 4
108792: DOUBLE
108793: EQUAL
108794: IFTRUE 108798
108796: GO 108882
108798: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
108799: LD_ADDR_VAR 0 1
108803: PUSH
108804: LD_INT 2
108806: PUSH
108807: LD_INT 4
108809: PUSH
108810: LD_INT 5
108812: PUSH
108813: LD_INT 8
108815: PUSH
108816: LD_INT 11
108818: PUSH
108819: LD_INT 12
108821: PUSH
108822: LD_INT 15
108824: PUSH
108825: LD_INT 16
108827: PUSH
108828: LD_INT 22
108830: PUSH
108831: LD_INT 23
108833: PUSH
108834: LD_INT 26
108836: PUSH
108837: LD_INT 36
108839: PUSH
108840: EMPTY
108841: LIST
108842: LIST
108843: LIST
108844: LIST
108845: LIST
108846: LIST
108847: LIST
108848: LIST
108849: LIST
108850: LIST
108851: LIST
108852: LIST
108853: PUSH
108854: LD_INT 101
108856: PUSH
108857: LD_INT 102
108859: PUSH
108860: LD_INT 105
108862: PUSH
108863: LD_INT 106
108865: PUSH
108866: LD_INT 108
108868: PUSH
108869: EMPTY
108870: LIST
108871: LIST
108872: LIST
108873: LIST
108874: LIST
108875: PUSH
108876: EMPTY
108877: LIST
108878: LIST
108879: ST_TO_ADDR
108880: GO 111483
108882: LD_INT 5
108884: DOUBLE
108885: EQUAL
108886: IFTRUE 108890
108888: GO 108990
108890: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
108891: LD_ADDR_VAR 0 1
108895: PUSH
108896: LD_INT 2
108898: PUSH
108899: LD_INT 4
108901: PUSH
108902: LD_INT 5
108904: PUSH
108905: LD_INT 6
108907: PUSH
108908: LD_INT 8
108910: PUSH
108911: LD_INT 11
108913: PUSH
108914: LD_INT 12
108916: PUSH
108917: LD_INT 15
108919: PUSH
108920: LD_INT 16
108922: PUSH
108923: LD_INT 22
108925: PUSH
108926: LD_INT 23
108928: PUSH
108929: LD_INT 25
108931: PUSH
108932: LD_INT 26
108934: PUSH
108935: LD_INT 36
108937: PUSH
108938: EMPTY
108939: LIST
108940: LIST
108941: LIST
108942: LIST
108943: LIST
108944: LIST
108945: LIST
108946: LIST
108947: LIST
108948: LIST
108949: LIST
108950: LIST
108951: LIST
108952: LIST
108953: PUSH
108954: LD_INT 101
108956: PUSH
108957: LD_INT 102
108959: PUSH
108960: LD_INT 105
108962: PUSH
108963: LD_INT 106
108965: PUSH
108966: LD_INT 108
108968: PUSH
108969: LD_INT 109
108971: PUSH
108972: LD_INT 112
108974: PUSH
108975: EMPTY
108976: LIST
108977: LIST
108978: LIST
108979: LIST
108980: LIST
108981: LIST
108982: LIST
108983: PUSH
108984: EMPTY
108985: LIST
108986: LIST
108987: ST_TO_ADDR
108988: GO 111483
108990: LD_INT 6
108992: DOUBLE
108993: EQUAL
108994: IFTRUE 108998
108996: GO 109118
108998: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
108999: LD_ADDR_VAR 0 1
109003: PUSH
109004: LD_INT 2
109006: PUSH
109007: LD_INT 4
109009: PUSH
109010: LD_INT 5
109012: PUSH
109013: LD_INT 6
109015: PUSH
109016: LD_INT 8
109018: PUSH
109019: LD_INT 11
109021: PUSH
109022: LD_INT 12
109024: PUSH
109025: LD_INT 15
109027: PUSH
109028: LD_INT 16
109030: PUSH
109031: LD_INT 20
109033: PUSH
109034: LD_INT 21
109036: PUSH
109037: LD_INT 22
109039: PUSH
109040: LD_INT 23
109042: PUSH
109043: LD_INT 25
109045: PUSH
109046: LD_INT 26
109048: PUSH
109049: LD_INT 30
109051: PUSH
109052: LD_INT 31
109054: PUSH
109055: LD_INT 32
109057: PUSH
109058: LD_INT 36
109060: PUSH
109061: EMPTY
109062: LIST
109063: LIST
109064: LIST
109065: LIST
109066: LIST
109067: LIST
109068: LIST
109069: LIST
109070: LIST
109071: LIST
109072: LIST
109073: LIST
109074: LIST
109075: LIST
109076: LIST
109077: LIST
109078: LIST
109079: LIST
109080: LIST
109081: PUSH
109082: LD_INT 101
109084: PUSH
109085: LD_INT 102
109087: PUSH
109088: LD_INT 105
109090: PUSH
109091: LD_INT 106
109093: PUSH
109094: LD_INT 108
109096: PUSH
109097: LD_INT 109
109099: PUSH
109100: LD_INT 112
109102: PUSH
109103: EMPTY
109104: LIST
109105: LIST
109106: LIST
109107: LIST
109108: LIST
109109: LIST
109110: LIST
109111: PUSH
109112: EMPTY
109113: LIST
109114: LIST
109115: ST_TO_ADDR
109116: GO 111483
109118: LD_INT 7
109120: DOUBLE
109121: EQUAL
109122: IFTRUE 109126
109124: GO 109226
109126: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
109127: LD_ADDR_VAR 0 1
109131: PUSH
109132: LD_INT 2
109134: PUSH
109135: LD_INT 4
109137: PUSH
109138: LD_INT 5
109140: PUSH
109141: LD_INT 7
109143: PUSH
109144: LD_INT 11
109146: PUSH
109147: LD_INT 12
109149: PUSH
109150: LD_INT 15
109152: PUSH
109153: LD_INT 16
109155: PUSH
109156: LD_INT 20
109158: PUSH
109159: LD_INT 21
109161: PUSH
109162: LD_INT 22
109164: PUSH
109165: LD_INT 23
109167: PUSH
109168: LD_INT 25
109170: PUSH
109171: LD_INT 26
109173: PUSH
109174: EMPTY
109175: LIST
109176: LIST
109177: LIST
109178: LIST
109179: LIST
109180: LIST
109181: LIST
109182: LIST
109183: LIST
109184: LIST
109185: LIST
109186: LIST
109187: LIST
109188: LIST
109189: PUSH
109190: LD_INT 101
109192: PUSH
109193: LD_INT 102
109195: PUSH
109196: LD_INT 103
109198: PUSH
109199: LD_INT 105
109201: PUSH
109202: LD_INT 106
109204: PUSH
109205: LD_INT 108
109207: PUSH
109208: LD_INT 112
109210: PUSH
109211: EMPTY
109212: LIST
109213: LIST
109214: LIST
109215: LIST
109216: LIST
109217: LIST
109218: LIST
109219: PUSH
109220: EMPTY
109221: LIST
109222: LIST
109223: ST_TO_ADDR
109224: GO 111483
109226: LD_INT 8
109228: DOUBLE
109229: EQUAL
109230: IFTRUE 109234
109232: GO 109362
109234: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
109235: LD_ADDR_VAR 0 1
109239: PUSH
109240: LD_INT 2
109242: PUSH
109243: LD_INT 4
109245: PUSH
109246: LD_INT 5
109248: PUSH
109249: LD_INT 6
109251: PUSH
109252: LD_INT 7
109254: PUSH
109255: LD_INT 8
109257: PUSH
109258: LD_INT 11
109260: PUSH
109261: LD_INT 12
109263: PUSH
109264: LD_INT 15
109266: PUSH
109267: LD_INT 16
109269: PUSH
109270: LD_INT 20
109272: PUSH
109273: LD_INT 21
109275: PUSH
109276: LD_INT 22
109278: PUSH
109279: LD_INT 23
109281: PUSH
109282: LD_INT 25
109284: PUSH
109285: LD_INT 26
109287: PUSH
109288: LD_INT 30
109290: PUSH
109291: LD_INT 31
109293: PUSH
109294: LD_INT 32
109296: PUSH
109297: LD_INT 36
109299: PUSH
109300: EMPTY
109301: LIST
109302: LIST
109303: LIST
109304: LIST
109305: LIST
109306: LIST
109307: LIST
109308: LIST
109309: LIST
109310: LIST
109311: LIST
109312: LIST
109313: LIST
109314: LIST
109315: LIST
109316: LIST
109317: LIST
109318: LIST
109319: LIST
109320: LIST
109321: PUSH
109322: LD_INT 101
109324: PUSH
109325: LD_INT 102
109327: PUSH
109328: LD_INT 103
109330: PUSH
109331: LD_INT 105
109333: PUSH
109334: LD_INT 106
109336: PUSH
109337: LD_INT 108
109339: PUSH
109340: LD_INT 109
109342: PUSH
109343: LD_INT 112
109345: PUSH
109346: EMPTY
109347: LIST
109348: LIST
109349: LIST
109350: LIST
109351: LIST
109352: LIST
109353: LIST
109354: LIST
109355: PUSH
109356: EMPTY
109357: LIST
109358: LIST
109359: ST_TO_ADDR
109360: GO 111483
109362: LD_INT 9
109364: DOUBLE
109365: EQUAL
109366: IFTRUE 109370
109368: GO 109506
109370: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
109371: LD_ADDR_VAR 0 1
109375: PUSH
109376: LD_INT 2
109378: PUSH
109379: LD_INT 4
109381: PUSH
109382: LD_INT 5
109384: PUSH
109385: LD_INT 6
109387: PUSH
109388: LD_INT 7
109390: PUSH
109391: LD_INT 8
109393: PUSH
109394: LD_INT 11
109396: PUSH
109397: LD_INT 12
109399: PUSH
109400: LD_INT 15
109402: PUSH
109403: LD_INT 16
109405: PUSH
109406: LD_INT 20
109408: PUSH
109409: LD_INT 21
109411: PUSH
109412: LD_INT 22
109414: PUSH
109415: LD_INT 23
109417: PUSH
109418: LD_INT 25
109420: PUSH
109421: LD_INT 26
109423: PUSH
109424: LD_INT 28
109426: PUSH
109427: LD_INT 30
109429: PUSH
109430: LD_INT 31
109432: PUSH
109433: LD_INT 32
109435: PUSH
109436: LD_INT 36
109438: PUSH
109439: EMPTY
109440: LIST
109441: LIST
109442: LIST
109443: LIST
109444: LIST
109445: LIST
109446: LIST
109447: LIST
109448: LIST
109449: LIST
109450: LIST
109451: LIST
109452: LIST
109453: LIST
109454: LIST
109455: LIST
109456: LIST
109457: LIST
109458: LIST
109459: LIST
109460: LIST
109461: PUSH
109462: LD_INT 101
109464: PUSH
109465: LD_INT 102
109467: PUSH
109468: LD_INT 103
109470: PUSH
109471: LD_INT 105
109473: PUSH
109474: LD_INT 106
109476: PUSH
109477: LD_INT 108
109479: PUSH
109480: LD_INT 109
109482: PUSH
109483: LD_INT 112
109485: PUSH
109486: LD_INT 114
109488: PUSH
109489: EMPTY
109490: LIST
109491: LIST
109492: LIST
109493: LIST
109494: LIST
109495: LIST
109496: LIST
109497: LIST
109498: LIST
109499: PUSH
109500: EMPTY
109501: LIST
109502: LIST
109503: ST_TO_ADDR
109504: GO 111483
109506: LD_INT 10
109508: DOUBLE
109509: EQUAL
109510: IFTRUE 109514
109512: GO 109698
109514: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
109515: LD_ADDR_VAR 0 1
109519: PUSH
109520: LD_INT 2
109522: PUSH
109523: LD_INT 4
109525: PUSH
109526: LD_INT 5
109528: PUSH
109529: LD_INT 6
109531: PUSH
109532: LD_INT 7
109534: PUSH
109535: LD_INT 8
109537: PUSH
109538: LD_INT 9
109540: PUSH
109541: LD_INT 10
109543: PUSH
109544: LD_INT 11
109546: PUSH
109547: LD_INT 12
109549: PUSH
109550: LD_INT 13
109552: PUSH
109553: LD_INT 14
109555: PUSH
109556: LD_INT 15
109558: PUSH
109559: LD_INT 16
109561: PUSH
109562: LD_INT 17
109564: PUSH
109565: LD_INT 18
109567: PUSH
109568: LD_INT 19
109570: PUSH
109571: LD_INT 20
109573: PUSH
109574: LD_INT 21
109576: PUSH
109577: LD_INT 22
109579: PUSH
109580: LD_INT 23
109582: PUSH
109583: LD_INT 24
109585: PUSH
109586: LD_INT 25
109588: PUSH
109589: LD_INT 26
109591: PUSH
109592: LD_INT 28
109594: PUSH
109595: LD_INT 30
109597: PUSH
109598: LD_INT 31
109600: PUSH
109601: LD_INT 32
109603: PUSH
109604: LD_INT 36
109606: PUSH
109607: EMPTY
109608: LIST
109609: LIST
109610: LIST
109611: LIST
109612: LIST
109613: LIST
109614: LIST
109615: LIST
109616: LIST
109617: LIST
109618: LIST
109619: LIST
109620: LIST
109621: LIST
109622: LIST
109623: LIST
109624: LIST
109625: LIST
109626: LIST
109627: LIST
109628: LIST
109629: LIST
109630: LIST
109631: LIST
109632: LIST
109633: LIST
109634: LIST
109635: LIST
109636: LIST
109637: PUSH
109638: LD_INT 101
109640: PUSH
109641: LD_INT 102
109643: PUSH
109644: LD_INT 103
109646: PUSH
109647: LD_INT 104
109649: PUSH
109650: LD_INT 105
109652: PUSH
109653: LD_INT 106
109655: PUSH
109656: LD_INT 107
109658: PUSH
109659: LD_INT 108
109661: PUSH
109662: LD_INT 109
109664: PUSH
109665: LD_INT 110
109667: PUSH
109668: LD_INT 111
109670: PUSH
109671: LD_INT 112
109673: PUSH
109674: LD_INT 114
109676: PUSH
109677: EMPTY
109678: LIST
109679: LIST
109680: LIST
109681: LIST
109682: LIST
109683: LIST
109684: LIST
109685: LIST
109686: LIST
109687: LIST
109688: LIST
109689: LIST
109690: LIST
109691: PUSH
109692: EMPTY
109693: LIST
109694: LIST
109695: ST_TO_ADDR
109696: GO 111483
109698: LD_INT 11
109700: DOUBLE
109701: EQUAL
109702: IFTRUE 109706
109704: GO 109898
109706: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
109707: LD_ADDR_VAR 0 1
109711: PUSH
109712: LD_INT 2
109714: PUSH
109715: LD_INT 3
109717: PUSH
109718: LD_INT 4
109720: PUSH
109721: LD_INT 5
109723: PUSH
109724: LD_INT 6
109726: PUSH
109727: LD_INT 7
109729: PUSH
109730: LD_INT 8
109732: PUSH
109733: LD_INT 9
109735: PUSH
109736: LD_INT 10
109738: PUSH
109739: LD_INT 11
109741: PUSH
109742: LD_INT 12
109744: PUSH
109745: LD_INT 13
109747: PUSH
109748: LD_INT 14
109750: PUSH
109751: LD_INT 15
109753: PUSH
109754: LD_INT 16
109756: PUSH
109757: LD_INT 17
109759: PUSH
109760: LD_INT 18
109762: PUSH
109763: LD_INT 19
109765: PUSH
109766: LD_INT 20
109768: PUSH
109769: LD_INT 21
109771: PUSH
109772: LD_INT 22
109774: PUSH
109775: LD_INT 23
109777: PUSH
109778: LD_INT 24
109780: PUSH
109781: LD_INT 25
109783: PUSH
109784: LD_INT 26
109786: PUSH
109787: LD_INT 28
109789: PUSH
109790: LD_INT 30
109792: PUSH
109793: LD_INT 31
109795: PUSH
109796: LD_INT 32
109798: PUSH
109799: LD_INT 34
109801: PUSH
109802: LD_INT 36
109804: PUSH
109805: EMPTY
109806: LIST
109807: LIST
109808: LIST
109809: LIST
109810: LIST
109811: LIST
109812: LIST
109813: LIST
109814: LIST
109815: LIST
109816: LIST
109817: LIST
109818: LIST
109819: LIST
109820: LIST
109821: LIST
109822: LIST
109823: LIST
109824: LIST
109825: LIST
109826: LIST
109827: LIST
109828: LIST
109829: LIST
109830: LIST
109831: LIST
109832: LIST
109833: LIST
109834: LIST
109835: LIST
109836: LIST
109837: PUSH
109838: LD_INT 101
109840: PUSH
109841: LD_INT 102
109843: PUSH
109844: LD_INT 103
109846: PUSH
109847: LD_INT 104
109849: PUSH
109850: LD_INT 105
109852: PUSH
109853: LD_INT 106
109855: PUSH
109856: LD_INT 107
109858: PUSH
109859: LD_INT 108
109861: PUSH
109862: LD_INT 109
109864: PUSH
109865: LD_INT 110
109867: PUSH
109868: LD_INT 111
109870: PUSH
109871: LD_INT 112
109873: PUSH
109874: LD_INT 114
109876: PUSH
109877: EMPTY
109878: LIST
109879: LIST
109880: LIST
109881: LIST
109882: LIST
109883: LIST
109884: LIST
109885: LIST
109886: LIST
109887: LIST
109888: LIST
109889: LIST
109890: LIST
109891: PUSH
109892: EMPTY
109893: LIST
109894: LIST
109895: ST_TO_ADDR
109896: GO 111483
109898: LD_INT 12
109900: DOUBLE
109901: EQUAL
109902: IFTRUE 109906
109904: GO 110114
109906: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
109907: LD_ADDR_VAR 0 1
109911: PUSH
109912: LD_INT 1
109914: PUSH
109915: LD_INT 2
109917: PUSH
109918: LD_INT 3
109920: PUSH
109921: LD_INT 4
109923: PUSH
109924: LD_INT 5
109926: PUSH
109927: LD_INT 6
109929: PUSH
109930: LD_INT 7
109932: PUSH
109933: LD_INT 8
109935: PUSH
109936: LD_INT 9
109938: PUSH
109939: LD_INT 10
109941: PUSH
109942: LD_INT 11
109944: PUSH
109945: LD_INT 12
109947: PUSH
109948: LD_INT 13
109950: PUSH
109951: LD_INT 14
109953: PUSH
109954: LD_INT 15
109956: PUSH
109957: LD_INT 16
109959: PUSH
109960: LD_INT 17
109962: PUSH
109963: LD_INT 18
109965: PUSH
109966: LD_INT 19
109968: PUSH
109969: LD_INT 20
109971: PUSH
109972: LD_INT 21
109974: PUSH
109975: LD_INT 22
109977: PUSH
109978: LD_INT 23
109980: PUSH
109981: LD_INT 24
109983: PUSH
109984: LD_INT 25
109986: PUSH
109987: LD_INT 26
109989: PUSH
109990: LD_INT 27
109992: PUSH
109993: LD_INT 28
109995: PUSH
109996: LD_INT 30
109998: PUSH
109999: LD_INT 31
110001: PUSH
110002: LD_INT 32
110004: PUSH
110005: LD_INT 33
110007: PUSH
110008: LD_INT 34
110010: PUSH
110011: LD_INT 36
110013: PUSH
110014: EMPTY
110015: LIST
110016: LIST
110017: LIST
110018: LIST
110019: LIST
110020: LIST
110021: LIST
110022: LIST
110023: LIST
110024: LIST
110025: LIST
110026: LIST
110027: LIST
110028: LIST
110029: LIST
110030: LIST
110031: LIST
110032: LIST
110033: LIST
110034: LIST
110035: LIST
110036: LIST
110037: LIST
110038: LIST
110039: LIST
110040: LIST
110041: LIST
110042: LIST
110043: LIST
110044: LIST
110045: LIST
110046: LIST
110047: LIST
110048: LIST
110049: PUSH
110050: LD_INT 101
110052: PUSH
110053: LD_INT 102
110055: PUSH
110056: LD_INT 103
110058: PUSH
110059: LD_INT 104
110061: PUSH
110062: LD_INT 105
110064: PUSH
110065: LD_INT 106
110067: PUSH
110068: LD_INT 107
110070: PUSH
110071: LD_INT 108
110073: PUSH
110074: LD_INT 109
110076: PUSH
110077: LD_INT 110
110079: PUSH
110080: LD_INT 111
110082: PUSH
110083: LD_INT 112
110085: PUSH
110086: LD_INT 113
110088: PUSH
110089: LD_INT 114
110091: PUSH
110092: EMPTY
110093: LIST
110094: LIST
110095: LIST
110096: LIST
110097: LIST
110098: LIST
110099: LIST
110100: LIST
110101: LIST
110102: LIST
110103: LIST
110104: LIST
110105: LIST
110106: LIST
110107: PUSH
110108: EMPTY
110109: LIST
110110: LIST
110111: ST_TO_ADDR
110112: GO 111483
110114: LD_INT 13
110116: DOUBLE
110117: EQUAL
110118: IFTRUE 110122
110120: GO 110318
110122: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
110123: LD_ADDR_VAR 0 1
110127: PUSH
110128: LD_INT 1
110130: PUSH
110131: LD_INT 2
110133: PUSH
110134: LD_INT 3
110136: PUSH
110137: LD_INT 4
110139: PUSH
110140: LD_INT 5
110142: PUSH
110143: LD_INT 8
110145: PUSH
110146: LD_INT 9
110148: PUSH
110149: LD_INT 10
110151: PUSH
110152: LD_INT 11
110154: PUSH
110155: LD_INT 12
110157: PUSH
110158: LD_INT 14
110160: PUSH
110161: LD_INT 15
110163: PUSH
110164: LD_INT 16
110166: PUSH
110167: LD_INT 17
110169: PUSH
110170: LD_INT 18
110172: PUSH
110173: LD_INT 19
110175: PUSH
110176: LD_INT 20
110178: PUSH
110179: LD_INT 21
110181: PUSH
110182: LD_INT 22
110184: PUSH
110185: LD_INT 23
110187: PUSH
110188: LD_INT 24
110190: PUSH
110191: LD_INT 25
110193: PUSH
110194: LD_INT 26
110196: PUSH
110197: LD_INT 27
110199: PUSH
110200: LD_INT 28
110202: PUSH
110203: LD_INT 30
110205: PUSH
110206: LD_INT 31
110208: PUSH
110209: LD_INT 32
110211: PUSH
110212: LD_INT 33
110214: PUSH
110215: LD_INT 34
110217: PUSH
110218: LD_INT 36
110220: PUSH
110221: EMPTY
110222: LIST
110223: LIST
110224: LIST
110225: LIST
110226: LIST
110227: LIST
110228: LIST
110229: LIST
110230: LIST
110231: LIST
110232: LIST
110233: LIST
110234: LIST
110235: LIST
110236: LIST
110237: LIST
110238: LIST
110239: LIST
110240: LIST
110241: LIST
110242: LIST
110243: LIST
110244: LIST
110245: LIST
110246: LIST
110247: LIST
110248: LIST
110249: LIST
110250: LIST
110251: LIST
110252: LIST
110253: PUSH
110254: LD_INT 101
110256: PUSH
110257: LD_INT 102
110259: PUSH
110260: LD_INT 103
110262: PUSH
110263: LD_INT 104
110265: PUSH
110266: LD_INT 105
110268: PUSH
110269: LD_INT 106
110271: PUSH
110272: LD_INT 107
110274: PUSH
110275: LD_INT 108
110277: PUSH
110278: LD_INT 109
110280: PUSH
110281: LD_INT 110
110283: PUSH
110284: LD_INT 111
110286: PUSH
110287: LD_INT 112
110289: PUSH
110290: LD_INT 113
110292: PUSH
110293: LD_INT 114
110295: PUSH
110296: EMPTY
110297: LIST
110298: LIST
110299: LIST
110300: LIST
110301: LIST
110302: LIST
110303: LIST
110304: LIST
110305: LIST
110306: LIST
110307: LIST
110308: LIST
110309: LIST
110310: LIST
110311: PUSH
110312: EMPTY
110313: LIST
110314: LIST
110315: ST_TO_ADDR
110316: GO 111483
110318: LD_INT 14
110320: DOUBLE
110321: EQUAL
110322: IFTRUE 110326
110324: GO 110538
110326: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
110327: LD_ADDR_VAR 0 1
110331: PUSH
110332: LD_INT 1
110334: PUSH
110335: LD_INT 2
110337: PUSH
110338: LD_INT 3
110340: PUSH
110341: LD_INT 4
110343: PUSH
110344: LD_INT 5
110346: PUSH
110347: LD_INT 6
110349: PUSH
110350: LD_INT 7
110352: PUSH
110353: LD_INT 8
110355: PUSH
110356: LD_INT 9
110358: PUSH
110359: LD_INT 10
110361: PUSH
110362: LD_INT 11
110364: PUSH
110365: LD_INT 12
110367: PUSH
110368: LD_INT 13
110370: PUSH
110371: LD_INT 14
110373: PUSH
110374: LD_INT 15
110376: PUSH
110377: LD_INT 16
110379: PUSH
110380: LD_INT 17
110382: PUSH
110383: LD_INT 18
110385: PUSH
110386: LD_INT 19
110388: PUSH
110389: LD_INT 20
110391: PUSH
110392: LD_INT 21
110394: PUSH
110395: LD_INT 22
110397: PUSH
110398: LD_INT 23
110400: PUSH
110401: LD_INT 24
110403: PUSH
110404: LD_INT 25
110406: PUSH
110407: LD_INT 26
110409: PUSH
110410: LD_INT 27
110412: PUSH
110413: LD_INT 28
110415: PUSH
110416: LD_INT 29
110418: PUSH
110419: LD_INT 30
110421: PUSH
110422: LD_INT 31
110424: PUSH
110425: LD_INT 32
110427: PUSH
110428: LD_INT 33
110430: PUSH
110431: LD_INT 34
110433: PUSH
110434: LD_INT 36
110436: PUSH
110437: EMPTY
110438: LIST
110439: LIST
110440: LIST
110441: LIST
110442: LIST
110443: LIST
110444: LIST
110445: LIST
110446: LIST
110447: LIST
110448: LIST
110449: LIST
110450: LIST
110451: LIST
110452: LIST
110453: LIST
110454: LIST
110455: LIST
110456: LIST
110457: LIST
110458: LIST
110459: LIST
110460: LIST
110461: LIST
110462: LIST
110463: LIST
110464: LIST
110465: LIST
110466: LIST
110467: LIST
110468: LIST
110469: LIST
110470: LIST
110471: LIST
110472: LIST
110473: PUSH
110474: LD_INT 101
110476: PUSH
110477: LD_INT 102
110479: PUSH
110480: LD_INT 103
110482: PUSH
110483: LD_INT 104
110485: PUSH
110486: LD_INT 105
110488: PUSH
110489: LD_INT 106
110491: PUSH
110492: LD_INT 107
110494: PUSH
110495: LD_INT 108
110497: PUSH
110498: LD_INT 109
110500: PUSH
110501: LD_INT 110
110503: PUSH
110504: LD_INT 111
110506: PUSH
110507: LD_INT 112
110509: PUSH
110510: LD_INT 113
110512: PUSH
110513: LD_INT 114
110515: PUSH
110516: EMPTY
110517: LIST
110518: LIST
110519: LIST
110520: LIST
110521: LIST
110522: LIST
110523: LIST
110524: LIST
110525: LIST
110526: LIST
110527: LIST
110528: LIST
110529: LIST
110530: LIST
110531: PUSH
110532: EMPTY
110533: LIST
110534: LIST
110535: ST_TO_ADDR
110536: GO 111483
110538: LD_INT 15
110540: DOUBLE
110541: EQUAL
110542: IFTRUE 110546
110544: GO 110758
110546: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
110547: LD_ADDR_VAR 0 1
110551: PUSH
110552: LD_INT 1
110554: PUSH
110555: LD_INT 2
110557: PUSH
110558: LD_INT 3
110560: PUSH
110561: LD_INT 4
110563: PUSH
110564: LD_INT 5
110566: PUSH
110567: LD_INT 6
110569: PUSH
110570: LD_INT 7
110572: PUSH
110573: LD_INT 8
110575: PUSH
110576: LD_INT 9
110578: PUSH
110579: LD_INT 10
110581: PUSH
110582: LD_INT 11
110584: PUSH
110585: LD_INT 12
110587: PUSH
110588: LD_INT 13
110590: PUSH
110591: LD_INT 14
110593: PUSH
110594: LD_INT 15
110596: PUSH
110597: LD_INT 16
110599: PUSH
110600: LD_INT 17
110602: PUSH
110603: LD_INT 18
110605: PUSH
110606: LD_INT 19
110608: PUSH
110609: LD_INT 20
110611: PUSH
110612: LD_INT 21
110614: PUSH
110615: LD_INT 22
110617: PUSH
110618: LD_INT 23
110620: PUSH
110621: LD_INT 24
110623: PUSH
110624: LD_INT 25
110626: PUSH
110627: LD_INT 26
110629: PUSH
110630: LD_INT 27
110632: PUSH
110633: LD_INT 28
110635: PUSH
110636: LD_INT 29
110638: PUSH
110639: LD_INT 30
110641: PUSH
110642: LD_INT 31
110644: PUSH
110645: LD_INT 32
110647: PUSH
110648: LD_INT 33
110650: PUSH
110651: LD_INT 34
110653: PUSH
110654: LD_INT 36
110656: PUSH
110657: EMPTY
110658: LIST
110659: LIST
110660: LIST
110661: LIST
110662: LIST
110663: LIST
110664: LIST
110665: LIST
110666: LIST
110667: LIST
110668: LIST
110669: LIST
110670: LIST
110671: LIST
110672: LIST
110673: LIST
110674: LIST
110675: LIST
110676: LIST
110677: LIST
110678: LIST
110679: LIST
110680: LIST
110681: LIST
110682: LIST
110683: LIST
110684: LIST
110685: LIST
110686: LIST
110687: LIST
110688: LIST
110689: LIST
110690: LIST
110691: LIST
110692: LIST
110693: PUSH
110694: LD_INT 101
110696: PUSH
110697: LD_INT 102
110699: PUSH
110700: LD_INT 103
110702: PUSH
110703: LD_INT 104
110705: PUSH
110706: LD_INT 105
110708: PUSH
110709: LD_INT 106
110711: PUSH
110712: LD_INT 107
110714: PUSH
110715: LD_INT 108
110717: PUSH
110718: LD_INT 109
110720: PUSH
110721: LD_INT 110
110723: PUSH
110724: LD_INT 111
110726: PUSH
110727: LD_INT 112
110729: PUSH
110730: LD_INT 113
110732: PUSH
110733: LD_INT 114
110735: PUSH
110736: EMPTY
110737: LIST
110738: LIST
110739: LIST
110740: LIST
110741: LIST
110742: LIST
110743: LIST
110744: LIST
110745: LIST
110746: LIST
110747: LIST
110748: LIST
110749: LIST
110750: LIST
110751: PUSH
110752: EMPTY
110753: LIST
110754: LIST
110755: ST_TO_ADDR
110756: GO 111483
110758: LD_INT 16
110760: DOUBLE
110761: EQUAL
110762: IFTRUE 110766
110764: GO 110890
110766: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
110767: LD_ADDR_VAR 0 1
110771: PUSH
110772: LD_INT 2
110774: PUSH
110775: LD_INT 4
110777: PUSH
110778: LD_INT 5
110780: PUSH
110781: LD_INT 7
110783: PUSH
110784: LD_INT 11
110786: PUSH
110787: LD_INT 12
110789: PUSH
110790: LD_INT 15
110792: PUSH
110793: LD_INT 16
110795: PUSH
110796: LD_INT 20
110798: PUSH
110799: LD_INT 21
110801: PUSH
110802: LD_INT 22
110804: PUSH
110805: LD_INT 23
110807: PUSH
110808: LD_INT 25
110810: PUSH
110811: LD_INT 26
110813: PUSH
110814: LD_INT 30
110816: PUSH
110817: LD_INT 31
110819: PUSH
110820: LD_INT 32
110822: PUSH
110823: LD_INT 33
110825: PUSH
110826: LD_INT 34
110828: PUSH
110829: EMPTY
110830: LIST
110831: LIST
110832: LIST
110833: LIST
110834: LIST
110835: LIST
110836: LIST
110837: LIST
110838: LIST
110839: LIST
110840: LIST
110841: LIST
110842: LIST
110843: LIST
110844: LIST
110845: LIST
110846: LIST
110847: LIST
110848: LIST
110849: PUSH
110850: LD_INT 101
110852: PUSH
110853: LD_INT 102
110855: PUSH
110856: LD_INT 103
110858: PUSH
110859: LD_INT 106
110861: PUSH
110862: LD_INT 108
110864: PUSH
110865: LD_INT 112
110867: PUSH
110868: LD_INT 113
110870: PUSH
110871: LD_INT 114
110873: PUSH
110874: EMPTY
110875: LIST
110876: LIST
110877: LIST
110878: LIST
110879: LIST
110880: LIST
110881: LIST
110882: LIST
110883: PUSH
110884: EMPTY
110885: LIST
110886: LIST
110887: ST_TO_ADDR
110888: GO 111483
110890: LD_INT 17
110892: DOUBLE
110893: EQUAL
110894: IFTRUE 110898
110896: GO 111110
110898: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
110899: LD_ADDR_VAR 0 1
110903: PUSH
110904: LD_INT 1
110906: PUSH
110907: LD_INT 2
110909: PUSH
110910: LD_INT 3
110912: PUSH
110913: LD_INT 4
110915: PUSH
110916: LD_INT 5
110918: PUSH
110919: LD_INT 6
110921: PUSH
110922: LD_INT 7
110924: PUSH
110925: LD_INT 8
110927: PUSH
110928: LD_INT 9
110930: PUSH
110931: LD_INT 10
110933: PUSH
110934: LD_INT 11
110936: PUSH
110937: LD_INT 12
110939: PUSH
110940: LD_INT 13
110942: PUSH
110943: LD_INT 14
110945: PUSH
110946: LD_INT 15
110948: PUSH
110949: LD_INT 16
110951: PUSH
110952: LD_INT 17
110954: PUSH
110955: LD_INT 18
110957: PUSH
110958: LD_INT 19
110960: PUSH
110961: LD_INT 20
110963: PUSH
110964: LD_INT 21
110966: PUSH
110967: LD_INT 22
110969: PUSH
110970: LD_INT 23
110972: PUSH
110973: LD_INT 24
110975: PUSH
110976: LD_INT 25
110978: PUSH
110979: LD_INT 26
110981: PUSH
110982: LD_INT 27
110984: PUSH
110985: LD_INT 28
110987: PUSH
110988: LD_INT 29
110990: PUSH
110991: LD_INT 30
110993: PUSH
110994: LD_INT 31
110996: PUSH
110997: LD_INT 32
110999: PUSH
111000: LD_INT 33
111002: PUSH
111003: LD_INT 34
111005: PUSH
111006: LD_INT 36
111008: PUSH
111009: EMPTY
111010: LIST
111011: LIST
111012: LIST
111013: LIST
111014: LIST
111015: LIST
111016: LIST
111017: LIST
111018: LIST
111019: LIST
111020: LIST
111021: LIST
111022: LIST
111023: LIST
111024: LIST
111025: LIST
111026: LIST
111027: LIST
111028: LIST
111029: LIST
111030: LIST
111031: LIST
111032: LIST
111033: LIST
111034: LIST
111035: LIST
111036: LIST
111037: LIST
111038: LIST
111039: LIST
111040: LIST
111041: LIST
111042: LIST
111043: LIST
111044: LIST
111045: PUSH
111046: LD_INT 101
111048: PUSH
111049: LD_INT 102
111051: PUSH
111052: LD_INT 103
111054: PUSH
111055: LD_INT 104
111057: PUSH
111058: LD_INT 105
111060: PUSH
111061: LD_INT 106
111063: PUSH
111064: LD_INT 107
111066: PUSH
111067: LD_INT 108
111069: PUSH
111070: LD_INT 109
111072: PUSH
111073: LD_INT 110
111075: PUSH
111076: LD_INT 111
111078: PUSH
111079: LD_INT 112
111081: PUSH
111082: LD_INT 113
111084: PUSH
111085: LD_INT 114
111087: PUSH
111088: EMPTY
111089: LIST
111090: LIST
111091: LIST
111092: LIST
111093: LIST
111094: LIST
111095: LIST
111096: LIST
111097: LIST
111098: LIST
111099: LIST
111100: LIST
111101: LIST
111102: LIST
111103: PUSH
111104: EMPTY
111105: LIST
111106: LIST
111107: ST_TO_ADDR
111108: GO 111483
111110: LD_INT 18
111112: DOUBLE
111113: EQUAL
111114: IFTRUE 111118
111116: GO 111254
111118: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
111119: LD_ADDR_VAR 0 1
111123: PUSH
111124: LD_INT 2
111126: PUSH
111127: LD_INT 4
111129: PUSH
111130: LD_INT 5
111132: PUSH
111133: LD_INT 7
111135: PUSH
111136: LD_INT 11
111138: PUSH
111139: LD_INT 12
111141: PUSH
111142: LD_INT 15
111144: PUSH
111145: LD_INT 16
111147: PUSH
111148: LD_INT 20
111150: PUSH
111151: LD_INT 21
111153: PUSH
111154: LD_INT 22
111156: PUSH
111157: LD_INT 23
111159: PUSH
111160: LD_INT 25
111162: PUSH
111163: LD_INT 26
111165: PUSH
111166: LD_INT 30
111168: PUSH
111169: LD_INT 31
111171: PUSH
111172: LD_INT 32
111174: PUSH
111175: LD_INT 33
111177: PUSH
111178: LD_INT 34
111180: PUSH
111181: LD_INT 35
111183: PUSH
111184: LD_INT 36
111186: PUSH
111187: EMPTY
111188: LIST
111189: LIST
111190: LIST
111191: LIST
111192: LIST
111193: LIST
111194: LIST
111195: LIST
111196: LIST
111197: LIST
111198: LIST
111199: LIST
111200: LIST
111201: LIST
111202: LIST
111203: LIST
111204: LIST
111205: LIST
111206: LIST
111207: LIST
111208: LIST
111209: PUSH
111210: LD_INT 101
111212: PUSH
111213: LD_INT 102
111215: PUSH
111216: LD_INT 103
111218: PUSH
111219: LD_INT 106
111221: PUSH
111222: LD_INT 108
111224: PUSH
111225: LD_INT 112
111227: PUSH
111228: LD_INT 113
111230: PUSH
111231: LD_INT 114
111233: PUSH
111234: LD_INT 115
111236: PUSH
111237: EMPTY
111238: LIST
111239: LIST
111240: LIST
111241: LIST
111242: LIST
111243: LIST
111244: LIST
111245: LIST
111246: LIST
111247: PUSH
111248: EMPTY
111249: LIST
111250: LIST
111251: ST_TO_ADDR
111252: GO 111483
111254: LD_INT 19
111256: DOUBLE
111257: EQUAL
111258: IFTRUE 111262
111260: GO 111482
111262: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
111263: LD_ADDR_VAR 0 1
111267: PUSH
111268: LD_INT 1
111270: PUSH
111271: LD_INT 2
111273: PUSH
111274: LD_INT 3
111276: PUSH
111277: LD_INT 4
111279: PUSH
111280: LD_INT 5
111282: PUSH
111283: LD_INT 6
111285: PUSH
111286: LD_INT 7
111288: PUSH
111289: LD_INT 8
111291: PUSH
111292: LD_INT 9
111294: PUSH
111295: LD_INT 10
111297: PUSH
111298: LD_INT 11
111300: PUSH
111301: LD_INT 12
111303: PUSH
111304: LD_INT 13
111306: PUSH
111307: LD_INT 14
111309: PUSH
111310: LD_INT 15
111312: PUSH
111313: LD_INT 16
111315: PUSH
111316: LD_INT 17
111318: PUSH
111319: LD_INT 18
111321: PUSH
111322: LD_INT 19
111324: PUSH
111325: LD_INT 20
111327: PUSH
111328: LD_INT 21
111330: PUSH
111331: LD_INT 22
111333: PUSH
111334: LD_INT 23
111336: PUSH
111337: LD_INT 24
111339: PUSH
111340: LD_INT 25
111342: PUSH
111343: LD_INT 26
111345: PUSH
111346: LD_INT 27
111348: PUSH
111349: LD_INT 28
111351: PUSH
111352: LD_INT 29
111354: PUSH
111355: LD_INT 30
111357: PUSH
111358: LD_INT 31
111360: PUSH
111361: LD_INT 32
111363: PUSH
111364: LD_INT 33
111366: PUSH
111367: LD_INT 34
111369: PUSH
111370: LD_INT 35
111372: PUSH
111373: LD_INT 36
111375: PUSH
111376: EMPTY
111377: LIST
111378: LIST
111379: LIST
111380: LIST
111381: LIST
111382: LIST
111383: LIST
111384: LIST
111385: LIST
111386: LIST
111387: LIST
111388: LIST
111389: LIST
111390: LIST
111391: LIST
111392: LIST
111393: LIST
111394: LIST
111395: LIST
111396: LIST
111397: LIST
111398: LIST
111399: LIST
111400: LIST
111401: LIST
111402: LIST
111403: LIST
111404: LIST
111405: LIST
111406: LIST
111407: LIST
111408: LIST
111409: LIST
111410: LIST
111411: LIST
111412: LIST
111413: PUSH
111414: LD_INT 101
111416: PUSH
111417: LD_INT 102
111419: PUSH
111420: LD_INT 103
111422: PUSH
111423: LD_INT 104
111425: PUSH
111426: LD_INT 105
111428: PUSH
111429: LD_INT 106
111431: PUSH
111432: LD_INT 107
111434: PUSH
111435: LD_INT 108
111437: PUSH
111438: LD_INT 109
111440: PUSH
111441: LD_INT 110
111443: PUSH
111444: LD_INT 111
111446: PUSH
111447: LD_INT 112
111449: PUSH
111450: LD_INT 113
111452: PUSH
111453: LD_INT 114
111455: PUSH
111456: LD_INT 115
111458: PUSH
111459: EMPTY
111460: LIST
111461: LIST
111462: LIST
111463: LIST
111464: LIST
111465: LIST
111466: LIST
111467: LIST
111468: LIST
111469: LIST
111470: LIST
111471: LIST
111472: LIST
111473: LIST
111474: LIST
111475: PUSH
111476: EMPTY
111477: LIST
111478: LIST
111479: ST_TO_ADDR
111480: GO 111483
111482: POP
// end else
111483: GO 111520
// if campaign_id = 5 then
111485: LD_OWVAR 69
111489: PUSH
111490: LD_INT 5
111492: EQUAL
111493: IFFALSE 111520
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
111495: LD_ADDR_VAR 0 1
111499: PUSH
111500: LD_INT 1
111502: PUSH
111503: LD_INT 2
111505: PUSH
111506: EMPTY
111507: LIST
111508: LIST
111509: PUSH
111510: LD_INT 100
111512: PUSH
111513: EMPTY
111514: LIST
111515: PUSH
111516: EMPTY
111517: LIST
111518: LIST
111519: ST_TO_ADDR
// end ; if result then
111520: LD_VAR 0 1
111524: IFFALSE 111813
// begin normal :=  ;
111526: LD_ADDR_VAR 0 3
111530: PUSH
111531: LD_STRING 
111533: ST_TO_ADDR
// hardcore :=  ;
111534: LD_ADDR_VAR 0 4
111538: PUSH
111539: LD_STRING 
111541: ST_TO_ADDR
// for i = 1 to normalCounter do
111542: LD_ADDR_VAR 0 5
111546: PUSH
111547: DOUBLE
111548: LD_INT 1
111550: DEC
111551: ST_TO_ADDR
111552: LD_EXP 146
111556: PUSH
111557: FOR_TO
111558: IFFALSE 111659
// begin tmp := 0 ;
111560: LD_ADDR_VAR 0 2
111564: PUSH
111565: LD_STRING 0
111567: ST_TO_ADDR
// if result [ 1 ] then
111568: LD_VAR 0 1
111572: PUSH
111573: LD_INT 1
111575: ARRAY
111576: IFFALSE 111641
// if result [ 1 ] [ 1 ] = i then
111578: LD_VAR 0 1
111582: PUSH
111583: LD_INT 1
111585: ARRAY
111586: PUSH
111587: LD_INT 1
111589: ARRAY
111590: PUSH
111591: LD_VAR 0 5
111595: EQUAL
111596: IFFALSE 111641
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
111598: LD_ADDR_VAR 0 1
111602: PUSH
111603: LD_VAR 0 1
111607: PPUSH
111608: LD_INT 1
111610: PPUSH
111611: LD_VAR 0 1
111615: PUSH
111616: LD_INT 1
111618: ARRAY
111619: PPUSH
111620: LD_INT 1
111622: PPUSH
111623: CALL_OW 3
111627: PPUSH
111628: CALL_OW 1
111632: ST_TO_ADDR
// tmp := 1 ;
111633: LD_ADDR_VAR 0 2
111637: PUSH
111638: LD_STRING 1
111640: ST_TO_ADDR
// end ; normal := normal & tmp ;
111641: LD_ADDR_VAR 0 3
111645: PUSH
111646: LD_VAR 0 3
111650: PUSH
111651: LD_VAR 0 2
111655: STR
111656: ST_TO_ADDR
// end ;
111657: GO 111557
111659: POP
111660: POP
// for i = 1 to hardcoreCounter do
111661: LD_ADDR_VAR 0 5
111665: PUSH
111666: DOUBLE
111667: LD_INT 1
111669: DEC
111670: ST_TO_ADDR
111671: LD_EXP 147
111675: PUSH
111676: FOR_TO
111677: IFFALSE 111782
// begin tmp := 0 ;
111679: LD_ADDR_VAR 0 2
111683: PUSH
111684: LD_STRING 0
111686: ST_TO_ADDR
// if result [ 2 ] then
111687: LD_VAR 0 1
111691: PUSH
111692: LD_INT 2
111694: ARRAY
111695: IFFALSE 111764
// if result [ 2 ] [ 1 ] = 100 + i then
111697: LD_VAR 0 1
111701: PUSH
111702: LD_INT 2
111704: ARRAY
111705: PUSH
111706: LD_INT 1
111708: ARRAY
111709: PUSH
111710: LD_INT 100
111712: PUSH
111713: LD_VAR 0 5
111717: PLUS
111718: EQUAL
111719: IFFALSE 111764
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
111721: LD_ADDR_VAR 0 1
111725: PUSH
111726: LD_VAR 0 1
111730: PPUSH
111731: LD_INT 2
111733: PPUSH
111734: LD_VAR 0 1
111738: PUSH
111739: LD_INT 2
111741: ARRAY
111742: PPUSH
111743: LD_INT 1
111745: PPUSH
111746: CALL_OW 3
111750: PPUSH
111751: CALL_OW 1
111755: ST_TO_ADDR
// tmp := 1 ;
111756: LD_ADDR_VAR 0 2
111760: PUSH
111761: LD_STRING 1
111763: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
111764: LD_ADDR_VAR 0 4
111768: PUSH
111769: LD_VAR 0 4
111773: PUSH
111774: LD_VAR 0 2
111778: STR
111779: ST_TO_ADDR
// end ;
111780: GO 111676
111782: POP
111783: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
111784: LD_STRING getStreamItemsFromMission("
111786: PUSH
111787: LD_VAR 0 3
111791: STR
111792: PUSH
111793: LD_STRING ","
111795: STR
111796: PUSH
111797: LD_VAR 0 4
111801: STR
111802: PUSH
111803: LD_STRING ")
111805: STR
111806: PPUSH
111807: CALL_OW 559
// end else
111811: GO 111820
// ToLua ( getStreamItemsFromMission("","") ) ;
111813: LD_STRING getStreamItemsFromMission("","")
111815: PPUSH
111816: CALL_OW 559
// end ;
111820: LD_VAR 0 1
111824: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
111825: LD_VAR 0 2
111829: PUSH
111830: LD_INT 100
111832: EQUAL
111833: IFFALSE 112782
// begin if not StreamModeActive then
111835: LD_EXP 145
111839: NOT
111840: IFFALSE 111850
// StreamModeActive := true ;
111842: LD_ADDR_EXP 145
111846: PUSH
111847: LD_INT 1
111849: ST_TO_ADDR
// if p3 = 0 then
111850: LD_VAR 0 3
111854: PUSH
111855: LD_INT 0
111857: EQUAL
111858: IFFALSE 111864
// InitStreamMode ;
111860: CALL 108085 0 0
// if p3 = 1 then
111864: LD_VAR 0 3
111868: PUSH
111869: LD_INT 1
111871: EQUAL
111872: IFFALSE 111882
// sRocket := true ;
111874: LD_ADDR_EXP 150
111878: PUSH
111879: LD_INT 1
111881: ST_TO_ADDR
// if p3 = 2 then
111882: LD_VAR 0 3
111886: PUSH
111887: LD_INT 2
111889: EQUAL
111890: IFFALSE 111900
// sSpeed := true ;
111892: LD_ADDR_EXP 149
111896: PUSH
111897: LD_INT 1
111899: ST_TO_ADDR
// if p3 = 3 then
111900: LD_VAR 0 3
111904: PUSH
111905: LD_INT 3
111907: EQUAL
111908: IFFALSE 111918
// sEngine := true ;
111910: LD_ADDR_EXP 151
111914: PUSH
111915: LD_INT 1
111917: ST_TO_ADDR
// if p3 = 4 then
111918: LD_VAR 0 3
111922: PUSH
111923: LD_INT 4
111925: EQUAL
111926: IFFALSE 111936
// sSpec := true ;
111928: LD_ADDR_EXP 148
111932: PUSH
111933: LD_INT 1
111935: ST_TO_ADDR
// if p3 = 5 then
111936: LD_VAR 0 3
111940: PUSH
111941: LD_INT 5
111943: EQUAL
111944: IFFALSE 111954
// sLevel := true ;
111946: LD_ADDR_EXP 152
111950: PUSH
111951: LD_INT 1
111953: ST_TO_ADDR
// if p3 = 6 then
111954: LD_VAR 0 3
111958: PUSH
111959: LD_INT 6
111961: EQUAL
111962: IFFALSE 111972
// sArmoury := true ;
111964: LD_ADDR_EXP 153
111968: PUSH
111969: LD_INT 1
111971: ST_TO_ADDR
// if p3 = 7 then
111972: LD_VAR 0 3
111976: PUSH
111977: LD_INT 7
111979: EQUAL
111980: IFFALSE 111990
// sRadar := true ;
111982: LD_ADDR_EXP 154
111986: PUSH
111987: LD_INT 1
111989: ST_TO_ADDR
// if p3 = 8 then
111990: LD_VAR 0 3
111994: PUSH
111995: LD_INT 8
111997: EQUAL
111998: IFFALSE 112008
// sBunker := true ;
112000: LD_ADDR_EXP 155
112004: PUSH
112005: LD_INT 1
112007: ST_TO_ADDR
// if p3 = 9 then
112008: LD_VAR 0 3
112012: PUSH
112013: LD_INT 9
112015: EQUAL
112016: IFFALSE 112026
// sHack := true ;
112018: LD_ADDR_EXP 156
112022: PUSH
112023: LD_INT 1
112025: ST_TO_ADDR
// if p3 = 10 then
112026: LD_VAR 0 3
112030: PUSH
112031: LD_INT 10
112033: EQUAL
112034: IFFALSE 112044
// sFire := true ;
112036: LD_ADDR_EXP 157
112040: PUSH
112041: LD_INT 1
112043: ST_TO_ADDR
// if p3 = 11 then
112044: LD_VAR 0 3
112048: PUSH
112049: LD_INT 11
112051: EQUAL
112052: IFFALSE 112062
// sRefresh := true ;
112054: LD_ADDR_EXP 158
112058: PUSH
112059: LD_INT 1
112061: ST_TO_ADDR
// if p3 = 12 then
112062: LD_VAR 0 3
112066: PUSH
112067: LD_INT 12
112069: EQUAL
112070: IFFALSE 112080
// sExp := true ;
112072: LD_ADDR_EXP 159
112076: PUSH
112077: LD_INT 1
112079: ST_TO_ADDR
// if p3 = 13 then
112080: LD_VAR 0 3
112084: PUSH
112085: LD_INT 13
112087: EQUAL
112088: IFFALSE 112098
// sDepot := true ;
112090: LD_ADDR_EXP 160
112094: PUSH
112095: LD_INT 1
112097: ST_TO_ADDR
// if p3 = 14 then
112098: LD_VAR 0 3
112102: PUSH
112103: LD_INT 14
112105: EQUAL
112106: IFFALSE 112116
// sFlag := true ;
112108: LD_ADDR_EXP 161
112112: PUSH
112113: LD_INT 1
112115: ST_TO_ADDR
// if p3 = 15 then
112116: LD_VAR 0 3
112120: PUSH
112121: LD_INT 15
112123: EQUAL
112124: IFFALSE 112134
// sKamikadze := true ;
112126: LD_ADDR_EXP 169
112130: PUSH
112131: LD_INT 1
112133: ST_TO_ADDR
// if p3 = 16 then
112134: LD_VAR 0 3
112138: PUSH
112139: LD_INT 16
112141: EQUAL
112142: IFFALSE 112152
// sTroll := true ;
112144: LD_ADDR_EXP 170
112148: PUSH
112149: LD_INT 1
112151: ST_TO_ADDR
// if p3 = 17 then
112152: LD_VAR 0 3
112156: PUSH
112157: LD_INT 17
112159: EQUAL
112160: IFFALSE 112170
// sSlow := true ;
112162: LD_ADDR_EXP 171
112166: PUSH
112167: LD_INT 1
112169: ST_TO_ADDR
// if p3 = 18 then
112170: LD_VAR 0 3
112174: PUSH
112175: LD_INT 18
112177: EQUAL
112178: IFFALSE 112188
// sLack := true ;
112180: LD_ADDR_EXP 172
112184: PUSH
112185: LD_INT 1
112187: ST_TO_ADDR
// if p3 = 19 then
112188: LD_VAR 0 3
112192: PUSH
112193: LD_INT 19
112195: EQUAL
112196: IFFALSE 112206
// sTank := true ;
112198: LD_ADDR_EXP 174
112202: PUSH
112203: LD_INT 1
112205: ST_TO_ADDR
// if p3 = 20 then
112206: LD_VAR 0 3
112210: PUSH
112211: LD_INT 20
112213: EQUAL
112214: IFFALSE 112224
// sRemote := true ;
112216: LD_ADDR_EXP 175
112220: PUSH
112221: LD_INT 1
112223: ST_TO_ADDR
// if p3 = 21 then
112224: LD_VAR 0 3
112228: PUSH
112229: LD_INT 21
112231: EQUAL
112232: IFFALSE 112242
// sPowell := true ;
112234: LD_ADDR_EXP 176
112238: PUSH
112239: LD_INT 1
112241: ST_TO_ADDR
// if p3 = 22 then
112242: LD_VAR 0 3
112246: PUSH
112247: LD_INT 22
112249: EQUAL
112250: IFFALSE 112260
// sTeleport := true ;
112252: LD_ADDR_EXP 179
112256: PUSH
112257: LD_INT 1
112259: ST_TO_ADDR
// if p3 = 23 then
112260: LD_VAR 0 3
112264: PUSH
112265: LD_INT 23
112267: EQUAL
112268: IFFALSE 112278
// sOilTower := true ;
112270: LD_ADDR_EXP 181
112274: PUSH
112275: LD_INT 1
112277: ST_TO_ADDR
// if p3 = 24 then
112278: LD_VAR 0 3
112282: PUSH
112283: LD_INT 24
112285: EQUAL
112286: IFFALSE 112296
// sShovel := true ;
112288: LD_ADDR_EXP 182
112292: PUSH
112293: LD_INT 1
112295: ST_TO_ADDR
// if p3 = 25 then
112296: LD_VAR 0 3
112300: PUSH
112301: LD_INT 25
112303: EQUAL
112304: IFFALSE 112314
// sSheik := true ;
112306: LD_ADDR_EXP 183
112310: PUSH
112311: LD_INT 1
112313: ST_TO_ADDR
// if p3 = 26 then
112314: LD_VAR 0 3
112318: PUSH
112319: LD_INT 26
112321: EQUAL
112322: IFFALSE 112332
// sEarthquake := true ;
112324: LD_ADDR_EXP 185
112328: PUSH
112329: LD_INT 1
112331: ST_TO_ADDR
// if p3 = 27 then
112332: LD_VAR 0 3
112336: PUSH
112337: LD_INT 27
112339: EQUAL
112340: IFFALSE 112350
// sAI := true ;
112342: LD_ADDR_EXP 186
112346: PUSH
112347: LD_INT 1
112349: ST_TO_ADDR
// if p3 = 28 then
112350: LD_VAR 0 3
112354: PUSH
112355: LD_INT 28
112357: EQUAL
112358: IFFALSE 112368
// sCargo := true ;
112360: LD_ADDR_EXP 189
112364: PUSH
112365: LD_INT 1
112367: ST_TO_ADDR
// if p3 = 29 then
112368: LD_VAR 0 3
112372: PUSH
112373: LD_INT 29
112375: EQUAL
112376: IFFALSE 112386
// sDLaser := true ;
112378: LD_ADDR_EXP 190
112382: PUSH
112383: LD_INT 1
112385: ST_TO_ADDR
// if p3 = 30 then
112386: LD_VAR 0 3
112390: PUSH
112391: LD_INT 30
112393: EQUAL
112394: IFFALSE 112404
// sExchange := true ;
112396: LD_ADDR_EXP 191
112400: PUSH
112401: LD_INT 1
112403: ST_TO_ADDR
// if p3 = 31 then
112404: LD_VAR 0 3
112408: PUSH
112409: LD_INT 31
112411: EQUAL
112412: IFFALSE 112422
// sFac := true ;
112414: LD_ADDR_EXP 192
112418: PUSH
112419: LD_INT 1
112421: ST_TO_ADDR
// if p3 = 32 then
112422: LD_VAR 0 3
112426: PUSH
112427: LD_INT 32
112429: EQUAL
112430: IFFALSE 112440
// sPower := true ;
112432: LD_ADDR_EXP 193
112436: PUSH
112437: LD_INT 1
112439: ST_TO_ADDR
// if p3 = 33 then
112440: LD_VAR 0 3
112444: PUSH
112445: LD_INT 33
112447: EQUAL
112448: IFFALSE 112458
// sRandom := true ;
112450: LD_ADDR_EXP 194
112454: PUSH
112455: LD_INT 1
112457: ST_TO_ADDR
// if p3 = 34 then
112458: LD_VAR 0 3
112462: PUSH
112463: LD_INT 34
112465: EQUAL
112466: IFFALSE 112476
// sShield := true ;
112468: LD_ADDR_EXP 195
112472: PUSH
112473: LD_INT 1
112475: ST_TO_ADDR
// if p3 = 35 then
112476: LD_VAR 0 3
112480: PUSH
112481: LD_INT 35
112483: EQUAL
112484: IFFALSE 112494
// sTime := true ;
112486: LD_ADDR_EXP 196
112490: PUSH
112491: LD_INT 1
112493: ST_TO_ADDR
// if p3 = 36 then
112494: LD_VAR 0 3
112498: PUSH
112499: LD_INT 36
112501: EQUAL
112502: IFFALSE 112512
// sTools := true ;
112504: LD_ADDR_EXP 197
112508: PUSH
112509: LD_INT 1
112511: ST_TO_ADDR
// if p3 = 101 then
112512: LD_VAR 0 3
112516: PUSH
112517: LD_INT 101
112519: EQUAL
112520: IFFALSE 112530
// sSold := true ;
112522: LD_ADDR_EXP 162
112526: PUSH
112527: LD_INT 1
112529: ST_TO_ADDR
// if p3 = 102 then
112530: LD_VAR 0 3
112534: PUSH
112535: LD_INT 102
112537: EQUAL
112538: IFFALSE 112548
// sDiff := true ;
112540: LD_ADDR_EXP 163
112544: PUSH
112545: LD_INT 1
112547: ST_TO_ADDR
// if p3 = 103 then
112548: LD_VAR 0 3
112552: PUSH
112553: LD_INT 103
112555: EQUAL
112556: IFFALSE 112566
// sFog := true ;
112558: LD_ADDR_EXP 166
112562: PUSH
112563: LD_INT 1
112565: ST_TO_ADDR
// if p3 = 104 then
112566: LD_VAR 0 3
112570: PUSH
112571: LD_INT 104
112573: EQUAL
112574: IFFALSE 112584
// sReset := true ;
112576: LD_ADDR_EXP 167
112580: PUSH
112581: LD_INT 1
112583: ST_TO_ADDR
// if p3 = 105 then
112584: LD_VAR 0 3
112588: PUSH
112589: LD_INT 105
112591: EQUAL
112592: IFFALSE 112602
// sSun := true ;
112594: LD_ADDR_EXP 168
112598: PUSH
112599: LD_INT 1
112601: ST_TO_ADDR
// if p3 = 106 then
112602: LD_VAR 0 3
112606: PUSH
112607: LD_INT 106
112609: EQUAL
112610: IFFALSE 112620
// sTiger := true ;
112612: LD_ADDR_EXP 164
112616: PUSH
112617: LD_INT 1
112619: ST_TO_ADDR
// if p3 = 107 then
112620: LD_VAR 0 3
112624: PUSH
112625: LD_INT 107
112627: EQUAL
112628: IFFALSE 112638
// sBomb := true ;
112630: LD_ADDR_EXP 165
112634: PUSH
112635: LD_INT 1
112637: ST_TO_ADDR
// if p3 = 108 then
112638: LD_VAR 0 3
112642: PUSH
112643: LD_INT 108
112645: EQUAL
112646: IFFALSE 112656
// sWound := true ;
112648: LD_ADDR_EXP 173
112652: PUSH
112653: LD_INT 1
112655: ST_TO_ADDR
// if p3 = 109 then
112656: LD_VAR 0 3
112660: PUSH
112661: LD_INT 109
112663: EQUAL
112664: IFFALSE 112674
// sBetray := true ;
112666: LD_ADDR_EXP 177
112670: PUSH
112671: LD_INT 1
112673: ST_TO_ADDR
// if p3 = 110 then
112674: LD_VAR 0 3
112678: PUSH
112679: LD_INT 110
112681: EQUAL
112682: IFFALSE 112692
// sContamin := true ;
112684: LD_ADDR_EXP 178
112688: PUSH
112689: LD_INT 1
112691: ST_TO_ADDR
// if p3 = 111 then
112692: LD_VAR 0 3
112696: PUSH
112697: LD_INT 111
112699: EQUAL
112700: IFFALSE 112710
// sOil := true ;
112702: LD_ADDR_EXP 180
112706: PUSH
112707: LD_INT 1
112709: ST_TO_ADDR
// if p3 = 112 then
112710: LD_VAR 0 3
112714: PUSH
112715: LD_INT 112
112717: EQUAL
112718: IFFALSE 112728
// sStu := true ;
112720: LD_ADDR_EXP 184
112724: PUSH
112725: LD_INT 1
112727: ST_TO_ADDR
// if p3 = 113 then
112728: LD_VAR 0 3
112732: PUSH
112733: LD_INT 113
112735: EQUAL
112736: IFFALSE 112746
// sBazooka := true ;
112738: LD_ADDR_EXP 187
112742: PUSH
112743: LD_INT 1
112745: ST_TO_ADDR
// if p3 = 114 then
112746: LD_VAR 0 3
112750: PUSH
112751: LD_INT 114
112753: EQUAL
112754: IFFALSE 112764
// sMortar := true ;
112756: LD_ADDR_EXP 188
112760: PUSH
112761: LD_INT 1
112763: ST_TO_ADDR
// if p3 = 115 then
112764: LD_VAR 0 3
112768: PUSH
112769: LD_INT 115
112771: EQUAL
112772: IFFALSE 112782
// sRanger := true ;
112774: LD_ADDR_EXP 198
112778: PUSH
112779: LD_INT 1
112781: ST_TO_ADDR
// end ; end ;
112782: PPOPN 6
112784: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
112785: LD_EXP 145
112789: PUSH
112790: LD_EXP 150
112794: AND
112795: IFFALSE 112919
112797: GO 112799
112799: DISABLE
112800: LD_INT 0
112802: PPUSH
112803: PPUSH
// begin enable ;
112804: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
112805: LD_ADDR_VAR 0 2
112809: PUSH
112810: LD_INT 22
112812: PUSH
112813: LD_OWVAR 2
112817: PUSH
112818: EMPTY
112819: LIST
112820: LIST
112821: PUSH
112822: LD_INT 2
112824: PUSH
112825: LD_INT 34
112827: PUSH
112828: LD_INT 7
112830: PUSH
112831: EMPTY
112832: LIST
112833: LIST
112834: PUSH
112835: LD_INT 34
112837: PUSH
112838: LD_INT 45
112840: PUSH
112841: EMPTY
112842: LIST
112843: LIST
112844: PUSH
112845: LD_INT 34
112847: PUSH
112848: LD_INT 28
112850: PUSH
112851: EMPTY
112852: LIST
112853: LIST
112854: PUSH
112855: LD_INT 34
112857: PUSH
112858: LD_INT 47
112860: PUSH
112861: EMPTY
112862: LIST
112863: LIST
112864: PUSH
112865: EMPTY
112866: LIST
112867: LIST
112868: LIST
112869: LIST
112870: LIST
112871: PUSH
112872: EMPTY
112873: LIST
112874: LIST
112875: PPUSH
112876: CALL_OW 69
112880: ST_TO_ADDR
// if not tmp then
112881: LD_VAR 0 2
112885: NOT
112886: IFFALSE 112890
// exit ;
112888: GO 112919
// for i in tmp do
112890: LD_ADDR_VAR 0 1
112894: PUSH
112895: LD_VAR 0 2
112899: PUSH
112900: FOR_IN
112901: IFFALSE 112917
// begin SetLives ( i , 0 ) ;
112903: LD_VAR 0 1
112907: PPUSH
112908: LD_INT 0
112910: PPUSH
112911: CALL_OW 234
// end ;
112915: GO 112900
112917: POP
112918: POP
// end ;
112919: PPOPN 2
112921: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
112922: LD_EXP 145
112926: PUSH
112927: LD_EXP 151
112931: AND
112932: IFFALSE 113016
112934: GO 112936
112936: DISABLE
112937: LD_INT 0
112939: PPUSH
112940: PPUSH
// begin enable ;
112941: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
112942: LD_ADDR_VAR 0 2
112946: PUSH
112947: LD_INT 22
112949: PUSH
112950: LD_OWVAR 2
112954: PUSH
112955: EMPTY
112956: LIST
112957: LIST
112958: PUSH
112959: LD_INT 32
112961: PUSH
112962: LD_INT 3
112964: PUSH
112965: EMPTY
112966: LIST
112967: LIST
112968: PUSH
112969: EMPTY
112970: LIST
112971: LIST
112972: PPUSH
112973: CALL_OW 69
112977: ST_TO_ADDR
// if not tmp then
112978: LD_VAR 0 2
112982: NOT
112983: IFFALSE 112987
// exit ;
112985: GO 113016
// for i in tmp do
112987: LD_ADDR_VAR 0 1
112991: PUSH
112992: LD_VAR 0 2
112996: PUSH
112997: FOR_IN
112998: IFFALSE 113014
// begin SetLives ( i , 0 ) ;
113000: LD_VAR 0 1
113004: PPUSH
113005: LD_INT 0
113007: PPUSH
113008: CALL_OW 234
// end ;
113012: GO 112997
113014: POP
113015: POP
// end ;
113016: PPOPN 2
113018: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
113019: LD_EXP 145
113023: PUSH
113024: LD_EXP 148
113028: AND
113029: IFFALSE 113122
113031: GO 113033
113033: DISABLE
113034: LD_INT 0
113036: PPUSH
// begin enable ;
113037: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
113038: LD_ADDR_VAR 0 1
113042: PUSH
113043: LD_INT 22
113045: PUSH
113046: LD_OWVAR 2
113050: PUSH
113051: EMPTY
113052: LIST
113053: LIST
113054: PUSH
113055: LD_INT 2
113057: PUSH
113058: LD_INT 25
113060: PUSH
113061: LD_INT 5
113063: PUSH
113064: EMPTY
113065: LIST
113066: LIST
113067: PUSH
113068: LD_INT 25
113070: PUSH
113071: LD_INT 9
113073: PUSH
113074: EMPTY
113075: LIST
113076: LIST
113077: PUSH
113078: LD_INT 25
113080: PUSH
113081: LD_INT 8
113083: PUSH
113084: EMPTY
113085: LIST
113086: LIST
113087: PUSH
113088: EMPTY
113089: LIST
113090: LIST
113091: LIST
113092: LIST
113093: PUSH
113094: EMPTY
113095: LIST
113096: LIST
113097: PPUSH
113098: CALL_OW 69
113102: PUSH
113103: FOR_IN
113104: IFFALSE 113120
// begin SetClass ( i , 1 ) ;
113106: LD_VAR 0 1
113110: PPUSH
113111: LD_INT 1
113113: PPUSH
113114: CALL_OW 336
// end ;
113118: GO 113103
113120: POP
113121: POP
// end ;
113122: PPOPN 1
113124: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
113125: LD_EXP 145
113129: PUSH
113130: LD_EXP 149
113134: AND
113135: PUSH
113136: LD_OWVAR 65
113140: PUSH
113141: LD_INT 7
113143: LESS
113144: AND
113145: IFFALSE 113159
113147: GO 113149
113149: DISABLE
// begin enable ;
113150: ENABLE
// game_speed := 7 ;
113151: LD_ADDR_OWVAR 65
113155: PUSH
113156: LD_INT 7
113158: ST_TO_ADDR
// end ;
113159: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
113160: LD_EXP 145
113164: PUSH
113165: LD_EXP 152
113169: AND
113170: IFFALSE 113372
113172: GO 113174
113174: DISABLE
113175: LD_INT 0
113177: PPUSH
113178: PPUSH
113179: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
113180: LD_ADDR_VAR 0 3
113184: PUSH
113185: LD_INT 81
113187: PUSH
113188: LD_OWVAR 2
113192: PUSH
113193: EMPTY
113194: LIST
113195: LIST
113196: PUSH
113197: LD_INT 21
113199: PUSH
113200: LD_INT 1
113202: PUSH
113203: EMPTY
113204: LIST
113205: LIST
113206: PUSH
113207: EMPTY
113208: LIST
113209: LIST
113210: PPUSH
113211: CALL_OW 69
113215: ST_TO_ADDR
// if not tmp then
113216: LD_VAR 0 3
113220: NOT
113221: IFFALSE 113225
// exit ;
113223: GO 113372
// if tmp > 5 then
113225: LD_VAR 0 3
113229: PUSH
113230: LD_INT 5
113232: GREATER
113233: IFFALSE 113245
// k := 5 else
113235: LD_ADDR_VAR 0 2
113239: PUSH
113240: LD_INT 5
113242: ST_TO_ADDR
113243: GO 113255
// k := tmp ;
113245: LD_ADDR_VAR 0 2
113249: PUSH
113250: LD_VAR 0 3
113254: ST_TO_ADDR
// for i := 1 to k do
113255: LD_ADDR_VAR 0 1
113259: PUSH
113260: DOUBLE
113261: LD_INT 1
113263: DEC
113264: ST_TO_ADDR
113265: LD_VAR 0 2
113269: PUSH
113270: FOR_TO
113271: IFFALSE 113370
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
113273: LD_VAR 0 3
113277: PUSH
113278: LD_VAR 0 1
113282: ARRAY
113283: PPUSH
113284: LD_VAR 0 1
113288: PUSH
113289: LD_INT 4
113291: MOD
113292: PUSH
113293: LD_INT 1
113295: PLUS
113296: PPUSH
113297: CALL_OW 259
113301: PUSH
113302: LD_INT 10
113304: LESS
113305: IFFALSE 113368
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
113307: LD_VAR 0 3
113311: PUSH
113312: LD_VAR 0 1
113316: ARRAY
113317: PPUSH
113318: LD_VAR 0 1
113322: PUSH
113323: LD_INT 4
113325: MOD
113326: PUSH
113327: LD_INT 1
113329: PLUS
113330: PPUSH
113331: LD_VAR 0 3
113335: PUSH
113336: LD_VAR 0 1
113340: ARRAY
113341: PPUSH
113342: LD_VAR 0 1
113346: PUSH
113347: LD_INT 4
113349: MOD
113350: PUSH
113351: LD_INT 1
113353: PLUS
113354: PPUSH
113355: CALL_OW 259
113359: PUSH
113360: LD_INT 1
113362: PLUS
113363: PPUSH
113364: CALL_OW 237
113368: GO 113270
113370: POP
113371: POP
// end ;
113372: PPOPN 3
113374: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
113375: LD_EXP 145
113379: PUSH
113380: LD_EXP 153
113384: AND
113385: IFFALSE 113405
113387: GO 113389
113389: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
113390: LD_INT 4
113392: PPUSH
113393: LD_OWVAR 2
113397: PPUSH
113398: LD_INT 0
113400: PPUSH
113401: CALL_OW 324
113405: END
// every 0 0$1 trigger StreamModeActive and sShovel do
113406: LD_EXP 145
113410: PUSH
113411: LD_EXP 182
113415: AND
113416: IFFALSE 113436
113418: GO 113420
113420: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
113421: LD_INT 19
113423: PPUSH
113424: LD_OWVAR 2
113428: PPUSH
113429: LD_INT 0
113431: PPUSH
113432: CALL_OW 324
113436: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
113437: LD_EXP 145
113441: PUSH
113442: LD_EXP 154
113446: AND
113447: IFFALSE 113549
113449: GO 113451
113451: DISABLE
113452: LD_INT 0
113454: PPUSH
113455: PPUSH
// begin enable ;
113456: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
113457: LD_ADDR_VAR 0 2
113461: PUSH
113462: LD_INT 22
113464: PUSH
113465: LD_OWVAR 2
113469: PUSH
113470: EMPTY
113471: LIST
113472: LIST
113473: PUSH
113474: LD_INT 2
113476: PUSH
113477: LD_INT 34
113479: PUSH
113480: LD_INT 11
113482: PUSH
113483: EMPTY
113484: LIST
113485: LIST
113486: PUSH
113487: LD_INT 34
113489: PUSH
113490: LD_INT 30
113492: PUSH
113493: EMPTY
113494: LIST
113495: LIST
113496: PUSH
113497: EMPTY
113498: LIST
113499: LIST
113500: LIST
113501: PUSH
113502: EMPTY
113503: LIST
113504: LIST
113505: PPUSH
113506: CALL_OW 69
113510: ST_TO_ADDR
// if not tmp then
113511: LD_VAR 0 2
113515: NOT
113516: IFFALSE 113520
// exit ;
113518: GO 113549
// for i in tmp do
113520: LD_ADDR_VAR 0 1
113524: PUSH
113525: LD_VAR 0 2
113529: PUSH
113530: FOR_IN
113531: IFFALSE 113547
// begin SetLives ( i , 0 ) ;
113533: LD_VAR 0 1
113537: PPUSH
113538: LD_INT 0
113540: PPUSH
113541: CALL_OW 234
// end ;
113545: GO 113530
113547: POP
113548: POP
// end ;
113549: PPOPN 2
113551: END
// every 0 0$1 trigger StreamModeActive and sBunker do
113552: LD_EXP 145
113556: PUSH
113557: LD_EXP 155
113561: AND
113562: IFFALSE 113582
113564: GO 113566
113566: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
113567: LD_INT 32
113569: PPUSH
113570: LD_OWVAR 2
113574: PPUSH
113575: LD_INT 0
113577: PPUSH
113578: CALL_OW 324
113582: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
113583: LD_EXP 145
113587: PUSH
113588: LD_EXP 156
113592: AND
113593: IFFALSE 113774
113595: GO 113597
113597: DISABLE
113598: LD_INT 0
113600: PPUSH
113601: PPUSH
113602: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
113603: LD_ADDR_VAR 0 2
113607: PUSH
113608: LD_INT 22
113610: PUSH
113611: LD_OWVAR 2
113615: PUSH
113616: EMPTY
113617: LIST
113618: LIST
113619: PUSH
113620: LD_INT 33
113622: PUSH
113623: LD_INT 3
113625: PUSH
113626: EMPTY
113627: LIST
113628: LIST
113629: PUSH
113630: EMPTY
113631: LIST
113632: LIST
113633: PPUSH
113634: CALL_OW 69
113638: ST_TO_ADDR
// if not tmp then
113639: LD_VAR 0 2
113643: NOT
113644: IFFALSE 113648
// exit ;
113646: GO 113774
// side := 0 ;
113648: LD_ADDR_VAR 0 3
113652: PUSH
113653: LD_INT 0
113655: ST_TO_ADDR
// for i := 1 to 8 do
113656: LD_ADDR_VAR 0 1
113660: PUSH
113661: DOUBLE
113662: LD_INT 1
113664: DEC
113665: ST_TO_ADDR
113666: LD_INT 8
113668: PUSH
113669: FOR_TO
113670: IFFALSE 113718
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
113672: LD_OWVAR 2
113676: PUSH
113677: LD_VAR 0 1
113681: NONEQUAL
113682: PUSH
113683: LD_OWVAR 2
113687: PPUSH
113688: LD_VAR 0 1
113692: PPUSH
113693: CALL_OW 81
113697: PUSH
113698: LD_INT 2
113700: EQUAL
113701: AND
113702: IFFALSE 113716
// begin side := i ;
113704: LD_ADDR_VAR 0 3
113708: PUSH
113709: LD_VAR 0 1
113713: ST_TO_ADDR
// break ;
113714: GO 113718
// end ;
113716: GO 113669
113718: POP
113719: POP
// if not side then
113720: LD_VAR 0 3
113724: NOT
113725: IFFALSE 113729
// exit ;
113727: GO 113774
// for i := 1 to tmp do
113729: LD_ADDR_VAR 0 1
113733: PUSH
113734: DOUBLE
113735: LD_INT 1
113737: DEC
113738: ST_TO_ADDR
113739: LD_VAR 0 2
113743: PUSH
113744: FOR_TO
113745: IFFALSE 113772
// if Prob ( 60 ) then
113747: LD_INT 60
113749: PPUSH
113750: CALL_OW 13
113754: IFFALSE 113770
// SetSide ( i , side ) ;
113756: LD_VAR 0 1
113760: PPUSH
113761: LD_VAR 0 3
113765: PPUSH
113766: CALL_OW 235
113770: GO 113744
113772: POP
113773: POP
// end ;
113774: PPOPN 3
113776: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
113777: LD_EXP 145
113781: PUSH
113782: LD_EXP 158
113786: AND
113787: IFFALSE 113906
113789: GO 113791
113791: DISABLE
113792: LD_INT 0
113794: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
113795: LD_ADDR_VAR 0 1
113799: PUSH
113800: LD_INT 22
113802: PUSH
113803: LD_OWVAR 2
113807: PUSH
113808: EMPTY
113809: LIST
113810: LIST
113811: PUSH
113812: LD_INT 21
113814: PUSH
113815: LD_INT 1
113817: PUSH
113818: EMPTY
113819: LIST
113820: LIST
113821: PUSH
113822: LD_INT 3
113824: PUSH
113825: LD_INT 23
113827: PUSH
113828: LD_INT 0
113830: PUSH
113831: EMPTY
113832: LIST
113833: LIST
113834: PUSH
113835: EMPTY
113836: LIST
113837: LIST
113838: PUSH
113839: EMPTY
113840: LIST
113841: LIST
113842: LIST
113843: PPUSH
113844: CALL_OW 69
113848: PUSH
113849: FOR_IN
113850: IFFALSE 113904
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
113852: LD_VAR 0 1
113856: PPUSH
113857: CALL_OW 257
113861: PUSH
113862: LD_INT 1
113864: PUSH
113865: LD_INT 2
113867: PUSH
113868: LD_INT 3
113870: PUSH
113871: LD_INT 4
113873: PUSH
113874: EMPTY
113875: LIST
113876: LIST
113877: LIST
113878: LIST
113879: IN
113880: IFFALSE 113902
// SetClass ( un , rand ( 1 , 4 ) ) ;
113882: LD_VAR 0 1
113886: PPUSH
113887: LD_INT 1
113889: PPUSH
113890: LD_INT 4
113892: PPUSH
113893: CALL_OW 12
113897: PPUSH
113898: CALL_OW 336
113902: GO 113849
113904: POP
113905: POP
// end ;
113906: PPOPN 1
113908: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
113909: LD_EXP 145
113913: PUSH
113914: LD_EXP 157
113918: AND
113919: IFFALSE 113998
113921: GO 113923
113923: DISABLE
113924: LD_INT 0
113926: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
113927: LD_ADDR_VAR 0 1
113931: PUSH
113932: LD_INT 22
113934: PUSH
113935: LD_OWVAR 2
113939: PUSH
113940: EMPTY
113941: LIST
113942: LIST
113943: PUSH
113944: LD_INT 21
113946: PUSH
113947: LD_INT 3
113949: PUSH
113950: EMPTY
113951: LIST
113952: LIST
113953: PUSH
113954: EMPTY
113955: LIST
113956: LIST
113957: PPUSH
113958: CALL_OW 69
113962: ST_TO_ADDR
// if not tmp then
113963: LD_VAR 0 1
113967: NOT
113968: IFFALSE 113972
// exit ;
113970: GO 113998
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
113972: LD_VAR 0 1
113976: PUSH
113977: LD_INT 1
113979: PPUSH
113980: LD_VAR 0 1
113984: PPUSH
113985: CALL_OW 12
113989: ARRAY
113990: PPUSH
113991: LD_INT 100
113993: PPUSH
113994: CALL_OW 234
// end ;
113998: PPOPN 1
114000: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
114001: LD_EXP 145
114005: PUSH
114006: LD_EXP 159
114010: AND
114011: IFFALSE 114109
114013: GO 114015
114015: DISABLE
114016: LD_INT 0
114018: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
114019: LD_ADDR_VAR 0 1
114023: PUSH
114024: LD_INT 22
114026: PUSH
114027: LD_OWVAR 2
114031: PUSH
114032: EMPTY
114033: LIST
114034: LIST
114035: PUSH
114036: LD_INT 21
114038: PUSH
114039: LD_INT 1
114041: PUSH
114042: EMPTY
114043: LIST
114044: LIST
114045: PUSH
114046: EMPTY
114047: LIST
114048: LIST
114049: PPUSH
114050: CALL_OW 69
114054: ST_TO_ADDR
// if not tmp then
114055: LD_VAR 0 1
114059: NOT
114060: IFFALSE 114064
// exit ;
114062: GO 114109
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
114064: LD_VAR 0 1
114068: PUSH
114069: LD_INT 1
114071: PPUSH
114072: LD_VAR 0 1
114076: PPUSH
114077: CALL_OW 12
114081: ARRAY
114082: PPUSH
114083: LD_INT 1
114085: PPUSH
114086: LD_INT 4
114088: PPUSH
114089: CALL_OW 12
114093: PPUSH
114094: LD_INT 3000
114096: PPUSH
114097: LD_INT 9000
114099: PPUSH
114100: CALL_OW 12
114104: PPUSH
114105: CALL_OW 492
// end ;
114109: PPOPN 1
114111: END
// every 0 0$1 trigger StreamModeActive and sDepot do
114112: LD_EXP 145
114116: PUSH
114117: LD_EXP 160
114121: AND
114122: IFFALSE 114142
114124: GO 114126
114126: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
114127: LD_INT 1
114129: PPUSH
114130: LD_OWVAR 2
114134: PPUSH
114135: LD_INT 0
114137: PPUSH
114138: CALL_OW 324
114142: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
114143: LD_EXP 145
114147: PUSH
114148: LD_EXP 161
114152: AND
114153: IFFALSE 114236
114155: GO 114157
114157: DISABLE
114158: LD_INT 0
114160: PPUSH
114161: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
114162: LD_ADDR_VAR 0 2
114166: PUSH
114167: LD_INT 22
114169: PUSH
114170: LD_OWVAR 2
114174: PUSH
114175: EMPTY
114176: LIST
114177: LIST
114178: PUSH
114179: LD_INT 21
114181: PUSH
114182: LD_INT 3
114184: PUSH
114185: EMPTY
114186: LIST
114187: LIST
114188: PUSH
114189: EMPTY
114190: LIST
114191: LIST
114192: PPUSH
114193: CALL_OW 69
114197: ST_TO_ADDR
// if not tmp then
114198: LD_VAR 0 2
114202: NOT
114203: IFFALSE 114207
// exit ;
114205: GO 114236
// for i in tmp do
114207: LD_ADDR_VAR 0 1
114211: PUSH
114212: LD_VAR 0 2
114216: PUSH
114217: FOR_IN
114218: IFFALSE 114234
// SetBLevel ( i , 10 ) ;
114220: LD_VAR 0 1
114224: PPUSH
114225: LD_INT 10
114227: PPUSH
114228: CALL_OW 241
114232: GO 114217
114234: POP
114235: POP
// end ;
114236: PPOPN 2
114238: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
114239: LD_EXP 145
114243: PUSH
114244: LD_EXP 162
114248: AND
114249: IFFALSE 114360
114251: GO 114253
114253: DISABLE
114254: LD_INT 0
114256: PPUSH
114257: PPUSH
114258: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
114259: LD_ADDR_VAR 0 3
114263: PUSH
114264: LD_INT 22
114266: PUSH
114267: LD_OWVAR 2
114271: PUSH
114272: EMPTY
114273: LIST
114274: LIST
114275: PUSH
114276: LD_INT 25
114278: PUSH
114279: LD_INT 1
114281: PUSH
114282: EMPTY
114283: LIST
114284: LIST
114285: PUSH
114286: EMPTY
114287: LIST
114288: LIST
114289: PPUSH
114290: CALL_OW 69
114294: ST_TO_ADDR
// if not tmp then
114295: LD_VAR 0 3
114299: NOT
114300: IFFALSE 114304
// exit ;
114302: GO 114360
// un := tmp [ rand ( 1 , tmp ) ] ;
114304: LD_ADDR_VAR 0 2
114308: PUSH
114309: LD_VAR 0 3
114313: PUSH
114314: LD_INT 1
114316: PPUSH
114317: LD_VAR 0 3
114321: PPUSH
114322: CALL_OW 12
114326: ARRAY
114327: ST_TO_ADDR
// if Crawls ( un ) then
114328: LD_VAR 0 2
114332: PPUSH
114333: CALL_OW 318
114337: IFFALSE 114348
// ComWalk ( un ) ;
114339: LD_VAR 0 2
114343: PPUSH
114344: CALL_OW 138
// SetClass ( un , class_sniper ) ;
114348: LD_VAR 0 2
114352: PPUSH
114353: LD_INT 5
114355: PPUSH
114356: CALL_OW 336
// end ;
114360: PPOPN 3
114362: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
114363: LD_EXP 145
114367: PUSH
114368: LD_EXP 163
114372: AND
114373: PUSH
114374: LD_OWVAR 67
114378: PUSH
114379: LD_INT 3
114381: LESS
114382: AND
114383: IFFALSE 114402
114385: GO 114387
114387: DISABLE
// Difficulty := Difficulty + 1 ;
114388: LD_ADDR_OWVAR 67
114392: PUSH
114393: LD_OWVAR 67
114397: PUSH
114398: LD_INT 1
114400: PLUS
114401: ST_TO_ADDR
114402: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
114403: LD_EXP 145
114407: PUSH
114408: LD_EXP 164
114412: AND
114413: IFFALSE 114516
114415: GO 114417
114417: DISABLE
114418: LD_INT 0
114420: PPUSH
// begin for i := 1 to 5 do
114421: LD_ADDR_VAR 0 1
114425: PUSH
114426: DOUBLE
114427: LD_INT 1
114429: DEC
114430: ST_TO_ADDR
114431: LD_INT 5
114433: PUSH
114434: FOR_TO
114435: IFFALSE 114514
// begin uc_nation := nation_nature ;
114437: LD_ADDR_OWVAR 21
114441: PUSH
114442: LD_INT 0
114444: ST_TO_ADDR
// uc_side := 0 ;
114445: LD_ADDR_OWVAR 20
114449: PUSH
114450: LD_INT 0
114452: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
114453: LD_ADDR_OWVAR 29
114457: PUSH
114458: LD_INT 12
114460: PUSH
114461: LD_INT 12
114463: PUSH
114464: EMPTY
114465: LIST
114466: LIST
114467: ST_TO_ADDR
// hc_agressivity := 20 ;
114468: LD_ADDR_OWVAR 35
114472: PUSH
114473: LD_INT 20
114475: ST_TO_ADDR
// hc_class := class_tiger ;
114476: LD_ADDR_OWVAR 28
114480: PUSH
114481: LD_INT 14
114483: ST_TO_ADDR
// hc_gallery :=  ;
114484: LD_ADDR_OWVAR 33
114488: PUSH
114489: LD_STRING 
114491: ST_TO_ADDR
// hc_name :=  ;
114492: LD_ADDR_OWVAR 26
114496: PUSH
114497: LD_STRING 
114499: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
114500: CALL_OW 44
114504: PPUSH
114505: LD_INT 0
114507: PPUSH
114508: CALL_OW 51
// end ;
114512: GO 114434
114514: POP
114515: POP
// end ;
114516: PPOPN 1
114518: END
// every 0 0$1 trigger StreamModeActive and sBomb do
114519: LD_EXP 145
114523: PUSH
114524: LD_EXP 165
114528: AND
114529: IFFALSE 114538
114531: GO 114533
114533: DISABLE
// StreamSibBomb ;
114534: CALL 114539 0 0
114538: END
// export function StreamSibBomb ; var i , x , y ; begin
114539: LD_INT 0
114541: PPUSH
114542: PPUSH
114543: PPUSH
114544: PPUSH
// result := false ;
114545: LD_ADDR_VAR 0 1
114549: PUSH
114550: LD_INT 0
114552: ST_TO_ADDR
// for i := 1 to 16 do
114553: LD_ADDR_VAR 0 2
114557: PUSH
114558: DOUBLE
114559: LD_INT 1
114561: DEC
114562: ST_TO_ADDR
114563: LD_INT 16
114565: PUSH
114566: FOR_TO
114567: IFFALSE 114766
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
114569: LD_ADDR_VAR 0 3
114573: PUSH
114574: LD_INT 10
114576: PUSH
114577: LD_INT 20
114579: PUSH
114580: LD_INT 30
114582: PUSH
114583: LD_INT 40
114585: PUSH
114586: LD_INT 50
114588: PUSH
114589: LD_INT 60
114591: PUSH
114592: LD_INT 70
114594: PUSH
114595: LD_INT 80
114597: PUSH
114598: LD_INT 90
114600: PUSH
114601: LD_INT 100
114603: PUSH
114604: LD_INT 110
114606: PUSH
114607: LD_INT 120
114609: PUSH
114610: LD_INT 130
114612: PUSH
114613: LD_INT 140
114615: PUSH
114616: LD_INT 150
114618: PUSH
114619: EMPTY
114620: LIST
114621: LIST
114622: LIST
114623: LIST
114624: LIST
114625: LIST
114626: LIST
114627: LIST
114628: LIST
114629: LIST
114630: LIST
114631: LIST
114632: LIST
114633: LIST
114634: LIST
114635: PUSH
114636: LD_INT 1
114638: PPUSH
114639: LD_INT 15
114641: PPUSH
114642: CALL_OW 12
114646: ARRAY
114647: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
114648: LD_ADDR_VAR 0 4
114652: PUSH
114653: LD_INT 10
114655: PUSH
114656: LD_INT 20
114658: PUSH
114659: LD_INT 30
114661: PUSH
114662: LD_INT 40
114664: PUSH
114665: LD_INT 50
114667: PUSH
114668: LD_INT 60
114670: PUSH
114671: LD_INT 70
114673: PUSH
114674: LD_INT 80
114676: PUSH
114677: LD_INT 90
114679: PUSH
114680: LD_INT 100
114682: PUSH
114683: LD_INT 110
114685: PUSH
114686: LD_INT 120
114688: PUSH
114689: LD_INT 130
114691: PUSH
114692: LD_INT 140
114694: PUSH
114695: LD_INT 150
114697: PUSH
114698: EMPTY
114699: LIST
114700: LIST
114701: LIST
114702: LIST
114703: LIST
114704: LIST
114705: LIST
114706: LIST
114707: LIST
114708: LIST
114709: LIST
114710: LIST
114711: LIST
114712: LIST
114713: LIST
114714: PUSH
114715: LD_INT 1
114717: PPUSH
114718: LD_INT 15
114720: PPUSH
114721: CALL_OW 12
114725: ARRAY
114726: ST_TO_ADDR
// if ValidHex ( x , y ) then
114727: LD_VAR 0 3
114731: PPUSH
114732: LD_VAR 0 4
114736: PPUSH
114737: CALL_OW 488
114741: IFFALSE 114764
// begin result := [ x , y ] ;
114743: LD_ADDR_VAR 0 1
114747: PUSH
114748: LD_VAR 0 3
114752: PUSH
114753: LD_VAR 0 4
114757: PUSH
114758: EMPTY
114759: LIST
114760: LIST
114761: ST_TO_ADDR
// break ;
114762: GO 114766
// end ; end ;
114764: GO 114566
114766: POP
114767: POP
// if result then
114768: LD_VAR 0 1
114772: IFFALSE 114832
// begin ToLua ( playSibBomb() ) ;
114774: LD_STRING playSibBomb()
114776: PPUSH
114777: CALL_OW 559
// wait ( 0 0$14 ) ;
114781: LD_INT 490
114783: PPUSH
114784: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
114788: LD_VAR 0 1
114792: PUSH
114793: LD_INT 1
114795: ARRAY
114796: PPUSH
114797: LD_VAR 0 1
114801: PUSH
114802: LD_INT 2
114804: ARRAY
114805: PPUSH
114806: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
114810: LD_VAR 0 1
114814: PUSH
114815: LD_INT 1
114817: ARRAY
114818: PPUSH
114819: LD_VAR 0 1
114823: PUSH
114824: LD_INT 2
114826: ARRAY
114827: PPUSH
114828: CALL_OW 429
// end ; end ;
114832: LD_VAR 0 1
114836: RET
// every 0 0$1 trigger StreamModeActive and sReset do
114837: LD_EXP 145
114841: PUSH
114842: LD_EXP 167
114846: AND
114847: IFFALSE 114859
114849: GO 114851
114851: DISABLE
// YouLost (  ) ;
114852: LD_STRING 
114854: PPUSH
114855: CALL_OW 104
114859: END
// every 0 0$1 trigger StreamModeActive and sFog do
114860: LD_EXP 145
114864: PUSH
114865: LD_EXP 166
114869: AND
114870: IFFALSE 114884
114872: GO 114874
114874: DISABLE
// FogOff ( your_side ) ;
114875: LD_OWVAR 2
114879: PPUSH
114880: CALL_OW 344
114884: END
// every 0 0$1 trigger StreamModeActive and sSun do
114885: LD_EXP 145
114889: PUSH
114890: LD_EXP 168
114894: AND
114895: IFFALSE 114923
114897: GO 114899
114899: DISABLE
// begin solar_recharge_percent := 0 ;
114900: LD_ADDR_OWVAR 79
114904: PUSH
114905: LD_INT 0
114907: ST_TO_ADDR
// wait ( 5 5$00 ) ;
114908: LD_INT 10500
114910: PPUSH
114911: CALL_OW 67
// solar_recharge_percent := 100 ;
114915: LD_ADDR_OWVAR 79
114919: PUSH
114920: LD_INT 100
114922: ST_TO_ADDR
// end ;
114923: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
114924: LD_EXP 145
114928: PUSH
114929: LD_EXP 169
114933: AND
114934: IFFALSE 115173
114936: GO 114938
114938: DISABLE
114939: LD_INT 0
114941: PPUSH
114942: PPUSH
114943: PPUSH
// begin tmp := [ ] ;
114944: LD_ADDR_VAR 0 3
114948: PUSH
114949: EMPTY
114950: ST_TO_ADDR
// for i := 1 to 6 do
114951: LD_ADDR_VAR 0 1
114955: PUSH
114956: DOUBLE
114957: LD_INT 1
114959: DEC
114960: ST_TO_ADDR
114961: LD_INT 6
114963: PUSH
114964: FOR_TO
114965: IFFALSE 115070
// begin uc_nation := nation_nature ;
114967: LD_ADDR_OWVAR 21
114971: PUSH
114972: LD_INT 0
114974: ST_TO_ADDR
// uc_side := 0 ;
114975: LD_ADDR_OWVAR 20
114979: PUSH
114980: LD_INT 0
114982: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
114983: LD_ADDR_OWVAR 29
114987: PUSH
114988: LD_INT 12
114990: PUSH
114991: LD_INT 12
114993: PUSH
114994: EMPTY
114995: LIST
114996: LIST
114997: ST_TO_ADDR
// hc_agressivity := 20 ;
114998: LD_ADDR_OWVAR 35
115002: PUSH
115003: LD_INT 20
115005: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
115006: LD_ADDR_OWVAR 28
115010: PUSH
115011: LD_INT 17
115013: ST_TO_ADDR
// hc_gallery :=  ;
115014: LD_ADDR_OWVAR 33
115018: PUSH
115019: LD_STRING 
115021: ST_TO_ADDR
// hc_name :=  ;
115022: LD_ADDR_OWVAR 26
115026: PUSH
115027: LD_STRING 
115029: ST_TO_ADDR
// un := CreateHuman ;
115030: LD_ADDR_VAR 0 2
115034: PUSH
115035: CALL_OW 44
115039: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
115040: LD_VAR 0 2
115044: PPUSH
115045: LD_INT 1
115047: PPUSH
115048: CALL_OW 51
// tmp := tmp ^ un ;
115052: LD_ADDR_VAR 0 3
115056: PUSH
115057: LD_VAR 0 3
115061: PUSH
115062: LD_VAR 0 2
115066: ADD
115067: ST_TO_ADDR
// end ;
115068: GO 114964
115070: POP
115071: POP
// repeat wait ( 0 0$1 ) ;
115072: LD_INT 35
115074: PPUSH
115075: CALL_OW 67
// for un in tmp do
115079: LD_ADDR_VAR 0 2
115083: PUSH
115084: LD_VAR 0 3
115088: PUSH
115089: FOR_IN
115090: IFFALSE 115164
// begin if IsDead ( un ) then
115092: LD_VAR 0 2
115096: PPUSH
115097: CALL_OW 301
115101: IFFALSE 115121
// begin tmp := tmp diff un ;
115103: LD_ADDR_VAR 0 3
115107: PUSH
115108: LD_VAR 0 3
115112: PUSH
115113: LD_VAR 0 2
115117: DIFF
115118: ST_TO_ADDR
// continue ;
115119: GO 115089
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
115121: LD_VAR 0 2
115125: PPUSH
115126: LD_INT 3
115128: PUSH
115129: LD_INT 22
115131: PUSH
115132: LD_INT 0
115134: PUSH
115135: EMPTY
115136: LIST
115137: LIST
115138: PUSH
115139: EMPTY
115140: LIST
115141: LIST
115142: PPUSH
115143: CALL_OW 69
115147: PPUSH
115148: LD_VAR 0 2
115152: PPUSH
115153: CALL_OW 74
115157: PPUSH
115158: CALL_OW 115
// end ;
115162: GO 115089
115164: POP
115165: POP
// until not tmp ;
115166: LD_VAR 0 3
115170: NOT
115171: IFFALSE 115072
// end ;
115173: PPOPN 3
115175: END
// every 0 0$1 trigger StreamModeActive and sTroll do
115176: LD_EXP 145
115180: PUSH
115181: LD_EXP 170
115185: AND
115186: IFFALSE 115240
115188: GO 115190
115190: DISABLE
// begin ToLua ( displayTroll(); ) ;
115191: LD_STRING displayTroll();
115193: PPUSH
115194: CALL_OW 559
// wait ( 3 3$00 ) ;
115198: LD_INT 6300
115200: PPUSH
115201: CALL_OW 67
// ToLua ( hideTroll(); ) ;
115205: LD_STRING hideTroll();
115207: PPUSH
115208: CALL_OW 559
// wait ( 1 1$00 ) ;
115212: LD_INT 2100
115214: PPUSH
115215: CALL_OW 67
// ToLua ( displayTroll(); ) ;
115219: LD_STRING displayTroll();
115221: PPUSH
115222: CALL_OW 559
// wait ( 1 1$00 ) ;
115226: LD_INT 2100
115228: PPUSH
115229: CALL_OW 67
// ToLua ( hideTroll(); ) ;
115233: LD_STRING hideTroll();
115235: PPUSH
115236: CALL_OW 559
// end ;
115240: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
115241: LD_EXP 145
115245: PUSH
115246: LD_EXP 171
115250: AND
115251: IFFALSE 115314
115253: GO 115255
115255: DISABLE
115256: LD_INT 0
115258: PPUSH
// begin p := 0 ;
115259: LD_ADDR_VAR 0 1
115263: PUSH
115264: LD_INT 0
115266: ST_TO_ADDR
// repeat game_speed := 1 ;
115267: LD_ADDR_OWVAR 65
115271: PUSH
115272: LD_INT 1
115274: ST_TO_ADDR
// wait ( 0 0$1 ) ;
115275: LD_INT 35
115277: PPUSH
115278: CALL_OW 67
// p := p + 1 ;
115282: LD_ADDR_VAR 0 1
115286: PUSH
115287: LD_VAR 0 1
115291: PUSH
115292: LD_INT 1
115294: PLUS
115295: ST_TO_ADDR
// until p >= 60 ;
115296: LD_VAR 0 1
115300: PUSH
115301: LD_INT 60
115303: GREATEREQUAL
115304: IFFALSE 115267
// game_speed := 4 ;
115306: LD_ADDR_OWVAR 65
115310: PUSH
115311: LD_INT 4
115313: ST_TO_ADDR
// end ;
115314: PPOPN 1
115316: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
115317: LD_EXP 145
115321: PUSH
115322: LD_EXP 172
115326: AND
115327: IFFALSE 115473
115329: GO 115331
115331: DISABLE
115332: LD_INT 0
115334: PPUSH
115335: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
115336: LD_ADDR_VAR 0 1
115340: PUSH
115341: LD_INT 22
115343: PUSH
115344: LD_OWVAR 2
115348: PUSH
115349: EMPTY
115350: LIST
115351: LIST
115352: PUSH
115353: LD_INT 2
115355: PUSH
115356: LD_INT 30
115358: PUSH
115359: LD_INT 0
115361: PUSH
115362: EMPTY
115363: LIST
115364: LIST
115365: PUSH
115366: LD_INT 30
115368: PUSH
115369: LD_INT 1
115371: PUSH
115372: EMPTY
115373: LIST
115374: LIST
115375: PUSH
115376: EMPTY
115377: LIST
115378: LIST
115379: LIST
115380: PUSH
115381: EMPTY
115382: LIST
115383: LIST
115384: PPUSH
115385: CALL_OW 69
115389: ST_TO_ADDR
// if not depot then
115390: LD_VAR 0 1
115394: NOT
115395: IFFALSE 115399
// exit ;
115397: GO 115473
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
115399: LD_ADDR_VAR 0 2
115403: PUSH
115404: LD_VAR 0 1
115408: PUSH
115409: LD_INT 1
115411: PPUSH
115412: LD_VAR 0 1
115416: PPUSH
115417: CALL_OW 12
115421: ARRAY
115422: PPUSH
115423: CALL_OW 274
115427: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
115428: LD_VAR 0 2
115432: PPUSH
115433: LD_INT 1
115435: PPUSH
115436: LD_INT 0
115438: PPUSH
115439: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
115443: LD_VAR 0 2
115447: PPUSH
115448: LD_INT 2
115450: PPUSH
115451: LD_INT 0
115453: PPUSH
115454: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
115458: LD_VAR 0 2
115462: PPUSH
115463: LD_INT 3
115465: PPUSH
115466: LD_INT 0
115468: PPUSH
115469: CALL_OW 277
// end ;
115473: PPOPN 2
115475: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
115476: LD_EXP 145
115480: PUSH
115481: LD_EXP 173
115485: AND
115486: IFFALSE 115583
115488: GO 115490
115490: DISABLE
115491: LD_INT 0
115493: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
115494: LD_ADDR_VAR 0 1
115498: PUSH
115499: LD_INT 22
115501: PUSH
115502: LD_OWVAR 2
115506: PUSH
115507: EMPTY
115508: LIST
115509: LIST
115510: PUSH
115511: LD_INT 21
115513: PUSH
115514: LD_INT 1
115516: PUSH
115517: EMPTY
115518: LIST
115519: LIST
115520: PUSH
115521: LD_INT 3
115523: PUSH
115524: LD_INT 23
115526: PUSH
115527: LD_INT 0
115529: PUSH
115530: EMPTY
115531: LIST
115532: LIST
115533: PUSH
115534: EMPTY
115535: LIST
115536: LIST
115537: PUSH
115538: EMPTY
115539: LIST
115540: LIST
115541: LIST
115542: PPUSH
115543: CALL_OW 69
115547: ST_TO_ADDR
// if not tmp then
115548: LD_VAR 0 1
115552: NOT
115553: IFFALSE 115557
// exit ;
115555: GO 115583
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
115557: LD_VAR 0 1
115561: PUSH
115562: LD_INT 1
115564: PPUSH
115565: LD_VAR 0 1
115569: PPUSH
115570: CALL_OW 12
115574: ARRAY
115575: PPUSH
115576: LD_INT 200
115578: PPUSH
115579: CALL_OW 234
// end ;
115583: PPOPN 1
115585: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
115586: LD_EXP 145
115590: PUSH
115591: LD_EXP 174
115595: AND
115596: IFFALSE 115675
115598: GO 115600
115600: DISABLE
115601: LD_INT 0
115603: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
115604: LD_ADDR_VAR 0 1
115608: PUSH
115609: LD_INT 22
115611: PUSH
115612: LD_OWVAR 2
115616: PUSH
115617: EMPTY
115618: LIST
115619: LIST
115620: PUSH
115621: LD_INT 21
115623: PUSH
115624: LD_INT 2
115626: PUSH
115627: EMPTY
115628: LIST
115629: LIST
115630: PUSH
115631: EMPTY
115632: LIST
115633: LIST
115634: PPUSH
115635: CALL_OW 69
115639: ST_TO_ADDR
// if not tmp then
115640: LD_VAR 0 1
115644: NOT
115645: IFFALSE 115649
// exit ;
115647: GO 115675
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
115649: LD_VAR 0 1
115653: PUSH
115654: LD_INT 1
115656: PPUSH
115657: LD_VAR 0 1
115661: PPUSH
115662: CALL_OW 12
115666: ARRAY
115667: PPUSH
115668: LD_INT 60
115670: PPUSH
115671: CALL_OW 234
// end ;
115675: PPOPN 1
115677: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
115678: LD_EXP 145
115682: PUSH
115683: LD_EXP 175
115687: AND
115688: IFFALSE 115787
115690: GO 115692
115692: DISABLE
115693: LD_INT 0
115695: PPUSH
115696: PPUSH
// begin enable ;
115697: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
115698: LD_ADDR_VAR 0 1
115702: PUSH
115703: LD_INT 22
115705: PUSH
115706: LD_OWVAR 2
115710: PUSH
115711: EMPTY
115712: LIST
115713: LIST
115714: PUSH
115715: LD_INT 61
115717: PUSH
115718: EMPTY
115719: LIST
115720: PUSH
115721: LD_INT 33
115723: PUSH
115724: LD_INT 2
115726: PUSH
115727: EMPTY
115728: LIST
115729: LIST
115730: PUSH
115731: EMPTY
115732: LIST
115733: LIST
115734: LIST
115735: PPUSH
115736: CALL_OW 69
115740: ST_TO_ADDR
// if not tmp then
115741: LD_VAR 0 1
115745: NOT
115746: IFFALSE 115750
// exit ;
115748: GO 115787
// for i in tmp do
115750: LD_ADDR_VAR 0 2
115754: PUSH
115755: LD_VAR 0 1
115759: PUSH
115760: FOR_IN
115761: IFFALSE 115785
// if IsControledBy ( i ) then
115763: LD_VAR 0 2
115767: PPUSH
115768: CALL_OW 312
115772: IFFALSE 115783
// ComUnlink ( i ) ;
115774: LD_VAR 0 2
115778: PPUSH
115779: CALL_OW 136
115783: GO 115760
115785: POP
115786: POP
// end ;
115787: PPOPN 2
115789: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
115790: LD_EXP 145
115794: PUSH
115795: LD_EXP 176
115799: AND
115800: IFFALSE 115940
115802: GO 115804
115804: DISABLE
115805: LD_INT 0
115807: PPUSH
115808: PPUSH
// begin ToLua ( displayPowell(); ) ;
115809: LD_STRING displayPowell();
115811: PPUSH
115812: CALL_OW 559
// uc_side := 0 ;
115816: LD_ADDR_OWVAR 20
115820: PUSH
115821: LD_INT 0
115823: ST_TO_ADDR
// uc_nation := 2 ;
115824: LD_ADDR_OWVAR 21
115828: PUSH
115829: LD_INT 2
115831: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
115832: LD_ADDR_OWVAR 37
115836: PUSH
115837: LD_INT 14
115839: ST_TO_ADDR
// vc_engine := engine_siberite ;
115840: LD_ADDR_OWVAR 39
115844: PUSH
115845: LD_INT 3
115847: ST_TO_ADDR
// vc_control := control_apeman ;
115848: LD_ADDR_OWVAR 38
115852: PUSH
115853: LD_INT 5
115855: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
115856: LD_ADDR_OWVAR 40
115860: PUSH
115861: LD_INT 29
115863: ST_TO_ADDR
// un := CreateVehicle ;
115864: LD_ADDR_VAR 0 2
115868: PUSH
115869: CALL_OW 45
115873: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
115874: LD_VAR 0 2
115878: PPUSH
115879: LD_INT 1
115881: PPUSH
115882: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
115886: LD_INT 35
115888: PPUSH
115889: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
115893: LD_VAR 0 2
115897: PPUSH
115898: LD_INT 22
115900: PUSH
115901: LD_OWVAR 2
115905: PUSH
115906: EMPTY
115907: LIST
115908: LIST
115909: PPUSH
115910: CALL_OW 69
115914: PPUSH
115915: LD_VAR 0 2
115919: PPUSH
115920: CALL_OW 74
115924: PPUSH
115925: CALL_OW 115
// until IsDead ( un ) ;
115929: LD_VAR 0 2
115933: PPUSH
115934: CALL_OW 301
115938: IFFALSE 115886
// end ;
115940: PPOPN 2
115942: END
// every 0 0$1 trigger StreamModeActive and sStu do
115943: LD_EXP 145
115947: PUSH
115948: LD_EXP 184
115952: AND
115953: IFFALSE 115969
115955: GO 115957
115957: DISABLE
// begin ToLua ( displayStucuk(); ) ;
115958: LD_STRING displayStucuk();
115960: PPUSH
115961: CALL_OW 559
// ResetFog ;
115965: CALL_OW 335
// end ;
115969: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
115970: LD_EXP 145
115974: PUSH
115975: LD_EXP 177
115979: AND
115980: IFFALSE 116121
115982: GO 115984
115984: DISABLE
115985: LD_INT 0
115987: PPUSH
115988: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
115989: LD_ADDR_VAR 0 2
115993: PUSH
115994: LD_INT 22
115996: PUSH
115997: LD_OWVAR 2
116001: PUSH
116002: EMPTY
116003: LIST
116004: LIST
116005: PUSH
116006: LD_INT 21
116008: PUSH
116009: LD_INT 1
116011: PUSH
116012: EMPTY
116013: LIST
116014: LIST
116015: PUSH
116016: EMPTY
116017: LIST
116018: LIST
116019: PPUSH
116020: CALL_OW 69
116024: ST_TO_ADDR
// if not tmp then
116025: LD_VAR 0 2
116029: NOT
116030: IFFALSE 116034
// exit ;
116032: GO 116121
// un := tmp [ rand ( 1 , tmp ) ] ;
116034: LD_ADDR_VAR 0 1
116038: PUSH
116039: LD_VAR 0 2
116043: PUSH
116044: LD_INT 1
116046: PPUSH
116047: LD_VAR 0 2
116051: PPUSH
116052: CALL_OW 12
116056: ARRAY
116057: ST_TO_ADDR
// SetSide ( un , 0 ) ;
116058: LD_VAR 0 1
116062: PPUSH
116063: LD_INT 0
116065: PPUSH
116066: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
116070: LD_VAR 0 1
116074: PPUSH
116075: LD_OWVAR 3
116079: PUSH
116080: LD_VAR 0 1
116084: DIFF
116085: PPUSH
116086: LD_VAR 0 1
116090: PPUSH
116091: CALL_OW 74
116095: PPUSH
116096: CALL_OW 115
// wait ( 0 0$20 ) ;
116100: LD_INT 700
116102: PPUSH
116103: CALL_OW 67
// SetSide ( un , your_side ) ;
116107: LD_VAR 0 1
116111: PPUSH
116112: LD_OWVAR 2
116116: PPUSH
116117: CALL_OW 235
// end ;
116121: PPOPN 2
116123: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
116124: LD_EXP 145
116128: PUSH
116129: LD_EXP 178
116133: AND
116134: IFFALSE 116240
116136: GO 116138
116138: DISABLE
116139: LD_INT 0
116141: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
116142: LD_ADDR_VAR 0 1
116146: PUSH
116147: LD_INT 22
116149: PUSH
116150: LD_OWVAR 2
116154: PUSH
116155: EMPTY
116156: LIST
116157: LIST
116158: PUSH
116159: LD_INT 2
116161: PUSH
116162: LD_INT 30
116164: PUSH
116165: LD_INT 0
116167: PUSH
116168: EMPTY
116169: LIST
116170: LIST
116171: PUSH
116172: LD_INT 30
116174: PUSH
116175: LD_INT 1
116177: PUSH
116178: EMPTY
116179: LIST
116180: LIST
116181: PUSH
116182: EMPTY
116183: LIST
116184: LIST
116185: LIST
116186: PUSH
116187: EMPTY
116188: LIST
116189: LIST
116190: PPUSH
116191: CALL_OW 69
116195: ST_TO_ADDR
// if not depot then
116196: LD_VAR 0 1
116200: NOT
116201: IFFALSE 116205
// exit ;
116203: GO 116240
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
116205: LD_VAR 0 1
116209: PUSH
116210: LD_INT 1
116212: ARRAY
116213: PPUSH
116214: CALL_OW 250
116218: PPUSH
116219: LD_VAR 0 1
116223: PUSH
116224: LD_INT 1
116226: ARRAY
116227: PPUSH
116228: CALL_OW 251
116232: PPUSH
116233: LD_INT 70
116235: PPUSH
116236: CALL_OW 495
// end ;
116240: PPOPN 1
116242: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
116243: LD_EXP 145
116247: PUSH
116248: LD_EXP 179
116252: AND
116253: IFFALSE 116464
116255: GO 116257
116257: DISABLE
116258: LD_INT 0
116260: PPUSH
116261: PPUSH
116262: PPUSH
116263: PPUSH
116264: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
116265: LD_ADDR_VAR 0 5
116269: PUSH
116270: LD_INT 22
116272: PUSH
116273: LD_OWVAR 2
116277: PUSH
116278: EMPTY
116279: LIST
116280: LIST
116281: PUSH
116282: LD_INT 21
116284: PUSH
116285: LD_INT 1
116287: PUSH
116288: EMPTY
116289: LIST
116290: LIST
116291: PUSH
116292: EMPTY
116293: LIST
116294: LIST
116295: PPUSH
116296: CALL_OW 69
116300: ST_TO_ADDR
// if not tmp then
116301: LD_VAR 0 5
116305: NOT
116306: IFFALSE 116310
// exit ;
116308: GO 116464
// for i in tmp do
116310: LD_ADDR_VAR 0 1
116314: PUSH
116315: LD_VAR 0 5
116319: PUSH
116320: FOR_IN
116321: IFFALSE 116462
// begin d := rand ( 0 , 5 ) ;
116323: LD_ADDR_VAR 0 4
116327: PUSH
116328: LD_INT 0
116330: PPUSH
116331: LD_INT 5
116333: PPUSH
116334: CALL_OW 12
116338: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
116339: LD_ADDR_VAR 0 2
116343: PUSH
116344: LD_VAR 0 1
116348: PPUSH
116349: CALL_OW 250
116353: PPUSH
116354: LD_VAR 0 4
116358: PPUSH
116359: LD_INT 3
116361: PPUSH
116362: LD_INT 12
116364: PPUSH
116365: CALL_OW 12
116369: PPUSH
116370: CALL_OW 272
116374: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
116375: LD_ADDR_VAR 0 3
116379: PUSH
116380: LD_VAR 0 1
116384: PPUSH
116385: CALL_OW 251
116389: PPUSH
116390: LD_VAR 0 4
116394: PPUSH
116395: LD_INT 3
116397: PPUSH
116398: LD_INT 12
116400: PPUSH
116401: CALL_OW 12
116405: PPUSH
116406: CALL_OW 273
116410: ST_TO_ADDR
// if ValidHex ( x , y ) then
116411: LD_VAR 0 2
116415: PPUSH
116416: LD_VAR 0 3
116420: PPUSH
116421: CALL_OW 488
116425: IFFALSE 116460
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
116427: LD_VAR 0 1
116431: PPUSH
116432: LD_VAR 0 2
116436: PPUSH
116437: LD_VAR 0 3
116441: PPUSH
116442: LD_INT 3
116444: PPUSH
116445: LD_INT 6
116447: PPUSH
116448: CALL_OW 12
116452: PPUSH
116453: LD_INT 1
116455: PPUSH
116456: CALL_OW 483
// end ;
116460: GO 116320
116462: POP
116463: POP
// end ;
116464: PPOPN 5
116466: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
116467: LD_EXP 145
116471: PUSH
116472: LD_EXP 180
116476: AND
116477: IFFALSE 116571
116479: GO 116481
116481: DISABLE
116482: LD_INT 0
116484: PPUSH
116485: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
116486: LD_ADDR_VAR 0 2
116490: PUSH
116491: LD_INT 22
116493: PUSH
116494: LD_OWVAR 2
116498: PUSH
116499: EMPTY
116500: LIST
116501: LIST
116502: PUSH
116503: LD_INT 32
116505: PUSH
116506: LD_INT 1
116508: PUSH
116509: EMPTY
116510: LIST
116511: LIST
116512: PUSH
116513: LD_INT 21
116515: PUSH
116516: LD_INT 2
116518: PUSH
116519: EMPTY
116520: LIST
116521: LIST
116522: PUSH
116523: EMPTY
116524: LIST
116525: LIST
116526: LIST
116527: PPUSH
116528: CALL_OW 69
116532: ST_TO_ADDR
// if not tmp then
116533: LD_VAR 0 2
116537: NOT
116538: IFFALSE 116542
// exit ;
116540: GO 116571
// for i in tmp do
116542: LD_ADDR_VAR 0 1
116546: PUSH
116547: LD_VAR 0 2
116551: PUSH
116552: FOR_IN
116553: IFFALSE 116569
// SetFuel ( i , 0 ) ;
116555: LD_VAR 0 1
116559: PPUSH
116560: LD_INT 0
116562: PPUSH
116563: CALL_OW 240
116567: GO 116552
116569: POP
116570: POP
// end ;
116571: PPOPN 2
116573: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
116574: LD_EXP 145
116578: PUSH
116579: LD_EXP 181
116583: AND
116584: IFFALSE 116650
116586: GO 116588
116588: DISABLE
116589: LD_INT 0
116591: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
116592: LD_ADDR_VAR 0 1
116596: PUSH
116597: LD_INT 22
116599: PUSH
116600: LD_OWVAR 2
116604: PUSH
116605: EMPTY
116606: LIST
116607: LIST
116608: PUSH
116609: LD_INT 30
116611: PUSH
116612: LD_INT 29
116614: PUSH
116615: EMPTY
116616: LIST
116617: LIST
116618: PUSH
116619: EMPTY
116620: LIST
116621: LIST
116622: PPUSH
116623: CALL_OW 69
116627: ST_TO_ADDR
// if not tmp then
116628: LD_VAR 0 1
116632: NOT
116633: IFFALSE 116637
// exit ;
116635: GO 116650
// DestroyUnit ( tmp [ 1 ] ) ;
116637: LD_VAR 0 1
116641: PUSH
116642: LD_INT 1
116644: ARRAY
116645: PPUSH
116646: CALL_OW 65
// end ;
116650: PPOPN 1
116652: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
116653: LD_EXP 145
116657: PUSH
116658: LD_EXP 183
116662: AND
116663: IFFALSE 116792
116665: GO 116667
116667: DISABLE
116668: LD_INT 0
116670: PPUSH
// begin uc_side := 0 ;
116671: LD_ADDR_OWVAR 20
116675: PUSH
116676: LD_INT 0
116678: ST_TO_ADDR
// uc_nation := nation_arabian ;
116679: LD_ADDR_OWVAR 21
116683: PUSH
116684: LD_INT 2
116686: ST_TO_ADDR
// hc_gallery :=  ;
116687: LD_ADDR_OWVAR 33
116691: PUSH
116692: LD_STRING 
116694: ST_TO_ADDR
// hc_name :=  ;
116695: LD_ADDR_OWVAR 26
116699: PUSH
116700: LD_STRING 
116702: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
116703: LD_INT 1
116705: PPUSH
116706: LD_INT 11
116708: PPUSH
116709: LD_INT 10
116711: PPUSH
116712: CALL_OW 380
// un := CreateHuman ;
116716: LD_ADDR_VAR 0 1
116720: PUSH
116721: CALL_OW 44
116725: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
116726: LD_VAR 0 1
116730: PPUSH
116731: LD_INT 1
116733: PPUSH
116734: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
116738: LD_INT 35
116740: PPUSH
116741: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
116745: LD_VAR 0 1
116749: PPUSH
116750: LD_INT 22
116752: PUSH
116753: LD_OWVAR 2
116757: PUSH
116758: EMPTY
116759: LIST
116760: LIST
116761: PPUSH
116762: CALL_OW 69
116766: PPUSH
116767: LD_VAR 0 1
116771: PPUSH
116772: CALL_OW 74
116776: PPUSH
116777: CALL_OW 115
// until IsDead ( un ) ;
116781: LD_VAR 0 1
116785: PPUSH
116786: CALL_OW 301
116790: IFFALSE 116738
// end ;
116792: PPOPN 1
116794: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
116795: LD_EXP 145
116799: PUSH
116800: LD_EXP 185
116804: AND
116805: IFFALSE 116817
116807: GO 116809
116809: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
116810: LD_STRING earthquake(getX(game), 0, 32)
116812: PPUSH
116813: CALL_OW 559
116817: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
116818: LD_EXP 145
116822: PUSH
116823: LD_EXP 186
116827: AND
116828: IFFALSE 116919
116830: GO 116832
116832: DISABLE
116833: LD_INT 0
116835: PPUSH
// begin enable ;
116836: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
116837: LD_ADDR_VAR 0 1
116841: PUSH
116842: LD_INT 22
116844: PUSH
116845: LD_OWVAR 2
116849: PUSH
116850: EMPTY
116851: LIST
116852: LIST
116853: PUSH
116854: LD_INT 21
116856: PUSH
116857: LD_INT 2
116859: PUSH
116860: EMPTY
116861: LIST
116862: LIST
116863: PUSH
116864: LD_INT 33
116866: PUSH
116867: LD_INT 3
116869: PUSH
116870: EMPTY
116871: LIST
116872: LIST
116873: PUSH
116874: EMPTY
116875: LIST
116876: LIST
116877: LIST
116878: PPUSH
116879: CALL_OW 69
116883: ST_TO_ADDR
// if not tmp then
116884: LD_VAR 0 1
116888: NOT
116889: IFFALSE 116893
// exit ;
116891: GO 116919
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
116893: LD_VAR 0 1
116897: PUSH
116898: LD_INT 1
116900: PPUSH
116901: LD_VAR 0 1
116905: PPUSH
116906: CALL_OW 12
116910: ARRAY
116911: PPUSH
116912: LD_INT 1
116914: PPUSH
116915: CALL_OW 234
// end ;
116919: PPOPN 1
116921: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
116922: LD_EXP 145
116926: PUSH
116927: LD_EXP 187
116931: AND
116932: IFFALSE 117073
116934: GO 116936
116936: DISABLE
116937: LD_INT 0
116939: PPUSH
116940: PPUSH
116941: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
116942: LD_ADDR_VAR 0 3
116946: PUSH
116947: LD_INT 22
116949: PUSH
116950: LD_OWVAR 2
116954: PUSH
116955: EMPTY
116956: LIST
116957: LIST
116958: PUSH
116959: LD_INT 25
116961: PUSH
116962: LD_INT 1
116964: PUSH
116965: EMPTY
116966: LIST
116967: LIST
116968: PUSH
116969: EMPTY
116970: LIST
116971: LIST
116972: PPUSH
116973: CALL_OW 69
116977: ST_TO_ADDR
// if not tmp then
116978: LD_VAR 0 3
116982: NOT
116983: IFFALSE 116987
// exit ;
116985: GO 117073
// un := tmp [ rand ( 1 , tmp ) ] ;
116987: LD_ADDR_VAR 0 2
116991: PUSH
116992: LD_VAR 0 3
116996: PUSH
116997: LD_INT 1
116999: PPUSH
117000: LD_VAR 0 3
117004: PPUSH
117005: CALL_OW 12
117009: ARRAY
117010: ST_TO_ADDR
// if Crawls ( un ) then
117011: LD_VAR 0 2
117015: PPUSH
117016: CALL_OW 318
117020: IFFALSE 117031
// ComWalk ( un ) ;
117022: LD_VAR 0 2
117026: PPUSH
117027: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
117031: LD_VAR 0 2
117035: PPUSH
117036: LD_INT 9
117038: PPUSH
117039: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
117043: LD_INT 28
117045: PPUSH
117046: LD_OWVAR 2
117050: PPUSH
117051: LD_INT 2
117053: PPUSH
117054: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
117058: LD_INT 29
117060: PPUSH
117061: LD_OWVAR 2
117065: PPUSH
117066: LD_INT 2
117068: PPUSH
117069: CALL_OW 322
// end ;
117073: PPOPN 3
117075: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
117076: LD_EXP 145
117080: PUSH
117081: LD_EXP 188
117085: AND
117086: IFFALSE 117197
117088: GO 117090
117090: DISABLE
117091: LD_INT 0
117093: PPUSH
117094: PPUSH
117095: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
117096: LD_ADDR_VAR 0 3
117100: PUSH
117101: LD_INT 22
117103: PUSH
117104: LD_OWVAR 2
117108: PUSH
117109: EMPTY
117110: LIST
117111: LIST
117112: PUSH
117113: LD_INT 25
117115: PUSH
117116: LD_INT 1
117118: PUSH
117119: EMPTY
117120: LIST
117121: LIST
117122: PUSH
117123: EMPTY
117124: LIST
117125: LIST
117126: PPUSH
117127: CALL_OW 69
117131: ST_TO_ADDR
// if not tmp then
117132: LD_VAR 0 3
117136: NOT
117137: IFFALSE 117141
// exit ;
117139: GO 117197
// un := tmp [ rand ( 1 , tmp ) ] ;
117141: LD_ADDR_VAR 0 2
117145: PUSH
117146: LD_VAR 0 3
117150: PUSH
117151: LD_INT 1
117153: PPUSH
117154: LD_VAR 0 3
117158: PPUSH
117159: CALL_OW 12
117163: ARRAY
117164: ST_TO_ADDR
// if Crawls ( un ) then
117165: LD_VAR 0 2
117169: PPUSH
117170: CALL_OW 318
117174: IFFALSE 117185
// ComWalk ( un ) ;
117176: LD_VAR 0 2
117180: PPUSH
117181: CALL_OW 138
// SetClass ( un , class_mortar ) ;
117185: LD_VAR 0 2
117189: PPUSH
117190: LD_INT 8
117192: PPUSH
117193: CALL_OW 336
// end ;
117197: PPOPN 3
117199: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
117200: LD_EXP 145
117204: PUSH
117205: LD_EXP 189
117209: AND
117210: IFFALSE 117354
117212: GO 117214
117214: DISABLE
117215: LD_INT 0
117217: PPUSH
117218: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
117219: LD_ADDR_VAR 0 2
117223: PUSH
117224: LD_INT 22
117226: PUSH
117227: LD_OWVAR 2
117231: PUSH
117232: EMPTY
117233: LIST
117234: LIST
117235: PUSH
117236: LD_INT 21
117238: PUSH
117239: LD_INT 2
117241: PUSH
117242: EMPTY
117243: LIST
117244: LIST
117245: PUSH
117246: LD_INT 2
117248: PUSH
117249: LD_INT 34
117251: PUSH
117252: LD_INT 12
117254: PUSH
117255: EMPTY
117256: LIST
117257: LIST
117258: PUSH
117259: LD_INT 34
117261: PUSH
117262: LD_INT 51
117264: PUSH
117265: EMPTY
117266: LIST
117267: LIST
117268: PUSH
117269: LD_INT 34
117271: PUSH
117272: LD_INT 32
117274: PUSH
117275: EMPTY
117276: LIST
117277: LIST
117278: PUSH
117279: EMPTY
117280: LIST
117281: LIST
117282: LIST
117283: LIST
117284: PUSH
117285: EMPTY
117286: LIST
117287: LIST
117288: LIST
117289: PPUSH
117290: CALL_OW 69
117294: ST_TO_ADDR
// if not tmp then
117295: LD_VAR 0 2
117299: NOT
117300: IFFALSE 117304
// exit ;
117302: GO 117354
// for i in tmp do
117304: LD_ADDR_VAR 0 1
117308: PUSH
117309: LD_VAR 0 2
117313: PUSH
117314: FOR_IN
117315: IFFALSE 117352
// if GetCargo ( i , mat_artifact ) = 0 then
117317: LD_VAR 0 1
117321: PPUSH
117322: LD_INT 4
117324: PPUSH
117325: CALL_OW 289
117329: PUSH
117330: LD_INT 0
117332: EQUAL
117333: IFFALSE 117350
// SetCargo ( i , mat_siberit , 100 ) ;
117335: LD_VAR 0 1
117339: PPUSH
117340: LD_INT 3
117342: PPUSH
117343: LD_INT 100
117345: PPUSH
117346: CALL_OW 290
117350: GO 117314
117352: POP
117353: POP
// end ;
117354: PPOPN 2
117356: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
117357: LD_EXP 145
117361: PUSH
117362: LD_EXP 190
117366: AND
117367: IFFALSE 117520
117369: GO 117371
117371: DISABLE
117372: LD_INT 0
117374: PPUSH
117375: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
117376: LD_ADDR_VAR 0 2
117380: PUSH
117381: LD_INT 22
117383: PUSH
117384: LD_OWVAR 2
117388: PUSH
117389: EMPTY
117390: LIST
117391: LIST
117392: PPUSH
117393: CALL_OW 69
117397: ST_TO_ADDR
// if not tmp then
117398: LD_VAR 0 2
117402: NOT
117403: IFFALSE 117407
// exit ;
117405: GO 117520
// for i := 1 to 2 do
117407: LD_ADDR_VAR 0 1
117411: PUSH
117412: DOUBLE
117413: LD_INT 1
117415: DEC
117416: ST_TO_ADDR
117417: LD_INT 2
117419: PUSH
117420: FOR_TO
117421: IFFALSE 117518
// begin uc_side := your_side ;
117423: LD_ADDR_OWVAR 20
117427: PUSH
117428: LD_OWVAR 2
117432: ST_TO_ADDR
// uc_nation := nation_american ;
117433: LD_ADDR_OWVAR 21
117437: PUSH
117438: LD_INT 1
117440: ST_TO_ADDR
// vc_chassis := us_morphling ;
117441: LD_ADDR_OWVAR 37
117445: PUSH
117446: LD_INT 5
117448: ST_TO_ADDR
// vc_engine := engine_siberite ;
117449: LD_ADDR_OWVAR 39
117453: PUSH
117454: LD_INT 3
117456: ST_TO_ADDR
// vc_control := control_computer ;
117457: LD_ADDR_OWVAR 38
117461: PUSH
117462: LD_INT 3
117464: ST_TO_ADDR
// vc_weapon := us_double_laser ;
117465: LD_ADDR_OWVAR 40
117469: PUSH
117470: LD_INT 10
117472: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
117473: CALL_OW 45
117477: PPUSH
117478: LD_VAR 0 2
117482: PUSH
117483: LD_INT 1
117485: ARRAY
117486: PPUSH
117487: CALL_OW 250
117491: PPUSH
117492: LD_VAR 0 2
117496: PUSH
117497: LD_INT 1
117499: ARRAY
117500: PPUSH
117501: CALL_OW 251
117505: PPUSH
117506: LD_INT 12
117508: PPUSH
117509: LD_INT 1
117511: PPUSH
117512: CALL_OW 50
// end ;
117516: GO 117420
117518: POP
117519: POP
// end ;
117520: PPOPN 2
117522: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
117523: LD_EXP 145
117527: PUSH
117528: LD_EXP 191
117532: AND
117533: IFFALSE 117755
117535: GO 117537
117537: DISABLE
117538: LD_INT 0
117540: PPUSH
117541: PPUSH
117542: PPUSH
117543: PPUSH
117544: PPUSH
117545: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
117546: LD_ADDR_VAR 0 6
117550: PUSH
117551: LD_INT 22
117553: PUSH
117554: LD_OWVAR 2
117558: PUSH
117559: EMPTY
117560: LIST
117561: LIST
117562: PUSH
117563: LD_INT 21
117565: PUSH
117566: LD_INT 1
117568: PUSH
117569: EMPTY
117570: LIST
117571: LIST
117572: PUSH
117573: LD_INT 3
117575: PUSH
117576: LD_INT 23
117578: PUSH
117579: LD_INT 0
117581: PUSH
117582: EMPTY
117583: LIST
117584: LIST
117585: PUSH
117586: EMPTY
117587: LIST
117588: LIST
117589: PUSH
117590: EMPTY
117591: LIST
117592: LIST
117593: LIST
117594: PPUSH
117595: CALL_OW 69
117599: ST_TO_ADDR
// if not tmp then
117600: LD_VAR 0 6
117604: NOT
117605: IFFALSE 117609
// exit ;
117607: GO 117755
// s1 := rand ( 1 , 4 ) ;
117609: LD_ADDR_VAR 0 2
117613: PUSH
117614: LD_INT 1
117616: PPUSH
117617: LD_INT 4
117619: PPUSH
117620: CALL_OW 12
117624: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
117625: LD_ADDR_VAR 0 4
117629: PUSH
117630: LD_VAR 0 6
117634: PUSH
117635: LD_INT 1
117637: ARRAY
117638: PPUSH
117639: LD_VAR 0 2
117643: PPUSH
117644: CALL_OW 259
117648: ST_TO_ADDR
// if s1 = 1 then
117649: LD_VAR 0 2
117653: PUSH
117654: LD_INT 1
117656: EQUAL
117657: IFFALSE 117677
// s2 := rand ( 2 , 4 ) else
117659: LD_ADDR_VAR 0 3
117663: PUSH
117664: LD_INT 2
117666: PPUSH
117667: LD_INT 4
117669: PPUSH
117670: CALL_OW 12
117674: ST_TO_ADDR
117675: GO 117685
// s2 := 1 ;
117677: LD_ADDR_VAR 0 3
117681: PUSH
117682: LD_INT 1
117684: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
117685: LD_ADDR_VAR 0 5
117689: PUSH
117690: LD_VAR 0 6
117694: PUSH
117695: LD_INT 1
117697: ARRAY
117698: PPUSH
117699: LD_VAR 0 3
117703: PPUSH
117704: CALL_OW 259
117708: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
117709: LD_VAR 0 6
117713: PUSH
117714: LD_INT 1
117716: ARRAY
117717: PPUSH
117718: LD_VAR 0 2
117722: PPUSH
117723: LD_VAR 0 5
117727: PPUSH
117728: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
117732: LD_VAR 0 6
117736: PUSH
117737: LD_INT 1
117739: ARRAY
117740: PPUSH
117741: LD_VAR 0 3
117745: PPUSH
117746: LD_VAR 0 4
117750: PPUSH
117751: CALL_OW 237
// end ;
117755: PPOPN 6
117757: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
117758: LD_EXP 145
117762: PUSH
117763: LD_EXP 192
117767: AND
117768: IFFALSE 117847
117770: GO 117772
117772: DISABLE
117773: LD_INT 0
117775: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
117776: LD_ADDR_VAR 0 1
117780: PUSH
117781: LD_INT 22
117783: PUSH
117784: LD_OWVAR 2
117788: PUSH
117789: EMPTY
117790: LIST
117791: LIST
117792: PUSH
117793: LD_INT 30
117795: PUSH
117796: LD_INT 3
117798: PUSH
117799: EMPTY
117800: LIST
117801: LIST
117802: PUSH
117803: EMPTY
117804: LIST
117805: LIST
117806: PPUSH
117807: CALL_OW 69
117811: ST_TO_ADDR
// if not tmp then
117812: LD_VAR 0 1
117816: NOT
117817: IFFALSE 117821
// exit ;
117819: GO 117847
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
117821: LD_VAR 0 1
117825: PUSH
117826: LD_INT 1
117828: PPUSH
117829: LD_VAR 0 1
117833: PPUSH
117834: CALL_OW 12
117838: ARRAY
117839: PPUSH
117840: LD_INT 1
117842: PPUSH
117843: CALL_OW 234
// end ;
117847: PPOPN 1
117849: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
117850: LD_EXP 145
117854: PUSH
117855: LD_EXP 193
117859: AND
117860: IFFALSE 117972
117862: GO 117864
117864: DISABLE
117865: LD_INT 0
117867: PPUSH
117868: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
117869: LD_ADDR_VAR 0 2
117873: PUSH
117874: LD_INT 22
117876: PUSH
117877: LD_OWVAR 2
117881: PUSH
117882: EMPTY
117883: LIST
117884: LIST
117885: PUSH
117886: LD_INT 2
117888: PUSH
117889: LD_INT 30
117891: PUSH
117892: LD_INT 27
117894: PUSH
117895: EMPTY
117896: LIST
117897: LIST
117898: PUSH
117899: LD_INT 30
117901: PUSH
117902: LD_INT 26
117904: PUSH
117905: EMPTY
117906: LIST
117907: LIST
117908: PUSH
117909: LD_INT 30
117911: PUSH
117912: LD_INT 28
117914: PUSH
117915: EMPTY
117916: LIST
117917: LIST
117918: PUSH
117919: EMPTY
117920: LIST
117921: LIST
117922: LIST
117923: LIST
117924: PUSH
117925: EMPTY
117926: LIST
117927: LIST
117928: PPUSH
117929: CALL_OW 69
117933: ST_TO_ADDR
// if not tmp then
117934: LD_VAR 0 2
117938: NOT
117939: IFFALSE 117943
// exit ;
117941: GO 117972
// for i in tmp do
117943: LD_ADDR_VAR 0 1
117947: PUSH
117948: LD_VAR 0 2
117952: PUSH
117953: FOR_IN
117954: IFFALSE 117970
// SetLives ( i , 1 ) ;
117956: LD_VAR 0 1
117960: PPUSH
117961: LD_INT 1
117963: PPUSH
117964: CALL_OW 234
117968: GO 117953
117970: POP
117971: POP
// end ;
117972: PPOPN 2
117974: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
117975: LD_EXP 145
117979: PUSH
117980: LD_EXP 194
117984: AND
117985: IFFALSE 118259
117987: GO 117989
117989: DISABLE
117990: LD_INT 0
117992: PPUSH
117993: PPUSH
117994: PPUSH
// begin i := rand ( 1 , 7 ) ;
117995: LD_ADDR_VAR 0 1
117999: PUSH
118000: LD_INT 1
118002: PPUSH
118003: LD_INT 7
118005: PPUSH
118006: CALL_OW 12
118010: ST_TO_ADDR
// case i of 1 :
118011: LD_VAR 0 1
118015: PUSH
118016: LD_INT 1
118018: DOUBLE
118019: EQUAL
118020: IFTRUE 118024
118022: GO 118034
118024: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
118025: LD_STRING earthquake(getX(game), 0, 32)
118027: PPUSH
118028: CALL_OW 559
118032: GO 118259
118034: LD_INT 2
118036: DOUBLE
118037: EQUAL
118038: IFTRUE 118042
118040: GO 118056
118042: POP
// begin ToLua ( displayStucuk(); ) ;
118043: LD_STRING displayStucuk();
118045: PPUSH
118046: CALL_OW 559
// ResetFog ;
118050: CALL_OW 335
// end ; 3 :
118054: GO 118259
118056: LD_INT 3
118058: DOUBLE
118059: EQUAL
118060: IFTRUE 118064
118062: GO 118168
118064: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
118065: LD_ADDR_VAR 0 2
118069: PUSH
118070: LD_INT 22
118072: PUSH
118073: LD_OWVAR 2
118077: PUSH
118078: EMPTY
118079: LIST
118080: LIST
118081: PUSH
118082: LD_INT 25
118084: PUSH
118085: LD_INT 1
118087: PUSH
118088: EMPTY
118089: LIST
118090: LIST
118091: PUSH
118092: EMPTY
118093: LIST
118094: LIST
118095: PPUSH
118096: CALL_OW 69
118100: ST_TO_ADDR
// if not tmp then
118101: LD_VAR 0 2
118105: NOT
118106: IFFALSE 118110
// exit ;
118108: GO 118259
// un := tmp [ rand ( 1 , tmp ) ] ;
118110: LD_ADDR_VAR 0 3
118114: PUSH
118115: LD_VAR 0 2
118119: PUSH
118120: LD_INT 1
118122: PPUSH
118123: LD_VAR 0 2
118127: PPUSH
118128: CALL_OW 12
118132: ARRAY
118133: ST_TO_ADDR
// if Crawls ( un ) then
118134: LD_VAR 0 3
118138: PPUSH
118139: CALL_OW 318
118143: IFFALSE 118154
// ComWalk ( un ) ;
118145: LD_VAR 0 3
118149: PPUSH
118150: CALL_OW 138
// SetClass ( un , class_mortar ) ;
118154: LD_VAR 0 3
118158: PPUSH
118159: LD_INT 8
118161: PPUSH
118162: CALL_OW 336
// end ; 4 :
118166: GO 118259
118168: LD_INT 4
118170: DOUBLE
118171: EQUAL
118172: IFTRUE 118176
118174: GO 118237
118176: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
118177: LD_ADDR_VAR 0 2
118181: PUSH
118182: LD_INT 22
118184: PUSH
118185: LD_OWVAR 2
118189: PUSH
118190: EMPTY
118191: LIST
118192: LIST
118193: PUSH
118194: LD_INT 30
118196: PUSH
118197: LD_INT 29
118199: PUSH
118200: EMPTY
118201: LIST
118202: LIST
118203: PUSH
118204: EMPTY
118205: LIST
118206: LIST
118207: PPUSH
118208: CALL_OW 69
118212: ST_TO_ADDR
// if not tmp then
118213: LD_VAR 0 2
118217: NOT
118218: IFFALSE 118222
// exit ;
118220: GO 118259
// DestroyUnit ( tmp [ 1 ] ) ;
118222: LD_VAR 0 2
118226: PUSH
118227: LD_INT 1
118229: ARRAY
118230: PPUSH
118231: CALL_OW 65
// end ; 5 .. 7 :
118235: GO 118259
118237: LD_INT 5
118239: DOUBLE
118240: GREATEREQUAL
118241: IFFALSE 118249
118243: LD_INT 7
118245: DOUBLE
118246: LESSEQUAL
118247: IFTRUE 118251
118249: GO 118258
118251: POP
// StreamSibBomb ; end ;
118252: CALL 114539 0 0
118256: GO 118259
118258: POP
// end ;
118259: PPOPN 3
118261: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
118262: LD_EXP 145
118266: PUSH
118267: LD_EXP 195
118271: AND
118272: IFFALSE 118428
118274: GO 118276
118276: DISABLE
118277: LD_INT 0
118279: PPUSH
118280: PPUSH
118281: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
118282: LD_ADDR_VAR 0 2
118286: PUSH
118287: LD_INT 81
118289: PUSH
118290: LD_OWVAR 2
118294: PUSH
118295: EMPTY
118296: LIST
118297: LIST
118298: PUSH
118299: LD_INT 2
118301: PUSH
118302: LD_INT 21
118304: PUSH
118305: LD_INT 1
118307: PUSH
118308: EMPTY
118309: LIST
118310: LIST
118311: PUSH
118312: LD_INT 21
118314: PUSH
118315: LD_INT 2
118317: PUSH
118318: EMPTY
118319: LIST
118320: LIST
118321: PUSH
118322: EMPTY
118323: LIST
118324: LIST
118325: LIST
118326: PUSH
118327: EMPTY
118328: LIST
118329: LIST
118330: PPUSH
118331: CALL_OW 69
118335: ST_TO_ADDR
// if not tmp then
118336: LD_VAR 0 2
118340: NOT
118341: IFFALSE 118345
// exit ;
118343: GO 118428
// p := 0 ;
118345: LD_ADDR_VAR 0 3
118349: PUSH
118350: LD_INT 0
118352: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
118353: LD_INT 35
118355: PPUSH
118356: CALL_OW 67
// p := p + 1 ;
118360: LD_ADDR_VAR 0 3
118364: PUSH
118365: LD_VAR 0 3
118369: PUSH
118370: LD_INT 1
118372: PLUS
118373: ST_TO_ADDR
// for i in tmp do
118374: LD_ADDR_VAR 0 1
118378: PUSH
118379: LD_VAR 0 2
118383: PUSH
118384: FOR_IN
118385: IFFALSE 118416
// if GetLives ( i ) < 1000 then
118387: LD_VAR 0 1
118391: PPUSH
118392: CALL_OW 256
118396: PUSH
118397: LD_INT 1000
118399: LESS
118400: IFFALSE 118414
// SetLives ( i , 1000 ) ;
118402: LD_VAR 0 1
118406: PPUSH
118407: LD_INT 1000
118409: PPUSH
118410: CALL_OW 234
118414: GO 118384
118416: POP
118417: POP
// until p > 20 ;
118418: LD_VAR 0 3
118422: PUSH
118423: LD_INT 20
118425: GREATER
118426: IFFALSE 118353
// end ;
118428: PPOPN 3
118430: END
// every 0 0$1 trigger StreamModeActive and sTime do
118431: LD_EXP 145
118435: PUSH
118436: LD_EXP 196
118440: AND
118441: IFFALSE 118476
118443: GO 118445
118445: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
118446: LD_INT 28
118448: PPUSH
118449: LD_OWVAR 2
118453: PPUSH
118454: LD_INT 2
118456: PPUSH
118457: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
118461: LD_INT 30
118463: PPUSH
118464: LD_OWVAR 2
118468: PPUSH
118469: LD_INT 2
118471: PPUSH
118472: CALL_OW 322
// end ;
118476: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
118477: LD_EXP 145
118481: PUSH
118482: LD_EXP 197
118486: AND
118487: IFFALSE 118608
118489: GO 118491
118491: DISABLE
118492: LD_INT 0
118494: PPUSH
118495: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
118496: LD_ADDR_VAR 0 2
118500: PUSH
118501: LD_INT 22
118503: PUSH
118504: LD_OWVAR 2
118508: PUSH
118509: EMPTY
118510: LIST
118511: LIST
118512: PUSH
118513: LD_INT 21
118515: PUSH
118516: LD_INT 1
118518: PUSH
118519: EMPTY
118520: LIST
118521: LIST
118522: PUSH
118523: LD_INT 3
118525: PUSH
118526: LD_INT 23
118528: PUSH
118529: LD_INT 0
118531: PUSH
118532: EMPTY
118533: LIST
118534: LIST
118535: PUSH
118536: EMPTY
118537: LIST
118538: LIST
118539: PUSH
118540: EMPTY
118541: LIST
118542: LIST
118543: LIST
118544: PPUSH
118545: CALL_OW 69
118549: ST_TO_ADDR
// if not tmp then
118550: LD_VAR 0 2
118554: NOT
118555: IFFALSE 118559
// exit ;
118557: GO 118608
// for i in tmp do
118559: LD_ADDR_VAR 0 1
118563: PUSH
118564: LD_VAR 0 2
118568: PUSH
118569: FOR_IN
118570: IFFALSE 118606
// begin if Crawls ( i ) then
118572: LD_VAR 0 1
118576: PPUSH
118577: CALL_OW 318
118581: IFFALSE 118592
// ComWalk ( i ) ;
118583: LD_VAR 0 1
118587: PPUSH
118588: CALL_OW 138
// SetClass ( i , 2 ) ;
118592: LD_VAR 0 1
118596: PPUSH
118597: LD_INT 2
118599: PPUSH
118600: CALL_OW 336
// end ;
118604: GO 118569
118606: POP
118607: POP
// end ;
118608: PPOPN 2
118610: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
118611: LD_EXP 145
118615: PUSH
118616: LD_EXP 198
118620: AND
118621: IFFALSE 118902
118623: GO 118625
118625: DISABLE
118626: LD_INT 0
118628: PPUSH
118629: PPUSH
118630: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
118631: LD_OWVAR 2
118635: PPUSH
118636: LD_INT 9
118638: PPUSH
118639: LD_INT 1
118641: PPUSH
118642: LD_INT 1
118644: PPUSH
118645: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
118649: LD_INT 9
118651: PPUSH
118652: LD_OWVAR 2
118656: PPUSH
118657: CALL_OW 343
// uc_side := 9 ;
118661: LD_ADDR_OWVAR 20
118665: PUSH
118666: LD_INT 9
118668: ST_TO_ADDR
// uc_nation := 2 ;
118669: LD_ADDR_OWVAR 21
118673: PUSH
118674: LD_INT 2
118676: ST_TO_ADDR
// hc_name := Dark Warrior ;
118677: LD_ADDR_OWVAR 26
118681: PUSH
118682: LD_STRING Dark Warrior
118684: ST_TO_ADDR
// hc_gallery :=  ;
118685: LD_ADDR_OWVAR 33
118689: PUSH
118690: LD_STRING 
118692: ST_TO_ADDR
// hc_noskilllimit := true ;
118693: LD_ADDR_OWVAR 76
118697: PUSH
118698: LD_INT 1
118700: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
118701: LD_ADDR_OWVAR 31
118705: PUSH
118706: LD_INT 30
118708: PUSH
118709: LD_INT 30
118711: PUSH
118712: LD_INT 30
118714: PUSH
118715: LD_INT 30
118717: PUSH
118718: EMPTY
118719: LIST
118720: LIST
118721: LIST
118722: LIST
118723: ST_TO_ADDR
// un := CreateHuman ;
118724: LD_ADDR_VAR 0 3
118728: PUSH
118729: CALL_OW 44
118733: ST_TO_ADDR
// hc_noskilllimit := false ;
118734: LD_ADDR_OWVAR 76
118738: PUSH
118739: LD_INT 0
118741: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
118742: LD_VAR 0 3
118746: PPUSH
118747: LD_INT 1
118749: PPUSH
118750: CALL_OW 51
// p := 0 ;
118754: LD_ADDR_VAR 0 2
118758: PUSH
118759: LD_INT 0
118761: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
118762: LD_INT 35
118764: PPUSH
118765: CALL_OW 67
// p := p + 1 ;
118769: LD_ADDR_VAR 0 2
118773: PUSH
118774: LD_VAR 0 2
118778: PUSH
118779: LD_INT 1
118781: PLUS
118782: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
118783: LD_VAR 0 3
118787: PPUSH
118788: CALL_OW 256
118792: PUSH
118793: LD_INT 1000
118795: LESS
118796: IFFALSE 118810
// SetLives ( un , 1000 ) ;
118798: LD_VAR 0 3
118802: PPUSH
118803: LD_INT 1000
118805: PPUSH
118806: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
118810: LD_VAR 0 3
118814: PPUSH
118815: LD_INT 81
118817: PUSH
118818: LD_OWVAR 2
118822: PUSH
118823: EMPTY
118824: LIST
118825: LIST
118826: PUSH
118827: LD_INT 91
118829: PUSH
118830: LD_VAR 0 3
118834: PUSH
118835: LD_INT 30
118837: PUSH
118838: EMPTY
118839: LIST
118840: LIST
118841: LIST
118842: PUSH
118843: EMPTY
118844: LIST
118845: LIST
118846: PPUSH
118847: CALL_OW 69
118851: PPUSH
118852: LD_VAR 0 3
118856: PPUSH
118857: CALL_OW 74
118861: PPUSH
118862: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
118866: LD_VAR 0 2
118870: PUSH
118871: LD_INT 60
118873: GREATER
118874: PUSH
118875: LD_VAR 0 3
118879: PPUSH
118880: CALL_OW 301
118884: OR
118885: IFFALSE 118762
// if un then
118887: LD_VAR 0 3
118891: IFFALSE 118902
// RemoveUnit ( un ) ;
118893: LD_VAR 0 3
118897: PPUSH
118898: CALL_OW 64
// end ; end_of_file
118902: PPOPN 3
118904: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
118905: LD_INT 0
118907: PPUSH
118908: PPUSH
118909: PPUSH
118910: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
118911: LD_VAR 0 1
118915: PPUSH
118916: CALL_OW 264
118920: PUSH
118921: LD_EXP 99
118925: EQUAL
118926: IFFALSE 118998
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
118928: LD_INT 68
118930: PPUSH
118931: LD_VAR 0 1
118935: PPUSH
118936: CALL_OW 255
118940: PPUSH
118941: CALL_OW 321
118945: PUSH
118946: LD_INT 2
118948: EQUAL
118949: IFFALSE 118961
// eff := 70 else
118951: LD_ADDR_VAR 0 6
118955: PUSH
118956: LD_INT 70
118958: ST_TO_ADDR
118959: GO 118969
// eff := 30 ;
118961: LD_ADDR_VAR 0 6
118965: PUSH
118966: LD_INT 30
118968: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
118969: LD_VAR 0 1
118973: PPUSH
118974: CALL_OW 250
118978: PPUSH
118979: LD_VAR 0 1
118983: PPUSH
118984: CALL_OW 251
118988: PPUSH
118989: LD_VAR 0 6
118993: PPUSH
118994: CALL_OW 495
// end ; end ;
118998: LD_VAR 0 4
119002: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
119003: LD_INT 0
119005: PPUSH
119006: PPUSH
119007: PPUSH
119008: PPUSH
119009: PPUSH
119010: PPUSH
// if cmd = 124 then
119011: LD_VAR 0 1
119015: PUSH
119016: LD_INT 124
119018: EQUAL
119019: IFFALSE 119225
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
119021: LD_ADDR_VAR 0 5
119025: PUSH
119026: LD_INT 2
119028: PUSH
119029: LD_INT 34
119031: PUSH
119032: LD_INT 53
119034: PUSH
119035: EMPTY
119036: LIST
119037: LIST
119038: PUSH
119039: LD_INT 34
119041: PUSH
119042: LD_INT 14
119044: PUSH
119045: EMPTY
119046: LIST
119047: LIST
119048: PUSH
119049: EMPTY
119050: LIST
119051: LIST
119052: LIST
119053: PPUSH
119054: CALL_OW 69
119058: ST_TO_ADDR
// if not tmp then
119059: LD_VAR 0 5
119063: NOT
119064: IFFALSE 119068
// exit ;
119066: GO 119225
// for i in tmp do
119068: LD_ADDR_VAR 0 3
119072: PUSH
119073: LD_VAR 0 5
119077: PUSH
119078: FOR_IN
119079: IFFALSE 119223
// begin taskList := GetTaskList ( i ) ;
119081: LD_ADDR_VAR 0 6
119085: PUSH
119086: LD_VAR 0 3
119090: PPUSH
119091: CALL_OW 437
119095: ST_TO_ADDR
// if not taskList then
119096: LD_VAR 0 6
119100: NOT
119101: IFFALSE 119105
// continue ;
119103: GO 119078
// for j = 1 to taskList do
119105: LD_ADDR_VAR 0 4
119109: PUSH
119110: DOUBLE
119111: LD_INT 1
119113: DEC
119114: ST_TO_ADDR
119115: LD_VAR 0 6
119119: PUSH
119120: FOR_TO
119121: IFFALSE 119219
// if taskList [ j ] [ 1 ] = | then
119123: LD_VAR 0 6
119127: PUSH
119128: LD_VAR 0 4
119132: ARRAY
119133: PUSH
119134: LD_INT 1
119136: ARRAY
119137: PUSH
119138: LD_STRING |
119140: EQUAL
119141: IFFALSE 119217
// begin _taskList := Delete ( taskList , 1 ) ;
119143: LD_ADDR_VAR 0 7
119147: PUSH
119148: LD_VAR 0 6
119152: PPUSH
119153: LD_INT 1
119155: PPUSH
119156: CALL_OW 3
119160: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
119161: LD_VAR 0 3
119165: PPUSH
119166: LD_VAR 0 7
119170: PPUSH
119171: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
119175: LD_VAR 0 3
119179: PPUSH
119180: LD_VAR 0 6
119184: PUSH
119185: LD_VAR 0 4
119189: ARRAY
119190: PUSH
119191: LD_INT 2
119193: ARRAY
119194: PPUSH
119195: LD_VAR 0 6
119199: PUSH
119200: LD_VAR 0 4
119204: ARRAY
119205: PUSH
119206: LD_INT 3
119208: ARRAY
119209: PPUSH
119210: LD_INT 8
119212: PPUSH
119213: CALL 119230 0 4
// end ;
119217: GO 119120
119219: POP
119220: POP
// end ;
119221: GO 119078
119223: POP
119224: POP
// end ; end ;
119225: LD_VAR 0 2
119229: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
119230: LD_INT 0
119232: PPUSH
119233: PPUSH
119234: PPUSH
119235: PPUSH
119236: PPUSH
119237: PPUSH
119238: PPUSH
119239: PPUSH
119240: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
119241: LD_VAR 0 1
119245: NOT
119246: PUSH
119247: LD_VAR 0 2
119251: PPUSH
119252: LD_VAR 0 3
119256: PPUSH
119257: CALL_OW 488
119261: NOT
119262: OR
119263: PUSH
119264: LD_VAR 0 4
119268: NOT
119269: OR
119270: IFFALSE 119274
// exit ;
119272: GO 119614
// list := [ ] ;
119274: LD_ADDR_VAR 0 13
119278: PUSH
119279: EMPTY
119280: ST_TO_ADDR
// if x - r < 0 then
119281: LD_VAR 0 2
119285: PUSH
119286: LD_VAR 0 4
119290: MINUS
119291: PUSH
119292: LD_INT 0
119294: LESS
119295: IFFALSE 119307
// min_x := 0 else
119297: LD_ADDR_VAR 0 7
119301: PUSH
119302: LD_INT 0
119304: ST_TO_ADDR
119305: GO 119323
// min_x := x - r ;
119307: LD_ADDR_VAR 0 7
119311: PUSH
119312: LD_VAR 0 2
119316: PUSH
119317: LD_VAR 0 4
119321: MINUS
119322: ST_TO_ADDR
// if y - r < 0 then
119323: LD_VAR 0 3
119327: PUSH
119328: LD_VAR 0 4
119332: MINUS
119333: PUSH
119334: LD_INT 0
119336: LESS
119337: IFFALSE 119349
// min_y := 0 else
119339: LD_ADDR_VAR 0 8
119343: PUSH
119344: LD_INT 0
119346: ST_TO_ADDR
119347: GO 119365
// min_y := y - r ;
119349: LD_ADDR_VAR 0 8
119353: PUSH
119354: LD_VAR 0 3
119358: PUSH
119359: LD_VAR 0 4
119363: MINUS
119364: ST_TO_ADDR
// max_x := x + r ;
119365: LD_ADDR_VAR 0 9
119369: PUSH
119370: LD_VAR 0 2
119374: PUSH
119375: LD_VAR 0 4
119379: PLUS
119380: ST_TO_ADDR
// max_y := y + r ;
119381: LD_ADDR_VAR 0 10
119385: PUSH
119386: LD_VAR 0 3
119390: PUSH
119391: LD_VAR 0 4
119395: PLUS
119396: ST_TO_ADDR
// for _x = min_x to max_x do
119397: LD_ADDR_VAR 0 11
119401: PUSH
119402: DOUBLE
119403: LD_VAR 0 7
119407: DEC
119408: ST_TO_ADDR
119409: LD_VAR 0 9
119413: PUSH
119414: FOR_TO
119415: IFFALSE 119532
// for _y = min_y to max_y do
119417: LD_ADDR_VAR 0 12
119421: PUSH
119422: DOUBLE
119423: LD_VAR 0 8
119427: DEC
119428: ST_TO_ADDR
119429: LD_VAR 0 10
119433: PUSH
119434: FOR_TO
119435: IFFALSE 119528
// begin if not ValidHex ( _x , _y ) then
119437: LD_VAR 0 11
119441: PPUSH
119442: LD_VAR 0 12
119446: PPUSH
119447: CALL_OW 488
119451: NOT
119452: IFFALSE 119456
// continue ;
119454: GO 119434
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
119456: LD_VAR 0 11
119460: PPUSH
119461: LD_VAR 0 12
119465: PPUSH
119466: CALL_OW 351
119470: PUSH
119471: LD_VAR 0 11
119475: PPUSH
119476: LD_VAR 0 12
119480: PPUSH
119481: CALL_OW 554
119485: AND
119486: IFFALSE 119526
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
119488: LD_ADDR_VAR 0 13
119492: PUSH
119493: LD_VAR 0 13
119497: PPUSH
119498: LD_VAR 0 13
119502: PUSH
119503: LD_INT 1
119505: PLUS
119506: PPUSH
119507: LD_VAR 0 11
119511: PUSH
119512: LD_VAR 0 12
119516: PUSH
119517: EMPTY
119518: LIST
119519: LIST
119520: PPUSH
119521: CALL_OW 2
119525: ST_TO_ADDR
// end ;
119526: GO 119434
119528: POP
119529: POP
119530: GO 119414
119532: POP
119533: POP
// if not list then
119534: LD_VAR 0 13
119538: NOT
119539: IFFALSE 119543
// exit ;
119541: GO 119614
// for i in list do
119543: LD_ADDR_VAR 0 6
119547: PUSH
119548: LD_VAR 0 13
119552: PUSH
119553: FOR_IN
119554: IFFALSE 119612
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
119556: LD_VAR 0 1
119560: PPUSH
119561: LD_STRING M
119563: PUSH
119564: LD_VAR 0 6
119568: PUSH
119569: LD_INT 1
119571: ARRAY
119572: PUSH
119573: LD_VAR 0 6
119577: PUSH
119578: LD_INT 2
119580: ARRAY
119581: PUSH
119582: LD_INT 0
119584: PUSH
119585: LD_INT 0
119587: PUSH
119588: LD_INT 0
119590: PUSH
119591: LD_INT 0
119593: PUSH
119594: EMPTY
119595: LIST
119596: LIST
119597: LIST
119598: LIST
119599: LIST
119600: LIST
119601: LIST
119602: PUSH
119603: EMPTY
119604: LIST
119605: PPUSH
119606: CALL_OW 447
119610: GO 119553
119612: POP
119613: POP
// end ;
119614: LD_VAR 0 5
119618: RET
