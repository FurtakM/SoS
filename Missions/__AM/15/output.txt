// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 34941 0 0
// InitNature ;
  19: CALL 34701 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 11057 0 0
// PrepareRussian ;
  40: CALL 6941 0 0
// PrepareLegion ;
  44: CALL 4181 0 0
// PreparePowell ;
  48: CALL 2918 0 0
// PrepareAmerican ;
  52: CALL 1690 0 0
// Action ;
  56: CALL 14951 0 0
// MC_Start ( ) ;
  60: CALL 37053 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// end ;
 462: LD_VAR 0 1
 466: RET
// export function CustomInitMacro ( ) ; begin
 467: LD_INT 0
 469: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 470: LD_ADDR_EXP 134
 474: PUSH
 475: LD_INT 2
 477: PUSH
 478: LD_INT 3
 480: PUSH
 481: LD_INT 6
 483: PUSH
 484: LD_INT 10
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 493: LD_ADDR_EXP 135
 497: PUSH
 498: LD_INT 1
 500: PUSH
 501: LD_INT 4
 503: PUSH
 504: LD_INT 5
 506: PUSH
 507: LD_INT 9
 509: PUSH
 510: EMPTY
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 516: LD_INT 1
 518: PPUSH
 519: LD_INT 10
 521: PUSH
 522: LD_INT 11
 524: PUSH
 525: LD_INT 12
 527: PUSH
 528: EMPTY
 529: LIST
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 59330 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 17
 542: PUSH
 543: EMPTY
 544: LIST
 545: PPUSH
 546: CALL 59423 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 550: LD_INT 1
 552: PPUSH
 553: LD_INT 5
 555: PPUSH
 556: CALL 58773 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 560: LD_INT 1
 562: PPUSH
 563: LD_INT 24
 565: PUSH
 566: LD_INT 3
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 47
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: LD_INT 24
 583: PUSH
 584: LD_INT 3
 586: PUSH
 587: LD_INT 3
 589: PUSH
 590: LD_INT 47
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: LIST
 597: LIST
 598: PUSH
 599: LD_INT 24
 601: PUSH
 602: LD_INT 3
 604: PUSH
 605: LD_INT 3
 607: PUSH
 608: LD_INT 47
 610: PUSH
 611: EMPTY
 612: LIST
 613: LIST
 614: LIST
 615: LIST
 616: PUSH
 617: LD_INT 24
 619: PUSH
 620: LD_INT 3
 622: PUSH
 623: LD_INT 1
 625: PUSH
 626: LD_INT 47
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: LIST
 634: PUSH
 635: LD_INT 24
 637: PUSH
 638: LD_INT 3
 640: PUSH
 641: LD_INT 1
 643: PUSH
 644: LD_INT 47
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: LIST
 659: PPUSH
 660: CALL 58588 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 664: LD_INT 2
 666: PPUSH
 667: LD_INT 10
 669: PUSH
 670: LD_INT 11
 672: PUSH
 673: LD_INT 12
 675: PUSH
 676: LD_INT 14
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: CALL 59330 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 689: LD_INT 2
 691: PPUSH
 692: LD_INT 16
 694: PUSH
 695: EMPTY
 696: LIST
 697: PPUSH
 698: CALL 59423 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 702: LD_INT 2
 704: PPUSH
 705: LD_INT 21
 707: PUSH
 708: LD_INT 3
 710: PUSH
 711: LD_INT 3
 713: PUSH
 714: LD_INT 51
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: LIST
 722: PUSH
 723: LD_INT 22
 725: PUSH
 726: LD_INT 3
 728: PUSH
 729: LD_INT 3
 731: PUSH
 732: LD_INT 52
 734: PUSH
 735: EMPTY
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: PUSH
 741: LD_INT 22
 743: PUSH
 744: LD_INT 3
 746: PUSH
 747: LD_INT 3
 749: PUSH
 750: LD_INT 52
 752: PUSH
 753: EMPTY
 754: LIST
 755: LIST
 756: LIST
 757: LIST
 758: PUSH
 759: LD_INT 24
 761: PUSH
 762: LD_INT 3
 764: PUSH
 765: LD_INT 3
 767: PUSH
 768: LD_INT 47
 770: PUSH
 771: EMPTY
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: PUSH
 777: LD_INT 24
 779: PUSH
 780: LD_INT 3
 782: PUSH
 783: LD_INT 3
 785: PUSH
 786: LD_INT 47
 788: PUSH
 789: EMPTY
 790: LIST
 791: LIST
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 24
 797: PUSH
 798: LD_INT 3
 800: PUSH
 801: LD_INT 3
 803: PUSH
 804: LD_INT 47
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: PUSH
 813: LD_INT 24
 815: PUSH
 816: LD_INT 3
 818: PUSH
 819: LD_INT 3
 821: PUSH
 822: LD_INT 47
 824: PUSH
 825: EMPTY
 826: LIST
 827: LIST
 828: LIST
 829: LIST
 830: PUSH
 831: LD_INT 24
 833: PUSH
 834: LD_INT 3
 836: PUSH
 837: LD_INT 3
 839: PUSH
 840: LD_INT 47
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: LIST
 853: LIST
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: PPUSH
 859: CALL 58588 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 863: LD_INT 2
 865: PPUSH
 866: LD_INT 5
 868: PPUSH
 869: CALL 58773 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 873: LD_INT 2
 875: PPUSH
 876: LD_INT 0
 878: PPUSH
 879: CALL 59203 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 883: LD_INT 3
 885: PPUSH
 886: LD_INT 10
 888: PUSH
 889: LD_INT 12
 891: PUSH
 892: LD_INT 15
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: PUSH
 900: LD_OWVAR 67
 904: ARRAY
 905: PPUSH
 906: LD_INT 27
 908: PPUSH
 909: CALL 58270 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 913: LD_INT 3
 915: PPUSH
 916: LD_INT 10
 918: PUSH
 919: LD_INT 11
 921: PUSH
 922: LD_INT 13
 924: PUSH
 925: LD_INT 15
 927: PUSH
 928: EMPTY
 929: LIST
 930: LIST
 931: LIST
 932: LIST
 933: PPUSH
 934: CALL 59330 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 938: LD_INT 3
 940: PPUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: PPUSH
 947: CALL 59423 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 951: LD_ADDR_EXP 139
 955: PUSH
 956: LD_EXP 139
 960: PPUSH
 961: LD_INT 3
 963: PPUSH
 964: LD_INT 22
 966: PUSH
 967: LD_INT 8
 969: PUSH
 970: EMPTY
 971: LIST
 972: LIST
 973: PUSH
 974: LD_INT 25
 976: PUSH
 977: LD_INT 15
 979: PUSH
 980: EMPTY
 981: LIST
 982: LIST
 983: PUSH
 984: EMPTY
 985: LIST
 986: LIST
 987: PPUSH
 988: CALL_OW 69
 992: PPUSH
 993: CALL_OW 1
 997: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 998: LD_INT 3
1000: PPUSH
1001: LD_INT 13
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_INT 1
1009: PUSH
1010: LD_INT 31
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: PUSH
1019: LD_INT 13
1021: PUSH
1022: LD_INT 2
1024: PUSH
1025: LD_INT 1
1027: PUSH
1028: LD_INT 31
1030: PUSH
1031: EMPTY
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: LD_INT 13
1039: PUSH
1040: LD_INT 3
1042: PUSH
1043: LD_INT 2
1045: PUSH
1046: LD_INT 32
1048: PUSH
1049: EMPTY
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: PUSH
1055: EMPTY
1056: LIST
1057: LIST
1058: LIST
1059: PPUSH
1060: CALL 58588 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1064: LD_INT 4
1066: PPUSH
1067: LD_INT 10
1069: PUSH
1070: LD_INT 12
1072: PUSH
1073: EMPTY
1074: LIST
1075: LIST
1076: PPUSH
1077: CALL 59330 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1081: LD_INT 4
1083: PPUSH
1084: LD_INT 9
1086: PUSH
1087: EMPTY
1088: LIST
1089: PPUSH
1090: CALL 59423 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1094: LD_INT 4
1096: PPUSH
1097: LD_INT 26
1099: PUSH
1100: LD_INT 74
1102: PUSH
1103: LD_INT 107
1105: PUSH
1106: LD_INT 0
1108: PUSH
1109: EMPTY
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: PUSH
1115: LD_INT 32
1117: PUSH
1118: LD_INT 77
1120: PUSH
1121: LD_INT 101
1123: PUSH
1124: LD_INT 4
1126: PUSH
1127: EMPTY
1128: LIST
1129: LIST
1130: LIST
1131: LIST
1132: PUSH
1133: LD_INT 32
1135: PUSH
1136: LD_INT 69
1138: PUSH
1139: LD_INT 86
1141: PUSH
1142: LD_INT 4
1144: PUSH
1145: EMPTY
1146: LIST
1147: LIST
1148: LIST
1149: LIST
1150: PUSH
1151: LD_INT 27
1153: PUSH
1154: LD_INT 77
1156: PUSH
1157: LD_INT 110
1159: PUSH
1160: LD_INT 3
1162: PUSH
1163: EMPTY
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: PUSH
1169: LD_INT 27
1171: PUSH
1172: LD_INT 42
1174: PUSH
1175: LD_INT 79
1177: PUSH
1178: LD_INT 5
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: LIST
1185: LIST
1186: PUSH
1187: LD_INT 29
1189: PUSH
1190: LD_INT 86
1192: PUSH
1193: LD_INT 105
1195: PUSH
1196: LD_INT 2
1198: PUSH
1199: EMPTY
1200: LIST
1201: LIST
1202: LIST
1203: LIST
1204: PUSH
1205: LD_INT 30
1207: PUSH
1208: LD_INT 40
1210: PUSH
1211: LD_INT 75
1213: PUSH
1214: LD_INT 1
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: PUSH
1223: LD_INT 32
1225: PUSH
1226: LD_INT 80
1228: PUSH
1229: LD_INT 106
1231: PUSH
1232: LD_INT 4
1234: PUSH
1235: EMPTY
1236: LIST
1237: LIST
1238: LIST
1239: LIST
1240: PUSH
1241: LD_INT 32
1243: PUSH
1244: LD_INT 75
1246: PUSH
1247: LD_INT 114
1249: PUSH
1250: LD_INT 5
1252: PUSH
1253: EMPTY
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: PUSH
1259: LD_INT 32
1261: PUSH
1262: LD_INT 82
1264: PUSH
1265: LD_INT 110
1267: PUSH
1268: LD_INT 5
1270: PUSH
1271: EMPTY
1272: LIST
1273: LIST
1274: LIST
1275: LIST
1276: PUSH
1277: LD_INT 32
1279: PUSH
1280: LD_INT 62
1282: PUSH
1283: LD_INT 78
1285: PUSH
1286: LD_INT 4
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: PUSH
1295: LD_INT 4
1297: PUSH
1298: LD_INT 39
1300: PUSH
1301: LD_INT 61
1303: PUSH
1304: LD_INT 3
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: LIST
1312: PUSH
1313: EMPTY
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: LIST
1324: LIST
1325: LIST
1326: PPUSH
1327: CALL 58480 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1331: LD_INT 4
1333: PPUSH
1334: LD_INT 5
1336: PUSH
1337: LD_INT 6
1339: PUSH
1340: LD_INT 7
1342: PUSH
1343: LD_INT 9
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: PPUSH
1352: CALL 59741 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1356: LD_INT 4
1358: PPUSH
1359: LD_INT 40
1361: PUSH
1362: LD_INT 75
1364: PUSH
1365: LD_INT 1
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: PUSH
1373: LD_INT 86
1375: PUSH
1376: LD_INT 105
1378: PUSH
1379: LD_INT 0
1381: PUSH
1382: EMPTY
1383: LIST
1384: LIST
1385: LIST
1386: PUSH
1387: EMPTY
1388: LIST
1389: LIST
1390: PPUSH
1391: CALL 58912 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1395: LD_INT 4
1397: PPUSH
1398: LD_INT 2
1400: PPUSH
1401: CALL 59203 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1405: LD_INT 4
1407: PPUSH
1408: LD_INT 0
1410: PPUSH
1411: CALL 59203 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1415: LD_INT 4
1417: PPUSH
1418: LD_INT 54
1420: PPUSH
1421: LD_INT 85
1423: PPUSH
1424: LD_INT 2
1426: PPUSH
1427: LD_INT 19
1429: PUSH
1430: LD_INT 16
1432: PUSH
1433: LD_INT 17
1435: PUSH
1436: LD_INT 18
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: PPUSH
1445: CALL 59535 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1449: LD_INT 4
1451: PPUSH
1452: LD_INT 3
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 1
1460: PUSH
1461: LD_INT 5
1463: PUSH
1464: EMPTY
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: PUSH
1470: LD_INT 4
1472: PUSH
1473: LD_INT 1
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 6
1481: PUSH
1482: EMPTY
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: PUSH
1488: LD_INT 4
1490: PUSH
1491: LD_INT 1
1493: PUSH
1494: LD_INT 1
1496: PUSH
1497: LD_INT 7
1499: PUSH
1500: EMPTY
1501: LIST
1502: LIST
1503: LIST
1504: LIST
1505: PUSH
1506: LD_INT 4
1508: PUSH
1509: LD_INT 1
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: LD_INT 6
1517: PUSH
1518: EMPTY
1519: LIST
1520: LIST
1521: LIST
1522: LIST
1523: PUSH
1524: EMPTY
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: PPUSH
1530: CALL 58588 0 2
// MC_SetTame ( 4 , powellApe ) ;
1534: LD_INT 4
1536: PPUSH
1537: LD_INT 13
1539: PPUSH
1540: CALL 59154 0 2
// end ;
1544: LD_VAR 0 1
1548: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1549: LD_EXP 36
1553: PUSH
1554: LD_EXP 17
1558: PUSH
1559: LD_INT 2
1561: GREATEREQUAL
1562: AND
1563: IFFALSE 1575
1565: GO 1567
1567: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1568: LD_STRING ACH_POWELL
1570: PPUSH
1571: CALL_OW 543
1575: END
// every 0 0$1 trigger debug do var i , tmp ;
1576: LD_EXP 1
1580: IFFALSE 1687
1582: GO 1584
1584: DISABLE
1585: LD_INT 0
1587: PPUSH
1588: PPUSH
// begin enable ;
1589: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1590: LD_ADDR_VAR 0 2
1594: PUSH
1595: LD_INT 22
1597: PUSH
1598: LD_INT 1
1600: PUSH
1601: EMPTY
1602: LIST
1603: LIST
1604: PUSH
1605: LD_INT 3
1607: PUSH
1608: LD_INT 21
1610: PUSH
1611: LD_INT 3
1613: PUSH
1614: EMPTY
1615: LIST
1616: LIST
1617: PUSH
1618: EMPTY
1619: LIST
1620: LIST
1621: PUSH
1622: LD_INT 3
1624: PUSH
1625: LD_INT 24
1627: PUSH
1628: LD_INT 999
1630: PUSH
1631: EMPTY
1632: LIST
1633: LIST
1634: PUSH
1635: EMPTY
1636: LIST
1637: LIST
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: PPUSH
1644: CALL_OW 69
1648: ST_TO_ADDR
// if not tmp then
1649: LD_VAR 0 2
1653: NOT
1654: IFFALSE 1658
// exit ;
1656: GO 1687
// for i in tmp do
1658: LD_ADDR_VAR 0 1
1662: PUSH
1663: LD_VAR 0 2
1667: PUSH
1668: FOR_IN
1669: IFFALSE 1685
// SetLives ( i , 1000 ) ;
1671: LD_VAR 0 1
1675: PPUSH
1676: LD_INT 1000
1678: PPUSH
1679: CALL_OW 234
1683: GO 1668
1685: POP
1686: POP
// end ; end_of_file
1687: PPOPN 2
1689: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1690: LD_INT 0
1692: PPUSH
// uc_side := 1 ;
1693: LD_ADDR_OWVAR 20
1697: PUSH
1698: LD_INT 1
1700: ST_TO_ADDR
// uc_nation := 1 ;
1701: LD_ADDR_OWVAR 21
1705: PUSH
1706: LD_INT 1
1708: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1709: LD_ADDR_EXP 39
1713: PUSH
1714: LD_STRING JMM
1716: PPUSH
1717: LD_EXP 1
1721: NOT
1722: PPUSH
1723: LD_STRING 14_
1725: PPUSH
1726: CALL 64980 0 3
1730: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1731: LD_EXP 4
1735: NOT
1736: PUSH
1737: LD_EXP 4
1741: PUSH
1742: LD_INT 1
1744: ARRAY
1745: PUSH
1746: LD_INT 1
1748: ARRAY
1749: NOT
1750: OR
1751: IFFALSE 1774
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1753: LD_INT 5
1755: PPUSH
1756: LD_INT 3
1758: PPUSH
1759: LD_INT 1
1761: PPUSH
1762: LD_INT 9
1764: PPUSH
1765: LD_INT 100
1767: PPUSH
1768: CALL 69804 0 5
1772: GO 1833
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1774: LD_EXP 4
1778: PUSH
1779: LD_INT 1
1781: ARRAY
1782: PUSH
1783: LD_INT 1
1785: ARRAY
1786: PPUSH
1787: LD_EXP 4
1791: PUSH
1792: LD_INT 2
1794: ARRAY
1795: PUSH
1796: LD_INT 1
1798: ARRAY
1799: PPUSH
1800: LD_EXP 4
1804: PUSH
1805: LD_INT 3
1807: ARRAY
1808: PUSH
1809: LD_INT 1
1811: ARRAY
1812: PPUSH
1813: LD_EXP 4
1817: PUSH
1818: LD_INT 4
1820: ARRAY
1821: PUSH
1822: LD_INT 1
1824: ARRAY
1825: PPUSH
1826: LD_INT 30
1828: PPUSH
1829: CALL 69804 0 5
// JMMNewVeh := CreateVehicle ;
1833: LD_ADDR_EXP 56
1837: PUSH
1838: CALL_OW 45
1842: ST_TO_ADDR
// if not JMMNewVeh then
1843: LD_EXP 56
1847: NOT
1848: IFFALSE 1879
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1850: LD_INT 5
1852: PPUSH
1853: LD_INT 3
1855: PPUSH
1856: LD_INT 1
1858: PPUSH
1859: LD_INT 9
1861: PPUSH
1862: LD_INT 100
1864: PPUSH
1865: CALL 69804 0 5
// JMMNewVeh := CreateVehicle ;
1869: LD_ADDR_EXP 56
1873: PUSH
1874: CALL_OW 45
1878: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1879: LD_EXP 56
1883: PPUSH
1884: LD_INT 4
1886: PPUSH
1887: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1891: LD_EXP 56
1895: PPUSH
1896: LD_INT 79
1898: PPUSH
1899: LD_INT 91
1901: PPUSH
1902: LD_INT 0
1904: PPUSH
1905: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1909: LD_EXP 39
1913: PPUSH
1914: LD_EXP 56
1918: PPUSH
1919: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1923: LD_EXP 6
1927: PUSH
1928: LD_EXP 2
1932: NOT
1933: AND
1934: IFFALSE 2192
// begin if not JMMGirlVeh then
1936: LD_EXP 5
1940: NOT
1941: IFFALSE 1964
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1943: LD_INT 3
1945: PPUSH
1946: LD_INT 3
1948: PPUSH
1949: LD_INT 1
1951: PPUSH
1952: LD_INT 9
1954: PPUSH
1955: LD_INT 100
1957: PPUSH
1958: CALL 69804 0 5
1962: GO 2023
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1964: LD_EXP 5
1968: PUSH
1969: LD_INT 1
1971: ARRAY
1972: PUSH
1973: LD_INT 1
1975: ARRAY
1976: PPUSH
1977: LD_EXP 5
1981: PUSH
1982: LD_INT 2
1984: ARRAY
1985: PUSH
1986: LD_INT 1
1988: ARRAY
1989: PPUSH
1990: LD_EXP 5
1994: PUSH
1995: LD_INT 3
1997: ARRAY
1998: PUSH
1999: LD_INT 1
2001: ARRAY
2002: PPUSH
2003: LD_EXP 5
2007: PUSH
2008: LD_INT 4
2010: ARRAY
2011: PUSH
2012: LD_INT 1
2014: ARRAY
2015: PPUSH
2016: LD_INT 30
2018: PPUSH
2019: CALL 69804 0 5
// GirlNewVeh := CreateVehicle ;
2023: LD_ADDR_EXP 57
2027: PUSH
2028: CALL_OW 45
2032: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2033: LD_EXP 57
2037: PPUSH
2038: LD_INT 4
2040: PPUSH
2041: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2045: LD_EXP 57
2049: PPUSH
2050: LD_INT 82
2052: PPUSH
2053: LD_INT 96
2055: PPUSH
2056: LD_INT 0
2058: PPUSH
2059: CALL_OW 48
// if JMMGirl = 1 then
2063: LD_EXP 7
2067: PUSH
2068: LD_INT 1
2070: EQUAL
2071: IFFALSE 2106
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2073: LD_ADDR_EXP 40
2077: PUSH
2078: LD_STRING Joan
2080: PPUSH
2081: LD_INT 1
2083: PPUSH
2084: LD_STRING 14_
2086: PPUSH
2087: CALL 64980 0 3
2091: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2092: LD_EXP 40
2096: PPUSH
2097: LD_EXP 57
2101: PPUSH
2102: CALL_OW 52
// end ; if JMMGirl = 2 then
2106: LD_EXP 7
2110: PUSH
2111: LD_INT 2
2113: EQUAL
2114: IFFALSE 2149
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2116: LD_ADDR_EXP 42
2120: PUSH
2121: LD_STRING Lisa
2123: PPUSH
2124: LD_INT 1
2126: PPUSH
2127: LD_STRING 14_
2129: PPUSH
2130: CALL 64980 0 3
2134: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2135: LD_EXP 42
2139: PPUSH
2140: LD_EXP 57
2144: PPUSH
2145: CALL_OW 52
// end ; if JMMGirl = 3 then
2149: LD_EXP 7
2153: PUSH
2154: LD_INT 3
2156: EQUAL
2157: IFFALSE 2192
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2159: LD_ADDR_EXP 54
2163: PUSH
2164: LD_STRING Connie
2166: PPUSH
2167: LD_INT 1
2169: PPUSH
2170: LD_STRING 14_
2172: PPUSH
2173: CALL 64980 0 3
2177: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2178: LD_EXP 54
2182: PPUSH
2183: LD_EXP 57
2187: PPUSH
2188: CALL_OW 52
// end ; end ; end ;
2192: LD_VAR 0 1
2196: RET
// export function PrepareStevensSquad ; var tmp ; begin
2197: LD_INT 0
2199: PPUSH
2200: PPUSH
// uc_side := 1 ;
2201: LD_ADDR_OWVAR 20
2205: PUSH
2206: LD_INT 1
2208: ST_TO_ADDR
// uc_nation := 1 ;
2209: LD_ADDR_OWVAR 21
2213: PUSH
2214: LD_INT 1
2216: ST_TO_ADDR
// tmp := [ ] ;
2217: LD_ADDR_VAR 0 2
2221: PUSH
2222: EMPTY
2223: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2224: LD_ADDR_EXP 41
2228: PUSH
2229: LD_STRING Stevens
2231: PPUSH
2232: LD_EXP 1
2236: NOT
2237: PPUSH
2238: LD_STRING 13f_
2240: PPUSH
2241: CALL 64980 0 3
2245: ST_TO_ADDR
// if not Stevens then
2246: LD_EXP 41
2250: NOT
2251: IFFALSE 2307
// begin hc_name = Baker Smith ;
2253: LD_ADDR_OWVAR 26
2257: PUSH
2258: LD_STRING Baker Smith
2260: ST_TO_ADDR
// hc_gallery =  ;
2261: LD_ADDR_OWVAR 33
2265: PUSH
2266: LD_STRING 
2268: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2269: LD_INT 1
2271: PPUSH
2272: LD_INT 10
2274: PPUSH
2275: CALL_OW 384
// Baker = CreateHuman ;
2279: LD_ADDR_EXP 55
2283: PUSH
2284: CALL_OW 44
2288: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2289: LD_ADDR_VAR 0 2
2293: PUSH
2294: LD_VAR 0 2
2298: PUSH
2299: LD_EXP 55
2303: ADD
2304: ST_TO_ADDR
// end else
2305: GO 2323
// tmp := tmp ^ Stevens ;
2307: LD_ADDR_VAR 0 2
2311: PUSH
2312: LD_VAR 0 2
2316: PUSH
2317: LD_EXP 41
2321: ADD
2322: ST_TO_ADDR
// if not Lisa then
2323: LD_EXP 42
2327: NOT
2328: IFFALSE 2374
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2330: LD_ADDR_EXP 42
2334: PUSH
2335: LD_STRING Lisa
2337: PPUSH
2338: LD_EXP 1
2342: NOT
2343: PPUSH
2344: LD_STRING 13f_
2346: PPUSH
2347: CALL 64980 0 3
2351: ST_TO_ADDR
// if Lisa then
2352: LD_EXP 42
2356: IFFALSE 2374
// tmp := tmp ^ Lisa ;
2358: LD_ADDR_VAR 0 2
2362: PUSH
2363: LD_VAR 0 2
2367: PUSH
2368: LD_EXP 42
2372: ADD
2373: ST_TO_ADDR
// end ; if not Donaldson then
2374: LD_EXP 43
2378: NOT
2379: IFFALSE 2425
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2381: LD_ADDR_EXP 43
2385: PUSH
2386: LD_STRING Donaldson
2388: PPUSH
2389: LD_EXP 1
2393: NOT
2394: PPUSH
2395: LD_STRING 13f_
2397: PPUSH
2398: CALL 64980 0 3
2402: ST_TO_ADDR
// if Donaldson then
2403: LD_EXP 43
2407: IFFALSE 2425
// tmp := tmp ^ Donaldson ;
2409: LD_ADDR_VAR 0 2
2413: PUSH
2414: LD_VAR 0 2
2418: PUSH
2419: LD_EXP 43
2423: ADD
2424: ST_TO_ADDR
// end ; if not Bobby then
2425: LD_EXP 44
2429: NOT
2430: IFFALSE 2476
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2432: LD_ADDR_EXP 44
2436: PUSH
2437: LD_STRING Bobby
2439: PPUSH
2440: LD_EXP 1
2444: NOT
2445: PPUSH
2446: LD_STRING 13f_
2448: PPUSH
2449: CALL 64980 0 3
2453: ST_TO_ADDR
// if Bobby then
2454: LD_EXP 44
2458: IFFALSE 2476
// tmp := tmp ^ Bobby ;
2460: LD_ADDR_VAR 0 2
2464: PUSH
2465: LD_VAR 0 2
2469: PUSH
2470: LD_EXP 44
2474: ADD
2475: ST_TO_ADDR
// end ; if not Cyrus then
2476: LD_EXP 45
2480: NOT
2481: IFFALSE 2527
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2483: LD_ADDR_EXP 45
2487: PUSH
2488: LD_STRING Cyrus
2490: PPUSH
2491: LD_EXP 1
2495: NOT
2496: PPUSH
2497: LD_STRING 13f_
2499: PPUSH
2500: CALL 64980 0 3
2504: ST_TO_ADDR
// if Cyrus then
2505: LD_EXP 45
2509: IFFALSE 2527
// tmp := tmp ^ Cyrus ;
2511: LD_ADDR_VAR 0 2
2515: PUSH
2516: LD_VAR 0 2
2520: PUSH
2521: LD_EXP 45
2525: ADD
2526: ST_TO_ADDR
// end ; if not Brown then
2527: LD_EXP 47
2531: NOT
2532: IFFALSE 2578
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2534: LD_ADDR_EXP 47
2538: PUSH
2539: LD_STRING Brown
2541: PPUSH
2542: LD_EXP 1
2546: NOT
2547: PPUSH
2548: LD_STRING 13f_
2550: PPUSH
2551: CALL 64980 0 3
2555: ST_TO_ADDR
// if Brown then
2556: LD_EXP 47
2560: IFFALSE 2578
// tmp := tmp ^ Brown ;
2562: LD_ADDR_VAR 0 2
2566: PUSH
2567: LD_VAR 0 2
2571: PUSH
2572: LD_EXP 47
2576: ADD
2577: ST_TO_ADDR
// end ; if not Gladstone then
2578: LD_EXP 48
2582: NOT
2583: IFFALSE 2629
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2585: LD_ADDR_EXP 48
2589: PUSH
2590: LD_STRING Gladstone
2592: PPUSH
2593: LD_EXP 1
2597: NOT
2598: PPUSH
2599: LD_STRING 13f_
2601: PPUSH
2602: CALL 64980 0 3
2606: ST_TO_ADDR
// if Gladstone then
2607: LD_EXP 48
2611: IFFALSE 2629
// tmp := tmp ^ Gladstone ;
2613: LD_ADDR_VAR 0 2
2617: PUSH
2618: LD_VAR 0 2
2622: PUSH
2623: LD_EXP 48
2627: ADD
2628: ST_TO_ADDR
// end ; if not Houten then
2629: LD_EXP 49
2633: NOT
2634: IFFALSE 2680
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2636: LD_ADDR_EXP 49
2640: PUSH
2641: LD_STRING Houten
2643: PPUSH
2644: LD_EXP 1
2648: NOT
2649: PPUSH
2650: LD_STRING 13f_
2652: PPUSH
2653: CALL 64980 0 3
2657: ST_TO_ADDR
// if Houten then
2658: LD_EXP 49
2662: IFFALSE 2680
// tmp := tmp ^ Houten ;
2664: LD_ADDR_VAR 0 2
2668: PUSH
2669: LD_VAR 0 2
2673: PUSH
2674: LD_EXP 49
2678: ADD
2679: ST_TO_ADDR
// end ; if not Cornel then
2680: LD_EXP 50
2684: NOT
2685: IFFALSE 2731
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2687: LD_ADDR_EXP 50
2691: PUSH
2692: LD_STRING Cornell
2694: PPUSH
2695: LD_EXP 1
2699: NOT
2700: PPUSH
2701: LD_STRING 13f_
2703: PPUSH
2704: CALL 64980 0 3
2708: ST_TO_ADDR
// if Cornel then
2709: LD_EXP 50
2713: IFFALSE 2731
// tmp := tmp ^ Cornel ;
2715: LD_ADDR_VAR 0 2
2719: PUSH
2720: LD_VAR 0 2
2724: PUSH
2725: LD_EXP 50
2729: ADD
2730: ST_TO_ADDR
// end ; if not Gary then
2731: LD_EXP 51
2735: NOT
2736: IFFALSE 2782
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2738: LD_ADDR_EXP 51
2742: PUSH
2743: LD_STRING Gary
2745: PPUSH
2746: LD_EXP 1
2750: NOT
2751: PPUSH
2752: LD_STRING 13f_
2754: PPUSH
2755: CALL 64980 0 3
2759: ST_TO_ADDR
// if Gary then
2760: LD_EXP 51
2764: IFFALSE 2782
// tmp := tmp ^ Gary ;
2766: LD_ADDR_VAR 0 2
2770: PUSH
2771: LD_VAR 0 2
2775: PUSH
2776: LD_EXP 51
2780: ADD
2781: ST_TO_ADDR
// end ; if not Frank then
2782: LD_EXP 52
2786: NOT
2787: IFFALSE 2833
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2789: LD_ADDR_EXP 52
2793: PUSH
2794: LD_STRING Frank
2796: PPUSH
2797: LD_EXP 1
2801: NOT
2802: PPUSH
2803: LD_STRING 13f_
2805: PPUSH
2806: CALL 64980 0 3
2810: ST_TO_ADDR
// if Frank then
2811: LD_EXP 52
2815: IFFALSE 2833
// tmp := tmp ^ Frank ;
2817: LD_ADDR_VAR 0 2
2821: PUSH
2822: LD_VAR 0 2
2826: PUSH
2827: LD_EXP 52
2831: ADD
2832: ST_TO_ADDR
// end ; if not Kikuchi then
2833: LD_EXP 53
2837: NOT
2838: IFFALSE 2884
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2840: LD_ADDR_EXP 53
2844: PUSH
2845: LD_STRING Kikuchi
2847: PPUSH
2848: LD_EXP 1
2852: NOT
2853: PPUSH
2854: LD_STRING 13f_
2856: PPUSH
2857: CALL 64980 0 3
2861: ST_TO_ADDR
// if Kikuchi then
2862: LD_EXP 53
2866: IFFALSE 2884
// tmp := tmp ^ Kikuchi ;
2868: LD_ADDR_VAR 0 2
2872: PUSH
2873: LD_VAR 0 2
2877: PUSH
2878: LD_EXP 53
2882: ADD
2883: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2884: LD_ADDR_VAR 0 2
2888: PUSH
2889: LD_VAR 0 2
2893: PUSH
2894: LD_STRING 13_other_survivors
2896: PPUSH
2897: CALL_OW 31
2901: UNION
2902: ST_TO_ADDR
// result := tmp ;
2903: LD_ADDR_VAR 0 1
2907: PUSH
2908: LD_VAR 0 2
2912: ST_TO_ADDR
// end ; end_of_file
2913: LD_VAR 0 1
2917: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2918: LD_INT 0
2920: PPUSH
2921: PPUSH
2922: PPUSH
2923: PPUSH
2924: PPUSH
2925: PPUSH
2926: PPUSH
2927: PPUSH
2928: PPUSH
2929: PPUSH
// uc_side := 4 ;
2930: LD_ADDR_OWVAR 20
2934: PUSH
2935: LD_INT 4
2937: ST_TO_ADDR
// uc_nation := 1 ;
2938: LD_ADDR_OWVAR 21
2942: PUSH
2943: LD_INT 1
2945: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 ] [ Difficulty ] ) ;
2946: LD_INT 387
2948: PPUSH
2949: CALL_OW 274
2953: PPUSH
2954: LD_INT 1
2956: PPUSH
2957: LD_INT 3500
2959: PUSH
2960: LD_INT 3000
2962: PUSH
2963: LD_INT 2500
2965: PUSH
2966: EMPTY
2967: LIST
2968: LIST
2969: LIST
2970: PUSH
2971: LD_OWVAR 67
2975: ARRAY
2976: PPUSH
2977: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2981: LD_INT 387
2983: PPUSH
2984: CALL_OW 274
2988: PPUSH
2989: LD_INT 2
2991: PPUSH
2992: LD_INT 400
2994: PPUSH
2995: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2999: LD_INT 387
3001: PPUSH
3002: CALL_OW 274
3006: PPUSH
3007: LD_INT 3
3009: PPUSH
3010: LD_INT 10
3012: PPUSH
3013: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3017: LD_ADDR_EXP 58
3021: PUSH
3022: LD_STRING Powell
3024: PPUSH
3025: CALL_OW 25
3029: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3030: LD_EXP 58
3034: PPUSH
3035: LD_INT 57
3037: PPUSH
3038: LD_INT 94
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3048: LD_EXP 58
3052: PPUSH
3053: LD_INT 58
3055: PPUSH
3056: LD_INT 94
3058: PPUSH
3059: CALL_OW 118
// vip := [ ] ;
3063: LD_ADDR_EXP 59
3067: PUSH
3068: EMPTY
3069: ST_TO_ADDR
// tmp := [ ] ;
3070: LD_ADDR_VAR 0 6
3074: PUSH
3075: EMPTY
3076: ST_TO_ADDR
// if JMMGirl <> 2 then
3077: LD_EXP 7
3081: PUSH
3082: LD_INT 2
3084: NONEQUAL
3085: IFFALSE 3109
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3087: LD_ADDR_EXP 42
3091: PUSH
3092: LD_STRING Lisa
3094: PPUSH
3095: LD_EXP 1
3099: NOT
3100: PPUSH
3101: LD_STRING 13s_
3103: PPUSH
3104: CALL 64980 0 3
3108: ST_TO_ADDR
// if Lisa then
3109: LD_EXP 42
3113: IFFALSE 3131
// tmp := tmp ^ Lisa ;
3115: LD_ADDR_VAR 0 6
3119: PUSH
3120: LD_VAR 0 6
3124: PUSH
3125: LD_EXP 42
3129: ADD
3130: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3131: LD_ADDR_EXP 43
3135: PUSH
3136: LD_STRING Donaldson
3138: PPUSH
3139: LD_EXP 1
3143: NOT
3144: PPUSH
3145: LD_STRING 13s_
3147: PPUSH
3148: CALL 64980 0 3
3152: ST_TO_ADDR
// if Donaldson then
3153: LD_EXP 43
3157: IFFALSE 3175
// tmp := tmp ^ Donaldson ;
3159: LD_ADDR_VAR 0 6
3163: PUSH
3164: LD_VAR 0 6
3168: PUSH
3169: LD_EXP 43
3173: ADD
3174: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3175: LD_ADDR_EXP 44
3179: PUSH
3180: LD_STRING Bobby
3182: PPUSH
3183: LD_EXP 1
3187: NOT
3188: PPUSH
3189: LD_STRING 13s_
3191: PPUSH
3192: CALL 64980 0 3
3196: ST_TO_ADDR
// if Bobby then
3197: LD_EXP 44
3201: IFFALSE 3219
// tmp := tmp ^ Bobby ;
3203: LD_ADDR_VAR 0 6
3207: PUSH
3208: LD_VAR 0 6
3212: PUSH
3213: LD_EXP 44
3217: ADD
3218: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3219: LD_ADDR_EXP 45
3223: PUSH
3224: LD_STRING Cyrus
3226: PPUSH
3227: LD_EXP 1
3231: NOT
3232: PPUSH
3233: LD_STRING 13s_
3235: PPUSH
3236: CALL 64980 0 3
3240: ST_TO_ADDR
// if Cyrus then
3241: LD_EXP 45
3245: IFFALSE 3263
// tmp := tmp ^ Cyrus ;
3247: LD_ADDR_VAR 0 6
3251: PUSH
3252: LD_VAR 0 6
3256: PUSH
3257: LD_EXP 45
3261: ADD
3262: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3263: LD_ADDR_EXP 46
3267: PUSH
3268: LD_STRING Denis
3270: PPUSH
3271: LD_EXP 1
3275: NOT
3276: PPUSH
3277: LD_STRING 13s_
3279: PPUSH
3280: CALL 64980 0 3
3284: ST_TO_ADDR
// if not Denis then
3285: LD_EXP 46
3289: NOT
3290: IFFALSE 3314
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3292: LD_ADDR_EXP 46
3296: PUSH
3297: LD_STRING Denis
3299: PPUSH
3300: LD_EXP 1
3304: NOT
3305: PPUSH
3306: LD_STRING 13f_
3308: PPUSH
3309: CALL 64980 0 3
3313: ST_TO_ADDR
// if Denis then
3314: LD_EXP 46
3318: IFFALSE 3336
// tmp := tmp ^ Denis ;
3320: LD_ADDR_VAR 0 6
3324: PUSH
3325: LD_VAR 0 6
3329: PUSH
3330: LD_EXP 46
3334: ADD
3335: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3336: LD_ADDR_EXP 47
3340: PUSH
3341: LD_STRING Brown
3343: PPUSH
3344: LD_EXP 1
3348: NOT
3349: PPUSH
3350: LD_STRING 13s_
3352: PPUSH
3353: CALL 64980 0 3
3357: ST_TO_ADDR
// if Brown then
3358: LD_EXP 47
3362: IFFALSE 3380
// tmp := tmp ^ Brown ;
3364: LD_ADDR_VAR 0 6
3368: PUSH
3369: LD_VAR 0 6
3373: PUSH
3374: LD_EXP 47
3378: ADD
3379: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3380: LD_ADDR_EXP 48
3384: PUSH
3385: LD_STRING Gladstone
3387: PPUSH
3388: LD_EXP 1
3392: NOT
3393: PPUSH
3394: LD_STRING 13s_
3396: PPUSH
3397: CALL 64980 0 3
3401: ST_TO_ADDR
// if Gladstone then
3402: LD_EXP 48
3406: IFFALSE 3424
// tmp := tmp ^ Gladstone ;
3408: LD_ADDR_VAR 0 6
3412: PUSH
3413: LD_VAR 0 6
3417: PUSH
3418: LD_EXP 48
3422: ADD
3423: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3424: LD_ADDR_EXP 49
3428: PUSH
3429: LD_STRING Houten
3431: PPUSH
3432: LD_EXP 1
3436: NOT
3437: PPUSH
3438: LD_STRING 13s_
3440: PPUSH
3441: CALL 64980 0 3
3445: ST_TO_ADDR
// if Houten then
3446: LD_EXP 49
3450: IFFALSE 3468
// tmp := tmp ^ Houten ;
3452: LD_ADDR_VAR 0 6
3456: PUSH
3457: LD_VAR 0 6
3461: PUSH
3462: LD_EXP 49
3466: ADD
3467: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3468: LD_ADDR_EXP 50
3472: PUSH
3473: LD_STRING Cornel
3475: PPUSH
3476: LD_EXP 1
3480: NOT
3481: PPUSH
3482: LD_STRING 13s_
3484: PPUSH
3485: CALL 64980 0 3
3489: ST_TO_ADDR
// if Cornel then
3490: LD_EXP 50
3494: IFFALSE 3512
// tmp := tmp ^ Cornel ;
3496: LD_ADDR_VAR 0 6
3500: PUSH
3501: LD_VAR 0 6
3505: PUSH
3506: LD_EXP 50
3510: ADD
3511: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3512: LD_ADDR_EXP 51
3516: PUSH
3517: LD_STRING Gary
3519: PPUSH
3520: LD_EXP 1
3524: NOT
3525: PPUSH
3526: LD_STRING 13s_
3528: PPUSH
3529: CALL 64980 0 3
3533: ST_TO_ADDR
// if Gary then
3534: LD_EXP 51
3538: IFFALSE 3556
// tmp := tmp ^ Gary ;
3540: LD_ADDR_VAR 0 6
3544: PUSH
3545: LD_VAR 0 6
3549: PUSH
3550: LD_EXP 51
3554: ADD
3555: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3556: LD_ADDR_EXP 52
3560: PUSH
3561: LD_STRING Frank
3563: PPUSH
3564: LD_EXP 1
3568: NOT
3569: PPUSH
3570: LD_STRING 13s_
3572: PPUSH
3573: CALL 64980 0 3
3577: ST_TO_ADDR
// if Frank then
3578: LD_EXP 52
3582: IFFALSE 3600
// tmp := tmp ^ Frank ;
3584: LD_ADDR_VAR 0 6
3588: PUSH
3589: LD_VAR 0 6
3593: PUSH
3594: LD_EXP 52
3598: ADD
3599: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3600: LD_ADDR_EXP 53
3604: PUSH
3605: LD_STRING Kikuchi
3607: PPUSH
3608: LD_EXP 1
3612: NOT
3613: PPUSH
3614: LD_STRING 13s_
3616: PPUSH
3617: CALL 64980 0 3
3621: ST_TO_ADDR
// if Kikuchi then
3622: LD_EXP 53
3626: IFFALSE 3644
// tmp := tmp ^ Kikuchi ;
3628: LD_ADDR_VAR 0 6
3632: PUSH
3633: LD_VAR 0 6
3637: PUSH
3638: LD_EXP 53
3642: ADD
3643: ST_TO_ADDR
// vip := tmp ;
3644: LD_ADDR_EXP 59
3648: PUSH
3649: LD_VAR 0 6
3653: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3654: LD_ADDR_VAR 0 6
3658: PUSH
3659: LD_VAR 0 6
3663: PUSH
3664: LD_STRING 13s_others
3666: PPUSH
3667: CALL_OW 31
3671: UNION
3672: ST_TO_ADDR
// if tmp < 20 then
3673: LD_VAR 0 6
3677: PUSH
3678: LD_INT 20
3680: LESS
3681: IFFALSE 3748
// for i = 1 to 20 - tmp do
3683: LD_ADDR_VAR 0 2
3687: PUSH
3688: DOUBLE
3689: LD_INT 1
3691: DEC
3692: ST_TO_ADDR
3693: LD_INT 20
3695: PUSH
3696: LD_VAR 0 6
3700: MINUS
3701: PUSH
3702: FOR_TO
3703: IFFALSE 3746
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3705: LD_INT 1
3707: PPUSH
3708: LD_VAR 0 2
3712: PUSH
3713: LD_INT 4
3715: MOD
3716: PUSH
3717: LD_INT 1
3719: PLUS
3720: PPUSH
3721: LD_INT 5
3723: PPUSH
3724: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3728: LD_ADDR_VAR 0 6
3732: PUSH
3733: LD_VAR 0 6
3737: PUSH
3738: CALL_OW 44
3742: ADD
3743: ST_TO_ADDR
// end ;
3744: GO 3702
3746: POP
3747: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3748: LD_ADDR_VAR 0 7
3752: PUSH
3753: LD_INT 22
3755: PUSH
3756: LD_INT 4
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: PUSH
3763: LD_INT 30
3765: PUSH
3766: LD_INT 0
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: PPUSH
3777: CALL_OW 69
3781: PUSH
3782: LD_INT 1
3784: ARRAY
3785: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3786: LD_ADDR_VAR 0 8
3790: PUSH
3791: LD_INT 22
3793: PUSH
3794: LD_INT 4
3796: PUSH
3797: EMPTY
3798: LIST
3799: LIST
3800: PUSH
3801: LD_INT 30
3803: PUSH
3804: LD_INT 6
3806: PUSH
3807: EMPTY
3808: LIST
3809: LIST
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: PPUSH
3815: CALL_OW 69
3819: PUSH
3820: LD_INT 1
3822: ARRAY
3823: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3824: LD_ADDR_VAR 0 9
3828: PUSH
3829: LD_INT 22
3831: PUSH
3832: LD_INT 4
3834: PUSH
3835: EMPTY
3836: LIST
3837: LIST
3838: PUSH
3839: LD_INT 30
3841: PUSH
3842: LD_INT 4
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: PPUSH
3853: CALL_OW 69
3857: PUSH
3858: LD_INT 1
3860: ARRAY
3861: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3862: LD_ADDR_VAR 0 10
3866: PUSH
3867: LD_INT 22
3869: PUSH
3870: LD_INT 4
3872: PUSH
3873: EMPTY
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 30
3879: PUSH
3880: LD_INT 2
3882: PUSH
3883: EMPTY
3884: LIST
3885: LIST
3886: PUSH
3887: EMPTY
3888: LIST
3889: LIST
3890: PPUSH
3891: CALL_OW 69
3895: PUSH
3896: LD_INT 1
3898: ARRAY
3899: ST_TO_ADDR
// for i in tmp do
3900: LD_ADDR_VAR 0 2
3904: PUSH
3905: LD_VAR 0 6
3909: PUSH
3910: FOR_IN
3911: IFFALSE 4037
// begin cl := GetClass ( i ) ;
3913: LD_ADDR_VAR 0 5
3917: PUSH
3918: LD_VAR 0 2
3922: PPUSH
3923: CALL_OW 257
3927: ST_TO_ADDR
// if cl > 4 then
3928: LD_VAR 0 5
3932: PUSH
3933: LD_INT 4
3935: GREATER
3936: IFFALSE 3946
// cl := 1 ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_INT 1
3945: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3946: LD_ADDR_VAR 0 3
3950: PUSH
3951: LD_VAR 0 9
3955: PUSH
3956: LD_VAR 0 7
3960: PUSH
3961: LD_VAR 0 10
3965: PUSH
3966: LD_VAR 0 8
3970: PUSH
3971: EMPTY
3972: LIST
3973: LIST
3974: LIST
3975: LIST
3976: PUSH
3977: LD_VAR 0 5
3981: ARRAY
3982: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3983: LD_VAR 0 3
3987: PPUSH
3988: CALL_OW 313
3992: PUSH
3993: LD_INT 5
3995: LESS
3996: IFFALSE 4014
// PlaceHumanInUnit ( i , b ) else
3998: LD_VAR 0 2
4002: PPUSH
4003: LD_VAR 0 3
4007: PPUSH
4008: CALL_OW 52
4012: GO 4035
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
4014: LD_VAR 0 2
4018: PPUSH
4019: LD_INT 58
4021: PPUSH
4022: LD_INT 91
4024: PPUSH
4025: LD_INT 6
4027: PPUSH
4028: LD_INT 0
4030: PPUSH
4031: CALL_OW 50
// end ;
4035: GO 3910
4037: POP
4038: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4039: LD_INT 2
4041: PPUSH
4042: LD_INT 1
4044: PPUSH
4045: LD_INT 1
4047: PPUSH
4048: LD_INT 12
4050: PPUSH
4051: LD_INT 100
4053: PPUSH
4054: CALL 69804 0 5
// veh := CreateVehicle ;
4058: LD_ADDR_VAR 0 4
4062: PUSH
4063: CALL_OW 45
4067: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4068: LD_VAR 0 4
4072: PPUSH
4073: LD_INT 4
4075: PPUSH
4076: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4080: LD_VAR 0 4
4084: PPUSH
4085: LD_INT 49
4087: PPUSH
4088: LD_INT 88
4090: PPUSH
4091: LD_INT 0
4093: PPUSH
4094: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4098: LD_VAR 0 4
4102: PPUSH
4103: LD_INT 1
4105: PPUSH
4106: LD_INT 100
4108: PPUSH
4109: CALL_OW 290
// uc_side := 0 ;
4113: LD_ADDR_OWVAR 20
4117: PUSH
4118: LD_INT 0
4120: ST_TO_ADDR
// uc_nation := 0 ;
4121: LD_ADDR_OWVAR 21
4125: PUSH
4126: LD_INT 0
4128: ST_TO_ADDR
// for i = 1 to 4 do
4129: LD_ADDR_VAR 0 2
4133: PUSH
4134: DOUBLE
4135: LD_INT 1
4137: DEC
4138: ST_TO_ADDR
4139: LD_INT 4
4141: PUSH
4142: FOR_TO
4143: IFFALSE 4174
// begin InitHc ;
4145: CALL_OW 19
// hc_class := class_apeman ;
4149: LD_ADDR_OWVAR 28
4153: PUSH
4154: LD_INT 12
4156: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4157: CALL_OW 44
4161: PPUSH
4162: LD_INT 13
4164: PPUSH
4165: LD_INT 0
4167: PPUSH
4168: CALL_OW 49
// end ;
4172: GO 4142
4174: POP
4175: POP
// end ; end_of_file
4176: LD_VAR 0 1
4180: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4181: LD_INT 0
4183: PPUSH
4184: PPUSH
4185: PPUSH
4186: PPUSH
4187: PPUSH
// side := 8 ;
4188: LD_ADDR_VAR 0 3
4192: PUSH
4193: LD_INT 8
4195: ST_TO_ADDR
// uc_side := side ;
4196: LD_ADDR_OWVAR 20
4200: PUSH
4201: LD_VAR 0 3
4205: ST_TO_ADDR
// uc_nation := 2 ;
4206: LD_ADDR_OWVAR 21
4210: PUSH
4211: LD_INT 2
4213: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4214: LD_ADDR_VAR 0 2
4218: PUSH
4219: LD_INT 22
4221: PUSH
4222: LD_VAR 0 3
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: PUSH
4231: LD_INT 21
4233: PUSH
4234: LD_INT 3
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: PPUSH
4245: CALL_OW 69
4249: PUSH
4250: FOR_IN
4251: IFFALSE 4267
// SetBLevel ( i , 10 ) ;
4253: LD_VAR 0 2
4257: PPUSH
4258: LD_INT 10
4260: PPUSH
4261: CALL_OW 241
4265: GO 4250
4267: POP
4268: POP
// if KurtStatus then
4269: LD_EXP 3
4273: IFFALSE 4296
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4275: LD_ADDR_EXP 60
4279: PUSH
4280: LD_STRING Kurt
4282: PPUSH
4283: LD_INT 0
4285: PPUSH
4286: LD_STRING 
4288: PPUSH
4289: CALL 64980 0 3
4293: ST_TO_ADDR
4294: GO 4318
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4296: LD_ADDR_EXP 60
4300: PUSH
4301: LD_STRING AltKurt
4303: PPUSH
4304: LD_EXP 1
4308: NOT
4309: PPUSH
4310: LD_STRING 
4312: PPUSH
4313: CALL 64980 0 3
4317: ST_TO_ADDR
// if not Kurt then
4318: LD_EXP 60
4322: NOT
4323: IFFALSE 4349
// begin InitHc ;
4325: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4329: LD_INT 1
4331: PPUSH
4332: LD_INT 10
4334: PPUSH
4335: CALL_OW 381
// Kurt := CreateHuman ;
4339: LD_ADDR_EXP 60
4343: PUSH
4344: CALL_OW 44
4348: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4349: LD_EXP 60
4353: PPUSH
4354: LD_INT 324
4356: PPUSH
4357: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4361: LD_ADDR_EXP 61
4365: PUSH
4366: LD_STRING Kozlov
4368: PPUSH
4369: LD_INT 0
4371: PPUSH
4372: LD_STRING 
4374: PPUSH
4375: CALL 64980 0 3
4379: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4380: LD_EXP 61
4384: PPUSH
4385: LD_INT 22
4387: PUSH
4388: LD_INT 8
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: LD_INT 23
4397: PUSH
4398: LD_INT 3
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: PUSH
4405: LD_INT 30
4407: PUSH
4408: LD_INT 8
4410: PUSH
4411: EMPTY
4412: LIST
4413: LIST
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PPUSH
4420: CALL_OW 69
4424: PUSH
4425: LD_INT 1
4427: ARRAY
4428: PPUSH
4429: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4433: LD_EXP 61
4437: PPUSH
4438: LD_INT 3
4440: PPUSH
4441: LD_INT 10
4443: PPUSH
4444: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4448: LD_ADDR_VAR 0 5
4452: PUSH
4453: LD_INT 22
4455: PUSH
4456: LD_VAR 0 3
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: PUSH
4465: LD_INT 30
4467: PUSH
4468: LD_INT 32
4470: PUSH
4471: EMPTY
4472: LIST
4473: LIST
4474: PUSH
4475: LD_INT 58
4477: PUSH
4478: EMPTY
4479: LIST
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: LIST
4485: PPUSH
4486: CALL_OW 69
4490: ST_TO_ADDR
// for i = 1 to 10 do
4491: LD_ADDR_VAR 0 2
4495: PUSH
4496: DOUBLE
4497: LD_INT 1
4499: DEC
4500: ST_TO_ADDR
4501: LD_INT 10
4503: PUSH
4504: FOR_TO
4505: IFFALSE 4577
// begin uc_nation := nation_nature ;
4507: LD_ADDR_OWVAR 21
4511: PUSH
4512: LD_INT 0
4514: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4515: LD_ADDR_OWVAR 28
4519: PUSH
4520: LD_INT 15
4522: ST_TO_ADDR
// hc_gallery :=  ;
4523: LD_ADDR_OWVAR 33
4527: PUSH
4528: LD_STRING 
4530: ST_TO_ADDR
// hc_name :=  ;
4531: LD_ADDR_OWVAR 26
4535: PUSH
4536: LD_STRING 
4538: ST_TO_ADDR
// un := CreateHuman ;
4539: LD_ADDR_VAR 0 4
4543: PUSH
4544: CALL_OW 44
4548: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4549: LD_VAR 0 4
4553: PPUSH
4554: LD_VAR 0 5
4558: PUSH
4559: LD_VAR 0 5
4563: PUSH
4564: LD_VAR 0 2
4568: MINUS
4569: ARRAY
4570: PPUSH
4571: CALL_OW 52
// end ;
4575: GO 4504
4577: POP
4578: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4579: LD_ADDR_VAR 0 5
4583: PUSH
4584: LD_STRING 12_kurt_squad
4586: PPUSH
4587: CALL_OW 31
4591: ST_TO_ADDR
// if tmp then
4592: LD_VAR 0 5
4596: IFFALSE 4630
// for i in tmp do
4598: LD_ADDR_VAR 0 2
4602: PUSH
4603: LD_VAR 0 5
4607: PUSH
4608: FOR_IN
4609: IFFALSE 4628
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4611: LD_VAR 0 2
4615: PPUSH
4616: LD_INT 5
4618: PPUSH
4619: LD_INT 0
4621: PPUSH
4622: CALL_OW 49
4626: GO 4608
4628: POP
4629: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4630: LD_INT 324
4632: PPUSH
4633: LD_INT 5
4635: PPUSH
4636: LD_STRING 
4638: PPUSH
4639: LD_INT 8
4641: PUSH
4642: LD_INT 9
4644: PUSH
4645: LD_INT 10
4647: PUSH
4648: EMPTY
4649: LIST
4650: LIST
4651: LIST
4652: PUSH
4653: LD_OWVAR 67
4657: ARRAY
4658: PPUSH
4659: LD_INT 3000
4661: PUSH
4662: LD_INT 500
4664: PUSH
4665: LD_INT 150
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: LIST
4672: PPUSH
4673: LD_INT 16
4675: PUSH
4676: LD_INT 6
4678: PUSH
4679: LD_INT 6
4681: PUSH
4682: LD_INT 8
4684: PUSH
4685: EMPTY
4686: LIST
4687: LIST
4688: LIST
4689: LIST
4690: PPUSH
4691: CALL 73213 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4695: LD_ADDR_EXP 110
4699: PUSH
4700: LD_EXP 110
4704: PPUSH
4705: LD_INT 3
4707: PPUSH
4708: LD_INT 22
4710: PUSH
4711: LD_VAR 0 3
4715: PUSH
4716: EMPTY
4717: LIST
4718: LIST
4719: PUSH
4720: LD_INT 23
4722: PUSH
4723: LD_INT 2
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: LD_INT 3
4732: PUSH
4733: LD_INT 21
4735: PUSH
4736: LD_INT 2
4738: PUSH
4739: EMPTY
4740: LIST
4741: LIST
4742: PUSH
4743: EMPTY
4744: LIST
4745: LIST
4746: PUSH
4747: EMPTY
4748: LIST
4749: LIST
4750: LIST
4751: PPUSH
4752: CALL_OW 69
4756: PUSH
4757: LD_EXP 60
4761: DIFF
4762: PPUSH
4763: CALL_OW 1
4767: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4768: LD_INT 1
4770: PPUSH
4771: LD_INT 7
4773: PPUSH
4774: CALL_OW 383
// Friend := CreateHuman ;
4778: LD_ADDR_EXP 62
4782: PUSH
4783: CALL_OW 44
4787: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4788: LD_INT 14
4790: PPUSH
4791: LD_INT 3
4793: PPUSH
4794: LD_INT 1
4796: PPUSH
4797: LD_INT 29
4799: PPUSH
4800: LD_INT 100
4802: PPUSH
4803: CALL 69804 0 5
// powellBomb := CreateVehicle ;
4807: LD_ADDR_EXP 63
4811: PUSH
4812: CALL_OW 45
4816: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4817: LD_EXP 63
4821: PPUSH
4822: LD_INT 90
4824: PPUSH
4825: LD_INT 51
4827: PPUSH
4828: LD_INT 0
4830: PPUSH
4831: CALL_OW 48
// end ;
4835: LD_VAR 0 1
4839: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4840: LD_INT 0
4842: PPUSH
4843: PPUSH
4844: PPUSH
// if IsLive ( kozlov_fac ) then
4845: LD_INT 332
4847: PPUSH
4848: CALL_OW 300
4852: IFFALSE 4856
// exit ;
4854: GO 5423
// ComExitBuilding ( Kozlov ) ;
4856: LD_EXP 61
4860: PPUSH
4861: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4865: LD_EXP 61
4869: PPUSH
4870: CALL_OW 257
4874: PUSH
4875: LD_INT 2
4877: NONEQUAL
4878: IFFALSE 4913
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4880: LD_EXP 61
4884: PPUSH
4885: LD_INT 324
4887: PPUSH
4888: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4892: LD_EXP 61
4896: PPUSH
4897: LD_INT 2
4899: PPUSH
4900: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4904: LD_EXP 61
4908: PPUSH
4909: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4913: LD_EXP 61
4917: PPUSH
4918: LD_INT 2
4920: PPUSH
4921: LD_INT 93
4923: PPUSH
4924: LD_INT 32
4926: PPUSH
4927: LD_INT 3
4929: PPUSH
4930: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4934: LD_INT 35
4936: PPUSH
4937: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4941: LD_INT 22
4943: PUSH
4944: LD_INT 8
4946: PUSH
4947: EMPTY
4948: LIST
4949: LIST
4950: PUSH
4951: LD_INT 30
4953: PUSH
4954: LD_INT 3
4956: PUSH
4957: EMPTY
4958: LIST
4959: LIST
4960: PUSH
4961: LD_INT 23
4963: PUSH
4964: LD_INT 3
4966: PUSH
4967: EMPTY
4968: LIST
4969: LIST
4970: PUSH
4971: LD_INT 57
4973: PUSH
4974: EMPTY
4975: LIST
4976: PUSH
4977: EMPTY
4978: LIST
4979: LIST
4980: LIST
4981: LIST
4982: PPUSH
4983: CALL_OW 69
4987: IFFALSE 4934
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4989: LD_ADDR_VAR 0 2
4993: PUSH
4994: LD_INT 22
4996: PUSH
4997: LD_INT 8
4999: PUSH
5000: EMPTY
5001: LIST
5002: LIST
5003: PUSH
5004: LD_INT 30
5006: PUSH
5007: LD_INT 3
5009: PUSH
5010: EMPTY
5011: LIST
5012: LIST
5013: PUSH
5014: LD_INT 23
5016: PUSH
5017: LD_INT 3
5019: PUSH
5020: EMPTY
5021: LIST
5022: LIST
5023: PUSH
5024: LD_INT 57
5026: PUSH
5027: EMPTY
5028: LIST
5029: PUSH
5030: EMPTY
5031: LIST
5032: LIST
5033: LIST
5034: LIST
5035: PPUSH
5036: CALL_OW 69
5040: PUSH
5041: LD_INT 1
5043: ARRAY
5044: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5045: LD_INT 22
5047: PUSH
5048: LD_INT 8
5050: PUSH
5051: EMPTY
5052: LIST
5053: LIST
5054: PUSH
5055: LD_INT 23
5057: PUSH
5058: LD_INT 3
5060: PUSH
5061: EMPTY
5062: LIST
5063: LIST
5064: PUSH
5065: LD_INT 30
5067: PUSH
5068: LD_INT 21
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: PUSH
5075: EMPTY
5076: LIST
5077: LIST
5078: LIST
5079: PPUSH
5080: CALL_OW 69
5084: NOT
5085: IFFALSE 5163
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5087: LD_EXP 61
5091: PPUSH
5092: LD_INT 21
5094: PPUSH
5095: LD_INT 97
5097: PPUSH
5098: LD_INT 36
5100: PPUSH
5101: LD_INT 5
5103: PPUSH
5104: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5108: LD_INT 35
5110: PPUSH
5111: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5115: LD_INT 22
5117: PUSH
5118: LD_INT 8
5120: PUSH
5121: EMPTY
5122: LIST
5123: LIST
5124: PUSH
5125: LD_INT 23
5127: PUSH
5128: LD_INT 3
5130: PUSH
5131: EMPTY
5132: LIST
5133: LIST
5134: PUSH
5135: LD_INT 30
5137: PUSH
5138: LD_INT 21
5140: PUSH
5141: EMPTY
5142: LIST
5143: LIST
5144: PUSH
5145: LD_INT 57
5147: PUSH
5148: EMPTY
5149: LIST
5150: PUSH
5151: EMPTY
5152: LIST
5153: LIST
5154: LIST
5155: LIST
5156: PPUSH
5157: CALL_OW 69
5161: IFFALSE 5108
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5163: LD_INT 22
5165: PUSH
5166: LD_INT 8
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: PUSH
5173: LD_INT 23
5175: PUSH
5176: LD_INT 3
5178: PUSH
5179: EMPTY
5180: LIST
5181: LIST
5182: PUSH
5183: LD_INT 30
5185: PUSH
5186: LD_INT 18
5188: PUSH
5189: EMPTY
5190: LIST
5191: LIST
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: LIST
5197: PPUSH
5198: CALL_OW 69
5202: NOT
5203: IFFALSE 5281
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5205: LD_EXP 61
5209: PPUSH
5210: LD_INT 18
5212: PPUSH
5213: LD_INT 89
5215: PPUSH
5216: LD_INT 32
5218: PPUSH
5219: LD_INT 1
5221: PPUSH
5222: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5226: LD_INT 35
5228: PPUSH
5229: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5233: LD_INT 22
5235: PUSH
5236: LD_INT 8
5238: PUSH
5239: EMPTY
5240: LIST
5241: LIST
5242: PUSH
5243: LD_INT 23
5245: PUSH
5246: LD_INT 3
5248: PUSH
5249: EMPTY
5250: LIST
5251: LIST
5252: PUSH
5253: LD_INT 30
5255: PUSH
5256: LD_INT 18
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: PUSH
5263: LD_INT 57
5265: PUSH
5266: EMPTY
5267: LIST
5268: PUSH
5269: EMPTY
5270: LIST
5271: LIST
5272: LIST
5273: LIST
5274: PPUSH
5275: CALL_OW 69
5279: IFFALSE 5226
// end ; lab := kozlov_lab ;
5281: LD_ADDR_VAR 0 3
5285: PUSH
5286: LD_INT 336
5288: ST_TO_ADDR
// if not lab then
5289: LD_VAR 0 3
5293: NOT
5294: IFFALSE 5298
// exit ;
5296: GO 5423
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5298: LD_EXP 61
5302: PPUSH
5303: LD_VAR 0 3
5307: PUSH
5308: LD_INT 1
5310: ARRAY
5311: PPUSH
5312: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5316: LD_EXP 61
5320: PPUSH
5321: LD_INT 4
5323: PPUSH
5324: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5328: LD_VAR 0 3
5332: PUSH
5333: LD_INT 1
5335: ARRAY
5336: PPUSH
5337: LD_INT 25
5339: PPUSH
5340: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5344: LD_INT 35
5346: PPUSH
5347: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5351: LD_INT 25
5353: PPUSH
5354: LD_INT 8
5356: PPUSH
5357: CALL_OW 321
5361: PUSH
5362: LD_INT 2
5364: EQUAL
5365: IFFALSE 5344
// ComExitBuilding ( Kozlov ) ;
5367: LD_EXP 61
5371: PPUSH
5372: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5376: LD_EXP 61
5380: PPUSH
5381: LD_VAR 0 2
5385: PPUSH
5386: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5390: LD_EXP 61
5394: PPUSH
5395: LD_INT 3
5397: PPUSH
5398: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5402: LD_VAR 0 2
5406: PPUSH
5407: LD_INT 23
5409: PPUSH
5410: LD_INT 3
5412: PPUSH
5413: LD_INT 1
5415: PPUSH
5416: LD_INT 48
5418: PPUSH
5419: CALL_OW 125
// end ;
5423: LD_VAR 0 1
5427: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5428: LD_EXP 22
5432: NOT
5433: PUSH
5434: LD_EXP 15
5438: PUSH
5439: LD_INT 6
5441: GREATEREQUAL
5442: AND
5443: IFFALSE 5524
5445: GO 5447
5447: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5448: LD_INT 3
5450: PPUSH
5451: LD_INT 3
5453: PPUSH
5454: CALL 58773 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5458: LD_INT 3
5460: PPUSH
5461: LD_INT 14
5463: PUSH
5464: LD_INT 1
5466: PUSH
5467: LD_INT 1
5469: PUSH
5470: LD_INT 28
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: LIST
5477: LIST
5478: PUSH
5479: LD_INT 14
5481: PUSH
5482: LD_INT 1
5484: PUSH
5485: LD_INT 1
5487: PUSH
5488: LD_INT 28
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: LIST
5495: LIST
5496: PUSH
5497: LD_INT 14
5499: PUSH
5500: LD_INT 1
5502: PUSH
5503: LD_INT 1
5505: PUSH
5506: LD_INT 28
5508: PUSH
5509: EMPTY
5510: LIST
5511: LIST
5512: LIST
5513: LIST
5514: PUSH
5515: EMPTY
5516: LIST
5517: LIST
5518: LIST
5519: PPUSH
5520: CALL 58636 0 2
// end ;
5524: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5525: LD_EXP 22
5529: NOT
5530: PUSH
5531: LD_EXP 15
5535: PUSH
5536: LD_INT 6
5538: GREATEREQUAL
5539: AND
5540: PUSH
5541: LD_INT 3
5543: PPUSH
5544: LD_INT 1
5546: PPUSH
5547: CALL 60054 0 2
5551: NOT
5552: AND
5553: IFFALSE 6393
5555: GO 5557
5557: DISABLE
5558: LD_INT 0
5560: PPUSH
5561: PPUSH
5562: PPUSH
// begin enable ;
5563: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5564: LD_INT 22
5566: PUSH
5567: LD_INT 8
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: PUSH
5574: LD_INT 23
5576: PUSH
5577: LD_INT 2
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: PUSH
5584: LD_INT 30
5586: PUSH
5587: LD_INT 3
5589: PUSH
5590: EMPTY
5591: LIST
5592: LIST
5593: PUSH
5594: EMPTY
5595: LIST
5596: LIST
5597: LIST
5598: PPUSH
5599: CALL_OW 69
5603: NOT
5604: IFFALSE 5608
// exit ;
5606: GO 6393
// if Prob ( 40 ) then
5608: LD_INT 40
5610: PPUSH
5611: CALL_OW 13
5615: IFFALSE 5742
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5617: LD_INT 3
5619: PPUSH
5620: LD_INT 14
5622: PUSH
5623: LD_INT 1
5625: PUSH
5626: LD_INT 2
5628: PUSH
5629: LD_INT 28
5631: PUSH
5632: EMPTY
5633: LIST
5634: LIST
5635: LIST
5636: LIST
5637: PUSH
5638: LD_INT 14
5640: PUSH
5641: LD_INT 1
5643: PUSH
5644: LD_INT 2
5646: PUSH
5647: LD_INT 28
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: LIST
5654: LIST
5655: PUSH
5656: LD_INT 14
5658: PUSH
5659: LD_INT 1
5661: PUSH
5662: LD_INT 2
5664: PUSH
5665: LD_INT 28
5667: PUSH
5668: EMPTY
5669: LIST
5670: LIST
5671: LIST
5672: LIST
5673: PUSH
5674: LD_INT 14
5676: PUSH
5677: LD_INT 1
5679: PUSH
5680: LD_INT 2
5682: PUSH
5683: LD_INT 28
5685: PUSH
5686: EMPTY
5687: LIST
5688: LIST
5689: LIST
5690: LIST
5691: PUSH
5692: LD_INT 14
5694: PUSH
5695: LD_INT 1
5697: PUSH
5698: LD_INT 2
5700: PUSH
5701: LD_INT 28
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: LIST
5708: LIST
5709: PUSH
5710: LD_INT 14
5712: PUSH
5713: LD_INT 1
5715: PUSH
5716: LD_INT 2
5718: PUSH
5719: LD_INT 26
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: LIST
5726: LIST
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: LIST
5732: LIST
5733: LIST
5734: LIST
5735: PPUSH
5736: CALL 58636 0 2
// end else
5740: GO 5933
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5742: LD_INT 3
5744: PPUSH
5745: LD_INT 14
5747: PUSH
5748: LD_INT 1
5750: PUSH
5751: LD_INT 2
5753: PUSH
5754: LD_INT 27
5756: PUSH
5757: LD_INT 26
5759: PUSH
5760: LD_INT 26
5762: PUSH
5763: EMPTY
5764: LIST
5765: LIST
5766: LIST
5767: PUSH
5768: LD_OWVAR 67
5772: ARRAY
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: LIST
5778: LIST
5779: PUSH
5780: LD_INT 14
5782: PUSH
5783: LD_INT 1
5785: PUSH
5786: LD_INT 2
5788: PUSH
5789: LD_INT 27
5791: PUSH
5792: LD_INT 26
5794: PUSH
5795: LD_INT 26
5797: PUSH
5798: EMPTY
5799: LIST
5800: LIST
5801: LIST
5802: PUSH
5803: LD_OWVAR 67
5807: ARRAY
5808: PUSH
5809: EMPTY
5810: LIST
5811: LIST
5812: LIST
5813: LIST
5814: PUSH
5815: LD_INT 14
5817: PUSH
5818: LD_INT 1
5820: PUSH
5821: LD_INT 2
5823: PUSH
5824: LD_INT 26
5826: PUSH
5827: LD_INT 26
5829: PUSH
5830: LD_INT 29
5832: PUSH
5833: EMPTY
5834: LIST
5835: LIST
5836: LIST
5837: PUSH
5838: LD_OWVAR 67
5842: ARRAY
5843: PUSH
5844: EMPTY
5845: LIST
5846: LIST
5847: LIST
5848: LIST
5849: PUSH
5850: LD_INT 13
5852: PUSH
5853: LD_INT 1
5855: PUSH
5856: LD_INT 2
5858: PUSH
5859: LD_INT 26
5861: PUSH
5862: LD_INT 29
5864: PUSH
5865: LD_INT 29
5867: PUSH
5868: EMPTY
5869: LIST
5870: LIST
5871: LIST
5872: PUSH
5873: LD_OWVAR 67
5877: ARRAY
5878: PUSH
5879: EMPTY
5880: LIST
5881: LIST
5882: LIST
5883: LIST
5884: PUSH
5885: LD_INT 13
5887: PUSH
5888: LD_INT 1
5890: PUSH
5891: LD_INT 2
5893: PUSH
5894: LD_INT 29
5896: PUSH
5897: EMPTY
5898: LIST
5899: LIST
5900: LIST
5901: LIST
5902: PUSH
5903: LD_INT 14
5905: PUSH
5906: LD_INT 1
5908: PUSH
5909: LD_INT 2
5911: PUSH
5912: LD_INT 26
5914: PUSH
5915: EMPTY
5916: LIST
5917: LIST
5918: LIST
5919: LIST
5920: PUSH
5921: EMPTY
5922: LIST
5923: LIST
5924: LIST
5925: LIST
5926: LIST
5927: LIST
5928: PPUSH
5929: CALL 58636 0 2
// end ; repeat wait ( 0 0$1 ) ;
5933: LD_INT 35
5935: PPUSH
5936: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5940: LD_INT 3
5942: PPUSH
5943: LD_INT 1
5945: PPUSH
5946: CALL 60054 0 2
5950: PUSH
5951: LD_INT 6
5953: GREATEREQUAL
5954: IFFALSE 5933
// wait ( 0 0$30 ) ;
5956: LD_INT 1050
5958: PPUSH
5959: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5963: LD_ADDR_VAR 0 2
5967: PUSH
5968: LD_INT 3
5970: PPUSH
5971: LD_INT 1
5973: PPUSH
5974: CALL 60054 0 2
5978: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5979: LD_ADDR_EXP 129
5983: PUSH
5984: LD_EXP 129
5988: PPUSH
5989: LD_INT 3
5991: PPUSH
5992: LD_EXP 129
5996: PUSH
5997: LD_INT 3
5999: ARRAY
6000: PUSH
6001: LD_VAR 0 2
6005: DIFF
6006: PPUSH
6007: CALL_OW 1
6011: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6012: LD_ADDR_VAR 0 3
6016: PUSH
6017: LD_INT 0
6019: PPUSH
6020: LD_INT 2
6022: PPUSH
6023: CALL_OW 12
6027: ST_TO_ADDR
// if target then
6028: LD_VAR 0 3
6032: IFFALSE 6160
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6034: LD_ADDR_VAR 0 2
6038: PUSH
6039: LD_VAR 0 2
6043: PPUSH
6044: LD_INT 24
6046: PUSH
6047: LD_INT 250
6049: PUSH
6050: EMPTY
6051: LIST
6052: LIST
6053: PPUSH
6054: CALL_OW 72
6058: ST_TO_ADDR
// for i in tmp do
6059: LD_ADDR_VAR 0 1
6063: PUSH
6064: LD_VAR 0 2
6068: PUSH
6069: FOR_IN
6070: IFFALSE 6110
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6072: LD_VAR 0 1
6076: PPUSH
6077: LD_INT 89
6079: PPUSH
6080: LD_INT 71
6082: PPUSH
6083: CALL_OW 297
6087: PUSH
6088: LD_INT 9
6090: GREATER
6091: IFFALSE 6108
// ComMoveXY ( i , 89 , 71 ) ;
6093: LD_VAR 0 1
6097: PPUSH
6098: LD_INT 89
6100: PPUSH
6101: LD_INT 71
6103: PPUSH
6104: CALL_OW 111
6108: GO 6069
6110: POP
6111: POP
// wait ( 0 0$1 ) ;
6112: LD_INT 35
6114: PPUSH
6115: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6119: LD_VAR 0 2
6123: PPUSH
6124: LD_INT 92
6126: PUSH
6127: LD_INT 89
6129: PUSH
6130: LD_INT 71
6132: PUSH
6133: LD_INT 9
6135: PUSH
6136: EMPTY
6137: LIST
6138: LIST
6139: LIST
6140: LIST
6141: PPUSH
6142: CALL_OW 72
6146: PUSH
6147: LD_VAR 0 2
6151: PUSH
6152: LD_INT 1
6154: MINUS
6155: GREATEREQUAL
6156: IFFALSE 6034
// end else
6158: GO 6284
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6160: LD_ADDR_VAR 0 2
6164: PUSH
6165: LD_VAR 0 2
6169: PPUSH
6170: LD_INT 24
6172: PUSH
6173: LD_INT 250
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: PPUSH
6180: CALL_OW 72
6184: ST_TO_ADDR
// for i in tmp do
6185: LD_ADDR_VAR 0 1
6189: PUSH
6190: LD_VAR 0 2
6194: PUSH
6195: FOR_IN
6196: IFFALSE 6236
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6198: LD_VAR 0 1
6202: PPUSH
6203: LD_INT 125
6205: PPUSH
6206: LD_INT 129
6208: PPUSH
6209: CALL_OW 297
6213: PUSH
6214: LD_INT 9
6216: GREATER
6217: IFFALSE 6234
// ComMoveXY ( i , 125 , 129 ) ;
6219: LD_VAR 0 1
6223: PPUSH
6224: LD_INT 125
6226: PPUSH
6227: LD_INT 129
6229: PPUSH
6230: CALL_OW 111
6234: GO 6195
6236: POP
6237: POP
// wait ( 0 0$1 ) ;
6238: LD_INT 35
6240: PPUSH
6241: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6245: LD_VAR 0 2
6249: PPUSH
6250: LD_INT 92
6252: PUSH
6253: LD_INT 125
6255: PUSH
6256: LD_INT 129
6258: PUSH
6259: LD_INT 9
6261: PUSH
6262: EMPTY
6263: LIST
6264: LIST
6265: LIST
6266: LIST
6267: PPUSH
6268: CALL_OW 72
6272: PUSH
6273: LD_VAR 0 2
6277: PUSH
6278: LD_INT 1
6280: MINUS
6281: GREATEREQUAL
6282: IFFALSE 6160
// end ; repeat wait ( 0 0$1 ) ;
6284: LD_INT 35
6286: PPUSH
6287: CALL_OW 67
// for i in tmp do
6291: LD_ADDR_VAR 0 1
6295: PUSH
6296: LD_VAR 0 2
6300: PUSH
6301: FOR_IN
6302: IFFALSE 6384
// begin if GetLives ( i ) > 251 then
6304: LD_VAR 0 1
6308: PPUSH
6309: CALL_OW 256
6313: PUSH
6314: LD_INT 251
6316: GREATER
6317: IFFALSE 6355
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6319: LD_VAR 0 1
6323: PPUSH
6324: LD_INT 81
6326: PUSH
6327: LD_INT 8
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: PPUSH
6334: CALL_OW 69
6338: PPUSH
6339: LD_VAR 0 1
6343: PPUSH
6344: CALL_OW 74
6348: PPUSH
6349: CALL_OW 115
6353: GO 6382
// if IsDead ( i ) then
6355: LD_VAR 0 1
6359: PPUSH
6360: CALL_OW 301
6364: IFFALSE 6382
// tmp := tmp diff i ;
6366: LD_ADDR_VAR 0 2
6370: PUSH
6371: LD_VAR 0 2
6375: PUSH
6376: LD_VAR 0 1
6380: DIFF
6381: ST_TO_ADDR
// end ;
6382: GO 6301
6384: POP
6385: POP
// until not tmp ;
6386: LD_VAR 0 2
6390: NOT
6391: IFFALSE 6284
// end ;
6393: PPOPN 3
6395: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6396: LD_EXP 22
6400: NOT
6401: PUSH
6402: LD_EXP 15
6406: PUSH
6407: LD_INT 6
6409: GREATEREQUAL
6410: AND
6411: PUSH
6412: LD_OWVAR 67
6416: PUSH
6417: LD_INT 1
6419: GREATER
6420: AND
6421: IFFALSE 6938
6423: GO 6425
6425: DISABLE
6426: LD_INT 0
6428: PPUSH
6429: PPUSH
6430: PPUSH
// begin enable ;
6431: ENABLE
// tmp := [ ] ;
6432: LD_ADDR_VAR 0 3
6436: PUSH
6437: EMPTY
6438: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6439: LD_ADDR_VAR 0 1
6443: PUSH
6444: DOUBLE
6445: LD_INT 1
6447: DEC
6448: ST_TO_ADDR
6449: LD_INT 4
6451: PUSH
6452: LD_INT 6
6454: PUSH
6455: LD_INT 7
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: LIST
6462: PUSH
6463: LD_OWVAR 67
6467: ARRAY
6468: PUSH
6469: FOR_TO
6470: IFFALSE 6630
// begin uc_side := 8 ;
6472: LD_ADDR_OWVAR 20
6476: PUSH
6477: LD_INT 8
6479: ST_TO_ADDR
// uc_nation := 2 ;
6480: LD_ADDR_OWVAR 21
6484: PUSH
6485: LD_INT 2
6487: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6488: LD_INT 13
6490: PUSH
6491: LD_INT 14
6493: PUSH
6494: EMPTY
6495: LIST
6496: LIST
6497: PUSH
6498: LD_INT 1
6500: PPUSH
6501: LD_INT 2
6503: PPUSH
6504: CALL_OW 12
6508: ARRAY
6509: PPUSH
6510: LD_INT 1
6512: PPUSH
6513: LD_INT 5
6515: PPUSH
6516: LD_INT 27
6518: PUSH
6519: LD_INT 28
6521: PUSH
6522: LD_INT 26
6524: PUSH
6525: LD_INT 25
6527: PUSH
6528: EMPTY
6529: LIST
6530: LIST
6531: LIST
6532: LIST
6533: PUSH
6534: LD_INT 1
6536: PPUSH
6537: LD_INT 4
6539: PPUSH
6540: CALL_OW 12
6544: ARRAY
6545: PPUSH
6546: LD_INT 88
6548: PPUSH
6549: CALL 69804 0 5
// un := CreateVehicle ;
6553: LD_ADDR_VAR 0 2
6557: PUSH
6558: CALL_OW 45
6562: ST_TO_ADDR
// tmp := tmp ^ un ;
6563: LD_ADDR_VAR 0 3
6567: PUSH
6568: LD_VAR 0 3
6572: PUSH
6573: LD_VAR 0 2
6577: ADD
6578: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6579: LD_VAR 0 2
6583: PPUSH
6584: LD_INT 3
6586: PPUSH
6587: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6591: LD_VAR 0 2
6595: PPUSH
6596: LD_INT 30
6598: PPUSH
6599: LD_INT 0
6601: PPUSH
6602: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6606: LD_VAR 0 2
6610: PPUSH
6611: LD_INT 16
6613: PPUSH
6614: LD_INT 11
6616: PPUSH
6617: CALL_OW 111
// wait ( 0 0$2 ) ;
6621: LD_INT 70
6623: PPUSH
6624: CALL_OW 67
// end ;
6628: GO 6469
6630: POP
6631: POP
// for i = 1 to Difficulty do
6632: LD_ADDR_VAR 0 1
6636: PUSH
6637: DOUBLE
6638: LD_INT 1
6640: DEC
6641: ST_TO_ADDR
6642: LD_OWVAR 67
6646: PUSH
6647: FOR_TO
6648: IFFALSE 6773
// begin uc_side := 8 ;
6650: LD_ADDR_OWVAR 20
6654: PUSH
6655: LD_INT 8
6657: ST_TO_ADDR
// uc_nation := 2 ;
6658: LD_ADDR_OWVAR 21
6662: PUSH
6663: LD_INT 2
6665: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6666: LD_INT 0
6668: PPUSH
6669: LD_INT 8
6671: PPUSH
6672: LD_INT 8
6674: PUSH
6675: LD_INT 8
6677: PUSH
6678: LD_INT 9
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: PUSH
6686: LD_OWVAR 67
6690: ARRAY
6691: PPUSH
6692: CALL_OW 380
// un := CreateHuman ;
6696: LD_ADDR_VAR 0 2
6700: PUSH
6701: CALL_OW 44
6705: ST_TO_ADDR
// tmp := tmp ^ un ;
6706: LD_ADDR_VAR 0 3
6710: PUSH
6711: LD_VAR 0 3
6715: PUSH
6716: LD_VAR 0 2
6720: ADD
6721: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6722: LD_VAR 0 2
6726: PPUSH
6727: LD_INT 3
6729: PPUSH
6730: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6734: LD_VAR 0 2
6738: PPUSH
6739: LD_INT 30
6741: PPUSH
6742: LD_INT 0
6744: PPUSH
6745: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6749: LD_VAR 0 2
6753: PPUSH
6754: LD_INT 16
6756: PPUSH
6757: LD_INT 11
6759: PPUSH
6760: CALL_OW 111
// wait ( 0 0$2 ) ;
6764: LD_INT 70
6766: PPUSH
6767: CALL_OW 67
// end ;
6771: GO 6647
6773: POP
6774: POP
// repeat wait ( 0 0$1 ) ;
6775: LD_INT 35
6777: PPUSH
6778: CALL_OW 67
// for i in tmp do
6782: LD_ADDR_VAR 0 1
6786: PUSH
6787: LD_VAR 0 3
6791: PUSH
6792: FOR_IN
6793: IFFALSE 6929
// begin if GetLives ( i ) > 250 then
6795: LD_VAR 0 1
6799: PPUSH
6800: CALL_OW 256
6804: PUSH
6805: LD_INT 250
6807: GREATER
6808: IFFALSE 6900
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6810: LD_INT 81
6812: PUSH
6813: LD_INT 8
6815: PUSH
6816: EMPTY
6817: LIST
6818: LIST
6819: PUSH
6820: LD_INT 91
6822: PUSH
6823: LD_VAR 0 1
6827: PUSH
6828: LD_INT 10
6830: PUSH
6831: EMPTY
6832: LIST
6833: LIST
6834: LIST
6835: PUSH
6836: EMPTY
6837: LIST
6838: LIST
6839: PPUSH
6840: CALL_OW 69
6844: NOT
6845: IFFALSE 6864
// ComAgressiveMove ( i , 67 , 110 ) else
6847: LD_VAR 0 1
6851: PPUSH
6852: LD_INT 67
6854: PPUSH
6855: LD_INT 110
6857: PPUSH
6858: CALL_OW 114
6862: GO 6898
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6864: LD_VAR 0 1
6868: PPUSH
6869: LD_INT 81
6871: PUSH
6872: LD_INT 8
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: PPUSH
6879: CALL_OW 69
6883: PPUSH
6884: LD_VAR 0 1
6888: PPUSH
6889: CALL_OW 74
6893: PPUSH
6894: CALL_OW 115
// end else
6898: GO 6927
// if IsDead ( i ) then
6900: LD_VAR 0 1
6904: PPUSH
6905: CALL_OW 301
6909: IFFALSE 6927
// tmp := tmp diff i ;
6911: LD_ADDR_VAR 0 3
6915: PUSH
6916: LD_VAR 0 3
6920: PUSH
6921: LD_VAR 0 1
6925: DIFF
6926: ST_TO_ADDR
// end ;
6927: GO 6792
6929: POP
6930: POP
// until not tmp ;
6931: LD_VAR 0 3
6935: NOT
6936: IFFALSE 6775
// end ; end_of_file
6938: PPOPN 3
6940: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6941: LD_INT 0
6943: PPUSH
6944: PPUSH
6945: PPUSH
6946: PPUSH
6947: PPUSH
6948: PPUSH
6949: PPUSH
6950: PPUSH
6951: PPUSH
// side := 3 ;
6952: LD_ADDR_VAR 0 6
6956: PUSH
6957: LD_INT 3
6959: ST_TO_ADDR
// uc_side := side ;
6960: LD_ADDR_OWVAR 20
6964: PUSH
6965: LD_VAR 0 6
6969: ST_TO_ADDR
// uc_nation := 3 ;
6970: LD_ADDR_OWVAR 21
6974: PUSH
6975: LD_INT 3
6977: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6978: LD_ADDR_VAR 0 2
6982: PUSH
6983: LD_INT 22
6985: PUSH
6986: LD_VAR 0 6
6990: PUSH
6991: EMPTY
6992: LIST
6993: LIST
6994: PUSH
6995: LD_INT 21
6997: PUSH
6998: LD_INT 3
7000: PUSH
7001: EMPTY
7002: LIST
7003: LIST
7004: PUSH
7005: EMPTY
7006: LIST
7007: LIST
7008: PPUSH
7009: CALL_OW 69
7013: PUSH
7014: FOR_IN
7015: IFFALSE 7031
// SetBLevel ( i , 10 ) ;
7017: LD_VAR 0 2
7021: PPUSH
7022: LD_INT 10
7024: PPUSH
7025: CALL_OW 241
7029: GO 7014
7031: POP
7032: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7033: LD_ADDR_VAR 0 9
7037: PUSH
7038: LD_INT 22
7040: PUSH
7041: LD_VAR 0 6
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: PUSH
7050: LD_INT 30
7052: PUSH
7053: LD_INT 34
7055: PUSH
7056: EMPTY
7057: LIST
7058: LIST
7059: PUSH
7060: EMPTY
7061: LIST
7062: LIST
7063: PPUSH
7064: CALL_OW 69
7068: ST_TO_ADDR
// if teleport then
7069: LD_VAR 0 9
7073: IFFALSE 7094
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7075: LD_VAR 0 9
7079: PUSH
7080: LD_INT 1
7082: ARRAY
7083: PPUSH
7084: LD_INT 123
7086: PPUSH
7087: LD_INT 122
7089: PPUSH
7090: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7094: LD_ADDR_EXP 64
7098: PUSH
7099: LD_STRING Platonov
7101: PPUSH
7102: CALL_OW 25
7106: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7107: LD_ADDR_EXP 65
7111: PUSH
7112: LD_STRING Kovalyuk
7114: PPUSH
7115: CALL_OW 25
7119: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7120: LD_ADDR_EXP 67
7124: PUSH
7125: LD_STRING Yakotich
7127: PPUSH
7128: LD_EXP 1
7132: NOT
7133: PPUSH
7134: LD_STRING 09_
7136: PPUSH
7137: CALL 64980 0 3
7141: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7142: LD_ADDR_EXP 66
7146: PUSH
7147: LD_STRING Bystrov
7149: PPUSH
7150: CALL_OW 25
7154: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7155: LD_ADDR_EXP 68
7159: PUSH
7160: LD_STRING Gleb
7162: PPUSH
7163: CALL_OW 25
7167: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7168: LD_STRING 03_Cornel
7170: PPUSH
7171: CALL_OW 28
7175: IFFALSE 7223
// begin Bierezov := NewCharacter ( Mikhail ) ;
7177: LD_ADDR_EXP 69
7181: PUSH
7182: LD_STRING Mikhail
7184: PPUSH
7185: CALL_OW 25
7189: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7190: LD_EXP 69
7194: PPUSH
7195: LD_INT 197
7197: PPUSH
7198: LD_INT 111
7200: PPUSH
7201: LD_INT 9
7203: PPUSH
7204: LD_INT 0
7206: PPUSH
7207: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7211: LD_EXP 69
7215: PPUSH
7216: LD_INT 3
7218: PPUSH
7219: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7223: LD_EXP 64
7227: PPUSH
7228: LD_INT 126
7230: PPUSH
7231: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7235: LD_EXP 65
7239: PPUSH
7240: LD_INT 134
7242: PPUSH
7243: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7247: LD_EXP 67
7251: PPUSH
7252: LD_INT 197
7254: PPUSH
7255: LD_INT 111
7257: PPUSH
7258: LD_INT 9
7260: PPUSH
7261: LD_INT 0
7263: PPUSH
7264: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7268: LD_EXP 66
7272: PPUSH
7273: LD_INT 197
7275: PPUSH
7276: LD_INT 111
7278: PPUSH
7279: LD_INT 9
7281: PPUSH
7282: LD_INT 0
7284: PPUSH
7285: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7289: LD_EXP 68
7293: PPUSH
7294: LD_INT 197
7296: PPUSH
7297: LD_INT 111
7299: PPUSH
7300: LD_INT 9
7302: PPUSH
7303: LD_INT 0
7305: PPUSH
7306: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7310: LD_ADDR_VAR 0 5
7314: PUSH
7315: LD_INT 126
7317: PPUSH
7318: LD_INT 4
7320: PPUSH
7321: LD_STRING zhukov
7323: PPUSH
7324: LD_INT 9
7326: PUSH
7327: LD_INT 10
7329: PUSH
7330: LD_INT 10
7332: PUSH
7333: EMPTY
7334: LIST
7335: LIST
7336: LIST
7337: PUSH
7338: LD_OWVAR 67
7342: ARRAY
7343: PPUSH
7344: LD_INT 90000
7346: PUSH
7347: LD_INT 1000
7349: PUSH
7350: LD_INT 300
7352: PUSH
7353: EMPTY
7354: LIST
7355: LIST
7356: LIST
7357: PPUSH
7358: LD_INT 18
7360: PUSH
7361: LD_INT 8
7363: PUSH
7364: LD_INT 13
7366: PUSH
7367: LD_INT 8
7369: PUSH
7370: EMPTY
7371: LIST
7372: LIST
7373: LIST
7374: LIST
7375: PPUSH
7376: CALL 73213 0 6
7380: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7381: LD_ADDR_VAR 0 4
7385: PUSH
7386: LD_INT 267
7388: PPUSH
7389: CALL_OW 274
7393: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7394: LD_VAR 0 4
7398: PPUSH
7399: LD_INT 1
7401: PPUSH
7402: LD_INT 5000
7404: PPUSH
7405: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7409: LD_VAR 0 4
7413: PPUSH
7414: LD_INT 2
7416: PPUSH
7417: LD_INT 200
7419: PPUSH
7420: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7424: LD_VAR 0 4
7428: PPUSH
7429: LD_INT 3
7431: PPUSH
7432: LD_INT 200
7434: PPUSH
7435: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7439: LD_ADDR_EXP 110
7443: PUSH
7444: LD_EXP 110
7448: PPUSH
7449: LD_INT 2
7451: PPUSH
7452: LD_VAR 0 5
7456: PUSH
7457: LD_INT 22
7459: PUSH
7460: LD_VAR 0 6
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: PUSH
7469: LD_INT 3
7471: PUSH
7472: LD_INT 21
7474: PUSH
7475: LD_INT 2
7477: PUSH
7478: EMPTY
7479: LIST
7480: LIST
7481: PUSH
7482: EMPTY
7483: LIST
7484: LIST
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: PPUSH
7490: CALL_OW 69
7494: UNION
7495: PUSH
7496: LD_EXP 64
7500: DIFF
7501: PPUSH
7502: CALL_OW 1
7506: ST_TO_ADDR
// behemoths := [ ] ;
7507: LD_ADDR_EXP 72
7511: PUSH
7512: EMPTY
7513: ST_TO_ADDR
// behemothBuilders := [ ] ;
7514: LD_ADDR_EXP 73
7518: PUSH
7519: EMPTY
7520: ST_TO_ADDR
// if Kovalyuk then
7521: LD_EXP 65
7525: IFFALSE 7547
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7527: LD_ADDR_EXP 73
7531: PUSH
7532: LD_EXP 73
7536: PPUSH
7537: LD_EXP 65
7541: PPUSH
7542: CALL 100850 0 2
7546: ST_TO_ADDR
// j := 3 ;
7547: LD_ADDR_VAR 0 3
7551: PUSH
7552: LD_INT 3
7554: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7555: LD_ADDR_VAR 0 2
7559: PUSH
7560: LD_INT 22
7562: PUSH
7563: LD_INT 3
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: PUSH
7570: LD_INT 25
7572: PUSH
7573: LD_INT 3
7575: PUSH
7576: EMPTY
7577: LIST
7578: LIST
7579: PUSH
7580: EMPTY
7581: LIST
7582: LIST
7583: PPUSH
7584: CALL_OW 69
7588: PUSH
7589: LD_EXP 65
7593: DIFF
7594: PUSH
7595: FOR_IN
7596: IFFALSE 7646
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7598: LD_ADDR_EXP 73
7602: PUSH
7603: LD_EXP 73
7607: PPUSH
7608: LD_VAR 0 2
7612: PPUSH
7613: CALL 100850 0 2
7617: ST_TO_ADDR
// j := j - 1 ;
7618: LD_ADDR_VAR 0 3
7622: PUSH
7623: LD_VAR 0 3
7627: PUSH
7628: LD_INT 1
7630: MINUS
7631: ST_TO_ADDR
// if j = 0 then
7632: LD_VAR 0 3
7636: PUSH
7637: LD_INT 0
7639: EQUAL
7640: IFFALSE 7644
// break ;
7642: GO 7646
// end ;
7644: GO 7595
7646: POP
7647: POP
// end ;
7648: LD_VAR 0 1
7652: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7653: LD_INT 0
7655: PPUSH
7656: PPUSH
7657: PPUSH
7658: PPUSH
7659: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7660: LD_ADDR_VAR 0 4
7664: PUSH
7665: LD_INT 209
7667: PUSH
7668: LD_INT 149
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: PUSH
7675: LD_INT 219
7677: PUSH
7678: LD_INT 154
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: PUSH
7685: LD_INT 223
7687: PUSH
7688: LD_INT 149
7690: PUSH
7691: EMPTY
7692: LIST
7693: LIST
7694: PUSH
7695: LD_INT 232
7697: PUSH
7698: LD_INT 155
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: PUSH
7705: EMPTY
7706: LIST
7707: LIST
7708: LIST
7709: LIST
7710: ST_TO_ADDR
// if not behemothBuilders then
7711: LD_EXP 73
7715: NOT
7716: IFFALSE 7720
// exit ;
7718: GO 7824
// j := 1 ;
7720: LD_ADDR_VAR 0 3
7724: PUSH
7725: LD_INT 1
7727: ST_TO_ADDR
// for i in behemothBuilders do
7728: LD_ADDR_VAR 0 2
7732: PUSH
7733: LD_EXP 73
7737: PUSH
7738: FOR_IN
7739: IFFALSE 7822
// begin if IsInUnit ( i ) then
7741: LD_VAR 0 2
7745: PPUSH
7746: CALL_OW 310
7750: IFFALSE 7761
// ComExitBuilding ( i ) ;
7752: LD_VAR 0 2
7756: PPUSH
7757: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7761: LD_VAR 0 2
7765: PPUSH
7766: LD_INT 37
7768: PPUSH
7769: LD_VAR 0 4
7773: PUSH
7774: LD_VAR 0 3
7778: ARRAY
7779: PUSH
7780: LD_INT 1
7782: ARRAY
7783: PPUSH
7784: LD_VAR 0 4
7788: PUSH
7789: LD_VAR 0 3
7793: ARRAY
7794: PUSH
7795: LD_INT 2
7797: ARRAY
7798: PPUSH
7799: LD_INT 0
7801: PPUSH
7802: CALL_OW 230
// j := j + 1 ;
7806: LD_ADDR_VAR 0 3
7810: PUSH
7811: LD_VAR 0 3
7815: PUSH
7816: LD_INT 1
7818: PLUS
7819: ST_TO_ADDR
// end ;
7820: GO 7738
7822: POP
7823: POP
// end ;
7824: LD_VAR 0 1
7828: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7829: LD_INT 24
7831: PPUSH
7832: LD_INT 30
7834: PUSH
7835: LD_INT 37
7837: PUSH
7838: EMPTY
7839: LIST
7840: LIST
7841: PPUSH
7842: CALL_OW 70
7846: IFFALSE 7859
7848: GO 7850
7850: DISABLE
// behemothUnderConstruct := true ;
7851: LD_ADDR_EXP 26
7855: PUSH
7856: LD_INT 1
7858: ST_TO_ADDR
7859: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7860: LD_INT 3
7862: PPUSH
7863: CALL 100898 0 1
7867: PUSH
7868: LD_INT 22
7870: PUSH
7871: LD_INT 3
7873: PUSH
7874: EMPTY
7875: LIST
7876: LIST
7877: PUSH
7878: LD_INT 30
7880: PUSH
7881: LD_INT 37
7883: PUSH
7884: EMPTY
7885: LIST
7886: LIST
7887: PUSH
7888: EMPTY
7889: LIST
7890: LIST
7891: PPUSH
7892: CALL_OW 69
7896: NOT
7897: AND
7898: IFFALSE 8084
7900: GO 7902
7902: DISABLE
7903: LD_INT 0
7905: PPUSH
7906: PPUSH
// begin enable ;
7907: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7908: LD_ADDR_VAR 0 2
7912: PUSH
7913: LD_INT 3
7915: PPUSH
7916: CALL 100898 0 1
7920: ST_TO_ADDR
// for i in tmp do
7921: LD_ADDR_VAR 0 1
7925: PUSH
7926: LD_VAR 0 2
7930: PUSH
7931: FOR_IN
7932: IFFALSE 8082
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7934: LD_VAR 0 1
7938: PPUSH
7939: LD_INT 9
7941: PPUSH
7942: CALL_OW 308
7946: PUSH
7947: LD_VAR 0 1
7951: PPUSH
7952: CALL_OW 110
7956: PUSH
7957: LD_INT 2
7959: EQUAL
7960: NOT
7961: AND
7962: IFFALSE 7976
// SetTag ( i , 2 ) ;
7964: LD_VAR 0 1
7968: PPUSH
7969: LD_INT 2
7971: PPUSH
7972: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7976: LD_INT 81
7978: PUSH
7979: LD_INT 3
7981: PUSH
7982: EMPTY
7983: LIST
7984: LIST
7985: PUSH
7986: LD_INT 91
7988: PUSH
7989: LD_VAR 0 1
7993: PUSH
7994: LD_INT 12
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: LIST
8001: PUSH
8002: EMPTY
8003: LIST
8004: LIST
8005: PPUSH
8006: CALL_OW 69
8010: NOT
8011: PUSH
8012: LD_VAR 0 1
8016: PPUSH
8017: CALL_OW 110
8021: PUSH
8022: LD_INT 2
8024: EQUAL
8025: NOT
8026: AND
8027: IFFALSE 8046
// ComAgressiveMove ( i , 64 , 93 ) else
8029: LD_VAR 0 1
8033: PPUSH
8034: LD_INT 64
8036: PPUSH
8037: LD_INT 93
8039: PPUSH
8040: CALL_OW 114
8044: GO 8080
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8046: LD_VAR 0 1
8050: PPUSH
8051: LD_INT 81
8053: PUSH
8054: LD_INT 3
8056: PUSH
8057: EMPTY
8058: LIST
8059: LIST
8060: PPUSH
8061: CALL_OW 69
8065: PPUSH
8066: LD_VAR 0 1
8070: PPUSH
8071: CALL_OW 74
8075: PPUSH
8076: CALL_OW 115
// end ;
8080: GO 7931
8082: POP
8083: POP
// end ;
8084: PPOPN 2
8086: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8087: LD_INT 0
8089: PPUSH
8090: PPUSH
8091: PPUSH
// result := [ ] ;
8092: LD_ADDR_VAR 0 2
8096: PUSH
8097: EMPTY
8098: ST_TO_ADDR
// uc_side := 6 ;
8099: LD_ADDR_OWVAR 20
8103: PUSH
8104: LD_INT 6
8106: ST_TO_ADDR
// uc_nation := 3 ;
8107: LD_ADDR_OWVAR 21
8111: PUSH
8112: LD_INT 3
8114: ST_TO_ADDR
// case strength of 1 :
8115: LD_VAR 0 1
8119: PUSH
8120: LD_INT 1
8122: DOUBLE
8123: EQUAL
8124: IFTRUE 8128
8126: GO 8266
8128: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8129: LD_ADDR_VAR 0 3
8133: PUSH
8134: DOUBLE
8135: LD_INT 1
8137: DEC
8138: ST_TO_ADDR
8139: LD_INT 4
8141: PUSH
8142: LD_INT 5
8144: PUSH
8145: LD_INT 6
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: LIST
8152: PUSH
8153: LD_OWVAR 67
8157: ARRAY
8158: PUSH
8159: FOR_TO
8160: IFFALSE 8262
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8162: LD_INT 22
8164: PUSH
8165: LD_INT 24
8167: PUSH
8168: EMPTY
8169: LIST
8170: LIST
8171: PUSH
8172: LD_VAR 0 3
8176: PUSH
8177: LD_INT 2
8179: MOD
8180: PUSH
8181: LD_INT 1
8183: PLUS
8184: ARRAY
8185: PPUSH
8186: LD_INT 1
8188: PUSH
8189: LD_INT 3
8191: PUSH
8192: EMPTY
8193: LIST
8194: LIST
8195: PUSH
8196: LD_INT 1
8198: PPUSH
8199: LD_INT 2
8201: PPUSH
8202: CALL_OW 12
8206: ARRAY
8207: PPUSH
8208: LD_INT 3
8210: PPUSH
8211: LD_INT 43
8213: PUSH
8214: LD_INT 44
8216: PUSH
8217: LD_INT 45
8219: PUSH
8220: EMPTY
8221: LIST
8222: LIST
8223: LIST
8224: PUSH
8225: LD_INT 1
8227: PPUSH
8228: LD_INT 3
8230: PPUSH
8231: CALL_OW 12
8235: ARRAY
8236: PPUSH
8237: LD_INT 80
8239: PPUSH
8240: CALL 69804 0 5
// result := result union CreateVehicle ;
8244: LD_ADDR_VAR 0 2
8248: PUSH
8249: LD_VAR 0 2
8253: PUSH
8254: CALL_OW 45
8258: UNION
8259: ST_TO_ADDR
// end ;
8260: GO 8159
8262: POP
8263: POP
// end ; 2 :
8264: GO 9217
8266: LD_INT 2
8268: DOUBLE
8269: EQUAL
8270: IFTRUE 8274
8272: GO 8430
8274: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8275: LD_ADDR_VAR 0 3
8279: PUSH
8280: DOUBLE
8281: LD_INT 1
8283: DEC
8284: ST_TO_ADDR
8285: LD_INT 5
8287: PUSH
8288: LD_INT 6
8290: PUSH
8291: LD_INT 7
8293: PUSH
8294: EMPTY
8295: LIST
8296: LIST
8297: LIST
8298: PUSH
8299: LD_OWVAR 67
8303: ARRAY
8304: PUSH
8305: FOR_TO
8306: IFFALSE 8426
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8308: LD_INT 22
8310: PUSH
8311: LD_INT 24
8313: PUSH
8314: LD_INT 24
8316: PUSH
8317: EMPTY
8318: LIST
8319: LIST
8320: LIST
8321: PUSH
8322: LD_VAR 0 3
8326: PUSH
8327: LD_INT 3
8329: MOD
8330: PUSH
8331: LD_INT 1
8333: PLUS
8334: ARRAY
8335: PPUSH
8336: LD_INT 1
8338: PUSH
8339: LD_INT 3
8341: PUSH
8342: EMPTY
8343: LIST
8344: LIST
8345: PUSH
8346: LD_INT 1
8348: PPUSH
8349: LD_INT 2
8351: PPUSH
8352: CALL_OW 12
8356: ARRAY
8357: PPUSH
8358: LD_INT 3
8360: PPUSH
8361: LD_INT 43
8363: PUSH
8364: LD_INT 44
8366: PUSH
8367: LD_INT 45
8369: PUSH
8370: LD_INT 44
8372: PUSH
8373: LD_INT 46
8375: PUSH
8376: LD_INT 46
8378: PUSH
8379: EMPTY
8380: LIST
8381: LIST
8382: LIST
8383: LIST
8384: LIST
8385: LIST
8386: PUSH
8387: LD_VAR 0 3
8391: PUSH
8392: LD_INT 6
8394: MOD
8395: PUSH
8396: LD_INT 1
8398: PLUS
8399: ARRAY
8400: PPUSH
8401: LD_INT 80
8403: PPUSH
8404: CALL 69804 0 5
// result := result union CreateVehicle ;
8408: LD_ADDR_VAR 0 2
8412: PUSH
8413: LD_VAR 0 2
8417: PUSH
8418: CALL_OW 45
8422: UNION
8423: ST_TO_ADDR
// end ;
8424: GO 8305
8426: POP
8427: POP
// end ; 3 :
8428: GO 9217
8430: LD_INT 3
8432: DOUBLE
8433: EQUAL
8434: IFTRUE 8438
8436: GO 8594
8438: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8439: LD_ADDR_VAR 0 3
8443: PUSH
8444: DOUBLE
8445: LD_INT 1
8447: DEC
8448: ST_TO_ADDR
8449: LD_INT 5
8451: PUSH
8452: LD_INT 7
8454: PUSH
8455: LD_INT 8
8457: PUSH
8458: EMPTY
8459: LIST
8460: LIST
8461: LIST
8462: PUSH
8463: LD_OWVAR 67
8467: ARRAY
8468: PUSH
8469: FOR_TO
8470: IFFALSE 8590
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8472: LD_INT 22
8474: PUSH
8475: LD_INT 24
8477: PUSH
8478: LD_INT 24
8480: PUSH
8481: EMPTY
8482: LIST
8483: LIST
8484: LIST
8485: PUSH
8486: LD_VAR 0 3
8490: PUSH
8491: LD_INT 3
8493: MOD
8494: PUSH
8495: LD_INT 1
8497: PLUS
8498: ARRAY
8499: PPUSH
8500: LD_INT 1
8502: PUSH
8503: LD_INT 3
8505: PUSH
8506: EMPTY
8507: LIST
8508: LIST
8509: PUSH
8510: LD_INT 1
8512: PPUSH
8513: LD_INT 2
8515: PPUSH
8516: CALL_OW 12
8520: ARRAY
8521: PPUSH
8522: LD_INT 3
8524: PPUSH
8525: LD_INT 43
8527: PUSH
8528: LD_INT 47
8530: PUSH
8531: LD_INT 45
8533: PUSH
8534: LD_INT 45
8536: PUSH
8537: LD_INT 46
8539: PUSH
8540: LD_INT 46
8542: PUSH
8543: EMPTY
8544: LIST
8545: LIST
8546: LIST
8547: LIST
8548: LIST
8549: LIST
8550: PUSH
8551: LD_VAR 0 3
8555: PUSH
8556: LD_INT 6
8558: MOD
8559: PUSH
8560: LD_INT 1
8562: PLUS
8563: ARRAY
8564: PPUSH
8565: LD_INT 80
8567: PPUSH
8568: CALL 69804 0 5
// result := result union CreateVehicle ;
8572: LD_ADDR_VAR 0 2
8576: PUSH
8577: LD_VAR 0 2
8581: PUSH
8582: CALL_OW 45
8586: UNION
8587: ST_TO_ADDR
// end ;
8588: GO 8469
8590: POP
8591: POP
// end ; 4 :
8592: GO 9217
8594: LD_INT 4
8596: DOUBLE
8597: EQUAL
8598: IFTRUE 8602
8600: GO 9216
8602: POP
// begin uc_nation := 3 ;
8603: LD_ADDR_OWVAR 21
8607: PUSH
8608: LD_INT 3
8610: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8611: LD_ADDR_VAR 0 3
8615: PUSH
8616: DOUBLE
8617: LD_INT 1
8619: DEC
8620: ST_TO_ADDR
8621: LD_INT 6
8623: PUSH
8624: LD_INT 8
8626: PUSH
8627: LD_INT 9
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: LIST
8634: PUSH
8635: LD_OWVAR 67
8639: ARRAY
8640: PUSH
8641: FOR_TO
8642: IFFALSE 8762
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8644: LD_INT 22
8646: PUSH
8647: LD_INT 24
8649: PUSH
8650: LD_INT 24
8652: PUSH
8653: EMPTY
8654: LIST
8655: LIST
8656: LIST
8657: PUSH
8658: LD_VAR 0 3
8662: PUSH
8663: LD_INT 3
8665: MOD
8666: PUSH
8667: LD_INT 1
8669: PLUS
8670: ARRAY
8671: PPUSH
8672: LD_INT 1
8674: PUSH
8675: LD_INT 3
8677: PUSH
8678: EMPTY
8679: LIST
8680: LIST
8681: PUSH
8682: LD_INT 1
8684: PPUSH
8685: LD_INT 2
8687: PPUSH
8688: CALL_OW 12
8692: ARRAY
8693: PPUSH
8694: LD_INT 3
8696: PPUSH
8697: LD_INT 45
8699: PUSH
8700: LD_INT 47
8702: PUSH
8703: LD_INT 47
8705: PUSH
8706: LD_INT 45
8708: PUSH
8709: LD_INT 46
8711: PUSH
8712: LD_INT 46
8714: PUSH
8715: EMPTY
8716: LIST
8717: LIST
8718: LIST
8719: LIST
8720: LIST
8721: LIST
8722: PUSH
8723: LD_VAR 0 3
8727: PUSH
8728: LD_INT 6
8730: MOD
8731: PUSH
8732: LD_INT 1
8734: PLUS
8735: ARRAY
8736: PPUSH
8737: LD_INT 80
8739: PPUSH
8740: CALL 69804 0 5
// result := result union CreateVehicle ;
8744: LD_ADDR_VAR 0 2
8748: PUSH
8749: LD_VAR 0 2
8753: PUSH
8754: CALL_OW 45
8758: UNION
8759: ST_TO_ADDR
// end ;
8760: GO 8641
8762: POP
8763: POP
// if not KappaStatus then
8764: LD_EXP 2
8768: NOT
8769: IFFALSE 9004
// begin uc_nation := 1 ;
8771: LD_ADDR_OWVAR 21
8775: PUSH
8776: LD_INT 1
8778: ST_TO_ADDR
// for i = 1 to 3 do
8779: LD_ADDR_VAR 0 3
8783: PUSH
8784: DOUBLE
8785: LD_INT 1
8787: DEC
8788: ST_TO_ADDR
8789: LD_INT 3
8791: PUSH
8792: FOR_TO
8793: IFFALSE 8929
// begin j := rand ( 0 , 1 ) ;
8795: LD_ADDR_VAR 0 4
8799: PUSH
8800: LD_INT 0
8802: PPUSH
8803: LD_INT 1
8805: PPUSH
8806: CALL_OW 12
8810: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8811: LD_INT 3
8813: PUSH
8814: LD_INT 5
8816: PUSH
8817: LD_INT 5
8819: PUSH
8820: LD_INT 4
8822: PUSH
8823: EMPTY
8824: LIST
8825: LIST
8826: LIST
8827: LIST
8828: PUSH
8829: LD_VAR 0 4
8833: PUSH
8834: LD_INT 1
8836: PPUSH
8837: LD_INT 3
8839: PPUSH
8840: CALL_OW 12
8844: PLUS
8845: ARRAY
8846: PPUSH
8847: LD_INT 1
8849: PUSH
8850: LD_INT 3
8852: PUSH
8853: EMPTY
8854: LIST
8855: LIST
8856: PUSH
8857: LD_INT 1
8859: PPUSH
8860: LD_INT 2
8862: PPUSH
8863: CALL_OW 12
8867: ARRAY
8868: PPUSH
8869: LD_INT 3
8871: PPUSH
8872: LD_INT 9
8874: PUSH
8875: LD_INT 7
8877: PUSH
8878: LD_INT 6
8880: PUSH
8881: EMPTY
8882: LIST
8883: LIST
8884: LIST
8885: PUSH
8886: LD_VAR 0 4
8890: PUSH
8891: LD_INT 1
8893: PPUSH
8894: LD_INT 2
8896: PPUSH
8897: CALL_OW 12
8901: PLUS
8902: ARRAY
8903: PPUSH
8904: LD_INT 85
8906: PPUSH
8907: CALL 69804 0 5
// result := result union CreateVehicle ;
8911: LD_ADDR_VAR 0 2
8915: PUSH
8916: LD_VAR 0 2
8920: PUSH
8921: CALL_OW 45
8925: UNION
8926: ST_TO_ADDR
// end ;
8927: GO 8792
8929: POP
8930: POP
// if vsevolodFirstAttack then
8931: LD_EXP 24
8935: IFFALSE 9002
// begin vsevolodFirstAttack := false ;
8937: LD_ADDR_EXP 24
8941: PUSH
8942: LD_INT 0
8944: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8945: LD_INT 5
8947: PPUSH
8948: LD_INT 3
8950: PPUSH
8951: LD_INT 1
8953: PPUSH
8954: LD_INT 6
8956: PPUSH
8957: LD_INT 100
8959: PPUSH
8960: CALL 69804 0 5
// sewiVeh := CreateVehicle ;
8964: LD_ADDR_EXP 71
8968: PUSH
8969: CALL_OW 45
8973: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8974: LD_EXP 71
8978: PPUSH
8979: LD_INT 1
8981: PPUSH
8982: CALL_OW 242
// result := result union sewiVeh ;
8986: LD_ADDR_VAR 0 2
8990: PUSH
8991: LD_VAR 0 2
8995: PUSH
8996: LD_EXP 71
9000: UNION
9001: ST_TO_ADDR
// end ; end else
9002: GO 9214
// if vsevolodFirstAttack then
9004: LD_EXP 24
9008: IFFALSE 9214
// begin vsevolodFirstAttack := false ;
9010: LD_ADDR_EXP 24
9014: PUSH
9015: LD_INT 0
9017: ST_TO_ADDR
// uc_nation := 3 ;
9018: LD_ADDR_OWVAR 21
9022: PUSH
9023: LD_INT 3
9025: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9026: LD_ADDR_VAR 0 3
9030: PUSH
9031: DOUBLE
9032: LD_INT 1
9034: DEC
9035: ST_TO_ADDR
9036: LD_INT 2
9038: PUSH
9039: LD_OWVAR 67
9043: PLUS
9044: PUSH
9045: FOR_TO
9046: IFFALSE 9154
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9048: LD_INT 22
9050: PUSH
9051: LD_INT 24
9053: PUSH
9054: LD_INT 24
9056: PUSH
9057: EMPTY
9058: LIST
9059: LIST
9060: LIST
9061: PUSH
9062: LD_VAR 0 3
9066: PUSH
9067: LD_INT 3
9069: MOD
9070: PUSH
9071: LD_INT 1
9073: PLUS
9074: ARRAY
9075: PPUSH
9076: LD_INT 1
9078: PUSH
9079: LD_INT 3
9081: PUSH
9082: EMPTY
9083: LIST
9084: LIST
9085: PUSH
9086: LD_INT 1
9088: PPUSH
9089: LD_INT 2
9091: PPUSH
9092: CALL_OW 12
9096: ARRAY
9097: PPUSH
9098: LD_INT 1
9100: PPUSH
9101: LD_INT 45
9103: PUSH
9104: LD_INT 47
9106: PUSH
9107: LD_INT 47
9109: PUSH
9110: EMPTY
9111: LIST
9112: LIST
9113: LIST
9114: PUSH
9115: LD_VAR 0 3
9119: PUSH
9120: LD_INT 3
9122: MOD
9123: PUSH
9124: LD_INT 1
9126: PLUS
9127: ARRAY
9128: PPUSH
9129: LD_INT 80
9131: PPUSH
9132: CALL 69804 0 5
// result := result union CreateVehicle ;
9136: LD_ADDR_VAR 0 2
9140: PUSH
9141: LD_VAR 0 2
9145: PUSH
9146: CALL_OW 45
9150: UNION
9151: ST_TO_ADDR
// end ;
9152: GO 9045
9154: POP
9155: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9156: LD_INT 24
9158: PPUSH
9159: LD_INT 3
9161: PPUSH
9162: LD_INT 1
9164: PPUSH
9165: LD_INT 47
9167: PPUSH
9168: LD_INT 100
9170: PPUSH
9171: CALL 69804 0 5
// sewiVeh := CreateVehicle ;
9175: LD_ADDR_EXP 71
9179: PUSH
9180: CALL_OW 45
9184: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9185: LD_EXP 71
9189: PPUSH
9190: LD_INT 6
9192: NEG
9193: PPUSH
9194: CALL_OW 242
// result := result union sewiVeh ;
9198: LD_ADDR_VAR 0 2
9202: PUSH
9203: LD_VAR 0 2
9207: PUSH
9208: LD_EXP 71
9212: UNION
9213: ST_TO_ADDR
// end ; end ; end ;
9214: GO 9217
9216: POP
// end ;
9217: LD_VAR 0 2
9221: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9222: LD_EXP 16
9226: IFFALSE 10067
9228: GO 9230
9230: DISABLE
9231: LD_INT 0
9233: PPUSH
9234: PPUSH
9235: PPUSH
9236: PPUSH
9237: PPUSH
9238: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9239: LD_ADDR_VAR 0 4
9243: PUSH
9244: LD_INT 11
9246: PUSH
9247: LD_INT 12
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 ] [ Difficulty ] ;
9254: LD_ADDR_VAR 0 3
9258: PUSH
9259: LD_INT 11550
9261: PUSH
9262: LD_INT 10150
9264: PUSH
9265: LD_INT 9800
9267: PUSH
9268: EMPTY
9269: LIST
9270: LIST
9271: LIST
9272: PUSH
9273: LD_OWVAR 67
9277: ARRAY
9278: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9279: LD_ADDR_VAR 0 6
9283: PUSH
9284: LD_INT 70
9286: PUSH
9287: LD_INT 118
9289: PUSH
9290: EMPTY
9291: LIST
9292: LIST
9293: PUSH
9294: LD_INT 78
9296: PUSH
9297: LD_INT 31
9299: PUSH
9300: EMPTY
9301: LIST
9302: LIST
9303: PUSH
9304: EMPTY
9305: LIST
9306: LIST
9307: ST_TO_ADDR
// repeat if missionStage = 2 then
9308: LD_EXP 15
9312: PUSH
9313: LD_INT 2
9315: EQUAL
9316: IFFALSE 9327
// wait ( 1 1$30 ) else
9318: LD_INT 3150
9320: PPUSH
9321: CALL_OW 67
9325: GO 9336
// wait ( time ) ;
9327: LD_VAR 0 3
9331: PPUSH
9332: CALL_OW 67
// if missionStage = 6 then
9336: LD_EXP 15
9340: PUSH
9341: LD_INT 6
9343: EQUAL
9344: IFFALSE 9372
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9346: LD_INT 51
9348: PPUSH
9349: LD_INT 6
9351: PPUSH
9352: LD_INT 2
9354: PPUSH
9355: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9359: LD_INT 57
9361: PPUSH
9362: LD_INT 6
9364: PPUSH
9365: LD_INT 2
9367: PPUSH
9368: CALL_OW 322
// end ; if missionStage = 8 then
9372: LD_EXP 15
9376: PUSH
9377: LD_INT 8
9379: EQUAL
9380: IFFALSE 9408
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9382: LD_INT 52
9384: PPUSH
9385: LD_INT 6
9387: PPUSH
9388: LD_INT 2
9390: PPUSH
9391: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9395: LD_INT 58
9397: PPUSH
9398: LD_INT 6
9400: PPUSH
9401: LD_INT 2
9403: PPUSH
9404: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9408: LD_EXP 15
9412: PUSH
9413: LD_INT 10
9415: EQUAL
9416: PUSH
9417: LD_OWVAR 67
9421: PUSH
9422: LD_INT 1
9424: GREATER
9425: AND
9426: IFFALSE 9454
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9428: LD_INT 53
9430: PPUSH
9431: LD_INT 6
9433: PPUSH
9434: LD_INT 2
9436: PPUSH
9437: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9441: LD_INT 59
9443: PPUSH
9444: LD_INT 6
9446: PPUSH
9447: LD_INT 2
9449: PPUSH
9450: CALL_OW 322
// end ; if activeAttacks then
9454: LD_EXP 16
9458: IFFALSE 10061
// begin if missionStage = 2 then
9460: LD_EXP 15
9464: PUSH
9465: LD_INT 2
9467: EQUAL
9468: IFFALSE 9478
// strength := 1 ;
9470: LD_ADDR_VAR 0 5
9474: PUSH
9475: LD_INT 1
9477: ST_TO_ADDR
// if missionStage > 2 then
9478: LD_EXP 15
9482: PUSH
9483: LD_INT 2
9485: GREATER
9486: IFFALSE 9496
// strength := 2 ;
9488: LD_ADDR_VAR 0 5
9492: PUSH
9493: LD_INT 2
9495: ST_TO_ADDR
// if missionStage > 6 then
9496: LD_EXP 15
9500: PUSH
9501: LD_INT 6
9503: GREATER
9504: IFFALSE 9514
// strength := 3 ;
9506: LD_ADDR_VAR 0 5
9510: PUSH
9511: LD_INT 3
9513: ST_TO_ADDR
// if missionStage > 10 then
9514: LD_EXP 15
9518: PUSH
9519: LD_INT 10
9521: GREATER
9522: IFFALSE 9532
// strength := 4 ;
9524: LD_ADDR_VAR 0 5
9528: PUSH
9529: LD_INT 4
9531: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9532: LD_ADDR_VAR 0 2
9536: PUSH
9537: LD_VAR 0 5
9541: PPUSH
9542: CALL 8087 0 1
9546: ST_TO_ADDR
// for i in tmp do
9547: LD_ADDR_VAR 0 1
9551: PUSH
9552: LD_VAR 0 2
9556: PUSH
9557: FOR_IN
9558: IFFALSE 9741
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9560: LD_VAR 0 1
9564: PPUSH
9565: LD_VAR 0 4
9569: PUSH
9570: LD_INT 1
9572: PPUSH
9573: LD_INT 2
9575: PPUSH
9576: CALL_OW 12
9580: ARRAY
9581: PPUSH
9582: LD_INT 0
9584: PPUSH
9585: CALL_OW 49
// if i = sewiVeh then
9589: LD_VAR 0 1
9593: PUSH
9594: LD_EXP 71
9598: EQUAL
9599: IFFALSE 9636
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9601: LD_ADDR_EXP 70
9605: PUSH
9606: LD_STRING Vsevolod
9608: PPUSH
9609: LD_INT 0
9611: PPUSH
9612: LD_STRING 
9614: PPUSH
9615: CALL 64980 0 3
9619: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9620: LD_EXP 70
9624: PPUSH
9625: LD_VAR 0 1
9629: PPUSH
9630: CALL_OW 52
// end else
9634: GO 9717
// if GetControl ( i ) = control_manual then
9636: LD_VAR 0 1
9640: PPUSH
9641: CALL_OW 263
9645: PUSH
9646: LD_INT 1
9648: EQUAL
9649: IFFALSE 9717
// begin uc_side := 6 ;
9651: LD_ADDR_OWVAR 20
9655: PUSH
9656: LD_INT 6
9658: ST_TO_ADDR
// uc_nation := 3 ;
9659: LD_ADDR_OWVAR 21
9663: PUSH
9664: LD_INT 3
9666: ST_TO_ADDR
// hc_gallery :=  ;
9667: LD_ADDR_OWVAR 33
9671: PUSH
9672: LD_STRING 
9674: ST_TO_ADDR
// hc_name :=  ;
9675: LD_ADDR_OWVAR 26
9679: PUSH
9680: LD_STRING 
9682: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9683: LD_INT 0
9685: PPUSH
9686: LD_INT 3
9688: PPUSH
9689: LD_INT 10
9691: PPUSH
9692: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9696: CALL_OW 44
9700: PPUSH
9701: LD_VAR 0 1
9705: PPUSH
9706: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9710: LD_INT 10
9712: PPUSH
9713: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9717: LD_VAR 0 1
9721: PPUSH
9722: LD_INT 111
9724: PPUSH
9725: LD_INT 197
9727: PPUSH
9728: CALL_OW 111
// wait ( 0 0$2 ) ;
9732: LD_INT 70
9734: PPUSH
9735: CALL_OW 67
// end ;
9739: GO 9557
9741: POP
9742: POP
// repeat wait ( 0 0$1 ) ;
9743: LD_INT 35
9745: PPUSH
9746: CALL_OW 67
// for i in tmp do
9750: LD_ADDR_VAR 0 1
9754: PUSH
9755: LD_VAR 0 2
9759: PUSH
9760: FOR_IN
9761: IFFALSE 10042
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9763: LD_INT 81
9765: PUSH
9766: LD_INT 6
9768: PUSH
9769: EMPTY
9770: LIST
9771: LIST
9772: PUSH
9773: LD_INT 91
9775: PUSH
9776: LD_VAR 0 1
9780: PUSH
9781: LD_INT 12
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: LIST
9788: PUSH
9789: EMPTY
9790: LIST
9791: LIST
9792: PPUSH
9793: CALL_OW 69
9797: IFFALSE 9855
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9799: LD_VAR 0 1
9803: PPUSH
9804: LD_INT 81
9806: PUSH
9807: LD_INT 6
9809: PUSH
9810: EMPTY
9811: LIST
9812: LIST
9813: PUSH
9814: LD_INT 91
9816: PUSH
9817: LD_VAR 0 1
9821: PUSH
9822: LD_INT 12
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: LIST
9829: PUSH
9830: EMPTY
9831: LIST
9832: LIST
9833: PPUSH
9834: CALL_OW 69
9838: PPUSH
9839: LD_VAR 0 1
9843: PPUSH
9844: CALL_OW 74
9848: PPUSH
9849: CALL_OW 115
9853: GO 10040
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9855: LD_INT 9
9857: PPUSH
9858: LD_INT 81
9860: PUSH
9861: LD_INT 6
9863: PUSH
9864: EMPTY
9865: LIST
9866: LIST
9867: PPUSH
9868: CALL_OW 70
9872: IFFALSE 10006
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9874: LD_VAR 0 1
9878: PPUSH
9879: LD_VAR 0 6
9883: PUSH
9884: LD_INT 1
9886: ARRAY
9887: PUSH
9888: LD_INT 1
9890: ARRAY
9891: PPUSH
9892: LD_VAR 0 6
9896: PUSH
9897: LD_INT 1
9899: ARRAY
9900: PUSH
9901: LD_INT 2
9903: ARRAY
9904: PPUSH
9905: CALL_OW 297
9909: PUSH
9910: LD_INT 10
9912: GREATER
9913: PUSH
9914: LD_VAR 0 1
9918: PPUSH
9919: LD_INT 9
9921: PPUSH
9922: CALL_OW 308
9926: NOT
9927: AND
9928: IFFALSE 9967
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9930: LD_VAR 0 1
9934: PPUSH
9935: LD_VAR 0 6
9939: PUSH
9940: LD_INT 1
9942: ARRAY
9943: PUSH
9944: LD_INT 1
9946: ARRAY
9947: PPUSH
9948: LD_VAR 0 6
9952: PUSH
9953: LD_INT 1
9955: ARRAY
9956: PUSH
9957: LD_INT 2
9959: ARRAY
9960: PPUSH
9961: CALL_OW 114
9965: GO 10004
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9967: LD_VAR 0 1
9971: PPUSH
9972: LD_INT 9
9974: PPUSH
9975: LD_INT 81
9977: PUSH
9978: LD_INT 6
9980: PUSH
9981: EMPTY
9982: LIST
9983: LIST
9984: PPUSH
9985: CALL_OW 70
9989: PPUSH
9990: LD_VAR 0 1
9994: PPUSH
9995: CALL_OW 74
9999: PPUSH
10000: CALL_OW 115
// end else
10004: GO 10040
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10006: LD_VAR 0 1
10010: PPUSH
10011: LD_INT 81
10013: PUSH
10014: LD_INT 6
10016: PUSH
10017: EMPTY
10018: LIST
10019: LIST
10020: PPUSH
10021: CALL_OW 69
10025: PPUSH
10026: LD_VAR 0 1
10030: PPUSH
10031: CALL_OW 74
10035: PPUSH
10036: CALL_OW 115
// end ;
10040: GO 9760
10042: POP
10043: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10044: LD_INT 22
10046: PUSH
10047: LD_INT 6
10049: PUSH
10050: EMPTY
10051: LIST
10052: LIST
10053: PPUSH
10054: CALL_OW 69
10058: NOT
10059: IFFALSE 9743
// end ; until russianDestroyed ;
10061: LD_EXP 21
10065: IFFALSE 9308
// end ;
10067: PPOPN 6
10069: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10070: LD_EXP 21
10074: NOT
10075: PUSH
10076: LD_EXP 15
10080: PUSH
10081: LD_INT 6
10083: GREATEREQUAL
10084: AND
10085: PUSH
10086: LD_INT 2
10088: PPUSH
10089: LD_INT 1
10091: PPUSH
10092: CALL 60054 0 2
10096: NOT
10097: AND
10098: IFFALSE 11054
10100: GO 10102
10102: DISABLE
10103: LD_INT 0
10105: PPUSH
10106: PPUSH
10107: PPUSH
10108: PPUSH
// begin enable ;
10109: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10110: LD_INT 22
10112: PUSH
10113: LD_INT 3
10115: PUSH
10116: EMPTY
10117: LIST
10118: LIST
10119: PUSH
10120: LD_INT 30
10122: PUSH
10123: LD_INT 3
10125: PUSH
10126: EMPTY
10127: LIST
10128: LIST
10129: PUSH
10130: EMPTY
10131: LIST
10132: LIST
10133: PPUSH
10134: CALL_OW 69
10138: NOT
10139: IFFALSE 10143
// exit ;
10141: GO 11054
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10143: LD_ADDR_VAR 0 4
10147: PUSH
10148: LD_INT 22
10150: PUSH
10151: LD_INT 3
10153: PUSH
10154: EMPTY
10155: LIST
10156: LIST
10157: PUSH
10158: LD_INT 30
10160: PUSH
10161: LD_INT 34
10163: PUSH
10164: EMPTY
10165: LIST
10166: LIST
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: PPUSH
10172: CALL_OW 69
10176: ST_TO_ADDR
// if Prob ( 40 ) then
10177: LD_INT 40
10179: PPUSH
10180: CALL_OW 13
10184: IFFALSE 10311
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10186: LD_INT 2
10188: PPUSH
10189: LD_INT 22
10191: PUSH
10192: LD_INT 3
10194: PUSH
10195: LD_INT 3
10197: PUSH
10198: LD_INT 49
10200: PUSH
10201: EMPTY
10202: LIST
10203: LIST
10204: LIST
10205: LIST
10206: PUSH
10207: LD_INT 22
10209: PUSH
10210: LD_INT 3
10212: PUSH
10213: LD_INT 3
10215: PUSH
10216: LD_INT 49
10218: PUSH
10219: EMPTY
10220: LIST
10221: LIST
10222: LIST
10223: LIST
10224: PUSH
10225: LD_INT 22
10227: PUSH
10228: LD_INT 3
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: LD_INT 49
10236: PUSH
10237: EMPTY
10238: LIST
10239: LIST
10240: LIST
10241: LIST
10242: PUSH
10243: LD_INT 24
10245: PUSH
10246: LD_INT 3
10248: PUSH
10249: LD_INT 3
10251: PUSH
10252: LD_INT 46
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: LIST
10259: LIST
10260: PUSH
10261: LD_INT 24
10263: PUSH
10264: LD_INT 3
10266: PUSH
10267: LD_INT 3
10269: PUSH
10270: LD_INT 46
10272: PUSH
10273: EMPTY
10274: LIST
10275: LIST
10276: LIST
10277: LIST
10278: PUSH
10279: LD_INT 24
10281: PUSH
10282: LD_INT 3
10284: PUSH
10285: LD_INT 3
10287: PUSH
10288: LD_INT 46
10290: PUSH
10291: EMPTY
10292: LIST
10293: LIST
10294: LIST
10295: LIST
10296: PUSH
10297: EMPTY
10298: LIST
10299: LIST
10300: LIST
10301: LIST
10302: LIST
10303: LIST
10304: PPUSH
10305: CALL 58636 0 2
// end else
10309: GO 10434
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10311: LD_INT 2
10313: PPUSH
10314: LD_INT 24
10316: PUSH
10317: LD_INT 3
10319: PUSH
10320: LD_INT 3
10322: PUSH
10323: LD_INT 47
10325: PUSH
10326: EMPTY
10327: LIST
10328: LIST
10329: LIST
10330: LIST
10331: PUSH
10332: LD_INT 24
10334: PUSH
10335: LD_INT 3
10337: PUSH
10338: LD_INT 3
10340: PUSH
10341: LD_INT 47
10343: PUSH
10344: EMPTY
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: PUSH
10350: LD_INT 24
10352: PUSH
10353: LD_INT 3
10355: PUSH
10356: LD_INT 3
10358: PUSH
10359: LD_INT 47
10361: PUSH
10362: EMPTY
10363: LIST
10364: LIST
10365: LIST
10366: LIST
10367: PUSH
10368: LD_INT 24
10370: PUSH
10371: LD_INT 3
10373: PUSH
10374: LD_INT 3
10376: PUSH
10377: LD_INT 46
10379: PUSH
10380: EMPTY
10381: LIST
10382: LIST
10383: LIST
10384: LIST
10385: PUSH
10386: LD_INT 24
10388: PUSH
10389: LD_INT 3
10391: PUSH
10392: LD_INT 3
10394: PUSH
10395: LD_INT 46
10397: PUSH
10398: EMPTY
10399: LIST
10400: LIST
10401: LIST
10402: LIST
10403: PUSH
10404: LD_INT 24
10406: PUSH
10407: LD_INT 3
10409: PUSH
10410: LD_INT 3
10412: PUSH
10413: LD_INT 46
10415: PUSH
10416: EMPTY
10417: LIST
10418: LIST
10419: LIST
10420: LIST
10421: PUSH
10422: EMPTY
10423: LIST
10424: LIST
10425: LIST
10426: LIST
10427: LIST
10428: LIST
10429: PPUSH
10430: CALL 58636 0 2
// end ; if Difficulty > 1 then
10434: LD_OWVAR 67
10438: PUSH
10439: LD_INT 1
10441: GREATER
10442: IFFALSE 10472
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10444: LD_INT 2
10446: PPUSH
10447: LD_INT 24
10449: PUSH
10450: LD_INT 3
10452: PUSH
10453: LD_INT 3
10455: PUSH
10456: LD_INT 47
10458: PUSH
10459: EMPTY
10460: LIST
10461: LIST
10462: LIST
10463: LIST
10464: PUSH
10465: EMPTY
10466: LIST
10467: PPUSH
10468: CALL 58636 0 2
// repeat wait ( 0 0$1 ) ;
10472: LD_INT 35
10474: PPUSH
10475: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10479: LD_INT 2
10481: PPUSH
10482: LD_INT 1
10484: PPUSH
10485: CALL 60054 0 2
10489: PUSH
10490: LD_INT 6
10492: PUSH
10493: LD_INT 7
10495: PUSH
10496: LD_INT 7
10498: PUSH
10499: EMPTY
10500: LIST
10501: LIST
10502: LIST
10503: PUSH
10504: LD_OWVAR 67
10508: ARRAY
10509: GREATEREQUAL
10510: IFFALSE 10472
// wait ( 0 0$30 ) ;
10512: LD_INT 1050
10514: PPUSH
10515: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10519: LD_ADDR_VAR 0 2
10523: PUSH
10524: LD_INT 2
10526: PPUSH
10527: LD_INT 1
10529: PPUSH
10530: CALL 60054 0 2
10534: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10535: LD_ADDR_EXP 129
10539: PUSH
10540: LD_EXP 129
10544: PPUSH
10545: LD_INT 2
10547: PPUSH
10548: LD_EXP 129
10552: PUSH
10553: LD_INT 2
10555: ARRAY
10556: PUSH
10557: LD_VAR 0 2
10561: DIFF
10562: PPUSH
10563: CALL_OW 1
10567: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10568: LD_ADDR_VAR 0 3
10572: PUSH
10573: LD_INT 0
10575: PPUSH
10576: LD_INT 1
10578: PPUSH
10579: CALL_OW 12
10583: ST_TO_ADDR
// if target then
10584: LD_VAR 0 3
10588: IFFALSE 10716
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10590: LD_ADDR_VAR 0 2
10594: PUSH
10595: LD_VAR 0 2
10599: PPUSH
10600: LD_INT 24
10602: PUSH
10603: LD_INT 250
10605: PUSH
10606: EMPTY
10607: LIST
10608: LIST
10609: PPUSH
10610: CALL_OW 72
10614: ST_TO_ADDR
// for i in tmp do
10615: LD_ADDR_VAR 0 1
10619: PUSH
10620: LD_VAR 0 2
10624: PUSH
10625: FOR_IN
10626: IFFALSE 10666
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10628: LD_VAR 0 1
10632: PPUSH
10633: LD_INT 139
10635: PPUSH
10636: LD_INT 89
10638: PPUSH
10639: CALL_OW 297
10643: PUSH
10644: LD_INT 9
10646: GREATER
10647: IFFALSE 10664
// ComMoveXY ( i , 139 , 89 ) ;
10649: LD_VAR 0 1
10653: PPUSH
10654: LD_INT 139
10656: PPUSH
10657: LD_INT 89
10659: PPUSH
10660: CALL_OW 111
10664: GO 10625
10666: POP
10667: POP
// wait ( 0 0$1 ) ;
10668: LD_INT 35
10670: PPUSH
10671: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10675: LD_VAR 0 2
10679: PPUSH
10680: LD_INT 92
10682: PUSH
10683: LD_INT 139
10685: PUSH
10686: LD_INT 89
10688: PUSH
10689: LD_INT 9
10691: PUSH
10692: EMPTY
10693: LIST
10694: LIST
10695: LIST
10696: LIST
10697: PPUSH
10698: CALL_OW 72
10702: PUSH
10703: LD_VAR 0 2
10707: PUSH
10708: LD_INT 1
10710: MINUS
10711: GREATEREQUAL
10712: IFFALSE 10590
// end else
10714: GO 10858
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10716: LD_VAR 0 2
10720: PPUSH
10721: LD_VAR 0 4
10725: PUSH
10726: LD_INT 1
10728: ARRAY
10729: PPUSH
10730: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10734: LD_ADDR_VAR 0 2
10738: PUSH
10739: LD_VAR 0 2
10743: PPUSH
10744: LD_INT 24
10746: PUSH
10747: LD_INT 250
10749: PUSH
10750: EMPTY
10751: LIST
10752: LIST
10753: PPUSH
10754: CALL_OW 72
10758: ST_TO_ADDR
// for i in tmp do
10759: LD_ADDR_VAR 0 1
10763: PUSH
10764: LD_VAR 0 2
10768: PUSH
10769: FOR_IN
10770: IFFALSE 10810
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10772: LD_VAR 0 1
10776: PPUSH
10777: LD_INT 124
10779: PPUSH
10780: LD_INT 139
10782: PPUSH
10783: CALL_OW 297
10787: PUSH
10788: LD_INT 9
10790: GREATER
10791: IFFALSE 10808
// ComMoveXY ( i , 124 , 139 ) ;
10793: LD_VAR 0 1
10797: PPUSH
10798: LD_INT 124
10800: PPUSH
10801: LD_INT 139
10803: PPUSH
10804: CALL_OW 111
10808: GO 10769
10810: POP
10811: POP
// wait ( 0 0$1 ) ;
10812: LD_INT 35
10814: PPUSH
10815: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10819: LD_VAR 0 2
10823: PPUSH
10824: LD_INT 92
10826: PUSH
10827: LD_INT 124
10829: PUSH
10830: LD_INT 139
10832: PUSH
10833: LD_INT 9
10835: PUSH
10836: EMPTY
10837: LIST
10838: LIST
10839: LIST
10840: LIST
10841: PPUSH
10842: CALL_OW 72
10846: PUSH
10847: LD_VAR 0 2
10851: PUSH
10852: LD_INT 1
10854: MINUS
10855: GREATEREQUAL
10856: IFFALSE 10734
// end ; repeat wait ( 0 0$1 ) ;
10858: LD_INT 35
10860: PPUSH
10861: CALL_OW 67
// for i in tmp do
10865: LD_ADDR_VAR 0 1
10869: PUSH
10870: LD_VAR 0 2
10874: PUSH
10875: FOR_IN
10876: IFFALSE 11045
// begin if GetLives ( i ) > 251 then
10878: LD_VAR 0 1
10882: PPUSH
10883: CALL_OW 256
10887: PUSH
10888: LD_INT 251
10890: GREATER
10891: IFFALSE 11016
// begin if GetWeapon ( i ) = ru_time_lapser then
10893: LD_VAR 0 1
10897: PPUSH
10898: CALL_OW 264
10902: PUSH
10903: LD_INT 49
10905: EQUAL
10906: IFFALSE 10962
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10908: LD_VAR 0 1
10912: PPUSH
10913: LD_INT 2
10915: PUSH
10916: LD_INT 22
10918: PUSH
10919: LD_INT 1
10921: PUSH
10922: EMPTY
10923: LIST
10924: LIST
10925: PUSH
10926: LD_INT 22
10928: PUSH
10929: LD_INT 8
10931: PUSH
10932: EMPTY
10933: LIST
10934: LIST
10935: PUSH
10936: EMPTY
10937: LIST
10938: LIST
10939: LIST
10940: PPUSH
10941: CALL_OW 69
10945: PPUSH
10946: LD_VAR 0 1
10950: PPUSH
10951: CALL_OW 74
10955: PPUSH
10956: CALL_OW 112
10960: GO 11014
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10962: LD_VAR 0 1
10966: PPUSH
10967: LD_INT 2
10969: PUSH
10970: LD_INT 22
10972: PUSH
10973: LD_INT 1
10975: PUSH
10976: EMPTY
10977: LIST
10978: LIST
10979: PUSH
10980: LD_INT 22
10982: PUSH
10983: LD_INT 8
10985: PUSH
10986: EMPTY
10987: LIST
10988: LIST
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: LIST
10994: PPUSH
10995: CALL_OW 69
10999: PPUSH
11000: LD_VAR 0 1
11004: PPUSH
11005: CALL_OW 74
11009: PPUSH
11010: CALL_OW 115
// end else
11014: GO 11043
// if IsDead ( i ) then
11016: LD_VAR 0 1
11020: PPUSH
11021: CALL_OW 301
11025: IFFALSE 11043
// tmp := tmp diff i ;
11027: LD_ADDR_VAR 0 2
11031: PUSH
11032: LD_VAR 0 2
11036: PUSH
11037: LD_VAR 0 1
11041: DIFF
11042: ST_TO_ADDR
// end ;
11043: GO 10875
11045: POP
11046: POP
// until not tmp ;
11047: LD_VAR 0 2
11051: NOT
11052: IFFALSE 10858
// end ; end_of_file
11054: PPOPN 4
11056: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11057: LD_INT 0
11059: PPUSH
11060: PPUSH
11061: PPUSH
11062: PPUSH
11063: PPUSH
11064: PPUSH
// side := 7 ;
11065: LD_ADDR_VAR 0 5
11069: PUSH
11070: LD_INT 7
11072: ST_TO_ADDR
// uc_side := side ;
11073: LD_ADDR_OWVAR 20
11077: PUSH
11078: LD_VAR 0 5
11082: ST_TO_ADDR
// uc_nation := 1 ;
11083: LD_ADDR_OWVAR 21
11087: PUSH
11088: LD_INT 1
11090: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11091: LD_ADDR_VAR 0 2
11095: PUSH
11096: LD_INT 22
11098: PUSH
11099: LD_VAR 0 5
11103: PUSH
11104: EMPTY
11105: LIST
11106: LIST
11107: PUSH
11108: LD_INT 21
11110: PUSH
11111: LD_INT 3
11113: PUSH
11114: EMPTY
11115: LIST
11116: LIST
11117: PUSH
11118: EMPTY
11119: LIST
11120: LIST
11121: PPUSH
11122: CALL_OW 69
11126: PUSH
11127: FOR_IN
11128: IFFALSE 11144
// SetBLevel ( i , 10 ) ;
11130: LD_VAR 0 2
11134: PPUSH
11135: LD_INT 10
11137: PPUSH
11138: CALL_OW 241
11142: GO 11127
11144: POP
11145: POP
// base := GetBase ( al_depot ) ;
11146: LD_ADDR_VAR 0 4
11150: PUSH
11151: LD_INT 2
11153: PPUSH
11154: CALL_OW 274
11158: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11159: LD_ADDR_VAR 0 6
11163: PUSH
11164: LD_INT 22
11166: PUSH
11167: LD_VAR 0 5
11171: PUSH
11172: EMPTY
11173: LIST
11174: LIST
11175: PUSH
11176: LD_INT 30
11178: PUSH
11179: LD_INT 34
11181: PUSH
11182: EMPTY
11183: LIST
11184: LIST
11185: PUSH
11186: EMPTY
11187: LIST
11188: LIST
11189: PPUSH
11190: CALL_OW 69
11194: ST_TO_ADDR
// if teleport then
11195: LD_VAR 0 6
11199: IFFALSE 11220
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11201: LD_VAR 0 6
11205: PUSH
11206: LD_INT 1
11208: ARRAY
11209: PPUSH
11210: LD_INT 262
11212: PPUSH
11213: LD_INT 119
11215: PPUSH
11216: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11220: LD_VAR 0 4
11224: PPUSH
11225: LD_INT 1
11227: PPUSH
11228: LD_INT 19500
11230: PPUSH
11231: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11235: LD_VAR 0 4
11239: PPUSH
11240: LD_INT 2
11242: PPUSH
11243: LD_INT 200
11245: PPUSH
11246: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11250: LD_VAR 0 4
11254: PPUSH
11255: LD_INT 3
11257: PPUSH
11258: LD_INT 650
11260: PPUSH
11261: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11265: LD_ADDR_EXP 74
11269: PUSH
11270: LD_STRING Roth
11272: PPUSH
11273: CALL_OW 25
11277: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11278: LD_ADDR_EXP 75
11282: PUSH
11283: LD_STRING Simms
11285: PPUSH
11286: LD_EXP 1
11290: NOT
11291: PPUSH
11292: LD_STRING 10c_
11294: PPUSH
11295: CALL 64980 0 3
11299: ST_TO_ADDR
// if not Simms then
11300: LD_EXP 75
11304: NOT
11305: IFFALSE 11335
// begin uc_nation := 1 ;
11307: LD_ADDR_OWVAR 21
11311: PUSH
11312: LD_INT 1
11314: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11315: LD_INT 2
11317: PPUSH
11318: LD_INT 10
11320: PPUSH
11321: CALL_OW 384
// Simms := CreateHuman ;
11325: LD_ADDR_EXP 75
11329: PUSH
11330: CALL_OW 44
11334: ST_TO_ADDR
// end ; uc_nation := 3 ;
11335: LD_ADDR_OWVAR 21
11339: PUSH
11340: LD_INT 3
11342: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11343: LD_ADDR_EXP 76
11347: PUSH
11348: LD_STRING Kirilenkova
11350: PPUSH
11351: CALL_OW 25
11355: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11356: LD_ADDR_EXP 90
11360: PUSH
11361: LD_STRING Oblukov
11363: PPUSH
11364: CALL_OW 25
11368: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11369: LD_ADDR_EXP 77
11373: PUSH
11374: LD_STRING Dolgov
11376: PPUSH
11377: CALL_OW 25
11381: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11382: LD_ADDR_EXP 78
11386: PUSH
11387: LD_STRING Petrosyan
11389: PPUSH
11390: CALL_OW 25
11394: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11395: LD_ADDR_EXP 89
11399: PUSH
11400: LD_STRING Scholtze
11402: PPUSH
11403: CALL_OW 25
11407: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11408: LD_ADDR_EXP 88
11412: PUSH
11413: LD_STRING Kapitsova
11415: PPUSH
11416: CALL_OW 25
11420: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11421: LD_ADDR_EXP 79
11425: PUSH
11426: LD_STRING Petrovova
11428: PPUSH
11429: CALL_OW 25
11433: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11434: LD_ADDR_EXP 80
11438: PUSH
11439: LD_STRING Kuzmov
11441: PPUSH
11442: CALL_OW 25
11446: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11447: LD_ADDR_EXP 87
11451: PUSH
11452: LD_STRING Karamazov
11454: PPUSH
11455: CALL_OW 25
11459: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11460: LD_STRING 13_Lipshchin_1
11462: PPUSH
11463: LD_INT 0
11465: PPUSH
11466: CALL_OW 30
11470: IFFALSE 11485
// Lipshchin := NewCharacter ( Lipshchin ) ;
11472: LD_ADDR_EXP 81
11476: PUSH
11477: LD_STRING Lipshchin
11479: PPUSH
11480: CALL_OW 25
11484: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11485: LD_STRING 13_Titov_1
11487: PPUSH
11488: LD_INT 0
11490: PPUSH
11491: CALL_OW 30
11495: IFFALSE 11510
// Titov := NewCharacter ( Titov ) ;
11497: LD_ADDR_EXP 83
11501: PUSH
11502: LD_STRING Titov
11504: PPUSH
11505: CALL_OW 25
11509: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11510: LD_STRING 13_Gnyevko_1
11512: PPUSH
11513: LD_INT 0
11515: PPUSH
11516: CALL_OW 30
11520: IFFALSE 11535
// Gnyevko := NewCharacter ( Gnyevko ) ;
11522: LD_ADDR_EXP 82
11526: PUSH
11527: LD_STRING Gnyevko
11529: PPUSH
11530: CALL_OW 25
11534: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11535: LD_STRING 13_Xavier_1
11537: PPUSH
11538: LD_INT 0
11540: PPUSH
11541: CALL_OW 30
11545: IFFALSE 11560
// Xavier := NewCharacter ( Xavier2 ) ;
11547: LD_ADDR_EXP 84
11551: PUSH
11552: LD_STRING Xavier2
11554: PPUSH
11555: CALL_OW 25
11559: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11560: LD_STRING 13_Belkov_1
11562: PPUSH
11563: LD_INT 0
11565: PPUSH
11566: CALL_OW 30
11570: IFFALSE 11585
// Belkov := NewCharacter ( Belkov ) ;
11572: LD_ADDR_EXP 85
11576: PUSH
11577: LD_STRING Belkov
11579: PPUSH
11580: CALL_OW 25
11584: ST_TO_ADDR
// if not BurlakStatus then
11585: LD_EXP 9
11589: NOT
11590: IFFALSE 11605
// Burlak = NewCharacter ( Burlak ) ;
11592: LD_ADDR_EXP 86
11596: PUSH
11597: LD_STRING Burlak
11599: PPUSH
11600: CALL_OW 25
11604: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11605: LD_ADDR_VAR 0 3
11609: PUSH
11610: LD_EXP 74
11614: PUSH
11615: LD_EXP 76
11619: PUSH
11620: LD_EXP 90
11624: PUSH
11625: LD_EXP 77
11629: PUSH
11630: LD_EXP 78
11634: PUSH
11635: LD_EXP 89
11639: PUSH
11640: LD_EXP 88
11644: PUSH
11645: LD_EXP 79
11649: PUSH
11650: LD_EXP 80
11654: PUSH
11655: LD_EXP 87
11659: PUSH
11660: EMPTY
11661: LIST
11662: LIST
11663: LIST
11664: LIST
11665: LIST
11666: LIST
11667: LIST
11668: LIST
11669: LIST
11670: LIST
11671: ST_TO_ADDR
// if Simms then
11672: LD_EXP 75
11676: IFFALSE 11694
// tmp := tmp ^ Simms ;
11678: LD_ADDR_VAR 0 3
11682: PUSH
11683: LD_VAR 0 3
11687: PUSH
11688: LD_EXP 75
11692: ADD
11693: ST_TO_ADDR
// if Titov then
11694: LD_EXP 83
11698: IFFALSE 11716
// tmp := tmp ^ Titov ;
11700: LD_ADDR_VAR 0 3
11704: PUSH
11705: LD_VAR 0 3
11709: PUSH
11710: LD_EXP 83
11714: ADD
11715: ST_TO_ADDR
// if Lipshchin then
11716: LD_EXP 81
11720: IFFALSE 11738
// tmp := tmp ^ Lipshchin ;
11722: LD_ADDR_VAR 0 3
11726: PUSH
11727: LD_VAR 0 3
11731: PUSH
11732: LD_EXP 81
11736: ADD
11737: ST_TO_ADDR
// if Gnyevko then
11738: LD_EXP 82
11742: IFFALSE 11760
// tmp := tmp ^ Gnyevko ;
11744: LD_ADDR_VAR 0 3
11748: PUSH
11749: LD_VAR 0 3
11753: PUSH
11754: LD_EXP 82
11758: ADD
11759: ST_TO_ADDR
// if Xavier then
11760: LD_EXP 84
11764: IFFALSE 11782
// tmp := tmp ^ Xavier ;
11766: LD_ADDR_VAR 0 3
11770: PUSH
11771: LD_VAR 0 3
11775: PUSH
11776: LD_EXP 84
11780: ADD
11781: ST_TO_ADDR
// if Belkov then
11782: LD_EXP 85
11786: IFFALSE 11804
// tmp := tmp ^ Belkov ;
11788: LD_ADDR_VAR 0 3
11792: PUSH
11793: LD_VAR 0 3
11797: PUSH
11798: LD_EXP 85
11802: ADD
11803: ST_TO_ADDR
// if Burlak then
11804: LD_EXP 86
11808: IFFALSE 11826
// tmp := tmp ^ Burlak ;
11810: LD_ADDR_VAR 0 3
11814: PUSH
11815: LD_VAR 0 3
11819: PUSH
11820: LD_EXP 86
11824: ADD
11825: ST_TO_ADDR
// for i = 1 to 11 do
11826: LD_ADDR_VAR 0 2
11830: PUSH
11831: DOUBLE
11832: LD_INT 1
11834: DEC
11835: ST_TO_ADDR
11836: LD_INT 11
11838: PUSH
11839: FOR_TO
11840: IFFALSE 11906
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11842: LD_ADDR_OWVAR 21
11846: PUSH
11847: LD_INT 1
11849: PUSH
11850: LD_INT 3
11852: PUSH
11853: EMPTY
11854: LIST
11855: LIST
11856: PUSH
11857: LD_INT 1
11859: PPUSH
11860: LD_INT 2
11862: PPUSH
11863: CALL_OW 12
11867: ARRAY
11868: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11869: LD_INT 0
11871: PPUSH
11872: LD_VAR 0 2
11876: PUSH
11877: LD_INT 2
11879: DIV
11880: PPUSH
11881: LD_INT 10
11883: PPUSH
11884: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11888: LD_ADDR_VAR 0 3
11892: PUSH
11893: LD_VAR 0 3
11897: PUSH
11898: CALL_OW 44
11902: ADD
11903: ST_TO_ADDR
// end ;
11904: GO 11839
11906: POP
11907: POP
// for i in tmp do
11908: LD_ADDR_VAR 0 2
11912: PUSH
11913: LD_VAR 0 3
11917: PUSH
11918: FOR_IN
11919: IFFALSE 11944
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11921: LD_VAR 0 2
11925: PPUSH
11926: LD_INT 260
11928: PPUSH
11929: LD_INT 235
11931: PPUSH
11932: LD_INT 8
11934: PPUSH
11935: LD_INT 0
11937: PPUSH
11938: CALL_OW 50
11942: GO 11918
11944: POP
11945: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11946: LD_ADDR_EXP 110
11950: PUSH
11951: LD_EXP 110
11955: PPUSH
11956: LD_INT 1
11958: PPUSH
11959: LD_INT 22
11961: PUSH
11962: LD_VAR 0 5
11966: PUSH
11967: EMPTY
11968: LIST
11969: LIST
11970: PUSH
11971: LD_INT 3
11973: PUSH
11974: LD_INT 21
11976: PUSH
11977: LD_INT 2
11979: PUSH
11980: EMPTY
11981: LIST
11982: LIST
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: PUSH
11988: EMPTY
11989: LIST
11990: LIST
11991: PPUSH
11992: CALL_OW 69
11996: PUSH
11997: LD_EXP 74
12001: PUSH
12002: LD_EXP 75
12006: PUSH
12007: EMPTY
12008: LIST
12009: LIST
12010: DIFF
12011: PPUSH
12012: CALL_OW 1
12016: ST_TO_ADDR
// uc_side := 0 ;
12017: LD_ADDR_OWVAR 20
12021: PUSH
12022: LD_INT 0
12024: ST_TO_ADDR
// uc_nation := 0 ;
12025: LD_ADDR_OWVAR 21
12029: PUSH
12030: LD_INT 0
12032: ST_TO_ADDR
// for i = 1 to 5 do
12033: LD_ADDR_VAR 0 2
12037: PUSH
12038: DOUBLE
12039: LD_INT 1
12041: DEC
12042: ST_TO_ADDR
12043: LD_INT 5
12045: PUSH
12046: FOR_TO
12047: IFFALSE 12084
// begin InitHc ;
12049: CALL_OW 19
// hc_class := class_apeman ;
12053: LD_ADDR_OWVAR 28
12057: PUSH
12058: LD_INT 12
12060: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12061: CALL_OW 44
12065: PPUSH
12066: LD_INT 299
12068: PPUSH
12069: LD_INT 229
12071: PPUSH
12072: LD_INT 10
12074: PPUSH
12075: LD_INT 0
12077: PPUSH
12078: CALL_OW 50
// end ;
12082: GO 12046
12084: POP
12085: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12086: LD_EXP 74
12090: PPUSH
12091: LD_INT 259
12093: PPUSH
12094: LD_INT 235
12096: PPUSH
12097: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12101: LD_EXP 74
12105: PPUSH
12106: LD_INT 262
12108: PPUSH
12109: LD_INT 235
12111: PPUSH
12112: CALL_OW 178
// if Simms then
12116: LD_EXP 75
12120: IFFALSE 12151
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12122: LD_EXP 75
12126: PPUSH
12127: LD_INT 262
12129: PPUSH
12130: LD_INT 235
12132: PPUSH
12133: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12137: LD_EXP 75
12141: PPUSH
12142: LD_EXP 74
12146: PPUSH
12147: CALL_OW 179
// end ; end ;
12151: LD_VAR 0 1
12155: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12156: LD_EXP 31
12160: PUSH
12161: LD_EXP 23
12165: NOT
12166: AND
12167: IFFALSE 12343
12169: GO 12171
12171: DISABLE
12172: LD_INT 0
12174: PPUSH
12175: PPUSH
12176: PPUSH
// begin enable ;
12177: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12178: LD_ADDR_VAR 0 2
12182: PUSH
12183: LD_INT 81
12185: PUSH
12186: LD_INT 7
12188: PUSH
12189: EMPTY
12190: LIST
12191: LIST
12192: PUSH
12193: LD_INT 2
12195: PUSH
12196: LD_INT 32
12198: PUSH
12199: LD_INT 3
12201: PUSH
12202: EMPTY
12203: LIST
12204: LIST
12205: PUSH
12206: LD_INT 30
12208: PUSH
12209: LD_INT 30
12211: PUSH
12212: EMPTY
12213: LIST
12214: LIST
12215: PUSH
12216: LD_INT 30
12218: PUSH
12219: LD_INT 28
12221: PUSH
12222: EMPTY
12223: LIST
12224: LIST
12225: PUSH
12226: LD_INT 34
12228: PUSH
12229: LD_INT 49
12231: PUSH
12232: EMPTY
12233: LIST
12234: LIST
12235: PUSH
12236: LD_INT 34
12238: PUSH
12239: LD_INT 10
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: PUSH
12246: LD_INT 34
12248: PUSH
12249: LD_INT 8
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: PUSH
12256: EMPTY
12257: LIST
12258: LIST
12259: LIST
12260: LIST
12261: LIST
12262: LIST
12263: LIST
12264: PUSH
12265: EMPTY
12266: LIST
12267: LIST
12268: PPUSH
12269: CALL_OW 69
12273: ST_TO_ADDR
// if not tmp then
12274: LD_VAR 0 2
12278: NOT
12279: IFFALSE 12283
// exit ;
12281: GO 12343
// target := tmp [ rand ( 1 , tmp ) ] ;
12283: LD_ADDR_VAR 0 3
12287: PUSH
12288: LD_VAR 0 2
12292: PUSH
12293: LD_INT 1
12295: PPUSH
12296: LD_VAR 0 2
12300: PPUSH
12301: CALL_OW 12
12305: ARRAY
12306: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12307: LD_VAR 0 3
12311: PPUSH
12312: CALL_OW 255
12316: PUSH
12317: LD_INT 1
12319: EQUAL
12320: IFFALSE 12331
// CenterNowOnUnits ( target ) ;
12322: LD_VAR 0 3
12326: PPUSH
12327: CALL_OW 87
// SetLives ( target , 0 ) ;
12331: LD_VAR 0 3
12335: PPUSH
12336: LD_INT 0
12338: PPUSH
12339: CALL_OW 234
// end ;
12343: PPOPN 3
12345: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12346: LD_EXP 23
12350: NOT
12351: PUSH
12352: LD_EXP 31
12356: AND
12357: IFFALSE 12879
12359: GO 12361
12361: DISABLE
12362: LD_INT 0
12364: PPUSH
12365: PPUSH
12366: PPUSH
// begin uc_side := 7 ;
12367: LD_ADDR_OWVAR 20
12371: PUSH
12372: LD_INT 7
12374: ST_TO_ADDR
// uc_nation := 1 ;
12375: LD_ADDR_OWVAR 21
12379: PUSH
12380: LD_INT 1
12382: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12383: LD_ADDR_VAR 0 3
12387: PUSH
12388: LD_INT 125
12390: PUSH
12391: LD_INT 163
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PUSH
12398: LD_INT 185
12400: PUSH
12401: LD_INT 168
12403: PUSH
12404: EMPTY
12405: LIST
12406: LIST
12407: PUSH
12408: LD_INT 111
12410: PUSH
12411: LD_INT 97
12413: PUSH
12414: EMPTY
12415: LIST
12416: LIST
12417: PUSH
12418: EMPTY
12419: LIST
12420: LIST
12421: LIST
12422: PPUSH
12423: CALL 100942 0 1
12427: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12428: LD_ADDR_EXP 91
12432: PUSH
12433: EMPTY
12434: ST_TO_ADDR
// for i = 1 to Difficulty do
12435: LD_ADDR_VAR 0 1
12439: PUSH
12440: DOUBLE
12441: LD_INT 1
12443: DEC
12444: ST_TO_ADDR
12445: LD_OWVAR 67
12449: PUSH
12450: FOR_TO
12451: IFFALSE 12609
// begin InitHc ;
12453: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12457: LD_INT 0
12459: PPUSH
12460: LD_INT 8
12462: PPUSH
12463: CALL_OW 381
// un := CreateHuman ;
12467: LD_ADDR_VAR 0 2
12471: PUSH
12472: CALL_OW 44
12476: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12477: LD_VAR 0 2
12481: PPUSH
12482: LD_INT 258
12484: PPUSH
12485: LD_INT 267
12487: PPUSH
12488: LD_INT 4
12490: PPUSH
12491: LD_INT 0
12493: PPUSH
12494: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12498: LD_ADDR_EXP 91
12502: PUSH
12503: LD_EXP 91
12507: PUSH
12508: LD_VAR 0 2
12512: UNION
12513: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12514: LD_VAR 0 2
12518: PPUSH
12519: LD_VAR 0 3
12523: PUSH
12524: LD_VAR 0 1
12528: ARRAY
12529: PUSH
12530: LD_INT 1
12532: ARRAY
12533: PPUSH
12534: LD_VAR 0 3
12538: PUSH
12539: LD_VAR 0 1
12543: ARRAY
12544: PUSH
12545: LD_INT 2
12547: ARRAY
12548: PPUSH
12549: LD_INT 4
12551: PPUSH
12552: LD_INT 1
12554: PPUSH
12555: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12559: LD_VAR 0 2
12563: PPUSH
12564: LD_VAR 0 3
12568: PUSH
12569: LD_VAR 0 1
12573: ARRAY
12574: PUSH
12575: LD_INT 1
12577: ARRAY
12578: PPUSH
12579: LD_VAR 0 3
12583: PUSH
12584: LD_VAR 0 1
12588: ARRAY
12589: PUSH
12590: LD_INT 2
12592: ARRAY
12593: PPUSH
12594: CALL_OW 171
// AddComInvisible ( un ) ;
12598: LD_VAR 0 2
12602: PPUSH
12603: CALL_OW 212
// end ;
12607: GO 12450
12609: POP
12610: POP
// repeat wait ( 0 0$20 ) ;
12611: LD_INT 700
12613: PPUSH
12614: CALL_OW 67
// for i in allianceSpecialForce do
12618: LD_ADDR_VAR 0 1
12622: PUSH
12623: LD_EXP 91
12627: PUSH
12628: FOR_IN
12629: IFFALSE 12864
// begin if IsInvisible ( i ) then
12631: LD_VAR 0 1
12635: PPUSH
12636: CALL_OW 571
12640: IFFALSE 12833
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12642: LD_ADDR_VAR 0 3
12646: PUSH
12647: LD_INT 22
12649: PUSH
12650: LD_INT 1
12652: PUSH
12653: EMPTY
12654: LIST
12655: LIST
12656: PUSH
12657: LD_INT 50
12659: PUSH
12660: EMPTY
12661: LIST
12662: PUSH
12663: LD_INT 56
12665: PUSH
12666: EMPTY
12667: LIST
12668: PUSH
12669: LD_INT 91
12671: PUSH
12672: LD_VAR 0 1
12676: PUSH
12677: LD_INT 25
12679: PUSH
12680: LD_INT 30
12682: PUSH
12683: LD_INT 35
12685: PUSH
12686: EMPTY
12687: LIST
12688: LIST
12689: LIST
12690: PUSH
12691: LD_OWVAR 67
12695: ARRAY
12696: PUSH
12697: EMPTY
12698: LIST
12699: LIST
12700: LIST
12701: PUSH
12702: LD_INT 2
12704: PUSH
12705: LD_INT 25
12707: PUSH
12708: LD_INT 1
12710: PUSH
12711: EMPTY
12712: LIST
12713: LIST
12714: PUSH
12715: LD_INT 25
12717: PUSH
12718: LD_INT 2
12720: PUSH
12721: EMPTY
12722: LIST
12723: LIST
12724: PUSH
12725: LD_INT 25
12727: PUSH
12728: LD_INT 3
12730: PUSH
12731: EMPTY
12732: LIST
12733: LIST
12734: PUSH
12735: LD_INT 25
12737: PUSH
12738: LD_INT 4
12740: PUSH
12741: EMPTY
12742: LIST
12743: LIST
12744: PUSH
12745: LD_INT 25
12747: PUSH
12748: LD_INT 5
12750: PUSH
12751: EMPTY
12752: LIST
12753: LIST
12754: PUSH
12755: LD_INT 25
12757: PUSH
12758: LD_INT 8
12760: PUSH
12761: EMPTY
12762: LIST
12763: LIST
12764: PUSH
12765: EMPTY
12766: LIST
12767: LIST
12768: LIST
12769: LIST
12770: LIST
12771: LIST
12772: LIST
12773: PUSH
12774: EMPTY
12775: LIST
12776: LIST
12777: LIST
12778: LIST
12779: LIST
12780: PPUSH
12781: CALL_OW 69
12785: ST_TO_ADDR
// if not tmp then
12786: LD_VAR 0 3
12790: NOT
12791: IFFALSE 12795
// continue ;
12793: GO 12628
// if Prob ( 30 * Difficulty ) then
12795: LD_INT 30
12797: PUSH
12798: LD_OWVAR 67
12802: MUL
12803: PPUSH
12804: CALL_OW 13
12808: IFFALSE 12833
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12810: LD_VAR 0 3
12814: PUSH
12815: LD_INT 1
12817: PPUSH
12818: LD_VAR 0 3
12822: PPUSH
12823: CALL_OW 12
12827: ARRAY
12828: PPUSH
12829: CALL 31022 0 1
// end ; if IsDead ( i ) then
12833: LD_VAR 0 1
12837: PPUSH
12838: CALL_OW 301
12842: IFFALSE 12862
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12844: LD_ADDR_EXP 91
12848: PUSH
12849: LD_EXP 91
12853: PUSH
12854: LD_VAR 0 1
12858: DIFF
12859: ST_TO_ADDR
// continue ;
12860: GO 12628
// end ; end ;
12862: GO 12628
12864: POP
12865: POP
// until allianceDestroyed or not allianceSpecialForce ;
12866: LD_EXP 23
12870: PUSH
12871: LD_EXP 91
12875: NOT
12876: OR
12877: IFFALSE 12611
// end ;
12879: PPOPN 3
12881: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12882: LD_EXP 23
12886: NOT
12887: PUSH
12888: LD_EXP 31
12892: AND
12893: IFFALSE 13860
12895: GO 12897
12897: DISABLE
12898: LD_INT 0
12900: PPUSH
12901: PPUSH
12902: PPUSH
12903: PPUSH
// begin enable ;
12904: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12905: LD_INT 22
12907: PUSH
12908: LD_INT 7
12910: PUSH
12911: EMPTY
12912: LIST
12913: LIST
12914: PUSH
12915: LD_INT 30
12917: PUSH
12918: LD_INT 3
12920: PUSH
12921: EMPTY
12922: LIST
12923: LIST
12924: PUSH
12925: EMPTY
12926: LIST
12927: LIST
12928: PPUSH
12929: CALL_OW 69
12933: NOT
12934: IFFALSE 12938
// exit ;
12936: GO 13860
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12938: LD_ADDR_VAR 0 4
12942: PUSH
12943: LD_INT 22
12945: PUSH
12946: LD_INT 7
12948: PUSH
12949: EMPTY
12950: LIST
12951: LIST
12952: PUSH
12953: LD_INT 30
12955: PUSH
12956: LD_INT 34
12958: PUSH
12959: EMPTY
12960: LIST
12961: LIST
12962: PUSH
12963: EMPTY
12964: LIST
12965: LIST
12966: PPUSH
12967: CALL_OW 69
12971: ST_TO_ADDR
// if Prob ( 40 ) then
12972: LD_INT 40
12974: PPUSH
12975: CALL_OW 13
12979: IFFALSE 13106
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12981: LD_INT 1
12983: PPUSH
12984: LD_INT 5
12986: PUSH
12987: LD_INT 3
12989: PUSH
12990: LD_INT 2
12992: PUSH
12993: LD_INT 6
12995: PUSH
12996: EMPTY
12997: LIST
12998: LIST
12999: LIST
13000: LIST
13001: PUSH
13002: LD_INT 5
13004: PUSH
13005: LD_INT 3
13007: PUSH
13008: LD_INT 2
13010: PUSH
13011: LD_INT 6
13013: PUSH
13014: EMPTY
13015: LIST
13016: LIST
13017: LIST
13018: LIST
13019: PUSH
13020: LD_INT 5
13022: PUSH
13023: LD_INT 3
13025: PUSH
13026: LD_INT 2
13028: PUSH
13029: LD_INT 6
13031: PUSH
13032: EMPTY
13033: LIST
13034: LIST
13035: LIST
13036: LIST
13037: PUSH
13038: LD_INT 24
13040: PUSH
13041: LD_INT 3
13043: PUSH
13044: LD_INT 3
13046: PUSH
13047: LD_INT 45
13049: PUSH
13050: EMPTY
13051: LIST
13052: LIST
13053: LIST
13054: LIST
13055: PUSH
13056: LD_INT 24
13058: PUSH
13059: LD_INT 3
13061: PUSH
13062: LD_INT 3
13064: PUSH
13065: LD_INT 47
13067: PUSH
13068: EMPTY
13069: LIST
13070: LIST
13071: LIST
13072: LIST
13073: PUSH
13074: LD_INT 24
13076: PUSH
13077: LD_INT 3
13079: PUSH
13080: LD_INT 3
13082: PUSH
13083: LD_INT 45
13085: PUSH
13086: EMPTY
13087: LIST
13088: LIST
13089: LIST
13090: LIST
13091: PUSH
13092: EMPTY
13093: LIST
13094: LIST
13095: LIST
13096: LIST
13097: LIST
13098: LIST
13099: PPUSH
13100: CALL 58636 0 2
// end else
13104: GO 13229
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13106: LD_INT 1
13108: PPUSH
13109: LD_INT 24
13111: PUSH
13112: LD_INT 3
13114: PUSH
13115: LD_INT 3
13117: PUSH
13118: LD_INT 47
13120: PUSH
13121: EMPTY
13122: LIST
13123: LIST
13124: LIST
13125: LIST
13126: PUSH
13127: LD_INT 24
13129: PUSH
13130: LD_INT 3
13132: PUSH
13133: LD_INT 3
13135: PUSH
13136: LD_INT 47
13138: PUSH
13139: EMPTY
13140: LIST
13141: LIST
13142: LIST
13143: LIST
13144: PUSH
13145: LD_INT 5
13147: PUSH
13148: LD_INT 3
13150: PUSH
13151: LD_INT 2
13153: PUSH
13154: LD_INT 9
13156: PUSH
13157: EMPTY
13158: LIST
13159: LIST
13160: LIST
13161: LIST
13162: PUSH
13163: LD_INT 5
13165: PUSH
13166: LD_INT 3
13168: PUSH
13169: LD_INT 2
13171: PUSH
13172: LD_INT 9
13174: PUSH
13175: EMPTY
13176: LIST
13177: LIST
13178: LIST
13179: LIST
13180: PUSH
13181: LD_INT 24
13183: PUSH
13184: LD_INT 1
13186: PUSH
13187: LD_INT 3
13189: PUSH
13190: LD_INT 45
13192: PUSH
13193: EMPTY
13194: LIST
13195: LIST
13196: LIST
13197: LIST
13198: PUSH
13199: LD_INT 24
13201: PUSH
13202: LD_INT 1
13204: PUSH
13205: LD_INT 3
13207: PUSH
13208: LD_INT 45
13210: PUSH
13211: EMPTY
13212: LIST
13213: LIST
13214: LIST
13215: LIST
13216: PUSH
13217: EMPTY
13218: LIST
13219: LIST
13220: LIST
13221: LIST
13222: LIST
13223: LIST
13224: PPUSH
13225: CALL 58636 0 2
// end ; if Difficulty > 1 then
13229: LD_OWVAR 67
13233: PUSH
13234: LD_INT 1
13236: GREATER
13237: IFFALSE 13267
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13239: LD_INT 1
13241: PPUSH
13242: LD_INT 24
13244: PUSH
13245: LD_INT 3
13247: PUSH
13248: LD_INT 3
13250: PUSH
13251: LD_INT 47
13253: PUSH
13254: EMPTY
13255: LIST
13256: LIST
13257: LIST
13258: LIST
13259: PUSH
13260: EMPTY
13261: LIST
13262: PPUSH
13263: CALL 58636 0 2
// repeat wait ( 0 0$1 ) ;
13267: LD_INT 35
13269: PPUSH
13270: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13274: LD_INT 1
13276: PPUSH
13277: LD_INT 1
13279: PPUSH
13280: CALL 60054 0 2
13284: PUSH
13285: LD_INT 6
13287: PUSH
13288: LD_INT 7
13290: PUSH
13291: LD_INT 7
13293: PUSH
13294: EMPTY
13295: LIST
13296: LIST
13297: LIST
13298: PUSH
13299: LD_OWVAR 67
13303: ARRAY
13304: GREATEREQUAL
13305: IFFALSE 13267
// wait ( 0 0$40 ) ;
13307: LD_INT 1400
13309: PPUSH
13310: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13314: LD_ADDR_VAR 0 2
13318: PUSH
13319: LD_INT 1
13321: PPUSH
13322: LD_INT 1
13324: PPUSH
13325: CALL 60054 0 2
13329: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13330: LD_ADDR_EXP 129
13334: PUSH
13335: LD_EXP 129
13339: PPUSH
13340: LD_INT 1
13342: PPUSH
13343: LD_EXP 129
13347: PUSH
13348: LD_INT 1
13350: ARRAY
13351: PUSH
13352: LD_VAR 0 2
13356: DIFF
13357: PPUSH
13358: CALL_OW 1
13362: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13363: LD_ADDR_VAR 0 3
13367: PUSH
13368: LD_INT 0
13370: PPUSH
13371: LD_INT 1
13373: PPUSH
13374: CALL_OW 12
13378: ST_TO_ADDR
// if target then
13379: LD_VAR 0 3
13383: IFFALSE 13549
// begin for i in tmp do
13385: LD_ADDR_VAR 0 1
13389: PUSH
13390: LD_VAR 0 2
13394: PUSH
13395: FOR_IN
13396: IFFALSE 13421
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13398: LD_VAR 0 1
13402: PPUSH
13403: LD_INT 179
13405: PPUSH
13406: LD_INT 209
13408: PPUSH
13409: LD_INT 8
13411: PPUSH
13412: LD_INT 1
13414: PPUSH
13415: CALL_OW 483
13419: GO 13395
13421: POP
13422: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13423: LD_ADDR_VAR 0 2
13427: PUSH
13428: LD_VAR 0 2
13432: PPUSH
13433: LD_INT 24
13435: PUSH
13436: LD_INT 250
13438: PUSH
13439: EMPTY
13440: LIST
13441: LIST
13442: PPUSH
13443: CALL_OW 72
13447: ST_TO_ADDR
// for i in tmp do
13448: LD_ADDR_VAR 0 1
13452: PUSH
13453: LD_VAR 0 2
13457: PUSH
13458: FOR_IN
13459: IFFALSE 13499
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13461: LD_VAR 0 1
13465: PPUSH
13466: LD_INT 179
13468: PPUSH
13469: LD_INT 209
13471: PPUSH
13472: CALL_OW 297
13476: PUSH
13477: LD_INT 9
13479: GREATER
13480: IFFALSE 13497
// ComMoveXY ( i , 179 , 209 ) ;
13482: LD_VAR 0 1
13486: PPUSH
13487: LD_INT 179
13489: PPUSH
13490: LD_INT 209
13492: PPUSH
13493: CALL_OW 111
13497: GO 13458
13499: POP
13500: POP
// wait ( 0 0$1 ) ;
13501: LD_INT 35
13503: PPUSH
13504: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13508: LD_VAR 0 2
13512: PPUSH
13513: LD_INT 92
13515: PUSH
13516: LD_INT 179
13518: PUSH
13519: LD_INT 209
13521: PUSH
13522: LD_INT 9
13524: PUSH
13525: EMPTY
13526: LIST
13527: LIST
13528: LIST
13529: LIST
13530: PPUSH
13531: CALL_OW 72
13535: PUSH
13536: LD_VAR 0 2
13540: PUSH
13541: LD_INT 1
13543: MINUS
13544: GREATEREQUAL
13545: IFFALSE 13423
// end else
13547: GO 13711
// begin for i in tmp do
13549: LD_ADDR_VAR 0 1
13553: PUSH
13554: LD_VAR 0 2
13558: PUSH
13559: FOR_IN
13560: IFFALSE 13585
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13562: LD_VAR 0 1
13566: PPUSH
13567: LD_INT 285
13569: PPUSH
13570: LD_INT 163
13572: PPUSH
13573: LD_INT 8
13575: PPUSH
13576: LD_INT 1
13578: PPUSH
13579: CALL_OW 483
13583: GO 13559
13585: POP
13586: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13587: LD_ADDR_VAR 0 2
13591: PUSH
13592: LD_VAR 0 2
13596: PPUSH
13597: LD_INT 24
13599: PUSH
13600: LD_INT 250
13602: PUSH
13603: EMPTY
13604: LIST
13605: LIST
13606: PPUSH
13607: CALL_OW 72
13611: ST_TO_ADDR
// for i in tmp do
13612: LD_ADDR_VAR 0 1
13616: PUSH
13617: LD_VAR 0 2
13621: PUSH
13622: FOR_IN
13623: IFFALSE 13663
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13625: LD_VAR 0 1
13629: PPUSH
13630: LD_INT 285
13632: PPUSH
13633: LD_INT 163
13635: PPUSH
13636: CALL_OW 297
13640: PUSH
13641: LD_INT 9
13643: GREATER
13644: IFFALSE 13661
// ComMoveXY ( i , 285 , 163 ) ;
13646: LD_VAR 0 1
13650: PPUSH
13651: LD_INT 285
13653: PPUSH
13654: LD_INT 163
13656: PPUSH
13657: CALL_OW 111
13661: GO 13622
13663: POP
13664: POP
// wait ( 0 0$1 ) ;
13665: LD_INT 35
13667: PPUSH
13668: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13672: LD_VAR 0 2
13676: PPUSH
13677: LD_INT 92
13679: PUSH
13680: LD_INT 285
13682: PUSH
13683: LD_INT 163
13685: PUSH
13686: LD_INT 9
13688: PUSH
13689: EMPTY
13690: LIST
13691: LIST
13692: LIST
13693: LIST
13694: PPUSH
13695: CALL_OW 72
13699: PUSH
13700: LD_VAR 0 2
13704: PUSH
13705: LD_INT 1
13707: MINUS
13708: GREATEREQUAL
13709: IFFALSE 13587
// end ; repeat wait ( 0 0$1 ) ;
13711: LD_INT 35
13713: PPUSH
13714: CALL_OW 67
// for i in tmp do
13718: LD_ADDR_VAR 0 1
13722: PUSH
13723: LD_VAR 0 2
13727: PUSH
13728: FOR_IN
13729: IFFALSE 13851
// if GetLives ( i ) > 251 then
13731: LD_VAR 0 1
13735: PPUSH
13736: CALL_OW 256
13740: PUSH
13741: LD_INT 251
13743: GREATER
13744: IFFALSE 13833
// begin if GetWeapon ( i ) = ru_time_lapser then
13746: LD_VAR 0 1
13750: PPUSH
13751: CALL_OW 264
13755: PUSH
13756: LD_INT 49
13758: EQUAL
13759: IFFALSE 13797
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13761: LD_VAR 0 1
13765: PPUSH
13766: LD_INT 81
13768: PUSH
13769: LD_INT 7
13771: PUSH
13772: EMPTY
13773: LIST
13774: LIST
13775: PPUSH
13776: CALL_OW 69
13780: PPUSH
13781: LD_VAR 0 1
13785: PPUSH
13786: CALL_OW 74
13790: PPUSH
13791: CALL_OW 112
13795: GO 13831
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13797: LD_VAR 0 1
13801: PPUSH
13802: LD_INT 81
13804: PUSH
13805: LD_INT 7
13807: PUSH
13808: EMPTY
13809: LIST
13810: LIST
13811: PPUSH
13812: CALL_OW 69
13816: PPUSH
13817: LD_VAR 0 1
13821: PPUSH
13822: CALL_OW 74
13826: PPUSH
13827: CALL_OW 115
// end else
13831: GO 13849
// tmp := tmp diff i ;
13833: LD_ADDR_VAR 0 2
13837: PUSH
13838: LD_VAR 0 2
13842: PUSH
13843: LD_VAR 0 1
13847: DIFF
13848: ST_TO_ADDR
13849: GO 13728
13851: POP
13852: POP
// until not tmp ;
13853: LD_VAR 0 2
13857: NOT
13858: IFFALSE 13711
// end ; end_of_file
13860: PPOPN 4
13862: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13863: LD_INT 0
13865: PPUSH
13866: PPUSH
13867: PPUSH
13868: PPUSH
// missionStage := 13 ;
13869: LD_ADDR_EXP 15
13873: PUSH
13874: LD_INT 13
13876: ST_TO_ADDR
// uc_side := 2 ;
13877: LD_ADDR_OWVAR 20
13881: PUSH
13882: LD_INT 2
13884: ST_TO_ADDR
// uc_nation := 2 ;
13885: LD_ADDR_OWVAR 21
13889: PUSH
13890: LD_INT 2
13892: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13893: LD_ADDR_EXP 92
13897: PUSH
13898: LD_STRING Omar
13900: PPUSH
13901: CALL_OW 25
13905: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13906: LD_EXP 92
13910: PPUSH
13911: LD_INT 4
13913: PPUSH
13914: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13918: LD_EXP 92
13922: PPUSH
13923: LD_INT 242
13925: PPUSH
13926: LD_INT 75
13928: PPUSH
13929: LD_INT 0
13931: PPUSH
13932: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13936: LD_ADDR_EXP 93
13940: PUSH
13941: LD_STRING Heike
13943: PPUSH
13944: CALL_OW 25
13948: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13949: LD_INT 14
13951: PPUSH
13952: LD_INT 3
13954: PPUSH
13955: LD_INT 1
13957: PPUSH
13958: LD_INT 27
13960: PPUSH
13961: LD_INT 100
13963: PPUSH
13964: CALL 69804 0 5
// veh := CreateVehicle ;
13968: LD_ADDR_VAR 0 3
13972: PUSH
13973: CALL_OW 45
13977: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13978: LD_VAR 0 3
13982: PPUSH
13983: LD_INT 1
13985: PPUSH
13986: CALL_OW 242
// SetDir ( veh , 4 ) ;
13990: LD_VAR 0 3
13994: PPUSH
13995: LD_INT 4
13997: PPUSH
13998: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14002: LD_VAR 0 3
14006: PPUSH
14007: LD_INT 241
14009: PPUSH
14010: LD_INT 72
14012: PPUSH
14013: LD_INT 0
14015: PPUSH
14016: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14020: LD_EXP 93
14024: PPUSH
14025: LD_VAR 0 3
14029: PPUSH
14030: CALL_OW 52
// if KhatamStatus then
14034: LD_EXP 8
14038: IFFALSE 14089
// begin Khatam := NewCharacter ( Khatam ) ;
14040: LD_ADDR_EXP 94
14044: PUSH
14045: LD_STRING Khatam
14047: PPUSH
14048: CALL_OW 25
14052: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14053: LD_EXP 94
14057: PPUSH
14058: LD_INT 245
14060: PPUSH
14061: LD_INT 78
14063: PPUSH
14064: LD_INT 3
14066: PPUSH
14067: LD_INT 0
14069: PPUSH
14070: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14074: LD_EXP 94
14078: PPUSH
14079: LD_INT 4
14081: PPUSH
14082: LD_INT 10
14084: PPUSH
14085: CALL_OW 237
// end ; for i = 1 to Difficulty do
14089: LD_ADDR_VAR 0 2
14093: PUSH
14094: DOUBLE
14095: LD_INT 1
14097: DEC
14098: ST_TO_ADDR
14099: LD_OWVAR 67
14103: PUSH
14104: FOR_TO
14105: IFFALSE 14171
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14107: LD_INT 0
14109: PPUSH
14110: LD_INT 7
14112: PUSH
14113: LD_OWVAR 67
14117: PLUS
14118: PPUSH
14119: CALL_OW 384
// un := CreateHuman ;
14123: LD_ADDR_VAR 0 4
14127: PUSH
14128: CALL_OW 44
14132: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14133: LD_VAR 0 4
14137: PPUSH
14138: LD_INT 28
14140: PUSH
14141: LD_INT 29
14143: PUSH
14144: EMPTY
14145: LIST
14146: LIST
14147: PUSH
14148: LD_VAR 0 2
14152: PUSH
14153: LD_INT 2
14155: MOD
14156: PUSH
14157: LD_INT 1
14159: PLUS
14160: ARRAY
14161: PPUSH
14162: LD_INT 0
14164: PPUSH
14165: CALL_OW 49
// end ;
14169: GO 14104
14171: POP
14172: POP
// for i = 1 to 6 do
14173: LD_ADDR_VAR 0 2
14177: PUSH
14178: DOUBLE
14179: LD_INT 1
14181: DEC
14182: ST_TO_ADDR
14183: LD_INT 6
14185: PUSH
14186: FOR_TO
14187: IFFALSE 14232
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14189: LD_INT 0
14191: PPUSH
14192: LD_INT 7
14194: PUSH
14195: LD_OWVAR 67
14199: PLUS
14200: PPUSH
14201: CALL_OW 381
// un := CreateHuman ;
14205: LD_ADDR_VAR 0 4
14209: PUSH
14210: CALL_OW 44
14214: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14215: LD_VAR 0 4
14219: PPUSH
14220: LD_INT 28
14222: PPUSH
14223: LD_INT 0
14225: PPUSH
14226: CALL_OW 49
// end ;
14230: GO 14186
14232: POP
14233: POP
// for i = 1 to 3 do
14234: LD_ADDR_VAR 0 2
14238: PUSH
14239: DOUBLE
14240: LD_INT 1
14242: DEC
14243: ST_TO_ADDR
14244: LD_INT 3
14246: PUSH
14247: FOR_TO
14248: IFFALSE 14296
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14250: LD_INT 0
14252: PPUSH
14253: LD_INT 8
14255: PPUSH
14256: LD_INT 7
14258: PUSH
14259: LD_OWVAR 67
14263: PLUS
14264: PPUSH
14265: CALL_OW 380
// un := CreateHuman ;
14269: LD_ADDR_VAR 0 4
14273: PUSH
14274: CALL_OW 44
14278: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14279: LD_VAR 0 4
14283: PPUSH
14284: LD_INT 28
14286: PPUSH
14287: LD_INT 0
14289: PPUSH
14290: CALL_OW 49
// end ;
14294: GO 14247
14296: POP
14297: POP
// for i = 1 to 3 do
14298: LD_ADDR_VAR 0 2
14302: PUSH
14303: DOUBLE
14304: LD_INT 1
14306: DEC
14307: ST_TO_ADDR
14308: LD_INT 3
14310: PUSH
14311: FOR_TO
14312: IFFALSE 14402
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14314: LD_INT 14
14316: PPUSH
14317: LD_INT 2
14319: PPUSH
14320: LD_INT 1
14322: PPUSH
14323: LD_INT 28
14325: PPUSH
14326: LD_INT 80
14328: PPUSH
14329: CALL 69804 0 5
// veh := CreateVehicle ;
14333: LD_ADDR_VAR 0 3
14337: PUSH
14338: CALL_OW 45
14342: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14343: LD_VAR 0 3
14347: PPUSH
14348: LD_INT 3
14350: PPUSH
14351: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14355: LD_VAR 0 3
14359: PPUSH
14360: LD_INT 29
14362: PPUSH
14363: LD_INT 0
14365: PPUSH
14366: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14370: LD_INT 0
14372: PPUSH
14373: LD_INT 7
14375: PUSH
14376: LD_OWVAR 67
14380: PLUS
14381: PPUSH
14382: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14386: CALL_OW 44
14390: PPUSH
14391: LD_VAR 0 3
14395: PPUSH
14396: CALL_OW 52
// end ;
14400: GO 14311
14402: POP
14403: POP
// for i = 1 to 5 + Difficulty do
14404: LD_ADDR_VAR 0 2
14408: PUSH
14409: DOUBLE
14410: LD_INT 1
14412: DEC
14413: ST_TO_ADDR
14414: LD_INT 5
14416: PUSH
14417: LD_OWVAR 67
14421: PLUS
14422: PUSH
14423: FOR_TO
14424: IFFALSE 14551
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14426: LD_INT 14
14428: PPUSH
14429: LD_INT 1
14431: PPUSH
14432: LD_INT 3
14434: PPUSH
14435: CALL_OW 12
14439: PPUSH
14440: LD_INT 1
14442: PPUSH
14443: LD_INT 28
14445: PUSH
14446: LD_INT 26
14448: PUSH
14449: LD_INT 27
14451: PUSH
14452: LD_INT 25
14454: PUSH
14455: EMPTY
14456: LIST
14457: LIST
14458: LIST
14459: LIST
14460: PUSH
14461: LD_VAR 0 2
14465: PUSH
14466: LD_INT 4
14468: MOD
14469: PUSH
14470: LD_INT 1
14472: PLUS
14473: ARRAY
14474: PPUSH
14475: LD_INT 80
14477: PPUSH
14478: CALL 69804 0 5
// veh := CreateVehicle ;
14482: LD_ADDR_VAR 0 3
14486: PUSH
14487: CALL_OW 45
14491: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14492: LD_VAR 0 3
14496: PPUSH
14497: LD_INT 4
14499: PPUSH
14500: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14504: LD_VAR 0 3
14508: PPUSH
14509: LD_INT 28
14511: PPUSH
14512: LD_INT 0
14514: PPUSH
14515: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14519: LD_INT 0
14521: PPUSH
14522: LD_INT 7
14524: PUSH
14525: LD_OWVAR 67
14529: PLUS
14530: PPUSH
14531: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14535: CALL_OW 44
14539: PPUSH
14540: LD_VAR 0 3
14544: PPUSH
14545: CALL_OW 52
// end ;
14549: GO 14423
14551: POP
14552: POP
// for i = 1 to 3 do
14553: LD_ADDR_VAR 0 2
14557: PUSH
14558: DOUBLE
14559: LD_INT 1
14561: DEC
14562: ST_TO_ADDR
14563: LD_INT 3
14565: PUSH
14566: FOR_TO
14567: IFFALSE 14627
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14569: LD_INT 14
14571: PPUSH
14572: LD_INT 3
14574: PPUSH
14575: LD_INT 5
14577: PPUSH
14578: LD_INT 29
14580: PPUSH
14581: LD_INT 80
14583: PPUSH
14584: CALL 69804 0 5
// veh := CreateVehicle ;
14588: LD_ADDR_VAR 0 3
14592: PUSH
14593: CALL_OW 45
14597: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14598: LD_VAR 0 3
14602: PPUSH
14603: LD_INT 4
14605: PPUSH
14606: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14610: LD_VAR 0 3
14614: PPUSH
14615: LD_INT 28
14617: PPUSH
14618: LD_INT 0
14620: PPUSH
14621: CALL_OW 49
// end ;
14625: GO 14566
14627: POP
14628: POP
// end ;
14629: LD_VAR 0 1
14633: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14634: LD_INT 22
14636: PUSH
14637: LD_INT 2
14639: PUSH
14640: EMPTY
14641: LIST
14642: LIST
14643: PPUSH
14644: CALL_OW 69
14648: IFFALSE 14948
14650: GO 14652
14652: DISABLE
14653: LD_INT 0
14655: PPUSH
14656: PPUSH
14657: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14658: LD_ADDR_VAR 0 3
14662: PUSH
14663: LD_INT 22
14665: PUSH
14666: LD_INT 2
14668: PUSH
14669: EMPTY
14670: LIST
14671: LIST
14672: PUSH
14673: LD_INT 25
14675: PUSH
14676: LD_INT 4
14678: PUSH
14679: EMPTY
14680: LIST
14681: LIST
14682: PUSH
14683: EMPTY
14684: LIST
14685: LIST
14686: PPUSH
14687: CALL_OW 69
14691: PUSH
14692: LD_EXP 94
14696: DIFF
14697: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14698: LD_ADDR_VAR 0 2
14702: PUSH
14703: LD_INT 22
14705: PUSH
14706: LD_INT 2
14708: PUSH
14709: EMPTY
14710: LIST
14711: LIST
14712: PPUSH
14713: CALL_OW 69
14717: PUSH
14718: LD_EXP 94
14722: PUSH
14723: LD_VAR 0 3
14727: UNION
14728: DIFF
14729: ST_TO_ADDR
// if Khatam then
14730: LD_EXP 94
14734: IFFALSE 14751
// ComMoveXY ( Khatam , 211 , 92 ) ;
14736: LD_EXP 94
14740: PPUSH
14741: LD_INT 211
14743: PPUSH
14744: LD_INT 92
14746: PPUSH
14747: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14751: LD_INT 197
14753: PPUSH
14754: LD_INT 80
14756: PPUSH
14757: LD_INT 2
14759: PPUSH
14760: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14764: LD_INT 213
14766: PPUSH
14767: LD_INT 90
14769: PPUSH
14770: LD_INT 2
14772: PPUSH
14773: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14777: LD_INT 215
14779: PPUSH
14780: LD_INT 129
14782: PPUSH
14783: LD_INT 2
14785: PPUSH
14786: CALL_OW 441
// if sci then
14790: LD_VAR 0 3
14794: IFFALSE 14815
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14796: LD_VAR 0 3
14800: PUSH
14801: LD_INT 1
14803: ARRAY
14804: PPUSH
14805: LD_INT 197
14807: PPUSH
14808: LD_INT 80
14810: PPUSH
14811: CALL_OW 158
// if sci > 1 then
14815: LD_VAR 0 3
14819: PUSH
14820: LD_INT 1
14822: GREATER
14823: IFFALSE 14844
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14825: LD_VAR 0 3
14829: PUSH
14830: LD_INT 2
14832: ARRAY
14833: PPUSH
14834: LD_INT 213
14836: PPUSH
14837: LD_INT 90
14839: PPUSH
14840: CALL_OW 158
// if sci > 2 then
14844: LD_VAR 0 3
14848: PUSH
14849: LD_INT 2
14851: GREATER
14852: IFFALSE 14873
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14854: LD_VAR 0 3
14858: PUSH
14859: LD_INT 3
14861: ARRAY
14862: PPUSH
14863: LD_INT 215
14865: PPUSH
14866: LD_INT 129
14868: PPUSH
14869: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14873: LD_INT 35
14875: PPUSH
14876: CALL_OW 67
// for i in tmp do
14880: LD_ADDR_VAR 0 1
14884: PUSH
14885: LD_VAR 0 2
14889: PUSH
14890: FOR_IN
14891: IFFALSE 14929
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14893: LD_VAR 0 1
14897: PPUSH
14898: LD_INT 81
14900: PUSH
14901: LD_INT 2
14903: PUSH
14904: EMPTY
14905: LIST
14906: LIST
14907: PPUSH
14908: CALL_OW 69
14912: PPUSH
14913: LD_VAR 0 1
14917: PPUSH
14918: CALL_OW 74
14922: PPUSH
14923: CALL_OW 115
14927: GO 14890
14929: POP
14930: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14931: LD_INT 22
14933: PUSH
14934: LD_INT 2
14936: PUSH
14937: EMPTY
14938: LIST
14939: LIST
14940: PPUSH
14941: CALL_OW 69
14945: NOT
14946: IFFALSE 14873
// end ; end_of_file
14948: PPOPN 3
14950: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14951: LD_INT 0
14953: PPUSH
14954: PPUSH
14955: PPUSH
14956: PPUSH
14957: PPUSH
14958: PPUSH
14959: PPUSH
14960: PPUSH
14961: PPUSH
// Video ( true ) ;
14962: LD_INT 1
14964: PPUSH
14965: CALL 100822 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14969: LD_ADDR_VAR 0 5
14973: PUSH
14974: LD_INT 7
14976: PPUSH
14977: LD_INT 0
14979: PPUSH
14980: CALL_OW 517
14984: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14985: LD_ADDR_VAR 0 2
14989: PUSH
14990: DOUBLE
14991: LD_INT 1
14993: DEC
14994: ST_TO_ADDR
14995: LD_VAR 0 5
14999: PUSH
15000: LD_INT 1
15002: ARRAY
15003: PUSH
15004: FOR_TO
15005: IFFALSE 15050
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15007: LD_VAR 0 5
15011: PUSH
15012: LD_INT 1
15014: ARRAY
15015: PUSH
15016: LD_VAR 0 2
15020: ARRAY
15021: PPUSH
15022: LD_VAR 0 5
15026: PUSH
15027: LD_INT 2
15029: ARRAY
15030: PUSH
15031: LD_VAR 0 2
15035: ARRAY
15036: PPUSH
15037: LD_INT 1
15039: PPUSH
15040: LD_INT 15
15042: NEG
15043: PPUSH
15044: CALL 100736 0 4
15048: GO 15004
15050: POP
15051: POP
// CenterNowOnUnits ( Powell ) ;
15052: LD_EXP 58
15056: PPUSH
15057: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15061: LD_ADDR_VAR 0 5
15065: PUSH
15066: LD_EXP 56
15070: PUSH
15071: EMPTY
15072: LIST
15073: ST_TO_ADDR
// if GirlNewVeh then
15074: LD_EXP 57
15078: IFFALSE 15096
// tmp := tmp ^ GirlNewVeh ;
15080: LD_ADDR_VAR 0 5
15084: PUSH
15085: LD_VAR 0 5
15089: PUSH
15090: LD_EXP 57
15094: ADD
15095: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15096: LD_VAR 0 5
15100: PPUSH
15101: LD_INT 60
15103: PPUSH
15104: LD_INT 109
15106: PPUSH
15107: CALL_OW 111
// if KappaStatus then
15111: LD_EXP 2
15115: IFFALSE 15167
// begin Say ( JMM , D1nT-JMM-1 ) ;
15117: LD_EXP 39
15121: PPUSH
15122: LD_STRING D1nT-JMM-1
15124: PPUSH
15125: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15129: LD_EXP 58
15133: PPUSH
15134: LD_STRING D1T-Pow-1
15136: PPUSH
15137: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15141: LD_EXP 39
15145: PPUSH
15146: LD_STRING D1T-JMM-2
15148: PPUSH
15149: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15153: LD_EXP 58
15157: PPUSH
15158: LD_STRING D1T-Pow-2
15160: PPUSH
15161: CALL_OW 88
// end else
15165: GO 15373
// if JMMGirlStatus then
15167: LD_EXP 6
15171: IFFALSE 15316
// begin Say ( JMM , D1T-JMM-1 ) ;
15173: LD_EXP 39
15177: PPUSH
15178: LD_STRING D1T-JMM-1
15180: PPUSH
15181: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15185: LD_EXP 58
15189: PPUSH
15190: LD_STRING D1T-Pow-1
15192: PPUSH
15193: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15197: LD_EXP 39
15201: PPUSH
15202: LD_STRING D1T-JMM-3
15204: PPUSH
15205: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15209: LD_EXP 58
15213: PPUSH
15214: LD_STRING D1T-Pow-3
15216: PPUSH
15217: CALL_OW 88
// if JMMGirl then
15221: LD_EXP 7
15225: IFFALSE 15314
// begin case JMMGirl of 1 :
15227: LD_EXP 7
15231: PUSH
15232: LD_INT 1
15234: DOUBLE
15235: EQUAL
15236: IFTRUE 15240
15238: GO 15255
15240: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15241: LD_EXP 40
15245: PPUSH
15246: LD_STRING D1T-Joan-3
15248: PPUSH
15249: CALL_OW 88
15253: GO 15302
15255: LD_INT 2
15257: DOUBLE
15258: EQUAL
15259: IFTRUE 15263
15261: GO 15278
15263: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15264: LD_EXP 42
15268: PPUSH
15269: LD_STRING D1T-Lisa-3
15271: PPUSH
15272: CALL_OW 88
15276: GO 15302
15278: LD_INT 3
15280: DOUBLE
15281: EQUAL
15282: IFTRUE 15286
15284: GO 15301
15286: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15287: LD_EXP 54
15291: PPUSH
15292: LD_STRING D1T-Con-3
15294: PPUSH
15295: CALL_OW 88
15299: GO 15302
15301: POP
// Say ( Powell , D1T-Pow-4 ) ;
15302: LD_EXP 58
15306: PPUSH
15307: LD_STRING D1T-Pow-4
15309: PPUSH
15310: CALL_OW 88
// end ; end else
15314: GO 15373
// if not FastEnd then
15316: LD_EXP 11
15320: NOT
15321: IFFALSE 15349
// begin Say ( JMM , D1T-JMM-4 ) ;
15323: LD_EXP 39
15327: PPUSH
15328: LD_STRING D1T-JMM-4
15330: PPUSH
15331: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15335: LD_EXP 58
15339: PPUSH
15340: LD_STRING D1T-Pow-5
15342: PPUSH
15343: CALL_OW 88
// end else
15347: GO 15373
// begin Say ( JMM , D1nT-JMM-1 ) ;
15349: LD_EXP 39
15353: PPUSH
15354: LD_STRING D1nT-JMM-1
15356: PPUSH
15357: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15361: LD_EXP 58
15365: PPUSH
15366: LD_STRING D1nT-Pow-1
15368: PPUSH
15369: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15373: LD_INT 35
15375: PPUSH
15376: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15380: LD_EXP 56
15384: PPUSH
15385: CALL_OW 314
15389: NOT
15390: IFFALSE 15373
// ComExitVehicle ( JMM ) ;
15392: LD_EXP 39
15396: PPUSH
15397: CALL_OW 121
// wait ( 3 ) ;
15401: LD_INT 3
15403: PPUSH
15404: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15408: LD_EXP 39
15412: PPUSH
15413: LD_INT 60
15415: PPUSH
15416: LD_INT 94
15418: PPUSH
15419: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15423: LD_EXP 39
15427: PPUSH
15428: LD_EXP 58
15432: PPUSH
15433: CALL_OW 179
// if Joan then
15437: LD_EXP 40
15441: IFFALSE 15495
// begin ComExitVehicle ( Joan ) ;
15443: LD_EXP 40
15447: PPUSH
15448: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15452: LD_EXP 40
15456: PPUSH
15457: LD_INT 35
15459: PPUSH
15460: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15464: LD_EXP 40
15468: PPUSH
15469: LD_INT 65
15471: PPUSH
15472: LD_INT 104
15474: PPUSH
15475: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15479: LD_EXP 40
15483: PPUSH
15484: LD_EXP 39
15488: PPUSH
15489: CALL_OW 179
// end else
15493: GO 15629
// if Lisa and JMMGirl = 2 then
15495: LD_EXP 42
15499: PUSH
15500: LD_EXP 7
15504: PUSH
15505: LD_INT 2
15507: EQUAL
15508: AND
15509: IFFALSE 15563
// begin ComExitVehicle ( Lisa ) ;
15511: LD_EXP 42
15515: PPUSH
15516: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15520: LD_EXP 42
15524: PPUSH
15525: LD_INT 35
15527: PPUSH
15528: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15532: LD_EXP 42
15536: PPUSH
15537: LD_INT 65
15539: PPUSH
15540: LD_INT 104
15542: PPUSH
15543: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15547: LD_EXP 42
15551: PPUSH
15552: LD_EXP 39
15556: PPUSH
15557: CALL_OW 179
// end else
15561: GO 15629
// if Connie and JMMGirl = 3 then
15563: LD_EXP 54
15567: PUSH
15568: LD_EXP 7
15572: PUSH
15573: LD_INT 3
15575: EQUAL
15576: AND
15577: IFFALSE 15629
// begin ComExitVehicle ( Connie ) ;
15579: LD_EXP 54
15583: PPUSH
15584: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15588: LD_EXP 54
15592: PPUSH
15593: LD_INT 35
15595: PPUSH
15596: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15600: LD_EXP 54
15604: PPUSH
15605: LD_INT 65
15607: PPUSH
15608: LD_INT 104
15610: PPUSH
15611: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15615: LD_EXP 54
15619: PPUSH
15620: LD_EXP 39
15624: PPUSH
15625: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15629: LD_INT 35
15631: PPUSH
15632: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15636: LD_EXP 39
15640: PPUSH
15641: LD_EXP 58
15645: PPUSH
15646: CALL_OW 296
15650: PUSH
15651: LD_INT 6
15653: LESS
15654: IFFALSE 15629
// wait ( 0 0$0.5 ) ;
15656: LD_INT 18
15658: PPUSH
15659: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15663: LD_EXP 39
15667: PPUSH
15668: LD_STRING D1-JMM-1
15670: PPUSH
15671: CALL_OW 88
// async ;
15675: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15676: LD_EXP 58
15680: PPUSH
15681: LD_STRING D1-Pow-1
15683: PPUSH
15684: CALL_OW 88
// if not dialogue_skipped then
15688: LD_OWVAR 59
15692: NOT
15693: IFFALSE 15702
// wait ( 0 0$2 ) ;
15695: LD_INT 70
15697: PPUSH
15698: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15702: LD_INT 170
15704: PPUSH
15705: LD_INT 99
15707: PPUSH
15708: LD_INT 1
15710: PPUSH
15711: LD_INT 6
15713: NEG
15714: PPUSH
15715: CALL 100736 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15719: LD_INT 174
15721: PPUSH
15722: LD_INT 115
15724: PPUSH
15725: LD_INT 1
15727: PPUSH
15728: LD_INT 6
15730: NEG
15731: PPUSH
15732: CALL 100736 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15736: LD_INT 169
15738: PPUSH
15739: LD_INT 71
15741: PPUSH
15742: LD_INT 1
15744: PPUSH
15745: LD_INT 6
15747: NEG
15748: PPUSH
15749: CALL 100736 0 4
// if not dialogue_skipped then
15753: LD_OWVAR 59
15757: NOT
15758: IFFALSE 15777
// begin CenterOnXY ( 170 , 99 ) ;
15760: LD_INT 170
15762: PPUSH
15763: LD_INT 99
15765: PPUSH
15766: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15770: LD_INT 80
15772: PPUSH
15773: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15777: LD_INT 75
15779: PPUSH
15780: LD_INT 53
15782: PPUSH
15783: LD_INT 1
15785: PPUSH
15786: LD_INT 9
15788: NEG
15789: PPUSH
15790: CALL 100736 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15794: LD_INT 54
15796: PPUSH
15797: LD_INT 42
15799: PPUSH
15800: LD_INT 1
15802: PPUSH
15803: LD_INT 9
15805: NEG
15806: PPUSH
15807: CALL 100736 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15811: LD_INT 62
15813: PPUSH
15814: LD_INT 51
15816: PPUSH
15817: LD_INT 1
15819: PPUSH
15820: LD_INT 9
15822: NEG
15823: PPUSH
15824: CALL 100736 0 4
// if not dialogue_skipped then
15828: LD_OWVAR 59
15832: NOT
15833: IFFALSE 15852
// begin CenterOnXY ( 75 , 53 ) ;
15835: LD_INT 75
15837: PPUSH
15838: LD_INT 53
15840: PPUSH
15841: CALL_OW 84
// wait ( 0 0$4 ) ;
15845: LD_INT 140
15847: PPUSH
15848: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15852: LD_EXP 58
15856: PPUSH
15857: CALL_OW 87
// if not dialogue_skipped then
15861: LD_OWVAR 59
15865: NOT
15866: IFFALSE 15875
// wait ( 0 0$2 ) ;
15868: LD_INT 70
15870: PPUSH
15871: CALL_OW 67
// sync ;
15875: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15876: LD_EXP 39
15880: PPUSH
15881: LD_STRING D1-JMM-2
15883: PPUSH
15884: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15888: LD_EXP 58
15892: PPUSH
15893: LD_STRING D1-Pow-2
15895: PPUSH
15896: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15900: LD_EXP 39
15904: PPUSH
15905: LD_STRING D1-JMM-3
15907: PPUSH
15908: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15912: LD_EXP 58
15916: PPUSH
15917: LD_STRING D1-Pow-3
15919: PPUSH
15920: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15924: LD_EXP 39
15928: PPUSH
15929: LD_STRING D1-JMM-4
15931: PPUSH
15932: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15936: LD_EXP 58
15940: PPUSH
15941: LD_STRING D1-Pow-4
15943: PPUSH
15944: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15948: LD_EXP 39
15952: PPUSH
15953: LD_STRING D1-JMM-5
15955: PPUSH
15956: CALL_OW 88
// async ;
15960: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15961: LD_EXP 58
15965: PPUSH
15966: LD_STRING D1-Pow-5
15968: PPUSH
15969: CALL_OW 88
// if not dialogue_skipped then
15973: LD_OWVAR 59
15977: NOT
15978: IFFALSE 15987
// wait ( 0 0$3.6 ) ;
15980: LD_INT 126
15982: PPUSH
15983: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15987: LD_INT 134
15989: PPUSH
15990: LD_INT 210
15992: PPUSH
15993: LD_INT 1
15995: PPUSH
15996: LD_INT 11
15998: NEG
15999: PPUSH
16000: CALL 100736 0 4
// if not dialogue_skipped then
16004: LD_OWVAR 59
16008: NOT
16009: IFFALSE 16028
// begin CenterOnXY ( 134 , 210 ) ;
16011: LD_INT 134
16013: PPUSH
16014: LD_INT 210
16016: PPUSH
16017: CALL_OW 84
// wait ( 0 0$2 ) ;
16021: LD_INT 70
16023: PPUSH
16024: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16028: LD_INT 101
16030: PPUSH
16031: LD_INT 159
16033: PPUSH
16034: LD_INT 1
16036: PPUSH
16037: LD_INT 10
16039: NEG
16040: PPUSH
16041: CALL 100736 0 4
// if not dialogue_skipped then
16045: LD_OWVAR 59
16049: NOT
16050: IFFALSE 16069
// begin CenterOnXY ( 101 , 159 ) ;
16052: LD_INT 101
16054: PPUSH
16055: LD_INT 159
16057: PPUSH
16058: CALL_OW 84
// wait ( 0 0$2 ) ;
16062: LD_INT 70
16064: PPUSH
16065: CALL_OW 67
// end ; sync ;
16069: SYNC
// CenterNowOnUnits ( Powell ) ;
16070: LD_EXP 58
16074: PPUSH
16075: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16079: LD_ADDR_VAR 0 6
16083: PUSH
16084: LD_INT 1
16086: PUSH
16087: LD_INT 2
16089: PUSH
16090: LD_INT 3
16092: PUSH
16093: LD_INT 4
16095: PUSH
16096: LD_INT 5
16098: PUSH
16099: LD_INT 6
16101: PUSH
16102: EMPTY
16103: LIST
16104: LIST
16105: LIST
16106: LIST
16107: LIST
16108: LIST
16109: ST_TO_ADDR
// if not dialogue_skipped then
16110: LD_OWVAR 59
16114: NOT
16115: IFFALSE 16284
// begin game_speed := 4 ;
16117: LD_ADDR_OWVAR 65
16121: PUSH
16122: LD_INT 4
16124: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16125: LD_INT 210
16127: PPUSH
16128: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16132: LD_ADDR_VAR 0 7
16136: PUSH
16137: LD_STRING Q1
16139: PPUSH
16140: LD_VAR 0 6
16144: PPUSH
16145: CALL_OW 98
16149: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16150: LD_ADDR_VAR 0 7
16154: PUSH
16155: LD_STRING Q1
16157: PPUSH
16158: LD_VAR 0 6
16162: PPUSH
16163: CALL_OW 98
16167: ST_TO_ADDR
// options = options diff dec ;
16168: LD_ADDR_VAR 0 6
16172: PUSH
16173: LD_VAR 0 6
16177: PUSH
16178: LD_VAR 0 7
16182: DIFF
16183: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16184: LD_VAR 0 7
16188: PPUSH
16189: LD_VAR 0 6
16193: PPUSH
16194: CALL 17756 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16198: LD_VAR 0 7
16202: PUSH
16203: LD_INT 5
16205: PUSH
16206: LD_INT 6
16208: PUSH
16209: EMPTY
16210: LIST
16211: LIST
16212: IN
16213: PUSH
16214: LD_VAR 0 6
16218: PUSH
16219: LD_INT 2
16221: EQUAL
16222: OR
16223: IFFALSE 16150
// if not ( dec in [ 5 , 6 ] ) then
16225: LD_VAR 0 7
16229: PUSH
16230: LD_INT 5
16232: PUSH
16233: LD_INT 6
16235: PUSH
16236: EMPTY
16237: LIST
16238: LIST
16239: IN
16240: NOT
16241: IFFALSE 16284
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16243: LD_ADDR_VAR 0 7
16247: PUSH
16248: LD_STRING Q1a
16250: PPUSH
16251: LD_INT 1
16253: PUSH
16254: LD_INT 2
16256: PUSH
16257: EMPTY
16258: LIST
16259: LIST
16260: PPUSH
16261: CALL_OW 98
16265: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16266: LD_VAR 0 7
16270: PUSH
16271: LD_INT 4
16273: PLUS
16274: PPUSH
16275: LD_VAR 0 6
16279: PPUSH
16280: CALL 17756 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16284: LD_INT 81
16286: PPUSH
16287: LD_INT 127
16289: PPUSH
16290: CALL_OW 84
// amount := 5 ;
16294: LD_ADDR_VAR 0 8
16298: PUSH
16299: LD_INT 5
16301: ST_TO_ADDR
// macmilan_squad := [ ] ;
16302: LD_ADDR_VAR 0 9
16306: PUSH
16307: EMPTY
16308: ST_TO_ADDR
// if vip < amount then
16309: LD_EXP 59
16313: PUSH
16314: LD_VAR 0 8
16318: LESS
16319: IFFALSE 16363
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16321: LD_ADDR_VAR 0 5
16325: PUSH
16326: LD_EXP 59
16330: PUSH
16331: LD_INT 22
16333: PUSH
16334: LD_INT 4
16336: PUSH
16337: EMPTY
16338: LIST
16339: LIST
16340: PUSH
16341: LD_INT 21
16343: PUSH
16344: LD_INT 1
16346: PUSH
16347: EMPTY
16348: LIST
16349: LIST
16350: PUSH
16351: EMPTY
16352: LIST
16353: LIST
16354: PPUSH
16355: CALL_OW 69
16359: UNION
16360: ST_TO_ADDR
16361: GO 16373
// tmp := vip ;
16363: LD_ADDR_VAR 0 5
16367: PUSH
16368: LD_EXP 59
16372: ST_TO_ADDR
// tmp := tmp diff Powell ;
16373: LD_ADDR_VAR 0 5
16377: PUSH
16378: LD_VAR 0 5
16382: PUSH
16383: LD_EXP 58
16387: DIFF
16388: ST_TO_ADDR
// if tmp < amount then
16389: LD_VAR 0 5
16393: PUSH
16394: LD_VAR 0 8
16398: LESS
16399: IFFALSE 16411
// amount := tmp ;
16401: LD_ADDR_VAR 0 8
16405: PUSH
16406: LD_VAR 0 5
16410: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16411: LD_VAR 0 5
16415: PUSH
16416: LD_INT 1
16418: ARRAY
16419: PPUSH
16420: CALL_OW 257
16424: PUSH
16425: LD_INT 2
16427: NONEQUAL
16428: IFFALSE 16490
// begin if IsInUnit ( tmp [ 1 ] ) then
16430: LD_VAR 0 5
16434: PUSH
16435: LD_INT 1
16437: ARRAY
16438: PPUSH
16439: CALL_OW 310
16443: IFFALSE 16458
// ComExitBuilding ( tmp [ 1 ] ) ;
16445: LD_VAR 0 5
16449: PUSH
16450: LD_INT 1
16452: ARRAY
16453: PPUSH
16454: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16458: LD_VAR 0 5
16462: PUSH
16463: LD_INT 1
16465: ARRAY
16466: PPUSH
16467: LD_INT 387
16469: PPUSH
16470: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16474: LD_VAR 0 5
16478: PUSH
16479: LD_INT 1
16481: ARRAY
16482: PPUSH
16483: LD_INT 2
16485: PPUSH
16486: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16490: LD_EXP 39
16494: PPUSH
16495: LD_INT 82
16497: PPUSH
16498: LD_INT 129
16500: PPUSH
16501: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16505: LD_EXP 39
16509: PPUSH
16510: LD_EXP 58
16514: PPUSH
16515: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16519: LD_INT 22
16521: PUSH
16522: LD_INT 1
16524: PUSH
16525: EMPTY
16526: LIST
16527: LIST
16528: PPUSH
16529: CALL_OW 69
16533: PUSH
16534: LD_EXP 39
16538: DIFF
16539: PPUSH
16540: LD_INT 84
16542: PPUSH
16543: LD_INT 128
16545: PPUSH
16546: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16550: LD_INT 22
16552: PUSH
16553: LD_INT 1
16555: PUSH
16556: EMPTY
16557: LIST
16558: LIST
16559: PPUSH
16560: CALL_OW 69
16564: PUSH
16565: LD_EXP 39
16569: DIFF
16570: PPUSH
16571: LD_EXP 39
16575: PPUSH
16576: CALL_OW 179
// for i = 1 to amount do
16580: LD_ADDR_VAR 0 2
16584: PUSH
16585: DOUBLE
16586: LD_INT 1
16588: DEC
16589: ST_TO_ADDR
16590: LD_VAR 0 8
16594: PUSH
16595: FOR_TO
16596: IFFALSE 16764
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16598: LD_ADDR_VAR 0 9
16602: PUSH
16603: LD_VAR 0 9
16607: PUSH
16608: LD_VAR 0 5
16612: PUSH
16613: LD_VAR 0 2
16617: ARRAY
16618: ADD
16619: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16620: LD_VAR 0 5
16624: PUSH
16625: LD_VAR 0 2
16629: ARRAY
16630: PPUSH
16631: CALL_OW 310
16635: IFFALSE 16652
// AddComExitBuilding ( tmp [ i ] ) ;
16637: LD_VAR 0 5
16641: PUSH
16642: LD_VAR 0 2
16646: ARRAY
16647: PPUSH
16648: CALL_OW 182
// if i = 2 and JMMNewVeh then
16652: LD_VAR 0 2
16656: PUSH
16657: LD_INT 2
16659: EQUAL
16660: PUSH
16661: LD_EXP 56
16665: AND
16666: IFFALSE 16724
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16668: LD_VAR 0 5
16672: PUSH
16673: LD_VAR 0 2
16677: ARRAY
16678: PPUSH
16679: LD_EXP 56
16683: PPUSH
16684: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16688: LD_VAR 0 5
16692: PUSH
16693: LD_VAR 0 2
16697: ARRAY
16698: PPUSH
16699: LD_INT 86
16701: PPUSH
16702: LD_INT 133
16704: PPUSH
16705: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16709: LD_VAR 0 5
16713: PUSH
16714: LD_VAR 0 2
16718: ARRAY
16719: PPUSH
16720: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16724: LD_VAR 0 5
16728: PUSH
16729: LD_VAR 0 2
16733: ARRAY
16734: PPUSH
16735: LD_INT 8
16737: PPUSH
16738: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16742: LD_VAR 0 5
16746: PUSH
16747: LD_VAR 0 2
16751: ARRAY
16752: PPUSH
16753: LD_EXP 39
16757: PPUSH
16758: CALL_OW 179
// end ;
16762: GO 16595
16764: POP
16765: POP
// if GirlNewVeh then
16766: LD_EXP 57
16770: IFFALSE 16784
// SetSide ( GirlNewVeh , 4 ) ;
16772: LD_EXP 57
16776: PPUSH
16777: LD_INT 4
16779: PPUSH
16780: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16784: LD_INT 35
16786: PPUSH
16787: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16791: LD_VAR 0 9
16795: PPUSH
16796: LD_INT 95
16798: PUSH
16799: LD_INT 9
16801: PUSH
16802: EMPTY
16803: LIST
16804: LIST
16805: PPUSH
16806: CALL_OW 72
16810: PUSH
16811: LD_INT 0
16813: EQUAL
16814: PUSH
16815: LD_EXP 39
16819: PPUSH
16820: LD_INT 9
16822: PPUSH
16823: CALL_OW 308
16827: NOT
16828: AND
16829: IFFALSE 16784
// wait ( 0 0$2 ) ;
16831: LD_INT 70
16833: PPUSH
16834: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16838: LD_VAR 0 9
16842: PPUSH
16843: LD_INT 1
16845: PPUSH
16846: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16850: LD_INT 21
16852: PUSH
16853: LD_INT 2
16855: PUSH
16856: EMPTY
16857: LIST
16858: LIST
16859: PUSH
16860: LD_INT 92
16862: PUSH
16863: LD_INT 83
16865: PUSH
16866: LD_INT 130
16868: PUSH
16869: LD_INT 10
16871: PUSH
16872: EMPTY
16873: LIST
16874: LIST
16875: LIST
16876: LIST
16877: PUSH
16878: EMPTY
16879: LIST
16880: LIST
16881: PPUSH
16882: CALL_OW 69
16886: PPUSH
16887: LD_INT 1
16889: PPUSH
16890: CALL_OW 235
// Video ( false ) ;
16894: LD_INT 0
16896: PPUSH
16897: CALL 100822 0 1
// ChangeMissionObjectives ( M1 ) ;
16901: LD_STRING M1
16903: PPUSH
16904: CALL_OW 337
// SaveForQuickRestart ;
16908: CALL_OW 22
// missionStart := true ;
16912: LD_ADDR_EXP 13
16916: PUSH
16917: LD_INT 1
16919: ST_TO_ADDR
// missionStage := 2 ;
16920: LD_ADDR_EXP 15
16924: PUSH
16925: LD_INT 2
16927: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16928: LD_INT 105
16930: PPUSH
16931: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16935: LD_ADDR_VAR 0 5
16939: PUSH
16940: LD_INT 22
16942: PUSH
16943: LD_INT 4
16945: PUSH
16946: EMPTY
16947: LIST
16948: LIST
16949: PUSH
16950: LD_INT 21
16952: PUSH
16953: LD_INT 1
16955: PUSH
16956: EMPTY
16957: LIST
16958: LIST
16959: PUSH
16960: EMPTY
16961: LIST
16962: LIST
16963: PPUSH
16964: CALL_OW 69
16968: PUSH
16969: LD_EXP 58
16973: DIFF
16974: ST_TO_ADDR
// if not tmp then
16975: LD_VAR 0 5
16979: NOT
16980: IFFALSE 16995
// tmp := [ Powell ] ;
16982: LD_ADDR_VAR 0 5
16986: PUSH
16987: LD_EXP 58
16991: PUSH
16992: EMPTY
16993: LIST
16994: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16995: LD_ADDR_EXP 110
16999: PUSH
17000: LD_EXP 110
17004: PPUSH
17005: LD_INT 4
17007: PPUSH
17008: LD_INT 22
17010: PUSH
17011: LD_INT 4
17013: PUSH
17014: EMPTY
17015: LIST
17016: LIST
17017: PUSH
17018: LD_INT 23
17020: PUSH
17021: LD_INT 1
17023: PUSH
17024: EMPTY
17025: LIST
17026: LIST
17027: PUSH
17028: LD_INT 3
17030: PUSH
17031: LD_INT 21
17033: PUSH
17034: LD_INT 2
17036: PUSH
17037: EMPTY
17038: LIST
17039: LIST
17040: PUSH
17041: EMPTY
17042: LIST
17043: LIST
17044: PUSH
17045: EMPTY
17046: LIST
17047: LIST
17048: LIST
17049: PPUSH
17050: CALL_OW 69
17054: PUSH
17055: LD_EXP 58
17059: DIFF
17060: PPUSH
17061: CALL_OW 1
17065: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17066: LD_ADDR_VAR 0 4
17070: PUSH
17071: LD_INT 22
17073: PUSH
17074: LD_INT 4
17076: PUSH
17077: EMPTY
17078: LIST
17079: LIST
17080: PUSH
17081: LD_INT 34
17083: PUSH
17084: LD_INT 12
17086: PUSH
17087: EMPTY
17088: LIST
17089: LIST
17090: PUSH
17091: EMPTY
17092: LIST
17093: LIST
17094: PPUSH
17095: CALL_OW 69
17099: PUSH
17100: LD_INT 1
17102: ARRAY
17103: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17104: LD_VAR 0 5
17108: PUSH
17109: LD_INT 1
17111: ARRAY
17112: PPUSH
17113: CALL_OW 310
17117: IFFALSE 17132
// ComExitBuilding ( tmp [ 1 ] ) ;
17119: LD_VAR 0 5
17123: PUSH
17124: LD_INT 1
17126: ARRAY
17127: PPUSH
17128: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17132: LD_VAR 0 5
17136: PUSH
17137: LD_INT 1
17139: ARRAY
17140: PPUSH
17141: LD_VAR 0 4
17145: PPUSH
17146: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17150: LD_VAR 0 5
17154: PUSH
17155: LD_INT 1
17157: ARRAY
17158: PPUSH
17159: LD_INT 80
17161: PPUSH
17162: LD_INT 136
17164: PPUSH
17165: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17169: LD_VAR 0 5
17173: PUSH
17174: LD_INT 1
17176: ARRAY
17177: PPUSH
17178: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17182: LD_VAR 0 5
17186: PUSH
17187: LD_INT 1
17189: ARRAY
17190: PPUSH
17191: LD_INT 59
17193: PPUSH
17194: LD_INT 112
17196: PPUSH
17197: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17201: LD_VAR 0 5
17205: PUSH
17206: LD_INT 1
17208: ARRAY
17209: PPUSH
17210: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17214: LD_EXP 40
17218: PUSH
17219: LD_EXP 40
17223: PPUSH
17224: CALL_OW 255
17228: PUSH
17229: LD_INT 1
17231: EQUAL
17232: AND
17233: IFFALSE 17259
// begin Say ( Joan , D3W-Joan-1 ) ;
17235: LD_EXP 40
17239: PPUSH
17240: LD_STRING D3W-Joan-1
17242: PPUSH
17243: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17247: LD_EXP 39
17251: PPUSH
17252: LD_STRING D3W-JMM-1
17254: PPUSH
17255: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17259: LD_EXP 42
17263: PUSH
17264: LD_EXP 42
17268: PPUSH
17269: CALL_OW 255
17273: PUSH
17274: LD_INT 1
17276: EQUAL
17277: AND
17278: PUSH
17279: LD_EXP 42
17283: PUSH
17284: LD_EXP 59
17288: IN
17289: NOT
17290: AND
17291: IFFALSE 17317
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17293: LD_EXP 42
17297: PPUSH
17298: LD_STRING D3W-Lisa-1
17300: PPUSH
17301: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17305: LD_EXP 39
17309: PPUSH
17310: LD_STRING D3W-JMM-1
17312: PPUSH
17313: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17317: LD_EXP 54
17321: PUSH
17322: LD_EXP 54
17326: PPUSH
17327: CALL_OW 255
17331: PUSH
17332: LD_INT 1
17334: EQUAL
17335: AND
17336: IFFALSE 17362
// begin Say ( Connie , D3W-Con-1 ) ;
17338: LD_EXP 54
17342: PPUSH
17343: LD_STRING D3W-Con-1
17345: PPUSH
17346: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17350: LD_EXP 39
17354: PPUSH
17355: LD_STRING D3W-JMM-1
17357: PPUSH
17358: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17362: LD_EXP 42
17366: PUSH
17367: LD_EXP 59
17371: IN
17372: PUSH
17373: LD_EXP 42
17377: PPUSH
17378: CALL_OW 255
17382: PUSH
17383: LD_INT 1
17385: EQUAL
17386: AND
17387: IFFALSE 17403
// Say ( Lisa , D3nW-Lisa-1 ) else
17389: LD_EXP 42
17393: PPUSH
17394: LD_STRING D3nW-Lisa-1
17396: PPUSH
17397: CALL_OW 88
17401: GO 17647
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17403: LD_EXP 45
17407: PUSH
17408: LD_EXP 59
17412: IN
17413: PUSH
17414: LD_EXP 45
17418: PPUSH
17419: CALL_OW 255
17423: PUSH
17424: LD_INT 1
17426: EQUAL
17427: AND
17428: IFFALSE 17444
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17430: LD_EXP 45
17434: PPUSH
17435: LD_STRING D3nW-Cyrus-1
17437: PPUSH
17438: CALL_OW 88
17442: GO 17647
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17444: LD_EXP 44
17448: PUSH
17449: LD_EXP 59
17453: IN
17454: PUSH
17455: LD_EXP 44
17459: PPUSH
17460: CALL_OW 255
17464: PUSH
17465: LD_INT 1
17467: EQUAL
17468: AND
17469: IFFALSE 17485
// Say ( Bobby , D3nW-Bobby-1 ) else
17471: LD_EXP 44
17475: PPUSH
17476: LD_STRING D3nW-Bobby-1
17478: PPUSH
17479: CALL_OW 88
17483: GO 17647
// if Gary in vip and GetSide ( Gary ) = 1 then
17485: LD_EXP 51
17489: PUSH
17490: LD_EXP 59
17494: IN
17495: PUSH
17496: LD_EXP 51
17500: PPUSH
17501: CALL_OW 255
17505: PUSH
17506: LD_INT 1
17508: EQUAL
17509: AND
17510: IFFALSE 17526
// Say ( Gary , D3nW-Gary-1 ) else
17512: LD_EXP 51
17516: PPUSH
17517: LD_STRING D3nW-Gary-1
17519: PPUSH
17520: CALL_OW 88
17524: GO 17647
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17526: LD_EXP 43
17530: PUSH
17531: LD_EXP 59
17535: IN
17536: PUSH
17537: LD_EXP 43
17541: PPUSH
17542: CALL_OW 255
17546: PUSH
17547: LD_INT 1
17549: EQUAL
17550: AND
17551: IFFALSE 17567
// Say ( Donaldson , D3nW-Don-1 ) else
17553: LD_EXP 43
17557: PPUSH
17558: LD_STRING D3nW-Don-1
17560: PPUSH
17561: CALL_OW 88
17565: GO 17647
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17567: LD_EXP 50
17571: PUSH
17572: LD_EXP 59
17576: IN
17577: PUSH
17578: LD_EXP 50
17582: PPUSH
17583: CALL_OW 255
17587: PUSH
17588: LD_INT 1
17590: EQUAL
17591: AND
17592: IFFALSE 17608
// Say ( Cornel , D3nW-Corn-1 ) else
17594: LD_EXP 50
17598: PPUSH
17599: LD_STRING D3nW-Corn-1
17601: PPUSH
17602: CALL_OW 88
17606: GO 17647
// if Frank in vip and GetSide ( Frank ) = 1 then
17608: LD_EXP 52
17612: PUSH
17613: LD_EXP 59
17617: IN
17618: PUSH
17619: LD_EXP 52
17623: PPUSH
17624: CALL_OW 255
17628: PUSH
17629: LD_INT 1
17631: EQUAL
17632: AND
17633: IFFALSE 17647
// Say ( Frank , D3nW-Frank-1 ) ;
17635: LD_EXP 52
17639: PPUSH
17640: LD_STRING D3nW-Frank-1
17642: PPUSH
17643: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17647: LD_EXP 59
17651: PPUSH
17652: LD_INT 22
17654: PUSH
17655: LD_INT 1
17657: PUSH
17658: EMPTY
17659: LIST
17660: LIST
17661: PPUSH
17662: CALL_OW 72
17666: IFFALSE 17692
// begin Say ( JMM , D3nW-JMM-1 ) ;
17668: LD_EXP 39
17672: PPUSH
17673: LD_STRING D3nW-JMM-1
17675: PPUSH
17676: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17680: LD_EXP 39
17684: PPUSH
17685: LD_STRING D3nW-JMM-1a
17687: PPUSH
17688: CALL_OW 88
// end ; t := 0 0$00 ;
17692: LD_ADDR_VAR 0 3
17696: PUSH
17697: LD_INT 0
17699: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17700: LD_INT 35
17702: PPUSH
17703: CALL_OW 67
// t := t + 0 0$1 ;
17707: LD_ADDR_VAR 0 3
17711: PUSH
17712: LD_VAR 0 3
17716: PUSH
17717: LD_INT 35
17719: PLUS
17720: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17721: LD_INT 59
17723: PPUSH
17724: LD_INT 112
17726: PPUSH
17727: CALL_OW 428
17731: PUSH
17732: LD_VAR 0 3
17736: PUSH
17737: LD_INT 2100
17739: GREATER
17740: OR
17741: IFFALSE 17700
// activeAttacks := true ;
17743: LD_ADDR_EXP 16
17747: PUSH
17748: LD_INT 1
17750: ST_TO_ADDR
// end ;
17751: LD_VAR 0 1
17755: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17756: LD_INT 0
17758: PPUSH
// case question of 1 :
17759: LD_VAR 0 1
17763: PUSH
17764: LD_INT 1
17766: DOUBLE
17767: EQUAL
17768: IFTRUE 17772
17770: GO 17823
17772: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17773: LD_EXP 39
17777: PPUSH
17778: LD_STRING D2Mot-JMM-1
17780: PPUSH
17781: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17785: LD_EXP 58
17789: PPUSH
17790: LD_STRING D2Mot-Pow-1
17792: PPUSH
17793: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17797: LD_EXP 39
17801: PPUSH
17802: LD_STRING D2Mot-JMM-2
17804: PPUSH
17805: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17809: LD_EXP 58
17813: PPUSH
17814: LD_STRING D2Mot-Pow-2
17816: PPUSH
17817: CALL_OW 88
// end ; 2 :
17821: GO 18174
17823: LD_INT 2
17825: DOUBLE
17826: EQUAL
17827: IFTRUE 17831
17829: GO 17907
17831: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17832: LD_EXP 39
17836: PPUSH
17837: LD_STRING D2Rus-JMM-1
17839: PPUSH
17840: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17844: LD_EXP 58
17848: PPUSH
17849: LD_STRING D2Rus-Pow-1
17851: PPUSH
17852: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17856: LD_EXP 39
17860: PPUSH
17861: LD_STRING D2Rus-JMM-2
17863: PPUSH
17864: CALL_OW 88
// if not ( 3 in list_of_q ) then
17868: LD_INT 3
17870: PUSH
17871: LD_VAR 0 2
17875: IN
17876: NOT
17877: IFFALSE 17893
// Say ( Powell , D2Rus-Pow-2 ) else
17879: LD_EXP 58
17883: PPUSH
17884: LD_STRING D2Rus-Pow-2
17886: PPUSH
17887: CALL_OW 88
17891: GO 17905
// Say ( Powell , D2Rus-Pow-2a ) ;
17893: LD_EXP 58
17897: PPUSH
17898: LD_STRING D2Rus-Pow-2a
17900: PPUSH
17901: CALL_OW 88
// end ; 3 :
17905: GO 18174
17907: LD_INT 3
17909: DOUBLE
17910: EQUAL
17911: IFTRUE 17915
17913: GO 18000
17915: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17916: LD_EXP 39
17920: PPUSH
17921: LD_STRING D2Leg-JMM-1
17923: PPUSH
17924: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17928: LD_EXP 58
17932: PPUSH
17933: LD_STRING D2Leg-Pow-1
17935: PPUSH
17936: CALL_OW 88
// if 2 in list_of_q then
17940: LD_INT 2
17942: PUSH
17943: LD_VAR 0 2
17947: IN
17948: IFFALSE 17974
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17950: LD_EXP 39
17954: PPUSH
17955: LD_STRING D2Leg-JMM-2
17957: PPUSH
17958: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17962: LD_EXP 58
17966: PPUSH
17967: LD_STRING D2Leg-Pow-2
17969: PPUSH
17970: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17974: LD_EXP 39
17978: PPUSH
17979: LD_STRING D2Leg-JMM-3
17981: PPUSH
17982: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17986: LD_EXP 58
17990: PPUSH
17991: LD_STRING D2Leg-Pow-3
17993: PPUSH
17994: CALL_OW 88
// end ; 4 :
17998: GO 18174
18000: LD_INT 4
18002: DOUBLE
18003: EQUAL
18004: IFTRUE 18008
18006: GO 18083
18008: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18009: LD_EXP 39
18013: PPUSH
18014: LD_STRING D2Ar-JMM-1
18016: PPUSH
18017: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18021: LD_EXP 58
18025: PPUSH
18026: LD_STRING D2Ar-Pow-1
18028: PPUSH
18029: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18033: LD_EXP 39
18037: PPUSH
18038: LD_STRING D2Ar-JMM-2
18040: PPUSH
18041: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18045: LD_EXP 58
18049: PPUSH
18050: LD_STRING D2Ar-Pow-2
18052: PPUSH
18053: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18057: LD_EXP 39
18061: PPUSH
18062: LD_STRING D2Ar-JMM-3
18064: PPUSH
18065: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18069: LD_EXP 58
18073: PPUSH
18074: LD_STRING D2Ar-Pow-3
18076: PPUSH
18077: CALL_OW 88
// end ; 5 :
18081: GO 18174
18083: LD_INT 5
18085: DOUBLE
18086: EQUAL
18087: IFTRUE 18091
18089: GO 18106
18091: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18092: LD_EXP 39
18096: PPUSH
18097: LD_STRING D2Conf-JMM-1
18099: PPUSH
18100: CALL_OW 88
18104: GO 18174
18106: LD_INT 6
18108: DOUBLE
18109: EQUAL
18110: IFTRUE 18114
18112: GO 18173
18114: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18115: LD_EXP 39
18119: PPUSH
18120: LD_STRING D2Com-JMM-1
18122: PPUSH
18123: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18127: LD_EXP 58
18131: PPUSH
18132: LD_STRING D2Com-Pow-1
18134: PPUSH
18135: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18139: LD_EXP 39
18143: PPUSH
18144: LD_STRING D2Com-JMM-2
18146: PPUSH
18147: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18151: LD_EXP 58
18155: PPUSH
18156: LD_STRING D2Com-Pow-2
18158: PPUSH
18159: CALL_OW 88
// powellAngerQuery := true ;
18163: LD_ADDR_EXP 36
18167: PUSH
18168: LD_INT 1
18170: ST_TO_ADDR
// end ; end ;
18171: GO 18174
18173: POP
// end ;
18174: LD_VAR 0 3
18178: RET
// every 0 0$5 trigger missionStart do var tmp ;
18179: LD_EXP 13
18183: IFFALSE 18466
18185: GO 18187
18187: DISABLE
18188: LD_INT 0
18190: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18191: LD_INT 35
18193: PPUSH
18194: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18198: LD_INT 14
18200: PPUSH
18201: LD_INT 22
18203: PUSH
18204: LD_INT 1
18206: PUSH
18207: EMPTY
18208: LIST
18209: LIST
18210: PPUSH
18211: CALL_OW 70
18215: PUSH
18216: LD_EXP 15
18220: PUSH
18221: LD_INT 2
18223: PUSH
18224: LD_INT 3
18226: PUSH
18227: LD_INT 4
18229: PUSH
18230: LD_INT 5
18232: PUSH
18233: EMPTY
18234: LIST
18235: LIST
18236: LIST
18237: LIST
18238: IN
18239: AND
18240: IFFALSE 18456
// begin powellAnger := powellAnger + 1 ;
18242: LD_ADDR_EXP 17
18246: PUSH
18247: LD_EXP 17
18251: PUSH
18252: LD_INT 1
18254: PLUS
18255: ST_TO_ADDR
// Video ( true ) ;
18256: LD_INT 1
18258: PPUSH
18259: CALL 100822 0 1
// CenterNowOnUnits ( tmp ) ;
18263: LD_VAR 0 1
18267: PPUSH
18268: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18272: LD_INT 14
18274: PPUSH
18275: LD_INT 22
18277: PUSH
18278: LD_INT 1
18280: PUSH
18281: EMPTY
18282: LIST
18283: LIST
18284: PPUSH
18285: CALL_OW 70
18289: PPUSH
18290: LD_INT 86
18292: PPUSH
18293: LD_INT 133
18295: PPUSH
18296: CALL_OW 111
// async ;
18300: ASYNC
// case powellAnger of 1 :
18301: LD_EXP 17
18305: PUSH
18306: LD_INT 1
18308: DOUBLE
18309: EQUAL
18310: IFTRUE 18314
18312: GO 18329
18314: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18315: LD_EXP 58
18319: PPUSH
18320: LD_STRING DBack1-Pow-1
18322: PPUSH
18323: CALL_OW 88
18327: GO 18376
18329: LD_INT 2
18331: DOUBLE
18332: EQUAL
18333: IFTRUE 18337
18335: GO 18352
18337: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18338: LD_EXP 58
18342: PPUSH
18343: LD_STRING DBack2-Pow-1
18345: PPUSH
18346: CALL_OW 88
18350: GO 18376
18352: LD_INT 3
18354: DOUBLE
18355: EQUAL
18356: IFTRUE 18360
18358: GO 18375
18360: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18361: LD_EXP 58
18365: PPUSH
18366: LD_STRING DBack3-Pow-1
18368: PPUSH
18369: CALL_OW 88
18373: GO 18376
18375: POP
// sync ;
18376: SYNC
// repeat wait ( 0 0$1 ) ;
18377: LD_INT 35
18379: PPUSH
18380: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18384: LD_INT 14
18386: PPUSH
18387: LD_INT 22
18389: PUSH
18390: LD_INT 1
18392: PUSH
18393: EMPTY
18394: LIST
18395: LIST
18396: PPUSH
18397: CALL_OW 70
18401: PPUSH
18402: LD_INT 86
18404: PPUSH
18405: LD_INT 133
18407: PPUSH
18408: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18412: LD_INT 14
18414: PPUSH
18415: LD_INT 22
18417: PUSH
18418: LD_INT 1
18420: PUSH
18421: EMPTY
18422: LIST
18423: LIST
18424: PPUSH
18425: CALL_OW 70
18429: NOT
18430: IFFALSE 18377
// if powellAnger >= 3 then
18432: LD_EXP 17
18436: PUSH
18437: LD_INT 3
18439: GREATEREQUAL
18440: IFFALSE 18449
// YouLost ( Dismissed ) ;
18442: LD_STRING Dismissed
18444: PPUSH
18445: CALL_OW 104
// Video ( false ) ;
18449: LD_INT 0
18451: PPUSH
18452: CALL 100822 0 1
// end ; until missionStage > 5 ;
18456: LD_EXP 15
18460: PUSH
18461: LD_INT 5
18463: GREATER
18464: IFFALSE 18191
// end ;
18466: PPOPN 1
18468: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18469: LD_EXP 13
18473: PUSH
18474: LD_INT 22
18476: PUSH
18477: LD_INT 4
18479: PUSH
18480: EMPTY
18481: LIST
18482: LIST
18483: PUSH
18484: LD_INT 21
18486: PUSH
18487: LD_INT 2
18489: PUSH
18490: EMPTY
18491: LIST
18492: LIST
18493: PUSH
18494: EMPTY
18495: LIST
18496: LIST
18497: PPUSH
18498: CALL_OW 69
18502: PUSH
18503: LD_INT 4
18505: GREATEREQUAL
18506: AND
18507: PUSH
18508: LD_EXP 15
18512: PUSH
18513: LD_INT 2
18515: EQUAL
18516: AND
18517: IFFALSE 20340
18519: GO 18521
18521: DISABLE
18522: LD_INT 0
18524: PPUSH
18525: PPUSH
18526: PPUSH
18527: PPUSH
18528: PPUSH
18529: PPUSH
18530: PPUSH
18531: PPUSH
// begin missionStage := 3 ;
18532: LD_ADDR_EXP 15
18536: PUSH
18537: LD_INT 3
18539: ST_TO_ADDR
// retreat := false ;
18540: LD_ADDR_VAR 0 4
18544: PUSH
18545: LD_INT 0
18547: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18548: LD_ADDR_VAR 0 5
18552: PUSH
18553: LD_INT 22
18555: PUSH
18556: LD_INT 4
18558: PUSH
18559: EMPTY
18560: LIST
18561: LIST
18562: PUSH
18563: LD_INT 30
18565: PUSH
18566: LD_INT 4
18568: PUSH
18569: EMPTY
18570: LIST
18571: LIST
18572: PUSH
18573: EMPTY
18574: LIST
18575: LIST
18576: PPUSH
18577: CALL_OW 69
18581: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18582: LD_ADDR_VAR 0 6
18586: PUSH
18587: LD_INT 22
18589: PUSH
18590: LD_INT 4
18592: PUSH
18593: EMPTY
18594: LIST
18595: LIST
18596: PUSH
18597: LD_INT 30
18599: PUSH
18600: LD_INT 5
18602: PUSH
18603: EMPTY
18604: LIST
18605: LIST
18606: PUSH
18607: EMPTY
18608: LIST
18609: LIST
18610: PPUSH
18611: CALL_OW 69
18615: ST_TO_ADDR
// if not bar then
18616: LD_VAR 0 6
18620: NOT
18621: IFFALSE 18674
// begin repeat wait ( 0 0$1 ) ;
18623: LD_INT 35
18625: PPUSH
18626: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18630: LD_INT 22
18632: PUSH
18633: LD_INT 4
18635: PUSH
18636: EMPTY
18637: LIST
18638: LIST
18639: PUSH
18640: LD_INT 3
18642: PUSH
18643: LD_INT 57
18645: PUSH
18646: EMPTY
18647: LIST
18648: PUSH
18649: EMPTY
18650: LIST
18651: LIST
18652: PUSH
18653: LD_INT 30
18655: PUSH
18656: LD_INT 5
18658: PUSH
18659: EMPTY
18660: LIST
18661: LIST
18662: PUSH
18663: EMPTY
18664: LIST
18665: LIST
18666: LIST
18667: PPUSH
18668: CALL_OW 69
18672: IFFALSE 18623
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18674: LD_ADDR_VAR 0 6
18678: PUSH
18679: LD_INT 22
18681: PUSH
18682: LD_INT 4
18684: PUSH
18685: EMPTY
18686: LIST
18687: LIST
18688: PUSH
18689: LD_INT 30
18691: PUSH
18692: LD_INT 5
18694: PUSH
18695: EMPTY
18696: LIST
18697: LIST
18698: PUSH
18699: EMPTY
18700: LIST
18701: LIST
18702: PPUSH
18703: CALL_OW 69
18707: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18708: LD_INT 35
18710: PPUSH
18711: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18715: LD_EXP 129
18719: PUSH
18720: LD_INT 4
18722: ARRAY
18723: PUSH
18724: LD_INT 4
18726: GREATEREQUAL
18727: IFFALSE 18708
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18729: LD_ADDR_VAR 0 2
18733: PUSH
18734: LD_INT 22
18736: PUSH
18737: LD_INT 4
18739: PUSH
18740: EMPTY
18741: LIST
18742: LIST
18743: PUSH
18744: LD_INT 2
18746: PUSH
18747: LD_INT 25
18749: PUSH
18750: LD_INT 1
18752: PUSH
18753: EMPTY
18754: LIST
18755: LIST
18756: PUSH
18757: LD_INT 25
18759: PUSH
18760: LD_INT 2
18762: PUSH
18763: EMPTY
18764: LIST
18765: LIST
18766: PUSH
18767: LD_INT 25
18769: PUSH
18770: LD_INT 3
18772: PUSH
18773: EMPTY
18774: LIST
18775: LIST
18776: PUSH
18777: LD_INT 25
18779: PUSH
18780: LD_INT 4
18782: PUSH
18783: EMPTY
18784: LIST
18785: LIST
18786: PUSH
18787: LD_INT 25
18789: PUSH
18790: LD_INT 5
18792: PUSH
18793: EMPTY
18794: LIST
18795: LIST
18796: PUSH
18797: EMPTY
18798: LIST
18799: LIST
18800: LIST
18801: LIST
18802: LIST
18803: LIST
18804: PUSH
18805: EMPTY
18806: LIST
18807: LIST
18808: PPUSH
18809: CALL_OW 69
18813: PUSH
18814: LD_EXP 58
18818: PUSH
18819: LD_EXP 59
18823: ADD
18824: DIFF
18825: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18826: LD_ADDR_VAR 0 3
18830: PUSH
18831: LD_VAR 0 2
18835: PPUSH
18836: LD_INT 26
18838: PUSH
18839: LD_INT 1
18841: PUSH
18842: EMPTY
18843: LIST
18844: LIST
18845: PPUSH
18846: CALL_OW 72
18850: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18851: LD_ADDR_VAR 0 2
18855: PUSH
18856: LD_VAR 0 2
18860: PUSH
18861: LD_VAR 0 3
18865: DIFF
18866: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18867: LD_ADDR_VAR 0 2
18871: PUSH
18872: LD_VAR 0 2
18876: PPUSH
18877: LD_INT 1
18879: PPUSH
18880: CALL 99475 0 2
18884: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18885: LD_ADDR_VAR 0 3
18889: PUSH
18890: LD_VAR 0 3
18894: PPUSH
18895: LD_INT 1
18897: PPUSH
18898: CALL 99475 0 2
18902: ST_TO_ADDR
// for i = 1 to 4 do
18903: LD_ADDR_VAR 0 1
18907: PUSH
18908: DOUBLE
18909: LD_INT 1
18911: DEC
18912: ST_TO_ADDR
18913: LD_INT 4
18915: PUSH
18916: FOR_TO
18917: IFFALSE 19083
// begin if tmp2 then
18919: LD_VAR 0 3
18923: IFFALSE 19004
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18925: LD_ADDR_EXP 18
18929: PUSH
18930: LD_EXP 18
18934: PPUSH
18935: LD_INT 1
18937: PPUSH
18938: LD_EXP 18
18942: PUSH
18943: LD_INT 1
18945: ARRAY
18946: PUSH
18947: LD_VAR 0 3
18951: PUSH
18952: LD_VAR 0 3
18956: ARRAY
18957: ADD
18958: PPUSH
18959: CALL_OW 1
18963: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18964: LD_VAR 0 3
18968: PUSH
18969: LD_VAR 0 3
18973: ARRAY
18974: PPUSH
18975: LD_INT 1
18977: PPUSH
18978: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18982: LD_ADDR_VAR 0 3
18986: PUSH
18987: LD_VAR 0 3
18991: PPUSH
18992: LD_VAR 0 3
18996: PPUSH
18997: CALL_OW 3
19001: ST_TO_ADDR
// end else
19002: GO 19081
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19004: LD_ADDR_EXP 18
19008: PUSH
19009: LD_EXP 18
19013: PPUSH
19014: LD_INT 1
19016: PPUSH
19017: LD_EXP 18
19021: PUSH
19022: LD_INT 1
19024: ARRAY
19025: PUSH
19026: LD_VAR 0 2
19030: PUSH
19031: LD_VAR 0 2
19035: ARRAY
19036: ADD
19037: PPUSH
19038: CALL_OW 1
19042: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19043: LD_VAR 0 2
19047: PUSH
19048: LD_VAR 0 2
19052: ARRAY
19053: PPUSH
19054: LD_INT 1
19056: PPUSH
19057: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19061: LD_ADDR_VAR 0 2
19065: PUSH
19066: LD_VAR 0 2
19070: PPUSH
19071: LD_VAR 0 2
19075: PPUSH
19076: CALL_OW 3
19080: ST_TO_ADDR
// end ; end ;
19081: GO 18916
19083: POP
19084: POP
// if tmp2 then
19085: LD_VAR 0 3
19089: IFFALSE 19107
// tmp := tmp union tmp2 ;
19091: LD_ADDR_VAR 0 2
19095: PUSH
19096: LD_VAR 0 2
19100: PUSH
19101: LD_VAR 0 3
19105: UNION
19106: ST_TO_ADDR
// for i = 1 to 4 do
19107: LD_ADDR_VAR 0 1
19111: PUSH
19112: DOUBLE
19113: LD_INT 1
19115: DEC
19116: ST_TO_ADDR
19117: LD_INT 4
19119: PUSH
19120: FOR_TO
19121: IFFALSE 19170
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19123: LD_ADDR_EXP 18
19127: PUSH
19128: LD_EXP 18
19132: PPUSH
19133: LD_INT 2
19135: PPUSH
19136: LD_EXP 18
19140: PUSH
19141: LD_INT 2
19143: ARRAY
19144: PUSH
19145: LD_VAR 0 2
19149: PUSH
19150: LD_VAR 0 2
19154: PUSH
19155: LD_VAR 0 1
19159: MINUS
19160: ARRAY
19161: ADD
19162: PPUSH
19163: CALL_OW 1
19167: ST_TO_ADDR
19168: GO 19120
19170: POP
19171: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19172: LD_ADDR_EXP 110
19176: PUSH
19177: LD_EXP 110
19181: PPUSH
19182: LD_INT 4
19184: PPUSH
19185: LD_EXP 110
19189: PUSH
19190: LD_INT 4
19192: ARRAY
19193: PUSH
19194: LD_EXP 18
19198: PUSH
19199: LD_INT 1
19201: ARRAY
19202: DIFF
19203: PPUSH
19204: CALL_OW 1
19208: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19209: LD_VAR 0 5
19213: PUSH
19214: LD_INT 1
19216: ARRAY
19217: PPUSH
19218: CALL_OW 313
19222: IFFALSE 19277
// begin for i in UnitsInside ( arm [ 1 ] ) do
19224: LD_ADDR_VAR 0 1
19228: PUSH
19229: LD_VAR 0 5
19233: PUSH
19234: LD_INT 1
19236: ARRAY
19237: PPUSH
19238: CALL_OW 313
19242: PUSH
19243: FOR_IN
19244: IFFALSE 19275
// begin ComExitBuilding ( i ) ;
19246: LD_VAR 0 1
19250: PPUSH
19251: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19255: LD_VAR 0 1
19259: PPUSH
19260: LD_VAR 0 6
19264: PUSH
19265: LD_INT 1
19267: ARRAY
19268: PPUSH
19269: CALL_OW 180
// end ;
19273: GO 19243
19275: POP
19276: POP
// end ; wait ( 0 0$3 ) ;
19277: LD_INT 105
19279: PPUSH
19280: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19284: LD_ADDR_VAR 0 1
19288: PUSH
19289: LD_EXP 18
19293: PUSH
19294: LD_INT 1
19296: ARRAY
19297: PUSH
19298: FOR_IN
19299: IFFALSE 19406
// begin if IsInUnit ( i ) then
19301: LD_VAR 0 1
19305: PPUSH
19306: CALL_OW 310
19310: IFFALSE 19321
// ComExitBuilding ( i ) ;
19312: LD_VAR 0 1
19316: PPUSH
19317: CALL_OW 122
// if GetClass ( i ) <> 1 then
19321: LD_VAR 0 1
19325: PPUSH
19326: CALL_OW 257
19330: PUSH
19331: LD_INT 1
19333: NONEQUAL
19334: IFFALSE 19375
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19336: LD_VAR 0 1
19340: PPUSH
19341: LD_VAR 0 5
19345: PUSH
19346: LD_INT 1
19348: ARRAY
19349: PPUSH
19350: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19354: LD_VAR 0 1
19358: PPUSH
19359: LD_INT 1
19361: PPUSH
19362: CALL_OW 183
// AddComExitBuilding ( i ) ;
19366: LD_VAR 0 1
19370: PPUSH
19371: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19375: LD_VAR 0 1
19379: PPUSH
19380: LD_INT 60
19382: PPUSH
19383: LD_INT 94
19385: PPUSH
19386: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19390: LD_VAR 0 1
19394: PPUSH
19395: LD_EXP 58
19399: PPUSH
19400: CALL_OW 179
// end ;
19404: GO 19298
19406: POP
19407: POP
// wait ( 0 0$15 ) ;
19408: LD_INT 525
19410: PPUSH
19411: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19415: LD_EXP 58
19419: PPUSH
19420: LD_STRING D4-Pow-1
19422: PPUSH
19423: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19427: LD_ADDR_VAR 0 2
19431: PUSH
19432: LD_EXP 18
19436: PUSH
19437: LD_INT 1
19439: ARRAY
19440: PPUSH
19441: LD_INT 26
19443: PUSH
19444: LD_INT 1
19446: PUSH
19447: EMPTY
19448: LIST
19449: LIST
19450: PPUSH
19451: CALL_OW 72
19455: ST_TO_ADDR
// if tmp then
19456: LD_VAR 0 2
19460: IFFALSE 19478
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19462: LD_VAR 0 2
19466: PUSH
19467: LD_INT 1
19469: ARRAY
19470: PPUSH
19471: LD_STRING D4-Sol1-1
19473: PPUSH
19474: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19478: LD_EXP 58
19482: PPUSH
19483: LD_STRING D4-Pow-2
19485: PPUSH
19486: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19490: LD_ADDR_VAR 0 1
19494: PUSH
19495: DOUBLE
19496: LD_INT 1
19498: DEC
19499: ST_TO_ADDR
19500: LD_EXP 18
19504: PUSH
19505: LD_INT 1
19507: ARRAY
19508: PUSH
19509: FOR_TO
19510: IFFALSE 19603
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19512: LD_EXP 18
19516: PUSH
19517: LD_INT 1
19519: ARRAY
19520: PUSH
19521: LD_VAR 0 1
19525: ARRAY
19526: PPUSH
19527: LD_EXP 129
19531: PUSH
19532: LD_INT 4
19534: ARRAY
19535: PUSH
19536: LD_INT 1
19538: ARRAY
19539: PPUSH
19540: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19544: LD_ADDR_EXP 129
19548: PUSH
19549: LD_EXP 129
19553: PPUSH
19554: LD_INT 4
19556: PPUSH
19557: LD_EXP 129
19561: PUSH
19562: LD_INT 4
19564: ARRAY
19565: PPUSH
19566: LD_INT 1
19568: PPUSH
19569: CALL_OW 3
19573: PPUSH
19574: CALL_OW 1
19578: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19579: LD_INT 8
19581: PPUSH
19582: LD_EXP 18
19586: PUSH
19587: LD_INT 1
19589: ARRAY
19590: PUSH
19591: LD_VAR 0 1
19595: ARRAY
19596: PPUSH
19597: CALL_OW 471
// end ;
19601: GO 19509
19603: POP
19604: POP
// repeat wait ( 0 0$1 ) ;
19605: LD_INT 35
19607: PPUSH
19608: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19612: LD_EXP 18
19616: PUSH
19617: LD_INT 1
19619: ARRAY
19620: PPUSH
19621: LD_INT 55
19623: PUSH
19624: EMPTY
19625: LIST
19626: PPUSH
19627: CALL_OW 72
19631: PUSH
19632: LD_INT 4
19634: GREATEREQUAL
19635: IFFALSE 19605
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19637: LD_EXP 18
19641: PUSH
19642: LD_INT 1
19644: ARRAY
19645: PPUSH
19646: LD_INT 69
19648: PPUSH
19649: LD_INT 94
19651: PPUSH
19652: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19656: LD_EXP 18
19660: PUSH
19661: LD_INT 1
19663: ARRAY
19664: PPUSH
19665: LD_INT 82
19667: PPUSH
19668: LD_INT 83
19670: PPUSH
19671: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19675: LD_EXP 18
19679: PUSH
19680: LD_INT 1
19682: ARRAY
19683: PPUSH
19684: LD_INT 77
19686: PPUSH
19687: LD_INT 69
19689: PPUSH
19690: CALL_OW 174
// repeat wait ( 3 ) ;
19694: LD_INT 3
19696: PPUSH
19697: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19701: LD_ADDR_VAR 0 1
19705: PUSH
19706: LD_EXP 18
19710: PUSH
19711: LD_INT 1
19713: ARRAY
19714: PUSH
19715: FOR_IN
19716: IFFALSE 19852
// begin if GetLives ( i ) < 990 then
19718: LD_VAR 0 1
19722: PPUSH
19723: CALL_OW 256
19727: PUSH
19728: LD_INT 990
19730: LESS
19731: IFFALSE 19745
// SetLives ( i , 1000 ) ;
19733: LD_VAR 0 1
19737: PPUSH
19738: LD_INT 1000
19740: PPUSH
19741: CALL_OW 234
// if not IsInUnit ( i ) then
19745: LD_VAR 0 1
19749: PPUSH
19750: CALL_OW 310
19754: NOT
19755: IFFALSE 19850
// begin if not HasTask ( i ) then
19757: LD_VAR 0 1
19761: PPUSH
19762: CALL_OW 314
19766: NOT
19767: IFFALSE 19784
// ComMoveXY ( i , 64 , 93 ) ;
19769: LD_VAR 0 1
19773: PPUSH
19774: LD_INT 64
19776: PPUSH
19777: LD_INT 93
19779: PPUSH
19780: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19784: LD_VAR 0 4
19788: NOT
19789: PUSH
19790: LD_VAR 0 1
19794: PPUSH
19795: CALL_OW 258
19799: PUSH
19800: LD_INT 1
19802: EQUAL
19803: AND
19804: IFFALSE 19850
// begin retreat := true ;
19806: LD_ADDR_VAR 0 4
19810: PUSH
19811: LD_INT 1
19813: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19814: LD_VAR 0 1
19818: PPUSH
19819: LD_INT 2
19821: PPUSH
19822: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19826: LD_VAR 0 1
19830: PPUSH
19831: LD_STRING D4a-Sol1-1
19833: PPUSH
19834: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19838: LD_EXP 58
19842: PPUSH
19843: LD_STRING D4a-Pow-1
19845: PPUSH
19846: CALL_OW 88
// end ; end ; end ;
19850: GO 19715
19852: POP
19853: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19854: LD_EXP 18
19858: PUSH
19859: LD_INT 1
19861: ARRAY
19862: PPUSH
19863: LD_INT 95
19865: PUSH
19866: LD_INT 9
19868: PUSH
19869: EMPTY
19870: LIST
19871: LIST
19872: PUSH
19873: LD_INT 3
19875: PUSH
19876: LD_INT 55
19878: PUSH
19879: EMPTY
19880: LIST
19881: PUSH
19882: EMPTY
19883: LIST
19884: LIST
19885: PUSH
19886: EMPTY
19887: LIST
19888: LIST
19889: PPUSH
19890: CALL_OW 72
19894: PUSH
19895: LD_INT 4
19897: GREATEREQUAL
19898: IFFALSE 19694
// for i in powellSquadAttack [ 1 ] do
19900: LD_ADDR_VAR 0 1
19904: PUSH
19905: LD_EXP 18
19909: PUSH
19910: LD_INT 1
19912: ARRAY
19913: PUSH
19914: FOR_IN
19915: IFFALSE 20051
// begin if GetTag ( i ) = 2 then
19917: LD_VAR 0 1
19921: PPUSH
19922: CALL_OW 110
19926: PUSH
19927: LD_INT 2
19929: EQUAL
19930: IFFALSE 19992
// begin ComMoveXY ( i , 60 , 94 ) ;
19932: LD_VAR 0 1
19936: PPUSH
19937: LD_INT 60
19939: PPUSH
19940: LD_INT 94
19942: PPUSH
19943: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19947: LD_VAR 0 1
19951: PPUSH
19952: LD_EXP 58
19956: PPUSH
19957: CALL_OW 179
// wait ( 0 0$3 ) ;
19961: LD_INT 105
19963: PPUSH
19964: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19968: LD_VAR 0 1
19972: PPUSH
19973: LD_STRING D4a-Sol1-2
19975: PPUSH
19976: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19980: LD_EXP 58
19984: PPUSH
19985: LD_STRING D4a-Pow-2
19987: PPUSH
19988: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19992: LD_VAR 0 1
19996: PPUSH
19997: LD_INT 0
19999: PPUSH
20000: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20004: LD_ADDR_EXP 110
20008: PUSH
20009: LD_EXP 110
20013: PPUSH
20014: LD_INT 4
20016: PPUSH
20017: LD_EXP 110
20021: PUSH
20022: LD_INT 4
20024: ARRAY
20025: PUSH
20026: LD_VAR 0 1
20030: UNION
20031: PPUSH
20032: CALL_OW 1
20036: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20037: LD_INT 8
20039: PPUSH
20040: LD_VAR 0 1
20044: PPUSH
20045: CALL_OW 472
// end ;
20049: GO 19914
20051: POP
20052: POP
// wait ( 4 4$00 ) ;
20053: LD_INT 8400
20055: PPUSH
20056: CALL_OW 67
// uc_side := 6 ;
20060: LD_ADDR_OWVAR 20
20064: PUSH
20065: LD_INT 6
20067: ST_TO_ADDR
// uc_nation := 3 ;
20068: LD_ADDR_OWVAR 21
20072: PUSH
20073: LD_INT 3
20075: ST_TO_ADDR
// ru := [ ] ;
20076: LD_ADDR_VAR 0 7
20080: PUSH
20081: EMPTY
20082: ST_TO_ADDR
// for i = 1 to 4 do
20083: LD_ADDR_VAR 0 1
20087: PUSH
20088: DOUBLE
20089: LD_INT 1
20091: DEC
20092: ST_TO_ADDR
20093: LD_INT 4
20095: PUSH
20096: FOR_TO
20097: IFFALSE 20198
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20099: LD_INT 22
20101: PPUSH
20102: LD_INT 1
20104: PPUSH
20105: LD_INT 3
20107: PPUSH
20108: LD_INT 43
20110: PUSH
20111: LD_INT 44
20113: PUSH
20114: EMPTY
20115: LIST
20116: LIST
20117: PUSH
20118: LD_INT 1
20120: PPUSH
20121: LD_INT 2
20123: PPUSH
20124: CALL_OW 12
20128: ARRAY
20129: PPUSH
20130: LD_INT 89
20132: PPUSH
20133: CALL 69804 0 5
// un := CreateVehicle ;
20137: LD_ADDR_VAR 0 8
20141: PUSH
20142: CALL_OW 45
20146: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20147: LD_VAR 0 8
20151: PPUSH
20152: LD_INT 4
20154: PPUSH
20155: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20159: LD_VAR 0 8
20163: PPUSH
20164: LD_INT 136
20166: PPUSH
20167: LD_INT 90
20169: PPUSH
20170: LD_INT 8
20172: PPUSH
20173: LD_INT 0
20175: PPUSH
20176: CALL_OW 50
// ru := ru ^ un ;
20180: LD_ADDR_VAR 0 7
20184: PUSH
20185: LD_VAR 0 7
20189: PUSH
20190: LD_VAR 0 8
20194: ADD
20195: ST_TO_ADDR
// end ;
20196: GO 20096
20198: POP
20199: POP
// if ru then
20200: LD_VAR 0 7
20204: IFFALSE 20221
// ComAgressiveMove ( ru , 80 , 92 ) ;
20206: LD_VAR 0 7
20210: PPUSH
20211: LD_INT 80
20213: PPUSH
20214: LD_INT 92
20216: PPUSH
20217: CALL_OW 114
// wait ( 8 8$00 ) ;
20221: LD_INT 16800
20223: PPUSH
20224: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20228: LD_INT 4
20230: PPUSH
20231: LD_INT 3
20233: PUSH
20234: LD_INT 1
20236: PUSH
20237: LD_INT 1
20239: PUSH
20240: LD_INT 5
20242: PUSH
20243: EMPTY
20244: LIST
20245: LIST
20246: LIST
20247: LIST
20248: PUSH
20249: LD_INT 4
20251: PUSH
20252: LD_INT 1
20254: PUSH
20255: LD_INT 1
20257: PUSH
20258: LD_INT 6
20260: PUSH
20261: EMPTY
20262: LIST
20263: LIST
20264: LIST
20265: LIST
20266: PUSH
20267: LD_INT 4
20269: PUSH
20270: LD_INT 1
20272: PUSH
20273: LD_INT 1
20275: PUSH
20276: LD_INT 7
20278: PUSH
20279: EMPTY
20280: LIST
20281: LIST
20282: LIST
20283: LIST
20284: PUSH
20285: LD_INT 3
20287: PUSH
20288: LD_INT 1
20290: PUSH
20291: LD_INT 1
20293: PUSH
20294: LD_INT 7
20296: PUSH
20297: EMPTY
20298: LIST
20299: LIST
20300: LIST
20301: LIST
20302: PUSH
20303: LD_INT 3
20305: PUSH
20306: LD_INT 1
20308: PUSH
20309: LD_INT 1
20311: PUSH
20312: LD_INT 5
20314: PUSH
20315: EMPTY
20316: LIST
20317: LIST
20318: LIST
20319: LIST
20320: PUSH
20321: EMPTY
20322: LIST
20323: LIST
20324: LIST
20325: LIST
20326: LIST
20327: PPUSH
20328: CALL 58588 0 2
// missionStage := 4 ;
20332: LD_ADDR_EXP 15
20336: PUSH
20337: LD_INT 4
20339: ST_TO_ADDR
// end ;
20340: PPOPN 8
20342: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20343: LD_EXP 15
20347: PUSH
20348: LD_INT 4
20350: EQUAL
20351: PUSH
20352: LD_INT 22
20354: PUSH
20355: LD_INT 4
20357: PUSH
20358: EMPTY
20359: LIST
20360: LIST
20361: PUSH
20362: LD_INT 21
20364: PUSH
20365: LD_INT 2
20367: PUSH
20368: EMPTY
20369: LIST
20370: LIST
20371: PUSH
20372: EMPTY
20373: LIST
20374: LIST
20375: PPUSH
20376: CALL_OW 69
20380: PUSH
20381: LD_INT 5
20383: GREATEREQUAL
20384: AND
20385: IFFALSE 24490
20387: GO 20389
20389: DISABLE
20390: LD_INT 0
20392: PPUSH
20393: PPUSH
20394: PPUSH
20395: PPUSH
20396: PPUSH
20397: PPUSH
20398: PPUSH
20399: PPUSH
20400: PPUSH
20401: PPUSH
20402: PPUSH
20403: PPUSH
20404: PPUSH
// begin missionStage := 5 ;
20405: LD_ADDR_EXP 15
20409: PUSH
20410: LD_INT 5
20412: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20413: LD_ADDR_VAR 0 10
20417: PUSH
20418: LD_INT 22
20420: PUSH
20421: LD_INT 4
20423: PUSH
20424: EMPTY
20425: LIST
20426: LIST
20427: PUSH
20428: LD_INT 2
20430: PUSH
20431: LD_INT 30
20433: PUSH
20434: LD_INT 4
20436: PUSH
20437: EMPTY
20438: LIST
20439: LIST
20440: PUSH
20441: LD_INT 30
20443: PUSH
20444: LD_INT 5
20446: PUSH
20447: EMPTY
20448: LIST
20449: LIST
20450: PUSH
20451: EMPTY
20452: LIST
20453: LIST
20454: LIST
20455: PUSH
20456: EMPTY
20457: LIST
20458: LIST
20459: PPUSH
20460: CALL_OW 69
20464: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20465: LD_ADDR_VAR 0 6
20469: PUSH
20470: LD_INT 22
20472: PUSH
20473: LD_INT 4
20475: PUSH
20476: EMPTY
20477: LIST
20478: LIST
20479: PUSH
20480: LD_INT 21
20482: PUSH
20483: LD_INT 1
20485: PUSH
20486: EMPTY
20487: LIST
20488: LIST
20489: PUSH
20490: LD_INT 3
20492: PUSH
20493: LD_INT 25
20495: PUSH
20496: LD_INT 16
20498: PUSH
20499: EMPTY
20500: LIST
20501: LIST
20502: PUSH
20503: EMPTY
20504: LIST
20505: LIST
20506: PUSH
20507: LD_INT 3
20509: PUSH
20510: LD_INT 25
20512: PUSH
20513: LD_INT 12
20515: PUSH
20516: EMPTY
20517: LIST
20518: LIST
20519: PUSH
20520: EMPTY
20521: LIST
20522: LIST
20523: PUSH
20524: EMPTY
20525: LIST
20526: LIST
20527: LIST
20528: LIST
20529: PPUSH
20530: CALL_OW 69
20534: PUSH
20535: LD_EXP 58
20539: DIFF
20540: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20541: LD_ADDR_VAR 0 9
20545: PUSH
20546: LD_INT 22
20548: PUSH
20549: LD_INT 4
20551: PUSH
20552: EMPTY
20553: LIST
20554: LIST
20555: PUSH
20556: LD_INT 30
20558: PUSH
20559: LD_INT 3
20561: PUSH
20562: EMPTY
20563: LIST
20564: LIST
20565: PUSH
20566: EMPTY
20567: LIST
20568: LIST
20569: PPUSH
20570: CALL_OW 69
20574: PUSH
20575: LD_INT 1
20577: ARRAY
20578: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20579: LD_INT 35
20581: PPUSH
20582: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20586: LD_EXP 129
20590: PUSH
20591: LD_INT 4
20593: ARRAY
20594: PUSH
20595: LD_INT 5
20597: GREATEREQUAL
20598: PUSH
20599: LD_EXP 129
20603: PUSH
20604: LD_INT 4
20606: ARRAY
20607: PPUSH
20608: LD_INT 58
20610: PUSH
20611: EMPTY
20612: LIST
20613: PPUSH
20614: CALL_OW 72
20618: PUSH
20619: LD_INT 5
20621: GREATEREQUAL
20622: AND
20623: IFFALSE 20579
// powellAllowRetreat := false ;
20625: LD_ADDR_EXP 19
20629: PUSH
20630: LD_INT 0
20632: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20633: LD_INT 700
20635: PPUSH
20636: CALL_OW 67
// activeAttacks := false ;
20640: LD_ADDR_EXP 16
20644: PUSH
20645: LD_INT 0
20647: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20648: LD_INT 35
20650: PPUSH
20651: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20655: LD_INT 22
20657: PUSH
20658: LD_INT 6
20660: PUSH
20661: EMPTY
20662: LIST
20663: LIST
20664: PPUSH
20665: CALL_OW 69
20669: PUSH
20670: LD_INT 0
20672: EQUAL
20673: IFFALSE 20648
// tmp := mc_vehicles [ 4 ] ;
20675: LD_ADDR_VAR 0 3
20679: PUSH
20680: LD_EXP 129
20684: PUSH
20685: LD_INT 4
20687: ARRAY
20688: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20689: LD_ADDR_VAR 0 1
20693: PUSH
20694: DOUBLE
20695: LD_INT 1
20697: DEC
20698: ST_TO_ADDR
20699: LD_EXP 18
20703: PUSH
20704: FOR_TO
20705: IFFALSE 20966
// begin for j in powellSquadAttack [ i ] do
20707: LD_ADDR_VAR 0 2
20711: PUSH
20712: LD_EXP 18
20716: PUSH
20717: LD_VAR 0 1
20721: ARRAY
20722: PUSH
20723: FOR_IN
20724: IFFALSE 20962
// begin forces := forces diff j ;
20726: LD_ADDR_VAR 0 6
20730: PUSH
20731: LD_VAR 0 6
20735: PUSH
20736: LD_VAR 0 2
20740: DIFF
20741: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20742: LD_VAR 0 2
20746: PPUSH
20747: LD_INT 1
20749: PPUSH
20750: CALL_OW 109
// wait ( 0 0$2 ) ;
20754: LD_INT 70
20756: PPUSH
20757: CALL_OW 67
// if IsInUnit ( j ) then
20761: LD_VAR 0 2
20765: PPUSH
20766: CALL_OW 310
20770: IFFALSE 20781
// ComExitBuilding ( j ) ;
20772: LD_VAR 0 2
20776: PPUSH
20777: CALL_OW 122
// if GetClass ( j ) <> 1 then
20781: LD_VAR 0 2
20785: PPUSH
20786: CALL_OW 257
20790: PUSH
20791: LD_INT 1
20793: NONEQUAL
20794: IFFALSE 20874
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20796: LD_VAR 0 10
20800: PUSH
20801: LD_INT 1
20803: ARRAY
20804: PPUSH
20805: CALL_OW 313
20809: PUSH
20810: LD_INT 5
20812: GREATEREQUAL
20813: IFFALSE 20835
// AddComEnterUnit ( j , arm [ 2 ] ) else
20815: LD_VAR 0 2
20819: PPUSH
20820: LD_VAR 0 10
20824: PUSH
20825: LD_INT 2
20827: ARRAY
20828: PPUSH
20829: CALL_OW 180
20833: GO 20853
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20835: LD_VAR 0 2
20839: PPUSH
20840: LD_VAR 0 10
20844: PUSH
20845: LD_INT 1
20847: ARRAY
20848: PPUSH
20849: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20853: LD_VAR 0 2
20857: PPUSH
20858: LD_INT 1
20860: PPUSH
20861: CALL_OW 183
// AddComExitBuilding ( j ) ;
20865: LD_VAR 0 2
20869: PPUSH
20870: CALL_OW 182
// end ; if i = 2 then
20874: LD_VAR 0 1
20878: PUSH
20879: LD_INT 2
20881: EQUAL
20882: IFFALSE 20899
// AddComMoveXY ( j , 61 , 93 ) ;
20884: LD_VAR 0 2
20888: PPUSH
20889: LD_INT 61
20891: PPUSH
20892: LD_INT 93
20894: PPUSH
20895: CALL_OW 171
// if i = 1 then
20899: LD_VAR 0 1
20903: PUSH
20904: LD_INT 1
20906: EQUAL
20907: IFFALSE 20960
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20909: LD_VAR 0 2
20913: PPUSH
20914: LD_VAR 0 3
20918: PUSH
20919: LD_INT 1
20921: ARRAY
20922: PPUSH
20923: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20927: LD_ADDR_VAR 0 3
20931: PUSH
20932: LD_VAR 0 3
20936: PPUSH
20937: LD_INT 1
20939: PPUSH
20940: CALL_OW 3
20944: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20945: LD_VAR 0 2
20949: PPUSH
20950: LD_INT 69
20952: PPUSH
20953: LD_INT 94
20955: PPUSH
20956: CALL_OW 171
// end ; end ;
20960: GO 20723
20962: POP
20963: POP
// end ;
20964: GO 20704
20966: POP
20967: POP
// wait ( 0 0$55 ) ;
20968: LD_INT 1925
20970: PPUSH
20971: CALL_OW 67
// MC_Kill ( 4 ) ;
20975: LD_INT 4
20977: PPUSH
20978: CALL 35176 0 1
// tmp := UnitsInside ( fac ) ;
20982: LD_ADDR_VAR 0 3
20986: PUSH
20987: LD_VAR 0 9
20991: PPUSH
20992: CALL_OW 313
20996: ST_TO_ADDR
// if tmp then
20997: LD_VAR 0 3
21001: IFFALSE 21122
// for i in tmp do
21003: LD_ADDR_VAR 0 1
21007: PUSH
21008: LD_VAR 0 3
21012: PUSH
21013: FOR_IN
21014: IFFALSE 21120
// begin ComExitBuilding ( i ) ;
21016: LD_VAR 0 1
21020: PPUSH
21021: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21025: LD_VAR 0 10
21029: PUSH
21030: LD_INT 2
21032: ARRAY
21033: PPUSH
21034: CALL_OW 313
21038: PUSH
21039: LD_INT 6
21041: LESS
21042: IFFALSE 21064
// AddComEnterUnit ( i , arm [ 2 ] ) else
21044: LD_VAR 0 1
21048: PPUSH
21049: LD_VAR 0 10
21053: PUSH
21054: LD_INT 2
21056: ARRAY
21057: PPUSH
21058: CALL_OW 180
21062: GO 21118
// if UnitsInside ( arm [ 1 ] ) < 6 then
21064: LD_VAR 0 10
21068: PUSH
21069: LD_INT 1
21071: ARRAY
21072: PPUSH
21073: CALL_OW 313
21077: PUSH
21078: LD_INT 6
21080: LESS
21081: IFFALSE 21103
// AddComEnterUnit ( i , arm [ 1 ] ) else
21083: LD_VAR 0 1
21087: PPUSH
21088: LD_VAR 0 10
21092: PUSH
21093: LD_INT 1
21095: ARRAY
21096: PPUSH
21097: CALL_OW 180
21101: GO 21118
// AddComMoveXY ( i , 37 , 68 ) ;
21103: LD_VAR 0 1
21107: PPUSH
21108: LD_INT 37
21110: PPUSH
21111: LD_INT 68
21113: PPUSH
21114: CALL_OW 171
// end ;
21118: GO 21013
21120: POP
21121: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21122: LD_ADDR_VAR 0 11
21126: PUSH
21127: LD_VAR 0 6
21131: PPUSH
21132: LD_INT 26
21134: PUSH
21135: LD_INT 1
21137: PUSH
21138: EMPTY
21139: LIST
21140: LIST
21141: PPUSH
21142: CALL_OW 72
21146: PUSH
21147: LD_EXP 59
21151: DIFF
21152: ST_TO_ADDR
// if not speaker then
21153: LD_VAR 0 11
21157: NOT
21158: IFFALSE 21185
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21160: LD_ADDR_VAR 0 11
21164: PUSH
21165: LD_VAR 0 6
21169: PPUSH
21170: LD_INT 26
21172: PUSH
21173: LD_INT 1
21175: PUSH
21176: EMPTY
21177: LIST
21178: LIST
21179: PPUSH
21180: CALL_OW 72
21184: ST_TO_ADDR
// if speaker then
21185: LD_VAR 0 11
21189: IFFALSE 21205
// speaker := speaker [ 1 ] ;
21191: LD_ADDR_VAR 0 11
21195: PUSH
21196: LD_VAR 0 11
21200: PUSH
21201: LD_INT 1
21203: ARRAY
21204: ST_TO_ADDR
// Video ( true ) ;
21205: LD_INT 1
21207: PPUSH
21208: CALL 100822 0 1
// CenterNowOnUnits ( Powell ) ;
21212: LD_EXP 58
21216: PPUSH
21217: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21221: LD_ADDR_VAR 0 3
21225: PUSH
21226: LD_VAR 0 6
21230: PPUSH
21231: LD_INT 3
21233: PUSH
21234: LD_INT 25
21236: PUSH
21237: LD_INT 1
21239: PUSH
21240: EMPTY
21241: LIST
21242: LIST
21243: PUSH
21244: EMPTY
21245: LIST
21246: LIST
21247: PPUSH
21248: CALL_OW 72
21252: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21253: LD_ADDR_VAR 0 12
21257: PUSH
21258: LD_INT 22
21260: PUSH
21261: LD_INT 4
21263: PUSH
21264: EMPTY
21265: LIST
21266: LIST
21267: PUSH
21268: LD_INT 30
21270: PUSH
21271: LD_INT 32
21273: PUSH
21274: EMPTY
21275: LIST
21276: LIST
21277: PUSH
21278: LD_INT 58
21280: PUSH
21281: EMPTY
21282: LIST
21283: PUSH
21284: EMPTY
21285: LIST
21286: LIST
21287: LIST
21288: PPUSH
21289: CALL_OW 69
21293: ST_TO_ADDR
// for i = 1 to 6 do
21294: LD_ADDR_VAR 0 1
21298: PUSH
21299: DOUBLE
21300: LD_INT 1
21302: DEC
21303: ST_TO_ADDR
21304: LD_INT 6
21306: PUSH
21307: FOR_TO
21308: IFFALSE 21449
// begin if IsInUnit ( tmp [ i ] ) then
21310: LD_VAR 0 3
21314: PUSH
21315: LD_VAR 0 1
21319: ARRAY
21320: PPUSH
21321: CALL_OW 310
21325: IFFALSE 21342
// ComExitBuilding ( tmp [ i ] ) ;
21327: LD_VAR 0 3
21331: PUSH
21332: LD_VAR 0 1
21336: ARRAY
21337: PPUSH
21338: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21342: LD_VAR 0 3
21346: PUSH
21347: LD_VAR 0 1
21351: ARRAY
21352: PPUSH
21353: LD_VAR 0 10
21357: PUSH
21358: LD_INT 1
21360: ARRAY
21361: PPUSH
21362: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21366: LD_VAR 0 3
21370: PUSH
21371: LD_VAR 0 1
21375: ARRAY
21376: PPUSH
21377: LD_INT 1
21379: PPUSH
21380: CALL_OW 183
// if emp_towers then
21384: LD_VAR 0 12
21388: IFFALSE 21447
// begin AddComExitBuilding ( tmp [ i ] ) ;
21390: LD_VAR 0 3
21394: PUSH
21395: LD_VAR 0 1
21399: ARRAY
21400: PPUSH
21401: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21405: LD_VAR 0 3
21409: PUSH
21410: LD_VAR 0 1
21414: ARRAY
21415: PPUSH
21416: LD_VAR 0 12
21420: PUSH
21421: LD_INT 1
21423: ARRAY
21424: PPUSH
21425: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21429: LD_ADDR_VAR 0 12
21433: PUSH
21434: LD_VAR 0 12
21438: PPUSH
21439: LD_INT 1
21441: PPUSH
21442: CALL_OW 3
21446: ST_TO_ADDR
// end ; end ;
21447: GO 21307
21449: POP
21450: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21451: LD_ADDR_VAR 0 3
21455: PUSH
21456: LD_EXP 18
21460: PUSH
21461: LD_INT 1
21463: ARRAY
21464: PUSH
21465: LD_EXP 18
21469: PUSH
21470: LD_INT 2
21472: ARRAY
21473: ADD
21474: PPUSH
21475: LD_INT 26
21477: PUSH
21478: LD_INT 1
21480: PUSH
21481: EMPTY
21482: LIST
21483: LIST
21484: PPUSH
21485: CALL_OW 72
21489: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21490: LD_ADDR_VAR 0 1
21494: PUSH
21495: LD_EXP 18
21499: PUSH
21500: LD_INT 2
21502: ARRAY
21503: PUSH
21504: FOR_IN
21505: IFFALSE 21523
// ComTurnUnit ( i , Powell ) ;
21507: LD_VAR 0 1
21511: PPUSH
21512: LD_EXP 58
21516: PPUSH
21517: CALL_OW 119
21521: GO 21504
21523: POP
21524: POP
// Say ( Powell , D5-Pow-1 ) ;
21525: LD_EXP 58
21529: PPUSH
21530: LD_STRING D5-Pow-1
21532: PPUSH
21533: CALL_OW 88
// if tmp then
21537: LD_VAR 0 3
21541: IFFALSE 21559
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21543: LD_VAR 0 3
21547: PUSH
21548: LD_INT 1
21550: ARRAY
21551: PPUSH
21552: LD_STRING D5-Sol2-1
21554: PPUSH
21555: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21559: LD_EXP 58
21563: PPUSH
21564: LD_STRING D5-Pow-2
21566: PPUSH
21567: CALL_OW 88
// if tmp > 1 then
21571: LD_VAR 0 3
21575: PUSH
21576: LD_INT 1
21578: GREATER
21579: IFFALSE 21597
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21581: LD_VAR 0 3
21585: PUSH
21586: LD_INT 2
21588: ARRAY
21589: PPUSH
21590: LD_STRING D5-Sol2-2
21592: PPUSH
21593: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21597: LD_EXP 58
21601: PPUSH
21602: LD_STRING D5-Pow-3
21604: PPUSH
21605: CALL_OW 88
// wait ( 0 0$1 ) ;
21609: LD_INT 35
21611: PPUSH
21612: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21616: LD_ADDR_VAR 0 3
21620: PUSH
21621: LD_EXP 18
21625: PUSH
21626: LD_INT 1
21628: ARRAY
21629: PUSH
21630: LD_EXP 18
21634: PUSH
21635: LD_INT 2
21637: ARRAY
21638: UNION
21639: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21640: LD_VAR 0 3
21644: PPUSH
21645: LD_INT 80
21647: PPUSH
21648: LD_INT 67
21650: PPUSH
21651: CALL_OW 114
// wait ( 0 0$2 ) ;
21655: LD_INT 70
21657: PPUSH
21658: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21662: LD_INT 79
21664: PPUSH
21665: LD_INT 72
21667: PPUSH
21668: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21672: LD_INT 35
21674: PPUSH
21675: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21679: LD_VAR 0 3
21683: PPUSH
21684: LD_INT 3
21686: PUSH
21687: LD_INT 24
21689: PUSH
21690: LD_INT 1000
21692: PUSH
21693: EMPTY
21694: LIST
21695: LIST
21696: PUSH
21697: EMPTY
21698: LIST
21699: LIST
21700: PPUSH
21701: CALL_OW 72
21705: IFFALSE 21672
// Say ( Powell , D5a-Pow-1 ) ;
21707: LD_EXP 58
21711: PPUSH
21712: LD_STRING D5a-Pow-1
21714: PPUSH
21715: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21719: LD_EXP 58
21723: PPUSH
21724: LD_STRING D5a-Pow-1a
21726: PPUSH
21727: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21731: LD_INT 10
21733: PPUSH
21734: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21738: LD_EXP 58
21742: PPUSH
21743: LD_STRING D5a-Pow-1b
21745: PPUSH
21746: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21750: LD_EXP 58
21754: PPUSH
21755: LD_STRING D5a-Pow-1c
21757: PPUSH
21758: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21762: LD_EXP 58
21766: PPUSH
21767: LD_STRING D5a-Pow-1d
21769: PPUSH
21770: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21774: LD_INT 35
21776: PPUSH
21777: CALL_OW 67
// if not HasTask ( tmp ) then
21781: LD_VAR 0 3
21785: PPUSH
21786: CALL_OW 314
21790: NOT
21791: IFFALSE 21808
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21793: LD_VAR 0 3
21797: PPUSH
21798: LD_INT 80
21800: PPUSH
21801: LD_INT 67
21803: PPUSH
21804: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21808: LD_VAR 0 3
21812: PPUSH
21813: LD_INT 24
21815: PUSH
21816: LD_INT 1
21818: PUSH
21819: EMPTY
21820: LIST
21821: LIST
21822: PPUSH
21823: CALL_OW 72
21827: NOT
21828: IFFALSE 21774
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21830: LD_ADDR_VAR 0 3
21834: PUSH
21835: LD_INT 22
21837: PUSH
21838: LD_INT 4
21840: PUSH
21841: EMPTY
21842: LIST
21843: LIST
21844: PUSH
21845: LD_INT 92
21847: PUSH
21848: LD_INT 60
21850: PUSH
21851: LD_INT 93
21853: PUSH
21854: LD_INT 10
21856: PUSH
21857: EMPTY
21858: LIST
21859: LIST
21860: LIST
21861: LIST
21862: PUSH
21863: LD_INT 3
21865: PUSH
21866: LD_INT 54
21868: PUSH
21869: EMPTY
21870: LIST
21871: PUSH
21872: EMPTY
21873: LIST
21874: LIST
21875: PUSH
21876: EMPTY
21877: LIST
21878: LIST
21879: LIST
21880: PPUSH
21881: CALL_OW 69
21885: PUSH
21886: LD_EXP 58
21890: DIFF
21891: ST_TO_ADDR
// if tmp then
21892: LD_VAR 0 3
21896: IFFALSE 21930
// for i in tmp do
21898: LD_ADDR_VAR 0 1
21902: PUSH
21903: LD_VAR 0 3
21907: PUSH
21908: FOR_IN
21909: IFFALSE 21928
// ComMoveXY ( i , 36 , 67 ) ;
21911: LD_VAR 0 1
21915: PPUSH
21916: LD_INT 36
21918: PPUSH
21919: LD_INT 67
21921: PPUSH
21922: CALL_OW 111
21926: GO 21908
21928: POP
21929: POP
// wait ( 0 0$3 ) ;
21930: LD_INT 105
21932: PPUSH
21933: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21937: LD_VAR 0 11
21941: PPUSH
21942: LD_STRING D6-Sol3-1
21944: PPUSH
21945: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21949: LD_EXP 58
21953: PPUSH
21954: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21958: LD_EXP 58
21962: PPUSH
21963: LD_STRING D6-Pow-1
21965: PPUSH
21966: CALL_OW 88
// tmp := [ ] ;
21970: LD_ADDR_VAR 0 3
21974: PUSH
21975: EMPTY
21976: ST_TO_ADDR
// for i = 1 to 2 do
21977: LD_ADDR_VAR 0 1
21981: PUSH
21982: DOUBLE
21983: LD_INT 1
21985: DEC
21986: ST_TO_ADDR
21987: LD_INT 2
21989: PUSH
21990: FOR_TO
21991: IFFALSE 22105
// begin uc_side := 8 ;
21993: LD_ADDR_OWVAR 20
21997: PUSH
21998: LD_INT 8
22000: ST_TO_ADDR
// uc_nation := 2 ;
22001: LD_ADDR_OWVAR 21
22005: PUSH
22006: LD_INT 2
22008: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22009: LD_INT 14
22011: PPUSH
22012: LD_INT 3
22014: PPUSH
22015: LD_INT 2
22017: PPUSH
22018: LD_INT 29
22020: PPUSH
22021: LD_INT 100
22023: PPUSH
22024: CALL 69804 0 5
// veh := CreateVehicle ;
22028: LD_ADDR_VAR 0 13
22032: PUSH
22033: CALL_OW 45
22037: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22038: LD_VAR 0 13
22042: PPUSH
22043: LD_INT 4
22045: PPUSH
22046: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22050: LD_VAR 0 13
22054: PPUSH
22055: LD_INT 99
22057: PPUSH
22058: LD_INT 83
22060: PPUSH
22061: LD_INT 6
22063: PPUSH
22064: LD_INT 0
22066: PPUSH
22067: CALL_OW 50
// wait ( 3 ) ;
22071: LD_INT 3
22073: PPUSH
22074: CALL_OW 67
// Connect ( veh ) ;
22078: LD_VAR 0 13
22082: PPUSH
22083: CALL 72859 0 1
// tmp := tmp ^ veh ;
22087: LD_ADDR_VAR 0 3
22091: PUSH
22092: LD_VAR 0 3
22096: PUSH
22097: LD_VAR 0 13
22101: ADD
22102: ST_TO_ADDR
// end ;
22103: GO 21990
22105: POP
22106: POP
// wait ( 0 0$1 ) ;
22107: LD_INT 35
22109: PPUSH
22110: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22114: LD_INT 99
22116: PPUSH
22117: LD_INT 83
22119: PPUSH
22120: LD_INT 1
22122: PPUSH
22123: LD_INT 10
22125: PPUSH
22126: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22130: LD_INT 99
22132: PPUSH
22133: LD_INT 83
22135: PPUSH
22136: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22140: LD_VAR 0 11
22144: PPUSH
22145: LD_STRING D6-Sol3-2
22147: PPUSH
22148: CALL_OW 88
// async ;
22152: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22153: LD_EXP 58
22157: PPUSH
22158: LD_STRING D6-Pow-2
22160: PPUSH
22161: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22165: LD_VAR 0 3
22169: PUSH
22170: LD_INT 1
22172: ARRAY
22173: PPUSH
22174: LD_VAR 0 9
22178: PPUSH
22179: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22183: LD_VAR 0 3
22187: PUSH
22188: LD_INT 2
22190: ARRAY
22191: PPUSH
22192: LD_INT 22
22194: PUSH
22195: LD_INT 4
22197: PUSH
22198: EMPTY
22199: LIST
22200: LIST
22201: PUSH
22202: LD_INT 21
22204: PUSH
22205: LD_INT 3
22207: PUSH
22208: EMPTY
22209: LIST
22210: LIST
22211: PUSH
22212: EMPTY
22213: LIST
22214: LIST
22215: PPUSH
22216: CALL_OW 69
22220: PPUSH
22221: LD_VAR 0 3
22225: PUSH
22226: LD_INT 2
22228: ARRAY
22229: PPUSH
22230: CALL_OW 74
22234: PPUSH
22235: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22239: LD_EXP 58
22243: PPUSH
22244: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22248: LD_INT 99
22250: PPUSH
22251: LD_INT 83
22253: PPUSH
22254: LD_INT 1
22256: PPUSH
22257: CALL_OW 331
// repeat wait ( 4 ) ;
22261: LD_INT 4
22263: PPUSH
22264: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22268: LD_VAR 0 3
22272: PUSH
22273: LD_INT 1
22275: ARRAY
22276: PPUSH
22277: CALL_OW 256
22281: PUSH
22282: LD_INT 1000
22284: LESS
22285: IFFALSE 22303
// SetLives ( tmp [ 1 ] , 1000 ) ;
22287: LD_VAR 0 3
22291: PUSH
22292: LD_INT 1
22294: ARRAY
22295: PPUSH
22296: LD_INT 1000
22298: PPUSH
22299: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22303: LD_INT 22
22305: PUSH
22306: LD_INT 4
22308: PUSH
22309: EMPTY
22310: LIST
22311: LIST
22312: PUSH
22313: LD_INT 30
22315: PUSH
22316: LD_INT 3
22318: PUSH
22319: EMPTY
22320: LIST
22321: LIST
22322: PUSH
22323: EMPTY
22324: LIST
22325: LIST
22326: PPUSH
22327: CALL_OW 69
22331: PUSH
22332: LD_INT 0
22334: EQUAL
22335: IFFALSE 22261
// sync ;
22337: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22338: LD_EXP 58
22342: PPUSH
22343: LD_STRING D6a-Pow-1
22345: PPUSH
22346: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22350: LD_VAR 0 11
22354: PPUSH
22355: LD_STRING D6a-Sol3-1
22357: PPUSH
22358: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22362: LD_EXP 58
22366: PPUSH
22367: LD_STRING D6a-Pow-2
22369: PPUSH
22370: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22374: LD_VAR 0 11
22378: PPUSH
22379: LD_STRING D6a-Sol3-2
22381: PPUSH
22382: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22386: LD_EXP 58
22390: PPUSH
22391: LD_STRING D6a-Pow-3
22393: PPUSH
22394: CALL_OW 88
// powellCenterCameraMode := true ;
22398: LD_ADDR_EXP 20
22402: PUSH
22403: LD_INT 1
22405: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22406: LD_ADDR_VAR 0 1
22410: PUSH
22411: LD_INT 22
22413: PUSH
22414: LD_INT 8
22416: PUSH
22417: EMPTY
22418: LIST
22419: LIST
22420: PUSH
22421: LD_INT 25
22423: PUSH
22424: LD_INT 2
22426: PUSH
22427: EMPTY
22428: LIST
22429: LIST
22430: PUSH
22431: EMPTY
22432: LIST
22433: LIST
22434: PPUSH
22435: CALL_OW 69
22439: PUSH
22440: FOR_IN
22441: IFFALSE 22496
// begin SetTag ( i , 1 ) ;
22443: LD_VAR 0 1
22447: PPUSH
22448: LD_INT 1
22450: PPUSH
22451: CALL_OW 109
// ComExitBuilding ( i ) ;
22455: LD_VAR 0 1
22459: PPUSH
22460: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22464: LD_VAR 0 1
22468: PPUSH
22469: LD_INT 35
22471: PPUSH
22472: LD_INT 6
22474: PPUSH
22475: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22479: LD_VAR 0 1
22483: PPUSH
22484: LD_INT 53
22486: PPUSH
22487: LD_INT 4
22489: PPUSH
22490: CALL_OW 171
// end ;
22494: GO 22440
22496: POP
22497: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22498: LD_ADDR_VAR 0 3
22502: PUSH
22503: LD_INT 22
22505: PUSH
22506: LD_INT 4
22508: PUSH
22509: EMPTY
22510: LIST
22511: LIST
22512: PUSH
22513: LD_INT 21
22515: PUSH
22516: LD_INT 2
22518: PUSH
22519: EMPTY
22520: LIST
22521: LIST
22522: PUSH
22523: LD_INT 3
22525: PUSH
22526: LD_INT 34
22528: PUSH
22529: LD_INT 12
22531: PUSH
22532: EMPTY
22533: LIST
22534: LIST
22535: PUSH
22536: EMPTY
22537: LIST
22538: LIST
22539: PUSH
22540: EMPTY
22541: LIST
22542: LIST
22543: LIST
22544: PPUSH
22545: CALL_OW 69
22549: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22550: LD_EXP 58
22554: PPUSH
22555: LD_VAR 0 3
22559: PPUSH
22560: LD_EXP 58
22564: PPUSH
22565: CALL_OW 74
22569: PPUSH
22570: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22574: LD_EXP 58
22578: PPUSH
22579: LD_INT 100
22581: PPUSH
22582: LD_INT 88
22584: PPUSH
22585: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22589: LD_EXP 58
22593: PPUSH
22594: LD_INT 100
22596: PPUSH
22597: LD_INT 75
22599: PPUSH
22600: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22604: LD_EXP 58
22608: PPUSH
22609: LD_INT 88
22611: PPUSH
22612: LD_INT 53
22614: PPUSH
22615: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22619: LD_INT 8
22621: PPUSH
22622: LD_EXP 58
22626: PPUSH
22627: CALL_OW 471
// repeat wait ( 3 ) ;
22631: LD_INT 3
22633: PPUSH
22634: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22638: LD_INT 22
22640: PUSH
22641: LD_INT 4
22643: PUSH
22644: EMPTY
22645: LIST
22646: LIST
22647: PUSH
22648: LD_INT 92
22650: PUSH
22651: LD_INT 100
22653: PUSH
22654: LD_INT 75
22656: PUSH
22657: LD_INT 6
22659: PUSH
22660: EMPTY
22661: LIST
22662: LIST
22663: LIST
22664: LIST
22665: PUSH
22666: EMPTY
22667: LIST
22668: LIST
22669: PPUSH
22670: CALL_OW 69
22674: IFFALSE 22631
// async ;
22676: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22677: LD_EXP 58
22681: PPUSH
22682: LD_STRING D6b-Pow-1
22684: PPUSH
22685: CALL_OW 88
// repeat wait ( 3 ) ;
22689: LD_INT 3
22691: PPUSH
22692: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22696: LD_EXP 58
22700: PPUSH
22701: CALL_OW 310
22705: PPUSH
22706: CALL_OW 256
22710: PUSH
22711: LD_INT 1000
22713: LESS
22714: IFFALSE 22733
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22716: LD_EXP 58
22720: PPUSH
22721: CALL_OW 310
22725: PPUSH
22726: LD_INT 1000
22728: PPUSH
22729: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22733: LD_EXP 58
22737: PPUSH
22738: CALL_OW 256
22742: PUSH
22743: LD_INT 1000
22745: LESS
22746: IFFALSE 22760
// SetLives ( Powell , 1000 ) ;
22748: LD_EXP 58
22752: PPUSH
22753: LD_INT 1000
22755: PPUSH
22756: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22760: LD_EXP 58
22764: PPUSH
22765: LD_EXP 63
22769: PPUSH
22770: CALL_OW 296
22774: PUSH
22775: LD_INT 5
22777: LESS
22778: PUSH
22779: LD_EXP 58
22783: PPUSH
22784: CALL_OW 310
22788: PPUSH
22789: LD_EXP 63
22793: PPUSH
22794: CALL_OW 296
22798: PUSH
22799: LD_INT 5
22801: LESS
22802: OR
22803: IFFALSE 22822
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22805: LD_EXP 58
22809: PPUSH
22810: CALL_OW 310
22814: PPUSH
22815: LD_INT 100
22817: PPUSH
22818: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22822: LD_EXP 58
22826: PPUSH
22827: CALL_OW 310
22831: NOT
22832: IFFALSE 22689
// DoNotAttack ( 8 , powellBomb ) ;
22834: LD_INT 8
22836: PPUSH
22837: LD_EXP 63
22841: PPUSH
22842: CALL_OW 471
// game_speed := 4 ;
22846: LD_ADDR_OWVAR 65
22850: PUSH
22851: LD_INT 4
22853: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22854: LD_EXP 58
22858: PPUSH
22859: LD_STRING D6b-Pow-1a
22861: PPUSH
22862: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22866: LD_EXP 58
22870: PPUSH
22871: LD_EXP 63
22875: PPUSH
22876: CALL_OW 180
// sync ;
22880: SYNC
// repeat wait ( 0 0$1 ) ;
22881: LD_INT 35
22883: PPUSH
22884: CALL_OW 67
// until IsInUnit ( Powell ) ;
22888: LD_EXP 58
22892: PPUSH
22893: CALL_OW 310
22897: IFFALSE 22881
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22899: LD_INT 8
22901: PPUSH
22902: LD_EXP 58
22906: PPUSH
22907: CALL_OW 310
22911: PPUSH
22912: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22916: LD_EXP 58
22920: PPUSH
22921: LD_INT 91
22923: PPUSH
22924: LD_INT 44
22926: PPUSH
22927: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22931: LD_EXP 58
22935: PPUSH
22936: LD_INT 96
22938: PPUSH
22939: LD_INT 44
22941: PPUSH
22942: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22946: LD_EXP 58
22950: PPUSH
22951: LD_INT 96
22953: PPUSH
22954: LD_INT 41
22956: PPUSH
22957: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22961: LD_EXP 58
22965: PPUSH
22966: LD_INT 92
22968: PPUSH
22969: LD_INT 39
22971: PPUSH
22972: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22976: LD_EXP 58
22980: PPUSH
22981: LD_INT 88
22983: PPUSH
22984: LD_INT 41
22986: PPUSH
22987: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22991: LD_EXP 58
22995: PPUSH
22996: LD_INT 91
22998: PPUSH
22999: LD_INT 44
23001: PPUSH
23002: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23006: LD_EXP 58
23010: PPUSH
23011: LD_INT 96
23013: PPUSH
23014: LD_INT 44
23016: PPUSH
23017: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23021: LD_EXP 58
23025: PPUSH
23026: LD_INT 96
23028: PPUSH
23029: LD_INT 41
23031: PPUSH
23032: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23036: LD_EXP 58
23040: PPUSH
23041: LD_INT 92
23043: PPUSH
23044: LD_INT 39
23046: PPUSH
23047: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23051: LD_EXP 58
23055: PPUSH
23056: LD_INT 88
23058: PPUSH
23059: LD_INT 41
23061: PPUSH
23062: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23066: LD_EXP 58
23070: PPUSH
23071: LD_INT 91
23073: PPUSH
23074: LD_INT 44
23076: PPUSH
23077: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23081: LD_EXP 58
23085: PPUSH
23086: LD_INT 93
23088: PPUSH
23089: LD_INT 39
23091: PPUSH
23092: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23096: LD_EXP 58
23100: PPUSH
23101: LD_INT 93
23103: PPUSH
23104: LD_INT 36
23106: PPUSH
23107: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23111: LD_INT 122
23113: PPUSH
23114: CALL_OW 67
// game_speed := 4 ;
23118: LD_ADDR_OWVAR 65
23122: PUSH
23123: LD_INT 4
23125: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23126: LD_EXP 58
23130: PPUSH
23131: LD_STRING D6b-Pow-1b
23133: PPUSH
23134: CALL_OW 88
// tmp := [ ] ;
23138: LD_ADDR_VAR 0 3
23142: PUSH
23143: EMPTY
23144: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23145: LD_ADDR_VAR 0 5
23149: PUSH
23150: LD_INT 78
23152: PUSH
23153: LD_INT 47
23155: PUSH
23156: EMPTY
23157: LIST
23158: LIST
23159: PUSH
23160: LD_INT 106
23162: PUSH
23163: LD_INT 53
23165: PUSH
23166: EMPTY
23167: LIST
23168: LIST
23169: PUSH
23170: EMPTY
23171: LIST
23172: LIST
23173: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23174: LD_ADDR_VAR 0 1
23178: PUSH
23179: LD_INT 22
23181: PUSH
23182: LD_INT 8
23184: PUSH
23185: EMPTY
23186: LIST
23187: LIST
23188: PUSH
23189: LD_INT 21
23191: PUSH
23192: LD_INT 3
23194: PUSH
23195: EMPTY
23196: LIST
23197: LIST
23198: PUSH
23199: LD_INT 92
23201: PUSH
23202: LD_INT 90
23204: PUSH
23205: LD_INT 52
23207: PUSH
23208: LD_INT 12
23210: PUSH
23211: EMPTY
23212: LIST
23213: LIST
23214: LIST
23215: LIST
23216: PUSH
23217: EMPTY
23218: LIST
23219: LIST
23220: LIST
23221: PPUSH
23222: CALL_OW 69
23226: PUSH
23227: FOR_IN
23228: IFFALSE 23253
// tmp := tmp ^ UnitsInside ( i ) ;
23230: LD_ADDR_VAR 0 3
23234: PUSH
23235: LD_VAR 0 3
23239: PUSH
23240: LD_VAR 0 1
23244: PPUSH
23245: CALL_OW 313
23249: ADD
23250: ST_TO_ADDR
23251: GO 23227
23253: POP
23254: POP
// for i in tmp do
23255: LD_ADDR_VAR 0 1
23259: PUSH
23260: LD_VAR 0 3
23264: PUSH
23265: FOR_IN
23266: IFFALSE 23428
// begin dist := 9999 ;
23268: LD_ADDR_VAR 0 8
23272: PUSH
23273: LD_INT 9999
23275: ST_TO_ADDR
// _xy := [ ] ;
23276: LD_ADDR_VAR 0 7
23280: PUSH
23281: EMPTY
23282: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23283: LD_VAR 0 1
23287: PPUSH
23288: LD_INT 1
23290: PPUSH
23291: CALL_OW 109
// ComExitBuilding ( i ) ;
23295: LD_VAR 0 1
23299: PPUSH
23300: CALL_OW 122
// for j in xy do
23304: LD_ADDR_VAR 0 2
23308: PUSH
23309: LD_VAR 0 5
23313: PUSH
23314: FOR_IN
23315: IFFALSE 23397
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23317: LD_VAR 0 1
23321: PPUSH
23322: LD_VAR 0 2
23326: PUSH
23327: LD_INT 1
23329: ARRAY
23330: PPUSH
23331: LD_VAR 0 2
23335: PUSH
23336: LD_INT 2
23338: ARRAY
23339: PPUSH
23340: CALL_OW 297
23344: PUSH
23345: LD_VAR 0 8
23349: LESS
23350: IFFALSE 23395
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23352: LD_ADDR_VAR 0 8
23356: PUSH
23357: LD_VAR 0 1
23361: PPUSH
23362: LD_VAR 0 2
23366: PUSH
23367: LD_INT 1
23369: ARRAY
23370: PPUSH
23371: LD_VAR 0 2
23375: PUSH
23376: LD_INT 2
23378: ARRAY
23379: PPUSH
23380: CALL_OW 297
23384: ST_TO_ADDR
// _xy := j ;
23385: LD_ADDR_VAR 0 7
23389: PUSH
23390: LD_VAR 0 2
23394: ST_TO_ADDR
// end ;
23395: GO 23314
23397: POP
23398: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23399: LD_VAR 0 1
23403: PPUSH
23404: LD_VAR 0 7
23408: PUSH
23409: LD_INT 1
23411: ARRAY
23412: PPUSH
23413: LD_VAR 0 7
23417: PUSH
23418: LD_INT 2
23420: ARRAY
23421: PPUSH
23422: CALL_OW 171
// end ;
23426: GO 23265
23428: POP
23429: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23430: LD_ADDR_VAR 0 4
23434: PUSH
23435: LD_VAR 0 3
23439: PPUSH
23440: LD_INT 26
23442: PUSH
23443: LD_INT 1
23445: PUSH
23446: EMPTY
23447: LIST
23448: LIST
23449: PUSH
23450: LD_INT 25
23452: PUSH
23453: LD_INT 1
23455: PUSH
23456: EMPTY
23457: LIST
23458: LIST
23459: PUSH
23460: EMPTY
23461: LIST
23462: LIST
23463: PPUSH
23464: CALL_OW 72
23468: ST_TO_ADDR
// if tmp2 < 2 then
23469: LD_VAR 0 4
23473: PUSH
23474: LD_INT 2
23476: LESS
23477: IFFALSE 23546
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23479: LD_ADDR_VAR 0 4
23483: PUSH
23484: LD_INT 22
23486: PUSH
23487: LD_INT 8
23489: PUSH
23490: EMPTY
23491: LIST
23492: LIST
23493: PUSH
23494: LD_INT 26
23496: PUSH
23497: LD_INT 1
23499: PUSH
23500: EMPTY
23501: LIST
23502: LIST
23503: PUSH
23504: LD_INT 3
23506: PUSH
23507: LD_INT 25
23509: PUSH
23510: LD_INT 15
23512: PUSH
23513: EMPTY
23514: LIST
23515: LIST
23516: PUSH
23517: EMPTY
23518: LIST
23519: LIST
23520: PUSH
23521: EMPTY
23522: LIST
23523: LIST
23524: LIST
23525: PPUSH
23526: CALL_OW 69
23530: PUSH
23531: LD_EXP 60
23535: PUSH
23536: LD_EXP 61
23540: PUSH
23541: EMPTY
23542: LIST
23543: LIST
23544: DIFF
23545: ST_TO_ADDR
// if tmp2 then
23546: LD_VAR 0 4
23550: IFFALSE 23568
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23552: LD_VAR 0 4
23556: PUSH
23557: LD_INT 1
23559: ARRAY
23560: PPUSH
23561: LD_STRING D6b-ArSol1-1
23563: PPUSH
23564: CALL_OW 88
// async ;
23568: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23569: LD_EXP 58
23573: PPUSH
23574: LD_STRING D6b-Pow-2
23576: PPUSH
23577: CALL_OW 88
// wait ( 0 0$1 ) ;
23581: LD_INT 35
23583: PPUSH
23584: CALL_OW 67
// if tmp2 > 1 then
23588: LD_VAR 0 4
23592: PUSH
23593: LD_INT 1
23595: GREATER
23596: IFFALSE 23614
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23598: LD_VAR 0 4
23602: PUSH
23603: LD_INT 2
23605: ARRAY
23606: PPUSH
23607: LD_STRING D6b-ArSol2-1
23609: PPUSH
23610: CALL_OW 88
// sync ;
23614: SYNC
// repeat wait ( 5 ) ;
23615: LD_INT 5
23617: PPUSH
23618: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23622: LD_INT 93
23624: PPUSH
23625: LD_INT 36
23627: PPUSH
23628: CALL_OW 428
23632: PPUSH
23633: CALL_OW 255
23637: PUSH
23638: LD_INT 4
23640: EQUAL
23641: IFFALSE 23615
// DialogueOn ;
23643: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23647: LD_INT 10
23649: PPUSH
23650: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23654: LD_EXP 58
23658: PPUSH
23659: LD_STRING D6b-Pow-2a
23661: PPUSH
23662: CALL_OW 88
// DialogueOff ;
23666: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23670: LD_EXP 58
23674: PPUSH
23675: CALL_OW 310
23679: PPUSH
23680: LD_INT 332
23682: PPUSH
23683: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23687: LD_INT 93
23689: PPUSH
23690: LD_INT 35
23692: PPUSH
23693: LD_INT 1
23695: PPUSH
23696: LD_INT 6
23698: NEG
23699: PPUSH
23700: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23704: LD_INT 35
23706: PPUSH
23707: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23711: LD_INT 332
23713: PPUSH
23714: CALL_OW 256
23718: PUSH
23719: LD_INT 1000
23721: LESS
23722: PUSH
23723: LD_INT 332
23725: PPUSH
23726: CALL_OW 300
23730: AND
23731: IFFALSE 23743
// SetLives ( kozlov_fac , 0 ) ;
23733: LD_INT 332
23735: PPUSH
23736: LD_INT 0
23738: PPUSH
23739: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23743: LD_INT 332
23745: PPUSH
23746: CALL_OW 301
23750: PUSH
23751: LD_EXP 58
23755: PPUSH
23756: CALL_OW 301
23760: OR
23761: IFFALSE 23704
// game_speed := 4 ;
23763: LD_ADDR_OWVAR 65
23767: PUSH
23768: LD_INT 4
23770: ST_TO_ADDR
// powellCenterCameraMode := false ;
23771: LD_ADDR_EXP 20
23775: PUSH
23776: LD_INT 0
23778: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23779: LD_ADDR_VAR 0 1
23783: PUSH
23784: LD_VAR 0 3
23788: PUSH
23789: LD_INT 22
23791: PUSH
23792: LD_INT 8
23794: PUSH
23795: EMPTY
23796: LIST
23797: LIST
23798: PUSH
23799: LD_INT 25
23801: PUSH
23802: LD_INT 2
23804: PUSH
23805: EMPTY
23806: LIST
23807: LIST
23808: PUSH
23809: EMPTY
23810: LIST
23811: LIST
23812: PPUSH
23813: CALL_OW 69
23817: UNION
23818: PUSH
23819: FOR_IN
23820: IFFALSE 23836
// SetTag ( i , 0 ) ;
23822: LD_VAR 0 1
23826: PPUSH
23827: LD_INT 0
23829: PPUSH
23830: CALL_OW 109
23834: GO 23819
23836: POP
23837: POP
// wait ( 0 0$3 ) ;
23838: LD_INT 105
23840: PPUSH
23841: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23845: LD_INT 93
23847: PPUSH
23848: LD_INT 35
23850: PPUSH
23851: LD_INT 1
23853: PPUSH
23854: CALL_OW 331
// DialogueOn ;
23858: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23862: LD_VAR 0 11
23866: PPUSH
23867: LD_STRING D6c-Sol3-1
23869: PPUSH
23870: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23874: LD_INT 10
23876: PPUSH
23877: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23881: LD_EXP 39
23885: PPUSH
23886: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23890: LD_EXP 39
23894: PPUSH
23895: LD_STRING D6c-JMM-1
23897: PPUSH
23898: CALL_OW 88
// if Cyrus then
23902: LD_EXP 45
23906: IFFALSE 23920
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23908: LD_EXP 45
23912: PPUSH
23913: LD_STRING D6c-Cyrus-1
23915: PPUSH
23916: CALL_OW 88
// if Bobby then
23920: LD_EXP 44
23924: IFFALSE 23938
// Say ( Bobby , D6c-Bobby-1 ) ;
23926: LD_EXP 44
23930: PPUSH
23931: LD_STRING D6c-Bobby-1
23933: PPUSH
23934: CALL_OW 88
// if Cornel then
23938: LD_EXP 50
23942: IFFALSE 23956
// Say ( Cornel , D6c-Corn-1 ) ;
23944: LD_EXP 50
23948: PPUSH
23949: LD_STRING D6c-Corn-1
23951: PPUSH
23952: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23956: LD_ADDR_VAR 0 4
23960: PUSH
23961: LD_INT 2
23963: PUSH
23964: LD_INT 22
23966: PUSH
23967: LD_INT 1
23969: PUSH
23970: EMPTY
23971: LIST
23972: LIST
23973: PUSH
23974: LD_INT 22
23976: PUSH
23977: LD_INT 4
23979: PUSH
23980: EMPTY
23981: LIST
23982: LIST
23983: PUSH
23984: EMPTY
23985: LIST
23986: LIST
23987: LIST
23988: PUSH
23989: LD_INT 26
23991: PUSH
23992: LD_INT 1
23994: PUSH
23995: EMPTY
23996: LIST
23997: LIST
23998: PUSH
23999: LD_INT 3
24001: PUSH
24002: LD_INT 25
24004: PUSH
24005: LD_INT 16
24007: PUSH
24008: EMPTY
24009: LIST
24010: LIST
24011: PUSH
24012: LD_INT 25
24014: PUSH
24015: LD_INT 12
24017: PUSH
24018: EMPTY
24019: LIST
24020: LIST
24021: PUSH
24022: EMPTY
24023: LIST
24024: LIST
24025: LIST
24026: PUSH
24027: EMPTY
24028: LIST
24029: LIST
24030: LIST
24031: PPUSH
24032: CALL_OW 69
24036: PUSH
24037: LD_VAR 0 11
24041: PUSH
24042: LD_EXP 39
24046: UNION
24047: PUSH
24048: LD_EXP 59
24052: UNION
24053: PUSH
24054: EMPTY
24055: LIST
24056: DIFF
24057: ST_TO_ADDR
// if tmp2 then
24058: LD_VAR 0 4
24062: IFFALSE 24080
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24064: LD_VAR 0 4
24068: PUSH
24069: LD_INT 1
24071: ARRAY
24072: PPUSH
24073: LD_STRING D6c-Sol1-1
24075: PPUSH
24076: CALL_OW 88
// if Lisa then
24080: LD_EXP 42
24084: IFFALSE 24098
// Say ( Lisa , D6c-Lisa-1 ) ;
24086: LD_EXP 42
24090: PPUSH
24091: LD_STRING D6c-Lisa-1
24093: PPUSH
24094: CALL_OW 88
// if Gary then
24098: LD_EXP 51
24102: IFFALSE 24116
// Say ( Gary , D6c-Gary-1 ) ;
24104: LD_EXP 51
24108: PPUSH
24109: LD_STRING D6c-Gary-1
24111: PPUSH
24112: CALL_OW 88
// if Donaldson then
24116: LD_EXP 43
24120: IFFALSE 24134
// Say ( Donaldson , D6c-Don-1 ) ;
24122: LD_EXP 43
24126: PPUSH
24127: LD_STRING D6c-Don-1
24129: PPUSH
24130: CALL_OW 88
// if tmp2 > 1 then
24134: LD_VAR 0 4
24138: PUSH
24139: LD_INT 1
24141: GREATER
24142: IFFALSE 24160
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24144: LD_VAR 0 4
24148: PUSH
24149: LD_INT 2
24151: ARRAY
24152: PPUSH
24153: LD_STRING D6c-Sol2-1
24155: PPUSH
24156: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24160: LD_VAR 0 11
24164: PPUSH
24165: LD_STRING D6c-Sol3-2
24167: PPUSH
24168: CALL_OW 88
// dwait ( 0 0$1 ) ;
24172: LD_INT 35
24174: PPUSH
24175: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24179: LD_EXP 39
24183: PPUSH
24184: LD_STRING D6c-JMM-2
24186: PPUSH
24187: CALL_OW 88
// DialogueOff ;
24191: CALL_OW 7
// Video ( false ) ;
24195: LD_INT 0
24197: PPUSH
24198: CALL 100822 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24202: LD_INT 22
24204: PUSH
24205: LD_INT 4
24207: PUSH
24208: EMPTY
24209: LIST
24210: LIST
24211: PPUSH
24212: CALL_OW 69
24216: PPUSH
24217: LD_INT 1
24219: PPUSH
24220: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24224: LD_INT 4
24226: PPUSH
24227: LD_INT 4
24229: PPUSH
24230: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24234: LD_ADDR_VAR 0 1
24238: PUSH
24239: LD_INT 4
24241: PPUSH
24242: LD_INT 1
24244: PPUSH
24245: LD_INT 2
24247: PPUSH
24248: CALL 65043 0 3
24252: PUSH
24253: FOR_IN
24254: IFFALSE 24291
// if GetTech ( i , 1 ) <> state_researched then
24256: LD_VAR 0 1
24260: PPUSH
24261: LD_INT 1
24263: PPUSH
24264: CALL_OW 321
24268: PUSH
24269: LD_INT 2
24271: NONEQUAL
24272: IFFALSE 24289
// SetTech ( i , 1 , state_researched ) ;
24274: LD_VAR 0 1
24278: PPUSH
24279: LD_INT 1
24281: PPUSH
24282: LD_INT 2
24284: PPUSH
24285: CALL_OW 322
24289: GO 24253
24291: POP
24292: POP
// missionStage := 6 ;
24293: LD_ADDR_EXP 15
24297: PUSH
24298: LD_INT 6
24300: ST_TO_ADDR
// activeAttacks := true ;
24301: LD_ADDR_EXP 16
24305: PUSH
24306: LD_INT 1
24308: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24309: LD_STRING M2
24311: PPUSH
24312: CALL_OW 337
// SaveForQuickRestart ;
24316: CALL_OW 22
// wait ( 0 0$40 ) ;
24320: LD_INT 1400
24322: PPUSH
24323: CALL_OW 67
// DialogueOn ;
24327: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24331: LD_EXP 62
24335: PPUSH
24336: LD_STRING D7-Friend-1
24338: PPUSH
24339: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24343: LD_EXP 39
24347: PPUSH
24348: LD_STRING D7-JMM-1
24350: PPUSH
24351: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24355: LD_EXP 62
24359: PPUSH
24360: LD_STRING D7-Friend-2
24362: PPUSH
24363: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24367: LD_EXP 39
24371: PPUSH
24372: LD_STRING D7-JMM-2
24374: PPUSH
24375: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24379: LD_EXP 62
24383: PPUSH
24384: LD_STRING D7-Friend-3
24386: PPUSH
24387: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24391: LD_EXP 39
24395: PPUSH
24396: LD_STRING D7-JMM-3
24398: PPUSH
24399: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24403: LD_EXP 62
24407: PPUSH
24408: LD_STRING D7-Friend-4
24410: PPUSH
24411: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24415: LD_EXP 39
24419: PPUSH
24420: LD_STRING D7-JMM-4
24422: PPUSH
24423: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24427: LD_EXP 62
24431: PPUSH
24432: LD_STRING D7-Friend-5
24434: PPUSH
24435: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24439: LD_EXP 39
24443: PPUSH
24444: LD_STRING D7-JMM-5
24446: PPUSH
24447: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24451: LD_EXP 62
24455: PPUSH
24456: LD_STRING D7-Friend-6
24458: PPUSH
24459: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24463: LD_EXP 39
24467: PPUSH
24468: LD_STRING D7-JMM-6
24470: PPUSH
24471: CALL_OW 88
// DialogueOff ;
24475: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24479: LD_STRING Mlegion
24481: PPUSH
24482: CALL_OW 337
// RebuildKozlovFactory ;
24486: CALL 4840 0 0
// end ;
24490: PPOPN 13
24492: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24493: LD_EXP 20
24497: PUSH
24498: LD_EXP 58
24502: PPUSH
24503: CALL_OW 300
24507: AND
24508: IFFALSE 24550
24510: GO 24512
24512: DISABLE
// begin enable ;
24513: ENABLE
// if IsInUnit ( Powell ) then
24514: LD_EXP 58
24518: PPUSH
24519: CALL_OW 310
24523: IFFALSE 24541
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24525: LD_EXP 58
24529: PPUSH
24530: CALL_OW 310
24534: PPUSH
24535: CALL_OW 85
24539: GO 24550
// CenterOnUnits ( Powell ) ;
24541: LD_EXP 58
24545: PPUSH
24546: CALL_OW 85
// end ;
24550: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24551: LD_INT 22
24553: PUSH
24554: LD_INT 8
24556: PUSH
24557: EMPTY
24558: LIST
24559: LIST
24560: PUSH
24561: LD_INT 34
24563: PUSH
24564: LD_INT 48
24566: PUSH
24567: EMPTY
24568: LIST
24569: LIST
24570: PUSH
24571: EMPTY
24572: LIST
24573: LIST
24574: PPUSH
24575: CALL_OW 69
24579: IFFALSE 24853
24581: GO 24583
24583: DISABLE
24584: LD_INT 0
24586: PPUSH
24587: PPUSH
// begin if missionStage < 9 then
24588: LD_EXP 15
24592: PUSH
24593: LD_INT 9
24595: LESS
24596: IFFALSE 24606
// missionStage := 9 ;
24598: LD_ADDR_EXP 15
24602: PUSH
24603: LD_INT 9
24605: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24606: LD_ADDR_VAR 0 1
24610: PUSH
24611: LD_INT 22
24613: PUSH
24614: LD_INT 8
24616: PUSH
24617: EMPTY
24618: LIST
24619: LIST
24620: PUSH
24621: LD_INT 34
24623: PUSH
24624: LD_INT 48
24626: PUSH
24627: EMPTY
24628: LIST
24629: LIST
24630: PUSH
24631: EMPTY
24632: LIST
24633: LIST
24634: PPUSH
24635: CALL_OW 69
24639: PUSH
24640: LD_INT 1
24642: ARRAY
24643: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24644: LD_INT 175
24646: PPUSH
24647: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24651: LD_EXP 12
24655: PUSH
24656: LD_EXP 3
24660: PUSH
24661: LD_INT 0
24663: PUSH
24664: LD_INT 2
24666: PUSH
24667: EMPTY
24668: LIST
24669: LIST
24670: IN
24671: OR
24672: IFFALSE 24695
// target := [ 68 , 108 , 1 ] else
24674: LD_ADDR_VAR 0 2
24678: PUSH
24679: LD_INT 68
24681: PUSH
24682: LD_INT 108
24684: PUSH
24685: LD_INT 1
24687: PUSH
24688: EMPTY
24689: LIST
24690: LIST
24691: LIST
24692: ST_TO_ADDR
24693: GO 24714
// target := [ 181 , 88 , 2 ] ;
24695: LD_ADDR_VAR 0 2
24699: PUSH
24700: LD_INT 181
24702: PUSH
24703: LD_INT 88
24705: PUSH
24706: LD_INT 2
24708: PUSH
24709: EMPTY
24710: LIST
24711: LIST
24712: LIST
24713: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24714: LD_VAR 0 1
24718: PPUSH
24719: LD_VAR 0 2
24723: PUSH
24724: LD_INT 1
24726: ARRAY
24727: PPUSH
24728: LD_VAR 0 2
24732: PUSH
24733: LD_INT 2
24735: ARRAY
24736: PPUSH
24737: CALL_OW 176
// if target [ 3 ] = 1 then
24741: LD_VAR 0 2
24745: PUSH
24746: LD_INT 3
24748: ARRAY
24749: PUSH
24750: LD_INT 1
24752: EQUAL
24753: IFFALSE 24769
// SayRadio ( Kurt , D12-Kurt-1 ) else
24755: LD_EXP 60
24759: PPUSH
24760: LD_STRING D12-Kurt-1
24762: PPUSH
24763: CALL_OW 94
24767: GO 24793
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24769: LD_EXP 60
24773: PPUSH
24774: LD_STRING D12a-Kurt-1
24776: PPUSH
24777: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24781: LD_EXP 74
24785: PPUSH
24786: LD_STRING D12a-Roth-1
24788: PPUSH
24789: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24793: LD_INT 350
24795: PPUSH
24796: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24800: LD_VAR 0 1
24804: PPUSH
24805: LD_INT 22
24807: PUSH
24808: LD_INT 8
24810: PUSH
24811: EMPTY
24812: LIST
24813: LIST
24814: PUSH
24815: LD_INT 23
24817: PUSH
24818: LD_INT 2
24820: PUSH
24821: EMPTY
24822: LIST
24823: LIST
24824: PUSH
24825: LD_INT 30
24827: PUSH
24828: LD_INT 3
24830: PUSH
24831: EMPTY
24832: LIST
24833: LIST
24834: PUSH
24835: EMPTY
24836: LIST
24837: LIST
24838: LIST
24839: PPUSH
24840: CALL_OW 69
24844: PUSH
24845: LD_INT 1
24847: ARRAY
24848: PPUSH
24849: CALL_OW 228
// end ;
24853: PPOPN 2
24855: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24856: LD_EXP 60
24860: PPUSH
24861: CALL_OW 256
24865: PUSH
24866: LD_INT 999
24868: LESS
24869: PUSH
24870: LD_INT 22
24872: PUSH
24873: LD_INT 8
24875: PUSH
24876: EMPTY
24877: LIST
24878: LIST
24879: PUSH
24880: LD_INT 21
24882: PUSH
24883: LD_INT 1
24885: PUSH
24886: EMPTY
24887: LIST
24888: LIST
24889: PUSH
24890: LD_INT 23
24892: PUSH
24893: LD_INT 2
24895: PUSH
24896: EMPTY
24897: LIST
24898: LIST
24899: PUSH
24900: EMPTY
24901: LIST
24902: LIST
24903: LIST
24904: PPUSH
24905: CALL_OW 69
24909: PUSH
24910: LD_INT 9
24912: PUSH
24913: LD_INT 8
24915: PUSH
24916: LD_INT 7
24918: PUSH
24919: EMPTY
24920: LIST
24921: LIST
24922: LIST
24923: PUSH
24924: LD_OWVAR 67
24928: ARRAY
24929: LESSEQUAL
24930: OR
24931: PUSH
24932: LD_INT 22
24934: PUSH
24935: LD_INT 8
24937: PUSH
24938: EMPTY
24939: LIST
24940: LIST
24941: PUSH
24942: LD_INT 34
24944: PUSH
24945: LD_INT 48
24947: PUSH
24948: EMPTY
24949: LIST
24950: LIST
24951: PUSH
24952: EMPTY
24953: LIST
24954: LIST
24955: PPUSH
24956: CALL_OW 69
24960: NOT
24961: AND
24962: PUSH
24963: LD_EXP 60
24967: PPUSH
24968: CALL_OW 302
24972: AND
24973: PUSH
24974: LD_INT 5
24976: PPUSH
24977: LD_INT 22
24979: PUSH
24980: LD_INT 1
24982: PUSH
24983: EMPTY
24984: LIST
24985: LIST
24986: PPUSH
24987: CALL_OW 70
24991: AND
24992: IFFALSE 25697
24994: GO 24996
24996: DISABLE
24997: LD_INT 0
24999: PPUSH
25000: PPUSH
25001: PPUSH
// begin DialogueOn ;
25002: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25006: LD_EXP 39
25010: PPUSH
25011: LD_STRING D13-JMM-1
25013: PPUSH
25014: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25018: LD_EXP 60
25022: PPUSH
25023: LD_STRING D13-Kurt-1
25025: PPUSH
25026: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25030: LD_EXP 39
25034: PPUSH
25035: LD_STRING D13-JMM-2
25037: PPUSH
25038: CALL_OW 88
// if FakeInfo then
25042: LD_EXP 12
25046: IFFALSE 25066
// begin Say ( Kurt , D13-Kurt-2 ) ;
25048: LD_EXP 60
25052: PPUSH
25053: LD_STRING D13-Kurt-2
25055: PPUSH
25056: CALL_OW 88
// DialogueOff ;
25060: CALL_OW 7
// exit ;
25064: GO 25697
// end ; if not KurtStatus then
25066: LD_EXP 3
25070: NOT
25071: IFFALSE 25087
// Say ( Kurt , D13-Kurt-2b ) else
25073: LD_EXP 60
25077: PPUSH
25078: LD_STRING D13-Kurt-2b
25080: PPUSH
25081: CALL_OW 88
25085: GO 25099
// Say ( Kurt , D13-Kurt-2a ) ;
25087: LD_EXP 60
25091: PPUSH
25092: LD_STRING D13-Kurt-2a
25094: PPUSH
25095: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25099: LD_EXP 39
25103: PPUSH
25104: LD_STRING D13-JMM-3
25106: PPUSH
25107: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25111: LD_EXP 60
25115: PPUSH
25116: LD_STRING D13-Kurt-3
25118: PPUSH
25119: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25123: LD_EXP 39
25127: PPUSH
25128: LD_STRING D13-JMM-4
25130: PPUSH
25131: CALL_OW 88
// DialogueOff ;
25135: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
25139: LD_STRING MlegionOut
25141: PPUSH
25142: CALL_OW 337
// legionDestroyed := true ;
25146: LD_ADDR_EXP 22
25150: PUSH
25151: LD_INT 1
25153: ST_TO_ADDR
// MC_Kill ( 3 ) ;
25154: LD_INT 3
25156: PPUSH
25157: CALL 35176 0 1
// KillUnit ( Kozlov ) ;
25161: LD_EXP 61
25165: PPUSH
25166: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25170: LD_ADDR_VAR 0 1
25174: PUSH
25175: LD_INT 22
25177: PUSH
25178: LD_INT 8
25180: PUSH
25181: EMPTY
25182: LIST
25183: LIST
25184: PUSH
25185: LD_INT 23
25187: PUSH
25188: LD_INT 3
25190: PUSH
25191: EMPTY
25192: LIST
25193: LIST
25194: PUSH
25195: LD_INT 3
25197: PUSH
25198: LD_INT 21
25200: PUSH
25201: LD_INT 33
25203: PUSH
25204: EMPTY
25205: LIST
25206: LIST
25207: PUSH
25208: EMPTY
25209: LIST
25210: LIST
25211: PUSH
25212: EMPTY
25213: LIST
25214: LIST
25215: LIST
25216: PPUSH
25217: CALL_OW 69
25221: PUSH
25222: FOR_IN
25223: IFFALSE 25236
// KillUnit ( i ) ;
25225: LD_VAR 0 1
25229: PPUSH
25230: CALL_OW 66
25234: GO 25222
25236: POP
25237: POP
// ChangeSideFog ( 8 , 1 ) ;
25238: LD_INT 8
25240: PPUSH
25241: LD_INT 1
25243: PPUSH
25244: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25248: LD_ADDR_VAR 0 2
25252: PUSH
25253: LD_INT 22
25255: PUSH
25256: LD_INT 8
25258: PUSH
25259: EMPTY
25260: LIST
25261: LIST
25262: PUSH
25263: LD_INT 21
25265: PUSH
25266: LD_INT 1
25268: PUSH
25269: EMPTY
25270: LIST
25271: LIST
25272: PUSH
25273: EMPTY
25274: LIST
25275: LIST
25276: PPUSH
25277: CALL_OW 69
25281: PUSH
25282: LD_EXP 61
25286: PUSH
25287: LD_EXP 60
25291: PUSH
25292: EMPTY
25293: LIST
25294: LIST
25295: DIFF
25296: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 ] [ Difficulty ] then
25297: LD_VAR 0 2
25301: PUSH
25302: LD_INT 6
25304: PUSH
25305: LD_INT 5
25307: PUSH
25308: LD_INT 4
25310: PUSH
25311: EMPTY
25312: LIST
25313: LIST
25314: LIST
25315: PUSH
25316: LD_OWVAR 67
25320: ARRAY
25321: GREATEREQUAL
25322: IFFALSE 25496
// begin x := [ 6 , 5 , 4 ] [ Difficulty ] ;
25324: LD_ADDR_VAR 0 3
25328: PUSH
25329: LD_INT 6
25331: PUSH
25332: LD_INT 5
25334: PUSH
25335: LD_INT 4
25337: PUSH
25338: EMPTY
25339: LIST
25340: LIST
25341: LIST
25342: PUSH
25343: LD_OWVAR 67
25347: ARRAY
25348: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25349: LD_ADDR_VAR 0 1
25353: PUSH
25354: DOUBLE
25355: LD_VAR 0 2
25359: PUSH
25360: LD_VAR 0 3
25364: PUSH
25365: LD_INT 1
25367: PLUS
25368: MINUS
25369: INC
25370: ST_TO_ADDR
25371: LD_INT 1
25373: PUSH
25374: FOR_DOWNTO
25375: IFFALSE 25492
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25377: LD_ADDR_EXP 38
25381: PUSH
25382: LD_EXP 38
25386: PUSH
25387: LD_VAR 0 2
25391: PUSH
25392: LD_VAR 0 1
25396: ARRAY
25397: ADD
25398: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25399: LD_VAR 0 2
25403: PUSH
25404: LD_VAR 0 1
25408: ARRAY
25409: PPUSH
25410: CALL_OW 310
25414: IFFALSE 25431
// ComExitBuilding ( tmp [ i ] ) ;
25416: LD_VAR 0 2
25420: PUSH
25421: LD_VAR 0 1
25425: ARRAY
25426: PPUSH
25427: CALL_OW 122
// if IsInUnit ( i ) then
25431: LD_VAR 0 1
25435: PPUSH
25436: CALL_OW 310
25440: IFFALSE 25457
// ComExitVehicle ( tmp [ i ] ) ;
25442: LD_VAR 0 2
25446: PUSH
25447: LD_VAR 0 1
25451: ARRAY
25452: PPUSH
25453: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25457: LD_VAR 0 2
25461: PUSH
25462: LD_VAR 0 1
25466: ARRAY
25467: PPUSH
25468: LD_INT 34
25470: PUSH
25471: LD_INT 0
25473: PPUSH
25474: LD_INT 6
25476: PPUSH
25477: CALL_OW 12
25481: PLUS
25482: PPUSH
25483: LD_INT 1
25485: PPUSH
25486: CALL_OW 171
// end ;
25490: GO 25374
25492: POP
25493: POP
// end else
25494: GO 25506
// x := tmp ;
25496: LD_ADDR_VAR 0 3
25500: PUSH
25501: LD_VAR 0 2
25505: ST_TO_ADDR
// for i := tmp downto tmp - x do
25506: LD_ADDR_VAR 0 1
25510: PUSH
25511: DOUBLE
25512: LD_VAR 0 2
25516: INC
25517: ST_TO_ADDR
25518: LD_VAR 0 2
25522: PUSH
25523: LD_VAR 0 3
25527: MINUS
25528: PUSH
25529: FOR_DOWNTO
25530: IFFALSE 25584
// begin if IsInUnit ( tmp [ i ] ) then
25532: LD_VAR 0 2
25536: PUSH
25537: LD_VAR 0 1
25541: ARRAY
25542: PPUSH
25543: CALL_OW 310
25547: IFFALSE 25564
// ComExitVehicle ( tmp [ i ] ) ;
25549: LD_VAR 0 2
25553: PUSH
25554: LD_VAR 0 1
25558: ARRAY
25559: PPUSH
25560: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25564: LD_VAR 0 2
25568: PUSH
25569: LD_VAR 0 1
25573: ARRAY
25574: PPUSH
25575: LD_INT 1
25577: PPUSH
25578: CALL_OW 235
// end ;
25582: GO 25529
25584: POP
25585: POP
// SetSide ( Kurt , 1 ) ;
25586: LD_EXP 60
25590: PPUSH
25591: LD_INT 1
25593: PPUSH
25594: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25598: LD_INT 22
25600: PUSH
25601: LD_INT 8
25603: PUSH
25604: EMPTY
25605: LIST
25606: LIST
25607: PUSH
25608: LD_INT 21
25610: PUSH
25611: LD_INT 3
25613: PUSH
25614: EMPTY
25615: LIST
25616: LIST
25617: PUSH
25618: EMPTY
25619: LIST
25620: LIST
25621: PPUSH
25622: CALL_OW 69
25626: PPUSH
25627: LD_INT 1
25629: PPUSH
25630: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25634: LD_INT 8
25636: PPUSH
25637: LD_INT 1
25639: PPUSH
25640: LD_INT 1
25642: PPUSH
25643: LD_INT 1
25645: PPUSH
25646: CALL_OW 80
// wait ( 1 1$20 ) ;
25650: LD_INT 2800
25652: PPUSH
25653: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25657: LD_EXP 62
25661: PPUSH
25662: LD_INT 37
25664: PPUSH
25665: LD_INT 1
25667: PPUSH
25668: LD_INT 0
25670: PPUSH
25671: CALL_OW 48
// wait ( 0 0$1 ) ;
25675: LD_INT 35
25677: PPUSH
25678: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25682: LD_EXP 62
25686: PPUSH
25687: LD_INT 60
25689: PPUSH
25690: LD_INT 95
25692: PPUSH
25693: CALL_OW 111
// end ;
25697: PPOPN 3
25699: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25700: LD_EXP 22
25704: NOT
25705: PUSH
25706: LD_INT 22
25708: PUSH
25709: LD_INT 8
25711: PUSH
25712: EMPTY
25713: LIST
25714: LIST
25715: PUSH
25716: LD_INT 21
25718: PUSH
25719: LD_INT 1
25721: PUSH
25722: EMPTY
25723: LIST
25724: LIST
25725: PUSH
25726: EMPTY
25727: LIST
25728: LIST
25729: PPUSH
25730: CALL_OW 69
25734: PUSH
25735: LD_INT 0
25737: EQUAL
25738: AND
25739: IFFALSE 25759
25741: GO 25743
25743: DISABLE
// begin legionDestroyed := true ;
25744: LD_ADDR_EXP 22
25748: PUSH
25749: LD_INT 1
25751: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
25752: LD_STRING MlegionOut
25754: PPUSH
25755: CALL_OW 337
// end ;
25759: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25760: LD_EXP 38
25764: IFFALSE 25839
25766: GO 25768
25768: DISABLE
25769: LD_INT 0
25771: PPUSH
// begin enable ;
25772: ENABLE
// for i in legionEscapeUnits do
25773: LD_ADDR_VAR 0 1
25777: PUSH
25778: LD_EXP 38
25782: PUSH
25783: FOR_IN
25784: IFFALSE 25837
// begin if IsInArea ( i , legionEscapeArea ) then
25786: LD_VAR 0 1
25790: PPUSH
25791: LD_INT 31
25793: PPUSH
25794: CALL_OW 308
25798: IFFALSE 25811
// RemoveUnit ( i ) else
25800: LD_VAR 0 1
25804: PPUSH
25805: CALL_OW 64
25809: GO 25835
// if not HasTask ( i ) then
25811: LD_VAR 0 1
25815: PPUSH
25816: CALL_OW 314
25820: NOT
25821: IFFALSE 25835
// ComMoveToArea ( i , legionEscapeArea ) ;
25823: LD_VAR 0 1
25827: PPUSH
25828: LD_INT 31
25830: PPUSH
25831: CALL_OW 113
// end ;
25835: GO 25783
25837: POP
25838: POP
// end ;
25839: PPOPN 1
25841: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25842: LD_INT 1
25844: PPUSH
25845: LD_EXP 62
25849: PPUSH
25850: CALL_OW 292
25854: IFFALSE 26152
25856: GO 25858
25858: DISABLE
25859: LD_INT 0
25861: PPUSH
// begin wait ( 0 0$2 ) ;
25862: LD_INT 70
25864: PPUSH
25865: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25869: LD_EXP 62
25873: PPUSH
25874: CALL_OW 87
// DialogueOn ;
25878: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25882: LD_EXP 39
25886: PPUSH
25887: LD_STRING D14-JMM-1
25889: PPUSH
25890: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25894: LD_EXP 62
25898: PPUSH
25899: LD_STRING D14-Friend-1
25901: PPUSH
25902: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25906: LD_EXP 39
25910: PPUSH
25911: LD_STRING D14-JMM-2
25913: PPUSH
25914: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25918: LD_EXP 62
25922: PPUSH
25923: LD_STRING D14-Friend-2
25925: PPUSH
25926: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25930: LD_EXP 39
25934: PPUSH
25935: LD_STRING D14-JMM-3
25937: PPUSH
25938: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25942: LD_EXP 62
25946: PPUSH
25947: LD_STRING D14-Friend-3
25949: PPUSH
25950: CALL_OW 88
// DialogueOff ;
25954: CALL_OW 7
// dec = Query ( Q14 ) ;
25958: LD_ADDR_VAR 0 1
25962: PUSH
25963: LD_STRING Q14
25965: PPUSH
25966: CALL_OW 97
25970: ST_TO_ADDR
// if dec = 1 then
25971: LD_VAR 0 1
25975: PUSH
25976: LD_INT 1
25978: EQUAL
25979: IFFALSE 26013
// begin DialogueOn ;
25981: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25985: LD_EXP 39
25989: PPUSH
25990: LD_STRING D14a-JMM-1
25992: PPUSH
25993: CALL_OW 88
// DialogueOff ;
25997: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26001: LD_EXP 62
26005: PPUSH
26006: LD_INT 1
26008: PPUSH
26009: CALL_OW 235
// end ; if dec = 2 then
26013: LD_VAR 0 1
26017: PUSH
26018: LD_INT 2
26020: EQUAL
26021: IFFALSE 26074
// begin DialogueOn ;
26023: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26027: LD_EXP 39
26031: PPUSH
26032: LD_STRING D14b-JMM-1
26034: PPUSH
26035: CALL_OW 88
// DialogueOff ;
26039: CALL_OW 7
// wait ( 0 0$1 ) ;
26043: LD_INT 35
26045: PPUSH
26046: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26050: LD_EXP 62
26054: PPUSH
26055: LD_INT 9
26057: PPUSH
26058: LD_INT 2
26060: PPUSH
26061: CALL_OW 111
// AddComHold ( Friend ) ;
26065: LD_EXP 62
26069: PPUSH
26070: CALL_OW 200
// end ; if dec = 3 then
26074: LD_VAR 0 1
26078: PUSH
26079: LD_INT 3
26081: EQUAL
26082: IFFALSE 26152
// begin DialogueOn ;
26084: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26088: LD_EXP 39
26092: PPUSH
26093: LD_STRING D14c-JMM-1
26095: PPUSH
26096: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26100: LD_EXP 62
26104: PPUSH
26105: LD_STRING D14c-Friend-1
26107: PPUSH
26108: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26112: LD_EXP 39
26116: PPUSH
26117: LD_STRING D14c-JMM-2
26119: PPUSH
26120: CALL_OW 88
// DialogueOff ;
26124: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26128: LD_EXP 62
26132: PPUSH
26133: LD_INT 9
26135: PPUSH
26136: LD_INT 2
26138: PPUSH
26139: CALL_OW 111
// AddComHold ( Friend ) ;
26143: LD_EXP 62
26147: PPUSH
26148: CALL_OW 200
// end ; end ;
26152: PPOPN 1
26154: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26155: LD_INT 9
26157: PPUSH
26158: LD_INT 2
26160: PPUSH
26161: CALL_OW 428
26165: PUSH
26166: LD_EXP 62
26170: EQUAL
26171: PUSH
26172: LD_EXP 62
26176: PPUSH
26177: CALL_OW 255
26181: PUSH
26182: LD_INT 8
26184: EQUAL
26185: AND
26186: IFFALSE 26200
26188: GO 26190
26190: DISABLE
// RemoveUnit ( Friend ) ;
26191: LD_EXP 62
26195: PPUSH
26196: CALL_OW 64
26200: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26201: LD_EXP 14
26205: PUSH
26206: LD_INT 31500
26208: GREATEREQUAL
26209: PUSH
26210: LD_EXP 7
26214: AND
26215: PUSH
26216: LD_EXP 2
26220: AND
26221: IFFALSE 26651
26223: GO 26225
26225: DISABLE
26226: LD_INT 0
26228: PPUSH
26229: PPUSH
26230: PPUSH
// begin missionStage := 7 ;
26231: LD_ADDR_EXP 15
26235: PUSH
26236: LD_INT 7
26238: ST_TO_ADDR
// uc_side = 1 ;
26239: LD_ADDR_OWVAR 20
26243: PUSH
26244: LD_INT 1
26246: ST_TO_ADDR
// uc_nation = 1 ;
26247: LD_ADDR_OWVAR 21
26251: PUSH
26252: LD_INT 1
26254: ST_TO_ADDR
// for i = 1 to 5 do
26255: LD_ADDR_VAR 0 1
26259: PUSH
26260: DOUBLE
26261: LD_INT 1
26263: DEC
26264: ST_TO_ADDR
26265: LD_INT 5
26267: PUSH
26268: FOR_TO
26269: IFFALSE 26365
// begin vc_engine = 3 ;
26271: LD_ADDR_OWVAR 39
26275: PUSH
26276: LD_INT 3
26278: ST_TO_ADDR
// vc_control = 3 ;
26279: LD_ADDR_OWVAR 38
26283: PUSH
26284: LD_INT 3
26286: ST_TO_ADDR
// vc_chassis = 3 ;
26287: LD_ADDR_OWVAR 37
26291: PUSH
26292: LD_INT 3
26294: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26295: LD_ADDR_OWVAR 40
26299: PUSH
26300: LD_INT 5
26302: PUSH
26303: LD_INT 9
26305: PUSH
26306: LD_INT 7
26308: PUSH
26309: EMPTY
26310: LIST
26311: LIST
26312: LIST
26313: PUSH
26314: LD_INT 1
26316: PPUSH
26317: LD_INT 3
26319: PPUSH
26320: CALL_OW 12
26324: ARRAY
26325: ST_TO_ADDR
// veh = CreateVehicle ;
26326: LD_ADDR_VAR 0 2
26330: PUSH
26331: CALL_OW 45
26335: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26336: LD_VAR 0 2
26340: PPUSH
26341: LD_INT 1
26343: PPUSH
26344: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26348: LD_VAR 0 2
26352: PPUSH
26353: LD_INT 19
26355: PPUSH
26356: LD_INT 0
26358: PPUSH
26359: CALL_OW 49
// end ;
26363: GO 26268
26365: POP
26366: POP
// vc_engine = 3 ;
26367: LD_ADDR_OWVAR 39
26371: PUSH
26372: LD_INT 3
26374: ST_TO_ADDR
// vc_control = 1 ;
26375: LD_ADDR_OWVAR 38
26379: PUSH
26380: LD_INT 1
26382: ST_TO_ADDR
// vc_chassis = 3 ;
26383: LD_ADDR_OWVAR 37
26387: PUSH
26388: LD_INT 3
26390: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26391: LD_ADDR_OWVAR 40
26395: PUSH
26396: LD_INT 5
26398: PUSH
26399: LD_INT 9
26401: PUSH
26402: LD_INT 7
26404: PUSH
26405: EMPTY
26406: LIST
26407: LIST
26408: LIST
26409: PUSH
26410: LD_INT 1
26412: PPUSH
26413: LD_INT 3
26415: PPUSH
26416: CALL_OW 12
26420: ARRAY
26421: ST_TO_ADDR
// vehG = CreateVehicle ;
26422: LD_ADDR_VAR 0 3
26426: PUSH
26427: CALL_OW 45
26431: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26432: LD_VAR 0 3
26436: PPUSH
26437: LD_INT 1
26439: PPUSH
26440: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26444: LD_VAR 0 3
26448: PPUSH
26449: LD_INT 19
26451: PPUSH
26452: LD_INT 0
26454: PPUSH
26455: CALL_OW 49
// if JMMGirl = 1 then
26459: LD_EXP 7
26463: PUSH
26464: LD_INT 1
26466: EQUAL
26467: IFFALSE 26523
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26469: LD_ADDR_EXP 40
26473: PUSH
26474: LD_STRING Joan
26476: PPUSH
26477: LD_INT 1
26479: PPUSH
26480: LD_STRING 14_
26482: PPUSH
26483: CALL 64980 0 3
26487: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26488: LD_EXP 40
26492: PPUSH
26493: LD_VAR 0 3
26497: PPUSH
26498: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26502: LD_VAR 0 3
26506: PPUSH
26507: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26511: LD_EXP 40
26515: PPUSH
26516: LD_STRING D10BW-Joan-1
26518: PPUSH
26519: CALL_OW 94
// end ; if JMMGirl = 2 then
26523: LD_EXP 7
26527: PUSH
26528: LD_INT 2
26530: EQUAL
26531: IFFALSE 26587
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26533: LD_ADDR_EXP 42
26537: PUSH
26538: LD_STRING Lisa
26540: PPUSH
26541: LD_INT 1
26543: PPUSH
26544: LD_STRING 14_
26546: PPUSH
26547: CALL 64980 0 3
26551: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26552: LD_EXP 42
26556: PPUSH
26557: LD_VAR 0 3
26561: PPUSH
26562: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26566: LD_VAR 0 3
26570: PPUSH
26571: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26575: LD_EXP 42
26579: PPUSH
26580: LD_STRING D10BW-Lisa-1
26582: PPUSH
26583: CALL_OW 94
// end ; if JMMGirl = 3 then
26587: LD_EXP 7
26591: PUSH
26592: LD_INT 3
26594: EQUAL
26595: IFFALSE 26651
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26597: LD_ADDR_EXP 54
26601: PUSH
26602: LD_STRING Connie
26604: PPUSH
26605: LD_INT 1
26607: PPUSH
26608: LD_STRING 14_
26610: PPUSH
26611: CALL 64980 0 3
26615: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26616: LD_EXP 54
26620: PPUSH
26621: LD_VAR 0 3
26625: PPUSH
26626: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26630: LD_VAR 0 3
26634: PPUSH
26635: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26639: LD_EXP 54
26643: PPUSH
26644: LD_STRING D10BW-Con-1
26646: PPUSH
26647: CALL_OW 94
// end ; end ;
26651: PPOPN 3
26653: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26654: LD_EXP 14
26658: PUSH
26659: LD_INT 94500
26661: GREATEREQUAL
26662: IFFALSE 27074
26664: GO 26666
26666: DISABLE
26667: LD_INT 0
26669: PPUSH
26670: PPUSH
26671: PPUSH
// begin tmp := PrepareStevensSquad ;
26672: LD_ADDR_VAR 0 3
26676: PUSH
26677: CALL 2197 0 0
26681: ST_TO_ADDR
// if not tmp then
26682: LD_VAR 0 3
26686: NOT
26687: IFFALSE 26691
// exit ;
26689: GO 27074
// uc_side := 1 ;
26691: LD_ADDR_OWVAR 20
26695: PUSH
26696: LD_INT 1
26698: ST_TO_ADDR
// uc_nation := 1 ;
26699: LD_ADDR_OWVAR 21
26703: PUSH
26704: LD_INT 1
26706: ST_TO_ADDR
// for i in tmp do
26707: LD_ADDR_VAR 0 1
26711: PUSH
26712: LD_VAR 0 3
26716: PUSH
26717: FOR_IN
26718: IFFALSE 26815
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26720: LD_INT 3
26722: PPUSH
26723: LD_INT 3
26725: PPUSH
26726: LD_INT 1
26728: PPUSH
26729: LD_INT 5
26731: PUSH
26732: LD_INT 9
26734: PUSH
26735: LD_INT 7
26737: PUSH
26738: EMPTY
26739: LIST
26740: LIST
26741: LIST
26742: PUSH
26743: LD_INT 1
26745: PPUSH
26746: LD_INT 3
26748: PPUSH
26749: CALL_OW 12
26753: ARRAY
26754: PPUSH
26755: LD_INT 40
26757: PPUSH
26758: CALL 69804 0 5
// veh := CreateVehicle ;
26762: LD_ADDR_VAR 0 2
26766: PUSH
26767: CALL_OW 45
26771: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26772: LD_VAR 0 2
26776: PPUSH
26777: LD_INT 1
26779: PPUSH
26780: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26784: LD_VAR 0 2
26788: PPUSH
26789: LD_INT 19
26791: PPUSH
26792: LD_INT 0
26794: PPUSH
26795: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26799: LD_VAR 0 1
26803: PPUSH
26804: LD_VAR 0 2
26808: PPUSH
26809: CALL_OW 52
// end ;
26813: GO 26717
26815: POP
26816: POP
// missionStage := 8 ;
26817: LD_ADDR_EXP 15
26821: PUSH
26822: LD_INT 8
26824: ST_TO_ADDR
// DialogueOn ;
26825: CALL_OW 6
// if Stevens then
26829: LD_EXP 41
26833: IFFALSE 26947
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26835: LD_EXP 41
26839: PPUSH
26840: CALL_OW 310
26844: PPUSH
26845: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26849: LD_EXP 41
26853: PPUSH
26854: LD_STRING D8-Huck-1
26856: PPUSH
26857: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26861: LD_EXP 39
26865: PPUSH
26866: LD_STRING D8-JMM-1
26868: PPUSH
26869: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26873: LD_EXP 41
26877: PPUSH
26878: LD_STRING D8-Huck-2
26880: PPUSH
26881: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26885: LD_EXP 39
26889: PPUSH
26890: LD_STRING D8-JMM-2
26892: PPUSH
26893: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26897: LD_EXP 41
26901: PPUSH
26902: LD_STRING D8-Huck-3
26904: PPUSH
26905: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26909: LD_EXP 39
26913: PPUSH
26914: LD_STRING D8-JMM-3
26916: PPUSH
26917: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26921: LD_EXP 41
26925: PPUSH
26926: LD_STRING D8-Huck-4
26928: PPUSH
26929: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26933: LD_EXP 39
26937: PPUSH
26938: LD_STRING D8-JMM-4
26940: PPUSH
26941: CALL_OW 88
// end else
26945: GO 27057
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26947: LD_EXP 55
26951: PPUSH
26952: CALL_OW 310
26956: PPUSH
26957: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26961: LD_EXP 55
26965: PPUSH
26966: LD_STRING D8-Huck-1
26968: PPUSH
26969: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26973: LD_EXP 39
26977: PPUSH
26978: LD_STRING D8-JMM-1a
26980: PPUSH
26981: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26985: LD_EXP 55
26989: PPUSH
26990: LD_STRING D8-Huck-2
26992: PPUSH
26993: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26997: LD_EXP 39
27001: PPUSH
27002: LD_STRING D8-JMM-2
27004: PPUSH
27005: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
27009: LD_EXP 55
27013: PPUSH
27014: LD_STRING D8-Huck-3
27016: PPUSH
27017: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27021: LD_EXP 39
27025: PPUSH
27026: LD_STRING D8-JMM-3
27028: PPUSH
27029: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27033: LD_EXP 55
27037: PPUSH
27038: LD_STRING D8-Huck-4
27040: PPUSH
27041: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27045: LD_EXP 39
27049: PPUSH
27050: LD_STRING D8-JMM-4
27052: PPUSH
27053: CALL_OW 88
// end ; DialogueOff ;
27057: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27061: LD_INT 25
27063: PPUSH
27064: LD_INT 1
27066: PPUSH
27067: LD_INT 1
27069: PPUSH
27070: CALL_OW 322
// end ;
27074: PPOPN 3
27076: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27077: LD_INT 1
27079: PPUSH
27080: LD_EXP 71
27084: PPUSH
27085: CALL_OW 292
27089: IFFALSE 27340
27091: GO 27093
27093: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27094: LD_EXP 71
27098: PPUSH
27099: CALL_OW 87
// DialogueOn ;
27103: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27107: LD_EXP 39
27111: PPUSH
27112: LD_STRING D10nB-JMM-1
27114: PPUSH
27115: CALL_OW 88
// if BurlakStatus = 1 then
27119: LD_EXP 9
27123: PUSH
27124: LD_INT 1
27126: EQUAL
27127: IFFALSE 27141
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27129: LD_EXP 70
27133: PPUSH
27134: LD_STRING D10nB-Vse-1a
27136: PPUSH
27137: CALL_OW 94
// end ; if BurlakStatus = 0 then
27141: LD_EXP 9
27145: PUSH
27146: LD_INT 0
27148: EQUAL
27149: IFFALSE 27163
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27151: LD_EXP 70
27155: PPUSH
27156: LD_STRING D10nB-Vse-1
27158: PPUSH
27159: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27163: LD_EXP 39
27167: PPUSH
27168: LD_STRING D10nB-JMM-2
27170: PPUSH
27171: CALL_OW 88
// if KappaStatus then
27175: LD_EXP 2
27179: IFFALSE 27193
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27181: LD_EXP 70
27185: PPUSH
27186: LD_STRING D10nB-Vse-5a
27188: PPUSH
27189: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27193: LD_EXP 2
27197: NOT
27198: PUSH
27199: LD_EXP 6
27203: PUSH
27204: LD_INT 0
27206: EQUAL
27207: AND
27208: IFFALSE 27336
// begin if JMMGirl = 1 then
27210: LD_EXP 7
27214: PUSH
27215: LD_INT 1
27217: EQUAL
27218: IFFALSE 27268
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27220: LD_EXP 70
27224: PPUSH
27225: LD_STRING D10nB-Vse-2
27227: PPUSH
27228: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27232: LD_EXP 39
27236: PPUSH
27237: LD_STRING D10nB-JMM-3
27239: PPUSH
27240: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27244: LD_EXP 70
27248: PPUSH
27249: LD_STRING D10nB-Vse-3
27251: PPUSH
27252: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27256: LD_EXP 39
27260: PPUSH
27261: LD_STRING D10nB-JMM-4
27263: PPUSH
27264: CALL_OW 88
// end ; if JMMGirl = 2 then
27268: LD_EXP 7
27272: PUSH
27273: LD_INT 2
27275: EQUAL
27276: IFFALSE 27302
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27278: LD_EXP 70
27282: PPUSH
27283: LD_STRING D10nB-Vse-4
27285: PPUSH
27286: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27290: LD_EXP 39
27294: PPUSH
27295: LD_STRING D10nB-JMM-5
27297: PPUSH
27298: CALL_OW 88
// end ; if JMMGirl = 3 then
27302: LD_EXP 7
27306: PUSH
27307: LD_INT 3
27309: EQUAL
27310: IFFALSE 27336
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27312: LD_EXP 70
27316: PPUSH
27317: LD_STRING D10nB-Vse-5
27319: PPUSH
27320: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27324: LD_EXP 39
27328: PPUSH
27329: LD_STRING D10nB-JMM-6
27331: PPUSH
27332: CALL_OW 88
// end ; end ; DialogueOff ;
27336: CALL_OW 7
// end ;
27340: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27341: LD_EXP 14
27345: PUSH
27346: LD_INT 115500
27348: GREATEREQUAL
27349: IFFALSE 27725
27351: GO 27353
27353: DISABLE
27354: LD_INT 0
27356: PPUSH
// begin missionStage := 10 ;
27357: LD_ADDR_EXP 15
27361: PUSH
27362: LD_INT 10
27364: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27365: LD_ADDR_VAR 0 1
27369: PUSH
27370: LD_INT 22
27372: PUSH
27373: LD_INT 1
27375: PUSH
27376: EMPTY
27377: LIST
27378: LIST
27379: PUSH
27380: LD_INT 23
27382: PUSH
27383: LD_INT 1
27385: PUSH
27386: EMPTY
27387: LIST
27388: LIST
27389: PUSH
27390: LD_INT 26
27392: PUSH
27393: LD_INT 1
27395: PUSH
27396: EMPTY
27397: LIST
27398: LIST
27399: PUSH
27400: LD_INT 3
27402: PUSH
27403: LD_INT 25
27405: PUSH
27406: LD_INT 12
27408: PUSH
27409: EMPTY
27410: LIST
27411: LIST
27412: PUSH
27413: EMPTY
27414: LIST
27415: LIST
27416: PUSH
27417: LD_INT 3
27419: PUSH
27420: LD_INT 25
27422: PUSH
27423: LD_INT 16
27425: PUSH
27426: EMPTY
27427: LIST
27428: LIST
27429: PUSH
27430: EMPTY
27431: LIST
27432: LIST
27433: PUSH
27434: EMPTY
27435: LIST
27436: LIST
27437: LIST
27438: LIST
27439: LIST
27440: PPUSH
27441: CALL_OW 69
27445: PUSH
27446: LD_EXP 39
27450: PUSH
27451: LD_EXP 60
27455: PUSH
27456: LD_EXP 41
27460: PUSH
27461: LD_EXP 55
27465: PUSH
27466: LD_EXP 42
27470: PUSH
27471: LD_EXP 43
27475: PUSH
27476: LD_EXP 44
27480: PUSH
27481: LD_EXP 45
27485: PUSH
27486: LD_EXP 46
27490: PUSH
27491: LD_EXP 47
27495: PUSH
27496: LD_EXP 48
27500: PUSH
27501: LD_EXP 49
27505: PUSH
27506: LD_EXP 50
27510: PUSH
27511: LD_EXP 51
27515: PUSH
27516: LD_EXP 52
27520: PUSH
27521: LD_EXP 53
27525: PUSH
27526: EMPTY
27527: LIST
27528: LIST
27529: LIST
27530: LIST
27531: LIST
27532: LIST
27533: LIST
27534: LIST
27535: LIST
27536: LIST
27537: LIST
27538: LIST
27539: LIST
27540: LIST
27541: LIST
27542: LIST
27543: DIFF
27544: ST_TO_ADDR
// if not tmp and Brown then
27545: LD_VAR 0 1
27549: NOT
27550: PUSH
27551: LD_EXP 47
27555: AND
27556: IFFALSE 27571
// tmp := [ Brown ] ;
27558: LD_ADDR_VAR 0 1
27562: PUSH
27563: LD_EXP 47
27567: PUSH
27568: EMPTY
27569: LIST
27570: ST_TO_ADDR
// DialogueOn ;
27571: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27575: LD_VAR 0 1
27579: PUSH
27580: LD_INT 1
27582: ARRAY
27583: PPUSH
27584: LD_STRING D11-Sol1-1
27586: PPUSH
27587: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27591: LD_EXP 64
27595: PPUSH
27596: LD_STRING D11-Pla-1
27598: PPUSH
27599: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27603: LD_EXP 65
27607: PPUSH
27608: LD_STRING D11-Kov-1
27610: PPUSH
27611: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27615: LD_EXP 64
27619: PPUSH
27620: LD_STRING D11-Pla-2
27622: PPUSH
27623: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27627: LD_VAR 0 1
27631: PUSH
27632: LD_INT 1
27634: ARRAY
27635: PPUSH
27636: LD_STRING D11-Sol1-2
27638: PPUSH
27639: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27643: LD_EXP 39
27647: PPUSH
27648: LD_STRING D11-JMM-2
27650: PPUSH
27651: CALL_OW 88
// DialogueOff ;
27655: CALL_OW 7
// allowBehemothConstruct := true ;
27659: LD_ADDR_EXP 25
27663: PUSH
27664: LD_INT 1
27666: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27667: LD_STRING M4
27669: PPUSH
27670: CALL_OW 337
// BuildBehemoths ;
27674: CALL 7653 0 0
// repeat wait ( 15 15$00 ) ;
27678: LD_INT 31500
27680: PPUSH
27681: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27685: LD_EXP 27
27689: IFFALSE 27693
// break ;
27691: GO 27725
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27693: LD_INT 267
27695: PPUSH
27696: CALL_OW 274
27700: PPUSH
27701: LD_INT 1
27703: PPUSH
27704: CALL_OW 275
27708: PUSH
27709: LD_INT 1000
27711: GREATEREQUAL
27712: IFFALSE 27718
// BuildBehemoths ;
27714: CALL 7653 0 0
// until not behemothBuilders ;
27718: LD_EXP 73
27722: NOT
27723: IFFALSE 27678
// end ;
27725: PPOPN 1
27727: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27728: LD_EXP 73
27732: NOT
27733: PUSH
27734: LD_EXP 28
27738: NOT
27739: AND
27740: PUSH
27741: LD_EXP 25
27745: AND
27746: IFFALSE 27766
27748: GO 27750
27750: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27751: LD_STRING M4a
27753: PPUSH
27754: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27758: LD_ADDR_EXP 27
27762: PUSH
27763: LD_INT 1
27765: ST_TO_ADDR
// end ;
27766: END
// every 0 0$1 trigger behemothDone do
27767: LD_EXP 28
27771: IFFALSE 27783
27773: GO 27775
27775: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27776: LD_STRING M4b
27778: PPUSH
27779: CALL_OW 337
27783: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27784: LD_EXP 29
27788: NOT
27789: IFFALSE 27985
27791: GO 27793
27793: DISABLE
27794: LD_INT 0
27796: PPUSH
27797: PPUSH
// begin enable ;
27798: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27799: LD_ADDR_VAR 0 1
27803: PUSH
27804: LD_INT 3
27806: PPUSH
27807: CALL 100898 0 1
27811: ST_TO_ADDR
// if not tmp and not behemothDone then
27812: LD_VAR 0 1
27816: NOT
27817: PUSH
27818: LD_EXP 28
27822: NOT
27823: AND
27824: IFFALSE 27860
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27826: LD_ADDR_VAR 0 1
27830: PUSH
27831: LD_INT 22
27833: PUSH
27834: LD_INT 3
27836: PUSH
27837: EMPTY
27838: LIST
27839: LIST
27840: PUSH
27841: LD_INT 30
27843: PUSH
27844: LD_INT 37
27846: PUSH
27847: EMPTY
27848: LIST
27849: LIST
27850: PUSH
27851: EMPTY
27852: LIST
27853: LIST
27854: PPUSH
27855: CALL_OW 69
27859: ST_TO_ADDR
// if not tmp then
27860: LD_VAR 0 1
27864: NOT
27865: IFFALSE 27869
// exit ;
27867: GO 27985
// for i in tmp do
27869: LD_ADDR_VAR 0 2
27873: PUSH
27874: LD_VAR 0 1
27878: PUSH
27879: FOR_IN
27880: IFFALSE 27983
// if See ( 1 , i ) then
27882: LD_INT 1
27884: PPUSH
27885: LD_VAR 0 2
27889: PPUSH
27890: CALL_OW 292
27894: IFFALSE 27981
// begin if GetType ( i ) = unit_building then
27896: LD_VAR 0 2
27900: PPUSH
27901: CALL_OW 247
27905: PUSH
27906: LD_INT 3
27908: EQUAL
27909: IFFALSE 27947
// begin CenterNowOnUnits ( i ) ;
27911: LD_VAR 0 2
27915: PPUSH
27916: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27920: LD_EXP 39
27924: PPUSH
27925: LD_STRING D17a-JMM-1
27927: PPUSH
27928: CALL_OW 88
// seeBehemoth := true ;
27932: LD_ADDR_EXP 29
27936: PUSH
27937: LD_INT 1
27939: ST_TO_ADDR
// disable ;
27940: DISABLE
// exit ;
27941: POP
27942: POP
27943: GO 27985
// end else
27945: GO 27981
// begin CenterNowOnUnits ( i ) ;
27947: LD_VAR 0 2
27951: PPUSH
27952: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27956: LD_EXP 39
27960: PPUSH
27961: LD_STRING D17b-JMM-1
27963: PPUSH
27964: CALL_OW 88
// seeBehemoth := true ;
27968: LD_ADDR_EXP 29
27972: PUSH
27973: LD_INT 1
27975: ST_TO_ADDR
// disable ;
27976: DISABLE
// exit ;
27977: POP
27978: POP
27979: GO 27985
// end ; end ;
27981: GO 27879
27983: POP
27984: POP
// end ;
27985: PPOPN 2
27987: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27988: LD_EXP 14
27992: PUSH
27993: LD_INT 116550
27995: GREATEREQUAL
27996: IFFALSE 29172
27998: GO 28000
28000: DISABLE
28001: LD_INT 0
28003: PPUSH
28004: PPUSH
28005: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
28006: LD_INT 2
28008: PPUSH
28009: LD_INT 23
28011: PUSH
28012: LD_INT 3
28014: PUSH
28015: LD_INT 3
28017: PUSH
28018: LD_INT 48
28020: PUSH
28021: EMPTY
28022: LIST
28023: LIST
28024: LIST
28025: LIST
28026: PUSH
28027: EMPTY
28028: LIST
28029: PPUSH
28030: CALL 58636 0 2
// repeat wait ( 0 0$1 ) ;
28034: LD_INT 35
28036: PPUSH
28037: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28041: LD_INT 22
28043: PUSH
28044: LD_INT 3
28046: PUSH
28047: EMPTY
28048: LIST
28049: LIST
28050: PUSH
28051: LD_INT 34
28053: PUSH
28054: LD_INT 48
28056: PUSH
28057: EMPTY
28058: LIST
28059: LIST
28060: PUSH
28061: EMPTY
28062: LIST
28063: LIST
28064: PPUSH
28065: CALL_OW 69
28069: IFFALSE 28034
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28071: LD_ADDR_VAR 0 1
28075: PUSH
28076: LD_INT 22
28078: PUSH
28079: LD_INT 3
28081: PUSH
28082: EMPTY
28083: LIST
28084: LIST
28085: PUSH
28086: LD_INT 34
28088: PUSH
28089: LD_INT 48
28091: PUSH
28092: EMPTY
28093: LIST
28094: LIST
28095: PUSH
28096: EMPTY
28097: LIST
28098: LIST
28099: PPUSH
28100: CALL_OW 69
28104: PUSH
28105: LD_INT 1
28107: ARRAY
28108: ST_TO_ADDR
// missionStage := 12 ;
28109: LD_ADDR_EXP 15
28113: PUSH
28114: LD_INT 12
28116: ST_TO_ADDR
// platonovHasBomb := true ;
28117: LD_ADDR_EXP 30
28121: PUSH
28122: LD_INT 1
28124: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28125: LD_VAR 0 1
28129: PPUSH
28130: LD_INT 181
28132: PPUSH
28133: LD_INT 86
28135: PPUSH
28136: CALL_OW 171
// AddComHold ( bomb ) ;
28140: LD_VAR 0 1
28144: PPUSH
28145: CALL_OW 200
// wait ( 0 0$10 ) ;
28149: LD_INT 350
28151: PPUSH
28152: CALL_OW 67
// DialogueOn ;
28156: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28160: LD_EXP 64
28164: PPUSH
28165: LD_STRING D15-Pla-1
28167: PPUSH
28168: CALL_OW 94
// dec = Query ( Q15a ) ;
28172: LD_ADDR_VAR 0 2
28176: PUSH
28177: LD_STRING Q15a
28179: PPUSH
28180: CALL_OW 97
28184: ST_TO_ADDR
// if dec = 1 then
28185: LD_VAR 0 2
28189: PUSH
28190: LD_INT 1
28192: EQUAL
28193: IFFALSE 28216
// begin Say ( JMM , D15a-JMM-1 ) ;
28195: LD_EXP 39
28199: PPUSH
28200: LD_STRING D15a-JMM-1
28202: PPUSH
28203: CALL_OW 88
// YouLost ( Surrender ) ;
28207: LD_STRING Surrender
28209: PPUSH
28210: CALL_OW 104
// exit ;
28214: GO 29172
// end ; if dec = 2 then
28216: LD_VAR 0 2
28220: PUSH
28221: LD_INT 2
28223: EQUAL
28224: IFFALSE 28293
// begin Say ( JMM , D15b-JMM-1 ) ;
28226: LD_EXP 39
28230: PPUSH
28231: LD_STRING D15b-JMM-1
28233: PPUSH
28234: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28238: LD_EXP 64
28242: PPUSH
28243: LD_STRING D15b-Pla-1
28245: PPUSH
28246: CALL_OW 94
// DialogueOff ;
28250: CALL_OW 7
// wait ( 3 3$00 ) ;
28254: LD_INT 6300
28256: PPUSH
28257: CALL_OW 67
// DialogueOn ;
28261: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28265: LD_EXP 39
28269: PPUSH
28270: LD_STRING D15d-JMM-1a
28272: PPUSH
28273: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28277: LD_EXP 64
28281: PPUSH
28282: LD_STRING D15d-Pla-1
28284: PPUSH
28285: CALL_OW 94
// DialogueOff ;
28289: CALL_OW 7
// end ; if dec = 3 then
28293: LD_VAR 0 2
28297: PUSH
28298: LD_INT 3
28300: EQUAL
28301: IFFALSE 28355
// begin Say ( JMM , D15c-JMM-1 ) ;
28303: LD_EXP 39
28307: PPUSH
28308: LD_STRING D15c-JMM-1
28310: PPUSH
28311: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28315: LD_EXP 64
28319: PPUSH
28320: LD_STRING D15c-Pla-1
28322: PPUSH
28323: CALL_OW 94
// DialogueOff ;
28327: CALL_OW 7
// wait ( 0 0$15 ) ;
28331: LD_INT 525
28333: PPUSH
28334: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28338: LD_VAR 0 1
28342: PPUSH
28343: LD_INT 60
28345: PPUSH
28346: LD_INT 95
28348: PPUSH
28349: CALL_OW 116
// exit ;
28353: GO 29172
// end ; if dec = 4 then
28355: LD_VAR 0 2
28359: PUSH
28360: LD_INT 4
28362: EQUAL
28363: IFFALSE 28393
// begin Say ( JMM , D15d-JMM-1 ) ;
28365: LD_EXP 39
28369: PPUSH
28370: LD_STRING D15d-JMM-1
28372: PPUSH
28373: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28377: LD_EXP 64
28381: PPUSH
28382: LD_STRING D15d-Pla-1
28384: PPUSH
28385: CALL_OW 94
// DialogueOff ;
28389: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28393: LD_EXP 62
28397: PPUSH
28398: CALL_OW 302
28402: PUSH
28403: LD_EXP 62
28407: PPUSH
28408: CALL_OW 255
28412: PUSH
28413: LD_INT 1
28415: EQUAL
28416: AND
28417: PUSH
28418: LD_INT 22
28420: PUSH
28421: LD_INT 1
28423: PUSH
28424: EMPTY
28425: LIST
28426: LIST
28427: PUSH
28428: LD_INT 34
28430: PUSH
28431: LD_INT 8
28433: PUSH
28434: EMPTY
28435: LIST
28436: LIST
28437: PUSH
28438: EMPTY
28439: LIST
28440: LIST
28441: PPUSH
28442: CALL_OW 69
28446: NOT
28447: AND
28448: IFFALSE 29073
// begin SetSide ( Friend , 8 ) ;
28450: LD_EXP 62
28454: PPUSH
28455: LD_INT 8
28457: PPUSH
28458: CALL_OW 235
// if IsInUnit ( Friend ) then
28462: LD_EXP 62
28466: PPUSH
28467: CALL_OW 310
28471: IFFALSE 28482
// ComExitBuilding ( Friend ) ;
28473: LD_EXP 62
28477: PPUSH
28478: CALL_OW 122
// if IsDriver ( Friend ) then
28482: LD_EXP 62
28486: PPUSH
28487: CALL 98575 0 1
28491: IFFALSE 28502
// ComExitVehicle ( Friend ) ;
28493: LD_EXP 62
28497: PPUSH
28498: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28502: LD_EXP 62
28506: PPUSH
28507: LD_INT 9
28509: PPUSH
28510: LD_INT 2
28512: PPUSH
28513: CALL_OW 171
// wait ( 0 0$05 ) ;
28517: LD_INT 175
28519: PPUSH
28520: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28524: LD_EXP 62
28528: PPUSH
28529: CALL_OW 87
// DialogueOn ;
28533: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28537: LD_EXP 39
28541: PPUSH
28542: LD_STRING D16-JMM-1
28544: PPUSH
28545: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28549: LD_EXP 62
28553: PPUSH
28554: LD_STRING D16-Friend-1
28556: PPUSH
28557: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28561: LD_EXP 39
28565: PPUSH
28566: LD_STRING D16-JMM-2
28568: PPUSH
28569: CALL_OW 88
// DialogueOff ;
28573: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28577: LD_EXP 62
28581: PPUSH
28582: LD_INT 1
28584: PPUSH
28585: CALL_OW 235
// ComHold ( Friend ) ;
28589: LD_EXP 62
28593: PPUSH
28594: CALL_OW 140
// wait ( 0 0$20 ) ;
28598: LD_INT 700
28600: PPUSH
28601: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28605: LD_EXP 62
28609: PPUSH
28610: LD_INT 9
28612: PPUSH
28613: LD_INT 2
28615: PPUSH
28616: CALL_OW 297
28620: PUSH
28621: LD_INT 30
28623: LESS
28624: IFFALSE 28693
// begin SetSide ( Friend , 8 ) ;
28626: LD_EXP 62
28630: PPUSH
28631: LD_INT 8
28633: PPUSH
28634: CALL_OW 235
// if IsInUnit ( Friend ) then
28638: LD_EXP 62
28642: PPUSH
28643: CALL_OW 310
28647: IFFALSE 28658
// ComExitBuilding ( Friend ) ;
28649: LD_EXP 62
28653: PPUSH
28654: CALL_OW 122
// if IsDriver ( Friend ) then
28658: LD_EXP 62
28662: PPUSH
28663: CALL 98575 0 1
28667: IFFALSE 28678
// ComExitVehicle ( Friend ) ;
28669: LD_EXP 62
28673: PPUSH
28674: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28678: LD_EXP 62
28682: PPUSH
28683: LD_INT 9
28685: PPUSH
28686: LD_INT 2
28688: PPUSH
28689: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28693: LD_INT 1050
28695: PPUSH
28696: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28700: LD_INT 22
28702: PUSH
28703: LD_INT 1
28705: PUSH
28706: EMPTY
28707: LIST
28708: LIST
28709: PUSH
28710: LD_INT 34
28712: PUSH
28713: LD_INT 8
28715: PUSH
28716: EMPTY
28717: LIST
28718: LIST
28719: PUSH
28720: EMPTY
28721: LIST
28722: LIST
28723: PPUSH
28724: CALL_OW 69
28728: NOT
28729: IFFALSE 29051
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28731: LD_ADDR_VAR 0 3
28735: PUSH
28736: LD_INT 22
28738: PUSH
28739: LD_INT 1
28741: PUSH
28742: EMPTY
28743: LIST
28744: LIST
28745: PUSH
28746: LD_INT 26
28748: PUSH
28749: LD_INT 1
28751: PUSH
28752: EMPTY
28753: LIST
28754: LIST
28755: PUSH
28756: LD_INT 3
28758: PUSH
28759: LD_INT 25
28761: PUSH
28762: LD_INT 12
28764: PUSH
28765: EMPTY
28766: LIST
28767: LIST
28768: PUSH
28769: LD_INT 25
28771: PUSH
28772: LD_INT 16
28774: PUSH
28775: EMPTY
28776: LIST
28777: LIST
28778: PUSH
28779: EMPTY
28780: LIST
28781: LIST
28782: LIST
28783: PUSH
28784: EMPTY
28785: LIST
28786: LIST
28787: LIST
28788: PPUSH
28789: CALL_OW 69
28793: PUSH
28794: LD_EXP 39
28798: PUSH
28799: LD_EXP 41
28803: PUSH
28804: LD_EXP 55
28808: PUSH
28809: LD_EXP 42
28813: PUSH
28814: LD_EXP 43
28818: PUSH
28819: LD_EXP 44
28823: PUSH
28824: LD_EXP 45
28828: PUSH
28829: LD_EXP 46
28833: PUSH
28834: LD_EXP 47
28838: PUSH
28839: LD_EXP 48
28843: PUSH
28844: LD_EXP 49
28848: PUSH
28849: LD_EXP 50
28853: PUSH
28854: LD_EXP 51
28858: PUSH
28859: LD_EXP 52
28863: PUSH
28864: LD_EXP 53
28868: PUSH
28869: EMPTY
28870: LIST
28871: LIST
28872: LIST
28873: LIST
28874: LIST
28875: LIST
28876: LIST
28877: LIST
28878: LIST
28879: LIST
28880: LIST
28881: LIST
28882: LIST
28883: LIST
28884: LIST
28885: DIFF
28886: ST_TO_ADDR
// DialogueOn ;
28887: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28891: LD_EXP 64
28895: PPUSH
28896: LD_STRING D16a-Pla-1
28898: PPUSH
28899: CALL_OW 94
// if Stevens then
28903: LD_EXP 41
28907: IFFALSE 28923
// Say ( Stevens , D16a-Huck-1 ) else
28909: LD_EXP 41
28913: PPUSH
28914: LD_STRING D16a-Huck-1
28916: PPUSH
28917: CALL_OW 88
28921: GO 28965
// if Baker then
28923: LD_EXP 55
28927: IFFALSE 28943
// Say ( Baker , D16a-Huck-1 ) else
28929: LD_EXP 55
28933: PPUSH
28934: LD_STRING D16a-Huck-1
28936: PPUSH
28937: CALL_OW 88
28941: GO 28965
// if tmp then
28943: LD_VAR 0 3
28947: IFFALSE 28965
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28949: LD_VAR 0 3
28953: PUSH
28954: LD_INT 1
28956: ARRAY
28957: PPUSH
28958: LD_STRING D16a-Sol1-1
28960: PPUSH
28961: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28965: LD_EXP 62
28969: PPUSH
28970: CALL_OW 255
28974: PUSH
28975: LD_INT 8
28977: EQUAL
28978: IFFALSE 28994
// Say ( JMM , D16a-JMM-1 ) else
28980: LD_EXP 39
28984: PPUSH
28985: LD_STRING D16a-JMM-1
28987: PPUSH
28988: CALL_OW 88
28992: GO 29030
// begin Say ( JMM , D16a-JMM-1a ) ;
28994: LD_EXP 39
28998: PPUSH
28999: LD_STRING D16a-JMM-1a
29001: PPUSH
29002: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
29006: LD_EXP 62
29010: PPUSH
29011: LD_STRING D16a-Friend-1
29013: PPUSH
29014: CALL_OW 88
// SetSide ( Friend , 3 ) ;
29018: LD_EXP 62
29022: PPUSH
29023: LD_INT 3
29025: PPUSH
29026: CALL_OW 235
// end ; DialogueOff ;
29030: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29034: LD_VAR 0 1
29038: PPUSH
29039: LD_INT 60
29041: PPUSH
29042: LD_INT 95
29044: PPUSH
29045: CALL_OW 116
// end else
29049: GO 29071
// begin DialogueOn ;
29051: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29055: LD_EXP 64
29059: PPUSH
29060: LD_STRING D16c-Pla-
29062: PPUSH
29063: CALL_OW 94
// DialogueOff ;
29067: CALL_OW 7
// end ; end else
29071: GO 29172
// begin wait ( 3 3$00 ) ;
29073: LD_INT 6300
29075: PPUSH
29076: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29080: LD_INT 22
29082: PUSH
29083: LD_INT 1
29085: PUSH
29086: EMPTY
29087: LIST
29088: LIST
29089: PUSH
29090: LD_INT 34
29092: PUSH
29093: LD_INT 8
29095: PUSH
29096: EMPTY
29097: LIST
29098: LIST
29099: PUSH
29100: EMPTY
29101: LIST
29102: LIST
29103: PPUSH
29104: CALL_OW 69
29108: NOT
29109: IFFALSE 29152
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29111: LD_EXP 64
29115: PPUSH
29116: LD_STRING D16b-Pla-1
29118: PPUSH
29119: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29123: LD_EXP 39
29127: PPUSH
29128: LD_STRING D16b-JMM-
29130: PPUSH
29131: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29135: LD_VAR 0 1
29139: PPUSH
29140: LD_INT 60
29142: PPUSH
29143: LD_INT 95
29145: PPUSH
29146: CALL_OW 116
// end else
29150: GO 29172
// begin DialogueOn ;
29152: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29156: LD_EXP 64
29160: PPUSH
29161: LD_STRING D16c-Pla-
29163: PPUSH
29164: CALL_OW 94
// DialogueOff ;
29168: CALL_OW 7
// end ; end ; end ;
29172: PPOPN 3
29174: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29175: LD_EXP 14
29179: PUSH
29180: LD_INT 126000
29182: GREATEREQUAL
29183: PUSH
29184: LD_EXP 23
29188: NOT
29189: AND
29190: PUSH
29191: LD_EXP 74
29195: PPUSH
29196: CALL_OW 302
29200: AND
29201: IFFALSE 29559
29203: GO 29205
29205: DISABLE
29206: LD_INT 0
29208: PPUSH
// begin missionStage = 11 ;
29209: LD_ADDR_EXP 15
29213: PUSH
29214: LD_INT 11
29216: ST_TO_ADDR
// DialogueOn ;
29217: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29221: LD_EXP 74
29225: PPUSH
29226: LD_STRING D9-Roth-1
29228: PPUSH
29229: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29233: LD_EXP 39
29237: PPUSH
29238: LD_STRING D9-JMM-1
29240: PPUSH
29241: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29245: LD_EXP 74
29249: PPUSH
29250: LD_STRING D9-Roth-2
29252: PPUSH
29253: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29257: LD_EXP 74
29261: PPUSH
29262: LD_STRING D9-Roth-2a
29264: PPUSH
29265: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29269: LD_EXP 64
29273: PPUSH
29274: LD_STRING D9-Pla-2
29276: PPUSH
29277: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29281: LD_EXP 74
29285: PPUSH
29286: LD_STRING D9-Roth-3
29288: PPUSH
29289: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29293: LD_EXP 64
29297: PPUSH
29298: LD_STRING D9-Pla-3
29300: PPUSH
29301: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29305: LD_EXP 74
29309: PPUSH
29310: LD_STRING D9-Roth-4
29312: PPUSH
29313: CALL_OW 94
// dec = Query ( Q9 ) ;
29317: LD_ADDR_VAR 0 1
29321: PUSH
29322: LD_STRING Q9
29324: PPUSH
29325: CALL_OW 97
29329: ST_TO_ADDR
// if dec = 1 then
29330: LD_VAR 0 1
29334: PUSH
29335: LD_INT 1
29337: EQUAL
29338: IFFALSE 29352
// SayRadio ( Roth , D9a-Roth-1 ) ;
29340: LD_EXP 74
29344: PPUSH
29345: LD_STRING D9a-Roth-1
29347: PPUSH
29348: CALL_OW 94
// if dec = 2 then
29352: LD_VAR 0 1
29356: PUSH
29357: LD_INT 2
29359: EQUAL
29360: IFFALSE 29386
// begin Say ( JMM , D9b-JMM-1 ) ;
29362: LD_EXP 39
29366: PPUSH
29367: LD_STRING D9b-JMM-1
29369: PPUSH
29370: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29374: LD_EXP 74
29378: PPUSH
29379: LD_STRING D9b-Roth-1
29381: PPUSH
29382: CALL_OW 94
// end ; if dec = 3 then
29386: LD_VAR 0 1
29390: PUSH
29391: LD_INT 3
29393: EQUAL
29394: IFFALSE 29456
// begin Say ( JMM , D9c-JMM-1 ) ;
29396: LD_EXP 39
29400: PPUSH
29401: LD_STRING D9c-JMM-1
29403: PPUSH
29404: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29408: LD_EXP 74
29412: PPUSH
29413: LD_STRING D9c-Roth-1
29415: PPUSH
29416: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29420: LD_EXP 39
29424: PPUSH
29425: LD_STRING D9c-JMM-2
29427: PPUSH
29428: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29432: LD_EXP 74
29436: PPUSH
29437: LD_STRING D9c-Roth-2
29439: PPUSH
29440: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29444: LD_EXP 39
29448: PPUSH
29449: LD_STRING D9c-JMM-3
29451: PPUSH
29452: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29456: LD_EXP 74
29460: PPUSH
29461: LD_STRING D9c-Roth-3
29463: PPUSH
29464: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29468: LD_EXP 74
29472: PPUSH
29473: LD_STRING D9cont-Roth-1
29475: PPUSH
29476: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29480: LD_EXP 39
29484: PPUSH
29485: LD_STRING D9cont-JMM-1
29487: PPUSH
29488: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29492: LD_EXP 74
29496: PPUSH
29497: LD_STRING D9cont-Roth-2
29499: PPUSH
29500: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29504: LD_EXP 39
29508: PPUSH
29509: LD_STRING D9cont-JMM-2
29511: PPUSH
29512: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29516: LD_EXP 74
29520: PPUSH
29521: LD_STRING D9cont-Roth-3
29523: PPUSH
29524: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29528: LD_EXP 39
29532: PPUSH
29533: LD_STRING D9cont-JMM-3
29535: PPUSH
29536: CALL_OW 88
// DialogueOff ;
29540: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29544: LD_STRING M3
29546: PPUSH
29547: CALL_OW 337
// allianceActive := true ;
29551: LD_ADDR_EXP 31
29555: PUSH
29556: LD_INT 1
29558: ST_TO_ADDR
// end ;
29559: PPOPN 1
29561: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29562: LD_EXP 64
29566: PPUSH
29567: CALL_OW 301
29571: PUSH
29572: LD_EXP 67
29576: PPUSH
29577: CALL_OW 301
29581: AND
29582: PUSH
29583: LD_INT 22
29585: PUSH
29586: LD_INT 3
29588: PUSH
29589: EMPTY
29590: LIST
29591: LIST
29592: PUSH
29593: LD_INT 21
29595: PUSH
29596: LD_INT 1
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: PUSH
29603: LD_INT 50
29605: PUSH
29606: EMPTY
29607: LIST
29608: PUSH
29609: EMPTY
29610: LIST
29611: LIST
29612: LIST
29613: PPUSH
29614: CALL_OW 69
29618: PUSH
29619: LD_INT 7
29621: PUSH
29622: LD_INT 8
29624: PUSH
29625: LD_INT 9
29627: PUSH
29628: EMPTY
29629: LIST
29630: LIST
29631: LIST
29632: PUSH
29633: LD_OWVAR 67
29637: ARRAY
29638: LESS
29639: AND
29640: IFFALSE 30411
29642: GO 29644
29644: DISABLE
29645: LD_INT 0
29647: PPUSH
29648: PPUSH
29649: PPUSH
29650: PPUSH
// begin MC_Kill ( 1 ) ;
29651: LD_INT 1
29653: PPUSH
29654: CALL 35176 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29658: LD_INT 1
29660: PPUSH
29661: LD_INT 3
29663: PPUSH
29664: LD_INT 1
29666: PPUSH
29667: LD_INT 1
29669: PPUSH
29670: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29674: LD_ADDR_VAR 0 1
29678: PUSH
29679: LD_INT 22
29681: PUSH
29682: LD_INT 3
29684: PUSH
29685: EMPTY
29686: LIST
29687: LIST
29688: PUSH
29689: LD_INT 21
29691: PUSH
29692: LD_INT 1
29694: PUSH
29695: EMPTY
29696: LIST
29697: LIST
29698: PUSH
29699: LD_INT 24
29701: PUSH
29702: LD_INT 900
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: PUSH
29709: EMPTY
29710: LIST
29711: LIST
29712: LIST
29713: PPUSH
29714: CALL_OW 69
29718: PUSH
29719: FOR_IN
29720: IFFALSE 29751
// if GetSex ( i ) = sex_male then
29722: LD_VAR 0 1
29726: PPUSH
29727: CALL_OW 258
29731: PUSH
29732: LD_INT 1
29734: EQUAL
29735: IFFALSE 29749
// begin tmp = i ;
29737: LD_ADDR_VAR 0 2
29741: PUSH
29742: LD_VAR 0 1
29746: ST_TO_ADDR
// break ;
29747: GO 29751
// end ;
29749: GO 29719
29751: POP
29752: POP
// if tmp = 0 then
29753: LD_VAR 0 2
29757: PUSH
29758: LD_INT 0
29760: EQUAL
29761: IFFALSE 29815
// begin uc_side = 3 ;
29763: LD_ADDR_OWVAR 20
29767: PUSH
29768: LD_INT 3
29770: ST_TO_ADDR
// uc_nation = 3 ;
29771: LD_ADDR_OWVAR 21
29775: PUSH
29776: LD_INT 3
29778: ST_TO_ADDR
// hc_name =  ;
29779: LD_ADDR_OWVAR 26
29783: PUSH
29784: LD_STRING 
29786: ST_TO_ADDR
// hc_gallery =  ;
29787: LD_ADDR_OWVAR 33
29791: PUSH
29792: LD_STRING 
29794: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29795: LD_INT 1
29797: PPUSH
29798: LD_INT 10
29800: PPUSH
29801: CALL_OW 381
// tmp = CreateHuman ;
29805: LD_ADDR_VAR 0 2
29809: PUSH
29810: CALL_OW 44
29814: ST_TO_ADDR
// end ; DialogueOn ;
29815: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29819: LD_VAR 0 2
29823: PPUSH
29824: LD_STRING DSurrenderRussians-RSol1-1a
29826: PPUSH
29827: CALL_OW 94
// DialogueOff ;
29831: CALL_OW 7
// russianDestroyed := true ;
29835: LD_ADDR_EXP 21
29839: PUSH
29840: LD_INT 1
29842: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29843: LD_INT 22
29845: PUSH
29846: LD_INT 3
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: PUSH
29853: LD_INT 21
29855: PUSH
29856: LD_INT 1
29858: PUSH
29859: EMPTY
29860: LIST
29861: LIST
29862: PUSH
29863: EMPTY
29864: LIST
29865: LIST
29866: PPUSH
29867: CALL_OW 69
29871: PPUSH
29872: CALL_OW 122
// wait ( 0 0$1 ) ;
29876: LD_INT 35
29878: PPUSH
29879: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
29883: LD_INT 22
29885: PUSH
29886: LD_INT 3
29888: PUSH
29889: EMPTY
29890: LIST
29891: LIST
29892: PUSH
29893: LD_INT 21
29895: PUSH
29896: LD_INT 1
29898: PUSH
29899: EMPTY
29900: LIST
29901: LIST
29902: PUSH
29903: EMPTY
29904: LIST
29905: LIST
29906: PPUSH
29907: CALL_OW 69
29911: PPUSH
29912: LD_INT 25
29914: PPUSH
29915: CALL_OW 173
// wait ( 0 0$10 ) ;
29919: LD_INT 350
29921: PPUSH
29922: CALL_OW 67
// PrepareOmarInvasion ;
29926: CALL 13863 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
29930: LD_ADDR_VAR 0 2
29934: PUSH
29935: LD_EXP 92
29939: PPUSH
29940: CALL_OW 250
29944: PUSH
29945: LD_EXP 92
29949: PPUSH
29950: CALL_OW 251
29954: PUSH
29955: EMPTY
29956: LIST
29957: LIST
29958: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
29959: LD_VAR 0 2
29963: PUSH
29964: LD_INT 1
29966: ARRAY
29967: PPUSH
29968: LD_VAR 0 2
29972: PUSH
29973: LD_INT 2
29975: ARRAY
29976: PPUSH
29977: LD_INT 1
29979: PPUSH
29980: LD_INT 8
29982: NEG
29983: PPUSH
29984: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29988: LD_EXP 92
29992: PPUSH
29993: CALL_OW 87
// DialogueOn ;
29997: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
30001: LD_EXP 39
30005: PPUSH
30006: LD_STRING D19-JMM-1
30008: PPUSH
30009: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
30013: LD_ADDR_VAR 0 3
30017: PUSH
30018: LD_INT 22
30020: PUSH
30021: LD_INT 1
30023: PUSH
30024: EMPTY
30025: LIST
30026: LIST
30027: PUSH
30028: LD_INT 26
30030: PUSH
30031: LD_INT 1
30033: PUSH
30034: EMPTY
30035: LIST
30036: LIST
30037: PUSH
30038: LD_INT 2
30040: PUSH
30041: LD_INT 25
30043: PUSH
30044: LD_INT 1
30046: PUSH
30047: EMPTY
30048: LIST
30049: LIST
30050: PUSH
30051: LD_INT 25
30053: PUSH
30054: LD_INT 2
30056: PUSH
30057: EMPTY
30058: LIST
30059: LIST
30060: PUSH
30061: LD_INT 25
30063: PUSH
30064: LD_INT 3
30066: PUSH
30067: EMPTY
30068: LIST
30069: LIST
30070: PUSH
30071: LD_INT 25
30073: PUSH
30074: LD_INT 4
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: PUSH
30081: LD_INT 25
30083: PUSH
30084: LD_INT 5
30086: PUSH
30087: EMPTY
30088: LIST
30089: LIST
30090: PUSH
30091: LD_INT 25
30093: PUSH
30094: LD_INT 8
30096: PUSH
30097: EMPTY
30098: LIST
30099: LIST
30100: PUSH
30101: EMPTY
30102: LIST
30103: LIST
30104: LIST
30105: LIST
30106: LIST
30107: LIST
30108: LIST
30109: PUSH
30110: EMPTY
30111: LIST
30112: LIST
30113: LIST
30114: PPUSH
30115: CALL_OW 69
30119: PUSH
30120: LD_EXP 39
30124: PUSH
30125: LD_EXP 40
30129: PUSH
30130: LD_EXP 41
30134: PUSH
30135: LD_EXP 42
30139: PUSH
30140: LD_EXP 43
30144: PUSH
30145: LD_EXP 44
30149: PUSH
30150: LD_EXP 45
30154: PUSH
30155: LD_EXP 46
30159: PUSH
30160: LD_EXP 47
30164: PUSH
30165: LD_EXP 48
30169: PUSH
30170: LD_EXP 49
30174: PUSH
30175: LD_EXP 50
30179: PUSH
30180: LD_EXP 51
30184: PUSH
30185: LD_EXP 52
30189: PUSH
30190: LD_EXP 53
30194: PUSH
30195: LD_EXP 54
30199: PUSH
30200: LD_EXP 55
30204: PUSH
30205: EMPTY
30206: LIST
30207: LIST
30208: LIST
30209: LIST
30210: LIST
30211: LIST
30212: LIST
30213: LIST
30214: LIST
30215: LIST
30216: LIST
30217: LIST
30218: LIST
30219: LIST
30220: LIST
30221: LIST
30222: LIST
30223: DIFF
30224: ST_TO_ADDR
// if tmp2 then
30225: LD_VAR 0 3
30229: IFFALSE 30247
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30231: LD_VAR 0 3
30235: PUSH
30236: LD_INT 1
30238: ARRAY
30239: PPUSH
30240: LD_STRING D19-Sol1-1
30242: PPUSH
30243: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30247: LD_EXP 39
30251: PPUSH
30252: LD_STRING D19-JMM-2
30254: PPUSH
30255: CALL_OW 88
// DialogueOff ;
30259: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30263: LD_VAR 0 2
30267: PUSH
30268: LD_INT 1
30270: ARRAY
30271: PPUSH
30272: LD_VAR 0 2
30276: PUSH
30277: LD_INT 2
30279: ARRAY
30280: PPUSH
30281: LD_INT 1
30283: PPUSH
30284: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30288: LD_STRING M5
30290: PPUSH
30291: CALL_OW 337
// omarOnMotherLode := false ;
30295: LD_ADDR_VAR 0 4
30299: PUSH
30300: LD_INT 0
30302: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30303: LD_INT 35
30305: PPUSH
30306: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30310: LD_EXP 92
30314: PPUSH
30315: LD_INT 215
30317: PPUSH
30318: LD_INT 100
30320: PPUSH
30321: CALL_OW 297
30325: PUSH
30326: LD_INT 10
30328: LESS
30329: PUSH
30330: LD_VAR 0 4
30334: NOT
30335: AND
30336: IFFALSE 30370
// begin omarOnMotherLode := true ;
30338: LD_ADDR_VAR 0 4
30342: PUSH
30343: LD_INT 1
30345: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30346: LD_EXP 39
30350: PPUSH
30351: LD_STRING D19b-JMM-1
30353: PPUSH
30354: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30358: LD_EXP 92
30362: PPUSH
30363: LD_STRING DOmarContam-Omar-1
30365: PPUSH
30366: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30370: LD_EXP 92
30374: PPUSH
30375: CALL_OW 301
30379: IFFALSE 30303
// Say ( JMM , D19a-JMM-1 ) ;
30381: LD_EXP 39
30385: PPUSH
30386: LD_STRING D19a-JMM-1
30388: PPUSH
30389: CALL_OW 88
// if Heike then
30393: LD_EXP 93
30397: IFFALSE 30411
// Say ( Heike , D19a-Hke-1 ) ;
30399: LD_EXP 93
30403: PPUSH
30404: LD_STRING D19a-Hke-1
30406: PPUSH
30407: CALL_OW 88
// end ;
30411: PPOPN 4
30413: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30414: LD_INT 22
30416: PUSH
30417: LD_INT 3
30419: PUSH
30420: EMPTY
30421: LIST
30422: LIST
30423: PUSH
30424: LD_INT 21
30426: PUSH
30427: LD_INT 1
30429: PUSH
30430: EMPTY
30431: LIST
30432: LIST
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: PPUSH
30438: CALL_OW 69
30442: PUSH
30443: LD_EXP 21
30447: AND
30448: IFFALSE 30516
30450: GO 30452
30452: DISABLE
30453: LD_INT 0
30455: PPUSH
30456: PPUSH
// begin enable ;
30457: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30458: LD_ADDR_VAR 0 2
30462: PUSH
30463: LD_INT 25
30465: PPUSH
30466: LD_INT 22
30468: PUSH
30469: LD_INT 3
30471: PUSH
30472: EMPTY
30473: LIST
30474: LIST
30475: PPUSH
30476: CALL_OW 70
30480: ST_TO_ADDR
// if not tmp then
30481: LD_VAR 0 2
30485: NOT
30486: IFFALSE 30490
// exit ;
30488: GO 30516
// for i in tmp do
30490: LD_ADDR_VAR 0 1
30494: PUSH
30495: LD_VAR 0 2
30499: PUSH
30500: FOR_IN
30501: IFFALSE 30514
// RemoveUnit ( i ) ;
30503: LD_VAR 0 1
30507: PPUSH
30508: CALL_OW 64
30512: GO 30500
30514: POP
30515: POP
// end ;
30516: PPOPN 2
30518: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30519: LD_INT 22
30521: PUSH
30522: LD_INT 7
30524: PUSH
30525: EMPTY
30526: LIST
30527: LIST
30528: PUSH
30529: LD_INT 21
30531: PUSH
30532: LD_INT 1
30534: PUSH
30535: EMPTY
30536: LIST
30537: LIST
30538: PUSH
30539: EMPTY
30540: LIST
30541: LIST
30542: PPUSH
30543: CALL_OW 69
30547: PUSH
30548: LD_INT 6
30550: LESS
30551: IFFALSE 31019
30553: GO 30555
30555: DISABLE
30556: LD_INT 0
30558: PPUSH
30559: PPUSH
// begin MC_Kill ( 1 ) ;
30560: LD_INT 1
30562: PPUSH
30563: CALL 35176 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30567: LD_INT 7
30569: PPUSH
30570: LD_INT 1
30572: PPUSH
30573: LD_INT 1
30575: PPUSH
30576: LD_INT 1
30578: PPUSH
30579: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30583: LD_ADDR_VAR 0 1
30587: PUSH
30588: LD_INT 22
30590: PUSH
30591: LD_INT 7
30593: PUSH
30594: EMPTY
30595: LIST
30596: LIST
30597: PUSH
30598: LD_INT 26
30600: PUSH
30601: LD_INT 1
30603: PUSH
30604: EMPTY
30605: LIST
30606: LIST
30607: PUSH
30608: EMPTY
30609: LIST
30610: LIST
30611: PPUSH
30612: CALL_OW 69
30616: PUSH
30617: LD_EXP 74
30621: DIFF
30622: ST_TO_ADDR
// if tmp then
30623: LD_VAR 0 1
30627: IFFALSE 30645
// tmp := tmp [ 1 ] else
30629: LD_ADDR_VAR 0 1
30633: PUSH
30634: LD_VAR 0 1
30638: PUSH
30639: LD_INT 1
30641: ARRAY
30642: ST_TO_ADDR
30643: GO 30681
// begin uc_side := 7 ;
30645: LD_ADDR_OWVAR 20
30649: PUSH
30650: LD_INT 7
30652: ST_TO_ADDR
// uc_nation := 1 ;
30653: LD_ADDR_OWVAR 21
30657: PUSH
30658: LD_INT 1
30660: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30661: LD_INT 1
30663: PPUSH
30664: LD_INT 8
30666: PPUSH
30667: CALL_OW 384
// tmp := CreateHuman ;
30671: LD_ADDR_VAR 0 1
30675: PUSH
30676: CALL_OW 44
30680: ST_TO_ADDR
// end ; DialogueOn ;
30681: CALL_OW 6
// if IsOK ( Roth ) then
30685: LD_EXP 74
30689: PPUSH
30690: CALL_OW 302
30694: IFFALSE 30708
// Say ( JMM , DAb-JMM-1 ) ;
30696: LD_EXP 39
30700: PPUSH
30701: LD_STRING DAb-JMM-1
30703: PPUSH
30704: CALL_OW 88
// if IsOK ( Roth ) then
30708: LD_EXP 74
30712: PPUSH
30713: CALL_OW 302
30717: IFFALSE 30741
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30719: LD_EXP 74
30723: PPUSH
30724: LD_STRING DSurrenderAlliance-Roth-1
30726: PPUSH
30727: CALL_OW 88
// RothCaptured := true ;
30731: LD_ADDR_EXP 33
30735: PUSH
30736: LD_INT 1
30738: ST_TO_ADDR
// end else
30739: GO 30753
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30741: LD_VAR 0 1
30745: PPUSH
30746: LD_STRING DSurrenderAlliance-Sci1-1
30748: PPUSH
30749: CALL_OW 88
// DialogueOff ;
30753: CALL_OW 7
// allianceDestroyed := true ;
30757: LD_ADDR_EXP 23
30761: PUSH
30762: LD_INT 1
30764: ST_TO_ADDR
// if capturedUnit = 0 then
30765: LD_EXP 34
30769: PUSH
30770: LD_INT 0
30772: EQUAL
30773: IFFALSE 30782
// SetAchievement ( ACH_ALLIANCE ) ;
30775: LD_STRING ACH_ALLIANCE
30777: PPUSH
30778: CALL_OW 543
// if trueAmericans then
30782: LD_EXP 35
30786: IFFALSE 30862
// begin if trueAmericans = 1 then
30788: LD_EXP 35
30792: PUSH
30793: LD_INT 1
30795: EQUAL
30796: IFFALSE 30812
// Say ( JMM , DAb-JMM-1a ) else
30798: LD_EXP 39
30802: PPUSH
30803: LD_STRING DAb-JMM-1a
30805: PPUSH
30806: CALL_OW 88
30810: GO 30824
// Say ( JMM , DAb-JMM-1b ) ;
30812: LD_EXP 39
30816: PPUSH
30817: LD_STRING DAb-JMM-1b
30819: PPUSH
30820: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30824: LD_EXP 35
30828: PPUSH
30829: CALL_OW 87
// for i in trueAmericans do
30833: LD_ADDR_VAR 0 2
30837: PUSH
30838: LD_EXP 35
30842: PUSH
30843: FOR_IN
30844: IFFALSE 30860
// SetSide ( i , 1 ) ;
30846: LD_VAR 0 2
30850: PPUSH
30851: LD_INT 1
30853: PPUSH
30854: CALL_OW 235
30858: GO 30843
30860: POP
30861: POP
// end ; repeat wait ( 0 0$1 ) ;
30862: LD_INT 35
30864: PPUSH
30865: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
30869: LD_ADDR_VAR 0 2
30873: PUSH
30874: LD_INT 22
30876: PUSH
30877: LD_INT 7
30879: PUSH
30880: EMPTY
30881: LIST
30882: LIST
30883: PUSH
30884: LD_INT 21
30886: PUSH
30887: LD_INT 1
30889: PUSH
30890: EMPTY
30891: LIST
30892: LIST
30893: PUSH
30894: EMPTY
30895: LIST
30896: LIST
30897: PPUSH
30898: CALL_OW 69
30902: PUSH
30903: FOR_IN
30904: IFFALSE 30986
// begin if IsInUnit ( i ) then
30906: LD_VAR 0 2
30910: PPUSH
30911: CALL_OW 310
30915: IFFALSE 30926
// ComExitBuilding ( i ) ;
30917: LD_VAR 0 2
30921: PPUSH
30922: CALL_OW 122
// if IsDriver ( i ) then
30926: LD_VAR 0 2
30930: PPUSH
30931: CALL 98575 0 1
30935: IFFALSE 30946
// ComExitVehicle ( i ) ;
30937: LD_VAR 0 2
30941: PPUSH
30942: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
30946: LD_VAR 0 2
30950: PPUSH
30951: LD_INT 26
30953: PPUSH
30954: CALL_OW 308
30958: NOT
30959: IFFALSE 30975
// AddComMoveToArea ( i , allianceEscapeArea ) else
30961: LD_VAR 0 2
30965: PPUSH
30966: LD_INT 26
30968: PPUSH
30969: CALL_OW 173
30973: GO 30984
// RemoveUnit ( i ) ;
30975: LD_VAR 0 2
30979: PPUSH
30980: CALL_OW 64
// end ;
30984: GO 30903
30986: POP
30987: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
30988: LD_INT 22
30990: PUSH
30991: LD_INT 7
30993: PUSH
30994: EMPTY
30995: LIST
30996: LIST
30997: PUSH
30998: LD_INT 21
31000: PUSH
31001: LD_INT 1
31003: PUSH
31004: EMPTY
31005: LIST
31006: LIST
31007: PUSH
31008: EMPTY
31009: LIST
31010: LIST
31011: PPUSH
31012: CALL_OW 69
31016: NOT
31017: IFFALSE 30862
// end ;
31019: PPOPN 2
31021: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31022: LD_INT 0
31024: PPUSH
31025: PPUSH
// if not unit then
31026: LD_VAR 0 1
31030: NOT
31031: IFFALSE 31035
// exit ;
31033: GO 32533
// DoNotAttack ( 7 , unit ) ;
31035: LD_INT 7
31037: PPUSH
31038: LD_VAR 0 1
31042: PPUSH
31043: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31047: LD_VAR 0 1
31051: PPUSH
31052: LD_INT 260
31054: PPUSH
31055: LD_INT 235
31057: PPUSH
31058: LD_INT 3
31060: PPUSH
31061: LD_INT 1
31063: PPUSH
31064: CALL_OW 483
// SetSide ( unit , 4 ) ;
31068: LD_VAR 0 1
31072: PPUSH
31073: LD_INT 4
31075: PPUSH
31076: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31080: LD_ADDR_EXP 34
31084: PUSH
31085: LD_EXP 34
31089: PUSH
31090: LD_INT 1
31092: PLUS
31093: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31094: LD_INT 70
31096: PPUSH
31097: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31101: LD_INT 260
31103: PPUSH
31104: LD_INT 235
31106: PPUSH
31107: LD_INT 1
31109: PPUSH
31110: LD_INT 8
31112: NEG
31113: PPUSH
31114: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31118: LD_VAR 0 1
31122: PPUSH
31123: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31127: LD_VAR 0 1
31131: PPUSH
31132: LD_EXP 74
31136: PPUSH
31137: CALL_OW 119
// DialogueOn ;
31141: CALL_OW 6
// case unit of JMM :
31145: LD_VAR 0 1
31149: PUSH
31150: LD_EXP 39
31154: DOUBLE
31155: EQUAL
31156: IFTRUE 31160
31158: GO 31175
31160: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31161: LD_EXP 39
31165: PPUSH
31166: LD_STRING DA1-JMM-1
31168: PPUSH
31169: CALL_OW 91
31173: GO 31617
31175: LD_EXP 40
31179: DOUBLE
31180: EQUAL
31181: IFTRUE 31185
31183: GO 31200
31185: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31186: LD_EXP 40
31190: PPUSH
31191: LD_STRING DA1-Joan-1
31193: PPUSH
31194: CALL_OW 91
31198: GO 31617
31200: LD_EXP 42
31204: DOUBLE
31205: EQUAL
31206: IFTRUE 31210
31208: GO 31225
31210: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31211: LD_EXP 42
31215: PPUSH
31216: LD_STRING DA1-Lisa-1
31218: PPUSH
31219: CALL_OW 91
31223: GO 31617
31225: LD_EXP 43
31229: DOUBLE
31230: EQUAL
31231: IFTRUE 31235
31233: GO 31250
31235: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31236: LD_EXP 43
31240: PPUSH
31241: LD_STRING DA1-Don-1
31243: PPUSH
31244: CALL_OW 91
31248: GO 31617
31250: LD_EXP 50
31254: DOUBLE
31255: EQUAL
31256: IFTRUE 31260
31258: GO 31275
31260: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31261: LD_EXP 50
31265: PPUSH
31266: LD_STRING DA1-Corn-1
31268: PPUSH
31269: CALL_OW 91
31273: GO 31617
31275: LD_EXP 46
31279: DOUBLE
31280: EQUAL
31281: IFTRUE 31285
31283: GO 31300
31285: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31286: LD_EXP 46
31290: PPUSH
31291: LD_STRING DA1-Den-1
31293: PPUSH
31294: CALL_OW 91
31298: GO 31617
31300: LD_EXP 44
31304: DOUBLE
31305: EQUAL
31306: IFTRUE 31310
31308: GO 31325
31310: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31311: LD_EXP 44
31315: PPUSH
31316: LD_STRING DA1-Bobby-1
31318: PPUSH
31319: CALL_OW 91
31323: GO 31617
31325: LD_EXP 48
31329: DOUBLE
31330: EQUAL
31331: IFTRUE 31335
31333: GO 31350
31335: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31336: LD_EXP 48
31340: PPUSH
31341: LD_STRING DA1-Glad-1
31343: PPUSH
31344: CALL_OW 91
31348: GO 31617
31350: LD_EXP 45
31354: DOUBLE
31355: EQUAL
31356: IFTRUE 31360
31358: GO 31375
31360: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31361: LD_EXP 45
31365: PPUSH
31366: LD_STRING DA1-Cyrus-1
31368: PPUSH
31369: CALL_OW 91
31373: GO 31617
31375: LD_EXP 41
31379: DOUBLE
31380: EQUAL
31381: IFTRUE 31385
31383: GO 31400
31385: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31386: LD_EXP 41
31390: PPUSH
31391: LD_STRING DA1-Huck-1
31393: PPUSH
31394: CALL_OW 91
31398: GO 31617
31400: LD_EXP 55
31404: DOUBLE
31405: EQUAL
31406: IFTRUE 31410
31408: GO 31425
31410: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31411: LD_EXP 55
31415: PPUSH
31416: LD_STRING DA1-Huck-1
31418: PPUSH
31419: CALL_OW 91
31423: GO 31617
31425: LD_EXP 47
31429: DOUBLE
31430: EQUAL
31431: IFTRUE 31435
31433: GO 31450
31435: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31436: LD_EXP 47
31440: PPUSH
31441: LD_STRING DA1-Brown-1
31443: PPUSH
31444: CALL_OW 91
31448: GO 31617
31450: LD_EXP 51
31454: DOUBLE
31455: EQUAL
31456: IFTRUE 31460
31458: GO 31475
31460: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31461: LD_EXP 51
31465: PPUSH
31466: LD_STRING DA1-Gary-1
31468: PPUSH
31469: CALL_OW 91
31473: GO 31617
31475: LD_EXP 54
31479: DOUBLE
31480: EQUAL
31481: IFTRUE 31485
31483: GO 31500
31485: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31486: LD_EXP 54
31490: PPUSH
31491: LD_STRING DA1-Con-1
31493: PPUSH
31494: CALL_OW 91
31498: GO 31617
31500: LD_EXP 60
31504: DOUBLE
31505: EQUAL
31506: IFTRUE 31510
31508: GO 31525
31510: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31511: LD_EXP 60
31515: PPUSH
31516: LD_STRING DA1-Kurt-1
31518: PPUSH
31519: CALL_OW 91
31523: GO 31617
31525: LD_EXP 53
31529: DOUBLE
31530: EQUAL
31531: IFTRUE 31535
31533: GO 31550
31535: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31536: LD_EXP 53
31540: PPUSH
31541: LD_STRING DA1-Yam-1
31543: PPUSH
31544: CALL_OW 91
31548: GO 31617
31550: LD_EXP 52
31554: DOUBLE
31555: EQUAL
31556: IFTRUE 31560
31558: GO 31575
31560: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31561: LD_EXP 52
31565: PPUSH
31566: LD_STRING DA1-Frank-1
31568: PPUSH
31569: CALL_OW 91
31573: GO 31617
31575: POP
// begin if GetSex ( unit ) = sex_male then
31576: LD_VAR 0 1
31580: PPUSH
31581: CALL_OW 258
31585: PUSH
31586: LD_INT 1
31588: EQUAL
31589: IFFALSE 31605
// ForceSay ( unit , DA1-Sol1-1 ) else
31591: LD_VAR 0 1
31595: PPUSH
31596: LD_STRING DA1-Sol1-1
31598: PPUSH
31599: CALL_OW 91
31603: GO 31617
// ForceSay ( unit , DA1-FSol1-1 ) ;
31605: LD_VAR 0 1
31609: PPUSH
31610: LD_STRING DA1-FSol1-1
31612: PPUSH
31613: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31617: LD_EXP 74
31621: PPUSH
31622: LD_STRING DA-Roth-1
31624: PPUSH
31625: CALL_OW 88
// if capturedUnit = 1 then
31629: LD_EXP 34
31633: PUSH
31634: LD_INT 1
31636: EQUAL
31637: IFFALSE 31665
// begin Say ( Simms , DA-Sim-1 ) ;
31639: LD_EXP 75
31643: PPUSH
31644: LD_STRING DA-Sim-1
31646: PPUSH
31647: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31651: LD_EXP 74
31655: PPUSH
31656: LD_STRING DA-Roth-2
31658: PPUSH
31659: CALL_OW 88
// end else
31663: GO 31677
// Say ( Simms , DA-Sim-2 ) ;
31665: LD_EXP 75
31669: PPUSH
31670: LD_STRING DA-Sim-2
31672: PPUSH
31673: CALL_OW 88
// case unit of JMM :
31677: LD_VAR 0 1
31681: PUSH
31682: LD_EXP 39
31686: DOUBLE
31687: EQUAL
31688: IFTRUE 31692
31690: GO 31707
31692: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31693: LD_EXP 39
31697: PPUSH
31698: LD_STRING DA1-JMM-1a
31700: PPUSH
31701: CALL_OW 91
31705: GO 32214
31707: LD_EXP 40
31711: DOUBLE
31712: EQUAL
31713: IFTRUE 31717
31715: GO 31732
31717: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31718: LD_EXP 40
31722: PPUSH
31723: LD_STRING DA1-Joan-1a
31725: PPUSH
31726: CALL_OW 91
31730: GO 32214
31732: LD_EXP 42
31736: DOUBLE
31737: EQUAL
31738: IFTRUE 31742
31740: GO 31757
31742: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31743: LD_EXP 42
31747: PPUSH
31748: LD_STRING DA1-Lisa-1a
31750: PPUSH
31751: CALL_OW 91
31755: GO 32214
31757: LD_EXP 43
31761: DOUBLE
31762: EQUAL
31763: IFTRUE 31767
31765: GO 31782
31767: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31768: LD_EXP 43
31772: PPUSH
31773: LD_STRING DA1-Don-1a
31775: PPUSH
31776: CALL_OW 91
31780: GO 32214
31782: LD_EXP 50
31786: DOUBLE
31787: EQUAL
31788: IFTRUE 31792
31790: GO 31807
31792: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31793: LD_EXP 50
31797: PPUSH
31798: LD_STRING DA1-Corn-1a
31800: PPUSH
31801: CALL_OW 91
31805: GO 32214
31807: LD_EXP 46
31811: DOUBLE
31812: EQUAL
31813: IFTRUE 31817
31815: GO 31832
31817: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31818: LD_EXP 46
31822: PPUSH
31823: LD_STRING DA1-Den-1a
31825: PPUSH
31826: CALL_OW 91
31830: GO 32214
31832: LD_EXP 44
31836: DOUBLE
31837: EQUAL
31838: IFTRUE 31842
31840: GO 31857
31842: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31843: LD_EXP 44
31847: PPUSH
31848: LD_STRING DA1-Bobby-1a
31850: PPUSH
31851: CALL_OW 91
31855: GO 32214
31857: LD_EXP 48
31861: DOUBLE
31862: EQUAL
31863: IFTRUE 31867
31865: GO 31882
31867: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
31868: LD_EXP 48
31872: PPUSH
31873: LD_STRING DA1-Glad-1a
31875: PPUSH
31876: CALL_OW 91
31880: GO 32214
31882: LD_EXP 45
31886: DOUBLE
31887: EQUAL
31888: IFTRUE 31892
31890: GO 31907
31892: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
31893: LD_EXP 45
31897: PPUSH
31898: LD_STRING DA1-Cyrus-1a
31900: PPUSH
31901: CALL_OW 91
31905: GO 32214
31907: LD_EXP 41
31911: DOUBLE
31912: EQUAL
31913: IFTRUE 31917
31915: GO 31932
31917: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
31918: LD_EXP 41
31922: PPUSH
31923: LD_STRING DA1-Huck-1a
31925: PPUSH
31926: CALL_OW 91
31930: GO 32214
31932: LD_EXP 55
31936: DOUBLE
31937: EQUAL
31938: IFTRUE 31942
31940: GO 31957
31942: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
31943: LD_EXP 55
31947: PPUSH
31948: LD_STRING DA1-Huck-1a
31950: PPUSH
31951: CALL_OW 91
31955: GO 32214
31957: LD_EXP 47
31961: DOUBLE
31962: EQUAL
31963: IFTRUE 31967
31965: GO 31982
31967: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
31968: LD_EXP 47
31972: PPUSH
31973: LD_STRING DA1-Brown-1a
31975: PPUSH
31976: CALL_OW 91
31980: GO 32214
31982: LD_EXP 51
31986: DOUBLE
31987: EQUAL
31988: IFTRUE 31992
31990: GO 32007
31992: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31993: LD_EXP 51
31997: PPUSH
31998: LD_STRING DA1-Gary-1a
32000: PPUSH
32001: CALL_OW 91
32005: GO 32214
32007: LD_EXP 54
32011: DOUBLE
32012: EQUAL
32013: IFTRUE 32017
32015: GO 32032
32017: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
32018: LD_EXP 54
32022: PPUSH
32023: LD_STRING DA1-Con-1a
32025: PPUSH
32026: CALL_OW 91
32030: GO 32214
32032: LD_EXP 60
32036: DOUBLE
32037: EQUAL
32038: IFTRUE 32042
32040: GO 32057
32042: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32043: LD_EXP 60
32047: PPUSH
32048: LD_STRING DA1-Kurt-1a
32050: PPUSH
32051: CALL_OW 91
32055: GO 32214
32057: LD_EXP 53
32061: DOUBLE
32062: EQUAL
32063: IFTRUE 32067
32065: GO 32082
32067: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32068: LD_EXP 53
32072: PPUSH
32073: LD_STRING DA1-Yam-1a
32075: PPUSH
32076: CALL_OW 91
32080: GO 32214
32082: LD_EXP 52
32086: DOUBLE
32087: EQUAL
32088: IFTRUE 32092
32090: GO 32107
32092: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32093: LD_EXP 52
32097: PPUSH
32098: LD_STRING DA1-Frank-1a
32100: PPUSH
32101: CALL_OW 91
32105: GO 32214
32107: POP
// begin join := rand ( 0 , 1 ) ;
32108: LD_ADDR_VAR 0 3
32112: PUSH
32113: LD_INT 0
32115: PPUSH
32116: LD_INT 1
32118: PPUSH
32119: CALL_OW 12
32123: ST_TO_ADDR
// if join then
32124: LD_VAR 0 3
32128: IFFALSE 32173
// begin if GetSex ( unit ) = sex_male then
32130: LD_VAR 0 1
32134: PPUSH
32135: CALL_OW 258
32139: PUSH
32140: LD_INT 1
32142: EQUAL
32143: IFFALSE 32159
// ForceSay ( unit , DA1-Sol1-1b ) else
32145: LD_VAR 0 1
32149: PPUSH
32150: LD_STRING DA1-Sol1-1b
32152: PPUSH
32153: CALL_OW 91
32157: GO 32171
// ForceSay ( unit , DA1-FSol1-1b ) ;
32159: LD_VAR 0 1
32163: PPUSH
32164: LD_STRING DA1-FSol1-1b
32166: PPUSH
32167: CALL_OW 91
// end else
32171: GO 32214
// begin if GetSex ( unit ) = sex_male then
32173: LD_VAR 0 1
32177: PPUSH
32178: CALL_OW 258
32182: PUSH
32183: LD_INT 1
32185: EQUAL
32186: IFFALSE 32202
// ForceSay ( unit , DA1-Sol1-1a ) else
32188: LD_VAR 0 1
32192: PPUSH
32193: LD_STRING DA1-Sol1-1a
32195: PPUSH
32196: CALL_OW 91
32200: GO 32214
// ForceSay ( unit , DA1-FSol1-1a ) ;
32202: LD_VAR 0 1
32206: PPUSH
32207: LD_STRING DA1-FSol1-1a
32209: PPUSH
32210: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32214: LD_VAR 0 1
32218: PUSH
32219: LD_EXP 39
32223: EQUAL
32224: IFFALSE 32235
// begin YouLost ( JMMCaptured ) ;
32226: LD_STRING JMMCaptured
32228: PPUSH
32229: CALL_OW 104
// exit ;
32233: GO 32533
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32235: LD_VAR 0 1
32239: PUSH
32240: LD_EXP 43
32244: PUSH
32245: LD_EXP 46
32249: PUSH
32250: LD_EXP 44
32254: PUSH
32255: LD_EXP 41
32259: PUSH
32260: LD_EXP 55
32264: PUSH
32265: LD_EXP 47
32269: PUSH
32270: LD_EXP 53
32274: PUSH
32275: EMPTY
32276: LIST
32277: LIST
32278: LIST
32279: LIST
32280: LIST
32281: LIST
32282: LIST
32283: IN
32284: PUSH
32285: LD_VAR 0 3
32289: OR
32290: IFFALSE 32389
// begin Say ( Roth , DA-Roth-3 ) ;
32292: LD_EXP 74
32296: PPUSH
32297: LD_STRING DA-Roth-3
32299: PPUSH
32300: CALL_OW 88
// SetSide ( unit , 7 ) ;
32304: LD_VAR 0 1
32308: PPUSH
32309: LD_INT 7
32311: PPUSH
32312: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32316: LD_ADDR_EXP 110
32320: PUSH
32321: LD_EXP 110
32325: PPUSH
32326: LD_INT 1
32328: PPUSH
32329: LD_EXP 110
32333: PUSH
32334: LD_INT 1
32336: ARRAY
32337: PUSH
32338: LD_VAR 0 1
32342: ADD
32343: PPUSH
32344: CALL_OW 1
32348: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32349: LD_INT 260
32351: PPUSH
32352: LD_INT 235
32354: PPUSH
32355: LD_INT 1
32357: PPUSH
32358: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32362: LD_VAR 0 1
32366: PPUSH
32367: LD_INT 1000
32369: PPUSH
32370: CALL_OW 234
// DialogueOff ;
32374: CALL_OW 7
// ComFree ( unit ) ;
32378: LD_VAR 0 1
32382: PPUSH
32383: CALL_OW 139
// end else
32387: GO 32470
// begin Say ( Roth , DA-Roth-3a ) ;
32389: LD_EXP 74
32393: PPUSH
32394: LD_STRING DA-Roth-3a
32396: PPUSH
32397: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32401: LD_ADDR_EXP 35
32405: PUSH
32406: LD_EXP 35
32410: PUSH
32411: LD_VAR 0 1
32415: ADD
32416: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32417: LD_INT 260
32419: PPUSH
32420: LD_INT 235
32422: PPUSH
32423: LD_INT 1
32425: PPUSH
32426: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32430: LD_VAR 0 1
32434: PPUSH
32435: LD_INT 1000
32437: PPUSH
32438: CALL_OW 234
// DialogueOff ;
32442: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32446: LD_VAR 0 1
32450: PPUSH
32451: LD_INT 272
32453: PPUSH
32454: LD_INT 254
32456: PPUSH
32457: CALL_OW 111
// AddComHold ( unit ) ;
32461: LD_VAR 0 1
32465: PPUSH
32466: CALL_OW 200
// end ; if capturedUnit = 1 then
32470: LD_EXP 34
32474: PUSH
32475: LD_INT 1
32477: EQUAL
32478: IFFALSE 32533
// begin DialogueOn ;
32480: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32484: LD_EXP 39
32488: PPUSH
32489: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32493: LD_EXP 39
32497: PPUSH
32498: LD_STRING DAa-JMM-1
32500: PPUSH
32501: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32505: LD_EXP 39
32509: PPUSH
32510: LD_STRING DAa-JMM-1a
32512: PPUSH
32513: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32517: LD_EXP 39
32521: PPUSH
32522: LD_STRING DAa-JMM-1b
32524: PPUSH
32525: CALL_OW 88
// DialogueOff ;
32529: CALL_OW 7
// end ; end ;
32533: LD_VAR 0 2
32537: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32538: LD_EXP 15
32542: PUSH
32543: LD_INT 13
32545: GREATEREQUAL
32546: PUSH
32547: LD_INT 22
32549: PUSH
32550: LD_INT 2
32552: PUSH
32553: EMPTY
32554: LIST
32555: LIST
32556: PUSH
32557: LD_INT 21
32559: PUSH
32560: LD_INT 1
32562: PUSH
32563: EMPTY
32564: LIST
32565: LIST
32566: PUSH
32567: EMPTY
32568: LIST
32569: LIST
32570: PPUSH
32571: CALL_OW 69
32575: PUSH
32576: LD_INT 0
32578: EQUAL
32579: AND
32580: PUSH
32581: LD_INT 22
32583: PUSH
32584: LD_INT 2
32586: PUSH
32587: EMPTY
32588: LIST
32589: LIST
32590: PUSH
32591: LD_INT 21
32593: PUSH
32594: LD_INT 2
32596: PUSH
32597: EMPTY
32598: LIST
32599: LIST
32600: PUSH
32601: LD_INT 50
32603: PUSH
32604: EMPTY
32605: LIST
32606: PUSH
32607: EMPTY
32608: LIST
32609: LIST
32610: LIST
32611: PPUSH
32612: CALL_OW 69
32616: PUSH
32617: LD_INT 0
32619: EQUAL
32620: AND
32621: PUSH
32622: LD_EXP 21
32626: AND
32627: PUSH
32628: LD_EXP 22
32632: AND
32633: PUSH
32634: LD_EXP 23
32638: AND
32639: IFFALSE 33281
32641: GO 32643
32643: DISABLE
32644: LD_INT 0
32646: PPUSH
32647: PPUSH
32648: PPUSH
// begin m1 := false ;
32649: LD_ADDR_VAR 0 1
32653: PUSH
32654: LD_INT 0
32656: ST_TO_ADDR
// m2 := false ;
32657: LD_ADDR_VAR 0 2
32661: PUSH
32662: LD_INT 0
32664: ST_TO_ADDR
// m3 := false ;
32665: LD_ADDR_VAR 0 3
32669: PUSH
32670: LD_INT 0
32672: ST_TO_ADDR
// if not bombExploded then
32673: LD_EXP 37
32677: NOT
32678: IFFALSE 32687
// SetAchievement ( ACH_SIBROCKET ) ;
32680: LD_STRING ACH_SIBROCKET
32682: PPUSH
32683: CALL_OW 543
// if tick <= 120 120$00 then
32687: LD_OWVAR 1
32691: PUSH
32692: LD_INT 252000
32694: LESSEQUAL
32695: IFFALSE 32711
// begin wait ( 3 ) ;
32697: LD_INT 3
32699: PPUSH
32700: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32704: LD_STRING ACH_ASPEED_15
32706: PPUSH
32707: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32711: LD_EXP 39
32715: PPUSH
32716: CALL_OW 87
// music_class := 5 ;
32720: LD_ADDR_OWVAR 72
32724: PUSH
32725: LD_INT 5
32727: ST_TO_ADDR
// music_nat := 5 ;
32728: LD_ADDR_OWVAR 71
32732: PUSH
32733: LD_INT 5
32735: ST_TO_ADDR
// DialogueOn ;
32736: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32740: LD_EXP 39
32744: PPUSH
32745: LD_STRING D20-JMM-1
32747: PPUSH
32748: CALL_OW 88
// if IsOK ( Joan ) then
32752: LD_EXP 40
32756: PPUSH
32757: CALL_OW 302
32761: IFFALSE 32775
// Say ( Joan , D20-Joan-1 ) ;
32763: LD_EXP 40
32767: PPUSH
32768: LD_STRING D20-Joan-1
32770: PPUSH
32771: CALL_OW 88
// if IsOk ( Lisa ) then
32775: LD_EXP 42
32779: PPUSH
32780: CALL_OW 302
32784: IFFALSE 32798
// Say ( Lisa , D20-Lisa-1 ) ;
32786: LD_EXP 42
32790: PPUSH
32791: LD_STRING D20-Lisa-1
32793: PPUSH
32794: CALL_OW 88
// if IsOk ( Donaldson ) then
32798: LD_EXP 43
32802: PPUSH
32803: CALL_OW 302
32807: IFFALSE 32821
// Say ( Donaldson , D20-Don-1 ) ;
32809: LD_EXP 43
32813: PPUSH
32814: LD_STRING D20-Don-1
32816: PPUSH
32817: CALL_OW 88
// if IsOK ( Cornel ) then
32821: LD_EXP 50
32825: PPUSH
32826: CALL_OW 302
32830: IFFALSE 32844
// Say ( Cornel , D20-Corn-1 ) ;
32832: LD_EXP 50
32836: PPUSH
32837: LD_STRING D20-Corn-1
32839: PPUSH
32840: CALL_OW 88
// if IsOk ( Denis ) then
32844: LD_EXP 46
32848: PPUSH
32849: CALL_OW 302
32853: IFFALSE 32867
// Say ( Denis , D20-Den-1 ) ;
32855: LD_EXP 46
32859: PPUSH
32860: LD_STRING D20-Den-1
32862: PPUSH
32863: CALL_OW 88
// if IsOk ( Bobby ) then
32867: LD_EXP 44
32871: PPUSH
32872: CALL_OW 302
32876: IFFALSE 32890
// Say ( Bobby , D20-Bobby-1 ) ;
32878: LD_EXP 44
32882: PPUSH
32883: LD_STRING D20-Bobby-1
32885: PPUSH
32886: CALL_OW 88
// if IsOk ( Gladstone ) then
32890: LD_EXP 48
32894: PPUSH
32895: CALL_OW 302
32899: IFFALSE 32913
// Say ( Gladstone , D20-Glad-1 ) ;
32901: LD_EXP 48
32905: PPUSH
32906: LD_STRING D20-Glad-1
32908: PPUSH
32909: CALL_OW 88
// if IsOk ( Cyrus ) then
32913: LD_EXP 45
32917: PPUSH
32918: CALL_OW 302
32922: IFFALSE 32936
// Say ( Cyrus , D20-Cyrus-1 ) ;
32924: LD_EXP 45
32928: PPUSH
32929: LD_STRING D20-Cyrus-1
32931: PPUSH
32932: CALL_OW 88
// if IsOk ( Stevens ) then
32936: LD_EXP 41
32940: PPUSH
32941: CALL_OW 302
32945: IFFALSE 32959
// Say ( Stevens , D20-Huck-1 ) ;
32947: LD_EXP 41
32951: PPUSH
32952: LD_STRING D20-Huck-1
32954: PPUSH
32955: CALL_OW 88
// if IsOk ( Brown ) then
32959: LD_EXP 47
32963: PPUSH
32964: CALL_OW 302
32968: IFFALSE 32982
// Say ( Brown , D20-Brown-1 ) ;
32970: LD_EXP 47
32974: PPUSH
32975: LD_STRING D20-Brown-1
32977: PPUSH
32978: CALL_OW 88
// if IsOk ( Gary ) then
32982: LD_EXP 51
32986: PPUSH
32987: CALL_OW 302
32991: IFFALSE 33005
// Say ( Gary , D20-Gary-1 ) ;
32993: LD_EXP 51
32997: PPUSH
32998: LD_STRING D20-Gary-1
33000: PPUSH
33001: CALL_OW 88
// if IsOk ( Connie ) then
33005: LD_EXP 54
33009: PPUSH
33010: CALL_OW 302
33014: IFFALSE 33028
// Say ( Connie , D20-Con-1 ) ;
33016: LD_EXP 54
33020: PPUSH
33021: LD_STRING D20-Con-1
33023: PPUSH
33024: CALL_OW 88
// if IsOk ( Kurt ) then
33028: LD_EXP 60
33032: PPUSH
33033: CALL_OW 302
33037: IFFALSE 33051
// Say ( Kurt , D20-Kurt-1 ) ;
33039: LD_EXP 60
33043: PPUSH
33044: LD_STRING D20-Kurt-1
33046: PPUSH
33047: CALL_OW 88
// if IsOk ( Kikuchi ) then
33051: LD_EXP 53
33055: PPUSH
33056: CALL_OW 302
33060: IFFALSE 33074
// Say ( Kikuchi , D20-Yam-1 ) ;
33062: LD_EXP 53
33066: PPUSH
33067: LD_STRING D20-Yam-1
33069: PPUSH
33070: CALL_OW 88
// if IsOk ( Frank ) then
33074: LD_EXP 52
33078: PPUSH
33079: CALL_OW 302
33083: IFFALSE 33097
// Say ( Frank , D20-Frank-1 ) ;
33085: LD_EXP 52
33089: PPUSH
33090: LD_STRING D20-Frank-1
33092: PPUSH
33093: CALL_OW 88
// DialogueOff ;
33097: CALL_OW 7
// if RothCaptured then
33101: LD_EXP 33
33105: IFFALSE 33127
// begin m1 := true ;
33107: LD_ADDR_VAR 0 1
33111: PUSH
33112: LD_INT 1
33114: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33115: LD_STRING Roth
33117: PPUSH
33118: LD_INT 1
33120: PPUSH
33121: CALL_OW 101
// end else
33125: GO 33138
// AddMedal ( Roth , - 1 ) ;
33127: LD_STRING Roth
33129: PPUSH
33130: LD_INT 1
33132: NEG
33133: PPUSH
33134: CALL_OW 101
// if behemothDestroyedBeforeFinish then
33138: LD_EXP 27
33142: IFFALSE 33164
// begin m2 := true ;
33144: LD_ADDR_VAR 0 2
33148: PUSH
33149: LD_INT 1
33151: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33152: LD_STRING Project
33154: PPUSH
33155: LD_INT 1
33157: PPUSH
33158: CALL_OW 101
// end else
33162: GO 33175
// AddMedal ( Project , - 1 ) ;
33164: LD_STRING Project
33166: PPUSH
33167: LD_INT 1
33169: NEG
33170: PPUSH
33171: CALL_OW 101
// if lostCounter = 0 then
33175: LD_EXP 32
33179: PUSH
33180: LD_INT 0
33182: EQUAL
33183: IFFALSE 33205
// begin m3 := true ;
33185: LD_ADDR_VAR 0 3
33189: PUSH
33190: LD_INT 1
33192: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33193: LD_STRING NoLosses
33195: PPUSH
33196: LD_INT 1
33198: PPUSH
33199: CALL_OW 101
// end else
33203: GO 33216
// AddMedal ( NoLosses , - 1 ) ;
33205: LD_STRING NoLosses
33207: PPUSH
33208: LD_INT 1
33210: NEG
33211: PPUSH
33212: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
33216: LD_VAR 0 1
33220: PUSH
33221: LD_VAR 0 2
33225: AND
33226: PUSH
33227: LD_VAR 0 3
33231: AND
33232: PUSH
33233: LD_OWVAR 67
33237: PUSH
33238: LD_INT 3
33240: EQUAL
33241: AND
33242: IFFALSE 33254
// SetAchievementEX ( ACH_AMER , 15 ) ;
33244: LD_STRING ACH_AMER
33246: PPUSH
33247: LD_INT 15
33249: PPUSH
33250: CALL_OW 564
// GiveMedals ( MAIN ) ;
33254: LD_STRING MAIN
33256: PPUSH
33257: CALL_OW 102
// music_class := 4 ;
33261: LD_ADDR_OWVAR 72
33265: PUSH
33266: LD_INT 4
33268: ST_TO_ADDR
// music_nat := 1 ;
33269: LD_ADDR_OWVAR 71
33273: PUSH
33274: LD_INT 1
33276: ST_TO_ADDR
// YouWin ;
33277: CALL_OW 103
// end ; end_of_file
33281: PPOPN 3
33283: END
// export function CustomEvent ( event ) ; begin
33284: LD_INT 0
33286: PPUSH
// end ;
33287: LD_VAR 0 2
33291: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33292: LD_VAR 0 1
33296: PUSH
33297: LD_INT 1
33299: EQUAL
33300: PUSH
33301: LD_VAR 0 2
33305: PUSH
33306: LD_INT 4
33308: EQUAL
33309: AND
33310: PUSH
33311: LD_EXP 58
33315: PPUSH
33316: CALL_OW 300
33320: AND
33321: IFFALSE 33337
// begin wait ( 0 0$2 ) ;
33323: LD_INT 70
33325: PPUSH
33326: CALL_OW 67
// YouLost ( Dismissed ) ;
33330: LD_STRING Dismissed
33332: PPUSH
33333: CALL_OW 104
// end ; end ;
33337: PPOPN 2
33339: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33340: LD_VAR 0 2
33344: PPUSH
33345: LD_VAR 0 3
33349: PPUSH
33350: LD_INT 18
33352: PPUSH
33353: CALL_OW 309
33357: IFFALSE 33366
// YouLost ( Motherlode3 ) ;
33359: LD_STRING Motherlode3
33361: PPUSH
33362: CALL_OW 104
// end ;
33366: PPOPN 3
33368: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33369: LD_EXP 27
33373: NOT
33374: IFFALSE 33384
// behemothDone := true ;
33376: LD_ADDR_EXP 28
33380: PUSH
33381: LD_INT 1
33383: ST_TO_ADDR
// end ;
33384: PPOPN 1
33386: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33387: LD_VAR 0 1
33391: PPUSH
33392: CALL_OW 255
33396: PUSH
33397: LD_INT 1
33399: EQUAL
33400: IFFALSE 33410
// bombExploded := true ;
33402: LD_ADDR_EXP 37
33406: PUSH
33407: LD_INT 1
33409: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33410: LD_VAR 0 1
33414: PPUSH
33415: CALL_OW 255
33419: PUSH
33420: LD_INT 1
33422: EQUAL
33423: PUSH
33424: LD_EXP 30
33428: AND
33429: PUSH
33430: LD_INT 22
33432: PUSH
33433: LD_INT 3
33435: PUSH
33436: EMPTY
33437: LIST
33438: LIST
33439: PUSH
33440: LD_INT 34
33442: PUSH
33443: LD_INT 48
33445: PUSH
33446: EMPTY
33447: LIST
33448: LIST
33449: PUSH
33450: EMPTY
33451: LIST
33452: LIST
33453: PPUSH
33454: CALL_OW 69
33458: AND
33459: PUSH
33460: LD_INT 22
33462: PUSH
33463: LD_INT 1
33465: PUSH
33466: EMPTY
33467: LIST
33468: LIST
33469: PUSH
33470: LD_INT 34
33472: PUSH
33473: LD_INT 8
33475: PUSH
33476: EMPTY
33477: LIST
33478: LIST
33479: PUSH
33480: EMPTY
33481: LIST
33482: LIST
33483: PPUSH
33484: CALL_OW 69
33488: NOT
33489: AND
33490: IFFALSE 33542
// begin wait ( 0 0$5 ) ;
33492: LD_INT 175
33494: PPUSH
33495: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33499: LD_INT 22
33501: PUSH
33502: LD_INT 3
33504: PUSH
33505: EMPTY
33506: LIST
33507: LIST
33508: PUSH
33509: LD_INT 34
33511: PUSH
33512: LD_INT 48
33514: PUSH
33515: EMPTY
33516: LIST
33517: LIST
33518: PUSH
33519: EMPTY
33520: LIST
33521: LIST
33522: PPUSH
33523: CALL_OW 69
33527: PUSH
33528: LD_INT 1
33530: ARRAY
33531: PPUSH
33532: LD_INT 60
33534: PPUSH
33535: LD_INT 95
33537: PPUSH
33538: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33542: LD_VAR 0 2
33546: PPUSH
33547: LD_VAR 0 3
33551: PPUSH
33552: LD_INT 18
33554: PPUSH
33555: CALL_OW 309
33559: IFFALSE 33619
// begin if GetSide ( unit ) = 1 then
33561: LD_VAR 0 1
33565: PPUSH
33566: CALL_OW 255
33570: PUSH
33571: LD_INT 1
33573: EQUAL
33574: IFFALSE 33590
// begin wait ( 0 0$6 ) ;
33576: LD_INT 210
33578: PPUSH
33579: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33583: LD_STRING Motherlode2
33585: PPUSH
33586: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
33590: LD_VAR 0 1
33594: PPUSH
33595: CALL_OW 255
33599: PUSH
33600: LD_INT 8
33602: EQUAL
33603: IFFALSE 33619
// begin wait ( 0 0$6 ) ;
33605: LD_INT 210
33607: PPUSH
33608: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33612: LD_STRING Motherlode1
33614: PPUSH
33615: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33619: LD_VAR 0 1
33623: PPUSH
33624: CALL_OW 255
33628: PUSH
33629: LD_INT 3
33631: EQUAL
33632: IFFALSE 33653
// begin wait ( 0 0$5 ) ;
33634: LD_INT 175
33636: PPUSH
33637: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33641: LD_EXP 64
33645: PPUSH
33646: LD_STRING D18-Pla-1
33648: PPUSH
33649: CALL_OW 94
// end ; end ;
33653: PPOPN 3
33655: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
33656: LD_VAR 0 1
33660: PUSH
33661: LD_EXP 73
33665: IN
33666: IFFALSE 33686
// begin behemothBuilders := behemothBuilders diff un ;
33668: LD_ADDR_EXP 73
33672: PUSH
33673: LD_EXP 73
33677: PUSH
33678: LD_VAR 0 1
33682: DIFF
33683: ST_TO_ADDR
// exit ;
33684: GO 33784
// end ; if un = JMM then
33686: LD_VAR 0 1
33690: PUSH
33691: LD_EXP 39
33695: EQUAL
33696: IFFALSE 33707
// begin YouLost ( JMM ) ;
33698: LD_STRING JMM
33700: PPUSH
33701: CALL_OW 104
// exit ;
33705: GO 33784
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
33707: LD_VAR 0 1
33711: PUSH
33712: LD_INT 22
33714: PUSH
33715: LD_INT 1
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: PUSH
33722: LD_INT 3
33724: PUSH
33725: LD_INT 25
33727: PUSH
33728: LD_INT 16
33730: PUSH
33731: EMPTY
33732: LIST
33733: LIST
33734: PUSH
33735: LD_INT 25
33737: PUSH
33738: LD_INT 12
33740: PUSH
33741: EMPTY
33742: LIST
33743: LIST
33744: PUSH
33745: EMPTY
33746: LIST
33747: LIST
33748: LIST
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: PPUSH
33754: CALL_OW 69
33758: IN
33759: IFFALSE 33775
// lostCounter := lostCounter + 1 ;
33761: LD_ADDR_EXP 32
33765: PUSH
33766: LD_EXP 32
33770: PUSH
33771: LD_INT 1
33773: PLUS
33774: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
33775: LD_VAR 0 1
33779: PPUSH
33780: CALL 62028 0 1
// end ;
33784: PPOPN 1
33786: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33787: LD_VAR 0 1
33791: PPUSH
33792: LD_VAR 0 2
33796: PPUSH
33797: CALL 64362 0 2
// end ;
33801: PPOPN 2
33803: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33804: LD_VAR 0 1
33808: PPUSH
33809: CALL 63430 0 1
// end ;
33813: PPOPN 1
33815: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33816: LD_VAR 0 1
33820: PUSH
33821: LD_INT 22
33823: PUSH
33824: LD_INT 8
33826: PUSH
33827: EMPTY
33828: LIST
33829: LIST
33830: PUSH
33831: LD_INT 30
33833: PUSH
33834: LD_INT 2
33836: PUSH
33837: EMPTY
33838: LIST
33839: LIST
33840: PUSH
33841: LD_INT 23
33843: PUSH
33844: LD_INT 3
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: PUSH
33851: EMPTY
33852: LIST
33853: LIST
33854: LIST
33855: PPUSH
33856: CALL_OW 69
33860: IN
33861: IFFALSE 33888
// begin ComUpgrade ( building ) ;
33863: LD_VAR 0 1
33867: PPUSH
33868: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
33872: LD_EXP 61
33876: PPUSH
33877: LD_VAR 0 1
33881: PPUSH
33882: CALL 72777 0 2
// exit ;
33886: GO 33897
// end ; MCE_BuildingComplete ( building ) ;
33888: LD_VAR 0 1
33892: PPUSH
33893: CALL 63671 0 1
// end ;
33897: PPOPN 1
33899: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
33900: LD_VAR 0 1
33904: PPUSH
33905: LD_VAR 0 2
33909: PPUSH
33910: CALL 61724 0 2
// end ;
33914: PPOPN 2
33916: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
33917: LD_VAR 0 1
33921: PPUSH
33922: LD_VAR 0 2
33926: PPUSH
33927: LD_VAR 0 3
33931: PPUSH
33932: LD_VAR 0 4
33936: PPUSH
33937: LD_VAR 0 5
33941: PPUSH
33942: CALL 61344 0 5
// end ;
33946: PPOPN 5
33948: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
33949: LD_VAR 0 1
33953: PPUSH
33954: LD_VAR 0 2
33958: PPUSH
33959: CALL 60940 0 2
// end ;
33963: PPOPN 2
33965: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
33966: LD_VAR 0 1
33970: PPUSH
33971: LD_VAR 0 2
33975: PPUSH
33976: LD_VAR 0 3
33980: PPUSH
33981: LD_VAR 0 4
33985: PPUSH
33986: CALL 60778 0 4
// end ;
33990: PPOPN 4
33992: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
33993: LD_VAR 0 1
33997: PPUSH
33998: LD_VAR 0 2
34002: PPUSH
34003: LD_VAR 0 3
34007: PPUSH
34008: CALL 60553 0 3
// end ;
34012: PPOPN 3
34014: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
34015: LD_VAR 0 1
34019: PPUSH
34020: LD_VAR 0 2
34024: PPUSH
34025: CALL 60438 0 2
// end ;
34029: PPOPN 2
34031: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34032: LD_VAR 0 1
34036: PPUSH
34037: LD_VAR 0 2
34041: PPUSH
34042: CALL 64623 0 2
// end ;
34046: PPOPN 2
34048: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34049: LD_VAR 0 1
34053: PPUSH
34054: CALL_OW 255
34058: PUSH
34059: LD_INT 4
34061: EQUAL
34062: PUSH
34063: LD_VAR 0 1
34067: PUSH
34068: LD_EXP 18
34072: PUSH
34073: LD_INT 1
34075: ARRAY
34076: IN
34077: AND
34078: PUSH
34079: LD_EXP 19
34083: AND
34084: IFFALSE 34103
// begin ComMoveXY ( driver , 61 , 93 ) ;
34086: LD_VAR 0 1
34090: PPUSH
34091: LD_INT 61
34093: PPUSH
34094: LD_INT 93
34096: PPUSH
34097: CALL_OW 111
// exit ;
34101: GO 34127
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34103: LD_VAR 0 1
34107: PPUSH
34108: LD_VAR 0 2
34112: PPUSH
34113: LD_VAR 0 3
34117: PPUSH
34118: LD_VAR 0 4
34122: PPUSH
34123: CALL 64839 0 4
// end ;
34127: PPOPN 4
34129: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34130: LD_VAR 0 1
34134: PPUSH
34135: LD_VAR 0 2
34139: PPUSH
34140: CALL 60247 0 2
// end ;
34144: PPOPN 2
34146: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34147: LD_VAR 0 1
34151: PPUSH
34152: CALL 112279 0 1
// end ; end_of_file
34156: PPOPN 1
34158: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34159: LD_EXP 15
34163: PUSH
34164: LD_INT 2
34166: EQUAL
34167: IFFALSE 34646
34169: GO 34171
34171: DISABLE
34172: LD_INT 0
34174: PPUSH
// begin time := 0 0$40 ;
34175: LD_ADDR_VAR 0 1
34179: PUSH
34180: LD_INT 1400
34182: ST_TO_ADDR
// repeat wait ( time ) ;
34183: LD_VAR 0 1
34187: PPUSH
34188: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34192: LD_INT 1
34194: PPUSH
34195: LD_INT 5
34197: PPUSH
34198: CALL_OW 12
34202: PPUSH
34203: LD_INT 106
34205: PPUSH
34206: LD_INT 150
34208: PPUSH
34209: LD_INT 19
34211: PPUSH
34212: LD_INT 1
34214: PPUSH
34215: CALL_OW 56
// time := time + 0 0$9 ;
34219: LD_ADDR_VAR 0 1
34223: PUSH
34224: LD_VAR 0 1
34228: PUSH
34229: LD_INT 315
34231: PLUS
34232: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34233: LD_INT 455
34235: PPUSH
34236: LD_INT 840
34238: PPUSH
34239: CALL_OW 12
34243: PPUSH
34244: CALL_OW 67
// if Prob ( 50 ) then
34248: LD_INT 50
34250: PPUSH
34251: CALL_OW 13
34255: IFFALSE 34284
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34257: LD_INT 1
34259: PPUSH
34260: LD_INT 5
34262: PPUSH
34263: CALL_OW 12
34267: PPUSH
34268: LD_INT 62
34270: PPUSH
34271: LD_INT 108
34273: PPUSH
34274: LD_INT 10
34276: PPUSH
34277: LD_INT 1
34279: PPUSH
34280: CALL_OW 56
// until missionStage > 4 ;
34284: LD_EXP 15
34288: PUSH
34289: LD_INT 4
34291: GREATER
34292: IFFALSE 34183
// repeat wait ( 0 0$1 ) ;
34294: LD_INT 35
34296: PPUSH
34297: CALL_OW 67
// until missionStage = 6 ;
34301: LD_EXP 15
34305: PUSH
34306: LD_INT 6
34308: EQUAL
34309: IFFALSE 34294
// time := 0 0$50 ;
34311: LD_ADDR_VAR 0 1
34315: PUSH
34316: LD_INT 1750
34318: ST_TO_ADDR
// repeat wait ( time ) ;
34319: LD_VAR 0 1
34323: PPUSH
34324: CALL_OW 67
// if Prob ( 50 ) then
34328: LD_INT 50
34330: PPUSH
34331: CALL_OW 13
34335: IFFALSE 34364
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34337: LD_INT 1
34339: PPUSH
34340: LD_INT 5
34342: PPUSH
34343: CALL_OW 12
34347: PPUSH
34348: LD_INT 106
34350: PPUSH
34351: LD_INT 89
34353: PPUSH
34354: LD_INT 45
34356: PPUSH
34357: LD_INT 1
34359: PPUSH
34360: CALL_OW 56
// time := time + 0 0$2 ;
34364: LD_ADDR_VAR 0 1
34368: PUSH
34369: LD_VAR 0 1
34373: PUSH
34374: LD_INT 70
34376: PLUS
34377: ST_TO_ADDR
// if Prob ( 30 ) then
34378: LD_INT 30
34380: PPUSH
34381: CALL_OW 13
34385: IFFALSE 34431
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34387: LD_INT 385
34389: PPUSH
34390: LD_INT 945
34392: PPUSH
34393: CALL_OW 12
34397: PPUSH
34398: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34402: LD_INT 1
34404: PPUSH
34405: LD_INT 5
34407: PPUSH
34408: CALL_OW 12
34412: PPUSH
34413: LD_INT 21
34415: PPUSH
34416: LD_INT 26
34418: PPUSH
34419: LD_INT 12
34421: PPUSH
34422: LD_INT 1
34424: PPUSH
34425: CALL_OW 56
// end else
34429: GO 34467
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34431: LD_INT 700
34433: PPUSH
34434: LD_INT 1225
34436: PPUSH
34437: CALL_OW 12
34441: PPUSH
34442: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34446: LD_INT 1
34448: PPUSH
34449: LD_INT 5
34451: PPUSH
34452: CALL_OW 12
34456: PPUSH
34457: LD_INT 16
34459: PPUSH
34460: LD_INT 1
34462: PPUSH
34463: CALL_OW 55
// end ; if Prob ( 50 ) then
34467: LD_INT 50
34469: PPUSH
34470: CALL_OW 13
34474: IFFALSE 34520
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34476: LD_INT 700
34478: PPUSH
34479: LD_INT 1050
34481: PPUSH
34482: CALL_OW 12
34486: PPUSH
34487: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34491: LD_INT 1
34493: PPUSH
34494: LD_INT 5
34496: PPUSH
34497: CALL_OW 12
34501: PPUSH
34502: LD_INT 181
34504: PPUSH
34505: LD_INT 218
34507: PPUSH
34508: LD_INT 16
34510: PPUSH
34511: LD_INT 1
34513: PPUSH
34514: CALL_OW 56
// end else
34518: GO 34556
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34520: LD_INT 350
34522: PPUSH
34523: LD_INT 525
34525: PPUSH
34526: CALL_OW 12
34530: PPUSH
34531: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34535: LD_INT 1
34537: PPUSH
34538: LD_INT 5
34540: PPUSH
34541: CALL_OW 12
34545: PPUSH
34546: LD_INT 15
34548: PPUSH
34549: LD_INT 1
34551: PPUSH
34552: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
34556: LD_INT 45
34558: PUSH
34559: LD_INT 32
34561: PUSH
34562: LD_INT 25
34564: PUSH
34565: EMPTY
34566: LIST
34567: LIST
34568: LIST
34569: PUSH
34570: LD_OWVAR 67
34574: ARRAY
34575: PPUSH
34576: CALL_OW 13
34580: IFFALSE 34624
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34582: LD_INT 175
34584: PPUSH
34585: LD_INT 315
34587: PPUSH
34588: CALL_OW 12
34592: PPUSH
34593: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34597: LD_INT 1
34599: PPUSH
34600: LD_INT 5
34602: PPUSH
34603: CALL_OW 12
34607: PPUSH
34608: LD_INT 103
34610: PPUSH
34611: LD_INT 140
34613: PPUSH
34614: LD_INT 20
34616: PPUSH
34617: LD_INT 1
34619: PPUSH
34620: CALL_OW 56
// end ; if time > 1 1$20 then
34624: LD_VAR 0 1
34628: PUSH
34629: LD_INT 2800
34631: GREATER
34632: IFFALSE 34642
// time := 0 0$30 ;
34634: LD_ADDR_VAR 0 1
34638: PUSH
34639: LD_INT 1050
34641: ST_TO_ADDR
// until false ;
34642: LD_INT 0
34644: IFFALSE 34319
// end ; end_of_file
34646: PPOPN 1
34648: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34649: LD_EXP 13
34653: PUSH
34654: LD_EXP 15
34658: PUSH
34659: LD_INT 6
34661: GREATEREQUAL
34662: AND
34663: IFFALSE 34700
34665: GO 34667
34667: DISABLE
// begin enable ;
34668: ENABLE
// missionTime := missionTime + 0 0$1 ;
34669: LD_ADDR_EXP 14
34673: PUSH
34674: LD_EXP 14
34678: PUSH
34679: LD_INT 35
34681: PLUS
34682: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34683: LD_ADDR_OWVAR 47
34687: PUSH
34688: LD_STRING #Am15-1
34690: PUSH
34691: LD_EXP 14
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: ST_TO_ADDR
// end ; end_of_file
34700: END
// export function InitNature ; begin
34701: LD_INT 0
34703: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34704: LD_INT 3
34706: PPUSH
34707: LD_INT 3
34709: PPUSH
34710: LD_INT 2
34712: PPUSH
34713: LD_INT 1
34715: PPUSH
34716: LD_INT 1
34718: PPUSH
34719: LD_INT 0
34721: PPUSH
34722: LD_INT 0
34724: PPUSH
34725: LD_INT 20
34727: PPUSH
34728: LD_INT 0
34730: PPUSH
34731: CALL 97595 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34735: LD_INT 2
34737: PPUSH
34738: LD_INT 1
34740: PPUSH
34741: LD_INT 1
34743: PPUSH
34744: LD_INT 1
34746: PPUSH
34747: LD_INT 1
34749: PPUSH
34750: LD_INT 0
34752: PPUSH
34753: LD_INT 0
34755: PPUSH
34756: LD_INT 21
34758: PPUSH
34759: LD_INT 0
34761: PPUSH
34762: CALL 97595 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34766: LD_INT 4
34768: PPUSH
34769: LD_INT 1
34771: PPUSH
34772: LD_INT 2
34774: PPUSH
34775: LD_INT 4
34777: PPUSH
34778: LD_INT 2
34780: PPUSH
34781: LD_INT 1
34783: PPUSH
34784: LD_INT 0
34786: PPUSH
34787: LD_INT 22
34789: PPUSH
34790: LD_INT 0
34792: PPUSH
34793: CALL 97595 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34797: LD_INT 0
34799: PPUSH
34800: LD_INT 0
34802: PPUSH
34803: LD_INT 0
34805: PPUSH
34806: LD_INT 0
34808: PPUSH
34809: LD_INT 0
34811: PPUSH
34812: LD_INT 0
34814: PPUSH
34815: LD_INT 9
34817: PPUSH
34818: LD_INT 0
34820: PPUSH
34821: LD_INT 23
34823: PPUSH
34824: CALL 97595 0 9
// end ; end_of_file
34828: LD_VAR 0 1
34832: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
34833: GO 34835
34835: DISABLE
// begin ru_radar := 98 ;
34836: LD_ADDR_EXP 95
34840: PUSH
34841: LD_INT 98
34843: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34844: LD_ADDR_EXP 96
34848: PUSH
34849: LD_INT 89
34851: ST_TO_ADDR
// us_hack := 99 ;
34852: LD_ADDR_EXP 97
34856: PUSH
34857: LD_INT 99
34859: ST_TO_ADDR
// us_artillery := 97 ;
34860: LD_ADDR_EXP 98
34864: PUSH
34865: LD_INT 97
34867: ST_TO_ADDR
// ar_bio_bomb := 91 ;
34868: LD_ADDR_EXP 99
34872: PUSH
34873: LD_INT 91
34875: ST_TO_ADDR
// tech_Artillery := 80 ;
34876: LD_ADDR_EXP 100
34880: PUSH
34881: LD_INT 80
34883: ST_TO_ADDR
// tech_RadMat := 81 ;
34884: LD_ADDR_EXP 101
34888: PUSH
34889: LD_INT 81
34891: ST_TO_ADDR
// tech_BasicTools := 82 ;
34892: LD_ADDR_EXP 102
34896: PUSH
34897: LD_INT 82
34899: ST_TO_ADDR
// tech_Cargo := 83 ;
34900: LD_ADDR_EXP 103
34904: PUSH
34905: LD_INT 83
34907: ST_TO_ADDR
// tech_Track := 84 ;
34908: LD_ADDR_EXP 104
34912: PUSH
34913: LD_INT 84
34915: ST_TO_ADDR
// tech_Crane := 85 ;
34916: LD_ADDR_EXP 105
34920: PUSH
34921: LD_INT 85
34923: ST_TO_ADDR
// tech_Bulldozer := 86 ;
34924: LD_ADDR_EXP 106
34928: PUSH
34929: LD_INT 86
34931: ST_TO_ADDR
// tech_Hovercraft := 87 ;
34932: LD_ADDR_EXP 107
34936: PUSH
34937: LD_INT 87
34939: ST_TO_ADDR
// end ; end_of_file
34940: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
34941: LD_INT 0
34943: PPUSH
34944: PPUSH
// skirmish := false ;
34945: LD_ADDR_EXP 108
34949: PUSH
34950: LD_INT 0
34952: ST_TO_ADDR
// debug_mc := false ;
34953: LD_ADDR_EXP 109
34957: PUSH
34958: LD_INT 0
34960: ST_TO_ADDR
// mc_bases := [ ] ;
34961: LD_ADDR_EXP 110
34965: PUSH
34966: EMPTY
34967: ST_TO_ADDR
// mc_sides := [ ] ;
34968: LD_ADDR_EXP 136
34972: PUSH
34973: EMPTY
34974: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
34975: LD_ADDR_EXP 111
34979: PUSH
34980: EMPTY
34981: ST_TO_ADDR
// mc_building_repairs := [ ] ;
34982: LD_ADDR_EXP 112
34986: PUSH
34987: EMPTY
34988: ST_TO_ADDR
// mc_need_heal := [ ] ;
34989: LD_ADDR_EXP 113
34993: PUSH
34994: EMPTY
34995: ST_TO_ADDR
// mc_healers := [ ] ;
34996: LD_ADDR_EXP 114
35000: PUSH
35001: EMPTY
35002: ST_TO_ADDR
// mc_build_list := [ ] ;
35003: LD_ADDR_EXP 115
35007: PUSH
35008: EMPTY
35009: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
35010: LD_ADDR_EXP 142
35014: PUSH
35015: EMPTY
35016: ST_TO_ADDR
// mc_builders := [ ] ;
35017: LD_ADDR_EXP 116
35021: PUSH
35022: EMPTY
35023: ST_TO_ADDR
// mc_construct_list := [ ] ;
35024: LD_ADDR_EXP 117
35028: PUSH
35029: EMPTY
35030: ST_TO_ADDR
// mc_turret_list := [ ] ;
35031: LD_ADDR_EXP 118
35035: PUSH
35036: EMPTY
35037: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
35038: LD_ADDR_EXP 119
35042: PUSH
35043: EMPTY
35044: ST_TO_ADDR
// mc_miners := [ ] ;
35045: LD_ADDR_EXP 124
35049: PUSH
35050: EMPTY
35051: ST_TO_ADDR
// mc_mines := [ ] ;
35052: LD_ADDR_EXP 123
35056: PUSH
35057: EMPTY
35058: ST_TO_ADDR
// mc_minefields := [ ] ;
35059: LD_ADDR_EXP 125
35063: PUSH
35064: EMPTY
35065: ST_TO_ADDR
// mc_crates := [ ] ;
35066: LD_ADDR_EXP 126
35070: PUSH
35071: EMPTY
35072: ST_TO_ADDR
// mc_crates_collector := [ ] ;
35073: LD_ADDR_EXP 127
35077: PUSH
35078: EMPTY
35079: ST_TO_ADDR
// mc_crates_area := [ ] ;
35080: LD_ADDR_EXP 128
35084: PUSH
35085: EMPTY
35086: ST_TO_ADDR
// mc_vehicles := [ ] ;
35087: LD_ADDR_EXP 129
35091: PUSH
35092: EMPTY
35093: ST_TO_ADDR
// mc_attack := [ ] ;
35094: LD_ADDR_EXP 130
35098: PUSH
35099: EMPTY
35100: ST_TO_ADDR
// mc_produce := [ ] ;
35101: LD_ADDR_EXP 131
35105: PUSH
35106: EMPTY
35107: ST_TO_ADDR
// mc_defender := [ ] ;
35108: LD_ADDR_EXP 132
35112: PUSH
35113: EMPTY
35114: ST_TO_ADDR
// mc_parking := [ ] ;
35115: LD_ADDR_EXP 134
35119: PUSH
35120: EMPTY
35121: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35122: LD_ADDR_EXP 120
35126: PUSH
35127: EMPTY
35128: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35129: LD_ADDR_EXP 122
35133: PUSH
35134: EMPTY
35135: ST_TO_ADDR
// mc_scan := [ ] ;
35136: LD_ADDR_EXP 133
35140: PUSH
35141: EMPTY
35142: ST_TO_ADDR
// mc_scan_area := [ ] ;
35143: LD_ADDR_EXP 135
35147: PUSH
35148: EMPTY
35149: ST_TO_ADDR
// mc_tech := [ ] ;
35150: LD_ADDR_EXP 137
35154: PUSH
35155: EMPTY
35156: ST_TO_ADDR
// mc_class := [ ] ;
35157: LD_ADDR_EXP 151
35161: PUSH
35162: EMPTY
35163: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35164: LD_ADDR_EXP 152
35168: PUSH
35169: EMPTY
35170: ST_TO_ADDR
// end ;
35171: LD_VAR 0 1
35175: RET
// export function MC_Kill ( base ) ; begin
35176: LD_INT 0
35178: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35179: LD_ADDR_EXP 110
35183: PUSH
35184: LD_EXP 110
35188: PPUSH
35189: LD_VAR 0 1
35193: PPUSH
35194: EMPTY
35195: PPUSH
35196: CALL_OW 1
35200: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35201: LD_ADDR_EXP 111
35205: PUSH
35206: LD_EXP 111
35210: PPUSH
35211: LD_VAR 0 1
35215: PPUSH
35216: EMPTY
35217: PPUSH
35218: CALL_OW 1
35222: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35223: LD_ADDR_EXP 112
35227: PUSH
35228: LD_EXP 112
35232: PPUSH
35233: LD_VAR 0 1
35237: PPUSH
35238: EMPTY
35239: PPUSH
35240: CALL_OW 1
35244: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35245: LD_ADDR_EXP 113
35249: PUSH
35250: LD_EXP 113
35254: PPUSH
35255: LD_VAR 0 1
35259: PPUSH
35260: EMPTY
35261: PPUSH
35262: CALL_OW 1
35266: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35267: LD_ADDR_EXP 114
35271: PUSH
35272: LD_EXP 114
35276: PPUSH
35277: LD_VAR 0 1
35281: PPUSH
35282: EMPTY
35283: PPUSH
35284: CALL_OW 1
35288: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35289: LD_ADDR_EXP 115
35293: PUSH
35294: LD_EXP 115
35298: PPUSH
35299: LD_VAR 0 1
35303: PPUSH
35304: EMPTY
35305: PPUSH
35306: CALL_OW 1
35310: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35311: LD_ADDR_EXP 116
35315: PUSH
35316: LD_EXP 116
35320: PPUSH
35321: LD_VAR 0 1
35325: PPUSH
35326: EMPTY
35327: PPUSH
35328: CALL_OW 1
35332: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35333: LD_ADDR_EXP 117
35337: PUSH
35338: LD_EXP 117
35342: PPUSH
35343: LD_VAR 0 1
35347: PPUSH
35348: EMPTY
35349: PPUSH
35350: CALL_OW 1
35354: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35355: LD_ADDR_EXP 118
35359: PUSH
35360: LD_EXP 118
35364: PPUSH
35365: LD_VAR 0 1
35369: PPUSH
35370: EMPTY
35371: PPUSH
35372: CALL_OW 1
35376: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35377: LD_ADDR_EXP 119
35381: PUSH
35382: LD_EXP 119
35386: PPUSH
35387: LD_VAR 0 1
35391: PPUSH
35392: EMPTY
35393: PPUSH
35394: CALL_OW 1
35398: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35399: LD_ADDR_EXP 120
35403: PUSH
35404: LD_EXP 120
35408: PPUSH
35409: LD_VAR 0 1
35413: PPUSH
35414: EMPTY
35415: PPUSH
35416: CALL_OW 1
35420: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35421: LD_ADDR_EXP 121
35425: PUSH
35426: LD_EXP 121
35430: PPUSH
35431: LD_VAR 0 1
35435: PPUSH
35436: LD_INT 0
35438: PPUSH
35439: CALL_OW 1
35443: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35444: LD_ADDR_EXP 122
35448: PUSH
35449: LD_EXP 122
35453: PPUSH
35454: LD_VAR 0 1
35458: PPUSH
35459: EMPTY
35460: PPUSH
35461: CALL_OW 1
35465: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35466: LD_ADDR_EXP 123
35470: PUSH
35471: LD_EXP 123
35475: PPUSH
35476: LD_VAR 0 1
35480: PPUSH
35481: EMPTY
35482: PPUSH
35483: CALL_OW 1
35487: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35488: LD_ADDR_EXP 124
35492: PUSH
35493: LD_EXP 124
35497: PPUSH
35498: LD_VAR 0 1
35502: PPUSH
35503: EMPTY
35504: PPUSH
35505: CALL_OW 1
35509: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35510: LD_ADDR_EXP 125
35514: PUSH
35515: LD_EXP 125
35519: PPUSH
35520: LD_VAR 0 1
35524: PPUSH
35525: EMPTY
35526: PPUSH
35527: CALL_OW 1
35531: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35532: LD_ADDR_EXP 126
35536: PUSH
35537: LD_EXP 126
35541: PPUSH
35542: LD_VAR 0 1
35546: PPUSH
35547: EMPTY
35548: PPUSH
35549: CALL_OW 1
35553: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35554: LD_ADDR_EXP 127
35558: PUSH
35559: LD_EXP 127
35563: PPUSH
35564: LD_VAR 0 1
35568: PPUSH
35569: EMPTY
35570: PPUSH
35571: CALL_OW 1
35575: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35576: LD_ADDR_EXP 128
35580: PUSH
35581: LD_EXP 128
35585: PPUSH
35586: LD_VAR 0 1
35590: PPUSH
35591: EMPTY
35592: PPUSH
35593: CALL_OW 1
35597: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35598: LD_ADDR_EXP 129
35602: PUSH
35603: LD_EXP 129
35607: PPUSH
35608: LD_VAR 0 1
35612: PPUSH
35613: EMPTY
35614: PPUSH
35615: CALL_OW 1
35619: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35620: LD_ADDR_EXP 130
35624: PUSH
35625: LD_EXP 130
35629: PPUSH
35630: LD_VAR 0 1
35634: PPUSH
35635: EMPTY
35636: PPUSH
35637: CALL_OW 1
35641: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35642: LD_ADDR_EXP 131
35646: PUSH
35647: LD_EXP 131
35651: PPUSH
35652: LD_VAR 0 1
35656: PPUSH
35657: EMPTY
35658: PPUSH
35659: CALL_OW 1
35663: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35664: LD_ADDR_EXP 132
35668: PUSH
35669: LD_EXP 132
35673: PPUSH
35674: LD_VAR 0 1
35678: PPUSH
35679: EMPTY
35680: PPUSH
35681: CALL_OW 1
35685: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35686: LD_ADDR_EXP 133
35690: PUSH
35691: LD_EXP 133
35695: PPUSH
35696: LD_VAR 0 1
35700: PPUSH
35701: EMPTY
35702: PPUSH
35703: CALL_OW 1
35707: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35708: LD_ADDR_EXP 134
35712: PUSH
35713: LD_EXP 134
35717: PPUSH
35718: LD_VAR 0 1
35722: PPUSH
35723: EMPTY
35724: PPUSH
35725: CALL_OW 1
35729: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35730: LD_ADDR_EXP 135
35734: PUSH
35735: LD_EXP 135
35739: PPUSH
35740: LD_VAR 0 1
35744: PPUSH
35745: EMPTY
35746: PPUSH
35747: CALL_OW 1
35751: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35752: LD_ADDR_EXP 137
35756: PUSH
35757: LD_EXP 137
35761: PPUSH
35762: LD_VAR 0 1
35766: PPUSH
35767: EMPTY
35768: PPUSH
35769: CALL_OW 1
35773: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35774: LD_ADDR_EXP 139
35778: PUSH
35779: LD_EXP 139
35783: PPUSH
35784: LD_VAR 0 1
35788: PPUSH
35789: EMPTY
35790: PPUSH
35791: CALL_OW 1
35795: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35796: LD_ADDR_EXP 140
35800: PUSH
35801: LD_EXP 140
35805: PPUSH
35806: LD_VAR 0 1
35810: PPUSH
35811: EMPTY
35812: PPUSH
35813: CALL_OW 1
35817: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35818: LD_ADDR_EXP 141
35822: PUSH
35823: LD_EXP 141
35827: PPUSH
35828: LD_VAR 0 1
35832: PPUSH
35833: EMPTY
35834: PPUSH
35835: CALL_OW 1
35839: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35840: LD_ADDR_EXP 142
35844: PUSH
35845: LD_EXP 142
35849: PPUSH
35850: LD_VAR 0 1
35854: PPUSH
35855: EMPTY
35856: PPUSH
35857: CALL_OW 1
35861: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35862: LD_ADDR_EXP 143
35866: PUSH
35867: LD_EXP 143
35871: PPUSH
35872: LD_VAR 0 1
35876: PPUSH
35877: EMPTY
35878: PPUSH
35879: CALL_OW 1
35883: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35884: LD_ADDR_EXP 144
35888: PUSH
35889: LD_EXP 144
35893: PPUSH
35894: LD_VAR 0 1
35898: PPUSH
35899: EMPTY
35900: PPUSH
35901: CALL_OW 1
35905: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35906: LD_ADDR_EXP 145
35910: PUSH
35911: LD_EXP 145
35915: PPUSH
35916: LD_VAR 0 1
35920: PPUSH
35921: EMPTY
35922: PPUSH
35923: CALL_OW 1
35927: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35928: LD_ADDR_EXP 146
35932: PUSH
35933: LD_EXP 146
35937: PPUSH
35938: LD_VAR 0 1
35942: PPUSH
35943: EMPTY
35944: PPUSH
35945: CALL_OW 1
35949: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35950: LD_ADDR_EXP 147
35954: PUSH
35955: LD_EXP 147
35959: PPUSH
35960: LD_VAR 0 1
35964: PPUSH
35965: EMPTY
35966: PPUSH
35967: CALL_OW 1
35971: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35972: LD_ADDR_EXP 148
35976: PUSH
35977: LD_EXP 148
35981: PPUSH
35982: LD_VAR 0 1
35986: PPUSH
35987: EMPTY
35988: PPUSH
35989: CALL_OW 1
35993: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35994: LD_ADDR_EXP 149
35998: PUSH
35999: LD_EXP 149
36003: PPUSH
36004: LD_VAR 0 1
36008: PPUSH
36009: EMPTY
36010: PPUSH
36011: CALL_OW 1
36015: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36016: LD_ADDR_EXP 150
36020: PUSH
36021: LD_EXP 150
36025: PPUSH
36026: LD_VAR 0 1
36030: PPUSH
36031: EMPTY
36032: PPUSH
36033: CALL_OW 1
36037: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36038: LD_ADDR_EXP 151
36042: PUSH
36043: LD_EXP 151
36047: PPUSH
36048: LD_VAR 0 1
36052: PPUSH
36053: EMPTY
36054: PPUSH
36055: CALL_OW 1
36059: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36060: LD_ADDR_EXP 152
36064: PUSH
36065: LD_EXP 152
36069: PPUSH
36070: LD_VAR 0 1
36074: PPUSH
36075: LD_INT 0
36077: PPUSH
36078: CALL_OW 1
36082: ST_TO_ADDR
// end ;
36083: LD_VAR 0 2
36087: RET
// export function MC_Add ( side , units ) ; var base ; begin
36088: LD_INT 0
36090: PPUSH
36091: PPUSH
// base := mc_bases + 1 ;
36092: LD_ADDR_VAR 0 4
36096: PUSH
36097: LD_EXP 110
36101: PUSH
36102: LD_INT 1
36104: PLUS
36105: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36106: LD_ADDR_EXP 136
36110: PUSH
36111: LD_EXP 136
36115: PPUSH
36116: LD_VAR 0 4
36120: PPUSH
36121: LD_VAR 0 1
36125: PPUSH
36126: CALL_OW 1
36130: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36131: LD_ADDR_EXP 110
36135: PUSH
36136: LD_EXP 110
36140: PPUSH
36141: LD_VAR 0 4
36145: PPUSH
36146: LD_VAR 0 2
36150: PPUSH
36151: CALL_OW 1
36155: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36156: LD_ADDR_EXP 111
36160: PUSH
36161: LD_EXP 111
36165: PPUSH
36166: LD_VAR 0 4
36170: PPUSH
36171: EMPTY
36172: PPUSH
36173: CALL_OW 1
36177: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36178: LD_ADDR_EXP 112
36182: PUSH
36183: LD_EXP 112
36187: PPUSH
36188: LD_VAR 0 4
36192: PPUSH
36193: EMPTY
36194: PPUSH
36195: CALL_OW 1
36199: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36200: LD_ADDR_EXP 113
36204: PUSH
36205: LD_EXP 113
36209: PPUSH
36210: LD_VAR 0 4
36214: PPUSH
36215: EMPTY
36216: PPUSH
36217: CALL_OW 1
36221: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36222: LD_ADDR_EXP 114
36226: PUSH
36227: LD_EXP 114
36231: PPUSH
36232: LD_VAR 0 4
36236: PPUSH
36237: EMPTY
36238: PPUSH
36239: CALL_OW 1
36243: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36244: LD_ADDR_EXP 115
36248: PUSH
36249: LD_EXP 115
36253: PPUSH
36254: LD_VAR 0 4
36258: PPUSH
36259: EMPTY
36260: PPUSH
36261: CALL_OW 1
36265: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36266: LD_ADDR_EXP 116
36270: PUSH
36271: LD_EXP 116
36275: PPUSH
36276: LD_VAR 0 4
36280: PPUSH
36281: EMPTY
36282: PPUSH
36283: CALL_OW 1
36287: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36288: LD_ADDR_EXP 117
36292: PUSH
36293: LD_EXP 117
36297: PPUSH
36298: LD_VAR 0 4
36302: PPUSH
36303: EMPTY
36304: PPUSH
36305: CALL_OW 1
36309: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36310: LD_ADDR_EXP 118
36314: PUSH
36315: LD_EXP 118
36319: PPUSH
36320: LD_VAR 0 4
36324: PPUSH
36325: EMPTY
36326: PPUSH
36327: CALL_OW 1
36331: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36332: LD_ADDR_EXP 119
36336: PUSH
36337: LD_EXP 119
36341: PPUSH
36342: LD_VAR 0 4
36346: PPUSH
36347: EMPTY
36348: PPUSH
36349: CALL_OW 1
36353: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36354: LD_ADDR_EXP 120
36358: PUSH
36359: LD_EXP 120
36363: PPUSH
36364: LD_VAR 0 4
36368: PPUSH
36369: EMPTY
36370: PPUSH
36371: CALL_OW 1
36375: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36376: LD_ADDR_EXP 121
36380: PUSH
36381: LD_EXP 121
36385: PPUSH
36386: LD_VAR 0 4
36390: PPUSH
36391: LD_INT 0
36393: PPUSH
36394: CALL_OW 1
36398: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36399: LD_ADDR_EXP 122
36403: PUSH
36404: LD_EXP 122
36408: PPUSH
36409: LD_VAR 0 4
36413: PPUSH
36414: EMPTY
36415: PPUSH
36416: CALL_OW 1
36420: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36421: LD_ADDR_EXP 123
36425: PUSH
36426: LD_EXP 123
36430: PPUSH
36431: LD_VAR 0 4
36435: PPUSH
36436: EMPTY
36437: PPUSH
36438: CALL_OW 1
36442: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36443: LD_ADDR_EXP 124
36447: PUSH
36448: LD_EXP 124
36452: PPUSH
36453: LD_VAR 0 4
36457: PPUSH
36458: EMPTY
36459: PPUSH
36460: CALL_OW 1
36464: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36465: LD_ADDR_EXP 125
36469: PUSH
36470: LD_EXP 125
36474: PPUSH
36475: LD_VAR 0 4
36479: PPUSH
36480: EMPTY
36481: PPUSH
36482: CALL_OW 1
36486: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36487: LD_ADDR_EXP 126
36491: PUSH
36492: LD_EXP 126
36496: PPUSH
36497: LD_VAR 0 4
36501: PPUSH
36502: EMPTY
36503: PPUSH
36504: CALL_OW 1
36508: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36509: LD_ADDR_EXP 127
36513: PUSH
36514: LD_EXP 127
36518: PPUSH
36519: LD_VAR 0 4
36523: PPUSH
36524: EMPTY
36525: PPUSH
36526: CALL_OW 1
36530: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36531: LD_ADDR_EXP 128
36535: PUSH
36536: LD_EXP 128
36540: PPUSH
36541: LD_VAR 0 4
36545: PPUSH
36546: EMPTY
36547: PPUSH
36548: CALL_OW 1
36552: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36553: LD_ADDR_EXP 129
36557: PUSH
36558: LD_EXP 129
36562: PPUSH
36563: LD_VAR 0 4
36567: PPUSH
36568: EMPTY
36569: PPUSH
36570: CALL_OW 1
36574: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36575: LD_ADDR_EXP 130
36579: PUSH
36580: LD_EXP 130
36584: PPUSH
36585: LD_VAR 0 4
36589: PPUSH
36590: EMPTY
36591: PPUSH
36592: CALL_OW 1
36596: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36597: LD_ADDR_EXP 131
36601: PUSH
36602: LD_EXP 131
36606: PPUSH
36607: LD_VAR 0 4
36611: PPUSH
36612: EMPTY
36613: PPUSH
36614: CALL_OW 1
36618: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36619: LD_ADDR_EXP 132
36623: PUSH
36624: LD_EXP 132
36628: PPUSH
36629: LD_VAR 0 4
36633: PPUSH
36634: EMPTY
36635: PPUSH
36636: CALL_OW 1
36640: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36641: LD_ADDR_EXP 133
36645: PUSH
36646: LD_EXP 133
36650: PPUSH
36651: LD_VAR 0 4
36655: PPUSH
36656: EMPTY
36657: PPUSH
36658: CALL_OW 1
36662: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36663: LD_ADDR_EXP 134
36667: PUSH
36668: LD_EXP 134
36672: PPUSH
36673: LD_VAR 0 4
36677: PPUSH
36678: EMPTY
36679: PPUSH
36680: CALL_OW 1
36684: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36685: LD_ADDR_EXP 135
36689: PUSH
36690: LD_EXP 135
36694: PPUSH
36695: LD_VAR 0 4
36699: PPUSH
36700: EMPTY
36701: PPUSH
36702: CALL_OW 1
36706: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36707: LD_ADDR_EXP 137
36711: PUSH
36712: LD_EXP 137
36716: PPUSH
36717: LD_VAR 0 4
36721: PPUSH
36722: EMPTY
36723: PPUSH
36724: CALL_OW 1
36728: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36729: LD_ADDR_EXP 139
36733: PUSH
36734: LD_EXP 139
36738: PPUSH
36739: LD_VAR 0 4
36743: PPUSH
36744: EMPTY
36745: PPUSH
36746: CALL_OW 1
36750: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36751: LD_ADDR_EXP 140
36755: PUSH
36756: LD_EXP 140
36760: PPUSH
36761: LD_VAR 0 4
36765: PPUSH
36766: EMPTY
36767: PPUSH
36768: CALL_OW 1
36772: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36773: LD_ADDR_EXP 141
36777: PUSH
36778: LD_EXP 141
36782: PPUSH
36783: LD_VAR 0 4
36787: PPUSH
36788: EMPTY
36789: PPUSH
36790: CALL_OW 1
36794: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36795: LD_ADDR_EXP 142
36799: PUSH
36800: LD_EXP 142
36804: PPUSH
36805: LD_VAR 0 4
36809: PPUSH
36810: EMPTY
36811: PPUSH
36812: CALL_OW 1
36816: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36817: LD_ADDR_EXP 143
36821: PUSH
36822: LD_EXP 143
36826: PPUSH
36827: LD_VAR 0 4
36831: PPUSH
36832: EMPTY
36833: PPUSH
36834: CALL_OW 1
36838: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36839: LD_ADDR_EXP 144
36843: PUSH
36844: LD_EXP 144
36848: PPUSH
36849: LD_VAR 0 4
36853: PPUSH
36854: EMPTY
36855: PPUSH
36856: CALL_OW 1
36860: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36861: LD_ADDR_EXP 145
36865: PUSH
36866: LD_EXP 145
36870: PPUSH
36871: LD_VAR 0 4
36875: PPUSH
36876: EMPTY
36877: PPUSH
36878: CALL_OW 1
36882: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36883: LD_ADDR_EXP 146
36887: PUSH
36888: LD_EXP 146
36892: PPUSH
36893: LD_VAR 0 4
36897: PPUSH
36898: EMPTY
36899: PPUSH
36900: CALL_OW 1
36904: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36905: LD_ADDR_EXP 147
36909: PUSH
36910: LD_EXP 147
36914: PPUSH
36915: LD_VAR 0 4
36919: PPUSH
36920: EMPTY
36921: PPUSH
36922: CALL_OW 1
36926: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36927: LD_ADDR_EXP 148
36931: PUSH
36932: LD_EXP 148
36936: PPUSH
36937: LD_VAR 0 4
36941: PPUSH
36942: EMPTY
36943: PPUSH
36944: CALL_OW 1
36948: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36949: LD_ADDR_EXP 149
36953: PUSH
36954: LD_EXP 149
36958: PPUSH
36959: LD_VAR 0 4
36963: PPUSH
36964: EMPTY
36965: PPUSH
36966: CALL_OW 1
36970: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36971: LD_ADDR_EXP 150
36975: PUSH
36976: LD_EXP 150
36980: PPUSH
36981: LD_VAR 0 4
36985: PPUSH
36986: EMPTY
36987: PPUSH
36988: CALL_OW 1
36992: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36993: LD_ADDR_EXP 151
36997: PUSH
36998: LD_EXP 151
37002: PPUSH
37003: LD_VAR 0 4
37007: PPUSH
37008: EMPTY
37009: PPUSH
37010: CALL_OW 1
37014: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37015: LD_ADDR_EXP 152
37019: PUSH
37020: LD_EXP 152
37024: PPUSH
37025: LD_VAR 0 4
37029: PPUSH
37030: LD_INT 0
37032: PPUSH
37033: CALL_OW 1
37037: ST_TO_ADDR
// result := base ;
37038: LD_ADDR_VAR 0 3
37042: PUSH
37043: LD_VAR 0 4
37047: ST_TO_ADDR
// end ;
37048: LD_VAR 0 3
37052: RET
// export function MC_Start ( ) ; var i ; begin
37053: LD_INT 0
37055: PPUSH
37056: PPUSH
// for i = 1 to mc_bases do
37057: LD_ADDR_VAR 0 2
37061: PUSH
37062: DOUBLE
37063: LD_INT 1
37065: DEC
37066: ST_TO_ADDR
37067: LD_EXP 110
37071: PUSH
37072: FOR_TO
37073: IFFALSE 38150
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
37075: LD_ADDR_EXP 110
37079: PUSH
37080: LD_EXP 110
37084: PPUSH
37085: LD_VAR 0 2
37089: PPUSH
37090: LD_EXP 110
37094: PUSH
37095: LD_VAR 0 2
37099: ARRAY
37100: PUSH
37101: LD_INT 0
37103: DIFF
37104: PPUSH
37105: CALL_OW 1
37109: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37110: LD_ADDR_EXP 111
37114: PUSH
37115: LD_EXP 111
37119: PPUSH
37120: LD_VAR 0 2
37124: PPUSH
37125: EMPTY
37126: PPUSH
37127: CALL_OW 1
37131: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37132: LD_ADDR_EXP 112
37136: PUSH
37137: LD_EXP 112
37141: PPUSH
37142: LD_VAR 0 2
37146: PPUSH
37147: EMPTY
37148: PPUSH
37149: CALL_OW 1
37153: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37154: LD_ADDR_EXP 113
37158: PUSH
37159: LD_EXP 113
37163: PPUSH
37164: LD_VAR 0 2
37168: PPUSH
37169: EMPTY
37170: PPUSH
37171: CALL_OW 1
37175: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37176: LD_ADDR_EXP 114
37180: PUSH
37181: LD_EXP 114
37185: PPUSH
37186: LD_VAR 0 2
37190: PPUSH
37191: EMPTY
37192: PUSH
37193: EMPTY
37194: PUSH
37195: EMPTY
37196: LIST
37197: LIST
37198: PPUSH
37199: CALL_OW 1
37203: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37204: LD_ADDR_EXP 115
37208: PUSH
37209: LD_EXP 115
37213: PPUSH
37214: LD_VAR 0 2
37218: PPUSH
37219: EMPTY
37220: PPUSH
37221: CALL_OW 1
37225: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37226: LD_ADDR_EXP 142
37230: PUSH
37231: LD_EXP 142
37235: PPUSH
37236: LD_VAR 0 2
37240: PPUSH
37241: EMPTY
37242: PPUSH
37243: CALL_OW 1
37247: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37248: LD_ADDR_EXP 116
37252: PUSH
37253: LD_EXP 116
37257: PPUSH
37258: LD_VAR 0 2
37262: PPUSH
37263: EMPTY
37264: PPUSH
37265: CALL_OW 1
37269: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37270: LD_ADDR_EXP 117
37274: PUSH
37275: LD_EXP 117
37279: PPUSH
37280: LD_VAR 0 2
37284: PPUSH
37285: EMPTY
37286: PPUSH
37287: CALL_OW 1
37291: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37292: LD_ADDR_EXP 118
37296: PUSH
37297: LD_EXP 118
37301: PPUSH
37302: LD_VAR 0 2
37306: PPUSH
37307: LD_EXP 110
37311: PUSH
37312: LD_VAR 0 2
37316: ARRAY
37317: PPUSH
37318: LD_INT 2
37320: PUSH
37321: LD_INT 30
37323: PUSH
37324: LD_INT 32
37326: PUSH
37327: EMPTY
37328: LIST
37329: LIST
37330: PUSH
37331: LD_INT 30
37333: PUSH
37334: LD_INT 33
37336: PUSH
37337: EMPTY
37338: LIST
37339: LIST
37340: PUSH
37341: EMPTY
37342: LIST
37343: LIST
37344: LIST
37345: PPUSH
37346: CALL_OW 72
37350: PPUSH
37351: CALL_OW 1
37355: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37356: LD_ADDR_EXP 119
37360: PUSH
37361: LD_EXP 119
37365: PPUSH
37366: LD_VAR 0 2
37370: PPUSH
37371: LD_EXP 110
37375: PUSH
37376: LD_VAR 0 2
37380: ARRAY
37381: PPUSH
37382: LD_INT 2
37384: PUSH
37385: LD_INT 30
37387: PUSH
37388: LD_INT 32
37390: PUSH
37391: EMPTY
37392: LIST
37393: LIST
37394: PUSH
37395: LD_INT 30
37397: PUSH
37398: LD_INT 31
37400: PUSH
37401: EMPTY
37402: LIST
37403: LIST
37404: PUSH
37405: EMPTY
37406: LIST
37407: LIST
37408: LIST
37409: PUSH
37410: LD_INT 58
37412: PUSH
37413: EMPTY
37414: LIST
37415: PUSH
37416: EMPTY
37417: LIST
37418: LIST
37419: PPUSH
37420: CALL_OW 72
37424: PPUSH
37425: CALL_OW 1
37429: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37430: LD_ADDR_EXP 120
37434: PUSH
37435: LD_EXP 120
37439: PPUSH
37440: LD_VAR 0 2
37444: PPUSH
37445: EMPTY
37446: PPUSH
37447: CALL_OW 1
37451: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37452: LD_ADDR_EXP 124
37456: PUSH
37457: LD_EXP 124
37461: PPUSH
37462: LD_VAR 0 2
37466: PPUSH
37467: EMPTY
37468: PPUSH
37469: CALL_OW 1
37473: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37474: LD_ADDR_EXP 123
37478: PUSH
37479: LD_EXP 123
37483: PPUSH
37484: LD_VAR 0 2
37488: PPUSH
37489: EMPTY
37490: PPUSH
37491: CALL_OW 1
37495: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37496: LD_ADDR_EXP 125
37500: PUSH
37501: LD_EXP 125
37505: PPUSH
37506: LD_VAR 0 2
37510: PPUSH
37511: EMPTY
37512: PPUSH
37513: CALL_OW 1
37517: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37518: LD_ADDR_EXP 126
37522: PUSH
37523: LD_EXP 126
37527: PPUSH
37528: LD_VAR 0 2
37532: PPUSH
37533: EMPTY
37534: PPUSH
37535: CALL_OW 1
37539: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37540: LD_ADDR_EXP 127
37544: PUSH
37545: LD_EXP 127
37549: PPUSH
37550: LD_VAR 0 2
37554: PPUSH
37555: EMPTY
37556: PPUSH
37557: CALL_OW 1
37561: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37562: LD_ADDR_EXP 128
37566: PUSH
37567: LD_EXP 128
37571: PPUSH
37572: LD_VAR 0 2
37576: PPUSH
37577: EMPTY
37578: PPUSH
37579: CALL_OW 1
37583: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37584: LD_ADDR_EXP 129
37588: PUSH
37589: LD_EXP 129
37593: PPUSH
37594: LD_VAR 0 2
37598: PPUSH
37599: EMPTY
37600: PPUSH
37601: CALL_OW 1
37605: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37606: LD_ADDR_EXP 130
37610: PUSH
37611: LD_EXP 130
37615: PPUSH
37616: LD_VAR 0 2
37620: PPUSH
37621: EMPTY
37622: PPUSH
37623: CALL_OW 1
37627: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37628: LD_ADDR_EXP 131
37632: PUSH
37633: LD_EXP 131
37637: PPUSH
37638: LD_VAR 0 2
37642: PPUSH
37643: EMPTY
37644: PPUSH
37645: CALL_OW 1
37649: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37650: LD_ADDR_EXP 132
37654: PUSH
37655: LD_EXP 132
37659: PPUSH
37660: LD_VAR 0 2
37664: PPUSH
37665: EMPTY
37666: PPUSH
37667: CALL_OW 1
37671: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
37672: LD_ADDR_EXP 121
37676: PUSH
37677: LD_EXP 121
37681: PPUSH
37682: LD_VAR 0 2
37686: PPUSH
37687: LD_INT 0
37689: PPUSH
37690: CALL_OW 1
37694: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
37695: LD_ADDR_EXP 134
37699: PUSH
37700: LD_EXP 134
37704: PPUSH
37705: LD_VAR 0 2
37709: PPUSH
37710: LD_INT 0
37712: PPUSH
37713: CALL_OW 1
37717: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37718: LD_ADDR_EXP 122
37722: PUSH
37723: LD_EXP 122
37727: PPUSH
37728: LD_VAR 0 2
37732: PPUSH
37733: EMPTY
37734: PPUSH
37735: CALL_OW 1
37739: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37740: LD_ADDR_EXP 133
37744: PUSH
37745: LD_EXP 133
37749: PPUSH
37750: LD_VAR 0 2
37754: PPUSH
37755: LD_INT 0
37757: PPUSH
37758: CALL_OW 1
37762: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
37763: LD_ADDR_EXP 135
37767: PUSH
37768: LD_EXP 135
37772: PPUSH
37773: LD_VAR 0 2
37777: PPUSH
37778: EMPTY
37779: PPUSH
37780: CALL_OW 1
37784: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
37785: LD_ADDR_EXP 138
37789: PUSH
37790: LD_EXP 138
37794: PPUSH
37795: LD_VAR 0 2
37799: PPUSH
37800: LD_INT 0
37802: PPUSH
37803: CALL_OW 1
37807: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
37808: LD_ADDR_EXP 139
37812: PUSH
37813: LD_EXP 139
37817: PPUSH
37818: LD_VAR 0 2
37822: PPUSH
37823: EMPTY
37824: PPUSH
37825: CALL_OW 1
37829: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
37830: LD_ADDR_EXP 140
37834: PUSH
37835: LD_EXP 140
37839: PPUSH
37840: LD_VAR 0 2
37844: PPUSH
37845: EMPTY
37846: PPUSH
37847: CALL_OW 1
37851: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37852: LD_ADDR_EXP 141
37856: PUSH
37857: LD_EXP 141
37861: PPUSH
37862: LD_VAR 0 2
37866: PPUSH
37867: EMPTY
37868: PPUSH
37869: CALL_OW 1
37873: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
37874: LD_ADDR_EXP 143
37878: PUSH
37879: LD_EXP 143
37883: PPUSH
37884: LD_VAR 0 2
37888: PPUSH
37889: LD_EXP 110
37893: PUSH
37894: LD_VAR 0 2
37898: ARRAY
37899: PPUSH
37900: LD_INT 2
37902: PUSH
37903: LD_INT 30
37905: PUSH
37906: LD_INT 6
37908: PUSH
37909: EMPTY
37910: LIST
37911: LIST
37912: PUSH
37913: LD_INT 30
37915: PUSH
37916: LD_INT 7
37918: PUSH
37919: EMPTY
37920: LIST
37921: LIST
37922: PUSH
37923: LD_INT 30
37925: PUSH
37926: LD_INT 8
37928: PUSH
37929: EMPTY
37930: LIST
37931: LIST
37932: PUSH
37933: EMPTY
37934: LIST
37935: LIST
37936: LIST
37937: LIST
37938: PPUSH
37939: CALL_OW 72
37943: PPUSH
37944: CALL_OW 1
37948: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
37949: LD_ADDR_EXP 144
37953: PUSH
37954: LD_EXP 144
37958: PPUSH
37959: LD_VAR 0 2
37963: PPUSH
37964: EMPTY
37965: PPUSH
37966: CALL_OW 1
37970: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
37971: LD_ADDR_EXP 145
37975: PUSH
37976: LD_EXP 145
37980: PPUSH
37981: LD_VAR 0 2
37985: PPUSH
37986: EMPTY
37987: PPUSH
37988: CALL_OW 1
37992: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
37993: LD_ADDR_EXP 146
37997: PUSH
37998: LD_EXP 146
38002: PPUSH
38003: LD_VAR 0 2
38007: PPUSH
38008: EMPTY
38009: PPUSH
38010: CALL_OW 1
38014: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
38015: LD_ADDR_EXP 147
38019: PUSH
38020: LD_EXP 147
38024: PPUSH
38025: LD_VAR 0 2
38029: PPUSH
38030: EMPTY
38031: PPUSH
38032: CALL_OW 1
38036: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38037: LD_ADDR_EXP 148
38041: PUSH
38042: LD_EXP 148
38046: PPUSH
38047: LD_VAR 0 2
38051: PPUSH
38052: EMPTY
38053: PPUSH
38054: CALL_OW 1
38058: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
38059: LD_ADDR_EXP 149
38063: PUSH
38064: LD_EXP 149
38068: PPUSH
38069: LD_VAR 0 2
38073: PPUSH
38074: EMPTY
38075: PPUSH
38076: CALL_OW 1
38080: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
38081: LD_ADDR_EXP 150
38085: PUSH
38086: LD_EXP 150
38090: PPUSH
38091: LD_VAR 0 2
38095: PPUSH
38096: EMPTY
38097: PPUSH
38098: CALL_OW 1
38102: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38103: LD_ADDR_EXP 151
38107: PUSH
38108: LD_EXP 151
38112: PPUSH
38113: LD_VAR 0 2
38117: PPUSH
38118: EMPTY
38119: PPUSH
38120: CALL_OW 1
38124: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38125: LD_ADDR_EXP 152
38129: PUSH
38130: LD_EXP 152
38134: PPUSH
38135: LD_VAR 0 2
38139: PPUSH
38140: LD_INT 0
38142: PPUSH
38143: CALL_OW 1
38147: ST_TO_ADDR
// end ;
38148: GO 37072
38150: POP
38151: POP
// MC_InitSides ( ) ;
38152: CALL 38438 0 0
// MC_InitResearch ( ) ;
38156: CALL 38177 0 0
// CustomInitMacro ( ) ;
38160: CALL 467 0 0
// skirmish := true ;
38164: LD_ADDR_EXP 108
38168: PUSH
38169: LD_INT 1
38171: ST_TO_ADDR
// end ;
38172: LD_VAR 0 1
38176: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38177: LD_INT 0
38179: PPUSH
38180: PPUSH
38181: PPUSH
38182: PPUSH
38183: PPUSH
38184: PPUSH
// if not mc_bases then
38185: LD_EXP 110
38189: NOT
38190: IFFALSE 38194
// exit ;
38192: GO 38433
// for i = 1 to 8 do
38194: LD_ADDR_VAR 0 2
38198: PUSH
38199: DOUBLE
38200: LD_INT 1
38202: DEC
38203: ST_TO_ADDR
38204: LD_INT 8
38206: PUSH
38207: FOR_TO
38208: IFFALSE 38234
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38210: LD_ADDR_EXP 137
38214: PUSH
38215: LD_EXP 137
38219: PPUSH
38220: LD_VAR 0 2
38224: PPUSH
38225: EMPTY
38226: PPUSH
38227: CALL_OW 1
38231: ST_TO_ADDR
38232: GO 38207
38234: POP
38235: POP
// tmp := [ ] ;
38236: LD_ADDR_VAR 0 5
38240: PUSH
38241: EMPTY
38242: ST_TO_ADDR
// for i = 1 to mc_sides do
38243: LD_ADDR_VAR 0 2
38247: PUSH
38248: DOUBLE
38249: LD_INT 1
38251: DEC
38252: ST_TO_ADDR
38253: LD_EXP 136
38257: PUSH
38258: FOR_TO
38259: IFFALSE 38317
// if not mc_sides [ i ] in tmp then
38261: LD_EXP 136
38265: PUSH
38266: LD_VAR 0 2
38270: ARRAY
38271: PUSH
38272: LD_VAR 0 5
38276: IN
38277: NOT
38278: IFFALSE 38315
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38280: LD_ADDR_VAR 0 5
38284: PUSH
38285: LD_VAR 0 5
38289: PPUSH
38290: LD_VAR 0 5
38294: PUSH
38295: LD_INT 1
38297: PLUS
38298: PPUSH
38299: LD_EXP 136
38303: PUSH
38304: LD_VAR 0 2
38308: ARRAY
38309: PPUSH
38310: CALL_OW 2
38314: ST_TO_ADDR
38315: GO 38258
38317: POP
38318: POP
// if not tmp then
38319: LD_VAR 0 5
38323: NOT
38324: IFFALSE 38328
// exit ;
38326: GO 38433
// for j in tmp do
38328: LD_ADDR_VAR 0 3
38332: PUSH
38333: LD_VAR 0 5
38337: PUSH
38338: FOR_IN
38339: IFFALSE 38431
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38341: LD_ADDR_VAR 0 6
38345: PUSH
38346: LD_INT 22
38348: PUSH
38349: LD_VAR 0 3
38353: PUSH
38354: EMPTY
38355: LIST
38356: LIST
38357: PPUSH
38358: CALL_OW 69
38362: ST_TO_ADDR
// if not un then
38363: LD_VAR 0 6
38367: NOT
38368: IFFALSE 38372
// continue ;
38370: GO 38338
// nation := GetNation ( un [ 1 ] ) ;
38372: LD_ADDR_VAR 0 4
38376: PUSH
38377: LD_VAR 0 6
38381: PUSH
38382: LD_INT 1
38384: ARRAY
38385: PPUSH
38386: CALL_OW 248
38390: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38391: LD_ADDR_EXP 137
38395: PUSH
38396: LD_EXP 137
38400: PPUSH
38401: LD_VAR 0 3
38405: PPUSH
38406: LD_VAR 0 3
38410: PPUSH
38411: LD_VAR 0 4
38415: PPUSH
38416: LD_INT 1
38418: PPUSH
38419: CALL 65043 0 3
38423: PPUSH
38424: CALL_OW 1
38428: ST_TO_ADDR
// end ;
38429: GO 38338
38431: POP
38432: POP
// end ;
38433: LD_VAR 0 1
38437: RET
// export function MC_InitSides ( ) ; var i ; begin
38438: LD_INT 0
38440: PPUSH
38441: PPUSH
// if not mc_bases then
38442: LD_EXP 110
38446: NOT
38447: IFFALSE 38451
// exit ;
38449: GO 38525
// for i = 1 to mc_bases do
38451: LD_ADDR_VAR 0 2
38455: PUSH
38456: DOUBLE
38457: LD_INT 1
38459: DEC
38460: ST_TO_ADDR
38461: LD_EXP 110
38465: PUSH
38466: FOR_TO
38467: IFFALSE 38523
// if mc_bases [ i ] then
38469: LD_EXP 110
38473: PUSH
38474: LD_VAR 0 2
38478: ARRAY
38479: IFFALSE 38521
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38481: LD_ADDR_EXP 136
38485: PUSH
38486: LD_EXP 136
38490: PPUSH
38491: LD_VAR 0 2
38495: PPUSH
38496: LD_EXP 110
38500: PUSH
38501: LD_VAR 0 2
38505: ARRAY
38506: PUSH
38507: LD_INT 1
38509: ARRAY
38510: PPUSH
38511: CALL_OW 255
38515: PPUSH
38516: CALL_OW 1
38520: ST_TO_ADDR
38521: GO 38466
38523: POP
38524: POP
// end ;
38525: LD_VAR 0 1
38529: RET
// every 0 0$01 trigger skirmish do
38530: LD_EXP 108
38534: IFFALSE 38688
38536: GO 38538
38538: DISABLE
// begin enable ;
38539: ENABLE
// MC_CheckBuildings ( ) ;
38540: CALL 43186 0 0
// MC_CheckPeopleLife ( ) ;
38544: CALL 43311 0 0
// RaiseSailEvent ( 100 ) ;
38548: LD_INT 100
38550: PPUSH
38551: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38555: LD_INT 103
38557: PPUSH
38558: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38562: LD_INT 104
38564: PPUSH
38565: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38569: LD_INT 105
38571: PPUSH
38572: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38576: LD_INT 106
38578: PPUSH
38579: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38583: LD_INT 107
38585: PPUSH
38586: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38590: LD_INT 108
38592: PPUSH
38593: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38597: LD_INT 109
38599: PPUSH
38600: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38604: LD_INT 110
38606: PPUSH
38607: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38611: LD_INT 111
38613: PPUSH
38614: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
38618: LD_INT 112
38620: PPUSH
38621: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
38625: LD_INT 113
38627: PPUSH
38628: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
38632: LD_INT 120
38634: PPUSH
38635: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
38639: LD_INT 121
38641: PPUSH
38642: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
38646: LD_INT 122
38648: PPUSH
38649: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
38653: LD_INT 123
38655: PPUSH
38656: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
38660: LD_INT 124
38662: PPUSH
38663: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
38667: LD_INT 125
38669: PPUSH
38670: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
38674: LD_INT 126
38676: PPUSH
38677: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
38681: LD_INT 200
38683: PPUSH
38684: CALL_OW 427
// end ;
38688: END
// on SailEvent ( event ) do begin if event < 100 then
38689: LD_VAR 0 1
38693: PUSH
38694: LD_INT 100
38696: LESS
38697: IFFALSE 38708
// CustomEvent ( event ) ;
38699: LD_VAR 0 1
38703: PPUSH
38704: CALL 33284 0 1
// if event = 100 then
38708: LD_VAR 0 1
38712: PUSH
38713: LD_INT 100
38715: EQUAL
38716: IFFALSE 38722
// MC_ClassManager ( ) ;
38718: CALL 39114 0 0
// if event = 101 then
38722: LD_VAR 0 1
38726: PUSH
38727: LD_INT 101
38729: EQUAL
38730: IFFALSE 38736
// MC_RepairBuildings ( ) ;
38732: CALL 43907 0 0
// if event = 102 then
38736: LD_VAR 0 1
38740: PUSH
38741: LD_INT 102
38743: EQUAL
38744: IFFALSE 38750
// MC_Heal ( ) ;
38746: CALL 44771 0 0
// if event = 103 then
38750: LD_VAR 0 1
38754: PUSH
38755: LD_INT 103
38757: EQUAL
38758: IFFALSE 38764
// MC_Build ( ) ;
38760: CALL 45193 0 0
// if event = 104 then
38764: LD_VAR 0 1
38768: PUSH
38769: LD_INT 104
38771: EQUAL
38772: IFFALSE 38778
// MC_TurretWeapon ( ) ;
38774: CALL 46806 0 0
// if event = 105 then
38778: LD_VAR 0 1
38782: PUSH
38783: LD_INT 105
38785: EQUAL
38786: IFFALSE 38792
// MC_BuildUpgrade ( ) ;
38788: CALL 46357 0 0
// if event = 106 then
38792: LD_VAR 0 1
38796: PUSH
38797: LD_INT 106
38799: EQUAL
38800: IFFALSE 38806
// MC_PlantMines ( ) ;
38802: CALL 47236 0 0
// if event = 107 then
38806: LD_VAR 0 1
38810: PUSH
38811: LD_INT 107
38813: EQUAL
38814: IFFALSE 38820
// MC_CollectCrates ( ) ;
38816: CALL 48034 0 0
// if event = 108 then
38820: LD_VAR 0 1
38824: PUSH
38825: LD_INT 108
38827: EQUAL
38828: IFFALSE 38834
// MC_LinkRemoteControl ( ) ;
38830: CALL 49810 0 0
// if event = 109 then
38834: LD_VAR 0 1
38838: PUSH
38839: LD_INT 109
38841: EQUAL
38842: IFFALSE 38848
// MC_ProduceVehicle ( ) ;
38844: CALL 49991 0 0
// if event = 110 then
38848: LD_VAR 0 1
38852: PUSH
38853: LD_INT 110
38855: EQUAL
38856: IFFALSE 38862
// MC_SendAttack ( ) ;
38858: CALL 50457 0 0
// if event = 111 then
38862: LD_VAR 0 1
38866: PUSH
38867: LD_INT 111
38869: EQUAL
38870: IFFALSE 38876
// MC_Defend ( ) ;
38872: CALL 50565 0 0
// if event = 112 then
38876: LD_VAR 0 1
38880: PUSH
38881: LD_INT 112
38883: EQUAL
38884: IFFALSE 38890
// MC_Research ( ) ;
38886: CALL 51170 0 0
// if event = 113 then
38890: LD_VAR 0 1
38894: PUSH
38895: LD_INT 113
38897: EQUAL
38898: IFFALSE 38904
// MC_MinesTrigger ( ) ;
38900: CALL 52284 0 0
// if event = 120 then
38904: LD_VAR 0 1
38908: PUSH
38909: LD_INT 120
38911: EQUAL
38912: IFFALSE 38918
// MC_RepairVehicle ( ) ;
38914: CALL 52383 0 0
// if event = 121 then
38918: LD_VAR 0 1
38922: PUSH
38923: LD_INT 121
38925: EQUAL
38926: IFFALSE 38932
// MC_TameApe ( ) ;
38928: CALL 53113 0 0
// if event = 122 then
38932: LD_VAR 0 1
38936: PUSH
38937: LD_INT 122
38939: EQUAL
38940: IFFALSE 38946
// MC_ChangeApeClass ( ) ;
38942: CALL 53942 0 0
// if event = 123 then
38946: LD_VAR 0 1
38950: PUSH
38951: LD_INT 123
38953: EQUAL
38954: IFFALSE 38960
// MC_Bazooka ( ) ;
38956: CALL 54592 0 0
// if event = 124 then
38960: LD_VAR 0 1
38964: PUSH
38965: LD_INT 124
38967: EQUAL
38968: IFFALSE 38974
// MC_TeleportExit ( ) ;
38970: CALL 54790 0 0
// if event = 125 then
38974: LD_VAR 0 1
38978: PUSH
38979: LD_INT 125
38981: EQUAL
38982: IFFALSE 38988
// MC_Deposits ( ) ;
38984: CALL 55437 0 0
// if event = 126 then
38988: LD_VAR 0 1
38992: PUSH
38993: LD_INT 126
38995: EQUAL
38996: IFFALSE 39002
// MC_RemoteDriver ( ) ;
38998: CALL 56062 0 0
// if event = 200 then
39002: LD_VAR 0 1
39006: PUSH
39007: LD_INT 200
39009: EQUAL
39010: IFFALSE 39016
// MC_Idle ( ) ;
39012: CALL 58011 0 0
// end ;
39016: PPOPN 1
39018: END
// export function MC_Reset ( base , tag ) ; var i ; begin
39019: LD_INT 0
39021: PPUSH
39022: PPUSH
// if not mc_bases [ base ] or not tag then
39023: LD_EXP 110
39027: PUSH
39028: LD_VAR 0 1
39032: ARRAY
39033: NOT
39034: PUSH
39035: LD_VAR 0 2
39039: NOT
39040: OR
39041: IFFALSE 39045
// exit ;
39043: GO 39109
// for i in mc_bases [ base ] union mc_ape [ base ] do
39045: LD_ADDR_VAR 0 4
39049: PUSH
39050: LD_EXP 110
39054: PUSH
39055: LD_VAR 0 1
39059: ARRAY
39060: PUSH
39061: LD_EXP 139
39065: PUSH
39066: LD_VAR 0 1
39070: ARRAY
39071: UNION
39072: PUSH
39073: FOR_IN
39074: IFFALSE 39107
// if GetTag ( i ) = tag then
39076: LD_VAR 0 4
39080: PPUSH
39081: CALL_OW 110
39085: PUSH
39086: LD_VAR 0 2
39090: EQUAL
39091: IFFALSE 39105
// SetTag ( i , 0 ) ;
39093: LD_VAR 0 4
39097: PPUSH
39098: LD_INT 0
39100: PPUSH
39101: CALL_OW 109
39105: GO 39073
39107: POP
39108: POP
// end ;
39109: LD_VAR 0 3
39113: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39114: LD_INT 0
39116: PPUSH
39117: PPUSH
39118: PPUSH
39119: PPUSH
39120: PPUSH
39121: PPUSH
39122: PPUSH
39123: PPUSH
// if not mc_bases then
39124: LD_EXP 110
39128: NOT
39129: IFFALSE 39133
// exit ;
39131: GO 39591
// for i = 1 to mc_bases do
39133: LD_ADDR_VAR 0 2
39137: PUSH
39138: DOUBLE
39139: LD_INT 1
39141: DEC
39142: ST_TO_ADDR
39143: LD_EXP 110
39147: PUSH
39148: FOR_TO
39149: IFFALSE 39589
// begin tmp := MC_ClassCheckReq ( i ) ;
39151: LD_ADDR_VAR 0 4
39155: PUSH
39156: LD_VAR 0 2
39160: PPUSH
39161: CALL 39596 0 1
39165: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39166: LD_ADDR_EXP 151
39170: PUSH
39171: LD_EXP 151
39175: PPUSH
39176: LD_VAR 0 2
39180: PPUSH
39181: LD_VAR 0 4
39185: PPUSH
39186: CALL_OW 1
39190: ST_TO_ADDR
// if not tmp then
39191: LD_VAR 0 4
39195: NOT
39196: IFFALSE 39200
// continue ;
39198: GO 39148
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39200: LD_ADDR_VAR 0 6
39204: PUSH
39205: LD_EXP 110
39209: PUSH
39210: LD_VAR 0 2
39214: ARRAY
39215: PPUSH
39216: LD_INT 2
39218: PUSH
39219: LD_INT 30
39221: PUSH
39222: LD_INT 4
39224: PUSH
39225: EMPTY
39226: LIST
39227: LIST
39228: PUSH
39229: LD_INT 30
39231: PUSH
39232: LD_INT 5
39234: PUSH
39235: EMPTY
39236: LIST
39237: LIST
39238: PUSH
39239: EMPTY
39240: LIST
39241: LIST
39242: LIST
39243: PPUSH
39244: CALL_OW 72
39248: PUSH
39249: LD_EXP 110
39253: PUSH
39254: LD_VAR 0 2
39258: ARRAY
39259: PPUSH
39260: LD_INT 2
39262: PUSH
39263: LD_INT 30
39265: PUSH
39266: LD_INT 0
39268: PUSH
39269: EMPTY
39270: LIST
39271: LIST
39272: PUSH
39273: LD_INT 30
39275: PUSH
39276: LD_INT 1
39278: PUSH
39279: EMPTY
39280: LIST
39281: LIST
39282: PUSH
39283: EMPTY
39284: LIST
39285: LIST
39286: LIST
39287: PPUSH
39288: CALL_OW 72
39292: PUSH
39293: LD_EXP 110
39297: PUSH
39298: LD_VAR 0 2
39302: ARRAY
39303: PPUSH
39304: LD_INT 30
39306: PUSH
39307: LD_INT 3
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PPUSH
39314: CALL_OW 72
39318: PUSH
39319: LD_EXP 110
39323: PUSH
39324: LD_VAR 0 2
39328: ARRAY
39329: PPUSH
39330: LD_INT 2
39332: PUSH
39333: LD_INT 30
39335: PUSH
39336: LD_INT 6
39338: PUSH
39339: EMPTY
39340: LIST
39341: LIST
39342: PUSH
39343: LD_INT 30
39345: PUSH
39346: LD_INT 7
39348: PUSH
39349: EMPTY
39350: LIST
39351: LIST
39352: PUSH
39353: LD_INT 30
39355: PUSH
39356: LD_INT 8
39358: PUSH
39359: EMPTY
39360: LIST
39361: LIST
39362: PUSH
39363: EMPTY
39364: LIST
39365: LIST
39366: LIST
39367: LIST
39368: PPUSH
39369: CALL_OW 72
39373: PUSH
39374: EMPTY
39375: LIST
39376: LIST
39377: LIST
39378: LIST
39379: ST_TO_ADDR
// for j = 1 to 4 do
39380: LD_ADDR_VAR 0 3
39384: PUSH
39385: DOUBLE
39386: LD_INT 1
39388: DEC
39389: ST_TO_ADDR
39390: LD_INT 4
39392: PUSH
39393: FOR_TO
39394: IFFALSE 39585
// begin if not tmp [ j ] then
39396: LD_VAR 0 4
39400: PUSH
39401: LD_VAR 0 3
39405: ARRAY
39406: NOT
39407: IFFALSE 39411
// continue ;
39409: GO 39393
// for p in tmp [ j ] do
39411: LD_ADDR_VAR 0 5
39415: PUSH
39416: LD_VAR 0 4
39420: PUSH
39421: LD_VAR 0 3
39425: ARRAY
39426: PUSH
39427: FOR_IN
39428: IFFALSE 39581
// begin if not b [ j ] then
39430: LD_VAR 0 6
39434: PUSH
39435: LD_VAR 0 3
39439: ARRAY
39440: NOT
39441: IFFALSE 39445
// break ;
39443: GO 39581
// e := 0 ;
39445: LD_ADDR_VAR 0 7
39449: PUSH
39450: LD_INT 0
39452: ST_TO_ADDR
// for k in b [ j ] do
39453: LD_ADDR_VAR 0 8
39457: PUSH
39458: LD_VAR 0 6
39462: PUSH
39463: LD_VAR 0 3
39467: ARRAY
39468: PUSH
39469: FOR_IN
39470: IFFALSE 39497
// if IsNotFull ( k ) then
39472: LD_VAR 0 8
39476: PPUSH
39477: CALL 67192 0 1
39481: IFFALSE 39495
// begin e := k ;
39483: LD_ADDR_VAR 0 7
39487: PUSH
39488: LD_VAR 0 8
39492: ST_TO_ADDR
// break ;
39493: GO 39497
// end ;
39495: GO 39469
39497: POP
39498: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39499: LD_VAR 0 7
39503: PUSH
39504: LD_VAR 0 5
39508: PPUSH
39509: LD_VAR 0 7
39513: PPUSH
39514: CALL 99612 0 2
39518: NOT
39519: AND
39520: IFFALSE 39579
// begin if IsInUnit ( p ) then
39522: LD_VAR 0 5
39526: PPUSH
39527: CALL_OW 310
39531: IFFALSE 39542
// ComExitBuilding ( p ) ;
39533: LD_VAR 0 5
39537: PPUSH
39538: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39542: LD_VAR 0 5
39546: PPUSH
39547: LD_VAR 0 7
39551: PPUSH
39552: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39556: LD_VAR 0 5
39560: PPUSH
39561: LD_VAR 0 3
39565: PPUSH
39566: CALL_OW 183
// AddComExitBuilding ( p ) ;
39570: LD_VAR 0 5
39574: PPUSH
39575: CALL_OW 182
// end ; end ;
39579: GO 39427
39581: POP
39582: POP
// end ;
39583: GO 39393
39585: POP
39586: POP
// end ;
39587: GO 39148
39589: POP
39590: POP
// end ;
39591: LD_VAR 0 1
39595: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39596: LD_INT 0
39598: PPUSH
39599: PPUSH
39600: PPUSH
39601: PPUSH
39602: PPUSH
39603: PPUSH
39604: PPUSH
39605: PPUSH
39606: PPUSH
39607: PPUSH
39608: PPUSH
39609: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39610: LD_VAR 0 1
39614: NOT
39615: PUSH
39616: LD_EXP 110
39620: PUSH
39621: LD_VAR 0 1
39625: ARRAY
39626: NOT
39627: OR
39628: PUSH
39629: LD_EXP 110
39633: PUSH
39634: LD_VAR 0 1
39638: ARRAY
39639: PPUSH
39640: LD_INT 2
39642: PUSH
39643: LD_INT 30
39645: PUSH
39646: LD_INT 0
39648: PUSH
39649: EMPTY
39650: LIST
39651: LIST
39652: PUSH
39653: LD_INT 30
39655: PUSH
39656: LD_INT 1
39658: PUSH
39659: EMPTY
39660: LIST
39661: LIST
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: LIST
39667: PPUSH
39668: CALL_OW 72
39672: NOT
39673: OR
39674: IFFALSE 39678
// exit ;
39676: GO 43181
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39678: LD_ADDR_VAR 0 4
39682: PUSH
39683: LD_EXP 110
39687: PUSH
39688: LD_VAR 0 1
39692: ARRAY
39693: PPUSH
39694: LD_INT 2
39696: PUSH
39697: LD_INT 25
39699: PUSH
39700: LD_INT 1
39702: PUSH
39703: EMPTY
39704: LIST
39705: LIST
39706: PUSH
39707: LD_INT 25
39709: PUSH
39710: LD_INT 2
39712: PUSH
39713: EMPTY
39714: LIST
39715: LIST
39716: PUSH
39717: LD_INT 25
39719: PUSH
39720: LD_INT 3
39722: PUSH
39723: EMPTY
39724: LIST
39725: LIST
39726: PUSH
39727: LD_INT 25
39729: PUSH
39730: LD_INT 4
39732: PUSH
39733: EMPTY
39734: LIST
39735: LIST
39736: PUSH
39737: LD_INT 25
39739: PUSH
39740: LD_INT 5
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: LD_INT 25
39749: PUSH
39750: LD_INT 8
39752: PUSH
39753: EMPTY
39754: LIST
39755: LIST
39756: PUSH
39757: LD_INT 25
39759: PUSH
39760: LD_INT 9
39762: PUSH
39763: EMPTY
39764: LIST
39765: LIST
39766: PUSH
39767: EMPTY
39768: LIST
39769: LIST
39770: LIST
39771: LIST
39772: LIST
39773: LIST
39774: LIST
39775: LIST
39776: PPUSH
39777: CALL_OW 72
39781: ST_TO_ADDR
// if not tmp then
39782: LD_VAR 0 4
39786: NOT
39787: IFFALSE 39791
// exit ;
39789: GO 43181
// for i in tmp do
39791: LD_ADDR_VAR 0 3
39795: PUSH
39796: LD_VAR 0 4
39800: PUSH
39801: FOR_IN
39802: IFFALSE 39833
// if GetTag ( i ) then
39804: LD_VAR 0 3
39808: PPUSH
39809: CALL_OW 110
39813: IFFALSE 39831
// tmp := tmp diff i ;
39815: LD_ADDR_VAR 0 4
39819: PUSH
39820: LD_VAR 0 4
39824: PUSH
39825: LD_VAR 0 3
39829: DIFF
39830: ST_TO_ADDR
39831: GO 39801
39833: POP
39834: POP
// if not tmp then
39835: LD_VAR 0 4
39839: NOT
39840: IFFALSE 39844
// exit ;
39842: GO 43181
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39844: LD_ADDR_VAR 0 5
39848: PUSH
39849: LD_EXP 110
39853: PUSH
39854: LD_VAR 0 1
39858: ARRAY
39859: PPUSH
39860: LD_INT 2
39862: PUSH
39863: LD_INT 25
39865: PUSH
39866: LD_INT 1
39868: PUSH
39869: EMPTY
39870: LIST
39871: LIST
39872: PUSH
39873: LD_INT 25
39875: PUSH
39876: LD_INT 5
39878: PUSH
39879: EMPTY
39880: LIST
39881: LIST
39882: PUSH
39883: LD_INT 25
39885: PUSH
39886: LD_INT 8
39888: PUSH
39889: EMPTY
39890: LIST
39891: LIST
39892: PUSH
39893: LD_INT 25
39895: PUSH
39896: LD_INT 9
39898: PUSH
39899: EMPTY
39900: LIST
39901: LIST
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: LIST
39907: LIST
39908: LIST
39909: PPUSH
39910: CALL_OW 72
39914: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
39915: LD_ADDR_VAR 0 6
39919: PUSH
39920: LD_EXP 110
39924: PUSH
39925: LD_VAR 0 1
39929: ARRAY
39930: PPUSH
39931: LD_INT 25
39933: PUSH
39934: LD_INT 2
39936: PUSH
39937: EMPTY
39938: LIST
39939: LIST
39940: PPUSH
39941: CALL_OW 72
39945: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
39946: LD_ADDR_VAR 0 7
39950: PUSH
39951: LD_EXP 110
39955: PUSH
39956: LD_VAR 0 1
39960: ARRAY
39961: PPUSH
39962: LD_INT 25
39964: PUSH
39965: LD_INT 3
39967: PUSH
39968: EMPTY
39969: LIST
39970: LIST
39971: PPUSH
39972: CALL_OW 72
39976: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
39977: LD_ADDR_VAR 0 8
39981: PUSH
39982: LD_EXP 110
39986: PUSH
39987: LD_VAR 0 1
39991: ARRAY
39992: PPUSH
39993: LD_INT 25
39995: PUSH
39996: LD_INT 4
39998: PUSH
39999: EMPTY
40000: LIST
40001: LIST
40002: PUSH
40003: LD_INT 24
40005: PUSH
40006: LD_INT 251
40008: PUSH
40009: EMPTY
40010: LIST
40011: LIST
40012: PUSH
40013: EMPTY
40014: LIST
40015: LIST
40016: PPUSH
40017: CALL_OW 72
40021: ST_TO_ADDR
// if mc_scan [ base ] then
40022: LD_EXP 133
40026: PUSH
40027: LD_VAR 0 1
40031: ARRAY
40032: IFFALSE 40493
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
40034: LD_ADDR_EXP 152
40038: PUSH
40039: LD_EXP 152
40043: PPUSH
40044: LD_VAR 0 1
40048: PPUSH
40049: LD_INT 4
40051: PPUSH
40052: CALL_OW 1
40056: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40057: LD_ADDR_VAR 0 12
40061: PUSH
40062: LD_EXP 110
40066: PUSH
40067: LD_VAR 0 1
40071: ARRAY
40072: PPUSH
40073: LD_INT 2
40075: PUSH
40076: LD_INT 30
40078: PUSH
40079: LD_INT 4
40081: PUSH
40082: EMPTY
40083: LIST
40084: LIST
40085: PUSH
40086: LD_INT 30
40088: PUSH
40089: LD_INT 5
40091: PUSH
40092: EMPTY
40093: LIST
40094: LIST
40095: PUSH
40096: EMPTY
40097: LIST
40098: LIST
40099: LIST
40100: PPUSH
40101: CALL_OW 72
40105: ST_TO_ADDR
// if not b then
40106: LD_VAR 0 12
40110: NOT
40111: IFFALSE 40115
// exit ;
40113: GO 43181
// p := [ ] ;
40115: LD_ADDR_VAR 0 11
40119: PUSH
40120: EMPTY
40121: ST_TO_ADDR
// if sci >= 2 then
40122: LD_VAR 0 8
40126: PUSH
40127: LD_INT 2
40129: GREATEREQUAL
40130: IFFALSE 40161
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40132: LD_ADDR_VAR 0 8
40136: PUSH
40137: LD_VAR 0 8
40141: PUSH
40142: LD_INT 1
40144: ARRAY
40145: PUSH
40146: LD_VAR 0 8
40150: PUSH
40151: LD_INT 2
40153: ARRAY
40154: PUSH
40155: EMPTY
40156: LIST
40157: LIST
40158: ST_TO_ADDR
40159: GO 40222
// if sci = 1 then
40161: LD_VAR 0 8
40165: PUSH
40166: LD_INT 1
40168: EQUAL
40169: IFFALSE 40190
// sci := [ sci [ 1 ] ] else
40171: LD_ADDR_VAR 0 8
40175: PUSH
40176: LD_VAR 0 8
40180: PUSH
40181: LD_INT 1
40183: ARRAY
40184: PUSH
40185: EMPTY
40186: LIST
40187: ST_TO_ADDR
40188: GO 40222
// if sci = 0 then
40190: LD_VAR 0 8
40194: PUSH
40195: LD_INT 0
40197: EQUAL
40198: IFFALSE 40222
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40200: LD_ADDR_VAR 0 11
40204: PUSH
40205: LD_VAR 0 4
40209: PPUSH
40210: LD_INT 4
40212: PPUSH
40213: CALL 99475 0 2
40217: PUSH
40218: LD_INT 1
40220: ARRAY
40221: ST_TO_ADDR
// if eng > 4 then
40222: LD_VAR 0 6
40226: PUSH
40227: LD_INT 4
40229: GREATER
40230: IFFALSE 40276
// for i = eng downto 4 do
40232: LD_ADDR_VAR 0 3
40236: PUSH
40237: DOUBLE
40238: LD_VAR 0 6
40242: INC
40243: ST_TO_ADDR
40244: LD_INT 4
40246: PUSH
40247: FOR_DOWNTO
40248: IFFALSE 40274
// eng := eng diff eng [ i ] ;
40250: LD_ADDR_VAR 0 6
40254: PUSH
40255: LD_VAR 0 6
40259: PUSH
40260: LD_VAR 0 6
40264: PUSH
40265: LD_VAR 0 3
40269: ARRAY
40270: DIFF
40271: ST_TO_ADDR
40272: GO 40247
40274: POP
40275: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40276: LD_ADDR_VAR 0 4
40280: PUSH
40281: LD_VAR 0 4
40285: PUSH
40286: LD_VAR 0 5
40290: PUSH
40291: LD_VAR 0 6
40295: UNION
40296: PUSH
40297: LD_VAR 0 7
40301: UNION
40302: PUSH
40303: LD_VAR 0 8
40307: UNION
40308: DIFF
40309: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40310: LD_ADDR_VAR 0 13
40314: PUSH
40315: LD_EXP 110
40319: PUSH
40320: LD_VAR 0 1
40324: ARRAY
40325: PPUSH
40326: LD_INT 2
40328: PUSH
40329: LD_INT 30
40331: PUSH
40332: LD_INT 32
40334: PUSH
40335: EMPTY
40336: LIST
40337: LIST
40338: PUSH
40339: LD_INT 30
40341: PUSH
40342: LD_INT 31
40344: PUSH
40345: EMPTY
40346: LIST
40347: LIST
40348: PUSH
40349: EMPTY
40350: LIST
40351: LIST
40352: LIST
40353: PPUSH
40354: CALL_OW 72
40358: PUSH
40359: LD_EXP 110
40363: PUSH
40364: LD_VAR 0 1
40368: ARRAY
40369: PPUSH
40370: LD_INT 2
40372: PUSH
40373: LD_INT 30
40375: PUSH
40376: LD_INT 4
40378: PUSH
40379: EMPTY
40380: LIST
40381: LIST
40382: PUSH
40383: LD_INT 30
40385: PUSH
40386: LD_INT 5
40388: PUSH
40389: EMPTY
40390: LIST
40391: LIST
40392: PUSH
40393: EMPTY
40394: LIST
40395: LIST
40396: LIST
40397: PPUSH
40398: CALL_OW 72
40402: PUSH
40403: LD_INT 6
40405: MUL
40406: PLUS
40407: ST_TO_ADDR
// if bcount < tmp then
40408: LD_VAR 0 13
40412: PUSH
40413: LD_VAR 0 4
40417: LESS
40418: IFFALSE 40464
// for i = tmp downto bcount do
40420: LD_ADDR_VAR 0 3
40424: PUSH
40425: DOUBLE
40426: LD_VAR 0 4
40430: INC
40431: ST_TO_ADDR
40432: LD_VAR 0 13
40436: PUSH
40437: FOR_DOWNTO
40438: IFFALSE 40462
// tmp := Delete ( tmp , tmp ) ;
40440: LD_ADDR_VAR 0 4
40444: PUSH
40445: LD_VAR 0 4
40449: PPUSH
40450: LD_VAR 0 4
40454: PPUSH
40455: CALL_OW 3
40459: ST_TO_ADDR
40460: GO 40437
40462: POP
40463: POP
// result := [ tmp , 0 , 0 , p ] ;
40464: LD_ADDR_VAR 0 2
40468: PUSH
40469: LD_VAR 0 4
40473: PUSH
40474: LD_INT 0
40476: PUSH
40477: LD_INT 0
40479: PUSH
40480: LD_VAR 0 11
40484: PUSH
40485: EMPTY
40486: LIST
40487: LIST
40488: LIST
40489: LIST
40490: ST_TO_ADDR
// exit ;
40491: GO 43181
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40493: LD_EXP 110
40497: PUSH
40498: LD_VAR 0 1
40502: ARRAY
40503: PPUSH
40504: LD_INT 2
40506: PUSH
40507: LD_INT 30
40509: PUSH
40510: LD_INT 6
40512: PUSH
40513: EMPTY
40514: LIST
40515: LIST
40516: PUSH
40517: LD_INT 30
40519: PUSH
40520: LD_INT 7
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: PUSH
40527: LD_INT 30
40529: PUSH
40530: LD_INT 8
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: PUSH
40537: EMPTY
40538: LIST
40539: LIST
40540: LIST
40541: LIST
40542: PPUSH
40543: CALL_OW 72
40547: NOT
40548: PUSH
40549: LD_EXP 110
40553: PUSH
40554: LD_VAR 0 1
40558: ARRAY
40559: PPUSH
40560: LD_INT 30
40562: PUSH
40563: LD_INT 3
40565: PUSH
40566: EMPTY
40567: LIST
40568: LIST
40569: PPUSH
40570: CALL_OW 72
40574: NOT
40575: AND
40576: IFFALSE 40648
// begin if eng = tmp then
40578: LD_VAR 0 6
40582: PUSH
40583: LD_VAR 0 4
40587: EQUAL
40588: IFFALSE 40592
// exit ;
40590: GO 43181
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40592: LD_ADDR_EXP 152
40596: PUSH
40597: LD_EXP 152
40601: PPUSH
40602: LD_VAR 0 1
40606: PPUSH
40607: LD_INT 1
40609: PPUSH
40610: CALL_OW 1
40614: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
40615: LD_ADDR_VAR 0 2
40619: PUSH
40620: LD_INT 0
40622: PUSH
40623: LD_VAR 0 4
40627: PUSH
40628: LD_VAR 0 6
40632: DIFF
40633: PUSH
40634: LD_INT 0
40636: PUSH
40637: LD_INT 0
40639: PUSH
40640: EMPTY
40641: LIST
40642: LIST
40643: LIST
40644: LIST
40645: ST_TO_ADDR
// exit ;
40646: GO 43181
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40648: LD_EXP 137
40652: PUSH
40653: LD_EXP 136
40657: PUSH
40658: LD_VAR 0 1
40662: ARRAY
40663: ARRAY
40664: PUSH
40665: LD_EXP 110
40669: PUSH
40670: LD_VAR 0 1
40674: ARRAY
40675: PPUSH
40676: LD_INT 2
40678: PUSH
40679: LD_INT 30
40681: PUSH
40682: LD_INT 6
40684: PUSH
40685: EMPTY
40686: LIST
40687: LIST
40688: PUSH
40689: LD_INT 30
40691: PUSH
40692: LD_INT 7
40694: PUSH
40695: EMPTY
40696: LIST
40697: LIST
40698: PUSH
40699: LD_INT 30
40701: PUSH
40702: LD_INT 8
40704: PUSH
40705: EMPTY
40706: LIST
40707: LIST
40708: PUSH
40709: EMPTY
40710: LIST
40711: LIST
40712: LIST
40713: LIST
40714: PPUSH
40715: CALL_OW 72
40719: AND
40720: PUSH
40721: LD_EXP 110
40725: PUSH
40726: LD_VAR 0 1
40730: ARRAY
40731: PPUSH
40732: LD_INT 30
40734: PUSH
40735: LD_INT 3
40737: PUSH
40738: EMPTY
40739: LIST
40740: LIST
40741: PPUSH
40742: CALL_OW 72
40746: NOT
40747: AND
40748: IFFALSE 40962
// begin if sci >= 6 then
40750: LD_VAR 0 8
40754: PUSH
40755: LD_INT 6
40757: GREATEREQUAL
40758: IFFALSE 40762
// exit ;
40760: GO 43181
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
40762: LD_ADDR_EXP 152
40766: PUSH
40767: LD_EXP 152
40771: PPUSH
40772: LD_VAR 0 1
40776: PPUSH
40777: LD_INT 2
40779: PPUSH
40780: CALL_OW 1
40784: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
40785: LD_ADDR_VAR 0 9
40789: PUSH
40790: LD_VAR 0 4
40794: PUSH
40795: LD_VAR 0 8
40799: DIFF
40800: PPUSH
40801: LD_INT 4
40803: PPUSH
40804: CALL 99475 0 2
40808: ST_TO_ADDR
// p := [ ] ;
40809: LD_ADDR_VAR 0 11
40813: PUSH
40814: EMPTY
40815: ST_TO_ADDR
// if sci < 6 and sort > 6 then
40816: LD_VAR 0 8
40820: PUSH
40821: LD_INT 6
40823: LESS
40824: PUSH
40825: LD_VAR 0 9
40829: PUSH
40830: LD_INT 6
40832: GREATER
40833: AND
40834: IFFALSE 40915
// begin for i = 1 to 6 - sci do
40836: LD_ADDR_VAR 0 3
40840: PUSH
40841: DOUBLE
40842: LD_INT 1
40844: DEC
40845: ST_TO_ADDR
40846: LD_INT 6
40848: PUSH
40849: LD_VAR 0 8
40853: MINUS
40854: PUSH
40855: FOR_TO
40856: IFFALSE 40911
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
40858: LD_ADDR_VAR 0 11
40862: PUSH
40863: LD_VAR 0 11
40867: PPUSH
40868: LD_VAR 0 11
40872: PUSH
40873: LD_INT 1
40875: PLUS
40876: PPUSH
40877: LD_VAR 0 9
40881: PUSH
40882: LD_INT 1
40884: ARRAY
40885: PPUSH
40886: CALL_OW 2
40890: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
40891: LD_ADDR_VAR 0 9
40895: PUSH
40896: LD_VAR 0 9
40900: PPUSH
40901: LD_INT 1
40903: PPUSH
40904: CALL_OW 3
40908: ST_TO_ADDR
// end ;
40909: GO 40855
40911: POP
40912: POP
// end else
40913: GO 40935
// if sort then
40915: LD_VAR 0 9
40919: IFFALSE 40935
// p := sort [ 1 ] ;
40921: LD_ADDR_VAR 0 11
40925: PUSH
40926: LD_VAR 0 9
40930: PUSH
40931: LD_INT 1
40933: ARRAY
40934: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
40935: LD_ADDR_VAR 0 2
40939: PUSH
40940: LD_INT 0
40942: PUSH
40943: LD_INT 0
40945: PUSH
40946: LD_INT 0
40948: PUSH
40949: LD_VAR 0 11
40953: PUSH
40954: EMPTY
40955: LIST
40956: LIST
40957: LIST
40958: LIST
40959: ST_TO_ADDR
// exit ;
40960: GO 43181
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40962: LD_EXP 137
40966: PUSH
40967: LD_EXP 136
40971: PUSH
40972: LD_VAR 0 1
40976: ARRAY
40977: ARRAY
40978: PUSH
40979: LD_EXP 110
40983: PUSH
40984: LD_VAR 0 1
40988: ARRAY
40989: PPUSH
40990: LD_INT 2
40992: PUSH
40993: LD_INT 30
40995: PUSH
40996: LD_INT 6
40998: PUSH
40999: EMPTY
41000: LIST
41001: LIST
41002: PUSH
41003: LD_INT 30
41005: PUSH
41006: LD_INT 7
41008: PUSH
41009: EMPTY
41010: LIST
41011: LIST
41012: PUSH
41013: LD_INT 30
41015: PUSH
41016: LD_INT 8
41018: PUSH
41019: EMPTY
41020: LIST
41021: LIST
41022: PUSH
41023: EMPTY
41024: LIST
41025: LIST
41026: LIST
41027: LIST
41028: PPUSH
41029: CALL_OW 72
41033: AND
41034: PUSH
41035: LD_EXP 110
41039: PUSH
41040: LD_VAR 0 1
41044: ARRAY
41045: PPUSH
41046: LD_INT 30
41048: PUSH
41049: LD_INT 3
41051: PUSH
41052: EMPTY
41053: LIST
41054: LIST
41055: PPUSH
41056: CALL_OW 72
41060: AND
41061: IFFALSE 41795
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
41063: LD_ADDR_EXP 152
41067: PUSH
41068: LD_EXP 152
41072: PPUSH
41073: LD_VAR 0 1
41077: PPUSH
41078: LD_INT 3
41080: PPUSH
41081: CALL_OW 1
41085: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41086: LD_ADDR_VAR 0 2
41090: PUSH
41091: LD_INT 0
41093: PUSH
41094: LD_INT 0
41096: PUSH
41097: LD_INT 0
41099: PUSH
41100: LD_INT 0
41102: PUSH
41103: EMPTY
41104: LIST
41105: LIST
41106: LIST
41107: LIST
41108: ST_TO_ADDR
// if not eng then
41109: LD_VAR 0 6
41113: NOT
41114: IFFALSE 41177
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41116: LD_ADDR_VAR 0 11
41120: PUSH
41121: LD_VAR 0 4
41125: PPUSH
41126: LD_INT 2
41128: PPUSH
41129: CALL 99475 0 2
41133: PUSH
41134: LD_INT 1
41136: ARRAY
41137: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41138: LD_ADDR_VAR 0 2
41142: PUSH
41143: LD_VAR 0 2
41147: PPUSH
41148: LD_INT 2
41150: PPUSH
41151: LD_VAR 0 11
41155: PPUSH
41156: CALL_OW 1
41160: ST_TO_ADDR
// tmp := tmp diff p ;
41161: LD_ADDR_VAR 0 4
41165: PUSH
41166: LD_VAR 0 4
41170: PUSH
41171: LD_VAR 0 11
41175: DIFF
41176: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41177: LD_VAR 0 4
41181: PUSH
41182: LD_VAR 0 8
41186: PUSH
41187: LD_INT 6
41189: LESS
41190: AND
41191: IFFALSE 41379
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41193: LD_ADDR_VAR 0 9
41197: PUSH
41198: LD_VAR 0 4
41202: PUSH
41203: LD_VAR 0 8
41207: PUSH
41208: LD_VAR 0 7
41212: UNION
41213: DIFF
41214: PPUSH
41215: LD_INT 4
41217: PPUSH
41218: CALL 99475 0 2
41222: ST_TO_ADDR
// p := [ ] ;
41223: LD_ADDR_VAR 0 11
41227: PUSH
41228: EMPTY
41229: ST_TO_ADDR
// if sort then
41230: LD_VAR 0 9
41234: IFFALSE 41350
// for i = 1 to 6 - sci do
41236: LD_ADDR_VAR 0 3
41240: PUSH
41241: DOUBLE
41242: LD_INT 1
41244: DEC
41245: ST_TO_ADDR
41246: LD_INT 6
41248: PUSH
41249: LD_VAR 0 8
41253: MINUS
41254: PUSH
41255: FOR_TO
41256: IFFALSE 41348
// begin if i = sort then
41258: LD_VAR 0 3
41262: PUSH
41263: LD_VAR 0 9
41267: EQUAL
41268: IFFALSE 41272
// break ;
41270: GO 41348
// if GetClass ( i ) = 4 then
41272: LD_VAR 0 3
41276: PPUSH
41277: CALL_OW 257
41281: PUSH
41282: LD_INT 4
41284: EQUAL
41285: IFFALSE 41289
// continue ;
41287: GO 41255
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41289: LD_ADDR_VAR 0 11
41293: PUSH
41294: LD_VAR 0 11
41298: PPUSH
41299: LD_VAR 0 11
41303: PUSH
41304: LD_INT 1
41306: PLUS
41307: PPUSH
41308: LD_VAR 0 9
41312: PUSH
41313: LD_VAR 0 3
41317: ARRAY
41318: PPUSH
41319: CALL_OW 2
41323: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41324: LD_ADDR_VAR 0 4
41328: PUSH
41329: LD_VAR 0 4
41333: PUSH
41334: LD_VAR 0 9
41338: PUSH
41339: LD_VAR 0 3
41343: ARRAY
41344: DIFF
41345: ST_TO_ADDR
// end ;
41346: GO 41255
41348: POP
41349: POP
// if p then
41350: LD_VAR 0 11
41354: IFFALSE 41379
// result := Replace ( result , 4 , p ) ;
41356: LD_ADDR_VAR 0 2
41360: PUSH
41361: LD_VAR 0 2
41365: PPUSH
41366: LD_INT 4
41368: PPUSH
41369: LD_VAR 0 11
41373: PPUSH
41374: CALL_OW 1
41378: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41379: LD_VAR 0 4
41383: PUSH
41384: LD_VAR 0 7
41388: PUSH
41389: LD_INT 6
41391: LESS
41392: AND
41393: IFFALSE 41581
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41395: LD_ADDR_VAR 0 9
41399: PUSH
41400: LD_VAR 0 4
41404: PUSH
41405: LD_VAR 0 8
41409: PUSH
41410: LD_VAR 0 7
41414: UNION
41415: DIFF
41416: PPUSH
41417: LD_INT 3
41419: PPUSH
41420: CALL 99475 0 2
41424: ST_TO_ADDR
// p := [ ] ;
41425: LD_ADDR_VAR 0 11
41429: PUSH
41430: EMPTY
41431: ST_TO_ADDR
// if sort then
41432: LD_VAR 0 9
41436: IFFALSE 41552
// for i = 1 to 6 - mech do
41438: LD_ADDR_VAR 0 3
41442: PUSH
41443: DOUBLE
41444: LD_INT 1
41446: DEC
41447: ST_TO_ADDR
41448: LD_INT 6
41450: PUSH
41451: LD_VAR 0 7
41455: MINUS
41456: PUSH
41457: FOR_TO
41458: IFFALSE 41550
// begin if i = sort then
41460: LD_VAR 0 3
41464: PUSH
41465: LD_VAR 0 9
41469: EQUAL
41470: IFFALSE 41474
// break ;
41472: GO 41550
// if GetClass ( i ) = 3 then
41474: LD_VAR 0 3
41478: PPUSH
41479: CALL_OW 257
41483: PUSH
41484: LD_INT 3
41486: EQUAL
41487: IFFALSE 41491
// continue ;
41489: GO 41457
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41491: LD_ADDR_VAR 0 11
41495: PUSH
41496: LD_VAR 0 11
41500: PPUSH
41501: LD_VAR 0 11
41505: PUSH
41506: LD_INT 1
41508: PLUS
41509: PPUSH
41510: LD_VAR 0 9
41514: PUSH
41515: LD_VAR 0 3
41519: ARRAY
41520: PPUSH
41521: CALL_OW 2
41525: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41526: LD_ADDR_VAR 0 4
41530: PUSH
41531: LD_VAR 0 4
41535: PUSH
41536: LD_VAR 0 9
41540: PUSH
41541: LD_VAR 0 3
41545: ARRAY
41546: DIFF
41547: ST_TO_ADDR
// end ;
41548: GO 41457
41550: POP
41551: POP
// if p then
41552: LD_VAR 0 11
41556: IFFALSE 41581
// result := Replace ( result , 3 , p ) ;
41558: LD_ADDR_VAR 0 2
41562: PUSH
41563: LD_VAR 0 2
41567: PPUSH
41568: LD_INT 3
41570: PPUSH
41571: LD_VAR 0 11
41575: PPUSH
41576: CALL_OW 1
41580: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41581: LD_VAR 0 4
41585: PUSH
41586: LD_INT 6
41588: GREATER
41589: PUSH
41590: LD_VAR 0 6
41594: PUSH
41595: LD_INT 6
41597: LESS
41598: AND
41599: IFFALSE 41793
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41601: LD_ADDR_VAR 0 9
41605: PUSH
41606: LD_VAR 0 4
41610: PUSH
41611: LD_VAR 0 8
41615: PUSH
41616: LD_VAR 0 7
41620: UNION
41621: PUSH
41622: LD_VAR 0 6
41626: UNION
41627: DIFF
41628: PPUSH
41629: LD_INT 2
41631: PPUSH
41632: CALL 99475 0 2
41636: ST_TO_ADDR
// p := [ ] ;
41637: LD_ADDR_VAR 0 11
41641: PUSH
41642: EMPTY
41643: ST_TO_ADDR
// if sort then
41644: LD_VAR 0 9
41648: IFFALSE 41764
// for i = 1 to 6 - eng do
41650: LD_ADDR_VAR 0 3
41654: PUSH
41655: DOUBLE
41656: LD_INT 1
41658: DEC
41659: ST_TO_ADDR
41660: LD_INT 6
41662: PUSH
41663: LD_VAR 0 6
41667: MINUS
41668: PUSH
41669: FOR_TO
41670: IFFALSE 41762
// begin if i = sort then
41672: LD_VAR 0 3
41676: PUSH
41677: LD_VAR 0 9
41681: EQUAL
41682: IFFALSE 41686
// break ;
41684: GO 41762
// if GetClass ( i ) = 2 then
41686: LD_VAR 0 3
41690: PPUSH
41691: CALL_OW 257
41695: PUSH
41696: LD_INT 2
41698: EQUAL
41699: IFFALSE 41703
// continue ;
41701: GO 41669
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41703: LD_ADDR_VAR 0 11
41707: PUSH
41708: LD_VAR 0 11
41712: PPUSH
41713: LD_VAR 0 11
41717: PUSH
41718: LD_INT 1
41720: PLUS
41721: PPUSH
41722: LD_VAR 0 9
41726: PUSH
41727: LD_VAR 0 3
41731: ARRAY
41732: PPUSH
41733: CALL_OW 2
41737: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41738: LD_ADDR_VAR 0 4
41742: PUSH
41743: LD_VAR 0 4
41747: PUSH
41748: LD_VAR 0 9
41752: PUSH
41753: LD_VAR 0 3
41757: ARRAY
41758: DIFF
41759: ST_TO_ADDR
// end ;
41760: GO 41669
41762: POP
41763: POP
// if p then
41764: LD_VAR 0 11
41768: IFFALSE 41793
// result := Replace ( result , 2 , p ) ;
41770: LD_ADDR_VAR 0 2
41774: PUSH
41775: LD_VAR 0 2
41779: PPUSH
41780: LD_INT 2
41782: PPUSH
41783: LD_VAR 0 11
41787: PPUSH
41788: CALL_OW 1
41792: ST_TO_ADDR
// end ; exit ;
41793: GO 43181
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
41795: LD_EXP 137
41799: PUSH
41800: LD_EXP 136
41804: PUSH
41805: LD_VAR 0 1
41809: ARRAY
41810: ARRAY
41811: NOT
41812: PUSH
41813: LD_EXP 110
41817: PUSH
41818: LD_VAR 0 1
41822: ARRAY
41823: PPUSH
41824: LD_INT 30
41826: PUSH
41827: LD_INT 3
41829: PUSH
41830: EMPTY
41831: LIST
41832: LIST
41833: PPUSH
41834: CALL_OW 72
41838: AND
41839: PUSH
41840: LD_EXP 115
41844: PUSH
41845: LD_VAR 0 1
41849: ARRAY
41850: AND
41851: IFFALSE 42459
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
41853: LD_ADDR_EXP 152
41857: PUSH
41858: LD_EXP 152
41862: PPUSH
41863: LD_VAR 0 1
41867: PPUSH
41868: LD_INT 5
41870: PPUSH
41871: CALL_OW 1
41875: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41876: LD_ADDR_VAR 0 2
41880: PUSH
41881: LD_INT 0
41883: PUSH
41884: LD_INT 0
41886: PUSH
41887: LD_INT 0
41889: PUSH
41890: LD_INT 0
41892: PUSH
41893: EMPTY
41894: LIST
41895: LIST
41896: LIST
41897: LIST
41898: ST_TO_ADDR
// if sci > 1 then
41899: LD_VAR 0 8
41903: PUSH
41904: LD_INT 1
41906: GREATER
41907: IFFALSE 41935
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
41909: LD_ADDR_VAR 0 4
41913: PUSH
41914: LD_VAR 0 4
41918: PUSH
41919: LD_VAR 0 8
41923: PUSH
41924: LD_VAR 0 8
41928: PUSH
41929: LD_INT 1
41931: ARRAY
41932: DIFF
41933: DIFF
41934: ST_TO_ADDR
// if tmp and not sci then
41935: LD_VAR 0 4
41939: PUSH
41940: LD_VAR 0 8
41944: NOT
41945: AND
41946: IFFALSE 42015
// begin sort := SortBySkill ( tmp , 4 ) ;
41948: LD_ADDR_VAR 0 9
41952: PUSH
41953: LD_VAR 0 4
41957: PPUSH
41958: LD_INT 4
41960: PPUSH
41961: CALL 99475 0 2
41965: ST_TO_ADDR
// if sort then
41966: LD_VAR 0 9
41970: IFFALSE 41986
// p := sort [ 1 ] ;
41972: LD_ADDR_VAR 0 11
41976: PUSH
41977: LD_VAR 0 9
41981: PUSH
41982: LD_INT 1
41984: ARRAY
41985: ST_TO_ADDR
// if p then
41986: LD_VAR 0 11
41990: IFFALSE 42015
// result := Replace ( result , 4 , p ) ;
41992: LD_ADDR_VAR 0 2
41996: PUSH
41997: LD_VAR 0 2
42001: PPUSH
42002: LD_INT 4
42004: PPUSH
42005: LD_VAR 0 11
42009: PPUSH
42010: CALL_OW 1
42014: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42015: LD_ADDR_VAR 0 4
42019: PUSH
42020: LD_VAR 0 4
42024: PUSH
42025: LD_VAR 0 7
42029: DIFF
42030: ST_TO_ADDR
// if tmp and mech < 6 then
42031: LD_VAR 0 4
42035: PUSH
42036: LD_VAR 0 7
42040: PUSH
42041: LD_INT 6
42043: LESS
42044: AND
42045: IFFALSE 42233
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
42047: LD_ADDR_VAR 0 9
42051: PUSH
42052: LD_VAR 0 4
42056: PUSH
42057: LD_VAR 0 8
42061: PUSH
42062: LD_VAR 0 7
42066: UNION
42067: DIFF
42068: PPUSH
42069: LD_INT 3
42071: PPUSH
42072: CALL 99475 0 2
42076: ST_TO_ADDR
// p := [ ] ;
42077: LD_ADDR_VAR 0 11
42081: PUSH
42082: EMPTY
42083: ST_TO_ADDR
// if sort then
42084: LD_VAR 0 9
42088: IFFALSE 42204
// for i = 1 to 6 - mech do
42090: LD_ADDR_VAR 0 3
42094: PUSH
42095: DOUBLE
42096: LD_INT 1
42098: DEC
42099: ST_TO_ADDR
42100: LD_INT 6
42102: PUSH
42103: LD_VAR 0 7
42107: MINUS
42108: PUSH
42109: FOR_TO
42110: IFFALSE 42202
// begin if i = sort then
42112: LD_VAR 0 3
42116: PUSH
42117: LD_VAR 0 9
42121: EQUAL
42122: IFFALSE 42126
// break ;
42124: GO 42202
// if GetClass ( i ) = 3 then
42126: LD_VAR 0 3
42130: PPUSH
42131: CALL_OW 257
42135: PUSH
42136: LD_INT 3
42138: EQUAL
42139: IFFALSE 42143
// continue ;
42141: GO 42109
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42143: LD_ADDR_VAR 0 11
42147: PUSH
42148: LD_VAR 0 11
42152: PPUSH
42153: LD_VAR 0 11
42157: PUSH
42158: LD_INT 1
42160: PLUS
42161: PPUSH
42162: LD_VAR 0 9
42166: PUSH
42167: LD_VAR 0 3
42171: ARRAY
42172: PPUSH
42173: CALL_OW 2
42177: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42178: LD_ADDR_VAR 0 4
42182: PUSH
42183: LD_VAR 0 4
42187: PUSH
42188: LD_VAR 0 9
42192: PUSH
42193: LD_VAR 0 3
42197: ARRAY
42198: DIFF
42199: ST_TO_ADDR
// end ;
42200: GO 42109
42202: POP
42203: POP
// if p then
42204: LD_VAR 0 11
42208: IFFALSE 42233
// result := Replace ( result , 3 , p ) ;
42210: LD_ADDR_VAR 0 2
42214: PUSH
42215: LD_VAR 0 2
42219: PPUSH
42220: LD_INT 3
42222: PPUSH
42223: LD_VAR 0 11
42227: PPUSH
42228: CALL_OW 1
42232: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42233: LD_ADDR_VAR 0 4
42237: PUSH
42238: LD_VAR 0 4
42242: PUSH
42243: LD_VAR 0 6
42247: DIFF
42248: ST_TO_ADDR
// if tmp and eng < 6 then
42249: LD_VAR 0 4
42253: PUSH
42254: LD_VAR 0 6
42258: PUSH
42259: LD_INT 6
42261: LESS
42262: AND
42263: IFFALSE 42457
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42265: LD_ADDR_VAR 0 9
42269: PUSH
42270: LD_VAR 0 4
42274: PUSH
42275: LD_VAR 0 8
42279: PUSH
42280: LD_VAR 0 7
42284: UNION
42285: PUSH
42286: LD_VAR 0 6
42290: UNION
42291: DIFF
42292: PPUSH
42293: LD_INT 2
42295: PPUSH
42296: CALL 99475 0 2
42300: ST_TO_ADDR
// p := [ ] ;
42301: LD_ADDR_VAR 0 11
42305: PUSH
42306: EMPTY
42307: ST_TO_ADDR
// if sort then
42308: LD_VAR 0 9
42312: IFFALSE 42428
// for i = 1 to 6 - eng do
42314: LD_ADDR_VAR 0 3
42318: PUSH
42319: DOUBLE
42320: LD_INT 1
42322: DEC
42323: ST_TO_ADDR
42324: LD_INT 6
42326: PUSH
42327: LD_VAR 0 6
42331: MINUS
42332: PUSH
42333: FOR_TO
42334: IFFALSE 42426
// begin if i = sort then
42336: LD_VAR 0 3
42340: PUSH
42341: LD_VAR 0 9
42345: EQUAL
42346: IFFALSE 42350
// break ;
42348: GO 42426
// if GetClass ( i ) = 2 then
42350: LD_VAR 0 3
42354: PPUSH
42355: CALL_OW 257
42359: PUSH
42360: LD_INT 2
42362: EQUAL
42363: IFFALSE 42367
// continue ;
42365: GO 42333
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42367: LD_ADDR_VAR 0 11
42371: PUSH
42372: LD_VAR 0 11
42376: PPUSH
42377: LD_VAR 0 11
42381: PUSH
42382: LD_INT 1
42384: PLUS
42385: PPUSH
42386: LD_VAR 0 9
42390: PUSH
42391: LD_VAR 0 3
42395: ARRAY
42396: PPUSH
42397: CALL_OW 2
42401: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42402: LD_ADDR_VAR 0 4
42406: PUSH
42407: LD_VAR 0 4
42411: PUSH
42412: LD_VAR 0 9
42416: PUSH
42417: LD_VAR 0 3
42421: ARRAY
42422: DIFF
42423: ST_TO_ADDR
// end ;
42424: GO 42333
42426: POP
42427: POP
// if p then
42428: LD_VAR 0 11
42432: IFFALSE 42457
// result := Replace ( result , 2 , p ) ;
42434: LD_ADDR_VAR 0 2
42438: PUSH
42439: LD_VAR 0 2
42443: PPUSH
42444: LD_INT 2
42446: PPUSH
42447: LD_VAR 0 11
42451: PPUSH
42452: CALL_OW 1
42456: ST_TO_ADDR
// end ; exit ;
42457: GO 43181
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42459: LD_EXP 137
42463: PUSH
42464: LD_EXP 136
42468: PUSH
42469: LD_VAR 0 1
42473: ARRAY
42474: ARRAY
42475: NOT
42476: PUSH
42477: LD_EXP 110
42481: PUSH
42482: LD_VAR 0 1
42486: ARRAY
42487: PPUSH
42488: LD_INT 30
42490: PUSH
42491: LD_INT 3
42493: PUSH
42494: EMPTY
42495: LIST
42496: LIST
42497: PPUSH
42498: CALL_OW 72
42502: AND
42503: PUSH
42504: LD_EXP 115
42508: PUSH
42509: LD_VAR 0 1
42513: ARRAY
42514: NOT
42515: AND
42516: IFFALSE 43181
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42518: LD_ADDR_EXP 152
42522: PUSH
42523: LD_EXP 152
42527: PPUSH
42528: LD_VAR 0 1
42532: PPUSH
42533: LD_INT 6
42535: PPUSH
42536: CALL_OW 1
42540: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42541: LD_ADDR_VAR 0 2
42545: PUSH
42546: LD_INT 0
42548: PUSH
42549: LD_INT 0
42551: PUSH
42552: LD_INT 0
42554: PUSH
42555: LD_INT 0
42557: PUSH
42558: EMPTY
42559: LIST
42560: LIST
42561: LIST
42562: LIST
42563: ST_TO_ADDR
// if sci >= 1 then
42564: LD_VAR 0 8
42568: PUSH
42569: LD_INT 1
42571: GREATEREQUAL
42572: IFFALSE 42594
// tmp := tmp diff sci [ 1 ] ;
42574: LD_ADDR_VAR 0 4
42578: PUSH
42579: LD_VAR 0 4
42583: PUSH
42584: LD_VAR 0 8
42588: PUSH
42589: LD_INT 1
42591: ARRAY
42592: DIFF
42593: ST_TO_ADDR
// if tmp and not sci then
42594: LD_VAR 0 4
42598: PUSH
42599: LD_VAR 0 8
42603: NOT
42604: AND
42605: IFFALSE 42674
// begin sort := SortBySkill ( tmp , 4 ) ;
42607: LD_ADDR_VAR 0 9
42611: PUSH
42612: LD_VAR 0 4
42616: PPUSH
42617: LD_INT 4
42619: PPUSH
42620: CALL 99475 0 2
42624: ST_TO_ADDR
// if sort then
42625: LD_VAR 0 9
42629: IFFALSE 42645
// p := sort [ 1 ] ;
42631: LD_ADDR_VAR 0 11
42635: PUSH
42636: LD_VAR 0 9
42640: PUSH
42641: LD_INT 1
42643: ARRAY
42644: ST_TO_ADDR
// if p then
42645: LD_VAR 0 11
42649: IFFALSE 42674
// result := Replace ( result , 4 , p ) ;
42651: LD_ADDR_VAR 0 2
42655: PUSH
42656: LD_VAR 0 2
42660: PPUSH
42661: LD_INT 4
42663: PPUSH
42664: LD_VAR 0 11
42668: PPUSH
42669: CALL_OW 1
42673: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42674: LD_ADDR_VAR 0 4
42678: PUSH
42679: LD_VAR 0 4
42683: PUSH
42684: LD_VAR 0 7
42688: DIFF
42689: ST_TO_ADDR
// if tmp and mech < 6 then
42690: LD_VAR 0 4
42694: PUSH
42695: LD_VAR 0 7
42699: PUSH
42700: LD_INT 6
42702: LESS
42703: AND
42704: IFFALSE 42886
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
42706: LD_ADDR_VAR 0 9
42710: PUSH
42711: LD_VAR 0 4
42715: PUSH
42716: LD_VAR 0 7
42720: DIFF
42721: PPUSH
42722: LD_INT 3
42724: PPUSH
42725: CALL 99475 0 2
42729: ST_TO_ADDR
// p := [ ] ;
42730: LD_ADDR_VAR 0 11
42734: PUSH
42735: EMPTY
42736: ST_TO_ADDR
// if sort then
42737: LD_VAR 0 9
42741: IFFALSE 42857
// for i = 1 to 6 - mech do
42743: LD_ADDR_VAR 0 3
42747: PUSH
42748: DOUBLE
42749: LD_INT 1
42751: DEC
42752: ST_TO_ADDR
42753: LD_INT 6
42755: PUSH
42756: LD_VAR 0 7
42760: MINUS
42761: PUSH
42762: FOR_TO
42763: IFFALSE 42855
// begin if i = sort then
42765: LD_VAR 0 3
42769: PUSH
42770: LD_VAR 0 9
42774: EQUAL
42775: IFFALSE 42779
// break ;
42777: GO 42855
// if GetClass ( i ) = 3 then
42779: LD_VAR 0 3
42783: PPUSH
42784: CALL_OW 257
42788: PUSH
42789: LD_INT 3
42791: EQUAL
42792: IFFALSE 42796
// continue ;
42794: GO 42762
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42796: LD_ADDR_VAR 0 11
42800: PUSH
42801: LD_VAR 0 11
42805: PPUSH
42806: LD_VAR 0 11
42810: PUSH
42811: LD_INT 1
42813: PLUS
42814: PPUSH
42815: LD_VAR 0 9
42819: PUSH
42820: LD_VAR 0 3
42824: ARRAY
42825: PPUSH
42826: CALL_OW 2
42830: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42831: LD_ADDR_VAR 0 4
42835: PUSH
42836: LD_VAR 0 4
42840: PUSH
42841: LD_VAR 0 9
42845: PUSH
42846: LD_VAR 0 3
42850: ARRAY
42851: DIFF
42852: ST_TO_ADDR
// end ;
42853: GO 42762
42855: POP
42856: POP
// if p then
42857: LD_VAR 0 11
42861: IFFALSE 42886
// result := Replace ( result , 3 , p ) ;
42863: LD_ADDR_VAR 0 2
42867: PUSH
42868: LD_VAR 0 2
42872: PPUSH
42873: LD_INT 3
42875: PPUSH
42876: LD_VAR 0 11
42880: PPUSH
42881: CALL_OW 1
42885: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42886: LD_ADDR_VAR 0 4
42890: PUSH
42891: LD_VAR 0 4
42895: PUSH
42896: LD_VAR 0 6
42900: DIFF
42901: ST_TO_ADDR
// if tmp and eng < 4 then
42902: LD_VAR 0 4
42906: PUSH
42907: LD_VAR 0 6
42911: PUSH
42912: LD_INT 4
42914: LESS
42915: AND
42916: IFFALSE 43106
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
42918: LD_ADDR_VAR 0 9
42922: PUSH
42923: LD_VAR 0 4
42927: PUSH
42928: LD_VAR 0 7
42932: PUSH
42933: LD_VAR 0 6
42937: UNION
42938: DIFF
42939: PPUSH
42940: LD_INT 2
42942: PPUSH
42943: CALL 99475 0 2
42947: ST_TO_ADDR
// p := [ ] ;
42948: LD_ADDR_VAR 0 11
42952: PUSH
42953: EMPTY
42954: ST_TO_ADDR
// if sort then
42955: LD_VAR 0 9
42959: IFFALSE 43075
// for i = 1 to 4 - eng do
42961: LD_ADDR_VAR 0 3
42965: PUSH
42966: DOUBLE
42967: LD_INT 1
42969: DEC
42970: ST_TO_ADDR
42971: LD_INT 4
42973: PUSH
42974: LD_VAR 0 6
42978: MINUS
42979: PUSH
42980: FOR_TO
42981: IFFALSE 43073
// begin if i = sort then
42983: LD_VAR 0 3
42987: PUSH
42988: LD_VAR 0 9
42992: EQUAL
42993: IFFALSE 42997
// break ;
42995: GO 43073
// if GetClass ( i ) = 2 then
42997: LD_VAR 0 3
43001: PPUSH
43002: CALL_OW 257
43006: PUSH
43007: LD_INT 2
43009: EQUAL
43010: IFFALSE 43014
// continue ;
43012: GO 42980
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43014: LD_ADDR_VAR 0 11
43018: PUSH
43019: LD_VAR 0 11
43023: PPUSH
43024: LD_VAR 0 11
43028: PUSH
43029: LD_INT 1
43031: PLUS
43032: PPUSH
43033: LD_VAR 0 9
43037: PUSH
43038: LD_VAR 0 3
43042: ARRAY
43043: PPUSH
43044: CALL_OW 2
43048: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43049: LD_ADDR_VAR 0 4
43053: PUSH
43054: LD_VAR 0 4
43058: PUSH
43059: LD_VAR 0 9
43063: PUSH
43064: LD_VAR 0 3
43068: ARRAY
43069: DIFF
43070: ST_TO_ADDR
// end ;
43071: GO 42980
43073: POP
43074: POP
// if p then
43075: LD_VAR 0 11
43079: IFFALSE 43104
// result := Replace ( result , 2 , p ) ;
43081: LD_ADDR_VAR 0 2
43085: PUSH
43086: LD_VAR 0 2
43090: PPUSH
43091: LD_INT 2
43093: PPUSH
43094: LD_VAR 0 11
43098: PPUSH
43099: CALL_OW 1
43103: ST_TO_ADDR
// end else
43104: GO 43150
// for i = eng downto 5 do
43106: LD_ADDR_VAR 0 3
43110: PUSH
43111: DOUBLE
43112: LD_VAR 0 6
43116: INC
43117: ST_TO_ADDR
43118: LD_INT 5
43120: PUSH
43121: FOR_DOWNTO
43122: IFFALSE 43148
// tmp := tmp union eng [ i ] ;
43124: LD_ADDR_VAR 0 4
43128: PUSH
43129: LD_VAR 0 4
43133: PUSH
43134: LD_VAR 0 6
43138: PUSH
43139: LD_VAR 0 3
43143: ARRAY
43144: UNION
43145: ST_TO_ADDR
43146: GO 43121
43148: POP
43149: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43150: LD_ADDR_VAR 0 2
43154: PUSH
43155: LD_VAR 0 2
43159: PPUSH
43160: LD_INT 1
43162: PPUSH
43163: LD_VAR 0 4
43167: PUSH
43168: LD_VAR 0 5
43172: DIFF
43173: PPUSH
43174: CALL_OW 1
43178: ST_TO_ADDR
// exit ;
43179: GO 43181
// end ; end ;
43181: LD_VAR 0 2
43185: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43186: LD_INT 0
43188: PPUSH
43189: PPUSH
43190: PPUSH
// if not mc_bases then
43191: LD_EXP 110
43195: NOT
43196: IFFALSE 43200
// exit ;
43198: GO 43306
// for i = 1 to mc_bases do
43200: LD_ADDR_VAR 0 2
43204: PUSH
43205: DOUBLE
43206: LD_INT 1
43208: DEC
43209: ST_TO_ADDR
43210: LD_EXP 110
43214: PUSH
43215: FOR_TO
43216: IFFALSE 43297
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43218: LD_ADDR_VAR 0 3
43222: PUSH
43223: LD_EXP 110
43227: PUSH
43228: LD_VAR 0 2
43232: ARRAY
43233: PPUSH
43234: LD_INT 21
43236: PUSH
43237: LD_INT 3
43239: PUSH
43240: EMPTY
43241: LIST
43242: LIST
43243: PUSH
43244: LD_INT 3
43246: PUSH
43247: LD_INT 24
43249: PUSH
43250: LD_INT 1000
43252: PUSH
43253: EMPTY
43254: LIST
43255: LIST
43256: PUSH
43257: EMPTY
43258: LIST
43259: LIST
43260: PUSH
43261: EMPTY
43262: LIST
43263: LIST
43264: PPUSH
43265: CALL_OW 72
43269: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43270: LD_ADDR_EXP 111
43274: PUSH
43275: LD_EXP 111
43279: PPUSH
43280: LD_VAR 0 2
43284: PPUSH
43285: LD_VAR 0 3
43289: PPUSH
43290: CALL_OW 1
43294: ST_TO_ADDR
// end ;
43295: GO 43215
43297: POP
43298: POP
// RaiseSailEvent ( 101 ) ;
43299: LD_INT 101
43301: PPUSH
43302: CALL_OW 427
// end ;
43306: LD_VAR 0 1
43310: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43311: LD_INT 0
43313: PPUSH
43314: PPUSH
43315: PPUSH
43316: PPUSH
43317: PPUSH
43318: PPUSH
43319: PPUSH
// if not mc_bases then
43320: LD_EXP 110
43324: NOT
43325: IFFALSE 43329
// exit ;
43327: GO 43902
// for i = 1 to mc_bases do
43329: LD_ADDR_VAR 0 2
43333: PUSH
43334: DOUBLE
43335: LD_INT 1
43337: DEC
43338: ST_TO_ADDR
43339: LD_EXP 110
43343: PUSH
43344: FOR_TO
43345: IFFALSE 43893
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
43347: LD_ADDR_VAR 0 5
43351: PUSH
43352: LD_EXP 110
43356: PUSH
43357: LD_VAR 0 2
43361: ARRAY
43362: PUSH
43363: LD_EXP 139
43367: PUSH
43368: LD_VAR 0 2
43372: ARRAY
43373: UNION
43374: PPUSH
43375: LD_INT 21
43377: PUSH
43378: LD_INT 1
43380: PUSH
43381: EMPTY
43382: LIST
43383: LIST
43384: PUSH
43385: LD_INT 1
43387: PUSH
43388: LD_INT 3
43390: PUSH
43391: LD_INT 54
43393: PUSH
43394: EMPTY
43395: LIST
43396: PUSH
43397: EMPTY
43398: LIST
43399: LIST
43400: PUSH
43401: LD_INT 3
43403: PUSH
43404: LD_INT 24
43406: PUSH
43407: LD_INT 800
43409: PUSH
43410: EMPTY
43411: LIST
43412: LIST
43413: PUSH
43414: EMPTY
43415: LIST
43416: LIST
43417: PUSH
43418: EMPTY
43419: LIST
43420: LIST
43421: LIST
43422: PUSH
43423: EMPTY
43424: LIST
43425: LIST
43426: PPUSH
43427: CALL_OW 72
43431: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43432: LD_ADDR_VAR 0 6
43436: PUSH
43437: LD_EXP 110
43441: PUSH
43442: LD_VAR 0 2
43446: ARRAY
43447: PPUSH
43448: LD_INT 21
43450: PUSH
43451: LD_INT 1
43453: PUSH
43454: EMPTY
43455: LIST
43456: LIST
43457: PUSH
43458: LD_INT 1
43460: PUSH
43461: LD_INT 3
43463: PUSH
43464: LD_INT 54
43466: PUSH
43467: EMPTY
43468: LIST
43469: PUSH
43470: EMPTY
43471: LIST
43472: LIST
43473: PUSH
43474: LD_INT 3
43476: PUSH
43477: LD_INT 24
43479: PUSH
43480: LD_INT 250
43482: PUSH
43483: EMPTY
43484: LIST
43485: LIST
43486: PUSH
43487: EMPTY
43488: LIST
43489: LIST
43490: PUSH
43491: EMPTY
43492: LIST
43493: LIST
43494: LIST
43495: PUSH
43496: EMPTY
43497: LIST
43498: LIST
43499: PPUSH
43500: CALL_OW 72
43504: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43505: LD_ADDR_VAR 0 7
43509: PUSH
43510: LD_VAR 0 5
43514: PUSH
43515: LD_VAR 0 6
43519: DIFF
43520: ST_TO_ADDR
// if not need_heal_1 then
43521: LD_VAR 0 6
43525: NOT
43526: IFFALSE 43559
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43528: LD_ADDR_EXP 113
43532: PUSH
43533: LD_EXP 113
43537: PPUSH
43538: LD_VAR 0 2
43542: PUSH
43543: LD_INT 1
43545: PUSH
43546: EMPTY
43547: LIST
43548: LIST
43549: PPUSH
43550: EMPTY
43551: PPUSH
43552: CALL 69926 0 3
43556: ST_TO_ADDR
43557: GO 43629
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43559: LD_ADDR_EXP 113
43563: PUSH
43564: LD_EXP 113
43568: PPUSH
43569: LD_VAR 0 2
43573: PUSH
43574: LD_INT 1
43576: PUSH
43577: EMPTY
43578: LIST
43579: LIST
43580: PPUSH
43581: LD_EXP 113
43585: PUSH
43586: LD_VAR 0 2
43590: ARRAY
43591: PUSH
43592: LD_INT 1
43594: ARRAY
43595: PPUSH
43596: LD_INT 3
43598: PUSH
43599: LD_INT 24
43601: PUSH
43602: LD_INT 1000
43604: PUSH
43605: EMPTY
43606: LIST
43607: LIST
43608: PUSH
43609: EMPTY
43610: LIST
43611: LIST
43612: PPUSH
43613: CALL_OW 72
43617: PUSH
43618: LD_VAR 0 6
43622: UNION
43623: PPUSH
43624: CALL 69926 0 3
43628: ST_TO_ADDR
// if not need_heal_2 then
43629: LD_VAR 0 7
43633: NOT
43634: IFFALSE 43667
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
43636: LD_ADDR_EXP 113
43640: PUSH
43641: LD_EXP 113
43645: PPUSH
43646: LD_VAR 0 2
43650: PUSH
43651: LD_INT 2
43653: PUSH
43654: EMPTY
43655: LIST
43656: LIST
43657: PPUSH
43658: EMPTY
43659: PPUSH
43660: CALL 69926 0 3
43664: ST_TO_ADDR
43665: GO 43699
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
43667: LD_ADDR_EXP 113
43671: PUSH
43672: LD_EXP 113
43676: PPUSH
43677: LD_VAR 0 2
43681: PUSH
43682: LD_INT 2
43684: PUSH
43685: EMPTY
43686: LIST
43687: LIST
43688: PPUSH
43689: LD_VAR 0 7
43693: PPUSH
43694: CALL 69926 0 3
43698: ST_TO_ADDR
// if need_heal_2 then
43699: LD_VAR 0 7
43703: IFFALSE 43875
// for j in need_heal_2 do
43705: LD_ADDR_VAR 0 3
43709: PUSH
43710: LD_VAR 0 7
43714: PUSH
43715: FOR_IN
43716: IFFALSE 43873
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
43718: LD_ADDR_VAR 0 5
43722: PUSH
43723: LD_EXP 110
43727: PUSH
43728: LD_VAR 0 2
43732: ARRAY
43733: PPUSH
43734: LD_INT 2
43736: PUSH
43737: LD_INT 30
43739: PUSH
43740: LD_INT 6
43742: PUSH
43743: EMPTY
43744: LIST
43745: LIST
43746: PUSH
43747: LD_INT 30
43749: PUSH
43750: LD_INT 7
43752: PUSH
43753: EMPTY
43754: LIST
43755: LIST
43756: PUSH
43757: LD_INT 30
43759: PUSH
43760: LD_INT 8
43762: PUSH
43763: EMPTY
43764: LIST
43765: LIST
43766: PUSH
43767: LD_INT 30
43769: PUSH
43770: LD_INT 0
43772: PUSH
43773: EMPTY
43774: LIST
43775: LIST
43776: PUSH
43777: LD_INT 30
43779: PUSH
43780: LD_INT 1
43782: PUSH
43783: EMPTY
43784: LIST
43785: LIST
43786: PUSH
43787: LD_INT 25
43789: PUSH
43790: LD_INT 4
43792: PUSH
43793: EMPTY
43794: LIST
43795: LIST
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: LIST
43801: LIST
43802: LIST
43803: LIST
43804: LIST
43805: PPUSH
43806: CALL_OW 72
43810: ST_TO_ADDR
// if tmp then
43811: LD_VAR 0 5
43815: IFFALSE 43871
// begin k := NearestUnitToUnit ( tmp , j ) ;
43817: LD_ADDR_VAR 0 4
43821: PUSH
43822: LD_VAR 0 5
43826: PPUSH
43827: LD_VAR 0 3
43831: PPUSH
43832: CALL_OW 74
43836: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
43837: LD_VAR 0 3
43841: PPUSH
43842: LD_VAR 0 4
43846: PPUSH
43847: CALL_OW 296
43851: PUSH
43852: LD_INT 7
43854: GREATER
43855: IFFALSE 43871
// ComMoveUnit ( j , k ) ;
43857: LD_VAR 0 3
43861: PPUSH
43862: LD_VAR 0 4
43866: PPUSH
43867: CALL_OW 112
// end ; end ;
43871: GO 43715
43873: POP
43874: POP
// if not need_heal_1 and not need_heal_2 then
43875: LD_VAR 0 6
43879: NOT
43880: PUSH
43881: LD_VAR 0 7
43885: NOT
43886: AND
43887: IFFALSE 43891
// continue ;
43889: GO 43344
// end ;
43891: GO 43344
43893: POP
43894: POP
// RaiseSailEvent ( 102 ) ;
43895: LD_INT 102
43897: PPUSH
43898: CALL_OW 427
// end ;
43902: LD_VAR 0 1
43906: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
43907: LD_INT 0
43909: PPUSH
43910: PPUSH
43911: PPUSH
43912: PPUSH
43913: PPUSH
43914: PPUSH
43915: PPUSH
43916: PPUSH
// if not mc_bases then
43917: LD_EXP 110
43921: NOT
43922: IFFALSE 43926
// exit ;
43924: GO 44766
// for i = 1 to mc_bases do
43926: LD_ADDR_VAR 0 2
43930: PUSH
43931: DOUBLE
43932: LD_INT 1
43934: DEC
43935: ST_TO_ADDR
43936: LD_EXP 110
43940: PUSH
43941: FOR_TO
43942: IFFALSE 44764
// begin if not mc_building_need_repair [ i ] then
43944: LD_EXP 111
43948: PUSH
43949: LD_VAR 0 2
43953: ARRAY
43954: NOT
43955: IFFALSE 44129
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
43957: LD_ADDR_VAR 0 6
43961: PUSH
43962: LD_EXP 129
43966: PUSH
43967: LD_VAR 0 2
43971: ARRAY
43972: PPUSH
43973: LD_INT 3
43975: PUSH
43976: LD_INT 24
43978: PUSH
43979: LD_INT 1000
43981: PUSH
43982: EMPTY
43983: LIST
43984: LIST
43985: PUSH
43986: EMPTY
43987: LIST
43988: LIST
43989: PUSH
43990: LD_INT 2
43992: PUSH
43993: LD_INT 34
43995: PUSH
43996: LD_INT 13
43998: PUSH
43999: EMPTY
44000: LIST
44001: LIST
44002: PUSH
44003: LD_INT 34
44005: PUSH
44006: LD_INT 52
44008: PUSH
44009: EMPTY
44010: LIST
44011: LIST
44012: PUSH
44013: EMPTY
44014: LIST
44015: LIST
44016: LIST
44017: PUSH
44018: EMPTY
44019: LIST
44020: LIST
44021: PPUSH
44022: CALL_OW 72
44026: ST_TO_ADDR
// if cranes then
44027: LD_VAR 0 6
44031: IFFALSE 44093
// for j in cranes do
44033: LD_ADDR_VAR 0 3
44037: PUSH
44038: LD_VAR 0 6
44042: PUSH
44043: FOR_IN
44044: IFFALSE 44091
// if not IsInArea ( j , mc_parking [ i ] ) then
44046: LD_VAR 0 3
44050: PPUSH
44051: LD_EXP 134
44055: PUSH
44056: LD_VAR 0 2
44060: ARRAY
44061: PPUSH
44062: CALL_OW 308
44066: NOT
44067: IFFALSE 44089
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44069: LD_VAR 0 3
44073: PPUSH
44074: LD_EXP 134
44078: PUSH
44079: LD_VAR 0 2
44083: ARRAY
44084: PPUSH
44085: CALL_OW 113
44089: GO 44043
44091: POP
44092: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44093: LD_ADDR_EXP 112
44097: PUSH
44098: LD_EXP 112
44102: PPUSH
44103: LD_VAR 0 2
44107: PPUSH
44108: EMPTY
44109: PPUSH
44110: CALL_OW 1
44114: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44115: LD_VAR 0 2
44119: PPUSH
44120: LD_INT 101
44122: PPUSH
44123: CALL 39019 0 2
// continue ;
44127: GO 43941
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44129: LD_ADDR_EXP 116
44133: PUSH
44134: LD_EXP 116
44138: PPUSH
44139: LD_VAR 0 2
44143: PPUSH
44144: EMPTY
44145: PPUSH
44146: CALL_OW 1
44150: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44151: LD_VAR 0 2
44155: PPUSH
44156: LD_INT 103
44158: PPUSH
44159: CALL 39019 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
44163: LD_ADDR_VAR 0 5
44167: PUSH
44168: LD_EXP 110
44172: PUSH
44173: LD_VAR 0 2
44177: ARRAY
44178: PUSH
44179: LD_EXP 139
44183: PUSH
44184: LD_VAR 0 2
44188: ARRAY
44189: UNION
44190: PPUSH
44191: LD_INT 2
44193: PUSH
44194: LD_INT 25
44196: PUSH
44197: LD_INT 2
44199: PUSH
44200: EMPTY
44201: LIST
44202: LIST
44203: PUSH
44204: LD_INT 25
44206: PUSH
44207: LD_INT 16
44209: PUSH
44210: EMPTY
44211: LIST
44212: LIST
44213: PUSH
44214: EMPTY
44215: LIST
44216: LIST
44217: LIST
44218: PUSH
44219: EMPTY
44220: LIST
44221: PPUSH
44222: CALL_OW 72
44226: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
44227: LD_ADDR_VAR 0 6
44231: PUSH
44232: LD_EXP 129
44236: PUSH
44237: LD_VAR 0 2
44241: ARRAY
44242: PPUSH
44243: LD_INT 2
44245: PUSH
44246: LD_INT 34
44248: PUSH
44249: LD_INT 13
44251: PUSH
44252: EMPTY
44253: LIST
44254: LIST
44255: PUSH
44256: LD_INT 34
44258: PUSH
44259: LD_INT 52
44261: PUSH
44262: EMPTY
44263: LIST
44264: LIST
44265: PUSH
44266: EMPTY
44267: LIST
44268: LIST
44269: LIST
44270: PPUSH
44271: CALL_OW 72
44275: ST_TO_ADDR
// if cranes then
44276: LD_VAR 0 6
44280: IFFALSE 44416
// begin for j in cranes do
44282: LD_ADDR_VAR 0 3
44286: PUSH
44287: LD_VAR 0 6
44291: PUSH
44292: FOR_IN
44293: IFFALSE 44414
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
44295: LD_VAR 0 3
44299: PPUSH
44300: CALL_OW 256
44304: PUSH
44305: LD_INT 500
44307: GREATEREQUAL
44308: PUSH
44309: LD_VAR 0 3
44313: PPUSH
44314: CALL_OW 314
44318: NOT
44319: AND
44320: IFFALSE 44354
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44322: LD_VAR 0 3
44326: PPUSH
44327: LD_EXP 111
44331: PUSH
44332: LD_VAR 0 2
44336: ARRAY
44337: PPUSH
44338: LD_VAR 0 3
44342: PPUSH
44343: CALL_OW 74
44347: PPUSH
44348: CALL_OW 130
44352: GO 44412
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44354: LD_VAR 0 3
44358: PPUSH
44359: CALL_OW 256
44363: PUSH
44364: LD_INT 500
44366: LESS
44367: PUSH
44368: LD_VAR 0 3
44372: PPUSH
44373: LD_EXP 134
44377: PUSH
44378: LD_VAR 0 2
44382: ARRAY
44383: PPUSH
44384: CALL_OW 308
44388: NOT
44389: AND
44390: IFFALSE 44412
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44392: LD_VAR 0 3
44396: PPUSH
44397: LD_EXP 134
44401: PUSH
44402: LD_VAR 0 2
44406: ARRAY
44407: PPUSH
44408: CALL_OW 113
44412: GO 44292
44414: POP
44415: POP
// end ; if not tmp then
44416: LD_VAR 0 5
44420: NOT
44421: IFFALSE 44425
// continue ;
44423: GO 43941
// for j in tmp do
44425: LD_ADDR_VAR 0 3
44429: PUSH
44430: LD_VAR 0 5
44434: PUSH
44435: FOR_IN
44436: IFFALSE 44760
// begin if mc_need_heal [ i ] then
44438: LD_EXP 113
44442: PUSH
44443: LD_VAR 0 2
44447: ARRAY
44448: IFFALSE 44496
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
44450: LD_VAR 0 3
44454: PUSH
44455: LD_EXP 113
44459: PUSH
44460: LD_VAR 0 2
44464: ARRAY
44465: PUSH
44466: LD_INT 1
44468: ARRAY
44469: IN
44470: PUSH
44471: LD_VAR 0 3
44475: PUSH
44476: LD_EXP 113
44480: PUSH
44481: LD_VAR 0 2
44485: ARRAY
44486: PUSH
44487: LD_INT 2
44489: ARRAY
44490: IN
44491: OR
44492: IFFALSE 44496
// continue ;
44494: GO 44435
// if IsInUnit ( j ) then
44496: LD_VAR 0 3
44500: PPUSH
44501: CALL_OW 310
44505: IFFALSE 44516
// ComExitBuilding ( j ) ;
44507: LD_VAR 0 3
44511: PPUSH
44512: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44516: LD_VAR 0 3
44520: PUSH
44521: LD_EXP 112
44525: PUSH
44526: LD_VAR 0 2
44530: ARRAY
44531: IN
44532: NOT
44533: IFFALSE 44591
// begin SetTag ( j , 101 ) ;
44535: LD_VAR 0 3
44539: PPUSH
44540: LD_INT 101
44542: PPUSH
44543: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
44547: LD_ADDR_EXP 112
44551: PUSH
44552: LD_EXP 112
44556: PPUSH
44557: LD_VAR 0 2
44561: PUSH
44562: LD_EXP 112
44566: PUSH
44567: LD_VAR 0 2
44571: ARRAY
44572: PUSH
44573: LD_INT 1
44575: PLUS
44576: PUSH
44577: EMPTY
44578: LIST
44579: LIST
44580: PPUSH
44581: LD_VAR 0 3
44585: PPUSH
44586: CALL 69926 0 3
44590: ST_TO_ADDR
// end ; wait ( 1 ) ;
44591: LD_INT 1
44593: PPUSH
44594: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
44598: LD_ADDR_VAR 0 7
44602: PUSH
44603: LD_EXP 111
44607: PUSH
44608: LD_VAR 0 2
44612: ARRAY
44613: ST_TO_ADDR
// if mc_scan [ i ] then
44614: LD_EXP 133
44618: PUSH
44619: LD_VAR 0 2
44623: ARRAY
44624: IFFALSE 44693
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
44626: LD_ADDR_VAR 0 7
44630: PUSH
44631: LD_EXP 111
44635: PUSH
44636: LD_VAR 0 2
44640: ARRAY
44641: PPUSH
44642: LD_INT 3
44644: PUSH
44645: LD_INT 2
44647: PUSH
44648: LD_INT 30
44650: PUSH
44651: LD_INT 32
44653: PUSH
44654: EMPTY
44655: LIST
44656: LIST
44657: PUSH
44658: LD_INT 30
44660: PUSH
44661: LD_INT 33
44663: PUSH
44664: EMPTY
44665: LIST
44666: LIST
44667: PUSH
44668: LD_INT 30
44670: PUSH
44671: LD_INT 31
44673: PUSH
44674: EMPTY
44675: LIST
44676: LIST
44677: PUSH
44678: EMPTY
44679: LIST
44680: LIST
44681: LIST
44682: LIST
44683: PUSH
44684: EMPTY
44685: LIST
44686: LIST
44687: PPUSH
44688: CALL_OW 72
44692: ST_TO_ADDR
// if not to_repair_tmp then
44693: LD_VAR 0 7
44697: NOT
44698: IFFALSE 44702
// continue ;
44700: GO 44435
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
44702: LD_ADDR_VAR 0 8
44706: PUSH
44707: LD_VAR 0 7
44711: PPUSH
44712: LD_VAR 0 3
44716: PPUSH
44717: CALL_OW 74
44721: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
44722: LD_VAR 0 8
44726: PPUSH
44727: LD_INT 14
44729: PPUSH
44730: CALL 72519 0 2
44734: PUSH
44735: LD_INT 4
44737: ARRAY
44738: PUSH
44739: LD_INT 5
44741: LESS
44742: IFFALSE 44758
// ComRepairBuilding ( j , to_repair ) ;
44744: LD_VAR 0 3
44748: PPUSH
44749: LD_VAR 0 8
44753: PPUSH
44754: CALL_OW 130
// end ;
44758: GO 44435
44760: POP
44761: POP
// end ;
44762: GO 43941
44764: POP
44765: POP
// end ;
44766: LD_VAR 0 1
44770: RET
// export function MC_Heal ; var i , j , tmp ; begin
44771: LD_INT 0
44773: PPUSH
44774: PPUSH
44775: PPUSH
44776: PPUSH
// if not mc_bases then
44777: LD_EXP 110
44781: NOT
44782: IFFALSE 44786
// exit ;
44784: GO 45188
// for i = 1 to mc_bases do
44786: LD_ADDR_VAR 0 2
44790: PUSH
44791: DOUBLE
44792: LD_INT 1
44794: DEC
44795: ST_TO_ADDR
44796: LD_EXP 110
44800: PUSH
44801: FOR_TO
44802: IFFALSE 45186
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
44804: LD_EXP 113
44808: PUSH
44809: LD_VAR 0 2
44813: ARRAY
44814: PUSH
44815: LD_INT 1
44817: ARRAY
44818: NOT
44819: PUSH
44820: LD_EXP 113
44824: PUSH
44825: LD_VAR 0 2
44829: ARRAY
44830: PUSH
44831: LD_INT 2
44833: ARRAY
44834: NOT
44835: AND
44836: IFFALSE 44874
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
44838: LD_ADDR_EXP 114
44842: PUSH
44843: LD_EXP 114
44847: PPUSH
44848: LD_VAR 0 2
44852: PPUSH
44853: EMPTY
44854: PPUSH
44855: CALL_OW 1
44859: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
44860: LD_VAR 0 2
44864: PPUSH
44865: LD_INT 102
44867: PPUSH
44868: CALL 39019 0 2
// continue ;
44872: GO 44801
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
44874: LD_ADDR_VAR 0 4
44878: PUSH
44879: LD_EXP 110
44883: PUSH
44884: LD_VAR 0 2
44888: ARRAY
44889: PPUSH
44890: LD_INT 25
44892: PUSH
44893: LD_INT 4
44895: PUSH
44896: EMPTY
44897: LIST
44898: LIST
44899: PPUSH
44900: CALL_OW 72
44904: ST_TO_ADDR
// if not tmp then
44905: LD_VAR 0 4
44909: NOT
44910: IFFALSE 44914
// continue ;
44912: GO 44801
// if mc_taming [ i ] then
44914: LD_EXP 141
44918: PUSH
44919: LD_VAR 0 2
44923: ARRAY
44924: IFFALSE 44948
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
44926: LD_ADDR_EXP 141
44930: PUSH
44931: LD_EXP 141
44935: PPUSH
44936: LD_VAR 0 2
44940: PPUSH
44941: EMPTY
44942: PPUSH
44943: CALL_OW 1
44947: ST_TO_ADDR
// for j in tmp do
44948: LD_ADDR_VAR 0 3
44952: PUSH
44953: LD_VAR 0 4
44957: PUSH
44958: FOR_IN
44959: IFFALSE 45182
// begin if IsInUnit ( j ) then
44961: LD_VAR 0 3
44965: PPUSH
44966: CALL_OW 310
44970: IFFALSE 44981
// ComExitBuilding ( j ) ;
44972: LD_VAR 0 3
44976: PPUSH
44977: CALL_OW 122
// if not j in mc_healers [ i ] then
44981: LD_VAR 0 3
44985: PUSH
44986: LD_EXP 114
44990: PUSH
44991: LD_VAR 0 2
44995: ARRAY
44996: IN
44997: NOT
44998: IFFALSE 45044
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
45000: LD_ADDR_EXP 114
45004: PUSH
45005: LD_EXP 114
45009: PPUSH
45010: LD_VAR 0 2
45014: PUSH
45015: LD_EXP 114
45019: PUSH
45020: LD_VAR 0 2
45024: ARRAY
45025: PUSH
45026: LD_INT 1
45028: PLUS
45029: PUSH
45030: EMPTY
45031: LIST
45032: LIST
45033: PPUSH
45034: LD_VAR 0 3
45038: PPUSH
45039: CALL 69926 0 3
45043: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
45044: LD_VAR 0 3
45048: PPUSH
45049: CALL_OW 110
45053: PUSH
45054: LD_INT 102
45056: NONEQUAL
45057: IFFALSE 45071
// SetTag ( j , 102 ) ;
45059: LD_VAR 0 3
45063: PPUSH
45064: LD_INT 102
45066: PPUSH
45067: CALL_OW 109
// Wait ( 3 ) ;
45071: LD_INT 3
45073: PPUSH
45074: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
45078: LD_EXP 113
45082: PUSH
45083: LD_VAR 0 2
45087: ARRAY
45088: PUSH
45089: LD_INT 1
45091: ARRAY
45092: IFFALSE 45124
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45094: LD_VAR 0 3
45098: PPUSH
45099: LD_EXP 113
45103: PUSH
45104: LD_VAR 0 2
45108: ARRAY
45109: PUSH
45110: LD_INT 1
45112: ARRAY
45113: PUSH
45114: LD_INT 1
45116: ARRAY
45117: PPUSH
45118: CALL_OW 128
45122: GO 45180
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45124: LD_VAR 0 3
45128: PPUSH
45129: CALL_OW 314
45133: NOT
45134: PUSH
45135: LD_EXP 113
45139: PUSH
45140: LD_VAR 0 2
45144: ARRAY
45145: PUSH
45146: LD_INT 2
45148: ARRAY
45149: AND
45150: IFFALSE 45180
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45152: LD_VAR 0 3
45156: PPUSH
45157: LD_EXP 113
45161: PUSH
45162: LD_VAR 0 2
45166: ARRAY
45167: PUSH
45168: LD_INT 2
45170: ARRAY
45171: PUSH
45172: LD_INT 1
45174: ARRAY
45175: PPUSH
45176: CALL_OW 128
// end ;
45180: GO 44958
45182: POP
45183: POP
// end ;
45184: GO 44801
45186: POP
45187: POP
// end ;
45188: LD_VAR 0 1
45192: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45193: LD_INT 0
45195: PPUSH
45196: PPUSH
45197: PPUSH
45198: PPUSH
45199: PPUSH
// if not mc_bases then
45200: LD_EXP 110
45204: NOT
45205: IFFALSE 45209
// exit ;
45207: GO 46352
// for i = 1 to mc_bases do
45209: LD_ADDR_VAR 0 2
45213: PUSH
45214: DOUBLE
45215: LD_INT 1
45217: DEC
45218: ST_TO_ADDR
45219: LD_EXP 110
45223: PUSH
45224: FOR_TO
45225: IFFALSE 46350
// begin if mc_scan [ i ] then
45227: LD_EXP 133
45231: PUSH
45232: LD_VAR 0 2
45236: ARRAY
45237: IFFALSE 45241
// continue ;
45239: GO 45224
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45241: LD_EXP 115
45245: PUSH
45246: LD_VAR 0 2
45250: ARRAY
45251: NOT
45252: PUSH
45253: LD_EXP 117
45257: PUSH
45258: LD_VAR 0 2
45262: ARRAY
45263: NOT
45264: AND
45265: PUSH
45266: LD_EXP 116
45270: PUSH
45271: LD_VAR 0 2
45275: ARRAY
45276: AND
45277: IFFALSE 45315
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45279: LD_ADDR_EXP 116
45283: PUSH
45284: LD_EXP 116
45288: PPUSH
45289: LD_VAR 0 2
45293: PPUSH
45294: EMPTY
45295: PPUSH
45296: CALL_OW 1
45300: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45301: LD_VAR 0 2
45305: PPUSH
45306: LD_INT 103
45308: PPUSH
45309: CALL 39019 0 2
// continue ;
45313: GO 45224
// end ; if mc_construct_list [ i ] then
45315: LD_EXP 117
45319: PUSH
45320: LD_VAR 0 2
45324: ARRAY
45325: IFFALSE 45545
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45327: LD_ADDR_VAR 0 4
45331: PUSH
45332: LD_EXP 110
45336: PUSH
45337: LD_VAR 0 2
45341: ARRAY
45342: PPUSH
45343: LD_INT 25
45345: PUSH
45346: LD_INT 2
45348: PUSH
45349: EMPTY
45350: LIST
45351: LIST
45352: PPUSH
45353: CALL_OW 72
45357: PUSH
45358: LD_EXP 112
45362: PUSH
45363: LD_VAR 0 2
45367: ARRAY
45368: DIFF
45369: ST_TO_ADDR
// if not tmp then
45370: LD_VAR 0 4
45374: NOT
45375: IFFALSE 45379
// continue ;
45377: GO 45224
// for j in tmp do
45379: LD_ADDR_VAR 0 3
45383: PUSH
45384: LD_VAR 0 4
45388: PUSH
45389: FOR_IN
45390: IFFALSE 45541
// begin if not mc_builders [ i ] then
45392: LD_EXP 116
45396: PUSH
45397: LD_VAR 0 2
45401: ARRAY
45402: NOT
45403: IFFALSE 45461
// begin SetTag ( j , 103 ) ;
45405: LD_VAR 0 3
45409: PPUSH
45410: LD_INT 103
45412: PPUSH
45413: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45417: LD_ADDR_EXP 116
45421: PUSH
45422: LD_EXP 116
45426: PPUSH
45427: LD_VAR 0 2
45431: PUSH
45432: LD_EXP 116
45436: PUSH
45437: LD_VAR 0 2
45441: ARRAY
45442: PUSH
45443: LD_INT 1
45445: PLUS
45446: PUSH
45447: EMPTY
45448: LIST
45449: LIST
45450: PPUSH
45451: LD_VAR 0 3
45455: PPUSH
45456: CALL 69926 0 3
45460: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45461: LD_VAR 0 3
45465: PPUSH
45466: CALL_OW 310
45470: IFFALSE 45481
// ComExitBuilding ( j ) ;
45472: LD_VAR 0 3
45476: PPUSH
45477: CALL_OW 122
// wait ( 3 ) ;
45481: LD_INT 3
45483: PPUSH
45484: CALL_OW 67
// if not mc_construct_list [ i ] then
45488: LD_EXP 117
45492: PUSH
45493: LD_VAR 0 2
45497: ARRAY
45498: NOT
45499: IFFALSE 45503
// break ;
45501: GO 45541
// if not HasTask ( j ) then
45503: LD_VAR 0 3
45507: PPUSH
45508: CALL_OW 314
45512: NOT
45513: IFFALSE 45539
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45515: LD_VAR 0 3
45519: PPUSH
45520: LD_EXP 117
45524: PUSH
45525: LD_VAR 0 2
45529: ARRAY
45530: PUSH
45531: LD_INT 1
45533: ARRAY
45534: PPUSH
45535: CALL 72777 0 2
// end ;
45539: GO 45389
45541: POP
45542: POP
// end else
45543: GO 46348
// if mc_build_list [ i ] then
45545: LD_EXP 115
45549: PUSH
45550: LD_VAR 0 2
45554: ARRAY
45555: IFFALSE 46348
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45557: LD_ADDR_VAR 0 5
45561: PUSH
45562: LD_EXP 110
45566: PUSH
45567: LD_VAR 0 2
45571: ARRAY
45572: PPUSH
45573: LD_INT 2
45575: PUSH
45576: LD_INT 30
45578: PUSH
45579: LD_INT 0
45581: PUSH
45582: EMPTY
45583: LIST
45584: LIST
45585: PUSH
45586: LD_INT 30
45588: PUSH
45589: LD_INT 1
45591: PUSH
45592: EMPTY
45593: LIST
45594: LIST
45595: PUSH
45596: EMPTY
45597: LIST
45598: LIST
45599: LIST
45600: PPUSH
45601: CALL_OW 72
45605: ST_TO_ADDR
// if depot then
45606: LD_VAR 0 5
45610: IFFALSE 45628
// depot := depot [ 1 ] else
45612: LD_ADDR_VAR 0 5
45616: PUSH
45617: LD_VAR 0 5
45621: PUSH
45622: LD_INT 1
45624: ARRAY
45625: ST_TO_ADDR
45626: GO 45636
// depot := 0 ;
45628: LD_ADDR_VAR 0 5
45632: PUSH
45633: LD_INT 0
45635: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
45636: LD_EXP 115
45640: PUSH
45641: LD_VAR 0 2
45645: ARRAY
45646: PUSH
45647: LD_INT 1
45649: ARRAY
45650: PUSH
45651: LD_INT 1
45653: ARRAY
45654: PPUSH
45655: CALL 72607 0 1
45659: PUSH
45660: LD_EXP 110
45664: PUSH
45665: LD_VAR 0 2
45669: ARRAY
45670: PPUSH
45671: LD_INT 2
45673: PUSH
45674: LD_INT 30
45676: PUSH
45677: LD_INT 2
45679: PUSH
45680: EMPTY
45681: LIST
45682: LIST
45683: PUSH
45684: LD_INT 30
45686: PUSH
45687: LD_INT 3
45689: PUSH
45690: EMPTY
45691: LIST
45692: LIST
45693: PUSH
45694: EMPTY
45695: LIST
45696: LIST
45697: LIST
45698: PPUSH
45699: CALL_OW 72
45703: NOT
45704: AND
45705: IFFALSE 45810
// begin for j = 1 to mc_build_list [ i ] do
45707: LD_ADDR_VAR 0 3
45711: PUSH
45712: DOUBLE
45713: LD_INT 1
45715: DEC
45716: ST_TO_ADDR
45717: LD_EXP 115
45721: PUSH
45722: LD_VAR 0 2
45726: ARRAY
45727: PUSH
45728: FOR_TO
45729: IFFALSE 45808
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
45731: LD_EXP 115
45735: PUSH
45736: LD_VAR 0 2
45740: ARRAY
45741: PUSH
45742: LD_VAR 0 3
45746: ARRAY
45747: PUSH
45748: LD_INT 1
45750: ARRAY
45751: PUSH
45752: LD_INT 2
45754: EQUAL
45755: IFFALSE 45806
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
45757: LD_ADDR_EXP 115
45761: PUSH
45762: LD_EXP 115
45766: PPUSH
45767: LD_VAR 0 2
45771: PPUSH
45772: LD_EXP 115
45776: PUSH
45777: LD_VAR 0 2
45781: ARRAY
45782: PPUSH
45783: LD_VAR 0 3
45787: PPUSH
45788: LD_INT 1
45790: PPUSH
45791: LD_INT 0
45793: PPUSH
45794: CALL 69344 0 4
45798: PPUSH
45799: CALL_OW 1
45803: ST_TO_ADDR
// break ;
45804: GO 45808
// end ;
45806: GO 45728
45808: POP
45809: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
45810: LD_EXP 115
45814: PUSH
45815: LD_VAR 0 2
45819: ARRAY
45820: PUSH
45821: LD_INT 1
45823: ARRAY
45824: PUSH
45825: LD_INT 1
45827: ARRAY
45828: PUSH
45829: LD_INT 0
45831: EQUAL
45832: PUSH
45833: LD_VAR 0 5
45837: PUSH
45838: LD_VAR 0 5
45842: PPUSH
45843: LD_EXP 115
45847: PUSH
45848: LD_VAR 0 2
45852: ARRAY
45853: PUSH
45854: LD_INT 1
45856: ARRAY
45857: PUSH
45858: LD_INT 1
45860: ARRAY
45861: PPUSH
45862: LD_EXP 115
45866: PUSH
45867: LD_VAR 0 2
45871: ARRAY
45872: PUSH
45873: LD_INT 1
45875: ARRAY
45876: PUSH
45877: LD_INT 2
45879: ARRAY
45880: PPUSH
45881: LD_EXP 115
45885: PUSH
45886: LD_VAR 0 2
45890: ARRAY
45891: PUSH
45892: LD_INT 1
45894: ARRAY
45895: PUSH
45896: LD_INT 3
45898: ARRAY
45899: PPUSH
45900: LD_EXP 115
45904: PUSH
45905: LD_VAR 0 2
45909: ARRAY
45910: PUSH
45911: LD_INT 1
45913: ARRAY
45914: PUSH
45915: LD_INT 4
45917: ARRAY
45918: PPUSH
45919: CALL 77341 0 5
45923: AND
45924: OR
45925: IFFALSE 46206
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45927: LD_ADDR_VAR 0 4
45931: PUSH
45932: LD_EXP 110
45936: PUSH
45937: LD_VAR 0 2
45941: ARRAY
45942: PPUSH
45943: LD_INT 25
45945: PUSH
45946: LD_INT 2
45948: PUSH
45949: EMPTY
45950: LIST
45951: LIST
45952: PPUSH
45953: CALL_OW 72
45957: PUSH
45958: LD_EXP 112
45962: PUSH
45963: LD_VAR 0 2
45967: ARRAY
45968: DIFF
45969: ST_TO_ADDR
// if not tmp then
45970: LD_VAR 0 4
45974: NOT
45975: IFFALSE 45979
// continue ;
45977: GO 45224
// for j in tmp do
45979: LD_ADDR_VAR 0 3
45983: PUSH
45984: LD_VAR 0 4
45988: PUSH
45989: FOR_IN
45990: IFFALSE 46202
// begin if not mc_builders [ i ] then
45992: LD_EXP 116
45996: PUSH
45997: LD_VAR 0 2
46001: ARRAY
46002: NOT
46003: IFFALSE 46061
// begin SetTag ( j , 103 ) ;
46005: LD_VAR 0 3
46009: PPUSH
46010: LD_INT 103
46012: PPUSH
46013: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
46017: LD_ADDR_EXP 116
46021: PUSH
46022: LD_EXP 116
46026: PPUSH
46027: LD_VAR 0 2
46031: PUSH
46032: LD_EXP 116
46036: PUSH
46037: LD_VAR 0 2
46041: ARRAY
46042: PUSH
46043: LD_INT 1
46045: PLUS
46046: PUSH
46047: EMPTY
46048: LIST
46049: LIST
46050: PPUSH
46051: LD_VAR 0 3
46055: PPUSH
46056: CALL 69926 0 3
46060: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
46061: LD_VAR 0 3
46065: PPUSH
46066: CALL_OW 310
46070: IFFALSE 46081
// ComExitBuilding ( j ) ;
46072: LD_VAR 0 3
46076: PPUSH
46077: CALL_OW 122
// wait ( 3 ) ;
46081: LD_INT 3
46083: PPUSH
46084: CALL_OW 67
// if not mc_build_list [ i ] then
46088: LD_EXP 115
46092: PUSH
46093: LD_VAR 0 2
46097: ARRAY
46098: NOT
46099: IFFALSE 46103
// break ;
46101: GO 46202
// if not HasTask ( j ) then
46103: LD_VAR 0 3
46107: PPUSH
46108: CALL_OW 314
46112: NOT
46113: IFFALSE 46200
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46115: LD_VAR 0 3
46119: PPUSH
46120: LD_EXP 115
46124: PUSH
46125: LD_VAR 0 2
46129: ARRAY
46130: PUSH
46131: LD_INT 1
46133: ARRAY
46134: PUSH
46135: LD_INT 1
46137: ARRAY
46138: PPUSH
46139: LD_EXP 115
46143: PUSH
46144: LD_VAR 0 2
46148: ARRAY
46149: PUSH
46150: LD_INT 1
46152: ARRAY
46153: PUSH
46154: LD_INT 2
46156: ARRAY
46157: PPUSH
46158: LD_EXP 115
46162: PUSH
46163: LD_VAR 0 2
46167: ARRAY
46168: PUSH
46169: LD_INT 1
46171: ARRAY
46172: PUSH
46173: LD_INT 3
46175: ARRAY
46176: PPUSH
46177: LD_EXP 115
46181: PUSH
46182: LD_VAR 0 2
46186: ARRAY
46187: PUSH
46188: LD_INT 1
46190: ARRAY
46191: PUSH
46192: LD_INT 4
46194: ARRAY
46195: PPUSH
46196: CALL_OW 145
// end ;
46200: GO 45989
46202: POP
46203: POP
// end else
46204: GO 46348
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
46206: LD_EXP 110
46210: PUSH
46211: LD_VAR 0 2
46215: ARRAY
46216: PPUSH
46217: LD_EXP 115
46221: PUSH
46222: LD_VAR 0 2
46226: ARRAY
46227: PUSH
46228: LD_INT 1
46230: ARRAY
46231: PUSH
46232: LD_INT 1
46234: ARRAY
46235: PPUSH
46236: LD_EXP 115
46240: PUSH
46241: LD_VAR 0 2
46245: ARRAY
46246: PUSH
46247: LD_INT 1
46249: ARRAY
46250: PUSH
46251: LD_INT 2
46253: ARRAY
46254: PPUSH
46255: LD_EXP 115
46259: PUSH
46260: LD_VAR 0 2
46264: ARRAY
46265: PUSH
46266: LD_INT 1
46268: ARRAY
46269: PUSH
46270: LD_INT 3
46272: ARRAY
46273: PPUSH
46274: LD_EXP 115
46278: PUSH
46279: LD_VAR 0 2
46283: ARRAY
46284: PUSH
46285: LD_INT 1
46287: ARRAY
46288: PUSH
46289: LD_INT 4
46291: ARRAY
46292: PPUSH
46293: CALL 76677 0 5
46297: NOT
46298: IFFALSE 46348
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46300: LD_ADDR_EXP 115
46304: PUSH
46305: LD_EXP 115
46309: PPUSH
46310: LD_VAR 0 2
46314: PPUSH
46315: LD_EXP 115
46319: PUSH
46320: LD_VAR 0 2
46324: ARRAY
46325: PPUSH
46326: LD_INT 1
46328: PPUSH
46329: LD_INT 1
46331: NEG
46332: PPUSH
46333: LD_INT 0
46335: PPUSH
46336: CALL 69344 0 4
46340: PPUSH
46341: CALL_OW 1
46345: ST_TO_ADDR
// continue ;
46346: GO 45224
// end ; end ; end ;
46348: GO 45224
46350: POP
46351: POP
// end ;
46352: LD_VAR 0 1
46356: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46357: LD_INT 0
46359: PPUSH
46360: PPUSH
46361: PPUSH
46362: PPUSH
46363: PPUSH
46364: PPUSH
// if not mc_bases then
46365: LD_EXP 110
46369: NOT
46370: IFFALSE 46374
// exit ;
46372: GO 46801
// for i = 1 to mc_bases do
46374: LD_ADDR_VAR 0 2
46378: PUSH
46379: DOUBLE
46380: LD_INT 1
46382: DEC
46383: ST_TO_ADDR
46384: LD_EXP 110
46388: PUSH
46389: FOR_TO
46390: IFFALSE 46799
// begin tmp := mc_build_upgrade [ i ] ;
46392: LD_ADDR_VAR 0 4
46396: PUSH
46397: LD_EXP 142
46401: PUSH
46402: LD_VAR 0 2
46406: ARRAY
46407: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46408: LD_ADDR_VAR 0 6
46412: PUSH
46413: LD_EXP 143
46417: PUSH
46418: LD_VAR 0 2
46422: ARRAY
46423: PPUSH
46424: LD_INT 2
46426: PUSH
46427: LD_INT 30
46429: PUSH
46430: LD_INT 6
46432: PUSH
46433: EMPTY
46434: LIST
46435: LIST
46436: PUSH
46437: LD_INT 30
46439: PUSH
46440: LD_INT 7
46442: PUSH
46443: EMPTY
46444: LIST
46445: LIST
46446: PUSH
46447: EMPTY
46448: LIST
46449: LIST
46450: LIST
46451: PPUSH
46452: CALL_OW 72
46456: ST_TO_ADDR
// if not tmp and not lab then
46457: LD_VAR 0 4
46461: NOT
46462: PUSH
46463: LD_VAR 0 6
46467: NOT
46468: AND
46469: IFFALSE 46473
// continue ;
46471: GO 46389
// if tmp then
46473: LD_VAR 0 4
46477: IFFALSE 46597
// for j in tmp do
46479: LD_ADDR_VAR 0 3
46483: PUSH
46484: LD_VAR 0 4
46488: PUSH
46489: FOR_IN
46490: IFFALSE 46595
// begin if UpgradeCost ( j ) then
46492: LD_VAR 0 3
46496: PPUSH
46497: CALL 76337 0 1
46501: IFFALSE 46593
// begin ComUpgrade ( j ) ;
46503: LD_VAR 0 3
46507: PPUSH
46508: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46512: LD_ADDR_EXP 142
46516: PUSH
46517: LD_EXP 142
46521: PPUSH
46522: LD_VAR 0 2
46526: PPUSH
46527: LD_EXP 142
46531: PUSH
46532: LD_VAR 0 2
46536: ARRAY
46537: PUSH
46538: LD_VAR 0 3
46542: DIFF
46543: PPUSH
46544: CALL_OW 1
46548: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46549: LD_ADDR_EXP 117
46553: PUSH
46554: LD_EXP 117
46558: PPUSH
46559: LD_VAR 0 2
46563: PUSH
46564: LD_EXP 117
46568: PUSH
46569: LD_VAR 0 2
46573: ARRAY
46574: PUSH
46575: LD_INT 1
46577: PLUS
46578: PUSH
46579: EMPTY
46580: LIST
46581: LIST
46582: PPUSH
46583: LD_VAR 0 3
46587: PPUSH
46588: CALL 69926 0 3
46592: ST_TO_ADDR
// end ; end ;
46593: GO 46489
46595: POP
46596: POP
// if not lab or not mc_lab_upgrade [ i ] then
46597: LD_VAR 0 6
46601: NOT
46602: PUSH
46603: LD_EXP 144
46607: PUSH
46608: LD_VAR 0 2
46612: ARRAY
46613: NOT
46614: OR
46615: IFFALSE 46619
// continue ;
46617: GO 46389
// for j in lab do
46619: LD_ADDR_VAR 0 3
46623: PUSH
46624: LD_VAR 0 6
46628: PUSH
46629: FOR_IN
46630: IFFALSE 46795
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
46632: LD_VAR 0 3
46636: PPUSH
46637: CALL_OW 266
46641: PUSH
46642: LD_INT 6
46644: PUSH
46645: LD_INT 7
46647: PUSH
46648: EMPTY
46649: LIST
46650: LIST
46651: IN
46652: PUSH
46653: LD_VAR 0 3
46657: PPUSH
46658: CALL_OW 461
46662: PUSH
46663: LD_INT 1
46665: NONEQUAL
46666: AND
46667: IFFALSE 46793
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
46669: LD_VAR 0 3
46673: PPUSH
46674: LD_EXP 144
46678: PUSH
46679: LD_VAR 0 2
46683: ARRAY
46684: PUSH
46685: LD_INT 1
46687: ARRAY
46688: PPUSH
46689: CALL 76542 0 2
46693: IFFALSE 46793
// begin ComCancel ( j ) ;
46695: LD_VAR 0 3
46699: PPUSH
46700: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
46704: LD_VAR 0 3
46708: PPUSH
46709: LD_EXP 144
46713: PUSH
46714: LD_VAR 0 2
46718: ARRAY
46719: PUSH
46720: LD_INT 1
46722: ARRAY
46723: PPUSH
46724: CALL_OW 207
// if not j in mc_construct_list [ i ] then
46728: LD_VAR 0 3
46732: PUSH
46733: LD_EXP 117
46737: PUSH
46738: LD_VAR 0 2
46742: ARRAY
46743: IN
46744: NOT
46745: IFFALSE 46791
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46747: LD_ADDR_EXP 117
46751: PUSH
46752: LD_EXP 117
46756: PPUSH
46757: LD_VAR 0 2
46761: PUSH
46762: LD_EXP 117
46766: PUSH
46767: LD_VAR 0 2
46771: ARRAY
46772: PUSH
46773: LD_INT 1
46775: PLUS
46776: PUSH
46777: EMPTY
46778: LIST
46779: LIST
46780: PPUSH
46781: LD_VAR 0 3
46785: PPUSH
46786: CALL 69926 0 3
46790: ST_TO_ADDR
// break ;
46791: GO 46795
// end ; end ; end ;
46793: GO 46629
46795: POP
46796: POP
// end ;
46797: GO 46389
46799: POP
46800: POP
// end ;
46801: LD_VAR 0 1
46805: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
46806: LD_INT 0
46808: PPUSH
46809: PPUSH
46810: PPUSH
46811: PPUSH
46812: PPUSH
46813: PPUSH
46814: PPUSH
46815: PPUSH
46816: PPUSH
// if not mc_bases then
46817: LD_EXP 110
46821: NOT
46822: IFFALSE 46826
// exit ;
46824: GO 47231
// for i = 1 to mc_bases do
46826: LD_ADDR_VAR 0 2
46830: PUSH
46831: DOUBLE
46832: LD_INT 1
46834: DEC
46835: ST_TO_ADDR
46836: LD_EXP 110
46840: PUSH
46841: FOR_TO
46842: IFFALSE 47229
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
46844: LD_EXP 118
46848: PUSH
46849: LD_VAR 0 2
46853: ARRAY
46854: NOT
46855: PUSH
46856: LD_EXP 110
46860: PUSH
46861: LD_VAR 0 2
46865: ARRAY
46866: PPUSH
46867: LD_INT 30
46869: PUSH
46870: LD_INT 3
46872: PUSH
46873: EMPTY
46874: LIST
46875: LIST
46876: PPUSH
46877: CALL_OW 72
46881: NOT
46882: OR
46883: IFFALSE 46887
// continue ;
46885: GO 46841
// busy := false ;
46887: LD_ADDR_VAR 0 8
46891: PUSH
46892: LD_INT 0
46894: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
46895: LD_ADDR_VAR 0 4
46899: PUSH
46900: LD_EXP 110
46904: PUSH
46905: LD_VAR 0 2
46909: ARRAY
46910: PPUSH
46911: LD_INT 30
46913: PUSH
46914: LD_INT 3
46916: PUSH
46917: EMPTY
46918: LIST
46919: LIST
46920: PPUSH
46921: CALL_OW 72
46925: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
46926: LD_ADDR_VAR 0 6
46930: PUSH
46931: LD_EXP 118
46935: PUSH
46936: LD_VAR 0 2
46940: ARRAY
46941: PPUSH
46942: LD_INT 2
46944: PUSH
46945: LD_INT 30
46947: PUSH
46948: LD_INT 32
46950: PUSH
46951: EMPTY
46952: LIST
46953: LIST
46954: PUSH
46955: LD_INT 30
46957: PUSH
46958: LD_INT 33
46960: PUSH
46961: EMPTY
46962: LIST
46963: LIST
46964: PUSH
46965: EMPTY
46966: LIST
46967: LIST
46968: LIST
46969: PPUSH
46970: CALL_OW 72
46974: ST_TO_ADDR
// if not t then
46975: LD_VAR 0 6
46979: NOT
46980: IFFALSE 46984
// continue ;
46982: GO 46841
// for j in tmp do
46984: LD_ADDR_VAR 0 3
46988: PUSH
46989: LD_VAR 0 4
46993: PUSH
46994: FOR_IN
46995: IFFALSE 47025
// if not BuildingStatus ( j ) = bs_idle then
46997: LD_VAR 0 3
47001: PPUSH
47002: CALL_OW 461
47006: PUSH
47007: LD_INT 2
47009: EQUAL
47010: NOT
47011: IFFALSE 47023
// begin busy := true ;
47013: LD_ADDR_VAR 0 8
47017: PUSH
47018: LD_INT 1
47020: ST_TO_ADDR
// break ;
47021: GO 47025
// end ;
47023: GO 46994
47025: POP
47026: POP
// if busy then
47027: LD_VAR 0 8
47031: IFFALSE 47035
// continue ;
47033: GO 46841
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
47035: LD_ADDR_VAR 0 7
47039: PUSH
47040: LD_VAR 0 6
47044: PPUSH
47045: LD_INT 35
47047: PUSH
47048: LD_INT 0
47050: PUSH
47051: EMPTY
47052: LIST
47053: LIST
47054: PPUSH
47055: CALL_OW 72
47059: ST_TO_ADDR
// if tw then
47060: LD_VAR 0 7
47064: IFFALSE 47141
// begin tw := tw [ 1 ] ;
47066: LD_ADDR_VAR 0 7
47070: PUSH
47071: LD_VAR 0 7
47075: PUSH
47076: LD_INT 1
47078: ARRAY
47079: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
47080: LD_ADDR_VAR 0 9
47084: PUSH
47085: LD_VAR 0 7
47089: PPUSH
47090: LD_EXP 135
47094: PUSH
47095: LD_VAR 0 2
47099: ARRAY
47100: PPUSH
47101: CALL 74896 0 2
47105: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47106: LD_EXP 149
47110: PUSH
47111: LD_VAR 0 2
47115: ARRAY
47116: IFFALSE 47139
// if not weapon in mc_allowed_tower_weapons [ i ] then
47118: LD_VAR 0 9
47122: PUSH
47123: LD_EXP 149
47127: PUSH
47128: LD_VAR 0 2
47132: ARRAY
47133: IN
47134: NOT
47135: IFFALSE 47139
// continue ;
47137: GO 46841
// end else
47139: GO 47204
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47141: LD_ADDR_VAR 0 5
47145: PUSH
47146: LD_EXP 118
47150: PUSH
47151: LD_VAR 0 2
47155: ARRAY
47156: PPUSH
47157: LD_VAR 0 4
47161: PPUSH
47162: CALL 100398 0 2
47166: ST_TO_ADDR
// if not tmp2 then
47167: LD_VAR 0 5
47171: NOT
47172: IFFALSE 47176
// continue ;
47174: GO 46841
// tw := tmp2 [ 1 ] ;
47176: LD_ADDR_VAR 0 7
47180: PUSH
47181: LD_VAR 0 5
47185: PUSH
47186: LD_INT 1
47188: ARRAY
47189: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47190: LD_ADDR_VAR 0 9
47194: PUSH
47195: LD_VAR 0 5
47199: PUSH
47200: LD_INT 2
47202: ARRAY
47203: ST_TO_ADDR
// end ; if not weapon then
47204: LD_VAR 0 9
47208: NOT
47209: IFFALSE 47213
// continue ;
47211: GO 46841
// ComPlaceWeapon ( tw , weapon ) ;
47213: LD_VAR 0 7
47217: PPUSH
47218: LD_VAR 0 9
47222: PPUSH
47223: CALL_OW 148
// end ;
47227: GO 46841
47229: POP
47230: POP
// end ;
47231: LD_VAR 0 1
47235: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
47236: LD_INT 0
47238: PPUSH
47239: PPUSH
47240: PPUSH
47241: PPUSH
47242: PPUSH
47243: PPUSH
// if not mc_bases then
47244: LD_EXP 110
47248: NOT
47249: IFFALSE 47253
// exit ;
47251: GO 48029
// for i = 1 to mc_bases do
47253: LD_ADDR_VAR 0 2
47257: PUSH
47258: DOUBLE
47259: LD_INT 1
47261: DEC
47262: ST_TO_ADDR
47263: LD_EXP 110
47267: PUSH
47268: FOR_TO
47269: IFFALSE 48027
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47271: LD_EXP 123
47275: PUSH
47276: LD_VAR 0 2
47280: ARRAY
47281: NOT
47282: PUSH
47283: LD_EXP 123
47287: PUSH
47288: LD_VAR 0 2
47292: ARRAY
47293: PUSH
47294: LD_EXP 124
47298: PUSH
47299: LD_VAR 0 2
47303: ARRAY
47304: EQUAL
47305: OR
47306: PUSH
47307: LD_EXP 133
47311: PUSH
47312: LD_VAR 0 2
47316: ARRAY
47317: OR
47318: IFFALSE 47322
// continue ;
47320: GO 47268
// if mc_miners [ i ] then
47322: LD_EXP 124
47326: PUSH
47327: LD_VAR 0 2
47331: ARRAY
47332: IFFALSE 47714
// begin for j = mc_miners [ i ] downto 1 do
47334: LD_ADDR_VAR 0 3
47338: PUSH
47339: DOUBLE
47340: LD_EXP 124
47344: PUSH
47345: LD_VAR 0 2
47349: ARRAY
47350: INC
47351: ST_TO_ADDR
47352: LD_INT 1
47354: PUSH
47355: FOR_DOWNTO
47356: IFFALSE 47712
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47358: LD_EXP 124
47362: PUSH
47363: LD_VAR 0 2
47367: ARRAY
47368: PUSH
47369: LD_VAR 0 3
47373: ARRAY
47374: PPUSH
47375: CALL_OW 301
47379: PUSH
47380: LD_EXP 124
47384: PUSH
47385: LD_VAR 0 2
47389: ARRAY
47390: PUSH
47391: LD_VAR 0 3
47395: ARRAY
47396: PPUSH
47397: CALL_OW 257
47401: PUSH
47402: LD_INT 1
47404: NONEQUAL
47405: OR
47406: IFFALSE 47469
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47408: LD_ADDR_VAR 0 5
47412: PUSH
47413: LD_EXP 124
47417: PUSH
47418: LD_VAR 0 2
47422: ARRAY
47423: PUSH
47424: LD_EXP 124
47428: PUSH
47429: LD_VAR 0 2
47433: ARRAY
47434: PUSH
47435: LD_VAR 0 3
47439: ARRAY
47440: DIFF
47441: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47442: LD_ADDR_EXP 124
47446: PUSH
47447: LD_EXP 124
47451: PPUSH
47452: LD_VAR 0 2
47456: PPUSH
47457: LD_VAR 0 5
47461: PPUSH
47462: CALL_OW 1
47466: ST_TO_ADDR
// continue ;
47467: GO 47355
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47469: LD_EXP 124
47473: PUSH
47474: LD_VAR 0 2
47478: ARRAY
47479: PUSH
47480: LD_VAR 0 3
47484: ARRAY
47485: PPUSH
47486: CALL_OW 257
47490: PUSH
47491: LD_INT 1
47493: EQUAL
47494: PUSH
47495: LD_EXP 124
47499: PUSH
47500: LD_VAR 0 2
47504: ARRAY
47505: PUSH
47506: LD_VAR 0 3
47510: ARRAY
47511: PPUSH
47512: CALL_OW 459
47516: NOT
47517: AND
47518: PUSH
47519: LD_EXP 124
47523: PUSH
47524: LD_VAR 0 2
47528: ARRAY
47529: PUSH
47530: LD_VAR 0 3
47534: ARRAY
47535: PPUSH
47536: CALL_OW 314
47540: NOT
47541: AND
47542: IFFALSE 47710
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
47544: LD_EXP 124
47548: PUSH
47549: LD_VAR 0 2
47553: ARRAY
47554: PUSH
47555: LD_VAR 0 3
47559: ARRAY
47560: PPUSH
47561: CALL_OW 310
47565: IFFALSE 47588
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
47567: LD_EXP 124
47571: PUSH
47572: LD_VAR 0 2
47576: ARRAY
47577: PUSH
47578: LD_VAR 0 3
47582: ARRAY
47583: PPUSH
47584: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
47588: LD_EXP 124
47592: PUSH
47593: LD_VAR 0 2
47597: ARRAY
47598: PUSH
47599: LD_VAR 0 3
47603: ARRAY
47604: PPUSH
47605: CALL_OW 314
47609: NOT
47610: IFFALSE 47710
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
47612: LD_EXP 124
47616: PUSH
47617: LD_VAR 0 2
47621: ARRAY
47622: PUSH
47623: LD_VAR 0 3
47627: ARRAY
47628: PPUSH
47629: LD_EXP 123
47633: PUSH
47634: LD_VAR 0 2
47638: ARRAY
47639: PUSH
47640: LD_VAR 0 3
47644: PUSH
47645: LD_EXP 123
47649: PUSH
47650: LD_VAR 0 2
47654: ARRAY
47655: MOD
47656: PUSH
47657: LD_INT 1
47659: PLUS
47660: ARRAY
47661: PUSH
47662: LD_INT 1
47664: ARRAY
47665: PPUSH
47666: LD_EXP 123
47670: PUSH
47671: LD_VAR 0 2
47675: ARRAY
47676: PUSH
47677: LD_VAR 0 3
47681: PUSH
47682: LD_EXP 123
47686: PUSH
47687: LD_VAR 0 2
47691: ARRAY
47692: MOD
47693: PUSH
47694: LD_INT 1
47696: PLUS
47697: ARRAY
47698: PUSH
47699: LD_INT 2
47701: ARRAY
47702: PPUSH
47703: LD_INT 0
47705: PPUSH
47706: CALL_OW 193
// end ; end ;
47710: GO 47355
47712: POP
47713: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
47714: LD_ADDR_VAR 0 5
47718: PUSH
47719: LD_EXP 110
47723: PUSH
47724: LD_VAR 0 2
47728: ARRAY
47729: PPUSH
47730: LD_INT 2
47732: PUSH
47733: LD_INT 30
47735: PUSH
47736: LD_INT 4
47738: PUSH
47739: EMPTY
47740: LIST
47741: LIST
47742: PUSH
47743: LD_INT 30
47745: PUSH
47746: LD_INT 5
47748: PUSH
47749: EMPTY
47750: LIST
47751: LIST
47752: PUSH
47753: LD_INT 30
47755: PUSH
47756: LD_INT 32
47758: PUSH
47759: EMPTY
47760: LIST
47761: LIST
47762: PUSH
47763: EMPTY
47764: LIST
47765: LIST
47766: LIST
47767: LIST
47768: PPUSH
47769: CALL_OW 72
47773: ST_TO_ADDR
// if not tmp then
47774: LD_VAR 0 5
47778: NOT
47779: IFFALSE 47783
// continue ;
47781: GO 47268
// list := [ ] ;
47783: LD_ADDR_VAR 0 6
47787: PUSH
47788: EMPTY
47789: ST_TO_ADDR
// for j in tmp do
47790: LD_ADDR_VAR 0 3
47794: PUSH
47795: LD_VAR 0 5
47799: PUSH
47800: FOR_IN
47801: IFFALSE 47870
// begin for k in UnitsInside ( j ) do
47803: LD_ADDR_VAR 0 4
47807: PUSH
47808: LD_VAR 0 3
47812: PPUSH
47813: CALL_OW 313
47817: PUSH
47818: FOR_IN
47819: IFFALSE 47866
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
47821: LD_VAR 0 4
47825: PPUSH
47826: CALL_OW 257
47830: PUSH
47831: LD_INT 1
47833: EQUAL
47834: PUSH
47835: LD_VAR 0 4
47839: PPUSH
47840: CALL_OW 459
47844: NOT
47845: AND
47846: IFFALSE 47864
// list := list ^ k ;
47848: LD_ADDR_VAR 0 6
47852: PUSH
47853: LD_VAR 0 6
47857: PUSH
47858: LD_VAR 0 4
47862: ADD
47863: ST_TO_ADDR
47864: GO 47818
47866: POP
47867: POP
// end ;
47868: GO 47800
47870: POP
47871: POP
// list := list diff mc_miners [ i ] ;
47872: LD_ADDR_VAR 0 6
47876: PUSH
47877: LD_VAR 0 6
47881: PUSH
47882: LD_EXP 124
47886: PUSH
47887: LD_VAR 0 2
47891: ARRAY
47892: DIFF
47893: ST_TO_ADDR
// if not list then
47894: LD_VAR 0 6
47898: NOT
47899: IFFALSE 47903
// continue ;
47901: GO 47268
// k := mc_mines [ i ] - mc_miners [ i ] ;
47903: LD_ADDR_VAR 0 4
47907: PUSH
47908: LD_EXP 123
47912: PUSH
47913: LD_VAR 0 2
47917: ARRAY
47918: PUSH
47919: LD_EXP 124
47923: PUSH
47924: LD_VAR 0 2
47928: ARRAY
47929: MINUS
47930: ST_TO_ADDR
// if k > list then
47931: LD_VAR 0 4
47935: PUSH
47936: LD_VAR 0 6
47940: GREATER
47941: IFFALSE 47953
// k := list ;
47943: LD_ADDR_VAR 0 4
47947: PUSH
47948: LD_VAR 0 6
47952: ST_TO_ADDR
// for j = 1 to k do
47953: LD_ADDR_VAR 0 3
47957: PUSH
47958: DOUBLE
47959: LD_INT 1
47961: DEC
47962: ST_TO_ADDR
47963: LD_VAR 0 4
47967: PUSH
47968: FOR_TO
47969: IFFALSE 48023
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
47971: LD_ADDR_EXP 124
47975: PUSH
47976: LD_EXP 124
47980: PPUSH
47981: LD_VAR 0 2
47985: PUSH
47986: LD_EXP 124
47990: PUSH
47991: LD_VAR 0 2
47995: ARRAY
47996: PUSH
47997: LD_INT 1
47999: PLUS
48000: PUSH
48001: EMPTY
48002: LIST
48003: LIST
48004: PPUSH
48005: LD_VAR 0 6
48009: PUSH
48010: LD_VAR 0 3
48014: ARRAY
48015: PPUSH
48016: CALL 69926 0 3
48020: ST_TO_ADDR
48021: GO 47968
48023: POP
48024: POP
// end ;
48025: GO 47268
48027: POP
48028: POP
// end ;
48029: LD_VAR 0 1
48033: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
48034: LD_INT 0
48036: PPUSH
48037: PPUSH
48038: PPUSH
48039: PPUSH
48040: PPUSH
48041: PPUSH
48042: PPUSH
48043: PPUSH
48044: PPUSH
48045: PPUSH
// if not mc_bases then
48046: LD_EXP 110
48050: NOT
48051: IFFALSE 48055
// exit ;
48053: GO 49805
// for i = 1 to mc_bases do
48055: LD_ADDR_VAR 0 2
48059: PUSH
48060: DOUBLE
48061: LD_INT 1
48063: DEC
48064: ST_TO_ADDR
48065: LD_EXP 110
48069: PUSH
48070: FOR_TO
48071: IFFALSE 49803
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
48073: LD_EXP 110
48077: PUSH
48078: LD_VAR 0 2
48082: ARRAY
48083: NOT
48084: PUSH
48085: LD_EXP 117
48089: PUSH
48090: LD_VAR 0 2
48094: ARRAY
48095: OR
48096: IFFALSE 48100
// continue ;
48098: GO 48070
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48100: LD_EXP 126
48104: PUSH
48105: LD_VAR 0 2
48109: ARRAY
48110: NOT
48111: PUSH
48112: LD_EXP 127
48116: PUSH
48117: LD_VAR 0 2
48121: ARRAY
48122: AND
48123: IFFALSE 48161
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48125: LD_ADDR_EXP 127
48129: PUSH
48130: LD_EXP 127
48134: PPUSH
48135: LD_VAR 0 2
48139: PPUSH
48140: EMPTY
48141: PPUSH
48142: CALL_OW 1
48146: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48147: LD_VAR 0 2
48151: PPUSH
48152: LD_INT 107
48154: PPUSH
48155: CALL 39019 0 2
// continue ;
48159: GO 48070
// end ; target := [ ] ;
48161: LD_ADDR_VAR 0 6
48165: PUSH
48166: EMPTY
48167: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48168: LD_ADDR_VAR 0 3
48172: PUSH
48173: DOUBLE
48174: LD_EXP 126
48178: PUSH
48179: LD_VAR 0 2
48183: ARRAY
48184: INC
48185: ST_TO_ADDR
48186: LD_INT 1
48188: PUSH
48189: FOR_DOWNTO
48190: IFFALSE 48450
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48192: LD_EXP 126
48196: PUSH
48197: LD_VAR 0 2
48201: ARRAY
48202: PUSH
48203: LD_VAR 0 3
48207: ARRAY
48208: PUSH
48209: LD_INT 2
48211: ARRAY
48212: PPUSH
48213: LD_EXP 126
48217: PUSH
48218: LD_VAR 0 2
48222: ARRAY
48223: PUSH
48224: LD_VAR 0 3
48228: ARRAY
48229: PUSH
48230: LD_INT 3
48232: ARRAY
48233: PPUSH
48234: CALL_OW 488
48238: PUSH
48239: LD_EXP 126
48243: PUSH
48244: LD_VAR 0 2
48248: ARRAY
48249: PUSH
48250: LD_VAR 0 3
48254: ARRAY
48255: PUSH
48256: LD_INT 2
48258: ARRAY
48259: PPUSH
48260: LD_EXP 126
48264: PUSH
48265: LD_VAR 0 2
48269: ARRAY
48270: PUSH
48271: LD_VAR 0 3
48275: ARRAY
48276: PUSH
48277: LD_INT 3
48279: ARRAY
48280: PPUSH
48281: CALL_OW 284
48285: PUSH
48286: LD_INT 0
48288: EQUAL
48289: AND
48290: IFFALSE 48345
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48292: LD_ADDR_VAR 0 5
48296: PUSH
48297: LD_EXP 126
48301: PUSH
48302: LD_VAR 0 2
48306: ARRAY
48307: PPUSH
48308: LD_VAR 0 3
48312: PPUSH
48313: CALL_OW 3
48317: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48318: LD_ADDR_EXP 126
48322: PUSH
48323: LD_EXP 126
48327: PPUSH
48328: LD_VAR 0 2
48332: PPUSH
48333: LD_VAR 0 5
48337: PPUSH
48338: CALL_OW 1
48342: ST_TO_ADDR
// continue ;
48343: GO 48189
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48345: LD_EXP 110
48349: PUSH
48350: LD_VAR 0 2
48354: ARRAY
48355: PUSH
48356: LD_INT 1
48358: ARRAY
48359: PPUSH
48360: CALL_OW 255
48364: PPUSH
48365: LD_EXP 126
48369: PUSH
48370: LD_VAR 0 2
48374: ARRAY
48375: PUSH
48376: LD_VAR 0 3
48380: ARRAY
48381: PUSH
48382: LD_INT 2
48384: ARRAY
48385: PPUSH
48386: LD_EXP 126
48390: PUSH
48391: LD_VAR 0 2
48395: ARRAY
48396: PUSH
48397: LD_VAR 0 3
48401: ARRAY
48402: PUSH
48403: LD_INT 3
48405: ARRAY
48406: PPUSH
48407: LD_INT 30
48409: PPUSH
48410: CALL 70822 0 4
48414: PUSH
48415: LD_INT 4
48417: ARRAY
48418: PUSH
48419: LD_INT 0
48421: EQUAL
48422: IFFALSE 48448
// begin target := mc_crates [ i ] [ j ] ;
48424: LD_ADDR_VAR 0 6
48428: PUSH
48429: LD_EXP 126
48433: PUSH
48434: LD_VAR 0 2
48438: ARRAY
48439: PUSH
48440: LD_VAR 0 3
48444: ARRAY
48445: ST_TO_ADDR
// break ;
48446: GO 48450
// end ; end ;
48448: GO 48189
48450: POP
48451: POP
// if not target then
48452: LD_VAR 0 6
48456: NOT
48457: IFFALSE 48461
// continue ;
48459: GO 48070
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48461: LD_ADDR_VAR 0 7
48465: PUSH
48466: LD_EXP 129
48470: PUSH
48471: LD_VAR 0 2
48475: ARRAY
48476: PPUSH
48477: LD_INT 2
48479: PUSH
48480: LD_INT 3
48482: PUSH
48483: LD_INT 58
48485: PUSH
48486: EMPTY
48487: LIST
48488: PUSH
48489: EMPTY
48490: LIST
48491: LIST
48492: PUSH
48493: LD_INT 61
48495: PUSH
48496: EMPTY
48497: LIST
48498: PUSH
48499: LD_INT 33
48501: PUSH
48502: LD_INT 5
48504: PUSH
48505: EMPTY
48506: LIST
48507: LIST
48508: PUSH
48509: LD_INT 33
48511: PUSH
48512: LD_INT 3
48514: PUSH
48515: EMPTY
48516: LIST
48517: LIST
48518: PUSH
48519: EMPTY
48520: LIST
48521: LIST
48522: LIST
48523: LIST
48524: LIST
48525: PUSH
48526: LD_INT 2
48528: PUSH
48529: LD_INT 34
48531: PUSH
48532: LD_INT 32
48534: PUSH
48535: EMPTY
48536: LIST
48537: LIST
48538: PUSH
48539: LD_INT 34
48541: PUSH
48542: LD_INT 51
48544: PUSH
48545: EMPTY
48546: LIST
48547: LIST
48548: PUSH
48549: LD_INT 34
48551: PUSH
48552: LD_INT 12
48554: PUSH
48555: EMPTY
48556: LIST
48557: LIST
48558: PUSH
48559: EMPTY
48560: LIST
48561: LIST
48562: LIST
48563: LIST
48564: PUSH
48565: EMPTY
48566: LIST
48567: LIST
48568: PPUSH
48569: CALL_OW 72
48573: ST_TO_ADDR
// if not cargo then
48574: LD_VAR 0 7
48578: NOT
48579: IFFALSE 49222
// begin if mc_crates_collector [ i ] < 5 then
48581: LD_EXP 127
48585: PUSH
48586: LD_VAR 0 2
48590: ARRAY
48591: PUSH
48592: LD_INT 5
48594: LESS
48595: IFFALSE 48961
// begin if mc_ape [ i ] then
48597: LD_EXP 139
48601: PUSH
48602: LD_VAR 0 2
48606: ARRAY
48607: IFFALSE 48654
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
48609: LD_ADDR_VAR 0 5
48613: PUSH
48614: LD_EXP 139
48618: PUSH
48619: LD_VAR 0 2
48623: ARRAY
48624: PPUSH
48625: LD_INT 25
48627: PUSH
48628: LD_INT 16
48630: PUSH
48631: EMPTY
48632: LIST
48633: LIST
48634: PUSH
48635: LD_INT 24
48637: PUSH
48638: LD_INT 750
48640: PUSH
48641: EMPTY
48642: LIST
48643: LIST
48644: PUSH
48645: EMPTY
48646: LIST
48647: LIST
48648: PPUSH
48649: CALL_OW 72
48653: ST_TO_ADDR
// if not tmp then
48654: LD_VAR 0 5
48658: NOT
48659: IFFALSE 48706
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
48661: LD_ADDR_VAR 0 5
48665: PUSH
48666: LD_EXP 110
48670: PUSH
48671: LD_VAR 0 2
48675: ARRAY
48676: PPUSH
48677: LD_INT 25
48679: PUSH
48680: LD_INT 2
48682: PUSH
48683: EMPTY
48684: LIST
48685: LIST
48686: PUSH
48687: LD_INT 24
48689: PUSH
48690: LD_INT 750
48692: PUSH
48693: EMPTY
48694: LIST
48695: LIST
48696: PUSH
48697: EMPTY
48698: LIST
48699: LIST
48700: PPUSH
48701: CALL_OW 72
48705: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
48706: LD_EXP 139
48710: PUSH
48711: LD_VAR 0 2
48715: ARRAY
48716: PUSH
48717: LD_EXP 110
48721: PUSH
48722: LD_VAR 0 2
48726: ARRAY
48727: PPUSH
48728: LD_INT 25
48730: PUSH
48731: LD_INT 2
48733: PUSH
48734: EMPTY
48735: LIST
48736: LIST
48737: PUSH
48738: LD_INT 24
48740: PUSH
48741: LD_INT 750
48743: PUSH
48744: EMPTY
48745: LIST
48746: LIST
48747: PUSH
48748: EMPTY
48749: LIST
48750: LIST
48751: PPUSH
48752: CALL_OW 72
48756: AND
48757: PUSH
48758: LD_VAR 0 5
48762: PUSH
48763: LD_INT 5
48765: LESS
48766: AND
48767: IFFALSE 48849
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
48769: LD_ADDR_VAR 0 3
48773: PUSH
48774: LD_EXP 110
48778: PUSH
48779: LD_VAR 0 2
48783: ARRAY
48784: PPUSH
48785: LD_INT 25
48787: PUSH
48788: LD_INT 2
48790: PUSH
48791: EMPTY
48792: LIST
48793: LIST
48794: PUSH
48795: LD_INT 24
48797: PUSH
48798: LD_INT 750
48800: PUSH
48801: EMPTY
48802: LIST
48803: LIST
48804: PUSH
48805: EMPTY
48806: LIST
48807: LIST
48808: PPUSH
48809: CALL_OW 72
48813: PUSH
48814: FOR_IN
48815: IFFALSE 48847
// begin tmp := tmp union j ;
48817: LD_ADDR_VAR 0 5
48821: PUSH
48822: LD_VAR 0 5
48826: PUSH
48827: LD_VAR 0 3
48831: UNION
48832: ST_TO_ADDR
// if tmp >= 5 then
48833: LD_VAR 0 5
48837: PUSH
48838: LD_INT 5
48840: GREATEREQUAL
48841: IFFALSE 48845
// break ;
48843: GO 48847
// end ;
48845: GO 48814
48847: POP
48848: POP
// end ; if not tmp then
48849: LD_VAR 0 5
48853: NOT
48854: IFFALSE 48858
// continue ;
48856: GO 48070
// for j in tmp do
48858: LD_ADDR_VAR 0 3
48862: PUSH
48863: LD_VAR 0 5
48867: PUSH
48868: FOR_IN
48869: IFFALSE 48959
// if not GetTag ( j ) then
48871: LD_VAR 0 3
48875: PPUSH
48876: CALL_OW 110
48880: NOT
48881: IFFALSE 48957
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
48883: LD_ADDR_EXP 127
48887: PUSH
48888: LD_EXP 127
48892: PPUSH
48893: LD_VAR 0 2
48897: PUSH
48898: LD_EXP 127
48902: PUSH
48903: LD_VAR 0 2
48907: ARRAY
48908: PUSH
48909: LD_INT 1
48911: PLUS
48912: PUSH
48913: EMPTY
48914: LIST
48915: LIST
48916: PPUSH
48917: LD_VAR 0 3
48921: PPUSH
48922: CALL 69926 0 3
48926: ST_TO_ADDR
// SetTag ( j , 107 ) ;
48927: LD_VAR 0 3
48931: PPUSH
48932: LD_INT 107
48934: PPUSH
48935: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
48939: LD_EXP 127
48943: PUSH
48944: LD_VAR 0 2
48948: ARRAY
48949: PUSH
48950: LD_INT 5
48952: GREATEREQUAL
48953: IFFALSE 48957
// break ;
48955: GO 48959
// end ;
48957: GO 48868
48959: POP
48960: POP
// end ; if mc_crates_collector [ i ] and target then
48961: LD_EXP 127
48965: PUSH
48966: LD_VAR 0 2
48970: ARRAY
48971: PUSH
48972: LD_VAR 0 6
48976: AND
48977: IFFALSE 49220
// begin if mc_crates_collector [ i ] < target [ 1 ] then
48979: LD_EXP 127
48983: PUSH
48984: LD_VAR 0 2
48988: ARRAY
48989: PUSH
48990: LD_VAR 0 6
48994: PUSH
48995: LD_INT 1
48997: ARRAY
48998: LESS
48999: IFFALSE 49019
// tmp := mc_crates_collector [ i ] else
49001: LD_ADDR_VAR 0 5
49005: PUSH
49006: LD_EXP 127
49010: PUSH
49011: LD_VAR 0 2
49015: ARRAY
49016: ST_TO_ADDR
49017: GO 49033
// tmp := target [ 1 ] ;
49019: LD_ADDR_VAR 0 5
49023: PUSH
49024: LD_VAR 0 6
49028: PUSH
49029: LD_INT 1
49031: ARRAY
49032: ST_TO_ADDR
// k := 0 ;
49033: LD_ADDR_VAR 0 4
49037: PUSH
49038: LD_INT 0
49040: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
49041: LD_ADDR_VAR 0 3
49045: PUSH
49046: LD_EXP 127
49050: PUSH
49051: LD_VAR 0 2
49055: ARRAY
49056: PUSH
49057: FOR_IN
49058: IFFALSE 49218
// begin k := k + 1 ;
49060: LD_ADDR_VAR 0 4
49064: PUSH
49065: LD_VAR 0 4
49069: PUSH
49070: LD_INT 1
49072: PLUS
49073: ST_TO_ADDR
// if k > tmp then
49074: LD_VAR 0 4
49078: PUSH
49079: LD_VAR 0 5
49083: GREATER
49084: IFFALSE 49088
// break ;
49086: GO 49218
// if not GetClass ( j ) in [ 2 , 16 ] then
49088: LD_VAR 0 3
49092: PPUSH
49093: CALL_OW 257
49097: PUSH
49098: LD_INT 2
49100: PUSH
49101: LD_INT 16
49103: PUSH
49104: EMPTY
49105: LIST
49106: LIST
49107: IN
49108: NOT
49109: IFFALSE 49162
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49111: LD_ADDR_EXP 127
49115: PUSH
49116: LD_EXP 127
49120: PPUSH
49121: LD_VAR 0 2
49125: PPUSH
49126: LD_EXP 127
49130: PUSH
49131: LD_VAR 0 2
49135: ARRAY
49136: PUSH
49137: LD_VAR 0 3
49141: DIFF
49142: PPUSH
49143: CALL_OW 1
49147: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49148: LD_VAR 0 3
49152: PPUSH
49153: LD_INT 0
49155: PPUSH
49156: CALL_OW 109
// continue ;
49160: GO 49057
// end ; if IsInUnit ( j ) then
49162: LD_VAR 0 3
49166: PPUSH
49167: CALL_OW 310
49171: IFFALSE 49182
// ComExitBuilding ( j ) ;
49173: LD_VAR 0 3
49177: PPUSH
49178: CALL_OW 122
// wait ( 3 ) ;
49182: LD_INT 3
49184: PPUSH
49185: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49189: LD_VAR 0 3
49193: PPUSH
49194: LD_VAR 0 6
49198: PUSH
49199: LD_INT 2
49201: ARRAY
49202: PPUSH
49203: LD_VAR 0 6
49207: PUSH
49208: LD_INT 3
49210: ARRAY
49211: PPUSH
49212: CALL_OW 117
// end ;
49216: GO 49057
49218: POP
49219: POP
// end ; end else
49220: GO 49801
// begin for j in cargo do
49222: LD_ADDR_VAR 0 3
49226: PUSH
49227: LD_VAR 0 7
49231: PUSH
49232: FOR_IN
49233: IFFALSE 49799
// begin if GetTag ( j ) <> 0 then
49235: LD_VAR 0 3
49239: PPUSH
49240: CALL_OW 110
49244: PUSH
49245: LD_INT 0
49247: NONEQUAL
49248: IFFALSE 49252
// continue ;
49250: GO 49232
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49252: LD_VAR 0 3
49256: PPUSH
49257: CALL_OW 256
49261: PUSH
49262: LD_INT 1000
49264: LESS
49265: PUSH
49266: LD_VAR 0 3
49270: PPUSH
49271: LD_EXP 134
49275: PUSH
49276: LD_VAR 0 2
49280: ARRAY
49281: PPUSH
49282: CALL_OW 308
49286: NOT
49287: AND
49288: IFFALSE 49310
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49290: LD_VAR 0 3
49294: PPUSH
49295: LD_EXP 134
49299: PUSH
49300: LD_VAR 0 2
49304: ARRAY
49305: PPUSH
49306: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49310: LD_VAR 0 3
49314: PPUSH
49315: CALL_OW 256
49319: PUSH
49320: LD_INT 1000
49322: LESS
49323: PUSH
49324: LD_VAR 0 3
49328: PPUSH
49329: LD_EXP 134
49333: PUSH
49334: LD_VAR 0 2
49338: ARRAY
49339: PPUSH
49340: CALL_OW 308
49344: AND
49345: IFFALSE 49349
// continue ;
49347: GO 49232
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49349: LD_VAR 0 3
49353: PPUSH
49354: CALL_OW 262
49358: PUSH
49359: LD_INT 2
49361: EQUAL
49362: PUSH
49363: LD_VAR 0 3
49367: PPUSH
49368: CALL_OW 261
49372: PUSH
49373: LD_INT 15
49375: LESS
49376: AND
49377: IFFALSE 49381
// continue ;
49379: GO 49232
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49381: LD_VAR 0 3
49385: PPUSH
49386: CALL_OW 262
49390: PUSH
49391: LD_INT 1
49393: EQUAL
49394: PUSH
49395: LD_VAR 0 3
49399: PPUSH
49400: CALL_OW 261
49404: PUSH
49405: LD_INT 10
49407: LESS
49408: AND
49409: IFFALSE 49738
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49411: LD_ADDR_VAR 0 8
49415: PUSH
49416: LD_EXP 110
49420: PUSH
49421: LD_VAR 0 2
49425: ARRAY
49426: PPUSH
49427: LD_INT 2
49429: PUSH
49430: LD_INT 30
49432: PUSH
49433: LD_INT 0
49435: PUSH
49436: EMPTY
49437: LIST
49438: LIST
49439: PUSH
49440: LD_INT 30
49442: PUSH
49443: LD_INT 1
49445: PUSH
49446: EMPTY
49447: LIST
49448: LIST
49449: PUSH
49450: EMPTY
49451: LIST
49452: LIST
49453: LIST
49454: PPUSH
49455: CALL_OW 72
49459: ST_TO_ADDR
// if not depot then
49460: LD_VAR 0 8
49464: NOT
49465: IFFALSE 49469
// continue ;
49467: GO 49232
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
49469: LD_VAR 0 3
49473: PPUSH
49474: LD_VAR 0 8
49478: PPUSH
49479: LD_VAR 0 3
49483: PPUSH
49484: CALL_OW 74
49488: PPUSH
49489: CALL_OW 296
49493: PUSH
49494: LD_INT 6
49496: LESS
49497: IFFALSE 49513
// SetFuel ( j , 100 ) else
49499: LD_VAR 0 3
49503: PPUSH
49504: LD_INT 100
49506: PPUSH
49507: CALL_OW 240
49511: GO 49738
// if GetFuel ( j ) = 0 then
49513: LD_VAR 0 3
49517: PPUSH
49518: CALL_OW 261
49522: PUSH
49523: LD_INT 0
49525: EQUAL
49526: IFFALSE 49738
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
49528: LD_ADDR_EXP 129
49532: PUSH
49533: LD_EXP 129
49537: PPUSH
49538: LD_VAR 0 2
49542: PPUSH
49543: LD_EXP 129
49547: PUSH
49548: LD_VAR 0 2
49552: ARRAY
49553: PUSH
49554: LD_VAR 0 3
49558: DIFF
49559: PPUSH
49560: CALL_OW 1
49564: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
49565: LD_VAR 0 3
49569: PPUSH
49570: CALL_OW 263
49574: PUSH
49575: LD_INT 1
49577: EQUAL
49578: IFFALSE 49594
// ComExitVehicle ( IsInUnit ( j ) ) ;
49580: LD_VAR 0 3
49584: PPUSH
49585: CALL_OW 310
49589: PPUSH
49590: CALL_OW 121
// if GetControl ( j ) = control_remote then
49594: LD_VAR 0 3
49598: PPUSH
49599: CALL_OW 263
49603: PUSH
49604: LD_INT 2
49606: EQUAL
49607: IFFALSE 49618
// ComUnlink ( j ) ;
49609: LD_VAR 0 3
49613: PPUSH
49614: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
49618: LD_ADDR_VAR 0 9
49622: PUSH
49623: LD_VAR 0 2
49627: PPUSH
49628: LD_INT 3
49630: PPUSH
49631: CALL 59091 0 2
49635: ST_TO_ADDR
// if fac then
49636: LD_VAR 0 9
49640: IFFALSE 49736
// begin for k in fac do
49642: LD_ADDR_VAR 0 4
49646: PUSH
49647: LD_VAR 0 9
49651: PUSH
49652: FOR_IN
49653: IFFALSE 49734
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
49655: LD_ADDR_VAR 0 10
49659: PUSH
49660: LD_VAR 0 9
49664: PPUSH
49665: LD_VAR 0 3
49669: PPUSH
49670: CALL_OW 265
49674: PPUSH
49675: LD_VAR 0 3
49679: PPUSH
49680: CALL_OW 262
49684: PPUSH
49685: LD_VAR 0 3
49689: PPUSH
49690: CALL_OW 263
49694: PPUSH
49695: LD_VAR 0 3
49699: PPUSH
49700: CALL_OW 264
49704: PPUSH
49705: CALL 67458 0 5
49709: ST_TO_ADDR
// if components then
49710: LD_VAR 0 10
49714: IFFALSE 49732
// begin MC_InsertProduceList ( i , components ) ;
49716: LD_VAR 0 2
49720: PPUSH
49721: LD_VAR 0 10
49725: PPUSH
49726: CALL 58636 0 2
// break ;
49730: GO 49734
// end ; end ;
49732: GO 49652
49734: POP
49735: POP
// end ; continue ;
49736: GO 49232
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
49738: LD_VAR 0 3
49742: PPUSH
49743: LD_INT 1
49745: PPUSH
49746: CALL_OW 289
49750: PUSH
49751: LD_INT 100
49753: LESS
49754: PUSH
49755: LD_VAR 0 3
49759: PPUSH
49760: CALL_OW 314
49764: NOT
49765: AND
49766: IFFALSE 49795
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49768: LD_VAR 0 3
49772: PPUSH
49773: LD_VAR 0 6
49777: PUSH
49778: LD_INT 2
49780: ARRAY
49781: PPUSH
49782: LD_VAR 0 6
49786: PUSH
49787: LD_INT 3
49789: ARRAY
49790: PPUSH
49791: CALL_OW 117
// break ;
49795: GO 49799
// end ;
49797: GO 49232
49799: POP
49800: POP
// end ; end ;
49801: GO 48070
49803: POP
49804: POP
// end ;
49805: LD_VAR 0 1
49809: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
49810: LD_INT 0
49812: PPUSH
49813: PPUSH
49814: PPUSH
49815: PPUSH
// if not mc_bases then
49816: LD_EXP 110
49820: NOT
49821: IFFALSE 49825
// exit ;
49823: GO 49986
// for i = 1 to mc_bases do
49825: LD_ADDR_VAR 0 2
49829: PUSH
49830: DOUBLE
49831: LD_INT 1
49833: DEC
49834: ST_TO_ADDR
49835: LD_EXP 110
49839: PUSH
49840: FOR_TO
49841: IFFALSE 49984
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
49843: LD_ADDR_VAR 0 4
49847: PUSH
49848: LD_EXP 129
49852: PUSH
49853: LD_VAR 0 2
49857: ARRAY
49858: PUSH
49859: LD_EXP 132
49863: PUSH
49864: LD_VAR 0 2
49868: ARRAY
49869: UNION
49870: PPUSH
49871: LD_INT 33
49873: PUSH
49874: LD_INT 2
49876: PUSH
49877: EMPTY
49878: LIST
49879: LIST
49880: PPUSH
49881: CALL_OW 72
49885: ST_TO_ADDR
// if tmp then
49886: LD_VAR 0 4
49890: IFFALSE 49982
// for j in tmp do
49892: LD_ADDR_VAR 0 3
49896: PUSH
49897: LD_VAR 0 4
49901: PUSH
49902: FOR_IN
49903: IFFALSE 49980
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
49905: LD_VAR 0 3
49909: PPUSH
49910: CALL_OW 312
49914: NOT
49915: PUSH
49916: LD_VAR 0 3
49920: PPUSH
49921: CALL_OW 256
49925: PUSH
49926: LD_INT 250
49928: GREATEREQUAL
49929: AND
49930: IFFALSE 49943
// Connect ( j ) else
49932: LD_VAR 0 3
49936: PPUSH
49937: CALL 72859 0 1
49941: GO 49978
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
49943: LD_VAR 0 3
49947: PPUSH
49948: CALL_OW 256
49952: PUSH
49953: LD_INT 250
49955: LESS
49956: PUSH
49957: LD_VAR 0 3
49961: PPUSH
49962: CALL_OW 312
49966: AND
49967: IFFALSE 49978
// ComUnlink ( j ) ;
49969: LD_VAR 0 3
49973: PPUSH
49974: CALL_OW 136
49978: GO 49902
49980: POP
49981: POP
// end ;
49982: GO 49840
49984: POP
49985: POP
// end ;
49986: LD_VAR 0 1
49990: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
49991: LD_INT 0
49993: PPUSH
49994: PPUSH
49995: PPUSH
49996: PPUSH
49997: PPUSH
// if not mc_bases then
49998: LD_EXP 110
50002: NOT
50003: IFFALSE 50007
// exit ;
50005: GO 50452
// for i = 1 to mc_bases do
50007: LD_ADDR_VAR 0 2
50011: PUSH
50012: DOUBLE
50013: LD_INT 1
50015: DEC
50016: ST_TO_ADDR
50017: LD_EXP 110
50021: PUSH
50022: FOR_TO
50023: IFFALSE 50450
// begin if not mc_produce [ i ] then
50025: LD_EXP 131
50029: PUSH
50030: LD_VAR 0 2
50034: ARRAY
50035: NOT
50036: IFFALSE 50040
// continue ;
50038: GO 50022
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50040: LD_ADDR_VAR 0 5
50044: PUSH
50045: LD_EXP 110
50049: PUSH
50050: LD_VAR 0 2
50054: ARRAY
50055: PPUSH
50056: LD_INT 30
50058: PUSH
50059: LD_INT 3
50061: PUSH
50062: EMPTY
50063: LIST
50064: LIST
50065: PPUSH
50066: CALL_OW 72
50070: ST_TO_ADDR
// if not fac then
50071: LD_VAR 0 5
50075: NOT
50076: IFFALSE 50080
// continue ;
50078: GO 50022
// for j in fac do
50080: LD_ADDR_VAR 0 3
50084: PUSH
50085: LD_VAR 0 5
50089: PUSH
50090: FOR_IN
50091: IFFALSE 50446
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50093: LD_VAR 0 3
50097: PPUSH
50098: CALL_OW 461
50102: PUSH
50103: LD_INT 2
50105: NONEQUAL
50106: PUSH
50107: LD_VAR 0 3
50111: PPUSH
50112: LD_INT 15
50114: PPUSH
50115: CALL 72519 0 2
50119: PUSH
50120: LD_INT 4
50122: ARRAY
50123: OR
50124: IFFALSE 50128
// continue ;
50126: GO 50090
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50128: LD_VAR 0 3
50132: PPUSH
50133: LD_EXP 131
50137: PUSH
50138: LD_VAR 0 2
50142: ARRAY
50143: PUSH
50144: LD_INT 1
50146: ARRAY
50147: PUSH
50148: LD_INT 1
50150: ARRAY
50151: PPUSH
50152: LD_EXP 131
50156: PUSH
50157: LD_VAR 0 2
50161: ARRAY
50162: PUSH
50163: LD_INT 1
50165: ARRAY
50166: PUSH
50167: LD_INT 2
50169: ARRAY
50170: PPUSH
50171: LD_EXP 131
50175: PUSH
50176: LD_VAR 0 2
50180: ARRAY
50181: PUSH
50182: LD_INT 1
50184: ARRAY
50185: PUSH
50186: LD_INT 3
50188: ARRAY
50189: PPUSH
50190: LD_EXP 131
50194: PUSH
50195: LD_VAR 0 2
50199: ARRAY
50200: PUSH
50201: LD_INT 1
50203: ARRAY
50204: PUSH
50205: LD_INT 4
50207: ARRAY
50208: PPUSH
50209: CALL_OW 448
50213: PUSH
50214: LD_VAR 0 3
50218: PPUSH
50219: LD_EXP 131
50223: PUSH
50224: LD_VAR 0 2
50228: ARRAY
50229: PUSH
50230: LD_INT 1
50232: ARRAY
50233: PUSH
50234: LD_INT 1
50236: ARRAY
50237: PUSH
50238: LD_EXP 131
50242: PUSH
50243: LD_VAR 0 2
50247: ARRAY
50248: PUSH
50249: LD_INT 1
50251: ARRAY
50252: PUSH
50253: LD_INT 2
50255: ARRAY
50256: PUSH
50257: LD_EXP 131
50261: PUSH
50262: LD_VAR 0 2
50266: ARRAY
50267: PUSH
50268: LD_INT 1
50270: ARRAY
50271: PUSH
50272: LD_INT 3
50274: ARRAY
50275: PUSH
50276: LD_EXP 131
50280: PUSH
50281: LD_VAR 0 2
50285: ARRAY
50286: PUSH
50287: LD_INT 1
50289: ARRAY
50290: PUSH
50291: LD_INT 4
50293: ARRAY
50294: PUSH
50295: EMPTY
50296: LIST
50297: LIST
50298: LIST
50299: LIST
50300: PPUSH
50301: CALL 76190 0 2
50305: AND
50306: IFFALSE 50444
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50308: LD_VAR 0 3
50312: PPUSH
50313: LD_EXP 131
50317: PUSH
50318: LD_VAR 0 2
50322: ARRAY
50323: PUSH
50324: LD_INT 1
50326: ARRAY
50327: PUSH
50328: LD_INT 1
50330: ARRAY
50331: PPUSH
50332: LD_EXP 131
50336: PUSH
50337: LD_VAR 0 2
50341: ARRAY
50342: PUSH
50343: LD_INT 1
50345: ARRAY
50346: PUSH
50347: LD_INT 2
50349: ARRAY
50350: PPUSH
50351: LD_EXP 131
50355: PUSH
50356: LD_VAR 0 2
50360: ARRAY
50361: PUSH
50362: LD_INT 1
50364: ARRAY
50365: PUSH
50366: LD_INT 3
50368: ARRAY
50369: PPUSH
50370: LD_EXP 131
50374: PUSH
50375: LD_VAR 0 2
50379: ARRAY
50380: PUSH
50381: LD_INT 1
50383: ARRAY
50384: PUSH
50385: LD_INT 4
50387: ARRAY
50388: PPUSH
50389: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50393: LD_ADDR_VAR 0 4
50397: PUSH
50398: LD_EXP 131
50402: PUSH
50403: LD_VAR 0 2
50407: ARRAY
50408: PPUSH
50409: LD_INT 1
50411: PPUSH
50412: CALL_OW 3
50416: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50417: LD_ADDR_EXP 131
50421: PUSH
50422: LD_EXP 131
50426: PPUSH
50427: LD_VAR 0 2
50431: PPUSH
50432: LD_VAR 0 4
50436: PPUSH
50437: CALL_OW 1
50441: ST_TO_ADDR
// break ;
50442: GO 50446
// end ; end ;
50444: GO 50090
50446: POP
50447: POP
// end ;
50448: GO 50022
50450: POP
50451: POP
// end ;
50452: LD_VAR 0 1
50456: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
50457: LD_INT 0
50459: PPUSH
50460: PPUSH
50461: PPUSH
// if not mc_bases then
50462: LD_EXP 110
50466: NOT
50467: IFFALSE 50471
// exit ;
50469: GO 50560
// for i = 1 to mc_bases do
50471: LD_ADDR_VAR 0 2
50475: PUSH
50476: DOUBLE
50477: LD_INT 1
50479: DEC
50480: ST_TO_ADDR
50481: LD_EXP 110
50485: PUSH
50486: FOR_TO
50487: IFFALSE 50558
// begin if mc_attack [ i ] then
50489: LD_EXP 130
50493: PUSH
50494: LD_VAR 0 2
50498: ARRAY
50499: IFFALSE 50556
// begin tmp := mc_attack [ i ] [ 1 ] ;
50501: LD_ADDR_VAR 0 3
50505: PUSH
50506: LD_EXP 130
50510: PUSH
50511: LD_VAR 0 2
50515: ARRAY
50516: PUSH
50517: LD_INT 1
50519: ARRAY
50520: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50521: LD_ADDR_EXP 130
50525: PUSH
50526: LD_EXP 130
50530: PPUSH
50531: LD_VAR 0 2
50535: PPUSH
50536: EMPTY
50537: PPUSH
50538: CALL_OW 1
50542: ST_TO_ADDR
// Attack ( tmp ) ;
50543: LD_VAR 0 3
50547: PPUSH
50548: CALL 112749 0 1
// exit ;
50552: POP
50553: POP
50554: GO 50560
// end ; end ;
50556: GO 50486
50558: POP
50559: POP
// end ;
50560: LD_VAR 0 1
50564: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
50565: LD_INT 0
50567: PPUSH
50568: PPUSH
50569: PPUSH
50570: PPUSH
50571: PPUSH
50572: PPUSH
50573: PPUSH
// if not mc_bases then
50574: LD_EXP 110
50578: NOT
50579: IFFALSE 50583
// exit ;
50581: GO 51165
// for i = 1 to mc_bases do
50583: LD_ADDR_VAR 0 2
50587: PUSH
50588: DOUBLE
50589: LD_INT 1
50591: DEC
50592: ST_TO_ADDR
50593: LD_EXP 110
50597: PUSH
50598: FOR_TO
50599: IFFALSE 51163
// begin if not mc_bases [ i ] then
50601: LD_EXP 110
50605: PUSH
50606: LD_VAR 0 2
50610: ARRAY
50611: NOT
50612: IFFALSE 50616
// continue ;
50614: GO 50598
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
50616: LD_ADDR_VAR 0 7
50620: PUSH
50621: LD_EXP 110
50625: PUSH
50626: LD_VAR 0 2
50630: ARRAY
50631: PUSH
50632: LD_INT 1
50634: ARRAY
50635: PPUSH
50636: CALL 66762 0 1
50640: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
50641: LD_ADDR_EXP 133
50645: PUSH
50646: LD_EXP 133
50650: PPUSH
50651: LD_VAR 0 2
50655: PPUSH
50656: LD_EXP 110
50660: PUSH
50661: LD_VAR 0 2
50665: ARRAY
50666: PUSH
50667: LD_INT 1
50669: ARRAY
50670: PPUSH
50671: CALL_OW 255
50675: PPUSH
50676: LD_EXP 135
50680: PUSH
50681: LD_VAR 0 2
50685: ARRAY
50686: PPUSH
50687: CALL 66727 0 2
50691: PPUSH
50692: CALL_OW 1
50696: ST_TO_ADDR
// if not mc_scan [ i ] then
50697: LD_EXP 133
50701: PUSH
50702: LD_VAR 0 2
50706: ARRAY
50707: NOT
50708: IFFALSE 50863
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50710: LD_ADDR_VAR 0 4
50714: PUSH
50715: LD_EXP 110
50719: PUSH
50720: LD_VAR 0 2
50724: ARRAY
50725: PPUSH
50726: LD_INT 2
50728: PUSH
50729: LD_INT 25
50731: PUSH
50732: LD_INT 5
50734: PUSH
50735: EMPTY
50736: LIST
50737: LIST
50738: PUSH
50739: LD_INT 25
50741: PUSH
50742: LD_INT 8
50744: PUSH
50745: EMPTY
50746: LIST
50747: LIST
50748: PUSH
50749: LD_INT 25
50751: PUSH
50752: LD_INT 9
50754: PUSH
50755: EMPTY
50756: LIST
50757: LIST
50758: PUSH
50759: EMPTY
50760: LIST
50761: LIST
50762: LIST
50763: LIST
50764: PPUSH
50765: CALL_OW 72
50769: ST_TO_ADDR
// if not tmp then
50770: LD_VAR 0 4
50774: NOT
50775: IFFALSE 50779
// continue ;
50777: GO 50598
// for j in tmp do
50779: LD_ADDR_VAR 0 3
50783: PUSH
50784: LD_VAR 0 4
50788: PUSH
50789: FOR_IN
50790: IFFALSE 50861
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
50792: LD_VAR 0 3
50796: PPUSH
50797: CALL_OW 310
50801: PPUSH
50802: CALL_OW 266
50806: PUSH
50807: LD_INT 5
50809: EQUAL
50810: PUSH
50811: LD_VAR 0 3
50815: PPUSH
50816: CALL_OW 257
50820: PUSH
50821: LD_INT 1
50823: EQUAL
50824: AND
50825: PUSH
50826: LD_VAR 0 3
50830: PPUSH
50831: CALL_OW 459
50835: NOT
50836: AND
50837: PUSH
50838: LD_VAR 0 7
50842: AND
50843: IFFALSE 50859
// ComChangeProfession ( j , class ) ;
50845: LD_VAR 0 3
50849: PPUSH
50850: LD_VAR 0 7
50854: PPUSH
50855: CALL_OW 123
50859: GO 50789
50861: POP
50862: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
50863: LD_EXP 133
50867: PUSH
50868: LD_VAR 0 2
50872: ARRAY
50873: PUSH
50874: LD_EXP 132
50878: PUSH
50879: LD_VAR 0 2
50883: ARRAY
50884: NOT
50885: AND
50886: PUSH
50887: LD_EXP 110
50891: PUSH
50892: LD_VAR 0 2
50896: ARRAY
50897: PPUSH
50898: LD_INT 30
50900: PUSH
50901: LD_INT 32
50903: PUSH
50904: EMPTY
50905: LIST
50906: LIST
50907: PPUSH
50908: CALL_OW 72
50912: NOT
50913: AND
50914: PUSH
50915: LD_EXP 110
50919: PUSH
50920: LD_VAR 0 2
50924: ARRAY
50925: PPUSH
50926: LD_INT 2
50928: PUSH
50929: LD_INT 30
50931: PUSH
50932: LD_INT 4
50934: PUSH
50935: EMPTY
50936: LIST
50937: LIST
50938: PUSH
50939: LD_INT 30
50941: PUSH
50942: LD_INT 5
50944: PUSH
50945: EMPTY
50946: LIST
50947: LIST
50948: PUSH
50949: EMPTY
50950: LIST
50951: LIST
50952: LIST
50953: PPUSH
50954: CALL_OW 72
50958: NOT
50959: AND
50960: IFFALSE 51092
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50962: LD_ADDR_VAR 0 4
50966: PUSH
50967: LD_EXP 110
50971: PUSH
50972: LD_VAR 0 2
50976: ARRAY
50977: PPUSH
50978: LD_INT 2
50980: PUSH
50981: LD_INT 25
50983: PUSH
50984: LD_INT 1
50986: PUSH
50987: EMPTY
50988: LIST
50989: LIST
50990: PUSH
50991: LD_INT 25
50993: PUSH
50994: LD_INT 5
50996: PUSH
50997: EMPTY
50998: LIST
50999: LIST
51000: PUSH
51001: LD_INT 25
51003: PUSH
51004: LD_INT 8
51006: PUSH
51007: EMPTY
51008: LIST
51009: LIST
51010: PUSH
51011: LD_INT 25
51013: PUSH
51014: LD_INT 9
51016: PUSH
51017: EMPTY
51018: LIST
51019: LIST
51020: PUSH
51021: EMPTY
51022: LIST
51023: LIST
51024: LIST
51025: LIST
51026: LIST
51027: PPUSH
51028: CALL_OW 72
51032: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
51033: LD_ADDR_VAR 0 4
51037: PUSH
51038: LD_VAR 0 4
51042: PUSH
51043: LD_VAR 0 4
51047: PPUSH
51048: LD_INT 18
51050: PPUSH
51051: CALL 98487 0 2
51055: DIFF
51056: ST_TO_ADDR
// if tmp then
51057: LD_VAR 0 4
51061: IFFALSE 51092
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
51063: LD_VAR 0 2
51067: PPUSH
51068: LD_VAR 0 4
51072: PPUSH
51073: LD_EXP 135
51077: PUSH
51078: LD_VAR 0 2
51082: ARRAY
51083: PPUSH
51084: CALL 117458 0 3
// exit ;
51088: POP
51089: POP
51090: GO 51165
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
51092: LD_EXP 133
51096: PUSH
51097: LD_VAR 0 2
51101: ARRAY
51102: PUSH
51103: LD_EXP 132
51107: PUSH
51108: LD_VAR 0 2
51112: ARRAY
51113: AND
51114: IFFALSE 51161
// begin tmp := mc_defender [ i ] ;
51116: LD_ADDR_VAR 0 4
51120: PUSH
51121: LD_EXP 132
51125: PUSH
51126: LD_VAR 0 2
51130: ARRAY
51131: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
51132: LD_VAR 0 2
51136: PPUSH
51137: LD_VAR 0 4
51141: PPUSH
51142: LD_EXP 133
51146: PUSH
51147: LD_VAR 0 2
51151: ARRAY
51152: PPUSH
51153: CALL 118019 0 3
// exit ;
51157: POP
51158: POP
51159: GO 51165
// end ; end ;
51161: GO 50598
51163: POP
51164: POP
// end ;
51165: LD_VAR 0 1
51169: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
51170: LD_INT 0
51172: PPUSH
51173: PPUSH
51174: PPUSH
51175: PPUSH
51176: PPUSH
51177: PPUSH
51178: PPUSH
51179: PPUSH
51180: PPUSH
51181: PPUSH
51182: PPUSH
// if not mc_bases then
51183: LD_EXP 110
51187: NOT
51188: IFFALSE 51192
// exit ;
51190: GO 52279
// for i = 1 to mc_bases do
51192: LD_ADDR_VAR 0 2
51196: PUSH
51197: DOUBLE
51198: LD_INT 1
51200: DEC
51201: ST_TO_ADDR
51202: LD_EXP 110
51206: PUSH
51207: FOR_TO
51208: IFFALSE 52277
// begin tmp := mc_lab [ i ] ;
51210: LD_ADDR_VAR 0 6
51214: PUSH
51215: LD_EXP 143
51219: PUSH
51220: LD_VAR 0 2
51224: ARRAY
51225: ST_TO_ADDR
// if not tmp then
51226: LD_VAR 0 6
51230: NOT
51231: IFFALSE 51235
// continue ;
51233: GO 51207
// idle_lab := 0 ;
51235: LD_ADDR_VAR 0 11
51239: PUSH
51240: LD_INT 0
51242: ST_TO_ADDR
// for j in tmp do
51243: LD_ADDR_VAR 0 3
51247: PUSH
51248: LD_VAR 0 6
51252: PUSH
51253: FOR_IN
51254: IFFALSE 52273
// begin researching := false ;
51256: LD_ADDR_VAR 0 10
51260: PUSH
51261: LD_INT 0
51263: ST_TO_ADDR
// side := GetSide ( j ) ;
51264: LD_ADDR_VAR 0 4
51268: PUSH
51269: LD_VAR 0 3
51273: PPUSH
51274: CALL_OW 255
51278: ST_TO_ADDR
// if not mc_tech [ side ] then
51279: LD_EXP 137
51283: PUSH
51284: LD_VAR 0 4
51288: ARRAY
51289: NOT
51290: IFFALSE 51294
// continue ;
51292: GO 51253
// if BuildingStatus ( j ) = bs_idle then
51294: LD_VAR 0 3
51298: PPUSH
51299: CALL_OW 461
51303: PUSH
51304: LD_INT 2
51306: EQUAL
51307: IFFALSE 51495
// begin if idle_lab and UnitsInside ( j ) < 6 then
51309: LD_VAR 0 11
51313: PUSH
51314: LD_VAR 0 3
51318: PPUSH
51319: CALL_OW 313
51323: PUSH
51324: LD_INT 6
51326: LESS
51327: AND
51328: IFFALSE 51399
// begin tmp2 := UnitsInside ( idle_lab ) ;
51330: LD_ADDR_VAR 0 9
51334: PUSH
51335: LD_VAR 0 11
51339: PPUSH
51340: CALL_OW 313
51344: ST_TO_ADDR
// if tmp2 then
51345: LD_VAR 0 9
51349: IFFALSE 51391
// for x in tmp2 do
51351: LD_ADDR_VAR 0 7
51355: PUSH
51356: LD_VAR 0 9
51360: PUSH
51361: FOR_IN
51362: IFFALSE 51389
// begin ComExitBuilding ( x ) ;
51364: LD_VAR 0 7
51368: PPUSH
51369: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51373: LD_VAR 0 7
51377: PPUSH
51378: LD_VAR 0 3
51382: PPUSH
51383: CALL_OW 180
// end ;
51387: GO 51361
51389: POP
51390: POP
// idle_lab := 0 ;
51391: LD_ADDR_VAR 0 11
51395: PUSH
51396: LD_INT 0
51398: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
51399: LD_ADDR_VAR 0 5
51403: PUSH
51404: LD_EXP 137
51408: PUSH
51409: LD_VAR 0 4
51413: ARRAY
51414: PUSH
51415: FOR_IN
51416: IFFALSE 51476
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
51418: LD_VAR 0 3
51422: PPUSH
51423: LD_VAR 0 5
51427: PPUSH
51428: CALL_OW 430
51432: PUSH
51433: LD_VAR 0 4
51437: PPUSH
51438: LD_VAR 0 5
51442: PPUSH
51443: CALL 65832 0 2
51447: AND
51448: IFFALSE 51474
// begin researching := true ;
51450: LD_ADDR_VAR 0 10
51454: PUSH
51455: LD_INT 1
51457: ST_TO_ADDR
// ComResearch ( j , t ) ;
51458: LD_VAR 0 3
51462: PPUSH
51463: LD_VAR 0 5
51467: PPUSH
51468: CALL_OW 124
// break ;
51472: GO 51476
// end ;
51474: GO 51415
51476: POP
51477: POP
// if not researching then
51478: LD_VAR 0 10
51482: NOT
51483: IFFALSE 51495
// idle_lab := j ;
51485: LD_ADDR_VAR 0 11
51489: PUSH
51490: LD_VAR 0 3
51494: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
51495: LD_VAR 0 3
51499: PPUSH
51500: CALL_OW 461
51504: PUSH
51505: LD_INT 10
51507: EQUAL
51508: IFFALSE 52096
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
51510: LD_EXP 139
51514: PUSH
51515: LD_VAR 0 2
51519: ARRAY
51520: NOT
51521: PUSH
51522: LD_EXP 140
51526: PUSH
51527: LD_VAR 0 2
51531: ARRAY
51532: NOT
51533: AND
51534: PUSH
51535: LD_EXP 137
51539: PUSH
51540: LD_VAR 0 4
51544: ARRAY
51545: PUSH
51546: LD_INT 1
51548: GREATER
51549: AND
51550: IFFALSE 51681
// begin ComCancel ( j ) ;
51552: LD_VAR 0 3
51556: PPUSH
51557: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
51561: LD_ADDR_EXP 137
51565: PUSH
51566: LD_EXP 137
51570: PPUSH
51571: LD_VAR 0 4
51575: PPUSH
51576: LD_EXP 137
51580: PUSH
51581: LD_VAR 0 4
51585: ARRAY
51586: PPUSH
51587: LD_EXP 137
51591: PUSH
51592: LD_VAR 0 4
51596: ARRAY
51597: PUSH
51598: LD_INT 1
51600: MINUS
51601: PPUSH
51602: LD_EXP 137
51606: PUSH
51607: LD_VAR 0 4
51611: ARRAY
51612: PPUSH
51613: LD_INT 0
51615: PPUSH
51616: CALL 69344 0 4
51620: PPUSH
51621: CALL_OW 1
51625: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
51626: LD_ADDR_EXP 137
51630: PUSH
51631: LD_EXP 137
51635: PPUSH
51636: LD_VAR 0 4
51640: PPUSH
51641: LD_EXP 137
51645: PUSH
51646: LD_VAR 0 4
51650: ARRAY
51651: PPUSH
51652: LD_EXP 137
51656: PUSH
51657: LD_VAR 0 4
51661: ARRAY
51662: PPUSH
51663: LD_INT 1
51665: PPUSH
51666: LD_INT 0
51668: PPUSH
51669: CALL 69344 0 4
51673: PPUSH
51674: CALL_OW 1
51678: ST_TO_ADDR
// continue ;
51679: GO 51253
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
51681: LD_EXP 139
51685: PUSH
51686: LD_VAR 0 2
51690: ARRAY
51691: PUSH
51692: LD_EXP 140
51696: PUSH
51697: LD_VAR 0 2
51701: ARRAY
51702: NOT
51703: AND
51704: IFFALSE 51831
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
51706: LD_ADDR_EXP 140
51710: PUSH
51711: LD_EXP 140
51715: PPUSH
51716: LD_VAR 0 2
51720: PUSH
51721: LD_EXP 140
51725: PUSH
51726: LD_VAR 0 2
51730: ARRAY
51731: PUSH
51732: LD_INT 1
51734: PLUS
51735: PUSH
51736: EMPTY
51737: LIST
51738: LIST
51739: PPUSH
51740: LD_EXP 139
51744: PUSH
51745: LD_VAR 0 2
51749: ARRAY
51750: PUSH
51751: LD_INT 1
51753: ARRAY
51754: PPUSH
51755: CALL 69926 0 3
51759: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
51760: LD_EXP 139
51764: PUSH
51765: LD_VAR 0 2
51769: ARRAY
51770: PUSH
51771: LD_INT 1
51773: ARRAY
51774: PPUSH
51775: LD_INT 112
51777: PPUSH
51778: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
51782: LD_ADDR_VAR 0 9
51786: PUSH
51787: LD_EXP 139
51791: PUSH
51792: LD_VAR 0 2
51796: ARRAY
51797: PPUSH
51798: LD_INT 1
51800: PPUSH
51801: CALL_OW 3
51805: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
51806: LD_ADDR_EXP 139
51810: PUSH
51811: LD_EXP 139
51815: PPUSH
51816: LD_VAR 0 2
51820: PPUSH
51821: LD_VAR 0 9
51825: PPUSH
51826: CALL_OW 1
51830: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
51831: LD_EXP 139
51835: PUSH
51836: LD_VAR 0 2
51840: ARRAY
51841: PUSH
51842: LD_EXP 140
51846: PUSH
51847: LD_VAR 0 2
51851: ARRAY
51852: AND
51853: PUSH
51854: LD_EXP 140
51858: PUSH
51859: LD_VAR 0 2
51863: ARRAY
51864: PUSH
51865: LD_INT 1
51867: ARRAY
51868: PPUSH
51869: CALL_OW 310
51873: NOT
51874: AND
51875: PUSH
51876: LD_VAR 0 3
51880: PPUSH
51881: CALL_OW 313
51885: PUSH
51886: LD_INT 6
51888: EQUAL
51889: AND
51890: IFFALSE 51946
// begin tmp2 := UnitsInside ( j ) ;
51892: LD_ADDR_VAR 0 9
51896: PUSH
51897: LD_VAR 0 3
51901: PPUSH
51902: CALL_OW 313
51906: ST_TO_ADDR
// if tmp2 = 6 then
51907: LD_VAR 0 9
51911: PUSH
51912: LD_INT 6
51914: EQUAL
51915: IFFALSE 51946
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
51917: LD_VAR 0 9
51921: PUSH
51922: LD_INT 1
51924: ARRAY
51925: PPUSH
51926: LD_INT 112
51928: PPUSH
51929: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
51933: LD_VAR 0 9
51937: PUSH
51938: LD_INT 1
51940: ARRAY
51941: PPUSH
51942: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
51946: LD_EXP 140
51950: PUSH
51951: LD_VAR 0 2
51955: ARRAY
51956: PUSH
51957: LD_EXP 140
51961: PUSH
51962: LD_VAR 0 2
51966: ARRAY
51967: PUSH
51968: LD_INT 1
51970: ARRAY
51971: PPUSH
51972: CALL_OW 314
51976: NOT
51977: AND
51978: PUSH
51979: LD_EXP 140
51983: PUSH
51984: LD_VAR 0 2
51988: ARRAY
51989: PUSH
51990: LD_INT 1
51992: ARRAY
51993: PPUSH
51994: CALL_OW 310
51998: NOT
51999: AND
52000: IFFALSE 52026
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
52002: LD_EXP 140
52006: PUSH
52007: LD_VAR 0 2
52011: ARRAY
52012: PUSH
52013: LD_INT 1
52015: ARRAY
52016: PPUSH
52017: LD_VAR 0 3
52021: PPUSH
52022: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
52026: LD_EXP 140
52030: PUSH
52031: LD_VAR 0 2
52035: ARRAY
52036: PUSH
52037: LD_INT 1
52039: ARRAY
52040: PPUSH
52041: CALL_OW 310
52045: PUSH
52046: LD_EXP 140
52050: PUSH
52051: LD_VAR 0 2
52055: ARRAY
52056: PUSH
52057: LD_INT 1
52059: ARRAY
52060: PPUSH
52061: CALL_OW 310
52065: PPUSH
52066: CALL_OW 461
52070: PUSH
52071: LD_INT 3
52073: NONEQUAL
52074: AND
52075: IFFALSE 52096
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
52077: LD_EXP 140
52081: PUSH
52082: LD_VAR 0 2
52086: ARRAY
52087: PUSH
52088: LD_INT 1
52090: ARRAY
52091: PPUSH
52092: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52096: LD_VAR 0 3
52100: PPUSH
52101: CALL_OW 461
52105: PUSH
52106: LD_INT 6
52108: EQUAL
52109: PUSH
52110: LD_VAR 0 6
52114: PUSH
52115: LD_INT 1
52117: GREATER
52118: AND
52119: IFFALSE 52271
// begin sci := [ ] ;
52121: LD_ADDR_VAR 0 8
52125: PUSH
52126: EMPTY
52127: ST_TO_ADDR
// for x in ( tmp diff j ) do
52128: LD_ADDR_VAR 0 7
52132: PUSH
52133: LD_VAR 0 6
52137: PUSH
52138: LD_VAR 0 3
52142: DIFF
52143: PUSH
52144: FOR_IN
52145: IFFALSE 52197
// begin if sci = 6 then
52147: LD_VAR 0 8
52151: PUSH
52152: LD_INT 6
52154: EQUAL
52155: IFFALSE 52159
// break ;
52157: GO 52197
// if BuildingStatus ( x ) = bs_idle then
52159: LD_VAR 0 7
52163: PPUSH
52164: CALL_OW 461
52168: PUSH
52169: LD_INT 2
52171: EQUAL
52172: IFFALSE 52195
// sci := sci ^ UnitsInside ( x ) ;
52174: LD_ADDR_VAR 0 8
52178: PUSH
52179: LD_VAR 0 8
52183: PUSH
52184: LD_VAR 0 7
52188: PPUSH
52189: CALL_OW 313
52193: ADD
52194: ST_TO_ADDR
// end ;
52195: GO 52144
52197: POP
52198: POP
// if not sci then
52199: LD_VAR 0 8
52203: NOT
52204: IFFALSE 52208
// continue ;
52206: GO 51253
// for x in sci do
52208: LD_ADDR_VAR 0 7
52212: PUSH
52213: LD_VAR 0 8
52217: PUSH
52218: FOR_IN
52219: IFFALSE 52269
// if IsInUnit ( x ) and not HasTask ( x ) then
52221: LD_VAR 0 7
52225: PPUSH
52226: CALL_OW 310
52230: PUSH
52231: LD_VAR 0 7
52235: PPUSH
52236: CALL_OW 314
52240: NOT
52241: AND
52242: IFFALSE 52267
// begin ComExitBuilding ( x ) ;
52244: LD_VAR 0 7
52248: PPUSH
52249: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52253: LD_VAR 0 7
52257: PPUSH
52258: LD_VAR 0 3
52262: PPUSH
52263: CALL_OW 180
// end ;
52267: GO 52218
52269: POP
52270: POP
// end ; end ;
52271: GO 51253
52273: POP
52274: POP
// end ;
52275: GO 51207
52277: POP
52278: POP
// end ;
52279: LD_VAR 0 1
52283: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
52284: LD_INT 0
52286: PPUSH
52287: PPUSH
// if not mc_bases then
52288: LD_EXP 110
52292: NOT
52293: IFFALSE 52297
// exit ;
52295: GO 52378
// for i = 1 to mc_bases do
52297: LD_ADDR_VAR 0 2
52301: PUSH
52302: DOUBLE
52303: LD_INT 1
52305: DEC
52306: ST_TO_ADDR
52307: LD_EXP 110
52311: PUSH
52312: FOR_TO
52313: IFFALSE 52376
// if mc_mines [ i ] and mc_miners [ i ] then
52315: LD_EXP 123
52319: PUSH
52320: LD_VAR 0 2
52324: ARRAY
52325: PUSH
52326: LD_EXP 124
52330: PUSH
52331: LD_VAR 0 2
52335: ARRAY
52336: AND
52337: IFFALSE 52374
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
52339: LD_EXP 124
52343: PUSH
52344: LD_VAR 0 2
52348: ARRAY
52349: PUSH
52350: LD_INT 1
52352: ARRAY
52353: PPUSH
52354: CALL_OW 255
52358: PPUSH
52359: LD_EXP 123
52363: PUSH
52364: LD_VAR 0 2
52368: ARRAY
52369: PPUSH
52370: CALL 66915 0 2
52374: GO 52312
52376: POP
52377: POP
// end ;
52378: LD_VAR 0 1
52382: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
52383: LD_INT 0
52385: PPUSH
52386: PPUSH
52387: PPUSH
52388: PPUSH
52389: PPUSH
52390: PPUSH
52391: PPUSH
52392: PPUSH
// if not mc_bases or not mc_parking then
52393: LD_EXP 110
52397: NOT
52398: PUSH
52399: LD_EXP 134
52403: NOT
52404: OR
52405: IFFALSE 52409
// exit ;
52407: GO 53108
// for i = 1 to mc_bases do
52409: LD_ADDR_VAR 0 2
52413: PUSH
52414: DOUBLE
52415: LD_INT 1
52417: DEC
52418: ST_TO_ADDR
52419: LD_EXP 110
52423: PUSH
52424: FOR_TO
52425: IFFALSE 53106
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
52427: LD_EXP 110
52431: PUSH
52432: LD_VAR 0 2
52436: ARRAY
52437: NOT
52438: PUSH
52439: LD_EXP 134
52443: PUSH
52444: LD_VAR 0 2
52448: ARRAY
52449: NOT
52450: OR
52451: IFFALSE 52455
// continue ;
52453: GO 52424
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52455: LD_ADDR_VAR 0 5
52459: PUSH
52460: LD_EXP 110
52464: PUSH
52465: LD_VAR 0 2
52469: ARRAY
52470: PUSH
52471: LD_INT 1
52473: ARRAY
52474: PPUSH
52475: CALL_OW 255
52479: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52480: LD_ADDR_VAR 0 6
52484: PUSH
52485: LD_EXP 110
52489: PUSH
52490: LD_VAR 0 2
52494: ARRAY
52495: PPUSH
52496: LD_INT 30
52498: PUSH
52499: LD_INT 3
52501: PUSH
52502: EMPTY
52503: LIST
52504: LIST
52505: PPUSH
52506: CALL_OW 72
52510: ST_TO_ADDR
// if not fac then
52511: LD_VAR 0 6
52515: NOT
52516: IFFALSE 52567
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52518: LD_ADDR_VAR 0 6
52522: PUSH
52523: LD_EXP 110
52527: PUSH
52528: LD_VAR 0 2
52532: ARRAY
52533: PPUSH
52534: LD_INT 2
52536: PUSH
52537: LD_INT 30
52539: PUSH
52540: LD_INT 0
52542: PUSH
52543: EMPTY
52544: LIST
52545: LIST
52546: PUSH
52547: LD_INT 30
52549: PUSH
52550: LD_INT 1
52552: PUSH
52553: EMPTY
52554: LIST
52555: LIST
52556: PUSH
52557: EMPTY
52558: LIST
52559: LIST
52560: LIST
52561: PPUSH
52562: CALL_OW 72
52566: ST_TO_ADDR
// if not fac then
52567: LD_VAR 0 6
52571: NOT
52572: IFFALSE 52576
// continue ;
52574: GO 52424
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52576: LD_ADDR_VAR 0 7
52580: PUSH
52581: LD_EXP 134
52585: PUSH
52586: LD_VAR 0 2
52590: ARRAY
52591: PPUSH
52592: LD_INT 22
52594: PUSH
52595: LD_VAR 0 5
52599: PUSH
52600: EMPTY
52601: LIST
52602: LIST
52603: PUSH
52604: LD_INT 21
52606: PUSH
52607: LD_INT 2
52609: PUSH
52610: EMPTY
52611: LIST
52612: LIST
52613: PUSH
52614: LD_INT 3
52616: PUSH
52617: LD_INT 24
52619: PUSH
52620: LD_INT 1000
52622: PUSH
52623: EMPTY
52624: LIST
52625: LIST
52626: PUSH
52627: EMPTY
52628: LIST
52629: LIST
52630: PUSH
52631: EMPTY
52632: LIST
52633: LIST
52634: LIST
52635: PPUSH
52636: CALL_OW 70
52640: ST_TO_ADDR
// for j in fac do
52641: LD_ADDR_VAR 0 3
52645: PUSH
52646: LD_VAR 0 6
52650: PUSH
52651: FOR_IN
52652: IFFALSE 52733
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52654: LD_ADDR_VAR 0 7
52658: PUSH
52659: LD_VAR 0 7
52663: PUSH
52664: LD_INT 22
52666: PUSH
52667: LD_VAR 0 5
52671: PUSH
52672: EMPTY
52673: LIST
52674: LIST
52675: PUSH
52676: LD_INT 91
52678: PUSH
52679: LD_VAR 0 3
52683: PUSH
52684: LD_INT 15
52686: PUSH
52687: EMPTY
52688: LIST
52689: LIST
52690: LIST
52691: PUSH
52692: LD_INT 21
52694: PUSH
52695: LD_INT 2
52697: PUSH
52698: EMPTY
52699: LIST
52700: LIST
52701: PUSH
52702: LD_INT 3
52704: PUSH
52705: LD_INT 24
52707: PUSH
52708: LD_INT 1000
52710: PUSH
52711: EMPTY
52712: LIST
52713: LIST
52714: PUSH
52715: EMPTY
52716: LIST
52717: LIST
52718: PUSH
52719: EMPTY
52720: LIST
52721: LIST
52722: LIST
52723: LIST
52724: PPUSH
52725: CALL_OW 69
52729: UNION
52730: ST_TO_ADDR
52731: GO 52651
52733: POP
52734: POP
// if not vehs then
52735: LD_VAR 0 7
52739: NOT
52740: IFFALSE 52766
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52742: LD_ADDR_EXP 122
52746: PUSH
52747: LD_EXP 122
52751: PPUSH
52752: LD_VAR 0 2
52756: PPUSH
52757: EMPTY
52758: PPUSH
52759: CALL_OW 1
52763: ST_TO_ADDR
// continue ;
52764: GO 52424
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52766: LD_ADDR_VAR 0 8
52770: PUSH
52771: LD_EXP 110
52775: PUSH
52776: LD_VAR 0 2
52780: ARRAY
52781: PPUSH
52782: LD_INT 30
52784: PUSH
52785: LD_INT 3
52787: PUSH
52788: EMPTY
52789: LIST
52790: LIST
52791: PPUSH
52792: CALL_OW 72
52796: ST_TO_ADDR
// if tmp then
52797: LD_VAR 0 8
52801: IFFALSE 52904
// begin for j in tmp do
52803: LD_ADDR_VAR 0 3
52807: PUSH
52808: LD_VAR 0 8
52812: PUSH
52813: FOR_IN
52814: IFFALSE 52902
// for k in UnitsInside ( j ) do
52816: LD_ADDR_VAR 0 4
52820: PUSH
52821: LD_VAR 0 3
52825: PPUSH
52826: CALL_OW 313
52830: PUSH
52831: FOR_IN
52832: IFFALSE 52898
// if k then
52834: LD_VAR 0 4
52838: IFFALSE 52896
// if not k in mc_repair_vehicle [ i ] then
52840: LD_VAR 0 4
52844: PUSH
52845: LD_EXP 122
52849: PUSH
52850: LD_VAR 0 2
52854: ARRAY
52855: IN
52856: NOT
52857: IFFALSE 52896
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
52859: LD_ADDR_EXP 122
52863: PUSH
52864: LD_EXP 122
52868: PPUSH
52869: LD_VAR 0 2
52873: PPUSH
52874: LD_EXP 122
52878: PUSH
52879: LD_VAR 0 2
52883: ARRAY
52884: PUSH
52885: LD_VAR 0 4
52889: UNION
52890: PPUSH
52891: CALL_OW 1
52895: ST_TO_ADDR
52896: GO 52831
52898: POP
52899: POP
52900: GO 52813
52902: POP
52903: POP
// end ; if not mc_repair_vehicle [ i ] then
52904: LD_EXP 122
52908: PUSH
52909: LD_VAR 0 2
52913: ARRAY
52914: NOT
52915: IFFALSE 52919
// continue ;
52917: GO 52424
// for j in mc_repair_vehicle [ i ] do
52919: LD_ADDR_VAR 0 3
52923: PUSH
52924: LD_EXP 122
52928: PUSH
52929: LD_VAR 0 2
52933: ARRAY
52934: PUSH
52935: FOR_IN
52936: IFFALSE 53102
// begin if GetClass ( j ) <> 3 then
52938: LD_VAR 0 3
52942: PPUSH
52943: CALL_OW 257
52947: PUSH
52948: LD_INT 3
52950: NONEQUAL
52951: IFFALSE 52992
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
52953: LD_ADDR_EXP 122
52957: PUSH
52958: LD_EXP 122
52962: PPUSH
52963: LD_VAR 0 2
52967: PPUSH
52968: LD_EXP 122
52972: PUSH
52973: LD_VAR 0 2
52977: ARRAY
52978: PUSH
52979: LD_VAR 0 3
52983: DIFF
52984: PPUSH
52985: CALL_OW 1
52989: ST_TO_ADDR
// continue ;
52990: GO 52935
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
52992: LD_VAR 0 3
52996: PPUSH
52997: CALL_OW 311
53001: NOT
53002: PUSH
53003: LD_VAR 0 3
53007: PUSH
53008: LD_EXP 113
53012: PUSH
53013: LD_VAR 0 2
53017: ARRAY
53018: PUSH
53019: LD_INT 1
53021: ARRAY
53022: IN
53023: NOT
53024: AND
53025: PUSH
53026: LD_VAR 0 3
53030: PUSH
53031: LD_EXP 113
53035: PUSH
53036: LD_VAR 0 2
53040: ARRAY
53041: PUSH
53042: LD_INT 2
53044: ARRAY
53045: IN
53046: NOT
53047: AND
53048: IFFALSE 53100
// begin if IsInUnit ( j ) then
53050: LD_VAR 0 3
53054: PPUSH
53055: CALL_OW 310
53059: IFFALSE 53070
// ComExitBuilding ( j ) ;
53061: LD_VAR 0 3
53065: PPUSH
53066: CALL_OW 122
// if not HasTask ( j ) then
53070: LD_VAR 0 3
53074: PPUSH
53075: CALL_OW 314
53079: NOT
53080: IFFALSE 53100
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
53082: LD_VAR 0 3
53086: PPUSH
53087: LD_VAR 0 7
53091: PUSH
53092: LD_INT 1
53094: ARRAY
53095: PPUSH
53096: CALL_OW 189
// end ; end ;
53100: GO 52935
53102: POP
53103: POP
// end ;
53104: GO 52424
53106: POP
53107: POP
// end ;
53108: LD_VAR 0 1
53112: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53113: LD_INT 0
53115: PPUSH
53116: PPUSH
53117: PPUSH
53118: PPUSH
53119: PPUSH
53120: PPUSH
53121: PPUSH
53122: PPUSH
53123: PPUSH
53124: PPUSH
53125: PPUSH
// if not mc_bases then
53126: LD_EXP 110
53130: NOT
53131: IFFALSE 53135
// exit ;
53133: GO 53937
// for i = 1 to mc_bases do
53135: LD_ADDR_VAR 0 2
53139: PUSH
53140: DOUBLE
53141: LD_INT 1
53143: DEC
53144: ST_TO_ADDR
53145: LD_EXP 110
53149: PUSH
53150: FOR_TO
53151: IFFALSE 53935
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
53153: LD_EXP 138
53157: PUSH
53158: LD_VAR 0 2
53162: ARRAY
53163: NOT
53164: PUSH
53165: LD_EXP 113
53169: PUSH
53170: LD_VAR 0 2
53174: ARRAY
53175: PUSH
53176: LD_INT 1
53178: ARRAY
53179: OR
53180: PUSH
53181: LD_EXP 113
53185: PUSH
53186: LD_VAR 0 2
53190: ARRAY
53191: PUSH
53192: LD_INT 2
53194: ARRAY
53195: OR
53196: PUSH
53197: LD_EXP 136
53201: PUSH
53202: LD_VAR 0 2
53206: ARRAY
53207: PPUSH
53208: LD_INT 1
53210: PPUSH
53211: CALL_OW 325
53215: NOT
53216: OR
53217: PUSH
53218: LD_EXP 133
53222: PUSH
53223: LD_VAR 0 2
53227: ARRAY
53228: OR
53229: IFFALSE 53233
// continue ;
53231: GO 53150
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
53233: LD_ADDR_VAR 0 8
53237: PUSH
53238: LD_EXP 110
53242: PUSH
53243: LD_VAR 0 2
53247: ARRAY
53248: PPUSH
53249: LD_INT 25
53251: PUSH
53252: LD_INT 4
53254: PUSH
53255: EMPTY
53256: LIST
53257: LIST
53258: PUSH
53259: LD_INT 50
53261: PUSH
53262: EMPTY
53263: LIST
53264: PUSH
53265: LD_INT 3
53267: PUSH
53268: LD_INT 60
53270: PUSH
53271: EMPTY
53272: LIST
53273: PUSH
53274: EMPTY
53275: LIST
53276: LIST
53277: PUSH
53278: EMPTY
53279: LIST
53280: LIST
53281: LIST
53282: PPUSH
53283: CALL_OW 72
53287: PUSH
53288: LD_EXP 114
53292: PUSH
53293: LD_VAR 0 2
53297: ARRAY
53298: DIFF
53299: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53300: LD_ADDR_VAR 0 9
53304: PUSH
53305: LD_EXP 110
53309: PUSH
53310: LD_VAR 0 2
53314: ARRAY
53315: PPUSH
53316: LD_INT 2
53318: PUSH
53319: LD_INT 30
53321: PUSH
53322: LD_INT 0
53324: PUSH
53325: EMPTY
53326: LIST
53327: LIST
53328: PUSH
53329: LD_INT 30
53331: PUSH
53332: LD_INT 1
53334: PUSH
53335: EMPTY
53336: LIST
53337: LIST
53338: PUSH
53339: EMPTY
53340: LIST
53341: LIST
53342: LIST
53343: PPUSH
53344: CALL_OW 72
53348: ST_TO_ADDR
// if not tmp or not dep then
53349: LD_VAR 0 8
53353: NOT
53354: PUSH
53355: LD_VAR 0 9
53359: NOT
53360: OR
53361: IFFALSE 53365
// continue ;
53363: GO 53150
// side := GetSide ( tmp [ 1 ] ) ;
53365: LD_ADDR_VAR 0 11
53369: PUSH
53370: LD_VAR 0 8
53374: PUSH
53375: LD_INT 1
53377: ARRAY
53378: PPUSH
53379: CALL_OW 255
53383: ST_TO_ADDR
// dep := dep [ 1 ] ;
53384: LD_ADDR_VAR 0 9
53388: PUSH
53389: LD_VAR 0 9
53393: PUSH
53394: LD_INT 1
53396: ARRAY
53397: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
53398: LD_ADDR_VAR 0 7
53402: PUSH
53403: LD_EXP 138
53407: PUSH
53408: LD_VAR 0 2
53412: ARRAY
53413: PPUSH
53414: LD_INT 22
53416: PUSH
53417: LD_INT 0
53419: PUSH
53420: EMPTY
53421: LIST
53422: LIST
53423: PUSH
53424: LD_INT 25
53426: PUSH
53427: LD_INT 12
53429: PUSH
53430: EMPTY
53431: LIST
53432: LIST
53433: PUSH
53434: EMPTY
53435: LIST
53436: LIST
53437: PPUSH
53438: CALL_OW 70
53442: PUSH
53443: LD_INT 22
53445: PUSH
53446: LD_INT 0
53448: PUSH
53449: EMPTY
53450: LIST
53451: LIST
53452: PUSH
53453: LD_INT 25
53455: PUSH
53456: LD_INT 12
53458: PUSH
53459: EMPTY
53460: LIST
53461: LIST
53462: PUSH
53463: LD_INT 91
53465: PUSH
53466: LD_VAR 0 9
53470: PUSH
53471: LD_INT 20
53473: PUSH
53474: EMPTY
53475: LIST
53476: LIST
53477: LIST
53478: PUSH
53479: EMPTY
53480: LIST
53481: LIST
53482: LIST
53483: PPUSH
53484: CALL_OW 69
53488: UNION
53489: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
53490: LD_ADDR_VAR 0 10
53494: PUSH
53495: LD_EXP 138
53499: PUSH
53500: LD_VAR 0 2
53504: ARRAY
53505: PPUSH
53506: LD_INT 81
53508: PUSH
53509: LD_VAR 0 11
53513: PUSH
53514: EMPTY
53515: LIST
53516: LIST
53517: PPUSH
53518: CALL_OW 70
53522: ST_TO_ADDR
// if not apes or danger_at_area then
53523: LD_VAR 0 7
53527: NOT
53528: PUSH
53529: LD_VAR 0 10
53533: OR
53534: IFFALSE 53584
// begin if mc_taming [ i ] then
53536: LD_EXP 141
53540: PUSH
53541: LD_VAR 0 2
53545: ARRAY
53546: IFFALSE 53582
// begin MC_Reset ( i , 121 ) ;
53548: LD_VAR 0 2
53552: PPUSH
53553: LD_INT 121
53555: PPUSH
53556: CALL 39019 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53560: LD_ADDR_EXP 141
53564: PUSH
53565: LD_EXP 141
53569: PPUSH
53570: LD_VAR 0 2
53574: PPUSH
53575: EMPTY
53576: PPUSH
53577: CALL_OW 1
53581: ST_TO_ADDR
// end ; continue ;
53582: GO 53150
// end ; for j in tmp do
53584: LD_ADDR_VAR 0 3
53588: PUSH
53589: LD_VAR 0 8
53593: PUSH
53594: FOR_IN
53595: IFFALSE 53931
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
53597: LD_VAR 0 3
53601: PUSH
53602: LD_EXP 141
53606: PUSH
53607: LD_VAR 0 2
53611: ARRAY
53612: IN
53613: NOT
53614: PUSH
53615: LD_EXP 141
53619: PUSH
53620: LD_VAR 0 2
53624: ARRAY
53625: PUSH
53626: LD_INT 3
53628: LESS
53629: AND
53630: IFFALSE 53688
// begin SetTag ( j , 121 ) ;
53632: LD_VAR 0 3
53636: PPUSH
53637: LD_INT 121
53639: PPUSH
53640: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
53644: LD_ADDR_EXP 141
53648: PUSH
53649: LD_EXP 141
53653: PPUSH
53654: LD_VAR 0 2
53658: PUSH
53659: LD_EXP 141
53663: PUSH
53664: LD_VAR 0 2
53668: ARRAY
53669: PUSH
53670: LD_INT 1
53672: PLUS
53673: PUSH
53674: EMPTY
53675: LIST
53676: LIST
53677: PPUSH
53678: LD_VAR 0 3
53682: PPUSH
53683: CALL 69926 0 3
53687: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
53688: LD_VAR 0 3
53692: PUSH
53693: LD_EXP 141
53697: PUSH
53698: LD_VAR 0 2
53702: ARRAY
53703: IN
53704: IFFALSE 53929
// begin if GetClass ( j ) <> 4 then
53706: LD_VAR 0 3
53710: PPUSH
53711: CALL_OW 257
53715: PUSH
53716: LD_INT 4
53718: NONEQUAL
53719: IFFALSE 53772
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
53721: LD_ADDR_EXP 141
53725: PUSH
53726: LD_EXP 141
53730: PPUSH
53731: LD_VAR 0 2
53735: PPUSH
53736: LD_EXP 141
53740: PUSH
53741: LD_VAR 0 2
53745: ARRAY
53746: PUSH
53747: LD_VAR 0 3
53751: DIFF
53752: PPUSH
53753: CALL_OW 1
53757: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53758: LD_VAR 0 3
53762: PPUSH
53763: LD_INT 0
53765: PPUSH
53766: CALL_OW 109
// continue ;
53770: GO 53594
// end ; if IsInUnit ( j ) then
53772: LD_VAR 0 3
53776: PPUSH
53777: CALL_OW 310
53781: IFFALSE 53792
// ComExitBuilding ( j ) ;
53783: LD_VAR 0 3
53787: PPUSH
53788: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
53792: LD_ADDR_VAR 0 6
53796: PUSH
53797: LD_VAR 0 7
53801: PPUSH
53802: LD_VAR 0 3
53806: PPUSH
53807: CALL_OW 74
53811: ST_TO_ADDR
// if not ape then
53812: LD_VAR 0 6
53816: NOT
53817: IFFALSE 53821
// break ;
53819: GO 53931
// x := GetX ( ape ) ;
53821: LD_ADDR_VAR 0 4
53825: PUSH
53826: LD_VAR 0 6
53830: PPUSH
53831: CALL_OW 250
53835: ST_TO_ADDR
// y := GetY ( ape ) ;
53836: LD_ADDR_VAR 0 5
53840: PUSH
53841: LD_VAR 0 6
53845: PPUSH
53846: CALL_OW 251
53850: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
53851: LD_VAR 0 4
53855: PPUSH
53856: LD_VAR 0 5
53860: PPUSH
53861: CALL_OW 488
53865: NOT
53866: PUSH
53867: LD_VAR 0 11
53871: PPUSH
53872: LD_VAR 0 4
53876: PPUSH
53877: LD_VAR 0 5
53881: PPUSH
53882: LD_INT 20
53884: PPUSH
53885: CALL 70822 0 4
53889: PUSH
53890: LD_INT 4
53892: ARRAY
53893: OR
53894: IFFALSE 53898
// break ;
53896: GO 53931
// if not HasTask ( j ) then
53898: LD_VAR 0 3
53902: PPUSH
53903: CALL_OW 314
53907: NOT
53908: IFFALSE 53929
// ComTameXY ( j , x , y ) ;
53910: LD_VAR 0 3
53914: PPUSH
53915: LD_VAR 0 4
53919: PPUSH
53920: LD_VAR 0 5
53924: PPUSH
53925: CALL_OW 131
// end ; end ;
53929: GO 53594
53931: POP
53932: POP
// end ;
53933: GO 53150
53935: POP
53936: POP
// end ;
53937: LD_VAR 0 1
53941: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
53942: LD_INT 0
53944: PPUSH
53945: PPUSH
53946: PPUSH
53947: PPUSH
53948: PPUSH
53949: PPUSH
53950: PPUSH
53951: PPUSH
// if not mc_bases then
53952: LD_EXP 110
53956: NOT
53957: IFFALSE 53961
// exit ;
53959: GO 54587
// for i = 1 to mc_bases do
53961: LD_ADDR_VAR 0 2
53965: PUSH
53966: DOUBLE
53967: LD_INT 1
53969: DEC
53970: ST_TO_ADDR
53971: LD_EXP 110
53975: PUSH
53976: FOR_TO
53977: IFFALSE 54585
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
53979: LD_EXP 139
53983: PUSH
53984: LD_VAR 0 2
53988: ARRAY
53989: NOT
53990: PUSH
53991: LD_EXP 139
53995: PUSH
53996: LD_VAR 0 2
54000: ARRAY
54001: PPUSH
54002: LD_INT 25
54004: PUSH
54005: LD_INT 12
54007: PUSH
54008: EMPTY
54009: LIST
54010: LIST
54011: PPUSH
54012: CALL_OW 72
54016: NOT
54017: OR
54018: IFFALSE 54022
// continue ;
54020: GO 53976
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
54022: LD_ADDR_VAR 0 5
54026: PUSH
54027: LD_EXP 139
54031: PUSH
54032: LD_VAR 0 2
54036: ARRAY
54037: PUSH
54038: LD_INT 1
54040: ARRAY
54041: PPUSH
54042: CALL_OW 255
54046: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
54047: LD_VAR 0 5
54051: PPUSH
54052: LD_INT 2
54054: PPUSH
54055: CALL_OW 325
54059: IFFALSE 54312
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54061: LD_ADDR_VAR 0 4
54065: PUSH
54066: LD_EXP 139
54070: PUSH
54071: LD_VAR 0 2
54075: ARRAY
54076: PPUSH
54077: LD_INT 25
54079: PUSH
54080: LD_INT 16
54082: PUSH
54083: EMPTY
54084: LIST
54085: LIST
54086: PPUSH
54087: CALL_OW 72
54091: ST_TO_ADDR
// if tmp < 6 then
54092: LD_VAR 0 4
54096: PUSH
54097: LD_INT 6
54099: LESS
54100: IFFALSE 54312
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54102: LD_ADDR_VAR 0 6
54106: PUSH
54107: LD_EXP 110
54111: PUSH
54112: LD_VAR 0 2
54116: ARRAY
54117: PPUSH
54118: LD_INT 2
54120: PUSH
54121: LD_INT 30
54123: PUSH
54124: LD_INT 0
54126: PUSH
54127: EMPTY
54128: LIST
54129: LIST
54130: PUSH
54131: LD_INT 30
54133: PUSH
54134: LD_INT 1
54136: PUSH
54137: EMPTY
54138: LIST
54139: LIST
54140: PUSH
54141: EMPTY
54142: LIST
54143: LIST
54144: LIST
54145: PPUSH
54146: CALL_OW 72
54150: ST_TO_ADDR
// if depot then
54151: LD_VAR 0 6
54155: IFFALSE 54312
// begin selected := 0 ;
54157: LD_ADDR_VAR 0 7
54161: PUSH
54162: LD_INT 0
54164: ST_TO_ADDR
// for j in depot do
54165: LD_ADDR_VAR 0 3
54169: PUSH
54170: LD_VAR 0 6
54174: PUSH
54175: FOR_IN
54176: IFFALSE 54207
// begin if UnitsInside ( j ) < 6 then
54178: LD_VAR 0 3
54182: PPUSH
54183: CALL_OW 313
54187: PUSH
54188: LD_INT 6
54190: LESS
54191: IFFALSE 54205
// begin selected := j ;
54193: LD_ADDR_VAR 0 7
54197: PUSH
54198: LD_VAR 0 3
54202: ST_TO_ADDR
// break ;
54203: GO 54207
// end ; end ;
54205: GO 54175
54207: POP
54208: POP
// if selected then
54209: LD_VAR 0 7
54213: IFFALSE 54312
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54215: LD_ADDR_VAR 0 3
54219: PUSH
54220: LD_EXP 139
54224: PUSH
54225: LD_VAR 0 2
54229: ARRAY
54230: PPUSH
54231: LD_INT 25
54233: PUSH
54234: LD_INT 12
54236: PUSH
54237: EMPTY
54238: LIST
54239: LIST
54240: PPUSH
54241: CALL_OW 72
54245: PUSH
54246: FOR_IN
54247: IFFALSE 54310
// if not HasTask ( j ) then
54249: LD_VAR 0 3
54253: PPUSH
54254: CALL_OW 314
54258: NOT
54259: IFFALSE 54308
// begin if not IsInUnit ( j ) then
54261: LD_VAR 0 3
54265: PPUSH
54266: CALL_OW 310
54270: NOT
54271: IFFALSE 54287
// ComEnterUnit ( j , selected ) ;
54273: LD_VAR 0 3
54277: PPUSH
54278: LD_VAR 0 7
54282: PPUSH
54283: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
54287: LD_VAR 0 3
54291: PPUSH
54292: LD_INT 16
54294: PPUSH
54295: CALL_OW 183
// AddComExitBuilding ( j ) ;
54299: LD_VAR 0 3
54303: PPUSH
54304: CALL_OW 182
// end ;
54308: GO 54246
54310: POP
54311: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
54312: LD_VAR 0 5
54316: PPUSH
54317: LD_INT 11
54319: PPUSH
54320: CALL_OW 325
54324: IFFALSE 54583
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54326: LD_ADDR_VAR 0 4
54330: PUSH
54331: LD_EXP 139
54335: PUSH
54336: LD_VAR 0 2
54340: ARRAY
54341: PPUSH
54342: LD_INT 25
54344: PUSH
54345: LD_INT 16
54347: PUSH
54348: EMPTY
54349: LIST
54350: LIST
54351: PPUSH
54352: CALL_OW 72
54356: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
54357: LD_VAR 0 4
54361: PUSH
54362: LD_INT 6
54364: GREATEREQUAL
54365: PUSH
54366: LD_VAR 0 5
54370: PPUSH
54371: LD_INT 2
54373: PPUSH
54374: CALL_OW 325
54378: NOT
54379: OR
54380: IFFALSE 54583
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
54382: LD_ADDR_VAR 0 8
54386: PUSH
54387: LD_EXP 110
54391: PUSH
54392: LD_VAR 0 2
54396: ARRAY
54397: PPUSH
54398: LD_INT 2
54400: PUSH
54401: LD_INT 30
54403: PUSH
54404: LD_INT 4
54406: PUSH
54407: EMPTY
54408: LIST
54409: LIST
54410: PUSH
54411: LD_INT 30
54413: PUSH
54414: LD_INT 5
54416: PUSH
54417: EMPTY
54418: LIST
54419: LIST
54420: PUSH
54421: EMPTY
54422: LIST
54423: LIST
54424: LIST
54425: PPUSH
54426: CALL_OW 72
54430: ST_TO_ADDR
// if barracks then
54431: LD_VAR 0 8
54435: IFFALSE 54583
// begin selected := 0 ;
54437: LD_ADDR_VAR 0 7
54441: PUSH
54442: LD_INT 0
54444: ST_TO_ADDR
// for j in barracks do
54445: LD_ADDR_VAR 0 3
54449: PUSH
54450: LD_VAR 0 8
54454: PUSH
54455: FOR_IN
54456: IFFALSE 54487
// begin if UnitsInside ( j ) < 6 then
54458: LD_VAR 0 3
54462: PPUSH
54463: CALL_OW 313
54467: PUSH
54468: LD_INT 6
54470: LESS
54471: IFFALSE 54485
// begin selected := j ;
54473: LD_ADDR_VAR 0 7
54477: PUSH
54478: LD_VAR 0 3
54482: ST_TO_ADDR
// break ;
54483: GO 54487
// end ; end ;
54485: GO 54455
54487: POP
54488: POP
// if selected then
54489: LD_VAR 0 7
54493: IFFALSE 54583
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54495: LD_ADDR_VAR 0 3
54499: PUSH
54500: LD_EXP 139
54504: PUSH
54505: LD_VAR 0 2
54509: ARRAY
54510: PPUSH
54511: LD_INT 25
54513: PUSH
54514: LD_INT 12
54516: PUSH
54517: EMPTY
54518: LIST
54519: LIST
54520: PPUSH
54521: CALL_OW 72
54525: PUSH
54526: FOR_IN
54527: IFFALSE 54581
// if not IsInUnit ( j ) and not HasTask ( j ) then
54529: LD_VAR 0 3
54533: PPUSH
54534: CALL_OW 310
54538: NOT
54539: PUSH
54540: LD_VAR 0 3
54544: PPUSH
54545: CALL_OW 314
54549: NOT
54550: AND
54551: IFFALSE 54579
// begin ComEnterUnit ( j , selected ) ;
54553: LD_VAR 0 3
54557: PPUSH
54558: LD_VAR 0 7
54562: PPUSH
54563: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
54567: LD_VAR 0 3
54571: PPUSH
54572: LD_INT 15
54574: PPUSH
54575: CALL_OW 183
// end ;
54579: GO 54526
54581: POP
54582: POP
// end ; end ; end ; end ; end ;
54583: GO 53976
54585: POP
54586: POP
// end ;
54587: LD_VAR 0 1
54591: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
54592: LD_INT 0
54594: PPUSH
54595: PPUSH
54596: PPUSH
54597: PPUSH
// if not mc_bases then
54598: LD_EXP 110
54602: NOT
54603: IFFALSE 54607
// exit ;
54605: GO 54785
// for i = 1 to mc_bases do
54607: LD_ADDR_VAR 0 2
54611: PUSH
54612: DOUBLE
54613: LD_INT 1
54615: DEC
54616: ST_TO_ADDR
54617: LD_EXP 110
54621: PUSH
54622: FOR_TO
54623: IFFALSE 54783
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
54625: LD_ADDR_VAR 0 4
54629: PUSH
54630: LD_EXP 110
54634: PUSH
54635: LD_VAR 0 2
54639: ARRAY
54640: PPUSH
54641: LD_INT 25
54643: PUSH
54644: LD_INT 9
54646: PUSH
54647: EMPTY
54648: LIST
54649: LIST
54650: PPUSH
54651: CALL_OW 72
54655: ST_TO_ADDR
// if not tmp then
54656: LD_VAR 0 4
54660: NOT
54661: IFFALSE 54665
// continue ;
54663: GO 54622
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
54665: LD_EXP 136
54669: PUSH
54670: LD_VAR 0 2
54674: ARRAY
54675: PPUSH
54676: LD_INT 29
54678: PPUSH
54679: CALL_OW 325
54683: NOT
54684: PUSH
54685: LD_EXP 136
54689: PUSH
54690: LD_VAR 0 2
54694: ARRAY
54695: PPUSH
54696: LD_INT 28
54698: PPUSH
54699: CALL_OW 325
54703: NOT
54704: AND
54705: IFFALSE 54709
// continue ;
54707: GO 54622
// for j in tmp do
54709: LD_ADDR_VAR 0 3
54713: PUSH
54714: LD_VAR 0 4
54718: PUSH
54719: FOR_IN
54720: IFFALSE 54779
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
54722: LD_VAR 0 3
54726: PUSH
54727: LD_EXP 113
54731: PUSH
54732: LD_VAR 0 2
54736: ARRAY
54737: PUSH
54738: LD_INT 1
54740: ARRAY
54741: IN
54742: NOT
54743: PUSH
54744: LD_VAR 0 3
54748: PUSH
54749: LD_EXP 113
54753: PUSH
54754: LD_VAR 0 2
54758: ARRAY
54759: PUSH
54760: LD_INT 2
54762: ARRAY
54763: IN
54764: NOT
54765: AND
54766: IFFALSE 54777
// ComSpaceTimeShoot ( j ) ;
54768: LD_VAR 0 3
54772: PPUSH
54773: CALL 65923 0 1
54777: GO 54719
54779: POP
54780: POP
// end ;
54781: GO 54622
54783: POP
54784: POP
// end ;
54785: LD_VAR 0 1
54789: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
54790: LD_INT 0
54792: PPUSH
54793: PPUSH
54794: PPUSH
54795: PPUSH
54796: PPUSH
54797: PPUSH
54798: PPUSH
54799: PPUSH
54800: PPUSH
// if not mc_bases then
54801: LD_EXP 110
54805: NOT
54806: IFFALSE 54810
// exit ;
54808: GO 55432
// for i = 1 to mc_bases do
54810: LD_ADDR_VAR 0 2
54814: PUSH
54815: DOUBLE
54816: LD_INT 1
54818: DEC
54819: ST_TO_ADDR
54820: LD_EXP 110
54824: PUSH
54825: FOR_TO
54826: IFFALSE 55430
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
54828: LD_EXP 145
54832: PUSH
54833: LD_VAR 0 2
54837: ARRAY
54838: NOT
54839: PUSH
54840: LD_INT 38
54842: PPUSH
54843: LD_EXP 136
54847: PUSH
54848: LD_VAR 0 2
54852: ARRAY
54853: PPUSH
54854: CALL_OW 321
54858: PUSH
54859: LD_INT 2
54861: NONEQUAL
54862: OR
54863: IFFALSE 54867
// continue ;
54865: GO 54825
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
54867: LD_ADDR_VAR 0 8
54871: PUSH
54872: LD_EXP 110
54876: PUSH
54877: LD_VAR 0 2
54881: ARRAY
54882: PPUSH
54883: LD_INT 30
54885: PUSH
54886: LD_INT 34
54888: PUSH
54889: EMPTY
54890: LIST
54891: LIST
54892: PPUSH
54893: CALL_OW 72
54897: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
54898: LD_ADDR_VAR 0 9
54902: PUSH
54903: LD_EXP 110
54907: PUSH
54908: LD_VAR 0 2
54912: ARRAY
54913: PPUSH
54914: LD_INT 25
54916: PUSH
54917: LD_INT 4
54919: PUSH
54920: EMPTY
54921: LIST
54922: LIST
54923: PPUSH
54924: CALL_OW 72
54928: PPUSH
54929: LD_INT 0
54931: PPUSH
54932: CALL 98487 0 2
54936: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
54937: LD_VAR 0 9
54941: NOT
54942: PUSH
54943: LD_VAR 0 8
54947: NOT
54948: OR
54949: PUSH
54950: LD_EXP 110
54954: PUSH
54955: LD_VAR 0 2
54959: ARRAY
54960: PPUSH
54961: LD_INT 124
54963: PPUSH
54964: CALL 98487 0 2
54968: OR
54969: IFFALSE 54973
// continue ;
54971: GO 54825
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
54973: LD_EXP 146
54977: PUSH
54978: LD_VAR 0 2
54982: ARRAY
54983: PUSH
54984: LD_EXP 145
54988: PUSH
54989: LD_VAR 0 2
54993: ARRAY
54994: LESS
54995: PUSH
54996: LD_EXP 146
55000: PUSH
55001: LD_VAR 0 2
55005: ARRAY
55006: PUSH
55007: LD_VAR 0 8
55011: LESS
55012: AND
55013: IFFALSE 55428
// begin tmp := sci [ 1 ] ;
55015: LD_ADDR_VAR 0 7
55019: PUSH
55020: LD_VAR 0 9
55024: PUSH
55025: LD_INT 1
55027: ARRAY
55028: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
55029: LD_VAR 0 7
55033: PPUSH
55034: LD_INT 124
55036: PPUSH
55037: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
55041: LD_ADDR_VAR 0 3
55045: PUSH
55046: DOUBLE
55047: LD_EXP 145
55051: PUSH
55052: LD_VAR 0 2
55056: ARRAY
55057: INC
55058: ST_TO_ADDR
55059: LD_EXP 145
55063: PUSH
55064: LD_VAR 0 2
55068: ARRAY
55069: PUSH
55070: FOR_DOWNTO
55071: IFFALSE 55414
// begin if IsInUnit ( tmp ) then
55073: LD_VAR 0 7
55077: PPUSH
55078: CALL_OW 310
55082: IFFALSE 55093
// ComExitBuilding ( tmp ) ;
55084: LD_VAR 0 7
55088: PPUSH
55089: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55093: LD_INT 35
55095: PPUSH
55096: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55100: LD_VAR 0 7
55104: PPUSH
55105: CALL_OW 310
55109: NOT
55110: PUSH
55111: LD_VAR 0 7
55115: PPUSH
55116: CALL_OW 314
55120: NOT
55121: AND
55122: IFFALSE 55093
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
55124: LD_ADDR_VAR 0 6
55128: PUSH
55129: LD_VAR 0 7
55133: PPUSH
55134: CALL_OW 250
55138: PUSH
55139: LD_VAR 0 7
55143: PPUSH
55144: CALL_OW 251
55148: PUSH
55149: EMPTY
55150: LIST
55151: LIST
55152: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55153: LD_INT 35
55155: PPUSH
55156: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
55160: LD_ADDR_VAR 0 4
55164: PUSH
55165: LD_EXP 145
55169: PUSH
55170: LD_VAR 0 2
55174: ARRAY
55175: PUSH
55176: LD_VAR 0 3
55180: ARRAY
55181: PUSH
55182: LD_INT 1
55184: ARRAY
55185: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
55186: LD_ADDR_VAR 0 5
55190: PUSH
55191: LD_EXP 145
55195: PUSH
55196: LD_VAR 0 2
55200: ARRAY
55201: PUSH
55202: LD_VAR 0 3
55206: ARRAY
55207: PUSH
55208: LD_INT 2
55210: ARRAY
55211: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
55212: LD_VAR 0 7
55216: PPUSH
55217: LD_INT 10
55219: PPUSH
55220: CALL 72519 0 2
55224: PUSH
55225: LD_INT 4
55227: ARRAY
55228: IFFALSE 55266
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
55230: LD_VAR 0 7
55234: PPUSH
55235: LD_VAR 0 6
55239: PUSH
55240: LD_INT 1
55242: ARRAY
55243: PPUSH
55244: LD_VAR 0 6
55248: PUSH
55249: LD_INT 2
55251: ARRAY
55252: PPUSH
55253: CALL_OW 111
// wait ( 0 0$10 ) ;
55257: LD_INT 350
55259: PPUSH
55260: CALL_OW 67
// end else
55264: GO 55292
// begin ComMoveXY ( tmp , x , y ) ;
55266: LD_VAR 0 7
55270: PPUSH
55271: LD_VAR 0 4
55275: PPUSH
55276: LD_VAR 0 5
55280: PPUSH
55281: CALL_OW 111
// wait ( 0 0$3 ) ;
55285: LD_INT 105
55287: PPUSH
55288: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
55292: LD_VAR 0 7
55296: PPUSH
55297: LD_VAR 0 4
55301: PPUSH
55302: LD_VAR 0 5
55306: PPUSH
55307: CALL_OW 307
55311: IFFALSE 55153
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
55313: LD_VAR 0 7
55317: PPUSH
55318: LD_VAR 0 4
55322: PPUSH
55323: LD_VAR 0 5
55327: PPUSH
55328: LD_VAR 0 8
55332: PUSH
55333: LD_VAR 0 3
55337: ARRAY
55338: PPUSH
55339: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
55343: LD_INT 35
55345: PPUSH
55346: CALL_OW 67
// until not HasTask ( tmp ) ;
55350: LD_VAR 0 7
55354: PPUSH
55355: CALL_OW 314
55359: NOT
55360: IFFALSE 55343
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
55362: LD_ADDR_EXP 146
55366: PUSH
55367: LD_EXP 146
55371: PPUSH
55372: LD_VAR 0 2
55376: PUSH
55377: LD_EXP 146
55381: PUSH
55382: LD_VAR 0 2
55386: ARRAY
55387: PUSH
55388: LD_INT 1
55390: PLUS
55391: PUSH
55392: EMPTY
55393: LIST
55394: LIST
55395: PPUSH
55396: LD_VAR 0 8
55400: PUSH
55401: LD_VAR 0 3
55405: ARRAY
55406: PPUSH
55407: CALL 69926 0 3
55411: ST_TO_ADDR
// end ;
55412: GO 55070
55414: POP
55415: POP
// MC_Reset ( i , 124 ) ;
55416: LD_VAR 0 2
55420: PPUSH
55421: LD_INT 124
55423: PPUSH
55424: CALL 39019 0 2
// end ; end ;
55428: GO 54825
55430: POP
55431: POP
// end ;
55432: LD_VAR 0 1
55436: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
55437: LD_INT 0
55439: PPUSH
55440: PPUSH
55441: PPUSH
// if not mc_bases then
55442: LD_EXP 110
55446: NOT
55447: IFFALSE 55451
// exit ;
55449: GO 56057
// for i = 1 to mc_bases do
55451: LD_ADDR_VAR 0 2
55455: PUSH
55456: DOUBLE
55457: LD_INT 1
55459: DEC
55460: ST_TO_ADDR
55461: LD_EXP 110
55465: PUSH
55466: FOR_TO
55467: IFFALSE 56055
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
55469: LD_ADDR_VAR 0 3
55473: PUSH
55474: LD_EXP 110
55478: PUSH
55479: LD_VAR 0 2
55483: ARRAY
55484: PPUSH
55485: LD_INT 25
55487: PUSH
55488: LD_INT 4
55490: PUSH
55491: EMPTY
55492: LIST
55493: LIST
55494: PPUSH
55495: CALL_OW 72
55499: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55500: LD_VAR 0 3
55504: NOT
55505: PUSH
55506: LD_EXP 147
55510: PUSH
55511: LD_VAR 0 2
55515: ARRAY
55516: NOT
55517: OR
55518: PUSH
55519: LD_EXP 110
55523: PUSH
55524: LD_VAR 0 2
55528: ARRAY
55529: PPUSH
55530: LD_INT 2
55532: PUSH
55533: LD_INT 30
55535: PUSH
55536: LD_INT 0
55538: PUSH
55539: EMPTY
55540: LIST
55541: LIST
55542: PUSH
55543: LD_INT 30
55545: PUSH
55546: LD_INT 1
55548: PUSH
55549: EMPTY
55550: LIST
55551: LIST
55552: PUSH
55553: EMPTY
55554: LIST
55555: LIST
55556: LIST
55557: PPUSH
55558: CALL_OW 72
55562: NOT
55563: OR
55564: IFFALSE 55614
// begin if mc_deposits_finder [ i ] then
55566: LD_EXP 148
55570: PUSH
55571: LD_VAR 0 2
55575: ARRAY
55576: IFFALSE 55612
// begin MC_Reset ( i , 125 ) ;
55578: LD_VAR 0 2
55582: PPUSH
55583: LD_INT 125
55585: PPUSH
55586: CALL 39019 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55590: LD_ADDR_EXP 148
55594: PUSH
55595: LD_EXP 148
55599: PPUSH
55600: LD_VAR 0 2
55604: PPUSH
55605: EMPTY
55606: PPUSH
55607: CALL_OW 1
55611: ST_TO_ADDR
// end ; continue ;
55612: GO 55466
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
55614: LD_EXP 147
55618: PUSH
55619: LD_VAR 0 2
55623: ARRAY
55624: PUSH
55625: LD_INT 1
55627: ARRAY
55628: PUSH
55629: LD_INT 3
55631: ARRAY
55632: PUSH
55633: LD_INT 1
55635: EQUAL
55636: PUSH
55637: LD_INT 20
55639: PPUSH
55640: LD_EXP 136
55644: PUSH
55645: LD_VAR 0 2
55649: ARRAY
55650: PPUSH
55651: CALL_OW 321
55655: PUSH
55656: LD_INT 2
55658: NONEQUAL
55659: AND
55660: IFFALSE 55710
// begin if mc_deposits_finder [ i ] then
55662: LD_EXP 148
55666: PUSH
55667: LD_VAR 0 2
55671: ARRAY
55672: IFFALSE 55708
// begin MC_Reset ( i , 125 ) ;
55674: LD_VAR 0 2
55678: PPUSH
55679: LD_INT 125
55681: PPUSH
55682: CALL 39019 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55686: LD_ADDR_EXP 148
55690: PUSH
55691: LD_EXP 148
55695: PPUSH
55696: LD_VAR 0 2
55700: PPUSH
55701: EMPTY
55702: PPUSH
55703: CALL_OW 1
55707: ST_TO_ADDR
// end ; continue ;
55708: GO 55466
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
55710: LD_EXP 147
55714: PUSH
55715: LD_VAR 0 2
55719: ARRAY
55720: PUSH
55721: LD_INT 1
55723: ARRAY
55724: PUSH
55725: LD_INT 1
55727: ARRAY
55728: PPUSH
55729: LD_EXP 147
55733: PUSH
55734: LD_VAR 0 2
55738: ARRAY
55739: PUSH
55740: LD_INT 1
55742: ARRAY
55743: PUSH
55744: LD_INT 2
55746: ARRAY
55747: PPUSH
55748: LD_EXP 136
55752: PUSH
55753: LD_VAR 0 2
55757: ARRAY
55758: PPUSH
55759: CALL_OW 440
55763: IFFALSE 55806
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
55765: LD_ADDR_EXP 147
55769: PUSH
55770: LD_EXP 147
55774: PPUSH
55775: LD_VAR 0 2
55779: PPUSH
55780: LD_EXP 147
55784: PUSH
55785: LD_VAR 0 2
55789: ARRAY
55790: PPUSH
55791: LD_INT 1
55793: PPUSH
55794: CALL_OW 3
55798: PPUSH
55799: CALL_OW 1
55803: ST_TO_ADDR
55804: GO 56053
// begin if not mc_deposits_finder [ i ] then
55806: LD_EXP 148
55810: PUSH
55811: LD_VAR 0 2
55815: ARRAY
55816: NOT
55817: IFFALSE 55869
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
55819: LD_ADDR_EXP 148
55823: PUSH
55824: LD_EXP 148
55828: PPUSH
55829: LD_VAR 0 2
55833: PPUSH
55834: LD_VAR 0 3
55838: PUSH
55839: LD_INT 1
55841: ARRAY
55842: PUSH
55843: EMPTY
55844: LIST
55845: PPUSH
55846: CALL_OW 1
55850: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
55851: LD_VAR 0 3
55855: PUSH
55856: LD_INT 1
55858: ARRAY
55859: PPUSH
55860: LD_INT 125
55862: PPUSH
55863: CALL_OW 109
// end else
55867: GO 56053
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
55869: LD_EXP 148
55873: PUSH
55874: LD_VAR 0 2
55878: ARRAY
55879: PUSH
55880: LD_INT 1
55882: ARRAY
55883: PPUSH
55884: CALL_OW 310
55888: IFFALSE 55911
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
55890: LD_EXP 148
55894: PUSH
55895: LD_VAR 0 2
55899: ARRAY
55900: PUSH
55901: LD_INT 1
55903: ARRAY
55904: PPUSH
55905: CALL_OW 122
55909: GO 56053
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
55911: LD_EXP 148
55915: PUSH
55916: LD_VAR 0 2
55920: ARRAY
55921: PUSH
55922: LD_INT 1
55924: ARRAY
55925: PPUSH
55926: CALL_OW 314
55930: NOT
55931: PUSH
55932: LD_EXP 148
55936: PUSH
55937: LD_VAR 0 2
55941: ARRAY
55942: PUSH
55943: LD_INT 1
55945: ARRAY
55946: PPUSH
55947: LD_EXP 147
55951: PUSH
55952: LD_VAR 0 2
55956: ARRAY
55957: PUSH
55958: LD_INT 1
55960: ARRAY
55961: PUSH
55962: LD_INT 1
55964: ARRAY
55965: PPUSH
55966: LD_EXP 147
55970: PUSH
55971: LD_VAR 0 2
55975: ARRAY
55976: PUSH
55977: LD_INT 1
55979: ARRAY
55980: PUSH
55981: LD_INT 2
55983: ARRAY
55984: PPUSH
55985: CALL_OW 297
55989: PUSH
55990: LD_INT 6
55992: GREATER
55993: AND
55994: IFFALSE 56053
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
55996: LD_EXP 148
56000: PUSH
56001: LD_VAR 0 2
56005: ARRAY
56006: PUSH
56007: LD_INT 1
56009: ARRAY
56010: PPUSH
56011: LD_EXP 147
56015: PUSH
56016: LD_VAR 0 2
56020: ARRAY
56021: PUSH
56022: LD_INT 1
56024: ARRAY
56025: PUSH
56026: LD_INT 1
56028: ARRAY
56029: PPUSH
56030: LD_EXP 147
56034: PUSH
56035: LD_VAR 0 2
56039: ARRAY
56040: PUSH
56041: LD_INT 1
56043: ARRAY
56044: PUSH
56045: LD_INT 2
56047: ARRAY
56048: PPUSH
56049: CALL_OW 111
// end ; end ; end ;
56053: GO 55466
56055: POP
56056: POP
// end ;
56057: LD_VAR 0 1
56061: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
56062: LD_INT 0
56064: PPUSH
56065: PPUSH
56066: PPUSH
56067: PPUSH
56068: PPUSH
56069: PPUSH
56070: PPUSH
56071: PPUSH
56072: PPUSH
56073: PPUSH
56074: PPUSH
// if not mc_bases then
56075: LD_EXP 110
56079: NOT
56080: IFFALSE 56084
// exit ;
56082: GO 57024
// for i = 1 to mc_bases do
56084: LD_ADDR_VAR 0 2
56088: PUSH
56089: DOUBLE
56090: LD_INT 1
56092: DEC
56093: ST_TO_ADDR
56094: LD_EXP 110
56098: PUSH
56099: FOR_TO
56100: IFFALSE 57022
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56102: LD_EXP 110
56106: PUSH
56107: LD_VAR 0 2
56111: ARRAY
56112: NOT
56113: PUSH
56114: LD_EXP 133
56118: PUSH
56119: LD_VAR 0 2
56123: ARRAY
56124: OR
56125: IFFALSE 56129
// continue ;
56127: GO 56099
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
56129: LD_ADDR_VAR 0 7
56133: PUSH
56134: LD_EXP 110
56138: PUSH
56139: LD_VAR 0 2
56143: ARRAY
56144: PUSH
56145: LD_INT 1
56147: ARRAY
56148: PPUSH
56149: CALL_OW 248
56153: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
56154: LD_VAR 0 7
56158: PUSH
56159: LD_INT 3
56161: EQUAL
56162: PUSH
56163: LD_EXP 129
56167: PUSH
56168: LD_VAR 0 2
56172: ARRAY
56173: PUSH
56174: LD_EXP 132
56178: PUSH
56179: LD_VAR 0 2
56183: ARRAY
56184: UNION
56185: PPUSH
56186: LD_INT 33
56188: PUSH
56189: LD_INT 2
56191: PUSH
56192: EMPTY
56193: LIST
56194: LIST
56195: PPUSH
56196: CALL_OW 72
56200: NOT
56201: OR
56202: IFFALSE 56206
// continue ;
56204: GO 56099
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
56206: LD_ADDR_VAR 0 9
56210: PUSH
56211: LD_EXP 110
56215: PUSH
56216: LD_VAR 0 2
56220: ARRAY
56221: PPUSH
56222: LD_INT 30
56224: PUSH
56225: LD_INT 36
56227: PUSH
56228: EMPTY
56229: LIST
56230: LIST
56231: PPUSH
56232: CALL_OW 72
56236: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
56237: LD_ADDR_VAR 0 10
56241: PUSH
56242: LD_EXP 129
56246: PUSH
56247: LD_VAR 0 2
56251: ARRAY
56252: PPUSH
56253: LD_INT 34
56255: PUSH
56256: LD_INT 31
56258: PUSH
56259: EMPTY
56260: LIST
56261: LIST
56262: PPUSH
56263: CALL_OW 72
56267: ST_TO_ADDR
// if not cts and not mcts then
56268: LD_VAR 0 9
56272: NOT
56273: PUSH
56274: LD_VAR 0 10
56278: NOT
56279: AND
56280: IFFALSE 56284
// continue ;
56282: GO 56099
// x := cts ;
56284: LD_ADDR_VAR 0 11
56288: PUSH
56289: LD_VAR 0 9
56293: ST_TO_ADDR
// if not x then
56294: LD_VAR 0 11
56298: NOT
56299: IFFALSE 56311
// x := mcts ;
56301: LD_ADDR_VAR 0 11
56305: PUSH
56306: LD_VAR 0 10
56310: ST_TO_ADDR
// if not x then
56311: LD_VAR 0 11
56315: NOT
56316: IFFALSE 56320
// continue ;
56318: GO 56099
// if mc_remote_driver [ i ] then
56320: LD_EXP 150
56324: PUSH
56325: LD_VAR 0 2
56329: ARRAY
56330: IFFALSE 56717
// for j in mc_remote_driver [ i ] do
56332: LD_ADDR_VAR 0 3
56336: PUSH
56337: LD_EXP 150
56341: PUSH
56342: LD_VAR 0 2
56346: ARRAY
56347: PUSH
56348: FOR_IN
56349: IFFALSE 56715
// begin if GetClass ( j ) <> 3 then
56351: LD_VAR 0 3
56355: PPUSH
56356: CALL_OW 257
56360: PUSH
56361: LD_INT 3
56363: NONEQUAL
56364: IFFALSE 56417
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
56366: LD_ADDR_EXP 150
56370: PUSH
56371: LD_EXP 150
56375: PPUSH
56376: LD_VAR 0 2
56380: PPUSH
56381: LD_EXP 150
56385: PUSH
56386: LD_VAR 0 2
56390: ARRAY
56391: PUSH
56392: LD_VAR 0 3
56396: DIFF
56397: PPUSH
56398: CALL_OW 1
56402: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56403: LD_VAR 0 3
56407: PPUSH
56408: LD_INT 0
56410: PPUSH
56411: CALL_OW 109
// continue ;
56415: GO 56348
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
56417: LD_EXP 129
56421: PUSH
56422: LD_VAR 0 2
56426: ARRAY
56427: PPUSH
56428: LD_INT 34
56430: PUSH
56431: LD_INT 31
56433: PUSH
56434: EMPTY
56435: LIST
56436: LIST
56437: PUSH
56438: LD_INT 58
56440: PUSH
56441: EMPTY
56442: LIST
56443: PUSH
56444: EMPTY
56445: LIST
56446: LIST
56447: PPUSH
56448: CALL_OW 72
56452: PUSH
56453: LD_VAR 0 3
56457: PPUSH
56458: CALL 98575 0 1
56462: NOT
56463: AND
56464: IFFALSE 56535
// begin if IsInUnit ( j ) then
56466: LD_VAR 0 3
56470: PPUSH
56471: CALL_OW 310
56475: IFFALSE 56486
// ComExitBuilding ( j ) ;
56477: LD_VAR 0 3
56481: PPUSH
56482: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
56486: LD_VAR 0 3
56490: PPUSH
56491: LD_EXP 129
56495: PUSH
56496: LD_VAR 0 2
56500: ARRAY
56501: PPUSH
56502: LD_INT 34
56504: PUSH
56505: LD_INT 31
56507: PUSH
56508: EMPTY
56509: LIST
56510: LIST
56511: PUSH
56512: LD_INT 58
56514: PUSH
56515: EMPTY
56516: LIST
56517: PUSH
56518: EMPTY
56519: LIST
56520: LIST
56521: PPUSH
56522: CALL_OW 72
56526: PUSH
56527: LD_INT 1
56529: ARRAY
56530: PPUSH
56531: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
56535: LD_VAR 0 3
56539: PPUSH
56540: CALL_OW 310
56544: NOT
56545: PUSH
56546: LD_VAR 0 3
56550: PPUSH
56551: CALL_OW 310
56555: PPUSH
56556: CALL_OW 266
56560: PUSH
56561: LD_INT 36
56563: NONEQUAL
56564: PUSH
56565: LD_VAR 0 3
56569: PPUSH
56570: CALL 98575 0 1
56574: NOT
56575: AND
56576: OR
56577: IFFALSE 56713
// begin if IsInUnit ( j ) then
56579: LD_VAR 0 3
56583: PPUSH
56584: CALL_OW 310
56588: IFFALSE 56599
// ComExitBuilding ( j ) ;
56590: LD_VAR 0 3
56594: PPUSH
56595: CALL_OW 122
// ct := 0 ;
56599: LD_ADDR_VAR 0 8
56603: PUSH
56604: LD_INT 0
56606: ST_TO_ADDR
// for k in x do
56607: LD_ADDR_VAR 0 4
56611: PUSH
56612: LD_VAR 0 11
56616: PUSH
56617: FOR_IN
56618: IFFALSE 56691
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
56620: LD_VAR 0 4
56624: PPUSH
56625: CALL_OW 264
56629: PUSH
56630: LD_INT 31
56632: EQUAL
56633: PUSH
56634: LD_VAR 0 4
56638: PPUSH
56639: CALL_OW 311
56643: NOT
56644: AND
56645: PUSH
56646: LD_VAR 0 4
56650: PPUSH
56651: CALL_OW 266
56655: PUSH
56656: LD_INT 36
56658: EQUAL
56659: PUSH
56660: LD_VAR 0 4
56664: PPUSH
56665: CALL_OW 313
56669: PUSH
56670: LD_INT 3
56672: LESS
56673: AND
56674: OR
56675: IFFALSE 56689
// begin ct := k ;
56677: LD_ADDR_VAR 0 8
56681: PUSH
56682: LD_VAR 0 4
56686: ST_TO_ADDR
// break ;
56687: GO 56691
// end ;
56689: GO 56617
56691: POP
56692: POP
// if ct then
56693: LD_VAR 0 8
56697: IFFALSE 56713
// ComEnterUnit ( j , ct ) ;
56699: LD_VAR 0 3
56703: PPUSH
56704: LD_VAR 0 8
56708: PPUSH
56709: CALL_OW 120
// end ; end ;
56713: GO 56348
56715: POP
56716: POP
// places := 0 ;
56717: LD_ADDR_VAR 0 5
56721: PUSH
56722: LD_INT 0
56724: ST_TO_ADDR
// for j = 1 to x do
56725: LD_ADDR_VAR 0 3
56729: PUSH
56730: DOUBLE
56731: LD_INT 1
56733: DEC
56734: ST_TO_ADDR
56735: LD_VAR 0 11
56739: PUSH
56740: FOR_TO
56741: IFFALSE 56817
// if GetWeapon ( x [ j ] ) = ar_control_tower then
56743: LD_VAR 0 11
56747: PUSH
56748: LD_VAR 0 3
56752: ARRAY
56753: PPUSH
56754: CALL_OW 264
56758: PUSH
56759: LD_INT 31
56761: EQUAL
56762: IFFALSE 56780
// places := places + 1 else
56764: LD_ADDR_VAR 0 5
56768: PUSH
56769: LD_VAR 0 5
56773: PUSH
56774: LD_INT 1
56776: PLUS
56777: ST_TO_ADDR
56778: GO 56815
// if GetBType ( x [ j ] ) = b_control_tower then
56780: LD_VAR 0 11
56784: PUSH
56785: LD_VAR 0 3
56789: ARRAY
56790: PPUSH
56791: CALL_OW 266
56795: PUSH
56796: LD_INT 36
56798: EQUAL
56799: IFFALSE 56815
// places := places + 3 ;
56801: LD_ADDR_VAR 0 5
56805: PUSH
56806: LD_VAR 0 5
56810: PUSH
56811: LD_INT 3
56813: PLUS
56814: ST_TO_ADDR
56815: GO 56740
56817: POP
56818: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
56819: LD_VAR 0 5
56823: PUSH
56824: LD_INT 0
56826: EQUAL
56827: PUSH
56828: LD_VAR 0 5
56832: PUSH
56833: LD_EXP 150
56837: PUSH
56838: LD_VAR 0 2
56842: ARRAY
56843: LESSEQUAL
56844: OR
56845: IFFALSE 56849
// continue ;
56847: GO 56099
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
56849: LD_ADDR_VAR 0 6
56853: PUSH
56854: LD_EXP 110
56858: PUSH
56859: LD_VAR 0 2
56863: ARRAY
56864: PPUSH
56865: LD_INT 25
56867: PUSH
56868: LD_INT 3
56870: PUSH
56871: EMPTY
56872: LIST
56873: LIST
56874: PPUSH
56875: CALL_OW 72
56879: PUSH
56880: LD_EXP 150
56884: PUSH
56885: LD_VAR 0 2
56889: ARRAY
56890: DIFF
56891: PPUSH
56892: LD_INT 3
56894: PPUSH
56895: CALL 99475 0 2
56899: ST_TO_ADDR
// for j in tmp do
56900: LD_ADDR_VAR 0 3
56904: PUSH
56905: LD_VAR 0 6
56909: PUSH
56910: FOR_IN
56911: IFFALSE 56946
// if GetTag ( j ) > 0 then
56913: LD_VAR 0 3
56917: PPUSH
56918: CALL_OW 110
56922: PUSH
56923: LD_INT 0
56925: GREATER
56926: IFFALSE 56944
// tmp := tmp diff j ;
56928: LD_ADDR_VAR 0 6
56932: PUSH
56933: LD_VAR 0 6
56937: PUSH
56938: LD_VAR 0 3
56942: DIFF
56943: ST_TO_ADDR
56944: GO 56910
56946: POP
56947: POP
// if not tmp then
56948: LD_VAR 0 6
56952: NOT
56953: IFFALSE 56957
// continue ;
56955: GO 56099
// if places then
56957: LD_VAR 0 5
56961: IFFALSE 57020
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
56963: LD_ADDR_EXP 150
56967: PUSH
56968: LD_EXP 150
56972: PPUSH
56973: LD_VAR 0 2
56977: PPUSH
56978: LD_EXP 150
56982: PUSH
56983: LD_VAR 0 2
56987: ARRAY
56988: PUSH
56989: LD_VAR 0 6
56993: PUSH
56994: LD_INT 1
56996: ARRAY
56997: UNION
56998: PPUSH
56999: CALL_OW 1
57003: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
57004: LD_VAR 0 6
57008: PUSH
57009: LD_INT 1
57011: ARRAY
57012: PPUSH
57013: LD_INT 126
57015: PPUSH
57016: CALL_OW 109
// end ; end ;
57020: GO 56099
57022: POP
57023: POP
// end ;
57024: LD_VAR 0 1
57028: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
57029: LD_INT 0
57031: PPUSH
57032: PPUSH
57033: PPUSH
57034: PPUSH
57035: PPUSH
57036: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
57037: LD_VAR 0 1
57041: NOT
57042: PUSH
57043: LD_VAR 0 2
57047: NOT
57048: OR
57049: PUSH
57050: LD_VAR 0 3
57054: NOT
57055: OR
57056: PUSH
57057: LD_VAR 0 4
57061: PUSH
57062: LD_INT 1
57064: PUSH
57065: LD_INT 2
57067: PUSH
57068: LD_INT 3
57070: PUSH
57071: LD_INT 4
57073: PUSH
57074: LD_INT 5
57076: PUSH
57077: LD_INT 8
57079: PUSH
57080: LD_INT 9
57082: PUSH
57083: LD_INT 15
57085: PUSH
57086: LD_INT 16
57088: PUSH
57089: EMPTY
57090: LIST
57091: LIST
57092: LIST
57093: LIST
57094: LIST
57095: LIST
57096: LIST
57097: LIST
57098: LIST
57099: IN
57100: NOT
57101: OR
57102: IFFALSE 57106
// exit ;
57104: GO 58006
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57106: LD_ADDR_VAR 0 2
57110: PUSH
57111: LD_VAR 0 2
57115: PPUSH
57116: LD_INT 21
57118: PUSH
57119: LD_INT 3
57121: PUSH
57122: EMPTY
57123: LIST
57124: LIST
57125: PUSH
57126: LD_INT 24
57128: PUSH
57129: LD_INT 250
57131: PUSH
57132: EMPTY
57133: LIST
57134: LIST
57135: PUSH
57136: EMPTY
57137: LIST
57138: LIST
57139: PPUSH
57140: CALL_OW 72
57144: ST_TO_ADDR
// case class of 1 , 15 :
57145: LD_VAR 0 4
57149: PUSH
57150: LD_INT 1
57152: DOUBLE
57153: EQUAL
57154: IFTRUE 57164
57156: LD_INT 15
57158: DOUBLE
57159: EQUAL
57160: IFTRUE 57164
57162: GO 57249
57164: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
57165: LD_ADDR_VAR 0 8
57169: PUSH
57170: LD_VAR 0 2
57174: PPUSH
57175: LD_INT 2
57177: PUSH
57178: LD_INT 30
57180: PUSH
57181: LD_INT 32
57183: PUSH
57184: EMPTY
57185: LIST
57186: LIST
57187: PUSH
57188: LD_INT 30
57190: PUSH
57191: LD_INT 31
57193: PUSH
57194: EMPTY
57195: LIST
57196: LIST
57197: PUSH
57198: EMPTY
57199: LIST
57200: LIST
57201: LIST
57202: PPUSH
57203: CALL_OW 72
57207: PUSH
57208: LD_VAR 0 2
57212: PPUSH
57213: LD_INT 2
57215: PUSH
57216: LD_INT 30
57218: PUSH
57219: LD_INT 4
57221: PUSH
57222: EMPTY
57223: LIST
57224: LIST
57225: PUSH
57226: LD_INT 30
57228: PUSH
57229: LD_INT 5
57231: PUSH
57232: EMPTY
57233: LIST
57234: LIST
57235: PUSH
57236: EMPTY
57237: LIST
57238: LIST
57239: LIST
57240: PPUSH
57241: CALL_OW 72
57245: ADD
57246: ST_TO_ADDR
57247: GO 57495
57249: LD_INT 2
57251: DOUBLE
57252: EQUAL
57253: IFTRUE 57263
57255: LD_INT 16
57257: DOUBLE
57258: EQUAL
57259: IFTRUE 57263
57261: GO 57309
57263: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
57264: LD_ADDR_VAR 0 8
57268: PUSH
57269: LD_VAR 0 2
57273: PPUSH
57274: LD_INT 2
57276: PUSH
57277: LD_INT 30
57279: PUSH
57280: LD_INT 0
57282: PUSH
57283: EMPTY
57284: LIST
57285: LIST
57286: PUSH
57287: LD_INT 30
57289: PUSH
57290: LD_INT 1
57292: PUSH
57293: EMPTY
57294: LIST
57295: LIST
57296: PUSH
57297: EMPTY
57298: LIST
57299: LIST
57300: LIST
57301: PPUSH
57302: CALL_OW 72
57306: ST_TO_ADDR
57307: GO 57495
57309: LD_INT 3
57311: DOUBLE
57312: EQUAL
57313: IFTRUE 57317
57315: GO 57363
57317: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
57318: LD_ADDR_VAR 0 8
57322: PUSH
57323: LD_VAR 0 2
57327: PPUSH
57328: LD_INT 2
57330: PUSH
57331: LD_INT 30
57333: PUSH
57334: LD_INT 2
57336: PUSH
57337: EMPTY
57338: LIST
57339: LIST
57340: PUSH
57341: LD_INT 30
57343: PUSH
57344: LD_INT 3
57346: PUSH
57347: EMPTY
57348: LIST
57349: LIST
57350: PUSH
57351: EMPTY
57352: LIST
57353: LIST
57354: LIST
57355: PPUSH
57356: CALL_OW 72
57360: ST_TO_ADDR
57361: GO 57495
57363: LD_INT 4
57365: DOUBLE
57366: EQUAL
57367: IFTRUE 57371
57369: GO 57428
57371: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
57372: LD_ADDR_VAR 0 8
57376: PUSH
57377: LD_VAR 0 2
57381: PPUSH
57382: LD_INT 2
57384: PUSH
57385: LD_INT 30
57387: PUSH
57388: LD_INT 6
57390: PUSH
57391: EMPTY
57392: LIST
57393: LIST
57394: PUSH
57395: LD_INT 30
57397: PUSH
57398: LD_INT 7
57400: PUSH
57401: EMPTY
57402: LIST
57403: LIST
57404: PUSH
57405: LD_INT 30
57407: PUSH
57408: LD_INT 8
57410: PUSH
57411: EMPTY
57412: LIST
57413: LIST
57414: PUSH
57415: EMPTY
57416: LIST
57417: LIST
57418: LIST
57419: LIST
57420: PPUSH
57421: CALL_OW 72
57425: ST_TO_ADDR
57426: GO 57495
57428: LD_INT 5
57430: DOUBLE
57431: EQUAL
57432: IFTRUE 57448
57434: LD_INT 8
57436: DOUBLE
57437: EQUAL
57438: IFTRUE 57448
57440: LD_INT 9
57442: DOUBLE
57443: EQUAL
57444: IFTRUE 57448
57446: GO 57494
57448: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
57449: LD_ADDR_VAR 0 8
57453: PUSH
57454: LD_VAR 0 2
57458: PPUSH
57459: LD_INT 2
57461: PUSH
57462: LD_INT 30
57464: PUSH
57465: LD_INT 4
57467: PUSH
57468: EMPTY
57469: LIST
57470: LIST
57471: PUSH
57472: LD_INT 30
57474: PUSH
57475: LD_INT 5
57477: PUSH
57478: EMPTY
57479: LIST
57480: LIST
57481: PUSH
57482: EMPTY
57483: LIST
57484: LIST
57485: LIST
57486: PPUSH
57487: CALL_OW 72
57491: ST_TO_ADDR
57492: GO 57495
57494: POP
// if not tmp then
57495: LD_VAR 0 8
57499: NOT
57500: IFFALSE 57504
// exit ;
57502: GO 58006
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
57504: LD_VAR 0 4
57508: PUSH
57509: LD_INT 1
57511: PUSH
57512: LD_INT 15
57514: PUSH
57515: EMPTY
57516: LIST
57517: LIST
57518: IN
57519: PUSH
57520: LD_EXP 119
57524: PUSH
57525: LD_VAR 0 1
57529: ARRAY
57530: AND
57531: IFFALSE 57687
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
57533: LD_ADDR_VAR 0 9
57537: PUSH
57538: LD_EXP 119
57542: PUSH
57543: LD_VAR 0 1
57547: ARRAY
57548: PUSH
57549: LD_INT 1
57551: ARRAY
57552: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
57553: LD_VAR 0 9
57557: PUSH
57558: LD_EXP 120
57562: PUSH
57563: LD_VAR 0 1
57567: ARRAY
57568: IN
57569: NOT
57570: IFFALSE 57685
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
57572: LD_ADDR_EXP 120
57576: PUSH
57577: LD_EXP 120
57581: PPUSH
57582: LD_VAR 0 1
57586: PUSH
57587: LD_EXP 120
57591: PUSH
57592: LD_VAR 0 1
57596: ARRAY
57597: PUSH
57598: LD_INT 1
57600: PLUS
57601: PUSH
57602: EMPTY
57603: LIST
57604: LIST
57605: PPUSH
57606: LD_VAR 0 9
57610: PPUSH
57611: CALL 69926 0 3
57615: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
57616: LD_ADDR_EXP 119
57620: PUSH
57621: LD_EXP 119
57625: PPUSH
57626: LD_VAR 0 1
57630: PPUSH
57631: LD_EXP 119
57635: PUSH
57636: LD_VAR 0 1
57640: ARRAY
57641: PUSH
57642: LD_VAR 0 9
57646: DIFF
57647: PPUSH
57648: CALL_OW 1
57652: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
57653: LD_VAR 0 3
57657: PPUSH
57658: LD_EXP 120
57662: PUSH
57663: LD_VAR 0 1
57667: ARRAY
57668: PUSH
57669: LD_EXP 120
57673: PUSH
57674: LD_VAR 0 1
57678: ARRAY
57679: ARRAY
57680: PPUSH
57681: CALL_OW 120
// end ; exit ;
57685: GO 58006
// end ; if tmp > 1 then
57687: LD_VAR 0 8
57691: PUSH
57692: LD_INT 1
57694: GREATER
57695: IFFALSE 57799
// for i = 2 to tmp do
57697: LD_ADDR_VAR 0 6
57701: PUSH
57702: DOUBLE
57703: LD_INT 2
57705: DEC
57706: ST_TO_ADDR
57707: LD_VAR 0 8
57711: PUSH
57712: FOR_TO
57713: IFFALSE 57797
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
57715: LD_VAR 0 8
57719: PUSH
57720: LD_VAR 0 6
57724: ARRAY
57725: PPUSH
57726: CALL_OW 461
57730: PUSH
57731: LD_INT 6
57733: EQUAL
57734: IFFALSE 57795
// begin x := tmp [ i ] ;
57736: LD_ADDR_VAR 0 9
57740: PUSH
57741: LD_VAR 0 8
57745: PUSH
57746: LD_VAR 0 6
57750: ARRAY
57751: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
57752: LD_ADDR_VAR 0 8
57756: PUSH
57757: LD_VAR 0 8
57761: PPUSH
57762: LD_VAR 0 6
57766: PPUSH
57767: CALL_OW 3
57771: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
57772: LD_ADDR_VAR 0 8
57776: PUSH
57777: LD_VAR 0 8
57781: PPUSH
57782: LD_INT 1
57784: PPUSH
57785: LD_VAR 0 9
57789: PPUSH
57790: CALL_OW 2
57794: ST_TO_ADDR
// end ;
57795: GO 57712
57797: POP
57798: POP
// for i in tmp do
57799: LD_ADDR_VAR 0 6
57803: PUSH
57804: LD_VAR 0 8
57808: PUSH
57809: FOR_IN
57810: IFFALSE 57879
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
57812: LD_VAR 0 6
57816: PPUSH
57817: CALL_OW 313
57821: PUSH
57822: LD_INT 6
57824: LESS
57825: PUSH
57826: LD_VAR 0 6
57830: PPUSH
57831: CALL_OW 266
57835: PUSH
57836: LD_INT 31
57838: PUSH
57839: LD_INT 32
57841: PUSH
57842: EMPTY
57843: LIST
57844: LIST
57845: IN
57846: NOT
57847: AND
57848: PUSH
57849: LD_VAR 0 6
57853: PPUSH
57854: CALL_OW 313
57858: PUSH
57859: LD_INT 0
57861: EQUAL
57862: OR
57863: IFFALSE 57877
// begin j := i ;
57865: LD_ADDR_VAR 0 7
57869: PUSH
57870: LD_VAR 0 6
57874: ST_TO_ADDR
// break ;
57875: GO 57879
// end ; end ;
57877: GO 57809
57879: POP
57880: POP
// if j then
57881: LD_VAR 0 7
57885: IFFALSE 57903
// ComEnterUnit ( unit , j ) else
57887: LD_VAR 0 3
57891: PPUSH
57892: LD_VAR 0 7
57896: PPUSH
57897: CALL_OW 120
57901: GO 58006
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57903: LD_ADDR_VAR 0 10
57907: PUSH
57908: LD_VAR 0 2
57912: PPUSH
57913: LD_INT 2
57915: PUSH
57916: LD_INT 30
57918: PUSH
57919: LD_INT 0
57921: PUSH
57922: EMPTY
57923: LIST
57924: LIST
57925: PUSH
57926: LD_INT 30
57928: PUSH
57929: LD_INT 1
57931: PUSH
57932: EMPTY
57933: LIST
57934: LIST
57935: PUSH
57936: EMPTY
57937: LIST
57938: LIST
57939: LIST
57940: PPUSH
57941: CALL_OW 72
57945: ST_TO_ADDR
// if depot then
57946: LD_VAR 0 10
57950: IFFALSE 58006
// begin depot := NearestUnitToUnit ( depot , unit ) ;
57952: LD_ADDR_VAR 0 10
57956: PUSH
57957: LD_VAR 0 10
57961: PPUSH
57962: LD_VAR 0 3
57966: PPUSH
57967: CALL_OW 74
57971: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
57972: LD_VAR 0 3
57976: PPUSH
57977: LD_VAR 0 10
57981: PPUSH
57982: CALL_OW 296
57986: PUSH
57987: LD_INT 10
57989: GREATER
57990: IFFALSE 58006
// ComStandNearbyBuilding ( unit , depot ) ;
57992: LD_VAR 0 3
57996: PPUSH
57997: LD_VAR 0 10
58001: PPUSH
58002: CALL 66540 0 2
// end ; end ; end ;
58006: LD_VAR 0 5
58010: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
58011: LD_INT 0
58013: PPUSH
58014: PPUSH
58015: PPUSH
58016: PPUSH
// if not mc_bases then
58017: LD_EXP 110
58021: NOT
58022: IFFALSE 58026
// exit ;
58024: GO 58265
// for i = 1 to mc_bases do
58026: LD_ADDR_VAR 0 2
58030: PUSH
58031: DOUBLE
58032: LD_INT 1
58034: DEC
58035: ST_TO_ADDR
58036: LD_EXP 110
58040: PUSH
58041: FOR_TO
58042: IFFALSE 58263
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
58044: LD_ADDR_VAR 0 4
58048: PUSH
58049: LD_EXP 110
58053: PUSH
58054: LD_VAR 0 2
58058: ARRAY
58059: PPUSH
58060: LD_INT 21
58062: PUSH
58063: LD_INT 1
58065: PUSH
58066: EMPTY
58067: LIST
58068: LIST
58069: PPUSH
58070: CALL_OW 72
58074: PUSH
58075: LD_EXP 139
58079: PUSH
58080: LD_VAR 0 2
58084: ARRAY
58085: UNION
58086: ST_TO_ADDR
// if not tmp then
58087: LD_VAR 0 4
58091: NOT
58092: IFFALSE 58096
// continue ;
58094: GO 58041
// for j in tmp do
58096: LD_ADDR_VAR 0 3
58100: PUSH
58101: LD_VAR 0 4
58105: PUSH
58106: FOR_IN
58107: IFFALSE 58259
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58109: LD_VAR 0 3
58113: PPUSH
58114: CALL_OW 110
58118: NOT
58119: PUSH
58120: LD_VAR 0 3
58124: PPUSH
58125: CALL_OW 314
58129: NOT
58130: AND
58131: PUSH
58132: LD_VAR 0 3
58136: PPUSH
58137: CALL_OW 311
58141: NOT
58142: AND
58143: PUSH
58144: LD_VAR 0 3
58148: PPUSH
58149: CALL_OW 310
58153: NOT
58154: AND
58155: PUSH
58156: LD_VAR 0 3
58160: PUSH
58161: LD_EXP 113
58165: PUSH
58166: LD_VAR 0 2
58170: ARRAY
58171: PUSH
58172: LD_INT 1
58174: ARRAY
58175: IN
58176: NOT
58177: AND
58178: PUSH
58179: LD_VAR 0 3
58183: PUSH
58184: LD_EXP 113
58188: PUSH
58189: LD_VAR 0 2
58193: ARRAY
58194: PUSH
58195: LD_INT 2
58197: ARRAY
58198: IN
58199: NOT
58200: AND
58201: PUSH
58202: LD_VAR 0 3
58206: PUSH
58207: LD_EXP 122
58211: PUSH
58212: LD_VAR 0 2
58216: ARRAY
58217: IN
58218: NOT
58219: AND
58220: IFFALSE 58257
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
58222: LD_VAR 0 2
58226: PPUSH
58227: LD_EXP 110
58231: PUSH
58232: LD_VAR 0 2
58236: ARRAY
58237: PPUSH
58238: LD_VAR 0 3
58242: PPUSH
58243: LD_VAR 0 3
58247: PPUSH
58248: CALL_OW 257
58252: PPUSH
58253: CALL 57029 0 4
// end ;
58257: GO 58106
58259: POP
58260: POP
// end ;
58261: GO 58041
58263: POP
58264: POP
// end ;
58265: LD_VAR 0 1
58269: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
58270: LD_INT 0
58272: PPUSH
58273: PPUSH
58274: PPUSH
58275: PPUSH
58276: PPUSH
58277: PPUSH
// if not mc_bases [ base ] then
58278: LD_EXP 110
58282: PUSH
58283: LD_VAR 0 1
58287: ARRAY
58288: NOT
58289: IFFALSE 58293
// exit ;
58291: GO 58475
// tmp := [ ] ;
58293: LD_ADDR_VAR 0 6
58297: PUSH
58298: EMPTY
58299: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
58300: LD_ADDR_VAR 0 7
58304: PUSH
58305: LD_VAR 0 3
58309: PPUSH
58310: LD_INT 0
58312: PPUSH
58313: CALL_OW 517
58317: ST_TO_ADDR
// if not list then
58318: LD_VAR 0 7
58322: NOT
58323: IFFALSE 58327
// exit ;
58325: GO 58475
// for i = 1 to amount do
58327: LD_ADDR_VAR 0 5
58331: PUSH
58332: DOUBLE
58333: LD_INT 1
58335: DEC
58336: ST_TO_ADDR
58337: LD_VAR 0 2
58341: PUSH
58342: FOR_TO
58343: IFFALSE 58423
// begin x := rand ( 1 , list [ 1 ] ) ;
58345: LD_ADDR_VAR 0 8
58349: PUSH
58350: LD_INT 1
58352: PPUSH
58353: LD_VAR 0 7
58357: PUSH
58358: LD_INT 1
58360: ARRAY
58361: PPUSH
58362: CALL_OW 12
58366: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
58367: LD_ADDR_VAR 0 6
58371: PUSH
58372: LD_VAR 0 6
58376: PPUSH
58377: LD_VAR 0 5
58381: PPUSH
58382: LD_VAR 0 7
58386: PUSH
58387: LD_INT 1
58389: ARRAY
58390: PUSH
58391: LD_VAR 0 8
58395: ARRAY
58396: PUSH
58397: LD_VAR 0 7
58401: PUSH
58402: LD_INT 2
58404: ARRAY
58405: PUSH
58406: LD_VAR 0 8
58410: ARRAY
58411: PUSH
58412: EMPTY
58413: LIST
58414: LIST
58415: PPUSH
58416: CALL_OW 1
58420: ST_TO_ADDR
// end ;
58421: GO 58342
58423: POP
58424: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
58425: LD_ADDR_EXP 123
58429: PUSH
58430: LD_EXP 123
58434: PPUSH
58435: LD_VAR 0 1
58439: PPUSH
58440: LD_VAR 0 6
58444: PPUSH
58445: CALL_OW 1
58449: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
58450: LD_ADDR_EXP 125
58454: PUSH
58455: LD_EXP 125
58459: PPUSH
58460: LD_VAR 0 1
58464: PPUSH
58465: LD_VAR 0 3
58469: PPUSH
58470: CALL_OW 1
58474: ST_TO_ADDR
// end ;
58475: LD_VAR 0 4
58479: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
58480: LD_INT 0
58482: PPUSH
// if not mc_bases [ base ] then
58483: LD_EXP 110
58487: PUSH
58488: LD_VAR 0 1
58492: ARRAY
58493: NOT
58494: IFFALSE 58498
// exit ;
58496: GO 58523
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
58498: LD_ADDR_EXP 115
58502: PUSH
58503: LD_EXP 115
58507: PPUSH
58508: LD_VAR 0 1
58512: PPUSH
58513: LD_VAR 0 2
58517: PPUSH
58518: CALL_OW 1
58522: ST_TO_ADDR
// end ;
58523: LD_VAR 0 3
58527: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
58528: LD_INT 0
58530: PPUSH
// if not mc_bases [ base ] then
58531: LD_EXP 110
58535: PUSH
58536: LD_VAR 0 1
58540: ARRAY
58541: NOT
58542: IFFALSE 58546
// exit ;
58544: GO 58583
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
58546: LD_ADDR_EXP 115
58550: PUSH
58551: LD_EXP 115
58555: PPUSH
58556: LD_VAR 0 1
58560: PPUSH
58561: LD_EXP 115
58565: PUSH
58566: LD_VAR 0 1
58570: ARRAY
58571: PUSH
58572: LD_VAR 0 2
58576: UNION
58577: PPUSH
58578: CALL_OW 1
58582: ST_TO_ADDR
// end ;
58583: LD_VAR 0 3
58587: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
58588: LD_INT 0
58590: PPUSH
// if not mc_bases [ base ] then
58591: LD_EXP 110
58595: PUSH
58596: LD_VAR 0 1
58600: ARRAY
58601: NOT
58602: IFFALSE 58606
// exit ;
58604: GO 58631
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
58606: LD_ADDR_EXP 131
58610: PUSH
58611: LD_EXP 131
58615: PPUSH
58616: LD_VAR 0 1
58620: PPUSH
58621: LD_VAR 0 2
58625: PPUSH
58626: CALL_OW 1
58630: ST_TO_ADDR
// end ;
58631: LD_VAR 0 3
58635: RET
// export function MC_InsertProduceList ( base , components ) ; begin
58636: LD_INT 0
58638: PPUSH
// if not mc_bases [ base ] then
58639: LD_EXP 110
58643: PUSH
58644: LD_VAR 0 1
58648: ARRAY
58649: NOT
58650: IFFALSE 58654
// exit ;
58652: GO 58691
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
58654: LD_ADDR_EXP 131
58658: PUSH
58659: LD_EXP 131
58663: PPUSH
58664: LD_VAR 0 1
58668: PPUSH
58669: LD_EXP 131
58673: PUSH
58674: LD_VAR 0 1
58678: ARRAY
58679: PUSH
58680: LD_VAR 0 2
58684: ADD
58685: PPUSH
58686: CALL_OW 1
58690: ST_TO_ADDR
// end ;
58691: LD_VAR 0 3
58695: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
58696: LD_INT 0
58698: PPUSH
// if not mc_bases [ base ] then
58699: LD_EXP 110
58703: PUSH
58704: LD_VAR 0 1
58708: ARRAY
58709: NOT
58710: IFFALSE 58714
// exit ;
58712: GO 58768
// mc_defender := Replace ( mc_defender , base , deflist ) ;
58714: LD_ADDR_EXP 132
58718: PUSH
58719: LD_EXP 132
58723: PPUSH
58724: LD_VAR 0 1
58728: PPUSH
58729: LD_VAR 0 2
58733: PPUSH
58734: CALL_OW 1
58738: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
58739: LD_ADDR_EXP 121
58743: PUSH
58744: LD_EXP 121
58748: PPUSH
58749: LD_VAR 0 1
58753: PPUSH
58754: LD_VAR 0 2
58758: PUSH
58759: LD_INT 0
58761: PLUS
58762: PPUSH
58763: CALL_OW 1
58767: ST_TO_ADDR
// end ;
58768: LD_VAR 0 3
58772: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
58773: LD_INT 0
58775: PPUSH
// if not mc_bases [ base ] then
58776: LD_EXP 110
58780: PUSH
58781: LD_VAR 0 1
58785: ARRAY
58786: NOT
58787: IFFALSE 58791
// exit ;
58789: GO 58816
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
58791: LD_ADDR_EXP 121
58795: PUSH
58796: LD_EXP 121
58800: PPUSH
58801: LD_VAR 0 1
58805: PPUSH
58806: LD_VAR 0 2
58810: PPUSH
58811: CALL_OW 1
58815: ST_TO_ADDR
// end ;
58816: LD_VAR 0 3
58820: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
58821: LD_INT 0
58823: PPUSH
58824: PPUSH
58825: PPUSH
58826: PPUSH
// if not mc_bases [ base ] then
58827: LD_EXP 110
58831: PUSH
58832: LD_VAR 0 1
58836: ARRAY
58837: NOT
58838: IFFALSE 58842
// exit ;
58840: GO 58907
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
58842: LD_ADDR_EXP 130
58846: PUSH
58847: LD_EXP 130
58851: PPUSH
58852: LD_VAR 0 1
58856: PUSH
58857: LD_EXP 130
58861: PUSH
58862: LD_VAR 0 1
58866: ARRAY
58867: PUSH
58868: LD_INT 1
58870: PLUS
58871: PUSH
58872: EMPTY
58873: LIST
58874: LIST
58875: PPUSH
58876: LD_VAR 0 1
58880: PUSH
58881: LD_VAR 0 2
58885: PUSH
58886: LD_VAR 0 3
58890: PUSH
58891: LD_VAR 0 4
58895: PUSH
58896: EMPTY
58897: LIST
58898: LIST
58899: LIST
58900: LIST
58901: PPUSH
58902: CALL 69926 0 3
58906: ST_TO_ADDR
// end ;
58907: LD_VAR 0 5
58911: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
58912: LD_INT 0
58914: PPUSH
// if not mc_bases [ base ] then
58915: LD_EXP 110
58919: PUSH
58920: LD_VAR 0 1
58924: ARRAY
58925: NOT
58926: IFFALSE 58930
// exit ;
58928: GO 58955
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
58930: LD_ADDR_EXP 147
58934: PUSH
58935: LD_EXP 147
58939: PPUSH
58940: LD_VAR 0 1
58944: PPUSH
58945: LD_VAR 0 2
58949: PPUSH
58950: CALL_OW 1
58954: ST_TO_ADDR
// end ;
58955: LD_VAR 0 3
58959: RET
// export function MC_GetMinesField ( base ) ; begin
58960: LD_INT 0
58962: PPUSH
// result := mc_mines [ base ] ;
58963: LD_ADDR_VAR 0 2
58967: PUSH
58968: LD_EXP 123
58972: PUSH
58973: LD_VAR 0 1
58977: ARRAY
58978: ST_TO_ADDR
// end ;
58979: LD_VAR 0 2
58983: RET
// export function MC_GetProduceList ( base ) ; begin
58984: LD_INT 0
58986: PPUSH
// result := mc_produce [ base ] ;
58987: LD_ADDR_VAR 0 2
58991: PUSH
58992: LD_EXP 131
58996: PUSH
58997: LD_VAR 0 1
59001: ARRAY
59002: ST_TO_ADDR
// end ;
59003: LD_VAR 0 2
59007: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
59008: LD_INT 0
59010: PPUSH
59011: PPUSH
// if not mc_bases then
59012: LD_EXP 110
59016: NOT
59017: IFFALSE 59021
// exit ;
59019: GO 59086
// if mc_bases [ base ] then
59021: LD_EXP 110
59025: PUSH
59026: LD_VAR 0 1
59030: ARRAY
59031: IFFALSE 59086
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59033: LD_ADDR_VAR 0 3
59037: PUSH
59038: LD_EXP 110
59042: PUSH
59043: LD_VAR 0 1
59047: ARRAY
59048: PPUSH
59049: LD_INT 30
59051: PUSH
59052: LD_VAR 0 2
59056: PUSH
59057: EMPTY
59058: LIST
59059: LIST
59060: PPUSH
59061: CALL_OW 72
59065: ST_TO_ADDR
// if result then
59066: LD_VAR 0 3
59070: IFFALSE 59086
// result := result [ 1 ] ;
59072: LD_ADDR_VAR 0 3
59076: PUSH
59077: LD_VAR 0 3
59081: PUSH
59082: LD_INT 1
59084: ARRAY
59085: ST_TO_ADDR
// end ; end ;
59086: LD_VAR 0 3
59090: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59091: LD_INT 0
59093: PPUSH
59094: PPUSH
// if not mc_bases then
59095: LD_EXP 110
59099: NOT
59100: IFFALSE 59104
// exit ;
59102: GO 59149
// if mc_bases [ base ] then
59104: LD_EXP 110
59108: PUSH
59109: LD_VAR 0 1
59113: ARRAY
59114: IFFALSE 59149
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59116: LD_ADDR_VAR 0 3
59120: PUSH
59121: LD_EXP 110
59125: PUSH
59126: LD_VAR 0 1
59130: ARRAY
59131: PPUSH
59132: LD_INT 30
59134: PUSH
59135: LD_VAR 0 2
59139: PUSH
59140: EMPTY
59141: LIST
59142: LIST
59143: PPUSH
59144: CALL_OW 72
59148: ST_TO_ADDR
// end ;
59149: LD_VAR 0 3
59153: RET
// export function MC_SetTame ( base , area ) ; begin
59154: LD_INT 0
59156: PPUSH
// if not mc_bases or not base then
59157: LD_EXP 110
59161: NOT
59162: PUSH
59163: LD_VAR 0 1
59167: NOT
59168: OR
59169: IFFALSE 59173
// exit ;
59171: GO 59198
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
59173: LD_ADDR_EXP 138
59177: PUSH
59178: LD_EXP 138
59182: PPUSH
59183: LD_VAR 0 1
59187: PPUSH
59188: LD_VAR 0 2
59192: PPUSH
59193: CALL_OW 1
59197: ST_TO_ADDR
// end ;
59198: LD_VAR 0 3
59202: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
59203: LD_INT 0
59205: PPUSH
59206: PPUSH
// if not mc_bases or not base then
59207: LD_EXP 110
59211: NOT
59212: PUSH
59213: LD_VAR 0 1
59217: NOT
59218: OR
59219: IFFALSE 59223
// exit ;
59221: GO 59325
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59223: LD_ADDR_VAR 0 4
59227: PUSH
59228: LD_EXP 110
59232: PUSH
59233: LD_VAR 0 1
59237: ARRAY
59238: PPUSH
59239: LD_INT 30
59241: PUSH
59242: LD_VAR 0 2
59246: PUSH
59247: EMPTY
59248: LIST
59249: LIST
59250: PPUSH
59251: CALL_OW 72
59255: ST_TO_ADDR
// if not tmp then
59256: LD_VAR 0 4
59260: NOT
59261: IFFALSE 59265
// exit ;
59263: GO 59325
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
59265: LD_ADDR_EXP 142
59269: PUSH
59270: LD_EXP 142
59274: PPUSH
59275: LD_VAR 0 1
59279: PPUSH
59280: LD_EXP 142
59284: PUSH
59285: LD_VAR 0 1
59289: ARRAY
59290: PPUSH
59291: LD_EXP 142
59295: PUSH
59296: LD_VAR 0 1
59300: ARRAY
59301: PUSH
59302: LD_INT 1
59304: PLUS
59305: PPUSH
59306: LD_VAR 0 4
59310: PUSH
59311: LD_INT 1
59313: ARRAY
59314: PPUSH
59315: CALL_OW 2
59319: PPUSH
59320: CALL_OW 1
59324: ST_TO_ADDR
// end ;
59325: LD_VAR 0 3
59329: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
59330: LD_INT 0
59332: PPUSH
59333: PPUSH
// if not mc_bases or not base or not kinds then
59334: LD_EXP 110
59338: NOT
59339: PUSH
59340: LD_VAR 0 1
59344: NOT
59345: OR
59346: PUSH
59347: LD_VAR 0 2
59351: NOT
59352: OR
59353: IFFALSE 59357
// exit ;
59355: GO 59418
// for i in kinds do
59357: LD_ADDR_VAR 0 4
59361: PUSH
59362: LD_VAR 0 2
59366: PUSH
59367: FOR_IN
59368: IFFALSE 59416
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
59370: LD_ADDR_EXP 144
59374: PUSH
59375: LD_EXP 144
59379: PPUSH
59380: LD_VAR 0 1
59384: PUSH
59385: LD_EXP 144
59389: PUSH
59390: LD_VAR 0 1
59394: ARRAY
59395: PUSH
59396: LD_INT 1
59398: PLUS
59399: PUSH
59400: EMPTY
59401: LIST
59402: LIST
59403: PPUSH
59404: LD_VAR 0 4
59408: PPUSH
59409: CALL 69926 0 3
59413: ST_TO_ADDR
59414: GO 59367
59416: POP
59417: POP
// end ;
59418: LD_VAR 0 3
59422: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
59423: LD_INT 0
59425: PPUSH
// if not mc_bases or not base or not areas then
59426: LD_EXP 110
59430: NOT
59431: PUSH
59432: LD_VAR 0 1
59436: NOT
59437: OR
59438: PUSH
59439: LD_VAR 0 2
59443: NOT
59444: OR
59445: IFFALSE 59449
// exit ;
59447: GO 59474
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
59449: LD_ADDR_EXP 128
59453: PUSH
59454: LD_EXP 128
59458: PPUSH
59459: LD_VAR 0 1
59463: PPUSH
59464: LD_VAR 0 2
59468: PPUSH
59469: CALL_OW 1
59473: ST_TO_ADDR
// end ;
59474: LD_VAR 0 3
59478: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
59479: LD_INT 0
59481: PPUSH
// if not mc_bases or not base or not teleports_exit then
59482: LD_EXP 110
59486: NOT
59487: PUSH
59488: LD_VAR 0 1
59492: NOT
59493: OR
59494: PUSH
59495: LD_VAR 0 2
59499: NOT
59500: OR
59501: IFFALSE 59505
// exit ;
59503: GO 59530
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
59505: LD_ADDR_EXP 145
59509: PUSH
59510: LD_EXP 145
59514: PPUSH
59515: LD_VAR 0 1
59519: PPUSH
59520: LD_VAR 0 2
59524: PPUSH
59525: CALL_OW 1
59529: ST_TO_ADDR
// end ;
59530: LD_VAR 0 3
59534: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
59535: LD_INT 0
59537: PPUSH
59538: PPUSH
59539: PPUSH
// if not mc_bases or not base or not ext_list then
59540: LD_EXP 110
59544: NOT
59545: PUSH
59546: LD_VAR 0 1
59550: NOT
59551: OR
59552: PUSH
59553: LD_VAR 0 5
59557: NOT
59558: OR
59559: IFFALSE 59563
// exit ;
59561: GO 59736
// tmp := GetFacExtXYD ( x , y , d ) ;
59563: LD_ADDR_VAR 0 8
59567: PUSH
59568: LD_VAR 0 2
59572: PPUSH
59573: LD_VAR 0 3
59577: PPUSH
59578: LD_VAR 0 4
59582: PPUSH
59583: CALL 98605 0 3
59587: ST_TO_ADDR
// if not tmp then
59588: LD_VAR 0 8
59592: NOT
59593: IFFALSE 59597
// exit ;
59595: GO 59736
// for i in tmp do
59597: LD_ADDR_VAR 0 7
59601: PUSH
59602: LD_VAR 0 8
59606: PUSH
59607: FOR_IN
59608: IFFALSE 59734
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
59610: LD_ADDR_EXP 115
59614: PUSH
59615: LD_EXP 115
59619: PPUSH
59620: LD_VAR 0 1
59624: PPUSH
59625: LD_EXP 115
59629: PUSH
59630: LD_VAR 0 1
59634: ARRAY
59635: PPUSH
59636: LD_EXP 115
59640: PUSH
59641: LD_VAR 0 1
59645: ARRAY
59646: PUSH
59647: LD_INT 1
59649: PLUS
59650: PPUSH
59651: LD_VAR 0 5
59655: PUSH
59656: LD_INT 1
59658: ARRAY
59659: PUSH
59660: LD_VAR 0 7
59664: PUSH
59665: LD_INT 1
59667: ARRAY
59668: PUSH
59669: LD_VAR 0 7
59673: PUSH
59674: LD_INT 2
59676: ARRAY
59677: PUSH
59678: LD_VAR 0 7
59682: PUSH
59683: LD_INT 3
59685: ARRAY
59686: PUSH
59687: EMPTY
59688: LIST
59689: LIST
59690: LIST
59691: LIST
59692: PPUSH
59693: CALL_OW 2
59697: PPUSH
59698: CALL_OW 1
59702: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
59703: LD_ADDR_VAR 0 5
59707: PUSH
59708: LD_VAR 0 5
59712: PPUSH
59713: LD_INT 1
59715: PPUSH
59716: CALL_OW 3
59720: ST_TO_ADDR
// if not ext_list then
59721: LD_VAR 0 5
59725: NOT
59726: IFFALSE 59732
// exit ;
59728: POP
59729: POP
59730: GO 59736
// end ;
59732: GO 59607
59734: POP
59735: POP
// end ;
59736: LD_VAR 0 6
59740: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
59741: LD_INT 0
59743: PPUSH
// if not mc_bases or not base or not weapon_list then
59744: LD_EXP 110
59748: NOT
59749: PUSH
59750: LD_VAR 0 1
59754: NOT
59755: OR
59756: PUSH
59757: LD_VAR 0 2
59761: NOT
59762: OR
59763: IFFALSE 59767
// exit ;
59765: GO 59792
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
59767: LD_ADDR_EXP 149
59771: PUSH
59772: LD_EXP 149
59776: PPUSH
59777: LD_VAR 0 1
59781: PPUSH
59782: LD_VAR 0 2
59786: PPUSH
59787: CALL_OW 1
59791: ST_TO_ADDR
// end ;
59792: LD_VAR 0 3
59796: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
59797: LD_INT 0
59799: PPUSH
// if not mc_bases or not base or not tech_list then
59800: LD_EXP 110
59804: NOT
59805: PUSH
59806: LD_VAR 0 1
59810: NOT
59811: OR
59812: PUSH
59813: LD_VAR 0 2
59817: NOT
59818: OR
59819: IFFALSE 59823
// exit ;
59821: GO 59848
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
59823: LD_ADDR_EXP 137
59827: PUSH
59828: LD_EXP 137
59832: PPUSH
59833: LD_VAR 0 1
59837: PPUSH
59838: LD_VAR 0 2
59842: PPUSH
59843: CALL_OW 1
59847: ST_TO_ADDR
// end ;
59848: LD_VAR 0 3
59852: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
59853: LD_INT 0
59855: PPUSH
// if not mc_bases or not parking_area or not base then
59856: LD_EXP 110
59860: NOT
59861: PUSH
59862: LD_VAR 0 2
59866: NOT
59867: OR
59868: PUSH
59869: LD_VAR 0 1
59873: NOT
59874: OR
59875: IFFALSE 59879
// exit ;
59877: GO 59904
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
59879: LD_ADDR_EXP 134
59883: PUSH
59884: LD_EXP 134
59888: PPUSH
59889: LD_VAR 0 1
59893: PPUSH
59894: LD_VAR 0 2
59898: PPUSH
59899: CALL_OW 1
59903: ST_TO_ADDR
// end ;
59904: LD_VAR 0 3
59908: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
59909: LD_INT 0
59911: PPUSH
// if not mc_bases or not base or not scan_area then
59912: LD_EXP 110
59916: NOT
59917: PUSH
59918: LD_VAR 0 1
59922: NOT
59923: OR
59924: PUSH
59925: LD_VAR 0 2
59929: NOT
59930: OR
59931: IFFALSE 59935
// exit ;
59933: GO 59960
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
59935: LD_ADDR_EXP 135
59939: PUSH
59940: LD_EXP 135
59944: PPUSH
59945: LD_VAR 0 1
59949: PPUSH
59950: LD_VAR 0 2
59954: PPUSH
59955: CALL_OW 1
59959: ST_TO_ADDR
// end ;
59960: LD_VAR 0 3
59964: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
59965: LD_INT 0
59967: PPUSH
59968: PPUSH
// if not mc_bases or not base then
59969: LD_EXP 110
59973: NOT
59974: PUSH
59975: LD_VAR 0 1
59979: NOT
59980: OR
59981: IFFALSE 59985
// exit ;
59983: GO 60049
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
59985: LD_ADDR_VAR 0 3
59989: PUSH
59990: LD_INT 1
59992: PUSH
59993: LD_INT 2
59995: PUSH
59996: LD_INT 3
59998: PUSH
59999: LD_INT 4
60001: PUSH
60002: LD_INT 11
60004: PUSH
60005: EMPTY
60006: LIST
60007: LIST
60008: LIST
60009: LIST
60010: LIST
60011: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
60012: LD_ADDR_EXP 137
60016: PUSH
60017: LD_EXP 137
60021: PPUSH
60022: LD_VAR 0 1
60026: PPUSH
60027: LD_EXP 137
60031: PUSH
60032: LD_VAR 0 1
60036: ARRAY
60037: PUSH
60038: LD_VAR 0 3
60042: DIFF
60043: PPUSH
60044: CALL_OW 1
60048: ST_TO_ADDR
// end ;
60049: LD_VAR 0 2
60053: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
60054: LD_INT 0
60056: PPUSH
// result := mc_vehicles [ base ] ;
60057: LD_ADDR_VAR 0 3
60061: PUSH
60062: LD_EXP 129
60066: PUSH
60067: LD_VAR 0 1
60071: ARRAY
60072: ST_TO_ADDR
// if onlyCombat then
60073: LD_VAR 0 2
60077: IFFALSE 60242
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
60079: LD_ADDR_VAR 0 3
60083: PUSH
60084: LD_VAR 0 3
60088: PUSH
60089: LD_VAR 0 3
60093: PPUSH
60094: LD_INT 2
60096: PUSH
60097: LD_INT 34
60099: PUSH
60100: LD_INT 12
60102: PUSH
60103: EMPTY
60104: LIST
60105: LIST
60106: PUSH
60107: LD_INT 34
60109: PUSH
60110: LD_INT 51
60112: PUSH
60113: EMPTY
60114: LIST
60115: LIST
60116: PUSH
60117: LD_INT 34
60119: PUSH
60120: LD_EXP 96
60124: PUSH
60125: EMPTY
60126: LIST
60127: LIST
60128: PUSH
60129: LD_INT 34
60131: PUSH
60132: LD_INT 32
60134: PUSH
60135: EMPTY
60136: LIST
60137: LIST
60138: PUSH
60139: LD_INT 34
60141: PUSH
60142: LD_INT 13
60144: PUSH
60145: EMPTY
60146: LIST
60147: LIST
60148: PUSH
60149: LD_INT 34
60151: PUSH
60152: LD_INT 52
60154: PUSH
60155: EMPTY
60156: LIST
60157: LIST
60158: PUSH
60159: LD_INT 34
60161: PUSH
60162: LD_INT 14
60164: PUSH
60165: EMPTY
60166: LIST
60167: LIST
60168: PUSH
60169: LD_INT 34
60171: PUSH
60172: LD_INT 53
60174: PUSH
60175: EMPTY
60176: LIST
60177: LIST
60178: PUSH
60179: LD_INT 34
60181: PUSH
60182: LD_EXP 95
60186: PUSH
60187: EMPTY
60188: LIST
60189: LIST
60190: PUSH
60191: LD_INT 34
60193: PUSH
60194: LD_INT 31
60196: PUSH
60197: EMPTY
60198: LIST
60199: LIST
60200: PUSH
60201: LD_INT 34
60203: PUSH
60204: LD_INT 48
60206: PUSH
60207: EMPTY
60208: LIST
60209: LIST
60210: PUSH
60211: LD_INT 34
60213: PUSH
60214: LD_INT 8
60216: PUSH
60217: EMPTY
60218: LIST
60219: LIST
60220: PUSH
60221: EMPTY
60222: LIST
60223: LIST
60224: LIST
60225: LIST
60226: LIST
60227: LIST
60228: LIST
60229: LIST
60230: LIST
60231: LIST
60232: LIST
60233: LIST
60234: LIST
60235: PPUSH
60236: CALL_OW 72
60240: DIFF
60241: ST_TO_ADDR
// end ; end_of_file
60242: LD_VAR 0 3
60246: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
60247: LD_INT 0
60249: PPUSH
60250: PPUSH
60251: PPUSH
// if not mc_bases or not skirmish then
60252: LD_EXP 110
60256: NOT
60257: PUSH
60258: LD_EXP 108
60262: NOT
60263: OR
60264: IFFALSE 60268
// exit ;
60266: GO 60433
// for i = 1 to mc_bases do
60268: LD_ADDR_VAR 0 4
60272: PUSH
60273: DOUBLE
60274: LD_INT 1
60276: DEC
60277: ST_TO_ADDR
60278: LD_EXP 110
60282: PUSH
60283: FOR_TO
60284: IFFALSE 60431
// begin if sci in mc_bases [ i ] then
60286: LD_VAR 0 2
60290: PUSH
60291: LD_EXP 110
60295: PUSH
60296: LD_VAR 0 4
60300: ARRAY
60301: IN
60302: IFFALSE 60429
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
60304: LD_ADDR_EXP 139
60308: PUSH
60309: LD_EXP 139
60313: PPUSH
60314: LD_VAR 0 4
60318: PUSH
60319: LD_EXP 139
60323: PUSH
60324: LD_VAR 0 4
60328: ARRAY
60329: PUSH
60330: LD_INT 1
60332: PLUS
60333: PUSH
60334: EMPTY
60335: LIST
60336: LIST
60337: PPUSH
60338: LD_VAR 0 1
60342: PPUSH
60343: CALL 69926 0 3
60347: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
60348: LD_ADDR_VAR 0 5
60352: PUSH
60353: LD_EXP 110
60357: PUSH
60358: LD_VAR 0 4
60362: ARRAY
60363: PPUSH
60364: LD_INT 2
60366: PUSH
60367: LD_INT 30
60369: PUSH
60370: LD_INT 0
60372: PUSH
60373: EMPTY
60374: LIST
60375: LIST
60376: PUSH
60377: LD_INT 30
60379: PUSH
60380: LD_INT 1
60382: PUSH
60383: EMPTY
60384: LIST
60385: LIST
60386: PUSH
60387: EMPTY
60388: LIST
60389: LIST
60390: LIST
60391: PPUSH
60392: CALL_OW 72
60396: PPUSH
60397: LD_VAR 0 1
60401: PPUSH
60402: CALL_OW 74
60406: ST_TO_ADDR
// if tmp then
60407: LD_VAR 0 5
60411: IFFALSE 60427
// ComStandNearbyBuilding ( ape , tmp ) ;
60413: LD_VAR 0 1
60417: PPUSH
60418: LD_VAR 0 5
60422: PPUSH
60423: CALL 66540 0 2
// break ;
60427: GO 60431
// end ; end ;
60429: GO 60283
60431: POP
60432: POP
// end ;
60433: LD_VAR 0 3
60437: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
60438: LD_INT 0
60440: PPUSH
60441: PPUSH
60442: PPUSH
// if not mc_bases or not skirmish then
60443: LD_EXP 110
60447: NOT
60448: PUSH
60449: LD_EXP 108
60453: NOT
60454: OR
60455: IFFALSE 60459
// exit ;
60457: GO 60548
// for i = 1 to mc_bases do
60459: LD_ADDR_VAR 0 4
60463: PUSH
60464: DOUBLE
60465: LD_INT 1
60467: DEC
60468: ST_TO_ADDR
60469: LD_EXP 110
60473: PUSH
60474: FOR_TO
60475: IFFALSE 60546
// begin if building in mc_busy_turret_list [ i ] then
60477: LD_VAR 0 1
60481: PUSH
60482: LD_EXP 120
60486: PUSH
60487: LD_VAR 0 4
60491: ARRAY
60492: IN
60493: IFFALSE 60544
// begin tmp := mc_busy_turret_list [ i ] diff building ;
60495: LD_ADDR_VAR 0 5
60499: PUSH
60500: LD_EXP 120
60504: PUSH
60505: LD_VAR 0 4
60509: ARRAY
60510: PUSH
60511: LD_VAR 0 1
60515: DIFF
60516: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
60517: LD_ADDR_EXP 120
60521: PUSH
60522: LD_EXP 120
60526: PPUSH
60527: LD_VAR 0 4
60531: PPUSH
60532: LD_VAR 0 5
60536: PPUSH
60537: CALL_OW 1
60541: ST_TO_ADDR
// break ;
60542: GO 60546
// end ; end ;
60544: GO 60474
60546: POP
60547: POP
// end ;
60548: LD_VAR 0 3
60552: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
60553: LD_INT 0
60555: PPUSH
60556: PPUSH
60557: PPUSH
// if not mc_bases or not skirmish then
60558: LD_EXP 110
60562: NOT
60563: PUSH
60564: LD_EXP 108
60568: NOT
60569: OR
60570: IFFALSE 60574
// exit ;
60572: GO 60773
// for i = 1 to mc_bases do
60574: LD_ADDR_VAR 0 5
60578: PUSH
60579: DOUBLE
60580: LD_INT 1
60582: DEC
60583: ST_TO_ADDR
60584: LD_EXP 110
60588: PUSH
60589: FOR_TO
60590: IFFALSE 60771
// if building in mc_bases [ i ] then
60592: LD_VAR 0 1
60596: PUSH
60597: LD_EXP 110
60601: PUSH
60602: LD_VAR 0 5
60606: ARRAY
60607: IN
60608: IFFALSE 60769
// begin tmp := mc_bases [ i ] diff building ;
60610: LD_ADDR_VAR 0 6
60614: PUSH
60615: LD_EXP 110
60619: PUSH
60620: LD_VAR 0 5
60624: ARRAY
60625: PUSH
60626: LD_VAR 0 1
60630: DIFF
60631: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
60632: LD_ADDR_EXP 110
60636: PUSH
60637: LD_EXP 110
60641: PPUSH
60642: LD_VAR 0 5
60646: PPUSH
60647: LD_VAR 0 6
60651: PPUSH
60652: CALL_OW 1
60656: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
60657: LD_VAR 0 1
60661: PUSH
60662: LD_EXP 118
60666: PUSH
60667: LD_VAR 0 5
60671: ARRAY
60672: IN
60673: IFFALSE 60712
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
60675: LD_ADDR_EXP 118
60679: PUSH
60680: LD_EXP 118
60684: PPUSH
60685: LD_VAR 0 5
60689: PPUSH
60690: LD_EXP 118
60694: PUSH
60695: LD_VAR 0 5
60699: ARRAY
60700: PUSH
60701: LD_VAR 0 1
60705: DIFF
60706: PPUSH
60707: CALL_OW 1
60711: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
60712: LD_VAR 0 1
60716: PUSH
60717: LD_EXP 119
60721: PUSH
60722: LD_VAR 0 5
60726: ARRAY
60727: IN
60728: IFFALSE 60767
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
60730: LD_ADDR_EXP 119
60734: PUSH
60735: LD_EXP 119
60739: PPUSH
60740: LD_VAR 0 5
60744: PPUSH
60745: LD_EXP 119
60749: PUSH
60750: LD_VAR 0 5
60754: ARRAY
60755: PUSH
60756: LD_VAR 0 1
60760: DIFF
60761: PPUSH
60762: CALL_OW 1
60766: ST_TO_ADDR
// break ;
60767: GO 60771
// end ;
60769: GO 60589
60771: POP
60772: POP
// end ;
60773: LD_VAR 0 4
60777: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
60778: LD_INT 0
60780: PPUSH
60781: PPUSH
60782: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
60783: LD_EXP 110
60787: NOT
60788: PUSH
60789: LD_EXP 108
60793: NOT
60794: OR
60795: PUSH
60796: LD_VAR 0 3
60800: PUSH
60801: LD_EXP 136
60805: IN
60806: NOT
60807: OR
60808: IFFALSE 60812
// exit ;
60810: GO 60935
// for i = 1 to mc_vehicles do
60812: LD_ADDR_VAR 0 6
60816: PUSH
60817: DOUBLE
60818: LD_INT 1
60820: DEC
60821: ST_TO_ADDR
60822: LD_EXP 129
60826: PUSH
60827: FOR_TO
60828: IFFALSE 60933
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
60830: LD_VAR 0 2
60834: PUSH
60835: LD_EXP 129
60839: PUSH
60840: LD_VAR 0 6
60844: ARRAY
60845: IN
60846: PUSH
60847: LD_VAR 0 1
60851: PUSH
60852: LD_EXP 129
60856: PUSH
60857: LD_VAR 0 6
60861: ARRAY
60862: IN
60863: OR
60864: IFFALSE 60931
// begin tmp := mc_vehicles [ i ] diff old ;
60866: LD_ADDR_VAR 0 7
60870: PUSH
60871: LD_EXP 129
60875: PUSH
60876: LD_VAR 0 6
60880: ARRAY
60881: PUSH
60882: LD_VAR 0 2
60886: DIFF
60887: ST_TO_ADDR
// tmp := tmp diff new ;
60888: LD_ADDR_VAR 0 7
60892: PUSH
60893: LD_VAR 0 7
60897: PUSH
60898: LD_VAR 0 1
60902: DIFF
60903: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
60904: LD_ADDR_EXP 129
60908: PUSH
60909: LD_EXP 129
60913: PPUSH
60914: LD_VAR 0 6
60918: PPUSH
60919: LD_VAR 0 7
60923: PPUSH
60924: CALL_OW 1
60928: ST_TO_ADDR
// break ;
60929: GO 60933
// end ;
60931: GO 60827
60933: POP
60934: POP
// end ;
60935: LD_VAR 0 5
60939: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
60940: LD_INT 0
60942: PPUSH
60943: PPUSH
60944: PPUSH
60945: PPUSH
// if not mc_bases or not skirmish then
60946: LD_EXP 110
60950: NOT
60951: PUSH
60952: LD_EXP 108
60956: NOT
60957: OR
60958: IFFALSE 60962
// exit ;
60960: GO 61339
// side := GetSide ( vehicle ) ;
60962: LD_ADDR_VAR 0 5
60966: PUSH
60967: LD_VAR 0 1
60971: PPUSH
60972: CALL_OW 255
60976: ST_TO_ADDR
// for i = 1 to mc_bases do
60977: LD_ADDR_VAR 0 4
60981: PUSH
60982: DOUBLE
60983: LD_INT 1
60985: DEC
60986: ST_TO_ADDR
60987: LD_EXP 110
60991: PUSH
60992: FOR_TO
60993: IFFALSE 61337
// begin if factory in mc_bases [ i ] then
60995: LD_VAR 0 2
60999: PUSH
61000: LD_EXP 110
61004: PUSH
61005: LD_VAR 0 4
61009: ARRAY
61010: IN
61011: IFFALSE 61335
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
61013: LD_EXP 132
61017: PUSH
61018: LD_VAR 0 4
61022: ARRAY
61023: PUSH
61024: LD_EXP 121
61028: PUSH
61029: LD_VAR 0 4
61033: ARRAY
61034: LESS
61035: PUSH
61036: LD_VAR 0 1
61040: PPUSH
61041: CALL_OW 264
61045: PUSH
61046: LD_INT 31
61048: PUSH
61049: LD_INT 32
61051: PUSH
61052: LD_INT 51
61054: PUSH
61055: LD_EXP 96
61059: PUSH
61060: LD_INT 12
61062: PUSH
61063: LD_INT 30
61065: PUSH
61066: LD_EXP 95
61070: PUSH
61071: LD_INT 11
61073: PUSH
61074: LD_INT 53
61076: PUSH
61077: LD_INT 14
61079: PUSH
61080: LD_EXP 99
61084: PUSH
61085: LD_INT 29
61087: PUSH
61088: LD_EXP 97
61092: PUSH
61093: LD_INT 13
61095: PUSH
61096: LD_INT 52
61098: PUSH
61099: LD_INT 48
61101: PUSH
61102: LD_INT 8
61104: PUSH
61105: EMPTY
61106: LIST
61107: LIST
61108: LIST
61109: LIST
61110: LIST
61111: LIST
61112: LIST
61113: LIST
61114: LIST
61115: LIST
61116: LIST
61117: LIST
61118: LIST
61119: LIST
61120: LIST
61121: LIST
61122: LIST
61123: IN
61124: NOT
61125: AND
61126: IFFALSE 61174
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
61128: LD_ADDR_EXP 132
61132: PUSH
61133: LD_EXP 132
61137: PPUSH
61138: LD_VAR 0 4
61142: PUSH
61143: LD_EXP 132
61147: PUSH
61148: LD_VAR 0 4
61152: ARRAY
61153: PUSH
61154: LD_INT 1
61156: PLUS
61157: PUSH
61158: EMPTY
61159: LIST
61160: LIST
61161: PPUSH
61162: LD_VAR 0 1
61166: PPUSH
61167: CALL 69926 0 3
61171: ST_TO_ADDR
61172: GO 61218
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
61174: LD_ADDR_EXP 129
61178: PUSH
61179: LD_EXP 129
61183: PPUSH
61184: LD_VAR 0 4
61188: PUSH
61189: LD_EXP 129
61193: PUSH
61194: LD_VAR 0 4
61198: ARRAY
61199: PUSH
61200: LD_INT 1
61202: PLUS
61203: PUSH
61204: EMPTY
61205: LIST
61206: LIST
61207: PPUSH
61208: LD_VAR 0 1
61212: PPUSH
61213: CALL 69926 0 3
61217: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
61218: LD_VAR 0 1
61222: PPUSH
61223: CALL_OW 263
61227: PUSH
61228: LD_INT 2
61230: EQUAL
61231: IFFALSE 61251
// begin repeat wait ( 0 0$1 ) ;
61233: LD_INT 35
61235: PPUSH
61236: CALL_OW 67
// until IsControledBy ( vehicle ) ;
61240: LD_VAR 0 1
61244: PPUSH
61245: CALL_OW 312
61249: IFFALSE 61233
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
61251: LD_VAR 0 1
61255: PPUSH
61256: LD_EXP 134
61260: PUSH
61261: LD_VAR 0 4
61265: ARRAY
61266: PPUSH
61267: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
61271: LD_VAR 0 1
61275: PPUSH
61276: CALL_OW 263
61280: PUSH
61281: LD_INT 1
61283: NONEQUAL
61284: IFFALSE 61288
// break ;
61286: GO 61337
// repeat wait ( 0 0$1 ) ;
61288: LD_INT 35
61290: PPUSH
61291: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
61295: LD_VAR 0 1
61299: PPUSH
61300: LD_EXP 134
61304: PUSH
61305: LD_VAR 0 4
61309: ARRAY
61310: PPUSH
61311: CALL_OW 308
61315: IFFALSE 61288
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
61317: LD_VAR 0 1
61321: PPUSH
61322: CALL_OW 311
61326: PPUSH
61327: CALL_OW 121
// exit ;
61331: POP
61332: POP
61333: GO 61339
// end ; end ;
61335: GO 60992
61337: POP
61338: POP
// end ;
61339: LD_VAR 0 3
61343: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
61344: LD_INT 0
61346: PPUSH
61347: PPUSH
61348: PPUSH
61349: PPUSH
// if not mc_bases or not skirmish then
61350: LD_EXP 110
61354: NOT
61355: PUSH
61356: LD_EXP 108
61360: NOT
61361: OR
61362: IFFALSE 61366
// exit ;
61364: GO 61719
// repeat wait ( 0 0$1 ) ;
61366: LD_INT 35
61368: PPUSH
61369: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
61373: LD_VAR 0 2
61377: PPUSH
61378: LD_VAR 0 3
61382: PPUSH
61383: CALL_OW 284
61387: IFFALSE 61366
// if GetResourceTypeXY ( x , y ) = mat_artefact then
61389: LD_VAR 0 2
61393: PPUSH
61394: LD_VAR 0 3
61398: PPUSH
61399: CALL_OW 283
61403: PUSH
61404: LD_INT 4
61406: EQUAL
61407: IFFALSE 61411
// exit ;
61409: GO 61719
// for i = 1 to mc_bases do
61411: LD_ADDR_VAR 0 7
61415: PUSH
61416: DOUBLE
61417: LD_INT 1
61419: DEC
61420: ST_TO_ADDR
61421: LD_EXP 110
61425: PUSH
61426: FOR_TO
61427: IFFALSE 61717
// begin if mc_crates_area [ i ] then
61429: LD_EXP 128
61433: PUSH
61434: LD_VAR 0 7
61438: ARRAY
61439: IFFALSE 61550
// for j in mc_crates_area [ i ] do
61441: LD_ADDR_VAR 0 8
61445: PUSH
61446: LD_EXP 128
61450: PUSH
61451: LD_VAR 0 7
61455: ARRAY
61456: PUSH
61457: FOR_IN
61458: IFFALSE 61548
// if InArea ( x , y , j ) then
61460: LD_VAR 0 2
61464: PPUSH
61465: LD_VAR 0 3
61469: PPUSH
61470: LD_VAR 0 8
61474: PPUSH
61475: CALL_OW 309
61479: IFFALSE 61546
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61481: LD_ADDR_EXP 126
61485: PUSH
61486: LD_EXP 126
61490: PPUSH
61491: LD_VAR 0 7
61495: PUSH
61496: LD_EXP 126
61500: PUSH
61501: LD_VAR 0 7
61505: ARRAY
61506: PUSH
61507: LD_INT 1
61509: PLUS
61510: PUSH
61511: EMPTY
61512: LIST
61513: LIST
61514: PPUSH
61515: LD_VAR 0 4
61519: PUSH
61520: LD_VAR 0 2
61524: PUSH
61525: LD_VAR 0 3
61529: PUSH
61530: EMPTY
61531: LIST
61532: LIST
61533: LIST
61534: PPUSH
61535: CALL 69926 0 3
61539: ST_TO_ADDR
// exit ;
61540: POP
61541: POP
61542: POP
61543: POP
61544: GO 61719
// end ;
61546: GO 61457
61548: POP
61549: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61550: LD_ADDR_VAR 0 9
61554: PUSH
61555: LD_EXP 110
61559: PUSH
61560: LD_VAR 0 7
61564: ARRAY
61565: PPUSH
61566: LD_INT 2
61568: PUSH
61569: LD_INT 30
61571: PUSH
61572: LD_INT 0
61574: PUSH
61575: EMPTY
61576: LIST
61577: LIST
61578: PUSH
61579: LD_INT 30
61581: PUSH
61582: LD_INT 1
61584: PUSH
61585: EMPTY
61586: LIST
61587: LIST
61588: PUSH
61589: EMPTY
61590: LIST
61591: LIST
61592: LIST
61593: PPUSH
61594: CALL_OW 72
61598: ST_TO_ADDR
// if not depot then
61599: LD_VAR 0 9
61603: NOT
61604: IFFALSE 61608
// continue ;
61606: GO 61426
// for j in depot do
61608: LD_ADDR_VAR 0 8
61612: PUSH
61613: LD_VAR 0 9
61617: PUSH
61618: FOR_IN
61619: IFFALSE 61713
// if GetDistUnitXY ( j , x , y ) < 30 then
61621: LD_VAR 0 8
61625: PPUSH
61626: LD_VAR 0 2
61630: PPUSH
61631: LD_VAR 0 3
61635: PPUSH
61636: CALL_OW 297
61640: PUSH
61641: LD_INT 30
61643: LESS
61644: IFFALSE 61711
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61646: LD_ADDR_EXP 126
61650: PUSH
61651: LD_EXP 126
61655: PPUSH
61656: LD_VAR 0 7
61660: PUSH
61661: LD_EXP 126
61665: PUSH
61666: LD_VAR 0 7
61670: ARRAY
61671: PUSH
61672: LD_INT 1
61674: PLUS
61675: PUSH
61676: EMPTY
61677: LIST
61678: LIST
61679: PPUSH
61680: LD_VAR 0 4
61684: PUSH
61685: LD_VAR 0 2
61689: PUSH
61690: LD_VAR 0 3
61694: PUSH
61695: EMPTY
61696: LIST
61697: LIST
61698: LIST
61699: PPUSH
61700: CALL 69926 0 3
61704: ST_TO_ADDR
// exit ;
61705: POP
61706: POP
61707: POP
61708: POP
61709: GO 61719
// end ;
61711: GO 61618
61713: POP
61714: POP
// end ;
61715: GO 61426
61717: POP
61718: POP
// end ;
61719: LD_VAR 0 6
61723: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
61724: LD_INT 0
61726: PPUSH
61727: PPUSH
61728: PPUSH
61729: PPUSH
// if not mc_bases or not skirmish then
61730: LD_EXP 110
61734: NOT
61735: PUSH
61736: LD_EXP 108
61740: NOT
61741: OR
61742: IFFALSE 61746
// exit ;
61744: GO 62023
// side := GetSide ( lab ) ;
61746: LD_ADDR_VAR 0 4
61750: PUSH
61751: LD_VAR 0 2
61755: PPUSH
61756: CALL_OW 255
61760: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
61761: LD_VAR 0 4
61765: PUSH
61766: LD_EXP 136
61770: IN
61771: NOT
61772: PUSH
61773: LD_EXP 137
61777: NOT
61778: OR
61779: PUSH
61780: LD_EXP 110
61784: NOT
61785: OR
61786: IFFALSE 61790
// exit ;
61788: GO 62023
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
61790: LD_ADDR_EXP 137
61794: PUSH
61795: LD_EXP 137
61799: PPUSH
61800: LD_VAR 0 4
61804: PPUSH
61805: LD_EXP 137
61809: PUSH
61810: LD_VAR 0 4
61814: ARRAY
61815: PUSH
61816: LD_VAR 0 1
61820: DIFF
61821: PPUSH
61822: CALL_OW 1
61826: ST_TO_ADDR
// for i = 1 to mc_bases do
61827: LD_ADDR_VAR 0 5
61831: PUSH
61832: DOUBLE
61833: LD_INT 1
61835: DEC
61836: ST_TO_ADDR
61837: LD_EXP 110
61841: PUSH
61842: FOR_TO
61843: IFFALSE 62021
// begin if lab in mc_bases [ i ] then
61845: LD_VAR 0 2
61849: PUSH
61850: LD_EXP 110
61854: PUSH
61855: LD_VAR 0 5
61859: ARRAY
61860: IN
61861: IFFALSE 62019
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
61863: LD_VAR 0 1
61867: PUSH
61868: LD_INT 11
61870: PUSH
61871: LD_INT 4
61873: PUSH
61874: LD_INT 3
61876: PUSH
61877: LD_INT 2
61879: PUSH
61880: EMPTY
61881: LIST
61882: LIST
61883: LIST
61884: LIST
61885: IN
61886: PUSH
61887: LD_EXP 140
61891: PUSH
61892: LD_VAR 0 5
61896: ARRAY
61897: AND
61898: IFFALSE 62019
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
61900: LD_ADDR_VAR 0 6
61904: PUSH
61905: LD_EXP 140
61909: PUSH
61910: LD_VAR 0 5
61914: ARRAY
61915: PUSH
61916: LD_INT 1
61918: ARRAY
61919: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61920: LD_ADDR_EXP 140
61924: PUSH
61925: LD_EXP 140
61929: PPUSH
61930: LD_VAR 0 5
61934: PPUSH
61935: EMPTY
61936: PPUSH
61937: CALL_OW 1
61941: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
61942: LD_VAR 0 6
61946: PPUSH
61947: LD_INT 0
61949: PPUSH
61950: CALL_OW 109
// ComExitBuilding ( tmp ) ;
61954: LD_VAR 0 6
61958: PPUSH
61959: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
61963: LD_ADDR_EXP 139
61967: PUSH
61968: LD_EXP 139
61972: PPUSH
61973: LD_VAR 0 5
61977: PPUSH
61978: LD_EXP 139
61982: PUSH
61983: LD_VAR 0 5
61987: ARRAY
61988: PPUSH
61989: LD_INT 1
61991: PPUSH
61992: LD_VAR 0 6
61996: PPUSH
61997: CALL_OW 2
62001: PPUSH
62002: CALL_OW 1
62006: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
62007: LD_VAR 0 5
62011: PPUSH
62012: LD_INT 112
62014: PPUSH
62015: CALL 39019 0 2
// end ; end ; end ;
62019: GO 61842
62021: POP
62022: POP
// end ;
62023: LD_VAR 0 3
62027: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
62028: LD_INT 0
62030: PPUSH
62031: PPUSH
62032: PPUSH
62033: PPUSH
62034: PPUSH
62035: PPUSH
62036: PPUSH
62037: PPUSH
// if not mc_bases or not skirmish then
62038: LD_EXP 110
62042: NOT
62043: PUSH
62044: LD_EXP 108
62048: NOT
62049: OR
62050: IFFALSE 62054
// exit ;
62052: GO 63425
// for i = 1 to mc_bases do
62054: LD_ADDR_VAR 0 3
62058: PUSH
62059: DOUBLE
62060: LD_INT 1
62062: DEC
62063: ST_TO_ADDR
62064: LD_EXP 110
62068: PUSH
62069: FOR_TO
62070: IFFALSE 63423
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
62072: LD_VAR 0 1
62076: PUSH
62077: LD_EXP 110
62081: PUSH
62082: LD_VAR 0 3
62086: ARRAY
62087: IN
62088: PUSH
62089: LD_VAR 0 1
62093: PUSH
62094: LD_EXP 117
62098: PUSH
62099: LD_VAR 0 3
62103: ARRAY
62104: IN
62105: OR
62106: PUSH
62107: LD_VAR 0 1
62111: PUSH
62112: LD_EXP 132
62116: PUSH
62117: LD_VAR 0 3
62121: ARRAY
62122: IN
62123: OR
62124: PUSH
62125: LD_VAR 0 1
62129: PUSH
62130: LD_EXP 129
62134: PUSH
62135: LD_VAR 0 3
62139: ARRAY
62140: IN
62141: OR
62142: PUSH
62143: LD_VAR 0 1
62147: PUSH
62148: LD_EXP 139
62152: PUSH
62153: LD_VAR 0 3
62157: ARRAY
62158: IN
62159: OR
62160: PUSH
62161: LD_VAR 0 1
62165: PUSH
62166: LD_EXP 140
62170: PUSH
62171: LD_VAR 0 3
62175: ARRAY
62176: IN
62177: OR
62178: IFFALSE 63421
// begin if un in mc_ape [ i ] then
62180: LD_VAR 0 1
62184: PUSH
62185: LD_EXP 139
62189: PUSH
62190: LD_VAR 0 3
62194: ARRAY
62195: IN
62196: IFFALSE 62235
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
62198: LD_ADDR_EXP 139
62202: PUSH
62203: LD_EXP 139
62207: PPUSH
62208: LD_VAR 0 3
62212: PPUSH
62213: LD_EXP 139
62217: PUSH
62218: LD_VAR 0 3
62222: ARRAY
62223: PUSH
62224: LD_VAR 0 1
62228: DIFF
62229: PPUSH
62230: CALL_OW 1
62234: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
62235: LD_VAR 0 1
62239: PUSH
62240: LD_EXP 140
62244: PUSH
62245: LD_VAR 0 3
62249: ARRAY
62250: IN
62251: IFFALSE 62275
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62253: LD_ADDR_EXP 140
62257: PUSH
62258: LD_EXP 140
62262: PPUSH
62263: LD_VAR 0 3
62267: PPUSH
62268: EMPTY
62269: PPUSH
62270: CALL_OW 1
62274: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
62275: LD_VAR 0 1
62279: PPUSH
62280: CALL_OW 247
62284: PUSH
62285: LD_INT 2
62287: EQUAL
62288: PUSH
62289: LD_VAR 0 1
62293: PPUSH
62294: CALL_OW 110
62298: PUSH
62299: LD_INT 20
62301: EQUAL
62302: PUSH
62303: LD_VAR 0 1
62307: PUSH
62308: LD_EXP 132
62312: PUSH
62313: LD_VAR 0 3
62317: ARRAY
62318: IN
62319: OR
62320: PUSH
62321: LD_VAR 0 1
62325: PPUSH
62326: CALL_OW 264
62330: PUSH
62331: LD_INT 12
62333: PUSH
62334: LD_INT 51
62336: PUSH
62337: LD_EXP 96
62341: PUSH
62342: LD_INT 32
62344: PUSH
62345: LD_INT 13
62347: PUSH
62348: LD_INT 52
62350: PUSH
62351: LD_INT 31
62353: PUSH
62354: EMPTY
62355: LIST
62356: LIST
62357: LIST
62358: LIST
62359: LIST
62360: LIST
62361: LIST
62362: IN
62363: OR
62364: AND
62365: IFFALSE 62673
// begin if un in mc_defender [ i ] then
62367: LD_VAR 0 1
62371: PUSH
62372: LD_EXP 132
62376: PUSH
62377: LD_VAR 0 3
62381: ARRAY
62382: IN
62383: IFFALSE 62422
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62385: LD_ADDR_EXP 132
62389: PUSH
62390: LD_EXP 132
62394: PPUSH
62395: LD_VAR 0 3
62399: PPUSH
62400: LD_EXP 132
62404: PUSH
62405: LD_VAR 0 3
62409: ARRAY
62410: PUSH
62411: LD_VAR 0 1
62415: DIFF
62416: PPUSH
62417: CALL_OW 1
62421: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
62422: LD_ADDR_VAR 0 8
62426: PUSH
62427: LD_VAR 0 3
62431: PPUSH
62432: LD_INT 3
62434: PPUSH
62435: CALL 59091 0 2
62439: ST_TO_ADDR
// if fac then
62440: LD_VAR 0 8
62444: IFFALSE 62673
// begin for j in fac do
62446: LD_ADDR_VAR 0 4
62450: PUSH
62451: LD_VAR 0 8
62455: PUSH
62456: FOR_IN
62457: IFFALSE 62671
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
62459: LD_ADDR_VAR 0 9
62463: PUSH
62464: LD_VAR 0 8
62468: PPUSH
62469: LD_VAR 0 1
62473: PPUSH
62474: CALL_OW 265
62478: PPUSH
62479: LD_VAR 0 1
62483: PPUSH
62484: CALL_OW 262
62488: PPUSH
62489: LD_VAR 0 1
62493: PPUSH
62494: CALL_OW 263
62498: PPUSH
62499: LD_VAR 0 1
62503: PPUSH
62504: CALL_OW 264
62508: PPUSH
62509: CALL 67458 0 5
62513: ST_TO_ADDR
// if components then
62514: LD_VAR 0 9
62518: IFFALSE 62669
// begin if GetWeapon ( un ) = ar_control_tower then
62520: LD_VAR 0 1
62524: PPUSH
62525: CALL_OW 264
62529: PUSH
62530: LD_INT 31
62532: EQUAL
62533: IFFALSE 62650
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
62535: LD_VAR 0 1
62539: PPUSH
62540: CALL_OW 311
62544: PPUSH
62545: LD_INT 0
62547: PPUSH
62548: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
62552: LD_ADDR_EXP 150
62556: PUSH
62557: LD_EXP 150
62561: PPUSH
62562: LD_VAR 0 3
62566: PPUSH
62567: LD_EXP 150
62571: PUSH
62572: LD_VAR 0 3
62576: ARRAY
62577: PUSH
62578: LD_VAR 0 1
62582: PPUSH
62583: CALL_OW 311
62587: DIFF
62588: PPUSH
62589: CALL_OW 1
62593: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
62594: LD_ADDR_VAR 0 7
62598: PUSH
62599: LD_EXP 131
62603: PUSH
62604: LD_VAR 0 3
62608: ARRAY
62609: PPUSH
62610: LD_INT 1
62612: PPUSH
62613: LD_VAR 0 9
62617: PPUSH
62618: CALL_OW 2
62622: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62623: LD_ADDR_EXP 131
62627: PUSH
62628: LD_EXP 131
62632: PPUSH
62633: LD_VAR 0 3
62637: PPUSH
62638: LD_VAR 0 7
62642: PPUSH
62643: CALL_OW 1
62647: ST_TO_ADDR
// end else
62648: GO 62667
// MC_InsertProduceList ( i , [ components ] ) ;
62650: LD_VAR 0 3
62654: PPUSH
62655: LD_VAR 0 9
62659: PUSH
62660: EMPTY
62661: LIST
62662: PPUSH
62663: CALL 58636 0 2
// break ;
62667: GO 62671
// end ; end ;
62669: GO 62456
62671: POP
62672: POP
// end ; end ; if GetType ( un ) = unit_building then
62673: LD_VAR 0 1
62677: PPUSH
62678: CALL_OW 247
62682: PUSH
62683: LD_INT 3
62685: EQUAL
62686: IFFALSE 63089
// begin btype := GetBType ( un ) ;
62688: LD_ADDR_VAR 0 5
62692: PUSH
62693: LD_VAR 0 1
62697: PPUSH
62698: CALL_OW 266
62702: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
62703: LD_VAR 0 5
62707: PUSH
62708: LD_INT 29
62710: PUSH
62711: LD_INT 30
62713: PUSH
62714: EMPTY
62715: LIST
62716: LIST
62717: IN
62718: IFFALSE 62791
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
62720: LD_VAR 0 1
62724: PPUSH
62725: CALL_OW 250
62729: PPUSH
62730: LD_VAR 0 1
62734: PPUSH
62735: CALL_OW 251
62739: PPUSH
62740: LD_VAR 0 1
62744: PPUSH
62745: CALL_OW 255
62749: PPUSH
62750: CALL_OW 440
62754: NOT
62755: IFFALSE 62791
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
62757: LD_VAR 0 1
62761: PPUSH
62762: CALL_OW 250
62766: PPUSH
62767: LD_VAR 0 1
62771: PPUSH
62772: CALL_OW 251
62776: PPUSH
62777: LD_VAR 0 1
62781: PPUSH
62782: CALL_OW 255
62786: PPUSH
62787: CALL_OW 441
// end ; if btype = b_warehouse then
62791: LD_VAR 0 5
62795: PUSH
62796: LD_INT 1
62798: EQUAL
62799: IFFALSE 62817
// begin btype := b_depot ;
62801: LD_ADDR_VAR 0 5
62805: PUSH
62806: LD_INT 0
62808: ST_TO_ADDR
// pos := 1 ;
62809: LD_ADDR_VAR 0 6
62813: PUSH
62814: LD_INT 1
62816: ST_TO_ADDR
// end ; if btype = b_factory then
62817: LD_VAR 0 5
62821: PUSH
62822: LD_INT 3
62824: EQUAL
62825: IFFALSE 62843
// begin btype := b_workshop ;
62827: LD_ADDR_VAR 0 5
62831: PUSH
62832: LD_INT 2
62834: ST_TO_ADDR
// pos := 1 ;
62835: LD_ADDR_VAR 0 6
62839: PUSH
62840: LD_INT 1
62842: ST_TO_ADDR
// end ; if btype = b_barracks then
62843: LD_VAR 0 5
62847: PUSH
62848: LD_INT 5
62850: EQUAL
62851: IFFALSE 62861
// btype := b_armoury ;
62853: LD_ADDR_VAR 0 5
62857: PUSH
62858: LD_INT 4
62860: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
62861: LD_VAR 0 5
62865: PUSH
62866: LD_INT 7
62868: PUSH
62869: LD_INT 8
62871: PUSH
62872: EMPTY
62873: LIST
62874: LIST
62875: IN
62876: IFFALSE 62886
// btype := b_lab ;
62878: LD_ADDR_VAR 0 5
62882: PUSH
62883: LD_INT 6
62885: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
62886: LD_ADDR_EXP 115
62890: PUSH
62891: LD_EXP 115
62895: PPUSH
62896: LD_VAR 0 3
62900: PUSH
62901: LD_EXP 115
62905: PUSH
62906: LD_VAR 0 3
62910: ARRAY
62911: PUSH
62912: LD_INT 1
62914: PLUS
62915: PUSH
62916: EMPTY
62917: LIST
62918: LIST
62919: PPUSH
62920: LD_VAR 0 5
62924: PUSH
62925: LD_VAR 0 1
62929: PPUSH
62930: CALL_OW 250
62934: PUSH
62935: LD_VAR 0 1
62939: PPUSH
62940: CALL_OW 251
62944: PUSH
62945: LD_VAR 0 1
62949: PPUSH
62950: CALL_OW 254
62954: PUSH
62955: EMPTY
62956: LIST
62957: LIST
62958: LIST
62959: LIST
62960: PPUSH
62961: CALL 69926 0 3
62965: ST_TO_ADDR
// if pos = 1 then
62966: LD_VAR 0 6
62970: PUSH
62971: LD_INT 1
62973: EQUAL
62974: IFFALSE 63089
// begin tmp := mc_build_list [ i ] ;
62976: LD_ADDR_VAR 0 7
62980: PUSH
62981: LD_EXP 115
62985: PUSH
62986: LD_VAR 0 3
62990: ARRAY
62991: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62992: LD_VAR 0 7
62996: PPUSH
62997: LD_INT 2
62999: PUSH
63000: LD_INT 30
63002: PUSH
63003: LD_INT 0
63005: PUSH
63006: EMPTY
63007: LIST
63008: LIST
63009: PUSH
63010: LD_INT 30
63012: PUSH
63013: LD_INT 1
63015: PUSH
63016: EMPTY
63017: LIST
63018: LIST
63019: PUSH
63020: EMPTY
63021: LIST
63022: LIST
63023: LIST
63024: PPUSH
63025: CALL_OW 72
63029: IFFALSE 63039
// pos := 2 ;
63031: LD_ADDR_VAR 0 6
63035: PUSH
63036: LD_INT 2
63038: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
63039: LD_ADDR_VAR 0 7
63043: PUSH
63044: LD_VAR 0 7
63048: PPUSH
63049: LD_VAR 0 6
63053: PPUSH
63054: LD_VAR 0 7
63058: PPUSH
63059: CALL 70252 0 3
63063: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
63064: LD_ADDR_EXP 115
63068: PUSH
63069: LD_EXP 115
63073: PPUSH
63074: LD_VAR 0 3
63078: PPUSH
63079: LD_VAR 0 7
63083: PPUSH
63084: CALL_OW 1
63088: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63089: LD_VAR 0 1
63093: PUSH
63094: LD_EXP 110
63098: PUSH
63099: LD_VAR 0 3
63103: ARRAY
63104: IN
63105: IFFALSE 63144
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
63107: LD_ADDR_EXP 110
63111: PUSH
63112: LD_EXP 110
63116: PPUSH
63117: LD_VAR 0 3
63121: PPUSH
63122: LD_EXP 110
63126: PUSH
63127: LD_VAR 0 3
63131: ARRAY
63132: PUSH
63133: LD_VAR 0 1
63137: DIFF
63138: PPUSH
63139: CALL_OW 1
63143: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
63144: LD_VAR 0 1
63148: PUSH
63149: LD_EXP 117
63153: PUSH
63154: LD_VAR 0 3
63158: ARRAY
63159: IN
63160: IFFALSE 63199
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
63162: LD_ADDR_EXP 117
63166: PUSH
63167: LD_EXP 117
63171: PPUSH
63172: LD_VAR 0 3
63176: PPUSH
63177: LD_EXP 117
63181: PUSH
63182: LD_VAR 0 3
63186: ARRAY
63187: PUSH
63188: LD_VAR 0 1
63192: DIFF
63193: PPUSH
63194: CALL_OW 1
63198: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
63199: LD_VAR 0 1
63203: PUSH
63204: LD_EXP 129
63208: PUSH
63209: LD_VAR 0 3
63213: ARRAY
63214: IN
63215: IFFALSE 63254
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
63217: LD_ADDR_EXP 129
63221: PUSH
63222: LD_EXP 129
63226: PPUSH
63227: LD_VAR 0 3
63231: PPUSH
63232: LD_EXP 129
63236: PUSH
63237: LD_VAR 0 3
63241: ARRAY
63242: PUSH
63243: LD_VAR 0 1
63247: DIFF
63248: PPUSH
63249: CALL_OW 1
63253: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
63254: LD_VAR 0 1
63258: PUSH
63259: LD_EXP 132
63263: PUSH
63264: LD_VAR 0 3
63268: ARRAY
63269: IN
63270: IFFALSE 63309
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63272: LD_ADDR_EXP 132
63276: PUSH
63277: LD_EXP 132
63281: PPUSH
63282: LD_VAR 0 3
63286: PPUSH
63287: LD_EXP 132
63291: PUSH
63292: LD_VAR 0 3
63296: ARRAY
63297: PUSH
63298: LD_VAR 0 1
63302: DIFF
63303: PPUSH
63304: CALL_OW 1
63308: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
63309: LD_VAR 0 1
63313: PUSH
63314: LD_EXP 119
63318: PUSH
63319: LD_VAR 0 3
63323: ARRAY
63324: IN
63325: IFFALSE 63364
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
63327: LD_ADDR_EXP 119
63331: PUSH
63332: LD_EXP 119
63336: PPUSH
63337: LD_VAR 0 3
63341: PPUSH
63342: LD_EXP 119
63346: PUSH
63347: LD_VAR 0 3
63351: ARRAY
63352: PUSH
63353: LD_VAR 0 1
63357: DIFF
63358: PPUSH
63359: CALL_OW 1
63363: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
63364: LD_VAR 0 1
63368: PUSH
63369: LD_EXP 118
63373: PUSH
63374: LD_VAR 0 3
63378: ARRAY
63379: IN
63380: IFFALSE 63419
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
63382: LD_ADDR_EXP 118
63386: PUSH
63387: LD_EXP 118
63391: PPUSH
63392: LD_VAR 0 3
63396: PPUSH
63397: LD_EXP 118
63401: PUSH
63402: LD_VAR 0 3
63406: ARRAY
63407: PUSH
63408: LD_VAR 0 1
63412: DIFF
63413: PPUSH
63414: CALL_OW 1
63418: ST_TO_ADDR
// end ; break ;
63419: GO 63423
// end ;
63421: GO 62069
63423: POP
63424: POP
// end ;
63425: LD_VAR 0 2
63429: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
63430: LD_INT 0
63432: PPUSH
63433: PPUSH
63434: PPUSH
// if not mc_bases or not skirmish then
63435: LD_EXP 110
63439: NOT
63440: PUSH
63441: LD_EXP 108
63445: NOT
63446: OR
63447: IFFALSE 63451
// exit ;
63449: GO 63666
// for i = 1 to mc_bases do
63451: LD_ADDR_VAR 0 3
63455: PUSH
63456: DOUBLE
63457: LD_INT 1
63459: DEC
63460: ST_TO_ADDR
63461: LD_EXP 110
63465: PUSH
63466: FOR_TO
63467: IFFALSE 63664
// begin if building in mc_construct_list [ i ] then
63469: LD_VAR 0 1
63473: PUSH
63474: LD_EXP 117
63478: PUSH
63479: LD_VAR 0 3
63483: ARRAY
63484: IN
63485: IFFALSE 63662
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63487: LD_ADDR_EXP 117
63491: PUSH
63492: LD_EXP 117
63496: PPUSH
63497: LD_VAR 0 3
63501: PPUSH
63502: LD_EXP 117
63506: PUSH
63507: LD_VAR 0 3
63511: ARRAY
63512: PUSH
63513: LD_VAR 0 1
63517: DIFF
63518: PPUSH
63519: CALL_OW 1
63523: ST_TO_ADDR
// if building in mc_lab [ i ] then
63524: LD_VAR 0 1
63528: PUSH
63529: LD_EXP 143
63533: PUSH
63534: LD_VAR 0 3
63538: ARRAY
63539: IN
63540: IFFALSE 63595
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
63542: LD_ADDR_EXP 144
63546: PUSH
63547: LD_EXP 144
63551: PPUSH
63552: LD_VAR 0 3
63556: PPUSH
63557: LD_EXP 144
63561: PUSH
63562: LD_VAR 0 3
63566: ARRAY
63567: PPUSH
63568: LD_INT 1
63570: PPUSH
63571: LD_EXP 144
63575: PUSH
63576: LD_VAR 0 3
63580: ARRAY
63581: PPUSH
63582: LD_INT 0
63584: PPUSH
63585: CALL 69344 0 4
63589: PPUSH
63590: CALL_OW 1
63594: ST_TO_ADDR
// if not building in mc_bases [ i ] then
63595: LD_VAR 0 1
63599: PUSH
63600: LD_EXP 110
63604: PUSH
63605: LD_VAR 0 3
63609: ARRAY
63610: IN
63611: NOT
63612: IFFALSE 63658
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63614: LD_ADDR_EXP 110
63618: PUSH
63619: LD_EXP 110
63623: PPUSH
63624: LD_VAR 0 3
63628: PUSH
63629: LD_EXP 110
63633: PUSH
63634: LD_VAR 0 3
63638: ARRAY
63639: PUSH
63640: LD_INT 1
63642: PLUS
63643: PUSH
63644: EMPTY
63645: LIST
63646: LIST
63647: PPUSH
63648: LD_VAR 0 1
63652: PPUSH
63653: CALL 69926 0 3
63657: ST_TO_ADDR
// exit ;
63658: POP
63659: POP
63660: GO 63666
// end ; end ;
63662: GO 63466
63664: POP
63665: POP
// end ;
63666: LD_VAR 0 2
63670: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
63671: LD_INT 0
63673: PPUSH
63674: PPUSH
63675: PPUSH
63676: PPUSH
63677: PPUSH
63678: PPUSH
63679: PPUSH
// if not mc_bases or not skirmish then
63680: LD_EXP 110
63684: NOT
63685: PUSH
63686: LD_EXP 108
63690: NOT
63691: OR
63692: IFFALSE 63696
// exit ;
63694: GO 64357
// for i = 1 to mc_bases do
63696: LD_ADDR_VAR 0 3
63700: PUSH
63701: DOUBLE
63702: LD_INT 1
63704: DEC
63705: ST_TO_ADDR
63706: LD_EXP 110
63710: PUSH
63711: FOR_TO
63712: IFFALSE 64355
// begin if building in mc_construct_list [ i ] then
63714: LD_VAR 0 1
63718: PUSH
63719: LD_EXP 117
63723: PUSH
63724: LD_VAR 0 3
63728: ARRAY
63729: IN
63730: IFFALSE 64353
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63732: LD_ADDR_EXP 117
63736: PUSH
63737: LD_EXP 117
63741: PPUSH
63742: LD_VAR 0 3
63746: PPUSH
63747: LD_EXP 117
63751: PUSH
63752: LD_VAR 0 3
63756: ARRAY
63757: PUSH
63758: LD_VAR 0 1
63762: DIFF
63763: PPUSH
63764: CALL_OW 1
63768: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63769: LD_ADDR_EXP 110
63773: PUSH
63774: LD_EXP 110
63778: PPUSH
63779: LD_VAR 0 3
63783: PUSH
63784: LD_EXP 110
63788: PUSH
63789: LD_VAR 0 3
63793: ARRAY
63794: PUSH
63795: LD_INT 1
63797: PLUS
63798: PUSH
63799: EMPTY
63800: LIST
63801: LIST
63802: PPUSH
63803: LD_VAR 0 1
63807: PPUSH
63808: CALL 69926 0 3
63812: ST_TO_ADDR
// btype := GetBType ( building ) ;
63813: LD_ADDR_VAR 0 5
63817: PUSH
63818: LD_VAR 0 1
63822: PPUSH
63823: CALL_OW 266
63827: ST_TO_ADDR
// side := GetSide ( building ) ;
63828: LD_ADDR_VAR 0 8
63832: PUSH
63833: LD_VAR 0 1
63837: PPUSH
63838: CALL_OW 255
63842: ST_TO_ADDR
// if btype = b_lab then
63843: LD_VAR 0 5
63847: PUSH
63848: LD_INT 6
63850: EQUAL
63851: IFFALSE 63901
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
63853: LD_ADDR_EXP 143
63857: PUSH
63858: LD_EXP 143
63862: PPUSH
63863: LD_VAR 0 3
63867: PUSH
63868: LD_EXP 143
63872: PUSH
63873: LD_VAR 0 3
63877: ARRAY
63878: PUSH
63879: LD_INT 1
63881: PLUS
63882: PUSH
63883: EMPTY
63884: LIST
63885: LIST
63886: PPUSH
63887: LD_VAR 0 1
63891: PPUSH
63892: CALL 69926 0 3
63896: ST_TO_ADDR
// exit ;
63897: POP
63898: POP
63899: GO 64357
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
63901: LD_VAR 0 5
63905: PUSH
63906: LD_INT 0
63908: PUSH
63909: LD_INT 2
63911: PUSH
63912: LD_INT 4
63914: PUSH
63915: EMPTY
63916: LIST
63917: LIST
63918: LIST
63919: IN
63920: IFFALSE 64044
// begin if btype = b_armoury then
63922: LD_VAR 0 5
63926: PUSH
63927: LD_INT 4
63929: EQUAL
63930: IFFALSE 63940
// btype := b_barracks ;
63932: LD_ADDR_VAR 0 5
63936: PUSH
63937: LD_INT 5
63939: ST_TO_ADDR
// if btype = b_depot then
63940: LD_VAR 0 5
63944: PUSH
63945: LD_INT 0
63947: EQUAL
63948: IFFALSE 63958
// btype := b_warehouse ;
63950: LD_ADDR_VAR 0 5
63954: PUSH
63955: LD_INT 1
63957: ST_TO_ADDR
// if btype = b_workshop then
63958: LD_VAR 0 5
63962: PUSH
63963: LD_INT 2
63965: EQUAL
63966: IFFALSE 63976
// btype := b_factory ;
63968: LD_ADDR_VAR 0 5
63972: PUSH
63973: LD_INT 3
63975: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
63976: LD_VAR 0 5
63980: PPUSH
63981: LD_VAR 0 8
63985: PPUSH
63986: CALL_OW 323
63990: PUSH
63991: LD_INT 1
63993: EQUAL
63994: IFFALSE 64040
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
63996: LD_ADDR_EXP 142
64000: PUSH
64001: LD_EXP 142
64005: PPUSH
64006: LD_VAR 0 3
64010: PUSH
64011: LD_EXP 142
64015: PUSH
64016: LD_VAR 0 3
64020: ARRAY
64021: PUSH
64022: LD_INT 1
64024: PLUS
64025: PUSH
64026: EMPTY
64027: LIST
64028: LIST
64029: PPUSH
64030: LD_VAR 0 1
64034: PPUSH
64035: CALL 69926 0 3
64039: ST_TO_ADDR
// exit ;
64040: POP
64041: POP
64042: GO 64357
// end ; if btype in [ b_bunker , b_turret ] then
64044: LD_VAR 0 5
64048: PUSH
64049: LD_INT 32
64051: PUSH
64052: LD_INT 33
64054: PUSH
64055: EMPTY
64056: LIST
64057: LIST
64058: IN
64059: IFFALSE 64349
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
64061: LD_ADDR_EXP 118
64065: PUSH
64066: LD_EXP 118
64070: PPUSH
64071: LD_VAR 0 3
64075: PUSH
64076: LD_EXP 118
64080: PUSH
64081: LD_VAR 0 3
64085: ARRAY
64086: PUSH
64087: LD_INT 1
64089: PLUS
64090: PUSH
64091: EMPTY
64092: LIST
64093: LIST
64094: PPUSH
64095: LD_VAR 0 1
64099: PPUSH
64100: CALL 69926 0 3
64104: ST_TO_ADDR
// if btype = b_bunker then
64105: LD_VAR 0 5
64109: PUSH
64110: LD_INT 32
64112: EQUAL
64113: IFFALSE 64349
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64115: LD_ADDR_EXP 119
64119: PUSH
64120: LD_EXP 119
64124: PPUSH
64125: LD_VAR 0 3
64129: PUSH
64130: LD_EXP 119
64134: PUSH
64135: LD_VAR 0 3
64139: ARRAY
64140: PUSH
64141: LD_INT 1
64143: PLUS
64144: PUSH
64145: EMPTY
64146: LIST
64147: LIST
64148: PPUSH
64149: LD_VAR 0 1
64153: PPUSH
64154: CALL 69926 0 3
64158: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
64159: LD_ADDR_VAR 0 6
64163: PUSH
64164: LD_EXP 110
64168: PUSH
64169: LD_VAR 0 3
64173: ARRAY
64174: PPUSH
64175: LD_INT 25
64177: PUSH
64178: LD_INT 1
64180: PUSH
64181: EMPTY
64182: LIST
64183: LIST
64184: PUSH
64185: LD_INT 3
64187: PUSH
64188: LD_INT 54
64190: PUSH
64191: EMPTY
64192: LIST
64193: PUSH
64194: EMPTY
64195: LIST
64196: LIST
64197: PUSH
64198: EMPTY
64199: LIST
64200: LIST
64201: PPUSH
64202: CALL_OW 72
64206: ST_TO_ADDR
// if tmp then
64207: LD_VAR 0 6
64211: IFFALSE 64217
// exit ;
64213: POP
64214: POP
64215: GO 64357
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64217: LD_ADDR_VAR 0 6
64221: PUSH
64222: LD_EXP 110
64226: PUSH
64227: LD_VAR 0 3
64231: ARRAY
64232: PPUSH
64233: LD_INT 2
64235: PUSH
64236: LD_INT 30
64238: PUSH
64239: LD_INT 4
64241: PUSH
64242: EMPTY
64243: LIST
64244: LIST
64245: PUSH
64246: LD_INT 30
64248: PUSH
64249: LD_INT 5
64251: PUSH
64252: EMPTY
64253: LIST
64254: LIST
64255: PUSH
64256: EMPTY
64257: LIST
64258: LIST
64259: LIST
64260: PPUSH
64261: CALL_OW 72
64265: ST_TO_ADDR
// if not tmp then
64266: LD_VAR 0 6
64270: NOT
64271: IFFALSE 64277
// exit ;
64273: POP
64274: POP
64275: GO 64357
// for j in tmp do
64277: LD_ADDR_VAR 0 4
64281: PUSH
64282: LD_VAR 0 6
64286: PUSH
64287: FOR_IN
64288: IFFALSE 64347
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
64290: LD_ADDR_VAR 0 7
64294: PUSH
64295: LD_VAR 0 4
64299: PPUSH
64300: CALL_OW 313
64304: PPUSH
64305: LD_INT 25
64307: PUSH
64308: LD_INT 1
64310: PUSH
64311: EMPTY
64312: LIST
64313: LIST
64314: PPUSH
64315: CALL_OW 72
64319: ST_TO_ADDR
// if units then
64320: LD_VAR 0 7
64324: IFFALSE 64345
// begin ComExitBuilding ( units [ 1 ] ) ;
64326: LD_VAR 0 7
64330: PUSH
64331: LD_INT 1
64333: ARRAY
64334: PPUSH
64335: CALL_OW 122
// exit ;
64339: POP
64340: POP
64341: POP
64342: POP
64343: GO 64357
// end ; end ;
64345: GO 64287
64347: POP
64348: POP
// end ; end ; exit ;
64349: POP
64350: POP
64351: GO 64357
// end ; end ;
64353: GO 63711
64355: POP
64356: POP
// end ;
64357: LD_VAR 0 2
64361: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
64362: LD_INT 0
64364: PPUSH
64365: PPUSH
64366: PPUSH
64367: PPUSH
64368: PPUSH
64369: PPUSH
64370: PPUSH
// if not mc_bases or not skirmish then
64371: LD_EXP 110
64375: NOT
64376: PUSH
64377: LD_EXP 108
64381: NOT
64382: OR
64383: IFFALSE 64387
// exit ;
64385: GO 64618
// btype := GetBType ( building ) ;
64387: LD_ADDR_VAR 0 6
64391: PUSH
64392: LD_VAR 0 1
64396: PPUSH
64397: CALL_OW 266
64401: ST_TO_ADDR
// x := GetX ( building ) ;
64402: LD_ADDR_VAR 0 7
64406: PUSH
64407: LD_VAR 0 1
64411: PPUSH
64412: CALL_OW 250
64416: ST_TO_ADDR
// y := GetY ( building ) ;
64417: LD_ADDR_VAR 0 8
64421: PUSH
64422: LD_VAR 0 1
64426: PPUSH
64427: CALL_OW 251
64431: ST_TO_ADDR
// d := GetDir ( building ) ;
64432: LD_ADDR_VAR 0 9
64436: PUSH
64437: LD_VAR 0 1
64441: PPUSH
64442: CALL_OW 254
64446: ST_TO_ADDR
// for i = 1 to mc_bases do
64447: LD_ADDR_VAR 0 4
64451: PUSH
64452: DOUBLE
64453: LD_INT 1
64455: DEC
64456: ST_TO_ADDR
64457: LD_EXP 110
64461: PUSH
64462: FOR_TO
64463: IFFALSE 64616
// begin if not mc_build_list [ i ] then
64465: LD_EXP 115
64469: PUSH
64470: LD_VAR 0 4
64474: ARRAY
64475: NOT
64476: IFFALSE 64480
// continue ;
64478: GO 64462
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
64480: LD_VAR 0 6
64484: PUSH
64485: LD_VAR 0 7
64489: PUSH
64490: LD_VAR 0 8
64494: PUSH
64495: LD_VAR 0 9
64499: PUSH
64500: EMPTY
64501: LIST
64502: LIST
64503: LIST
64504: LIST
64505: PPUSH
64506: LD_EXP 115
64510: PUSH
64511: LD_VAR 0 4
64515: ARRAY
64516: PUSH
64517: LD_INT 1
64519: ARRAY
64520: PPUSH
64521: CALL 76095 0 2
64525: IFFALSE 64614
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
64527: LD_ADDR_EXP 115
64531: PUSH
64532: LD_EXP 115
64536: PPUSH
64537: LD_VAR 0 4
64541: PPUSH
64542: LD_EXP 115
64546: PUSH
64547: LD_VAR 0 4
64551: ARRAY
64552: PPUSH
64553: LD_INT 1
64555: PPUSH
64556: CALL_OW 3
64560: PPUSH
64561: CALL_OW 1
64565: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
64566: LD_ADDR_EXP 117
64570: PUSH
64571: LD_EXP 117
64575: PPUSH
64576: LD_VAR 0 4
64580: PUSH
64581: LD_EXP 117
64585: PUSH
64586: LD_VAR 0 4
64590: ARRAY
64591: PUSH
64592: LD_INT 1
64594: PLUS
64595: PUSH
64596: EMPTY
64597: LIST
64598: LIST
64599: PPUSH
64600: LD_VAR 0 1
64604: PPUSH
64605: CALL 69926 0 3
64609: ST_TO_ADDR
// exit ;
64610: POP
64611: POP
64612: GO 64618
// end ; end ;
64614: GO 64462
64616: POP
64617: POP
// end ;
64618: LD_VAR 0 3
64622: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
64623: LD_INT 0
64625: PPUSH
64626: PPUSH
64627: PPUSH
// if not mc_bases or not skirmish then
64628: LD_EXP 110
64632: NOT
64633: PUSH
64634: LD_EXP 108
64638: NOT
64639: OR
64640: IFFALSE 64644
// exit ;
64642: GO 64834
// for i = 1 to mc_bases do
64644: LD_ADDR_VAR 0 4
64648: PUSH
64649: DOUBLE
64650: LD_INT 1
64652: DEC
64653: ST_TO_ADDR
64654: LD_EXP 110
64658: PUSH
64659: FOR_TO
64660: IFFALSE 64747
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
64662: LD_VAR 0 1
64666: PUSH
64667: LD_EXP 118
64671: PUSH
64672: LD_VAR 0 4
64676: ARRAY
64677: IN
64678: PUSH
64679: LD_VAR 0 1
64683: PUSH
64684: LD_EXP 119
64688: PUSH
64689: LD_VAR 0 4
64693: ARRAY
64694: IN
64695: NOT
64696: AND
64697: IFFALSE 64745
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64699: LD_ADDR_EXP 119
64703: PUSH
64704: LD_EXP 119
64708: PPUSH
64709: LD_VAR 0 4
64713: PUSH
64714: LD_EXP 119
64718: PUSH
64719: LD_VAR 0 4
64723: ARRAY
64724: PUSH
64725: LD_INT 1
64727: PLUS
64728: PUSH
64729: EMPTY
64730: LIST
64731: LIST
64732: PPUSH
64733: LD_VAR 0 1
64737: PPUSH
64738: CALL 69926 0 3
64742: ST_TO_ADDR
// break ;
64743: GO 64747
// end ; end ;
64745: GO 64659
64747: POP
64748: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
64749: LD_VAR 0 1
64753: PPUSH
64754: CALL_OW 257
64758: PUSH
64759: LD_EXP 136
64763: IN
64764: PUSH
64765: LD_VAR 0 1
64769: PPUSH
64770: CALL_OW 266
64774: PUSH
64775: LD_INT 5
64777: EQUAL
64778: AND
64779: PUSH
64780: LD_VAR 0 2
64784: PPUSH
64785: CALL_OW 110
64789: PUSH
64790: LD_INT 18
64792: NONEQUAL
64793: AND
64794: IFFALSE 64834
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
64796: LD_VAR 0 2
64800: PPUSH
64801: CALL_OW 257
64805: PUSH
64806: LD_INT 5
64808: PUSH
64809: LD_INT 8
64811: PUSH
64812: LD_INT 9
64814: PUSH
64815: EMPTY
64816: LIST
64817: LIST
64818: LIST
64819: IN
64820: IFFALSE 64834
// SetClass ( unit , 1 ) ;
64822: LD_VAR 0 2
64826: PPUSH
64827: LD_INT 1
64829: PPUSH
64830: CALL_OW 336
// end ;
64834: LD_VAR 0 3
64838: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
64839: LD_INT 0
64841: PPUSH
64842: PPUSH
// if not mc_bases or not skirmish then
64843: LD_EXP 110
64847: NOT
64848: PUSH
64849: LD_EXP 108
64853: NOT
64854: OR
64855: IFFALSE 64859
// exit ;
64857: GO 64975
// if GetLives ( abandoned_vehicle ) > 250 then
64859: LD_VAR 0 2
64863: PPUSH
64864: CALL_OW 256
64868: PUSH
64869: LD_INT 250
64871: GREATER
64872: IFFALSE 64876
// exit ;
64874: GO 64975
// for i = 1 to mc_bases do
64876: LD_ADDR_VAR 0 6
64880: PUSH
64881: DOUBLE
64882: LD_INT 1
64884: DEC
64885: ST_TO_ADDR
64886: LD_EXP 110
64890: PUSH
64891: FOR_TO
64892: IFFALSE 64973
// begin if driver in mc_bases [ i ] then
64894: LD_VAR 0 1
64898: PUSH
64899: LD_EXP 110
64903: PUSH
64904: LD_VAR 0 6
64908: ARRAY
64909: IN
64910: IFFALSE 64971
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
64912: LD_VAR 0 1
64916: PPUSH
64917: LD_EXP 110
64921: PUSH
64922: LD_VAR 0 6
64926: ARRAY
64927: PPUSH
64928: LD_INT 2
64930: PUSH
64931: LD_INT 30
64933: PUSH
64934: LD_INT 0
64936: PUSH
64937: EMPTY
64938: LIST
64939: LIST
64940: PUSH
64941: LD_INT 30
64943: PUSH
64944: LD_INT 1
64946: PUSH
64947: EMPTY
64948: LIST
64949: LIST
64950: PUSH
64951: EMPTY
64952: LIST
64953: LIST
64954: LIST
64955: PPUSH
64956: CALL_OW 72
64960: PUSH
64961: LD_INT 1
64963: ARRAY
64964: PPUSH
64965: CALL_OW 112
// break ;
64969: GO 64973
// end ; end ;
64971: GO 64891
64973: POP
64974: POP
// end ; end_of_file
64975: LD_VAR 0 5
64979: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
64980: LD_INT 0
64982: PPUSH
64983: PPUSH
// if exist_mode then
64984: LD_VAR 0 2
64988: IFFALSE 65013
// unit := CreateCharacter ( prefix & ident ) else
64990: LD_ADDR_VAR 0 5
64994: PUSH
64995: LD_VAR 0 3
64999: PUSH
65000: LD_VAR 0 1
65004: STR
65005: PPUSH
65006: CALL_OW 34
65010: ST_TO_ADDR
65011: GO 65028
// unit := NewCharacter ( ident ) ;
65013: LD_ADDR_VAR 0 5
65017: PUSH
65018: LD_VAR 0 1
65022: PPUSH
65023: CALL_OW 25
65027: ST_TO_ADDR
// result := unit ;
65028: LD_ADDR_VAR 0 4
65032: PUSH
65033: LD_VAR 0 5
65037: ST_TO_ADDR
// end ;
65038: LD_VAR 0 4
65042: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
65043: LD_INT 0
65045: PPUSH
65046: PPUSH
// if not side or not nation then
65047: LD_VAR 0 1
65051: NOT
65052: PUSH
65053: LD_VAR 0 2
65057: NOT
65058: OR
65059: IFFALSE 65063
// exit ;
65061: GO 65827
// case nation of nation_american :
65063: LD_VAR 0 2
65067: PUSH
65068: LD_INT 1
65070: DOUBLE
65071: EQUAL
65072: IFTRUE 65076
65074: GO 65290
65076: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
65077: LD_ADDR_VAR 0 4
65081: PUSH
65082: LD_INT 35
65084: PUSH
65085: LD_INT 45
65087: PUSH
65088: LD_INT 46
65090: PUSH
65091: LD_INT 47
65093: PUSH
65094: LD_INT 82
65096: PUSH
65097: LD_INT 83
65099: PUSH
65100: LD_INT 84
65102: PUSH
65103: LD_INT 85
65105: PUSH
65106: LD_INT 86
65108: PUSH
65109: LD_INT 1
65111: PUSH
65112: LD_INT 2
65114: PUSH
65115: LD_INT 6
65117: PUSH
65118: LD_INT 15
65120: PUSH
65121: LD_INT 16
65123: PUSH
65124: LD_INT 7
65126: PUSH
65127: LD_INT 12
65129: PUSH
65130: LD_INT 13
65132: PUSH
65133: LD_INT 10
65135: PUSH
65136: LD_INT 14
65138: PUSH
65139: LD_INT 20
65141: PUSH
65142: LD_INT 21
65144: PUSH
65145: LD_INT 22
65147: PUSH
65148: LD_INT 25
65150: PUSH
65151: LD_INT 32
65153: PUSH
65154: LD_INT 27
65156: PUSH
65157: LD_INT 36
65159: PUSH
65160: LD_INT 69
65162: PUSH
65163: LD_INT 39
65165: PUSH
65166: LD_INT 34
65168: PUSH
65169: LD_INT 40
65171: PUSH
65172: LD_INT 48
65174: PUSH
65175: LD_INT 49
65177: PUSH
65178: LD_INT 50
65180: PUSH
65181: LD_INT 51
65183: PUSH
65184: LD_INT 52
65186: PUSH
65187: LD_INT 53
65189: PUSH
65190: LD_INT 54
65192: PUSH
65193: LD_INT 55
65195: PUSH
65196: LD_INT 56
65198: PUSH
65199: LD_INT 57
65201: PUSH
65202: LD_INT 58
65204: PUSH
65205: LD_INT 59
65207: PUSH
65208: LD_INT 60
65210: PUSH
65211: LD_INT 61
65213: PUSH
65214: LD_INT 62
65216: PUSH
65217: LD_INT 80
65219: PUSH
65220: LD_INT 82
65222: PUSH
65223: LD_INT 83
65225: PUSH
65226: LD_INT 84
65228: PUSH
65229: LD_INT 85
65231: PUSH
65232: LD_INT 86
65234: PUSH
65235: EMPTY
65236: LIST
65237: LIST
65238: LIST
65239: LIST
65240: LIST
65241: LIST
65242: LIST
65243: LIST
65244: LIST
65245: LIST
65246: LIST
65247: LIST
65248: LIST
65249: LIST
65250: LIST
65251: LIST
65252: LIST
65253: LIST
65254: LIST
65255: LIST
65256: LIST
65257: LIST
65258: LIST
65259: LIST
65260: LIST
65261: LIST
65262: LIST
65263: LIST
65264: LIST
65265: LIST
65266: LIST
65267: LIST
65268: LIST
65269: LIST
65270: LIST
65271: LIST
65272: LIST
65273: LIST
65274: LIST
65275: LIST
65276: LIST
65277: LIST
65278: LIST
65279: LIST
65280: LIST
65281: LIST
65282: LIST
65283: LIST
65284: LIST
65285: LIST
65286: LIST
65287: ST_TO_ADDR
65288: GO 65751
65290: LD_INT 2
65292: DOUBLE
65293: EQUAL
65294: IFTRUE 65298
65296: GO 65520
65298: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
65299: LD_ADDR_VAR 0 4
65303: PUSH
65304: LD_INT 35
65306: PUSH
65307: LD_INT 45
65309: PUSH
65310: LD_INT 46
65312: PUSH
65313: LD_INT 47
65315: PUSH
65316: LD_INT 82
65318: PUSH
65319: LD_INT 83
65321: PUSH
65322: LD_INT 84
65324: PUSH
65325: LD_INT 85
65327: PUSH
65328: LD_INT 87
65330: PUSH
65331: LD_INT 70
65333: PUSH
65334: LD_INT 1
65336: PUSH
65337: LD_INT 11
65339: PUSH
65340: LD_INT 3
65342: PUSH
65343: LD_INT 4
65345: PUSH
65346: LD_INT 5
65348: PUSH
65349: LD_INT 6
65351: PUSH
65352: LD_INT 15
65354: PUSH
65355: LD_INT 18
65357: PUSH
65358: LD_INT 7
65360: PUSH
65361: LD_INT 17
65363: PUSH
65364: LD_INT 8
65366: PUSH
65367: LD_INT 20
65369: PUSH
65370: LD_INT 21
65372: PUSH
65373: LD_INT 22
65375: PUSH
65376: LD_INT 72
65378: PUSH
65379: LD_INT 26
65381: PUSH
65382: LD_INT 69
65384: PUSH
65385: LD_INT 39
65387: PUSH
65388: LD_INT 40
65390: PUSH
65391: LD_INT 41
65393: PUSH
65394: LD_INT 42
65396: PUSH
65397: LD_INT 43
65399: PUSH
65400: LD_INT 48
65402: PUSH
65403: LD_INT 49
65405: PUSH
65406: LD_INT 50
65408: PUSH
65409: LD_INT 51
65411: PUSH
65412: LD_INT 52
65414: PUSH
65415: LD_INT 53
65417: PUSH
65418: LD_INT 54
65420: PUSH
65421: LD_INT 55
65423: PUSH
65424: LD_INT 56
65426: PUSH
65427: LD_INT 60
65429: PUSH
65430: LD_INT 61
65432: PUSH
65433: LD_INT 62
65435: PUSH
65436: LD_INT 66
65438: PUSH
65439: LD_INT 67
65441: PUSH
65442: LD_INT 68
65444: PUSH
65445: LD_INT 81
65447: PUSH
65448: LD_INT 82
65450: PUSH
65451: LD_INT 83
65453: PUSH
65454: LD_INT 84
65456: PUSH
65457: LD_INT 85
65459: PUSH
65460: LD_INT 87
65462: PUSH
65463: EMPTY
65464: LIST
65465: LIST
65466: LIST
65467: LIST
65468: LIST
65469: LIST
65470: LIST
65471: LIST
65472: LIST
65473: LIST
65474: LIST
65475: LIST
65476: LIST
65477: LIST
65478: LIST
65479: LIST
65480: LIST
65481: LIST
65482: LIST
65483: LIST
65484: LIST
65485: LIST
65486: LIST
65487: LIST
65488: LIST
65489: LIST
65490: LIST
65491: LIST
65492: LIST
65493: LIST
65494: LIST
65495: LIST
65496: LIST
65497: LIST
65498: LIST
65499: LIST
65500: LIST
65501: LIST
65502: LIST
65503: LIST
65504: LIST
65505: LIST
65506: LIST
65507: LIST
65508: LIST
65509: LIST
65510: LIST
65511: LIST
65512: LIST
65513: LIST
65514: LIST
65515: LIST
65516: LIST
65517: ST_TO_ADDR
65518: GO 65751
65520: LD_INT 3
65522: DOUBLE
65523: EQUAL
65524: IFTRUE 65528
65526: GO 65750
65528: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
65529: LD_ADDR_VAR 0 4
65533: PUSH
65534: LD_INT 46
65536: PUSH
65537: LD_INT 47
65539: PUSH
65540: LD_INT 1
65542: PUSH
65543: LD_INT 2
65545: PUSH
65546: LD_INT 82
65548: PUSH
65549: LD_INT 83
65551: PUSH
65552: LD_INT 84
65554: PUSH
65555: LD_INT 85
65557: PUSH
65558: LD_INT 86
65560: PUSH
65561: LD_INT 11
65563: PUSH
65564: LD_INT 9
65566: PUSH
65567: LD_INT 20
65569: PUSH
65570: LD_INT 19
65572: PUSH
65573: LD_INT 21
65575: PUSH
65576: LD_INT 24
65578: PUSH
65579: LD_INT 22
65581: PUSH
65582: LD_INT 25
65584: PUSH
65585: LD_INT 28
65587: PUSH
65588: LD_INT 29
65590: PUSH
65591: LD_INT 30
65593: PUSH
65594: LD_INT 31
65596: PUSH
65597: LD_INT 37
65599: PUSH
65600: LD_INT 38
65602: PUSH
65603: LD_INT 32
65605: PUSH
65606: LD_INT 27
65608: PUSH
65609: LD_INT 33
65611: PUSH
65612: LD_INT 69
65614: PUSH
65615: LD_INT 39
65617: PUSH
65618: LD_INT 34
65620: PUSH
65621: LD_INT 40
65623: PUSH
65624: LD_INT 71
65626: PUSH
65627: LD_INT 23
65629: PUSH
65630: LD_INT 44
65632: PUSH
65633: LD_INT 48
65635: PUSH
65636: LD_INT 49
65638: PUSH
65639: LD_INT 50
65641: PUSH
65642: LD_INT 51
65644: PUSH
65645: LD_INT 52
65647: PUSH
65648: LD_INT 53
65650: PUSH
65651: LD_INT 54
65653: PUSH
65654: LD_INT 55
65656: PUSH
65657: LD_INT 56
65659: PUSH
65660: LD_INT 57
65662: PUSH
65663: LD_INT 58
65665: PUSH
65666: LD_INT 59
65668: PUSH
65669: LD_INT 63
65671: PUSH
65672: LD_INT 64
65674: PUSH
65675: LD_INT 65
65677: PUSH
65678: LD_INT 82
65680: PUSH
65681: LD_INT 83
65683: PUSH
65684: LD_INT 84
65686: PUSH
65687: LD_INT 85
65689: PUSH
65690: LD_INT 86
65692: PUSH
65693: EMPTY
65694: LIST
65695: LIST
65696: LIST
65697: LIST
65698: LIST
65699: LIST
65700: LIST
65701: LIST
65702: LIST
65703: LIST
65704: LIST
65705: LIST
65706: LIST
65707: LIST
65708: LIST
65709: LIST
65710: LIST
65711: LIST
65712: LIST
65713: LIST
65714: LIST
65715: LIST
65716: LIST
65717: LIST
65718: LIST
65719: LIST
65720: LIST
65721: LIST
65722: LIST
65723: LIST
65724: LIST
65725: LIST
65726: LIST
65727: LIST
65728: LIST
65729: LIST
65730: LIST
65731: LIST
65732: LIST
65733: LIST
65734: LIST
65735: LIST
65736: LIST
65737: LIST
65738: LIST
65739: LIST
65740: LIST
65741: LIST
65742: LIST
65743: LIST
65744: LIST
65745: LIST
65746: LIST
65747: ST_TO_ADDR
65748: GO 65751
65750: POP
// if state > - 1 and state < 3 then
65751: LD_VAR 0 3
65755: PUSH
65756: LD_INT 1
65758: NEG
65759: GREATER
65760: PUSH
65761: LD_VAR 0 3
65765: PUSH
65766: LD_INT 3
65768: LESS
65769: AND
65770: IFFALSE 65827
// for i in result do
65772: LD_ADDR_VAR 0 5
65776: PUSH
65777: LD_VAR 0 4
65781: PUSH
65782: FOR_IN
65783: IFFALSE 65825
// if GetTech ( i , side ) <> state then
65785: LD_VAR 0 5
65789: PPUSH
65790: LD_VAR 0 1
65794: PPUSH
65795: CALL_OW 321
65799: PUSH
65800: LD_VAR 0 3
65804: NONEQUAL
65805: IFFALSE 65823
// result := result diff i ;
65807: LD_ADDR_VAR 0 4
65811: PUSH
65812: LD_VAR 0 4
65816: PUSH
65817: LD_VAR 0 5
65821: DIFF
65822: ST_TO_ADDR
65823: GO 65782
65825: POP
65826: POP
// end ;
65827: LD_VAR 0 4
65831: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
65832: LD_INT 0
65834: PPUSH
65835: PPUSH
65836: PPUSH
// result := true ;
65837: LD_ADDR_VAR 0 3
65841: PUSH
65842: LD_INT 1
65844: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
65845: LD_ADDR_VAR 0 5
65849: PUSH
65850: LD_VAR 0 2
65854: PPUSH
65855: CALL_OW 480
65859: ST_TO_ADDR
// if not tmp then
65860: LD_VAR 0 5
65864: NOT
65865: IFFALSE 65869
// exit ;
65867: GO 65918
// for i in tmp do
65869: LD_ADDR_VAR 0 4
65873: PUSH
65874: LD_VAR 0 5
65878: PUSH
65879: FOR_IN
65880: IFFALSE 65916
// if GetTech ( i , side ) <> state_researched then
65882: LD_VAR 0 4
65886: PPUSH
65887: LD_VAR 0 1
65891: PPUSH
65892: CALL_OW 321
65896: PUSH
65897: LD_INT 2
65899: NONEQUAL
65900: IFFALSE 65914
// begin result := false ;
65902: LD_ADDR_VAR 0 3
65906: PUSH
65907: LD_INT 0
65909: ST_TO_ADDR
// exit ;
65910: POP
65911: POP
65912: GO 65918
// end ;
65914: GO 65879
65916: POP
65917: POP
// end ;
65918: LD_VAR 0 3
65922: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
65923: LD_INT 0
65925: PPUSH
65926: PPUSH
65927: PPUSH
65928: PPUSH
65929: PPUSH
65930: PPUSH
65931: PPUSH
65932: PPUSH
65933: PPUSH
65934: PPUSH
65935: PPUSH
65936: PPUSH
65937: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
65938: LD_VAR 0 1
65942: NOT
65943: PUSH
65944: LD_VAR 0 1
65948: PPUSH
65949: CALL_OW 257
65953: PUSH
65954: LD_INT 9
65956: NONEQUAL
65957: OR
65958: IFFALSE 65962
// exit ;
65960: GO 66535
// side := GetSide ( unit ) ;
65962: LD_ADDR_VAR 0 9
65966: PUSH
65967: LD_VAR 0 1
65971: PPUSH
65972: CALL_OW 255
65976: ST_TO_ADDR
// tech_space := tech_spacanom ;
65977: LD_ADDR_VAR 0 12
65981: PUSH
65982: LD_INT 29
65984: ST_TO_ADDR
// tech_time := tech_taurad ;
65985: LD_ADDR_VAR 0 13
65989: PUSH
65990: LD_INT 28
65992: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
65993: LD_ADDR_VAR 0 11
65997: PUSH
65998: LD_VAR 0 1
66002: PPUSH
66003: CALL_OW 310
66007: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
66008: LD_VAR 0 11
66012: PPUSH
66013: CALL_OW 247
66017: PUSH
66018: LD_INT 2
66020: EQUAL
66021: IFFALSE 66025
// exit ;
66023: GO 66535
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66025: LD_ADDR_VAR 0 8
66029: PUSH
66030: LD_INT 81
66032: PUSH
66033: LD_VAR 0 9
66037: PUSH
66038: EMPTY
66039: LIST
66040: LIST
66041: PUSH
66042: LD_INT 3
66044: PUSH
66045: LD_INT 21
66047: PUSH
66048: LD_INT 3
66050: PUSH
66051: EMPTY
66052: LIST
66053: LIST
66054: PUSH
66055: EMPTY
66056: LIST
66057: LIST
66058: PUSH
66059: EMPTY
66060: LIST
66061: LIST
66062: PPUSH
66063: CALL_OW 69
66067: ST_TO_ADDR
// if not tmp then
66068: LD_VAR 0 8
66072: NOT
66073: IFFALSE 66077
// exit ;
66075: GO 66535
// if in_unit then
66077: LD_VAR 0 11
66081: IFFALSE 66105
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
66083: LD_ADDR_VAR 0 10
66087: PUSH
66088: LD_VAR 0 8
66092: PPUSH
66093: LD_VAR 0 11
66097: PPUSH
66098: CALL_OW 74
66102: ST_TO_ADDR
66103: GO 66125
// enemy := NearestUnitToUnit ( tmp , unit ) ;
66105: LD_ADDR_VAR 0 10
66109: PUSH
66110: LD_VAR 0 8
66114: PPUSH
66115: LD_VAR 0 1
66119: PPUSH
66120: CALL_OW 74
66124: ST_TO_ADDR
// if not enemy then
66125: LD_VAR 0 10
66129: NOT
66130: IFFALSE 66134
// exit ;
66132: GO 66535
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
66134: LD_VAR 0 11
66138: PUSH
66139: LD_VAR 0 11
66143: PPUSH
66144: LD_VAR 0 10
66148: PPUSH
66149: CALL_OW 296
66153: PUSH
66154: LD_INT 13
66156: GREATER
66157: AND
66158: PUSH
66159: LD_VAR 0 1
66163: PPUSH
66164: LD_VAR 0 10
66168: PPUSH
66169: CALL_OW 296
66173: PUSH
66174: LD_INT 12
66176: GREATER
66177: OR
66178: IFFALSE 66182
// exit ;
66180: GO 66535
// missile := [ 1 ] ;
66182: LD_ADDR_VAR 0 14
66186: PUSH
66187: LD_INT 1
66189: PUSH
66190: EMPTY
66191: LIST
66192: ST_TO_ADDR
// if Researched ( side , tech_space ) then
66193: LD_VAR 0 9
66197: PPUSH
66198: LD_VAR 0 12
66202: PPUSH
66203: CALL_OW 325
66207: IFFALSE 66236
// missile := Insert ( missile , missile + 1 , 2 ) ;
66209: LD_ADDR_VAR 0 14
66213: PUSH
66214: LD_VAR 0 14
66218: PPUSH
66219: LD_VAR 0 14
66223: PUSH
66224: LD_INT 1
66226: PLUS
66227: PPUSH
66228: LD_INT 2
66230: PPUSH
66231: CALL_OW 2
66235: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
66236: LD_VAR 0 9
66240: PPUSH
66241: LD_VAR 0 13
66245: PPUSH
66246: CALL_OW 325
66250: PUSH
66251: LD_VAR 0 10
66255: PPUSH
66256: CALL_OW 255
66260: PPUSH
66261: LD_VAR 0 13
66265: PPUSH
66266: CALL_OW 325
66270: NOT
66271: AND
66272: IFFALSE 66301
// missile := Insert ( missile , missile + 1 , 3 ) ;
66274: LD_ADDR_VAR 0 14
66278: PUSH
66279: LD_VAR 0 14
66283: PPUSH
66284: LD_VAR 0 14
66288: PUSH
66289: LD_INT 1
66291: PLUS
66292: PPUSH
66293: LD_INT 3
66295: PPUSH
66296: CALL_OW 2
66300: ST_TO_ADDR
// if missile < 2 then
66301: LD_VAR 0 14
66305: PUSH
66306: LD_INT 2
66308: LESS
66309: IFFALSE 66313
// exit ;
66311: GO 66535
// x := GetX ( enemy ) ;
66313: LD_ADDR_VAR 0 4
66317: PUSH
66318: LD_VAR 0 10
66322: PPUSH
66323: CALL_OW 250
66327: ST_TO_ADDR
// y := GetY ( enemy ) ;
66328: LD_ADDR_VAR 0 5
66332: PUSH
66333: LD_VAR 0 10
66337: PPUSH
66338: CALL_OW 251
66342: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
66343: LD_ADDR_VAR 0 6
66347: PUSH
66348: LD_VAR 0 4
66352: PUSH
66353: LD_INT 1
66355: NEG
66356: PPUSH
66357: LD_INT 1
66359: PPUSH
66360: CALL_OW 12
66364: PLUS
66365: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
66366: LD_ADDR_VAR 0 7
66370: PUSH
66371: LD_VAR 0 5
66375: PUSH
66376: LD_INT 1
66378: NEG
66379: PPUSH
66380: LD_INT 1
66382: PPUSH
66383: CALL_OW 12
66387: PLUS
66388: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66389: LD_VAR 0 6
66393: PPUSH
66394: LD_VAR 0 7
66398: PPUSH
66399: CALL_OW 488
66403: NOT
66404: IFFALSE 66426
// begin _x := x ;
66406: LD_ADDR_VAR 0 6
66410: PUSH
66411: LD_VAR 0 4
66415: ST_TO_ADDR
// _y := y ;
66416: LD_ADDR_VAR 0 7
66420: PUSH
66421: LD_VAR 0 5
66425: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
66426: LD_ADDR_VAR 0 3
66430: PUSH
66431: LD_INT 1
66433: PPUSH
66434: LD_VAR 0 14
66438: PPUSH
66439: CALL_OW 12
66443: ST_TO_ADDR
// case i of 1 :
66444: LD_VAR 0 3
66448: PUSH
66449: LD_INT 1
66451: DOUBLE
66452: EQUAL
66453: IFTRUE 66457
66455: GO 66474
66457: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
66458: LD_VAR 0 1
66462: PPUSH
66463: LD_VAR 0 10
66467: PPUSH
66468: CALL_OW 115
66472: GO 66535
66474: LD_INT 2
66476: DOUBLE
66477: EQUAL
66478: IFTRUE 66482
66480: GO 66504
66482: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
66483: LD_VAR 0 1
66487: PPUSH
66488: LD_VAR 0 6
66492: PPUSH
66493: LD_VAR 0 7
66497: PPUSH
66498: CALL_OW 153
66502: GO 66535
66504: LD_INT 3
66506: DOUBLE
66507: EQUAL
66508: IFTRUE 66512
66510: GO 66534
66512: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
66513: LD_VAR 0 1
66517: PPUSH
66518: LD_VAR 0 6
66522: PPUSH
66523: LD_VAR 0 7
66527: PPUSH
66528: CALL_OW 154
66532: GO 66535
66534: POP
// end ;
66535: LD_VAR 0 2
66539: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
66540: LD_INT 0
66542: PPUSH
66543: PPUSH
66544: PPUSH
66545: PPUSH
66546: PPUSH
66547: PPUSH
// if not unit or not building then
66548: LD_VAR 0 1
66552: NOT
66553: PUSH
66554: LD_VAR 0 2
66558: NOT
66559: OR
66560: IFFALSE 66564
// exit ;
66562: GO 66722
// x := GetX ( building ) ;
66564: LD_ADDR_VAR 0 5
66568: PUSH
66569: LD_VAR 0 2
66573: PPUSH
66574: CALL_OW 250
66578: ST_TO_ADDR
// y := GetY ( building ) ;
66579: LD_ADDR_VAR 0 6
66583: PUSH
66584: LD_VAR 0 2
66588: PPUSH
66589: CALL_OW 251
66593: ST_TO_ADDR
// for i = 0 to 5 do
66594: LD_ADDR_VAR 0 4
66598: PUSH
66599: DOUBLE
66600: LD_INT 0
66602: DEC
66603: ST_TO_ADDR
66604: LD_INT 5
66606: PUSH
66607: FOR_TO
66608: IFFALSE 66720
// begin _x := ShiftX ( x , i , 3 ) ;
66610: LD_ADDR_VAR 0 7
66614: PUSH
66615: LD_VAR 0 5
66619: PPUSH
66620: LD_VAR 0 4
66624: PPUSH
66625: LD_INT 3
66627: PPUSH
66628: CALL_OW 272
66632: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
66633: LD_ADDR_VAR 0 8
66637: PUSH
66638: LD_VAR 0 6
66642: PPUSH
66643: LD_VAR 0 4
66647: PPUSH
66648: LD_INT 3
66650: PPUSH
66651: CALL_OW 273
66655: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66656: LD_VAR 0 7
66660: PPUSH
66661: LD_VAR 0 8
66665: PPUSH
66666: CALL_OW 488
66670: NOT
66671: IFFALSE 66675
// continue ;
66673: GO 66607
// if HexInfo ( _x , _y ) = 0 then
66675: LD_VAR 0 7
66679: PPUSH
66680: LD_VAR 0 8
66684: PPUSH
66685: CALL_OW 428
66689: PUSH
66690: LD_INT 0
66692: EQUAL
66693: IFFALSE 66718
// begin ComMoveXY ( unit , _x , _y ) ;
66695: LD_VAR 0 1
66699: PPUSH
66700: LD_VAR 0 7
66704: PPUSH
66705: LD_VAR 0 8
66709: PPUSH
66710: CALL_OW 111
// exit ;
66714: POP
66715: POP
66716: GO 66722
// end ; end ;
66718: GO 66607
66720: POP
66721: POP
// end ;
66722: LD_VAR 0 3
66726: RET
// export function ScanBase ( side , base_area ) ; begin
66727: LD_INT 0
66729: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
66730: LD_ADDR_VAR 0 3
66734: PUSH
66735: LD_VAR 0 2
66739: PPUSH
66740: LD_INT 81
66742: PUSH
66743: LD_VAR 0 1
66747: PUSH
66748: EMPTY
66749: LIST
66750: LIST
66751: PPUSH
66752: CALL_OW 70
66756: ST_TO_ADDR
// end ;
66757: LD_VAR 0 3
66761: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
66762: LD_INT 0
66764: PPUSH
66765: PPUSH
66766: PPUSH
66767: PPUSH
// result := false ;
66768: LD_ADDR_VAR 0 2
66772: PUSH
66773: LD_INT 0
66775: ST_TO_ADDR
// side := GetSide ( unit ) ;
66776: LD_ADDR_VAR 0 3
66780: PUSH
66781: LD_VAR 0 1
66785: PPUSH
66786: CALL_OW 255
66790: ST_TO_ADDR
// nat := GetNation ( unit ) ;
66791: LD_ADDR_VAR 0 4
66795: PUSH
66796: LD_VAR 0 1
66800: PPUSH
66801: CALL_OW 248
66805: ST_TO_ADDR
// case nat of 1 :
66806: LD_VAR 0 4
66810: PUSH
66811: LD_INT 1
66813: DOUBLE
66814: EQUAL
66815: IFTRUE 66819
66817: GO 66830
66819: POP
// tech := tech_lassight ; 2 :
66820: LD_ADDR_VAR 0 5
66824: PUSH
66825: LD_INT 12
66827: ST_TO_ADDR
66828: GO 66869
66830: LD_INT 2
66832: DOUBLE
66833: EQUAL
66834: IFTRUE 66838
66836: GO 66849
66838: POP
// tech := tech_mortar ; 3 :
66839: LD_ADDR_VAR 0 5
66843: PUSH
66844: LD_INT 41
66846: ST_TO_ADDR
66847: GO 66869
66849: LD_INT 3
66851: DOUBLE
66852: EQUAL
66853: IFTRUE 66857
66855: GO 66868
66857: POP
// tech := tech_bazooka ; end ;
66858: LD_ADDR_VAR 0 5
66862: PUSH
66863: LD_INT 44
66865: ST_TO_ADDR
66866: GO 66869
66868: POP
// if Researched ( side , tech ) then
66869: LD_VAR 0 3
66873: PPUSH
66874: LD_VAR 0 5
66878: PPUSH
66879: CALL_OW 325
66883: IFFALSE 66910
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
66885: LD_ADDR_VAR 0 2
66889: PUSH
66890: LD_INT 5
66892: PUSH
66893: LD_INT 8
66895: PUSH
66896: LD_INT 9
66898: PUSH
66899: EMPTY
66900: LIST
66901: LIST
66902: LIST
66903: PUSH
66904: LD_VAR 0 4
66908: ARRAY
66909: ST_TO_ADDR
// end ;
66910: LD_VAR 0 2
66914: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
66915: LD_INT 0
66917: PPUSH
66918: PPUSH
66919: PPUSH
// if not mines then
66920: LD_VAR 0 2
66924: NOT
66925: IFFALSE 66929
// exit ;
66927: GO 67073
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66929: LD_ADDR_VAR 0 5
66933: PUSH
66934: LD_INT 81
66936: PUSH
66937: LD_VAR 0 1
66941: PUSH
66942: EMPTY
66943: LIST
66944: LIST
66945: PUSH
66946: LD_INT 3
66948: PUSH
66949: LD_INT 21
66951: PUSH
66952: LD_INT 3
66954: PUSH
66955: EMPTY
66956: LIST
66957: LIST
66958: PUSH
66959: EMPTY
66960: LIST
66961: LIST
66962: PUSH
66963: EMPTY
66964: LIST
66965: LIST
66966: PPUSH
66967: CALL_OW 69
66971: ST_TO_ADDR
// for i in mines do
66972: LD_ADDR_VAR 0 4
66976: PUSH
66977: LD_VAR 0 2
66981: PUSH
66982: FOR_IN
66983: IFFALSE 67071
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
66985: LD_VAR 0 4
66989: PUSH
66990: LD_INT 1
66992: ARRAY
66993: PPUSH
66994: LD_VAR 0 4
66998: PUSH
66999: LD_INT 2
67001: ARRAY
67002: PPUSH
67003: CALL_OW 458
67007: NOT
67008: IFFALSE 67012
// continue ;
67010: GO 66982
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
67012: LD_VAR 0 4
67016: PUSH
67017: LD_INT 1
67019: ARRAY
67020: PPUSH
67021: LD_VAR 0 4
67025: PUSH
67026: LD_INT 2
67028: ARRAY
67029: PPUSH
67030: CALL_OW 428
67034: PUSH
67035: LD_VAR 0 5
67039: IN
67040: IFFALSE 67069
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
67042: LD_VAR 0 4
67046: PUSH
67047: LD_INT 1
67049: ARRAY
67050: PPUSH
67051: LD_VAR 0 4
67055: PUSH
67056: LD_INT 2
67058: ARRAY
67059: PPUSH
67060: LD_VAR 0 1
67064: PPUSH
67065: CALL_OW 456
// end ;
67069: GO 66982
67071: POP
67072: POP
// end ;
67073: LD_VAR 0 3
67077: RET
// export function Count ( array ) ; var i ; begin
67078: LD_INT 0
67080: PPUSH
67081: PPUSH
// result := 0 ;
67082: LD_ADDR_VAR 0 2
67086: PUSH
67087: LD_INT 0
67089: ST_TO_ADDR
// for i in array do
67090: LD_ADDR_VAR 0 3
67094: PUSH
67095: LD_VAR 0 1
67099: PUSH
67100: FOR_IN
67101: IFFALSE 67125
// if i then
67103: LD_VAR 0 3
67107: IFFALSE 67123
// result := result + 1 ;
67109: LD_ADDR_VAR 0 2
67113: PUSH
67114: LD_VAR 0 2
67118: PUSH
67119: LD_INT 1
67121: PLUS
67122: ST_TO_ADDR
67123: GO 67100
67125: POP
67126: POP
// end ;
67127: LD_VAR 0 2
67131: RET
// export function IsEmpty ( building ) ; begin
67132: LD_INT 0
67134: PPUSH
// if not building then
67135: LD_VAR 0 1
67139: NOT
67140: IFFALSE 67144
// exit ;
67142: GO 67187
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
67144: LD_ADDR_VAR 0 2
67148: PUSH
67149: LD_VAR 0 1
67153: PUSH
67154: LD_INT 22
67156: PUSH
67157: LD_VAR 0 1
67161: PPUSH
67162: CALL_OW 255
67166: PUSH
67167: EMPTY
67168: LIST
67169: LIST
67170: PUSH
67171: LD_INT 58
67173: PUSH
67174: EMPTY
67175: LIST
67176: PUSH
67177: EMPTY
67178: LIST
67179: LIST
67180: PPUSH
67181: CALL_OW 69
67185: IN
67186: ST_TO_ADDR
// end ;
67187: LD_VAR 0 2
67191: RET
// export function IsNotFull ( building ) ; begin
67192: LD_INT 0
67194: PPUSH
// if not building then
67195: LD_VAR 0 1
67199: NOT
67200: IFFALSE 67204
// exit ;
67202: GO 67223
// result := UnitsInside ( building ) < 6 ;
67204: LD_ADDR_VAR 0 2
67208: PUSH
67209: LD_VAR 0 1
67213: PPUSH
67214: CALL_OW 313
67218: PUSH
67219: LD_INT 6
67221: LESS
67222: ST_TO_ADDR
// end ;
67223: LD_VAR 0 2
67227: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
67228: LD_INT 0
67230: PPUSH
67231: PPUSH
67232: PPUSH
67233: PPUSH
// tmp := [ ] ;
67234: LD_ADDR_VAR 0 3
67238: PUSH
67239: EMPTY
67240: ST_TO_ADDR
// list := [ ] ;
67241: LD_ADDR_VAR 0 5
67245: PUSH
67246: EMPTY
67247: ST_TO_ADDR
// for i = 16 to 25 do
67248: LD_ADDR_VAR 0 4
67252: PUSH
67253: DOUBLE
67254: LD_INT 16
67256: DEC
67257: ST_TO_ADDR
67258: LD_INT 25
67260: PUSH
67261: FOR_TO
67262: IFFALSE 67335
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
67264: LD_ADDR_VAR 0 3
67268: PUSH
67269: LD_VAR 0 3
67273: PUSH
67274: LD_INT 22
67276: PUSH
67277: LD_VAR 0 1
67281: PPUSH
67282: CALL_OW 255
67286: PUSH
67287: EMPTY
67288: LIST
67289: LIST
67290: PUSH
67291: LD_INT 91
67293: PUSH
67294: LD_VAR 0 1
67298: PUSH
67299: LD_INT 6
67301: PUSH
67302: EMPTY
67303: LIST
67304: LIST
67305: LIST
67306: PUSH
67307: LD_INT 30
67309: PUSH
67310: LD_VAR 0 4
67314: PUSH
67315: EMPTY
67316: LIST
67317: LIST
67318: PUSH
67319: EMPTY
67320: LIST
67321: LIST
67322: LIST
67323: PUSH
67324: EMPTY
67325: LIST
67326: PPUSH
67327: CALL_OW 69
67331: ADD
67332: ST_TO_ADDR
67333: GO 67261
67335: POP
67336: POP
// for i = 1 to tmp do
67337: LD_ADDR_VAR 0 4
67341: PUSH
67342: DOUBLE
67343: LD_INT 1
67345: DEC
67346: ST_TO_ADDR
67347: LD_VAR 0 3
67351: PUSH
67352: FOR_TO
67353: IFFALSE 67441
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
67355: LD_ADDR_VAR 0 5
67359: PUSH
67360: LD_VAR 0 5
67364: PUSH
67365: LD_VAR 0 3
67369: PUSH
67370: LD_VAR 0 4
67374: ARRAY
67375: PPUSH
67376: CALL_OW 266
67380: PUSH
67381: LD_VAR 0 3
67385: PUSH
67386: LD_VAR 0 4
67390: ARRAY
67391: PPUSH
67392: CALL_OW 250
67396: PUSH
67397: LD_VAR 0 3
67401: PUSH
67402: LD_VAR 0 4
67406: ARRAY
67407: PPUSH
67408: CALL_OW 251
67412: PUSH
67413: LD_VAR 0 3
67417: PUSH
67418: LD_VAR 0 4
67422: ARRAY
67423: PPUSH
67424: CALL_OW 254
67428: PUSH
67429: EMPTY
67430: LIST
67431: LIST
67432: LIST
67433: LIST
67434: PUSH
67435: EMPTY
67436: LIST
67437: ADD
67438: ST_TO_ADDR
67439: GO 67352
67441: POP
67442: POP
// result := list ;
67443: LD_ADDR_VAR 0 2
67447: PUSH
67448: LD_VAR 0 5
67452: ST_TO_ADDR
// end ;
67453: LD_VAR 0 2
67457: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
67458: LD_INT 0
67460: PPUSH
67461: PPUSH
67462: PPUSH
67463: PPUSH
67464: PPUSH
67465: PPUSH
67466: PPUSH
// if not factory then
67467: LD_VAR 0 1
67471: NOT
67472: IFFALSE 67476
// exit ;
67474: GO 68069
// if control = control_apeman then
67476: LD_VAR 0 4
67480: PUSH
67481: LD_INT 5
67483: EQUAL
67484: IFFALSE 67593
// begin tmp := UnitsInside ( factory ) ;
67486: LD_ADDR_VAR 0 8
67490: PUSH
67491: LD_VAR 0 1
67495: PPUSH
67496: CALL_OW 313
67500: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
67501: LD_VAR 0 8
67505: PPUSH
67506: LD_INT 25
67508: PUSH
67509: LD_INT 12
67511: PUSH
67512: EMPTY
67513: LIST
67514: LIST
67515: PPUSH
67516: CALL_OW 72
67520: NOT
67521: IFFALSE 67531
// control := control_manual ;
67523: LD_ADDR_VAR 0 4
67527: PUSH
67528: LD_INT 1
67530: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
67531: LD_ADDR_VAR 0 8
67535: PUSH
67536: LD_VAR 0 1
67540: PPUSH
67541: CALL 67228 0 1
67545: ST_TO_ADDR
// if tmp then
67546: LD_VAR 0 8
67550: IFFALSE 67593
// begin for i in tmp do
67552: LD_ADDR_VAR 0 7
67556: PUSH
67557: LD_VAR 0 8
67561: PUSH
67562: FOR_IN
67563: IFFALSE 67591
// if i [ 1 ] = b_ext_radio then
67565: LD_VAR 0 7
67569: PUSH
67570: LD_INT 1
67572: ARRAY
67573: PUSH
67574: LD_INT 22
67576: EQUAL
67577: IFFALSE 67589
// begin control := control_remote ;
67579: LD_ADDR_VAR 0 4
67583: PUSH
67584: LD_INT 2
67586: ST_TO_ADDR
// break ;
67587: GO 67591
// end ;
67589: GO 67562
67591: POP
67592: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
67593: LD_VAR 0 1
67597: PPUSH
67598: LD_VAR 0 2
67602: PPUSH
67603: LD_VAR 0 3
67607: PPUSH
67608: LD_VAR 0 4
67612: PPUSH
67613: LD_VAR 0 5
67617: PPUSH
67618: CALL_OW 448
67622: IFFALSE 67657
// begin result := [ chassis , engine , control , weapon ] ;
67624: LD_ADDR_VAR 0 6
67628: PUSH
67629: LD_VAR 0 2
67633: PUSH
67634: LD_VAR 0 3
67638: PUSH
67639: LD_VAR 0 4
67643: PUSH
67644: LD_VAR 0 5
67648: PUSH
67649: EMPTY
67650: LIST
67651: LIST
67652: LIST
67653: LIST
67654: ST_TO_ADDR
// exit ;
67655: GO 68069
// end ; _chassis := AvailableChassisList ( factory ) ;
67657: LD_ADDR_VAR 0 9
67661: PUSH
67662: LD_VAR 0 1
67666: PPUSH
67667: CALL_OW 475
67671: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
67672: LD_ADDR_VAR 0 11
67676: PUSH
67677: LD_VAR 0 1
67681: PPUSH
67682: CALL_OW 476
67686: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
67687: LD_ADDR_VAR 0 12
67691: PUSH
67692: LD_VAR 0 1
67696: PPUSH
67697: CALL_OW 477
67701: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
67702: LD_ADDR_VAR 0 10
67706: PUSH
67707: LD_VAR 0 1
67711: PPUSH
67712: CALL_OW 478
67716: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
67717: LD_VAR 0 9
67721: NOT
67722: PUSH
67723: LD_VAR 0 11
67727: NOT
67728: OR
67729: PUSH
67730: LD_VAR 0 12
67734: NOT
67735: OR
67736: PUSH
67737: LD_VAR 0 10
67741: NOT
67742: OR
67743: IFFALSE 67778
// begin result := [ chassis , engine , control , weapon ] ;
67745: LD_ADDR_VAR 0 6
67749: PUSH
67750: LD_VAR 0 2
67754: PUSH
67755: LD_VAR 0 3
67759: PUSH
67760: LD_VAR 0 4
67764: PUSH
67765: LD_VAR 0 5
67769: PUSH
67770: EMPTY
67771: LIST
67772: LIST
67773: LIST
67774: LIST
67775: ST_TO_ADDR
// exit ;
67776: GO 68069
// end ; if not chassis in _chassis then
67778: LD_VAR 0 2
67782: PUSH
67783: LD_VAR 0 9
67787: IN
67788: NOT
67789: IFFALSE 67815
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
67791: LD_ADDR_VAR 0 2
67795: PUSH
67796: LD_VAR 0 9
67800: PUSH
67801: LD_INT 1
67803: PPUSH
67804: LD_VAR 0 9
67808: PPUSH
67809: CALL_OW 12
67813: ARRAY
67814: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
67815: LD_VAR 0 2
67819: PPUSH
67820: LD_VAR 0 3
67824: PPUSH
67825: CALL 68074 0 2
67829: NOT
67830: IFFALSE 67889
// repeat engine := _engine [ 1 ] ;
67832: LD_ADDR_VAR 0 3
67836: PUSH
67837: LD_VAR 0 11
67841: PUSH
67842: LD_INT 1
67844: ARRAY
67845: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
67846: LD_ADDR_VAR 0 11
67850: PUSH
67851: LD_VAR 0 11
67855: PPUSH
67856: LD_INT 1
67858: PPUSH
67859: CALL_OW 3
67863: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
67864: LD_VAR 0 2
67868: PPUSH
67869: LD_VAR 0 3
67873: PPUSH
67874: CALL 68074 0 2
67878: PUSH
67879: LD_VAR 0 11
67883: PUSH
67884: EMPTY
67885: EQUAL
67886: OR
67887: IFFALSE 67832
// if not control in _control then
67889: LD_VAR 0 4
67893: PUSH
67894: LD_VAR 0 12
67898: IN
67899: NOT
67900: IFFALSE 67926
// control := _control [ rand ( 1 , _control ) ] ;
67902: LD_ADDR_VAR 0 4
67906: PUSH
67907: LD_VAR 0 12
67911: PUSH
67912: LD_INT 1
67914: PPUSH
67915: LD_VAR 0 12
67919: PPUSH
67920: CALL_OW 12
67924: ARRAY
67925: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
67926: LD_VAR 0 2
67930: PPUSH
67931: LD_VAR 0 5
67935: PPUSH
67936: CALL 68294 0 2
67940: NOT
67941: IFFALSE 68000
// repeat weapon := _weapon [ 1 ] ;
67943: LD_ADDR_VAR 0 5
67947: PUSH
67948: LD_VAR 0 10
67952: PUSH
67953: LD_INT 1
67955: ARRAY
67956: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
67957: LD_ADDR_VAR 0 10
67961: PUSH
67962: LD_VAR 0 10
67966: PPUSH
67967: LD_INT 1
67969: PPUSH
67970: CALL_OW 3
67974: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
67975: LD_VAR 0 2
67979: PPUSH
67980: LD_VAR 0 5
67984: PPUSH
67985: CALL 68294 0 2
67989: PUSH
67990: LD_VAR 0 10
67994: PUSH
67995: EMPTY
67996: EQUAL
67997: OR
67998: IFFALSE 67943
// result := [ ] ;
68000: LD_ADDR_VAR 0 6
68004: PUSH
68005: EMPTY
68006: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68007: LD_VAR 0 1
68011: PPUSH
68012: LD_VAR 0 2
68016: PPUSH
68017: LD_VAR 0 3
68021: PPUSH
68022: LD_VAR 0 4
68026: PPUSH
68027: LD_VAR 0 5
68031: PPUSH
68032: CALL_OW 448
68036: IFFALSE 68069
// result := [ chassis , engine , control , weapon ] ;
68038: LD_ADDR_VAR 0 6
68042: PUSH
68043: LD_VAR 0 2
68047: PUSH
68048: LD_VAR 0 3
68052: PUSH
68053: LD_VAR 0 4
68057: PUSH
68058: LD_VAR 0 5
68062: PUSH
68063: EMPTY
68064: LIST
68065: LIST
68066: LIST
68067: LIST
68068: ST_TO_ADDR
// end ;
68069: LD_VAR 0 6
68073: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
68074: LD_INT 0
68076: PPUSH
// if not chassis or not engine then
68077: LD_VAR 0 1
68081: NOT
68082: PUSH
68083: LD_VAR 0 2
68087: NOT
68088: OR
68089: IFFALSE 68093
// exit ;
68091: GO 68289
// case engine of engine_solar :
68093: LD_VAR 0 2
68097: PUSH
68098: LD_INT 2
68100: DOUBLE
68101: EQUAL
68102: IFTRUE 68106
68104: GO 68144
68106: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
68107: LD_ADDR_VAR 0 3
68111: PUSH
68112: LD_INT 11
68114: PUSH
68115: LD_INT 12
68117: PUSH
68118: LD_INT 13
68120: PUSH
68121: LD_INT 14
68123: PUSH
68124: LD_INT 1
68126: PUSH
68127: LD_INT 2
68129: PUSH
68130: LD_INT 3
68132: PUSH
68133: EMPTY
68134: LIST
68135: LIST
68136: LIST
68137: LIST
68138: LIST
68139: LIST
68140: LIST
68141: ST_TO_ADDR
68142: GO 68273
68144: LD_INT 1
68146: DOUBLE
68147: EQUAL
68148: IFTRUE 68152
68150: GO 68214
68152: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
68153: LD_ADDR_VAR 0 3
68157: PUSH
68158: LD_INT 11
68160: PUSH
68161: LD_INT 12
68163: PUSH
68164: LD_INT 13
68166: PUSH
68167: LD_INT 14
68169: PUSH
68170: LD_INT 1
68172: PUSH
68173: LD_INT 2
68175: PUSH
68176: LD_INT 3
68178: PUSH
68179: LD_INT 4
68181: PUSH
68182: LD_INT 5
68184: PUSH
68185: LD_INT 21
68187: PUSH
68188: LD_INT 23
68190: PUSH
68191: LD_INT 22
68193: PUSH
68194: LD_INT 24
68196: PUSH
68197: EMPTY
68198: LIST
68199: LIST
68200: LIST
68201: LIST
68202: LIST
68203: LIST
68204: LIST
68205: LIST
68206: LIST
68207: LIST
68208: LIST
68209: LIST
68210: LIST
68211: ST_TO_ADDR
68212: GO 68273
68214: LD_INT 3
68216: DOUBLE
68217: EQUAL
68218: IFTRUE 68222
68220: GO 68272
68222: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
68223: LD_ADDR_VAR 0 3
68227: PUSH
68228: LD_INT 13
68230: PUSH
68231: LD_INT 14
68233: PUSH
68234: LD_INT 2
68236: PUSH
68237: LD_INT 3
68239: PUSH
68240: LD_INT 4
68242: PUSH
68243: LD_INT 5
68245: PUSH
68246: LD_INT 21
68248: PUSH
68249: LD_INT 22
68251: PUSH
68252: LD_INT 23
68254: PUSH
68255: LD_INT 24
68257: PUSH
68258: EMPTY
68259: LIST
68260: LIST
68261: LIST
68262: LIST
68263: LIST
68264: LIST
68265: LIST
68266: LIST
68267: LIST
68268: LIST
68269: ST_TO_ADDR
68270: GO 68273
68272: POP
// result := ( chassis in result ) ;
68273: LD_ADDR_VAR 0 3
68277: PUSH
68278: LD_VAR 0 1
68282: PUSH
68283: LD_VAR 0 3
68287: IN
68288: ST_TO_ADDR
// end ;
68289: LD_VAR 0 3
68293: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
68294: LD_INT 0
68296: PPUSH
// if not chassis or not weapon then
68297: LD_VAR 0 1
68301: NOT
68302: PUSH
68303: LD_VAR 0 2
68307: NOT
68308: OR
68309: IFFALSE 68313
// exit ;
68311: GO 69339
// case weapon of us_machine_gun :
68313: LD_VAR 0 2
68317: PUSH
68318: LD_INT 2
68320: DOUBLE
68321: EQUAL
68322: IFTRUE 68326
68324: GO 68356
68326: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
68327: LD_ADDR_VAR 0 3
68331: PUSH
68332: LD_INT 1
68334: PUSH
68335: LD_INT 2
68337: PUSH
68338: LD_INT 3
68340: PUSH
68341: LD_INT 4
68343: PUSH
68344: LD_INT 5
68346: PUSH
68347: EMPTY
68348: LIST
68349: LIST
68350: LIST
68351: LIST
68352: LIST
68353: ST_TO_ADDR
68354: GO 69323
68356: LD_INT 3
68358: DOUBLE
68359: EQUAL
68360: IFTRUE 68364
68362: GO 68394
68364: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
68365: LD_ADDR_VAR 0 3
68369: PUSH
68370: LD_INT 1
68372: PUSH
68373: LD_INT 2
68375: PUSH
68376: LD_INT 3
68378: PUSH
68379: LD_INT 4
68381: PUSH
68382: LD_INT 5
68384: PUSH
68385: EMPTY
68386: LIST
68387: LIST
68388: LIST
68389: LIST
68390: LIST
68391: ST_TO_ADDR
68392: GO 69323
68394: LD_INT 11
68396: DOUBLE
68397: EQUAL
68398: IFTRUE 68402
68400: GO 68432
68402: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
68403: LD_ADDR_VAR 0 3
68407: PUSH
68408: LD_INT 1
68410: PUSH
68411: LD_INT 2
68413: PUSH
68414: LD_INT 3
68416: PUSH
68417: LD_INT 4
68419: PUSH
68420: LD_INT 5
68422: PUSH
68423: EMPTY
68424: LIST
68425: LIST
68426: LIST
68427: LIST
68428: LIST
68429: ST_TO_ADDR
68430: GO 69323
68432: LD_INT 4
68434: DOUBLE
68435: EQUAL
68436: IFTRUE 68440
68438: GO 68466
68440: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
68441: LD_ADDR_VAR 0 3
68445: PUSH
68446: LD_INT 2
68448: PUSH
68449: LD_INT 3
68451: PUSH
68452: LD_INT 4
68454: PUSH
68455: LD_INT 5
68457: PUSH
68458: EMPTY
68459: LIST
68460: LIST
68461: LIST
68462: LIST
68463: ST_TO_ADDR
68464: GO 69323
68466: LD_INT 5
68468: DOUBLE
68469: EQUAL
68470: IFTRUE 68474
68472: GO 68500
68474: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
68475: LD_ADDR_VAR 0 3
68479: PUSH
68480: LD_INT 2
68482: PUSH
68483: LD_INT 3
68485: PUSH
68486: LD_INT 4
68488: PUSH
68489: LD_INT 5
68491: PUSH
68492: EMPTY
68493: LIST
68494: LIST
68495: LIST
68496: LIST
68497: ST_TO_ADDR
68498: GO 69323
68500: LD_INT 9
68502: DOUBLE
68503: EQUAL
68504: IFTRUE 68508
68506: GO 68534
68508: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
68509: LD_ADDR_VAR 0 3
68513: PUSH
68514: LD_INT 2
68516: PUSH
68517: LD_INT 3
68519: PUSH
68520: LD_INT 4
68522: PUSH
68523: LD_INT 5
68525: PUSH
68526: EMPTY
68527: LIST
68528: LIST
68529: LIST
68530: LIST
68531: ST_TO_ADDR
68532: GO 69323
68534: LD_INT 7
68536: DOUBLE
68537: EQUAL
68538: IFTRUE 68542
68540: GO 68568
68542: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
68543: LD_ADDR_VAR 0 3
68547: PUSH
68548: LD_INT 2
68550: PUSH
68551: LD_INT 3
68553: PUSH
68554: LD_INT 4
68556: PUSH
68557: LD_INT 5
68559: PUSH
68560: EMPTY
68561: LIST
68562: LIST
68563: LIST
68564: LIST
68565: ST_TO_ADDR
68566: GO 69323
68568: LD_INT 12
68570: DOUBLE
68571: EQUAL
68572: IFTRUE 68576
68574: GO 68602
68576: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
68577: LD_ADDR_VAR 0 3
68581: PUSH
68582: LD_INT 2
68584: PUSH
68585: LD_INT 3
68587: PUSH
68588: LD_INT 4
68590: PUSH
68591: LD_INT 5
68593: PUSH
68594: EMPTY
68595: LIST
68596: LIST
68597: LIST
68598: LIST
68599: ST_TO_ADDR
68600: GO 69323
68602: LD_INT 13
68604: DOUBLE
68605: EQUAL
68606: IFTRUE 68610
68608: GO 68636
68610: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
68611: LD_ADDR_VAR 0 3
68615: PUSH
68616: LD_INT 2
68618: PUSH
68619: LD_INT 3
68621: PUSH
68622: LD_INT 4
68624: PUSH
68625: LD_INT 5
68627: PUSH
68628: EMPTY
68629: LIST
68630: LIST
68631: LIST
68632: LIST
68633: ST_TO_ADDR
68634: GO 69323
68636: LD_INT 14
68638: DOUBLE
68639: EQUAL
68640: IFTRUE 68644
68642: GO 68662
68644: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
68645: LD_ADDR_VAR 0 3
68649: PUSH
68650: LD_INT 4
68652: PUSH
68653: LD_INT 5
68655: PUSH
68656: EMPTY
68657: LIST
68658: LIST
68659: ST_TO_ADDR
68660: GO 69323
68662: LD_INT 6
68664: DOUBLE
68665: EQUAL
68666: IFTRUE 68670
68668: GO 68688
68670: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
68671: LD_ADDR_VAR 0 3
68675: PUSH
68676: LD_INT 4
68678: PUSH
68679: LD_INT 5
68681: PUSH
68682: EMPTY
68683: LIST
68684: LIST
68685: ST_TO_ADDR
68686: GO 69323
68688: LD_INT 10
68690: DOUBLE
68691: EQUAL
68692: IFTRUE 68696
68694: GO 68714
68696: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
68697: LD_ADDR_VAR 0 3
68701: PUSH
68702: LD_INT 4
68704: PUSH
68705: LD_INT 5
68707: PUSH
68708: EMPTY
68709: LIST
68710: LIST
68711: ST_TO_ADDR
68712: GO 69323
68714: LD_INT 22
68716: DOUBLE
68717: EQUAL
68718: IFTRUE 68722
68720: GO 68748
68722: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
68723: LD_ADDR_VAR 0 3
68727: PUSH
68728: LD_INT 11
68730: PUSH
68731: LD_INT 12
68733: PUSH
68734: LD_INT 13
68736: PUSH
68737: LD_INT 14
68739: PUSH
68740: EMPTY
68741: LIST
68742: LIST
68743: LIST
68744: LIST
68745: ST_TO_ADDR
68746: GO 69323
68748: LD_INT 23
68750: DOUBLE
68751: EQUAL
68752: IFTRUE 68756
68754: GO 68782
68756: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
68757: LD_ADDR_VAR 0 3
68761: PUSH
68762: LD_INT 11
68764: PUSH
68765: LD_INT 12
68767: PUSH
68768: LD_INT 13
68770: PUSH
68771: LD_INT 14
68773: PUSH
68774: EMPTY
68775: LIST
68776: LIST
68777: LIST
68778: LIST
68779: ST_TO_ADDR
68780: GO 69323
68782: LD_INT 24
68784: DOUBLE
68785: EQUAL
68786: IFTRUE 68790
68788: GO 68816
68790: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
68791: LD_ADDR_VAR 0 3
68795: PUSH
68796: LD_INT 11
68798: PUSH
68799: LD_INT 12
68801: PUSH
68802: LD_INT 13
68804: PUSH
68805: LD_INT 14
68807: PUSH
68808: EMPTY
68809: LIST
68810: LIST
68811: LIST
68812: LIST
68813: ST_TO_ADDR
68814: GO 69323
68816: LD_INT 30
68818: DOUBLE
68819: EQUAL
68820: IFTRUE 68824
68822: GO 68850
68824: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
68825: LD_ADDR_VAR 0 3
68829: PUSH
68830: LD_INT 11
68832: PUSH
68833: LD_INT 12
68835: PUSH
68836: LD_INT 13
68838: PUSH
68839: LD_INT 14
68841: PUSH
68842: EMPTY
68843: LIST
68844: LIST
68845: LIST
68846: LIST
68847: ST_TO_ADDR
68848: GO 69323
68850: LD_INT 25
68852: DOUBLE
68853: EQUAL
68854: IFTRUE 68858
68856: GO 68876
68858: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
68859: LD_ADDR_VAR 0 3
68863: PUSH
68864: LD_INT 13
68866: PUSH
68867: LD_INT 14
68869: PUSH
68870: EMPTY
68871: LIST
68872: LIST
68873: ST_TO_ADDR
68874: GO 69323
68876: LD_INT 27
68878: DOUBLE
68879: EQUAL
68880: IFTRUE 68884
68882: GO 68902
68884: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
68885: LD_ADDR_VAR 0 3
68889: PUSH
68890: LD_INT 13
68892: PUSH
68893: LD_INT 14
68895: PUSH
68896: EMPTY
68897: LIST
68898: LIST
68899: ST_TO_ADDR
68900: GO 69323
68902: LD_INT 28
68904: DOUBLE
68905: EQUAL
68906: IFTRUE 68910
68908: GO 68928
68910: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
68911: LD_ADDR_VAR 0 3
68915: PUSH
68916: LD_INT 13
68918: PUSH
68919: LD_INT 14
68921: PUSH
68922: EMPTY
68923: LIST
68924: LIST
68925: ST_TO_ADDR
68926: GO 69323
68928: LD_INT 29
68930: DOUBLE
68931: EQUAL
68932: IFTRUE 68936
68934: GO 68954
68936: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
68937: LD_ADDR_VAR 0 3
68941: PUSH
68942: LD_INT 13
68944: PUSH
68945: LD_INT 14
68947: PUSH
68948: EMPTY
68949: LIST
68950: LIST
68951: ST_TO_ADDR
68952: GO 69323
68954: LD_INT 31
68956: DOUBLE
68957: EQUAL
68958: IFTRUE 68962
68960: GO 68980
68962: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
68963: LD_ADDR_VAR 0 3
68967: PUSH
68968: LD_INT 13
68970: PUSH
68971: LD_INT 14
68973: PUSH
68974: EMPTY
68975: LIST
68976: LIST
68977: ST_TO_ADDR
68978: GO 69323
68980: LD_INT 26
68982: DOUBLE
68983: EQUAL
68984: IFTRUE 68988
68986: GO 69006
68988: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
68989: LD_ADDR_VAR 0 3
68993: PUSH
68994: LD_INT 13
68996: PUSH
68997: LD_INT 14
68999: PUSH
69000: EMPTY
69001: LIST
69002: LIST
69003: ST_TO_ADDR
69004: GO 69323
69006: LD_INT 42
69008: DOUBLE
69009: EQUAL
69010: IFTRUE 69014
69012: GO 69040
69014: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
69015: LD_ADDR_VAR 0 3
69019: PUSH
69020: LD_INT 21
69022: PUSH
69023: LD_INT 22
69025: PUSH
69026: LD_INT 23
69028: PUSH
69029: LD_INT 24
69031: PUSH
69032: EMPTY
69033: LIST
69034: LIST
69035: LIST
69036: LIST
69037: ST_TO_ADDR
69038: GO 69323
69040: LD_INT 43
69042: DOUBLE
69043: EQUAL
69044: IFTRUE 69048
69046: GO 69074
69048: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
69049: LD_ADDR_VAR 0 3
69053: PUSH
69054: LD_INT 21
69056: PUSH
69057: LD_INT 22
69059: PUSH
69060: LD_INT 23
69062: PUSH
69063: LD_INT 24
69065: PUSH
69066: EMPTY
69067: LIST
69068: LIST
69069: LIST
69070: LIST
69071: ST_TO_ADDR
69072: GO 69323
69074: LD_INT 44
69076: DOUBLE
69077: EQUAL
69078: IFTRUE 69082
69080: GO 69108
69082: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
69083: LD_ADDR_VAR 0 3
69087: PUSH
69088: LD_INT 21
69090: PUSH
69091: LD_INT 22
69093: PUSH
69094: LD_INT 23
69096: PUSH
69097: LD_INT 24
69099: PUSH
69100: EMPTY
69101: LIST
69102: LIST
69103: LIST
69104: LIST
69105: ST_TO_ADDR
69106: GO 69323
69108: LD_INT 45
69110: DOUBLE
69111: EQUAL
69112: IFTRUE 69116
69114: GO 69142
69116: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
69117: LD_ADDR_VAR 0 3
69121: PUSH
69122: LD_INT 21
69124: PUSH
69125: LD_INT 22
69127: PUSH
69128: LD_INT 23
69130: PUSH
69131: LD_INT 24
69133: PUSH
69134: EMPTY
69135: LIST
69136: LIST
69137: LIST
69138: LIST
69139: ST_TO_ADDR
69140: GO 69323
69142: LD_INT 49
69144: DOUBLE
69145: EQUAL
69146: IFTRUE 69150
69148: GO 69176
69150: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
69151: LD_ADDR_VAR 0 3
69155: PUSH
69156: LD_INT 21
69158: PUSH
69159: LD_INT 22
69161: PUSH
69162: LD_INT 23
69164: PUSH
69165: LD_INT 24
69167: PUSH
69168: EMPTY
69169: LIST
69170: LIST
69171: LIST
69172: LIST
69173: ST_TO_ADDR
69174: GO 69323
69176: LD_INT 51
69178: DOUBLE
69179: EQUAL
69180: IFTRUE 69184
69182: GO 69210
69184: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
69185: LD_ADDR_VAR 0 3
69189: PUSH
69190: LD_INT 21
69192: PUSH
69193: LD_INT 22
69195: PUSH
69196: LD_INT 23
69198: PUSH
69199: LD_INT 24
69201: PUSH
69202: EMPTY
69203: LIST
69204: LIST
69205: LIST
69206: LIST
69207: ST_TO_ADDR
69208: GO 69323
69210: LD_INT 52
69212: DOUBLE
69213: EQUAL
69214: IFTRUE 69218
69216: GO 69244
69218: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
69219: LD_ADDR_VAR 0 3
69223: PUSH
69224: LD_INT 21
69226: PUSH
69227: LD_INT 22
69229: PUSH
69230: LD_INT 23
69232: PUSH
69233: LD_INT 24
69235: PUSH
69236: EMPTY
69237: LIST
69238: LIST
69239: LIST
69240: LIST
69241: ST_TO_ADDR
69242: GO 69323
69244: LD_INT 53
69246: DOUBLE
69247: EQUAL
69248: IFTRUE 69252
69250: GO 69270
69252: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
69253: LD_ADDR_VAR 0 3
69257: PUSH
69258: LD_INT 23
69260: PUSH
69261: LD_INT 24
69263: PUSH
69264: EMPTY
69265: LIST
69266: LIST
69267: ST_TO_ADDR
69268: GO 69323
69270: LD_INT 46
69272: DOUBLE
69273: EQUAL
69274: IFTRUE 69278
69276: GO 69296
69278: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
69279: LD_ADDR_VAR 0 3
69283: PUSH
69284: LD_INT 23
69286: PUSH
69287: LD_INT 24
69289: PUSH
69290: EMPTY
69291: LIST
69292: LIST
69293: ST_TO_ADDR
69294: GO 69323
69296: LD_INT 47
69298: DOUBLE
69299: EQUAL
69300: IFTRUE 69304
69302: GO 69322
69304: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69305: LD_ADDR_VAR 0 3
69309: PUSH
69310: LD_INT 23
69312: PUSH
69313: LD_INT 24
69315: PUSH
69316: EMPTY
69317: LIST
69318: LIST
69319: ST_TO_ADDR
69320: GO 69323
69322: POP
// result := ( chassis in result ) ;
69323: LD_ADDR_VAR 0 3
69327: PUSH
69328: LD_VAR 0 1
69332: PUSH
69333: LD_VAR 0 3
69337: IN
69338: ST_TO_ADDR
// end ;
69339: LD_VAR 0 3
69343: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
69344: LD_INT 0
69346: PPUSH
69347: PPUSH
69348: PPUSH
69349: PPUSH
69350: PPUSH
69351: PPUSH
69352: PPUSH
// result := array ;
69353: LD_ADDR_VAR 0 5
69357: PUSH
69358: LD_VAR 0 1
69362: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
69363: LD_VAR 0 1
69367: NOT
69368: PUSH
69369: LD_VAR 0 2
69373: NOT
69374: OR
69375: PUSH
69376: LD_VAR 0 3
69380: NOT
69381: OR
69382: PUSH
69383: LD_VAR 0 2
69387: PUSH
69388: LD_VAR 0 1
69392: GREATER
69393: OR
69394: PUSH
69395: LD_VAR 0 3
69399: PUSH
69400: LD_VAR 0 1
69404: GREATER
69405: OR
69406: IFFALSE 69410
// exit ;
69408: GO 69706
// if direction then
69410: LD_VAR 0 4
69414: IFFALSE 69478
// begin d := 1 ;
69416: LD_ADDR_VAR 0 9
69420: PUSH
69421: LD_INT 1
69423: ST_TO_ADDR
// if i_from > i_to then
69424: LD_VAR 0 2
69428: PUSH
69429: LD_VAR 0 3
69433: GREATER
69434: IFFALSE 69460
// length := ( array - i_from ) + i_to else
69436: LD_ADDR_VAR 0 11
69440: PUSH
69441: LD_VAR 0 1
69445: PUSH
69446: LD_VAR 0 2
69450: MINUS
69451: PUSH
69452: LD_VAR 0 3
69456: PLUS
69457: ST_TO_ADDR
69458: GO 69476
// length := i_to - i_from ;
69460: LD_ADDR_VAR 0 11
69464: PUSH
69465: LD_VAR 0 3
69469: PUSH
69470: LD_VAR 0 2
69474: MINUS
69475: ST_TO_ADDR
// end else
69476: GO 69539
// begin d := - 1 ;
69478: LD_ADDR_VAR 0 9
69482: PUSH
69483: LD_INT 1
69485: NEG
69486: ST_TO_ADDR
// if i_from > i_to then
69487: LD_VAR 0 2
69491: PUSH
69492: LD_VAR 0 3
69496: GREATER
69497: IFFALSE 69517
// length := i_from - i_to else
69499: LD_ADDR_VAR 0 11
69503: PUSH
69504: LD_VAR 0 2
69508: PUSH
69509: LD_VAR 0 3
69513: MINUS
69514: ST_TO_ADDR
69515: GO 69539
// length := ( array - i_to ) + i_from ;
69517: LD_ADDR_VAR 0 11
69521: PUSH
69522: LD_VAR 0 1
69526: PUSH
69527: LD_VAR 0 3
69531: MINUS
69532: PUSH
69533: LD_VAR 0 2
69537: PLUS
69538: ST_TO_ADDR
// end ; if not length then
69539: LD_VAR 0 11
69543: NOT
69544: IFFALSE 69548
// exit ;
69546: GO 69706
// tmp := array ;
69548: LD_ADDR_VAR 0 10
69552: PUSH
69553: LD_VAR 0 1
69557: ST_TO_ADDR
// for i = 1 to length do
69558: LD_ADDR_VAR 0 6
69562: PUSH
69563: DOUBLE
69564: LD_INT 1
69566: DEC
69567: ST_TO_ADDR
69568: LD_VAR 0 11
69572: PUSH
69573: FOR_TO
69574: IFFALSE 69694
// begin for j = 1 to array do
69576: LD_ADDR_VAR 0 7
69580: PUSH
69581: DOUBLE
69582: LD_INT 1
69584: DEC
69585: ST_TO_ADDR
69586: LD_VAR 0 1
69590: PUSH
69591: FOR_TO
69592: IFFALSE 69680
// begin k := j + d ;
69594: LD_ADDR_VAR 0 8
69598: PUSH
69599: LD_VAR 0 7
69603: PUSH
69604: LD_VAR 0 9
69608: PLUS
69609: ST_TO_ADDR
// if k > array then
69610: LD_VAR 0 8
69614: PUSH
69615: LD_VAR 0 1
69619: GREATER
69620: IFFALSE 69630
// k := 1 ;
69622: LD_ADDR_VAR 0 8
69626: PUSH
69627: LD_INT 1
69629: ST_TO_ADDR
// if not k then
69630: LD_VAR 0 8
69634: NOT
69635: IFFALSE 69647
// k := array ;
69637: LD_ADDR_VAR 0 8
69641: PUSH
69642: LD_VAR 0 1
69646: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
69647: LD_ADDR_VAR 0 10
69651: PUSH
69652: LD_VAR 0 10
69656: PPUSH
69657: LD_VAR 0 8
69661: PPUSH
69662: LD_VAR 0 1
69666: PUSH
69667: LD_VAR 0 7
69671: ARRAY
69672: PPUSH
69673: CALL_OW 1
69677: ST_TO_ADDR
// end ;
69678: GO 69591
69680: POP
69681: POP
// array := tmp ;
69682: LD_ADDR_VAR 0 1
69686: PUSH
69687: LD_VAR 0 10
69691: ST_TO_ADDR
// end ;
69692: GO 69573
69694: POP
69695: POP
// result := array ;
69696: LD_ADDR_VAR 0 5
69700: PUSH
69701: LD_VAR 0 1
69705: ST_TO_ADDR
// end ;
69706: LD_VAR 0 5
69710: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
69711: LD_INT 0
69713: PPUSH
69714: PPUSH
// result := 0 ;
69715: LD_ADDR_VAR 0 3
69719: PUSH
69720: LD_INT 0
69722: ST_TO_ADDR
// if not array or not value in array then
69723: LD_VAR 0 1
69727: NOT
69728: PUSH
69729: LD_VAR 0 2
69733: PUSH
69734: LD_VAR 0 1
69738: IN
69739: NOT
69740: OR
69741: IFFALSE 69745
// exit ;
69743: GO 69799
// for i = 1 to array do
69745: LD_ADDR_VAR 0 4
69749: PUSH
69750: DOUBLE
69751: LD_INT 1
69753: DEC
69754: ST_TO_ADDR
69755: LD_VAR 0 1
69759: PUSH
69760: FOR_TO
69761: IFFALSE 69797
// if value = array [ i ] then
69763: LD_VAR 0 2
69767: PUSH
69768: LD_VAR 0 1
69772: PUSH
69773: LD_VAR 0 4
69777: ARRAY
69778: EQUAL
69779: IFFALSE 69795
// begin result := i ;
69781: LD_ADDR_VAR 0 3
69785: PUSH
69786: LD_VAR 0 4
69790: ST_TO_ADDR
// exit ;
69791: POP
69792: POP
69793: GO 69799
// end ;
69795: GO 69760
69797: POP
69798: POP
// end ;
69799: LD_VAR 0 3
69803: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
69804: LD_INT 0
69806: PPUSH
// vc_chassis := chassis ;
69807: LD_ADDR_OWVAR 37
69811: PUSH
69812: LD_VAR 0 1
69816: ST_TO_ADDR
// vc_engine := engine ;
69817: LD_ADDR_OWVAR 39
69821: PUSH
69822: LD_VAR 0 2
69826: ST_TO_ADDR
// vc_control := control ;
69827: LD_ADDR_OWVAR 38
69831: PUSH
69832: LD_VAR 0 3
69836: ST_TO_ADDR
// vc_weapon := weapon ;
69837: LD_ADDR_OWVAR 40
69841: PUSH
69842: LD_VAR 0 4
69846: ST_TO_ADDR
// vc_fuel_battery := fuel ;
69847: LD_ADDR_OWVAR 41
69851: PUSH
69852: LD_VAR 0 5
69856: ST_TO_ADDR
// end ;
69857: LD_VAR 0 6
69861: RET
// export function WantPlant ( unit ) ; var task ; begin
69862: LD_INT 0
69864: PPUSH
69865: PPUSH
// result := false ;
69866: LD_ADDR_VAR 0 2
69870: PUSH
69871: LD_INT 0
69873: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
69874: LD_ADDR_VAR 0 3
69878: PUSH
69879: LD_VAR 0 1
69883: PPUSH
69884: CALL_OW 437
69888: ST_TO_ADDR
// if task then
69889: LD_VAR 0 3
69893: IFFALSE 69921
// if task [ 1 ] [ 1 ] = p then
69895: LD_VAR 0 3
69899: PUSH
69900: LD_INT 1
69902: ARRAY
69903: PUSH
69904: LD_INT 1
69906: ARRAY
69907: PUSH
69908: LD_STRING p
69910: EQUAL
69911: IFFALSE 69921
// result := true ;
69913: LD_ADDR_VAR 0 2
69917: PUSH
69918: LD_INT 1
69920: ST_TO_ADDR
// end ;
69921: LD_VAR 0 2
69925: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
69926: LD_INT 0
69928: PPUSH
69929: PPUSH
69930: PPUSH
69931: PPUSH
// if pos < 1 then
69932: LD_VAR 0 2
69936: PUSH
69937: LD_INT 1
69939: LESS
69940: IFFALSE 69944
// exit ;
69942: GO 70247
// if pos = 1 then
69944: LD_VAR 0 2
69948: PUSH
69949: LD_INT 1
69951: EQUAL
69952: IFFALSE 69985
// result := Replace ( arr , pos [ 1 ] , value ) else
69954: LD_ADDR_VAR 0 4
69958: PUSH
69959: LD_VAR 0 1
69963: PPUSH
69964: LD_VAR 0 2
69968: PUSH
69969: LD_INT 1
69971: ARRAY
69972: PPUSH
69973: LD_VAR 0 3
69977: PPUSH
69978: CALL_OW 1
69982: ST_TO_ADDR
69983: GO 70247
// begin tmp := arr ;
69985: LD_ADDR_VAR 0 6
69989: PUSH
69990: LD_VAR 0 1
69994: ST_TO_ADDR
// s_arr := [ tmp ] ;
69995: LD_ADDR_VAR 0 7
69999: PUSH
70000: LD_VAR 0 6
70004: PUSH
70005: EMPTY
70006: LIST
70007: ST_TO_ADDR
// for i = 1 to pos - 1 do
70008: LD_ADDR_VAR 0 5
70012: PUSH
70013: DOUBLE
70014: LD_INT 1
70016: DEC
70017: ST_TO_ADDR
70018: LD_VAR 0 2
70022: PUSH
70023: LD_INT 1
70025: MINUS
70026: PUSH
70027: FOR_TO
70028: IFFALSE 70073
// begin tmp := tmp [ pos [ i ] ] ;
70030: LD_ADDR_VAR 0 6
70034: PUSH
70035: LD_VAR 0 6
70039: PUSH
70040: LD_VAR 0 2
70044: PUSH
70045: LD_VAR 0 5
70049: ARRAY
70050: ARRAY
70051: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
70052: LD_ADDR_VAR 0 7
70056: PUSH
70057: LD_VAR 0 7
70061: PUSH
70062: LD_VAR 0 6
70066: PUSH
70067: EMPTY
70068: LIST
70069: ADD
70070: ST_TO_ADDR
// end ;
70071: GO 70027
70073: POP
70074: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
70075: LD_ADDR_VAR 0 6
70079: PUSH
70080: LD_VAR 0 6
70084: PPUSH
70085: LD_VAR 0 2
70089: PUSH
70090: LD_VAR 0 2
70094: ARRAY
70095: PPUSH
70096: LD_VAR 0 3
70100: PPUSH
70101: CALL_OW 1
70105: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
70106: LD_ADDR_VAR 0 7
70110: PUSH
70111: LD_VAR 0 7
70115: PPUSH
70116: LD_VAR 0 7
70120: PPUSH
70121: LD_VAR 0 6
70125: PPUSH
70126: CALL_OW 1
70130: ST_TO_ADDR
// for i = s_arr downto 2 do
70131: LD_ADDR_VAR 0 5
70135: PUSH
70136: DOUBLE
70137: LD_VAR 0 7
70141: INC
70142: ST_TO_ADDR
70143: LD_INT 2
70145: PUSH
70146: FOR_DOWNTO
70147: IFFALSE 70231
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
70149: LD_ADDR_VAR 0 6
70153: PUSH
70154: LD_VAR 0 7
70158: PUSH
70159: LD_VAR 0 5
70163: PUSH
70164: LD_INT 1
70166: MINUS
70167: ARRAY
70168: PPUSH
70169: LD_VAR 0 2
70173: PUSH
70174: LD_VAR 0 5
70178: PUSH
70179: LD_INT 1
70181: MINUS
70182: ARRAY
70183: PPUSH
70184: LD_VAR 0 7
70188: PUSH
70189: LD_VAR 0 5
70193: ARRAY
70194: PPUSH
70195: CALL_OW 1
70199: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
70200: LD_ADDR_VAR 0 7
70204: PUSH
70205: LD_VAR 0 7
70209: PPUSH
70210: LD_VAR 0 5
70214: PUSH
70215: LD_INT 1
70217: MINUS
70218: PPUSH
70219: LD_VAR 0 6
70223: PPUSH
70224: CALL_OW 1
70228: ST_TO_ADDR
// end ;
70229: GO 70146
70231: POP
70232: POP
// result := s_arr [ 1 ] ;
70233: LD_ADDR_VAR 0 4
70237: PUSH
70238: LD_VAR 0 7
70242: PUSH
70243: LD_INT 1
70245: ARRAY
70246: ST_TO_ADDR
// end ; end ;
70247: LD_VAR 0 4
70251: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
70252: LD_INT 0
70254: PPUSH
70255: PPUSH
// if not list then
70256: LD_VAR 0 1
70260: NOT
70261: IFFALSE 70265
// exit ;
70263: GO 70356
// i := list [ pos1 ] ;
70265: LD_ADDR_VAR 0 5
70269: PUSH
70270: LD_VAR 0 1
70274: PUSH
70275: LD_VAR 0 2
70279: ARRAY
70280: ST_TO_ADDR
// if not i then
70281: LD_VAR 0 5
70285: NOT
70286: IFFALSE 70290
// exit ;
70288: GO 70356
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
70290: LD_ADDR_VAR 0 1
70294: PUSH
70295: LD_VAR 0 1
70299: PPUSH
70300: LD_VAR 0 2
70304: PPUSH
70305: LD_VAR 0 1
70309: PUSH
70310: LD_VAR 0 3
70314: ARRAY
70315: PPUSH
70316: CALL_OW 1
70320: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
70321: LD_ADDR_VAR 0 1
70325: PUSH
70326: LD_VAR 0 1
70330: PPUSH
70331: LD_VAR 0 3
70335: PPUSH
70336: LD_VAR 0 5
70340: PPUSH
70341: CALL_OW 1
70345: ST_TO_ADDR
// result := list ;
70346: LD_ADDR_VAR 0 4
70350: PUSH
70351: LD_VAR 0 1
70355: ST_TO_ADDR
// end ;
70356: LD_VAR 0 4
70360: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
70361: LD_INT 0
70363: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
70364: LD_ADDR_VAR 0 5
70368: PUSH
70369: LD_VAR 0 1
70373: PPUSH
70374: CALL_OW 250
70378: PPUSH
70379: LD_VAR 0 1
70383: PPUSH
70384: CALL_OW 251
70388: PPUSH
70389: LD_VAR 0 2
70393: PPUSH
70394: LD_VAR 0 3
70398: PPUSH
70399: LD_VAR 0 4
70403: PPUSH
70404: CALL 70414 0 5
70408: ST_TO_ADDR
// end ;
70409: LD_VAR 0 5
70413: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
70414: LD_INT 0
70416: PPUSH
70417: PPUSH
70418: PPUSH
70419: PPUSH
// if not list then
70420: LD_VAR 0 3
70424: NOT
70425: IFFALSE 70429
// exit ;
70427: GO 70817
// result := [ ] ;
70429: LD_ADDR_VAR 0 6
70433: PUSH
70434: EMPTY
70435: ST_TO_ADDR
// for i in list do
70436: LD_ADDR_VAR 0 7
70440: PUSH
70441: LD_VAR 0 3
70445: PUSH
70446: FOR_IN
70447: IFFALSE 70649
// begin tmp := GetDistUnitXY ( i , x , y ) ;
70449: LD_ADDR_VAR 0 9
70453: PUSH
70454: LD_VAR 0 7
70458: PPUSH
70459: LD_VAR 0 1
70463: PPUSH
70464: LD_VAR 0 2
70468: PPUSH
70469: CALL_OW 297
70473: ST_TO_ADDR
// if not result then
70474: LD_VAR 0 6
70478: NOT
70479: IFFALSE 70505
// result := [ [ i , tmp ] ] else
70481: LD_ADDR_VAR 0 6
70485: PUSH
70486: LD_VAR 0 7
70490: PUSH
70491: LD_VAR 0 9
70495: PUSH
70496: EMPTY
70497: LIST
70498: LIST
70499: PUSH
70500: EMPTY
70501: LIST
70502: ST_TO_ADDR
70503: GO 70647
// begin if result [ result ] [ 2 ] < tmp then
70505: LD_VAR 0 6
70509: PUSH
70510: LD_VAR 0 6
70514: ARRAY
70515: PUSH
70516: LD_INT 2
70518: ARRAY
70519: PUSH
70520: LD_VAR 0 9
70524: LESS
70525: IFFALSE 70567
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
70527: LD_ADDR_VAR 0 6
70531: PUSH
70532: LD_VAR 0 6
70536: PPUSH
70537: LD_VAR 0 6
70541: PUSH
70542: LD_INT 1
70544: PLUS
70545: PPUSH
70546: LD_VAR 0 7
70550: PUSH
70551: LD_VAR 0 9
70555: PUSH
70556: EMPTY
70557: LIST
70558: LIST
70559: PPUSH
70560: CALL_OW 2
70564: ST_TO_ADDR
70565: GO 70647
// for j = 1 to result do
70567: LD_ADDR_VAR 0 8
70571: PUSH
70572: DOUBLE
70573: LD_INT 1
70575: DEC
70576: ST_TO_ADDR
70577: LD_VAR 0 6
70581: PUSH
70582: FOR_TO
70583: IFFALSE 70645
// begin if tmp < result [ j ] [ 2 ] then
70585: LD_VAR 0 9
70589: PUSH
70590: LD_VAR 0 6
70594: PUSH
70595: LD_VAR 0 8
70599: ARRAY
70600: PUSH
70601: LD_INT 2
70603: ARRAY
70604: LESS
70605: IFFALSE 70643
// begin result := Insert ( result , j , [ i , tmp ] ) ;
70607: LD_ADDR_VAR 0 6
70611: PUSH
70612: LD_VAR 0 6
70616: PPUSH
70617: LD_VAR 0 8
70621: PPUSH
70622: LD_VAR 0 7
70626: PUSH
70627: LD_VAR 0 9
70631: PUSH
70632: EMPTY
70633: LIST
70634: LIST
70635: PPUSH
70636: CALL_OW 2
70640: ST_TO_ADDR
// break ;
70641: GO 70645
// end ; end ;
70643: GO 70582
70645: POP
70646: POP
// end ; end ;
70647: GO 70446
70649: POP
70650: POP
// if result and not asc then
70651: LD_VAR 0 6
70655: PUSH
70656: LD_VAR 0 4
70660: NOT
70661: AND
70662: IFFALSE 70737
// begin tmp := result ;
70664: LD_ADDR_VAR 0 9
70668: PUSH
70669: LD_VAR 0 6
70673: ST_TO_ADDR
// for i = tmp downto 1 do
70674: LD_ADDR_VAR 0 7
70678: PUSH
70679: DOUBLE
70680: LD_VAR 0 9
70684: INC
70685: ST_TO_ADDR
70686: LD_INT 1
70688: PUSH
70689: FOR_DOWNTO
70690: IFFALSE 70735
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
70692: LD_ADDR_VAR 0 6
70696: PUSH
70697: LD_VAR 0 6
70701: PPUSH
70702: LD_VAR 0 9
70706: PUSH
70707: LD_VAR 0 7
70711: MINUS
70712: PUSH
70713: LD_INT 1
70715: PLUS
70716: PPUSH
70717: LD_VAR 0 9
70721: PUSH
70722: LD_VAR 0 7
70726: ARRAY
70727: PPUSH
70728: CALL_OW 1
70732: ST_TO_ADDR
70733: GO 70689
70735: POP
70736: POP
// end ; tmp := [ ] ;
70737: LD_ADDR_VAR 0 9
70741: PUSH
70742: EMPTY
70743: ST_TO_ADDR
// if mode then
70744: LD_VAR 0 5
70748: IFFALSE 70817
// begin for i = 1 to result do
70750: LD_ADDR_VAR 0 7
70754: PUSH
70755: DOUBLE
70756: LD_INT 1
70758: DEC
70759: ST_TO_ADDR
70760: LD_VAR 0 6
70764: PUSH
70765: FOR_TO
70766: IFFALSE 70805
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
70768: LD_ADDR_VAR 0 9
70772: PUSH
70773: LD_VAR 0 9
70777: PPUSH
70778: LD_VAR 0 7
70782: PPUSH
70783: LD_VAR 0 6
70787: PUSH
70788: LD_VAR 0 7
70792: ARRAY
70793: PUSH
70794: LD_INT 1
70796: ARRAY
70797: PPUSH
70798: CALL_OW 1
70802: ST_TO_ADDR
70803: GO 70765
70805: POP
70806: POP
// result := tmp ;
70807: LD_ADDR_VAR 0 6
70811: PUSH
70812: LD_VAR 0 9
70816: ST_TO_ADDR
// end ; end ;
70817: LD_VAR 0 6
70821: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
70822: LD_INT 0
70824: PPUSH
70825: PPUSH
70826: PPUSH
70827: PPUSH
70828: PPUSH
70829: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
70830: LD_ADDR_VAR 0 5
70834: PUSH
70835: LD_INT 0
70837: PUSH
70838: LD_INT 0
70840: PUSH
70841: LD_INT 0
70843: PUSH
70844: EMPTY
70845: PUSH
70846: EMPTY
70847: LIST
70848: LIST
70849: LIST
70850: LIST
70851: ST_TO_ADDR
// if not x or not y then
70852: LD_VAR 0 2
70856: NOT
70857: PUSH
70858: LD_VAR 0 3
70862: NOT
70863: OR
70864: IFFALSE 70868
// exit ;
70866: GO 72514
// if not range then
70868: LD_VAR 0 4
70872: NOT
70873: IFFALSE 70883
// range := 10 ;
70875: LD_ADDR_VAR 0 4
70879: PUSH
70880: LD_INT 10
70882: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
70883: LD_ADDR_VAR 0 8
70887: PUSH
70888: LD_INT 81
70890: PUSH
70891: LD_VAR 0 1
70895: PUSH
70896: EMPTY
70897: LIST
70898: LIST
70899: PUSH
70900: LD_INT 92
70902: PUSH
70903: LD_VAR 0 2
70907: PUSH
70908: LD_VAR 0 3
70912: PUSH
70913: LD_VAR 0 4
70917: PUSH
70918: EMPTY
70919: LIST
70920: LIST
70921: LIST
70922: LIST
70923: PUSH
70924: LD_INT 3
70926: PUSH
70927: LD_INT 21
70929: PUSH
70930: LD_INT 3
70932: PUSH
70933: EMPTY
70934: LIST
70935: LIST
70936: PUSH
70937: EMPTY
70938: LIST
70939: LIST
70940: PUSH
70941: EMPTY
70942: LIST
70943: LIST
70944: LIST
70945: PPUSH
70946: CALL_OW 69
70950: ST_TO_ADDR
// if not tmp then
70951: LD_VAR 0 8
70955: NOT
70956: IFFALSE 70960
// exit ;
70958: GO 72514
// for i in tmp do
70960: LD_ADDR_VAR 0 6
70964: PUSH
70965: LD_VAR 0 8
70969: PUSH
70970: FOR_IN
70971: IFFALSE 72489
// begin points := [ 0 , 0 , 0 ] ;
70973: LD_ADDR_VAR 0 9
70977: PUSH
70978: LD_INT 0
70980: PUSH
70981: LD_INT 0
70983: PUSH
70984: LD_INT 0
70986: PUSH
70987: EMPTY
70988: LIST
70989: LIST
70990: LIST
70991: ST_TO_ADDR
// bpoints := 1 ;
70992: LD_ADDR_VAR 0 10
70996: PUSH
70997: LD_INT 1
70999: ST_TO_ADDR
// case GetType ( i ) of unit_human :
71000: LD_VAR 0 6
71004: PPUSH
71005: CALL_OW 247
71009: PUSH
71010: LD_INT 1
71012: DOUBLE
71013: EQUAL
71014: IFTRUE 71018
71016: GO 71596
71018: POP
// begin if GetClass ( i ) = 1 then
71019: LD_VAR 0 6
71023: PPUSH
71024: CALL_OW 257
71028: PUSH
71029: LD_INT 1
71031: EQUAL
71032: IFFALSE 71053
// points := [ 10 , 5 , 3 ] ;
71034: LD_ADDR_VAR 0 9
71038: PUSH
71039: LD_INT 10
71041: PUSH
71042: LD_INT 5
71044: PUSH
71045: LD_INT 3
71047: PUSH
71048: EMPTY
71049: LIST
71050: LIST
71051: LIST
71052: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
71053: LD_VAR 0 6
71057: PPUSH
71058: CALL_OW 257
71062: PUSH
71063: LD_INT 2
71065: PUSH
71066: LD_INT 3
71068: PUSH
71069: LD_INT 4
71071: PUSH
71072: EMPTY
71073: LIST
71074: LIST
71075: LIST
71076: IN
71077: IFFALSE 71098
// points := [ 3 , 2 , 1 ] ;
71079: LD_ADDR_VAR 0 9
71083: PUSH
71084: LD_INT 3
71086: PUSH
71087: LD_INT 2
71089: PUSH
71090: LD_INT 1
71092: PUSH
71093: EMPTY
71094: LIST
71095: LIST
71096: LIST
71097: ST_TO_ADDR
// if GetClass ( i ) = 5 then
71098: LD_VAR 0 6
71102: PPUSH
71103: CALL_OW 257
71107: PUSH
71108: LD_INT 5
71110: EQUAL
71111: IFFALSE 71132
// points := [ 130 , 5 , 2 ] ;
71113: LD_ADDR_VAR 0 9
71117: PUSH
71118: LD_INT 130
71120: PUSH
71121: LD_INT 5
71123: PUSH
71124: LD_INT 2
71126: PUSH
71127: EMPTY
71128: LIST
71129: LIST
71130: LIST
71131: ST_TO_ADDR
// if GetClass ( i ) = 8 then
71132: LD_VAR 0 6
71136: PPUSH
71137: CALL_OW 257
71141: PUSH
71142: LD_INT 8
71144: EQUAL
71145: IFFALSE 71166
// points := [ 35 , 35 , 30 ] ;
71147: LD_ADDR_VAR 0 9
71151: PUSH
71152: LD_INT 35
71154: PUSH
71155: LD_INT 35
71157: PUSH
71158: LD_INT 30
71160: PUSH
71161: EMPTY
71162: LIST
71163: LIST
71164: LIST
71165: ST_TO_ADDR
// if GetClass ( i ) = 9 then
71166: LD_VAR 0 6
71170: PPUSH
71171: CALL_OW 257
71175: PUSH
71176: LD_INT 9
71178: EQUAL
71179: IFFALSE 71200
// points := [ 20 , 55 , 40 ] ;
71181: LD_ADDR_VAR 0 9
71185: PUSH
71186: LD_INT 20
71188: PUSH
71189: LD_INT 55
71191: PUSH
71192: LD_INT 40
71194: PUSH
71195: EMPTY
71196: LIST
71197: LIST
71198: LIST
71199: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
71200: LD_VAR 0 6
71204: PPUSH
71205: CALL_OW 257
71209: PUSH
71210: LD_INT 12
71212: PUSH
71213: LD_INT 16
71215: PUSH
71216: EMPTY
71217: LIST
71218: LIST
71219: IN
71220: IFFALSE 71241
// points := [ 5 , 3 , 2 ] ;
71222: LD_ADDR_VAR 0 9
71226: PUSH
71227: LD_INT 5
71229: PUSH
71230: LD_INT 3
71232: PUSH
71233: LD_INT 2
71235: PUSH
71236: EMPTY
71237: LIST
71238: LIST
71239: LIST
71240: ST_TO_ADDR
// if GetClass ( i ) = 17 then
71241: LD_VAR 0 6
71245: PPUSH
71246: CALL_OW 257
71250: PUSH
71251: LD_INT 17
71253: EQUAL
71254: IFFALSE 71275
// points := [ 100 , 50 , 75 ] ;
71256: LD_ADDR_VAR 0 9
71260: PUSH
71261: LD_INT 100
71263: PUSH
71264: LD_INT 50
71266: PUSH
71267: LD_INT 75
71269: PUSH
71270: EMPTY
71271: LIST
71272: LIST
71273: LIST
71274: ST_TO_ADDR
// if GetClass ( i ) = 15 then
71275: LD_VAR 0 6
71279: PPUSH
71280: CALL_OW 257
71284: PUSH
71285: LD_INT 15
71287: EQUAL
71288: IFFALSE 71309
// points := [ 10 , 5 , 3 ] ;
71290: LD_ADDR_VAR 0 9
71294: PUSH
71295: LD_INT 10
71297: PUSH
71298: LD_INT 5
71300: PUSH
71301: LD_INT 3
71303: PUSH
71304: EMPTY
71305: LIST
71306: LIST
71307: LIST
71308: ST_TO_ADDR
// if GetClass ( i ) = 14 then
71309: LD_VAR 0 6
71313: PPUSH
71314: CALL_OW 257
71318: PUSH
71319: LD_INT 14
71321: EQUAL
71322: IFFALSE 71343
// points := [ 10 , 0 , 0 ] ;
71324: LD_ADDR_VAR 0 9
71328: PUSH
71329: LD_INT 10
71331: PUSH
71332: LD_INT 0
71334: PUSH
71335: LD_INT 0
71337: PUSH
71338: EMPTY
71339: LIST
71340: LIST
71341: LIST
71342: ST_TO_ADDR
// if GetClass ( i ) = 11 then
71343: LD_VAR 0 6
71347: PPUSH
71348: CALL_OW 257
71352: PUSH
71353: LD_INT 11
71355: EQUAL
71356: IFFALSE 71377
// points := [ 30 , 10 , 5 ] ;
71358: LD_ADDR_VAR 0 9
71362: PUSH
71363: LD_INT 30
71365: PUSH
71366: LD_INT 10
71368: PUSH
71369: LD_INT 5
71371: PUSH
71372: EMPTY
71373: LIST
71374: LIST
71375: LIST
71376: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
71377: LD_VAR 0 1
71381: PPUSH
71382: LD_INT 5
71384: PPUSH
71385: CALL_OW 321
71389: PUSH
71390: LD_INT 2
71392: EQUAL
71393: IFFALSE 71410
// bpoints := bpoints * 1.8 ;
71395: LD_ADDR_VAR 0 10
71399: PUSH
71400: LD_VAR 0 10
71404: PUSH
71405: LD_REAL  1.80000000000000E+0000
71408: MUL
71409: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
71410: LD_VAR 0 6
71414: PPUSH
71415: CALL_OW 257
71419: PUSH
71420: LD_INT 1
71422: PUSH
71423: LD_INT 2
71425: PUSH
71426: LD_INT 3
71428: PUSH
71429: LD_INT 4
71431: PUSH
71432: EMPTY
71433: LIST
71434: LIST
71435: LIST
71436: LIST
71437: IN
71438: PUSH
71439: LD_VAR 0 1
71443: PPUSH
71444: LD_INT 51
71446: PPUSH
71447: CALL_OW 321
71451: PUSH
71452: LD_INT 2
71454: EQUAL
71455: AND
71456: IFFALSE 71473
// bpoints := bpoints * 1.2 ;
71458: LD_ADDR_VAR 0 10
71462: PUSH
71463: LD_VAR 0 10
71467: PUSH
71468: LD_REAL  1.20000000000000E+0000
71471: MUL
71472: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
71473: LD_VAR 0 6
71477: PPUSH
71478: CALL_OW 257
71482: PUSH
71483: LD_INT 5
71485: PUSH
71486: LD_INT 7
71488: PUSH
71489: LD_INT 9
71491: PUSH
71492: EMPTY
71493: LIST
71494: LIST
71495: LIST
71496: IN
71497: PUSH
71498: LD_VAR 0 1
71502: PPUSH
71503: LD_INT 52
71505: PPUSH
71506: CALL_OW 321
71510: PUSH
71511: LD_INT 2
71513: EQUAL
71514: AND
71515: IFFALSE 71532
// bpoints := bpoints * 1.5 ;
71517: LD_ADDR_VAR 0 10
71521: PUSH
71522: LD_VAR 0 10
71526: PUSH
71527: LD_REAL  1.50000000000000E+0000
71530: MUL
71531: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
71532: LD_VAR 0 1
71536: PPUSH
71537: LD_INT 66
71539: PPUSH
71540: CALL_OW 321
71544: PUSH
71545: LD_INT 2
71547: EQUAL
71548: IFFALSE 71565
// bpoints := bpoints * 1.1 ;
71550: LD_ADDR_VAR 0 10
71554: PUSH
71555: LD_VAR 0 10
71559: PUSH
71560: LD_REAL  1.10000000000000E+0000
71563: MUL
71564: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
71565: LD_ADDR_VAR 0 10
71569: PUSH
71570: LD_VAR 0 10
71574: PUSH
71575: LD_VAR 0 6
71579: PPUSH
71580: LD_INT 1
71582: PPUSH
71583: CALL_OW 259
71587: PUSH
71588: LD_REAL  1.15000000000000E+0000
71591: MUL
71592: MUL
71593: ST_TO_ADDR
// end ; unit_vehicle :
71594: GO 72418
71596: LD_INT 2
71598: DOUBLE
71599: EQUAL
71600: IFTRUE 71604
71602: GO 72406
71604: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
71605: LD_VAR 0 6
71609: PPUSH
71610: CALL_OW 264
71614: PUSH
71615: LD_INT 2
71617: PUSH
71618: LD_INT 42
71620: PUSH
71621: LD_INT 24
71623: PUSH
71624: EMPTY
71625: LIST
71626: LIST
71627: LIST
71628: IN
71629: IFFALSE 71650
// points := [ 25 , 5 , 3 ] ;
71631: LD_ADDR_VAR 0 9
71635: PUSH
71636: LD_INT 25
71638: PUSH
71639: LD_INT 5
71641: PUSH
71642: LD_INT 3
71644: PUSH
71645: EMPTY
71646: LIST
71647: LIST
71648: LIST
71649: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
71650: LD_VAR 0 6
71654: PPUSH
71655: CALL_OW 264
71659: PUSH
71660: LD_INT 4
71662: PUSH
71663: LD_INT 43
71665: PUSH
71666: LD_INT 25
71668: PUSH
71669: EMPTY
71670: LIST
71671: LIST
71672: LIST
71673: IN
71674: IFFALSE 71695
// points := [ 40 , 15 , 5 ] ;
71676: LD_ADDR_VAR 0 9
71680: PUSH
71681: LD_INT 40
71683: PUSH
71684: LD_INT 15
71686: PUSH
71687: LD_INT 5
71689: PUSH
71690: EMPTY
71691: LIST
71692: LIST
71693: LIST
71694: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
71695: LD_VAR 0 6
71699: PPUSH
71700: CALL_OW 264
71704: PUSH
71705: LD_INT 3
71707: PUSH
71708: LD_INT 23
71710: PUSH
71711: EMPTY
71712: LIST
71713: LIST
71714: IN
71715: IFFALSE 71736
// points := [ 7 , 25 , 8 ] ;
71717: LD_ADDR_VAR 0 9
71721: PUSH
71722: LD_INT 7
71724: PUSH
71725: LD_INT 25
71727: PUSH
71728: LD_INT 8
71730: PUSH
71731: EMPTY
71732: LIST
71733: LIST
71734: LIST
71735: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
71736: LD_VAR 0 6
71740: PPUSH
71741: CALL_OW 264
71745: PUSH
71746: LD_INT 5
71748: PUSH
71749: LD_INT 27
71751: PUSH
71752: LD_INT 44
71754: PUSH
71755: EMPTY
71756: LIST
71757: LIST
71758: LIST
71759: IN
71760: IFFALSE 71781
// points := [ 14 , 50 , 16 ] ;
71762: LD_ADDR_VAR 0 9
71766: PUSH
71767: LD_INT 14
71769: PUSH
71770: LD_INT 50
71772: PUSH
71773: LD_INT 16
71775: PUSH
71776: EMPTY
71777: LIST
71778: LIST
71779: LIST
71780: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
71781: LD_VAR 0 6
71785: PPUSH
71786: CALL_OW 264
71790: PUSH
71791: LD_INT 6
71793: PUSH
71794: LD_INT 46
71796: PUSH
71797: EMPTY
71798: LIST
71799: LIST
71800: IN
71801: IFFALSE 71822
// points := [ 32 , 120 , 70 ] ;
71803: LD_ADDR_VAR 0 9
71807: PUSH
71808: LD_INT 32
71810: PUSH
71811: LD_INT 120
71813: PUSH
71814: LD_INT 70
71816: PUSH
71817: EMPTY
71818: LIST
71819: LIST
71820: LIST
71821: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
71822: LD_VAR 0 6
71826: PPUSH
71827: CALL_OW 264
71831: PUSH
71832: LD_INT 7
71834: PUSH
71835: LD_INT 28
71837: PUSH
71838: LD_INT 45
71840: PUSH
71841: EMPTY
71842: LIST
71843: LIST
71844: LIST
71845: IN
71846: IFFALSE 71867
// points := [ 35 , 20 , 45 ] ;
71848: LD_ADDR_VAR 0 9
71852: PUSH
71853: LD_INT 35
71855: PUSH
71856: LD_INT 20
71858: PUSH
71859: LD_INT 45
71861: PUSH
71862: EMPTY
71863: LIST
71864: LIST
71865: LIST
71866: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
71867: LD_VAR 0 6
71871: PPUSH
71872: CALL_OW 264
71876: PUSH
71877: LD_INT 47
71879: PUSH
71880: EMPTY
71881: LIST
71882: IN
71883: IFFALSE 71904
// points := [ 67 , 45 , 75 ] ;
71885: LD_ADDR_VAR 0 9
71889: PUSH
71890: LD_INT 67
71892: PUSH
71893: LD_INT 45
71895: PUSH
71896: LD_INT 75
71898: PUSH
71899: EMPTY
71900: LIST
71901: LIST
71902: LIST
71903: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
71904: LD_VAR 0 6
71908: PPUSH
71909: CALL_OW 264
71913: PUSH
71914: LD_INT 26
71916: PUSH
71917: EMPTY
71918: LIST
71919: IN
71920: IFFALSE 71941
// points := [ 120 , 30 , 80 ] ;
71922: LD_ADDR_VAR 0 9
71926: PUSH
71927: LD_INT 120
71929: PUSH
71930: LD_INT 30
71932: PUSH
71933: LD_INT 80
71935: PUSH
71936: EMPTY
71937: LIST
71938: LIST
71939: LIST
71940: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
71941: LD_VAR 0 6
71945: PPUSH
71946: CALL_OW 264
71950: PUSH
71951: LD_INT 22
71953: PUSH
71954: EMPTY
71955: LIST
71956: IN
71957: IFFALSE 71978
// points := [ 40 , 1 , 1 ] ;
71959: LD_ADDR_VAR 0 9
71963: PUSH
71964: LD_INT 40
71966: PUSH
71967: LD_INT 1
71969: PUSH
71970: LD_INT 1
71972: PUSH
71973: EMPTY
71974: LIST
71975: LIST
71976: LIST
71977: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
71978: LD_VAR 0 6
71982: PPUSH
71983: CALL_OW 264
71987: PUSH
71988: LD_INT 29
71990: PUSH
71991: EMPTY
71992: LIST
71993: IN
71994: IFFALSE 72015
// points := [ 70 , 200 , 400 ] ;
71996: LD_ADDR_VAR 0 9
72000: PUSH
72001: LD_INT 70
72003: PUSH
72004: LD_INT 200
72006: PUSH
72007: LD_INT 400
72009: PUSH
72010: EMPTY
72011: LIST
72012: LIST
72013: LIST
72014: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
72015: LD_VAR 0 6
72019: PPUSH
72020: CALL_OW 264
72024: PUSH
72025: LD_INT 14
72027: PUSH
72028: LD_INT 53
72030: PUSH
72031: EMPTY
72032: LIST
72033: LIST
72034: IN
72035: IFFALSE 72056
// points := [ 40 , 10 , 20 ] ;
72037: LD_ADDR_VAR 0 9
72041: PUSH
72042: LD_INT 40
72044: PUSH
72045: LD_INT 10
72047: PUSH
72048: LD_INT 20
72050: PUSH
72051: EMPTY
72052: LIST
72053: LIST
72054: LIST
72055: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
72056: LD_VAR 0 6
72060: PPUSH
72061: CALL_OW 264
72065: PUSH
72066: LD_INT 9
72068: PUSH
72069: EMPTY
72070: LIST
72071: IN
72072: IFFALSE 72093
// points := [ 5 , 70 , 20 ] ;
72074: LD_ADDR_VAR 0 9
72078: PUSH
72079: LD_INT 5
72081: PUSH
72082: LD_INT 70
72084: PUSH
72085: LD_INT 20
72087: PUSH
72088: EMPTY
72089: LIST
72090: LIST
72091: LIST
72092: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
72093: LD_VAR 0 6
72097: PPUSH
72098: CALL_OW 264
72102: PUSH
72103: LD_INT 10
72105: PUSH
72106: EMPTY
72107: LIST
72108: IN
72109: IFFALSE 72130
// points := [ 35 , 110 , 70 ] ;
72111: LD_ADDR_VAR 0 9
72115: PUSH
72116: LD_INT 35
72118: PUSH
72119: LD_INT 110
72121: PUSH
72122: LD_INT 70
72124: PUSH
72125: EMPTY
72126: LIST
72127: LIST
72128: LIST
72129: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
72130: LD_VAR 0 6
72134: PPUSH
72135: CALL_OW 265
72139: PUSH
72140: LD_INT 25
72142: EQUAL
72143: IFFALSE 72164
// points := [ 80 , 65 , 100 ] ;
72145: LD_ADDR_VAR 0 9
72149: PUSH
72150: LD_INT 80
72152: PUSH
72153: LD_INT 65
72155: PUSH
72156: LD_INT 100
72158: PUSH
72159: EMPTY
72160: LIST
72161: LIST
72162: LIST
72163: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
72164: LD_VAR 0 6
72168: PPUSH
72169: CALL_OW 263
72173: PUSH
72174: LD_INT 1
72176: EQUAL
72177: IFFALSE 72212
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
72179: LD_ADDR_VAR 0 10
72183: PUSH
72184: LD_VAR 0 10
72188: PUSH
72189: LD_VAR 0 6
72193: PPUSH
72194: CALL_OW 311
72198: PPUSH
72199: LD_INT 3
72201: PPUSH
72202: CALL_OW 259
72206: PUSH
72207: LD_INT 4
72209: MUL
72210: MUL
72211: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
72212: LD_VAR 0 6
72216: PPUSH
72217: CALL_OW 263
72221: PUSH
72222: LD_INT 2
72224: EQUAL
72225: IFFALSE 72276
// begin j := IsControledBy ( i ) ;
72227: LD_ADDR_VAR 0 7
72231: PUSH
72232: LD_VAR 0 6
72236: PPUSH
72237: CALL_OW 312
72241: ST_TO_ADDR
// if j then
72242: LD_VAR 0 7
72246: IFFALSE 72276
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
72248: LD_ADDR_VAR 0 10
72252: PUSH
72253: LD_VAR 0 10
72257: PUSH
72258: LD_VAR 0 7
72262: PPUSH
72263: LD_INT 3
72265: PPUSH
72266: CALL_OW 259
72270: PUSH
72271: LD_INT 3
72273: MUL
72274: MUL
72275: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
72276: LD_VAR 0 6
72280: PPUSH
72281: CALL_OW 264
72285: PUSH
72286: LD_INT 5
72288: PUSH
72289: LD_INT 6
72291: PUSH
72292: LD_INT 46
72294: PUSH
72295: LD_INT 44
72297: PUSH
72298: LD_INT 47
72300: PUSH
72301: LD_INT 45
72303: PUSH
72304: LD_INT 28
72306: PUSH
72307: LD_INT 7
72309: PUSH
72310: LD_INT 27
72312: PUSH
72313: LD_INT 29
72315: PUSH
72316: EMPTY
72317: LIST
72318: LIST
72319: LIST
72320: LIST
72321: LIST
72322: LIST
72323: LIST
72324: LIST
72325: LIST
72326: LIST
72327: IN
72328: PUSH
72329: LD_VAR 0 1
72333: PPUSH
72334: LD_INT 52
72336: PPUSH
72337: CALL_OW 321
72341: PUSH
72342: LD_INT 2
72344: EQUAL
72345: AND
72346: IFFALSE 72363
// bpoints := bpoints * 1.2 ;
72348: LD_ADDR_VAR 0 10
72352: PUSH
72353: LD_VAR 0 10
72357: PUSH
72358: LD_REAL  1.20000000000000E+0000
72361: MUL
72362: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
72363: LD_VAR 0 6
72367: PPUSH
72368: CALL_OW 264
72372: PUSH
72373: LD_INT 6
72375: PUSH
72376: LD_INT 46
72378: PUSH
72379: LD_INT 47
72381: PUSH
72382: EMPTY
72383: LIST
72384: LIST
72385: LIST
72386: IN
72387: IFFALSE 72404
// bpoints := bpoints * 1.2 ;
72389: LD_ADDR_VAR 0 10
72393: PUSH
72394: LD_VAR 0 10
72398: PUSH
72399: LD_REAL  1.20000000000000E+0000
72402: MUL
72403: ST_TO_ADDR
// end ; unit_building :
72404: GO 72418
72406: LD_INT 3
72408: DOUBLE
72409: EQUAL
72410: IFTRUE 72414
72412: GO 72417
72414: POP
// ; end ;
72415: GO 72418
72417: POP
// for j = 1 to 3 do
72418: LD_ADDR_VAR 0 7
72422: PUSH
72423: DOUBLE
72424: LD_INT 1
72426: DEC
72427: ST_TO_ADDR
72428: LD_INT 3
72430: PUSH
72431: FOR_TO
72432: IFFALSE 72485
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
72434: LD_ADDR_VAR 0 5
72438: PUSH
72439: LD_VAR 0 5
72443: PPUSH
72444: LD_VAR 0 7
72448: PPUSH
72449: LD_VAR 0 5
72453: PUSH
72454: LD_VAR 0 7
72458: ARRAY
72459: PUSH
72460: LD_VAR 0 9
72464: PUSH
72465: LD_VAR 0 7
72469: ARRAY
72470: PUSH
72471: LD_VAR 0 10
72475: MUL
72476: PLUS
72477: PPUSH
72478: CALL_OW 1
72482: ST_TO_ADDR
72483: GO 72431
72485: POP
72486: POP
// end ;
72487: GO 70970
72489: POP
72490: POP
// result := Replace ( result , 4 , tmp ) ;
72491: LD_ADDR_VAR 0 5
72495: PUSH
72496: LD_VAR 0 5
72500: PPUSH
72501: LD_INT 4
72503: PPUSH
72504: LD_VAR 0 8
72508: PPUSH
72509: CALL_OW 1
72513: ST_TO_ADDR
// end ;
72514: LD_VAR 0 5
72518: RET
// export function DangerAtRange ( unit , range ) ; begin
72519: LD_INT 0
72521: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
72522: LD_ADDR_VAR 0 3
72526: PUSH
72527: LD_VAR 0 1
72531: PPUSH
72532: CALL_OW 255
72536: PPUSH
72537: LD_VAR 0 1
72541: PPUSH
72542: CALL_OW 250
72546: PPUSH
72547: LD_VAR 0 1
72551: PPUSH
72552: CALL_OW 251
72556: PPUSH
72557: LD_VAR 0 2
72561: PPUSH
72562: CALL 70822 0 4
72566: ST_TO_ADDR
// end ;
72567: LD_VAR 0 3
72571: RET
// export function DangerInArea ( side , area ) ; begin
72572: LD_INT 0
72574: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
72575: LD_ADDR_VAR 0 3
72579: PUSH
72580: LD_VAR 0 2
72584: PPUSH
72585: LD_INT 81
72587: PUSH
72588: LD_VAR 0 1
72592: PUSH
72593: EMPTY
72594: LIST
72595: LIST
72596: PPUSH
72597: CALL_OW 70
72601: ST_TO_ADDR
// end ;
72602: LD_VAR 0 3
72606: RET
// export function IsExtension ( b ) ; begin
72607: LD_INT 0
72609: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
72610: LD_ADDR_VAR 0 2
72614: PUSH
72615: LD_VAR 0 1
72619: PUSH
72620: LD_INT 23
72622: PUSH
72623: LD_INT 20
72625: PUSH
72626: LD_INT 22
72628: PUSH
72629: LD_INT 17
72631: PUSH
72632: LD_INT 24
72634: PUSH
72635: LD_INT 21
72637: PUSH
72638: LD_INT 19
72640: PUSH
72641: LD_INT 16
72643: PUSH
72644: LD_INT 25
72646: PUSH
72647: LD_INT 18
72649: PUSH
72650: EMPTY
72651: LIST
72652: LIST
72653: LIST
72654: LIST
72655: LIST
72656: LIST
72657: LIST
72658: LIST
72659: LIST
72660: LIST
72661: IN
72662: ST_TO_ADDR
// end ;
72663: LD_VAR 0 2
72667: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
72668: LD_INT 0
72670: PPUSH
72671: PPUSH
72672: PPUSH
// result := [ ] ;
72673: LD_ADDR_VAR 0 3
72677: PUSH
72678: EMPTY
72679: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
72680: LD_ADDR_VAR 0 4
72684: PUSH
72685: LD_VAR 0 2
72689: PPUSH
72690: LD_INT 21
72692: PUSH
72693: LD_INT 3
72695: PUSH
72696: EMPTY
72697: LIST
72698: LIST
72699: PPUSH
72700: CALL_OW 70
72704: ST_TO_ADDR
// if not tmp then
72705: LD_VAR 0 4
72709: NOT
72710: IFFALSE 72714
// exit ;
72712: GO 72772
// for i in tmp do
72714: LD_ADDR_VAR 0 5
72718: PUSH
72719: LD_VAR 0 4
72723: PUSH
72724: FOR_IN
72725: IFFALSE 72760
// if GetBase ( i ) <> base then
72727: LD_VAR 0 5
72731: PPUSH
72732: CALL_OW 274
72736: PUSH
72737: LD_VAR 0 1
72741: NONEQUAL
72742: IFFALSE 72758
// ComLinkToBase ( base , i ) ;
72744: LD_VAR 0 1
72748: PPUSH
72749: LD_VAR 0 5
72753: PPUSH
72754: CALL_OW 169
72758: GO 72724
72760: POP
72761: POP
// result := tmp ;
72762: LD_ADDR_VAR 0 3
72766: PUSH
72767: LD_VAR 0 4
72771: ST_TO_ADDR
// end ;
72772: LD_VAR 0 3
72776: RET
// export function ComComplete ( unit , b ) ; var i ; begin
72777: LD_INT 0
72779: PPUSH
72780: PPUSH
// if BuildingStatus ( b ) = bs_build then
72781: LD_VAR 0 2
72785: PPUSH
72786: CALL_OW 461
72790: PUSH
72791: LD_INT 1
72793: EQUAL
72794: IFFALSE 72854
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
72796: LD_VAR 0 1
72800: PPUSH
72801: LD_STRING h
72803: PUSH
72804: LD_VAR 0 2
72808: PPUSH
72809: CALL_OW 250
72813: PUSH
72814: LD_VAR 0 2
72818: PPUSH
72819: CALL_OW 251
72823: PUSH
72824: LD_VAR 0 2
72828: PUSH
72829: LD_INT 0
72831: PUSH
72832: LD_INT 0
72834: PUSH
72835: LD_INT 0
72837: PUSH
72838: EMPTY
72839: LIST
72840: LIST
72841: LIST
72842: LIST
72843: LIST
72844: LIST
72845: LIST
72846: PUSH
72847: EMPTY
72848: LIST
72849: PPUSH
72850: CALL_OW 446
// end ;
72854: LD_VAR 0 3
72858: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
72859: LD_INT 0
72861: PPUSH
72862: PPUSH
72863: PPUSH
72864: PPUSH
72865: PPUSH
72866: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
72867: LD_VAR 0 1
72871: NOT
72872: PUSH
72873: LD_VAR 0 1
72877: PPUSH
72878: CALL_OW 263
72882: PUSH
72883: LD_INT 2
72885: EQUAL
72886: NOT
72887: OR
72888: IFFALSE 72892
// exit ;
72890: GO 73208
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
72892: LD_ADDR_VAR 0 6
72896: PUSH
72897: LD_INT 22
72899: PUSH
72900: LD_VAR 0 1
72904: PPUSH
72905: CALL_OW 255
72909: PUSH
72910: EMPTY
72911: LIST
72912: LIST
72913: PUSH
72914: LD_INT 2
72916: PUSH
72917: LD_INT 30
72919: PUSH
72920: LD_INT 36
72922: PUSH
72923: EMPTY
72924: LIST
72925: LIST
72926: PUSH
72927: LD_INT 34
72929: PUSH
72930: LD_INT 31
72932: PUSH
72933: EMPTY
72934: LIST
72935: LIST
72936: PUSH
72937: EMPTY
72938: LIST
72939: LIST
72940: LIST
72941: PUSH
72942: EMPTY
72943: LIST
72944: LIST
72945: PPUSH
72946: CALL_OW 69
72950: ST_TO_ADDR
// if not tmp then
72951: LD_VAR 0 6
72955: NOT
72956: IFFALSE 72960
// exit ;
72958: GO 73208
// result := [ ] ;
72960: LD_ADDR_VAR 0 2
72964: PUSH
72965: EMPTY
72966: ST_TO_ADDR
// for i in tmp do
72967: LD_ADDR_VAR 0 3
72971: PUSH
72972: LD_VAR 0 6
72976: PUSH
72977: FOR_IN
72978: IFFALSE 73049
// begin t := UnitsInside ( i ) ;
72980: LD_ADDR_VAR 0 4
72984: PUSH
72985: LD_VAR 0 3
72989: PPUSH
72990: CALL_OW 313
72994: ST_TO_ADDR
// if t then
72995: LD_VAR 0 4
72999: IFFALSE 73047
// for j in t do
73001: LD_ADDR_VAR 0 7
73005: PUSH
73006: LD_VAR 0 4
73010: PUSH
73011: FOR_IN
73012: IFFALSE 73045
// result := Insert ( result , result + 1 , j ) ;
73014: LD_ADDR_VAR 0 2
73018: PUSH
73019: LD_VAR 0 2
73023: PPUSH
73024: LD_VAR 0 2
73028: PUSH
73029: LD_INT 1
73031: PLUS
73032: PPUSH
73033: LD_VAR 0 7
73037: PPUSH
73038: CALL_OW 2
73042: ST_TO_ADDR
73043: GO 73011
73045: POP
73046: POP
// end ;
73047: GO 72977
73049: POP
73050: POP
// if not result then
73051: LD_VAR 0 2
73055: NOT
73056: IFFALSE 73060
// exit ;
73058: GO 73208
// mech := result [ 1 ] ;
73060: LD_ADDR_VAR 0 5
73064: PUSH
73065: LD_VAR 0 2
73069: PUSH
73070: LD_INT 1
73072: ARRAY
73073: ST_TO_ADDR
// if result > 1 then
73074: LD_VAR 0 2
73078: PUSH
73079: LD_INT 1
73081: GREATER
73082: IFFALSE 73194
// for i = 2 to result do
73084: LD_ADDR_VAR 0 3
73088: PUSH
73089: DOUBLE
73090: LD_INT 2
73092: DEC
73093: ST_TO_ADDR
73094: LD_VAR 0 2
73098: PUSH
73099: FOR_TO
73100: IFFALSE 73192
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
73102: LD_ADDR_VAR 0 4
73106: PUSH
73107: LD_VAR 0 2
73111: PUSH
73112: LD_VAR 0 3
73116: ARRAY
73117: PPUSH
73118: LD_INT 3
73120: PPUSH
73121: CALL_OW 259
73125: PUSH
73126: LD_VAR 0 2
73130: PUSH
73131: LD_VAR 0 3
73135: ARRAY
73136: PPUSH
73137: CALL_OW 432
73141: MINUS
73142: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
73143: LD_VAR 0 4
73147: PUSH
73148: LD_VAR 0 5
73152: PPUSH
73153: LD_INT 3
73155: PPUSH
73156: CALL_OW 259
73160: PUSH
73161: LD_VAR 0 5
73165: PPUSH
73166: CALL_OW 432
73170: MINUS
73171: GREATEREQUAL
73172: IFFALSE 73190
// mech := result [ i ] ;
73174: LD_ADDR_VAR 0 5
73178: PUSH
73179: LD_VAR 0 2
73183: PUSH
73184: LD_VAR 0 3
73188: ARRAY
73189: ST_TO_ADDR
// end ;
73190: GO 73099
73192: POP
73193: POP
// ComLinkTo ( vehicle , mech ) ;
73194: LD_VAR 0 1
73198: PPUSH
73199: LD_VAR 0 5
73203: PPUSH
73204: CALL_OW 135
// end ;
73208: LD_VAR 0 2
73212: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
73213: LD_INT 0
73215: PPUSH
73216: PPUSH
73217: PPUSH
73218: PPUSH
73219: PPUSH
73220: PPUSH
73221: PPUSH
73222: PPUSH
73223: PPUSH
73224: PPUSH
73225: PPUSH
73226: PPUSH
73227: PPUSH
// result := [ ] ;
73228: LD_ADDR_VAR 0 7
73232: PUSH
73233: EMPTY
73234: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
73235: LD_VAR 0 1
73239: PPUSH
73240: CALL_OW 266
73244: PUSH
73245: LD_INT 0
73247: PUSH
73248: LD_INT 1
73250: PUSH
73251: EMPTY
73252: LIST
73253: LIST
73254: IN
73255: NOT
73256: IFFALSE 73260
// exit ;
73258: GO 74891
// if name then
73260: LD_VAR 0 3
73264: IFFALSE 73280
// SetBName ( base_dep , name ) ;
73266: LD_VAR 0 1
73270: PPUSH
73271: LD_VAR 0 3
73275: PPUSH
73276: CALL_OW 500
// base := GetBase ( base_dep ) ;
73280: LD_ADDR_VAR 0 15
73284: PUSH
73285: LD_VAR 0 1
73289: PPUSH
73290: CALL_OW 274
73294: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
73295: LD_ADDR_VAR 0 16
73299: PUSH
73300: LD_VAR 0 1
73304: PPUSH
73305: CALL_OW 255
73309: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
73310: LD_ADDR_VAR 0 17
73314: PUSH
73315: LD_VAR 0 1
73319: PPUSH
73320: CALL_OW 248
73324: ST_TO_ADDR
// if sources then
73325: LD_VAR 0 5
73329: IFFALSE 73376
// for i = 1 to 3 do
73331: LD_ADDR_VAR 0 8
73335: PUSH
73336: DOUBLE
73337: LD_INT 1
73339: DEC
73340: ST_TO_ADDR
73341: LD_INT 3
73343: PUSH
73344: FOR_TO
73345: IFFALSE 73374
// AddResourceType ( base , i , sources [ i ] ) ;
73347: LD_VAR 0 15
73351: PPUSH
73352: LD_VAR 0 8
73356: PPUSH
73357: LD_VAR 0 5
73361: PUSH
73362: LD_VAR 0 8
73366: ARRAY
73367: PPUSH
73368: CALL_OW 276
73372: GO 73344
73374: POP
73375: POP
// buildings := GetBaseBuildings ( base , area ) ;
73376: LD_ADDR_VAR 0 18
73380: PUSH
73381: LD_VAR 0 15
73385: PPUSH
73386: LD_VAR 0 2
73390: PPUSH
73391: CALL 72668 0 2
73395: ST_TO_ADDR
// InitHc ;
73396: CALL_OW 19
// InitUc ;
73400: CALL_OW 18
// uc_side := side ;
73404: LD_ADDR_OWVAR 20
73408: PUSH
73409: LD_VAR 0 16
73413: ST_TO_ADDR
// uc_nation := nation ;
73414: LD_ADDR_OWVAR 21
73418: PUSH
73419: LD_VAR 0 17
73423: ST_TO_ADDR
// if buildings then
73424: LD_VAR 0 18
73428: IFFALSE 74750
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
73430: LD_ADDR_VAR 0 19
73434: PUSH
73435: LD_VAR 0 18
73439: PPUSH
73440: LD_INT 2
73442: PUSH
73443: LD_INT 30
73445: PUSH
73446: LD_INT 29
73448: PUSH
73449: EMPTY
73450: LIST
73451: LIST
73452: PUSH
73453: LD_INT 30
73455: PUSH
73456: LD_INT 30
73458: PUSH
73459: EMPTY
73460: LIST
73461: LIST
73462: PUSH
73463: EMPTY
73464: LIST
73465: LIST
73466: LIST
73467: PPUSH
73468: CALL_OW 72
73472: ST_TO_ADDR
// if tmp then
73473: LD_VAR 0 19
73477: IFFALSE 73525
// for i in tmp do
73479: LD_ADDR_VAR 0 8
73483: PUSH
73484: LD_VAR 0 19
73488: PUSH
73489: FOR_IN
73490: IFFALSE 73523
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
73492: LD_VAR 0 8
73496: PPUSH
73497: CALL_OW 250
73501: PPUSH
73502: LD_VAR 0 8
73506: PPUSH
73507: CALL_OW 251
73511: PPUSH
73512: LD_VAR 0 16
73516: PPUSH
73517: CALL_OW 441
73521: GO 73489
73523: POP
73524: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
73525: LD_VAR 0 18
73529: PPUSH
73530: LD_INT 2
73532: PUSH
73533: LD_INT 30
73535: PUSH
73536: LD_INT 32
73538: PUSH
73539: EMPTY
73540: LIST
73541: LIST
73542: PUSH
73543: LD_INT 30
73545: PUSH
73546: LD_INT 33
73548: PUSH
73549: EMPTY
73550: LIST
73551: LIST
73552: PUSH
73553: EMPTY
73554: LIST
73555: LIST
73556: LIST
73557: PPUSH
73558: CALL_OW 72
73562: IFFALSE 73650
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
73564: LD_ADDR_VAR 0 8
73568: PUSH
73569: LD_VAR 0 18
73573: PPUSH
73574: LD_INT 2
73576: PUSH
73577: LD_INT 30
73579: PUSH
73580: LD_INT 32
73582: PUSH
73583: EMPTY
73584: LIST
73585: LIST
73586: PUSH
73587: LD_INT 30
73589: PUSH
73590: LD_INT 33
73592: PUSH
73593: EMPTY
73594: LIST
73595: LIST
73596: PUSH
73597: EMPTY
73598: LIST
73599: LIST
73600: LIST
73601: PPUSH
73602: CALL_OW 72
73606: PUSH
73607: FOR_IN
73608: IFFALSE 73648
// begin if not GetBWeapon ( i ) then
73610: LD_VAR 0 8
73614: PPUSH
73615: CALL_OW 269
73619: NOT
73620: IFFALSE 73646
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
73622: LD_VAR 0 8
73626: PPUSH
73627: LD_VAR 0 8
73631: PPUSH
73632: LD_VAR 0 2
73636: PPUSH
73637: CALL 74896 0 2
73641: PPUSH
73642: CALL_OW 431
// end ;
73646: GO 73607
73648: POP
73649: POP
// end ; for i = 1 to personel do
73650: LD_ADDR_VAR 0 8
73654: PUSH
73655: DOUBLE
73656: LD_INT 1
73658: DEC
73659: ST_TO_ADDR
73660: LD_VAR 0 6
73664: PUSH
73665: FOR_TO
73666: IFFALSE 74730
// begin if i > 4 then
73668: LD_VAR 0 8
73672: PUSH
73673: LD_INT 4
73675: GREATER
73676: IFFALSE 73680
// break ;
73678: GO 74730
// case i of 1 :
73680: LD_VAR 0 8
73684: PUSH
73685: LD_INT 1
73687: DOUBLE
73688: EQUAL
73689: IFTRUE 73693
73691: GO 73773
73693: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
73694: LD_ADDR_VAR 0 12
73698: PUSH
73699: LD_VAR 0 18
73703: PPUSH
73704: LD_INT 22
73706: PUSH
73707: LD_VAR 0 16
73711: PUSH
73712: EMPTY
73713: LIST
73714: LIST
73715: PUSH
73716: LD_INT 58
73718: PUSH
73719: EMPTY
73720: LIST
73721: PUSH
73722: LD_INT 2
73724: PUSH
73725: LD_INT 30
73727: PUSH
73728: LD_INT 32
73730: PUSH
73731: EMPTY
73732: LIST
73733: LIST
73734: PUSH
73735: LD_INT 30
73737: PUSH
73738: LD_INT 4
73740: PUSH
73741: EMPTY
73742: LIST
73743: LIST
73744: PUSH
73745: LD_INT 30
73747: PUSH
73748: LD_INT 5
73750: PUSH
73751: EMPTY
73752: LIST
73753: LIST
73754: PUSH
73755: EMPTY
73756: LIST
73757: LIST
73758: LIST
73759: LIST
73760: PUSH
73761: EMPTY
73762: LIST
73763: LIST
73764: LIST
73765: PPUSH
73766: CALL_OW 72
73770: ST_TO_ADDR
73771: GO 73995
73773: LD_INT 2
73775: DOUBLE
73776: EQUAL
73777: IFTRUE 73781
73779: GO 73843
73781: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
73782: LD_ADDR_VAR 0 12
73786: PUSH
73787: LD_VAR 0 18
73791: PPUSH
73792: LD_INT 22
73794: PUSH
73795: LD_VAR 0 16
73799: PUSH
73800: EMPTY
73801: LIST
73802: LIST
73803: PUSH
73804: LD_INT 2
73806: PUSH
73807: LD_INT 30
73809: PUSH
73810: LD_INT 0
73812: PUSH
73813: EMPTY
73814: LIST
73815: LIST
73816: PUSH
73817: LD_INT 30
73819: PUSH
73820: LD_INT 1
73822: PUSH
73823: EMPTY
73824: LIST
73825: LIST
73826: PUSH
73827: EMPTY
73828: LIST
73829: LIST
73830: LIST
73831: PUSH
73832: EMPTY
73833: LIST
73834: LIST
73835: PPUSH
73836: CALL_OW 72
73840: ST_TO_ADDR
73841: GO 73995
73843: LD_INT 3
73845: DOUBLE
73846: EQUAL
73847: IFTRUE 73851
73849: GO 73913
73851: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
73852: LD_ADDR_VAR 0 12
73856: PUSH
73857: LD_VAR 0 18
73861: PPUSH
73862: LD_INT 22
73864: PUSH
73865: LD_VAR 0 16
73869: PUSH
73870: EMPTY
73871: LIST
73872: LIST
73873: PUSH
73874: LD_INT 2
73876: PUSH
73877: LD_INT 30
73879: PUSH
73880: LD_INT 2
73882: PUSH
73883: EMPTY
73884: LIST
73885: LIST
73886: PUSH
73887: LD_INT 30
73889: PUSH
73890: LD_INT 3
73892: PUSH
73893: EMPTY
73894: LIST
73895: LIST
73896: PUSH
73897: EMPTY
73898: LIST
73899: LIST
73900: LIST
73901: PUSH
73902: EMPTY
73903: LIST
73904: LIST
73905: PPUSH
73906: CALL_OW 72
73910: ST_TO_ADDR
73911: GO 73995
73913: LD_INT 4
73915: DOUBLE
73916: EQUAL
73917: IFTRUE 73921
73919: GO 73994
73921: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
73922: LD_ADDR_VAR 0 12
73926: PUSH
73927: LD_VAR 0 18
73931: PPUSH
73932: LD_INT 22
73934: PUSH
73935: LD_VAR 0 16
73939: PUSH
73940: EMPTY
73941: LIST
73942: LIST
73943: PUSH
73944: LD_INT 2
73946: PUSH
73947: LD_INT 30
73949: PUSH
73950: LD_INT 6
73952: PUSH
73953: EMPTY
73954: LIST
73955: LIST
73956: PUSH
73957: LD_INT 30
73959: PUSH
73960: LD_INT 7
73962: PUSH
73963: EMPTY
73964: LIST
73965: LIST
73966: PUSH
73967: LD_INT 30
73969: PUSH
73970: LD_INT 8
73972: PUSH
73973: EMPTY
73974: LIST
73975: LIST
73976: PUSH
73977: EMPTY
73978: LIST
73979: LIST
73980: LIST
73981: LIST
73982: PUSH
73983: EMPTY
73984: LIST
73985: LIST
73986: PPUSH
73987: CALL_OW 72
73991: ST_TO_ADDR
73992: GO 73995
73994: POP
// if i = 1 then
73995: LD_VAR 0 8
73999: PUSH
74000: LD_INT 1
74002: EQUAL
74003: IFFALSE 74114
// begin tmp := [ ] ;
74005: LD_ADDR_VAR 0 19
74009: PUSH
74010: EMPTY
74011: ST_TO_ADDR
// for j in f do
74012: LD_ADDR_VAR 0 9
74016: PUSH
74017: LD_VAR 0 12
74021: PUSH
74022: FOR_IN
74023: IFFALSE 74096
// if GetBType ( j ) = b_bunker then
74025: LD_VAR 0 9
74029: PPUSH
74030: CALL_OW 266
74034: PUSH
74035: LD_INT 32
74037: EQUAL
74038: IFFALSE 74065
// tmp := Insert ( tmp , 1 , j ) else
74040: LD_ADDR_VAR 0 19
74044: PUSH
74045: LD_VAR 0 19
74049: PPUSH
74050: LD_INT 1
74052: PPUSH
74053: LD_VAR 0 9
74057: PPUSH
74058: CALL_OW 2
74062: ST_TO_ADDR
74063: GO 74094
// tmp := Insert ( tmp , tmp + 1 , j ) ;
74065: LD_ADDR_VAR 0 19
74069: PUSH
74070: LD_VAR 0 19
74074: PPUSH
74075: LD_VAR 0 19
74079: PUSH
74080: LD_INT 1
74082: PLUS
74083: PPUSH
74084: LD_VAR 0 9
74088: PPUSH
74089: CALL_OW 2
74093: ST_TO_ADDR
74094: GO 74022
74096: POP
74097: POP
// if tmp then
74098: LD_VAR 0 19
74102: IFFALSE 74114
// f := tmp ;
74104: LD_ADDR_VAR 0 12
74108: PUSH
74109: LD_VAR 0 19
74113: ST_TO_ADDR
// end ; x := personel [ i ] ;
74114: LD_ADDR_VAR 0 13
74118: PUSH
74119: LD_VAR 0 6
74123: PUSH
74124: LD_VAR 0 8
74128: ARRAY
74129: ST_TO_ADDR
// if x = - 1 then
74130: LD_VAR 0 13
74134: PUSH
74135: LD_INT 1
74137: NEG
74138: EQUAL
74139: IFFALSE 74348
// begin for j in f do
74141: LD_ADDR_VAR 0 9
74145: PUSH
74146: LD_VAR 0 12
74150: PUSH
74151: FOR_IN
74152: IFFALSE 74344
// repeat InitHc ;
74154: CALL_OW 19
// if GetBType ( j ) = b_barracks then
74158: LD_VAR 0 9
74162: PPUSH
74163: CALL_OW 266
74167: PUSH
74168: LD_INT 5
74170: EQUAL
74171: IFFALSE 74241
// begin if UnitsInside ( j ) < 3 then
74173: LD_VAR 0 9
74177: PPUSH
74178: CALL_OW 313
74182: PUSH
74183: LD_INT 3
74185: LESS
74186: IFFALSE 74222
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74188: LD_INT 0
74190: PPUSH
74191: LD_INT 5
74193: PUSH
74194: LD_INT 8
74196: PUSH
74197: LD_INT 9
74199: PUSH
74200: EMPTY
74201: LIST
74202: LIST
74203: LIST
74204: PUSH
74205: LD_VAR 0 17
74209: ARRAY
74210: PPUSH
74211: LD_VAR 0 4
74215: PPUSH
74216: CALL_OW 380
74220: GO 74239
// PrepareHuman ( false , i , skill ) ;
74222: LD_INT 0
74224: PPUSH
74225: LD_VAR 0 8
74229: PPUSH
74230: LD_VAR 0 4
74234: PPUSH
74235: CALL_OW 380
// end else
74239: GO 74258
// PrepareHuman ( false , i , skill ) ;
74241: LD_INT 0
74243: PPUSH
74244: LD_VAR 0 8
74248: PPUSH
74249: LD_VAR 0 4
74253: PPUSH
74254: CALL_OW 380
// un := CreateHuman ;
74258: LD_ADDR_VAR 0 14
74262: PUSH
74263: CALL_OW 44
74267: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74268: LD_ADDR_VAR 0 7
74272: PUSH
74273: LD_VAR 0 7
74277: PPUSH
74278: LD_INT 1
74280: PPUSH
74281: LD_VAR 0 14
74285: PPUSH
74286: CALL_OW 2
74290: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
74291: LD_VAR 0 14
74295: PPUSH
74296: LD_VAR 0 9
74300: PPUSH
74301: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
74305: LD_VAR 0 9
74309: PPUSH
74310: CALL_OW 313
74314: PUSH
74315: LD_INT 6
74317: EQUAL
74318: PUSH
74319: LD_VAR 0 9
74323: PPUSH
74324: CALL_OW 266
74328: PUSH
74329: LD_INT 32
74331: PUSH
74332: LD_INT 31
74334: PUSH
74335: EMPTY
74336: LIST
74337: LIST
74338: IN
74339: OR
74340: IFFALSE 74154
74342: GO 74151
74344: POP
74345: POP
// end else
74346: GO 74728
// for j = 1 to x do
74348: LD_ADDR_VAR 0 9
74352: PUSH
74353: DOUBLE
74354: LD_INT 1
74356: DEC
74357: ST_TO_ADDR
74358: LD_VAR 0 13
74362: PUSH
74363: FOR_TO
74364: IFFALSE 74726
// begin InitHc ;
74366: CALL_OW 19
// if not f then
74370: LD_VAR 0 12
74374: NOT
74375: IFFALSE 74464
// begin PrepareHuman ( false , i , skill ) ;
74377: LD_INT 0
74379: PPUSH
74380: LD_VAR 0 8
74384: PPUSH
74385: LD_VAR 0 4
74389: PPUSH
74390: CALL_OW 380
// un := CreateHuman ;
74394: LD_ADDR_VAR 0 14
74398: PUSH
74399: CALL_OW 44
74403: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74404: LD_ADDR_VAR 0 7
74408: PUSH
74409: LD_VAR 0 7
74413: PPUSH
74414: LD_INT 1
74416: PPUSH
74417: LD_VAR 0 14
74421: PPUSH
74422: CALL_OW 2
74426: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74427: LD_VAR 0 14
74431: PPUSH
74432: LD_VAR 0 1
74436: PPUSH
74437: CALL_OW 250
74441: PPUSH
74442: LD_VAR 0 1
74446: PPUSH
74447: CALL_OW 251
74451: PPUSH
74452: LD_INT 10
74454: PPUSH
74455: LD_INT 0
74457: PPUSH
74458: CALL_OW 50
// continue ;
74462: GO 74363
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
74464: LD_VAR 0 12
74468: PUSH
74469: LD_INT 1
74471: ARRAY
74472: PPUSH
74473: CALL_OW 313
74477: PUSH
74478: LD_VAR 0 12
74482: PUSH
74483: LD_INT 1
74485: ARRAY
74486: PPUSH
74487: CALL_OW 266
74491: PUSH
74492: LD_INT 32
74494: PUSH
74495: LD_INT 31
74497: PUSH
74498: EMPTY
74499: LIST
74500: LIST
74501: IN
74502: AND
74503: PUSH
74504: LD_VAR 0 12
74508: PUSH
74509: LD_INT 1
74511: ARRAY
74512: PPUSH
74513: CALL_OW 313
74517: PUSH
74518: LD_INT 6
74520: EQUAL
74521: OR
74522: IFFALSE 74542
// f := Delete ( f , 1 ) ;
74524: LD_ADDR_VAR 0 12
74528: PUSH
74529: LD_VAR 0 12
74533: PPUSH
74534: LD_INT 1
74536: PPUSH
74537: CALL_OW 3
74541: ST_TO_ADDR
// if not f then
74542: LD_VAR 0 12
74546: NOT
74547: IFFALSE 74565
// begin x := x + 2 ;
74549: LD_ADDR_VAR 0 13
74553: PUSH
74554: LD_VAR 0 13
74558: PUSH
74559: LD_INT 2
74561: PLUS
74562: ST_TO_ADDR
// continue ;
74563: GO 74363
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
74565: LD_VAR 0 12
74569: PUSH
74570: LD_INT 1
74572: ARRAY
74573: PPUSH
74574: CALL_OW 266
74578: PUSH
74579: LD_INT 5
74581: EQUAL
74582: IFFALSE 74656
// begin if UnitsInside ( f [ 1 ] ) < 3 then
74584: LD_VAR 0 12
74588: PUSH
74589: LD_INT 1
74591: ARRAY
74592: PPUSH
74593: CALL_OW 313
74597: PUSH
74598: LD_INT 3
74600: LESS
74601: IFFALSE 74637
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74603: LD_INT 0
74605: PPUSH
74606: LD_INT 5
74608: PUSH
74609: LD_INT 8
74611: PUSH
74612: LD_INT 9
74614: PUSH
74615: EMPTY
74616: LIST
74617: LIST
74618: LIST
74619: PUSH
74620: LD_VAR 0 17
74624: ARRAY
74625: PPUSH
74626: LD_VAR 0 4
74630: PPUSH
74631: CALL_OW 380
74635: GO 74654
// PrepareHuman ( false , i , skill ) ;
74637: LD_INT 0
74639: PPUSH
74640: LD_VAR 0 8
74644: PPUSH
74645: LD_VAR 0 4
74649: PPUSH
74650: CALL_OW 380
// end else
74654: GO 74673
// PrepareHuman ( false , i , skill ) ;
74656: LD_INT 0
74658: PPUSH
74659: LD_VAR 0 8
74663: PPUSH
74664: LD_VAR 0 4
74668: PPUSH
74669: CALL_OW 380
// un := CreateHuman ;
74673: LD_ADDR_VAR 0 14
74677: PUSH
74678: CALL_OW 44
74682: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74683: LD_ADDR_VAR 0 7
74687: PUSH
74688: LD_VAR 0 7
74692: PPUSH
74693: LD_INT 1
74695: PPUSH
74696: LD_VAR 0 14
74700: PPUSH
74701: CALL_OW 2
74705: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
74706: LD_VAR 0 14
74710: PPUSH
74711: LD_VAR 0 12
74715: PUSH
74716: LD_INT 1
74718: ARRAY
74719: PPUSH
74720: CALL_OW 52
// end ;
74724: GO 74363
74726: POP
74727: POP
// end ;
74728: GO 73665
74730: POP
74731: POP
// result := result ^ buildings ;
74732: LD_ADDR_VAR 0 7
74736: PUSH
74737: LD_VAR 0 7
74741: PUSH
74742: LD_VAR 0 18
74746: ADD
74747: ST_TO_ADDR
// end else
74748: GO 74891
// begin for i = 1 to personel do
74750: LD_ADDR_VAR 0 8
74754: PUSH
74755: DOUBLE
74756: LD_INT 1
74758: DEC
74759: ST_TO_ADDR
74760: LD_VAR 0 6
74764: PUSH
74765: FOR_TO
74766: IFFALSE 74889
// begin if i > 4 then
74768: LD_VAR 0 8
74772: PUSH
74773: LD_INT 4
74775: GREATER
74776: IFFALSE 74780
// break ;
74778: GO 74889
// x := personel [ i ] ;
74780: LD_ADDR_VAR 0 13
74784: PUSH
74785: LD_VAR 0 6
74789: PUSH
74790: LD_VAR 0 8
74794: ARRAY
74795: ST_TO_ADDR
// if x = - 1 then
74796: LD_VAR 0 13
74800: PUSH
74801: LD_INT 1
74803: NEG
74804: EQUAL
74805: IFFALSE 74809
// continue ;
74807: GO 74765
// PrepareHuman ( false , i , skill ) ;
74809: LD_INT 0
74811: PPUSH
74812: LD_VAR 0 8
74816: PPUSH
74817: LD_VAR 0 4
74821: PPUSH
74822: CALL_OW 380
// un := CreateHuman ;
74826: LD_ADDR_VAR 0 14
74830: PUSH
74831: CALL_OW 44
74835: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74836: LD_VAR 0 14
74840: PPUSH
74841: LD_VAR 0 1
74845: PPUSH
74846: CALL_OW 250
74850: PPUSH
74851: LD_VAR 0 1
74855: PPUSH
74856: CALL_OW 251
74860: PPUSH
74861: LD_INT 10
74863: PPUSH
74864: LD_INT 0
74866: PPUSH
74867: CALL_OW 50
// result := result ^ un ;
74871: LD_ADDR_VAR 0 7
74875: PUSH
74876: LD_VAR 0 7
74880: PUSH
74881: LD_VAR 0 14
74885: ADD
74886: ST_TO_ADDR
// end ;
74887: GO 74765
74889: POP
74890: POP
// end ; end ;
74891: LD_VAR 0 7
74895: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
74896: LD_INT 0
74898: PPUSH
74899: PPUSH
74900: PPUSH
74901: PPUSH
74902: PPUSH
74903: PPUSH
74904: PPUSH
74905: PPUSH
74906: PPUSH
74907: PPUSH
74908: PPUSH
74909: PPUSH
74910: PPUSH
74911: PPUSH
74912: PPUSH
74913: PPUSH
// result := false ;
74914: LD_ADDR_VAR 0 3
74918: PUSH
74919: LD_INT 0
74921: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
74922: LD_VAR 0 1
74926: NOT
74927: PUSH
74928: LD_VAR 0 1
74932: PPUSH
74933: CALL_OW 266
74937: PUSH
74938: LD_INT 32
74940: PUSH
74941: LD_INT 33
74943: PUSH
74944: EMPTY
74945: LIST
74946: LIST
74947: IN
74948: NOT
74949: OR
74950: IFFALSE 74954
// exit ;
74952: GO 76090
// nat := GetNation ( tower ) ;
74954: LD_ADDR_VAR 0 12
74958: PUSH
74959: LD_VAR 0 1
74963: PPUSH
74964: CALL_OW 248
74968: ST_TO_ADDR
// side := GetSide ( tower ) ;
74969: LD_ADDR_VAR 0 16
74973: PUSH
74974: LD_VAR 0 1
74978: PPUSH
74979: CALL_OW 255
74983: ST_TO_ADDR
// x := GetX ( tower ) ;
74984: LD_ADDR_VAR 0 10
74988: PUSH
74989: LD_VAR 0 1
74993: PPUSH
74994: CALL_OW 250
74998: ST_TO_ADDR
// y := GetY ( tower ) ;
74999: LD_ADDR_VAR 0 11
75003: PUSH
75004: LD_VAR 0 1
75008: PPUSH
75009: CALL_OW 251
75013: ST_TO_ADDR
// if not x or not y then
75014: LD_VAR 0 10
75018: NOT
75019: PUSH
75020: LD_VAR 0 11
75024: NOT
75025: OR
75026: IFFALSE 75030
// exit ;
75028: GO 76090
// weapon := 0 ;
75030: LD_ADDR_VAR 0 18
75034: PUSH
75035: LD_INT 0
75037: ST_TO_ADDR
// fac_list := [ ] ;
75038: LD_ADDR_VAR 0 17
75042: PUSH
75043: EMPTY
75044: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
75045: LD_ADDR_VAR 0 6
75049: PUSH
75050: LD_VAR 0 1
75054: PPUSH
75055: CALL_OW 274
75059: PPUSH
75060: LD_VAR 0 2
75064: PPUSH
75065: CALL 72668 0 2
75069: PPUSH
75070: LD_INT 30
75072: PUSH
75073: LD_INT 3
75075: PUSH
75076: EMPTY
75077: LIST
75078: LIST
75079: PPUSH
75080: CALL_OW 72
75084: ST_TO_ADDR
// if not factories then
75085: LD_VAR 0 6
75089: NOT
75090: IFFALSE 75094
// exit ;
75092: GO 76090
// for i in factories do
75094: LD_ADDR_VAR 0 8
75098: PUSH
75099: LD_VAR 0 6
75103: PUSH
75104: FOR_IN
75105: IFFALSE 75130
// fac_list := fac_list union AvailableWeaponList ( i ) ;
75107: LD_ADDR_VAR 0 17
75111: PUSH
75112: LD_VAR 0 17
75116: PUSH
75117: LD_VAR 0 8
75121: PPUSH
75122: CALL_OW 478
75126: UNION
75127: ST_TO_ADDR
75128: GO 75104
75130: POP
75131: POP
// if not fac_list then
75132: LD_VAR 0 17
75136: NOT
75137: IFFALSE 75141
// exit ;
75139: GO 76090
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
75141: LD_ADDR_VAR 0 5
75145: PUSH
75146: LD_INT 4
75148: PUSH
75149: LD_INT 5
75151: PUSH
75152: LD_INT 9
75154: PUSH
75155: LD_INT 10
75157: PUSH
75158: LD_INT 6
75160: PUSH
75161: LD_INT 7
75163: PUSH
75164: LD_INT 11
75166: PUSH
75167: EMPTY
75168: LIST
75169: LIST
75170: LIST
75171: LIST
75172: LIST
75173: LIST
75174: LIST
75175: PUSH
75176: LD_INT 27
75178: PUSH
75179: LD_INT 28
75181: PUSH
75182: LD_INT 26
75184: PUSH
75185: LD_INT 30
75187: PUSH
75188: EMPTY
75189: LIST
75190: LIST
75191: LIST
75192: LIST
75193: PUSH
75194: LD_INT 43
75196: PUSH
75197: LD_INT 44
75199: PUSH
75200: LD_INT 46
75202: PUSH
75203: LD_INT 45
75205: PUSH
75206: LD_INT 47
75208: PUSH
75209: LD_INT 49
75211: PUSH
75212: EMPTY
75213: LIST
75214: LIST
75215: LIST
75216: LIST
75217: LIST
75218: LIST
75219: PUSH
75220: EMPTY
75221: LIST
75222: LIST
75223: LIST
75224: PUSH
75225: LD_VAR 0 12
75229: ARRAY
75230: ST_TO_ADDR
// for i in list do
75231: LD_ADDR_VAR 0 8
75235: PUSH
75236: LD_VAR 0 5
75240: PUSH
75241: FOR_IN
75242: IFFALSE 75275
// if not i in fac_list then
75244: LD_VAR 0 8
75248: PUSH
75249: LD_VAR 0 17
75253: IN
75254: NOT
75255: IFFALSE 75273
// list := list diff i ;
75257: LD_ADDR_VAR 0 5
75261: PUSH
75262: LD_VAR 0 5
75266: PUSH
75267: LD_VAR 0 8
75271: DIFF
75272: ST_TO_ADDR
75273: GO 75241
75275: POP
75276: POP
// if not list then
75277: LD_VAR 0 5
75281: NOT
75282: IFFALSE 75286
// exit ;
75284: GO 76090
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
75286: LD_VAR 0 12
75290: PUSH
75291: LD_INT 3
75293: EQUAL
75294: PUSH
75295: LD_INT 49
75297: PUSH
75298: LD_VAR 0 5
75302: IN
75303: AND
75304: PUSH
75305: LD_INT 31
75307: PPUSH
75308: LD_VAR 0 16
75312: PPUSH
75313: CALL_OW 321
75317: PUSH
75318: LD_INT 2
75320: EQUAL
75321: AND
75322: IFFALSE 75382
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
75324: LD_INT 22
75326: PUSH
75327: LD_VAR 0 16
75331: PUSH
75332: EMPTY
75333: LIST
75334: LIST
75335: PUSH
75336: LD_INT 35
75338: PUSH
75339: LD_INT 49
75341: PUSH
75342: EMPTY
75343: LIST
75344: LIST
75345: PUSH
75346: LD_INT 91
75348: PUSH
75349: LD_VAR 0 1
75353: PUSH
75354: LD_INT 10
75356: PUSH
75357: EMPTY
75358: LIST
75359: LIST
75360: LIST
75361: PUSH
75362: EMPTY
75363: LIST
75364: LIST
75365: LIST
75366: PPUSH
75367: CALL_OW 69
75371: NOT
75372: IFFALSE 75382
// weapon := ru_time_lapser ;
75374: LD_ADDR_VAR 0 18
75378: PUSH
75379: LD_INT 49
75381: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
75382: LD_VAR 0 12
75386: PUSH
75387: LD_INT 1
75389: PUSH
75390: LD_INT 2
75392: PUSH
75393: EMPTY
75394: LIST
75395: LIST
75396: IN
75397: PUSH
75398: LD_INT 11
75400: PUSH
75401: LD_VAR 0 5
75405: IN
75406: PUSH
75407: LD_INT 30
75409: PUSH
75410: LD_VAR 0 5
75414: IN
75415: OR
75416: AND
75417: PUSH
75418: LD_INT 6
75420: PPUSH
75421: LD_VAR 0 16
75425: PPUSH
75426: CALL_OW 321
75430: PUSH
75431: LD_INT 2
75433: EQUAL
75434: AND
75435: IFFALSE 75600
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
75437: LD_INT 22
75439: PUSH
75440: LD_VAR 0 16
75444: PUSH
75445: EMPTY
75446: LIST
75447: LIST
75448: PUSH
75449: LD_INT 2
75451: PUSH
75452: LD_INT 35
75454: PUSH
75455: LD_INT 11
75457: PUSH
75458: EMPTY
75459: LIST
75460: LIST
75461: PUSH
75462: LD_INT 35
75464: PUSH
75465: LD_INT 30
75467: PUSH
75468: EMPTY
75469: LIST
75470: LIST
75471: PUSH
75472: EMPTY
75473: LIST
75474: LIST
75475: LIST
75476: PUSH
75477: LD_INT 91
75479: PUSH
75480: LD_VAR 0 1
75484: PUSH
75485: LD_INT 18
75487: PUSH
75488: EMPTY
75489: LIST
75490: LIST
75491: LIST
75492: PUSH
75493: EMPTY
75494: LIST
75495: LIST
75496: LIST
75497: PPUSH
75498: CALL_OW 69
75502: NOT
75503: PUSH
75504: LD_INT 22
75506: PUSH
75507: LD_VAR 0 16
75511: PUSH
75512: EMPTY
75513: LIST
75514: LIST
75515: PUSH
75516: LD_INT 2
75518: PUSH
75519: LD_INT 30
75521: PUSH
75522: LD_INT 32
75524: PUSH
75525: EMPTY
75526: LIST
75527: LIST
75528: PUSH
75529: LD_INT 30
75531: PUSH
75532: LD_INT 33
75534: PUSH
75535: EMPTY
75536: LIST
75537: LIST
75538: PUSH
75539: EMPTY
75540: LIST
75541: LIST
75542: LIST
75543: PUSH
75544: LD_INT 91
75546: PUSH
75547: LD_VAR 0 1
75551: PUSH
75552: LD_INT 12
75554: PUSH
75555: EMPTY
75556: LIST
75557: LIST
75558: LIST
75559: PUSH
75560: EMPTY
75561: LIST
75562: LIST
75563: LIST
75564: PUSH
75565: EMPTY
75566: LIST
75567: PPUSH
75568: CALL_OW 69
75572: PUSH
75573: LD_INT 2
75575: GREATER
75576: AND
75577: IFFALSE 75600
// weapon := [ us_radar , ar_radar ] [ nat ] ;
75579: LD_ADDR_VAR 0 18
75583: PUSH
75584: LD_INT 11
75586: PUSH
75587: LD_INT 30
75589: PUSH
75590: EMPTY
75591: LIST
75592: LIST
75593: PUSH
75594: LD_VAR 0 12
75598: ARRAY
75599: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
75600: LD_VAR 0 18
75604: NOT
75605: PUSH
75606: LD_INT 40
75608: PPUSH
75609: LD_VAR 0 16
75613: PPUSH
75614: CALL_OW 321
75618: PUSH
75619: LD_INT 2
75621: EQUAL
75622: AND
75623: PUSH
75624: LD_INT 7
75626: PUSH
75627: LD_VAR 0 5
75631: IN
75632: PUSH
75633: LD_INT 28
75635: PUSH
75636: LD_VAR 0 5
75640: IN
75641: OR
75642: PUSH
75643: LD_INT 45
75645: PUSH
75646: LD_VAR 0 5
75650: IN
75651: OR
75652: AND
75653: IFFALSE 75907
// begin hex := GetHexInfo ( x , y ) ;
75655: LD_ADDR_VAR 0 4
75659: PUSH
75660: LD_VAR 0 10
75664: PPUSH
75665: LD_VAR 0 11
75669: PPUSH
75670: CALL_OW 546
75674: ST_TO_ADDR
// if hex [ 1 ] then
75675: LD_VAR 0 4
75679: PUSH
75680: LD_INT 1
75682: ARRAY
75683: IFFALSE 75687
// exit ;
75685: GO 76090
// height := hex [ 2 ] ;
75687: LD_ADDR_VAR 0 15
75691: PUSH
75692: LD_VAR 0 4
75696: PUSH
75697: LD_INT 2
75699: ARRAY
75700: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
75701: LD_ADDR_VAR 0 14
75705: PUSH
75706: LD_INT 0
75708: PUSH
75709: LD_INT 2
75711: PUSH
75712: LD_INT 3
75714: PUSH
75715: LD_INT 5
75717: PUSH
75718: EMPTY
75719: LIST
75720: LIST
75721: LIST
75722: LIST
75723: ST_TO_ADDR
// for i in tmp do
75724: LD_ADDR_VAR 0 8
75728: PUSH
75729: LD_VAR 0 14
75733: PUSH
75734: FOR_IN
75735: IFFALSE 75905
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
75737: LD_ADDR_VAR 0 9
75741: PUSH
75742: LD_VAR 0 10
75746: PPUSH
75747: LD_VAR 0 8
75751: PPUSH
75752: LD_INT 5
75754: PPUSH
75755: CALL_OW 272
75759: PUSH
75760: LD_VAR 0 11
75764: PPUSH
75765: LD_VAR 0 8
75769: PPUSH
75770: LD_INT 5
75772: PPUSH
75773: CALL_OW 273
75777: PUSH
75778: EMPTY
75779: LIST
75780: LIST
75781: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
75782: LD_VAR 0 9
75786: PUSH
75787: LD_INT 1
75789: ARRAY
75790: PPUSH
75791: LD_VAR 0 9
75795: PUSH
75796: LD_INT 2
75798: ARRAY
75799: PPUSH
75800: CALL_OW 488
75804: IFFALSE 75903
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
75806: LD_ADDR_VAR 0 4
75810: PUSH
75811: LD_VAR 0 9
75815: PUSH
75816: LD_INT 1
75818: ARRAY
75819: PPUSH
75820: LD_VAR 0 9
75824: PUSH
75825: LD_INT 2
75827: ARRAY
75828: PPUSH
75829: CALL_OW 546
75833: ST_TO_ADDR
// if hex [ 1 ] then
75834: LD_VAR 0 4
75838: PUSH
75839: LD_INT 1
75841: ARRAY
75842: IFFALSE 75846
// continue ;
75844: GO 75734
// h := hex [ 2 ] ;
75846: LD_ADDR_VAR 0 13
75850: PUSH
75851: LD_VAR 0 4
75855: PUSH
75856: LD_INT 2
75858: ARRAY
75859: ST_TO_ADDR
// if h + 7 < height then
75860: LD_VAR 0 13
75864: PUSH
75865: LD_INT 7
75867: PLUS
75868: PUSH
75869: LD_VAR 0 15
75873: LESS
75874: IFFALSE 75903
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
75876: LD_ADDR_VAR 0 18
75880: PUSH
75881: LD_INT 7
75883: PUSH
75884: LD_INT 28
75886: PUSH
75887: LD_INT 45
75889: PUSH
75890: EMPTY
75891: LIST
75892: LIST
75893: LIST
75894: PUSH
75895: LD_VAR 0 12
75899: ARRAY
75900: ST_TO_ADDR
// break ;
75901: GO 75905
// end ; end ; end ;
75903: GO 75734
75905: POP
75906: POP
// end ; if not weapon then
75907: LD_VAR 0 18
75911: NOT
75912: IFFALSE 75972
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
75914: LD_ADDR_VAR 0 5
75918: PUSH
75919: LD_VAR 0 5
75923: PUSH
75924: LD_INT 11
75926: PUSH
75927: LD_INT 30
75929: PUSH
75930: LD_INT 49
75932: PUSH
75933: EMPTY
75934: LIST
75935: LIST
75936: LIST
75937: DIFF
75938: ST_TO_ADDR
// if not list then
75939: LD_VAR 0 5
75943: NOT
75944: IFFALSE 75948
// exit ;
75946: GO 76090
// weapon := list [ rand ( 1 , list ) ] ;
75948: LD_ADDR_VAR 0 18
75952: PUSH
75953: LD_VAR 0 5
75957: PUSH
75958: LD_INT 1
75960: PPUSH
75961: LD_VAR 0 5
75965: PPUSH
75966: CALL_OW 12
75970: ARRAY
75971: ST_TO_ADDR
// end ; if weapon then
75972: LD_VAR 0 18
75976: IFFALSE 76090
// begin tmp := CostOfWeapon ( weapon ) ;
75978: LD_ADDR_VAR 0 14
75982: PUSH
75983: LD_VAR 0 18
75987: PPUSH
75988: CALL_OW 451
75992: ST_TO_ADDR
// j := GetBase ( tower ) ;
75993: LD_ADDR_VAR 0 9
75997: PUSH
75998: LD_VAR 0 1
76002: PPUSH
76003: CALL_OW 274
76007: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
76008: LD_VAR 0 9
76012: PPUSH
76013: LD_INT 1
76015: PPUSH
76016: CALL_OW 275
76020: PUSH
76021: LD_VAR 0 14
76025: PUSH
76026: LD_INT 1
76028: ARRAY
76029: GREATEREQUAL
76030: PUSH
76031: LD_VAR 0 9
76035: PPUSH
76036: LD_INT 2
76038: PPUSH
76039: CALL_OW 275
76043: PUSH
76044: LD_VAR 0 14
76048: PUSH
76049: LD_INT 2
76051: ARRAY
76052: GREATEREQUAL
76053: AND
76054: PUSH
76055: LD_VAR 0 9
76059: PPUSH
76060: LD_INT 3
76062: PPUSH
76063: CALL_OW 275
76067: PUSH
76068: LD_VAR 0 14
76072: PUSH
76073: LD_INT 3
76075: ARRAY
76076: GREATEREQUAL
76077: AND
76078: IFFALSE 76090
// result := weapon ;
76080: LD_ADDR_VAR 0 3
76084: PUSH
76085: LD_VAR 0 18
76089: ST_TO_ADDR
// end ; end ;
76090: LD_VAR 0 3
76094: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
76095: LD_INT 0
76097: PPUSH
76098: PPUSH
// result := true ;
76099: LD_ADDR_VAR 0 3
76103: PUSH
76104: LD_INT 1
76106: ST_TO_ADDR
// if array1 = array2 then
76107: LD_VAR 0 1
76111: PUSH
76112: LD_VAR 0 2
76116: EQUAL
76117: IFFALSE 76177
// begin for i = 1 to array1 do
76119: LD_ADDR_VAR 0 4
76123: PUSH
76124: DOUBLE
76125: LD_INT 1
76127: DEC
76128: ST_TO_ADDR
76129: LD_VAR 0 1
76133: PUSH
76134: FOR_TO
76135: IFFALSE 76173
// if array1 [ i ] <> array2 [ i ] then
76137: LD_VAR 0 1
76141: PUSH
76142: LD_VAR 0 4
76146: ARRAY
76147: PUSH
76148: LD_VAR 0 2
76152: PUSH
76153: LD_VAR 0 4
76157: ARRAY
76158: NONEQUAL
76159: IFFALSE 76171
// begin result := false ;
76161: LD_ADDR_VAR 0 3
76165: PUSH
76166: LD_INT 0
76168: ST_TO_ADDR
// break ;
76169: GO 76173
// end ;
76171: GO 76134
76173: POP
76174: POP
// end else
76175: GO 76185
// result := false ;
76177: LD_ADDR_VAR 0 3
76181: PUSH
76182: LD_INT 0
76184: ST_TO_ADDR
// end ;
76185: LD_VAR 0 3
76189: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
76190: LD_INT 0
76192: PPUSH
76193: PPUSH
76194: PPUSH
// pom := GetBase ( fac ) ;
76195: LD_ADDR_VAR 0 5
76199: PUSH
76200: LD_VAR 0 1
76204: PPUSH
76205: CALL_OW 274
76209: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
76210: LD_ADDR_VAR 0 4
76214: PUSH
76215: LD_VAR 0 2
76219: PUSH
76220: LD_INT 1
76222: ARRAY
76223: PPUSH
76224: LD_VAR 0 2
76228: PUSH
76229: LD_INT 2
76231: ARRAY
76232: PPUSH
76233: LD_VAR 0 2
76237: PUSH
76238: LD_INT 3
76240: ARRAY
76241: PPUSH
76242: LD_VAR 0 2
76246: PUSH
76247: LD_INT 4
76249: ARRAY
76250: PPUSH
76251: CALL_OW 449
76255: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76256: LD_ADDR_VAR 0 3
76260: PUSH
76261: LD_VAR 0 5
76265: PPUSH
76266: LD_INT 1
76268: PPUSH
76269: CALL_OW 275
76273: PUSH
76274: LD_VAR 0 4
76278: PUSH
76279: LD_INT 1
76281: ARRAY
76282: GREATEREQUAL
76283: PUSH
76284: LD_VAR 0 5
76288: PPUSH
76289: LD_INT 2
76291: PPUSH
76292: CALL_OW 275
76296: PUSH
76297: LD_VAR 0 4
76301: PUSH
76302: LD_INT 2
76304: ARRAY
76305: GREATEREQUAL
76306: AND
76307: PUSH
76308: LD_VAR 0 5
76312: PPUSH
76313: LD_INT 3
76315: PPUSH
76316: CALL_OW 275
76320: PUSH
76321: LD_VAR 0 4
76325: PUSH
76326: LD_INT 3
76328: ARRAY
76329: GREATEREQUAL
76330: AND
76331: ST_TO_ADDR
// end ;
76332: LD_VAR 0 3
76336: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
76337: LD_INT 0
76339: PPUSH
76340: PPUSH
76341: PPUSH
76342: PPUSH
// pom := GetBase ( building ) ;
76343: LD_ADDR_VAR 0 3
76347: PUSH
76348: LD_VAR 0 1
76352: PPUSH
76353: CALL_OW 274
76357: ST_TO_ADDR
// if not pom then
76358: LD_VAR 0 3
76362: NOT
76363: IFFALSE 76367
// exit ;
76365: GO 76537
// btype := GetBType ( building ) ;
76367: LD_ADDR_VAR 0 5
76371: PUSH
76372: LD_VAR 0 1
76376: PPUSH
76377: CALL_OW 266
76381: ST_TO_ADDR
// if btype = b_armoury then
76382: LD_VAR 0 5
76386: PUSH
76387: LD_INT 4
76389: EQUAL
76390: IFFALSE 76400
// btype := b_barracks ;
76392: LD_ADDR_VAR 0 5
76396: PUSH
76397: LD_INT 5
76399: ST_TO_ADDR
// if btype = b_depot then
76400: LD_VAR 0 5
76404: PUSH
76405: LD_INT 0
76407: EQUAL
76408: IFFALSE 76418
// btype := b_warehouse ;
76410: LD_ADDR_VAR 0 5
76414: PUSH
76415: LD_INT 1
76417: ST_TO_ADDR
// if btype = b_workshop then
76418: LD_VAR 0 5
76422: PUSH
76423: LD_INT 2
76425: EQUAL
76426: IFFALSE 76436
// btype := b_factory ;
76428: LD_ADDR_VAR 0 5
76432: PUSH
76433: LD_INT 3
76435: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76436: LD_ADDR_VAR 0 4
76440: PUSH
76441: LD_VAR 0 5
76445: PPUSH
76446: LD_VAR 0 1
76450: PPUSH
76451: CALL_OW 248
76455: PPUSH
76456: CALL_OW 450
76460: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76461: LD_ADDR_VAR 0 2
76465: PUSH
76466: LD_VAR 0 3
76470: PPUSH
76471: LD_INT 1
76473: PPUSH
76474: CALL_OW 275
76478: PUSH
76479: LD_VAR 0 4
76483: PUSH
76484: LD_INT 1
76486: ARRAY
76487: GREATEREQUAL
76488: PUSH
76489: LD_VAR 0 3
76493: PPUSH
76494: LD_INT 2
76496: PPUSH
76497: CALL_OW 275
76501: PUSH
76502: LD_VAR 0 4
76506: PUSH
76507: LD_INT 2
76509: ARRAY
76510: GREATEREQUAL
76511: AND
76512: PUSH
76513: LD_VAR 0 3
76517: PPUSH
76518: LD_INT 3
76520: PPUSH
76521: CALL_OW 275
76525: PUSH
76526: LD_VAR 0 4
76530: PUSH
76531: LD_INT 3
76533: ARRAY
76534: GREATEREQUAL
76535: AND
76536: ST_TO_ADDR
// end ;
76537: LD_VAR 0 2
76541: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
76542: LD_INT 0
76544: PPUSH
76545: PPUSH
76546: PPUSH
// pom := GetBase ( building ) ;
76547: LD_ADDR_VAR 0 4
76551: PUSH
76552: LD_VAR 0 1
76556: PPUSH
76557: CALL_OW 274
76561: ST_TO_ADDR
// if not pom then
76562: LD_VAR 0 4
76566: NOT
76567: IFFALSE 76571
// exit ;
76569: GO 76672
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76571: LD_ADDR_VAR 0 5
76575: PUSH
76576: LD_VAR 0 2
76580: PPUSH
76581: LD_VAR 0 1
76585: PPUSH
76586: CALL_OW 248
76590: PPUSH
76591: CALL_OW 450
76595: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76596: LD_ADDR_VAR 0 3
76600: PUSH
76601: LD_VAR 0 4
76605: PPUSH
76606: LD_INT 1
76608: PPUSH
76609: CALL_OW 275
76613: PUSH
76614: LD_VAR 0 5
76618: PUSH
76619: LD_INT 1
76621: ARRAY
76622: GREATEREQUAL
76623: PUSH
76624: LD_VAR 0 4
76628: PPUSH
76629: LD_INT 2
76631: PPUSH
76632: CALL_OW 275
76636: PUSH
76637: LD_VAR 0 5
76641: PUSH
76642: LD_INT 2
76644: ARRAY
76645: GREATEREQUAL
76646: AND
76647: PUSH
76648: LD_VAR 0 4
76652: PPUSH
76653: LD_INT 3
76655: PPUSH
76656: CALL_OW 275
76660: PUSH
76661: LD_VAR 0 5
76665: PUSH
76666: LD_INT 3
76668: ARRAY
76669: GREATEREQUAL
76670: AND
76671: ST_TO_ADDR
// end ;
76672: LD_VAR 0 3
76676: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
76677: LD_INT 0
76679: PPUSH
76680: PPUSH
76681: PPUSH
76682: PPUSH
76683: PPUSH
76684: PPUSH
76685: PPUSH
76686: PPUSH
76687: PPUSH
76688: PPUSH
// result := false ;
76689: LD_ADDR_VAR 0 6
76693: PUSH
76694: LD_INT 0
76696: ST_TO_ADDR
// if not base or not btype or not x or not y then
76697: LD_VAR 0 1
76701: NOT
76702: PUSH
76703: LD_VAR 0 2
76707: NOT
76708: OR
76709: PUSH
76710: LD_VAR 0 3
76714: NOT
76715: OR
76716: PUSH
76717: LD_VAR 0 4
76721: NOT
76722: OR
76723: IFFALSE 76727
// exit ;
76725: GO 77336
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
76727: LD_ADDR_VAR 0 12
76731: PUSH
76732: LD_VAR 0 2
76736: PPUSH
76737: LD_VAR 0 3
76741: PPUSH
76742: LD_VAR 0 4
76746: PPUSH
76747: LD_VAR 0 5
76751: PPUSH
76752: LD_VAR 0 1
76756: PUSH
76757: LD_INT 1
76759: ARRAY
76760: PPUSH
76761: CALL_OW 248
76765: PPUSH
76766: LD_INT 0
76768: PPUSH
76769: CALL 78173 0 6
76773: ST_TO_ADDR
// if not hexes then
76774: LD_VAR 0 12
76778: NOT
76779: IFFALSE 76783
// exit ;
76781: GO 77336
// for i = 1 to hexes do
76783: LD_ADDR_VAR 0 7
76787: PUSH
76788: DOUBLE
76789: LD_INT 1
76791: DEC
76792: ST_TO_ADDR
76793: LD_VAR 0 12
76797: PUSH
76798: FOR_TO
76799: IFFALSE 77334
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
76801: LD_ADDR_VAR 0 11
76805: PUSH
76806: LD_VAR 0 12
76810: PUSH
76811: LD_VAR 0 7
76815: ARRAY
76816: PUSH
76817: LD_INT 1
76819: ARRAY
76820: PPUSH
76821: LD_VAR 0 12
76825: PUSH
76826: LD_VAR 0 7
76830: ARRAY
76831: PUSH
76832: LD_INT 2
76834: ARRAY
76835: PPUSH
76836: CALL_OW 428
76840: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
76841: LD_VAR 0 12
76845: PUSH
76846: LD_VAR 0 7
76850: ARRAY
76851: PUSH
76852: LD_INT 1
76854: ARRAY
76855: PPUSH
76856: LD_VAR 0 12
76860: PUSH
76861: LD_VAR 0 7
76865: ARRAY
76866: PUSH
76867: LD_INT 2
76869: ARRAY
76870: PPUSH
76871: CALL_OW 351
76875: PUSH
76876: LD_VAR 0 12
76880: PUSH
76881: LD_VAR 0 7
76885: ARRAY
76886: PUSH
76887: LD_INT 1
76889: ARRAY
76890: PPUSH
76891: LD_VAR 0 12
76895: PUSH
76896: LD_VAR 0 7
76900: ARRAY
76901: PUSH
76902: LD_INT 2
76904: ARRAY
76905: PPUSH
76906: CALL_OW 488
76910: NOT
76911: OR
76912: PUSH
76913: LD_VAR 0 11
76917: PPUSH
76918: CALL_OW 247
76922: PUSH
76923: LD_INT 3
76925: EQUAL
76926: OR
76927: IFFALSE 76933
// exit ;
76929: POP
76930: POP
76931: GO 77336
// if not tmp or not tmp in base then
76933: LD_VAR 0 11
76937: NOT
76938: PUSH
76939: LD_VAR 0 11
76943: PUSH
76944: LD_VAR 0 1
76948: IN
76949: NOT
76950: OR
76951: IFFALSE 76955
// continue ;
76953: GO 76798
// result := true ;
76955: LD_ADDR_VAR 0 6
76959: PUSH
76960: LD_INT 1
76962: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
76963: LD_ADDR_VAR 0 15
76967: PUSH
76968: LD_VAR 0 1
76972: PPUSH
76973: LD_INT 22
76975: PUSH
76976: LD_VAR 0 11
76980: PPUSH
76981: CALL_OW 255
76985: PUSH
76986: EMPTY
76987: LIST
76988: LIST
76989: PUSH
76990: LD_INT 2
76992: PUSH
76993: LD_INT 30
76995: PUSH
76996: LD_INT 0
76998: PUSH
76999: EMPTY
77000: LIST
77001: LIST
77002: PUSH
77003: LD_INT 30
77005: PUSH
77006: LD_INT 1
77008: PUSH
77009: EMPTY
77010: LIST
77011: LIST
77012: PUSH
77013: EMPTY
77014: LIST
77015: LIST
77016: LIST
77017: PUSH
77018: EMPTY
77019: LIST
77020: LIST
77021: PPUSH
77022: CALL_OW 72
77026: ST_TO_ADDR
// if dep then
77027: LD_VAR 0 15
77031: IFFALSE 77167
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
77033: LD_ADDR_VAR 0 14
77037: PUSH
77038: LD_VAR 0 15
77042: PUSH
77043: LD_INT 1
77045: ARRAY
77046: PPUSH
77047: CALL_OW 250
77051: PPUSH
77052: LD_VAR 0 15
77056: PUSH
77057: LD_INT 1
77059: ARRAY
77060: PPUSH
77061: CALL_OW 254
77065: PPUSH
77066: LD_INT 5
77068: PPUSH
77069: CALL_OW 272
77073: PUSH
77074: LD_VAR 0 15
77078: PUSH
77079: LD_INT 1
77081: ARRAY
77082: PPUSH
77083: CALL_OW 251
77087: PPUSH
77088: LD_VAR 0 15
77092: PUSH
77093: LD_INT 1
77095: ARRAY
77096: PPUSH
77097: CALL_OW 254
77101: PPUSH
77102: LD_INT 5
77104: PPUSH
77105: CALL_OW 273
77109: PUSH
77110: EMPTY
77111: LIST
77112: LIST
77113: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
77114: LD_VAR 0 14
77118: PUSH
77119: LD_INT 1
77121: ARRAY
77122: PPUSH
77123: LD_VAR 0 14
77127: PUSH
77128: LD_INT 2
77130: ARRAY
77131: PPUSH
77132: CALL_OW 488
77136: IFFALSE 77167
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
77138: LD_VAR 0 11
77142: PPUSH
77143: LD_VAR 0 14
77147: PUSH
77148: LD_INT 1
77150: ARRAY
77151: PPUSH
77152: LD_VAR 0 14
77156: PUSH
77157: LD_INT 2
77159: ARRAY
77160: PPUSH
77161: CALL_OW 111
// continue ;
77165: GO 76798
// end ; end ; r := GetDir ( tmp ) ;
77167: LD_ADDR_VAR 0 13
77171: PUSH
77172: LD_VAR 0 11
77176: PPUSH
77177: CALL_OW 254
77181: ST_TO_ADDR
// if r = 5 then
77182: LD_VAR 0 13
77186: PUSH
77187: LD_INT 5
77189: EQUAL
77190: IFFALSE 77200
// r := 0 ;
77192: LD_ADDR_VAR 0 13
77196: PUSH
77197: LD_INT 0
77199: ST_TO_ADDR
// for j = r to 5 do
77200: LD_ADDR_VAR 0 8
77204: PUSH
77205: DOUBLE
77206: LD_VAR 0 13
77210: DEC
77211: ST_TO_ADDR
77212: LD_INT 5
77214: PUSH
77215: FOR_TO
77216: IFFALSE 77330
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
77218: LD_ADDR_VAR 0 9
77222: PUSH
77223: LD_VAR 0 11
77227: PPUSH
77228: CALL_OW 250
77232: PPUSH
77233: LD_VAR 0 8
77237: PPUSH
77238: LD_INT 2
77240: PPUSH
77241: CALL_OW 272
77245: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
77246: LD_ADDR_VAR 0 10
77250: PUSH
77251: LD_VAR 0 11
77255: PPUSH
77256: CALL_OW 251
77260: PPUSH
77261: LD_VAR 0 8
77265: PPUSH
77266: LD_INT 2
77268: PPUSH
77269: CALL_OW 273
77273: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
77274: LD_VAR 0 9
77278: PPUSH
77279: LD_VAR 0 10
77283: PPUSH
77284: CALL_OW 488
77288: PUSH
77289: LD_VAR 0 9
77293: PPUSH
77294: LD_VAR 0 10
77298: PPUSH
77299: CALL_OW 428
77303: NOT
77304: AND
77305: IFFALSE 77328
// begin ComMoveXY ( tmp , _x , _y ) ;
77307: LD_VAR 0 11
77311: PPUSH
77312: LD_VAR 0 9
77316: PPUSH
77317: LD_VAR 0 10
77321: PPUSH
77322: CALL_OW 111
// break ;
77326: GO 77330
// end ; end ;
77328: GO 77215
77330: POP
77331: POP
// end ;
77332: GO 76798
77334: POP
77335: POP
// end ;
77336: LD_VAR 0 6
77340: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
77341: LD_INT 0
77343: PPUSH
77344: PPUSH
77345: PPUSH
77346: PPUSH
77347: PPUSH
77348: PPUSH
77349: PPUSH
77350: PPUSH
77351: PPUSH
77352: PPUSH
// result := false ;
77353: LD_ADDR_VAR 0 6
77357: PUSH
77358: LD_INT 0
77360: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
77361: LD_VAR 0 1
77365: NOT
77366: PUSH
77367: LD_VAR 0 1
77371: PPUSH
77372: CALL_OW 266
77376: PUSH
77377: LD_INT 0
77379: PUSH
77380: LD_INT 1
77382: PUSH
77383: EMPTY
77384: LIST
77385: LIST
77386: IN
77387: NOT
77388: OR
77389: PUSH
77390: LD_VAR 0 2
77394: NOT
77395: OR
77396: PUSH
77397: LD_VAR 0 5
77401: PUSH
77402: LD_INT 0
77404: PUSH
77405: LD_INT 1
77407: PUSH
77408: LD_INT 2
77410: PUSH
77411: LD_INT 3
77413: PUSH
77414: LD_INT 4
77416: PUSH
77417: LD_INT 5
77419: PUSH
77420: EMPTY
77421: LIST
77422: LIST
77423: LIST
77424: LIST
77425: LIST
77426: LIST
77427: IN
77428: NOT
77429: OR
77430: PUSH
77431: LD_VAR 0 3
77435: PPUSH
77436: LD_VAR 0 4
77440: PPUSH
77441: CALL_OW 488
77445: NOT
77446: OR
77447: IFFALSE 77451
// exit ;
77449: GO 78168
// pom := GetBase ( depot ) ;
77451: LD_ADDR_VAR 0 10
77455: PUSH
77456: LD_VAR 0 1
77460: PPUSH
77461: CALL_OW 274
77465: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
77466: LD_ADDR_VAR 0 11
77470: PUSH
77471: LD_VAR 0 2
77475: PPUSH
77476: LD_VAR 0 1
77480: PPUSH
77481: CALL_OW 248
77485: PPUSH
77486: CALL_OW 450
77490: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
77491: LD_VAR 0 10
77495: PPUSH
77496: LD_INT 1
77498: PPUSH
77499: CALL_OW 275
77503: PUSH
77504: LD_VAR 0 11
77508: PUSH
77509: LD_INT 1
77511: ARRAY
77512: GREATEREQUAL
77513: PUSH
77514: LD_VAR 0 10
77518: PPUSH
77519: LD_INT 2
77521: PPUSH
77522: CALL_OW 275
77526: PUSH
77527: LD_VAR 0 11
77531: PUSH
77532: LD_INT 2
77534: ARRAY
77535: GREATEREQUAL
77536: AND
77537: PUSH
77538: LD_VAR 0 10
77542: PPUSH
77543: LD_INT 3
77545: PPUSH
77546: CALL_OW 275
77550: PUSH
77551: LD_VAR 0 11
77555: PUSH
77556: LD_INT 3
77558: ARRAY
77559: GREATEREQUAL
77560: AND
77561: NOT
77562: IFFALSE 77566
// exit ;
77564: GO 78168
// if GetBType ( depot ) = b_depot then
77566: LD_VAR 0 1
77570: PPUSH
77571: CALL_OW 266
77575: PUSH
77576: LD_INT 0
77578: EQUAL
77579: IFFALSE 77591
// dist := 28 else
77581: LD_ADDR_VAR 0 14
77585: PUSH
77586: LD_INT 28
77588: ST_TO_ADDR
77589: GO 77599
// dist := 36 ;
77591: LD_ADDR_VAR 0 14
77595: PUSH
77596: LD_INT 36
77598: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
77599: LD_VAR 0 1
77603: PPUSH
77604: LD_VAR 0 3
77608: PPUSH
77609: LD_VAR 0 4
77613: PPUSH
77614: CALL_OW 297
77618: PUSH
77619: LD_VAR 0 14
77623: GREATER
77624: IFFALSE 77628
// exit ;
77626: GO 78168
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
77628: LD_ADDR_VAR 0 12
77632: PUSH
77633: LD_VAR 0 2
77637: PPUSH
77638: LD_VAR 0 3
77642: PPUSH
77643: LD_VAR 0 4
77647: PPUSH
77648: LD_VAR 0 5
77652: PPUSH
77653: LD_VAR 0 1
77657: PPUSH
77658: CALL_OW 248
77662: PPUSH
77663: LD_INT 0
77665: PPUSH
77666: CALL 78173 0 6
77670: ST_TO_ADDR
// if not hexes then
77671: LD_VAR 0 12
77675: NOT
77676: IFFALSE 77680
// exit ;
77678: GO 78168
// hex := GetHexInfo ( x , y ) ;
77680: LD_ADDR_VAR 0 15
77684: PUSH
77685: LD_VAR 0 3
77689: PPUSH
77690: LD_VAR 0 4
77694: PPUSH
77695: CALL_OW 546
77699: ST_TO_ADDR
// if hex [ 1 ] then
77700: LD_VAR 0 15
77704: PUSH
77705: LD_INT 1
77707: ARRAY
77708: IFFALSE 77712
// exit ;
77710: GO 78168
// height := hex [ 2 ] ;
77712: LD_ADDR_VAR 0 13
77716: PUSH
77717: LD_VAR 0 15
77721: PUSH
77722: LD_INT 2
77724: ARRAY
77725: ST_TO_ADDR
// for i = 1 to hexes do
77726: LD_ADDR_VAR 0 7
77730: PUSH
77731: DOUBLE
77732: LD_INT 1
77734: DEC
77735: ST_TO_ADDR
77736: LD_VAR 0 12
77740: PUSH
77741: FOR_TO
77742: IFFALSE 78072
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
77744: LD_VAR 0 12
77748: PUSH
77749: LD_VAR 0 7
77753: ARRAY
77754: PUSH
77755: LD_INT 1
77757: ARRAY
77758: PPUSH
77759: LD_VAR 0 12
77763: PUSH
77764: LD_VAR 0 7
77768: ARRAY
77769: PUSH
77770: LD_INT 2
77772: ARRAY
77773: PPUSH
77774: CALL_OW 488
77778: NOT
77779: PUSH
77780: LD_VAR 0 12
77784: PUSH
77785: LD_VAR 0 7
77789: ARRAY
77790: PUSH
77791: LD_INT 1
77793: ARRAY
77794: PPUSH
77795: LD_VAR 0 12
77799: PUSH
77800: LD_VAR 0 7
77804: ARRAY
77805: PUSH
77806: LD_INT 2
77808: ARRAY
77809: PPUSH
77810: CALL_OW 428
77814: PUSH
77815: LD_INT 0
77817: GREATER
77818: OR
77819: PUSH
77820: LD_VAR 0 12
77824: PUSH
77825: LD_VAR 0 7
77829: ARRAY
77830: PUSH
77831: LD_INT 1
77833: ARRAY
77834: PPUSH
77835: LD_VAR 0 12
77839: PUSH
77840: LD_VAR 0 7
77844: ARRAY
77845: PUSH
77846: LD_INT 2
77848: ARRAY
77849: PPUSH
77850: CALL_OW 351
77854: OR
77855: IFFALSE 77861
// exit ;
77857: POP
77858: POP
77859: GO 78168
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77861: LD_ADDR_VAR 0 8
77865: PUSH
77866: LD_VAR 0 12
77870: PUSH
77871: LD_VAR 0 7
77875: ARRAY
77876: PUSH
77877: LD_INT 1
77879: ARRAY
77880: PPUSH
77881: LD_VAR 0 12
77885: PUSH
77886: LD_VAR 0 7
77890: ARRAY
77891: PUSH
77892: LD_INT 2
77894: ARRAY
77895: PPUSH
77896: CALL_OW 546
77900: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
77901: LD_VAR 0 8
77905: PUSH
77906: LD_INT 1
77908: ARRAY
77909: PUSH
77910: LD_VAR 0 8
77914: PUSH
77915: LD_INT 2
77917: ARRAY
77918: PUSH
77919: LD_VAR 0 13
77923: PUSH
77924: LD_INT 2
77926: PLUS
77927: GREATER
77928: OR
77929: PUSH
77930: LD_VAR 0 8
77934: PUSH
77935: LD_INT 2
77937: ARRAY
77938: PUSH
77939: LD_VAR 0 13
77943: PUSH
77944: LD_INT 2
77946: MINUS
77947: LESS
77948: OR
77949: PUSH
77950: LD_VAR 0 8
77954: PUSH
77955: LD_INT 3
77957: ARRAY
77958: PUSH
77959: LD_INT 0
77961: PUSH
77962: LD_INT 8
77964: PUSH
77965: LD_INT 9
77967: PUSH
77968: LD_INT 10
77970: PUSH
77971: LD_INT 11
77973: PUSH
77974: LD_INT 12
77976: PUSH
77977: LD_INT 13
77979: PUSH
77980: LD_INT 16
77982: PUSH
77983: LD_INT 17
77985: PUSH
77986: LD_INT 18
77988: PUSH
77989: LD_INT 19
77991: PUSH
77992: LD_INT 20
77994: PUSH
77995: LD_INT 21
77997: PUSH
77998: EMPTY
77999: LIST
78000: LIST
78001: LIST
78002: LIST
78003: LIST
78004: LIST
78005: LIST
78006: LIST
78007: LIST
78008: LIST
78009: LIST
78010: LIST
78011: LIST
78012: IN
78013: NOT
78014: OR
78015: PUSH
78016: LD_VAR 0 8
78020: PUSH
78021: LD_INT 5
78023: ARRAY
78024: NOT
78025: OR
78026: PUSH
78027: LD_VAR 0 8
78031: PUSH
78032: LD_INT 6
78034: ARRAY
78035: PUSH
78036: LD_INT 1
78038: PUSH
78039: LD_INT 2
78041: PUSH
78042: LD_INT 7
78044: PUSH
78045: LD_INT 9
78047: PUSH
78048: LD_INT 10
78050: PUSH
78051: LD_INT 11
78053: PUSH
78054: EMPTY
78055: LIST
78056: LIST
78057: LIST
78058: LIST
78059: LIST
78060: LIST
78061: IN
78062: NOT
78063: OR
78064: IFFALSE 78070
// exit ;
78066: POP
78067: POP
78068: GO 78168
// end ;
78070: GO 77741
78072: POP
78073: POP
// side := GetSide ( depot ) ;
78074: LD_ADDR_VAR 0 9
78078: PUSH
78079: LD_VAR 0 1
78083: PPUSH
78084: CALL_OW 255
78088: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
78089: LD_VAR 0 9
78093: PPUSH
78094: LD_VAR 0 3
78098: PPUSH
78099: LD_VAR 0 4
78103: PPUSH
78104: LD_INT 20
78106: PPUSH
78107: CALL 70822 0 4
78111: PUSH
78112: LD_INT 4
78114: ARRAY
78115: IFFALSE 78119
// exit ;
78117: GO 78168
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
78119: LD_VAR 0 2
78123: PUSH
78124: LD_INT 29
78126: PUSH
78127: LD_INT 30
78129: PUSH
78130: EMPTY
78131: LIST
78132: LIST
78133: IN
78134: PUSH
78135: LD_VAR 0 3
78139: PPUSH
78140: LD_VAR 0 4
78144: PPUSH
78145: LD_VAR 0 9
78149: PPUSH
78150: CALL_OW 440
78154: NOT
78155: AND
78156: IFFALSE 78160
// exit ;
78158: GO 78168
// result := true ;
78160: LD_ADDR_VAR 0 6
78164: PUSH
78165: LD_INT 1
78167: ST_TO_ADDR
// end ;
78168: LD_VAR 0 6
78172: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
78173: LD_INT 0
78175: PPUSH
78176: PPUSH
78177: PPUSH
78178: PPUSH
78179: PPUSH
78180: PPUSH
78181: PPUSH
78182: PPUSH
78183: PPUSH
78184: PPUSH
78185: PPUSH
78186: PPUSH
78187: PPUSH
78188: PPUSH
78189: PPUSH
78190: PPUSH
78191: PPUSH
78192: PPUSH
78193: PPUSH
78194: PPUSH
78195: PPUSH
78196: PPUSH
78197: PPUSH
78198: PPUSH
78199: PPUSH
78200: PPUSH
78201: PPUSH
78202: PPUSH
78203: PPUSH
78204: PPUSH
78205: PPUSH
78206: PPUSH
78207: PPUSH
78208: PPUSH
78209: PPUSH
78210: PPUSH
78211: PPUSH
78212: PPUSH
78213: PPUSH
78214: PPUSH
78215: PPUSH
78216: PPUSH
78217: PPUSH
78218: PPUSH
78219: PPUSH
78220: PPUSH
78221: PPUSH
78222: PPUSH
78223: PPUSH
78224: PPUSH
78225: PPUSH
78226: PPUSH
78227: PPUSH
78228: PPUSH
78229: PPUSH
78230: PPUSH
78231: PPUSH
78232: PPUSH
// result = [ ] ;
78233: LD_ADDR_VAR 0 7
78237: PUSH
78238: EMPTY
78239: ST_TO_ADDR
// temp_list = [ ] ;
78240: LD_ADDR_VAR 0 9
78244: PUSH
78245: EMPTY
78246: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
78247: LD_VAR 0 4
78251: PUSH
78252: LD_INT 0
78254: PUSH
78255: LD_INT 1
78257: PUSH
78258: LD_INT 2
78260: PUSH
78261: LD_INT 3
78263: PUSH
78264: LD_INT 4
78266: PUSH
78267: LD_INT 5
78269: PUSH
78270: EMPTY
78271: LIST
78272: LIST
78273: LIST
78274: LIST
78275: LIST
78276: LIST
78277: IN
78278: NOT
78279: PUSH
78280: LD_VAR 0 1
78284: PUSH
78285: LD_INT 0
78287: PUSH
78288: LD_INT 1
78290: PUSH
78291: EMPTY
78292: LIST
78293: LIST
78294: IN
78295: PUSH
78296: LD_VAR 0 5
78300: PUSH
78301: LD_INT 1
78303: PUSH
78304: LD_INT 2
78306: PUSH
78307: LD_INT 3
78309: PUSH
78310: EMPTY
78311: LIST
78312: LIST
78313: LIST
78314: IN
78315: NOT
78316: AND
78317: OR
78318: IFFALSE 78322
// exit ;
78320: GO 96713
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
78322: LD_VAR 0 1
78326: PUSH
78327: LD_INT 6
78329: PUSH
78330: LD_INT 7
78332: PUSH
78333: LD_INT 8
78335: PUSH
78336: LD_INT 13
78338: PUSH
78339: LD_INT 12
78341: PUSH
78342: LD_INT 15
78344: PUSH
78345: LD_INT 11
78347: PUSH
78348: LD_INT 14
78350: PUSH
78351: LD_INT 10
78353: PUSH
78354: EMPTY
78355: LIST
78356: LIST
78357: LIST
78358: LIST
78359: LIST
78360: LIST
78361: LIST
78362: LIST
78363: LIST
78364: IN
78365: IFFALSE 78375
// btype = b_lab ;
78367: LD_ADDR_VAR 0 1
78371: PUSH
78372: LD_INT 6
78374: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
78375: LD_VAR 0 6
78379: PUSH
78380: LD_INT 0
78382: PUSH
78383: LD_INT 1
78385: PUSH
78386: LD_INT 2
78388: PUSH
78389: EMPTY
78390: LIST
78391: LIST
78392: LIST
78393: IN
78394: NOT
78395: PUSH
78396: LD_VAR 0 1
78400: PUSH
78401: LD_INT 0
78403: PUSH
78404: LD_INT 1
78406: PUSH
78407: LD_INT 2
78409: PUSH
78410: LD_INT 3
78412: PUSH
78413: LD_INT 6
78415: PUSH
78416: LD_INT 36
78418: PUSH
78419: LD_INT 4
78421: PUSH
78422: LD_INT 5
78424: PUSH
78425: LD_INT 31
78427: PUSH
78428: LD_INT 32
78430: PUSH
78431: LD_INT 33
78433: PUSH
78434: EMPTY
78435: LIST
78436: LIST
78437: LIST
78438: LIST
78439: LIST
78440: LIST
78441: LIST
78442: LIST
78443: LIST
78444: LIST
78445: LIST
78446: IN
78447: NOT
78448: PUSH
78449: LD_VAR 0 6
78453: PUSH
78454: LD_INT 1
78456: EQUAL
78457: AND
78458: OR
78459: PUSH
78460: LD_VAR 0 1
78464: PUSH
78465: LD_INT 2
78467: PUSH
78468: LD_INT 3
78470: PUSH
78471: EMPTY
78472: LIST
78473: LIST
78474: IN
78475: NOT
78476: PUSH
78477: LD_VAR 0 6
78481: PUSH
78482: LD_INT 2
78484: EQUAL
78485: AND
78486: OR
78487: IFFALSE 78497
// mode = 0 ;
78489: LD_ADDR_VAR 0 6
78493: PUSH
78494: LD_INT 0
78496: ST_TO_ADDR
// case mode of 0 :
78497: LD_VAR 0 6
78501: PUSH
78502: LD_INT 0
78504: DOUBLE
78505: EQUAL
78506: IFTRUE 78510
78508: GO 89963
78510: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78511: LD_ADDR_VAR 0 11
78515: PUSH
78516: LD_INT 0
78518: PUSH
78519: LD_INT 0
78521: PUSH
78522: EMPTY
78523: LIST
78524: LIST
78525: PUSH
78526: LD_INT 0
78528: PUSH
78529: LD_INT 1
78531: NEG
78532: PUSH
78533: EMPTY
78534: LIST
78535: LIST
78536: PUSH
78537: LD_INT 1
78539: PUSH
78540: LD_INT 0
78542: PUSH
78543: EMPTY
78544: LIST
78545: LIST
78546: PUSH
78547: LD_INT 1
78549: PUSH
78550: LD_INT 1
78552: PUSH
78553: EMPTY
78554: LIST
78555: LIST
78556: PUSH
78557: LD_INT 0
78559: PUSH
78560: LD_INT 1
78562: PUSH
78563: EMPTY
78564: LIST
78565: LIST
78566: PUSH
78567: LD_INT 1
78569: NEG
78570: PUSH
78571: LD_INT 0
78573: PUSH
78574: EMPTY
78575: LIST
78576: LIST
78577: PUSH
78578: LD_INT 1
78580: NEG
78581: PUSH
78582: LD_INT 1
78584: NEG
78585: PUSH
78586: EMPTY
78587: LIST
78588: LIST
78589: PUSH
78590: LD_INT 1
78592: NEG
78593: PUSH
78594: LD_INT 2
78596: NEG
78597: PUSH
78598: EMPTY
78599: LIST
78600: LIST
78601: PUSH
78602: LD_INT 0
78604: PUSH
78605: LD_INT 2
78607: NEG
78608: PUSH
78609: EMPTY
78610: LIST
78611: LIST
78612: PUSH
78613: LD_INT 1
78615: PUSH
78616: LD_INT 1
78618: NEG
78619: PUSH
78620: EMPTY
78621: LIST
78622: LIST
78623: PUSH
78624: LD_INT 1
78626: PUSH
78627: LD_INT 2
78629: PUSH
78630: EMPTY
78631: LIST
78632: LIST
78633: PUSH
78634: LD_INT 0
78636: PUSH
78637: LD_INT 2
78639: PUSH
78640: EMPTY
78641: LIST
78642: LIST
78643: PUSH
78644: LD_INT 1
78646: NEG
78647: PUSH
78648: LD_INT 1
78650: PUSH
78651: EMPTY
78652: LIST
78653: LIST
78654: PUSH
78655: LD_INT 1
78657: PUSH
78658: LD_INT 3
78660: PUSH
78661: EMPTY
78662: LIST
78663: LIST
78664: PUSH
78665: LD_INT 0
78667: PUSH
78668: LD_INT 3
78670: PUSH
78671: EMPTY
78672: LIST
78673: LIST
78674: PUSH
78675: LD_INT 1
78677: NEG
78678: PUSH
78679: LD_INT 2
78681: PUSH
78682: EMPTY
78683: LIST
78684: LIST
78685: PUSH
78686: EMPTY
78687: LIST
78688: LIST
78689: LIST
78690: LIST
78691: LIST
78692: LIST
78693: LIST
78694: LIST
78695: LIST
78696: LIST
78697: LIST
78698: LIST
78699: LIST
78700: LIST
78701: LIST
78702: LIST
78703: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78704: LD_ADDR_VAR 0 12
78708: PUSH
78709: LD_INT 0
78711: PUSH
78712: LD_INT 0
78714: PUSH
78715: EMPTY
78716: LIST
78717: LIST
78718: PUSH
78719: LD_INT 0
78721: PUSH
78722: LD_INT 1
78724: NEG
78725: PUSH
78726: EMPTY
78727: LIST
78728: LIST
78729: PUSH
78730: LD_INT 1
78732: PUSH
78733: LD_INT 0
78735: PUSH
78736: EMPTY
78737: LIST
78738: LIST
78739: PUSH
78740: LD_INT 1
78742: PUSH
78743: LD_INT 1
78745: PUSH
78746: EMPTY
78747: LIST
78748: LIST
78749: PUSH
78750: LD_INT 0
78752: PUSH
78753: LD_INT 1
78755: PUSH
78756: EMPTY
78757: LIST
78758: LIST
78759: PUSH
78760: LD_INT 1
78762: NEG
78763: PUSH
78764: LD_INT 0
78766: PUSH
78767: EMPTY
78768: LIST
78769: LIST
78770: PUSH
78771: LD_INT 1
78773: NEG
78774: PUSH
78775: LD_INT 1
78777: NEG
78778: PUSH
78779: EMPTY
78780: LIST
78781: LIST
78782: PUSH
78783: LD_INT 1
78785: PUSH
78786: LD_INT 1
78788: NEG
78789: PUSH
78790: EMPTY
78791: LIST
78792: LIST
78793: PUSH
78794: LD_INT 2
78796: PUSH
78797: LD_INT 0
78799: PUSH
78800: EMPTY
78801: LIST
78802: LIST
78803: PUSH
78804: LD_INT 2
78806: PUSH
78807: LD_INT 1
78809: PUSH
78810: EMPTY
78811: LIST
78812: LIST
78813: PUSH
78814: LD_INT 1
78816: NEG
78817: PUSH
78818: LD_INT 1
78820: PUSH
78821: EMPTY
78822: LIST
78823: LIST
78824: PUSH
78825: LD_INT 2
78827: NEG
78828: PUSH
78829: LD_INT 0
78831: PUSH
78832: EMPTY
78833: LIST
78834: LIST
78835: PUSH
78836: LD_INT 2
78838: NEG
78839: PUSH
78840: LD_INT 1
78842: NEG
78843: PUSH
78844: EMPTY
78845: LIST
78846: LIST
78847: PUSH
78848: LD_INT 2
78850: NEG
78851: PUSH
78852: LD_INT 1
78854: PUSH
78855: EMPTY
78856: LIST
78857: LIST
78858: PUSH
78859: LD_INT 3
78861: NEG
78862: PUSH
78863: LD_INT 0
78865: PUSH
78866: EMPTY
78867: LIST
78868: LIST
78869: PUSH
78870: LD_INT 3
78872: NEG
78873: PUSH
78874: LD_INT 1
78876: NEG
78877: PUSH
78878: EMPTY
78879: LIST
78880: LIST
78881: PUSH
78882: EMPTY
78883: LIST
78884: LIST
78885: LIST
78886: LIST
78887: LIST
78888: LIST
78889: LIST
78890: LIST
78891: LIST
78892: LIST
78893: LIST
78894: LIST
78895: LIST
78896: LIST
78897: LIST
78898: LIST
78899: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78900: LD_ADDR_VAR 0 13
78904: PUSH
78905: LD_INT 0
78907: PUSH
78908: LD_INT 0
78910: PUSH
78911: EMPTY
78912: LIST
78913: LIST
78914: PUSH
78915: LD_INT 0
78917: PUSH
78918: LD_INT 1
78920: NEG
78921: PUSH
78922: EMPTY
78923: LIST
78924: LIST
78925: PUSH
78926: LD_INT 1
78928: PUSH
78929: LD_INT 0
78931: PUSH
78932: EMPTY
78933: LIST
78934: LIST
78935: PUSH
78936: LD_INT 1
78938: PUSH
78939: LD_INT 1
78941: PUSH
78942: EMPTY
78943: LIST
78944: LIST
78945: PUSH
78946: LD_INT 0
78948: PUSH
78949: LD_INT 1
78951: PUSH
78952: EMPTY
78953: LIST
78954: LIST
78955: PUSH
78956: LD_INT 1
78958: NEG
78959: PUSH
78960: LD_INT 0
78962: PUSH
78963: EMPTY
78964: LIST
78965: LIST
78966: PUSH
78967: LD_INT 1
78969: NEG
78970: PUSH
78971: LD_INT 1
78973: NEG
78974: PUSH
78975: EMPTY
78976: LIST
78977: LIST
78978: PUSH
78979: LD_INT 1
78981: NEG
78982: PUSH
78983: LD_INT 2
78985: NEG
78986: PUSH
78987: EMPTY
78988: LIST
78989: LIST
78990: PUSH
78991: LD_INT 2
78993: PUSH
78994: LD_INT 1
78996: PUSH
78997: EMPTY
78998: LIST
78999: LIST
79000: PUSH
79001: LD_INT 2
79003: PUSH
79004: LD_INT 2
79006: PUSH
79007: EMPTY
79008: LIST
79009: LIST
79010: PUSH
79011: LD_INT 1
79013: PUSH
79014: LD_INT 2
79016: PUSH
79017: EMPTY
79018: LIST
79019: LIST
79020: PUSH
79021: LD_INT 2
79023: NEG
79024: PUSH
79025: LD_INT 1
79027: NEG
79028: PUSH
79029: EMPTY
79030: LIST
79031: LIST
79032: PUSH
79033: LD_INT 2
79035: NEG
79036: PUSH
79037: LD_INT 2
79039: NEG
79040: PUSH
79041: EMPTY
79042: LIST
79043: LIST
79044: PUSH
79045: LD_INT 2
79047: NEG
79048: PUSH
79049: LD_INT 3
79051: NEG
79052: PUSH
79053: EMPTY
79054: LIST
79055: LIST
79056: PUSH
79057: LD_INT 3
79059: NEG
79060: PUSH
79061: LD_INT 2
79063: NEG
79064: PUSH
79065: EMPTY
79066: LIST
79067: LIST
79068: PUSH
79069: LD_INT 3
79071: NEG
79072: PUSH
79073: LD_INT 3
79075: NEG
79076: PUSH
79077: EMPTY
79078: LIST
79079: LIST
79080: PUSH
79081: EMPTY
79082: LIST
79083: LIST
79084: LIST
79085: LIST
79086: LIST
79087: LIST
79088: LIST
79089: LIST
79090: LIST
79091: LIST
79092: LIST
79093: LIST
79094: LIST
79095: LIST
79096: LIST
79097: LIST
79098: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79099: LD_ADDR_VAR 0 14
79103: PUSH
79104: LD_INT 0
79106: PUSH
79107: LD_INT 0
79109: PUSH
79110: EMPTY
79111: LIST
79112: LIST
79113: PUSH
79114: LD_INT 0
79116: PUSH
79117: LD_INT 1
79119: NEG
79120: PUSH
79121: EMPTY
79122: LIST
79123: LIST
79124: PUSH
79125: LD_INT 1
79127: PUSH
79128: LD_INT 0
79130: PUSH
79131: EMPTY
79132: LIST
79133: LIST
79134: PUSH
79135: LD_INT 1
79137: PUSH
79138: LD_INT 1
79140: PUSH
79141: EMPTY
79142: LIST
79143: LIST
79144: PUSH
79145: LD_INT 0
79147: PUSH
79148: LD_INT 1
79150: PUSH
79151: EMPTY
79152: LIST
79153: LIST
79154: PUSH
79155: LD_INT 1
79157: NEG
79158: PUSH
79159: LD_INT 0
79161: PUSH
79162: EMPTY
79163: LIST
79164: LIST
79165: PUSH
79166: LD_INT 1
79168: NEG
79169: PUSH
79170: LD_INT 1
79172: NEG
79173: PUSH
79174: EMPTY
79175: LIST
79176: LIST
79177: PUSH
79178: LD_INT 1
79180: NEG
79181: PUSH
79182: LD_INT 2
79184: NEG
79185: PUSH
79186: EMPTY
79187: LIST
79188: LIST
79189: PUSH
79190: LD_INT 0
79192: PUSH
79193: LD_INT 2
79195: NEG
79196: PUSH
79197: EMPTY
79198: LIST
79199: LIST
79200: PUSH
79201: LD_INT 1
79203: PUSH
79204: LD_INT 1
79206: NEG
79207: PUSH
79208: EMPTY
79209: LIST
79210: LIST
79211: PUSH
79212: LD_INT 1
79214: PUSH
79215: LD_INT 2
79217: PUSH
79218: EMPTY
79219: LIST
79220: LIST
79221: PUSH
79222: LD_INT 0
79224: PUSH
79225: LD_INT 2
79227: PUSH
79228: EMPTY
79229: LIST
79230: LIST
79231: PUSH
79232: LD_INT 1
79234: NEG
79235: PUSH
79236: LD_INT 1
79238: PUSH
79239: EMPTY
79240: LIST
79241: LIST
79242: PUSH
79243: LD_INT 1
79245: NEG
79246: PUSH
79247: LD_INT 3
79249: NEG
79250: PUSH
79251: EMPTY
79252: LIST
79253: LIST
79254: PUSH
79255: LD_INT 0
79257: PUSH
79258: LD_INT 3
79260: NEG
79261: PUSH
79262: EMPTY
79263: LIST
79264: LIST
79265: PUSH
79266: LD_INT 1
79268: PUSH
79269: LD_INT 2
79271: NEG
79272: PUSH
79273: EMPTY
79274: LIST
79275: LIST
79276: PUSH
79277: EMPTY
79278: LIST
79279: LIST
79280: LIST
79281: LIST
79282: LIST
79283: LIST
79284: LIST
79285: LIST
79286: LIST
79287: LIST
79288: LIST
79289: LIST
79290: LIST
79291: LIST
79292: LIST
79293: LIST
79294: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79295: LD_ADDR_VAR 0 15
79299: PUSH
79300: LD_INT 0
79302: PUSH
79303: LD_INT 0
79305: PUSH
79306: EMPTY
79307: LIST
79308: LIST
79309: PUSH
79310: LD_INT 0
79312: PUSH
79313: LD_INT 1
79315: NEG
79316: PUSH
79317: EMPTY
79318: LIST
79319: LIST
79320: PUSH
79321: LD_INT 1
79323: PUSH
79324: LD_INT 0
79326: PUSH
79327: EMPTY
79328: LIST
79329: LIST
79330: PUSH
79331: LD_INT 1
79333: PUSH
79334: LD_INT 1
79336: PUSH
79337: EMPTY
79338: LIST
79339: LIST
79340: PUSH
79341: LD_INT 0
79343: PUSH
79344: LD_INT 1
79346: PUSH
79347: EMPTY
79348: LIST
79349: LIST
79350: PUSH
79351: LD_INT 1
79353: NEG
79354: PUSH
79355: LD_INT 0
79357: PUSH
79358: EMPTY
79359: LIST
79360: LIST
79361: PUSH
79362: LD_INT 1
79364: NEG
79365: PUSH
79366: LD_INT 1
79368: NEG
79369: PUSH
79370: EMPTY
79371: LIST
79372: LIST
79373: PUSH
79374: LD_INT 1
79376: PUSH
79377: LD_INT 1
79379: NEG
79380: PUSH
79381: EMPTY
79382: LIST
79383: LIST
79384: PUSH
79385: LD_INT 2
79387: PUSH
79388: LD_INT 0
79390: PUSH
79391: EMPTY
79392: LIST
79393: LIST
79394: PUSH
79395: LD_INT 2
79397: PUSH
79398: LD_INT 1
79400: PUSH
79401: EMPTY
79402: LIST
79403: LIST
79404: PUSH
79405: LD_INT 1
79407: NEG
79408: PUSH
79409: LD_INT 1
79411: PUSH
79412: EMPTY
79413: LIST
79414: LIST
79415: PUSH
79416: LD_INT 2
79418: NEG
79419: PUSH
79420: LD_INT 0
79422: PUSH
79423: EMPTY
79424: LIST
79425: LIST
79426: PUSH
79427: LD_INT 2
79429: NEG
79430: PUSH
79431: LD_INT 1
79433: NEG
79434: PUSH
79435: EMPTY
79436: LIST
79437: LIST
79438: PUSH
79439: LD_INT 2
79441: PUSH
79442: LD_INT 1
79444: NEG
79445: PUSH
79446: EMPTY
79447: LIST
79448: LIST
79449: PUSH
79450: LD_INT 3
79452: PUSH
79453: LD_INT 0
79455: PUSH
79456: EMPTY
79457: LIST
79458: LIST
79459: PUSH
79460: LD_INT 3
79462: PUSH
79463: LD_INT 1
79465: PUSH
79466: EMPTY
79467: LIST
79468: LIST
79469: PUSH
79470: EMPTY
79471: LIST
79472: LIST
79473: LIST
79474: LIST
79475: LIST
79476: LIST
79477: LIST
79478: LIST
79479: LIST
79480: LIST
79481: LIST
79482: LIST
79483: LIST
79484: LIST
79485: LIST
79486: LIST
79487: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79488: LD_ADDR_VAR 0 16
79492: PUSH
79493: LD_INT 0
79495: PUSH
79496: LD_INT 0
79498: PUSH
79499: EMPTY
79500: LIST
79501: LIST
79502: PUSH
79503: LD_INT 0
79505: PUSH
79506: LD_INT 1
79508: NEG
79509: PUSH
79510: EMPTY
79511: LIST
79512: LIST
79513: PUSH
79514: LD_INT 1
79516: PUSH
79517: LD_INT 0
79519: PUSH
79520: EMPTY
79521: LIST
79522: LIST
79523: PUSH
79524: LD_INT 1
79526: PUSH
79527: LD_INT 1
79529: PUSH
79530: EMPTY
79531: LIST
79532: LIST
79533: PUSH
79534: LD_INT 0
79536: PUSH
79537: LD_INT 1
79539: PUSH
79540: EMPTY
79541: LIST
79542: LIST
79543: PUSH
79544: LD_INT 1
79546: NEG
79547: PUSH
79548: LD_INT 0
79550: PUSH
79551: EMPTY
79552: LIST
79553: LIST
79554: PUSH
79555: LD_INT 1
79557: NEG
79558: PUSH
79559: LD_INT 1
79561: NEG
79562: PUSH
79563: EMPTY
79564: LIST
79565: LIST
79566: PUSH
79567: LD_INT 1
79569: NEG
79570: PUSH
79571: LD_INT 2
79573: NEG
79574: PUSH
79575: EMPTY
79576: LIST
79577: LIST
79578: PUSH
79579: LD_INT 2
79581: PUSH
79582: LD_INT 1
79584: PUSH
79585: EMPTY
79586: LIST
79587: LIST
79588: PUSH
79589: LD_INT 2
79591: PUSH
79592: LD_INT 2
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: PUSH
79599: LD_INT 1
79601: PUSH
79602: LD_INT 2
79604: PUSH
79605: EMPTY
79606: LIST
79607: LIST
79608: PUSH
79609: LD_INT 2
79611: NEG
79612: PUSH
79613: LD_INT 1
79615: NEG
79616: PUSH
79617: EMPTY
79618: LIST
79619: LIST
79620: PUSH
79621: LD_INT 2
79623: NEG
79624: PUSH
79625: LD_INT 2
79627: NEG
79628: PUSH
79629: EMPTY
79630: LIST
79631: LIST
79632: PUSH
79633: LD_INT 3
79635: PUSH
79636: LD_INT 2
79638: PUSH
79639: EMPTY
79640: LIST
79641: LIST
79642: PUSH
79643: LD_INT 3
79645: PUSH
79646: LD_INT 3
79648: PUSH
79649: EMPTY
79650: LIST
79651: LIST
79652: PUSH
79653: LD_INT 2
79655: PUSH
79656: LD_INT 3
79658: PUSH
79659: EMPTY
79660: LIST
79661: LIST
79662: PUSH
79663: EMPTY
79664: LIST
79665: LIST
79666: LIST
79667: LIST
79668: LIST
79669: LIST
79670: LIST
79671: LIST
79672: LIST
79673: LIST
79674: LIST
79675: LIST
79676: LIST
79677: LIST
79678: LIST
79679: LIST
79680: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79681: LD_ADDR_VAR 0 17
79685: PUSH
79686: LD_INT 0
79688: PUSH
79689: LD_INT 0
79691: PUSH
79692: EMPTY
79693: LIST
79694: LIST
79695: PUSH
79696: LD_INT 0
79698: PUSH
79699: LD_INT 1
79701: NEG
79702: PUSH
79703: EMPTY
79704: LIST
79705: LIST
79706: PUSH
79707: LD_INT 1
79709: PUSH
79710: LD_INT 0
79712: PUSH
79713: EMPTY
79714: LIST
79715: LIST
79716: PUSH
79717: LD_INT 1
79719: PUSH
79720: LD_INT 1
79722: PUSH
79723: EMPTY
79724: LIST
79725: LIST
79726: PUSH
79727: LD_INT 0
79729: PUSH
79730: LD_INT 1
79732: PUSH
79733: EMPTY
79734: LIST
79735: LIST
79736: PUSH
79737: LD_INT 1
79739: NEG
79740: PUSH
79741: LD_INT 0
79743: PUSH
79744: EMPTY
79745: LIST
79746: LIST
79747: PUSH
79748: LD_INT 1
79750: NEG
79751: PUSH
79752: LD_INT 1
79754: NEG
79755: PUSH
79756: EMPTY
79757: LIST
79758: LIST
79759: PUSH
79760: LD_INT 1
79762: NEG
79763: PUSH
79764: LD_INT 2
79766: NEG
79767: PUSH
79768: EMPTY
79769: LIST
79770: LIST
79771: PUSH
79772: LD_INT 0
79774: PUSH
79775: LD_INT 2
79777: NEG
79778: PUSH
79779: EMPTY
79780: LIST
79781: LIST
79782: PUSH
79783: LD_INT 1
79785: PUSH
79786: LD_INT 1
79788: NEG
79789: PUSH
79790: EMPTY
79791: LIST
79792: LIST
79793: PUSH
79794: LD_INT 2
79796: PUSH
79797: LD_INT 0
79799: PUSH
79800: EMPTY
79801: LIST
79802: LIST
79803: PUSH
79804: LD_INT 2
79806: PUSH
79807: LD_INT 1
79809: PUSH
79810: EMPTY
79811: LIST
79812: LIST
79813: PUSH
79814: LD_INT 2
79816: PUSH
79817: LD_INT 2
79819: PUSH
79820: EMPTY
79821: LIST
79822: LIST
79823: PUSH
79824: LD_INT 1
79826: PUSH
79827: LD_INT 2
79829: PUSH
79830: EMPTY
79831: LIST
79832: LIST
79833: PUSH
79834: LD_INT 0
79836: PUSH
79837: LD_INT 2
79839: PUSH
79840: EMPTY
79841: LIST
79842: LIST
79843: PUSH
79844: LD_INT 1
79846: NEG
79847: PUSH
79848: LD_INT 1
79850: PUSH
79851: EMPTY
79852: LIST
79853: LIST
79854: PUSH
79855: LD_INT 2
79857: NEG
79858: PUSH
79859: LD_INT 0
79861: PUSH
79862: EMPTY
79863: LIST
79864: LIST
79865: PUSH
79866: LD_INT 2
79868: NEG
79869: PUSH
79870: LD_INT 1
79872: NEG
79873: PUSH
79874: EMPTY
79875: LIST
79876: LIST
79877: PUSH
79878: LD_INT 2
79880: NEG
79881: PUSH
79882: LD_INT 2
79884: NEG
79885: PUSH
79886: EMPTY
79887: LIST
79888: LIST
79889: PUSH
79890: EMPTY
79891: LIST
79892: LIST
79893: LIST
79894: LIST
79895: LIST
79896: LIST
79897: LIST
79898: LIST
79899: LIST
79900: LIST
79901: LIST
79902: LIST
79903: LIST
79904: LIST
79905: LIST
79906: LIST
79907: LIST
79908: LIST
79909: LIST
79910: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79911: LD_ADDR_VAR 0 18
79915: PUSH
79916: LD_INT 0
79918: PUSH
79919: LD_INT 0
79921: PUSH
79922: EMPTY
79923: LIST
79924: LIST
79925: PUSH
79926: LD_INT 0
79928: PUSH
79929: LD_INT 1
79931: NEG
79932: PUSH
79933: EMPTY
79934: LIST
79935: LIST
79936: PUSH
79937: LD_INT 1
79939: PUSH
79940: LD_INT 0
79942: PUSH
79943: EMPTY
79944: LIST
79945: LIST
79946: PUSH
79947: LD_INT 1
79949: PUSH
79950: LD_INT 1
79952: PUSH
79953: EMPTY
79954: LIST
79955: LIST
79956: PUSH
79957: LD_INT 0
79959: PUSH
79960: LD_INT 1
79962: PUSH
79963: EMPTY
79964: LIST
79965: LIST
79966: PUSH
79967: LD_INT 1
79969: NEG
79970: PUSH
79971: LD_INT 0
79973: PUSH
79974: EMPTY
79975: LIST
79976: LIST
79977: PUSH
79978: LD_INT 1
79980: NEG
79981: PUSH
79982: LD_INT 1
79984: NEG
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: PUSH
79990: LD_INT 1
79992: NEG
79993: PUSH
79994: LD_INT 2
79996: NEG
79997: PUSH
79998: EMPTY
79999: LIST
80000: LIST
80001: PUSH
80002: LD_INT 0
80004: PUSH
80005: LD_INT 2
80007: NEG
80008: PUSH
80009: EMPTY
80010: LIST
80011: LIST
80012: PUSH
80013: LD_INT 1
80015: PUSH
80016: LD_INT 1
80018: NEG
80019: PUSH
80020: EMPTY
80021: LIST
80022: LIST
80023: PUSH
80024: LD_INT 2
80026: PUSH
80027: LD_INT 0
80029: PUSH
80030: EMPTY
80031: LIST
80032: LIST
80033: PUSH
80034: LD_INT 2
80036: PUSH
80037: LD_INT 1
80039: PUSH
80040: EMPTY
80041: LIST
80042: LIST
80043: PUSH
80044: LD_INT 2
80046: PUSH
80047: LD_INT 2
80049: PUSH
80050: EMPTY
80051: LIST
80052: LIST
80053: PUSH
80054: LD_INT 1
80056: PUSH
80057: LD_INT 2
80059: PUSH
80060: EMPTY
80061: LIST
80062: LIST
80063: PUSH
80064: LD_INT 0
80066: PUSH
80067: LD_INT 2
80069: PUSH
80070: EMPTY
80071: LIST
80072: LIST
80073: PUSH
80074: LD_INT 1
80076: NEG
80077: PUSH
80078: LD_INT 1
80080: PUSH
80081: EMPTY
80082: LIST
80083: LIST
80084: PUSH
80085: LD_INT 2
80087: NEG
80088: PUSH
80089: LD_INT 0
80091: PUSH
80092: EMPTY
80093: LIST
80094: LIST
80095: PUSH
80096: LD_INT 2
80098: NEG
80099: PUSH
80100: LD_INT 1
80102: NEG
80103: PUSH
80104: EMPTY
80105: LIST
80106: LIST
80107: PUSH
80108: LD_INT 2
80110: NEG
80111: PUSH
80112: LD_INT 2
80114: NEG
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: PUSH
80120: EMPTY
80121: LIST
80122: LIST
80123: LIST
80124: LIST
80125: LIST
80126: LIST
80127: LIST
80128: LIST
80129: LIST
80130: LIST
80131: LIST
80132: LIST
80133: LIST
80134: LIST
80135: LIST
80136: LIST
80137: LIST
80138: LIST
80139: LIST
80140: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80141: LD_ADDR_VAR 0 19
80145: PUSH
80146: LD_INT 0
80148: PUSH
80149: LD_INT 0
80151: PUSH
80152: EMPTY
80153: LIST
80154: LIST
80155: PUSH
80156: LD_INT 0
80158: PUSH
80159: LD_INT 1
80161: NEG
80162: PUSH
80163: EMPTY
80164: LIST
80165: LIST
80166: PUSH
80167: LD_INT 1
80169: PUSH
80170: LD_INT 0
80172: PUSH
80173: EMPTY
80174: LIST
80175: LIST
80176: PUSH
80177: LD_INT 1
80179: PUSH
80180: LD_INT 1
80182: PUSH
80183: EMPTY
80184: LIST
80185: LIST
80186: PUSH
80187: LD_INT 0
80189: PUSH
80190: LD_INT 1
80192: PUSH
80193: EMPTY
80194: LIST
80195: LIST
80196: PUSH
80197: LD_INT 1
80199: NEG
80200: PUSH
80201: LD_INT 0
80203: PUSH
80204: EMPTY
80205: LIST
80206: LIST
80207: PUSH
80208: LD_INT 1
80210: NEG
80211: PUSH
80212: LD_INT 1
80214: NEG
80215: PUSH
80216: EMPTY
80217: LIST
80218: LIST
80219: PUSH
80220: LD_INT 1
80222: NEG
80223: PUSH
80224: LD_INT 2
80226: NEG
80227: PUSH
80228: EMPTY
80229: LIST
80230: LIST
80231: PUSH
80232: LD_INT 0
80234: PUSH
80235: LD_INT 2
80237: NEG
80238: PUSH
80239: EMPTY
80240: LIST
80241: LIST
80242: PUSH
80243: LD_INT 1
80245: PUSH
80246: LD_INT 1
80248: NEG
80249: PUSH
80250: EMPTY
80251: LIST
80252: LIST
80253: PUSH
80254: LD_INT 2
80256: PUSH
80257: LD_INT 0
80259: PUSH
80260: EMPTY
80261: LIST
80262: LIST
80263: PUSH
80264: LD_INT 2
80266: PUSH
80267: LD_INT 1
80269: PUSH
80270: EMPTY
80271: LIST
80272: LIST
80273: PUSH
80274: LD_INT 2
80276: PUSH
80277: LD_INT 2
80279: PUSH
80280: EMPTY
80281: LIST
80282: LIST
80283: PUSH
80284: LD_INT 1
80286: PUSH
80287: LD_INT 2
80289: PUSH
80290: EMPTY
80291: LIST
80292: LIST
80293: PUSH
80294: LD_INT 0
80296: PUSH
80297: LD_INT 2
80299: PUSH
80300: EMPTY
80301: LIST
80302: LIST
80303: PUSH
80304: LD_INT 1
80306: NEG
80307: PUSH
80308: LD_INT 1
80310: PUSH
80311: EMPTY
80312: LIST
80313: LIST
80314: PUSH
80315: LD_INT 2
80317: NEG
80318: PUSH
80319: LD_INT 0
80321: PUSH
80322: EMPTY
80323: LIST
80324: LIST
80325: PUSH
80326: LD_INT 2
80328: NEG
80329: PUSH
80330: LD_INT 1
80332: NEG
80333: PUSH
80334: EMPTY
80335: LIST
80336: LIST
80337: PUSH
80338: LD_INT 2
80340: NEG
80341: PUSH
80342: LD_INT 2
80344: NEG
80345: PUSH
80346: EMPTY
80347: LIST
80348: LIST
80349: PUSH
80350: EMPTY
80351: LIST
80352: LIST
80353: LIST
80354: LIST
80355: LIST
80356: LIST
80357: LIST
80358: LIST
80359: LIST
80360: LIST
80361: LIST
80362: LIST
80363: LIST
80364: LIST
80365: LIST
80366: LIST
80367: LIST
80368: LIST
80369: LIST
80370: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80371: LD_ADDR_VAR 0 20
80375: PUSH
80376: LD_INT 0
80378: PUSH
80379: LD_INT 0
80381: PUSH
80382: EMPTY
80383: LIST
80384: LIST
80385: PUSH
80386: LD_INT 0
80388: PUSH
80389: LD_INT 1
80391: NEG
80392: PUSH
80393: EMPTY
80394: LIST
80395: LIST
80396: PUSH
80397: LD_INT 1
80399: PUSH
80400: LD_INT 0
80402: PUSH
80403: EMPTY
80404: LIST
80405: LIST
80406: PUSH
80407: LD_INT 1
80409: PUSH
80410: LD_INT 1
80412: PUSH
80413: EMPTY
80414: LIST
80415: LIST
80416: PUSH
80417: LD_INT 0
80419: PUSH
80420: LD_INT 1
80422: PUSH
80423: EMPTY
80424: LIST
80425: LIST
80426: PUSH
80427: LD_INT 1
80429: NEG
80430: PUSH
80431: LD_INT 0
80433: PUSH
80434: EMPTY
80435: LIST
80436: LIST
80437: PUSH
80438: LD_INT 1
80440: NEG
80441: PUSH
80442: LD_INT 1
80444: NEG
80445: PUSH
80446: EMPTY
80447: LIST
80448: LIST
80449: PUSH
80450: LD_INT 1
80452: NEG
80453: PUSH
80454: LD_INT 2
80456: NEG
80457: PUSH
80458: EMPTY
80459: LIST
80460: LIST
80461: PUSH
80462: LD_INT 0
80464: PUSH
80465: LD_INT 2
80467: NEG
80468: PUSH
80469: EMPTY
80470: LIST
80471: LIST
80472: PUSH
80473: LD_INT 1
80475: PUSH
80476: LD_INT 1
80478: NEG
80479: PUSH
80480: EMPTY
80481: LIST
80482: LIST
80483: PUSH
80484: LD_INT 2
80486: PUSH
80487: LD_INT 0
80489: PUSH
80490: EMPTY
80491: LIST
80492: LIST
80493: PUSH
80494: LD_INT 2
80496: PUSH
80497: LD_INT 1
80499: PUSH
80500: EMPTY
80501: LIST
80502: LIST
80503: PUSH
80504: LD_INT 2
80506: PUSH
80507: LD_INT 2
80509: PUSH
80510: EMPTY
80511: LIST
80512: LIST
80513: PUSH
80514: LD_INT 1
80516: PUSH
80517: LD_INT 2
80519: PUSH
80520: EMPTY
80521: LIST
80522: LIST
80523: PUSH
80524: LD_INT 0
80526: PUSH
80527: LD_INT 2
80529: PUSH
80530: EMPTY
80531: LIST
80532: LIST
80533: PUSH
80534: LD_INT 1
80536: NEG
80537: PUSH
80538: LD_INT 1
80540: PUSH
80541: EMPTY
80542: LIST
80543: LIST
80544: PUSH
80545: LD_INT 2
80547: NEG
80548: PUSH
80549: LD_INT 0
80551: PUSH
80552: EMPTY
80553: LIST
80554: LIST
80555: PUSH
80556: LD_INT 2
80558: NEG
80559: PUSH
80560: LD_INT 1
80562: NEG
80563: PUSH
80564: EMPTY
80565: LIST
80566: LIST
80567: PUSH
80568: LD_INT 2
80570: NEG
80571: PUSH
80572: LD_INT 2
80574: NEG
80575: PUSH
80576: EMPTY
80577: LIST
80578: LIST
80579: PUSH
80580: EMPTY
80581: LIST
80582: LIST
80583: LIST
80584: LIST
80585: LIST
80586: LIST
80587: LIST
80588: LIST
80589: LIST
80590: LIST
80591: LIST
80592: LIST
80593: LIST
80594: LIST
80595: LIST
80596: LIST
80597: LIST
80598: LIST
80599: LIST
80600: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80601: LD_ADDR_VAR 0 21
80605: PUSH
80606: LD_INT 0
80608: PUSH
80609: LD_INT 0
80611: PUSH
80612: EMPTY
80613: LIST
80614: LIST
80615: PUSH
80616: LD_INT 0
80618: PUSH
80619: LD_INT 1
80621: NEG
80622: PUSH
80623: EMPTY
80624: LIST
80625: LIST
80626: PUSH
80627: LD_INT 1
80629: PUSH
80630: LD_INT 0
80632: PUSH
80633: EMPTY
80634: LIST
80635: LIST
80636: PUSH
80637: LD_INT 1
80639: PUSH
80640: LD_INT 1
80642: PUSH
80643: EMPTY
80644: LIST
80645: LIST
80646: PUSH
80647: LD_INT 0
80649: PUSH
80650: LD_INT 1
80652: PUSH
80653: EMPTY
80654: LIST
80655: LIST
80656: PUSH
80657: LD_INT 1
80659: NEG
80660: PUSH
80661: LD_INT 0
80663: PUSH
80664: EMPTY
80665: LIST
80666: LIST
80667: PUSH
80668: LD_INT 1
80670: NEG
80671: PUSH
80672: LD_INT 1
80674: NEG
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: PUSH
80680: LD_INT 1
80682: NEG
80683: PUSH
80684: LD_INT 2
80686: NEG
80687: PUSH
80688: EMPTY
80689: LIST
80690: LIST
80691: PUSH
80692: LD_INT 0
80694: PUSH
80695: LD_INT 2
80697: NEG
80698: PUSH
80699: EMPTY
80700: LIST
80701: LIST
80702: PUSH
80703: LD_INT 1
80705: PUSH
80706: LD_INT 1
80708: NEG
80709: PUSH
80710: EMPTY
80711: LIST
80712: LIST
80713: PUSH
80714: LD_INT 2
80716: PUSH
80717: LD_INT 0
80719: PUSH
80720: EMPTY
80721: LIST
80722: LIST
80723: PUSH
80724: LD_INT 2
80726: PUSH
80727: LD_INT 1
80729: PUSH
80730: EMPTY
80731: LIST
80732: LIST
80733: PUSH
80734: LD_INT 2
80736: PUSH
80737: LD_INT 2
80739: PUSH
80740: EMPTY
80741: LIST
80742: LIST
80743: PUSH
80744: LD_INT 1
80746: PUSH
80747: LD_INT 2
80749: PUSH
80750: EMPTY
80751: LIST
80752: LIST
80753: PUSH
80754: LD_INT 0
80756: PUSH
80757: LD_INT 2
80759: PUSH
80760: EMPTY
80761: LIST
80762: LIST
80763: PUSH
80764: LD_INT 1
80766: NEG
80767: PUSH
80768: LD_INT 1
80770: PUSH
80771: EMPTY
80772: LIST
80773: LIST
80774: PUSH
80775: LD_INT 2
80777: NEG
80778: PUSH
80779: LD_INT 0
80781: PUSH
80782: EMPTY
80783: LIST
80784: LIST
80785: PUSH
80786: LD_INT 2
80788: NEG
80789: PUSH
80790: LD_INT 1
80792: NEG
80793: PUSH
80794: EMPTY
80795: LIST
80796: LIST
80797: PUSH
80798: LD_INT 2
80800: NEG
80801: PUSH
80802: LD_INT 2
80804: NEG
80805: PUSH
80806: EMPTY
80807: LIST
80808: LIST
80809: PUSH
80810: EMPTY
80811: LIST
80812: LIST
80813: LIST
80814: LIST
80815: LIST
80816: LIST
80817: LIST
80818: LIST
80819: LIST
80820: LIST
80821: LIST
80822: LIST
80823: LIST
80824: LIST
80825: LIST
80826: LIST
80827: LIST
80828: LIST
80829: LIST
80830: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80831: LD_ADDR_VAR 0 22
80835: PUSH
80836: LD_INT 0
80838: PUSH
80839: LD_INT 0
80841: PUSH
80842: EMPTY
80843: LIST
80844: LIST
80845: PUSH
80846: LD_INT 0
80848: PUSH
80849: LD_INT 1
80851: NEG
80852: PUSH
80853: EMPTY
80854: LIST
80855: LIST
80856: PUSH
80857: LD_INT 1
80859: PUSH
80860: LD_INT 0
80862: PUSH
80863: EMPTY
80864: LIST
80865: LIST
80866: PUSH
80867: LD_INT 1
80869: PUSH
80870: LD_INT 1
80872: PUSH
80873: EMPTY
80874: LIST
80875: LIST
80876: PUSH
80877: LD_INT 0
80879: PUSH
80880: LD_INT 1
80882: PUSH
80883: EMPTY
80884: LIST
80885: LIST
80886: PUSH
80887: LD_INT 1
80889: NEG
80890: PUSH
80891: LD_INT 0
80893: PUSH
80894: EMPTY
80895: LIST
80896: LIST
80897: PUSH
80898: LD_INT 1
80900: NEG
80901: PUSH
80902: LD_INT 1
80904: NEG
80905: PUSH
80906: EMPTY
80907: LIST
80908: LIST
80909: PUSH
80910: LD_INT 1
80912: NEG
80913: PUSH
80914: LD_INT 2
80916: NEG
80917: PUSH
80918: EMPTY
80919: LIST
80920: LIST
80921: PUSH
80922: LD_INT 0
80924: PUSH
80925: LD_INT 2
80927: NEG
80928: PUSH
80929: EMPTY
80930: LIST
80931: LIST
80932: PUSH
80933: LD_INT 1
80935: PUSH
80936: LD_INT 1
80938: NEG
80939: PUSH
80940: EMPTY
80941: LIST
80942: LIST
80943: PUSH
80944: LD_INT 2
80946: PUSH
80947: LD_INT 0
80949: PUSH
80950: EMPTY
80951: LIST
80952: LIST
80953: PUSH
80954: LD_INT 2
80956: PUSH
80957: LD_INT 1
80959: PUSH
80960: EMPTY
80961: LIST
80962: LIST
80963: PUSH
80964: LD_INT 2
80966: PUSH
80967: LD_INT 2
80969: PUSH
80970: EMPTY
80971: LIST
80972: LIST
80973: PUSH
80974: LD_INT 1
80976: PUSH
80977: LD_INT 2
80979: PUSH
80980: EMPTY
80981: LIST
80982: LIST
80983: PUSH
80984: LD_INT 0
80986: PUSH
80987: LD_INT 2
80989: PUSH
80990: EMPTY
80991: LIST
80992: LIST
80993: PUSH
80994: LD_INT 1
80996: NEG
80997: PUSH
80998: LD_INT 1
81000: PUSH
81001: EMPTY
81002: LIST
81003: LIST
81004: PUSH
81005: LD_INT 2
81007: NEG
81008: PUSH
81009: LD_INT 0
81011: PUSH
81012: EMPTY
81013: LIST
81014: LIST
81015: PUSH
81016: LD_INT 2
81018: NEG
81019: PUSH
81020: LD_INT 1
81022: NEG
81023: PUSH
81024: EMPTY
81025: LIST
81026: LIST
81027: PUSH
81028: LD_INT 2
81030: NEG
81031: PUSH
81032: LD_INT 2
81034: NEG
81035: PUSH
81036: EMPTY
81037: LIST
81038: LIST
81039: PUSH
81040: EMPTY
81041: LIST
81042: LIST
81043: LIST
81044: LIST
81045: LIST
81046: LIST
81047: LIST
81048: LIST
81049: LIST
81050: LIST
81051: LIST
81052: LIST
81053: LIST
81054: LIST
81055: LIST
81056: LIST
81057: LIST
81058: LIST
81059: LIST
81060: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
81061: LD_ADDR_VAR 0 23
81065: PUSH
81066: LD_INT 0
81068: PUSH
81069: LD_INT 0
81071: PUSH
81072: EMPTY
81073: LIST
81074: LIST
81075: PUSH
81076: LD_INT 0
81078: PUSH
81079: LD_INT 1
81081: NEG
81082: PUSH
81083: EMPTY
81084: LIST
81085: LIST
81086: PUSH
81087: LD_INT 1
81089: PUSH
81090: LD_INT 0
81092: PUSH
81093: EMPTY
81094: LIST
81095: LIST
81096: PUSH
81097: LD_INT 1
81099: PUSH
81100: LD_INT 1
81102: PUSH
81103: EMPTY
81104: LIST
81105: LIST
81106: PUSH
81107: LD_INT 0
81109: PUSH
81110: LD_INT 1
81112: PUSH
81113: EMPTY
81114: LIST
81115: LIST
81116: PUSH
81117: LD_INT 1
81119: NEG
81120: PUSH
81121: LD_INT 0
81123: PUSH
81124: EMPTY
81125: LIST
81126: LIST
81127: PUSH
81128: LD_INT 1
81130: NEG
81131: PUSH
81132: LD_INT 1
81134: NEG
81135: PUSH
81136: EMPTY
81137: LIST
81138: LIST
81139: PUSH
81140: LD_INT 1
81142: NEG
81143: PUSH
81144: LD_INT 2
81146: NEG
81147: PUSH
81148: EMPTY
81149: LIST
81150: LIST
81151: PUSH
81152: LD_INT 0
81154: PUSH
81155: LD_INT 2
81157: NEG
81158: PUSH
81159: EMPTY
81160: LIST
81161: LIST
81162: PUSH
81163: LD_INT 1
81165: PUSH
81166: LD_INT 1
81168: NEG
81169: PUSH
81170: EMPTY
81171: LIST
81172: LIST
81173: PUSH
81174: LD_INT 2
81176: PUSH
81177: LD_INT 0
81179: PUSH
81180: EMPTY
81181: LIST
81182: LIST
81183: PUSH
81184: LD_INT 2
81186: PUSH
81187: LD_INT 1
81189: PUSH
81190: EMPTY
81191: LIST
81192: LIST
81193: PUSH
81194: LD_INT 2
81196: PUSH
81197: LD_INT 2
81199: PUSH
81200: EMPTY
81201: LIST
81202: LIST
81203: PUSH
81204: LD_INT 1
81206: PUSH
81207: LD_INT 2
81209: PUSH
81210: EMPTY
81211: LIST
81212: LIST
81213: PUSH
81214: LD_INT 0
81216: PUSH
81217: LD_INT 2
81219: PUSH
81220: EMPTY
81221: LIST
81222: LIST
81223: PUSH
81224: LD_INT 1
81226: NEG
81227: PUSH
81228: LD_INT 1
81230: PUSH
81231: EMPTY
81232: LIST
81233: LIST
81234: PUSH
81235: LD_INT 2
81237: NEG
81238: PUSH
81239: LD_INT 0
81241: PUSH
81242: EMPTY
81243: LIST
81244: LIST
81245: PUSH
81246: LD_INT 2
81248: NEG
81249: PUSH
81250: LD_INT 1
81252: NEG
81253: PUSH
81254: EMPTY
81255: LIST
81256: LIST
81257: PUSH
81258: LD_INT 2
81260: NEG
81261: PUSH
81262: LD_INT 2
81264: NEG
81265: PUSH
81266: EMPTY
81267: LIST
81268: LIST
81269: PUSH
81270: LD_INT 2
81272: NEG
81273: PUSH
81274: LD_INT 3
81276: NEG
81277: PUSH
81278: EMPTY
81279: LIST
81280: LIST
81281: PUSH
81282: LD_INT 1
81284: NEG
81285: PUSH
81286: LD_INT 3
81288: NEG
81289: PUSH
81290: EMPTY
81291: LIST
81292: LIST
81293: PUSH
81294: LD_INT 1
81296: PUSH
81297: LD_INT 2
81299: NEG
81300: PUSH
81301: EMPTY
81302: LIST
81303: LIST
81304: PUSH
81305: LD_INT 2
81307: PUSH
81308: LD_INT 1
81310: NEG
81311: PUSH
81312: EMPTY
81313: LIST
81314: LIST
81315: PUSH
81316: EMPTY
81317: LIST
81318: LIST
81319: LIST
81320: LIST
81321: LIST
81322: LIST
81323: LIST
81324: LIST
81325: LIST
81326: LIST
81327: LIST
81328: LIST
81329: LIST
81330: LIST
81331: LIST
81332: LIST
81333: LIST
81334: LIST
81335: LIST
81336: LIST
81337: LIST
81338: LIST
81339: LIST
81340: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
81341: LD_ADDR_VAR 0 24
81345: PUSH
81346: LD_INT 0
81348: PUSH
81349: LD_INT 0
81351: PUSH
81352: EMPTY
81353: LIST
81354: LIST
81355: PUSH
81356: LD_INT 0
81358: PUSH
81359: LD_INT 1
81361: NEG
81362: PUSH
81363: EMPTY
81364: LIST
81365: LIST
81366: PUSH
81367: LD_INT 1
81369: PUSH
81370: LD_INT 0
81372: PUSH
81373: EMPTY
81374: LIST
81375: LIST
81376: PUSH
81377: LD_INT 1
81379: PUSH
81380: LD_INT 1
81382: PUSH
81383: EMPTY
81384: LIST
81385: LIST
81386: PUSH
81387: LD_INT 0
81389: PUSH
81390: LD_INT 1
81392: PUSH
81393: EMPTY
81394: LIST
81395: LIST
81396: PUSH
81397: LD_INT 1
81399: NEG
81400: PUSH
81401: LD_INT 0
81403: PUSH
81404: EMPTY
81405: LIST
81406: LIST
81407: PUSH
81408: LD_INT 1
81410: NEG
81411: PUSH
81412: LD_INT 1
81414: NEG
81415: PUSH
81416: EMPTY
81417: LIST
81418: LIST
81419: PUSH
81420: LD_INT 1
81422: NEG
81423: PUSH
81424: LD_INT 2
81426: NEG
81427: PUSH
81428: EMPTY
81429: LIST
81430: LIST
81431: PUSH
81432: LD_INT 0
81434: PUSH
81435: LD_INT 2
81437: NEG
81438: PUSH
81439: EMPTY
81440: LIST
81441: LIST
81442: PUSH
81443: LD_INT 1
81445: PUSH
81446: LD_INT 1
81448: NEG
81449: PUSH
81450: EMPTY
81451: LIST
81452: LIST
81453: PUSH
81454: LD_INT 2
81456: PUSH
81457: LD_INT 0
81459: PUSH
81460: EMPTY
81461: LIST
81462: LIST
81463: PUSH
81464: LD_INT 2
81466: PUSH
81467: LD_INT 1
81469: PUSH
81470: EMPTY
81471: LIST
81472: LIST
81473: PUSH
81474: LD_INT 2
81476: PUSH
81477: LD_INT 2
81479: PUSH
81480: EMPTY
81481: LIST
81482: LIST
81483: PUSH
81484: LD_INT 1
81486: PUSH
81487: LD_INT 2
81489: PUSH
81490: EMPTY
81491: LIST
81492: LIST
81493: PUSH
81494: LD_INT 0
81496: PUSH
81497: LD_INT 2
81499: PUSH
81500: EMPTY
81501: LIST
81502: LIST
81503: PUSH
81504: LD_INT 1
81506: NEG
81507: PUSH
81508: LD_INT 1
81510: PUSH
81511: EMPTY
81512: LIST
81513: LIST
81514: PUSH
81515: LD_INT 2
81517: NEG
81518: PUSH
81519: LD_INT 0
81521: PUSH
81522: EMPTY
81523: LIST
81524: LIST
81525: PUSH
81526: LD_INT 2
81528: NEG
81529: PUSH
81530: LD_INT 1
81532: NEG
81533: PUSH
81534: EMPTY
81535: LIST
81536: LIST
81537: PUSH
81538: LD_INT 2
81540: NEG
81541: PUSH
81542: LD_INT 2
81544: NEG
81545: PUSH
81546: EMPTY
81547: LIST
81548: LIST
81549: PUSH
81550: LD_INT 1
81552: PUSH
81553: LD_INT 2
81555: NEG
81556: PUSH
81557: EMPTY
81558: LIST
81559: LIST
81560: PUSH
81561: LD_INT 2
81563: PUSH
81564: LD_INT 1
81566: NEG
81567: PUSH
81568: EMPTY
81569: LIST
81570: LIST
81571: PUSH
81572: LD_INT 3
81574: PUSH
81575: LD_INT 1
81577: PUSH
81578: EMPTY
81579: LIST
81580: LIST
81581: PUSH
81582: LD_INT 3
81584: PUSH
81585: LD_INT 2
81587: PUSH
81588: EMPTY
81589: LIST
81590: LIST
81591: PUSH
81592: EMPTY
81593: LIST
81594: LIST
81595: LIST
81596: LIST
81597: LIST
81598: LIST
81599: LIST
81600: LIST
81601: LIST
81602: LIST
81603: LIST
81604: LIST
81605: LIST
81606: LIST
81607: LIST
81608: LIST
81609: LIST
81610: LIST
81611: LIST
81612: LIST
81613: LIST
81614: LIST
81615: LIST
81616: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
81617: LD_ADDR_VAR 0 25
81621: PUSH
81622: LD_INT 0
81624: PUSH
81625: LD_INT 0
81627: PUSH
81628: EMPTY
81629: LIST
81630: LIST
81631: PUSH
81632: LD_INT 0
81634: PUSH
81635: LD_INT 1
81637: NEG
81638: PUSH
81639: EMPTY
81640: LIST
81641: LIST
81642: PUSH
81643: LD_INT 1
81645: PUSH
81646: LD_INT 0
81648: PUSH
81649: EMPTY
81650: LIST
81651: LIST
81652: PUSH
81653: LD_INT 1
81655: PUSH
81656: LD_INT 1
81658: PUSH
81659: EMPTY
81660: LIST
81661: LIST
81662: PUSH
81663: LD_INT 0
81665: PUSH
81666: LD_INT 1
81668: PUSH
81669: EMPTY
81670: LIST
81671: LIST
81672: PUSH
81673: LD_INT 1
81675: NEG
81676: PUSH
81677: LD_INT 0
81679: PUSH
81680: EMPTY
81681: LIST
81682: LIST
81683: PUSH
81684: LD_INT 1
81686: NEG
81687: PUSH
81688: LD_INT 1
81690: NEG
81691: PUSH
81692: EMPTY
81693: LIST
81694: LIST
81695: PUSH
81696: LD_INT 1
81698: NEG
81699: PUSH
81700: LD_INT 2
81702: NEG
81703: PUSH
81704: EMPTY
81705: LIST
81706: LIST
81707: PUSH
81708: LD_INT 0
81710: PUSH
81711: LD_INT 2
81713: NEG
81714: PUSH
81715: EMPTY
81716: LIST
81717: LIST
81718: PUSH
81719: LD_INT 1
81721: PUSH
81722: LD_INT 1
81724: NEG
81725: PUSH
81726: EMPTY
81727: LIST
81728: LIST
81729: PUSH
81730: LD_INT 2
81732: PUSH
81733: LD_INT 0
81735: PUSH
81736: EMPTY
81737: LIST
81738: LIST
81739: PUSH
81740: LD_INT 2
81742: PUSH
81743: LD_INT 1
81745: PUSH
81746: EMPTY
81747: LIST
81748: LIST
81749: PUSH
81750: LD_INT 2
81752: PUSH
81753: LD_INT 2
81755: PUSH
81756: EMPTY
81757: LIST
81758: LIST
81759: PUSH
81760: LD_INT 1
81762: PUSH
81763: LD_INT 2
81765: PUSH
81766: EMPTY
81767: LIST
81768: LIST
81769: PUSH
81770: LD_INT 0
81772: PUSH
81773: LD_INT 2
81775: PUSH
81776: EMPTY
81777: LIST
81778: LIST
81779: PUSH
81780: LD_INT 1
81782: NEG
81783: PUSH
81784: LD_INT 1
81786: PUSH
81787: EMPTY
81788: LIST
81789: LIST
81790: PUSH
81791: LD_INT 2
81793: NEG
81794: PUSH
81795: LD_INT 0
81797: PUSH
81798: EMPTY
81799: LIST
81800: LIST
81801: PUSH
81802: LD_INT 2
81804: NEG
81805: PUSH
81806: LD_INT 1
81808: NEG
81809: PUSH
81810: EMPTY
81811: LIST
81812: LIST
81813: PUSH
81814: LD_INT 2
81816: NEG
81817: PUSH
81818: LD_INT 2
81820: NEG
81821: PUSH
81822: EMPTY
81823: LIST
81824: LIST
81825: PUSH
81826: LD_INT 3
81828: PUSH
81829: LD_INT 1
81831: PUSH
81832: EMPTY
81833: LIST
81834: LIST
81835: PUSH
81836: LD_INT 3
81838: PUSH
81839: LD_INT 2
81841: PUSH
81842: EMPTY
81843: LIST
81844: LIST
81845: PUSH
81846: LD_INT 2
81848: PUSH
81849: LD_INT 3
81851: PUSH
81852: EMPTY
81853: LIST
81854: LIST
81855: PUSH
81856: LD_INT 1
81858: PUSH
81859: LD_INT 3
81861: PUSH
81862: EMPTY
81863: LIST
81864: LIST
81865: PUSH
81866: EMPTY
81867: LIST
81868: LIST
81869: LIST
81870: LIST
81871: LIST
81872: LIST
81873: LIST
81874: LIST
81875: LIST
81876: LIST
81877: LIST
81878: LIST
81879: LIST
81880: LIST
81881: LIST
81882: LIST
81883: LIST
81884: LIST
81885: LIST
81886: LIST
81887: LIST
81888: LIST
81889: LIST
81890: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
81891: LD_ADDR_VAR 0 26
81895: PUSH
81896: LD_INT 0
81898: PUSH
81899: LD_INT 0
81901: PUSH
81902: EMPTY
81903: LIST
81904: LIST
81905: PUSH
81906: LD_INT 0
81908: PUSH
81909: LD_INT 1
81911: NEG
81912: PUSH
81913: EMPTY
81914: LIST
81915: LIST
81916: PUSH
81917: LD_INT 1
81919: PUSH
81920: LD_INT 0
81922: PUSH
81923: EMPTY
81924: LIST
81925: LIST
81926: PUSH
81927: LD_INT 1
81929: PUSH
81930: LD_INT 1
81932: PUSH
81933: EMPTY
81934: LIST
81935: LIST
81936: PUSH
81937: LD_INT 0
81939: PUSH
81940: LD_INT 1
81942: PUSH
81943: EMPTY
81944: LIST
81945: LIST
81946: PUSH
81947: LD_INT 1
81949: NEG
81950: PUSH
81951: LD_INT 0
81953: PUSH
81954: EMPTY
81955: LIST
81956: LIST
81957: PUSH
81958: LD_INT 1
81960: NEG
81961: PUSH
81962: LD_INT 1
81964: NEG
81965: PUSH
81966: EMPTY
81967: LIST
81968: LIST
81969: PUSH
81970: LD_INT 1
81972: NEG
81973: PUSH
81974: LD_INT 2
81976: NEG
81977: PUSH
81978: EMPTY
81979: LIST
81980: LIST
81981: PUSH
81982: LD_INT 0
81984: PUSH
81985: LD_INT 2
81987: NEG
81988: PUSH
81989: EMPTY
81990: LIST
81991: LIST
81992: PUSH
81993: LD_INT 1
81995: PUSH
81996: LD_INT 1
81998: NEG
81999: PUSH
82000: EMPTY
82001: LIST
82002: LIST
82003: PUSH
82004: LD_INT 2
82006: PUSH
82007: LD_INT 0
82009: PUSH
82010: EMPTY
82011: LIST
82012: LIST
82013: PUSH
82014: LD_INT 2
82016: PUSH
82017: LD_INT 1
82019: PUSH
82020: EMPTY
82021: LIST
82022: LIST
82023: PUSH
82024: LD_INT 2
82026: PUSH
82027: LD_INT 2
82029: PUSH
82030: EMPTY
82031: LIST
82032: LIST
82033: PUSH
82034: LD_INT 1
82036: PUSH
82037: LD_INT 2
82039: PUSH
82040: EMPTY
82041: LIST
82042: LIST
82043: PUSH
82044: LD_INT 0
82046: PUSH
82047: LD_INT 2
82049: PUSH
82050: EMPTY
82051: LIST
82052: LIST
82053: PUSH
82054: LD_INT 1
82056: NEG
82057: PUSH
82058: LD_INT 1
82060: PUSH
82061: EMPTY
82062: LIST
82063: LIST
82064: PUSH
82065: LD_INT 2
82067: NEG
82068: PUSH
82069: LD_INT 0
82071: PUSH
82072: EMPTY
82073: LIST
82074: LIST
82075: PUSH
82076: LD_INT 2
82078: NEG
82079: PUSH
82080: LD_INT 1
82082: NEG
82083: PUSH
82084: EMPTY
82085: LIST
82086: LIST
82087: PUSH
82088: LD_INT 2
82090: NEG
82091: PUSH
82092: LD_INT 2
82094: NEG
82095: PUSH
82096: EMPTY
82097: LIST
82098: LIST
82099: PUSH
82100: LD_INT 2
82102: PUSH
82103: LD_INT 3
82105: PUSH
82106: EMPTY
82107: LIST
82108: LIST
82109: PUSH
82110: LD_INT 1
82112: PUSH
82113: LD_INT 3
82115: PUSH
82116: EMPTY
82117: LIST
82118: LIST
82119: PUSH
82120: LD_INT 1
82122: NEG
82123: PUSH
82124: LD_INT 2
82126: PUSH
82127: EMPTY
82128: LIST
82129: LIST
82130: PUSH
82131: LD_INT 2
82133: NEG
82134: PUSH
82135: LD_INT 1
82137: PUSH
82138: EMPTY
82139: LIST
82140: LIST
82141: PUSH
82142: EMPTY
82143: LIST
82144: LIST
82145: LIST
82146: LIST
82147: LIST
82148: LIST
82149: LIST
82150: LIST
82151: LIST
82152: LIST
82153: LIST
82154: LIST
82155: LIST
82156: LIST
82157: LIST
82158: LIST
82159: LIST
82160: LIST
82161: LIST
82162: LIST
82163: LIST
82164: LIST
82165: LIST
82166: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82167: LD_ADDR_VAR 0 27
82171: PUSH
82172: LD_INT 0
82174: PUSH
82175: LD_INT 0
82177: PUSH
82178: EMPTY
82179: LIST
82180: LIST
82181: PUSH
82182: LD_INT 0
82184: PUSH
82185: LD_INT 1
82187: NEG
82188: PUSH
82189: EMPTY
82190: LIST
82191: LIST
82192: PUSH
82193: LD_INT 1
82195: PUSH
82196: LD_INT 0
82198: PUSH
82199: EMPTY
82200: LIST
82201: LIST
82202: PUSH
82203: LD_INT 1
82205: PUSH
82206: LD_INT 1
82208: PUSH
82209: EMPTY
82210: LIST
82211: LIST
82212: PUSH
82213: LD_INT 0
82215: PUSH
82216: LD_INT 1
82218: PUSH
82219: EMPTY
82220: LIST
82221: LIST
82222: PUSH
82223: LD_INT 1
82225: NEG
82226: PUSH
82227: LD_INT 0
82229: PUSH
82230: EMPTY
82231: LIST
82232: LIST
82233: PUSH
82234: LD_INT 1
82236: NEG
82237: PUSH
82238: LD_INT 1
82240: NEG
82241: PUSH
82242: EMPTY
82243: LIST
82244: LIST
82245: PUSH
82246: LD_INT 1
82248: NEG
82249: PUSH
82250: LD_INT 2
82252: NEG
82253: PUSH
82254: EMPTY
82255: LIST
82256: LIST
82257: PUSH
82258: LD_INT 0
82260: PUSH
82261: LD_INT 2
82263: NEG
82264: PUSH
82265: EMPTY
82266: LIST
82267: LIST
82268: PUSH
82269: LD_INT 1
82271: PUSH
82272: LD_INT 1
82274: NEG
82275: PUSH
82276: EMPTY
82277: LIST
82278: LIST
82279: PUSH
82280: LD_INT 2
82282: PUSH
82283: LD_INT 0
82285: PUSH
82286: EMPTY
82287: LIST
82288: LIST
82289: PUSH
82290: LD_INT 2
82292: PUSH
82293: LD_INT 1
82295: PUSH
82296: EMPTY
82297: LIST
82298: LIST
82299: PUSH
82300: LD_INT 2
82302: PUSH
82303: LD_INT 2
82305: PUSH
82306: EMPTY
82307: LIST
82308: LIST
82309: PUSH
82310: LD_INT 1
82312: PUSH
82313: LD_INT 2
82315: PUSH
82316: EMPTY
82317: LIST
82318: LIST
82319: PUSH
82320: LD_INT 0
82322: PUSH
82323: LD_INT 2
82325: PUSH
82326: EMPTY
82327: LIST
82328: LIST
82329: PUSH
82330: LD_INT 1
82332: NEG
82333: PUSH
82334: LD_INT 1
82336: PUSH
82337: EMPTY
82338: LIST
82339: LIST
82340: PUSH
82341: LD_INT 2
82343: NEG
82344: PUSH
82345: LD_INT 0
82347: PUSH
82348: EMPTY
82349: LIST
82350: LIST
82351: PUSH
82352: LD_INT 2
82354: NEG
82355: PUSH
82356: LD_INT 1
82358: NEG
82359: PUSH
82360: EMPTY
82361: LIST
82362: LIST
82363: PUSH
82364: LD_INT 2
82366: NEG
82367: PUSH
82368: LD_INT 2
82370: NEG
82371: PUSH
82372: EMPTY
82373: LIST
82374: LIST
82375: PUSH
82376: LD_INT 1
82378: NEG
82379: PUSH
82380: LD_INT 2
82382: PUSH
82383: EMPTY
82384: LIST
82385: LIST
82386: PUSH
82387: LD_INT 2
82389: NEG
82390: PUSH
82391: LD_INT 1
82393: PUSH
82394: EMPTY
82395: LIST
82396: LIST
82397: PUSH
82398: LD_INT 3
82400: NEG
82401: PUSH
82402: LD_INT 1
82404: NEG
82405: PUSH
82406: EMPTY
82407: LIST
82408: LIST
82409: PUSH
82410: LD_INT 3
82412: NEG
82413: PUSH
82414: LD_INT 2
82416: NEG
82417: PUSH
82418: EMPTY
82419: LIST
82420: LIST
82421: PUSH
82422: EMPTY
82423: LIST
82424: LIST
82425: LIST
82426: LIST
82427: LIST
82428: LIST
82429: LIST
82430: LIST
82431: LIST
82432: LIST
82433: LIST
82434: LIST
82435: LIST
82436: LIST
82437: LIST
82438: LIST
82439: LIST
82440: LIST
82441: LIST
82442: LIST
82443: LIST
82444: LIST
82445: LIST
82446: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82447: LD_ADDR_VAR 0 28
82451: PUSH
82452: LD_INT 0
82454: PUSH
82455: LD_INT 0
82457: PUSH
82458: EMPTY
82459: LIST
82460: LIST
82461: PUSH
82462: LD_INT 0
82464: PUSH
82465: LD_INT 1
82467: NEG
82468: PUSH
82469: EMPTY
82470: LIST
82471: LIST
82472: PUSH
82473: LD_INT 1
82475: PUSH
82476: LD_INT 0
82478: PUSH
82479: EMPTY
82480: LIST
82481: LIST
82482: PUSH
82483: LD_INT 1
82485: PUSH
82486: LD_INT 1
82488: PUSH
82489: EMPTY
82490: LIST
82491: LIST
82492: PUSH
82493: LD_INT 0
82495: PUSH
82496: LD_INT 1
82498: PUSH
82499: EMPTY
82500: LIST
82501: LIST
82502: PUSH
82503: LD_INT 1
82505: NEG
82506: PUSH
82507: LD_INT 0
82509: PUSH
82510: EMPTY
82511: LIST
82512: LIST
82513: PUSH
82514: LD_INT 1
82516: NEG
82517: PUSH
82518: LD_INT 1
82520: NEG
82521: PUSH
82522: EMPTY
82523: LIST
82524: LIST
82525: PUSH
82526: LD_INT 1
82528: NEG
82529: PUSH
82530: LD_INT 2
82532: NEG
82533: PUSH
82534: EMPTY
82535: LIST
82536: LIST
82537: PUSH
82538: LD_INT 0
82540: PUSH
82541: LD_INT 2
82543: NEG
82544: PUSH
82545: EMPTY
82546: LIST
82547: LIST
82548: PUSH
82549: LD_INT 1
82551: PUSH
82552: LD_INT 1
82554: NEG
82555: PUSH
82556: EMPTY
82557: LIST
82558: LIST
82559: PUSH
82560: LD_INT 2
82562: PUSH
82563: LD_INT 0
82565: PUSH
82566: EMPTY
82567: LIST
82568: LIST
82569: PUSH
82570: LD_INT 2
82572: PUSH
82573: LD_INT 1
82575: PUSH
82576: EMPTY
82577: LIST
82578: LIST
82579: PUSH
82580: LD_INT 2
82582: PUSH
82583: LD_INT 2
82585: PUSH
82586: EMPTY
82587: LIST
82588: LIST
82589: PUSH
82590: LD_INT 1
82592: PUSH
82593: LD_INT 2
82595: PUSH
82596: EMPTY
82597: LIST
82598: LIST
82599: PUSH
82600: LD_INT 0
82602: PUSH
82603: LD_INT 2
82605: PUSH
82606: EMPTY
82607: LIST
82608: LIST
82609: PUSH
82610: LD_INT 1
82612: NEG
82613: PUSH
82614: LD_INT 1
82616: PUSH
82617: EMPTY
82618: LIST
82619: LIST
82620: PUSH
82621: LD_INT 2
82623: NEG
82624: PUSH
82625: LD_INT 0
82627: PUSH
82628: EMPTY
82629: LIST
82630: LIST
82631: PUSH
82632: LD_INT 2
82634: NEG
82635: PUSH
82636: LD_INT 1
82638: NEG
82639: PUSH
82640: EMPTY
82641: LIST
82642: LIST
82643: PUSH
82644: LD_INT 2
82646: NEG
82647: PUSH
82648: LD_INT 2
82650: NEG
82651: PUSH
82652: EMPTY
82653: LIST
82654: LIST
82655: PUSH
82656: LD_INT 2
82658: NEG
82659: PUSH
82660: LD_INT 3
82662: NEG
82663: PUSH
82664: EMPTY
82665: LIST
82666: LIST
82667: PUSH
82668: LD_INT 1
82670: NEG
82671: PUSH
82672: LD_INT 3
82674: NEG
82675: PUSH
82676: EMPTY
82677: LIST
82678: LIST
82679: PUSH
82680: LD_INT 3
82682: NEG
82683: PUSH
82684: LD_INT 1
82686: NEG
82687: PUSH
82688: EMPTY
82689: LIST
82690: LIST
82691: PUSH
82692: LD_INT 3
82694: NEG
82695: PUSH
82696: LD_INT 2
82698: NEG
82699: PUSH
82700: EMPTY
82701: LIST
82702: LIST
82703: PUSH
82704: EMPTY
82705: LIST
82706: LIST
82707: LIST
82708: LIST
82709: LIST
82710: LIST
82711: LIST
82712: LIST
82713: LIST
82714: LIST
82715: LIST
82716: LIST
82717: LIST
82718: LIST
82719: LIST
82720: LIST
82721: LIST
82722: LIST
82723: LIST
82724: LIST
82725: LIST
82726: LIST
82727: LIST
82728: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82729: LD_ADDR_VAR 0 29
82733: PUSH
82734: LD_INT 0
82736: PUSH
82737: LD_INT 0
82739: PUSH
82740: EMPTY
82741: LIST
82742: LIST
82743: PUSH
82744: LD_INT 0
82746: PUSH
82747: LD_INT 1
82749: NEG
82750: PUSH
82751: EMPTY
82752: LIST
82753: LIST
82754: PUSH
82755: LD_INT 1
82757: PUSH
82758: LD_INT 0
82760: PUSH
82761: EMPTY
82762: LIST
82763: LIST
82764: PUSH
82765: LD_INT 1
82767: PUSH
82768: LD_INT 1
82770: PUSH
82771: EMPTY
82772: LIST
82773: LIST
82774: PUSH
82775: LD_INT 0
82777: PUSH
82778: LD_INT 1
82780: PUSH
82781: EMPTY
82782: LIST
82783: LIST
82784: PUSH
82785: LD_INT 1
82787: NEG
82788: PUSH
82789: LD_INT 0
82791: PUSH
82792: EMPTY
82793: LIST
82794: LIST
82795: PUSH
82796: LD_INT 1
82798: NEG
82799: PUSH
82800: LD_INT 1
82802: NEG
82803: PUSH
82804: EMPTY
82805: LIST
82806: LIST
82807: PUSH
82808: LD_INT 1
82810: NEG
82811: PUSH
82812: LD_INT 2
82814: NEG
82815: PUSH
82816: EMPTY
82817: LIST
82818: LIST
82819: PUSH
82820: LD_INT 0
82822: PUSH
82823: LD_INT 2
82825: NEG
82826: PUSH
82827: EMPTY
82828: LIST
82829: LIST
82830: PUSH
82831: LD_INT 1
82833: PUSH
82834: LD_INT 1
82836: NEG
82837: PUSH
82838: EMPTY
82839: LIST
82840: LIST
82841: PUSH
82842: LD_INT 2
82844: PUSH
82845: LD_INT 0
82847: PUSH
82848: EMPTY
82849: LIST
82850: LIST
82851: PUSH
82852: LD_INT 2
82854: PUSH
82855: LD_INT 1
82857: PUSH
82858: EMPTY
82859: LIST
82860: LIST
82861: PUSH
82862: LD_INT 1
82864: PUSH
82865: LD_INT 2
82867: PUSH
82868: EMPTY
82869: LIST
82870: LIST
82871: PUSH
82872: LD_INT 0
82874: PUSH
82875: LD_INT 2
82877: PUSH
82878: EMPTY
82879: LIST
82880: LIST
82881: PUSH
82882: LD_INT 1
82884: NEG
82885: PUSH
82886: LD_INT 1
82888: PUSH
82889: EMPTY
82890: LIST
82891: LIST
82892: PUSH
82893: LD_INT 2
82895: NEG
82896: PUSH
82897: LD_INT 1
82899: NEG
82900: PUSH
82901: EMPTY
82902: LIST
82903: LIST
82904: PUSH
82905: LD_INT 2
82907: NEG
82908: PUSH
82909: LD_INT 2
82911: NEG
82912: PUSH
82913: EMPTY
82914: LIST
82915: LIST
82916: PUSH
82917: LD_INT 2
82919: NEG
82920: PUSH
82921: LD_INT 3
82923: NEG
82924: PUSH
82925: EMPTY
82926: LIST
82927: LIST
82928: PUSH
82929: LD_INT 2
82931: PUSH
82932: LD_INT 1
82934: NEG
82935: PUSH
82936: EMPTY
82937: LIST
82938: LIST
82939: PUSH
82940: LD_INT 3
82942: PUSH
82943: LD_INT 1
82945: PUSH
82946: EMPTY
82947: LIST
82948: LIST
82949: PUSH
82950: LD_INT 1
82952: PUSH
82953: LD_INT 3
82955: PUSH
82956: EMPTY
82957: LIST
82958: LIST
82959: PUSH
82960: LD_INT 1
82962: NEG
82963: PUSH
82964: LD_INT 2
82966: PUSH
82967: EMPTY
82968: LIST
82969: LIST
82970: PUSH
82971: LD_INT 3
82973: NEG
82974: PUSH
82975: LD_INT 2
82977: NEG
82978: PUSH
82979: EMPTY
82980: LIST
82981: LIST
82982: PUSH
82983: EMPTY
82984: LIST
82985: LIST
82986: LIST
82987: LIST
82988: LIST
82989: LIST
82990: LIST
82991: LIST
82992: LIST
82993: LIST
82994: LIST
82995: LIST
82996: LIST
82997: LIST
82998: LIST
82999: LIST
83000: LIST
83001: LIST
83002: LIST
83003: LIST
83004: LIST
83005: LIST
83006: LIST
83007: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83008: LD_ADDR_VAR 0 30
83012: PUSH
83013: LD_INT 0
83015: PUSH
83016: LD_INT 0
83018: PUSH
83019: EMPTY
83020: LIST
83021: LIST
83022: PUSH
83023: LD_INT 0
83025: PUSH
83026: LD_INT 1
83028: NEG
83029: PUSH
83030: EMPTY
83031: LIST
83032: LIST
83033: PUSH
83034: LD_INT 1
83036: PUSH
83037: LD_INT 0
83039: PUSH
83040: EMPTY
83041: LIST
83042: LIST
83043: PUSH
83044: LD_INT 1
83046: PUSH
83047: LD_INT 1
83049: PUSH
83050: EMPTY
83051: LIST
83052: LIST
83053: PUSH
83054: LD_INT 0
83056: PUSH
83057: LD_INT 1
83059: PUSH
83060: EMPTY
83061: LIST
83062: LIST
83063: PUSH
83064: LD_INT 1
83066: NEG
83067: PUSH
83068: LD_INT 0
83070: PUSH
83071: EMPTY
83072: LIST
83073: LIST
83074: PUSH
83075: LD_INT 1
83077: NEG
83078: PUSH
83079: LD_INT 1
83081: NEG
83082: PUSH
83083: EMPTY
83084: LIST
83085: LIST
83086: PUSH
83087: LD_INT 1
83089: NEG
83090: PUSH
83091: LD_INT 2
83093: NEG
83094: PUSH
83095: EMPTY
83096: LIST
83097: LIST
83098: PUSH
83099: LD_INT 0
83101: PUSH
83102: LD_INT 2
83104: NEG
83105: PUSH
83106: EMPTY
83107: LIST
83108: LIST
83109: PUSH
83110: LD_INT 1
83112: PUSH
83113: LD_INT 1
83115: NEG
83116: PUSH
83117: EMPTY
83118: LIST
83119: LIST
83120: PUSH
83121: LD_INT 2
83123: PUSH
83124: LD_INT 0
83126: PUSH
83127: EMPTY
83128: LIST
83129: LIST
83130: PUSH
83131: LD_INT 2
83133: PUSH
83134: LD_INT 1
83136: PUSH
83137: EMPTY
83138: LIST
83139: LIST
83140: PUSH
83141: LD_INT 2
83143: PUSH
83144: LD_INT 2
83146: PUSH
83147: EMPTY
83148: LIST
83149: LIST
83150: PUSH
83151: LD_INT 1
83153: PUSH
83154: LD_INT 2
83156: PUSH
83157: EMPTY
83158: LIST
83159: LIST
83160: PUSH
83161: LD_INT 1
83163: NEG
83164: PUSH
83165: LD_INT 1
83167: PUSH
83168: EMPTY
83169: LIST
83170: LIST
83171: PUSH
83172: LD_INT 2
83174: NEG
83175: PUSH
83176: LD_INT 0
83178: PUSH
83179: EMPTY
83180: LIST
83181: LIST
83182: PUSH
83183: LD_INT 2
83185: NEG
83186: PUSH
83187: LD_INT 1
83189: NEG
83190: PUSH
83191: EMPTY
83192: LIST
83193: LIST
83194: PUSH
83195: LD_INT 1
83197: NEG
83198: PUSH
83199: LD_INT 3
83201: NEG
83202: PUSH
83203: EMPTY
83204: LIST
83205: LIST
83206: PUSH
83207: LD_INT 1
83209: PUSH
83210: LD_INT 2
83212: NEG
83213: PUSH
83214: EMPTY
83215: LIST
83216: LIST
83217: PUSH
83218: LD_INT 3
83220: PUSH
83221: LD_INT 2
83223: PUSH
83224: EMPTY
83225: LIST
83226: LIST
83227: PUSH
83228: LD_INT 2
83230: PUSH
83231: LD_INT 3
83233: PUSH
83234: EMPTY
83235: LIST
83236: LIST
83237: PUSH
83238: LD_INT 2
83240: NEG
83241: PUSH
83242: LD_INT 1
83244: PUSH
83245: EMPTY
83246: LIST
83247: LIST
83248: PUSH
83249: LD_INT 3
83251: NEG
83252: PUSH
83253: LD_INT 1
83255: NEG
83256: PUSH
83257: EMPTY
83258: LIST
83259: LIST
83260: PUSH
83261: EMPTY
83262: LIST
83263: LIST
83264: LIST
83265: LIST
83266: LIST
83267: LIST
83268: LIST
83269: LIST
83270: LIST
83271: LIST
83272: LIST
83273: LIST
83274: LIST
83275: LIST
83276: LIST
83277: LIST
83278: LIST
83279: LIST
83280: LIST
83281: LIST
83282: LIST
83283: LIST
83284: LIST
83285: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83286: LD_ADDR_VAR 0 31
83290: PUSH
83291: LD_INT 0
83293: PUSH
83294: LD_INT 0
83296: PUSH
83297: EMPTY
83298: LIST
83299: LIST
83300: PUSH
83301: LD_INT 0
83303: PUSH
83304: LD_INT 1
83306: NEG
83307: PUSH
83308: EMPTY
83309: LIST
83310: LIST
83311: PUSH
83312: LD_INT 1
83314: PUSH
83315: LD_INT 0
83317: PUSH
83318: EMPTY
83319: LIST
83320: LIST
83321: PUSH
83322: LD_INT 1
83324: PUSH
83325: LD_INT 1
83327: PUSH
83328: EMPTY
83329: LIST
83330: LIST
83331: PUSH
83332: LD_INT 0
83334: PUSH
83335: LD_INT 1
83337: PUSH
83338: EMPTY
83339: LIST
83340: LIST
83341: PUSH
83342: LD_INT 1
83344: NEG
83345: PUSH
83346: LD_INT 0
83348: PUSH
83349: EMPTY
83350: LIST
83351: LIST
83352: PUSH
83353: LD_INT 1
83355: NEG
83356: PUSH
83357: LD_INT 1
83359: NEG
83360: PUSH
83361: EMPTY
83362: LIST
83363: LIST
83364: PUSH
83365: LD_INT 1
83367: NEG
83368: PUSH
83369: LD_INT 2
83371: NEG
83372: PUSH
83373: EMPTY
83374: LIST
83375: LIST
83376: PUSH
83377: LD_INT 1
83379: PUSH
83380: LD_INT 1
83382: NEG
83383: PUSH
83384: EMPTY
83385: LIST
83386: LIST
83387: PUSH
83388: LD_INT 2
83390: PUSH
83391: LD_INT 0
83393: PUSH
83394: EMPTY
83395: LIST
83396: LIST
83397: PUSH
83398: LD_INT 2
83400: PUSH
83401: LD_INT 1
83403: PUSH
83404: EMPTY
83405: LIST
83406: LIST
83407: PUSH
83408: LD_INT 2
83410: PUSH
83411: LD_INT 2
83413: PUSH
83414: EMPTY
83415: LIST
83416: LIST
83417: PUSH
83418: LD_INT 1
83420: PUSH
83421: LD_INT 2
83423: PUSH
83424: EMPTY
83425: LIST
83426: LIST
83427: PUSH
83428: LD_INT 0
83430: PUSH
83431: LD_INT 2
83433: PUSH
83434: EMPTY
83435: LIST
83436: LIST
83437: PUSH
83438: LD_INT 1
83440: NEG
83441: PUSH
83442: LD_INT 1
83444: PUSH
83445: EMPTY
83446: LIST
83447: LIST
83448: PUSH
83449: LD_INT 2
83451: NEG
83452: PUSH
83453: LD_INT 1
83455: NEG
83456: PUSH
83457: EMPTY
83458: LIST
83459: LIST
83460: PUSH
83461: LD_INT 2
83463: NEG
83464: PUSH
83465: LD_INT 2
83467: NEG
83468: PUSH
83469: EMPTY
83470: LIST
83471: LIST
83472: PUSH
83473: LD_INT 2
83475: NEG
83476: PUSH
83477: LD_INT 3
83479: NEG
83480: PUSH
83481: EMPTY
83482: LIST
83483: LIST
83484: PUSH
83485: LD_INT 2
83487: PUSH
83488: LD_INT 1
83490: NEG
83491: PUSH
83492: EMPTY
83493: LIST
83494: LIST
83495: PUSH
83496: LD_INT 3
83498: PUSH
83499: LD_INT 1
83501: PUSH
83502: EMPTY
83503: LIST
83504: LIST
83505: PUSH
83506: LD_INT 1
83508: PUSH
83509: LD_INT 3
83511: PUSH
83512: EMPTY
83513: LIST
83514: LIST
83515: PUSH
83516: LD_INT 1
83518: NEG
83519: PUSH
83520: LD_INT 2
83522: PUSH
83523: EMPTY
83524: LIST
83525: LIST
83526: PUSH
83527: LD_INT 3
83529: NEG
83530: PUSH
83531: LD_INT 2
83533: NEG
83534: PUSH
83535: EMPTY
83536: LIST
83537: LIST
83538: PUSH
83539: EMPTY
83540: LIST
83541: LIST
83542: LIST
83543: LIST
83544: LIST
83545: LIST
83546: LIST
83547: LIST
83548: LIST
83549: LIST
83550: LIST
83551: LIST
83552: LIST
83553: LIST
83554: LIST
83555: LIST
83556: LIST
83557: LIST
83558: LIST
83559: LIST
83560: LIST
83561: LIST
83562: LIST
83563: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83564: LD_ADDR_VAR 0 32
83568: PUSH
83569: LD_INT 0
83571: PUSH
83572: LD_INT 0
83574: PUSH
83575: EMPTY
83576: LIST
83577: LIST
83578: PUSH
83579: LD_INT 0
83581: PUSH
83582: LD_INT 1
83584: NEG
83585: PUSH
83586: EMPTY
83587: LIST
83588: LIST
83589: PUSH
83590: LD_INT 1
83592: PUSH
83593: LD_INT 0
83595: PUSH
83596: EMPTY
83597: LIST
83598: LIST
83599: PUSH
83600: LD_INT 1
83602: PUSH
83603: LD_INT 1
83605: PUSH
83606: EMPTY
83607: LIST
83608: LIST
83609: PUSH
83610: LD_INT 0
83612: PUSH
83613: LD_INT 1
83615: PUSH
83616: EMPTY
83617: LIST
83618: LIST
83619: PUSH
83620: LD_INT 1
83622: NEG
83623: PUSH
83624: LD_INT 0
83626: PUSH
83627: EMPTY
83628: LIST
83629: LIST
83630: PUSH
83631: LD_INT 1
83633: NEG
83634: PUSH
83635: LD_INT 1
83637: NEG
83638: PUSH
83639: EMPTY
83640: LIST
83641: LIST
83642: PUSH
83643: LD_INT 1
83645: NEG
83646: PUSH
83647: LD_INT 2
83649: NEG
83650: PUSH
83651: EMPTY
83652: LIST
83653: LIST
83654: PUSH
83655: LD_INT 0
83657: PUSH
83658: LD_INT 2
83660: NEG
83661: PUSH
83662: EMPTY
83663: LIST
83664: LIST
83665: PUSH
83666: LD_INT 1
83668: PUSH
83669: LD_INT 1
83671: NEG
83672: PUSH
83673: EMPTY
83674: LIST
83675: LIST
83676: PUSH
83677: LD_INT 2
83679: PUSH
83680: LD_INT 1
83682: PUSH
83683: EMPTY
83684: LIST
83685: LIST
83686: PUSH
83687: LD_INT 2
83689: PUSH
83690: LD_INT 2
83692: PUSH
83693: EMPTY
83694: LIST
83695: LIST
83696: PUSH
83697: LD_INT 1
83699: PUSH
83700: LD_INT 2
83702: PUSH
83703: EMPTY
83704: LIST
83705: LIST
83706: PUSH
83707: LD_INT 0
83709: PUSH
83710: LD_INT 2
83712: PUSH
83713: EMPTY
83714: LIST
83715: LIST
83716: PUSH
83717: LD_INT 1
83719: NEG
83720: PUSH
83721: LD_INT 1
83723: PUSH
83724: EMPTY
83725: LIST
83726: LIST
83727: PUSH
83728: LD_INT 2
83730: NEG
83731: PUSH
83732: LD_INT 0
83734: PUSH
83735: EMPTY
83736: LIST
83737: LIST
83738: PUSH
83739: LD_INT 2
83741: NEG
83742: PUSH
83743: LD_INT 1
83745: NEG
83746: PUSH
83747: EMPTY
83748: LIST
83749: LIST
83750: PUSH
83751: LD_INT 1
83753: NEG
83754: PUSH
83755: LD_INT 3
83757: NEG
83758: PUSH
83759: EMPTY
83760: LIST
83761: LIST
83762: PUSH
83763: LD_INT 1
83765: PUSH
83766: LD_INT 2
83768: NEG
83769: PUSH
83770: EMPTY
83771: LIST
83772: LIST
83773: PUSH
83774: LD_INT 3
83776: PUSH
83777: LD_INT 2
83779: PUSH
83780: EMPTY
83781: LIST
83782: LIST
83783: PUSH
83784: LD_INT 2
83786: PUSH
83787: LD_INT 3
83789: PUSH
83790: EMPTY
83791: LIST
83792: LIST
83793: PUSH
83794: LD_INT 2
83796: NEG
83797: PUSH
83798: LD_INT 1
83800: PUSH
83801: EMPTY
83802: LIST
83803: LIST
83804: PUSH
83805: LD_INT 3
83807: NEG
83808: PUSH
83809: LD_INT 1
83811: NEG
83812: PUSH
83813: EMPTY
83814: LIST
83815: LIST
83816: PUSH
83817: EMPTY
83818: LIST
83819: LIST
83820: LIST
83821: LIST
83822: LIST
83823: LIST
83824: LIST
83825: LIST
83826: LIST
83827: LIST
83828: LIST
83829: LIST
83830: LIST
83831: LIST
83832: LIST
83833: LIST
83834: LIST
83835: LIST
83836: LIST
83837: LIST
83838: LIST
83839: LIST
83840: LIST
83841: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83842: LD_ADDR_VAR 0 33
83846: PUSH
83847: LD_INT 0
83849: PUSH
83850: LD_INT 0
83852: PUSH
83853: EMPTY
83854: LIST
83855: LIST
83856: PUSH
83857: LD_INT 0
83859: PUSH
83860: LD_INT 1
83862: NEG
83863: PUSH
83864: EMPTY
83865: LIST
83866: LIST
83867: PUSH
83868: LD_INT 1
83870: PUSH
83871: LD_INT 0
83873: PUSH
83874: EMPTY
83875: LIST
83876: LIST
83877: PUSH
83878: LD_INT 1
83880: PUSH
83881: LD_INT 1
83883: PUSH
83884: EMPTY
83885: LIST
83886: LIST
83887: PUSH
83888: LD_INT 0
83890: PUSH
83891: LD_INT 1
83893: PUSH
83894: EMPTY
83895: LIST
83896: LIST
83897: PUSH
83898: LD_INT 1
83900: NEG
83901: PUSH
83902: LD_INT 0
83904: PUSH
83905: EMPTY
83906: LIST
83907: LIST
83908: PUSH
83909: LD_INT 1
83911: NEG
83912: PUSH
83913: LD_INT 1
83915: NEG
83916: PUSH
83917: EMPTY
83918: LIST
83919: LIST
83920: PUSH
83921: LD_INT 1
83923: NEG
83924: PUSH
83925: LD_INT 2
83927: NEG
83928: PUSH
83929: EMPTY
83930: LIST
83931: LIST
83932: PUSH
83933: LD_INT 1
83935: PUSH
83936: LD_INT 1
83938: NEG
83939: PUSH
83940: EMPTY
83941: LIST
83942: LIST
83943: PUSH
83944: LD_INT 2
83946: PUSH
83947: LD_INT 0
83949: PUSH
83950: EMPTY
83951: LIST
83952: LIST
83953: PUSH
83954: LD_INT 2
83956: PUSH
83957: LD_INT 1
83959: PUSH
83960: EMPTY
83961: LIST
83962: LIST
83963: PUSH
83964: LD_INT 1
83966: PUSH
83967: LD_INT 2
83969: PUSH
83970: EMPTY
83971: LIST
83972: LIST
83973: PUSH
83974: LD_INT 0
83976: PUSH
83977: LD_INT 2
83979: PUSH
83980: EMPTY
83981: LIST
83982: LIST
83983: PUSH
83984: LD_INT 1
83986: NEG
83987: PUSH
83988: LD_INT 1
83990: PUSH
83991: EMPTY
83992: LIST
83993: LIST
83994: PUSH
83995: LD_INT 2
83997: NEG
83998: PUSH
83999: LD_INT 0
84001: PUSH
84002: EMPTY
84003: LIST
84004: LIST
84005: PUSH
84006: LD_INT 2
84008: NEG
84009: PUSH
84010: LD_INT 1
84012: NEG
84013: PUSH
84014: EMPTY
84015: LIST
84016: LIST
84017: PUSH
84018: LD_INT 2
84020: NEG
84021: PUSH
84022: LD_INT 2
84024: NEG
84025: PUSH
84026: EMPTY
84027: LIST
84028: LIST
84029: PUSH
84030: LD_INT 2
84032: NEG
84033: PUSH
84034: LD_INT 3
84036: NEG
84037: PUSH
84038: EMPTY
84039: LIST
84040: LIST
84041: PUSH
84042: LD_INT 2
84044: PUSH
84045: LD_INT 1
84047: NEG
84048: PUSH
84049: EMPTY
84050: LIST
84051: LIST
84052: PUSH
84053: LD_INT 3
84055: PUSH
84056: LD_INT 1
84058: PUSH
84059: EMPTY
84060: LIST
84061: LIST
84062: PUSH
84063: LD_INT 1
84065: PUSH
84066: LD_INT 3
84068: PUSH
84069: EMPTY
84070: LIST
84071: LIST
84072: PUSH
84073: LD_INT 1
84075: NEG
84076: PUSH
84077: LD_INT 2
84079: PUSH
84080: EMPTY
84081: LIST
84082: LIST
84083: PUSH
84084: LD_INT 3
84086: NEG
84087: PUSH
84088: LD_INT 2
84090: NEG
84091: PUSH
84092: EMPTY
84093: LIST
84094: LIST
84095: PUSH
84096: EMPTY
84097: LIST
84098: LIST
84099: LIST
84100: LIST
84101: LIST
84102: LIST
84103: LIST
84104: LIST
84105: LIST
84106: LIST
84107: LIST
84108: LIST
84109: LIST
84110: LIST
84111: LIST
84112: LIST
84113: LIST
84114: LIST
84115: LIST
84116: LIST
84117: LIST
84118: LIST
84119: LIST
84120: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84121: LD_ADDR_VAR 0 34
84125: PUSH
84126: LD_INT 0
84128: PUSH
84129: LD_INT 0
84131: PUSH
84132: EMPTY
84133: LIST
84134: LIST
84135: PUSH
84136: LD_INT 0
84138: PUSH
84139: LD_INT 1
84141: NEG
84142: PUSH
84143: EMPTY
84144: LIST
84145: LIST
84146: PUSH
84147: LD_INT 1
84149: PUSH
84150: LD_INT 0
84152: PUSH
84153: EMPTY
84154: LIST
84155: LIST
84156: PUSH
84157: LD_INT 1
84159: PUSH
84160: LD_INT 1
84162: PUSH
84163: EMPTY
84164: LIST
84165: LIST
84166: PUSH
84167: LD_INT 0
84169: PUSH
84170: LD_INT 1
84172: PUSH
84173: EMPTY
84174: LIST
84175: LIST
84176: PUSH
84177: LD_INT 1
84179: NEG
84180: PUSH
84181: LD_INT 0
84183: PUSH
84184: EMPTY
84185: LIST
84186: LIST
84187: PUSH
84188: LD_INT 1
84190: NEG
84191: PUSH
84192: LD_INT 1
84194: NEG
84195: PUSH
84196: EMPTY
84197: LIST
84198: LIST
84199: PUSH
84200: LD_INT 1
84202: NEG
84203: PUSH
84204: LD_INT 2
84206: NEG
84207: PUSH
84208: EMPTY
84209: LIST
84210: LIST
84211: PUSH
84212: LD_INT 0
84214: PUSH
84215: LD_INT 2
84217: NEG
84218: PUSH
84219: EMPTY
84220: LIST
84221: LIST
84222: PUSH
84223: LD_INT 1
84225: PUSH
84226: LD_INT 1
84228: NEG
84229: PUSH
84230: EMPTY
84231: LIST
84232: LIST
84233: PUSH
84234: LD_INT 2
84236: PUSH
84237: LD_INT 1
84239: PUSH
84240: EMPTY
84241: LIST
84242: LIST
84243: PUSH
84244: LD_INT 2
84246: PUSH
84247: LD_INT 2
84249: PUSH
84250: EMPTY
84251: LIST
84252: LIST
84253: PUSH
84254: LD_INT 1
84256: PUSH
84257: LD_INT 2
84259: PUSH
84260: EMPTY
84261: LIST
84262: LIST
84263: PUSH
84264: LD_INT 1
84266: NEG
84267: PUSH
84268: LD_INT 1
84270: PUSH
84271: EMPTY
84272: LIST
84273: LIST
84274: PUSH
84275: LD_INT 2
84277: NEG
84278: PUSH
84279: LD_INT 0
84281: PUSH
84282: EMPTY
84283: LIST
84284: LIST
84285: PUSH
84286: LD_INT 2
84288: NEG
84289: PUSH
84290: LD_INT 1
84292: NEG
84293: PUSH
84294: EMPTY
84295: LIST
84296: LIST
84297: PUSH
84298: LD_INT 2
84300: NEG
84301: PUSH
84302: LD_INT 2
84304: NEG
84305: PUSH
84306: EMPTY
84307: LIST
84308: LIST
84309: PUSH
84310: LD_INT 1
84312: NEG
84313: PUSH
84314: LD_INT 3
84316: NEG
84317: PUSH
84318: EMPTY
84319: LIST
84320: LIST
84321: PUSH
84322: LD_INT 1
84324: PUSH
84325: LD_INT 2
84327: NEG
84328: PUSH
84329: EMPTY
84330: LIST
84331: LIST
84332: PUSH
84333: LD_INT 3
84335: PUSH
84336: LD_INT 2
84338: PUSH
84339: EMPTY
84340: LIST
84341: LIST
84342: PUSH
84343: LD_INT 2
84345: PUSH
84346: LD_INT 3
84348: PUSH
84349: EMPTY
84350: LIST
84351: LIST
84352: PUSH
84353: LD_INT 2
84355: NEG
84356: PUSH
84357: LD_INT 1
84359: PUSH
84360: EMPTY
84361: LIST
84362: LIST
84363: PUSH
84364: LD_INT 3
84366: NEG
84367: PUSH
84368: LD_INT 1
84370: NEG
84371: PUSH
84372: EMPTY
84373: LIST
84374: LIST
84375: PUSH
84376: EMPTY
84377: LIST
84378: LIST
84379: LIST
84380: LIST
84381: LIST
84382: LIST
84383: LIST
84384: LIST
84385: LIST
84386: LIST
84387: LIST
84388: LIST
84389: LIST
84390: LIST
84391: LIST
84392: LIST
84393: LIST
84394: LIST
84395: LIST
84396: LIST
84397: LIST
84398: LIST
84399: LIST
84400: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84401: LD_ADDR_VAR 0 35
84405: PUSH
84406: LD_INT 0
84408: PUSH
84409: LD_INT 0
84411: PUSH
84412: EMPTY
84413: LIST
84414: LIST
84415: PUSH
84416: LD_INT 0
84418: PUSH
84419: LD_INT 1
84421: NEG
84422: PUSH
84423: EMPTY
84424: LIST
84425: LIST
84426: PUSH
84427: LD_INT 1
84429: PUSH
84430: LD_INT 0
84432: PUSH
84433: EMPTY
84434: LIST
84435: LIST
84436: PUSH
84437: LD_INT 1
84439: PUSH
84440: LD_INT 1
84442: PUSH
84443: EMPTY
84444: LIST
84445: LIST
84446: PUSH
84447: LD_INT 0
84449: PUSH
84450: LD_INT 1
84452: PUSH
84453: EMPTY
84454: LIST
84455: LIST
84456: PUSH
84457: LD_INT 1
84459: NEG
84460: PUSH
84461: LD_INT 0
84463: PUSH
84464: EMPTY
84465: LIST
84466: LIST
84467: PUSH
84468: LD_INT 1
84470: NEG
84471: PUSH
84472: LD_INT 1
84474: NEG
84475: PUSH
84476: EMPTY
84477: LIST
84478: LIST
84479: PUSH
84480: LD_INT 2
84482: PUSH
84483: LD_INT 1
84485: PUSH
84486: EMPTY
84487: LIST
84488: LIST
84489: PUSH
84490: LD_INT 2
84492: NEG
84493: PUSH
84494: LD_INT 1
84496: NEG
84497: PUSH
84498: EMPTY
84499: LIST
84500: LIST
84501: PUSH
84502: EMPTY
84503: LIST
84504: LIST
84505: LIST
84506: LIST
84507: LIST
84508: LIST
84509: LIST
84510: LIST
84511: LIST
84512: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84513: LD_ADDR_VAR 0 36
84517: PUSH
84518: LD_INT 0
84520: PUSH
84521: LD_INT 0
84523: PUSH
84524: EMPTY
84525: LIST
84526: LIST
84527: PUSH
84528: LD_INT 0
84530: PUSH
84531: LD_INT 1
84533: NEG
84534: PUSH
84535: EMPTY
84536: LIST
84537: LIST
84538: PUSH
84539: LD_INT 1
84541: PUSH
84542: LD_INT 0
84544: PUSH
84545: EMPTY
84546: LIST
84547: LIST
84548: PUSH
84549: LD_INT 1
84551: PUSH
84552: LD_INT 1
84554: PUSH
84555: EMPTY
84556: LIST
84557: LIST
84558: PUSH
84559: LD_INT 0
84561: PUSH
84562: LD_INT 1
84564: PUSH
84565: EMPTY
84566: LIST
84567: LIST
84568: PUSH
84569: LD_INT 1
84571: NEG
84572: PUSH
84573: LD_INT 0
84575: PUSH
84576: EMPTY
84577: LIST
84578: LIST
84579: PUSH
84580: LD_INT 1
84582: NEG
84583: PUSH
84584: LD_INT 1
84586: NEG
84587: PUSH
84588: EMPTY
84589: LIST
84590: LIST
84591: PUSH
84592: LD_INT 1
84594: NEG
84595: PUSH
84596: LD_INT 2
84598: NEG
84599: PUSH
84600: EMPTY
84601: LIST
84602: LIST
84603: PUSH
84604: LD_INT 1
84606: PUSH
84607: LD_INT 2
84609: PUSH
84610: EMPTY
84611: LIST
84612: LIST
84613: PUSH
84614: EMPTY
84615: LIST
84616: LIST
84617: LIST
84618: LIST
84619: LIST
84620: LIST
84621: LIST
84622: LIST
84623: LIST
84624: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84625: LD_ADDR_VAR 0 37
84629: PUSH
84630: LD_INT 0
84632: PUSH
84633: LD_INT 0
84635: PUSH
84636: EMPTY
84637: LIST
84638: LIST
84639: PUSH
84640: LD_INT 0
84642: PUSH
84643: LD_INT 1
84645: NEG
84646: PUSH
84647: EMPTY
84648: LIST
84649: LIST
84650: PUSH
84651: LD_INT 1
84653: PUSH
84654: LD_INT 0
84656: PUSH
84657: EMPTY
84658: LIST
84659: LIST
84660: PUSH
84661: LD_INT 1
84663: PUSH
84664: LD_INT 1
84666: PUSH
84667: EMPTY
84668: LIST
84669: LIST
84670: PUSH
84671: LD_INT 0
84673: PUSH
84674: LD_INT 1
84676: PUSH
84677: EMPTY
84678: LIST
84679: LIST
84680: PUSH
84681: LD_INT 1
84683: NEG
84684: PUSH
84685: LD_INT 0
84687: PUSH
84688: EMPTY
84689: LIST
84690: LIST
84691: PUSH
84692: LD_INT 1
84694: NEG
84695: PUSH
84696: LD_INT 1
84698: NEG
84699: PUSH
84700: EMPTY
84701: LIST
84702: LIST
84703: PUSH
84704: LD_INT 1
84706: PUSH
84707: LD_INT 1
84709: NEG
84710: PUSH
84711: EMPTY
84712: LIST
84713: LIST
84714: PUSH
84715: LD_INT 1
84717: NEG
84718: PUSH
84719: LD_INT 1
84721: PUSH
84722: EMPTY
84723: LIST
84724: LIST
84725: PUSH
84726: EMPTY
84727: LIST
84728: LIST
84729: LIST
84730: LIST
84731: LIST
84732: LIST
84733: LIST
84734: LIST
84735: LIST
84736: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84737: LD_ADDR_VAR 0 38
84741: PUSH
84742: LD_INT 0
84744: PUSH
84745: LD_INT 0
84747: PUSH
84748: EMPTY
84749: LIST
84750: LIST
84751: PUSH
84752: LD_INT 0
84754: PUSH
84755: LD_INT 1
84757: NEG
84758: PUSH
84759: EMPTY
84760: LIST
84761: LIST
84762: PUSH
84763: LD_INT 1
84765: PUSH
84766: LD_INT 0
84768: PUSH
84769: EMPTY
84770: LIST
84771: LIST
84772: PUSH
84773: LD_INT 1
84775: PUSH
84776: LD_INT 1
84778: PUSH
84779: EMPTY
84780: LIST
84781: LIST
84782: PUSH
84783: LD_INT 0
84785: PUSH
84786: LD_INT 1
84788: PUSH
84789: EMPTY
84790: LIST
84791: LIST
84792: PUSH
84793: LD_INT 1
84795: NEG
84796: PUSH
84797: LD_INT 0
84799: PUSH
84800: EMPTY
84801: LIST
84802: LIST
84803: PUSH
84804: LD_INT 1
84806: NEG
84807: PUSH
84808: LD_INT 1
84810: NEG
84811: PUSH
84812: EMPTY
84813: LIST
84814: LIST
84815: PUSH
84816: LD_INT 2
84818: PUSH
84819: LD_INT 1
84821: PUSH
84822: EMPTY
84823: LIST
84824: LIST
84825: PUSH
84826: LD_INT 2
84828: NEG
84829: PUSH
84830: LD_INT 1
84832: NEG
84833: PUSH
84834: EMPTY
84835: LIST
84836: LIST
84837: PUSH
84838: EMPTY
84839: LIST
84840: LIST
84841: LIST
84842: LIST
84843: LIST
84844: LIST
84845: LIST
84846: LIST
84847: LIST
84848: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84849: LD_ADDR_VAR 0 39
84853: PUSH
84854: LD_INT 0
84856: PUSH
84857: LD_INT 0
84859: PUSH
84860: EMPTY
84861: LIST
84862: LIST
84863: PUSH
84864: LD_INT 0
84866: PUSH
84867: LD_INT 1
84869: NEG
84870: PUSH
84871: EMPTY
84872: LIST
84873: LIST
84874: PUSH
84875: LD_INT 1
84877: PUSH
84878: LD_INT 0
84880: PUSH
84881: EMPTY
84882: LIST
84883: LIST
84884: PUSH
84885: LD_INT 1
84887: PUSH
84888: LD_INT 1
84890: PUSH
84891: EMPTY
84892: LIST
84893: LIST
84894: PUSH
84895: LD_INT 0
84897: PUSH
84898: LD_INT 1
84900: PUSH
84901: EMPTY
84902: LIST
84903: LIST
84904: PUSH
84905: LD_INT 1
84907: NEG
84908: PUSH
84909: LD_INT 0
84911: PUSH
84912: EMPTY
84913: LIST
84914: LIST
84915: PUSH
84916: LD_INT 1
84918: NEG
84919: PUSH
84920: LD_INT 1
84922: NEG
84923: PUSH
84924: EMPTY
84925: LIST
84926: LIST
84927: PUSH
84928: LD_INT 1
84930: NEG
84931: PUSH
84932: LD_INT 2
84934: NEG
84935: PUSH
84936: EMPTY
84937: LIST
84938: LIST
84939: PUSH
84940: LD_INT 1
84942: PUSH
84943: LD_INT 2
84945: PUSH
84946: EMPTY
84947: LIST
84948: LIST
84949: PUSH
84950: EMPTY
84951: LIST
84952: LIST
84953: LIST
84954: LIST
84955: LIST
84956: LIST
84957: LIST
84958: LIST
84959: LIST
84960: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84961: LD_ADDR_VAR 0 40
84965: PUSH
84966: LD_INT 0
84968: PUSH
84969: LD_INT 0
84971: PUSH
84972: EMPTY
84973: LIST
84974: LIST
84975: PUSH
84976: LD_INT 0
84978: PUSH
84979: LD_INT 1
84981: NEG
84982: PUSH
84983: EMPTY
84984: LIST
84985: LIST
84986: PUSH
84987: LD_INT 1
84989: PUSH
84990: LD_INT 0
84992: PUSH
84993: EMPTY
84994: LIST
84995: LIST
84996: PUSH
84997: LD_INT 1
84999: PUSH
85000: LD_INT 1
85002: PUSH
85003: EMPTY
85004: LIST
85005: LIST
85006: PUSH
85007: LD_INT 0
85009: PUSH
85010: LD_INT 1
85012: PUSH
85013: EMPTY
85014: LIST
85015: LIST
85016: PUSH
85017: LD_INT 1
85019: NEG
85020: PUSH
85021: LD_INT 0
85023: PUSH
85024: EMPTY
85025: LIST
85026: LIST
85027: PUSH
85028: LD_INT 1
85030: NEG
85031: PUSH
85032: LD_INT 1
85034: NEG
85035: PUSH
85036: EMPTY
85037: LIST
85038: LIST
85039: PUSH
85040: LD_INT 1
85042: PUSH
85043: LD_INT 1
85045: NEG
85046: PUSH
85047: EMPTY
85048: LIST
85049: LIST
85050: PUSH
85051: LD_INT 1
85053: NEG
85054: PUSH
85055: LD_INT 1
85057: PUSH
85058: EMPTY
85059: LIST
85060: LIST
85061: PUSH
85062: EMPTY
85063: LIST
85064: LIST
85065: LIST
85066: LIST
85067: LIST
85068: LIST
85069: LIST
85070: LIST
85071: LIST
85072: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85073: LD_ADDR_VAR 0 41
85077: PUSH
85078: LD_INT 0
85080: PUSH
85081: LD_INT 0
85083: PUSH
85084: EMPTY
85085: LIST
85086: LIST
85087: PUSH
85088: LD_INT 0
85090: PUSH
85091: LD_INT 1
85093: NEG
85094: PUSH
85095: EMPTY
85096: LIST
85097: LIST
85098: PUSH
85099: LD_INT 1
85101: PUSH
85102: LD_INT 0
85104: PUSH
85105: EMPTY
85106: LIST
85107: LIST
85108: PUSH
85109: LD_INT 1
85111: PUSH
85112: LD_INT 1
85114: PUSH
85115: EMPTY
85116: LIST
85117: LIST
85118: PUSH
85119: LD_INT 0
85121: PUSH
85122: LD_INT 1
85124: PUSH
85125: EMPTY
85126: LIST
85127: LIST
85128: PUSH
85129: LD_INT 1
85131: NEG
85132: PUSH
85133: LD_INT 0
85135: PUSH
85136: EMPTY
85137: LIST
85138: LIST
85139: PUSH
85140: LD_INT 1
85142: NEG
85143: PUSH
85144: LD_INT 1
85146: NEG
85147: PUSH
85148: EMPTY
85149: LIST
85150: LIST
85151: PUSH
85152: LD_INT 1
85154: NEG
85155: PUSH
85156: LD_INT 2
85158: NEG
85159: PUSH
85160: EMPTY
85161: LIST
85162: LIST
85163: PUSH
85164: LD_INT 1
85166: PUSH
85167: LD_INT 1
85169: NEG
85170: PUSH
85171: EMPTY
85172: LIST
85173: LIST
85174: PUSH
85175: LD_INT 2
85177: PUSH
85178: LD_INT 0
85180: PUSH
85181: EMPTY
85182: LIST
85183: LIST
85184: PUSH
85185: LD_INT 2
85187: PUSH
85188: LD_INT 1
85190: PUSH
85191: EMPTY
85192: LIST
85193: LIST
85194: PUSH
85195: LD_INT 2
85197: PUSH
85198: LD_INT 2
85200: PUSH
85201: EMPTY
85202: LIST
85203: LIST
85204: PUSH
85205: LD_INT 1
85207: PUSH
85208: LD_INT 2
85210: PUSH
85211: EMPTY
85212: LIST
85213: LIST
85214: PUSH
85215: LD_INT 1
85217: NEG
85218: PUSH
85219: LD_INT 1
85221: PUSH
85222: EMPTY
85223: LIST
85224: LIST
85225: PUSH
85226: LD_INT 2
85228: NEG
85229: PUSH
85230: LD_INT 0
85232: PUSH
85233: EMPTY
85234: LIST
85235: LIST
85236: PUSH
85237: LD_INT 2
85239: NEG
85240: PUSH
85241: LD_INT 1
85243: NEG
85244: PUSH
85245: EMPTY
85246: LIST
85247: LIST
85248: PUSH
85249: LD_INT 2
85251: NEG
85252: PUSH
85253: LD_INT 2
85255: NEG
85256: PUSH
85257: EMPTY
85258: LIST
85259: LIST
85260: PUSH
85261: LD_INT 2
85263: NEG
85264: PUSH
85265: LD_INT 3
85267: NEG
85268: PUSH
85269: EMPTY
85270: LIST
85271: LIST
85272: PUSH
85273: LD_INT 2
85275: PUSH
85276: LD_INT 1
85278: NEG
85279: PUSH
85280: EMPTY
85281: LIST
85282: LIST
85283: PUSH
85284: LD_INT 3
85286: PUSH
85287: LD_INT 0
85289: PUSH
85290: EMPTY
85291: LIST
85292: LIST
85293: PUSH
85294: LD_INT 3
85296: PUSH
85297: LD_INT 1
85299: PUSH
85300: EMPTY
85301: LIST
85302: LIST
85303: PUSH
85304: LD_INT 3
85306: PUSH
85307: LD_INT 2
85309: PUSH
85310: EMPTY
85311: LIST
85312: LIST
85313: PUSH
85314: LD_INT 3
85316: PUSH
85317: LD_INT 3
85319: PUSH
85320: EMPTY
85321: LIST
85322: LIST
85323: PUSH
85324: LD_INT 2
85326: PUSH
85327: LD_INT 3
85329: PUSH
85330: EMPTY
85331: LIST
85332: LIST
85333: PUSH
85334: LD_INT 2
85336: NEG
85337: PUSH
85338: LD_INT 1
85340: PUSH
85341: EMPTY
85342: LIST
85343: LIST
85344: PUSH
85345: LD_INT 3
85347: NEG
85348: PUSH
85349: LD_INT 0
85351: PUSH
85352: EMPTY
85353: LIST
85354: LIST
85355: PUSH
85356: LD_INT 3
85358: NEG
85359: PUSH
85360: LD_INT 1
85362: NEG
85363: PUSH
85364: EMPTY
85365: LIST
85366: LIST
85367: PUSH
85368: LD_INT 3
85370: NEG
85371: PUSH
85372: LD_INT 2
85374: NEG
85375: PUSH
85376: EMPTY
85377: LIST
85378: LIST
85379: PUSH
85380: LD_INT 3
85382: NEG
85383: PUSH
85384: LD_INT 3
85386: NEG
85387: PUSH
85388: EMPTY
85389: LIST
85390: LIST
85391: PUSH
85392: EMPTY
85393: LIST
85394: LIST
85395: LIST
85396: LIST
85397: LIST
85398: LIST
85399: LIST
85400: LIST
85401: LIST
85402: LIST
85403: LIST
85404: LIST
85405: LIST
85406: LIST
85407: LIST
85408: LIST
85409: LIST
85410: LIST
85411: LIST
85412: LIST
85413: LIST
85414: LIST
85415: LIST
85416: LIST
85417: LIST
85418: LIST
85419: LIST
85420: LIST
85421: LIST
85422: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85423: LD_ADDR_VAR 0 42
85427: PUSH
85428: LD_INT 0
85430: PUSH
85431: LD_INT 0
85433: PUSH
85434: EMPTY
85435: LIST
85436: LIST
85437: PUSH
85438: LD_INT 0
85440: PUSH
85441: LD_INT 1
85443: NEG
85444: PUSH
85445: EMPTY
85446: LIST
85447: LIST
85448: PUSH
85449: LD_INT 1
85451: PUSH
85452: LD_INT 0
85454: PUSH
85455: EMPTY
85456: LIST
85457: LIST
85458: PUSH
85459: LD_INT 1
85461: PUSH
85462: LD_INT 1
85464: PUSH
85465: EMPTY
85466: LIST
85467: LIST
85468: PUSH
85469: LD_INT 0
85471: PUSH
85472: LD_INT 1
85474: PUSH
85475: EMPTY
85476: LIST
85477: LIST
85478: PUSH
85479: LD_INT 1
85481: NEG
85482: PUSH
85483: LD_INT 0
85485: PUSH
85486: EMPTY
85487: LIST
85488: LIST
85489: PUSH
85490: LD_INT 1
85492: NEG
85493: PUSH
85494: LD_INT 1
85496: NEG
85497: PUSH
85498: EMPTY
85499: LIST
85500: LIST
85501: PUSH
85502: LD_INT 1
85504: NEG
85505: PUSH
85506: LD_INT 2
85508: NEG
85509: PUSH
85510: EMPTY
85511: LIST
85512: LIST
85513: PUSH
85514: LD_INT 0
85516: PUSH
85517: LD_INT 2
85519: NEG
85520: PUSH
85521: EMPTY
85522: LIST
85523: LIST
85524: PUSH
85525: LD_INT 1
85527: PUSH
85528: LD_INT 1
85530: NEG
85531: PUSH
85532: EMPTY
85533: LIST
85534: LIST
85535: PUSH
85536: LD_INT 2
85538: PUSH
85539: LD_INT 1
85541: PUSH
85542: EMPTY
85543: LIST
85544: LIST
85545: PUSH
85546: LD_INT 2
85548: PUSH
85549: LD_INT 2
85551: PUSH
85552: EMPTY
85553: LIST
85554: LIST
85555: PUSH
85556: LD_INT 1
85558: PUSH
85559: LD_INT 2
85561: PUSH
85562: EMPTY
85563: LIST
85564: LIST
85565: PUSH
85566: LD_INT 0
85568: PUSH
85569: LD_INT 2
85571: PUSH
85572: EMPTY
85573: LIST
85574: LIST
85575: PUSH
85576: LD_INT 1
85578: NEG
85579: PUSH
85580: LD_INT 1
85582: PUSH
85583: EMPTY
85584: LIST
85585: LIST
85586: PUSH
85587: LD_INT 2
85589: NEG
85590: PUSH
85591: LD_INT 1
85593: NEG
85594: PUSH
85595: EMPTY
85596: LIST
85597: LIST
85598: PUSH
85599: LD_INT 2
85601: NEG
85602: PUSH
85603: LD_INT 2
85605: NEG
85606: PUSH
85607: EMPTY
85608: LIST
85609: LIST
85610: PUSH
85611: LD_INT 2
85613: NEG
85614: PUSH
85615: LD_INT 3
85617: NEG
85618: PUSH
85619: EMPTY
85620: LIST
85621: LIST
85622: PUSH
85623: LD_INT 1
85625: NEG
85626: PUSH
85627: LD_INT 3
85629: NEG
85630: PUSH
85631: EMPTY
85632: LIST
85633: LIST
85634: PUSH
85635: LD_INT 0
85637: PUSH
85638: LD_INT 3
85640: NEG
85641: PUSH
85642: EMPTY
85643: LIST
85644: LIST
85645: PUSH
85646: LD_INT 1
85648: PUSH
85649: LD_INT 2
85651: NEG
85652: PUSH
85653: EMPTY
85654: LIST
85655: LIST
85656: PUSH
85657: LD_INT 3
85659: PUSH
85660: LD_INT 2
85662: PUSH
85663: EMPTY
85664: LIST
85665: LIST
85666: PUSH
85667: LD_INT 3
85669: PUSH
85670: LD_INT 3
85672: PUSH
85673: EMPTY
85674: LIST
85675: LIST
85676: PUSH
85677: LD_INT 2
85679: PUSH
85680: LD_INT 3
85682: PUSH
85683: EMPTY
85684: LIST
85685: LIST
85686: PUSH
85687: LD_INT 1
85689: PUSH
85690: LD_INT 3
85692: PUSH
85693: EMPTY
85694: LIST
85695: LIST
85696: PUSH
85697: LD_INT 0
85699: PUSH
85700: LD_INT 3
85702: PUSH
85703: EMPTY
85704: LIST
85705: LIST
85706: PUSH
85707: LD_INT 1
85709: NEG
85710: PUSH
85711: LD_INT 2
85713: PUSH
85714: EMPTY
85715: LIST
85716: LIST
85717: PUSH
85718: LD_INT 3
85720: NEG
85721: PUSH
85722: LD_INT 2
85724: NEG
85725: PUSH
85726: EMPTY
85727: LIST
85728: LIST
85729: PUSH
85730: LD_INT 3
85732: NEG
85733: PUSH
85734: LD_INT 3
85736: NEG
85737: PUSH
85738: EMPTY
85739: LIST
85740: LIST
85741: PUSH
85742: EMPTY
85743: LIST
85744: LIST
85745: LIST
85746: LIST
85747: LIST
85748: LIST
85749: LIST
85750: LIST
85751: LIST
85752: LIST
85753: LIST
85754: LIST
85755: LIST
85756: LIST
85757: LIST
85758: LIST
85759: LIST
85760: LIST
85761: LIST
85762: LIST
85763: LIST
85764: LIST
85765: LIST
85766: LIST
85767: LIST
85768: LIST
85769: LIST
85770: LIST
85771: LIST
85772: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85773: LD_ADDR_VAR 0 43
85777: PUSH
85778: LD_INT 0
85780: PUSH
85781: LD_INT 0
85783: PUSH
85784: EMPTY
85785: LIST
85786: LIST
85787: PUSH
85788: LD_INT 0
85790: PUSH
85791: LD_INT 1
85793: NEG
85794: PUSH
85795: EMPTY
85796: LIST
85797: LIST
85798: PUSH
85799: LD_INT 1
85801: PUSH
85802: LD_INT 0
85804: PUSH
85805: EMPTY
85806: LIST
85807: LIST
85808: PUSH
85809: LD_INT 1
85811: PUSH
85812: LD_INT 1
85814: PUSH
85815: EMPTY
85816: LIST
85817: LIST
85818: PUSH
85819: LD_INT 0
85821: PUSH
85822: LD_INT 1
85824: PUSH
85825: EMPTY
85826: LIST
85827: LIST
85828: PUSH
85829: LD_INT 1
85831: NEG
85832: PUSH
85833: LD_INT 0
85835: PUSH
85836: EMPTY
85837: LIST
85838: LIST
85839: PUSH
85840: LD_INT 1
85842: NEG
85843: PUSH
85844: LD_INT 1
85846: NEG
85847: PUSH
85848: EMPTY
85849: LIST
85850: LIST
85851: PUSH
85852: LD_INT 1
85854: NEG
85855: PUSH
85856: LD_INT 2
85858: NEG
85859: PUSH
85860: EMPTY
85861: LIST
85862: LIST
85863: PUSH
85864: LD_INT 0
85866: PUSH
85867: LD_INT 2
85869: NEG
85870: PUSH
85871: EMPTY
85872: LIST
85873: LIST
85874: PUSH
85875: LD_INT 1
85877: PUSH
85878: LD_INT 1
85880: NEG
85881: PUSH
85882: EMPTY
85883: LIST
85884: LIST
85885: PUSH
85886: LD_INT 2
85888: PUSH
85889: LD_INT 0
85891: PUSH
85892: EMPTY
85893: LIST
85894: LIST
85895: PUSH
85896: LD_INT 2
85898: PUSH
85899: LD_INT 1
85901: PUSH
85902: EMPTY
85903: LIST
85904: LIST
85905: PUSH
85906: LD_INT 1
85908: PUSH
85909: LD_INT 2
85911: PUSH
85912: EMPTY
85913: LIST
85914: LIST
85915: PUSH
85916: LD_INT 0
85918: PUSH
85919: LD_INT 2
85921: PUSH
85922: EMPTY
85923: LIST
85924: LIST
85925: PUSH
85926: LD_INT 1
85928: NEG
85929: PUSH
85930: LD_INT 1
85932: PUSH
85933: EMPTY
85934: LIST
85935: LIST
85936: PUSH
85937: LD_INT 2
85939: NEG
85940: PUSH
85941: LD_INT 0
85943: PUSH
85944: EMPTY
85945: LIST
85946: LIST
85947: PUSH
85948: LD_INT 2
85950: NEG
85951: PUSH
85952: LD_INT 1
85954: NEG
85955: PUSH
85956: EMPTY
85957: LIST
85958: LIST
85959: PUSH
85960: LD_INT 1
85962: NEG
85963: PUSH
85964: LD_INT 3
85966: NEG
85967: PUSH
85968: EMPTY
85969: LIST
85970: LIST
85971: PUSH
85972: LD_INT 0
85974: PUSH
85975: LD_INT 3
85977: NEG
85978: PUSH
85979: EMPTY
85980: LIST
85981: LIST
85982: PUSH
85983: LD_INT 1
85985: PUSH
85986: LD_INT 2
85988: NEG
85989: PUSH
85990: EMPTY
85991: LIST
85992: LIST
85993: PUSH
85994: LD_INT 2
85996: PUSH
85997: LD_INT 1
85999: NEG
86000: PUSH
86001: EMPTY
86002: LIST
86003: LIST
86004: PUSH
86005: LD_INT 3
86007: PUSH
86008: LD_INT 0
86010: PUSH
86011: EMPTY
86012: LIST
86013: LIST
86014: PUSH
86015: LD_INT 3
86017: PUSH
86018: LD_INT 1
86020: PUSH
86021: EMPTY
86022: LIST
86023: LIST
86024: PUSH
86025: LD_INT 1
86027: PUSH
86028: LD_INT 3
86030: PUSH
86031: EMPTY
86032: LIST
86033: LIST
86034: PUSH
86035: LD_INT 0
86037: PUSH
86038: LD_INT 3
86040: PUSH
86041: EMPTY
86042: LIST
86043: LIST
86044: PUSH
86045: LD_INT 1
86047: NEG
86048: PUSH
86049: LD_INT 2
86051: PUSH
86052: EMPTY
86053: LIST
86054: LIST
86055: PUSH
86056: LD_INT 2
86058: NEG
86059: PUSH
86060: LD_INT 1
86062: PUSH
86063: EMPTY
86064: LIST
86065: LIST
86066: PUSH
86067: LD_INT 3
86069: NEG
86070: PUSH
86071: LD_INT 0
86073: PUSH
86074: EMPTY
86075: LIST
86076: LIST
86077: PUSH
86078: LD_INT 3
86080: NEG
86081: PUSH
86082: LD_INT 1
86084: NEG
86085: PUSH
86086: EMPTY
86087: LIST
86088: LIST
86089: PUSH
86090: EMPTY
86091: LIST
86092: LIST
86093: LIST
86094: LIST
86095: LIST
86096: LIST
86097: LIST
86098: LIST
86099: LIST
86100: LIST
86101: LIST
86102: LIST
86103: LIST
86104: LIST
86105: LIST
86106: LIST
86107: LIST
86108: LIST
86109: LIST
86110: LIST
86111: LIST
86112: LIST
86113: LIST
86114: LIST
86115: LIST
86116: LIST
86117: LIST
86118: LIST
86119: LIST
86120: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86121: LD_ADDR_VAR 0 44
86125: PUSH
86126: LD_INT 0
86128: PUSH
86129: LD_INT 0
86131: PUSH
86132: EMPTY
86133: LIST
86134: LIST
86135: PUSH
86136: LD_INT 0
86138: PUSH
86139: LD_INT 1
86141: NEG
86142: PUSH
86143: EMPTY
86144: LIST
86145: LIST
86146: PUSH
86147: LD_INT 1
86149: PUSH
86150: LD_INT 0
86152: PUSH
86153: EMPTY
86154: LIST
86155: LIST
86156: PUSH
86157: LD_INT 1
86159: PUSH
86160: LD_INT 1
86162: PUSH
86163: EMPTY
86164: LIST
86165: LIST
86166: PUSH
86167: LD_INT 0
86169: PUSH
86170: LD_INT 1
86172: PUSH
86173: EMPTY
86174: LIST
86175: LIST
86176: PUSH
86177: LD_INT 1
86179: NEG
86180: PUSH
86181: LD_INT 0
86183: PUSH
86184: EMPTY
86185: LIST
86186: LIST
86187: PUSH
86188: LD_INT 1
86190: NEG
86191: PUSH
86192: LD_INT 1
86194: NEG
86195: PUSH
86196: EMPTY
86197: LIST
86198: LIST
86199: PUSH
86200: LD_INT 1
86202: NEG
86203: PUSH
86204: LD_INT 2
86206: NEG
86207: PUSH
86208: EMPTY
86209: LIST
86210: LIST
86211: PUSH
86212: LD_INT 1
86214: PUSH
86215: LD_INT 1
86217: NEG
86218: PUSH
86219: EMPTY
86220: LIST
86221: LIST
86222: PUSH
86223: LD_INT 2
86225: PUSH
86226: LD_INT 0
86228: PUSH
86229: EMPTY
86230: LIST
86231: LIST
86232: PUSH
86233: LD_INT 2
86235: PUSH
86236: LD_INT 1
86238: PUSH
86239: EMPTY
86240: LIST
86241: LIST
86242: PUSH
86243: LD_INT 2
86245: PUSH
86246: LD_INT 2
86248: PUSH
86249: EMPTY
86250: LIST
86251: LIST
86252: PUSH
86253: LD_INT 1
86255: PUSH
86256: LD_INT 2
86258: PUSH
86259: EMPTY
86260: LIST
86261: LIST
86262: PUSH
86263: LD_INT 1
86265: NEG
86266: PUSH
86267: LD_INT 1
86269: PUSH
86270: EMPTY
86271: LIST
86272: LIST
86273: PUSH
86274: LD_INT 2
86276: NEG
86277: PUSH
86278: LD_INT 0
86280: PUSH
86281: EMPTY
86282: LIST
86283: LIST
86284: PUSH
86285: LD_INT 2
86287: NEG
86288: PUSH
86289: LD_INT 1
86291: NEG
86292: PUSH
86293: EMPTY
86294: LIST
86295: LIST
86296: PUSH
86297: LD_INT 2
86299: NEG
86300: PUSH
86301: LD_INT 2
86303: NEG
86304: PUSH
86305: EMPTY
86306: LIST
86307: LIST
86308: PUSH
86309: LD_INT 2
86311: NEG
86312: PUSH
86313: LD_INT 3
86315: NEG
86316: PUSH
86317: EMPTY
86318: LIST
86319: LIST
86320: PUSH
86321: LD_INT 2
86323: PUSH
86324: LD_INT 1
86326: NEG
86327: PUSH
86328: EMPTY
86329: LIST
86330: LIST
86331: PUSH
86332: LD_INT 3
86334: PUSH
86335: LD_INT 0
86337: PUSH
86338: EMPTY
86339: LIST
86340: LIST
86341: PUSH
86342: LD_INT 3
86344: PUSH
86345: LD_INT 1
86347: PUSH
86348: EMPTY
86349: LIST
86350: LIST
86351: PUSH
86352: LD_INT 3
86354: PUSH
86355: LD_INT 2
86357: PUSH
86358: EMPTY
86359: LIST
86360: LIST
86361: PUSH
86362: LD_INT 3
86364: PUSH
86365: LD_INT 3
86367: PUSH
86368: EMPTY
86369: LIST
86370: LIST
86371: PUSH
86372: LD_INT 2
86374: PUSH
86375: LD_INT 3
86377: PUSH
86378: EMPTY
86379: LIST
86380: LIST
86381: PUSH
86382: LD_INT 2
86384: NEG
86385: PUSH
86386: LD_INT 1
86388: PUSH
86389: EMPTY
86390: LIST
86391: LIST
86392: PUSH
86393: LD_INT 3
86395: NEG
86396: PUSH
86397: LD_INT 0
86399: PUSH
86400: EMPTY
86401: LIST
86402: LIST
86403: PUSH
86404: LD_INT 3
86406: NEG
86407: PUSH
86408: LD_INT 1
86410: NEG
86411: PUSH
86412: EMPTY
86413: LIST
86414: LIST
86415: PUSH
86416: LD_INT 3
86418: NEG
86419: PUSH
86420: LD_INT 2
86422: NEG
86423: PUSH
86424: EMPTY
86425: LIST
86426: LIST
86427: PUSH
86428: LD_INT 3
86430: NEG
86431: PUSH
86432: LD_INT 3
86434: NEG
86435: PUSH
86436: EMPTY
86437: LIST
86438: LIST
86439: PUSH
86440: EMPTY
86441: LIST
86442: LIST
86443: LIST
86444: LIST
86445: LIST
86446: LIST
86447: LIST
86448: LIST
86449: LIST
86450: LIST
86451: LIST
86452: LIST
86453: LIST
86454: LIST
86455: LIST
86456: LIST
86457: LIST
86458: LIST
86459: LIST
86460: LIST
86461: LIST
86462: LIST
86463: LIST
86464: LIST
86465: LIST
86466: LIST
86467: LIST
86468: LIST
86469: LIST
86470: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86471: LD_ADDR_VAR 0 45
86475: PUSH
86476: LD_INT 0
86478: PUSH
86479: LD_INT 0
86481: PUSH
86482: EMPTY
86483: LIST
86484: LIST
86485: PUSH
86486: LD_INT 0
86488: PUSH
86489: LD_INT 1
86491: NEG
86492: PUSH
86493: EMPTY
86494: LIST
86495: LIST
86496: PUSH
86497: LD_INT 1
86499: PUSH
86500: LD_INT 0
86502: PUSH
86503: EMPTY
86504: LIST
86505: LIST
86506: PUSH
86507: LD_INT 1
86509: PUSH
86510: LD_INT 1
86512: PUSH
86513: EMPTY
86514: LIST
86515: LIST
86516: PUSH
86517: LD_INT 0
86519: PUSH
86520: LD_INT 1
86522: PUSH
86523: EMPTY
86524: LIST
86525: LIST
86526: PUSH
86527: LD_INT 1
86529: NEG
86530: PUSH
86531: LD_INT 0
86533: PUSH
86534: EMPTY
86535: LIST
86536: LIST
86537: PUSH
86538: LD_INT 1
86540: NEG
86541: PUSH
86542: LD_INT 1
86544: NEG
86545: PUSH
86546: EMPTY
86547: LIST
86548: LIST
86549: PUSH
86550: LD_INT 1
86552: NEG
86553: PUSH
86554: LD_INT 2
86556: NEG
86557: PUSH
86558: EMPTY
86559: LIST
86560: LIST
86561: PUSH
86562: LD_INT 0
86564: PUSH
86565: LD_INT 2
86567: NEG
86568: PUSH
86569: EMPTY
86570: LIST
86571: LIST
86572: PUSH
86573: LD_INT 1
86575: PUSH
86576: LD_INT 1
86578: NEG
86579: PUSH
86580: EMPTY
86581: LIST
86582: LIST
86583: PUSH
86584: LD_INT 2
86586: PUSH
86587: LD_INT 1
86589: PUSH
86590: EMPTY
86591: LIST
86592: LIST
86593: PUSH
86594: LD_INT 2
86596: PUSH
86597: LD_INT 2
86599: PUSH
86600: EMPTY
86601: LIST
86602: LIST
86603: PUSH
86604: LD_INT 1
86606: PUSH
86607: LD_INT 2
86609: PUSH
86610: EMPTY
86611: LIST
86612: LIST
86613: PUSH
86614: LD_INT 0
86616: PUSH
86617: LD_INT 2
86619: PUSH
86620: EMPTY
86621: LIST
86622: LIST
86623: PUSH
86624: LD_INT 1
86626: NEG
86627: PUSH
86628: LD_INT 1
86630: PUSH
86631: EMPTY
86632: LIST
86633: LIST
86634: PUSH
86635: LD_INT 2
86637: NEG
86638: PUSH
86639: LD_INT 1
86641: NEG
86642: PUSH
86643: EMPTY
86644: LIST
86645: LIST
86646: PUSH
86647: LD_INT 2
86649: NEG
86650: PUSH
86651: LD_INT 2
86653: NEG
86654: PUSH
86655: EMPTY
86656: LIST
86657: LIST
86658: PUSH
86659: LD_INT 2
86661: NEG
86662: PUSH
86663: LD_INT 3
86665: NEG
86666: PUSH
86667: EMPTY
86668: LIST
86669: LIST
86670: PUSH
86671: LD_INT 1
86673: NEG
86674: PUSH
86675: LD_INT 3
86677: NEG
86678: PUSH
86679: EMPTY
86680: LIST
86681: LIST
86682: PUSH
86683: LD_INT 0
86685: PUSH
86686: LD_INT 3
86688: NEG
86689: PUSH
86690: EMPTY
86691: LIST
86692: LIST
86693: PUSH
86694: LD_INT 1
86696: PUSH
86697: LD_INT 2
86699: NEG
86700: PUSH
86701: EMPTY
86702: LIST
86703: LIST
86704: PUSH
86705: LD_INT 3
86707: PUSH
86708: LD_INT 2
86710: PUSH
86711: EMPTY
86712: LIST
86713: LIST
86714: PUSH
86715: LD_INT 3
86717: PUSH
86718: LD_INT 3
86720: PUSH
86721: EMPTY
86722: LIST
86723: LIST
86724: PUSH
86725: LD_INT 2
86727: PUSH
86728: LD_INT 3
86730: PUSH
86731: EMPTY
86732: LIST
86733: LIST
86734: PUSH
86735: LD_INT 1
86737: PUSH
86738: LD_INT 3
86740: PUSH
86741: EMPTY
86742: LIST
86743: LIST
86744: PUSH
86745: LD_INT 0
86747: PUSH
86748: LD_INT 3
86750: PUSH
86751: EMPTY
86752: LIST
86753: LIST
86754: PUSH
86755: LD_INT 1
86757: NEG
86758: PUSH
86759: LD_INT 2
86761: PUSH
86762: EMPTY
86763: LIST
86764: LIST
86765: PUSH
86766: LD_INT 3
86768: NEG
86769: PUSH
86770: LD_INT 2
86772: NEG
86773: PUSH
86774: EMPTY
86775: LIST
86776: LIST
86777: PUSH
86778: LD_INT 3
86780: NEG
86781: PUSH
86782: LD_INT 3
86784: NEG
86785: PUSH
86786: EMPTY
86787: LIST
86788: LIST
86789: PUSH
86790: EMPTY
86791: LIST
86792: LIST
86793: LIST
86794: LIST
86795: LIST
86796: LIST
86797: LIST
86798: LIST
86799: LIST
86800: LIST
86801: LIST
86802: LIST
86803: LIST
86804: LIST
86805: LIST
86806: LIST
86807: LIST
86808: LIST
86809: LIST
86810: LIST
86811: LIST
86812: LIST
86813: LIST
86814: LIST
86815: LIST
86816: LIST
86817: LIST
86818: LIST
86819: LIST
86820: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86821: LD_ADDR_VAR 0 46
86825: PUSH
86826: LD_INT 0
86828: PUSH
86829: LD_INT 0
86831: PUSH
86832: EMPTY
86833: LIST
86834: LIST
86835: PUSH
86836: LD_INT 0
86838: PUSH
86839: LD_INT 1
86841: NEG
86842: PUSH
86843: EMPTY
86844: LIST
86845: LIST
86846: PUSH
86847: LD_INT 1
86849: PUSH
86850: LD_INT 0
86852: PUSH
86853: EMPTY
86854: LIST
86855: LIST
86856: PUSH
86857: LD_INT 1
86859: PUSH
86860: LD_INT 1
86862: PUSH
86863: EMPTY
86864: LIST
86865: LIST
86866: PUSH
86867: LD_INT 0
86869: PUSH
86870: LD_INT 1
86872: PUSH
86873: EMPTY
86874: LIST
86875: LIST
86876: PUSH
86877: LD_INT 1
86879: NEG
86880: PUSH
86881: LD_INT 0
86883: PUSH
86884: EMPTY
86885: LIST
86886: LIST
86887: PUSH
86888: LD_INT 1
86890: NEG
86891: PUSH
86892: LD_INT 1
86894: NEG
86895: PUSH
86896: EMPTY
86897: LIST
86898: LIST
86899: PUSH
86900: LD_INT 1
86902: NEG
86903: PUSH
86904: LD_INT 2
86906: NEG
86907: PUSH
86908: EMPTY
86909: LIST
86910: LIST
86911: PUSH
86912: LD_INT 0
86914: PUSH
86915: LD_INT 2
86917: NEG
86918: PUSH
86919: EMPTY
86920: LIST
86921: LIST
86922: PUSH
86923: LD_INT 1
86925: PUSH
86926: LD_INT 1
86928: NEG
86929: PUSH
86930: EMPTY
86931: LIST
86932: LIST
86933: PUSH
86934: LD_INT 2
86936: PUSH
86937: LD_INT 0
86939: PUSH
86940: EMPTY
86941: LIST
86942: LIST
86943: PUSH
86944: LD_INT 2
86946: PUSH
86947: LD_INT 1
86949: PUSH
86950: EMPTY
86951: LIST
86952: LIST
86953: PUSH
86954: LD_INT 1
86956: PUSH
86957: LD_INT 2
86959: PUSH
86960: EMPTY
86961: LIST
86962: LIST
86963: PUSH
86964: LD_INT 0
86966: PUSH
86967: LD_INT 2
86969: PUSH
86970: EMPTY
86971: LIST
86972: LIST
86973: PUSH
86974: LD_INT 1
86976: NEG
86977: PUSH
86978: LD_INT 1
86980: PUSH
86981: EMPTY
86982: LIST
86983: LIST
86984: PUSH
86985: LD_INT 2
86987: NEG
86988: PUSH
86989: LD_INT 0
86991: PUSH
86992: EMPTY
86993: LIST
86994: LIST
86995: PUSH
86996: LD_INT 2
86998: NEG
86999: PUSH
87000: LD_INT 1
87002: NEG
87003: PUSH
87004: EMPTY
87005: LIST
87006: LIST
87007: PUSH
87008: LD_INT 1
87010: NEG
87011: PUSH
87012: LD_INT 3
87014: NEG
87015: PUSH
87016: EMPTY
87017: LIST
87018: LIST
87019: PUSH
87020: LD_INT 0
87022: PUSH
87023: LD_INT 3
87025: NEG
87026: PUSH
87027: EMPTY
87028: LIST
87029: LIST
87030: PUSH
87031: LD_INT 1
87033: PUSH
87034: LD_INT 2
87036: NEG
87037: PUSH
87038: EMPTY
87039: LIST
87040: LIST
87041: PUSH
87042: LD_INT 2
87044: PUSH
87045: LD_INT 1
87047: NEG
87048: PUSH
87049: EMPTY
87050: LIST
87051: LIST
87052: PUSH
87053: LD_INT 3
87055: PUSH
87056: LD_INT 0
87058: PUSH
87059: EMPTY
87060: LIST
87061: LIST
87062: PUSH
87063: LD_INT 3
87065: PUSH
87066: LD_INT 1
87068: PUSH
87069: EMPTY
87070: LIST
87071: LIST
87072: PUSH
87073: LD_INT 1
87075: PUSH
87076: LD_INT 3
87078: PUSH
87079: EMPTY
87080: LIST
87081: LIST
87082: PUSH
87083: LD_INT 0
87085: PUSH
87086: LD_INT 3
87088: PUSH
87089: EMPTY
87090: LIST
87091: LIST
87092: PUSH
87093: LD_INT 1
87095: NEG
87096: PUSH
87097: LD_INT 2
87099: PUSH
87100: EMPTY
87101: LIST
87102: LIST
87103: PUSH
87104: LD_INT 2
87106: NEG
87107: PUSH
87108: LD_INT 1
87110: PUSH
87111: EMPTY
87112: LIST
87113: LIST
87114: PUSH
87115: LD_INT 3
87117: NEG
87118: PUSH
87119: LD_INT 0
87121: PUSH
87122: EMPTY
87123: LIST
87124: LIST
87125: PUSH
87126: LD_INT 3
87128: NEG
87129: PUSH
87130: LD_INT 1
87132: NEG
87133: PUSH
87134: EMPTY
87135: LIST
87136: LIST
87137: PUSH
87138: EMPTY
87139: LIST
87140: LIST
87141: LIST
87142: LIST
87143: LIST
87144: LIST
87145: LIST
87146: LIST
87147: LIST
87148: LIST
87149: LIST
87150: LIST
87151: LIST
87152: LIST
87153: LIST
87154: LIST
87155: LIST
87156: LIST
87157: LIST
87158: LIST
87159: LIST
87160: LIST
87161: LIST
87162: LIST
87163: LIST
87164: LIST
87165: LIST
87166: LIST
87167: LIST
87168: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87169: LD_ADDR_VAR 0 47
87173: PUSH
87174: LD_INT 0
87176: PUSH
87177: LD_INT 0
87179: PUSH
87180: EMPTY
87181: LIST
87182: LIST
87183: PUSH
87184: LD_INT 0
87186: PUSH
87187: LD_INT 1
87189: NEG
87190: PUSH
87191: EMPTY
87192: LIST
87193: LIST
87194: PUSH
87195: LD_INT 1
87197: PUSH
87198: LD_INT 0
87200: PUSH
87201: EMPTY
87202: LIST
87203: LIST
87204: PUSH
87205: LD_INT 1
87207: PUSH
87208: LD_INT 1
87210: PUSH
87211: EMPTY
87212: LIST
87213: LIST
87214: PUSH
87215: LD_INT 0
87217: PUSH
87218: LD_INT 1
87220: PUSH
87221: EMPTY
87222: LIST
87223: LIST
87224: PUSH
87225: LD_INT 1
87227: NEG
87228: PUSH
87229: LD_INT 0
87231: PUSH
87232: EMPTY
87233: LIST
87234: LIST
87235: PUSH
87236: LD_INT 1
87238: NEG
87239: PUSH
87240: LD_INT 1
87242: NEG
87243: PUSH
87244: EMPTY
87245: LIST
87246: LIST
87247: PUSH
87248: LD_INT 1
87250: NEG
87251: PUSH
87252: LD_INT 2
87254: NEG
87255: PUSH
87256: EMPTY
87257: LIST
87258: LIST
87259: PUSH
87260: LD_INT 0
87262: PUSH
87263: LD_INT 2
87265: NEG
87266: PUSH
87267: EMPTY
87268: LIST
87269: LIST
87270: PUSH
87271: LD_INT 1
87273: PUSH
87274: LD_INT 1
87276: NEG
87277: PUSH
87278: EMPTY
87279: LIST
87280: LIST
87281: PUSH
87282: LD_INT 2
87284: NEG
87285: PUSH
87286: LD_INT 1
87288: NEG
87289: PUSH
87290: EMPTY
87291: LIST
87292: LIST
87293: PUSH
87294: LD_INT 2
87296: NEG
87297: PUSH
87298: LD_INT 2
87300: NEG
87301: PUSH
87302: EMPTY
87303: LIST
87304: LIST
87305: PUSH
87306: EMPTY
87307: LIST
87308: LIST
87309: LIST
87310: LIST
87311: LIST
87312: LIST
87313: LIST
87314: LIST
87315: LIST
87316: LIST
87317: LIST
87318: LIST
87319: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
87320: LD_ADDR_VAR 0 48
87324: PUSH
87325: LD_INT 0
87327: PUSH
87328: LD_INT 0
87330: PUSH
87331: EMPTY
87332: LIST
87333: LIST
87334: PUSH
87335: LD_INT 0
87337: PUSH
87338: LD_INT 1
87340: NEG
87341: PUSH
87342: EMPTY
87343: LIST
87344: LIST
87345: PUSH
87346: LD_INT 1
87348: PUSH
87349: LD_INT 0
87351: PUSH
87352: EMPTY
87353: LIST
87354: LIST
87355: PUSH
87356: LD_INT 1
87358: PUSH
87359: LD_INT 1
87361: PUSH
87362: EMPTY
87363: LIST
87364: LIST
87365: PUSH
87366: LD_INT 0
87368: PUSH
87369: LD_INT 1
87371: PUSH
87372: EMPTY
87373: LIST
87374: LIST
87375: PUSH
87376: LD_INT 1
87378: NEG
87379: PUSH
87380: LD_INT 0
87382: PUSH
87383: EMPTY
87384: LIST
87385: LIST
87386: PUSH
87387: LD_INT 1
87389: NEG
87390: PUSH
87391: LD_INT 1
87393: NEG
87394: PUSH
87395: EMPTY
87396: LIST
87397: LIST
87398: PUSH
87399: LD_INT 1
87401: NEG
87402: PUSH
87403: LD_INT 2
87405: NEG
87406: PUSH
87407: EMPTY
87408: LIST
87409: LIST
87410: PUSH
87411: LD_INT 0
87413: PUSH
87414: LD_INT 2
87416: NEG
87417: PUSH
87418: EMPTY
87419: LIST
87420: LIST
87421: PUSH
87422: LD_INT 1
87424: PUSH
87425: LD_INT 1
87427: NEG
87428: PUSH
87429: EMPTY
87430: LIST
87431: LIST
87432: PUSH
87433: LD_INT 2
87435: PUSH
87436: LD_INT 0
87438: PUSH
87439: EMPTY
87440: LIST
87441: LIST
87442: PUSH
87443: LD_INT 2
87445: PUSH
87446: LD_INT 1
87448: PUSH
87449: EMPTY
87450: LIST
87451: LIST
87452: PUSH
87453: EMPTY
87454: LIST
87455: LIST
87456: LIST
87457: LIST
87458: LIST
87459: LIST
87460: LIST
87461: LIST
87462: LIST
87463: LIST
87464: LIST
87465: LIST
87466: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
87467: LD_ADDR_VAR 0 49
87471: PUSH
87472: LD_INT 0
87474: PUSH
87475: LD_INT 0
87477: PUSH
87478: EMPTY
87479: LIST
87480: LIST
87481: PUSH
87482: LD_INT 0
87484: PUSH
87485: LD_INT 1
87487: NEG
87488: PUSH
87489: EMPTY
87490: LIST
87491: LIST
87492: PUSH
87493: LD_INT 1
87495: PUSH
87496: LD_INT 0
87498: PUSH
87499: EMPTY
87500: LIST
87501: LIST
87502: PUSH
87503: LD_INT 1
87505: PUSH
87506: LD_INT 1
87508: PUSH
87509: EMPTY
87510: LIST
87511: LIST
87512: PUSH
87513: LD_INT 0
87515: PUSH
87516: LD_INT 1
87518: PUSH
87519: EMPTY
87520: LIST
87521: LIST
87522: PUSH
87523: LD_INT 1
87525: NEG
87526: PUSH
87527: LD_INT 0
87529: PUSH
87530: EMPTY
87531: LIST
87532: LIST
87533: PUSH
87534: LD_INT 1
87536: NEG
87537: PUSH
87538: LD_INT 1
87540: NEG
87541: PUSH
87542: EMPTY
87543: LIST
87544: LIST
87545: PUSH
87546: LD_INT 1
87548: PUSH
87549: LD_INT 1
87551: NEG
87552: PUSH
87553: EMPTY
87554: LIST
87555: LIST
87556: PUSH
87557: LD_INT 2
87559: PUSH
87560: LD_INT 0
87562: PUSH
87563: EMPTY
87564: LIST
87565: LIST
87566: PUSH
87567: LD_INT 2
87569: PUSH
87570: LD_INT 1
87572: PUSH
87573: EMPTY
87574: LIST
87575: LIST
87576: PUSH
87577: LD_INT 2
87579: PUSH
87580: LD_INT 2
87582: PUSH
87583: EMPTY
87584: LIST
87585: LIST
87586: PUSH
87587: LD_INT 1
87589: PUSH
87590: LD_INT 2
87592: PUSH
87593: EMPTY
87594: LIST
87595: LIST
87596: PUSH
87597: EMPTY
87598: LIST
87599: LIST
87600: LIST
87601: LIST
87602: LIST
87603: LIST
87604: LIST
87605: LIST
87606: LIST
87607: LIST
87608: LIST
87609: LIST
87610: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
87611: LD_ADDR_VAR 0 50
87615: PUSH
87616: LD_INT 0
87618: PUSH
87619: LD_INT 0
87621: PUSH
87622: EMPTY
87623: LIST
87624: LIST
87625: PUSH
87626: LD_INT 0
87628: PUSH
87629: LD_INT 1
87631: NEG
87632: PUSH
87633: EMPTY
87634: LIST
87635: LIST
87636: PUSH
87637: LD_INT 1
87639: PUSH
87640: LD_INT 0
87642: PUSH
87643: EMPTY
87644: LIST
87645: LIST
87646: PUSH
87647: LD_INT 1
87649: PUSH
87650: LD_INT 1
87652: PUSH
87653: EMPTY
87654: LIST
87655: LIST
87656: PUSH
87657: LD_INT 0
87659: PUSH
87660: LD_INT 1
87662: PUSH
87663: EMPTY
87664: LIST
87665: LIST
87666: PUSH
87667: LD_INT 1
87669: NEG
87670: PUSH
87671: LD_INT 0
87673: PUSH
87674: EMPTY
87675: LIST
87676: LIST
87677: PUSH
87678: LD_INT 1
87680: NEG
87681: PUSH
87682: LD_INT 1
87684: NEG
87685: PUSH
87686: EMPTY
87687: LIST
87688: LIST
87689: PUSH
87690: LD_INT 2
87692: PUSH
87693: LD_INT 1
87695: PUSH
87696: EMPTY
87697: LIST
87698: LIST
87699: PUSH
87700: LD_INT 2
87702: PUSH
87703: LD_INT 2
87705: PUSH
87706: EMPTY
87707: LIST
87708: LIST
87709: PUSH
87710: LD_INT 1
87712: PUSH
87713: LD_INT 2
87715: PUSH
87716: EMPTY
87717: LIST
87718: LIST
87719: PUSH
87720: LD_INT 0
87722: PUSH
87723: LD_INT 2
87725: PUSH
87726: EMPTY
87727: LIST
87728: LIST
87729: PUSH
87730: LD_INT 1
87732: NEG
87733: PUSH
87734: LD_INT 1
87736: PUSH
87737: EMPTY
87738: LIST
87739: LIST
87740: PUSH
87741: EMPTY
87742: LIST
87743: LIST
87744: LIST
87745: LIST
87746: LIST
87747: LIST
87748: LIST
87749: LIST
87750: LIST
87751: LIST
87752: LIST
87753: LIST
87754: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
87755: LD_ADDR_VAR 0 51
87759: PUSH
87760: LD_INT 0
87762: PUSH
87763: LD_INT 0
87765: PUSH
87766: EMPTY
87767: LIST
87768: LIST
87769: PUSH
87770: LD_INT 0
87772: PUSH
87773: LD_INT 1
87775: NEG
87776: PUSH
87777: EMPTY
87778: LIST
87779: LIST
87780: PUSH
87781: LD_INT 1
87783: PUSH
87784: LD_INT 0
87786: PUSH
87787: EMPTY
87788: LIST
87789: LIST
87790: PUSH
87791: LD_INT 1
87793: PUSH
87794: LD_INT 1
87796: PUSH
87797: EMPTY
87798: LIST
87799: LIST
87800: PUSH
87801: LD_INT 0
87803: PUSH
87804: LD_INT 1
87806: PUSH
87807: EMPTY
87808: LIST
87809: LIST
87810: PUSH
87811: LD_INT 1
87813: NEG
87814: PUSH
87815: LD_INT 0
87817: PUSH
87818: EMPTY
87819: LIST
87820: LIST
87821: PUSH
87822: LD_INT 1
87824: NEG
87825: PUSH
87826: LD_INT 1
87828: NEG
87829: PUSH
87830: EMPTY
87831: LIST
87832: LIST
87833: PUSH
87834: LD_INT 1
87836: PUSH
87837: LD_INT 2
87839: PUSH
87840: EMPTY
87841: LIST
87842: LIST
87843: PUSH
87844: LD_INT 0
87846: PUSH
87847: LD_INT 2
87849: PUSH
87850: EMPTY
87851: LIST
87852: LIST
87853: PUSH
87854: LD_INT 1
87856: NEG
87857: PUSH
87858: LD_INT 1
87860: PUSH
87861: EMPTY
87862: LIST
87863: LIST
87864: PUSH
87865: LD_INT 2
87867: NEG
87868: PUSH
87869: LD_INT 0
87871: PUSH
87872: EMPTY
87873: LIST
87874: LIST
87875: PUSH
87876: LD_INT 2
87878: NEG
87879: PUSH
87880: LD_INT 1
87882: NEG
87883: PUSH
87884: EMPTY
87885: LIST
87886: LIST
87887: PUSH
87888: EMPTY
87889: LIST
87890: LIST
87891: LIST
87892: LIST
87893: LIST
87894: LIST
87895: LIST
87896: LIST
87897: LIST
87898: LIST
87899: LIST
87900: LIST
87901: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87902: LD_ADDR_VAR 0 52
87906: PUSH
87907: LD_INT 0
87909: PUSH
87910: LD_INT 0
87912: PUSH
87913: EMPTY
87914: LIST
87915: LIST
87916: PUSH
87917: LD_INT 0
87919: PUSH
87920: LD_INT 1
87922: NEG
87923: PUSH
87924: EMPTY
87925: LIST
87926: LIST
87927: PUSH
87928: LD_INT 1
87930: PUSH
87931: LD_INT 0
87933: PUSH
87934: EMPTY
87935: LIST
87936: LIST
87937: PUSH
87938: LD_INT 1
87940: PUSH
87941: LD_INT 1
87943: PUSH
87944: EMPTY
87945: LIST
87946: LIST
87947: PUSH
87948: LD_INT 0
87950: PUSH
87951: LD_INT 1
87953: PUSH
87954: EMPTY
87955: LIST
87956: LIST
87957: PUSH
87958: LD_INT 1
87960: NEG
87961: PUSH
87962: LD_INT 0
87964: PUSH
87965: EMPTY
87966: LIST
87967: LIST
87968: PUSH
87969: LD_INT 1
87971: NEG
87972: PUSH
87973: LD_INT 1
87975: NEG
87976: PUSH
87977: EMPTY
87978: LIST
87979: LIST
87980: PUSH
87981: LD_INT 1
87983: NEG
87984: PUSH
87985: LD_INT 2
87987: NEG
87988: PUSH
87989: EMPTY
87990: LIST
87991: LIST
87992: PUSH
87993: LD_INT 1
87995: NEG
87996: PUSH
87997: LD_INT 1
87999: PUSH
88000: EMPTY
88001: LIST
88002: LIST
88003: PUSH
88004: LD_INT 2
88006: NEG
88007: PUSH
88008: LD_INT 0
88010: PUSH
88011: EMPTY
88012: LIST
88013: LIST
88014: PUSH
88015: LD_INT 2
88017: NEG
88018: PUSH
88019: LD_INT 1
88021: NEG
88022: PUSH
88023: EMPTY
88024: LIST
88025: LIST
88026: PUSH
88027: LD_INT 2
88029: NEG
88030: PUSH
88031: LD_INT 2
88033: NEG
88034: PUSH
88035: EMPTY
88036: LIST
88037: LIST
88038: PUSH
88039: EMPTY
88040: LIST
88041: LIST
88042: LIST
88043: LIST
88044: LIST
88045: LIST
88046: LIST
88047: LIST
88048: LIST
88049: LIST
88050: LIST
88051: LIST
88052: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88053: LD_ADDR_VAR 0 53
88057: PUSH
88058: LD_INT 0
88060: PUSH
88061: LD_INT 0
88063: PUSH
88064: EMPTY
88065: LIST
88066: LIST
88067: PUSH
88068: LD_INT 0
88070: PUSH
88071: LD_INT 1
88073: NEG
88074: PUSH
88075: EMPTY
88076: LIST
88077: LIST
88078: PUSH
88079: LD_INT 1
88081: PUSH
88082: LD_INT 0
88084: PUSH
88085: EMPTY
88086: LIST
88087: LIST
88088: PUSH
88089: LD_INT 1
88091: PUSH
88092: LD_INT 1
88094: PUSH
88095: EMPTY
88096: LIST
88097: LIST
88098: PUSH
88099: LD_INT 0
88101: PUSH
88102: LD_INT 1
88104: PUSH
88105: EMPTY
88106: LIST
88107: LIST
88108: PUSH
88109: LD_INT 1
88111: NEG
88112: PUSH
88113: LD_INT 0
88115: PUSH
88116: EMPTY
88117: LIST
88118: LIST
88119: PUSH
88120: LD_INT 1
88122: NEG
88123: PUSH
88124: LD_INT 1
88126: NEG
88127: PUSH
88128: EMPTY
88129: LIST
88130: LIST
88131: PUSH
88132: LD_INT 1
88134: NEG
88135: PUSH
88136: LD_INT 2
88138: NEG
88139: PUSH
88140: EMPTY
88141: LIST
88142: LIST
88143: PUSH
88144: LD_INT 0
88146: PUSH
88147: LD_INT 2
88149: NEG
88150: PUSH
88151: EMPTY
88152: LIST
88153: LIST
88154: PUSH
88155: LD_INT 1
88157: PUSH
88158: LD_INT 1
88160: NEG
88161: PUSH
88162: EMPTY
88163: LIST
88164: LIST
88165: PUSH
88166: LD_INT 2
88168: PUSH
88169: LD_INT 0
88171: PUSH
88172: EMPTY
88173: LIST
88174: LIST
88175: PUSH
88176: LD_INT 2
88178: PUSH
88179: LD_INT 1
88181: PUSH
88182: EMPTY
88183: LIST
88184: LIST
88185: PUSH
88186: LD_INT 2
88188: PUSH
88189: LD_INT 2
88191: PUSH
88192: EMPTY
88193: LIST
88194: LIST
88195: PUSH
88196: LD_INT 1
88198: PUSH
88199: LD_INT 2
88201: PUSH
88202: EMPTY
88203: LIST
88204: LIST
88205: PUSH
88206: LD_INT 0
88208: PUSH
88209: LD_INT 2
88211: PUSH
88212: EMPTY
88213: LIST
88214: LIST
88215: PUSH
88216: LD_INT 1
88218: NEG
88219: PUSH
88220: LD_INT 1
88222: PUSH
88223: EMPTY
88224: LIST
88225: LIST
88226: PUSH
88227: LD_INT 2
88229: NEG
88230: PUSH
88231: LD_INT 0
88233: PUSH
88234: EMPTY
88235: LIST
88236: LIST
88237: PUSH
88238: LD_INT 2
88240: NEG
88241: PUSH
88242: LD_INT 1
88244: NEG
88245: PUSH
88246: EMPTY
88247: LIST
88248: LIST
88249: PUSH
88250: LD_INT 2
88252: NEG
88253: PUSH
88254: LD_INT 2
88256: NEG
88257: PUSH
88258: EMPTY
88259: LIST
88260: LIST
88261: PUSH
88262: EMPTY
88263: LIST
88264: LIST
88265: LIST
88266: LIST
88267: LIST
88268: LIST
88269: LIST
88270: LIST
88271: LIST
88272: LIST
88273: LIST
88274: LIST
88275: LIST
88276: LIST
88277: LIST
88278: LIST
88279: LIST
88280: LIST
88281: LIST
88282: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88283: LD_ADDR_VAR 0 54
88287: PUSH
88288: LD_INT 0
88290: PUSH
88291: LD_INT 0
88293: PUSH
88294: EMPTY
88295: LIST
88296: LIST
88297: PUSH
88298: LD_INT 0
88300: PUSH
88301: LD_INT 1
88303: NEG
88304: PUSH
88305: EMPTY
88306: LIST
88307: LIST
88308: PUSH
88309: LD_INT 1
88311: PUSH
88312: LD_INT 0
88314: PUSH
88315: EMPTY
88316: LIST
88317: LIST
88318: PUSH
88319: LD_INT 1
88321: PUSH
88322: LD_INT 1
88324: PUSH
88325: EMPTY
88326: LIST
88327: LIST
88328: PUSH
88329: LD_INT 0
88331: PUSH
88332: LD_INT 1
88334: PUSH
88335: EMPTY
88336: LIST
88337: LIST
88338: PUSH
88339: LD_INT 1
88341: NEG
88342: PUSH
88343: LD_INT 0
88345: PUSH
88346: EMPTY
88347: LIST
88348: LIST
88349: PUSH
88350: LD_INT 1
88352: NEG
88353: PUSH
88354: LD_INT 1
88356: NEG
88357: PUSH
88358: EMPTY
88359: LIST
88360: LIST
88361: PUSH
88362: LD_INT 1
88364: NEG
88365: PUSH
88366: LD_INT 2
88368: NEG
88369: PUSH
88370: EMPTY
88371: LIST
88372: LIST
88373: PUSH
88374: LD_INT 0
88376: PUSH
88377: LD_INT 2
88379: NEG
88380: PUSH
88381: EMPTY
88382: LIST
88383: LIST
88384: PUSH
88385: LD_INT 1
88387: PUSH
88388: LD_INT 1
88390: NEG
88391: PUSH
88392: EMPTY
88393: LIST
88394: LIST
88395: PUSH
88396: LD_INT 2
88398: PUSH
88399: LD_INT 0
88401: PUSH
88402: EMPTY
88403: LIST
88404: LIST
88405: PUSH
88406: LD_INT 2
88408: PUSH
88409: LD_INT 1
88411: PUSH
88412: EMPTY
88413: LIST
88414: LIST
88415: PUSH
88416: LD_INT 2
88418: PUSH
88419: LD_INT 2
88421: PUSH
88422: EMPTY
88423: LIST
88424: LIST
88425: PUSH
88426: LD_INT 1
88428: PUSH
88429: LD_INT 2
88431: PUSH
88432: EMPTY
88433: LIST
88434: LIST
88435: PUSH
88436: LD_INT 0
88438: PUSH
88439: LD_INT 2
88441: PUSH
88442: EMPTY
88443: LIST
88444: LIST
88445: PUSH
88446: LD_INT 1
88448: NEG
88449: PUSH
88450: LD_INT 1
88452: PUSH
88453: EMPTY
88454: LIST
88455: LIST
88456: PUSH
88457: LD_INT 2
88459: NEG
88460: PUSH
88461: LD_INT 0
88463: PUSH
88464: EMPTY
88465: LIST
88466: LIST
88467: PUSH
88468: LD_INT 2
88470: NEG
88471: PUSH
88472: LD_INT 1
88474: NEG
88475: PUSH
88476: EMPTY
88477: LIST
88478: LIST
88479: PUSH
88480: LD_INT 2
88482: NEG
88483: PUSH
88484: LD_INT 2
88486: NEG
88487: PUSH
88488: EMPTY
88489: LIST
88490: LIST
88491: PUSH
88492: EMPTY
88493: LIST
88494: LIST
88495: LIST
88496: LIST
88497: LIST
88498: LIST
88499: LIST
88500: LIST
88501: LIST
88502: LIST
88503: LIST
88504: LIST
88505: LIST
88506: LIST
88507: LIST
88508: LIST
88509: LIST
88510: LIST
88511: LIST
88512: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88513: LD_ADDR_VAR 0 55
88517: PUSH
88518: LD_INT 0
88520: PUSH
88521: LD_INT 0
88523: PUSH
88524: EMPTY
88525: LIST
88526: LIST
88527: PUSH
88528: LD_INT 0
88530: PUSH
88531: LD_INT 1
88533: NEG
88534: PUSH
88535: EMPTY
88536: LIST
88537: LIST
88538: PUSH
88539: LD_INT 1
88541: PUSH
88542: LD_INT 0
88544: PUSH
88545: EMPTY
88546: LIST
88547: LIST
88548: PUSH
88549: LD_INT 1
88551: PUSH
88552: LD_INT 1
88554: PUSH
88555: EMPTY
88556: LIST
88557: LIST
88558: PUSH
88559: LD_INT 0
88561: PUSH
88562: LD_INT 1
88564: PUSH
88565: EMPTY
88566: LIST
88567: LIST
88568: PUSH
88569: LD_INT 1
88571: NEG
88572: PUSH
88573: LD_INT 0
88575: PUSH
88576: EMPTY
88577: LIST
88578: LIST
88579: PUSH
88580: LD_INT 1
88582: NEG
88583: PUSH
88584: LD_INT 1
88586: NEG
88587: PUSH
88588: EMPTY
88589: LIST
88590: LIST
88591: PUSH
88592: LD_INT 1
88594: NEG
88595: PUSH
88596: LD_INT 2
88598: NEG
88599: PUSH
88600: EMPTY
88601: LIST
88602: LIST
88603: PUSH
88604: LD_INT 0
88606: PUSH
88607: LD_INT 2
88609: NEG
88610: PUSH
88611: EMPTY
88612: LIST
88613: LIST
88614: PUSH
88615: LD_INT 1
88617: PUSH
88618: LD_INT 1
88620: NEG
88621: PUSH
88622: EMPTY
88623: LIST
88624: LIST
88625: PUSH
88626: LD_INT 2
88628: PUSH
88629: LD_INT 0
88631: PUSH
88632: EMPTY
88633: LIST
88634: LIST
88635: PUSH
88636: LD_INT 2
88638: PUSH
88639: LD_INT 1
88641: PUSH
88642: EMPTY
88643: LIST
88644: LIST
88645: PUSH
88646: LD_INT 2
88648: PUSH
88649: LD_INT 2
88651: PUSH
88652: EMPTY
88653: LIST
88654: LIST
88655: PUSH
88656: LD_INT 1
88658: PUSH
88659: LD_INT 2
88661: PUSH
88662: EMPTY
88663: LIST
88664: LIST
88665: PUSH
88666: LD_INT 0
88668: PUSH
88669: LD_INT 2
88671: PUSH
88672: EMPTY
88673: LIST
88674: LIST
88675: PUSH
88676: LD_INT 1
88678: NEG
88679: PUSH
88680: LD_INT 1
88682: PUSH
88683: EMPTY
88684: LIST
88685: LIST
88686: PUSH
88687: LD_INT 2
88689: NEG
88690: PUSH
88691: LD_INT 0
88693: PUSH
88694: EMPTY
88695: LIST
88696: LIST
88697: PUSH
88698: LD_INT 2
88700: NEG
88701: PUSH
88702: LD_INT 1
88704: NEG
88705: PUSH
88706: EMPTY
88707: LIST
88708: LIST
88709: PUSH
88710: LD_INT 2
88712: NEG
88713: PUSH
88714: LD_INT 2
88716: NEG
88717: PUSH
88718: EMPTY
88719: LIST
88720: LIST
88721: PUSH
88722: EMPTY
88723: LIST
88724: LIST
88725: LIST
88726: LIST
88727: LIST
88728: LIST
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: LIST
88734: LIST
88735: LIST
88736: LIST
88737: LIST
88738: LIST
88739: LIST
88740: LIST
88741: LIST
88742: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88743: LD_ADDR_VAR 0 56
88747: PUSH
88748: LD_INT 0
88750: PUSH
88751: LD_INT 0
88753: PUSH
88754: EMPTY
88755: LIST
88756: LIST
88757: PUSH
88758: LD_INT 0
88760: PUSH
88761: LD_INT 1
88763: NEG
88764: PUSH
88765: EMPTY
88766: LIST
88767: LIST
88768: PUSH
88769: LD_INT 1
88771: PUSH
88772: LD_INT 0
88774: PUSH
88775: EMPTY
88776: LIST
88777: LIST
88778: PUSH
88779: LD_INT 1
88781: PUSH
88782: LD_INT 1
88784: PUSH
88785: EMPTY
88786: LIST
88787: LIST
88788: PUSH
88789: LD_INT 0
88791: PUSH
88792: LD_INT 1
88794: PUSH
88795: EMPTY
88796: LIST
88797: LIST
88798: PUSH
88799: LD_INT 1
88801: NEG
88802: PUSH
88803: LD_INT 0
88805: PUSH
88806: EMPTY
88807: LIST
88808: LIST
88809: PUSH
88810: LD_INT 1
88812: NEG
88813: PUSH
88814: LD_INT 1
88816: NEG
88817: PUSH
88818: EMPTY
88819: LIST
88820: LIST
88821: PUSH
88822: LD_INT 1
88824: NEG
88825: PUSH
88826: LD_INT 2
88828: NEG
88829: PUSH
88830: EMPTY
88831: LIST
88832: LIST
88833: PUSH
88834: LD_INT 0
88836: PUSH
88837: LD_INT 2
88839: NEG
88840: PUSH
88841: EMPTY
88842: LIST
88843: LIST
88844: PUSH
88845: LD_INT 1
88847: PUSH
88848: LD_INT 1
88850: NEG
88851: PUSH
88852: EMPTY
88853: LIST
88854: LIST
88855: PUSH
88856: LD_INT 2
88858: PUSH
88859: LD_INT 0
88861: PUSH
88862: EMPTY
88863: LIST
88864: LIST
88865: PUSH
88866: LD_INT 2
88868: PUSH
88869: LD_INT 1
88871: PUSH
88872: EMPTY
88873: LIST
88874: LIST
88875: PUSH
88876: LD_INT 2
88878: PUSH
88879: LD_INT 2
88881: PUSH
88882: EMPTY
88883: LIST
88884: LIST
88885: PUSH
88886: LD_INT 1
88888: PUSH
88889: LD_INT 2
88891: PUSH
88892: EMPTY
88893: LIST
88894: LIST
88895: PUSH
88896: LD_INT 0
88898: PUSH
88899: LD_INT 2
88901: PUSH
88902: EMPTY
88903: LIST
88904: LIST
88905: PUSH
88906: LD_INT 1
88908: NEG
88909: PUSH
88910: LD_INT 1
88912: PUSH
88913: EMPTY
88914: LIST
88915: LIST
88916: PUSH
88917: LD_INT 2
88919: NEG
88920: PUSH
88921: LD_INT 0
88923: PUSH
88924: EMPTY
88925: LIST
88926: LIST
88927: PUSH
88928: LD_INT 2
88930: NEG
88931: PUSH
88932: LD_INT 1
88934: NEG
88935: PUSH
88936: EMPTY
88937: LIST
88938: LIST
88939: PUSH
88940: LD_INT 2
88942: NEG
88943: PUSH
88944: LD_INT 2
88946: NEG
88947: PUSH
88948: EMPTY
88949: LIST
88950: LIST
88951: PUSH
88952: EMPTY
88953: LIST
88954: LIST
88955: LIST
88956: LIST
88957: LIST
88958: LIST
88959: LIST
88960: LIST
88961: LIST
88962: LIST
88963: LIST
88964: LIST
88965: LIST
88966: LIST
88967: LIST
88968: LIST
88969: LIST
88970: LIST
88971: LIST
88972: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88973: LD_ADDR_VAR 0 57
88977: PUSH
88978: LD_INT 0
88980: PUSH
88981: LD_INT 0
88983: PUSH
88984: EMPTY
88985: LIST
88986: LIST
88987: PUSH
88988: LD_INT 0
88990: PUSH
88991: LD_INT 1
88993: NEG
88994: PUSH
88995: EMPTY
88996: LIST
88997: LIST
88998: PUSH
88999: LD_INT 1
89001: PUSH
89002: LD_INT 0
89004: PUSH
89005: EMPTY
89006: LIST
89007: LIST
89008: PUSH
89009: LD_INT 1
89011: PUSH
89012: LD_INT 1
89014: PUSH
89015: EMPTY
89016: LIST
89017: LIST
89018: PUSH
89019: LD_INT 0
89021: PUSH
89022: LD_INT 1
89024: PUSH
89025: EMPTY
89026: LIST
89027: LIST
89028: PUSH
89029: LD_INT 1
89031: NEG
89032: PUSH
89033: LD_INT 0
89035: PUSH
89036: EMPTY
89037: LIST
89038: LIST
89039: PUSH
89040: LD_INT 1
89042: NEG
89043: PUSH
89044: LD_INT 1
89046: NEG
89047: PUSH
89048: EMPTY
89049: LIST
89050: LIST
89051: PUSH
89052: LD_INT 1
89054: NEG
89055: PUSH
89056: LD_INT 2
89058: NEG
89059: PUSH
89060: EMPTY
89061: LIST
89062: LIST
89063: PUSH
89064: LD_INT 0
89066: PUSH
89067: LD_INT 2
89069: NEG
89070: PUSH
89071: EMPTY
89072: LIST
89073: LIST
89074: PUSH
89075: LD_INT 1
89077: PUSH
89078: LD_INT 1
89080: NEG
89081: PUSH
89082: EMPTY
89083: LIST
89084: LIST
89085: PUSH
89086: LD_INT 2
89088: PUSH
89089: LD_INT 0
89091: PUSH
89092: EMPTY
89093: LIST
89094: LIST
89095: PUSH
89096: LD_INT 2
89098: PUSH
89099: LD_INT 1
89101: PUSH
89102: EMPTY
89103: LIST
89104: LIST
89105: PUSH
89106: LD_INT 2
89108: PUSH
89109: LD_INT 2
89111: PUSH
89112: EMPTY
89113: LIST
89114: LIST
89115: PUSH
89116: LD_INT 1
89118: PUSH
89119: LD_INT 2
89121: PUSH
89122: EMPTY
89123: LIST
89124: LIST
89125: PUSH
89126: LD_INT 0
89128: PUSH
89129: LD_INT 2
89131: PUSH
89132: EMPTY
89133: LIST
89134: LIST
89135: PUSH
89136: LD_INT 1
89138: NEG
89139: PUSH
89140: LD_INT 1
89142: PUSH
89143: EMPTY
89144: LIST
89145: LIST
89146: PUSH
89147: LD_INT 2
89149: NEG
89150: PUSH
89151: LD_INT 0
89153: PUSH
89154: EMPTY
89155: LIST
89156: LIST
89157: PUSH
89158: LD_INT 2
89160: NEG
89161: PUSH
89162: LD_INT 1
89164: NEG
89165: PUSH
89166: EMPTY
89167: LIST
89168: LIST
89169: PUSH
89170: LD_INT 2
89172: NEG
89173: PUSH
89174: LD_INT 2
89176: NEG
89177: PUSH
89178: EMPTY
89179: LIST
89180: LIST
89181: PUSH
89182: EMPTY
89183: LIST
89184: LIST
89185: LIST
89186: LIST
89187: LIST
89188: LIST
89189: LIST
89190: LIST
89191: LIST
89192: LIST
89193: LIST
89194: LIST
89195: LIST
89196: LIST
89197: LIST
89198: LIST
89199: LIST
89200: LIST
89201: LIST
89202: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89203: LD_ADDR_VAR 0 58
89207: PUSH
89208: LD_INT 0
89210: PUSH
89211: LD_INT 0
89213: PUSH
89214: EMPTY
89215: LIST
89216: LIST
89217: PUSH
89218: LD_INT 0
89220: PUSH
89221: LD_INT 1
89223: NEG
89224: PUSH
89225: EMPTY
89226: LIST
89227: LIST
89228: PUSH
89229: LD_INT 1
89231: PUSH
89232: LD_INT 0
89234: PUSH
89235: EMPTY
89236: LIST
89237: LIST
89238: PUSH
89239: LD_INT 1
89241: PUSH
89242: LD_INT 1
89244: PUSH
89245: EMPTY
89246: LIST
89247: LIST
89248: PUSH
89249: LD_INT 0
89251: PUSH
89252: LD_INT 1
89254: PUSH
89255: EMPTY
89256: LIST
89257: LIST
89258: PUSH
89259: LD_INT 1
89261: NEG
89262: PUSH
89263: LD_INT 0
89265: PUSH
89266: EMPTY
89267: LIST
89268: LIST
89269: PUSH
89270: LD_INT 1
89272: NEG
89273: PUSH
89274: LD_INT 1
89276: NEG
89277: PUSH
89278: EMPTY
89279: LIST
89280: LIST
89281: PUSH
89282: LD_INT 1
89284: NEG
89285: PUSH
89286: LD_INT 2
89288: NEG
89289: PUSH
89290: EMPTY
89291: LIST
89292: LIST
89293: PUSH
89294: LD_INT 0
89296: PUSH
89297: LD_INT 2
89299: NEG
89300: PUSH
89301: EMPTY
89302: LIST
89303: LIST
89304: PUSH
89305: LD_INT 1
89307: PUSH
89308: LD_INT 1
89310: NEG
89311: PUSH
89312: EMPTY
89313: LIST
89314: LIST
89315: PUSH
89316: LD_INT 2
89318: PUSH
89319: LD_INT 0
89321: PUSH
89322: EMPTY
89323: LIST
89324: LIST
89325: PUSH
89326: LD_INT 2
89328: PUSH
89329: LD_INT 1
89331: PUSH
89332: EMPTY
89333: LIST
89334: LIST
89335: PUSH
89336: LD_INT 2
89338: PUSH
89339: LD_INT 2
89341: PUSH
89342: EMPTY
89343: LIST
89344: LIST
89345: PUSH
89346: LD_INT 1
89348: PUSH
89349: LD_INT 2
89351: PUSH
89352: EMPTY
89353: LIST
89354: LIST
89355: PUSH
89356: LD_INT 0
89358: PUSH
89359: LD_INT 2
89361: PUSH
89362: EMPTY
89363: LIST
89364: LIST
89365: PUSH
89366: LD_INT 1
89368: NEG
89369: PUSH
89370: LD_INT 1
89372: PUSH
89373: EMPTY
89374: LIST
89375: LIST
89376: PUSH
89377: LD_INT 2
89379: NEG
89380: PUSH
89381: LD_INT 0
89383: PUSH
89384: EMPTY
89385: LIST
89386: LIST
89387: PUSH
89388: LD_INT 2
89390: NEG
89391: PUSH
89392: LD_INT 1
89394: NEG
89395: PUSH
89396: EMPTY
89397: LIST
89398: LIST
89399: PUSH
89400: LD_INT 2
89402: NEG
89403: PUSH
89404: LD_INT 2
89406: NEG
89407: PUSH
89408: EMPTY
89409: LIST
89410: LIST
89411: PUSH
89412: EMPTY
89413: LIST
89414: LIST
89415: LIST
89416: LIST
89417: LIST
89418: LIST
89419: LIST
89420: LIST
89421: LIST
89422: LIST
89423: LIST
89424: LIST
89425: LIST
89426: LIST
89427: LIST
89428: LIST
89429: LIST
89430: LIST
89431: LIST
89432: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89433: LD_ADDR_VAR 0 59
89437: PUSH
89438: LD_INT 0
89440: PUSH
89441: LD_INT 0
89443: PUSH
89444: EMPTY
89445: LIST
89446: LIST
89447: PUSH
89448: LD_INT 0
89450: PUSH
89451: LD_INT 1
89453: NEG
89454: PUSH
89455: EMPTY
89456: LIST
89457: LIST
89458: PUSH
89459: LD_INT 1
89461: PUSH
89462: LD_INT 0
89464: PUSH
89465: EMPTY
89466: LIST
89467: LIST
89468: PUSH
89469: LD_INT 1
89471: PUSH
89472: LD_INT 1
89474: PUSH
89475: EMPTY
89476: LIST
89477: LIST
89478: PUSH
89479: LD_INT 0
89481: PUSH
89482: LD_INT 1
89484: PUSH
89485: EMPTY
89486: LIST
89487: LIST
89488: PUSH
89489: LD_INT 1
89491: NEG
89492: PUSH
89493: LD_INT 0
89495: PUSH
89496: EMPTY
89497: LIST
89498: LIST
89499: PUSH
89500: LD_INT 1
89502: NEG
89503: PUSH
89504: LD_INT 1
89506: NEG
89507: PUSH
89508: EMPTY
89509: LIST
89510: LIST
89511: PUSH
89512: EMPTY
89513: LIST
89514: LIST
89515: LIST
89516: LIST
89517: LIST
89518: LIST
89519: LIST
89520: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89521: LD_ADDR_VAR 0 60
89525: PUSH
89526: LD_INT 0
89528: PUSH
89529: LD_INT 0
89531: PUSH
89532: EMPTY
89533: LIST
89534: LIST
89535: PUSH
89536: LD_INT 0
89538: PUSH
89539: LD_INT 1
89541: NEG
89542: PUSH
89543: EMPTY
89544: LIST
89545: LIST
89546: PUSH
89547: LD_INT 1
89549: PUSH
89550: LD_INT 0
89552: PUSH
89553: EMPTY
89554: LIST
89555: LIST
89556: PUSH
89557: LD_INT 1
89559: PUSH
89560: LD_INT 1
89562: PUSH
89563: EMPTY
89564: LIST
89565: LIST
89566: PUSH
89567: LD_INT 0
89569: PUSH
89570: LD_INT 1
89572: PUSH
89573: EMPTY
89574: LIST
89575: LIST
89576: PUSH
89577: LD_INT 1
89579: NEG
89580: PUSH
89581: LD_INT 0
89583: PUSH
89584: EMPTY
89585: LIST
89586: LIST
89587: PUSH
89588: LD_INT 1
89590: NEG
89591: PUSH
89592: LD_INT 1
89594: NEG
89595: PUSH
89596: EMPTY
89597: LIST
89598: LIST
89599: PUSH
89600: EMPTY
89601: LIST
89602: LIST
89603: LIST
89604: LIST
89605: LIST
89606: LIST
89607: LIST
89608: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89609: LD_ADDR_VAR 0 61
89613: PUSH
89614: LD_INT 0
89616: PUSH
89617: LD_INT 0
89619: PUSH
89620: EMPTY
89621: LIST
89622: LIST
89623: PUSH
89624: LD_INT 0
89626: PUSH
89627: LD_INT 1
89629: NEG
89630: PUSH
89631: EMPTY
89632: LIST
89633: LIST
89634: PUSH
89635: LD_INT 1
89637: PUSH
89638: LD_INT 0
89640: PUSH
89641: EMPTY
89642: LIST
89643: LIST
89644: PUSH
89645: LD_INT 1
89647: PUSH
89648: LD_INT 1
89650: PUSH
89651: EMPTY
89652: LIST
89653: LIST
89654: PUSH
89655: LD_INT 0
89657: PUSH
89658: LD_INT 1
89660: PUSH
89661: EMPTY
89662: LIST
89663: LIST
89664: PUSH
89665: LD_INT 1
89667: NEG
89668: PUSH
89669: LD_INT 0
89671: PUSH
89672: EMPTY
89673: LIST
89674: LIST
89675: PUSH
89676: LD_INT 1
89678: NEG
89679: PUSH
89680: LD_INT 1
89682: NEG
89683: PUSH
89684: EMPTY
89685: LIST
89686: LIST
89687: PUSH
89688: EMPTY
89689: LIST
89690: LIST
89691: LIST
89692: LIST
89693: LIST
89694: LIST
89695: LIST
89696: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89697: LD_ADDR_VAR 0 62
89701: PUSH
89702: LD_INT 0
89704: PUSH
89705: LD_INT 0
89707: PUSH
89708: EMPTY
89709: LIST
89710: LIST
89711: PUSH
89712: LD_INT 0
89714: PUSH
89715: LD_INT 1
89717: NEG
89718: PUSH
89719: EMPTY
89720: LIST
89721: LIST
89722: PUSH
89723: LD_INT 1
89725: PUSH
89726: LD_INT 0
89728: PUSH
89729: EMPTY
89730: LIST
89731: LIST
89732: PUSH
89733: LD_INT 1
89735: PUSH
89736: LD_INT 1
89738: PUSH
89739: EMPTY
89740: LIST
89741: LIST
89742: PUSH
89743: LD_INT 0
89745: PUSH
89746: LD_INT 1
89748: PUSH
89749: EMPTY
89750: LIST
89751: LIST
89752: PUSH
89753: LD_INT 1
89755: NEG
89756: PUSH
89757: LD_INT 0
89759: PUSH
89760: EMPTY
89761: LIST
89762: LIST
89763: PUSH
89764: LD_INT 1
89766: NEG
89767: PUSH
89768: LD_INT 1
89770: NEG
89771: PUSH
89772: EMPTY
89773: LIST
89774: LIST
89775: PUSH
89776: EMPTY
89777: LIST
89778: LIST
89779: LIST
89780: LIST
89781: LIST
89782: LIST
89783: LIST
89784: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89785: LD_ADDR_VAR 0 63
89789: PUSH
89790: LD_INT 0
89792: PUSH
89793: LD_INT 0
89795: PUSH
89796: EMPTY
89797: LIST
89798: LIST
89799: PUSH
89800: LD_INT 0
89802: PUSH
89803: LD_INT 1
89805: NEG
89806: PUSH
89807: EMPTY
89808: LIST
89809: LIST
89810: PUSH
89811: LD_INT 1
89813: PUSH
89814: LD_INT 0
89816: PUSH
89817: EMPTY
89818: LIST
89819: LIST
89820: PUSH
89821: LD_INT 1
89823: PUSH
89824: LD_INT 1
89826: PUSH
89827: EMPTY
89828: LIST
89829: LIST
89830: PUSH
89831: LD_INT 0
89833: PUSH
89834: LD_INT 1
89836: PUSH
89837: EMPTY
89838: LIST
89839: LIST
89840: PUSH
89841: LD_INT 1
89843: NEG
89844: PUSH
89845: LD_INT 0
89847: PUSH
89848: EMPTY
89849: LIST
89850: LIST
89851: PUSH
89852: LD_INT 1
89854: NEG
89855: PUSH
89856: LD_INT 1
89858: NEG
89859: PUSH
89860: EMPTY
89861: LIST
89862: LIST
89863: PUSH
89864: EMPTY
89865: LIST
89866: LIST
89867: LIST
89868: LIST
89869: LIST
89870: LIST
89871: LIST
89872: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89873: LD_ADDR_VAR 0 64
89877: PUSH
89878: LD_INT 0
89880: PUSH
89881: LD_INT 0
89883: PUSH
89884: EMPTY
89885: LIST
89886: LIST
89887: PUSH
89888: LD_INT 0
89890: PUSH
89891: LD_INT 1
89893: NEG
89894: PUSH
89895: EMPTY
89896: LIST
89897: LIST
89898: PUSH
89899: LD_INT 1
89901: PUSH
89902: LD_INT 0
89904: PUSH
89905: EMPTY
89906: LIST
89907: LIST
89908: PUSH
89909: LD_INT 1
89911: PUSH
89912: LD_INT 1
89914: PUSH
89915: EMPTY
89916: LIST
89917: LIST
89918: PUSH
89919: LD_INT 0
89921: PUSH
89922: LD_INT 1
89924: PUSH
89925: EMPTY
89926: LIST
89927: LIST
89928: PUSH
89929: LD_INT 1
89931: NEG
89932: PUSH
89933: LD_INT 0
89935: PUSH
89936: EMPTY
89937: LIST
89938: LIST
89939: PUSH
89940: LD_INT 1
89942: NEG
89943: PUSH
89944: LD_INT 1
89946: NEG
89947: PUSH
89948: EMPTY
89949: LIST
89950: LIST
89951: PUSH
89952: EMPTY
89953: LIST
89954: LIST
89955: LIST
89956: LIST
89957: LIST
89958: LIST
89959: LIST
89960: ST_TO_ADDR
// end ; 1 :
89961: GO 95858
89963: LD_INT 1
89965: DOUBLE
89966: EQUAL
89967: IFTRUE 89971
89969: GO 92594
89971: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89972: LD_ADDR_VAR 0 11
89976: PUSH
89977: LD_INT 1
89979: NEG
89980: PUSH
89981: LD_INT 3
89983: NEG
89984: PUSH
89985: EMPTY
89986: LIST
89987: LIST
89988: PUSH
89989: LD_INT 0
89991: PUSH
89992: LD_INT 3
89994: NEG
89995: PUSH
89996: EMPTY
89997: LIST
89998: LIST
89999: PUSH
90000: LD_INT 1
90002: PUSH
90003: LD_INT 2
90005: NEG
90006: PUSH
90007: EMPTY
90008: LIST
90009: LIST
90010: PUSH
90011: EMPTY
90012: LIST
90013: LIST
90014: LIST
90015: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90016: LD_ADDR_VAR 0 12
90020: PUSH
90021: LD_INT 2
90023: PUSH
90024: LD_INT 1
90026: NEG
90027: PUSH
90028: EMPTY
90029: LIST
90030: LIST
90031: PUSH
90032: LD_INT 3
90034: PUSH
90035: LD_INT 0
90037: PUSH
90038: EMPTY
90039: LIST
90040: LIST
90041: PUSH
90042: LD_INT 3
90044: PUSH
90045: LD_INT 1
90047: PUSH
90048: EMPTY
90049: LIST
90050: LIST
90051: PUSH
90052: EMPTY
90053: LIST
90054: LIST
90055: LIST
90056: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90057: LD_ADDR_VAR 0 13
90061: PUSH
90062: LD_INT 3
90064: PUSH
90065: LD_INT 2
90067: PUSH
90068: EMPTY
90069: LIST
90070: LIST
90071: PUSH
90072: LD_INT 3
90074: PUSH
90075: LD_INT 3
90077: PUSH
90078: EMPTY
90079: LIST
90080: LIST
90081: PUSH
90082: LD_INT 2
90084: PUSH
90085: LD_INT 3
90087: PUSH
90088: EMPTY
90089: LIST
90090: LIST
90091: PUSH
90092: EMPTY
90093: LIST
90094: LIST
90095: LIST
90096: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90097: LD_ADDR_VAR 0 14
90101: PUSH
90102: LD_INT 1
90104: PUSH
90105: LD_INT 3
90107: PUSH
90108: EMPTY
90109: LIST
90110: LIST
90111: PUSH
90112: LD_INT 0
90114: PUSH
90115: LD_INT 3
90117: PUSH
90118: EMPTY
90119: LIST
90120: LIST
90121: PUSH
90122: LD_INT 1
90124: NEG
90125: PUSH
90126: LD_INT 2
90128: PUSH
90129: EMPTY
90130: LIST
90131: LIST
90132: PUSH
90133: EMPTY
90134: LIST
90135: LIST
90136: LIST
90137: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90138: LD_ADDR_VAR 0 15
90142: PUSH
90143: LD_INT 2
90145: NEG
90146: PUSH
90147: LD_INT 1
90149: PUSH
90150: EMPTY
90151: LIST
90152: LIST
90153: PUSH
90154: LD_INT 3
90156: NEG
90157: PUSH
90158: LD_INT 0
90160: PUSH
90161: EMPTY
90162: LIST
90163: LIST
90164: PUSH
90165: LD_INT 3
90167: NEG
90168: PUSH
90169: LD_INT 1
90171: NEG
90172: PUSH
90173: EMPTY
90174: LIST
90175: LIST
90176: PUSH
90177: EMPTY
90178: LIST
90179: LIST
90180: LIST
90181: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90182: LD_ADDR_VAR 0 16
90186: PUSH
90187: LD_INT 2
90189: NEG
90190: PUSH
90191: LD_INT 3
90193: NEG
90194: PUSH
90195: EMPTY
90196: LIST
90197: LIST
90198: PUSH
90199: LD_INT 3
90201: NEG
90202: PUSH
90203: LD_INT 2
90205: NEG
90206: PUSH
90207: EMPTY
90208: LIST
90209: LIST
90210: PUSH
90211: LD_INT 3
90213: NEG
90214: PUSH
90215: LD_INT 3
90217: NEG
90218: PUSH
90219: EMPTY
90220: LIST
90221: LIST
90222: PUSH
90223: EMPTY
90224: LIST
90225: LIST
90226: LIST
90227: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90228: LD_ADDR_VAR 0 17
90232: PUSH
90233: LD_INT 1
90235: NEG
90236: PUSH
90237: LD_INT 3
90239: NEG
90240: PUSH
90241: EMPTY
90242: LIST
90243: LIST
90244: PUSH
90245: LD_INT 0
90247: PUSH
90248: LD_INT 3
90250: NEG
90251: PUSH
90252: EMPTY
90253: LIST
90254: LIST
90255: PUSH
90256: LD_INT 1
90258: PUSH
90259: LD_INT 2
90261: NEG
90262: PUSH
90263: EMPTY
90264: LIST
90265: LIST
90266: PUSH
90267: EMPTY
90268: LIST
90269: LIST
90270: LIST
90271: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90272: LD_ADDR_VAR 0 18
90276: PUSH
90277: LD_INT 2
90279: PUSH
90280: LD_INT 1
90282: NEG
90283: PUSH
90284: EMPTY
90285: LIST
90286: LIST
90287: PUSH
90288: LD_INT 3
90290: PUSH
90291: LD_INT 0
90293: PUSH
90294: EMPTY
90295: LIST
90296: LIST
90297: PUSH
90298: LD_INT 3
90300: PUSH
90301: LD_INT 1
90303: PUSH
90304: EMPTY
90305: LIST
90306: LIST
90307: PUSH
90308: EMPTY
90309: LIST
90310: LIST
90311: LIST
90312: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90313: LD_ADDR_VAR 0 19
90317: PUSH
90318: LD_INT 3
90320: PUSH
90321: LD_INT 2
90323: PUSH
90324: EMPTY
90325: LIST
90326: LIST
90327: PUSH
90328: LD_INT 3
90330: PUSH
90331: LD_INT 3
90333: PUSH
90334: EMPTY
90335: LIST
90336: LIST
90337: PUSH
90338: LD_INT 2
90340: PUSH
90341: LD_INT 3
90343: PUSH
90344: EMPTY
90345: LIST
90346: LIST
90347: PUSH
90348: EMPTY
90349: LIST
90350: LIST
90351: LIST
90352: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90353: LD_ADDR_VAR 0 20
90357: PUSH
90358: LD_INT 1
90360: PUSH
90361: LD_INT 3
90363: PUSH
90364: EMPTY
90365: LIST
90366: LIST
90367: PUSH
90368: LD_INT 0
90370: PUSH
90371: LD_INT 3
90373: PUSH
90374: EMPTY
90375: LIST
90376: LIST
90377: PUSH
90378: LD_INT 1
90380: NEG
90381: PUSH
90382: LD_INT 2
90384: PUSH
90385: EMPTY
90386: LIST
90387: LIST
90388: PUSH
90389: EMPTY
90390: LIST
90391: LIST
90392: LIST
90393: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90394: LD_ADDR_VAR 0 21
90398: PUSH
90399: LD_INT 2
90401: NEG
90402: PUSH
90403: LD_INT 1
90405: PUSH
90406: EMPTY
90407: LIST
90408: LIST
90409: PUSH
90410: LD_INT 3
90412: NEG
90413: PUSH
90414: LD_INT 0
90416: PUSH
90417: EMPTY
90418: LIST
90419: LIST
90420: PUSH
90421: LD_INT 3
90423: NEG
90424: PUSH
90425: LD_INT 1
90427: NEG
90428: PUSH
90429: EMPTY
90430: LIST
90431: LIST
90432: PUSH
90433: EMPTY
90434: LIST
90435: LIST
90436: LIST
90437: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90438: LD_ADDR_VAR 0 22
90442: PUSH
90443: LD_INT 2
90445: NEG
90446: PUSH
90447: LD_INT 3
90449: NEG
90450: PUSH
90451: EMPTY
90452: LIST
90453: LIST
90454: PUSH
90455: LD_INT 3
90457: NEG
90458: PUSH
90459: LD_INT 2
90461: NEG
90462: PUSH
90463: EMPTY
90464: LIST
90465: LIST
90466: PUSH
90467: LD_INT 3
90469: NEG
90470: PUSH
90471: LD_INT 3
90473: NEG
90474: PUSH
90475: EMPTY
90476: LIST
90477: LIST
90478: PUSH
90479: EMPTY
90480: LIST
90481: LIST
90482: LIST
90483: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
90484: LD_ADDR_VAR 0 23
90488: PUSH
90489: LD_INT 0
90491: PUSH
90492: LD_INT 3
90494: NEG
90495: PUSH
90496: EMPTY
90497: LIST
90498: LIST
90499: PUSH
90500: LD_INT 1
90502: NEG
90503: PUSH
90504: LD_INT 4
90506: NEG
90507: PUSH
90508: EMPTY
90509: LIST
90510: LIST
90511: PUSH
90512: LD_INT 1
90514: PUSH
90515: LD_INT 3
90517: NEG
90518: PUSH
90519: EMPTY
90520: LIST
90521: LIST
90522: PUSH
90523: EMPTY
90524: LIST
90525: LIST
90526: LIST
90527: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
90528: LD_ADDR_VAR 0 24
90532: PUSH
90533: LD_INT 3
90535: PUSH
90536: LD_INT 0
90538: PUSH
90539: EMPTY
90540: LIST
90541: LIST
90542: PUSH
90543: LD_INT 3
90545: PUSH
90546: LD_INT 1
90548: NEG
90549: PUSH
90550: EMPTY
90551: LIST
90552: LIST
90553: PUSH
90554: LD_INT 4
90556: PUSH
90557: LD_INT 1
90559: PUSH
90560: EMPTY
90561: LIST
90562: LIST
90563: PUSH
90564: EMPTY
90565: LIST
90566: LIST
90567: LIST
90568: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
90569: LD_ADDR_VAR 0 25
90573: PUSH
90574: LD_INT 3
90576: PUSH
90577: LD_INT 3
90579: PUSH
90580: EMPTY
90581: LIST
90582: LIST
90583: PUSH
90584: LD_INT 4
90586: PUSH
90587: LD_INT 3
90589: PUSH
90590: EMPTY
90591: LIST
90592: LIST
90593: PUSH
90594: LD_INT 3
90596: PUSH
90597: LD_INT 4
90599: PUSH
90600: EMPTY
90601: LIST
90602: LIST
90603: PUSH
90604: EMPTY
90605: LIST
90606: LIST
90607: LIST
90608: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
90609: LD_ADDR_VAR 0 26
90613: PUSH
90614: LD_INT 0
90616: PUSH
90617: LD_INT 3
90619: PUSH
90620: EMPTY
90621: LIST
90622: LIST
90623: PUSH
90624: LD_INT 1
90626: PUSH
90627: LD_INT 4
90629: PUSH
90630: EMPTY
90631: LIST
90632: LIST
90633: PUSH
90634: LD_INT 1
90636: NEG
90637: PUSH
90638: LD_INT 3
90640: PUSH
90641: EMPTY
90642: LIST
90643: LIST
90644: PUSH
90645: EMPTY
90646: LIST
90647: LIST
90648: LIST
90649: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
90650: LD_ADDR_VAR 0 27
90654: PUSH
90655: LD_INT 3
90657: NEG
90658: PUSH
90659: LD_INT 0
90661: PUSH
90662: EMPTY
90663: LIST
90664: LIST
90665: PUSH
90666: LD_INT 3
90668: NEG
90669: PUSH
90670: LD_INT 1
90672: PUSH
90673: EMPTY
90674: LIST
90675: LIST
90676: PUSH
90677: LD_INT 4
90679: NEG
90680: PUSH
90681: LD_INT 1
90683: NEG
90684: PUSH
90685: EMPTY
90686: LIST
90687: LIST
90688: PUSH
90689: EMPTY
90690: LIST
90691: LIST
90692: LIST
90693: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
90694: LD_ADDR_VAR 0 28
90698: PUSH
90699: LD_INT 3
90701: NEG
90702: PUSH
90703: LD_INT 3
90705: NEG
90706: PUSH
90707: EMPTY
90708: LIST
90709: LIST
90710: PUSH
90711: LD_INT 3
90713: NEG
90714: PUSH
90715: LD_INT 4
90717: NEG
90718: PUSH
90719: EMPTY
90720: LIST
90721: LIST
90722: PUSH
90723: LD_INT 4
90725: NEG
90726: PUSH
90727: LD_INT 3
90729: NEG
90730: PUSH
90731: EMPTY
90732: LIST
90733: LIST
90734: PUSH
90735: EMPTY
90736: LIST
90737: LIST
90738: LIST
90739: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
90740: LD_ADDR_VAR 0 29
90744: PUSH
90745: LD_INT 1
90747: NEG
90748: PUSH
90749: LD_INT 3
90751: NEG
90752: PUSH
90753: EMPTY
90754: LIST
90755: LIST
90756: PUSH
90757: LD_INT 0
90759: PUSH
90760: LD_INT 3
90762: NEG
90763: PUSH
90764: EMPTY
90765: LIST
90766: LIST
90767: PUSH
90768: LD_INT 1
90770: PUSH
90771: LD_INT 2
90773: NEG
90774: PUSH
90775: EMPTY
90776: LIST
90777: LIST
90778: PUSH
90779: LD_INT 1
90781: NEG
90782: PUSH
90783: LD_INT 4
90785: NEG
90786: PUSH
90787: EMPTY
90788: LIST
90789: LIST
90790: PUSH
90791: LD_INT 0
90793: PUSH
90794: LD_INT 4
90796: NEG
90797: PUSH
90798: EMPTY
90799: LIST
90800: LIST
90801: PUSH
90802: LD_INT 1
90804: PUSH
90805: LD_INT 3
90807: NEG
90808: PUSH
90809: EMPTY
90810: LIST
90811: LIST
90812: PUSH
90813: LD_INT 1
90815: NEG
90816: PUSH
90817: LD_INT 5
90819: NEG
90820: PUSH
90821: EMPTY
90822: LIST
90823: LIST
90824: PUSH
90825: LD_INT 0
90827: PUSH
90828: LD_INT 5
90830: NEG
90831: PUSH
90832: EMPTY
90833: LIST
90834: LIST
90835: PUSH
90836: LD_INT 1
90838: PUSH
90839: LD_INT 4
90841: NEG
90842: PUSH
90843: EMPTY
90844: LIST
90845: LIST
90846: PUSH
90847: LD_INT 1
90849: NEG
90850: PUSH
90851: LD_INT 6
90853: NEG
90854: PUSH
90855: EMPTY
90856: LIST
90857: LIST
90858: PUSH
90859: LD_INT 0
90861: PUSH
90862: LD_INT 6
90864: NEG
90865: PUSH
90866: EMPTY
90867: LIST
90868: LIST
90869: PUSH
90870: LD_INT 1
90872: PUSH
90873: LD_INT 5
90875: NEG
90876: PUSH
90877: EMPTY
90878: LIST
90879: LIST
90880: PUSH
90881: EMPTY
90882: LIST
90883: LIST
90884: LIST
90885: LIST
90886: LIST
90887: LIST
90888: LIST
90889: LIST
90890: LIST
90891: LIST
90892: LIST
90893: LIST
90894: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
90895: LD_ADDR_VAR 0 30
90899: PUSH
90900: LD_INT 2
90902: PUSH
90903: LD_INT 1
90905: NEG
90906: PUSH
90907: EMPTY
90908: LIST
90909: LIST
90910: PUSH
90911: LD_INT 3
90913: PUSH
90914: LD_INT 0
90916: PUSH
90917: EMPTY
90918: LIST
90919: LIST
90920: PUSH
90921: LD_INT 3
90923: PUSH
90924: LD_INT 1
90926: PUSH
90927: EMPTY
90928: LIST
90929: LIST
90930: PUSH
90931: LD_INT 3
90933: PUSH
90934: LD_INT 1
90936: NEG
90937: PUSH
90938: EMPTY
90939: LIST
90940: LIST
90941: PUSH
90942: LD_INT 4
90944: PUSH
90945: LD_INT 0
90947: PUSH
90948: EMPTY
90949: LIST
90950: LIST
90951: PUSH
90952: LD_INT 4
90954: PUSH
90955: LD_INT 1
90957: PUSH
90958: EMPTY
90959: LIST
90960: LIST
90961: PUSH
90962: LD_INT 4
90964: PUSH
90965: LD_INT 1
90967: NEG
90968: PUSH
90969: EMPTY
90970: LIST
90971: LIST
90972: PUSH
90973: LD_INT 5
90975: PUSH
90976: LD_INT 0
90978: PUSH
90979: EMPTY
90980: LIST
90981: LIST
90982: PUSH
90983: LD_INT 5
90985: PUSH
90986: LD_INT 1
90988: PUSH
90989: EMPTY
90990: LIST
90991: LIST
90992: PUSH
90993: LD_INT 5
90995: PUSH
90996: LD_INT 1
90998: NEG
90999: PUSH
91000: EMPTY
91001: LIST
91002: LIST
91003: PUSH
91004: LD_INT 6
91006: PUSH
91007: LD_INT 0
91009: PUSH
91010: EMPTY
91011: LIST
91012: LIST
91013: PUSH
91014: LD_INT 6
91016: PUSH
91017: LD_INT 1
91019: PUSH
91020: EMPTY
91021: LIST
91022: LIST
91023: PUSH
91024: EMPTY
91025: LIST
91026: LIST
91027: LIST
91028: LIST
91029: LIST
91030: LIST
91031: LIST
91032: LIST
91033: LIST
91034: LIST
91035: LIST
91036: LIST
91037: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
91038: LD_ADDR_VAR 0 31
91042: PUSH
91043: LD_INT 3
91045: PUSH
91046: LD_INT 2
91048: PUSH
91049: EMPTY
91050: LIST
91051: LIST
91052: PUSH
91053: LD_INT 3
91055: PUSH
91056: LD_INT 3
91058: PUSH
91059: EMPTY
91060: LIST
91061: LIST
91062: PUSH
91063: LD_INT 2
91065: PUSH
91066: LD_INT 3
91068: PUSH
91069: EMPTY
91070: LIST
91071: LIST
91072: PUSH
91073: LD_INT 4
91075: PUSH
91076: LD_INT 3
91078: PUSH
91079: EMPTY
91080: LIST
91081: LIST
91082: PUSH
91083: LD_INT 4
91085: PUSH
91086: LD_INT 4
91088: PUSH
91089: EMPTY
91090: LIST
91091: LIST
91092: PUSH
91093: LD_INT 3
91095: PUSH
91096: LD_INT 4
91098: PUSH
91099: EMPTY
91100: LIST
91101: LIST
91102: PUSH
91103: LD_INT 5
91105: PUSH
91106: LD_INT 4
91108: PUSH
91109: EMPTY
91110: LIST
91111: LIST
91112: PUSH
91113: LD_INT 5
91115: PUSH
91116: LD_INT 5
91118: PUSH
91119: EMPTY
91120: LIST
91121: LIST
91122: PUSH
91123: LD_INT 4
91125: PUSH
91126: LD_INT 5
91128: PUSH
91129: EMPTY
91130: LIST
91131: LIST
91132: PUSH
91133: LD_INT 6
91135: PUSH
91136: LD_INT 5
91138: PUSH
91139: EMPTY
91140: LIST
91141: LIST
91142: PUSH
91143: LD_INT 6
91145: PUSH
91146: LD_INT 6
91148: PUSH
91149: EMPTY
91150: LIST
91151: LIST
91152: PUSH
91153: LD_INT 5
91155: PUSH
91156: LD_INT 6
91158: PUSH
91159: EMPTY
91160: LIST
91161: LIST
91162: PUSH
91163: EMPTY
91164: LIST
91165: LIST
91166: LIST
91167: LIST
91168: LIST
91169: LIST
91170: LIST
91171: LIST
91172: LIST
91173: LIST
91174: LIST
91175: LIST
91176: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
91177: LD_ADDR_VAR 0 32
91181: PUSH
91182: LD_INT 1
91184: PUSH
91185: LD_INT 3
91187: PUSH
91188: EMPTY
91189: LIST
91190: LIST
91191: PUSH
91192: LD_INT 0
91194: PUSH
91195: LD_INT 3
91197: PUSH
91198: EMPTY
91199: LIST
91200: LIST
91201: PUSH
91202: LD_INT 1
91204: NEG
91205: PUSH
91206: LD_INT 2
91208: PUSH
91209: EMPTY
91210: LIST
91211: LIST
91212: PUSH
91213: LD_INT 1
91215: PUSH
91216: LD_INT 4
91218: PUSH
91219: EMPTY
91220: LIST
91221: LIST
91222: PUSH
91223: LD_INT 0
91225: PUSH
91226: LD_INT 4
91228: PUSH
91229: EMPTY
91230: LIST
91231: LIST
91232: PUSH
91233: LD_INT 1
91235: NEG
91236: PUSH
91237: LD_INT 3
91239: PUSH
91240: EMPTY
91241: LIST
91242: LIST
91243: PUSH
91244: LD_INT 1
91246: PUSH
91247: LD_INT 5
91249: PUSH
91250: EMPTY
91251: LIST
91252: LIST
91253: PUSH
91254: LD_INT 0
91256: PUSH
91257: LD_INT 5
91259: PUSH
91260: EMPTY
91261: LIST
91262: LIST
91263: PUSH
91264: LD_INT 1
91266: NEG
91267: PUSH
91268: LD_INT 4
91270: PUSH
91271: EMPTY
91272: LIST
91273: LIST
91274: PUSH
91275: LD_INT 1
91277: PUSH
91278: LD_INT 6
91280: PUSH
91281: EMPTY
91282: LIST
91283: LIST
91284: PUSH
91285: LD_INT 0
91287: PUSH
91288: LD_INT 6
91290: PUSH
91291: EMPTY
91292: LIST
91293: LIST
91294: PUSH
91295: LD_INT 1
91297: NEG
91298: PUSH
91299: LD_INT 5
91301: PUSH
91302: EMPTY
91303: LIST
91304: LIST
91305: PUSH
91306: EMPTY
91307: LIST
91308: LIST
91309: LIST
91310: LIST
91311: LIST
91312: LIST
91313: LIST
91314: LIST
91315: LIST
91316: LIST
91317: LIST
91318: LIST
91319: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
91320: LD_ADDR_VAR 0 33
91324: PUSH
91325: LD_INT 2
91327: NEG
91328: PUSH
91329: LD_INT 1
91331: PUSH
91332: EMPTY
91333: LIST
91334: LIST
91335: PUSH
91336: LD_INT 3
91338: NEG
91339: PUSH
91340: LD_INT 0
91342: PUSH
91343: EMPTY
91344: LIST
91345: LIST
91346: PUSH
91347: LD_INT 3
91349: NEG
91350: PUSH
91351: LD_INT 1
91353: NEG
91354: PUSH
91355: EMPTY
91356: LIST
91357: LIST
91358: PUSH
91359: LD_INT 3
91361: NEG
91362: PUSH
91363: LD_INT 1
91365: PUSH
91366: EMPTY
91367: LIST
91368: LIST
91369: PUSH
91370: LD_INT 4
91372: NEG
91373: PUSH
91374: LD_INT 0
91376: PUSH
91377: EMPTY
91378: LIST
91379: LIST
91380: PUSH
91381: LD_INT 4
91383: NEG
91384: PUSH
91385: LD_INT 1
91387: NEG
91388: PUSH
91389: EMPTY
91390: LIST
91391: LIST
91392: PUSH
91393: LD_INT 4
91395: NEG
91396: PUSH
91397: LD_INT 1
91399: PUSH
91400: EMPTY
91401: LIST
91402: LIST
91403: PUSH
91404: LD_INT 5
91406: NEG
91407: PUSH
91408: LD_INT 0
91410: PUSH
91411: EMPTY
91412: LIST
91413: LIST
91414: PUSH
91415: LD_INT 5
91417: NEG
91418: PUSH
91419: LD_INT 1
91421: NEG
91422: PUSH
91423: EMPTY
91424: LIST
91425: LIST
91426: PUSH
91427: LD_INT 5
91429: NEG
91430: PUSH
91431: LD_INT 1
91433: PUSH
91434: EMPTY
91435: LIST
91436: LIST
91437: PUSH
91438: LD_INT 6
91440: NEG
91441: PUSH
91442: LD_INT 0
91444: PUSH
91445: EMPTY
91446: LIST
91447: LIST
91448: PUSH
91449: LD_INT 6
91451: NEG
91452: PUSH
91453: LD_INT 1
91455: NEG
91456: PUSH
91457: EMPTY
91458: LIST
91459: LIST
91460: PUSH
91461: EMPTY
91462: LIST
91463: LIST
91464: LIST
91465: LIST
91466: LIST
91467: LIST
91468: LIST
91469: LIST
91470: LIST
91471: LIST
91472: LIST
91473: LIST
91474: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
91475: LD_ADDR_VAR 0 34
91479: PUSH
91480: LD_INT 2
91482: NEG
91483: PUSH
91484: LD_INT 3
91486: NEG
91487: PUSH
91488: EMPTY
91489: LIST
91490: LIST
91491: PUSH
91492: LD_INT 3
91494: NEG
91495: PUSH
91496: LD_INT 2
91498: NEG
91499: PUSH
91500: EMPTY
91501: LIST
91502: LIST
91503: PUSH
91504: LD_INT 3
91506: NEG
91507: PUSH
91508: LD_INT 3
91510: NEG
91511: PUSH
91512: EMPTY
91513: LIST
91514: LIST
91515: PUSH
91516: LD_INT 3
91518: NEG
91519: PUSH
91520: LD_INT 4
91522: NEG
91523: PUSH
91524: EMPTY
91525: LIST
91526: LIST
91527: PUSH
91528: LD_INT 4
91530: NEG
91531: PUSH
91532: LD_INT 3
91534: NEG
91535: PUSH
91536: EMPTY
91537: LIST
91538: LIST
91539: PUSH
91540: LD_INT 4
91542: NEG
91543: PUSH
91544: LD_INT 4
91546: NEG
91547: PUSH
91548: EMPTY
91549: LIST
91550: LIST
91551: PUSH
91552: LD_INT 4
91554: NEG
91555: PUSH
91556: LD_INT 5
91558: NEG
91559: PUSH
91560: EMPTY
91561: LIST
91562: LIST
91563: PUSH
91564: LD_INT 5
91566: NEG
91567: PUSH
91568: LD_INT 4
91570: NEG
91571: PUSH
91572: EMPTY
91573: LIST
91574: LIST
91575: PUSH
91576: LD_INT 5
91578: NEG
91579: PUSH
91580: LD_INT 5
91582: NEG
91583: PUSH
91584: EMPTY
91585: LIST
91586: LIST
91587: PUSH
91588: LD_INT 5
91590: NEG
91591: PUSH
91592: LD_INT 6
91594: NEG
91595: PUSH
91596: EMPTY
91597: LIST
91598: LIST
91599: PUSH
91600: LD_INT 6
91602: NEG
91603: PUSH
91604: LD_INT 5
91606: NEG
91607: PUSH
91608: EMPTY
91609: LIST
91610: LIST
91611: PUSH
91612: LD_INT 6
91614: NEG
91615: PUSH
91616: LD_INT 6
91618: NEG
91619: PUSH
91620: EMPTY
91621: LIST
91622: LIST
91623: PUSH
91624: EMPTY
91625: LIST
91626: LIST
91627: LIST
91628: LIST
91629: LIST
91630: LIST
91631: LIST
91632: LIST
91633: LIST
91634: LIST
91635: LIST
91636: LIST
91637: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
91638: LD_ADDR_VAR 0 41
91642: PUSH
91643: LD_INT 0
91645: PUSH
91646: LD_INT 2
91648: NEG
91649: PUSH
91650: EMPTY
91651: LIST
91652: LIST
91653: PUSH
91654: LD_INT 1
91656: NEG
91657: PUSH
91658: LD_INT 3
91660: NEG
91661: PUSH
91662: EMPTY
91663: LIST
91664: LIST
91665: PUSH
91666: LD_INT 1
91668: PUSH
91669: LD_INT 2
91671: NEG
91672: PUSH
91673: EMPTY
91674: LIST
91675: LIST
91676: PUSH
91677: EMPTY
91678: LIST
91679: LIST
91680: LIST
91681: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
91682: LD_ADDR_VAR 0 42
91686: PUSH
91687: LD_INT 2
91689: PUSH
91690: LD_INT 0
91692: PUSH
91693: EMPTY
91694: LIST
91695: LIST
91696: PUSH
91697: LD_INT 2
91699: PUSH
91700: LD_INT 1
91702: NEG
91703: PUSH
91704: EMPTY
91705: LIST
91706: LIST
91707: PUSH
91708: LD_INT 3
91710: PUSH
91711: LD_INT 1
91713: PUSH
91714: EMPTY
91715: LIST
91716: LIST
91717: PUSH
91718: EMPTY
91719: LIST
91720: LIST
91721: LIST
91722: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
91723: LD_ADDR_VAR 0 43
91727: PUSH
91728: LD_INT 2
91730: PUSH
91731: LD_INT 2
91733: PUSH
91734: EMPTY
91735: LIST
91736: LIST
91737: PUSH
91738: LD_INT 3
91740: PUSH
91741: LD_INT 2
91743: PUSH
91744: EMPTY
91745: LIST
91746: LIST
91747: PUSH
91748: LD_INT 2
91750: PUSH
91751: LD_INT 3
91753: PUSH
91754: EMPTY
91755: LIST
91756: LIST
91757: PUSH
91758: EMPTY
91759: LIST
91760: LIST
91761: LIST
91762: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
91763: LD_ADDR_VAR 0 44
91767: PUSH
91768: LD_INT 0
91770: PUSH
91771: LD_INT 2
91773: PUSH
91774: EMPTY
91775: LIST
91776: LIST
91777: PUSH
91778: LD_INT 1
91780: PUSH
91781: LD_INT 3
91783: PUSH
91784: EMPTY
91785: LIST
91786: LIST
91787: PUSH
91788: LD_INT 1
91790: NEG
91791: PUSH
91792: LD_INT 2
91794: PUSH
91795: EMPTY
91796: LIST
91797: LIST
91798: PUSH
91799: EMPTY
91800: LIST
91801: LIST
91802: LIST
91803: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
91804: LD_ADDR_VAR 0 45
91808: PUSH
91809: LD_INT 2
91811: NEG
91812: PUSH
91813: LD_INT 0
91815: PUSH
91816: EMPTY
91817: LIST
91818: LIST
91819: PUSH
91820: LD_INT 2
91822: NEG
91823: PUSH
91824: LD_INT 1
91826: PUSH
91827: EMPTY
91828: LIST
91829: LIST
91830: PUSH
91831: LD_INT 3
91833: NEG
91834: PUSH
91835: LD_INT 1
91837: NEG
91838: PUSH
91839: EMPTY
91840: LIST
91841: LIST
91842: PUSH
91843: EMPTY
91844: LIST
91845: LIST
91846: LIST
91847: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
91848: LD_ADDR_VAR 0 46
91852: PUSH
91853: LD_INT 2
91855: NEG
91856: PUSH
91857: LD_INT 2
91859: NEG
91860: PUSH
91861: EMPTY
91862: LIST
91863: LIST
91864: PUSH
91865: LD_INT 2
91867: NEG
91868: PUSH
91869: LD_INT 3
91871: NEG
91872: PUSH
91873: EMPTY
91874: LIST
91875: LIST
91876: PUSH
91877: LD_INT 3
91879: NEG
91880: PUSH
91881: LD_INT 2
91883: NEG
91884: PUSH
91885: EMPTY
91886: LIST
91887: LIST
91888: PUSH
91889: EMPTY
91890: LIST
91891: LIST
91892: LIST
91893: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
91894: LD_ADDR_VAR 0 47
91898: PUSH
91899: LD_INT 2
91901: NEG
91902: PUSH
91903: LD_INT 3
91905: NEG
91906: PUSH
91907: EMPTY
91908: LIST
91909: LIST
91910: PUSH
91911: LD_INT 1
91913: NEG
91914: PUSH
91915: LD_INT 3
91917: NEG
91918: PUSH
91919: EMPTY
91920: LIST
91921: LIST
91922: PUSH
91923: EMPTY
91924: LIST
91925: LIST
91926: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
91927: LD_ADDR_VAR 0 48
91931: PUSH
91932: LD_INT 1
91934: PUSH
91935: LD_INT 2
91937: NEG
91938: PUSH
91939: EMPTY
91940: LIST
91941: LIST
91942: PUSH
91943: LD_INT 2
91945: PUSH
91946: LD_INT 1
91948: NEG
91949: PUSH
91950: EMPTY
91951: LIST
91952: LIST
91953: PUSH
91954: EMPTY
91955: LIST
91956: LIST
91957: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
91958: LD_ADDR_VAR 0 49
91962: PUSH
91963: LD_INT 3
91965: PUSH
91966: LD_INT 1
91968: PUSH
91969: EMPTY
91970: LIST
91971: LIST
91972: PUSH
91973: LD_INT 3
91975: PUSH
91976: LD_INT 2
91978: PUSH
91979: EMPTY
91980: LIST
91981: LIST
91982: PUSH
91983: EMPTY
91984: LIST
91985: LIST
91986: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
91987: LD_ADDR_VAR 0 50
91991: PUSH
91992: LD_INT 2
91994: PUSH
91995: LD_INT 3
91997: PUSH
91998: EMPTY
91999: LIST
92000: LIST
92001: PUSH
92002: LD_INT 1
92004: PUSH
92005: LD_INT 3
92007: PUSH
92008: EMPTY
92009: LIST
92010: LIST
92011: PUSH
92012: EMPTY
92013: LIST
92014: LIST
92015: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
92016: LD_ADDR_VAR 0 51
92020: PUSH
92021: LD_INT 1
92023: NEG
92024: PUSH
92025: LD_INT 2
92027: PUSH
92028: EMPTY
92029: LIST
92030: LIST
92031: PUSH
92032: LD_INT 2
92034: NEG
92035: PUSH
92036: LD_INT 1
92038: PUSH
92039: EMPTY
92040: LIST
92041: LIST
92042: PUSH
92043: EMPTY
92044: LIST
92045: LIST
92046: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
92047: LD_ADDR_VAR 0 52
92051: PUSH
92052: LD_INT 3
92054: NEG
92055: PUSH
92056: LD_INT 1
92058: NEG
92059: PUSH
92060: EMPTY
92061: LIST
92062: LIST
92063: PUSH
92064: LD_INT 3
92066: NEG
92067: PUSH
92068: LD_INT 2
92070: NEG
92071: PUSH
92072: EMPTY
92073: LIST
92074: LIST
92075: PUSH
92076: EMPTY
92077: LIST
92078: LIST
92079: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92080: LD_ADDR_VAR 0 53
92084: PUSH
92085: LD_INT 1
92087: NEG
92088: PUSH
92089: LD_INT 3
92091: NEG
92092: PUSH
92093: EMPTY
92094: LIST
92095: LIST
92096: PUSH
92097: LD_INT 0
92099: PUSH
92100: LD_INT 3
92102: NEG
92103: PUSH
92104: EMPTY
92105: LIST
92106: LIST
92107: PUSH
92108: LD_INT 1
92110: PUSH
92111: LD_INT 2
92113: NEG
92114: PUSH
92115: EMPTY
92116: LIST
92117: LIST
92118: PUSH
92119: EMPTY
92120: LIST
92121: LIST
92122: LIST
92123: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92124: LD_ADDR_VAR 0 54
92128: PUSH
92129: LD_INT 2
92131: PUSH
92132: LD_INT 1
92134: NEG
92135: PUSH
92136: EMPTY
92137: LIST
92138: LIST
92139: PUSH
92140: LD_INT 3
92142: PUSH
92143: LD_INT 0
92145: PUSH
92146: EMPTY
92147: LIST
92148: LIST
92149: PUSH
92150: LD_INT 3
92152: PUSH
92153: LD_INT 1
92155: PUSH
92156: EMPTY
92157: LIST
92158: LIST
92159: PUSH
92160: EMPTY
92161: LIST
92162: LIST
92163: LIST
92164: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92165: LD_ADDR_VAR 0 55
92169: PUSH
92170: LD_INT 3
92172: PUSH
92173: LD_INT 2
92175: PUSH
92176: EMPTY
92177: LIST
92178: LIST
92179: PUSH
92180: LD_INT 3
92182: PUSH
92183: LD_INT 3
92185: PUSH
92186: EMPTY
92187: LIST
92188: LIST
92189: PUSH
92190: LD_INT 2
92192: PUSH
92193: LD_INT 3
92195: PUSH
92196: EMPTY
92197: LIST
92198: LIST
92199: PUSH
92200: EMPTY
92201: LIST
92202: LIST
92203: LIST
92204: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92205: LD_ADDR_VAR 0 56
92209: PUSH
92210: LD_INT 1
92212: PUSH
92213: LD_INT 3
92215: PUSH
92216: EMPTY
92217: LIST
92218: LIST
92219: PUSH
92220: LD_INT 0
92222: PUSH
92223: LD_INT 3
92225: PUSH
92226: EMPTY
92227: LIST
92228: LIST
92229: PUSH
92230: LD_INT 1
92232: NEG
92233: PUSH
92234: LD_INT 2
92236: PUSH
92237: EMPTY
92238: LIST
92239: LIST
92240: PUSH
92241: EMPTY
92242: LIST
92243: LIST
92244: LIST
92245: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92246: LD_ADDR_VAR 0 57
92250: PUSH
92251: LD_INT 2
92253: NEG
92254: PUSH
92255: LD_INT 1
92257: PUSH
92258: EMPTY
92259: LIST
92260: LIST
92261: PUSH
92262: LD_INT 3
92264: NEG
92265: PUSH
92266: LD_INT 0
92268: PUSH
92269: EMPTY
92270: LIST
92271: LIST
92272: PUSH
92273: LD_INT 3
92275: NEG
92276: PUSH
92277: LD_INT 1
92279: NEG
92280: PUSH
92281: EMPTY
92282: LIST
92283: LIST
92284: PUSH
92285: EMPTY
92286: LIST
92287: LIST
92288: LIST
92289: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92290: LD_ADDR_VAR 0 58
92294: PUSH
92295: LD_INT 2
92297: NEG
92298: PUSH
92299: LD_INT 3
92301: NEG
92302: PUSH
92303: EMPTY
92304: LIST
92305: LIST
92306: PUSH
92307: LD_INT 3
92309: NEG
92310: PUSH
92311: LD_INT 2
92313: NEG
92314: PUSH
92315: EMPTY
92316: LIST
92317: LIST
92318: PUSH
92319: LD_INT 3
92321: NEG
92322: PUSH
92323: LD_INT 3
92325: NEG
92326: PUSH
92327: EMPTY
92328: LIST
92329: LIST
92330: PUSH
92331: EMPTY
92332: LIST
92333: LIST
92334: LIST
92335: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
92336: LD_ADDR_VAR 0 59
92340: PUSH
92341: LD_INT 1
92343: NEG
92344: PUSH
92345: LD_INT 2
92347: NEG
92348: PUSH
92349: EMPTY
92350: LIST
92351: LIST
92352: PUSH
92353: LD_INT 0
92355: PUSH
92356: LD_INT 2
92358: NEG
92359: PUSH
92360: EMPTY
92361: LIST
92362: LIST
92363: PUSH
92364: LD_INT 1
92366: PUSH
92367: LD_INT 1
92369: NEG
92370: PUSH
92371: EMPTY
92372: LIST
92373: LIST
92374: PUSH
92375: EMPTY
92376: LIST
92377: LIST
92378: LIST
92379: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
92380: LD_ADDR_VAR 0 60
92384: PUSH
92385: LD_INT 1
92387: PUSH
92388: LD_INT 1
92390: NEG
92391: PUSH
92392: EMPTY
92393: LIST
92394: LIST
92395: PUSH
92396: LD_INT 2
92398: PUSH
92399: LD_INT 0
92401: PUSH
92402: EMPTY
92403: LIST
92404: LIST
92405: PUSH
92406: LD_INT 2
92408: PUSH
92409: LD_INT 1
92411: PUSH
92412: EMPTY
92413: LIST
92414: LIST
92415: PUSH
92416: EMPTY
92417: LIST
92418: LIST
92419: LIST
92420: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
92421: LD_ADDR_VAR 0 61
92425: PUSH
92426: LD_INT 2
92428: PUSH
92429: LD_INT 1
92431: PUSH
92432: EMPTY
92433: LIST
92434: LIST
92435: PUSH
92436: LD_INT 2
92438: PUSH
92439: LD_INT 2
92441: PUSH
92442: EMPTY
92443: LIST
92444: LIST
92445: PUSH
92446: LD_INT 1
92448: PUSH
92449: LD_INT 2
92451: PUSH
92452: EMPTY
92453: LIST
92454: LIST
92455: PUSH
92456: EMPTY
92457: LIST
92458: LIST
92459: LIST
92460: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
92461: LD_ADDR_VAR 0 62
92465: PUSH
92466: LD_INT 1
92468: PUSH
92469: LD_INT 2
92471: PUSH
92472: EMPTY
92473: LIST
92474: LIST
92475: PUSH
92476: LD_INT 0
92478: PUSH
92479: LD_INT 2
92481: PUSH
92482: EMPTY
92483: LIST
92484: LIST
92485: PUSH
92486: LD_INT 1
92488: NEG
92489: PUSH
92490: LD_INT 1
92492: PUSH
92493: EMPTY
92494: LIST
92495: LIST
92496: PUSH
92497: EMPTY
92498: LIST
92499: LIST
92500: LIST
92501: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
92502: LD_ADDR_VAR 0 63
92506: PUSH
92507: LD_INT 1
92509: NEG
92510: PUSH
92511: LD_INT 1
92513: PUSH
92514: EMPTY
92515: LIST
92516: LIST
92517: PUSH
92518: LD_INT 2
92520: NEG
92521: PUSH
92522: LD_INT 0
92524: PUSH
92525: EMPTY
92526: LIST
92527: LIST
92528: PUSH
92529: LD_INT 2
92531: NEG
92532: PUSH
92533: LD_INT 1
92535: NEG
92536: PUSH
92537: EMPTY
92538: LIST
92539: LIST
92540: PUSH
92541: EMPTY
92542: LIST
92543: LIST
92544: LIST
92545: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92546: LD_ADDR_VAR 0 64
92550: PUSH
92551: LD_INT 1
92553: NEG
92554: PUSH
92555: LD_INT 2
92557: NEG
92558: PUSH
92559: EMPTY
92560: LIST
92561: LIST
92562: PUSH
92563: LD_INT 2
92565: NEG
92566: PUSH
92567: LD_INT 1
92569: NEG
92570: PUSH
92571: EMPTY
92572: LIST
92573: LIST
92574: PUSH
92575: LD_INT 2
92577: NEG
92578: PUSH
92579: LD_INT 2
92581: NEG
92582: PUSH
92583: EMPTY
92584: LIST
92585: LIST
92586: PUSH
92587: EMPTY
92588: LIST
92589: LIST
92590: LIST
92591: ST_TO_ADDR
// end ; 2 :
92592: GO 95858
92594: LD_INT 2
92596: DOUBLE
92597: EQUAL
92598: IFTRUE 92602
92600: GO 95857
92602: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
92603: LD_ADDR_VAR 0 29
92607: PUSH
92608: LD_INT 4
92610: PUSH
92611: LD_INT 0
92613: PUSH
92614: EMPTY
92615: LIST
92616: LIST
92617: PUSH
92618: LD_INT 4
92620: PUSH
92621: LD_INT 1
92623: NEG
92624: PUSH
92625: EMPTY
92626: LIST
92627: LIST
92628: PUSH
92629: LD_INT 5
92631: PUSH
92632: LD_INT 0
92634: PUSH
92635: EMPTY
92636: LIST
92637: LIST
92638: PUSH
92639: LD_INT 5
92641: PUSH
92642: LD_INT 1
92644: PUSH
92645: EMPTY
92646: LIST
92647: LIST
92648: PUSH
92649: LD_INT 4
92651: PUSH
92652: LD_INT 1
92654: PUSH
92655: EMPTY
92656: LIST
92657: LIST
92658: PUSH
92659: LD_INT 3
92661: PUSH
92662: LD_INT 0
92664: PUSH
92665: EMPTY
92666: LIST
92667: LIST
92668: PUSH
92669: LD_INT 3
92671: PUSH
92672: LD_INT 1
92674: NEG
92675: PUSH
92676: EMPTY
92677: LIST
92678: LIST
92679: PUSH
92680: LD_INT 3
92682: PUSH
92683: LD_INT 2
92685: NEG
92686: PUSH
92687: EMPTY
92688: LIST
92689: LIST
92690: PUSH
92691: LD_INT 5
92693: PUSH
92694: LD_INT 2
92696: PUSH
92697: EMPTY
92698: LIST
92699: LIST
92700: PUSH
92701: LD_INT 3
92703: PUSH
92704: LD_INT 3
92706: PUSH
92707: EMPTY
92708: LIST
92709: LIST
92710: PUSH
92711: LD_INT 3
92713: PUSH
92714: LD_INT 2
92716: PUSH
92717: EMPTY
92718: LIST
92719: LIST
92720: PUSH
92721: LD_INT 4
92723: PUSH
92724: LD_INT 3
92726: PUSH
92727: EMPTY
92728: LIST
92729: LIST
92730: PUSH
92731: LD_INT 4
92733: PUSH
92734: LD_INT 4
92736: PUSH
92737: EMPTY
92738: LIST
92739: LIST
92740: PUSH
92741: LD_INT 3
92743: PUSH
92744: LD_INT 4
92746: PUSH
92747: EMPTY
92748: LIST
92749: LIST
92750: PUSH
92751: LD_INT 2
92753: PUSH
92754: LD_INT 3
92756: PUSH
92757: EMPTY
92758: LIST
92759: LIST
92760: PUSH
92761: LD_INT 2
92763: PUSH
92764: LD_INT 2
92766: PUSH
92767: EMPTY
92768: LIST
92769: LIST
92770: PUSH
92771: LD_INT 4
92773: PUSH
92774: LD_INT 2
92776: PUSH
92777: EMPTY
92778: LIST
92779: LIST
92780: PUSH
92781: LD_INT 2
92783: PUSH
92784: LD_INT 4
92786: PUSH
92787: EMPTY
92788: LIST
92789: LIST
92790: PUSH
92791: LD_INT 0
92793: PUSH
92794: LD_INT 4
92796: PUSH
92797: EMPTY
92798: LIST
92799: LIST
92800: PUSH
92801: LD_INT 0
92803: PUSH
92804: LD_INT 3
92806: PUSH
92807: EMPTY
92808: LIST
92809: LIST
92810: PUSH
92811: LD_INT 1
92813: PUSH
92814: LD_INT 4
92816: PUSH
92817: EMPTY
92818: LIST
92819: LIST
92820: PUSH
92821: LD_INT 1
92823: PUSH
92824: LD_INT 5
92826: PUSH
92827: EMPTY
92828: LIST
92829: LIST
92830: PUSH
92831: LD_INT 0
92833: PUSH
92834: LD_INT 5
92836: PUSH
92837: EMPTY
92838: LIST
92839: LIST
92840: PUSH
92841: LD_INT 1
92843: NEG
92844: PUSH
92845: LD_INT 4
92847: PUSH
92848: EMPTY
92849: LIST
92850: LIST
92851: PUSH
92852: LD_INT 1
92854: NEG
92855: PUSH
92856: LD_INT 3
92858: PUSH
92859: EMPTY
92860: LIST
92861: LIST
92862: PUSH
92863: LD_INT 2
92865: PUSH
92866: LD_INT 5
92868: PUSH
92869: EMPTY
92870: LIST
92871: LIST
92872: PUSH
92873: LD_INT 2
92875: NEG
92876: PUSH
92877: LD_INT 3
92879: PUSH
92880: EMPTY
92881: LIST
92882: LIST
92883: PUSH
92884: LD_INT 3
92886: NEG
92887: PUSH
92888: LD_INT 0
92890: PUSH
92891: EMPTY
92892: LIST
92893: LIST
92894: PUSH
92895: LD_INT 3
92897: NEG
92898: PUSH
92899: LD_INT 1
92901: NEG
92902: PUSH
92903: EMPTY
92904: LIST
92905: LIST
92906: PUSH
92907: LD_INT 2
92909: NEG
92910: PUSH
92911: LD_INT 0
92913: PUSH
92914: EMPTY
92915: LIST
92916: LIST
92917: PUSH
92918: LD_INT 2
92920: NEG
92921: PUSH
92922: LD_INT 1
92924: PUSH
92925: EMPTY
92926: LIST
92927: LIST
92928: PUSH
92929: LD_INT 3
92931: NEG
92932: PUSH
92933: LD_INT 1
92935: PUSH
92936: EMPTY
92937: LIST
92938: LIST
92939: PUSH
92940: LD_INT 4
92942: NEG
92943: PUSH
92944: LD_INT 0
92946: PUSH
92947: EMPTY
92948: LIST
92949: LIST
92950: PUSH
92951: LD_INT 4
92953: NEG
92954: PUSH
92955: LD_INT 1
92957: NEG
92958: PUSH
92959: EMPTY
92960: LIST
92961: LIST
92962: PUSH
92963: LD_INT 4
92965: NEG
92966: PUSH
92967: LD_INT 2
92969: NEG
92970: PUSH
92971: EMPTY
92972: LIST
92973: LIST
92974: PUSH
92975: LD_INT 2
92977: NEG
92978: PUSH
92979: LD_INT 2
92981: PUSH
92982: EMPTY
92983: LIST
92984: LIST
92985: PUSH
92986: LD_INT 4
92988: NEG
92989: PUSH
92990: LD_INT 4
92992: NEG
92993: PUSH
92994: EMPTY
92995: LIST
92996: LIST
92997: PUSH
92998: LD_INT 4
93000: NEG
93001: PUSH
93002: LD_INT 5
93004: NEG
93005: PUSH
93006: EMPTY
93007: LIST
93008: LIST
93009: PUSH
93010: LD_INT 3
93012: NEG
93013: PUSH
93014: LD_INT 4
93016: NEG
93017: PUSH
93018: EMPTY
93019: LIST
93020: LIST
93021: PUSH
93022: LD_INT 3
93024: NEG
93025: PUSH
93026: LD_INT 3
93028: NEG
93029: PUSH
93030: EMPTY
93031: LIST
93032: LIST
93033: PUSH
93034: LD_INT 4
93036: NEG
93037: PUSH
93038: LD_INT 3
93040: NEG
93041: PUSH
93042: EMPTY
93043: LIST
93044: LIST
93045: PUSH
93046: LD_INT 5
93048: NEG
93049: PUSH
93050: LD_INT 4
93052: NEG
93053: PUSH
93054: EMPTY
93055: LIST
93056: LIST
93057: PUSH
93058: LD_INT 5
93060: NEG
93061: PUSH
93062: LD_INT 5
93064: NEG
93065: PUSH
93066: EMPTY
93067: LIST
93068: LIST
93069: PUSH
93070: LD_INT 3
93072: NEG
93073: PUSH
93074: LD_INT 5
93076: NEG
93077: PUSH
93078: EMPTY
93079: LIST
93080: LIST
93081: PUSH
93082: LD_INT 5
93084: NEG
93085: PUSH
93086: LD_INT 3
93088: NEG
93089: PUSH
93090: EMPTY
93091: LIST
93092: LIST
93093: PUSH
93094: EMPTY
93095: LIST
93096: LIST
93097: LIST
93098: LIST
93099: LIST
93100: LIST
93101: LIST
93102: LIST
93103: LIST
93104: LIST
93105: LIST
93106: LIST
93107: LIST
93108: LIST
93109: LIST
93110: LIST
93111: LIST
93112: LIST
93113: LIST
93114: LIST
93115: LIST
93116: LIST
93117: LIST
93118: LIST
93119: LIST
93120: LIST
93121: LIST
93122: LIST
93123: LIST
93124: LIST
93125: LIST
93126: LIST
93127: LIST
93128: LIST
93129: LIST
93130: LIST
93131: LIST
93132: LIST
93133: LIST
93134: LIST
93135: LIST
93136: LIST
93137: LIST
93138: LIST
93139: LIST
93140: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
93141: LD_ADDR_VAR 0 30
93145: PUSH
93146: LD_INT 4
93148: PUSH
93149: LD_INT 4
93151: PUSH
93152: EMPTY
93153: LIST
93154: LIST
93155: PUSH
93156: LD_INT 4
93158: PUSH
93159: LD_INT 3
93161: PUSH
93162: EMPTY
93163: LIST
93164: LIST
93165: PUSH
93166: LD_INT 5
93168: PUSH
93169: LD_INT 4
93171: PUSH
93172: EMPTY
93173: LIST
93174: LIST
93175: PUSH
93176: LD_INT 5
93178: PUSH
93179: LD_INT 5
93181: PUSH
93182: EMPTY
93183: LIST
93184: LIST
93185: PUSH
93186: LD_INT 4
93188: PUSH
93189: LD_INT 5
93191: PUSH
93192: EMPTY
93193: LIST
93194: LIST
93195: PUSH
93196: LD_INT 3
93198: PUSH
93199: LD_INT 4
93201: PUSH
93202: EMPTY
93203: LIST
93204: LIST
93205: PUSH
93206: LD_INT 3
93208: PUSH
93209: LD_INT 3
93211: PUSH
93212: EMPTY
93213: LIST
93214: LIST
93215: PUSH
93216: LD_INT 5
93218: PUSH
93219: LD_INT 3
93221: PUSH
93222: EMPTY
93223: LIST
93224: LIST
93225: PUSH
93226: LD_INT 3
93228: PUSH
93229: LD_INT 5
93231: PUSH
93232: EMPTY
93233: LIST
93234: LIST
93235: PUSH
93236: LD_INT 0
93238: PUSH
93239: LD_INT 3
93241: PUSH
93242: EMPTY
93243: LIST
93244: LIST
93245: PUSH
93246: LD_INT 0
93248: PUSH
93249: LD_INT 2
93251: PUSH
93252: EMPTY
93253: LIST
93254: LIST
93255: PUSH
93256: LD_INT 1
93258: PUSH
93259: LD_INT 3
93261: PUSH
93262: EMPTY
93263: LIST
93264: LIST
93265: PUSH
93266: LD_INT 1
93268: PUSH
93269: LD_INT 4
93271: PUSH
93272: EMPTY
93273: LIST
93274: LIST
93275: PUSH
93276: LD_INT 0
93278: PUSH
93279: LD_INT 4
93281: PUSH
93282: EMPTY
93283: LIST
93284: LIST
93285: PUSH
93286: LD_INT 1
93288: NEG
93289: PUSH
93290: LD_INT 3
93292: PUSH
93293: EMPTY
93294: LIST
93295: LIST
93296: PUSH
93297: LD_INT 1
93299: NEG
93300: PUSH
93301: LD_INT 2
93303: PUSH
93304: EMPTY
93305: LIST
93306: LIST
93307: PUSH
93308: LD_INT 2
93310: PUSH
93311: LD_INT 4
93313: PUSH
93314: EMPTY
93315: LIST
93316: LIST
93317: PUSH
93318: LD_INT 2
93320: NEG
93321: PUSH
93322: LD_INT 2
93324: PUSH
93325: EMPTY
93326: LIST
93327: LIST
93328: PUSH
93329: LD_INT 4
93331: NEG
93332: PUSH
93333: LD_INT 0
93335: PUSH
93336: EMPTY
93337: LIST
93338: LIST
93339: PUSH
93340: LD_INT 4
93342: NEG
93343: PUSH
93344: LD_INT 1
93346: NEG
93347: PUSH
93348: EMPTY
93349: LIST
93350: LIST
93351: PUSH
93352: LD_INT 3
93354: NEG
93355: PUSH
93356: LD_INT 0
93358: PUSH
93359: EMPTY
93360: LIST
93361: LIST
93362: PUSH
93363: LD_INT 3
93365: NEG
93366: PUSH
93367: LD_INT 1
93369: PUSH
93370: EMPTY
93371: LIST
93372: LIST
93373: PUSH
93374: LD_INT 4
93376: NEG
93377: PUSH
93378: LD_INT 1
93380: PUSH
93381: EMPTY
93382: LIST
93383: LIST
93384: PUSH
93385: LD_INT 5
93387: NEG
93388: PUSH
93389: LD_INT 0
93391: PUSH
93392: EMPTY
93393: LIST
93394: LIST
93395: PUSH
93396: LD_INT 5
93398: NEG
93399: PUSH
93400: LD_INT 1
93402: NEG
93403: PUSH
93404: EMPTY
93405: LIST
93406: LIST
93407: PUSH
93408: LD_INT 5
93410: NEG
93411: PUSH
93412: LD_INT 2
93414: NEG
93415: PUSH
93416: EMPTY
93417: LIST
93418: LIST
93419: PUSH
93420: LD_INT 3
93422: NEG
93423: PUSH
93424: LD_INT 2
93426: PUSH
93427: EMPTY
93428: LIST
93429: LIST
93430: PUSH
93431: LD_INT 3
93433: NEG
93434: PUSH
93435: LD_INT 3
93437: NEG
93438: PUSH
93439: EMPTY
93440: LIST
93441: LIST
93442: PUSH
93443: LD_INT 3
93445: NEG
93446: PUSH
93447: LD_INT 4
93449: NEG
93450: PUSH
93451: EMPTY
93452: LIST
93453: LIST
93454: PUSH
93455: LD_INT 2
93457: NEG
93458: PUSH
93459: LD_INT 3
93461: NEG
93462: PUSH
93463: EMPTY
93464: LIST
93465: LIST
93466: PUSH
93467: LD_INT 2
93469: NEG
93470: PUSH
93471: LD_INT 2
93473: NEG
93474: PUSH
93475: EMPTY
93476: LIST
93477: LIST
93478: PUSH
93479: LD_INT 3
93481: NEG
93482: PUSH
93483: LD_INT 2
93485: NEG
93486: PUSH
93487: EMPTY
93488: LIST
93489: LIST
93490: PUSH
93491: LD_INT 4
93493: NEG
93494: PUSH
93495: LD_INT 3
93497: NEG
93498: PUSH
93499: EMPTY
93500: LIST
93501: LIST
93502: PUSH
93503: LD_INT 4
93505: NEG
93506: PUSH
93507: LD_INT 4
93509: NEG
93510: PUSH
93511: EMPTY
93512: LIST
93513: LIST
93514: PUSH
93515: LD_INT 2
93517: NEG
93518: PUSH
93519: LD_INT 4
93521: NEG
93522: PUSH
93523: EMPTY
93524: LIST
93525: LIST
93526: PUSH
93527: LD_INT 4
93529: NEG
93530: PUSH
93531: LD_INT 2
93533: NEG
93534: PUSH
93535: EMPTY
93536: LIST
93537: LIST
93538: PUSH
93539: LD_INT 0
93541: PUSH
93542: LD_INT 4
93544: NEG
93545: PUSH
93546: EMPTY
93547: LIST
93548: LIST
93549: PUSH
93550: LD_INT 0
93552: PUSH
93553: LD_INT 5
93555: NEG
93556: PUSH
93557: EMPTY
93558: LIST
93559: LIST
93560: PUSH
93561: LD_INT 1
93563: PUSH
93564: LD_INT 4
93566: NEG
93567: PUSH
93568: EMPTY
93569: LIST
93570: LIST
93571: PUSH
93572: LD_INT 1
93574: PUSH
93575: LD_INT 3
93577: NEG
93578: PUSH
93579: EMPTY
93580: LIST
93581: LIST
93582: PUSH
93583: LD_INT 0
93585: PUSH
93586: LD_INT 3
93588: NEG
93589: PUSH
93590: EMPTY
93591: LIST
93592: LIST
93593: PUSH
93594: LD_INT 1
93596: NEG
93597: PUSH
93598: LD_INT 4
93600: NEG
93601: PUSH
93602: EMPTY
93603: LIST
93604: LIST
93605: PUSH
93606: LD_INT 1
93608: NEG
93609: PUSH
93610: LD_INT 5
93612: NEG
93613: PUSH
93614: EMPTY
93615: LIST
93616: LIST
93617: PUSH
93618: LD_INT 2
93620: PUSH
93621: LD_INT 3
93623: NEG
93624: PUSH
93625: EMPTY
93626: LIST
93627: LIST
93628: PUSH
93629: LD_INT 2
93631: NEG
93632: PUSH
93633: LD_INT 5
93635: NEG
93636: PUSH
93637: EMPTY
93638: LIST
93639: LIST
93640: PUSH
93641: EMPTY
93642: LIST
93643: LIST
93644: LIST
93645: LIST
93646: LIST
93647: LIST
93648: LIST
93649: LIST
93650: LIST
93651: LIST
93652: LIST
93653: LIST
93654: LIST
93655: LIST
93656: LIST
93657: LIST
93658: LIST
93659: LIST
93660: LIST
93661: LIST
93662: LIST
93663: LIST
93664: LIST
93665: LIST
93666: LIST
93667: LIST
93668: LIST
93669: LIST
93670: LIST
93671: LIST
93672: LIST
93673: LIST
93674: LIST
93675: LIST
93676: LIST
93677: LIST
93678: LIST
93679: LIST
93680: LIST
93681: LIST
93682: LIST
93683: LIST
93684: LIST
93685: LIST
93686: LIST
93687: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
93688: LD_ADDR_VAR 0 31
93692: PUSH
93693: LD_INT 0
93695: PUSH
93696: LD_INT 4
93698: PUSH
93699: EMPTY
93700: LIST
93701: LIST
93702: PUSH
93703: LD_INT 0
93705: PUSH
93706: LD_INT 3
93708: PUSH
93709: EMPTY
93710: LIST
93711: LIST
93712: PUSH
93713: LD_INT 1
93715: PUSH
93716: LD_INT 4
93718: PUSH
93719: EMPTY
93720: LIST
93721: LIST
93722: PUSH
93723: LD_INT 1
93725: PUSH
93726: LD_INT 5
93728: PUSH
93729: EMPTY
93730: LIST
93731: LIST
93732: PUSH
93733: LD_INT 0
93735: PUSH
93736: LD_INT 5
93738: PUSH
93739: EMPTY
93740: LIST
93741: LIST
93742: PUSH
93743: LD_INT 1
93745: NEG
93746: PUSH
93747: LD_INT 4
93749: PUSH
93750: EMPTY
93751: LIST
93752: LIST
93753: PUSH
93754: LD_INT 1
93756: NEG
93757: PUSH
93758: LD_INT 3
93760: PUSH
93761: EMPTY
93762: LIST
93763: LIST
93764: PUSH
93765: LD_INT 2
93767: PUSH
93768: LD_INT 5
93770: PUSH
93771: EMPTY
93772: LIST
93773: LIST
93774: PUSH
93775: LD_INT 2
93777: NEG
93778: PUSH
93779: LD_INT 3
93781: PUSH
93782: EMPTY
93783: LIST
93784: LIST
93785: PUSH
93786: LD_INT 3
93788: NEG
93789: PUSH
93790: LD_INT 0
93792: PUSH
93793: EMPTY
93794: LIST
93795: LIST
93796: PUSH
93797: LD_INT 3
93799: NEG
93800: PUSH
93801: LD_INT 1
93803: NEG
93804: PUSH
93805: EMPTY
93806: LIST
93807: LIST
93808: PUSH
93809: LD_INT 2
93811: NEG
93812: PUSH
93813: LD_INT 0
93815: PUSH
93816: EMPTY
93817: LIST
93818: LIST
93819: PUSH
93820: LD_INT 2
93822: NEG
93823: PUSH
93824: LD_INT 1
93826: PUSH
93827: EMPTY
93828: LIST
93829: LIST
93830: PUSH
93831: LD_INT 3
93833: NEG
93834: PUSH
93835: LD_INT 1
93837: PUSH
93838: EMPTY
93839: LIST
93840: LIST
93841: PUSH
93842: LD_INT 4
93844: NEG
93845: PUSH
93846: LD_INT 0
93848: PUSH
93849: EMPTY
93850: LIST
93851: LIST
93852: PUSH
93853: LD_INT 4
93855: NEG
93856: PUSH
93857: LD_INT 1
93859: NEG
93860: PUSH
93861: EMPTY
93862: LIST
93863: LIST
93864: PUSH
93865: LD_INT 4
93867: NEG
93868: PUSH
93869: LD_INT 2
93871: NEG
93872: PUSH
93873: EMPTY
93874: LIST
93875: LIST
93876: PUSH
93877: LD_INT 2
93879: NEG
93880: PUSH
93881: LD_INT 2
93883: PUSH
93884: EMPTY
93885: LIST
93886: LIST
93887: PUSH
93888: LD_INT 4
93890: NEG
93891: PUSH
93892: LD_INT 4
93894: NEG
93895: PUSH
93896: EMPTY
93897: LIST
93898: LIST
93899: PUSH
93900: LD_INT 4
93902: NEG
93903: PUSH
93904: LD_INT 5
93906: NEG
93907: PUSH
93908: EMPTY
93909: LIST
93910: LIST
93911: PUSH
93912: LD_INT 3
93914: NEG
93915: PUSH
93916: LD_INT 4
93918: NEG
93919: PUSH
93920: EMPTY
93921: LIST
93922: LIST
93923: PUSH
93924: LD_INT 3
93926: NEG
93927: PUSH
93928: LD_INT 3
93930: NEG
93931: PUSH
93932: EMPTY
93933: LIST
93934: LIST
93935: PUSH
93936: LD_INT 4
93938: NEG
93939: PUSH
93940: LD_INT 3
93942: NEG
93943: PUSH
93944: EMPTY
93945: LIST
93946: LIST
93947: PUSH
93948: LD_INT 5
93950: NEG
93951: PUSH
93952: LD_INT 4
93954: NEG
93955: PUSH
93956: EMPTY
93957: LIST
93958: LIST
93959: PUSH
93960: LD_INT 5
93962: NEG
93963: PUSH
93964: LD_INT 5
93966: NEG
93967: PUSH
93968: EMPTY
93969: LIST
93970: LIST
93971: PUSH
93972: LD_INT 3
93974: NEG
93975: PUSH
93976: LD_INT 5
93978: NEG
93979: PUSH
93980: EMPTY
93981: LIST
93982: LIST
93983: PUSH
93984: LD_INT 5
93986: NEG
93987: PUSH
93988: LD_INT 3
93990: NEG
93991: PUSH
93992: EMPTY
93993: LIST
93994: LIST
93995: PUSH
93996: LD_INT 0
93998: PUSH
93999: LD_INT 3
94001: NEG
94002: PUSH
94003: EMPTY
94004: LIST
94005: LIST
94006: PUSH
94007: LD_INT 0
94009: PUSH
94010: LD_INT 4
94012: NEG
94013: PUSH
94014: EMPTY
94015: LIST
94016: LIST
94017: PUSH
94018: LD_INT 1
94020: PUSH
94021: LD_INT 3
94023: NEG
94024: PUSH
94025: EMPTY
94026: LIST
94027: LIST
94028: PUSH
94029: LD_INT 1
94031: PUSH
94032: LD_INT 2
94034: NEG
94035: PUSH
94036: EMPTY
94037: LIST
94038: LIST
94039: PUSH
94040: LD_INT 0
94042: PUSH
94043: LD_INT 2
94045: NEG
94046: PUSH
94047: EMPTY
94048: LIST
94049: LIST
94050: PUSH
94051: LD_INT 1
94053: NEG
94054: PUSH
94055: LD_INT 3
94057: NEG
94058: PUSH
94059: EMPTY
94060: LIST
94061: LIST
94062: PUSH
94063: LD_INT 1
94065: NEG
94066: PUSH
94067: LD_INT 4
94069: NEG
94070: PUSH
94071: EMPTY
94072: LIST
94073: LIST
94074: PUSH
94075: LD_INT 2
94077: PUSH
94078: LD_INT 2
94080: NEG
94081: PUSH
94082: EMPTY
94083: LIST
94084: LIST
94085: PUSH
94086: LD_INT 2
94088: NEG
94089: PUSH
94090: LD_INT 4
94092: NEG
94093: PUSH
94094: EMPTY
94095: LIST
94096: LIST
94097: PUSH
94098: LD_INT 4
94100: PUSH
94101: LD_INT 0
94103: PUSH
94104: EMPTY
94105: LIST
94106: LIST
94107: PUSH
94108: LD_INT 4
94110: PUSH
94111: LD_INT 1
94113: NEG
94114: PUSH
94115: EMPTY
94116: LIST
94117: LIST
94118: PUSH
94119: LD_INT 5
94121: PUSH
94122: LD_INT 0
94124: PUSH
94125: EMPTY
94126: LIST
94127: LIST
94128: PUSH
94129: LD_INT 5
94131: PUSH
94132: LD_INT 1
94134: PUSH
94135: EMPTY
94136: LIST
94137: LIST
94138: PUSH
94139: LD_INT 4
94141: PUSH
94142: LD_INT 1
94144: PUSH
94145: EMPTY
94146: LIST
94147: LIST
94148: PUSH
94149: LD_INT 3
94151: PUSH
94152: LD_INT 0
94154: PUSH
94155: EMPTY
94156: LIST
94157: LIST
94158: PUSH
94159: LD_INT 3
94161: PUSH
94162: LD_INT 1
94164: NEG
94165: PUSH
94166: EMPTY
94167: LIST
94168: LIST
94169: PUSH
94170: LD_INT 3
94172: PUSH
94173: LD_INT 2
94175: NEG
94176: PUSH
94177: EMPTY
94178: LIST
94179: LIST
94180: PUSH
94181: LD_INT 5
94183: PUSH
94184: LD_INT 2
94186: PUSH
94187: EMPTY
94188: LIST
94189: LIST
94190: PUSH
94191: EMPTY
94192: LIST
94193: LIST
94194: LIST
94195: LIST
94196: LIST
94197: LIST
94198: LIST
94199: LIST
94200: LIST
94201: LIST
94202: LIST
94203: LIST
94204: LIST
94205: LIST
94206: LIST
94207: LIST
94208: LIST
94209: LIST
94210: LIST
94211: LIST
94212: LIST
94213: LIST
94214: LIST
94215: LIST
94216: LIST
94217: LIST
94218: LIST
94219: LIST
94220: LIST
94221: LIST
94222: LIST
94223: LIST
94224: LIST
94225: LIST
94226: LIST
94227: LIST
94228: LIST
94229: LIST
94230: LIST
94231: LIST
94232: LIST
94233: LIST
94234: LIST
94235: LIST
94236: LIST
94237: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
94238: LD_ADDR_VAR 0 32
94242: PUSH
94243: LD_INT 4
94245: NEG
94246: PUSH
94247: LD_INT 0
94249: PUSH
94250: EMPTY
94251: LIST
94252: LIST
94253: PUSH
94254: LD_INT 4
94256: NEG
94257: PUSH
94258: LD_INT 1
94260: NEG
94261: PUSH
94262: EMPTY
94263: LIST
94264: LIST
94265: PUSH
94266: LD_INT 3
94268: NEG
94269: PUSH
94270: LD_INT 0
94272: PUSH
94273: EMPTY
94274: LIST
94275: LIST
94276: PUSH
94277: LD_INT 3
94279: NEG
94280: PUSH
94281: LD_INT 1
94283: PUSH
94284: EMPTY
94285: LIST
94286: LIST
94287: PUSH
94288: LD_INT 4
94290: NEG
94291: PUSH
94292: LD_INT 1
94294: PUSH
94295: EMPTY
94296: LIST
94297: LIST
94298: PUSH
94299: LD_INT 5
94301: NEG
94302: PUSH
94303: LD_INT 0
94305: PUSH
94306: EMPTY
94307: LIST
94308: LIST
94309: PUSH
94310: LD_INT 5
94312: NEG
94313: PUSH
94314: LD_INT 1
94316: NEG
94317: PUSH
94318: EMPTY
94319: LIST
94320: LIST
94321: PUSH
94322: LD_INT 5
94324: NEG
94325: PUSH
94326: LD_INT 2
94328: NEG
94329: PUSH
94330: EMPTY
94331: LIST
94332: LIST
94333: PUSH
94334: LD_INT 3
94336: NEG
94337: PUSH
94338: LD_INT 2
94340: PUSH
94341: EMPTY
94342: LIST
94343: LIST
94344: PUSH
94345: LD_INT 3
94347: NEG
94348: PUSH
94349: LD_INT 3
94351: NEG
94352: PUSH
94353: EMPTY
94354: LIST
94355: LIST
94356: PUSH
94357: LD_INT 3
94359: NEG
94360: PUSH
94361: LD_INT 4
94363: NEG
94364: PUSH
94365: EMPTY
94366: LIST
94367: LIST
94368: PUSH
94369: LD_INT 2
94371: NEG
94372: PUSH
94373: LD_INT 3
94375: NEG
94376: PUSH
94377: EMPTY
94378: LIST
94379: LIST
94380: PUSH
94381: LD_INT 2
94383: NEG
94384: PUSH
94385: LD_INT 2
94387: NEG
94388: PUSH
94389: EMPTY
94390: LIST
94391: LIST
94392: PUSH
94393: LD_INT 3
94395: NEG
94396: PUSH
94397: LD_INT 2
94399: NEG
94400: PUSH
94401: EMPTY
94402: LIST
94403: LIST
94404: PUSH
94405: LD_INT 4
94407: NEG
94408: PUSH
94409: LD_INT 3
94411: NEG
94412: PUSH
94413: EMPTY
94414: LIST
94415: LIST
94416: PUSH
94417: LD_INT 4
94419: NEG
94420: PUSH
94421: LD_INT 4
94423: NEG
94424: PUSH
94425: EMPTY
94426: LIST
94427: LIST
94428: PUSH
94429: LD_INT 2
94431: NEG
94432: PUSH
94433: LD_INT 4
94435: NEG
94436: PUSH
94437: EMPTY
94438: LIST
94439: LIST
94440: PUSH
94441: LD_INT 4
94443: NEG
94444: PUSH
94445: LD_INT 2
94447: NEG
94448: PUSH
94449: EMPTY
94450: LIST
94451: LIST
94452: PUSH
94453: LD_INT 0
94455: PUSH
94456: LD_INT 4
94458: NEG
94459: PUSH
94460: EMPTY
94461: LIST
94462: LIST
94463: PUSH
94464: LD_INT 0
94466: PUSH
94467: LD_INT 5
94469: NEG
94470: PUSH
94471: EMPTY
94472: LIST
94473: LIST
94474: PUSH
94475: LD_INT 1
94477: PUSH
94478: LD_INT 4
94480: NEG
94481: PUSH
94482: EMPTY
94483: LIST
94484: LIST
94485: PUSH
94486: LD_INT 1
94488: PUSH
94489: LD_INT 3
94491: NEG
94492: PUSH
94493: EMPTY
94494: LIST
94495: LIST
94496: PUSH
94497: LD_INT 0
94499: PUSH
94500: LD_INT 3
94502: NEG
94503: PUSH
94504: EMPTY
94505: LIST
94506: LIST
94507: PUSH
94508: LD_INT 1
94510: NEG
94511: PUSH
94512: LD_INT 4
94514: NEG
94515: PUSH
94516: EMPTY
94517: LIST
94518: LIST
94519: PUSH
94520: LD_INT 1
94522: NEG
94523: PUSH
94524: LD_INT 5
94526: NEG
94527: PUSH
94528: EMPTY
94529: LIST
94530: LIST
94531: PUSH
94532: LD_INT 2
94534: PUSH
94535: LD_INT 3
94537: NEG
94538: PUSH
94539: EMPTY
94540: LIST
94541: LIST
94542: PUSH
94543: LD_INT 2
94545: NEG
94546: PUSH
94547: LD_INT 5
94549: NEG
94550: PUSH
94551: EMPTY
94552: LIST
94553: LIST
94554: PUSH
94555: LD_INT 3
94557: PUSH
94558: LD_INT 0
94560: PUSH
94561: EMPTY
94562: LIST
94563: LIST
94564: PUSH
94565: LD_INT 3
94567: PUSH
94568: LD_INT 1
94570: NEG
94571: PUSH
94572: EMPTY
94573: LIST
94574: LIST
94575: PUSH
94576: LD_INT 4
94578: PUSH
94579: LD_INT 0
94581: PUSH
94582: EMPTY
94583: LIST
94584: LIST
94585: PUSH
94586: LD_INT 4
94588: PUSH
94589: LD_INT 1
94591: PUSH
94592: EMPTY
94593: LIST
94594: LIST
94595: PUSH
94596: LD_INT 3
94598: PUSH
94599: LD_INT 1
94601: PUSH
94602: EMPTY
94603: LIST
94604: LIST
94605: PUSH
94606: LD_INT 2
94608: PUSH
94609: LD_INT 0
94611: PUSH
94612: EMPTY
94613: LIST
94614: LIST
94615: PUSH
94616: LD_INT 2
94618: PUSH
94619: LD_INT 1
94621: NEG
94622: PUSH
94623: EMPTY
94624: LIST
94625: LIST
94626: PUSH
94627: LD_INT 2
94629: PUSH
94630: LD_INT 2
94632: NEG
94633: PUSH
94634: EMPTY
94635: LIST
94636: LIST
94637: PUSH
94638: LD_INT 4
94640: PUSH
94641: LD_INT 2
94643: PUSH
94644: EMPTY
94645: LIST
94646: LIST
94647: PUSH
94648: LD_INT 4
94650: PUSH
94651: LD_INT 4
94653: PUSH
94654: EMPTY
94655: LIST
94656: LIST
94657: PUSH
94658: LD_INT 4
94660: PUSH
94661: LD_INT 3
94663: PUSH
94664: EMPTY
94665: LIST
94666: LIST
94667: PUSH
94668: LD_INT 5
94670: PUSH
94671: LD_INT 4
94673: PUSH
94674: EMPTY
94675: LIST
94676: LIST
94677: PUSH
94678: LD_INT 5
94680: PUSH
94681: LD_INT 5
94683: PUSH
94684: EMPTY
94685: LIST
94686: LIST
94687: PUSH
94688: LD_INT 4
94690: PUSH
94691: LD_INT 5
94693: PUSH
94694: EMPTY
94695: LIST
94696: LIST
94697: PUSH
94698: LD_INT 3
94700: PUSH
94701: LD_INT 4
94703: PUSH
94704: EMPTY
94705: LIST
94706: LIST
94707: PUSH
94708: LD_INT 3
94710: PUSH
94711: LD_INT 3
94713: PUSH
94714: EMPTY
94715: LIST
94716: LIST
94717: PUSH
94718: LD_INT 5
94720: PUSH
94721: LD_INT 3
94723: PUSH
94724: EMPTY
94725: LIST
94726: LIST
94727: PUSH
94728: LD_INT 3
94730: PUSH
94731: LD_INT 5
94733: PUSH
94734: EMPTY
94735: LIST
94736: LIST
94737: PUSH
94738: EMPTY
94739: LIST
94740: LIST
94741: LIST
94742: LIST
94743: LIST
94744: LIST
94745: LIST
94746: LIST
94747: LIST
94748: LIST
94749: LIST
94750: LIST
94751: LIST
94752: LIST
94753: LIST
94754: LIST
94755: LIST
94756: LIST
94757: LIST
94758: LIST
94759: LIST
94760: LIST
94761: LIST
94762: LIST
94763: LIST
94764: LIST
94765: LIST
94766: LIST
94767: LIST
94768: LIST
94769: LIST
94770: LIST
94771: LIST
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: LIST
94778: LIST
94779: LIST
94780: LIST
94781: LIST
94782: LIST
94783: LIST
94784: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
94785: LD_ADDR_VAR 0 33
94789: PUSH
94790: LD_INT 4
94792: NEG
94793: PUSH
94794: LD_INT 4
94796: NEG
94797: PUSH
94798: EMPTY
94799: LIST
94800: LIST
94801: PUSH
94802: LD_INT 4
94804: NEG
94805: PUSH
94806: LD_INT 5
94808: NEG
94809: PUSH
94810: EMPTY
94811: LIST
94812: LIST
94813: PUSH
94814: LD_INT 3
94816: NEG
94817: PUSH
94818: LD_INT 4
94820: NEG
94821: PUSH
94822: EMPTY
94823: LIST
94824: LIST
94825: PUSH
94826: LD_INT 3
94828: NEG
94829: PUSH
94830: LD_INT 3
94832: NEG
94833: PUSH
94834: EMPTY
94835: LIST
94836: LIST
94837: PUSH
94838: LD_INT 4
94840: NEG
94841: PUSH
94842: LD_INT 3
94844: NEG
94845: PUSH
94846: EMPTY
94847: LIST
94848: LIST
94849: PUSH
94850: LD_INT 5
94852: NEG
94853: PUSH
94854: LD_INT 4
94856: NEG
94857: PUSH
94858: EMPTY
94859: LIST
94860: LIST
94861: PUSH
94862: LD_INT 5
94864: NEG
94865: PUSH
94866: LD_INT 5
94868: NEG
94869: PUSH
94870: EMPTY
94871: LIST
94872: LIST
94873: PUSH
94874: LD_INT 3
94876: NEG
94877: PUSH
94878: LD_INT 5
94880: NEG
94881: PUSH
94882: EMPTY
94883: LIST
94884: LIST
94885: PUSH
94886: LD_INT 5
94888: NEG
94889: PUSH
94890: LD_INT 3
94892: NEG
94893: PUSH
94894: EMPTY
94895: LIST
94896: LIST
94897: PUSH
94898: LD_INT 0
94900: PUSH
94901: LD_INT 3
94903: NEG
94904: PUSH
94905: EMPTY
94906: LIST
94907: LIST
94908: PUSH
94909: LD_INT 0
94911: PUSH
94912: LD_INT 4
94914: NEG
94915: PUSH
94916: EMPTY
94917: LIST
94918: LIST
94919: PUSH
94920: LD_INT 1
94922: PUSH
94923: LD_INT 3
94925: NEG
94926: PUSH
94927: EMPTY
94928: LIST
94929: LIST
94930: PUSH
94931: LD_INT 1
94933: PUSH
94934: LD_INT 2
94936: NEG
94937: PUSH
94938: EMPTY
94939: LIST
94940: LIST
94941: PUSH
94942: LD_INT 0
94944: PUSH
94945: LD_INT 2
94947: NEG
94948: PUSH
94949: EMPTY
94950: LIST
94951: LIST
94952: PUSH
94953: LD_INT 1
94955: NEG
94956: PUSH
94957: LD_INT 3
94959: NEG
94960: PUSH
94961: EMPTY
94962: LIST
94963: LIST
94964: PUSH
94965: LD_INT 1
94967: NEG
94968: PUSH
94969: LD_INT 4
94971: NEG
94972: PUSH
94973: EMPTY
94974: LIST
94975: LIST
94976: PUSH
94977: LD_INT 2
94979: PUSH
94980: LD_INT 2
94982: NEG
94983: PUSH
94984: EMPTY
94985: LIST
94986: LIST
94987: PUSH
94988: LD_INT 2
94990: NEG
94991: PUSH
94992: LD_INT 4
94994: NEG
94995: PUSH
94996: EMPTY
94997: LIST
94998: LIST
94999: PUSH
95000: LD_INT 4
95002: PUSH
95003: LD_INT 0
95005: PUSH
95006: EMPTY
95007: LIST
95008: LIST
95009: PUSH
95010: LD_INT 4
95012: PUSH
95013: LD_INT 1
95015: NEG
95016: PUSH
95017: EMPTY
95018: LIST
95019: LIST
95020: PUSH
95021: LD_INT 5
95023: PUSH
95024: LD_INT 0
95026: PUSH
95027: EMPTY
95028: LIST
95029: LIST
95030: PUSH
95031: LD_INT 5
95033: PUSH
95034: LD_INT 1
95036: PUSH
95037: EMPTY
95038: LIST
95039: LIST
95040: PUSH
95041: LD_INT 4
95043: PUSH
95044: LD_INT 1
95046: PUSH
95047: EMPTY
95048: LIST
95049: LIST
95050: PUSH
95051: LD_INT 3
95053: PUSH
95054: LD_INT 0
95056: PUSH
95057: EMPTY
95058: LIST
95059: LIST
95060: PUSH
95061: LD_INT 3
95063: PUSH
95064: LD_INT 1
95066: NEG
95067: PUSH
95068: EMPTY
95069: LIST
95070: LIST
95071: PUSH
95072: LD_INT 3
95074: PUSH
95075: LD_INT 2
95077: NEG
95078: PUSH
95079: EMPTY
95080: LIST
95081: LIST
95082: PUSH
95083: LD_INT 5
95085: PUSH
95086: LD_INT 2
95088: PUSH
95089: EMPTY
95090: LIST
95091: LIST
95092: PUSH
95093: LD_INT 3
95095: PUSH
95096: LD_INT 3
95098: PUSH
95099: EMPTY
95100: LIST
95101: LIST
95102: PUSH
95103: LD_INT 3
95105: PUSH
95106: LD_INT 2
95108: PUSH
95109: EMPTY
95110: LIST
95111: LIST
95112: PUSH
95113: LD_INT 4
95115: PUSH
95116: LD_INT 3
95118: PUSH
95119: EMPTY
95120: LIST
95121: LIST
95122: PUSH
95123: LD_INT 4
95125: PUSH
95126: LD_INT 4
95128: PUSH
95129: EMPTY
95130: LIST
95131: LIST
95132: PUSH
95133: LD_INT 3
95135: PUSH
95136: LD_INT 4
95138: PUSH
95139: EMPTY
95140: LIST
95141: LIST
95142: PUSH
95143: LD_INT 2
95145: PUSH
95146: LD_INT 3
95148: PUSH
95149: EMPTY
95150: LIST
95151: LIST
95152: PUSH
95153: LD_INT 2
95155: PUSH
95156: LD_INT 2
95158: PUSH
95159: EMPTY
95160: LIST
95161: LIST
95162: PUSH
95163: LD_INT 4
95165: PUSH
95166: LD_INT 2
95168: PUSH
95169: EMPTY
95170: LIST
95171: LIST
95172: PUSH
95173: LD_INT 2
95175: PUSH
95176: LD_INT 4
95178: PUSH
95179: EMPTY
95180: LIST
95181: LIST
95182: PUSH
95183: LD_INT 0
95185: PUSH
95186: LD_INT 4
95188: PUSH
95189: EMPTY
95190: LIST
95191: LIST
95192: PUSH
95193: LD_INT 0
95195: PUSH
95196: LD_INT 3
95198: PUSH
95199: EMPTY
95200: LIST
95201: LIST
95202: PUSH
95203: LD_INT 1
95205: PUSH
95206: LD_INT 4
95208: PUSH
95209: EMPTY
95210: LIST
95211: LIST
95212: PUSH
95213: LD_INT 1
95215: PUSH
95216: LD_INT 5
95218: PUSH
95219: EMPTY
95220: LIST
95221: LIST
95222: PUSH
95223: LD_INT 0
95225: PUSH
95226: LD_INT 5
95228: PUSH
95229: EMPTY
95230: LIST
95231: LIST
95232: PUSH
95233: LD_INT 1
95235: NEG
95236: PUSH
95237: LD_INT 4
95239: PUSH
95240: EMPTY
95241: LIST
95242: LIST
95243: PUSH
95244: LD_INT 1
95246: NEG
95247: PUSH
95248: LD_INT 3
95250: PUSH
95251: EMPTY
95252: LIST
95253: LIST
95254: PUSH
95255: LD_INT 2
95257: PUSH
95258: LD_INT 5
95260: PUSH
95261: EMPTY
95262: LIST
95263: LIST
95264: PUSH
95265: LD_INT 2
95267: NEG
95268: PUSH
95269: LD_INT 3
95271: PUSH
95272: EMPTY
95273: LIST
95274: LIST
95275: PUSH
95276: EMPTY
95277: LIST
95278: LIST
95279: LIST
95280: LIST
95281: LIST
95282: LIST
95283: LIST
95284: LIST
95285: LIST
95286: LIST
95287: LIST
95288: LIST
95289: LIST
95290: LIST
95291: LIST
95292: LIST
95293: LIST
95294: LIST
95295: LIST
95296: LIST
95297: LIST
95298: LIST
95299: LIST
95300: LIST
95301: LIST
95302: LIST
95303: LIST
95304: LIST
95305: LIST
95306: LIST
95307: LIST
95308: LIST
95309: LIST
95310: LIST
95311: LIST
95312: LIST
95313: LIST
95314: LIST
95315: LIST
95316: LIST
95317: LIST
95318: LIST
95319: LIST
95320: LIST
95321: LIST
95322: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
95323: LD_ADDR_VAR 0 34
95327: PUSH
95328: LD_INT 0
95330: PUSH
95331: LD_INT 4
95333: NEG
95334: PUSH
95335: EMPTY
95336: LIST
95337: LIST
95338: PUSH
95339: LD_INT 0
95341: PUSH
95342: LD_INT 5
95344: NEG
95345: PUSH
95346: EMPTY
95347: LIST
95348: LIST
95349: PUSH
95350: LD_INT 1
95352: PUSH
95353: LD_INT 4
95355: NEG
95356: PUSH
95357: EMPTY
95358: LIST
95359: LIST
95360: PUSH
95361: LD_INT 1
95363: PUSH
95364: LD_INT 3
95366: NEG
95367: PUSH
95368: EMPTY
95369: LIST
95370: LIST
95371: PUSH
95372: LD_INT 0
95374: PUSH
95375: LD_INT 3
95377: NEG
95378: PUSH
95379: EMPTY
95380: LIST
95381: LIST
95382: PUSH
95383: LD_INT 1
95385: NEG
95386: PUSH
95387: LD_INT 4
95389: NEG
95390: PUSH
95391: EMPTY
95392: LIST
95393: LIST
95394: PUSH
95395: LD_INT 1
95397: NEG
95398: PUSH
95399: LD_INT 5
95401: NEG
95402: PUSH
95403: EMPTY
95404: LIST
95405: LIST
95406: PUSH
95407: LD_INT 2
95409: PUSH
95410: LD_INT 3
95412: NEG
95413: PUSH
95414: EMPTY
95415: LIST
95416: LIST
95417: PUSH
95418: LD_INT 2
95420: NEG
95421: PUSH
95422: LD_INT 5
95424: NEG
95425: PUSH
95426: EMPTY
95427: LIST
95428: LIST
95429: PUSH
95430: LD_INT 3
95432: PUSH
95433: LD_INT 0
95435: PUSH
95436: EMPTY
95437: LIST
95438: LIST
95439: PUSH
95440: LD_INT 3
95442: PUSH
95443: LD_INT 1
95445: NEG
95446: PUSH
95447: EMPTY
95448: LIST
95449: LIST
95450: PUSH
95451: LD_INT 4
95453: PUSH
95454: LD_INT 0
95456: PUSH
95457: EMPTY
95458: LIST
95459: LIST
95460: PUSH
95461: LD_INT 4
95463: PUSH
95464: LD_INT 1
95466: PUSH
95467: EMPTY
95468: LIST
95469: LIST
95470: PUSH
95471: LD_INT 3
95473: PUSH
95474: LD_INT 1
95476: PUSH
95477: EMPTY
95478: LIST
95479: LIST
95480: PUSH
95481: LD_INT 2
95483: PUSH
95484: LD_INT 0
95486: PUSH
95487: EMPTY
95488: LIST
95489: LIST
95490: PUSH
95491: LD_INT 2
95493: PUSH
95494: LD_INT 1
95496: NEG
95497: PUSH
95498: EMPTY
95499: LIST
95500: LIST
95501: PUSH
95502: LD_INT 2
95504: PUSH
95505: LD_INT 2
95507: NEG
95508: PUSH
95509: EMPTY
95510: LIST
95511: LIST
95512: PUSH
95513: LD_INT 4
95515: PUSH
95516: LD_INT 2
95518: PUSH
95519: EMPTY
95520: LIST
95521: LIST
95522: PUSH
95523: LD_INT 4
95525: PUSH
95526: LD_INT 4
95528: PUSH
95529: EMPTY
95530: LIST
95531: LIST
95532: PUSH
95533: LD_INT 4
95535: PUSH
95536: LD_INT 3
95538: PUSH
95539: EMPTY
95540: LIST
95541: LIST
95542: PUSH
95543: LD_INT 5
95545: PUSH
95546: LD_INT 4
95548: PUSH
95549: EMPTY
95550: LIST
95551: LIST
95552: PUSH
95553: LD_INT 5
95555: PUSH
95556: LD_INT 5
95558: PUSH
95559: EMPTY
95560: LIST
95561: LIST
95562: PUSH
95563: LD_INT 4
95565: PUSH
95566: LD_INT 5
95568: PUSH
95569: EMPTY
95570: LIST
95571: LIST
95572: PUSH
95573: LD_INT 3
95575: PUSH
95576: LD_INT 4
95578: PUSH
95579: EMPTY
95580: LIST
95581: LIST
95582: PUSH
95583: LD_INT 3
95585: PUSH
95586: LD_INT 3
95588: PUSH
95589: EMPTY
95590: LIST
95591: LIST
95592: PUSH
95593: LD_INT 5
95595: PUSH
95596: LD_INT 3
95598: PUSH
95599: EMPTY
95600: LIST
95601: LIST
95602: PUSH
95603: LD_INT 3
95605: PUSH
95606: LD_INT 5
95608: PUSH
95609: EMPTY
95610: LIST
95611: LIST
95612: PUSH
95613: LD_INT 0
95615: PUSH
95616: LD_INT 3
95618: PUSH
95619: EMPTY
95620: LIST
95621: LIST
95622: PUSH
95623: LD_INT 0
95625: PUSH
95626: LD_INT 2
95628: PUSH
95629: EMPTY
95630: LIST
95631: LIST
95632: PUSH
95633: LD_INT 1
95635: PUSH
95636: LD_INT 3
95638: PUSH
95639: EMPTY
95640: LIST
95641: LIST
95642: PUSH
95643: LD_INT 1
95645: PUSH
95646: LD_INT 4
95648: PUSH
95649: EMPTY
95650: LIST
95651: LIST
95652: PUSH
95653: LD_INT 0
95655: PUSH
95656: LD_INT 4
95658: PUSH
95659: EMPTY
95660: LIST
95661: LIST
95662: PUSH
95663: LD_INT 1
95665: NEG
95666: PUSH
95667: LD_INT 3
95669: PUSH
95670: EMPTY
95671: LIST
95672: LIST
95673: PUSH
95674: LD_INT 1
95676: NEG
95677: PUSH
95678: LD_INT 2
95680: PUSH
95681: EMPTY
95682: LIST
95683: LIST
95684: PUSH
95685: LD_INT 2
95687: PUSH
95688: LD_INT 4
95690: PUSH
95691: EMPTY
95692: LIST
95693: LIST
95694: PUSH
95695: LD_INT 2
95697: NEG
95698: PUSH
95699: LD_INT 2
95701: PUSH
95702: EMPTY
95703: LIST
95704: LIST
95705: PUSH
95706: LD_INT 4
95708: NEG
95709: PUSH
95710: LD_INT 0
95712: PUSH
95713: EMPTY
95714: LIST
95715: LIST
95716: PUSH
95717: LD_INT 4
95719: NEG
95720: PUSH
95721: LD_INT 1
95723: NEG
95724: PUSH
95725: EMPTY
95726: LIST
95727: LIST
95728: PUSH
95729: LD_INT 3
95731: NEG
95732: PUSH
95733: LD_INT 0
95735: PUSH
95736: EMPTY
95737: LIST
95738: LIST
95739: PUSH
95740: LD_INT 3
95742: NEG
95743: PUSH
95744: LD_INT 1
95746: PUSH
95747: EMPTY
95748: LIST
95749: LIST
95750: PUSH
95751: LD_INT 4
95753: NEG
95754: PUSH
95755: LD_INT 1
95757: PUSH
95758: EMPTY
95759: LIST
95760: LIST
95761: PUSH
95762: LD_INT 5
95764: NEG
95765: PUSH
95766: LD_INT 0
95768: PUSH
95769: EMPTY
95770: LIST
95771: LIST
95772: PUSH
95773: LD_INT 5
95775: NEG
95776: PUSH
95777: LD_INT 1
95779: NEG
95780: PUSH
95781: EMPTY
95782: LIST
95783: LIST
95784: PUSH
95785: LD_INT 5
95787: NEG
95788: PUSH
95789: LD_INT 2
95791: NEG
95792: PUSH
95793: EMPTY
95794: LIST
95795: LIST
95796: PUSH
95797: LD_INT 3
95799: NEG
95800: PUSH
95801: LD_INT 2
95803: PUSH
95804: EMPTY
95805: LIST
95806: LIST
95807: PUSH
95808: EMPTY
95809: LIST
95810: LIST
95811: LIST
95812: LIST
95813: LIST
95814: LIST
95815: LIST
95816: LIST
95817: LIST
95818: LIST
95819: LIST
95820: LIST
95821: LIST
95822: LIST
95823: LIST
95824: LIST
95825: LIST
95826: LIST
95827: LIST
95828: LIST
95829: LIST
95830: LIST
95831: LIST
95832: LIST
95833: LIST
95834: LIST
95835: LIST
95836: LIST
95837: LIST
95838: LIST
95839: LIST
95840: LIST
95841: LIST
95842: LIST
95843: LIST
95844: LIST
95845: LIST
95846: LIST
95847: LIST
95848: LIST
95849: LIST
95850: LIST
95851: LIST
95852: LIST
95853: LIST
95854: ST_TO_ADDR
// end ; end ;
95855: GO 95858
95857: POP
// case btype of b_depot , b_warehouse :
95858: LD_VAR 0 1
95862: PUSH
95863: LD_INT 0
95865: DOUBLE
95866: EQUAL
95867: IFTRUE 95877
95869: LD_INT 1
95871: DOUBLE
95872: EQUAL
95873: IFTRUE 95877
95875: GO 96078
95877: POP
// case nation of nation_american :
95878: LD_VAR 0 5
95882: PUSH
95883: LD_INT 1
95885: DOUBLE
95886: EQUAL
95887: IFTRUE 95891
95889: GO 95947
95891: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
95892: LD_ADDR_VAR 0 9
95896: PUSH
95897: LD_VAR 0 11
95901: PUSH
95902: LD_VAR 0 12
95906: PUSH
95907: LD_VAR 0 13
95911: PUSH
95912: LD_VAR 0 14
95916: PUSH
95917: LD_VAR 0 15
95921: PUSH
95922: LD_VAR 0 16
95926: PUSH
95927: EMPTY
95928: LIST
95929: LIST
95930: LIST
95931: LIST
95932: LIST
95933: LIST
95934: PUSH
95935: LD_VAR 0 4
95939: PUSH
95940: LD_INT 1
95942: PLUS
95943: ARRAY
95944: ST_TO_ADDR
95945: GO 96076
95947: LD_INT 2
95949: DOUBLE
95950: EQUAL
95951: IFTRUE 95955
95953: GO 96011
95955: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
95956: LD_ADDR_VAR 0 9
95960: PUSH
95961: LD_VAR 0 17
95965: PUSH
95966: LD_VAR 0 18
95970: PUSH
95971: LD_VAR 0 19
95975: PUSH
95976: LD_VAR 0 20
95980: PUSH
95981: LD_VAR 0 21
95985: PUSH
95986: LD_VAR 0 22
95990: PUSH
95991: EMPTY
95992: LIST
95993: LIST
95994: LIST
95995: LIST
95996: LIST
95997: LIST
95998: PUSH
95999: LD_VAR 0 4
96003: PUSH
96004: LD_INT 1
96006: PLUS
96007: ARRAY
96008: ST_TO_ADDR
96009: GO 96076
96011: LD_INT 3
96013: DOUBLE
96014: EQUAL
96015: IFTRUE 96019
96017: GO 96075
96019: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
96020: LD_ADDR_VAR 0 9
96024: PUSH
96025: LD_VAR 0 23
96029: PUSH
96030: LD_VAR 0 24
96034: PUSH
96035: LD_VAR 0 25
96039: PUSH
96040: LD_VAR 0 26
96044: PUSH
96045: LD_VAR 0 27
96049: PUSH
96050: LD_VAR 0 28
96054: PUSH
96055: EMPTY
96056: LIST
96057: LIST
96058: LIST
96059: LIST
96060: LIST
96061: LIST
96062: PUSH
96063: LD_VAR 0 4
96067: PUSH
96068: LD_INT 1
96070: PLUS
96071: ARRAY
96072: ST_TO_ADDR
96073: GO 96076
96075: POP
96076: GO 96631
96078: LD_INT 2
96080: DOUBLE
96081: EQUAL
96082: IFTRUE 96092
96084: LD_INT 3
96086: DOUBLE
96087: EQUAL
96088: IFTRUE 96092
96090: GO 96148
96092: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
96093: LD_ADDR_VAR 0 9
96097: PUSH
96098: LD_VAR 0 29
96102: PUSH
96103: LD_VAR 0 30
96107: PUSH
96108: LD_VAR 0 31
96112: PUSH
96113: LD_VAR 0 32
96117: PUSH
96118: LD_VAR 0 33
96122: PUSH
96123: LD_VAR 0 34
96127: PUSH
96128: EMPTY
96129: LIST
96130: LIST
96131: LIST
96132: LIST
96133: LIST
96134: LIST
96135: PUSH
96136: LD_VAR 0 4
96140: PUSH
96141: LD_INT 1
96143: PLUS
96144: ARRAY
96145: ST_TO_ADDR
96146: GO 96631
96148: LD_INT 16
96150: DOUBLE
96151: EQUAL
96152: IFTRUE 96210
96154: LD_INT 17
96156: DOUBLE
96157: EQUAL
96158: IFTRUE 96210
96160: LD_INT 18
96162: DOUBLE
96163: EQUAL
96164: IFTRUE 96210
96166: LD_INT 19
96168: DOUBLE
96169: EQUAL
96170: IFTRUE 96210
96172: LD_INT 22
96174: DOUBLE
96175: EQUAL
96176: IFTRUE 96210
96178: LD_INT 20
96180: DOUBLE
96181: EQUAL
96182: IFTRUE 96210
96184: LD_INT 21
96186: DOUBLE
96187: EQUAL
96188: IFTRUE 96210
96190: LD_INT 23
96192: DOUBLE
96193: EQUAL
96194: IFTRUE 96210
96196: LD_INT 24
96198: DOUBLE
96199: EQUAL
96200: IFTRUE 96210
96202: LD_INT 25
96204: DOUBLE
96205: EQUAL
96206: IFTRUE 96210
96208: GO 96266
96210: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
96211: LD_ADDR_VAR 0 9
96215: PUSH
96216: LD_VAR 0 35
96220: PUSH
96221: LD_VAR 0 36
96225: PUSH
96226: LD_VAR 0 37
96230: PUSH
96231: LD_VAR 0 38
96235: PUSH
96236: LD_VAR 0 39
96240: PUSH
96241: LD_VAR 0 40
96245: PUSH
96246: EMPTY
96247: LIST
96248: LIST
96249: LIST
96250: LIST
96251: LIST
96252: LIST
96253: PUSH
96254: LD_VAR 0 4
96258: PUSH
96259: LD_INT 1
96261: PLUS
96262: ARRAY
96263: ST_TO_ADDR
96264: GO 96631
96266: LD_INT 6
96268: DOUBLE
96269: EQUAL
96270: IFTRUE 96322
96272: LD_INT 7
96274: DOUBLE
96275: EQUAL
96276: IFTRUE 96322
96278: LD_INT 8
96280: DOUBLE
96281: EQUAL
96282: IFTRUE 96322
96284: LD_INT 13
96286: DOUBLE
96287: EQUAL
96288: IFTRUE 96322
96290: LD_INT 12
96292: DOUBLE
96293: EQUAL
96294: IFTRUE 96322
96296: LD_INT 15
96298: DOUBLE
96299: EQUAL
96300: IFTRUE 96322
96302: LD_INT 11
96304: DOUBLE
96305: EQUAL
96306: IFTRUE 96322
96308: LD_INT 14
96310: DOUBLE
96311: EQUAL
96312: IFTRUE 96322
96314: LD_INT 10
96316: DOUBLE
96317: EQUAL
96318: IFTRUE 96322
96320: GO 96378
96322: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
96323: LD_ADDR_VAR 0 9
96327: PUSH
96328: LD_VAR 0 41
96332: PUSH
96333: LD_VAR 0 42
96337: PUSH
96338: LD_VAR 0 43
96342: PUSH
96343: LD_VAR 0 44
96347: PUSH
96348: LD_VAR 0 45
96352: PUSH
96353: LD_VAR 0 46
96357: PUSH
96358: EMPTY
96359: LIST
96360: LIST
96361: LIST
96362: LIST
96363: LIST
96364: LIST
96365: PUSH
96366: LD_VAR 0 4
96370: PUSH
96371: LD_INT 1
96373: PLUS
96374: ARRAY
96375: ST_TO_ADDR
96376: GO 96631
96378: LD_INT 36
96380: DOUBLE
96381: EQUAL
96382: IFTRUE 96386
96384: GO 96442
96386: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
96387: LD_ADDR_VAR 0 9
96391: PUSH
96392: LD_VAR 0 47
96396: PUSH
96397: LD_VAR 0 48
96401: PUSH
96402: LD_VAR 0 49
96406: PUSH
96407: LD_VAR 0 50
96411: PUSH
96412: LD_VAR 0 51
96416: PUSH
96417: LD_VAR 0 52
96421: PUSH
96422: EMPTY
96423: LIST
96424: LIST
96425: LIST
96426: LIST
96427: LIST
96428: LIST
96429: PUSH
96430: LD_VAR 0 4
96434: PUSH
96435: LD_INT 1
96437: PLUS
96438: ARRAY
96439: ST_TO_ADDR
96440: GO 96631
96442: LD_INT 4
96444: DOUBLE
96445: EQUAL
96446: IFTRUE 96468
96448: LD_INT 5
96450: DOUBLE
96451: EQUAL
96452: IFTRUE 96468
96454: LD_INT 34
96456: DOUBLE
96457: EQUAL
96458: IFTRUE 96468
96460: LD_INT 37
96462: DOUBLE
96463: EQUAL
96464: IFTRUE 96468
96466: GO 96524
96468: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
96469: LD_ADDR_VAR 0 9
96473: PUSH
96474: LD_VAR 0 53
96478: PUSH
96479: LD_VAR 0 54
96483: PUSH
96484: LD_VAR 0 55
96488: PUSH
96489: LD_VAR 0 56
96493: PUSH
96494: LD_VAR 0 57
96498: PUSH
96499: LD_VAR 0 58
96503: PUSH
96504: EMPTY
96505: LIST
96506: LIST
96507: LIST
96508: LIST
96509: LIST
96510: LIST
96511: PUSH
96512: LD_VAR 0 4
96516: PUSH
96517: LD_INT 1
96519: PLUS
96520: ARRAY
96521: ST_TO_ADDR
96522: GO 96631
96524: LD_INT 31
96526: DOUBLE
96527: EQUAL
96528: IFTRUE 96574
96530: LD_INT 32
96532: DOUBLE
96533: EQUAL
96534: IFTRUE 96574
96536: LD_INT 33
96538: DOUBLE
96539: EQUAL
96540: IFTRUE 96574
96542: LD_INT 27
96544: DOUBLE
96545: EQUAL
96546: IFTRUE 96574
96548: LD_INT 26
96550: DOUBLE
96551: EQUAL
96552: IFTRUE 96574
96554: LD_INT 28
96556: DOUBLE
96557: EQUAL
96558: IFTRUE 96574
96560: LD_INT 29
96562: DOUBLE
96563: EQUAL
96564: IFTRUE 96574
96566: LD_INT 30
96568: DOUBLE
96569: EQUAL
96570: IFTRUE 96574
96572: GO 96630
96574: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
96575: LD_ADDR_VAR 0 9
96579: PUSH
96580: LD_VAR 0 59
96584: PUSH
96585: LD_VAR 0 60
96589: PUSH
96590: LD_VAR 0 61
96594: PUSH
96595: LD_VAR 0 62
96599: PUSH
96600: LD_VAR 0 63
96604: PUSH
96605: LD_VAR 0 64
96609: PUSH
96610: EMPTY
96611: LIST
96612: LIST
96613: LIST
96614: LIST
96615: LIST
96616: LIST
96617: PUSH
96618: LD_VAR 0 4
96622: PUSH
96623: LD_INT 1
96625: PLUS
96626: ARRAY
96627: ST_TO_ADDR
96628: GO 96631
96630: POP
// temp_list2 = [ ] ;
96631: LD_ADDR_VAR 0 10
96635: PUSH
96636: EMPTY
96637: ST_TO_ADDR
// for i in temp_list do
96638: LD_ADDR_VAR 0 8
96642: PUSH
96643: LD_VAR 0 9
96647: PUSH
96648: FOR_IN
96649: IFFALSE 96701
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
96651: LD_ADDR_VAR 0 10
96655: PUSH
96656: LD_VAR 0 10
96660: PUSH
96661: LD_VAR 0 8
96665: PUSH
96666: LD_INT 1
96668: ARRAY
96669: PUSH
96670: LD_VAR 0 2
96674: PLUS
96675: PUSH
96676: LD_VAR 0 8
96680: PUSH
96681: LD_INT 2
96683: ARRAY
96684: PUSH
96685: LD_VAR 0 3
96689: PLUS
96690: PUSH
96691: EMPTY
96692: LIST
96693: LIST
96694: PUSH
96695: EMPTY
96696: LIST
96697: ADD
96698: ST_TO_ADDR
96699: GO 96648
96701: POP
96702: POP
// result = temp_list2 ;
96703: LD_ADDR_VAR 0 7
96707: PUSH
96708: LD_VAR 0 10
96712: ST_TO_ADDR
// end ;
96713: LD_VAR 0 7
96717: RET
// export function EnemyInRange ( unit , dist ) ; begin
96718: LD_INT 0
96720: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
96721: LD_ADDR_VAR 0 3
96725: PUSH
96726: LD_VAR 0 1
96730: PPUSH
96731: CALL_OW 255
96735: PPUSH
96736: LD_VAR 0 1
96740: PPUSH
96741: CALL_OW 250
96745: PPUSH
96746: LD_VAR 0 1
96750: PPUSH
96751: CALL_OW 251
96755: PPUSH
96756: LD_VAR 0 2
96760: PPUSH
96761: CALL 70822 0 4
96765: PUSH
96766: LD_INT 4
96768: ARRAY
96769: ST_TO_ADDR
// end ;
96770: LD_VAR 0 3
96774: RET
// export function PlayerSeeMe ( unit ) ; begin
96775: LD_INT 0
96777: PPUSH
// result := See ( your_side , unit ) ;
96778: LD_ADDR_VAR 0 2
96782: PUSH
96783: LD_OWVAR 2
96787: PPUSH
96788: LD_VAR 0 1
96792: PPUSH
96793: CALL_OW 292
96797: ST_TO_ADDR
// end ;
96798: LD_VAR 0 2
96802: RET
// export function ReverseDir ( unit ) ; begin
96803: LD_INT 0
96805: PPUSH
// if not unit then
96806: LD_VAR 0 1
96810: NOT
96811: IFFALSE 96815
// exit ;
96813: GO 96838
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
96815: LD_ADDR_VAR 0 2
96819: PUSH
96820: LD_VAR 0 1
96824: PPUSH
96825: CALL_OW 254
96829: PUSH
96830: LD_INT 3
96832: PLUS
96833: PUSH
96834: LD_INT 6
96836: MOD
96837: ST_TO_ADDR
// end ;
96838: LD_VAR 0 2
96842: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
96843: LD_INT 0
96845: PPUSH
96846: PPUSH
96847: PPUSH
96848: PPUSH
96849: PPUSH
// if not hexes then
96850: LD_VAR 0 2
96854: NOT
96855: IFFALSE 96859
// exit ;
96857: GO 97007
// dist := 9999 ;
96859: LD_ADDR_VAR 0 5
96863: PUSH
96864: LD_INT 9999
96866: ST_TO_ADDR
// for i = 1 to hexes do
96867: LD_ADDR_VAR 0 4
96871: PUSH
96872: DOUBLE
96873: LD_INT 1
96875: DEC
96876: ST_TO_ADDR
96877: LD_VAR 0 2
96881: PUSH
96882: FOR_TO
96883: IFFALSE 96995
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
96885: LD_VAR 0 1
96889: PPUSH
96890: LD_VAR 0 2
96894: PUSH
96895: LD_VAR 0 4
96899: ARRAY
96900: PUSH
96901: LD_INT 1
96903: ARRAY
96904: PPUSH
96905: LD_VAR 0 2
96909: PUSH
96910: LD_VAR 0 4
96914: ARRAY
96915: PUSH
96916: LD_INT 2
96918: ARRAY
96919: PPUSH
96920: CALL_OW 297
96924: PUSH
96925: LD_VAR 0 5
96929: LESS
96930: IFFALSE 96993
// begin hex := hexes [ i ] ;
96932: LD_ADDR_VAR 0 7
96936: PUSH
96937: LD_VAR 0 2
96941: PUSH
96942: LD_VAR 0 4
96946: ARRAY
96947: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
96948: LD_ADDR_VAR 0 5
96952: PUSH
96953: LD_VAR 0 1
96957: PPUSH
96958: LD_VAR 0 2
96962: PUSH
96963: LD_VAR 0 4
96967: ARRAY
96968: PUSH
96969: LD_INT 1
96971: ARRAY
96972: PPUSH
96973: LD_VAR 0 2
96977: PUSH
96978: LD_VAR 0 4
96982: ARRAY
96983: PUSH
96984: LD_INT 2
96986: ARRAY
96987: PPUSH
96988: CALL_OW 297
96992: ST_TO_ADDR
// end ; end ;
96993: GO 96882
96995: POP
96996: POP
// result := hex ;
96997: LD_ADDR_VAR 0 3
97001: PUSH
97002: LD_VAR 0 7
97006: ST_TO_ADDR
// end ;
97007: LD_VAR 0 3
97011: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
97012: LD_INT 0
97014: PPUSH
97015: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
97016: LD_VAR 0 1
97020: NOT
97021: PUSH
97022: LD_VAR 0 1
97026: PUSH
97027: LD_INT 21
97029: PUSH
97030: LD_INT 2
97032: PUSH
97033: EMPTY
97034: LIST
97035: LIST
97036: PUSH
97037: LD_INT 23
97039: PUSH
97040: LD_INT 2
97042: PUSH
97043: EMPTY
97044: LIST
97045: LIST
97046: PUSH
97047: EMPTY
97048: LIST
97049: LIST
97050: PPUSH
97051: CALL_OW 69
97055: IN
97056: NOT
97057: OR
97058: IFFALSE 97062
// exit ;
97060: GO 97109
// for i = 1 to 3 do
97062: LD_ADDR_VAR 0 3
97066: PUSH
97067: DOUBLE
97068: LD_INT 1
97070: DEC
97071: ST_TO_ADDR
97072: LD_INT 3
97074: PUSH
97075: FOR_TO
97076: IFFALSE 97107
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
97078: LD_VAR 0 1
97082: PPUSH
97083: CALL_OW 250
97087: PPUSH
97088: LD_VAR 0 1
97092: PPUSH
97093: CALL_OW 251
97097: PPUSH
97098: LD_INT 1
97100: PPUSH
97101: CALL_OW 453
97105: GO 97075
97107: POP
97108: POP
// end ;
97109: LD_VAR 0 2
97113: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
97114: LD_INT 0
97116: PPUSH
97117: PPUSH
97118: PPUSH
97119: PPUSH
97120: PPUSH
97121: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
97122: LD_VAR 0 1
97126: NOT
97127: PUSH
97128: LD_VAR 0 2
97132: NOT
97133: OR
97134: PUSH
97135: LD_VAR 0 1
97139: PPUSH
97140: CALL_OW 314
97144: OR
97145: IFFALSE 97149
// exit ;
97147: GO 97590
// x := GetX ( enemy_unit ) ;
97149: LD_ADDR_VAR 0 7
97153: PUSH
97154: LD_VAR 0 2
97158: PPUSH
97159: CALL_OW 250
97163: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
97164: LD_ADDR_VAR 0 8
97168: PUSH
97169: LD_VAR 0 2
97173: PPUSH
97174: CALL_OW 251
97178: ST_TO_ADDR
// if not x or not y then
97179: LD_VAR 0 7
97183: NOT
97184: PUSH
97185: LD_VAR 0 8
97189: NOT
97190: OR
97191: IFFALSE 97195
// exit ;
97193: GO 97590
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
97195: LD_ADDR_VAR 0 6
97199: PUSH
97200: LD_VAR 0 7
97204: PPUSH
97205: LD_INT 0
97207: PPUSH
97208: LD_INT 4
97210: PPUSH
97211: CALL_OW 272
97215: PUSH
97216: LD_VAR 0 8
97220: PPUSH
97221: LD_INT 0
97223: PPUSH
97224: LD_INT 4
97226: PPUSH
97227: CALL_OW 273
97231: PUSH
97232: EMPTY
97233: LIST
97234: LIST
97235: PUSH
97236: LD_VAR 0 7
97240: PPUSH
97241: LD_INT 1
97243: PPUSH
97244: LD_INT 4
97246: PPUSH
97247: CALL_OW 272
97251: PUSH
97252: LD_VAR 0 8
97256: PPUSH
97257: LD_INT 1
97259: PPUSH
97260: LD_INT 4
97262: PPUSH
97263: CALL_OW 273
97267: PUSH
97268: EMPTY
97269: LIST
97270: LIST
97271: PUSH
97272: LD_VAR 0 7
97276: PPUSH
97277: LD_INT 2
97279: PPUSH
97280: LD_INT 4
97282: PPUSH
97283: CALL_OW 272
97287: PUSH
97288: LD_VAR 0 8
97292: PPUSH
97293: LD_INT 2
97295: PPUSH
97296: LD_INT 4
97298: PPUSH
97299: CALL_OW 273
97303: PUSH
97304: EMPTY
97305: LIST
97306: LIST
97307: PUSH
97308: LD_VAR 0 7
97312: PPUSH
97313: LD_INT 3
97315: PPUSH
97316: LD_INT 4
97318: PPUSH
97319: CALL_OW 272
97323: PUSH
97324: LD_VAR 0 8
97328: PPUSH
97329: LD_INT 3
97331: PPUSH
97332: LD_INT 4
97334: PPUSH
97335: CALL_OW 273
97339: PUSH
97340: EMPTY
97341: LIST
97342: LIST
97343: PUSH
97344: LD_VAR 0 7
97348: PPUSH
97349: LD_INT 4
97351: PPUSH
97352: LD_INT 4
97354: PPUSH
97355: CALL_OW 272
97359: PUSH
97360: LD_VAR 0 8
97364: PPUSH
97365: LD_INT 4
97367: PPUSH
97368: LD_INT 4
97370: PPUSH
97371: CALL_OW 273
97375: PUSH
97376: EMPTY
97377: LIST
97378: LIST
97379: PUSH
97380: LD_VAR 0 7
97384: PPUSH
97385: LD_INT 5
97387: PPUSH
97388: LD_INT 4
97390: PPUSH
97391: CALL_OW 272
97395: PUSH
97396: LD_VAR 0 8
97400: PPUSH
97401: LD_INT 5
97403: PPUSH
97404: LD_INT 4
97406: PPUSH
97407: CALL_OW 273
97411: PUSH
97412: EMPTY
97413: LIST
97414: LIST
97415: PUSH
97416: EMPTY
97417: LIST
97418: LIST
97419: LIST
97420: LIST
97421: LIST
97422: LIST
97423: ST_TO_ADDR
// for i = tmp downto 1 do
97424: LD_ADDR_VAR 0 4
97428: PUSH
97429: DOUBLE
97430: LD_VAR 0 6
97434: INC
97435: ST_TO_ADDR
97436: LD_INT 1
97438: PUSH
97439: FOR_DOWNTO
97440: IFFALSE 97541
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
97442: LD_VAR 0 6
97446: PUSH
97447: LD_VAR 0 4
97451: ARRAY
97452: PUSH
97453: LD_INT 1
97455: ARRAY
97456: PPUSH
97457: LD_VAR 0 6
97461: PUSH
97462: LD_VAR 0 4
97466: ARRAY
97467: PUSH
97468: LD_INT 2
97470: ARRAY
97471: PPUSH
97472: CALL_OW 488
97476: NOT
97477: PUSH
97478: LD_VAR 0 6
97482: PUSH
97483: LD_VAR 0 4
97487: ARRAY
97488: PUSH
97489: LD_INT 1
97491: ARRAY
97492: PPUSH
97493: LD_VAR 0 6
97497: PUSH
97498: LD_VAR 0 4
97502: ARRAY
97503: PUSH
97504: LD_INT 2
97506: ARRAY
97507: PPUSH
97508: CALL_OW 428
97512: PUSH
97513: LD_INT 0
97515: NONEQUAL
97516: OR
97517: IFFALSE 97539
// tmp := Delete ( tmp , i ) ;
97519: LD_ADDR_VAR 0 6
97523: PUSH
97524: LD_VAR 0 6
97528: PPUSH
97529: LD_VAR 0 4
97533: PPUSH
97534: CALL_OW 3
97538: ST_TO_ADDR
97539: GO 97439
97541: POP
97542: POP
// j := GetClosestHex ( unit , tmp ) ;
97543: LD_ADDR_VAR 0 5
97547: PUSH
97548: LD_VAR 0 1
97552: PPUSH
97553: LD_VAR 0 6
97557: PPUSH
97558: CALL 96843 0 2
97562: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
97563: LD_VAR 0 1
97567: PPUSH
97568: LD_VAR 0 5
97572: PUSH
97573: LD_INT 1
97575: ARRAY
97576: PPUSH
97577: LD_VAR 0 5
97581: PUSH
97582: LD_INT 2
97584: ARRAY
97585: PPUSH
97586: CALL_OW 111
// end ;
97590: LD_VAR 0 3
97594: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
97595: LD_INT 0
97597: PPUSH
97598: PPUSH
97599: PPUSH
// uc_side = 0 ;
97600: LD_ADDR_OWVAR 20
97604: PUSH
97605: LD_INT 0
97607: ST_TO_ADDR
// uc_nation = 0 ;
97608: LD_ADDR_OWVAR 21
97612: PUSH
97613: LD_INT 0
97615: ST_TO_ADDR
// InitHc ;
97616: CALL_OW 19
// InitVc ;
97620: CALL_OW 20
// if mastodonts then
97624: LD_VAR 0 6
97628: IFFALSE 97695
// for i = 1 to mastodonts do
97630: LD_ADDR_VAR 0 11
97634: PUSH
97635: DOUBLE
97636: LD_INT 1
97638: DEC
97639: ST_TO_ADDR
97640: LD_VAR 0 6
97644: PUSH
97645: FOR_TO
97646: IFFALSE 97693
// begin vc_chassis := 31 ;
97648: LD_ADDR_OWVAR 37
97652: PUSH
97653: LD_INT 31
97655: ST_TO_ADDR
// vc_control := control_rider ;
97656: LD_ADDR_OWVAR 38
97660: PUSH
97661: LD_INT 4
97663: ST_TO_ADDR
// animal := CreateVehicle ;
97664: LD_ADDR_VAR 0 12
97668: PUSH
97669: CALL_OW 45
97673: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97674: LD_VAR 0 12
97678: PPUSH
97679: LD_VAR 0 8
97683: PPUSH
97684: LD_INT 0
97686: PPUSH
97687: CALL 99764 0 3
// end ;
97691: GO 97645
97693: POP
97694: POP
// if horses then
97695: LD_VAR 0 5
97699: IFFALSE 97766
// for i = 1 to horses do
97701: LD_ADDR_VAR 0 11
97705: PUSH
97706: DOUBLE
97707: LD_INT 1
97709: DEC
97710: ST_TO_ADDR
97711: LD_VAR 0 5
97715: PUSH
97716: FOR_TO
97717: IFFALSE 97764
// begin hc_class := 21 ;
97719: LD_ADDR_OWVAR 28
97723: PUSH
97724: LD_INT 21
97726: ST_TO_ADDR
// hc_gallery :=  ;
97727: LD_ADDR_OWVAR 33
97731: PUSH
97732: LD_STRING 
97734: ST_TO_ADDR
// animal := CreateHuman ;
97735: LD_ADDR_VAR 0 12
97739: PUSH
97740: CALL_OW 44
97744: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97745: LD_VAR 0 12
97749: PPUSH
97750: LD_VAR 0 8
97754: PPUSH
97755: LD_INT 0
97757: PPUSH
97758: CALL 99764 0 3
// end ;
97762: GO 97716
97764: POP
97765: POP
// if birds then
97766: LD_VAR 0 1
97770: IFFALSE 97837
// for i = 1 to birds do
97772: LD_ADDR_VAR 0 11
97776: PUSH
97777: DOUBLE
97778: LD_INT 1
97780: DEC
97781: ST_TO_ADDR
97782: LD_VAR 0 1
97786: PUSH
97787: FOR_TO
97788: IFFALSE 97835
// begin hc_class = 18 ;
97790: LD_ADDR_OWVAR 28
97794: PUSH
97795: LD_INT 18
97797: ST_TO_ADDR
// hc_gallery =  ;
97798: LD_ADDR_OWVAR 33
97802: PUSH
97803: LD_STRING 
97805: ST_TO_ADDR
// animal := CreateHuman ;
97806: LD_ADDR_VAR 0 12
97810: PUSH
97811: CALL_OW 44
97815: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97816: LD_VAR 0 12
97820: PPUSH
97821: LD_VAR 0 8
97825: PPUSH
97826: LD_INT 0
97828: PPUSH
97829: CALL 99764 0 3
// end ;
97833: GO 97787
97835: POP
97836: POP
// if tigers then
97837: LD_VAR 0 2
97841: IFFALSE 97925
// for i = 1 to tigers do
97843: LD_ADDR_VAR 0 11
97847: PUSH
97848: DOUBLE
97849: LD_INT 1
97851: DEC
97852: ST_TO_ADDR
97853: LD_VAR 0 2
97857: PUSH
97858: FOR_TO
97859: IFFALSE 97923
// begin hc_class = class_tiger ;
97861: LD_ADDR_OWVAR 28
97865: PUSH
97866: LD_INT 14
97868: ST_TO_ADDR
// hc_gallery =  ;
97869: LD_ADDR_OWVAR 33
97873: PUSH
97874: LD_STRING 
97876: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
97877: LD_ADDR_OWVAR 35
97881: PUSH
97882: LD_INT 7
97884: NEG
97885: PPUSH
97886: LD_INT 7
97888: PPUSH
97889: CALL_OW 12
97893: ST_TO_ADDR
// animal := CreateHuman ;
97894: LD_ADDR_VAR 0 12
97898: PUSH
97899: CALL_OW 44
97903: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97904: LD_VAR 0 12
97908: PPUSH
97909: LD_VAR 0 8
97913: PPUSH
97914: LD_INT 0
97916: PPUSH
97917: CALL 99764 0 3
// end ;
97921: GO 97858
97923: POP
97924: POP
// if apemans then
97925: LD_VAR 0 3
97929: IFFALSE 98052
// for i = 1 to apemans do
97931: LD_ADDR_VAR 0 11
97935: PUSH
97936: DOUBLE
97937: LD_INT 1
97939: DEC
97940: ST_TO_ADDR
97941: LD_VAR 0 3
97945: PUSH
97946: FOR_TO
97947: IFFALSE 98050
// begin hc_class = class_apeman ;
97949: LD_ADDR_OWVAR 28
97953: PUSH
97954: LD_INT 12
97956: ST_TO_ADDR
// hc_gallery =  ;
97957: LD_ADDR_OWVAR 33
97961: PUSH
97962: LD_STRING 
97964: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
97965: LD_ADDR_OWVAR 35
97969: PUSH
97970: LD_INT 5
97972: NEG
97973: PPUSH
97974: LD_INT 5
97976: PPUSH
97977: CALL_OW 12
97981: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
97982: LD_ADDR_OWVAR 31
97986: PUSH
97987: LD_INT 1
97989: PPUSH
97990: LD_INT 3
97992: PPUSH
97993: CALL_OW 12
97997: PUSH
97998: LD_INT 1
98000: PPUSH
98001: LD_INT 3
98003: PPUSH
98004: CALL_OW 12
98008: PUSH
98009: LD_INT 0
98011: PUSH
98012: LD_INT 0
98014: PUSH
98015: EMPTY
98016: LIST
98017: LIST
98018: LIST
98019: LIST
98020: ST_TO_ADDR
// animal := CreateHuman ;
98021: LD_ADDR_VAR 0 12
98025: PUSH
98026: CALL_OW 44
98030: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98031: LD_VAR 0 12
98035: PPUSH
98036: LD_VAR 0 8
98040: PPUSH
98041: LD_INT 0
98043: PPUSH
98044: CALL 99764 0 3
// end ;
98048: GO 97946
98050: POP
98051: POP
// if enchidnas then
98052: LD_VAR 0 4
98056: IFFALSE 98123
// for i = 1 to enchidnas do
98058: LD_ADDR_VAR 0 11
98062: PUSH
98063: DOUBLE
98064: LD_INT 1
98066: DEC
98067: ST_TO_ADDR
98068: LD_VAR 0 4
98072: PUSH
98073: FOR_TO
98074: IFFALSE 98121
// begin hc_class = 13 ;
98076: LD_ADDR_OWVAR 28
98080: PUSH
98081: LD_INT 13
98083: ST_TO_ADDR
// hc_gallery =  ;
98084: LD_ADDR_OWVAR 33
98088: PUSH
98089: LD_STRING 
98091: ST_TO_ADDR
// animal := CreateHuman ;
98092: LD_ADDR_VAR 0 12
98096: PUSH
98097: CALL_OW 44
98101: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98102: LD_VAR 0 12
98106: PPUSH
98107: LD_VAR 0 8
98111: PPUSH
98112: LD_INT 0
98114: PPUSH
98115: CALL 99764 0 3
// end ;
98119: GO 98073
98121: POP
98122: POP
// if fishes then
98123: LD_VAR 0 7
98127: IFFALSE 98194
// for i = 1 to fishes do
98129: LD_ADDR_VAR 0 11
98133: PUSH
98134: DOUBLE
98135: LD_INT 1
98137: DEC
98138: ST_TO_ADDR
98139: LD_VAR 0 7
98143: PUSH
98144: FOR_TO
98145: IFFALSE 98192
// begin hc_class = 20 ;
98147: LD_ADDR_OWVAR 28
98151: PUSH
98152: LD_INT 20
98154: ST_TO_ADDR
// hc_gallery =  ;
98155: LD_ADDR_OWVAR 33
98159: PUSH
98160: LD_STRING 
98162: ST_TO_ADDR
// animal := CreateHuman ;
98163: LD_ADDR_VAR 0 12
98167: PUSH
98168: CALL_OW 44
98172: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
98173: LD_VAR 0 12
98177: PPUSH
98178: LD_VAR 0 9
98182: PPUSH
98183: LD_INT 0
98185: PPUSH
98186: CALL 99764 0 3
// end ;
98190: GO 98144
98192: POP
98193: POP
// end ;
98194: LD_VAR 0 10
98198: RET
// export function WantHeal ( sci , unit ) ; begin
98199: LD_INT 0
98201: PPUSH
// if GetTaskList ( sci ) > 0 then
98202: LD_VAR 0 1
98206: PPUSH
98207: CALL_OW 437
98211: PUSH
98212: LD_INT 0
98214: GREATER
98215: IFFALSE 98285
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
98217: LD_VAR 0 1
98221: PPUSH
98222: CALL_OW 437
98226: PUSH
98227: LD_INT 1
98229: ARRAY
98230: PUSH
98231: LD_INT 1
98233: ARRAY
98234: PUSH
98235: LD_STRING l
98237: EQUAL
98238: PUSH
98239: LD_VAR 0 1
98243: PPUSH
98244: CALL_OW 437
98248: PUSH
98249: LD_INT 1
98251: ARRAY
98252: PUSH
98253: LD_INT 4
98255: ARRAY
98256: PUSH
98257: LD_VAR 0 2
98261: EQUAL
98262: AND
98263: IFFALSE 98275
// result := true else
98265: LD_ADDR_VAR 0 3
98269: PUSH
98270: LD_INT 1
98272: ST_TO_ADDR
98273: GO 98283
// result := false ;
98275: LD_ADDR_VAR 0 3
98279: PUSH
98280: LD_INT 0
98282: ST_TO_ADDR
// end else
98283: GO 98293
// result := false ;
98285: LD_ADDR_VAR 0 3
98289: PUSH
98290: LD_INT 0
98292: ST_TO_ADDR
// end ;
98293: LD_VAR 0 3
98297: RET
// export function HealTarget ( sci ) ; begin
98298: LD_INT 0
98300: PPUSH
// if not sci then
98301: LD_VAR 0 1
98305: NOT
98306: IFFALSE 98310
// exit ;
98308: GO 98375
// result := 0 ;
98310: LD_ADDR_VAR 0 2
98314: PUSH
98315: LD_INT 0
98317: ST_TO_ADDR
// if GetTaskList ( sci ) then
98318: LD_VAR 0 1
98322: PPUSH
98323: CALL_OW 437
98327: IFFALSE 98375
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
98329: LD_VAR 0 1
98333: PPUSH
98334: CALL_OW 437
98338: PUSH
98339: LD_INT 1
98341: ARRAY
98342: PUSH
98343: LD_INT 1
98345: ARRAY
98346: PUSH
98347: LD_STRING l
98349: EQUAL
98350: IFFALSE 98375
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
98352: LD_ADDR_VAR 0 2
98356: PUSH
98357: LD_VAR 0 1
98361: PPUSH
98362: CALL_OW 437
98366: PUSH
98367: LD_INT 1
98369: ARRAY
98370: PUSH
98371: LD_INT 4
98373: ARRAY
98374: ST_TO_ADDR
// end ;
98375: LD_VAR 0 2
98379: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
98380: LD_INT 0
98382: PPUSH
98383: PPUSH
98384: PPUSH
98385: PPUSH
// if not base_units then
98386: LD_VAR 0 1
98390: NOT
98391: IFFALSE 98395
// exit ;
98393: GO 98482
// result := false ;
98395: LD_ADDR_VAR 0 2
98399: PUSH
98400: LD_INT 0
98402: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
98403: LD_ADDR_VAR 0 5
98407: PUSH
98408: LD_VAR 0 1
98412: PPUSH
98413: LD_INT 21
98415: PUSH
98416: LD_INT 3
98418: PUSH
98419: EMPTY
98420: LIST
98421: LIST
98422: PPUSH
98423: CALL_OW 72
98427: ST_TO_ADDR
// if not tmp then
98428: LD_VAR 0 5
98432: NOT
98433: IFFALSE 98437
// exit ;
98435: GO 98482
// for i in tmp do
98437: LD_ADDR_VAR 0 3
98441: PUSH
98442: LD_VAR 0 5
98446: PUSH
98447: FOR_IN
98448: IFFALSE 98480
// begin result := EnemyInRange ( i , 22 ) ;
98450: LD_ADDR_VAR 0 2
98454: PUSH
98455: LD_VAR 0 3
98459: PPUSH
98460: LD_INT 22
98462: PPUSH
98463: CALL 96718 0 2
98467: ST_TO_ADDR
// if result then
98468: LD_VAR 0 2
98472: IFFALSE 98478
// exit ;
98474: POP
98475: POP
98476: GO 98482
// end ;
98478: GO 98447
98480: POP
98481: POP
// end ;
98482: LD_VAR 0 2
98486: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
98487: LD_INT 0
98489: PPUSH
98490: PPUSH
// if not units then
98491: LD_VAR 0 1
98495: NOT
98496: IFFALSE 98500
// exit ;
98498: GO 98570
// result := [ ] ;
98500: LD_ADDR_VAR 0 3
98504: PUSH
98505: EMPTY
98506: ST_TO_ADDR
// for i in units do
98507: LD_ADDR_VAR 0 4
98511: PUSH
98512: LD_VAR 0 1
98516: PUSH
98517: FOR_IN
98518: IFFALSE 98568
// if GetTag ( i ) = tag then
98520: LD_VAR 0 4
98524: PPUSH
98525: CALL_OW 110
98529: PUSH
98530: LD_VAR 0 2
98534: EQUAL
98535: IFFALSE 98566
// result := Insert ( result , result + 1 , i ) ;
98537: LD_ADDR_VAR 0 3
98541: PUSH
98542: LD_VAR 0 3
98546: PPUSH
98547: LD_VAR 0 3
98551: PUSH
98552: LD_INT 1
98554: PLUS
98555: PPUSH
98556: LD_VAR 0 4
98560: PPUSH
98561: CALL_OW 2
98565: ST_TO_ADDR
98566: GO 98517
98568: POP
98569: POP
// end ;
98570: LD_VAR 0 3
98574: RET
// export function IsDriver ( un ) ; begin
98575: LD_INT 0
98577: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
98578: LD_ADDR_VAR 0 2
98582: PUSH
98583: LD_VAR 0 1
98587: PUSH
98588: LD_INT 55
98590: PUSH
98591: EMPTY
98592: LIST
98593: PPUSH
98594: CALL_OW 69
98598: IN
98599: ST_TO_ADDR
// end ;
98600: LD_VAR 0 2
98604: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
98605: LD_INT 0
98607: PPUSH
98608: PPUSH
// list := [ ] ;
98609: LD_ADDR_VAR 0 5
98613: PUSH
98614: EMPTY
98615: ST_TO_ADDR
// case d of 0 :
98616: LD_VAR 0 3
98620: PUSH
98621: LD_INT 0
98623: DOUBLE
98624: EQUAL
98625: IFTRUE 98629
98627: GO 98762
98629: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
98630: LD_ADDR_VAR 0 5
98634: PUSH
98635: LD_VAR 0 1
98639: PUSH
98640: LD_INT 4
98642: MINUS
98643: PUSH
98644: LD_VAR 0 2
98648: PUSH
98649: LD_INT 4
98651: MINUS
98652: PUSH
98653: LD_INT 2
98655: PUSH
98656: EMPTY
98657: LIST
98658: LIST
98659: LIST
98660: PUSH
98661: LD_VAR 0 1
98665: PUSH
98666: LD_INT 3
98668: MINUS
98669: PUSH
98670: LD_VAR 0 2
98674: PUSH
98675: LD_INT 1
98677: PUSH
98678: EMPTY
98679: LIST
98680: LIST
98681: LIST
98682: PUSH
98683: LD_VAR 0 1
98687: PUSH
98688: LD_INT 4
98690: PLUS
98691: PUSH
98692: LD_VAR 0 2
98696: PUSH
98697: LD_INT 4
98699: PUSH
98700: EMPTY
98701: LIST
98702: LIST
98703: LIST
98704: PUSH
98705: LD_VAR 0 1
98709: PUSH
98710: LD_INT 3
98712: PLUS
98713: PUSH
98714: LD_VAR 0 2
98718: PUSH
98719: LD_INT 3
98721: PLUS
98722: PUSH
98723: LD_INT 5
98725: PUSH
98726: EMPTY
98727: LIST
98728: LIST
98729: LIST
98730: PUSH
98731: LD_VAR 0 1
98735: PUSH
98736: LD_VAR 0 2
98740: PUSH
98741: LD_INT 4
98743: PLUS
98744: PUSH
98745: LD_INT 0
98747: PUSH
98748: EMPTY
98749: LIST
98750: LIST
98751: LIST
98752: PUSH
98753: EMPTY
98754: LIST
98755: LIST
98756: LIST
98757: LIST
98758: LIST
98759: ST_TO_ADDR
// end ; 1 :
98760: GO 99460
98762: LD_INT 1
98764: DOUBLE
98765: EQUAL
98766: IFTRUE 98770
98768: GO 98903
98770: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
98771: LD_ADDR_VAR 0 5
98775: PUSH
98776: LD_VAR 0 1
98780: PUSH
98781: LD_VAR 0 2
98785: PUSH
98786: LD_INT 4
98788: MINUS
98789: PUSH
98790: LD_INT 3
98792: PUSH
98793: EMPTY
98794: LIST
98795: LIST
98796: LIST
98797: PUSH
98798: LD_VAR 0 1
98802: PUSH
98803: LD_INT 3
98805: MINUS
98806: PUSH
98807: LD_VAR 0 2
98811: PUSH
98812: LD_INT 3
98814: MINUS
98815: PUSH
98816: LD_INT 2
98818: PUSH
98819: EMPTY
98820: LIST
98821: LIST
98822: LIST
98823: PUSH
98824: LD_VAR 0 1
98828: PUSH
98829: LD_INT 4
98831: MINUS
98832: PUSH
98833: LD_VAR 0 2
98837: PUSH
98838: LD_INT 1
98840: PUSH
98841: EMPTY
98842: LIST
98843: LIST
98844: LIST
98845: PUSH
98846: LD_VAR 0 1
98850: PUSH
98851: LD_VAR 0 2
98855: PUSH
98856: LD_INT 3
98858: PLUS
98859: PUSH
98860: LD_INT 0
98862: PUSH
98863: EMPTY
98864: LIST
98865: LIST
98866: LIST
98867: PUSH
98868: LD_VAR 0 1
98872: PUSH
98873: LD_INT 4
98875: PLUS
98876: PUSH
98877: LD_VAR 0 2
98881: PUSH
98882: LD_INT 4
98884: PLUS
98885: PUSH
98886: LD_INT 5
98888: PUSH
98889: EMPTY
98890: LIST
98891: LIST
98892: LIST
98893: PUSH
98894: EMPTY
98895: LIST
98896: LIST
98897: LIST
98898: LIST
98899: LIST
98900: ST_TO_ADDR
// end ; 2 :
98901: GO 99460
98903: LD_INT 2
98905: DOUBLE
98906: EQUAL
98907: IFTRUE 98911
98909: GO 99040
98911: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
98912: LD_ADDR_VAR 0 5
98916: PUSH
98917: LD_VAR 0 1
98921: PUSH
98922: LD_VAR 0 2
98926: PUSH
98927: LD_INT 3
98929: MINUS
98930: PUSH
98931: LD_INT 3
98933: PUSH
98934: EMPTY
98935: LIST
98936: LIST
98937: LIST
98938: PUSH
98939: LD_VAR 0 1
98943: PUSH
98944: LD_INT 4
98946: PLUS
98947: PUSH
98948: LD_VAR 0 2
98952: PUSH
98953: LD_INT 4
98955: PUSH
98956: EMPTY
98957: LIST
98958: LIST
98959: LIST
98960: PUSH
98961: LD_VAR 0 1
98965: PUSH
98966: LD_VAR 0 2
98970: PUSH
98971: LD_INT 4
98973: PLUS
98974: PUSH
98975: LD_INT 0
98977: PUSH
98978: EMPTY
98979: LIST
98980: LIST
98981: LIST
98982: PUSH
98983: LD_VAR 0 1
98987: PUSH
98988: LD_INT 3
98990: MINUS
98991: PUSH
98992: LD_VAR 0 2
98996: PUSH
98997: LD_INT 1
98999: PUSH
99000: EMPTY
99001: LIST
99002: LIST
99003: LIST
99004: PUSH
99005: LD_VAR 0 1
99009: PUSH
99010: LD_INT 4
99012: MINUS
99013: PUSH
99014: LD_VAR 0 2
99018: PUSH
99019: LD_INT 4
99021: MINUS
99022: PUSH
99023: LD_INT 2
99025: PUSH
99026: EMPTY
99027: LIST
99028: LIST
99029: LIST
99030: PUSH
99031: EMPTY
99032: LIST
99033: LIST
99034: LIST
99035: LIST
99036: LIST
99037: ST_TO_ADDR
// end ; 3 :
99038: GO 99460
99040: LD_INT 3
99042: DOUBLE
99043: EQUAL
99044: IFTRUE 99048
99046: GO 99181
99048: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
99049: LD_ADDR_VAR 0 5
99053: PUSH
99054: LD_VAR 0 1
99058: PUSH
99059: LD_INT 3
99061: PLUS
99062: PUSH
99063: LD_VAR 0 2
99067: PUSH
99068: LD_INT 4
99070: PUSH
99071: EMPTY
99072: LIST
99073: LIST
99074: LIST
99075: PUSH
99076: LD_VAR 0 1
99080: PUSH
99081: LD_INT 4
99083: PLUS
99084: PUSH
99085: LD_VAR 0 2
99089: PUSH
99090: LD_INT 4
99092: PLUS
99093: PUSH
99094: LD_INT 5
99096: PUSH
99097: EMPTY
99098: LIST
99099: LIST
99100: LIST
99101: PUSH
99102: LD_VAR 0 1
99106: PUSH
99107: LD_INT 4
99109: MINUS
99110: PUSH
99111: LD_VAR 0 2
99115: PUSH
99116: LD_INT 1
99118: PUSH
99119: EMPTY
99120: LIST
99121: LIST
99122: LIST
99123: PUSH
99124: LD_VAR 0 1
99128: PUSH
99129: LD_VAR 0 2
99133: PUSH
99134: LD_INT 4
99136: MINUS
99137: PUSH
99138: LD_INT 3
99140: PUSH
99141: EMPTY
99142: LIST
99143: LIST
99144: LIST
99145: PUSH
99146: LD_VAR 0 1
99150: PUSH
99151: LD_INT 3
99153: MINUS
99154: PUSH
99155: LD_VAR 0 2
99159: PUSH
99160: LD_INT 3
99162: MINUS
99163: PUSH
99164: LD_INT 2
99166: PUSH
99167: EMPTY
99168: LIST
99169: LIST
99170: LIST
99171: PUSH
99172: EMPTY
99173: LIST
99174: LIST
99175: LIST
99176: LIST
99177: LIST
99178: ST_TO_ADDR
// end ; 4 :
99179: GO 99460
99181: LD_INT 4
99183: DOUBLE
99184: EQUAL
99185: IFTRUE 99189
99187: GO 99322
99189: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
99190: LD_ADDR_VAR 0 5
99194: PUSH
99195: LD_VAR 0 1
99199: PUSH
99200: LD_VAR 0 2
99204: PUSH
99205: LD_INT 4
99207: PLUS
99208: PUSH
99209: LD_INT 0
99211: PUSH
99212: EMPTY
99213: LIST
99214: LIST
99215: LIST
99216: PUSH
99217: LD_VAR 0 1
99221: PUSH
99222: LD_INT 3
99224: PLUS
99225: PUSH
99226: LD_VAR 0 2
99230: PUSH
99231: LD_INT 3
99233: PLUS
99234: PUSH
99235: LD_INT 5
99237: PUSH
99238: EMPTY
99239: LIST
99240: LIST
99241: LIST
99242: PUSH
99243: LD_VAR 0 1
99247: PUSH
99248: LD_INT 4
99250: PLUS
99251: PUSH
99252: LD_VAR 0 2
99256: PUSH
99257: LD_INT 4
99259: PUSH
99260: EMPTY
99261: LIST
99262: LIST
99263: LIST
99264: PUSH
99265: LD_VAR 0 1
99269: PUSH
99270: LD_VAR 0 2
99274: PUSH
99275: LD_INT 3
99277: MINUS
99278: PUSH
99279: LD_INT 3
99281: PUSH
99282: EMPTY
99283: LIST
99284: LIST
99285: LIST
99286: PUSH
99287: LD_VAR 0 1
99291: PUSH
99292: LD_INT 4
99294: MINUS
99295: PUSH
99296: LD_VAR 0 2
99300: PUSH
99301: LD_INT 4
99303: MINUS
99304: PUSH
99305: LD_INT 2
99307: PUSH
99308: EMPTY
99309: LIST
99310: LIST
99311: LIST
99312: PUSH
99313: EMPTY
99314: LIST
99315: LIST
99316: LIST
99317: LIST
99318: LIST
99319: ST_TO_ADDR
// end ; 5 :
99320: GO 99460
99322: LD_INT 5
99324: DOUBLE
99325: EQUAL
99326: IFTRUE 99330
99328: GO 99459
99330: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
99331: LD_ADDR_VAR 0 5
99335: PUSH
99336: LD_VAR 0 1
99340: PUSH
99341: LD_INT 4
99343: MINUS
99344: PUSH
99345: LD_VAR 0 2
99349: PUSH
99350: LD_INT 1
99352: PUSH
99353: EMPTY
99354: LIST
99355: LIST
99356: LIST
99357: PUSH
99358: LD_VAR 0 1
99362: PUSH
99363: LD_VAR 0 2
99367: PUSH
99368: LD_INT 4
99370: MINUS
99371: PUSH
99372: LD_INT 3
99374: PUSH
99375: EMPTY
99376: LIST
99377: LIST
99378: LIST
99379: PUSH
99380: LD_VAR 0 1
99384: PUSH
99385: LD_INT 4
99387: PLUS
99388: PUSH
99389: LD_VAR 0 2
99393: PUSH
99394: LD_INT 4
99396: PLUS
99397: PUSH
99398: LD_INT 5
99400: PUSH
99401: EMPTY
99402: LIST
99403: LIST
99404: LIST
99405: PUSH
99406: LD_VAR 0 1
99410: PUSH
99411: LD_INT 3
99413: PLUS
99414: PUSH
99415: LD_VAR 0 2
99419: PUSH
99420: LD_INT 4
99422: PUSH
99423: EMPTY
99424: LIST
99425: LIST
99426: LIST
99427: PUSH
99428: LD_VAR 0 1
99432: PUSH
99433: LD_VAR 0 2
99437: PUSH
99438: LD_INT 3
99440: PLUS
99441: PUSH
99442: LD_INT 0
99444: PUSH
99445: EMPTY
99446: LIST
99447: LIST
99448: LIST
99449: PUSH
99450: EMPTY
99451: LIST
99452: LIST
99453: LIST
99454: LIST
99455: LIST
99456: ST_TO_ADDR
// end ; end ;
99457: GO 99460
99459: POP
// result := list ;
99460: LD_ADDR_VAR 0 4
99464: PUSH
99465: LD_VAR 0 5
99469: ST_TO_ADDR
// end ;
99470: LD_VAR 0 4
99474: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
99475: LD_INT 0
99477: PPUSH
99478: PPUSH
99479: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
99480: LD_VAR 0 1
99484: NOT
99485: PUSH
99486: LD_VAR 0 2
99490: PUSH
99491: LD_INT 1
99493: PUSH
99494: LD_INT 2
99496: PUSH
99497: LD_INT 3
99499: PUSH
99500: LD_INT 4
99502: PUSH
99503: EMPTY
99504: LIST
99505: LIST
99506: LIST
99507: LIST
99508: IN
99509: NOT
99510: OR
99511: IFFALSE 99515
// exit ;
99513: GO 99607
// tmp := [ ] ;
99515: LD_ADDR_VAR 0 5
99519: PUSH
99520: EMPTY
99521: ST_TO_ADDR
// for i in units do
99522: LD_ADDR_VAR 0 4
99526: PUSH
99527: LD_VAR 0 1
99531: PUSH
99532: FOR_IN
99533: IFFALSE 99576
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
99535: LD_ADDR_VAR 0 5
99539: PUSH
99540: LD_VAR 0 5
99544: PPUSH
99545: LD_VAR 0 5
99549: PUSH
99550: LD_INT 1
99552: PLUS
99553: PPUSH
99554: LD_VAR 0 4
99558: PPUSH
99559: LD_VAR 0 2
99563: PPUSH
99564: CALL_OW 259
99568: PPUSH
99569: CALL_OW 2
99573: ST_TO_ADDR
99574: GO 99532
99576: POP
99577: POP
// if not tmp then
99578: LD_VAR 0 5
99582: NOT
99583: IFFALSE 99587
// exit ;
99585: GO 99607
// result := SortListByListDesc ( units , tmp ) ;
99587: LD_ADDR_VAR 0 3
99591: PUSH
99592: LD_VAR 0 1
99596: PPUSH
99597: LD_VAR 0 5
99601: PPUSH
99602: CALL_OW 77
99606: ST_TO_ADDR
// end ;
99607: LD_VAR 0 3
99611: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
99612: LD_INT 0
99614: PPUSH
99615: PPUSH
99616: PPUSH
// x := GetX ( building ) ;
99617: LD_ADDR_VAR 0 4
99621: PUSH
99622: LD_VAR 0 2
99626: PPUSH
99627: CALL_OW 250
99631: ST_TO_ADDR
// y := GetY ( building ) ;
99632: LD_ADDR_VAR 0 5
99636: PUSH
99637: LD_VAR 0 2
99641: PPUSH
99642: CALL_OW 251
99646: ST_TO_ADDR
// if GetTaskList ( unit ) then
99647: LD_VAR 0 1
99651: PPUSH
99652: CALL_OW 437
99656: IFFALSE 99751
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
99658: LD_STRING e
99660: PUSH
99661: LD_VAR 0 1
99665: PPUSH
99666: CALL_OW 437
99670: PUSH
99671: LD_INT 1
99673: ARRAY
99674: PUSH
99675: LD_INT 1
99677: ARRAY
99678: EQUAL
99679: PUSH
99680: LD_VAR 0 4
99684: PUSH
99685: LD_VAR 0 1
99689: PPUSH
99690: CALL_OW 437
99694: PUSH
99695: LD_INT 1
99697: ARRAY
99698: PUSH
99699: LD_INT 2
99701: ARRAY
99702: EQUAL
99703: AND
99704: PUSH
99705: LD_VAR 0 5
99709: PUSH
99710: LD_VAR 0 1
99714: PPUSH
99715: CALL_OW 437
99719: PUSH
99720: LD_INT 1
99722: ARRAY
99723: PUSH
99724: LD_INT 3
99726: ARRAY
99727: EQUAL
99728: AND
99729: IFFALSE 99741
// result := true else
99731: LD_ADDR_VAR 0 3
99735: PUSH
99736: LD_INT 1
99738: ST_TO_ADDR
99739: GO 99749
// result := false ;
99741: LD_ADDR_VAR 0 3
99745: PUSH
99746: LD_INT 0
99748: ST_TO_ADDR
// end else
99749: GO 99759
// result := false ;
99751: LD_ADDR_VAR 0 3
99755: PUSH
99756: LD_INT 0
99758: ST_TO_ADDR
// end ;
99759: LD_VAR 0 3
99763: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
99764: LD_INT 0
99766: PPUSH
99767: PPUSH
99768: PPUSH
99769: PPUSH
// if not unit or not area then
99770: LD_VAR 0 1
99774: NOT
99775: PUSH
99776: LD_VAR 0 2
99780: NOT
99781: OR
99782: IFFALSE 99786
// exit ;
99784: GO 99950
// tmp := AreaToList ( area , i ) ;
99786: LD_ADDR_VAR 0 6
99790: PUSH
99791: LD_VAR 0 2
99795: PPUSH
99796: LD_VAR 0 5
99800: PPUSH
99801: CALL_OW 517
99805: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
99806: LD_ADDR_VAR 0 5
99810: PUSH
99811: DOUBLE
99812: LD_INT 1
99814: DEC
99815: ST_TO_ADDR
99816: LD_VAR 0 6
99820: PUSH
99821: LD_INT 1
99823: ARRAY
99824: PUSH
99825: FOR_TO
99826: IFFALSE 99948
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
99828: LD_ADDR_VAR 0 7
99832: PUSH
99833: LD_VAR 0 6
99837: PUSH
99838: LD_INT 1
99840: ARRAY
99841: PUSH
99842: LD_VAR 0 5
99846: ARRAY
99847: PUSH
99848: LD_VAR 0 6
99852: PUSH
99853: LD_INT 2
99855: ARRAY
99856: PUSH
99857: LD_VAR 0 5
99861: ARRAY
99862: PUSH
99863: EMPTY
99864: LIST
99865: LIST
99866: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
99867: LD_VAR 0 7
99871: PUSH
99872: LD_INT 1
99874: ARRAY
99875: PPUSH
99876: LD_VAR 0 7
99880: PUSH
99881: LD_INT 2
99883: ARRAY
99884: PPUSH
99885: CALL_OW 428
99889: PUSH
99890: LD_INT 0
99892: EQUAL
99893: IFFALSE 99946
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
99895: LD_VAR 0 1
99899: PPUSH
99900: LD_VAR 0 7
99904: PUSH
99905: LD_INT 1
99907: ARRAY
99908: PPUSH
99909: LD_VAR 0 7
99913: PUSH
99914: LD_INT 2
99916: ARRAY
99917: PPUSH
99918: LD_VAR 0 3
99922: PPUSH
99923: CALL_OW 48
// result := IsPlaced ( unit ) ;
99927: LD_ADDR_VAR 0 4
99931: PUSH
99932: LD_VAR 0 1
99936: PPUSH
99937: CALL_OW 305
99941: ST_TO_ADDR
// exit ;
99942: POP
99943: POP
99944: GO 99950
// end ; end ;
99946: GO 99825
99948: POP
99949: POP
// end ;
99950: LD_VAR 0 4
99954: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
99955: LD_INT 0
99957: PPUSH
99958: PPUSH
99959: PPUSH
// if not side or side > 8 then
99960: LD_VAR 0 1
99964: NOT
99965: PUSH
99966: LD_VAR 0 1
99970: PUSH
99971: LD_INT 8
99973: GREATER
99974: OR
99975: IFFALSE 99979
// exit ;
99977: GO 100166
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
99979: LD_ADDR_VAR 0 4
99983: PUSH
99984: LD_INT 22
99986: PUSH
99987: LD_VAR 0 1
99991: PUSH
99992: EMPTY
99993: LIST
99994: LIST
99995: PUSH
99996: LD_INT 21
99998: PUSH
99999: LD_INT 3
100001: PUSH
100002: EMPTY
100003: LIST
100004: LIST
100005: PUSH
100006: EMPTY
100007: LIST
100008: LIST
100009: PPUSH
100010: CALL_OW 69
100014: ST_TO_ADDR
// if not tmp then
100015: LD_VAR 0 4
100019: NOT
100020: IFFALSE 100024
// exit ;
100022: GO 100166
// enable_addtolog := true ;
100024: LD_ADDR_OWVAR 81
100028: PUSH
100029: LD_INT 1
100031: ST_TO_ADDR
// AddToLog ( [ ) ;
100032: LD_STRING [
100034: PPUSH
100035: CALL_OW 561
// for i in tmp do
100039: LD_ADDR_VAR 0 3
100043: PUSH
100044: LD_VAR 0 4
100048: PUSH
100049: FOR_IN
100050: IFFALSE 100157
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
100052: LD_STRING [
100054: PUSH
100055: LD_VAR 0 3
100059: PPUSH
100060: CALL_OW 266
100064: STR
100065: PUSH
100066: LD_STRING , 
100068: STR
100069: PUSH
100070: LD_VAR 0 3
100074: PPUSH
100075: CALL_OW 250
100079: STR
100080: PUSH
100081: LD_STRING , 
100083: STR
100084: PUSH
100085: LD_VAR 0 3
100089: PPUSH
100090: CALL_OW 251
100094: STR
100095: PUSH
100096: LD_STRING , 
100098: STR
100099: PUSH
100100: LD_VAR 0 3
100104: PPUSH
100105: CALL_OW 254
100109: STR
100110: PUSH
100111: LD_STRING , 
100113: STR
100114: PUSH
100115: LD_VAR 0 3
100119: PPUSH
100120: LD_INT 1
100122: PPUSH
100123: CALL_OW 268
100127: STR
100128: PUSH
100129: LD_STRING , 
100131: STR
100132: PUSH
100133: LD_VAR 0 3
100137: PPUSH
100138: LD_INT 2
100140: PPUSH
100141: CALL_OW 268
100145: STR
100146: PUSH
100147: LD_STRING ],
100149: STR
100150: PPUSH
100151: CALL_OW 561
// end ;
100155: GO 100049
100157: POP
100158: POP
// AddToLog ( ]; ) ;
100159: LD_STRING ];
100161: PPUSH
100162: CALL_OW 561
// end ;
100166: LD_VAR 0 2
100170: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
100171: LD_INT 0
100173: PPUSH
100174: PPUSH
100175: PPUSH
100176: PPUSH
100177: PPUSH
// if not area or not rate or not max then
100178: LD_VAR 0 1
100182: NOT
100183: PUSH
100184: LD_VAR 0 2
100188: NOT
100189: OR
100190: PUSH
100191: LD_VAR 0 4
100195: NOT
100196: OR
100197: IFFALSE 100201
// exit ;
100199: GO 100393
// while 1 do
100201: LD_INT 1
100203: IFFALSE 100393
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
100205: LD_ADDR_VAR 0 9
100209: PUSH
100210: LD_VAR 0 1
100214: PPUSH
100215: LD_INT 1
100217: PPUSH
100218: CALL_OW 287
100222: PUSH
100223: LD_INT 10
100225: MUL
100226: ST_TO_ADDR
// r := rate / 10 ;
100227: LD_ADDR_VAR 0 7
100231: PUSH
100232: LD_VAR 0 2
100236: PUSH
100237: LD_INT 10
100239: DIVREAL
100240: ST_TO_ADDR
// time := 1 1$00 ;
100241: LD_ADDR_VAR 0 8
100245: PUSH
100246: LD_INT 2100
100248: ST_TO_ADDR
// if amount < min then
100249: LD_VAR 0 9
100253: PUSH
100254: LD_VAR 0 3
100258: LESS
100259: IFFALSE 100277
// r := r * 2 else
100261: LD_ADDR_VAR 0 7
100265: PUSH
100266: LD_VAR 0 7
100270: PUSH
100271: LD_INT 2
100273: MUL
100274: ST_TO_ADDR
100275: GO 100303
// if amount > max then
100277: LD_VAR 0 9
100281: PUSH
100282: LD_VAR 0 4
100286: GREATER
100287: IFFALSE 100303
// r := r / 2 ;
100289: LD_ADDR_VAR 0 7
100293: PUSH
100294: LD_VAR 0 7
100298: PUSH
100299: LD_INT 2
100301: DIVREAL
100302: ST_TO_ADDR
// time := time / r ;
100303: LD_ADDR_VAR 0 8
100307: PUSH
100308: LD_VAR 0 8
100312: PUSH
100313: LD_VAR 0 7
100317: DIVREAL
100318: ST_TO_ADDR
// if time < 0 then
100319: LD_VAR 0 8
100323: PUSH
100324: LD_INT 0
100326: LESS
100327: IFFALSE 100344
// time := time * - 1 ;
100329: LD_ADDR_VAR 0 8
100333: PUSH
100334: LD_VAR 0 8
100338: PUSH
100339: LD_INT 1
100341: NEG
100342: MUL
100343: ST_TO_ADDR
// wait ( time ) ;
100344: LD_VAR 0 8
100348: PPUSH
100349: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
100353: LD_INT 35
100355: PPUSH
100356: LD_INT 875
100358: PPUSH
100359: CALL_OW 12
100363: PPUSH
100364: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
100368: LD_INT 1
100370: PPUSH
100371: LD_INT 5
100373: PPUSH
100374: CALL_OW 12
100378: PPUSH
100379: LD_VAR 0 1
100383: PPUSH
100384: LD_INT 1
100386: PPUSH
100387: CALL_OW 55
// end ;
100391: GO 100201
// end ;
100393: LD_VAR 0 5
100397: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
100398: LD_INT 0
100400: PPUSH
100401: PPUSH
100402: PPUSH
100403: PPUSH
100404: PPUSH
100405: PPUSH
100406: PPUSH
100407: PPUSH
// if not turrets or not factories then
100408: LD_VAR 0 1
100412: NOT
100413: PUSH
100414: LD_VAR 0 2
100418: NOT
100419: OR
100420: IFFALSE 100424
// exit ;
100422: GO 100731
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
100424: LD_ADDR_VAR 0 10
100428: PUSH
100429: LD_INT 5
100431: PUSH
100432: LD_INT 6
100434: PUSH
100435: EMPTY
100436: LIST
100437: LIST
100438: PUSH
100439: LD_INT 2
100441: PUSH
100442: LD_INT 4
100444: PUSH
100445: EMPTY
100446: LIST
100447: LIST
100448: PUSH
100449: LD_INT 3
100451: PUSH
100452: LD_INT 5
100454: PUSH
100455: EMPTY
100456: LIST
100457: LIST
100458: PUSH
100459: EMPTY
100460: LIST
100461: LIST
100462: LIST
100463: PUSH
100464: LD_INT 24
100466: PUSH
100467: LD_INT 25
100469: PUSH
100470: EMPTY
100471: LIST
100472: LIST
100473: PUSH
100474: LD_INT 23
100476: PUSH
100477: LD_INT 27
100479: PUSH
100480: EMPTY
100481: LIST
100482: LIST
100483: PUSH
100484: EMPTY
100485: LIST
100486: LIST
100487: PUSH
100488: LD_INT 42
100490: PUSH
100491: LD_INT 43
100493: PUSH
100494: EMPTY
100495: LIST
100496: LIST
100497: PUSH
100498: LD_INT 44
100500: PUSH
100501: LD_INT 46
100503: PUSH
100504: EMPTY
100505: LIST
100506: LIST
100507: PUSH
100508: LD_INT 45
100510: PUSH
100511: LD_INT 47
100513: PUSH
100514: EMPTY
100515: LIST
100516: LIST
100517: PUSH
100518: EMPTY
100519: LIST
100520: LIST
100521: LIST
100522: PUSH
100523: EMPTY
100524: LIST
100525: LIST
100526: LIST
100527: ST_TO_ADDR
// result := [ ] ;
100528: LD_ADDR_VAR 0 3
100532: PUSH
100533: EMPTY
100534: ST_TO_ADDR
// for i in turrets do
100535: LD_ADDR_VAR 0 4
100539: PUSH
100540: LD_VAR 0 1
100544: PUSH
100545: FOR_IN
100546: IFFALSE 100729
// begin nat := GetNation ( i ) ;
100548: LD_ADDR_VAR 0 7
100552: PUSH
100553: LD_VAR 0 4
100557: PPUSH
100558: CALL_OW 248
100562: ST_TO_ADDR
// weapon := 0 ;
100563: LD_ADDR_VAR 0 8
100567: PUSH
100568: LD_INT 0
100570: ST_TO_ADDR
// if not nat then
100571: LD_VAR 0 7
100575: NOT
100576: IFFALSE 100580
// continue ;
100578: GO 100545
// for j in list [ nat ] do
100580: LD_ADDR_VAR 0 5
100584: PUSH
100585: LD_VAR 0 10
100589: PUSH
100590: LD_VAR 0 7
100594: ARRAY
100595: PUSH
100596: FOR_IN
100597: IFFALSE 100638
// if GetBWeapon ( i ) = j [ 1 ] then
100599: LD_VAR 0 4
100603: PPUSH
100604: CALL_OW 269
100608: PUSH
100609: LD_VAR 0 5
100613: PUSH
100614: LD_INT 1
100616: ARRAY
100617: EQUAL
100618: IFFALSE 100636
// begin weapon := j [ 2 ] ;
100620: LD_ADDR_VAR 0 8
100624: PUSH
100625: LD_VAR 0 5
100629: PUSH
100630: LD_INT 2
100632: ARRAY
100633: ST_TO_ADDR
// break ;
100634: GO 100638
// end ;
100636: GO 100596
100638: POP
100639: POP
// if not weapon then
100640: LD_VAR 0 8
100644: NOT
100645: IFFALSE 100649
// continue ;
100647: GO 100545
// for k in factories do
100649: LD_ADDR_VAR 0 6
100653: PUSH
100654: LD_VAR 0 2
100658: PUSH
100659: FOR_IN
100660: IFFALSE 100725
// begin weapons := AvailableWeaponList ( k ) ;
100662: LD_ADDR_VAR 0 9
100666: PUSH
100667: LD_VAR 0 6
100671: PPUSH
100672: CALL_OW 478
100676: ST_TO_ADDR
// if not weapons then
100677: LD_VAR 0 9
100681: NOT
100682: IFFALSE 100686
// continue ;
100684: GO 100659
// if weapon in weapons then
100686: LD_VAR 0 8
100690: PUSH
100691: LD_VAR 0 9
100695: IN
100696: IFFALSE 100723
// begin result := [ i , weapon ] ;
100698: LD_ADDR_VAR 0 3
100702: PUSH
100703: LD_VAR 0 4
100707: PUSH
100708: LD_VAR 0 8
100712: PUSH
100713: EMPTY
100714: LIST
100715: LIST
100716: ST_TO_ADDR
// exit ;
100717: POP
100718: POP
100719: POP
100720: POP
100721: GO 100731
// end ; end ;
100723: GO 100659
100725: POP
100726: POP
// end ;
100727: GO 100545
100729: POP
100730: POP
// end ;
100731: LD_VAR 0 3
100735: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
100736: LD_INT 0
100738: PPUSH
// if not side or side > 8 then
100739: LD_VAR 0 3
100743: NOT
100744: PUSH
100745: LD_VAR 0 3
100749: PUSH
100750: LD_INT 8
100752: GREATER
100753: OR
100754: IFFALSE 100758
// exit ;
100756: GO 100817
// if not range then
100758: LD_VAR 0 4
100762: NOT
100763: IFFALSE 100774
// range := - 12 ;
100765: LD_ADDR_VAR 0 4
100769: PUSH
100770: LD_INT 12
100772: NEG
100773: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
100774: LD_VAR 0 1
100778: PPUSH
100779: LD_VAR 0 2
100783: PPUSH
100784: LD_VAR 0 3
100788: PPUSH
100789: LD_VAR 0 4
100793: PPUSH
100794: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
100798: LD_VAR 0 1
100802: PPUSH
100803: LD_VAR 0 2
100807: PPUSH
100808: LD_VAR 0 3
100812: PPUSH
100813: CALL_OW 331
// end ;
100817: LD_VAR 0 5
100821: RET
// export function Video ( mode ) ; begin
100822: LD_INT 0
100824: PPUSH
// ingame_video = mode ;
100825: LD_ADDR_OWVAR 52
100829: PUSH
100830: LD_VAR 0 1
100834: ST_TO_ADDR
// interface_hidden = mode ;
100835: LD_ADDR_OWVAR 54
100839: PUSH
100840: LD_VAR 0 1
100844: ST_TO_ADDR
// end ;
100845: LD_VAR 0 2
100849: RET
// export function Join ( array , element ) ; begin
100850: LD_INT 0
100852: PPUSH
// result := array ^ element ;
100853: LD_ADDR_VAR 0 3
100857: PUSH
100858: LD_VAR 0 1
100862: PUSH
100863: LD_VAR 0 2
100867: ADD
100868: ST_TO_ADDR
// end ;
100869: LD_VAR 0 3
100873: RET
// export function JoinUnion ( array , element ) ; begin
100874: LD_INT 0
100876: PPUSH
// result := array union element ;
100877: LD_ADDR_VAR 0 3
100881: PUSH
100882: LD_VAR 0 1
100886: PUSH
100887: LD_VAR 0 2
100891: UNION
100892: ST_TO_ADDR
// end ;
100893: LD_VAR 0 3
100897: RET
// export function GetBehemoths ( side ) ; begin
100898: LD_INT 0
100900: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
100901: LD_ADDR_VAR 0 2
100905: PUSH
100906: LD_INT 22
100908: PUSH
100909: LD_VAR 0 1
100913: PUSH
100914: EMPTY
100915: LIST
100916: LIST
100917: PUSH
100918: LD_INT 31
100920: PUSH
100921: LD_INT 25
100923: PUSH
100924: EMPTY
100925: LIST
100926: LIST
100927: PUSH
100928: EMPTY
100929: LIST
100930: LIST
100931: PPUSH
100932: CALL_OW 69
100936: ST_TO_ADDR
// end ;
100937: LD_VAR 0 2
100941: RET
// export function Shuffle ( array ) ; var i , index ; begin
100942: LD_INT 0
100944: PPUSH
100945: PPUSH
100946: PPUSH
// result := [ ] ;
100947: LD_ADDR_VAR 0 2
100951: PUSH
100952: EMPTY
100953: ST_TO_ADDR
// if not array then
100954: LD_VAR 0 1
100958: NOT
100959: IFFALSE 100963
// exit ;
100961: GO 101062
// Randomize ;
100963: CALL_OW 10
// for i = array downto 1 do
100967: LD_ADDR_VAR 0 3
100971: PUSH
100972: DOUBLE
100973: LD_VAR 0 1
100977: INC
100978: ST_TO_ADDR
100979: LD_INT 1
100981: PUSH
100982: FOR_DOWNTO
100983: IFFALSE 101060
// begin index := rand ( 1 , array ) ;
100985: LD_ADDR_VAR 0 4
100989: PUSH
100990: LD_INT 1
100992: PPUSH
100993: LD_VAR 0 1
100997: PPUSH
100998: CALL_OW 12
101002: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
101003: LD_ADDR_VAR 0 2
101007: PUSH
101008: LD_VAR 0 2
101012: PPUSH
101013: LD_VAR 0 2
101017: PUSH
101018: LD_INT 1
101020: PLUS
101021: PPUSH
101022: LD_VAR 0 1
101026: PUSH
101027: LD_VAR 0 4
101031: ARRAY
101032: PPUSH
101033: CALL_OW 2
101037: ST_TO_ADDR
// array := Delete ( array , index ) ;
101038: LD_ADDR_VAR 0 1
101042: PUSH
101043: LD_VAR 0 1
101047: PPUSH
101048: LD_VAR 0 4
101052: PPUSH
101053: CALL_OW 3
101057: ST_TO_ADDR
// end ;
101058: GO 100982
101060: POP
101061: POP
// end ;
101062: LD_VAR 0 2
101066: RET
// export function GetBaseMaterials ( base ) ; begin
101067: LD_INT 0
101069: PPUSH
// result := [ 0 , 0 , 0 ] ;
101070: LD_ADDR_VAR 0 2
101074: PUSH
101075: LD_INT 0
101077: PUSH
101078: LD_INT 0
101080: PUSH
101081: LD_INT 0
101083: PUSH
101084: EMPTY
101085: LIST
101086: LIST
101087: LIST
101088: ST_TO_ADDR
// if not base then
101089: LD_VAR 0 1
101093: NOT
101094: IFFALSE 101098
// exit ;
101096: GO 101147
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
101098: LD_ADDR_VAR 0 2
101102: PUSH
101103: LD_VAR 0 1
101107: PPUSH
101108: LD_INT 1
101110: PPUSH
101111: CALL_OW 275
101115: PUSH
101116: LD_VAR 0 1
101120: PPUSH
101121: LD_INT 2
101123: PPUSH
101124: CALL_OW 275
101128: PUSH
101129: LD_VAR 0 1
101133: PPUSH
101134: LD_INT 3
101136: PPUSH
101137: CALL_OW 275
101141: PUSH
101142: EMPTY
101143: LIST
101144: LIST
101145: LIST
101146: ST_TO_ADDR
// end ; end_of_file end_of_file
101147: LD_VAR 0 2
101151: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
101152: GO 101154
101154: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
101155: LD_STRING initStreamRollete();
101157: PPUSH
101158: CALL_OW 559
// InitStreamMode ;
101162: CALL 101171 0 0
// DefineStreamItems ( ) ;
101166: CALL 101611 0 0
// end ;
101170: END
// function InitStreamMode ; begin
101171: LD_INT 0
101173: PPUSH
// streamModeActive := false ;
101174: LD_ADDR_EXP 153
101178: PUSH
101179: LD_INT 0
101181: ST_TO_ADDR
// normalCounter := 36 ;
101182: LD_ADDR_EXP 154
101186: PUSH
101187: LD_INT 36
101189: ST_TO_ADDR
// hardcoreCounter := 16 ;
101190: LD_ADDR_EXP 155
101194: PUSH
101195: LD_INT 16
101197: ST_TO_ADDR
// sRocket := false ;
101198: LD_ADDR_EXP 158
101202: PUSH
101203: LD_INT 0
101205: ST_TO_ADDR
// sSpeed := false ;
101206: LD_ADDR_EXP 157
101210: PUSH
101211: LD_INT 0
101213: ST_TO_ADDR
// sEngine := false ;
101214: LD_ADDR_EXP 159
101218: PUSH
101219: LD_INT 0
101221: ST_TO_ADDR
// sSpec := false ;
101222: LD_ADDR_EXP 156
101226: PUSH
101227: LD_INT 0
101229: ST_TO_ADDR
// sLevel := false ;
101230: LD_ADDR_EXP 160
101234: PUSH
101235: LD_INT 0
101237: ST_TO_ADDR
// sArmoury := false ;
101238: LD_ADDR_EXP 161
101242: PUSH
101243: LD_INT 0
101245: ST_TO_ADDR
// sRadar := false ;
101246: LD_ADDR_EXP 162
101250: PUSH
101251: LD_INT 0
101253: ST_TO_ADDR
// sBunker := false ;
101254: LD_ADDR_EXP 163
101258: PUSH
101259: LD_INT 0
101261: ST_TO_ADDR
// sHack := false ;
101262: LD_ADDR_EXP 164
101266: PUSH
101267: LD_INT 0
101269: ST_TO_ADDR
// sFire := false ;
101270: LD_ADDR_EXP 165
101274: PUSH
101275: LD_INT 0
101277: ST_TO_ADDR
// sRefresh := false ;
101278: LD_ADDR_EXP 166
101282: PUSH
101283: LD_INT 0
101285: ST_TO_ADDR
// sExp := false ;
101286: LD_ADDR_EXP 167
101290: PUSH
101291: LD_INT 0
101293: ST_TO_ADDR
// sDepot := false ;
101294: LD_ADDR_EXP 168
101298: PUSH
101299: LD_INT 0
101301: ST_TO_ADDR
// sFlag := false ;
101302: LD_ADDR_EXP 169
101306: PUSH
101307: LD_INT 0
101309: ST_TO_ADDR
// sKamikadze := false ;
101310: LD_ADDR_EXP 177
101314: PUSH
101315: LD_INT 0
101317: ST_TO_ADDR
// sTroll := false ;
101318: LD_ADDR_EXP 178
101322: PUSH
101323: LD_INT 0
101325: ST_TO_ADDR
// sSlow := false ;
101326: LD_ADDR_EXP 179
101330: PUSH
101331: LD_INT 0
101333: ST_TO_ADDR
// sLack := false ;
101334: LD_ADDR_EXP 180
101338: PUSH
101339: LD_INT 0
101341: ST_TO_ADDR
// sTank := false ;
101342: LD_ADDR_EXP 182
101346: PUSH
101347: LD_INT 0
101349: ST_TO_ADDR
// sRemote := false ;
101350: LD_ADDR_EXP 183
101354: PUSH
101355: LD_INT 0
101357: ST_TO_ADDR
// sPowell := false ;
101358: LD_ADDR_EXP 184
101362: PUSH
101363: LD_INT 0
101365: ST_TO_ADDR
// sTeleport := false ;
101366: LD_ADDR_EXP 187
101370: PUSH
101371: LD_INT 0
101373: ST_TO_ADDR
// sOilTower := false ;
101374: LD_ADDR_EXP 189
101378: PUSH
101379: LD_INT 0
101381: ST_TO_ADDR
// sShovel := false ;
101382: LD_ADDR_EXP 190
101386: PUSH
101387: LD_INT 0
101389: ST_TO_ADDR
// sSheik := false ;
101390: LD_ADDR_EXP 191
101394: PUSH
101395: LD_INT 0
101397: ST_TO_ADDR
// sEarthquake := false ;
101398: LD_ADDR_EXP 193
101402: PUSH
101403: LD_INT 0
101405: ST_TO_ADDR
// sAI := false ;
101406: LD_ADDR_EXP 194
101410: PUSH
101411: LD_INT 0
101413: ST_TO_ADDR
// sCargo := false ;
101414: LD_ADDR_EXP 197
101418: PUSH
101419: LD_INT 0
101421: ST_TO_ADDR
// sDLaser := false ;
101422: LD_ADDR_EXP 198
101426: PUSH
101427: LD_INT 0
101429: ST_TO_ADDR
// sExchange := false ;
101430: LD_ADDR_EXP 199
101434: PUSH
101435: LD_INT 0
101437: ST_TO_ADDR
// sFac := false ;
101438: LD_ADDR_EXP 200
101442: PUSH
101443: LD_INT 0
101445: ST_TO_ADDR
// sPower := false ;
101446: LD_ADDR_EXP 201
101450: PUSH
101451: LD_INT 0
101453: ST_TO_ADDR
// sRandom := false ;
101454: LD_ADDR_EXP 202
101458: PUSH
101459: LD_INT 0
101461: ST_TO_ADDR
// sShield := false ;
101462: LD_ADDR_EXP 203
101466: PUSH
101467: LD_INT 0
101469: ST_TO_ADDR
// sTime := false ;
101470: LD_ADDR_EXP 204
101474: PUSH
101475: LD_INT 0
101477: ST_TO_ADDR
// sTools := false ;
101478: LD_ADDR_EXP 205
101482: PUSH
101483: LD_INT 0
101485: ST_TO_ADDR
// sSold := false ;
101486: LD_ADDR_EXP 170
101490: PUSH
101491: LD_INT 0
101493: ST_TO_ADDR
// sDiff := false ;
101494: LD_ADDR_EXP 171
101498: PUSH
101499: LD_INT 0
101501: ST_TO_ADDR
// sFog := false ;
101502: LD_ADDR_EXP 174
101506: PUSH
101507: LD_INT 0
101509: ST_TO_ADDR
// sReset := false ;
101510: LD_ADDR_EXP 175
101514: PUSH
101515: LD_INT 0
101517: ST_TO_ADDR
// sSun := false ;
101518: LD_ADDR_EXP 176
101522: PUSH
101523: LD_INT 0
101525: ST_TO_ADDR
// sTiger := false ;
101526: LD_ADDR_EXP 172
101530: PUSH
101531: LD_INT 0
101533: ST_TO_ADDR
// sBomb := false ;
101534: LD_ADDR_EXP 173
101538: PUSH
101539: LD_INT 0
101541: ST_TO_ADDR
// sWound := false ;
101542: LD_ADDR_EXP 181
101546: PUSH
101547: LD_INT 0
101549: ST_TO_ADDR
// sBetray := false ;
101550: LD_ADDR_EXP 185
101554: PUSH
101555: LD_INT 0
101557: ST_TO_ADDR
// sContamin := false ;
101558: LD_ADDR_EXP 186
101562: PUSH
101563: LD_INT 0
101565: ST_TO_ADDR
// sOil := false ;
101566: LD_ADDR_EXP 188
101570: PUSH
101571: LD_INT 0
101573: ST_TO_ADDR
// sStu := false ;
101574: LD_ADDR_EXP 192
101578: PUSH
101579: LD_INT 0
101581: ST_TO_ADDR
// sBazooka := false ;
101582: LD_ADDR_EXP 195
101586: PUSH
101587: LD_INT 0
101589: ST_TO_ADDR
// sMortar := false ;
101590: LD_ADDR_EXP 196
101594: PUSH
101595: LD_INT 0
101597: ST_TO_ADDR
// sRanger := false ;
101598: LD_ADDR_EXP 206
101602: PUSH
101603: LD_INT 0
101605: ST_TO_ADDR
// end ;
101606: LD_VAR 0 1
101610: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
101611: LD_INT 0
101613: PPUSH
101614: PPUSH
101615: PPUSH
101616: PPUSH
101617: PPUSH
// result := [ ] ;
101618: LD_ADDR_VAR 0 1
101622: PUSH
101623: EMPTY
101624: ST_TO_ADDR
// if campaign_id = 1 then
101625: LD_OWVAR 69
101629: PUSH
101630: LD_INT 1
101632: EQUAL
101633: IFFALSE 104571
// begin case mission_number of 1 :
101635: LD_OWVAR 70
101639: PUSH
101640: LD_INT 1
101642: DOUBLE
101643: EQUAL
101644: IFTRUE 101648
101646: GO 101712
101648: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
101649: LD_ADDR_VAR 0 1
101653: PUSH
101654: LD_INT 2
101656: PUSH
101657: LD_INT 4
101659: PUSH
101660: LD_INT 11
101662: PUSH
101663: LD_INT 12
101665: PUSH
101666: LD_INT 15
101668: PUSH
101669: LD_INT 16
101671: PUSH
101672: LD_INT 22
101674: PUSH
101675: LD_INT 23
101677: PUSH
101678: LD_INT 26
101680: PUSH
101681: EMPTY
101682: LIST
101683: LIST
101684: LIST
101685: LIST
101686: LIST
101687: LIST
101688: LIST
101689: LIST
101690: LIST
101691: PUSH
101692: LD_INT 101
101694: PUSH
101695: LD_INT 102
101697: PUSH
101698: LD_INT 106
101700: PUSH
101701: EMPTY
101702: LIST
101703: LIST
101704: LIST
101705: PUSH
101706: EMPTY
101707: LIST
101708: LIST
101709: ST_TO_ADDR
101710: GO 104569
101712: LD_INT 2
101714: DOUBLE
101715: EQUAL
101716: IFTRUE 101720
101718: GO 101792
101720: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
101721: LD_ADDR_VAR 0 1
101725: PUSH
101726: LD_INT 2
101728: PUSH
101729: LD_INT 4
101731: PUSH
101732: LD_INT 11
101734: PUSH
101735: LD_INT 12
101737: PUSH
101738: LD_INT 15
101740: PUSH
101741: LD_INT 16
101743: PUSH
101744: LD_INT 22
101746: PUSH
101747: LD_INT 23
101749: PUSH
101750: LD_INT 26
101752: PUSH
101753: EMPTY
101754: LIST
101755: LIST
101756: LIST
101757: LIST
101758: LIST
101759: LIST
101760: LIST
101761: LIST
101762: LIST
101763: PUSH
101764: LD_INT 101
101766: PUSH
101767: LD_INT 102
101769: PUSH
101770: LD_INT 105
101772: PUSH
101773: LD_INT 106
101775: PUSH
101776: LD_INT 108
101778: PUSH
101779: EMPTY
101780: LIST
101781: LIST
101782: LIST
101783: LIST
101784: LIST
101785: PUSH
101786: EMPTY
101787: LIST
101788: LIST
101789: ST_TO_ADDR
101790: GO 104569
101792: LD_INT 3
101794: DOUBLE
101795: EQUAL
101796: IFTRUE 101800
101798: GO 101876
101800: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
101801: LD_ADDR_VAR 0 1
101805: PUSH
101806: LD_INT 2
101808: PUSH
101809: LD_INT 4
101811: PUSH
101812: LD_INT 5
101814: PUSH
101815: LD_INT 11
101817: PUSH
101818: LD_INT 12
101820: PUSH
101821: LD_INT 15
101823: PUSH
101824: LD_INT 16
101826: PUSH
101827: LD_INT 22
101829: PUSH
101830: LD_INT 26
101832: PUSH
101833: LD_INT 36
101835: PUSH
101836: EMPTY
101837: LIST
101838: LIST
101839: LIST
101840: LIST
101841: LIST
101842: LIST
101843: LIST
101844: LIST
101845: LIST
101846: LIST
101847: PUSH
101848: LD_INT 101
101850: PUSH
101851: LD_INT 102
101853: PUSH
101854: LD_INT 105
101856: PUSH
101857: LD_INT 106
101859: PUSH
101860: LD_INT 108
101862: PUSH
101863: EMPTY
101864: LIST
101865: LIST
101866: LIST
101867: LIST
101868: LIST
101869: PUSH
101870: EMPTY
101871: LIST
101872: LIST
101873: ST_TO_ADDR
101874: GO 104569
101876: LD_INT 4
101878: DOUBLE
101879: EQUAL
101880: IFTRUE 101884
101882: GO 101968
101884: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
101885: LD_ADDR_VAR 0 1
101889: PUSH
101890: LD_INT 2
101892: PUSH
101893: LD_INT 4
101895: PUSH
101896: LD_INT 5
101898: PUSH
101899: LD_INT 8
101901: PUSH
101902: LD_INT 11
101904: PUSH
101905: LD_INT 12
101907: PUSH
101908: LD_INT 15
101910: PUSH
101911: LD_INT 16
101913: PUSH
101914: LD_INT 22
101916: PUSH
101917: LD_INT 23
101919: PUSH
101920: LD_INT 26
101922: PUSH
101923: LD_INT 36
101925: PUSH
101926: EMPTY
101927: LIST
101928: LIST
101929: LIST
101930: LIST
101931: LIST
101932: LIST
101933: LIST
101934: LIST
101935: LIST
101936: LIST
101937: LIST
101938: LIST
101939: PUSH
101940: LD_INT 101
101942: PUSH
101943: LD_INT 102
101945: PUSH
101946: LD_INT 105
101948: PUSH
101949: LD_INT 106
101951: PUSH
101952: LD_INT 108
101954: PUSH
101955: EMPTY
101956: LIST
101957: LIST
101958: LIST
101959: LIST
101960: LIST
101961: PUSH
101962: EMPTY
101963: LIST
101964: LIST
101965: ST_TO_ADDR
101966: GO 104569
101968: LD_INT 5
101970: DOUBLE
101971: EQUAL
101972: IFTRUE 101976
101974: GO 102076
101976: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
101977: LD_ADDR_VAR 0 1
101981: PUSH
101982: LD_INT 2
101984: PUSH
101985: LD_INT 4
101987: PUSH
101988: LD_INT 5
101990: PUSH
101991: LD_INT 6
101993: PUSH
101994: LD_INT 8
101996: PUSH
101997: LD_INT 11
101999: PUSH
102000: LD_INT 12
102002: PUSH
102003: LD_INT 15
102005: PUSH
102006: LD_INT 16
102008: PUSH
102009: LD_INT 22
102011: PUSH
102012: LD_INT 23
102014: PUSH
102015: LD_INT 25
102017: PUSH
102018: LD_INT 26
102020: PUSH
102021: LD_INT 36
102023: PUSH
102024: EMPTY
102025: LIST
102026: LIST
102027: LIST
102028: LIST
102029: LIST
102030: LIST
102031: LIST
102032: LIST
102033: LIST
102034: LIST
102035: LIST
102036: LIST
102037: LIST
102038: LIST
102039: PUSH
102040: LD_INT 101
102042: PUSH
102043: LD_INT 102
102045: PUSH
102046: LD_INT 105
102048: PUSH
102049: LD_INT 106
102051: PUSH
102052: LD_INT 108
102054: PUSH
102055: LD_INT 109
102057: PUSH
102058: LD_INT 112
102060: PUSH
102061: EMPTY
102062: LIST
102063: LIST
102064: LIST
102065: LIST
102066: LIST
102067: LIST
102068: LIST
102069: PUSH
102070: EMPTY
102071: LIST
102072: LIST
102073: ST_TO_ADDR
102074: GO 104569
102076: LD_INT 6
102078: DOUBLE
102079: EQUAL
102080: IFTRUE 102084
102082: GO 102204
102084: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
102085: LD_ADDR_VAR 0 1
102089: PUSH
102090: LD_INT 2
102092: PUSH
102093: LD_INT 4
102095: PUSH
102096: LD_INT 5
102098: PUSH
102099: LD_INT 6
102101: PUSH
102102: LD_INT 8
102104: PUSH
102105: LD_INT 11
102107: PUSH
102108: LD_INT 12
102110: PUSH
102111: LD_INT 15
102113: PUSH
102114: LD_INT 16
102116: PUSH
102117: LD_INT 20
102119: PUSH
102120: LD_INT 21
102122: PUSH
102123: LD_INT 22
102125: PUSH
102126: LD_INT 23
102128: PUSH
102129: LD_INT 25
102131: PUSH
102132: LD_INT 26
102134: PUSH
102135: LD_INT 30
102137: PUSH
102138: LD_INT 31
102140: PUSH
102141: LD_INT 32
102143: PUSH
102144: LD_INT 36
102146: PUSH
102147: EMPTY
102148: LIST
102149: LIST
102150: LIST
102151: LIST
102152: LIST
102153: LIST
102154: LIST
102155: LIST
102156: LIST
102157: LIST
102158: LIST
102159: LIST
102160: LIST
102161: LIST
102162: LIST
102163: LIST
102164: LIST
102165: LIST
102166: LIST
102167: PUSH
102168: LD_INT 101
102170: PUSH
102171: LD_INT 102
102173: PUSH
102174: LD_INT 105
102176: PUSH
102177: LD_INT 106
102179: PUSH
102180: LD_INT 108
102182: PUSH
102183: LD_INT 109
102185: PUSH
102186: LD_INT 112
102188: PUSH
102189: EMPTY
102190: LIST
102191: LIST
102192: LIST
102193: LIST
102194: LIST
102195: LIST
102196: LIST
102197: PUSH
102198: EMPTY
102199: LIST
102200: LIST
102201: ST_TO_ADDR
102202: GO 104569
102204: LD_INT 7
102206: DOUBLE
102207: EQUAL
102208: IFTRUE 102212
102210: GO 102312
102212: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
102213: LD_ADDR_VAR 0 1
102217: PUSH
102218: LD_INT 2
102220: PUSH
102221: LD_INT 4
102223: PUSH
102224: LD_INT 5
102226: PUSH
102227: LD_INT 7
102229: PUSH
102230: LD_INT 11
102232: PUSH
102233: LD_INT 12
102235: PUSH
102236: LD_INT 15
102238: PUSH
102239: LD_INT 16
102241: PUSH
102242: LD_INT 20
102244: PUSH
102245: LD_INT 21
102247: PUSH
102248: LD_INT 22
102250: PUSH
102251: LD_INT 23
102253: PUSH
102254: LD_INT 25
102256: PUSH
102257: LD_INT 26
102259: PUSH
102260: EMPTY
102261: LIST
102262: LIST
102263: LIST
102264: LIST
102265: LIST
102266: LIST
102267: LIST
102268: LIST
102269: LIST
102270: LIST
102271: LIST
102272: LIST
102273: LIST
102274: LIST
102275: PUSH
102276: LD_INT 101
102278: PUSH
102279: LD_INT 102
102281: PUSH
102282: LD_INT 103
102284: PUSH
102285: LD_INT 105
102287: PUSH
102288: LD_INT 106
102290: PUSH
102291: LD_INT 108
102293: PUSH
102294: LD_INT 112
102296: PUSH
102297: EMPTY
102298: LIST
102299: LIST
102300: LIST
102301: LIST
102302: LIST
102303: LIST
102304: LIST
102305: PUSH
102306: EMPTY
102307: LIST
102308: LIST
102309: ST_TO_ADDR
102310: GO 104569
102312: LD_INT 8
102314: DOUBLE
102315: EQUAL
102316: IFTRUE 102320
102318: GO 102448
102320: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
102321: LD_ADDR_VAR 0 1
102325: PUSH
102326: LD_INT 2
102328: PUSH
102329: LD_INT 4
102331: PUSH
102332: LD_INT 5
102334: PUSH
102335: LD_INT 6
102337: PUSH
102338: LD_INT 7
102340: PUSH
102341: LD_INT 8
102343: PUSH
102344: LD_INT 11
102346: PUSH
102347: LD_INT 12
102349: PUSH
102350: LD_INT 15
102352: PUSH
102353: LD_INT 16
102355: PUSH
102356: LD_INT 20
102358: PUSH
102359: LD_INT 21
102361: PUSH
102362: LD_INT 22
102364: PUSH
102365: LD_INT 23
102367: PUSH
102368: LD_INT 25
102370: PUSH
102371: LD_INT 26
102373: PUSH
102374: LD_INT 30
102376: PUSH
102377: LD_INT 31
102379: PUSH
102380: LD_INT 32
102382: PUSH
102383: LD_INT 36
102385: PUSH
102386: EMPTY
102387: LIST
102388: LIST
102389: LIST
102390: LIST
102391: LIST
102392: LIST
102393: LIST
102394: LIST
102395: LIST
102396: LIST
102397: LIST
102398: LIST
102399: LIST
102400: LIST
102401: LIST
102402: LIST
102403: LIST
102404: LIST
102405: LIST
102406: LIST
102407: PUSH
102408: LD_INT 101
102410: PUSH
102411: LD_INT 102
102413: PUSH
102414: LD_INT 103
102416: PUSH
102417: LD_INT 105
102419: PUSH
102420: LD_INT 106
102422: PUSH
102423: LD_INT 108
102425: PUSH
102426: LD_INT 109
102428: PUSH
102429: LD_INT 112
102431: PUSH
102432: EMPTY
102433: LIST
102434: LIST
102435: LIST
102436: LIST
102437: LIST
102438: LIST
102439: LIST
102440: LIST
102441: PUSH
102442: EMPTY
102443: LIST
102444: LIST
102445: ST_TO_ADDR
102446: GO 104569
102448: LD_INT 9
102450: DOUBLE
102451: EQUAL
102452: IFTRUE 102456
102454: GO 102592
102456: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
102457: LD_ADDR_VAR 0 1
102461: PUSH
102462: LD_INT 2
102464: PUSH
102465: LD_INT 4
102467: PUSH
102468: LD_INT 5
102470: PUSH
102471: LD_INT 6
102473: PUSH
102474: LD_INT 7
102476: PUSH
102477: LD_INT 8
102479: PUSH
102480: LD_INT 11
102482: PUSH
102483: LD_INT 12
102485: PUSH
102486: LD_INT 15
102488: PUSH
102489: LD_INT 16
102491: PUSH
102492: LD_INT 20
102494: PUSH
102495: LD_INT 21
102497: PUSH
102498: LD_INT 22
102500: PUSH
102501: LD_INT 23
102503: PUSH
102504: LD_INT 25
102506: PUSH
102507: LD_INT 26
102509: PUSH
102510: LD_INT 28
102512: PUSH
102513: LD_INT 30
102515: PUSH
102516: LD_INT 31
102518: PUSH
102519: LD_INT 32
102521: PUSH
102522: LD_INT 36
102524: PUSH
102525: EMPTY
102526: LIST
102527: LIST
102528: LIST
102529: LIST
102530: LIST
102531: LIST
102532: LIST
102533: LIST
102534: LIST
102535: LIST
102536: LIST
102537: LIST
102538: LIST
102539: LIST
102540: LIST
102541: LIST
102542: LIST
102543: LIST
102544: LIST
102545: LIST
102546: LIST
102547: PUSH
102548: LD_INT 101
102550: PUSH
102551: LD_INT 102
102553: PUSH
102554: LD_INT 103
102556: PUSH
102557: LD_INT 105
102559: PUSH
102560: LD_INT 106
102562: PUSH
102563: LD_INT 108
102565: PUSH
102566: LD_INT 109
102568: PUSH
102569: LD_INT 112
102571: PUSH
102572: LD_INT 114
102574: PUSH
102575: EMPTY
102576: LIST
102577: LIST
102578: LIST
102579: LIST
102580: LIST
102581: LIST
102582: LIST
102583: LIST
102584: LIST
102585: PUSH
102586: EMPTY
102587: LIST
102588: LIST
102589: ST_TO_ADDR
102590: GO 104569
102592: LD_INT 10
102594: DOUBLE
102595: EQUAL
102596: IFTRUE 102600
102598: GO 102784
102600: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
102601: LD_ADDR_VAR 0 1
102605: PUSH
102606: LD_INT 2
102608: PUSH
102609: LD_INT 4
102611: PUSH
102612: LD_INT 5
102614: PUSH
102615: LD_INT 6
102617: PUSH
102618: LD_INT 7
102620: PUSH
102621: LD_INT 8
102623: PUSH
102624: LD_INT 9
102626: PUSH
102627: LD_INT 10
102629: PUSH
102630: LD_INT 11
102632: PUSH
102633: LD_INT 12
102635: PUSH
102636: LD_INT 13
102638: PUSH
102639: LD_INT 14
102641: PUSH
102642: LD_INT 15
102644: PUSH
102645: LD_INT 16
102647: PUSH
102648: LD_INT 17
102650: PUSH
102651: LD_INT 18
102653: PUSH
102654: LD_INT 19
102656: PUSH
102657: LD_INT 20
102659: PUSH
102660: LD_INT 21
102662: PUSH
102663: LD_INT 22
102665: PUSH
102666: LD_INT 23
102668: PUSH
102669: LD_INT 24
102671: PUSH
102672: LD_INT 25
102674: PUSH
102675: LD_INT 26
102677: PUSH
102678: LD_INT 28
102680: PUSH
102681: LD_INT 30
102683: PUSH
102684: LD_INT 31
102686: PUSH
102687: LD_INT 32
102689: PUSH
102690: LD_INT 36
102692: PUSH
102693: EMPTY
102694: LIST
102695: LIST
102696: LIST
102697: LIST
102698: LIST
102699: LIST
102700: LIST
102701: LIST
102702: LIST
102703: LIST
102704: LIST
102705: LIST
102706: LIST
102707: LIST
102708: LIST
102709: LIST
102710: LIST
102711: LIST
102712: LIST
102713: LIST
102714: LIST
102715: LIST
102716: LIST
102717: LIST
102718: LIST
102719: LIST
102720: LIST
102721: LIST
102722: LIST
102723: PUSH
102724: LD_INT 101
102726: PUSH
102727: LD_INT 102
102729: PUSH
102730: LD_INT 103
102732: PUSH
102733: LD_INT 104
102735: PUSH
102736: LD_INT 105
102738: PUSH
102739: LD_INT 106
102741: PUSH
102742: LD_INT 107
102744: PUSH
102745: LD_INT 108
102747: PUSH
102748: LD_INT 109
102750: PUSH
102751: LD_INT 110
102753: PUSH
102754: LD_INT 111
102756: PUSH
102757: LD_INT 112
102759: PUSH
102760: LD_INT 114
102762: PUSH
102763: EMPTY
102764: LIST
102765: LIST
102766: LIST
102767: LIST
102768: LIST
102769: LIST
102770: LIST
102771: LIST
102772: LIST
102773: LIST
102774: LIST
102775: LIST
102776: LIST
102777: PUSH
102778: EMPTY
102779: LIST
102780: LIST
102781: ST_TO_ADDR
102782: GO 104569
102784: LD_INT 11
102786: DOUBLE
102787: EQUAL
102788: IFTRUE 102792
102790: GO 102984
102792: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
102793: LD_ADDR_VAR 0 1
102797: PUSH
102798: LD_INT 2
102800: PUSH
102801: LD_INT 3
102803: PUSH
102804: LD_INT 4
102806: PUSH
102807: LD_INT 5
102809: PUSH
102810: LD_INT 6
102812: PUSH
102813: LD_INT 7
102815: PUSH
102816: LD_INT 8
102818: PUSH
102819: LD_INT 9
102821: PUSH
102822: LD_INT 10
102824: PUSH
102825: LD_INT 11
102827: PUSH
102828: LD_INT 12
102830: PUSH
102831: LD_INT 13
102833: PUSH
102834: LD_INT 14
102836: PUSH
102837: LD_INT 15
102839: PUSH
102840: LD_INT 16
102842: PUSH
102843: LD_INT 17
102845: PUSH
102846: LD_INT 18
102848: PUSH
102849: LD_INT 19
102851: PUSH
102852: LD_INT 20
102854: PUSH
102855: LD_INT 21
102857: PUSH
102858: LD_INT 22
102860: PUSH
102861: LD_INT 23
102863: PUSH
102864: LD_INT 24
102866: PUSH
102867: LD_INT 25
102869: PUSH
102870: LD_INT 26
102872: PUSH
102873: LD_INT 28
102875: PUSH
102876: LD_INT 30
102878: PUSH
102879: LD_INT 31
102881: PUSH
102882: LD_INT 32
102884: PUSH
102885: LD_INT 34
102887: PUSH
102888: LD_INT 36
102890: PUSH
102891: EMPTY
102892: LIST
102893: LIST
102894: LIST
102895: LIST
102896: LIST
102897: LIST
102898: LIST
102899: LIST
102900: LIST
102901: LIST
102902: LIST
102903: LIST
102904: LIST
102905: LIST
102906: LIST
102907: LIST
102908: LIST
102909: LIST
102910: LIST
102911: LIST
102912: LIST
102913: LIST
102914: LIST
102915: LIST
102916: LIST
102917: LIST
102918: LIST
102919: LIST
102920: LIST
102921: LIST
102922: LIST
102923: PUSH
102924: LD_INT 101
102926: PUSH
102927: LD_INT 102
102929: PUSH
102930: LD_INT 103
102932: PUSH
102933: LD_INT 104
102935: PUSH
102936: LD_INT 105
102938: PUSH
102939: LD_INT 106
102941: PUSH
102942: LD_INT 107
102944: PUSH
102945: LD_INT 108
102947: PUSH
102948: LD_INT 109
102950: PUSH
102951: LD_INT 110
102953: PUSH
102954: LD_INT 111
102956: PUSH
102957: LD_INT 112
102959: PUSH
102960: LD_INT 114
102962: PUSH
102963: EMPTY
102964: LIST
102965: LIST
102966: LIST
102967: LIST
102968: LIST
102969: LIST
102970: LIST
102971: LIST
102972: LIST
102973: LIST
102974: LIST
102975: LIST
102976: LIST
102977: PUSH
102978: EMPTY
102979: LIST
102980: LIST
102981: ST_TO_ADDR
102982: GO 104569
102984: LD_INT 12
102986: DOUBLE
102987: EQUAL
102988: IFTRUE 102992
102990: GO 103200
102992: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
102993: LD_ADDR_VAR 0 1
102997: PUSH
102998: LD_INT 1
103000: PUSH
103001: LD_INT 2
103003: PUSH
103004: LD_INT 3
103006: PUSH
103007: LD_INT 4
103009: PUSH
103010: LD_INT 5
103012: PUSH
103013: LD_INT 6
103015: PUSH
103016: LD_INT 7
103018: PUSH
103019: LD_INT 8
103021: PUSH
103022: LD_INT 9
103024: PUSH
103025: LD_INT 10
103027: PUSH
103028: LD_INT 11
103030: PUSH
103031: LD_INT 12
103033: PUSH
103034: LD_INT 13
103036: PUSH
103037: LD_INT 14
103039: PUSH
103040: LD_INT 15
103042: PUSH
103043: LD_INT 16
103045: PUSH
103046: LD_INT 17
103048: PUSH
103049: LD_INT 18
103051: PUSH
103052: LD_INT 19
103054: PUSH
103055: LD_INT 20
103057: PUSH
103058: LD_INT 21
103060: PUSH
103061: LD_INT 22
103063: PUSH
103064: LD_INT 23
103066: PUSH
103067: LD_INT 24
103069: PUSH
103070: LD_INT 25
103072: PUSH
103073: LD_INT 26
103075: PUSH
103076: LD_INT 27
103078: PUSH
103079: LD_INT 28
103081: PUSH
103082: LD_INT 30
103084: PUSH
103085: LD_INT 31
103087: PUSH
103088: LD_INT 32
103090: PUSH
103091: LD_INT 33
103093: PUSH
103094: LD_INT 34
103096: PUSH
103097: LD_INT 36
103099: PUSH
103100: EMPTY
103101: LIST
103102: LIST
103103: LIST
103104: LIST
103105: LIST
103106: LIST
103107: LIST
103108: LIST
103109: LIST
103110: LIST
103111: LIST
103112: LIST
103113: LIST
103114: LIST
103115: LIST
103116: LIST
103117: LIST
103118: LIST
103119: LIST
103120: LIST
103121: LIST
103122: LIST
103123: LIST
103124: LIST
103125: LIST
103126: LIST
103127: LIST
103128: LIST
103129: LIST
103130: LIST
103131: LIST
103132: LIST
103133: LIST
103134: LIST
103135: PUSH
103136: LD_INT 101
103138: PUSH
103139: LD_INT 102
103141: PUSH
103142: LD_INT 103
103144: PUSH
103145: LD_INT 104
103147: PUSH
103148: LD_INT 105
103150: PUSH
103151: LD_INT 106
103153: PUSH
103154: LD_INT 107
103156: PUSH
103157: LD_INT 108
103159: PUSH
103160: LD_INT 109
103162: PUSH
103163: LD_INT 110
103165: PUSH
103166: LD_INT 111
103168: PUSH
103169: LD_INT 112
103171: PUSH
103172: LD_INT 113
103174: PUSH
103175: LD_INT 114
103177: PUSH
103178: EMPTY
103179: LIST
103180: LIST
103181: LIST
103182: LIST
103183: LIST
103184: LIST
103185: LIST
103186: LIST
103187: LIST
103188: LIST
103189: LIST
103190: LIST
103191: LIST
103192: LIST
103193: PUSH
103194: EMPTY
103195: LIST
103196: LIST
103197: ST_TO_ADDR
103198: GO 104569
103200: LD_INT 13
103202: DOUBLE
103203: EQUAL
103204: IFTRUE 103208
103206: GO 103404
103208: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
103209: LD_ADDR_VAR 0 1
103213: PUSH
103214: LD_INT 1
103216: PUSH
103217: LD_INT 2
103219: PUSH
103220: LD_INT 3
103222: PUSH
103223: LD_INT 4
103225: PUSH
103226: LD_INT 5
103228: PUSH
103229: LD_INT 8
103231: PUSH
103232: LD_INT 9
103234: PUSH
103235: LD_INT 10
103237: PUSH
103238: LD_INT 11
103240: PUSH
103241: LD_INT 12
103243: PUSH
103244: LD_INT 14
103246: PUSH
103247: LD_INT 15
103249: PUSH
103250: LD_INT 16
103252: PUSH
103253: LD_INT 17
103255: PUSH
103256: LD_INT 18
103258: PUSH
103259: LD_INT 19
103261: PUSH
103262: LD_INT 20
103264: PUSH
103265: LD_INT 21
103267: PUSH
103268: LD_INT 22
103270: PUSH
103271: LD_INT 23
103273: PUSH
103274: LD_INT 24
103276: PUSH
103277: LD_INT 25
103279: PUSH
103280: LD_INT 26
103282: PUSH
103283: LD_INT 27
103285: PUSH
103286: LD_INT 28
103288: PUSH
103289: LD_INT 30
103291: PUSH
103292: LD_INT 31
103294: PUSH
103295: LD_INT 32
103297: PUSH
103298: LD_INT 33
103300: PUSH
103301: LD_INT 34
103303: PUSH
103304: LD_INT 36
103306: PUSH
103307: EMPTY
103308: LIST
103309: LIST
103310: LIST
103311: LIST
103312: LIST
103313: LIST
103314: LIST
103315: LIST
103316: LIST
103317: LIST
103318: LIST
103319: LIST
103320: LIST
103321: LIST
103322: LIST
103323: LIST
103324: LIST
103325: LIST
103326: LIST
103327: LIST
103328: LIST
103329: LIST
103330: LIST
103331: LIST
103332: LIST
103333: LIST
103334: LIST
103335: LIST
103336: LIST
103337: LIST
103338: LIST
103339: PUSH
103340: LD_INT 101
103342: PUSH
103343: LD_INT 102
103345: PUSH
103346: LD_INT 103
103348: PUSH
103349: LD_INT 104
103351: PUSH
103352: LD_INT 105
103354: PUSH
103355: LD_INT 106
103357: PUSH
103358: LD_INT 107
103360: PUSH
103361: LD_INT 108
103363: PUSH
103364: LD_INT 109
103366: PUSH
103367: LD_INT 110
103369: PUSH
103370: LD_INT 111
103372: PUSH
103373: LD_INT 112
103375: PUSH
103376: LD_INT 113
103378: PUSH
103379: LD_INT 114
103381: PUSH
103382: EMPTY
103383: LIST
103384: LIST
103385: LIST
103386: LIST
103387: LIST
103388: LIST
103389: LIST
103390: LIST
103391: LIST
103392: LIST
103393: LIST
103394: LIST
103395: LIST
103396: LIST
103397: PUSH
103398: EMPTY
103399: LIST
103400: LIST
103401: ST_TO_ADDR
103402: GO 104569
103404: LD_INT 14
103406: DOUBLE
103407: EQUAL
103408: IFTRUE 103412
103410: GO 103624
103412: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
103413: LD_ADDR_VAR 0 1
103417: PUSH
103418: LD_INT 1
103420: PUSH
103421: LD_INT 2
103423: PUSH
103424: LD_INT 3
103426: PUSH
103427: LD_INT 4
103429: PUSH
103430: LD_INT 5
103432: PUSH
103433: LD_INT 6
103435: PUSH
103436: LD_INT 7
103438: PUSH
103439: LD_INT 8
103441: PUSH
103442: LD_INT 9
103444: PUSH
103445: LD_INT 10
103447: PUSH
103448: LD_INT 11
103450: PUSH
103451: LD_INT 12
103453: PUSH
103454: LD_INT 13
103456: PUSH
103457: LD_INT 14
103459: PUSH
103460: LD_INT 15
103462: PUSH
103463: LD_INT 16
103465: PUSH
103466: LD_INT 17
103468: PUSH
103469: LD_INT 18
103471: PUSH
103472: LD_INT 19
103474: PUSH
103475: LD_INT 20
103477: PUSH
103478: LD_INT 21
103480: PUSH
103481: LD_INT 22
103483: PUSH
103484: LD_INT 23
103486: PUSH
103487: LD_INT 24
103489: PUSH
103490: LD_INT 25
103492: PUSH
103493: LD_INT 26
103495: PUSH
103496: LD_INT 27
103498: PUSH
103499: LD_INT 28
103501: PUSH
103502: LD_INT 29
103504: PUSH
103505: LD_INT 30
103507: PUSH
103508: LD_INT 31
103510: PUSH
103511: LD_INT 32
103513: PUSH
103514: LD_INT 33
103516: PUSH
103517: LD_INT 34
103519: PUSH
103520: LD_INT 36
103522: PUSH
103523: EMPTY
103524: LIST
103525: LIST
103526: LIST
103527: LIST
103528: LIST
103529: LIST
103530: LIST
103531: LIST
103532: LIST
103533: LIST
103534: LIST
103535: LIST
103536: LIST
103537: LIST
103538: LIST
103539: LIST
103540: LIST
103541: LIST
103542: LIST
103543: LIST
103544: LIST
103545: LIST
103546: LIST
103547: LIST
103548: LIST
103549: LIST
103550: LIST
103551: LIST
103552: LIST
103553: LIST
103554: LIST
103555: LIST
103556: LIST
103557: LIST
103558: LIST
103559: PUSH
103560: LD_INT 101
103562: PUSH
103563: LD_INT 102
103565: PUSH
103566: LD_INT 103
103568: PUSH
103569: LD_INT 104
103571: PUSH
103572: LD_INT 105
103574: PUSH
103575: LD_INT 106
103577: PUSH
103578: LD_INT 107
103580: PUSH
103581: LD_INT 108
103583: PUSH
103584: LD_INT 109
103586: PUSH
103587: LD_INT 110
103589: PUSH
103590: LD_INT 111
103592: PUSH
103593: LD_INT 112
103595: PUSH
103596: LD_INT 113
103598: PUSH
103599: LD_INT 114
103601: PUSH
103602: EMPTY
103603: LIST
103604: LIST
103605: LIST
103606: LIST
103607: LIST
103608: LIST
103609: LIST
103610: LIST
103611: LIST
103612: LIST
103613: LIST
103614: LIST
103615: LIST
103616: LIST
103617: PUSH
103618: EMPTY
103619: LIST
103620: LIST
103621: ST_TO_ADDR
103622: GO 104569
103624: LD_INT 15
103626: DOUBLE
103627: EQUAL
103628: IFTRUE 103632
103630: GO 103844
103632: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
103633: LD_ADDR_VAR 0 1
103637: PUSH
103638: LD_INT 1
103640: PUSH
103641: LD_INT 2
103643: PUSH
103644: LD_INT 3
103646: PUSH
103647: LD_INT 4
103649: PUSH
103650: LD_INT 5
103652: PUSH
103653: LD_INT 6
103655: PUSH
103656: LD_INT 7
103658: PUSH
103659: LD_INT 8
103661: PUSH
103662: LD_INT 9
103664: PUSH
103665: LD_INT 10
103667: PUSH
103668: LD_INT 11
103670: PUSH
103671: LD_INT 12
103673: PUSH
103674: LD_INT 13
103676: PUSH
103677: LD_INT 14
103679: PUSH
103680: LD_INT 15
103682: PUSH
103683: LD_INT 16
103685: PUSH
103686: LD_INT 17
103688: PUSH
103689: LD_INT 18
103691: PUSH
103692: LD_INT 19
103694: PUSH
103695: LD_INT 20
103697: PUSH
103698: LD_INT 21
103700: PUSH
103701: LD_INT 22
103703: PUSH
103704: LD_INT 23
103706: PUSH
103707: LD_INT 24
103709: PUSH
103710: LD_INT 25
103712: PUSH
103713: LD_INT 26
103715: PUSH
103716: LD_INT 27
103718: PUSH
103719: LD_INT 28
103721: PUSH
103722: LD_INT 29
103724: PUSH
103725: LD_INT 30
103727: PUSH
103728: LD_INT 31
103730: PUSH
103731: LD_INT 32
103733: PUSH
103734: LD_INT 33
103736: PUSH
103737: LD_INT 34
103739: PUSH
103740: LD_INT 36
103742: PUSH
103743: EMPTY
103744: LIST
103745: LIST
103746: LIST
103747: LIST
103748: LIST
103749: LIST
103750: LIST
103751: LIST
103752: LIST
103753: LIST
103754: LIST
103755: LIST
103756: LIST
103757: LIST
103758: LIST
103759: LIST
103760: LIST
103761: LIST
103762: LIST
103763: LIST
103764: LIST
103765: LIST
103766: LIST
103767: LIST
103768: LIST
103769: LIST
103770: LIST
103771: LIST
103772: LIST
103773: LIST
103774: LIST
103775: LIST
103776: LIST
103777: LIST
103778: LIST
103779: PUSH
103780: LD_INT 101
103782: PUSH
103783: LD_INT 102
103785: PUSH
103786: LD_INT 103
103788: PUSH
103789: LD_INT 104
103791: PUSH
103792: LD_INT 105
103794: PUSH
103795: LD_INT 106
103797: PUSH
103798: LD_INT 107
103800: PUSH
103801: LD_INT 108
103803: PUSH
103804: LD_INT 109
103806: PUSH
103807: LD_INT 110
103809: PUSH
103810: LD_INT 111
103812: PUSH
103813: LD_INT 112
103815: PUSH
103816: LD_INT 113
103818: PUSH
103819: LD_INT 114
103821: PUSH
103822: EMPTY
103823: LIST
103824: LIST
103825: LIST
103826: LIST
103827: LIST
103828: LIST
103829: LIST
103830: LIST
103831: LIST
103832: LIST
103833: LIST
103834: LIST
103835: LIST
103836: LIST
103837: PUSH
103838: EMPTY
103839: LIST
103840: LIST
103841: ST_TO_ADDR
103842: GO 104569
103844: LD_INT 16
103846: DOUBLE
103847: EQUAL
103848: IFTRUE 103852
103850: GO 103976
103852: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
103853: LD_ADDR_VAR 0 1
103857: PUSH
103858: LD_INT 2
103860: PUSH
103861: LD_INT 4
103863: PUSH
103864: LD_INT 5
103866: PUSH
103867: LD_INT 7
103869: PUSH
103870: LD_INT 11
103872: PUSH
103873: LD_INT 12
103875: PUSH
103876: LD_INT 15
103878: PUSH
103879: LD_INT 16
103881: PUSH
103882: LD_INT 20
103884: PUSH
103885: LD_INT 21
103887: PUSH
103888: LD_INT 22
103890: PUSH
103891: LD_INT 23
103893: PUSH
103894: LD_INT 25
103896: PUSH
103897: LD_INT 26
103899: PUSH
103900: LD_INT 30
103902: PUSH
103903: LD_INT 31
103905: PUSH
103906: LD_INT 32
103908: PUSH
103909: LD_INT 33
103911: PUSH
103912: LD_INT 34
103914: PUSH
103915: EMPTY
103916: LIST
103917: LIST
103918: LIST
103919: LIST
103920: LIST
103921: LIST
103922: LIST
103923: LIST
103924: LIST
103925: LIST
103926: LIST
103927: LIST
103928: LIST
103929: LIST
103930: LIST
103931: LIST
103932: LIST
103933: LIST
103934: LIST
103935: PUSH
103936: LD_INT 101
103938: PUSH
103939: LD_INT 102
103941: PUSH
103942: LD_INT 103
103944: PUSH
103945: LD_INT 106
103947: PUSH
103948: LD_INT 108
103950: PUSH
103951: LD_INT 112
103953: PUSH
103954: LD_INT 113
103956: PUSH
103957: LD_INT 114
103959: PUSH
103960: EMPTY
103961: LIST
103962: LIST
103963: LIST
103964: LIST
103965: LIST
103966: LIST
103967: LIST
103968: LIST
103969: PUSH
103970: EMPTY
103971: LIST
103972: LIST
103973: ST_TO_ADDR
103974: GO 104569
103976: LD_INT 17
103978: DOUBLE
103979: EQUAL
103980: IFTRUE 103984
103982: GO 104196
103984: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
103985: LD_ADDR_VAR 0 1
103989: PUSH
103990: LD_INT 1
103992: PUSH
103993: LD_INT 2
103995: PUSH
103996: LD_INT 3
103998: PUSH
103999: LD_INT 4
104001: PUSH
104002: LD_INT 5
104004: PUSH
104005: LD_INT 6
104007: PUSH
104008: LD_INT 7
104010: PUSH
104011: LD_INT 8
104013: PUSH
104014: LD_INT 9
104016: PUSH
104017: LD_INT 10
104019: PUSH
104020: LD_INT 11
104022: PUSH
104023: LD_INT 12
104025: PUSH
104026: LD_INT 13
104028: PUSH
104029: LD_INT 14
104031: PUSH
104032: LD_INT 15
104034: PUSH
104035: LD_INT 16
104037: PUSH
104038: LD_INT 17
104040: PUSH
104041: LD_INT 18
104043: PUSH
104044: LD_INT 19
104046: PUSH
104047: LD_INT 20
104049: PUSH
104050: LD_INT 21
104052: PUSH
104053: LD_INT 22
104055: PUSH
104056: LD_INT 23
104058: PUSH
104059: LD_INT 24
104061: PUSH
104062: LD_INT 25
104064: PUSH
104065: LD_INT 26
104067: PUSH
104068: LD_INT 27
104070: PUSH
104071: LD_INT 28
104073: PUSH
104074: LD_INT 29
104076: PUSH
104077: LD_INT 30
104079: PUSH
104080: LD_INT 31
104082: PUSH
104083: LD_INT 32
104085: PUSH
104086: LD_INT 33
104088: PUSH
104089: LD_INT 34
104091: PUSH
104092: LD_INT 36
104094: PUSH
104095: EMPTY
104096: LIST
104097: LIST
104098: LIST
104099: LIST
104100: LIST
104101: LIST
104102: LIST
104103: LIST
104104: LIST
104105: LIST
104106: LIST
104107: LIST
104108: LIST
104109: LIST
104110: LIST
104111: LIST
104112: LIST
104113: LIST
104114: LIST
104115: LIST
104116: LIST
104117: LIST
104118: LIST
104119: LIST
104120: LIST
104121: LIST
104122: LIST
104123: LIST
104124: LIST
104125: LIST
104126: LIST
104127: LIST
104128: LIST
104129: LIST
104130: LIST
104131: PUSH
104132: LD_INT 101
104134: PUSH
104135: LD_INT 102
104137: PUSH
104138: LD_INT 103
104140: PUSH
104141: LD_INT 104
104143: PUSH
104144: LD_INT 105
104146: PUSH
104147: LD_INT 106
104149: PUSH
104150: LD_INT 107
104152: PUSH
104153: LD_INT 108
104155: PUSH
104156: LD_INT 109
104158: PUSH
104159: LD_INT 110
104161: PUSH
104162: LD_INT 111
104164: PUSH
104165: LD_INT 112
104167: PUSH
104168: LD_INT 113
104170: PUSH
104171: LD_INT 114
104173: PUSH
104174: EMPTY
104175: LIST
104176: LIST
104177: LIST
104178: LIST
104179: LIST
104180: LIST
104181: LIST
104182: LIST
104183: LIST
104184: LIST
104185: LIST
104186: LIST
104187: LIST
104188: LIST
104189: PUSH
104190: EMPTY
104191: LIST
104192: LIST
104193: ST_TO_ADDR
104194: GO 104569
104196: LD_INT 18
104198: DOUBLE
104199: EQUAL
104200: IFTRUE 104204
104202: GO 104340
104204: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
104205: LD_ADDR_VAR 0 1
104209: PUSH
104210: LD_INT 2
104212: PUSH
104213: LD_INT 4
104215: PUSH
104216: LD_INT 5
104218: PUSH
104219: LD_INT 7
104221: PUSH
104222: LD_INT 11
104224: PUSH
104225: LD_INT 12
104227: PUSH
104228: LD_INT 15
104230: PUSH
104231: LD_INT 16
104233: PUSH
104234: LD_INT 20
104236: PUSH
104237: LD_INT 21
104239: PUSH
104240: LD_INT 22
104242: PUSH
104243: LD_INT 23
104245: PUSH
104246: LD_INT 25
104248: PUSH
104249: LD_INT 26
104251: PUSH
104252: LD_INT 30
104254: PUSH
104255: LD_INT 31
104257: PUSH
104258: LD_INT 32
104260: PUSH
104261: LD_INT 33
104263: PUSH
104264: LD_INT 34
104266: PUSH
104267: LD_INT 35
104269: PUSH
104270: LD_INT 36
104272: PUSH
104273: EMPTY
104274: LIST
104275: LIST
104276: LIST
104277: LIST
104278: LIST
104279: LIST
104280: LIST
104281: LIST
104282: LIST
104283: LIST
104284: LIST
104285: LIST
104286: LIST
104287: LIST
104288: LIST
104289: LIST
104290: LIST
104291: LIST
104292: LIST
104293: LIST
104294: LIST
104295: PUSH
104296: LD_INT 101
104298: PUSH
104299: LD_INT 102
104301: PUSH
104302: LD_INT 103
104304: PUSH
104305: LD_INT 106
104307: PUSH
104308: LD_INT 108
104310: PUSH
104311: LD_INT 112
104313: PUSH
104314: LD_INT 113
104316: PUSH
104317: LD_INT 114
104319: PUSH
104320: LD_INT 115
104322: PUSH
104323: EMPTY
104324: LIST
104325: LIST
104326: LIST
104327: LIST
104328: LIST
104329: LIST
104330: LIST
104331: LIST
104332: LIST
104333: PUSH
104334: EMPTY
104335: LIST
104336: LIST
104337: ST_TO_ADDR
104338: GO 104569
104340: LD_INT 19
104342: DOUBLE
104343: EQUAL
104344: IFTRUE 104348
104346: GO 104568
104348: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
104349: LD_ADDR_VAR 0 1
104353: PUSH
104354: LD_INT 1
104356: PUSH
104357: LD_INT 2
104359: PUSH
104360: LD_INT 3
104362: PUSH
104363: LD_INT 4
104365: PUSH
104366: LD_INT 5
104368: PUSH
104369: LD_INT 6
104371: PUSH
104372: LD_INT 7
104374: PUSH
104375: LD_INT 8
104377: PUSH
104378: LD_INT 9
104380: PUSH
104381: LD_INT 10
104383: PUSH
104384: LD_INT 11
104386: PUSH
104387: LD_INT 12
104389: PUSH
104390: LD_INT 13
104392: PUSH
104393: LD_INT 14
104395: PUSH
104396: LD_INT 15
104398: PUSH
104399: LD_INT 16
104401: PUSH
104402: LD_INT 17
104404: PUSH
104405: LD_INT 18
104407: PUSH
104408: LD_INT 19
104410: PUSH
104411: LD_INT 20
104413: PUSH
104414: LD_INT 21
104416: PUSH
104417: LD_INT 22
104419: PUSH
104420: LD_INT 23
104422: PUSH
104423: LD_INT 24
104425: PUSH
104426: LD_INT 25
104428: PUSH
104429: LD_INT 26
104431: PUSH
104432: LD_INT 27
104434: PUSH
104435: LD_INT 28
104437: PUSH
104438: LD_INT 29
104440: PUSH
104441: LD_INT 30
104443: PUSH
104444: LD_INT 31
104446: PUSH
104447: LD_INT 32
104449: PUSH
104450: LD_INT 33
104452: PUSH
104453: LD_INT 34
104455: PUSH
104456: LD_INT 35
104458: PUSH
104459: LD_INT 36
104461: PUSH
104462: EMPTY
104463: LIST
104464: LIST
104465: LIST
104466: LIST
104467: LIST
104468: LIST
104469: LIST
104470: LIST
104471: LIST
104472: LIST
104473: LIST
104474: LIST
104475: LIST
104476: LIST
104477: LIST
104478: LIST
104479: LIST
104480: LIST
104481: LIST
104482: LIST
104483: LIST
104484: LIST
104485: LIST
104486: LIST
104487: LIST
104488: LIST
104489: LIST
104490: LIST
104491: LIST
104492: LIST
104493: LIST
104494: LIST
104495: LIST
104496: LIST
104497: LIST
104498: LIST
104499: PUSH
104500: LD_INT 101
104502: PUSH
104503: LD_INT 102
104505: PUSH
104506: LD_INT 103
104508: PUSH
104509: LD_INT 104
104511: PUSH
104512: LD_INT 105
104514: PUSH
104515: LD_INT 106
104517: PUSH
104518: LD_INT 107
104520: PUSH
104521: LD_INT 108
104523: PUSH
104524: LD_INT 109
104526: PUSH
104527: LD_INT 110
104529: PUSH
104530: LD_INT 111
104532: PUSH
104533: LD_INT 112
104535: PUSH
104536: LD_INT 113
104538: PUSH
104539: LD_INT 114
104541: PUSH
104542: LD_INT 115
104544: PUSH
104545: EMPTY
104546: LIST
104547: LIST
104548: LIST
104549: LIST
104550: LIST
104551: LIST
104552: LIST
104553: LIST
104554: LIST
104555: LIST
104556: LIST
104557: LIST
104558: LIST
104559: LIST
104560: LIST
104561: PUSH
104562: EMPTY
104563: LIST
104564: LIST
104565: ST_TO_ADDR
104566: GO 104569
104568: POP
// end else
104569: GO 104788
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
104571: LD_ADDR_VAR 0 1
104575: PUSH
104576: LD_INT 1
104578: PUSH
104579: LD_INT 2
104581: PUSH
104582: LD_INT 3
104584: PUSH
104585: LD_INT 4
104587: PUSH
104588: LD_INT 5
104590: PUSH
104591: LD_INT 6
104593: PUSH
104594: LD_INT 7
104596: PUSH
104597: LD_INT 8
104599: PUSH
104600: LD_INT 9
104602: PUSH
104603: LD_INT 10
104605: PUSH
104606: LD_INT 11
104608: PUSH
104609: LD_INT 12
104611: PUSH
104612: LD_INT 13
104614: PUSH
104615: LD_INT 14
104617: PUSH
104618: LD_INT 15
104620: PUSH
104621: LD_INT 16
104623: PUSH
104624: LD_INT 17
104626: PUSH
104627: LD_INT 18
104629: PUSH
104630: LD_INT 19
104632: PUSH
104633: LD_INT 20
104635: PUSH
104636: LD_INT 21
104638: PUSH
104639: LD_INT 22
104641: PUSH
104642: LD_INT 23
104644: PUSH
104645: LD_INT 24
104647: PUSH
104648: LD_INT 25
104650: PUSH
104651: LD_INT 26
104653: PUSH
104654: LD_INT 27
104656: PUSH
104657: LD_INT 28
104659: PUSH
104660: LD_INT 29
104662: PUSH
104663: LD_INT 30
104665: PUSH
104666: LD_INT 31
104668: PUSH
104669: LD_INT 32
104671: PUSH
104672: LD_INT 33
104674: PUSH
104675: LD_INT 34
104677: PUSH
104678: LD_INT 35
104680: PUSH
104681: LD_INT 36
104683: PUSH
104684: EMPTY
104685: LIST
104686: LIST
104687: LIST
104688: LIST
104689: LIST
104690: LIST
104691: LIST
104692: LIST
104693: LIST
104694: LIST
104695: LIST
104696: LIST
104697: LIST
104698: LIST
104699: LIST
104700: LIST
104701: LIST
104702: LIST
104703: LIST
104704: LIST
104705: LIST
104706: LIST
104707: LIST
104708: LIST
104709: LIST
104710: LIST
104711: LIST
104712: LIST
104713: LIST
104714: LIST
104715: LIST
104716: LIST
104717: LIST
104718: LIST
104719: LIST
104720: LIST
104721: PUSH
104722: LD_INT 101
104724: PUSH
104725: LD_INT 102
104727: PUSH
104728: LD_INT 103
104730: PUSH
104731: LD_INT 104
104733: PUSH
104734: LD_INT 105
104736: PUSH
104737: LD_INT 106
104739: PUSH
104740: LD_INT 107
104742: PUSH
104743: LD_INT 108
104745: PUSH
104746: LD_INT 109
104748: PUSH
104749: LD_INT 110
104751: PUSH
104752: LD_INT 111
104754: PUSH
104755: LD_INT 112
104757: PUSH
104758: LD_INT 113
104760: PUSH
104761: LD_INT 114
104763: PUSH
104764: LD_INT 115
104766: PUSH
104767: EMPTY
104768: LIST
104769: LIST
104770: LIST
104771: LIST
104772: LIST
104773: LIST
104774: LIST
104775: LIST
104776: LIST
104777: LIST
104778: LIST
104779: LIST
104780: LIST
104781: LIST
104782: LIST
104783: PUSH
104784: EMPTY
104785: LIST
104786: LIST
104787: ST_TO_ADDR
// if result then
104788: LD_VAR 0 1
104792: IFFALSE 105081
// begin normal :=  ;
104794: LD_ADDR_VAR 0 3
104798: PUSH
104799: LD_STRING 
104801: ST_TO_ADDR
// hardcore :=  ;
104802: LD_ADDR_VAR 0 4
104806: PUSH
104807: LD_STRING 
104809: ST_TO_ADDR
// for i = 1 to normalCounter do
104810: LD_ADDR_VAR 0 5
104814: PUSH
104815: DOUBLE
104816: LD_INT 1
104818: DEC
104819: ST_TO_ADDR
104820: LD_EXP 154
104824: PUSH
104825: FOR_TO
104826: IFFALSE 104927
// begin tmp := 0 ;
104828: LD_ADDR_VAR 0 2
104832: PUSH
104833: LD_STRING 0
104835: ST_TO_ADDR
// if result [ 1 ] then
104836: LD_VAR 0 1
104840: PUSH
104841: LD_INT 1
104843: ARRAY
104844: IFFALSE 104909
// if result [ 1 ] [ 1 ] = i then
104846: LD_VAR 0 1
104850: PUSH
104851: LD_INT 1
104853: ARRAY
104854: PUSH
104855: LD_INT 1
104857: ARRAY
104858: PUSH
104859: LD_VAR 0 5
104863: EQUAL
104864: IFFALSE 104909
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
104866: LD_ADDR_VAR 0 1
104870: PUSH
104871: LD_VAR 0 1
104875: PPUSH
104876: LD_INT 1
104878: PPUSH
104879: LD_VAR 0 1
104883: PUSH
104884: LD_INT 1
104886: ARRAY
104887: PPUSH
104888: LD_INT 1
104890: PPUSH
104891: CALL_OW 3
104895: PPUSH
104896: CALL_OW 1
104900: ST_TO_ADDR
// tmp := 1 ;
104901: LD_ADDR_VAR 0 2
104905: PUSH
104906: LD_STRING 1
104908: ST_TO_ADDR
// end ; normal := normal & tmp ;
104909: LD_ADDR_VAR 0 3
104913: PUSH
104914: LD_VAR 0 3
104918: PUSH
104919: LD_VAR 0 2
104923: STR
104924: ST_TO_ADDR
// end ;
104925: GO 104825
104927: POP
104928: POP
// for i = 1 to hardcoreCounter do
104929: LD_ADDR_VAR 0 5
104933: PUSH
104934: DOUBLE
104935: LD_INT 1
104937: DEC
104938: ST_TO_ADDR
104939: LD_EXP 155
104943: PUSH
104944: FOR_TO
104945: IFFALSE 105050
// begin tmp := 0 ;
104947: LD_ADDR_VAR 0 2
104951: PUSH
104952: LD_STRING 0
104954: ST_TO_ADDR
// if result [ 2 ] then
104955: LD_VAR 0 1
104959: PUSH
104960: LD_INT 2
104962: ARRAY
104963: IFFALSE 105032
// if result [ 2 ] [ 1 ] = 100 + i then
104965: LD_VAR 0 1
104969: PUSH
104970: LD_INT 2
104972: ARRAY
104973: PUSH
104974: LD_INT 1
104976: ARRAY
104977: PUSH
104978: LD_INT 100
104980: PUSH
104981: LD_VAR 0 5
104985: PLUS
104986: EQUAL
104987: IFFALSE 105032
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
104989: LD_ADDR_VAR 0 1
104993: PUSH
104994: LD_VAR 0 1
104998: PPUSH
104999: LD_INT 2
105001: PPUSH
105002: LD_VAR 0 1
105006: PUSH
105007: LD_INT 2
105009: ARRAY
105010: PPUSH
105011: LD_INT 1
105013: PPUSH
105014: CALL_OW 3
105018: PPUSH
105019: CALL_OW 1
105023: ST_TO_ADDR
// tmp := 1 ;
105024: LD_ADDR_VAR 0 2
105028: PUSH
105029: LD_STRING 1
105031: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
105032: LD_ADDR_VAR 0 4
105036: PUSH
105037: LD_VAR 0 4
105041: PUSH
105042: LD_VAR 0 2
105046: STR
105047: ST_TO_ADDR
// end ;
105048: GO 104944
105050: POP
105051: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
105052: LD_STRING getStreamItemsFromMission("
105054: PUSH
105055: LD_VAR 0 3
105059: STR
105060: PUSH
105061: LD_STRING ","
105063: STR
105064: PUSH
105065: LD_VAR 0 4
105069: STR
105070: PUSH
105071: LD_STRING ")
105073: STR
105074: PPUSH
105075: CALL_OW 559
// end else
105079: GO 105088
// ToLua ( getStreamItemsFromMission("","") ) ;
105081: LD_STRING getStreamItemsFromMission("","")
105083: PPUSH
105084: CALL_OW 559
// end ;
105088: LD_VAR 0 1
105092: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
105093: LD_VAR 0 2
105097: PUSH
105098: LD_INT 100
105100: EQUAL
105101: IFFALSE 106050
// begin if not StreamModeActive then
105103: LD_EXP 153
105107: NOT
105108: IFFALSE 105118
// StreamModeActive := true ;
105110: LD_ADDR_EXP 153
105114: PUSH
105115: LD_INT 1
105117: ST_TO_ADDR
// if p3 = 0 then
105118: LD_VAR 0 3
105122: PUSH
105123: LD_INT 0
105125: EQUAL
105126: IFFALSE 105132
// InitStreamMode ;
105128: CALL 101171 0 0
// if p3 = 1 then
105132: LD_VAR 0 3
105136: PUSH
105137: LD_INT 1
105139: EQUAL
105140: IFFALSE 105150
// sRocket := true ;
105142: LD_ADDR_EXP 158
105146: PUSH
105147: LD_INT 1
105149: ST_TO_ADDR
// if p3 = 2 then
105150: LD_VAR 0 3
105154: PUSH
105155: LD_INT 2
105157: EQUAL
105158: IFFALSE 105168
// sSpeed := true ;
105160: LD_ADDR_EXP 157
105164: PUSH
105165: LD_INT 1
105167: ST_TO_ADDR
// if p3 = 3 then
105168: LD_VAR 0 3
105172: PUSH
105173: LD_INT 3
105175: EQUAL
105176: IFFALSE 105186
// sEngine := true ;
105178: LD_ADDR_EXP 159
105182: PUSH
105183: LD_INT 1
105185: ST_TO_ADDR
// if p3 = 4 then
105186: LD_VAR 0 3
105190: PUSH
105191: LD_INT 4
105193: EQUAL
105194: IFFALSE 105204
// sSpec := true ;
105196: LD_ADDR_EXP 156
105200: PUSH
105201: LD_INT 1
105203: ST_TO_ADDR
// if p3 = 5 then
105204: LD_VAR 0 3
105208: PUSH
105209: LD_INT 5
105211: EQUAL
105212: IFFALSE 105222
// sLevel := true ;
105214: LD_ADDR_EXP 160
105218: PUSH
105219: LD_INT 1
105221: ST_TO_ADDR
// if p3 = 6 then
105222: LD_VAR 0 3
105226: PUSH
105227: LD_INT 6
105229: EQUAL
105230: IFFALSE 105240
// sArmoury := true ;
105232: LD_ADDR_EXP 161
105236: PUSH
105237: LD_INT 1
105239: ST_TO_ADDR
// if p3 = 7 then
105240: LD_VAR 0 3
105244: PUSH
105245: LD_INT 7
105247: EQUAL
105248: IFFALSE 105258
// sRadar := true ;
105250: LD_ADDR_EXP 162
105254: PUSH
105255: LD_INT 1
105257: ST_TO_ADDR
// if p3 = 8 then
105258: LD_VAR 0 3
105262: PUSH
105263: LD_INT 8
105265: EQUAL
105266: IFFALSE 105276
// sBunker := true ;
105268: LD_ADDR_EXP 163
105272: PUSH
105273: LD_INT 1
105275: ST_TO_ADDR
// if p3 = 9 then
105276: LD_VAR 0 3
105280: PUSH
105281: LD_INT 9
105283: EQUAL
105284: IFFALSE 105294
// sHack := true ;
105286: LD_ADDR_EXP 164
105290: PUSH
105291: LD_INT 1
105293: ST_TO_ADDR
// if p3 = 10 then
105294: LD_VAR 0 3
105298: PUSH
105299: LD_INT 10
105301: EQUAL
105302: IFFALSE 105312
// sFire := true ;
105304: LD_ADDR_EXP 165
105308: PUSH
105309: LD_INT 1
105311: ST_TO_ADDR
// if p3 = 11 then
105312: LD_VAR 0 3
105316: PUSH
105317: LD_INT 11
105319: EQUAL
105320: IFFALSE 105330
// sRefresh := true ;
105322: LD_ADDR_EXP 166
105326: PUSH
105327: LD_INT 1
105329: ST_TO_ADDR
// if p3 = 12 then
105330: LD_VAR 0 3
105334: PUSH
105335: LD_INT 12
105337: EQUAL
105338: IFFALSE 105348
// sExp := true ;
105340: LD_ADDR_EXP 167
105344: PUSH
105345: LD_INT 1
105347: ST_TO_ADDR
// if p3 = 13 then
105348: LD_VAR 0 3
105352: PUSH
105353: LD_INT 13
105355: EQUAL
105356: IFFALSE 105366
// sDepot := true ;
105358: LD_ADDR_EXP 168
105362: PUSH
105363: LD_INT 1
105365: ST_TO_ADDR
// if p3 = 14 then
105366: LD_VAR 0 3
105370: PUSH
105371: LD_INT 14
105373: EQUAL
105374: IFFALSE 105384
// sFlag := true ;
105376: LD_ADDR_EXP 169
105380: PUSH
105381: LD_INT 1
105383: ST_TO_ADDR
// if p3 = 15 then
105384: LD_VAR 0 3
105388: PUSH
105389: LD_INT 15
105391: EQUAL
105392: IFFALSE 105402
// sKamikadze := true ;
105394: LD_ADDR_EXP 177
105398: PUSH
105399: LD_INT 1
105401: ST_TO_ADDR
// if p3 = 16 then
105402: LD_VAR 0 3
105406: PUSH
105407: LD_INT 16
105409: EQUAL
105410: IFFALSE 105420
// sTroll := true ;
105412: LD_ADDR_EXP 178
105416: PUSH
105417: LD_INT 1
105419: ST_TO_ADDR
// if p3 = 17 then
105420: LD_VAR 0 3
105424: PUSH
105425: LD_INT 17
105427: EQUAL
105428: IFFALSE 105438
// sSlow := true ;
105430: LD_ADDR_EXP 179
105434: PUSH
105435: LD_INT 1
105437: ST_TO_ADDR
// if p3 = 18 then
105438: LD_VAR 0 3
105442: PUSH
105443: LD_INT 18
105445: EQUAL
105446: IFFALSE 105456
// sLack := true ;
105448: LD_ADDR_EXP 180
105452: PUSH
105453: LD_INT 1
105455: ST_TO_ADDR
// if p3 = 19 then
105456: LD_VAR 0 3
105460: PUSH
105461: LD_INT 19
105463: EQUAL
105464: IFFALSE 105474
// sTank := true ;
105466: LD_ADDR_EXP 182
105470: PUSH
105471: LD_INT 1
105473: ST_TO_ADDR
// if p3 = 20 then
105474: LD_VAR 0 3
105478: PUSH
105479: LD_INT 20
105481: EQUAL
105482: IFFALSE 105492
// sRemote := true ;
105484: LD_ADDR_EXP 183
105488: PUSH
105489: LD_INT 1
105491: ST_TO_ADDR
// if p3 = 21 then
105492: LD_VAR 0 3
105496: PUSH
105497: LD_INT 21
105499: EQUAL
105500: IFFALSE 105510
// sPowell := true ;
105502: LD_ADDR_EXP 184
105506: PUSH
105507: LD_INT 1
105509: ST_TO_ADDR
// if p3 = 22 then
105510: LD_VAR 0 3
105514: PUSH
105515: LD_INT 22
105517: EQUAL
105518: IFFALSE 105528
// sTeleport := true ;
105520: LD_ADDR_EXP 187
105524: PUSH
105525: LD_INT 1
105527: ST_TO_ADDR
// if p3 = 23 then
105528: LD_VAR 0 3
105532: PUSH
105533: LD_INT 23
105535: EQUAL
105536: IFFALSE 105546
// sOilTower := true ;
105538: LD_ADDR_EXP 189
105542: PUSH
105543: LD_INT 1
105545: ST_TO_ADDR
// if p3 = 24 then
105546: LD_VAR 0 3
105550: PUSH
105551: LD_INT 24
105553: EQUAL
105554: IFFALSE 105564
// sShovel := true ;
105556: LD_ADDR_EXP 190
105560: PUSH
105561: LD_INT 1
105563: ST_TO_ADDR
// if p3 = 25 then
105564: LD_VAR 0 3
105568: PUSH
105569: LD_INT 25
105571: EQUAL
105572: IFFALSE 105582
// sSheik := true ;
105574: LD_ADDR_EXP 191
105578: PUSH
105579: LD_INT 1
105581: ST_TO_ADDR
// if p3 = 26 then
105582: LD_VAR 0 3
105586: PUSH
105587: LD_INT 26
105589: EQUAL
105590: IFFALSE 105600
// sEarthquake := true ;
105592: LD_ADDR_EXP 193
105596: PUSH
105597: LD_INT 1
105599: ST_TO_ADDR
// if p3 = 27 then
105600: LD_VAR 0 3
105604: PUSH
105605: LD_INT 27
105607: EQUAL
105608: IFFALSE 105618
// sAI := true ;
105610: LD_ADDR_EXP 194
105614: PUSH
105615: LD_INT 1
105617: ST_TO_ADDR
// if p3 = 28 then
105618: LD_VAR 0 3
105622: PUSH
105623: LD_INT 28
105625: EQUAL
105626: IFFALSE 105636
// sCargo := true ;
105628: LD_ADDR_EXP 197
105632: PUSH
105633: LD_INT 1
105635: ST_TO_ADDR
// if p3 = 29 then
105636: LD_VAR 0 3
105640: PUSH
105641: LD_INT 29
105643: EQUAL
105644: IFFALSE 105654
// sDLaser := true ;
105646: LD_ADDR_EXP 198
105650: PUSH
105651: LD_INT 1
105653: ST_TO_ADDR
// if p3 = 30 then
105654: LD_VAR 0 3
105658: PUSH
105659: LD_INT 30
105661: EQUAL
105662: IFFALSE 105672
// sExchange := true ;
105664: LD_ADDR_EXP 199
105668: PUSH
105669: LD_INT 1
105671: ST_TO_ADDR
// if p3 = 31 then
105672: LD_VAR 0 3
105676: PUSH
105677: LD_INT 31
105679: EQUAL
105680: IFFALSE 105690
// sFac := true ;
105682: LD_ADDR_EXP 200
105686: PUSH
105687: LD_INT 1
105689: ST_TO_ADDR
// if p3 = 32 then
105690: LD_VAR 0 3
105694: PUSH
105695: LD_INT 32
105697: EQUAL
105698: IFFALSE 105708
// sPower := true ;
105700: LD_ADDR_EXP 201
105704: PUSH
105705: LD_INT 1
105707: ST_TO_ADDR
// if p3 = 33 then
105708: LD_VAR 0 3
105712: PUSH
105713: LD_INT 33
105715: EQUAL
105716: IFFALSE 105726
// sRandom := true ;
105718: LD_ADDR_EXP 202
105722: PUSH
105723: LD_INT 1
105725: ST_TO_ADDR
// if p3 = 34 then
105726: LD_VAR 0 3
105730: PUSH
105731: LD_INT 34
105733: EQUAL
105734: IFFALSE 105744
// sShield := true ;
105736: LD_ADDR_EXP 203
105740: PUSH
105741: LD_INT 1
105743: ST_TO_ADDR
// if p3 = 35 then
105744: LD_VAR 0 3
105748: PUSH
105749: LD_INT 35
105751: EQUAL
105752: IFFALSE 105762
// sTime := true ;
105754: LD_ADDR_EXP 204
105758: PUSH
105759: LD_INT 1
105761: ST_TO_ADDR
// if p3 = 36 then
105762: LD_VAR 0 3
105766: PUSH
105767: LD_INT 36
105769: EQUAL
105770: IFFALSE 105780
// sTools := true ;
105772: LD_ADDR_EXP 205
105776: PUSH
105777: LD_INT 1
105779: ST_TO_ADDR
// if p3 = 101 then
105780: LD_VAR 0 3
105784: PUSH
105785: LD_INT 101
105787: EQUAL
105788: IFFALSE 105798
// sSold := true ;
105790: LD_ADDR_EXP 170
105794: PUSH
105795: LD_INT 1
105797: ST_TO_ADDR
// if p3 = 102 then
105798: LD_VAR 0 3
105802: PUSH
105803: LD_INT 102
105805: EQUAL
105806: IFFALSE 105816
// sDiff := true ;
105808: LD_ADDR_EXP 171
105812: PUSH
105813: LD_INT 1
105815: ST_TO_ADDR
// if p3 = 103 then
105816: LD_VAR 0 3
105820: PUSH
105821: LD_INT 103
105823: EQUAL
105824: IFFALSE 105834
// sFog := true ;
105826: LD_ADDR_EXP 174
105830: PUSH
105831: LD_INT 1
105833: ST_TO_ADDR
// if p3 = 104 then
105834: LD_VAR 0 3
105838: PUSH
105839: LD_INT 104
105841: EQUAL
105842: IFFALSE 105852
// sReset := true ;
105844: LD_ADDR_EXP 175
105848: PUSH
105849: LD_INT 1
105851: ST_TO_ADDR
// if p3 = 105 then
105852: LD_VAR 0 3
105856: PUSH
105857: LD_INT 105
105859: EQUAL
105860: IFFALSE 105870
// sSun := true ;
105862: LD_ADDR_EXP 176
105866: PUSH
105867: LD_INT 1
105869: ST_TO_ADDR
// if p3 = 106 then
105870: LD_VAR 0 3
105874: PUSH
105875: LD_INT 106
105877: EQUAL
105878: IFFALSE 105888
// sTiger := true ;
105880: LD_ADDR_EXP 172
105884: PUSH
105885: LD_INT 1
105887: ST_TO_ADDR
// if p3 = 107 then
105888: LD_VAR 0 3
105892: PUSH
105893: LD_INT 107
105895: EQUAL
105896: IFFALSE 105906
// sBomb := true ;
105898: LD_ADDR_EXP 173
105902: PUSH
105903: LD_INT 1
105905: ST_TO_ADDR
// if p3 = 108 then
105906: LD_VAR 0 3
105910: PUSH
105911: LD_INT 108
105913: EQUAL
105914: IFFALSE 105924
// sWound := true ;
105916: LD_ADDR_EXP 181
105920: PUSH
105921: LD_INT 1
105923: ST_TO_ADDR
// if p3 = 109 then
105924: LD_VAR 0 3
105928: PUSH
105929: LD_INT 109
105931: EQUAL
105932: IFFALSE 105942
// sBetray := true ;
105934: LD_ADDR_EXP 185
105938: PUSH
105939: LD_INT 1
105941: ST_TO_ADDR
// if p3 = 110 then
105942: LD_VAR 0 3
105946: PUSH
105947: LD_INT 110
105949: EQUAL
105950: IFFALSE 105960
// sContamin := true ;
105952: LD_ADDR_EXP 186
105956: PUSH
105957: LD_INT 1
105959: ST_TO_ADDR
// if p3 = 111 then
105960: LD_VAR 0 3
105964: PUSH
105965: LD_INT 111
105967: EQUAL
105968: IFFALSE 105978
// sOil := true ;
105970: LD_ADDR_EXP 188
105974: PUSH
105975: LD_INT 1
105977: ST_TO_ADDR
// if p3 = 112 then
105978: LD_VAR 0 3
105982: PUSH
105983: LD_INT 112
105985: EQUAL
105986: IFFALSE 105996
// sStu := true ;
105988: LD_ADDR_EXP 192
105992: PUSH
105993: LD_INT 1
105995: ST_TO_ADDR
// if p3 = 113 then
105996: LD_VAR 0 3
106000: PUSH
106001: LD_INT 113
106003: EQUAL
106004: IFFALSE 106014
// sBazooka := true ;
106006: LD_ADDR_EXP 195
106010: PUSH
106011: LD_INT 1
106013: ST_TO_ADDR
// if p3 = 114 then
106014: LD_VAR 0 3
106018: PUSH
106019: LD_INT 114
106021: EQUAL
106022: IFFALSE 106032
// sMortar := true ;
106024: LD_ADDR_EXP 196
106028: PUSH
106029: LD_INT 1
106031: ST_TO_ADDR
// if p3 = 115 then
106032: LD_VAR 0 3
106036: PUSH
106037: LD_INT 115
106039: EQUAL
106040: IFFALSE 106050
// sRanger := true ;
106042: LD_ADDR_EXP 206
106046: PUSH
106047: LD_INT 1
106049: ST_TO_ADDR
// end ; end ;
106050: PPOPN 6
106052: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
106053: LD_EXP 153
106057: PUSH
106058: LD_EXP 158
106062: AND
106063: IFFALSE 106187
106065: GO 106067
106067: DISABLE
106068: LD_INT 0
106070: PPUSH
106071: PPUSH
// begin enable ;
106072: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
106073: LD_ADDR_VAR 0 2
106077: PUSH
106078: LD_INT 22
106080: PUSH
106081: LD_OWVAR 2
106085: PUSH
106086: EMPTY
106087: LIST
106088: LIST
106089: PUSH
106090: LD_INT 2
106092: PUSH
106093: LD_INT 34
106095: PUSH
106096: LD_INT 7
106098: PUSH
106099: EMPTY
106100: LIST
106101: LIST
106102: PUSH
106103: LD_INT 34
106105: PUSH
106106: LD_INT 45
106108: PUSH
106109: EMPTY
106110: LIST
106111: LIST
106112: PUSH
106113: LD_INT 34
106115: PUSH
106116: LD_INT 28
106118: PUSH
106119: EMPTY
106120: LIST
106121: LIST
106122: PUSH
106123: LD_INT 34
106125: PUSH
106126: LD_INT 47
106128: PUSH
106129: EMPTY
106130: LIST
106131: LIST
106132: PUSH
106133: EMPTY
106134: LIST
106135: LIST
106136: LIST
106137: LIST
106138: LIST
106139: PUSH
106140: EMPTY
106141: LIST
106142: LIST
106143: PPUSH
106144: CALL_OW 69
106148: ST_TO_ADDR
// if not tmp then
106149: LD_VAR 0 2
106153: NOT
106154: IFFALSE 106158
// exit ;
106156: GO 106187
// for i in tmp do
106158: LD_ADDR_VAR 0 1
106162: PUSH
106163: LD_VAR 0 2
106167: PUSH
106168: FOR_IN
106169: IFFALSE 106185
// begin SetLives ( i , 0 ) ;
106171: LD_VAR 0 1
106175: PPUSH
106176: LD_INT 0
106178: PPUSH
106179: CALL_OW 234
// end ;
106183: GO 106168
106185: POP
106186: POP
// end ;
106187: PPOPN 2
106189: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
106190: LD_EXP 153
106194: PUSH
106195: LD_EXP 159
106199: AND
106200: IFFALSE 106284
106202: GO 106204
106204: DISABLE
106205: LD_INT 0
106207: PPUSH
106208: PPUSH
// begin enable ;
106209: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
106210: LD_ADDR_VAR 0 2
106214: PUSH
106215: LD_INT 22
106217: PUSH
106218: LD_OWVAR 2
106222: PUSH
106223: EMPTY
106224: LIST
106225: LIST
106226: PUSH
106227: LD_INT 32
106229: PUSH
106230: LD_INT 3
106232: PUSH
106233: EMPTY
106234: LIST
106235: LIST
106236: PUSH
106237: EMPTY
106238: LIST
106239: LIST
106240: PPUSH
106241: CALL_OW 69
106245: ST_TO_ADDR
// if not tmp then
106246: LD_VAR 0 2
106250: NOT
106251: IFFALSE 106255
// exit ;
106253: GO 106284
// for i in tmp do
106255: LD_ADDR_VAR 0 1
106259: PUSH
106260: LD_VAR 0 2
106264: PUSH
106265: FOR_IN
106266: IFFALSE 106282
// begin SetLives ( i , 0 ) ;
106268: LD_VAR 0 1
106272: PPUSH
106273: LD_INT 0
106275: PPUSH
106276: CALL_OW 234
// end ;
106280: GO 106265
106282: POP
106283: POP
// end ;
106284: PPOPN 2
106286: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
106287: LD_EXP 153
106291: PUSH
106292: LD_EXP 156
106296: AND
106297: IFFALSE 106390
106299: GO 106301
106301: DISABLE
106302: LD_INT 0
106304: PPUSH
// begin enable ;
106305: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
106306: LD_ADDR_VAR 0 1
106310: PUSH
106311: LD_INT 22
106313: PUSH
106314: LD_OWVAR 2
106318: PUSH
106319: EMPTY
106320: LIST
106321: LIST
106322: PUSH
106323: LD_INT 2
106325: PUSH
106326: LD_INT 25
106328: PUSH
106329: LD_INT 5
106331: PUSH
106332: EMPTY
106333: LIST
106334: LIST
106335: PUSH
106336: LD_INT 25
106338: PUSH
106339: LD_INT 9
106341: PUSH
106342: EMPTY
106343: LIST
106344: LIST
106345: PUSH
106346: LD_INT 25
106348: PUSH
106349: LD_INT 8
106351: PUSH
106352: EMPTY
106353: LIST
106354: LIST
106355: PUSH
106356: EMPTY
106357: LIST
106358: LIST
106359: LIST
106360: LIST
106361: PUSH
106362: EMPTY
106363: LIST
106364: LIST
106365: PPUSH
106366: CALL_OW 69
106370: PUSH
106371: FOR_IN
106372: IFFALSE 106388
// begin SetClass ( i , 1 ) ;
106374: LD_VAR 0 1
106378: PPUSH
106379: LD_INT 1
106381: PPUSH
106382: CALL_OW 336
// end ;
106386: GO 106371
106388: POP
106389: POP
// end ;
106390: PPOPN 1
106392: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
106393: LD_EXP 153
106397: PUSH
106398: LD_EXP 157
106402: AND
106403: PUSH
106404: LD_OWVAR 65
106408: PUSH
106409: LD_INT 7
106411: LESS
106412: AND
106413: IFFALSE 106427
106415: GO 106417
106417: DISABLE
// begin enable ;
106418: ENABLE
// game_speed := 7 ;
106419: LD_ADDR_OWVAR 65
106423: PUSH
106424: LD_INT 7
106426: ST_TO_ADDR
// end ;
106427: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
106428: LD_EXP 153
106432: PUSH
106433: LD_EXP 160
106437: AND
106438: IFFALSE 106640
106440: GO 106442
106442: DISABLE
106443: LD_INT 0
106445: PPUSH
106446: PPUSH
106447: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
106448: LD_ADDR_VAR 0 3
106452: PUSH
106453: LD_INT 81
106455: PUSH
106456: LD_OWVAR 2
106460: PUSH
106461: EMPTY
106462: LIST
106463: LIST
106464: PUSH
106465: LD_INT 21
106467: PUSH
106468: LD_INT 1
106470: PUSH
106471: EMPTY
106472: LIST
106473: LIST
106474: PUSH
106475: EMPTY
106476: LIST
106477: LIST
106478: PPUSH
106479: CALL_OW 69
106483: ST_TO_ADDR
// if not tmp then
106484: LD_VAR 0 3
106488: NOT
106489: IFFALSE 106493
// exit ;
106491: GO 106640
// if tmp > 5 then
106493: LD_VAR 0 3
106497: PUSH
106498: LD_INT 5
106500: GREATER
106501: IFFALSE 106513
// k := 5 else
106503: LD_ADDR_VAR 0 2
106507: PUSH
106508: LD_INT 5
106510: ST_TO_ADDR
106511: GO 106523
// k := tmp ;
106513: LD_ADDR_VAR 0 2
106517: PUSH
106518: LD_VAR 0 3
106522: ST_TO_ADDR
// for i := 1 to k do
106523: LD_ADDR_VAR 0 1
106527: PUSH
106528: DOUBLE
106529: LD_INT 1
106531: DEC
106532: ST_TO_ADDR
106533: LD_VAR 0 2
106537: PUSH
106538: FOR_TO
106539: IFFALSE 106638
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
106541: LD_VAR 0 3
106545: PUSH
106546: LD_VAR 0 1
106550: ARRAY
106551: PPUSH
106552: LD_VAR 0 1
106556: PUSH
106557: LD_INT 4
106559: MOD
106560: PUSH
106561: LD_INT 1
106563: PLUS
106564: PPUSH
106565: CALL_OW 259
106569: PUSH
106570: LD_INT 10
106572: LESS
106573: IFFALSE 106636
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
106575: LD_VAR 0 3
106579: PUSH
106580: LD_VAR 0 1
106584: ARRAY
106585: PPUSH
106586: LD_VAR 0 1
106590: PUSH
106591: LD_INT 4
106593: MOD
106594: PUSH
106595: LD_INT 1
106597: PLUS
106598: PPUSH
106599: LD_VAR 0 3
106603: PUSH
106604: LD_VAR 0 1
106608: ARRAY
106609: PPUSH
106610: LD_VAR 0 1
106614: PUSH
106615: LD_INT 4
106617: MOD
106618: PUSH
106619: LD_INT 1
106621: PLUS
106622: PPUSH
106623: CALL_OW 259
106627: PUSH
106628: LD_INT 1
106630: PLUS
106631: PPUSH
106632: CALL_OW 237
106636: GO 106538
106638: POP
106639: POP
// end ;
106640: PPOPN 3
106642: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
106643: LD_EXP 153
106647: PUSH
106648: LD_EXP 161
106652: AND
106653: IFFALSE 106673
106655: GO 106657
106657: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
106658: LD_INT 4
106660: PPUSH
106661: LD_OWVAR 2
106665: PPUSH
106666: LD_INT 0
106668: PPUSH
106669: CALL_OW 324
106673: END
// every 0 0$1 trigger StreamModeActive and sShovel do
106674: LD_EXP 153
106678: PUSH
106679: LD_EXP 190
106683: AND
106684: IFFALSE 106704
106686: GO 106688
106688: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
106689: LD_INT 19
106691: PPUSH
106692: LD_OWVAR 2
106696: PPUSH
106697: LD_INT 0
106699: PPUSH
106700: CALL_OW 324
106704: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
106705: LD_EXP 153
106709: PUSH
106710: LD_EXP 162
106714: AND
106715: IFFALSE 106817
106717: GO 106719
106719: DISABLE
106720: LD_INT 0
106722: PPUSH
106723: PPUSH
// begin enable ;
106724: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
106725: LD_ADDR_VAR 0 2
106729: PUSH
106730: LD_INT 22
106732: PUSH
106733: LD_OWVAR 2
106737: PUSH
106738: EMPTY
106739: LIST
106740: LIST
106741: PUSH
106742: LD_INT 2
106744: PUSH
106745: LD_INT 34
106747: PUSH
106748: LD_INT 11
106750: PUSH
106751: EMPTY
106752: LIST
106753: LIST
106754: PUSH
106755: LD_INT 34
106757: PUSH
106758: LD_INT 30
106760: PUSH
106761: EMPTY
106762: LIST
106763: LIST
106764: PUSH
106765: EMPTY
106766: LIST
106767: LIST
106768: LIST
106769: PUSH
106770: EMPTY
106771: LIST
106772: LIST
106773: PPUSH
106774: CALL_OW 69
106778: ST_TO_ADDR
// if not tmp then
106779: LD_VAR 0 2
106783: NOT
106784: IFFALSE 106788
// exit ;
106786: GO 106817
// for i in tmp do
106788: LD_ADDR_VAR 0 1
106792: PUSH
106793: LD_VAR 0 2
106797: PUSH
106798: FOR_IN
106799: IFFALSE 106815
// begin SetLives ( i , 0 ) ;
106801: LD_VAR 0 1
106805: PPUSH
106806: LD_INT 0
106808: PPUSH
106809: CALL_OW 234
// end ;
106813: GO 106798
106815: POP
106816: POP
// end ;
106817: PPOPN 2
106819: END
// every 0 0$1 trigger StreamModeActive and sBunker do
106820: LD_EXP 153
106824: PUSH
106825: LD_EXP 163
106829: AND
106830: IFFALSE 106850
106832: GO 106834
106834: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
106835: LD_INT 32
106837: PPUSH
106838: LD_OWVAR 2
106842: PPUSH
106843: LD_INT 0
106845: PPUSH
106846: CALL_OW 324
106850: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
106851: LD_EXP 153
106855: PUSH
106856: LD_EXP 164
106860: AND
106861: IFFALSE 107042
106863: GO 106865
106865: DISABLE
106866: LD_INT 0
106868: PPUSH
106869: PPUSH
106870: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
106871: LD_ADDR_VAR 0 2
106875: PUSH
106876: LD_INT 22
106878: PUSH
106879: LD_OWVAR 2
106883: PUSH
106884: EMPTY
106885: LIST
106886: LIST
106887: PUSH
106888: LD_INT 33
106890: PUSH
106891: LD_INT 3
106893: PUSH
106894: EMPTY
106895: LIST
106896: LIST
106897: PUSH
106898: EMPTY
106899: LIST
106900: LIST
106901: PPUSH
106902: CALL_OW 69
106906: ST_TO_ADDR
// if not tmp then
106907: LD_VAR 0 2
106911: NOT
106912: IFFALSE 106916
// exit ;
106914: GO 107042
// side := 0 ;
106916: LD_ADDR_VAR 0 3
106920: PUSH
106921: LD_INT 0
106923: ST_TO_ADDR
// for i := 1 to 8 do
106924: LD_ADDR_VAR 0 1
106928: PUSH
106929: DOUBLE
106930: LD_INT 1
106932: DEC
106933: ST_TO_ADDR
106934: LD_INT 8
106936: PUSH
106937: FOR_TO
106938: IFFALSE 106986
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
106940: LD_OWVAR 2
106944: PUSH
106945: LD_VAR 0 1
106949: NONEQUAL
106950: PUSH
106951: LD_OWVAR 2
106955: PPUSH
106956: LD_VAR 0 1
106960: PPUSH
106961: CALL_OW 81
106965: PUSH
106966: LD_INT 2
106968: EQUAL
106969: AND
106970: IFFALSE 106984
// begin side := i ;
106972: LD_ADDR_VAR 0 3
106976: PUSH
106977: LD_VAR 0 1
106981: ST_TO_ADDR
// break ;
106982: GO 106986
// end ;
106984: GO 106937
106986: POP
106987: POP
// if not side then
106988: LD_VAR 0 3
106992: NOT
106993: IFFALSE 106997
// exit ;
106995: GO 107042
// for i := 1 to tmp do
106997: LD_ADDR_VAR 0 1
107001: PUSH
107002: DOUBLE
107003: LD_INT 1
107005: DEC
107006: ST_TO_ADDR
107007: LD_VAR 0 2
107011: PUSH
107012: FOR_TO
107013: IFFALSE 107040
// if Prob ( 60 ) then
107015: LD_INT 60
107017: PPUSH
107018: CALL_OW 13
107022: IFFALSE 107038
// SetSide ( i , side ) ;
107024: LD_VAR 0 1
107028: PPUSH
107029: LD_VAR 0 3
107033: PPUSH
107034: CALL_OW 235
107038: GO 107012
107040: POP
107041: POP
// end ;
107042: PPOPN 3
107044: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
107045: LD_EXP 153
107049: PUSH
107050: LD_EXP 166
107054: AND
107055: IFFALSE 107174
107057: GO 107059
107059: DISABLE
107060: LD_INT 0
107062: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
107063: LD_ADDR_VAR 0 1
107067: PUSH
107068: LD_INT 22
107070: PUSH
107071: LD_OWVAR 2
107075: PUSH
107076: EMPTY
107077: LIST
107078: LIST
107079: PUSH
107080: LD_INT 21
107082: PUSH
107083: LD_INT 1
107085: PUSH
107086: EMPTY
107087: LIST
107088: LIST
107089: PUSH
107090: LD_INT 3
107092: PUSH
107093: LD_INT 23
107095: PUSH
107096: LD_INT 0
107098: PUSH
107099: EMPTY
107100: LIST
107101: LIST
107102: PUSH
107103: EMPTY
107104: LIST
107105: LIST
107106: PUSH
107107: EMPTY
107108: LIST
107109: LIST
107110: LIST
107111: PPUSH
107112: CALL_OW 69
107116: PUSH
107117: FOR_IN
107118: IFFALSE 107172
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
107120: LD_VAR 0 1
107124: PPUSH
107125: CALL_OW 257
107129: PUSH
107130: LD_INT 1
107132: PUSH
107133: LD_INT 2
107135: PUSH
107136: LD_INT 3
107138: PUSH
107139: LD_INT 4
107141: PUSH
107142: EMPTY
107143: LIST
107144: LIST
107145: LIST
107146: LIST
107147: IN
107148: IFFALSE 107170
// SetClass ( un , rand ( 1 , 4 ) ) ;
107150: LD_VAR 0 1
107154: PPUSH
107155: LD_INT 1
107157: PPUSH
107158: LD_INT 4
107160: PPUSH
107161: CALL_OW 12
107165: PPUSH
107166: CALL_OW 336
107170: GO 107117
107172: POP
107173: POP
// end ;
107174: PPOPN 1
107176: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
107177: LD_EXP 153
107181: PUSH
107182: LD_EXP 165
107186: AND
107187: IFFALSE 107266
107189: GO 107191
107191: DISABLE
107192: LD_INT 0
107194: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
107195: LD_ADDR_VAR 0 1
107199: PUSH
107200: LD_INT 22
107202: PUSH
107203: LD_OWVAR 2
107207: PUSH
107208: EMPTY
107209: LIST
107210: LIST
107211: PUSH
107212: LD_INT 21
107214: PUSH
107215: LD_INT 3
107217: PUSH
107218: EMPTY
107219: LIST
107220: LIST
107221: PUSH
107222: EMPTY
107223: LIST
107224: LIST
107225: PPUSH
107226: CALL_OW 69
107230: ST_TO_ADDR
// if not tmp then
107231: LD_VAR 0 1
107235: NOT
107236: IFFALSE 107240
// exit ;
107238: GO 107266
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
107240: LD_VAR 0 1
107244: PUSH
107245: LD_INT 1
107247: PPUSH
107248: LD_VAR 0 1
107252: PPUSH
107253: CALL_OW 12
107257: ARRAY
107258: PPUSH
107259: LD_INT 100
107261: PPUSH
107262: CALL_OW 234
// end ;
107266: PPOPN 1
107268: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
107269: LD_EXP 153
107273: PUSH
107274: LD_EXP 167
107278: AND
107279: IFFALSE 107377
107281: GO 107283
107283: DISABLE
107284: LD_INT 0
107286: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
107287: LD_ADDR_VAR 0 1
107291: PUSH
107292: LD_INT 22
107294: PUSH
107295: LD_OWVAR 2
107299: PUSH
107300: EMPTY
107301: LIST
107302: LIST
107303: PUSH
107304: LD_INT 21
107306: PUSH
107307: LD_INT 1
107309: PUSH
107310: EMPTY
107311: LIST
107312: LIST
107313: PUSH
107314: EMPTY
107315: LIST
107316: LIST
107317: PPUSH
107318: CALL_OW 69
107322: ST_TO_ADDR
// if not tmp then
107323: LD_VAR 0 1
107327: NOT
107328: IFFALSE 107332
// exit ;
107330: GO 107377
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
107332: LD_VAR 0 1
107336: PUSH
107337: LD_INT 1
107339: PPUSH
107340: LD_VAR 0 1
107344: PPUSH
107345: CALL_OW 12
107349: ARRAY
107350: PPUSH
107351: LD_INT 1
107353: PPUSH
107354: LD_INT 4
107356: PPUSH
107357: CALL_OW 12
107361: PPUSH
107362: LD_INT 3000
107364: PPUSH
107365: LD_INT 9000
107367: PPUSH
107368: CALL_OW 12
107372: PPUSH
107373: CALL_OW 492
// end ;
107377: PPOPN 1
107379: END
// every 0 0$1 trigger StreamModeActive and sDepot do
107380: LD_EXP 153
107384: PUSH
107385: LD_EXP 168
107389: AND
107390: IFFALSE 107410
107392: GO 107394
107394: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
107395: LD_INT 1
107397: PPUSH
107398: LD_OWVAR 2
107402: PPUSH
107403: LD_INT 0
107405: PPUSH
107406: CALL_OW 324
107410: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
107411: LD_EXP 153
107415: PUSH
107416: LD_EXP 169
107420: AND
107421: IFFALSE 107504
107423: GO 107425
107425: DISABLE
107426: LD_INT 0
107428: PPUSH
107429: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
107430: LD_ADDR_VAR 0 2
107434: PUSH
107435: LD_INT 22
107437: PUSH
107438: LD_OWVAR 2
107442: PUSH
107443: EMPTY
107444: LIST
107445: LIST
107446: PUSH
107447: LD_INT 21
107449: PUSH
107450: LD_INT 3
107452: PUSH
107453: EMPTY
107454: LIST
107455: LIST
107456: PUSH
107457: EMPTY
107458: LIST
107459: LIST
107460: PPUSH
107461: CALL_OW 69
107465: ST_TO_ADDR
// if not tmp then
107466: LD_VAR 0 2
107470: NOT
107471: IFFALSE 107475
// exit ;
107473: GO 107504
// for i in tmp do
107475: LD_ADDR_VAR 0 1
107479: PUSH
107480: LD_VAR 0 2
107484: PUSH
107485: FOR_IN
107486: IFFALSE 107502
// SetBLevel ( i , 10 ) ;
107488: LD_VAR 0 1
107492: PPUSH
107493: LD_INT 10
107495: PPUSH
107496: CALL_OW 241
107500: GO 107485
107502: POP
107503: POP
// end ;
107504: PPOPN 2
107506: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
107507: LD_EXP 153
107511: PUSH
107512: LD_EXP 170
107516: AND
107517: IFFALSE 107628
107519: GO 107521
107521: DISABLE
107522: LD_INT 0
107524: PPUSH
107525: PPUSH
107526: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
107527: LD_ADDR_VAR 0 3
107531: PUSH
107532: LD_INT 22
107534: PUSH
107535: LD_OWVAR 2
107539: PUSH
107540: EMPTY
107541: LIST
107542: LIST
107543: PUSH
107544: LD_INT 25
107546: PUSH
107547: LD_INT 1
107549: PUSH
107550: EMPTY
107551: LIST
107552: LIST
107553: PUSH
107554: EMPTY
107555: LIST
107556: LIST
107557: PPUSH
107558: CALL_OW 69
107562: ST_TO_ADDR
// if not tmp then
107563: LD_VAR 0 3
107567: NOT
107568: IFFALSE 107572
// exit ;
107570: GO 107628
// un := tmp [ rand ( 1 , tmp ) ] ;
107572: LD_ADDR_VAR 0 2
107576: PUSH
107577: LD_VAR 0 3
107581: PUSH
107582: LD_INT 1
107584: PPUSH
107585: LD_VAR 0 3
107589: PPUSH
107590: CALL_OW 12
107594: ARRAY
107595: ST_TO_ADDR
// if Crawls ( un ) then
107596: LD_VAR 0 2
107600: PPUSH
107601: CALL_OW 318
107605: IFFALSE 107616
// ComWalk ( un ) ;
107607: LD_VAR 0 2
107611: PPUSH
107612: CALL_OW 138
// SetClass ( un , class_sniper ) ;
107616: LD_VAR 0 2
107620: PPUSH
107621: LD_INT 5
107623: PPUSH
107624: CALL_OW 336
// end ;
107628: PPOPN 3
107630: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
107631: LD_EXP 153
107635: PUSH
107636: LD_EXP 171
107640: AND
107641: PUSH
107642: LD_OWVAR 67
107646: PUSH
107647: LD_INT 3
107649: LESS
107650: AND
107651: IFFALSE 107670
107653: GO 107655
107655: DISABLE
// Difficulty := Difficulty + 1 ;
107656: LD_ADDR_OWVAR 67
107660: PUSH
107661: LD_OWVAR 67
107665: PUSH
107666: LD_INT 1
107668: PLUS
107669: ST_TO_ADDR
107670: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
107671: LD_EXP 153
107675: PUSH
107676: LD_EXP 172
107680: AND
107681: IFFALSE 107784
107683: GO 107685
107685: DISABLE
107686: LD_INT 0
107688: PPUSH
// begin for i := 1 to 5 do
107689: LD_ADDR_VAR 0 1
107693: PUSH
107694: DOUBLE
107695: LD_INT 1
107697: DEC
107698: ST_TO_ADDR
107699: LD_INT 5
107701: PUSH
107702: FOR_TO
107703: IFFALSE 107782
// begin uc_nation := nation_nature ;
107705: LD_ADDR_OWVAR 21
107709: PUSH
107710: LD_INT 0
107712: ST_TO_ADDR
// uc_side := 0 ;
107713: LD_ADDR_OWVAR 20
107717: PUSH
107718: LD_INT 0
107720: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
107721: LD_ADDR_OWVAR 29
107725: PUSH
107726: LD_INT 12
107728: PUSH
107729: LD_INT 12
107731: PUSH
107732: EMPTY
107733: LIST
107734: LIST
107735: ST_TO_ADDR
// hc_agressivity := 20 ;
107736: LD_ADDR_OWVAR 35
107740: PUSH
107741: LD_INT 20
107743: ST_TO_ADDR
// hc_class := class_tiger ;
107744: LD_ADDR_OWVAR 28
107748: PUSH
107749: LD_INT 14
107751: ST_TO_ADDR
// hc_gallery :=  ;
107752: LD_ADDR_OWVAR 33
107756: PUSH
107757: LD_STRING 
107759: ST_TO_ADDR
// hc_name :=  ;
107760: LD_ADDR_OWVAR 26
107764: PUSH
107765: LD_STRING 
107767: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
107768: CALL_OW 44
107772: PPUSH
107773: LD_INT 0
107775: PPUSH
107776: CALL_OW 51
// end ;
107780: GO 107702
107782: POP
107783: POP
// end ;
107784: PPOPN 1
107786: END
// every 0 0$1 trigger StreamModeActive and sBomb do
107787: LD_EXP 153
107791: PUSH
107792: LD_EXP 173
107796: AND
107797: IFFALSE 107806
107799: GO 107801
107801: DISABLE
// StreamSibBomb ;
107802: CALL 107807 0 0
107806: END
// export function StreamSibBomb ; var i , x , y ; begin
107807: LD_INT 0
107809: PPUSH
107810: PPUSH
107811: PPUSH
107812: PPUSH
// result := false ;
107813: LD_ADDR_VAR 0 1
107817: PUSH
107818: LD_INT 0
107820: ST_TO_ADDR
// for i := 1 to 16 do
107821: LD_ADDR_VAR 0 2
107825: PUSH
107826: DOUBLE
107827: LD_INT 1
107829: DEC
107830: ST_TO_ADDR
107831: LD_INT 16
107833: PUSH
107834: FOR_TO
107835: IFFALSE 108034
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
107837: LD_ADDR_VAR 0 3
107841: PUSH
107842: LD_INT 10
107844: PUSH
107845: LD_INT 20
107847: PUSH
107848: LD_INT 30
107850: PUSH
107851: LD_INT 40
107853: PUSH
107854: LD_INT 50
107856: PUSH
107857: LD_INT 60
107859: PUSH
107860: LD_INT 70
107862: PUSH
107863: LD_INT 80
107865: PUSH
107866: LD_INT 90
107868: PUSH
107869: LD_INT 100
107871: PUSH
107872: LD_INT 110
107874: PUSH
107875: LD_INT 120
107877: PUSH
107878: LD_INT 130
107880: PUSH
107881: LD_INT 140
107883: PUSH
107884: LD_INT 150
107886: PUSH
107887: EMPTY
107888: LIST
107889: LIST
107890: LIST
107891: LIST
107892: LIST
107893: LIST
107894: LIST
107895: LIST
107896: LIST
107897: LIST
107898: LIST
107899: LIST
107900: LIST
107901: LIST
107902: LIST
107903: PUSH
107904: LD_INT 1
107906: PPUSH
107907: LD_INT 15
107909: PPUSH
107910: CALL_OW 12
107914: ARRAY
107915: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
107916: LD_ADDR_VAR 0 4
107920: PUSH
107921: LD_INT 10
107923: PUSH
107924: LD_INT 20
107926: PUSH
107927: LD_INT 30
107929: PUSH
107930: LD_INT 40
107932: PUSH
107933: LD_INT 50
107935: PUSH
107936: LD_INT 60
107938: PUSH
107939: LD_INT 70
107941: PUSH
107942: LD_INT 80
107944: PUSH
107945: LD_INT 90
107947: PUSH
107948: LD_INT 100
107950: PUSH
107951: LD_INT 110
107953: PUSH
107954: LD_INT 120
107956: PUSH
107957: LD_INT 130
107959: PUSH
107960: LD_INT 140
107962: PUSH
107963: LD_INT 150
107965: PUSH
107966: EMPTY
107967: LIST
107968: LIST
107969: LIST
107970: LIST
107971: LIST
107972: LIST
107973: LIST
107974: LIST
107975: LIST
107976: LIST
107977: LIST
107978: LIST
107979: LIST
107980: LIST
107981: LIST
107982: PUSH
107983: LD_INT 1
107985: PPUSH
107986: LD_INT 15
107988: PPUSH
107989: CALL_OW 12
107993: ARRAY
107994: ST_TO_ADDR
// if ValidHex ( x , y ) then
107995: LD_VAR 0 3
107999: PPUSH
108000: LD_VAR 0 4
108004: PPUSH
108005: CALL_OW 488
108009: IFFALSE 108032
// begin result := [ x , y ] ;
108011: LD_ADDR_VAR 0 1
108015: PUSH
108016: LD_VAR 0 3
108020: PUSH
108021: LD_VAR 0 4
108025: PUSH
108026: EMPTY
108027: LIST
108028: LIST
108029: ST_TO_ADDR
// break ;
108030: GO 108034
// end ; end ;
108032: GO 107834
108034: POP
108035: POP
// if result then
108036: LD_VAR 0 1
108040: IFFALSE 108100
// begin ToLua ( playSibBomb() ) ;
108042: LD_STRING playSibBomb()
108044: PPUSH
108045: CALL_OW 559
// wait ( 0 0$14 ) ;
108049: LD_INT 490
108051: PPUSH
108052: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
108056: LD_VAR 0 1
108060: PUSH
108061: LD_INT 1
108063: ARRAY
108064: PPUSH
108065: LD_VAR 0 1
108069: PUSH
108070: LD_INT 2
108072: ARRAY
108073: PPUSH
108074: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
108078: LD_VAR 0 1
108082: PUSH
108083: LD_INT 1
108085: ARRAY
108086: PPUSH
108087: LD_VAR 0 1
108091: PUSH
108092: LD_INT 2
108094: ARRAY
108095: PPUSH
108096: CALL_OW 429
// end ; end ;
108100: LD_VAR 0 1
108104: RET
// every 0 0$1 trigger StreamModeActive and sReset do
108105: LD_EXP 153
108109: PUSH
108110: LD_EXP 175
108114: AND
108115: IFFALSE 108127
108117: GO 108119
108119: DISABLE
// YouLost (  ) ;
108120: LD_STRING 
108122: PPUSH
108123: CALL_OW 104
108127: END
// every 0 0$1 trigger StreamModeActive and sFog do
108128: LD_EXP 153
108132: PUSH
108133: LD_EXP 174
108137: AND
108138: IFFALSE 108152
108140: GO 108142
108142: DISABLE
// FogOff ( your_side ) ;
108143: LD_OWVAR 2
108147: PPUSH
108148: CALL_OW 344
108152: END
// every 0 0$1 trigger StreamModeActive and sSun do
108153: LD_EXP 153
108157: PUSH
108158: LD_EXP 176
108162: AND
108163: IFFALSE 108191
108165: GO 108167
108167: DISABLE
// begin solar_recharge_percent := 0 ;
108168: LD_ADDR_OWVAR 79
108172: PUSH
108173: LD_INT 0
108175: ST_TO_ADDR
// wait ( 5 5$00 ) ;
108176: LD_INT 10500
108178: PPUSH
108179: CALL_OW 67
// solar_recharge_percent := 100 ;
108183: LD_ADDR_OWVAR 79
108187: PUSH
108188: LD_INT 100
108190: ST_TO_ADDR
// end ;
108191: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
108192: LD_EXP 153
108196: PUSH
108197: LD_EXP 177
108201: AND
108202: IFFALSE 108441
108204: GO 108206
108206: DISABLE
108207: LD_INT 0
108209: PPUSH
108210: PPUSH
108211: PPUSH
// begin tmp := [ ] ;
108212: LD_ADDR_VAR 0 3
108216: PUSH
108217: EMPTY
108218: ST_TO_ADDR
// for i := 1 to 6 do
108219: LD_ADDR_VAR 0 1
108223: PUSH
108224: DOUBLE
108225: LD_INT 1
108227: DEC
108228: ST_TO_ADDR
108229: LD_INT 6
108231: PUSH
108232: FOR_TO
108233: IFFALSE 108338
// begin uc_nation := nation_nature ;
108235: LD_ADDR_OWVAR 21
108239: PUSH
108240: LD_INT 0
108242: ST_TO_ADDR
// uc_side := 0 ;
108243: LD_ADDR_OWVAR 20
108247: PUSH
108248: LD_INT 0
108250: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
108251: LD_ADDR_OWVAR 29
108255: PUSH
108256: LD_INT 12
108258: PUSH
108259: LD_INT 12
108261: PUSH
108262: EMPTY
108263: LIST
108264: LIST
108265: ST_TO_ADDR
// hc_agressivity := 20 ;
108266: LD_ADDR_OWVAR 35
108270: PUSH
108271: LD_INT 20
108273: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
108274: LD_ADDR_OWVAR 28
108278: PUSH
108279: LD_INT 17
108281: ST_TO_ADDR
// hc_gallery :=  ;
108282: LD_ADDR_OWVAR 33
108286: PUSH
108287: LD_STRING 
108289: ST_TO_ADDR
// hc_name :=  ;
108290: LD_ADDR_OWVAR 26
108294: PUSH
108295: LD_STRING 
108297: ST_TO_ADDR
// un := CreateHuman ;
108298: LD_ADDR_VAR 0 2
108302: PUSH
108303: CALL_OW 44
108307: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
108308: LD_VAR 0 2
108312: PPUSH
108313: LD_INT 1
108315: PPUSH
108316: CALL_OW 51
// tmp := tmp ^ un ;
108320: LD_ADDR_VAR 0 3
108324: PUSH
108325: LD_VAR 0 3
108329: PUSH
108330: LD_VAR 0 2
108334: ADD
108335: ST_TO_ADDR
// end ;
108336: GO 108232
108338: POP
108339: POP
// repeat wait ( 0 0$1 ) ;
108340: LD_INT 35
108342: PPUSH
108343: CALL_OW 67
// for un in tmp do
108347: LD_ADDR_VAR 0 2
108351: PUSH
108352: LD_VAR 0 3
108356: PUSH
108357: FOR_IN
108358: IFFALSE 108432
// begin if IsDead ( un ) then
108360: LD_VAR 0 2
108364: PPUSH
108365: CALL_OW 301
108369: IFFALSE 108389
// begin tmp := tmp diff un ;
108371: LD_ADDR_VAR 0 3
108375: PUSH
108376: LD_VAR 0 3
108380: PUSH
108381: LD_VAR 0 2
108385: DIFF
108386: ST_TO_ADDR
// continue ;
108387: GO 108357
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
108389: LD_VAR 0 2
108393: PPUSH
108394: LD_INT 3
108396: PUSH
108397: LD_INT 22
108399: PUSH
108400: LD_INT 0
108402: PUSH
108403: EMPTY
108404: LIST
108405: LIST
108406: PUSH
108407: EMPTY
108408: LIST
108409: LIST
108410: PPUSH
108411: CALL_OW 69
108415: PPUSH
108416: LD_VAR 0 2
108420: PPUSH
108421: CALL_OW 74
108425: PPUSH
108426: CALL_OW 115
// end ;
108430: GO 108357
108432: POP
108433: POP
// until not tmp ;
108434: LD_VAR 0 3
108438: NOT
108439: IFFALSE 108340
// end ;
108441: PPOPN 3
108443: END
// every 0 0$1 trigger StreamModeActive and sTroll do
108444: LD_EXP 153
108448: PUSH
108449: LD_EXP 178
108453: AND
108454: IFFALSE 108508
108456: GO 108458
108458: DISABLE
// begin ToLua ( displayTroll(); ) ;
108459: LD_STRING displayTroll();
108461: PPUSH
108462: CALL_OW 559
// wait ( 3 3$00 ) ;
108466: LD_INT 6300
108468: PPUSH
108469: CALL_OW 67
// ToLua ( hideTroll(); ) ;
108473: LD_STRING hideTroll();
108475: PPUSH
108476: CALL_OW 559
// wait ( 1 1$00 ) ;
108480: LD_INT 2100
108482: PPUSH
108483: CALL_OW 67
// ToLua ( displayTroll(); ) ;
108487: LD_STRING displayTroll();
108489: PPUSH
108490: CALL_OW 559
// wait ( 1 1$00 ) ;
108494: LD_INT 2100
108496: PPUSH
108497: CALL_OW 67
// ToLua ( hideTroll(); ) ;
108501: LD_STRING hideTroll();
108503: PPUSH
108504: CALL_OW 559
// end ;
108508: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
108509: LD_EXP 153
108513: PUSH
108514: LD_EXP 179
108518: AND
108519: IFFALSE 108582
108521: GO 108523
108523: DISABLE
108524: LD_INT 0
108526: PPUSH
// begin p := 0 ;
108527: LD_ADDR_VAR 0 1
108531: PUSH
108532: LD_INT 0
108534: ST_TO_ADDR
// repeat game_speed := 1 ;
108535: LD_ADDR_OWVAR 65
108539: PUSH
108540: LD_INT 1
108542: ST_TO_ADDR
// wait ( 0 0$1 ) ;
108543: LD_INT 35
108545: PPUSH
108546: CALL_OW 67
// p := p + 1 ;
108550: LD_ADDR_VAR 0 1
108554: PUSH
108555: LD_VAR 0 1
108559: PUSH
108560: LD_INT 1
108562: PLUS
108563: ST_TO_ADDR
// until p >= 60 ;
108564: LD_VAR 0 1
108568: PUSH
108569: LD_INT 60
108571: GREATEREQUAL
108572: IFFALSE 108535
// game_speed := 4 ;
108574: LD_ADDR_OWVAR 65
108578: PUSH
108579: LD_INT 4
108581: ST_TO_ADDR
// end ;
108582: PPOPN 1
108584: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
108585: LD_EXP 153
108589: PUSH
108590: LD_EXP 180
108594: AND
108595: IFFALSE 108741
108597: GO 108599
108599: DISABLE
108600: LD_INT 0
108602: PPUSH
108603: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
108604: LD_ADDR_VAR 0 1
108608: PUSH
108609: LD_INT 22
108611: PUSH
108612: LD_OWVAR 2
108616: PUSH
108617: EMPTY
108618: LIST
108619: LIST
108620: PUSH
108621: LD_INT 2
108623: PUSH
108624: LD_INT 30
108626: PUSH
108627: LD_INT 0
108629: PUSH
108630: EMPTY
108631: LIST
108632: LIST
108633: PUSH
108634: LD_INT 30
108636: PUSH
108637: LD_INT 1
108639: PUSH
108640: EMPTY
108641: LIST
108642: LIST
108643: PUSH
108644: EMPTY
108645: LIST
108646: LIST
108647: LIST
108648: PUSH
108649: EMPTY
108650: LIST
108651: LIST
108652: PPUSH
108653: CALL_OW 69
108657: ST_TO_ADDR
// if not depot then
108658: LD_VAR 0 1
108662: NOT
108663: IFFALSE 108667
// exit ;
108665: GO 108741
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
108667: LD_ADDR_VAR 0 2
108671: PUSH
108672: LD_VAR 0 1
108676: PUSH
108677: LD_INT 1
108679: PPUSH
108680: LD_VAR 0 1
108684: PPUSH
108685: CALL_OW 12
108689: ARRAY
108690: PPUSH
108691: CALL_OW 274
108695: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
108696: LD_VAR 0 2
108700: PPUSH
108701: LD_INT 1
108703: PPUSH
108704: LD_INT 0
108706: PPUSH
108707: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
108711: LD_VAR 0 2
108715: PPUSH
108716: LD_INT 2
108718: PPUSH
108719: LD_INT 0
108721: PPUSH
108722: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
108726: LD_VAR 0 2
108730: PPUSH
108731: LD_INT 3
108733: PPUSH
108734: LD_INT 0
108736: PPUSH
108737: CALL_OW 277
// end ;
108741: PPOPN 2
108743: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
108744: LD_EXP 153
108748: PUSH
108749: LD_EXP 181
108753: AND
108754: IFFALSE 108851
108756: GO 108758
108758: DISABLE
108759: LD_INT 0
108761: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
108762: LD_ADDR_VAR 0 1
108766: PUSH
108767: LD_INT 22
108769: PUSH
108770: LD_OWVAR 2
108774: PUSH
108775: EMPTY
108776: LIST
108777: LIST
108778: PUSH
108779: LD_INT 21
108781: PUSH
108782: LD_INT 1
108784: PUSH
108785: EMPTY
108786: LIST
108787: LIST
108788: PUSH
108789: LD_INT 3
108791: PUSH
108792: LD_INT 23
108794: PUSH
108795: LD_INT 0
108797: PUSH
108798: EMPTY
108799: LIST
108800: LIST
108801: PUSH
108802: EMPTY
108803: LIST
108804: LIST
108805: PUSH
108806: EMPTY
108807: LIST
108808: LIST
108809: LIST
108810: PPUSH
108811: CALL_OW 69
108815: ST_TO_ADDR
// if not tmp then
108816: LD_VAR 0 1
108820: NOT
108821: IFFALSE 108825
// exit ;
108823: GO 108851
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
108825: LD_VAR 0 1
108829: PUSH
108830: LD_INT 1
108832: PPUSH
108833: LD_VAR 0 1
108837: PPUSH
108838: CALL_OW 12
108842: ARRAY
108843: PPUSH
108844: LD_INT 200
108846: PPUSH
108847: CALL_OW 234
// end ;
108851: PPOPN 1
108853: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
108854: LD_EXP 153
108858: PUSH
108859: LD_EXP 182
108863: AND
108864: IFFALSE 108943
108866: GO 108868
108868: DISABLE
108869: LD_INT 0
108871: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
108872: LD_ADDR_VAR 0 1
108876: PUSH
108877: LD_INT 22
108879: PUSH
108880: LD_OWVAR 2
108884: PUSH
108885: EMPTY
108886: LIST
108887: LIST
108888: PUSH
108889: LD_INT 21
108891: PUSH
108892: LD_INT 2
108894: PUSH
108895: EMPTY
108896: LIST
108897: LIST
108898: PUSH
108899: EMPTY
108900: LIST
108901: LIST
108902: PPUSH
108903: CALL_OW 69
108907: ST_TO_ADDR
// if not tmp then
108908: LD_VAR 0 1
108912: NOT
108913: IFFALSE 108917
// exit ;
108915: GO 108943
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
108917: LD_VAR 0 1
108921: PUSH
108922: LD_INT 1
108924: PPUSH
108925: LD_VAR 0 1
108929: PPUSH
108930: CALL_OW 12
108934: ARRAY
108935: PPUSH
108936: LD_INT 60
108938: PPUSH
108939: CALL_OW 234
// end ;
108943: PPOPN 1
108945: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
108946: LD_EXP 153
108950: PUSH
108951: LD_EXP 183
108955: AND
108956: IFFALSE 109055
108958: GO 108960
108960: DISABLE
108961: LD_INT 0
108963: PPUSH
108964: PPUSH
// begin enable ;
108965: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
108966: LD_ADDR_VAR 0 1
108970: PUSH
108971: LD_INT 22
108973: PUSH
108974: LD_OWVAR 2
108978: PUSH
108979: EMPTY
108980: LIST
108981: LIST
108982: PUSH
108983: LD_INT 61
108985: PUSH
108986: EMPTY
108987: LIST
108988: PUSH
108989: LD_INT 33
108991: PUSH
108992: LD_INT 2
108994: PUSH
108995: EMPTY
108996: LIST
108997: LIST
108998: PUSH
108999: EMPTY
109000: LIST
109001: LIST
109002: LIST
109003: PPUSH
109004: CALL_OW 69
109008: ST_TO_ADDR
// if not tmp then
109009: LD_VAR 0 1
109013: NOT
109014: IFFALSE 109018
// exit ;
109016: GO 109055
// for i in tmp do
109018: LD_ADDR_VAR 0 2
109022: PUSH
109023: LD_VAR 0 1
109027: PUSH
109028: FOR_IN
109029: IFFALSE 109053
// if IsControledBy ( i ) then
109031: LD_VAR 0 2
109035: PPUSH
109036: CALL_OW 312
109040: IFFALSE 109051
// ComUnlink ( i ) ;
109042: LD_VAR 0 2
109046: PPUSH
109047: CALL_OW 136
109051: GO 109028
109053: POP
109054: POP
// end ;
109055: PPOPN 2
109057: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
109058: LD_EXP 153
109062: PUSH
109063: LD_EXP 184
109067: AND
109068: IFFALSE 109208
109070: GO 109072
109072: DISABLE
109073: LD_INT 0
109075: PPUSH
109076: PPUSH
// begin ToLua ( displayPowell(); ) ;
109077: LD_STRING displayPowell();
109079: PPUSH
109080: CALL_OW 559
// uc_side := 0 ;
109084: LD_ADDR_OWVAR 20
109088: PUSH
109089: LD_INT 0
109091: ST_TO_ADDR
// uc_nation := 2 ;
109092: LD_ADDR_OWVAR 21
109096: PUSH
109097: LD_INT 2
109099: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
109100: LD_ADDR_OWVAR 37
109104: PUSH
109105: LD_INT 14
109107: ST_TO_ADDR
// vc_engine := engine_siberite ;
109108: LD_ADDR_OWVAR 39
109112: PUSH
109113: LD_INT 3
109115: ST_TO_ADDR
// vc_control := control_apeman ;
109116: LD_ADDR_OWVAR 38
109120: PUSH
109121: LD_INT 5
109123: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
109124: LD_ADDR_OWVAR 40
109128: PUSH
109129: LD_INT 29
109131: ST_TO_ADDR
// un := CreateVehicle ;
109132: LD_ADDR_VAR 0 2
109136: PUSH
109137: CALL_OW 45
109141: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
109142: LD_VAR 0 2
109146: PPUSH
109147: LD_INT 1
109149: PPUSH
109150: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
109154: LD_INT 35
109156: PPUSH
109157: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
109161: LD_VAR 0 2
109165: PPUSH
109166: LD_INT 22
109168: PUSH
109169: LD_OWVAR 2
109173: PUSH
109174: EMPTY
109175: LIST
109176: LIST
109177: PPUSH
109178: CALL_OW 69
109182: PPUSH
109183: LD_VAR 0 2
109187: PPUSH
109188: CALL_OW 74
109192: PPUSH
109193: CALL_OW 115
// until IsDead ( un ) ;
109197: LD_VAR 0 2
109201: PPUSH
109202: CALL_OW 301
109206: IFFALSE 109154
// end ;
109208: PPOPN 2
109210: END
// every 0 0$1 trigger StreamModeActive and sStu do
109211: LD_EXP 153
109215: PUSH
109216: LD_EXP 192
109220: AND
109221: IFFALSE 109237
109223: GO 109225
109225: DISABLE
// begin ToLua ( displayStucuk(); ) ;
109226: LD_STRING displayStucuk();
109228: PPUSH
109229: CALL_OW 559
// ResetFog ;
109233: CALL_OW 335
// end ;
109237: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
109238: LD_EXP 153
109242: PUSH
109243: LD_EXP 185
109247: AND
109248: IFFALSE 109389
109250: GO 109252
109252: DISABLE
109253: LD_INT 0
109255: PPUSH
109256: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
109257: LD_ADDR_VAR 0 2
109261: PUSH
109262: LD_INT 22
109264: PUSH
109265: LD_OWVAR 2
109269: PUSH
109270: EMPTY
109271: LIST
109272: LIST
109273: PUSH
109274: LD_INT 21
109276: PUSH
109277: LD_INT 1
109279: PUSH
109280: EMPTY
109281: LIST
109282: LIST
109283: PUSH
109284: EMPTY
109285: LIST
109286: LIST
109287: PPUSH
109288: CALL_OW 69
109292: ST_TO_ADDR
// if not tmp then
109293: LD_VAR 0 2
109297: NOT
109298: IFFALSE 109302
// exit ;
109300: GO 109389
// un := tmp [ rand ( 1 , tmp ) ] ;
109302: LD_ADDR_VAR 0 1
109306: PUSH
109307: LD_VAR 0 2
109311: PUSH
109312: LD_INT 1
109314: PPUSH
109315: LD_VAR 0 2
109319: PPUSH
109320: CALL_OW 12
109324: ARRAY
109325: ST_TO_ADDR
// SetSide ( un , 0 ) ;
109326: LD_VAR 0 1
109330: PPUSH
109331: LD_INT 0
109333: PPUSH
109334: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
109338: LD_VAR 0 1
109342: PPUSH
109343: LD_OWVAR 3
109347: PUSH
109348: LD_VAR 0 1
109352: DIFF
109353: PPUSH
109354: LD_VAR 0 1
109358: PPUSH
109359: CALL_OW 74
109363: PPUSH
109364: CALL_OW 115
// wait ( 0 0$20 ) ;
109368: LD_INT 700
109370: PPUSH
109371: CALL_OW 67
// SetSide ( un , your_side ) ;
109375: LD_VAR 0 1
109379: PPUSH
109380: LD_OWVAR 2
109384: PPUSH
109385: CALL_OW 235
// end ;
109389: PPOPN 2
109391: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
109392: LD_EXP 153
109396: PUSH
109397: LD_EXP 186
109401: AND
109402: IFFALSE 109508
109404: GO 109406
109406: DISABLE
109407: LD_INT 0
109409: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
109410: LD_ADDR_VAR 0 1
109414: PUSH
109415: LD_INT 22
109417: PUSH
109418: LD_OWVAR 2
109422: PUSH
109423: EMPTY
109424: LIST
109425: LIST
109426: PUSH
109427: LD_INT 2
109429: PUSH
109430: LD_INT 30
109432: PUSH
109433: LD_INT 0
109435: PUSH
109436: EMPTY
109437: LIST
109438: LIST
109439: PUSH
109440: LD_INT 30
109442: PUSH
109443: LD_INT 1
109445: PUSH
109446: EMPTY
109447: LIST
109448: LIST
109449: PUSH
109450: EMPTY
109451: LIST
109452: LIST
109453: LIST
109454: PUSH
109455: EMPTY
109456: LIST
109457: LIST
109458: PPUSH
109459: CALL_OW 69
109463: ST_TO_ADDR
// if not depot then
109464: LD_VAR 0 1
109468: NOT
109469: IFFALSE 109473
// exit ;
109471: GO 109508
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
109473: LD_VAR 0 1
109477: PUSH
109478: LD_INT 1
109480: ARRAY
109481: PPUSH
109482: CALL_OW 250
109486: PPUSH
109487: LD_VAR 0 1
109491: PUSH
109492: LD_INT 1
109494: ARRAY
109495: PPUSH
109496: CALL_OW 251
109500: PPUSH
109501: LD_INT 70
109503: PPUSH
109504: CALL_OW 495
// end ;
109508: PPOPN 1
109510: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
109511: LD_EXP 153
109515: PUSH
109516: LD_EXP 187
109520: AND
109521: IFFALSE 109732
109523: GO 109525
109525: DISABLE
109526: LD_INT 0
109528: PPUSH
109529: PPUSH
109530: PPUSH
109531: PPUSH
109532: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
109533: LD_ADDR_VAR 0 5
109537: PUSH
109538: LD_INT 22
109540: PUSH
109541: LD_OWVAR 2
109545: PUSH
109546: EMPTY
109547: LIST
109548: LIST
109549: PUSH
109550: LD_INT 21
109552: PUSH
109553: LD_INT 1
109555: PUSH
109556: EMPTY
109557: LIST
109558: LIST
109559: PUSH
109560: EMPTY
109561: LIST
109562: LIST
109563: PPUSH
109564: CALL_OW 69
109568: ST_TO_ADDR
// if not tmp then
109569: LD_VAR 0 5
109573: NOT
109574: IFFALSE 109578
// exit ;
109576: GO 109732
// for i in tmp do
109578: LD_ADDR_VAR 0 1
109582: PUSH
109583: LD_VAR 0 5
109587: PUSH
109588: FOR_IN
109589: IFFALSE 109730
// begin d := rand ( 0 , 5 ) ;
109591: LD_ADDR_VAR 0 4
109595: PUSH
109596: LD_INT 0
109598: PPUSH
109599: LD_INT 5
109601: PPUSH
109602: CALL_OW 12
109606: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
109607: LD_ADDR_VAR 0 2
109611: PUSH
109612: LD_VAR 0 1
109616: PPUSH
109617: CALL_OW 250
109621: PPUSH
109622: LD_VAR 0 4
109626: PPUSH
109627: LD_INT 3
109629: PPUSH
109630: LD_INT 12
109632: PPUSH
109633: CALL_OW 12
109637: PPUSH
109638: CALL_OW 272
109642: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
109643: LD_ADDR_VAR 0 3
109647: PUSH
109648: LD_VAR 0 1
109652: PPUSH
109653: CALL_OW 251
109657: PPUSH
109658: LD_VAR 0 4
109662: PPUSH
109663: LD_INT 3
109665: PPUSH
109666: LD_INT 12
109668: PPUSH
109669: CALL_OW 12
109673: PPUSH
109674: CALL_OW 273
109678: ST_TO_ADDR
// if ValidHex ( x , y ) then
109679: LD_VAR 0 2
109683: PPUSH
109684: LD_VAR 0 3
109688: PPUSH
109689: CALL_OW 488
109693: IFFALSE 109728
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
109695: LD_VAR 0 1
109699: PPUSH
109700: LD_VAR 0 2
109704: PPUSH
109705: LD_VAR 0 3
109709: PPUSH
109710: LD_INT 3
109712: PPUSH
109713: LD_INT 6
109715: PPUSH
109716: CALL_OW 12
109720: PPUSH
109721: LD_INT 1
109723: PPUSH
109724: CALL_OW 483
// end ;
109728: GO 109588
109730: POP
109731: POP
// end ;
109732: PPOPN 5
109734: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
109735: LD_EXP 153
109739: PUSH
109740: LD_EXP 188
109744: AND
109745: IFFALSE 109839
109747: GO 109749
109749: DISABLE
109750: LD_INT 0
109752: PPUSH
109753: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
109754: LD_ADDR_VAR 0 2
109758: PUSH
109759: LD_INT 22
109761: PUSH
109762: LD_OWVAR 2
109766: PUSH
109767: EMPTY
109768: LIST
109769: LIST
109770: PUSH
109771: LD_INT 32
109773: PUSH
109774: LD_INT 1
109776: PUSH
109777: EMPTY
109778: LIST
109779: LIST
109780: PUSH
109781: LD_INT 21
109783: PUSH
109784: LD_INT 2
109786: PUSH
109787: EMPTY
109788: LIST
109789: LIST
109790: PUSH
109791: EMPTY
109792: LIST
109793: LIST
109794: LIST
109795: PPUSH
109796: CALL_OW 69
109800: ST_TO_ADDR
// if not tmp then
109801: LD_VAR 0 2
109805: NOT
109806: IFFALSE 109810
// exit ;
109808: GO 109839
// for i in tmp do
109810: LD_ADDR_VAR 0 1
109814: PUSH
109815: LD_VAR 0 2
109819: PUSH
109820: FOR_IN
109821: IFFALSE 109837
// SetFuel ( i , 0 ) ;
109823: LD_VAR 0 1
109827: PPUSH
109828: LD_INT 0
109830: PPUSH
109831: CALL_OW 240
109835: GO 109820
109837: POP
109838: POP
// end ;
109839: PPOPN 2
109841: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
109842: LD_EXP 153
109846: PUSH
109847: LD_EXP 189
109851: AND
109852: IFFALSE 109918
109854: GO 109856
109856: DISABLE
109857: LD_INT 0
109859: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
109860: LD_ADDR_VAR 0 1
109864: PUSH
109865: LD_INT 22
109867: PUSH
109868: LD_OWVAR 2
109872: PUSH
109873: EMPTY
109874: LIST
109875: LIST
109876: PUSH
109877: LD_INT 30
109879: PUSH
109880: LD_INT 29
109882: PUSH
109883: EMPTY
109884: LIST
109885: LIST
109886: PUSH
109887: EMPTY
109888: LIST
109889: LIST
109890: PPUSH
109891: CALL_OW 69
109895: ST_TO_ADDR
// if not tmp then
109896: LD_VAR 0 1
109900: NOT
109901: IFFALSE 109905
// exit ;
109903: GO 109918
// DestroyUnit ( tmp [ 1 ] ) ;
109905: LD_VAR 0 1
109909: PUSH
109910: LD_INT 1
109912: ARRAY
109913: PPUSH
109914: CALL_OW 65
// end ;
109918: PPOPN 1
109920: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
109921: LD_EXP 153
109925: PUSH
109926: LD_EXP 191
109930: AND
109931: IFFALSE 110060
109933: GO 109935
109935: DISABLE
109936: LD_INT 0
109938: PPUSH
// begin uc_side := 0 ;
109939: LD_ADDR_OWVAR 20
109943: PUSH
109944: LD_INT 0
109946: ST_TO_ADDR
// uc_nation := nation_arabian ;
109947: LD_ADDR_OWVAR 21
109951: PUSH
109952: LD_INT 2
109954: ST_TO_ADDR
// hc_gallery :=  ;
109955: LD_ADDR_OWVAR 33
109959: PUSH
109960: LD_STRING 
109962: ST_TO_ADDR
// hc_name :=  ;
109963: LD_ADDR_OWVAR 26
109967: PUSH
109968: LD_STRING 
109970: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
109971: LD_INT 1
109973: PPUSH
109974: LD_INT 11
109976: PPUSH
109977: LD_INT 10
109979: PPUSH
109980: CALL_OW 380
// un := CreateHuman ;
109984: LD_ADDR_VAR 0 1
109988: PUSH
109989: CALL_OW 44
109993: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
109994: LD_VAR 0 1
109998: PPUSH
109999: LD_INT 1
110001: PPUSH
110002: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
110006: LD_INT 35
110008: PPUSH
110009: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
110013: LD_VAR 0 1
110017: PPUSH
110018: LD_INT 22
110020: PUSH
110021: LD_OWVAR 2
110025: PUSH
110026: EMPTY
110027: LIST
110028: LIST
110029: PPUSH
110030: CALL_OW 69
110034: PPUSH
110035: LD_VAR 0 1
110039: PPUSH
110040: CALL_OW 74
110044: PPUSH
110045: CALL_OW 115
// until IsDead ( un ) ;
110049: LD_VAR 0 1
110053: PPUSH
110054: CALL_OW 301
110058: IFFALSE 110006
// end ;
110060: PPOPN 1
110062: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
110063: LD_EXP 153
110067: PUSH
110068: LD_EXP 193
110072: AND
110073: IFFALSE 110085
110075: GO 110077
110077: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
110078: LD_STRING earthquake(getX(game), 0, 32)
110080: PPUSH
110081: CALL_OW 559
110085: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
110086: LD_EXP 153
110090: PUSH
110091: LD_EXP 194
110095: AND
110096: IFFALSE 110187
110098: GO 110100
110100: DISABLE
110101: LD_INT 0
110103: PPUSH
// begin enable ;
110104: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
110105: LD_ADDR_VAR 0 1
110109: PUSH
110110: LD_INT 22
110112: PUSH
110113: LD_OWVAR 2
110117: PUSH
110118: EMPTY
110119: LIST
110120: LIST
110121: PUSH
110122: LD_INT 21
110124: PUSH
110125: LD_INT 2
110127: PUSH
110128: EMPTY
110129: LIST
110130: LIST
110131: PUSH
110132: LD_INT 33
110134: PUSH
110135: LD_INT 3
110137: PUSH
110138: EMPTY
110139: LIST
110140: LIST
110141: PUSH
110142: EMPTY
110143: LIST
110144: LIST
110145: LIST
110146: PPUSH
110147: CALL_OW 69
110151: ST_TO_ADDR
// if not tmp then
110152: LD_VAR 0 1
110156: NOT
110157: IFFALSE 110161
// exit ;
110159: GO 110187
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
110161: LD_VAR 0 1
110165: PUSH
110166: LD_INT 1
110168: PPUSH
110169: LD_VAR 0 1
110173: PPUSH
110174: CALL_OW 12
110178: ARRAY
110179: PPUSH
110180: LD_INT 1
110182: PPUSH
110183: CALL_OW 234
// end ;
110187: PPOPN 1
110189: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
110190: LD_EXP 153
110194: PUSH
110195: LD_EXP 195
110199: AND
110200: IFFALSE 110341
110202: GO 110204
110204: DISABLE
110205: LD_INT 0
110207: PPUSH
110208: PPUSH
110209: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
110210: LD_ADDR_VAR 0 3
110214: PUSH
110215: LD_INT 22
110217: PUSH
110218: LD_OWVAR 2
110222: PUSH
110223: EMPTY
110224: LIST
110225: LIST
110226: PUSH
110227: LD_INT 25
110229: PUSH
110230: LD_INT 1
110232: PUSH
110233: EMPTY
110234: LIST
110235: LIST
110236: PUSH
110237: EMPTY
110238: LIST
110239: LIST
110240: PPUSH
110241: CALL_OW 69
110245: ST_TO_ADDR
// if not tmp then
110246: LD_VAR 0 3
110250: NOT
110251: IFFALSE 110255
// exit ;
110253: GO 110341
// un := tmp [ rand ( 1 , tmp ) ] ;
110255: LD_ADDR_VAR 0 2
110259: PUSH
110260: LD_VAR 0 3
110264: PUSH
110265: LD_INT 1
110267: PPUSH
110268: LD_VAR 0 3
110272: PPUSH
110273: CALL_OW 12
110277: ARRAY
110278: ST_TO_ADDR
// if Crawls ( un ) then
110279: LD_VAR 0 2
110283: PPUSH
110284: CALL_OW 318
110288: IFFALSE 110299
// ComWalk ( un ) ;
110290: LD_VAR 0 2
110294: PPUSH
110295: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
110299: LD_VAR 0 2
110303: PPUSH
110304: LD_INT 9
110306: PPUSH
110307: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
110311: LD_INT 28
110313: PPUSH
110314: LD_OWVAR 2
110318: PPUSH
110319: LD_INT 2
110321: PPUSH
110322: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
110326: LD_INT 29
110328: PPUSH
110329: LD_OWVAR 2
110333: PPUSH
110334: LD_INT 2
110336: PPUSH
110337: CALL_OW 322
// end ;
110341: PPOPN 3
110343: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
110344: LD_EXP 153
110348: PUSH
110349: LD_EXP 196
110353: AND
110354: IFFALSE 110465
110356: GO 110358
110358: DISABLE
110359: LD_INT 0
110361: PPUSH
110362: PPUSH
110363: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
110364: LD_ADDR_VAR 0 3
110368: PUSH
110369: LD_INT 22
110371: PUSH
110372: LD_OWVAR 2
110376: PUSH
110377: EMPTY
110378: LIST
110379: LIST
110380: PUSH
110381: LD_INT 25
110383: PUSH
110384: LD_INT 1
110386: PUSH
110387: EMPTY
110388: LIST
110389: LIST
110390: PUSH
110391: EMPTY
110392: LIST
110393: LIST
110394: PPUSH
110395: CALL_OW 69
110399: ST_TO_ADDR
// if not tmp then
110400: LD_VAR 0 3
110404: NOT
110405: IFFALSE 110409
// exit ;
110407: GO 110465
// un := tmp [ rand ( 1 , tmp ) ] ;
110409: LD_ADDR_VAR 0 2
110413: PUSH
110414: LD_VAR 0 3
110418: PUSH
110419: LD_INT 1
110421: PPUSH
110422: LD_VAR 0 3
110426: PPUSH
110427: CALL_OW 12
110431: ARRAY
110432: ST_TO_ADDR
// if Crawls ( un ) then
110433: LD_VAR 0 2
110437: PPUSH
110438: CALL_OW 318
110442: IFFALSE 110453
// ComWalk ( un ) ;
110444: LD_VAR 0 2
110448: PPUSH
110449: CALL_OW 138
// SetClass ( un , class_mortar ) ;
110453: LD_VAR 0 2
110457: PPUSH
110458: LD_INT 8
110460: PPUSH
110461: CALL_OW 336
// end ;
110465: PPOPN 3
110467: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
110468: LD_EXP 153
110472: PUSH
110473: LD_EXP 197
110477: AND
110478: IFFALSE 110622
110480: GO 110482
110482: DISABLE
110483: LD_INT 0
110485: PPUSH
110486: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
110487: LD_ADDR_VAR 0 2
110491: PUSH
110492: LD_INT 22
110494: PUSH
110495: LD_OWVAR 2
110499: PUSH
110500: EMPTY
110501: LIST
110502: LIST
110503: PUSH
110504: LD_INT 21
110506: PUSH
110507: LD_INT 2
110509: PUSH
110510: EMPTY
110511: LIST
110512: LIST
110513: PUSH
110514: LD_INT 2
110516: PUSH
110517: LD_INT 34
110519: PUSH
110520: LD_INT 12
110522: PUSH
110523: EMPTY
110524: LIST
110525: LIST
110526: PUSH
110527: LD_INT 34
110529: PUSH
110530: LD_INT 51
110532: PUSH
110533: EMPTY
110534: LIST
110535: LIST
110536: PUSH
110537: LD_INT 34
110539: PUSH
110540: LD_INT 32
110542: PUSH
110543: EMPTY
110544: LIST
110545: LIST
110546: PUSH
110547: EMPTY
110548: LIST
110549: LIST
110550: LIST
110551: LIST
110552: PUSH
110553: EMPTY
110554: LIST
110555: LIST
110556: LIST
110557: PPUSH
110558: CALL_OW 69
110562: ST_TO_ADDR
// if not tmp then
110563: LD_VAR 0 2
110567: NOT
110568: IFFALSE 110572
// exit ;
110570: GO 110622
// for i in tmp do
110572: LD_ADDR_VAR 0 1
110576: PUSH
110577: LD_VAR 0 2
110581: PUSH
110582: FOR_IN
110583: IFFALSE 110620
// if GetCargo ( i , mat_artifact ) = 0 then
110585: LD_VAR 0 1
110589: PPUSH
110590: LD_INT 4
110592: PPUSH
110593: CALL_OW 289
110597: PUSH
110598: LD_INT 0
110600: EQUAL
110601: IFFALSE 110618
// SetCargo ( i , mat_siberit , 100 ) ;
110603: LD_VAR 0 1
110607: PPUSH
110608: LD_INT 3
110610: PPUSH
110611: LD_INT 100
110613: PPUSH
110614: CALL_OW 290
110618: GO 110582
110620: POP
110621: POP
// end ;
110622: PPOPN 2
110624: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
110625: LD_EXP 153
110629: PUSH
110630: LD_EXP 198
110634: AND
110635: IFFALSE 110788
110637: GO 110639
110639: DISABLE
110640: LD_INT 0
110642: PPUSH
110643: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
110644: LD_ADDR_VAR 0 2
110648: PUSH
110649: LD_INT 22
110651: PUSH
110652: LD_OWVAR 2
110656: PUSH
110657: EMPTY
110658: LIST
110659: LIST
110660: PPUSH
110661: CALL_OW 69
110665: ST_TO_ADDR
// if not tmp then
110666: LD_VAR 0 2
110670: NOT
110671: IFFALSE 110675
// exit ;
110673: GO 110788
// for i := 1 to 2 do
110675: LD_ADDR_VAR 0 1
110679: PUSH
110680: DOUBLE
110681: LD_INT 1
110683: DEC
110684: ST_TO_ADDR
110685: LD_INT 2
110687: PUSH
110688: FOR_TO
110689: IFFALSE 110786
// begin uc_side := your_side ;
110691: LD_ADDR_OWVAR 20
110695: PUSH
110696: LD_OWVAR 2
110700: ST_TO_ADDR
// uc_nation := nation_american ;
110701: LD_ADDR_OWVAR 21
110705: PUSH
110706: LD_INT 1
110708: ST_TO_ADDR
// vc_chassis := us_morphling ;
110709: LD_ADDR_OWVAR 37
110713: PUSH
110714: LD_INT 5
110716: ST_TO_ADDR
// vc_engine := engine_siberite ;
110717: LD_ADDR_OWVAR 39
110721: PUSH
110722: LD_INT 3
110724: ST_TO_ADDR
// vc_control := control_computer ;
110725: LD_ADDR_OWVAR 38
110729: PUSH
110730: LD_INT 3
110732: ST_TO_ADDR
// vc_weapon := us_double_laser ;
110733: LD_ADDR_OWVAR 40
110737: PUSH
110738: LD_INT 10
110740: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
110741: CALL_OW 45
110745: PPUSH
110746: LD_VAR 0 2
110750: PUSH
110751: LD_INT 1
110753: ARRAY
110754: PPUSH
110755: CALL_OW 250
110759: PPUSH
110760: LD_VAR 0 2
110764: PUSH
110765: LD_INT 1
110767: ARRAY
110768: PPUSH
110769: CALL_OW 251
110773: PPUSH
110774: LD_INT 12
110776: PPUSH
110777: LD_INT 1
110779: PPUSH
110780: CALL_OW 50
// end ;
110784: GO 110688
110786: POP
110787: POP
// end ;
110788: PPOPN 2
110790: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
110791: LD_EXP 153
110795: PUSH
110796: LD_EXP 199
110800: AND
110801: IFFALSE 111023
110803: GO 110805
110805: DISABLE
110806: LD_INT 0
110808: PPUSH
110809: PPUSH
110810: PPUSH
110811: PPUSH
110812: PPUSH
110813: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
110814: LD_ADDR_VAR 0 6
110818: PUSH
110819: LD_INT 22
110821: PUSH
110822: LD_OWVAR 2
110826: PUSH
110827: EMPTY
110828: LIST
110829: LIST
110830: PUSH
110831: LD_INT 21
110833: PUSH
110834: LD_INT 1
110836: PUSH
110837: EMPTY
110838: LIST
110839: LIST
110840: PUSH
110841: LD_INT 3
110843: PUSH
110844: LD_INT 23
110846: PUSH
110847: LD_INT 0
110849: PUSH
110850: EMPTY
110851: LIST
110852: LIST
110853: PUSH
110854: EMPTY
110855: LIST
110856: LIST
110857: PUSH
110858: EMPTY
110859: LIST
110860: LIST
110861: LIST
110862: PPUSH
110863: CALL_OW 69
110867: ST_TO_ADDR
// if not tmp then
110868: LD_VAR 0 6
110872: NOT
110873: IFFALSE 110877
// exit ;
110875: GO 111023
// s1 := rand ( 1 , 4 ) ;
110877: LD_ADDR_VAR 0 2
110881: PUSH
110882: LD_INT 1
110884: PPUSH
110885: LD_INT 4
110887: PPUSH
110888: CALL_OW 12
110892: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
110893: LD_ADDR_VAR 0 4
110897: PUSH
110898: LD_VAR 0 6
110902: PUSH
110903: LD_INT 1
110905: ARRAY
110906: PPUSH
110907: LD_VAR 0 2
110911: PPUSH
110912: CALL_OW 259
110916: ST_TO_ADDR
// if s1 = 1 then
110917: LD_VAR 0 2
110921: PUSH
110922: LD_INT 1
110924: EQUAL
110925: IFFALSE 110945
// s2 := rand ( 2 , 4 ) else
110927: LD_ADDR_VAR 0 3
110931: PUSH
110932: LD_INT 2
110934: PPUSH
110935: LD_INT 4
110937: PPUSH
110938: CALL_OW 12
110942: ST_TO_ADDR
110943: GO 110953
// s2 := 1 ;
110945: LD_ADDR_VAR 0 3
110949: PUSH
110950: LD_INT 1
110952: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
110953: LD_ADDR_VAR 0 5
110957: PUSH
110958: LD_VAR 0 6
110962: PUSH
110963: LD_INT 1
110965: ARRAY
110966: PPUSH
110967: LD_VAR 0 3
110971: PPUSH
110972: CALL_OW 259
110976: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
110977: LD_VAR 0 6
110981: PUSH
110982: LD_INT 1
110984: ARRAY
110985: PPUSH
110986: LD_VAR 0 2
110990: PPUSH
110991: LD_VAR 0 5
110995: PPUSH
110996: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
111000: LD_VAR 0 6
111004: PUSH
111005: LD_INT 1
111007: ARRAY
111008: PPUSH
111009: LD_VAR 0 3
111013: PPUSH
111014: LD_VAR 0 4
111018: PPUSH
111019: CALL_OW 237
// end ;
111023: PPOPN 6
111025: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
111026: LD_EXP 153
111030: PUSH
111031: LD_EXP 200
111035: AND
111036: IFFALSE 111115
111038: GO 111040
111040: DISABLE
111041: LD_INT 0
111043: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
111044: LD_ADDR_VAR 0 1
111048: PUSH
111049: LD_INT 22
111051: PUSH
111052: LD_OWVAR 2
111056: PUSH
111057: EMPTY
111058: LIST
111059: LIST
111060: PUSH
111061: LD_INT 30
111063: PUSH
111064: LD_INT 3
111066: PUSH
111067: EMPTY
111068: LIST
111069: LIST
111070: PUSH
111071: EMPTY
111072: LIST
111073: LIST
111074: PPUSH
111075: CALL_OW 69
111079: ST_TO_ADDR
// if not tmp then
111080: LD_VAR 0 1
111084: NOT
111085: IFFALSE 111089
// exit ;
111087: GO 111115
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
111089: LD_VAR 0 1
111093: PUSH
111094: LD_INT 1
111096: PPUSH
111097: LD_VAR 0 1
111101: PPUSH
111102: CALL_OW 12
111106: ARRAY
111107: PPUSH
111108: LD_INT 1
111110: PPUSH
111111: CALL_OW 234
// end ;
111115: PPOPN 1
111117: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
111118: LD_EXP 153
111122: PUSH
111123: LD_EXP 201
111127: AND
111128: IFFALSE 111240
111130: GO 111132
111132: DISABLE
111133: LD_INT 0
111135: PPUSH
111136: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
111137: LD_ADDR_VAR 0 2
111141: PUSH
111142: LD_INT 22
111144: PUSH
111145: LD_OWVAR 2
111149: PUSH
111150: EMPTY
111151: LIST
111152: LIST
111153: PUSH
111154: LD_INT 2
111156: PUSH
111157: LD_INT 30
111159: PUSH
111160: LD_INT 27
111162: PUSH
111163: EMPTY
111164: LIST
111165: LIST
111166: PUSH
111167: LD_INT 30
111169: PUSH
111170: LD_INT 26
111172: PUSH
111173: EMPTY
111174: LIST
111175: LIST
111176: PUSH
111177: LD_INT 30
111179: PUSH
111180: LD_INT 28
111182: PUSH
111183: EMPTY
111184: LIST
111185: LIST
111186: PUSH
111187: EMPTY
111188: LIST
111189: LIST
111190: LIST
111191: LIST
111192: PUSH
111193: EMPTY
111194: LIST
111195: LIST
111196: PPUSH
111197: CALL_OW 69
111201: ST_TO_ADDR
// if not tmp then
111202: LD_VAR 0 2
111206: NOT
111207: IFFALSE 111211
// exit ;
111209: GO 111240
// for i in tmp do
111211: LD_ADDR_VAR 0 1
111215: PUSH
111216: LD_VAR 0 2
111220: PUSH
111221: FOR_IN
111222: IFFALSE 111238
// SetLives ( i , 1 ) ;
111224: LD_VAR 0 1
111228: PPUSH
111229: LD_INT 1
111231: PPUSH
111232: CALL_OW 234
111236: GO 111221
111238: POP
111239: POP
// end ;
111240: PPOPN 2
111242: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
111243: LD_EXP 153
111247: PUSH
111248: LD_EXP 202
111252: AND
111253: IFFALSE 111527
111255: GO 111257
111257: DISABLE
111258: LD_INT 0
111260: PPUSH
111261: PPUSH
111262: PPUSH
// begin i := rand ( 1 , 7 ) ;
111263: LD_ADDR_VAR 0 1
111267: PUSH
111268: LD_INT 1
111270: PPUSH
111271: LD_INT 7
111273: PPUSH
111274: CALL_OW 12
111278: ST_TO_ADDR
// case i of 1 :
111279: LD_VAR 0 1
111283: PUSH
111284: LD_INT 1
111286: DOUBLE
111287: EQUAL
111288: IFTRUE 111292
111290: GO 111302
111292: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
111293: LD_STRING earthquake(getX(game), 0, 32)
111295: PPUSH
111296: CALL_OW 559
111300: GO 111527
111302: LD_INT 2
111304: DOUBLE
111305: EQUAL
111306: IFTRUE 111310
111308: GO 111324
111310: POP
// begin ToLua ( displayStucuk(); ) ;
111311: LD_STRING displayStucuk();
111313: PPUSH
111314: CALL_OW 559
// ResetFog ;
111318: CALL_OW 335
// end ; 3 :
111322: GO 111527
111324: LD_INT 3
111326: DOUBLE
111327: EQUAL
111328: IFTRUE 111332
111330: GO 111436
111332: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
111333: LD_ADDR_VAR 0 2
111337: PUSH
111338: LD_INT 22
111340: PUSH
111341: LD_OWVAR 2
111345: PUSH
111346: EMPTY
111347: LIST
111348: LIST
111349: PUSH
111350: LD_INT 25
111352: PUSH
111353: LD_INT 1
111355: PUSH
111356: EMPTY
111357: LIST
111358: LIST
111359: PUSH
111360: EMPTY
111361: LIST
111362: LIST
111363: PPUSH
111364: CALL_OW 69
111368: ST_TO_ADDR
// if not tmp then
111369: LD_VAR 0 2
111373: NOT
111374: IFFALSE 111378
// exit ;
111376: GO 111527
// un := tmp [ rand ( 1 , tmp ) ] ;
111378: LD_ADDR_VAR 0 3
111382: PUSH
111383: LD_VAR 0 2
111387: PUSH
111388: LD_INT 1
111390: PPUSH
111391: LD_VAR 0 2
111395: PPUSH
111396: CALL_OW 12
111400: ARRAY
111401: ST_TO_ADDR
// if Crawls ( un ) then
111402: LD_VAR 0 3
111406: PPUSH
111407: CALL_OW 318
111411: IFFALSE 111422
// ComWalk ( un ) ;
111413: LD_VAR 0 3
111417: PPUSH
111418: CALL_OW 138
// SetClass ( un , class_mortar ) ;
111422: LD_VAR 0 3
111426: PPUSH
111427: LD_INT 8
111429: PPUSH
111430: CALL_OW 336
// end ; 4 :
111434: GO 111527
111436: LD_INT 4
111438: DOUBLE
111439: EQUAL
111440: IFTRUE 111444
111442: GO 111505
111444: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
111445: LD_ADDR_VAR 0 2
111449: PUSH
111450: LD_INT 22
111452: PUSH
111453: LD_OWVAR 2
111457: PUSH
111458: EMPTY
111459: LIST
111460: LIST
111461: PUSH
111462: LD_INT 30
111464: PUSH
111465: LD_INT 29
111467: PUSH
111468: EMPTY
111469: LIST
111470: LIST
111471: PUSH
111472: EMPTY
111473: LIST
111474: LIST
111475: PPUSH
111476: CALL_OW 69
111480: ST_TO_ADDR
// if not tmp then
111481: LD_VAR 0 2
111485: NOT
111486: IFFALSE 111490
// exit ;
111488: GO 111527
// DestroyUnit ( tmp [ 1 ] ) ;
111490: LD_VAR 0 2
111494: PUSH
111495: LD_INT 1
111497: ARRAY
111498: PPUSH
111499: CALL_OW 65
// end ; 5 .. 7 :
111503: GO 111527
111505: LD_INT 5
111507: DOUBLE
111508: GREATEREQUAL
111509: IFFALSE 111517
111511: LD_INT 7
111513: DOUBLE
111514: LESSEQUAL
111515: IFTRUE 111519
111517: GO 111526
111519: POP
// StreamSibBomb ; end ;
111520: CALL 107807 0 0
111524: GO 111527
111526: POP
// end ;
111527: PPOPN 3
111529: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
111530: LD_EXP 153
111534: PUSH
111535: LD_EXP 203
111539: AND
111540: IFFALSE 111696
111542: GO 111544
111544: DISABLE
111545: LD_INT 0
111547: PPUSH
111548: PPUSH
111549: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
111550: LD_ADDR_VAR 0 2
111554: PUSH
111555: LD_INT 81
111557: PUSH
111558: LD_OWVAR 2
111562: PUSH
111563: EMPTY
111564: LIST
111565: LIST
111566: PUSH
111567: LD_INT 2
111569: PUSH
111570: LD_INT 21
111572: PUSH
111573: LD_INT 1
111575: PUSH
111576: EMPTY
111577: LIST
111578: LIST
111579: PUSH
111580: LD_INT 21
111582: PUSH
111583: LD_INT 2
111585: PUSH
111586: EMPTY
111587: LIST
111588: LIST
111589: PUSH
111590: EMPTY
111591: LIST
111592: LIST
111593: LIST
111594: PUSH
111595: EMPTY
111596: LIST
111597: LIST
111598: PPUSH
111599: CALL_OW 69
111603: ST_TO_ADDR
// if not tmp then
111604: LD_VAR 0 2
111608: NOT
111609: IFFALSE 111613
// exit ;
111611: GO 111696
// p := 0 ;
111613: LD_ADDR_VAR 0 3
111617: PUSH
111618: LD_INT 0
111620: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
111621: LD_INT 35
111623: PPUSH
111624: CALL_OW 67
// p := p + 1 ;
111628: LD_ADDR_VAR 0 3
111632: PUSH
111633: LD_VAR 0 3
111637: PUSH
111638: LD_INT 1
111640: PLUS
111641: ST_TO_ADDR
// for i in tmp do
111642: LD_ADDR_VAR 0 1
111646: PUSH
111647: LD_VAR 0 2
111651: PUSH
111652: FOR_IN
111653: IFFALSE 111684
// if GetLives ( i ) < 1000 then
111655: LD_VAR 0 1
111659: PPUSH
111660: CALL_OW 256
111664: PUSH
111665: LD_INT 1000
111667: LESS
111668: IFFALSE 111682
// SetLives ( i , 1000 ) ;
111670: LD_VAR 0 1
111674: PPUSH
111675: LD_INT 1000
111677: PPUSH
111678: CALL_OW 234
111682: GO 111652
111684: POP
111685: POP
// until p > 20 ;
111686: LD_VAR 0 3
111690: PUSH
111691: LD_INT 20
111693: GREATER
111694: IFFALSE 111621
// end ;
111696: PPOPN 3
111698: END
// every 0 0$1 trigger StreamModeActive and sTime do
111699: LD_EXP 153
111703: PUSH
111704: LD_EXP 204
111708: AND
111709: IFFALSE 111744
111711: GO 111713
111713: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
111714: LD_INT 28
111716: PPUSH
111717: LD_OWVAR 2
111721: PPUSH
111722: LD_INT 2
111724: PPUSH
111725: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
111729: LD_INT 30
111731: PPUSH
111732: LD_OWVAR 2
111736: PPUSH
111737: LD_INT 2
111739: PPUSH
111740: CALL_OW 322
// end ;
111744: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
111745: LD_EXP 153
111749: PUSH
111750: LD_EXP 205
111754: AND
111755: IFFALSE 111876
111757: GO 111759
111759: DISABLE
111760: LD_INT 0
111762: PPUSH
111763: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
111764: LD_ADDR_VAR 0 2
111768: PUSH
111769: LD_INT 22
111771: PUSH
111772: LD_OWVAR 2
111776: PUSH
111777: EMPTY
111778: LIST
111779: LIST
111780: PUSH
111781: LD_INT 21
111783: PUSH
111784: LD_INT 1
111786: PUSH
111787: EMPTY
111788: LIST
111789: LIST
111790: PUSH
111791: LD_INT 3
111793: PUSH
111794: LD_INT 23
111796: PUSH
111797: LD_INT 0
111799: PUSH
111800: EMPTY
111801: LIST
111802: LIST
111803: PUSH
111804: EMPTY
111805: LIST
111806: LIST
111807: PUSH
111808: EMPTY
111809: LIST
111810: LIST
111811: LIST
111812: PPUSH
111813: CALL_OW 69
111817: ST_TO_ADDR
// if not tmp then
111818: LD_VAR 0 2
111822: NOT
111823: IFFALSE 111827
// exit ;
111825: GO 111876
// for i in tmp do
111827: LD_ADDR_VAR 0 1
111831: PUSH
111832: LD_VAR 0 2
111836: PUSH
111837: FOR_IN
111838: IFFALSE 111874
// begin if Crawls ( i ) then
111840: LD_VAR 0 1
111844: PPUSH
111845: CALL_OW 318
111849: IFFALSE 111860
// ComWalk ( i ) ;
111851: LD_VAR 0 1
111855: PPUSH
111856: CALL_OW 138
// SetClass ( i , 2 ) ;
111860: LD_VAR 0 1
111864: PPUSH
111865: LD_INT 2
111867: PPUSH
111868: CALL_OW 336
// end ;
111872: GO 111837
111874: POP
111875: POP
// end ;
111876: PPOPN 2
111878: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
111879: LD_EXP 153
111883: PUSH
111884: LD_EXP 206
111888: AND
111889: IFFALSE 112170
111891: GO 111893
111893: DISABLE
111894: LD_INT 0
111896: PPUSH
111897: PPUSH
111898: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
111899: LD_OWVAR 2
111903: PPUSH
111904: LD_INT 9
111906: PPUSH
111907: LD_INT 1
111909: PPUSH
111910: LD_INT 1
111912: PPUSH
111913: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
111917: LD_INT 9
111919: PPUSH
111920: LD_OWVAR 2
111924: PPUSH
111925: CALL_OW 343
// uc_side := 9 ;
111929: LD_ADDR_OWVAR 20
111933: PUSH
111934: LD_INT 9
111936: ST_TO_ADDR
// uc_nation := 2 ;
111937: LD_ADDR_OWVAR 21
111941: PUSH
111942: LD_INT 2
111944: ST_TO_ADDR
// hc_name := Dark Warrior ;
111945: LD_ADDR_OWVAR 26
111949: PUSH
111950: LD_STRING Dark Warrior
111952: ST_TO_ADDR
// hc_gallery :=  ;
111953: LD_ADDR_OWVAR 33
111957: PUSH
111958: LD_STRING 
111960: ST_TO_ADDR
// hc_noskilllimit := true ;
111961: LD_ADDR_OWVAR 76
111965: PUSH
111966: LD_INT 1
111968: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
111969: LD_ADDR_OWVAR 31
111973: PUSH
111974: LD_INT 30
111976: PUSH
111977: LD_INT 30
111979: PUSH
111980: LD_INT 30
111982: PUSH
111983: LD_INT 30
111985: PUSH
111986: EMPTY
111987: LIST
111988: LIST
111989: LIST
111990: LIST
111991: ST_TO_ADDR
// un := CreateHuman ;
111992: LD_ADDR_VAR 0 3
111996: PUSH
111997: CALL_OW 44
112001: ST_TO_ADDR
// hc_noskilllimit := false ;
112002: LD_ADDR_OWVAR 76
112006: PUSH
112007: LD_INT 0
112009: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
112010: LD_VAR 0 3
112014: PPUSH
112015: LD_INT 1
112017: PPUSH
112018: CALL_OW 51
// p := 0 ;
112022: LD_ADDR_VAR 0 2
112026: PUSH
112027: LD_INT 0
112029: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
112030: LD_INT 35
112032: PPUSH
112033: CALL_OW 67
// p := p + 1 ;
112037: LD_ADDR_VAR 0 2
112041: PUSH
112042: LD_VAR 0 2
112046: PUSH
112047: LD_INT 1
112049: PLUS
112050: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
112051: LD_VAR 0 3
112055: PPUSH
112056: CALL_OW 256
112060: PUSH
112061: LD_INT 1000
112063: LESS
112064: IFFALSE 112078
// SetLives ( un , 1000 ) ;
112066: LD_VAR 0 3
112070: PPUSH
112071: LD_INT 1000
112073: PPUSH
112074: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
112078: LD_VAR 0 3
112082: PPUSH
112083: LD_INT 81
112085: PUSH
112086: LD_OWVAR 2
112090: PUSH
112091: EMPTY
112092: LIST
112093: LIST
112094: PUSH
112095: LD_INT 91
112097: PUSH
112098: LD_VAR 0 3
112102: PUSH
112103: LD_INT 30
112105: PUSH
112106: EMPTY
112107: LIST
112108: LIST
112109: LIST
112110: PUSH
112111: EMPTY
112112: LIST
112113: LIST
112114: PPUSH
112115: CALL_OW 69
112119: PPUSH
112120: LD_VAR 0 3
112124: PPUSH
112125: CALL_OW 74
112129: PPUSH
112130: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
112134: LD_VAR 0 2
112138: PUSH
112139: LD_INT 60
112141: GREATER
112142: PUSH
112143: LD_VAR 0 3
112147: PPUSH
112148: CALL_OW 301
112152: OR
112153: IFFALSE 112030
// if un then
112155: LD_VAR 0 3
112159: IFFALSE 112170
// RemoveUnit ( un ) ;
112161: LD_VAR 0 3
112165: PPUSH
112166: CALL_OW 64
// end ; end_of_file
112170: PPOPN 3
112172: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
112173: LD_INT 0
112175: PPUSH
112176: PPUSH
112177: PPUSH
112178: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
112179: LD_VAR 0 1
112183: PPUSH
112184: CALL_OW 264
112188: PUSH
112189: LD_EXP 99
112193: EQUAL
112194: IFFALSE 112266
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
112196: LD_INT 68
112198: PPUSH
112199: LD_VAR 0 1
112203: PPUSH
112204: CALL_OW 255
112208: PPUSH
112209: CALL_OW 321
112213: PUSH
112214: LD_INT 2
112216: EQUAL
112217: IFFALSE 112229
// eff := 70 else
112219: LD_ADDR_VAR 0 4
112223: PUSH
112224: LD_INT 70
112226: ST_TO_ADDR
112227: GO 112237
// eff := 30 ;
112229: LD_ADDR_VAR 0 4
112233: PUSH
112234: LD_INT 30
112236: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
112237: LD_VAR 0 1
112241: PPUSH
112242: CALL_OW 250
112246: PPUSH
112247: LD_VAR 0 1
112251: PPUSH
112252: CALL_OW 251
112256: PPUSH
112257: LD_VAR 0 4
112261: PPUSH
112262: CALL_OW 495
// end ; end ;
112266: LD_VAR 0 2
112270: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
112271: LD_INT 0
112273: PPUSH
// end ;
112274: LD_VAR 0 4
112278: RET
// export function SOS_Command ( cmd ) ; begin
112279: LD_INT 0
112281: PPUSH
// end ;
112282: LD_VAR 0 2
112286: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
112287: LD_VAR 0 1
112291: PUSH
112292: LD_INT 255
112294: EQUAL
112295: PUSH
112296: LD_VAR 0 2
112300: PPUSH
112301: CALL_OW 264
112305: PUSH
112306: LD_INT 14
112308: PUSH
112309: LD_INT 53
112311: PUSH
112312: EMPTY
112313: LIST
112314: LIST
112315: IN
112316: AND
112317: PUSH
112318: LD_VAR 0 4
112322: PPUSH
112323: LD_VAR 0 5
112327: PPUSH
112328: CALL_OW 488
112332: AND
112333: IFFALSE 112357
// CutTreeXYR ( unit , x , y , 12 ) ;
112335: LD_VAR 0 2
112339: PPUSH
112340: LD_VAR 0 4
112344: PPUSH
112345: LD_VAR 0 5
112349: PPUSH
112350: LD_INT 12
112352: PPUSH
112353: CALL 112360 0 4
// end ;
112357: PPOPN 5
112359: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
112360: LD_INT 0
112362: PPUSH
112363: PPUSH
112364: PPUSH
112365: PPUSH
112366: PPUSH
112367: PPUSH
112368: PPUSH
112369: PPUSH
112370: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
112371: LD_VAR 0 1
112375: NOT
112376: PUSH
112377: LD_VAR 0 2
112381: PPUSH
112382: LD_VAR 0 3
112386: PPUSH
112387: CALL_OW 488
112391: NOT
112392: OR
112393: PUSH
112394: LD_VAR 0 4
112398: NOT
112399: OR
112400: IFFALSE 112404
// exit ;
112402: GO 112744
// list := [ ] ;
112404: LD_ADDR_VAR 0 13
112408: PUSH
112409: EMPTY
112410: ST_TO_ADDR
// if x - r < 0 then
112411: LD_VAR 0 2
112415: PUSH
112416: LD_VAR 0 4
112420: MINUS
112421: PUSH
112422: LD_INT 0
112424: LESS
112425: IFFALSE 112437
// min_x := 0 else
112427: LD_ADDR_VAR 0 7
112431: PUSH
112432: LD_INT 0
112434: ST_TO_ADDR
112435: GO 112453
// min_x := x - r ;
112437: LD_ADDR_VAR 0 7
112441: PUSH
112442: LD_VAR 0 2
112446: PUSH
112447: LD_VAR 0 4
112451: MINUS
112452: ST_TO_ADDR
// if y - r < 0 then
112453: LD_VAR 0 3
112457: PUSH
112458: LD_VAR 0 4
112462: MINUS
112463: PUSH
112464: LD_INT 0
112466: LESS
112467: IFFALSE 112479
// min_y := 0 else
112469: LD_ADDR_VAR 0 8
112473: PUSH
112474: LD_INT 0
112476: ST_TO_ADDR
112477: GO 112495
// min_y := y - r ;
112479: LD_ADDR_VAR 0 8
112483: PUSH
112484: LD_VAR 0 3
112488: PUSH
112489: LD_VAR 0 4
112493: MINUS
112494: ST_TO_ADDR
// max_x := x + r ;
112495: LD_ADDR_VAR 0 9
112499: PUSH
112500: LD_VAR 0 2
112504: PUSH
112505: LD_VAR 0 4
112509: PLUS
112510: ST_TO_ADDR
// max_y := y + r ;
112511: LD_ADDR_VAR 0 10
112515: PUSH
112516: LD_VAR 0 3
112520: PUSH
112521: LD_VAR 0 4
112525: PLUS
112526: ST_TO_ADDR
// for _x = min_x to max_x do
112527: LD_ADDR_VAR 0 11
112531: PUSH
112532: DOUBLE
112533: LD_VAR 0 7
112537: DEC
112538: ST_TO_ADDR
112539: LD_VAR 0 9
112543: PUSH
112544: FOR_TO
112545: IFFALSE 112662
// for _y = min_y to max_y do
112547: LD_ADDR_VAR 0 12
112551: PUSH
112552: DOUBLE
112553: LD_VAR 0 8
112557: DEC
112558: ST_TO_ADDR
112559: LD_VAR 0 10
112563: PUSH
112564: FOR_TO
112565: IFFALSE 112658
// begin if not ValidHex ( _x , _y ) then
112567: LD_VAR 0 11
112571: PPUSH
112572: LD_VAR 0 12
112576: PPUSH
112577: CALL_OW 488
112581: NOT
112582: IFFALSE 112586
// continue ;
112584: GO 112564
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
112586: LD_VAR 0 11
112590: PPUSH
112591: LD_VAR 0 12
112595: PPUSH
112596: CALL_OW 351
112600: PUSH
112601: LD_VAR 0 11
112605: PPUSH
112606: LD_VAR 0 12
112610: PPUSH
112611: CALL_OW 554
112615: AND
112616: IFFALSE 112656
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
112618: LD_ADDR_VAR 0 13
112622: PUSH
112623: LD_VAR 0 13
112627: PPUSH
112628: LD_VAR 0 13
112632: PUSH
112633: LD_INT 1
112635: PLUS
112636: PPUSH
112637: LD_VAR 0 11
112641: PUSH
112642: LD_VAR 0 12
112646: PUSH
112647: EMPTY
112648: LIST
112649: LIST
112650: PPUSH
112651: CALL_OW 2
112655: ST_TO_ADDR
// end ;
112656: GO 112564
112658: POP
112659: POP
112660: GO 112544
112662: POP
112663: POP
// if not list then
112664: LD_VAR 0 13
112668: NOT
112669: IFFALSE 112673
// exit ;
112671: GO 112744
// for i in list do
112673: LD_ADDR_VAR 0 6
112677: PUSH
112678: LD_VAR 0 13
112682: PUSH
112683: FOR_IN
112684: IFFALSE 112742
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
112686: LD_VAR 0 1
112690: PPUSH
112691: LD_STRING M
112693: PUSH
112694: LD_VAR 0 6
112698: PUSH
112699: LD_INT 1
112701: ARRAY
112702: PUSH
112703: LD_VAR 0 6
112707: PUSH
112708: LD_INT 2
112710: ARRAY
112711: PUSH
112712: LD_INT 0
112714: PUSH
112715: LD_INT 0
112717: PUSH
112718: LD_INT 0
112720: PUSH
112721: LD_INT 0
112723: PUSH
112724: EMPTY
112725: LIST
112726: LIST
112727: LIST
112728: LIST
112729: LIST
112730: LIST
112731: LIST
112732: PUSH
112733: EMPTY
112734: LIST
112735: PPUSH
112736: CALL_OW 447
112740: GO 112683
112742: POP
112743: POP
// end ; end_of_file
112744: LD_VAR 0 5
112748: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
112749: LD_INT 0
112751: PPUSH
112752: PPUSH
112753: PPUSH
112754: PPUSH
112755: PPUSH
112756: PPUSH
112757: PPUSH
112758: PPUSH
112759: PPUSH
112760: PPUSH
112761: PPUSH
112762: PPUSH
112763: PPUSH
112764: PPUSH
112765: PPUSH
112766: PPUSH
112767: PPUSH
112768: PPUSH
112769: PPUSH
112770: PPUSH
112771: PPUSH
112772: PPUSH
112773: PPUSH
112774: PPUSH
112775: PPUSH
112776: PPUSH
112777: PPUSH
112778: PPUSH
112779: PPUSH
112780: PPUSH
112781: PPUSH
112782: PPUSH
112783: PPUSH
112784: PPUSH
// if not list then
112785: LD_VAR 0 1
112789: NOT
112790: IFFALSE 112794
// exit ;
112792: GO 117453
// base := list [ 1 ] ;
112794: LD_ADDR_VAR 0 3
112798: PUSH
112799: LD_VAR 0 1
112803: PUSH
112804: LD_INT 1
112806: ARRAY
112807: ST_TO_ADDR
// group := list [ 2 ] ;
112808: LD_ADDR_VAR 0 4
112812: PUSH
112813: LD_VAR 0 1
112817: PUSH
112818: LD_INT 2
112820: ARRAY
112821: ST_TO_ADDR
// path := list [ 3 ] ;
112822: LD_ADDR_VAR 0 5
112826: PUSH
112827: LD_VAR 0 1
112831: PUSH
112832: LD_INT 3
112834: ARRAY
112835: ST_TO_ADDR
// flags := list [ 4 ] ;
112836: LD_ADDR_VAR 0 6
112840: PUSH
112841: LD_VAR 0 1
112845: PUSH
112846: LD_INT 4
112848: ARRAY
112849: ST_TO_ADDR
// mined := [ ] ;
112850: LD_ADDR_VAR 0 27
112854: PUSH
112855: EMPTY
112856: ST_TO_ADDR
// bombed := [ ] ;
112857: LD_ADDR_VAR 0 28
112861: PUSH
112862: EMPTY
112863: ST_TO_ADDR
// healers := [ ] ;
112864: LD_ADDR_VAR 0 31
112868: PUSH
112869: EMPTY
112870: ST_TO_ADDR
// to_heal := [ ] ;
112871: LD_ADDR_VAR 0 30
112875: PUSH
112876: EMPTY
112877: ST_TO_ADDR
// repairs := [ ] ;
112878: LD_ADDR_VAR 0 33
112882: PUSH
112883: EMPTY
112884: ST_TO_ADDR
// to_repair := [ ] ;
112885: LD_ADDR_VAR 0 32
112889: PUSH
112890: EMPTY
112891: ST_TO_ADDR
// if not group or not path then
112892: LD_VAR 0 4
112896: NOT
112897: PUSH
112898: LD_VAR 0 5
112902: NOT
112903: OR
112904: IFFALSE 112908
// exit ;
112906: GO 117453
// side := GetSide ( group [ 1 ] ) ;
112908: LD_ADDR_VAR 0 35
112912: PUSH
112913: LD_VAR 0 4
112917: PUSH
112918: LD_INT 1
112920: ARRAY
112921: PPUSH
112922: CALL_OW 255
112926: ST_TO_ADDR
// if flags then
112927: LD_VAR 0 6
112931: IFFALSE 113075
// begin f_ignore_area := flags [ 1 ] ;
112933: LD_ADDR_VAR 0 17
112937: PUSH
112938: LD_VAR 0 6
112942: PUSH
112943: LD_INT 1
112945: ARRAY
112946: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
112947: LD_ADDR_VAR 0 18
112951: PUSH
112952: LD_VAR 0 6
112956: PUSH
112957: LD_INT 2
112959: ARRAY
112960: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
112961: LD_ADDR_VAR 0 19
112965: PUSH
112966: LD_VAR 0 6
112970: PUSH
112971: LD_INT 3
112973: ARRAY
112974: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
112975: LD_ADDR_VAR 0 20
112979: PUSH
112980: LD_VAR 0 6
112984: PUSH
112985: LD_INT 4
112987: ARRAY
112988: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
112989: LD_ADDR_VAR 0 21
112993: PUSH
112994: LD_VAR 0 6
112998: PUSH
112999: LD_INT 5
113001: ARRAY
113002: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
113003: LD_ADDR_VAR 0 22
113007: PUSH
113008: LD_VAR 0 6
113012: PUSH
113013: LD_INT 6
113015: ARRAY
113016: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
113017: LD_ADDR_VAR 0 23
113021: PUSH
113022: LD_VAR 0 6
113026: PUSH
113027: LD_INT 7
113029: ARRAY
113030: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
113031: LD_ADDR_VAR 0 24
113035: PUSH
113036: LD_VAR 0 6
113040: PUSH
113041: LD_INT 8
113043: ARRAY
113044: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
113045: LD_ADDR_VAR 0 25
113049: PUSH
113050: LD_VAR 0 6
113054: PUSH
113055: LD_INT 9
113057: ARRAY
113058: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
113059: LD_ADDR_VAR 0 26
113063: PUSH
113064: LD_VAR 0 6
113068: PUSH
113069: LD_INT 10
113071: ARRAY
113072: ST_TO_ADDR
// end else
113073: GO 113155
// begin f_ignore_area := false ;
113075: LD_ADDR_VAR 0 17
113079: PUSH
113080: LD_INT 0
113082: ST_TO_ADDR
// f_capture := false ;
113083: LD_ADDR_VAR 0 18
113087: PUSH
113088: LD_INT 0
113090: ST_TO_ADDR
// f_ignore_civ := false ;
113091: LD_ADDR_VAR 0 19
113095: PUSH
113096: LD_INT 0
113098: ST_TO_ADDR
// f_murder := false ;
113099: LD_ADDR_VAR 0 20
113103: PUSH
113104: LD_INT 0
113106: ST_TO_ADDR
// f_mines := false ;
113107: LD_ADDR_VAR 0 21
113111: PUSH
113112: LD_INT 0
113114: ST_TO_ADDR
// f_repair := false ;
113115: LD_ADDR_VAR 0 22
113119: PUSH
113120: LD_INT 0
113122: ST_TO_ADDR
// f_heal := false ;
113123: LD_ADDR_VAR 0 23
113127: PUSH
113128: LD_INT 0
113130: ST_TO_ADDR
// f_spacetime := false ;
113131: LD_ADDR_VAR 0 24
113135: PUSH
113136: LD_INT 0
113138: ST_TO_ADDR
// f_attack_depot := false ;
113139: LD_ADDR_VAR 0 25
113143: PUSH
113144: LD_INT 0
113146: ST_TO_ADDR
// f_crawl := false ;
113147: LD_ADDR_VAR 0 26
113151: PUSH
113152: LD_INT 0
113154: ST_TO_ADDR
// end ; if f_heal then
113155: LD_VAR 0 23
113159: IFFALSE 113186
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
113161: LD_ADDR_VAR 0 31
113165: PUSH
113166: LD_VAR 0 4
113170: PPUSH
113171: LD_INT 25
113173: PUSH
113174: LD_INT 4
113176: PUSH
113177: EMPTY
113178: LIST
113179: LIST
113180: PPUSH
113181: CALL_OW 72
113185: ST_TO_ADDR
// if f_repair then
113186: LD_VAR 0 22
113190: IFFALSE 113217
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
113192: LD_ADDR_VAR 0 33
113196: PUSH
113197: LD_VAR 0 4
113201: PPUSH
113202: LD_INT 25
113204: PUSH
113205: LD_INT 3
113207: PUSH
113208: EMPTY
113209: LIST
113210: LIST
113211: PPUSH
113212: CALL_OW 72
113216: ST_TO_ADDR
// units_path := [ ] ;
113217: LD_ADDR_VAR 0 16
113221: PUSH
113222: EMPTY
113223: ST_TO_ADDR
// for i = 1 to group do
113224: LD_ADDR_VAR 0 7
113228: PUSH
113229: DOUBLE
113230: LD_INT 1
113232: DEC
113233: ST_TO_ADDR
113234: LD_VAR 0 4
113238: PUSH
113239: FOR_TO
113240: IFFALSE 113269
// units_path := Replace ( units_path , i , path ) ;
113242: LD_ADDR_VAR 0 16
113246: PUSH
113247: LD_VAR 0 16
113251: PPUSH
113252: LD_VAR 0 7
113256: PPUSH
113257: LD_VAR 0 5
113261: PPUSH
113262: CALL_OW 1
113266: ST_TO_ADDR
113267: GO 113239
113269: POP
113270: POP
// repeat for i = group downto 1 do
113271: LD_ADDR_VAR 0 7
113275: PUSH
113276: DOUBLE
113277: LD_VAR 0 4
113281: INC
113282: ST_TO_ADDR
113283: LD_INT 1
113285: PUSH
113286: FOR_DOWNTO
113287: IFFALSE 117409
// begin wait ( 5 ) ;
113289: LD_INT 5
113291: PPUSH
113292: CALL_OW 67
// tmp := [ ] ;
113296: LD_ADDR_VAR 0 14
113300: PUSH
113301: EMPTY
113302: ST_TO_ADDR
// attacking := false ;
113303: LD_ADDR_VAR 0 29
113307: PUSH
113308: LD_INT 0
113310: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
113311: LD_VAR 0 4
113315: PUSH
113316: LD_VAR 0 7
113320: ARRAY
113321: PPUSH
113322: CALL_OW 301
113326: PUSH
113327: LD_VAR 0 4
113331: PUSH
113332: LD_VAR 0 7
113336: ARRAY
113337: NOT
113338: OR
113339: IFFALSE 113448
// begin if GetType ( group [ i ] ) = unit_human then
113341: LD_VAR 0 4
113345: PUSH
113346: LD_VAR 0 7
113350: ARRAY
113351: PPUSH
113352: CALL_OW 247
113356: PUSH
113357: LD_INT 1
113359: EQUAL
113360: IFFALSE 113406
// begin to_heal := to_heal diff group [ i ] ;
113362: LD_ADDR_VAR 0 30
113366: PUSH
113367: LD_VAR 0 30
113371: PUSH
113372: LD_VAR 0 4
113376: PUSH
113377: LD_VAR 0 7
113381: ARRAY
113382: DIFF
113383: ST_TO_ADDR
// healers := healers diff group [ i ] ;
113384: LD_ADDR_VAR 0 31
113388: PUSH
113389: LD_VAR 0 31
113393: PUSH
113394: LD_VAR 0 4
113398: PUSH
113399: LD_VAR 0 7
113403: ARRAY
113404: DIFF
113405: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
113406: LD_ADDR_VAR 0 4
113410: PUSH
113411: LD_VAR 0 4
113415: PPUSH
113416: LD_VAR 0 7
113420: PPUSH
113421: CALL_OW 3
113425: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
113426: LD_ADDR_VAR 0 16
113430: PUSH
113431: LD_VAR 0 16
113435: PPUSH
113436: LD_VAR 0 7
113440: PPUSH
113441: CALL_OW 3
113445: ST_TO_ADDR
// continue ;
113446: GO 113286
// end ; if f_repair then
113448: LD_VAR 0 22
113452: IFFALSE 113941
// begin if GetType ( group [ i ] ) = unit_vehicle then
113454: LD_VAR 0 4
113458: PUSH
113459: LD_VAR 0 7
113463: ARRAY
113464: PPUSH
113465: CALL_OW 247
113469: PUSH
113470: LD_INT 2
113472: EQUAL
113473: IFFALSE 113663
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
113475: LD_VAR 0 4
113479: PUSH
113480: LD_VAR 0 7
113484: ARRAY
113485: PPUSH
113486: CALL_OW 256
113490: PUSH
113491: LD_INT 700
113493: LESS
113494: PUSH
113495: LD_VAR 0 4
113499: PUSH
113500: LD_VAR 0 7
113504: ARRAY
113505: PUSH
113506: LD_VAR 0 32
113510: IN
113511: NOT
113512: AND
113513: IFFALSE 113537
// to_repair := to_repair union group [ i ] ;
113515: LD_ADDR_VAR 0 32
113519: PUSH
113520: LD_VAR 0 32
113524: PUSH
113525: LD_VAR 0 4
113529: PUSH
113530: LD_VAR 0 7
113534: ARRAY
113535: UNION
113536: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
113537: LD_VAR 0 4
113541: PUSH
113542: LD_VAR 0 7
113546: ARRAY
113547: PPUSH
113548: CALL_OW 256
113552: PUSH
113553: LD_INT 1000
113555: EQUAL
113556: PUSH
113557: LD_VAR 0 4
113561: PUSH
113562: LD_VAR 0 7
113566: ARRAY
113567: PUSH
113568: LD_VAR 0 32
113572: IN
113573: AND
113574: IFFALSE 113598
// to_repair := to_repair diff group [ i ] ;
113576: LD_ADDR_VAR 0 32
113580: PUSH
113581: LD_VAR 0 32
113585: PUSH
113586: LD_VAR 0 4
113590: PUSH
113591: LD_VAR 0 7
113595: ARRAY
113596: DIFF
113597: ST_TO_ADDR
// if group [ i ] in to_repair then
113598: LD_VAR 0 4
113602: PUSH
113603: LD_VAR 0 7
113607: ARRAY
113608: PUSH
113609: LD_VAR 0 32
113613: IN
113614: IFFALSE 113661
// begin if not IsInArea ( group [ i ] , f_repair ) then
113616: LD_VAR 0 4
113620: PUSH
113621: LD_VAR 0 7
113625: ARRAY
113626: PPUSH
113627: LD_VAR 0 22
113631: PPUSH
113632: CALL_OW 308
113636: NOT
113637: IFFALSE 113659
// ComMoveToArea ( group [ i ] , f_repair ) ;
113639: LD_VAR 0 4
113643: PUSH
113644: LD_VAR 0 7
113648: ARRAY
113649: PPUSH
113650: LD_VAR 0 22
113654: PPUSH
113655: CALL_OW 113
// continue ;
113659: GO 113286
// end ; end else
113661: GO 113941
// if group [ i ] in repairs then
113663: LD_VAR 0 4
113667: PUSH
113668: LD_VAR 0 7
113672: ARRAY
113673: PUSH
113674: LD_VAR 0 33
113678: IN
113679: IFFALSE 113941
// begin if IsInUnit ( group [ i ] ) then
113681: LD_VAR 0 4
113685: PUSH
113686: LD_VAR 0 7
113690: ARRAY
113691: PPUSH
113692: CALL_OW 310
113696: IFFALSE 113764
// begin z := IsInUnit ( group [ i ] ) ;
113698: LD_ADDR_VAR 0 13
113702: PUSH
113703: LD_VAR 0 4
113707: PUSH
113708: LD_VAR 0 7
113712: ARRAY
113713: PPUSH
113714: CALL_OW 310
113718: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
113719: LD_VAR 0 13
113723: PUSH
113724: LD_VAR 0 32
113728: IN
113729: PUSH
113730: LD_VAR 0 13
113734: PPUSH
113735: LD_VAR 0 22
113739: PPUSH
113740: CALL_OW 308
113744: AND
113745: IFFALSE 113762
// ComExitVehicle ( group [ i ] ) ;
113747: LD_VAR 0 4
113751: PUSH
113752: LD_VAR 0 7
113756: ARRAY
113757: PPUSH
113758: CALL_OW 121
// end else
113762: GO 113941
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
113764: LD_ADDR_VAR 0 13
113768: PUSH
113769: LD_VAR 0 4
113773: PPUSH
113774: LD_INT 95
113776: PUSH
113777: LD_VAR 0 22
113781: PUSH
113782: EMPTY
113783: LIST
113784: LIST
113785: PUSH
113786: LD_INT 58
113788: PUSH
113789: EMPTY
113790: LIST
113791: PUSH
113792: EMPTY
113793: LIST
113794: LIST
113795: PPUSH
113796: CALL_OW 72
113800: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
113801: LD_VAR 0 4
113805: PUSH
113806: LD_VAR 0 7
113810: ARRAY
113811: PPUSH
113812: CALL_OW 314
113816: NOT
113817: IFFALSE 113939
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
113819: LD_ADDR_VAR 0 10
113823: PUSH
113824: LD_VAR 0 13
113828: PPUSH
113829: LD_VAR 0 4
113833: PUSH
113834: LD_VAR 0 7
113838: ARRAY
113839: PPUSH
113840: CALL_OW 74
113844: ST_TO_ADDR
// if not x then
113845: LD_VAR 0 10
113849: NOT
113850: IFFALSE 113854
// continue ;
113852: GO 113286
// if GetLives ( x ) < 1000 then
113854: LD_VAR 0 10
113858: PPUSH
113859: CALL_OW 256
113863: PUSH
113864: LD_INT 1000
113866: LESS
113867: IFFALSE 113891
// ComRepairVehicle ( group [ i ] , x ) else
113869: LD_VAR 0 4
113873: PUSH
113874: LD_VAR 0 7
113878: ARRAY
113879: PPUSH
113880: LD_VAR 0 10
113884: PPUSH
113885: CALL_OW 129
113889: GO 113939
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
113891: LD_VAR 0 23
113895: PUSH
113896: LD_VAR 0 4
113900: PUSH
113901: LD_VAR 0 7
113905: ARRAY
113906: PPUSH
113907: CALL_OW 256
113911: PUSH
113912: LD_INT 1000
113914: LESS
113915: AND
113916: NOT
113917: IFFALSE 113939
// ComEnterUnit ( group [ i ] , x ) ;
113919: LD_VAR 0 4
113923: PUSH
113924: LD_VAR 0 7
113928: ARRAY
113929: PPUSH
113930: LD_VAR 0 10
113934: PPUSH
113935: CALL_OW 120
// end ; continue ;
113939: GO 113286
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
113941: LD_VAR 0 23
113945: PUSH
113946: LD_VAR 0 4
113950: PUSH
113951: LD_VAR 0 7
113955: ARRAY
113956: PPUSH
113957: CALL_OW 247
113961: PUSH
113962: LD_INT 1
113964: EQUAL
113965: AND
113966: IFFALSE 114444
// begin if group [ i ] in healers then
113968: LD_VAR 0 4
113972: PUSH
113973: LD_VAR 0 7
113977: ARRAY
113978: PUSH
113979: LD_VAR 0 31
113983: IN
113984: IFFALSE 114257
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
113986: LD_VAR 0 4
113990: PUSH
113991: LD_VAR 0 7
113995: ARRAY
113996: PPUSH
113997: LD_VAR 0 23
114001: PPUSH
114002: CALL_OW 308
114006: NOT
114007: PUSH
114008: LD_VAR 0 4
114012: PUSH
114013: LD_VAR 0 7
114017: ARRAY
114018: PPUSH
114019: CALL_OW 314
114023: NOT
114024: AND
114025: IFFALSE 114049
// ComMoveToArea ( group [ i ] , f_heal ) else
114027: LD_VAR 0 4
114031: PUSH
114032: LD_VAR 0 7
114036: ARRAY
114037: PPUSH
114038: LD_VAR 0 23
114042: PPUSH
114043: CALL_OW 113
114047: GO 114255
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
114049: LD_VAR 0 4
114053: PUSH
114054: LD_VAR 0 7
114058: ARRAY
114059: PPUSH
114060: CALL 98298 0 1
114064: PPUSH
114065: CALL_OW 256
114069: PUSH
114070: LD_INT 1000
114072: EQUAL
114073: IFFALSE 114092
// ComStop ( group [ i ] ) else
114075: LD_VAR 0 4
114079: PUSH
114080: LD_VAR 0 7
114084: ARRAY
114085: PPUSH
114086: CALL_OW 141
114090: GO 114255
// if not HasTask ( group [ i ] ) and to_heal then
114092: LD_VAR 0 4
114096: PUSH
114097: LD_VAR 0 7
114101: ARRAY
114102: PPUSH
114103: CALL_OW 314
114107: NOT
114108: PUSH
114109: LD_VAR 0 30
114113: AND
114114: IFFALSE 114255
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
114116: LD_ADDR_VAR 0 13
114120: PUSH
114121: LD_VAR 0 30
114125: PPUSH
114126: LD_INT 3
114128: PUSH
114129: LD_INT 54
114131: PUSH
114132: EMPTY
114133: LIST
114134: PUSH
114135: EMPTY
114136: LIST
114137: LIST
114138: PPUSH
114139: CALL_OW 72
114143: PPUSH
114144: LD_VAR 0 4
114148: PUSH
114149: LD_VAR 0 7
114153: ARRAY
114154: PPUSH
114155: CALL_OW 74
114159: ST_TO_ADDR
// if z then
114160: LD_VAR 0 13
114164: IFFALSE 114255
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
114166: LD_INT 91
114168: PUSH
114169: LD_VAR 0 13
114173: PUSH
114174: LD_INT 10
114176: PUSH
114177: EMPTY
114178: LIST
114179: LIST
114180: LIST
114181: PUSH
114182: LD_INT 81
114184: PUSH
114185: LD_VAR 0 13
114189: PPUSH
114190: CALL_OW 255
114194: PUSH
114195: EMPTY
114196: LIST
114197: LIST
114198: PUSH
114199: EMPTY
114200: LIST
114201: LIST
114202: PPUSH
114203: CALL_OW 69
114207: PUSH
114208: LD_INT 0
114210: EQUAL
114211: IFFALSE 114235
// ComHeal ( group [ i ] , z ) else
114213: LD_VAR 0 4
114217: PUSH
114218: LD_VAR 0 7
114222: ARRAY
114223: PPUSH
114224: LD_VAR 0 13
114228: PPUSH
114229: CALL_OW 128
114233: GO 114255
// ComMoveToArea ( group [ i ] , f_heal ) ;
114235: LD_VAR 0 4
114239: PUSH
114240: LD_VAR 0 7
114244: ARRAY
114245: PPUSH
114246: LD_VAR 0 23
114250: PPUSH
114251: CALL_OW 113
// end ; continue ;
114255: GO 113286
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
114257: LD_VAR 0 4
114261: PUSH
114262: LD_VAR 0 7
114266: ARRAY
114267: PPUSH
114268: CALL_OW 256
114272: PUSH
114273: LD_INT 700
114275: LESS
114276: PUSH
114277: LD_VAR 0 4
114281: PUSH
114282: LD_VAR 0 7
114286: ARRAY
114287: PUSH
114288: LD_VAR 0 30
114292: IN
114293: NOT
114294: AND
114295: IFFALSE 114319
// to_heal := to_heal union group [ i ] ;
114297: LD_ADDR_VAR 0 30
114301: PUSH
114302: LD_VAR 0 30
114306: PUSH
114307: LD_VAR 0 4
114311: PUSH
114312: LD_VAR 0 7
114316: ARRAY
114317: UNION
114318: ST_TO_ADDR
// if group [ i ] in to_heal then
114319: LD_VAR 0 4
114323: PUSH
114324: LD_VAR 0 7
114328: ARRAY
114329: PUSH
114330: LD_VAR 0 30
114334: IN
114335: IFFALSE 114444
// begin if GetLives ( group [ i ] ) = 1000 then
114337: LD_VAR 0 4
114341: PUSH
114342: LD_VAR 0 7
114346: ARRAY
114347: PPUSH
114348: CALL_OW 256
114352: PUSH
114353: LD_INT 1000
114355: EQUAL
114356: IFFALSE 114382
// to_heal := to_heal diff group [ i ] else
114358: LD_ADDR_VAR 0 30
114362: PUSH
114363: LD_VAR 0 30
114367: PUSH
114368: LD_VAR 0 4
114372: PUSH
114373: LD_VAR 0 7
114377: ARRAY
114378: DIFF
114379: ST_TO_ADDR
114380: GO 114444
// begin if not IsInArea ( group [ i ] , to_heal ) then
114382: LD_VAR 0 4
114386: PUSH
114387: LD_VAR 0 7
114391: ARRAY
114392: PPUSH
114393: LD_VAR 0 30
114397: PPUSH
114398: CALL_OW 308
114402: NOT
114403: IFFALSE 114427
// ComMoveToArea ( group [ i ] , f_heal ) else
114405: LD_VAR 0 4
114409: PUSH
114410: LD_VAR 0 7
114414: ARRAY
114415: PPUSH
114416: LD_VAR 0 23
114420: PPUSH
114421: CALL_OW 113
114425: GO 114442
// ComHold ( group [ i ] ) ;
114427: LD_VAR 0 4
114431: PUSH
114432: LD_VAR 0 7
114436: ARRAY
114437: PPUSH
114438: CALL_OW 140
// continue ;
114442: GO 113286
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
114444: LD_VAR 0 4
114448: PUSH
114449: LD_VAR 0 7
114453: ARRAY
114454: PPUSH
114455: LD_INT 10
114457: PPUSH
114458: CALL 96718 0 2
114462: NOT
114463: PUSH
114464: LD_VAR 0 16
114468: PUSH
114469: LD_VAR 0 7
114473: ARRAY
114474: PUSH
114475: EMPTY
114476: EQUAL
114477: NOT
114478: AND
114479: IFFALSE 114745
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
114481: LD_VAR 0 4
114485: PUSH
114486: LD_VAR 0 7
114490: ARRAY
114491: PPUSH
114492: CALL_OW 262
114496: PUSH
114497: LD_INT 1
114499: PUSH
114500: LD_INT 2
114502: PUSH
114503: EMPTY
114504: LIST
114505: LIST
114506: IN
114507: IFFALSE 114548
// if GetFuel ( group [ i ] ) < 10 then
114509: LD_VAR 0 4
114513: PUSH
114514: LD_VAR 0 7
114518: ARRAY
114519: PPUSH
114520: CALL_OW 261
114524: PUSH
114525: LD_INT 10
114527: LESS
114528: IFFALSE 114548
// SetFuel ( group [ i ] , 12 ) ;
114530: LD_VAR 0 4
114534: PUSH
114535: LD_VAR 0 7
114539: ARRAY
114540: PPUSH
114541: LD_INT 12
114543: PPUSH
114544: CALL_OW 240
// if units_path [ i ] then
114548: LD_VAR 0 16
114552: PUSH
114553: LD_VAR 0 7
114557: ARRAY
114558: IFFALSE 114743
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
114560: LD_VAR 0 4
114564: PUSH
114565: LD_VAR 0 7
114569: ARRAY
114570: PPUSH
114571: LD_VAR 0 16
114575: PUSH
114576: LD_VAR 0 7
114580: ARRAY
114581: PUSH
114582: LD_INT 1
114584: ARRAY
114585: PUSH
114586: LD_INT 1
114588: ARRAY
114589: PPUSH
114590: LD_VAR 0 16
114594: PUSH
114595: LD_VAR 0 7
114599: ARRAY
114600: PUSH
114601: LD_INT 1
114603: ARRAY
114604: PUSH
114605: LD_INT 2
114607: ARRAY
114608: PPUSH
114609: CALL_OW 297
114613: PUSH
114614: LD_INT 6
114616: GREATER
114617: IFFALSE 114692
// begin if not HasTask ( group [ i ] ) then
114619: LD_VAR 0 4
114623: PUSH
114624: LD_VAR 0 7
114628: ARRAY
114629: PPUSH
114630: CALL_OW 314
114634: NOT
114635: IFFALSE 114690
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
114637: LD_VAR 0 4
114641: PUSH
114642: LD_VAR 0 7
114646: ARRAY
114647: PPUSH
114648: LD_VAR 0 16
114652: PUSH
114653: LD_VAR 0 7
114657: ARRAY
114658: PUSH
114659: LD_INT 1
114661: ARRAY
114662: PUSH
114663: LD_INT 1
114665: ARRAY
114666: PPUSH
114667: LD_VAR 0 16
114671: PUSH
114672: LD_VAR 0 7
114676: ARRAY
114677: PUSH
114678: LD_INT 1
114680: ARRAY
114681: PUSH
114682: LD_INT 2
114684: ARRAY
114685: PPUSH
114686: CALL_OW 114
// end else
114690: GO 114743
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
114692: LD_ADDR_VAR 0 15
114696: PUSH
114697: LD_VAR 0 16
114701: PUSH
114702: LD_VAR 0 7
114706: ARRAY
114707: PPUSH
114708: LD_INT 1
114710: PPUSH
114711: CALL_OW 3
114715: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
114716: LD_ADDR_VAR 0 16
114720: PUSH
114721: LD_VAR 0 16
114725: PPUSH
114726: LD_VAR 0 7
114730: PPUSH
114731: LD_VAR 0 15
114735: PPUSH
114736: CALL_OW 1
114740: ST_TO_ADDR
// continue ;
114741: GO 113286
// end ; end ; end else
114743: GO 117407
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
114745: LD_ADDR_VAR 0 14
114749: PUSH
114750: LD_INT 81
114752: PUSH
114753: LD_VAR 0 4
114757: PUSH
114758: LD_VAR 0 7
114762: ARRAY
114763: PPUSH
114764: CALL_OW 255
114768: PUSH
114769: EMPTY
114770: LIST
114771: LIST
114772: PPUSH
114773: CALL_OW 69
114777: ST_TO_ADDR
// if not tmp then
114778: LD_VAR 0 14
114782: NOT
114783: IFFALSE 114787
// continue ;
114785: GO 113286
// if f_ignore_area then
114787: LD_VAR 0 17
114791: IFFALSE 114879
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
114793: LD_ADDR_VAR 0 15
114797: PUSH
114798: LD_VAR 0 14
114802: PPUSH
114803: LD_INT 3
114805: PUSH
114806: LD_INT 92
114808: PUSH
114809: LD_VAR 0 17
114813: PUSH
114814: LD_INT 1
114816: ARRAY
114817: PUSH
114818: LD_VAR 0 17
114822: PUSH
114823: LD_INT 2
114825: ARRAY
114826: PUSH
114827: LD_VAR 0 17
114831: PUSH
114832: LD_INT 3
114834: ARRAY
114835: PUSH
114836: EMPTY
114837: LIST
114838: LIST
114839: LIST
114840: LIST
114841: PUSH
114842: EMPTY
114843: LIST
114844: LIST
114845: PPUSH
114846: CALL_OW 72
114850: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
114851: LD_VAR 0 14
114855: PUSH
114856: LD_VAR 0 15
114860: DIFF
114861: IFFALSE 114879
// tmp := tmp diff tmp2 ;
114863: LD_ADDR_VAR 0 14
114867: PUSH
114868: LD_VAR 0 14
114872: PUSH
114873: LD_VAR 0 15
114877: DIFF
114878: ST_TO_ADDR
// end ; if not f_murder then
114879: LD_VAR 0 20
114883: NOT
114884: IFFALSE 114942
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
114886: LD_ADDR_VAR 0 15
114890: PUSH
114891: LD_VAR 0 14
114895: PPUSH
114896: LD_INT 3
114898: PUSH
114899: LD_INT 50
114901: PUSH
114902: EMPTY
114903: LIST
114904: PUSH
114905: EMPTY
114906: LIST
114907: LIST
114908: PPUSH
114909: CALL_OW 72
114913: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
114914: LD_VAR 0 14
114918: PUSH
114919: LD_VAR 0 15
114923: DIFF
114924: IFFALSE 114942
// tmp := tmp diff tmp2 ;
114926: LD_ADDR_VAR 0 14
114930: PUSH
114931: LD_VAR 0 14
114935: PUSH
114936: LD_VAR 0 15
114940: DIFF
114941: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
114942: LD_ADDR_VAR 0 14
114946: PUSH
114947: LD_VAR 0 4
114951: PUSH
114952: LD_VAR 0 7
114956: ARRAY
114957: PPUSH
114958: LD_VAR 0 14
114962: PPUSH
114963: LD_INT 1
114965: PPUSH
114966: LD_INT 1
114968: PPUSH
114969: CALL 70361 0 4
114973: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
114974: LD_VAR 0 4
114978: PUSH
114979: LD_VAR 0 7
114983: ARRAY
114984: PPUSH
114985: CALL_OW 257
114989: PUSH
114990: LD_INT 1
114992: EQUAL
114993: IFFALSE 115441
// begin if WantPlant ( group [ i ] ) then
114995: LD_VAR 0 4
114999: PUSH
115000: LD_VAR 0 7
115004: ARRAY
115005: PPUSH
115006: CALL 69862 0 1
115010: IFFALSE 115014
// continue ;
115012: GO 113286
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
115014: LD_VAR 0 18
115018: PUSH
115019: LD_VAR 0 4
115023: PUSH
115024: LD_VAR 0 7
115028: ARRAY
115029: PPUSH
115030: CALL_OW 310
115034: NOT
115035: AND
115036: PUSH
115037: LD_VAR 0 14
115041: PUSH
115042: LD_INT 1
115044: ARRAY
115045: PUSH
115046: LD_VAR 0 14
115050: PPUSH
115051: LD_INT 21
115053: PUSH
115054: LD_INT 2
115056: PUSH
115057: EMPTY
115058: LIST
115059: LIST
115060: PUSH
115061: LD_INT 58
115063: PUSH
115064: EMPTY
115065: LIST
115066: PUSH
115067: EMPTY
115068: LIST
115069: LIST
115070: PPUSH
115071: CALL_OW 72
115075: IN
115076: AND
115077: IFFALSE 115113
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
115079: LD_VAR 0 4
115083: PUSH
115084: LD_VAR 0 7
115088: ARRAY
115089: PPUSH
115090: LD_VAR 0 14
115094: PUSH
115095: LD_INT 1
115097: ARRAY
115098: PPUSH
115099: CALL_OW 120
// attacking := true ;
115103: LD_ADDR_VAR 0 29
115107: PUSH
115108: LD_INT 1
115110: ST_TO_ADDR
// continue ;
115111: GO 113286
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
115113: LD_VAR 0 26
115117: PUSH
115118: LD_VAR 0 4
115122: PUSH
115123: LD_VAR 0 7
115127: ARRAY
115128: PPUSH
115129: CALL_OW 257
115133: PUSH
115134: LD_INT 1
115136: EQUAL
115137: AND
115138: PUSH
115139: LD_VAR 0 4
115143: PUSH
115144: LD_VAR 0 7
115148: ARRAY
115149: PPUSH
115150: CALL_OW 256
115154: PUSH
115155: LD_INT 800
115157: LESS
115158: AND
115159: PUSH
115160: LD_VAR 0 4
115164: PUSH
115165: LD_VAR 0 7
115169: ARRAY
115170: PPUSH
115171: CALL_OW 318
115175: NOT
115176: AND
115177: IFFALSE 115194
// ComCrawl ( group [ i ] ) ;
115179: LD_VAR 0 4
115183: PUSH
115184: LD_VAR 0 7
115188: ARRAY
115189: PPUSH
115190: CALL_OW 137
// if f_mines then
115194: LD_VAR 0 21
115198: IFFALSE 115441
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
115200: LD_VAR 0 14
115204: PUSH
115205: LD_INT 1
115207: ARRAY
115208: PPUSH
115209: CALL_OW 247
115213: PUSH
115214: LD_INT 3
115216: EQUAL
115217: PUSH
115218: LD_VAR 0 14
115222: PUSH
115223: LD_INT 1
115225: ARRAY
115226: PUSH
115227: LD_VAR 0 27
115231: IN
115232: NOT
115233: AND
115234: IFFALSE 115441
// begin x := GetX ( tmp [ 1 ] ) ;
115236: LD_ADDR_VAR 0 10
115240: PUSH
115241: LD_VAR 0 14
115245: PUSH
115246: LD_INT 1
115248: ARRAY
115249: PPUSH
115250: CALL_OW 250
115254: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
115255: LD_ADDR_VAR 0 11
115259: PUSH
115260: LD_VAR 0 14
115264: PUSH
115265: LD_INT 1
115267: ARRAY
115268: PPUSH
115269: CALL_OW 251
115273: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
115274: LD_ADDR_VAR 0 12
115278: PUSH
115279: LD_VAR 0 4
115283: PUSH
115284: LD_VAR 0 7
115288: ARRAY
115289: PPUSH
115290: CALL 96803 0 1
115294: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
115295: LD_VAR 0 4
115299: PUSH
115300: LD_VAR 0 7
115304: ARRAY
115305: PPUSH
115306: LD_VAR 0 10
115310: PPUSH
115311: LD_VAR 0 11
115315: PPUSH
115316: LD_VAR 0 14
115320: PUSH
115321: LD_INT 1
115323: ARRAY
115324: PPUSH
115325: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
115329: LD_VAR 0 4
115333: PUSH
115334: LD_VAR 0 7
115338: ARRAY
115339: PPUSH
115340: LD_VAR 0 10
115344: PPUSH
115345: LD_VAR 0 12
115349: PPUSH
115350: LD_INT 7
115352: PPUSH
115353: CALL_OW 272
115357: PPUSH
115358: LD_VAR 0 11
115362: PPUSH
115363: LD_VAR 0 12
115367: PPUSH
115368: LD_INT 7
115370: PPUSH
115371: CALL_OW 273
115375: PPUSH
115376: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
115380: LD_VAR 0 4
115384: PUSH
115385: LD_VAR 0 7
115389: ARRAY
115390: PPUSH
115391: LD_INT 71
115393: PPUSH
115394: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
115398: LD_ADDR_VAR 0 27
115402: PUSH
115403: LD_VAR 0 27
115407: PPUSH
115408: LD_VAR 0 27
115412: PUSH
115413: LD_INT 1
115415: PLUS
115416: PPUSH
115417: LD_VAR 0 14
115421: PUSH
115422: LD_INT 1
115424: ARRAY
115425: PPUSH
115426: CALL_OW 1
115430: ST_TO_ADDR
// attacking := true ;
115431: LD_ADDR_VAR 0 29
115435: PUSH
115436: LD_INT 1
115438: ST_TO_ADDR
// continue ;
115439: GO 113286
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
115441: LD_VAR 0 4
115445: PUSH
115446: LD_VAR 0 7
115450: ARRAY
115451: PPUSH
115452: CALL_OW 257
115456: PUSH
115457: LD_INT 17
115459: EQUAL
115460: PUSH
115461: LD_VAR 0 4
115465: PUSH
115466: LD_VAR 0 7
115470: ARRAY
115471: PPUSH
115472: CALL_OW 110
115476: PUSH
115477: LD_INT 71
115479: EQUAL
115480: NOT
115481: AND
115482: IFFALSE 115628
// begin attacking := false ;
115484: LD_ADDR_VAR 0 29
115488: PUSH
115489: LD_INT 0
115491: ST_TO_ADDR
// k := 5 ;
115492: LD_ADDR_VAR 0 9
115496: PUSH
115497: LD_INT 5
115499: ST_TO_ADDR
// if tmp < k then
115500: LD_VAR 0 14
115504: PUSH
115505: LD_VAR 0 9
115509: LESS
115510: IFFALSE 115522
// k := tmp ;
115512: LD_ADDR_VAR 0 9
115516: PUSH
115517: LD_VAR 0 14
115521: ST_TO_ADDR
// for j = 1 to k do
115522: LD_ADDR_VAR 0 8
115526: PUSH
115527: DOUBLE
115528: LD_INT 1
115530: DEC
115531: ST_TO_ADDR
115532: LD_VAR 0 9
115536: PUSH
115537: FOR_TO
115538: IFFALSE 115626
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
115540: LD_VAR 0 14
115544: PUSH
115545: LD_VAR 0 8
115549: ARRAY
115550: PUSH
115551: LD_VAR 0 14
115555: PPUSH
115556: LD_INT 58
115558: PUSH
115559: EMPTY
115560: LIST
115561: PPUSH
115562: CALL_OW 72
115566: IN
115567: NOT
115568: IFFALSE 115624
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115570: LD_VAR 0 4
115574: PUSH
115575: LD_VAR 0 7
115579: ARRAY
115580: PPUSH
115581: LD_VAR 0 14
115585: PUSH
115586: LD_VAR 0 8
115590: ARRAY
115591: PPUSH
115592: CALL_OW 115
// attacking := true ;
115596: LD_ADDR_VAR 0 29
115600: PUSH
115601: LD_INT 1
115603: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
115604: LD_VAR 0 4
115608: PUSH
115609: LD_VAR 0 7
115613: ARRAY
115614: PPUSH
115615: LD_INT 71
115617: PPUSH
115618: CALL_OW 109
// continue ;
115622: GO 115537
// end ; end ;
115624: GO 115537
115626: POP
115627: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
115628: LD_VAR 0 4
115632: PUSH
115633: LD_VAR 0 7
115637: ARRAY
115638: PPUSH
115639: CALL_OW 257
115643: PUSH
115644: LD_INT 8
115646: EQUAL
115647: PUSH
115648: LD_VAR 0 4
115652: PUSH
115653: LD_VAR 0 7
115657: ARRAY
115658: PPUSH
115659: CALL_OW 264
115663: PUSH
115664: LD_INT 28
115666: PUSH
115667: LD_INT 45
115669: PUSH
115670: LD_INT 7
115672: PUSH
115673: LD_INT 47
115675: PUSH
115676: EMPTY
115677: LIST
115678: LIST
115679: LIST
115680: LIST
115681: IN
115682: OR
115683: IFFALSE 115939
// begin attacking := false ;
115685: LD_ADDR_VAR 0 29
115689: PUSH
115690: LD_INT 0
115692: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
115693: LD_VAR 0 14
115697: PUSH
115698: LD_INT 1
115700: ARRAY
115701: PPUSH
115702: CALL_OW 266
115706: PUSH
115707: LD_INT 32
115709: PUSH
115710: LD_INT 31
115712: PUSH
115713: LD_INT 33
115715: PUSH
115716: LD_INT 4
115718: PUSH
115719: LD_INT 5
115721: PUSH
115722: EMPTY
115723: LIST
115724: LIST
115725: LIST
115726: LIST
115727: LIST
115728: IN
115729: IFFALSE 115915
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
115731: LD_ADDR_VAR 0 9
115735: PUSH
115736: LD_VAR 0 14
115740: PUSH
115741: LD_INT 1
115743: ARRAY
115744: PPUSH
115745: CALL_OW 266
115749: PPUSH
115750: LD_VAR 0 14
115754: PUSH
115755: LD_INT 1
115757: ARRAY
115758: PPUSH
115759: CALL_OW 250
115763: PPUSH
115764: LD_VAR 0 14
115768: PUSH
115769: LD_INT 1
115771: ARRAY
115772: PPUSH
115773: CALL_OW 251
115777: PPUSH
115778: LD_VAR 0 14
115782: PUSH
115783: LD_INT 1
115785: ARRAY
115786: PPUSH
115787: CALL_OW 254
115791: PPUSH
115792: LD_VAR 0 14
115796: PUSH
115797: LD_INT 1
115799: ARRAY
115800: PPUSH
115801: CALL_OW 248
115805: PPUSH
115806: LD_INT 0
115808: PPUSH
115809: CALL 78173 0 6
115813: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
115814: LD_ADDR_VAR 0 8
115818: PUSH
115819: LD_VAR 0 4
115823: PUSH
115824: LD_VAR 0 7
115828: ARRAY
115829: PPUSH
115830: LD_VAR 0 9
115834: PPUSH
115835: CALL 96843 0 2
115839: ST_TO_ADDR
// if j then
115840: LD_VAR 0 8
115844: IFFALSE 115913
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
115846: LD_VAR 0 8
115850: PUSH
115851: LD_INT 1
115853: ARRAY
115854: PPUSH
115855: LD_VAR 0 8
115859: PUSH
115860: LD_INT 2
115862: ARRAY
115863: PPUSH
115864: CALL_OW 488
115868: IFFALSE 115913
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
115870: LD_VAR 0 4
115874: PUSH
115875: LD_VAR 0 7
115879: ARRAY
115880: PPUSH
115881: LD_VAR 0 8
115885: PUSH
115886: LD_INT 1
115888: ARRAY
115889: PPUSH
115890: LD_VAR 0 8
115894: PUSH
115895: LD_INT 2
115897: ARRAY
115898: PPUSH
115899: CALL_OW 116
// attacking := true ;
115903: LD_ADDR_VAR 0 29
115907: PUSH
115908: LD_INT 1
115910: ST_TO_ADDR
// continue ;
115911: GO 113286
// end ; end else
115913: GO 115939
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115915: LD_VAR 0 4
115919: PUSH
115920: LD_VAR 0 7
115924: ARRAY
115925: PPUSH
115926: LD_VAR 0 14
115930: PUSH
115931: LD_INT 1
115933: ARRAY
115934: PPUSH
115935: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
115939: LD_VAR 0 4
115943: PUSH
115944: LD_VAR 0 7
115948: ARRAY
115949: PPUSH
115950: CALL_OW 265
115954: PUSH
115955: LD_INT 11
115957: EQUAL
115958: IFFALSE 116236
// begin k := 10 ;
115960: LD_ADDR_VAR 0 9
115964: PUSH
115965: LD_INT 10
115967: ST_TO_ADDR
// x := 0 ;
115968: LD_ADDR_VAR 0 10
115972: PUSH
115973: LD_INT 0
115975: ST_TO_ADDR
// if tmp < k then
115976: LD_VAR 0 14
115980: PUSH
115981: LD_VAR 0 9
115985: LESS
115986: IFFALSE 115998
// k := tmp ;
115988: LD_ADDR_VAR 0 9
115992: PUSH
115993: LD_VAR 0 14
115997: ST_TO_ADDR
// for j = k downto 1 do
115998: LD_ADDR_VAR 0 8
116002: PUSH
116003: DOUBLE
116004: LD_VAR 0 9
116008: INC
116009: ST_TO_ADDR
116010: LD_INT 1
116012: PUSH
116013: FOR_DOWNTO
116014: IFFALSE 116089
// begin if GetType ( tmp [ j ] ) = unit_human then
116016: LD_VAR 0 14
116020: PUSH
116021: LD_VAR 0 8
116025: ARRAY
116026: PPUSH
116027: CALL_OW 247
116031: PUSH
116032: LD_INT 1
116034: EQUAL
116035: IFFALSE 116087
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
116037: LD_VAR 0 4
116041: PUSH
116042: LD_VAR 0 7
116046: ARRAY
116047: PPUSH
116048: LD_VAR 0 14
116052: PUSH
116053: LD_VAR 0 8
116057: ARRAY
116058: PPUSH
116059: CALL 97114 0 2
// x := tmp [ j ] ;
116063: LD_ADDR_VAR 0 10
116067: PUSH
116068: LD_VAR 0 14
116072: PUSH
116073: LD_VAR 0 8
116077: ARRAY
116078: ST_TO_ADDR
// attacking := true ;
116079: LD_ADDR_VAR 0 29
116083: PUSH
116084: LD_INT 1
116086: ST_TO_ADDR
// end ; end ;
116087: GO 116013
116089: POP
116090: POP
// if not x then
116091: LD_VAR 0 10
116095: NOT
116096: IFFALSE 116236
// begin attacking := true ;
116098: LD_ADDR_VAR 0 29
116102: PUSH
116103: LD_INT 1
116105: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
116106: LD_VAR 0 4
116110: PUSH
116111: LD_VAR 0 7
116115: ARRAY
116116: PPUSH
116117: CALL_OW 250
116121: PPUSH
116122: LD_VAR 0 4
116126: PUSH
116127: LD_VAR 0 7
116131: ARRAY
116132: PPUSH
116133: CALL_OW 251
116137: PPUSH
116138: CALL_OW 546
116142: PUSH
116143: LD_INT 2
116145: ARRAY
116146: PUSH
116147: LD_VAR 0 14
116151: PUSH
116152: LD_INT 1
116154: ARRAY
116155: PPUSH
116156: CALL_OW 250
116160: PPUSH
116161: LD_VAR 0 14
116165: PUSH
116166: LD_INT 1
116168: ARRAY
116169: PPUSH
116170: CALL_OW 251
116174: PPUSH
116175: CALL_OW 546
116179: PUSH
116180: LD_INT 2
116182: ARRAY
116183: EQUAL
116184: IFFALSE 116212
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
116186: LD_VAR 0 4
116190: PUSH
116191: LD_VAR 0 7
116195: ARRAY
116196: PPUSH
116197: LD_VAR 0 14
116201: PUSH
116202: LD_INT 1
116204: ARRAY
116205: PPUSH
116206: CALL 97114 0 2
116210: GO 116236
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116212: LD_VAR 0 4
116216: PUSH
116217: LD_VAR 0 7
116221: ARRAY
116222: PPUSH
116223: LD_VAR 0 14
116227: PUSH
116228: LD_INT 1
116230: ARRAY
116231: PPUSH
116232: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
116236: LD_VAR 0 4
116240: PUSH
116241: LD_VAR 0 7
116245: ARRAY
116246: PPUSH
116247: CALL_OW 264
116251: PUSH
116252: LD_INT 29
116254: EQUAL
116255: IFFALSE 116621
// begin if WantsToAttack ( group [ i ] ) in bombed then
116257: LD_VAR 0 4
116261: PUSH
116262: LD_VAR 0 7
116266: ARRAY
116267: PPUSH
116268: CALL_OW 319
116272: PUSH
116273: LD_VAR 0 28
116277: IN
116278: IFFALSE 116282
// continue ;
116280: GO 113286
// k := 8 ;
116282: LD_ADDR_VAR 0 9
116286: PUSH
116287: LD_INT 8
116289: ST_TO_ADDR
// x := 0 ;
116290: LD_ADDR_VAR 0 10
116294: PUSH
116295: LD_INT 0
116297: ST_TO_ADDR
// if tmp < k then
116298: LD_VAR 0 14
116302: PUSH
116303: LD_VAR 0 9
116307: LESS
116308: IFFALSE 116320
// k := tmp ;
116310: LD_ADDR_VAR 0 9
116314: PUSH
116315: LD_VAR 0 14
116319: ST_TO_ADDR
// for j = 1 to k do
116320: LD_ADDR_VAR 0 8
116324: PUSH
116325: DOUBLE
116326: LD_INT 1
116328: DEC
116329: ST_TO_ADDR
116330: LD_VAR 0 9
116334: PUSH
116335: FOR_TO
116336: IFFALSE 116468
// begin if GetType ( tmp [ j ] ) = unit_building then
116338: LD_VAR 0 14
116342: PUSH
116343: LD_VAR 0 8
116347: ARRAY
116348: PPUSH
116349: CALL_OW 247
116353: PUSH
116354: LD_INT 3
116356: EQUAL
116357: IFFALSE 116466
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
116359: LD_VAR 0 14
116363: PUSH
116364: LD_VAR 0 8
116368: ARRAY
116369: PUSH
116370: LD_VAR 0 28
116374: IN
116375: NOT
116376: PUSH
116377: LD_VAR 0 14
116381: PUSH
116382: LD_VAR 0 8
116386: ARRAY
116387: PPUSH
116388: CALL_OW 313
116392: AND
116393: IFFALSE 116466
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116395: LD_VAR 0 4
116399: PUSH
116400: LD_VAR 0 7
116404: ARRAY
116405: PPUSH
116406: LD_VAR 0 14
116410: PUSH
116411: LD_VAR 0 8
116415: ARRAY
116416: PPUSH
116417: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
116421: LD_ADDR_VAR 0 28
116425: PUSH
116426: LD_VAR 0 28
116430: PPUSH
116431: LD_VAR 0 28
116435: PUSH
116436: LD_INT 1
116438: PLUS
116439: PPUSH
116440: LD_VAR 0 14
116444: PUSH
116445: LD_VAR 0 8
116449: ARRAY
116450: PPUSH
116451: CALL_OW 1
116455: ST_TO_ADDR
// attacking := true ;
116456: LD_ADDR_VAR 0 29
116460: PUSH
116461: LD_INT 1
116463: ST_TO_ADDR
// break ;
116464: GO 116468
// end ; end ;
116466: GO 116335
116468: POP
116469: POP
// if not attacking and f_attack_depot then
116470: LD_VAR 0 29
116474: NOT
116475: PUSH
116476: LD_VAR 0 25
116480: AND
116481: IFFALSE 116576
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
116483: LD_ADDR_VAR 0 13
116487: PUSH
116488: LD_VAR 0 14
116492: PPUSH
116493: LD_INT 2
116495: PUSH
116496: LD_INT 30
116498: PUSH
116499: LD_INT 0
116501: PUSH
116502: EMPTY
116503: LIST
116504: LIST
116505: PUSH
116506: LD_INT 30
116508: PUSH
116509: LD_INT 1
116511: PUSH
116512: EMPTY
116513: LIST
116514: LIST
116515: PUSH
116516: EMPTY
116517: LIST
116518: LIST
116519: LIST
116520: PPUSH
116521: CALL_OW 72
116525: ST_TO_ADDR
// if z then
116526: LD_VAR 0 13
116530: IFFALSE 116576
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
116532: LD_VAR 0 4
116536: PUSH
116537: LD_VAR 0 7
116541: ARRAY
116542: PPUSH
116543: LD_VAR 0 13
116547: PPUSH
116548: LD_VAR 0 4
116552: PUSH
116553: LD_VAR 0 7
116557: ARRAY
116558: PPUSH
116559: CALL_OW 74
116563: PPUSH
116564: CALL_OW 115
// attacking := true ;
116568: LD_ADDR_VAR 0 29
116572: PUSH
116573: LD_INT 1
116575: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
116576: LD_VAR 0 4
116580: PUSH
116581: LD_VAR 0 7
116585: ARRAY
116586: PPUSH
116587: CALL_OW 256
116591: PUSH
116592: LD_INT 500
116594: LESS
116595: IFFALSE 116621
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116597: LD_VAR 0 4
116601: PUSH
116602: LD_VAR 0 7
116606: ARRAY
116607: PPUSH
116608: LD_VAR 0 14
116612: PUSH
116613: LD_INT 1
116615: ARRAY
116616: PPUSH
116617: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
116621: LD_VAR 0 4
116625: PUSH
116626: LD_VAR 0 7
116630: ARRAY
116631: PPUSH
116632: CALL_OW 264
116636: PUSH
116637: LD_INT 49
116639: EQUAL
116640: IFFALSE 116761
// begin if not HasTask ( group [ i ] ) then
116642: LD_VAR 0 4
116646: PUSH
116647: LD_VAR 0 7
116651: ARRAY
116652: PPUSH
116653: CALL_OW 314
116657: NOT
116658: IFFALSE 116761
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
116660: LD_ADDR_VAR 0 9
116664: PUSH
116665: LD_INT 81
116667: PUSH
116668: LD_VAR 0 4
116672: PUSH
116673: LD_VAR 0 7
116677: ARRAY
116678: PPUSH
116679: CALL_OW 255
116683: PUSH
116684: EMPTY
116685: LIST
116686: LIST
116687: PPUSH
116688: CALL_OW 69
116692: PPUSH
116693: LD_VAR 0 4
116697: PUSH
116698: LD_VAR 0 7
116702: ARRAY
116703: PPUSH
116704: CALL_OW 74
116708: ST_TO_ADDR
// if k then
116709: LD_VAR 0 9
116713: IFFALSE 116761
// if GetDistUnits ( group [ i ] , k ) > 10 then
116715: LD_VAR 0 4
116719: PUSH
116720: LD_VAR 0 7
116724: ARRAY
116725: PPUSH
116726: LD_VAR 0 9
116730: PPUSH
116731: CALL_OW 296
116735: PUSH
116736: LD_INT 10
116738: GREATER
116739: IFFALSE 116761
// ComMoveUnit ( group [ i ] , k ) ;
116741: LD_VAR 0 4
116745: PUSH
116746: LD_VAR 0 7
116750: ARRAY
116751: PPUSH
116752: LD_VAR 0 9
116756: PPUSH
116757: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
116761: LD_VAR 0 4
116765: PUSH
116766: LD_VAR 0 7
116770: ARRAY
116771: PPUSH
116772: CALL_OW 256
116776: PUSH
116777: LD_INT 250
116779: LESS
116780: PUSH
116781: LD_VAR 0 4
116785: PUSH
116786: LD_VAR 0 7
116790: ARRAY
116791: PUSH
116792: LD_INT 21
116794: PUSH
116795: LD_INT 2
116797: PUSH
116798: EMPTY
116799: LIST
116800: LIST
116801: PUSH
116802: LD_INT 23
116804: PUSH
116805: LD_INT 2
116807: PUSH
116808: EMPTY
116809: LIST
116810: LIST
116811: PUSH
116812: EMPTY
116813: LIST
116814: LIST
116815: PPUSH
116816: CALL_OW 69
116820: IN
116821: AND
116822: IFFALSE 116947
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
116824: LD_ADDR_VAR 0 9
116828: PUSH
116829: LD_OWVAR 3
116833: PUSH
116834: LD_VAR 0 4
116838: PUSH
116839: LD_VAR 0 7
116843: ARRAY
116844: DIFF
116845: PPUSH
116846: LD_VAR 0 4
116850: PUSH
116851: LD_VAR 0 7
116855: ARRAY
116856: PPUSH
116857: CALL_OW 74
116861: ST_TO_ADDR
// if not k then
116862: LD_VAR 0 9
116866: NOT
116867: IFFALSE 116871
// continue ;
116869: GO 113286
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
116871: LD_VAR 0 9
116875: PUSH
116876: LD_INT 81
116878: PUSH
116879: LD_VAR 0 4
116883: PUSH
116884: LD_VAR 0 7
116888: ARRAY
116889: PPUSH
116890: CALL_OW 255
116894: PUSH
116895: EMPTY
116896: LIST
116897: LIST
116898: PPUSH
116899: CALL_OW 69
116903: IN
116904: PUSH
116905: LD_VAR 0 9
116909: PPUSH
116910: LD_VAR 0 4
116914: PUSH
116915: LD_VAR 0 7
116919: ARRAY
116920: PPUSH
116921: CALL_OW 296
116925: PUSH
116926: LD_INT 5
116928: LESS
116929: AND
116930: IFFALSE 116947
// ComAutodestruct ( group [ i ] ) ;
116932: LD_VAR 0 4
116936: PUSH
116937: LD_VAR 0 7
116941: ARRAY
116942: PPUSH
116943: CALL 97012 0 1
// end ; if f_attack_depot then
116947: LD_VAR 0 25
116951: IFFALSE 117063
// begin k := 6 ;
116953: LD_ADDR_VAR 0 9
116957: PUSH
116958: LD_INT 6
116960: ST_TO_ADDR
// if tmp < k then
116961: LD_VAR 0 14
116965: PUSH
116966: LD_VAR 0 9
116970: LESS
116971: IFFALSE 116983
// k := tmp ;
116973: LD_ADDR_VAR 0 9
116977: PUSH
116978: LD_VAR 0 14
116982: ST_TO_ADDR
// for j = 1 to k do
116983: LD_ADDR_VAR 0 8
116987: PUSH
116988: DOUBLE
116989: LD_INT 1
116991: DEC
116992: ST_TO_ADDR
116993: LD_VAR 0 9
116997: PUSH
116998: FOR_TO
116999: IFFALSE 117061
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
117001: LD_VAR 0 8
117005: PPUSH
117006: CALL_OW 266
117010: PUSH
117011: LD_INT 0
117013: PUSH
117014: LD_INT 1
117016: PUSH
117017: EMPTY
117018: LIST
117019: LIST
117020: IN
117021: IFFALSE 117059
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117023: LD_VAR 0 4
117027: PUSH
117028: LD_VAR 0 7
117032: ARRAY
117033: PPUSH
117034: LD_VAR 0 14
117038: PUSH
117039: LD_VAR 0 8
117043: ARRAY
117044: PPUSH
117045: CALL_OW 115
// attacking := true ;
117049: LD_ADDR_VAR 0 29
117053: PUSH
117054: LD_INT 1
117056: ST_TO_ADDR
// break ;
117057: GO 117061
// end ;
117059: GO 116998
117061: POP
117062: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
117063: LD_VAR 0 4
117067: PUSH
117068: LD_VAR 0 7
117072: ARRAY
117073: PPUSH
117074: CALL_OW 302
117078: PUSH
117079: LD_VAR 0 29
117083: NOT
117084: AND
117085: IFFALSE 117407
// begin if GetTag ( group [ i ] ) = 71 then
117087: LD_VAR 0 4
117091: PUSH
117092: LD_VAR 0 7
117096: ARRAY
117097: PPUSH
117098: CALL_OW 110
117102: PUSH
117103: LD_INT 71
117105: EQUAL
117106: IFFALSE 117147
// begin if HasTask ( group [ i ] ) then
117108: LD_VAR 0 4
117112: PUSH
117113: LD_VAR 0 7
117117: ARRAY
117118: PPUSH
117119: CALL_OW 314
117123: IFFALSE 117129
// continue else
117125: GO 113286
117127: GO 117147
// SetTag ( group [ i ] , 0 ) ;
117129: LD_VAR 0 4
117133: PUSH
117134: LD_VAR 0 7
117138: ARRAY
117139: PPUSH
117140: LD_INT 0
117142: PPUSH
117143: CALL_OW 109
// end ; k := 8 ;
117147: LD_ADDR_VAR 0 9
117151: PUSH
117152: LD_INT 8
117154: ST_TO_ADDR
// x := 0 ;
117155: LD_ADDR_VAR 0 10
117159: PUSH
117160: LD_INT 0
117162: ST_TO_ADDR
// if tmp < k then
117163: LD_VAR 0 14
117167: PUSH
117168: LD_VAR 0 9
117172: LESS
117173: IFFALSE 117185
// k := tmp ;
117175: LD_ADDR_VAR 0 9
117179: PUSH
117180: LD_VAR 0 14
117184: ST_TO_ADDR
// for j = 1 to k do
117185: LD_ADDR_VAR 0 8
117189: PUSH
117190: DOUBLE
117191: LD_INT 1
117193: DEC
117194: ST_TO_ADDR
117195: LD_VAR 0 9
117199: PUSH
117200: FOR_TO
117201: IFFALSE 117299
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
117203: LD_VAR 0 14
117207: PUSH
117208: LD_VAR 0 8
117212: ARRAY
117213: PPUSH
117214: CALL_OW 247
117218: PUSH
117219: LD_INT 1
117221: EQUAL
117222: PUSH
117223: LD_VAR 0 14
117227: PUSH
117228: LD_VAR 0 8
117232: ARRAY
117233: PPUSH
117234: CALL_OW 256
117238: PUSH
117239: LD_INT 250
117241: LESS
117242: PUSH
117243: LD_VAR 0 20
117247: AND
117248: PUSH
117249: LD_VAR 0 20
117253: NOT
117254: PUSH
117255: LD_VAR 0 14
117259: PUSH
117260: LD_VAR 0 8
117264: ARRAY
117265: PPUSH
117266: CALL_OW 256
117270: PUSH
117271: LD_INT 250
117273: GREATEREQUAL
117274: AND
117275: OR
117276: AND
117277: IFFALSE 117297
// begin x := tmp [ j ] ;
117279: LD_ADDR_VAR 0 10
117283: PUSH
117284: LD_VAR 0 14
117288: PUSH
117289: LD_VAR 0 8
117293: ARRAY
117294: ST_TO_ADDR
// break ;
117295: GO 117299
// end ;
117297: GO 117200
117299: POP
117300: POP
// if x then
117301: LD_VAR 0 10
117305: IFFALSE 117329
// ComAttackUnit ( group [ i ] , x ) else
117307: LD_VAR 0 4
117311: PUSH
117312: LD_VAR 0 7
117316: ARRAY
117317: PPUSH
117318: LD_VAR 0 10
117322: PPUSH
117323: CALL_OW 115
117327: GO 117353
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117329: LD_VAR 0 4
117333: PUSH
117334: LD_VAR 0 7
117338: ARRAY
117339: PPUSH
117340: LD_VAR 0 14
117344: PUSH
117345: LD_INT 1
117347: ARRAY
117348: PPUSH
117349: CALL_OW 115
// if not HasTask ( group [ i ] ) then
117353: LD_VAR 0 4
117357: PUSH
117358: LD_VAR 0 7
117362: ARRAY
117363: PPUSH
117364: CALL_OW 314
117368: NOT
117369: IFFALSE 117407
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
117371: LD_VAR 0 4
117375: PUSH
117376: LD_VAR 0 7
117380: ARRAY
117381: PPUSH
117382: LD_VAR 0 14
117386: PPUSH
117387: LD_VAR 0 4
117391: PUSH
117392: LD_VAR 0 7
117396: ARRAY
117397: PPUSH
117398: CALL_OW 74
117402: PPUSH
117403: CALL_OW 115
// end ; end ; end ;
117407: GO 113286
117409: POP
117410: POP
// wait ( 0 0$2 ) ;
117411: LD_INT 70
117413: PPUSH
117414: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
117418: LD_VAR 0 4
117422: NOT
117423: PUSH
117424: LD_VAR 0 4
117428: PUSH
117429: EMPTY
117430: EQUAL
117431: OR
117432: PUSH
117433: LD_INT 81
117435: PUSH
117436: LD_VAR 0 35
117440: PUSH
117441: EMPTY
117442: LIST
117443: LIST
117444: PPUSH
117445: CALL_OW 69
117449: NOT
117450: OR
117451: IFFALSE 113271
// end ;
117453: LD_VAR 0 2
117457: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
117458: LD_INT 0
117460: PPUSH
117461: PPUSH
117462: PPUSH
117463: PPUSH
117464: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
117465: LD_VAR 0 1
117469: NOT
117470: PUSH
117471: LD_EXP 110
117475: PUSH
117476: LD_VAR 0 1
117480: ARRAY
117481: NOT
117482: OR
117483: PUSH
117484: LD_VAR 0 2
117488: NOT
117489: OR
117490: PUSH
117491: LD_VAR 0 3
117495: NOT
117496: OR
117497: IFFALSE 117501
// exit ;
117499: GO 118014
// side := mc_sides [ base ] ;
117501: LD_ADDR_VAR 0 6
117505: PUSH
117506: LD_EXP 136
117510: PUSH
117511: LD_VAR 0 1
117515: ARRAY
117516: ST_TO_ADDR
// if not side then
117517: LD_VAR 0 6
117521: NOT
117522: IFFALSE 117526
// exit ;
117524: GO 118014
// for i in solds do
117526: LD_ADDR_VAR 0 7
117530: PUSH
117531: LD_VAR 0 2
117535: PUSH
117536: FOR_IN
117537: IFFALSE 117598
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
117539: LD_VAR 0 7
117543: PPUSH
117544: CALL_OW 310
117548: PPUSH
117549: CALL_OW 266
117553: PUSH
117554: LD_INT 32
117556: PUSH
117557: LD_INT 31
117559: PUSH
117560: EMPTY
117561: LIST
117562: LIST
117563: IN
117564: IFFALSE 117584
// solds := solds diff i else
117566: LD_ADDR_VAR 0 2
117570: PUSH
117571: LD_VAR 0 2
117575: PUSH
117576: LD_VAR 0 7
117580: DIFF
117581: ST_TO_ADDR
117582: GO 117596
// SetTag ( i , 18 ) ;
117584: LD_VAR 0 7
117588: PPUSH
117589: LD_INT 18
117591: PPUSH
117592: CALL_OW 109
117596: GO 117536
117598: POP
117599: POP
// if not solds then
117600: LD_VAR 0 2
117604: NOT
117605: IFFALSE 117609
// exit ;
117607: GO 118014
// repeat wait ( 0 0$1 ) ;
117609: LD_INT 35
117611: PPUSH
117612: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
117616: LD_ADDR_VAR 0 5
117620: PUSH
117621: LD_VAR 0 6
117625: PPUSH
117626: LD_VAR 0 3
117630: PPUSH
117631: CALL 66727 0 2
117635: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117636: LD_EXP 110
117640: PUSH
117641: LD_VAR 0 1
117645: ARRAY
117646: NOT
117647: PUSH
117648: LD_EXP 110
117652: PUSH
117653: LD_VAR 0 1
117657: ARRAY
117658: PUSH
117659: EMPTY
117660: EQUAL
117661: OR
117662: IFFALSE 117699
// begin for i in solds do
117664: LD_ADDR_VAR 0 7
117668: PUSH
117669: LD_VAR 0 2
117673: PUSH
117674: FOR_IN
117675: IFFALSE 117688
// ComStop ( i ) ;
117677: LD_VAR 0 7
117681: PPUSH
117682: CALL_OW 141
117686: GO 117674
117688: POP
117689: POP
// solds := [ ] ;
117690: LD_ADDR_VAR 0 2
117694: PUSH
117695: EMPTY
117696: ST_TO_ADDR
// exit ;
117697: GO 118014
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
117699: LD_VAR 0 5
117703: NOT
117704: PUSH
117705: LD_VAR 0 5
117709: PUSH
117710: LD_INT 3
117712: GREATER
117713: OR
117714: PUSH
117715: LD_EXP 132
117719: PUSH
117720: LD_VAR 0 1
117724: ARRAY
117725: OR
117726: IFFALSE 117767
// begin for i in solds do
117728: LD_ADDR_VAR 0 7
117732: PUSH
117733: LD_VAR 0 2
117737: PUSH
117738: FOR_IN
117739: IFFALSE 117763
// if HasTask ( i ) then
117741: LD_VAR 0 7
117745: PPUSH
117746: CALL_OW 314
117750: IFFALSE 117761
// ComStop ( i ) ;
117752: LD_VAR 0 7
117756: PPUSH
117757: CALL_OW 141
117761: GO 117738
117763: POP
117764: POP
// break ;
117765: GO 118002
// end ; for i in solds do
117767: LD_ADDR_VAR 0 7
117771: PUSH
117772: LD_VAR 0 2
117776: PUSH
117777: FOR_IN
117778: IFFALSE 117994
// begin if IsInUnit ( i ) then
117780: LD_VAR 0 7
117784: PPUSH
117785: CALL_OW 310
117789: IFFALSE 117800
// ComExitBuilding ( i ) ;
117791: LD_VAR 0 7
117795: PPUSH
117796: CALL_OW 122
// if GetLives ( i ) > 333 then
117800: LD_VAR 0 7
117804: PPUSH
117805: CALL_OW 256
117809: PUSH
117810: LD_INT 333
117812: GREATER
117813: IFFALSE 117841
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
117815: LD_VAR 0 7
117819: PPUSH
117820: LD_VAR 0 5
117824: PPUSH
117825: LD_VAR 0 7
117829: PPUSH
117830: CALL_OW 74
117834: PPUSH
117835: CALL_OW 115
117839: GO 117992
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
117841: LD_ADDR_VAR 0 8
117845: PUSH
117846: LD_EXP 110
117850: PUSH
117851: LD_VAR 0 1
117855: ARRAY
117856: PPUSH
117857: LD_INT 2
117859: PUSH
117860: LD_INT 30
117862: PUSH
117863: LD_INT 0
117865: PUSH
117866: EMPTY
117867: LIST
117868: LIST
117869: PUSH
117870: LD_INT 30
117872: PUSH
117873: LD_INT 1
117875: PUSH
117876: EMPTY
117877: LIST
117878: LIST
117879: PUSH
117880: LD_INT 30
117882: PUSH
117883: LD_INT 6
117885: PUSH
117886: EMPTY
117887: LIST
117888: LIST
117889: PUSH
117890: EMPTY
117891: LIST
117892: LIST
117893: LIST
117894: LIST
117895: PPUSH
117896: CALL_OW 72
117900: PPUSH
117901: LD_VAR 0 7
117905: PPUSH
117906: CALL_OW 74
117910: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
117911: LD_VAR 0 7
117915: PPUSH
117916: LD_VAR 0 8
117920: PPUSH
117921: CALL_OW 250
117925: PPUSH
117926: LD_INT 3
117928: PPUSH
117929: LD_INT 5
117931: PPUSH
117932: CALL_OW 272
117936: PPUSH
117937: LD_VAR 0 8
117941: PPUSH
117942: CALL_OW 251
117946: PPUSH
117947: LD_INT 3
117949: PPUSH
117950: LD_INT 5
117952: PPUSH
117953: CALL_OW 273
117957: PPUSH
117958: CALL_OW 111
// SetTag ( i , 0 ) ;
117962: LD_VAR 0 7
117966: PPUSH
117967: LD_INT 0
117969: PPUSH
117970: CALL_OW 109
// solds := solds diff i ;
117974: LD_ADDR_VAR 0 2
117978: PUSH
117979: LD_VAR 0 2
117983: PUSH
117984: LD_VAR 0 7
117988: DIFF
117989: ST_TO_ADDR
// continue ;
117990: GO 117777
// end ; end ;
117992: GO 117777
117994: POP
117995: POP
// until solds ;
117996: LD_VAR 0 2
118000: IFFALSE 117609
// MC_Reset ( base , 18 ) ;
118002: LD_VAR 0 1
118006: PPUSH
118007: LD_INT 18
118009: PPUSH
118010: CALL 39019 0 2
// end ;
118014: LD_VAR 0 4
118018: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
118019: LD_INT 0
118021: PPUSH
118022: PPUSH
118023: PPUSH
118024: PPUSH
118025: PPUSH
118026: PPUSH
118027: PPUSH
118028: PPUSH
118029: PPUSH
118030: PPUSH
118031: PPUSH
118032: PPUSH
118033: PPUSH
118034: PPUSH
118035: PPUSH
118036: PPUSH
118037: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
118038: LD_ADDR_VAR 0 13
118042: PUSH
118043: LD_EXP 110
118047: PUSH
118048: LD_VAR 0 1
118052: ARRAY
118053: PPUSH
118054: LD_INT 25
118056: PUSH
118057: LD_INT 3
118059: PUSH
118060: EMPTY
118061: LIST
118062: LIST
118063: PPUSH
118064: CALL_OW 72
118068: ST_TO_ADDR
// if mc_remote_driver [ base ] then
118069: LD_EXP 150
118073: PUSH
118074: LD_VAR 0 1
118078: ARRAY
118079: IFFALSE 118103
// mechs := mechs diff mc_remote_driver [ base ] ;
118081: LD_ADDR_VAR 0 13
118085: PUSH
118086: LD_VAR 0 13
118090: PUSH
118091: LD_EXP 150
118095: PUSH
118096: LD_VAR 0 1
118100: ARRAY
118101: DIFF
118102: ST_TO_ADDR
// for i in mechs do
118103: LD_ADDR_VAR 0 5
118107: PUSH
118108: LD_VAR 0 13
118112: PUSH
118113: FOR_IN
118114: IFFALSE 118149
// if GetTag ( i ) > 0 then
118116: LD_VAR 0 5
118120: PPUSH
118121: CALL_OW 110
118125: PUSH
118126: LD_INT 0
118128: GREATER
118129: IFFALSE 118147
// mechs := mechs diff i ;
118131: LD_ADDR_VAR 0 13
118135: PUSH
118136: LD_VAR 0 13
118140: PUSH
118141: LD_VAR 0 5
118145: DIFF
118146: ST_TO_ADDR
118147: GO 118113
118149: POP
118150: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118151: LD_ADDR_VAR 0 9
118155: PUSH
118156: LD_EXP 110
118160: PUSH
118161: LD_VAR 0 1
118165: ARRAY
118166: PPUSH
118167: LD_INT 2
118169: PUSH
118170: LD_INT 25
118172: PUSH
118173: LD_INT 1
118175: PUSH
118176: EMPTY
118177: LIST
118178: LIST
118179: PUSH
118180: LD_INT 25
118182: PUSH
118183: LD_INT 5
118185: PUSH
118186: EMPTY
118187: LIST
118188: LIST
118189: PUSH
118190: LD_INT 25
118192: PUSH
118193: LD_INT 8
118195: PUSH
118196: EMPTY
118197: LIST
118198: LIST
118199: PUSH
118200: LD_INT 25
118202: PUSH
118203: LD_INT 9
118205: PUSH
118206: EMPTY
118207: LIST
118208: LIST
118209: PUSH
118210: EMPTY
118211: LIST
118212: LIST
118213: LIST
118214: LIST
118215: LIST
118216: PPUSH
118217: CALL_OW 72
118221: ST_TO_ADDR
// if not defenders and not solds then
118222: LD_VAR 0 2
118226: NOT
118227: PUSH
118228: LD_VAR 0 9
118232: NOT
118233: AND
118234: IFFALSE 118238
// exit ;
118236: GO 119864
// depot_under_attack := false ;
118238: LD_ADDR_VAR 0 17
118242: PUSH
118243: LD_INT 0
118245: ST_TO_ADDR
// sold_defenders := [ ] ;
118246: LD_ADDR_VAR 0 18
118250: PUSH
118251: EMPTY
118252: ST_TO_ADDR
// if mechs then
118253: LD_VAR 0 13
118257: IFFALSE 118386
// for i in defenders do
118259: LD_ADDR_VAR 0 5
118263: PUSH
118264: LD_VAR 0 2
118268: PUSH
118269: FOR_IN
118270: IFFALSE 118384
// begin SetTag ( i , 20 ) ;
118272: LD_VAR 0 5
118276: PPUSH
118277: LD_INT 20
118279: PPUSH
118280: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
118284: LD_VAR 0 5
118288: PPUSH
118289: CALL_OW 263
118293: PUSH
118294: LD_INT 1
118296: EQUAL
118297: PUSH
118298: LD_VAR 0 5
118302: PPUSH
118303: CALL_OW 311
118307: NOT
118308: AND
118309: PUSH
118310: LD_VAR 0 13
118314: AND
118315: IFFALSE 118382
// begin un := mechs [ 1 ] ;
118317: LD_ADDR_VAR 0 11
118321: PUSH
118322: LD_VAR 0 13
118326: PUSH
118327: LD_INT 1
118329: ARRAY
118330: ST_TO_ADDR
// ComExitBuilding ( un ) ;
118331: LD_VAR 0 11
118335: PPUSH
118336: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
118340: LD_VAR 0 11
118344: PPUSH
118345: LD_VAR 0 5
118349: PPUSH
118350: CALL_OW 180
// SetTag ( un , 19 ) ;
118354: LD_VAR 0 11
118358: PPUSH
118359: LD_INT 19
118361: PPUSH
118362: CALL_OW 109
// mechs := mechs diff un ;
118366: LD_ADDR_VAR 0 13
118370: PUSH
118371: LD_VAR 0 13
118375: PUSH
118376: LD_VAR 0 11
118380: DIFF
118381: ST_TO_ADDR
// end ; end ;
118382: GO 118269
118384: POP
118385: POP
// if solds then
118386: LD_VAR 0 9
118390: IFFALSE 118449
// for i in solds do
118392: LD_ADDR_VAR 0 5
118396: PUSH
118397: LD_VAR 0 9
118401: PUSH
118402: FOR_IN
118403: IFFALSE 118447
// if not GetTag ( i ) then
118405: LD_VAR 0 5
118409: PPUSH
118410: CALL_OW 110
118414: NOT
118415: IFFALSE 118445
// begin defenders := defenders union i ;
118417: LD_ADDR_VAR 0 2
118421: PUSH
118422: LD_VAR 0 2
118426: PUSH
118427: LD_VAR 0 5
118431: UNION
118432: ST_TO_ADDR
// SetTag ( i , 18 ) ;
118433: LD_VAR 0 5
118437: PPUSH
118438: LD_INT 18
118440: PPUSH
118441: CALL_OW 109
// end ;
118445: GO 118402
118447: POP
118448: POP
// repeat wait ( 0 0$1 ) ;
118449: LD_INT 35
118451: PPUSH
118452: CALL_OW 67
// enemy := mc_scan [ base ] ;
118456: LD_ADDR_VAR 0 3
118460: PUSH
118461: LD_EXP 133
118465: PUSH
118466: LD_VAR 0 1
118470: ARRAY
118471: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118472: LD_EXP 110
118476: PUSH
118477: LD_VAR 0 1
118481: ARRAY
118482: NOT
118483: PUSH
118484: LD_EXP 110
118488: PUSH
118489: LD_VAR 0 1
118493: ARRAY
118494: PUSH
118495: EMPTY
118496: EQUAL
118497: OR
118498: IFFALSE 118535
// begin for i in defenders do
118500: LD_ADDR_VAR 0 5
118504: PUSH
118505: LD_VAR 0 2
118509: PUSH
118510: FOR_IN
118511: IFFALSE 118524
// ComStop ( i ) ;
118513: LD_VAR 0 5
118517: PPUSH
118518: CALL_OW 141
118522: GO 118510
118524: POP
118525: POP
// defenders := [ ] ;
118526: LD_ADDR_VAR 0 2
118530: PUSH
118531: EMPTY
118532: ST_TO_ADDR
// exit ;
118533: GO 119864
// end ; for i in defenders do
118535: LD_ADDR_VAR 0 5
118539: PUSH
118540: LD_VAR 0 2
118544: PUSH
118545: FOR_IN
118546: IFFALSE 119364
// begin e := NearestUnitToUnit ( enemy , i ) ;
118548: LD_ADDR_VAR 0 14
118552: PUSH
118553: LD_VAR 0 3
118557: PPUSH
118558: LD_VAR 0 5
118562: PPUSH
118563: CALL_OW 74
118567: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
118568: LD_ADDR_VAR 0 8
118572: PUSH
118573: LD_EXP 110
118577: PUSH
118578: LD_VAR 0 1
118582: ARRAY
118583: PPUSH
118584: LD_INT 2
118586: PUSH
118587: LD_INT 30
118589: PUSH
118590: LD_INT 0
118592: PUSH
118593: EMPTY
118594: LIST
118595: LIST
118596: PUSH
118597: LD_INT 30
118599: PUSH
118600: LD_INT 1
118602: PUSH
118603: EMPTY
118604: LIST
118605: LIST
118606: PUSH
118607: EMPTY
118608: LIST
118609: LIST
118610: LIST
118611: PPUSH
118612: CALL_OW 72
118616: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
118617: LD_ADDR_VAR 0 17
118621: PUSH
118622: LD_VAR 0 8
118626: NOT
118627: PUSH
118628: LD_VAR 0 8
118632: PPUSH
118633: LD_INT 3
118635: PUSH
118636: LD_INT 24
118638: PUSH
118639: LD_INT 600
118641: PUSH
118642: EMPTY
118643: LIST
118644: LIST
118645: PUSH
118646: EMPTY
118647: LIST
118648: LIST
118649: PPUSH
118650: CALL_OW 72
118654: OR
118655: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
118656: LD_VAR 0 5
118660: PPUSH
118661: CALL_OW 247
118665: PUSH
118666: LD_INT 2
118668: DOUBLE
118669: EQUAL
118670: IFTRUE 118674
118672: GO 119070
118674: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
118675: LD_VAR 0 5
118679: PPUSH
118680: CALL_OW 256
118684: PUSH
118685: LD_INT 650
118687: GREATER
118688: PUSH
118689: LD_VAR 0 5
118693: PPUSH
118694: LD_VAR 0 14
118698: PPUSH
118699: CALL_OW 296
118703: PUSH
118704: LD_INT 40
118706: LESS
118707: PUSH
118708: LD_VAR 0 14
118712: PPUSH
118713: LD_EXP 135
118717: PUSH
118718: LD_VAR 0 1
118722: ARRAY
118723: PPUSH
118724: CALL_OW 308
118728: OR
118729: AND
118730: IFFALSE 118852
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
118732: LD_VAR 0 5
118736: PPUSH
118737: CALL_OW 262
118741: PUSH
118742: LD_INT 1
118744: EQUAL
118745: PUSH
118746: LD_VAR 0 5
118750: PPUSH
118751: CALL_OW 261
118755: PUSH
118756: LD_INT 30
118758: LESS
118759: AND
118760: PUSH
118761: LD_VAR 0 8
118765: AND
118766: IFFALSE 118836
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
118768: LD_VAR 0 5
118772: PPUSH
118773: LD_VAR 0 8
118777: PPUSH
118778: LD_VAR 0 5
118782: PPUSH
118783: CALL_OW 74
118787: PPUSH
118788: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
118792: LD_VAR 0 5
118796: PPUSH
118797: LD_VAR 0 8
118801: PPUSH
118802: LD_VAR 0 5
118806: PPUSH
118807: CALL_OW 74
118811: PPUSH
118812: CALL_OW 296
118816: PUSH
118817: LD_INT 6
118819: LESS
118820: IFFALSE 118834
// SetFuel ( i , 100 ) ;
118822: LD_VAR 0 5
118826: PPUSH
118827: LD_INT 100
118829: PPUSH
118830: CALL_OW 240
// end else
118834: GO 118850
// ComAttackUnit ( i , e ) ;
118836: LD_VAR 0 5
118840: PPUSH
118841: LD_VAR 0 14
118845: PPUSH
118846: CALL_OW 115
// end else
118850: GO 118953
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
118852: LD_VAR 0 14
118856: PPUSH
118857: LD_EXP 135
118861: PUSH
118862: LD_VAR 0 1
118866: ARRAY
118867: PPUSH
118868: CALL_OW 308
118872: NOT
118873: PUSH
118874: LD_VAR 0 5
118878: PPUSH
118879: LD_VAR 0 14
118883: PPUSH
118884: CALL_OW 296
118888: PUSH
118889: LD_INT 40
118891: GREATEREQUAL
118892: AND
118893: PUSH
118894: LD_VAR 0 5
118898: PPUSH
118899: CALL_OW 256
118903: PUSH
118904: LD_INT 650
118906: LESSEQUAL
118907: OR
118908: PUSH
118909: LD_VAR 0 5
118913: PPUSH
118914: LD_EXP 134
118918: PUSH
118919: LD_VAR 0 1
118923: ARRAY
118924: PPUSH
118925: CALL_OW 308
118929: NOT
118930: AND
118931: IFFALSE 118953
// ComMoveToArea ( i , mc_parking [ base ] ) ;
118933: LD_VAR 0 5
118937: PPUSH
118938: LD_EXP 134
118942: PUSH
118943: LD_VAR 0 1
118947: ARRAY
118948: PPUSH
118949: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
118953: LD_VAR 0 5
118957: PPUSH
118958: CALL_OW 256
118962: PUSH
118963: LD_INT 998
118965: LESS
118966: PUSH
118967: LD_VAR 0 5
118971: PPUSH
118972: CALL_OW 263
118976: PUSH
118977: LD_INT 1
118979: EQUAL
118980: AND
118981: PUSH
118982: LD_VAR 0 5
118986: PPUSH
118987: CALL_OW 311
118991: AND
118992: PUSH
118993: LD_VAR 0 5
118997: PPUSH
118998: LD_EXP 134
119002: PUSH
119003: LD_VAR 0 1
119007: ARRAY
119008: PPUSH
119009: CALL_OW 308
119013: AND
119014: IFFALSE 119068
// begin mech := IsDrivenBy ( i ) ;
119016: LD_ADDR_VAR 0 10
119020: PUSH
119021: LD_VAR 0 5
119025: PPUSH
119026: CALL_OW 311
119030: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
119031: LD_VAR 0 10
119035: PPUSH
119036: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
119040: LD_VAR 0 10
119044: PPUSH
119045: LD_VAR 0 5
119049: PPUSH
119050: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
119054: LD_VAR 0 10
119058: PPUSH
119059: LD_VAR 0 5
119063: PPUSH
119064: CALL_OW 180
// end ; end ; unit_human :
119068: GO 119335
119070: LD_INT 1
119072: DOUBLE
119073: EQUAL
119074: IFTRUE 119078
119076: GO 119334
119078: POP
// begin b := IsInUnit ( i ) ;
119079: LD_ADDR_VAR 0 19
119083: PUSH
119084: LD_VAR 0 5
119088: PPUSH
119089: CALL_OW 310
119093: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
119094: LD_ADDR_VAR 0 20
119098: PUSH
119099: LD_VAR 0 19
119103: NOT
119104: PUSH
119105: LD_VAR 0 19
119109: PPUSH
119110: CALL_OW 266
119114: PUSH
119115: LD_INT 32
119117: PUSH
119118: LD_INT 31
119120: PUSH
119121: EMPTY
119122: LIST
119123: LIST
119124: IN
119125: OR
119126: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
119127: LD_VAR 0 17
119131: PUSH
119132: LD_VAR 0 2
119136: PPUSH
119137: LD_INT 21
119139: PUSH
119140: LD_INT 2
119142: PUSH
119143: EMPTY
119144: LIST
119145: LIST
119146: PPUSH
119147: CALL_OW 72
119151: PUSH
119152: LD_INT 1
119154: LESSEQUAL
119155: OR
119156: PUSH
119157: LD_VAR 0 20
119161: AND
119162: PUSH
119163: LD_VAR 0 5
119167: PUSH
119168: LD_VAR 0 18
119172: IN
119173: NOT
119174: AND
119175: IFFALSE 119268
// begin if b then
119177: LD_VAR 0 19
119181: IFFALSE 119230
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
119183: LD_VAR 0 19
119187: PPUSH
119188: LD_VAR 0 3
119192: PPUSH
119193: LD_VAR 0 19
119197: PPUSH
119198: CALL_OW 74
119202: PPUSH
119203: CALL_OW 296
119207: PUSH
119208: LD_INT 10
119210: LESS
119211: PUSH
119212: LD_VAR 0 19
119216: PPUSH
119217: CALL_OW 461
119221: PUSH
119222: LD_INT 7
119224: NONEQUAL
119225: AND
119226: IFFALSE 119230
// continue ;
119228: GO 118545
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
119230: LD_ADDR_VAR 0 18
119234: PUSH
119235: LD_VAR 0 18
119239: PPUSH
119240: LD_VAR 0 18
119244: PUSH
119245: LD_INT 1
119247: PLUS
119248: PPUSH
119249: LD_VAR 0 5
119253: PPUSH
119254: CALL_OW 1
119258: ST_TO_ADDR
// ComExitBuilding ( i ) ;
119259: LD_VAR 0 5
119263: PPUSH
119264: CALL_OW 122
// end ; if sold_defenders then
119268: LD_VAR 0 18
119272: IFFALSE 119332
// if i in sold_defenders then
119274: LD_VAR 0 5
119278: PUSH
119279: LD_VAR 0 18
119283: IN
119284: IFFALSE 119332
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
119286: LD_VAR 0 5
119290: PPUSH
119291: CALL_OW 314
119295: NOT
119296: PUSH
119297: LD_VAR 0 5
119301: PPUSH
119302: LD_VAR 0 14
119306: PPUSH
119307: CALL_OW 296
119311: PUSH
119312: LD_INT 30
119314: LESS
119315: AND
119316: IFFALSE 119332
// ComAttackUnit ( i , e ) ;
119318: LD_VAR 0 5
119322: PPUSH
119323: LD_VAR 0 14
119327: PPUSH
119328: CALL_OW 115
// end ; end ; end ;
119332: GO 119335
119334: POP
// if IsDead ( i ) then
119335: LD_VAR 0 5
119339: PPUSH
119340: CALL_OW 301
119344: IFFALSE 119362
// defenders := defenders diff i ;
119346: LD_ADDR_VAR 0 2
119350: PUSH
119351: LD_VAR 0 2
119355: PUSH
119356: LD_VAR 0 5
119360: DIFF
119361: ST_TO_ADDR
// end ;
119362: GO 118545
119364: POP
119365: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
119366: LD_VAR 0 3
119370: NOT
119371: PUSH
119372: LD_VAR 0 2
119376: NOT
119377: OR
119378: PUSH
119379: LD_EXP 110
119383: PUSH
119384: LD_VAR 0 1
119388: ARRAY
119389: NOT
119390: OR
119391: IFFALSE 118449
// MC_Reset ( base , 18 ) ;
119393: LD_VAR 0 1
119397: PPUSH
119398: LD_INT 18
119400: PPUSH
119401: CALL 39019 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
119405: LD_ADDR_VAR 0 2
119409: PUSH
119410: LD_VAR 0 2
119414: PUSH
119415: LD_VAR 0 2
119419: PPUSH
119420: LD_INT 2
119422: PUSH
119423: LD_INT 25
119425: PUSH
119426: LD_INT 1
119428: PUSH
119429: EMPTY
119430: LIST
119431: LIST
119432: PUSH
119433: LD_INT 25
119435: PUSH
119436: LD_INT 5
119438: PUSH
119439: EMPTY
119440: LIST
119441: LIST
119442: PUSH
119443: LD_INT 25
119445: PUSH
119446: LD_INT 8
119448: PUSH
119449: EMPTY
119450: LIST
119451: LIST
119452: PUSH
119453: LD_INT 25
119455: PUSH
119456: LD_INT 9
119458: PUSH
119459: EMPTY
119460: LIST
119461: LIST
119462: PUSH
119463: EMPTY
119464: LIST
119465: LIST
119466: LIST
119467: LIST
119468: LIST
119469: PPUSH
119470: CALL_OW 72
119474: DIFF
119475: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
119476: LD_VAR 0 3
119480: NOT
119481: PUSH
119482: LD_VAR 0 2
119486: PPUSH
119487: LD_INT 21
119489: PUSH
119490: LD_INT 2
119492: PUSH
119493: EMPTY
119494: LIST
119495: LIST
119496: PPUSH
119497: CALL_OW 72
119501: AND
119502: IFFALSE 119840
// begin tmp := FilterByTag ( defenders , 19 ) ;
119504: LD_ADDR_VAR 0 12
119508: PUSH
119509: LD_VAR 0 2
119513: PPUSH
119514: LD_INT 19
119516: PPUSH
119517: CALL 98487 0 2
119521: ST_TO_ADDR
// if tmp then
119522: LD_VAR 0 12
119526: IFFALSE 119596
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
119528: LD_ADDR_VAR 0 12
119532: PUSH
119533: LD_VAR 0 12
119537: PPUSH
119538: LD_INT 25
119540: PUSH
119541: LD_INT 3
119543: PUSH
119544: EMPTY
119545: LIST
119546: LIST
119547: PPUSH
119548: CALL_OW 72
119552: ST_TO_ADDR
// if tmp then
119553: LD_VAR 0 12
119557: IFFALSE 119596
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
119559: LD_ADDR_EXP 122
119563: PUSH
119564: LD_EXP 122
119568: PPUSH
119569: LD_VAR 0 1
119573: PPUSH
119574: LD_EXP 122
119578: PUSH
119579: LD_VAR 0 1
119583: ARRAY
119584: PUSH
119585: LD_VAR 0 12
119589: UNION
119590: PPUSH
119591: CALL_OW 1
119595: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
119596: LD_VAR 0 1
119600: PPUSH
119601: LD_INT 19
119603: PPUSH
119604: CALL 39019 0 2
// repeat wait ( 0 0$1 ) ;
119608: LD_INT 35
119610: PPUSH
119611: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119615: LD_EXP 110
119619: PUSH
119620: LD_VAR 0 1
119624: ARRAY
119625: NOT
119626: PUSH
119627: LD_EXP 110
119631: PUSH
119632: LD_VAR 0 1
119636: ARRAY
119637: PUSH
119638: EMPTY
119639: EQUAL
119640: OR
119641: IFFALSE 119678
// begin for i in defenders do
119643: LD_ADDR_VAR 0 5
119647: PUSH
119648: LD_VAR 0 2
119652: PUSH
119653: FOR_IN
119654: IFFALSE 119667
// ComStop ( i ) ;
119656: LD_VAR 0 5
119660: PPUSH
119661: CALL_OW 141
119665: GO 119653
119667: POP
119668: POP
// defenders := [ ] ;
119669: LD_ADDR_VAR 0 2
119673: PUSH
119674: EMPTY
119675: ST_TO_ADDR
// exit ;
119676: GO 119864
// end ; for i in defenders do
119678: LD_ADDR_VAR 0 5
119682: PUSH
119683: LD_VAR 0 2
119687: PUSH
119688: FOR_IN
119689: IFFALSE 119778
// begin if not IsInArea ( i , mc_parking [ base ] ) then
119691: LD_VAR 0 5
119695: PPUSH
119696: LD_EXP 134
119700: PUSH
119701: LD_VAR 0 1
119705: ARRAY
119706: PPUSH
119707: CALL_OW 308
119711: NOT
119712: IFFALSE 119736
// ComMoveToArea ( i , mc_parking [ base ] ) else
119714: LD_VAR 0 5
119718: PPUSH
119719: LD_EXP 134
119723: PUSH
119724: LD_VAR 0 1
119728: ARRAY
119729: PPUSH
119730: CALL_OW 113
119734: GO 119776
// if GetControl ( i ) = control_manual then
119736: LD_VAR 0 5
119740: PPUSH
119741: CALL_OW 263
119745: PUSH
119746: LD_INT 1
119748: EQUAL
119749: IFFALSE 119776
// if IsDrivenBy ( i ) then
119751: LD_VAR 0 5
119755: PPUSH
119756: CALL_OW 311
119760: IFFALSE 119776
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
119762: LD_VAR 0 5
119766: PPUSH
119767: CALL_OW 311
119771: PPUSH
119772: CALL_OW 121
// end ;
119776: GO 119688
119778: POP
119779: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
119780: LD_VAR 0 2
119784: PPUSH
119785: LD_INT 95
119787: PUSH
119788: LD_EXP 134
119792: PUSH
119793: LD_VAR 0 1
119797: ARRAY
119798: PUSH
119799: EMPTY
119800: LIST
119801: LIST
119802: PPUSH
119803: CALL_OW 72
119807: PUSH
119808: LD_VAR 0 2
119812: EQUAL
119813: PUSH
119814: LD_EXP 133
119818: PUSH
119819: LD_VAR 0 1
119823: ARRAY
119824: OR
119825: PUSH
119826: LD_EXP 110
119830: PUSH
119831: LD_VAR 0 1
119835: ARRAY
119836: NOT
119837: OR
119838: IFFALSE 119608
// end ; MC_Reset ( base , 19 ) ;
119840: LD_VAR 0 1
119844: PPUSH
119845: LD_INT 19
119847: PPUSH
119848: CALL 39019 0 2
// MC_Reset ( base , 20 ) ;
119852: LD_VAR 0 1
119856: PPUSH
119857: LD_INT 20
119859: PPUSH
119860: CALL 39019 0 2
// end ;
119864: LD_VAR 0 4
119868: RET
