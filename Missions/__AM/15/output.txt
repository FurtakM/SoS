// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitGlobalVariables ;
  15: CALL 34970 0 0
// InitMacro ;
  19: CALL 35114 0 0
// InitNature ;
  23: CALL 34838 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAlliance ;
  40: CALL 11097 0 0
// PrepareRussian ;
  44: CALL 6981 0 0
// PrepareLegion ;
  48: CALL 4206 0 0
// PreparePowell ;
  52: CALL 2943 0 0
// PrepareAmerican ;
  56: CALL 1715 0 0
// Action ;
  60: CALL 14991 0 0
// MC_Start ( ) ;
  64: CALL 37226 0 0
// end ;
  68: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// missionStart := false ;
  80: LD_ADDR_EXP 13
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// missionTime := 0 0$00 ;
  88: LD_ADDR_EXP 14
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// missionStage := 1 ;
  96: LD_ADDR_EXP 15
 100: PUSH
 101: LD_INT 1
 103: ST_TO_ADDR
// activeAttacks := false ;
 104: LD_ADDR_EXP 16
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// powellAnger := 0 ;
 112: LD_ADDR_EXP 17
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// powellAngerQuery := false ;
 120: LD_ADDR_EXP 36
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// powellAllowRetreat := true ;
 128: LD_ADDR_EXP 19
 132: PUSH
 133: LD_INT 1
 135: ST_TO_ADDR
// powellCenterCameraMode := false ;
 136: LD_ADDR_EXP 20
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 144: LD_ADDR_EXP 18
 148: PUSH
 149: EMPTY
 150: PUSH
 151: EMPTY
 152: PUSH
 153: EMPTY
 154: LIST
 155: LIST
 156: ST_TO_ADDR
// russianDestroyed := false ;
 157: LD_ADDR_EXP 21
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// legionDestroyed := false ;
 165: LD_ADDR_EXP 22
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// allianceDestroyed := false ;
 173: LD_ADDR_EXP 23
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 181: LD_ADDR_EXP 2
 185: PUSH
 186: LD_STRING 14_KappaStatus_1
 188: PPUSH
 189: LD_INT 0
 191: PPUSH
 192: CALL_OW 30
 196: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 197: LD_ADDR_EXP 3
 201: PUSH
 202: LD_STRING 06_KurtStatus_1
 204: PPUSH
 205: LD_INT 0
 207: PPUSH
 208: CALL_OW 30
 212: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 213: LD_ADDR_EXP 4
 217: PUSH
 218: LD_STRING 14_JMMVeh_1
 220: PPUSH
 221: LD_INT 0
 223: PPUSH
 224: CALL_OW 30
 228: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 229: LD_ADDR_EXP 5
 233: PUSH
 234: LD_STRING 14_JMMGirlVeh_1
 236: PPUSH
 237: LD_INT 0
 239: PPUSH
 240: CALL_OW 30
 244: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 245: LD_ADDR_EXP 7
 249: PUSH
 250: LD_STRING 14_JMMGirl_1
 252: PPUSH
 253: LD_INT 0
 255: PPUSH
 256: CALL_OW 30
 260: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 261: LD_ADDR_EXP 6
 265: PUSH
 266: LD_STRING 14_JMMGirlStatus_1
 268: PPUSH
 269: LD_INT 0
 271: PPUSH
 272: CALL_OW 30
 276: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 277: LD_ADDR_EXP 8
 281: PUSH
 282: LD_STRING 10_KhatamStatus_1
 284: PPUSH
 285: LD_INT 0
 287: PPUSH
 288: CALL_OW 30
 292: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 293: LD_ADDR_EXP 9
 297: PUSH
 298: LD_STRING 13_BurlakStatus_1
 300: PPUSH
 301: LD_INT 0
 303: PPUSH
 304: CALL_OW 30
 308: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 309: LD_ADDR_EXP 10
 313: PUSH
 314: LD_STRING 13_StevensStatus_1
 316: PPUSH
 317: LD_INT 0
 319: PPUSH
 320: CALL_OW 30
 324: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 325: LD_ADDR_EXP 11
 329: PUSH
 330: LD_STRING 14_FastEnd_1
 332: PPUSH
 333: LD_INT 0
 335: PPUSH
 336: CALL_OW 30
 340: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 341: LD_ADDR_EXP 12
 345: PUSH
 346: LD_STRING 12_MainDepositFake_1
 348: PPUSH
 349: LD_INT 0
 351: PPUSH
 352: CALL_OW 30
 356: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 357: LD_ADDR_EXP 24
 361: PUSH
 362: LD_INT 1
 364: ST_TO_ADDR
// behemothUnderConstruct := false ;
 365: LD_ADDR_EXP 26
 369: PUSH
 370: LD_INT 0
 372: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 373: LD_ADDR_EXP 27
 377: PUSH
 378: LD_INT 0
 380: ST_TO_ADDR
// behemothDone := false ;
 381: LD_ADDR_EXP 28
 385: PUSH
 386: LD_INT 0
 388: ST_TO_ADDR
// allowBehemothConstruct := false ;
 389: LD_ADDR_EXP 25
 393: PUSH
 394: LD_INT 0
 396: ST_TO_ADDR
// seeBehemoth := false ;
 397: LD_ADDR_EXP 29
 401: PUSH
 402: LD_INT 0
 404: ST_TO_ADDR
// platonovHasBomb := false ;
 405: LD_ADDR_EXP 30
 409: PUSH
 410: LD_INT 0
 412: ST_TO_ADDR
// allianceActive := false ;
 413: LD_ADDR_EXP 31
 417: PUSH
 418: LD_INT 0
 420: ST_TO_ADDR
// rothCaptured := false ;
 421: LD_ADDR_EXP 33
 425: PUSH
 426: LD_INT 0
 428: ST_TO_ADDR
// lostCounter := 0 ;
 429: LD_ADDR_EXP 32
 433: PUSH
 434: LD_INT 0
 436: ST_TO_ADDR
// capturedUnit := [ ] ;
 437: LD_ADDR_EXP 34
 441: PUSH
 442: EMPTY
 443: ST_TO_ADDR
// trueAmericans := [ ] ;
 444: LD_ADDR_EXP 35
 448: PUSH
 449: EMPTY
 450: ST_TO_ADDR
// bombExploded := false ;
 451: LD_ADDR_EXP 37
 455: PUSH
 456: LD_INT 0
 458: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 459: LD_ADDR_EXP 38
 463: PUSH
 464: EMPTY
 465: ST_TO_ADDR
// end ;
 466: LD_VAR 0 1
 470: RET
// export function CustomInitMacro ( ) ; begin
 471: LD_INT 0
 473: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 474: LD_ADDR_EXP 137
 478: PUSH
 479: LD_INT 2
 481: PUSH
 482: LD_INT 3
 484: PUSH
 485: LD_INT 6
 487: PUSH
 488: LD_INT 10
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 497: LD_ADDR_EXP 138
 501: PUSH
 502: LD_INT 1
 504: PUSH
 505: LD_INT 4
 507: PUSH
 508: LD_INT 5
 510: PUSH
 511: LD_INT 9
 513: PUSH
 514: EMPTY
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 520: LD_INT 1
 522: PPUSH
 523: LD_INT 10
 525: PUSH
 526: LD_INT 11
 528: PUSH
 529: LD_INT 12
 531: PUSH
 532: EMPTY
 533: LIST
 534: LIST
 535: LIST
 536: PPUSH
 537: CALL 59513 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 541: LD_INT 1
 543: PPUSH
 544: LD_INT 17
 546: PUSH
 547: EMPTY
 548: LIST
 549: PPUSH
 550: CALL 59606 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 554: LD_INT 1
 556: PPUSH
 557: LD_INT 5
 559: PPUSH
 560: CALL 58956 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 24
 569: PUSH
 570: LD_INT 3
 572: PUSH
 573: LD_INT 3
 575: PUSH
 576: LD_INT 47
 578: PUSH
 579: EMPTY
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: PUSH
 585: LD_INT 24
 587: PUSH
 588: LD_INT 3
 590: PUSH
 591: LD_INT 3
 593: PUSH
 594: LD_INT 47
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: PUSH
 603: LD_INT 24
 605: PUSH
 606: LD_INT 3
 608: PUSH
 609: LD_INT 3
 611: PUSH
 612: LD_INT 47
 614: PUSH
 615: EMPTY
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: PUSH
 621: LD_INT 24
 623: PUSH
 624: LD_INT 3
 626: PUSH
 627: LD_INT 1
 629: PUSH
 630: LD_INT 47
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: LIST
 637: LIST
 638: PUSH
 639: LD_INT 24
 641: PUSH
 642: LD_INT 3
 644: PUSH
 645: LD_INT 1
 647: PUSH
 648: LD_INT 47
 650: PUSH
 651: EMPTY
 652: LIST
 653: LIST
 654: LIST
 655: LIST
 656: PUSH
 657: EMPTY
 658: LIST
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: PPUSH
 664: CALL 58771 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 668: LD_INT 2
 670: PPUSH
 671: LD_INT 10
 673: PUSH
 674: LD_INT 11
 676: PUSH
 677: LD_INT 12
 679: PUSH
 680: LD_INT 14
 682: PUSH
 683: EMPTY
 684: LIST
 685: LIST
 686: LIST
 687: LIST
 688: PPUSH
 689: CALL 59513 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 693: LD_INT 2
 695: PPUSH
 696: LD_INT 16
 698: PUSH
 699: EMPTY
 700: LIST
 701: PPUSH
 702: CALL 59606 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 706: LD_INT 2
 708: PPUSH
 709: LD_INT 21
 711: PUSH
 712: LD_INT 3
 714: PUSH
 715: LD_INT 3
 717: PUSH
 718: LD_INT 51
 720: PUSH
 721: EMPTY
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: PUSH
 727: LD_INT 22
 729: PUSH
 730: LD_INT 3
 732: PUSH
 733: LD_INT 3
 735: PUSH
 736: LD_INT 52
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: PUSH
 745: LD_INT 22
 747: PUSH
 748: LD_INT 3
 750: PUSH
 751: LD_INT 3
 753: PUSH
 754: LD_INT 52
 756: PUSH
 757: EMPTY
 758: LIST
 759: LIST
 760: LIST
 761: LIST
 762: PUSH
 763: LD_INT 24
 765: PUSH
 766: LD_INT 3
 768: PUSH
 769: LD_INT 3
 771: PUSH
 772: LD_INT 47
 774: PUSH
 775: EMPTY
 776: LIST
 777: LIST
 778: LIST
 779: LIST
 780: PUSH
 781: LD_INT 24
 783: PUSH
 784: LD_INT 3
 786: PUSH
 787: LD_INT 3
 789: PUSH
 790: LD_INT 47
 792: PUSH
 793: EMPTY
 794: LIST
 795: LIST
 796: LIST
 797: LIST
 798: PUSH
 799: LD_INT 24
 801: PUSH
 802: LD_INT 3
 804: PUSH
 805: LD_INT 3
 807: PUSH
 808: LD_INT 47
 810: PUSH
 811: EMPTY
 812: LIST
 813: LIST
 814: LIST
 815: LIST
 816: PUSH
 817: LD_INT 24
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: LD_INT 3
 825: PUSH
 826: LD_INT 47
 828: PUSH
 829: EMPTY
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: PUSH
 835: LD_INT 24
 837: PUSH
 838: LD_INT 3
 840: PUSH
 841: LD_INT 3
 843: PUSH
 844: LD_INT 47
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: LIST
 851: LIST
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: PPUSH
 863: CALL 58771 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 867: LD_INT 2
 869: PPUSH
 870: LD_INT 5
 872: PPUSH
 873: CALL 58956 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 877: LD_INT 2
 879: PPUSH
 880: LD_INT 0
 882: PPUSH
 883: CALL 59386 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 887: LD_INT 3
 889: PPUSH
 890: LD_INT 10
 892: PUSH
 893: LD_INT 12
 895: PUSH
 896: LD_INT 15
 898: PUSH
 899: EMPTY
 900: LIST
 901: LIST
 902: LIST
 903: PUSH
 904: LD_OWVAR 67
 908: ARRAY
 909: PPUSH
 910: LD_INT 27
 912: PPUSH
 913: CALL 58453 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 917: LD_INT 3
 919: PPUSH
 920: LD_INT 10
 922: PUSH
 923: LD_INT 11
 925: PUSH
 926: LD_INT 13
 928: PUSH
 929: LD_INT 15
 931: PUSH
 932: EMPTY
 933: LIST
 934: LIST
 935: LIST
 936: LIST
 937: PPUSH
 938: CALL 59513 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 942: LD_INT 3
 944: PPUSH
 945: LD_INT 15
 947: PUSH
 948: EMPTY
 949: LIST
 950: PPUSH
 951: CALL 59606 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 955: LD_ADDR_EXP 142
 959: PUSH
 960: LD_EXP 142
 964: PPUSH
 965: LD_INT 3
 967: PPUSH
 968: LD_INT 22
 970: PUSH
 971: LD_INT 8
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: PUSH
 978: LD_INT 25
 980: PUSH
 981: LD_INT 15
 983: PUSH
 984: EMPTY
 985: LIST
 986: LIST
 987: PUSH
 988: EMPTY
 989: LIST
 990: LIST
 991: PPUSH
 992: CALL_OW 69
 996: PPUSH
 997: CALL_OW 1
1001: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1002: LD_INT 3
1004: PPUSH
1005: LD_INT 13
1007: PUSH
1008: LD_INT 2
1010: PUSH
1011: LD_INT 1
1013: PUSH
1014: LD_INT 31
1016: PUSH
1017: EMPTY
1018: LIST
1019: LIST
1020: LIST
1021: LIST
1022: PUSH
1023: LD_INT 13
1025: PUSH
1026: LD_INT 2
1028: PUSH
1029: LD_INT 1
1031: PUSH
1032: LD_INT 31
1034: PUSH
1035: EMPTY
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: PUSH
1041: LD_INT 13
1043: PUSH
1044: LD_INT 3
1046: PUSH
1047: LD_INT 2
1049: PUSH
1050: LD_INT 32
1052: PUSH
1053: EMPTY
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: PUSH
1059: LD_INT 14
1061: PUSH
1062: LD_INT 1
1064: PUSH
1065: LD_INT 2
1067: PUSH
1068: LD_EXP 101
1072: PUSH
1073: EMPTY
1074: LIST
1075: LIST
1076: LIST
1077: LIST
1078: PUSH
1079: EMPTY
1080: LIST
1081: LIST
1082: LIST
1083: LIST
1084: PPUSH
1085: CALL 58771 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1089: LD_INT 4
1091: PPUSH
1092: LD_INT 10
1094: PUSH
1095: LD_INT 12
1097: PUSH
1098: EMPTY
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 59513 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 9
1111: PUSH
1112: EMPTY
1113: LIST
1114: PPUSH
1115: CALL 59606 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1119: LD_INT 4
1121: PPUSH
1122: LD_INT 26
1124: PUSH
1125: LD_INT 74
1127: PUSH
1128: LD_INT 107
1130: PUSH
1131: LD_INT 0
1133: PUSH
1134: EMPTY
1135: LIST
1136: LIST
1137: LIST
1138: LIST
1139: PUSH
1140: LD_INT 32
1142: PUSH
1143: LD_INT 77
1145: PUSH
1146: LD_INT 101
1148: PUSH
1149: LD_INT 4
1151: PUSH
1152: EMPTY
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PUSH
1158: LD_INT 32
1160: PUSH
1161: LD_INT 69
1163: PUSH
1164: LD_INT 86
1166: PUSH
1167: LD_INT 4
1169: PUSH
1170: EMPTY
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: PUSH
1176: LD_INT 27
1178: PUSH
1179: LD_INT 77
1181: PUSH
1182: LD_INT 110
1184: PUSH
1185: LD_INT 3
1187: PUSH
1188: EMPTY
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: PUSH
1194: LD_INT 27
1196: PUSH
1197: LD_INT 42
1199: PUSH
1200: LD_INT 79
1202: PUSH
1203: LD_INT 5
1205: PUSH
1206: EMPTY
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: PUSH
1212: LD_INT 29
1214: PUSH
1215: LD_INT 86
1217: PUSH
1218: LD_INT 105
1220: PUSH
1221: LD_INT 2
1223: PUSH
1224: EMPTY
1225: LIST
1226: LIST
1227: LIST
1228: LIST
1229: PUSH
1230: LD_INT 30
1232: PUSH
1233: LD_INT 40
1235: PUSH
1236: LD_INT 75
1238: PUSH
1239: LD_INT 1
1241: PUSH
1242: EMPTY
1243: LIST
1244: LIST
1245: LIST
1246: LIST
1247: PUSH
1248: LD_INT 32
1250: PUSH
1251: LD_INT 80
1253: PUSH
1254: LD_INT 106
1256: PUSH
1257: LD_INT 4
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: PUSH
1266: LD_INT 32
1268: PUSH
1269: LD_INT 75
1271: PUSH
1272: LD_INT 114
1274: PUSH
1275: LD_INT 5
1277: PUSH
1278: EMPTY
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: PUSH
1284: LD_INT 32
1286: PUSH
1287: LD_INT 82
1289: PUSH
1290: LD_INT 110
1292: PUSH
1293: LD_INT 5
1295: PUSH
1296: EMPTY
1297: LIST
1298: LIST
1299: LIST
1300: LIST
1301: PUSH
1302: LD_INT 32
1304: PUSH
1305: LD_INT 62
1307: PUSH
1308: LD_INT 78
1310: PUSH
1311: LD_INT 4
1313: PUSH
1314: EMPTY
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: PUSH
1320: LD_INT 4
1322: PUSH
1323: LD_INT 39
1325: PUSH
1326: LD_INT 61
1328: PUSH
1329: LD_INT 3
1331: PUSH
1332: EMPTY
1333: LIST
1334: LIST
1335: LIST
1336: LIST
1337: PUSH
1338: EMPTY
1339: LIST
1340: LIST
1341: LIST
1342: LIST
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: PPUSH
1352: CALL 58663 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1356: LD_INT 4
1358: PPUSH
1359: LD_INT 5
1361: PUSH
1362: LD_INT 6
1364: PUSH
1365: LD_INT 7
1367: PUSH
1368: LD_INT 9
1370: PUSH
1371: EMPTY
1372: LIST
1373: LIST
1374: LIST
1375: LIST
1376: PPUSH
1377: CALL 59924 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1381: LD_INT 4
1383: PPUSH
1384: LD_INT 40
1386: PUSH
1387: LD_INT 75
1389: PUSH
1390: LD_INT 1
1392: PUSH
1393: EMPTY
1394: LIST
1395: LIST
1396: LIST
1397: PUSH
1398: LD_INT 86
1400: PUSH
1401: LD_INT 105
1403: PUSH
1404: LD_INT 0
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: PUSH
1412: EMPTY
1413: LIST
1414: LIST
1415: PPUSH
1416: CALL 59095 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1420: LD_INT 4
1422: PPUSH
1423: LD_INT 2
1425: PPUSH
1426: CALL 59386 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1430: LD_INT 4
1432: PPUSH
1433: LD_INT 0
1435: PPUSH
1436: CALL 59386 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1440: LD_INT 4
1442: PPUSH
1443: LD_INT 54
1445: PPUSH
1446: LD_INT 85
1448: PPUSH
1449: LD_INT 2
1451: PPUSH
1452: LD_INT 19
1454: PUSH
1455: LD_INT 16
1457: PUSH
1458: LD_INT 17
1460: PUSH
1461: LD_INT 18
1463: PUSH
1464: EMPTY
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: PPUSH
1470: CALL 59718 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1474: LD_INT 4
1476: PPUSH
1477: LD_INT 3
1479: PUSH
1480: LD_INT 1
1482: PUSH
1483: LD_INT 1
1485: PUSH
1486: LD_INT 5
1488: PUSH
1489: EMPTY
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: PUSH
1495: LD_INT 4
1497: PUSH
1498: LD_INT 1
1500: PUSH
1501: LD_INT 1
1503: PUSH
1504: LD_INT 6
1506: PUSH
1507: EMPTY
1508: LIST
1509: LIST
1510: LIST
1511: LIST
1512: PUSH
1513: LD_INT 4
1515: PUSH
1516: LD_INT 1
1518: PUSH
1519: LD_INT 1
1521: PUSH
1522: LD_INT 7
1524: PUSH
1525: EMPTY
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: PUSH
1531: LD_INT 4
1533: PUSH
1534: LD_INT 1
1536: PUSH
1537: LD_INT 1
1539: PUSH
1540: LD_INT 6
1542: PUSH
1543: EMPTY
1544: LIST
1545: LIST
1546: LIST
1547: LIST
1548: PUSH
1549: EMPTY
1550: LIST
1551: LIST
1552: LIST
1553: LIST
1554: PPUSH
1555: CALL 58771 0 2
// MC_SetTame ( 4 , powellApe ) ;
1559: LD_INT 4
1561: PPUSH
1562: LD_INT 13
1564: PPUSH
1565: CALL 59337 0 2
// end ;
1569: LD_VAR 0 1
1573: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1574: LD_EXP 36
1578: PUSH
1579: LD_EXP 17
1583: PUSH
1584: LD_INT 2
1586: GREATEREQUAL
1587: AND
1588: IFFALSE 1600
1590: GO 1592
1592: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1593: LD_STRING ACH_POWELL
1595: PPUSH
1596: CALL_OW 543
1600: END
// every 0 0$1 trigger debug do var i , tmp ;
1601: LD_EXP 1
1605: IFFALSE 1712
1607: GO 1609
1609: DISABLE
1610: LD_INT 0
1612: PPUSH
1613: PPUSH
// begin enable ;
1614: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1615: LD_ADDR_VAR 0 2
1619: PUSH
1620: LD_INT 22
1622: PUSH
1623: LD_INT 1
1625: PUSH
1626: EMPTY
1627: LIST
1628: LIST
1629: PUSH
1630: LD_INT 3
1632: PUSH
1633: LD_INT 21
1635: PUSH
1636: LD_INT 3
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: PUSH
1643: EMPTY
1644: LIST
1645: LIST
1646: PUSH
1647: LD_INT 3
1649: PUSH
1650: LD_INT 24
1652: PUSH
1653: LD_INT 999
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: PUSH
1660: EMPTY
1661: LIST
1662: LIST
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PPUSH
1669: CALL_OW 69
1673: ST_TO_ADDR
// if not tmp then
1674: LD_VAR 0 2
1678: NOT
1679: IFFALSE 1683
// exit ;
1681: GO 1712
// for i in tmp do
1683: LD_ADDR_VAR 0 1
1687: PUSH
1688: LD_VAR 0 2
1692: PUSH
1693: FOR_IN
1694: IFFALSE 1710
// SetLives ( i , 1000 ) ;
1696: LD_VAR 0 1
1700: PPUSH
1701: LD_INT 1000
1703: PPUSH
1704: CALL_OW 234
1708: GO 1693
1710: POP
1711: POP
// end ; end_of_file
1712: PPOPN 2
1714: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1715: LD_INT 0
1717: PPUSH
// uc_side := 1 ;
1718: LD_ADDR_OWVAR 20
1722: PUSH
1723: LD_INT 1
1725: ST_TO_ADDR
// uc_nation := 1 ;
1726: LD_ADDR_OWVAR 21
1730: PUSH
1731: LD_INT 1
1733: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1734: LD_ADDR_EXP 39
1738: PUSH
1739: LD_STRING JMM
1741: PPUSH
1742: LD_EXP 1
1746: NOT
1747: PPUSH
1748: LD_STRING 14_
1750: PPUSH
1751: CALL 65182 0 3
1755: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1756: LD_EXP 4
1760: NOT
1761: PUSH
1762: LD_EXP 4
1766: PUSH
1767: LD_INT 1
1769: ARRAY
1770: PUSH
1771: LD_INT 1
1773: ARRAY
1774: NOT
1775: OR
1776: IFFALSE 1799
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1778: LD_INT 5
1780: PPUSH
1781: LD_INT 3
1783: PPUSH
1784: LD_INT 1
1786: PPUSH
1787: LD_INT 9
1789: PPUSH
1790: LD_INT 100
1792: PPUSH
1793: CALL 70006 0 5
1797: GO 1858
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1799: LD_EXP 4
1803: PUSH
1804: LD_INT 1
1806: ARRAY
1807: PUSH
1808: LD_INT 1
1810: ARRAY
1811: PPUSH
1812: LD_EXP 4
1816: PUSH
1817: LD_INT 2
1819: ARRAY
1820: PUSH
1821: LD_INT 1
1823: ARRAY
1824: PPUSH
1825: LD_EXP 4
1829: PUSH
1830: LD_INT 3
1832: ARRAY
1833: PUSH
1834: LD_INT 1
1836: ARRAY
1837: PPUSH
1838: LD_EXP 4
1842: PUSH
1843: LD_INT 4
1845: ARRAY
1846: PUSH
1847: LD_INT 1
1849: ARRAY
1850: PPUSH
1851: LD_INT 30
1853: PPUSH
1854: CALL 70006 0 5
// JMMNewVeh := CreateVehicle ;
1858: LD_ADDR_EXP 56
1862: PUSH
1863: CALL_OW 45
1867: ST_TO_ADDR
// if not JMMNewVeh then
1868: LD_EXP 56
1872: NOT
1873: IFFALSE 1904
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1875: LD_INT 5
1877: PPUSH
1878: LD_INT 3
1880: PPUSH
1881: LD_INT 1
1883: PPUSH
1884: LD_INT 9
1886: PPUSH
1887: LD_INT 100
1889: PPUSH
1890: CALL 70006 0 5
// JMMNewVeh := CreateVehicle ;
1894: LD_ADDR_EXP 56
1898: PUSH
1899: CALL_OW 45
1903: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1904: LD_EXP 56
1908: PPUSH
1909: LD_INT 4
1911: PPUSH
1912: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1916: LD_EXP 56
1920: PPUSH
1921: LD_INT 79
1923: PPUSH
1924: LD_INT 91
1926: PPUSH
1927: LD_INT 0
1929: PPUSH
1930: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1934: LD_EXP 39
1938: PPUSH
1939: LD_EXP 56
1943: PPUSH
1944: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1948: LD_EXP 6
1952: PUSH
1953: LD_EXP 2
1957: NOT
1958: AND
1959: IFFALSE 2217
// begin if not JMMGirlVeh then
1961: LD_EXP 5
1965: NOT
1966: IFFALSE 1989
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1968: LD_INT 3
1970: PPUSH
1971: LD_INT 3
1973: PPUSH
1974: LD_INT 1
1976: PPUSH
1977: LD_INT 9
1979: PPUSH
1980: LD_INT 100
1982: PPUSH
1983: CALL 70006 0 5
1987: GO 2048
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1989: LD_EXP 5
1993: PUSH
1994: LD_INT 1
1996: ARRAY
1997: PUSH
1998: LD_INT 1
2000: ARRAY
2001: PPUSH
2002: LD_EXP 5
2006: PUSH
2007: LD_INT 2
2009: ARRAY
2010: PUSH
2011: LD_INT 1
2013: ARRAY
2014: PPUSH
2015: LD_EXP 5
2019: PUSH
2020: LD_INT 3
2022: ARRAY
2023: PUSH
2024: LD_INT 1
2026: ARRAY
2027: PPUSH
2028: LD_EXP 5
2032: PUSH
2033: LD_INT 4
2035: ARRAY
2036: PUSH
2037: LD_INT 1
2039: ARRAY
2040: PPUSH
2041: LD_INT 30
2043: PPUSH
2044: CALL 70006 0 5
// GirlNewVeh := CreateVehicle ;
2048: LD_ADDR_EXP 57
2052: PUSH
2053: CALL_OW 45
2057: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2058: LD_EXP 57
2062: PPUSH
2063: LD_INT 4
2065: PPUSH
2066: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2070: LD_EXP 57
2074: PPUSH
2075: LD_INT 82
2077: PPUSH
2078: LD_INT 96
2080: PPUSH
2081: LD_INT 0
2083: PPUSH
2084: CALL_OW 48
// if JMMGirl = 1 then
2088: LD_EXP 7
2092: PUSH
2093: LD_INT 1
2095: EQUAL
2096: IFFALSE 2131
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2098: LD_ADDR_EXP 40
2102: PUSH
2103: LD_STRING Joan
2105: PPUSH
2106: LD_INT 1
2108: PPUSH
2109: LD_STRING 14_
2111: PPUSH
2112: CALL 65182 0 3
2116: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2117: LD_EXP 40
2121: PPUSH
2122: LD_EXP 57
2126: PPUSH
2127: CALL_OW 52
// end ; if JMMGirl = 2 then
2131: LD_EXP 7
2135: PUSH
2136: LD_INT 2
2138: EQUAL
2139: IFFALSE 2174
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2141: LD_ADDR_EXP 42
2145: PUSH
2146: LD_STRING Lisa
2148: PPUSH
2149: LD_INT 1
2151: PPUSH
2152: LD_STRING 14_
2154: PPUSH
2155: CALL 65182 0 3
2159: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2160: LD_EXP 42
2164: PPUSH
2165: LD_EXP 57
2169: PPUSH
2170: CALL_OW 52
// end ; if JMMGirl = 3 then
2174: LD_EXP 7
2178: PUSH
2179: LD_INT 3
2181: EQUAL
2182: IFFALSE 2217
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2184: LD_ADDR_EXP 54
2188: PUSH
2189: LD_STRING Connie
2191: PPUSH
2192: LD_INT 1
2194: PPUSH
2195: LD_STRING 14_
2197: PPUSH
2198: CALL 65182 0 3
2202: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2203: LD_EXP 54
2207: PPUSH
2208: LD_EXP 57
2212: PPUSH
2213: CALL_OW 52
// end ; end ; end ;
2217: LD_VAR 0 1
2221: RET
// export function PrepareStevensSquad ; var tmp ; begin
2222: LD_INT 0
2224: PPUSH
2225: PPUSH
// uc_side := 1 ;
2226: LD_ADDR_OWVAR 20
2230: PUSH
2231: LD_INT 1
2233: ST_TO_ADDR
// uc_nation := 1 ;
2234: LD_ADDR_OWVAR 21
2238: PUSH
2239: LD_INT 1
2241: ST_TO_ADDR
// tmp := [ ] ;
2242: LD_ADDR_VAR 0 2
2246: PUSH
2247: EMPTY
2248: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2249: LD_ADDR_EXP 41
2253: PUSH
2254: LD_STRING Stevens
2256: PPUSH
2257: LD_EXP 1
2261: NOT
2262: PPUSH
2263: LD_STRING 13f_
2265: PPUSH
2266: CALL 65182 0 3
2270: ST_TO_ADDR
// if not Stevens then
2271: LD_EXP 41
2275: NOT
2276: IFFALSE 2332
// begin hc_name = Baker Smith ;
2278: LD_ADDR_OWVAR 26
2282: PUSH
2283: LD_STRING Baker Smith
2285: ST_TO_ADDR
// hc_gallery =  ;
2286: LD_ADDR_OWVAR 33
2290: PUSH
2291: LD_STRING 
2293: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2294: LD_INT 1
2296: PPUSH
2297: LD_INT 10
2299: PPUSH
2300: CALL_OW 384
// Baker = CreateHuman ;
2304: LD_ADDR_EXP 55
2308: PUSH
2309: CALL_OW 44
2313: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2314: LD_ADDR_VAR 0 2
2318: PUSH
2319: LD_VAR 0 2
2323: PUSH
2324: LD_EXP 55
2328: ADD
2329: ST_TO_ADDR
// end else
2330: GO 2348
// tmp := tmp ^ Stevens ;
2332: LD_ADDR_VAR 0 2
2336: PUSH
2337: LD_VAR 0 2
2341: PUSH
2342: LD_EXP 41
2346: ADD
2347: ST_TO_ADDR
// if not Lisa then
2348: LD_EXP 42
2352: NOT
2353: IFFALSE 2399
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2355: LD_ADDR_EXP 42
2359: PUSH
2360: LD_STRING Lisa
2362: PPUSH
2363: LD_EXP 1
2367: NOT
2368: PPUSH
2369: LD_STRING 13f_
2371: PPUSH
2372: CALL 65182 0 3
2376: ST_TO_ADDR
// if Lisa then
2377: LD_EXP 42
2381: IFFALSE 2399
// tmp := tmp ^ Lisa ;
2383: LD_ADDR_VAR 0 2
2387: PUSH
2388: LD_VAR 0 2
2392: PUSH
2393: LD_EXP 42
2397: ADD
2398: ST_TO_ADDR
// end ; if not Donaldson then
2399: LD_EXP 43
2403: NOT
2404: IFFALSE 2450
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2406: LD_ADDR_EXP 43
2410: PUSH
2411: LD_STRING Donaldson
2413: PPUSH
2414: LD_EXP 1
2418: NOT
2419: PPUSH
2420: LD_STRING 13f_
2422: PPUSH
2423: CALL 65182 0 3
2427: ST_TO_ADDR
// if Donaldson then
2428: LD_EXP 43
2432: IFFALSE 2450
// tmp := tmp ^ Donaldson ;
2434: LD_ADDR_VAR 0 2
2438: PUSH
2439: LD_VAR 0 2
2443: PUSH
2444: LD_EXP 43
2448: ADD
2449: ST_TO_ADDR
// end ; if not Bobby then
2450: LD_EXP 44
2454: NOT
2455: IFFALSE 2501
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2457: LD_ADDR_EXP 44
2461: PUSH
2462: LD_STRING Bobby
2464: PPUSH
2465: LD_EXP 1
2469: NOT
2470: PPUSH
2471: LD_STRING 13f_
2473: PPUSH
2474: CALL 65182 0 3
2478: ST_TO_ADDR
// if Bobby then
2479: LD_EXP 44
2483: IFFALSE 2501
// tmp := tmp ^ Bobby ;
2485: LD_ADDR_VAR 0 2
2489: PUSH
2490: LD_VAR 0 2
2494: PUSH
2495: LD_EXP 44
2499: ADD
2500: ST_TO_ADDR
// end ; if not Cyrus then
2501: LD_EXP 45
2505: NOT
2506: IFFALSE 2552
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2508: LD_ADDR_EXP 45
2512: PUSH
2513: LD_STRING Cyrus
2515: PPUSH
2516: LD_EXP 1
2520: NOT
2521: PPUSH
2522: LD_STRING 13f_
2524: PPUSH
2525: CALL 65182 0 3
2529: ST_TO_ADDR
// if Cyrus then
2530: LD_EXP 45
2534: IFFALSE 2552
// tmp := tmp ^ Cyrus ;
2536: LD_ADDR_VAR 0 2
2540: PUSH
2541: LD_VAR 0 2
2545: PUSH
2546: LD_EXP 45
2550: ADD
2551: ST_TO_ADDR
// end ; if not Brown then
2552: LD_EXP 47
2556: NOT
2557: IFFALSE 2603
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2559: LD_ADDR_EXP 47
2563: PUSH
2564: LD_STRING Brown
2566: PPUSH
2567: LD_EXP 1
2571: NOT
2572: PPUSH
2573: LD_STRING 13f_
2575: PPUSH
2576: CALL 65182 0 3
2580: ST_TO_ADDR
// if Brown then
2581: LD_EXP 47
2585: IFFALSE 2603
// tmp := tmp ^ Brown ;
2587: LD_ADDR_VAR 0 2
2591: PUSH
2592: LD_VAR 0 2
2596: PUSH
2597: LD_EXP 47
2601: ADD
2602: ST_TO_ADDR
// end ; if not Gladstone then
2603: LD_EXP 48
2607: NOT
2608: IFFALSE 2654
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2610: LD_ADDR_EXP 48
2614: PUSH
2615: LD_STRING Gladstone
2617: PPUSH
2618: LD_EXP 1
2622: NOT
2623: PPUSH
2624: LD_STRING 13f_
2626: PPUSH
2627: CALL 65182 0 3
2631: ST_TO_ADDR
// if Gladstone then
2632: LD_EXP 48
2636: IFFALSE 2654
// tmp := tmp ^ Gladstone ;
2638: LD_ADDR_VAR 0 2
2642: PUSH
2643: LD_VAR 0 2
2647: PUSH
2648: LD_EXP 48
2652: ADD
2653: ST_TO_ADDR
// end ; if not Houten then
2654: LD_EXP 49
2658: NOT
2659: IFFALSE 2705
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2661: LD_ADDR_EXP 49
2665: PUSH
2666: LD_STRING Houten
2668: PPUSH
2669: LD_EXP 1
2673: NOT
2674: PPUSH
2675: LD_STRING 13f_
2677: PPUSH
2678: CALL 65182 0 3
2682: ST_TO_ADDR
// if Houten then
2683: LD_EXP 49
2687: IFFALSE 2705
// tmp := tmp ^ Houten ;
2689: LD_ADDR_VAR 0 2
2693: PUSH
2694: LD_VAR 0 2
2698: PUSH
2699: LD_EXP 49
2703: ADD
2704: ST_TO_ADDR
// end ; if not Cornel then
2705: LD_EXP 50
2709: NOT
2710: IFFALSE 2756
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2712: LD_ADDR_EXP 50
2716: PUSH
2717: LD_STRING Cornell
2719: PPUSH
2720: LD_EXP 1
2724: NOT
2725: PPUSH
2726: LD_STRING 13f_
2728: PPUSH
2729: CALL 65182 0 3
2733: ST_TO_ADDR
// if Cornel then
2734: LD_EXP 50
2738: IFFALSE 2756
// tmp := tmp ^ Cornel ;
2740: LD_ADDR_VAR 0 2
2744: PUSH
2745: LD_VAR 0 2
2749: PUSH
2750: LD_EXP 50
2754: ADD
2755: ST_TO_ADDR
// end ; if not Gary then
2756: LD_EXP 51
2760: NOT
2761: IFFALSE 2807
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2763: LD_ADDR_EXP 51
2767: PUSH
2768: LD_STRING Gary
2770: PPUSH
2771: LD_EXP 1
2775: NOT
2776: PPUSH
2777: LD_STRING 13f_
2779: PPUSH
2780: CALL 65182 0 3
2784: ST_TO_ADDR
// if Gary then
2785: LD_EXP 51
2789: IFFALSE 2807
// tmp := tmp ^ Gary ;
2791: LD_ADDR_VAR 0 2
2795: PUSH
2796: LD_VAR 0 2
2800: PUSH
2801: LD_EXP 51
2805: ADD
2806: ST_TO_ADDR
// end ; if not Frank then
2807: LD_EXP 52
2811: NOT
2812: IFFALSE 2858
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2814: LD_ADDR_EXP 52
2818: PUSH
2819: LD_STRING Frank
2821: PPUSH
2822: LD_EXP 1
2826: NOT
2827: PPUSH
2828: LD_STRING 13f_
2830: PPUSH
2831: CALL 65182 0 3
2835: ST_TO_ADDR
// if Frank then
2836: LD_EXP 52
2840: IFFALSE 2858
// tmp := tmp ^ Frank ;
2842: LD_ADDR_VAR 0 2
2846: PUSH
2847: LD_VAR 0 2
2851: PUSH
2852: LD_EXP 52
2856: ADD
2857: ST_TO_ADDR
// end ; if not Kikuchi then
2858: LD_EXP 53
2862: NOT
2863: IFFALSE 2909
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2865: LD_ADDR_EXP 53
2869: PUSH
2870: LD_STRING Kikuchi
2872: PPUSH
2873: LD_EXP 1
2877: NOT
2878: PPUSH
2879: LD_STRING 13f_
2881: PPUSH
2882: CALL 65182 0 3
2886: ST_TO_ADDR
// if Kikuchi then
2887: LD_EXP 53
2891: IFFALSE 2909
// tmp := tmp ^ Kikuchi ;
2893: LD_ADDR_VAR 0 2
2897: PUSH
2898: LD_VAR 0 2
2902: PUSH
2903: LD_EXP 53
2907: ADD
2908: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2909: LD_ADDR_VAR 0 2
2913: PUSH
2914: LD_VAR 0 2
2918: PUSH
2919: LD_STRING 13_other_survivors
2921: PPUSH
2922: CALL_OW 31
2926: UNION
2927: ST_TO_ADDR
// result := tmp ;
2928: LD_ADDR_VAR 0 1
2932: PUSH
2933: LD_VAR 0 2
2937: ST_TO_ADDR
// end ; end_of_file
2938: LD_VAR 0 1
2942: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2943: LD_INT 0
2945: PPUSH
2946: PPUSH
2947: PPUSH
2948: PPUSH
2949: PPUSH
2950: PPUSH
2951: PPUSH
2952: PPUSH
2953: PPUSH
2954: PPUSH
// uc_side := 4 ;
2955: LD_ADDR_OWVAR 20
2959: PUSH
2960: LD_INT 4
2962: ST_TO_ADDR
// uc_nation := 1 ;
2963: LD_ADDR_OWVAR 21
2967: PUSH
2968: LD_INT 1
2970: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 ] [ Difficulty ] ) ;
2971: LD_INT 387
2973: PPUSH
2974: CALL_OW 274
2978: PPUSH
2979: LD_INT 1
2981: PPUSH
2982: LD_INT 3500
2984: PUSH
2985: LD_INT 3000
2987: PUSH
2988: LD_INT 2500
2990: PUSH
2991: EMPTY
2992: LIST
2993: LIST
2994: LIST
2995: PUSH
2996: LD_OWVAR 67
3000: ARRAY
3001: PPUSH
3002: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3006: LD_INT 387
3008: PPUSH
3009: CALL_OW 274
3013: PPUSH
3014: LD_INT 2
3016: PPUSH
3017: LD_INT 400
3019: PPUSH
3020: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3024: LD_INT 387
3026: PPUSH
3027: CALL_OW 274
3031: PPUSH
3032: LD_INT 3
3034: PPUSH
3035: LD_INT 10
3037: PPUSH
3038: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3042: LD_ADDR_EXP 58
3046: PUSH
3047: LD_STRING Powell
3049: PPUSH
3050: CALL_OW 25
3054: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3055: LD_EXP 58
3059: PPUSH
3060: LD_INT 57
3062: PPUSH
3063: LD_INT 94
3065: PPUSH
3066: LD_INT 0
3068: PPUSH
3069: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3073: LD_EXP 58
3077: PPUSH
3078: LD_INT 58
3080: PPUSH
3081: LD_INT 94
3083: PPUSH
3084: CALL_OW 118
// vip := [ ] ;
3088: LD_ADDR_EXP 59
3092: PUSH
3093: EMPTY
3094: ST_TO_ADDR
// tmp := [ ] ;
3095: LD_ADDR_VAR 0 6
3099: PUSH
3100: EMPTY
3101: ST_TO_ADDR
// if JMMGirl <> 2 then
3102: LD_EXP 7
3106: PUSH
3107: LD_INT 2
3109: NONEQUAL
3110: IFFALSE 3134
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3112: LD_ADDR_EXP 42
3116: PUSH
3117: LD_STRING Lisa
3119: PPUSH
3120: LD_EXP 1
3124: NOT
3125: PPUSH
3126: LD_STRING 13s_
3128: PPUSH
3129: CALL 65182 0 3
3133: ST_TO_ADDR
// if Lisa then
3134: LD_EXP 42
3138: IFFALSE 3156
// tmp := tmp ^ Lisa ;
3140: LD_ADDR_VAR 0 6
3144: PUSH
3145: LD_VAR 0 6
3149: PUSH
3150: LD_EXP 42
3154: ADD
3155: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3156: LD_ADDR_EXP 43
3160: PUSH
3161: LD_STRING Donaldson
3163: PPUSH
3164: LD_EXP 1
3168: NOT
3169: PPUSH
3170: LD_STRING 13s_
3172: PPUSH
3173: CALL 65182 0 3
3177: ST_TO_ADDR
// if Donaldson then
3178: LD_EXP 43
3182: IFFALSE 3200
// tmp := tmp ^ Donaldson ;
3184: LD_ADDR_VAR 0 6
3188: PUSH
3189: LD_VAR 0 6
3193: PUSH
3194: LD_EXP 43
3198: ADD
3199: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3200: LD_ADDR_EXP 44
3204: PUSH
3205: LD_STRING Bobby
3207: PPUSH
3208: LD_EXP 1
3212: NOT
3213: PPUSH
3214: LD_STRING 13s_
3216: PPUSH
3217: CALL 65182 0 3
3221: ST_TO_ADDR
// if Bobby then
3222: LD_EXP 44
3226: IFFALSE 3244
// tmp := tmp ^ Bobby ;
3228: LD_ADDR_VAR 0 6
3232: PUSH
3233: LD_VAR 0 6
3237: PUSH
3238: LD_EXP 44
3242: ADD
3243: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3244: LD_ADDR_EXP 45
3248: PUSH
3249: LD_STRING Cyrus
3251: PPUSH
3252: LD_EXP 1
3256: NOT
3257: PPUSH
3258: LD_STRING 13s_
3260: PPUSH
3261: CALL 65182 0 3
3265: ST_TO_ADDR
// if Cyrus then
3266: LD_EXP 45
3270: IFFALSE 3288
// tmp := tmp ^ Cyrus ;
3272: LD_ADDR_VAR 0 6
3276: PUSH
3277: LD_VAR 0 6
3281: PUSH
3282: LD_EXP 45
3286: ADD
3287: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3288: LD_ADDR_EXP 46
3292: PUSH
3293: LD_STRING Denis
3295: PPUSH
3296: LD_EXP 1
3300: NOT
3301: PPUSH
3302: LD_STRING 13s_
3304: PPUSH
3305: CALL 65182 0 3
3309: ST_TO_ADDR
// if not Denis then
3310: LD_EXP 46
3314: NOT
3315: IFFALSE 3339
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3317: LD_ADDR_EXP 46
3321: PUSH
3322: LD_STRING Denis
3324: PPUSH
3325: LD_EXP 1
3329: NOT
3330: PPUSH
3331: LD_STRING 13f_
3333: PPUSH
3334: CALL 65182 0 3
3338: ST_TO_ADDR
// if Denis then
3339: LD_EXP 46
3343: IFFALSE 3361
// tmp := tmp ^ Denis ;
3345: LD_ADDR_VAR 0 6
3349: PUSH
3350: LD_VAR 0 6
3354: PUSH
3355: LD_EXP 46
3359: ADD
3360: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3361: LD_ADDR_EXP 47
3365: PUSH
3366: LD_STRING Brown
3368: PPUSH
3369: LD_EXP 1
3373: NOT
3374: PPUSH
3375: LD_STRING 13s_
3377: PPUSH
3378: CALL 65182 0 3
3382: ST_TO_ADDR
// if Brown then
3383: LD_EXP 47
3387: IFFALSE 3405
// tmp := tmp ^ Brown ;
3389: LD_ADDR_VAR 0 6
3393: PUSH
3394: LD_VAR 0 6
3398: PUSH
3399: LD_EXP 47
3403: ADD
3404: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3405: LD_ADDR_EXP 48
3409: PUSH
3410: LD_STRING Gladstone
3412: PPUSH
3413: LD_EXP 1
3417: NOT
3418: PPUSH
3419: LD_STRING 13s_
3421: PPUSH
3422: CALL 65182 0 3
3426: ST_TO_ADDR
// if Gladstone then
3427: LD_EXP 48
3431: IFFALSE 3449
// tmp := tmp ^ Gladstone ;
3433: LD_ADDR_VAR 0 6
3437: PUSH
3438: LD_VAR 0 6
3442: PUSH
3443: LD_EXP 48
3447: ADD
3448: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3449: LD_ADDR_EXP 49
3453: PUSH
3454: LD_STRING Houten
3456: PPUSH
3457: LD_EXP 1
3461: NOT
3462: PPUSH
3463: LD_STRING 13s_
3465: PPUSH
3466: CALL 65182 0 3
3470: ST_TO_ADDR
// if Houten then
3471: LD_EXP 49
3475: IFFALSE 3493
// tmp := tmp ^ Houten ;
3477: LD_ADDR_VAR 0 6
3481: PUSH
3482: LD_VAR 0 6
3486: PUSH
3487: LD_EXP 49
3491: ADD
3492: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3493: LD_ADDR_EXP 50
3497: PUSH
3498: LD_STRING Cornel
3500: PPUSH
3501: LD_EXP 1
3505: NOT
3506: PPUSH
3507: LD_STRING 13s_
3509: PPUSH
3510: CALL 65182 0 3
3514: ST_TO_ADDR
// if Cornel then
3515: LD_EXP 50
3519: IFFALSE 3537
// tmp := tmp ^ Cornel ;
3521: LD_ADDR_VAR 0 6
3525: PUSH
3526: LD_VAR 0 6
3530: PUSH
3531: LD_EXP 50
3535: ADD
3536: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3537: LD_ADDR_EXP 51
3541: PUSH
3542: LD_STRING Gary
3544: PPUSH
3545: LD_EXP 1
3549: NOT
3550: PPUSH
3551: LD_STRING 13s_
3553: PPUSH
3554: CALL 65182 0 3
3558: ST_TO_ADDR
// if Gary then
3559: LD_EXP 51
3563: IFFALSE 3581
// tmp := tmp ^ Gary ;
3565: LD_ADDR_VAR 0 6
3569: PUSH
3570: LD_VAR 0 6
3574: PUSH
3575: LD_EXP 51
3579: ADD
3580: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3581: LD_ADDR_EXP 52
3585: PUSH
3586: LD_STRING Frank
3588: PPUSH
3589: LD_EXP 1
3593: NOT
3594: PPUSH
3595: LD_STRING 13s_
3597: PPUSH
3598: CALL 65182 0 3
3602: ST_TO_ADDR
// if Frank then
3603: LD_EXP 52
3607: IFFALSE 3625
// tmp := tmp ^ Frank ;
3609: LD_ADDR_VAR 0 6
3613: PUSH
3614: LD_VAR 0 6
3618: PUSH
3619: LD_EXP 52
3623: ADD
3624: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3625: LD_ADDR_EXP 53
3629: PUSH
3630: LD_STRING Kikuchi
3632: PPUSH
3633: LD_EXP 1
3637: NOT
3638: PPUSH
3639: LD_STRING 13s_
3641: PPUSH
3642: CALL 65182 0 3
3646: ST_TO_ADDR
// if Kikuchi then
3647: LD_EXP 53
3651: IFFALSE 3669
// tmp := tmp ^ Kikuchi ;
3653: LD_ADDR_VAR 0 6
3657: PUSH
3658: LD_VAR 0 6
3662: PUSH
3663: LD_EXP 53
3667: ADD
3668: ST_TO_ADDR
// vip := tmp ;
3669: LD_ADDR_EXP 59
3673: PUSH
3674: LD_VAR 0 6
3678: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3679: LD_ADDR_VAR 0 6
3683: PUSH
3684: LD_VAR 0 6
3688: PUSH
3689: LD_STRING 13s_others
3691: PPUSH
3692: CALL_OW 31
3696: UNION
3697: ST_TO_ADDR
// if tmp < 18 then
3698: LD_VAR 0 6
3702: PUSH
3703: LD_INT 18
3705: LESS
3706: IFFALSE 3773
// for i = 1 to 18 - tmp do
3708: LD_ADDR_VAR 0 2
3712: PUSH
3713: DOUBLE
3714: LD_INT 1
3716: DEC
3717: ST_TO_ADDR
3718: LD_INT 18
3720: PUSH
3721: LD_VAR 0 6
3725: MINUS
3726: PUSH
3727: FOR_TO
3728: IFFALSE 3771
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3730: LD_INT 1
3732: PPUSH
3733: LD_VAR 0 2
3737: PUSH
3738: LD_INT 4
3740: MOD
3741: PUSH
3742: LD_INT 1
3744: PLUS
3745: PPUSH
3746: LD_INT 5
3748: PPUSH
3749: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3753: LD_ADDR_VAR 0 6
3757: PUSH
3758: LD_VAR 0 6
3762: PUSH
3763: CALL_OW 44
3767: ADD
3768: ST_TO_ADDR
// end ;
3769: GO 3727
3771: POP
3772: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3773: LD_ADDR_VAR 0 7
3777: PUSH
3778: LD_INT 22
3780: PUSH
3781: LD_INT 4
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: PUSH
3788: LD_INT 30
3790: PUSH
3791: LD_INT 0
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: PUSH
3798: EMPTY
3799: LIST
3800: LIST
3801: PPUSH
3802: CALL_OW 69
3806: PUSH
3807: LD_INT 1
3809: ARRAY
3810: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3811: LD_ADDR_VAR 0 8
3815: PUSH
3816: LD_INT 22
3818: PUSH
3819: LD_INT 4
3821: PUSH
3822: EMPTY
3823: LIST
3824: LIST
3825: PUSH
3826: LD_INT 30
3828: PUSH
3829: LD_INT 6
3831: PUSH
3832: EMPTY
3833: LIST
3834: LIST
3835: PUSH
3836: EMPTY
3837: LIST
3838: LIST
3839: PPUSH
3840: CALL_OW 69
3844: PUSH
3845: LD_INT 1
3847: ARRAY
3848: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3849: LD_ADDR_VAR 0 9
3853: PUSH
3854: LD_INT 22
3856: PUSH
3857: LD_INT 4
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: PUSH
3864: LD_INT 30
3866: PUSH
3867: LD_INT 4
3869: PUSH
3870: EMPTY
3871: LIST
3872: LIST
3873: PUSH
3874: EMPTY
3875: LIST
3876: LIST
3877: PPUSH
3878: CALL_OW 69
3882: PUSH
3883: LD_INT 1
3885: ARRAY
3886: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3887: LD_ADDR_VAR 0 10
3891: PUSH
3892: LD_INT 22
3894: PUSH
3895: LD_INT 4
3897: PUSH
3898: EMPTY
3899: LIST
3900: LIST
3901: PUSH
3902: LD_INT 30
3904: PUSH
3905: LD_INT 2
3907: PUSH
3908: EMPTY
3909: LIST
3910: LIST
3911: PUSH
3912: EMPTY
3913: LIST
3914: LIST
3915: PPUSH
3916: CALL_OW 69
3920: PUSH
3921: LD_INT 1
3923: ARRAY
3924: ST_TO_ADDR
// for i in tmp do
3925: LD_ADDR_VAR 0 2
3929: PUSH
3930: LD_VAR 0 6
3934: PUSH
3935: FOR_IN
3936: IFFALSE 4062
// begin cl := GetClass ( i ) ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_VAR 0 2
3947: PPUSH
3948: CALL_OW 257
3952: ST_TO_ADDR
// if cl > 4 then
3953: LD_VAR 0 5
3957: PUSH
3958: LD_INT 4
3960: GREATER
3961: IFFALSE 3971
// cl := 1 ;
3963: LD_ADDR_VAR 0 5
3967: PUSH
3968: LD_INT 1
3970: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3971: LD_ADDR_VAR 0 3
3975: PUSH
3976: LD_VAR 0 9
3980: PUSH
3981: LD_VAR 0 7
3985: PUSH
3986: LD_VAR 0 10
3990: PUSH
3991: LD_VAR 0 8
3995: PUSH
3996: EMPTY
3997: LIST
3998: LIST
3999: LIST
4000: LIST
4001: PUSH
4002: LD_VAR 0 5
4006: ARRAY
4007: ST_TO_ADDR
// if UnitsInside ( b ) < 6 then
4008: LD_VAR 0 3
4012: PPUSH
4013: CALL_OW 313
4017: PUSH
4018: LD_INT 6
4020: LESS
4021: IFFALSE 4039
// PlaceHumanInUnit ( i , b ) else
4023: LD_VAR 0 2
4027: PPUSH
4028: LD_VAR 0 3
4032: PPUSH
4033: CALL_OW 52
4037: GO 4060
// PlaceUnitXYR ( i , 61 , 89 , 6 , false ) ;
4039: LD_VAR 0 2
4043: PPUSH
4044: LD_INT 61
4046: PPUSH
4047: LD_INT 89
4049: PPUSH
4050: LD_INT 6
4052: PPUSH
4053: LD_INT 0
4055: PPUSH
4056: CALL_OW 50
// end ;
4060: GO 3935
4062: POP
4063: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4064: LD_INT 2
4066: PPUSH
4067: LD_INT 1
4069: PPUSH
4070: LD_INT 1
4072: PPUSH
4073: LD_INT 12
4075: PPUSH
4076: LD_INT 100
4078: PPUSH
4079: CALL 70006 0 5
// veh := CreateVehicle ;
4083: LD_ADDR_VAR 0 4
4087: PUSH
4088: CALL_OW 45
4092: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4093: LD_VAR 0 4
4097: PPUSH
4098: LD_INT 4
4100: PPUSH
4101: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4105: LD_VAR 0 4
4109: PPUSH
4110: LD_INT 49
4112: PPUSH
4113: LD_INT 88
4115: PPUSH
4116: LD_INT 0
4118: PPUSH
4119: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4123: LD_VAR 0 4
4127: PPUSH
4128: LD_INT 1
4130: PPUSH
4131: LD_INT 100
4133: PPUSH
4134: CALL_OW 290
// uc_side := 0 ;
4138: LD_ADDR_OWVAR 20
4142: PUSH
4143: LD_INT 0
4145: ST_TO_ADDR
// uc_nation := 0 ;
4146: LD_ADDR_OWVAR 21
4150: PUSH
4151: LD_INT 0
4153: ST_TO_ADDR
// for i = 1 to 4 do
4154: LD_ADDR_VAR 0 2
4158: PUSH
4159: DOUBLE
4160: LD_INT 1
4162: DEC
4163: ST_TO_ADDR
4164: LD_INT 4
4166: PUSH
4167: FOR_TO
4168: IFFALSE 4199
// begin InitHc ;
4170: CALL_OW 19
// hc_class := class_apeman ;
4174: LD_ADDR_OWVAR 28
4178: PUSH
4179: LD_INT 12
4181: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4182: CALL_OW 44
4186: PPUSH
4187: LD_INT 13
4189: PPUSH
4190: LD_INT 0
4192: PPUSH
4193: CALL_OW 49
// end ;
4197: GO 4167
4199: POP
4200: POP
// end ; end_of_file
4201: LD_VAR 0 1
4205: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4206: LD_INT 0
4208: PPUSH
4209: PPUSH
4210: PPUSH
4211: PPUSH
4212: PPUSH
// side := 8 ;
4213: LD_ADDR_VAR 0 3
4217: PUSH
4218: LD_INT 8
4220: ST_TO_ADDR
// uc_side := side ;
4221: LD_ADDR_OWVAR 20
4225: PUSH
4226: LD_VAR 0 3
4230: ST_TO_ADDR
// uc_nation := 2 ;
4231: LD_ADDR_OWVAR 21
4235: PUSH
4236: LD_INT 2
4238: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4239: LD_ADDR_VAR 0 2
4243: PUSH
4244: LD_INT 22
4246: PUSH
4247: LD_VAR 0 3
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: PUSH
4256: LD_INT 21
4258: PUSH
4259: LD_INT 3
4261: PUSH
4262: EMPTY
4263: LIST
4264: LIST
4265: PUSH
4266: EMPTY
4267: LIST
4268: LIST
4269: PPUSH
4270: CALL_OW 69
4274: PUSH
4275: FOR_IN
4276: IFFALSE 4292
// SetBLevel ( i , 10 ) ;
4278: LD_VAR 0 2
4282: PPUSH
4283: LD_INT 10
4285: PPUSH
4286: CALL_OW 241
4290: GO 4275
4292: POP
4293: POP
// if KurtStatus then
4294: LD_EXP 3
4298: IFFALSE 4321
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4300: LD_ADDR_EXP 60
4304: PUSH
4305: LD_STRING Kurt
4307: PPUSH
4308: LD_INT 0
4310: PPUSH
4311: LD_STRING 
4313: PPUSH
4314: CALL 65182 0 3
4318: ST_TO_ADDR
4319: GO 4343
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4321: LD_ADDR_EXP 60
4325: PUSH
4326: LD_STRING AltKurt
4328: PPUSH
4329: LD_EXP 1
4333: NOT
4334: PPUSH
4335: LD_STRING 
4337: PPUSH
4338: CALL 65182 0 3
4342: ST_TO_ADDR
// if not Kurt then
4343: LD_EXP 60
4347: NOT
4348: IFFALSE 4374
// begin InitHc ;
4350: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4354: LD_INT 1
4356: PPUSH
4357: LD_INT 10
4359: PPUSH
4360: CALL_OW 381
// Kurt := CreateHuman ;
4364: LD_ADDR_EXP 60
4368: PUSH
4369: CALL_OW 44
4373: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4374: LD_EXP 60
4378: PPUSH
4379: LD_INT 324
4381: PPUSH
4382: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4386: LD_ADDR_EXP 61
4390: PUSH
4391: LD_STRING Kozlov
4393: PPUSH
4394: LD_INT 0
4396: PPUSH
4397: LD_STRING 
4399: PPUSH
4400: CALL 65182 0 3
4404: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4405: LD_EXP 61
4409: PPUSH
4410: LD_INT 22
4412: PUSH
4413: LD_INT 8
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: PUSH
4420: LD_INT 23
4422: PUSH
4423: LD_INT 3
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: LD_INT 30
4432: PUSH
4433: LD_INT 8
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: LIST
4444: PPUSH
4445: CALL_OW 69
4449: PUSH
4450: LD_INT 1
4452: ARRAY
4453: PPUSH
4454: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4458: LD_EXP 61
4462: PPUSH
4463: LD_INT 3
4465: PPUSH
4466: LD_INT 10
4468: PPUSH
4469: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4473: LD_EXP 61
4477: PPUSH
4478: LD_INT 4
4480: PPUSH
4481: LD_INT 10
4483: PPUSH
4484: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4488: LD_ADDR_VAR 0 5
4492: PUSH
4493: LD_INT 22
4495: PUSH
4496: LD_VAR 0 3
4500: PUSH
4501: EMPTY
4502: LIST
4503: LIST
4504: PUSH
4505: LD_INT 30
4507: PUSH
4508: LD_INT 32
4510: PUSH
4511: EMPTY
4512: LIST
4513: LIST
4514: PUSH
4515: LD_INT 58
4517: PUSH
4518: EMPTY
4519: LIST
4520: PUSH
4521: EMPTY
4522: LIST
4523: LIST
4524: LIST
4525: PPUSH
4526: CALL_OW 69
4530: ST_TO_ADDR
// for i = 1 to 10 do
4531: LD_ADDR_VAR 0 2
4535: PUSH
4536: DOUBLE
4537: LD_INT 1
4539: DEC
4540: ST_TO_ADDR
4541: LD_INT 10
4543: PUSH
4544: FOR_TO
4545: IFFALSE 4617
// begin uc_nation := nation_nature ;
4547: LD_ADDR_OWVAR 21
4551: PUSH
4552: LD_INT 0
4554: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4555: LD_ADDR_OWVAR 28
4559: PUSH
4560: LD_INT 15
4562: ST_TO_ADDR
// hc_gallery :=  ;
4563: LD_ADDR_OWVAR 33
4567: PUSH
4568: LD_STRING 
4570: ST_TO_ADDR
// hc_name :=  ;
4571: LD_ADDR_OWVAR 26
4575: PUSH
4576: LD_STRING 
4578: ST_TO_ADDR
// un := CreateHuman ;
4579: LD_ADDR_VAR 0 4
4583: PUSH
4584: CALL_OW 44
4588: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4589: LD_VAR 0 4
4593: PPUSH
4594: LD_VAR 0 5
4598: PUSH
4599: LD_VAR 0 5
4603: PUSH
4604: LD_VAR 0 2
4608: MINUS
4609: ARRAY
4610: PPUSH
4611: CALL_OW 52
// end ;
4615: GO 4544
4617: POP
4618: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4619: LD_ADDR_VAR 0 5
4623: PUSH
4624: LD_STRING 12_kurt_squad
4626: PPUSH
4627: CALL_OW 31
4631: ST_TO_ADDR
// if tmp then
4632: LD_VAR 0 5
4636: IFFALSE 4670
// for i in tmp do
4638: LD_ADDR_VAR 0 2
4642: PUSH
4643: LD_VAR 0 5
4647: PUSH
4648: FOR_IN
4649: IFFALSE 4668
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4651: LD_VAR 0 2
4655: PPUSH
4656: LD_INT 5
4658: PPUSH
4659: LD_INT 0
4661: PPUSH
4662: CALL_OW 49
4666: GO 4648
4668: POP
4669: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4670: LD_INT 324
4672: PPUSH
4673: LD_INT 5
4675: PPUSH
4676: LD_STRING 
4678: PPUSH
4679: LD_INT 8
4681: PUSH
4682: LD_INT 9
4684: PUSH
4685: LD_INT 10
4687: PUSH
4688: EMPTY
4689: LIST
4690: LIST
4691: LIST
4692: PUSH
4693: LD_OWVAR 67
4697: ARRAY
4698: PPUSH
4699: LD_INT 3000
4701: PUSH
4702: LD_INT 500
4704: PUSH
4705: LD_INT 150
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: LIST
4712: PPUSH
4713: LD_INT 16
4715: PUSH
4716: LD_INT 6
4718: PUSH
4719: LD_INT 6
4721: PUSH
4722: LD_INT 8
4724: PUSH
4725: EMPTY
4726: LIST
4727: LIST
4728: LIST
4729: LIST
4730: PPUSH
4731: CALL 73415 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4735: LD_ADDR_EXP 113
4739: PUSH
4740: LD_EXP 113
4744: PPUSH
4745: LD_INT 3
4747: PPUSH
4748: LD_INT 22
4750: PUSH
4751: LD_VAR 0 3
4755: PUSH
4756: EMPTY
4757: LIST
4758: LIST
4759: PUSH
4760: LD_INT 23
4762: PUSH
4763: LD_INT 2
4765: PUSH
4766: EMPTY
4767: LIST
4768: LIST
4769: PUSH
4770: LD_INT 3
4772: PUSH
4773: LD_INT 21
4775: PUSH
4776: LD_INT 2
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: PUSH
4783: EMPTY
4784: LIST
4785: LIST
4786: PUSH
4787: EMPTY
4788: LIST
4789: LIST
4790: LIST
4791: PPUSH
4792: CALL_OW 69
4796: PUSH
4797: LD_EXP 60
4801: DIFF
4802: PPUSH
4803: CALL_OW 1
4807: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4808: LD_INT 1
4810: PPUSH
4811: LD_INT 7
4813: PPUSH
4814: CALL_OW 383
// Friend := CreateHuman ;
4818: LD_ADDR_EXP 62
4822: PUSH
4823: CALL_OW 44
4827: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4828: LD_INT 14
4830: PPUSH
4831: LD_INT 3
4833: PPUSH
4834: LD_INT 1
4836: PPUSH
4837: LD_INT 29
4839: PPUSH
4840: LD_INT 100
4842: PPUSH
4843: CALL 70006 0 5
// powellBomb := CreateVehicle ;
4847: LD_ADDR_EXP 63
4851: PUSH
4852: CALL_OW 45
4856: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4857: LD_EXP 63
4861: PPUSH
4862: LD_INT 90
4864: PPUSH
4865: LD_INT 51
4867: PPUSH
4868: LD_INT 0
4870: PPUSH
4871: CALL_OW 48
// end ;
4875: LD_VAR 0 1
4879: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4880: LD_INT 0
4882: PPUSH
4883: PPUSH
4884: PPUSH
// if IsLive ( kozlov_fac ) then
4885: LD_INT 332
4887: PPUSH
4888: CALL_OW 300
4892: IFFALSE 4896
// exit ;
4894: GO 5463
// ComExitBuilding ( Kozlov ) ;
4896: LD_EXP 61
4900: PPUSH
4901: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4905: LD_EXP 61
4909: PPUSH
4910: CALL_OW 257
4914: PUSH
4915: LD_INT 2
4917: NONEQUAL
4918: IFFALSE 4953
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4920: LD_EXP 61
4924: PPUSH
4925: LD_INT 324
4927: PPUSH
4928: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4932: LD_EXP 61
4936: PPUSH
4937: LD_INT 2
4939: PPUSH
4940: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4944: LD_EXP 61
4948: PPUSH
4949: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4953: LD_EXP 61
4957: PPUSH
4958: LD_INT 2
4960: PPUSH
4961: LD_INT 93
4963: PPUSH
4964: LD_INT 32
4966: PPUSH
4967: LD_INT 3
4969: PPUSH
4970: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4974: LD_INT 35
4976: PPUSH
4977: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4981: LD_INT 22
4983: PUSH
4984: LD_INT 8
4986: PUSH
4987: EMPTY
4988: LIST
4989: LIST
4990: PUSH
4991: LD_INT 30
4993: PUSH
4994: LD_INT 3
4996: PUSH
4997: EMPTY
4998: LIST
4999: LIST
5000: PUSH
5001: LD_INT 23
5003: PUSH
5004: LD_INT 3
5006: PUSH
5007: EMPTY
5008: LIST
5009: LIST
5010: PUSH
5011: LD_INT 57
5013: PUSH
5014: EMPTY
5015: LIST
5016: PUSH
5017: EMPTY
5018: LIST
5019: LIST
5020: LIST
5021: LIST
5022: PPUSH
5023: CALL_OW 69
5027: IFFALSE 4974
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5029: LD_ADDR_VAR 0 2
5033: PUSH
5034: LD_INT 22
5036: PUSH
5037: LD_INT 8
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: PUSH
5044: LD_INT 30
5046: PUSH
5047: LD_INT 3
5049: PUSH
5050: EMPTY
5051: LIST
5052: LIST
5053: PUSH
5054: LD_INT 23
5056: PUSH
5057: LD_INT 3
5059: PUSH
5060: EMPTY
5061: LIST
5062: LIST
5063: PUSH
5064: LD_INT 57
5066: PUSH
5067: EMPTY
5068: LIST
5069: PUSH
5070: EMPTY
5071: LIST
5072: LIST
5073: LIST
5074: LIST
5075: PPUSH
5076: CALL_OW 69
5080: PUSH
5081: LD_INT 1
5083: ARRAY
5084: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5085: LD_INT 22
5087: PUSH
5088: LD_INT 8
5090: PUSH
5091: EMPTY
5092: LIST
5093: LIST
5094: PUSH
5095: LD_INT 23
5097: PUSH
5098: LD_INT 3
5100: PUSH
5101: EMPTY
5102: LIST
5103: LIST
5104: PUSH
5105: LD_INT 30
5107: PUSH
5108: LD_INT 21
5110: PUSH
5111: EMPTY
5112: LIST
5113: LIST
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: LIST
5119: PPUSH
5120: CALL_OW 69
5124: NOT
5125: IFFALSE 5203
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5127: LD_EXP 61
5131: PPUSH
5132: LD_INT 21
5134: PPUSH
5135: LD_INT 97
5137: PPUSH
5138: LD_INT 36
5140: PPUSH
5141: LD_INT 5
5143: PPUSH
5144: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5148: LD_INT 35
5150: PPUSH
5151: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5155: LD_INT 22
5157: PUSH
5158: LD_INT 8
5160: PUSH
5161: EMPTY
5162: LIST
5163: LIST
5164: PUSH
5165: LD_INT 23
5167: PUSH
5168: LD_INT 3
5170: PUSH
5171: EMPTY
5172: LIST
5173: LIST
5174: PUSH
5175: LD_INT 30
5177: PUSH
5178: LD_INT 21
5180: PUSH
5181: EMPTY
5182: LIST
5183: LIST
5184: PUSH
5185: LD_INT 57
5187: PUSH
5188: EMPTY
5189: LIST
5190: PUSH
5191: EMPTY
5192: LIST
5193: LIST
5194: LIST
5195: LIST
5196: PPUSH
5197: CALL_OW 69
5201: IFFALSE 5148
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5203: LD_INT 22
5205: PUSH
5206: LD_INT 8
5208: PUSH
5209: EMPTY
5210: LIST
5211: LIST
5212: PUSH
5213: LD_INT 23
5215: PUSH
5216: LD_INT 3
5218: PUSH
5219: EMPTY
5220: LIST
5221: LIST
5222: PUSH
5223: LD_INT 30
5225: PUSH
5226: LD_INT 18
5228: PUSH
5229: EMPTY
5230: LIST
5231: LIST
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: LIST
5237: PPUSH
5238: CALL_OW 69
5242: NOT
5243: IFFALSE 5321
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5245: LD_EXP 61
5249: PPUSH
5250: LD_INT 18
5252: PPUSH
5253: LD_INT 89
5255: PPUSH
5256: LD_INT 32
5258: PPUSH
5259: LD_INT 1
5261: PPUSH
5262: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5266: LD_INT 35
5268: PPUSH
5269: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5273: LD_INT 22
5275: PUSH
5276: LD_INT 8
5278: PUSH
5279: EMPTY
5280: LIST
5281: LIST
5282: PUSH
5283: LD_INT 23
5285: PUSH
5286: LD_INT 3
5288: PUSH
5289: EMPTY
5290: LIST
5291: LIST
5292: PUSH
5293: LD_INT 30
5295: PUSH
5296: LD_INT 18
5298: PUSH
5299: EMPTY
5300: LIST
5301: LIST
5302: PUSH
5303: LD_INT 57
5305: PUSH
5306: EMPTY
5307: LIST
5308: PUSH
5309: EMPTY
5310: LIST
5311: LIST
5312: LIST
5313: LIST
5314: PPUSH
5315: CALL_OW 69
5319: IFFALSE 5266
// end ; lab := kozlov_lab ;
5321: LD_ADDR_VAR 0 3
5325: PUSH
5326: LD_INT 336
5328: ST_TO_ADDR
// if not lab then
5329: LD_VAR 0 3
5333: NOT
5334: IFFALSE 5338
// exit ;
5336: GO 5463
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5338: LD_EXP 61
5342: PPUSH
5343: LD_VAR 0 3
5347: PUSH
5348: LD_INT 1
5350: ARRAY
5351: PPUSH
5352: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5356: LD_EXP 61
5360: PPUSH
5361: LD_INT 4
5363: PPUSH
5364: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5368: LD_VAR 0 3
5372: PUSH
5373: LD_INT 1
5375: ARRAY
5376: PPUSH
5377: LD_INT 25
5379: PPUSH
5380: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5384: LD_INT 35
5386: PPUSH
5387: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5391: LD_INT 25
5393: PPUSH
5394: LD_INT 8
5396: PPUSH
5397: CALL_OW 321
5401: PUSH
5402: LD_INT 2
5404: EQUAL
5405: IFFALSE 5384
// ComExitBuilding ( Kozlov ) ;
5407: LD_EXP 61
5411: PPUSH
5412: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5416: LD_EXP 61
5420: PPUSH
5421: LD_VAR 0 2
5425: PPUSH
5426: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5430: LD_EXP 61
5434: PPUSH
5435: LD_INT 3
5437: PPUSH
5438: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5442: LD_VAR 0 2
5446: PPUSH
5447: LD_INT 23
5449: PPUSH
5450: LD_INT 3
5452: PPUSH
5453: LD_INT 1
5455: PPUSH
5456: LD_INT 48
5458: PPUSH
5459: CALL_OW 125
// end ;
5463: LD_VAR 0 1
5467: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5468: LD_EXP 22
5472: NOT
5473: PUSH
5474: LD_EXP 15
5478: PUSH
5479: LD_INT 6
5481: GREATEREQUAL
5482: AND
5483: IFFALSE 5564
5485: GO 5487
5487: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5488: LD_INT 3
5490: PPUSH
5491: LD_INT 3
5493: PPUSH
5494: CALL 58956 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5498: LD_INT 3
5500: PPUSH
5501: LD_INT 14
5503: PUSH
5504: LD_INT 1
5506: PUSH
5507: LD_INT 1
5509: PUSH
5510: LD_INT 28
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: LIST
5517: LIST
5518: PUSH
5519: LD_INT 14
5521: PUSH
5522: LD_INT 1
5524: PUSH
5525: LD_INT 1
5527: PUSH
5528: LD_INT 28
5530: PUSH
5531: EMPTY
5532: LIST
5533: LIST
5534: LIST
5535: LIST
5536: PUSH
5537: LD_INT 14
5539: PUSH
5540: LD_INT 1
5542: PUSH
5543: LD_INT 1
5545: PUSH
5546: LD_INT 28
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: LIST
5553: LIST
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: LIST
5559: PPUSH
5560: CALL 58819 0 2
// end ;
5564: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5565: LD_EXP 22
5569: NOT
5570: PUSH
5571: LD_EXP 15
5575: PUSH
5576: LD_INT 6
5578: GREATEREQUAL
5579: AND
5580: PUSH
5581: LD_INT 3
5583: PPUSH
5584: LD_INT 1
5586: PPUSH
5587: CALL 60237 0 2
5591: NOT
5592: AND
5593: IFFALSE 6433
5595: GO 5597
5597: DISABLE
5598: LD_INT 0
5600: PPUSH
5601: PPUSH
5602: PPUSH
// begin enable ;
5603: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5604: LD_INT 22
5606: PUSH
5607: LD_INT 8
5609: PUSH
5610: EMPTY
5611: LIST
5612: LIST
5613: PUSH
5614: LD_INT 23
5616: PUSH
5617: LD_INT 2
5619: PUSH
5620: EMPTY
5621: LIST
5622: LIST
5623: PUSH
5624: LD_INT 30
5626: PUSH
5627: LD_INT 3
5629: PUSH
5630: EMPTY
5631: LIST
5632: LIST
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: LIST
5638: PPUSH
5639: CALL_OW 69
5643: NOT
5644: IFFALSE 5648
// exit ;
5646: GO 6433
// if Prob ( 40 ) then
5648: LD_INT 40
5650: PPUSH
5651: CALL_OW 13
5655: IFFALSE 5782
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5657: LD_INT 3
5659: PPUSH
5660: LD_INT 14
5662: PUSH
5663: LD_INT 1
5665: PUSH
5666: LD_INT 2
5668: PUSH
5669: LD_INT 28
5671: PUSH
5672: EMPTY
5673: LIST
5674: LIST
5675: LIST
5676: LIST
5677: PUSH
5678: LD_INT 14
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: LD_INT 2
5686: PUSH
5687: LD_INT 28
5689: PUSH
5690: EMPTY
5691: LIST
5692: LIST
5693: LIST
5694: LIST
5695: PUSH
5696: LD_INT 14
5698: PUSH
5699: LD_INT 1
5701: PUSH
5702: LD_INT 2
5704: PUSH
5705: LD_INT 28
5707: PUSH
5708: EMPTY
5709: LIST
5710: LIST
5711: LIST
5712: LIST
5713: PUSH
5714: LD_INT 14
5716: PUSH
5717: LD_INT 1
5719: PUSH
5720: LD_INT 2
5722: PUSH
5723: LD_INT 28
5725: PUSH
5726: EMPTY
5727: LIST
5728: LIST
5729: LIST
5730: LIST
5731: PUSH
5732: LD_INT 14
5734: PUSH
5735: LD_INT 1
5737: PUSH
5738: LD_INT 2
5740: PUSH
5741: LD_INT 28
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: LIST
5748: LIST
5749: PUSH
5750: LD_INT 14
5752: PUSH
5753: LD_INT 1
5755: PUSH
5756: LD_INT 2
5758: PUSH
5759: LD_INT 26
5761: PUSH
5762: EMPTY
5763: LIST
5764: LIST
5765: LIST
5766: LIST
5767: PUSH
5768: EMPTY
5769: LIST
5770: LIST
5771: LIST
5772: LIST
5773: LIST
5774: LIST
5775: PPUSH
5776: CALL 58819 0 2
// end else
5780: GO 5973
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5782: LD_INT 3
5784: PPUSH
5785: LD_INT 14
5787: PUSH
5788: LD_INT 1
5790: PUSH
5791: LD_INT 2
5793: PUSH
5794: LD_INT 27
5796: PUSH
5797: LD_INT 26
5799: PUSH
5800: LD_INT 26
5802: PUSH
5803: EMPTY
5804: LIST
5805: LIST
5806: LIST
5807: PUSH
5808: LD_OWVAR 67
5812: ARRAY
5813: PUSH
5814: EMPTY
5815: LIST
5816: LIST
5817: LIST
5818: LIST
5819: PUSH
5820: LD_INT 14
5822: PUSH
5823: LD_INT 1
5825: PUSH
5826: LD_INT 2
5828: PUSH
5829: LD_INT 27
5831: PUSH
5832: LD_INT 26
5834: PUSH
5835: LD_INT 26
5837: PUSH
5838: EMPTY
5839: LIST
5840: LIST
5841: LIST
5842: PUSH
5843: LD_OWVAR 67
5847: ARRAY
5848: PUSH
5849: EMPTY
5850: LIST
5851: LIST
5852: LIST
5853: LIST
5854: PUSH
5855: LD_INT 14
5857: PUSH
5858: LD_INT 1
5860: PUSH
5861: LD_INT 2
5863: PUSH
5864: LD_INT 26
5866: PUSH
5867: LD_INT 26
5869: PUSH
5870: LD_INT 29
5872: PUSH
5873: EMPTY
5874: LIST
5875: LIST
5876: LIST
5877: PUSH
5878: LD_OWVAR 67
5882: ARRAY
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: LIST
5888: LIST
5889: PUSH
5890: LD_INT 13
5892: PUSH
5893: LD_INT 1
5895: PUSH
5896: LD_INT 2
5898: PUSH
5899: LD_INT 26
5901: PUSH
5902: LD_INT 29
5904: PUSH
5905: LD_INT 29
5907: PUSH
5908: EMPTY
5909: LIST
5910: LIST
5911: LIST
5912: PUSH
5913: LD_OWVAR 67
5917: ARRAY
5918: PUSH
5919: EMPTY
5920: LIST
5921: LIST
5922: LIST
5923: LIST
5924: PUSH
5925: LD_INT 13
5927: PUSH
5928: LD_INT 1
5930: PUSH
5931: LD_INT 2
5933: PUSH
5934: LD_INT 29
5936: PUSH
5937: EMPTY
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: PUSH
5943: LD_INT 14
5945: PUSH
5946: LD_INT 1
5948: PUSH
5949: LD_INT 2
5951: PUSH
5952: LD_INT 26
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: PUSH
5961: EMPTY
5962: LIST
5963: LIST
5964: LIST
5965: LIST
5966: LIST
5967: LIST
5968: PPUSH
5969: CALL 58819 0 2
// end ; repeat wait ( 0 0$1 ) ;
5973: LD_INT 35
5975: PPUSH
5976: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5980: LD_INT 3
5982: PPUSH
5983: LD_INT 1
5985: PPUSH
5986: CALL 60237 0 2
5990: PUSH
5991: LD_INT 6
5993: GREATEREQUAL
5994: IFFALSE 5973
// wait ( 0 0$30 ) ;
5996: LD_INT 1050
5998: PPUSH
5999: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6003: LD_ADDR_VAR 0 2
6007: PUSH
6008: LD_INT 3
6010: PPUSH
6011: LD_INT 1
6013: PPUSH
6014: CALL 60237 0 2
6018: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6019: LD_ADDR_EXP 132
6023: PUSH
6024: LD_EXP 132
6028: PPUSH
6029: LD_INT 3
6031: PPUSH
6032: LD_EXP 132
6036: PUSH
6037: LD_INT 3
6039: ARRAY
6040: PUSH
6041: LD_VAR 0 2
6045: DIFF
6046: PPUSH
6047: CALL_OW 1
6051: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6052: LD_ADDR_VAR 0 3
6056: PUSH
6057: LD_INT 0
6059: PPUSH
6060: LD_INT 2
6062: PPUSH
6063: CALL_OW 12
6067: ST_TO_ADDR
// if target then
6068: LD_VAR 0 3
6072: IFFALSE 6200
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6074: LD_ADDR_VAR 0 2
6078: PUSH
6079: LD_VAR 0 2
6083: PPUSH
6084: LD_INT 24
6086: PUSH
6087: LD_INT 250
6089: PUSH
6090: EMPTY
6091: LIST
6092: LIST
6093: PPUSH
6094: CALL_OW 72
6098: ST_TO_ADDR
// for i in tmp do
6099: LD_ADDR_VAR 0 1
6103: PUSH
6104: LD_VAR 0 2
6108: PUSH
6109: FOR_IN
6110: IFFALSE 6150
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6112: LD_VAR 0 1
6116: PPUSH
6117: LD_INT 89
6119: PPUSH
6120: LD_INT 71
6122: PPUSH
6123: CALL_OW 297
6127: PUSH
6128: LD_INT 9
6130: GREATER
6131: IFFALSE 6148
// ComMoveXY ( i , 89 , 71 ) ;
6133: LD_VAR 0 1
6137: PPUSH
6138: LD_INT 89
6140: PPUSH
6141: LD_INT 71
6143: PPUSH
6144: CALL_OW 111
6148: GO 6109
6150: POP
6151: POP
// wait ( 0 0$1 ) ;
6152: LD_INT 35
6154: PPUSH
6155: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6159: LD_VAR 0 2
6163: PPUSH
6164: LD_INT 92
6166: PUSH
6167: LD_INT 89
6169: PUSH
6170: LD_INT 71
6172: PUSH
6173: LD_INT 9
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: LIST
6180: LIST
6181: PPUSH
6182: CALL_OW 72
6186: PUSH
6187: LD_VAR 0 2
6191: PUSH
6192: LD_INT 1
6194: MINUS
6195: GREATEREQUAL
6196: IFFALSE 6074
// end else
6198: GO 6324
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6200: LD_ADDR_VAR 0 2
6204: PUSH
6205: LD_VAR 0 2
6209: PPUSH
6210: LD_INT 24
6212: PUSH
6213: LD_INT 250
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: PPUSH
6220: CALL_OW 72
6224: ST_TO_ADDR
// for i in tmp do
6225: LD_ADDR_VAR 0 1
6229: PUSH
6230: LD_VAR 0 2
6234: PUSH
6235: FOR_IN
6236: IFFALSE 6276
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6238: LD_VAR 0 1
6242: PPUSH
6243: LD_INT 125
6245: PPUSH
6246: LD_INT 129
6248: PPUSH
6249: CALL_OW 297
6253: PUSH
6254: LD_INT 9
6256: GREATER
6257: IFFALSE 6274
// ComMoveXY ( i , 125 , 129 ) ;
6259: LD_VAR 0 1
6263: PPUSH
6264: LD_INT 125
6266: PPUSH
6267: LD_INT 129
6269: PPUSH
6270: CALL_OW 111
6274: GO 6235
6276: POP
6277: POP
// wait ( 0 0$1 ) ;
6278: LD_INT 35
6280: PPUSH
6281: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6285: LD_VAR 0 2
6289: PPUSH
6290: LD_INT 92
6292: PUSH
6293: LD_INT 125
6295: PUSH
6296: LD_INT 129
6298: PUSH
6299: LD_INT 9
6301: PUSH
6302: EMPTY
6303: LIST
6304: LIST
6305: LIST
6306: LIST
6307: PPUSH
6308: CALL_OW 72
6312: PUSH
6313: LD_VAR 0 2
6317: PUSH
6318: LD_INT 1
6320: MINUS
6321: GREATEREQUAL
6322: IFFALSE 6200
// end ; repeat wait ( 0 0$1 ) ;
6324: LD_INT 35
6326: PPUSH
6327: CALL_OW 67
// for i in tmp do
6331: LD_ADDR_VAR 0 1
6335: PUSH
6336: LD_VAR 0 2
6340: PUSH
6341: FOR_IN
6342: IFFALSE 6424
// begin if GetLives ( i ) > 251 then
6344: LD_VAR 0 1
6348: PPUSH
6349: CALL_OW 256
6353: PUSH
6354: LD_INT 251
6356: GREATER
6357: IFFALSE 6395
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6359: LD_VAR 0 1
6363: PPUSH
6364: LD_INT 81
6366: PUSH
6367: LD_INT 8
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: PPUSH
6374: CALL_OW 69
6378: PPUSH
6379: LD_VAR 0 1
6383: PPUSH
6384: CALL_OW 74
6388: PPUSH
6389: CALL_OW 115
6393: GO 6422
// if IsDead ( i ) then
6395: LD_VAR 0 1
6399: PPUSH
6400: CALL_OW 301
6404: IFFALSE 6422
// tmp := tmp diff i ;
6406: LD_ADDR_VAR 0 2
6410: PUSH
6411: LD_VAR 0 2
6415: PUSH
6416: LD_VAR 0 1
6420: DIFF
6421: ST_TO_ADDR
// end ;
6422: GO 6341
6424: POP
6425: POP
// until not tmp ;
6426: LD_VAR 0 2
6430: NOT
6431: IFFALSE 6324
// end ;
6433: PPOPN 3
6435: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6436: LD_EXP 22
6440: NOT
6441: PUSH
6442: LD_EXP 15
6446: PUSH
6447: LD_INT 6
6449: GREATEREQUAL
6450: AND
6451: PUSH
6452: LD_OWVAR 67
6456: PUSH
6457: LD_INT 1
6459: GREATER
6460: AND
6461: IFFALSE 6978
6463: GO 6465
6465: DISABLE
6466: LD_INT 0
6468: PPUSH
6469: PPUSH
6470: PPUSH
// begin enable ;
6471: ENABLE
// tmp := [ ] ;
6472: LD_ADDR_VAR 0 3
6476: PUSH
6477: EMPTY
6478: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6479: LD_ADDR_VAR 0 1
6483: PUSH
6484: DOUBLE
6485: LD_INT 1
6487: DEC
6488: ST_TO_ADDR
6489: LD_INT 4
6491: PUSH
6492: LD_INT 6
6494: PUSH
6495: LD_INT 7
6497: PUSH
6498: EMPTY
6499: LIST
6500: LIST
6501: LIST
6502: PUSH
6503: LD_OWVAR 67
6507: ARRAY
6508: PUSH
6509: FOR_TO
6510: IFFALSE 6670
// begin uc_side := 8 ;
6512: LD_ADDR_OWVAR 20
6516: PUSH
6517: LD_INT 8
6519: ST_TO_ADDR
// uc_nation := 2 ;
6520: LD_ADDR_OWVAR 21
6524: PUSH
6525: LD_INT 2
6527: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6528: LD_INT 13
6530: PUSH
6531: LD_INT 14
6533: PUSH
6534: EMPTY
6535: LIST
6536: LIST
6537: PUSH
6538: LD_INT 1
6540: PPUSH
6541: LD_INT 2
6543: PPUSH
6544: CALL_OW 12
6548: ARRAY
6549: PPUSH
6550: LD_INT 1
6552: PPUSH
6553: LD_INT 5
6555: PPUSH
6556: LD_INT 27
6558: PUSH
6559: LD_INT 28
6561: PUSH
6562: LD_INT 26
6564: PUSH
6565: LD_INT 25
6567: PUSH
6568: EMPTY
6569: LIST
6570: LIST
6571: LIST
6572: LIST
6573: PUSH
6574: LD_INT 1
6576: PPUSH
6577: LD_INT 4
6579: PPUSH
6580: CALL_OW 12
6584: ARRAY
6585: PPUSH
6586: LD_INT 88
6588: PPUSH
6589: CALL 70006 0 5
// un := CreateVehicle ;
6593: LD_ADDR_VAR 0 2
6597: PUSH
6598: CALL_OW 45
6602: ST_TO_ADDR
// tmp := tmp ^ un ;
6603: LD_ADDR_VAR 0 3
6607: PUSH
6608: LD_VAR 0 3
6612: PUSH
6613: LD_VAR 0 2
6617: ADD
6618: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6619: LD_VAR 0 2
6623: PPUSH
6624: LD_INT 3
6626: PPUSH
6627: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6631: LD_VAR 0 2
6635: PPUSH
6636: LD_INT 30
6638: PPUSH
6639: LD_INT 0
6641: PPUSH
6642: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6646: LD_VAR 0 2
6650: PPUSH
6651: LD_INT 16
6653: PPUSH
6654: LD_INT 11
6656: PPUSH
6657: CALL_OW 111
// wait ( 0 0$2 ) ;
6661: LD_INT 70
6663: PPUSH
6664: CALL_OW 67
// end ;
6668: GO 6509
6670: POP
6671: POP
// for i = 1 to Difficulty do
6672: LD_ADDR_VAR 0 1
6676: PUSH
6677: DOUBLE
6678: LD_INT 1
6680: DEC
6681: ST_TO_ADDR
6682: LD_OWVAR 67
6686: PUSH
6687: FOR_TO
6688: IFFALSE 6813
// begin uc_side := 8 ;
6690: LD_ADDR_OWVAR 20
6694: PUSH
6695: LD_INT 8
6697: ST_TO_ADDR
// uc_nation := 2 ;
6698: LD_ADDR_OWVAR 21
6702: PUSH
6703: LD_INT 2
6705: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6706: LD_INT 0
6708: PPUSH
6709: LD_INT 8
6711: PPUSH
6712: LD_INT 8
6714: PUSH
6715: LD_INT 8
6717: PUSH
6718: LD_INT 9
6720: PUSH
6721: EMPTY
6722: LIST
6723: LIST
6724: LIST
6725: PUSH
6726: LD_OWVAR 67
6730: ARRAY
6731: PPUSH
6732: CALL_OW 380
// un := CreateHuman ;
6736: LD_ADDR_VAR 0 2
6740: PUSH
6741: CALL_OW 44
6745: ST_TO_ADDR
// tmp := tmp ^ un ;
6746: LD_ADDR_VAR 0 3
6750: PUSH
6751: LD_VAR 0 3
6755: PUSH
6756: LD_VAR 0 2
6760: ADD
6761: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6762: LD_VAR 0 2
6766: PPUSH
6767: LD_INT 3
6769: PPUSH
6770: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6774: LD_VAR 0 2
6778: PPUSH
6779: LD_INT 30
6781: PPUSH
6782: LD_INT 0
6784: PPUSH
6785: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6789: LD_VAR 0 2
6793: PPUSH
6794: LD_INT 16
6796: PPUSH
6797: LD_INT 11
6799: PPUSH
6800: CALL_OW 111
// wait ( 0 0$2 ) ;
6804: LD_INT 70
6806: PPUSH
6807: CALL_OW 67
// end ;
6811: GO 6687
6813: POP
6814: POP
// repeat wait ( 0 0$1 ) ;
6815: LD_INT 35
6817: PPUSH
6818: CALL_OW 67
// for i in tmp do
6822: LD_ADDR_VAR 0 1
6826: PUSH
6827: LD_VAR 0 3
6831: PUSH
6832: FOR_IN
6833: IFFALSE 6969
// begin if GetLives ( i ) > 250 then
6835: LD_VAR 0 1
6839: PPUSH
6840: CALL_OW 256
6844: PUSH
6845: LD_INT 250
6847: GREATER
6848: IFFALSE 6940
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6850: LD_INT 81
6852: PUSH
6853: LD_INT 8
6855: PUSH
6856: EMPTY
6857: LIST
6858: LIST
6859: PUSH
6860: LD_INT 91
6862: PUSH
6863: LD_VAR 0 1
6867: PUSH
6868: LD_INT 10
6870: PUSH
6871: EMPTY
6872: LIST
6873: LIST
6874: LIST
6875: PUSH
6876: EMPTY
6877: LIST
6878: LIST
6879: PPUSH
6880: CALL_OW 69
6884: NOT
6885: IFFALSE 6904
// ComAgressiveMove ( i , 67 , 110 ) else
6887: LD_VAR 0 1
6891: PPUSH
6892: LD_INT 67
6894: PPUSH
6895: LD_INT 110
6897: PPUSH
6898: CALL_OW 114
6902: GO 6938
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6904: LD_VAR 0 1
6908: PPUSH
6909: LD_INT 81
6911: PUSH
6912: LD_INT 8
6914: PUSH
6915: EMPTY
6916: LIST
6917: LIST
6918: PPUSH
6919: CALL_OW 69
6923: PPUSH
6924: LD_VAR 0 1
6928: PPUSH
6929: CALL_OW 74
6933: PPUSH
6934: CALL_OW 115
// end else
6938: GO 6967
// if IsDead ( i ) then
6940: LD_VAR 0 1
6944: PPUSH
6945: CALL_OW 301
6949: IFFALSE 6967
// tmp := tmp diff i ;
6951: LD_ADDR_VAR 0 3
6955: PUSH
6956: LD_VAR 0 3
6960: PUSH
6961: LD_VAR 0 1
6965: DIFF
6966: ST_TO_ADDR
// end ;
6967: GO 6832
6969: POP
6970: POP
// until not tmp ;
6971: LD_VAR 0 3
6975: NOT
6976: IFFALSE 6815
// end ; end_of_file
6978: PPOPN 3
6980: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6981: LD_INT 0
6983: PPUSH
6984: PPUSH
6985: PPUSH
6986: PPUSH
6987: PPUSH
6988: PPUSH
6989: PPUSH
6990: PPUSH
6991: PPUSH
// side := 3 ;
6992: LD_ADDR_VAR 0 6
6996: PUSH
6997: LD_INT 3
6999: ST_TO_ADDR
// uc_side := side ;
7000: LD_ADDR_OWVAR 20
7004: PUSH
7005: LD_VAR 0 6
7009: ST_TO_ADDR
// uc_nation := 3 ;
7010: LD_ADDR_OWVAR 21
7014: PUSH
7015: LD_INT 3
7017: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7018: LD_ADDR_VAR 0 2
7022: PUSH
7023: LD_INT 22
7025: PUSH
7026: LD_VAR 0 6
7030: PUSH
7031: EMPTY
7032: LIST
7033: LIST
7034: PUSH
7035: LD_INT 21
7037: PUSH
7038: LD_INT 3
7040: PUSH
7041: EMPTY
7042: LIST
7043: LIST
7044: PUSH
7045: EMPTY
7046: LIST
7047: LIST
7048: PPUSH
7049: CALL_OW 69
7053: PUSH
7054: FOR_IN
7055: IFFALSE 7071
// SetBLevel ( i , 10 ) ;
7057: LD_VAR 0 2
7061: PPUSH
7062: LD_INT 10
7064: PPUSH
7065: CALL_OW 241
7069: GO 7054
7071: POP
7072: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7073: LD_ADDR_VAR 0 9
7077: PUSH
7078: LD_INT 22
7080: PUSH
7081: LD_VAR 0 6
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: PUSH
7090: LD_INT 30
7092: PUSH
7093: LD_INT 34
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PUSH
7100: EMPTY
7101: LIST
7102: LIST
7103: PPUSH
7104: CALL_OW 69
7108: ST_TO_ADDR
// if teleport then
7109: LD_VAR 0 9
7113: IFFALSE 7134
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7115: LD_VAR 0 9
7119: PUSH
7120: LD_INT 1
7122: ARRAY
7123: PPUSH
7124: LD_INT 123
7126: PPUSH
7127: LD_INT 122
7129: PPUSH
7130: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7134: LD_ADDR_EXP 64
7138: PUSH
7139: LD_STRING Platonov
7141: PPUSH
7142: CALL_OW 25
7146: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7147: LD_ADDR_EXP 65
7151: PUSH
7152: LD_STRING Kovalyuk
7154: PPUSH
7155: CALL_OW 25
7159: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7160: LD_ADDR_EXP 67
7164: PUSH
7165: LD_STRING Yakotich
7167: PPUSH
7168: LD_EXP 1
7172: NOT
7173: PPUSH
7174: LD_STRING 09_
7176: PPUSH
7177: CALL 65182 0 3
7181: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7182: LD_ADDR_EXP 66
7186: PUSH
7187: LD_STRING Bystrov
7189: PPUSH
7190: CALL_OW 25
7194: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7195: LD_ADDR_EXP 68
7199: PUSH
7200: LD_STRING Gleb
7202: PPUSH
7203: CALL_OW 25
7207: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7208: LD_STRING 03_Cornel
7210: PPUSH
7211: CALL_OW 28
7215: IFFALSE 7263
// begin Bierezov := NewCharacter ( Mikhail ) ;
7217: LD_ADDR_EXP 69
7221: PUSH
7222: LD_STRING Mikhail
7224: PPUSH
7225: CALL_OW 25
7229: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7230: LD_EXP 69
7234: PPUSH
7235: LD_INT 197
7237: PPUSH
7238: LD_INT 111
7240: PPUSH
7241: LD_INT 9
7243: PPUSH
7244: LD_INT 0
7246: PPUSH
7247: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7251: LD_EXP 69
7255: PPUSH
7256: LD_INT 3
7258: PPUSH
7259: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7263: LD_EXP 64
7267: PPUSH
7268: LD_INT 126
7270: PPUSH
7271: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7275: LD_EXP 65
7279: PPUSH
7280: LD_INT 134
7282: PPUSH
7283: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7287: LD_EXP 67
7291: PPUSH
7292: LD_INT 197
7294: PPUSH
7295: LD_INT 111
7297: PPUSH
7298: LD_INT 9
7300: PPUSH
7301: LD_INT 0
7303: PPUSH
7304: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7308: LD_EXP 66
7312: PPUSH
7313: LD_INT 197
7315: PPUSH
7316: LD_INT 111
7318: PPUSH
7319: LD_INT 9
7321: PPUSH
7322: LD_INT 0
7324: PPUSH
7325: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7329: LD_EXP 68
7333: PPUSH
7334: LD_INT 197
7336: PPUSH
7337: LD_INT 111
7339: PPUSH
7340: LD_INT 9
7342: PPUSH
7343: LD_INT 0
7345: PPUSH
7346: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7350: LD_ADDR_VAR 0 5
7354: PUSH
7355: LD_INT 126
7357: PPUSH
7358: LD_INT 4
7360: PPUSH
7361: LD_STRING zhukov
7363: PPUSH
7364: LD_INT 9
7366: PUSH
7367: LD_INT 10
7369: PUSH
7370: LD_INT 10
7372: PUSH
7373: EMPTY
7374: LIST
7375: LIST
7376: LIST
7377: PUSH
7378: LD_OWVAR 67
7382: ARRAY
7383: PPUSH
7384: LD_INT 90000
7386: PUSH
7387: LD_INT 1000
7389: PUSH
7390: LD_INT 300
7392: PUSH
7393: EMPTY
7394: LIST
7395: LIST
7396: LIST
7397: PPUSH
7398: LD_INT 18
7400: PUSH
7401: LD_INT 8
7403: PUSH
7404: LD_INT 13
7406: PUSH
7407: LD_INT 8
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: LIST
7414: LIST
7415: PPUSH
7416: CALL 73415 0 6
7420: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7421: LD_ADDR_VAR 0 4
7425: PUSH
7426: LD_INT 267
7428: PPUSH
7429: CALL_OW 274
7433: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7434: LD_VAR 0 4
7438: PPUSH
7439: LD_INT 1
7441: PPUSH
7442: LD_INT 5000
7444: PPUSH
7445: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7449: LD_VAR 0 4
7453: PPUSH
7454: LD_INT 2
7456: PPUSH
7457: LD_INT 200
7459: PPUSH
7460: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7464: LD_VAR 0 4
7468: PPUSH
7469: LD_INT 3
7471: PPUSH
7472: LD_INT 200
7474: PPUSH
7475: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7479: LD_ADDR_EXP 113
7483: PUSH
7484: LD_EXP 113
7488: PPUSH
7489: LD_INT 2
7491: PPUSH
7492: LD_VAR 0 5
7496: PUSH
7497: LD_INT 22
7499: PUSH
7500: LD_VAR 0 6
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PUSH
7509: LD_INT 3
7511: PUSH
7512: LD_INT 21
7514: PUSH
7515: LD_INT 2
7517: PUSH
7518: EMPTY
7519: LIST
7520: LIST
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PUSH
7526: EMPTY
7527: LIST
7528: LIST
7529: PPUSH
7530: CALL_OW 69
7534: UNION
7535: PUSH
7536: LD_EXP 64
7540: DIFF
7541: PPUSH
7542: CALL_OW 1
7546: ST_TO_ADDR
// behemoths := [ ] ;
7547: LD_ADDR_EXP 72
7551: PUSH
7552: EMPTY
7553: ST_TO_ADDR
// behemothBuilders := [ ] ;
7554: LD_ADDR_EXP 73
7558: PUSH
7559: EMPTY
7560: ST_TO_ADDR
// if Kovalyuk then
7561: LD_EXP 65
7565: IFFALSE 7587
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7567: LD_ADDR_EXP 73
7571: PUSH
7572: LD_EXP 73
7576: PPUSH
7577: LD_EXP 65
7581: PPUSH
7582: CALL 101171 0 2
7586: ST_TO_ADDR
// j := 3 ;
7587: LD_ADDR_VAR 0 3
7591: PUSH
7592: LD_INT 3
7594: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7595: LD_ADDR_VAR 0 2
7599: PUSH
7600: LD_INT 22
7602: PUSH
7603: LD_INT 3
7605: PUSH
7606: EMPTY
7607: LIST
7608: LIST
7609: PUSH
7610: LD_INT 25
7612: PUSH
7613: LD_INT 3
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PPUSH
7624: CALL_OW 69
7628: PUSH
7629: LD_EXP 65
7633: DIFF
7634: PUSH
7635: FOR_IN
7636: IFFALSE 7686
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7638: LD_ADDR_EXP 73
7642: PUSH
7643: LD_EXP 73
7647: PPUSH
7648: LD_VAR 0 2
7652: PPUSH
7653: CALL 101171 0 2
7657: ST_TO_ADDR
// j := j - 1 ;
7658: LD_ADDR_VAR 0 3
7662: PUSH
7663: LD_VAR 0 3
7667: PUSH
7668: LD_INT 1
7670: MINUS
7671: ST_TO_ADDR
// if j = 0 then
7672: LD_VAR 0 3
7676: PUSH
7677: LD_INT 0
7679: EQUAL
7680: IFFALSE 7684
// break ;
7682: GO 7686
// end ;
7684: GO 7635
7686: POP
7687: POP
// end ;
7688: LD_VAR 0 1
7692: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7693: LD_INT 0
7695: PPUSH
7696: PPUSH
7697: PPUSH
7698: PPUSH
7699: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7700: LD_ADDR_VAR 0 4
7704: PUSH
7705: LD_INT 209
7707: PUSH
7708: LD_INT 149
7710: PUSH
7711: EMPTY
7712: LIST
7713: LIST
7714: PUSH
7715: LD_INT 219
7717: PUSH
7718: LD_INT 154
7720: PUSH
7721: EMPTY
7722: LIST
7723: LIST
7724: PUSH
7725: LD_INT 223
7727: PUSH
7728: LD_INT 149
7730: PUSH
7731: EMPTY
7732: LIST
7733: LIST
7734: PUSH
7735: LD_INT 232
7737: PUSH
7738: LD_INT 155
7740: PUSH
7741: EMPTY
7742: LIST
7743: LIST
7744: PUSH
7745: EMPTY
7746: LIST
7747: LIST
7748: LIST
7749: LIST
7750: ST_TO_ADDR
// if not behemothBuilders then
7751: LD_EXP 73
7755: NOT
7756: IFFALSE 7760
// exit ;
7758: GO 7864
// j := 1 ;
7760: LD_ADDR_VAR 0 3
7764: PUSH
7765: LD_INT 1
7767: ST_TO_ADDR
// for i in behemothBuilders do
7768: LD_ADDR_VAR 0 2
7772: PUSH
7773: LD_EXP 73
7777: PUSH
7778: FOR_IN
7779: IFFALSE 7862
// begin if IsInUnit ( i ) then
7781: LD_VAR 0 2
7785: PPUSH
7786: CALL_OW 310
7790: IFFALSE 7801
// ComExitBuilding ( i ) ;
7792: LD_VAR 0 2
7796: PPUSH
7797: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7801: LD_VAR 0 2
7805: PPUSH
7806: LD_INT 37
7808: PPUSH
7809: LD_VAR 0 4
7813: PUSH
7814: LD_VAR 0 3
7818: ARRAY
7819: PUSH
7820: LD_INT 1
7822: ARRAY
7823: PPUSH
7824: LD_VAR 0 4
7828: PUSH
7829: LD_VAR 0 3
7833: ARRAY
7834: PUSH
7835: LD_INT 2
7837: ARRAY
7838: PPUSH
7839: LD_INT 0
7841: PPUSH
7842: CALL_OW 230
// j := j + 1 ;
7846: LD_ADDR_VAR 0 3
7850: PUSH
7851: LD_VAR 0 3
7855: PUSH
7856: LD_INT 1
7858: PLUS
7859: ST_TO_ADDR
// end ;
7860: GO 7778
7862: POP
7863: POP
// end ;
7864: LD_VAR 0 1
7868: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7869: LD_INT 24
7871: PPUSH
7872: LD_INT 30
7874: PUSH
7875: LD_INT 37
7877: PUSH
7878: EMPTY
7879: LIST
7880: LIST
7881: PPUSH
7882: CALL_OW 70
7886: IFFALSE 7899
7888: GO 7890
7890: DISABLE
// behemothUnderConstruct := true ;
7891: LD_ADDR_EXP 26
7895: PUSH
7896: LD_INT 1
7898: ST_TO_ADDR
7899: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7900: LD_INT 3
7902: PPUSH
7903: CALL 101232 0 1
7907: PUSH
7908: LD_INT 22
7910: PUSH
7911: LD_INT 3
7913: PUSH
7914: EMPTY
7915: LIST
7916: LIST
7917: PUSH
7918: LD_INT 30
7920: PUSH
7921: LD_INT 37
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: PUSH
7928: EMPTY
7929: LIST
7930: LIST
7931: PPUSH
7932: CALL_OW 69
7936: NOT
7937: AND
7938: IFFALSE 8124
7940: GO 7942
7942: DISABLE
7943: LD_INT 0
7945: PPUSH
7946: PPUSH
// begin enable ;
7947: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7948: LD_ADDR_VAR 0 2
7952: PUSH
7953: LD_INT 3
7955: PPUSH
7956: CALL 101232 0 1
7960: ST_TO_ADDR
// for i in tmp do
7961: LD_ADDR_VAR 0 1
7965: PUSH
7966: LD_VAR 0 2
7970: PUSH
7971: FOR_IN
7972: IFFALSE 8122
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7974: LD_VAR 0 1
7978: PPUSH
7979: LD_INT 9
7981: PPUSH
7982: CALL_OW 308
7986: PUSH
7987: LD_VAR 0 1
7991: PPUSH
7992: CALL_OW 110
7996: PUSH
7997: LD_INT 2
7999: EQUAL
8000: NOT
8001: AND
8002: IFFALSE 8016
// SetTag ( i , 2 ) ;
8004: LD_VAR 0 1
8008: PPUSH
8009: LD_INT 2
8011: PPUSH
8012: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8016: LD_INT 81
8018: PUSH
8019: LD_INT 3
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PUSH
8026: LD_INT 91
8028: PUSH
8029: LD_VAR 0 1
8033: PUSH
8034: LD_INT 12
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: LIST
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: PPUSH
8046: CALL_OW 69
8050: NOT
8051: PUSH
8052: LD_VAR 0 1
8056: PPUSH
8057: CALL_OW 110
8061: PUSH
8062: LD_INT 2
8064: EQUAL
8065: NOT
8066: AND
8067: IFFALSE 8086
// ComAgressiveMove ( i , 64 , 93 ) else
8069: LD_VAR 0 1
8073: PPUSH
8074: LD_INT 64
8076: PPUSH
8077: LD_INT 93
8079: PPUSH
8080: CALL_OW 114
8084: GO 8120
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8086: LD_VAR 0 1
8090: PPUSH
8091: LD_INT 81
8093: PUSH
8094: LD_INT 3
8096: PUSH
8097: EMPTY
8098: LIST
8099: LIST
8100: PPUSH
8101: CALL_OW 69
8105: PPUSH
8106: LD_VAR 0 1
8110: PPUSH
8111: CALL_OW 74
8115: PPUSH
8116: CALL_OW 115
// end ;
8120: GO 7971
8122: POP
8123: POP
// end ;
8124: PPOPN 2
8126: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8127: LD_INT 0
8129: PPUSH
8130: PPUSH
8131: PPUSH
// result := [ ] ;
8132: LD_ADDR_VAR 0 2
8136: PUSH
8137: EMPTY
8138: ST_TO_ADDR
// uc_side := 6 ;
8139: LD_ADDR_OWVAR 20
8143: PUSH
8144: LD_INT 6
8146: ST_TO_ADDR
// uc_nation := 3 ;
8147: LD_ADDR_OWVAR 21
8151: PUSH
8152: LD_INT 3
8154: ST_TO_ADDR
// case strength of 1 :
8155: LD_VAR 0 1
8159: PUSH
8160: LD_INT 1
8162: DOUBLE
8163: EQUAL
8164: IFTRUE 8168
8166: GO 8306
8168: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8169: LD_ADDR_VAR 0 3
8173: PUSH
8174: DOUBLE
8175: LD_INT 1
8177: DEC
8178: ST_TO_ADDR
8179: LD_INT 4
8181: PUSH
8182: LD_INT 5
8184: PUSH
8185: LD_INT 6
8187: PUSH
8188: EMPTY
8189: LIST
8190: LIST
8191: LIST
8192: PUSH
8193: LD_OWVAR 67
8197: ARRAY
8198: PUSH
8199: FOR_TO
8200: IFFALSE 8302
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8202: LD_INT 22
8204: PUSH
8205: LD_INT 24
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: PUSH
8212: LD_VAR 0 3
8216: PUSH
8217: LD_INT 2
8219: MOD
8220: PUSH
8221: LD_INT 1
8223: PLUS
8224: ARRAY
8225: PPUSH
8226: LD_INT 1
8228: PUSH
8229: LD_INT 3
8231: PUSH
8232: EMPTY
8233: LIST
8234: LIST
8235: PUSH
8236: LD_INT 1
8238: PPUSH
8239: LD_INT 2
8241: PPUSH
8242: CALL_OW 12
8246: ARRAY
8247: PPUSH
8248: LD_INT 3
8250: PPUSH
8251: LD_INT 43
8253: PUSH
8254: LD_INT 44
8256: PUSH
8257: LD_INT 45
8259: PUSH
8260: EMPTY
8261: LIST
8262: LIST
8263: LIST
8264: PUSH
8265: LD_INT 1
8267: PPUSH
8268: LD_INT 3
8270: PPUSH
8271: CALL_OW 12
8275: ARRAY
8276: PPUSH
8277: LD_INT 80
8279: PPUSH
8280: CALL 70006 0 5
// result := result union CreateVehicle ;
8284: LD_ADDR_VAR 0 2
8288: PUSH
8289: LD_VAR 0 2
8293: PUSH
8294: CALL_OW 45
8298: UNION
8299: ST_TO_ADDR
// end ;
8300: GO 8199
8302: POP
8303: POP
// end ; 2 :
8304: GO 9257
8306: LD_INT 2
8308: DOUBLE
8309: EQUAL
8310: IFTRUE 8314
8312: GO 8470
8314: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8315: LD_ADDR_VAR 0 3
8319: PUSH
8320: DOUBLE
8321: LD_INT 1
8323: DEC
8324: ST_TO_ADDR
8325: LD_INT 5
8327: PUSH
8328: LD_INT 6
8330: PUSH
8331: LD_INT 7
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: LIST
8338: PUSH
8339: LD_OWVAR 67
8343: ARRAY
8344: PUSH
8345: FOR_TO
8346: IFFALSE 8466
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8348: LD_INT 22
8350: PUSH
8351: LD_INT 24
8353: PUSH
8354: LD_INT 24
8356: PUSH
8357: EMPTY
8358: LIST
8359: LIST
8360: LIST
8361: PUSH
8362: LD_VAR 0 3
8366: PUSH
8367: LD_INT 3
8369: MOD
8370: PUSH
8371: LD_INT 1
8373: PLUS
8374: ARRAY
8375: PPUSH
8376: LD_INT 1
8378: PUSH
8379: LD_INT 3
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: PUSH
8386: LD_INT 1
8388: PPUSH
8389: LD_INT 2
8391: PPUSH
8392: CALL_OW 12
8396: ARRAY
8397: PPUSH
8398: LD_INT 3
8400: PPUSH
8401: LD_INT 43
8403: PUSH
8404: LD_INT 44
8406: PUSH
8407: LD_INT 45
8409: PUSH
8410: LD_INT 44
8412: PUSH
8413: LD_INT 46
8415: PUSH
8416: LD_INT 46
8418: PUSH
8419: EMPTY
8420: LIST
8421: LIST
8422: LIST
8423: LIST
8424: LIST
8425: LIST
8426: PUSH
8427: LD_VAR 0 3
8431: PUSH
8432: LD_INT 6
8434: MOD
8435: PUSH
8436: LD_INT 1
8438: PLUS
8439: ARRAY
8440: PPUSH
8441: LD_INT 80
8443: PPUSH
8444: CALL 70006 0 5
// result := result union CreateVehicle ;
8448: LD_ADDR_VAR 0 2
8452: PUSH
8453: LD_VAR 0 2
8457: PUSH
8458: CALL_OW 45
8462: UNION
8463: ST_TO_ADDR
// end ;
8464: GO 8345
8466: POP
8467: POP
// end ; 3 :
8468: GO 9257
8470: LD_INT 3
8472: DOUBLE
8473: EQUAL
8474: IFTRUE 8478
8476: GO 8634
8478: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8479: LD_ADDR_VAR 0 3
8483: PUSH
8484: DOUBLE
8485: LD_INT 1
8487: DEC
8488: ST_TO_ADDR
8489: LD_INT 5
8491: PUSH
8492: LD_INT 7
8494: PUSH
8495: LD_INT 8
8497: PUSH
8498: EMPTY
8499: LIST
8500: LIST
8501: LIST
8502: PUSH
8503: LD_OWVAR 67
8507: ARRAY
8508: PUSH
8509: FOR_TO
8510: IFFALSE 8630
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8512: LD_INT 22
8514: PUSH
8515: LD_INT 24
8517: PUSH
8518: LD_INT 24
8520: PUSH
8521: EMPTY
8522: LIST
8523: LIST
8524: LIST
8525: PUSH
8526: LD_VAR 0 3
8530: PUSH
8531: LD_INT 3
8533: MOD
8534: PUSH
8535: LD_INT 1
8537: PLUS
8538: ARRAY
8539: PPUSH
8540: LD_INT 1
8542: PUSH
8543: LD_INT 3
8545: PUSH
8546: EMPTY
8547: LIST
8548: LIST
8549: PUSH
8550: LD_INT 1
8552: PPUSH
8553: LD_INT 2
8555: PPUSH
8556: CALL_OW 12
8560: ARRAY
8561: PPUSH
8562: LD_INT 3
8564: PPUSH
8565: LD_INT 43
8567: PUSH
8568: LD_INT 47
8570: PUSH
8571: LD_INT 45
8573: PUSH
8574: LD_INT 45
8576: PUSH
8577: LD_INT 46
8579: PUSH
8580: LD_INT 46
8582: PUSH
8583: EMPTY
8584: LIST
8585: LIST
8586: LIST
8587: LIST
8588: LIST
8589: LIST
8590: PUSH
8591: LD_VAR 0 3
8595: PUSH
8596: LD_INT 6
8598: MOD
8599: PUSH
8600: LD_INT 1
8602: PLUS
8603: ARRAY
8604: PPUSH
8605: LD_INT 80
8607: PPUSH
8608: CALL 70006 0 5
// result := result union CreateVehicle ;
8612: LD_ADDR_VAR 0 2
8616: PUSH
8617: LD_VAR 0 2
8621: PUSH
8622: CALL_OW 45
8626: UNION
8627: ST_TO_ADDR
// end ;
8628: GO 8509
8630: POP
8631: POP
// end ; 4 :
8632: GO 9257
8634: LD_INT 4
8636: DOUBLE
8637: EQUAL
8638: IFTRUE 8642
8640: GO 9256
8642: POP
// begin uc_nation := 3 ;
8643: LD_ADDR_OWVAR 21
8647: PUSH
8648: LD_INT 3
8650: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8651: LD_ADDR_VAR 0 3
8655: PUSH
8656: DOUBLE
8657: LD_INT 1
8659: DEC
8660: ST_TO_ADDR
8661: LD_INT 6
8663: PUSH
8664: LD_INT 8
8666: PUSH
8667: LD_INT 9
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: LIST
8674: PUSH
8675: LD_OWVAR 67
8679: ARRAY
8680: PUSH
8681: FOR_TO
8682: IFFALSE 8802
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8684: LD_INT 22
8686: PUSH
8687: LD_INT 24
8689: PUSH
8690: LD_INT 24
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: LIST
8697: PUSH
8698: LD_VAR 0 3
8702: PUSH
8703: LD_INT 3
8705: MOD
8706: PUSH
8707: LD_INT 1
8709: PLUS
8710: ARRAY
8711: PPUSH
8712: LD_INT 1
8714: PUSH
8715: LD_INT 3
8717: PUSH
8718: EMPTY
8719: LIST
8720: LIST
8721: PUSH
8722: LD_INT 1
8724: PPUSH
8725: LD_INT 2
8727: PPUSH
8728: CALL_OW 12
8732: ARRAY
8733: PPUSH
8734: LD_INT 3
8736: PPUSH
8737: LD_INT 45
8739: PUSH
8740: LD_INT 47
8742: PUSH
8743: LD_INT 47
8745: PUSH
8746: LD_INT 45
8748: PUSH
8749: LD_INT 46
8751: PUSH
8752: LD_INT 46
8754: PUSH
8755: EMPTY
8756: LIST
8757: LIST
8758: LIST
8759: LIST
8760: LIST
8761: LIST
8762: PUSH
8763: LD_VAR 0 3
8767: PUSH
8768: LD_INT 6
8770: MOD
8771: PUSH
8772: LD_INT 1
8774: PLUS
8775: ARRAY
8776: PPUSH
8777: LD_INT 80
8779: PPUSH
8780: CALL 70006 0 5
// result := result union CreateVehicle ;
8784: LD_ADDR_VAR 0 2
8788: PUSH
8789: LD_VAR 0 2
8793: PUSH
8794: CALL_OW 45
8798: UNION
8799: ST_TO_ADDR
// end ;
8800: GO 8681
8802: POP
8803: POP
// if not KappaStatus then
8804: LD_EXP 2
8808: NOT
8809: IFFALSE 9044
// begin uc_nation := 1 ;
8811: LD_ADDR_OWVAR 21
8815: PUSH
8816: LD_INT 1
8818: ST_TO_ADDR
// for i = 1 to 3 do
8819: LD_ADDR_VAR 0 3
8823: PUSH
8824: DOUBLE
8825: LD_INT 1
8827: DEC
8828: ST_TO_ADDR
8829: LD_INT 3
8831: PUSH
8832: FOR_TO
8833: IFFALSE 8969
// begin j := rand ( 0 , 1 ) ;
8835: LD_ADDR_VAR 0 4
8839: PUSH
8840: LD_INT 0
8842: PPUSH
8843: LD_INT 1
8845: PPUSH
8846: CALL_OW 12
8850: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8851: LD_INT 3
8853: PUSH
8854: LD_INT 5
8856: PUSH
8857: LD_INT 5
8859: PUSH
8860: LD_INT 4
8862: PUSH
8863: EMPTY
8864: LIST
8865: LIST
8866: LIST
8867: LIST
8868: PUSH
8869: LD_VAR 0 4
8873: PUSH
8874: LD_INT 1
8876: PPUSH
8877: LD_INT 3
8879: PPUSH
8880: CALL_OW 12
8884: PLUS
8885: ARRAY
8886: PPUSH
8887: LD_INT 1
8889: PUSH
8890: LD_INT 3
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: PUSH
8897: LD_INT 1
8899: PPUSH
8900: LD_INT 2
8902: PPUSH
8903: CALL_OW 12
8907: ARRAY
8908: PPUSH
8909: LD_INT 3
8911: PPUSH
8912: LD_INT 9
8914: PUSH
8915: LD_INT 7
8917: PUSH
8918: LD_INT 6
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: LIST
8925: PUSH
8926: LD_VAR 0 4
8930: PUSH
8931: LD_INT 1
8933: PPUSH
8934: LD_INT 2
8936: PPUSH
8937: CALL_OW 12
8941: PLUS
8942: ARRAY
8943: PPUSH
8944: LD_INT 85
8946: PPUSH
8947: CALL 70006 0 5
// result := result union CreateVehicle ;
8951: LD_ADDR_VAR 0 2
8955: PUSH
8956: LD_VAR 0 2
8960: PUSH
8961: CALL_OW 45
8965: UNION
8966: ST_TO_ADDR
// end ;
8967: GO 8832
8969: POP
8970: POP
// if vsevolodFirstAttack then
8971: LD_EXP 24
8975: IFFALSE 9042
// begin vsevolodFirstAttack := false ;
8977: LD_ADDR_EXP 24
8981: PUSH
8982: LD_INT 0
8984: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8985: LD_INT 5
8987: PPUSH
8988: LD_INT 3
8990: PPUSH
8991: LD_INT 1
8993: PPUSH
8994: LD_INT 6
8996: PPUSH
8997: LD_INT 100
8999: PPUSH
9000: CALL 70006 0 5
// sewiVeh := CreateVehicle ;
9004: LD_ADDR_EXP 71
9008: PUSH
9009: CALL_OW 45
9013: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9014: LD_EXP 71
9018: PPUSH
9019: LD_INT 1
9021: PPUSH
9022: CALL_OW 242
// result := result union sewiVeh ;
9026: LD_ADDR_VAR 0 2
9030: PUSH
9031: LD_VAR 0 2
9035: PUSH
9036: LD_EXP 71
9040: UNION
9041: ST_TO_ADDR
// end ; end else
9042: GO 9254
// if vsevolodFirstAttack then
9044: LD_EXP 24
9048: IFFALSE 9254
// begin vsevolodFirstAttack := false ;
9050: LD_ADDR_EXP 24
9054: PUSH
9055: LD_INT 0
9057: ST_TO_ADDR
// uc_nation := 3 ;
9058: LD_ADDR_OWVAR 21
9062: PUSH
9063: LD_INT 3
9065: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9066: LD_ADDR_VAR 0 3
9070: PUSH
9071: DOUBLE
9072: LD_INT 1
9074: DEC
9075: ST_TO_ADDR
9076: LD_INT 2
9078: PUSH
9079: LD_OWVAR 67
9083: PLUS
9084: PUSH
9085: FOR_TO
9086: IFFALSE 9194
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9088: LD_INT 22
9090: PUSH
9091: LD_INT 24
9093: PUSH
9094: LD_INT 24
9096: PUSH
9097: EMPTY
9098: LIST
9099: LIST
9100: LIST
9101: PUSH
9102: LD_VAR 0 3
9106: PUSH
9107: LD_INT 3
9109: MOD
9110: PUSH
9111: LD_INT 1
9113: PLUS
9114: ARRAY
9115: PPUSH
9116: LD_INT 1
9118: PUSH
9119: LD_INT 3
9121: PUSH
9122: EMPTY
9123: LIST
9124: LIST
9125: PUSH
9126: LD_INT 1
9128: PPUSH
9129: LD_INT 2
9131: PPUSH
9132: CALL_OW 12
9136: ARRAY
9137: PPUSH
9138: LD_INT 1
9140: PPUSH
9141: LD_INT 45
9143: PUSH
9144: LD_INT 47
9146: PUSH
9147: LD_INT 47
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: LIST
9154: PUSH
9155: LD_VAR 0 3
9159: PUSH
9160: LD_INT 3
9162: MOD
9163: PUSH
9164: LD_INT 1
9166: PLUS
9167: ARRAY
9168: PPUSH
9169: LD_INT 80
9171: PPUSH
9172: CALL 70006 0 5
// result := result union CreateVehicle ;
9176: LD_ADDR_VAR 0 2
9180: PUSH
9181: LD_VAR 0 2
9185: PUSH
9186: CALL_OW 45
9190: UNION
9191: ST_TO_ADDR
// end ;
9192: GO 9085
9194: POP
9195: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9196: LD_INT 24
9198: PPUSH
9199: LD_INT 3
9201: PPUSH
9202: LD_INT 1
9204: PPUSH
9205: LD_INT 47
9207: PPUSH
9208: LD_INT 100
9210: PPUSH
9211: CALL 70006 0 5
// sewiVeh := CreateVehicle ;
9215: LD_ADDR_EXP 71
9219: PUSH
9220: CALL_OW 45
9224: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9225: LD_EXP 71
9229: PPUSH
9230: LD_INT 6
9232: NEG
9233: PPUSH
9234: CALL_OW 242
// result := result union sewiVeh ;
9238: LD_ADDR_VAR 0 2
9242: PUSH
9243: LD_VAR 0 2
9247: PUSH
9248: LD_EXP 71
9252: UNION
9253: ST_TO_ADDR
// end ; end ; end ;
9254: GO 9257
9256: POP
// end ;
9257: LD_VAR 0 2
9261: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9262: LD_EXP 16
9266: IFFALSE 10107
9268: GO 9270
9270: DISABLE
9271: LD_INT 0
9273: PPUSH
9274: PPUSH
9275: PPUSH
9276: PPUSH
9277: PPUSH
9278: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9279: LD_ADDR_VAR 0 4
9283: PUSH
9284: LD_INT 11
9286: PUSH
9287: LD_INT 12
9289: PUSH
9290: EMPTY
9291: LIST
9292: LIST
9293: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 ] [ Difficulty ] ;
9294: LD_ADDR_VAR 0 3
9298: PUSH
9299: LD_INT 11550
9301: PUSH
9302: LD_INT 10150
9304: PUSH
9305: LD_INT 9800
9307: PUSH
9308: EMPTY
9309: LIST
9310: LIST
9311: LIST
9312: PUSH
9313: LD_OWVAR 67
9317: ARRAY
9318: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9319: LD_ADDR_VAR 0 6
9323: PUSH
9324: LD_INT 70
9326: PUSH
9327: LD_INT 118
9329: PUSH
9330: EMPTY
9331: LIST
9332: LIST
9333: PUSH
9334: LD_INT 78
9336: PUSH
9337: LD_INT 31
9339: PUSH
9340: EMPTY
9341: LIST
9342: LIST
9343: PUSH
9344: EMPTY
9345: LIST
9346: LIST
9347: ST_TO_ADDR
// repeat if missionStage = 2 then
9348: LD_EXP 15
9352: PUSH
9353: LD_INT 2
9355: EQUAL
9356: IFFALSE 9367
// wait ( 1 1$30 ) else
9358: LD_INT 3150
9360: PPUSH
9361: CALL_OW 67
9365: GO 9376
// wait ( time ) ;
9367: LD_VAR 0 3
9371: PPUSH
9372: CALL_OW 67
// if missionStage = 6 then
9376: LD_EXP 15
9380: PUSH
9381: LD_INT 6
9383: EQUAL
9384: IFFALSE 9412
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9386: LD_INT 51
9388: PPUSH
9389: LD_INT 6
9391: PPUSH
9392: LD_INT 2
9394: PPUSH
9395: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9399: LD_INT 57
9401: PPUSH
9402: LD_INT 6
9404: PPUSH
9405: LD_INT 2
9407: PPUSH
9408: CALL_OW 322
// end ; if missionStage = 8 then
9412: LD_EXP 15
9416: PUSH
9417: LD_INT 8
9419: EQUAL
9420: IFFALSE 9448
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9422: LD_INT 52
9424: PPUSH
9425: LD_INT 6
9427: PPUSH
9428: LD_INT 2
9430: PPUSH
9431: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9435: LD_INT 58
9437: PPUSH
9438: LD_INT 6
9440: PPUSH
9441: LD_INT 2
9443: PPUSH
9444: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9448: LD_EXP 15
9452: PUSH
9453: LD_INT 10
9455: EQUAL
9456: PUSH
9457: LD_OWVAR 67
9461: PUSH
9462: LD_INT 1
9464: GREATER
9465: AND
9466: IFFALSE 9494
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9468: LD_INT 53
9470: PPUSH
9471: LD_INT 6
9473: PPUSH
9474: LD_INT 2
9476: PPUSH
9477: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9481: LD_INT 59
9483: PPUSH
9484: LD_INT 6
9486: PPUSH
9487: LD_INT 2
9489: PPUSH
9490: CALL_OW 322
// end ; if activeAttacks then
9494: LD_EXP 16
9498: IFFALSE 10101
// begin if missionStage = 2 then
9500: LD_EXP 15
9504: PUSH
9505: LD_INT 2
9507: EQUAL
9508: IFFALSE 9518
// strength := 1 ;
9510: LD_ADDR_VAR 0 5
9514: PUSH
9515: LD_INT 1
9517: ST_TO_ADDR
// if missionStage > 2 then
9518: LD_EXP 15
9522: PUSH
9523: LD_INT 2
9525: GREATER
9526: IFFALSE 9536
// strength := 2 ;
9528: LD_ADDR_VAR 0 5
9532: PUSH
9533: LD_INT 2
9535: ST_TO_ADDR
// if missionStage > 6 then
9536: LD_EXP 15
9540: PUSH
9541: LD_INT 6
9543: GREATER
9544: IFFALSE 9554
// strength := 3 ;
9546: LD_ADDR_VAR 0 5
9550: PUSH
9551: LD_INT 3
9553: ST_TO_ADDR
// if missionStage > 10 then
9554: LD_EXP 15
9558: PUSH
9559: LD_INT 10
9561: GREATER
9562: IFFALSE 9572
// strength := 4 ;
9564: LD_ADDR_VAR 0 5
9568: PUSH
9569: LD_INT 4
9571: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9572: LD_ADDR_VAR 0 2
9576: PUSH
9577: LD_VAR 0 5
9581: PPUSH
9582: CALL 8127 0 1
9586: ST_TO_ADDR
// for i in tmp do
9587: LD_ADDR_VAR 0 1
9591: PUSH
9592: LD_VAR 0 2
9596: PUSH
9597: FOR_IN
9598: IFFALSE 9781
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9600: LD_VAR 0 1
9604: PPUSH
9605: LD_VAR 0 4
9609: PUSH
9610: LD_INT 1
9612: PPUSH
9613: LD_INT 2
9615: PPUSH
9616: CALL_OW 12
9620: ARRAY
9621: PPUSH
9622: LD_INT 0
9624: PPUSH
9625: CALL_OW 49
// if i = sewiVeh then
9629: LD_VAR 0 1
9633: PUSH
9634: LD_EXP 71
9638: EQUAL
9639: IFFALSE 9676
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9641: LD_ADDR_EXP 70
9645: PUSH
9646: LD_STRING Vsevolod
9648: PPUSH
9649: LD_INT 0
9651: PPUSH
9652: LD_STRING 
9654: PPUSH
9655: CALL 65182 0 3
9659: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9660: LD_EXP 70
9664: PPUSH
9665: LD_VAR 0 1
9669: PPUSH
9670: CALL_OW 52
// end else
9674: GO 9757
// if GetControl ( i ) = control_manual then
9676: LD_VAR 0 1
9680: PPUSH
9681: CALL_OW 263
9685: PUSH
9686: LD_INT 1
9688: EQUAL
9689: IFFALSE 9757
// begin uc_side := 6 ;
9691: LD_ADDR_OWVAR 20
9695: PUSH
9696: LD_INT 6
9698: ST_TO_ADDR
// uc_nation := 3 ;
9699: LD_ADDR_OWVAR 21
9703: PUSH
9704: LD_INT 3
9706: ST_TO_ADDR
// hc_gallery :=  ;
9707: LD_ADDR_OWVAR 33
9711: PUSH
9712: LD_STRING 
9714: ST_TO_ADDR
// hc_name :=  ;
9715: LD_ADDR_OWVAR 26
9719: PUSH
9720: LD_STRING 
9722: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9723: LD_INT 0
9725: PPUSH
9726: LD_INT 3
9728: PPUSH
9729: LD_INT 10
9731: PPUSH
9732: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9736: CALL_OW 44
9740: PPUSH
9741: LD_VAR 0 1
9745: PPUSH
9746: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9750: LD_INT 10
9752: PPUSH
9753: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9757: LD_VAR 0 1
9761: PPUSH
9762: LD_INT 111
9764: PPUSH
9765: LD_INT 197
9767: PPUSH
9768: CALL_OW 111
// wait ( 0 0$2 ) ;
9772: LD_INT 70
9774: PPUSH
9775: CALL_OW 67
// end ;
9779: GO 9597
9781: POP
9782: POP
// repeat wait ( 0 0$1 ) ;
9783: LD_INT 35
9785: PPUSH
9786: CALL_OW 67
// for i in tmp do
9790: LD_ADDR_VAR 0 1
9794: PUSH
9795: LD_VAR 0 2
9799: PUSH
9800: FOR_IN
9801: IFFALSE 10082
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9803: LD_INT 81
9805: PUSH
9806: LD_INT 6
9808: PUSH
9809: EMPTY
9810: LIST
9811: LIST
9812: PUSH
9813: LD_INT 91
9815: PUSH
9816: LD_VAR 0 1
9820: PUSH
9821: LD_INT 12
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: LIST
9828: PUSH
9829: EMPTY
9830: LIST
9831: LIST
9832: PPUSH
9833: CALL_OW 69
9837: IFFALSE 9895
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9839: LD_VAR 0 1
9843: PPUSH
9844: LD_INT 81
9846: PUSH
9847: LD_INT 6
9849: PUSH
9850: EMPTY
9851: LIST
9852: LIST
9853: PUSH
9854: LD_INT 91
9856: PUSH
9857: LD_VAR 0 1
9861: PUSH
9862: LD_INT 12
9864: PUSH
9865: EMPTY
9866: LIST
9867: LIST
9868: LIST
9869: PUSH
9870: EMPTY
9871: LIST
9872: LIST
9873: PPUSH
9874: CALL_OW 69
9878: PPUSH
9879: LD_VAR 0 1
9883: PPUSH
9884: CALL_OW 74
9888: PPUSH
9889: CALL_OW 115
9893: GO 10080
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9895: LD_INT 9
9897: PPUSH
9898: LD_INT 81
9900: PUSH
9901: LD_INT 6
9903: PUSH
9904: EMPTY
9905: LIST
9906: LIST
9907: PPUSH
9908: CALL_OW 70
9912: IFFALSE 10046
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9914: LD_VAR 0 1
9918: PPUSH
9919: LD_VAR 0 6
9923: PUSH
9924: LD_INT 1
9926: ARRAY
9927: PUSH
9928: LD_INT 1
9930: ARRAY
9931: PPUSH
9932: LD_VAR 0 6
9936: PUSH
9937: LD_INT 1
9939: ARRAY
9940: PUSH
9941: LD_INT 2
9943: ARRAY
9944: PPUSH
9945: CALL_OW 297
9949: PUSH
9950: LD_INT 10
9952: GREATER
9953: PUSH
9954: LD_VAR 0 1
9958: PPUSH
9959: LD_INT 9
9961: PPUSH
9962: CALL_OW 308
9966: NOT
9967: AND
9968: IFFALSE 10007
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9970: LD_VAR 0 1
9974: PPUSH
9975: LD_VAR 0 6
9979: PUSH
9980: LD_INT 1
9982: ARRAY
9983: PUSH
9984: LD_INT 1
9986: ARRAY
9987: PPUSH
9988: LD_VAR 0 6
9992: PUSH
9993: LD_INT 1
9995: ARRAY
9996: PUSH
9997: LD_INT 2
9999: ARRAY
10000: PPUSH
10001: CALL_OW 114
10005: GO 10044
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
10007: LD_VAR 0 1
10011: PPUSH
10012: LD_INT 9
10014: PPUSH
10015: LD_INT 81
10017: PUSH
10018: LD_INT 6
10020: PUSH
10021: EMPTY
10022: LIST
10023: LIST
10024: PPUSH
10025: CALL_OW 70
10029: PPUSH
10030: LD_VAR 0 1
10034: PPUSH
10035: CALL_OW 74
10039: PPUSH
10040: CALL_OW 115
// end else
10044: GO 10080
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10046: LD_VAR 0 1
10050: PPUSH
10051: LD_INT 81
10053: PUSH
10054: LD_INT 6
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: PPUSH
10061: CALL_OW 69
10065: PPUSH
10066: LD_VAR 0 1
10070: PPUSH
10071: CALL_OW 74
10075: PPUSH
10076: CALL_OW 115
// end ;
10080: GO 9800
10082: POP
10083: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10084: LD_INT 22
10086: PUSH
10087: LD_INT 6
10089: PUSH
10090: EMPTY
10091: LIST
10092: LIST
10093: PPUSH
10094: CALL_OW 69
10098: NOT
10099: IFFALSE 9783
// end ; until russianDestroyed ;
10101: LD_EXP 21
10105: IFFALSE 9348
// end ;
10107: PPOPN 6
10109: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10110: LD_EXP 21
10114: NOT
10115: PUSH
10116: LD_EXP 15
10120: PUSH
10121: LD_INT 6
10123: GREATEREQUAL
10124: AND
10125: PUSH
10126: LD_INT 2
10128: PPUSH
10129: LD_INT 1
10131: PPUSH
10132: CALL 60237 0 2
10136: NOT
10137: AND
10138: IFFALSE 11094
10140: GO 10142
10142: DISABLE
10143: LD_INT 0
10145: PPUSH
10146: PPUSH
10147: PPUSH
10148: PPUSH
// begin enable ;
10149: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10150: LD_INT 22
10152: PUSH
10153: LD_INT 3
10155: PUSH
10156: EMPTY
10157: LIST
10158: LIST
10159: PUSH
10160: LD_INT 30
10162: PUSH
10163: LD_INT 3
10165: PUSH
10166: EMPTY
10167: LIST
10168: LIST
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PPUSH
10174: CALL_OW 69
10178: NOT
10179: IFFALSE 10183
// exit ;
10181: GO 11094
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10183: LD_ADDR_VAR 0 4
10187: PUSH
10188: LD_INT 22
10190: PUSH
10191: LD_INT 3
10193: PUSH
10194: EMPTY
10195: LIST
10196: LIST
10197: PUSH
10198: LD_INT 30
10200: PUSH
10201: LD_INT 34
10203: PUSH
10204: EMPTY
10205: LIST
10206: LIST
10207: PUSH
10208: EMPTY
10209: LIST
10210: LIST
10211: PPUSH
10212: CALL_OW 69
10216: ST_TO_ADDR
// if Prob ( 40 ) then
10217: LD_INT 40
10219: PPUSH
10220: CALL_OW 13
10224: IFFALSE 10351
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10226: LD_INT 2
10228: PPUSH
10229: LD_INT 22
10231: PUSH
10232: LD_INT 3
10234: PUSH
10235: LD_INT 3
10237: PUSH
10238: LD_INT 49
10240: PUSH
10241: EMPTY
10242: LIST
10243: LIST
10244: LIST
10245: LIST
10246: PUSH
10247: LD_INT 22
10249: PUSH
10250: LD_INT 3
10252: PUSH
10253: LD_INT 3
10255: PUSH
10256: LD_INT 49
10258: PUSH
10259: EMPTY
10260: LIST
10261: LIST
10262: LIST
10263: LIST
10264: PUSH
10265: LD_INT 22
10267: PUSH
10268: LD_INT 3
10270: PUSH
10271: LD_INT 3
10273: PUSH
10274: LD_INT 49
10276: PUSH
10277: EMPTY
10278: LIST
10279: LIST
10280: LIST
10281: LIST
10282: PUSH
10283: LD_INT 24
10285: PUSH
10286: LD_INT 3
10288: PUSH
10289: LD_INT 3
10291: PUSH
10292: LD_INT 46
10294: PUSH
10295: EMPTY
10296: LIST
10297: LIST
10298: LIST
10299: LIST
10300: PUSH
10301: LD_INT 24
10303: PUSH
10304: LD_INT 3
10306: PUSH
10307: LD_INT 3
10309: PUSH
10310: LD_INT 46
10312: PUSH
10313: EMPTY
10314: LIST
10315: LIST
10316: LIST
10317: LIST
10318: PUSH
10319: LD_INT 24
10321: PUSH
10322: LD_INT 3
10324: PUSH
10325: LD_INT 3
10327: PUSH
10328: LD_INT 46
10330: PUSH
10331: EMPTY
10332: LIST
10333: LIST
10334: LIST
10335: LIST
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: PPUSH
10345: CALL 58819 0 2
// end else
10349: GO 10474
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10351: LD_INT 2
10353: PPUSH
10354: LD_INT 24
10356: PUSH
10357: LD_INT 3
10359: PUSH
10360: LD_INT 3
10362: PUSH
10363: LD_INT 47
10365: PUSH
10366: EMPTY
10367: LIST
10368: LIST
10369: LIST
10370: LIST
10371: PUSH
10372: LD_INT 24
10374: PUSH
10375: LD_INT 3
10377: PUSH
10378: LD_INT 3
10380: PUSH
10381: LD_INT 47
10383: PUSH
10384: EMPTY
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: PUSH
10390: LD_INT 24
10392: PUSH
10393: LD_INT 3
10395: PUSH
10396: LD_INT 3
10398: PUSH
10399: LD_INT 47
10401: PUSH
10402: EMPTY
10403: LIST
10404: LIST
10405: LIST
10406: LIST
10407: PUSH
10408: LD_INT 24
10410: PUSH
10411: LD_INT 3
10413: PUSH
10414: LD_INT 3
10416: PUSH
10417: LD_INT 46
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: LIST
10424: LIST
10425: PUSH
10426: LD_INT 24
10428: PUSH
10429: LD_INT 3
10431: PUSH
10432: LD_INT 3
10434: PUSH
10435: LD_INT 46
10437: PUSH
10438: EMPTY
10439: LIST
10440: LIST
10441: LIST
10442: LIST
10443: PUSH
10444: LD_INT 24
10446: PUSH
10447: LD_INT 3
10449: PUSH
10450: LD_INT 3
10452: PUSH
10453: LD_INT 46
10455: PUSH
10456: EMPTY
10457: LIST
10458: LIST
10459: LIST
10460: LIST
10461: PUSH
10462: EMPTY
10463: LIST
10464: LIST
10465: LIST
10466: LIST
10467: LIST
10468: LIST
10469: PPUSH
10470: CALL 58819 0 2
// end ; if Difficulty > 1 then
10474: LD_OWVAR 67
10478: PUSH
10479: LD_INT 1
10481: GREATER
10482: IFFALSE 10512
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10484: LD_INT 2
10486: PPUSH
10487: LD_INT 24
10489: PUSH
10490: LD_INT 3
10492: PUSH
10493: LD_INT 3
10495: PUSH
10496: LD_INT 47
10498: PUSH
10499: EMPTY
10500: LIST
10501: LIST
10502: LIST
10503: LIST
10504: PUSH
10505: EMPTY
10506: LIST
10507: PPUSH
10508: CALL 58819 0 2
// repeat wait ( 0 0$1 ) ;
10512: LD_INT 35
10514: PPUSH
10515: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10519: LD_INT 2
10521: PPUSH
10522: LD_INT 1
10524: PPUSH
10525: CALL 60237 0 2
10529: PUSH
10530: LD_INT 6
10532: PUSH
10533: LD_INT 7
10535: PUSH
10536: LD_INT 7
10538: PUSH
10539: EMPTY
10540: LIST
10541: LIST
10542: LIST
10543: PUSH
10544: LD_OWVAR 67
10548: ARRAY
10549: GREATEREQUAL
10550: IFFALSE 10512
// wait ( 0 0$30 ) ;
10552: LD_INT 1050
10554: PPUSH
10555: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10559: LD_ADDR_VAR 0 2
10563: PUSH
10564: LD_INT 2
10566: PPUSH
10567: LD_INT 1
10569: PPUSH
10570: CALL 60237 0 2
10574: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10575: LD_ADDR_EXP 132
10579: PUSH
10580: LD_EXP 132
10584: PPUSH
10585: LD_INT 2
10587: PPUSH
10588: LD_EXP 132
10592: PUSH
10593: LD_INT 2
10595: ARRAY
10596: PUSH
10597: LD_VAR 0 2
10601: DIFF
10602: PPUSH
10603: CALL_OW 1
10607: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10608: LD_ADDR_VAR 0 3
10612: PUSH
10613: LD_INT 0
10615: PPUSH
10616: LD_INT 1
10618: PPUSH
10619: CALL_OW 12
10623: ST_TO_ADDR
// if target then
10624: LD_VAR 0 3
10628: IFFALSE 10756
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10630: LD_ADDR_VAR 0 2
10634: PUSH
10635: LD_VAR 0 2
10639: PPUSH
10640: LD_INT 24
10642: PUSH
10643: LD_INT 250
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: PPUSH
10650: CALL_OW 72
10654: ST_TO_ADDR
// for i in tmp do
10655: LD_ADDR_VAR 0 1
10659: PUSH
10660: LD_VAR 0 2
10664: PUSH
10665: FOR_IN
10666: IFFALSE 10706
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10668: LD_VAR 0 1
10672: PPUSH
10673: LD_INT 139
10675: PPUSH
10676: LD_INT 89
10678: PPUSH
10679: CALL_OW 297
10683: PUSH
10684: LD_INT 9
10686: GREATER
10687: IFFALSE 10704
// ComMoveXY ( i , 139 , 89 ) ;
10689: LD_VAR 0 1
10693: PPUSH
10694: LD_INT 139
10696: PPUSH
10697: LD_INT 89
10699: PPUSH
10700: CALL_OW 111
10704: GO 10665
10706: POP
10707: POP
// wait ( 0 0$1 ) ;
10708: LD_INT 35
10710: PPUSH
10711: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10715: LD_VAR 0 2
10719: PPUSH
10720: LD_INT 92
10722: PUSH
10723: LD_INT 139
10725: PUSH
10726: LD_INT 89
10728: PUSH
10729: LD_INT 9
10731: PUSH
10732: EMPTY
10733: LIST
10734: LIST
10735: LIST
10736: LIST
10737: PPUSH
10738: CALL_OW 72
10742: PUSH
10743: LD_VAR 0 2
10747: PUSH
10748: LD_INT 1
10750: MINUS
10751: GREATEREQUAL
10752: IFFALSE 10630
// end else
10754: GO 10898
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10756: LD_VAR 0 2
10760: PPUSH
10761: LD_VAR 0 4
10765: PUSH
10766: LD_INT 1
10768: ARRAY
10769: PPUSH
10770: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10774: LD_ADDR_VAR 0 2
10778: PUSH
10779: LD_VAR 0 2
10783: PPUSH
10784: LD_INT 24
10786: PUSH
10787: LD_INT 250
10789: PUSH
10790: EMPTY
10791: LIST
10792: LIST
10793: PPUSH
10794: CALL_OW 72
10798: ST_TO_ADDR
// for i in tmp do
10799: LD_ADDR_VAR 0 1
10803: PUSH
10804: LD_VAR 0 2
10808: PUSH
10809: FOR_IN
10810: IFFALSE 10850
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10812: LD_VAR 0 1
10816: PPUSH
10817: LD_INT 124
10819: PPUSH
10820: LD_INT 139
10822: PPUSH
10823: CALL_OW 297
10827: PUSH
10828: LD_INT 9
10830: GREATER
10831: IFFALSE 10848
// ComMoveXY ( i , 124 , 139 ) ;
10833: LD_VAR 0 1
10837: PPUSH
10838: LD_INT 124
10840: PPUSH
10841: LD_INT 139
10843: PPUSH
10844: CALL_OW 111
10848: GO 10809
10850: POP
10851: POP
// wait ( 0 0$1 ) ;
10852: LD_INT 35
10854: PPUSH
10855: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10859: LD_VAR 0 2
10863: PPUSH
10864: LD_INT 92
10866: PUSH
10867: LD_INT 124
10869: PUSH
10870: LD_INT 139
10872: PUSH
10873: LD_INT 9
10875: PUSH
10876: EMPTY
10877: LIST
10878: LIST
10879: LIST
10880: LIST
10881: PPUSH
10882: CALL_OW 72
10886: PUSH
10887: LD_VAR 0 2
10891: PUSH
10892: LD_INT 1
10894: MINUS
10895: GREATEREQUAL
10896: IFFALSE 10774
// end ; repeat wait ( 0 0$1 ) ;
10898: LD_INT 35
10900: PPUSH
10901: CALL_OW 67
// for i in tmp do
10905: LD_ADDR_VAR 0 1
10909: PUSH
10910: LD_VAR 0 2
10914: PUSH
10915: FOR_IN
10916: IFFALSE 11085
// begin if GetLives ( i ) > 251 then
10918: LD_VAR 0 1
10922: PPUSH
10923: CALL_OW 256
10927: PUSH
10928: LD_INT 251
10930: GREATER
10931: IFFALSE 11056
// begin if GetWeapon ( i ) = ru_time_lapser then
10933: LD_VAR 0 1
10937: PPUSH
10938: CALL_OW 264
10942: PUSH
10943: LD_INT 49
10945: EQUAL
10946: IFFALSE 11002
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10948: LD_VAR 0 1
10952: PPUSH
10953: LD_INT 2
10955: PUSH
10956: LD_INT 22
10958: PUSH
10959: LD_INT 1
10961: PUSH
10962: EMPTY
10963: LIST
10964: LIST
10965: PUSH
10966: LD_INT 22
10968: PUSH
10969: LD_INT 8
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: PUSH
10976: EMPTY
10977: LIST
10978: LIST
10979: LIST
10980: PPUSH
10981: CALL_OW 69
10985: PPUSH
10986: LD_VAR 0 1
10990: PPUSH
10991: CALL_OW 74
10995: PPUSH
10996: CALL_OW 112
11000: GO 11054
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11002: LD_VAR 0 1
11006: PPUSH
11007: LD_INT 2
11009: PUSH
11010: LD_INT 22
11012: PUSH
11013: LD_INT 1
11015: PUSH
11016: EMPTY
11017: LIST
11018: LIST
11019: PUSH
11020: LD_INT 22
11022: PUSH
11023: LD_INT 8
11025: PUSH
11026: EMPTY
11027: LIST
11028: LIST
11029: PUSH
11030: EMPTY
11031: LIST
11032: LIST
11033: LIST
11034: PPUSH
11035: CALL_OW 69
11039: PPUSH
11040: LD_VAR 0 1
11044: PPUSH
11045: CALL_OW 74
11049: PPUSH
11050: CALL_OW 115
// end else
11054: GO 11083
// if IsDead ( i ) then
11056: LD_VAR 0 1
11060: PPUSH
11061: CALL_OW 301
11065: IFFALSE 11083
// tmp := tmp diff i ;
11067: LD_ADDR_VAR 0 2
11071: PUSH
11072: LD_VAR 0 2
11076: PUSH
11077: LD_VAR 0 1
11081: DIFF
11082: ST_TO_ADDR
// end ;
11083: GO 10915
11085: POP
11086: POP
// until not tmp ;
11087: LD_VAR 0 2
11091: NOT
11092: IFFALSE 10898
// end ; end_of_file
11094: PPOPN 4
11096: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11097: LD_INT 0
11099: PPUSH
11100: PPUSH
11101: PPUSH
11102: PPUSH
11103: PPUSH
11104: PPUSH
// side := 7 ;
11105: LD_ADDR_VAR 0 5
11109: PUSH
11110: LD_INT 7
11112: ST_TO_ADDR
// uc_side := side ;
11113: LD_ADDR_OWVAR 20
11117: PUSH
11118: LD_VAR 0 5
11122: ST_TO_ADDR
// uc_nation := 1 ;
11123: LD_ADDR_OWVAR 21
11127: PUSH
11128: LD_INT 1
11130: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11131: LD_ADDR_VAR 0 2
11135: PUSH
11136: LD_INT 22
11138: PUSH
11139: LD_VAR 0 5
11143: PUSH
11144: EMPTY
11145: LIST
11146: LIST
11147: PUSH
11148: LD_INT 21
11150: PUSH
11151: LD_INT 3
11153: PUSH
11154: EMPTY
11155: LIST
11156: LIST
11157: PUSH
11158: EMPTY
11159: LIST
11160: LIST
11161: PPUSH
11162: CALL_OW 69
11166: PUSH
11167: FOR_IN
11168: IFFALSE 11184
// SetBLevel ( i , 10 ) ;
11170: LD_VAR 0 2
11174: PPUSH
11175: LD_INT 10
11177: PPUSH
11178: CALL_OW 241
11182: GO 11167
11184: POP
11185: POP
// base := GetBase ( al_depot ) ;
11186: LD_ADDR_VAR 0 4
11190: PUSH
11191: LD_INT 2
11193: PPUSH
11194: CALL_OW 274
11198: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11199: LD_ADDR_VAR 0 6
11203: PUSH
11204: LD_INT 22
11206: PUSH
11207: LD_VAR 0 5
11211: PUSH
11212: EMPTY
11213: LIST
11214: LIST
11215: PUSH
11216: LD_INT 30
11218: PUSH
11219: LD_INT 34
11221: PUSH
11222: EMPTY
11223: LIST
11224: LIST
11225: PUSH
11226: EMPTY
11227: LIST
11228: LIST
11229: PPUSH
11230: CALL_OW 69
11234: ST_TO_ADDR
// if teleport then
11235: LD_VAR 0 6
11239: IFFALSE 11260
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11241: LD_VAR 0 6
11245: PUSH
11246: LD_INT 1
11248: ARRAY
11249: PPUSH
11250: LD_INT 262
11252: PPUSH
11253: LD_INT 119
11255: PPUSH
11256: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11260: LD_VAR 0 4
11264: PPUSH
11265: LD_INT 1
11267: PPUSH
11268: LD_INT 19500
11270: PPUSH
11271: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11275: LD_VAR 0 4
11279: PPUSH
11280: LD_INT 2
11282: PPUSH
11283: LD_INT 200
11285: PPUSH
11286: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11290: LD_VAR 0 4
11294: PPUSH
11295: LD_INT 3
11297: PPUSH
11298: LD_INT 650
11300: PPUSH
11301: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11305: LD_ADDR_EXP 74
11309: PUSH
11310: LD_STRING Roth
11312: PPUSH
11313: CALL_OW 25
11317: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11318: LD_ADDR_EXP 75
11322: PUSH
11323: LD_STRING Simms
11325: PPUSH
11326: LD_EXP 1
11330: NOT
11331: PPUSH
11332: LD_STRING 10c_
11334: PPUSH
11335: CALL 65182 0 3
11339: ST_TO_ADDR
// if not Simms then
11340: LD_EXP 75
11344: NOT
11345: IFFALSE 11375
// begin uc_nation := 1 ;
11347: LD_ADDR_OWVAR 21
11351: PUSH
11352: LD_INT 1
11354: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11355: LD_INT 2
11357: PPUSH
11358: LD_INT 10
11360: PPUSH
11361: CALL_OW 384
// Simms := CreateHuman ;
11365: LD_ADDR_EXP 75
11369: PUSH
11370: CALL_OW 44
11374: ST_TO_ADDR
// end ; uc_nation := 3 ;
11375: LD_ADDR_OWVAR 21
11379: PUSH
11380: LD_INT 3
11382: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11383: LD_ADDR_EXP 76
11387: PUSH
11388: LD_STRING Kirilenkova
11390: PPUSH
11391: CALL_OW 25
11395: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11396: LD_ADDR_EXP 90
11400: PUSH
11401: LD_STRING Oblukov
11403: PPUSH
11404: CALL_OW 25
11408: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11409: LD_ADDR_EXP 77
11413: PUSH
11414: LD_STRING Dolgov
11416: PPUSH
11417: CALL_OW 25
11421: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11422: LD_ADDR_EXP 78
11426: PUSH
11427: LD_STRING Petrosyan
11429: PPUSH
11430: CALL_OW 25
11434: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11435: LD_ADDR_EXP 89
11439: PUSH
11440: LD_STRING Scholtze
11442: PPUSH
11443: CALL_OW 25
11447: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11448: LD_ADDR_EXP 88
11452: PUSH
11453: LD_STRING Kapitsova
11455: PPUSH
11456: CALL_OW 25
11460: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11461: LD_ADDR_EXP 79
11465: PUSH
11466: LD_STRING Petrovova
11468: PPUSH
11469: CALL_OW 25
11473: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11474: LD_ADDR_EXP 80
11478: PUSH
11479: LD_STRING Kuzmov
11481: PPUSH
11482: CALL_OW 25
11486: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11487: LD_ADDR_EXP 87
11491: PUSH
11492: LD_STRING Karamazov
11494: PPUSH
11495: CALL_OW 25
11499: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11500: LD_STRING 13_Lipshchin_1
11502: PPUSH
11503: LD_INT 0
11505: PPUSH
11506: CALL_OW 30
11510: IFFALSE 11525
// Lipshchin := NewCharacter ( Lipshchin ) ;
11512: LD_ADDR_EXP 81
11516: PUSH
11517: LD_STRING Lipshchin
11519: PPUSH
11520: CALL_OW 25
11524: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11525: LD_STRING 13_Titov_1
11527: PPUSH
11528: LD_INT 0
11530: PPUSH
11531: CALL_OW 30
11535: IFFALSE 11550
// Titov := NewCharacter ( Titov ) ;
11537: LD_ADDR_EXP 83
11541: PUSH
11542: LD_STRING Titov
11544: PPUSH
11545: CALL_OW 25
11549: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11550: LD_STRING 13_Gnyevko_1
11552: PPUSH
11553: LD_INT 0
11555: PPUSH
11556: CALL_OW 30
11560: IFFALSE 11575
// Gnyevko := NewCharacter ( Gnyevko ) ;
11562: LD_ADDR_EXP 82
11566: PUSH
11567: LD_STRING Gnyevko
11569: PPUSH
11570: CALL_OW 25
11574: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11575: LD_STRING 13_Xavier_1
11577: PPUSH
11578: LD_INT 0
11580: PPUSH
11581: CALL_OW 30
11585: IFFALSE 11600
// Xavier := NewCharacter ( Xavier2 ) ;
11587: LD_ADDR_EXP 84
11591: PUSH
11592: LD_STRING Xavier2
11594: PPUSH
11595: CALL_OW 25
11599: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11600: LD_STRING 13_Belkov_1
11602: PPUSH
11603: LD_INT 0
11605: PPUSH
11606: CALL_OW 30
11610: IFFALSE 11625
// Belkov := NewCharacter ( Belkov ) ;
11612: LD_ADDR_EXP 85
11616: PUSH
11617: LD_STRING Belkov
11619: PPUSH
11620: CALL_OW 25
11624: ST_TO_ADDR
// if not BurlakStatus then
11625: LD_EXP 9
11629: NOT
11630: IFFALSE 11645
// Burlak = NewCharacter ( Burlak ) ;
11632: LD_ADDR_EXP 86
11636: PUSH
11637: LD_STRING Burlak
11639: PPUSH
11640: CALL_OW 25
11644: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11645: LD_ADDR_VAR 0 3
11649: PUSH
11650: LD_EXP 74
11654: PUSH
11655: LD_EXP 76
11659: PUSH
11660: LD_EXP 90
11664: PUSH
11665: LD_EXP 77
11669: PUSH
11670: LD_EXP 78
11674: PUSH
11675: LD_EXP 89
11679: PUSH
11680: LD_EXP 88
11684: PUSH
11685: LD_EXP 79
11689: PUSH
11690: LD_EXP 80
11694: PUSH
11695: LD_EXP 87
11699: PUSH
11700: EMPTY
11701: LIST
11702: LIST
11703: LIST
11704: LIST
11705: LIST
11706: LIST
11707: LIST
11708: LIST
11709: LIST
11710: LIST
11711: ST_TO_ADDR
// if Simms then
11712: LD_EXP 75
11716: IFFALSE 11734
// tmp := tmp ^ Simms ;
11718: LD_ADDR_VAR 0 3
11722: PUSH
11723: LD_VAR 0 3
11727: PUSH
11728: LD_EXP 75
11732: ADD
11733: ST_TO_ADDR
// if Titov then
11734: LD_EXP 83
11738: IFFALSE 11756
// tmp := tmp ^ Titov ;
11740: LD_ADDR_VAR 0 3
11744: PUSH
11745: LD_VAR 0 3
11749: PUSH
11750: LD_EXP 83
11754: ADD
11755: ST_TO_ADDR
// if Lipshchin then
11756: LD_EXP 81
11760: IFFALSE 11778
// tmp := tmp ^ Lipshchin ;
11762: LD_ADDR_VAR 0 3
11766: PUSH
11767: LD_VAR 0 3
11771: PUSH
11772: LD_EXP 81
11776: ADD
11777: ST_TO_ADDR
// if Gnyevko then
11778: LD_EXP 82
11782: IFFALSE 11800
// tmp := tmp ^ Gnyevko ;
11784: LD_ADDR_VAR 0 3
11788: PUSH
11789: LD_VAR 0 3
11793: PUSH
11794: LD_EXP 82
11798: ADD
11799: ST_TO_ADDR
// if Xavier then
11800: LD_EXP 84
11804: IFFALSE 11822
// tmp := tmp ^ Xavier ;
11806: LD_ADDR_VAR 0 3
11810: PUSH
11811: LD_VAR 0 3
11815: PUSH
11816: LD_EXP 84
11820: ADD
11821: ST_TO_ADDR
// if Belkov then
11822: LD_EXP 85
11826: IFFALSE 11844
// tmp := tmp ^ Belkov ;
11828: LD_ADDR_VAR 0 3
11832: PUSH
11833: LD_VAR 0 3
11837: PUSH
11838: LD_EXP 85
11842: ADD
11843: ST_TO_ADDR
// if Burlak then
11844: LD_EXP 86
11848: IFFALSE 11866
// tmp := tmp ^ Burlak ;
11850: LD_ADDR_VAR 0 3
11854: PUSH
11855: LD_VAR 0 3
11859: PUSH
11860: LD_EXP 86
11864: ADD
11865: ST_TO_ADDR
// for i = 1 to 11 do
11866: LD_ADDR_VAR 0 2
11870: PUSH
11871: DOUBLE
11872: LD_INT 1
11874: DEC
11875: ST_TO_ADDR
11876: LD_INT 11
11878: PUSH
11879: FOR_TO
11880: IFFALSE 11946
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11882: LD_ADDR_OWVAR 21
11886: PUSH
11887: LD_INT 1
11889: PUSH
11890: LD_INT 3
11892: PUSH
11893: EMPTY
11894: LIST
11895: LIST
11896: PUSH
11897: LD_INT 1
11899: PPUSH
11900: LD_INT 2
11902: PPUSH
11903: CALL_OW 12
11907: ARRAY
11908: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11909: LD_INT 0
11911: PPUSH
11912: LD_VAR 0 2
11916: PUSH
11917: LD_INT 2
11919: DIV
11920: PPUSH
11921: LD_INT 10
11923: PPUSH
11924: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11928: LD_ADDR_VAR 0 3
11932: PUSH
11933: LD_VAR 0 3
11937: PUSH
11938: CALL_OW 44
11942: ADD
11943: ST_TO_ADDR
// end ;
11944: GO 11879
11946: POP
11947: POP
// for i in tmp do
11948: LD_ADDR_VAR 0 2
11952: PUSH
11953: LD_VAR 0 3
11957: PUSH
11958: FOR_IN
11959: IFFALSE 11984
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11961: LD_VAR 0 2
11965: PPUSH
11966: LD_INT 260
11968: PPUSH
11969: LD_INT 235
11971: PPUSH
11972: LD_INT 8
11974: PPUSH
11975: LD_INT 0
11977: PPUSH
11978: CALL_OW 50
11982: GO 11958
11984: POP
11985: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11986: LD_ADDR_EXP 113
11990: PUSH
11991: LD_EXP 113
11995: PPUSH
11996: LD_INT 1
11998: PPUSH
11999: LD_INT 22
12001: PUSH
12002: LD_VAR 0 5
12006: PUSH
12007: EMPTY
12008: LIST
12009: LIST
12010: PUSH
12011: LD_INT 3
12013: PUSH
12014: LD_INT 21
12016: PUSH
12017: LD_INT 2
12019: PUSH
12020: EMPTY
12021: LIST
12022: LIST
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: EMPTY
12029: LIST
12030: LIST
12031: PPUSH
12032: CALL_OW 69
12036: PUSH
12037: LD_EXP 74
12041: PUSH
12042: LD_EXP 75
12046: PUSH
12047: EMPTY
12048: LIST
12049: LIST
12050: DIFF
12051: PPUSH
12052: CALL_OW 1
12056: ST_TO_ADDR
// uc_side := 0 ;
12057: LD_ADDR_OWVAR 20
12061: PUSH
12062: LD_INT 0
12064: ST_TO_ADDR
// uc_nation := 0 ;
12065: LD_ADDR_OWVAR 21
12069: PUSH
12070: LD_INT 0
12072: ST_TO_ADDR
// for i = 1 to 5 do
12073: LD_ADDR_VAR 0 2
12077: PUSH
12078: DOUBLE
12079: LD_INT 1
12081: DEC
12082: ST_TO_ADDR
12083: LD_INT 5
12085: PUSH
12086: FOR_TO
12087: IFFALSE 12124
// begin InitHc ;
12089: CALL_OW 19
// hc_class := class_apeman ;
12093: LD_ADDR_OWVAR 28
12097: PUSH
12098: LD_INT 12
12100: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12101: CALL_OW 44
12105: PPUSH
12106: LD_INT 299
12108: PPUSH
12109: LD_INT 229
12111: PPUSH
12112: LD_INT 10
12114: PPUSH
12115: LD_INT 0
12117: PPUSH
12118: CALL_OW 50
// end ;
12122: GO 12086
12124: POP
12125: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12126: LD_EXP 74
12130: PPUSH
12131: LD_INT 259
12133: PPUSH
12134: LD_INT 235
12136: PPUSH
12137: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12141: LD_EXP 74
12145: PPUSH
12146: LD_INT 262
12148: PPUSH
12149: LD_INT 235
12151: PPUSH
12152: CALL_OW 178
// if Simms then
12156: LD_EXP 75
12160: IFFALSE 12191
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12162: LD_EXP 75
12166: PPUSH
12167: LD_INT 262
12169: PPUSH
12170: LD_INT 235
12172: PPUSH
12173: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12177: LD_EXP 75
12181: PPUSH
12182: LD_EXP 74
12186: PPUSH
12187: CALL_OW 179
// end ; end ;
12191: LD_VAR 0 1
12195: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12196: LD_EXP 31
12200: PUSH
12201: LD_EXP 23
12205: NOT
12206: AND
12207: IFFALSE 12383
12209: GO 12211
12211: DISABLE
12212: LD_INT 0
12214: PPUSH
12215: PPUSH
12216: PPUSH
// begin enable ;
12217: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12218: LD_ADDR_VAR 0 2
12222: PUSH
12223: LD_INT 81
12225: PUSH
12226: LD_INT 7
12228: PUSH
12229: EMPTY
12230: LIST
12231: LIST
12232: PUSH
12233: LD_INT 2
12235: PUSH
12236: LD_INT 32
12238: PUSH
12239: LD_INT 3
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: PUSH
12246: LD_INT 30
12248: PUSH
12249: LD_INT 30
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: PUSH
12256: LD_INT 30
12258: PUSH
12259: LD_INT 28
12261: PUSH
12262: EMPTY
12263: LIST
12264: LIST
12265: PUSH
12266: LD_INT 34
12268: PUSH
12269: LD_INT 49
12271: PUSH
12272: EMPTY
12273: LIST
12274: LIST
12275: PUSH
12276: LD_INT 34
12278: PUSH
12279: LD_INT 10
12281: PUSH
12282: EMPTY
12283: LIST
12284: LIST
12285: PUSH
12286: LD_INT 34
12288: PUSH
12289: LD_INT 8
12291: PUSH
12292: EMPTY
12293: LIST
12294: LIST
12295: PUSH
12296: EMPTY
12297: LIST
12298: LIST
12299: LIST
12300: LIST
12301: LIST
12302: LIST
12303: LIST
12304: PUSH
12305: EMPTY
12306: LIST
12307: LIST
12308: PPUSH
12309: CALL_OW 69
12313: ST_TO_ADDR
// if not tmp then
12314: LD_VAR 0 2
12318: NOT
12319: IFFALSE 12323
// exit ;
12321: GO 12383
// target := tmp [ rand ( 1 , tmp ) ] ;
12323: LD_ADDR_VAR 0 3
12327: PUSH
12328: LD_VAR 0 2
12332: PUSH
12333: LD_INT 1
12335: PPUSH
12336: LD_VAR 0 2
12340: PPUSH
12341: CALL_OW 12
12345: ARRAY
12346: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12347: LD_VAR 0 3
12351: PPUSH
12352: CALL_OW 255
12356: PUSH
12357: LD_INT 1
12359: EQUAL
12360: IFFALSE 12371
// CenterNowOnUnits ( target ) ;
12362: LD_VAR 0 3
12366: PPUSH
12367: CALL_OW 87
// SetLives ( target , 0 ) ;
12371: LD_VAR 0 3
12375: PPUSH
12376: LD_INT 0
12378: PPUSH
12379: CALL_OW 234
// end ;
12383: PPOPN 3
12385: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12386: LD_EXP 23
12390: NOT
12391: PUSH
12392: LD_EXP 31
12396: AND
12397: IFFALSE 12919
12399: GO 12401
12401: DISABLE
12402: LD_INT 0
12404: PPUSH
12405: PPUSH
12406: PPUSH
// begin uc_side := 7 ;
12407: LD_ADDR_OWVAR 20
12411: PUSH
12412: LD_INT 7
12414: ST_TO_ADDR
// uc_nation := 1 ;
12415: LD_ADDR_OWVAR 21
12419: PUSH
12420: LD_INT 1
12422: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12423: LD_ADDR_VAR 0 3
12427: PUSH
12428: LD_INT 125
12430: PUSH
12431: LD_INT 163
12433: PUSH
12434: EMPTY
12435: LIST
12436: LIST
12437: PUSH
12438: LD_INT 185
12440: PUSH
12441: LD_INT 168
12443: PUSH
12444: EMPTY
12445: LIST
12446: LIST
12447: PUSH
12448: LD_INT 111
12450: PUSH
12451: LD_INT 97
12453: PUSH
12454: EMPTY
12455: LIST
12456: LIST
12457: PUSH
12458: EMPTY
12459: LIST
12460: LIST
12461: LIST
12462: PPUSH
12463: CALL 101276 0 1
12467: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12468: LD_ADDR_EXP 91
12472: PUSH
12473: EMPTY
12474: ST_TO_ADDR
// for i = 1 to Difficulty do
12475: LD_ADDR_VAR 0 1
12479: PUSH
12480: DOUBLE
12481: LD_INT 1
12483: DEC
12484: ST_TO_ADDR
12485: LD_OWVAR 67
12489: PUSH
12490: FOR_TO
12491: IFFALSE 12649
// begin InitHc ;
12493: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12497: LD_INT 0
12499: PPUSH
12500: LD_INT 8
12502: PPUSH
12503: CALL_OW 381
// un := CreateHuman ;
12507: LD_ADDR_VAR 0 2
12511: PUSH
12512: CALL_OW 44
12516: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12517: LD_VAR 0 2
12521: PPUSH
12522: LD_INT 258
12524: PPUSH
12525: LD_INT 267
12527: PPUSH
12528: LD_INT 4
12530: PPUSH
12531: LD_INT 0
12533: PPUSH
12534: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12538: LD_ADDR_EXP 91
12542: PUSH
12543: LD_EXP 91
12547: PUSH
12548: LD_VAR 0 2
12552: UNION
12553: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12554: LD_VAR 0 2
12558: PPUSH
12559: LD_VAR 0 3
12563: PUSH
12564: LD_VAR 0 1
12568: ARRAY
12569: PUSH
12570: LD_INT 1
12572: ARRAY
12573: PPUSH
12574: LD_VAR 0 3
12578: PUSH
12579: LD_VAR 0 1
12583: ARRAY
12584: PUSH
12585: LD_INT 2
12587: ARRAY
12588: PPUSH
12589: LD_INT 4
12591: PPUSH
12592: LD_INT 1
12594: PPUSH
12595: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12599: LD_VAR 0 2
12603: PPUSH
12604: LD_VAR 0 3
12608: PUSH
12609: LD_VAR 0 1
12613: ARRAY
12614: PUSH
12615: LD_INT 1
12617: ARRAY
12618: PPUSH
12619: LD_VAR 0 3
12623: PUSH
12624: LD_VAR 0 1
12628: ARRAY
12629: PUSH
12630: LD_INT 2
12632: ARRAY
12633: PPUSH
12634: CALL_OW 171
// AddComInvisible ( un ) ;
12638: LD_VAR 0 2
12642: PPUSH
12643: CALL_OW 212
// end ;
12647: GO 12490
12649: POP
12650: POP
// repeat wait ( 0 0$20 ) ;
12651: LD_INT 700
12653: PPUSH
12654: CALL_OW 67
// for i in allianceSpecialForce do
12658: LD_ADDR_VAR 0 1
12662: PUSH
12663: LD_EXP 91
12667: PUSH
12668: FOR_IN
12669: IFFALSE 12904
// begin if IsInvisible ( i ) then
12671: LD_VAR 0 1
12675: PPUSH
12676: CALL_OW 571
12680: IFFALSE 12873
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12682: LD_ADDR_VAR 0 3
12686: PUSH
12687: LD_INT 22
12689: PUSH
12690: LD_INT 1
12692: PUSH
12693: EMPTY
12694: LIST
12695: LIST
12696: PUSH
12697: LD_INT 50
12699: PUSH
12700: EMPTY
12701: LIST
12702: PUSH
12703: LD_INT 56
12705: PUSH
12706: EMPTY
12707: LIST
12708: PUSH
12709: LD_INT 91
12711: PUSH
12712: LD_VAR 0 1
12716: PUSH
12717: LD_INT 25
12719: PUSH
12720: LD_INT 30
12722: PUSH
12723: LD_INT 35
12725: PUSH
12726: EMPTY
12727: LIST
12728: LIST
12729: LIST
12730: PUSH
12731: LD_OWVAR 67
12735: ARRAY
12736: PUSH
12737: EMPTY
12738: LIST
12739: LIST
12740: LIST
12741: PUSH
12742: LD_INT 2
12744: PUSH
12745: LD_INT 25
12747: PUSH
12748: LD_INT 1
12750: PUSH
12751: EMPTY
12752: LIST
12753: LIST
12754: PUSH
12755: LD_INT 25
12757: PUSH
12758: LD_INT 2
12760: PUSH
12761: EMPTY
12762: LIST
12763: LIST
12764: PUSH
12765: LD_INT 25
12767: PUSH
12768: LD_INT 3
12770: PUSH
12771: EMPTY
12772: LIST
12773: LIST
12774: PUSH
12775: LD_INT 25
12777: PUSH
12778: LD_INT 4
12780: PUSH
12781: EMPTY
12782: LIST
12783: LIST
12784: PUSH
12785: LD_INT 25
12787: PUSH
12788: LD_INT 5
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: PUSH
12795: LD_INT 25
12797: PUSH
12798: LD_INT 8
12800: PUSH
12801: EMPTY
12802: LIST
12803: LIST
12804: PUSH
12805: EMPTY
12806: LIST
12807: LIST
12808: LIST
12809: LIST
12810: LIST
12811: LIST
12812: LIST
12813: PUSH
12814: EMPTY
12815: LIST
12816: LIST
12817: LIST
12818: LIST
12819: LIST
12820: PPUSH
12821: CALL_OW 69
12825: ST_TO_ADDR
// if not tmp then
12826: LD_VAR 0 3
12830: NOT
12831: IFFALSE 12835
// continue ;
12833: GO 12668
// if Prob ( 30 * Difficulty ) then
12835: LD_INT 30
12837: PUSH
12838: LD_OWVAR 67
12842: MUL
12843: PPUSH
12844: CALL_OW 13
12848: IFFALSE 12873
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12850: LD_VAR 0 3
12854: PUSH
12855: LD_INT 1
12857: PPUSH
12858: LD_VAR 0 3
12862: PPUSH
12863: CALL_OW 12
12867: ARRAY
12868: PPUSH
12869: CALL 31166 0 1
// end ; if IsDead ( i ) then
12873: LD_VAR 0 1
12877: PPUSH
12878: CALL_OW 301
12882: IFFALSE 12902
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12884: LD_ADDR_EXP 91
12888: PUSH
12889: LD_EXP 91
12893: PUSH
12894: LD_VAR 0 1
12898: DIFF
12899: ST_TO_ADDR
// continue ;
12900: GO 12668
// end ; end ;
12902: GO 12668
12904: POP
12905: POP
// until allianceDestroyed or not allianceSpecialForce ;
12906: LD_EXP 23
12910: PUSH
12911: LD_EXP 91
12915: NOT
12916: OR
12917: IFFALSE 12651
// end ;
12919: PPOPN 3
12921: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12922: LD_EXP 23
12926: NOT
12927: PUSH
12928: LD_EXP 31
12932: AND
12933: IFFALSE 13900
12935: GO 12937
12937: DISABLE
12938: LD_INT 0
12940: PPUSH
12941: PPUSH
12942: PPUSH
12943: PPUSH
// begin enable ;
12944: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12945: LD_INT 22
12947: PUSH
12948: LD_INT 7
12950: PUSH
12951: EMPTY
12952: LIST
12953: LIST
12954: PUSH
12955: LD_INT 30
12957: PUSH
12958: LD_INT 3
12960: PUSH
12961: EMPTY
12962: LIST
12963: LIST
12964: PUSH
12965: EMPTY
12966: LIST
12967: LIST
12968: PPUSH
12969: CALL_OW 69
12973: NOT
12974: IFFALSE 12978
// exit ;
12976: GO 13900
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12978: LD_ADDR_VAR 0 4
12982: PUSH
12983: LD_INT 22
12985: PUSH
12986: LD_INT 7
12988: PUSH
12989: EMPTY
12990: LIST
12991: LIST
12992: PUSH
12993: LD_INT 30
12995: PUSH
12996: LD_INT 34
12998: PUSH
12999: EMPTY
13000: LIST
13001: LIST
13002: PUSH
13003: EMPTY
13004: LIST
13005: LIST
13006: PPUSH
13007: CALL_OW 69
13011: ST_TO_ADDR
// if Prob ( 40 ) then
13012: LD_INT 40
13014: PPUSH
13015: CALL_OW 13
13019: IFFALSE 13146
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
13021: LD_INT 1
13023: PPUSH
13024: LD_INT 5
13026: PUSH
13027: LD_INT 3
13029: PUSH
13030: LD_INT 2
13032: PUSH
13033: LD_INT 6
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: LIST
13040: LIST
13041: PUSH
13042: LD_INT 5
13044: PUSH
13045: LD_INT 3
13047: PUSH
13048: LD_INT 2
13050: PUSH
13051: LD_INT 6
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: LIST
13058: LIST
13059: PUSH
13060: LD_INT 5
13062: PUSH
13063: LD_INT 3
13065: PUSH
13066: LD_INT 2
13068: PUSH
13069: LD_INT 6
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: LIST
13076: LIST
13077: PUSH
13078: LD_INT 24
13080: PUSH
13081: LD_INT 3
13083: PUSH
13084: LD_INT 3
13086: PUSH
13087: LD_INT 45
13089: PUSH
13090: EMPTY
13091: LIST
13092: LIST
13093: LIST
13094: LIST
13095: PUSH
13096: LD_INT 24
13098: PUSH
13099: LD_INT 3
13101: PUSH
13102: LD_INT 3
13104: PUSH
13105: LD_INT 47
13107: PUSH
13108: EMPTY
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: PUSH
13114: LD_INT 24
13116: PUSH
13117: LD_INT 3
13119: PUSH
13120: LD_INT 3
13122: PUSH
13123: LD_INT 45
13125: PUSH
13126: EMPTY
13127: LIST
13128: LIST
13129: LIST
13130: LIST
13131: PUSH
13132: EMPTY
13133: LIST
13134: LIST
13135: LIST
13136: LIST
13137: LIST
13138: LIST
13139: PPUSH
13140: CALL 58819 0 2
// end else
13144: GO 13269
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13146: LD_INT 1
13148: PPUSH
13149: LD_INT 24
13151: PUSH
13152: LD_INT 3
13154: PUSH
13155: LD_INT 3
13157: PUSH
13158: LD_INT 47
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: LIST
13165: LIST
13166: PUSH
13167: LD_INT 24
13169: PUSH
13170: LD_INT 3
13172: PUSH
13173: LD_INT 3
13175: PUSH
13176: LD_INT 47
13178: PUSH
13179: EMPTY
13180: LIST
13181: LIST
13182: LIST
13183: LIST
13184: PUSH
13185: LD_INT 5
13187: PUSH
13188: LD_INT 3
13190: PUSH
13191: LD_INT 2
13193: PUSH
13194: LD_INT 9
13196: PUSH
13197: EMPTY
13198: LIST
13199: LIST
13200: LIST
13201: LIST
13202: PUSH
13203: LD_INT 5
13205: PUSH
13206: LD_INT 3
13208: PUSH
13209: LD_INT 2
13211: PUSH
13212: LD_INT 9
13214: PUSH
13215: EMPTY
13216: LIST
13217: LIST
13218: LIST
13219: LIST
13220: PUSH
13221: LD_INT 24
13223: PUSH
13224: LD_INT 1
13226: PUSH
13227: LD_INT 3
13229: PUSH
13230: LD_INT 45
13232: PUSH
13233: EMPTY
13234: LIST
13235: LIST
13236: LIST
13237: LIST
13238: PUSH
13239: LD_INT 24
13241: PUSH
13242: LD_INT 1
13244: PUSH
13245: LD_INT 3
13247: PUSH
13248: LD_INT 45
13250: PUSH
13251: EMPTY
13252: LIST
13253: LIST
13254: LIST
13255: LIST
13256: PUSH
13257: EMPTY
13258: LIST
13259: LIST
13260: LIST
13261: LIST
13262: LIST
13263: LIST
13264: PPUSH
13265: CALL 58819 0 2
// end ; if Difficulty > 1 then
13269: LD_OWVAR 67
13273: PUSH
13274: LD_INT 1
13276: GREATER
13277: IFFALSE 13307
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13279: LD_INT 1
13281: PPUSH
13282: LD_INT 24
13284: PUSH
13285: LD_INT 3
13287: PUSH
13288: LD_INT 3
13290: PUSH
13291: LD_INT 47
13293: PUSH
13294: EMPTY
13295: LIST
13296: LIST
13297: LIST
13298: LIST
13299: PUSH
13300: EMPTY
13301: LIST
13302: PPUSH
13303: CALL 58819 0 2
// repeat wait ( 0 0$1 ) ;
13307: LD_INT 35
13309: PPUSH
13310: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13314: LD_INT 1
13316: PPUSH
13317: LD_INT 1
13319: PPUSH
13320: CALL 60237 0 2
13324: PUSH
13325: LD_INT 6
13327: PUSH
13328: LD_INT 7
13330: PUSH
13331: LD_INT 7
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: LIST
13338: PUSH
13339: LD_OWVAR 67
13343: ARRAY
13344: GREATEREQUAL
13345: IFFALSE 13307
// wait ( 0 0$40 ) ;
13347: LD_INT 1400
13349: PPUSH
13350: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13354: LD_ADDR_VAR 0 2
13358: PUSH
13359: LD_INT 1
13361: PPUSH
13362: LD_INT 1
13364: PPUSH
13365: CALL 60237 0 2
13369: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13370: LD_ADDR_EXP 132
13374: PUSH
13375: LD_EXP 132
13379: PPUSH
13380: LD_INT 1
13382: PPUSH
13383: LD_EXP 132
13387: PUSH
13388: LD_INT 1
13390: ARRAY
13391: PUSH
13392: LD_VAR 0 2
13396: DIFF
13397: PPUSH
13398: CALL_OW 1
13402: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13403: LD_ADDR_VAR 0 3
13407: PUSH
13408: LD_INT 0
13410: PPUSH
13411: LD_INT 1
13413: PPUSH
13414: CALL_OW 12
13418: ST_TO_ADDR
// if target then
13419: LD_VAR 0 3
13423: IFFALSE 13589
// begin for i in tmp do
13425: LD_ADDR_VAR 0 1
13429: PUSH
13430: LD_VAR 0 2
13434: PUSH
13435: FOR_IN
13436: IFFALSE 13461
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13438: LD_VAR 0 1
13442: PPUSH
13443: LD_INT 179
13445: PPUSH
13446: LD_INT 209
13448: PPUSH
13449: LD_INT 8
13451: PPUSH
13452: LD_INT 1
13454: PPUSH
13455: CALL_OW 483
13459: GO 13435
13461: POP
13462: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13463: LD_ADDR_VAR 0 2
13467: PUSH
13468: LD_VAR 0 2
13472: PPUSH
13473: LD_INT 24
13475: PUSH
13476: LD_INT 250
13478: PUSH
13479: EMPTY
13480: LIST
13481: LIST
13482: PPUSH
13483: CALL_OW 72
13487: ST_TO_ADDR
// for i in tmp do
13488: LD_ADDR_VAR 0 1
13492: PUSH
13493: LD_VAR 0 2
13497: PUSH
13498: FOR_IN
13499: IFFALSE 13539
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13501: LD_VAR 0 1
13505: PPUSH
13506: LD_INT 179
13508: PPUSH
13509: LD_INT 209
13511: PPUSH
13512: CALL_OW 297
13516: PUSH
13517: LD_INT 9
13519: GREATER
13520: IFFALSE 13537
// ComMoveXY ( i , 179 , 209 ) ;
13522: LD_VAR 0 1
13526: PPUSH
13527: LD_INT 179
13529: PPUSH
13530: LD_INT 209
13532: PPUSH
13533: CALL_OW 111
13537: GO 13498
13539: POP
13540: POP
// wait ( 0 0$1 ) ;
13541: LD_INT 35
13543: PPUSH
13544: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13548: LD_VAR 0 2
13552: PPUSH
13553: LD_INT 92
13555: PUSH
13556: LD_INT 179
13558: PUSH
13559: LD_INT 209
13561: PUSH
13562: LD_INT 9
13564: PUSH
13565: EMPTY
13566: LIST
13567: LIST
13568: LIST
13569: LIST
13570: PPUSH
13571: CALL_OW 72
13575: PUSH
13576: LD_VAR 0 2
13580: PUSH
13581: LD_INT 1
13583: MINUS
13584: GREATEREQUAL
13585: IFFALSE 13463
// end else
13587: GO 13751
// begin for i in tmp do
13589: LD_ADDR_VAR 0 1
13593: PUSH
13594: LD_VAR 0 2
13598: PUSH
13599: FOR_IN
13600: IFFALSE 13625
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13602: LD_VAR 0 1
13606: PPUSH
13607: LD_INT 285
13609: PPUSH
13610: LD_INT 163
13612: PPUSH
13613: LD_INT 8
13615: PPUSH
13616: LD_INT 1
13618: PPUSH
13619: CALL_OW 483
13623: GO 13599
13625: POP
13626: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13627: LD_ADDR_VAR 0 2
13631: PUSH
13632: LD_VAR 0 2
13636: PPUSH
13637: LD_INT 24
13639: PUSH
13640: LD_INT 250
13642: PUSH
13643: EMPTY
13644: LIST
13645: LIST
13646: PPUSH
13647: CALL_OW 72
13651: ST_TO_ADDR
// for i in tmp do
13652: LD_ADDR_VAR 0 1
13656: PUSH
13657: LD_VAR 0 2
13661: PUSH
13662: FOR_IN
13663: IFFALSE 13703
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13665: LD_VAR 0 1
13669: PPUSH
13670: LD_INT 285
13672: PPUSH
13673: LD_INT 163
13675: PPUSH
13676: CALL_OW 297
13680: PUSH
13681: LD_INT 9
13683: GREATER
13684: IFFALSE 13701
// ComMoveXY ( i , 285 , 163 ) ;
13686: LD_VAR 0 1
13690: PPUSH
13691: LD_INT 285
13693: PPUSH
13694: LD_INT 163
13696: PPUSH
13697: CALL_OW 111
13701: GO 13662
13703: POP
13704: POP
// wait ( 0 0$1 ) ;
13705: LD_INT 35
13707: PPUSH
13708: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13712: LD_VAR 0 2
13716: PPUSH
13717: LD_INT 92
13719: PUSH
13720: LD_INT 285
13722: PUSH
13723: LD_INT 163
13725: PUSH
13726: LD_INT 9
13728: PUSH
13729: EMPTY
13730: LIST
13731: LIST
13732: LIST
13733: LIST
13734: PPUSH
13735: CALL_OW 72
13739: PUSH
13740: LD_VAR 0 2
13744: PUSH
13745: LD_INT 1
13747: MINUS
13748: GREATEREQUAL
13749: IFFALSE 13627
// end ; repeat wait ( 0 0$1 ) ;
13751: LD_INT 35
13753: PPUSH
13754: CALL_OW 67
// for i in tmp do
13758: LD_ADDR_VAR 0 1
13762: PUSH
13763: LD_VAR 0 2
13767: PUSH
13768: FOR_IN
13769: IFFALSE 13891
// if GetLives ( i ) > 251 then
13771: LD_VAR 0 1
13775: PPUSH
13776: CALL_OW 256
13780: PUSH
13781: LD_INT 251
13783: GREATER
13784: IFFALSE 13873
// begin if GetWeapon ( i ) = ru_time_lapser then
13786: LD_VAR 0 1
13790: PPUSH
13791: CALL_OW 264
13795: PUSH
13796: LD_INT 49
13798: EQUAL
13799: IFFALSE 13837
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13801: LD_VAR 0 1
13805: PPUSH
13806: LD_INT 81
13808: PUSH
13809: LD_INT 7
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: PPUSH
13816: CALL_OW 69
13820: PPUSH
13821: LD_VAR 0 1
13825: PPUSH
13826: CALL_OW 74
13830: PPUSH
13831: CALL_OW 112
13835: GO 13871
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13837: LD_VAR 0 1
13841: PPUSH
13842: LD_INT 81
13844: PUSH
13845: LD_INT 7
13847: PUSH
13848: EMPTY
13849: LIST
13850: LIST
13851: PPUSH
13852: CALL_OW 69
13856: PPUSH
13857: LD_VAR 0 1
13861: PPUSH
13862: CALL_OW 74
13866: PPUSH
13867: CALL_OW 115
// end else
13871: GO 13889
// tmp := tmp diff i ;
13873: LD_ADDR_VAR 0 2
13877: PUSH
13878: LD_VAR 0 2
13882: PUSH
13883: LD_VAR 0 1
13887: DIFF
13888: ST_TO_ADDR
13889: GO 13768
13891: POP
13892: POP
// until not tmp ;
13893: LD_VAR 0 2
13897: NOT
13898: IFFALSE 13751
// end ; end_of_file
13900: PPOPN 4
13902: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13903: LD_INT 0
13905: PPUSH
13906: PPUSH
13907: PPUSH
13908: PPUSH
// missionStage := 13 ;
13909: LD_ADDR_EXP 15
13913: PUSH
13914: LD_INT 13
13916: ST_TO_ADDR
// uc_side := 2 ;
13917: LD_ADDR_OWVAR 20
13921: PUSH
13922: LD_INT 2
13924: ST_TO_ADDR
// uc_nation := 2 ;
13925: LD_ADDR_OWVAR 21
13929: PUSH
13930: LD_INT 2
13932: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13933: LD_ADDR_EXP 92
13937: PUSH
13938: LD_STRING Omar
13940: PPUSH
13941: CALL_OW 25
13945: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13946: LD_EXP 92
13950: PPUSH
13951: LD_INT 4
13953: PPUSH
13954: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13958: LD_EXP 92
13962: PPUSH
13963: LD_INT 242
13965: PPUSH
13966: LD_INT 75
13968: PPUSH
13969: LD_INT 0
13971: PPUSH
13972: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13976: LD_ADDR_EXP 93
13980: PUSH
13981: LD_STRING Heike
13983: PPUSH
13984: CALL_OW 25
13988: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13989: LD_INT 14
13991: PPUSH
13992: LD_INT 3
13994: PPUSH
13995: LD_INT 1
13997: PPUSH
13998: LD_INT 27
14000: PPUSH
14001: LD_INT 100
14003: PPUSH
14004: CALL 70006 0 5
// veh := CreateVehicle ;
14008: LD_ADDR_VAR 0 3
14012: PUSH
14013: CALL_OW 45
14017: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
14018: LD_VAR 0 3
14022: PPUSH
14023: LD_INT 1
14025: PPUSH
14026: CALL_OW 242
// SetDir ( veh , 4 ) ;
14030: LD_VAR 0 3
14034: PPUSH
14035: LD_INT 4
14037: PPUSH
14038: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14042: LD_VAR 0 3
14046: PPUSH
14047: LD_INT 241
14049: PPUSH
14050: LD_INT 72
14052: PPUSH
14053: LD_INT 0
14055: PPUSH
14056: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14060: LD_EXP 93
14064: PPUSH
14065: LD_VAR 0 3
14069: PPUSH
14070: CALL_OW 52
// if KhatamStatus then
14074: LD_EXP 8
14078: IFFALSE 14129
// begin Khatam := NewCharacter ( Khatam ) ;
14080: LD_ADDR_EXP 94
14084: PUSH
14085: LD_STRING Khatam
14087: PPUSH
14088: CALL_OW 25
14092: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14093: LD_EXP 94
14097: PPUSH
14098: LD_INT 245
14100: PPUSH
14101: LD_INT 78
14103: PPUSH
14104: LD_INT 3
14106: PPUSH
14107: LD_INT 0
14109: PPUSH
14110: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14114: LD_EXP 94
14118: PPUSH
14119: LD_INT 4
14121: PPUSH
14122: LD_INT 10
14124: PPUSH
14125: CALL_OW 237
// end ; for i = 1 to Difficulty do
14129: LD_ADDR_VAR 0 2
14133: PUSH
14134: DOUBLE
14135: LD_INT 1
14137: DEC
14138: ST_TO_ADDR
14139: LD_OWVAR 67
14143: PUSH
14144: FOR_TO
14145: IFFALSE 14211
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14147: LD_INT 0
14149: PPUSH
14150: LD_INT 7
14152: PUSH
14153: LD_OWVAR 67
14157: PLUS
14158: PPUSH
14159: CALL_OW 384
// un := CreateHuman ;
14163: LD_ADDR_VAR 0 4
14167: PUSH
14168: CALL_OW 44
14172: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14173: LD_VAR 0 4
14177: PPUSH
14178: LD_INT 28
14180: PUSH
14181: LD_INT 29
14183: PUSH
14184: EMPTY
14185: LIST
14186: LIST
14187: PUSH
14188: LD_VAR 0 2
14192: PUSH
14193: LD_INT 2
14195: MOD
14196: PUSH
14197: LD_INT 1
14199: PLUS
14200: ARRAY
14201: PPUSH
14202: LD_INT 0
14204: PPUSH
14205: CALL_OW 49
// end ;
14209: GO 14144
14211: POP
14212: POP
// for i = 1 to 6 do
14213: LD_ADDR_VAR 0 2
14217: PUSH
14218: DOUBLE
14219: LD_INT 1
14221: DEC
14222: ST_TO_ADDR
14223: LD_INT 6
14225: PUSH
14226: FOR_TO
14227: IFFALSE 14272
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14229: LD_INT 0
14231: PPUSH
14232: LD_INT 7
14234: PUSH
14235: LD_OWVAR 67
14239: PLUS
14240: PPUSH
14241: CALL_OW 381
// un := CreateHuman ;
14245: LD_ADDR_VAR 0 4
14249: PUSH
14250: CALL_OW 44
14254: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14255: LD_VAR 0 4
14259: PPUSH
14260: LD_INT 28
14262: PPUSH
14263: LD_INT 0
14265: PPUSH
14266: CALL_OW 49
// end ;
14270: GO 14226
14272: POP
14273: POP
// for i = 1 to 3 do
14274: LD_ADDR_VAR 0 2
14278: PUSH
14279: DOUBLE
14280: LD_INT 1
14282: DEC
14283: ST_TO_ADDR
14284: LD_INT 3
14286: PUSH
14287: FOR_TO
14288: IFFALSE 14336
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14290: LD_INT 0
14292: PPUSH
14293: LD_INT 8
14295: PPUSH
14296: LD_INT 7
14298: PUSH
14299: LD_OWVAR 67
14303: PLUS
14304: PPUSH
14305: CALL_OW 380
// un := CreateHuman ;
14309: LD_ADDR_VAR 0 4
14313: PUSH
14314: CALL_OW 44
14318: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14319: LD_VAR 0 4
14323: PPUSH
14324: LD_INT 28
14326: PPUSH
14327: LD_INT 0
14329: PPUSH
14330: CALL_OW 49
// end ;
14334: GO 14287
14336: POP
14337: POP
// for i = 1 to 3 do
14338: LD_ADDR_VAR 0 2
14342: PUSH
14343: DOUBLE
14344: LD_INT 1
14346: DEC
14347: ST_TO_ADDR
14348: LD_INT 3
14350: PUSH
14351: FOR_TO
14352: IFFALSE 14442
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14354: LD_INT 14
14356: PPUSH
14357: LD_INT 2
14359: PPUSH
14360: LD_INT 1
14362: PPUSH
14363: LD_INT 28
14365: PPUSH
14366: LD_INT 80
14368: PPUSH
14369: CALL 70006 0 5
// veh := CreateVehicle ;
14373: LD_ADDR_VAR 0 3
14377: PUSH
14378: CALL_OW 45
14382: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14383: LD_VAR 0 3
14387: PPUSH
14388: LD_INT 3
14390: PPUSH
14391: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14395: LD_VAR 0 3
14399: PPUSH
14400: LD_INT 29
14402: PPUSH
14403: LD_INT 0
14405: PPUSH
14406: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14410: LD_INT 0
14412: PPUSH
14413: LD_INT 7
14415: PUSH
14416: LD_OWVAR 67
14420: PLUS
14421: PPUSH
14422: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14426: CALL_OW 44
14430: PPUSH
14431: LD_VAR 0 3
14435: PPUSH
14436: CALL_OW 52
// end ;
14440: GO 14351
14442: POP
14443: POP
// for i = 1 to 5 + Difficulty do
14444: LD_ADDR_VAR 0 2
14448: PUSH
14449: DOUBLE
14450: LD_INT 1
14452: DEC
14453: ST_TO_ADDR
14454: LD_INT 5
14456: PUSH
14457: LD_OWVAR 67
14461: PLUS
14462: PUSH
14463: FOR_TO
14464: IFFALSE 14591
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14466: LD_INT 14
14468: PPUSH
14469: LD_INT 1
14471: PPUSH
14472: LD_INT 3
14474: PPUSH
14475: CALL_OW 12
14479: PPUSH
14480: LD_INT 1
14482: PPUSH
14483: LD_INT 28
14485: PUSH
14486: LD_INT 26
14488: PUSH
14489: LD_INT 27
14491: PUSH
14492: LD_INT 25
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: LIST
14499: LIST
14500: PUSH
14501: LD_VAR 0 2
14505: PUSH
14506: LD_INT 4
14508: MOD
14509: PUSH
14510: LD_INT 1
14512: PLUS
14513: ARRAY
14514: PPUSH
14515: LD_INT 80
14517: PPUSH
14518: CALL 70006 0 5
// veh := CreateVehicle ;
14522: LD_ADDR_VAR 0 3
14526: PUSH
14527: CALL_OW 45
14531: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14532: LD_VAR 0 3
14536: PPUSH
14537: LD_INT 4
14539: PPUSH
14540: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14544: LD_VAR 0 3
14548: PPUSH
14549: LD_INT 28
14551: PPUSH
14552: LD_INT 0
14554: PPUSH
14555: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14559: LD_INT 0
14561: PPUSH
14562: LD_INT 7
14564: PUSH
14565: LD_OWVAR 67
14569: PLUS
14570: PPUSH
14571: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14575: CALL_OW 44
14579: PPUSH
14580: LD_VAR 0 3
14584: PPUSH
14585: CALL_OW 52
// end ;
14589: GO 14463
14591: POP
14592: POP
// for i = 1 to 3 do
14593: LD_ADDR_VAR 0 2
14597: PUSH
14598: DOUBLE
14599: LD_INT 1
14601: DEC
14602: ST_TO_ADDR
14603: LD_INT 3
14605: PUSH
14606: FOR_TO
14607: IFFALSE 14667
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14609: LD_INT 14
14611: PPUSH
14612: LD_INT 3
14614: PPUSH
14615: LD_INT 5
14617: PPUSH
14618: LD_INT 29
14620: PPUSH
14621: LD_INT 80
14623: PPUSH
14624: CALL 70006 0 5
// veh := CreateVehicle ;
14628: LD_ADDR_VAR 0 3
14632: PUSH
14633: CALL_OW 45
14637: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14638: LD_VAR 0 3
14642: PPUSH
14643: LD_INT 4
14645: PPUSH
14646: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14650: LD_VAR 0 3
14654: PPUSH
14655: LD_INT 28
14657: PPUSH
14658: LD_INT 0
14660: PPUSH
14661: CALL_OW 49
// end ;
14665: GO 14606
14667: POP
14668: POP
// end ;
14669: LD_VAR 0 1
14673: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14674: LD_INT 22
14676: PUSH
14677: LD_INT 2
14679: PUSH
14680: EMPTY
14681: LIST
14682: LIST
14683: PPUSH
14684: CALL_OW 69
14688: IFFALSE 14988
14690: GO 14692
14692: DISABLE
14693: LD_INT 0
14695: PPUSH
14696: PPUSH
14697: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14698: LD_ADDR_VAR 0 3
14702: PUSH
14703: LD_INT 22
14705: PUSH
14706: LD_INT 2
14708: PUSH
14709: EMPTY
14710: LIST
14711: LIST
14712: PUSH
14713: LD_INT 25
14715: PUSH
14716: LD_INT 4
14718: PUSH
14719: EMPTY
14720: LIST
14721: LIST
14722: PUSH
14723: EMPTY
14724: LIST
14725: LIST
14726: PPUSH
14727: CALL_OW 69
14731: PUSH
14732: LD_EXP 94
14736: DIFF
14737: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14738: LD_ADDR_VAR 0 2
14742: PUSH
14743: LD_INT 22
14745: PUSH
14746: LD_INT 2
14748: PUSH
14749: EMPTY
14750: LIST
14751: LIST
14752: PPUSH
14753: CALL_OW 69
14757: PUSH
14758: LD_EXP 94
14762: PUSH
14763: LD_VAR 0 3
14767: UNION
14768: DIFF
14769: ST_TO_ADDR
// if Khatam then
14770: LD_EXP 94
14774: IFFALSE 14791
// ComMoveXY ( Khatam , 211 , 92 ) ;
14776: LD_EXP 94
14780: PPUSH
14781: LD_INT 211
14783: PPUSH
14784: LD_INT 92
14786: PPUSH
14787: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14791: LD_INT 197
14793: PPUSH
14794: LD_INT 80
14796: PPUSH
14797: LD_INT 2
14799: PPUSH
14800: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14804: LD_INT 213
14806: PPUSH
14807: LD_INT 90
14809: PPUSH
14810: LD_INT 2
14812: PPUSH
14813: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14817: LD_INT 215
14819: PPUSH
14820: LD_INT 129
14822: PPUSH
14823: LD_INT 2
14825: PPUSH
14826: CALL_OW 441
// if sci then
14830: LD_VAR 0 3
14834: IFFALSE 14855
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14836: LD_VAR 0 3
14840: PUSH
14841: LD_INT 1
14843: ARRAY
14844: PPUSH
14845: LD_INT 197
14847: PPUSH
14848: LD_INT 80
14850: PPUSH
14851: CALL_OW 158
// if sci > 1 then
14855: LD_VAR 0 3
14859: PUSH
14860: LD_INT 1
14862: GREATER
14863: IFFALSE 14884
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14865: LD_VAR 0 3
14869: PUSH
14870: LD_INT 2
14872: ARRAY
14873: PPUSH
14874: LD_INT 213
14876: PPUSH
14877: LD_INT 90
14879: PPUSH
14880: CALL_OW 158
// if sci > 2 then
14884: LD_VAR 0 3
14888: PUSH
14889: LD_INT 2
14891: GREATER
14892: IFFALSE 14913
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14894: LD_VAR 0 3
14898: PUSH
14899: LD_INT 3
14901: ARRAY
14902: PPUSH
14903: LD_INT 215
14905: PPUSH
14906: LD_INT 129
14908: PPUSH
14909: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14913: LD_INT 35
14915: PPUSH
14916: CALL_OW 67
// for i in tmp do
14920: LD_ADDR_VAR 0 1
14924: PUSH
14925: LD_VAR 0 2
14929: PUSH
14930: FOR_IN
14931: IFFALSE 14969
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14933: LD_VAR 0 1
14937: PPUSH
14938: LD_INT 81
14940: PUSH
14941: LD_INT 2
14943: PUSH
14944: EMPTY
14945: LIST
14946: LIST
14947: PPUSH
14948: CALL_OW 69
14952: PPUSH
14953: LD_VAR 0 1
14957: PPUSH
14958: CALL_OW 74
14962: PPUSH
14963: CALL_OW 115
14967: GO 14930
14969: POP
14970: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14971: LD_INT 22
14973: PUSH
14974: LD_INT 2
14976: PUSH
14977: EMPTY
14978: LIST
14979: LIST
14980: PPUSH
14981: CALL_OW 69
14985: NOT
14986: IFFALSE 14913
// end ; end_of_file
14988: PPOPN 3
14990: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14991: LD_INT 0
14993: PPUSH
14994: PPUSH
14995: PPUSH
14996: PPUSH
14997: PPUSH
14998: PPUSH
14999: PPUSH
15000: PPUSH
15001: PPUSH
// Video ( true ) ;
15002: LD_INT 1
15004: PPUSH
15005: CALL 101143 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
15009: LD_ADDR_VAR 0 5
15013: PUSH
15014: LD_INT 7
15016: PPUSH
15017: LD_INT 0
15019: PPUSH
15020: CALL_OW 517
15024: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15025: LD_ADDR_VAR 0 2
15029: PUSH
15030: DOUBLE
15031: LD_INT 1
15033: DEC
15034: ST_TO_ADDR
15035: LD_VAR 0 5
15039: PUSH
15040: LD_INT 1
15042: ARRAY
15043: PUSH
15044: FOR_TO
15045: IFFALSE 15090
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15047: LD_VAR 0 5
15051: PUSH
15052: LD_INT 1
15054: ARRAY
15055: PUSH
15056: LD_VAR 0 2
15060: ARRAY
15061: PPUSH
15062: LD_VAR 0 5
15066: PUSH
15067: LD_INT 2
15069: ARRAY
15070: PUSH
15071: LD_VAR 0 2
15075: ARRAY
15076: PPUSH
15077: LD_INT 1
15079: PPUSH
15080: LD_INT 15
15082: NEG
15083: PPUSH
15084: CALL 101057 0 4
15088: GO 15044
15090: POP
15091: POP
// CenterNowOnUnits ( Powell ) ;
15092: LD_EXP 58
15096: PPUSH
15097: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15101: LD_ADDR_VAR 0 5
15105: PUSH
15106: LD_EXP 56
15110: PUSH
15111: EMPTY
15112: LIST
15113: ST_TO_ADDR
// if GirlNewVeh then
15114: LD_EXP 57
15118: IFFALSE 15136
// tmp := tmp ^ GirlNewVeh ;
15120: LD_ADDR_VAR 0 5
15124: PUSH
15125: LD_VAR 0 5
15129: PUSH
15130: LD_EXP 57
15134: ADD
15135: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15136: LD_VAR 0 5
15140: PPUSH
15141: LD_INT 60
15143: PPUSH
15144: LD_INT 109
15146: PPUSH
15147: CALL_OW 111
// if KappaStatus then
15151: LD_EXP 2
15155: IFFALSE 15207
// begin Say ( JMM , D1nT-JMM-1 ) ;
15157: LD_EXP 39
15161: PPUSH
15162: LD_STRING D1nT-JMM-1
15164: PPUSH
15165: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15169: LD_EXP 58
15173: PPUSH
15174: LD_STRING D1T-Pow-1
15176: PPUSH
15177: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15181: LD_EXP 39
15185: PPUSH
15186: LD_STRING D1T-JMM-2
15188: PPUSH
15189: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15193: LD_EXP 58
15197: PPUSH
15198: LD_STRING D1T-Pow-2
15200: PPUSH
15201: CALL_OW 88
// end else
15205: GO 15413
// if JMMGirlStatus then
15207: LD_EXP 6
15211: IFFALSE 15356
// begin Say ( JMM , D1T-JMM-1 ) ;
15213: LD_EXP 39
15217: PPUSH
15218: LD_STRING D1T-JMM-1
15220: PPUSH
15221: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15225: LD_EXP 58
15229: PPUSH
15230: LD_STRING D1T-Pow-1
15232: PPUSH
15233: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15237: LD_EXP 39
15241: PPUSH
15242: LD_STRING D1T-JMM-3
15244: PPUSH
15245: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15249: LD_EXP 58
15253: PPUSH
15254: LD_STRING D1T-Pow-3
15256: PPUSH
15257: CALL_OW 88
// if JMMGirl then
15261: LD_EXP 7
15265: IFFALSE 15354
// begin case JMMGirl of 1 :
15267: LD_EXP 7
15271: PUSH
15272: LD_INT 1
15274: DOUBLE
15275: EQUAL
15276: IFTRUE 15280
15278: GO 15295
15280: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15281: LD_EXP 40
15285: PPUSH
15286: LD_STRING D1T-Joan-3
15288: PPUSH
15289: CALL_OW 88
15293: GO 15342
15295: LD_INT 2
15297: DOUBLE
15298: EQUAL
15299: IFTRUE 15303
15301: GO 15318
15303: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15304: LD_EXP 42
15308: PPUSH
15309: LD_STRING D1T-Lisa-3
15311: PPUSH
15312: CALL_OW 88
15316: GO 15342
15318: LD_INT 3
15320: DOUBLE
15321: EQUAL
15322: IFTRUE 15326
15324: GO 15341
15326: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15327: LD_EXP 54
15331: PPUSH
15332: LD_STRING D1T-Con-3
15334: PPUSH
15335: CALL_OW 88
15339: GO 15342
15341: POP
// Say ( Powell , D1T-Pow-4 ) ;
15342: LD_EXP 58
15346: PPUSH
15347: LD_STRING D1T-Pow-4
15349: PPUSH
15350: CALL_OW 88
// end ; end else
15354: GO 15413
// if not FastEnd then
15356: LD_EXP 11
15360: NOT
15361: IFFALSE 15389
// begin Say ( JMM , D1T-JMM-4 ) ;
15363: LD_EXP 39
15367: PPUSH
15368: LD_STRING D1T-JMM-4
15370: PPUSH
15371: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15375: LD_EXP 58
15379: PPUSH
15380: LD_STRING D1T-Pow-5
15382: PPUSH
15383: CALL_OW 88
// end else
15387: GO 15413
// begin Say ( JMM , D1nT-JMM-1 ) ;
15389: LD_EXP 39
15393: PPUSH
15394: LD_STRING D1nT-JMM-1
15396: PPUSH
15397: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15401: LD_EXP 58
15405: PPUSH
15406: LD_STRING D1nT-Pow-1
15408: PPUSH
15409: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15413: LD_INT 35
15415: PPUSH
15416: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15420: LD_EXP 56
15424: PPUSH
15425: CALL_OW 314
15429: NOT
15430: IFFALSE 15413
// ComExitVehicle ( JMM ) ;
15432: LD_EXP 39
15436: PPUSH
15437: CALL_OW 121
// wait ( 3 ) ;
15441: LD_INT 3
15443: PPUSH
15444: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15448: LD_EXP 39
15452: PPUSH
15453: LD_INT 60
15455: PPUSH
15456: LD_INT 94
15458: PPUSH
15459: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15463: LD_EXP 39
15467: PPUSH
15468: LD_EXP 58
15472: PPUSH
15473: CALL_OW 179
// if Joan then
15477: LD_EXP 40
15481: IFFALSE 15535
// begin ComExitVehicle ( Joan ) ;
15483: LD_EXP 40
15487: PPUSH
15488: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15492: LD_EXP 40
15496: PPUSH
15497: LD_INT 35
15499: PPUSH
15500: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15504: LD_EXP 40
15508: PPUSH
15509: LD_INT 65
15511: PPUSH
15512: LD_INT 104
15514: PPUSH
15515: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15519: LD_EXP 40
15523: PPUSH
15524: LD_EXP 39
15528: PPUSH
15529: CALL_OW 179
// end else
15533: GO 15669
// if Lisa and JMMGirl = 2 then
15535: LD_EXP 42
15539: PUSH
15540: LD_EXP 7
15544: PUSH
15545: LD_INT 2
15547: EQUAL
15548: AND
15549: IFFALSE 15603
// begin ComExitVehicle ( Lisa ) ;
15551: LD_EXP 42
15555: PPUSH
15556: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15560: LD_EXP 42
15564: PPUSH
15565: LD_INT 35
15567: PPUSH
15568: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15572: LD_EXP 42
15576: PPUSH
15577: LD_INT 65
15579: PPUSH
15580: LD_INT 104
15582: PPUSH
15583: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15587: LD_EXP 42
15591: PPUSH
15592: LD_EXP 39
15596: PPUSH
15597: CALL_OW 179
// end else
15601: GO 15669
// if Connie and JMMGirl = 3 then
15603: LD_EXP 54
15607: PUSH
15608: LD_EXP 7
15612: PUSH
15613: LD_INT 3
15615: EQUAL
15616: AND
15617: IFFALSE 15669
// begin ComExitVehicle ( Connie ) ;
15619: LD_EXP 54
15623: PPUSH
15624: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15628: LD_EXP 54
15632: PPUSH
15633: LD_INT 35
15635: PPUSH
15636: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15640: LD_EXP 54
15644: PPUSH
15645: LD_INT 65
15647: PPUSH
15648: LD_INT 104
15650: PPUSH
15651: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15655: LD_EXP 54
15659: PPUSH
15660: LD_EXP 39
15664: PPUSH
15665: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15669: LD_INT 35
15671: PPUSH
15672: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15676: LD_EXP 39
15680: PPUSH
15681: LD_EXP 58
15685: PPUSH
15686: CALL_OW 296
15690: PUSH
15691: LD_INT 6
15693: LESS
15694: IFFALSE 15669
// wait ( 0 0$0.5 ) ;
15696: LD_INT 18
15698: PPUSH
15699: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15703: LD_EXP 39
15707: PPUSH
15708: LD_STRING D1-JMM-1
15710: PPUSH
15711: CALL_OW 88
// async ;
15715: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15716: LD_EXP 58
15720: PPUSH
15721: LD_STRING D1-Pow-1
15723: PPUSH
15724: CALL_OW 88
// if not dialogue_skipped then
15728: LD_OWVAR 59
15732: NOT
15733: IFFALSE 15742
// wait ( 0 0$2 ) ;
15735: LD_INT 70
15737: PPUSH
15738: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15742: LD_INT 170
15744: PPUSH
15745: LD_INT 99
15747: PPUSH
15748: LD_INT 1
15750: PPUSH
15751: LD_INT 6
15753: NEG
15754: PPUSH
15755: CALL 101057 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15759: LD_INT 174
15761: PPUSH
15762: LD_INT 115
15764: PPUSH
15765: LD_INT 1
15767: PPUSH
15768: LD_INT 6
15770: NEG
15771: PPUSH
15772: CALL 101057 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15776: LD_INT 169
15778: PPUSH
15779: LD_INT 71
15781: PPUSH
15782: LD_INT 1
15784: PPUSH
15785: LD_INT 6
15787: NEG
15788: PPUSH
15789: CALL 101057 0 4
// if not dialogue_skipped then
15793: LD_OWVAR 59
15797: NOT
15798: IFFALSE 15817
// begin CenterOnXY ( 170 , 99 ) ;
15800: LD_INT 170
15802: PPUSH
15803: LD_INT 99
15805: PPUSH
15806: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15810: LD_INT 80
15812: PPUSH
15813: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15817: LD_INT 75
15819: PPUSH
15820: LD_INT 53
15822: PPUSH
15823: LD_INT 1
15825: PPUSH
15826: LD_INT 9
15828: NEG
15829: PPUSH
15830: CALL 101057 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15834: LD_INT 54
15836: PPUSH
15837: LD_INT 42
15839: PPUSH
15840: LD_INT 1
15842: PPUSH
15843: LD_INT 9
15845: NEG
15846: PPUSH
15847: CALL 101057 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15851: LD_INT 62
15853: PPUSH
15854: LD_INT 51
15856: PPUSH
15857: LD_INT 1
15859: PPUSH
15860: LD_INT 9
15862: NEG
15863: PPUSH
15864: CALL 101057 0 4
// if not dialogue_skipped then
15868: LD_OWVAR 59
15872: NOT
15873: IFFALSE 15892
// begin CenterOnXY ( 75 , 53 ) ;
15875: LD_INT 75
15877: PPUSH
15878: LD_INT 53
15880: PPUSH
15881: CALL_OW 84
// wait ( 0 0$4 ) ;
15885: LD_INT 140
15887: PPUSH
15888: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15892: LD_EXP 58
15896: PPUSH
15897: CALL_OW 87
// if not dialogue_skipped then
15901: LD_OWVAR 59
15905: NOT
15906: IFFALSE 15915
// wait ( 0 0$2 ) ;
15908: LD_INT 70
15910: PPUSH
15911: CALL_OW 67
// sync ;
15915: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15916: LD_EXP 39
15920: PPUSH
15921: LD_STRING D1-JMM-2
15923: PPUSH
15924: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15928: LD_EXP 58
15932: PPUSH
15933: LD_STRING D1-Pow-2
15935: PPUSH
15936: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15940: LD_EXP 39
15944: PPUSH
15945: LD_STRING D1-JMM-3
15947: PPUSH
15948: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15952: LD_EXP 58
15956: PPUSH
15957: LD_STRING D1-Pow-3
15959: PPUSH
15960: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15964: LD_EXP 39
15968: PPUSH
15969: LD_STRING D1-JMM-4
15971: PPUSH
15972: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15976: LD_EXP 58
15980: PPUSH
15981: LD_STRING D1-Pow-4
15983: PPUSH
15984: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15988: LD_EXP 39
15992: PPUSH
15993: LD_STRING D1-JMM-5
15995: PPUSH
15996: CALL_OW 88
// async ;
16000: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
16001: LD_EXP 58
16005: PPUSH
16006: LD_STRING D1-Pow-5
16008: PPUSH
16009: CALL_OW 88
// if not dialogue_skipped then
16013: LD_OWVAR 59
16017: NOT
16018: IFFALSE 16027
// wait ( 0 0$3.6 ) ;
16020: LD_INT 126
16022: PPUSH
16023: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16027: LD_INT 134
16029: PPUSH
16030: LD_INT 210
16032: PPUSH
16033: LD_INT 1
16035: PPUSH
16036: LD_INT 11
16038: NEG
16039: PPUSH
16040: CALL 101057 0 4
// if not dialogue_skipped then
16044: LD_OWVAR 59
16048: NOT
16049: IFFALSE 16068
// begin CenterOnXY ( 134 , 210 ) ;
16051: LD_INT 134
16053: PPUSH
16054: LD_INT 210
16056: PPUSH
16057: CALL_OW 84
// wait ( 0 0$2 ) ;
16061: LD_INT 70
16063: PPUSH
16064: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16068: LD_INT 101
16070: PPUSH
16071: LD_INT 159
16073: PPUSH
16074: LD_INT 1
16076: PPUSH
16077: LD_INT 10
16079: NEG
16080: PPUSH
16081: CALL 101057 0 4
// if not dialogue_skipped then
16085: LD_OWVAR 59
16089: NOT
16090: IFFALSE 16109
// begin CenterOnXY ( 101 , 159 ) ;
16092: LD_INT 101
16094: PPUSH
16095: LD_INT 159
16097: PPUSH
16098: CALL_OW 84
// wait ( 0 0$2 ) ;
16102: LD_INT 70
16104: PPUSH
16105: CALL_OW 67
// end ; sync ;
16109: SYNC
// CenterNowOnUnits ( Powell ) ;
16110: LD_EXP 58
16114: PPUSH
16115: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16119: LD_ADDR_VAR 0 6
16123: PUSH
16124: LD_INT 1
16126: PUSH
16127: LD_INT 2
16129: PUSH
16130: LD_INT 3
16132: PUSH
16133: LD_INT 4
16135: PUSH
16136: LD_INT 5
16138: PUSH
16139: LD_INT 6
16141: PUSH
16142: EMPTY
16143: LIST
16144: LIST
16145: LIST
16146: LIST
16147: LIST
16148: LIST
16149: ST_TO_ADDR
// if not dialogue_skipped then
16150: LD_OWVAR 59
16154: NOT
16155: IFFALSE 16324
// begin game_speed := 4 ;
16157: LD_ADDR_OWVAR 65
16161: PUSH
16162: LD_INT 4
16164: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16165: LD_INT 210
16167: PPUSH
16168: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16172: LD_ADDR_VAR 0 7
16176: PUSH
16177: LD_STRING Q1
16179: PPUSH
16180: LD_VAR 0 6
16184: PPUSH
16185: CALL_OW 98
16189: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16190: LD_ADDR_VAR 0 7
16194: PUSH
16195: LD_STRING Q1
16197: PPUSH
16198: LD_VAR 0 6
16202: PPUSH
16203: CALL_OW 98
16207: ST_TO_ADDR
// options = options diff dec ;
16208: LD_ADDR_VAR 0 6
16212: PUSH
16213: LD_VAR 0 6
16217: PUSH
16218: LD_VAR 0 7
16222: DIFF
16223: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16224: LD_VAR 0 7
16228: PPUSH
16229: LD_VAR 0 6
16233: PPUSH
16234: CALL 17796 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16238: LD_VAR 0 7
16242: PUSH
16243: LD_INT 5
16245: PUSH
16246: LD_INT 6
16248: PUSH
16249: EMPTY
16250: LIST
16251: LIST
16252: IN
16253: PUSH
16254: LD_VAR 0 6
16258: PUSH
16259: LD_INT 2
16261: EQUAL
16262: OR
16263: IFFALSE 16190
// if not ( dec in [ 5 , 6 ] ) then
16265: LD_VAR 0 7
16269: PUSH
16270: LD_INT 5
16272: PUSH
16273: LD_INT 6
16275: PUSH
16276: EMPTY
16277: LIST
16278: LIST
16279: IN
16280: NOT
16281: IFFALSE 16324
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16283: LD_ADDR_VAR 0 7
16287: PUSH
16288: LD_STRING Q1a
16290: PPUSH
16291: LD_INT 1
16293: PUSH
16294: LD_INT 2
16296: PUSH
16297: EMPTY
16298: LIST
16299: LIST
16300: PPUSH
16301: CALL_OW 98
16305: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16306: LD_VAR 0 7
16310: PUSH
16311: LD_INT 4
16313: PLUS
16314: PPUSH
16315: LD_VAR 0 6
16319: PPUSH
16320: CALL 17796 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16324: LD_INT 81
16326: PPUSH
16327: LD_INT 127
16329: PPUSH
16330: CALL_OW 84
// amount := 5 ;
16334: LD_ADDR_VAR 0 8
16338: PUSH
16339: LD_INT 5
16341: ST_TO_ADDR
// macmilan_squad := [ ] ;
16342: LD_ADDR_VAR 0 9
16346: PUSH
16347: EMPTY
16348: ST_TO_ADDR
// if vip < amount then
16349: LD_EXP 59
16353: PUSH
16354: LD_VAR 0 8
16358: LESS
16359: IFFALSE 16403
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16361: LD_ADDR_VAR 0 5
16365: PUSH
16366: LD_EXP 59
16370: PUSH
16371: LD_INT 22
16373: PUSH
16374: LD_INT 4
16376: PUSH
16377: EMPTY
16378: LIST
16379: LIST
16380: PUSH
16381: LD_INT 21
16383: PUSH
16384: LD_INT 1
16386: PUSH
16387: EMPTY
16388: LIST
16389: LIST
16390: PUSH
16391: EMPTY
16392: LIST
16393: LIST
16394: PPUSH
16395: CALL_OW 69
16399: UNION
16400: ST_TO_ADDR
16401: GO 16413
// tmp := vip ;
16403: LD_ADDR_VAR 0 5
16407: PUSH
16408: LD_EXP 59
16412: ST_TO_ADDR
// tmp := tmp diff Powell ;
16413: LD_ADDR_VAR 0 5
16417: PUSH
16418: LD_VAR 0 5
16422: PUSH
16423: LD_EXP 58
16427: DIFF
16428: ST_TO_ADDR
// if tmp < amount then
16429: LD_VAR 0 5
16433: PUSH
16434: LD_VAR 0 8
16438: LESS
16439: IFFALSE 16451
// amount := tmp ;
16441: LD_ADDR_VAR 0 8
16445: PUSH
16446: LD_VAR 0 5
16450: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16451: LD_VAR 0 5
16455: PUSH
16456: LD_INT 1
16458: ARRAY
16459: PPUSH
16460: CALL_OW 257
16464: PUSH
16465: LD_INT 2
16467: NONEQUAL
16468: IFFALSE 16530
// begin if IsInUnit ( tmp [ 1 ] ) then
16470: LD_VAR 0 5
16474: PUSH
16475: LD_INT 1
16477: ARRAY
16478: PPUSH
16479: CALL_OW 310
16483: IFFALSE 16498
// ComExitBuilding ( tmp [ 1 ] ) ;
16485: LD_VAR 0 5
16489: PUSH
16490: LD_INT 1
16492: ARRAY
16493: PPUSH
16494: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16498: LD_VAR 0 5
16502: PUSH
16503: LD_INT 1
16505: ARRAY
16506: PPUSH
16507: LD_INT 387
16509: PPUSH
16510: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16514: LD_VAR 0 5
16518: PUSH
16519: LD_INT 1
16521: ARRAY
16522: PPUSH
16523: LD_INT 2
16525: PPUSH
16526: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16530: LD_EXP 39
16534: PPUSH
16535: LD_INT 82
16537: PPUSH
16538: LD_INT 129
16540: PPUSH
16541: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16545: LD_EXP 39
16549: PPUSH
16550: LD_EXP 58
16554: PPUSH
16555: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16559: LD_INT 22
16561: PUSH
16562: LD_INT 1
16564: PUSH
16565: EMPTY
16566: LIST
16567: LIST
16568: PPUSH
16569: CALL_OW 69
16573: PUSH
16574: LD_EXP 39
16578: DIFF
16579: PPUSH
16580: LD_INT 84
16582: PPUSH
16583: LD_INT 128
16585: PPUSH
16586: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16590: LD_INT 22
16592: PUSH
16593: LD_INT 1
16595: PUSH
16596: EMPTY
16597: LIST
16598: LIST
16599: PPUSH
16600: CALL_OW 69
16604: PUSH
16605: LD_EXP 39
16609: DIFF
16610: PPUSH
16611: LD_EXP 39
16615: PPUSH
16616: CALL_OW 179
// for i = 1 to amount do
16620: LD_ADDR_VAR 0 2
16624: PUSH
16625: DOUBLE
16626: LD_INT 1
16628: DEC
16629: ST_TO_ADDR
16630: LD_VAR 0 8
16634: PUSH
16635: FOR_TO
16636: IFFALSE 16804
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16638: LD_ADDR_VAR 0 9
16642: PUSH
16643: LD_VAR 0 9
16647: PUSH
16648: LD_VAR 0 5
16652: PUSH
16653: LD_VAR 0 2
16657: ARRAY
16658: ADD
16659: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16660: LD_VAR 0 5
16664: PUSH
16665: LD_VAR 0 2
16669: ARRAY
16670: PPUSH
16671: CALL_OW 310
16675: IFFALSE 16692
// AddComExitBuilding ( tmp [ i ] ) ;
16677: LD_VAR 0 5
16681: PUSH
16682: LD_VAR 0 2
16686: ARRAY
16687: PPUSH
16688: CALL_OW 182
// if i = 2 and JMMNewVeh then
16692: LD_VAR 0 2
16696: PUSH
16697: LD_INT 2
16699: EQUAL
16700: PUSH
16701: LD_EXP 56
16705: AND
16706: IFFALSE 16764
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16708: LD_VAR 0 5
16712: PUSH
16713: LD_VAR 0 2
16717: ARRAY
16718: PPUSH
16719: LD_EXP 56
16723: PPUSH
16724: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16728: LD_VAR 0 5
16732: PUSH
16733: LD_VAR 0 2
16737: ARRAY
16738: PPUSH
16739: LD_INT 86
16741: PPUSH
16742: LD_INT 133
16744: PPUSH
16745: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16749: LD_VAR 0 5
16753: PUSH
16754: LD_VAR 0 2
16758: ARRAY
16759: PPUSH
16760: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16764: LD_VAR 0 5
16768: PUSH
16769: LD_VAR 0 2
16773: ARRAY
16774: PPUSH
16775: LD_INT 8
16777: PPUSH
16778: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16782: LD_VAR 0 5
16786: PUSH
16787: LD_VAR 0 2
16791: ARRAY
16792: PPUSH
16793: LD_EXP 39
16797: PPUSH
16798: CALL_OW 179
// end ;
16802: GO 16635
16804: POP
16805: POP
// if GirlNewVeh then
16806: LD_EXP 57
16810: IFFALSE 16824
// SetSide ( GirlNewVeh , 4 ) ;
16812: LD_EXP 57
16816: PPUSH
16817: LD_INT 4
16819: PPUSH
16820: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16824: LD_INT 35
16826: PPUSH
16827: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16831: LD_VAR 0 9
16835: PPUSH
16836: LD_INT 95
16838: PUSH
16839: LD_INT 9
16841: PUSH
16842: EMPTY
16843: LIST
16844: LIST
16845: PPUSH
16846: CALL_OW 72
16850: PUSH
16851: LD_INT 0
16853: EQUAL
16854: PUSH
16855: LD_EXP 39
16859: PPUSH
16860: LD_INT 9
16862: PPUSH
16863: CALL_OW 308
16867: NOT
16868: AND
16869: IFFALSE 16824
// wait ( 0 0$2 ) ;
16871: LD_INT 70
16873: PPUSH
16874: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16878: LD_VAR 0 9
16882: PPUSH
16883: LD_INT 1
16885: PPUSH
16886: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16890: LD_INT 21
16892: PUSH
16893: LD_INT 2
16895: PUSH
16896: EMPTY
16897: LIST
16898: LIST
16899: PUSH
16900: LD_INT 92
16902: PUSH
16903: LD_INT 83
16905: PUSH
16906: LD_INT 130
16908: PUSH
16909: LD_INT 10
16911: PUSH
16912: EMPTY
16913: LIST
16914: LIST
16915: LIST
16916: LIST
16917: PUSH
16918: EMPTY
16919: LIST
16920: LIST
16921: PPUSH
16922: CALL_OW 69
16926: PPUSH
16927: LD_INT 1
16929: PPUSH
16930: CALL_OW 235
// Video ( false ) ;
16934: LD_INT 0
16936: PPUSH
16937: CALL 101143 0 1
// ChangeMissionObjectives ( M1 ) ;
16941: LD_STRING M1
16943: PPUSH
16944: CALL_OW 337
// SaveForQuickRestart ;
16948: CALL_OW 22
// missionStart := true ;
16952: LD_ADDR_EXP 13
16956: PUSH
16957: LD_INT 1
16959: ST_TO_ADDR
// missionStage := 2 ;
16960: LD_ADDR_EXP 15
16964: PUSH
16965: LD_INT 2
16967: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16968: LD_INT 105
16970: PPUSH
16971: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16975: LD_ADDR_VAR 0 5
16979: PUSH
16980: LD_INT 22
16982: PUSH
16983: LD_INT 4
16985: PUSH
16986: EMPTY
16987: LIST
16988: LIST
16989: PUSH
16990: LD_INT 21
16992: PUSH
16993: LD_INT 1
16995: PUSH
16996: EMPTY
16997: LIST
16998: LIST
16999: PUSH
17000: EMPTY
17001: LIST
17002: LIST
17003: PPUSH
17004: CALL_OW 69
17008: PUSH
17009: LD_EXP 58
17013: DIFF
17014: ST_TO_ADDR
// if not tmp then
17015: LD_VAR 0 5
17019: NOT
17020: IFFALSE 17035
// tmp := [ Powell ] ;
17022: LD_ADDR_VAR 0 5
17026: PUSH
17027: LD_EXP 58
17031: PUSH
17032: EMPTY
17033: LIST
17034: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
17035: LD_ADDR_EXP 113
17039: PUSH
17040: LD_EXP 113
17044: PPUSH
17045: LD_INT 4
17047: PPUSH
17048: LD_INT 22
17050: PUSH
17051: LD_INT 4
17053: PUSH
17054: EMPTY
17055: LIST
17056: LIST
17057: PUSH
17058: LD_INT 23
17060: PUSH
17061: LD_INT 1
17063: PUSH
17064: EMPTY
17065: LIST
17066: LIST
17067: PUSH
17068: LD_INT 3
17070: PUSH
17071: LD_INT 21
17073: PUSH
17074: LD_INT 2
17076: PUSH
17077: EMPTY
17078: LIST
17079: LIST
17080: PUSH
17081: EMPTY
17082: LIST
17083: LIST
17084: PUSH
17085: EMPTY
17086: LIST
17087: LIST
17088: LIST
17089: PPUSH
17090: CALL_OW 69
17094: PUSH
17095: LD_EXP 58
17099: DIFF
17100: PPUSH
17101: CALL_OW 1
17105: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17106: LD_ADDR_VAR 0 4
17110: PUSH
17111: LD_INT 22
17113: PUSH
17114: LD_INT 4
17116: PUSH
17117: EMPTY
17118: LIST
17119: LIST
17120: PUSH
17121: LD_INT 34
17123: PUSH
17124: LD_INT 12
17126: PUSH
17127: EMPTY
17128: LIST
17129: LIST
17130: PUSH
17131: EMPTY
17132: LIST
17133: LIST
17134: PPUSH
17135: CALL_OW 69
17139: PUSH
17140: LD_INT 1
17142: ARRAY
17143: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17144: LD_VAR 0 5
17148: PUSH
17149: LD_INT 1
17151: ARRAY
17152: PPUSH
17153: CALL_OW 310
17157: IFFALSE 17172
// ComExitBuilding ( tmp [ 1 ] ) ;
17159: LD_VAR 0 5
17163: PUSH
17164: LD_INT 1
17166: ARRAY
17167: PPUSH
17168: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17172: LD_VAR 0 5
17176: PUSH
17177: LD_INT 1
17179: ARRAY
17180: PPUSH
17181: LD_VAR 0 4
17185: PPUSH
17186: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17190: LD_VAR 0 5
17194: PUSH
17195: LD_INT 1
17197: ARRAY
17198: PPUSH
17199: LD_INT 80
17201: PPUSH
17202: LD_INT 136
17204: PPUSH
17205: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17209: LD_VAR 0 5
17213: PUSH
17214: LD_INT 1
17216: ARRAY
17217: PPUSH
17218: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17222: LD_VAR 0 5
17226: PUSH
17227: LD_INT 1
17229: ARRAY
17230: PPUSH
17231: LD_INT 59
17233: PPUSH
17234: LD_INT 112
17236: PPUSH
17237: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17241: LD_VAR 0 5
17245: PUSH
17246: LD_INT 1
17248: ARRAY
17249: PPUSH
17250: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17254: LD_EXP 40
17258: PUSH
17259: LD_EXP 40
17263: PPUSH
17264: CALL_OW 255
17268: PUSH
17269: LD_INT 1
17271: EQUAL
17272: AND
17273: IFFALSE 17299
// begin Say ( Joan , D3W-Joan-1 ) ;
17275: LD_EXP 40
17279: PPUSH
17280: LD_STRING D3W-Joan-1
17282: PPUSH
17283: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17287: LD_EXP 39
17291: PPUSH
17292: LD_STRING D3W-JMM-1
17294: PPUSH
17295: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17299: LD_EXP 42
17303: PUSH
17304: LD_EXP 42
17308: PPUSH
17309: CALL_OW 255
17313: PUSH
17314: LD_INT 1
17316: EQUAL
17317: AND
17318: PUSH
17319: LD_EXP 42
17323: PUSH
17324: LD_EXP 59
17328: IN
17329: NOT
17330: AND
17331: IFFALSE 17357
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17333: LD_EXP 42
17337: PPUSH
17338: LD_STRING D3W-Lisa-1
17340: PPUSH
17341: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17345: LD_EXP 39
17349: PPUSH
17350: LD_STRING D3W-JMM-1
17352: PPUSH
17353: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17357: LD_EXP 54
17361: PUSH
17362: LD_EXP 54
17366: PPUSH
17367: CALL_OW 255
17371: PUSH
17372: LD_INT 1
17374: EQUAL
17375: AND
17376: IFFALSE 17402
// begin Say ( Connie , D3W-Con-1 ) ;
17378: LD_EXP 54
17382: PPUSH
17383: LD_STRING D3W-Con-1
17385: PPUSH
17386: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17390: LD_EXP 39
17394: PPUSH
17395: LD_STRING D3W-JMM-1
17397: PPUSH
17398: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17402: LD_EXP 42
17406: PUSH
17407: LD_EXP 59
17411: IN
17412: PUSH
17413: LD_EXP 42
17417: PPUSH
17418: CALL_OW 255
17422: PUSH
17423: LD_INT 1
17425: EQUAL
17426: AND
17427: IFFALSE 17443
// Say ( Lisa , D3nW-Lisa-1 ) else
17429: LD_EXP 42
17433: PPUSH
17434: LD_STRING D3nW-Lisa-1
17436: PPUSH
17437: CALL_OW 88
17441: GO 17687
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17443: LD_EXP 45
17447: PUSH
17448: LD_EXP 59
17452: IN
17453: PUSH
17454: LD_EXP 45
17458: PPUSH
17459: CALL_OW 255
17463: PUSH
17464: LD_INT 1
17466: EQUAL
17467: AND
17468: IFFALSE 17484
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17470: LD_EXP 45
17474: PPUSH
17475: LD_STRING D3nW-Cyrus-1
17477: PPUSH
17478: CALL_OW 88
17482: GO 17687
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17484: LD_EXP 44
17488: PUSH
17489: LD_EXP 59
17493: IN
17494: PUSH
17495: LD_EXP 44
17499: PPUSH
17500: CALL_OW 255
17504: PUSH
17505: LD_INT 1
17507: EQUAL
17508: AND
17509: IFFALSE 17525
// Say ( Bobby , D3nW-Bobby-1 ) else
17511: LD_EXP 44
17515: PPUSH
17516: LD_STRING D3nW-Bobby-1
17518: PPUSH
17519: CALL_OW 88
17523: GO 17687
// if Gary in vip and GetSide ( Gary ) = 1 then
17525: LD_EXP 51
17529: PUSH
17530: LD_EXP 59
17534: IN
17535: PUSH
17536: LD_EXP 51
17540: PPUSH
17541: CALL_OW 255
17545: PUSH
17546: LD_INT 1
17548: EQUAL
17549: AND
17550: IFFALSE 17566
// Say ( Gary , D3nW-Gary-1 ) else
17552: LD_EXP 51
17556: PPUSH
17557: LD_STRING D3nW-Gary-1
17559: PPUSH
17560: CALL_OW 88
17564: GO 17687
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17566: LD_EXP 43
17570: PUSH
17571: LD_EXP 59
17575: IN
17576: PUSH
17577: LD_EXP 43
17581: PPUSH
17582: CALL_OW 255
17586: PUSH
17587: LD_INT 1
17589: EQUAL
17590: AND
17591: IFFALSE 17607
// Say ( Donaldson , D3nW-Don-1 ) else
17593: LD_EXP 43
17597: PPUSH
17598: LD_STRING D3nW-Don-1
17600: PPUSH
17601: CALL_OW 88
17605: GO 17687
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17607: LD_EXP 50
17611: PUSH
17612: LD_EXP 59
17616: IN
17617: PUSH
17618: LD_EXP 50
17622: PPUSH
17623: CALL_OW 255
17627: PUSH
17628: LD_INT 1
17630: EQUAL
17631: AND
17632: IFFALSE 17648
// Say ( Cornel , D3nW-Corn-1 ) else
17634: LD_EXP 50
17638: PPUSH
17639: LD_STRING D3nW-Corn-1
17641: PPUSH
17642: CALL_OW 88
17646: GO 17687
// if Frank in vip and GetSide ( Frank ) = 1 then
17648: LD_EXP 52
17652: PUSH
17653: LD_EXP 59
17657: IN
17658: PUSH
17659: LD_EXP 52
17663: PPUSH
17664: CALL_OW 255
17668: PUSH
17669: LD_INT 1
17671: EQUAL
17672: AND
17673: IFFALSE 17687
// Say ( Frank , D3nW-Frank-1 ) ;
17675: LD_EXP 52
17679: PPUSH
17680: LD_STRING D3nW-Frank-1
17682: PPUSH
17683: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17687: LD_EXP 59
17691: PPUSH
17692: LD_INT 22
17694: PUSH
17695: LD_INT 1
17697: PUSH
17698: EMPTY
17699: LIST
17700: LIST
17701: PPUSH
17702: CALL_OW 72
17706: IFFALSE 17732
// begin Say ( JMM , D3nW-JMM-1 ) ;
17708: LD_EXP 39
17712: PPUSH
17713: LD_STRING D3nW-JMM-1
17715: PPUSH
17716: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17720: LD_EXP 39
17724: PPUSH
17725: LD_STRING D3nW-JMM-1a
17727: PPUSH
17728: CALL_OW 88
// end ; t := 0 0$00 ;
17732: LD_ADDR_VAR 0 3
17736: PUSH
17737: LD_INT 0
17739: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17740: LD_INT 35
17742: PPUSH
17743: CALL_OW 67
// t := t + 0 0$1 ;
17747: LD_ADDR_VAR 0 3
17751: PUSH
17752: LD_VAR 0 3
17756: PUSH
17757: LD_INT 35
17759: PLUS
17760: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17761: LD_INT 59
17763: PPUSH
17764: LD_INT 112
17766: PPUSH
17767: CALL_OW 428
17771: PUSH
17772: LD_VAR 0 3
17776: PUSH
17777: LD_INT 2100
17779: GREATER
17780: OR
17781: IFFALSE 17740
// activeAttacks := true ;
17783: LD_ADDR_EXP 16
17787: PUSH
17788: LD_INT 1
17790: ST_TO_ADDR
// end ;
17791: LD_VAR 0 1
17795: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17796: LD_INT 0
17798: PPUSH
// case question of 1 :
17799: LD_VAR 0 1
17803: PUSH
17804: LD_INT 1
17806: DOUBLE
17807: EQUAL
17808: IFTRUE 17812
17810: GO 17863
17812: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17813: LD_EXP 39
17817: PPUSH
17818: LD_STRING D2Mot-JMM-1
17820: PPUSH
17821: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17825: LD_EXP 58
17829: PPUSH
17830: LD_STRING D2Mot-Pow-1
17832: PPUSH
17833: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17837: LD_EXP 39
17841: PPUSH
17842: LD_STRING D2Mot-JMM-2
17844: PPUSH
17845: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17849: LD_EXP 58
17853: PPUSH
17854: LD_STRING D2Mot-Pow-2
17856: PPUSH
17857: CALL_OW 88
// end ; 2 :
17861: GO 18214
17863: LD_INT 2
17865: DOUBLE
17866: EQUAL
17867: IFTRUE 17871
17869: GO 17947
17871: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17872: LD_EXP 39
17876: PPUSH
17877: LD_STRING D2Rus-JMM-1
17879: PPUSH
17880: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17884: LD_EXP 58
17888: PPUSH
17889: LD_STRING D2Rus-Pow-1
17891: PPUSH
17892: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17896: LD_EXP 39
17900: PPUSH
17901: LD_STRING D2Rus-JMM-2
17903: PPUSH
17904: CALL_OW 88
// if not ( 3 in list_of_q ) then
17908: LD_INT 3
17910: PUSH
17911: LD_VAR 0 2
17915: IN
17916: NOT
17917: IFFALSE 17933
// Say ( Powell , D2Rus-Pow-2 ) else
17919: LD_EXP 58
17923: PPUSH
17924: LD_STRING D2Rus-Pow-2
17926: PPUSH
17927: CALL_OW 88
17931: GO 17945
// Say ( Powell , D2Rus-Pow-2a ) ;
17933: LD_EXP 58
17937: PPUSH
17938: LD_STRING D2Rus-Pow-2a
17940: PPUSH
17941: CALL_OW 88
// end ; 3 :
17945: GO 18214
17947: LD_INT 3
17949: DOUBLE
17950: EQUAL
17951: IFTRUE 17955
17953: GO 18040
17955: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17956: LD_EXP 39
17960: PPUSH
17961: LD_STRING D2Leg-JMM-1
17963: PPUSH
17964: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17968: LD_EXP 58
17972: PPUSH
17973: LD_STRING D2Leg-Pow-1
17975: PPUSH
17976: CALL_OW 88
// if 2 in list_of_q then
17980: LD_INT 2
17982: PUSH
17983: LD_VAR 0 2
17987: IN
17988: IFFALSE 18014
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17990: LD_EXP 39
17994: PPUSH
17995: LD_STRING D2Leg-JMM-2
17997: PPUSH
17998: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
18002: LD_EXP 58
18006: PPUSH
18007: LD_STRING D2Leg-Pow-2
18009: PPUSH
18010: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
18014: LD_EXP 39
18018: PPUSH
18019: LD_STRING D2Leg-JMM-3
18021: PPUSH
18022: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18026: LD_EXP 58
18030: PPUSH
18031: LD_STRING D2Leg-Pow-3
18033: PPUSH
18034: CALL_OW 88
// end ; 4 :
18038: GO 18214
18040: LD_INT 4
18042: DOUBLE
18043: EQUAL
18044: IFTRUE 18048
18046: GO 18123
18048: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18049: LD_EXP 39
18053: PPUSH
18054: LD_STRING D2Ar-JMM-1
18056: PPUSH
18057: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18061: LD_EXP 58
18065: PPUSH
18066: LD_STRING D2Ar-Pow-1
18068: PPUSH
18069: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18073: LD_EXP 39
18077: PPUSH
18078: LD_STRING D2Ar-JMM-2
18080: PPUSH
18081: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18085: LD_EXP 58
18089: PPUSH
18090: LD_STRING D2Ar-Pow-2
18092: PPUSH
18093: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18097: LD_EXP 39
18101: PPUSH
18102: LD_STRING D2Ar-JMM-3
18104: PPUSH
18105: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18109: LD_EXP 58
18113: PPUSH
18114: LD_STRING D2Ar-Pow-3
18116: PPUSH
18117: CALL_OW 88
// end ; 5 :
18121: GO 18214
18123: LD_INT 5
18125: DOUBLE
18126: EQUAL
18127: IFTRUE 18131
18129: GO 18146
18131: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18132: LD_EXP 39
18136: PPUSH
18137: LD_STRING D2Conf-JMM-1
18139: PPUSH
18140: CALL_OW 88
18144: GO 18214
18146: LD_INT 6
18148: DOUBLE
18149: EQUAL
18150: IFTRUE 18154
18152: GO 18213
18154: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18155: LD_EXP 39
18159: PPUSH
18160: LD_STRING D2Com-JMM-1
18162: PPUSH
18163: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18167: LD_EXP 58
18171: PPUSH
18172: LD_STRING D2Com-Pow-1
18174: PPUSH
18175: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18179: LD_EXP 39
18183: PPUSH
18184: LD_STRING D2Com-JMM-2
18186: PPUSH
18187: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18191: LD_EXP 58
18195: PPUSH
18196: LD_STRING D2Com-Pow-2
18198: PPUSH
18199: CALL_OW 88
// powellAngerQuery := true ;
18203: LD_ADDR_EXP 36
18207: PUSH
18208: LD_INT 1
18210: ST_TO_ADDR
// end ; end ;
18211: GO 18214
18213: POP
// end ;
18214: LD_VAR 0 3
18218: RET
// every 0 0$5 trigger missionStart do var tmp ;
18219: LD_EXP 13
18223: IFFALSE 18506
18225: GO 18227
18227: DISABLE
18228: LD_INT 0
18230: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18231: LD_INT 35
18233: PPUSH
18234: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18238: LD_INT 14
18240: PPUSH
18241: LD_INT 22
18243: PUSH
18244: LD_INT 1
18246: PUSH
18247: EMPTY
18248: LIST
18249: LIST
18250: PPUSH
18251: CALL_OW 70
18255: PUSH
18256: LD_EXP 15
18260: PUSH
18261: LD_INT 2
18263: PUSH
18264: LD_INT 3
18266: PUSH
18267: LD_INT 4
18269: PUSH
18270: LD_INT 5
18272: PUSH
18273: EMPTY
18274: LIST
18275: LIST
18276: LIST
18277: LIST
18278: IN
18279: AND
18280: IFFALSE 18496
// begin powellAnger := powellAnger + 1 ;
18282: LD_ADDR_EXP 17
18286: PUSH
18287: LD_EXP 17
18291: PUSH
18292: LD_INT 1
18294: PLUS
18295: ST_TO_ADDR
// Video ( true ) ;
18296: LD_INT 1
18298: PPUSH
18299: CALL 101143 0 1
// CenterNowOnUnits ( tmp ) ;
18303: LD_VAR 0 1
18307: PPUSH
18308: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18312: LD_INT 14
18314: PPUSH
18315: LD_INT 22
18317: PUSH
18318: LD_INT 1
18320: PUSH
18321: EMPTY
18322: LIST
18323: LIST
18324: PPUSH
18325: CALL_OW 70
18329: PPUSH
18330: LD_INT 86
18332: PPUSH
18333: LD_INT 133
18335: PPUSH
18336: CALL_OW 111
// async ;
18340: ASYNC
// case powellAnger of 1 :
18341: LD_EXP 17
18345: PUSH
18346: LD_INT 1
18348: DOUBLE
18349: EQUAL
18350: IFTRUE 18354
18352: GO 18369
18354: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18355: LD_EXP 58
18359: PPUSH
18360: LD_STRING DBack1-Pow-1
18362: PPUSH
18363: CALL_OW 88
18367: GO 18416
18369: LD_INT 2
18371: DOUBLE
18372: EQUAL
18373: IFTRUE 18377
18375: GO 18392
18377: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18378: LD_EXP 58
18382: PPUSH
18383: LD_STRING DBack2-Pow-1
18385: PPUSH
18386: CALL_OW 88
18390: GO 18416
18392: LD_INT 3
18394: DOUBLE
18395: EQUAL
18396: IFTRUE 18400
18398: GO 18415
18400: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18401: LD_EXP 58
18405: PPUSH
18406: LD_STRING DBack3-Pow-1
18408: PPUSH
18409: CALL_OW 88
18413: GO 18416
18415: POP
// sync ;
18416: SYNC
// repeat wait ( 0 0$1 ) ;
18417: LD_INT 35
18419: PPUSH
18420: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18424: LD_INT 14
18426: PPUSH
18427: LD_INT 22
18429: PUSH
18430: LD_INT 1
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: PPUSH
18437: CALL_OW 70
18441: PPUSH
18442: LD_INT 86
18444: PPUSH
18445: LD_INT 133
18447: PPUSH
18448: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18452: LD_INT 14
18454: PPUSH
18455: LD_INT 22
18457: PUSH
18458: LD_INT 1
18460: PUSH
18461: EMPTY
18462: LIST
18463: LIST
18464: PPUSH
18465: CALL_OW 70
18469: NOT
18470: IFFALSE 18417
// if powellAnger >= 3 then
18472: LD_EXP 17
18476: PUSH
18477: LD_INT 3
18479: GREATEREQUAL
18480: IFFALSE 18489
// YouLost ( Dismissed ) ;
18482: LD_STRING Dismissed
18484: PPUSH
18485: CALL_OW 104
// Video ( false ) ;
18489: LD_INT 0
18491: PPUSH
18492: CALL 101143 0 1
// end ; until missionStage > 5 ;
18496: LD_EXP 15
18500: PUSH
18501: LD_INT 5
18503: GREATER
18504: IFFALSE 18231
// end ;
18506: PPOPN 1
18508: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18509: LD_EXP 13
18513: PUSH
18514: LD_INT 22
18516: PUSH
18517: LD_INT 4
18519: PUSH
18520: EMPTY
18521: LIST
18522: LIST
18523: PUSH
18524: LD_INT 21
18526: PUSH
18527: LD_INT 2
18529: PUSH
18530: EMPTY
18531: LIST
18532: LIST
18533: PUSH
18534: EMPTY
18535: LIST
18536: LIST
18537: PPUSH
18538: CALL_OW 69
18542: PUSH
18543: LD_INT 4
18545: GREATEREQUAL
18546: AND
18547: PUSH
18548: LD_EXP 15
18552: PUSH
18553: LD_INT 2
18555: EQUAL
18556: AND
18557: IFFALSE 20380
18559: GO 18561
18561: DISABLE
18562: LD_INT 0
18564: PPUSH
18565: PPUSH
18566: PPUSH
18567: PPUSH
18568: PPUSH
18569: PPUSH
18570: PPUSH
18571: PPUSH
// begin missionStage := 3 ;
18572: LD_ADDR_EXP 15
18576: PUSH
18577: LD_INT 3
18579: ST_TO_ADDR
// retreat := false ;
18580: LD_ADDR_VAR 0 4
18584: PUSH
18585: LD_INT 0
18587: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18588: LD_ADDR_VAR 0 5
18592: PUSH
18593: LD_INT 22
18595: PUSH
18596: LD_INT 4
18598: PUSH
18599: EMPTY
18600: LIST
18601: LIST
18602: PUSH
18603: LD_INT 30
18605: PUSH
18606: LD_INT 4
18608: PUSH
18609: EMPTY
18610: LIST
18611: LIST
18612: PUSH
18613: EMPTY
18614: LIST
18615: LIST
18616: PPUSH
18617: CALL_OW 69
18621: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18622: LD_ADDR_VAR 0 6
18626: PUSH
18627: LD_INT 22
18629: PUSH
18630: LD_INT 4
18632: PUSH
18633: EMPTY
18634: LIST
18635: LIST
18636: PUSH
18637: LD_INT 30
18639: PUSH
18640: LD_INT 5
18642: PUSH
18643: EMPTY
18644: LIST
18645: LIST
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: PPUSH
18651: CALL_OW 69
18655: ST_TO_ADDR
// if not bar then
18656: LD_VAR 0 6
18660: NOT
18661: IFFALSE 18714
// begin repeat wait ( 0 0$1 ) ;
18663: LD_INT 35
18665: PPUSH
18666: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18670: LD_INT 22
18672: PUSH
18673: LD_INT 4
18675: PUSH
18676: EMPTY
18677: LIST
18678: LIST
18679: PUSH
18680: LD_INT 3
18682: PUSH
18683: LD_INT 57
18685: PUSH
18686: EMPTY
18687: LIST
18688: PUSH
18689: EMPTY
18690: LIST
18691: LIST
18692: PUSH
18693: LD_INT 30
18695: PUSH
18696: LD_INT 5
18698: PUSH
18699: EMPTY
18700: LIST
18701: LIST
18702: PUSH
18703: EMPTY
18704: LIST
18705: LIST
18706: LIST
18707: PPUSH
18708: CALL_OW 69
18712: IFFALSE 18663
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18714: LD_ADDR_VAR 0 6
18718: PUSH
18719: LD_INT 22
18721: PUSH
18722: LD_INT 4
18724: PUSH
18725: EMPTY
18726: LIST
18727: LIST
18728: PUSH
18729: LD_INT 30
18731: PUSH
18732: LD_INT 5
18734: PUSH
18735: EMPTY
18736: LIST
18737: LIST
18738: PUSH
18739: EMPTY
18740: LIST
18741: LIST
18742: PPUSH
18743: CALL_OW 69
18747: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18748: LD_INT 35
18750: PPUSH
18751: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18755: LD_EXP 132
18759: PUSH
18760: LD_INT 4
18762: ARRAY
18763: PUSH
18764: LD_INT 4
18766: GREATEREQUAL
18767: IFFALSE 18748
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18769: LD_ADDR_VAR 0 2
18773: PUSH
18774: LD_INT 22
18776: PUSH
18777: LD_INT 4
18779: PUSH
18780: EMPTY
18781: LIST
18782: LIST
18783: PUSH
18784: LD_INT 2
18786: PUSH
18787: LD_INT 25
18789: PUSH
18790: LD_INT 1
18792: PUSH
18793: EMPTY
18794: LIST
18795: LIST
18796: PUSH
18797: LD_INT 25
18799: PUSH
18800: LD_INT 2
18802: PUSH
18803: EMPTY
18804: LIST
18805: LIST
18806: PUSH
18807: LD_INT 25
18809: PUSH
18810: LD_INT 3
18812: PUSH
18813: EMPTY
18814: LIST
18815: LIST
18816: PUSH
18817: LD_INT 25
18819: PUSH
18820: LD_INT 4
18822: PUSH
18823: EMPTY
18824: LIST
18825: LIST
18826: PUSH
18827: LD_INT 25
18829: PUSH
18830: LD_INT 5
18832: PUSH
18833: EMPTY
18834: LIST
18835: LIST
18836: PUSH
18837: EMPTY
18838: LIST
18839: LIST
18840: LIST
18841: LIST
18842: LIST
18843: LIST
18844: PUSH
18845: EMPTY
18846: LIST
18847: LIST
18848: PPUSH
18849: CALL_OW 69
18853: PUSH
18854: LD_EXP 58
18858: PUSH
18859: LD_EXP 59
18863: ADD
18864: DIFF
18865: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18866: LD_ADDR_VAR 0 3
18870: PUSH
18871: LD_VAR 0 2
18875: PPUSH
18876: LD_INT 26
18878: PUSH
18879: LD_INT 1
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: PPUSH
18886: CALL_OW 72
18890: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18891: LD_ADDR_VAR 0 2
18895: PUSH
18896: LD_VAR 0 2
18900: PUSH
18901: LD_VAR 0 3
18905: DIFF
18906: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18907: LD_ADDR_VAR 0 2
18911: PUSH
18912: LD_VAR 0 2
18916: PPUSH
18917: LD_INT 1
18919: PPUSH
18920: CALL 99677 0 2
18924: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18925: LD_ADDR_VAR 0 3
18929: PUSH
18930: LD_VAR 0 3
18934: PPUSH
18935: LD_INT 1
18937: PPUSH
18938: CALL 99677 0 2
18942: ST_TO_ADDR
// for i = 1 to 4 do
18943: LD_ADDR_VAR 0 1
18947: PUSH
18948: DOUBLE
18949: LD_INT 1
18951: DEC
18952: ST_TO_ADDR
18953: LD_INT 4
18955: PUSH
18956: FOR_TO
18957: IFFALSE 19123
// begin if tmp2 then
18959: LD_VAR 0 3
18963: IFFALSE 19044
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18965: LD_ADDR_EXP 18
18969: PUSH
18970: LD_EXP 18
18974: PPUSH
18975: LD_INT 1
18977: PPUSH
18978: LD_EXP 18
18982: PUSH
18983: LD_INT 1
18985: ARRAY
18986: PUSH
18987: LD_VAR 0 3
18991: PUSH
18992: LD_VAR 0 3
18996: ARRAY
18997: ADD
18998: PPUSH
18999: CALL_OW 1
19003: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
19004: LD_VAR 0 3
19008: PUSH
19009: LD_VAR 0 3
19013: ARRAY
19014: PPUSH
19015: LD_INT 1
19017: PPUSH
19018: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
19022: LD_ADDR_VAR 0 3
19026: PUSH
19027: LD_VAR 0 3
19031: PPUSH
19032: LD_VAR 0 3
19036: PPUSH
19037: CALL_OW 3
19041: ST_TO_ADDR
// end else
19042: GO 19121
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19044: LD_ADDR_EXP 18
19048: PUSH
19049: LD_EXP 18
19053: PPUSH
19054: LD_INT 1
19056: PPUSH
19057: LD_EXP 18
19061: PUSH
19062: LD_INT 1
19064: ARRAY
19065: PUSH
19066: LD_VAR 0 2
19070: PUSH
19071: LD_VAR 0 2
19075: ARRAY
19076: ADD
19077: PPUSH
19078: CALL_OW 1
19082: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19083: LD_VAR 0 2
19087: PUSH
19088: LD_VAR 0 2
19092: ARRAY
19093: PPUSH
19094: LD_INT 1
19096: PPUSH
19097: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19101: LD_ADDR_VAR 0 2
19105: PUSH
19106: LD_VAR 0 2
19110: PPUSH
19111: LD_VAR 0 2
19115: PPUSH
19116: CALL_OW 3
19120: ST_TO_ADDR
// end ; end ;
19121: GO 18956
19123: POP
19124: POP
// if tmp2 then
19125: LD_VAR 0 3
19129: IFFALSE 19147
// tmp := tmp union tmp2 ;
19131: LD_ADDR_VAR 0 2
19135: PUSH
19136: LD_VAR 0 2
19140: PUSH
19141: LD_VAR 0 3
19145: UNION
19146: ST_TO_ADDR
// for i = 1 to 4 do
19147: LD_ADDR_VAR 0 1
19151: PUSH
19152: DOUBLE
19153: LD_INT 1
19155: DEC
19156: ST_TO_ADDR
19157: LD_INT 4
19159: PUSH
19160: FOR_TO
19161: IFFALSE 19210
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19163: LD_ADDR_EXP 18
19167: PUSH
19168: LD_EXP 18
19172: PPUSH
19173: LD_INT 2
19175: PPUSH
19176: LD_EXP 18
19180: PUSH
19181: LD_INT 2
19183: ARRAY
19184: PUSH
19185: LD_VAR 0 2
19189: PUSH
19190: LD_VAR 0 2
19194: PUSH
19195: LD_VAR 0 1
19199: MINUS
19200: ARRAY
19201: ADD
19202: PPUSH
19203: CALL_OW 1
19207: ST_TO_ADDR
19208: GO 19160
19210: POP
19211: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19212: LD_ADDR_EXP 113
19216: PUSH
19217: LD_EXP 113
19221: PPUSH
19222: LD_INT 4
19224: PPUSH
19225: LD_EXP 113
19229: PUSH
19230: LD_INT 4
19232: ARRAY
19233: PUSH
19234: LD_EXP 18
19238: PUSH
19239: LD_INT 1
19241: ARRAY
19242: DIFF
19243: PPUSH
19244: CALL_OW 1
19248: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19249: LD_VAR 0 5
19253: PUSH
19254: LD_INT 1
19256: ARRAY
19257: PPUSH
19258: CALL_OW 313
19262: IFFALSE 19317
// begin for i in UnitsInside ( arm [ 1 ] ) do
19264: LD_ADDR_VAR 0 1
19268: PUSH
19269: LD_VAR 0 5
19273: PUSH
19274: LD_INT 1
19276: ARRAY
19277: PPUSH
19278: CALL_OW 313
19282: PUSH
19283: FOR_IN
19284: IFFALSE 19315
// begin ComExitBuilding ( i ) ;
19286: LD_VAR 0 1
19290: PPUSH
19291: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19295: LD_VAR 0 1
19299: PPUSH
19300: LD_VAR 0 6
19304: PUSH
19305: LD_INT 1
19307: ARRAY
19308: PPUSH
19309: CALL_OW 180
// end ;
19313: GO 19283
19315: POP
19316: POP
// end ; wait ( 0 0$3 ) ;
19317: LD_INT 105
19319: PPUSH
19320: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19324: LD_ADDR_VAR 0 1
19328: PUSH
19329: LD_EXP 18
19333: PUSH
19334: LD_INT 1
19336: ARRAY
19337: PUSH
19338: FOR_IN
19339: IFFALSE 19446
// begin if IsInUnit ( i ) then
19341: LD_VAR 0 1
19345: PPUSH
19346: CALL_OW 310
19350: IFFALSE 19361
// ComExitBuilding ( i ) ;
19352: LD_VAR 0 1
19356: PPUSH
19357: CALL_OW 122
// if GetClass ( i ) <> 1 then
19361: LD_VAR 0 1
19365: PPUSH
19366: CALL_OW 257
19370: PUSH
19371: LD_INT 1
19373: NONEQUAL
19374: IFFALSE 19415
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19376: LD_VAR 0 1
19380: PPUSH
19381: LD_VAR 0 5
19385: PUSH
19386: LD_INT 1
19388: ARRAY
19389: PPUSH
19390: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19394: LD_VAR 0 1
19398: PPUSH
19399: LD_INT 1
19401: PPUSH
19402: CALL_OW 183
// AddComExitBuilding ( i ) ;
19406: LD_VAR 0 1
19410: PPUSH
19411: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19415: LD_VAR 0 1
19419: PPUSH
19420: LD_INT 60
19422: PPUSH
19423: LD_INT 94
19425: PPUSH
19426: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19430: LD_VAR 0 1
19434: PPUSH
19435: LD_EXP 58
19439: PPUSH
19440: CALL_OW 179
// end ;
19444: GO 19338
19446: POP
19447: POP
// wait ( 0 0$15 ) ;
19448: LD_INT 525
19450: PPUSH
19451: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19455: LD_EXP 58
19459: PPUSH
19460: LD_STRING D4-Pow-1
19462: PPUSH
19463: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19467: LD_ADDR_VAR 0 2
19471: PUSH
19472: LD_EXP 18
19476: PUSH
19477: LD_INT 1
19479: ARRAY
19480: PPUSH
19481: LD_INT 26
19483: PUSH
19484: LD_INT 1
19486: PUSH
19487: EMPTY
19488: LIST
19489: LIST
19490: PPUSH
19491: CALL_OW 72
19495: ST_TO_ADDR
// if tmp then
19496: LD_VAR 0 2
19500: IFFALSE 19518
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19502: LD_VAR 0 2
19506: PUSH
19507: LD_INT 1
19509: ARRAY
19510: PPUSH
19511: LD_STRING D4-Sol1-1
19513: PPUSH
19514: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19518: LD_EXP 58
19522: PPUSH
19523: LD_STRING D4-Pow-2
19525: PPUSH
19526: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19530: LD_ADDR_VAR 0 1
19534: PUSH
19535: DOUBLE
19536: LD_INT 1
19538: DEC
19539: ST_TO_ADDR
19540: LD_EXP 18
19544: PUSH
19545: LD_INT 1
19547: ARRAY
19548: PUSH
19549: FOR_TO
19550: IFFALSE 19643
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19552: LD_EXP 18
19556: PUSH
19557: LD_INT 1
19559: ARRAY
19560: PUSH
19561: LD_VAR 0 1
19565: ARRAY
19566: PPUSH
19567: LD_EXP 132
19571: PUSH
19572: LD_INT 4
19574: ARRAY
19575: PUSH
19576: LD_INT 1
19578: ARRAY
19579: PPUSH
19580: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19584: LD_ADDR_EXP 132
19588: PUSH
19589: LD_EXP 132
19593: PPUSH
19594: LD_INT 4
19596: PPUSH
19597: LD_EXP 132
19601: PUSH
19602: LD_INT 4
19604: ARRAY
19605: PPUSH
19606: LD_INT 1
19608: PPUSH
19609: CALL_OW 3
19613: PPUSH
19614: CALL_OW 1
19618: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19619: LD_INT 8
19621: PPUSH
19622: LD_EXP 18
19626: PUSH
19627: LD_INT 1
19629: ARRAY
19630: PUSH
19631: LD_VAR 0 1
19635: ARRAY
19636: PPUSH
19637: CALL_OW 471
// end ;
19641: GO 19549
19643: POP
19644: POP
// repeat wait ( 0 0$1 ) ;
19645: LD_INT 35
19647: PPUSH
19648: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19652: LD_EXP 18
19656: PUSH
19657: LD_INT 1
19659: ARRAY
19660: PPUSH
19661: LD_INT 55
19663: PUSH
19664: EMPTY
19665: LIST
19666: PPUSH
19667: CALL_OW 72
19671: PUSH
19672: LD_INT 4
19674: GREATEREQUAL
19675: IFFALSE 19645
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19677: LD_EXP 18
19681: PUSH
19682: LD_INT 1
19684: ARRAY
19685: PPUSH
19686: LD_INT 69
19688: PPUSH
19689: LD_INT 94
19691: PPUSH
19692: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19696: LD_EXP 18
19700: PUSH
19701: LD_INT 1
19703: ARRAY
19704: PPUSH
19705: LD_INT 82
19707: PPUSH
19708: LD_INT 83
19710: PPUSH
19711: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19715: LD_EXP 18
19719: PUSH
19720: LD_INT 1
19722: ARRAY
19723: PPUSH
19724: LD_INT 77
19726: PPUSH
19727: LD_INT 69
19729: PPUSH
19730: CALL_OW 174
// repeat wait ( 3 ) ;
19734: LD_INT 3
19736: PPUSH
19737: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19741: LD_ADDR_VAR 0 1
19745: PUSH
19746: LD_EXP 18
19750: PUSH
19751: LD_INT 1
19753: ARRAY
19754: PUSH
19755: FOR_IN
19756: IFFALSE 19892
// begin if GetLives ( i ) < 990 then
19758: LD_VAR 0 1
19762: PPUSH
19763: CALL_OW 256
19767: PUSH
19768: LD_INT 990
19770: LESS
19771: IFFALSE 19785
// SetLives ( i , 1000 ) ;
19773: LD_VAR 0 1
19777: PPUSH
19778: LD_INT 1000
19780: PPUSH
19781: CALL_OW 234
// if not IsInUnit ( i ) then
19785: LD_VAR 0 1
19789: PPUSH
19790: CALL_OW 310
19794: NOT
19795: IFFALSE 19890
// begin if not HasTask ( i ) then
19797: LD_VAR 0 1
19801: PPUSH
19802: CALL_OW 314
19806: NOT
19807: IFFALSE 19824
// ComMoveXY ( i , 64 , 93 ) ;
19809: LD_VAR 0 1
19813: PPUSH
19814: LD_INT 64
19816: PPUSH
19817: LD_INT 93
19819: PPUSH
19820: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19824: LD_VAR 0 4
19828: NOT
19829: PUSH
19830: LD_VAR 0 1
19834: PPUSH
19835: CALL_OW 258
19839: PUSH
19840: LD_INT 1
19842: EQUAL
19843: AND
19844: IFFALSE 19890
// begin retreat := true ;
19846: LD_ADDR_VAR 0 4
19850: PUSH
19851: LD_INT 1
19853: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19854: LD_VAR 0 1
19858: PPUSH
19859: LD_INT 2
19861: PPUSH
19862: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19866: LD_VAR 0 1
19870: PPUSH
19871: LD_STRING D4a-Sol1-1
19873: PPUSH
19874: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19878: LD_EXP 58
19882: PPUSH
19883: LD_STRING D4a-Pow-1
19885: PPUSH
19886: CALL_OW 88
// end ; end ; end ;
19890: GO 19755
19892: POP
19893: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19894: LD_EXP 18
19898: PUSH
19899: LD_INT 1
19901: ARRAY
19902: PPUSH
19903: LD_INT 95
19905: PUSH
19906: LD_INT 9
19908: PUSH
19909: EMPTY
19910: LIST
19911: LIST
19912: PUSH
19913: LD_INT 3
19915: PUSH
19916: LD_INT 55
19918: PUSH
19919: EMPTY
19920: LIST
19921: PUSH
19922: EMPTY
19923: LIST
19924: LIST
19925: PUSH
19926: EMPTY
19927: LIST
19928: LIST
19929: PPUSH
19930: CALL_OW 72
19934: PUSH
19935: LD_INT 4
19937: GREATEREQUAL
19938: IFFALSE 19734
// for i in powellSquadAttack [ 1 ] do
19940: LD_ADDR_VAR 0 1
19944: PUSH
19945: LD_EXP 18
19949: PUSH
19950: LD_INT 1
19952: ARRAY
19953: PUSH
19954: FOR_IN
19955: IFFALSE 20091
// begin if GetTag ( i ) = 2 then
19957: LD_VAR 0 1
19961: PPUSH
19962: CALL_OW 110
19966: PUSH
19967: LD_INT 2
19969: EQUAL
19970: IFFALSE 20032
// begin ComMoveXY ( i , 60 , 94 ) ;
19972: LD_VAR 0 1
19976: PPUSH
19977: LD_INT 60
19979: PPUSH
19980: LD_INT 94
19982: PPUSH
19983: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19987: LD_VAR 0 1
19991: PPUSH
19992: LD_EXP 58
19996: PPUSH
19997: CALL_OW 179
// wait ( 0 0$3 ) ;
20001: LD_INT 105
20003: PPUSH
20004: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
20008: LD_VAR 0 1
20012: PPUSH
20013: LD_STRING D4a-Sol1-2
20015: PPUSH
20016: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
20020: LD_EXP 58
20024: PPUSH
20025: LD_STRING D4a-Pow-2
20027: PPUSH
20028: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
20032: LD_VAR 0 1
20036: PPUSH
20037: LD_INT 0
20039: PPUSH
20040: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20044: LD_ADDR_EXP 113
20048: PUSH
20049: LD_EXP 113
20053: PPUSH
20054: LD_INT 4
20056: PPUSH
20057: LD_EXP 113
20061: PUSH
20062: LD_INT 4
20064: ARRAY
20065: PUSH
20066: LD_VAR 0 1
20070: UNION
20071: PPUSH
20072: CALL_OW 1
20076: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20077: LD_INT 8
20079: PPUSH
20080: LD_VAR 0 1
20084: PPUSH
20085: CALL_OW 472
// end ;
20089: GO 19954
20091: POP
20092: POP
// wait ( 4 4$00 ) ;
20093: LD_INT 8400
20095: PPUSH
20096: CALL_OW 67
// uc_side := 6 ;
20100: LD_ADDR_OWVAR 20
20104: PUSH
20105: LD_INT 6
20107: ST_TO_ADDR
// uc_nation := 3 ;
20108: LD_ADDR_OWVAR 21
20112: PUSH
20113: LD_INT 3
20115: ST_TO_ADDR
// ru := [ ] ;
20116: LD_ADDR_VAR 0 7
20120: PUSH
20121: EMPTY
20122: ST_TO_ADDR
// for i = 1 to 4 do
20123: LD_ADDR_VAR 0 1
20127: PUSH
20128: DOUBLE
20129: LD_INT 1
20131: DEC
20132: ST_TO_ADDR
20133: LD_INT 4
20135: PUSH
20136: FOR_TO
20137: IFFALSE 20238
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20139: LD_INT 22
20141: PPUSH
20142: LD_INT 1
20144: PPUSH
20145: LD_INT 3
20147: PPUSH
20148: LD_INT 43
20150: PUSH
20151: LD_INT 44
20153: PUSH
20154: EMPTY
20155: LIST
20156: LIST
20157: PUSH
20158: LD_INT 1
20160: PPUSH
20161: LD_INT 2
20163: PPUSH
20164: CALL_OW 12
20168: ARRAY
20169: PPUSH
20170: LD_INT 89
20172: PPUSH
20173: CALL 70006 0 5
// un := CreateVehicle ;
20177: LD_ADDR_VAR 0 8
20181: PUSH
20182: CALL_OW 45
20186: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20187: LD_VAR 0 8
20191: PPUSH
20192: LD_INT 4
20194: PPUSH
20195: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20199: LD_VAR 0 8
20203: PPUSH
20204: LD_INT 136
20206: PPUSH
20207: LD_INT 90
20209: PPUSH
20210: LD_INT 8
20212: PPUSH
20213: LD_INT 0
20215: PPUSH
20216: CALL_OW 50
// ru := ru ^ un ;
20220: LD_ADDR_VAR 0 7
20224: PUSH
20225: LD_VAR 0 7
20229: PUSH
20230: LD_VAR 0 8
20234: ADD
20235: ST_TO_ADDR
// end ;
20236: GO 20136
20238: POP
20239: POP
// if ru then
20240: LD_VAR 0 7
20244: IFFALSE 20261
// ComAgressiveMove ( ru , 80 , 92 ) ;
20246: LD_VAR 0 7
20250: PPUSH
20251: LD_INT 80
20253: PPUSH
20254: LD_INT 92
20256: PPUSH
20257: CALL_OW 114
// wait ( 8 8$00 ) ;
20261: LD_INT 16800
20263: PPUSH
20264: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20268: LD_INT 4
20270: PPUSH
20271: LD_INT 3
20273: PUSH
20274: LD_INT 1
20276: PUSH
20277: LD_INT 1
20279: PUSH
20280: LD_INT 5
20282: PUSH
20283: EMPTY
20284: LIST
20285: LIST
20286: LIST
20287: LIST
20288: PUSH
20289: LD_INT 4
20291: PUSH
20292: LD_INT 1
20294: PUSH
20295: LD_INT 1
20297: PUSH
20298: LD_INT 6
20300: PUSH
20301: EMPTY
20302: LIST
20303: LIST
20304: LIST
20305: LIST
20306: PUSH
20307: LD_INT 4
20309: PUSH
20310: LD_INT 1
20312: PUSH
20313: LD_INT 1
20315: PUSH
20316: LD_INT 7
20318: PUSH
20319: EMPTY
20320: LIST
20321: LIST
20322: LIST
20323: LIST
20324: PUSH
20325: LD_INT 3
20327: PUSH
20328: LD_INT 1
20330: PUSH
20331: LD_INT 1
20333: PUSH
20334: LD_INT 7
20336: PUSH
20337: EMPTY
20338: LIST
20339: LIST
20340: LIST
20341: LIST
20342: PUSH
20343: LD_INT 3
20345: PUSH
20346: LD_INT 1
20348: PUSH
20349: LD_INT 1
20351: PUSH
20352: LD_INT 5
20354: PUSH
20355: EMPTY
20356: LIST
20357: LIST
20358: LIST
20359: LIST
20360: PUSH
20361: EMPTY
20362: LIST
20363: LIST
20364: LIST
20365: LIST
20366: LIST
20367: PPUSH
20368: CALL 58771 0 2
// missionStage := 4 ;
20372: LD_ADDR_EXP 15
20376: PUSH
20377: LD_INT 4
20379: ST_TO_ADDR
// end ;
20380: PPOPN 8
20382: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20383: LD_EXP 15
20387: PUSH
20388: LD_INT 4
20390: EQUAL
20391: PUSH
20392: LD_INT 22
20394: PUSH
20395: LD_INT 4
20397: PUSH
20398: EMPTY
20399: LIST
20400: LIST
20401: PUSH
20402: LD_INT 21
20404: PUSH
20405: LD_INT 2
20407: PUSH
20408: EMPTY
20409: LIST
20410: LIST
20411: PUSH
20412: EMPTY
20413: LIST
20414: LIST
20415: PPUSH
20416: CALL_OW 69
20420: PUSH
20421: LD_INT 5
20423: GREATEREQUAL
20424: AND
20425: IFFALSE 24530
20427: GO 20429
20429: DISABLE
20430: LD_INT 0
20432: PPUSH
20433: PPUSH
20434: PPUSH
20435: PPUSH
20436: PPUSH
20437: PPUSH
20438: PPUSH
20439: PPUSH
20440: PPUSH
20441: PPUSH
20442: PPUSH
20443: PPUSH
20444: PPUSH
// begin missionStage := 5 ;
20445: LD_ADDR_EXP 15
20449: PUSH
20450: LD_INT 5
20452: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20453: LD_ADDR_VAR 0 10
20457: PUSH
20458: LD_INT 22
20460: PUSH
20461: LD_INT 4
20463: PUSH
20464: EMPTY
20465: LIST
20466: LIST
20467: PUSH
20468: LD_INT 2
20470: PUSH
20471: LD_INT 30
20473: PUSH
20474: LD_INT 4
20476: PUSH
20477: EMPTY
20478: LIST
20479: LIST
20480: PUSH
20481: LD_INT 30
20483: PUSH
20484: LD_INT 5
20486: PUSH
20487: EMPTY
20488: LIST
20489: LIST
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: LIST
20495: PUSH
20496: EMPTY
20497: LIST
20498: LIST
20499: PPUSH
20500: CALL_OW 69
20504: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20505: LD_ADDR_VAR 0 6
20509: PUSH
20510: LD_INT 22
20512: PUSH
20513: LD_INT 4
20515: PUSH
20516: EMPTY
20517: LIST
20518: LIST
20519: PUSH
20520: LD_INT 21
20522: PUSH
20523: LD_INT 1
20525: PUSH
20526: EMPTY
20527: LIST
20528: LIST
20529: PUSH
20530: LD_INT 3
20532: PUSH
20533: LD_INT 25
20535: PUSH
20536: LD_INT 16
20538: PUSH
20539: EMPTY
20540: LIST
20541: LIST
20542: PUSH
20543: EMPTY
20544: LIST
20545: LIST
20546: PUSH
20547: LD_INT 3
20549: PUSH
20550: LD_INT 25
20552: PUSH
20553: LD_INT 12
20555: PUSH
20556: EMPTY
20557: LIST
20558: LIST
20559: PUSH
20560: EMPTY
20561: LIST
20562: LIST
20563: PUSH
20564: EMPTY
20565: LIST
20566: LIST
20567: LIST
20568: LIST
20569: PPUSH
20570: CALL_OW 69
20574: PUSH
20575: LD_EXP 58
20579: DIFF
20580: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20581: LD_ADDR_VAR 0 9
20585: PUSH
20586: LD_INT 22
20588: PUSH
20589: LD_INT 4
20591: PUSH
20592: EMPTY
20593: LIST
20594: LIST
20595: PUSH
20596: LD_INT 30
20598: PUSH
20599: LD_INT 3
20601: PUSH
20602: EMPTY
20603: LIST
20604: LIST
20605: PUSH
20606: EMPTY
20607: LIST
20608: LIST
20609: PPUSH
20610: CALL_OW 69
20614: PUSH
20615: LD_INT 1
20617: ARRAY
20618: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20619: LD_INT 35
20621: PPUSH
20622: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20626: LD_EXP 132
20630: PUSH
20631: LD_INT 4
20633: ARRAY
20634: PUSH
20635: LD_INT 5
20637: GREATEREQUAL
20638: PUSH
20639: LD_EXP 132
20643: PUSH
20644: LD_INT 4
20646: ARRAY
20647: PPUSH
20648: LD_INT 58
20650: PUSH
20651: EMPTY
20652: LIST
20653: PPUSH
20654: CALL_OW 72
20658: PUSH
20659: LD_INT 5
20661: GREATEREQUAL
20662: AND
20663: IFFALSE 20619
// powellAllowRetreat := false ;
20665: LD_ADDR_EXP 19
20669: PUSH
20670: LD_INT 0
20672: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20673: LD_INT 700
20675: PPUSH
20676: CALL_OW 67
// activeAttacks := false ;
20680: LD_ADDR_EXP 16
20684: PUSH
20685: LD_INT 0
20687: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20688: LD_INT 35
20690: PPUSH
20691: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20695: LD_INT 22
20697: PUSH
20698: LD_INT 6
20700: PUSH
20701: EMPTY
20702: LIST
20703: LIST
20704: PPUSH
20705: CALL_OW 69
20709: PUSH
20710: LD_INT 0
20712: EQUAL
20713: IFFALSE 20688
// tmp := mc_vehicles [ 4 ] ;
20715: LD_ADDR_VAR 0 3
20719: PUSH
20720: LD_EXP 132
20724: PUSH
20725: LD_INT 4
20727: ARRAY
20728: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20729: LD_ADDR_VAR 0 1
20733: PUSH
20734: DOUBLE
20735: LD_INT 1
20737: DEC
20738: ST_TO_ADDR
20739: LD_EXP 18
20743: PUSH
20744: FOR_TO
20745: IFFALSE 21006
// begin for j in powellSquadAttack [ i ] do
20747: LD_ADDR_VAR 0 2
20751: PUSH
20752: LD_EXP 18
20756: PUSH
20757: LD_VAR 0 1
20761: ARRAY
20762: PUSH
20763: FOR_IN
20764: IFFALSE 21002
// begin forces := forces diff j ;
20766: LD_ADDR_VAR 0 6
20770: PUSH
20771: LD_VAR 0 6
20775: PUSH
20776: LD_VAR 0 2
20780: DIFF
20781: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20782: LD_VAR 0 2
20786: PPUSH
20787: LD_INT 1
20789: PPUSH
20790: CALL_OW 109
// wait ( 0 0$2 ) ;
20794: LD_INT 70
20796: PPUSH
20797: CALL_OW 67
// if IsInUnit ( j ) then
20801: LD_VAR 0 2
20805: PPUSH
20806: CALL_OW 310
20810: IFFALSE 20821
// ComExitBuilding ( j ) ;
20812: LD_VAR 0 2
20816: PPUSH
20817: CALL_OW 122
// if GetClass ( j ) <> 1 then
20821: LD_VAR 0 2
20825: PPUSH
20826: CALL_OW 257
20830: PUSH
20831: LD_INT 1
20833: NONEQUAL
20834: IFFALSE 20914
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20836: LD_VAR 0 10
20840: PUSH
20841: LD_INT 1
20843: ARRAY
20844: PPUSH
20845: CALL_OW 313
20849: PUSH
20850: LD_INT 5
20852: GREATEREQUAL
20853: IFFALSE 20875
// AddComEnterUnit ( j , arm [ 2 ] ) else
20855: LD_VAR 0 2
20859: PPUSH
20860: LD_VAR 0 10
20864: PUSH
20865: LD_INT 2
20867: ARRAY
20868: PPUSH
20869: CALL_OW 180
20873: GO 20893
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20875: LD_VAR 0 2
20879: PPUSH
20880: LD_VAR 0 10
20884: PUSH
20885: LD_INT 1
20887: ARRAY
20888: PPUSH
20889: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20893: LD_VAR 0 2
20897: PPUSH
20898: LD_INT 1
20900: PPUSH
20901: CALL_OW 183
// AddComExitBuilding ( j ) ;
20905: LD_VAR 0 2
20909: PPUSH
20910: CALL_OW 182
// end ; if i = 2 then
20914: LD_VAR 0 1
20918: PUSH
20919: LD_INT 2
20921: EQUAL
20922: IFFALSE 20939
// AddComMoveXY ( j , 61 , 93 ) ;
20924: LD_VAR 0 2
20928: PPUSH
20929: LD_INT 61
20931: PPUSH
20932: LD_INT 93
20934: PPUSH
20935: CALL_OW 171
// if i = 1 then
20939: LD_VAR 0 1
20943: PUSH
20944: LD_INT 1
20946: EQUAL
20947: IFFALSE 21000
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20949: LD_VAR 0 2
20953: PPUSH
20954: LD_VAR 0 3
20958: PUSH
20959: LD_INT 1
20961: ARRAY
20962: PPUSH
20963: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20967: LD_ADDR_VAR 0 3
20971: PUSH
20972: LD_VAR 0 3
20976: PPUSH
20977: LD_INT 1
20979: PPUSH
20980: CALL_OW 3
20984: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20985: LD_VAR 0 2
20989: PPUSH
20990: LD_INT 69
20992: PPUSH
20993: LD_INT 94
20995: PPUSH
20996: CALL_OW 171
// end ; end ;
21000: GO 20763
21002: POP
21003: POP
// end ;
21004: GO 20744
21006: POP
21007: POP
// wait ( 0 0$55 ) ;
21008: LD_INT 1925
21010: PPUSH
21011: CALL_OW 67
// MC_Kill ( 4 ) ;
21015: LD_INT 4
21017: PPUSH
21018: CALL 35349 0 1
// tmp := UnitsInside ( fac ) ;
21022: LD_ADDR_VAR 0 3
21026: PUSH
21027: LD_VAR 0 9
21031: PPUSH
21032: CALL_OW 313
21036: ST_TO_ADDR
// if tmp then
21037: LD_VAR 0 3
21041: IFFALSE 21162
// for i in tmp do
21043: LD_ADDR_VAR 0 1
21047: PUSH
21048: LD_VAR 0 3
21052: PUSH
21053: FOR_IN
21054: IFFALSE 21160
// begin ComExitBuilding ( i ) ;
21056: LD_VAR 0 1
21060: PPUSH
21061: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21065: LD_VAR 0 10
21069: PUSH
21070: LD_INT 2
21072: ARRAY
21073: PPUSH
21074: CALL_OW 313
21078: PUSH
21079: LD_INT 6
21081: LESS
21082: IFFALSE 21104
// AddComEnterUnit ( i , arm [ 2 ] ) else
21084: LD_VAR 0 1
21088: PPUSH
21089: LD_VAR 0 10
21093: PUSH
21094: LD_INT 2
21096: ARRAY
21097: PPUSH
21098: CALL_OW 180
21102: GO 21158
// if UnitsInside ( arm [ 1 ] ) < 6 then
21104: LD_VAR 0 10
21108: PUSH
21109: LD_INT 1
21111: ARRAY
21112: PPUSH
21113: CALL_OW 313
21117: PUSH
21118: LD_INT 6
21120: LESS
21121: IFFALSE 21143
// AddComEnterUnit ( i , arm [ 1 ] ) else
21123: LD_VAR 0 1
21127: PPUSH
21128: LD_VAR 0 10
21132: PUSH
21133: LD_INT 1
21135: ARRAY
21136: PPUSH
21137: CALL_OW 180
21141: GO 21158
// AddComMoveXY ( i , 37 , 68 ) ;
21143: LD_VAR 0 1
21147: PPUSH
21148: LD_INT 37
21150: PPUSH
21151: LD_INT 68
21153: PPUSH
21154: CALL_OW 171
// end ;
21158: GO 21053
21160: POP
21161: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21162: LD_ADDR_VAR 0 11
21166: PUSH
21167: LD_VAR 0 6
21171: PPUSH
21172: LD_INT 26
21174: PUSH
21175: LD_INT 1
21177: PUSH
21178: EMPTY
21179: LIST
21180: LIST
21181: PPUSH
21182: CALL_OW 72
21186: PUSH
21187: LD_EXP 59
21191: DIFF
21192: ST_TO_ADDR
// if not speaker then
21193: LD_VAR 0 11
21197: NOT
21198: IFFALSE 21225
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21200: LD_ADDR_VAR 0 11
21204: PUSH
21205: LD_VAR 0 6
21209: PPUSH
21210: LD_INT 26
21212: PUSH
21213: LD_INT 1
21215: PUSH
21216: EMPTY
21217: LIST
21218: LIST
21219: PPUSH
21220: CALL_OW 72
21224: ST_TO_ADDR
// if speaker then
21225: LD_VAR 0 11
21229: IFFALSE 21245
// speaker := speaker [ 1 ] ;
21231: LD_ADDR_VAR 0 11
21235: PUSH
21236: LD_VAR 0 11
21240: PUSH
21241: LD_INT 1
21243: ARRAY
21244: ST_TO_ADDR
// Video ( true ) ;
21245: LD_INT 1
21247: PPUSH
21248: CALL 101143 0 1
// CenterNowOnUnits ( Powell ) ;
21252: LD_EXP 58
21256: PPUSH
21257: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21261: LD_ADDR_VAR 0 3
21265: PUSH
21266: LD_VAR 0 6
21270: PPUSH
21271: LD_INT 3
21273: PUSH
21274: LD_INT 25
21276: PUSH
21277: LD_INT 1
21279: PUSH
21280: EMPTY
21281: LIST
21282: LIST
21283: PUSH
21284: EMPTY
21285: LIST
21286: LIST
21287: PPUSH
21288: CALL_OW 72
21292: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21293: LD_ADDR_VAR 0 12
21297: PUSH
21298: LD_INT 22
21300: PUSH
21301: LD_INT 4
21303: PUSH
21304: EMPTY
21305: LIST
21306: LIST
21307: PUSH
21308: LD_INT 30
21310: PUSH
21311: LD_INT 32
21313: PUSH
21314: EMPTY
21315: LIST
21316: LIST
21317: PUSH
21318: LD_INT 58
21320: PUSH
21321: EMPTY
21322: LIST
21323: PUSH
21324: EMPTY
21325: LIST
21326: LIST
21327: LIST
21328: PPUSH
21329: CALL_OW 69
21333: ST_TO_ADDR
// for i = 1 to 6 do
21334: LD_ADDR_VAR 0 1
21338: PUSH
21339: DOUBLE
21340: LD_INT 1
21342: DEC
21343: ST_TO_ADDR
21344: LD_INT 6
21346: PUSH
21347: FOR_TO
21348: IFFALSE 21489
// begin if IsInUnit ( tmp [ i ] ) then
21350: LD_VAR 0 3
21354: PUSH
21355: LD_VAR 0 1
21359: ARRAY
21360: PPUSH
21361: CALL_OW 310
21365: IFFALSE 21382
// ComExitBuilding ( tmp [ i ] ) ;
21367: LD_VAR 0 3
21371: PUSH
21372: LD_VAR 0 1
21376: ARRAY
21377: PPUSH
21378: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21382: LD_VAR 0 3
21386: PUSH
21387: LD_VAR 0 1
21391: ARRAY
21392: PPUSH
21393: LD_VAR 0 10
21397: PUSH
21398: LD_INT 1
21400: ARRAY
21401: PPUSH
21402: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21406: LD_VAR 0 3
21410: PUSH
21411: LD_VAR 0 1
21415: ARRAY
21416: PPUSH
21417: LD_INT 1
21419: PPUSH
21420: CALL_OW 183
// if emp_towers then
21424: LD_VAR 0 12
21428: IFFALSE 21487
// begin AddComExitBuilding ( tmp [ i ] ) ;
21430: LD_VAR 0 3
21434: PUSH
21435: LD_VAR 0 1
21439: ARRAY
21440: PPUSH
21441: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21445: LD_VAR 0 3
21449: PUSH
21450: LD_VAR 0 1
21454: ARRAY
21455: PPUSH
21456: LD_VAR 0 12
21460: PUSH
21461: LD_INT 1
21463: ARRAY
21464: PPUSH
21465: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21469: LD_ADDR_VAR 0 12
21473: PUSH
21474: LD_VAR 0 12
21478: PPUSH
21479: LD_INT 1
21481: PPUSH
21482: CALL_OW 3
21486: ST_TO_ADDR
// end ; end ;
21487: GO 21347
21489: POP
21490: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21491: LD_ADDR_VAR 0 3
21495: PUSH
21496: LD_EXP 18
21500: PUSH
21501: LD_INT 1
21503: ARRAY
21504: PUSH
21505: LD_EXP 18
21509: PUSH
21510: LD_INT 2
21512: ARRAY
21513: ADD
21514: PPUSH
21515: LD_INT 26
21517: PUSH
21518: LD_INT 1
21520: PUSH
21521: EMPTY
21522: LIST
21523: LIST
21524: PPUSH
21525: CALL_OW 72
21529: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21530: LD_ADDR_VAR 0 1
21534: PUSH
21535: LD_EXP 18
21539: PUSH
21540: LD_INT 2
21542: ARRAY
21543: PUSH
21544: FOR_IN
21545: IFFALSE 21563
// ComTurnUnit ( i , Powell ) ;
21547: LD_VAR 0 1
21551: PPUSH
21552: LD_EXP 58
21556: PPUSH
21557: CALL_OW 119
21561: GO 21544
21563: POP
21564: POP
// Say ( Powell , D5-Pow-1 ) ;
21565: LD_EXP 58
21569: PPUSH
21570: LD_STRING D5-Pow-1
21572: PPUSH
21573: CALL_OW 88
// if tmp then
21577: LD_VAR 0 3
21581: IFFALSE 21599
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21583: LD_VAR 0 3
21587: PUSH
21588: LD_INT 1
21590: ARRAY
21591: PPUSH
21592: LD_STRING D5-Sol2-1
21594: PPUSH
21595: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21599: LD_EXP 58
21603: PPUSH
21604: LD_STRING D5-Pow-2
21606: PPUSH
21607: CALL_OW 88
// if tmp > 1 then
21611: LD_VAR 0 3
21615: PUSH
21616: LD_INT 1
21618: GREATER
21619: IFFALSE 21637
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21621: LD_VAR 0 3
21625: PUSH
21626: LD_INT 2
21628: ARRAY
21629: PPUSH
21630: LD_STRING D5-Sol2-2
21632: PPUSH
21633: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21637: LD_EXP 58
21641: PPUSH
21642: LD_STRING D5-Pow-3
21644: PPUSH
21645: CALL_OW 88
// wait ( 0 0$1 ) ;
21649: LD_INT 35
21651: PPUSH
21652: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21656: LD_ADDR_VAR 0 3
21660: PUSH
21661: LD_EXP 18
21665: PUSH
21666: LD_INT 1
21668: ARRAY
21669: PUSH
21670: LD_EXP 18
21674: PUSH
21675: LD_INT 2
21677: ARRAY
21678: UNION
21679: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21680: LD_VAR 0 3
21684: PPUSH
21685: LD_INT 80
21687: PPUSH
21688: LD_INT 67
21690: PPUSH
21691: CALL_OW 114
// wait ( 0 0$2 ) ;
21695: LD_INT 70
21697: PPUSH
21698: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21702: LD_INT 79
21704: PPUSH
21705: LD_INT 72
21707: PPUSH
21708: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21712: LD_INT 35
21714: PPUSH
21715: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21719: LD_VAR 0 3
21723: PPUSH
21724: LD_INT 3
21726: PUSH
21727: LD_INT 24
21729: PUSH
21730: LD_INT 1000
21732: PUSH
21733: EMPTY
21734: LIST
21735: LIST
21736: PUSH
21737: EMPTY
21738: LIST
21739: LIST
21740: PPUSH
21741: CALL_OW 72
21745: IFFALSE 21712
// Say ( Powell , D5a-Pow-1 ) ;
21747: LD_EXP 58
21751: PPUSH
21752: LD_STRING D5a-Pow-1
21754: PPUSH
21755: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21759: LD_EXP 58
21763: PPUSH
21764: LD_STRING D5a-Pow-1a
21766: PPUSH
21767: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21771: LD_INT 10
21773: PPUSH
21774: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21778: LD_EXP 58
21782: PPUSH
21783: LD_STRING D5a-Pow-1b
21785: PPUSH
21786: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21790: LD_EXP 58
21794: PPUSH
21795: LD_STRING D5a-Pow-1c
21797: PPUSH
21798: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21802: LD_EXP 58
21806: PPUSH
21807: LD_STRING D5a-Pow-1d
21809: PPUSH
21810: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21814: LD_INT 35
21816: PPUSH
21817: CALL_OW 67
// if not HasTask ( tmp ) then
21821: LD_VAR 0 3
21825: PPUSH
21826: CALL_OW 314
21830: NOT
21831: IFFALSE 21848
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21833: LD_VAR 0 3
21837: PPUSH
21838: LD_INT 80
21840: PPUSH
21841: LD_INT 67
21843: PPUSH
21844: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21848: LD_VAR 0 3
21852: PPUSH
21853: LD_INT 24
21855: PUSH
21856: LD_INT 1
21858: PUSH
21859: EMPTY
21860: LIST
21861: LIST
21862: PPUSH
21863: CALL_OW 72
21867: NOT
21868: IFFALSE 21814
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21870: LD_ADDR_VAR 0 3
21874: PUSH
21875: LD_INT 22
21877: PUSH
21878: LD_INT 4
21880: PUSH
21881: EMPTY
21882: LIST
21883: LIST
21884: PUSH
21885: LD_INT 92
21887: PUSH
21888: LD_INT 60
21890: PUSH
21891: LD_INT 93
21893: PUSH
21894: LD_INT 10
21896: PUSH
21897: EMPTY
21898: LIST
21899: LIST
21900: LIST
21901: LIST
21902: PUSH
21903: LD_INT 3
21905: PUSH
21906: LD_INT 54
21908: PUSH
21909: EMPTY
21910: LIST
21911: PUSH
21912: EMPTY
21913: LIST
21914: LIST
21915: PUSH
21916: EMPTY
21917: LIST
21918: LIST
21919: LIST
21920: PPUSH
21921: CALL_OW 69
21925: PUSH
21926: LD_EXP 58
21930: DIFF
21931: ST_TO_ADDR
// if tmp then
21932: LD_VAR 0 3
21936: IFFALSE 21970
// for i in tmp do
21938: LD_ADDR_VAR 0 1
21942: PUSH
21943: LD_VAR 0 3
21947: PUSH
21948: FOR_IN
21949: IFFALSE 21968
// ComMoveXY ( i , 36 , 67 ) ;
21951: LD_VAR 0 1
21955: PPUSH
21956: LD_INT 36
21958: PPUSH
21959: LD_INT 67
21961: PPUSH
21962: CALL_OW 111
21966: GO 21948
21968: POP
21969: POP
// wait ( 0 0$3 ) ;
21970: LD_INT 105
21972: PPUSH
21973: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21977: LD_VAR 0 11
21981: PPUSH
21982: LD_STRING D6-Sol3-1
21984: PPUSH
21985: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21989: LD_EXP 58
21993: PPUSH
21994: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21998: LD_EXP 58
22002: PPUSH
22003: LD_STRING D6-Pow-1
22005: PPUSH
22006: CALL_OW 88
// tmp := [ ] ;
22010: LD_ADDR_VAR 0 3
22014: PUSH
22015: EMPTY
22016: ST_TO_ADDR
// for i = 1 to 2 do
22017: LD_ADDR_VAR 0 1
22021: PUSH
22022: DOUBLE
22023: LD_INT 1
22025: DEC
22026: ST_TO_ADDR
22027: LD_INT 2
22029: PUSH
22030: FOR_TO
22031: IFFALSE 22145
// begin uc_side := 8 ;
22033: LD_ADDR_OWVAR 20
22037: PUSH
22038: LD_INT 8
22040: ST_TO_ADDR
// uc_nation := 2 ;
22041: LD_ADDR_OWVAR 21
22045: PUSH
22046: LD_INT 2
22048: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22049: LD_INT 14
22051: PPUSH
22052: LD_INT 3
22054: PPUSH
22055: LD_INT 2
22057: PPUSH
22058: LD_INT 29
22060: PPUSH
22061: LD_INT 100
22063: PPUSH
22064: CALL 70006 0 5
// veh := CreateVehicle ;
22068: LD_ADDR_VAR 0 13
22072: PUSH
22073: CALL_OW 45
22077: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22078: LD_VAR 0 13
22082: PPUSH
22083: LD_INT 4
22085: PPUSH
22086: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22090: LD_VAR 0 13
22094: PPUSH
22095: LD_INT 99
22097: PPUSH
22098: LD_INT 83
22100: PPUSH
22101: LD_INT 6
22103: PPUSH
22104: LD_INT 0
22106: PPUSH
22107: CALL_OW 50
// wait ( 3 ) ;
22111: LD_INT 3
22113: PPUSH
22114: CALL_OW 67
// Connect ( veh ) ;
22118: LD_VAR 0 13
22122: PPUSH
22123: CALL 73061 0 1
// tmp := tmp ^ veh ;
22127: LD_ADDR_VAR 0 3
22131: PUSH
22132: LD_VAR 0 3
22136: PUSH
22137: LD_VAR 0 13
22141: ADD
22142: ST_TO_ADDR
// end ;
22143: GO 22030
22145: POP
22146: POP
// wait ( 0 0$1 ) ;
22147: LD_INT 35
22149: PPUSH
22150: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22154: LD_INT 99
22156: PPUSH
22157: LD_INT 83
22159: PPUSH
22160: LD_INT 1
22162: PPUSH
22163: LD_INT 10
22165: PPUSH
22166: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22170: LD_INT 99
22172: PPUSH
22173: LD_INT 83
22175: PPUSH
22176: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22180: LD_VAR 0 11
22184: PPUSH
22185: LD_STRING D6-Sol3-2
22187: PPUSH
22188: CALL_OW 88
// async ;
22192: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22193: LD_EXP 58
22197: PPUSH
22198: LD_STRING D6-Pow-2
22200: PPUSH
22201: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22205: LD_VAR 0 3
22209: PUSH
22210: LD_INT 1
22212: ARRAY
22213: PPUSH
22214: LD_VAR 0 9
22218: PPUSH
22219: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22223: LD_VAR 0 3
22227: PUSH
22228: LD_INT 2
22230: ARRAY
22231: PPUSH
22232: LD_INT 22
22234: PUSH
22235: LD_INT 4
22237: PUSH
22238: EMPTY
22239: LIST
22240: LIST
22241: PUSH
22242: LD_INT 21
22244: PUSH
22245: LD_INT 3
22247: PUSH
22248: EMPTY
22249: LIST
22250: LIST
22251: PUSH
22252: EMPTY
22253: LIST
22254: LIST
22255: PPUSH
22256: CALL_OW 69
22260: PPUSH
22261: LD_VAR 0 3
22265: PUSH
22266: LD_INT 2
22268: ARRAY
22269: PPUSH
22270: CALL_OW 74
22274: PPUSH
22275: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22279: LD_EXP 58
22283: PPUSH
22284: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22288: LD_INT 99
22290: PPUSH
22291: LD_INT 83
22293: PPUSH
22294: LD_INT 1
22296: PPUSH
22297: CALL_OW 331
// repeat wait ( 4 ) ;
22301: LD_INT 4
22303: PPUSH
22304: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22308: LD_VAR 0 3
22312: PUSH
22313: LD_INT 1
22315: ARRAY
22316: PPUSH
22317: CALL_OW 256
22321: PUSH
22322: LD_INT 1000
22324: LESS
22325: IFFALSE 22343
// SetLives ( tmp [ 1 ] , 1000 ) ;
22327: LD_VAR 0 3
22331: PUSH
22332: LD_INT 1
22334: ARRAY
22335: PPUSH
22336: LD_INT 1000
22338: PPUSH
22339: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22343: LD_INT 22
22345: PUSH
22346: LD_INT 4
22348: PUSH
22349: EMPTY
22350: LIST
22351: LIST
22352: PUSH
22353: LD_INT 30
22355: PUSH
22356: LD_INT 3
22358: PUSH
22359: EMPTY
22360: LIST
22361: LIST
22362: PUSH
22363: EMPTY
22364: LIST
22365: LIST
22366: PPUSH
22367: CALL_OW 69
22371: PUSH
22372: LD_INT 0
22374: EQUAL
22375: IFFALSE 22301
// sync ;
22377: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22378: LD_EXP 58
22382: PPUSH
22383: LD_STRING D6a-Pow-1
22385: PPUSH
22386: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22390: LD_VAR 0 11
22394: PPUSH
22395: LD_STRING D6a-Sol3-1
22397: PPUSH
22398: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22402: LD_EXP 58
22406: PPUSH
22407: LD_STRING D6a-Pow-2
22409: PPUSH
22410: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22414: LD_VAR 0 11
22418: PPUSH
22419: LD_STRING D6a-Sol3-2
22421: PPUSH
22422: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22426: LD_EXP 58
22430: PPUSH
22431: LD_STRING D6a-Pow-3
22433: PPUSH
22434: CALL_OW 88
// powellCenterCameraMode := true ;
22438: LD_ADDR_EXP 20
22442: PUSH
22443: LD_INT 1
22445: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22446: LD_ADDR_VAR 0 1
22450: PUSH
22451: LD_INT 22
22453: PUSH
22454: LD_INT 8
22456: PUSH
22457: EMPTY
22458: LIST
22459: LIST
22460: PUSH
22461: LD_INT 25
22463: PUSH
22464: LD_INT 2
22466: PUSH
22467: EMPTY
22468: LIST
22469: LIST
22470: PUSH
22471: EMPTY
22472: LIST
22473: LIST
22474: PPUSH
22475: CALL_OW 69
22479: PUSH
22480: FOR_IN
22481: IFFALSE 22536
// begin SetTag ( i , 1 ) ;
22483: LD_VAR 0 1
22487: PPUSH
22488: LD_INT 1
22490: PPUSH
22491: CALL_OW 109
// ComExitBuilding ( i ) ;
22495: LD_VAR 0 1
22499: PPUSH
22500: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22504: LD_VAR 0 1
22508: PPUSH
22509: LD_INT 35
22511: PPUSH
22512: LD_INT 6
22514: PPUSH
22515: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22519: LD_VAR 0 1
22523: PPUSH
22524: LD_INT 53
22526: PPUSH
22527: LD_INT 4
22529: PPUSH
22530: CALL_OW 171
// end ;
22534: GO 22480
22536: POP
22537: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22538: LD_ADDR_VAR 0 3
22542: PUSH
22543: LD_INT 22
22545: PUSH
22546: LD_INT 4
22548: PUSH
22549: EMPTY
22550: LIST
22551: LIST
22552: PUSH
22553: LD_INT 21
22555: PUSH
22556: LD_INT 2
22558: PUSH
22559: EMPTY
22560: LIST
22561: LIST
22562: PUSH
22563: LD_INT 3
22565: PUSH
22566: LD_INT 34
22568: PUSH
22569: LD_INT 12
22571: PUSH
22572: EMPTY
22573: LIST
22574: LIST
22575: PUSH
22576: EMPTY
22577: LIST
22578: LIST
22579: PUSH
22580: EMPTY
22581: LIST
22582: LIST
22583: LIST
22584: PPUSH
22585: CALL_OW 69
22589: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22590: LD_EXP 58
22594: PPUSH
22595: LD_VAR 0 3
22599: PPUSH
22600: LD_EXP 58
22604: PPUSH
22605: CALL_OW 74
22609: PPUSH
22610: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22614: LD_EXP 58
22618: PPUSH
22619: LD_INT 100
22621: PPUSH
22622: LD_INT 88
22624: PPUSH
22625: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22629: LD_EXP 58
22633: PPUSH
22634: LD_INT 100
22636: PPUSH
22637: LD_INT 75
22639: PPUSH
22640: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22644: LD_EXP 58
22648: PPUSH
22649: LD_INT 88
22651: PPUSH
22652: LD_INT 53
22654: PPUSH
22655: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22659: LD_INT 8
22661: PPUSH
22662: LD_EXP 58
22666: PPUSH
22667: CALL_OW 471
// repeat wait ( 3 ) ;
22671: LD_INT 3
22673: PPUSH
22674: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22678: LD_INT 22
22680: PUSH
22681: LD_INT 4
22683: PUSH
22684: EMPTY
22685: LIST
22686: LIST
22687: PUSH
22688: LD_INT 92
22690: PUSH
22691: LD_INT 100
22693: PUSH
22694: LD_INT 75
22696: PUSH
22697: LD_INT 6
22699: PUSH
22700: EMPTY
22701: LIST
22702: LIST
22703: LIST
22704: LIST
22705: PUSH
22706: EMPTY
22707: LIST
22708: LIST
22709: PPUSH
22710: CALL_OW 69
22714: IFFALSE 22671
// async ;
22716: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22717: LD_EXP 58
22721: PPUSH
22722: LD_STRING D6b-Pow-1
22724: PPUSH
22725: CALL_OW 88
// repeat wait ( 3 ) ;
22729: LD_INT 3
22731: PPUSH
22732: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22736: LD_EXP 58
22740: PPUSH
22741: CALL_OW 310
22745: PPUSH
22746: CALL_OW 256
22750: PUSH
22751: LD_INT 1000
22753: LESS
22754: IFFALSE 22773
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22756: LD_EXP 58
22760: PPUSH
22761: CALL_OW 310
22765: PPUSH
22766: LD_INT 1000
22768: PPUSH
22769: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22773: LD_EXP 58
22777: PPUSH
22778: CALL_OW 256
22782: PUSH
22783: LD_INT 1000
22785: LESS
22786: IFFALSE 22800
// SetLives ( Powell , 1000 ) ;
22788: LD_EXP 58
22792: PPUSH
22793: LD_INT 1000
22795: PPUSH
22796: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22800: LD_EXP 58
22804: PPUSH
22805: LD_EXP 63
22809: PPUSH
22810: CALL_OW 296
22814: PUSH
22815: LD_INT 5
22817: LESS
22818: PUSH
22819: LD_EXP 58
22823: PPUSH
22824: CALL_OW 310
22828: PPUSH
22829: LD_EXP 63
22833: PPUSH
22834: CALL_OW 296
22838: PUSH
22839: LD_INT 5
22841: LESS
22842: OR
22843: IFFALSE 22862
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22845: LD_EXP 58
22849: PPUSH
22850: CALL_OW 310
22854: PPUSH
22855: LD_INT 100
22857: PPUSH
22858: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22862: LD_EXP 58
22866: PPUSH
22867: CALL_OW 310
22871: NOT
22872: IFFALSE 22729
// DoNotAttack ( 8 , powellBomb ) ;
22874: LD_INT 8
22876: PPUSH
22877: LD_EXP 63
22881: PPUSH
22882: CALL_OW 471
// game_speed := 4 ;
22886: LD_ADDR_OWVAR 65
22890: PUSH
22891: LD_INT 4
22893: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22894: LD_EXP 58
22898: PPUSH
22899: LD_STRING D6b-Pow-1a
22901: PPUSH
22902: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22906: LD_EXP 58
22910: PPUSH
22911: LD_EXP 63
22915: PPUSH
22916: CALL_OW 180
// sync ;
22920: SYNC
// repeat wait ( 0 0$1 ) ;
22921: LD_INT 35
22923: PPUSH
22924: CALL_OW 67
// until IsInUnit ( Powell ) ;
22928: LD_EXP 58
22932: PPUSH
22933: CALL_OW 310
22937: IFFALSE 22921
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22939: LD_INT 8
22941: PPUSH
22942: LD_EXP 58
22946: PPUSH
22947: CALL_OW 310
22951: PPUSH
22952: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22956: LD_EXP 58
22960: PPUSH
22961: LD_INT 91
22963: PPUSH
22964: LD_INT 44
22966: PPUSH
22967: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22971: LD_EXP 58
22975: PPUSH
22976: LD_INT 96
22978: PPUSH
22979: LD_INT 44
22981: PPUSH
22982: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22986: LD_EXP 58
22990: PPUSH
22991: LD_INT 96
22993: PPUSH
22994: LD_INT 41
22996: PPUSH
22997: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23001: LD_EXP 58
23005: PPUSH
23006: LD_INT 92
23008: PPUSH
23009: LD_INT 39
23011: PPUSH
23012: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23016: LD_EXP 58
23020: PPUSH
23021: LD_INT 88
23023: PPUSH
23024: LD_INT 41
23026: PPUSH
23027: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23031: LD_EXP 58
23035: PPUSH
23036: LD_INT 91
23038: PPUSH
23039: LD_INT 44
23041: PPUSH
23042: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23046: LD_EXP 58
23050: PPUSH
23051: LD_INT 96
23053: PPUSH
23054: LD_INT 44
23056: PPUSH
23057: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23061: LD_EXP 58
23065: PPUSH
23066: LD_INT 96
23068: PPUSH
23069: LD_INT 41
23071: PPUSH
23072: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23076: LD_EXP 58
23080: PPUSH
23081: LD_INT 92
23083: PPUSH
23084: LD_INT 39
23086: PPUSH
23087: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23091: LD_EXP 58
23095: PPUSH
23096: LD_INT 88
23098: PPUSH
23099: LD_INT 41
23101: PPUSH
23102: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23106: LD_EXP 58
23110: PPUSH
23111: LD_INT 91
23113: PPUSH
23114: LD_INT 44
23116: PPUSH
23117: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23121: LD_EXP 58
23125: PPUSH
23126: LD_INT 93
23128: PPUSH
23129: LD_INT 39
23131: PPUSH
23132: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23136: LD_EXP 58
23140: PPUSH
23141: LD_INT 93
23143: PPUSH
23144: LD_INT 36
23146: PPUSH
23147: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23151: LD_INT 122
23153: PPUSH
23154: CALL_OW 67
// game_speed := 4 ;
23158: LD_ADDR_OWVAR 65
23162: PUSH
23163: LD_INT 4
23165: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23166: LD_EXP 58
23170: PPUSH
23171: LD_STRING D6b-Pow-1b
23173: PPUSH
23174: CALL_OW 88
// tmp := [ ] ;
23178: LD_ADDR_VAR 0 3
23182: PUSH
23183: EMPTY
23184: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23185: LD_ADDR_VAR 0 5
23189: PUSH
23190: LD_INT 78
23192: PUSH
23193: LD_INT 47
23195: PUSH
23196: EMPTY
23197: LIST
23198: LIST
23199: PUSH
23200: LD_INT 106
23202: PUSH
23203: LD_INT 53
23205: PUSH
23206: EMPTY
23207: LIST
23208: LIST
23209: PUSH
23210: EMPTY
23211: LIST
23212: LIST
23213: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23214: LD_ADDR_VAR 0 1
23218: PUSH
23219: LD_INT 22
23221: PUSH
23222: LD_INT 8
23224: PUSH
23225: EMPTY
23226: LIST
23227: LIST
23228: PUSH
23229: LD_INT 21
23231: PUSH
23232: LD_INT 3
23234: PUSH
23235: EMPTY
23236: LIST
23237: LIST
23238: PUSH
23239: LD_INT 92
23241: PUSH
23242: LD_INT 90
23244: PUSH
23245: LD_INT 52
23247: PUSH
23248: LD_INT 12
23250: PUSH
23251: EMPTY
23252: LIST
23253: LIST
23254: LIST
23255: LIST
23256: PUSH
23257: EMPTY
23258: LIST
23259: LIST
23260: LIST
23261: PPUSH
23262: CALL_OW 69
23266: PUSH
23267: FOR_IN
23268: IFFALSE 23293
// tmp := tmp ^ UnitsInside ( i ) ;
23270: LD_ADDR_VAR 0 3
23274: PUSH
23275: LD_VAR 0 3
23279: PUSH
23280: LD_VAR 0 1
23284: PPUSH
23285: CALL_OW 313
23289: ADD
23290: ST_TO_ADDR
23291: GO 23267
23293: POP
23294: POP
// for i in tmp do
23295: LD_ADDR_VAR 0 1
23299: PUSH
23300: LD_VAR 0 3
23304: PUSH
23305: FOR_IN
23306: IFFALSE 23468
// begin dist := 9999 ;
23308: LD_ADDR_VAR 0 8
23312: PUSH
23313: LD_INT 9999
23315: ST_TO_ADDR
// _xy := [ ] ;
23316: LD_ADDR_VAR 0 7
23320: PUSH
23321: EMPTY
23322: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23323: LD_VAR 0 1
23327: PPUSH
23328: LD_INT 1
23330: PPUSH
23331: CALL_OW 109
// ComExitBuilding ( i ) ;
23335: LD_VAR 0 1
23339: PPUSH
23340: CALL_OW 122
// for j in xy do
23344: LD_ADDR_VAR 0 2
23348: PUSH
23349: LD_VAR 0 5
23353: PUSH
23354: FOR_IN
23355: IFFALSE 23437
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23357: LD_VAR 0 1
23361: PPUSH
23362: LD_VAR 0 2
23366: PUSH
23367: LD_INT 1
23369: ARRAY
23370: PPUSH
23371: LD_VAR 0 2
23375: PUSH
23376: LD_INT 2
23378: ARRAY
23379: PPUSH
23380: CALL_OW 297
23384: PUSH
23385: LD_VAR 0 8
23389: LESS
23390: IFFALSE 23435
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23392: LD_ADDR_VAR 0 8
23396: PUSH
23397: LD_VAR 0 1
23401: PPUSH
23402: LD_VAR 0 2
23406: PUSH
23407: LD_INT 1
23409: ARRAY
23410: PPUSH
23411: LD_VAR 0 2
23415: PUSH
23416: LD_INT 2
23418: ARRAY
23419: PPUSH
23420: CALL_OW 297
23424: ST_TO_ADDR
// _xy := j ;
23425: LD_ADDR_VAR 0 7
23429: PUSH
23430: LD_VAR 0 2
23434: ST_TO_ADDR
// end ;
23435: GO 23354
23437: POP
23438: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23439: LD_VAR 0 1
23443: PPUSH
23444: LD_VAR 0 7
23448: PUSH
23449: LD_INT 1
23451: ARRAY
23452: PPUSH
23453: LD_VAR 0 7
23457: PUSH
23458: LD_INT 2
23460: ARRAY
23461: PPUSH
23462: CALL_OW 171
// end ;
23466: GO 23305
23468: POP
23469: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23470: LD_ADDR_VAR 0 4
23474: PUSH
23475: LD_VAR 0 3
23479: PPUSH
23480: LD_INT 26
23482: PUSH
23483: LD_INT 1
23485: PUSH
23486: EMPTY
23487: LIST
23488: LIST
23489: PUSH
23490: LD_INT 25
23492: PUSH
23493: LD_INT 1
23495: PUSH
23496: EMPTY
23497: LIST
23498: LIST
23499: PUSH
23500: EMPTY
23501: LIST
23502: LIST
23503: PPUSH
23504: CALL_OW 72
23508: ST_TO_ADDR
// if tmp2 < 2 then
23509: LD_VAR 0 4
23513: PUSH
23514: LD_INT 2
23516: LESS
23517: IFFALSE 23586
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23519: LD_ADDR_VAR 0 4
23523: PUSH
23524: LD_INT 22
23526: PUSH
23527: LD_INT 8
23529: PUSH
23530: EMPTY
23531: LIST
23532: LIST
23533: PUSH
23534: LD_INT 26
23536: PUSH
23537: LD_INT 1
23539: PUSH
23540: EMPTY
23541: LIST
23542: LIST
23543: PUSH
23544: LD_INT 3
23546: PUSH
23547: LD_INT 25
23549: PUSH
23550: LD_INT 15
23552: PUSH
23553: EMPTY
23554: LIST
23555: LIST
23556: PUSH
23557: EMPTY
23558: LIST
23559: LIST
23560: PUSH
23561: EMPTY
23562: LIST
23563: LIST
23564: LIST
23565: PPUSH
23566: CALL_OW 69
23570: PUSH
23571: LD_EXP 60
23575: PUSH
23576: LD_EXP 61
23580: PUSH
23581: EMPTY
23582: LIST
23583: LIST
23584: DIFF
23585: ST_TO_ADDR
// if tmp2 then
23586: LD_VAR 0 4
23590: IFFALSE 23608
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23592: LD_VAR 0 4
23596: PUSH
23597: LD_INT 1
23599: ARRAY
23600: PPUSH
23601: LD_STRING D6b-ArSol1-1
23603: PPUSH
23604: CALL_OW 88
// async ;
23608: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23609: LD_EXP 58
23613: PPUSH
23614: LD_STRING D6b-Pow-2
23616: PPUSH
23617: CALL_OW 88
// wait ( 0 0$1 ) ;
23621: LD_INT 35
23623: PPUSH
23624: CALL_OW 67
// if tmp2 > 1 then
23628: LD_VAR 0 4
23632: PUSH
23633: LD_INT 1
23635: GREATER
23636: IFFALSE 23654
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23638: LD_VAR 0 4
23642: PUSH
23643: LD_INT 2
23645: ARRAY
23646: PPUSH
23647: LD_STRING D6b-ArSol2-1
23649: PPUSH
23650: CALL_OW 88
// sync ;
23654: SYNC
// repeat wait ( 5 ) ;
23655: LD_INT 5
23657: PPUSH
23658: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23662: LD_INT 93
23664: PPUSH
23665: LD_INT 36
23667: PPUSH
23668: CALL_OW 428
23672: PPUSH
23673: CALL_OW 255
23677: PUSH
23678: LD_INT 4
23680: EQUAL
23681: IFFALSE 23655
// DialogueOn ;
23683: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23687: LD_INT 10
23689: PPUSH
23690: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23694: LD_EXP 58
23698: PPUSH
23699: LD_STRING D6b-Pow-2a
23701: PPUSH
23702: CALL_OW 88
// DialogueOff ;
23706: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23710: LD_EXP 58
23714: PPUSH
23715: CALL_OW 310
23719: PPUSH
23720: LD_INT 332
23722: PPUSH
23723: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23727: LD_INT 93
23729: PPUSH
23730: LD_INT 35
23732: PPUSH
23733: LD_INT 1
23735: PPUSH
23736: LD_INT 6
23738: NEG
23739: PPUSH
23740: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23744: LD_INT 35
23746: PPUSH
23747: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23751: LD_INT 332
23753: PPUSH
23754: CALL_OW 256
23758: PUSH
23759: LD_INT 1000
23761: LESS
23762: PUSH
23763: LD_INT 332
23765: PPUSH
23766: CALL_OW 300
23770: AND
23771: IFFALSE 23783
// SetLives ( kozlov_fac , 0 ) ;
23773: LD_INT 332
23775: PPUSH
23776: LD_INT 0
23778: PPUSH
23779: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23783: LD_INT 332
23785: PPUSH
23786: CALL_OW 301
23790: PUSH
23791: LD_EXP 58
23795: PPUSH
23796: CALL_OW 301
23800: OR
23801: IFFALSE 23744
// game_speed := 4 ;
23803: LD_ADDR_OWVAR 65
23807: PUSH
23808: LD_INT 4
23810: ST_TO_ADDR
// powellCenterCameraMode := false ;
23811: LD_ADDR_EXP 20
23815: PUSH
23816: LD_INT 0
23818: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23819: LD_ADDR_VAR 0 1
23823: PUSH
23824: LD_VAR 0 3
23828: PUSH
23829: LD_INT 22
23831: PUSH
23832: LD_INT 8
23834: PUSH
23835: EMPTY
23836: LIST
23837: LIST
23838: PUSH
23839: LD_INT 25
23841: PUSH
23842: LD_INT 2
23844: PUSH
23845: EMPTY
23846: LIST
23847: LIST
23848: PUSH
23849: EMPTY
23850: LIST
23851: LIST
23852: PPUSH
23853: CALL_OW 69
23857: UNION
23858: PUSH
23859: FOR_IN
23860: IFFALSE 23876
// SetTag ( i , 0 ) ;
23862: LD_VAR 0 1
23866: PPUSH
23867: LD_INT 0
23869: PPUSH
23870: CALL_OW 109
23874: GO 23859
23876: POP
23877: POP
// wait ( 0 0$3 ) ;
23878: LD_INT 105
23880: PPUSH
23881: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23885: LD_INT 93
23887: PPUSH
23888: LD_INT 35
23890: PPUSH
23891: LD_INT 1
23893: PPUSH
23894: CALL_OW 331
// DialogueOn ;
23898: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23902: LD_VAR 0 11
23906: PPUSH
23907: LD_STRING D6c-Sol3-1
23909: PPUSH
23910: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23914: LD_INT 10
23916: PPUSH
23917: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23921: LD_EXP 39
23925: PPUSH
23926: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23930: LD_EXP 39
23934: PPUSH
23935: LD_STRING D6c-JMM-1
23937: PPUSH
23938: CALL_OW 88
// if Cyrus then
23942: LD_EXP 45
23946: IFFALSE 23960
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23948: LD_EXP 45
23952: PPUSH
23953: LD_STRING D6c-Cyrus-1
23955: PPUSH
23956: CALL_OW 88
// if Bobby then
23960: LD_EXP 44
23964: IFFALSE 23978
// Say ( Bobby , D6c-Bobby-1 ) ;
23966: LD_EXP 44
23970: PPUSH
23971: LD_STRING D6c-Bobby-1
23973: PPUSH
23974: CALL_OW 88
// if Cornel then
23978: LD_EXP 50
23982: IFFALSE 23996
// Say ( Cornel , D6c-Corn-1 ) ;
23984: LD_EXP 50
23988: PPUSH
23989: LD_STRING D6c-Corn-1
23991: PPUSH
23992: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23996: LD_ADDR_VAR 0 4
24000: PUSH
24001: LD_INT 2
24003: PUSH
24004: LD_INT 22
24006: PUSH
24007: LD_INT 1
24009: PUSH
24010: EMPTY
24011: LIST
24012: LIST
24013: PUSH
24014: LD_INT 22
24016: PUSH
24017: LD_INT 4
24019: PUSH
24020: EMPTY
24021: LIST
24022: LIST
24023: PUSH
24024: EMPTY
24025: LIST
24026: LIST
24027: LIST
24028: PUSH
24029: LD_INT 26
24031: PUSH
24032: LD_INT 1
24034: PUSH
24035: EMPTY
24036: LIST
24037: LIST
24038: PUSH
24039: LD_INT 3
24041: PUSH
24042: LD_INT 25
24044: PUSH
24045: LD_INT 16
24047: PUSH
24048: EMPTY
24049: LIST
24050: LIST
24051: PUSH
24052: LD_INT 25
24054: PUSH
24055: LD_INT 12
24057: PUSH
24058: EMPTY
24059: LIST
24060: LIST
24061: PUSH
24062: EMPTY
24063: LIST
24064: LIST
24065: LIST
24066: PUSH
24067: EMPTY
24068: LIST
24069: LIST
24070: LIST
24071: PPUSH
24072: CALL_OW 69
24076: PUSH
24077: LD_VAR 0 11
24081: PUSH
24082: LD_EXP 39
24086: UNION
24087: PUSH
24088: LD_EXP 59
24092: UNION
24093: PUSH
24094: EMPTY
24095: LIST
24096: DIFF
24097: ST_TO_ADDR
// if tmp2 then
24098: LD_VAR 0 4
24102: IFFALSE 24120
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24104: LD_VAR 0 4
24108: PUSH
24109: LD_INT 1
24111: ARRAY
24112: PPUSH
24113: LD_STRING D6c-Sol1-1
24115: PPUSH
24116: CALL_OW 88
// if Lisa then
24120: LD_EXP 42
24124: IFFALSE 24138
// Say ( Lisa , D6c-Lisa-1 ) ;
24126: LD_EXP 42
24130: PPUSH
24131: LD_STRING D6c-Lisa-1
24133: PPUSH
24134: CALL_OW 88
// if Gary then
24138: LD_EXP 51
24142: IFFALSE 24156
// Say ( Gary , D6c-Gary-1 ) ;
24144: LD_EXP 51
24148: PPUSH
24149: LD_STRING D6c-Gary-1
24151: PPUSH
24152: CALL_OW 88
// if Donaldson then
24156: LD_EXP 43
24160: IFFALSE 24174
// Say ( Donaldson , D6c-Don-1 ) ;
24162: LD_EXP 43
24166: PPUSH
24167: LD_STRING D6c-Don-1
24169: PPUSH
24170: CALL_OW 88
// if tmp2 > 1 then
24174: LD_VAR 0 4
24178: PUSH
24179: LD_INT 1
24181: GREATER
24182: IFFALSE 24200
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24184: LD_VAR 0 4
24188: PUSH
24189: LD_INT 2
24191: ARRAY
24192: PPUSH
24193: LD_STRING D6c-Sol2-1
24195: PPUSH
24196: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24200: LD_VAR 0 11
24204: PPUSH
24205: LD_STRING D6c-Sol3-2
24207: PPUSH
24208: CALL_OW 88
// dwait ( 0 0$1 ) ;
24212: LD_INT 35
24214: PPUSH
24215: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24219: LD_EXP 39
24223: PPUSH
24224: LD_STRING D6c-JMM-2
24226: PPUSH
24227: CALL_OW 88
// DialogueOff ;
24231: CALL_OW 7
// Video ( false ) ;
24235: LD_INT 0
24237: PPUSH
24238: CALL 101143 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24242: LD_INT 22
24244: PUSH
24245: LD_INT 4
24247: PUSH
24248: EMPTY
24249: LIST
24250: LIST
24251: PPUSH
24252: CALL_OW 69
24256: PPUSH
24257: LD_INT 1
24259: PPUSH
24260: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24264: LD_INT 4
24266: PPUSH
24267: LD_INT 4
24269: PPUSH
24270: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24274: LD_ADDR_VAR 0 1
24278: PUSH
24279: LD_INT 4
24281: PPUSH
24282: LD_INT 1
24284: PPUSH
24285: LD_INT 2
24287: PPUSH
24288: CALL 65245 0 3
24292: PUSH
24293: FOR_IN
24294: IFFALSE 24331
// if GetTech ( i , 1 ) <> state_researched then
24296: LD_VAR 0 1
24300: PPUSH
24301: LD_INT 1
24303: PPUSH
24304: CALL_OW 321
24308: PUSH
24309: LD_INT 2
24311: NONEQUAL
24312: IFFALSE 24329
// SetTech ( i , 1 , state_researched ) ;
24314: LD_VAR 0 1
24318: PPUSH
24319: LD_INT 1
24321: PPUSH
24322: LD_INT 2
24324: PPUSH
24325: CALL_OW 322
24329: GO 24293
24331: POP
24332: POP
// missionStage := 6 ;
24333: LD_ADDR_EXP 15
24337: PUSH
24338: LD_INT 6
24340: ST_TO_ADDR
// activeAttacks := true ;
24341: LD_ADDR_EXP 16
24345: PUSH
24346: LD_INT 1
24348: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24349: LD_STRING M2
24351: PPUSH
24352: CALL_OW 337
// SaveForQuickRestart ;
24356: CALL_OW 22
// wait ( 0 0$40 ) ;
24360: LD_INT 1400
24362: PPUSH
24363: CALL_OW 67
// DialogueOn ;
24367: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24371: LD_EXP 62
24375: PPUSH
24376: LD_STRING D7-Friend-1
24378: PPUSH
24379: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24383: LD_EXP 39
24387: PPUSH
24388: LD_STRING D7-JMM-1
24390: PPUSH
24391: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24395: LD_EXP 62
24399: PPUSH
24400: LD_STRING D7-Friend-2
24402: PPUSH
24403: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24407: LD_EXP 39
24411: PPUSH
24412: LD_STRING D7-JMM-2
24414: PPUSH
24415: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24419: LD_EXP 62
24423: PPUSH
24424: LD_STRING D7-Friend-3
24426: PPUSH
24427: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24431: LD_EXP 39
24435: PPUSH
24436: LD_STRING D7-JMM-3
24438: PPUSH
24439: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24443: LD_EXP 62
24447: PPUSH
24448: LD_STRING D7-Friend-4
24450: PPUSH
24451: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24455: LD_EXP 39
24459: PPUSH
24460: LD_STRING D7-JMM-4
24462: PPUSH
24463: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24467: LD_EXP 62
24471: PPUSH
24472: LD_STRING D7-Friend-5
24474: PPUSH
24475: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24479: LD_EXP 39
24483: PPUSH
24484: LD_STRING D7-JMM-5
24486: PPUSH
24487: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24491: LD_EXP 62
24495: PPUSH
24496: LD_STRING D7-Friend-6
24498: PPUSH
24499: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24503: LD_EXP 39
24507: PPUSH
24508: LD_STRING D7-JMM-6
24510: PPUSH
24511: CALL_OW 88
// DialogueOff ;
24515: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24519: LD_STRING Mlegion
24521: PPUSH
24522: CALL_OW 337
// RebuildKozlovFactory ;
24526: CALL 4880 0 0
// end ;
24530: PPOPN 13
24532: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24533: LD_EXP 20
24537: PUSH
24538: LD_EXP 58
24542: PPUSH
24543: CALL_OW 300
24547: AND
24548: IFFALSE 24590
24550: GO 24552
24552: DISABLE
// begin enable ;
24553: ENABLE
// if IsInUnit ( Powell ) then
24554: LD_EXP 58
24558: PPUSH
24559: CALL_OW 310
24563: IFFALSE 24581
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24565: LD_EXP 58
24569: PPUSH
24570: CALL_OW 310
24574: PPUSH
24575: CALL_OW 85
24579: GO 24590
// CenterOnUnits ( Powell ) ;
24581: LD_EXP 58
24585: PPUSH
24586: CALL_OW 85
// end ;
24590: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24591: LD_INT 22
24593: PUSH
24594: LD_INT 8
24596: PUSH
24597: EMPTY
24598: LIST
24599: LIST
24600: PUSH
24601: LD_INT 34
24603: PUSH
24604: LD_INT 48
24606: PUSH
24607: EMPTY
24608: LIST
24609: LIST
24610: PUSH
24611: EMPTY
24612: LIST
24613: LIST
24614: PPUSH
24615: CALL_OW 69
24619: IFFALSE 24893
24621: GO 24623
24623: DISABLE
24624: LD_INT 0
24626: PPUSH
24627: PPUSH
// begin if missionStage < 9 then
24628: LD_EXP 15
24632: PUSH
24633: LD_INT 9
24635: LESS
24636: IFFALSE 24646
// missionStage := 9 ;
24638: LD_ADDR_EXP 15
24642: PUSH
24643: LD_INT 9
24645: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24646: LD_ADDR_VAR 0 1
24650: PUSH
24651: LD_INT 22
24653: PUSH
24654: LD_INT 8
24656: PUSH
24657: EMPTY
24658: LIST
24659: LIST
24660: PUSH
24661: LD_INT 34
24663: PUSH
24664: LD_INT 48
24666: PUSH
24667: EMPTY
24668: LIST
24669: LIST
24670: PUSH
24671: EMPTY
24672: LIST
24673: LIST
24674: PPUSH
24675: CALL_OW 69
24679: PUSH
24680: LD_INT 1
24682: ARRAY
24683: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24684: LD_INT 175
24686: PPUSH
24687: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24691: LD_EXP 12
24695: PUSH
24696: LD_EXP 3
24700: PUSH
24701: LD_INT 0
24703: PUSH
24704: LD_INT 2
24706: PUSH
24707: EMPTY
24708: LIST
24709: LIST
24710: IN
24711: OR
24712: IFFALSE 24735
// target := [ 68 , 108 , 1 ] else
24714: LD_ADDR_VAR 0 2
24718: PUSH
24719: LD_INT 68
24721: PUSH
24722: LD_INT 108
24724: PUSH
24725: LD_INT 1
24727: PUSH
24728: EMPTY
24729: LIST
24730: LIST
24731: LIST
24732: ST_TO_ADDR
24733: GO 24754
// target := [ 181 , 88 , 2 ] ;
24735: LD_ADDR_VAR 0 2
24739: PUSH
24740: LD_INT 181
24742: PUSH
24743: LD_INT 88
24745: PUSH
24746: LD_INT 2
24748: PUSH
24749: EMPTY
24750: LIST
24751: LIST
24752: LIST
24753: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24754: LD_VAR 0 1
24758: PPUSH
24759: LD_VAR 0 2
24763: PUSH
24764: LD_INT 1
24766: ARRAY
24767: PPUSH
24768: LD_VAR 0 2
24772: PUSH
24773: LD_INT 2
24775: ARRAY
24776: PPUSH
24777: CALL_OW 176
// if target [ 3 ] = 1 then
24781: LD_VAR 0 2
24785: PUSH
24786: LD_INT 3
24788: ARRAY
24789: PUSH
24790: LD_INT 1
24792: EQUAL
24793: IFFALSE 24809
// SayRadio ( Kurt , D12-Kurt-1 ) else
24795: LD_EXP 60
24799: PPUSH
24800: LD_STRING D12-Kurt-1
24802: PPUSH
24803: CALL_OW 94
24807: GO 24833
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24809: LD_EXP 60
24813: PPUSH
24814: LD_STRING D12a-Kurt-1
24816: PPUSH
24817: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24821: LD_EXP 74
24825: PPUSH
24826: LD_STRING D12a-Roth-1
24828: PPUSH
24829: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24833: LD_INT 350
24835: PPUSH
24836: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24840: LD_VAR 0 1
24844: PPUSH
24845: LD_INT 22
24847: PUSH
24848: LD_INT 8
24850: PUSH
24851: EMPTY
24852: LIST
24853: LIST
24854: PUSH
24855: LD_INT 23
24857: PUSH
24858: LD_INT 2
24860: PUSH
24861: EMPTY
24862: LIST
24863: LIST
24864: PUSH
24865: LD_INT 30
24867: PUSH
24868: LD_INT 3
24870: PUSH
24871: EMPTY
24872: LIST
24873: LIST
24874: PUSH
24875: EMPTY
24876: LIST
24877: LIST
24878: LIST
24879: PPUSH
24880: CALL_OW 69
24884: PUSH
24885: LD_INT 1
24887: ARRAY
24888: PPUSH
24889: CALL_OW 228
// end ;
24893: PPOPN 2
24895: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24896: LD_EXP 60
24900: PPUSH
24901: CALL_OW 256
24905: PUSH
24906: LD_INT 999
24908: LESS
24909: PUSH
24910: LD_INT 22
24912: PUSH
24913: LD_INT 8
24915: PUSH
24916: EMPTY
24917: LIST
24918: LIST
24919: PUSH
24920: LD_INT 21
24922: PUSH
24923: LD_INT 1
24925: PUSH
24926: EMPTY
24927: LIST
24928: LIST
24929: PUSH
24930: LD_INT 23
24932: PUSH
24933: LD_INT 2
24935: PUSH
24936: EMPTY
24937: LIST
24938: LIST
24939: PUSH
24940: EMPTY
24941: LIST
24942: LIST
24943: LIST
24944: PPUSH
24945: CALL_OW 69
24949: PUSH
24950: LD_INT 9
24952: PUSH
24953: LD_INT 8
24955: PUSH
24956: LD_INT 7
24958: PUSH
24959: EMPTY
24960: LIST
24961: LIST
24962: LIST
24963: PUSH
24964: LD_OWVAR 67
24968: ARRAY
24969: LESSEQUAL
24970: OR
24971: PUSH
24972: LD_INT 22
24974: PUSH
24975: LD_INT 8
24977: PUSH
24978: EMPTY
24979: LIST
24980: LIST
24981: PUSH
24982: LD_INT 34
24984: PUSH
24985: LD_INT 48
24987: PUSH
24988: EMPTY
24989: LIST
24990: LIST
24991: PUSH
24992: EMPTY
24993: LIST
24994: LIST
24995: PPUSH
24996: CALL_OW 69
25000: NOT
25001: AND
25002: PUSH
25003: LD_EXP 60
25007: PPUSH
25008: CALL_OW 302
25012: AND
25013: PUSH
25014: LD_INT 5
25016: PPUSH
25017: LD_INT 22
25019: PUSH
25020: LD_INT 1
25022: PUSH
25023: EMPTY
25024: LIST
25025: LIST
25026: PPUSH
25027: CALL_OW 70
25031: AND
25032: IFFALSE 25737
25034: GO 25036
25036: DISABLE
25037: LD_INT 0
25039: PPUSH
25040: PPUSH
25041: PPUSH
// begin DialogueOn ;
25042: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25046: LD_EXP 39
25050: PPUSH
25051: LD_STRING D13-JMM-1
25053: PPUSH
25054: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25058: LD_EXP 60
25062: PPUSH
25063: LD_STRING D13-Kurt-1
25065: PPUSH
25066: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25070: LD_EXP 39
25074: PPUSH
25075: LD_STRING D13-JMM-2
25077: PPUSH
25078: CALL_OW 88
// if FakeInfo then
25082: LD_EXP 12
25086: IFFALSE 25106
// begin Say ( Kurt , D13-Kurt-2 ) ;
25088: LD_EXP 60
25092: PPUSH
25093: LD_STRING D13-Kurt-2
25095: PPUSH
25096: CALL_OW 88
// DialogueOff ;
25100: CALL_OW 7
// exit ;
25104: GO 25737
// end ; if not KurtStatus then
25106: LD_EXP 3
25110: NOT
25111: IFFALSE 25127
// Say ( Kurt , D13-Kurt-2b ) else
25113: LD_EXP 60
25117: PPUSH
25118: LD_STRING D13-Kurt-2b
25120: PPUSH
25121: CALL_OW 88
25125: GO 25139
// Say ( Kurt , D13-Kurt-2a ) ;
25127: LD_EXP 60
25131: PPUSH
25132: LD_STRING D13-Kurt-2a
25134: PPUSH
25135: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25139: LD_EXP 39
25143: PPUSH
25144: LD_STRING D13-JMM-3
25146: PPUSH
25147: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25151: LD_EXP 60
25155: PPUSH
25156: LD_STRING D13-Kurt-3
25158: PPUSH
25159: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25163: LD_EXP 39
25167: PPUSH
25168: LD_STRING D13-JMM-4
25170: PPUSH
25171: CALL_OW 88
// DialogueOff ;
25175: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
25179: LD_STRING MlegionOut
25181: PPUSH
25182: CALL_OW 337
// legionDestroyed := true ;
25186: LD_ADDR_EXP 22
25190: PUSH
25191: LD_INT 1
25193: ST_TO_ADDR
// MC_Kill ( 3 ) ;
25194: LD_INT 3
25196: PPUSH
25197: CALL 35349 0 1
// KillUnit ( Kozlov ) ;
25201: LD_EXP 61
25205: PPUSH
25206: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25210: LD_ADDR_VAR 0 1
25214: PUSH
25215: LD_INT 22
25217: PUSH
25218: LD_INT 8
25220: PUSH
25221: EMPTY
25222: LIST
25223: LIST
25224: PUSH
25225: LD_INT 23
25227: PUSH
25228: LD_INT 3
25230: PUSH
25231: EMPTY
25232: LIST
25233: LIST
25234: PUSH
25235: LD_INT 3
25237: PUSH
25238: LD_INT 21
25240: PUSH
25241: LD_INT 33
25243: PUSH
25244: EMPTY
25245: LIST
25246: LIST
25247: PUSH
25248: EMPTY
25249: LIST
25250: LIST
25251: PUSH
25252: EMPTY
25253: LIST
25254: LIST
25255: LIST
25256: PPUSH
25257: CALL_OW 69
25261: PUSH
25262: FOR_IN
25263: IFFALSE 25276
// KillUnit ( i ) ;
25265: LD_VAR 0 1
25269: PPUSH
25270: CALL_OW 66
25274: GO 25262
25276: POP
25277: POP
// ChangeSideFog ( 8 , 1 ) ;
25278: LD_INT 8
25280: PPUSH
25281: LD_INT 1
25283: PPUSH
25284: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25288: LD_ADDR_VAR 0 2
25292: PUSH
25293: LD_INT 22
25295: PUSH
25296: LD_INT 8
25298: PUSH
25299: EMPTY
25300: LIST
25301: LIST
25302: PUSH
25303: LD_INT 21
25305: PUSH
25306: LD_INT 1
25308: PUSH
25309: EMPTY
25310: LIST
25311: LIST
25312: PUSH
25313: EMPTY
25314: LIST
25315: LIST
25316: PPUSH
25317: CALL_OW 69
25321: PUSH
25322: LD_EXP 61
25326: PUSH
25327: LD_EXP 60
25331: PUSH
25332: EMPTY
25333: LIST
25334: LIST
25335: DIFF
25336: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 ] [ Difficulty ] then
25337: LD_VAR 0 2
25341: PUSH
25342: LD_INT 6
25344: PUSH
25345: LD_INT 5
25347: PUSH
25348: LD_INT 4
25350: PUSH
25351: EMPTY
25352: LIST
25353: LIST
25354: LIST
25355: PUSH
25356: LD_OWVAR 67
25360: ARRAY
25361: GREATEREQUAL
25362: IFFALSE 25536
// begin x := [ 6 , 5 , 4 ] [ Difficulty ] ;
25364: LD_ADDR_VAR 0 3
25368: PUSH
25369: LD_INT 6
25371: PUSH
25372: LD_INT 5
25374: PUSH
25375: LD_INT 4
25377: PUSH
25378: EMPTY
25379: LIST
25380: LIST
25381: LIST
25382: PUSH
25383: LD_OWVAR 67
25387: ARRAY
25388: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25389: LD_ADDR_VAR 0 1
25393: PUSH
25394: DOUBLE
25395: LD_VAR 0 2
25399: PUSH
25400: LD_VAR 0 3
25404: PUSH
25405: LD_INT 1
25407: PLUS
25408: MINUS
25409: INC
25410: ST_TO_ADDR
25411: LD_INT 1
25413: PUSH
25414: FOR_DOWNTO
25415: IFFALSE 25532
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25417: LD_ADDR_EXP 38
25421: PUSH
25422: LD_EXP 38
25426: PUSH
25427: LD_VAR 0 2
25431: PUSH
25432: LD_VAR 0 1
25436: ARRAY
25437: ADD
25438: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25439: LD_VAR 0 2
25443: PUSH
25444: LD_VAR 0 1
25448: ARRAY
25449: PPUSH
25450: CALL_OW 310
25454: IFFALSE 25471
// ComExitBuilding ( tmp [ i ] ) ;
25456: LD_VAR 0 2
25460: PUSH
25461: LD_VAR 0 1
25465: ARRAY
25466: PPUSH
25467: CALL_OW 122
// if IsInUnit ( i ) then
25471: LD_VAR 0 1
25475: PPUSH
25476: CALL_OW 310
25480: IFFALSE 25497
// ComExitVehicle ( tmp [ i ] ) ;
25482: LD_VAR 0 2
25486: PUSH
25487: LD_VAR 0 1
25491: ARRAY
25492: PPUSH
25493: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25497: LD_VAR 0 2
25501: PUSH
25502: LD_VAR 0 1
25506: ARRAY
25507: PPUSH
25508: LD_INT 34
25510: PUSH
25511: LD_INT 0
25513: PPUSH
25514: LD_INT 6
25516: PPUSH
25517: CALL_OW 12
25521: PLUS
25522: PPUSH
25523: LD_INT 1
25525: PPUSH
25526: CALL_OW 171
// end ;
25530: GO 25414
25532: POP
25533: POP
// end else
25534: GO 25546
// x := tmp ;
25536: LD_ADDR_VAR 0 3
25540: PUSH
25541: LD_VAR 0 2
25545: ST_TO_ADDR
// for i := tmp downto tmp - x do
25546: LD_ADDR_VAR 0 1
25550: PUSH
25551: DOUBLE
25552: LD_VAR 0 2
25556: INC
25557: ST_TO_ADDR
25558: LD_VAR 0 2
25562: PUSH
25563: LD_VAR 0 3
25567: MINUS
25568: PUSH
25569: FOR_DOWNTO
25570: IFFALSE 25624
// begin if IsInUnit ( tmp [ i ] ) then
25572: LD_VAR 0 2
25576: PUSH
25577: LD_VAR 0 1
25581: ARRAY
25582: PPUSH
25583: CALL_OW 310
25587: IFFALSE 25604
// ComExitVehicle ( tmp [ i ] ) ;
25589: LD_VAR 0 2
25593: PUSH
25594: LD_VAR 0 1
25598: ARRAY
25599: PPUSH
25600: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25604: LD_VAR 0 2
25608: PUSH
25609: LD_VAR 0 1
25613: ARRAY
25614: PPUSH
25615: LD_INT 1
25617: PPUSH
25618: CALL_OW 235
// end ;
25622: GO 25569
25624: POP
25625: POP
// SetSide ( Kurt , 1 ) ;
25626: LD_EXP 60
25630: PPUSH
25631: LD_INT 1
25633: PPUSH
25634: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25638: LD_INT 22
25640: PUSH
25641: LD_INT 8
25643: PUSH
25644: EMPTY
25645: LIST
25646: LIST
25647: PUSH
25648: LD_INT 21
25650: PUSH
25651: LD_INT 3
25653: PUSH
25654: EMPTY
25655: LIST
25656: LIST
25657: PUSH
25658: EMPTY
25659: LIST
25660: LIST
25661: PPUSH
25662: CALL_OW 69
25666: PPUSH
25667: LD_INT 1
25669: PPUSH
25670: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25674: LD_INT 8
25676: PPUSH
25677: LD_INT 1
25679: PPUSH
25680: LD_INT 1
25682: PPUSH
25683: LD_INT 1
25685: PPUSH
25686: CALL_OW 80
// wait ( 1 1$20 ) ;
25690: LD_INT 2800
25692: PPUSH
25693: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25697: LD_EXP 62
25701: PPUSH
25702: LD_INT 37
25704: PPUSH
25705: LD_INT 1
25707: PPUSH
25708: LD_INT 0
25710: PPUSH
25711: CALL_OW 48
// wait ( 0 0$1 ) ;
25715: LD_INT 35
25717: PPUSH
25718: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25722: LD_EXP 62
25726: PPUSH
25727: LD_INT 60
25729: PPUSH
25730: LD_INT 95
25732: PPUSH
25733: CALL_OW 111
// end ;
25737: PPOPN 3
25739: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25740: LD_EXP 22
25744: NOT
25745: PUSH
25746: LD_INT 22
25748: PUSH
25749: LD_INT 8
25751: PUSH
25752: EMPTY
25753: LIST
25754: LIST
25755: PUSH
25756: LD_INT 21
25758: PUSH
25759: LD_INT 1
25761: PUSH
25762: EMPTY
25763: LIST
25764: LIST
25765: PUSH
25766: EMPTY
25767: LIST
25768: LIST
25769: PPUSH
25770: CALL_OW 69
25774: PUSH
25775: LD_INT 0
25777: EQUAL
25778: AND
25779: IFFALSE 25799
25781: GO 25783
25783: DISABLE
// begin legionDestroyed := true ;
25784: LD_ADDR_EXP 22
25788: PUSH
25789: LD_INT 1
25791: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
25792: LD_STRING MlegionOut
25794: PPUSH
25795: CALL_OW 337
// end ;
25799: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25800: LD_EXP 38
25804: IFFALSE 25879
25806: GO 25808
25808: DISABLE
25809: LD_INT 0
25811: PPUSH
// begin enable ;
25812: ENABLE
// for i in legionEscapeUnits do
25813: LD_ADDR_VAR 0 1
25817: PUSH
25818: LD_EXP 38
25822: PUSH
25823: FOR_IN
25824: IFFALSE 25877
// begin if IsInArea ( i , legionEscapeArea ) then
25826: LD_VAR 0 1
25830: PPUSH
25831: LD_INT 31
25833: PPUSH
25834: CALL_OW 308
25838: IFFALSE 25851
// RemoveUnit ( i ) else
25840: LD_VAR 0 1
25844: PPUSH
25845: CALL_OW 64
25849: GO 25875
// if not HasTask ( i ) then
25851: LD_VAR 0 1
25855: PPUSH
25856: CALL_OW 314
25860: NOT
25861: IFFALSE 25875
// ComMoveToArea ( i , legionEscapeArea ) ;
25863: LD_VAR 0 1
25867: PPUSH
25868: LD_INT 31
25870: PPUSH
25871: CALL_OW 113
// end ;
25875: GO 25823
25877: POP
25878: POP
// end ;
25879: PPOPN 1
25881: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25882: LD_INT 1
25884: PPUSH
25885: LD_EXP 62
25889: PPUSH
25890: CALL_OW 292
25894: IFFALSE 26192
25896: GO 25898
25898: DISABLE
25899: LD_INT 0
25901: PPUSH
// begin wait ( 0 0$2 ) ;
25902: LD_INT 70
25904: PPUSH
25905: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25909: LD_EXP 62
25913: PPUSH
25914: CALL_OW 87
// DialogueOn ;
25918: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25922: LD_EXP 39
25926: PPUSH
25927: LD_STRING D14-JMM-1
25929: PPUSH
25930: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25934: LD_EXP 62
25938: PPUSH
25939: LD_STRING D14-Friend-1
25941: PPUSH
25942: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25946: LD_EXP 39
25950: PPUSH
25951: LD_STRING D14-JMM-2
25953: PPUSH
25954: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25958: LD_EXP 62
25962: PPUSH
25963: LD_STRING D14-Friend-2
25965: PPUSH
25966: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25970: LD_EXP 39
25974: PPUSH
25975: LD_STRING D14-JMM-3
25977: PPUSH
25978: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25982: LD_EXP 62
25986: PPUSH
25987: LD_STRING D14-Friend-3
25989: PPUSH
25990: CALL_OW 88
// DialogueOff ;
25994: CALL_OW 7
// dec = Query ( Q14 ) ;
25998: LD_ADDR_VAR 0 1
26002: PUSH
26003: LD_STRING Q14
26005: PPUSH
26006: CALL_OW 97
26010: ST_TO_ADDR
// if dec = 1 then
26011: LD_VAR 0 1
26015: PUSH
26016: LD_INT 1
26018: EQUAL
26019: IFFALSE 26053
// begin DialogueOn ;
26021: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
26025: LD_EXP 39
26029: PPUSH
26030: LD_STRING D14a-JMM-1
26032: PPUSH
26033: CALL_OW 88
// DialogueOff ;
26037: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26041: LD_EXP 62
26045: PPUSH
26046: LD_INT 1
26048: PPUSH
26049: CALL_OW 235
// end ; if dec = 2 then
26053: LD_VAR 0 1
26057: PUSH
26058: LD_INT 2
26060: EQUAL
26061: IFFALSE 26114
// begin DialogueOn ;
26063: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26067: LD_EXP 39
26071: PPUSH
26072: LD_STRING D14b-JMM-1
26074: PPUSH
26075: CALL_OW 88
// DialogueOff ;
26079: CALL_OW 7
// wait ( 0 0$1 ) ;
26083: LD_INT 35
26085: PPUSH
26086: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26090: LD_EXP 62
26094: PPUSH
26095: LD_INT 9
26097: PPUSH
26098: LD_INT 2
26100: PPUSH
26101: CALL_OW 111
// AddComHold ( Friend ) ;
26105: LD_EXP 62
26109: PPUSH
26110: CALL_OW 200
// end ; if dec = 3 then
26114: LD_VAR 0 1
26118: PUSH
26119: LD_INT 3
26121: EQUAL
26122: IFFALSE 26192
// begin DialogueOn ;
26124: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26128: LD_EXP 39
26132: PPUSH
26133: LD_STRING D14c-JMM-1
26135: PPUSH
26136: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26140: LD_EXP 62
26144: PPUSH
26145: LD_STRING D14c-Friend-1
26147: PPUSH
26148: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26152: LD_EXP 39
26156: PPUSH
26157: LD_STRING D14c-JMM-2
26159: PPUSH
26160: CALL_OW 88
// DialogueOff ;
26164: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26168: LD_EXP 62
26172: PPUSH
26173: LD_INT 9
26175: PPUSH
26176: LD_INT 2
26178: PPUSH
26179: CALL_OW 111
// AddComHold ( Friend ) ;
26183: LD_EXP 62
26187: PPUSH
26188: CALL_OW 200
// end ; end ;
26192: PPOPN 1
26194: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26195: LD_INT 9
26197: PPUSH
26198: LD_INT 2
26200: PPUSH
26201: CALL_OW 428
26205: PUSH
26206: LD_EXP 62
26210: EQUAL
26211: PUSH
26212: LD_EXP 62
26216: PPUSH
26217: CALL_OW 255
26221: PUSH
26222: LD_INT 8
26224: EQUAL
26225: AND
26226: IFFALSE 26240
26228: GO 26230
26230: DISABLE
// RemoveUnit ( Friend ) ;
26231: LD_EXP 62
26235: PPUSH
26236: CALL_OW 64
26240: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26241: LD_EXP 14
26245: PUSH
26246: LD_INT 31500
26248: GREATEREQUAL
26249: PUSH
26250: LD_EXP 7
26254: AND
26255: PUSH
26256: LD_EXP 2
26260: AND
26261: IFFALSE 26691
26263: GO 26265
26265: DISABLE
26266: LD_INT 0
26268: PPUSH
26269: PPUSH
26270: PPUSH
// begin missionStage := 7 ;
26271: LD_ADDR_EXP 15
26275: PUSH
26276: LD_INT 7
26278: ST_TO_ADDR
// uc_side = 1 ;
26279: LD_ADDR_OWVAR 20
26283: PUSH
26284: LD_INT 1
26286: ST_TO_ADDR
// uc_nation = 1 ;
26287: LD_ADDR_OWVAR 21
26291: PUSH
26292: LD_INT 1
26294: ST_TO_ADDR
// for i = 1 to 5 do
26295: LD_ADDR_VAR 0 1
26299: PUSH
26300: DOUBLE
26301: LD_INT 1
26303: DEC
26304: ST_TO_ADDR
26305: LD_INT 5
26307: PUSH
26308: FOR_TO
26309: IFFALSE 26405
// begin vc_engine = 3 ;
26311: LD_ADDR_OWVAR 39
26315: PUSH
26316: LD_INT 3
26318: ST_TO_ADDR
// vc_control = 3 ;
26319: LD_ADDR_OWVAR 38
26323: PUSH
26324: LD_INT 3
26326: ST_TO_ADDR
// vc_chassis = 3 ;
26327: LD_ADDR_OWVAR 37
26331: PUSH
26332: LD_INT 3
26334: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26335: LD_ADDR_OWVAR 40
26339: PUSH
26340: LD_INT 5
26342: PUSH
26343: LD_INT 9
26345: PUSH
26346: LD_INT 7
26348: PUSH
26349: EMPTY
26350: LIST
26351: LIST
26352: LIST
26353: PUSH
26354: LD_INT 1
26356: PPUSH
26357: LD_INT 3
26359: PPUSH
26360: CALL_OW 12
26364: ARRAY
26365: ST_TO_ADDR
// veh = CreateVehicle ;
26366: LD_ADDR_VAR 0 2
26370: PUSH
26371: CALL_OW 45
26375: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26376: LD_VAR 0 2
26380: PPUSH
26381: LD_INT 1
26383: PPUSH
26384: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26388: LD_VAR 0 2
26392: PPUSH
26393: LD_INT 19
26395: PPUSH
26396: LD_INT 0
26398: PPUSH
26399: CALL_OW 49
// end ;
26403: GO 26308
26405: POP
26406: POP
// vc_engine = 3 ;
26407: LD_ADDR_OWVAR 39
26411: PUSH
26412: LD_INT 3
26414: ST_TO_ADDR
// vc_control = 1 ;
26415: LD_ADDR_OWVAR 38
26419: PUSH
26420: LD_INT 1
26422: ST_TO_ADDR
// vc_chassis = 3 ;
26423: LD_ADDR_OWVAR 37
26427: PUSH
26428: LD_INT 3
26430: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26431: LD_ADDR_OWVAR 40
26435: PUSH
26436: LD_INT 5
26438: PUSH
26439: LD_INT 9
26441: PUSH
26442: LD_INT 7
26444: PUSH
26445: EMPTY
26446: LIST
26447: LIST
26448: LIST
26449: PUSH
26450: LD_INT 1
26452: PPUSH
26453: LD_INT 3
26455: PPUSH
26456: CALL_OW 12
26460: ARRAY
26461: ST_TO_ADDR
// vehG = CreateVehicle ;
26462: LD_ADDR_VAR 0 3
26466: PUSH
26467: CALL_OW 45
26471: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26472: LD_VAR 0 3
26476: PPUSH
26477: LD_INT 1
26479: PPUSH
26480: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26484: LD_VAR 0 3
26488: PPUSH
26489: LD_INT 19
26491: PPUSH
26492: LD_INT 0
26494: PPUSH
26495: CALL_OW 49
// if JMMGirl = 1 then
26499: LD_EXP 7
26503: PUSH
26504: LD_INT 1
26506: EQUAL
26507: IFFALSE 26563
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26509: LD_ADDR_EXP 40
26513: PUSH
26514: LD_STRING Joan
26516: PPUSH
26517: LD_INT 1
26519: PPUSH
26520: LD_STRING 14_
26522: PPUSH
26523: CALL 65182 0 3
26527: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26528: LD_EXP 40
26532: PPUSH
26533: LD_VAR 0 3
26537: PPUSH
26538: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26542: LD_VAR 0 3
26546: PPUSH
26547: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26551: LD_EXP 40
26555: PPUSH
26556: LD_STRING D10BW-Joan-1
26558: PPUSH
26559: CALL_OW 94
// end ; if JMMGirl = 2 then
26563: LD_EXP 7
26567: PUSH
26568: LD_INT 2
26570: EQUAL
26571: IFFALSE 26627
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26573: LD_ADDR_EXP 42
26577: PUSH
26578: LD_STRING Lisa
26580: PPUSH
26581: LD_INT 1
26583: PPUSH
26584: LD_STRING 14_
26586: PPUSH
26587: CALL 65182 0 3
26591: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26592: LD_EXP 42
26596: PPUSH
26597: LD_VAR 0 3
26601: PPUSH
26602: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26606: LD_VAR 0 3
26610: PPUSH
26611: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26615: LD_EXP 42
26619: PPUSH
26620: LD_STRING D10BW-Lisa-1
26622: PPUSH
26623: CALL_OW 94
// end ; if JMMGirl = 3 then
26627: LD_EXP 7
26631: PUSH
26632: LD_INT 3
26634: EQUAL
26635: IFFALSE 26691
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26637: LD_ADDR_EXP 54
26641: PUSH
26642: LD_STRING Connie
26644: PPUSH
26645: LD_INT 1
26647: PPUSH
26648: LD_STRING 14_
26650: PPUSH
26651: CALL 65182 0 3
26655: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26656: LD_EXP 54
26660: PPUSH
26661: LD_VAR 0 3
26665: PPUSH
26666: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26670: LD_VAR 0 3
26674: PPUSH
26675: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26679: LD_EXP 54
26683: PPUSH
26684: LD_STRING D10BW-Con-1
26686: PPUSH
26687: CALL_OW 94
// end ; end ;
26691: PPOPN 3
26693: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26694: LD_EXP 14
26698: PUSH
26699: LD_INT 94500
26701: GREATEREQUAL
26702: IFFALSE 27114
26704: GO 26706
26706: DISABLE
26707: LD_INT 0
26709: PPUSH
26710: PPUSH
26711: PPUSH
// begin tmp := PrepareStevensSquad ;
26712: LD_ADDR_VAR 0 3
26716: PUSH
26717: CALL 2222 0 0
26721: ST_TO_ADDR
// if not tmp then
26722: LD_VAR 0 3
26726: NOT
26727: IFFALSE 26731
// exit ;
26729: GO 27114
// uc_side := 1 ;
26731: LD_ADDR_OWVAR 20
26735: PUSH
26736: LD_INT 1
26738: ST_TO_ADDR
// uc_nation := 1 ;
26739: LD_ADDR_OWVAR 21
26743: PUSH
26744: LD_INT 1
26746: ST_TO_ADDR
// for i in tmp do
26747: LD_ADDR_VAR 0 1
26751: PUSH
26752: LD_VAR 0 3
26756: PUSH
26757: FOR_IN
26758: IFFALSE 26855
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26760: LD_INT 3
26762: PPUSH
26763: LD_INT 3
26765: PPUSH
26766: LD_INT 1
26768: PPUSH
26769: LD_INT 5
26771: PUSH
26772: LD_INT 9
26774: PUSH
26775: LD_INT 7
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: LIST
26782: PUSH
26783: LD_INT 1
26785: PPUSH
26786: LD_INT 3
26788: PPUSH
26789: CALL_OW 12
26793: ARRAY
26794: PPUSH
26795: LD_INT 40
26797: PPUSH
26798: CALL 70006 0 5
// veh := CreateVehicle ;
26802: LD_ADDR_VAR 0 2
26806: PUSH
26807: CALL_OW 45
26811: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26812: LD_VAR 0 2
26816: PPUSH
26817: LD_INT 1
26819: PPUSH
26820: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26824: LD_VAR 0 2
26828: PPUSH
26829: LD_INT 19
26831: PPUSH
26832: LD_INT 0
26834: PPUSH
26835: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26839: LD_VAR 0 1
26843: PPUSH
26844: LD_VAR 0 2
26848: PPUSH
26849: CALL_OW 52
// end ;
26853: GO 26757
26855: POP
26856: POP
// missionStage := 8 ;
26857: LD_ADDR_EXP 15
26861: PUSH
26862: LD_INT 8
26864: ST_TO_ADDR
// DialogueOn ;
26865: CALL_OW 6
// if Stevens then
26869: LD_EXP 41
26873: IFFALSE 26987
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26875: LD_EXP 41
26879: PPUSH
26880: CALL_OW 310
26884: PPUSH
26885: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26889: LD_EXP 41
26893: PPUSH
26894: LD_STRING D8-Huck-1
26896: PPUSH
26897: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26901: LD_EXP 39
26905: PPUSH
26906: LD_STRING D8-JMM-1
26908: PPUSH
26909: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26913: LD_EXP 41
26917: PPUSH
26918: LD_STRING D8-Huck-2
26920: PPUSH
26921: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26925: LD_EXP 39
26929: PPUSH
26930: LD_STRING D8-JMM-2
26932: PPUSH
26933: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26937: LD_EXP 41
26941: PPUSH
26942: LD_STRING D8-Huck-3
26944: PPUSH
26945: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26949: LD_EXP 39
26953: PPUSH
26954: LD_STRING D8-JMM-3
26956: PPUSH
26957: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26961: LD_EXP 41
26965: PPUSH
26966: LD_STRING D8-Huck-4
26968: PPUSH
26969: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26973: LD_EXP 39
26977: PPUSH
26978: LD_STRING D8-JMM-4
26980: PPUSH
26981: CALL_OW 88
// end else
26985: GO 27097
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26987: LD_EXP 55
26991: PPUSH
26992: CALL_OW 310
26996: PPUSH
26997: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
27001: LD_EXP 55
27005: PPUSH
27006: LD_STRING D8-Huck-1
27008: PPUSH
27009: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
27013: LD_EXP 39
27017: PPUSH
27018: LD_STRING D8-JMM-1a
27020: PPUSH
27021: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
27025: LD_EXP 55
27029: PPUSH
27030: LD_STRING D8-Huck-2
27032: PPUSH
27033: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27037: LD_EXP 39
27041: PPUSH
27042: LD_STRING D8-JMM-2
27044: PPUSH
27045: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
27049: LD_EXP 55
27053: PPUSH
27054: LD_STRING D8-Huck-3
27056: PPUSH
27057: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27061: LD_EXP 39
27065: PPUSH
27066: LD_STRING D8-JMM-3
27068: PPUSH
27069: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27073: LD_EXP 55
27077: PPUSH
27078: LD_STRING D8-Huck-4
27080: PPUSH
27081: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27085: LD_EXP 39
27089: PPUSH
27090: LD_STRING D8-JMM-4
27092: PPUSH
27093: CALL_OW 88
// end ; DialogueOff ;
27097: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27101: LD_INT 25
27103: PPUSH
27104: LD_INT 1
27106: PPUSH
27107: LD_INT 1
27109: PPUSH
27110: CALL_OW 322
// end ;
27114: PPOPN 3
27116: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27117: LD_INT 1
27119: PPUSH
27120: LD_EXP 71
27124: PPUSH
27125: CALL_OW 292
27129: IFFALSE 27380
27131: GO 27133
27133: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27134: LD_EXP 71
27138: PPUSH
27139: CALL_OW 87
// DialogueOn ;
27143: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27147: LD_EXP 39
27151: PPUSH
27152: LD_STRING D10nB-JMM-1
27154: PPUSH
27155: CALL_OW 88
// if BurlakStatus = 1 then
27159: LD_EXP 9
27163: PUSH
27164: LD_INT 1
27166: EQUAL
27167: IFFALSE 27181
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27169: LD_EXP 70
27173: PPUSH
27174: LD_STRING D10nB-Vse-1a
27176: PPUSH
27177: CALL_OW 94
// end ; if BurlakStatus = 0 then
27181: LD_EXP 9
27185: PUSH
27186: LD_INT 0
27188: EQUAL
27189: IFFALSE 27203
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27191: LD_EXP 70
27195: PPUSH
27196: LD_STRING D10nB-Vse-1
27198: PPUSH
27199: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27203: LD_EXP 39
27207: PPUSH
27208: LD_STRING D10nB-JMM-2
27210: PPUSH
27211: CALL_OW 88
// if KappaStatus then
27215: LD_EXP 2
27219: IFFALSE 27233
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27221: LD_EXP 70
27225: PPUSH
27226: LD_STRING D10nB-Vse-5a
27228: PPUSH
27229: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27233: LD_EXP 2
27237: NOT
27238: PUSH
27239: LD_EXP 6
27243: PUSH
27244: LD_INT 0
27246: EQUAL
27247: AND
27248: IFFALSE 27376
// begin if JMMGirl = 1 then
27250: LD_EXP 7
27254: PUSH
27255: LD_INT 1
27257: EQUAL
27258: IFFALSE 27308
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27260: LD_EXP 70
27264: PPUSH
27265: LD_STRING D10nB-Vse-2
27267: PPUSH
27268: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27272: LD_EXP 39
27276: PPUSH
27277: LD_STRING D10nB-JMM-3
27279: PPUSH
27280: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27284: LD_EXP 70
27288: PPUSH
27289: LD_STRING D10nB-Vse-3
27291: PPUSH
27292: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27296: LD_EXP 39
27300: PPUSH
27301: LD_STRING D10nB-JMM-4
27303: PPUSH
27304: CALL_OW 88
// end ; if JMMGirl = 2 then
27308: LD_EXP 7
27312: PUSH
27313: LD_INT 2
27315: EQUAL
27316: IFFALSE 27342
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27318: LD_EXP 70
27322: PPUSH
27323: LD_STRING D10nB-Vse-4
27325: PPUSH
27326: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27330: LD_EXP 39
27334: PPUSH
27335: LD_STRING D10nB-JMM-5
27337: PPUSH
27338: CALL_OW 88
// end ; if JMMGirl = 3 then
27342: LD_EXP 7
27346: PUSH
27347: LD_INT 3
27349: EQUAL
27350: IFFALSE 27376
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27352: LD_EXP 70
27356: PPUSH
27357: LD_STRING D10nB-Vse-5
27359: PPUSH
27360: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27364: LD_EXP 39
27368: PPUSH
27369: LD_STRING D10nB-JMM-6
27371: PPUSH
27372: CALL_OW 88
// end ; end ; DialogueOff ;
27376: CALL_OW 7
// end ;
27380: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27381: LD_EXP 14
27385: PUSH
27386: LD_INT 115500
27388: GREATEREQUAL
27389: IFFALSE 27765
27391: GO 27393
27393: DISABLE
27394: LD_INT 0
27396: PPUSH
// begin missionStage := 10 ;
27397: LD_ADDR_EXP 15
27401: PUSH
27402: LD_INT 10
27404: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27405: LD_ADDR_VAR 0 1
27409: PUSH
27410: LD_INT 22
27412: PUSH
27413: LD_INT 1
27415: PUSH
27416: EMPTY
27417: LIST
27418: LIST
27419: PUSH
27420: LD_INT 23
27422: PUSH
27423: LD_INT 1
27425: PUSH
27426: EMPTY
27427: LIST
27428: LIST
27429: PUSH
27430: LD_INT 26
27432: PUSH
27433: LD_INT 1
27435: PUSH
27436: EMPTY
27437: LIST
27438: LIST
27439: PUSH
27440: LD_INT 3
27442: PUSH
27443: LD_INT 25
27445: PUSH
27446: LD_INT 12
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: PUSH
27453: EMPTY
27454: LIST
27455: LIST
27456: PUSH
27457: LD_INT 3
27459: PUSH
27460: LD_INT 25
27462: PUSH
27463: LD_INT 16
27465: PUSH
27466: EMPTY
27467: LIST
27468: LIST
27469: PUSH
27470: EMPTY
27471: LIST
27472: LIST
27473: PUSH
27474: EMPTY
27475: LIST
27476: LIST
27477: LIST
27478: LIST
27479: LIST
27480: PPUSH
27481: CALL_OW 69
27485: PUSH
27486: LD_EXP 39
27490: PUSH
27491: LD_EXP 60
27495: PUSH
27496: LD_EXP 41
27500: PUSH
27501: LD_EXP 55
27505: PUSH
27506: LD_EXP 42
27510: PUSH
27511: LD_EXP 43
27515: PUSH
27516: LD_EXP 44
27520: PUSH
27521: LD_EXP 45
27525: PUSH
27526: LD_EXP 46
27530: PUSH
27531: LD_EXP 47
27535: PUSH
27536: LD_EXP 48
27540: PUSH
27541: LD_EXP 49
27545: PUSH
27546: LD_EXP 50
27550: PUSH
27551: LD_EXP 51
27555: PUSH
27556: LD_EXP 52
27560: PUSH
27561: LD_EXP 53
27565: PUSH
27566: EMPTY
27567: LIST
27568: LIST
27569: LIST
27570: LIST
27571: LIST
27572: LIST
27573: LIST
27574: LIST
27575: LIST
27576: LIST
27577: LIST
27578: LIST
27579: LIST
27580: LIST
27581: LIST
27582: LIST
27583: DIFF
27584: ST_TO_ADDR
// if not tmp and Brown then
27585: LD_VAR 0 1
27589: NOT
27590: PUSH
27591: LD_EXP 47
27595: AND
27596: IFFALSE 27611
// tmp := [ Brown ] ;
27598: LD_ADDR_VAR 0 1
27602: PUSH
27603: LD_EXP 47
27607: PUSH
27608: EMPTY
27609: LIST
27610: ST_TO_ADDR
// DialogueOn ;
27611: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27615: LD_VAR 0 1
27619: PUSH
27620: LD_INT 1
27622: ARRAY
27623: PPUSH
27624: LD_STRING D11-Sol1-1
27626: PPUSH
27627: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27631: LD_EXP 64
27635: PPUSH
27636: LD_STRING D11-Pla-1
27638: PPUSH
27639: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27643: LD_EXP 65
27647: PPUSH
27648: LD_STRING D11-Kov-1
27650: PPUSH
27651: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27655: LD_EXP 64
27659: PPUSH
27660: LD_STRING D11-Pla-2
27662: PPUSH
27663: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27667: LD_VAR 0 1
27671: PUSH
27672: LD_INT 1
27674: ARRAY
27675: PPUSH
27676: LD_STRING D11-Sol1-2
27678: PPUSH
27679: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27683: LD_EXP 39
27687: PPUSH
27688: LD_STRING D11-JMM-2
27690: PPUSH
27691: CALL_OW 88
// DialogueOff ;
27695: CALL_OW 7
// allowBehemothConstruct := true ;
27699: LD_ADDR_EXP 25
27703: PUSH
27704: LD_INT 1
27706: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27707: LD_STRING M4
27709: PPUSH
27710: CALL_OW 337
// BuildBehemoths ;
27714: CALL 7693 0 0
// repeat wait ( 15 15$00 ) ;
27718: LD_INT 31500
27720: PPUSH
27721: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27725: LD_EXP 27
27729: IFFALSE 27733
// break ;
27731: GO 27765
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27733: LD_INT 267
27735: PPUSH
27736: CALL_OW 274
27740: PPUSH
27741: LD_INT 1
27743: PPUSH
27744: CALL_OW 275
27748: PUSH
27749: LD_INT 1000
27751: GREATEREQUAL
27752: IFFALSE 27758
// BuildBehemoths ;
27754: CALL 7693 0 0
// until not behemothBuilders ;
27758: LD_EXP 73
27762: NOT
27763: IFFALSE 27718
// end ;
27765: PPOPN 1
27767: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27768: LD_EXP 73
27772: NOT
27773: PUSH
27774: LD_EXP 28
27778: NOT
27779: AND
27780: PUSH
27781: LD_EXP 25
27785: AND
27786: IFFALSE 27806
27788: GO 27790
27790: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27791: LD_STRING M4a
27793: PPUSH
27794: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27798: LD_ADDR_EXP 27
27802: PUSH
27803: LD_INT 1
27805: ST_TO_ADDR
// end ;
27806: END
// every 0 0$1 trigger behemothDone do
27807: LD_EXP 28
27811: IFFALSE 27823
27813: GO 27815
27815: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27816: LD_STRING M4b
27818: PPUSH
27819: CALL_OW 337
27823: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27824: LD_EXP 29
27828: NOT
27829: IFFALSE 28025
27831: GO 27833
27833: DISABLE
27834: LD_INT 0
27836: PPUSH
27837: PPUSH
// begin enable ;
27838: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27839: LD_ADDR_VAR 0 1
27843: PUSH
27844: LD_INT 3
27846: PPUSH
27847: CALL 101232 0 1
27851: ST_TO_ADDR
// if not tmp and not behemothDone then
27852: LD_VAR 0 1
27856: NOT
27857: PUSH
27858: LD_EXP 28
27862: NOT
27863: AND
27864: IFFALSE 27900
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27866: LD_ADDR_VAR 0 1
27870: PUSH
27871: LD_INT 22
27873: PUSH
27874: LD_INT 3
27876: PUSH
27877: EMPTY
27878: LIST
27879: LIST
27880: PUSH
27881: LD_INT 30
27883: PUSH
27884: LD_INT 37
27886: PUSH
27887: EMPTY
27888: LIST
27889: LIST
27890: PUSH
27891: EMPTY
27892: LIST
27893: LIST
27894: PPUSH
27895: CALL_OW 69
27899: ST_TO_ADDR
// if not tmp then
27900: LD_VAR 0 1
27904: NOT
27905: IFFALSE 27909
// exit ;
27907: GO 28025
// for i in tmp do
27909: LD_ADDR_VAR 0 2
27913: PUSH
27914: LD_VAR 0 1
27918: PUSH
27919: FOR_IN
27920: IFFALSE 28023
// if See ( 1 , i ) then
27922: LD_INT 1
27924: PPUSH
27925: LD_VAR 0 2
27929: PPUSH
27930: CALL_OW 292
27934: IFFALSE 28021
// begin if GetType ( i ) = unit_building then
27936: LD_VAR 0 2
27940: PPUSH
27941: CALL_OW 247
27945: PUSH
27946: LD_INT 3
27948: EQUAL
27949: IFFALSE 27987
// begin CenterNowOnUnits ( i ) ;
27951: LD_VAR 0 2
27955: PPUSH
27956: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27960: LD_EXP 39
27964: PPUSH
27965: LD_STRING D17a-JMM-1
27967: PPUSH
27968: CALL_OW 88
// seeBehemoth := true ;
27972: LD_ADDR_EXP 29
27976: PUSH
27977: LD_INT 1
27979: ST_TO_ADDR
// disable ;
27980: DISABLE
// exit ;
27981: POP
27982: POP
27983: GO 28025
// end else
27985: GO 28021
// begin CenterNowOnUnits ( i ) ;
27987: LD_VAR 0 2
27991: PPUSH
27992: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27996: LD_EXP 39
28000: PPUSH
28001: LD_STRING D17b-JMM-1
28003: PPUSH
28004: CALL_OW 88
// seeBehemoth := true ;
28008: LD_ADDR_EXP 29
28012: PUSH
28013: LD_INT 1
28015: ST_TO_ADDR
// disable ;
28016: DISABLE
// exit ;
28017: POP
28018: POP
28019: GO 28025
// end ; end ;
28021: GO 27919
28023: POP
28024: POP
// end ;
28025: PPOPN 2
28027: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
28028: LD_EXP 14
28032: PUSH
28033: LD_INT 123200
28035: GREATEREQUAL
28036: IFFALSE 29212
28038: GO 28040
28040: DISABLE
28041: LD_INT 0
28043: PPUSH
28044: PPUSH
28045: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
28046: LD_INT 2
28048: PPUSH
28049: LD_INT 23
28051: PUSH
28052: LD_INT 3
28054: PUSH
28055: LD_INT 3
28057: PUSH
28058: LD_INT 48
28060: PUSH
28061: EMPTY
28062: LIST
28063: LIST
28064: LIST
28065: LIST
28066: PUSH
28067: EMPTY
28068: LIST
28069: PPUSH
28070: CALL 58819 0 2
// repeat wait ( 0 0$1 ) ;
28074: LD_INT 35
28076: PPUSH
28077: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28081: LD_INT 22
28083: PUSH
28084: LD_INT 3
28086: PUSH
28087: EMPTY
28088: LIST
28089: LIST
28090: PUSH
28091: LD_INT 34
28093: PUSH
28094: LD_INT 48
28096: PUSH
28097: EMPTY
28098: LIST
28099: LIST
28100: PUSH
28101: EMPTY
28102: LIST
28103: LIST
28104: PPUSH
28105: CALL_OW 69
28109: IFFALSE 28074
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28111: LD_ADDR_VAR 0 1
28115: PUSH
28116: LD_INT 22
28118: PUSH
28119: LD_INT 3
28121: PUSH
28122: EMPTY
28123: LIST
28124: LIST
28125: PUSH
28126: LD_INT 34
28128: PUSH
28129: LD_INT 48
28131: PUSH
28132: EMPTY
28133: LIST
28134: LIST
28135: PUSH
28136: EMPTY
28137: LIST
28138: LIST
28139: PPUSH
28140: CALL_OW 69
28144: PUSH
28145: LD_INT 1
28147: ARRAY
28148: ST_TO_ADDR
// missionStage := 12 ;
28149: LD_ADDR_EXP 15
28153: PUSH
28154: LD_INT 12
28156: ST_TO_ADDR
// platonovHasBomb := true ;
28157: LD_ADDR_EXP 30
28161: PUSH
28162: LD_INT 1
28164: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28165: LD_VAR 0 1
28169: PPUSH
28170: LD_INT 181
28172: PPUSH
28173: LD_INT 86
28175: PPUSH
28176: CALL_OW 171
// AddComHold ( bomb ) ;
28180: LD_VAR 0 1
28184: PPUSH
28185: CALL_OW 200
// wait ( 0 0$10 ) ;
28189: LD_INT 350
28191: PPUSH
28192: CALL_OW 67
// DialogueOn ;
28196: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28200: LD_EXP 64
28204: PPUSH
28205: LD_STRING D15-Pla-1
28207: PPUSH
28208: CALL_OW 94
// dec = Query ( Q15a ) ;
28212: LD_ADDR_VAR 0 2
28216: PUSH
28217: LD_STRING Q15a
28219: PPUSH
28220: CALL_OW 97
28224: ST_TO_ADDR
// if dec = 1 then
28225: LD_VAR 0 2
28229: PUSH
28230: LD_INT 1
28232: EQUAL
28233: IFFALSE 28256
// begin Say ( JMM , D15a-JMM-1 ) ;
28235: LD_EXP 39
28239: PPUSH
28240: LD_STRING D15a-JMM-1
28242: PPUSH
28243: CALL_OW 88
// YouLost ( Surrender ) ;
28247: LD_STRING Surrender
28249: PPUSH
28250: CALL_OW 104
// exit ;
28254: GO 29212
// end ; if dec = 2 then
28256: LD_VAR 0 2
28260: PUSH
28261: LD_INT 2
28263: EQUAL
28264: IFFALSE 28333
// begin Say ( JMM , D15b-JMM-1 ) ;
28266: LD_EXP 39
28270: PPUSH
28271: LD_STRING D15b-JMM-1
28273: PPUSH
28274: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28278: LD_EXP 64
28282: PPUSH
28283: LD_STRING D15b-Pla-1
28285: PPUSH
28286: CALL_OW 94
// DialogueOff ;
28290: CALL_OW 7
// wait ( 3 3$00 ) ;
28294: LD_INT 6300
28296: PPUSH
28297: CALL_OW 67
// DialogueOn ;
28301: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28305: LD_EXP 39
28309: PPUSH
28310: LD_STRING D15d-JMM-1a
28312: PPUSH
28313: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28317: LD_EXP 64
28321: PPUSH
28322: LD_STRING D15d-Pla-1
28324: PPUSH
28325: CALL_OW 94
// DialogueOff ;
28329: CALL_OW 7
// end ; if dec = 3 then
28333: LD_VAR 0 2
28337: PUSH
28338: LD_INT 3
28340: EQUAL
28341: IFFALSE 28395
// begin Say ( JMM , D15c-JMM-1 ) ;
28343: LD_EXP 39
28347: PPUSH
28348: LD_STRING D15c-JMM-1
28350: PPUSH
28351: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28355: LD_EXP 64
28359: PPUSH
28360: LD_STRING D15c-Pla-1
28362: PPUSH
28363: CALL_OW 94
// DialogueOff ;
28367: CALL_OW 7
// wait ( 0 0$15 ) ;
28371: LD_INT 525
28373: PPUSH
28374: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28378: LD_VAR 0 1
28382: PPUSH
28383: LD_INT 60
28385: PPUSH
28386: LD_INT 95
28388: PPUSH
28389: CALL_OW 116
// exit ;
28393: GO 29212
// end ; if dec = 4 then
28395: LD_VAR 0 2
28399: PUSH
28400: LD_INT 4
28402: EQUAL
28403: IFFALSE 28433
// begin Say ( JMM , D15d-JMM-1 ) ;
28405: LD_EXP 39
28409: PPUSH
28410: LD_STRING D15d-JMM-1
28412: PPUSH
28413: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28417: LD_EXP 64
28421: PPUSH
28422: LD_STRING D15d-Pla-1
28424: PPUSH
28425: CALL_OW 94
// DialogueOff ;
28429: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28433: LD_EXP 62
28437: PPUSH
28438: CALL_OW 302
28442: PUSH
28443: LD_EXP 62
28447: PPUSH
28448: CALL_OW 255
28452: PUSH
28453: LD_INT 1
28455: EQUAL
28456: AND
28457: PUSH
28458: LD_INT 22
28460: PUSH
28461: LD_INT 1
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PUSH
28468: LD_INT 34
28470: PUSH
28471: LD_INT 8
28473: PUSH
28474: EMPTY
28475: LIST
28476: LIST
28477: PUSH
28478: EMPTY
28479: LIST
28480: LIST
28481: PPUSH
28482: CALL_OW 69
28486: NOT
28487: AND
28488: IFFALSE 29113
// begin SetSide ( Friend , 8 ) ;
28490: LD_EXP 62
28494: PPUSH
28495: LD_INT 8
28497: PPUSH
28498: CALL_OW 235
// if IsInUnit ( Friend ) then
28502: LD_EXP 62
28506: PPUSH
28507: CALL_OW 310
28511: IFFALSE 28522
// ComExitBuilding ( Friend ) ;
28513: LD_EXP 62
28517: PPUSH
28518: CALL_OW 122
// if IsDriver ( Friend ) then
28522: LD_EXP 62
28526: PPUSH
28527: CALL 98777 0 1
28531: IFFALSE 28542
// ComExitVehicle ( Friend ) ;
28533: LD_EXP 62
28537: PPUSH
28538: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28542: LD_EXP 62
28546: PPUSH
28547: LD_INT 9
28549: PPUSH
28550: LD_INT 2
28552: PPUSH
28553: CALL_OW 171
// wait ( 0 0$05 ) ;
28557: LD_INT 175
28559: PPUSH
28560: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28564: LD_EXP 62
28568: PPUSH
28569: CALL_OW 87
// DialogueOn ;
28573: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28577: LD_EXP 39
28581: PPUSH
28582: LD_STRING D16-JMM-1
28584: PPUSH
28585: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28589: LD_EXP 62
28593: PPUSH
28594: LD_STRING D16-Friend-1
28596: PPUSH
28597: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28601: LD_EXP 39
28605: PPUSH
28606: LD_STRING D16-JMM-2
28608: PPUSH
28609: CALL_OW 88
// DialogueOff ;
28613: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28617: LD_EXP 62
28621: PPUSH
28622: LD_INT 1
28624: PPUSH
28625: CALL_OW 235
// ComHold ( Friend ) ;
28629: LD_EXP 62
28633: PPUSH
28634: CALL_OW 140
// wait ( 0 0$20 ) ;
28638: LD_INT 700
28640: PPUSH
28641: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28645: LD_EXP 62
28649: PPUSH
28650: LD_INT 9
28652: PPUSH
28653: LD_INT 2
28655: PPUSH
28656: CALL_OW 297
28660: PUSH
28661: LD_INT 30
28663: LESS
28664: IFFALSE 28733
// begin SetSide ( Friend , 8 ) ;
28666: LD_EXP 62
28670: PPUSH
28671: LD_INT 8
28673: PPUSH
28674: CALL_OW 235
// if IsInUnit ( Friend ) then
28678: LD_EXP 62
28682: PPUSH
28683: CALL_OW 310
28687: IFFALSE 28698
// ComExitBuilding ( Friend ) ;
28689: LD_EXP 62
28693: PPUSH
28694: CALL_OW 122
// if IsDriver ( Friend ) then
28698: LD_EXP 62
28702: PPUSH
28703: CALL 98777 0 1
28707: IFFALSE 28718
// ComExitVehicle ( Friend ) ;
28709: LD_EXP 62
28713: PPUSH
28714: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28718: LD_EXP 62
28722: PPUSH
28723: LD_INT 9
28725: PPUSH
28726: LD_INT 2
28728: PPUSH
28729: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28733: LD_INT 1050
28735: PPUSH
28736: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28740: LD_INT 22
28742: PUSH
28743: LD_INT 1
28745: PUSH
28746: EMPTY
28747: LIST
28748: LIST
28749: PUSH
28750: LD_INT 34
28752: PUSH
28753: LD_INT 8
28755: PUSH
28756: EMPTY
28757: LIST
28758: LIST
28759: PUSH
28760: EMPTY
28761: LIST
28762: LIST
28763: PPUSH
28764: CALL_OW 69
28768: NOT
28769: IFFALSE 29091
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28771: LD_ADDR_VAR 0 3
28775: PUSH
28776: LD_INT 22
28778: PUSH
28779: LD_INT 1
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: PUSH
28786: LD_INT 26
28788: PUSH
28789: LD_INT 1
28791: PUSH
28792: EMPTY
28793: LIST
28794: LIST
28795: PUSH
28796: LD_INT 3
28798: PUSH
28799: LD_INT 25
28801: PUSH
28802: LD_INT 12
28804: PUSH
28805: EMPTY
28806: LIST
28807: LIST
28808: PUSH
28809: LD_INT 25
28811: PUSH
28812: LD_INT 16
28814: PUSH
28815: EMPTY
28816: LIST
28817: LIST
28818: PUSH
28819: EMPTY
28820: LIST
28821: LIST
28822: LIST
28823: PUSH
28824: EMPTY
28825: LIST
28826: LIST
28827: LIST
28828: PPUSH
28829: CALL_OW 69
28833: PUSH
28834: LD_EXP 39
28838: PUSH
28839: LD_EXP 41
28843: PUSH
28844: LD_EXP 55
28848: PUSH
28849: LD_EXP 42
28853: PUSH
28854: LD_EXP 43
28858: PUSH
28859: LD_EXP 44
28863: PUSH
28864: LD_EXP 45
28868: PUSH
28869: LD_EXP 46
28873: PUSH
28874: LD_EXP 47
28878: PUSH
28879: LD_EXP 48
28883: PUSH
28884: LD_EXP 49
28888: PUSH
28889: LD_EXP 50
28893: PUSH
28894: LD_EXP 51
28898: PUSH
28899: LD_EXP 52
28903: PUSH
28904: LD_EXP 53
28908: PUSH
28909: EMPTY
28910: LIST
28911: LIST
28912: LIST
28913: LIST
28914: LIST
28915: LIST
28916: LIST
28917: LIST
28918: LIST
28919: LIST
28920: LIST
28921: LIST
28922: LIST
28923: LIST
28924: LIST
28925: DIFF
28926: ST_TO_ADDR
// DialogueOn ;
28927: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28931: LD_EXP 64
28935: PPUSH
28936: LD_STRING D16a-Pla-1
28938: PPUSH
28939: CALL_OW 94
// if Stevens then
28943: LD_EXP 41
28947: IFFALSE 28963
// Say ( Stevens , D16a-Huck-1 ) else
28949: LD_EXP 41
28953: PPUSH
28954: LD_STRING D16a-Huck-1
28956: PPUSH
28957: CALL_OW 88
28961: GO 29005
// if Baker then
28963: LD_EXP 55
28967: IFFALSE 28983
// Say ( Baker , D16a-Huck-1 ) else
28969: LD_EXP 55
28973: PPUSH
28974: LD_STRING D16a-Huck-1
28976: PPUSH
28977: CALL_OW 88
28981: GO 29005
// if tmp then
28983: LD_VAR 0 3
28987: IFFALSE 29005
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28989: LD_VAR 0 3
28993: PUSH
28994: LD_INT 1
28996: ARRAY
28997: PPUSH
28998: LD_STRING D16a-Sol1-1
29000: PPUSH
29001: CALL_OW 88
// if GetSide ( Friend ) = 8 then
29005: LD_EXP 62
29009: PPUSH
29010: CALL_OW 255
29014: PUSH
29015: LD_INT 8
29017: EQUAL
29018: IFFALSE 29034
// Say ( JMM , D16a-JMM-1 ) else
29020: LD_EXP 39
29024: PPUSH
29025: LD_STRING D16a-JMM-1
29027: PPUSH
29028: CALL_OW 88
29032: GO 29070
// begin Say ( JMM , D16a-JMM-1a ) ;
29034: LD_EXP 39
29038: PPUSH
29039: LD_STRING D16a-JMM-1a
29041: PPUSH
29042: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
29046: LD_EXP 62
29050: PPUSH
29051: LD_STRING D16a-Friend-1
29053: PPUSH
29054: CALL_OW 88
// SetSide ( Friend , 3 ) ;
29058: LD_EXP 62
29062: PPUSH
29063: LD_INT 3
29065: PPUSH
29066: CALL_OW 235
// end ; DialogueOff ;
29070: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29074: LD_VAR 0 1
29078: PPUSH
29079: LD_INT 60
29081: PPUSH
29082: LD_INT 95
29084: PPUSH
29085: CALL_OW 116
// end else
29089: GO 29111
// begin DialogueOn ;
29091: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29095: LD_EXP 64
29099: PPUSH
29100: LD_STRING D16c-Pla-
29102: PPUSH
29103: CALL_OW 94
// DialogueOff ;
29107: CALL_OW 7
// end ; end else
29111: GO 29212
// begin wait ( 3 3$00 ) ;
29113: LD_INT 6300
29115: PPUSH
29116: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29120: LD_INT 22
29122: PUSH
29123: LD_INT 1
29125: PUSH
29126: EMPTY
29127: LIST
29128: LIST
29129: PUSH
29130: LD_INT 34
29132: PUSH
29133: LD_INT 8
29135: PUSH
29136: EMPTY
29137: LIST
29138: LIST
29139: PUSH
29140: EMPTY
29141: LIST
29142: LIST
29143: PPUSH
29144: CALL_OW 69
29148: NOT
29149: IFFALSE 29192
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29151: LD_EXP 64
29155: PPUSH
29156: LD_STRING D16b-Pla-1
29158: PPUSH
29159: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29163: LD_EXP 39
29167: PPUSH
29168: LD_STRING D16b-JMM-
29170: PPUSH
29171: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29175: LD_VAR 0 1
29179: PPUSH
29180: LD_INT 60
29182: PPUSH
29183: LD_INT 95
29185: PPUSH
29186: CALL_OW 116
// end else
29190: GO 29212
// begin DialogueOn ;
29192: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29196: LD_EXP 64
29200: PPUSH
29201: LD_STRING D16c-Pla-
29203: PPUSH
29204: CALL_OW 94
// DialogueOff ;
29208: CALL_OW 7
// end ; end ; end ;
29212: PPOPN 3
29214: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29215: LD_EXP 14
29219: PUSH
29220: LD_INT 126000
29222: GREATEREQUAL
29223: PUSH
29224: LD_EXP 23
29228: NOT
29229: AND
29230: PUSH
29231: LD_EXP 74
29235: PPUSH
29236: CALL_OW 302
29240: AND
29241: IFFALSE 29599
29243: GO 29245
29245: DISABLE
29246: LD_INT 0
29248: PPUSH
// begin missionStage = 11 ;
29249: LD_ADDR_EXP 15
29253: PUSH
29254: LD_INT 11
29256: ST_TO_ADDR
// DialogueOn ;
29257: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29261: LD_EXP 74
29265: PPUSH
29266: LD_STRING D9-Roth-1
29268: PPUSH
29269: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29273: LD_EXP 39
29277: PPUSH
29278: LD_STRING D9-JMM-1
29280: PPUSH
29281: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29285: LD_EXP 74
29289: PPUSH
29290: LD_STRING D9-Roth-2
29292: PPUSH
29293: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29297: LD_EXP 74
29301: PPUSH
29302: LD_STRING D9-Roth-2a
29304: PPUSH
29305: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29309: LD_EXP 64
29313: PPUSH
29314: LD_STRING D9-Pla-2
29316: PPUSH
29317: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29321: LD_EXP 74
29325: PPUSH
29326: LD_STRING D9-Roth-3
29328: PPUSH
29329: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29333: LD_EXP 64
29337: PPUSH
29338: LD_STRING D9-Pla-3
29340: PPUSH
29341: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29345: LD_EXP 74
29349: PPUSH
29350: LD_STRING D9-Roth-4
29352: PPUSH
29353: CALL_OW 94
// dec = Query ( Q9 ) ;
29357: LD_ADDR_VAR 0 1
29361: PUSH
29362: LD_STRING Q9
29364: PPUSH
29365: CALL_OW 97
29369: ST_TO_ADDR
// if dec = 1 then
29370: LD_VAR 0 1
29374: PUSH
29375: LD_INT 1
29377: EQUAL
29378: IFFALSE 29392
// SayRadio ( Roth , D9a-Roth-1 ) ;
29380: LD_EXP 74
29384: PPUSH
29385: LD_STRING D9a-Roth-1
29387: PPUSH
29388: CALL_OW 94
// if dec = 2 then
29392: LD_VAR 0 1
29396: PUSH
29397: LD_INT 2
29399: EQUAL
29400: IFFALSE 29426
// begin Say ( JMM , D9b-JMM-1 ) ;
29402: LD_EXP 39
29406: PPUSH
29407: LD_STRING D9b-JMM-1
29409: PPUSH
29410: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29414: LD_EXP 74
29418: PPUSH
29419: LD_STRING D9b-Roth-1
29421: PPUSH
29422: CALL_OW 94
// end ; if dec = 3 then
29426: LD_VAR 0 1
29430: PUSH
29431: LD_INT 3
29433: EQUAL
29434: IFFALSE 29496
// begin Say ( JMM , D9c-JMM-1 ) ;
29436: LD_EXP 39
29440: PPUSH
29441: LD_STRING D9c-JMM-1
29443: PPUSH
29444: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29448: LD_EXP 74
29452: PPUSH
29453: LD_STRING D9c-Roth-1
29455: PPUSH
29456: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29460: LD_EXP 39
29464: PPUSH
29465: LD_STRING D9c-JMM-2
29467: PPUSH
29468: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29472: LD_EXP 74
29476: PPUSH
29477: LD_STRING D9c-Roth-2
29479: PPUSH
29480: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29484: LD_EXP 39
29488: PPUSH
29489: LD_STRING D9c-JMM-3
29491: PPUSH
29492: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29496: LD_EXP 74
29500: PPUSH
29501: LD_STRING D9c-Roth-3
29503: PPUSH
29504: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29508: LD_EXP 74
29512: PPUSH
29513: LD_STRING D9cont-Roth-1
29515: PPUSH
29516: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29520: LD_EXP 39
29524: PPUSH
29525: LD_STRING D9cont-JMM-1
29527: PPUSH
29528: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29532: LD_EXP 74
29536: PPUSH
29537: LD_STRING D9cont-Roth-2
29539: PPUSH
29540: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29544: LD_EXP 39
29548: PPUSH
29549: LD_STRING D9cont-JMM-2
29551: PPUSH
29552: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29556: LD_EXP 74
29560: PPUSH
29561: LD_STRING D9cont-Roth-3
29563: PPUSH
29564: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29568: LD_EXP 39
29572: PPUSH
29573: LD_STRING D9cont-JMM-3
29575: PPUSH
29576: CALL_OW 88
// DialogueOff ;
29580: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29584: LD_STRING M3
29586: PPUSH
29587: CALL_OW 337
// allianceActive := true ;
29591: LD_ADDR_EXP 31
29595: PUSH
29596: LD_INT 1
29598: ST_TO_ADDR
// end ;
29599: PPOPN 1
29601: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
29602: LD_INT 1
29604: PPUSH
29605: LD_INT 126
29607: PPUSH
29608: CALL_OW 292
29612: PUSH
29613: LD_EXP 64
29617: PPUSH
29618: CALL_OW 310
29622: AND
29623: IFFALSE 29703
29625: GO 29627
29627: DISABLE
29628: LD_INT 0
29630: PPUSH
// begin ComExitBuilding ( Platonov ) ;
29631: LD_EXP 64
29635: PPUSH
29636: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
29640: LD_ADDR_VAR 0 1
29644: PUSH
29645: LD_INT 4
29647: PPUSH
29648: LD_INT 22
29650: PUSH
29651: LD_INT 1
29653: PUSH
29654: EMPTY
29655: LIST
29656: LIST
29657: PPUSH
29658: CALL_OW 70
29662: PPUSH
29663: LD_EXP 64
29667: PPUSH
29668: CALL_OW 74
29672: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
29673: LD_EXP 64
29677: PPUSH
29678: LD_VAR 0 1
29682: PUSH
29683: LD_INT 1
29685: ARRAY
29686: PPUSH
29687: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
29691: LD_EXP 64
29695: PPUSH
29696: LD_STRING D18-Pla-1
29698: PPUSH
29699: CALL_OW 88
// end ;
29703: PPOPN 1
29705: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29706: LD_EXP 64
29710: PPUSH
29711: CALL_OW 301
29715: PUSH
29716: LD_EXP 67
29720: PPUSH
29721: CALL_OW 301
29725: AND
29726: PUSH
29727: LD_INT 22
29729: PUSH
29730: LD_INT 3
29732: PUSH
29733: EMPTY
29734: LIST
29735: LIST
29736: PUSH
29737: LD_INT 21
29739: PUSH
29740: LD_INT 1
29742: PUSH
29743: EMPTY
29744: LIST
29745: LIST
29746: PUSH
29747: LD_INT 50
29749: PUSH
29750: EMPTY
29751: LIST
29752: PUSH
29753: EMPTY
29754: LIST
29755: LIST
29756: LIST
29757: PPUSH
29758: CALL_OW 69
29762: PUSH
29763: LD_INT 7
29765: PUSH
29766: LD_INT 8
29768: PUSH
29769: LD_INT 9
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: LIST
29776: PUSH
29777: LD_OWVAR 67
29781: ARRAY
29782: LESS
29783: AND
29784: IFFALSE 30555
29786: GO 29788
29788: DISABLE
29789: LD_INT 0
29791: PPUSH
29792: PPUSH
29793: PPUSH
29794: PPUSH
// begin MC_Kill ( 1 ) ;
29795: LD_INT 1
29797: PPUSH
29798: CALL 35349 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29802: LD_INT 1
29804: PPUSH
29805: LD_INT 3
29807: PPUSH
29808: LD_INT 1
29810: PPUSH
29811: LD_INT 1
29813: PPUSH
29814: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29818: LD_ADDR_VAR 0 1
29822: PUSH
29823: LD_INT 22
29825: PUSH
29826: LD_INT 3
29828: PUSH
29829: EMPTY
29830: LIST
29831: LIST
29832: PUSH
29833: LD_INT 21
29835: PUSH
29836: LD_INT 1
29838: PUSH
29839: EMPTY
29840: LIST
29841: LIST
29842: PUSH
29843: LD_INT 24
29845: PUSH
29846: LD_INT 900
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: LIST
29857: PPUSH
29858: CALL_OW 69
29862: PUSH
29863: FOR_IN
29864: IFFALSE 29895
// if GetSex ( i ) = sex_male then
29866: LD_VAR 0 1
29870: PPUSH
29871: CALL_OW 258
29875: PUSH
29876: LD_INT 1
29878: EQUAL
29879: IFFALSE 29893
// begin tmp = i ;
29881: LD_ADDR_VAR 0 2
29885: PUSH
29886: LD_VAR 0 1
29890: ST_TO_ADDR
// break ;
29891: GO 29895
// end ;
29893: GO 29863
29895: POP
29896: POP
// if tmp = 0 then
29897: LD_VAR 0 2
29901: PUSH
29902: LD_INT 0
29904: EQUAL
29905: IFFALSE 29959
// begin uc_side = 3 ;
29907: LD_ADDR_OWVAR 20
29911: PUSH
29912: LD_INT 3
29914: ST_TO_ADDR
// uc_nation = 3 ;
29915: LD_ADDR_OWVAR 21
29919: PUSH
29920: LD_INT 3
29922: ST_TO_ADDR
// hc_name =  ;
29923: LD_ADDR_OWVAR 26
29927: PUSH
29928: LD_STRING 
29930: ST_TO_ADDR
// hc_gallery =  ;
29931: LD_ADDR_OWVAR 33
29935: PUSH
29936: LD_STRING 
29938: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29939: LD_INT 1
29941: PPUSH
29942: LD_INT 10
29944: PPUSH
29945: CALL_OW 381
// tmp = CreateHuman ;
29949: LD_ADDR_VAR 0 2
29953: PUSH
29954: CALL_OW 44
29958: ST_TO_ADDR
// end ; DialogueOn ;
29959: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29963: LD_VAR 0 2
29967: PPUSH
29968: LD_STRING DSurrenderRussians-RSol1-1a
29970: PPUSH
29971: CALL_OW 94
// DialogueOff ;
29975: CALL_OW 7
// russianDestroyed := true ;
29979: LD_ADDR_EXP 21
29983: PUSH
29984: LD_INT 1
29986: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29987: LD_INT 22
29989: PUSH
29990: LD_INT 3
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: PUSH
29997: LD_INT 21
29999: PUSH
30000: LD_INT 1
30002: PUSH
30003: EMPTY
30004: LIST
30005: LIST
30006: PUSH
30007: EMPTY
30008: LIST
30009: LIST
30010: PPUSH
30011: CALL_OW 69
30015: PPUSH
30016: CALL_OW 122
// wait ( 0 0$1 ) ;
30020: LD_INT 35
30022: PPUSH
30023: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
30027: LD_INT 22
30029: PUSH
30030: LD_INT 3
30032: PUSH
30033: EMPTY
30034: LIST
30035: LIST
30036: PUSH
30037: LD_INT 21
30039: PUSH
30040: LD_INT 1
30042: PUSH
30043: EMPTY
30044: LIST
30045: LIST
30046: PUSH
30047: EMPTY
30048: LIST
30049: LIST
30050: PPUSH
30051: CALL_OW 69
30055: PPUSH
30056: LD_INT 25
30058: PPUSH
30059: CALL_OW 173
// wait ( 0 0$10 ) ;
30063: LD_INT 350
30065: PPUSH
30066: CALL_OW 67
// PrepareOmarInvasion ;
30070: CALL 13903 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
30074: LD_ADDR_VAR 0 2
30078: PUSH
30079: LD_EXP 92
30083: PPUSH
30084: CALL_OW 250
30088: PUSH
30089: LD_EXP 92
30093: PPUSH
30094: CALL_OW 251
30098: PUSH
30099: EMPTY
30100: LIST
30101: LIST
30102: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
30103: LD_VAR 0 2
30107: PUSH
30108: LD_INT 1
30110: ARRAY
30111: PPUSH
30112: LD_VAR 0 2
30116: PUSH
30117: LD_INT 2
30119: ARRAY
30120: PPUSH
30121: LD_INT 1
30123: PPUSH
30124: LD_INT 8
30126: NEG
30127: PPUSH
30128: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
30132: LD_EXP 92
30136: PPUSH
30137: CALL_OW 87
// DialogueOn ;
30141: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
30145: LD_EXP 39
30149: PPUSH
30150: LD_STRING D19-JMM-1
30152: PPUSH
30153: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
30157: LD_ADDR_VAR 0 3
30161: PUSH
30162: LD_INT 22
30164: PUSH
30165: LD_INT 1
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: PUSH
30172: LD_INT 26
30174: PUSH
30175: LD_INT 1
30177: PUSH
30178: EMPTY
30179: LIST
30180: LIST
30181: PUSH
30182: LD_INT 2
30184: PUSH
30185: LD_INT 25
30187: PUSH
30188: LD_INT 1
30190: PUSH
30191: EMPTY
30192: LIST
30193: LIST
30194: PUSH
30195: LD_INT 25
30197: PUSH
30198: LD_INT 2
30200: PUSH
30201: EMPTY
30202: LIST
30203: LIST
30204: PUSH
30205: LD_INT 25
30207: PUSH
30208: LD_INT 3
30210: PUSH
30211: EMPTY
30212: LIST
30213: LIST
30214: PUSH
30215: LD_INT 25
30217: PUSH
30218: LD_INT 4
30220: PUSH
30221: EMPTY
30222: LIST
30223: LIST
30224: PUSH
30225: LD_INT 25
30227: PUSH
30228: LD_INT 5
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 25
30237: PUSH
30238: LD_INT 8
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: LIST
30249: LIST
30250: LIST
30251: LIST
30252: LIST
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: LIST
30258: PPUSH
30259: CALL_OW 69
30263: PUSH
30264: LD_EXP 39
30268: PUSH
30269: LD_EXP 40
30273: PUSH
30274: LD_EXP 41
30278: PUSH
30279: LD_EXP 42
30283: PUSH
30284: LD_EXP 43
30288: PUSH
30289: LD_EXP 44
30293: PUSH
30294: LD_EXP 45
30298: PUSH
30299: LD_EXP 46
30303: PUSH
30304: LD_EXP 47
30308: PUSH
30309: LD_EXP 48
30313: PUSH
30314: LD_EXP 49
30318: PUSH
30319: LD_EXP 50
30323: PUSH
30324: LD_EXP 51
30328: PUSH
30329: LD_EXP 52
30333: PUSH
30334: LD_EXP 53
30338: PUSH
30339: LD_EXP 54
30343: PUSH
30344: LD_EXP 55
30348: PUSH
30349: EMPTY
30350: LIST
30351: LIST
30352: LIST
30353: LIST
30354: LIST
30355: LIST
30356: LIST
30357: LIST
30358: LIST
30359: LIST
30360: LIST
30361: LIST
30362: LIST
30363: LIST
30364: LIST
30365: LIST
30366: LIST
30367: DIFF
30368: ST_TO_ADDR
// if tmp2 then
30369: LD_VAR 0 3
30373: IFFALSE 30391
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30375: LD_VAR 0 3
30379: PUSH
30380: LD_INT 1
30382: ARRAY
30383: PPUSH
30384: LD_STRING D19-Sol1-1
30386: PPUSH
30387: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30391: LD_EXP 39
30395: PPUSH
30396: LD_STRING D19-JMM-2
30398: PPUSH
30399: CALL_OW 88
// DialogueOff ;
30403: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30407: LD_VAR 0 2
30411: PUSH
30412: LD_INT 1
30414: ARRAY
30415: PPUSH
30416: LD_VAR 0 2
30420: PUSH
30421: LD_INT 2
30423: ARRAY
30424: PPUSH
30425: LD_INT 1
30427: PPUSH
30428: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30432: LD_STRING M5
30434: PPUSH
30435: CALL_OW 337
// omarOnMotherLode := false ;
30439: LD_ADDR_VAR 0 4
30443: PUSH
30444: LD_INT 0
30446: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30447: LD_INT 35
30449: PPUSH
30450: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30454: LD_EXP 92
30458: PPUSH
30459: LD_INT 215
30461: PPUSH
30462: LD_INT 100
30464: PPUSH
30465: CALL_OW 297
30469: PUSH
30470: LD_INT 10
30472: LESS
30473: PUSH
30474: LD_VAR 0 4
30478: NOT
30479: AND
30480: IFFALSE 30514
// begin omarOnMotherLode := true ;
30482: LD_ADDR_VAR 0 4
30486: PUSH
30487: LD_INT 1
30489: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30490: LD_EXP 39
30494: PPUSH
30495: LD_STRING D19b-JMM-1
30497: PPUSH
30498: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30502: LD_EXP 92
30506: PPUSH
30507: LD_STRING DOmarContam-Omar-1
30509: PPUSH
30510: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30514: LD_EXP 92
30518: PPUSH
30519: CALL_OW 301
30523: IFFALSE 30447
// Say ( JMM , D19a-JMM-1 ) ;
30525: LD_EXP 39
30529: PPUSH
30530: LD_STRING D19a-JMM-1
30532: PPUSH
30533: CALL_OW 88
// if Heike then
30537: LD_EXP 93
30541: IFFALSE 30555
// Say ( Heike , D19a-Hke-1 ) ;
30543: LD_EXP 93
30547: PPUSH
30548: LD_STRING D19a-Hke-1
30550: PPUSH
30551: CALL_OW 88
// end ;
30555: PPOPN 4
30557: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30558: LD_INT 22
30560: PUSH
30561: LD_INT 3
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: PUSH
30568: LD_INT 21
30570: PUSH
30571: LD_INT 1
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PPUSH
30582: CALL_OW 69
30586: PUSH
30587: LD_EXP 21
30591: AND
30592: IFFALSE 30660
30594: GO 30596
30596: DISABLE
30597: LD_INT 0
30599: PPUSH
30600: PPUSH
// begin enable ;
30601: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30602: LD_ADDR_VAR 0 2
30606: PUSH
30607: LD_INT 25
30609: PPUSH
30610: LD_INT 22
30612: PUSH
30613: LD_INT 3
30615: PUSH
30616: EMPTY
30617: LIST
30618: LIST
30619: PPUSH
30620: CALL_OW 70
30624: ST_TO_ADDR
// if not tmp then
30625: LD_VAR 0 2
30629: NOT
30630: IFFALSE 30634
// exit ;
30632: GO 30660
// for i in tmp do
30634: LD_ADDR_VAR 0 1
30638: PUSH
30639: LD_VAR 0 2
30643: PUSH
30644: FOR_IN
30645: IFFALSE 30658
// RemoveUnit ( i ) ;
30647: LD_VAR 0 1
30651: PPUSH
30652: CALL_OW 64
30656: GO 30644
30658: POP
30659: POP
// end ;
30660: PPOPN 2
30662: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30663: LD_INT 22
30665: PUSH
30666: LD_INT 7
30668: PUSH
30669: EMPTY
30670: LIST
30671: LIST
30672: PUSH
30673: LD_INT 21
30675: PUSH
30676: LD_INT 1
30678: PUSH
30679: EMPTY
30680: LIST
30681: LIST
30682: PUSH
30683: EMPTY
30684: LIST
30685: LIST
30686: PPUSH
30687: CALL_OW 69
30691: PUSH
30692: LD_INT 6
30694: LESS
30695: IFFALSE 31163
30697: GO 30699
30699: DISABLE
30700: LD_INT 0
30702: PPUSH
30703: PPUSH
// begin MC_Kill ( 1 ) ;
30704: LD_INT 1
30706: PPUSH
30707: CALL 35349 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30711: LD_INT 7
30713: PPUSH
30714: LD_INT 1
30716: PPUSH
30717: LD_INT 1
30719: PPUSH
30720: LD_INT 1
30722: PPUSH
30723: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30727: LD_ADDR_VAR 0 1
30731: PUSH
30732: LD_INT 22
30734: PUSH
30735: LD_INT 7
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: PUSH
30742: LD_INT 26
30744: PUSH
30745: LD_INT 1
30747: PUSH
30748: EMPTY
30749: LIST
30750: LIST
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: PPUSH
30756: CALL_OW 69
30760: PUSH
30761: LD_EXP 74
30765: DIFF
30766: ST_TO_ADDR
// if tmp then
30767: LD_VAR 0 1
30771: IFFALSE 30789
// tmp := tmp [ 1 ] else
30773: LD_ADDR_VAR 0 1
30777: PUSH
30778: LD_VAR 0 1
30782: PUSH
30783: LD_INT 1
30785: ARRAY
30786: ST_TO_ADDR
30787: GO 30825
// begin uc_side := 7 ;
30789: LD_ADDR_OWVAR 20
30793: PUSH
30794: LD_INT 7
30796: ST_TO_ADDR
// uc_nation := 1 ;
30797: LD_ADDR_OWVAR 21
30801: PUSH
30802: LD_INT 1
30804: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30805: LD_INT 1
30807: PPUSH
30808: LD_INT 8
30810: PPUSH
30811: CALL_OW 384
// tmp := CreateHuman ;
30815: LD_ADDR_VAR 0 1
30819: PUSH
30820: CALL_OW 44
30824: ST_TO_ADDR
// end ; DialogueOn ;
30825: CALL_OW 6
// if IsOK ( Roth ) then
30829: LD_EXP 74
30833: PPUSH
30834: CALL_OW 302
30838: IFFALSE 30852
// Say ( JMM , DAb-JMM-1 ) ;
30840: LD_EXP 39
30844: PPUSH
30845: LD_STRING DAb-JMM-1
30847: PPUSH
30848: CALL_OW 88
// if IsOK ( Roth ) then
30852: LD_EXP 74
30856: PPUSH
30857: CALL_OW 302
30861: IFFALSE 30885
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30863: LD_EXP 74
30867: PPUSH
30868: LD_STRING DSurrenderAlliance-Roth-1
30870: PPUSH
30871: CALL_OW 88
// RothCaptured := true ;
30875: LD_ADDR_EXP 33
30879: PUSH
30880: LD_INT 1
30882: ST_TO_ADDR
// end else
30883: GO 30897
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30885: LD_VAR 0 1
30889: PPUSH
30890: LD_STRING DSurrenderAlliance-Sci1-1
30892: PPUSH
30893: CALL_OW 88
// DialogueOff ;
30897: CALL_OW 7
// allianceDestroyed := true ;
30901: LD_ADDR_EXP 23
30905: PUSH
30906: LD_INT 1
30908: ST_TO_ADDR
// if capturedUnit = 0 then
30909: LD_EXP 34
30913: PUSH
30914: LD_INT 0
30916: EQUAL
30917: IFFALSE 30926
// SetAchievement ( ACH_ALLIANCE ) ;
30919: LD_STRING ACH_ALLIANCE
30921: PPUSH
30922: CALL_OW 543
// if trueAmericans then
30926: LD_EXP 35
30930: IFFALSE 31006
// begin if trueAmericans = 1 then
30932: LD_EXP 35
30936: PUSH
30937: LD_INT 1
30939: EQUAL
30940: IFFALSE 30956
// Say ( JMM , DAb-JMM-1a ) else
30942: LD_EXP 39
30946: PPUSH
30947: LD_STRING DAb-JMM-1a
30949: PPUSH
30950: CALL_OW 88
30954: GO 30968
// Say ( JMM , DAb-JMM-1b ) ;
30956: LD_EXP 39
30960: PPUSH
30961: LD_STRING DAb-JMM-1b
30963: PPUSH
30964: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30968: LD_EXP 35
30972: PPUSH
30973: CALL_OW 87
// for i in trueAmericans do
30977: LD_ADDR_VAR 0 2
30981: PUSH
30982: LD_EXP 35
30986: PUSH
30987: FOR_IN
30988: IFFALSE 31004
// SetSide ( i , 1 ) ;
30990: LD_VAR 0 2
30994: PPUSH
30995: LD_INT 1
30997: PPUSH
30998: CALL_OW 235
31002: GO 30987
31004: POP
31005: POP
// end ; repeat wait ( 0 0$1 ) ;
31006: LD_INT 35
31008: PPUSH
31009: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
31013: LD_ADDR_VAR 0 2
31017: PUSH
31018: LD_INT 22
31020: PUSH
31021: LD_INT 7
31023: PUSH
31024: EMPTY
31025: LIST
31026: LIST
31027: PUSH
31028: LD_INT 21
31030: PUSH
31031: LD_INT 1
31033: PUSH
31034: EMPTY
31035: LIST
31036: LIST
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PPUSH
31042: CALL_OW 69
31046: PUSH
31047: FOR_IN
31048: IFFALSE 31130
// begin if IsInUnit ( i ) then
31050: LD_VAR 0 2
31054: PPUSH
31055: CALL_OW 310
31059: IFFALSE 31070
// ComExitBuilding ( i ) ;
31061: LD_VAR 0 2
31065: PPUSH
31066: CALL_OW 122
// if IsDriver ( i ) then
31070: LD_VAR 0 2
31074: PPUSH
31075: CALL 98777 0 1
31079: IFFALSE 31090
// ComExitVehicle ( i ) ;
31081: LD_VAR 0 2
31085: PPUSH
31086: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
31090: LD_VAR 0 2
31094: PPUSH
31095: LD_INT 26
31097: PPUSH
31098: CALL_OW 308
31102: NOT
31103: IFFALSE 31119
// AddComMoveToArea ( i , allianceEscapeArea ) else
31105: LD_VAR 0 2
31109: PPUSH
31110: LD_INT 26
31112: PPUSH
31113: CALL_OW 173
31117: GO 31128
// RemoveUnit ( i ) ;
31119: LD_VAR 0 2
31123: PPUSH
31124: CALL_OW 64
// end ;
31128: GO 31047
31130: POP
31131: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
31132: LD_INT 22
31134: PUSH
31135: LD_INT 7
31137: PUSH
31138: EMPTY
31139: LIST
31140: LIST
31141: PUSH
31142: LD_INT 21
31144: PUSH
31145: LD_INT 1
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: PUSH
31152: EMPTY
31153: LIST
31154: LIST
31155: PPUSH
31156: CALL_OW 69
31160: NOT
31161: IFFALSE 31006
// end ;
31163: PPOPN 2
31165: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31166: LD_INT 0
31168: PPUSH
31169: PPUSH
// if not unit then
31170: LD_VAR 0 1
31174: NOT
31175: IFFALSE 31179
// exit ;
31177: GO 32677
// DoNotAttack ( 7 , unit ) ;
31179: LD_INT 7
31181: PPUSH
31182: LD_VAR 0 1
31186: PPUSH
31187: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31191: LD_VAR 0 1
31195: PPUSH
31196: LD_INT 260
31198: PPUSH
31199: LD_INT 235
31201: PPUSH
31202: LD_INT 3
31204: PPUSH
31205: LD_INT 1
31207: PPUSH
31208: CALL_OW 483
// SetSide ( unit , 4 ) ;
31212: LD_VAR 0 1
31216: PPUSH
31217: LD_INT 4
31219: PPUSH
31220: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31224: LD_ADDR_EXP 34
31228: PUSH
31229: LD_EXP 34
31233: PUSH
31234: LD_INT 1
31236: PLUS
31237: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31238: LD_INT 70
31240: PPUSH
31241: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31245: LD_INT 260
31247: PPUSH
31248: LD_INT 235
31250: PPUSH
31251: LD_INT 1
31253: PPUSH
31254: LD_INT 8
31256: NEG
31257: PPUSH
31258: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31262: LD_VAR 0 1
31266: PPUSH
31267: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31271: LD_VAR 0 1
31275: PPUSH
31276: LD_EXP 74
31280: PPUSH
31281: CALL_OW 119
// DialogueOn ;
31285: CALL_OW 6
// case unit of JMM :
31289: LD_VAR 0 1
31293: PUSH
31294: LD_EXP 39
31298: DOUBLE
31299: EQUAL
31300: IFTRUE 31304
31302: GO 31319
31304: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31305: LD_EXP 39
31309: PPUSH
31310: LD_STRING DA1-JMM-1
31312: PPUSH
31313: CALL_OW 91
31317: GO 31761
31319: LD_EXP 40
31323: DOUBLE
31324: EQUAL
31325: IFTRUE 31329
31327: GO 31344
31329: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31330: LD_EXP 40
31334: PPUSH
31335: LD_STRING DA1-Joan-1
31337: PPUSH
31338: CALL_OW 91
31342: GO 31761
31344: LD_EXP 42
31348: DOUBLE
31349: EQUAL
31350: IFTRUE 31354
31352: GO 31369
31354: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31355: LD_EXP 42
31359: PPUSH
31360: LD_STRING DA1-Lisa-1
31362: PPUSH
31363: CALL_OW 91
31367: GO 31761
31369: LD_EXP 43
31373: DOUBLE
31374: EQUAL
31375: IFTRUE 31379
31377: GO 31394
31379: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31380: LD_EXP 43
31384: PPUSH
31385: LD_STRING DA1-Don-1
31387: PPUSH
31388: CALL_OW 91
31392: GO 31761
31394: LD_EXP 50
31398: DOUBLE
31399: EQUAL
31400: IFTRUE 31404
31402: GO 31419
31404: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31405: LD_EXP 50
31409: PPUSH
31410: LD_STRING DA1-Corn-1
31412: PPUSH
31413: CALL_OW 91
31417: GO 31761
31419: LD_EXP 46
31423: DOUBLE
31424: EQUAL
31425: IFTRUE 31429
31427: GO 31444
31429: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31430: LD_EXP 46
31434: PPUSH
31435: LD_STRING DA1-Den-1
31437: PPUSH
31438: CALL_OW 91
31442: GO 31761
31444: LD_EXP 44
31448: DOUBLE
31449: EQUAL
31450: IFTRUE 31454
31452: GO 31469
31454: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31455: LD_EXP 44
31459: PPUSH
31460: LD_STRING DA1-Bobby-1
31462: PPUSH
31463: CALL_OW 91
31467: GO 31761
31469: LD_EXP 48
31473: DOUBLE
31474: EQUAL
31475: IFTRUE 31479
31477: GO 31494
31479: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31480: LD_EXP 48
31484: PPUSH
31485: LD_STRING DA1-Glad-1
31487: PPUSH
31488: CALL_OW 91
31492: GO 31761
31494: LD_EXP 45
31498: DOUBLE
31499: EQUAL
31500: IFTRUE 31504
31502: GO 31519
31504: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31505: LD_EXP 45
31509: PPUSH
31510: LD_STRING DA1-Cyrus-1
31512: PPUSH
31513: CALL_OW 91
31517: GO 31761
31519: LD_EXP 41
31523: DOUBLE
31524: EQUAL
31525: IFTRUE 31529
31527: GO 31544
31529: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31530: LD_EXP 41
31534: PPUSH
31535: LD_STRING DA1-Huck-1
31537: PPUSH
31538: CALL_OW 91
31542: GO 31761
31544: LD_EXP 55
31548: DOUBLE
31549: EQUAL
31550: IFTRUE 31554
31552: GO 31569
31554: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31555: LD_EXP 55
31559: PPUSH
31560: LD_STRING DA1-Huck-1
31562: PPUSH
31563: CALL_OW 91
31567: GO 31761
31569: LD_EXP 47
31573: DOUBLE
31574: EQUAL
31575: IFTRUE 31579
31577: GO 31594
31579: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31580: LD_EXP 47
31584: PPUSH
31585: LD_STRING DA1-Brown-1
31587: PPUSH
31588: CALL_OW 91
31592: GO 31761
31594: LD_EXP 51
31598: DOUBLE
31599: EQUAL
31600: IFTRUE 31604
31602: GO 31619
31604: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31605: LD_EXP 51
31609: PPUSH
31610: LD_STRING DA1-Gary-1
31612: PPUSH
31613: CALL_OW 91
31617: GO 31761
31619: LD_EXP 54
31623: DOUBLE
31624: EQUAL
31625: IFTRUE 31629
31627: GO 31644
31629: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31630: LD_EXP 54
31634: PPUSH
31635: LD_STRING DA1-Con-1
31637: PPUSH
31638: CALL_OW 91
31642: GO 31761
31644: LD_EXP 60
31648: DOUBLE
31649: EQUAL
31650: IFTRUE 31654
31652: GO 31669
31654: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31655: LD_EXP 60
31659: PPUSH
31660: LD_STRING DA1-Kurt-1
31662: PPUSH
31663: CALL_OW 91
31667: GO 31761
31669: LD_EXP 53
31673: DOUBLE
31674: EQUAL
31675: IFTRUE 31679
31677: GO 31694
31679: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31680: LD_EXP 53
31684: PPUSH
31685: LD_STRING DA1-Yam-1
31687: PPUSH
31688: CALL_OW 91
31692: GO 31761
31694: LD_EXP 52
31698: DOUBLE
31699: EQUAL
31700: IFTRUE 31704
31702: GO 31719
31704: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31705: LD_EXP 52
31709: PPUSH
31710: LD_STRING DA1-Frank-1
31712: PPUSH
31713: CALL_OW 91
31717: GO 31761
31719: POP
// begin if GetSex ( unit ) = sex_male then
31720: LD_VAR 0 1
31724: PPUSH
31725: CALL_OW 258
31729: PUSH
31730: LD_INT 1
31732: EQUAL
31733: IFFALSE 31749
// ForceSay ( unit , DA1-Sol1-1 ) else
31735: LD_VAR 0 1
31739: PPUSH
31740: LD_STRING DA1-Sol1-1
31742: PPUSH
31743: CALL_OW 91
31747: GO 31761
// ForceSay ( unit , DA1-FSol1-1 ) ;
31749: LD_VAR 0 1
31753: PPUSH
31754: LD_STRING DA1-FSol1-1
31756: PPUSH
31757: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31761: LD_EXP 74
31765: PPUSH
31766: LD_STRING DA-Roth-1
31768: PPUSH
31769: CALL_OW 88
// if capturedUnit = 1 then
31773: LD_EXP 34
31777: PUSH
31778: LD_INT 1
31780: EQUAL
31781: IFFALSE 31809
// begin Say ( Simms , DA-Sim-1 ) ;
31783: LD_EXP 75
31787: PPUSH
31788: LD_STRING DA-Sim-1
31790: PPUSH
31791: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31795: LD_EXP 74
31799: PPUSH
31800: LD_STRING DA-Roth-2
31802: PPUSH
31803: CALL_OW 88
// end else
31807: GO 31821
// Say ( Simms , DA-Sim-2 ) ;
31809: LD_EXP 75
31813: PPUSH
31814: LD_STRING DA-Sim-2
31816: PPUSH
31817: CALL_OW 88
// case unit of JMM :
31821: LD_VAR 0 1
31825: PUSH
31826: LD_EXP 39
31830: DOUBLE
31831: EQUAL
31832: IFTRUE 31836
31834: GO 31851
31836: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31837: LD_EXP 39
31841: PPUSH
31842: LD_STRING DA1-JMM-1a
31844: PPUSH
31845: CALL_OW 91
31849: GO 32358
31851: LD_EXP 40
31855: DOUBLE
31856: EQUAL
31857: IFTRUE 31861
31859: GO 31876
31861: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31862: LD_EXP 40
31866: PPUSH
31867: LD_STRING DA1-Joan-1a
31869: PPUSH
31870: CALL_OW 91
31874: GO 32358
31876: LD_EXP 42
31880: DOUBLE
31881: EQUAL
31882: IFTRUE 31886
31884: GO 31901
31886: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31887: LD_EXP 42
31891: PPUSH
31892: LD_STRING DA1-Lisa-1a
31894: PPUSH
31895: CALL_OW 91
31899: GO 32358
31901: LD_EXP 43
31905: DOUBLE
31906: EQUAL
31907: IFTRUE 31911
31909: GO 31926
31911: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31912: LD_EXP 43
31916: PPUSH
31917: LD_STRING DA1-Don-1a
31919: PPUSH
31920: CALL_OW 91
31924: GO 32358
31926: LD_EXP 50
31930: DOUBLE
31931: EQUAL
31932: IFTRUE 31936
31934: GO 31951
31936: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31937: LD_EXP 50
31941: PPUSH
31942: LD_STRING DA1-Corn-1a
31944: PPUSH
31945: CALL_OW 91
31949: GO 32358
31951: LD_EXP 46
31955: DOUBLE
31956: EQUAL
31957: IFTRUE 31961
31959: GO 31976
31961: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31962: LD_EXP 46
31966: PPUSH
31967: LD_STRING DA1-Den-1a
31969: PPUSH
31970: CALL_OW 91
31974: GO 32358
31976: LD_EXP 44
31980: DOUBLE
31981: EQUAL
31982: IFTRUE 31986
31984: GO 32001
31986: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31987: LD_EXP 44
31991: PPUSH
31992: LD_STRING DA1-Bobby-1a
31994: PPUSH
31995: CALL_OW 91
31999: GO 32358
32001: LD_EXP 48
32005: DOUBLE
32006: EQUAL
32007: IFTRUE 32011
32009: GO 32026
32011: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
32012: LD_EXP 48
32016: PPUSH
32017: LD_STRING DA1-Glad-1a
32019: PPUSH
32020: CALL_OW 91
32024: GO 32358
32026: LD_EXP 45
32030: DOUBLE
32031: EQUAL
32032: IFTRUE 32036
32034: GO 32051
32036: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
32037: LD_EXP 45
32041: PPUSH
32042: LD_STRING DA1-Cyrus-1a
32044: PPUSH
32045: CALL_OW 91
32049: GO 32358
32051: LD_EXP 41
32055: DOUBLE
32056: EQUAL
32057: IFTRUE 32061
32059: GO 32076
32061: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
32062: LD_EXP 41
32066: PPUSH
32067: LD_STRING DA1-Huck-1a
32069: PPUSH
32070: CALL_OW 91
32074: GO 32358
32076: LD_EXP 55
32080: DOUBLE
32081: EQUAL
32082: IFTRUE 32086
32084: GO 32101
32086: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
32087: LD_EXP 55
32091: PPUSH
32092: LD_STRING DA1-Huck-1a
32094: PPUSH
32095: CALL_OW 91
32099: GO 32358
32101: LD_EXP 47
32105: DOUBLE
32106: EQUAL
32107: IFTRUE 32111
32109: GO 32126
32111: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
32112: LD_EXP 47
32116: PPUSH
32117: LD_STRING DA1-Brown-1a
32119: PPUSH
32120: CALL_OW 91
32124: GO 32358
32126: LD_EXP 51
32130: DOUBLE
32131: EQUAL
32132: IFTRUE 32136
32134: GO 32151
32136: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
32137: LD_EXP 51
32141: PPUSH
32142: LD_STRING DA1-Gary-1a
32144: PPUSH
32145: CALL_OW 91
32149: GO 32358
32151: LD_EXP 54
32155: DOUBLE
32156: EQUAL
32157: IFTRUE 32161
32159: GO 32176
32161: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
32162: LD_EXP 54
32166: PPUSH
32167: LD_STRING DA1-Con-1a
32169: PPUSH
32170: CALL_OW 91
32174: GO 32358
32176: LD_EXP 60
32180: DOUBLE
32181: EQUAL
32182: IFTRUE 32186
32184: GO 32201
32186: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32187: LD_EXP 60
32191: PPUSH
32192: LD_STRING DA1-Kurt-1a
32194: PPUSH
32195: CALL_OW 91
32199: GO 32358
32201: LD_EXP 53
32205: DOUBLE
32206: EQUAL
32207: IFTRUE 32211
32209: GO 32226
32211: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32212: LD_EXP 53
32216: PPUSH
32217: LD_STRING DA1-Yam-1a
32219: PPUSH
32220: CALL_OW 91
32224: GO 32358
32226: LD_EXP 52
32230: DOUBLE
32231: EQUAL
32232: IFTRUE 32236
32234: GO 32251
32236: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32237: LD_EXP 52
32241: PPUSH
32242: LD_STRING DA1-Frank-1a
32244: PPUSH
32245: CALL_OW 91
32249: GO 32358
32251: POP
// begin join := rand ( 0 , 1 ) ;
32252: LD_ADDR_VAR 0 3
32256: PUSH
32257: LD_INT 0
32259: PPUSH
32260: LD_INT 1
32262: PPUSH
32263: CALL_OW 12
32267: ST_TO_ADDR
// if join then
32268: LD_VAR 0 3
32272: IFFALSE 32317
// begin if GetSex ( unit ) = sex_male then
32274: LD_VAR 0 1
32278: PPUSH
32279: CALL_OW 258
32283: PUSH
32284: LD_INT 1
32286: EQUAL
32287: IFFALSE 32303
// ForceSay ( unit , DA1-Sol1-1b ) else
32289: LD_VAR 0 1
32293: PPUSH
32294: LD_STRING DA1-Sol1-1b
32296: PPUSH
32297: CALL_OW 91
32301: GO 32315
// ForceSay ( unit , DA1-FSol1-1b ) ;
32303: LD_VAR 0 1
32307: PPUSH
32308: LD_STRING DA1-FSol1-1b
32310: PPUSH
32311: CALL_OW 91
// end else
32315: GO 32358
// begin if GetSex ( unit ) = sex_male then
32317: LD_VAR 0 1
32321: PPUSH
32322: CALL_OW 258
32326: PUSH
32327: LD_INT 1
32329: EQUAL
32330: IFFALSE 32346
// ForceSay ( unit , DA1-Sol1-1a ) else
32332: LD_VAR 0 1
32336: PPUSH
32337: LD_STRING DA1-Sol1-1a
32339: PPUSH
32340: CALL_OW 91
32344: GO 32358
// ForceSay ( unit , DA1-FSol1-1a ) ;
32346: LD_VAR 0 1
32350: PPUSH
32351: LD_STRING DA1-FSol1-1a
32353: PPUSH
32354: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32358: LD_VAR 0 1
32362: PUSH
32363: LD_EXP 39
32367: EQUAL
32368: IFFALSE 32379
// begin YouLost ( JMMCaptured ) ;
32370: LD_STRING JMMCaptured
32372: PPUSH
32373: CALL_OW 104
// exit ;
32377: GO 32677
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32379: LD_VAR 0 1
32383: PUSH
32384: LD_EXP 43
32388: PUSH
32389: LD_EXP 46
32393: PUSH
32394: LD_EXP 44
32398: PUSH
32399: LD_EXP 41
32403: PUSH
32404: LD_EXP 55
32408: PUSH
32409: LD_EXP 47
32413: PUSH
32414: LD_EXP 53
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: LIST
32423: LIST
32424: LIST
32425: LIST
32426: LIST
32427: IN
32428: PUSH
32429: LD_VAR 0 3
32433: OR
32434: IFFALSE 32533
// begin Say ( Roth , DA-Roth-3 ) ;
32436: LD_EXP 74
32440: PPUSH
32441: LD_STRING DA-Roth-3
32443: PPUSH
32444: CALL_OW 88
// SetSide ( unit , 7 ) ;
32448: LD_VAR 0 1
32452: PPUSH
32453: LD_INT 7
32455: PPUSH
32456: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32460: LD_ADDR_EXP 113
32464: PUSH
32465: LD_EXP 113
32469: PPUSH
32470: LD_INT 1
32472: PPUSH
32473: LD_EXP 113
32477: PUSH
32478: LD_INT 1
32480: ARRAY
32481: PUSH
32482: LD_VAR 0 1
32486: ADD
32487: PPUSH
32488: CALL_OW 1
32492: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32493: LD_INT 260
32495: PPUSH
32496: LD_INT 235
32498: PPUSH
32499: LD_INT 1
32501: PPUSH
32502: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32506: LD_VAR 0 1
32510: PPUSH
32511: LD_INT 1000
32513: PPUSH
32514: CALL_OW 234
// DialogueOff ;
32518: CALL_OW 7
// ComFree ( unit ) ;
32522: LD_VAR 0 1
32526: PPUSH
32527: CALL_OW 139
// end else
32531: GO 32614
// begin Say ( Roth , DA-Roth-3a ) ;
32533: LD_EXP 74
32537: PPUSH
32538: LD_STRING DA-Roth-3a
32540: PPUSH
32541: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32545: LD_ADDR_EXP 35
32549: PUSH
32550: LD_EXP 35
32554: PUSH
32555: LD_VAR 0 1
32559: ADD
32560: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32561: LD_INT 260
32563: PPUSH
32564: LD_INT 235
32566: PPUSH
32567: LD_INT 1
32569: PPUSH
32570: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32574: LD_VAR 0 1
32578: PPUSH
32579: LD_INT 1000
32581: PPUSH
32582: CALL_OW 234
// DialogueOff ;
32586: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32590: LD_VAR 0 1
32594: PPUSH
32595: LD_INT 272
32597: PPUSH
32598: LD_INT 254
32600: PPUSH
32601: CALL_OW 111
// AddComHold ( unit ) ;
32605: LD_VAR 0 1
32609: PPUSH
32610: CALL_OW 200
// end ; if capturedUnit = 1 then
32614: LD_EXP 34
32618: PUSH
32619: LD_INT 1
32621: EQUAL
32622: IFFALSE 32677
// begin DialogueOn ;
32624: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32628: LD_EXP 39
32632: PPUSH
32633: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32637: LD_EXP 39
32641: PPUSH
32642: LD_STRING DAa-JMM-1
32644: PPUSH
32645: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32649: LD_EXP 39
32653: PPUSH
32654: LD_STRING DAa-JMM-1a
32656: PPUSH
32657: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32661: LD_EXP 39
32665: PPUSH
32666: LD_STRING DAa-JMM-1b
32668: PPUSH
32669: CALL_OW 88
// DialogueOff ;
32673: CALL_OW 7
// end ; end ;
32677: LD_VAR 0 2
32681: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32682: LD_EXP 15
32686: PUSH
32687: LD_INT 13
32689: GREATEREQUAL
32690: PUSH
32691: LD_INT 22
32693: PUSH
32694: LD_INT 2
32696: PUSH
32697: EMPTY
32698: LIST
32699: LIST
32700: PUSH
32701: LD_INT 21
32703: PUSH
32704: LD_INT 1
32706: PUSH
32707: EMPTY
32708: LIST
32709: LIST
32710: PUSH
32711: EMPTY
32712: LIST
32713: LIST
32714: PPUSH
32715: CALL_OW 69
32719: PUSH
32720: LD_INT 0
32722: EQUAL
32723: AND
32724: PUSH
32725: LD_INT 22
32727: PUSH
32728: LD_INT 2
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 21
32737: PUSH
32738: LD_INT 2
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: PUSH
32745: LD_INT 50
32747: PUSH
32748: EMPTY
32749: LIST
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: LIST
32755: PPUSH
32756: CALL_OW 69
32760: PUSH
32761: LD_INT 0
32763: EQUAL
32764: AND
32765: PUSH
32766: LD_EXP 21
32770: AND
32771: PUSH
32772: LD_EXP 22
32776: AND
32777: PUSH
32778: LD_EXP 23
32782: AND
32783: IFFALSE 33425
32785: GO 32787
32787: DISABLE
32788: LD_INT 0
32790: PPUSH
32791: PPUSH
32792: PPUSH
// begin m1 := false ;
32793: LD_ADDR_VAR 0 1
32797: PUSH
32798: LD_INT 0
32800: ST_TO_ADDR
// m2 := false ;
32801: LD_ADDR_VAR 0 2
32805: PUSH
32806: LD_INT 0
32808: ST_TO_ADDR
// m3 := false ;
32809: LD_ADDR_VAR 0 3
32813: PUSH
32814: LD_INT 0
32816: ST_TO_ADDR
// if not bombExploded then
32817: LD_EXP 37
32821: NOT
32822: IFFALSE 32831
// SetAchievement ( ACH_SIBROCKET ) ;
32824: LD_STRING ACH_SIBROCKET
32826: PPUSH
32827: CALL_OW 543
// if tick <= 120 120$00 then
32831: LD_OWVAR 1
32835: PUSH
32836: LD_INT 252000
32838: LESSEQUAL
32839: IFFALSE 32855
// begin wait ( 3 ) ;
32841: LD_INT 3
32843: PPUSH
32844: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32848: LD_STRING ACH_ASPEED_15
32850: PPUSH
32851: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32855: LD_EXP 39
32859: PPUSH
32860: CALL_OW 87
// music_class := 5 ;
32864: LD_ADDR_OWVAR 72
32868: PUSH
32869: LD_INT 5
32871: ST_TO_ADDR
// music_nat := 5 ;
32872: LD_ADDR_OWVAR 71
32876: PUSH
32877: LD_INT 5
32879: ST_TO_ADDR
// DialogueOn ;
32880: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32884: LD_EXP 39
32888: PPUSH
32889: LD_STRING D20-JMM-1
32891: PPUSH
32892: CALL_OW 88
// if IsOK ( Joan ) then
32896: LD_EXP 40
32900: PPUSH
32901: CALL_OW 302
32905: IFFALSE 32919
// Say ( Joan , D20-Joan-1 ) ;
32907: LD_EXP 40
32911: PPUSH
32912: LD_STRING D20-Joan-1
32914: PPUSH
32915: CALL_OW 88
// if IsOk ( Lisa ) then
32919: LD_EXP 42
32923: PPUSH
32924: CALL_OW 302
32928: IFFALSE 32942
// Say ( Lisa , D20-Lisa-1 ) ;
32930: LD_EXP 42
32934: PPUSH
32935: LD_STRING D20-Lisa-1
32937: PPUSH
32938: CALL_OW 88
// if IsOk ( Donaldson ) then
32942: LD_EXP 43
32946: PPUSH
32947: CALL_OW 302
32951: IFFALSE 32965
// Say ( Donaldson , D20-Don-1 ) ;
32953: LD_EXP 43
32957: PPUSH
32958: LD_STRING D20-Don-1
32960: PPUSH
32961: CALL_OW 88
// if IsOK ( Cornel ) then
32965: LD_EXP 50
32969: PPUSH
32970: CALL_OW 302
32974: IFFALSE 32988
// Say ( Cornel , D20-Corn-1 ) ;
32976: LD_EXP 50
32980: PPUSH
32981: LD_STRING D20-Corn-1
32983: PPUSH
32984: CALL_OW 88
// if IsOk ( Denis ) then
32988: LD_EXP 46
32992: PPUSH
32993: CALL_OW 302
32997: IFFALSE 33011
// Say ( Denis , D20-Den-1 ) ;
32999: LD_EXP 46
33003: PPUSH
33004: LD_STRING D20-Den-1
33006: PPUSH
33007: CALL_OW 88
// if IsOk ( Bobby ) then
33011: LD_EXP 44
33015: PPUSH
33016: CALL_OW 302
33020: IFFALSE 33034
// Say ( Bobby , D20-Bobby-1 ) ;
33022: LD_EXP 44
33026: PPUSH
33027: LD_STRING D20-Bobby-1
33029: PPUSH
33030: CALL_OW 88
// if IsOk ( Gladstone ) then
33034: LD_EXP 48
33038: PPUSH
33039: CALL_OW 302
33043: IFFALSE 33057
// Say ( Gladstone , D20-Glad-1 ) ;
33045: LD_EXP 48
33049: PPUSH
33050: LD_STRING D20-Glad-1
33052: PPUSH
33053: CALL_OW 88
// if IsOk ( Cyrus ) then
33057: LD_EXP 45
33061: PPUSH
33062: CALL_OW 302
33066: IFFALSE 33080
// Say ( Cyrus , D20-Cyrus-1 ) ;
33068: LD_EXP 45
33072: PPUSH
33073: LD_STRING D20-Cyrus-1
33075: PPUSH
33076: CALL_OW 88
// if IsOk ( Stevens ) then
33080: LD_EXP 41
33084: PPUSH
33085: CALL_OW 302
33089: IFFALSE 33103
// Say ( Stevens , D20-Huck-1 ) ;
33091: LD_EXP 41
33095: PPUSH
33096: LD_STRING D20-Huck-1
33098: PPUSH
33099: CALL_OW 88
// if IsOk ( Brown ) then
33103: LD_EXP 47
33107: PPUSH
33108: CALL_OW 302
33112: IFFALSE 33126
// Say ( Brown , D20-Brown-1 ) ;
33114: LD_EXP 47
33118: PPUSH
33119: LD_STRING D20-Brown-1
33121: PPUSH
33122: CALL_OW 88
// if IsOk ( Gary ) then
33126: LD_EXP 51
33130: PPUSH
33131: CALL_OW 302
33135: IFFALSE 33149
// Say ( Gary , D20-Gary-1 ) ;
33137: LD_EXP 51
33141: PPUSH
33142: LD_STRING D20-Gary-1
33144: PPUSH
33145: CALL_OW 88
// if IsOk ( Connie ) then
33149: LD_EXP 54
33153: PPUSH
33154: CALL_OW 302
33158: IFFALSE 33172
// Say ( Connie , D20-Con-1 ) ;
33160: LD_EXP 54
33164: PPUSH
33165: LD_STRING D20-Con-1
33167: PPUSH
33168: CALL_OW 88
// if IsOk ( Kurt ) then
33172: LD_EXP 60
33176: PPUSH
33177: CALL_OW 302
33181: IFFALSE 33195
// Say ( Kurt , D20-Kurt-1 ) ;
33183: LD_EXP 60
33187: PPUSH
33188: LD_STRING D20-Kurt-1
33190: PPUSH
33191: CALL_OW 88
// if IsOk ( Kikuchi ) then
33195: LD_EXP 53
33199: PPUSH
33200: CALL_OW 302
33204: IFFALSE 33218
// Say ( Kikuchi , D20-Yam-1 ) ;
33206: LD_EXP 53
33210: PPUSH
33211: LD_STRING D20-Yam-1
33213: PPUSH
33214: CALL_OW 88
// if IsOk ( Frank ) then
33218: LD_EXP 52
33222: PPUSH
33223: CALL_OW 302
33227: IFFALSE 33241
// Say ( Frank , D20-Frank-1 ) ;
33229: LD_EXP 52
33233: PPUSH
33234: LD_STRING D20-Frank-1
33236: PPUSH
33237: CALL_OW 88
// DialogueOff ;
33241: CALL_OW 7
// if RothCaptured then
33245: LD_EXP 33
33249: IFFALSE 33271
// begin m1 := true ;
33251: LD_ADDR_VAR 0 1
33255: PUSH
33256: LD_INT 1
33258: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33259: LD_STRING Roth
33261: PPUSH
33262: LD_INT 1
33264: PPUSH
33265: CALL_OW 101
// end else
33269: GO 33282
// AddMedal ( Roth , - 1 ) ;
33271: LD_STRING Roth
33273: PPUSH
33274: LD_INT 1
33276: NEG
33277: PPUSH
33278: CALL_OW 101
// if behemothDestroyedBeforeFinish then
33282: LD_EXP 27
33286: IFFALSE 33308
// begin m2 := true ;
33288: LD_ADDR_VAR 0 2
33292: PUSH
33293: LD_INT 1
33295: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33296: LD_STRING Project
33298: PPUSH
33299: LD_INT 1
33301: PPUSH
33302: CALL_OW 101
// end else
33306: GO 33319
// AddMedal ( Project , - 1 ) ;
33308: LD_STRING Project
33310: PPUSH
33311: LD_INT 1
33313: NEG
33314: PPUSH
33315: CALL_OW 101
// if lostCounter = 0 then
33319: LD_EXP 32
33323: PUSH
33324: LD_INT 0
33326: EQUAL
33327: IFFALSE 33349
// begin m3 := true ;
33329: LD_ADDR_VAR 0 3
33333: PUSH
33334: LD_INT 1
33336: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33337: LD_STRING NoLosses
33339: PPUSH
33340: LD_INT 1
33342: PPUSH
33343: CALL_OW 101
// end else
33347: GO 33360
// AddMedal ( NoLosses , - 1 ) ;
33349: LD_STRING NoLosses
33351: PPUSH
33352: LD_INT 1
33354: NEG
33355: PPUSH
33356: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
33360: LD_VAR 0 1
33364: PUSH
33365: LD_VAR 0 2
33369: AND
33370: PUSH
33371: LD_VAR 0 3
33375: AND
33376: PUSH
33377: LD_OWVAR 67
33381: PUSH
33382: LD_INT 3
33384: EQUAL
33385: AND
33386: IFFALSE 33398
// SetAchievementEX ( ACH_AMER , 15 ) ;
33388: LD_STRING ACH_AMER
33390: PPUSH
33391: LD_INT 15
33393: PPUSH
33394: CALL_OW 564
// GiveMedals ( MAIN ) ;
33398: LD_STRING MAIN
33400: PPUSH
33401: CALL_OW 102
// music_class := 4 ;
33405: LD_ADDR_OWVAR 72
33409: PUSH
33410: LD_INT 4
33412: ST_TO_ADDR
// music_nat := 1 ;
33413: LD_ADDR_OWVAR 71
33417: PUSH
33418: LD_INT 1
33420: ST_TO_ADDR
// YouWin ;
33421: CALL_OW 103
// end ; end_of_file
33425: PPOPN 3
33427: END
// export function CustomEvent ( event ) ; begin
33428: LD_INT 0
33430: PPUSH
// end ;
33431: LD_VAR 0 2
33435: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33436: LD_VAR 0 1
33440: PUSH
33441: LD_INT 1
33443: EQUAL
33444: PUSH
33445: LD_VAR 0 2
33449: PUSH
33450: LD_INT 4
33452: EQUAL
33453: AND
33454: PUSH
33455: LD_EXP 58
33459: PPUSH
33460: CALL_OW 300
33464: AND
33465: IFFALSE 33481
// begin wait ( 0 0$2 ) ;
33467: LD_INT 70
33469: PPUSH
33470: CALL_OW 67
// YouLost ( Dismissed ) ;
33474: LD_STRING Dismissed
33476: PPUSH
33477: CALL_OW 104
// end ; end ;
33481: PPOPN 2
33483: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33484: LD_VAR 0 2
33488: PPUSH
33489: LD_VAR 0 3
33493: PPUSH
33494: LD_INT 18
33496: PPUSH
33497: CALL_OW 309
33501: IFFALSE 33510
// YouLost ( Motherlode3 ) ;
33503: LD_STRING Motherlode3
33505: PPUSH
33506: CALL_OW 104
// end ;
33510: PPOPN 3
33512: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33513: LD_EXP 27
33517: NOT
33518: IFFALSE 33528
// behemothDone := true ;
33520: LD_ADDR_EXP 28
33524: PUSH
33525: LD_INT 1
33527: ST_TO_ADDR
// end ;
33528: PPOPN 1
33530: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33531: LD_VAR 0 1
33535: PPUSH
33536: CALL_OW 255
33540: PUSH
33541: LD_INT 1
33543: EQUAL
33544: IFFALSE 33554
// bombExploded := true ;
33546: LD_ADDR_EXP 37
33550: PUSH
33551: LD_INT 1
33553: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33554: LD_VAR 0 1
33558: PPUSH
33559: CALL_OW 255
33563: PUSH
33564: LD_INT 1
33566: EQUAL
33567: PUSH
33568: LD_EXP 30
33572: AND
33573: PUSH
33574: LD_INT 22
33576: PUSH
33577: LD_INT 3
33579: PUSH
33580: EMPTY
33581: LIST
33582: LIST
33583: PUSH
33584: LD_INT 34
33586: PUSH
33587: LD_INT 48
33589: PUSH
33590: EMPTY
33591: LIST
33592: LIST
33593: PUSH
33594: EMPTY
33595: LIST
33596: LIST
33597: PPUSH
33598: CALL_OW 69
33602: AND
33603: PUSH
33604: LD_INT 22
33606: PUSH
33607: LD_INT 1
33609: PUSH
33610: EMPTY
33611: LIST
33612: LIST
33613: PUSH
33614: LD_INT 34
33616: PUSH
33617: LD_INT 8
33619: PUSH
33620: EMPTY
33621: LIST
33622: LIST
33623: PUSH
33624: EMPTY
33625: LIST
33626: LIST
33627: PPUSH
33628: CALL_OW 69
33632: NOT
33633: AND
33634: IFFALSE 33686
// begin wait ( 0 0$5 ) ;
33636: LD_INT 175
33638: PPUSH
33639: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33643: LD_INT 22
33645: PUSH
33646: LD_INT 3
33648: PUSH
33649: EMPTY
33650: LIST
33651: LIST
33652: PUSH
33653: LD_INT 34
33655: PUSH
33656: LD_INT 48
33658: PUSH
33659: EMPTY
33660: LIST
33661: LIST
33662: PUSH
33663: EMPTY
33664: LIST
33665: LIST
33666: PPUSH
33667: CALL_OW 69
33671: PUSH
33672: LD_INT 1
33674: ARRAY
33675: PPUSH
33676: LD_INT 60
33678: PPUSH
33679: LD_INT 95
33681: PPUSH
33682: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33686: LD_VAR 0 2
33690: PPUSH
33691: LD_VAR 0 3
33695: PPUSH
33696: LD_INT 18
33698: PPUSH
33699: CALL_OW 309
33703: IFFALSE 33763
// begin if GetSide ( unit ) = 1 then
33705: LD_VAR 0 1
33709: PPUSH
33710: CALL_OW 255
33714: PUSH
33715: LD_INT 1
33717: EQUAL
33718: IFFALSE 33734
// begin wait ( 0 0$6 ) ;
33720: LD_INT 210
33722: PPUSH
33723: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33727: LD_STRING Motherlode2
33729: PPUSH
33730: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
33734: LD_VAR 0 1
33738: PPUSH
33739: CALL_OW 255
33743: PUSH
33744: LD_INT 8
33746: EQUAL
33747: IFFALSE 33763
// begin wait ( 0 0$6 ) ;
33749: LD_INT 210
33751: PPUSH
33752: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33756: LD_STRING Motherlode1
33758: PPUSH
33759: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33763: LD_VAR 0 1
33767: PPUSH
33768: CALL_OW 255
33772: PUSH
33773: LD_INT 3
33775: EQUAL
33776: IFFALSE 33797
// begin wait ( 0 0$5 ) ;
33778: LD_INT 175
33780: PPUSH
33781: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33785: LD_EXP 64
33789: PPUSH
33790: LD_STRING D18-Pla-1
33792: PPUSH
33793: CALL_OW 94
// end ; end ;
33797: PPOPN 3
33799: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
33800: LD_VAR 0 1
33804: PUSH
33805: LD_INT 22
33807: PUSH
33808: LD_INT 1
33810: PUSH
33811: EMPTY
33812: LIST
33813: LIST
33814: PUSH
33815: LD_INT 21
33817: PUSH
33818: LD_INT 1
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: PUSH
33825: LD_INT 23
33827: PUSH
33828: LD_INT 1
33830: PUSH
33831: EMPTY
33832: LIST
33833: LIST
33834: PUSH
33835: EMPTY
33836: LIST
33837: LIST
33838: LIST
33839: PPUSH
33840: CALL_OW 69
33844: IN
33845: IFFALSE 33861
// lostCounter := lostCounter + 1 ;
33847: LD_ADDR_EXP 32
33851: PUSH
33852: LD_EXP 32
33856: PUSH
33857: LD_INT 1
33859: PLUS
33860: ST_TO_ADDR
// if un in behemothBuilders then
33861: LD_VAR 0 1
33865: PUSH
33866: LD_EXP 73
33870: IN
33871: IFFALSE 33891
// begin behemothBuilders := behemothBuilders diff un ;
33873: LD_ADDR_EXP 73
33877: PUSH
33878: LD_EXP 73
33882: PUSH
33883: LD_VAR 0 1
33887: DIFF
33888: ST_TO_ADDR
// exit ;
33889: GO 33921
// end ; if un = JMM then
33891: LD_VAR 0 1
33895: PUSH
33896: LD_EXP 39
33900: EQUAL
33901: IFFALSE 33912
// begin YouLost ( JMM ) ;
33903: LD_STRING JMM
33905: PPUSH
33906: CALL_OW 104
// exit ;
33910: GO 33921
// end ; MCE_UnitDestroyed ( un ) ;
33912: LD_VAR 0 1
33916: PPUSH
33917: CALL 62230 0 1
// end ;
33921: PPOPN 1
33923: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33924: LD_VAR 0 1
33928: PPUSH
33929: LD_VAR 0 2
33933: PPUSH
33934: CALL 64564 0 2
// end ;
33938: PPOPN 2
33940: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33941: LD_VAR 0 1
33945: PPUSH
33946: CALL 63632 0 1
// end ;
33950: PPOPN 1
33952: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33953: LD_VAR 0 1
33957: PUSH
33958: LD_INT 22
33960: PUSH
33961: LD_INT 8
33963: PUSH
33964: EMPTY
33965: LIST
33966: LIST
33967: PUSH
33968: LD_INT 30
33970: PUSH
33971: LD_INT 2
33973: PUSH
33974: EMPTY
33975: LIST
33976: LIST
33977: PUSH
33978: LD_INT 23
33980: PUSH
33981: LD_INT 3
33983: PUSH
33984: EMPTY
33985: LIST
33986: LIST
33987: PUSH
33988: EMPTY
33989: LIST
33990: LIST
33991: LIST
33992: PPUSH
33993: CALL_OW 69
33997: IN
33998: IFFALSE 34025
// begin ComUpgrade ( building ) ;
34000: LD_VAR 0 1
34004: PPUSH
34005: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
34009: LD_EXP 61
34013: PPUSH
34014: LD_VAR 0 1
34018: PPUSH
34019: CALL 72979 0 2
// exit ;
34023: GO 34034
// end ; MCE_BuildingComplete ( building ) ;
34025: LD_VAR 0 1
34029: PPUSH
34030: CALL 63873 0 1
// end ;
34034: PPOPN 1
34036: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
34037: LD_VAR 0 1
34041: PPUSH
34042: LD_VAR 0 2
34046: PPUSH
34047: CALL 61926 0 2
// end ;
34051: PPOPN 2
34053: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
34054: LD_VAR 0 1
34058: PPUSH
34059: LD_VAR 0 2
34063: PPUSH
34064: LD_VAR 0 3
34068: PPUSH
34069: LD_VAR 0 4
34073: PPUSH
34074: LD_VAR 0 5
34078: PPUSH
34079: CALL 61546 0 5
// end ;
34083: PPOPN 5
34085: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
34086: LD_VAR 0 1
34090: PPUSH
34091: LD_VAR 0 2
34095: PPUSH
34096: CALL 61136 0 2
// end ;
34100: PPOPN 2
34102: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
34103: LD_VAR 0 1
34107: PPUSH
34108: LD_VAR 0 2
34112: PPUSH
34113: LD_VAR 0 3
34117: PPUSH
34118: LD_VAR 0 4
34122: PPUSH
34123: CALL 60974 0 4
// end ;
34127: PPOPN 4
34129: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
34130: LD_VAR 0 1
34134: PPUSH
34135: LD_VAR 0 2
34139: PPUSH
34140: LD_VAR 0 3
34144: PPUSH
34145: CALL 60749 0 3
// end ;
34149: PPOPN 3
34151: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
34152: LD_VAR 0 1
34156: PPUSH
34157: LD_VAR 0 2
34161: PPUSH
34162: CALL 60634 0 2
// end ;
34166: PPOPN 2
34168: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34169: LD_VAR 0 1
34173: PPUSH
34174: LD_VAR 0 2
34178: PPUSH
34179: CALL 64825 0 2
// end ;
34183: PPOPN 2
34185: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34186: LD_VAR 0 1
34190: PPUSH
34191: CALL_OW 255
34195: PUSH
34196: LD_INT 4
34198: EQUAL
34199: PUSH
34200: LD_VAR 0 1
34204: PUSH
34205: LD_EXP 18
34209: PUSH
34210: LD_INT 1
34212: ARRAY
34213: IN
34214: AND
34215: PUSH
34216: LD_EXP 19
34220: AND
34221: IFFALSE 34240
// begin ComMoveXY ( driver , 61 , 93 ) ;
34223: LD_VAR 0 1
34227: PPUSH
34228: LD_INT 61
34230: PPUSH
34231: LD_INT 93
34233: PPUSH
34234: CALL_OW 111
// exit ;
34238: GO 34264
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34240: LD_VAR 0 1
34244: PPUSH
34245: LD_VAR 0 2
34249: PPUSH
34250: LD_VAR 0 3
34254: PPUSH
34255: LD_VAR 0 4
34259: PPUSH
34260: CALL 65041 0 4
// end ;
34264: PPOPN 4
34266: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34267: LD_VAR 0 1
34271: PPUSH
34272: LD_VAR 0 2
34276: PPUSH
34277: CALL 60443 0 2
// end ;
34281: PPOPN 2
34283: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34284: LD_VAR 0 1
34288: PPUSH
34289: CALL 115524 0 1
// end ; end_of_file
34293: PPOPN 1
34295: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34296: LD_EXP 15
34300: PUSH
34301: LD_INT 2
34303: EQUAL
34304: IFFALSE 34783
34306: GO 34308
34308: DISABLE
34309: LD_INT 0
34311: PPUSH
// begin time := 0 0$40 ;
34312: LD_ADDR_VAR 0 1
34316: PUSH
34317: LD_INT 1400
34319: ST_TO_ADDR
// repeat wait ( time ) ;
34320: LD_VAR 0 1
34324: PPUSH
34325: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34329: LD_INT 1
34331: PPUSH
34332: LD_INT 5
34334: PPUSH
34335: CALL_OW 12
34339: PPUSH
34340: LD_INT 106
34342: PPUSH
34343: LD_INT 150
34345: PPUSH
34346: LD_INT 19
34348: PPUSH
34349: LD_INT 1
34351: PPUSH
34352: CALL_OW 56
// time := time + 0 0$9 ;
34356: LD_ADDR_VAR 0 1
34360: PUSH
34361: LD_VAR 0 1
34365: PUSH
34366: LD_INT 315
34368: PLUS
34369: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34370: LD_INT 455
34372: PPUSH
34373: LD_INT 840
34375: PPUSH
34376: CALL_OW 12
34380: PPUSH
34381: CALL_OW 67
// if Prob ( 50 ) then
34385: LD_INT 50
34387: PPUSH
34388: CALL_OW 13
34392: IFFALSE 34421
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34394: LD_INT 1
34396: PPUSH
34397: LD_INT 5
34399: PPUSH
34400: CALL_OW 12
34404: PPUSH
34405: LD_INT 62
34407: PPUSH
34408: LD_INT 108
34410: PPUSH
34411: LD_INT 10
34413: PPUSH
34414: LD_INT 1
34416: PPUSH
34417: CALL_OW 56
// until missionStage > 4 ;
34421: LD_EXP 15
34425: PUSH
34426: LD_INT 4
34428: GREATER
34429: IFFALSE 34320
// repeat wait ( 0 0$1 ) ;
34431: LD_INT 35
34433: PPUSH
34434: CALL_OW 67
// until missionStage = 6 ;
34438: LD_EXP 15
34442: PUSH
34443: LD_INT 6
34445: EQUAL
34446: IFFALSE 34431
// time := 0 0$50 ;
34448: LD_ADDR_VAR 0 1
34452: PUSH
34453: LD_INT 1750
34455: ST_TO_ADDR
// repeat wait ( time ) ;
34456: LD_VAR 0 1
34460: PPUSH
34461: CALL_OW 67
// if Prob ( 50 ) then
34465: LD_INT 50
34467: PPUSH
34468: CALL_OW 13
34472: IFFALSE 34501
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34474: LD_INT 1
34476: PPUSH
34477: LD_INT 5
34479: PPUSH
34480: CALL_OW 12
34484: PPUSH
34485: LD_INT 106
34487: PPUSH
34488: LD_INT 89
34490: PPUSH
34491: LD_INT 45
34493: PPUSH
34494: LD_INT 1
34496: PPUSH
34497: CALL_OW 56
// time := time + 0 0$2 ;
34501: LD_ADDR_VAR 0 1
34505: PUSH
34506: LD_VAR 0 1
34510: PUSH
34511: LD_INT 70
34513: PLUS
34514: ST_TO_ADDR
// if Prob ( 30 ) then
34515: LD_INT 30
34517: PPUSH
34518: CALL_OW 13
34522: IFFALSE 34568
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34524: LD_INT 385
34526: PPUSH
34527: LD_INT 945
34529: PPUSH
34530: CALL_OW 12
34534: PPUSH
34535: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34539: LD_INT 1
34541: PPUSH
34542: LD_INT 5
34544: PPUSH
34545: CALL_OW 12
34549: PPUSH
34550: LD_INT 21
34552: PPUSH
34553: LD_INT 26
34555: PPUSH
34556: LD_INT 12
34558: PPUSH
34559: LD_INT 1
34561: PPUSH
34562: CALL_OW 56
// end else
34566: GO 34604
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34568: LD_INT 700
34570: PPUSH
34571: LD_INT 1225
34573: PPUSH
34574: CALL_OW 12
34578: PPUSH
34579: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34583: LD_INT 1
34585: PPUSH
34586: LD_INT 5
34588: PPUSH
34589: CALL_OW 12
34593: PPUSH
34594: LD_INT 16
34596: PPUSH
34597: LD_INT 1
34599: PPUSH
34600: CALL_OW 55
// end ; if Prob ( 50 ) then
34604: LD_INT 50
34606: PPUSH
34607: CALL_OW 13
34611: IFFALSE 34657
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34613: LD_INT 700
34615: PPUSH
34616: LD_INT 1050
34618: PPUSH
34619: CALL_OW 12
34623: PPUSH
34624: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34628: LD_INT 1
34630: PPUSH
34631: LD_INT 5
34633: PPUSH
34634: CALL_OW 12
34638: PPUSH
34639: LD_INT 181
34641: PPUSH
34642: LD_INT 218
34644: PPUSH
34645: LD_INT 16
34647: PPUSH
34648: LD_INT 1
34650: PPUSH
34651: CALL_OW 56
// end else
34655: GO 34693
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34657: LD_INT 350
34659: PPUSH
34660: LD_INT 525
34662: PPUSH
34663: CALL_OW 12
34667: PPUSH
34668: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34672: LD_INT 1
34674: PPUSH
34675: LD_INT 5
34677: PPUSH
34678: CALL_OW 12
34682: PPUSH
34683: LD_INT 15
34685: PPUSH
34686: LD_INT 1
34688: PPUSH
34689: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
34693: LD_INT 45
34695: PUSH
34696: LD_INT 32
34698: PUSH
34699: LD_INT 25
34701: PUSH
34702: EMPTY
34703: LIST
34704: LIST
34705: LIST
34706: PUSH
34707: LD_OWVAR 67
34711: ARRAY
34712: PPUSH
34713: CALL_OW 13
34717: IFFALSE 34761
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34719: LD_INT 175
34721: PPUSH
34722: LD_INT 315
34724: PPUSH
34725: CALL_OW 12
34729: PPUSH
34730: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34734: LD_INT 1
34736: PPUSH
34737: LD_INT 5
34739: PPUSH
34740: CALL_OW 12
34744: PPUSH
34745: LD_INT 103
34747: PPUSH
34748: LD_INT 140
34750: PPUSH
34751: LD_INT 20
34753: PPUSH
34754: LD_INT 1
34756: PPUSH
34757: CALL_OW 56
// end ; if time > 1 1$20 then
34761: LD_VAR 0 1
34765: PUSH
34766: LD_INT 2800
34768: GREATER
34769: IFFALSE 34779
// time := 0 0$30 ;
34771: LD_ADDR_VAR 0 1
34775: PUSH
34776: LD_INT 1050
34778: ST_TO_ADDR
// until false ;
34779: LD_INT 0
34781: IFFALSE 34456
// end ; end_of_file
34783: PPOPN 1
34785: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34786: LD_EXP 13
34790: PUSH
34791: LD_EXP 15
34795: PUSH
34796: LD_INT 6
34798: GREATEREQUAL
34799: AND
34800: IFFALSE 34837
34802: GO 34804
34804: DISABLE
// begin enable ;
34805: ENABLE
// missionTime := missionTime + 0 0$1 ;
34806: LD_ADDR_EXP 14
34810: PUSH
34811: LD_EXP 14
34815: PUSH
34816: LD_INT 35
34818: PLUS
34819: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34820: LD_ADDR_OWVAR 47
34824: PUSH
34825: LD_STRING #Am15-1
34827: PUSH
34828: LD_EXP 14
34832: PUSH
34833: EMPTY
34834: LIST
34835: LIST
34836: ST_TO_ADDR
// end ; end_of_file
34837: END
// export function InitNature ; begin
34838: LD_INT 0
34840: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34841: LD_INT 3
34843: PPUSH
34844: LD_INT 3
34846: PPUSH
34847: LD_INT 2
34849: PPUSH
34850: LD_INT 1
34852: PPUSH
34853: LD_INT 1
34855: PPUSH
34856: LD_INT 0
34858: PPUSH
34859: LD_INT 0
34861: PPUSH
34862: LD_INT 20
34864: PPUSH
34865: LD_INT 0
34867: PPUSH
34868: CALL 97797 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34872: LD_INT 2
34874: PPUSH
34875: LD_INT 1
34877: PPUSH
34878: LD_INT 1
34880: PPUSH
34881: LD_INT 1
34883: PPUSH
34884: LD_INT 1
34886: PPUSH
34887: LD_INT 0
34889: PPUSH
34890: LD_INT 0
34892: PPUSH
34893: LD_INT 21
34895: PPUSH
34896: LD_INT 0
34898: PPUSH
34899: CALL 97797 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34903: LD_INT 4
34905: PPUSH
34906: LD_INT 1
34908: PPUSH
34909: LD_INT 2
34911: PPUSH
34912: LD_INT 4
34914: PPUSH
34915: LD_INT 2
34917: PPUSH
34918: LD_INT 1
34920: PPUSH
34921: LD_INT 0
34923: PPUSH
34924: LD_INT 22
34926: PPUSH
34927: LD_INT 0
34929: PPUSH
34930: CALL 97797 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34934: LD_INT 0
34936: PPUSH
34937: LD_INT 0
34939: PPUSH
34940: LD_INT 0
34942: PPUSH
34943: LD_INT 0
34945: PPUSH
34946: LD_INT 0
34948: PPUSH
34949: LD_INT 0
34951: PPUSH
34952: LD_INT 9
34954: PPUSH
34955: LD_INT 0
34957: PPUSH
34958: LD_INT 23
34960: PPUSH
34961: CALL 97797 0 9
// end ; end_of_file
34965: LD_VAR 0 1
34969: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
34970: LD_INT 0
34972: PPUSH
// ar_miner := 81 ;
34973: LD_ADDR_EXP 102
34977: PUSH
34978: LD_INT 81
34980: ST_TO_ADDR
// ar_crane := 88 ;
34981: LD_ADDR_EXP 101
34985: PUSH
34986: LD_INT 88
34988: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34989: LD_ADDR_EXP 96
34993: PUSH
34994: LD_INT 89
34996: ST_TO_ADDR
// us_hack := 99 ;
34997: LD_ADDR_EXP 97
35001: PUSH
35002: LD_INT 99
35004: ST_TO_ADDR
// us_artillery := 97 ;
35005: LD_ADDR_EXP 98
35009: PUSH
35010: LD_INT 97
35012: ST_TO_ADDR
// ar_bio_bomb := 91 ;
35013: LD_ADDR_EXP 99
35017: PUSH
35018: LD_INT 91
35020: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
35021: LD_ADDR_EXP 100
35025: PUSH
35026: LD_INT 92
35028: ST_TO_ADDR
// ru_radar := 98 ;
35029: LD_ADDR_EXP 95
35033: PUSH
35034: LD_INT 98
35036: ST_TO_ADDR
// tech_Artillery := 80 ;
35037: LD_ADDR_EXP 103
35041: PUSH
35042: LD_INT 80
35044: ST_TO_ADDR
// tech_RadMat := 81 ;
35045: LD_ADDR_EXP 104
35049: PUSH
35050: LD_INT 81
35052: ST_TO_ADDR
// tech_BasicTools := 82 ;
35053: LD_ADDR_EXP 105
35057: PUSH
35058: LD_INT 82
35060: ST_TO_ADDR
// tech_Cargo := 83 ;
35061: LD_ADDR_EXP 106
35065: PUSH
35066: LD_INT 83
35068: ST_TO_ADDR
// tech_Track := 84 ;
35069: LD_ADDR_EXP 107
35073: PUSH
35074: LD_INT 84
35076: ST_TO_ADDR
// tech_Crane := 85 ;
35077: LD_ADDR_EXP 108
35081: PUSH
35082: LD_INT 85
35084: ST_TO_ADDR
// tech_Bulldozer := 86 ;
35085: LD_ADDR_EXP 109
35089: PUSH
35090: LD_INT 86
35092: ST_TO_ADDR
// tech_Hovercraft := 87 ;
35093: LD_ADDR_EXP 110
35097: PUSH
35098: LD_INT 87
35100: ST_TO_ADDR
// end ;
35101: LD_VAR 0 1
35105: RET
// every 1 do
35106: GO 35108
35108: DISABLE
// InitGlobalVariables ; end_of_file
35109: CALL 34970 0 0
35113: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
35114: LD_INT 0
35116: PPUSH
35117: PPUSH
// skirmish := false ;
35118: LD_ADDR_EXP 111
35122: PUSH
35123: LD_INT 0
35125: ST_TO_ADDR
// debug_mc := false ;
35126: LD_ADDR_EXP 112
35130: PUSH
35131: LD_INT 0
35133: ST_TO_ADDR
// mc_bases := [ ] ;
35134: LD_ADDR_EXP 113
35138: PUSH
35139: EMPTY
35140: ST_TO_ADDR
// mc_sides := [ ] ;
35141: LD_ADDR_EXP 139
35145: PUSH
35146: EMPTY
35147: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
35148: LD_ADDR_EXP 114
35152: PUSH
35153: EMPTY
35154: ST_TO_ADDR
// mc_building_repairs := [ ] ;
35155: LD_ADDR_EXP 115
35159: PUSH
35160: EMPTY
35161: ST_TO_ADDR
// mc_need_heal := [ ] ;
35162: LD_ADDR_EXP 116
35166: PUSH
35167: EMPTY
35168: ST_TO_ADDR
// mc_healers := [ ] ;
35169: LD_ADDR_EXP 117
35173: PUSH
35174: EMPTY
35175: ST_TO_ADDR
// mc_build_list := [ ] ;
35176: LD_ADDR_EXP 118
35180: PUSH
35181: EMPTY
35182: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
35183: LD_ADDR_EXP 145
35187: PUSH
35188: EMPTY
35189: ST_TO_ADDR
// mc_builders := [ ] ;
35190: LD_ADDR_EXP 119
35194: PUSH
35195: EMPTY
35196: ST_TO_ADDR
// mc_construct_list := [ ] ;
35197: LD_ADDR_EXP 120
35201: PUSH
35202: EMPTY
35203: ST_TO_ADDR
// mc_turret_list := [ ] ;
35204: LD_ADDR_EXP 121
35208: PUSH
35209: EMPTY
35210: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
35211: LD_ADDR_EXP 122
35215: PUSH
35216: EMPTY
35217: ST_TO_ADDR
// mc_miners := [ ] ;
35218: LD_ADDR_EXP 127
35222: PUSH
35223: EMPTY
35224: ST_TO_ADDR
// mc_mines := [ ] ;
35225: LD_ADDR_EXP 126
35229: PUSH
35230: EMPTY
35231: ST_TO_ADDR
// mc_minefields := [ ] ;
35232: LD_ADDR_EXP 128
35236: PUSH
35237: EMPTY
35238: ST_TO_ADDR
// mc_crates := [ ] ;
35239: LD_ADDR_EXP 129
35243: PUSH
35244: EMPTY
35245: ST_TO_ADDR
// mc_crates_collector := [ ] ;
35246: LD_ADDR_EXP 130
35250: PUSH
35251: EMPTY
35252: ST_TO_ADDR
// mc_crates_area := [ ] ;
35253: LD_ADDR_EXP 131
35257: PUSH
35258: EMPTY
35259: ST_TO_ADDR
// mc_vehicles := [ ] ;
35260: LD_ADDR_EXP 132
35264: PUSH
35265: EMPTY
35266: ST_TO_ADDR
// mc_attack := [ ] ;
35267: LD_ADDR_EXP 133
35271: PUSH
35272: EMPTY
35273: ST_TO_ADDR
// mc_produce := [ ] ;
35274: LD_ADDR_EXP 134
35278: PUSH
35279: EMPTY
35280: ST_TO_ADDR
// mc_defender := [ ] ;
35281: LD_ADDR_EXP 135
35285: PUSH
35286: EMPTY
35287: ST_TO_ADDR
// mc_parking := [ ] ;
35288: LD_ADDR_EXP 137
35292: PUSH
35293: EMPTY
35294: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35295: LD_ADDR_EXP 123
35299: PUSH
35300: EMPTY
35301: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35302: LD_ADDR_EXP 125
35306: PUSH
35307: EMPTY
35308: ST_TO_ADDR
// mc_scan := [ ] ;
35309: LD_ADDR_EXP 136
35313: PUSH
35314: EMPTY
35315: ST_TO_ADDR
// mc_scan_area := [ ] ;
35316: LD_ADDR_EXP 138
35320: PUSH
35321: EMPTY
35322: ST_TO_ADDR
// mc_tech := [ ] ;
35323: LD_ADDR_EXP 140
35327: PUSH
35328: EMPTY
35329: ST_TO_ADDR
// mc_class := [ ] ;
35330: LD_ADDR_EXP 154
35334: PUSH
35335: EMPTY
35336: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35337: LD_ADDR_EXP 155
35341: PUSH
35342: EMPTY
35343: ST_TO_ADDR
// end ;
35344: LD_VAR 0 1
35348: RET
// export function MC_Kill ( base ) ; begin
35349: LD_INT 0
35351: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35352: LD_ADDR_EXP 113
35356: PUSH
35357: LD_EXP 113
35361: PPUSH
35362: LD_VAR 0 1
35366: PPUSH
35367: EMPTY
35368: PPUSH
35369: CALL_OW 1
35373: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35374: LD_ADDR_EXP 114
35378: PUSH
35379: LD_EXP 114
35383: PPUSH
35384: LD_VAR 0 1
35388: PPUSH
35389: EMPTY
35390: PPUSH
35391: CALL_OW 1
35395: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35396: LD_ADDR_EXP 115
35400: PUSH
35401: LD_EXP 115
35405: PPUSH
35406: LD_VAR 0 1
35410: PPUSH
35411: EMPTY
35412: PPUSH
35413: CALL_OW 1
35417: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35418: LD_ADDR_EXP 116
35422: PUSH
35423: LD_EXP 116
35427: PPUSH
35428: LD_VAR 0 1
35432: PPUSH
35433: EMPTY
35434: PPUSH
35435: CALL_OW 1
35439: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35440: LD_ADDR_EXP 117
35444: PUSH
35445: LD_EXP 117
35449: PPUSH
35450: LD_VAR 0 1
35454: PPUSH
35455: EMPTY
35456: PPUSH
35457: CALL_OW 1
35461: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35462: LD_ADDR_EXP 118
35466: PUSH
35467: LD_EXP 118
35471: PPUSH
35472: LD_VAR 0 1
35476: PPUSH
35477: EMPTY
35478: PPUSH
35479: CALL_OW 1
35483: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35484: LD_ADDR_EXP 119
35488: PUSH
35489: LD_EXP 119
35493: PPUSH
35494: LD_VAR 0 1
35498: PPUSH
35499: EMPTY
35500: PPUSH
35501: CALL_OW 1
35505: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35506: LD_ADDR_EXP 120
35510: PUSH
35511: LD_EXP 120
35515: PPUSH
35516: LD_VAR 0 1
35520: PPUSH
35521: EMPTY
35522: PPUSH
35523: CALL_OW 1
35527: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35528: LD_ADDR_EXP 121
35532: PUSH
35533: LD_EXP 121
35537: PPUSH
35538: LD_VAR 0 1
35542: PPUSH
35543: EMPTY
35544: PPUSH
35545: CALL_OW 1
35549: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35550: LD_ADDR_EXP 122
35554: PUSH
35555: LD_EXP 122
35559: PPUSH
35560: LD_VAR 0 1
35564: PPUSH
35565: EMPTY
35566: PPUSH
35567: CALL_OW 1
35571: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35572: LD_ADDR_EXP 123
35576: PUSH
35577: LD_EXP 123
35581: PPUSH
35582: LD_VAR 0 1
35586: PPUSH
35587: EMPTY
35588: PPUSH
35589: CALL_OW 1
35593: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35594: LD_ADDR_EXP 124
35598: PUSH
35599: LD_EXP 124
35603: PPUSH
35604: LD_VAR 0 1
35608: PPUSH
35609: LD_INT 0
35611: PPUSH
35612: CALL_OW 1
35616: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35617: LD_ADDR_EXP 125
35621: PUSH
35622: LD_EXP 125
35626: PPUSH
35627: LD_VAR 0 1
35631: PPUSH
35632: EMPTY
35633: PPUSH
35634: CALL_OW 1
35638: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35639: LD_ADDR_EXP 126
35643: PUSH
35644: LD_EXP 126
35648: PPUSH
35649: LD_VAR 0 1
35653: PPUSH
35654: EMPTY
35655: PPUSH
35656: CALL_OW 1
35660: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35661: LD_ADDR_EXP 127
35665: PUSH
35666: LD_EXP 127
35670: PPUSH
35671: LD_VAR 0 1
35675: PPUSH
35676: EMPTY
35677: PPUSH
35678: CALL_OW 1
35682: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35683: LD_ADDR_EXP 128
35687: PUSH
35688: LD_EXP 128
35692: PPUSH
35693: LD_VAR 0 1
35697: PPUSH
35698: EMPTY
35699: PPUSH
35700: CALL_OW 1
35704: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35705: LD_ADDR_EXP 129
35709: PUSH
35710: LD_EXP 129
35714: PPUSH
35715: LD_VAR 0 1
35719: PPUSH
35720: EMPTY
35721: PPUSH
35722: CALL_OW 1
35726: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35727: LD_ADDR_EXP 130
35731: PUSH
35732: LD_EXP 130
35736: PPUSH
35737: LD_VAR 0 1
35741: PPUSH
35742: EMPTY
35743: PPUSH
35744: CALL_OW 1
35748: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35749: LD_ADDR_EXP 131
35753: PUSH
35754: LD_EXP 131
35758: PPUSH
35759: LD_VAR 0 1
35763: PPUSH
35764: EMPTY
35765: PPUSH
35766: CALL_OW 1
35770: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35771: LD_ADDR_EXP 132
35775: PUSH
35776: LD_EXP 132
35780: PPUSH
35781: LD_VAR 0 1
35785: PPUSH
35786: EMPTY
35787: PPUSH
35788: CALL_OW 1
35792: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35793: LD_ADDR_EXP 133
35797: PUSH
35798: LD_EXP 133
35802: PPUSH
35803: LD_VAR 0 1
35807: PPUSH
35808: EMPTY
35809: PPUSH
35810: CALL_OW 1
35814: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35815: LD_ADDR_EXP 134
35819: PUSH
35820: LD_EXP 134
35824: PPUSH
35825: LD_VAR 0 1
35829: PPUSH
35830: EMPTY
35831: PPUSH
35832: CALL_OW 1
35836: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35837: LD_ADDR_EXP 135
35841: PUSH
35842: LD_EXP 135
35846: PPUSH
35847: LD_VAR 0 1
35851: PPUSH
35852: EMPTY
35853: PPUSH
35854: CALL_OW 1
35858: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35859: LD_ADDR_EXP 136
35863: PUSH
35864: LD_EXP 136
35868: PPUSH
35869: LD_VAR 0 1
35873: PPUSH
35874: EMPTY
35875: PPUSH
35876: CALL_OW 1
35880: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35881: LD_ADDR_EXP 137
35885: PUSH
35886: LD_EXP 137
35890: PPUSH
35891: LD_VAR 0 1
35895: PPUSH
35896: EMPTY
35897: PPUSH
35898: CALL_OW 1
35902: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35903: LD_ADDR_EXP 138
35907: PUSH
35908: LD_EXP 138
35912: PPUSH
35913: LD_VAR 0 1
35917: PPUSH
35918: EMPTY
35919: PPUSH
35920: CALL_OW 1
35924: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35925: LD_ADDR_EXP 140
35929: PUSH
35930: LD_EXP 140
35934: PPUSH
35935: LD_VAR 0 1
35939: PPUSH
35940: EMPTY
35941: PPUSH
35942: CALL_OW 1
35946: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35947: LD_ADDR_EXP 142
35951: PUSH
35952: LD_EXP 142
35956: PPUSH
35957: LD_VAR 0 1
35961: PPUSH
35962: EMPTY
35963: PPUSH
35964: CALL_OW 1
35968: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35969: LD_ADDR_EXP 143
35973: PUSH
35974: LD_EXP 143
35978: PPUSH
35979: LD_VAR 0 1
35983: PPUSH
35984: EMPTY
35985: PPUSH
35986: CALL_OW 1
35990: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35991: LD_ADDR_EXP 144
35995: PUSH
35996: LD_EXP 144
36000: PPUSH
36001: LD_VAR 0 1
36005: PPUSH
36006: EMPTY
36007: PPUSH
36008: CALL_OW 1
36012: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36013: LD_ADDR_EXP 145
36017: PUSH
36018: LD_EXP 145
36022: PPUSH
36023: LD_VAR 0 1
36027: PPUSH
36028: EMPTY
36029: PPUSH
36030: CALL_OW 1
36034: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36035: LD_ADDR_EXP 146
36039: PUSH
36040: LD_EXP 146
36044: PPUSH
36045: LD_VAR 0 1
36049: PPUSH
36050: EMPTY
36051: PPUSH
36052: CALL_OW 1
36056: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36057: LD_ADDR_EXP 147
36061: PUSH
36062: LD_EXP 147
36066: PPUSH
36067: LD_VAR 0 1
36071: PPUSH
36072: EMPTY
36073: PPUSH
36074: CALL_OW 1
36078: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36079: LD_ADDR_EXP 148
36083: PUSH
36084: LD_EXP 148
36088: PPUSH
36089: LD_VAR 0 1
36093: PPUSH
36094: EMPTY
36095: PPUSH
36096: CALL_OW 1
36100: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36101: LD_ADDR_EXP 149
36105: PUSH
36106: LD_EXP 149
36110: PPUSH
36111: LD_VAR 0 1
36115: PPUSH
36116: EMPTY
36117: PPUSH
36118: CALL_OW 1
36122: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36123: LD_ADDR_EXP 150
36127: PUSH
36128: LD_EXP 150
36132: PPUSH
36133: LD_VAR 0 1
36137: PPUSH
36138: EMPTY
36139: PPUSH
36140: CALL_OW 1
36144: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36145: LD_ADDR_EXP 151
36149: PUSH
36150: LD_EXP 151
36154: PPUSH
36155: LD_VAR 0 1
36159: PPUSH
36160: EMPTY
36161: PPUSH
36162: CALL_OW 1
36166: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36167: LD_ADDR_EXP 152
36171: PUSH
36172: LD_EXP 152
36176: PPUSH
36177: LD_VAR 0 1
36181: PPUSH
36182: EMPTY
36183: PPUSH
36184: CALL_OW 1
36188: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36189: LD_ADDR_EXP 153
36193: PUSH
36194: LD_EXP 153
36198: PPUSH
36199: LD_VAR 0 1
36203: PPUSH
36204: EMPTY
36205: PPUSH
36206: CALL_OW 1
36210: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36211: LD_ADDR_EXP 154
36215: PUSH
36216: LD_EXP 154
36220: PPUSH
36221: LD_VAR 0 1
36225: PPUSH
36226: EMPTY
36227: PPUSH
36228: CALL_OW 1
36232: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36233: LD_ADDR_EXP 155
36237: PUSH
36238: LD_EXP 155
36242: PPUSH
36243: LD_VAR 0 1
36247: PPUSH
36248: LD_INT 0
36250: PPUSH
36251: CALL_OW 1
36255: ST_TO_ADDR
// end ;
36256: LD_VAR 0 2
36260: RET
// export function MC_Add ( side , units ) ; var base ; begin
36261: LD_INT 0
36263: PPUSH
36264: PPUSH
// base := mc_bases + 1 ;
36265: LD_ADDR_VAR 0 4
36269: PUSH
36270: LD_EXP 113
36274: PUSH
36275: LD_INT 1
36277: PLUS
36278: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36279: LD_ADDR_EXP 139
36283: PUSH
36284: LD_EXP 139
36288: PPUSH
36289: LD_VAR 0 4
36293: PPUSH
36294: LD_VAR 0 1
36298: PPUSH
36299: CALL_OW 1
36303: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36304: LD_ADDR_EXP 113
36308: PUSH
36309: LD_EXP 113
36313: PPUSH
36314: LD_VAR 0 4
36318: PPUSH
36319: LD_VAR 0 2
36323: PPUSH
36324: CALL_OW 1
36328: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36329: LD_ADDR_EXP 114
36333: PUSH
36334: LD_EXP 114
36338: PPUSH
36339: LD_VAR 0 4
36343: PPUSH
36344: EMPTY
36345: PPUSH
36346: CALL_OW 1
36350: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36351: LD_ADDR_EXP 115
36355: PUSH
36356: LD_EXP 115
36360: PPUSH
36361: LD_VAR 0 4
36365: PPUSH
36366: EMPTY
36367: PPUSH
36368: CALL_OW 1
36372: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36373: LD_ADDR_EXP 116
36377: PUSH
36378: LD_EXP 116
36382: PPUSH
36383: LD_VAR 0 4
36387: PPUSH
36388: EMPTY
36389: PPUSH
36390: CALL_OW 1
36394: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36395: LD_ADDR_EXP 117
36399: PUSH
36400: LD_EXP 117
36404: PPUSH
36405: LD_VAR 0 4
36409: PPUSH
36410: EMPTY
36411: PPUSH
36412: CALL_OW 1
36416: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36417: LD_ADDR_EXP 118
36421: PUSH
36422: LD_EXP 118
36426: PPUSH
36427: LD_VAR 0 4
36431: PPUSH
36432: EMPTY
36433: PPUSH
36434: CALL_OW 1
36438: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36439: LD_ADDR_EXP 119
36443: PUSH
36444: LD_EXP 119
36448: PPUSH
36449: LD_VAR 0 4
36453: PPUSH
36454: EMPTY
36455: PPUSH
36456: CALL_OW 1
36460: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36461: LD_ADDR_EXP 120
36465: PUSH
36466: LD_EXP 120
36470: PPUSH
36471: LD_VAR 0 4
36475: PPUSH
36476: EMPTY
36477: PPUSH
36478: CALL_OW 1
36482: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36483: LD_ADDR_EXP 121
36487: PUSH
36488: LD_EXP 121
36492: PPUSH
36493: LD_VAR 0 4
36497: PPUSH
36498: EMPTY
36499: PPUSH
36500: CALL_OW 1
36504: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36505: LD_ADDR_EXP 122
36509: PUSH
36510: LD_EXP 122
36514: PPUSH
36515: LD_VAR 0 4
36519: PPUSH
36520: EMPTY
36521: PPUSH
36522: CALL_OW 1
36526: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36527: LD_ADDR_EXP 123
36531: PUSH
36532: LD_EXP 123
36536: PPUSH
36537: LD_VAR 0 4
36541: PPUSH
36542: EMPTY
36543: PPUSH
36544: CALL_OW 1
36548: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36549: LD_ADDR_EXP 124
36553: PUSH
36554: LD_EXP 124
36558: PPUSH
36559: LD_VAR 0 4
36563: PPUSH
36564: LD_INT 0
36566: PPUSH
36567: CALL_OW 1
36571: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36572: LD_ADDR_EXP 125
36576: PUSH
36577: LD_EXP 125
36581: PPUSH
36582: LD_VAR 0 4
36586: PPUSH
36587: EMPTY
36588: PPUSH
36589: CALL_OW 1
36593: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36594: LD_ADDR_EXP 126
36598: PUSH
36599: LD_EXP 126
36603: PPUSH
36604: LD_VAR 0 4
36608: PPUSH
36609: EMPTY
36610: PPUSH
36611: CALL_OW 1
36615: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36616: LD_ADDR_EXP 127
36620: PUSH
36621: LD_EXP 127
36625: PPUSH
36626: LD_VAR 0 4
36630: PPUSH
36631: EMPTY
36632: PPUSH
36633: CALL_OW 1
36637: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36638: LD_ADDR_EXP 128
36642: PUSH
36643: LD_EXP 128
36647: PPUSH
36648: LD_VAR 0 4
36652: PPUSH
36653: EMPTY
36654: PPUSH
36655: CALL_OW 1
36659: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36660: LD_ADDR_EXP 129
36664: PUSH
36665: LD_EXP 129
36669: PPUSH
36670: LD_VAR 0 4
36674: PPUSH
36675: EMPTY
36676: PPUSH
36677: CALL_OW 1
36681: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36682: LD_ADDR_EXP 130
36686: PUSH
36687: LD_EXP 130
36691: PPUSH
36692: LD_VAR 0 4
36696: PPUSH
36697: EMPTY
36698: PPUSH
36699: CALL_OW 1
36703: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36704: LD_ADDR_EXP 131
36708: PUSH
36709: LD_EXP 131
36713: PPUSH
36714: LD_VAR 0 4
36718: PPUSH
36719: EMPTY
36720: PPUSH
36721: CALL_OW 1
36725: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36726: LD_ADDR_EXP 132
36730: PUSH
36731: LD_EXP 132
36735: PPUSH
36736: LD_VAR 0 4
36740: PPUSH
36741: EMPTY
36742: PPUSH
36743: CALL_OW 1
36747: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36748: LD_ADDR_EXP 133
36752: PUSH
36753: LD_EXP 133
36757: PPUSH
36758: LD_VAR 0 4
36762: PPUSH
36763: EMPTY
36764: PPUSH
36765: CALL_OW 1
36769: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36770: LD_ADDR_EXP 134
36774: PUSH
36775: LD_EXP 134
36779: PPUSH
36780: LD_VAR 0 4
36784: PPUSH
36785: EMPTY
36786: PPUSH
36787: CALL_OW 1
36791: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36792: LD_ADDR_EXP 135
36796: PUSH
36797: LD_EXP 135
36801: PPUSH
36802: LD_VAR 0 4
36806: PPUSH
36807: EMPTY
36808: PPUSH
36809: CALL_OW 1
36813: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36814: LD_ADDR_EXP 136
36818: PUSH
36819: LD_EXP 136
36823: PPUSH
36824: LD_VAR 0 4
36828: PPUSH
36829: EMPTY
36830: PPUSH
36831: CALL_OW 1
36835: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36836: LD_ADDR_EXP 137
36840: PUSH
36841: LD_EXP 137
36845: PPUSH
36846: LD_VAR 0 4
36850: PPUSH
36851: EMPTY
36852: PPUSH
36853: CALL_OW 1
36857: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36858: LD_ADDR_EXP 138
36862: PUSH
36863: LD_EXP 138
36867: PPUSH
36868: LD_VAR 0 4
36872: PPUSH
36873: EMPTY
36874: PPUSH
36875: CALL_OW 1
36879: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36880: LD_ADDR_EXP 140
36884: PUSH
36885: LD_EXP 140
36889: PPUSH
36890: LD_VAR 0 4
36894: PPUSH
36895: EMPTY
36896: PPUSH
36897: CALL_OW 1
36901: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36902: LD_ADDR_EXP 142
36906: PUSH
36907: LD_EXP 142
36911: PPUSH
36912: LD_VAR 0 4
36916: PPUSH
36917: EMPTY
36918: PPUSH
36919: CALL_OW 1
36923: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36924: LD_ADDR_EXP 143
36928: PUSH
36929: LD_EXP 143
36933: PPUSH
36934: LD_VAR 0 4
36938: PPUSH
36939: EMPTY
36940: PPUSH
36941: CALL_OW 1
36945: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36946: LD_ADDR_EXP 144
36950: PUSH
36951: LD_EXP 144
36955: PPUSH
36956: LD_VAR 0 4
36960: PPUSH
36961: EMPTY
36962: PPUSH
36963: CALL_OW 1
36967: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36968: LD_ADDR_EXP 145
36972: PUSH
36973: LD_EXP 145
36977: PPUSH
36978: LD_VAR 0 4
36982: PPUSH
36983: EMPTY
36984: PPUSH
36985: CALL_OW 1
36989: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36990: LD_ADDR_EXP 146
36994: PUSH
36995: LD_EXP 146
36999: PPUSH
37000: LD_VAR 0 4
37004: PPUSH
37005: EMPTY
37006: PPUSH
37007: CALL_OW 1
37011: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37012: LD_ADDR_EXP 147
37016: PUSH
37017: LD_EXP 147
37021: PPUSH
37022: LD_VAR 0 4
37026: PPUSH
37027: EMPTY
37028: PPUSH
37029: CALL_OW 1
37033: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37034: LD_ADDR_EXP 148
37038: PUSH
37039: LD_EXP 148
37043: PPUSH
37044: LD_VAR 0 4
37048: PPUSH
37049: EMPTY
37050: PPUSH
37051: CALL_OW 1
37055: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37056: LD_ADDR_EXP 149
37060: PUSH
37061: LD_EXP 149
37065: PPUSH
37066: LD_VAR 0 4
37070: PPUSH
37071: EMPTY
37072: PPUSH
37073: CALL_OW 1
37077: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37078: LD_ADDR_EXP 150
37082: PUSH
37083: LD_EXP 150
37087: PPUSH
37088: LD_VAR 0 4
37092: PPUSH
37093: EMPTY
37094: PPUSH
37095: CALL_OW 1
37099: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37100: LD_ADDR_EXP 151
37104: PUSH
37105: LD_EXP 151
37109: PPUSH
37110: LD_VAR 0 4
37114: PPUSH
37115: EMPTY
37116: PPUSH
37117: CALL_OW 1
37121: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37122: LD_ADDR_EXP 152
37126: PUSH
37127: LD_EXP 152
37131: PPUSH
37132: LD_VAR 0 4
37136: PPUSH
37137: EMPTY
37138: PPUSH
37139: CALL_OW 1
37143: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37144: LD_ADDR_EXP 153
37148: PUSH
37149: LD_EXP 153
37153: PPUSH
37154: LD_VAR 0 4
37158: PPUSH
37159: EMPTY
37160: PPUSH
37161: CALL_OW 1
37165: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37166: LD_ADDR_EXP 154
37170: PUSH
37171: LD_EXP 154
37175: PPUSH
37176: LD_VAR 0 4
37180: PPUSH
37181: EMPTY
37182: PPUSH
37183: CALL_OW 1
37187: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37188: LD_ADDR_EXP 155
37192: PUSH
37193: LD_EXP 155
37197: PPUSH
37198: LD_VAR 0 4
37202: PPUSH
37203: LD_INT 0
37205: PPUSH
37206: CALL_OW 1
37210: ST_TO_ADDR
// result := base ;
37211: LD_ADDR_VAR 0 3
37215: PUSH
37216: LD_VAR 0 4
37220: ST_TO_ADDR
// end ;
37221: LD_VAR 0 3
37225: RET
// export function MC_Start ( ) ; var i ; begin
37226: LD_INT 0
37228: PPUSH
37229: PPUSH
// for i = 1 to mc_bases do
37230: LD_ADDR_VAR 0 2
37234: PUSH
37235: DOUBLE
37236: LD_INT 1
37238: DEC
37239: ST_TO_ADDR
37240: LD_EXP 113
37244: PUSH
37245: FOR_TO
37246: IFFALSE 38323
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
37248: LD_ADDR_EXP 113
37252: PUSH
37253: LD_EXP 113
37257: PPUSH
37258: LD_VAR 0 2
37262: PPUSH
37263: LD_EXP 113
37267: PUSH
37268: LD_VAR 0 2
37272: ARRAY
37273: PUSH
37274: LD_INT 0
37276: DIFF
37277: PPUSH
37278: CALL_OW 1
37282: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37283: LD_ADDR_EXP 114
37287: PUSH
37288: LD_EXP 114
37292: PPUSH
37293: LD_VAR 0 2
37297: PPUSH
37298: EMPTY
37299: PPUSH
37300: CALL_OW 1
37304: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37305: LD_ADDR_EXP 115
37309: PUSH
37310: LD_EXP 115
37314: PPUSH
37315: LD_VAR 0 2
37319: PPUSH
37320: EMPTY
37321: PPUSH
37322: CALL_OW 1
37326: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37327: LD_ADDR_EXP 116
37331: PUSH
37332: LD_EXP 116
37336: PPUSH
37337: LD_VAR 0 2
37341: PPUSH
37342: EMPTY
37343: PPUSH
37344: CALL_OW 1
37348: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37349: LD_ADDR_EXP 117
37353: PUSH
37354: LD_EXP 117
37358: PPUSH
37359: LD_VAR 0 2
37363: PPUSH
37364: EMPTY
37365: PUSH
37366: EMPTY
37367: PUSH
37368: EMPTY
37369: LIST
37370: LIST
37371: PPUSH
37372: CALL_OW 1
37376: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37377: LD_ADDR_EXP 118
37381: PUSH
37382: LD_EXP 118
37386: PPUSH
37387: LD_VAR 0 2
37391: PPUSH
37392: EMPTY
37393: PPUSH
37394: CALL_OW 1
37398: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37399: LD_ADDR_EXP 145
37403: PUSH
37404: LD_EXP 145
37408: PPUSH
37409: LD_VAR 0 2
37413: PPUSH
37414: EMPTY
37415: PPUSH
37416: CALL_OW 1
37420: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37421: LD_ADDR_EXP 119
37425: PUSH
37426: LD_EXP 119
37430: PPUSH
37431: LD_VAR 0 2
37435: PPUSH
37436: EMPTY
37437: PPUSH
37438: CALL_OW 1
37442: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37443: LD_ADDR_EXP 120
37447: PUSH
37448: LD_EXP 120
37452: PPUSH
37453: LD_VAR 0 2
37457: PPUSH
37458: EMPTY
37459: PPUSH
37460: CALL_OW 1
37464: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37465: LD_ADDR_EXP 121
37469: PUSH
37470: LD_EXP 121
37474: PPUSH
37475: LD_VAR 0 2
37479: PPUSH
37480: LD_EXP 113
37484: PUSH
37485: LD_VAR 0 2
37489: ARRAY
37490: PPUSH
37491: LD_INT 2
37493: PUSH
37494: LD_INT 30
37496: PUSH
37497: LD_INT 32
37499: PUSH
37500: EMPTY
37501: LIST
37502: LIST
37503: PUSH
37504: LD_INT 30
37506: PUSH
37507: LD_INT 33
37509: PUSH
37510: EMPTY
37511: LIST
37512: LIST
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: LIST
37518: PPUSH
37519: CALL_OW 72
37523: PPUSH
37524: CALL_OW 1
37528: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37529: LD_ADDR_EXP 122
37533: PUSH
37534: LD_EXP 122
37538: PPUSH
37539: LD_VAR 0 2
37543: PPUSH
37544: LD_EXP 113
37548: PUSH
37549: LD_VAR 0 2
37553: ARRAY
37554: PPUSH
37555: LD_INT 2
37557: PUSH
37558: LD_INT 30
37560: PUSH
37561: LD_INT 32
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PUSH
37568: LD_INT 30
37570: PUSH
37571: LD_INT 31
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: LIST
37582: PUSH
37583: LD_INT 58
37585: PUSH
37586: EMPTY
37587: LIST
37588: PUSH
37589: EMPTY
37590: LIST
37591: LIST
37592: PPUSH
37593: CALL_OW 72
37597: PPUSH
37598: CALL_OW 1
37602: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37603: LD_ADDR_EXP 123
37607: PUSH
37608: LD_EXP 123
37612: PPUSH
37613: LD_VAR 0 2
37617: PPUSH
37618: EMPTY
37619: PPUSH
37620: CALL_OW 1
37624: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37625: LD_ADDR_EXP 127
37629: PUSH
37630: LD_EXP 127
37634: PPUSH
37635: LD_VAR 0 2
37639: PPUSH
37640: EMPTY
37641: PPUSH
37642: CALL_OW 1
37646: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37647: LD_ADDR_EXP 126
37651: PUSH
37652: LD_EXP 126
37656: PPUSH
37657: LD_VAR 0 2
37661: PPUSH
37662: EMPTY
37663: PPUSH
37664: CALL_OW 1
37668: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37669: LD_ADDR_EXP 128
37673: PUSH
37674: LD_EXP 128
37678: PPUSH
37679: LD_VAR 0 2
37683: PPUSH
37684: EMPTY
37685: PPUSH
37686: CALL_OW 1
37690: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37691: LD_ADDR_EXP 129
37695: PUSH
37696: LD_EXP 129
37700: PPUSH
37701: LD_VAR 0 2
37705: PPUSH
37706: EMPTY
37707: PPUSH
37708: CALL_OW 1
37712: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37713: LD_ADDR_EXP 130
37717: PUSH
37718: LD_EXP 130
37722: PPUSH
37723: LD_VAR 0 2
37727: PPUSH
37728: EMPTY
37729: PPUSH
37730: CALL_OW 1
37734: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37735: LD_ADDR_EXP 131
37739: PUSH
37740: LD_EXP 131
37744: PPUSH
37745: LD_VAR 0 2
37749: PPUSH
37750: EMPTY
37751: PPUSH
37752: CALL_OW 1
37756: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37757: LD_ADDR_EXP 132
37761: PUSH
37762: LD_EXP 132
37766: PPUSH
37767: LD_VAR 0 2
37771: PPUSH
37772: EMPTY
37773: PPUSH
37774: CALL_OW 1
37778: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37779: LD_ADDR_EXP 133
37783: PUSH
37784: LD_EXP 133
37788: PPUSH
37789: LD_VAR 0 2
37793: PPUSH
37794: EMPTY
37795: PPUSH
37796: CALL_OW 1
37800: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37801: LD_ADDR_EXP 134
37805: PUSH
37806: LD_EXP 134
37810: PPUSH
37811: LD_VAR 0 2
37815: PPUSH
37816: EMPTY
37817: PPUSH
37818: CALL_OW 1
37822: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37823: LD_ADDR_EXP 135
37827: PUSH
37828: LD_EXP 135
37832: PPUSH
37833: LD_VAR 0 2
37837: PPUSH
37838: EMPTY
37839: PPUSH
37840: CALL_OW 1
37844: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
37845: LD_ADDR_EXP 124
37849: PUSH
37850: LD_EXP 124
37854: PPUSH
37855: LD_VAR 0 2
37859: PPUSH
37860: LD_INT 0
37862: PPUSH
37863: CALL_OW 1
37867: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
37868: LD_ADDR_EXP 137
37872: PUSH
37873: LD_EXP 137
37877: PPUSH
37878: LD_VAR 0 2
37882: PPUSH
37883: LD_INT 0
37885: PPUSH
37886: CALL_OW 1
37890: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37891: LD_ADDR_EXP 125
37895: PUSH
37896: LD_EXP 125
37900: PPUSH
37901: LD_VAR 0 2
37905: PPUSH
37906: EMPTY
37907: PPUSH
37908: CALL_OW 1
37912: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37913: LD_ADDR_EXP 136
37917: PUSH
37918: LD_EXP 136
37922: PPUSH
37923: LD_VAR 0 2
37927: PPUSH
37928: LD_INT 0
37930: PPUSH
37931: CALL_OW 1
37935: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
37936: LD_ADDR_EXP 138
37940: PUSH
37941: LD_EXP 138
37945: PPUSH
37946: LD_VAR 0 2
37950: PPUSH
37951: EMPTY
37952: PPUSH
37953: CALL_OW 1
37957: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
37958: LD_ADDR_EXP 141
37962: PUSH
37963: LD_EXP 141
37967: PPUSH
37968: LD_VAR 0 2
37972: PPUSH
37973: LD_INT 0
37975: PPUSH
37976: CALL_OW 1
37980: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
37981: LD_ADDR_EXP 142
37985: PUSH
37986: LD_EXP 142
37990: PPUSH
37991: LD_VAR 0 2
37995: PPUSH
37996: EMPTY
37997: PPUSH
37998: CALL_OW 1
38002: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
38003: LD_ADDR_EXP 143
38007: PUSH
38008: LD_EXP 143
38012: PPUSH
38013: LD_VAR 0 2
38017: PPUSH
38018: EMPTY
38019: PPUSH
38020: CALL_OW 1
38024: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38025: LD_ADDR_EXP 144
38029: PUSH
38030: LD_EXP 144
38034: PPUSH
38035: LD_VAR 0 2
38039: PPUSH
38040: EMPTY
38041: PPUSH
38042: CALL_OW 1
38046: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
38047: LD_ADDR_EXP 146
38051: PUSH
38052: LD_EXP 146
38056: PPUSH
38057: LD_VAR 0 2
38061: PPUSH
38062: LD_EXP 113
38066: PUSH
38067: LD_VAR 0 2
38071: ARRAY
38072: PPUSH
38073: LD_INT 2
38075: PUSH
38076: LD_INT 30
38078: PUSH
38079: LD_INT 6
38081: PUSH
38082: EMPTY
38083: LIST
38084: LIST
38085: PUSH
38086: LD_INT 30
38088: PUSH
38089: LD_INT 7
38091: PUSH
38092: EMPTY
38093: LIST
38094: LIST
38095: PUSH
38096: LD_INT 30
38098: PUSH
38099: LD_INT 8
38101: PUSH
38102: EMPTY
38103: LIST
38104: LIST
38105: PUSH
38106: EMPTY
38107: LIST
38108: LIST
38109: LIST
38110: LIST
38111: PPUSH
38112: CALL_OW 72
38116: PPUSH
38117: CALL_OW 1
38121: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
38122: LD_ADDR_EXP 147
38126: PUSH
38127: LD_EXP 147
38131: PPUSH
38132: LD_VAR 0 2
38136: PPUSH
38137: EMPTY
38138: PPUSH
38139: CALL_OW 1
38143: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
38144: LD_ADDR_EXP 148
38148: PUSH
38149: LD_EXP 148
38153: PPUSH
38154: LD_VAR 0 2
38158: PPUSH
38159: EMPTY
38160: PPUSH
38161: CALL_OW 1
38165: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
38166: LD_ADDR_EXP 149
38170: PUSH
38171: LD_EXP 149
38175: PPUSH
38176: LD_VAR 0 2
38180: PPUSH
38181: EMPTY
38182: PPUSH
38183: CALL_OW 1
38187: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
38188: LD_ADDR_EXP 150
38192: PUSH
38193: LD_EXP 150
38197: PPUSH
38198: LD_VAR 0 2
38202: PPUSH
38203: EMPTY
38204: PPUSH
38205: CALL_OW 1
38209: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38210: LD_ADDR_EXP 151
38214: PUSH
38215: LD_EXP 151
38219: PPUSH
38220: LD_VAR 0 2
38224: PPUSH
38225: EMPTY
38226: PPUSH
38227: CALL_OW 1
38231: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
38232: LD_ADDR_EXP 152
38236: PUSH
38237: LD_EXP 152
38241: PPUSH
38242: LD_VAR 0 2
38246: PPUSH
38247: EMPTY
38248: PPUSH
38249: CALL_OW 1
38253: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
38254: LD_ADDR_EXP 153
38258: PUSH
38259: LD_EXP 153
38263: PPUSH
38264: LD_VAR 0 2
38268: PPUSH
38269: EMPTY
38270: PPUSH
38271: CALL_OW 1
38275: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38276: LD_ADDR_EXP 154
38280: PUSH
38281: LD_EXP 154
38285: PPUSH
38286: LD_VAR 0 2
38290: PPUSH
38291: EMPTY
38292: PPUSH
38293: CALL_OW 1
38297: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38298: LD_ADDR_EXP 155
38302: PUSH
38303: LD_EXP 155
38307: PPUSH
38308: LD_VAR 0 2
38312: PPUSH
38313: LD_INT 0
38315: PPUSH
38316: CALL_OW 1
38320: ST_TO_ADDR
// end ;
38321: GO 37245
38323: POP
38324: POP
// MC_InitSides ( ) ;
38325: CALL 38611 0 0
// MC_InitResearch ( ) ;
38329: CALL 38350 0 0
// CustomInitMacro ( ) ;
38333: CALL 471 0 0
// skirmish := true ;
38337: LD_ADDR_EXP 111
38341: PUSH
38342: LD_INT 1
38344: ST_TO_ADDR
// end ;
38345: LD_VAR 0 1
38349: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38350: LD_INT 0
38352: PPUSH
38353: PPUSH
38354: PPUSH
38355: PPUSH
38356: PPUSH
38357: PPUSH
// if not mc_bases then
38358: LD_EXP 113
38362: NOT
38363: IFFALSE 38367
// exit ;
38365: GO 38606
// for i = 1 to 8 do
38367: LD_ADDR_VAR 0 2
38371: PUSH
38372: DOUBLE
38373: LD_INT 1
38375: DEC
38376: ST_TO_ADDR
38377: LD_INT 8
38379: PUSH
38380: FOR_TO
38381: IFFALSE 38407
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38383: LD_ADDR_EXP 140
38387: PUSH
38388: LD_EXP 140
38392: PPUSH
38393: LD_VAR 0 2
38397: PPUSH
38398: EMPTY
38399: PPUSH
38400: CALL_OW 1
38404: ST_TO_ADDR
38405: GO 38380
38407: POP
38408: POP
// tmp := [ ] ;
38409: LD_ADDR_VAR 0 5
38413: PUSH
38414: EMPTY
38415: ST_TO_ADDR
// for i = 1 to mc_sides do
38416: LD_ADDR_VAR 0 2
38420: PUSH
38421: DOUBLE
38422: LD_INT 1
38424: DEC
38425: ST_TO_ADDR
38426: LD_EXP 139
38430: PUSH
38431: FOR_TO
38432: IFFALSE 38490
// if not mc_sides [ i ] in tmp then
38434: LD_EXP 139
38438: PUSH
38439: LD_VAR 0 2
38443: ARRAY
38444: PUSH
38445: LD_VAR 0 5
38449: IN
38450: NOT
38451: IFFALSE 38488
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38453: LD_ADDR_VAR 0 5
38457: PUSH
38458: LD_VAR 0 5
38462: PPUSH
38463: LD_VAR 0 5
38467: PUSH
38468: LD_INT 1
38470: PLUS
38471: PPUSH
38472: LD_EXP 139
38476: PUSH
38477: LD_VAR 0 2
38481: ARRAY
38482: PPUSH
38483: CALL_OW 2
38487: ST_TO_ADDR
38488: GO 38431
38490: POP
38491: POP
// if not tmp then
38492: LD_VAR 0 5
38496: NOT
38497: IFFALSE 38501
// exit ;
38499: GO 38606
// for j in tmp do
38501: LD_ADDR_VAR 0 3
38505: PUSH
38506: LD_VAR 0 5
38510: PUSH
38511: FOR_IN
38512: IFFALSE 38604
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38514: LD_ADDR_VAR 0 6
38518: PUSH
38519: LD_INT 22
38521: PUSH
38522: LD_VAR 0 3
38526: PUSH
38527: EMPTY
38528: LIST
38529: LIST
38530: PPUSH
38531: CALL_OW 69
38535: ST_TO_ADDR
// if not un then
38536: LD_VAR 0 6
38540: NOT
38541: IFFALSE 38545
// continue ;
38543: GO 38511
// nation := GetNation ( un [ 1 ] ) ;
38545: LD_ADDR_VAR 0 4
38549: PUSH
38550: LD_VAR 0 6
38554: PUSH
38555: LD_INT 1
38557: ARRAY
38558: PPUSH
38559: CALL_OW 248
38563: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38564: LD_ADDR_EXP 140
38568: PUSH
38569: LD_EXP 140
38573: PPUSH
38574: LD_VAR 0 3
38578: PPUSH
38579: LD_VAR 0 3
38583: PPUSH
38584: LD_VAR 0 4
38588: PPUSH
38589: LD_INT 1
38591: PPUSH
38592: CALL 65245 0 3
38596: PPUSH
38597: CALL_OW 1
38601: ST_TO_ADDR
// end ;
38602: GO 38511
38604: POP
38605: POP
// end ;
38606: LD_VAR 0 1
38610: RET
// export function MC_InitSides ( ) ; var i ; begin
38611: LD_INT 0
38613: PPUSH
38614: PPUSH
// if not mc_bases then
38615: LD_EXP 113
38619: NOT
38620: IFFALSE 38624
// exit ;
38622: GO 38698
// for i = 1 to mc_bases do
38624: LD_ADDR_VAR 0 2
38628: PUSH
38629: DOUBLE
38630: LD_INT 1
38632: DEC
38633: ST_TO_ADDR
38634: LD_EXP 113
38638: PUSH
38639: FOR_TO
38640: IFFALSE 38696
// if mc_bases [ i ] then
38642: LD_EXP 113
38646: PUSH
38647: LD_VAR 0 2
38651: ARRAY
38652: IFFALSE 38694
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38654: LD_ADDR_EXP 139
38658: PUSH
38659: LD_EXP 139
38663: PPUSH
38664: LD_VAR 0 2
38668: PPUSH
38669: LD_EXP 113
38673: PUSH
38674: LD_VAR 0 2
38678: ARRAY
38679: PUSH
38680: LD_INT 1
38682: ARRAY
38683: PPUSH
38684: CALL_OW 255
38688: PPUSH
38689: CALL_OW 1
38693: ST_TO_ADDR
38694: GO 38639
38696: POP
38697: POP
// end ;
38698: LD_VAR 0 1
38702: RET
// every 0 0$01 trigger skirmish do
38703: LD_EXP 111
38707: IFFALSE 38861
38709: GO 38711
38711: DISABLE
// begin enable ;
38712: ENABLE
// MC_CheckBuildings ( ) ;
38713: CALL 43359 0 0
// MC_CheckPeopleLife ( ) ;
38717: CALL 43484 0 0
// RaiseSailEvent ( 100 ) ;
38721: LD_INT 100
38723: PPUSH
38724: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38728: LD_INT 103
38730: PPUSH
38731: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38735: LD_INT 104
38737: PPUSH
38738: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38742: LD_INT 105
38744: PPUSH
38745: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38749: LD_INT 106
38751: PPUSH
38752: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38756: LD_INT 107
38758: PPUSH
38759: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38763: LD_INT 108
38765: PPUSH
38766: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38770: LD_INT 109
38772: PPUSH
38773: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38777: LD_INT 110
38779: PPUSH
38780: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38784: LD_INT 111
38786: PPUSH
38787: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
38791: LD_INT 112
38793: PPUSH
38794: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
38798: LD_INT 113
38800: PPUSH
38801: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
38805: LD_INT 120
38807: PPUSH
38808: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
38812: LD_INT 121
38814: PPUSH
38815: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
38819: LD_INT 122
38821: PPUSH
38822: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
38826: LD_INT 123
38828: PPUSH
38829: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
38833: LD_INT 124
38835: PPUSH
38836: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
38840: LD_INT 125
38842: PPUSH
38843: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
38847: LD_INT 126
38849: PPUSH
38850: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
38854: LD_INT 200
38856: PPUSH
38857: CALL_OW 427
// end ;
38861: END
// on SailEvent ( event ) do begin if event < 100 then
38862: LD_VAR 0 1
38866: PUSH
38867: LD_INT 100
38869: LESS
38870: IFFALSE 38881
// CustomEvent ( event ) ;
38872: LD_VAR 0 1
38876: PPUSH
38877: CALL 33428 0 1
// if event = 100 then
38881: LD_VAR 0 1
38885: PUSH
38886: LD_INT 100
38888: EQUAL
38889: IFFALSE 38895
// MC_ClassManager ( ) ;
38891: CALL 39287 0 0
// if event = 101 then
38895: LD_VAR 0 1
38899: PUSH
38900: LD_INT 101
38902: EQUAL
38903: IFFALSE 38909
// MC_RepairBuildings ( ) ;
38905: CALL 44069 0 0
// if event = 102 then
38909: LD_VAR 0 1
38913: PUSH
38914: LD_INT 102
38916: EQUAL
38917: IFFALSE 38923
// MC_Heal ( ) ;
38919: CALL 44954 0 0
// if event = 103 then
38923: LD_VAR 0 1
38927: PUSH
38928: LD_INT 103
38930: EQUAL
38931: IFFALSE 38937
// MC_Build ( ) ;
38933: CALL 45376 0 0
// if event = 104 then
38937: LD_VAR 0 1
38941: PUSH
38942: LD_INT 104
38944: EQUAL
38945: IFFALSE 38951
// MC_TurretWeapon ( ) ;
38947: CALL 46989 0 0
// if event = 105 then
38951: LD_VAR 0 1
38955: PUSH
38956: LD_INT 105
38958: EQUAL
38959: IFFALSE 38965
// MC_BuildUpgrade ( ) ;
38961: CALL 46540 0 0
// if event = 106 then
38965: LD_VAR 0 1
38969: PUSH
38970: LD_INT 106
38972: EQUAL
38973: IFFALSE 38979
// MC_PlantMines ( ) ;
38975: CALL 47419 0 0
// if event = 107 then
38979: LD_VAR 0 1
38983: PUSH
38984: LD_INT 107
38986: EQUAL
38987: IFFALSE 38993
// MC_CollectCrates ( ) ;
38989: CALL 48217 0 0
// if event = 108 then
38993: LD_VAR 0 1
38997: PUSH
38998: LD_INT 108
39000: EQUAL
39001: IFFALSE 39007
// MC_LinkRemoteControl ( ) ;
39003: CALL 49993 0 0
// if event = 109 then
39007: LD_VAR 0 1
39011: PUSH
39012: LD_INT 109
39014: EQUAL
39015: IFFALSE 39021
// MC_ProduceVehicle ( ) ;
39017: CALL 50174 0 0
// if event = 110 then
39021: LD_VAR 0 1
39025: PUSH
39026: LD_INT 110
39028: EQUAL
39029: IFFALSE 39035
// MC_SendAttack ( ) ;
39031: CALL 50640 0 0
// if event = 111 then
39035: LD_VAR 0 1
39039: PUSH
39040: LD_INT 111
39042: EQUAL
39043: IFFALSE 39049
// MC_Defend ( ) ;
39045: CALL 50748 0 0
// if event = 112 then
39049: LD_VAR 0 1
39053: PUSH
39054: LD_INT 112
39056: EQUAL
39057: IFFALSE 39063
// MC_Research ( ) ;
39059: CALL 51353 0 0
// if event = 113 then
39063: LD_VAR 0 1
39067: PUSH
39068: LD_INT 113
39070: EQUAL
39071: IFFALSE 39077
// MC_MinesTrigger ( ) ;
39073: CALL 52467 0 0
// if event = 120 then
39077: LD_VAR 0 1
39081: PUSH
39082: LD_INT 120
39084: EQUAL
39085: IFFALSE 39091
// MC_RepairVehicle ( ) ;
39087: CALL 52566 0 0
// if event = 121 then
39091: LD_VAR 0 1
39095: PUSH
39096: LD_INT 121
39098: EQUAL
39099: IFFALSE 39105
// MC_TameApe ( ) ;
39101: CALL 53296 0 0
// if event = 122 then
39105: LD_VAR 0 1
39109: PUSH
39110: LD_INT 122
39112: EQUAL
39113: IFFALSE 39119
// MC_ChangeApeClass ( ) ;
39115: CALL 54125 0 0
// if event = 123 then
39119: LD_VAR 0 1
39123: PUSH
39124: LD_INT 123
39126: EQUAL
39127: IFFALSE 39133
// MC_Bazooka ( ) ;
39129: CALL 54775 0 0
// if event = 124 then
39133: LD_VAR 0 1
39137: PUSH
39138: LD_INT 124
39140: EQUAL
39141: IFFALSE 39147
// MC_TeleportExit ( ) ;
39143: CALL 54973 0 0
// if event = 125 then
39147: LD_VAR 0 1
39151: PUSH
39152: LD_INT 125
39154: EQUAL
39155: IFFALSE 39161
// MC_Deposits ( ) ;
39157: CALL 55620 0 0
// if event = 126 then
39161: LD_VAR 0 1
39165: PUSH
39166: LD_INT 126
39168: EQUAL
39169: IFFALSE 39175
// MC_RemoteDriver ( ) ;
39171: CALL 56245 0 0
// if event = 200 then
39175: LD_VAR 0 1
39179: PUSH
39180: LD_INT 200
39182: EQUAL
39183: IFFALSE 39189
// MC_Idle ( ) ;
39185: CALL 58194 0 0
// end ;
39189: PPOPN 1
39191: END
// export function MC_Reset ( base , tag ) ; var i ; begin
39192: LD_INT 0
39194: PPUSH
39195: PPUSH
// if not mc_bases [ base ] or not tag then
39196: LD_EXP 113
39200: PUSH
39201: LD_VAR 0 1
39205: ARRAY
39206: NOT
39207: PUSH
39208: LD_VAR 0 2
39212: NOT
39213: OR
39214: IFFALSE 39218
// exit ;
39216: GO 39282
// for i in mc_bases [ base ] union mc_ape [ base ] do
39218: LD_ADDR_VAR 0 4
39222: PUSH
39223: LD_EXP 113
39227: PUSH
39228: LD_VAR 0 1
39232: ARRAY
39233: PUSH
39234: LD_EXP 142
39238: PUSH
39239: LD_VAR 0 1
39243: ARRAY
39244: UNION
39245: PUSH
39246: FOR_IN
39247: IFFALSE 39280
// if GetTag ( i ) = tag then
39249: LD_VAR 0 4
39253: PPUSH
39254: CALL_OW 110
39258: PUSH
39259: LD_VAR 0 2
39263: EQUAL
39264: IFFALSE 39278
// SetTag ( i , 0 ) ;
39266: LD_VAR 0 4
39270: PPUSH
39271: LD_INT 0
39273: PPUSH
39274: CALL_OW 109
39278: GO 39246
39280: POP
39281: POP
// end ;
39282: LD_VAR 0 3
39286: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39287: LD_INT 0
39289: PPUSH
39290: PPUSH
39291: PPUSH
39292: PPUSH
39293: PPUSH
39294: PPUSH
39295: PPUSH
39296: PPUSH
// if not mc_bases then
39297: LD_EXP 113
39301: NOT
39302: IFFALSE 39306
// exit ;
39304: GO 39764
// for i = 1 to mc_bases do
39306: LD_ADDR_VAR 0 2
39310: PUSH
39311: DOUBLE
39312: LD_INT 1
39314: DEC
39315: ST_TO_ADDR
39316: LD_EXP 113
39320: PUSH
39321: FOR_TO
39322: IFFALSE 39762
// begin tmp := MC_ClassCheckReq ( i ) ;
39324: LD_ADDR_VAR 0 4
39328: PUSH
39329: LD_VAR 0 2
39333: PPUSH
39334: CALL 39769 0 1
39338: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39339: LD_ADDR_EXP 154
39343: PUSH
39344: LD_EXP 154
39348: PPUSH
39349: LD_VAR 0 2
39353: PPUSH
39354: LD_VAR 0 4
39358: PPUSH
39359: CALL_OW 1
39363: ST_TO_ADDR
// if not tmp then
39364: LD_VAR 0 4
39368: NOT
39369: IFFALSE 39373
// continue ;
39371: GO 39321
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39373: LD_ADDR_VAR 0 6
39377: PUSH
39378: LD_EXP 113
39382: PUSH
39383: LD_VAR 0 2
39387: ARRAY
39388: PPUSH
39389: LD_INT 2
39391: PUSH
39392: LD_INT 30
39394: PUSH
39395: LD_INT 4
39397: PUSH
39398: EMPTY
39399: LIST
39400: LIST
39401: PUSH
39402: LD_INT 30
39404: PUSH
39405: LD_INT 5
39407: PUSH
39408: EMPTY
39409: LIST
39410: LIST
39411: PUSH
39412: EMPTY
39413: LIST
39414: LIST
39415: LIST
39416: PPUSH
39417: CALL_OW 72
39421: PUSH
39422: LD_EXP 113
39426: PUSH
39427: LD_VAR 0 2
39431: ARRAY
39432: PPUSH
39433: LD_INT 2
39435: PUSH
39436: LD_INT 30
39438: PUSH
39439: LD_INT 0
39441: PUSH
39442: EMPTY
39443: LIST
39444: LIST
39445: PUSH
39446: LD_INT 30
39448: PUSH
39449: LD_INT 1
39451: PUSH
39452: EMPTY
39453: LIST
39454: LIST
39455: PUSH
39456: EMPTY
39457: LIST
39458: LIST
39459: LIST
39460: PPUSH
39461: CALL_OW 72
39465: PUSH
39466: LD_EXP 113
39470: PUSH
39471: LD_VAR 0 2
39475: ARRAY
39476: PPUSH
39477: LD_INT 30
39479: PUSH
39480: LD_INT 3
39482: PUSH
39483: EMPTY
39484: LIST
39485: LIST
39486: PPUSH
39487: CALL_OW 72
39491: PUSH
39492: LD_EXP 113
39496: PUSH
39497: LD_VAR 0 2
39501: ARRAY
39502: PPUSH
39503: LD_INT 2
39505: PUSH
39506: LD_INT 30
39508: PUSH
39509: LD_INT 6
39511: PUSH
39512: EMPTY
39513: LIST
39514: LIST
39515: PUSH
39516: LD_INT 30
39518: PUSH
39519: LD_INT 7
39521: PUSH
39522: EMPTY
39523: LIST
39524: LIST
39525: PUSH
39526: LD_INT 30
39528: PUSH
39529: LD_INT 8
39531: PUSH
39532: EMPTY
39533: LIST
39534: LIST
39535: PUSH
39536: EMPTY
39537: LIST
39538: LIST
39539: LIST
39540: LIST
39541: PPUSH
39542: CALL_OW 72
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: LIST
39551: LIST
39552: ST_TO_ADDR
// for j = 1 to 4 do
39553: LD_ADDR_VAR 0 3
39557: PUSH
39558: DOUBLE
39559: LD_INT 1
39561: DEC
39562: ST_TO_ADDR
39563: LD_INT 4
39565: PUSH
39566: FOR_TO
39567: IFFALSE 39758
// begin if not tmp [ j ] then
39569: LD_VAR 0 4
39573: PUSH
39574: LD_VAR 0 3
39578: ARRAY
39579: NOT
39580: IFFALSE 39584
// continue ;
39582: GO 39566
// for p in tmp [ j ] do
39584: LD_ADDR_VAR 0 5
39588: PUSH
39589: LD_VAR 0 4
39593: PUSH
39594: LD_VAR 0 3
39598: ARRAY
39599: PUSH
39600: FOR_IN
39601: IFFALSE 39754
// begin if not b [ j ] then
39603: LD_VAR 0 6
39607: PUSH
39608: LD_VAR 0 3
39612: ARRAY
39613: NOT
39614: IFFALSE 39618
// break ;
39616: GO 39754
// e := 0 ;
39618: LD_ADDR_VAR 0 7
39622: PUSH
39623: LD_INT 0
39625: ST_TO_ADDR
// for k in b [ j ] do
39626: LD_ADDR_VAR 0 8
39630: PUSH
39631: LD_VAR 0 6
39635: PUSH
39636: LD_VAR 0 3
39640: ARRAY
39641: PUSH
39642: FOR_IN
39643: IFFALSE 39670
// if IsNotFull ( k ) then
39645: LD_VAR 0 8
39649: PPUSH
39650: CALL 67394 0 1
39654: IFFALSE 39668
// begin e := k ;
39656: LD_ADDR_VAR 0 7
39660: PUSH
39661: LD_VAR 0 8
39665: ST_TO_ADDR
// break ;
39666: GO 39670
// end ;
39668: GO 39642
39670: POP
39671: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39672: LD_VAR 0 7
39676: PUSH
39677: LD_VAR 0 5
39681: PPUSH
39682: LD_VAR 0 7
39686: PPUSH
39687: CALL 99814 0 2
39691: NOT
39692: AND
39693: IFFALSE 39752
// begin if IsInUnit ( p ) then
39695: LD_VAR 0 5
39699: PPUSH
39700: CALL_OW 310
39704: IFFALSE 39715
// ComExitBuilding ( p ) ;
39706: LD_VAR 0 5
39710: PPUSH
39711: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39715: LD_VAR 0 5
39719: PPUSH
39720: LD_VAR 0 7
39724: PPUSH
39725: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39729: LD_VAR 0 5
39733: PPUSH
39734: LD_VAR 0 3
39738: PPUSH
39739: CALL_OW 183
// AddComExitBuilding ( p ) ;
39743: LD_VAR 0 5
39747: PPUSH
39748: CALL_OW 182
// end ; end ;
39752: GO 39600
39754: POP
39755: POP
// end ;
39756: GO 39566
39758: POP
39759: POP
// end ;
39760: GO 39321
39762: POP
39763: POP
// end ;
39764: LD_VAR 0 1
39768: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39769: LD_INT 0
39771: PPUSH
39772: PPUSH
39773: PPUSH
39774: PPUSH
39775: PPUSH
39776: PPUSH
39777: PPUSH
39778: PPUSH
39779: PPUSH
39780: PPUSH
39781: PPUSH
39782: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39783: LD_VAR 0 1
39787: NOT
39788: PUSH
39789: LD_EXP 113
39793: PUSH
39794: LD_VAR 0 1
39798: ARRAY
39799: NOT
39800: OR
39801: PUSH
39802: LD_EXP 113
39806: PUSH
39807: LD_VAR 0 1
39811: ARRAY
39812: PPUSH
39813: LD_INT 2
39815: PUSH
39816: LD_INT 30
39818: PUSH
39819: LD_INT 0
39821: PUSH
39822: EMPTY
39823: LIST
39824: LIST
39825: PUSH
39826: LD_INT 30
39828: PUSH
39829: LD_INT 1
39831: PUSH
39832: EMPTY
39833: LIST
39834: LIST
39835: PUSH
39836: EMPTY
39837: LIST
39838: LIST
39839: LIST
39840: PPUSH
39841: CALL_OW 72
39845: NOT
39846: OR
39847: IFFALSE 39851
// exit ;
39849: GO 43354
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39851: LD_ADDR_VAR 0 4
39855: PUSH
39856: LD_EXP 113
39860: PUSH
39861: LD_VAR 0 1
39865: ARRAY
39866: PPUSH
39867: LD_INT 2
39869: PUSH
39870: LD_INT 25
39872: PUSH
39873: LD_INT 1
39875: PUSH
39876: EMPTY
39877: LIST
39878: LIST
39879: PUSH
39880: LD_INT 25
39882: PUSH
39883: LD_INT 2
39885: PUSH
39886: EMPTY
39887: LIST
39888: LIST
39889: PUSH
39890: LD_INT 25
39892: PUSH
39893: LD_INT 3
39895: PUSH
39896: EMPTY
39897: LIST
39898: LIST
39899: PUSH
39900: LD_INT 25
39902: PUSH
39903: LD_INT 4
39905: PUSH
39906: EMPTY
39907: LIST
39908: LIST
39909: PUSH
39910: LD_INT 25
39912: PUSH
39913: LD_INT 5
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: PUSH
39920: LD_INT 25
39922: PUSH
39923: LD_INT 8
39925: PUSH
39926: EMPTY
39927: LIST
39928: LIST
39929: PUSH
39930: LD_INT 25
39932: PUSH
39933: LD_INT 9
39935: PUSH
39936: EMPTY
39937: LIST
39938: LIST
39939: PUSH
39940: EMPTY
39941: LIST
39942: LIST
39943: LIST
39944: LIST
39945: LIST
39946: LIST
39947: LIST
39948: LIST
39949: PPUSH
39950: CALL_OW 72
39954: ST_TO_ADDR
// if not tmp then
39955: LD_VAR 0 4
39959: NOT
39960: IFFALSE 39964
// exit ;
39962: GO 43354
// for i in tmp do
39964: LD_ADDR_VAR 0 3
39968: PUSH
39969: LD_VAR 0 4
39973: PUSH
39974: FOR_IN
39975: IFFALSE 40006
// if GetTag ( i ) then
39977: LD_VAR 0 3
39981: PPUSH
39982: CALL_OW 110
39986: IFFALSE 40004
// tmp := tmp diff i ;
39988: LD_ADDR_VAR 0 4
39992: PUSH
39993: LD_VAR 0 4
39997: PUSH
39998: LD_VAR 0 3
40002: DIFF
40003: ST_TO_ADDR
40004: GO 39974
40006: POP
40007: POP
// if not tmp then
40008: LD_VAR 0 4
40012: NOT
40013: IFFALSE 40017
// exit ;
40015: GO 43354
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40017: LD_ADDR_VAR 0 5
40021: PUSH
40022: LD_EXP 113
40026: PUSH
40027: LD_VAR 0 1
40031: ARRAY
40032: PPUSH
40033: LD_INT 2
40035: PUSH
40036: LD_INT 25
40038: PUSH
40039: LD_INT 1
40041: PUSH
40042: EMPTY
40043: LIST
40044: LIST
40045: PUSH
40046: LD_INT 25
40048: PUSH
40049: LD_INT 5
40051: PUSH
40052: EMPTY
40053: LIST
40054: LIST
40055: PUSH
40056: LD_INT 25
40058: PUSH
40059: LD_INT 8
40061: PUSH
40062: EMPTY
40063: LIST
40064: LIST
40065: PUSH
40066: LD_INT 25
40068: PUSH
40069: LD_INT 9
40071: PUSH
40072: EMPTY
40073: LIST
40074: LIST
40075: PUSH
40076: EMPTY
40077: LIST
40078: LIST
40079: LIST
40080: LIST
40081: LIST
40082: PPUSH
40083: CALL_OW 72
40087: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
40088: LD_ADDR_VAR 0 6
40092: PUSH
40093: LD_EXP 113
40097: PUSH
40098: LD_VAR 0 1
40102: ARRAY
40103: PPUSH
40104: LD_INT 25
40106: PUSH
40107: LD_INT 2
40109: PUSH
40110: EMPTY
40111: LIST
40112: LIST
40113: PPUSH
40114: CALL_OW 72
40118: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
40119: LD_ADDR_VAR 0 7
40123: PUSH
40124: LD_EXP 113
40128: PUSH
40129: LD_VAR 0 1
40133: ARRAY
40134: PPUSH
40135: LD_INT 25
40137: PUSH
40138: LD_INT 3
40140: PUSH
40141: EMPTY
40142: LIST
40143: LIST
40144: PPUSH
40145: CALL_OW 72
40149: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
40150: LD_ADDR_VAR 0 8
40154: PUSH
40155: LD_EXP 113
40159: PUSH
40160: LD_VAR 0 1
40164: ARRAY
40165: PPUSH
40166: LD_INT 25
40168: PUSH
40169: LD_INT 4
40171: PUSH
40172: EMPTY
40173: LIST
40174: LIST
40175: PUSH
40176: LD_INT 24
40178: PUSH
40179: LD_INT 251
40181: PUSH
40182: EMPTY
40183: LIST
40184: LIST
40185: PUSH
40186: EMPTY
40187: LIST
40188: LIST
40189: PPUSH
40190: CALL_OW 72
40194: ST_TO_ADDR
// if mc_scan [ base ] then
40195: LD_EXP 136
40199: PUSH
40200: LD_VAR 0 1
40204: ARRAY
40205: IFFALSE 40666
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
40207: LD_ADDR_EXP 155
40211: PUSH
40212: LD_EXP 155
40216: PPUSH
40217: LD_VAR 0 1
40221: PPUSH
40222: LD_INT 4
40224: PPUSH
40225: CALL_OW 1
40229: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40230: LD_ADDR_VAR 0 12
40234: PUSH
40235: LD_EXP 113
40239: PUSH
40240: LD_VAR 0 1
40244: ARRAY
40245: PPUSH
40246: LD_INT 2
40248: PUSH
40249: LD_INT 30
40251: PUSH
40252: LD_INT 4
40254: PUSH
40255: EMPTY
40256: LIST
40257: LIST
40258: PUSH
40259: LD_INT 30
40261: PUSH
40262: LD_INT 5
40264: PUSH
40265: EMPTY
40266: LIST
40267: LIST
40268: PUSH
40269: EMPTY
40270: LIST
40271: LIST
40272: LIST
40273: PPUSH
40274: CALL_OW 72
40278: ST_TO_ADDR
// if not b then
40279: LD_VAR 0 12
40283: NOT
40284: IFFALSE 40288
// exit ;
40286: GO 43354
// p := [ ] ;
40288: LD_ADDR_VAR 0 11
40292: PUSH
40293: EMPTY
40294: ST_TO_ADDR
// if sci >= 2 then
40295: LD_VAR 0 8
40299: PUSH
40300: LD_INT 2
40302: GREATEREQUAL
40303: IFFALSE 40334
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40305: LD_ADDR_VAR 0 8
40309: PUSH
40310: LD_VAR 0 8
40314: PUSH
40315: LD_INT 1
40317: ARRAY
40318: PUSH
40319: LD_VAR 0 8
40323: PUSH
40324: LD_INT 2
40326: ARRAY
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: ST_TO_ADDR
40332: GO 40395
// if sci = 1 then
40334: LD_VAR 0 8
40338: PUSH
40339: LD_INT 1
40341: EQUAL
40342: IFFALSE 40363
// sci := [ sci [ 1 ] ] else
40344: LD_ADDR_VAR 0 8
40348: PUSH
40349: LD_VAR 0 8
40353: PUSH
40354: LD_INT 1
40356: ARRAY
40357: PUSH
40358: EMPTY
40359: LIST
40360: ST_TO_ADDR
40361: GO 40395
// if sci = 0 then
40363: LD_VAR 0 8
40367: PUSH
40368: LD_INT 0
40370: EQUAL
40371: IFFALSE 40395
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40373: LD_ADDR_VAR 0 11
40377: PUSH
40378: LD_VAR 0 4
40382: PPUSH
40383: LD_INT 4
40385: PPUSH
40386: CALL 99677 0 2
40390: PUSH
40391: LD_INT 1
40393: ARRAY
40394: ST_TO_ADDR
// if eng > 4 then
40395: LD_VAR 0 6
40399: PUSH
40400: LD_INT 4
40402: GREATER
40403: IFFALSE 40449
// for i = eng downto 4 do
40405: LD_ADDR_VAR 0 3
40409: PUSH
40410: DOUBLE
40411: LD_VAR 0 6
40415: INC
40416: ST_TO_ADDR
40417: LD_INT 4
40419: PUSH
40420: FOR_DOWNTO
40421: IFFALSE 40447
// eng := eng diff eng [ i ] ;
40423: LD_ADDR_VAR 0 6
40427: PUSH
40428: LD_VAR 0 6
40432: PUSH
40433: LD_VAR 0 6
40437: PUSH
40438: LD_VAR 0 3
40442: ARRAY
40443: DIFF
40444: ST_TO_ADDR
40445: GO 40420
40447: POP
40448: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40449: LD_ADDR_VAR 0 4
40453: PUSH
40454: LD_VAR 0 4
40458: PUSH
40459: LD_VAR 0 5
40463: PUSH
40464: LD_VAR 0 6
40468: UNION
40469: PUSH
40470: LD_VAR 0 7
40474: UNION
40475: PUSH
40476: LD_VAR 0 8
40480: UNION
40481: DIFF
40482: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40483: LD_ADDR_VAR 0 13
40487: PUSH
40488: LD_EXP 113
40492: PUSH
40493: LD_VAR 0 1
40497: ARRAY
40498: PPUSH
40499: LD_INT 2
40501: PUSH
40502: LD_INT 30
40504: PUSH
40505: LD_INT 32
40507: PUSH
40508: EMPTY
40509: LIST
40510: LIST
40511: PUSH
40512: LD_INT 30
40514: PUSH
40515: LD_INT 31
40517: PUSH
40518: EMPTY
40519: LIST
40520: LIST
40521: PUSH
40522: EMPTY
40523: LIST
40524: LIST
40525: LIST
40526: PPUSH
40527: CALL_OW 72
40531: PUSH
40532: LD_EXP 113
40536: PUSH
40537: LD_VAR 0 1
40541: ARRAY
40542: PPUSH
40543: LD_INT 2
40545: PUSH
40546: LD_INT 30
40548: PUSH
40549: LD_INT 4
40551: PUSH
40552: EMPTY
40553: LIST
40554: LIST
40555: PUSH
40556: LD_INT 30
40558: PUSH
40559: LD_INT 5
40561: PUSH
40562: EMPTY
40563: LIST
40564: LIST
40565: PUSH
40566: EMPTY
40567: LIST
40568: LIST
40569: LIST
40570: PPUSH
40571: CALL_OW 72
40575: PUSH
40576: LD_INT 6
40578: MUL
40579: PLUS
40580: ST_TO_ADDR
// if bcount < tmp then
40581: LD_VAR 0 13
40585: PUSH
40586: LD_VAR 0 4
40590: LESS
40591: IFFALSE 40637
// for i = tmp downto bcount do
40593: LD_ADDR_VAR 0 3
40597: PUSH
40598: DOUBLE
40599: LD_VAR 0 4
40603: INC
40604: ST_TO_ADDR
40605: LD_VAR 0 13
40609: PUSH
40610: FOR_DOWNTO
40611: IFFALSE 40635
// tmp := Delete ( tmp , tmp ) ;
40613: LD_ADDR_VAR 0 4
40617: PUSH
40618: LD_VAR 0 4
40622: PPUSH
40623: LD_VAR 0 4
40627: PPUSH
40628: CALL_OW 3
40632: ST_TO_ADDR
40633: GO 40610
40635: POP
40636: POP
// result := [ tmp , 0 , 0 , p ] ;
40637: LD_ADDR_VAR 0 2
40641: PUSH
40642: LD_VAR 0 4
40646: PUSH
40647: LD_INT 0
40649: PUSH
40650: LD_INT 0
40652: PUSH
40653: LD_VAR 0 11
40657: PUSH
40658: EMPTY
40659: LIST
40660: LIST
40661: LIST
40662: LIST
40663: ST_TO_ADDR
// exit ;
40664: GO 43354
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40666: LD_EXP 113
40670: PUSH
40671: LD_VAR 0 1
40675: ARRAY
40676: PPUSH
40677: LD_INT 2
40679: PUSH
40680: LD_INT 30
40682: PUSH
40683: LD_INT 6
40685: PUSH
40686: EMPTY
40687: LIST
40688: LIST
40689: PUSH
40690: LD_INT 30
40692: PUSH
40693: LD_INT 7
40695: PUSH
40696: EMPTY
40697: LIST
40698: LIST
40699: PUSH
40700: LD_INT 30
40702: PUSH
40703: LD_INT 8
40705: PUSH
40706: EMPTY
40707: LIST
40708: LIST
40709: PUSH
40710: EMPTY
40711: LIST
40712: LIST
40713: LIST
40714: LIST
40715: PPUSH
40716: CALL_OW 72
40720: NOT
40721: PUSH
40722: LD_EXP 113
40726: PUSH
40727: LD_VAR 0 1
40731: ARRAY
40732: PPUSH
40733: LD_INT 30
40735: PUSH
40736: LD_INT 3
40738: PUSH
40739: EMPTY
40740: LIST
40741: LIST
40742: PPUSH
40743: CALL_OW 72
40747: NOT
40748: AND
40749: IFFALSE 40821
// begin if eng = tmp then
40751: LD_VAR 0 6
40755: PUSH
40756: LD_VAR 0 4
40760: EQUAL
40761: IFFALSE 40765
// exit ;
40763: GO 43354
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40765: LD_ADDR_EXP 155
40769: PUSH
40770: LD_EXP 155
40774: PPUSH
40775: LD_VAR 0 1
40779: PPUSH
40780: LD_INT 1
40782: PPUSH
40783: CALL_OW 1
40787: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
40788: LD_ADDR_VAR 0 2
40792: PUSH
40793: LD_INT 0
40795: PUSH
40796: LD_VAR 0 4
40800: PUSH
40801: LD_VAR 0 6
40805: DIFF
40806: PUSH
40807: LD_INT 0
40809: PUSH
40810: LD_INT 0
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: LIST
40817: LIST
40818: ST_TO_ADDR
// exit ;
40819: GO 43354
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40821: LD_EXP 140
40825: PUSH
40826: LD_EXP 139
40830: PUSH
40831: LD_VAR 0 1
40835: ARRAY
40836: ARRAY
40837: PUSH
40838: LD_EXP 113
40842: PUSH
40843: LD_VAR 0 1
40847: ARRAY
40848: PPUSH
40849: LD_INT 2
40851: PUSH
40852: LD_INT 30
40854: PUSH
40855: LD_INT 6
40857: PUSH
40858: EMPTY
40859: LIST
40860: LIST
40861: PUSH
40862: LD_INT 30
40864: PUSH
40865: LD_INT 7
40867: PUSH
40868: EMPTY
40869: LIST
40870: LIST
40871: PUSH
40872: LD_INT 30
40874: PUSH
40875: LD_INT 8
40877: PUSH
40878: EMPTY
40879: LIST
40880: LIST
40881: PUSH
40882: EMPTY
40883: LIST
40884: LIST
40885: LIST
40886: LIST
40887: PPUSH
40888: CALL_OW 72
40892: AND
40893: PUSH
40894: LD_EXP 113
40898: PUSH
40899: LD_VAR 0 1
40903: ARRAY
40904: PPUSH
40905: LD_INT 30
40907: PUSH
40908: LD_INT 3
40910: PUSH
40911: EMPTY
40912: LIST
40913: LIST
40914: PPUSH
40915: CALL_OW 72
40919: NOT
40920: AND
40921: IFFALSE 41135
// begin if sci >= 6 then
40923: LD_VAR 0 8
40927: PUSH
40928: LD_INT 6
40930: GREATEREQUAL
40931: IFFALSE 40935
// exit ;
40933: GO 43354
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
40935: LD_ADDR_EXP 155
40939: PUSH
40940: LD_EXP 155
40944: PPUSH
40945: LD_VAR 0 1
40949: PPUSH
40950: LD_INT 2
40952: PPUSH
40953: CALL_OW 1
40957: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
40958: LD_ADDR_VAR 0 9
40962: PUSH
40963: LD_VAR 0 4
40967: PUSH
40968: LD_VAR 0 8
40972: DIFF
40973: PPUSH
40974: LD_INT 4
40976: PPUSH
40977: CALL 99677 0 2
40981: ST_TO_ADDR
// p := [ ] ;
40982: LD_ADDR_VAR 0 11
40986: PUSH
40987: EMPTY
40988: ST_TO_ADDR
// if sci < 6 and sort > 6 then
40989: LD_VAR 0 8
40993: PUSH
40994: LD_INT 6
40996: LESS
40997: PUSH
40998: LD_VAR 0 9
41002: PUSH
41003: LD_INT 6
41005: GREATER
41006: AND
41007: IFFALSE 41088
// begin for i = 1 to 6 - sci do
41009: LD_ADDR_VAR 0 3
41013: PUSH
41014: DOUBLE
41015: LD_INT 1
41017: DEC
41018: ST_TO_ADDR
41019: LD_INT 6
41021: PUSH
41022: LD_VAR 0 8
41026: MINUS
41027: PUSH
41028: FOR_TO
41029: IFFALSE 41084
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
41031: LD_ADDR_VAR 0 11
41035: PUSH
41036: LD_VAR 0 11
41040: PPUSH
41041: LD_VAR 0 11
41045: PUSH
41046: LD_INT 1
41048: PLUS
41049: PPUSH
41050: LD_VAR 0 9
41054: PUSH
41055: LD_INT 1
41057: ARRAY
41058: PPUSH
41059: CALL_OW 2
41063: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
41064: LD_ADDR_VAR 0 9
41068: PUSH
41069: LD_VAR 0 9
41073: PPUSH
41074: LD_INT 1
41076: PPUSH
41077: CALL_OW 3
41081: ST_TO_ADDR
// end ;
41082: GO 41028
41084: POP
41085: POP
// end else
41086: GO 41108
// if sort then
41088: LD_VAR 0 9
41092: IFFALSE 41108
// p := sort [ 1 ] ;
41094: LD_ADDR_VAR 0 11
41098: PUSH
41099: LD_VAR 0 9
41103: PUSH
41104: LD_INT 1
41106: ARRAY
41107: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
41108: LD_ADDR_VAR 0 2
41112: PUSH
41113: LD_INT 0
41115: PUSH
41116: LD_INT 0
41118: PUSH
41119: LD_INT 0
41121: PUSH
41122: LD_VAR 0 11
41126: PUSH
41127: EMPTY
41128: LIST
41129: LIST
41130: LIST
41131: LIST
41132: ST_TO_ADDR
// exit ;
41133: GO 43354
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41135: LD_EXP 140
41139: PUSH
41140: LD_EXP 139
41144: PUSH
41145: LD_VAR 0 1
41149: ARRAY
41150: ARRAY
41151: PUSH
41152: LD_EXP 113
41156: PUSH
41157: LD_VAR 0 1
41161: ARRAY
41162: PPUSH
41163: LD_INT 2
41165: PUSH
41166: LD_INT 30
41168: PUSH
41169: LD_INT 6
41171: PUSH
41172: EMPTY
41173: LIST
41174: LIST
41175: PUSH
41176: LD_INT 30
41178: PUSH
41179: LD_INT 7
41181: PUSH
41182: EMPTY
41183: LIST
41184: LIST
41185: PUSH
41186: LD_INT 30
41188: PUSH
41189: LD_INT 8
41191: PUSH
41192: EMPTY
41193: LIST
41194: LIST
41195: PUSH
41196: EMPTY
41197: LIST
41198: LIST
41199: LIST
41200: LIST
41201: PPUSH
41202: CALL_OW 72
41206: AND
41207: PUSH
41208: LD_EXP 113
41212: PUSH
41213: LD_VAR 0 1
41217: ARRAY
41218: PPUSH
41219: LD_INT 30
41221: PUSH
41222: LD_INT 3
41224: PUSH
41225: EMPTY
41226: LIST
41227: LIST
41228: PPUSH
41229: CALL_OW 72
41233: AND
41234: IFFALSE 41968
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
41236: LD_ADDR_EXP 155
41240: PUSH
41241: LD_EXP 155
41245: PPUSH
41246: LD_VAR 0 1
41250: PPUSH
41251: LD_INT 3
41253: PPUSH
41254: CALL_OW 1
41258: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41259: LD_ADDR_VAR 0 2
41263: PUSH
41264: LD_INT 0
41266: PUSH
41267: LD_INT 0
41269: PUSH
41270: LD_INT 0
41272: PUSH
41273: LD_INT 0
41275: PUSH
41276: EMPTY
41277: LIST
41278: LIST
41279: LIST
41280: LIST
41281: ST_TO_ADDR
// if not eng then
41282: LD_VAR 0 6
41286: NOT
41287: IFFALSE 41350
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41289: LD_ADDR_VAR 0 11
41293: PUSH
41294: LD_VAR 0 4
41298: PPUSH
41299: LD_INT 2
41301: PPUSH
41302: CALL 99677 0 2
41306: PUSH
41307: LD_INT 1
41309: ARRAY
41310: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41311: LD_ADDR_VAR 0 2
41315: PUSH
41316: LD_VAR 0 2
41320: PPUSH
41321: LD_INT 2
41323: PPUSH
41324: LD_VAR 0 11
41328: PPUSH
41329: CALL_OW 1
41333: ST_TO_ADDR
// tmp := tmp diff p ;
41334: LD_ADDR_VAR 0 4
41338: PUSH
41339: LD_VAR 0 4
41343: PUSH
41344: LD_VAR 0 11
41348: DIFF
41349: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41350: LD_VAR 0 4
41354: PUSH
41355: LD_VAR 0 8
41359: PUSH
41360: LD_INT 6
41362: LESS
41363: AND
41364: IFFALSE 41552
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41366: LD_ADDR_VAR 0 9
41370: PUSH
41371: LD_VAR 0 4
41375: PUSH
41376: LD_VAR 0 8
41380: PUSH
41381: LD_VAR 0 7
41385: UNION
41386: DIFF
41387: PPUSH
41388: LD_INT 4
41390: PPUSH
41391: CALL 99677 0 2
41395: ST_TO_ADDR
// p := [ ] ;
41396: LD_ADDR_VAR 0 11
41400: PUSH
41401: EMPTY
41402: ST_TO_ADDR
// if sort then
41403: LD_VAR 0 9
41407: IFFALSE 41523
// for i = 1 to 6 - sci do
41409: LD_ADDR_VAR 0 3
41413: PUSH
41414: DOUBLE
41415: LD_INT 1
41417: DEC
41418: ST_TO_ADDR
41419: LD_INT 6
41421: PUSH
41422: LD_VAR 0 8
41426: MINUS
41427: PUSH
41428: FOR_TO
41429: IFFALSE 41521
// begin if i = sort then
41431: LD_VAR 0 3
41435: PUSH
41436: LD_VAR 0 9
41440: EQUAL
41441: IFFALSE 41445
// break ;
41443: GO 41521
// if GetClass ( i ) = 4 then
41445: LD_VAR 0 3
41449: PPUSH
41450: CALL_OW 257
41454: PUSH
41455: LD_INT 4
41457: EQUAL
41458: IFFALSE 41462
// continue ;
41460: GO 41428
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41462: LD_ADDR_VAR 0 11
41466: PUSH
41467: LD_VAR 0 11
41471: PPUSH
41472: LD_VAR 0 11
41476: PUSH
41477: LD_INT 1
41479: PLUS
41480: PPUSH
41481: LD_VAR 0 9
41485: PUSH
41486: LD_VAR 0 3
41490: ARRAY
41491: PPUSH
41492: CALL_OW 2
41496: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41497: LD_ADDR_VAR 0 4
41501: PUSH
41502: LD_VAR 0 4
41506: PUSH
41507: LD_VAR 0 9
41511: PUSH
41512: LD_VAR 0 3
41516: ARRAY
41517: DIFF
41518: ST_TO_ADDR
// end ;
41519: GO 41428
41521: POP
41522: POP
// if p then
41523: LD_VAR 0 11
41527: IFFALSE 41552
// result := Replace ( result , 4 , p ) ;
41529: LD_ADDR_VAR 0 2
41533: PUSH
41534: LD_VAR 0 2
41538: PPUSH
41539: LD_INT 4
41541: PPUSH
41542: LD_VAR 0 11
41546: PPUSH
41547: CALL_OW 1
41551: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41552: LD_VAR 0 4
41556: PUSH
41557: LD_VAR 0 7
41561: PUSH
41562: LD_INT 6
41564: LESS
41565: AND
41566: IFFALSE 41754
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41568: LD_ADDR_VAR 0 9
41572: PUSH
41573: LD_VAR 0 4
41577: PUSH
41578: LD_VAR 0 8
41582: PUSH
41583: LD_VAR 0 7
41587: UNION
41588: DIFF
41589: PPUSH
41590: LD_INT 3
41592: PPUSH
41593: CALL 99677 0 2
41597: ST_TO_ADDR
// p := [ ] ;
41598: LD_ADDR_VAR 0 11
41602: PUSH
41603: EMPTY
41604: ST_TO_ADDR
// if sort then
41605: LD_VAR 0 9
41609: IFFALSE 41725
// for i = 1 to 6 - mech do
41611: LD_ADDR_VAR 0 3
41615: PUSH
41616: DOUBLE
41617: LD_INT 1
41619: DEC
41620: ST_TO_ADDR
41621: LD_INT 6
41623: PUSH
41624: LD_VAR 0 7
41628: MINUS
41629: PUSH
41630: FOR_TO
41631: IFFALSE 41723
// begin if i = sort then
41633: LD_VAR 0 3
41637: PUSH
41638: LD_VAR 0 9
41642: EQUAL
41643: IFFALSE 41647
// break ;
41645: GO 41723
// if GetClass ( i ) = 3 then
41647: LD_VAR 0 3
41651: PPUSH
41652: CALL_OW 257
41656: PUSH
41657: LD_INT 3
41659: EQUAL
41660: IFFALSE 41664
// continue ;
41662: GO 41630
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41664: LD_ADDR_VAR 0 11
41668: PUSH
41669: LD_VAR 0 11
41673: PPUSH
41674: LD_VAR 0 11
41678: PUSH
41679: LD_INT 1
41681: PLUS
41682: PPUSH
41683: LD_VAR 0 9
41687: PUSH
41688: LD_VAR 0 3
41692: ARRAY
41693: PPUSH
41694: CALL_OW 2
41698: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41699: LD_ADDR_VAR 0 4
41703: PUSH
41704: LD_VAR 0 4
41708: PUSH
41709: LD_VAR 0 9
41713: PUSH
41714: LD_VAR 0 3
41718: ARRAY
41719: DIFF
41720: ST_TO_ADDR
// end ;
41721: GO 41630
41723: POP
41724: POP
// if p then
41725: LD_VAR 0 11
41729: IFFALSE 41754
// result := Replace ( result , 3 , p ) ;
41731: LD_ADDR_VAR 0 2
41735: PUSH
41736: LD_VAR 0 2
41740: PPUSH
41741: LD_INT 3
41743: PPUSH
41744: LD_VAR 0 11
41748: PPUSH
41749: CALL_OW 1
41753: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41754: LD_VAR 0 4
41758: PUSH
41759: LD_INT 6
41761: GREATER
41762: PUSH
41763: LD_VAR 0 6
41767: PUSH
41768: LD_INT 6
41770: LESS
41771: AND
41772: IFFALSE 41966
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41774: LD_ADDR_VAR 0 9
41778: PUSH
41779: LD_VAR 0 4
41783: PUSH
41784: LD_VAR 0 8
41788: PUSH
41789: LD_VAR 0 7
41793: UNION
41794: PUSH
41795: LD_VAR 0 6
41799: UNION
41800: DIFF
41801: PPUSH
41802: LD_INT 2
41804: PPUSH
41805: CALL 99677 0 2
41809: ST_TO_ADDR
// p := [ ] ;
41810: LD_ADDR_VAR 0 11
41814: PUSH
41815: EMPTY
41816: ST_TO_ADDR
// if sort then
41817: LD_VAR 0 9
41821: IFFALSE 41937
// for i = 1 to 6 - eng do
41823: LD_ADDR_VAR 0 3
41827: PUSH
41828: DOUBLE
41829: LD_INT 1
41831: DEC
41832: ST_TO_ADDR
41833: LD_INT 6
41835: PUSH
41836: LD_VAR 0 6
41840: MINUS
41841: PUSH
41842: FOR_TO
41843: IFFALSE 41935
// begin if i = sort then
41845: LD_VAR 0 3
41849: PUSH
41850: LD_VAR 0 9
41854: EQUAL
41855: IFFALSE 41859
// break ;
41857: GO 41935
// if GetClass ( i ) = 2 then
41859: LD_VAR 0 3
41863: PPUSH
41864: CALL_OW 257
41868: PUSH
41869: LD_INT 2
41871: EQUAL
41872: IFFALSE 41876
// continue ;
41874: GO 41842
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41876: LD_ADDR_VAR 0 11
41880: PUSH
41881: LD_VAR 0 11
41885: PPUSH
41886: LD_VAR 0 11
41890: PUSH
41891: LD_INT 1
41893: PLUS
41894: PPUSH
41895: LD_VAR 0 9
41899: PUSH
41900: LD_VAR 0 3
41904: ARRAY
41905: PPUSH
41906: CALL_OW 2
41910: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41911: LD_ADDR_VAR 0 4
41915: PUSH
41916: LD_VAR 0 4
41920: PUSH
41921: LD_VAR 0 9
41925: PUSH
41926: LD_VAR 0 3
41930: ARRAY
41931: DIFF
41932: ST_TO_ADDR
// end ;
41933: GO 41842
41935: POP
41936: POP
// if p then
41937: LD_VAR 0 11
41941: IFFALSE 41966
// result := Replace ( result , 2 , p ) ;
41943: LD_ADDR_VAR 0 2
41947: PUSH
41948: LD_VAR 0 2
41952: PPUSH
41953: LD_INT 2
41955: PPUSH
41956: LD_VAR 0 11
41960: PPUSH
41961: CALL_OW 1
41965: ST_TO_ADDR
// end ; exit ;
41966: GO 43354
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
41968: LD_EXP 140
41972: PUSH
41973: LD_EXP 139
41977: PUSH
41978: LD_VAR 0 1
41982: ARRAY
41983: ARRAY
41984: NOT
41985: PUSH
41986: LD_EXP 113
41990: PUSH
41991: LD_VAR 0 1
41995: ARRAY
41996: PPUSH
41997: LD_INT 30
41999: PUSH
42000: LD_INT 3
42002: PUSH
42003: EMPTY
42004: LIST
42005: LIST
42006: PPUSH
42007: CALL_OW 72
42011: AND
42012: PUSH
42013: LD_EXP 118
42017: PUSH
42018: LD_VAR 0 1
42022: ARRAY
42023: AND
42024: IFFALSE 42632
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
42026: LD_ADDR_EXP 155
42030: PUSH
42031: LD_EXP 155
42035: PPUSH
42036: LD_VAR 0 1
42040: PPUSH
42041: LD_INT 5
42043: PPUSH
42044: CALL_OW 1
42048: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42049: LD_ADDR_VAR 0 2
42053: PUSH
42054: LD_INT 0
42056: PUSH
42057: LD_INT 0
42059: PUSH
42060: LD_INT 0
42062: PUSH
42063: LD_INT 0
42065: PUSH
42066: EMPTY
42067: LIST
42068: LIST
42069: LIST
42070: LIST
42071: ST_TO_ADDR
// if sci > 1 then
42072: LD_VAR 0 8
42076: PUSH
42077: LD_INT 1
42079: GREATER
42080: IFFALSE 42108
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
42082: LD_ADDR_VAR 0 4
42086: PUSH
42087: LD_VAR 0 4
42091: PUSH
42092: LD_VAR 0 8
42096: PUSH
42097: LD_VAR 0 8
42101: PUSH
42102: LD_INT 1
42104: ARRAY
42105: DIFF
42106: DIFF
42107: ST_TO_ADDR
// if tmp and not sci then
42108: LD_VAR 0 4
42112: PUSH
42113: LD_VAR 0 8
42117: NOT
42118: AND
42119: IFFALSE 42188
// begin sort := SortBySkill ( tmp , 4 ) ;
42121: LD_ADDR_VAR 0 9
42125: PUSH
42126: LD_VAR 0 4
42130: PPUSH
42131: LD_INT 4
42133: PPUSH
42134: CALL 99677 0 2
42138: ST_TO_ADDR
// if sort then
42139: LD_VAR 0 9
42143: IFFALSE 42159
// p := sort [ 1 ] ;
42145: LD_ADDR_VAR 0 11
42149: PUSH
42150: LD_VAR 0 9
42154: PUSH
42155: LD_INT 1
42157: ARRAY
42158: ST_TO_ADDR
// if p then
42159: LD_VAR 0 11
42163: IFFALSE 42188
// result := Replace ( result , 4 , p ) ;
42165: LD_ADDR_VAR 0 2
42169: PUSH
42170: LD_VAR 0 2
42174: PPUSH
42175: LD_INT 4
42177: PPUSH
42178: LD_VAR 0 11
42182: PPUSH
42183: CALL_OW 1
42187: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42188: LD_ADDR_VAR 0 4
42192: PUSH
42193: LD_VAR 0 4
42197: PUSH
42198: LD_VAR 0 7
42202: DIFF
42203: ST_TO_ADDR
// if tmp and mech < 6 then
42204: LD_VAR 0 4
42208: PUSH
42209: LD_VAR 0 7
42213: PUSH
42214: LD_INT 6
42216: LESS
42217: AND
42218: IFFALSE 42406
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
42220: LD_ADDR_VAR 0 9
42224: PUSH
42225: LD_VAR 0 4
42229: PUSH
42230: LD_VAR 0 8
42234: PUSH
42235: LD_VAR 0 7
42239: UNION
42240: DIFF
42241: PPUSH
42242: LD_INT 3
42244: PPUSH
42245: CALL 99677 0 2
42249: ST_TO_ADDR
// p := [ ] ;
42250: LD_ADDR_VAR 0 11
42254: PUSH
42255: EMPTY
42256: ST_TO_ADDR
// if sort then
42257: LD_VAR 0 9
42261: IFFALSE 42377
// for i = 1 to 6 - mech do
42263: LD_ADDR_VAR 0 3
42267: PUSH
42268: DOUBLE
42269: LD_INT 1
42271: DEC
42272: ST_TO_ADDR
42273: LD_INT 6
42275: PUSH
42276: LD_VAR 0 7
42280: MINUS
42281: PUSH
42282: FOR_TO
42283: IFFALSE 42375
// begin if i = sort then
42285: LD_VAR 0 3
42289: PUSH
42290: LD_VAR 0 9
42294: EQUAL
42295: IFFALSE 42299
// break ;
42297: GO 42375
// if GetClass ( i ) = 3 then
42299: LD_VAR 0 3
42303: PPUSH
42304: CALL_OW 257
42308: PUSH
42309: LD_INT 3
42311: EQUAL
42312: IFFALSE 42316
// continue ;
42314: GO 42282
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42316: LD_ADDR_VAR 0 11
42320: PUSH
42321: LD_VAR 0 11
42325: PPUSH
42326: LD_VAR 0 11
42330: PUSH
42331: LD_INT 1
42333: PLUS
42334: PPUSH
42335: LD_VAR 0 9
42339: PUSH
42340: LD_VAR 0 3
42344: ARRAY
42345: PPUSH
42346: CALL_OW 2
42350: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42351: LD_ADDR_VAR 0 4
42355: PUSH
42356: LD_VAR 0 4
42360: PUSH
42361: LD_VAR 0 9
42365: PUSH
42366: LD_VAR 0 3
42370: ARRAY
42371: DIFF
42372: ST_TO_ADDR
// end ;
42373: GO 42282
42375: POP
42376: POP
// if p then
42377: LD_VAR 0 11
42381: IFFALSE 42406
// result := Replace ( result , 3 , p ) ;
42383: LD_ADDR_VAR 0 2
42387: PUSH
42388: LD_VAR 0 2
42392: PPUSH
42393: LD_INT 3
42395: PPUSH
42396: LD_VAR 0 11
42400: PPUSH
42401: CALL_OW 1
42405: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42406: LD_ADDR_VAR 0 4
42410: PUSH
42411: LD_VAR 0 4
42415: PUSH
42416: LD_VAR 0 6
42420: DIFF
42421: ST_TO_ADDR
// if tmp and eng < 6 then
42422: LD_VAR 0 4
42426: PUSH
42427: LD_VAR 0 6
42431: PUSH
42432: LD_INT 6
42434: LESS
42435: AND
42436: IFFALSE 42630
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42438: LD_ADDR_VAR 0 9
42442: PUSH
42443: LD_VAR 0 4
42447: PUSH
42448: LD_VAR 0 8
42452: PUSH
42453: LD_VAR 0 7
42457: UNION
42458: PUSH
42459: LD_VAR 0 6
42463: UNION
42464: DIFF
42465: PPUSH
42466: LD_INT 2
42468: PPUSH
42469: CALL 99677 0 2
42473: ST_TO_ADDR
// p := [ ] ;
42474: LD_ADDR_VAR 0 11
42478: PUSH
42479: EMPTY
42480: ST_TO_ADDR
// if sort then
42481: LD_VAR 0 9
42485: IFFALSE 42601
// for i = 1 to 6 - eng do
42487: LD_ADDR_VAR 0 3
42491: PUSH
42492: DOUBLE
42493: LD_INT 1
42495: DEC
42496: ST_TO_ADDR
42497: LD_INT 6
42499: PUSH
42500: LD_VAR 0 6
42504: MINUS
42505: PUSH
42506: FOR_TO
42507: IFFALSE 42599
// begin if i = sort then
42509: LD_VAR 0 3
42513: PUSH
42514: LD_VAR 0 9
42518: EQUAL
42519: IFFALSE 42523
// break ;
42521: GO 42599
// if GetClass ( i ) = 2 then
42523: LD_VAR 0 3
42527: PPUSH
42528: CALL_OW 257
42532: PUSH
42533: LD_INT 2
42535: EQUAL
42536: IFFALSE 42540
// continue ;
42538: GO 42506
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42540: LD_ADDR_VAR 0 11
42544: PUSH
42545: LD_VAR 0 11
42549: PPUSH
42550: LD_VAR 0 11
42554: PUSH
42555: LD_INT 1
42557: PLUS
42558: PPUSH
42559: LD_VAR 0 9
42563: PUSH
42564: LD_VAR 0 3
42568: ARRAY
42569: PPUSH
42570: CALL_OW 2
42574: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42575: LD_ADDR_VAR 0 4
42579: PUSH
42580: LD_VAR 0 4
42584: PUSH
42585: LD_VAR 0 9
42589: PUSH
42590: LD_VAR 0 3
42594: ARRAY
42595: DIFF
42596: ST_TO_ADDR
// end ;
42597: GO 42506
42599: POP
42600: POP
// if p then
42601: LD_VAR 0 11
42605: IFFALSE 42630
// result := Replace ( result , 2 , p ) ;
42607: LD_ADDR_VAR 0 2
42611: PUSH
42612: LD_VAR 0 2
42616: PPUSH
42617: LD_INT 2
42619: PPUSH
42620: LD_VAR 0 11
42624: PPUSH
42625: CALL_OW 1
42629: ST_TO_ADDR
// end ; exit ;
42630: GO 43354
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42632: LD_EXP 140
42636: PUSH
42637: LD_EXP 139
42641: PUSH
42642: LD_VAR 0 1
42646: ARRAY
42647: ARRAY
42648: NOT
42649: PUSH
42650: LD_EXP 113
42654: PUSH
42655: LD_VAR 0 1
42659: ARRAY
42660: PPUSH
42661: LD_INT 30
42663: PUSH
42664: LD_INT 3
42666: PUSH
42667: EMPTY
42668: LIST
42669: LIST
42670: PPUSH
42671: CALL_OW 72
42675: AND
42676: PUSH
42677: LD_EXP 118
42681: PUSH
42682: LD_VAR 0 1
42686: ARRAY
42687: NOT
42688: AND
42689: IFFALSE 43354
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42691: LD_ADDR_EXP 155
42695: PUSH
42696: LD_EXP 155
42700: PPUSH
42701: LD_VAR 0 1
42705: PPUSH
42706: LD_INT 6
42708: PPUSH
42709: CALL_OW 1
42713: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42714: LD_ADDR_VAR 0 2
42718: PUSH
42719: LD_INT 0
42721: PUSH
42722: LD_INT 0
42724: PUSH
42725: LD_INT 0
42727: PUSH
42728: LD_INT 0
42730: PUSH
42731: EMPTY
42732: LIST
42733: LIST
42734: LIST
42735: LIST
42736: ST_TO_ADDR
// if sci >= 1 then
42737: LD_VAR 0 8
42741: PUSH
42742: LD_INT 1
42744: GREATEREQUAL
42745: IFFALSE 42767
// tmp := tmp diff sci [ 1 ] ;
42747: LD_ADDR_VAR 0 4
42751: PUSH
42752: LD_VAR 0 4
42756: PUSH
42757: LD_VAR 0 8
42761: PUSH
42762: LD_INT 1
42764: ARRAY
42765: DIFF
42766: ST_TO_ADDR
// if tmp and not sci then
42767: LD_VAR 0 4
42771: PUSH
42772: LD_VAR 0 8
42776: NOT
42777: AND
42778: IFFALSE 42847
// begin sort := SortBySkill ( tmp , 4 ) ;
42780: LD_ADDR_VAR 0 9
42784: PUSH
42785: LD_VAR 0 4
42789: PPUSH
42790: LD_INT 4
42792: PPUSH
42793: CALL 99677 0 2
42797: ST_TO_ADDR
// if sort then
42798: LD_VAR 0 9
42802: IFFALSE 42818
// p := sort [ 1 ] ;
42804: LD_ADDR_VAR 0 11
42808: PUSH
42809: LD_VAR 0 9
42813: PUSH
42814: LD_INT 1
42816: ARRAY
42817: ST_TO_ADDR
// if p then
42818: LD_VAR 0 11
42822: IFFALSE 42847
// result := Replace ( result , 4 , p ) ;
42824: LD_ADDR_VAR 0 2
42828: PUSH
42829: LD_VAR 0 2
42833: PPUSH
42834: LD_INT 4
42836: PPUSH
42837: LD_VAR 0 11
42841: PPUSH
42842: CALL_OW 1
42846: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42847: LD_ADDR_VAR 0 4
42851: PUSH
42852: LD_VAR 0 4
42856: PUSH
42857: LD_VAR 0 7
42861: DIFF
42862: ST_TO_ADDR
// if tmp and mech < 6 then
42863: LD_VAR 0 4
42867: PUSH
42868: LD_VAR 0 7
42872: PUSH
42873: LD_INT 6
42875: LESS
42876: AND
42877: IFFALSE 43059
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
42879: LD_ADDR_VAR 0 9
42883: PUSH
42884: LD_VAR 0 4
42888: PUSH
42889: LD_VAR 0 7
42893: DIFF
42894: PPUSH
42895: LD_INT 3
42897: PPUSH
42898: CALL 99677 0 2
42902: ST_TO_ADDR
// p := [ ] ;
42903: LD_ADDR_VAR 0 11
42907: PUSH
42908: EMPTY
42909: ST_TO_ADDR
// if sort then
42910: LD_VAR 0 9
42914: IFFALSE 43030
// for i = 1 to 6 - mech do
42916: LD_ADDR_VAR 0 3
42920: PUSH
42921: DOUBLE
42922: LD_INT 1
42924: DEC
42925: ST_TO_ADDR
42926: LD_INT 6
42928: PUSH
42929: LD_VAR 0 7
42933: MINUS
42934: PUSH
42935: FOR_TO
42936: IFFALSE 43028
// begin if i = sort then
42938: LD_VAR 0 3
42942: PUSH
42943: LD_VAR 0 9
42947: EQUAL
42948: IFFALSE 42952
// break ;
42950: GO 43028
// if GetClass ( i ) = 3 then
42952: LD_VAR 0 3
42956: PPUSH
42957: CALL_OW 257
42961: PUSH
42962: LD_INT 3
42964: EQUAL
42965: IFFALSE 42969
// continue ;
42967: GO 42935
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42969: LD_ADDR_VAR 0 11
42973: PUSH
42974: LD_VAR 0 11
42978: PPUSH
42979: LD_VAR 0 11
42983: PUSH
42984: LD_INT 1
42986: PLUS
42987: PPUSH
42988: LD_VAR 0 9
42992: PUSH
42993: LD_VAR 0 3
42997: ARRAY
42998: PPUSH
42999: CALL_OW 2
43003: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43004: LD_ADDR_VAR 0 4
43008: PUSH
43009: LD_VAR 0 4
43013: PUSH
43014: LD_VAR 0 9
43018: PUSH
43019: LD_VAR 0 3
43023: ARRAY
43024: DIFF
43025: ST_TO_ADDR
// end ;
43026: GO 42935
43028: POP
43029: POP
// if p then
43030: LD_VAR 0 11
43034: IFFALSE 43059
// result := Replace ( result , 3 , p ) ;
43036: LD_ADDR_VAR 0 2
43040: PUSH
43041: LD_VAR 0 2
43045: PPUSH
43046: LD_INT 3
43048: PPUSH
43049: LD_VAR 0 11
43053: PPUSH
43054: CALL_OW 1
43058: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
43059: LD_ADDR_VAR 0 4
43063: PUSH
43064: LD_VAR 0 4
43068: PUSH
43069: LD_VAR 0 6
43073: DIFF
43074: ST_TO_ADDR
// if tmp and eng < 4 then
43075: LD_VAR 0 4
43079: PUSH
43080: LD_VAR 0 6
43084: PUSH
43085: LD_INT 4
43087: LESS
43088: AND
43089: IFFALSE 43279
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
43091: LD_ADDR_VAR 0 9
43095: PUSH
43096: LD_VAR 0 4
43100: PUSH
43101: LD_VAR 0 7
43105: PUSH
43106: LD_VAR 0 6
43110: UNION
43111: DIFF
43112: PPUSH
43113: LD_INT 2
43115: PPUSH
43116: CALL 99677 0 2
43120: ST_TO_ADDR
// p := [ ] ;
43121: LD_ADDR_VAR 0 11
43125: PUSH
43126: EMPTY
43127: ST_TO_ADDR
// if sort then
43128: LD_VAR 0 9
43132: IFFALSE 43248
// for i = 1 to 4 - eng do
43134: LD_ADDR_VAR 0 3
43138: PUSH
43139: DOUBLE
43140: LD_INT 1
43142: DEC
43143: ST_TO_ADDR
43144: LD_INT 4
43146: PUSH
43147: LD_VAR 0 6
43151: MINUS
43152: PUSH
43153: FOR_TO
43154: IFFALSE 43246
// begin if i = sort then
43156: LD_VAR 0 3
43160: PUSH
43161: LD_VAR 0 9
43165: EQUAL
43166: IFFALSE 43170
// break ;
43168: GO 43246
// if GetClass ( i ) = 2 then
43170: LD_VAR 0 3
43174: PPUSH
43175: CALL_OW 257
43179: PUSH
43180: LD_INT 2
43182: EQUAL
43183: IFFALSE 43187
// continue ;
43185: GO 43153
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43187: LD_ADDR_VAR 0 11
43191: PUSH
43192: LD_VAR 0 11
43196: PPUSH
43197: LD_VAR 0 11
43201: PUSH
43202: LD_INT 1
43204: PLUS
43205: PPUSH
43206: LD_VAR 0 9
43210: PUSH
43211: LD_VAR 0 3
43215: ARRAY
43216: PPUSH
43217: CALL_OW 2
43221: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43222: LD_ADDR_VAR 0 4
43226: PUSH
43227: LD_VAR 0 4
43231: PUSH
43232: LD_VAR 0 9
43236: PUSH
43237: LD_VAR 0 3
43241: ARRAY
43242: DIFF
43243: ST_TO_ADDR
// end ;
43244: GO 43153
43246: POP
43247: POP
// if p then
43248: LD_VAR 0 11
43252: IFFALSE 43277
// result := Replace ( result , 2 , p ) ;
43254: LD_ADDR_VAR 0 2
43258: PUSH
43259: LD_VAR 0 2
43263: PPUSH
43264: LD_INT 2
43266: PPUSH
43267: LD_VAR 0 11
43271: PPUSH
43272: CALL_OW 1
43276: ST_TO_ADDR
// end else
43277: GO 43323
// for i = eng downto 5 do
43279: LD_ADDR_VAR 0 3
43283: PUSH
43284: DOUBLE
43285: LD_VAR 0 6
43289: INC
43290: ST_TO_ADDR
43291: LD_INT 5
43293: PUSH
43294: FOR_DOWNTO
43295: IFFALSE 43321
// tmp := tmp union eng [ i ] ;
43297: LD_ADDR_VAR 0 4
43301: PUSH
43302: LD_VAR 0 4
43306: PUSH
43307: LD_VAR 0 6
43311: PUSH
43312: LD_VAR 0 3
43316: ARRAY
43317: UNION
43318: ST_TO_ADDR
43319: GO 43294
43321: POP
43322: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43323: LD_ADDR_VAR 0 2
43327: PUSH
43328: LD_VAR 0 2
43332: PPUSH
43333: LD_INT 1
43335: PPUSH
43336: LD_VAR 0 4
43340: PUSH
43341: LD_VAR 0 5
43345: DIFF
43346: PPUSH
43347: CALL_OW 1
43351: ST_TO_ADDR
// exit ;
43352: GO 43354
// end ; end ;
43354: LD_VAR 0 2
43358: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43359: LD_INT 0
43361: PPUSH
43362: PPUSH
43363: PPUSH
// if not mc_bases then
43364: LD_EXP 113
43368: NOT
43369: IFFALSE 43373
// exit ;
43371: GO 43479
// for i = 1 to mc_bases do
43373: LD_ADDR_VAR 0 2
43377: PUSH
43378: DOUBLE
43379: LD_INT 1
43381: DEC
43382: ST_TO_ADDR
43383: LD_EXP 113
43387: PUSH
43388: FOR_TO
43389: IFFALSE 43470
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43391: LD_ADDR_VAR 0 3
43395: PUSH
43396: LD_EXP 113
43400: PUSH
43401: LD_VAR 0 2
43405: ARRAY
43406: PPUSH
43407: LD_INT 21
43409: PUSH
43410: LD_INT 3
43412: PUSH
43413: EMPTY
43414: LIST
43415: LIST
43416: PUSH
43417: LD_INT 3
43419: PUSH
43420: LD_INT 24
43422: PUSH
43423: LD_INT 1000
43425: PUSH
43426: EMPTY
43427: LIST
43428: LIST
43429: PUSH
43430: EMPTY
43431: LIST
43432: LIST
43433: PUSH
43434: EMPTY
43435: LIST
43436: LIST
43437: PPUSH
43438: CALL_OW 72
43442: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43443: LD_ADDR_EXP 114
43447: PUSH
43448: LD_EXP 114
43452: PPUSH
43453: LD_VAR 0 2
43457: PPUSH
43458: LD_VAR 0 3
43462: PPUSH
43463: CALL_OW 1
43467: ST_TO_ADDR
// end ;
43468: GO 43388
43470: POP
43471: POP
// RaiseSailEvent ( 101 ) ;
43472: LD_INT 101
43474: PPUSH
43475: CALL_OW 427
// end ;
43479: LD_VAR 0 1
43483: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43484: LD_INT 0
43486: PPUSH
43487: PPUSH
43488: PPUSH
43489: PPUSH
43490: PPUSH
43491: PPUSH
43492: PPUSH
// if not mc_bases then
43493: LD_EXP 113
43497: NOT
43498: IFFALSE 43502
// exit ;
43500: GO 44064
// for i = 1 to mc_bases do
43502: LD_ADDR_VAR 0 2
43506: PUSH
43507: DOUBLE
43508: LD_INT 1
43510: DEC
43511: ST_TO_ADDR
43512: LD_EXP 113
43516: PUSH
43517: FOR_TO
43518: IFFALSE 44055
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
43520: LD_ADDR_VAR 0 5
43524: PUSH
43525: LD_EXP 113
43529: PUSH
43530: LD_VAR 0 2
43534: ARRAY
43535: PUSH
43536: LD_EXP 142
43540: PUSH
43541: LD_VAR 0 2
43545: ARRAY
43546: UNION
43547: PPUSH
43548: LD_INT 21
43550: PUSH
43551: LD_INT 1
43553: PUSH
43554: EMPTY
43555: LIST
43556: LIST
43557: PUSH
43558: LD_INT 1
43560: PUSH
43561: LD_INT 3
43563: PUSH
43564: LD_INT 54
43566: PUSH
43567: EMPTY
43568: LIST
43569: PUSH
43570: EMPTY
43571: LIST
43572: LIST
43573: PUSH
43574: LD_INT 3
43576: PUSH
43577: LD_INT 24
43579: PUSH
43580: LD_INT 800
43582: PUSH
43583: EMPTY
43584: LIST
43585: LIST
43586: PUSH
43587: EMPTY
43588: LIST
43589: LIST
43590: PUSH
43591: EMPTY
43592: LIST
43593: LIST
43594: LIST
43595: PUSH
43596: EMPTY
43597: LIST
43598: LIST
43599: PPUSH
43600: CALL_OW 72
43604: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43605: LD_ADDR_VAR 0 6
43609: PUSH
43610: LD_EXP 113
43614: PUSH
43615: LD_VAR 0 2
43619: ARRAY
43620: PPUSH
43621: LD_INT 21
43623: PUSH
43624: LD_INT 1
43626: PUSH
43627: EMPTY
43628: LIST
43629: LIST
43630: PUSH
43631: LD_INT 1
43633: PUSH
43634: LD_INT 3
43636: PUSH
43637: LD_INT 54
43639: PUSH
43640: EMPTY
43641: LIST
43642: PUSH
43643: EMPTY
43644: LIST
43645: LIST
43646: PUSH
43647: LD_INT 3
43649: PUSH
43650: LD_INT 24
43652: PUSH
43653: LD_INT 250
43655: PUSH
43656: EMPTY
43657: LIST
43658: LIST
43659: PUSH
43660: EMPTY
43661: LIST
43662: LIST
43663: PUSH
43664: EMPTY
43665: LIST
43666: LIST
43667: LIST
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: PPUSH
43673: CALL_OW 72
43677: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43678: LD_ADDR_VAR 0 7
43682: PUSH
43683: LD_VAR 0 5
43687: PUSH
43688: LD_VAR 0 6
43692: DIFF
43693: ST_TO_ADDR
// if not need_heal_1 then
43694: LD_VAR 0 6
43698: NOT
43699: IFFALSE 43732
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43701: LD_ADDR_EXP 116
43705: PUSH
43706: LD_EXP 116
43710: PPUSH
43711: LD_VAR 0 2
43715: PUSH
43716: LD_INT 1
43718: PUSH
43719: EMPTY
43720: LIST
43721: LIST
43722: PPUSH
43723: EMPTY
43724: PPUSH
43725: CALL 70128 0 3
43729: ST_TO_ADDR
43730: GO 43802
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43732: LD_ADDR_EXP 116
43736: PUSH
43737: LD_EXP 116
43741: PPUSH
43742: LD_VAR 0 2
43746: PUSH
43747: LD_INT 1
43749: PUSH
43750: EMPTY
43751: LIST
43752: LIST
43753: PPUSH
43754: LD_EXP 116
43758: PUSH
43759: LD_VAR 0 2
43763: ARRAY
43764: PUSH
43765: LD_INT 1
43767: ARRAY
43768: PPUSH
43769: LD_INT 3
43771: PUSH
43772: LD_INT 24
43774: PUSH
43775: LD_INT 1000
43777: PUSH
43778: EMPTY
43779: LIST
43780: LIST
43781: PUSH
43782: EMPTY
43783: LIST
43784: LIST
43785: PPUSH
43786: CALL_OW 72
43790: PUSH
43791: LD_VAR 0 6
43795: UNION
43796: PPUSH
43797: CALL 70128 0 3
43801: ST_TO_ADDR
// if not need_heal_2 then
43802: LD_VAR 0 7
43806: NOT
43807: IFFALSE 43840
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
43809: LD_ADDR_EXP 116
43813: PUSH
43814: LD_EXP 116
43818: PPUSH
43819: LD_VAR 0 2
43823: PUSH
43824: LD_INT 2
43826: PUSH
43827: EMPTY
43828: LIST
43829: LIST
43830: PPUSH
43831: EMPTY
43832: PPUSH
43833: CALL 70128 0 3
43837: ST_TO_ADDR
43838: GO 43872
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
43840: LD_ADDR_EXP 116
43844: PUSH
43845: LD_EXP 116
43849: PPUSH
43850: LD_VAR 0 2
43854: PUSH
43855: LD_INT 2
43857: PUSH
43858: EMPTY
43859: LIST
43860: LIST
43861: PPUSH
43862: LD_VAR 0 7
43866: PPUSH
43867: CALL 70128 0 3
43871: ST_TO_ADDR
// if need_heal_2 then
43872: LD_VAR 0 7
43876: IFFALSE 44037
// for j in need_heal_2 do
43878: LD_ADDR_VAR 0 3
43882: PUSH
43883: LD_VAR 0 7
43887: PUSH
43888: FOR_IN
43889: IFFALSE 44035
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43891: LD_ADDR_VAR 0 5
43895: PUSH
43896: LD_EXP 113
43900: PUSH
43901: LD_VAR 0 2
43905: ARRAY
43906: PPUSH
43907: LD_INT 2
43909: PUSH
43910: LD_INT 30
43912: PUSH
43913: LD_INT 6
43915: PUSH
43916: EMPTY
43917: LIST
43918: LIST
43919: PUSH
43920: LD_INT 30
43922: PUSH
43923: LD_INT 7
43925: PUSH
43926: EMPTY
43927: LIST
43928: LIST
43929: PUSH
43930: LD_INT 30
43932: PUSH
43933: LD_INT 8
43935: PUSH
43936: EMPTY
43937: LIST
43938: LIST
43939: PUSH
43940: LD_INT 30
43942: PUSH
43943: LD_INT 0
43945: PUSH
43946: EMPTY
43947: LIST
43948: LIST
43949: PUSH
43950: LD_INT 30
43952: PUSH
43953: LD_INT 1
43955: PUSH
43956: EMPTY
43957: LIST
43958: LIST
43959: PUSH
43960: EMPTY
43961: LIST
43962: LIST
43963: LIST
43964: LIST
43965: LIST
43966: LIST
43967: PPUSH
43968: CALL_OW 72
43972: ST_TO_ADDR
// if tmp then
43973: LD_VAR 0 5
43977: IFFALSE 44033
// begin k := NearestUnitToUnit ( tmp , j ) ;
43979: LD_ADDR_VAR 0 4
43983: PUSH
43984: LD_VAR 0 5
43988: PPUSH
43989: LD_VAR 0 3
43993: PPUSH
43994: CALL_OW 74
43998: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
43999: LD_VAR 0 3
44003: PPUSH
44004: LD_VAR 0 4
44008: PPUSH
44009: CALL_OW 296
44013: PUSH
44014: LD_INT 5
44016: GREATER
44017: IFFALSE 44033
// ComMoveToNearbyEntrance ( j , k ) ;
44019: LD_VAR 0 3
44023: PPUSH
44024: LD_VAR 0 4
44028: PPUSH
44029: CALL 101994 0 2
// end ; end ;
44033: GO 43888
44035: POP
44036: POP
// if not need_heal_1 and not need_heal_2 then
44037: LD_VAR 0 6
44041: NOT
44042: PUSH
44043: LD_VAR 0 7
44047: NOT
44048: AND
44049: IFFALSE 44053
// continue ;
44051: GO 43517
// end ;
44053: GO 43517
44055: POP
44056: POP
// RaiseSailEvent ( 102 ) ;
44057: LD_INT 102
44059: PPUSH
44060: CALL_OW 427
// end ;
44064: LD_VAR 0 1
44068: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
44069: LD_INT 0
44071: PPUSH
44072: PPUSH
44073: PPUSH
44074: PPUSH
44075: PPUSH
44076: PPUSH
44077: PPUSH
44078: PPUSH
// if not mc_bases then
44079: LD_EXP 113
44083: NOT
44084: IFFALSE 44088
// exit ;
44086: GO 44949
// for i = 1 to mc_bases do
44088: LD_ADDR_VAR 0 2
44092: PUSH
44093: DOUBLE
44094: LD_INT 1
44096: DEC
44097: ST_TO_ADDR
44098: LD_EXP 113
44102: PUSH
44103: FOR_TO
44104: IFFALSE 44947
// begin if not mc_building_need_repair [ i ] then
44106: LD_EXP 114
44110: PUSH
44111: LD_VAR 0 2
44115: ARRAY
44116: NOT
44117: IFFALSE 44304
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
44119: LD_ADDR_VAR 0 6
44123: PUSH
44124: LD_EXP 132
44128: PUSH
44129: LD_VAR 0 2
44133: ARRAY
44134: PPUSH
44135: LD_INT 3
44137: PUSH
44138: LD_INT 24
44140: PUSH
44141: LD_INT 1000
44143: PUSH
44144: EMPTY
44145: LIST
44146: LIST
44147: PUSH
44148: EMPTY
44149: LIST
44150: LIST
44151: PUSH
44152: LD_INT 2
44154: PUSH
44155: LD_INT 34
44157: PUSH
44158: LD_INT 13
44160: PUSH
44161: EMPTY
44162: LIST
44163: LIST
44164: PUSH
44165: LD_INT 34
44167: PUSH
44168: LD_INT 52
44170: PUSH
44171: EMPTY
44172: LIST
44173: LIST
44174: PUSH
44175: LD_INT 34
44177: PUSH
44178: LD_EXP 101
44182: PUSH
44183: EMPTY
44184: LIST
44185: LIST
44186: PUSH
44187: EMPTY
44188: LIST
44189: LIST
44190: LIST
44191: LIST
44192: PUSH
44193: EMPTY
44194: LIST
44195: LIST
44196: PPUSH
44197: CALL_OW 72
44201: ST_TO_ADDR
// if cranes then
44202: LD_VAR 0 6
44206: IFFALSE 44268
// for j in cranes do
44208: LD_ADDR_VAR 0 3
44212: PUSH
44213: LD_VAR 0 6
44217: PUSH
44218: FOR_IN
44219: IFFALSE 44266
// if not IsInArea ( j , mc_parking [ i ] ) then
44221: LD_VAR 0 3
44225: PPUSH
44226: LD_EXP 137
44230: PUSH
44231: LD_VAR 0 2
44235: ARRAY
44236: PPUSH
44237: CALL_OW 308
44241: NOT
44242: IFFALSE 44264
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44244: LD_VAR 0 3
44248: PPUSH
44249: LD_EXP 137
44253: PUSH
44254: LD_VAR 0 2
44258: ARRAY
44259: PPUSH
44260: CALL_OW 113
44264: GO 44218
44266: POP
44267: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44268: LD_ADDR_EXP 115
44272: PUSH
44273: LD_EXP 115
44277: PPUSH
44278: LD_VAR 0 2
44282: PPUSH
44283: EMPTY
44284: PPUSH
44285: CALL_OW 1
44289: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44290: LD_VAR 0 2
44294: PPUSH
44295: LD_INT 101
44297: PPUSH
44298: CALL 39192 0 2
// continue ;
44302: GO 44103
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44304: LD_ADDR_EXP 119
44308: PUSH
44309: LD_EXP 119
44313: PPUSH
44314: LD_VAR 0 2
44318: PPUSH
44319: EMPTY
44320: PPUSH
44321: CALL_OW 1
44325: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44326: LD_VAR 0 2
44330: PPUSH
44331: LD_INT 103
44333: PPUSH
44334: CALL 39192 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
44338: LD_ADDR_VAR 0 5
44342: PUSH
44343: LD_EXP 113
44347: PUSH
44348: LD_VAR 0 2
44352: ARRAY
44353: PUSH
44354: LD_EXP 142
44358: PUSH
44359: LD_VAR 0 2
44363: ARRAY
44364: UNION
44365: PPUSH
44366: LD_INT 2
44368: PUSH
44369: LD_INT 25
44371: PUSH
44372: LD_INT 2
44374: PUSH
44375: EMPTY
44376: LIST
44377: LIST
44378: PUSH
44379: LD_INT 25
44381: PUSH
44382: LD_INT 16
44384: PUSH
44385: EMPTY
44386: LIST
44387: LIST
44388: PUSH
44389: EMPTY
44390: LIST
44391: LIST
44392: LIST
44393: PUSH
44394: EMPTY
44395: LIST
44396: PPUSH
44397: CALL_OW 72
44401: PUSH
44402: LD_EXP 116
44406: PUSH
44407: LD_VAR 0 2
44411: ARRAY
44412: PUSH
44413: LD_INT 1
44415: ARRAY
44416: PUSH
44417: LD_EXP 116
44421: PUSH
44422: LD_VAR 0 2
44426: ARRAY
44427: PUSH
44428: LD_INT 2
44430: ARRAY
44431: UNION
44432: DIFF
44433: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
44434: LD_ADDR_VAR 0 6
44438: PUSH
44439: LD_EXP 132
44443: PUSH
44444: LD_VAR 0 2
44448: ARRAY
44449: PPUSH
44450: LD_INT 2
44452: PUSH
44453: LD_INT 34
44455: PUSH
44456: LD_INT 13
44458: PUSH
44459: EMPTY
44460: LIST
44461: LIST
44462: PUSH
44463: LD_INT 34
44465: PUSH
44466: LD_INT 52
44468: PUSH
44469: EMPTY
44470: LIST
44471: LIST
44472: PUSH
44473: LD_INT 34
44475: PUSH
44476: LD_EXP 101
44480: PUSH
44481: EMPTY
44482: LIST
44483: LIST
44484: PUSH
44485: EMPTY
44486: LIST
44487: LIST
44488: LIST
44489: LIST
44490: PPUSH
44491: CALL_OW 72
44495: ST_TO_ADDR
// if cranes then
44496: LD_VAR 0 6
44500: IFFALSE 44636
// begin for j in cranes do
44502: LD_ADDR_VAR 0 3
44506: PUSH
44507: LD_VAR 0 6
44511: PUSH
44512: FOR_IN
44513: IFFALSE 44634
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
44515: LD_VAR 0 3
44519: PPUSH
44520: CALL_OW 256
44524: PUSH
44525: LD_INT 1000
44527: EQUAL
44528: PUSH
44529: LD_VAR 0 3
44533: PPUSH
44534: CALL_OW 314
44538: NOT
44539: AND
44540: IFFALSE 44574
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44542: LD_VAR 0 3
44546: PPUSH
44547: LD_EXP 114
44551: PUSH
44552: LD_VAR 0 2
44556: ARRAY
44557: PPUSH
44558: LD_VAR 0 3
44562: PPUSH
44563: CALL_OW 74
44567: PPUSH
44568: CALL_OW 130
44572: GO 44632
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44574: LD_VAR 0 3
44578: PPUSH
44579: CALL_OW 256
44583: PUSH
44584: LD_INT 500
44586: LESS
44587: PUSH
44588: LD_VAR 0 3
44592: PPUSH
44593: LD_EXP 137
44597: PUSH
44598: LD_VAR 0 2
44602: ARRAY
44603: PPUSH
44604: CALL_OW 308
44608: NOT
44609: AND
44610: IFFALSE 44632
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44612: LD_VAR 0 3
44616: PPUSH
44617: LD_EXP 137
44621: PUSH
44622: LD_VAR 0 2
44626: ARRAY
44627: PPUSH
44628: CALL_OW 113
// end ;
44632: GO 44512
44634: POP
44635: POP
// end ; if tmp > 3 then
44636: LD_VAR 0 5
44640: PUSH
44641: LD_INT 3
44643: GREATER
44644: IFFALSE 44664
// tmp := ShrinkArray ( tmp , 4 ) ;
44646: LD_ADDR_VAR 0 5
44650: PUSH
44651: LD_VAR 0 5
44655: PPUSH
44656: LD_INT 4
44658: PPUSH
44659: CALL 101486 0 2
44663: ST_TO_ADDR
// if not tmp then
44664: LD_VAR 0 5
44668: NOT
44669: IFFALSE 44673
// continue ;
44671: GO 44103
// for j in tmp do
44673: LD_ADDR_VAR 0 3
44677: PUSH
44678: LD_VAR 0 5
44682: PUSH
44683: FOR_IN
44684: IFFALSE 44943
// begin if IsInUnit ( j ) then
44686: LD_VAR 0 3
44690: PPUSH
44691: CALL_OW 310
44695: IFFALSE 44706
// ComExitBuilding ( j ) ;
44697: LD_VAR 0 3
44701: PPUSH
44702: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44706: LD_VAR 0 3
44710: PUSH
44711: LD_EXP 115
44715: PUSH
44716: LD_VAR 0 2
44720: ARRAY
44721: IN
44722: NOT
44723: IFFALSE 44781
// begin SetTag ( j , 101 ) ;
44725: LD_VAR 0 3
44729: PPUSH
44730: LD_INT 101
44732: PPUSH
44733: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
44737: LD_ADDR_EXP 115
44741: PUSH
44742: LD_EXP 115
44746: PPUSH
44747: LD_VAR 0 2
44751: PUSH
44752: LD_EXP 115
44756: PUSH
44757: LD_VAR 0 2
44761: ARRAY
44762: PUSH
44763: LD_INT 1
44765: PLUS
44766: PUSH
44767: EMPTY
44768: LIST
44769: LIST
44770: PPUSH
44771: LD_VAR 0 3
44775: PPUSH
44776: CALL 70128 0 3
44780: ST_TO_ADDR
// end ; wait ( 1 ) ;
44781: LD_INT 1
44783: PPUSH
44784: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
44788: LD_ADDR_VAR 0 7
44792: PUSH
44793: LD_EXP 114
44797: PUSH
44798: LD_VAR 0 2
44802: ARRAY
44803: ST_TO_ADDR
// if mc_scan [ i ] then
44804: LD_EXP 136
44808: PUSH
44809: LD_VAR 0 2
44813: ARRAY
44814: IFFALSE 44876
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
44816: LD_ADDR_VAR 0 7
44820: PUSH
44821: LD_EXP 114
44825: PUSH
44826: LD_VAR 0 2
44830: ARRAY
44831: PPUSH
44832: LD_INT 3
44834: PUSH
44835: LD_INT 30
44837: PUSH
44838: LD_INT 32
44840: PUSH
44841: EMPTY
44842: LIST
44843: LIST
44844: PUSH
44845: LD_INT 30
44847: PUSH
44848: LD_INT 33
44850: PUSH
44851: EMPTY
44852: LIST
44853: LIST
44854: PUSH
44855: LD_INT 30
44857: PUSH
44858: LD_INT 31
44860: PUSH
44861: EMPTY
44862: LIST
44863: LIST
44864: PUSH
44865: EMPTY
44866: LIST
44867: LIST
44868: LIST
44869: LIST
44870: PPUSH
44871: CALL_OW 72
44875: ST_TO_ADDR
// if not to_repair_tmp then
44876: LD_VAR 0 7
44880: NOT
44881: IFFALSE 44885
// continue ;
44883: GO 44683
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
44885: LD_ADDR_VAR 0 8
44889: PUSH
44890: LD_VAR 0 7
44894: PPUSH
44895: LD_VAR 0 3
44899: PPUSH
44900: CALL_OW 74
44904: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
44905: LD_VAR 0 8
44909: PPUSH
44910: LD_INT 16
44912: PPUSH
44913: CALL 72721 0 2
44917: PUSH
44918: LD_INT 4
44920: ARRAY
44921: PUSH
44922: LD_INT 10
44924: LESS
44925: IFFALSE 44941
// ComRepairBuilding ( j , to_repair ) ;
44927: LD_VAR 0 3
44931: PPUSH
44932: LD_VAR 0 8
44936: PPUSH
44937: CALL_OW 130
// end ;
44941: GO 44683
44943: POP
44944: POP
// end ;
44945: GO 44103
44947: POP
44948: POP
// end ;
44949: LD_VAR 0 1
44953: RET
// export function MC_Heal ; var i , j , tmp ; begin
44954: LD_INT 0
44956: PPUSH
44957: PPUSH
44958: PPUSH
44959: PPUSH
// if not mc_bases then
44960: LD_EXP 113
44964: NOT
44965: IFFALSE 44969
// exit ;
44967: GO 45371
// for i = 1 to mc_bases do
44969: LD_ADDR_VAR 0 2
44973: PUSH
44974: DOUBLE
44975: LD_INT 1
44977: DEC
44978: ST_TO_ADDR
44979: LD_EXP 113
44983: PUSH
44984: FOR_TO
44985: IFFALSE 45369
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
44987: LD_EXP 116
44991: PUSH
44992: LD_VAR 0 2
44996: ARRAY
44997: PUSH
44998: LD_INT 1
45000: ARRAY
45001: NOT
45002: PUSH
45003: LD_EXP 116
45007: PUSH
45008: LD_VAR 0 2
45012: ARRAY
45013: PUSH
45014: LD_INT 2
45016: ARRAY
45017: NOT
45018: AND
45019: IFFALSE 45057
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
45021: LD_ADDR_EXP 117
45025: PUSH
45026: LD_EXP 117
45030: PPUSH
45031: LD_VAR 0 2
45035: PPUSH
45036: EMPTY
45037: PPUSH
45038: CALL_OW 1
45042: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
45043: LD_VAR 0 2
45047: PPUSH
45048: LD_INT 102
45050: PPUSH
45051: CALL 39192 0 2
// continue ;
45055: GO 44984
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
45057: LD_ADDR_VAR 0 4
45061: PUSH
45062: LD_EXP 113
45066: PUSH
45067: LD_VAR 0 2
45071: ARRAY
45072: PPUSH
45073: LD_INT 25
45075: PUSH
45076: LD_INT 4
45078: PUSH
45079: EMPTY
45080: LIST
45081: LIST
45082: PPUSH
45083: CALL_OW 72
45087: ST_TO_ADDR
// if not tmp then
45088: LD_VAR 0 4
45092: NOT
45093: IFFALSE 45097
// continue ;
45095: GO 44984
// if mc_taming [ i ] then
45097: LD_EXP 144
45101: PUSH
45102: LD_VAR 0 2
45106: ARRAY
45107: IFFALSE 45131
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
45109: LD_ADDR_EXP 144
45113: PUSH
45114: LD_EXP 144
45118: PPUSH
45119: LD_VAR 0 2
45123: PPUSH
45124: EMPTY
45125: PPUSH
45126: CALL_OW 1
45130: ST_TO_ADDR
// for j in tmp do
45131: LD_ADDR_VAR 0 3
45135: PUSH
45136: LD_VAR 0 4
45140: PUSH
45141: FOR_IN
45142: IFFALSE 45365
// begin if IsInUnit ( j ) then
45144: LD_VAR 0 3
45148: PPUSH
45149: CALL_OW 310
45153: IFFALSE 45164
// ComExitBuilding ( j ) ;
45155: LD_VAR 0 3
45159: PPUSH
45160: CALL_OW 122
// if not j in mc_healers [ i ] then
45164: LD_VAR 0 3
45168: PUSH
45169: LD_EXP 117
45173: PUSH
45174: LD_VAR 0 2
45178: ARRAY
45179: IN
45180: NOT
45181: IFFALSE 45227
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
45183: LD_ADDR_EXP 117
45187: PUSH
45188: LD_EXP 117
45192: PPUSH
45193: LD_VAR 0 2
45197: PUSH
45198: LD_EXP 117
45202: PUSH
45203: LD_VAR 0 2
45207: ARRAY
45208: PUSH
45209: LD_INT 1
45211: PLUS
45212: PUSH
45213: EMPTY
45214: LIST
45215: LIST
45216: PPUSH
45217: LD_VAR 0 3
45221: PPUSH
45222: CALL 70128 0 3
45226: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
45227: LD_VAR 0 3
45231: PPUSH
45232: CALL_OW 110
45236: PUSH
45237: LD_INT 102
45239: NONEQUAL
45240: IFFALSE 45254
// SetTag ( j , 102 ) ;
45242: LD_VAR 0 3
45246: PPUSH
45247: LD_INT 102
45249: PPUSH
45250: CALL_OW 109
// Wait ( 3 ) ;
45254: LD_INT 3
45256: PPUSH
45257: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
45261: LD_EXP 116
45265: PUSH
45266: LD_VAR 0 2
45270: ARRAY
45271: PUSH
45272: LD_INT 1
45274: ARRAY
45275: IFFALSE 45307
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45277: LD_VAR 0 3
45281: PPUSH
45282: LD_EXP 116
45286: PUSH
45287: LD_VAR 0 2
45291: ARRAY
45292: PUSH
45293: LD_INT 1
45295: ARRAY
45296: PUSH
45297: LD_INT 1
45299: ARRAY
45300: PPUSH
45301: CALL_OW 128
45305: GO 45363
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45307: LD_VAR 0 3
45311: PPUSH
45312: CALL_OW 314
45316: NOT
45317: PUSH
45318: LD_EXP 116
45322: PUSH
45323: LD_VAR 0 2
45327: ARRAY
45328: PUSH
45329: LD_INT 2
45331: ARRAY
45332: AND
45333: IFFALSE 45363
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45335: LD_VAR 0 3
45339: PPUSH
45340: LD_EXP 116
45344: PUSH
45345: LD_VAR 0 2
45349: ARRAY
45350: PUSH
45351: LD_INT 2
45353: ARRAY
45354: PUSH
45355: LD_INT 1
45357: ARRAY
45358: PPUSH
45359: CALL_OW 128
// end ;
45363: GO 45141
45365: POP
45366: POP
// end ;
45367: GO 44984
45369: POP
45370: POP
// end ;
45371: LD_VAR 0 1
45375: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45376: LD_INT 0
45378: PPUSH
45379: PPUSH
45380: PPUSH
45381: PPUSH
45382: PPUSH
// if not mc_bases then
45383: LD_EXP 113
45387: NOT
45388: IFFALSE 45392
// exit ;
45390: GO 46535
// for i = 1 to mc_bases do
45392: LD_ADDR_VAR 0 2
45396: PUSH
45397: DOUBLE
45398: LD_INT 1
45400: DEC
45401: ST_TO_ADDR
45402: LD_EXP 113
45406: PUSH
45407: FOR_TO
45408: IFFALSE 46533
// begin if mc_scan [ i ] then
45410: LD_EXP 136
45414: PUSH
45415: LD_VAR 0 2
45419: ARRAY
45420: IFFALSE 45424
// continue ;
45422: GO 45407
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45424: LD_EXP 118
45428: PUSH
45429: LD_VAR 0 2
45433: ARRAY
45434: NOT
45435: PUSH
45436: LD_EXP 120
45440: PUSH
45441: LD_VAR 0 2
45445: ARRAY
45446: NOT
45447: AND
45448: PUSH
45449: LD_EXP 119
45453: PUSH
45454: LD_VAR 0 2
45458: ARRAY
45459: AND
45460: IFFALSE 45498
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45462: LD_ADDR_EXP 119
45466: PUSH
45467: LD_EXP 119
45471: PPUSH
45472: LD_VAR 0 2
45476: PPUSH
45477: EMPTY
45478: PPUSH
45479: CALL_OW 1
45483: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45484: LD_VAR 0 2
45488: PPUSH
45489: LD_INT 103
45491: PPUSH
45492: CALL 39192 0 2
// continue ;
45496: GO 45407
// end ; if mc_construct_list [ i ] then
45498: LD_EXP 120
45502: PUSH
45503: LD_VAR 0 2
45507: ARRAY
45508: IFFALSE 45728
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45510: LD_ADDR_VAR 0 4
45514: PUSH
45515: LD_EXP 113
45519: PUSH
45520: LD_VAR 0 2
45524: ARRAY
45525: PPUSH
45526: LD_INT 25
45528: PUSH
45529: LD_INT 2
45531: PUSH
45532: EMPTY
45533: LIST
45534: LIST
45535: PPUSH
45536: CALL_OW 72
45540: PUSH
45541: LD_EXP 115
45545: PUSH
45546: LD_VAR 0 2
45550: ARRAY
45551: DIFF
45552: ST_TO_ADDR
// if not tmp then
45553: LD_VAR 0 4
45557: NOT
45558: IFFALSE 45562
// continue ;
45560: GO 45407
// for j in tmp do
45562: LD_ADDR_VAR 0 3
45566: PUSH
45567: LD_VAR 0 4
45571: PUSH
45572: FOR_IN
45573: IFFALSE 45724
// begin if not mc_builders [ i ] then
45575: LD_EXP 119
45579: PUSH
45580: LD_VAR 0 2
45584: ARRAY
45585: NOT
45586: IFFALSE 45644
// begin SetTag ( j , 103 ) ;
45588: LD_VAR 0 3
45592: PPUSH
45593: LD_INT 103
45595: PPUSH
45596: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45600: LD_ADDR_EXP 119
45604: PUSH
45605: LD_EXP 119
45609: PPUSH
45610: LD_VAR 0 2
45614: PUSH
45615: LD_EXP 119
45619: PUSH
45620: LD_VAR 0 2
45624: ARRAY
45625: PUSH
45626: LD_INT 1
45628: PLUS
45629: PUSH
45630: EMPTY
45631: LIST
45632: LIST
45633: PPUSH
45634: LD_VAR 0 3
45638: PPUSH
45639: CALL 70128 0 3
45643: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45644: LD_VAR 0 3
45648: PPUSH
45649: CALL_OW 310
45653: IFFALSE 45664
// ComExitBuilding ( j ) ;
45655: LD_VAR 0 3
45659: PPUSH
45660: CALL_OW 122
// wait ( 3 ) ;
45664: LD_INT 3
45666: PPUSH
45667: CALL_OW 67
// if not mc_construct_list [ i ] then
45671: LD_EXP 120
45675: PUSH
45676: LD_VAR 0 2
45680: ARRAY
45681: NOT
45682: IFFALSE 45686
// break ;
45684: GO 45724
// if not HasTask ( j ) then
45686: LD_VAR 0 3
45690: PPUSH
45691: CALL_OW 314
45695: NOT
45696: IFFALSE 45722
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45698: LD_VAR 0 3
45702: PPUSH
45703: LD_EXP 120
45707: PUSH
45708: LD_VAR 0 2
45712: ARRAY
45713: PUSH
45714: LD_INT 1
45716: ARRAY
45717: PPUSH
45718: CALL 72979 0 2
// end ;
45722: GO 45572
45724: POP
45725: POP
// end else
45726: GO 46531
// if mc_build_list [ i ] then
45728: LD_EXP 118
45732: PUSH
45733: LD_VAR 0 2
45737: ARRAY
45738: IFFALSE 46531
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45740: LD_ADDR_VAR 0 5
45744: PUSH
45745: LD_EXP 113
45749: PUSH
45750: LD_VAR 0 2
45754: ARRAY
45755: PPUSH
45756: LD_INT 2
45758: PUSH
45759: LD_INT 30
45761: PUSH
45762: LD_INT 0
45764: PUSH
45765: EMPTY
45766: LIST
45767: LIST
45768: PUSH
45769: LD_INT 30
45771: PUSH
45772: LD_INT 1
45774: PUSH
45775: EMPTY
45776: LIST
45777: LIST
45778: PUSH
45779: EMPTY
45780: LIST
45781: LIST
45782: LIST
45783: PPUSH
45784: CALL_OW 72
45788: ST_TO_ADDR
// if depot then
45789: LD_VAR 0 5
45793: IFFALSE 45811
// depot := depot [ 1 ] else
45795: LD_ADDR_VAR 0 5
45799: PUSH
45800: LD_VAR 0 5
45804: PUSH
45805: LD_INT 1
45807: ARRAY
45808: ST_TO_ADDR
45809: GO 45819
// depot := 0 ;
45811: LD_ADDR_VAR 0 5
45815: PUSH
45816: LD_INT 0
45818: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
45819: LD_EXP 118
45823: PUSH
45824: LD_VAR 0 2
45828: ARRAY
45829: PUSH
45830: LD_INT 1
45832: ARRAY
45833: PUSH
45834: LD_INT 1
45836: ARRAY
45837: PPUSH
45838: CALL 72809 0 1
45842: PUSH
45843: LD_EXP 113
45847: PUSH
45848: LD_VAR 0 2
45852: ARRAY
45853: PPUSH
45854: LD_INT 2
45856: PUSH
45857: LD_INT 30
45859: PUSH
45860: LD_INT 2
45862: PUSH
45863: EMPTY
45864: LIST
45865: LIST
45866: PUSH
45867: LD_INT 30
45869: PUSH
45870: LD_INT 3
45872: PUSH
45873: EMPTY
45874: LIST
45875: LIST
45876: PUSH
45877: EMPTY
45878: LIST
45879: LIST
45880: LIST
45881: PPUSH
45882: CALL_OW 72
45886: NOT
45887: AND
45888: IFFALSE 45993
// begin for j = 1 to mc_build_list [ i ] do
45890: LD_ADDR_VAR 0 3
45894: PUSH
45895: DOUBLE
45896: LD_INT 1
45898: DEC
45899: ST_TO_ADDR
45900: LD_EXP 118
45904: PUSH
45905: LD_VAR 0 2
45909: ARRAY
45910: PUSH
45911: FOR_TO
45912: IFFALSE 45991
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
45914: LD_EXP 118
45918: PUSH
45919: LD_VAR 0 2
45923: ARRAY
45924: PUSH
45925: LD_VAR 0 3
45929: ARRAY
45930: PUSH
45931: LD_INT 1
45933: ARRAY
45934: PUSH
45935: LD_INT 2
45937: EQUAL
45938: IFFALSE 45989
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
45940: LD_ADDR_EXP 118
45944: PUSH
45945: LD_EXP 118
45949: PPUSH
45950: LD_VAR 0 2
45954: PPUSH
45955: LD_EXP 118
45959: PUSH
45960: LD_VAR 0 2
45964: ARRAY
45965: PPUSH
45966: LD_VAR 0 3
45970: PPUSH
45971: LD_INT 1
45973: PPUSH
45974: LD_INT 0
45976: PPUSH
45977: CALL 69546 0 4
45981: PPUSH
45982: CALL_OW 1
45986: ST_TO_ADDR
// break ;
45987: GO 45991
// end ;
45989: GO 45911
45991: POP
45992: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
45993: LD_EXP 118
45997: PUSH
45998: LD_VAR 0 2
46002: ARRAY
46003: PUSH
46004: LD_INT 1
46006: ARRAY
46007: PUSH
46008: LD_INT 1
46010: ARRAY
46011: PUSH
46012: LD_INT 0
46014: EQUAL
46015: PUSH
46016: LD_VAR 0 5
46020: PUSH
46021: LD_VAR 0 5
46025: PPUSH
46026: LD_EXP 118
46030: PUSH
46031: LD_VAR 0 2
46035: ARRAY
46036: PUSH
46037: LD_INT 1
46039: ARRAY
46040: PUSH
46041: LD_INT 1
46043: ARRAY
46044: PPUSH
46045: LD_EXP 118
46049: PUSH
46050: LD_VAR 0 2
46054: ARRAY
46055: PUSH
46056: LD_INT 1
46058: ARRAY
46059: PUSH
46060: LD_INT 2
46062: ARRAY
46063: PPUSH
46064: LD_EXP 118
46068: PUSH
46069: LD_VAR 0 2
46073: ARRAY
46074: PUSH
46075: LD_INT 1
46077: ARRAY
46078: PUSH
46079: LD_INT 3
46081: ARRAY
46082: PPUSH
46083: LD_EXP 118
46087: PUSH
46088: LD_VAR 0 2
46092: ARRAY
46093: PUSH
46094: LD_INT 1
46096: ARRAY
46097: PUSH
46098: LD_INT 4
46100: ARRAY
46101: PPUSH
46102: CALL 77543 0 5
46106: AND
46107: OR
46108: IFFALSE 46389
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
46110: LD_ADDR_VAR 0 4
46114: PUSH
46115: LD_EXP 113
46119: PUSH
46120: LD_VAR 0 2
46124: ARRAY
46125: PPUSH
46126: LD_INT 25
46128: PUSH
46129: LD_INT 2
46131: PUSH
46132: EMPTY
46133: LIST
46134: LIST
46135: PPUSH
46136: CALL_OW 72
46140: PUSH
46141: LD_EXP 115
46145: PUSH
46146: LD_VAR 0 2
46150: ARRAY
46151: DIFF
46152: ST_TO_ADDR
// if not tmp then
46153: LD_VAR 0 4
46157: NOT
46158: IFFALSE 46162
// continue ;
46160: GO 45407
// for j in tmp do
46162: LD_ADDR_VAR 0 3
46166: PUSH
46167: LD_VAR 0 4
46171: PUSH
46172: FOR_IN
46173: IFFALSE 46385
// begin if not mc_builders [ i ] then
46175: LD_EXP 119
46179: PUSH
46180: LD_VAR 0 2
46184: ARRAY
46185: NOT
46186: IFFALSE 46244
// begin SetTag ( j , 103 ) ;
46188: LD_VAR 0 3
46192: PPUSH
46193: LD_INT 103
46195: PPUSH
46196: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
46200: LD_ADDR_EXP 119
46204: PUSH
46205: LD_EXP 119
46209: PPUSH
46210: LD_VAR 0 2
46214: PUSH
46215: LD_EXP 119
46219: PUSH
46220: LD_VAR 0 2
46224: ARRAY
46225: PUSH
46226: LD_INT 1
46228: PLUS
46229: PUSH
46230: EMPTY
46231: LIST
46232: LIST
46233: PPUSH
46234: LD_VAR 0 3
46238: PPUSH
46239: CALL 70128 0 3
46243: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
46244: LD_VAR 0 3
46248: PPUSH
46249: CALL_OW 310
46253: IFFALSE 46264
// ComExitBuilding ( j ) ;
46255: LD_VAR 0 3
46259: PPUSH
46260: CALL_OW 122
// wait ( 3 ) ;
46264: LD_INT 3
46266: PPUSH
46267: CALL_OW 67
// if not mc_build_list [ i ] then
46271: LD_EXP 118
46275: PUSH
46276: LD_VAR 0 2
46280: ARRAY
46281: NOT
46282: IFFALSE 46286
// break ;
46284: GO 46385
// if not HasTask ( j ) then
46286: LD_VAR 0 3
46290: PPUSH
46291: CALL_OW 314
46295: NOT
46296: IFFALSE 46383
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46298: LD_VAR 0 3
46302: PPUSH
46303: LD_EXP 118
46307: PUSH
46308: LD_VAR 0 2
46312: ARRAY
46313: PUSH
46314: LD_INT 1
46316: ARRAY
46317: PUSH
46318: LD_INT 1
46320: ARRAY
46321: PPUSH
46322: LD_EXP 118
46326: PUSH
46327: LD_VAR 0 2
46331: ARRAY
46332: PUSH
46333: LD_INT 1
46335: ARRAY
46336: PUSH
46337: LD_INT 2
46339: ARRAY
46340: PPUSH
46341: LD_EXP 118
46345: PUSH
46346: LD_VAR 0 2
46350: ARRAY
46351: PUSH
46352: LD_INT 1
46354: ARRAY
46355: PUSH
46356: LD_INT 3
46358: ARRAY
46359: PPUSH
46360: LD_EXP 118
46364: PUSH
46365: LD_VAR 0 2
46369: ARRAY
46370: PUSH
46371: LD_INT 1
46373: ARRAY
46374: PUSH
46375: LD_INT 4
46377: ARRAY
46378: PPUSH
46379: CALL_OW 145
// end ;
46383: GO 46172
46385: POP
46386: POP
// end else
46387: GO 46531
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
46389: LD_EXP 113
46393: PUSH
46394: LD_VAR 0 2
46398: ARRAY
46399: PPUSH
46400: LD_EXP 118
46404: PUSH
46405: LD_VAR 0 2
46409: ARRAY
46410: PUSH
46411: LD_INT 1
46413: ARRAY
46414: PUSH
46415: LD_INT 1
46417: ARRAY
46418: PPUSH
46419: LD_EXP 118
46423: PUSH
46424: LD_VAR 0 2
46428: ARRAY
46429: PUSH
46430: LD_INT 1
46432: ARRAY
46433: PUSH
46434: LD_INT 2
46436: ARRAY
46437: PPUSH
46438: LD_EXP 118
46442: PUSH
46443: LD_VAR 0 2
46447: ARRAY
46448: PUSH
46449: LD_INT 1
46451: ARRAY
46452: PUSH
46453: LD_INT 3
46455: ARRAY
46456: PPUSH
46457: LD_EXP 118
46461: PUSH
46462: LD_VAR 0 2
46466: ARRAY
46467: PUSH
46468: LD_INT 1
46470: ARRAY
46471: PUSH
46472: LD_INT 4
46474: ARRAY
46475: PPUSH
46476: CALL 76879 0 5
46480: NOT
46481: IFFALSE 46531
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46483: LD_ADDR_EXP 118
46487: PUSH
46488: LD_EXP 118
46492: PPUSH
46493: LD_VAR 0 2
46497: PPUSH
46498: LD_EXP 118
46502: PUSH
46503: LD_VAR 0 2
46507: ARRAY
46508: PPUSH
46509: LD_INT 1
46511: PPUSH
46512: LD_INT 1
46514: NEG
46515: PPUSH
46516: LD_INT 0
46518: PPUSH
46519: CALL 69546 0 4
46523: PPUSH
46524: CALL_OW 1
46528: ST_TO_ADDR
// continue ;
46529: GO 45407
// end ; end ; end ;
46531: GO 45407
46533: POP
46534: POP
// end ;
46535: LD_VAR 0 1
46539: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46540: LD_INT 0
46542: PPUSH
46543: PPUSH
46544: PPUSH
46545: PPUSH
46546: PPUSH
46547: PPUSH
// if not mc_bases then
46548: LD_EXP 113
46552: NOT
46553: IFFALSE 46557
// exit ;
46555: GO 46984
// for i = 1 to mc_bases do
46557: LD_ADDR_VAR 0 2
46561: PUSH
46562: DOUBLE
46563: LD_INT 1
46565: DEC
46566: ST_TO_ADDR
46567: LD_EXP 113
46571: PUSH
46572: FOR_TO
46573: IFFALSE 46982
// begin tmp := mc_build_upgrade [ i ] ;
46575: LD_ADDR_VAR 0 4
46579: PUSH
46580: LD_EXP 145
46584: PUSH
46585: LD_VAR 0 2
46589: ARRAY
46590: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46591: LD_ADDR_VAR 0 6
46595: PUSH
46596: LD_EXP 146
46600: PUSH
46601: LD_VAR 0 2
46605: ARRAY
46606: PPUSH
46607: LD_INT 2
46609: PUSH
46610: LD_INT 30
46612: PUSH
46613: LD_INT 6
46615: PUSH
46616: EMPTY
46617: LIST
46618: LIST
46619: PUSH
46620: LD_INT 30
46622: PUSH
46623: LD_INT 7
46625: PUSH
46626: EMPTY
46627: LIST
46628: LIST
46629: PUSH
46630: EMPTY
46631: LIST
46632: LIST
46633: LIST
46634: PPUSH
46635: CALL_OW 72
46639: ST_TO_ADDR
// if not tmp and not lab then
46640: LD_VAR 0 4
46644: NOT
46645: PUSH
46646: LD_VAR 0 6
46650: NOT
46651: AND
46652: IFFALSE 46656
// continue ;
46654: GO 46572
// if tmp then
46656: LD_VAR 0 4
46660: IFFALSE 46780
// for j in tmp do
46662: LD_ADDR_VAR 0 3
46666: PUSH
46667: LD_VAR 0 4
46671: PUSH
46672: FOR_IN
46673: IFFALSE 46778
// begin if UpgradeCost ( j ) then
46675: LD_VAR 0 3
46679: PPUSH
46680: CALL 76539 0 1
46684: IFFALSE 46776
// begin ComUpgrade ( j ) ;
46686: LD_VAR 0 3
46690: PPUSH
46691: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46695: LD_ADDR_EXP 145
46699: PUSH
46700: LD_EXP 145
46704: PPUSH
46705: LD_VAR 0 2
46709: PPUSH
46710: LD_EXP 145
46714: PUSH
46715: LD_VAR 0 2
46719: ARRAY
46720: PUSH
46721: LD_VAR 0 3
46725: DIFF
46726: PPUSH
46727: CALL_OW 1
46731: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46732: LD_ADDR_EXP 120
46736: PUSH
46737: LD_EXP 120
46741: PPUSH
46742: LD_VAR 0 2
46746: PUSH
46747: LD_EXP 120
46751: PUSH
46752: LD_VAR 0 2
46756: ARRAY
46757: PUSH
46758: LD_INT 1
46760: PLUS
46761: PUSH
46762: EMPTY
46763: LIST
46764: LIST
46765: PPUSH
46766: LD_VAR 0 3
46770: PPUSH
46771: CALL 70128 0 3
46775: ST_TO_ADDR
// end ; end ;
46776: GO 46672
46778: POP
46779: POP
// if not lab or not mc_lab_upgrade [ i ] then
46780: LD_VAR 0 6
46784: NOT
46785: PUSH
46786: LD_EXP 147
46790: PUSH
46791: LD_VAR 0 2
46795: ARRAY
46796: NOT
46797: OR
46798: IFFALSE 46802
// continue ;
46800: GO 46572
// for j in lab do
46802: LD_ADDR_VAR 0 3
46806: PUSH
46807: LD_VAR 0 6
46811: PUSH
46812: FOR_IN
46813: IFFALSE 46978
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
46815: LD_VAR 0 3
46819: PPUSH
46820: CALL_OW 266
46824: PUSH
46825: LD_INT 6
46827: PUSH
46828: LD_INT 7
46830: PUSH
46831: EMPTY
46832: LIST
46833: LIST
46834: IN
46835: PUSH
46836: LD_VAR 0 3
46840: PPUSH
46841: CALL_OW 461
46845: PUSH
46846: LD_INT 1
46848: NONEQUAL
46849: AND
46850: IFFALSE 46976
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
46852: LD_VAR 0 3
46856: PPUSH
46857: LD_EXP 147
46861: PUSH
46862: LD_VAR 0 2
46866: ARRAY
46867: PUSH
46868: LD_INT 1
46870: ARRAY
46871: PPUSH
46872: CALL 76744 0 2
46876: IFFALSE 46976
// begin ComCancel ( j ) ;
46878: LD_VAR 0 3
46882: PPUSH
46883: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
46887: LD_VAR 0 3
46891: PPUSH
46892: LD_EXP 147
46896: PUSH
46897: LD_VAR 0 2
46901: ARRAY
46902: PUSH
46903: LD_INT 1
46905: ARRAY
46906: PPUSH
46907: CALL_OW 207
// if not j in mc_construct_list [ i ] then
46911: LD_VAR 0 3
46915: PUSH
46916: LD_EXP 120
46920: PUSH
46921: LD_VAR 0 2
46925: ARRAY
46926: IN
46927: NOT
46928: IFFALSE 46974
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46930: LD_ADDR_EXP 120
46934: PUSH
46935: LD_EXP 120
46939: PPUSH
46940: LD_VAR 0 2
46944: PUSH
46945: LD_EXP 120
46949: PUSH
46950: LD_VAR 0 2
46954: ARRAY
46955: PUSH
46956: LD_INT 1
46958: PLUS
46959: PUSH
46960: EMPTY
46961: LIST
46962: LIST
46963: PPUSH
46964: LD_VAR 0 3
46968: PPUSH
46969: CALL 70128 0 3
46973: ST_TO_ADDR
// break ;
46974: GO 46978
// end ; end ; end ;
46976: GO 46812
46978: POP
46979: POP
// end ;
46980: GO 46572
46982: POP
46983: POP
// end ;
46984: LD_VAR 0 1
46988: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
46989: LD_INT 0
46991: PPUSH
46992: PPUSH
46993: PPUSH
46994: PPUSH
46995: PPUSH
46996: PPUSH
46997: PPUSH
46998: PPUSH
46999: PPUSH
// if not mc_bases then
47000: LD_EXP 113
47004: NOT
47005: IFFALSE 47009
// exit ;
47007: GO 47414
// for i = 1 to mc_bases do
47009: LD_ADDR_VAR 0 2
47013: PUSH
47014: DOUBLE
47015: LD_INT 1
47017: DEC
47018: ST_TO_ADDR
47019: LD_EXP 113
47023: PUSH
47024: FOR_TO
47025: IFFALSE 47412
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
47027: LD_EXP 121
47031: PUSH
47032: LD_VAR 0 2
47036: ARRAY
47037: NOT
47038: PUSH
47039: LD_EXP 113
47043: PUSH
47044: LD_VAR 0 2
47048: ARRAY
47049: PPUSH
47050: LD_INT 30
47052: PUSH
47053: LD_INT 3
47055: PUSH
47056: EMPTY
47057: LIST
47058: LIST
47059: PPUSH
47060: CALL_OW 72
47064: NOT
47065: OR
47066: IFFALSE 47070
// continue ;
47068: GO 47024
// busy := false ;
47070: LD_ADDR_VAR 0 8
47074: PUSH
47075: LD_INT 0
47077: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
47078: LD_ADDR_VAR 0 4
47082: PUSH
47083: LD_EXP 113
47087: PUSH
47088: LD_VAR 0 2
47092: ARRAY
47093: PPUSH
47094: LD_INT 30
47096: PUSH
47097: LD_INT 3
47099: PUSH
47100: EMPTY
47101: LIST
47102: LIST
47103: PPUSH
47104: CALL_OW 72
47108: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
47109: LD_ADDR_VAR 0 6
47113: PUSH
47114: LD_EXP 121
47118: PUSH
47119: LD_VAR 0 2
47123: ARRAY
47124: PPUSH
47125: LD_INT 2
47127: PUSH
47128: LD_INT 30
47130: PUSH
47131: LD_INT 32
47133: PUSH
47134: EMPTY
47135: LIST
47136: LIST
47137: PUSH
47138: LD_INT 30
47140: PUSH
47141: LD_INT 33
47143: PUSH
47144: EMPTY
47145: LIST
47146: LIST
47147: PUSH
47148: EMPTY
47149: LIST
47150: LIST
47151: LIST
47152: PPUSH
47153: CALL_OW 72
47157: ST_TO_ADDR
// if not t then
47158: LD_VAR 0 6
47162: NOT
47163: IFFALSE 47167
// continue ;
47165: GO 47024
// for j in tmp do
47167: LD_ADDR_VAR 0 3
47171: PUSH
47172: LD_VAR 0 4
47176: PUSH
47177: FOR_IN
47178: IFFALSE 47208
// if not BuildingStatus ( j ) = bs_idle then
47180: LD_VAR 0 3
47184: PPUSH
47185: CALL_OW 461
47189: PUSH
47190: LD_INT 2
47192: EQUAL
47193: NOT
47194: IFFALSE 47206
// begin busy := true ;
47196: LD_ADDR_VAR 0 8
47200: PUSH
47201: LD_INT 1
47203: ST_TO_ADDR
// break ;
47204: GO 47208
// end ;
47206: GO 47177
47208: POP
47209: POP
// if busy then
47210: LD_VAR 0 8
47214: IFFALSE 47218
// continue ;
47216: GO 47024
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
47218: LD_ADDR_VAR 0 7
47222: PUSH
47223: LD_VAR 0 6
47227: PPUSH
47228: LD_INT 35
47230: PUSH
47231: LD_INT 0
47233: PUSH
47234: EMPTY
47235: LIST
47236: LIST
47237: PPUSH
47238: CALL_OW 72
47242: ST_TO_ADDR
// if tw then
47243: LD_VAR 0 7
47247: IFFALSE 47324
// begin tw := tw [ 1 ] ;
47249: LD_ADDR_VAR 0 7
47253: PUSH
47254: LD_VAR 0 7
47258: PUSH
47259: LD_INT 1
47261: ARRAY
47262: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
47263: LD_ADDR_VAR 0 9
47267: PUSH
47268: LD_VAR 0 7
47272: PPUSH
47273: LD_EXP 138
47277: PUSH
47278: LD_VAR 0 2
47282: ARRAY
47283: PPUSH
47284: CALL 75098 0 2
47288: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47289: LD_EXP 152
47293: PUSH
47294: LD_VAR 0 2
47298: ARRAY
47299: IFFALSE 47322
// if not weapon in mc_allowed_tower_weapons [ i ] then
47301: LD_VAR 0 9
47305: PUSH
47306: LD_EXP 152
47310: PUSH
47311: LD_VAR 0 2
47315: ARRAY
47316: IN
47317: NOT
47318: IFFALSE 47322
// continue ;
47320: GO 47024
// end else
47322: GO 47387
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47324: LD_ADDR_VAR 0 5
47328: PUSH
47329: LD_EXP 121
47333: PUSH
47334: LD_VAR 0 2
47338: ARRAY
47339: PPUSH
47340: LD_VAR 0 4
47344: PPUSH
47345: CALL 100719 0 2
47349: ST_TO_ADDR
// if not tmp2 then
47350: LD_VAR 0 5
47354: NOT
47355: IFFALSE 47359
// continue ;
47357: GO 47024
// tw := tmp2 [ 1 ] ;
47359: LD_ADDR_VAR 0 7
47363: PUSH
47364: LD_VAR 0 5
47368: PUSH
47369: LD_INT 1
47371: ARRAY
47372: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47373: LD_ADDR_VAR 0 9
47377: PUSH
47378: LD_VAR 0 5
47382: PUSH
47383: LD_INT 2
47385: ARRAY
47386: ST_TO_ADDR
// end ; if not weapon then
47387: LD_VAR 0 9
47391: NOT
47392: IFFALSE 47396
// continue ;
47394: GO 47024
// ComPlaceWeapon ( tw , weapon ) ;
47396: LD_VAR 0 7
47400: PPUSH
47401: LD_VAR 0 9
47405: PPUSH
47406: CALL_OW 148
// end ;
47410: GO 47024
47412: POP
47413: POP
// end ;
47414: LD_VAR 0 1
47418: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
47419: LD_INT 0
47421: PPUSH
47422: PPUSH
47423: PPUSH
47424: PPUSH
47425: PPUSH
47426: PPUSH
// if not mc_bases then
47427: LD_EXP 113
47431: NOT
47432: IFFALSE 47436
// exit ;
47434: GO 48212
// for i = 1 to mc_bases do
47436: LD_ADDR_VAR 0 2
47440: PUSH
47441: DOUBLE
47442: LD_INT 1
47444: DEC
47445: ST_TO_ADDR
47446: LD_EXP 113
47450: PUSH
47451: FOR_TO
47452: IFFALSE 48210
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47454: LD_EXP 126
47458: PUSH
47459: LD_VAR 0 2
47463: ARRAY
47464: NOT
47465: PUSH
47466: LD_EXP 126
47470: PUSH
47471: LD_VAR 0 2
47475: ARRAY
47476: PUSH
47477: LD_EXP 127
47481: PUSH
47482: LD_VAR 0 2
47486: ARRAY
47487: EQUAL
47488: OR
47489: PUSH
47490: LD_EXP 136
47494: PUSH
47495: LD_VAR 0 2
47499: ARRAY
47500: OR
47501: IFFALSE 47505
// continue ;
47503: GO 47451
// if mc_miners [ i ] then
47505: LD_EXP 127
47509: PUSH
47510: LD_VAR 0 2
47514: ARRAY
47515: IFFALSE 47897
// begin for j = mc_miners [ i ] downto 1 do
47517: LD_ADDR_VAR 0 3
47521: PUSH
47522: DOUBLE
47523: LD_EXP 127
47527: PUSH
47528: LD_VAR 0 2
47532: ARRAY
47533: INC
47534: ST_TO_ADDR
47535: LD_INT 1
47537: PUSH
47538: FOR_DOWNTO
47539: IFFALSE 47895
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47541: LD_EXP 127
47545: PUSH
47546: LD_VAR 0 2
47550: ARRAY
47551: PUSH
47552: LD_VAR 0 3
47556: ARRAY
47557: PPUSH
47558: CALL_OW 301
47562: PUSH
47563: LD_EXP 127
47567: PUSH
47568: LD_VAR 0 2
47572: ARRAY
47573: PUSH
47574: LD_VAR 0 3
47578: ARRAY
47579: PPUSH
47580: CALL_OW 257
47584: PUSH
47585: LD_INT 1
47587: NONEQUAL
47588: OR
47589: IFFALSE 47652
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47591: LD_ADDR_VAR 0 5
47595: PUSH
47596: LD_EXP 127
47600: PUSH
47601: LD_VAR 0 2
47605: ARRAY
47606: PUSH
47607: LD_EXP 127
47611: PUSH
47612: LD_VAR 0 2
47616: ARRAY
47617: PUSH
47618: LD_VAR 0 3
47622: ARRAY
47623: DIFF
47624: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47625: LD_ADDR_EXP 127
47629: PUSH
47630: LD_EXP 127
47634: PPUSH
47635: LD_VAR 0 2
47639: PPUSH
47640: LD_VAR 0 5
47644: PPUSH
47645: CALL_OW 1
47649: ST_TO_ADDR
// continue ;
47650: GO 47538
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47652: LD_EXP 127
47656: PUSH
47657: LD_VAR 0 2
47661: ARRAY
47662: PUSH
47663: LD_VAR 0 3
47667: ARRAY
47668: PPUSH
47669: CALL_OW 257
47673: PUSH
47674: LD_INT 1
47676: EQUAL
47677: PUSH
47678: LD_EXP 127
47682: PUSH
47683: LD_VAR 0 2
47687: ARRAY
47688: PUSH
47689: LD_VAR 0 3
47693: ARRAY
47694: PPUSH
47695: CALL_OW 459
47699: NOT
47700: AND
47701: PUSH
47702: LD_EXP 127
47706: PUSH
47707: LD_VAR 0 2
47711: ARRAY
47712: PUSH
47713: LD_VAR 0 3
47717: ARRAY
47718: PPUSH
47719: CALL_OW 314
47723: NOT
47724: AND
47725: IFFALSE 47893
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
47727: LD_EXP 127
47731: PUSH
47732: LD_VAR 0 2
47736: ARRAY
47737: PUSH
47738: LD_VAR 0 3
47742: ARRAY
47743: PPUSH
47744: CALL_OW 310
47748: IFFALSE 47771
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
47750: LD_EXP 127
47754: PUSH
47755: LD_VAR 0 2
47759: ARRAY
47760: PUSH
47761: LD_VAR 0 3
47765: ARRAY
47766: PPUSH
47767: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
47771: LD_EXP 127
47775: PUSH
47776: LD_VAR 0 2
47780: ARRAY
47781: PUSH
47782: LD_VAR 0 3
47786: ARRAY
47787: PPUSH
47788: CALL_OW 314
47792: NOT
47793: IFFALSE 47893
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
47795: LD_EXP 127
47799: PUSH
47800: LD_VAR 0 2
47804: ARRAY
47805: PUSH
47806: LD_VAR 0 3
47810: ARRAY
47811: PPUSH
47812: LD_EXP 126
47816: PUSH
47817: LD_VAR 0 2
47821: ARRAY
47822: PUSH
47823: LD_VAR 0 3
47827: PUSH
47828: LD_EXP 126
47832: PUSH
47833: LD_VAR 0 2
47837: ARRAY
47838: MOD
47839: PUSH
47840: LD_INT 1
47842: PLUS
47843: ARRAY
47844: PUSH
47845: LD_INT 1
47847: ARRAY
47848: PPUSH
47849: LD_EXP 126
47853: PUSH
47854: LD_VAR 0 2
47858: ARRAY
47859: PUSH
47860: LD_VAR 0 3
47864: PUSH
47865: LD_EXP 126
47869: PUSH
47870: LD_VAR 0 2
47874: ARRAY
47875: MOD
47876: PUSH
47877: LD_INT 1
47879: PLUS
47880: ARRAY
47881: PUSH
47882: LD_INT 2
47884: ARRAY
47885: PPUSH
47886: LD_INT 0
47888: PPUSH
47889: CALL_OW 193
// end ; end ;
47893: GO 47538
47895: POP
47896: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
47897: LD_ADDR_VAR 0 5
47901: PUSH
47902: LD_EXP 113
47906: PUSH
47907: LD_VAR 0 2
47911: ARRAY
47912: PPUSH
47913: LD_INT 2
47915: PUSH
47916: LD_INT 30
47918: PUSH
47919: LD_INT 4
47921: PUSH
47922: EMPTY
47923: LIST
47924: LIST
47925: PUSH
47926: LD_INT 30
47928: PUSH
47929: LD_INT 5
47931: PUSH
47932: EMPTY
47933: LIST
47934: LIST
47935: PUSH
47936: LD_INT 30
47938: PUSH
47939: LD_INT 32
47941: PUSH
47942: EMPTY
47943: LIST
47944: LIST
47945: PUSH
47946: EMPTY
47947: LIST
47948: LIST
47949: LIST
47950: LIST
47951: PPUSH
47952: CALL_OW 72
47956: ST_TO_ADDR
// if not tmp then
47957: LD_VAR 0 5
47961: NOT
47962: IFFALSE 47966
// continue ;
47964: GO 47451
// list := [ ] ;
47966: LD_ADDR_VAR 0 6
47970: PUSH
47971: EMPTY
47972: ST_TO_ADDR
// for j in tmp do
47973: LD_ADDR_VAR 0 3
47977: PUSH
47978: LD_VAR 0 5
47982: PUSH
47983: FOR_IN
47984: IFFALSE 48053
// begin for k in UnitsInside ( j ) do
47986: LD_ADDR_VAR 0 4
47990: PUSH
47991: LD_VAR 0 3
47995: PPUSH
47996: CALL_OW 313
48000: PUSH
48001: FOR_IN
48002: IFFALSE 48049
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
48004: LD_VAR 0 4
48008: PPUSH
48009: CALL_OW 257
48013: PUSH
48014: LD_INT 1
48016: EQUAL
48017: PUSH
48018: LD_VAR 0 4
48022: PPUSH
48023: CALL_OW 459
48027: NOT
48028: AND
48029: IFFALSE 48047
// list := list ^ k ;
48031: LD_ADDR_VAR 0 6
48035: PUSH
48036: LD_VAR 0 6
48040: PUSH
48041: LD_VAR 0 4
48045: ADD
48046: ST_TO_ADDR
48047: GO 48001
48049: POP
48050: POP
// end ;
48051: GO 47983
48053: POP
48054: POP
// list := list diff mc_miners [ i ] ;
48055: LD_ADDR_VAR 0 6
48059: PUSH
48060: LD_VAR 0 6
48064: PUSH
48065: LD_EXP 127
48069: PUSH
48070: LD_VAR 0 2
48074: ARRAY
48075: DIFF
48076: ST_TO_ADDR
// if not list then
48077: LD_VAR 0 6
48081: NOT
48082: IFFALSE 48086
// continue ;
48084: GO 47451
// k := mc_mines [ i ] - mc_miners [ i ] ;
48086: LD_ADDR_VAR 0 4
48090: PUSH
48091: LD_EXP 126
48095: PUSH
48096: LD_VAR 0 2
48100: ARRAY
48101: PUSH
48102: LD_EXP 127
48106: PUSH
48107: LD_VAR 0 2
48111: ARRAY
48112: MINUS
48113: ST_TO_ADDR
// if k > list then
48114: LD_VAR 0 4
48118: PUSH
48119: LD_VAR 0 6
48123: GREATER
48124: IFFALSE 48136
// k := list ;
48126: LD_ADDR_VAR 0 4
48130: PUSH
48131: LD_VAR 0 6
48135: ST_TO_ADDR
// for j = 1 to k do
48136: LD_ADDR_VAR 0 3
48140: PUSH
48141: DOUBLE
48142: LD_INT 1
48144: DEC
48145: ST_TO_ADDR
48146: LD_VAR 0 4
48150: PUSH
48151: FOR_TO
48152: IFFALSE 48206
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
48154: LD_ADDR_EXP 127
48158: PUSH
48159: LD_EXP 127
48163: PPUSH
48164: LD_VAR 0 2
48168: PUSH
48169: LD_EXP 127
48173: PUSH
48174: LD_VAR 0 2
48178: ARRAY
48179: PUSH
48180: LD_INT 1
48182: PLUS
48183: PUSH
48184: EMPTY
48185: LIST
48186: LIST
48187: PPUSH
48188: LD_VAR 0 6
48192: PUSH
48193: LD_VAR 0 3
48197: ARRAY
48198: PPUSH
48199: CALL 70128 0 3
48203: ST_TO_ADDR
48204: GO 48151
48206: POP
48207: POP
// end ;
48208: GO 47451
48210: POP
48211: POP
// end ;
48212: LD_VAR 0 1
48216: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
48217: LD_INT 0
48219: PPUSH
48220: PPUSH
48221: PPUSH
48222: PPUSH
48223: PPUSH
48224: PPUSH
48225: PPUSH
48226: PPUSH
48227: PPUSH
48228: PPUSH
// if not mc_bases then
48229: LD_EXP 113
48233: NOT
48234: IFFALSE 48238
// exit ;
48236: GO 49988
// for i = 1 to mc_bases do
48238: LD_ADDR_VAR 0 2
48242: PUSH
48243: DOUBLE
48244: LD_INT 1
48246: DEC
48247: ST_TO_ADDR
48248: LD_EXP 113
48252: PUSH
48253: FOR_TO
48254: IFFALSE 49986
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
48256: LD_EXP 113
48260: PUSH
48261: LD_VAR 0 2
48265: ARRAY
48266: NOT
48267: PUSH
48268: LD_EXP 120
48272: PUSH
48273: LD_VAR 0 2
48277: ARRAY
48278: OR
48279: IFFALSE 48283
// continue ;
48281: GO 48253
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48283: LD_EXP 129
48287: PUSH
48288: LD_VAR 0 2
48292: ARRAY
48293: NOT
48294: PUSH
48295: LD_EXP 130
48299: PUSH
48300: LD_VAR 0 2
48304: ARRAY
48305: AND
48306: IFFALSE 48344
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48308: LD_ADDR_EXP 130
48312: PUSH
48313: LD_EXP 130
48317: PPUSH
48318: LD_VAR 0 2
48322: PPUSH
48323: EMPTY
48324: PPUSH
48325: CALL_OW 1
48329: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48330: LD_VAR 0 2
48334: PPUSH
48335: LD_INT 107
48337: PPUSH
48338: CALL 39192 0 2
// continue ;
48342: GO 48253
// end ; target := [ ] ;
48344: LD_ADDR_VAR 0 6
48348: PUSH
48349: EMPTY
48350: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48351: LD_ADDR_VAR 0 3
48355: PUSH
48356: DOUBLE
48357: LD_EXP 129
48361: PUSH
48362: LD_VAR 0 2
48366: ARRAY
48367: INC
48368: ST_TO_ADDR
48369: LD_INT 1
48371: PUSH
48372: FOR_DOWNTO
48373: IFFALSE 48633
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48375: LD_EXP 129
48379: PUSH
48380: LD_VAR 0 2
48384: ARRAY
48385: PUSH
48386: LD_VAR 0 3
48390: ARRAY
48391: PUSH
48392: LD_INT 2
48394: ARRAY
48395: PPUSH
48396: LD_EXP 129
48400: PUSH
48401: LD_VAR 0 2
48405: ARRAY
48406: PUSH
48407: LD_VAR 0 3
48411: ARRAY
48412: PUSH
48413: LD_INT 3
48415: ARRAY
48416: PPUSH
48417: CALL_OW 488
48421: PUSH
48422: LD_EXP 129
48426: PUSH
48427: LD_VAR 0 2
48431: ARRAY
48432: PUSH
48433: LD_VAR 0 3
48437: ARRAY
48438: PUSH
48439: LD_INT 2
48441: ARRAY
48442: PPUSH
48443: LD_EXP 129
48447: PUSH
48448: LD_VAR 0 2
48452: ARRAY
48453: PUSH
48454: LD_VAR 0 3
48458: ARRAY
48459: PUSH
48460: LD_INT 3
48462: ARRAY
48463: PPUSH
48464: CALL_OW 284
48468: PUSH
48469: LD_INT 0
48471: EQUAL
48472: AND
48473: IFFALSE 48528
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48475: LD_ADDR_VAR 0 5
48479: PUSH
48480: LD_EXP 129
48484: PUSH
48485: LD_VAR 0 2
48489: ARRAY
48490: PPUSH
48491: LD_VAR 0 3
48495: PPUSH
48496: CALL_OW 3
48500: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48501: LD_ADDR_EXP 129
48505: PUSH
48506: LD_EXP 129
48510: PPUSH
48511: LD_VAR 0 2
48515: PPUSH
48516: LD_VAR 0 5
48520: PPUSH
48521: CALL_OW 1
48525: ST_TO_ADDR
// continue ;
48526: GO 48372
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48528: LD_EXP 113
48532: PUSH
48533: LD_VAR 0 2
48537: ARRAY
48538: PUSH
48539: LD_INT 1
48541: ARRAY
48542: PPUSH
48543: CALL_OW 255
48547: PPUSH
48548: LD_EXP 129
48552: PUSH
48553: LD_VAR 0 2
48557: ARRAY
48558: PUSH
48559: LD_VAR 0 3
48563: ARRAY
48564: PUSH
48565: LD_INT 2
48567: ARRAY
48568: PPUSH
48569: LD_EXP 129
48573: PUSH
48574: LD_VAR 0 2
48578: ARRAY
48579: PUSH
48580: LD_VAR 0 3
48584: ARRAY
48585: PUSH
48586: LD_INT 3
48588: ARRAY
48589: PPUSH
48590: LD_INT 30
48592: PPUSH
48593: CALL 71024 0 4
48597: PUSH
48598: LD_INT 4
48600: ARRAY
48601: PUSH
48602: LD_INT 0
48604: EQUAL
48605: IFFALSE 48631
// begin target := mc_crates [ i ] [ j ] ;
48607: LD_ADDR_VAR 0 6
48611: PUSH
48612: LD_EXP 129
48616: PUSH
48617: LD_VAR 0 2
48621: ARRAY
48622: PUSH
48623: LD_VAR 0 3
48627: ARRAY
48628: ST_TO_ADDR
// break ;
48629: GO 48633
// end ; end ;
48631: GO 48372
48633: POP
48634: POP
// if not target then
48635: LD_VAR 0 6
48639: NOT
48640: IFFALSE 48644
// continue ;
48642: GO 48253
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48644: LD_ADDR_VAR 0 7
48648: PUSH
48649: LD_EXP 132
48653: PUSH
48654: LD_VAR 0 2
48658: ARRAY
48659: PPUSH
48660: LD_INT 2
48662: PUSH
48663: LD_INT 3
48665: PUSH
48666: LD_INT 58
48668: PUSH
48669: EMPTY
48670: LIST
48671: PUSH
48672: EMPTY
48673: LIST
48674: LIST
48675: PUSH
48676: LD_INT 61
48678: PUSH
48679: EMPTY
48680: LIST
48681: PUSH
48682: LD_INT 33
48684: PUSH
48685: LD_INT 5
48687: PUSH
48688: EMPTY
48689: LIST
48690: LIST
48691: PUSH
48692: LD_INT 33
48694: PUSH
48695: LD_INT 3
48697: PUSH
48698: EMPTY
48699: LIST
48700: LIST
48701: PUSH
48702: EMPTY
48703: LIST
48704: LIST
48705: LIST
48706: LIST
48707: LIST
48708: PUSH
48709: LD_INT 2
48711: PUSH
48712: LD_INT 34
48714: PUSH
48715: LD_INT 32
48717: PUSH
48718: EMPTY
48719: LIST
48720: LIST
48721: PUSH
48722: LD_INT 34
48724: PUSH
48725: LD_INT 51
48727: PUSH
48728: EMPTY
48729: LIST
48730: LIST
48731: PUSH
48732: LD_INT 34
48734: PUSH
48735: LD_INT 12
48737: PUSH
48738: EMPTY
48739: LIST
48740: LIST
48741: PUSH
48742: EMPTY
48743: LIST
48744: LIST
48745: LIST
48746: LIST
48747: PUSH
48748: EMPTY
48749: LIST
48750: LIST
48751: PPUSH
48752: CALL_OW 72
48756: ST_TO_ADDR
// if not cargo then
48757: LD_VAR 0 7
48761: NOT
48762: IFFALSE 49405
// begin if mc_crates_collector [ i ] < 5 then
48764: LD_EXP 130
48768: PUSH
48769: LD_VAR 0 2
48773: ARRAY
48774: PUSH
48775: LD_INT 5
48777: LESS
48778: IFFALSE 49144
// begin if mc_ape [ i ] then
48780: LD_EXP 142
48784: PUSH
48785: LD_VAR 0 2
48789: ARRAY
48790: IFFALSE 48837
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
48792: LD_ADDR_VAR 0 5
48796: PUSH
48797: LD_EXP 142
48801: PUSH
48802: LD_VAR 0 2
48806: ARRAY
48807: PPUSH
48808: LD_INT 25
48810: PUSH
48811: LD_INT 16
48813: PUSH
48814: EMPTY
48815: LIST
48816: LIST
48817: PUSH
48818: LD_INT 24
48820: PUSH
48821: LD_INT 750
48823: PUSH
48824: EMPTY
48825: LIST
48826: LIST
48827: PUSH
48828: EMPTY
48829: LIST
48830: LIST
48831: PPUSH
48832: CALL_OW 72
48836: ST_TO_ADDR
// if not tmp then
48837: LD_VAR 0 5
48841: NOT
48842: IFFALSE 48889
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
48844: LD_ADDR_VAR 0 5
48848: PUSH
48849: LD_EXP 113
48853: PUSH
48854: LD_VAR 0 2
48858: ARRAY
48859: PPUSH
48860: LD_INT 25
48862: PUSH
48863: LD_INT 2
48865: PUSH
48866: EMPTY
48867: LIST
48868: LIST
48869: PUSH
48870: LD_INT 24
48872: PUSH
48873: LD_INT 750
48875: PUSH
48876: EMPTY
48877: LIST
48878: LIST
48879: PUSH
48880: EMPTY
48881: LIST
48882: LIST
48883: PPUSH
48884: CALL_OW 72
48888: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
48889: LD_EXP 142
48893: PUSH
48894: LD_VAR 0 2
48898: ARRAY
48899: PUSH
48900: LD_EXP 113
48904: PUSH
48905: LD_VAR 0 2
48909: ARRAY
48910: PPUSH
48911: LD_INT 25
48913: PUSH
48914: LD_INT 2
48916: PUSH
48917: EMPTY
48918: LIST
48919: LIST
48920: PUSH
48921: LD_INT 24
48923: PUSH
48924: LD_INT 750
48926: PUSH
48927: EMPTY
48928: LIST
48929: LIST
48930: PUSH
48931: EMPTY
48932: LIST
48933: LIST
48934: PPUSH
48935: CALL_OW 72
48939: AND
48940: PUSH
48941: LD_VAR 0 5
48945: PUSH
48946: LD_INT 5
48948: LESS
48949: AND
48950: IFFALSE 49032
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
48952: LD_ADDR_VAR 0 3
48956: PUSH
48957: LD_EXP 113
48961: PUSH
48962: LD_VAR 0 2
48966: ARRAY
48967: PPUSH
48968: LD_INT 25
48970: PUSH
48971: LD_INT 2
48973: PUSH
48974: EMPTY
48975: LIST
48976: LIST
48977: PUSH
48978: LD_INT 24
48980: PUSH
48981: LD_INT 750
48983: PUSH
48984: EMPTY
48985: LIST
48986: LIST
48987: PUSH
48988: EMPTY
48989: LIST
48990: LIST
48991: PPUSH
48992: CALL_OW 72
48996: PUSH
48997: FOR_IN
48998: IFFALSE 49030
// begin tmp := tmp union j ;
49000: LD_ADDR_VAR 0 5
49004: PUSH
49005: LD_VAR 0 5
49009: PUSH
49010: LD_VAR 0 3
49014: UNION
49015: ST_TO_ADDR
// if tmp >= 5 then
49016: LD_VAR 0 5
49020: PUSH
49021: LD_INT 5
49023: GREATEREQUAL
49024: IFFALSE 49028
// break ;
49026: GO 49030
// end ;
49028: GO 48997
49030: POP
49031: POP
// end ; if not tmp then
49032: LD_VAR 0 5
49036: NOT
49037: IFFALSE 49041
// continue ;
49039: GO 48253
// for j in tmp do
49041: LD_ADDR_VAR 0 3
49045: PUSH
49046: LD_VAR 0 5
49050: PUSH
49051: FOR_IN
49052: IFFALSE 49142
// if not GetTag ( j ) then
49054: LD_VAR 0 3
49058: PPUSH
49059: CALL_OW 110
49063: NOT
49064: IFFALSE 49140
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
49066: LD_ADDR_EXP 130
49070: PUSH
49071: LD_EXP 130
49075: PPUSH
49076: LD_VAR 0 2
49080: PUSH
49081: LD_EXP 130
49085: PUSH
49086: LD_VAR 0 2
49090: ARRAY
49091: PUSH
49092: LD_INT 1
49094: PLUS
49095: PUSH
49096: EMPTY
49097: LIST
49098: LIST
49099: PPUSH
49100: LD_VAR 0 3
49104: PPUSH
49105: CALL 70128 0 3
49109: ST_TO_ADDR
// SetTag ( j , 107 ) ;
49110: LD_VAR 0 3
49114: PPUSH
49115: LD_INT 107
49117: PPUSH
49118: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
49122: LD_EXP 130
49126: PUSH
49127: LD_VAR 0 2
49131: ARRAY
49132: PUSH
49133: LD_INT 5
49135: GREATEREQUAL
49136: IFFALSE 49140
// break ;
49138: GO 49142
// end ;
49140: GO 49051
49142: POP
49143: POP
// end ; if mc_crates_collector [ i ] and target then
49144: LD_EXP 130
49148: PUSH
49149: LD_VAR 0 2
49153: ARRAY
49154: PUSH
49155: LD_VAR 0 6
49159: AND
49160: IFFALSE 49403
// begin if mc_crates_collector [ i ] < target [ 1 ] then
49162: LD_EXP 130
49166: PUSH
49167: LD_VAR 0 2
49171: ARRAY
49172: PUSH
49173: LD_VAR 0 6
49177: PUSH
49178: LD_INT 1
49180: ARRAY
49181: LESS
49182: IFFALSE 49202
// tmp := mc_crates_collector [ i ] else
49184: LD_ADDR_VAR 0 5
49188: PUSH
49189: LD_EXP 130
49193: PUSH
49194: LD_VAR 0 2
49198: ARRAY
49199: ST_TO_ADDR
49200: GO 49216
// tmp := target [ 1 ] ;
49202: LD_ADDR_VAR 0 5
49206: PUSH
49207: LD_VAR 0 6
49211: PUSH
49212: LD_INT 1
49214: ARRAY
49215: ST_TO_ADDR
// k := 0 ;
49216: LD_ADDR_VAR 0 4
49220: PUSH
49221: LD_INT 0
49223: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
49224: LD_ADDR_VAR 0 3
49228: PUSH
49229: LD_EXP 130
49233: PUSH
49234: LD_VAR 0 2
49238: ARRAY
49239: PUSH
49240: FOR_IN
49241: IFFALSE 49401
// begin k := k + 1 ;
49243: LD_ADDR_VAR 0 4
49247: PUSH
49248: LD_VAR 0 4
49252: PUSH
49253: LD_INT 1
49255: PLUS
49256: ST_TO_ADDR
// if k > tmp then
49257: LD_VAR 0 4
49261: PUSH
49262: LD_VAR 0 5
49266: GREATER
49267: IFFALSE 49271
// break ;
49269: GO 49401
// if not GetClass ( j ) in [ 2 , 16 ] then
49271: LD_VAR 0 3
49275: PPUSH
49276: CALL_OW 257
49280: PUSH
49281: LD_INT 2
49283: PUSH
49284: LD_INT 16
49286: PUSH
49287: EMPTY
49288: LIST
49289: LIST
49290: IN
49291: NOT
49292: IFFALSE 49345
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49294: LD_ADDR_EXP 130
49298: PUSH
49299: LD_EXP 130
49303: PPUSH
49304: LD_VAR 0 2
49308: PPUSH
49309: LD_EXP 130
49313: PUSH
49314: LD_VAR 0 2
49318: ARRAY
49319: PUSH
49320: LD_VAR 0 3
49324: DIFF
49325: PPUSH
49326: CALL_OW 1
49330: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49331: LD_VAR 0 3
49335: PPUSH
49336: LD_INT 0
49338: PPUSH
49339: CALL_OW 109
// continue ;
49343: GO 49240
// end ; if IsInUnit ( j ) then
49345: LD_VAR 0 3
49349: PPUSH
49350: CALL_OW 310
49354: IFFALSE 49365
// ComExitBuilding ( j ) ;
49356: LD_VAR 0 3
49360: PPUSH
49361: CALL_OW 122
// wait ( 3 ) ;
49365: LD_INT 3
49367: PPUSH
49368: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49372: LD_VAR 0 3
49376: PPUSH
49377: LD_VAR 0 6
49381: PUSH
49382: LD_INT 2
49384: ARRAY
49385: PPUSH
49386: LD_VAR 0 6
49390: PUSH
49391: LD_INT 3
49393: ARRAY
49394: PPUSH
49395: CALL_OW 117
// end ;
49399: GO 49240
49401: POP
49402: POP
// end ; end else
49403: GO 49984
// begin for j in cargo do
49405: LD_ADDR_VAR 0 3
49409: PUSH
49410: LD_VAR 0 7
49414: PUSH
49415: FOR_IN
49416: IFFALSE 49982
// begin if GetTag ( j ) <> 0 then
49418: LD_VAR 0 3
49422: PPUSH
49423: CALL_OW 110
49427: PUSH
49428: LD_INT 0
49430: NONEQUAL
49431: IFFALSE 49435
// continue ;
49433: GO 49415
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49435: LD_VAR 0 3
49439: PPUSH
49440: CALL_OW 256
49444: PUSH
49445: LD_INT 1000
49447: LESS
49448: PUSH
49449: LD_VAR 0 3
49453: PPUSH
49454: LD_EXP 137
49458: PUSH
49459: LD_VAR 0 2
49463: ARRAY
49464: PPUSH
49465: CALL_OW 308
49469: NOT
49470: AND
49471: IFFALSE 49493
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49473: LD_VAR 0 3
49477: PPUSH
49478: LD_EXP 137
49482: PUSH
49483: LD_VAR 0 2
49487: ARRAY
49488: PPUSH
49489: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49493: LD_VAR 0 3
49497: PPUSH
49498: CALL_OW 256
49502: PUSH
49503: LD_INT 1000
49505: LESS
49506: PUSH
49507: LD_VAR 0 3
49511: PPUSH
49512: LD_EXP 137
49516: PUSH
49517: LD_VAR 0 2
49521: ARRAY
49522: PPUSH
49523: CALL_OW 308
49527: AND
49528: IFFALSE 49532
// continue ;
49530: GO 49415
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49532: LD_VAR 0 3
49536: PPUSH
49537: CALL_OW 262
49541: PUSH
49542: LD_INT 2
49544: EQUAL
49545: PUSH
49546: LD_VAR 0 3
49550: PPUSH
49551: CALL_OW 261
49555: PUSH
49556: LD_INT 15
49558: LESS
49559: AND
49560: IFFALSE 49564
// continue ;
49562: GO 49415
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49564: LD_VAR 0 3
49568: PPUSH
49569: CALL_OW 262
49573: PUSH
49574: LD_INT 1
49576: EQUAL
49577: PUSH
49578: LD_VAR 0 3
49582: PPUSH
49583: CALL_OW 261
49587: PUSH
49588: LD_INT 10
49590: LESS
49591: AND
49592: IFFALSE 49921
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49594: LD_ADDR_VAR 0 8
49598: PUSH
49599: LD_EXP 113
49603: PUSH
49604: LD_VAR 0 2
49608: ARRAY
49609: PPUSH
49610: LD_INT 2
49612: PUSH
49613: LD_INT 30
49615: PUSH
49616: LD_INT 0
49618: PUSH
49619: EMPTY
49620: LIST
49621: LIST
49622: PUSH
49623: LD_INT 30
49625: PUSH
49626: LD_INT 1
49628: PUSH
49629: EMPTY
49630: LIST
49631: LIST
49632: PUSH
49633: EMPTY
49634: LIST
49635: LIST
49636: LIST
49637: PPUSH
49638: CALL_OW 72
49642: ST_TO_ADDR
// if not depot then
49643: LD_VAR 0 8
49647: NOT
49648: IFFALSE 49652
// continue ;
49650: GO 49415
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
49652: LD_VAR 0 3
49656: PPUSH
49657: LD_VAR 0 8
49661: PPUSH
49662: LD_VAR 0 3
49666: PPUSH
49667: CALL_OW 74
49671: PPUSH
49672: CALL_OW 296
49676: PUSH
49677: LD_INT 6
49679: LESS
49680: IFFALSE 49696
// SetFuel ( j , 100 ) else
49682: LD_VAR 0 3
49686: PPUSH
49687: LD_INT 100
49689: PPUSH
49690: CALL_OW 240
49694: GO 49921
// if GetFuel ( j ) = 0 then
49696: LD_VAR 0 3
49700: PPUSH
49701: CALL_OW 261
49705: PUSH
49706: LD_INT 0
49708: EQUAL
49709: IFFALSE 49921
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
49711: LD_ADDR_EXP 132
49715: PUSH
49716: LD_EXP 132
49720: PPUSH
49721: LD_VAR 0 2
49725: PPUSH
49726: LD_EXP 132
49730: PUSH
49731: LD_VAR 0 2
49735: ARRAY
49736: PUSH
49737: LD_VAR 0 3
49741: DIFF
49742: PPUSH
49743: CALL_OW 1
49747: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
49748: LD_VAR 0 3
49752: PPUSH
49753: CALL_OW 263
49757: PUSH
49758: LD_INT 1
49760: EQUAL
49761: IFFALSE 49777
// ComExitVehicle ( IsInUnit ( j ) ) ;
49763: LD_VAR 0 3
49767: PPUSH
49768: CALL_OW 310
49772: PPUSH
49773: CALL_OW 121
// if GetControl ( j ) = control_remote then
49777: LD_VAR 0 3
49781: PPUSH
49782: CALL_OW 263
49786: PUSH
49787: LD_INT 2
49789: EQUAL
49790: IFFALSE 49801
// ComUnlink ( j ) ;
49792: LD_VAR 0 3
49796: PPUSH
49797: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
49801: LD_ADDR_VAR 0 9
49805: PUSH
49806: LD_VAR 0 2
49810: PPUSH
49811: LD_INT 3
49813: PPUSH
49814: CALL 59274 0 2
49818: ST_TO_ADDR
// if fac then
49819: LD_VAR 0 9
49823: IFFALSE 49919
// begin for k in fac do
49825: LD_ADDR_VAR 0 4
49829: PUSH
49830: LD_VAR 0 9
49834: PUSH
49835: FOR_IN
49836: IFFALSE 49917
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
49838: LD_ADDR_VAR 0 10
49842: PUSH
49843: LD_VAR 0 9
49847: PPUSH
49848: LD_VAR 0 3
49852: PPUSH
49853: CALL_OW 265
49857: PPUSH
49858: LD_VAR 0 3
49862: PPUSH
49863: CALL_OW 262
49867: PPUSH
49868: LD_VAR 0 3
49872: PPUSH
49873: CALL_OW 263
49877: PPUSH
49878: LD_VAR 0 3
49882: PPUSH
49883: CALL_OW 264
49887: PPUSH
49888: CALL 67660 0 5
49892: ST_TO_ADDR
// if components then
49893: LD_VAR 0 10
49897: IFFALSE 49915
// begin MC_InsertProduceList ( i , components ) ;
49899: LD_VAR 0 2
49903: PPUSH
49904: LD_VAR 0 10
49908: PPUSH
49909: CALL 58819 0 2
// break ;
49913: GO 49917
// end ; end ;
49915: GO 49835
49917: POP
49918: POP
// end ; continue ;
49919: GO 49415
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
49921: LD_VAR 0 3
49925: PPUSH
49926: LD_INT 1
49928: PPUSH
49929: CALL_OW 289
49933: PUSH
49934: LD_INT 100
49936: LESS
49937: PUSH
49938: LD_VAR 0 3
49942: PPUSH
49943: CALL_OW 314
49947: NOT
49948: AND
49949: IFFALSE 49978
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49951: LD_VAR 0 3
49955: PPUSH
49956: LD_VAR 0 6
49960: PUSH
49961: LD_INT 2
49963: ARRAY
49964: PPUSH
49965: LD_VAR 0 6
49969: PUSH
49970: LD_INT 3
49972: ARRAY
49973: PPUSH
49974: CALL_OW 117
// break ;
49978: GO 49982
// end ;
49980: GO 49415
49982: POP
49983: POP
// end ; end ;
49984: GO 48253
49986: POP
49987: POP
// end ;
49988: LD_VAR 0 1
49992: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
49993: LD_INT 0
49995: PPUSH
49996: PPUSH
49997: PPUSH
49998: PPUSH
// if not mc_bases then
49999: LD_EXP 113
50003: NOT
50004: IFFALSE 50008
// exit ;
50006: GO 50169
// for i = 1 to mc_bases do
50008: LD_ADDR_VAR 0 2
50012: PUSH
50013: DOUBLE
50014: LD_INT 1
50016: DEC
50017: ST_TO_ADDR
50018: LD_EXP 113
50022: PUSH
50023: FOR_TO
50024: IFFALSE 50167
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
50026: LD_ADDR_VAR 0 4
50030: PUSH
50031: LD_EXP 132
50035: PUSH
50036: LD_VAR 0 2
50040: ARRAY
50041: PUSH
50042: LD_EXP 135
50046: PUSH
50047: LD_VAR 0 2
50051: ARRAY
50052: UNION
50053: PPUSH
50054: LD_INT 33
50056: PUSH
50057: LD_INT 2
50059: PUSH
50060: EMPTY
50061: LIST
50062: LIST
50063: PPUSH
50064: CALL_OW 72
50068: ST_TO_ADDR
// if tmp then
50069: LD_VAR 0 4
50073: IFFALSE 50165
// for j in tmp do
50075: LD_ADDR_VAR 0 3
50079: PUSH
50080: LD_VAR 0 4
50084: PUSH
50085: FOR_IN
50086: IFFALSE 50163
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
50088: LD_VAR 0 3
50092: PPUSH
50093: CALL_OW 312
50097: NOT
50098: PUSH
50099: LD_VAR 0 3
50103: PPUSH
50104: CALL_OW 256
50108: PUSH
50109: LD_INT 250
50111: GREATEREQUAL
50112: AND
50113: IFFALSE 50126
// Connect ( j ) else
50115: LD_VAR 0 3
50119: PPUSH
50120: CALL 73061 0 1
50124: GO 50161
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
50126: LD_VAR 0 3
50130: PPUSH
50131: CALL_OW 256
50135: PUSH
50136: LD_INT 250
50138: LESS
50139: PUSH
50140: LD_VAR 0 3
50144: PPUSH
50145: CALL_OW 312
50149: AND
50150: IFFALSE 50161
// ComUnlink ( j ) ;
50152: LD_VAR 0 3
50156: PPUSH
50157: CALL_OW 136
50161: GO 50085
50163: POP
50164: POP
// end ;
50165: GO 50023
50167: POP
50168: POP
// end ;
50169: LD_VAR 0 1
50173: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
50174: LD_INT 0
50176: PPUSH
50177: PPUSH
50178: PPUSH
50179: PPUSH
50180: PPUSH
// if not mc_bases then
50181: LD_EXP 113
50185: NOT
50186: IFFALSE 50190
// exit ;
50188: GO 50635
// for i = 1 to mc_bases do
50190: LD_ADDR_VAR 0 2
50194: PUSH
50195: DOUBLE
50196: LD_INT 1
50198: DEC
50199: ST_TO_ADDR
50200: LD_EXP 113
50204: PUSH
50205: FOR_TO
50206: IFFALSE 50633
// begin if not mc_produce [ i ] then
50208: LD_EXP 134
50212: PUSH
50213: LD_VAR 0 2
50217: ARRAY
50218: NOT
50219: IFFALSE 50223
// continue ;
50221: GO 50205
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50223: LD_ADDR_VAR 0 5
50227: PUSH
50228: LD_EXP 113
50232: PUSH
50233: LD_VAR 0 2
50237: ARRAY
50238: PPUSH
50239: LD_INT 30
50241: PUSH
50242: LD_INT 3
50244: PUSH
50245: EMPTY
50246: LIST
50247: LIST
50248: PPUSH
50249: CALL_OW 72
50253: ST_TO_ADDR
// if not fac then
50254: LD_VAR 0 5
50258: NOT
50259: IFFALSE 50263
// continue ;
50261: GO 50205
// for j in fac do
50263: LD_ADDR_VAR 0 3
50267: PUSH
50268: LD_VAR 0 5
50272: PUSH
50273: FOR_IN
50274: IFFALSE 50629
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50276: LD_VAR 0 3
50280: PPUSH
50281: CALL_OW 461
50285: PUSH
50286: LD_INT 2
50288: NONEQUAL
50289: PUSH
50290: LD_VAR 0 3
50294: PPUSH
50295: LD_INT 15
50297: PPUSH
50298: CALL 72721 0 2
50302: PUSH
50303: LD_INT 4
50305: ARRAY
50306: OR
50307: IFFALSE 50311
// continue ;
50309: GO 50273
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50311: LD_VAR 0 3
50315: PPUSH
50316: LD_EXP 134
50320: PUSH
50321: LD_VAR 0 2
50325: ARRAY
50326: PUSH
50327: LD_INT 1
50329: ARRAY
50330: PUSH
50331: LD_INT 1
50333: ARRAY
50334: PPUSH
50335: LD_EXP 134
50339: PUSH
50340: LD_VAR 0 2
50344: ARRAY
50345: PUSH
50346: LD_INT 1
50348: ARRAY
50349: PUSH
50350: LD_INT 2
50352: ARRAY
50353: PPUSH
50354: LD_EXP 134
50358: PUSH
50359: LD_VAR 0 2
50363: ARRAY
50364: PUSH
50365: LD_INT 1
50367: ARRAY
50368: PUSH
50369: LD_INT 3
50371: ARRAY
50372: PPUSH
50373: LD_EXP 134
50377: PUSH
50378: LD_VAR 0 2
50382: ARRAY
50383: PUSH
50384: LD_INT 1
50386: ARRAY
50387: PUSH
50388: LD_INT 4
50390: ARRAY
50391: PPUSH
50392: CALL_OW 448
50396: PUSH
50397: LD_VAR 0 3
50401: PPUSH
50402: LD_EXP 134
50406: PUSH
50407: LD_VAR 0 2
50411: ARRAY
50412: PUSH
50413: LD_INT 1
50415: ARRAY
50416: PUSH
50417: LD_INT 1
50419: ARRAY
50420: PUSH
50421: LD_EXP 134
50425: PUSH
50426: LD_VAR 0 2
50430: ARRAY
50431: PUSH
50432: LD_INT 1
50434: ARRAY
50435: PUSH
50436: LD_INT 2
50438: ARRAY
50439: PUSH
50440: LD_EXP 134
50444: PUSH
50445: LD_VAR 0 2
50449: ARRAY
50450: PUSH
50451: LD_INT 1
50453: ARRAY
50454: PUSH
50455: LD_INT 3
50457: ARRAY
50458: PUSH
50459: LD_EXP 134
50463: PUSH
50464: LD_VAR 0 2
50468: ARRAY
50469: PUSH
50470: LD_INT 1
50472: ARRAY
50473: PUSH
50474: LD_INT 4
50476: ARRAY
50477: PUSH
50478: EMPTY
50479: LIST
50480: LIST
50481: LIST
50482: LIST
50483: PPUSH
50484: CALL 76392 0 2
50488: AND
50489: IFFALSE 50627
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50491: LD_VAR 0 3
50495: PPUSH
50496: LD_EXP 134
50500: PUSH
50501: LD_VAR 0 2
50505: ARRAY
50506: PUSH
50507: LD_INT 1
50509: ARRAY
50510: PUSH
50511: LD_INT 1
50513: ARRAY
50514: PPUSH
50515: LD_EXP 134
50519: PUSH
50520: LD_VAR 0 2
50524: ARRAY
50525: PUSH
50526: LD_INT 1
50528: ARRAY
50529: PUSH
50530: LD_INT 2
50532: ARRAY
50533: PPUSH
50534: LD_EXP 134
50538: PUSH
50539: LD_VAR 0 2
50543: ARRAY
50544: PUSH
50545: LD_INT 1
50547: ARRAY
50548: PUSH
50549: LD_INT 3
50551: ARRAY
50552: PPUSH
50553: LD_EXP 134
50557: PUSH
50558: LD_VAR 0 2
50562: ARRAY
50563: PUSH
50564: LD_INT 1
50566: ARRAY
50567: PUSH
50568: LD_INT 4
50570: ARRAY
50571: PPUSH
50572: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50576: LD_ADDR_VAR 0 4
50580: PUSH
50581: LD_EXP 134
50585: PUSH
50586: LD_VAR 0 2
50590: ARRAY
50591: PPUSH
50592: LD_INT 1
50594: PPUSH
50595: CALL_OW 3
50599: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50600: LD_ADDR_EXP 134
50604: PUSH
50605: LD_EXP 134
50609: PPUSH
50610: LD_VAR 0 2
50614: PPUSH
50615: LD_VAR 0 4
50619: PPUSH
50620: CALL_OW 1
50624: ST_TO_ADDR
// break ;
50625: GO 50629
// end ; end ;
50627: GO 50273
50629: POP
50630: POP
// end ;
50631: GO 50205
50633: POP
50634: POP
// end ;
50635: LD_VAR 0 1
50639: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
50640: LD_INT 0
50642: PPUSH
50643: PPUSH
50644: PPUSH
// if not mc_bases then
50645: LD_EXP 113
50649: NOT
50650: IFFALSE 50654
// exit ;
50652: GO 50743
// for i = 1 to mc_bases do
50654: LD_ADDR_VAR 0 2
50658: PUSH
50659: DOUBLE
50660: LD_INT 1
50662: DEC
50663: ST_TO_ADDR
50664: LD_EXP 113
50668: PUSH
50669: FOR_TO
50670: IFFALSE 50741
// begin if mc_attack [ i ] then
50672: LD_EXP 133
50676: PUSH
50677: LD_VAR 0 2
50681: ARRAY
50682: IFFALSE 50739
// begin tmp := mc_attack [ i ] [ 1 ] ;
50684: LD_ADDR_VAR 0 3
50688: PUSH
50689: LD_EXP 133
50693: PUSH
50694: LD_VAR 0 2
50698: ARRAY
50699: PUSH
50700: LD_INT 1
50702: ARRAY
50703: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50704: LD_ADDR_EXP 133
50708: PUSH
50709: LD_EXP 133
50713: PPUSH
50714: LD_VAR 0 2
50718: PPUSH
50719: EMPTY
50720: PPUSH
50721: CALL_OW 1
50725: ST_TO_ADDR
// Attack ( tmp ) ;
50726: LD_VAR 0 3
50730: PPUSH
50731: CALL 119407 0 1
// exit ;
50735: POP
50736: POP
50737: GO 50743
// end ; end ;
50739: GO 50669
50741: POP
50742: POP
// end ;
50743: LD_VAR 0 1
50747: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
50748: LD_INT 0
50750: PPUSH
50751: PPUSH
50752: PPUSH
50753: PPUSH
50754: PPUSH
50755: PPUSH
50756: PPUSH
// if not mc_bases then
50757: LD_EXP 113
50761: NOT
50762: IFFALSE 50766
// exit ;
50764: GO 51348
// for i = 1 to mc_bases do
50766: LD_ADDR_VAR 0 2
50770: PUSH
50771: DOUBLE
50772: LD_INT 1
50774: DEC
50775: ST_TO_ADDR
50776: LD_EXP 113
50780: PUSH
50781: FOR_TO
50782: IFFALSE 51346
// begin if not mc_bases [ i ] then
50784: LD_EXP 113
50788: PUSH
50789: LD_VAR 0 2
50793: ARRAY
50794: NOT
50795: IFFALSE 50799
// continue ;
50797: GO 50781
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
50799: LD_ADDR_VAR 0 7
50803: PUSH
50804: LD_EXP 113
50808: PUSH
50809: LD_VAR 0 2
50813: ARRAY
50814: PUSH
50815: LD_INT 1
50817: ARRAY
50818: PPUSH
50819: CALL 66964 0 1
50823: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
50824: LD_ADDR_EXP 136
50828: PUSH
50829: LD_EXP 136
50833: PPUSH
50834: LD_VAR 0 2
50838: PPUSH
50839: LD_EXP 113
50843: PUSH
50844: LD_VAR 0 2
50848: ARRAY
50849: PUSH
50850: LD_INT 1
50852: ARRAY
50853: PPUSH
50854: CALL_OW 255
50858: PPUSH
50859: LD_EXP 138
50863: PUSH
50864: LD_VAR 0 2
50868: ARRAY
50869: PPUSH
50870: CALL 66929 0 2
50874: PPUSH
50875: CALL_OW 1
50879: ST_TO_ADDR
// if not mc_scan [ i ] then
50880: LD_EXP 136
50884: PUSH
50885: LD_VAR 0 2
50889: ARRAY
50890: NOT
50891: IFFALSE 51046
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50893: LD_ADDR_VAR 0 4
50897: PUSH
50898: LD_EXP 113
50902: PUSH
50903: LD_VAR 0 2
50907: ARRAY
50908: PPUSH
50909: LD_INT 2
50911: PUSH
50912: LD_INT 25
50914: PUSH
50915: LD_INT 5
50917: PUSH
50918: EMPTY
50919: LIST
50920: LIST
50921: PUSH
50922: LD_INT 25
50924: PUSH
50925: LD_INT 8
50927: PUSH
50928: EMPTY
50929: LIST
50930: LIST
50931: PUSH
50932: LD_INT 25
50934: PUSH
50935: LD_INT 9
50937: PUSH
50938: EMPTY
50939: LIST
50940: LIST
50941: PUSH
50942: EMPTY
50943: LIST
50944: LIST
50945: LIST
50946: LIST
50947: PPUSH
50948: CALL_OW 72
50952: ST_TO_ADDR
// if not tmp then
50953: LD_VAR 0 4
50957: NOT
50958: IFFALSE 50962
// continue ;
50960: GO 50781
// for j in tmp do
50962: LD_ADDR_VAR 0 3
50966: PUSH
50967: LD_VAR 0 4
50971: PUSH
50972: FOR_IN
50973: IFFALSE 51044
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
50975: LD_VAR 0 3
50979: PPUSH
50980: CALL_OW 310
50984: PPUSH
50985: CALL_OW 266
50989: PUSH
50990: LD_INT 5
50992: EQUAL
50993: PUSH
50994: LD_VAR 0 3
50998: PPUSH
50999: CALL_OW 257
51003: PUSH
51004: LD_INT 1
51006: EQUAL
51007: AND
51008: PUSH
51009: LD_VAR 0 3
51013: PPUSH
51014: CALL_OW 459
51018: NOT
51019: AND
51020: PUSH
51021: LD_VAR 0 7
51025: AND
51026: IFFALSE 51042
// ComChangeProfession ( j , class ) ;
51028: LD_VAR 0 3
51032: PPUSH
51033: LD_VAR 0 7
51037: PPUSH
51038: CALL_OW 123
51042: GO 50972
51044: POP
51045: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
51046: LD_EXP 136
51050: PUSH
51051: LD_VAR 0 2
51055: ARRAY
51056: PUSH
51057: LD_EXP 135
51061: PUSH
51062: LD_VAR 0 2
51066: ARRAY
51067: NOT
51068: AND
51069: PUSH
51070: LD_EXP 113
51074: PUSH
51075: LD_VAR 0 2
51079: ARRAY
51080: PPUSH
51081: LD_INT 30
51083: PUSH
51084: LD_INT 32
51086: PUSH
51087: EMPTY
51088: LIST
51089: LIST
51090: PPUSH
51091: CALL_OW 72
51095: NOT
51096: AND
51097: PUSH
51098: LD_EXP 113
51102: PUSH
51103: LD_VAR 0 2
51107: ARRAY
51108: PPUSH
51109: LD_INT 2
51111: PUSH
51112: LD_INT 30
51114: PUSH
51115: LD_INT 4
51117: PUSH
51118: EMPTY
51119: LIST
51120: LIST
51121: PUSH
51122: LD_INT 30
51124: PUSH
51125: LD_INT 5
51127: PUSH
51128: EMPTY
51129: LIST
51130: LIST
51131: PUSH
51132: EMPTY
51133: LIST
51134: LIST
51135: LIST
51136: PPUSH
51137: CALL_OW 72
51141: NOT
51142: AND
51143: IFFALSE 51275
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51145: LD_ADDR_VAR 0 4
51149: PUSH
51150: LD_EXP 113
51154: PUSH
51155: LD_VAR 0 2
51159: ARRAY
51160: PPUSH
51161: LD_INT 2
51163: PUSH
51164: LD_INT 25
51166: PUSH
51167: LD_INT 1
51169: PUSH
51170: EMPTY
51171: LIST
51172: LIST
51173: PUSH
51174: LD_INT 25
51176: PUSH
51177: LD_INT 5
51179: PUSH
51180: EMPTY
51181: LIST
51182: LIST
51183: PUSH
51184: LD_INT 25
51186: PUSH
51187: LD_INT 8
51189: PUSH
51190: EMPTY
51191: LIST
51192: LIST
51193: PUSH
51194: LD_INT 25
51196: PUSH
51197: LD_INT 9
51199: PUSH
51200: EMPTY
51201: LIST
51202: LIST
51203: PUSH
51204: EMPTY
51205: LIST
51206: LIST
51207: LIST
51208: LIST
51209: LIST
51210: PPUSH
51211: CALL_OW 72
51215: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
51216: LD_ADDR_VAR 0 4
51220: PUSH
51221: LD_VAR 0 4
51225: PUSH
51226: LD_VAR 0 4
51230: PPUSH
51231: LD_INT 18
51233: PPUSH
51234: CALL 98689 0 2
51238: DIFF
51239: ST_TO_ADDR
// if tmp then
51240: LD_VAR 0 4
51244: IFFALSE 51275
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
51246: LD_VAR 0 2
51250: PPUSH
51251: LD_VAR 0 4
51255: PPUSH
51256: LD_EXP 138
51260: PUSH
51261: LD_VAR 0 2
51265: ARRAY
51266: PPUSH
51267: CALL 124116 0 3
// exit ;
51271: POP
51272: POP
51273: GO 51348
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
51275: LD_EXP 136
51279: PUSH
51280: LD_VAR 0 2
51284: ARRAY
51285: PUSH
51286: LD_EXP 135
51290: PUSH
51291: LD_VAR 0 2
51295: ARRAY
51296: AND
51297: IFFALSE 51344
// begin tmp := mc_defender [ i ] ;
51299: LD_ADDR_VAR 0 4
51303: PUSH
51304: LD_EXP 135
51308: PUSH
51309: LD_VAR 0 2
51313: ARRAY
51314: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
51315: LD_VAR 0 2
51319: PPUSH
51320: LD_VAR 0 4
51324: PPUSH
51325: LD_EXP 136
51329: PUSH
51330: LD_VAR 0 2
51334: ARRAY
51335: PPUSH
51336: CALL 124677 0 3
// exit ;
51340: POP
51341: POP
51342: GO 51348
// end ; end ;
51344: GO 50781
51346: POP
51347: POP
// end ;
51348: LD_VAR 0 1
51352: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
51353: LD_INT 0
51355: PPUSH
51356: PPUSH
51357: PPUSH
51358: PPUSH
51359: PPUSH
51360: PPUSH
51361: PPUSH
51362: PPUSH
51363: PPUSH
51364: PPUSH
51365: PPUSH
// if not mc_bases then
51366: LD_EXP 113
51370: NOT
51371: IFFALSE 51375
// exit ;
51373: GO 52462
// for i = 1 to mc_bases do
51375: LD_ADDR_VAR 0 2
51379: PUSH
51380: DOUBLE
51381: LD_INT 1
51383: DEC
51384: ST_TO_ADDR
51385: LD_EXP 113
51389: PUSH
51390: FOR_TO
51391: IFFALSE 52460
// begin tmp := mc_lab [ i ] ;
51393: LD_ADDR_VAR 0 6
51397: PUSH
51398: LD_EXP 146
51402: PUSH
51403: LD_VAR 0 2
51407: ARRAY
51408: ST_TO_ADDR
// if not tmp then
51409: LD_VAR 0 6
51413: NOT
51414: IFFALSE 51418
// continue ;
51416: GO 51390
// idle_lab := 0 ;
51418: LD_ADDR_VAR 0 11
51422: PUSH
51423: LD_INT 0
51425: ST_TO_ADDR
// for j in tmp do
51426: LD_ADDR_VAR 0 3
51430: PUSH
51431: LD_VAR 0 6
51435: PUSH
51436: FOR_IN
51437: IFFALSE 52456
// begin researching := false ;
51439: LD_ADDR_VAR 0 10
51443: PUSH
51444: LD_INT 0
51446: ST_TO_ADDR
// side := GetSide ( j ) ;
51447: LD_ADDR_VAR 0 4
51451: PUSH
51452: LD_VAR 0 3
51456: PPUSH
51457: CALL_OW 255
51461: ST_TO_ADDR
// if not mc_tech [ side ] then
51462: LD_EXP 140
51466: PUSH
51467: LD_VAR 0 4
51471: ARRAY
51472: NOT
51473: IFFALSE 51477
// continue ;
51475: GO 51436
// if BuildingStatus ( j ) = bs_idle then
51477: LD_VAR 0 3
51481: PPUSH
51482: CALL_OW 461
51486: PUSH
51487: LD_INT 2
51489: EQUAL
51490: IFFALSE 51678
// begin if idle_lab and UnitsInside ( j ) < 6 then
51492: LD_VAR 0 11
51496: PUSH
51497: LD_VAR 0 3
51501: PPUSH
51502: CALL_OW 313
51506: PUSH
51507: LD_INT 6
51509: LESS
51510: AND
51511: IFFALSE 51582
// begin tmp2 := UnitsInside ( idle_lab ) ;
51513: LD_ADDR_VAR 0 9
51517: PUSH
51518: LD_VAR 0 11
51522: PPUSH
51523: CALL_OW 313
51527: ST_TO_ADDR
// if tmp2 then
51528: LD_VAR 0 9
51532: IFFALSE 51574
// for x in tmp2 do
51534: LD_ADDR_VAR 0 7
51538: PUSH
51539: LD_VAR 0 9
51543: PUSH
51544: FOR_IN
51545: IFFALSE 51572
// begin ComExitBuilding ( x ) ;
51547: LD_VAR 0 7
51551: PPUSH
51552: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51556: LD_VAR 0 7
51560: PPUSH
51561: LD_VAR 0 3
51565: PPUSH
51566: CALL_OW 180
// end ;
51570: GO 51544
51572: POP
51573: POP
// idle_lab := 0 ;
51574: LD_ADDR_VAR 0 11
51578: PUSH
51579: LD_INT 0
51581: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
51582: LD_ADDR_VAR 0 5
51586: PUSH
51587: LD_EXP 140
51591: PUSH
51592: LD_VAR 0 4
51596: ARRAY
51597: PUSH
51598: FOR_IN
51599: IFFALSE 51659
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
51601: LD_VAR 0 3
51605: PPUSH
51606: LD_VAR 0 5
51610: PPUSH
51611: CALL_OW 430
51615: PUSH
51616: LD_VAR 0 4
51620: PPUSH
51621: LD_VAR 0 5
51625: PPUSH
51626: CALL 66034 0 2
51630: AND
51631: IFFALSE 51657
// begin researching := true ;
51633: LD_ADDR_VAR 0 10
51637: PUSH
51638: LD_INT 1
51640: ST_TO_ADDR
// ComResearch ( j , t ) ;
51641: LD_VAR 0 3
51645: PPUSH
51646: LD_VAR 0 5
51650: PPUSH
51651: CALL_OW 124
// break ;
51655: GO 51659
// end ;
51657: GO 51598
51659: POP
51660: POP
// if not researching then
51661: LD_VAR 0 10
51665: NOT
51666: IFFALSE 51678
// idle_lab := j ;
51668: LD_ADDR_VAR 0 11
51672: PUSH
51673: LD_VAR 0 3
51677: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
51678: LD_VAR 0 3
51682: PPUSH
51683: CALL_OW 461
51687: PUSH
51688: LD_INT 10
51690: EQUAL
51691: IFFALSE 52279
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
51693: LD_EXP 142
51697: PUSH
51698: LD_VAR 0 2
51702: ARRAY
51703: NOT
51704: PUSH
51705: LD_EXP 143
51709: PUSH
51710: LD_VAR 0 2
51714: ARRAY
51715: NOT
51716: AND
51717: PUSH
51718: LD_EXP 140
51722: PUSH
51723: LD_VAR 0 4
51727: ARRAY
51728: PUSH
51729: LD_INT 1
51731: GREATER
51732: AND
51733: IFFALSE 51864
// begin ComCancel ( j ) ;
51735: LD_VAR 0 3
51739: PPUSH
51740: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
51744: LD_ADDR_EXP 140
51748: PUSH
51749: LD_EXP 140
51753: PPUSH
51754: LD_VAR 0 4
51758: PPUSH
51759: LD_EXP 140
51763: PUSH
51764: LD_VAR 0 4
51768: ARRAY
51769: PPUSH
51770: LD_EXP 140
51774: PUSH
51775: LD_VAR 0 4
51779: ARRAY
51780: PUSH
51781: LD_INT 1
51783: MINUS
51784: PPUSH
51785: LD_EXP 140
51789: PUSH
51790: LD_VAR 0 4
51794: ARRAY
51795: PPUSH
51796: LD_INT 0
51798: PPUSH
51799: CALL 69546 0 4
51803: PPUSH
51804: CALL_OW 1
51808: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
51809: LD_ADDR_EXP 140
51813: PUSH
51814: LD_EXP 140
51818: PPUSH
51819: LD_VAR 0 4
51823: PPUSH
51824: LD_EXP 140
51828: PUSH
51829: LD_VAR 0 4
51833: ARRAY
51834: PPUSH
51835: LD_EXP 140
51839: PUSH
51840: LD_VAR 0 4
51844: ARRAY
51845: PPUSH
51846: LD_INT 1
51848: PPUSH
51849: LD_INT 0
51851: PPUSH
51852: CALL 69546 0 4
51856: PPUSH
51857: CALL_OW 1
51861: ST_TO_ADDR
// continue ;
51862: GO 51436
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
51864: LD_EXP 142
51868: PUSH
51869: LD_VAR 0 2
51873: ARRAY
51874: PUSH
51875: LD_EXP 143
51879: PUSH
51880: LD_VAR 0 2
51884: ARRAY
51885: NOT
51886: AND
51887: IFFALSE 52014
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
51889: LD_ADDR_EXP 143
51893: PUSH
51894: LD_EXP 143
51898: PPUSH
51899: LD_VAR 0 2
51903: PUSH
51904: LD_EXP 143
51908: PUSH
51909: LD_VAR 0 2
51913: ARRAY
51914: PUSH
51915: LD_INT 1
51917: PLUS
51918: PUSH
51919: EMPTY
51920: LIST
51921: LIST
51922: PPUSH
51923: LD_EXP 142
51927: PUSH
51928: LD_VAR 0 2
51932: ARRAY
51933: PUSH
51934: LD_INT 1
51936: ARRAY
51937: PPUSH
51938: CALL 70128 0 3
51942: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
51943: LD_EXP 142
51947: PUSH
51948: LD_VAR 0 2
51952: ARRAY
51953: PUSH
51954: LD_INT 1
51956: ARRAY
51957: PPUSH
51958: LD_INT 112
51960: PPUSH
51961: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
51965: LD_ADDR_VAR 0 9
51969: PUSH
51970: LD_EXP 142
51974: PUSH
51975: LD_VAR 0 2
51979: ARRAY
51980: PPUSH
51981: LD_INT 1
51983: PPUSH
51984: CALL_OW 3
51988: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
51989: LD_ADDR_EXP 142
51993: PUSH
51994: LD_EXP 142
51998: PPUSH
51999: LD_VAR 0 2
52003: PPUSH
52004: LD_VAR 0 9
52008: PPUSH
52009: CALL_OW 1
52013: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
52014: LD_EXP 142
52018: PUSH
52019: LD_VAR 0 2
52023: ARRAY
52024: PUSH
52025: LD_EXP 143
52029: PUSH
52030: LD_VAR 0 2
52034: ARRAY
52035: AND
52036: PUSH
52037: LD_EXP 143
52041: PUSH
52042: LD_VAR 0 2
52046: ARRAY
52047: PUSH
52048: LD_INT 1
52050: ARRAY
52051: PPUSH
52052: CALL_OW 310
52056: NOT
52057: AND
52058: PUSH
52059: LD_VAR 0 3
52063: PPUSH
52064: CALL_OW 313
52068: PUSH
52069: LD_INT 6
52071: EQUAL
52072: AND
52073: IFFALSE 52129
// begin tmp2 := UnitsInside ( j ) ;
52075: LD_ADDR_VAR 0 9
52079: PUSH
52080: LD_VAR 0 3
52084: PPUSH
52085: CALL_OW 313
52089: ST_TO_ADDR
// if tmp2 = 6 then
52090: LD_VAR 0 9
52094: PUSH
52095: LD_INT 6
52097: EQUAL
52098: IFFALSE 52129
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
52100: LD_VAR 0 9
52104: PUSH
52105: LD_INT 1
52107: ARRAY
52108: PPUSH
52109: LD_INT 112
52111: PPUSH
52112: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
52116: LD_VAR 0 9
52120: PUSH
52121: LD_INT 1
52123: ARRAY
52124: PPUSH
52125: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
52129: LD_EXP 143
52133: PUSH
52134: LD_VAR 0 2
52138: ARRAY
52139: PUSH
52140: LD_EXP 143
52144: PUSH
52145: LD_VAR 0 2
52149: ARRAY
52150: PUSH
52151: LD_INT 1
52153: ARRAY
52154: PPUSH
52155: CALL_OW 314
52159: NOT
52160: AND
52161: PUSH
52162: LD_EXP 143
52166: PUSH
52167: LD_VAR 0 2
52171: ARRAY
52172: PUSH
52173: LD_INT 1
52175: ARRAY
52176: PPUSH
52177: CALL_OW 310
52181: NOT
52182: AND
52183: IFFALSE 52209
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
52185: LD_EXP 143
52189: PUSH
52190: LD_VAR 0 2
52194: ARRAY
52195: PUSH
52196: LD_INT 1
52198: ARRAY
52199: PPUSH
52200: LD_VAR 0 3
52204: PPUSH
52205: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
52209: LD_EXP 143
52213: PUSH
52214: LD_VAR 0 2
52218: ARRAY
52219: PUSH
52220: LD_INT 1
52222: ARRAY
52223: PPUSH
52224: CALL_OW 310
52228: PUSH
52229: LD_EXP 143
52233: PUSH
52234: LD_VAR 0 2
52238: ARRAY
52239: PUSH
52240: LD_INT 1
52242: ARRAY
52243: PPUSH
52244: CALL_OW 310
52248: PPUSH
52249: CALL_OW 461
52253: PUSH
52254: LD_INT 3
52256: NONEQUAL
52257: AND
52258: IFFALSE 52279
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
52260: LD_EXP 143
52264: PUSH
52265: LD_VAR 0 2
52269: ARRAY
52270: PUSH
52271: LD_INT 1
52273: ARRAY
52274: PPUSH
52275: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52279: LD_VAR 0 3
52283: PPUSH
52284: CALL_OW 461
52288: PUSH
52289: LD_INT 6
52291: EQUAL
52292: PUSH
52293: LD_VAR 0 6
52297: PUSH
52298: LD_INT 1
52300: GREATER
52301: AND
52302: IFFALSE 52454
// begin sci := [ ] ;
52304: LD_ADDR_VAR 0 8
52308: PUSH
52309: EMPTY
52310: ST_TO_ADDR
// for x in ( tmp diff j ) do
52311: LD_ADDR_VAR 0 7
52315: PUSH
52316: LD_VAR 0 6
52320: PUSH
52321: LD_VAR 0 3
52325: DIFF
52326: PUSH
52327: FOR_IN
52328: IFFALSE 52380
// begin if sci = 6 then
52330: LD_VAR 0 8
52334: PUSH
52335: LD_INT 6
52337: EQUAL
52338: IFFALSE 52342
// break ;
52340: GO 52380
// if BuildingStatus ( x ) = bs_idle then
52342: LD_VAR 0 7
52346: PPUSH
52347: CALL_OW 461
52351: PUSH
52352: LD_INT 2
52354: EQUAL
52355: IFFALSE 52378
// sci := sci ^ UnitsInside ( x ) ;
52357: LD_ADDR_VAR 0 8
52361: PUSH
52362: LD_VAR 0 8
52366: PUSH
52367: LD_VAR 0 7
52371: PPUSH
52372: CALL_OW 313
52376: ADD
52377: ST_TO_ADDR
// end ;
52378: GO 52327
52380: POP
52381: POP
// if not sci then
52382: LD_VAR 0 8
52386: NOT
52387: IFFALSE 52391
// continue ;
52389: GO 51436
// for x in sci do
52391: LD_ADDR_VAR 0 7
52395: PUSH
52396: LD_VAR 0 8
52400: PUSH
52401: FOR_IN
52402: IFFALSE 52452
// if IsInUnit ( x ) and not HasTask ( x ) then
52404: LD_VAR 0 7
52408: PPUSH
52409: CALL_OW 310
52413: PUSH
52414: LD_VAR 0 7
52418: PPUSH
52419: CALL_OW 314
52423: NOT
52424: AND
52425: IFFALSE 52450
// begin ComExitBuilding ( x ) ;
52427: LD_VAR 0 7
52431: PPUSH
52432: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52436: LD_VAR 0 7
52440: PPUSH
52441: LD_VAR 0 3
52445: PPUSH
52446: CALL_OW 180
// end ;
52450: GO 52401
52452: POP
52453: POP
// end ; end ;
52454: GO 51436
52456: POP
52457: POP
// end ;
52458: GO 51390
52460: POP
52461: POP
// end ;
52462: LD_VAR 0 1
52466: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
52467: LD_INT 0
52469: PPUSH
52470: PPUSH
// if not mc_bases then
52471: LD_EXP 113
52475: NOT
52476: IFFALSE 52480
// exit ;
52478: GO 52561
// for i = 1 to mc_bases do
52480: LD_ADDR_VAR 0 2
52484: PUSH
52485: DOUBLE
52486: LD_INT 1
52488: DEC
52489: ST_TO_ADDR
52490: LD_EXP 113
52494: PUSH
52495: FOR_TO
52496: IFFALSE 52559
// if mc_mines [ i ] and mc_miners [ i ] then
52498: LD_EXP 126
52502: PUSH
52503: LD_VAR 0 2
52507: ARRAY
52508: PUSH
52509: LD_EXP 127
52513: PUSH
52514: LD_VAR 0 2
52518: ARRAY
52519: AND
52520: IFFALSE 52557
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
52522: LD_EXP 127
52526: PUSH
52527: LD_VAR 0 2
52531: ARRAY
52532: PUSH
52533: LD_INT 1
52535: ARRAY
52536: PPUSH
52537: CALL_OW 255
52541: PPUSH
52542: LD_EXP 126
52546: PUSH
52547: LD_VAR 0 2
52551: ARRAY
52552: PPUSH
52553: CALL 67117 0 2
52557: GO 52495
52559: POP
52560: POP
// end ;
52561: LD_VAR 0 1
52565: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
52566: LD_INT 0
52568: PPUSH
52569: PPUSH
52570: PPUSH
52571: PPUSH
52572: PPUSH
52573: PPUSH
52574: PPUSH
52575: PPUSH
// if not mc_bases or not mc_parking then
52576: LD_EXP 113
52580: NOT
52581: PUSH
52582: LD_EXP 137
52586: NOT
52587: OR
52588: IFFALSE 52592
// exit ;
52590: GO 53291
// for i = 1 to mc_bases do
52592: LD_ADDR_VAR 0 2
52596: PUSH
52597: DOUBLE
52598: LD_INT 1
52600: DEC
52601: ST_TO_ADDR
52602: LD_EXP 113
52606: PUSH
52607: FOR_TO
52608: IFFALSE 53289
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
52610: LD_EXP 113
52614: PUSH
52615: LD_VAR 0 2
52619: ARRAY
52620: NOT
52621: PUSH
52622: LD_EXP 137
52626: PUSH
52627: LD_VAR 0 2
52631: ARRAY
52632: NOT
52633: OR
52634: IFFALSE 52638
// continue ;
52636: GO 52607
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52638: LD_ADDR_VAR 0 5
52642: PUSH
52643: LD_EXP 113
52647: PUSH
52648: LD_VAR 0 2
52652: ARRAY
52653: PUSH
52654: LD_INT 1
52656: ARRAY
52657: PPUSH
52658: CALL_OW 255
52662: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52663: LD_ADDR_VAR 0 6
52667: PUSH
52668: LD_EXP 113
52672: PUSH
52673: LD_VAR 0 2
52677: ARRAY
52678: PPUSH
52679: LD_INT 30
52681: PUSH
52682: LD_INT 3
52684: PUSH
52685: EMPTY
52686: LIST
52687: LIST
52688: PPUSH
52689: CALL_OW 72
52693: ST_TO_ADDR
// if not fac then
52694: LD_VAR 0 6
52698: NOT
52699: IFFALSE 52750
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52701: LD_ADDR_VAR 0 6
52705: PUSH
52706: LD_EXP 113
52710: PUSH
52711: LD_VAR 0 2
52715: ARRAY
52716: PPUSH
52717: LD_INT 2
52719: PUSH
52720: LD_INT 30
52722: PUSH
52723: LD_INT 0
52725: PUSH
52726: EMPTY
52727: LIST
52728: LIST
52729: PUSH
52730: LD_INT 30
52732: PUSH
52733: LD_INT 1
52735: PUSH
52736: EMPTY
52737: LIST
52738: LIST
52739: PUSH
52740: EMPTY
52741: LIST
52742: LIST
52743: LIST
52744: PPUSH
52745: CALL_OW 72
52749: ST_TO_ADDR
// if not fac then
52750: LD_VAR 0 6
52754: NOT
52755: IFFALSE 52759
// continue ;
52757: GO 52607
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52759: LD_ADDR_VAR 0 7
52763: PUSH
52764: LD_EXP 137
52768: PUSH
52769: LD_VAR 0 2
52773: ARRAY
52774: PPUSH
52775: LD_INT 22
52777: PUSH
52778: LD_VAR 0 5
52782: PUSH
52783: EMPTY
52784: LIST
52785: LIST
52786: PUSH
52787: LD_INT 21
52789: PUSH
52790: LD_INT 2
52792: PUSH
52793: EMPTY
52794: LIST
52795: LIST
52796: PUSH
52797: LD_INT 3
52799: PUSH
52800: LD_INT 24
52802: PUSH
52803: LD_INT 1000
52805: PUSH
52806: EMPTY
52807: LIST
52808: LIST
52809: PUSH
52810: EMPTY
52811: LIST
52812: LIST
52813: PUSH
52814: EMPTY
52815: LIST
52816: LIST
52817: LIST
52818: PPUSH
52819: CALL_OW 70
52823: ST_TO_ADDR
// for j in fac do
52824: LD_ADDR_VAR 0 3
52828: PUSH
52829: LD_VAR 0 6
52833: PUSH
52834: FOR_IN
52835: IFFALSE 52916
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52837: LD_ADDR_VAR 0 7
52841: PUSH
52842: LD_VAR 0 7
52846: PUSH
52847: LD_INT 22
52849: PUSH
52850: LD_VAR 0 5
52854: PUSH
52855: EMPTY
52856: LIST
52857: LIST
52858: PUSH
52859: LD_INT 91
52861: PUSH
52862: LD_VAR 0 3
52866: PUSH
52867: LD_INT 15
52869: PUSH
52870: EMPTY
52871: LIST
52872: LIST
52873: LIST
52874: PUSH
52875: LD_INT 21
52877: PUSH
52878: LD_INT 2
52880: PUSH
52881: EMPTY
52882: LIST
52883: LIST
52884: PUSH
52885: LD_INT 3
52887: PUSH
52888: LD_INT 24
52890: PUSH
52891: LD_INT 1000
52893: PUSH
52894: EMPTY
52895: LIST
52896: LIST
52897: PUSH
52898: EMPTY
52899: LIST
52900: LIST
52901: PUSH
52902: EMPTY
52903: LIST
52904: LIST
52905: LIST
52906: LIST
52907: PPUSH
52908: CALL_OW 69
52912: UNION
52913: ST_TO_ADDR
52914: GO 52834
52916: POP
52917: POP
// if not vehs then
52918: LD_VAR 0 7
52922: NOT
52923: IFFALSE 52949
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52925: LD_ADDR_EXP 125
52929: PUSH
52930: LD_EXP 125
52934: PPUSH
52935: LD_VAR 0 2
52939: PPUSH
52940: EMPTY
52941: PPUSH
52942: CALL_OW 1
52946: ST_TO_ADDR
// continue ;
52947: GO 52607
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52949: LD_ADDR_VAR 0 8
52953: PUSH
52954: LD_EXP 113
52958: PUSH
52959: LD_VAR 0 2
52963: ARRAY
52964: PPUSH
52965: LD_INT 30
52967: PUSH
52968: LD_INT 3
52970: PUSH
52971: EMPTY
52972: LIST
52973: LIST
52974: PPUSH
52975: CALL_OW 72
52979: ST_TO_ADDR
// if tmp then
52980: LD_VAR 0 8
52984: IFFALSE 53087
// begin for j in tmp do
52986: LD_ADDR_VAR 0 3
52990: PUSH
52991: LD_VAR 0 8
52995: PUSH
52996: FOR_IN
52997: IFFALSE 53085
// for k in UnitsInside ( j ) do
52999: LD_ADDR_VAR 0 4
53003: PUSH
53004: LD_VAR 0 3
53008: PPUSH
53009: CALL_OW 313
53013: PUSH
53014: FOR_IN
53015: IFFALSE 53081
// if k then
53017: LD_VAR 0 4
53021: IFFALSE 53079
// if not k in mc_repair_vehicle [ i ] then
53023: LD_VAR 0 4
53027: PUSH
53028: LD_EXP 125
53032: PUSH
53033: LD_VAR 0 2
53037: ARRAY
53038: IN
53039: NOT
53040: IFFALSE 53079
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
53042: LD_ADDR_EXP 125
53046: PUSH
53047: LD_EXP 125
53051: PPUSH
53052: LD_VAR 0 2
53056: PPUSH
53057: LD_EXP 125
53061: PUSH
53062: LD_VAR 0 2
53066: ARRAY
53067: PUSH
53068: LD_VAR 0 4
53072: UNION
53073: PPUSH
53074: CALL_OW 1
53078: ST_TO_ADDR
53079: GO 53014
53081: POP
53082: POP
53083: GO 52996
53085: POP
53086: POP
// end ; if not mc_repair_vehicle [ i ] then
53087: LD_EXP 125
53091: PUSH
53092: LD_VAR 0 2
53096: ARRAY
53097: NOT
53098: IFFALSE 53102
// continue ;
53100: GO 52607
// for j in mc_repair_vehicle [ i ] do
53102: LD_ADDR_VAR 0 3
53106: PUSH
53107: LD_EXP 125
53111: PUSH
53112: LD_VAR 0 2
53116: ARRAY
53117: PUSH
53118: FOR_IN
53119: IFFALSE 53285
// begin if GetClass ( j ) <> 3 then
53121: LD_VAR 0 3
53125: PPUSH
53126: CALL_OW 257
53130: PUSH
53131: LD_INT 3
53133: NONEQUAL
53134: IFFALSE 53175
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
53136: LD_ADDR_EXP 125
53140: PUSH
53141: LD_EXP 125
53145: PPUSH
53146: LD_VAR 0 2
53150: PPUSH
53151: LD_EXP 125
53155: PUSH
53156: LD_VAR 0 2
53160: ARRAY
53161: PUSH
53162: LD_VAR 0 3
53166: DIFF
53167: PPUSH
53168: CALL_OW 1
53172: ST_TO_ADDR
// continue ;
53173: GO 53118
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53175: LD_VAR 0 3
53179: PPUSH
53180: CALL_OW 311
53184: NOT
53185: PUSH
53186: LD_VAR 0 3
53190: PUSH
53191: LD_EXP 116
53195: PUSH
53196: LD_VAR 0 2
53200: ARRAY
53201: PUSH
53202: LD_INT 1
53204: ARRAY
53205: IN
53206: NOT
53207: AND
53208: PUSH
53209: LD_VAR 0 3
53213: PUSH
53214: LD_EXP 116
53218: PUSH
53219: LD_VAR 0 2
53223: ARRAY
53224: PUSH
53225: LD_INT 2
53227: ARRAY
53228: IN
53229: NOT
53230: AND
53231: IFFALSE 53283
// begin if IsInUnit ( j ) then
53233: LD_VAR 0 3
53237: PPUSH
53238: CALL_OW 310
53242: IFFALSE 53253
// ComExitBuilding ( j ) ;
53244: LD_VAR 0 3
53248: PPUSH
53249: CALL_OW 122
// if not HasTask ( j ) then
53253: LD_VAR 0 3
53257: PPUSH
53258: CALL_OW 314
53262: NOT
53263: IFFALSE 53283
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
53265: LD_VAR 0 3
53269: PPUSH
53270: LD_VAR 0 7
53274: PUSH
53275: LD_INT 1
53277: ARRAY
53278: PPUSH
53279: CALL_OW 189
// end ; end ;
53283: GO 53118
53285: POP
53286: POP
// end ;
53287: GO 52607
53289: POP
53290: POP
// end ;
53291: LD_VAR 0 1
53295: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53296: LD_INT 0
53298: PPUSH
53299: PPUSH
53300: PPUSH
53301: PPUSH
53302: PPUSH
53303: PPUSH
53304: PPUSH
53305: PPUSH
53306: PPUSH
53307: PPUSH
53308: PPUSH
// if not mc_bases then
53309: LD_EXP 113
53313: NOT
53314: IFFALSE 53318
// exit ;
53316: GO 54120
// for i = 1 to mc_bases do
53318: LD_ADDR_VAR 0 2
53322: PUSH
53323: DOUBLE
53324: LD_INT 1
53326: DEC
53327: ST_TO_ADDR
53328: LD_EXP 113
53332: PUSH
53333: FOR_TO
53334: IFFALSE 54118
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
53336: LD_EXP 141
53340: PUSH
53341: LD_VAR 0 2
53345: ARRAY
53346: NOT
53347: PUSH
53348: LD_EXP 116
53352: PUSH
53353: LD_VAR 0 2
53357: ARRAY
53358: PUSH
53359: LD_INT 1
53361: ARRAY
53362: OR
53363: PUSH
53364: LD_EXP 116
53368: PUSH
53369: LD_VAR 0 2
53373: ARRAY
53374: PUSH
53375: LD_INT 2
53377: ARRAY
53378: OR
53379: PUSH
53380: LD_EXP 139
53384: PUSH
53385: LD_VAR 0 2
53389: ARRAY
53390: PPUSH
53391: LD_INT 1
53393: PPUSH
53394: CALL_OW 325
53398: NOT
53399: OR
53400: PUSH
53401: LD_EXP 136
53405: PUSH
53406: LD_VAR 0 2
53410: ARRAY
53411: OR
53412: IFFALSE 53416
// continue ;
53414: GO 53333
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
53416: LD_ADDR_VAR 0 8
53420: PUSH
53421: LD_EXP 113
53425: PUSH
53426: LD_VAR 0 2
53430: ARRAY
53431: PPUSH
53432: LD_INT 25
53434: PUSH
53435: LD_INT 4
53437: PUSH
53438: EMPTY
53439: LIST
53440: LIST
53441: PUSH
53442: LD_INT 50
53444: PUSH
53445: EMPTY
53446: LIST
53447: PUSH
53448: LD_INT 3
53450: PUSH
53451: LD_INT 60
53453: PUSH
53454: EMPTY
53455: LIST
53456: PUSH
53457: EMPTY
53458: LIST
53459: LIST
53460: PUSH
53461: EMPTY
53462: LIST
53463: LIST
53464: LIST
53465: PPUSH
53466: CALL_OW 72
53470: PUSH
53471: LD_EXP 117
53475: PUSH
53476: LD_VAR 0 2
53480: ARRAY
53481: DIFF
53482: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53483: LD_ADDR_VAR 0 9
53487: PUSH
53488: LD_EXP 113
53492: PUSH
53493: LD_VAR 0 2
53497: ARRAY
53498: PPUSH
53499: LD_INT 2
53501: PUSH
53502: LD_INT 30
53504: PUSH
53505: LD_INT 0
53507: PUSH
53508: EMPTY
53509: LIST
53510: LIST
53511: PUSH
53512: LD_INT 30
53514: PUSH
53515: LD_INT 1
53517: PUSH
53518: EMPTY
53519: LIST
53520: LIST
53521: PUSH
53522: EMPTY
53523: LIST
53524: LIST
53525: LIST
53526: PPUSH
53527: CALL_OW 72
53531: ST_TO_ADDR
// if not tmp or not dep then
53532: LD_VAR 0 8
53536: NOT
53537: PUSH
53538: LD_VAR 0 9
53542: NOT
53543: OR
53544: IFFALSE 53548
// continue ;
53546: GO 53333
// side := GetSide ( tmp [ 1 ] ) ;
53548: LD_ADDR_VAR 0 11
53552: PUSH
53553: LD_VAR 0 8
53557: PUSH
53558: LD_INT 1
53560: ARRAY
53561: PPUSH
53562: CALL_OW 255
53566: ST_TO_ADDR
// dep := dep [ 1 ] ;
53567: LD_ADDR_VAR 0 9
53571: PUSH
53572: LD_VAR 0 9
53576: PUSH
53577: LD_INT 1
53579: ARRAY
53580: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
53581: LD_ADDR_VAR 0 7
53585: PUSH
53586: LD_EXP 141
53590: PUSH
53591: LD_VAR 0 2
53595: ARRAY
53596: PPUSH
53597: LD_INT 22
53599: PUSH
53600: LD_INT 0
53602: PUSH
53603: EMPTY
53604: LIST
53605: LIST
53606: PUSH
53607: LD_INT 25
53609: PUSH
53610: LD_INT 12
53612: PUSH
53613: EMPTY
53614: LIST
53615: LIST
53616: PUSH
53617: EMPTY
53618: LIST
53619: LIST
53620: PPUSH
53621: CALL_OW 70
53625: PUSH
53626: LD_INT 22
53628: PUSH
53629: LD_INT 0
53631: PUSH
53632: EMPTY
53633: LIST
53634: LIST
53635: PUSH
53636: LD_INT 25
53638: PUSH
53639: LD_INT 12
53641: PUSH
53642: EMPTY
53643: LIST
53644: LIST
53645: PUSH
53646: LD_INT 91
53648: PUSH
53649: LD_VAR 0 9
53653: PUSH
53654: LD_INT 20
53656: PUSH
53657: EMPTY
53658: LIST
53659: LIST
53660: LIST
53661: PUSH
53662: EMPTY
53663: LIST
53664: LIST
53665: LIST
53666: PPUSH
53667: CALL_OW 69
53671: UNION
53672: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
53673: LD_ADDR_VAR 0 10
53677: PUSH
53678: LD_EXP 141
53682: PUSH
53683: LD_VAR 0 2
53687: ARRAY
53688: PPUSH
53689: LD_INT 81
53691: PUSH
53692: LD_VAR 0 11
53696: PUSH
53697: EMPTY
53698: LIST
53699: LIST
53700: PPUSH
53701: CALL_OW 70
53705: ST_TO_ADDR
// if not apes or danger_at_area then
53706: LD_VAR 0 7
53710: NOT
53711: PUSH
53712: LD_VAR 0 10
53716: OR
53717: IFFALSE 53767
// begin if mc_taming [ i ] then
53719: LD_EXP 144
53723: PUSH
53724: LD_VAR 0 2
53728: ARRAY
53729: IFFALSE 53765
// begin MC_Reset ( i , 121 ) ;
53731: LD_VAR 0 2
53735: PPUSH
53736: LD_INT 121
53738: PPUSH
53739: CALL 39192 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53743: LD_ADDR_EXP 144
53747: PUSH
53748: LD_EXP 144
53752: PPUSH
53753: LD_VAR 0 2
53757: PPUSH
53758: EMPTY
53759: PPUSH
53760: CALL_OW 1
53764: ST_TO_ADDR
// end ; continue ;
53765: GO 53333
// end ; for j in tmp do
53767: LD_ADDR_VAR 0 3
53771: PUSH
53772: LD_VAR 0 8
53776: PUSH
53777: FOR_IN
53778: IFFALSE 54114
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
53780: LD_VAR 0 3
53784: PUSH
53785: LD_EXP 144
53789: PUSH
53790: LD_VAR 0 2
53794: ARRAY
53795: IN
53796: NOT
53797: PUSH
53798: LD_EXP 144
53802: PUSH
53803: LD_VAR 0 2
53807: ARRAY
53808: PUSH
53809: LD_INT 3
53811: LESS
53812: AND
53813: IFFALSE 53871
// begin SetTag ( j , 121 ) ;
53815: LD_VAR 0 3
53819: PPUSH
53820: LD_INT 121
53822: PPUSH
53823: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
53827: LD_ADDR_EXP 144
53831: PUSH
53832: LD_EXP 144
53836: PPUSH
53837: LD_VAR 0 2
53841: PUSH
53842: LD_EXP 144
53846: PUSH
53847: LD_VAR 0 2
53851: ARRAY
53852: PUSH
53853: LD_INT 1
53855: PLUS
53856: PUSH
53857: EMPTY
53858: LIST
53859: LIST
53860: PPUSH
53861: LD_VAR 0 3
53865: PPUSH
53866: CALL 70128 0 3
53870: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
53871: LD_VAR 0 3
53875: PUSH
53876: LD_EXP 144
53880: PUSH
53881: LD_VAR 0 2
53885: ARRAY
53886: IN
53887: IFFALSE 54112
// begin if GetClass ( j ) <> 4 then
53889: LD_VAR 0 3
53893: PPUSH
53894: CALL_OW 257
53898: PUSH
53899: LD_INT 4
53901: NONEQUAL
53902: IFFALSE 53955
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
53904: LD_ADDR_EXP 144
53908: PUSH
53909: LD_EXP 144
53913: PPUSH
53914: LD_VAR 0 2
53918: PPUSH
53919: LD_EXP 144
53923: PUSH
53924: LD_VAR 0 2
53928: ARRAY
53929: PUSH
53930: LD_VAR 0 3
53934: DIFF
53935: PPUSH
53936: CALL_OW 1
53940: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53941: LD_VAR 0 3
53945: PPUSH
53946: LD_INT 0
53948: PPUSH
53949: CALL_OW 109
// continue ;
53953: GO 53777
// end ; if IsInUnit ( j ) then
53955: LD_VAR 0 3
53959: PPUSH
53960: CALL_OW 310
53964: IFFALSE 53975
// ComExitBuilding ( j ) ;
53966: LD_VAR 0 3
53970: PPUSH
53971: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
53975: LD_ADDR_VAR 0 6
53979: PUSH
53980: LD_VAR 0 7
53984: PPUSH
53985: LD_VAR 0 3
53989: PPUSH
53990: CALL_OW 74
53994: ST_TO_ADDR
// if not ape then
53995: LD_VAR 0 6
53999: NOT
54000: IFFALSE 54004
// break ;
54002: GO 54114
// x := GetX ( ape ) ;
54004: LD_ADDR_VAR 0 4
54008: PUSH
54009: LD_VAR 0 6
54013: PPUSH
54014: CALL_OW 250
54018: ST_TO_ADDR
// y := GetY ( ape ) ;
54019: LD_ADDR_VAR 0 5
54023: PUSH
54024: LD_VAR 0 6
54028: PPUSH
54029: CALL_OW 251
54033: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
54034: LD_VAR 0 4
54038: PPUSH
54039: LD_VAR 0 5
54043: PPUSH
54044: CALL_OW 488
54048: NOT
54049: PUSH
54050: LD_VAR 0 11
54054: PPUSH
54055: LD_VAR 0 4
54059: PPUSH
54060: LD_VAR 0 5
54064: PPUSH
54065: LD_INT 20
54067: PPUSH
54068: CALL 71024 0 4
54072: PUSH
54073: LD_INT 4
54075: ARRAY
54076: OR
54077: IFFALSE 54081
// break ;
54079: GO 54114
// if not HasTask ( j ) then
54081: LD_VAR 0 3
54085: PPUSH
54086: CALL_OW 314
54090: NOT
54091: IFFALSE 54112
// ComTameXY ( j , x , y ) ;
54093: LD_VAR 0 3
54097: PPUSH
54098: LD_VAR 0 4
54102: PPUSH
54103: LD_VAR 0 5
54107: PPUSH
54108: CALL_OW 131
// end ; end ;
54112: GO 53777
54114: POP
54115: POP
// end ;
54116: GO 53333
54118: POP
54119: POP
// end ;
54120: LD_VAR 0 1
54124: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
54125: LD_INT 0
54127: PPUSH
54128: PPUSH
54129: PPUSH
54130: PPUSH
54131: PPUSH
54132: PPUSH
54133: PPUSH
54134: PPUSH
// if not mc_bases then
54135: LD_EXP 113
54139: NOT
54140: IFFALSE 54144
// exit ;
54142: GO 54770
// for i = 1 to mc_bases do
54144: LD_ADDR_VAR 0 2
54148: PUSH
54149: DOUBLE
54150: LD_INT 1
54152: DEC
54153: ST_TO_ADDR
54154: LD_EXP 113
54158: PUSH
54159: FOR_TO
54160: IFFALSE 54768
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
54162: LD_EXP 142
54166: PUSH
54167: LD_VAR 0 2
54171: ARRAY
54172: NOT
54173: PUSH
54174: LD_EXP 142
54178: PUSH
54179: LD_VAR 0 2
54183: ARRAY
54184: PPUSH
54185: LD_INT 25
54187: PUSH
54188: LD_INT 12
54190: PUSH
54191: EMPTY
54192: LIST
54193: LIST
54194: PPUSH
54195: CALL_OW 72
54199: NOT
54200: OR
54201: IFFALSE 54205
// continue ;
54203: GO 54159
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
54205: LD_ADDR_VAR 0 5
54209: PUSH
54210: LD_EXP 142
54214: PUSH
54215: LD_VAR 0 2
54219: ARRAY
54220: PUSH
54221: LD_INT 1
54223: ARRAY
54224: PPUSH
54225: CALL_OW 255
54229: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
54230: LD_VAR 0 5
54234: PPUSH
54235: LD_INT 2
54237: PPUSH
54238: CALL_OW 325
54242: IFFALSE 54495
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54244: LD_ADDR_VAR 0 4
54248: PUSH
54249: LD_EXP 142
54253: PUSH
54254: LD_VAR 0 2
54258: ARRAY
54259: PPUSH
54260: LD_INT 25
54262: PUSH
54263: LD_INT 16
54265: PUSH
54266: EMPTY
54267: LIST
54268: LIST
54269: PPUSH
54270: CALL_OW 72
54274: ST_TO_ADDR
// if tmp < 6 then
54275: LD_VAR 0 4
54279: PUSH
54280: LD_INT 6
54282: LESS
54283: IFFALSE 54495
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54285: LD_ADDR_VAR 0 6
54289: PUSH
54290: LD_EXP 113
54294: PUSH
54295: LD_VAR 0 2
54299: ARRAY
54300: PPUSH
54301: LD_INT 2
54303: PUSH
54304: LD_INT 30
54306: PUSH
54307: LD_INT 0
54309: PUSH
54310: EMPTY
54311: LIST
54312: LIST
54313: PUSH
54314: LD_INT 30
54316: PUSH
54317: LD_INT 1
54319: PUSH
54320: EMPTY
54321: LIST
54322: LIST
54323: PUSH
54324: EMPTY
54325: LIST
54326: LIST
54327: LIST
54328: PPUSH
54329: CALL_OW 72
54333: ST_TO_ADDR
// if depot then
54334: LD_VAR 0 6
54338: IFFALSE 54495
// begin selected := 0 ;
54340: LD_ADDR_VAR 0 7
54344: PUSH
54345: LD_INT 0
54347: ST_TO_ADDR
// for j in depot do
54348: LD_ADDR_VAR 0 3
54352: PUSH
54353: LD_VAR 0 6
54357: PUSH
54358: FOR_IN
54359: IFFALSE 54390
// begin if UnitsInside ( j ) < 6 then
54361: LD_VAR 0 3
54365: PPUSH
54366: CALL_OW 313
54370: PUSH
54371: LD_INT 6
54373: LESS
54374: IFFALSE 54388
// begin selected := j ;
54376: LD_ADDR_VAR 0 7
54380: PUSH
54381: LD_VAR 0 3
54385: ST_TO_ADDR
// break ;
54386: GO 54390
// end ; end ;
54388: GO 54358
54390: POP
54391: POP
// if selected then
54392: LD_VAR 0 7
54396: IFFALSE 54495
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54398: LD_ADDR_VAR 0 3
54402: PUSH
54403: LD_EXP 142
54407: PUSH
54408: LD_VAR 0 2
54412: ARRAY
54413: PPUSH
54414: LD_INT 25
54416: PUSH
54417: LD_INT 12
54419: PUSH
54420: EMPTY
54421: LIST
54422: LIST
54423: PPUSH
54424: CALL_OW 72
54428: PUSH
54429: FOR_IN
54430: IFFALSE 54493
// if not HasTask ( j ) then
54432: LD_VAR 0 3
54436: PPUSH
54437: CALL_OW 314
54441: NOT
54442: IFFALSE 54491
// begin if not IsInUnit ( j ) then
54444: LD_VAR 0 3
54448: PPUSH
54449: CALL_OW 310
54453: NOT
54454: IFFALSE 54470
// ComEnterUnit ( j , selected ) ;
54456: LD_VAR 0 3
54460: PPUSH
54461: LD_VAR 0 7
54465: PPUSH
54466: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
54470: LD_VAR 0 3
54474: PPUSH
54475: LD_INT 16
54477: PPUSH
54478: CALL_OW 183
// AddComExitBuilding ( j ) ;
54482: LD_VAR 0 3
54486: PPUSH
54487: CALL_OW 182
// end ;
54491: GO 54429
54493: POP
54494: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
54495: LD_VAR 0 5
54499: PPUSH
54500: LD_INT 11
54502: PPUSH
54503: CALL_OW 325
54507: IFFALSE 54766
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54509: LD_ADDR_VAR 0 4
54513: PUSH
54514: LD_EXP 142
54518: PUSH
54519: LD_VAR 0 2
54523: ARRAY
54524: PPUSH
54525: LD_INT 25
54527: PUSH
54528: LD_INT 16
54530: PUSH
54531: EMPTY
54532: LIST
54533: LIST
54534: PPUSH
54535: CALL_OW 72
54539: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
54540: LD_VAR 0 4
54544: PUSH
54545: LD_INT 6
54547: GREATEREQUAL
54548: PUSH
54549: LD_VAR 0 5
54553: PPUSH
54554: LD_INT 2
54556: PPUSH
54557: CALL_OW 325
54561: NOT
54562: OR
54563: IFFALSE 54766
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
54565: LD_ADDR_VAR 0 8
54569: PUSH
54570: LD_EXP 113
54574: PUSH
54575: LD_VAR 0 2
54579: ARRAY
54580: PPUSH
54581: LD_INT 2
54583: PUSH
54584: LD_INT 30
54586: PUSH
54587: LD_INT 4
54589: PUSH
54590: EMPTY
54591: LIST
54592: LIST
54593: PUSH
54594: LD_INT 30
54596: PUSH
54597: LD_INT 5
54599: PUSH
54600: EMPTY
54601: LIST
54602: LIST
54603: PUSH
54604: EMPTY
54605: LIST
54606: LIST
54607: LIST
54608: PPUSH
54609: CALL_OW 72
54613: ST_TO_ADDR
// if barracks then
54614: LD_VAR 0 8
54618: IFFALSE 54766
// begin selected := 0 ;
54620: LD_ADDR_VAR 0 7
54624: PUSH
54625: LD_INT 0
54627: ST_TO_ADDR
// for j in barracks do
54628: LD_ADDR_VAR 0 3
54632: PUSH
54633: LD_VAR 0 8
54637: PUSH
54638: FOR_IN
54639: IFFALSE 54670
// begin if UnitsInside ( j ) < 6 then
54641: LD_VAR 0 3
54645: PPUSH
54646: CALL_OW 313
54650: PUSH
54651: LD_INT 6
54653: LESS
54654: IFFALSE 54668
// begin selected := j ;
54656: LD_ADDR_VAR 0 7
54660: PUSH
54661: LD_VAR 0 3
54665: ST_TO_ADDR
// break ;
54666: GO 54670
// end ; end ;
54668: GO 54638
54670: POP
54671: POP
// if selected then
54672: LD_VAR 0 7
54676: IFFALSE 54766
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54678: LD_ADDR_VAR 0 3
54682: PUSH
54683: LD_EXP 142
54687: PUSH
54688: LD_VAR 0 2
54692: ARRAY
54693: PPUSH
54694: LD_INT 25
54696: PUSH
54697: LD_INT 12
54699: PUSH
54700: EMPTY
54701: LIST
54702: LIST
54703: PPUSH
54704: CALL_OW 72
54708: PUSH
54709: FOR_IN
54710: IFFALSE 54764
// if not IsInUnit ( j ) and not HasTask ( j ) then
54712: LD_VAR 0 3
54716: PPUSH
54717: CALL_OW 310
54721: NOT
54722: PUSH
54723: LD_VAR 0 3
54727: PPUSH
54728: CALL_OW 314
54732: NOT
54733: AND
54734: IFFALSE 54762
// begin ComEnterUnit ( j , selected ) ;
54736: LD_VAR 0 3
54740: PPUSH
54741: LD_VAR 0 7
54745: PPUSH
54746: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
54750: LD_VAR 0 3
54754: PPUSH
54755: LD_INT 15
54757: PPUSH
54758: CALL_OW 183
// end ;
54762: GO 54709
54764: POP
54765: POP
// end ; end ; end ; end ; end ;
54766: GO 54159
54768: POP
54769: POP
// end ;
54770: LD_VAR 0 1
54774: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
54775: LD_INT 0
54777: PPUSH
54778: PPUSH
54779: PPUSH
54780: PPUSH
// if not mc_bases then
54781: LD_EXP 113
54785: NOT
54786: IFFALSE 54790
// exit ;
54788: GO 54968
// for i = 1 to mc_bases do
54790: LD_ADDR_VAR 0 2
54794: PUSH
54795: DOUBLE
54796: LD_INT 1
54798: DEC
54799: ST_TO_ADDR
54800: LD_EXP 113
54804: PUSH
54805: FOR_TO
54806: IFFALSE 54966
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
54808: LD_ADDR_VAR 0 4
54812: PUSH
54813: LD_EXP 113
54817: PUSH
54818: LD_VAR 0 2
54822: ARRAY
54823: PPUSH
54824: LD_INT 25
54826: PUSH
54827: LD_INT 9
54829: PUSH
54830: EMPTY
54831: LIST
54832: LIST
54833: PPUSH
54834: CALL_OW 72
54838: ST_TO_ADDR
// if not tmp then
54839: LD_VAR 0 4
54843: NOT
54844: IFFALSE 54848
// continue ;
54846: GO 54805
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
54848: LD_EXP 139
54852: PUSH
54853: LD_VAR 0 2
54857: ARRAY
54858: PPUSH
54859: LD_INT 29
54861: PPUSH
54862: CALL_OW 325
54866: NOT
54867: PUSH
54868: LD_EXP 139
54872: PUSH
54873: LD_VAR 0 2
54877: ARRAY
54878: PPUSH
54879: LD_INT 28
54881: PPUSH
54882: CALL_OW 325
54886: NOT
54887: AND
54888: IFFALSE 54892
// continue ;
54890: GO 54805
// for j in tmp do
54892: LD_ADDR_VAR 0 3
54896: PUSH
54897: LD_VAR 0 4
54901: PUSH
54902: FOR_IN
54903: IFFALSE 54962
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
54905: LD_VAR 0 3
54909: PUSH
54910: LD_EXP 116
54914: PUSH
54915: LD_VAR 0 2
54919: ARRAY
54920: PUSH
54921: LD_INT 1
54923: ARRAY
54924: IN
54925: NOT
54926: PUSH
54927: LD_VAR 0 3
54931: PUSH
54932: LD_EXP 116
54936: PUSH
54937: LD_VAR 0 2
54941: ARRAY
54942: PUSH
54943: LD_INT 2
54945: ARRAY
54946: IN
54947: NOT
54948: AND
54949: IFFALSE 54960
// ComSpaceTimeShoot ( j ) ;
54951: LD_VAR 0 3
54955: PPUSH
54956: CALL 66125 0 1
54960: GO 54902
54962: POP
54963: POP
// end ;
54964: GO 54805
54966: POP
54967: POP
// end ;
54968: LD_VAR 0 1
54972: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
54973: LD_INT 0
54975: PPUSH
54976: PPUSH
54977: PPUSH
54978: PPUSH
54979: PPUSH
54980: PPUSH
54981: PPUSH
54982: PPUSH
54983: PPUSH
// if not mc_bases then
54984: LD_EXP 113
54988: NOT
54989: IFFALSE 54993
// exit ;
54991: GO 55615
// for i = 1 to mc_bases do
54993: LD_ADDR_VAR 0 2
54997: PUSH
54998: DOUBLE
54999: LD_INT 1
55001: DEC
55002: ST_TO_ADDR
55003: LD_EXP 113
55007: PUSH
55008: FOR_TO
55009: IFFALSE 55613
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
55011: LD_EXP 148
55015: PUSH
55016: LD_VAR 0 2
55020: ARRAY
55021: NOT
55022: PUSH
55023: LD_INT 38
55025: PPUSH
55026: LD_EXP 139
55030: PUSH
55031: LD_VAR 0 2
55035: ARRAY
55036: PPUSH
55037: CALL_OW 321
55041: PUSH
55042: LD_INT 2
55044: NONEQUAL
55045: OR
55046: IFFALSE 55050
// continue ;
55048: GO 55008
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
55050: LD_ADDR_VAR 0 8
55054: PUSH
55055: LD_EXP 113
55059: PUSH
55060: LD_VAR 0 2
55064: ARRAY
55065: PPUSH
55066: LD_INT 30
55068: PUSH
55069: LD_INT 34
55071: PUSH
55072: EMPTY
55073: LIST
55074: LIST
55075: PPUSH
55076: CALL_OW 72
55080: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
55081: LD_ADDR_VAR 0 9
55085: PUSH
55086: LD_EXP 113
55090: PUSH
55091: LD_VAR 0 2
55095: ARRAY
55096: PPUSH
55097: LD_INT 25
55099: PUSH
55100: LD_INT 4
55102: PUSH
55103: EMPTY
55104: LIST
55105: LIST
55106: PPUSH
55107: CALL_OW 72
55111: PPUSH
55112: LD_INT 0
55114: PPUSH
55115: CALL 98689 0 2
55119: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
55120: LD_VAR 0 9
55124: NOT
55125: PUSH
55126: LD_VAR 0 8
55130: NOT
55131: OR
55132: PUSH
55133: LD_EXP 113
55137: PUSH
55138: LD_VAR 0 2
55142: ARRAY
55143: PPUSH
55144: LD_INT 124
55146: PPUSH
55147: CALL 98689 0 2
55151: OR
55152: IFFALSE 55156
// continue ;
55154: GO 55008
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
55156: LD_EXP 149
55160: PUSH
55161: LD_VAR 0 2
55165: ARRAY
55166: PUSH
55167: LD_EXP 148
55171: PUSH
55172: LD_VAR 0 2
55176: ARRAY
55177: LESS
55178: PUSH
55179: LD_EXP 149
55183: PUSH
55184: LD_VAR 0 2
55188: ARRAY
55189: PUSH
55190: LD_VAR 0 8
55194: LESS
55195: AND
55196: IFFALSE 55611
// begin tmp := sci [ 1 ] ;
55198: LD_ADDR_VAR 0 7
55202: PUSH
55203: LD_VAR 0 9
55207: PUSH
55208: LD_INT 1
55210: ARRAY
55211: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
55212: LD_VAR 0 7
55216: PPUSH
55217: LD_INT 124
55219: PPUSH
55220: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
55224: LD_ADDR_VAR 0 3
55228: PUSH
55229: DOUBLE
55230: LD_EXP 148
55234: PUSH
55235: LD_VAR 0 2
55239: ARRAY
55240: INC
55241: ST_TO_ADDR
55242: LD_EXP 148
55246: PUSH
55247: LD_VAR 0 2
55251: ARRAY
55252: PUSH
55253: FOR_DOWNTO
55254: IFFALSE 55597
// begin if IsInUnit ( tmp ) then
55256: LD_VAR 0 7
55260: PPUSH
55261: CALL_OW 310
55265: IFFALSE 55276
// ComExitBuilding ( tmp ) ;
55267: LD_VAR 0 7
55271: PPUSH
55272: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55276: LD_INT 35
55278: PPUSH
55279: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55283: LD_VAR 0 7
55287: PPUSH
55288: CALL_OW 310
55292: NOT
55293: PUSH
55294: LD_VAR 0 7
55298: PPUSH
55299: CALL_OW 314
55303: NOT
55304: AND
55305: IFFALSE 55276
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
55307: LD_ADDR_VAR 0 6
55311: PUSH
55312: LD_VAR 0 7
55316: PPUSH
55317: CALL_OW 250
55321: PUSH
55322: LD_VAR 0 7
55326: PPUSH
55327: CALL_OW 251
55331: PUSH
55332: EMPTY
55333: LIST
55334: LIST
55335: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55336: LD_INT 35
55338: PPUSH
55339: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
55343: LD_ADDR_VAR 0 4
55347: PUSH
55348: LD_EXP 148
55352: PUSH
55353: LD_VAR 0 2
55357: ARRAY
55358: PUSH
55359: LD_VAR 0 3
55363: ARRAY
55364: PUSH
55365: LD_INT 1
55367: ARRAY
55368: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
55369: LD_ADDR_VAR 0 5
55373: PUSH
55374: LD_EXP 148
55378: PUSH
55379: LD_VAR 0 2
55383: ARRAY
55384: PUSH
55385: LD_VAR 0 3
55389: ARRAY
55390: PUSH
55391: LD_INT 2
55393: ARRAY
55394: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
55395: LD_VAR 0 7
55399: PPUSH
55400: LD_INT 10
55402: PPUSH
55403: CALL 72721 0 2
55407: PUSH
55408: LD_INT 4
55410: ARRAY
55411: IFFALSE 55449
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
55413: LD_VAR 0 7
55417: PPUSH
55418: LD_VAR 0 6
55422: PUSH
55423: LD_INT 1
55425: ARRAY
55426: PPUSH
55427: LD_VAR 0 6
55431: PUSH
55432: LD_INT 2
55434: ARRAY
55435: PPUSH
55436: CALL_OW 111
// wait ( 0 0$10 ) ;
55440: LD_INT 350
55442: PPUSH
55443: CALL_OW 67
// end else
55447: GO 55475
// begin ComMoveXY ( tmp , x , y ) ;
55449: LD_VAR 0 7
55453: PPUSH
55454: LD_VAR 0 4
55458: PPUSH
55459: LD_VAR 0 5
55463: PPUSH
55464: CALL_OW 111
// wait ( 0 0$3 ) ;
55468: LD_INT 105
55470: PPUSH
55471: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
55475: LD_VAR 0 7
55479: PPUSH
55480: LD_VAR 0 4
55484: PPUSH
55485: LD_VAR 0 5
55489: PPUSH
55490: CALL_OW 307
55494: IFFALSE 55336
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
55496: LD_VAR 0 7
55500: PPUSH
55501: LD_VAR 0 4
55505: PPUSH
55506: LD_VAR 0 5
55510: PPUSH
55511: LD_VAR 0 8
55515: PUSH
55516: LD_VAR 0 3
55520: ARRAY
55521: PPUSH
55522: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
55526: LD_INT 35
55528: PPUSH
55529: CALL_OW 67
// until not HasTask ( tmp ) ;
55533: LD_VAR 0 7
55537: PPUSH
55538: CALL_OW 314
55542: NOT
55543: IFFALSE 55526
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
55545: LD_ADDR_EXP 149
55549: PUSH
55550: LD_EXP 149
55554: PPUSH
55555: LD_VAR 0 2
55559: PUSH
55560: LD_EXP 149
55564: PUSH
55565: LD_VAR 0 2
55569: ARRAY
55570: PUSH
55571: LD_INT 1
55573: PLUS
55574: PUSH
55575: EMPTY
55576: LIST
55577: LIST
55578: PPUSH
55579: LD_VAR 0 8
55583: PUSH
55584: LD_VAR 0 3
55588: ARRAY
55589: PPUSH
55590: CALL 70128 0 3
55594: ST_TO_ADDR
// end ;
55595: GO 55253
55597: POP
55598: POP
// MC_Reset ( i , 124 ) ;
55599: LD_VAR 0 2
55603: PPUSH
55604: LD_INT 124
55606: PPUSH
55607: CALL 39192 0 2
// end ; end ;
55611: GO 55008
55613: POP
55614: POP
// end ;
55615: LD_VAR 0 1
55619: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
55620: LD_INT 0
55622: PPUSH
55623: PPUSH
55624: PPUSH
// if not mc_bases then
55625: LD_EXP 113
55629: NOT
55630: IFFALSE 55634
// exit ;
55632: GO 56240
// for i = 1 to mc_bases do
55634: LD_ADDR_VAR 0 2
55638: PUSH
55639: DOUBLE
55640: LD_INT 1
55642: DEC
55643: ST_TO_ADDR
55644: LD_EXP 113
55648: PUSH
55649: FOR_TO
55650: IFFALSE 56238
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
55652: LD_ADDR_VAR 0 3
55656: PUSH
55657: LD_EXP 113
55661: PUSH
55662: LD_VAR 0 2
55666: ARRAY
55667: PPUSH
55668: LD_INT 25
55670: PUSH
55671: LD_INT 4
55673: PUSH
55674: EMPTY
55675: LIST
55676: LIST
55677: PPUSH
55678: CALL_OW 72
55682: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55683: LD_VAR 0 3
55687: NOT
55688: PUSH
55689: LD_EXP 150
55693: PUSH
55694: LD_VAR 0 2
55698: ARRAY
55699: NOT
55700: OR
55701: PUSH
55702: LD_EXP 113
55706: PUSH
55707: LD_VAR 0 2
55711: ARRAY
55712: PPUSH
55713: LD_INT 2
55715: PUSH
55716: LD_INT 30
55718: PUSH
55719: LD_INT 0
55721: PUSH
55722: EMPTY
55723: LIST
55724: LIST
55725: PUSH
55726: LD_INT 30
55728: PUSH
55729: LD_INT 1
55731: PUSH
55732: EMPTY
55733: LIST
55734: LIST
55735: PUSH
55736: EMPTY
55737: LIST
55738: LIST
55739: LIST
55740: PPUSH
55741: CALL_OW 72
55745: NOT
55746: OR
55747: IFFALSE 55797
// begin if mc_deposits_finder [ i ] then
55749: LD_EXP 151
55753: PUSH
55754: LD_VAR 0 2
55758: ARRAY
55759: IFFALSE 55795
// begin MC_Reset ( i , 125 ) ;
55761: LD_VAR 0 2
55765: PPUSH
55766: LD_INT 125
55768: PPUSH
55769: CALL 39192 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55773: LD_ADDR_EXP 151
55777: PUSH
55778: LD_EXP 151
55782: PPUSH
55783: LD_VAR 0 2
55787: PPUSH
55788: EMPTY
55789: PPUSH
55790: CALL_OW 1
55794: ST_TO_ADDR
// end ; continue ;
55795: GO 55649
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
55797: LD_EXP 150
55801: PUSH
55802: LD_VAR 0 2
55806: ARRAY
55807: PUSH
55808: LD_INT 1
55810: ARRAY
55811: PUSH
55812: LD_INT 3
55814: ARRAY
55815: PUSH
55816: LD_INT 1
55818: EQUAL
55819: PUSH
55820: LD_INT 20
55822: PPUSH
55823: LD_EXP 139
55827: PUSH
55828: LD_VAR 0 2
55832: ARRAY
55833: PPUSH
55834: CALL_OW 321
55838: PUSH
55839: LD_INT 2
55841: NONEQUAL
55842: AND
55843: IFFALSE 55893
// begin if mc_deposits_finder [ i ] then
55845: LD_EXP 151
55849: PUSH
55850: LD_VAR 0 2
55854: ARRAY
55855: IFFALSE 55891
// begin MC_Reset ( i , 125 ) ;
55857: LD_VAR 0 2
55861: PPUSH
55862: LD_INT 125
55864: PPUSH
55865: CALL 39192 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55869: LD_ADDR_EXP 151
55873: PUSH
55874: LD_EXP 151
55878: PPUSH
55879: LD_VAR 0 2
55883: PPUSH
55884: EMPTY
55885: PPUSH
55886: CALL_OW 1
55890: ST_TO_ADDR
// end ; continue ;
55891: GO 55649
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
55893: LD_EXP 150
55897: PUSH
55898: LD_VAR 0 2
55902: ARRAY
55903: PUSH
55904: LD_INT 1
55906: ARRAY
55907: PUSH
55908: LD_INT 1
55910: ARRAY
55911: PPUSH
55912: LD_EXP 150
55916: PUSH
55917: LD_VAR 0 2
55921: ARRAY
55922: PUSH
55923: LD_INT 1
55925: ARRAY
55926: PUSH
55927: LD_INT 2
55929: ARRAY
55930: PPUSH
55931: LD_EXP 139
55935: PUSH
55936: LD_VAR 0 2
55940: ARRAY
55941: PPUSH
55942: CALL_OW 440
55946: IFFALSE 55989
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
55948: LD_ADDR_EXP 150
55952: PUSH
55953: LD_EXP 150
55957: PPUSH
55958: LD_VAR 0 2
55962: PPUSH
55963: LD_EXP 150
55967: PUSH
55968: LD_VAR 0 2
55972: ARRAY
55973: PPUSH
55974: LD_INT 1
55976: PPUSH
55977: CALL_OW 3
55981: PPUSH
55982: CALL_OW 1
55986: ST_TO_ADDR
55987: GO 56236
// begin if not mc_deposits_finder [ i ] then
55989: LD_EXP 151
55993: PUSH
55994: LD_VAR 0 2
55998: ARRAY
55999: NOT
56000: IFFALSE 56052
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
56002: LD_ADDR_EXP 151
56006: PUSH
56007: LD_EXP 151
56011: PPUSH
56012: LD_VAR 0 2
56016: PPUSH
56017: LD_VAR 0 3
56021: PUSH
56022: LD_INT 1
56024: ARRAY
56025: PUSH
56026: EMPTY
56027: LIST
56028: PPUSH
56029: CALL_OW 1
56033: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
56034: LD_VAR 0 3
56038: PUSH
56039: LD_INT 1
56041: ARRAY
56042: PPUSH
56043: LD_INT 125
56045: PPUSH
56046: CALL_OW 109
// end else
56050: GO 56236
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
56052: LD_EXP 151
56056: PUSH
56057: LD_VAR 0 2
56061: ARRAY
56062: PUSH
56063: LD_INT 1
56065: ARRAY
56066: PPUSH
56067: CALL_OW 310
56071: IFFALSE 56094
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
56073: LD_EXP 151
56077: PUSH
56078: LD_VAR 0 2
56082: ARRAY
56083: PUSH
56084: LD_INT 1
56086: ARRAY
56087: PPUSH
56088: CALL_OW 122
56092: GO 56236
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
56094: LD_EXP 151
56098: PUSH
56099: LD_VAR 0 2
56103: ARRAY
56104: PUSH
56105: LD_INT 1
56107: ARRAY
56108: PPUSH
56109: CALL_OW 314
56113: NOT
56114: PUSH
56115: LD_EXP 151
56119: PUSH
56120: LD_VAR 0 2
56124: ARRAY
56125: PUSH
56126: LD_INT 1
56128: ARRAY
56129: PPUSH
56130: LD_EXP 150
56134: PUSH
56135: LD_VAR 0 2
56139: ARRAY
56140: PUSH
56141: LD_INT 1
56143: ARRAY
56144: PUSH
56145: LD_INT 1
56147: ARRAY
56148: PPUSH
56149: LD_EXP 150
56153: PUSH
56154: LD_VAR 0 2
56158: ARRAY
56159: PUSH
56160: LD_INT 1
56162: ARRAY
56163: PUSH
56164: LD_INT 2
56166: ARRAY
56167: PPUSH
56168: CALL_OW 297
56172: PUSH
56173: LD_INT 6
56175: GREATER
56176: AND
56177: IFFALSE 56236
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
56179: LD_EXP 151
56183: PUSH
56184: LD_VAR 0 2
56188: ARRAY
56189: PUSH
56190: LD_INT 1
56192: ARRAY
56193: PPUSH
56194: LD_EXP 150
56198: PUSH
56199: LD_VAR 0 2
56203: ARRAY
56204: PUSH
56205: LD_INT 1
56207: ARRAY
56208: PUSH
56209: LD_INT 1
56211: ARRAY
56212: PPUSH
56213: LD_EXP 150
56217: PUSH
56218: LD_VAR 0 2
56222: ARRAY
56223: PUSH
56224: LD_INT 1
56226: ARRAY
56227: PUSH
56228: LD_INT 2
56230: ARRAY
56231: PPUSH
56232: CALL_OW 111
// end ; end ; end ;
56236: GO 55649
56238: POP
56239: POP
// end ;
56240: LD_VAR 0 1
56244: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
56245: LD_INT 0
56247: PPUSH
56248: PPUSH
56249: PPUSH
56250: PPUSH
56251: PPUSH
56252: PPUSH
56253: PPUSH
56254: PPUSH
56255: PPUSH
56256: PPUSH
56257: PPUSH
// if not mc_bases then
56258: LD_EXP 113
56262: NOT
56263: IFFALSE 56267
// exit ;
56265: GO 57207
// for i = 1 to mc_bases do
56267: LD_ADDR_VAR 0 2
56271: PUSH
56272: DOUBLE
56273: LD_INT 1
56275: DEC
56276: ST_TO_ADDR
56277: LD_EXP 113
56281: PUSH
56282: FOR_TO
56283: IFFALSE 57205
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56285: LD_EXP 113
56289: PUSH
56290: LD_VAR 0 2
56294: ARRAY
56295: NOT
56296: PUSH
56297: LD_EXP 136
56301: PUSH
56302: LD_VAR 0 2
56306: ARRAY
56307: OR
56308: IFFALSE 56312
// continue ;
56310: GO 56282
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
56312: LD_ADDR_VAR 0 7
56316: PUSH
56317: LD_EXP 113
56321: PUSH
56322: LD_VAR 0 2
56326: ARRAY
56327: PUSH
56328: LD_INT 1
56330: ARRAY
56331: PPUSH
56332: CALL_OW 248
56336: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
56337: LD_VAR 0 7
56341: PUSH
56342: LD_INT 3
56344: EQUAL
56345: PUSH
56346: LD_EXP 132
56350: PUSH
56351: LD_VAR 0 2
56355: ARRAY
56356: PUSH
56357: LD_EXP 135
56361: PUSH
56362: LD_VAR 0 2
56366: ARRAY
56367: UNION
56368: PPUSH
56369: LD_INT 33
56371: PUSH
56372: LD_INT 2
56374: PUSH
56375: EMPTY
56376: LIST
56377: LIST
56378: PPUSH
56379: CALL_OW 72
56383: NOT
56384: OR
56385: IFFALSE 56389
// continue ;
56387: GO 56282
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
56389: LD_ADDR_VAR 0 9
56393: PUSH
56394: LD_EXP 113
56398: PUSH
56399: LD_VAR 0 2
56403: ARRAY
56404: PPUSH
56405: LD_INT 30
56407: PUSH
56408: LD_INT 36
56410: PUSH
56411: EMPTY
56412: LIST
56413: LIST
56414: PPUSH
56415: CALL_OW 72
56419: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
56420: LD_ADDR_VAR 0 10
56424: PUSH
56425: LD_EXP 132
56429: PUSH
56430: LD_VAR 0 2
56434: ARRAY
56435: PPUSH
56436: LD_INT 34
56438: PUSH
56439: LD_INT 31
56441: PUSH
56442: EMPTY
56443: LIST
56444: LIST
56445: PPUSH
56446: CALL_OW 72
56450: ST_TO_ADDR
// if not cts and not mcts then
56451: LD_VAR 0 9
56455: NOT
56456: PUSH
56457: LD_VAR 0 10
56461: NOT
56462: AND
56463: IFFALSE 56467
// continue ;
56465: GO 56282
// x := cts ;
56467: LD_ADDR_VAR 0 11
56471: PUSH
56472: LD_VAR 0 9
56476: ST_TO_ADDR
// if not x then
56477: LD_VAR 0 11
56481: NOT
56482: IFFALSE 56494
// x := mcts ;
56484: LD_ADDR_VAR 0 11
56488: PUSH
56489: LD_VAR 0 10
56493: ST_TO_ADDR
// if not x then
56494: LD_VAR 0 11
56498: NOT
56499: IFFALSE 56503
// continue ;
56501: GO 56282
// if mc_remote_driver [ i ] then
56503: LD_EXP 153
56507: PUSH
56508: LD_VAR 0 2
56512: ARRAY
56513: IFFALSE 56900
// for j in mc_remote_driver [ i ] do
56515: LD_ADDR_VAR 0 3
56519: PUSH
56520: LD_EXP 153
56524: PUSH
56525: LD_VAR 0 2
56529: ARRAY
56530: PUSH
56531: FOR_IN
56532: IFFALSE 56898
// begin if GetClass ( j ) <> 3 then
56534: LD_VAR 0 3
56538: PPUSH
56539: CALL_OW 257
56543: PUSH
56544: LD_INT 3
56546: NONEQUAL
56547: IFFALSE 56600
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
56549: LD_ADDR_EXP 153
56553: PUSH
56554: LD_EXP 153
56558: PPUSH
56559: LD_VAR 0 2
56563: PPUSH
56564: LD_EXP 153
56568: PUSH
56569: LD_VAR 0 2
56573: ARRAY
56574: PUSH
56575: LD_VAR 0 3
56579: DIFF
56580: PPUSH
56581: CALL_OW 1
56585: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56586: LD_VAR 0 3
56590: PPUSH
56591: LD_INT 0
56593: PPUSH
56594: CALL_OW 109
// continue ;
56598: GO 56531
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
56600: LD_EXP 132
56604: PUSH
56605: LD_VAR 0 2
56609: ARRAY
56610: PPUSH
56611: LD_INT 34
56613: PUSH
56614: LD_INT 31
56616: PUSH
56617: EMPTY
56618: LIST
56619: LIST
56620: PUSH
56621: LD_INT 58
56623: PUSH
56624: EMPTY
56625: LIST
56626: PUSH
56627: EMPTY
56628: LIST
56629: LIST
56630: PPUSH
56631: CALL_OW 72
56635: PUSH
56636: LD_VAR 0 3
56640: PPUSH
56641: CALL 98777 0 1
56645: NOT
56646: AND
56647: IFFALSE 56718
// begin if IsInUnit ( j ) then
56649: LD_VAR 0 3
56653: PPUSH
56654: CALL_OW 310
56658: IFFALSE 56669
// ComExitBuilding ( j ) ;
56660: LD_VAR 0 3
56664: PPUSH
56665: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
56669: LD_VAR 0 3
56673: PPUSH
56674: LD_EXP 132
56678: PUSH
56679: LD_VAR 0 2
56683: ARRAY
56684: PPUSH
56685: LD_INT 34
56687: PUSH
56688: LD_INT 31
56690: PUSH
56691: EMPTY
56692: LIST
56693: LIST
56694: PUSH
56695: LD_INT 58
56697: PUSH
56698: EMPTY
56699: LIST
56700: PUSH
56701: EMPTY
56702: LIST
56703: LIST
56704: PPUSH
56705: CALL_OW 72
56709: PUSH
56710: LD_INT 1
56712: ARRAY
56713: PPUSH
56714: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
56718: LD_VAR 0 3
56722: PPUSH
56723: CALL_OW 310
56727: NOT
56728: PUSH
56729: LD_VAR 0 3
56733: PPUSH
56734: CALL_OW 310
56738: PPUSH
56739: CALL_OW 266
56743: PUSH
56744: LD_INT 36
56746: NONEQUAL
56747: PUSH
56748: LD_VAR 0 3
56752: PPUSH
56753: CALL 98777 0 1
56757: NOT
56758: AND
56759: OR
56760: IFFALSE 56896
// begin if IsInUnit ( j ) then
56762: LD_VAR 0 3
56766: PPUSH
56767: CALL_OW 310
56771: IFFALSE 56782
// ComExitBuilding ( j ) ;
56773: LD_VAR 0 3
56777: PPUSH
56778: CALL_OW 122
// ct := 0 ;
56782: LD_ADDR_VAR 0 8
56786: PUSH
56787: LD_INT 0
56789: ST_TO_ADDR
// for k in x do
56790: LD_ADDR_VAR 0 4
56794: PUSH
56795: LD_VAR 0 11
56799: PUSH
56800: FOR_IN
56801: IFFALSE 56874
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
56803: LD_VAR 0 4
56807: PPUSH
56808: CALL_OW 264
56812: PUSH
56813: LD_INT 31
56815: EQUAL
56816: PUSH
56817: LD_VAR 0 4
56821: PPUSH
56822: CALL_OW 311
56826: NOT
56827: AND
56828: PUSH
56829: LD_VAR 0 4
56833: PPUSH
56834: CALL_OW 266
56838: PUSH
56839: LD_INT 36
56841: EQUAL
56842: PUSH
56843: LD_VAR 0 4
56847: PPUSH
56848: CALL_OW 313
56852: PUSH
56853: LD_INT 3
56855: LESS
56856: AND
56857: OR
56858: IFFALSE 56872
// begin ct := k ;
56860: LD_ADDR_VAR 0 8
56864: PUSH
56865: LD_VAR 0 4
56869: ST_TO_ADDR
// break ;
56870: GO 56874
// end ;
56872: GO 56800
56874: POP
56875: POP
// if ct then
56876: LD_VAR 0 8
56880: IFFALSE 56896
// ComEnterUnit ( j , ct ) ;
56882: LD_VAR 0 3
56886: PPUSH
56887: LD_VAR 0 8
56891: PPUSH
56892: CALL_OW 120
// end ; end ;
56896: GO 56531
56898: POP
56899: POP
// places := 0 ;
56900: LD_ADDR_VAR 0 5
56904: PUSH
56905: LD_INT 0
56907: ST_TO_ADDR
// for j = 1 to x do
56908: LD_ADDR_VAR 0 3
56912: PUSH
56913: DOUBLE
56914: LD_INT 1
56916: DEC
56917: ST_TO_ADDR
56918: LD_VAR 0 11
56922: PUSH
56923: FOR_TO
56924: IFFALSE 57000
// if GetWeapon ( x [ j ] ) = ar_control_tower then
56926: LD_VAR 0 11
56930: PUSH
56931: LD_VAR 0 3
56935: ARRAY
56936: PPUSH
56937: CALL_OW 264
56941: PUSH
56942: LD_INT 31
56944: EQUAL
56945: IFFALSE 56963
// places := places + 1 else
56947: LD_ADDR_VAR 0 5
56951: PUSH
56952: LD_VAR 0 5
56956: PUSH
56957: LD_INT 1
56959: PLUS
56960: ST_TO_ADDR
56961: GO 56998
// if GetBType ( x [ j ] ) = b_control_tower then
56963: LD_VAR 0 11
56967: PUSH
56968: LD_VAR 0 3
56972: ARRAY
56973: PPUSH
56974: CALL_OW 266
56978: PUSH
56979: LD_INT 36
56981: EQUAL
56982: IFFALSE 56998
// places := places + 3 ;
56984: LD_ADDR_VAR 0 5
56988: PUSH
56989: LD_VAR 0 5
56993: PUSH
56994: LD_INT 3
56996: PLUS
56997: ST_TO_ADDR
56998: GO 56923
57000: POP
57001: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
57002: LD_VAR 0 5
57006: PUSH
57007: LD_INT 0
57009: EQUAL
57010: PUSH
57011: LD_VAR 0 5
57015: PUSH
57016: LD_EXP 153
57020: PUSH
57021: LD_VAR 0 2
57025: ARRAY
57026: LESSEQUAL
57027: OR
57028: IFFALSE 57032
// continue ;
57030: GO 56282
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
57032: LD_ADDR_VAR 0 6
57036: PUSH
57037: LD_EXP 113
57041: PUSH
57042: LD_VAR 0 2
57046: ARRAY
57047: PPUSH
57048: LD_INT 25
57050: PUSH
57051: LD_INT 3
57053: PUSH
57054: EMPTY
57055: LIST
57056: LIST
57057: PPUSH
57058: CALL_OW 72
57062: PUSH
57063: LD_EXP 153
57067: PUSH
57068: LD_VAR 0 2
57072: ARRAY
57073: DIFF
57074: PPUSH
57075: LD_INT 3
57077: PPUSH
57078: CALL 99677 0 2
57082: ST_TO_ADDR
// for j in tmp do
57083: LD_ADDR_VAR 0 3
57087: PUSH
57088: LD_VAR 0 6
57092: PUSH
57093: FOR_IN
57094: IFFALSE 57129
// if GetTag ( j ) > 0 then
57096: LD_VAR 0 3
57100: PPUSH
57101: CALL_OW 110
57105: PUSH
57106: LD_INT 0
57108: GREATER
57109: IFFALSE 57127
// tmp := tmp diff j ;
57111: LD_ADDR_VAR 0 6
57115: PUSH
57116: LD_VAR 0 6
57120: PUSH
57121: LD_VAR 0 3
57125: DIFF
57126: ST_TO_ADDR
57127: GO 57093
57129: POP
57130: POP
// if not tmp then
57131: LD_VAR 0 6
57135: NOT
57136: IFFALSE 57140
// continue ;
57138: GO 56282
// if places then
57140: LD_VAR 0 5
57144: IFFALSE 57203
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
57146: LD_ADDR_EXP 153
57150: PUSH
57151: LD_EXP 153
57155: PPUSH
57156: LD_VAR 0 2
57160: PPUSH
57161: LD_EXP 153
57165: PUSH
57166: LD_VAR 0 2
57170: ARRAY
57171: PUSH
57172: LD_VAR 0 6
57176: PUSH
57177: LD_INT 1
57179: ARRAY
57180: UNION
57181: PPUSH
57182: CALL_OW 1
57186: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
57187: LD_VAR 0 6
57191: PUSH
57192: LD_INT 1
57194: ARRAY
57195: PPUSH
57196: LD_INT 126
57198: PPUSH
57199: CALL_OW 109
// end ; end ;
57203: GO 56282
57205: POP
57206: POP
// end ;
57207: LD_VAR 0 1
57211: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
57212: LD_INT 0
57214: PPUSH
57215: PPUSH
57216: PPUSH
57217: PPUSH
57218: PPUSH
57219: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
57220: LD_VAR 0 1
57224: NOT
57225: PUSH
57226: LD_VAR 0 2
57230: NOT
57231: OR
57232: PUSH
57233: LD_VAR 0 3
57237: NOT
57238: OR
57239: PUSH
57240: LD_VAR 0 4
57244: PUSH
57245: LD_INT 1
57247: PUSH
57248: LD_INT 2
57250: PUSH
57251: LD_INT 3
57253: PUSH
57254: LD_INT 4
57256: PUSH
57257: LD_INT 5
57259: PUSH
57260: LD_INT 8
57262: PUSH
57263: LD_INT 9
57265: PUSH
57266: LD_INT 15
57268: PUSH
57269: LD_INT 16
57271: PUSH
57272: EMPTY
57273: LIST
57274: LIST
57275: LIST
57276: LIST
57277: LIST
57278: LIST
57279: LIST
57280: LIST
57281: LIST
57282: IN
57283: NOT
57284: OR
57285: IFFALSE 57289
// exit ;
57287: GO 58189
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57289: LD_ADDR_VAR 0 2
57293: PUSH
57294: LD_VAR 0 2
57298: PPUSH
57299: LD_INT 21
57301: PUSH
57302: LD_INT 3
57304: PUSH
57305: EMPTY
57306: LIST
57307: LIST
57308: PUSH
57309: LD_INT 24
57311: PUSH
57312: LD_INT 250
57314: PUSH
57315: EMPTY
57316: LIST
57317: LIST
57318: PUSH
57319: EMPTY
57320: LIST
57321: LIST
57322: PPUSH
57323: CALL_OW 72
57327: ST_TO_ADDR
// case class of 1 , 15 :
57328: LD_VAR 0 4
57332: PUSH
57333: LD_INT 1
57335: DOUBLE
57336: EQUAL
57337: IFTRUE 57347
57339: LD_INT 15
57341: DOUBLE
57342: EQUAL
57343: IFTRUE 57347
57345: GO 57432
57347: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
57348: LD_ADDR_VAR 0 8
57352: PUSH
57353: LD_VAR 0 2
57357: PPUSH
57358: LD_INT 2
57360: PUSH
57361: LD_INT 30
57363: PUSH
57364: LD_INT 32
57366: PUSH
57367: EMPTY
57368: LIST
57369: LIST
57370: PUSH
57371: LD_INT 30
57373: PUSH
57374: LD_INT 31
57376: PUSH
57377: EMPTY
57378: LIST
57379: LIST
57380: PUSH
57381: EMPTY
57382: LIST
57383: LIST
57384: LIST
57385: PPUSH
57386: CALL_OW 72
57390: PUSH
57391: LD_VAR 0 2
57395: PPUSH
57396: LD_INT 2
57398: PUSH
57399: LD_INT 30
57401: PUSH
57402: LD_INT 4
57404: PUSH
57405: EMPTY
57406: LIST
57407: LIST
57408: PUSH
57409: LD_INT 30
57411: PUSH
57412: LD_INT 5
57414: PUSH
57415: EMPTY
57416: LIST
57417: LIST
57418: PUSH
57419: EMPTY
57420: LIST
57421: LIST
57422: LIST
57423: PPUSH
57424: CALL_OW 72
57428: ADD
57429: ST_TO_ADDR
57430: GO 57678
57432: LD_INT 2
57434: DOUBLE
57435: EQUAL
57436: IFTRUE 57446
57438: LD_INT 16
57440: DOUBLE
57441: EQUAL
57442: IFTRUE 57446
57444: GO 57492
57446: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
57447: LD_ADDR_VAR 0 8
57451: PUSH
57452: LD_VAR 0 2
57456: PPUSH
57457: LD_INT 2
57459: PUSH
57460: LD_INT 30
57462: PUSH
57463: LD_INT 0
57465: PUSH
57466: EMPTY
57467: LIST
57468: LIST
57469: PUSH
57470: LD_INT 30
57472: PUSH
57473: LD_INT 1
57475: PUSH
57476: EMPTY
57477: LIST
57478: LIST
57479: PUSH
57480: EMPTY
57481: LIST
57482: LIST
57483: LIST
57484: PPUSH
57485: CALL_OW 72
57489: ST_TO_ADDR
57490: GO 57678
57492: LD_INT 3
57494: DOUBLE
57495: EQUAL
57496: IFTRUE 57500
57498: GO 57546
57500: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
57501: LD_ADDR_VAR 0 8
57505: PUSH
57506: LD_VAR 0 2
57510: PPUSH
57511: LD_INT 2
57513: PUSH
57514: LD_INT 30
57516: PUSH
57517: LD_INT 2
57519: PUSH
57520: EMPTY
57521: LIST
57522: LIST
57523: PUSH
57524: LD_INT 30
57526: PUSH
57527: LD_INT 3
57529: PUSH
57530: EMPTY
57531: LIST
57532: LIST
57533: PUSH
57534: EMPTY
57535: LIST
57536: LIST
57537: LIST
57538: PPUSH
57539: CALL_OW 72
57543: ST_TO_ADDR
57544: GO 57678
57546: LD_INT 4
57548: DOUBLE
57549: EQUAL
57550: IFTRUE 57554
57552: GO 57611
57554: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
57555: LD_ADDR_VAR 0 8
57559: PUSH
57560: LD_VAR 0 2
57564: PPUSH
57565: LD_INT 2
57567: PUSH
57568: LD_INT 30
57570: PUSH
57571: LD_INT 6
57573: PUSH
57574: EMPTY
57575: LIST
57576: LIST
57577: PUSH
57578: LD_INT 30
57580: PUSH
57581: LD_INT 7
57583: PUSH
57584: EMPTY
57585: LIST
57586: LIST
57587: PUSH
57588: LD_INT 30
57590: PUSH
57591: LD_INT 8
57593: PUSH
57594: EMPTY
57595: LIST
57596: LIST
57597: PUSH
57598: EMPTY
57599: LIST
57600: LIST
57601: LIST
57602: LIST
57603: PPUSH
57604: CALL_OW 72
57608: ST_TO_ADDR
57609: GO 57678
57611: LD_INT 5
57613: DOUBLE
57614: EQUAL
57615: IFTRUE 57631
57617: LD_INT 8
57619: DOUBLE
57620: EQUAL
57621: IFTRUE 57631
57623: LD_INT 9
57625: DOUBLE
57626: EQUAL
57627: IFTRUE 57631
57629: GO 57677
57631: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
57632: LD_ADDR_VAR 0 8
57636: PUSH
57637: LD_VAR 0 2
57641: PPUSH
57642: LD_INT 2
57644: PUSH
57645: LD_INT 30
57647: PUSH
57648: LD_INT 4
57650: PUSH
57651: EMPTY
57652: LIST
57653: LIST
57654: PUSH
57655: LD_INT 30
57657: PUSH
57658: LD_INT 5
57660: PUSH
57661: EMPTY
57662: LIST
57663: LIST
57664: PUSH
57665: EMPTY
57666: LIST
57667: LIST
57668: LIST
57669: PPUSH
57670: CALL_OW 72
57674: ST_TO_ADDR
57675: GO 57678
57677: POP
// if not tmp then
57678: LD_VAR 0 8
57682: NOT
57683: IFFALSE 57687
// exit ;
57685: GO 58189
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
57687: LD_VAR 0 4
57691: PUSH
57692: LD_INT 1
57694: PUSH
57695: LD_INT 15
57697: PUSH
57698: EMPTY
57699: LIST
57700: LIST
57701: IN
57702: PUSH
57703: LD_EXP 122
57707: PUSH
57708: LD_VAR 0 1
57712: ARRAY
57713: AND
57714: IFFALSE 57870
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
57716: LD_ADDR_VAR 0 9
57720: PUSH
57721: LD_EXP 122
57725: PUSH
57726: LD_VAR 0 1
57730: ARRAY
57731: PUSH
57732: LD_INT 1
57734: ARRAY
57735: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
57736: LD_VAR 0 9
57740: PUSH
57741: LD_EXP 123
57745: PUSH
57746: LD_VAR 0 1
57750: ARRAY
57751: IN
57752: NOT
57753: IFFALSE 57868
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
57755: LD_ADDR_EXP 123
57759: PUSH
57760: LD_EXP 123
57764: PPUSH
57765: LD_VAR 0 1
57769: PUSH
57770: LD_EXP 123
57774: PUSH
57775: LD_VAR 0 1
57779: ARRAY
57780: PUSH
57781: LD_INT 1
57783: PLUS
57784: PUSH
57785: EMPTY
57786: LIST
57787: LIST
57788: PPUSH
57789: LD_VAR 0 9
57793: PPUSH
57794: CALL 70128 0 3
57798: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
57799: LD_ADDR_EXP 122
57803: PUSH
57804: LD_EXP 122
57808: PPUSH
57809: LD_VAR 0 1
57813: PPUSH
57814: LD_EXP 122
57818: PUSH
57819: LD_VAR 0 1
57823: ARRAY
57824: PUSH
57825: LD_VAR 0 9
57829: DIFF
57830: PPUSH
57831: CALL_OW 1
57835: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
57836: LD_VAR 0 3
57840: PPUSH
57841: LD_EXP 123
57845: PUSH
57846: LD_VAR 0 1
57850: ARRAY
57851: PUSH
57852: LD_EXP 123
57856: PUSH
57857: LD_VAR 0 1
57861: ARRAY
57862: ARRAY
57863: PPUSH
57864: CALL_OW 120
// end ; exit ;
57868: GO 58189
// end ; if tmp > 1 then
57870: LD_VAR 0 8
57874: PUSH
57875: LD_INT 1
57877: GREATER
57878: IFFALSE 57982
// for i = 2 to tmp do
57880: LD_ADDR_VAR 0 6
57884: PUSH
57885: DOUBLE
57886: LD_INT 2
57888: DEC
57889: ST_TO_ADDR
57890: LD_VAR 0 8
57894: PUSH
57895: FOR_TO
57896: IFFALSE 57980
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
57898: LD_VAR 0 8
57902: PUSH
57903: LD_VAR 0 6
57907: ARRAY
57908: PPUSH
57909: CALL_OW 461
57913: PUSH
57914: LD_INT 6
57916: EQUAL
57917: IFFALSE 57978
// begin x := tmp [ i ] ;
57919: LD_ADDR_VAR 0 9
57923: PUSH
57924: LD_VAR 0 8
57928: PUSH
57929: LD_VAR 0 6
57933: ARRAY
57934: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
57935: LD_ADDR_VAR 0 8
57939: PUSH
57940: LD_VAR 0 8
57944: PPUSH
57945: LD_VAR 0 6
57949: PPUSH
57950: CALL_OW 3
57954: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
57955: LD_ADDR_VAR 0 8
57959: PUSH
57960: LD_VAR 0 8
57964: PPUSH
57965: LD_INT 1
57967: PPUSH
57968: LD_VAR 0 9
57972: PPUSH
57973: CALL_OW 2
57977: ST_TO_ADDR
// end ;
57978: GO 57895
57980: POP
57981: POP
// for i in tmp do
57982: LD_ADDR_VAR 0 6
57986: PUSH
57987: LD_VAR 0 8
57991: PUSH
57992: FOR_IN
57993: IFFALSE 58062
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
57995: LD_VAR 0 6
57999: PPUSH
58000: CALL_OW 313
58004: PUSH
58005: LD_INT 6
58007: LESS
58008: PUSH
58009: LD_VAR 0 6
58013: PPUSH
58014: CALL_OW 266
58018: PUSH
58019: LD_INT 31
58021: PUSH
58022: LD_INT 32
58024: PUSH
58025: EMPTY
58026: LIST
58027: LIST
58028: IN
58029: NOT
58030: AND
58031: PUSH
58032: LD_VAR 0 6
58036: PPUSH
58037: CALL_OW 313
58041: PUSH
58042: LD_INT 0
58044: EQUAL
58045: OR
58046: IFFALSE 58060
// begin j := i ;
58048: LD_ADDR_VAR 0 7
58052: PUSH
58053: LD_VAR 0 6
58057: ST_TO_ADDR
// break ;
58058: GO 58062
// end ; end ;
58060: GO 57992
58062: POP
58063: POP
// if j then
58064: LD_VAR 0 7
58068: IFFALSE 58086
// ComEnterUnit ( unit , j ) else
58070: LD_VAR 0 3
58074: PPUSH
58075: LD_VAR 0 7
58079: PPUSH
58080: CALL_OW 120
58084: GO 58189
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58086: LD_ADDR_VAR 0 10
58090: PUSH
58091: LD_VAR 0 2
58095: PPUSH
58096: LD_INT 2
58098: PUSH
58099: LD_INT 30
58101: PUSH
58102: LD_INT 0
58104: PUSH
58105: EMPTY
58106: LIST
58107: LIST
58108: PUSH
58109: LD_INT 30
58111: PUSH
58112: LD_INT 1
58114: PUSH
58115: EMPTY
58116: LIST
58117: LIST
58118: PUSH
58119: EMPTY
58120: LIST
58121: LIST
58122: LIST
58123: PPUSH
58124: CALL_OW 72
58128: ST_TO_ADDR
// if depot then
58129: LD_VAR 0 10
58133: IFFALSE 58189
// begin depot := NearestUnitToUnit ( depot , unit ) ;
58135: LD_ADDR_VAR 0 10
58139: PUSH
58140: LD_VAR 0 10
58144: PPUSH
58145: LD_VAR 0 3
58149: PPUSH
58150: CALL_OW 74
58154: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
58155: LD_VAR 0 3
58159: PPUSH
58160: LD_VAR 0 10
58164: PPUSH
58165: CALL_OW 296
58169: PUSH
58170: LD_INT 10
58172: GREATER
58173: IFFALSE 58189
// ComStandNearbyBuilding ( unit , depot ) ;
58175: LD_VAR 0 3
58179: PPUSH
58180: LD_VAR 0 10
58184: PPUSH
58185: CALL 66742 0 2
// end ; end ; end ;
58189: LD_VAR 0 5
58193: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
58194: LD_INT 0
58196: PPUSH
58197: PPUSH
58198: PPUSH
58199: PPUSH
// if not mc_bases then
58200: LD_EXP 113
58204: NOT
58205: IFFALSE 58209
// exit ;
58207: GO 58448
// for i = 1 to mc_bases do
58209: LD_ADDR_VAR 0 2
58213: PUSH
58214: DOUBLE
58215: LD_INT 1
58217: DEC
58218: ST_TO_ADDR
58219: LD_EXP 113
58223: PUSH
58224: FOR_TO
58225: IFFALSE 58446
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
58227: LD_ADDR_VAR 0 4
58231: PUSH
58232: LD_EXP 113
58236: PUSH
58237: LD_VAR 0 2
58241: ARRAY
58242: PPUSH
58243: LD_INT 21
58245: PUSH
58246: LD_INT 1
58248: PUSH
58249: EMPTY
58250: LIST
58251: LIST
58252: PPUSH
58253: CALL_OW 72
58257: PUSH
58258: LD_EXP 142
58262: PUSH
58263: LD_VAR 0 2
58267: ARRAY
58268: UNION
58269: ST_TO_ADDR
// if not tmp then
58270: LD_VAR 0 4
58274: NOT
58275: IFFALSE 58279
// continue ;
58277: GO 58224
// for j in tmp do
58279: LD_ADDR_VAR 0 3
58283: PUSH
58284: LD_VAR 0 4
58288: PUSH
58289: FOR_IN
58290: IFFALSE 58442
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58292: LD_VAR 0 3
58296: PPUSH
58297: CALL_OW 110
58301: NOT
58302: PUSH
58303: LD_VAR 0 3
58307: PPUSH
58308: CALL_OW 314
58312: NOT
58313: AND
58314: PUSH
58315: LD_VAR 0 3
58319: PPUSH
58320: CALL_OW 311
58324: NOT
58325: AND
58326: PUSH
58327: LD_VAR 0 3
58331: PPUSH
58332: CALL_OW 310
58336: NOT
58337: AND
58338: PUSH
58339: LD_VAR 0 3
58343: PUSH
58344: LD_EXP 116
58348: PUSH
58349: LD_VAR 0 2
58353: ARRAY
58354: PUSH
58355: LD_INT 1
58357: ARRAY
58358: IN
58359: NOT
58360: AND
58361: PUSH
58362: LD_VAR 0 3
58366: PUSH
58367: LD_EXP 116
58371: PUSH
58372: LD_VAR 0 2
58376: ARRAY
58377: PUSH
58378: LD_INT 2
58380: ARRAY
58381: IN
58382: NOT
58383: AND
58384: PUSH
58385: LD_VAR 0 3
58389: PUSH
58390: LD_EXP 125
58394: PUSH
58395: LD_VAR 0 2
58399: ARRAY
58400: IN
58401: NOT
58402: AND
58403: IFFALSE 58440
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
58405: LD_VAR 0 2
58409: PPUSH
58410: LD_EXP 113
58414: PUSH
58415: LD_VAR 0 2
58419: ARRAY
58420: PPUSH
58421: LD_VAR 0 3
58425: PPUSH
58426: LD_VAR 0 3
58430: PPUSH
58431: CALL_OW 257
58435: PPUSH
58436: CALL 57212 0 4
// end ;
58440: GO 58289
58442: POP
58443: POP
// end ;
58444: GO 58224
58446: POP
58447: POP
// end ;
58448: LD_VAR 0 1
58452: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
58453: LD_INT 0
58455: PPUSH
58456: PPUSH
58457: PPUSH
58458: PPUSH
58459: PPUSH
58460: PPUSH
// if not mc_bases [ base ] then
58461: LD_EXP 113
58465: PUSH
58466: LD_VAR 0 1
58470: ARRAY
58471: NOT
58472: IFFALSE 58476
// exit ;
58474: GO 58658
// tmp := [ ] ;
58476: LD_ADDR_VAR 0 6
58480: PUSH
58481: EMPTY
58482: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
58483: LD_ADDR_VAR 0 7
58487: PUSH
58488: LD_VAR 0 3
58492: PPUSH
58493: LD_INT 0
58495: PPUSH
58496: CALL_OW 517
58500: ST_TO_ADDR
// if not list then
58501: LD_VAR 0 7
58505: NOT
58506: IFFALSE 58510
// exit ;
58508: GO 58658
// for i = 1 to amount do
58510: LD_ADDR_VAR 0 5
58514: PUSH
58515: DOUBLE
58516: LD_INT 1
58518: DEC
58519: ST_TO_ADDR
58520: LD_VAR 0 2
58524: PUSH
58525: FOR_TO
58526: IFFALSE 58606
// begin x := rand ( 1 , list [ 1 ] ) ;
58528: LD_ADDR_VAR 0 8
58532: PUSH
58533: LD_INT 1
58535: PPUSH
58536: LD_VAR 0 7
58540: PUSH
58541: LD_INT 1
58543: ARRAY
58544: PPUSH
58545: CALL_OW 12
58549: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
58550: LD_ADDR_VAR 0 6
58554: PUSH
58555: LD_VAR 0 6
58559: PPUSH
58560: LD_VAR 0 5
58564: PPUSH
58565: LD_VAR 0 7
58569: PUSH
58570: LD_INT 1
58572: ARRAY
58573: PUSH
58574: LD_VAR 0 8
58578: ARRAY
58579: PUSH
58580: LD_VAR 0 7
58584: PUSH
58585: LD_INT 2
58587: ARRAY
58588: PUSH
58589: LD_VAR 0 8
58593: ARRAY
58594: PUSH
58595: EMPTY
58596: LIST
58597: LIST
58598: PPUSH
58599: CALL_OW 1
58603: ST_TO_ADDR
// end ;
58604: GO 58525
58606: POP
58607: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
58608: LD_ADDR_EXP 126
58612: PUSH
58613: LD_EXP 126
58617: PPUSH
58618: LD_VAR 0 1
58622: PPUSH
58623: LD_VAR 0 6
58627: PPUSH
58628: CALL_OW 1
58632: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
58633: LD_ADDR_EXP 128
58637: PUSH
58638: LD_EXP 128
58642: PPUSH
58643: LD_VAR 0 1
58647: PPUSH
58648: LD_VAR 0 3
58652: PPUSH
58653: CALL_OW 1
58657: ST_TO_ADDR
// end ;
58658: LD_VAR 0 4
58662: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
58663: LD_INT 0
58665: PPUSH
// if not mc_bases [ base ] then
58666: LD_EXP 113
58670: PUSH
58671: LD_VAR 0 1
58675: ARRAY
58676: NOT
58677: IFFALSE 58681
// exit ;
58679: GO 58706
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
58681: LD_ADDR_EXP 118
58685: PUSH
58686: LD_EXP 118
58690: PPUSH
58691: LD_VAR 0 1
58695: PPUSH
58696: LD_VAR 0 2
58700: PPUSH
58701: CALL_OW 1
58705: ST_TO_ADDR
// end ;
58706: LD_VAR 0 3
58710: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
58711: LD_INT 0
58713: PPUSH
// if not mc_bases [ base ] then
58714: LD_EXP 113
58718: PUSH
58719: LD_VAR 0 1
58723: ARRAY
58724: NOT
58725: IFFALSE 58729
// exit ;
58727: GO 58766
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
58729: LD_ADDR_EXP 118
58733: PUSH
58734: LD_EXP 118
58738: PPUSH
58739: LD_VAR 0 1
58743: PPUSH
58744: LD_EXP 118
58748: PUSH
58749: LD_VAR 0 1
58753: ARRAY
58754: PUSH
58755: LD_VAR 0 2
58759: UNION
58760: PPUSH
58761: CALL_OW 1
58765: ST_TO_ADDR
// end ;
58766: LD_VAR 0 3
58770: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
58771: LD_INT 0
58773: PPUSH
// if not mc_bases [ base ] then
58774: LD_EXP 113
58778: PUSH
58779: LD_VAR 0 1
58783: ARRAY
58784: NOT
58785: IFFALSE 58789
// exit ;
58787: GO 58814
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
58789: LD_ADDR_EXP 134
58793: PUSH
58794: LD_EXP 134
58798: PPUSH
58799: LD_VAR 0 1
58803: PPUSH
58804: LD_VAR 0 2
58808: PPUSH
58809: CALL_OW 1
58813: ST_TO_ADDR
// end ;
58814: LD_VAR 0 3
58818: RET
// export function MC_InsertProduceList ( base , components ) ; begin
58819: LD_INT 0
58821: PPUSH
// if not mc_bases [ base ] then
58822: LD_EXP 113
58826: PUSH
58827: LD_VAR 0 1
58831: ARRAY
58832: NOT
58833: IFFALSE 58837
// exit ;
58835: GO 58874
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
58837: LD_ADDR_EXP 134
58841: PUSH
58842: LD_EXP 134
58846: PPUSH
58847: LD_VAR 0 1
58851: PPUSH
58852: LD_EXP 134
58856: PUSH
58857: LD_VAR 0 1
58861: ARRAY
58862: PUSH
58863: LD_VAR 0 2
58867: ADD
58868: PPUSH
58869: CALL_OW 1
58873: ST_TO_ADDR
// end ;
58874: LD_VAR 0 3
58878: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
58879: LD_INT 0
58881: PPUSH
// if not mc_bases [ base ] then
58882: LD_EXP 113
58886: PUSH
58887: LD_VAR 0 1
58891: ARRAY
58892: NOT
58893: IFFALSE 58897
// exit ;
58895: GO 58951
// mc_defender := Replace ( mc_defender , base , deflist ) ;
58897: LD_ADDR_EXP 135
58901: PUSH
58902: LD_EXP 135
58906: PPUSH
58907: LD_VAR 0 1
58911: PPUSH
58912: LD_VAR 0 2
58916: PPUSH
58917: CALL_OW 1
58921: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
58922: LD_ADDR_EXP 124
58926: PUSH
58927: LD_EXP 124
58931: PPUSH
58932: LD_VAR 0 1
58936: PPUSH
58937: LD_VAR 0 2
58941: PUSH
58942: LD_INT 0
58944: PLUS
58945: PPUSH
58946: CALL_OW 1
58950: ST_TO_ADDR
// end ;
58951: LD_VAR 0 3
58955: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
58956: LD_INT 0
58958: PPUSH
// if not mc_bases [ base ] then
58959: LD_EXP 113
58963: PUSH
58964: LD_VAR 0 1
58968: ARRAY
58969: NOT
58970: IFFALSE 58974
// exit ;
58972: GO 58999
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
58974: LD_ADDR_EXP 124
58978: PUSH
58979: LD_EXP 124
58983: PPUSH
58984: LD_VAR 0 1
58988: PPUSH
58989: LD_VAR 0 2
58993: PPUSH
58994: CALL_OW 1
58998: ST_TO_ADDR
// end ;
58999: LD_VAR 0 3
59003: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
59004: LD_INT 0
59006: PPUSH
59007: PPUSH
59008: PPUSH
59009: PPUSH
// if not mc_bases [ base ] then
59010: LD_EXP 113
59014: PUSH
59015: LD_VAR 0 1
59019: ARRAY
59020: NOT
59021: IFFALSE 59025
// exit ;
59023: GO 59090
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
59025: LD_ADDR_EXP 133
59029: PUSH
59030: LD_EXP 133
59034: PPUSH
59035: LD_VAR 0 1
59039: PUSH
59040: LD_EXP 133
59044: PUSH
59045: LD_VAR 0 1
59049: ARRAY
59050: PUSH
59051: LD_INT 1
59053: PLUS
59054: PUSH
59055: EMPTY
59056: LIST
59057: LIST
59058: PPUSH
59059: LD_VAR 0 1
59063: PUSH
59064: LD_VAR 0 2
59068: PUSH
59069: LD_VAR 0 3
59073: PUSH
59074: LD_VAR 0 4
59078: PUSH
59079: EMPTY
59080: LIST
59081: LIST
59082: LIST
59083: LIST
59084: PPUSH
59085: CALL 70128 0 3
59089: ST_TO_ADDR
// end ;
59090: LD_VAR 0 5
59094: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
59095: LD_INT 0
59097: PPUSH
// if not mc_bases [ base ] then
59098: LD_EXP 113
59102: PUSH
59103: LD_VAR 0 1
59107: ARRAY
59108: NOT
59109: IFFALSE 59113
// exit ;
59111: GO 59138
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
59113: LD_ADDR_EXP 150
59117: PUSH
59118: LD_EXP 150
59122: PPUSH
59123: LD_VAR 0 1
59127: PPUSH
59128: LD_VAR 0 2
59132: PPUSH
59133: CALL_OW 1
59137: ST_TO_ADDR
// end ;
59138: LD_VAR 0 3
59142: RET
// export function MC_GetMinesField ( base ) ; begin
59143: LD_INT 0
59145: PPUSH
// result := mc_mines [ base ] ;
59146: LD_ADDR_VAR 0 2
59150: PUSH
59151: LD_EXP 126
59155: PUSH
59156: LD_VAR 0 1
59160: ARRAY
59161: ST_TO_ADDR
// end ;
59162: LD_VAR 0 2
59166: RET
// export function MC_GetProduceList ( base ) ; begin
59167: LD_INT 0
59169: PPUSH
// result := mc_produce [ base ] ;
59170: LD_ADDR_VAR 0 2
59174: PUSH
59175: LD_EXP 134
59179: PUSH
59180: LD_VAR 0 1
59184: ARRAY
59185: ST_TO_ADDR
// end ;
59186: LD_VAR 0 2
59190: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
59191: LD_INT 0
59193: PPUSH
59194: PPUSH
// if not mc_bases then
59195: LD_EXP 113
59199: NOT
59200: IFFALSE 59204
// exit ;
59202: GO 59269
// if mc_bases [ base ] then
59204: LD_EXP 113
59208: PUSH
59209: LD_VAR 0 1
59213: ARRAY
59214: IFFALSE 59269
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59216: LD_ADDR_VAR 0 3
59220: PUSH
59221: LD_EXP 113
59225: PUSH
59226: LD_VAR 0 1
59230: ARRAY
59231: PPUSH
59232: LD_INT 30
59234: PUSH
59235: LD_VAR 0 2
59239: PUSH
59240: EMPTY
59241: LIST
59242: LIST
59243: PPUSH
59244: CALL_OW 72
59248: ST_TO_ADDR
// if result then
59249: LD_VAR 0 3
59253: IFFALSE 59269
// result := result [ 1 ] ;
59255: LD_ADDR_VAR 0 3
59259: PUSH
59260: LD_VAR 0 3
59264: PUSH
59265: LD_INT 1
59267: ARRAY
59268: ST_TO_ADDR
// end ; end ;
59269: LD_VAR 0 3
59273: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59274: LD_INT 0
59276: PPUSH
59277: PPUSH
// if not mc_bases then
59278: LD_EXP 113
59282: NOT
59283: IFFALSE 59287
// exit ;
59285: GO 59332
// if mc_bases [ base ] then
59287: LD_EXP 113
59291: PUSH
59292: LD_VAR 0 1
59296: ARRAY
59297: IFFALSE 59332
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59299: LD_ADDR_VAR 0 3
59303: PUSH
59304: LD_EXP 113
59308: PUSH
59309: LD_VAR 0 1
59313: ARRAY
59314: PPUSH
59315: LD_INT 30
59317: PUSH
59318: LD_VAR 0 2
59322: PUSH
59323: EMPTY
59324: LIST
59325: LIST
59326: PPUSH
59327: CALL_OW 72
59331: ST_TO_ADDR
// end ;
59332: LD_VAR 0 3
59336: RET
// export function MC_SetTame ( base , area ) ; begin
59337: LD_INT 0
59339: PPUSH
// if not mc_bases or not base then
59340: LD_EXP 113
59344: NOT
59345: PUSH
59346: LD_VAR 0 1
59350: NOT
59351: OR
59352: IFFALSE 59356
// exit ;
59354: GO 59381
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
59356: LD_ADDR_EXP 141
59360: PUSH
59361: LD_EXP 141
59365: PPUSH
59366: LD_VAR 0 1
59370: PPUSH
59371: LD_VAR 0 2
59375: PPUSH
59376: CALL_OW 1
59380: ST_TO_ADDR
// end ;
59381: LD_VAR 0 3
59385: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
59386: LD_INT 0
59388: PPUSH
59389: PPUSH
// if not mc_bases or not base then
59390: LD_EXP 113
59394: NOT
59395: PUSH
59396: LD_VAR 0 1
59400: NOT
59401: OR
59402: IFFALSE 59406
// exit ;
59404: GO 59508
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59406: LD_ADDR_VAR 0 4
59410: PUSH
59411: LD_EXP 113
59415: PUSH
59416: LD_VAR 0 1
59420: ARRAY
59421: PPUSH
59422: LD_INT 30
59424: PUSH
59425: LD_VAR 0 2
59429: PUSH
59430: EMPTY
59431: LIST
59432: LIST
59433: PPUSH
59434: CALL_OW 72
59438: ST_TO_ADDR
// if not tmp then
59439: LD_VAR 0 4
59443: NOT
59444: IFFALSE 59448
// exit ;
59446: GO 59508
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
59448: LD_ADDR_EXP 145
59452: PUSH
59453: LD_EXP 145
59457: PPUSH
59458: LD_VAR 0 1
59462: PPUSH
59463: LD_EXP 145
59467: PUSH
59468: LD_VAR 0 1
59472: ARRAY
59473: PPUSH
59474: LD_EXP 145
59478: PUSH
59479: LD_VAR 0 1
59483: ARRAY
59484: PUSH
59485: LD_INT 1
59487: PLUS
59488: PPUSH
59489: LD_VAR 0 4
59493: PUSH
59494: LD_INT 1
59496: ARRAY
59497: PPUSH
59498: CALL_OW 2
59502: PPUSH
59503: CALL_OW 1
59507: ST_TO_ADDR
// end ;
59508: LD_VAR 0 3
59512: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
59513: LD_INT 0
59515: PPUSH
59516: PPUSH
// if not mc_bases or not base or not kinds then
59517: LD_EXP 113
59521: NOT
59522: PUSH
59523: LD_VAR 0 1
59527: NOT
59528: OR
59529: PUSH
59530: LD_VAR 0 2
59534: NOT
59535: OR
59536: IFFALSE 59540
// exit ;
59538: GO 59601
// for i in kinds do
59540: LD_ADDR_VAR 0 4
59544: PUSH
59545: LD_VAR 0 2
59549: PUSH
59550: FOR_IN
59551: IFFALSE 59599
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
59553: LD_ADDR_EXP 147
59557: PUSH
59558: LD_EXP 147
59562: PPUSH
59563: LD_VAR 0 1
59567: PUSH
59568: LD_EXP 147
59572: PUSH
59573: LD_VAR 0 1
59577: ARRAY
59578: PUSH
59579: LD_INT 1
59581: PLUS
59582: PUSH
59583: EMPTY
59584: LIST
59585: LIST
59586: PPUSH
59587: LD_VAR 0 4
59591: PPUSH
59592: CALL 70128 0 3
59596: ST_TO_ADDR
59597: GO 59550
59599: POP
59600: POP
// end ;
59601: LD_VAR 0 3
59605: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
59606: LD_INT 0
59608: PPUSH
// if not mc_bases or not base or not areas then
59609: LD_EXP 113
59613: NOT
59614: PUSH
59615: LD_VAR 0 1
59619: NOT
59620: OR
59621: PUSH
59622: LD_VAR 0 2
59626: NOT
59627: OR
59628: IFFALSE 59632
// exit ;
59630: GO 59657
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
59632: LD_ADDR_EXP 131
59636: PUSH
59637: LD_EXP 131
59641: PPUSH
59642: LD_VAR 0 1
59646: PPUSH
59647: LD_VAR 0 2
59651: PPUSH
59652: CALL_OW 1
59656: ST_TO_ADDR
// end ;
59657: LD_VAR 0 3
59661: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
59662: LD_INT 0
59664: PPUSH
// if not mc_bases or not base or not teleports_exit then
59665: LD_EXP 113
59669: NOT
59670: PUSH
59671: LD_VAR 0 1
59675: NOT
59676: OR
59677: PUSH
59678: LD_VAR 0 2
59682: NOT
59683: OR
59684: IFFALSE 59688
// exit ;
59686: GO 59713
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
59688: LD_ADDR_EXP 148
59692: PUSH
59693: LD_EXP 148
59697: PPUSH
59698: LD_VAR 0 1
59702: PPUSH
59703: LD_VAR 0 2
59707: PPUSH
59708: CALL_OW 1
59712: ST_TO_ADDR
// end ;
59713: LD_VAR 0 3
59717: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
59718: LD_INT 0
59720: PPUSH
59721: PPUSH
59722: PPUSH
// if not mc_bases or not base or not ext_list then
59723: LD_EXP 113
59727: NOT
59728: PUSH
59729: LD_VAR 0 1
59733: NOT
59734: OR
59735: PUSH
59736: LD_VAR 0 5
59740: NOT
59741: OR
59742: IFFALSE 59746
// exit ;
59744: GO 59919
// tmp := GetFacExtXYD ( x , y , d ) ;
59746: LD_ADDR_VAR 0 8
59750: PUSH
59751: LD_VAR 0 2
59755: PPUSH
59756: LD_VAR 0 3
59760: PPUSH
59761: LD_VAR 0 4
59765: PPUSH
59766: CALL 98807 0 3
59770: ST_TO_ADDR
// if not tmp then
59771: LD_VAR 0 8
59775: NOT
59776: IFFALSE 59780
// exit ;
59778: GO 59919
// for i in tmp do
59780: LD_ADDR_VAR 0 7
59784: PUSH
59785: LD_VAR 0 8
59789: PUSH
59790: FOR_IN
59791: IFFALSE 59917
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
59793: LD_ADDR_EXP 118
59797: PUSH
59798: LD_EXP 118
59802: PPUSH
59803: LD_VAR 0 1
59807: PPUSH
59808: LD_EXP 118
59812: PUSH
59813: LD_VAR 0 1
59817: ARRAY
59818: PPUSH
59819: LD_EXP 118
59823: PUSH
59824: LD_VAR 0 1
59828: ARRAY
59829: PUSH
59830: LD_INT 1
59832: PLUS
59833: PPUSH
59834: LD_VAR 0 5
59838: PUSH
59839: LD_INT 1
59841: ARRAY
59842: PUSH
59843: LD_VAR 0 7
59847: PUSH
59848: LD_INT 1
59850: ARRAY
59851: PUSH
59852: LD_VAR 0 7
59856: PUSH
59857: LD_INT 2
59859: ARRAY
59860: PUSH
59861: LD_VAR 0 7
59865: PUSH
59866: LD_INT 3
59868: ARRAY
59869: PUSH
59870: EMPTY
59871: LIST
59872: LIST
59873: LIST
59874: LIST
59875: PPUSH
59876: CALL_OW 2
59880: PPUSH
59881: CALL_OW 1
59885: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
59886: LD_ADDR_VAR 0 5
59890: PUSH
59891: LD_VAR 0 5
59895: PPUSH
59896: LD_INT 1
59898: PPUSH
59899: CALL_OW 3
59903: ST_TO_ADDR
// if not ext_list then
59904: LD_VAR 0 5
59908: NOT
59909: IFFALSE 59915
// exit ;
59911: POP
59912: POP
59913: GO 59919
// end ;
59915: GO 59790
59917: POP
59918: POP
// end ;
59919: LD_VAR 0 6
59923: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
59924: LD_INT 0
59926: PPUSH
// if not mc_bases or not base or not weapon_list then
59927: LD_EXP 113
59931: NOT
59932: PUSH
59933: LD_VAR 0 1
59937: NOT
59938: OR
59939: PUSH
59940: LD_VAR 0 2
59944: NOT
59945: OR
59946: IFFALSE 59950
// exit ;
59948: GO 59975
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
59950: LD_ADDR_EXP 152
59954: PUSH
59955: LD_EXP 152
59959: PPUSH
59960: LD_VAR 0 1
59964: PPUSH
59965: LD_VAR 0 2
59969: PPUSH
59970: CALL_OW 1
59974: ST_TO_ADDR
// end ;
59975: LD_VAR 0 3
59979: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
59980: LD_INT 0
59982: PPUSH
// if not mc_bases or not base or not tech_list then
59983: LD_EXP 113
59987: NOT
59988: PUSH
59989: LD_VAR 0 1
59993: NOT
59994: OR
59995: PUSH
59996: LD_VAR 0 2
60000: NOT
60001: OR
60002: IFFALSE 60006
// exit ;
60004: GO 60031
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
60006: LD_ADDR_EXP 140
60010: PUSH
60011: LD_EXP 140
60015: PPUSH
60016: LD_VAR 0 1
60020: PPUSH
60021: LD_VAR 0 2
60025: PPUSH
60026: CALL_OW 1
60030: ST_TO_ADDR
// end ;
60031: LD_VAR 0 3
60035: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
60036: LD_INT 0
60038: PPUSH
// if not mc_bases or not parking_area or not base then
60039: LD_EXP 113
60043: NOT
60044: PUSH
60045: LD_VAR 0 2
60049: NOT
60050: OR
60051: PUSH
60052: LD_VAR 0 1
60056: NOT
60057: OR
60058: IFFALSE 60062
// exit ;
60060: GO 60087
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
60062: LD_ADDR_EXP 137
60066: PUSH
60067: LD_EXP 137
60071: PPUSH
60072: LD_VAR 0 1
60076: PPUSH
60077: LD_VAR 0 2
60081: PPUSH
60082: CALL_OW 1
60086: ST_TO_ADDR
// end ;
60087: LD_VAR 0 3
60091: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
60092: LD_INT 0
60094: PPUSH
// if not mc_bases or not base or not scan_area then
60095: LD_EXP 113
60099: NOT
60100: PUSH
60101: LD_VAR 0 1
60105: NOT
60106: OR
60107: PUSH
60108: LD_VAR 0 2
60112: NOT
60113: OR
60114: IFFALSE 60118
// exit ;
60116: GO 60143
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
60118: LD_ADDR_EXP 138
60122: PUSH
60123: LD_EXP 138
60127: PPUSH
60128: LD_VAR 0 1
60132: PPUSH
60133: LD_VAR 0 2
60137: PPUSH
60138: CALL_OW 1
60142: ST_TO_ADDR
// end ;
60143: LD_VAR 0 3
60147: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
60148: LD_INT 0
60150: PPUSH
60151: PPUSH
// if not mc_bases or not base then
60152: LD_EXP 113
60156: NOT
60157: PUSH
60158: LD_VAR 0 1
60162: NOT
60163: OR
60164: IFFALSE 60168
// exit ;
60166: GO 60232
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
60168: LD_ADDR_VAR 0 3
60172: PUSH
60173: LD_INT 1
60175: PUSH
60176: LD_INT 2
60178: PUSH
60179: LD_INT 3
60181: PUSH
60182: LD_INT 4
60184: PUSH
60185: LD_INT 11
60187: PUSH
60188: EMPTY
60189: LIST
60190: LIST
60191: LIST
60192: LIST
60193: LIST
60194: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
60195: LD_ADDR_EXP 140
60199: PUSH
60200: LD_EXP 140
60204: PPUSH
60205: LD_VAR 0 1
60209: PPUSH
60210: LD_EXP 140
60214: PUSH
60215: LD_VAR 0 1
60219: ARRAY
60220: PUSH
60221: LD_VAR 0 3
60225: DIFF
60226: PPUSH
60227: CALL_OW 1
60231: ST_TO_ADDR
// end ;
60232: LD_VAR 0 2
60236: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
60237: LD_INT 0
60239: PPUSH
// result := mc_vehicles [ base ] ;
60240: LD_ADDR_VAR 0 3
60244: PUSH
60245: LD_EXP 132
60249: PUSH
60250: LD_VAR 0 1
60254: ARRAY
60255: ST_TO_ADDR
// if onlyCombat then
60256: LD_VAR 0 2
60260: IFFALSE 60438
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
60262: LD_ADDR_VAR 0 3
60266: PUSH
60267: LD_VAR 0 3
60271: PUSH
60272: LD_VAR 0 3
60276: PPUSH
60277: LD_INT 2
60279: PUSH
60280: LD_INT 34
60282: PUSH
60283: LD_INT 12
60285: PUSH
60286: EMPTY
60287: LIST
60288: LIST
60289: PUSH
60290: LD_INT 34
60292: PUSH
60293: LD_INT 51
60295: PUSH
60296: EMPTY
60297: LIST
60298: LIST
60299: PUSH
60300: LD_INT 34
60302: PUSH
60303: LD_EXP 96
60307: PUSH
60308: EMPTY
60309: LIST
60310: LIST
60311: PUSH
60312: LD_INT 34
60314: PUSH
60315: LD_INT 32
60317: PUSH
60318: EMPTY
60319: LIST
60320: LIST
60321: PUSH
60322: LD_INT 34
60324: PUSH
60325: LD_INT 13
60327: PUSH
60328: EMPTY
60329: LIST
60330: LIST
60331: PUSH
60332: LD_INT 34
60334: PUSH
60335: LD_INT 52
60337: PUSH
60338: EMPTY
60339: LIST
60340: LIST
60341: PUSH
60342: LD_INT 34
60344: PUSH
60345: LD_EXP 101
60349: PUSH
60350: EMPTY
60351: LIST
60352: LIST
60353: PUSH
60354: LD_INT 34
60356: PUSH
60357: LD_INT 14
60359: PUSH
60360: EMPTY
60361: LIST
60362: LIST
60363: PUSH
60364: LD_INT 34
60366: PUSH
60367: LD_INT 53
60369: PUSH
60370: EMPTY
60371: LIST
60372: LIST
60373: PUSH
60374: LD_INT 34
60376: PUSH
60377: LD_EXP 95
60381: PUSH
60382: EMPTY
60383: LIST
60384: LIST
60385: PUSH
60386: LD_INT 34
60388: PUSH
60389: LD_INT 31
60391: PUSH
60392: EMPTY
60393: LIST
60394: LIST
60395: PUSH
60396: LD_INT 34
60398: PUSH
60399: LD_INT 48
60401: PUSH
60402: EMPTY
60403: LIST
60404: LIST
60405: PUSH
60406: LD_INT 34
60408: PUSH
60409: LD_INT 8
60411: PUSH
60412: EMPTY
60413: LIST
60414: LIST
60415: PUSH
60416: EMPTY
60417: LIST
60418: LIST
60419: LIST
60420: LIST
60421: LIST
60422: LIST
60423: LIST
60424: LIST
60425: LIST
60426: LIST
60427: LIST
60428: LIST
60429: LIST
60430: LIST
60431: PPUSH
60432: CALL_OW 72
60436: DIFF
60437: ST_TO_ADDR
// end ; end_of_file
60438: LD_VAR 0 3
60442: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
60443: LD_INT 0
60445: PPUSH
60446: PPUSH
60447: PPUSH
// if not mc_bases or not skirmish then
60448: LD_EXP 113
60452: NOT
60453: PUSH
60454: LD_EXP 111
60458: NOT
60459: OR
60460: IFFALSE 60464
// exit ;
60462: GO 60629
// for i = 1 to mc_bases do
60464: LD_ADDR_VAR 0 4
60468: PUSH
60469: DOUBLE
60470: LD_INT 1
60472: DEC
60473: ST_TO_ADDR
60474: LD_EXP 113
60478: PUSH
60479: FOR_TO
60480: IFFALSE 60627
// begin if sci in mc_bases [ i ] then
60482: LD_VAR 0 2
60486: PUSH
60487: LD_EXP 113
60491: PUSH
60492: LD_VAR 0 4
60496: ARRAY
60497: IN
60498: IFFALSE 60625
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
60500: LD_ADDR_EXP 142
60504: PUSH
60505: LD_EXP 142
60509: PPUSH
60510: LD_VAR 0 4
60514: PUSH
60515: LD_EXP 142
60519: PUSH
60520: LD_VAR 0 4
60524: ARRAY
60525: PUSH
60526: LD_INT 1
60528: PLUS
60529: PUSH
60530: EMPTY
60531: LIST
60532: LIST
60533: PPUSH
60534: LD_VAR 0 1
60538: PPUSH
60539: CALL 70128 0 3
60543: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
60544: LD_ADDR_VAR 0 5
60548: PUSH
60549: LD_EXP 113
60553: PUSH
60554: LD_VAR 0 4
60558: ARRAY
60559: PPUSH
60560: LD_INT 2
60562: PUSH
60563: LD_INT 30
60565: PUSH
60566: LD_INT 0
60568: PUSH
60569: EMPTY
60570: LIST
60571: LIST
60572: PUSH
60573: LD_INT 30
60575: PUSH
60576: LD_INT 1
60578: PUSH
60579: EMPTY
60580: LIST
60581: LIST
60582: PUSH
60583: EMPTY
60584: LIST
60585: LIST
60586: LIST
60587: PPUSH
60588: CALL_OW 72
60592: PPUSH
60593: LD_VAR 0 1
60597: PPUSH
60598: CALL_OW 74
60602: ST_TO_ADDR
// if tmp then
60603: LD_VAR 0 5
60607: IFFALSE 60623
// ComStandNearbyBuilding ( ape , tmp ) ;
60609: LD_VAR 0 1
60613: PPUSH
60614: LD_VAR 0 5
60618: PPUSH
60619: CALL 66742 0 2
// break ;
60623: GO 60627
// end ; end ;
60625: GO 60479
60627: POP
60628: POP
// end ;
60629: LD_VAR 0 3
60633: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
60634: LD_INT 0
60636: PPUSH
60637: PPUSH
60638: PPUSH
// if not mc_bases or not skirmish then
60639: LD_EXP 113
60643: NOT
60644: PUSH
60645: LD_EXP 111
60649: NOT
60650: OR
60651: IFFALSE 60655
// exit ;
60653: GO 60744
// for i = 1 to mc_bases do
60655: LD_ADDR_VAR 0 4
60659: PUSH
60660: DOUBLE
60661: LD_INT 1
60663: DEC
60664: ST_TO_ADDR
60665: LD_EXP 113
60669: PUSH
60670: FOR_TO
60671: IFFALSE 60742
// begin if building in mc_busy_turret_list [ i ] then
60673: LD_VAR 0 1
60677: PUSH
60678: LD_EXP 123
60682: PUSH
60683: LD_VAR 0 4
60687: ARRAY
60688: IN
60689: IFFALSE 60740
// begin tmp := mc_busy_turret_list [ i ] diff building ;
60691: LD_ADDR_VAR 0 5
60695: PUSH
60696: LD_EXP 123
60700: PUSH
60701: LD_VAR 0 4
60705: ARRAY
60706: PUSH
60707: LD_VAR 0 1
60711: DIFF
60712: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
60713: LD_ADDR_EXP 123
60717: PUSH
60718: LD_EXP 123
60722: PPUSH
60723: LD_VAR 0 4
60727: PPUSH
60728: LD_VAR 0 5
60732: PPUSH
60733: CALL_OW 1
60737: ST_TO_ADDR
// break ;
60738: GO 60742
// end ; end ;
60740: GO 60670
60742: POP
60743: POP
// end ;
60744: LD_VAR 0 3
60748: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
60749: LD_INT 0
60751: PPUSH
60752: PPUSH
60753: PPUSH
// if not mc_bases or not skirmish then
60754: LD_EXP 113
60758: NOT
60759: PUSH
60760: LD_EXP 111
60764: NOT
60765: OR
60766: IFFALSE 60770
// exit ;
60768: GO 60969
// for i = 1 to mc_bases do
60770: LD_ADDR_VAR 0 5
60774: PUSH
60775: DOUBLE
60776: LD_INT 1
60778: DEC
60779: ST_TO_ADDR
60780: LD_EXP 113
60784: PUSH
60785: FOR_TO
60786: IFFALSE 60967
// if building in mc_bases [ i ] then
60788: LD_VAR 0 1
60792: PUSH
60793: LD_EXP 113
60797: PUSH
60798: LD_VAR 0 5
60802: ARRAY
60803: IN
60804: IFFALSE 60965
// begin tmp := mc_bases [ i ] diff building ;
60806: LD_ADDR_VAR 0 6
60810: PUSH
60811: LD_EXP 113
60815: PUSH
60816: LD_VAR 0 5
60820: ARRAY
60821: PUSH
60822: LD_VAR 0 1
60826: DIFF
60827: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
60828: LD_ADDR_EXP 113
60832: PUSH
60833: LD_EXP 113
60837: PPUSH
60838: LD_VAR 0 5
60842: PPUSH
60843: LD_VAR 0 6
60847: PPUSH
60848: CALL_OW 1
60852: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
60853: LD_VAR 0 1
60857: PUSH
60858: LD_EXP 121
60862: PUSH
60863: LD_VAR 0 5
60867: ARRAY
60868: IN
60869: IFFALSE 60908
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
60871: LD_ADDR_EXP 121
60875: PUSH
60876: LD_EXP 121
60880: PPUSH
60881: LD_VAR 0 5
60885: PPUSH
60886: LD_EXP 121
60890: PUSH
60891: LD_VAR 0 5
60895: ARRAY
60896: PUSH
60897: LD_VAR 0 1
60901: DIFF
60902: PPUSH
60903: CALL_OW 1
60907: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
60908: LD_VAR 0 1
60912: PUSH
60913: LD_EXP 122
60917: PUSH
60918: LD_VAR 0 5
60922: ARRAY
60923: IN
60924: IFFALSE 60963
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
60926: LD_ADDR_EXP 122
60930: PUSH
60931: LD_EXP 122
60935: PPUSH
60936: LD_VAR 0 5
60940: PPUSH
60941: LD_EXP 122
60945: PUSH
60946: LD_VAR 0 5
60950: ARRAY
60951: PUSH
60952: LD_VAR 0 1
60956: DIFF
60957: PPUSH
60958: CALL_OW 1
60962: ST_TO_ADDR
// break ;
60963: GO 60967
// end ;
60965: GO 60785
60967: POP
60968: POP
// end ;
60969: LD_VAR 0 4
60973: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
60974: LD_INT 0
60976: PPUSH
60977: PPUSH
60978: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
60979: LD_EXP 113
60983: NOT
60984: PUSH
60985: LD_EXP 111
60989: NOT
60990: OR
60991: PUSH
60992: LD_VAR 0 3
60996: PUSH
60997: LD_EXP 139
61001: IN
61002: NOT
61003: OR
61004: IFFALSE 61008
// exit ;
61006: GO 61131
// for i = 1 to mc_vehicles do
61008: LD_ADDR_VAR 0 6
61012: PUSH
61013: DOUBLE
61014: LD_INT 1
61016: DEC
61017: ST_TO_ADDR
61018: LD_EXP 132
61022: PUSH
61023: FOR_TO
61024: IFFALSE 61129
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
61026: LD_VAR 0 2
61030: PUSH
61031: LD_EXP 132
61035: PUSH
61036: LD_VAR 0 6
61040: ARRAY
61041: IN
61042: PUSH
61043: LD_VAR 0 1
61047: PUSH
61048: LD_EXP 132
61052: PUSH
61053: LD_VAR 0 6
61057: ARRAY
61058: IN
61059: OR
61060: IFFALSE 61127
// begin tmp := mc_vehicles [ i ] diff old ;
61062: LD_ADDR_VAR 0 7
61066: PUSH
61067: LD_EXP 132
61071: PUSH
61072: LD_VAR 0 6
61076: ARRAY
61077: PUSH
61078: LD_VAR 0 2
61082: DIFF
61083: ST_TO_ADDR
// tmp := tmp diff new ;
61084: LD_ADDR_VAR 0 7
61088: PUSH
61089: LD_VAR 0 7
61093: PUSH
61094: LD_VAR 0 1
61098: DIFF
61099: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
61100: LD_ADDR_EXP 132
61104: PUSH
61105: LD_EXP 132
61109: PPUSH
61110: LD_VAR 0 6
61114: PPUSH
61115: LD_VAR 0 7
61119: PPUSH
61120: CALL_OW 1
61124: ST_TO_ADDR
// break ;
61125: GO 61129
// end ;
61127: GO 61023
61129: POP
61130: POP
// end ;
61131: LD_VAR 0 5
61135: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
61136: LD_INT 0
61138: PPUSH
61139: PPUSH
61140: PPUSH
61141: PPUSH
// if not mc_bases or not skirmish then
61142: LD_EXP 113
61146: NOT
61147: PUSH
61148: LD_EXP 111
61152: NOT
61153: OR
61154: IFFALSE 61158
// exit ;
61156: GO 61541
// side := GetSide ( vehicle ) ;
61158: LD_ADDR_VAR 0 5
61162: PUSH
61163: LD_VAR 0 1
61167: PPUSH
61168: CALL_OW 255
61172: ST_TO_ADDR
// for i = 1 to mc_bases do
61173: LD_ADDR_VAR 0 4
61177: PUSH
61178: DOUBLE
61179: LD_INT 1
61181: DEC
61182: ST_TO_ADDR
61183: LD_EXP 113
61187: PUSH
61188: FOR_TO
61189: IFFALSE 61539
// begin if factory in mc_bases [ i ] then
61191: LD_VAR 0 2
61195: PUSH
61196: LD_EXP 113
61200: PUSH
61201: LD_VAR 0 4
61205: ARRAY
61206: IN
61207: IFFALSE 61537
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
61209: LD_EXP 135
61213: PUSH
61214: LD_VAR 0 4
61218: ARRAY
61219: PUSH
61220: LD_EXP 124
61224: PUSH
61225: LD_VAR 0 4
61229: ARRAY
61230: LESS
61231: PUSH
61232: LD_VAR 0 1
61236: PPUSH
61237: CALL_OW 264
61241: PUSH
61242: LD_INT 31
61244: PUSH
61245: LD_INT 32
61247: PUSH
61248: LD_INT 51
61250: PUSH
61251: LD_EXP 96
61255: PUSH
61256: LD_INT 12
61258: PUSH
61259: LD_INT 30
61261: PUSH
61262: LD_EXP 95
61266: PUSH
61267: LD_INT 11
61269: PUSH
61270: LD_INT 53
61272: PUSH
61273: LD_INT 14
61275: PUSH
61276: LD_EXP 99
61280: PUSH
61281: LD_INT 29
61283: PUSH
61284: LD_EXP 97
61288: PUSH
61289: LD_INT 13
61291: PUSH
61292: LD_INT 52
61294: PUSH
61295: LD_EXP 101
61299: PUSH
61300: LD_INT 48
61302: PUSH
61303: LD_INT 8
61305: PUSH
61306: EMPTY
61307: LIST
61308: LIST
61309: LIST
61310: LIST
61311: LIST
61312: LIST
61313: LIST
61314: LIST
61315: LIST
61316: LIST
61317: LIST
61318: LIST
61319: LIST
61320: LIST
61321: LIST
61322: LIST
61323: LIST
61324: LIST
61325: IN
61326: NOT
61327: AND
61328: IFFALSE 61376
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
61330: LD_ADDR_EXP 135
61334: PUSH
61335: LD_EXP 135
61339: PPUSH
61340: LD_VAR 0 4
61344: PUSH
61345: LD_EXP 135
61349: PUSH
61350: LD_VAR 0 4
61354: ARRAY
61355: PUSH
61356: LD_INT 1
61358: PLUS
61359: PUSH
61360: EMPTY
61361: LIST
61362: LIST
61363: PPUSH
61364: LD_VAR 0 1
61368: PPUSH
61369: CALL 70128 0 3
61373: ST_TO_ADDR
61374: GO 61420
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
61376: LD_ADDR_EXP 132
61380: PUSH
61381: LD_EXP 132
61385: PPUSH
61386: LD_VAR 0 4
61390: PUSH
61391: LD_EXP 132
61395: PUSH
61396: LD_VAR 0 4
61400: ARRAY
61401: PUSH
61402: LD_INT 1
61404: PLUS
61405: PUSH
61406: EMPTY
61407: LIST
61408: LIST
61409: PPUSH
61410: LD_VAR 0 1
61414: PPUSH
61415: CALL 70128 0 3
61419: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
61420: LD_VAR 0 1
61424: PPUSH
61425: CALL_OW 263
61429: PUSH
61430: LD_INT 2
61432: EQUAL
61433: IFFALSE 61453
// begin repeat wait ( 0 0$1 ) ;
61435: LD_INT 35
61437: PPUSH
61438: CALL_OW 67
// until IsControledBy ( vehicle ) ;
61442: LD_VAR 0 1
61446: PPUSH
61447: CALL_OW 312
61451: IFFALSE 61435
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
61453: LD_VAR 0 1
61457: PPUSH
61458: LD_EXP 137
61462: PUSH
61463: LD_VAR 0 4
61467: ARRAY
61468: PPUSH
61469: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
61473: LD_VAR 0 1
61477: PPUSH
61478: CALL_OW 263
61482: PUSH
61483: LD_INT 1
61485: NONEQUAL
61486: IFFALSE 61490
// break ;
61488: GO 61539
// repeat wait ( 0 0$1 ) ;
61490: LD_INT 35
61492: PPUSH
61493: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
61497: LD_VAR 0 1
61501: PPUSH
61502: LD_EXP 137
61506: PUSH
61507: LD_VAR 0 4
61511: ARRAY
61512: PPUSH
61513: CALL_OW 308
61517: IFFALSE 61490
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
61519: LD_VAR 0 1
61523: PPUSH
61524: CALL_OW 311
61528: PPUSH
61529: CALL_OW 121
// exit ;
61533: POP
61534: POP
61535: GO 61541
// end ; end ;
61537: GO 61188
61539: POP
61540: POP
// end ;
61541: LD_VAR 0 3
61545: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
61546: LD_INT 0
61548: PPUSH
61549: PPUSH
61550: PPUSH
61551: PPUSH
// if not mc_bases or not skirmish then
61552: LD_EXP 113
61556: NOT
61557: PUSH
61558: LD_EXP 111
61562: NOT
61563: OR
61564: IFFALSE 61568
// exit ;
61566: GO 61921
// repeat wait ( 0 0$1 ) ;
61568: LD_INT 35
61570: PPUSH
61571: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
61575: LD_VAR 0 2
61579: PPUSH
61580: LD_VAR 0 3
61584: PPUSH
61585: CALL_OW 284
61589: IFFALSE 61568
// if GetResourceTypeXY ( x , y ) = mat_artefact then
61591: LD_VAR 0 2
61595: PPUSH
61596: LD_VAR 0 3
61600: PPUSH
61601: CALL_OW 283
61605: PUSH
61606: LD_INT 4
61608: EQUAL
61609: IFFALSE 61613
// exit ;
61611: GO 61921
// for i = 1 to mc_bases do
61613: LD_ADDR_VAR 0 7
61617: PUSH
61618: DOUBLE
61619: LD_INT 1
61621: DEC
61622: ST_TO_ADDR
61623: LD_EXP 113
61627: PUSH
61628: FOR_TO
61629: IFFALSE 61919
// begin if mc_crates_area [ i ] then
61631: LD_EXP 131
61635: PUSH
61636: LD_VAR 0 7
61640: ARRAY
61641: IFFALSE 61752
// for j in mc_crates_area [ i ] do
61643: LD_ADDR_VAR 0 8
61647: PUSH
61648: LD_EXP 131
61652: PUSH
61653: LD_VAR 0 7
61657: ARRAY
61658: PUSH
61659: FOR_IN
61660: IFFALSE 61750
// if InArea ( x , y , j ) then
61662: LD_VAR 0 2
61666: PPUSH
61667: LD_VAR 0 3
61671: PPUSH
61672: LD_VAR 0 8
61676: PPUSH
61677: CALL_OW 309
61681: IFFALSE 61748
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61683: LD_ADDR_EXP 129
61687: PUSH
61688: LD_EXP 129
61692: PPUSH
61693: LD_VAR 0 7
61697: PUSH
61698: LD_EXP 129
61702: PUSH
61703: LD_VAR 0 7
61707: ARRAY
61708: PUSH
61709: LD_INT 1
61711: PLUS
61712: PUSH
61713: EMPTY
61714: LIST
61715: LIST
61716: PPUSH
61717: LD_VAR 0 4
61721: PUSH
61722: LD_VAR 0 2
61726: PUSH
61727: LD_VAR 0 3
61731: PUSH
61732: EMPTY
61733: LIST
61734: LIST
61735: LIST
61736: PPUSH
61737: CALL 70128 0 3
61741: ST_TO_ADDR
// exit ;
61742: POP
61743: POP
61744: POP
61745: POP
61746: GO 61921
// end ;
61748: GO 61659
61750: POP
61751: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61752: LD_ADDR_VAR 0 9
61756: PUSH
61757: LD_EXP 113
61761: PUSH
61762: LD_VAR 0 7
61766: ARRAY
61767: PPUSH
61768: LD_INT 2
61770: PUSH
61771: LD_INT 30
61773: PUSH
61774: LD_INT 0
61776: PUSH
61777: EMPTY
61778: LIST
61779: LIST
61780: PUSH
61781: LD_INT 30
61783: PUSH
61784: LD_INT 1
61786: PUSH
61787: EMPTY
61788: LIST
61789: LIST
61790: PUSH
61791: EMPTY
61792: LIST
61793: LIST
61794: LIST
61795: PPUSH
61796: CALL_OW 72
61800: ST_TO_ADDR
// if not depot then
61801: LD_VAR 0 9
61805: NOT
61806: IFFALSE 61810
// continue ;
61808: GO 61628
// for j in depot do
61810: LD_ADDR_VAR 0 8
61814: PUSH
61815: LD_VAR 0 9
61819: PUSH
61820: FOR_IN
61821: IFFALSE 61915
// if GetDistUnitXY ( j , x , y ) < 30 then
61823: LD_VAR 0 8
61827: PPUSH
61828: LD_VAR 0 2
61832: PPUSH
61833: LD_VAR 0 3
61837: PPUSH
61838: CALL_OW 297
61842: PUSH
61843: LD_INT 30
61845: LESS
61846: IFFALSE 61913
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61848: LD_ADDR_EXP 129
61852: PUSH
61853: LD_EXP 129
61857: PPUSH
61858: LD_VAR 0 7
61862: PUSH
61863: LD_EXP 129
61867: PUSH
61868: LD_VAR 0 7
61872: ARRAY
61873: PUSH
61874: LD_INT 1
61876: PLUS
61877: PUSH
61878: EMPTY
61879: LIST
61880: LIST
61881: PPUSH
61882: LD_VAR 0 4
61886: PUSH
61887: LD_VAR 0 2
61891: PUSH
61892: LD_VAR 0 3
61896: PUSH
61897: EMPTY
61898: LIST
61899: LIST
61900: LIST
61901: PPUSH
61902: CALL 70128 0 3
61906: ST_TO_ADDR
// exit ;
61907: POP
61908: POP
61909: POP
61910: POP
61911: GO 61921
// end ;
61913: GO 61820
61915: POP
61916: POP
// end ;
61917: GO 61628
61919: POP
61920: POP
// end ;
61921: LD_VAR 0 6
61925: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
61926: LD_INT 0
61928: PPUSH
61929: PPUSH
61930: PPUSH
61931: PPUSH
// if not mc_bases or not skirmish then
61932: LD_EXP 113
61936: NOT
61937: PUSH
61938: LD_EXP 111
61942: NOT
61943: OR
61944: IFFALSE 61948
// exit ;
61946: GO 62225
// side := GetSide ( lab ) ;
61948: LD_ADDR_VAR 0 4
61952: PUSH
61953: LD_VAR 0 2
61957: PPUSH
61958: CALL_OW 255
61962: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
61963: LD_VAR 0 4
61967: PUSH
61968: LD_EXP 139
61972: IN
61973: NOT
61974: PUSH
61975: LD_EXP 140
61979: NOT
61980: OR
61981: PUSH
61982: LD_EXP 113
61986: NOT
61987: OR
61988: IFFALSE 61992
// exit ;
61990: GO 62225
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
61992: LD_ADDR_EXP 140
61996: PUSH
61997: LD_EXP 140
62001: PPUSH
62002: LD_VAR 0 4
62006: PPUSH
62007: LD_EXP 140
62011: PUSH
62012: LD_VAR 0 4
62016: ARRAY
62017: PUSH
62018: LD_VAR 0 1
62022: DIFF
62023: PPUSH
62024: CALL_OW 1
62028: ST_TO_ADDR
// for i = 1 to mc_bases do
62029: LD_ADDR_VAR 0 5
62033: PUSH
62034: DOUBLE
62035: LD_INT 1
62037: DEC
62038: ST_TO_ADDR
62039: LD_EXP 113
62043: PUSH
62044: FOR_TO
62045: IFFALSE 62223
// begin if lab in mc_bases [ i ] then
62047: LD_VAR 0 2
62051: PUSH
62052: LD_EXP 113
62056: PUSH
62057: LD_VAR 0 5
62061: ARRAY
62062: IN
62063: IFFALSE 62221
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
62065: LD_VAR 0 1
62069: PUSH
62070: LD_INT 11
62072: PUSH
62073: LD_INT 4
62075: PUSH
62076: LD_INT 3
62078: PUSH
62079: LD_INT 2
62081: PUSH
62082: EMPTY
62083: LIST
62084: LIST
62085: LIST
62086: LIST
62087: IN
62088: PUSH
62089: LD_EXP 143
62093: PUSH
62094: LD_VAR 0 5
62098: ARRAY
62099: AND
62100: IFFALSE 62221
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
62102: LD_ADDR_VAR 0 6
62106: PUSH
62107: LD_EXP 143
62111: PUSH
62112: LD_VAR 0 5
62116: ARRAY
62117: PUSH
62118: LD_INT 1
62120: ARRAY
62121: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62122: LD_ADDR_EXP 143
62126: PUSH
62127: LD_EXP 143
62131: PPUSH
62132: LD_VAR 0 5
62136: PPUSH
62137: EMPTY
62138: PPUSH
62139: CALL_OW 1
62143: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
62144: LD_VAR 0 6
62148: PPUSH
62149: LD_INT 0
62151: PPUSH
62152: CALL_OW 109
// ComExitBuilding ( tmp ) ;
62156: LD_VAR 0 6
62160: PPUSH
62161: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
62165: LD_ADDR_EXP 142
62169: PUSH
62170: LD_EXP 142
62174: PPUSH
62175: LD_VAR 0 5
62179: PPUSH
62180: LD_EXP 142
62184: PUSH
62185: LD_VAR 0 5
62189: ARRAY
62190: PPUSH
62191: LD_INT 1
62193: PPUSH
62194: LD_VAR 0 6
62198: PPUSH
62199: CALL_OW 2
62203: PPUSH
62204: CALL_OW 1
62208: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
62209: LD_VAR 0 5
62213: PPUSH
62214: LD_INT 112
62216: PPUSH
62217: CALL 39192 0 2
// end ; end ; end ;
62221: GO 62044
62223: POP
62224: POP
// end ;
62225: LD_VAR 0 3
62229: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
62230: LD_INT 0
62232: PPUSH
62233: PPUSH
62234: PPUSH
62235: PPUSH
62236: PPUSH
62237: PPUSH
62238: PPUSH
62239: PPUSH
// if not mc_bases or not skirmish then
62240: LD_EXP 113
62244: NOT
62245: PUSH
62246: LD_EXP 111
62250: NOT
62251: OR
62252: IFFALSE 62256
// exit ;
62254: GO 63627
// for i = 1 to mc_bases do
62256: LD_ADDR_VAR 0 3
62260: PUSH
62261: DOUBLE
62262: LD_INT 1
62264: DEC
62265: ST_TO_ADDR
62266: LD_EXP 113
62270: PUSH
62271: FOR_TO
62272: IFFALSE 63625
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
62274: LD_VAR 0 1
62278: PUSH
62279: LD_EXP 113
62283: PUSH
62284: LD_VAR 0 3
62288: ARRAY
62289: IN
62290: PUSH
62291: LD_VAR 0 1
62295: PUSH
62296: LD_EXP 120
62300: PUSH
62301: LD_VAR 0 3
62305: ARRAY
62306: IN
62307: OR
62308: PUSH
62309: LD_VAR 0 1
62313: PUSH
62314: LD_EXP 135
62318: PUSH
62319: LD_VAR 0 3
62323: ARRAY
62324: IN
62325: OR
62326: PUSH
62327: LD_VAR 0 1
62331: PUSH
62332: LD_EXP 132
62336: PUSH
62337: LD_VAR 0 3
62341: ARRAY
62342: IN
62343: OR
62344: PUSH
62345: LD_VAR 0 1
62349: PUSH
62350: LD_EXP 142
62354: PUSH
62355: LD_VAR 0 3
62359: ARRAY
62360: IN
62361: OR
62362: PUSH
62363: LD_VAR 0 1
62367: PUSH
62368: LD_EXP 143
62372: PUSH
62373: LD_VAR 0 3
62377: ARRAY
62378: IN
62379: OR
62380: IFFALSE 63623
// begin if un in mc_ape [ i ] then
62382: LD_VAR 0 1
62386: PUSH
62387: LD_EXP 142
62391: PUSH
62392: LD_VAR 0 3
62396: ARRAY
62397: IN
62398: IFFALSE 62437
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
62400: LD_ADDR_EXP 142
62404: PUSH
62405: LD_EXP 142
62409: PPUSH
62410: LD_VAR 0 3
62414: PPUSH
62415: LD_EXP 142
62419: PUSH
62420: LD_VAR 0 3
62424: ARRAY
62425: PUSH
62426: LD_VAR 0 1
62430: DIFF
62431: PPUSH
62432: CALL_OW 1
62436: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
62437: LD_VAR 0 1
62441: PUSH
62442: LD_EXP 143
62446: PUSH
62447: LD_VAR 0 3
62451: ARRAY
62452: IN
62453: IFFALSE 62477
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62455: LD_ADDR_EXP 143
62459: PUSH
62460: LD_EXP 143
62464: PPUSH
62465: LD_VAR 0 3
62469: PPUSH
62470: EMPTY
62471: PPUSH
62472: CALL_OW 1
62476: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
62477: LD_VAR 0 1
62481: PPUSH
62482: CALL_OW 247
62486: PUSH
62487: LD_INT 2
62489: EQUAL
62490: PUSH
62491: LD_VAR 0 1
62495: PPUSH
62496: CALL_OW 110
62500: PUSH
62501: LD_INT 20
62503: EQUAL
62504: PUSH
62505: LD_VAR 0 1
62509: PUSH
62510: LD_EXP 135
62514: PUSH
62515: LD_VAR 0 3
62519: ARRAY
62520: IN
62521: OR
62522: PUSH
62523: LD_VAR 0 1
62527: PPUSH
62528: CALL_OW 264
62532: PUSH
62533: LD_INT 12
62535: PUSH
62536: LD_INT 51
62538: PUSH
62539: LD_EXP 96
62543: PUSH
62544: LD_INT 32
62546: PUSH
62547: LD_INT 13
62549: PUSH
62550: LD_INT 52
62552: PUSH
62553: LD_INT 31
62555: PUSH
62556: EMPTY
62557: LIST
62558: LIST
62559: LIST
62560: LIST
62561: LIST
62562: LIST
62563: LIST
62564: IN
62565: OR
62566: AND
62567: IFFALSE 62875
// begin if un in mc_defender [ i ] then
62569: LD_VAR 0 1
62573: PUSH
62574: LD_EXP 135
62578: PUSH
62579: LD_VAR 0 3
62583: ARRAY
62584: IN
62585: IFFALSE 62624
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62587: LD_ADDR_EXP 135
62591: PUSH
62592: LD_EXP 135
62596: PPUSH
62597: LD_VAR 0 3
62601: PPUSH
62602: LD_EXP 135
62606: PUSH
62607: LD_VAR 0 3
62611: ARRAY
62612: PUSH
62613: LD_VAR 0 1
62617: DIFF
62618: PPUSH
62619: CALL_OW 1
62623: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
62624: LD_ADDR_VAR 0 8
62628: PUSH
62629: LD_VAR 0 3
62633: PPUSH
62634: LD_INT 3
62636: PPUSH
62637: CALL 59274 0 2
62641: ST_TO_ADDR
// if fac then
62642: LD_VAR 0 8
62646: IFFALSE 62875
// begin for j in fac do
62648: LD_ADDR_VAR 0 4
62652: PUSH
62653: LD_VAR 0 8
62657: PUSH
62658: FOR_IN
62659: IFFALSE 62873
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
62661: LD_ADDR_VAR 0 9
62665: PUSH
62666: LD_VAR 0 8
62670: PPUSH
62671: LD_VAR 0 1
62675: PPUSH
62676: CALL_OW 265
62680: PPUSH
62681: LD_VAR 0 1
62685: PPUSH
62686: CALL_OW 262
62690: PPUSH
62691: LD_VAR 0 1
62695: PPUSH
62696: CALL_OW 263
62700: PPUSH
62701: LD_VAR 0 1
62705: PPUSH
62706: CALL_OW 264
62710: PPUSH
62711: CALL 67660 0 5
62715: ST_TO_ADDR
// if components then
62716: LD_VAR 0 9
62720: IFFALSE 62871
// begin if GetWeapon ( un ) = ar_control_tower then
62722: LD_VAR 0 1
62726: PPUSH
62727: CALL_OW 264
62731: PUSH
62732: LD_INT 31
62734: EQUAL
62735: IFFALSE 62852
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
62737: LD_VAR 0 1
62741: PPUSH
62742: CALL_OW 311
62746: PPUSH
62747: LD_INT 0
62749: PPUSH
62750: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
62754: LD_ADDR_EXP 153
62758: PUSH
62759: LD_EXP 153
62763: PPUSH
62764: LD_VAR 0 3
62768: PPUSH
62769: LD_EXP 153
62773: PUSH
62774: LD_VAR 0 3
62778: ARRAY
62779: PUSH
62780: LD_VAR 0 1
62784: PPUSH
62785: CALL_OW 311
62789: DIFF
62790: PPUSH
62791: CALL_OW 1
62795: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
62796: LD_ADDR_VAR 0 7
62800: PUSH
62801: LD_EXP 134
62805: PUSH
62806: LD_VAR 0 3
62810: ARRAY
62811: PPUSH
62812: LD_INT 1
62814: PPUSH
62815: LD_VAR 0 9
62819: PPUSH
62820: CALL_OW 2
62824: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62825: LD_ADDR_EXP 134
62829: PUSH
62830: LD_EXP 134
62834: PPUSH
62835: LD_VAR 0 3
62839: PPUSH
62840: LD_VAR 0 7
62844: PPUSH
62845: CALL_OW 1
62849: ST_TO_ADDR
// end else
62850: GO 62869
// MC_InsertProduceList ( i , [ components ] ) ;
62852: LD_VAR 0 3
62856: PPUSH
62857: LD_VAR 0 9
62861: PUSH
62862: EMPTY
62863: LIST
62864: PPUSH
62865: CALL 58819 0 2
// break ;
62869: GO 62873
// end ; end ;
62871: GO 62658
62873: POP
62874: POP
// end ; end ; if GetType ( un ) = unit_building then
62875: LD_VAR 0 1
62879: PPUSH
62880: CALL_OW 247
62884: PUSH
62885: LD_INT 3
62887: EQUAL
62888: IFFALSE 63291
// begin btype := GetBType ( un ) ;
62890: LD_ADDR_VAR 0 5
62894: PUSH
62895: LD_VAR 0 1
62899: PPUSH
62900: CALL_OW 266
62904: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
62905: LD_VAR 0 5
62909: PUSH
62910: LD_INT 29
62912: PUSH
62913: LD_INT 30
62915: PUSH
62916: EMPTY
62917: LIST
62918: LIST
62919: IN
62920: IFFALSE 62993
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
62922: LD_VAR 0 1
62926: PPUSH
62927: CALL_OW 250
62931: PPUSH
62932: LD_VAR 0 1
62936: PPUSH
62937: CALL_OW 251
62941: PPUSH
62942: LD_VAR 0 1
62946: PPUSH
62947: CALL_OW 255
62951: PPUSH
62952: CALL_OW 440
62956: NOT
62957: IFFALSE 62993
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
62959: LD_VAR 0 1
62963: PPUSH
62964: CALL_OW 250
62968: PPUSH
62969: LD_VAR 0 1
62973: PPUSH
62974: CALL_OW 251
62978: PPUSH
62979: LD_VAR 0 1
62983: PPUSH
62984: CALL_OW 255
62988: PPUSH
62989: CALL_OW 441
// end ; if btype = b_warehouse then
62993: LD_VAR 0 5
62997: PUSH
62998: LD_INT 1
63000: EQUAL
63001: IFFALSE 63019
// begin btype := b_depot ;
63003: LD_ADDR_VAR 0 5
63007: PUSH
63008: LD_INT 0
63010: ST_TO_ADDR
// pos := 1 ;
63011: LD_ADDR_VAR 0 6
63015: PUSH
63016: LD_INT 1
63018: ST_TO_ADDR
// end ; if btype = b_factory then
63019: LD_VAR 0 5
63023: PUSH
63024: LD_INT 3
63026: EQUAL
63027: IFFALSE 63045
// begin btype := b_workshop ;
63029: LD_ADDR_VAR 0 5
63033: PUSH
63034: LD_INT 2
63036: ST_TO_ADDR
// pos := 1 ;
63037: LD_ADDR_VAR 0 6
63041: PUSH
63042: LD_INT 1
63044: ST_TO_ADDR
// end ; if btype = b_barracks then
63045: LD_VAR 0 5
63049: PUSH
63050: LD_INT 5
63052: EQUAL
63053: IFFALSE 63063
// btype := b_armoury ;
63055: LD_ADDR_VAR 0 5
63059: PUSH
63060: LD_INT 4
63062: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
63063: LD_VAR 0 5
63067: PUSH
63068: LD_INT 7
63070: PUSH
63071: LD_INT 8
63073: PUSH
63074: EMPTY
63075: LIST
63076: LIST
63077: IN
63078: IFFALSE 63088
// btype := b_lab ;
63080: LD_ADDR_VAR 0 5
63084: PUSH
63085: LD_INT 6
63087: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
63088: LD_ADDR_EXP 118
63092: PUSH
63093: LD_EXP 118
63097: PPUSH
63098: LD_VAR 0 3
63102: PUSH
63103: LD_EXP 118
63107: PUSH
63108: LD_VAR 0 3
63112: ARRAY
63113: PUSH
63114: LD_INT 1
63116: PLUS
63117: PUSH
63118: EMPTY
63119: LIST
63120: LIST
63121: PPUSH
63122: LD_VAR 0 5
63126: PUSH
63127: LD_VAR 0 1
63131: PPUSH
63132: CALL_OW 250
63136: PUSH
63137: LD_VAR 0 1
63141: PPUSH
63142: CALL_OW 251
63146: PUSH
63147: LD_VAR 0 1
63151: PPUSH
63152: CALL_OW 254
63156: PUSH
63157: EMPTY
63158: LIST
63159: LIST
63160: LIST
63161: LIST
63162: PPUSH
63163: CALL 70128 0 3
63167: ST_TO_ADDR
// if pos = 1 then
63168: LD_VAR 0 6
63172: PUSH
63173: LD_INT 1
63175: EQUAL
63176: IFFALSE 63291
// begin tmp := mc_build_list [ i ] ;
63178: LD_ADDR_VAR 0 7
63182: PUSH
63183: LD_EXP 118
63187: PUSH
63188: LD_VAR 0 3
63192: ARRAY
63193: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
63194: LD_VAR 0 7
63198: PPUSH
63199: LD_INT 2
63201: PUSH
63202: LD_INT 30
63204: PUSH
63205: LD_INT 0
63207: PUSH
63208: EMPTY
63209: LIST
63210: LIST
63211: PUSH
63212: LD_INT 30
63214: PUSH
63215: LD_INT 1
63217: PUSH
63218: EMPTY
63219: LIST
63220: LIST
63221: PUSH
63222: EMPTY
63223: LIST
63224: LIST
63225: LIST
63226: PPUSH
63227: CALL_OW 72
63231: IFFALSE 63241
// pos := 2 ;
63233: LD_ADDR_VAR 0 6
63237: PUSH
63238: LD_INT 2
63240: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
63241: LD_ADDR_VAR 0 7
63245: PUSH
63246: LD_VAR 0 7
63250: PPUSH
63251: LD_VAR 0 6
63255: PPUSH
63256: LD_VAR 0 7
63260: PPUSH
63261: CALL 70454 0 3
63265: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
63266: LD_ADDR_EXP 118
63270: PUSH
63271: LD_EXP 118
63275: PPUSH
63276: LD_VAR 0 3
63280: PPUSH
63281: LD_VAR 0 7
63285: PPUSH
63286: CALL_OW 1
63290: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63291: LD_VAR 0 1
63295: PUSH
63296: LD_EXP 113
63300: PUSH
63301: LD_VAR 0 3
63305: ARRAY
63306: IN
63307: IFFALSE 63346
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
63309: LD_ADDR_EXP 113
63313: PUSH
63314: LD_EXP 113
63318: PPUSH
63319: LD_VAR 0 3
63323: PPUSH
63324: LD_EXP 113
63328: PUSH
63329: LD_VAR 0 3
63333: ARRAY
63334: PUSH
63335: LD_VAR 0 1
63339: DIFF
63340: PPUSH
63341: CALL_OW 1
63345: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
63346: LD_VAR 0 1
63350: PUSH
63351: LD_EXP 120
63355: PUSH
63356: LD_VAR 0 3
63360: ARRAY
63361: IN
63362: IFFALSE 63401
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
63364: LD_ADDR_EXP 120
63368: PUSH
63369: LD_EXP 120
63373: PPUSH
63374: LD_VAR 0 3
63378: PPUSH
63379: LD_EXP 120
63383: PUSH
63384: LD_VAR 0 3
63388: ARRAY
63389: PUSH
63390: LD_VAR 0 1
63394: DIFF
63395: PPUSH
63396: CALL_OW 1
63400: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
63401: LD_VAR 0 1
63405: PUSH
63406: LD_EXP 132
63410: PUSH
63411: LD_VAR 0 3
63415: ARRAY
63416: IN
63417: IFFALSE 63456
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
63419: LD_ADDR_EXP 132
63423: PUSH
63424: LD_EXP 132
63428: PPUSH
63429: LD_VAR 0 3
63433: PPUSH
63434: LD_EXP 132
63438: PUSH
63439: LD_VAR 0 3
63443: ARRAY
63444: PUSH
63445: LD_VAR 0 1
63449: DIFF
63450: PPUSH
63451: CALL_OW 1
63455: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
63456: LD_VAR 0 1
63460: PUSH
63461: LD_EXP 135
63465: PUSH
63466: LD_VAR 0 3
63470: ARRAY
63471: IN
63472: IFFALSE 63511
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63474: LD_ADDR_EXP 135
63478: PUSH
63479: LD_EXP 135
63483: PPUSH
63484: LD_VAR 0 3
63488: PPUSH
63489: LD_EXP 135
63493: PUSH
63494: LD_VAR 0 3
63498: ARRAY
63499: PUSH
63500: LD_VAR 0 1
63504: DIFF
63505: PPUSH
63506: CALL_OW 1
63510: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
63511: LD_VAR 0 1
63515: PUSH
63516: LD_EXP 122
63520: PUSH
63521: LD_VAR 0 3
63525: ARRAY
63526: IN
63527: IFFALSE 63566
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
63529: LD_ADDR_EXP 122
63533: PUSH
63534: LD_EXP 122
63538: PPUSH
63539: LD_VAR 0 3
63543: PPUSH
63544: LD_EXP 122
63548: PUSH
63549: LD_VAR 0 3
63553: ARRAY
63554: PUSH
63555: LD_VAR 0 1
63559: DIFF
63560: PPUSH
63561: CALL_OW 1
63565: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
63566: LD_VAR 0 1
63570: PUSH
63571: LD_EXP 121
63575: PUSH
63576: LD_VAR 0 3
63580: ARRAY
63581: IN
63582: IFFALSE 63621
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
63584: LD_ADDR_EXP 121
63588: PUSH
63589: LD_EXP 121
63593: PPUSH
63594: LD_VAR 0 3
63598: PPUSH
63599: LD_EXP 121
63603: PUSH
63604: LD_VAR 0 3
63608: ARRAY
63609: PUSH
63610: LD_VAR 0 1
63614: DIFF
63615: PPUSH
63616: CALL_OW 1
63620: ST_TO_ADDR
// end ; break ;
63621: GO 63625
// end ;
63623: GO 62271
63625: POP
63626: POP
// end ;
63627: LD_VAR 0 2
63631: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
63632: LD_INT 0
63634: PPUSH
63635: PPUSH
63636: PPUSH
// if not mc_bases or not skirmish then
63637: LD_EXP 113
63641: NOT
63642: PUSH
63643: LD_EXP 111
63647: NOT
63648: OR
63649: IFFALSE 63653
// exit ;
63651: GO 63868
// for i = 1 to mc_bases do
63653: LD_ADDR_VAR 0 3
63657: PUSH
63658: DOUBLE
63659: LD_INT 1
63661: DEC
63662: ST_TO_ADDR
63663: LD_EXP 113
63667: PUSH
63668: FOR_TO
63669: IFFALSE 63866
// begin if building in mc_construct_list [ i ] then
63671: LD_VAR 0 1
63675: PUSH
63676: LD_EXP 120
63680: PUSH
63681: LD_VAR 0 3
63685: ARRAY
63686: IN
63687: IFFALSE 63864
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63689: LD_ADDR_EXP 120
63693: PUSH
63694: LD_EXP 120
63698: PPUSH
63699: LD_VAR 0 3
63703: PPUSH
63704: LD_EXP 120
63708: PUSH
63709: LD_VAR 0 3
63713: ARRAY
63714: PUSH
63715: LD_VAR 0 1
63719: DIFF
63720: PPUSH
63721: CALL_OW 1
63725: ST_TO_ADDR
// if building in mc_lab [ i ] then
63726: LD_VAR 0 1
63730: PUSH
63731: LD_EXP 146
63735: PUSH
63736: LD_VAR 0 3
63740: ARRAY
63741: IN
63742: IFFALSE 63797
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
63744: LD_ADDR_EXP 147
63748: PUSH
63749: LD_EXP 147
63753: PPUSH
63754: LD_VAR 0 3
63758: PPUSH
63759: LD_EXP 147
63763: PUSH
63764: LD_VAR 0 3
63768: ARRAY
63769: PPUSH
63770: LD_INT 1
63772: PPUSH
63773: LD_EXP 147
63777: PUSH
63778: LD_VAR 0 3
63782: ARRAY
63783: PPUSH
63784: LD_INT 0
63786: PPUSH
63787: CALL 69546 0 4
63791: PPUSH
63792: CALL_OW 1
63796: ST_TO_ADDR
// if not building in mc_bases [ i ] then
63797: LD_VAR 0 1
63801: PUSH
63802: LD_EXP 113
63806: PUSH
63807: LD_VAR 0 3
63811: ARRAY
63812: IN
63813: NOT
63814: IFFALSE 63860
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63816: LD_ADDR_EXP 113
63820: PUSH
63821: LD_EXP 113
63825: PPUSH
63826: LD_VAR 0 3
63830: PUSH
63831: LD_EXP 113
63835: PUSH
63836: LD_VAR 0 3
63840: ARRAY
63841: PUSH
63842: LD_INT 1
63844: PLUS
63845: PUSH
63846: EMPTY
63847: LIST
63848: LIST
63849: PPUSH
63850: LD_VAR 0 1
63854: PPUSH
63855: CALL 70128 0 3
63859: ST_TO_ADDR
// exit ;
63860: POP
63861: POP
63862: GO 63868
// end ; end ;
63864: GO 63668
63866: POP
63867: POP
// end ;
63868: LD_VAR 0 2
63872: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
63873: LD_INT 0
63875: PPUSH
63876: PPUSH
63877: PPUSH
63878: PPUSH
63879: PPUSH
63880: PPUSH
63881: PPUSH
// if not mc_bases or not skirmish then
63882: LD_EXP 113
63886: NOT
63887: PUSH
63888: LD_EXP 111
63892: NOT
63893: OR
63894: IFFALSE 63898
// exit ;
63896: GO 64559
// for i = 1 to mc_bases do
63898: LD_ADDR_VAR 0 3
63902: PUSH
63903: DOUBLE
63904: LD_INT 1
63906: DEC
63907: ST_TO_ADDR
63908: LD_EXP 113
63912: PUSH
63913: FOR_TO
63914: IFFALSE 64557
// begin if building in mc_construct_list [ i ] then
63916: LD_VAR 0 1
63920: PUSH
63921: LD_EXP 120
63925: PUSH
63926: LD_VAR 0 3
63930: ARRAY
63931: IN
63932: IFFALSE 64555
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63934: LD_ADDR_EXP 120
63938: PUSH
63939: LD_EXP 120
63943: PPUSH
63944: LD_VAR 0 3
63948: PPUSH
63949: LD_EXP 120
63953: PUSH
63954: LD_VAR 0 3
63958: ARRAY
63959: PUSH
63960: LD_VAR 0 1
63964: DIFF
63965: PPUSH
63966: CALL_OW 1
63970: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63971: LD_ADDR_EXP 113
63975: PUSH
63976: LD_EXP 113
63980: PPUSH
63981: LD_VAR 0 3
63985: PUSH
63986: LD_EXP 113
63990: PUSH
63991: LD_VAR 0 3
63995: ARRAY
63996: PUSH
63997: LD_INT 1
63999: PLUS
64000: PUSH
64001: EMPTY
64002: LIST
64003: LIST
64004: PPUSH
64005: LD_VAR 0 1
64009: PPUSH
64010: CALL 70128 0 3
64014: ST_TO_ADDR
// btype := GetBType ( building ) ;
64015: LD_ADDR_VAR 0 5
64019: PUSH
64020: LD_VAR 0 1
64024: PPUSH
64025: CALL_OW 266
64029: ST_TO_ADDR
// side := GetSide ( building ) ;
64030: LD_ADDR_VAR 0 8
64034: PUSH
64035: LD_VAR 0 1
64039: PPUSH
64040: CALL_OW 255
64044: ST_TO_ADDR
// if btype = b_lab then
64045: LD_VAR 0 5
64049: PUSH
64050: LD_INT 6
64052: EQUAL
64053: IFFALSE 64103
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
64055: LD_ADDR_EXP 146
64059: PUSH
64060: LD_EXP 146
64064: PPUSH
64065: LD_VAR 0 3
64069: PUSH
64070: LD_EXP 146
64074: PUSH
64075: LD_VAR 0 3
64079: ARRAY
64080: PUSH
64081: LD_INT 1
64083: PLUS
64084: PUSH
64085: EMPTY
64086: LIST
64087: LIST
64088: PPUSH
64089: LD_VAR 0 1
64093: PPUSH
64094: CALL 70128 0 3
64098: ST_TO_ADDR
// exit ;
64099: POP
64100: POP
64101: GO 64559
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
64103: LD_VAR 0 5
64107: PUSH
64108: LD_INT 0
64110: PUSH
64111: LD_INT 2
64113: PUSH
64114: LD_INT 4
64116: PUSH
64117: EMPTY
64118: LIST
64119: LIST
64120: LIST
64121: IN
64122: IFFALSE 64246
// begin if btype = b_armoury then
64124: LD_VAR 0 5
64128: PUSH
64129: LD_INT 4
64131: EQUAL
64132: IFFALSE 64142
// btype := b_barracks ;
64134: LD_ADDR_VAR 0 5
64138: PUSH
64139: LD_INT 5
64141: ST_TO_ADDR
// if btype = b_depot then
64142: LD_VAR 0 5
64146: PUSH
64147: LD_INT 0
64149: EQUAL
64150: IFFALSE 64160
// btype := b_warehouse ;
64152: LD_ADDR_VAR 0 5
64156: PUSH
64157: LD_INT 1
64159: ST_TO_ADDR
// if btype = b_workshop then
64160: LD_VAR 0 5
64164: PUSH
64165: LD_INT 2
64167: EQUAL
64168: IFFALSE 64178
// btype := b_factory ;
64170: LD_ADDR_VAR 0 5
64174: PUSH
64175: LD_INT 3
64177: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
64178: LD_VAR 0 5
64182: PPUSH
64183: LD_VAR 0 8
64187: PPUSH
64188: CALL_OW 323
64192: PUSH
64193: LD_INT 1
64195: EQUAL
64196: IFFALSE 64242
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
64198: LD_ADDR_EXP 145
64202: PUSH
64203: LD_EXP 145
64207: PPUSH
64208: LD_VAR 0 3
64212: PUSH
64213: LD_EXP 145
64217: PUSH
64218: LD_VAR 0 3
64222: ARRAY
64223: PUSH
64224: LD_INT 1
64226: PLUS
64227: PUSH
64228: EMPTY
64229: LIST
64230: LIST
64231: PPUSH
64232: LD_VAR 0 1
64236: PPUSH
64237: CALL 70128 0 3
64241: ST_TO_ADDR
// exit ;
64242: POP
64243: POP
64244: GO 64559
// end ; if btype in [ b_bunker , b_turret ] then
64246: LD_VAR 0 5
64250: PUSH
64251: LD_INT 32
64253: PUSH
64254: LD_INT 33
64256: PUSH
64257: EMPTY
64258: LIST
64259: LIST
64260: IN
64261: IFFALSE 64551
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
64263: LD_ADDR_EXP 121
64267: PUSH
64268: LD_EXP 121
64272: PPUSH
64273: LD_VAR 0 3
64277: PUSH
64278: LD_EXP 121
64282: PUSH
64283: LD_VAR 0 3
64287: ARRAY
64288: PUSH
64289: LD_INT 1
64291: PLUS
64292: PUSH
64293: EMPTY
64294: LIST
64295: LIST
64296: PPUSH
64297: LD_VAR 0 1
64301: PPUSH
64302: CALL 70128 0 3
64306: ST_TO_ADDR
// if btype = b_bunker then
64307: LD_VAR 0 5
64311: PUSH
64312: LD_INT 32
64314: EQUAL
64315: IFFALSE 64551
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64317: LD_ADDR_EXP 122
64321: PUSH
64322: LD_EXP 122
64326: PPUSH
64327: LD_VAR 0 3
64331: PUSH
64332: LD_EXP 122
64336: PUSH
64337: LD_VAR 0 3
64341: ARRAY
64342: PUSH
64343: LD_INT 1
64345: PLUS
64346: PUSH
64347: EMPTY
64348: LIST
64349: LIST
64350: PPUSH
64351: LD_VAR 0 1
64355: PPUSH
64356: CALL 70128 0 3
64360: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
64361: LD_ADDR_VAR 0 6
64365: PUSH
64366: LD_EXP 113
64370: PUSH
64371: LD_VAR 0 3
64375: ARRAY
64376: PPUSH
64377: LD_INT 25
64379: PUSH
64380: LD_INT 1
64382: PUSH
64383: EMPTY
64384: LIST
64385: LIST
64386: PUSH
64387: LD_INT 3
64389: PUSH
64390: LD_INT 54
64392: PUSH
64393: EMPTY
64394: LIST
64395: PUSH
64396: EMPTY
64397: LIST
64398: LIST
64399: PUSH
64400: EMPTY
64401: LIST
64402: LIST
64403: PPUSH
64404: CALL_OW 72
64408: ST_TO_ADDR
// if tmp then
64409: LD_VAR 0 6
64413: IFFALSE 64419
// exit ;
64415: POP
64416: POP
64417: GO 64559
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64419: LD_ADDR_VAR 0 6
64423: PUSH
64424: LD_EXP 113
64428: PUSH
64429: LD_VAR 0 3
64433: ARRAY
64434: PPUSH
64435: LD_INT 2
64437: PUSH
64438: LD_INT 30
64440: PUSH
64441: LD_INT 4
64443: PUSH
64444: EMPTY
64445: LIST
64446: LIST
64447: PUSH
64448: LD_INT 30
64450: PUSH
64451: LD_INT 5
64453: PUSH
64454: EMPTY
64455: LIST
64456: LIST
64457: PUSH
64458: EMPTY
64459: LIST
64460: LIST
64461: LIST
64462: PPUSH
64463: CALL_OW 72
64467: ST_TO_ADDR
// if not tmp then
64468: LD_VAR 0 6
64472: NOT
64473: IFFALSE 64479
// exit ;
64475: POP
64476: POP
64477: GO 64559
// for j in tmp do
64479: LD_ADDR_VAR 0 4
64483: PUSH
64484: LD_VAR 0 6
64488: PUSH
64489: FOR_IN
64490: IFFALSE 64549
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
64492: LD_ADDR_VAR 0 7
64496: PUSH
64497: LD_VAR 0 4
64501: PPUSH
64502: CALL_OW 313
64506: PPUSH
64507: LD_INT 25
64509: PUSH
64510: LD_INT 1
64512: PUSH
64513: EMPTY
64514: LIST
64515: LIST
64516: PPUSH
64517: CALL_OW 72
64521: ST_TO_ADDR
// if units then
64522: LD_VAR 0 7
64526: IFFALSE 64547
// begin ComExitBuilding ( units [ 1 ] ) ;
64528: LD_VAR 0 7
64532: PUSH
64533: LD_INT 1
64535: ARRAY
64536: PPUSH
64537: CALL_OW 122
// exit ;
64541: POP
64542: POP
64543: POP
64544: POP
64545: GO 64559
// end ; end ;
64547: GO 64489
64549: POP
64550: POP
// end ; end ; exit ;
64551: POP
64552: POP
64553: GO 64559
// end ; end ;
64555: GO 63913
64557: POP
64558: POP
// end ;
64559: LD_VAR 0 2
64563: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
64564: LD_INT 0
64566: PPUSH
64567: PPUSH
64568: PPUSH
64569: PPUSH
64570: PPUSH
64571: PPUSH
64572: PPUSH
// if not mc_bases or not skirmish then
64573: LD_EXP 113
64577: NOT
64578: PUSH
64579: LD_EXP 111
64583: NOT
64584: OR
64585: IFFALSE 64589
// exit ;
64587: GO 64820
// btype := GetBType ( building ) ;
64589: LD_ADDR_VAR 0 6
64593: PUSH
64594: LD_VAR 0 1
64598: PPUSH
64599: CALL_OW 266
64603: ST_TO_ADDR
// x := GetX ( building ) ;
64604: LD_ADDR_VAR 0 7
64608: PUSH
64609: LD_VAR 0 1
64613: PPUSH
64614: CALL_OW 250
64618: ST_TO_ADDR
// y := GetY ( building ) ;
64619: LD_ADDR_VAR 0 8
64623: PUSH
64624: LD_VAR 0 1
64628: PPUSH
64629: CALL_OW 251
64633: ST_TO_ADDR
// d := GetDir ( building ) ;
64634: LD_ADDR_VAR 0 9
64638: PUSH
64639: LD_VAR 0 1
64643: PPUSH
64644: CALL_OW 254
64648: ST_TO_ADDR
// for i = 1 to mc_bases do
64649: LD_ADDR_VAR 0 4
64653: PUSH
64654: DOUBLE
64655: LD_INT 1
64657: DEC
64658: ST_TO_ADDR
64659: LD_EXP 113
64663: PUSH
64664: FOR_TO
64665: IFFALSE 64818
// begin if not mc_build_list [ i ] then
64667: LD_EXP 118
64671: PUSH
64672: LD_VAR 0 4
64676: ARRAY
64677: NOT
64678: IFFALSE 64682
// continue ;
64680: GO 64664
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
64682: LD_VAR 0 6
64686: PUSH
64687: LD_VAR 0 7
64691: PUSH
64692: LD_VAR 0 8
64696: PUSH
64697: LD_VAR 0 9
64701: PUSH
64702: EMPTY
64703: LIST
64704: LIST
64705: LIST
64706: LIST
64707: PPUSH
64708: LD_EXP 118
64712: PUSH
64713: LD_VAR 0 4
64717: ARRAY
64718: PUSH
64719: LD_INT 1
64721: ARRAY
64722: PPUSH
64723: CALL 76297 0 2
64727: IFFALSE 64816
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
64729: LD_ADDR_EXP 118
64733: PUSH
64734: LD_EXP 118
64738: PPUSH
64739: LD_VAR 0 4
64743: PPUSH
64744: LD_EXP 118
64748: PUSH
64749: LD_VAR 0 4
64753: ARRAY
64754: PPUSH
64755: LD_INT 1
64757: PPUSH
64758: CALL_OW 3
64762: PPUSH
64763: CALL_OW 1
64767: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
64768: LD_ADDR_EXP 120
64772: PUSH
64773: LD_EXP 120
64777: PPUSH
64778: LD_VAR 0 4
64782: PUSH
64783: LD_EXP 120
64787: PUSH
64788: LD_VAR 0 4
64792: ARRAY
64793: PUSH
64794: LD_INT 1
64796: PLUS
64797: PUSH
64798: EMPTY
64799: LIST
64800: LIST
64801: PPUSH
64802: LD_VAR 0 1
64806: PPUSH
64807: CALL 70128 0 3
64811: ST_TO_ADDR
// exit ;
64812: POP
64813: POP
64814: GO 64820
// end ; end ;
64816: GO 64664
64818: POP
64819: POP
// end ;
64820: LD_VAR 0 3
64824: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
64825: LD_INT 0
64827: PPUSH
64828: PPUSH
64829: PPUSH
// if not mc_bases or not skirmish then
64830: LD_EXP 113
64834: NOT
64835: PUSH
64836: LD_EXP 111
64840: NOT
64841: OR
64842: IFFALSE 64846
// exit ;
64844: GO 65036
// for i = 1 to mc_bases do
64846: LD_ADDR_VAR 0 4
64850: PUSH
64851: DOUBLE
64852: LD_INT 1
64854: DEC
64855: ST_TO_ADDR
64856: LD_EXP 113
64860: PUSH
64861: FOR_TO
64862: IFFALSE 64949
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
64864: LD_VAR 0 1
64868: PUSH
64869: LD_EXP 121
64873: PUSH
64874: LD_VAR 0 4
64878: ARRAY
64879: IN
64880: PUSH
64881: LD_VAR 0 1
64885: PUSH
64886: LD_EXP 122
64890: PUSH
64891: LD_VAR 0 4
64895: ARRAY
64896: IN
64897: NOT
64898: AND
64899: IFFALSE 64947
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64901: LD_ADDR_EXP 122
64905: PUSH
64906: LD_EXP 122
64910: PPUSH
64911: LD_VAR 0 4
64915: PUSH
64916: LD_EXP 122
64920: PUSH
64921: LD_VAR 0 4
64925: ARRAY
64926: PUSH
64927: LD_INT 1
64929: PLUS
64930: PUSH
64931: EMPTY
64932: LIST
64933: LIST
64934: PPUSH
64935: LD_VAR 0 1
64939: PPUSH
64940: CALL 70128 0 3
64944: ST_TO_ADDR
// break ;
64945: GO 64949
// end ; end ;
64947: GO 64861
64949: POP
64950: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
64951: LD_VAR 0 1
64955: PPUSH
64956: CALL_OW 257
64960: PUSH
64961: LD_EXP 139
64965: IN
64966: PUSH
64967: LD_VAR 0 1
64971: PPUSH
64972: CALL_OW 266
64976: PUSH
64977: LD_INT 5
64979: EQUAL
64980: AND
64981: PUSH
64982: LD_VAR 0 2
64986: PPUSH
64987: CALL_OW 110
64991: PUSH
64992: LD_INT 18
64994: NONEQUAL
64995: AND
64996: IFFALSE 65036
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
64998: LD_VAR 0 2
65002: PPUSH
65003: CALL_OW 257
65007: PUSH
65008: LD_INT 5
65010: PUSH
65011: LD_INT 8
65013: PUSH
65014: LD_INT 9
65016: PUSH
65017: EMPTY
65018: LIST
65019: LIST
65020: LIST
65021: IN
65022: IFFALSE 65036
// SetClass ( unit , 1 ) ;
65024: LD_VAR 0 2
65028: PPUSH
65029: LD_INT 1
65031: PPUSH
65032: CALL_OW 336
// end ;
65036: LD_VAR 0 3
65040: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
65041: LD_INT 0
65043: PPUSH
65044: PPUSH
// if not mc_bases or not skirmish then
65045: LD_EXP 113
65049: NOT
65050: PUSH
65051: LD_EXP 111
65055: NOT
65056: OR
65057: IFFALSE 65061
// exit ;
65059: GO 65177
// if GetLives ( abandoned_vehicle ) > 250 then
65061: LD_VAR 0 2
65065: PPUSH
65066: CALL_OW 256
65070: PUSH
65071: LD_INT 250
65073: GREATER
65074: IFFALSE 65078
// exit ;
65076: GO 65177
// for i = 1 to mc_bases do
65078: LD_ADDR_VAR 0 6
65082: PUSH
65083: DOUBLE
65084: LD_INT 1
65086: DEC
65087: ST_TO_ADDR
65088: LD_EXP 113
65092: PUSH
65093: FOR_TO
65094: IFFALSE 65175
// begin if driver in mc_bases [ i ] then
65096: LD_VAR 0 1
65100: PUSH
65101: LD_EXP 113
65105: PUSH
65106: LD_VAR 0 6
65110: ARRAY
65111: IN
65112: IFFALSE 65173
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
65114: LD_VAR 0 1
65118: PPUSH
65119: LD_EXP 113
65123: PUSH
65124: LD_VAR 0 6
65128: ARRAY
65129: PPUSH
65130: LD_INT 2
65132: PUSH
65133: LD_INT 30
65135: PUSH
65136: LD_INT 0
65138: PUSH
65139: EMPTY
65140: LIST
65141: LIST
65142: PUSH
65143: LD_INT 30
65145: PUSH
65146: LD_INT 1
65148: PUSH
65149: EMPTY
65150: LIST
65151: LIST
65152: PUSH
65153: EMPTY
65154: LIST
65155: LIST
65156: LIST
65157: PPUSH
65158: CALL_OW 72
65162: PUSH
65163: LD_INT 1
65165: ARRAY
65166: PPUSH
65167: CALL 101994 0 2
// break ;
65171: GO 65175
// end ; end ;
65173: GO 65093
65175: POP
65176: POP
// end ; end_of_file
65177: LD_VAR 0 5
65181: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
65182: LD_INT 0
65184: PPUSH
65185: PPUSH
// if exist_mode then
65186: LD_VAR 0 2
65190: IFFALSE 65215
// unit := CreateCharacter ( prefix & ident ) else
65192: LD_ADDR_VAR 0 5
65196: PUSH
65197: LD_VAR 0 3
65201: PUSH
65202: LD_VAR 0 1
65206: STR
65207: PPUSH
65208: CALL_OW 34
65212: ST_TO_ADDR
65213: GO 65230
// unit := NewCharacter ( ident ) ;
65215: LD_ADDR_VAR 0 5
65219: PUSH
65220: LD_VAR 0 1
65224: PPUSH
65225: CALL_OW 25
65229: ST_TO_ADDR
// result := unit ;
65230: LD_ADDR_VAR 0 4
65234: PUSH
65235: LD_VAR 0 5
65239: ST_TO_ADDR
// end ;
65240: LD_VAR 0 4
65244: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
65245: LD_INT 0
65247: PPUSH
65248: PPUSH
// if not side or not nation then
65249: LD_VAR 0 1
65253: NOT
65254: PUSH
65255: LD_VAR 0 2
65259: NOT
65260: OR
65261: IFFALSE 65265
// exit ;
65263: GO 66029
// case nation of nation_american :
65265: LD_VAR 0 2
65269: PUSH
65270: LD_INT 1
65272: DOUBLE
65273: EQUAL
65274: IFTRUE 65278
65276: GO 65492
65278: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
65279: LD_ADDR_VAR 0 4
65283: PUSH
65284: LD_INT 35
65286: PUSH
65287: LD_INT 45
65289: PUSH
65290: LD_INT 46
65292: PUSH
65293: LD_INT 47
65295: PUSH
65296: LD_INT 82
65298: PUSH
65299: LD_INT 83
65301: PUSH
65302: LD_INT 84
65304: PUSH
65305: LD_INT 85
65307: PUSH
65308: LD_INT 86
65310: PUSH
65311: LD_INT 1
65313: PUSH
65314: LD_INT 2
65316: PUSH
65317: LD_INT 6
65319: PUSH
65320: LD_INT 15
65322: PUSH
65323: LD_INT 16
65325: PUSH
65326: LD_INT 7
65328: PUSH
65329: LD_INT 12
65331: PUSH
65332: LD_INT 13
65334: PUSH
65335: LD_INT 10
65337: PUSH
65338: LD_INT 14
65340: PUSH
65341: LD_INT 20
65343: PUSH
65344: LD_INT 21
65346: PUSH
65347: LD_INT 22
65349: PUSH
65350: LD_INT 25
65352: PUSH
65353: LD_INT 32
65355: PUSH
65356: LD_INT 27
65358: PUSH
65359: LD_INT 36
65361: PUSH
65362: LD_INT 69
65364: PUSH
65365: LD_INT 39
65367: PUSH
65368: LD_INT 34
65370: PUSH
65371: LD_INT 40
65373: PUSH
65374: LD_INT 48
65376: PUSH
65377: LD_INT 49
65379: PUSH
65380: LD_INT 50
65382: PUSH
65383: LD_INT 51
65385: PUSH
65386: LD_INT 52
65388: PUSH
65389: LD_INT 53
65391: PUSH
65392: LD_INT 54
65394: PUSH
65395: LD_INT 55
65397: PUSH
65398: LD_INT 56
65400: PUSH
65401: LD_INT 57
65403: PUSH
65404: LD_INT 58
65406: PUSH
65407: LD_INT 59
65409: PUSH
65410: LD_INT 60
65412: PUSH
65413: LD_INT 61
65415: PUSH
65416: LD_INT 62
65418: PUSH
65419: LD_INT 80
65421: PUSH
65422: LD_INT 82
65424: PUSH
65425: LD_INT 83
65427: PUSH
65428: LD_INT 84
65430: PUSH
65431: LD_INT 85
65433: PUSH
65434: LD_INT 86
65436: PUSH
65437: EMPTY
65438: LIST
65439: LIST
65440: LIST
65441: LIST
65442: LIST
65443: LIST
65444: LIST
65445: LIST
65446: LIST
65447: LIST
65448: LIST
65449: LIST
65450: LIST
65451: LIST
65452: LIST
65453: LIST
65454: LIST
65455: LIST
65456: LIST
65457: LIST
65458: LIST
65459: LIST
65460: LIST
65461: LIST
65462: LIST
65463: LIST
65464: LIST
65465: LIST
65466: LIST
65467: LIST
65468: LIST
65469: LIST
65470: LIST
65471: LIST
65472: LIST
65473: LIST
65474: LIST
65475: LIST
65476: LIST
65477: LIST
65478: LIST
65479: LIST
65480: LIST
65481: LIST
65482: LIST
65483: LIST
65484: LIST
65485: LIST
65486: LIST
65487: LIST
65488: LIST
65489: ST_TO_ADDR
65490: GO 65953
65492: LD_INT 2
65494: DOUBLE
65495: EQUAL
65496: IFTRUE 65500
65498: GO 65722
65500: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
65501: LD_ADDR_VAR 0 4
65505: PUSH
65506: LD_INT 35
65508: PUSH
65509: LD_INT 45
65511: PUSH
65512: LD_INT 46
65514: PUSH
65515: LD_INT 47
65517: PUSH
65518: LD_INT 82
65520: PUSH
65521: LD_INT 83
65523: PUSH
65524: LD_INT 84
65526: PUSH
65527: LD_INT 85
65529: PUSH
65530: LD_INT 87
65532: PUSH
65533: LD_INT 70
65535: PUSH
65536: LD_INT 1
65538: PUSH
65539: LD_INT 11
65541: PUSH
65542: LD_INT 3
65544: PUSH
65545: LD_INT 4
65547: PUSH
65548: LD_INT 5
65550: PUSH
65551: LD_INT 6
65553: PUSH
65554: LD_INT 15
65556: PUSH
65557: LD_INT 18
65559: PUSH
65560: LD_INT 7
65562: PUSH
65563: LD_INT 17
65565: PUSH
65566: LD_INT 8
65568: PUSH
65569: LD_INT 20
65571: PUSH
65572: LD_INT 21
65574: PUSH
65575: LD_INT 22
65577: PUSH
65578: LD_INT 72
65580: PUSH
65581: LD_INT 26
65583: PUSH
65584: LD_INT 69
65586: PUSH
65587: LD_INT 39
65589: PUSH
65590: LD_INT 40
65592: PUSH
65593: LD_INT 41
65595: PUSH
65596: LD_INT 42
65598: PUSH
65599: LD_INT 43
65601: PUSH
65602: LD_INT 48
65604: PUSH
65605: LD_INT 49
65607: PUSH
65608: LD_INT 50
65610: PUSH
65611: LD_INT 51
65613: PUSH
65614: LD_INT 52
65616: PUSH
65617: LD_INT 53
65619: PUSH
65620: LD_INT 54
65622: PUSH
65623: LD_INT 55
65625: PUSH
65626: LD_INT 56
65628: PUSH
65629: LD_INT 60
65631: PUSH
65632: LD_INT 61
65634: PUSH
65635: LD_INT 62
65637: PUSH
65638: LD_INT 66
65640: PUSH
65641: LD_INT 67
65643: PUSH
65644: LD_INT 68
65646: PUSH
65647: LD_INT 81
65649: PUSH
65650: LD_INT 82
65652: PUSH
65653: LD_INT 83
65655: PUSH
65656: LD_INT 84
65658: PUSH
65659: LD_INT 85
65661: PUSH
65662: LD_INT 87
65664: PUSH
65665: EMPTY
65666: LIST
65667: LIST
65668: LIST
65669: LIST
65670: LIST
65671: LIST
65672: LIST
65673: LIST
65674: LIST
65675: LIST
65676: LIST
65677: LIST
65678: LIST
65679: LIST
65680: LIST
65681: LIST
65682: LIST
65683: LIST
65684: LIST
65685: LIST
65686: LIST
65687: LIST
65688: LIST
65689: LIST
65690: LIST
65691: LIST
65692: LIST
65693: LIST
65694: LIST
65695: LIST
65696: LIST
65697: LIST
65698: LIST
65699: LIST
65700: LIST
65701: LIST
65702: LIST
65703: LIST
65704: LIST
65705: LIST
65706: LIST
65707: LIST
65708: LIST
65709: LIST
65710: LIST
65711: LIST
65712: LIST
65713: LIST
65714: LIST
65715: LIST
65716: LIST
65717: LIST
65718: LIST
65719: ST_TO_ADDR
65720: GO 65953
65722: LD_INT 3
65724: DOUBLE
65725: EQUAL
65726: IFTRUE 65730
65728: GO 65952
65730: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
65731: LD_ADDR_VAR 0 4
65735: PUSH
65736: LD_INT 46
65738: PUSH
65739: LD_INT 47
65741: PUSH
65742: LD_INT 1
65744: PUSH
65745: LD_INT 2
65747: PUSH
65748: LD_INT 82
65750: PUSH
65751: LD_INT 83
65753: PUSH
65754: LD_INT 84
65756: PUSH
65757: LD_INT 85
65759: PUSH
65760: LD_INT 86
65762: PUSH
65763: LD_INT 11
65765: PUSH
65766: LD_INT 9
65768: PUSH
65769: LD_INT 20
65771: PUSH
65772: LD_INT 19
65774: PUSH
65775: LD_INT 21
65777: PUSH
65778: LD_INT 24
65780: PUSH
65781: LD_INT 22
65783: PUSH
65784: LD_INT 25
65786: PUSH
65787: LD_INT 28
65789: PUSH
65790: LD_INT 29
65792: PUSH
65793: LD_INT 30
65795: PUSH
65796: LD_INT 31
65798: PUSH
65799: LD_INT 37
65801: PUSH
65802: LD_INT 38
65804: PUSH
65805: LD_INT 32
65807: PUSH
65808: LD_INT 27
65810: PUSH
65811: LD_INT 33
65813: PUSH
65814: LD_INT 69
65816: PUSH
65817: LD_INT 39
65819: PUSH
65820: LD_INT 34
65822: PUSH
65823: LD_INT 40
65825: PUSH
65826: LD_INT 71
65828: PUSH
65829: LD_INT 23
65831: PUSH
65832: LD_INT 44
65834: PUSH
65835: LD_INT 48
65837: PUSH
65838: LD_INT 49
65840: PUSH
65841: LD_INT 50
65843: PUSH
65844: LD_INT 51
65846: PUSH
65847: LD_INT 52
65849: PUSH
65850: LD_INT 53
65852: PUSH
65853: LD_INT 54
65855: PUSH
65856: LD_INT 55
65858: PUSH
65859: LD_INT 56
65861: PUSH
65862: LD_INT 57
65864: PUSH
65865: LD_INT 58
65867: PUSH
65868: LD_INT 59
65870: PUSH
65871: LD_INT 63
65873: PUSH
65874: LD_INT 64
65876: PUSH
65877: LD_INT 65
65879: PUSH
65880: LD_INT 82
65882: PUSH
65883: LD_INT 83
65885: PUSH
65886: LD_INT 84
65888: PUSH
65889: LD_INT 85
65891: PUSH
65892: LD_INT 86
65894: PUSH
65895: EMPTY
65896: LIST
65897: LIST
65898: LIST
65899: LIST
65900: LIST
65901: LIST
65902: LIST
65903: LIST
65904: LIST
65905: LIST
65906: LIST
65907: LIST
65908: LIST
65909: LIST
65910: LIST
65911: LIST
65912: LIST
65913: LIST
65914: LIST
65915: LIST
65916: LIST
65917: LIST
65918: LIST
65919: LIST
65920: LIST
65921: LIST
65922: LIST
65923: LIST
65924: LIST
65925: LIST
65926: LIST
65927: LIST
65928: LIST
65929: LIST
65930: LIST
65931: LIST
65932: LIST
65933: LIST
65934: LIST
65935: LIST
65936: LIST
65937: LIST
65938: LIST
65939: LIST
65940: LIST
65941: LIST
65942: LIST
65943: LIST
65944: LIST
65945: LIST
65946: LIST
65947: LIST
65948: LIST
65949: ST_TO_ADDR
65950: GO 65953
65952: POP
// if state > - 1 and state < 3 then
65953: LD_VAR 0 3
65957: PUSH
65958: LD_INT 1
65960: NEG
65961: GREATER
65962: PUSH
65963: LD_VAR 0 3
65967: PUSH
65968: LD_INT 3
65970: LESS
65971: AND
65972: IFFALSE 66029
// for i in result do
65974: LD_ADDR_VAR 0 5
65978: PUSH
65979: LD_VAR 0 4
65983: PUSH
65984: FOR_IN
65985: IFFALSE 66027
// if GetTech ( i , side ) <> state then
65987: LD_VAR 0 5
65991: PPUSH
65992: LD_VAR 0 1
65996: PPUSH
65997: CALL_OW 321
66001: PUSH
66002: LD_VAR 0 3
66006: NONEQUAL
66007: IFFALSE 66025
// result := result diff i ;
66009: LD_ADDR_VAR 0 4
66013: PUSH
66014: LD_VAR 0 4
66018: PUSH
66019: LD_VAR 0 5
66023: DIFF
66024: ST_TO_ADDR
66025: GO 65984
66027: POP
66028: POP
// end ;
66029: LD_VAR 0 4
66033: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
66034: LD_INT 0
66036: PPUSH
66037: PPUSH
66038: PPUSH
// result := true ;
66039: LD_ADDR_VAR 0 3
66043: PUSH
66044: LD_INT 1
66046: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
66047: LD_ADDR_VAR 0 5
66051: PUSH
66052: LD_VAR 0 2
66056: PPUSH
66057: CALL_OW 480
66061: ST_TO_ADDR
// if not tmp then
66062: LD_VAR 0 5
66066: NOT
66067: IFFALSE 66071
// exit ;
66069: GO 66120
// for i in tmp do
66071: LD_ADDR_VAR 0 4
66075: PUSH
66076: LD_VAR 0 5
66080: PUSH
66081: FOR_IN
66082: IFFALSE 66118
// if GetTech ( i , side ) <> state_researched then
66084: LD_VAR 0 4
66088: PPUSH
66089: LD_VAR 0 1
66093: PPUSH
66094: CALL_OW 321
66098: PUSH
66099: LD_INT 2
66101: NONEQUAL
66102: IFFALSE 66116
// begin result := false ;
66104: LD_ADDR_VAR 0 3
66108: PUSH
66109: LD_INT 0
66111: ST_TO_ADDR
// exit ;
66112: POP
66113: POP
66114: GO 66120
// end ;
66116: GO 66081
66118: POP
66119: POP
// end ;
66120: LD_VAR 0 3
66124: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
66125: LD_INT 0
66127: PPUSH
66128: PPUSH
66129: PPUSH
66130: PPUSH
66131: PPUSH
66132: PPUSH
66133: PPUSH
66134: PPUSH
66135: PPUSH
66136: PPUSH
66137: PPUSH
66138: PPUSH
66139: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
66140: LD_VAR 0 1
66144: NOT
66145: PUSH
66146: LD_VAR 0 1
66150: PPUSH
66151: CALL_OW 257
66155: PUSH
66156: LD_INT 9
66158: NONEQUAL
66159: OR
66160: IFFALSE 66164
// exit ;
66162: GO 66737
// side := GetSide ( unit ) ;
66164: LD_ADDR_VAR 0 9
66168: PUSH
66169: LD_VAR 0 1
66173: PPUSH
66174: CALL_OW 255
66178: ST_TO_ADDR
// tech_space := tech_spacanom ;
66179: LD_ADDR_VAR 0 12
66183: PUSH
66184: LD_INT 29
66186: ST_TO_ADDR
// tech_time := tech_taurad ;
66187: LD_ADDR_VAR 0 13
66191: PUSH
66192: LD_INT 28
66194: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
66195: LD_ADDR_VAR 0 11
66199: PUSH
66200: LD_VAR 0 1
66204: PPUSH
66205: CALL_OW 310
66209: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
66210: LD_VAR 0 11
66214: PPUSH
66215: CALL_OW 247
66219: PUSH
66220: LD_INT 2
66222: EQUAL
66223: IFFALSE 66227
// exit ;
66225: GO 66737
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66227: LD_ADDR_VAR 0 8
66231: PUSH
66232: LD_INT 81
66234: PUSH
66235: LD_VAR 0 9
66239: PUSH
66240: EMPTY
66241: LIST
66242: LIST
66243: PUSH
66244: LD_INT 3
66246: PUSH
66247: LD_INT 21
66249: PUSH
66250: LD_INT 3
66252: PUSH
66253: EMPTY
66254: LIST
66255: LIST
66256: PUSH
66257: EMPTY
66258: LIST
66259: LIST
66260: PUSH
66261: EMPTY
66262: LIST
66263: LIST
66264: PPUSH
66265: CALL_OW 69
66269: ST_TO_ADDR
// if not tmp then
66270: LD_VAR 0 8
66274: NOT
66275: IFFALSE 66279
// exit ;
66277: GO 66737
// if in_unit then
66279: LD_VAR 0 11
66283: IFFALSE 66307
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
66285: LD_ADDR_VAR 0 10
66289: PUSH
66290: LD_VAR 0 8
66294: PPUSH
66295: LD_VAR 0 11
66299: PPUSH
66300: CALL_OW 74
66304: ST_TO_ADDR
66305: GO 66327
// enemy := NearestUnitToUnit ( tmp , unit ) ;
66307: LD_ADDR_VAR 0 10
66311: PUSH
66312: LD_VAR 0 8
66316: PPUSH
66317: LD_VAR 0 1
66321: PPUSH
66322: CALL_OW 74
66326: ST_TO_ADDR
// if not enemy then
66327: LD_VAR 0 10
66331: NOT
66332: IFFALSE 66336
// exit ;
66334: GO 66737
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
66336: LD_VAR 0 11
66340: PUSH
66341: LD_VAR 0 11
66345: PPUSH
66346: LD_VAR 0 10
66350: PPUSH
66351: CALL_OW 296
66355: PUSH
66356: LD_INT 13
66358: GREATER
66359: AND
66360: PUSH
66361: LD_VAR 0 1
66365: PPUSH
66366: LD_VAR 0 10
66370: PPUSH
66371: CALL_OW 296
66375: PUSH
66376: LD_INT 12
66378: GREATER
66379: OR
66380: IFFALSE 66384
// exit ;
66382: GO 66737
// missile := [ 1 ] ;
66384: LD_ADDR_VAR 0 14
66388: PUSH
66389: LD_INT 1
66391: PUSH
66392: EMPTY
66393: LIST
66394: ST_TO_ADDR
// if Researched ( side , tech_space ) then
66395: LD_VAR 0 9
66399: PPUSH
66400: LD_VAR 0 12
66404: PPUSH
66405: CALL_OW 325
66409: IFFALSE 66438
// missile := Insert ( missile , missile + 1 , 2 ) ;
66411: LD_ADDR_VAR 0 14
66415: PUSH
66416: LD_VAR 0 14
66420: PPUSH
66421: LD_VAR 0 14
66425: PUSH
66426: LD_INT 1
66428: PLUS
66429: PPUSH
66430: LD_INT 2
66432: PPUSH
66433: CALL_OW 2
66437: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
66438: LD_VAR 0 9
66442: PPUSH
66443: LD_VAR 0 13
66447: PPUSH
66448: CALL_OW 325
66452: PUSH
66453: LD_VAR 0 10
66457: PPUSH
66458: CALL_OW 255
66462: PPUSH
66463: LD_VAR 0 13
66467: PPUSH
66468: CALL_OW 325
66472: NOT
66473: AND
66474: IFFALSE 66503
// missile := Insert ( missile , missile + 1 , 3 ) ;
66476: LD_ADDR_VAR 0 14
66480: PUSH
66481: LD_VAR 0 14
66485: PPUSH
66486: LD_VAR 0 14
66490: PUSH
66491: LD_INT 1
66493: PLUS
66494: PPUSH
66495: LD_INT 3
66497: PPUSH
66498: CALL_OW 2
66502: ST_TO_ADDR
// if missile < 2 then
66503: LD_VAR 0 14
66507: PUSH
66508: LD_INT 2
66510: LESS
66511: IFFALSE 66515
// exit ;
66513: GO 66737
// x := GetX ( enemy ) ;
66515: LD_ADDR_VAR 0 4
66519: PUSH
66520: LD_VAR 0 10
66524: PPUSH
66525: CALL_OW 250
66529: ST_TO_ADDR
// y := GetY ( enemy ) ;
66530: LD_ADDR_VAR 0 5
66534: PUSH
66535: LD_VAR 0 10
66539: PPUSH
66540: CALL_OW 251
66544: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
66545: LD_ADDR_VAR 0 6
66549: PUSH
66550: LD_VAR 0 4
66554: PUSH
66555: LD_INT 1
66557: NEG
66558: PPUSH
66559: LD_INT 1
66561: PPUSH
66562: CALL_OW 12
66566: PLUS
66567: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
66568: LD_ADDR_VAR 0 7
66572: PUSH
66573: LD_VAR 0 5
66577: PUSH
66578: LD_INT 1
66580: NEG
66581: PPUSH
66582: LD_INT 1
66584: PPUSH
66585: CALL_OW 12
66589: PLUS
66590: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66591: LD_VAR 0 6
66595: PPUSH
66596: LD_VAR 0 7
66600: PPUSH
66601: CALL_OW 488
66605: NOT
66606: IFFALSE 66628
// begin _x := x ;
66608: LD_ADDR_VAR 0 6
66612: PUSH
66613: LD_VAR 0 4
66617: ST_TO_ADDR
// _y := y ;
66618: LD_ADDR_VAR 0 7
66622: PUSH
66623: LD_VAR 0 5
66627: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
66628: LD_ADDR_VAR 0 3
66632: PUSH
66633: LD_INT 1
66635: PPUSH
66636: LD_VAR 0 14
66640: PPUSH
66641: CALL_OW 12
66645: ST_TO_ADDR
// case i of 1 :
66646: LD_VAR 0 3
66650: PUSH
66651: LD_INT 1
66653: DOUBLE
66654: EQUAL
66655: IFTRUE 66659
66657: GO 66676
66659: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
66660: LD_VAR 0 1
66664: PPUSH
66665: LD_VAR 0 10
66669: PPUSH
66670: CALL_OW 115
66674: GO 66737
66676: LD_INT 2
66678: DOUBLE
66679: EQUAL
66680: IFTRUE 66684
66682: GO 66706
66684: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
66685: LD_VAR 0 1
66689: PPUSH
66690: LD_VAR 0 6
66694: PPUSH
66695: LD_VAR 0 7
66699: PPUSH
66700: CALL_OW 153
66704: GO 66737
66706: LD_INT 3
66708: DOUBLE
66709: EQUAL
66710: IFTRUE 66714
66712: GO 66736
66714: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
66715: LD_VAR 0 1
66719: PPUSH
66720: LD_VAR 0 6
66724: PPUSH
66725: LD_VAR 0 7
66729: PPUSH
66730: CALL_OW 154
66734: GO 66737
66736: POP
// end ;
66737: LD_VAR 0 2
66741: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
66742: LD_INT 0
66744: PPUSH
66745: PPUSH
66746: PPUSH
66747: PPUSH
66748: PPUSH
66749: PPUSH
// if not unit or not building then
66750: LD_VAR 0 1
66754: NOT
66755: PUSH
66756: LD_VAR 0 2
66760: NOT
66761: OR
66762: IFFALSE 66766
// exit ;
66764: GO 66924
// x := GetX ( building ) ;
66766: LD_ADDR_VAR 0 5
66770: PUSH
66771: LD_VAR 0 2
66775: PPUSH
66776: CALL_OW 250
66780: ST_TO_ADDR
// y := GetY ( building ) ;
66781: LD_ADDR_VAR 0 6
66785: PUSH
66786: LD_VAR 0 2
66790: PPUSH
66791: CALL_OW 251
66795: ST_TO_ADDR
// for i = 0 to 5 do
66796: LD_ADDR_VAR 0 4
66800: PUSH
66801: DOUBLE
66802: LD_INT 0
66804: DEC
66805: ST_TO_ADDR
66806: LD_INT 5
66808: PUSH
66809: FOR_TO
66810: IFFALSE 66922
// begin _x := ShiftX ( x , i , 3 ) ;
66812: LD_ADDR_VAR 0 7
66816: PUSH
66817: LD_VAR 0 5
66821: PPUSH
66822: LD_VAR 0 4
66826: PPUSH
66827: LD_INT 3
66829: PPUSH
66830: CALL_OW 272
66834: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
66835: LD_ADDR_VAR 0 8
66839: PUSH
66840: LD_VAR 0 6
66844: PPUSH
66845: LD_VAR 0 4
66849: PPUSH
66850: LD_INT 3
66852: PPUSH
66853: CALL_OW 273
66857: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66858: LD_VAR 0 7
66862: PPUSH
66863: LD_VAR 0 8
66867: PPUSH
66868: CALL_OW 488
66872: NOT
66873: IFFALSE 66877
// continue ;
66875: GO 66809
// if HexInfo ( _x , _y ) = 0 then
66877: LD_VAR 0 7
66881: PPUSH
66882: LD_VAR 0 8
66886: PPUSH
66887: CALL_OW 428
66891: PUSH
66892: LD_INT 0
66894: EQUAL
66895: IFFALSE 66920
// begin ComMoveXY ( unit , _x , _y ) ;
66897: LD_VAR 0 1
66901: PPUSH
66902: LD_VAR 0 7
66906: PPUSH
66907: LD_VAR 0 8
66911: PPUSH
66912: CALL_OW 111
// exit ;
66916: POP
66917: POP
66918: GO 66924
// end ; end ;
66920: GO 66809
66922: POP
66923: POP
// end ;
66924: LD_VAR 0 3
66928: RET
// export function ScanBase ( side , base_area ) ; begin
66929: LD_INT 0
66931: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
66932: LD_ADDR_VAR 0 3
66936: PUSH
66937: LD_VAR 0 2
66941: PPUSH
66942: LD_INT 81
66944: PUSH
66945: LD_VAR 0 1
66949: PUSH
66950: EMPTY
66951: LIST
66952: LIST
66953: PPUSH
66954: CALL_OW 70
66958: ST_TO_ADDR
// end ;
66959: LD_VAR 0 3
66963: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
66964: LD_INT 0
66966: PPUSH
66967: PPUSH
66968: PPUSH
66969: PPUSH
// result := false ;
66970: LD_ADDR_VAR 0 2
66974: PUSH
66975: LD_INT 0
66977: ST_TO_ADDR
// side := GetSide ( unit ) ;
66978: LD_ADDR_VAR 0 3
66982: PUSH
66983: LD_VAR 0 1
66987: PPUSH
66988: CALL_OW 255
66992: ST_TO_ADDR
// nat := GetNation ( unit ) ;
66993: LD_ADDR_VAR 0 4
66997: PUSH
66998: LD_VAR 0 1
67002: PPUSH
67003: CALL_OW 248
67007: ST_TO_ADDR
// case nat of 1 :
67008: LD_VAR 0 4
67012: PUSH
67013: LD_INT 1
67015: DOUBLE
67016: EQUAL
67017: IFTRUE 67021
67019: GO 67032
67021: POP
// tech := tech_lassight ; 2 :
67022: LD_ADDR_VAR 0 5
67026: PUSH
67027: LD_INT 12
67029: ST_TO_ADDR
67030: GO 67071
67032: LD_INT 2
67034: DOUBLE
67035: EQUAL
67036: IFTRUE 67040
67038: GO 67051
67040: POP
// tech := tech_mortar ; 3 :
67041: LD_ADDR_VAR 0 5
67045: PUSH
67046: LD_INT 41
67048: ST_TO_ADDR
67049: GO 67071
67051: LD_INT 3
67053: DOUBLE
67054: EQUAL
67055: IFTRUE 67059
67057: GO 67070
67059: POP
// tech := tech_bazooka ; end ;
67060: LD_ADDR_VAR 0 5
67064: PUSH
67065: LD_INT 44
67067: ST_TO_ADDR
67068: GO 67071
67070: POP
// if Researched ( side , tech ) then
67071: LD_VAR 0 3
67075: PPUSH
67076: LD_VAR 0 5
67080: PPUSH
67081: CALL_OW 325
67085: IFFALSE 67112
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
67087: LD_ADDR_VAR 0 2
67091: PUSH
67092: LD_INT 5
67094: PUSH
67095: LD_INT 8
67097: PUSH
67098: LD_INT 9
67100: PUSH
67101: EMPTY
67102: LIST
67103: LIST
67104: LIST
67105: PUSH
67106: LD_VAR 0 4
67110: ARRAY
67111: ST_TO_ADDR
// end ;
67112: LD_VAR 0 2
67116: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
67117: LD_INT 0
67119: PPUSH
67120: PPUSH
67121: PPUSH
// if not mines then
67122: LD_VAR 0 2
67126: NOT
67127: IFFALSE 67131
// exit ;
67129: GO 67275
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67131: LD_ADDR_VAR 0 5
67135: PUSH
67136: LD_INT 81
67138: PUSH
67139: LD_VAR 0 1
67143: PUSH
67144: EMPTY
67145: LIST
67146: LIST
67147: PUSH
67148: LD_INT 3
67150: PUSH
67151: LD_INT 21
67153: PUSH
67154: LD_INT 3
67156: PUSH
67157: EMPTY
67158: LIST
67159: LIST
67160: PUSH
67161: EMPTY
67162: LIST
67163: LIST
67164: PUSH
67165: EMPTY
67166: LIST
67167: LIST
67168: PPUSH
67169: CALL_OW 69
67173: ST_TO_ADDR
// for i in mines do
67174: LD_ADDR_VAR 0 4
67178: PUSH
67179: LD_VAR 0 2
67183: PUSH
67184: FOR_IN
67185: IFFALSE 67273
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
67187: LD_VAR 0 4
67191: PUSH
67192: LD_INT 1
67194: ARRAY
67195: PPUSH
67196: LD_VAR 0 4
67200: PUSH
67201: LD_INT 2
67203: ARRAY
67204: PPUSH
67205: CALL_OW 458
67209: NOT
67210: IFFALSE 67214
// continue ;
67212: GO 67184
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
67214: LD_VAR 0 4
67218: PUSH
67219: LD_INT 1
67221: ARRAY
67222: PPUSH
67223: LD_VAR 0 4
67227: PUSH
67228: LD_INT 2
67230: ARRAY
67231: PPUSH
67232: CALL_OW 428
67236: PUSH
67237: LD_VAR 0 5
67241: IN
67242: IFFALSE 67271
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
67244: LD_VAR 0 4
67248: PUSH
67249: LD_INT 1
67251: ARRAY
67252: PPUSH
67253: LD_VAR 0 4
67257: PUSH
67258: LD_INT 2
67260: ARRAY
67261: PPUSH
67262: LD_VAR 0 1
67266: PPUSH
67267: CALL_OW 456
// end ;
67271: GO 67184
67273: POP
67274: POP
// end ;
67275: LD_VAR 0 3
67279: RET
// export function Count ( array ) ; var i ; begin
67280: LD_INT 0
67282: PPUSH
67283: PPUSH
// result := 0 ;
67284: LD_ADDR_VAR 0 2
67288: PUSH
67289: LD_INT 0
67291: ST_TO_ADDR
// for i in array do
67292: LD_ADDR_VAR 0 3
67296: PUSH
67297: LD_VAR 0 1
67301: PUSH
67302: FOR_IN
67303: IFFALSE 67327
// if i then
67305: LD_VAR 0 3
67309: IFFALSE 67325
// result := result + 1 ;
67311: LD_ADDR_VAR 0 2
67315: PUSH
67316: LD_VAR 0 2
67320: PUSH
67321: LD_INT 1
67323: PLUS
67324: ST_TO_ADDR
67325: GO 67302
67327: POP
67328: POP
// end ;
67329: LD_VAR 0 2
67333: RET
// export function IsEmpty ( building ) ; begin
67334: LD_INT 0
67336: PPUSH
// if not building then
67337: LD_VAR 0 1
67341: NOT
67342: IFFALSE 67346
// exit ;
67344: GO 67389
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
67346: LD_ADDR_VAR 0 2
67350: PUSH
67351: LD_VAR 0 1
67355: PUSH
67356: LD_INT 22
67358: PUSH
67359: LD_VAR 0 1
67363: PPUSH
67364: CALL_OW 255
67368: PUSH
67369: EMPTY
67370: LIST
67371: LIST
67372: PUSH
67373: LD_INT 58
67375: PUSH
67376: EMPTY
67377: LIST
67378: PUSH
67379: EMPTY
67380: LIST
67381: LIST
67382: PPUSH
67383: CALL_OW 69
67387: IN
67388: ST_TO_ADDR
// end ;
67389: LD_VAR 0 2
67393: RET
// export function IsNotFull ( building ) ; begin
67394: LD_INT 0
67396: PPUSH
// if not building then
67397: LD_VAR 0 1
67401: NOT
67402: IFFALSE 67406
// exit ;
67404: GO 67425
// result := UnitsInside ( building ) < 6 ;
67406: LD_ADDR_VAR 0 2
67410: PUSH
67411: LD_VAR 0 1
67415: PPUSH
67416: CALL_OW 313
67420: PUSH
67421: LD_INT 6
67423: LESS
67424: ST_TO_ADDR
// end ;
67425: LD_VAR 0 2
67429: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
67430: LD_INT 0
67432: PPUSH
67433: PPUSH
67434: PPUSH
67435: PPUSH
// tmp := [ ] ;
67436: LD_ADDR_VAR 0 3
67440: PUSH
67441: EMPTY
67442: ST_TO_ADDR
// list := [ ] ;
67443: LD_ADDR_VAR 0 5
67447: PUSH
67448: EMPTY
67449: ST_TO_ADDR
// for i = 16 to 25 do
67450: LD_ADDR_VAR 0 4
67454: PUSH
67455: DOUBLE
67456: LD_INT 16
67458: DEC
67459: ST_TO_ADDR
67460: LD_INT 25
67462: PUSH
67463: FOR_TO
67464: IFFALSE 67537
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
67466: LD_ADDR_VAR 0 3
67470: PUSH
67471: LD_VAR 0 3
67475: PUSH
67476: LD_INT 22
67478: PUSH
67479: LD_VAR 0 1
67483: PPUSH
67484: CALL_OW 255
67488: PUSH
67489: EMPTY
67490: LIST
67491: LIST
67492: PUSH
67493: LD_INT 91
67495: PUSH
67496: LD_VAR 0 1
67500: PUSH
67501: LD_INT 6
67503: PUSH
67504: EMPTY
67505: LIST
67506: LIST
67507: LIST
67508: PUSH
67509: LD_INT 30
67511: PUSH
67512: LD_VAR 0 4
67516: PUSH
67517: EMPTY
67518: LIST
67519: LIST
67520: PUSH
67521: EMPTY
67522: LIST
67523: LIST
67524: LIST
67525: PUSH
67526: EMPTY
67527: LIST
67528: PPUSH
67529: CALL_OW 69
67533: ADD
67534: ST_TO_ADDR
67535: GO 67463
67537: POP
67538: POP
// for i = 1 to tmp do
67539: LD_ADDR_VAR 0 4
67543: PUSH
67544: DOUBLE
67545: LD_INT 1
67547: DEC
67548: ST_TO_ADDR
67549: LD_VAR 0 3
67553: PUSH
67554: FOR_TO
67555: IFFALSE 67643
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
67557: LD_ADDR_VAR 0 5
67561: PUSH
67562: LD_VAR 0 5
67566: PUSH
67567: LD_VAR 0 3
67571: PUSH
67572: LD_VAR 0 4
67576: ARRAY
67577: PPUSH
67578: CALL_OW 266
67582: PUSH
67583: LD_VAR 0 3
67587: PUSH
67588: LD_VAR 0 4
67592: ARRAY
67593: PPUSH
67594: CALL_OW 250
67598: PUSH
67599: LD_VAR 0 3
67603: PUSH
67604: LD_VAR 0 4
67608: ARRAY
67609: PPUSH
67610: CALL_OW 251
67614: PUSH
67615: LD_VAR 0 3
67619: PUSH
67620: LD_VAR 0 4
67624: ARRAY
67625: PPUSH
67626: CALL_OW 254
67630: PUSH
67631: EMPTY
67632: LIST
67633: LIST
67634: LIST
67635: LIST
67636: PUSH
67637: EMPTY
67638: LIST
67639: ADD
67640: ST_TO_ADDR
67641: GO 67554
67643: POP
67644: POP
// result := list ;
67645: LD_ADDR_VAR 0 2
67649: PUSH
67650: LD_VAR 0 5
67654: ST_TO_ADDR
// end ;
67655: LD_VAR 0 2
67659: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
67660: LD_INT 0
67662: PPUSH
67663: PPUSH
67664: PPUSH
67665: PPUSH
67666: PPUSH
67667: PPUSH
67668: PPUSH
// if not factory then
67669: LD_VAR 0 1
67673: NOT
67674: IFFALSE 67678
// exit ;
67676: GO 68271
// if control = control_apeman then
67678: LD_VAR 0 4
67682: PUSH
67683: LD_INT 5
67685: EQUAL
67686: IFFALSE 67795
// begin tmp := UnitsInside ( factory ) ;
67688: LD_ADDR_VAR 0 8
67692: PUSH
67693: LD_VAR 0 1
67697: PPUSH
67698: CALL_OW 313
67702: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
67703: LD_VAR 0 8
67707: PPUSH
67708: LD_INT 25
67710: PUSH
67711: LD_INT 12
67713: PUSH
67714: EMPTY
67715: LIST
67716: LIST
67717: PPUSH
67718: CALL_OW 72
67722: NOT
67723: IFFALSE 67733
// control := control_manual ;
67725: LD_ADDR_VAR 0 4
67729: PUSH
67730: LD_INT 1
67732: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
67733: LD_ADDR_VAR 0 8
67737: PUSH
67738: LD_VAR 0 1
67742: PPUSH
67743: CALL 67430 0 1
67747: ST_TO_ADDR
// if tmp then
67748: LD_VAR 0 8
67752: IFFALSE 67795
// begin for i in tmp do
67754: LD_ADDR_VAR 0 7
67758: PUSH
67759: LD_VAR 0 8
67763: PUSH
67764: FOR_IN
67765: IFFALSE 67793
// if i [ 1 ] = b_ext_radio then
67767: LD_VAR 0 7
67771: PUSH
67772: LD_INT 1
67774: ARRAY
67775: PUSH
67776: LD_INT 22
67778: EQUAL
67779: IFFALSE 67791
// begin control := control_remote ;
67781: LD_ADDR_VAR 0 4
67785: PUSH
67786: LD_INT 2
67788: ST_TO_ADDR
// break ;
67789: GO 67793
// end ;
67791: GO 67764
67793: POP
67794: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
67795: LD_VAR 0 1
67799: PPUSH
67800: LD_VAR 0 2
67804: PPUSH
67805: LD_VAR 0 3
67809: PPUSH
67810: LD_VAR 0 4
67814: PPUSH
67815: LD_VAR 0 5
67819: PPUSH
67820: CALL_OW 448
67824: IFFALSE 67859
// begin result := [ chassis , engine , control , weapon ] ;
67826: LD_ADDR_VAR 0 6
67830: PUSH
67831: LD_VAR 0 2
67835: PUSH
67836: LD_VAR 0 3
67840: PUSH
67841: LD_VAR 0 4
67845: PUSH
67846: LD_VAR 0 5
67850: PUSH
67851: EMPTY
67852: LIST
67853: LIST
67854: LIST
67855: LIST
67856: ST_TO_ADDR
// exit ;
67857: GO 68271
// end ; _chassis := AvailableChassisList ( factory ) ;
67859: LD_ADDR_VAR 0 9
67863: PUSH
67864: LD_VAR 0 1
67868: PPUSH
67869: CALL_OW 475
67873: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
67874: LD_ADDR_VAR 0 11
67878: PUSH
67879: LD_VAR 0 1
67883: PPUSH
67884: CALL_OW 476
67888: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
67889: LD_ADDR_VAR 0 12
67893: PUSH
67894: LD_VAR 0 1
67898: PPUSH
67899: CALL_OW 477
67903: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
67904: LD_ADDR_VAR 0 10
67908: PUSH
67909: LD_VAR 0 1
67913: PPUSH
67914: CALL_OW 478
67918: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
67919: LD_VAR 0 9
67923: NOT
67924: PUSH
67925: LD_VAR 0 11
67929: NOT
67930: OR
67931: PUSH
67932: LD_VAR 0 12
67936: NOT
67937: OR
67938: PUSH
67939: LD_VAR 0 10
67943: NOT
67944: OR
67945: IFFALSE 67980
// begin result := [ chassis , engine , control , weapon ] ;
67947: LD_ADDR_VAR 0 6
67951: PUSH
67952: LD_VAR 0 2
67956: PUSH
67957: LD_VAR 0 3
67961: PUSH
67962: LD_VAR 0 4
67966: PUSH
67967: LD_VAR 0 5
67971: PUSH
67972: EMPTY
67973: LIST
67974: LIST
67975: LIST
67976: LIST
67977: ST_TO_ADDR
// exit ;
67978: GO 68271
// end ; if not chassis in _chassis then
67980: LD_VAR 0 2
67984: PUSH
67985: LD_VAR 0 9
67989: IN
67990: NOT
67991: IFFALSE 68017
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
67993: LD_ADDR_VAR 0 2
67997: PUSH
67998: LD_VAR 0 9
68002: PUSH
68003: LD_INT 1
68005: PPUSH
68006: LD_VAR 0 9
68010: PPUSH
68011: CALL_OW 12
68015: ARRAY
68016: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
68017: LD_VAR 0 2
68021: PPUSH
68022: LD_VAR 0 3
68026: PPUSH
68027: CALL 68276 0 2
68031: NOT
68032: IFFALSE 68091
// repeat engine := _engine [ 1 ] ;
68034: LD_ADDR_VAR 0 3
68038: PUSH
68039: LD_VAR 0 11
68043: PUSH
68044: LD_INT 1
68046: ARRAY
68047: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
68048: LD_ADDR_VAR 0 11
68052: PUSH
68053: LD_VAR 0 11
68057: PPUSH
68058: LD_INT 1
68060: PPUSH
68061: CALL_OW 3
68065: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
68066: LD_VAR 0 2
68070: PPUSH
68071: LD_VAR 0 3
68075: PPUSH
68076: CALL 68276 0 2
68080: PUSH
68081: LD_VAR 0 11
68085: PUSH
68086: EMPTY
68087: EQUAL
68088: OR
68089: IFFALSE 68034
// if not control in _control then
68091: LD_VAR 0 4
68095: PUSH
68096: LD_VAR 0 12
68100: IN
68101: NOT
68102: IFFALSE 68128
// control := _control [ rand ( 1 , _control ) ] ;
68104: LD_ADDR_VAR 0 4
68108: PUSH
68109: LD_VAR 0 12
68113: PUSH
68114: LD_INT 1
68116: PPUSH
68117: LD_VAR 0 12
68121: PPUSH
68122: CALL_OW 12
68126: ARRAY
68127: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
68128: LD_VAR 0 2
68132: PPUSH
68133: LD_VAR 0 5
68137: PPUSH
68138: CALL 68496 0 2
68142: NOT
68143: IFFALSE 68202
// repeat weapon := _weapon [ 1 ] ;
68145: LD_ADDR_VAR 0 5
68149: PUSH
68150: LD_VAR 0 10
68154: PUSH
68155: LD_INT 1
68157: ARRAY
68158: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
68159: LD_ADDR_VAR 0 10
68163: PUSH
68164: LD_VAR 0 10
68168: PPUSH
68169: LD_INT 1
68171: PPUSH
68172: CALL_OW 3
68176: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
68177: LD_VAR 0 2
68181: PPUSH
68182: LD_VAR 0 5
68186: PPUSH
68187: CALL 68496 0 2
68191: PUSH
68192: LD_VAR 0 10
68196: PUSH
68197: EMPTY
68198: EQUAL
68199: OR
68200: IFFALSE 68145
// result := [ ] ;
68202: LD_ADDR_VAR 0 6
68206: PUSH
68207: EMPTY
68208: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68209: LD_VAR 0 1
68213: PPUSH
68214: LD_VAR 0 2
68218: PPUSH
68219: LD_VAR 0 3
68223: PPUSH
68224: LD_VAR 0 4
68228: PPUSH
68229: LD_VAR 0 5
68233: PPUSH
68234: CALL_OW 448
68238: IFFALSE 68271
// result := [ chassis , engine , control , weapon ] ;
68240: LD_ADDR_VAR 0 6
68244: PUSH
68245: LD_VAR 0 2
68249: PUSH
68250: LD_VAR 0 3
68254: PUSH
68255: LD_VAR 0 4
68259: PUSH
68260: LD_VAR 0 5
68264: PUSH
68265: EMPTY
68266: LIST
68267: LIST
68268: LIST
68269: LIST
68270: ST_TO_ADDR
// end ;
68271: LD_VAR 0 6
68275: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
68276: LD_INT 0
68278: PPUSH
// if not chassis or not engine then
68279: LD_VAR 0 1
68283: NOT
68284: PUSH
68285: LD_VAR 0 2
68289: NOT
68290: OR
68291: IFFALSE 68295
// exit ;
68293: GO 68491
// case engine of engine_solar :
68295: LD_VAR 0 2
68299: PUSH
68300: LD_INT 2
68302: DOUBLE
68303: EQUAL
68304: IFTRUE 68308
68306: GO 68346
68308: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
68309: LD_ADDR_VAR 0 3
68313: PUSH
68314: LD_INT 11
68316: PUSH
68317: LD_INT 12
68319: PUSH
68320: LD_INT 13
68322: PUSH
68323: LD_INT 14
68325: PUSH
68326: LD_INT 1
68328: PUSH
68329: LD_INT 2
68331: PUSH
68332: LD_INT 3
68334: PUSH
68335: EMPTY
68336: LIST
68337: LIST
68338: LIST
68339: LIST
68340: LIST
68341: LIST
68342: LIST
68343: ST_TO_ADDR
68344: GO 68475
68346: LD_INT 1
68348: DOUBLE
68349: EQUAL
68350: IFTRUE 68354
68352: GO 68416
68354: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
68355: LD_ADDR_VAR 0 3
68359: PUSH
68360: LD_INT 11
68362: PUSH
68363: LD_INT 12
68365: PUSH
68366: LD_INT 13
68368: PUSH
68369: LD_INT 14
68371: PUSH
68372: LD_INT 1
68374: PUSH
68375: LD_INT 2
68377: PUSH
68378: LD_INT 3
68380: PUSH
68381: LD_INT 4
68383: PUSH
68384: LD_INT 5
68386: PUSH
68387: LD_INT 21
68389: PUSH
68390: LD_INT 23
68392: PUSH
68393: LD_INT 22
68395: PUSH
68396: LD_INT 24
68398: PUSH
68399: EMPTY
68400: LIST
68401: LIST
68402: LIST
68403: LIST
68404: LIST
68405: LIST
68406: LIST
68407: LIST
68408: LIST
68409: LIST
68410: LIST
68411: LIST
68412: LIST
68413: ST_TO_ADDR
68414: GO 68475
68416: LD_INT 3
68418: DOUBLE
68419: EQUAL
68420: IFTRUE 68424
68422: GO 68474
68424: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
68425: LD_ADDR_VAR 0 3
68429: PUSH
68430: LD_INT 13
68432: PUSH
68433: LD_INT 14
68435: PUSH
68436: LD_INT 2
68438: PUSH
68439: LD_INT 3
68441: PUSH
68442: LD_INT 4
68444: PUSH
68445: LD_INT 5
68447: PUSH
68448: LD_INT 21
68450: PUSH
68451: LD_INT 22
68453: PUSH
68454: LD_INT 23
68456: PUSH
68457: LD_INT 24
68459: PUSH
68460: EMPTY
68461: LIST
68462: LIST
68463: LIST
68464: LIST
68465: LIST
68466: LIST
68467: LIST
68468: LIST
68469: LIST
68470: LIST
68471: ST_TO_ADDR
68472: GO 68475
68474: POP
// result := ( chassis in result ) ;
68475: LD_ADDR_VAR 0 3
68479: PUSH
68480: LD_VAR 0 1
68484: PUSH
68485: LD_VAR 0 3
68489: IN
68490: ST_TO_ADDR
// end ;
68491: LD_VAR 0 3
68495: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
68496: LD_INT 0
68498: PPUSH
// if not chassis or not weapon then
68499: LD_VAR 0 1
68503: NOT
68504: PUSH
68505: LD_VAR 0 2
68509: NOT
68510: OR
68511: IFFALSE 68515
// exit ;
68513: GO 69541
// case weapon of us_machine_gun :
68515: LD_VAR 0 2
68519: PUSH
68520: LD_INT 2
68522: DOUBLE
68523: EQUAL
68524: IFTRUE 68528
68526: GO 68558
68528: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
68529: LD_ADDR_VAR 0 3
68533: PUSH
68534: LD_INT 1
68536: PUSH
68537: LD_INT 2
68539: PUSH
68540: LD_INT 3
68542: PUSH
68543: LD_INT 4
68545: PUSH
68546: LD_INT 5
68548: PUSH
68549: EMPTY
68550: LIST
68551: LIST
68552: LIST
68553: LIST
68554: LIST
68555: ST_TO_ADDR
68556: GO 69525
68558: LD_INT 3
68560: DOUBLE
68561: EQUAL
68562: IFTRUE 68566
68564: GO 68596
68566: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
68567: LD_ADDR_VAR 0 3
68571: PUSH
68572: LD_INT 1
68574: PUSH
68575: LD_INT 2
68577: PUSH
68578: LD_INT 3
68580: PUSH
68581: LD_INT 4
68583: PUSH
68584: LD_INT 5
68586: PUSH
68587: EMPTY
68588: LIST
68589: LIST
68590: LIST
68591: LIST
68592: LIST
68593: ST_TO_ADDR
68594: GO 69525
68596: LD_INT 11
68598: DOUBLE
68599: EQUAL
68600: IFTRUE 68604
68602: GO 68634
68604: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
68605: LD_ADDR_VAR 0 3
68609: PUSH
68610: LD_INT 1
68612: PUSH
68613: LD_INT 2
68615: PUSH
68616: LD_INT 3
68618: PUSH
68619: LD_INT 4
68621: PUSH
68622: LD_INT 5
68624: PUSH
68625: EMPTY
68626: LIST
68627: LIST
68628: LIST
68629: LIST
68630: LIST
68631: ST_TO_ADDR
68632: GO 69525
68634: LD_INT 4
68636: DOUBLE
68637: EQUAL
68638: IFTRUE 68642
68640: GO 68668
68642: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
68643: LD_ADDR_VAR 0 3
68647: PUSH
68648: LD_INT 2
68650: PUSH
68651: LD_INT 3
68653: PUSH
68654: LD_INT 4
68656: PUSH
68657: LD_INT 5
68659: PUSH
68660: EMPTY
68661: LIST
68662: LIST
68663: LIST
68664: LIST
68665: ST_TO_ADDR
68666: GO 69525
68668: LD_INT 5
68670: DOUBLE
68671: EQUAL
68672: IFTRUE 68676
68674: GO 68702
68676: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
68677: LD_ADDR_VAR 0 3
68681: PUSH
68682: LD_INT 2
68684: PUSH
68685: LD_INT 3
68687: PUSH
68688: LD_INT 4
68690: PUSH
68691: LD_INT 5
68693: PUSH
68694: EMPTY
68695: LIST
68696: LIST
68697: LIST
68698: LIST
68699: ST_TO_ADDR
68700: GO 69525
68702: LD_INT 9
68704: DOUBLE
68705: EQUAL
68706: IFTRUE 68710
68708: GO 68736
68710: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
68711: LD_ADDR_VAR 0 3
68715: PUSH
68716: LD_INT 2
68718: PUSH
68719: LD_INT 3
68721: PUSH
68722: LD_INT 4
68724: PUSH
68725: LD_INT 5
68727: PUSH
68728: EMPTY
68729: LIST
68730: LIST
68731: LIST
68732: LIST
68733: ST_TO_ADDR
68734: GO 69525
68736: LD_INT 7
68738: DOUBLE
68739: EQUAL
68740: IFTRUE 68744
68742: GO 68770
68744: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
68745: LD_ADDR_VAR 0 3
68749: PUSH
68750: LD_INT 2
68752: PUSH
68753: LD_INT 3
68755: PUSH
68756: LD_INT 4
68758: PUSH
68759: LD_INT 5
68761: PUSH
68762: EMPTY
68763: LIST
68764: LIST
68765: LIST
68766: LIST
68767: ST_TO_ADDR
68768: GO 69525
68770: LD_INT 12
68772: DOUBLE
68773: EQUAL
68774: IFTRUE 68778
68776: GO 68804
68778: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
68779: LD_ADDR_VAR 0 3
68783: PUSH
68784: LD_INT 2
68786: PUSH
68787: LD_INT 3
68789: PUSH
68790: LD_INT 4
68792: PUSH
68793: LD_INT 5
68795: PUSH
68796: EMPTY
68797: LIST
68798: LIST
68799: LIST
68800: LIST
68801: ST_TO_ADDR
68802: GO 69525
68804: LD_INT 13
68806: DOUBLE
68807: EQUAL
68808: IFTRUE 68812
68810: GO 68838
68812: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
68813: LD_ADDR_VAR 0 3
68817: PUSH
68818: LD_INT 2
68820: PUSH
68821: LD_INT 3
68823: PUSH
68824: LD_INT 4
68826: PUSH
68827: LD_INT 5
68829: PUSH
68830: EMPTY
68831: LIST
68832: LIST
68833: LIST
68834: LIST
68835: ST_TO_ADDR
68836: GO 69525
68838: LD_INT 14
68840: DOUBLE
68841: EQUAL
68842: IFTRUE 68846
68844: GO 68864
68846: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
68847: LD_ADDR_VAR 0 3
68851: PUSH
68852: LD_INT 4
68854: PUSH
68855: LD_INT 5
68857: PUSH
68858: EMPTY
68859: LIST
68860: LIST
68861: ST_TO_ADDR
68862: GO 69525
68864: LD_INT 6
68866: DOUBLE
68867: EQUAL
68868: IFTRUE 68872
68870: GO 68890
68872: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
68873: LD_ADDR_VAR 0 3
68877: PUSH
68878: LD_INT 4
68880: PUSH
68881: LD_INT 5
68883: PUSH
68884: EMPTY
68885: LIST
68886: LIST
68887: ST_TO_ADDR
68888: GO 69525
68890: LD_INT 10
68892: DOUBLE
68893: EQUAL
68894: IFTRUE 68898
68896: GO 68916
68898: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
68899: LD_ADDR_VAR 0 3
68903: PUSH
68904: LD_INT 4
68906: PUSH
68907: LD_INT 5
68909: PUSH
68910: EMPTY
68911: LIST
68912: LIST
68913: ST_TO_ADDR
68914: GO 69525
68916: LD_INT 22
68918: DOUBLE
68919: EQUAL
68920: IFTRUE 68924
68922: GO 68950
68924: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
68925: LD_ADDR_VAR 0 3
68929: PUSH
68930: LD_INT 11
68932: PUSH
68933: LD_INT 12
68935: PUSH
68936: LD_INT 13
68938: PUSH
68939: LD_INT 14
68941: PUSH
68942: EMPTY
68943: LIST
68944: LIST
68945: LIST
68946: LIST
68947: ST_TO_ADDR
68948: GO 69525
68950: LD_INT 23
68952: DOUBLE
68953: EQUAL
68954: IFTRUE 68958
68956: GO 68984
68958: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
68959: LD_ADDR_VAR 0 3
68963: PUSH
68964: LD_INT 11
68966: PUSH
68967: LD_INT 12
68969: PUSH
68970: LD_INT 13
68972: PUSH
68973: LD_INT 14
68975: PUSH
68976: EMPTY
68977: LIST
68978: LIST
68979: LIST
68980: LIST
68981: ST_TO_ADDR
68982: GO 69525
68984: LD_INT 24
68986: DOUBLE
68987: EQUAL
68988: IFTRUE 68992
68990: GO 69018
68992: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
68993: LD_ADDR_VAR 0 3
68997: PUSH
68998: LD_INT 11
69000: PUSH
69001: LD_INT 12
69003: PUSH
69004: LD_INT 13
69006: PUSH
69007: LD_INT 14
69009: PUSH
69010: EMPTY
69011: LIST
69012: LIST
69013: LIST
69014: LIST
69015: ST_TO_ADDR
69016: GO 69525
69018: LD_INT 30
69020: DOUBLE
69021: EQUAL
69022: IFTRUE 69026
69024: GO 69052
69026: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
69027: LD_ADDR_VAR 0 3
69031: PUSH
69032: LD_INT 11
69034: PUSH
69035: LD_INT 12
69037: PUSH
69038: LD_INT 13
69040: PUSH
69041: LD_INT 14
69043: PUSH
69044: EMPTY
69045: LIST
69046: LIST
69047: LIST
69048: LIST
69049: ST_TO_ADDR
69050: GO 69525
69052: LD_INT 25
69054: DOUBLE
69055: EQUAL
69056: IFTRUE 69060
69058: GO 69078
69060: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
69061: LD_ADDR_VAR 0 3
69065: PUSH
69066: LD_INT 13
69068: PUSH
69069: LD_INT 14
69071: PUSH
69072: EMPTY
69073: LIST
69074: LIST
69075: ST_TO_ADDR
69076: GO 69525
69078: LD_INT 27
69080: DOUBLE
69081: EQUAL
69082: IFTRUE 69086
69084: GO 69104
69086: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
69087: LD_ADDR_VAR 0 3
69091: PUSH
69092: LD_INT 13
69094: PUSH
69095: LD_INT 14
69097: PUSH
69098: EMPTY
69099: LIST
69100: LIST
69101: ST_TO_ADDR
69102: GO 69525
69104: LD_INT 28
69106: DOUBLE
69107: EQUAL
69108: IFTRUE 69112
69110: GO 69130
69112: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
69113: LD_ADDR_VAR 0 3
69117: PUSH
69118: LD_INT 13
69120: PUSH
69121: LD_INT 14
69123: PUSH
69124: EMPTY
69125: LIST
69126: LIST
69127: ST_TO_ADDR
69128: GO 69525
69130: LD_INT 29
69132: DOUBLE
69133: EQUAL
69134: IFTRUE 69138
69136: GO 69156
69138: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
69139: LD_ADDR_VAR 0 3
69143: PUSH
69144: LD_INT 13
69146: PUSH
69147: LD_INT 14
69149: PUSH
69150: EMPTY
69151: LIST
69152: LIST
69153: ST_TO_ADDR
69154: GO 69525
69156: LD_INT 31
69158: DOUBLE
69159: EQUAL
69160: IFTRUE 69164
69162: GO 69182
69164: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
69165: LD_ADDR_VAR 0 3
69169: PUSH
69170: LD_INT 13
69172: PUSH
69173: LD_INT 14
69175: PUSH
69176: EMPTY
69177: LIST
69178: LIST
69179: ST_TO_ADDR
69180: GO 69525
69182: LD_INT 26
69184: DOUBLE
69185: EQUAL
69186: IFTRUE 69190
69188: GO 69208
69190: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
69191: LD_ADDR_VAR 0 3
69195: PUSH
69196: LD_INT 13
69198: PUSH
69199: LD_INT 14
69201: PUSH
69202: EMPTY
69203: LIST
69204: LIST
69205: ST_TO_ADDR
69206: GO 69525
69208: LD_INT 42
69210: DOUBLE
69211: EQUAL
69212: IFTRUE 69216
69214: GO 69242
69216: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
69217: LD_ADDR_VAR 0 3
69221: PUSH
69222: LD_INT 21
69224: PUSH
69225: LD_INT 22
69227: PUSH
69228: LD_INT 23
69230: PUSH
69231: LD_INT 24
69233: PUSH
69234: EMPTY
69235: LIST
69236: LIST
69237: LIST
69238: LIST
69239: ST_TO_ADDR
69240: GO 69525
69242: LD_INT 43
69244: DOUBLE
69245: EQUAL
69246: IFTRUE 69250
69248: GO 69276
69250: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
69251: LD_ADDR_VAR 0 3
69255: PUSH
69256: LD_INT 21
69258: PUSH
69259: LD_INT 22
69261: PUSH
69262: LD_INT 23
69264: PUSH
69265: LD_INT 24
69267: PUSH
69268: EMPTY
69269: LIST
69270: LIST
69271: LIST
69272: LIST
69273: ST_TO_ADDR
69274: GO 69525
69276: LD_INT 44
69278: DOUBLE
69279: EQUAL
69280: IFTRUE 69284
69282: GO 69310
69284: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
69285: LD_ADDR_VAR 0 3
69289: PUSH
69290: LD_INT 21
69292: PUSH
69293: LD_INT 22
69295: PUSH
69296: LD_INT 23
69298: PUSH
69299: LD_INT 24
69301: PUSH
69302: EMPTY
69303: LIST
69304: LIST
69305: LIST
69306: LIST
69307: ST_TO_ADDR
69308: GO 69525
69310: LD_INT 45
69312: DOUBLE
69313: EQUAL
69314: IFTRUE 69318
69316: GO 69344
69318: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
69319: LD_ADDR_VAR 0 3
69323: PUSH
69324: LD_INT 21
69326: PUSH
69327: LD_INT 22
69329: PUSH
69330: LD_INT 23
69332: PUSH
69333: LD_INT 24
69335: PUSH
69336: EMPTY
69337: LIST
69338: LIST
69339: LIST
69340: LIST
69341: ST_TO_ADDR
69342: GO 69525
69344: LD_INT 49
69346: DOUBLE
69347: EQUAL
69348: IFTRUE 69352
69350: GO 69378
69352: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
69353: LD_ADDR_VAR 0 3
69357: PUSH
69358: LD_INT 21
69360: PUSH
69361: LD_INT 22
69363: PUSH
69364: LD_INT 23
69366: PUSH
69367: LD_INT 24
69369: PUSH
69370: EMPTY
69371: LIST
69372: LIST
69373: LIST
69374: LIST
69375: ST_TO_ADDR
69376: GO 69525
69378: LD_INT 51
69380: DOUBLE
69381: EQUAL
69382: IFTRUE 69386
69384: GO 69412
69386: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
69387: LD_ADDR_VAR 0 3
69391: PUSH
69392: LD_INT 21
69394: PUSH
69395: LD_INT 22
69397: PUSH
69398: LD_INT 23
69400: PUSH
69401: LD_INT 24
69403: PUSH
69404: EMPTY
69405: LIST
69406: LIST
69407: LIST
69408: LIST
69409: ST_TO_ADDR
69410: GO 69525
69412: LD_INT 52
69414: DOUBLE
69415: EQUAL
69416: IFTRUE 69420
69418: GO 69446
69420: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
69421: LD_ADDR_VAR 0 3
69425: PUSH
69426: LD_INT 21
69428: PUSH
69429: LD_INT 22
69431: PUSH
69432: LD_INT 23
69434: PUSH
69435: LD_INT 24
69437: PUSH
69438: EMPTY
69439: LIST
69440: LIST
69441: LIST
69442: LIST
69443: ST_TO_ADDR
69444: GO 69525
69446: LD_INT 53
69448: DOUBLE
69449: EQUAL
69450: IFTRUE 69454
69452: GO 69472
69454: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
69455: LD_ADDR_VAR 0 3
69459: PUSH
69460: LD_INT 23
69462: PUSH
69463: LD_INT 24
69465: PUSH
69466: EMPTY
69467: LIST
69468: LIST
69469: ST_TO_ADDR
69470: GO 69525
69472: LD_INT 46
69474: DOUBLE
69475: EQUAL
69476: IFTRUE 69480
69478: GO 69498
69480: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
69481: LD_ADDR_VAR 0 3
69485: PUSH
69486: LD_INT 23
69488: PUSH
69489: LD_INT 24
69491: PUSH
69492: EMPTY
69493: LIST
69494: LIST
69495: ST_TO_ADDR
69496: GO 69525
69498: LD_INT 47
69500: DOUBLE
69501: EQUAL
69502: IFTRUE 69506
69504: GO 69524
69506: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69507: LD_ADDR_VAR 0 3
69511: PUSH
69512: LD_INT 23
69514: PUSH
69515: LD_INT 24
69517: PUSH
69518: EMPTY
69519: LIST
69520: LIST
69521: ST_TO_ADDR
69522: GO 69525
69524: POP
// result := ( chassis in result ) ;
69525: LD_ADDR_VAR 0 3
69529: PUSH
69530: LD_VAR 0 1
69534: PUSH
69535: LD_VAR 0 3
69539: IN
69540: ST_TO_ADDR
// end ;
69541: LD_VAR 0 3
69545: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
69546: LD_INT 0
69548: PPUSH
69549: PPUSH
69550: PPUSH
69551: PPUSH
69552: PPUSH
69553: PPUSH
69554: PPUSH
// result := array ;
69555: LD_ADDR_VAR 0 5
69559: PUSH
69560: LD_VAR 0 1
69564: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
69565: LD_VAR 0 1
69569: NOT
69570: PUSH
69571: LD_VAR 0 2
69575: NOT
69576: OR
69577: PUSH
69578: LD_VAR 0 3
69582: NOT
69583: OR
69584: PUSH
69585: LD_VAR 0 2
69589: PUSH
69590: LD_VAR 0 1
69594: GREATER
69595: OR
69596: PUSH
69597: LD_VAR 0 3
69601: PUSH
69602: LD_VAR 0 1
69606: GREATER
69607: OR
69608: IFFALSE 69612
// exit ;
69610: GO 69908
// if direction then
69612: LD_VAR 0 4
69616: IFFALSE 69680
// begin d := 1 ;
69618: LD_ADDR_VAR 0 9
69622: PUSH
69623: LD_INT 1
69625: ST_TO_ADDR
// if i_from > i_to then
69626: LD_VAR 0 2
69630: PUSH
69631: LD_VAR 0 3
69635: GREATER
69636: IFFALSE 69662
// length := ( array - i_from ) + i_to else
69638: LD_ADDR_VAR 0 11
69642: PUSH
69643: LD_VAR 0 1
69647: PUSH
69648: LD_VAR 0 2
69652: MINUS
69653: PUSH
69654: LD_VAR 0 3
69658: PLUS
69659: ST_TO_ADDR
69660: GO 69678
// length := i_to - i_from ;
69662: LD_ADDR_VAR 0 11
69666: PUSH
69667: LD_VAR 0 3
69671: PUSH
69672: LD_VAR 0 2
69676: MINUS
69677: ST_TO_ADDR
// end else
69678: GO 69741
// begin d := - 1 ;
69680: LD_ADDR_VAR 0 9
69684: PUSH
69685: LD_INT 1
69687: NEG
69688: ST_TO_ADDR
// if i_from > i_to then
69689: LD_VAR 0 2
69693: PUSH
69694: LD_VAR 0 3
69698: GREATER
69699: IFFALSE 69719
// length := i_from - i_to else
69701: LD_ADDR_VAR 0 11
69705: PUSH
69706: LD_VAR 0 2
69710: PUSH
69711: LD_VAR 0 3
69715: MINUS
69716: ST_TO_ADDR
69717: GO 69741
// length := ( array - i_to ) + i_from ;
69719: LD_ADDR_VAR 0 11
69723: PUSH
69724: LD_VAR 0 1
69728: PUSH
69729: LD_VAR 0 3
69733: MINUS
69734: PUSH
69735: LD_VAR 0 2
69739: PLUS
69740: ST_TO_ADDR
// end ; if not length then
69741: LD_VAR 0 11
69745: NOT
69746: IFFALSE 69750
// exit ;
69748: GO 69908
// tmp := array ;
69750: LD_ADDR_VAR 0 10
69754: PUSH
69755: LD_VAR 0 1
69759: ST_TO_ADDR
// for i = 1 to length do
69760: LD_ADDR_VAR 0 6
69764: PUSH
69765: DOUBLE
69766: LD_INT 1
69768: DEC
69769: ST_TO_ADDR
69770: LD_VAR 0 11
69774: PUSH
69775: FOR_TO
69776: IFFALSE 69896
// begin for j = 1 to array do
69778: LD_ADDR_VAR 0 7
69782: PUSH
69783: DOUBLE
69784: LD_INT 1
69786: DEC
69787: ST_TO_ADDR
69788: LD_VAR 0 1
69792: PUSH
69793: FOR_TO
69794: IFFALSE 69882
// begin k := j + d ;
69796: LD_ADDR_VAR 0 8
69800: PUSH
69801: LD_VAR 0 7
69805: PUSH
69806: LD_VAR 0 9
69810: PLUS
69811: ST_TO_ADDR
// if k > array then
69812: LD_VAR 0 8
69816: PUSH
69817: LD_VAR 0 1
69821: GREATER
69822: IFFALSE 69832
// k := 1 ;
69824: LD_ADDR_VAR 0 8
69828: PUSH
69829: LD_INT 1
69831: ST_TO_ADDR
// if not k then
69832: LD_VAR 0 8
69836: NOT
69837: IFFALSE 69849
// k := array ;
69839: LD_ADDR_VAR 0 8
69843: PUSH
69844: LD_VAR 0 1
69848: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
69849: LD_ADDR_VAR 0 10
69853: PUSH
69854: LD_VAR 0 10
69858: PPUSH
69859: LD_VAR 0 8
69863: PPUSH
69864: LD_VAR 0 1
69868: PUSH
69869: LD_VAR 0 7
69873: ARRAY
69874: PPUSH
69875: CALL_OW 1
69879: ST_TO_ADDR
// end ;
69880: GO 69793
69882: POP
69883: POP
// array := tmp ;
69884: LD_ADDR_VAR 0 1
69888: PUSH
69889: LD_VAR 0 10
69893: ST_TO_ADDR
// end ;
69894: GO 69775
69896: POP
69897: POP
// result := array ;
69898: LD_ADDR_VAR 0 5
69902: PUSH
69903: LD_VAR 0 1
69907: ST_TO_ADDR
// end ;
69908: LD_VAR 0 5
69912: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
69913: LD_INT 0
69915: PPUSH
69916: PPUSH
// result := 0 ;
69917: LD_ADDR_VAR 0 3
69921: PUSH
69922: LD_INT 0
69924: ST_TO_ADDR
// if not array or not value in array then
69925: LD_VAR 0 1
69929: NOT
69930: PUSH
69931: LD_VAR 0 2
69935: PUSH
69936: LD_VAR 0 1
69940: IN
69941: NOT
69942: OR
69943: IFFALSE 69947
// exit ;
69945: GO 70001
// for i = 1 to array do
69947: LD_ADDR_VAR 0 4
69951: PUSH
69952: DOUBLE
69953: LD_INT 1
69955: DEC
69956: ST_TO_ADDR
69957: LD_VAR 0 1
69961: PUSH
69962: FOR_TO
69963: IFFALSE 69999
// if value = array [ i ] then
69965: LD_VAR 0 2
69969: PUSH
69970: LD_VAR 0 1
69974: PUSH
69975: LD_VAR 0 4
69979: ARRAY
69980: EQUAL
69981: IFFALSE 69997
// begin result := i ;
69983: LD_ADDR_VAR 0 3
69987: PUSH
69988: LD_VAR 0 4
69992: ST_TO_ADDR
// exit ;
69993: POP
69994: POP
69995: GO 70001
// end ;
69997: GO 69962
69999: POP
70000: POP
// end ;
70001: LD_VAR 0 3
70005: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
70006: LD_INT 0
70008: PPUSH
// vc_chassis := chassis ;
70009: LD_ADDR_OWVAR 37
70013: PUSH
70014: LD_VAR 0 1
70018: ST_TO_ADDR
// vc_engine := engine ;
70019: LD_ADDR_OWVAR 39
70023: PUSH
70024: LD_VAR 0 2
70028: ST_TO_ADDR
// vc_control := control ;
70029: LD_ADDR_OWVAR 38
70033: PUSH
70034: LD_VAR 0 3
70038: ST_TO_ADDR
// vc_weapon := weapon ;
70039: LD_ADDR_OWVAR 40
70043: PUSH
70044: LD_VAR 0 4
70048: ST_TO_ADDR
// vc_fuel_battery := fuel ;
70049: LD_ADDR_OWVAR 41
70053: PUSH
70054: LD_VAR 0 5
70058: ST_TO_ADDR
// end ;
70059: LD_VAR 0 6
70063: RET
// export function WantPlant ( unit ) ; var task ; begin
70064: LD_INT 0
70066: PPUSH
70067: PPUSH
// result := false ;
70068: LD_ADDR_VAR 0 2
70072: PUSH
70073: LD_INT 0
70075: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
70076: LD_ADDR_VAR 0 3
70080: PUSH
70081: LD_VAR 0 1
70085: PPUSH
70086: CALL_OW 437
70090: ST_TO_ADDR
// if task then
70091: LD_VAR 0 3
70095: IFFALSE 70123
// if task [ 1 ] [ 1 ] = p then
70097: LD_VAR 0 3
70101: PUSH
70102: LD_INT 1
70104: ARRAY
70105: PUSH
70106: LD_INT 1
70108: ARRAY
70109: PUSH
70110: LD_STRING p
70112: EQUAL
70113: IFFALSE 70123
// result := true ;
70115: LD_ADDR_VAR 0 2
70119: PUSH
70120: LD_INT 1
70122: ST_TO_ADDR
// end ;
70123: LD_VAR 0 2
70127: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
70128: LD_INT 0
70130: PPUSH
70131: PPUSH
70132: PPUSH
70133: PPUSH
// if pos < 1 then
70134: LD_VAR 0 2
70138: PUSH
70139: LD_INT 1
70141: LESS
70142: IFFALSE 70146
// exit ;
70144: GO 70449
// if pos = 1 then
70146: LD_VAR 0 2
70150: PUSH
70151: LD_INT 1
70153: EQUAL
70154: IFFALSE 70187
// result := Replace ( arr , pos [ 1 ] , value ) else
70156: LD_ADDR_VAR 0 4
70160: PUSH
70161: LD_VAR 0 1
70165: PPUSH
70166: LD_VAR 0 2
70170: PUSH
70171: LD_INT 1
70173: ARRAY
70174: PPUSH
70175: LD_VAR 0 3
70179: PPUSH
70180: CALL_OW 1
70184: ST_TO_ADDR
70185: GO 70449
// begin tmp := arr ;
70187: LD_ADDR_VAR 0 6
70191: PUSH
70192: LD_VAR 0 1
70196: ST_TO_ADDR
// s_arr := [ tmp ] ;
70197: LD_ADDR_VAR 0 7
70201: PUSH
70202: LD_VAR 0 6
70206: PUSH
70207: EMPTY
70208: LIST
70209: ST_TO_ADDR
// for i = 1 to pos - 1 do
70210: LD_ADDR_VAR 0 5
70214: PUSH
70215: DOUBLE
70216: LD_INT 1
70218: DEC
70219: ST_TO_ADDR
70220: LD_VAR 0 2
70224: PUSH
70225: LD_INT 1
70227: MINUS
70228: PUSH
70229: FOR_TO
70230: IFFALSE 70275
// begin tmp := tmp [ pos [ i ] ] ;
70232: LD_ADDR_VAR 0 6
70236: PUSH
70237: LD_VAR 0 6
70241: PUSH
70242: LD_VAR 0 2
70246: PUSH
70247: LD_VAR 0 5
70251: ARRAY
70252: ARRAY
70253: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
70254: LD_ADDR_VAR 0 7
70258: PUSH
70259: LD_VAR 0 7
70263: PUSH
70264: LD_VAR 0 6
70268: PUSH
70269: EMPTY
70270: LIST
70271: ADD
70272: ST_TO_ADDR
// end ;
70273: GO 70229
70275: POP
70276: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
70277: LD_ADDR_VAR 0 6
70281: PUSH
70282: LD_VAR 0 6
70286: PPUSH
70287: LD_VAR 0 2
70291: PUSH
70292: LD_VAR 0 2
70296: ARRAY
70297: PPUSH
70298: LD_VAR 0 3
70302: PPUSH
70303: CALL_OW 1
70307: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
70308: LD_ADDR_VAR 0 7
70312: PUSH
70313: LD_VAR 0 7
70317: PPUSH
70318: LD_VAR 0 7
70322: PPUSH
70323: LD_VAR 0 6
70327: PPUSH
70328: CALL_OW 1
70332: ST_TO_ADDR
// for i = s_arr downto 2 do
70333: LD_ADDR_VAR 0 5
70337: PUSH
70338: DOUBLE
70339: LD_VAR 0 7
70343: INC
70344: ST_TO_ADDR
70345: LD_INT 2
70347: PUSH
70348: FOR_DOWNTO
70349: IFFALSE 70433
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
70351: LD_ADDR_VAR 0 6
70355: PUSH
70356: LD_VAR 0 7
70360: PUSH
70361: LD_VAR 0 5
70365: PUSH
70366: LD_INT 1
70368: MINUS
70369: ARRAY
70370: PPUSH
70371: LD_VAR 0 2
70375: PUSH
70376: LD_VAR 0 5
70380: PUSH
70381: LD_INT 1
70383: MINUS
70384: ARRAY
70385: PPUSH
70386: LD_VAR 0 7
70390: PUSH
70391: LD_VAR 0 5
70395: ARRAY
70396: PPUSH
70397: CALL_OW 1
70401: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
70402: LD_ADDR_VAR 0 7
70406: PUSH
70407: LD_VAR 0 7
70411: PPUSH
70412: LD_VAR 0 5
70416: PUSH
70417: LD_INT 1
70419: MINUS
70420: PPUSH
70421: LD_VAR 0 6
70425: PPUSH
70426: CALL_OW 1
70430: ST_TO_ADDR
// end ;
70431: GO 70348
70433: POP
70434: POP
// result := s_arr [ 1 ] ;
70435: LD_ADDR_VAR 0 4
70439: PUSH
70440: LD_VAR 0 7
70444: PUSH
70445: LD_INT 1
70447: ARRAY
70448: ST_TO_ADDR
// end ; end ;
70449: LD_VAR 0 4
70453: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
70454: LD_INT 0
70456: PPUSH
70457: PPUSH
// if not list then
70458: LD_VAR 0 1
70462: NOT
70463: IFFALSE 70467
// exit ;
70465: GO 70558
// i := list [ pos1 ] ;
70467: LD_ADDR_VAR 0 5
70471: PUSH
70472: LD_VAR 0 1
70476: PUSH
70477: LD_VAR 0 2
70481: ARRAY
70482: ST_TO_ADDR
// if not i then
70483: LD_VAR 0 5
70487: NOT
70488: IFFALSE 70492
// exit ;
70490: GO 70558
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
70492: LD_ADDR_VAR 0 1
70496: PUSH
70497: LD_VAR 0 1
70501: PPUSH
70502: LD_VAR 0 2
70506: PPUSH
70507: LD_VAR 0 1
70511: PUSH
70512: LD_VAR 0 3
70516: ARRAY
70517: PPUSH
70518: CALL_OW 1
70522: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
70523: LD_ADDR_VAR 0 1
70527: PUSH
70528: LD_VAR 0 1
70532: PPUSH
70533: LD_VAR 0 3
70537: PPUSH
70538: LD_VAR 0 5
70542: PPUSH
70543: CALL_OW 1
70547: ST_TO_ADDR
// result := list ;
70548: LD_ADDR_VAR 0 4
70552: PUSH
70553: LD_VAR 0 1
70557: ST_TO_ADDR
// end ;
70558: LD_VAR 0 4
70562: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
70563: LD_INT 0
70565: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
70566: LD_ADDR_VAR 0 5
70570: PUSH
70571: LD_VAR 0 1
70575: PPUSH
70576: CALL_OW 250
70580: PPUSH
70581: LD_VAR 0 1
70585: PPUSH
70586: CALL_OW 251
70590: PPUSH
70591: LD_VAR 0 2
70595: PPUSH
70596: LD_VAR 0 3
70600: PPUSH
70601: LD_VAR 0 4
70605: PPUSH
70606: CALL 70616 0 5
70610: ST_TO_ADDR
// end ;
70611: LD_VAR 0 5
70615: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
70616: LD_INT 0
70618: PPUSH
70619: PPUSH
70620: PPUSH
70621: PPUSH
// if not list then
70622: LD_VAR 0 3
70626: NOT
70627: IFFALSE 70631
// exit ;
70629: GO 71019
// result := [ ] ;
70631: LD_ADDR_VAR 0 6
70635: PUSH
70636: EMPTY
70637: ST_TO_ADDR
// for i in list do
70638: LD_ADDR_VAR 0 7
70642: PUSH
70643: LD_VAR 0 3
70647: PUSH
70648: FOR_IN
70649: IFFALSE 70851
// begin tmp := GetDistUnitXY ( i , x , y ) ;
70651: LD_ADDR_VAR 0 9
70655: PUSH
70656: LD_VAR 0 7
70660: PPUSH
70661: LD_VAR 0 1
70665: PPUSH
70666: LD_VAR 0 2
70670: PPUSH
70671: CALL_OW 297
70675: ST_TO_ADDR
// if not result then
70676: LD_VAR 0 6
70680: NOT
70681: IFFALSE 70707
// result := [ [ i , tmp ] ] else
70683: LD_ADDR_VAR 0 6
70687: PUSH
70688: LD_VAR 0 7
70692: PUSH
70693: LD_VAR 0 9
70697: PUSH
70698: EMPTY
70699: LIST
70700: LIST
70701: PUSH
70702: EMPTY
70703: LIST
70704: ST_TO_ADDR
70705: GO 70849
// begin if result [ result ] [ 2 ] < tmp then
70707: LD_VAR 0 6
70711: PUSH
70712: LD_VAR 0 6
70716: ARRAY
70717: PUSH
70718: LD_INT 2
70720: ARRAY
70721: PUSH
70722: LD_VAR 0 9
70726: LESS
70727: IFFALSE 70769
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
70729: LD_ADDR_VAR 0 6
70733: PUSH
70734: LD_VAR 0 6
70738: PPUSH
70739: LD_VAR 0 6
70743: PUSH
70744: LD_INT 1
70746: PLUS
70747: PPUSH
70748: LD_VAR 0 7
70752: PUSH
70753: LD_VAR 0 9
70757: PUSH
70758: EMPTY
70759: LIST
70760: LIST
70761: PPUSH
70762: CALL_OW 2
70766: ST_TO_ADDR
70767: GO 70849
// for j = 1 to result do
70769: LD_ADDR_VAR 0 8
70773: PUSH
70774: DOUBLE
70775: LD_INT 1
70777: DEC
70778: ST_TO_ADDR
70779: LD_VAR 0 6
70783: PUSH
70784: FOR_TO
70785: IFFALSE 70847
// begin if tmp < result [ j ] [ 2 ] then
70787: LD_VAR 0 9
70791: PUSH
70792: LD_VAR 0 6
70796: PUSH
70797: LD_VAR 0 8
70801: ARRAY
70802: PUSH
70803: LD_INT 2
70805: ARRAY
70806: LESS
70807: IFFALSE 70845
// begin result := Insert ( result , j , [ i , tmp ] ) ;
70809: LD_ADDR_VAR 0 6
70813: PUSH
70814: LD_VAR 0 6
70818: PPUSH
70819: LD_VAR 0 8
70823: PPUSH
70824: LD_VAR 0 7
70828: PUSH
70829: LD_VAR 0 9
70833: PUSH
70834: EMPTY
70835: LIST
70836: LIST
70837: PPUSH
70838: CALL_OW 2
70842: ST_TO_ADDR
// break ;
70843: GO 70847
// end ; end ;
70845: GO 70784
70847: POP
70848: POP
// end ; end ;
70849: GO 70648
70851: POP
70852: POP
// if result and not asc then
70853: LD_VAR 0 6
70857: PUSH
70858: LD_VAR 0 4
70862: NOT
70863: AND
70864: IFFALSE 70939
// begin tmp := result ;
70866: LD_ADDR_VAR 0 9
70870: PUSH
70871: LD_VAR 0 6
70875: ST_TO_ADDR
// for i = tmp downto 1 do
70876: LD_ADDR_VAR 0 7
70880: PUSH
70881: DOUBLE
70882: LD_VAR 0 9
70886: INC
70887: ST_TO_ADDR
70888: LD_INT 1
70890: PUSH
70891: FOR_DOWNTO
70892: IFFALSE 70937
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
70894: LD_ADDR_VAR 0 6
70898: PUSH
70899: LD_VAR 0 6
70903: PPUSH
70904: LD_VAR 0 9
70908: PUSH
70909: LD_VAR 0 7
70913: MINUS
70914: PUSH
70915: LD_INT 1
70917: PLUS
70918: PPUSH
70919: LD_VAR 0 9
70923: PUSH
70924: LD_VAR 0 7
70928: ARRAY
70929: PPUSH
70930: CALL_OW 1
70934: ST_TO_ADDR
70935: GO 70891
70937: POP
70938: POP
// end ; tmp := [ ] ;
70939: LD_ADDR_VAR 0 9
70943: PUSH
70944: EMPTY
70945: ST_TO_ADDR
// if mode then
70946: LD_VAR 0 5
70950: IFFALSE 71019
// begin for i = 1 to result do
70952: LD_ADDR_VAR 0 7
70956: PUSH
70957: DOUBLE
70958: LD_INT 1
70960: DEC
70961: ST_TO_ADDR
70962: LD_VAR 0 6
70966: PUSH
70967: FOR_TO
70968: IFFALSE 71007
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
70970: LD_ADDR_VAR 0 9
70974: PUSH
70975: LD_VAR 0 9
70979: PPUSH
70980: LD_VAR 0 7
70984: PPUSH
70985: LD_VAR 0 6
70989: PUSH
70990: LD_VAR 0 7
70994: ARRAY
70995: PUSH
70996: LD_INT 1
70998: ARRAY
70999: PPUSH
71000: CALL_OW 1
71004: ST_TO_ADDR
71005: GO 70967
71007: POP
71008: POP
// result := tmp ;
71009: LD_ADDR_VAR 0 6
71013: PUSH
71014: LD_VAR 0 9
71018: ST_TO_ADDR
// end ; end ;
71019: LD_VAR 0 6
71023: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
71024: LD_INT 0
71026: PPUSH
71027: PPUSH
71028: PPUSH
71029: PPUSH
71030: PPUSH
71031: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
71032: LD_ADDR_VAR 0 5
71036: PUSH
71037: LD_INT 0
71039: PUSH
71040: LD_INT 0
71042: PUSH
71043: LD_INT 0
71045: PUSH
71046: EMPTY
71047: PUSH
71048: EMPTY
71049: LIST
71050: LIST
71051: LIST
71052: LIST
71053: ST_TO_ADDR
// if not x or not y then
71054: LD_VAR 0 2
71058: NOT
71059: PUSH
71060: LD_VAR 0 3
71064: NOT
71065: OR
71066: IFFALSE 71070
// exit ;
71068: GO 72716
// if not range then
71070: LD_VAR 0 4
71074: NOT
71075: IFFALSE 71085
// range := 10 ;
71077: LD_ADDR_VAR 0 4
71081: PUSH
71082: LD_INT 10
71084: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71085: LD_ADDR_VAR 0 8
71089: PUSH
71090: LD_INT 81
71092: PUSH
71093: LD_VAR 0 1
71097: PUSH
71098: EMPTY
71099: LIST
71100: LIST
71101: PUSH
71102: LD_INT 92
71104: PUSH
71105: LD_VAR 0 2
71109: PUSH
71110: LD_VAR 0 3
71114: PUSH
71115: LD_VAR 0 4
71119: PUSH
71120: EMPTY
71121: LIST
71122: LIST
71123: LIST
71124: LIST
71125: PUSH
71126: LD_INT 3
71128: PUSH
71129: LD_INT 21
71131: PUSH
71132: LD_INT 3
71134: PUSH
71135: EMPTY
71136: LIST
71137: LIST
71138: PUSH
71139: EMPTY
71140: LIST
71141: LIST
71142: PUSH
71143: EMPTY
71144: LIST
71145: LIST
71146: LIST
71147: PPUSH
71148: CALL_OW 69
71152: ST_TO_ADDR
// if not tmp then
71153: LD_VAR 0 8
71157: NOT
71158: IFFALSE 71162
// exit ;
71160: GO 72716
// for i in tmp do
71162: LD_ADDR_VAR 0 6
71166: PUSH
71167: LD_VAR 0 8
71171: PUSH
71172: FOR_IN
71173: IFFALSE 72691
// begin points := [ 0 , 0 , 0 ] ;
71175: LD_ADDR_VAR 0 9
71179: PUSH
71180: LD_INT 0
71182: PUSH
71183: LD_INT 0
71185: PUSH
71186: LD_INT 0
71188: PUSH
71189: EMPTY
71190: LIST
71191: LIST
71192: LIST
71193: ST_TO_ADDR
// bpoints := 1 ;
71194: LD_ADDR_VAR 0 10
71198: PUSH
71199: LD_INT 1
71201: ST_TO_ADDR
// case GetType ( i ) of unit_human :
71202: LD_VAR 0 6
71206: PPUSH
71207: CALL_OW 247
71211: PUSH
71212: LD_INT 1
71214: DOUBLE
71215: EQUAL
71216: IFTRUE 71220
71218: GO 71798
71220: POP
// begin if GetClass ( i ) = 1 then
71221: LD_VAR 0 6
71225: PPUSH
71226: CALL_OW 257
71230: PUSH
71231: LD_INT 1
71233: EQUAL
71234: IFFALSE 71255
// points := [ 10 , 5 , 3 ] ;
71236: LD_ADDR_VAR 0 9
71240: PUSH
71241: LD_INT 10
71243: PUSH
71244: LD_INT 5
71246: PUSH
71247: LD_INT 3
71249: PUSH
71250: EMPTY
71251: LIST
71252: LIST
71253: LIST
71254: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
71255: LD_VAR 0 6
71259: PPUSH
71260: CALL_OW 257
71264: PUSH
71265: LD_INT 2
71267: PUSH
71268: LD_INT 3
71270: PUSH
71271: LD_INT 4
71273: PUSH
71274: EMPTY
71275: LIST
71276: LIST
71277: LIST
71278: IN
71279: IFFALSE 71300
// points := [ 3 , 2 , 1 ] ;
71281: LD_ADDR_VAR 0 9
71285: PUSH
71286: LD_INT 3
71288: PUSH
71289: LD_INT 2
71291: PUSH
71292: LD_INT 1
71294: PUSH
71295: EMPTY
71296: LIST
71297: LIST
71298: LIST
71299: ST_TO_ADDR
// if GetClass ( i ) = 5 then
71300: LD_VAR 0 6
71304: PPUSH
71305: CALL_OW 257
71309: PUSH
71310: LD_INT 5
71312: EQUAL
71313: IFFALSE 71334
// points := [ 130 , 5 , 2 ] ;
71315: LD_ADDR_VAR 0 9
71319: PUSH
71320: LD_INT 130
71322: PUSH
71323: LD_INT 5
71325: PUSH
71326: LD_INT 2
71328: PUSH
71329: EMPTY
71330: LIST
71331: LIST
71332: LIST
71333: ST_TO_ADDR
// if GetClass ( i ) = 8 then
71334: LD_VAR 0 6
71338: PPUSH
71339: CALL_OW 257
71343: PUSH
71344: LD_INT 8
71346: EQUAL
71347: IFFALSE 71368
// points := [ 35 , 35 , 30 ] ;
71349: LD_ADDR_VAR 0 9
71353: PUSH
71354: LD_INT 35
71356: PUSH
71357: LD_INT 35
71359: PUSH
71360: LD_INT 30
71362: PUSH
71363: EMPTY
71364: LIST
71365: LIST
71366: LIST
71367: ST_TO_ADDR
// if GetClass ( i ) = 9 then
71368: LD_VAR 0 6
71372: PPUSH
71373: CALL_OW 257
71377: PUSH
71378: LD_INT 9
71380: EQUAL
71381: IFFALSE 71402
// points := [ 20 , 55 , 40 ] ;
71383: LD_ADDR_VAR 0 9
71387: PUSH
71388: LD_INT 20
71390: PUSH
71391: LD_INT 55
71393: PUSH
71394: LD_INT 40
71396: PUSH
71397: EMPTY
71398: LIST
71399: LIST
71400: LIST
71401: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
71402: LD_VAR 0 6
71406: PPUSH
71407: CALL_OW 257
71411: PUSH
71412: LD_INT 12
71414: PUSH
71415: LD_INT 16
71417: PUSH
71418: EMPTY
71419: LIST
71420: LIST
71421: IN
71422: IFFALSE 71443
// points := [ 5 , 3 , 2 ] ;
71424: LD_ADDR_VAR 0 9
71428: PUSH
71429: LD_INT 5
71431: PUSH
71432: LD_INT 3
71434: PUSH
71435: LD_INT 2
71437: PUSH
71438: EMPTY
71439: LIST
71440: LIST
71441: LIST
71442: ST_TO_ADDR
// if GetClass ( i ) = 17 then
71443: LD_VAR 0 6
71447: PPUSH
71448: CALL_OW 257
71452: PUSH
71453: LD_INT 17
71455: EQUAL
71456: IFFALSE 71477
// points := [ 100 , 50 , 75 ] ;
71458: LD_ADDR_VAR 0 9
71462: PUSH
71463: LD_INT 100
71465: PUSH
71466: LD_INT 50
71468: PUSH
71469: LD_INT 75
71471: PUSH
71472: EMPTY
71473: LIST
71474: LIST
71475: LIST
71476: ST_TO_ADDR
// if GetClass ( i ) = 15 then
71477: LD_VAR 0 6
71481: PPUSH
71482: CALL_OW 257
71486: PUSH
71487: LD_INT 15
71489: EQUAL
71490: IFFALSE 71511
// points := [ 10 , 5 , 3 ] ;
71492: LD_ADDR_VAR 0 9
71496: PUSH
71497: LD_INT 10
71499: PUSH
71500: LD_INT 5
71502: PUSH
71503: LD_INT 3
71505: PUSH
71506: EMPTY
71507: LIST
71508: LIST
71509: LIST
71510: ST_TO_ADDR
// if GetClass ( i ) = 14 then
71511: LD_VAR 0 6
71515: PPUSH
71516: CALL_OW 257
71520: PUSH
71521: LD_INT 14
71523: EQUAL
71524: IFFALSE 71545
// points := [ 10 , 0 , 0 ] ;
71526: LD_ADDR_VAR 0 9
71530: PUSH
71531: LD_INT 10
71533: PUSH
71534: LD_INT 0
71536: PUSH
71537: LD_INT 0
71539: PUSH
71540: EMPTY
71541: LIST
71542: LIST
71543: LIST
71544: ST_TO_ADDR
// if GetClass ( i ) = 11 then
71545: LD_VAR 0 6
71549: PPUSH
71550: CALL_OW 257
71554: PUSH
71555: LD_INT 11
71557: EQUAL
71558: IFFALSE 71579
// points := [ 30 , 10 , 5 ] ;
71560: LD_ADDR_VAR 0 9
71564: PUSH
71565: LD_INT 30
71567: PUSH
71568: LD_INT 10
71570: PUSH
71571: LD_INT 5
71573: PUSH
71574: EMPTY
71575: LIST
71576: LIST
71577: LIST
71578: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
71579: LD_VAR 0 1
71583: PPUSH
71584: LD_INT 5
71586: PPUSH
71587: CALL_OW 321
71591: PUSH
71592: LD_INT 2
71594: EQUAL
71595: IFFALSE 71612
// bpoints := bpoints * 1.8 ;
71597: LD_ADDR_VAR 0 10
71601: PUSH
71602: LD_VAR 0 10
71606: PUSH
71607: LD_REAL  1.80000000000000E+0000
71610: MUL
71611: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
71612: LD_VAR 0 6
71616: PPUSH
71617: CALL_OW 257
71621: PUSH
71622: LD_INT 1
71624: PUSH
71625: LD_INT 2
71627: PUSH
71628: LD_INT 3
71630: PUSH
71631: LD_INT 4
71633: PUSH
71634: EMPTY
71635: LIST
71636: LIST
71637: LIST
71638: LIST
71639: IN
71640: PUSH
71641: LD_VAR 0 1
71645: PPUSH
71646: LD_INT 51
71648: PPUSH
71649: CALL_OW 321
71653: PUSH
71654: LD_INT 2
71656: EQUAL
71657: AND
71658: IFFALSE 71675
// bpoints := bpoints * 1.2 ;
71660: LD_ADDR_VAR 0 10
71664: PUSH
71665: LD_VAR 0 10
71669: PUSH
71670: LD_REAL  1.20000000000000E+0000
71673: MUL
71674: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
71675: LD_VAR 0 6
71679: PPUSH
71680: CALL_OW 257
71684: PUSH
71685: LD_INT 5
71687: PUSH
71688: LD_INT 7
71690: PUSH
71691: LD_INT 9
71693: PUSH
71694: EMPTY
71695: LIST
71696: LIST
71697: LIST
71698: IN
71699: PUSH
71700: LD_VAR 0 1
71704: PPUSH
71705: LD_INT 52
71707: PPUSH
71708: CALL_OW 321
71712: PUSH
71713: LD_INT 2
71715: EQUAL
71716: AND
71717: IFFALSE 71734
// bpoints := bpoints * 1.5 ;
71719: LD_ADDR_VAR 0 10
71723: PUSH
71724: LD_VAR 0 10
71728: PUSH
71729: LD_REAL  1.50000000000000E+0000
71732: MUL
71733: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
71734: LD_VAR 0 1
71738: PPUSH
71739: LD_INT 66
71741: PPUSH
71742: CALL_OW 321
71746: PUSH
71747: LD_INT 2
71749: EQUAL
71750: IFFALSE 71767
// bpoints := bpoints * 1.1 ;
71752: LD_ADDR_VAR 0 10
71756: PUSH
71757: LD_VAR 0 10
71761: PUSH
71762: LD_REAL  1.10000000000000E+0000
71765: MUL
71766: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
71767: LD_ADDR_VAR 0 10
71771: PUSH
71772: LD_VAR 0 10
71776: PUSH
71777: LD_VAR 0 6
71781: PPUSH
71782: LD_INT 1
71784: PPUSH
71785: CALL_OW 259
71789: PUSH
71790: LD_REAL  1.15000000000000E+0000
71793: MUL
71794: MUL
71795: ST_TO_ADDR
// end ; unit_vehicle :
71796: GO 72620
71798: LD_INT 2
71800: DOUBLE
71801: EQUAL
71802: IFTRUE 71806
71804: GO 72608
71806: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
71807: LD_VAR 0 6
71811: PPUSH
71812: CALL_OW 264
71816: PUSH
71817: LD_INT 2
71819: PUSH
71820: LD_INT 42
71822: PUSH
71823: LD_INT 24
71825: PUSH
71826: EMPTY
71827: LIST
71828: LIST
71829: LIST
71830: IN
71831: IFFALSE 71852
// points := [ 25 , 5 , 3 ] ;
71833: LD_ADDR_VAR 0 9
71837: PUSH
71838: LD_INT 25
71840: PUSH
71841: LD_INT 5
71843: PUSH
71844: LD_INT 3
71846: PUSH
71847: EMPTY
71848: LIST
71849: LIST
71850: LIST
71851: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
71852: LD_VAR 0 6
71856: PPUSH
71857: CALL_OW 264
71861: PUSH
71862: LD_INT 4
71864: PUSH
71865: LD_INT 43
71867: PUSH
71868: LD_INT 25
71870: PUSH
71871: EMPTY
71872: LIST
71873: LIST
71874: LIST
71875: IN
71876: IFFALSE 71897
// points := [ 40 , 15 , 5 ] ;
71878: LD_ADDR_VAR 0 9
71882: PUSH
71883: LD_INT 40
71885: PUSH
71886: LD_INT 15
71888: PUSH
71889: LD_INT 5
71891: PUSH
71892: EMPTY
71893: LIST
71894: LIST
71895: LIST
71896: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
71897: LD_VAR 0 6
71901: PPUSH
71902: CALL_OW 264
71906: PUSH
71907: LD_INT 3
71909: PUSH
71910: LD_INT 23
71912: PUSH
71913: EMPTY
71914: LIST
71915: LIST
71916: IN
71917: IFFALSE 71938
// points := [ 7 , 25 , 8 ] ;
71919: LD_ADDR_VAR 0 9
71923: PUSH
71924: LD_INT 7
71926: PUSH
71927: LD_INT 25
71929: PUSH
71930: LD_INT 8
71932: PUSH
71933: EMPTY
71934: LIST
71935: LIST
71936: LIST
71937: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
71938: LD_VAR 0 6
71942: PPUSH
71943: CALL_OW 264
71947: PUSH
71948: LD_INT 5
71950: PUSH
71951: LD_INT 27
71953: PUSH
71954: LD_INT 44
71956: PUSH
71957: EMPTY
71958: LIST
71959: LIST
71960: LIST
71961: IN
71962: IFFALSE 71983
// points := [ 14 , 50 , 16 ] ;
71964: LD_ADDR_VAR 0 9
71968: PUSH
71969: LD_INT 14
71971: PUSH
71972: LD_INT 50
71974: PUSH
71975: LD_INT 16
71977: PUSH
71978: EMPTY
71979: LIST
71980: LIST
71981: LIST
71982: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
71983: LD_VAR 0 6
71987: PPUSH
71988: CALL_OW 264
71992: PUSH
71993: LD_INT 6
71995: PUSH
71996: LD_INT 46
71998: PUSH
71999: EMPTY
72000: LIST
72001: LIST
72002: IN
72003: IFFALSE 72024
// points := [ 32 , 120 , 70 ] ;
72005: LD_ADDR_VAR 0 9
72009: PUSH
72010: LD_INT 32
72012: PUSH
72013: LD_INT 120
72015: PUSH
72016: LD_INT 70
72018: PUSH
72019: EMPTY
72020: LIST
72021: LIST
72022: LIST
72023: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
72024: LD_VAR 0 6
72028: PPUSH
72029: CALL_OW 264
72033: PUSH
72034: LD_INT 7
72036: PUSH
72037: LD_INT 28
72039: PUSH
72040: LD_INT 45
72042: PUSH
72043: EMPTY
72044: LIST
72045: LIST
72046: LIST
72047: IN
72048: IFFALSE 72069
// points := [ 35 , 20 , 45 ] ;
72050: LD_ADDR_VAR 0 9
72054: PUSH
72055: LD_INT 35
72057: PUSH
72058: LD_INT 20
72060: PUSH
72061: LD_INT 45
72063: PUSH
72064: EMPTY
72065: LIST
72066: LIST
72067: LIST
72068: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
72069: LD_VAR 0 6
72073: PPUSH
72074: CALL_OW 264
72078: PUSH
72079: LD_INT 47
72081: PUSH
72082: EMPTY
72083: LIST
72084: IN
72085: IFFALSE 72106
// points := [ 67 , 45 , 75 ] ;
72087: LD_ADDR_VAR 0 9
72091: PUSH
72092: LD_INT 67
72094: PUSH
72095: LD_INT 45
72097: PUSH
72098: LD_INT 75
72100: PUSH
72101: EMPTY
72102: LIST
72103: LIST
72104: LIST
72105: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
72106: LD_VAR 0 6
72110: PPUSH
72111: CALL_OW 264
72115: PUSH
72116: LD_INT 26
72118: PUSH
72119: EMPTY
72120: LIST
72121: IN
72122: IFFALSE 72143
// points := [ 120 , 30 , 80 ] ;
72124: LD_ADDR_VAR 0 9
72128: PUSH
72129: LD_INT 120
72131: PUSH
72132: LD_INT 30
72134: PUSH
72135: LD_INT 80
72137: PUSH
72138: EMPTY
72139: LIST
72140: LIST
72141: LIST
72142: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
72143: LD_VAR 0 6
72147: PPUSH
72148: CALL_OW 264
72152: PUSH
72153: LD_INT 22
72155: PUSH
72156: EMPTY
72157: LIST
72158: IN
72159: IFFALSE 72180
// points := [ 40 , 1 , 1 ] ;
72161: LD_ADDR_VAR 0 9
72165: PUSH
72166: LD_INT 40
72168: PUSH
72169: LD_INT 1
72171: PUSH
72172: LD_INT 1
72174: PUSH
72175: EMPTY
72176: LIST
72177: LIST
72178: LIST
72179: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
72180: LD_VAR 0 6
72184: PPUSH
72185: CALL_OW 264
72189: PUSH
72190: LD_INT 29
72192: PUSH
72193: EMPTY
72194: LIST
72195: IN
72196: IFFALSE 72217
// points := [ 70 , 200 , 400 ] ;
72198: LD_ADDR_VAR 0 9
72202: PUSH
72203: LD_INT 70
72205: PUSH
72206: LD_INT 200
72208: PUSH
72209: LD_INT 400
72211: PUSH
72212: EMPTY
72213: LIST
72214: LIST
72215: LIST
72216: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
72217: LD_VAR 0 6
72221: PPUSH
72222: CALL_OW 264
72226: PUSH
72227: LD_INT 14
72229: PUSH
72230: LD_INT 53
72232: PUSH
72233: EMPTY
72234: LIST
72235: LIST
72236: IN
72237: IFFALSE 72258
// points := [ 40 , 10 , 20 ] ;
72239: LD_ADDR_VAR 0 9
72243: PUSH
72244: LD_INT 40
72246: PUSH
72247: LD_INT 10
72249: PUSH
72250: LD_INT 20
72252: PUSH
72253: EMPTY
72254: LIST
72255: LIST
72256: LIST
72257: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
72258: LD_VAR 0 6
72262: PPUSH
72263: CALL_OW 264
72267: PUSH
72268: LD_INT 9
72270: PUSH
72271: EMPTY
72272: LIST
72273: IN
72274: IFFALSE 72295
// points := [ 5 , 70 , 20 ] ;
72276: LD_ADDR_VAR 0 9
72280: PUSH
72281: LD_INT 5
72283: PUSH
72284: LD_INT 70
72286: PUSH
72287: LD_INT 20
72289: PUSH
72290: EMPTY
72291: LIST
72292: LIST
72293: LIST
72294: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
72295: LD_VAR 0 6
72299: PPUSH
72300: CALL_OW 264
72304: PUSH
72305: LD_INT 10
72307: PUSH
72308: EMPTY
72309: LIST
72310: IN
72311: IFFALSE 72332
// points := [ 35 , 110 , 70 ] ;
72313: LD_ADDR_VAR 0 9
72317: PUSH
72318: LD_INT 35
72320: PUSH
72321: LD_INT 110
72323: PUSH
72324: LD_INT 70
72326: PUSH
72327: EMPTY
72328: LIST
72329: LIST
72330: LIST
72331: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
72332: LD_VAR 0 6
72336: PPUSH
72337: CALL_OW 265
72341: PUSH
72342: LD_INT 25
72344: EQUAL
72345: IFFALSE 72366
// points := [ 80 , 65 , 100 ] ;
72347: LD_ADDR_VAR 0 9
72351: PUSH
72352: LD_INT 80
72354: PUSH
72355: LD_INT 65
72357: PUSH
72358: LD_INT 100
72360: PUSH
72361: EMPTY
72362: LIST
72363: LIST
72364: LIST
72365: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
72366: LD_VAR 0 6
72370: PPUSH
72371: CALL_OW 263
72375: PUSH
72376: LD_INT 1
72378: EQUAL
72379: IFFALSE 72414
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
72381: LD_ADDR_VAR 0 10
72385: PUSH
72386: LD_VAR 0 10
72390: PUSH
72391: LD_VAR 0 6
72395: PPUSH
72396: CALL_OW 311
72400: PPUSH
72401: LD_INT 3
72403: PPUSH
72404: CALL_OW 259
72408: PUSH
72409: LD_INT 4
72411: MUL
72412: MUL
72413: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
72414: LD_VAR 0 6
72418: PPUSH
72419: CALL_OW 263
72423: PUSH
72424: LD_INT 2
72426: EQUAL
72427: IFFALSE 72478
// begin j := IsControledBy ( i ) ;
72429: LD_ADDR_VAR 0 7
72433: PUSH
72434: LD_VAR 0 6
72438: PPUSH
72439: CALL_OW 312
72443: ST_TO_ADDR
// if j then
72444: LD_VAR 0 7
72448: IFFALSE 72478
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
72450: LD_ADDR_VAR 0 10
72454: PUSH
72455: LD_VAR 0 10
72459: PUSH
72460: LD_VAR 0 7
72464: PPUSH
72465: LD_INT 3
72467: PPUSH
72468: CALL_OW 259
72472: PUSH
72473: LD_INT 3
72475: MUL
72476: MUL
72477: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
72478: LD_VAR 0 6
72482: PPUSH
72483: CALL_OW 264
72487: PUSH
72488: LD_INT 5
72490: PUSH
72491: LD_INT 6
72493: PUSH
72494: LD_INT 46
72496: PUSH
72497: LD_INT 44
72499: PUSH
72500: LD_INT 47
72502: PUSH
72503: LD_INT 45
72505: PUSH
72506: LD_INT 28
72508: PUSH
72509: LD_INT 7
72511: PUSH
72512: LD_INT 27
72514: PUSH
72515: LD_INT 29
72517: PUSH
72518: EMPTY
72519: LIST
72520: LIST
72521: LIST
72522: LIST
72523: LIST
72524: LIST
72525: LIST
72526: LIST
72527: LIST
72528: LIST
72529: IN
72530: PUSH
72531: LD_VAR 0 1
72535: PPUSH
72536: LD_INT 52
72538: PPUSH
72539: CALL_OW 321
72543: PUSH
72544: LD_INT 2
72546: EQUAL
72547: AND
72548: IFFALSE 72565
// bpoints := bpoints * 1.2 ;
72550: LD_ADDR_VAR 0 10
72554: PUSH
72555: LD_VAR 0 10
72559: PUSH
72560: LD_REAL  1.20000000000000E+0000
72563: MUL
72564: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
72565: LD_VAR 0 6
72569: PPUSH
72570: CALL_OW 264
72574: PUSH
72575: LD_INT 6
72577: PUSH
72578: LD_INT 46
72580: PUSH
72581: LD_INT 47
72583: PUSH
72584: EMPTY
72585: LIST
72586: LIST
72587: LIST
72588: IN
72589: IFFALSE 72606
// bpoints := bpoints * 1.2 ;
72591: LD_ADDR_VAR 0 10
72595: PUSH
72596: LD_VAR 0 10
72600: PUSH
72601: LD_REAL  1.20000000000000E+0000
72604: MUL
72605: ST_TO_ADDR
// end ; unit_building :
72606: GO 72620
72608: LD_INT 3
72610: DOUBLE
72611: EQUAL
72612: IFTRUE 72616
72614: GO 72619
72616: POP
// ; end ;
72617: GO 72620
72619: POP
// for j = 1 to 3 do
72620: LD_ADDR_VAR 0 7
72624: PUSH
72625: DOUBLE
72626: LD_INT 1
72628: DEC
72629: ST_TO_ADDR
72630: LD_INT 3
72632: PUSH
72633: FOR_TO
72634: IFFALSE 72687
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
72636: LD_ADDR_VAR 0 5
72640: PUSH
72641: LD_VAR 0 5
72645: PPUSH
72646: LD_VAR 0 7
72650: PPUSH
72651: LD_VAR 0 5
72655: PUSH
72656: LD_VAR 0 7
72660: ARRAY
72661: PUSH
72662: LD_VAR 0 9
72666: PUSH
72667: LD_VAR 0 7
72671: ARRAY
72672: PUSH
72673: LD_VAR 0 10
72677: MUL
72678: PLUS
72679: PPUSH
72680: CALL_OW 1
72684: ST_TO_ADDR
72685: GO 72633
72687: POP
72688: POP
// end ;
72689: GO 71172
72691: POP
72692: POP
// result := Replace ( result , 4 , tmp ) ;
72693: LD_ADDR_VAR 0 5
72697: PUSH
72698: LD_VAR 0 5
72702: PPUSH
72703: LD_INT 4
72705: PPUSH
72706: LD_VAR 0 8
72710: PPUSH
72711: CALL_OW 1
72715: ST_TO_ADDR
// end ;
72716: LD_VAR 0 5
72720: RET
// export function DangerAtRange ( unit , range ) ; begin
72721: LD_INT 0
72723: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
72724: LD_ADDR_VAR 0 3
72728: PUSH
72729: LD_VAR 0 1
72733: PPUSH
72734: CALL_OW 255
72738: PPUSH
72739: LD_VAR 0 1
72743: PPUSH
72744: CALL_OW 250
72748: PPUSH
72749: LD_VAR 0 1
72753: PPUSH
72754: CALL_OW 251
72758: PPUSH
72759: LD_VAR 0 2
72763: PPUSH
72764: CALL 71024 0 4
72768: ST_TO_ADDR
// end ;
72769: LD_VAR 0 3
72773: RET
// export function DangerInArea ( side , area ) ; begin
72774: LD_INT 0
72776: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
72777: LD_ADDR_VAR 0 3
72781: PUSH
72782: LD_VAR 0 2
72786: PPUSH
72787: LD_INT 81
72789: PUSH
72790: LD_VAR 0 1
72794: PUSH
72795: EMPTY
72796: LIST
72797: LIST
72798: PPUSH
72799: CALL_OW 70
72803: ST_TO_ADDR
// end ;
72804: LD_VAR 0 3
72808: RET
// export function IsExtension ( b ) ; begin
72809: LD_INT 0
72811: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
72812: LD_ADDR_VAR 0 2
72816: PUSH
72817: LD_VAR 0 1
72821: PUSH
72822: LD_INT 23
72824: PUSH
72825: LD_INT 20
72827: PUSH
72828: LD_INT 22
72830: PUSH
72831: LD_INT 17
72833: PUSH
72834: LD_INT 24
72836: PUSH
72837: LD_INT 21
72839: PUSH
72840: LD_INT 19
72842: PUSH
72843: LD_INT 16
72845: PUSH
72846: LD_INT 25
72848: PUSH
72849: LD_INT 18
72851: PUSH
72852: EMPTY
72853: LIST
72854: LIST
72855: LIST
72856: LIST
72857: LIST
72858: LIST
72859: LIST
72860: LIST
72861: LIST
72862: LIST
72863: IN
72864: ST_TO_ADDR
// end ;
72865: LD_VAR 0 2
72869: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
72870: LD_INT 0
72872: PPUSH
72873: PPUSH
72874: PPUSH
// result := [ ] ;
72875: LD_ADDR_VAR 0 3
72879: PUSH
72880: EMPTY
72881: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
72882: LD_ADDR_VAR 0 4
72886: PUSH
72887: LD_VAR 0 2
72891: PPUSH
72892: LD_INT 21
72894: PUSH
72895: LD_INT 3
72897: PUSH
72898: EMPTY
72899: LIST
72900: LIST
72901: PPUSH
72902: CALL_OW 70
72906: ST_TO_ADDR
// if not tmp then
72907: LD_VAR 0 4
72911: NOT
72912: IFFALSE 72916
// exit ;
72914: GO 72974
// for i in tmp do
72916: LD_ADDR_VAR 0 5
72920: PUSH
72921: LD_VAR 0 4
72925: PUSH
72926: FOR_IN
72927: IFFALSE 72962
// if GetBase ( i ) <> base then
72929: LD_VAR 0 5
72933: PPUSH
72934: CALL_OW 274
72938: PUSH
72939: LD_VAR 0 1
72943: NONEQUAL
72944: IFFALSE 72960
// ComLinkToBase ( base , i ) ;
72946: LD_VAR 0 1
72950: PPUSH
72951: LD_VAR 0 5
72955: PPUSH
72956: CALL_OW 169
72960: GO 72926
72962: POP
72963: POP
// result := tmp ;
72964: LD_ADDR_VAR 0 3
72968: PUSH
72969: LD_VAR 0 4
72973: ST_TO_ADDR
// end ;
72974: LD_VAR 0 3
72978: RET
// export function ComComplete ( unit , b ) ; var i ; begin
72979: LD_INT 0
72981: PPUSH
72982: PPUSH
// if BuildingStatus ( b ) = bs_build then
72983: LD_VAR 0 2
72987: PPUSH
72988: CALL_OW 461
72992: PUSH
72993: LD_INT 1
72995: EQUAL
72996: IFFALSE 73056
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
72998: LD_VAR 0 1
73002: PPUSH
73003: LD_STRING h
73005: PUSH
73006: LD_VAR 0 2
73010: PPUSH
73011: CALL_OW 250
73015: PUSH
73016: LD_VAR 0 2
73020: PPUSH
73021: CALL_OW 251
73025: PUSH
73026: LD_VAR 0 2
73030: PUSH
73031: LD_INT 0
73033: PUSH
73034: LD_INT 0
73036: PUSH
73037: LD_INT 0
73039: PUSH
73040: EMPTY
73041: LIST
73042: LIST
73043: LIST
73044: LIST
73045: LIST
73046: LIST
73047: LIST
73048: PUSH
73049: EMPTY
73050: LIST
73051: PPUSH
73052: CALL_OW 446
// end ;
73056: LD_VAR 0 3
73060: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
73061: LD_INT 0
73063: PPUSH
73064: PPUSH
73065: PPUSH
73066: PPUSH
73067: PPUSH
73068: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
73069: LD_VAR 0 1
73073: NOT
73074: PUSH
73075: LD_VAR 0 1
73079: PPUSH
73080: CALL_OW 263
73084: PUSH
73085: LD_INT 2
73087: EQUAL
73088: NOT
73089: OR
73090: IFFALSE 73094
// exit ;
73092: GO 73410
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
73094: LD_ADDR_VAR 0 6
73098: PUSH
73099: LD_INT 22
73101: PUSH
73102: LD_VAR 0 1
73106: PPUSH
73107: CALL_OW 255
73111: PUSH
73112: EMPTY
73113: LIST
73114: LIST
73115: PUSH
73116: LD_INT 2
73118: PUSH
73119: LD_INT 30
73121: PUSH
73122: LD_INT 36
73124: PUSH
73125: EMPTY
73126: LIST
73127: LIST
73128: PUSH
73129: LD_INT 34
73131: PUSH
73132: LD_INT 31
73134: PUSH
73135: EMPTY
73136: LIST
73137: LIST
73138: PUSH
73139: EMPTY
73140: LIST
73141: LIST
73142: LIST
73143: PUSH
73144: EMPTY
73145: LIST
73146: LIST
73147: PPUSH
73148: CALL_OW 69
73152: ST_TO_ADDR
// if not tmp then
73153: LD_VAR 0 6
73157: NOT
73158: IFFALSE 73162
// exit ;
73160: GO 73410
// result := [ ] ;
73162: LD_ADDR_VAR 0 2
73166: PUSH
73167: EMPTY
73168: ST_TO_ADDR
// for i in tmp do
73169: LD_ADDR_VAR 0 3
73173: PUSH
73174: LD_VAR 0 6
73178: PUSH
73179: FOR_IN
73180: IFFALSE 73251
// begin t := UnitsInside ( i ) ;
73182: LD_ADDR_VAR 0 4
73186: PUSH
73187: LD_VAR 0 3
73191: PPUSH
73192: CALL_OW 313
73196: ST_TO_ADDR
// if t then
73197: LD_VAR 0 4
73201: IFFALSE 73249
// for j in t do
73203: LD_ADDR_VAR 0 7
73207: PUSH
73208: LD_VAR 0 4
73212: PUSH
73213: FOR_IN
73214: IFFALSE 73247
// result := Insert ( result , result + 1 , j ) ;
73216: LD_ADDR_VAR 0 2
73220: PUSH
73221: LD_VAR 0 2
73225: PPUSH
73226: LD_VAR 0 2
73230: PUSH
73231: LD_INT 1
73233: PLUS
73234: PPUSH
73235: LD_VAR 0 7
73239: PPUSH
73240: CALL_OW 2
73244: ST_TO_ADDR
73245: GO 73213
73247: POP
73248: POP
// end ;
73249: GO 73179
73251: POP
73252: POP
// if not result then
73253: LD_VAR 0 2
73257: NOT
73258: IFFALSE 73262
// exit ;
73260: GO 73410
// mech := result [ 1 ] ;
73262: LD_ADDR_VAR 0 5
73266: PUSH
73267: LD_VAR 0 2
73271: PUSH
73272: LD_INT 1
73274: ARRAY
73275: ST_TO_ADDR
// if result > 1 then
73276: LD_VAR 0 2
73280: PUSH
73281: LD_INT 1
73283: GREATER
73284: IFFALSE 73396
// for i = 2 to result do
73286: LD_ADDR_VAR 0 3
73290: PUSH
73291: DOUBLE
73292: LD_INT 2
73294: DEC
73295: ST_TO_ADDR
73296: LD_VAR 0 2
73300: PUSH
73301: FOR_TO
73302: IFFALSE 73394
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
73304: LD_ADDR_VAR 0 4
73308: PUSH
73309: LD_VAR 0 2
73313: PUSH
73314: LD_VAR 0 3
73318: ARRAY
73319: PPUSH
73320: LD_INT 3
73322: PPUSH
73323: CALL_OW 259
73327: PUSH
73328: LD_VAR 0 2
73332: PUSH
73333: LD_VAR 0 3
73337: ARRAY
73338: PPUSH
73339: CALL_OW 432
73343: MINUS
73344: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
73345: LD_VAR 0 4
73349: PUSH
73350: LD_VAR 0 5
73354: PPUSH
73355: LD_INT 3
73357: PPUSH
73358: CALL_OW 259
73362: PUSH
73363: LD_VAR 0 5
73367: PPUSH
73368: CALL_OW 432
73372: MINUS
73373: GREATEREQUAL
73374: IFFALSE 73392
// mech := result [ i ] ;
73376: LD_ADDR_VAR 0 5
73380: PUSH
73381: LD_VAR 0 2
73385: PUSH
73386: LD_VAR 0 3
73390: ARRAY
73391: ST_TO_ADDR
// end ;
73392: GO 73301
73394: POP
73395: POP
// ComLinkTo ( vehicle , mech ) ;
73396: LD_VAR 0 1
73400: PPUSH
73401: LD_VAR 0 5
73405: PPUSH
73406: CALL_OW 135
// end ;
73410: LD_VAR 0 2
73414: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
73415: LD_INT 0
73417: PPUSH
73418: PPUSH
73419: PPUSH
73420: PPUSH
73421: PPUSH
73422: PPUSH
73423: PPUSH
73424: PPUSH
73425: PPUSH
73426: PPUSH
73427: PPUSH
73428: PPUSH
73429: PPUSH
// result := [ ] ;
73430: LD_ADDR_VAR 0 7
73434: PUSH
73435: EMPTY
73436: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
73437: LD_VAR 0 1
73441: PPUSH
73442: CALL_OW 266
73446: PUSH
73447: LD_INT 0
73449: PUSH
73450: LD_INT 1
73452: PUSH
73453: EMPTY
73454: LIST
73455: LIST
73456: IN
73457: NOT
73458: IFFALSE 73462
// exit ;
73460: GO 75093
// if name then
73462: LD_VAR 0 3
73466: IFFALSE 73482
// SetBName ( base_dep , name ) ;
73468: LD_VAR 0 1
73472: PPUSH
73473: LD_VAR 0 3
73477: PPUSH
73478: CALL_OW 500
// base := GetBase ( base_dep ) ;
73482: LD_ADDR_VAR 0 15
73486: PUSH
73487: LD_VAR 0 1
73491: PPUSH
73492: CALL_OW 274
73496: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
73497: LD_ADDR_VAR 0 16
73501: PUSH
73502: LD_VAR 0 1
73506: PPUSH
73507: CALL_OW 255
73511: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
73512: LD_ADDR_VAR 0 17
73516: PUSH
73517: LD_VAR 0 1
73521: PPUSH
73522: CALL_OW 248
73526: ST_TO_ADDR
// if sources then
73527: LD_VAR 0 5
73531: IFFALSE 73578
// for i = 1 to 3 do
73533: LD_ADDR_VAR 0 8
73537: PUSH
73538: DOUBLE
73539: LD_INT 1
73541: DEC
73542: ST_TO_ADDR
73543: LD_INT 3
73545: PUSH
73546: FOR_TO
73547: IFFALSE 73576
// AddResourceType ( base , i , sources [ i ] ) ;
73549: LD_VAR 0 15
73553: PPUSH
73554: LD_VAR 0 8
73558: PPUSH
73559: LD_VAR 0 5
73563: PUSH
73564: LD_VAR 0 8
73568: ARRAY
73569: PPUSH
73570: CALL_OW 276
73574: GO 73546
73576: POP
73577: POP
// buildings := GetBaseBuildings ( base , area ) ;
73578: LD_ADDR_VAR 0 18
73582: PUSH
73583: LD_VAR 0 15
73587: PPUSH
73588: LD_VAR 0 2
73592: PPUSH
73593: CALL 72870 0 2
73597: ST_TO_ADDR
// InitHc ;
73598: CALL_OW 19
// InitUc ;
73602: CALL_OW 18
// uc_side := side ;
73606: LD_ADDR_OWVAR 20
73610: PUSH
73611: LD_VAR 0 16
73615: ST_TO_ADDR
// uc_nation := nation ;
73616: LD_ADDR_OWVAR 21
73620: PUSH
73621: LD_VAR 0 17
73625: ST_TO_ADDR
// if buildings then
73626: LD_VAR 0 18
73630: IFFALSE 74952
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
73632: LD_ADDR_VAR 0 19
73636: PUSH
73637: LD_VAR 0 18
73641: PPUSH
73642: LD_INT 2
73644: PUSH
73645: LD_INT 30
73647: PUSH
73648: LD_INT 29
73650: PUSH
73651: EMPTY
73652: LIST
73653: LIST
73654: PUSH
73655: LD_INT 30
73657: PUSH
73658: LD_INT 30
73660: PUSH
73661: EMPTY
73662: LIST
73663: LIST
73664: PUSH
73665: EMPTY
73666: LIST
73667: LIST
73668: LIST
73669: PPUSH
73670: CALL_OW 72
73674: ST_TO_ADDR
// if tmp then
73675: LD_VAR 0 19
73679: IFFALSE 73727
// for i in tmp do
73681: LD_ADDR_VAR 0 8
73685: PUSH
73686: LD_VAR 0 19
73690: PUSH
73691: FOR_IN
73692: IFFALSE 73725
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
73694: LD_VAR 0 8
73698: PPUSH
73699: CALL_OW 250
73703: PPUSH
73704: LD_VAR 0 8
73708: PPUSH
73709: CALL_OW 251
73713: PPUSH
73714: LD_VAR 0 16
73718: PPUSH
73719: CALL_OW 441
73723: GO 73691
73725: POP
73726: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
73727: LD_VAR 0 18
73731: PPUSH
73732: LD_INT 2
73734: PUSH
73735: LD_INT 30
73737: PUSH
73738: LD_INT 32
73740: PUSH
73741: EMPTY
73742: LIST
73743: LIST
73744: PUSH
73745: LD_INT 30
73747: PUSH
73748: LD_INT 33
73750: PUSH
73751: EMPTY
73752: LIST
73753: LIST
73754: PUSH
73755: EMPTY
73756: LIST
73757: LIST
73758: LIST
73759: PPUSH
73760: CALL_OW 72
73764: IFFALSE 73852
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
73766: LD_ADDR_VAR 0 8
73770: PUSH
73771: LD_VAR 0 18
73775: PPUSH
73776: LD_INT 2
73778: PUSH
73779: LD_INT 30
73781: PUSH
73782: LD_INT 32
73784: PUSH
73785: EMPTY
73786: LIST
73787: LIST
73788: PUSH
73789: LD_INT 30
73791: PUSH
73792: LD_INT 33
73794: PUSH
73795: EMPTY
73796: LIST
73797: LIST
73798: PUSH
73799: EMPTY
73800: LIST
73801: LIST
73802: LIST
73803: PPUSH
73804: CALL_OW 72
73808: PUSH
73809: FOR_IN
73810: IFFALSE 73850
// begin if not GetBWeapon ( i ) then
73812: LD_VAR 0 8
73816: PPUSH
73817: CALL_OW 269
73821: NOT
73822: IFFALSE 73848
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
73824: LD_VAR 0 8
73828: PPUSH
73829: LD_VAR 0 8
73833: PPUSH
73834: LD_VAR 0 2
73838: PPUSH
73839: CALL 75098 0 2
73843: PPUSH
73844: CALL_OW 431
// end ;
73848: GO 73809
73850: POP
73851: POP
// end ; for i = 1 to personel do
73852: LD_ADDR_VAR 0 8
73856: PUSH
73857: DOUBLE
73858: LD_INT 1
73860: DEC
73861: ST_TO_ADDR
73862: LD_VAR 0 6
73866: PUSH
73867: FOR_TO
73868: IFFALSE 74932
// begin if i > 4 then
73870: LD_VAR 0 8
73874: PUSH
73875: LD_INT 4
73877: GREATER
73878: IFFALSE 73882
// break ;
73880: GO 74932
// case i of 1 :
73882: LD_VAR 0 8
73886: PUSH
73887: LD_INT 1
73889: DOUBLE
73890: EQUAL
73891: IFTRUE 73895
73893: GO 73975
73895: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
73896: LD_ADDR_VAR 0 12
73900: PUSH
73901: LD_VAR 0 18
73905: PPUSH
73906: LD_INT 22
73908: PUSH
73909: LD_VAR 0 16
73913: PUSH
73914: EMPTY
73915: LIST
73916: LIST
73917: PUSH
73918: LD_INT 58
73920: PUSH
73921: EMPTY
73922: LIST
73923: PUSH
73924: LD_INT 2
73926: PUSH
73927: LD_INT 30
73929: PUSH
73930: LD_INT 32
73932: PUSH
73933: EMPTY
73934: LIST
73935: LIST
73936: PUSH
73937: LD_INT 30
73939: PUSH
73940: LD_INT 4
73942: PUSH
73943: EMPTY
73944: LIST
73945: LIST
73946: PUSH
73947: LD_INT 30
73949: PUSH
73950: LD_INT 5
73952: PUSH
73953: EMPTY
73954: LIST
73955: LIST
73956: PUSH
73957: EMPTY
73958: LIST
73959: LIST
73960: LIST
73961: LIST
73962: PUSH
73963: EMPTY
73964: LIST
73965: LIST
73966: LIST
73967: PPUSH
73968: CALL_OW 72
73972: ST_TO_ADDR
73973: GO 74197
73975: LD_INT 2
73977: DOUBLE
73978: EQUAL
73979: IFTRUE 73983
73981: GO 74045
73983: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
73984: LD_ADDR_VAR 0 12
73988: PUSH
73989: LD_VAR 0 18
73993: PPUSH
73994: LD_INT 22
73996: PUSH
73997: LD_VAR 0 16
74001: PUSH
74002: EMPTY
74003: LIST
74004: LIST
74005: PUSH
74006: LD_INT 2
74008: PUSH
74009: LD_INT 30
74011: PUSH
74012: LD_INT 0
74014: PUSH
74015: EMPTY
74016: LIST
74017: LIST
74018: PUSH
74019: LD_INT 30
74021: PUSH
74022: LD_INT 1
74024: PUSH
74025: EMPTY
74026: LIST
74027: LIST
74028: PUSH
74029: EMPTY
74030: LIST
74031: LIST
74032: LIST
74033: PUSH
74034: EMPTY
74035: LIST
74036: LIST
74037: PPUSH
74038: CALL_OW 72
74042: ST_TO_ADDR
74043: GO 74197
74045: LD_INT 3
74047: DOUBLE
74048: EQUAL
74049: IFTRUE 74053
74051: GO 74115
74053: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
74054: LD_ADDR_VAR 0 12
74058: PUSH
74059: LD_VAR 0 18
74063: PPUSH
74064: LD_INT 22
74066: PUSH
74067: LD_VAR 0 16
74071: PUSH
74072: EMPTY
74073: LIST
74074: LIST
74075: PUSH
74076: LD_INT 2
74078: PUSH
74079: LD_INT 30
74081: PUSH
74082: LD_INT 2
74084: PUSH
74085: EMPTY
74086: LIST
74087: LIST
74088: PUSH
74089: LD_INT 30
74091: PUSH
74092: LD_INT 3
74094: PUSH
74095: EMPTY
74096: LIST
74097: LIST
74098: PUSH
74099: EMPTY
74100: LIST
74101: LIST
74102: LIST
74103: PUSH
74104: EMPTY
74105: LIST
74106: LIST
74107: PPUSH
74108: CALL_OW 72
74112: ST_TO_ADDR
74113: GO 74197
74115: LD_INT 4
74117: DOUBLE
74118: EQUAL
74119: IFTRUE 74123
74121: GO 74196
74123: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
74124: LD_ADDR_VAR 0 12
74128: PUSH
74129: LD_VAR 0 18
74133: PPUSH
74134: LD_INT 22
74136: PUSH
74137: LD_VAR 0 16
74141: PUSH
74142: EMPTY
74143: LIST
74144: LIST
74145: PUSH
74146: LD_INT 2
74148: PUSH
74149: LD_INT 30
74151: PUSH
74152: LD_INT 6
74154: PUSH
74155: EMPTY
74156: LIST
74157: LIST
74158: PUSH
74159: LD_INT 30
74161: PUSH
74162: LD_INT 7
74164: PUSH
74165: EMPTY
74166: LIST
74167: LIST
74168: PUSH
74169: LD_INT 30
74171: PUSH
74172: LD_INT 8
74174: PUSH
74175: EMPTY
74176: LIST
74177: LIST
74178: PUSH
74179: EMPTY
74180: LIST
74181: LIST
74182: LIST
74183: LIST
74184: PUSH
74185: EMPTY
74186: LIST
74187: LIST
74188: PPUSH
74189: CALL_OW 72
74193: ST_TO_ADDR
74194: GO 74197
74196: POP
// if i = 1 then
74197: LD_VAR 0 8
74201: PUSH
74202: LD_INT 1
74204: EQUAL
74205: IFFALSE 74316
// begin tmp := [ ] ;
74207: LD_ADDR_VAR 0 19
74211: PUSH
74212: EMPTY
74213: ST_TO_ADDR
// for j in f do
74214: LD_ADDR_VAR 0 9
74218: PUSH
74219: LD_VAR 0 12
74223: PUSH
74224: FOR_IN
74225: IFFALSE 74298
// if GetBType ( j ) = b_bunker then
74227: LD_VAR 0 9
74231: PPUSH
74232: CALL_OW 266
74236: PUSH
74237: LD_INT 32
74239: EQUAL
74240: IFFALSE 74267
// tmp := Insert ( tmp , 1 , j ) else
74242: LD_ADDR_VAR 0 19
74246: PUSH
74247: LD_VAR 0 19
74251: PPUSH
74252: LD_INT 1
74254: PPUSH
74255: LD_VAR 0 9
74259: PPUSH
74260: CALL_OW 2
74264: ST_TO_ADDR
74265: GO 74296
// tmp := Insert ( tmp , tmp + 1 , j ) ;
74267: LD_ADDR_VAR 0 19
74271: PUSH
74272: LD_VAR 0 19
74276: PPUSH
74277: LD_VAR 0 19
74281: PUSH
74282: LD_INT 1
74284: PLUS
74285: PPUSH
74286: LD_VAR 0 9
74290: PPUSH
74291: CALL_OW 2
74295: ST_TO_ADDR
74296: GO 74224
74298: POP
74299: POP
// if tmp then
74300: LD_VAR 0 19
74304: IFFALSE 74316
// f := tmp ;
74306: LD_ADDR_VAR 0 12
74310: PUSH
74311: LD_VAR 0 19
74315: ST_TO_ADDR
// end ; x := personel [ i ] ;
74316: LD_ADDR_VAR 0 13
74320: PUSH
74321: LD_VAR 0 6
74325: PUSH
74326: LD_VAR 0 8
74330: ARRAY
74331: ST_TO_ADDR
// if x = - 1 then
74332: LD_VAR 0 13
74336: PUSH
74337: LD_INT 1
74339: NEG
74340: EQUAL
74341: IFFALSE 74550
// begin for j in f do
74343: LD_ADDR_VAR 0 9
74347: PUSH
74348: LD_VAR 0 12
74352: PUSH
74353: FOR_IN
74354: IFFALSE 74546
// repeat InitHc ;
74356: CALL_OW 19
// if GetBType ( j ) = b_barracks then
74360: LD_VAR 0 9
74364: PPUSH
74365: CALL_OW 266
74369: PUSH
74370: LD_INT 5
74372: EQUAL
74373: IFFALSE 74443
// begin if UnitsInside ( j ) < 3 then
74375: LD_VAR 0 9
74379: PPUSH
74380: CALL_OW 313
74384: PUSH
74385: LD_INT 3
74387: LESS
74388: IFFALSE 74424
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74390: LD_INT 0
74392: PPUSH
74393: LD_INT 5
74395: PUSH
74396: LD_INT 8
74398: PUSH
74399: LD_INT 9
74401: PUSH
74402: EMPTY
74403: LIST
74404: LIST
74405: LIST
74406: PUSH
74407: LD_VAR 0 17
74411: ARRAY
74412: PPUSH
74413: LD_VAR 0 4
74417: PPUSH
74418: CALL_OW 380
74422: GO 74441
// PrepareHuman ( false , i , skill ) ;
74424: LD_INT 0
74426: PPUSH
74427: LD_VAR 0 8
74431: PPUSH
74432: LD_VAR 0 4
74436: PPUSH
74437: CALL_OW 380
// end else
74441: GO 74460
// PrepareHuman ( false , i , skill ) ;
74443: LD_INT 0
74445: PPUSH
74446: LD_VAR 0 8
74450: PPUSH
74451: LD_VAR 0 4
74455: PPUSH
74456: CALL_OW 380
// un := CreateHuman ;
74460: LD_ADDR_VAR 0 14
74464: PUSH
74465: CALL_OW 44
74469: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74470: LD_ADDR_VAR 0 7
74474: PUSH
74475: LD_VAR 0 7
74479: PPUSH
74480: LD_INT 1
74482: PPUSH
74483: LD_VAR 0 14
74487: PPUSH
74488: CALL_OW 2
74492: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
74493: LD_VAR 0 14
74497: PPUSH
74498: LD_VAR 0 9
74502: PPUSH
74503: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
74507: LD_VAR 0 9
74511: PPUSH
74512: CALL_OW 313
74516: PUSH
74517: LD_INT 6
74519: EQUAL
74520: PUSH
74521: LD_VAR 0 9
74525: PPUSH
74526: CALL_OW 266
74530: PUSH
74531: LD_INT 32
74533: PUSH
74534: LD_INT 31
74536: PUSH
74537: EMPTY
74538: LIST
74539: LIST
74540: IN
74541: OR
74542: IFFALSE 74356
74544: GO 74353
74546: POP
74547: POP
// end else
74548: GO 74930
// for j = 1 to x do
74550: LD_ADDR_VAR 0 9
74554: PUSH
74555: DOUBLE
74556: LD_INT 1
74558: DEC
74559: ST_TO_ADDR
74560: LD_VAR 0 13
74564: PUSH
74565: FOR_TO
74566: IFFALSE 74928
// begin InitHc ;
74568: CALL_OW 19
// if not f then
74572: LD_VAR 0 12
74576: NOT
74577: IFFALSE 74666
// begin PrepareHuman ( false , i , skill ) ;
74579: LD_INT 0
74581: PPUSH
74582: LD_VAR 0 8
74586: PPUSH
74587: LD_VAR 0 4
74591: PPUSH
74592: CALL_OW 380
// un := CreateHuman ;
74596: LD_ADDR_VAR 0 14
74600: PUSH
74601: CALL_OW 44
74605: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74606: LD_ADDR_VAR 0 7
74610: PUSH
74611: LD_VAR 0 7
74615: PPUSH
74616: LD_INT 1
74618: PPUSH
74619: LD_VAR 0 14
74623: PPUSH
74624: CALL_OW 2
74628: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74629: LD_VAR 0 14
74633: PPUSH
74634: LD_VAR 0 1
74638: PPUSH
74639: CALL_OW 250
74643: PPUSH
74644: LD_VAR 0 1
74648: PPUSH
74649: CALL_OW 251
74653: PPUSH
74654: LD_INT 10
74656: PPUSH
74657: LD_INT 0
74659: PPUSH
74660: CALL_OW 50
// continue ;
74664: GO 74565
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
74666: LD_VAR 0 12
74670: PUSH
74671: LD_INT 1
74673: ARRAY
74674: PPUSH
74675: CALL_OW 313
74679: PUSH
74680: LD_VAR 0 12
74684: PUSH
74685: LD_INT 1
74687: ARRAY
74688: PPUSH
74689: CALL_OW 266
74693: PUSH
74694: LD_INT 32
74696: PUSH
74697: LD_INT 31
74699: PUSH
74700: EMPTY
74701: LIST
74702: LIST
74703: IN
74704: AND
74705: PUSH
74706: LD_VAR 0 12
74710: PUSH
74711: LD_INT 1
74713: ARRAY
74714: PPUSH
74715: CALL_OW 313
74719: PUSH
74720: LD_INT 6
74722: EQUAL
74723: OR
74724: IFFALSE 74744
// f := Delete ( f , 1 ) ;
74726: LD_ADDR_VAR 0 12
74730: PUSH
74731: LD_VAR 0 12
74735: PPUSH
74736: LD_INT 1
74738: PPUSH
74739: CALL_OW 3
74743: ST_TO_ADDR
// if not f then
74744: LD_VAR 0 12
74748: NOT
74749: IFFALSE 74767
// begin x := x + 2 ;
74751: LD_ADDR_VAR 0 13
74755: PUSH
74756: LD_VAR 0 13
74760: PUSH
74761: LD_INT 2
74763: PLUS
74764: ST_TO_ADDR
// continue ;
74765: GO 74565
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
74767: LD_VAR 0 12
74771: PUSH
74772: LD_INT 1
74774: ARRAY
74775: PPUSH
74776: CALL_OW 266
74780: PUSH
74781: LD_INT 5
74783: EQUAL
74784: IFFALSE 74858
// begin if UnitsInside ( f [ 1 ] ) < 3 then
74786: LD_VAR 0 12
74790: PUSH
74791: LD_INT 1
74793: ARRAY
74794: PPUSH
74795: CALL_OW 313
74799: PUSH
74800: LD_INT 3
74802: LESS
74803: IFFALSE 74839
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74805: LD_INT 0
74807: PPUSH
74808: LD_INT 5
74810: PUSH
74811: LD_INT 8
74813: PUSH
74814: LD_INT 9
74816: PUSH
74817: EMPTY
74818: LIST
74819: LIST
74820: LIST
74821: PUSH
74822: LD_VAR 0 17
74826: ARRAY
74827: PPUSH
74828: LD_VAR 0 4
74832: PPUSH
74833: CALL_OW 380
74837: GO 74856
// PrepareHuman ( false , i , skill ) ;
74839: LD_INT 0
74841: PPUSH
74842: LD_VAR 0 8
74846: PPUSH
74847: LD_VAR 0 4
74851: PPUSH
74852: CALL_OW 380
// end else
74856: GO 74875
// PrepareHuman ( false , i , skill ) ;
74858: LD_INT 0
74860: PPUSH
74861: LD_VAR 0 8
74865: PPUSH
74866: LD_VAR 0 4
74870: PPUSH
74871: CALL_OW 380
// un := CreateHuman ;
74875: LD_ADDR_VAR 0 14
74879: PUSH
74880: CALL_OW 44
74884: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74885: LD_ADDR_VAR 0 7
74889: PUSH
74890: LD_VAR 0 7
74894: PPUSH
74895: LD_INT 1
74897: PPUSH
74898: LD_VAR 0 14
74902: PPUSH
74903: CALL_OW 2
74907: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
74908: LD_VAR 0 14
74912: PPUSH
74913: LD_VAR 0 12
74917: PUSH
74918: LD_INT 1
74920: ARRAY
74921: PPUSH
74922: CALL_OW 52
// end ;
74926: GO 74565
74928: POP
74929: POP
// end ;
74930: GO 73867
74932: POP
74933: POP
// result := result ^ buildings ;
74934: LD_ADDR_VAR 0 7
74938: PUSH
74939: LD_VAR 0 7
74943: PUSH
74944: LD_VAR 0 18
74948: ADD
74949: ST_TO_ADDR
// end else
74950: GO 75093
// begin for i = 1 to personel do
74952: LD_ADDR_VAR 0 8
74956: PUSH
74957: DOUBLE
74958: LD_INT 1
74960: DEC
74961: ST_TO_ADDR
74962: LD_VAR 0 6
74966: PUSH
74967: FOR_TO
74968: IFFALSE 75091
// begin if i > 4 then
74970: LD_VAR 0 8
74974: PUSH
74975: LD_INT 4
74977: GREATER
74978: IFFALSE 74982
// break ;
74980: GO 75091
// x := personel [ i ] ;
74982: LD_ADDR_VAR 0 13
74986: PUSH
74987: LD_VAR 0 6
74991: PUSH
74992: LD_VAR 0 8
74996: ARRAY
74997: ST_TO_ADDR
// if x = - 1 then
74998: LD_VAR 0 13
75002: PUSH
75003: LD_INT 1
75005: NEG
75006: EQUAL
75007: IFFALSE 75011
// continue ;
75009: GO 74967
// PrepareHuman ( false , i , skill ) ;
75011: LD_INT 0
75013: PPUSH
75014: LD_VAR 0 8
75018: PPUSH
75019: LD_VAR 0 4
75023: PPUSH
75024: CALL_OW 380
// un := CreateHuman ;
75028: LD_ADDR_VAR 0 14
75032: PUSH
75033: CALL_OW 44
75037: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75038: LD_VAR 0 14
75042: PPUSH
75043: LD_VAR 0 1
75047: PPUSH
75048: CALL_OW 250
75052: PPUSH
75053: LD_VAR 0 1
75057: PPUSH
75058: CALL_OW 251
75062: PPUSH
75063: LD_INT 10
75065: PPUSH
75066: LD_INT 0
75068: PPUSH
75069: CALL_OW 50
// result := result ^ un ;
75073: LD_ADDR_VAR 0 7
75077: PUSH
75078: LD_VAR 0 7
75082: PUSH
75083: LD_VAR 0 14
75087: ADD
75088: ST_TO_ADDR
// end ;
75089: GO 74967
75091: POP
75092: POP
// end ; end ;
75093: LD_VAR 0 7
75097: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
75098: LD_INT 0
75100: PPUSH
75101: PPUSH
75102: PPUSH
75103: PPUSH
75104: PPUSH
75105: PPUSH
75106: PPUSH
75107: PPUSH
75108: PPUSH
75109: PPUSH
75110: PPUSH
75111: PPUSH
75112: PPUSH
75113: PPUSH
75114: PPUSH
75115: PPUSH
// result := false ;
75116: LD_ADDR_VAR 0 3
75120: PUSH
75121: LD_INT 0
75123: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
75124: LD_VAR 0 1
75128: NOT
75129: PUSH
75130: LD_VAR 0 1
75134: PPUSH
75135: CALL_OW 266
75139: PUSH
75140: LD_INT 32
75142: PUSH
75143: LD_INT 33
75145: PUSH
75146: EMPTY
75147: LIST
75148: LIST
75149: IN
75150: NOT
75151: OR
75152: IFFALSE 75156
// exit ;
75154: GO 76292
// nat := GetNation ( tower ) ;
75156: LD_ADDR_VAR 0 12
75160: PUSH
75161: LD_VAR 0 1
75165: PPUSH
75166: CALL_OW 248
75170: ST_TO_ADDR
// side := GetSide ( tower ) ;
75171: LD_ADDR_VAR 0 16
75175: PUSH
75176: LD_VAR 0 1
75180: PPUSH
75181: CALL_OW 255
75185: ST_TO_ADDR
// x := GetX ( tower ) ;
75186: LD_ADDR_VAR 0 10
75190: PUSH
75191: LD_VAR 0 1
75195: PPUSH
75196: CALL_OW 250
75200: ST_TO_ADDR
// y := GetY ( tower ) ;
75201: LD_ADDR_VAR 0 11
75205: PUSH
75206: LD_VAR 0 1
75210: PPUSH
75211: CALL_OW 251
75215: ST_TO_ADDR
// if not x or not y then
75216: LD_VAR 0 10
75220: NOT
75221: PUSH
75222: LD_VAR 0 11
75226: NOT
75227: OR
75228: IFFALSE 75232
// exit ;
75230: GO 76292
// weapon := 0 ;
75232: LD_ADDR_VAR 0 18
75236: PUSH
75237: LD_INT 0
75239: ST_TO_ADDR
// fac_list := [ ] ;
75240: LD_ADDR_VAR 0 17
75244: PUSH
75245: EMPTY
75246: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
75247: LD_ADDR_VAR 0 6
75251: PUSH
75252: LD_VAR 0 1
75256: PPUSH
75257: CALL_OW 274
75261: PPUSH
75262: LD_VAR 0 2
75266: PPUSH
75267: CALL 72870 0 2
75271: PPUSH
75272: LD_INT 30
75274: PUSH
75275: LD_INT 3
75277: PUSH
75278: EMPTY
75279: LIST
75280: LIST
75281: PPUSH
75282: CALL_OW 72
75286: ST_TO_ADDR
// if not factories then
75287: LD_VAR 0 6
75291: NOT
75292: IFFALSE 75296
// exit ;
75294: GO 76292
// for i in factories do
75296: LD_ADDR_VAR 0 8
75300: PUSH
75301: LD_VAR 0 6
75305: PUSH
75306: FOR_IN
75307: IFFALSE 75332
// fac_list := fac_list union AvailableWeaponList ( i ) ;
75309: LD_ADDR_VAR 0 17
75313: PUSH
75314: LD_VAR 0 17
75318: PUSH
75319: LD_VAR 0 8
75323: PPUSH
75324: CALL_OW 478
75328: UNION
75329: ST_TO_ADDR
75330: GO 75306
75332: POP
75333: POP
// if not fac_list then
75334: LD_VAR 0 17
75338: NOT
75339: IFFALSE 75343
// exit ;
75341: GO 76292
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
75343: LD_ADDR_VAR 0 5
75347: PUSH
75348: LD_INT 4
75350: PUSH
75351: LD_INT 5
75353: PUSH
75354: LD_INT 9
75356: PUSH
75357: LD_INT 10
75359: PUSH
75360: LD_INT 6
75362: PUSH
75363: LD_INT 7
75365: PUSH
75366: LD_INT 11
75368: PUSH
75369: EMPTY
75370: LIST
75371: LIST
75372: LIST
75373: LIST
75374: LIST
75375: LIST
75376: LIST
75377: PUSH
75378: LD_INT 27
75380: PUSH
75381: LD_INT 28
75383: PUSH
75384: LD_INT 26
75386: PUSH
75387: LD_INT 30
75389: PUSH
75390: EMPTY
75391: LIST
75392: LIST
75393: LIST
75394: LIST
75395: PUSH
75396: LD_INT 43
75398: PUSH
75399: LD_INT 44
75401: PUSH
75402: LD_INT 46
75404: PUSH
75405: LD_INT 45
75407: PUSH
75408: LD_INT 47
75410: PUSH
75411: LD_INT 49
75413: PUSH
75414: EMPTY
75415: LIST
75416: LIST
75417: LIST
75418: LIST
75419: LIST
75420: LIST
75421: PUSH
75422: EMPTY
75423: LIST
75424: LIST
75425: LIST
75426: PUSH
75427: LD_VAR 0 12
75431: ARRAY
75432: ST_TO_ADDR
// for i in list do
75433: LD_ADDR_VAR 0 8
75437: PUSH
75438: LD_VAR 0 5
75442: PUSH
75443: FOR_IN
75444: IFFALSE 75477
// if not i in fac_list then
75446: LD_VAR 0 8
75450: PUSH
75451: LD_VAR 0 17
75455: IN
75456: NOT
75457: IFFALSE 75475
// list := list diff i ;
75459: LD_ADDR_VAR 0 5
75463: PUSH
75464: LD_VAR 0 5
75468: PUSH
75469: LD_VAR 0 8
75473: DIFF
75474: ST_TO_ADDR
75475: GO 75443
75477: POP
75478: POP
// if not list then
75479: LD_VAR 0 5
75483: NOT
75484: IFFALSE 75488
// exit ;
75486: GO 76292
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
75488: LD_VAR 0 12
75492: PUSH
75493: LD_INT 3
75495: EQUAL
75496: PUSH
75497: LD_INT 49
75499: PUSH
75500: LD_VAR 0 5
75504: IN
75505: AND
75506: PUSH
75507: LD_INT 31
75509: PPUSH
75510: LD_VAR 0 16
75514: PPUSH
75515: CALL_OW 321
75519: PUSH
75520: LD_INT 2
75522: EQUAL
75523: AND
75524: IFFALSE 75584
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
75526: LD_INT 22
75528: PUSH
75529: LD_VAR 0 16
75533: PUSH
75534: EMPTY
75535: LIST
75536: LIST
75537: PUSH
75538: LD_INT 35
75540: PUSH
75541: LD_INT 49
75543: PUSH
75544: EMPTY
75545: LIST
75546: LIST
75547: PUSH
75548: LD_INT 91
75550: PUSH
75551: LD_VAR 0 1
75555: PUSH
75556: LD_INT 10
75558: PUSH
75559: EMPTY
75560: LIST
75561: LIST
75562: LIST
75563: PUSH
75564: EMPTY
75565: LIST
75566: LIST
75567: LIST
75568: PPUSH
75569: CALL_OW 69
75573: NOT
75574: IFFALSE 75584
// weapon := ru_time_lapser ;
75576: LD_ADDR_VAR 0 18
75580: PUSH
75581: LD_INT 49
75583: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
75584: LD_VAR 0 12
75588: PUSH
75589: LD_INT 1
75591: PUSH
75592: LD_INT 2
75594: PUSH
75595: EMPTY
75596: LIST
75597: LIST
75598: IN
75599: PUSH
75600: LD_INT 11
75602: PUSH
75603: LD_VAR 0 5
75607: IN
75608: PUSH
75609: LD_INT 30
75611: PUSH
75612: LD_VAR 0 5
75616: IN
75617: OR
75618: AND
75619: PUSH
75620: LD_INT 6
75622: PPUSH
75623: LD_VAR 0 16
75627: PPUSH
75628: CALL_OW 321
75632: PUSH
75633: LD_INT 2
75635: EQUAL
75636: AND
75637: IFFALSE 75802
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
75639: LD_INT 22
75641: PUSH
75642: LD_VAR 0 16
75646: PUSH
75647: EMPTY
75648: LIST
75649: LIST
75650: PUSH
75651: LD_INT 2
75653: PUSH
75654: LD_INT 35
75656: PUSH
75657: LD_INT 11
75659: PUSH
75660: EMPTY
75661: LIST
75662: LIST
75663: PUSH
75664: LD_INT 35
75666: PUSH
75667: LD_INT 30
75669: PUSH
75670: EMPTY
75671: LIST
75672: LIST
75673: PUSH
75674: EMPTY
75675: LIST
75676: LIST
75677: LIST
75678: PUSH
75679: LD_INT 91
75681: PUSH
75682: LD_VAR 0 1
75686: PUSH
75687: LD_INT 18
75689: PUSH
75690: EMPTY
75691: LIST
75692: LIST
75693: LIST
75694: PUSH
75695: EMPTY
75696: LIST
75697: LIST
75698: LIST
75699: PPUSH
75700: CALL_OW 69
75704: NOT
75705: PUSH
75706: LD_INT 22
75708: PUSH
75709: LD_VAR 0 16
75713: PUSH
75714: EMPTY
75715: LIST
75716: LIST
75717: PUSH
75718: LD_INT 2
75720: PUSH
75721: LD_INT 30
75723: PUSH
75724: LD_INT 32
75726: PUSH
75727: EMPTY
75728: LIST
75729: LIST
75730: PUSH
75731: LD_INT 30
75733: PUSH
75734: LD_INT 33
75736: PUSH
75737: EMPTY
75738: LIST
75739: LIST
75740: PUSH
75741: EMPTY
75742: LIST
75743: LIST
75744: LIST
75745: PUSH
75746: LD_INT 91
75748: PUSH
75749: LD_VAR 0 1
75753: PUSH
75754: LD_INT 12
75756: PUSH
75757: EMPTY
75758: LIST
75759: LIST
75760: LIST
75761: PUSH
75762: EMPTY
75763: LIST
75764: LIST
75765: LIST
75766: PUSH
75767: EMPTY
75768: LIST
75769: PPUSH
75770: CALL_OW 69
75774: PUSH
75775: LD_INT 2
75777: GREATER
75778: AND
75779: IFFALSE 75802
// weapon := [ us_radar , ar_radar ] [ nat ] ;
75781: LD_ADDR_VAR 0 18
75785: PUSH
75786: LD_INT 11
75788: PUSH
75789: LD_INT 30
75791: PUSH
75792: EMPTY
75793: LIST
75794: LIST
75795: PUSH
75796: LD_VAR 0 12
75800: ARRAY
75801: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
75802: LD_VAR 0 18
75806: NOT
75807: PUSH
75808: LD_INT 40
75810: PPUSH
75811: LD_VAR 0 16
75815: PPUSH
75816: CALL_OW 321
75820: PUSH
75821: LD_INT 2
75823: EQUAL
75824: AND
75825: PUSH
75826: LD_INT 7
75828: PUSH
75829: LD_VAR 0 5
75833: IN
75834: PUSH
75835: LD_INT 28
75837: PUSH
75838: LD_VAR 0 5
75842: IN
75843: OR
75844: PUSH
75845: LD_INT 45
75847: PUSH
75848: LD_VAR 0 5
75852: IN
75853: OR
75854: AND
75855: IFFALSE 76109
// begin hex := GetHexInfo ( x , y ) ;
75857: LD_ADDR_VAR 0 4
75861: PUSH
75862: LD_VAR 0 10
75866: PPUSH
75867: LD_VAR 0 11
75871: PPUSH
75872: CALL_OW 546
75876: ST_TO_ADDR
// if hex [ 1 ] then
75877: LD_VAR 0 4
75881: PUSH
75882: LD_INT 1
75884: ARRAY
75885: IFFALSE 75889
// exit ;
75887: GO 76292
// height := hex [ 2 ] ;
75889: LD_ADDR_VAR 0 15
75893: PUSH
75894: LD_VAR 0 4
75898: PUSH
75899: LD_INT 2
75901: ARRAY
75902: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
75903: LD_ADDR_VAR 0 14
75907: PUSH
75908: LD_INT 0
75910: PUSH
75911: LD_INT 2
75913: PUSH
75914: LD_INT 3
75916: PUSH
75917: LD_INT 5
75919: PUSH
75920: EMPTY
75921: LIST
75922: LIST
75923: LIST
75924: LIST
75925: ST_TO_ADDR
// for i in tmp do
75926: LD_ADDR_VAR 0 8
75930: PUSH
75931: LD_VAR 0 14
75935: PUSH
75936: FOR_IN
75937: IFFALSE 76107
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
75939: LD_ADDR_VAR 0 9
75943: PUSH
75944: LD_VAR 0 10
75948: PPUSH
75949: LD_VAR 0 8
75953: PPUSH
75954: LD_INT 5
75956: PPUSH
75957: CALL_OW 272
75961: PUSH
75962: LD_VAR 0 11
75966: PPUSH
75967: LD_VAR 0 8
75971: PPUSH
75972: LD_INT 5
75974: PPUSH
75975: CALL_OW 273
75979: PUSH
75980: EMPTY
75981: LIST
75982: LIST
75983: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
75984: LD_VAR 0 9
75988: PUSH
75989: LD_INT 1
75991: ARRAY
75992: PPUSH
75993: LD_VAR 0 9
75997: PUSH
75998: LD_INT 2
76000: ARRAY
76001: PPUSH
76002: CALL_OW 488
76006: IFFALSE 76105
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
76008: LD_ADDR_VAR 0 4
76012: PUSH
76013: LD_VAR 0 9
76017: PUSH
76018: LD_INT 1
76020: ARRAY
76021: PPUSH
76022: LD_VAR 0 9
76026: PUSH
76027: LD_INT 2
76029: ARRAY
76030: PPUSH
76031: CALL_OW 546
76035: ST_TO_ADDR
// if hex [ 1 ] then
76036: LD_VAR 0 4
76040: PUSH
76041: LD_INT 1
76043: ARRAY
76044: IFFALSE 76048
// continue ;
76046: GO 75936
// h := hex [ 2 ] ;
76048: LD_ADDR_VAR 0 13
76052: PUSH
76053: LD_VAR 0 4
76057: PUSH
76058: LD_INT 2
76060: ARRAY
76061: ST_TO_ADDR
// if h + 7 < height then
76062: LD_VAR 0 13
76066: PUSH
76067: LD_INT 7
76069: PLUS
76070: PUSH
76071: LD_VAR 0 15
76075: LESS
76076: IFFALSE 76105
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
76078: LD_ADDR_VAR 0 18
76082: PUSH
76083: LD_INT 7
76085: PUSH
76086: LD_INT 28
76088: PUSH
76089: LD_INT 45
76091: PUSH
76092: EMPTY
76093: LIST
76094: LIST
76095: LIST
76096: PUSH
76097: LD_VAR 0 12
76101: ARRAY
76102: ST_TO_ADDR
// break ;
76103: GO 76107
// end ; end ; end ;
76105: GO 75936
76107: POP
76108: POP
// end ; if not weapon then
76109: LD_VAR 0 18
76113: NOT
76114: IFFALSE 76174
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
76116: LD_ADDR_VAR 0 5
76120: PUSH
76121: LD_VAR 0 5
76125: PUSH
76126: LD_INT 11
76128: PUSH
76129: LD_INT 30
76131: PUSH
76132: LD_INT 49
76134: PUSH
76135: EMPTY
76136: LIST
76137: LIST
76138: LIST
76139: DIFF
76140: ST_TO_ADDR
// if not list then
76141: LD_VAR 0 5
76145: NOT
76146: IFFALSE 76150
// exit ;
76148: GO 76292
// weapon := list [ rand ( 1 , list ) ] ;
76150: LD_ADDR_VAR 0 18
76154: PUSH
76155: LD_VAR 0 5
76159: PUSH
76160: LD_INT 1
76162: PPUSH
76163: LD_VAR 0 5
76167: PPUSH
76168: CALL_OW 12
76172: ARRAY
76173: ST_TO_ADDR
// end ; if weapon then
76174: LD_VAR 0 18
76178: IFFALSE 76292
// begin tmp := CostOfWeapon ( weapon ) ;
76180: LD_ADDR_VAR 0 14
76184: PUSH
76185: LD_VAR 0 18
76189: PPUSH
76190: CALL_OW 451
76194: ST_TO_ADDR
// j := GetBase ( tower ) ;
76195: LD_ADDR_VAR 0 9
76199: PUSH
76200: LD_VAR 0 1
76204: PPUSH
76205: CALL_OW 274
76209: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
76210: LD_VAR 0 9
76214: PPUSH
76215: LD_INT 1
76217: PPUSH
76218: CALL_OW 275
76222: PUSH
76223: LD_VAR 0 14
76227: PUSH
76228: LD_INT 1
76230: ARRAY
76231: GREATEREQUAL
76232: PUSH
76233: LD_VAR 0 9
76237: PPUSH
76238: LD_INT 2
76240: PPUSH
76241: CALL_OW 275
76245: PUSH
76246: LD_VAR 0 14
76250: PUSH
76251: LD_INT 2
76253: ARRAY
76254: GREATEREQUAL
76255: AND
76256: PUSH
76257: LD_VAR 0 9
76261: PPUSH
76262: LD_INT 3
76264: PPUSH
76265: CALL_OW 275
76269: PUSH
76270: LD_VAR 0 14
76274: PUSH
76275: LD_INT 3
76277: ARRAY
76278: GREATEREQUAL
76279: AND
76280: IFFALSE 76292
// result := weapon ;
76282: LD_ADDR_VAR 0 3
76286: PUSH
76287: LD_VAR 0 18
76291: ST_TO_ADDR
// end ; end ;
76292: LD_VAR 0 3
76296: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
76297: LD_INT 0
76299: PPUSH
76300: PPUSH
// result := true ;
76301: LD_ADDR_VAR 0 3
76305: PUSH
76306: LD_INT 1
76308: ST_TO_ADDR
// if array1 = array2 then
76309: LD_VAR 0 1
76313: PUSH
76314: LD_VAR 0 2
76318: EQUAL
76319: IFFALSE 76379
// begin for i = 1 to array1 do
76321: LD_ADDR_VAR 0 4
76325: PUSH
76326: DOUBLE
76327: LD_INT 1
76329: DEC
76330: ST_TO_ADDR
76331: LD_VAR 0 1
76335: PUSH
76336: FOR_TO
76337: IFFALSE 76375
// if array1 [ i ] <> array2 [ i ] then
76339: LD_VAR 0 1
76343: PUSH
76344: LD_VAR 0 4
76348: ARRAY
76349: PUSH
76350: LD_VAR 0 2
76354: PUSH
76355: LD_VAR 0 4
76359: ARRAY
76360: NONEQUAL
76361: IFFALSE 76373
// begin result := false ;
76363: LD_ADDR_VAR 0 3
76367: PUSH
76368: LD_INT 0
76370: ST_TO_ADDR
// break ;
76371: GO 76375
// end ;
76373: GO 76336
76375: POP
76376: POP
// end else
76377: GO 76387
// result := false ;
76379: LD_ADDR_VAR 0 3
76383: PUSH
76384: LD_INT 0
76386: ST_TO_ADDR
// end ;
76387: LD_VAR 0 3
76391: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
76392: LD_INT 0
76394: PPUSH
76395: PPUSH
76396: PPUSH
// pom := GetBase ( fac ) ;
76397: LD_ADDR_VAR 0 5
76401: PUSH
76402: LD_VAR 0 1
76406: PPUSH
76407: CALL_OW 274
76411: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
76412: LD_ADDR_VAR 0 4
76416: PUSH
76417: LD_VAR 0 2
76421: PUSH
76422: LD_INT 1
76424: ARRAY
76425: PPUSH
76426: LD_VAR 0 2
76430: PUSH
76431: LD_INT 2
76433: ARRAY
76434: PPUSH
76435: LD_VAR 0 2
76439: PUSH
76440: LD_INT 3
76442: ARRAY
76443: PPUSH
76444: LD_VAR 0 2
76448: PUSH
76449: LD_INT 4
76451: ARRAY
76452: PPUSH
76453: CALL_OW 449
76457: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76458: LD_ADDR_VAR 0 3
76462: PUSH
76463: LD_VAR 0 5
76467: PPUSH
76468: LD_INT 1
76470: PPUSH
76471: CALL_OW 275
76475: PUSH
76476: LD_VAR 0 4
76480: PUSH
76481: LD_INT 1
76483: ARRAY
76484: GREATEREQUAL
76485: PUSH
76486: LD_VAR 0 5
76490: PPUSH
76491: LD_INT 2
76493: PPUSH
76494: CALL_OW 275
76498: PUSH
76499: LD_VAR 0 4
76503: PUSH
76504: LD_INT 2
76506: ARRAY
76507: GREATEREQUAL
76508: AND
76509: PUSH
76510: LD_VAR 0 5
76514: PPUSH
76515: LD_INT 3
76517: PPUSH
76518: CALL_OW 275
76522: PUSH
76523: LD_VAR 0 4
76527: PUSH
76528: LD_INT 3
76530: ARRAY
76531: GREATEREQUAL
76532: AND
76533: ST_TO_ADDR
// end ;
76534: LD_VAR 0 3
76538: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
76539: LD_INT 0
76541: PPUSH
76542: PPUSH
76543: PPUSH
76544: PPUSH
// pom := GetBase ( building ) ;
76545: LD_ADDR_VAR 0 3
76549: PUSH
76550: LD_VAR 0 1
76554: PPUSH
76555: CALL_OW 274
76559: ST_TO_ADDR
// if not pom then
76560: LD_VAR 0 3
76564: NOT
76565: IFFALSE 76569
// exit ;
76567: GO 76739
// btype := GetBType ( building ) ;
76569: LD_ADDR_VAR 0 5
76573: PUSH
76574: LD_VAR 0 1
76578: PPUSH
76579: CALL_OW 266
76583: ST_TO_ADDR
// if btype = b_armoury then
76584: LD_VAR 0 5
76588: PUSH
76589: LD_INT 4
76591: EQUAL
76592: IFFALSE 76602
// btype := b_barracks ;
76594: LD_ADDR_VAR 0 5
76598: PUSH
76599: LD_INT 5
76601: ST_TO_ADDR
// if btype = b_depot then
76602: LD_VAR 0 5
76606: PUSH
76607: LD_INT 0
76609: EQUAL
76610: IFFALSE 76620
// btype := b_warehouse ;
76612: LD_ADDR_VAR 0 5
76616: PUSH
76617: LD_INT 1
76619: ST_TO_ADDR
// if btype = b_workshop then
76620: LD_VAR 0 5
76624: PUSH
76625: LD_INT 2
76627: EQUAL
76628: IFFALSE 76638
// btype := b_factory ;
76630: LD_ADDR_VAR 0 5
76634: PUSH
76635: LD_INT 3
76637: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76638: LD_ADDR_VAR 0 4
76642: PUSH
76643: LD_VAR 0 5
76647: PPUSH
76648: LD_VAR 0 1
76652: PPUSH
76653: CALL_OW 248
76657: PPUSH
76658: CALL_OW 450
76662: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76663: LD_ADDR_VAR 0 2
76667: PUSH
76668: LD_VAR 0 3
76672: PPUSH
76673: LD_INT 1
76675: PPUSH
76676: CALL_OW 275
76680: PUSH
76681: LD_VAR 0 4
76685: PUSH
76686: LD_INT 1
76688: ARRAY
76689: GREATEREQUAL
76690: PUSH
76691: LD_VAR 0 3
76695: PPUSH
76696: LD_INT 2
76698: PPUSH
76699: CALL_OW 275
76703: PUSH
76704: LD_VAR 0 4
76708: PUSH
76709: LD_INT 2
76711: ARRAY
76712: GREATEREQUAL
76713: AND
76714: PUSH
76715: LD_VAR 0 3
76719: PPUSH
76720: LD_INT 3
76722: PPUSH
76723: CALL_OW 275
76727: PUSH
76728: LD_VAR 0 4
76732: PUSH
76733: LD_INT 3
76735: ARRAY
76736: GREATEREQUAL
76737: AND
76738: ST_TO_ADDR
// end ;
76739: LD_VAR 0 2
76743: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
76744: LD_INT 0
76746: PPUSH
76747: PPUSH
76748: PPUSH
// pom := GetBase ( building ) ;
76749: LD_ADDR_VAR 0 4
76753: PUSH
76754: LD_VAR 0 1
76758: PPUSH
76759: CALL_OW 274
76763: ST_TO_ADDR
// if not pom then
76764: LD_VAR 0 4
76768: NOT
76769: IFFALSE 76773
// exit ;
76771: GO 76874
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76773: LD_ADDR_VAR 0 5
76777: PUSH
76778: LD_VAR 0 2
76782: PPUSH
76783: LD_VAR 0 1
76787: PPUSH
76788: CALL_OW 248
76792: PPUSH
76793: CALL_OW 450
76797: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76798: LD_ADDR_VAR 0 3
76802: PUSH
76803: LD_VAR 0 4
76807: PPUSH
76808: LD_INT 1
76810: PPUSH
76811: CALL_OW 275
76815: PUSH
76816: LD_VAR 0 5
76820: PUSH
76821: LD_INT 1
76823: ARRAY
76824: GREATEREQUAL
76825: PUSH
76826: LD_VAR 0 4
76830: PPUSH
76831: LD_INT 2
76833: PPUSH
76834: CALL_OW 275
76838: PUSH
76839: LD_VAR 0 5
76843: PUSH
76844: LD_INT 2
76846: ARRAY
76847: GREATEREQUAL
76848: AND
76849: PUSH
76850: LD_VAR 0 4
76854: PPUSH
76855: LD_INT 3
76857: PPUSH
76858: CALL_OW 275
76862: PUSH
76863: LD_VAR 0 5
76867: PUSH
76868: LD_INT 3
76870: ARRAY
76871: GREATEREQUAL
76872: AND
76873: ST_TO_ADDR
// end ;
76874: LD_VAR 0 3
76878: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
76879: LD_INT 0
76881: PPUSH
76882: PPUSH
76883: PPUSH
76884: PPUSH
76885: PPUSH
76886: PPUSH
76887: PPUSH
76888: PPUSH
76889: PPUSH
76890: PPUSH
// result := false ;
76891: LD_ADDR_VAR 0 6
76895: PUSH
76896: LD_INT 0
76898: ST_TO_ADDR
// if not base or not btype or not x or not y then
76899: LD_VAR 0 1
76903: NOT
76904: PUSH
76905: LD_VAR 0 2
76909: NOT
76910: OR
76911: PUSH
76912: LD_VAR 0 3
76916: NOT
76917: OR
76918: PUSH
76919: LD_VAR 0 4
76923: NOT
76924: OR
76925: IFFALSE 76929
// exit ;
76927: GO 77538
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
76929: LD_ADDR_VAR 0 12
76933: PUSH
76934: LD_VAR 0 2
76938: PPUSH
76939: LD_VAR 0 3
76943: PPUSH
76944: LD_VAR 0 4
76948: PPUSH
76949: LD_VAR 0 5
76953: PPUSH
76954: LD_VAR 0 1
76958: PUSH
76959: LD_INT 1
76961: ARRAY
76962: PPUSH
76963: CALL_OW 248
76967: PPUSH
76968: LD_INT 0
76970: PPUSH
76971: CALL 78375 0 6
76975: ST_TO_ADDR
// if not hexes then
76976: LD_VAR 0 12
76980: NOT
76981: IFFALSE 76985
// exit ;
76983: GO 77538
// for i = 1 to hexes do
76985: LD_ADDR_VAR 0 7
76989: PUSH
76990: DOUBLE
76991: LD_INT 1
76993: DEC
76994: ST_TO_ADDR
76995: LD_VAR 0 12
76999: PUSH
77000: FOR_TO
77001: IFFALSE 77536
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77003: LD_ADDR_VAR 0 11
77007: PUSH
77008: LD_VAR 0 12
77012: PUSH
77013: LD_VAR 0 7
77017: ARRAY
77018: PUSH
77019: LD_INT 1
77021: ARRAY
77022: PPUSH
77023: LD_VAR 0 12
77027: PUSH
77028: LD_VAR 0 7
77032: ARRAY
77033: PUSH
77034: LD_INT 2
77036: ARRAY
77037: PPUSH
77038: CALL_OW 428
77042: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
77043: LD_VAR 0 12
77047: PUSH
77048: LD_VAR 0 7
77052: ARRAY
77053: PUSH
77054: LD_INT 1
77056: ARRAY
77057: PPUSH
77058: LD_VAR 0 12
77062: PUSH
77063: LD_VAR 0 7
77067: ARRAY
77068: PUSH
77069: LD_INT 2
77071: ARRAY
77072: PPUSH
77073: CALL_OW 351
77077: PUSH
77078: LD_VAR 0 12
77082: PUSH
77083: LD_VAR 0 7
77087: ARRAY
77088: PUSH
77089: LD_INT 1
77091: ARRAY
77092: PPUSH
77093: LD_VAR 0 12
77097: PUSH
77098: LD_VAR 0 7
77102: ARRAY
77103: PUSH
77104: LD_INT 2
77106: ARRAY
77107: PPUSH
77108: CALL_OW 488
77112: NOT
77113: OR
77114: PUSH
77115: LD_VAR 0 11
77119: PPUSH
77120: CALL_OW 247
77124: PUSH
77125: LD_INT 3
77127: EQUAL
77128: OR
77129: IFFALSE 77135
// exit ;
77131: POP
77132: POP
77133: GO 77538
// if not tmp or not tmp in base then
77135: LD_VAR 0 11
77139: NOT
77140: PUSH
77141: LD_VAR 0 11
77145: PUSH
77146: LD_VAR 0 1
77150: IN
77151: NOT
77152: OR
77153: IFFALSE 77157
// continue ;
77155: GO 77000
// result := true ;
77157: LD_ADDR_VAR 0 6
77161: PUSH
77162: LD_INT 1
77164: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
77165: LD_ADDR_VAR 0 15
77169: PUSH
77170: LD_VAR 0 1
77174: PPUSH
77175: LD_INT 22
77177: PUSH
77178: LD_VAR 0 11
77182: PPUSH
77183: CALL_OW 255
77187: PUSH
77188: EMPTY
77189: LIST
77190: LIST
77191: PUSH
77192: LD_INT 2
77194: PUSH
77195: LD_INT 30
77197: PUSH
77198: LD_INT 0
77200: PUSH
77201: EMPTY
77202: LIST
77203: LIST
77204: PUSH
77205: LD_INT 30
77207: PUSH
77208: LD_INT 1
77210: PUSH
77211: EMPTY
77212: LIST
77213: LIST
77214: PUSH
77215: EMPTY
77216: LIST
77217: LIST
77218: LIST
77219: PUSH
77220: EMPTY
77221: LIST
77222: LIST
77223: PPUSH
77224: CALL_OW 72
77228: ST_TO_ADDR
// if dep then
77229: LD_VAR 0 15
77233: IFFALSE 77369
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
77235: LD_ADDR_VAR 0 14
77239: PUSH
77240: LD_VAR 0 15
77244: PUSH
77245: LD_INT 1
77247: ARRAY
77248: PPUSH
77249: CALL_OW 250
77253: PPUSH
77254: LD_VAR 0 15
77258: PUSH
77259: LD_INT 1
77261: ARRAY
77262: PPUSH
77263: CALL_OW 254
77267: PPUSH
77268: LD_INT 5
77270: PPUSH
77271: CALL_OW 272
77275: PUSH
77276: LD_VAR 0 15
77280: PUSH
77281: LD_INT 1
77283: ARRAY
77284: PPUSH
77285: CALL_OW 251
77289: PPUSH
77290: LD_VAR 0 15
77294: PUSH
77295: LD_INT 1
77297: ARRAY
77298: PPUSH
77299: CALL_OW 254
77303: PPUSH
77304: LD_INT 5
77306: PPUSH
77307: CALL_OW 273
77311: PUSH
77312: EMPTY
77313: LIST
77314: LIST
77315: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
77316: LD_VAR 0 14
77320: PUSH
77321: LD_INT 1
77323: ARRAY
77324: PPUSH
77325: LD_VAR 0 14
77329: PUSH
77330: LD_INT 2
77332: ARRAY
77333: PPUSH
77334: CALL_OW 488
77338: IFFALSE 77369
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
77340: LD_VAR 0 11
77344: PPUSH
77345: LD_VAR 0 14
77349: PUSH
77350: LD_INT 1
77352: ARRAY
77353: PPUSH
77354: LD_VAR 0 14
77358: PUSH
77359: LD_INT 2
77361: ARRAY
77362: PPUSH
77363: CALL_OW 111
// continue ;
77367: GO 77000
// end ; end ; r := GetDir ( tmp ) ;
77369: LD_ADDR_VAR 0 13
77373: PUSH
77374: LD_VAR 0 11
77378: PPUSH
77379: CALL_OW 254
77383: ST_TO_ADDR
// if r = 5 then
77384: LD_VAR 0 13
77388: PUSH
77389: LD_INT 5
77391: EQUAL
77392: IFFALSE 77402
// r := 0 ;
77394: LD_ADDR_VAR 0 13
77398: PUSH
77399: LD_INT 0
77401: ST_TO_ADDR
// for j = r to 5 do
77402: LD_ADDR_VAR 0 8
77406: PUSH
77407: DOUBLE
77408: LD_VAR 0 13
77412: DEC
77413: ST_TO_ADDR
77414: LD_INT 5
77416: PUSH
77417: FOR_TO
77418: IFFALSE 77532
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
77420: LD_ADDR_VAR 0 9
77424: PUSH
77425: LD_VAR 0 11
77429: PPUSH
77430: CALL_OW 250
77434: PPUSH
77435: LD_VAR 0 8
77439: PPUSH
77440: LD_INT 2
77442: PPUSH
77443: CALL_OW 272
77447: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
77448: LD_ADDR_VAR 0 10
77452: PUSH
77453: LD_VAR 0 11
77457: PPUSH
77458: CALL_OW 251
77462: PPUSH
77463: LD_VAR 0 8
77467: PPUSH
77468: LD_INT 2
77470: PPUSH
77471: CALL_OW 273
77475: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
77476: LD_VAR 0 9
77480: PPUSH
77481: LD_VAR 0 10
77485: PPUSH
77486: CALL_OW 488
77490: PUSH
77491: LD_VAR 0 9
77495: PPUSH
77496: LD_VAR 0 10
77500: PPUSH
77501: CALL_OW 428
77505: NOT
77506: AND
77507: IFFALSE 77530
// begin ComMoveXY ( tmp , _x , _y ) ;
77509: LD_VAR 0 11
77513: PPUSH
77514: LD_VAR 0 9
77518: PPUSH
77519: LD_VAR 0 10
77523: PPUSH
77524: CALL_OW 111
// break ;
77528: GO 77532
// end ; end ;
77530: GO 77417
77532: POP
77533: POP
// end ;
77534: GO 77000
77536: POP
77537: POP
// end ;
77538: LD_VAR 0 6
77542: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
77543: LD_INT 0
77545: PPUSH
77546: PPUSH
77547: PPUSH
77548: PPUSH
77549: PPUSH
77550: PPUSH
77551: PPUSH
77552: PPUSH
77553: PPUSH
77554: PPUSH
// result := false ;
77555: LD_ADDR_VAR 0 6
77559: PUSH
77560: LD_INT 0
77562: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
77563: LD_VAR 0 1
77567: NOT
77568: PUSH
77569: LD_VAR 0 1
77573: PPUSH
77574: CALL_OW 266
77578: PUSH
77579: LD_INT 0
77581: PUSH
77582: LD_INT 1
77584: PUSH
77585: EMPTY
77586: LIST
77587: LIST
77588: IN
77589: NOT
77590: OR
77591: PUSH
77592: LD_VAR 0 2
77596: NOT
77597: OR
77598: PUSH
77599: LD_VAR 0 5
77603: PUSH
77604: LD_INT 0
77606: PUSH
77607: LD_INT 1
77609: PUSH
77610: LD_INT 2
77612: PUSH
77613: LD_INT 3
77615: PUSH
77616: LD_INT 4
77618: PUSH
77619: LD_INT 5
77621: PUSH
77622: EMPTY
77623: LIST
77624: LIST
77625: LIST
77626: LIST
77627: LIST
77628: LIST
77629: IN
77630: NOT
77631: OR
77632: PUSH
77633: LD_VAR 0 3
77637: PPUSH
77638: LD_VAR 0 4
77642: PPUSH
77643: CALL_OW 488
77647: NOT
77648: OR
77649: IFFALSE 77653
// exit ;
77651: GO 78370
// pom := GetBase ( depot ) ;
77653: LD_ADDR_VAR 0 10
77657: PUSH
77658: LD_VAR 0 1
77662: PPUSH
77663: CALL_OW 274
77667: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
77668: LD_ADDR_VAR 0 11
77672: PUSH
77673: LD_VAR 0 2
77677: PPUSH
77678: LD_VAR 0 1
77682: PPUSH
77683: CALL_OW 248
77687: PPUSH
77688: CALL_OW 450
77692: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
77693: LD_VAR 0 10
77697: PPUSH
77698: LD_INT 1
77700: PPUSH
77701: CALL_OW 275
77705: PUSH
77706: LD_VAR 0 11
77710: PUSH
77711: LD_INT 1
77713: ARRAY
77714: GREATEREQUAL
77715: PUSH
77716: LD_VAR 0 10
77720: PPUSH
77721: LD_INT 2
77723: PPUSH
77724: CALL_OW 275
77728: PUSH
77729: LD_VAR 0 11
77733: PUSH
77734: LD_INT 2
77736: ARRAY
77737: GREATEREQUAL
77738: AND
77739: PUSH
77740: LD_VAR 0 10
77744: PPUSH
77745: LD_INT 3
77747: PPUSH
77748: CALL_OW 275
77752: PUSH
77753: LD_VAR 0 11
77757: PUSH
77758: LD_INT 3
77760: ARRAY
77761: GREATEREQUAL
77762: AND
77763: NOT
77764: IFFALSE 77768
// exit ;
77766: GO 78370
// if GetBType ( depot ) = b_depot then
77768: LD_VAR 0 1
77772: PPUSH
77773: CALL_OW 266
77777: PUSH
77778: LD_INT 0
77780: EQUAL
77781: IFFALSE 77793
// dist := 28 else
77783: LD_ADDR_VAR 0 14
77787: PUSH
77788: LD_INT 28
77790: ST_TO_ADDR
77791: GO 77801
// dist := 36 ;
77793: LD_ADDR_VAR 0 14
77797: PUSH
77798: LD_INT 36
77800: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
77801: LD_VAR 0 1
77805: PPUSH
77806: LD_VAR 0 3
77810: PPUSH
77811: LD_VAR 0 4
77815: PPUSH
77816: CALL_OW 297
77820: PUSH
77821: LD_VAR 0 14
77825: GREATER
77826: IFFALSE 77830
// exit ;
77828: GO 78370
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
77830: LD_ADDR_VAR 0 12
77834: PUSH
77835: LD_VAR 0 2
77839: PPUSH
77840: LD_VAR 0 3
77844: PPUSH
77845: LD_VAR 0 4
77849: PPUSH
77850: LD_VAR 0 5
77854: PPUSH
77855: LD_VAR 0 1
77859: PPUSH
77860: CALL_OW 248
77864: PPUSH
77865: LD_INT 0
77867: PPUSH
77868: CALL 78375 0 6
77872: ST_TO_ADDR
// if not hexes then
77873: LD_VAR 0 12
77877: NOT
77878: IFFALSE 77882
// exit ;
77880: GO 78370
// hex := GetHexInfo ( x , y ) ;
77882: LD_ADDR_VAR 0 15
77886: PUSH
77887: LD_VAR 0 3
77891: PPUSH
77892: LD_VAR 0 4
77896: PPUSH
77897: CALL_OW 546
77901: ST_TO_ADDR
// if hex [ 1 ] then
77902: LD_VAR 0 15
77906: PUSH
77907: LD_INT 1
77909: ARRAY
77910: IFFALSE 77914
// exit ;
77912: GO 78370
// height := hex [ 2 ] ;
77914: LD_ADDR_VAR 0 13
77918: PUSH
77919: LD_VAR 0 15
77923: PUSH
77924: LD_INT 2
77926: ARRAY
77927: ST_TO_ADDR
// for i = 1 to hexes do
77928: LD_ADDR_VAR 0 7
77932: PUSH
77933: DOUBLE
77934: LD_INT 1
77936: DEC
77937: ST_TO_ADDR
77938: LD_VAR 0 12
77942: PUSH
77943: FOR_TO
77944: IFFALSE 78274
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
77946: LD_VAR 0 12
77950: PUSH
77951: LD_VAR 0 7
77955: ARRAY
77956: PUSH
77957: LD_INT 1
77959: ARRAY
77960: PPUSH
77961: LD_VAR 0 12
77965: PUSH
77966: LD_VAR 0 7
77970: ARRAY
77971: PUSH
77972: LD_INT 2
77974: ARRAY
77975: PPUSH
77976: CALL_OW 488
77980: NOT
77981: PUSH
77982: LD_VAR 0 12
77986: PUSH
77987: LD_VAR 0 7
77991: ARRAY
77992: PUSH
77993: LD_INT 1
77995: ARRAY
77996: PPUSH
77997: LD_VAR 0 12
78001: PUSH
78002: LD_VAR 0 7
78006: ARRAY
78007: PUSH
78008: LD_INT 2
78010: ARRAY
78011: PPUSH
78012: CALL_OW 428
78016: PUSH
78017: LD_INT 0
78019: GREATER
78020: OR
78021: PUSH
78022: LD_VAR 0 12
78026: PUSH
78027: LD_VAR 0 7
78031: ARRAY
78032: PUSH
78033: LD_INT 1
78035: ARRAY
78036: PPUSH
78037: LD_VAR 0 12
78041: PUSH
78042: LD_VAR 0 7
78046: ARRAY
78047: PUSH
78048: LD_INT 2
78050: ARRAY
78051: PPUSH
78052: CALL_OW 351
78056: OR
78057: IFFALSE 78063
// exit ;
78059: POP
78060: POP
78061: GO 78370
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78063: LD_ADDR_VAR 0 8
78067: PUSH
78068: LD_VAR 0 12
78072: PUSH
78073: LD_VAR 0 7
78077: ARRAY
78078: PUSH
78079: LD_INT 1
78081: ARRAY
78082: PPUSH
78083: LD_VAR 0 12
78087: PUSH
78088: LD_VAR 0 7
78092: ARRAY
78093: PUSH
78094: LD_INT 2
78096: ARRAY
78097: PPUSH
78098: CALL_OW 546
78102: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
78103: LD_VAR 0 8
78107: PUSH
78108: LD_INT 1
78110: ARRAY
78111: PUSH
78112: LD_VAR 0 8
78116: PUSH
78117: LD_INT 2
78119: ARRAY
78120: PUSH
78121: LD_VAR 0 13
78125: PUSH
78126: LD_INT 2
78128: PLUS
78129: GREATER
78130: OR
78131: PUSH
78132: LD_VAR 0 8
78136: PUSH
78137: LD_INT 2
78139: ARRAY
78140: PUSH
78141: LD_VAR 0 13
78145: PUSH
78146: LD_INT 2
78148: MINUS
78149: LESS
78150: OR
78151: PUSH
78152: LD_VAR 0 8
78156: PUSH
78157: LD_INT 3
78159: ARRAY
78160: PUSH
78161: LD_INT 0
78163: PUSH
78164: LD_INT 8
78166: PUSH
78167: LD_INT 9
78169: PUSH
78170: LD_INT 10
78172: PUSH
78173: LD_INT 11
78175: PUSH
78176: LD_INT 12
78178: PUSH
78179: LD_INT 13
78181: PUSH
78182: LD_INT 16
78184: PUSH
78185: LD_INT 17
78187: PUSH
78188: LD_INT 18
78190: PUSH
78191: LD_INT 19
78193: PUSH
78194: LD_INT 20
78196: PUSH
78197: LD_INT 21
78199: PUSH
78200: EMPTY
78201: LIST
78202: LIST
78203: LIST
78204: LIST
78205: LIST
78206: LIST
78207: LIST
78208: LIST
78209: LIST
78210: LIST
78211: LIST
78212: LIST
78213: LIST
78214: IN
78215: NOT
78216: OR
78217: PUSH
78218: LD_VAR 0 8
78222: PUSH
78223: LD_INT 5
78225: ARRAY
78226: NOT
78227: OR
78228: PUSH
78229: LD_VAR 0 8
78233: PUSH
78234: LD_INT 6
78236: ARRAY
78237: PUSH
78238: LD_INT 1
78240: PUSH
78241: LD_INT 2
78243: PUSH
78244: LD_INT 7
78246: PUSH
78247: LD_INT 9
78249: PUSH
78250: LD_INT 10
78252: PUSH
78253: LD_INT 11
78255: PUSH
78256: EMPTY
78257: LIST
78258: LIST
78259: LIST
78260: LIST
78261: LIST
78262: LIST
78263: IN
78264: NOT
78265: OR
78266: IFFALSE 78272
// exit ;
78268: POP
78269: POP
78270: GO 78370
// end ;
78272: GO 77943
78274: POP
78275: POP
// side := GetSide ( depot ) ;
78276: LD_ADDR_VAR 0 9
78280: PUSH
78281: LD_VAR 0 1
78285: PPUSH
78286: CALL_OW 255
78290: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
78291: LD_VAR 0 9
78295: PPUSH
78296: LD_VAR 0 3
78300: PPUSH
78301: LD_VAR 0 4
78305: PPUSH
78306: LD_INT 20
78308: PPUSH
78309: CALL 71024 0 4
78313: PUSH
78314: LD_INT 4
78316: ARRAY
78317: IFFALSE 78321
// exit ;
78319: GO 78370
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
78321: LD_VAR 0 2
78325: PUSH
78326: LD_INT 29
78328: PUSH
78329: LD_INT 30
78331: PUSH
78332: EMPTY
78333: LIST
78334: LIST
78335: IN
78336: PUSH
78337: LD_VAR 0 3
78341: PPUSH
78342: LD_VAR 0 4
78346: PPUSH
78347: LD_VAR 0 9
78351: PPUSH
78352: CALL_OW 440
78356: NOT
78357: AND
78358: IFFALSE 78362
// exit ;
78360: GO 78370
// result := true ;
78362: LD_ADDR_VAR 0 6
78366: PUSH
78367: LD_INT 1
78369: ST_TO_ADDR
// end ;
78370: LD_VAR 0 6
78374: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
78375: LD_INT 0
78377: PPUSH
78378: PPUSH
78379: PPUSH
78380: PPUSH
78381: PPUSH
78382: PPUSH
78383: PPUSH
78384: PPUSH
78385: PPUSH
78386: PPUSH
78387: PPUSH
78388: PPUSH
78389: PPUSH
78390: PPUSH
78391: PPUSH
78392: PPUSH
78393: PPUSH
78394: PPUSH
78395: PPUSH
78396: PPUSH
78397: PPUSH
78398: PPUSH
78399: PPUSH
78400: PPUSH
78401: PPUSH
78402: PPUSH
78403: PPUSH
78404: PPUSH
78405: PPUSH
78406: PPUSH
78407: PPUSH
78408: PPUSH
78409: PPUSH
78410: PPUSH
78411: PPUSH
78412: PPUSH
78413: PPUSH
78414: PPUSH
78415: PPUSH
78416: PPUSH
78417: PPUSH
78418: PPUSH
78419: PPUSH
78420: PPUSH
78421: PPUSH
78422: PPUSH
78423: PPUSH
78424: PPUSH
78425: PPUSH
78426: PPUSH
78427: PPUSH
78428: PPUSH
78429: PPUSH
78430: PPUSH
78431: PPUSH
78432: PPUSH
78433: PPUSH
78434: PPUSH
// result = [ ] ;
78435: LD_ADDR_VAR 0 7
78439: PUSH
78440: EMPTY
78441: ST_TO_ADDR
// temp_list = [ ] ;
78442: LD_ADDR_VAR 0 9
78446: PUSH
78447: EMPTY
78448: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
78449: LD_VAR 0 4
78453: PUSH
78454: LD_INT 0
78456: PUSH
78457: LD_INT 1
78459: PUSH
78460: LD_INT 2
78462: PUSH
78463: LD_INT 3
78465: PUSH
78466: LD_INT 4
78468: PUSH
78469: LD_INT 5
78471: PUSH
78472: EMPTY
78473: LIST
78474: LIST
78475: LIST
78476: LIST
78477: LIST
78478: LIST
78479: IN
78480: NOT
78481: PUSH
78482: LD_VAR 0 1
78486: PUSH
78487: LD_INT 0
78489: PUSH
78490: LD_INT 1
78492: PUSH
78493: EMPTY
78494: LIST
78495: LIST
78496: IN
78497: PUSH
78498: LD_VAR 0 5
78502: PUSH
78503: LD_INT 1
78505: PUSH
78506: LD_INT 2
78508: PUSH
78509: LD_INT 3
78511: PUSH
78512: EMPTY
78513: LIST
78514: LIST
78515: LIST
78516: IN
78517: NOT
78518: AND
78519: OR
78520: IFFALSE 78524
// exit ;
78522: GO 96915
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
78524: LD_VAR 0 1
78528: PUSH
78529: LD_INT 6
78531: PUSH
78532: LD_INT 7
78534: PUSH
78535: LD_INT 8
78537: PUSH
78538: LD_INT 13
78540: PUSH
78541: LD_INT 12
78543: PUSH
78544: LD_INT 15
78546: PUSH
78547: LD_INT 11
78549: PUSH
78550: LD_INT 14
78552: PUSH
78553: LD_INT 10
78555: PUSH
78556: EMPTY
78557: LIST
78558: LIST
78559: LIST
78560: LIST
78561: LIST
78562: LIST
78563: LIST
78564: LIST
78565: LIST
78566: IN
78567: IFFALSE 78577
// btype = b_lab ;
78569: LD_ADDR_VAR 0 1
78573: PUSH
78574: LD_INT 6
78576: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
78577: LD_VAR 0 6
78581: PUSH
78582: LD_INT 0
78584: PUSH
78585: LD_INT 1
78587: PUSH
78588: LD_INT 2
78590: PUSH
78591: EMPTY
78592: LIST
78593: LIST
78594: LIST
78595: IN
78596: NOT
78597: PUSH
78598: LD_VAR 0 1
78602: PUSH
78603: LD_INT 0
78605: PUSH
78606: LD_INT 1
78608: PUSH
78609: LD_INT 2
78611: PUSH
78612: LD_INT 3
78614: PUSH
78615: LD_INT 6
78617: PUSH
78618: LD_INT 36
78620: PUSH
78621: LD_INT 4
78623: PUSH
78624: LD_INT 5
78626: PUSH
78627: LD_INT 31
78629: PUSH
78630: LD_INT 32
78632: PUSH
78633: LD_INT 33
78635: PUSH
78636: EMPTY
78637: LIST
78638: LIST
78639: LIST
78640: LIST
78641: LIST
78642: LIST
78643: LIST
78644: LIST
78645: LIST
78646: LIST
78647: LIST
78648: IN
78649: NOT
78650: PUSH
78651: LD_VAR 0 6
78655: PUSH
78656: LD_INT 1
78658: EQUAL
78659: AND
78660: OR
78661: PUSH
78662: LD_VAR 0 1
78666: PUSH
78667: LD_INT 2
78669: PUSH
78670: LD_INT 3
78672: PUSH
78673: EMPTY
78674: LIST
78675: LIST
78676: IN
78677: NOT
78678: PUSH
78679: LD_VAR 0 6
78683: PUSH
78684: LD_INT 2
78686: EQUAL
78687: AND
78688: OR
78689: IFFALSE 78699
// mode = 0 ;
78691: LD_ADDR_VAR 0 6
78695: PUSH
78696: LD_INT 0
78698: ST_TO_ADDR
// case mode of 0 :
78699: LD_VAR 0 6
78703: PUSH
78704: LD_INT 0
78706: DOUBLE
78707: EQUAL
78708: IFTRUE 78712
78710: GO 90165
78712: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78713: LD_ADDR_VAR 0 11
78717: PUSH
78718: LD_INT 0
78720: PUSH
78721: LD_INT 0
78723: PUSH
78724: EMPTY
78725: LIST
78726: LIST
78727: PUSH
78728: LD_INT 0
78730: PUSH
78731: LD_INT 1
78733: NEG
78734: PUSH
78735: EMPTY
78736: LIST
78737: LIST
78738: PUSH
78739: LD_INT 1
78741: PUSH
78742: LD_INT 0
78744: PUSH
78745: EMPTY
78746: LIST
78747: LIST
78748: PUSH
78749: LD_INT 1
78751: PUSH
78752: LD_INT 1
78754: PUSH
78755: EMPTY
78756: LIST
78757: LIST
78758: PUSH
78759: LD_INT 0
78761: PUSH
78762: LD_INT 1
78764: PUSH
78765: EMPTY
78766: LIST
78767: LIST
78768: PUSH
78769: LD_INT 1
78771: NEG
78772: PUSH
78773: LD_INT 0
78775: PUSH
78776: EMPTY
78777: LIST
78778: LIST
78779: PUSH
78780: LD_INT 1
78782: NEG
78783: PUSH
78784: LD_INT 1
78786: NEG
78787: PUSH
78788: EMPTY
78789: LIST
78790: LIST
78791: PUSH
78792: LD_INT 1
78794: NEG
78795: PUSH
78796: LD_INT 2
78798: NEG
78799: PUSH
78800: EMPTY
78801: LIST
78802: LIST
78803: PUSH
78804: LD_INT 0
78806: PUSH
78807: LD_INT 2
78809: NEG
78810: PUSH
78811: EMPTY
78812: LIST
78813: LIST
78814: PUSH
78815: LD_INT 1
78817: PUSH
78818: LD_INT 1
78820: NEG
78821: PUSH
78822: EMPTY
78823: LIST
78824: LIST
78825: PUSH
78826: LD_INT 1
78828: PUSH
78829: LD_INT 2
78831: PUSH
78832: EMPTY
78833: LIST
78834: LIST
78835: PUSH
78836: LD_INT 0
78838: PUSH
78839: LD_INT 2
78841: PUSH
78842: EMPTY
78843: LIST
78844: LIST
78845: PUSH
78846: LD_INT 1
78848: NEG
78849: PUSH
78850: LD_INT 1
78852: PUSH
78853: EMPTY
78854: LIST
78855: LIST
78856: PUSH
78857: LD_INT 1
78859: PUSH
78860: LD_INT 3
78862: PUSH
78863: EMPTY
78864: LIST
78865: LIST
78866: PUSH
78867: LD_INT 0
78869: PUSH
78870: LD_INT 3
78872: PUSH
78873: EMPTY
78874: LIST
78875: LIST
78876: PUSH
78877: LD_INT 1
78879: NEG
78880: PUSH
78881: LD_INT 2
78883: PUSH
78884: EMPTY
78885: LIST
78886: LIST
78887: PUSH
78888: EMPTY
78889: LIST
78890: LIST
78891: LIST
78892: LIST
78893: LIST
78894: LIST
78895: LIST
78896: LIST
78897: LIST
78898: LIST
78899: LIST
78900: LIST
78901: LIST
78902: LIST
78903: LIST
78904: LIST
78905: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78906: LD_ADDR_VAR 0 12
78910: PUSH
78911: LD_INT 0
78913: PUSH
78914: LD_INT 0
78916: PUSH
78917: EMPTY
78918: LIST
78919: LIST
78920: PUSH
78921: LD_INT 0
78923: PUSH
78924: LD_INT 1
78926: NEG
78927: PUSH
78928: EMPTY
78929: LIST
78930: LIST
78931: PUSH
78932: LD_INT 1
78934: PUSH
78935: LD_INT 0
78937: PUSH
78938: EMPTY
78939: LIST
78940: LIST
78941: PUSH
78942: LD_INT 1
78944: PUSH
78945: LD_INT 1
78947: PUSH
78948: EMPTY
78949: LIST
78950: LIST
78951: PUSH
78952: LD_INT 0
78954: PUSH
78955: LD_INT 1
78957: PUSH
78958: EMPTY
78959: LIST
78960: LIST
78961: PUSH
78962: LD_INT 1
78964: NEG
78965: PUSH
78966: LD_INT 0
78968: PUSH
78969: EMPTY
78970: LIST
78971: LIST
78972: PUSH
78973: LD_INT 1
78975: NEG
78976: PUSH
78977: LD_INT 1
78979: NEG
78980: PUSH
78981: EMPTY
78982: LIST
78983: LIST
78984: PUSH
78985: LD_INT 1
78987: PUSH
78988: LD_INT 1
78990: NEG
78991: PUSH
78992: EMPTY
78993: LIST
78994: LIST
78995: PUSH
78996: LD_INT 2
78998: PUSH
78999: LD_INT 0
79001: PUSH
79002: EMPTY
79003: LIST
79004: LIST
79005: PUSH
79006: LD_INT 2
79008: PUSH
79009: LD_INT 1
79011: PUSH
79012: EMPTY
79013: LIST
79014: LIST
79015: PUSH
79016: LD_INT 1
79018: NEG
79019: PUSH
79020: LD_INT 1
79022: PUSH
79023: EMPTY
79024: LIST
79025: LIST
79026: PUSH
79027: LD_INT 2
79029: NEG
79030: PUSH
79031: LD_INT 0
79033: PUSH
79034: EMPTY
79035: LIST
79036: LIST
79037: PUSH
79038: LD_INT 2
79040: NEG
79041: PUSH
79042: LD_INT 1
79044: NEG
79045: PUSH
79046: EMPTY
79047: LIST
79048: LIST
79049: PUSH
79050: LD_INT 2
79052: NEG
79053: PUSH
79054: LD_INT 1
79056: PUSH
79057: EMPTY
79058: LIST
79059: LIST
79060: PUSH
79061: LD_INT 3
79063: NEG
79064: PUSH
79065: LD_INT 0
79067: PUSH
79068: EMPTY
79069: LIST
79070: LIST
79071: PUSH
79072: LD_INT 3
79074: NEG
79075: PUSH
79076: LD_INT 1
79078: NEG
79079: PUSH
79080: EMPTY
79081: LIST
79082: LIST
79083: PUSH
79084: EMPTY
79085: LIST
79086: LIST
79087: LIST
79088: LIST
79089: LIST
79090: LIST
79091: LIST
79092: LIST
79093: LIST
79094: LIST
79095: LIST
79096: LIST
79097: LIST
79098: LIST
79099: LIST
79100: LIST
79101: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79102: LD_ADDR_VAR 0 13
79106: PUSH
79107: LD_INT 0
79109: PUSH
79110: LD_INT 0
79112: PUSH
79113: EMPTY
79114: LIST
79115: LIST
79116: PUSH
79117: LD_INT 0
79119: PUSH
79120: LD_INT 1
79122: NEG
79123: PUSH
79124: EMPTY
79125: LIST
79126: LIST
79127: PUSH
79128: LD_INT 1
79130: PUSH
79131: LD_INT 0
79133: PUSH
79134: EMPTY
79135: LIST
79136: LIST
79137: PUSH
79138: LD_INT 1
79140: PUSH
79141: LD_INT 1
79143: PUSH
79144: EMPTY
79145: LIST
79146: LIST
79147: PUSH
79148: LD_INT 0
79150: PUSH
79151: LD_INT 1
79153: PUSH
79154: EMPTY
79155: LIST
79156: LIST
79157: PUSH
79158: LD_INT 1
79160: NEG
79161: PUSH
79162: LD_INT 0
79164: PUSH
79165: EMPTY
79166: LIST
79167: LIST
79168: PUSH
79169: LD_INT 1
79171: NEG
79172: PUSH
79173: LD_INT 1
79175: NEG
79176: PUSH
79177: EMPTY
79178: LIST
79179: LIST
79180: PUSH
79181: LD_INT 1
79183: NEG
79184: PUSH
79185: LD_INT 2
79187: NEG
79188: PUSH
79189: EMPTY
79190: LIST
79191: LIST
79192: PUSH
79193: LD_INT 2
79195: PUSH
79196: LD_INT 1
79198: PUSH
79199: EMPTY
79200: LIST
79201: LIST
79202: PUSH
79203: LD_INT 2
79205: PUSH
79206: LD_INT 2
79208: PUSH
79209: EMPTY
79210: LIST
79211: LIST
79212: PUSH
79213: LD_INT 1
79215: PUSH
79216: LD_INT 2
79218: PUSH
79219: EMPTY
79220: LIST
79221: LIST
79222: PUSH
79223: LD_INT 2
79225: NEG
79226: PUSH
79227: LD_INT 1
79229: NEG
79230: PUSH
79231: EMPTY
79232: LIST
79233: LIST
79234: PUSH
79235: LD_INT 2
79237: NEG
79238: PUSH
79239: LD_INT 2
79241: NEG
79242: PUSH
79243: EMPTY
79244: LIST
79245: LIST
79246: PUSH
79247: LD_INT 2
79249: NEG
79250: PUSH
79251: LD_INT 3
79253: NEG
79254: PUSH
79255: EMPTY
79256: LIST
79257: LIST
79258: PUSH
79259: LD_INT 3
79261: NEG
79262: PUSH
79263: LD_INT 2
79265: NEG
79266: PUSH
79267: EMPTY
79268: LIST
79269: LIST
79270: PUSH
79271: LD_INT 3
79273: NEG
79274: PUSH
79275: LD_INT 3
79277: NEG
79278: PUSH
79279: EMPTY
79280: LIST
79281: LIST
79282: PUSH
79283: EMPTY
79284: LIST
79285: LIST
79286: LIST
79287: LIST
79288: LIST
79289: LIST
79290: LIST
79291: LIST
79292: LIST
79293: LIST
79294: LIST
79295: LIST
79296: LIST
79297: LIST
79298: LIST
79299: LIST
79300: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79301: LD_ADDR_VAR 0 14
79305: PUSH
79306: LD_INT 0
79308: PUSH
79309: LD_INT 0
79311: PUSH
79312: EMPTY
79313: LIST
79314: LIST
79315: PUSH
79316: LD_INT 0
79318: PUSH
79319: LD_INT 1
79321: NEG
79322: PUSH
79323: EMPTY
79324: LIST
79325: LIST
79326: PUSH
79327: LD_INT 1
79329: PUSH
79330: LD_INT 0
79332: PUSH
79333: EMPTY
79334: LIST
79335: LIST
79336: PUSH
79337: LD_INT 1
79339: PUSH
79340: LD_INT 1
79342: PUSH
79343: EMPTY
79344: LIST
79345: LIST
79346: PUSH
79347: LD_INT 0
79349: PUSH
79350: LD_INT 1
79352: PUSH
79353: EMPTY
79354: LIST
79355: LIST
79356: PUSH
79357: LD_INT 1
79359: NEG
79360: PUSH
79361: LD_INT 0
79363: PUSH
79364: EMPTY
79365: LIST
79366: LIST
79367: PUSH
79368: LD_INT 1
79370: NEG
79371: PUSH
79372: LD_INT 1
79374: NEG
79375: PUSH
79376: EMPTY
79377: LIST
79378: LIST
79379: PUSH
79380: LD_INT 1
79382: NEG
79383: PUSH
79384: LD_INT 2
79386: NEG
79387: PUSH
79388: EMPTY
79389: LIST
79390: LIST
79391: PUSH
79392: LD_INT 0
79394: PUSH
79395: LD_INT 2
79397: NEG
79398: PUSH
79399: EMPTY
79400: LIST
79401: LIST
79402: PUSH
79403: LD_INT 1
79405: PUSH
79406: LD_INT 1
79408: NEG
79409: PUSH
79410: EMPTY
79411: LIST
79412: LIST
79413: PUSH
79414: LD_INT 1
79416: PUSH
79417: LD_INT 2
79419: PUSH
79420: EMPTY
79421: LIST
79422: LIST
79423: PUSH
79424: LD_INT 0
79426: PUSH
79427: LD_INT 2
79429: PUSH
79430: EMPTY
79431: LIST
79432: LIST
79433: PUSH
79434: LD_INT 1
79436: NEG
79437: PUSH
79438: LD_INT 1
79440: PUSH
79441: EMPTY
79442: LIST
79443: LIST
79444: PUSH
79445: LD_INT 1
79447: NEG
79448: PUSH
79449: LD_INT 3
79451: NEG
79452: PUSH
79453: EMPTY
79454: LIST
79455: LIST
79456: PUSH
79457: LD_INT 0
79459: PUSH
79460: LD_INT 3
79462: NEG
79463: PUSH
79464: EMPTY
79465: LIST
79466: LIST
79467: PUSH
79468: LD_INT 1
79470: PUSH
79471: LD_INT 2
79473: NEG
79474: PUSH
79475: EMPTY
79476: LIST
79477: LIST
79478: PUSH
79479: EMPTY
79480: LIST
79481: LIST
79482: LIST
79483: LIST
79484: LIST
79485: LIST
79486: LIST
79487: LIST
79488: LIST
79489: LIST
79490: LIST
79491: LIST
79492: LIST
79493: LIST
79494: LIST
79495: LIST
79496: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79497: LD_ADDR_VAR 0 15
79501: PUSH
79502: LD_INT 0
79504: PUSH
79505: LD_INT 0
79507: PUSH
79508: EMPTY
79509: LIST
79510: LIST
79511: PUSH
79512: LD_INT 0
79514: PUSH
79515: LD_INT 1
79517: NEG
79518: PUSH
79519: EMPTY
79520: LIST
79521: LIST
79522: PUSH
79523: LD_INT 1
79525: PUSH
79526: LD_INT 0
79528: PUSH
79529: EMPTY
79530: LIST
79531: LIST
79532: PUSH
79533: LD_INT 1
79535: PUSH
79536: LD_INT 1
79538: PUSH
79539: EMPTY
79540: LIST
79541: LIST
79542: PUSH
79543: LD_INT 0
79545: PUSH
79546: LD_INT 1
79548: PUSH
79549: EMPTY
79550: LIST
79551: LIST
79552: PUSH
79553: LD_INT 1
79555: NEG
79556: PUSH
79557: LD_INT 0
79559: PUSH
79560: EMPTY
79561: LIST
79562: LIST
79563: PUSH
79564: LD_INT 1
79566: NEG
79567: PUSH
79568: LD_INT 1
79570: NEG
79571: PUSH
79572: EMPTY
79573: LIST
79574: LIST
79575: PUSH
79576: LD_INT 1
79578: PUSH
79579: LD_INT 1
79581: NEG
79582: PUSH
79583: EMPTY
79584: LIST
79585: LIST
79586: PUSH
79587: LD_INT 2
79589: PUSH
79590: LD_INT 0
79592: PUSH
79593: EMPTY
79594: LIST
79595: LIST
79596: PUSH
79597: LD_INT 2
79599: PUSH
79600: LD_INT 1
79602: PUSH
79603: EMPTY
79604: LIST
79605: LIST
79606: PUSH
79607: LD_INT 1
79609: NEG
79610: PUSH
79611: LD_INT 1
79613: PUSH
79614: EMPTY
79615: LIST
79616: LIST
79617: PUSH
79618: LD_INT 2
79620: NEG
79621: PUSH
79622: LD_INT 0
79624: PUSH
79625: EMPTY
79626: LIST
79627: LIST
79628: PUSH
79629: LD_INT 2
79631: NEG
79632: PUSH
79633: LD_INT 1
79635: NEG
79636: PUSH
79637: EMPTY
79638: LIST
79639: LIST
79640: PUSH
79641: LD_INT 2
79643: PUSH
79644: LD_INT 1
79646: NEG
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: PUSH
79652: LD_INT 3
79654: PUSH
79655: LD_INT 0
79657: PUSH
79658: EMPTY
79659: LIST
79660: LIST
79661: PUSH
79662: LD_INT 3
79664: PUSH
79665: LD_INT 1
79667: PUSH
79668: EMPTY
79669: LIST
79670: LIST
79671: PUSH
79672: EMPTY
79673: LIST
79674: LIST
79675: LIST
79676: LIST
79677: LIST
79678: LIST
79679: LIST
79680: LIST
79681: LIST
79682: LIST
79683: LIST
79684: LIST
79685: LIST
79686: LIST
79687: LIST
79688: LIST
79689: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79690: LD_ADDR_VAR 0 16
79694: PUSH
79695: LD_INT 0
79697: PUSH
79698: LD_INT 0
79700: PUSH
79701: EMPTY
79702: LIST
79703: LIST
79704: PUSH
79705: LD_INT 0
79707: PUSH
79708: LD_INT 1
79710: NEG
79711: PUSH
79712: EMPTY
79713: LIST
79714: LIST
79715: PUSH
79716: LD_INT 1
79718: PUSH
79719: LD_INT 0
79721: PUSH
79722: EMPTY
79723: LIST
79724: LIST
79725: PUSH
79726: LD_INT 1
79728: PUSH
79729: LD_INT 1
79731: PUSH
79732: EMPTY
79733: LIST
79734: LIST
79735: PUSH
79736: LD_INT 0
79738: PUSH
79739: LD_INT 1
79741: PUSH
79742: EMPTY
79743: LIST
79744: LIST
79745: PUSH
79746: LD_INT 1
79748: NEG
79749: PUSH
79750: LD_INT 0
79752: PUSH
79753: EMPTY
79754: LIST
79755: LIST
79756: PUSH
79757: LD_INT 1
79759: NEG
79760: PUSH
79761: LD_INT 1
79763: NEG
79764: PUSH
79765: EMPTY
79766: LIST
79767: LIST
79768: PUSH
79769: LD_INT 1
79771: NEG
79772: PUSH
79773: LD_INT 2
79775: NEG
79776: PUSH
79777: EMPTY
79778: LIST
79779: LIST
79780: PUSH
79781: LD_INT 2
79783: PUSH
79784: LD_INT 1
79786: PUSH
79787: EMPTY
79788: LIST
79789: LIST
79790: PUSH
79791: LD_INT 2
79793: PUSH
79794: LD_INT 2
79796: PUSH
79797: EMPTY
79798: LIST
79799: LIST
79800: PUSH
79801: LD_INT 1
79803: PUSH
79804: LD_INT 2
79806: PUSH
79807: EMPTY
79808: LIST
79809: LIST
79810: PUSH
79811: LD_INT 2
79813: NEG
79814: PUSH
79815: LD_INT 1
79817: NEG
79818: PUSH
79819: EMPTY
79820: LIST
79821: LIST
79822: PUSH
79823: LD_INT 2
79825: NEG
79826: PUSH
79827: LD_INT 2
79829: NEG
79830: PUSH
79831: EMPTY
79832: LIST
79833: LIST
79834: PUSH
79835: LD_INT 3
79837: PUSH
79838: LD_INT 2
79840: PUSH
79841: EMPTY
79842: LIST
79843: LIST
79844: PUSH
79845: LD_INT 3
79847: PUSH
79848: LD_INT 3
79850: PUSH
79851: EMPTY
79852: LIST
79853: LIST
79854: PUSH
79855: LD_INT 2
79857: PUSH
79858: LD_INT 3
79860: PUSH
79861: EMPTY
79862: LIST
79863: LIST
79864: PUSH
79865: EMPTY
79866: LIST
79867: LIST
79868: LIST
79869: LIST
79870: LIST
79871: LIST
79872: LIST
79873: LIST
79874: LIST
79875: LIST
79876: LIST
79877: LIST
79878: LIST
79879: LIST
79880: LIST
79881: LIST
79882: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79883: LD_ADDR_VAR 0 17
79887: PUSH
79888: LD_INT 0
79890: PUSH
79891: LD_INT 0
79893: PUSH
79894: EMPTY
79895: LIST
79896: LIST
79897: PUSH
79898: LD_INT 0
79900: PUSH
79901: LD_INT 1
79903: NEG
79904: PUSH
79905: EMPTY
79906: LIST
79907: LIST
79908: PUSH
79909: LD_INT 1
79911: PUSH
79912: LD_INT 0
79914: PUSH
79915: EMPTY
79916: LIST
79917: LIST
79918: PUSH
79919: LD_INT 1
79921: PUSH
79922: LD_INT 1
79924: PUSH
79925: EMPTY
79926: LIST
79927: LIST
79928: PUSH
79929: LD_INT 0
79931: PUSH
79932: LD_INT 1
79934: PUSH
79935: EMPTY
79936: LIST
79937: LIST
79938: PUSH
79939: LD_INT 1
79941: NEG
79942: PUSH
79943: LD_INT 0
79945: PUSH
79946: EMPTY
79947: LIST
79948: LIST
79949: PUSH
79950: LD_INT 1
79952: NEG
79953: PUSH
79954: LD_INT 1
79956: NEG
79957: PUSH
79958: EMPTY
79959: LIST
79960: LIST
79961: PUSH
79962: LD_INT 1
79964: NEG
79965: PUSH
79966: LD_INT 2
79968: NEG
79969: PUSH
79970: EMPTY
79971: LIST
79972: LIST
79973: PUSH
79974: LD_INT 0
79976: PUSH
79977: LD_INT 2
79979: NEG
79980: PUSH
79981: EMPTY
79982: LIST
79983: LIST
79984: PUSH
79985: LD_INT 1
79987: PUSH
79988: LD_INT 1
79990: NEG
79991: PUSH
79992: EMPTY
79993: LIST
79994: LIST
79995: PUSH
79996: LD_INT 2
79998: PUSH
79999: LD_INT 0
80001: PUSH
80002: EMPTY
80003: LIST
80004: LIST
80005: PUSH
80006: LD_INT 2
80008: PUSH
80009: LD_INT 1
80011: PUSH
80012: EMPTY
80013: LIST
80014: LIST
80015: PUSH
80016: LD_INT 2
80018: PUSH
80019: LD_INT 2
80021: PUSH
80022: EMPTY
80023: LIST
80024: LIST
80025: PUSH
80026: LD_INT 1
80028: PUSH
80029: LD_INT 2
80031: PUSH
80032: EMPTY
80033: LIST
80034: LIST
80035: PUSH
80036: LD_INT 0
80038: PUSH
80039: LD_INT 2
80041: PUSH
80042: EMPTY
80043: LIST
80044: LIST
80045: PUSH
80046: LD_INT 1
80048: NEG
80049: PUSH
80050: LD_INT 1
80052: PUSH
80053: EMPTY
80054: LIST
80055: LIST
80056: PUSH
80057: LD_INT 2
80059: NEG
80060: PUSH
80061: LD_INT 0
80063: PUSH
80064: EMPTY
80065: LIST
80066: LIST
80067: PUSH
80068: LD_INT 2
80070: NEG
80071: PUSH
80072: LD_INT 1
80074: NEG
80075: PUSH
80076: EMPTY
80077: LIST
80078: LIST
80079: PUSH
80080: LD_INT 2
80082: NEG
80083: PUSH
80084: LD_INT 2
80086: NEG
80087: PUSH
80088: EMPTY
80089: LIST
80090: LIST
80091: PUSH
80092: EMPTY
80093: LIST
80094: LIST
80095: LIST
80096: LIST
80097: LIST
80098: LIST
80099: LIST
80100: LIST
80101: LIST
80102: LIST
80103: LIST
80104: LIST
80105: LIST
80106: LIST
80107: LIST
80108: LIST
80109: LIST
80110: LIST
80111: LIST
80112: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80113: LD_ADDR_VAR 0 18
80117: PUSH
80118: LD_INT 0
80120: PUSH
80121: LD_INT 0
80123: PUSH
80124: EMPTY
80125: LIST
80126: LIST
80127: PUSH
80128: LD_INT 0
80130: PUSH
80131: LD_INT 1
80133: NEG
80134: PUSH
80135: EMPTY
80136: LIST
80137: LIST
80138: PUSH
80139: LD_INT 1
80141: PUSH
80142: LD_INT 0
80144: PUSH
80145: EMPTY
80146: LIST
80147: LIST
80148: PUSH
80149: LD_INT 1
80151: PUSH
80152: LD_INT 1
80154: PUSH
80155: EMPTY
80156: LIST
80157: LIST
80158: PUSH
80159: LD_INT 0
80161: PUSH
80162: LD_INT 1
80164: PUSH
80165: EMPTY
80166: LIST
80167: LIST
80168: PUSH
80169: LD_INT 1
80171: NEG
80172: PUSH
80173: LD_INT 0
80175: PUSH
80176: EMPTY
80177: LIST
80178: LIST
80179: PUSH
80180: LD_INT 1
80182: NEG
80183: PUSH
80184: LD_INT 1
80186: NEG
80187: PUSH
80188: EMPTY
80189: LIST
80190: LIST
80191: PUSH
80192: LD_INT 1
80194: NEG
80195: PUSH
80196: LD_INT 2
80198: NEG
80199: PUSH
80200: EMPTY
80201: LIST
80202: LIST
80203: PUSH
80204: LD_INT 0
80206: PUSH
80207: LD_INT 2
80209: NEG
80210: PUSH
80211: EMPTY
80212: LIST
80213: LIST
80214: PUSH
80215: LD_INT 1
80217: PUSH
80218: LD_INT 1
80220: NEG
80221: PUSH
80222: EMPTY
80223: LIST
80224: LIST
80225: PUSH
80226: LD_INT 2
80228: PUSH
80229: LD_INT 0
80231: PUSH
80232: EMPTY
80233: LIST
80234: LIST
80235: PUSH
80236: LD_INT 2
80238: PUSH
80239: LD_INT 1
80241: PUSH
80242: EMPTY
80243: LIST
80244: LIST
80245: PUSH
80246: LD_INT 2
80248: PUSH
80249: LD_INT 2
80251: PUSH
80252: EMPTY
80253: LIST
80254: LIST
80255: PUSH
80256: LD_INT 1
80258: PUSH
80259: LD_INT 2
80261: PUSH
80262: EMPTY
80263: LIST
80264: LIST
80265: PUSH
80266: LD_INT 0
80268: PUSH
80269: LD_INT 2
80271: PUSH
80272: EMPTY
80273: LIST
80274: LIST
80275: PUSH
80276: LD_INT 1
80278: NEG
80279: PUSH
80280: LD_INT 1
80282: PUSH
80283: EMPTY
80284: LIST
80285: LIST
80286: PUSH
80287: LD_INT 2
80289: NEG
80290: PUSH
80291: LD_INT 0
80293: PUSH
80294: EMPTY
80295: LIST
80296: LIST
80297: PUSH
80298: LD_INT 2
80300: NEG
80301: PUSH
80302: LD_INT 1
80304: NEG
80305: PUSH
80306: EMPTY
80307: LIST
80308: LIST
80309: PUSH
80310: LD_INT 2
80312: NEG
80313: PUSH
80314: LD_INT 2
80316: NEG
80317: PUSH
80318: EMPTY
80319: LIST
80320: LIST
80321: PUSH
80322: EMPTY
80323: LIST
80324: LIST
80325: LIST
80326: LIST
80327: LIST
80328: LIST
80329: LIST
80330: LIST
80331: LIST
80332: LIST
80333: LIST
80334: LIST
80335: LIST
80336: LIST
80337: LIST
80338: LIST
80339: LIST
80340: LIST
80341: LIST
80342: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80343: LD_ADDR_VAR 0 19
80347: PUSH
80348: LD_INT 0
80350: PUSH
80351: LD_INT 0
80353: PUSH
80354: EMPTY
80355: LIST
80356: LIST
80357: PUSH
80358: LD_INT 0
80360: PUSH
80361: LD_INT 1
80363: NEG
80364: PUSH
80365: EMPTY
80366: LIST
80367: LIST
80368: PUSH
80369: LD_INT 1
80371: PUSH
80372: LD_INT 0
80374: PUSH
80375: EMPTY
80376: LIST
80377: LIST
80378: PUSH
80379: LD_INT 1
80381: PUSH
80382: LD_INT 1
80384: PUSH
80385: EMPTY
80386: LIST
80387: LIST
80388: PUSH
80389: LD_INT 0
80391: PUSH
80392: LD_INT 1
80394: PUSH
80395: EMPTY
80396: LIST
80397: LIST
80398: PUSH
80399: LD_INT 1
80401: NEG
80402: PUSH
80403: LD_INT 0
80405: PUSH
80406: EMPTY
80407: LIST
80408: LIST
80409: PUSH
80410: LD_INT 1
80412: NEG
80413: PUSH
80414: LD_INT 1
80416: NEG
80417: PUSH
80418: EMPTY
80419: LIST
80420: LIST
80421: PUSH
80422: LD_INT 1
80424: NEG
80425: PUSH
80426: LD_INT 2
80428: NEG
80429: PUSH
80430: EMPTY
80431: LIST
80432: LIST
80433: PUSH
80434: LD_INT 0
80436: PUSH
80437: LD_INT 2
80439: NEG
80440: PUSH
80441: EMPTY
80442: LIST
80443: LIST
80444: PUSH
80445: LD_INT 1
80447: PUSH
80448: LD_INT 1
80450: NEG
80451: PUSH
80452: EMPTY
80453: LIST
80454: LIST
80455: PUSH
80456: LD_INT 2
80458: PUSH
80459: LD_INT 0
80461: PUSH
80462: EMPTY
80463: LIST
80464: LIST
80465: PUSH
80466: LD_INT 2
80468: PUSH
80469: LD_INT 1
80471: PUSH
80472: EMPTY
80473: LIST
80474: LIST
80475: PUSH
80476: LD_INT 2
80478: PUSH
80479: LD_INT 2
80481: PUSH
80482: EMPTY
80483: LIST
80484: LIST
80485: PUSH
80486: LD_INT 1
80488: PUSH
80489: LD_INT 2
80491: PUSH
80492: EMPTY
80493: LIST
80494: LIST
80495: PUSH
80496: LD_INT 0
80498: PUSH
80499: LD_INT 2
80501: PUSH
80502: EMPTY
80503: LIST
80504: LIST
80505: PUSH
80506: LD_INT 1
80508: NEG
80509: PUSH
80510: LD_INT 1
80512: PUSH
80513: EMPTY
80514: LIST
80515: LIST
80516: PUSH
80517: LD_INT 2
80519: NEG
80520: PUSH
80521: LD_INT 0
80523: PUSH
80524: EMPTY
80525: LIST
80526: LIST
80527: PUSH
80528: LD_INT 2
80530: NEG
80531: PUSH
80532: LD_INT 1
80534: NEG
80535: PUSH
80536: EMPTY
80537: LIST
80538: LIST
80539: PUSH
80540: LD_INT 2
80542: NEG
80543: PUSH
80544: LD_INT 2
80546: NEG
80547: PUSH
80548: EMPTY
80549: LIST
80550: LIST
80551: PUSH
80552: EMPTY
80553: LIST
80554: LIST
80555: LIST
80556: LIST
80557: LIST
80558: LIST
80559: LIST
80560: LIST
80561: LIST
80562: LIST
80563: LIST
80564: LIST
80565: LIST
80566: LIST
80567: LIST
80568: LIST
80569: LIST
80570: LIST
80571: LIST
80572: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80573: LD_ADDR_VAR 0 20
80577: PUSH
80578: LD_INT 0
80580: PUSH
80581: LD_INT 0
80583: PUSH
80584: EMPTY
80585: LIST
80586: LIST
80587: PUSH
80588: LD_INT 0
80590: PUSH
80591: LD_INT 1
80593: NEG
80594: PUSH
80595: EMPTY
80596: LIST
80597: LIST
80598: PUSH
80599: LD_INT 1
80601: PUSH
80602: LD_INT 0
80604: PUSH
80605: EMPTY
80606: LIST
80607: LIST
80608: PUSH
80609: LD_INT 1
80611: PUSH
80612: LD_INT 1
80614: PUSH
80615: EMPTY
80616: LIST
80617: LIST
80618: PUSH
80619: LD_INT 0
80621: PUSH
80622: LD_INT 1
80624: PUSH
80625: EMPTY
80626: LIST
80627: LIST
80628: PUSH
80629: LD_INT 1
80631: NEG
80632: PUSH
80633: LD_INT 0
80635: PUSH
80636: EMPTY
80637: LIST
80638: LIST
80639: PUSH
80640: LD_INT 1
80642: NEG
80643: PUSH
80644: LD_INT 1
80646: NEG
80647: PUSH
80648: EMPTY
80649: LIST
80650: LIST
80651: PUSH
80652: LD_INT 1
80654: NEG
80655: PUSH
80656: LD_INT 2
80658: NEG
80659: PUSH
80660: EMPTY
80661: LIST
80662: LIST
80663: PUSH
80664: LD_INT 0
80666: PUSH
80667: LD_INT 2
80669: NEG
80670: PUSH
80671: EMPTY
80672: LIST
80673: LIST
80674: PUSH
80675: LD_INT 1
80677: PUSH
80678: LD_INT 1
80680: NEG
80681: PUSH
80682: EMPTY
80683: LIST
80684: LIST
80685: PUSH
80686: LD_INT 2
80688: PUSH
80689: LD_INT 0
80691: PUSH
80692: EMPTY
80693: LIST
80694: LIST
80695: PUSH
80696: LD_INT 2
80698: PUSH
80699: LD_INT 1
80701: PUSH
80702: EMPTY
80703: LIST
80704: LIST
80705: PUSH
80706: LD_INT 2
80708: PUSH
80709: LD_INT 2
80711: PUSH
80712: EMPTY
80713: LIST
80714: LIST
80715: PUSH
80716: LD_INT 1
80718: PUSH
80719: LD_INT 2
80721: PUSH
80722: EMPTY
80723: LIST
80724: LIST
80725: PUSH
80726: LD_INT 0
80728: PUSH
80729: LD_INT 2
80731: PUSH
80732: EMPTY
80733: LIST
80734: LIST
80735: PUSH
80736: LD_INT 1
80738: NEG
80739: PUSH
80740: LD_INT 1
80742: PUSH
80743: EMPTY
80744: LIST
80745: LIST
80746: PUSH
80747: LD_INT 2
80749: NEG
80750: PUSH
80751: LD_INT 0
80753: PUSH
80754: EMPTY
80755: LIST
80756: LIST
80757: PUSH
80758: LD_INT 2
80760: NEG
80761: PUSH
80762: LD_INT 1
80764: NEG
80765: PUSH
80766: EMPTY
80767: LIST
80768: LIST
80769: PUSH
80770: LD_INT 2
80772: NEG
80773: PUSH
80774: LD_INT 2
80776: NEG
80777: PUSH
80778: EMPTY
80779: LIST
80780: LIST
80781: PUSH
80782: EMPTY
80783: LIST
80784: LIST
80785: LIST
80786: LIST
80787: LIST
80788: LIST
80789: LIST
80790: LIST
80791: LIST
80792: LIST
80793: LIST
80794: LIST
80795: LIST
80796: LIST
80797: LIST
80798: LIST
80799: LIST
80800: LIST
80801: LIST
80802: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80803: LD_ADDR_VAR 0 21
80807: PUSH
80808: LD_INT 0
80810: PUSH
80811: LD_INT 0
80813: PUSH
80814: EMPTY
80815: LIST
80816: LIST
80817: PUSH
80818: LD_INT 0
80820: PUSH
80821: LD_INT 1
80823: NEG
80824: PUSH
80825: EMPTY
80826: LIST
80827: LIST
80828: PUSH
80829: LD_INT 1
80831: PUSH
80832: LD_INT 0
80834: PUSH
80835: EMPTY
80836: LIST
80837: LIST
80838: PUSH
80839: LD_INT 1
80841: PUSH
80842: LD_INT 1
80844: PUSH
80845: EMPTY
80846: LIST
80847: LIST
80848: PUSH
80849: LD_INT 0
80851: PUSH
80852: LD_INT 1
80854: PUSH
80855: EMPTY
80856: LIST
80857: LIST
80858: PUSH
80859: LD_INT 1
80861: NEG
80862: PUSH
80863: LD_INT 0
80865: PUSH
80866: EMPTY
80867: LIST
80868: LIST
80869: PUSH
80870: LD_INT 1
80872: NEG
80873: PUSH
80874: LD_INT 1
80876: NEG
80877: PUSH
80878: EMPTY
80879: LIST
80880: LIST
80881: PUSH
80882: LD_INT 1
80884: NEG
80885: PUSH
80886: LD_INT 2
80888: NEG
80889: PUSH
80890: EMPTY
80891: LIST
80892: LIST
80893: PUSH
80894: LD_INT 0
80896: PUSH
80897: LD_INT 2
80899: NEG
80900: PUSH
80901: EMPTY
80902: LIST
80903: LIST
80904: PUSH
80905: LD_INT 1
80907: PUSH
80908: LD_INT 1
80910: NEG
80911: PUSH
80912: EMPTY
80913: LIST
80914: LIST
80915: PUSH
80916: LD_INT 2
80918: PUSH
80919: LD_INT 0
80921: PUSH
80922: EMPTY
80923: LIST
80924: LIST
80925: PUSH
80926: LD_INT 2
80928: PUSH
80929: LD_INT 1
80931: PUSH
80932: EMPTY
80933: LIST
80934: LIST
80935: PUSH
80936: LD_INT 2
80938: PUSH
80939: LD_INT 2
80941: PUSH
80942: EMPTY
80943: LIST
80944: LIST
80945: PUSH
80946: LD_INT 1
80948: PUSH
80949: LD_INT 2
80951: PUSH
80952: EMPTY
80953: LIST
80954: LIST
80955: PUSH
80956: LD_INT 0
80958: PUSH
80959: LD_INT 2
80961: PUSH
80962: EMPTY
80963: LIST
80964: LIST
80965: PUSH
80966: LD_INT 1
80968: NEG
80969: PUSH
80970: LD_INT 1
80972: PUSH
80973: EMPTY
80974: LIST
80975: LIST
80976: PUSH
80977: LD_INT 2
80979: NEG
80980: PUSH
80981: LD_INT 0
80983: PUSH
80984: EMPTY
80985: LIST
80986: LIST
80987: PUSH
80988: LD_INT 2
80990: NEG
80991: PUSH
80992: LD_INT 1
80994: NEG
80995: PUSH
80996: EMPTY
80997: LIST
80998: LIST
80999: PUSH
81000: LD_INT 2
81002: NEG
81003: PUSH
81004: LD_INT 2
81006: NEG
81007: PUSH
81008: EMPTY
81009: LIST
81010: LIST
81011: PUSH
81012: EMPTY
81013: LIST
81014: LIST
81015: LIST
81016: LIST
81017: LIST
81018: LIST
81019: LIST
81020: LIST
81021: LIST
81022: LIST
81023: LIST
81024: LIST
81025: LIST
81026: LIST
81027: LIST
81028: LIST
81029: LIST
81030: LIST
81031: LIST
81032: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81033: LD_ADDR_VAR 0 22
81037: PUSH
81038: LD_INT 0
81040: PUSH
81041: LD_INT 0
81043: PUSH
81044: EMPTY
81045: LIST
81046: LIST
81047: PUSH
81048: LD_INT 0
81050: PUSH
81051: LD_INT 1
81053: NEG
81054: PUSH
81055: EMPTY
81056: LIST
81057: LIST
81058: PUSH
81059: LD_INT 1
81061: PUSH
81062: LD_INT 0
81064: PUSH
81065: EMPTY
81066: LIST
81067: LIST
81068: PUSH
81069: LD_INT 1
81071: PUSH
81072: LD_INT 1
81074: PUSH
81075: EMPTY
81076: LIST
81077: LIST
81078: PUSH
81079: LD_INT 0
81081: PUSH
81082: LD_INT 1
81084: PUSH
81085: EMPTY
81086: LIST
81087: LIST
81088: PUSH
81089: LD_INT 1
81091: NEG
81092: PUSH
81093: LD_INT 0
81095: PUSH
81096: EMPTY
81097: LIST
81098: LIST
81099: PUSH
81100: LD_INT 1
81102: NEG
81103: PUSH
81104: LD_INT 1
81106: NEG
81107: PUSH
81108: EMPTY
81109: LIST
81110: LIST
81111: PUSH
81112: LD_INT 1
81114: NEG
81115: PUSH
81116: LD_INT 2
81118: NEG
81119: PUSH
81120: EMPTY
81121: LIST
81122: LIST
81123: PUSH
81124: LD_INT 0
81126: PUSH
81127: LD_INT 2
81129: NEG
81130: PUSH
81131: EMPTY
81132: LIST
81133: LIST
81134: PUSH
81135: LD_INT 1
81137: PUSH
81138: LD_INT 1
81140: NEG
81141: PUSH
81142: EMPTY
81143: LIST
81144: LIST
81145: PUSH
81146: LD_INT 2
81148: PUSH
81149: LD_INT 0
81151: PUSH
81152: EMPTY
81153: LIST
81154: LIST
81155: PUSH
81156: LD_INT 2
81158: PUSH
81159: LD_INT 1
81161: PUSH
81162: EMPTY
81163: LIST
81164: LIST
81165: PUSH
81166: LD_INT 2
81168: PUSH
81169: LD_INT 2
81171: PUSH
81172: EMPTY
81173: LIST
81174: LIST
81175: PUSH
81176: LD_INT 1
81178: PUSH
81179: LD_INT 2
81181: PUSH
81182: EMPTY
81183: LIST
81184: LIST
81185: PUSH
81186: LD_INT 0
81188: PUSH
81189: LD_INT 2
81191: PUSH
81192: EMPTY
81193: LIST
81194: LIST
81195: PUSH
81196: LD_INT 1
81198: NEG
81199: PUSH
81200: LD_INT 1
81202: PUSH
81203: EMPTY
81204: LIST
81205: LIST
81206: PUSH
81207: LD_INT 2
81209: NEG
81210: PUSH
81211: LD_INT 0
81213: PUSH
81214: EMPTY
81215: LIST
81216: LIST
81217: PUSH
81218: LD_INT 2
81220: NEG
81221: PUSH
81222: LD_INT 1
81224: NEG
81225: PUSH
81226: EMPTY
81227: LIST
81228: LIST
81229: PUSH
81230: LD_INT 2
81232: NEG
81233: PUSH
81234: LD_INT 2
81236: NEG
81237: PUSH
81238: EMPTY
81239: LIST
81240: LIST
81241: PUSH
81242: EMPTY
81243: LIST
81244: LIST
81245: LIST
81246: LIST
81247: LIST
81248: LIST
81249: LIST
81250: LIST
81251: LIST
81252: LIST
81253: LIST
81254: LIST
81255: LIST
81256: LIST
81257: LIST
81258: LIST
81259: LIST
81260: LIST
81261: LIST
81262: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
81263: LD_ADDR_VAR 0 23
81267: PUSH
81268: LD_INT 0
81270: PUSH
81271: LD_INT 0
81273: PUSH
81274: EMPTY
81275: LIST
81276: LIST
81277: PUSH
81278: LD_INT 0
81280: PUSH
81281: LD_INT 1
81283: NEG
81284: PUSH
81285: EMPTY
81286: LIST
81287: LIST
81288: PUSH
81289: LD_INT 1
81291: PUSH
81292: LD_INT 0
81294: PUSH
81295: EMPTY
81296: LIST
81297: LIST
81298: PUSH
81299: LD_INT 1
81301: PUSH
81302: LD_INT 1
81304: PUSH
81305: EMPTY
81306: LIST
81307: LIST
81308: PUSH
81309: LD_INT 0
81311: PUSH
81312: LD_INT 1
81314: PUSH
81315: EMPTY
81316: LIST
81317: LIST
81318: PUSH
81319: LD_INT 1
81321: NEG
81322: PUSH
81323: LD_INT 0
81325: PUSH
81326: EMPTY
81327: LIST
81328: LIST
81329: PUSH
81330: LD_INT 1
81332: NEG
81333: PUSH
81334: LD_INT 1
81336: NEG
81337: PUSH
81338: EMPTY
81339: LIST
81340: LIST
81341: PUSH
81342: LD_INT 1
81344: NEG
81345: PUSH
81346: LD_INT 2
81348: NEG
81349: PUSH
81350: EMPTY
81351: LIST
81352: LIST
81353: PUSH
81354: LD_INT 0
81356: PUSH
81357: LD_INT 2
81359: NEG
81360: PUSH
81361: EMPTY
81362: LIST
81363: LIST
81364: PUSH
81365: LD_INT 1
81367: PUSH
81368: LD_INT 1
81370: NEG
81371: PUSH
81372: EMPTY
81373: LIST
81374: LIST
81375: PUSH
81376: LD_INT 2
81378: PUSH
81379: LD_INT 0
81381: PUSH
81382: EMPTY
81383: LIST
81384: LIST
81385: PUSH
81386: LD_INT 2
81388: PUSH
81389: LD_INT 1
81391: PUSH
81392: EMPTY
81393: LIST
81394: LIST
81395: PUSH
81396: LD_INT 2
81398: PUSH
81399: LD_INT 2
81401: PUSH
81402: EMPTY
81403: LIST
81404: LIST
81405: PUSH
81406: LD_INT 1
81408: PUSH
81409: LD_INT 2
81411: PUSH
81412: EMPTY
81413: LIST
81414: LIST
81415: PUSH
81416: LD_INT 0
81418: PUSH
81419: LD_INT 2
81421: PUSH
81422: EMPTY
81423: LIST
81424: LIST
81425: PUSH
81426: LD_INT 1
81428: NEG
81429: PUSH
81430: LD_INT 1
81432: PUSH
81433: EMPTY
81434: LIST
81435: LIST
81436: PUSH
81437: LD_INT 2
81439: NEG
81440: PUSH
81441: LD_INT 0
81443: PUSH
81444: EMPTY
81445: LIST
81446: LIST
81447: PUSH
81448: LD_INT 2
81450: NEG
81451: PUSH
81452: LD_INT 1
81454: NEG
81455: PUSH
81456: EMPTY
81457: LIST
81458: LIST
81459: PUSH
81460: LD_INT 2
81462: NEG
81463: PUSH
81464: LD_INT 2
81466: NEG
81467: PUSH
81468: EMPTY
81469: LIST
81470: LIST
81471: PUSH
81472: LD_INT 2
81474: NEG
81475: PUSH
81476: LD_INT 3
81478: NEG
81479: PUSH
81480: EMPTY
81481: LIST
81482: LIST
81483: PUSH
81484: LD_INT 1
81486: NEG
81487: PUSH
81488: LD_INT 3
81490: NEG
81491: PUSH
81492: EMPTY
81493: LIST
81494: LIST
81495: PUSH
81496: LD_INT 1
81498: PUSH
81499: LD_INT 2
81501: NEG
81502: PUSH
81503: EMPTY
81504: LIST
81505: LIST
81506: PUSH
81507: LD_INT 2
81509: PUSH
81510: LD_INT 1
81512: NEG
81513: PUSH
81514: EMPTY
81515: LIST
81516: LIST
81517: PUSH
81518: EMPTY
81519: LIST
81520: LIST
81521: LIST
81522: LIST
81523: LIST
81524: LIST
81525: LIST
81526: LIST
81527: LIST
81528: LIST
81529: LIST
81530: LIST
81531: LIST
81532: LIST
81533: LIST
81534: LIST
81535: LIST
81536: LIST
81537: LIST
81538: LIST
81539: LIST
81540: LIST
81541: LIST
81542: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
81543: LD_ADDR_VAR 0 24
81547: PUSH
81548: LD_INT 0
81550: PUSH
81551: LD_INT 0
81553: PUSH
81554: EMPTY
81555: LIST
81556: LIST
81557: PUSH
81558: LD_INT 0
81560: PUSH
81561: LD_INT 1
81563: NEG
81564: PUSH
81565: EMPTY
81566: LIST
81567: LIST
81568: PUSH
81569: LD_INT 1
81571: PUSH
81572: LD_INT 0
81574: PUSH
81575: EMPTY
81576: LIST
81577: LIST
81578: PUSH
81579: LD_INT 1
81581: PUSH
81582: LD_INT 1
81584: PUSH
81585: EMPTY
81586: LIST
81587: LIST
81588: PUSH
81589: LD_INT 0
81591: PUSH
81592: LD_INT 1
81594: PUSH
81595: EMPTY
81596: LIST
81597: LIST
81598: PUSH
81599: LD_INT 1
81601: NEG
81602: PUSH
81603: LD_INT 0
81605: PUSH
81606: EMPTY
81607: LIST
81608: LIST
81609: PUSH
81610: LD_INT 1
81612: NEG
81613: PUSH
81614: LD_INT 1
81616: NEG
81617: PUSH
81618: EMPTY
81619: LIST
81620: LIST
81621: PUSH
81622: LD_INT 1
81624: NEG
81625: PUSH
81626: LD_INT 2
81628: NEG
81629: PUSH
81630: EMPTY
81631: LIST
81632: LIST
81633: PUSH
81634: LD_INT 0
81636: PUSH
81637: LD_INT 2
81639: NEG
81640: PUSH
81641: EMPTY
81642: LIST
81643: LIST
81644: PUSH
81645: LD_INT 1
81647: PUSH
81648: LD_INT 1
81650: NEG
81651: PUSH
81652: EMPTY
81653: LIST
81654: LIST
81655: PUSH
81656: LD_INT 2
81658: PUSH
81659: LD_INT 0
81661: PUSH
81662: EMPTY
81663: LIST
81664: LIST
81665: PUSH
81666: LD_INT 2
81668: PUSH
81669: LD_INT 1
81671: PUSH
81672: EMPTY
81673: LIST
81674: LIST
81675: PUSH
81676: LD_INT 2
81678: PUSH
81679: LD_INT 2
81681: PUSH
81682: EMPTY
81683: LIST
81684: LIST
81685: PUSH
81686: LD_INT 1
81688: PUSH
81689: LD_INT 2
81691: PUSH
81692: EMPTY
81693: LIST
81694: LIST
81695: PUSH
81696: LD_INT 0
81698: PUSH
81699: LD_INT 2
81701: PUSH
81702: EMPTY
81703: LIST
81704: LIST
81705: PUSH
81706: LD_INT 1
81708: NEG
81709: PUSH
81710: LD_INT 1
81712: PUSH
81713: EMPTY
81714: LIST
81715: LIST
81716: PUSH
81717: LD_INT 2
81719: NEG
81720: PUSH
81721: LD_INT 0
81723: PUSH
81724: EMPTY
81725: LIST
81726: LIST
81727: PUSH
81728: LD_INT 2
81730: NEG
81731: PUSH
81732: LD_INT 1
81734: NEG
81735: PUSH
81736: EMPTY
81737: LIST
81738: LIST
81739: PUSH
81740: LD_INT 2
81742: NEG
81743: PUSH
81744: LD_INT 2
81746: NEG
81747: PUSH
81748: EMPTY
81749: LIST
81750: LIST
81751: PUSH
81752: LD_INT 1
81754: PUSH
81755: LD_INT 2
81757: NEG
81758: PUSH
81759: EMPTY
81760: LIST
81761: LIST
81762: PUSH
81763: LD_INT 2
81765: PUSH
81766: LD_INT 1
81768: NEG
81769: PUSH
81770: EMPTY
81771: LIST
81772: LIST
81773: PUSH
81774: LD_INT 3
81776: PUSH
81777: LD_INT 1
81779: PUSH
81780: EMPTY
81781: LIST
81782: LIST
81783: PUSH
81784: LD_INT 3
81786: PUSH
81787: LD_INT 2
81789: PUSH
81790: EMPTY
81791: LIST
81792: LIST
81793: PUSH
81794: EMPTY
81795: LIST
81796: LIST
81797: LIST
81798: LIST
81799: LIST
81800: LIST
81801: LIST
81802: LIST
81803: LIST
81804: LIST
81805: LIST
81806: LIST
81807: LIST
81808: LIST
81809: LIST
81810: LIST
81811: LIST
81812: LIST
81813: LIST
81814: LIST
81815: LIST
81816: LIST
81817: LIST
81818: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
81819: LD_ADDR_VAR 0 25
81823: PUSH
81824: LD_INT 0
81826: PUSH
81827: LD_INT 0
81829: PUSH
81830: EMPTY
81831: LIST
81832: LIST
81833: PUSH
81834: LD_INT 0
81836: PUSH
81837: LD_INT 1
81839: NEG
81840: PUSH
81841: EMPTY
81842: LIST
81843: LIST
81844: PUSH
81845: LD_INT 1
81847: PUSH
81848: LD_INT 0
81850: PUSH
81851: EMPTY
81852: LIST
81853: LIST
81854: PUSH
81855: LD_INT 1
81857: PUSH
81858: LD_INT 1
81860: PUSH
81861: EMPTY
81862: LIST
81863: LIST
81864: PUSH
81865: LD_INT 0
81867: PUSH
81868: LD_INT 1
81870: PUSH
81871: EMPTY
81872: LIST
81873: LIST
81874: PUSH
81875: LD_INT 1
81877: NEG
81878: PUSH
81879: LD_INT 0
81881: PUSH
81882: EMPTY
81883: LIST
81884: LIST
81885: PUSH
81886: LD_INT 1
81888: NEG
81889: PUSH
81890: LD_INT 1
81892: NEG
81893: PUSH
81894: EMPTY
81895: LIST
81896: LIST
81897: PUSH
81898: LD_INT 1
81900: NEG
81901: PUSH
81902: LD_INT 2
81904: NEG
81905: PUSH
81906: EMPTY
81907: LIST
81908: LIST
81909: PUSH
81910: LD_INT 0
81912: PUSH
81913: LD_INT 2
81915: NEG
81916: PUSH
81917: EMPTY
81918: LIST
81919: LIST
81920: PUSH
81921: LD_INT 1
81923: PUSH
81924: LD_INT 1
81926: NEG
81927: PUSH
81928: EMPTY
81929: LIST
81930: LIST
81931: PUSH
81932: LD_INT 2
81934: PUSH
81935: LD_INT 0
81937: PUSH
81938: EMPTY
81939: LIST
81940: LIST
81941: PUSH
81942: LD_INT 2
81944: PUSH
81945: LD_INT 1
81947: PUSH
81948: EMPTY
81949: LIST
81950: LIST
81951: PUSH
81952: LD_INT 2
81954: PUSH
81955: LD_INT 2
81957: PUSH
81958: EMPTY
81959: LIST
81960: LIST
81961: PUSH
81962: LD_INT 1
81964: PUSH
81965: LD_INT 2
81967: PUSH
81968: EMPTY
81969: LIST
81970: LIST
81971: PUSH
81972: LD_INT 0
81974: PUSH
81975: LD_INT 2
81977: PUSH
81978: EMPTY
81979: LIST
81980: LIST
81981: PUSH
81982: LD_INT 1
81984: NEG
81985: PUSH
81986: LD_INT 1
81988: PUSH
81989: EMPTY
81990: LIST
81991: LIST
81992: PUSH
81993: LD_INT 2
81995: NEG
81996: PUSH
81997: LD_INT 0
81999: PUSH
82000: EMPTY
82001: LIST
82002: LIST
82003: PUSH
82004: LD_INT 2
82006: NEG
82007: PUSH
82008: LD_INT 1
82010: NEG
82011: PUSH
82012: EMPTY
82013: LIST
82014: LIST
82015: PUSH
82016: LD_INT 2
82018: NEG
82019: PUSH
82020: LD_INT 2
82022: NEG
82023: PUSH
82024: EMPTY
82025: LIST
82026: LIST
82027: PUSH
82028: LD_INT 3
82030: PUSH
82031: LD_INT 1
82033: PUSH
82034: EMPTY
82035: LIST
82036: LIST
82037: PUSH
82038: LD_INT 3
82040: PUSH
82041: LD_INT 2
82043: PUSH
82044: EMPTY
82045: LIST
82046: LIST
82047: PUSH
82048: LD_INT 2
82050: PUSH
82051: LD_INT 3
82053: PUSH
82054: EMPTY
82055: LIST
82056: LIST
82057: PUSH
82058: LD_INT 1
82060: PUSH
82061: LD_INT 3
82063: PUSH
82064: EMPTY
82065: LIST
82066: LIST
82067: PUSH
82068: EMPTY
82069: LIST
82070: LIST
82071: LIST
82072: LIST
82073: LIST
82074: LIST
82075: LIST
82076: LIST
82077: LIST
82078: LIST
82079: LIST
82080: LIST
82081: LIST
82082: LIST
82083: LIST
82084: LIST
82085: LIST
82086: LIST
82087: LIST
82088: LIST
82089: LIST
82090: LIST
82091: LIST
82092: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
82093: LD_ADDR_VAR 0 26
82097: PUSH
82098: LD_INT 0
82100: PUSH
82101: LD_INT 0
82103: PUSH
82104: EMPTY
82105: LIST
82106: LIST
82107: PUSH
82108: LD_INT 0
82110: PUSH
82111: LD_INT 1
82113: NEG
82114: PUSH
82115: EMPTY
82116: LIST
82117: LIST
82118: PUSH
82119: LD_INT 1
82121: PUSH
82122: LD_INT 0
82124: PUSH
82125: EMPTY
82126: LIST
82127: LIST
82128: PUSH
82129: LD_INT 1
82131: PUSH
82132: LD_INT 1
82134: PUSH
82135: EMPTY
82136: LIST
82137: LIST
82138: PUSH
82139: LD_INT 0
82141: PUSH
82142: LD_INT 1
82144: PUSH
82145: EMPTY
82146: LIST
82147: LIST
82148: PUSH
82149: LD_INT 1
82151: NEG
82152: PUSH
82153: LD_INT 0
82155: PUSH
82156: EMPTY
82157: LIST
82158: LIST
82159: PUSH
82160: LD_INT 1
82162: NEG
82163: PUSH
82164: LD_INT 1
82166: NEG
82167: PUSH
82168: EMPTY
82169: LIST
82170: LIST
82171: PUSH
82172: LD_INT 1
82174: NEG
82175: PUSH
82176: LD_INT 2
82178: NEG
82179: PUSH
82180: EMPTY
82181: LIST
82182: LIST
82183: PUSH
82184: LD_INT 0
82186: PUSH
82187: LD_INT 2
82189: NEG
82190: PUSH
82191: EMPTY
82192: LIST
82193: LIST
82194: PUSH
82195: LD_INT 1
82197: PUSH
82198: LD_INT 1
82200: NEG
82201: PUSH
82202: EMPTY
82203: LIST
82204: LIST
82205: PUSH
82206: LD_INT 2
82208: PUSH
82209: LD_INT 0
82211: PUSH
82212: EMPTY
82213: LIST
82214: LIST
82215: PUSH
82216: LD_INT 2
82218: PUSH
82219: LD_INT 1
82221: PUSH
82222: EMPTY
82223: LIST
82224: LIST
82225: PUSH
82226: LD_INT 2
82228: PUSH
82229: LD_INT 2
82231: PUSH
82232: EMPTY
82233: LIST
82234: LIST
82235: PUSH
82236: LD_INT 1
82238: PUSH
82239: LD_INT 2
82241: PUSH
82242: EMPTY
82243: LIST
82244: LIST
82245: PUSH
82246: LD_INT 0
82248: PUSH
82249: LD_INT 2
82251: PUSH
82252: EMPTY
82253: LIST
82254: LIST
82255: PUSH
82256: LD_INT 1
82258: NEG
82259: PUSH
82260: LD_INT 1
82262: PUSH
82263: EMPTY
82264: LIST
82265: LIST
82266: PUSH
82267: LD_INT 2
82269: NEG
82270: PUSH
82271: LD_INT 0
82273: PUSH
82274: EMPTY
82275: LIST
82276: LIST
82277: PUSH
82278: LD_INT 2
82280: NEG
82281: PUSH
82282: LD_INT 1
82284: NEG
82285: PUSH
82286: EMPTY
82287: LIST
82288: LIST
82289: PUSH
82290: LD_INT 2
82292: NEG
82293: PUSH
82294: LD_INT 2
82296: NEG
82297: PUSH
82298: EMPTY
82299: LIST
82300: LIST
82301: PUSH
82302: LD_INT 2
82304: PUSH
82305: LD_INT 3
82307: PUSH
82308: EMPTY
82309: LIST
82310: LIST
82311: PUSH
82312: LD_INT 1
82314: PUSH
82315: LD_INT 3
82317: PUSH
82318: EMPTY
82319: LIST
82320: LIST
82321: PUSH
82322: LD_INT 1
82324: NEG
82325: PUSH
82326: LD_INT 2
82328: PUSH
82329: EMPTY
82330: LIST
82331: LIST
82332: PUSH
82333: LD_INT 2
82335: NEG
82336: PUSH
82337: LD_INT 1
82339: PUSH
82340: EMPTY
82341: LIST
82342: LIST
82343: PUSH
82344: EMPTY
82345: LIST
82346: LIST
82347: LIST
82348: LIST
82349: LIST
82350: LIST
82351: LIST
82352: LIST
82353: LIST
82354: LIST
82355: LIST
82356: LIST
82357: LIST
82358: LIST
82359: LIST
82360: LIST
82361: LIST
82362: LIST
82363: LIST
82364: LIST
82365: LIST
82366: LIST
82367: LIST
82368: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82369: LD_ADDR_VAR 0 27
82373: PUSH
82374: LD_INT 0
82376: PUSH
82377: LD_INT 0
82379: PUSH
82380: EMPTY
82381: LIST
82382: LIST
82383: PUSH
82384: LD_INT 0
82386: PUSH
82387: LD_INT 1
82389: NEG
82390: PUSH
82391: EMPTY
82392: LIST
82393: LIST
82394: PUSH
82395: LD_INT 1
82397: PUSH
82398: LD_INT 0
82400: PUSH
82401: EMPTY
82402: LIST
82403: LIST
82404: PUSH
82405: LD_INT 1
82407: PUSH
82408: LD_INT 1
82410: PUSH
82411: EMPTY
82412: LIST
82413: LIST
82414: PUSH
82415: LD_INT 0
82417: PUSH
82418: LD_INT 1
82420: PUSH
82421: EMPTY
82422: LIST
82423: LIST
82424: PUSH
82425: LD_INT 1
82427: NEG
82428: PUSH
82429: LD_INT 0
82431: PUSH
82432: EMPTY
82433: LIST
82434: LIST
82435: PUSH
82436: LD_INT 1
82438: NEG
82439: PUSH
82440: LD_INT 1
82442: NEG
82443: PUSH
82444: EMPTY
82445: LIST
82446: LIST
82447: PUSH
82448: LD_INT 1
82450: NEG
82451: PUSH
82452: LD_INT 2
82454: NEG
82455: PUSH
82456: EMPTY
82457: LIST
82458: LIST
82459: PUSH
82460: LD_INT 0
82462: PUSH
82463: LD_INT 2
82465: NEG
82466: PUSH
82467: EMPTY
82468: LIST
82469: LIST
82470: PUSH
82471: LD_INT 1
82473: PUSH
82474: LD_INT 1
82476: NEG
82477: PUSH
82478: EMPTY
82479: LIST
82480: LIST
82481: PUSH
82482: LD_INT 2
82484: PUSH
82485: LD_INT 0
82487: PUSH
82488: EMPTY
82489: LIST
82490: LIST
82491: PUSH
82492: LD_INT 2
82494: PUSH
82495: LD_INT 1
82497: PUSH
82498: EMPTY
82499: LIST
82500: LIST
82501: PUSH
82502: LD_INT 2
82504: PUSH
82505: LD_INT 2
82507: PUSH
82508: EMPTY
82509: LIST
82510: LIST
82511: PUSH
82512: LD_INT 1
82514: PUSH
82515: LD_INT 2
82517: PUSH
82518: EMPTY
82519: LIST
82520: LIST
82521: PUSH
82522: LD_INT 0
82524: PUSH
82525: LD_INT 2
82527: PUSH
82528: EMPTY
82529: LIST
82530: LIST
82531: PUSH
82532: LD_INT 1
82534: NEG
82535: PUSH
82536: LD_INT 1
82538: PUSH
82539: EMPTY
82540: LIST
82541: LIST
82542: PUSH
82543: LD_INT 2
82545: NEG
82546: PUSH
82547: LD_INT 0
82549: PUSH
82550: EMPTY
82551: LIST
82552: LIST
82553: PUSH
82554: LD_INT 2
82556: NEG
82557: PUSH
82558: LD_INT 1
82560: NEG
82561: PUSH
82562: EMPTY
82563: LIST
82564: LIST
82565: PUSH
82566: LD_INT 2
82568: NEG
82569: PUSH
82570: LD_INT 2
82572: NEG
82573: PUSH
82574: EMPTY
82575: LIST
82576: LIST
82577: PUSH
82578: LD_INT 1
82580: NEG
82581: PUSH
82582: LD_INT 2
82584: PUSH
82585: EMPTY
82586: LIST
82587: LIST
82588: PUSH
82589: LD_INT 2
82591: NEG
82592: PUSH
82593: LD_INT 1
82595: PUSH
82596: EMPTY
82597: LIST
82598: LIST
82599: PUSH
82600: LD_INT 3
82602: NEG
82603: PUSH
82604: LD_INT 1
82606: NEG
82607: PUSH
82608: EMPTY
82609: LIST
82610: LIST
82611: PUSH
82612: LD_INT 3
82614: NEG
82615: PUSH
82616: LD_INT 2
82618: NEG
82619: PUSH
82620: EMPTY
82621: LIST
82622: LIST
82623: PUSH
82624: EMPTY
82625: LIST
82626: LIST
82627: LIST
82628: LIST
82629: LIST
82630: LIST
82631: LIST
82632: LIST
82633: LIST
82634: LIST
82635: LIST
82636: LIST
82637: LIST
82638: LIST
82639: LIST
82640: LIST
82641: LIST
82642: LIST
82643: LIST
82644: LIST
82645: LIST
82646: LIST
82647: LIST
82648: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82649: LD_ADDR_VAR 0 28
82653: PUSH
82654: LD_INT 0
82656: PUSH
82657: LD_INT 0
82659: PUSH
82660: EMPTY
82661: LIST
82662: LIST
82663: PUSH
82664: LD_INT 0
82666: PUSH
82667: LD_INT 1
82669: NEG
82670: PUSH
82671: EMPTY
82672: LIST
82673: LIST
82674: PUSH
82675: LD_INT 1
82677: PUSH
82678: LD_INT 0
82680: PUSH
82681: EMPTY
82682: LIST
82683: LIST
82684: PUSH
82685: LD_INT 1
82687: PUSH
82688: LD_INT 1
82690: PUSH
82691: EMPTY
82692: LIST
82693: LIST
82694: PUSH
82695: LD_INT 0
82697: PUSH
82698: LD_INT 1
82700: PUSH
82701: EMPTY
82702: LIST
82703: LIST
82704: PUSH
82705: LD_INT 1
82707: NEG
82708: PUSH
82709: LD_INT 0
82711: PUSH
82712: EMPTY
82713: LIST
82714: LIST
82715: PUSH
82716: LD_INT 1
82718: NEG
82719: PUSH
82720: LD_INT 1
82722: NEG
82723: PUSH
82724: EMPTY
82725: LIST
82726: LIST
82727: PUSH
82728: LD_INT 1
82730: NEG
82731: PUSH
82732: LD_INT 2
82734: NEG
82735: PUSH
82736: EMPTY
82737: LIST
82738: LIST
82739: PUSH
82740: LD_INT 0
82742: PUSH
82743: LD_INT 2
82745: NEG
82746: PUSH
82747: EMPTY
82748: LIST
82749: LIST
82750: PUSH
82751: LD_INT 1
82753: PUSH
82754: LD_INT 1
82756: NEG
82757: PUSH
82758: EMPTY
82759: LIST
82760: LIST
82761: PUSH
82762: LD_INT 2
82764: PUSH
82765: LD_INT 0
82767: PUSH
82768: EMPTY
82769: LIST
82770: LIST
82771: PUSH
82772: LD_INT 2
82774: PUSH
82775: LD_INT 1
82777: PUSH
82778: EMPTY
82779: LIST
82780: LIST
82781: PUSH
82782: LD_INT 2
82784: PUSH
82785: LD_INT 2
82787: PUSH
82788: EMPTY
82789: LIST
82790: LIST
82791: PUSH
82792: LD_INT 1
82794: PUSH
82795: LD_INT 2
82797: PUSH
82798: EMPTY
82799: LIST
82800: LIST
82801: PUSH
82802: LD_INT 0
82804: PUSH
82805: LD_INT 2
82807: PUSH
82808: EMPTY
82809: LIST
82810: LIST
82811: PUSH
82812: LD_INT 1
82814: NEG
82815: PUSH
82816: LD_INT 1
82818: PUSH
82819: EMPTY
82820: LIST
82821: LIST
82822: PUSH
82823: LD_INT 2
82825: NEG
82826: PUSH
82827: LD_INT 0
82829: PUSH
82830: EMPTY
82831: LIST
82832: LIST
82833: PUSH
82834: LD_INT 2
82836: NEG
82837: PUSH
82838: LD_INT 1
82840: NEG
82841: PUSH
82842: EMPTY
82843: LIST
82844: LIST
82845: PUSH
82846: LD_INT 2
82848: NEG
82849: PUSH
82850: LD_INT 2
82852: NEG
82853: PUSH
82854: EMPTY
82855: LIST
82856: LIST
82857: PUSH
82858: LD_INT 2
82860: NEG
82861: PUSH
82862: LD_INT 3
82864: NEG
82865: PUSH
82866: EMPTY
82867: LIST
82868: LIST
82869: PUSH
82870: LD_INT 1
82872: NEG
82873: PUSH
82874: LD_INT 3
82876: NEG
82877: PUSH
82878: EMPTY
82879: LIST
82880: LIST
82881: PUSH
82882: LD_INT 3
82884: NEG
82885: PUSH
82886: LD_INT 1
82888: NEG
82889: PUSH
82890: EMPTY
82891: LIST
82892: LIST
82893: PUSH
82894: LD_INT 3
82896: NEG
82897: PUSH
82898: LD_INT 2
82900: NEG
82901: PUSH
82902: EMPTY
82903: LIST
82904: LIST
82905: PUSH
82906: EMPTY
82907: LIST
82908: LIST
82909: LIST
82910: LIST
82911: LIST
82912: LIST
82913: LIST
82914: LIST
82915: LIST
82916: LIST
82917: LIST
82918: LIST
82919: LIST
82920: LIST
82921: LIST
82922: LIST
82923: LIST
82924: LIST
82925: LIST
82926: LIST
82927: LIST
82928: LIST
82929: LIST
82930: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82931: LD_ADDR_VAR 0 29
82935: PUSH
82936: LD_INT 0
82938: PUSH
82939: LD_INT 0
82941: PUSH
82942: EMPTY
82943: LIST
82944: LIST
82945: PUSH
82946: LD_INT 0
82948: PUSH
82949: LD_INT 1
82951: NEG
82952: PUSH
82953: EMPTY
82954: LIST
82955: LIST
82956: PUSH
82957: LD_INT 1
82959: PUSH
82960: LD_INT 0
82962: PUSH
82963: EMPTY
82964: LIST
82965: LIST
82966: PUSH
82967: LD_INT 1
82969: PUSH
82970: LD_INT 1
82972: PUSH
82973: EMPTY
82974: LIST
82975: LIST
82976: PUSH
82977: LD_INT 0
82979: PUSH
82980: LD_INT 1
82982: PUSH
82983: EMPTY
82984: LIST
82985: LIST
82986: PUSH
82987: LD_INT 1
82989: NEG
82990: PUSH
82991: LD_INT 0
82993: PUSH
82994: EMPTY
82995: LIST
82996: LIST
82997: PUSH
82998: LD_INT 1
83000: NEG
83001: PUSH
83002: LD_INT 1
83004: NEG
83005: PUSH
83006: EMPTY
83007: LIST
83008: LIST
83009: PUSH
83010: LD_INT 1
83012: NEG
83013: PUSH
83014: LD_INT 2
83016: NEG
83017: PUSH
83018: EMPTY
83019: LIST
83020: LIST
83021: PUSH
83022: LD_INT 0
83024: PUSH
83025: LD_INT 2
83027: NEG
83028: PUSH
83029: EMPTY
83030: LIST
83031: LIST
83032: PUSH
83033: LD_INT 1
83035: PUSH
83036: LD_INT 1
83038: NEG
83039: PUSH
83040: EMPTY
83041: LIST
83042: LIST
83043: PUSH
83044: LD_INT 2
83046: PUSH
83047: LD_INT 0
83049: PUSH
83050: EMPTY
83051: LIST
83052: LIST
83053: PUSH
83054: LD_INT 2
83056: PUSH
83057: LD_INT 1
83059: PUSH
83060: EMPTY
83061: LIST
83062: LIST
83063: PUSH
83064: LD_INT 1
83066: PUSH
83067: LD_INT 2
83069: PUSH
83070: EMPTY
83071: LIST
83072: LIST
83073: PUSH
83074: LD_INT 0
83076: PUSH
83077: LD_INT 2
83079: PUSH
83080: EMPTY
83081: LIST
83082: LIST
83083: PUSH
83084: LD_INT 1
83086: NEG
83087: PUSH
83088: LD_INT 1
83090: PUSH
83091: EMPTY
83092: LIST
83093: LIST
83094: PUSH
83095: LD_INT 2
83097: NEG
83098: PUSH
83099: LD_INT 1
83101: NEG
83102: PUSH
83103: EMPTY
83104: LIST
83105: LIST
83106: PUSH
83107: LD_INT 2
83109: NEG
83110: PUSH
83111: LD_INT 2
83113: NEG
83114: PUSH
83115: EMPTY
83116: LIST
83117: LIST
83118: PUSH
83119: LD_INT 2
83121: NEG
83122: PUSH
83123: LD_INT 3
83125: NEG
83126: PUSH
83127: EMPTY
83128: LIST
83129: LIST
83130: PUSH
83131: LD_INT 2
83133: PUSH
83134: LD_INT 1
83136: NEG
83137: PUSH
83138: EMPTY
83139: LIST
83140: LIST
83141: PUSH
83142: LD_INT 3
83144: PUSH
83145: LD_INT 1
83147: PUSH
83148: EMPTY
83149: LIST
83150: LIST
83151: PUSH
83152: LD_INT 1
83154: PUSH
83155: LD_INT 3
83157: PUSH
83158: EMPTY
83159: LIST
83160: LIST
83161: PUSH
83162: LD_INT 1
83164: NEG
83165: PUSH
83166: LD_INT 2
83168: PUSH
83169: EMPTY
83170: LIST
83171: LIST
83172: PUSH
83173: LD_INT 3
83175: NEG
83176: PUSH
83177: LD_INT 2
83179: NEG
83180: PUSH
83181: EMPTY
83182: LIST
83183: LIST
83184: PUSH
83185: EMPTY
83186: LIST
83187: LIST
83188: LIST
83189: LIST
83190: LIST
83191: LIST
83192: LIST
83193: LIST
83194: LIST
83195: LIST
83196: LIST
83197: LIST
83198: LIST
83199: LIST
83200: LIST
83201: LIST
83202: LIST
83203: LIST
83204: LIST
83205: LIST
83206: LIST
83207: LIST
83208: LIST
83209: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83210: LD_ADDR_VAR 0 30
83214: PUSH
83215: LD_INT 0
83217: PUSH
83218: LD_INT 0
83220: PUSH
83221: EMPTY
83222: LIST
83223: LIST
83224: PUSH
83225: LD_INT 0
83227: PUSH
83228: LD_INT 1
83230: NEG
83231: PUSH
83232: EMPTY
83233: LIST
83234: LIST
83235: PUSH
83236: LD_INT 1
83238: PUSH
83239: LD_INT 0
83241: PUSH
83242: EMPTY
83243: LIST
83244: LIST
83245: PUSH
83246: LD_INT 1
83248: PUSH
83249: LD_INT 1
83251: PUSH
83252: EMPTY
83253: LIST
83254: LIST
83255: PUSH
83256: LD_INT 0
83258: PUSH
83259: LD_INT 1
83261: PUSH
83262: EMPTY
83263: LIST
83264: LIST
83265: PUSH
83266: LD_INT 1
83268: NEG
83269: PUSH
83270: LD_INT 0
83272: PUSH
83273: EMPTY
83274: LIST
83275: LIST
83276: PUSH
83277: LD_INT 1
83279: NEG
83280: PUSH
83281: LD_INT 1
83283: NEG
83284: PUSH
83285: EMPTY
83286: LIST
83287: LIST
83288: PUSH
83289: LD_INT 1
83291: NEG
83292: PUSH
83293: LD_INT 2
83295: NEG
83296: PUSH
83297: EMPTY
83298: LIST
83299: LIST
83300: PUSH
83301: LD_INT 0
83303: PUSH
83304: LD_INT 2
83306: NEG
83307: PUSH
83308: EMPTY
83309: LIST
83310: LIST
83311: PUSH
83312: LD_INT 1
83314: PUSH
83315: LD_INT 1
83317: NEG
83318: PUSH
83319: EMPTY
83320: LIST
83321: LIST
83322: PUSH
83323: LD_INT 2
83325: PUSH
83326: LD_INT 0
83328: PUSH
83329: EMPTY
83330: LIST
83331: LIST
83332: PUSH
83333: LD_INT 2
83335: PUSH
83336: LD_INT 1
83338: PUSH
83339: EMPTY
83340: LIST
83341: LIST
83342: PUSH
83343: LD_INT 2
83345: PUSH
83346: LD_INT 2
83348: PUSH
83349: EMPTY
83350: LIST
83351: LIST
83352: PUSH
83353: LD_INT 1
83355: PUSH
83356: LD_INT 2
83358: PUSH
83359: EMPTY
83360: LIST
83361: LIST
83362: PUSH
83363: LD_INT 1
83365: NEG
83366: PUSH
83367: LD_INT 1
83369: PUSH
83370: EMPTY
83371: LIST
83372: LIST
83373: PUSH
83374: LD_INT 2
83376: NEG
83377: PUSH
83378: LD_INT 0
83380: PUSH
83381: EMPTY
83382: LIST
83383: LIST
83384: PUSH
83385: LD_INT 2
83387: NEG
83388: PUSH
83389: LD_INT 1
83391: NEG
83392: PUSH
83393: EMPTY
83394: LIST
83395: LIST
83396: PUSH
83397: LD_INT 1
83399: NEG
83400: PUSH
83401: LD_INT 3
83403: NEG
83404: PUSH
83405: EMPTY
83406: LIST
83407: LIST
83408: PUSH
83409: LD_INT 1
83411: PUSH
83412: LD_INT 2
83414: NEG
83415: PUSH
83416: EMPTY
83417: LIST
83418: LIST
83419: PUSH
83420: LD_INT 3
83422: PUSH
83423: LD_INT 2
83425: PUSH
83426: EMPTY
83427: LIST
83428: LIST
83429: PUSH
83430: LD_INT 2
83432: PUSH
83433: LD_INT 3
83435: PUSH
83436: EMPTY
83437: LIST
83438: LIST
83439: PUSH
83440: LD_INT 2
83442: NEG
83443: PUSH
83444: LD_INT 1
83446: PUSH
83447: EMPTY
83448: LIST
83449: LIST
83450: PUSH
83451: LD_INT 3
83453: NEG
83454: PUSH
83455: LD_INT 1
83457: NEG
83458: PUSH
83459: EMPTY
83460: LIST
83461: LIST
83462: PUSH
83463: EMPTY
83464: LIST
83465: LIST
83466: LIST
83467: LIST
83468: LIST
83469: LIST
83470: LIST
83471: LIST
83472: LIST
83473: LIST
83474: LIST
83475: LIST
83476: LIST
83477: LIST
83478: LIST
83479: LIST
83480: LIST
83481: LIST
83482: LIST
83483: LIST
83484: LIST
83485: LIST
83486: LIST
83487: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83488: LD_ADDR_VAR 0 31
83492: PUSH
83493: LD_INT 0
83495: PUSH
83496: LD_INT 0
83498: PUSH
83499: EMPTY
83500: LIST
83501: LIST
83502: PUSH
83503: LD_INT 0
83505: PUSH
83506: LD_INT 1
83508: NEG
83509: PUSH
83510: EMPTY
83511: LIST
83512: LIST
83513: PUSH
83514: LD_INT 1
83516: PUSH
83517: LD_INT 0
83519: PUSH
83520: EMPTY
83521: LIST
83522: LIST
83523: PUSH
83524: LD_INT 1
83526: PUSH
83527: LD_INT 1
83529: PUSH
83530: EMPTY
83531: LIST
83532: LIST
83533: PUSH
83534: LD_INT 0
83536: PUSH
83537: LD_INT 1
83539: PUSH
83540: EMPTY
83541: LIST
83542: LIST
83543: PUSH
83544: LD_INT 1
83546: NEG
83547: PUSH
83548: LD_INT 0
83550: PUSH
83551: EMPTY
83552: LIST
83553: LIST
83554: PUSH
83555: LD_INT 1
83557: NEG
83558: PUSH
83559: LD_INT 1
83561: NEG
83562: PUSH
83563: EMPTY
83564: LIST
83565: LIST
83566: PUSH
83567: LD_INT 1
83569: NEG
83570: PUSH
83571: LD_INT 2
83573: NEG
83574: PUSH
83575: EMPTY
83576: LIST
83577: LIST
83578: PUSH
83579: LD_INT 1
83581: PUSH
83582: LD_INT 1
83584: NEG
83585: PUSH
83586: EMPTY
83587: LIST
83588: LIST
83589: PUSH
83590: LD_INT 2
83592: PUSH
83593: LD_INT 0
83595: PUSH
83596: EMPTY
83597: LIST
83598: LIST
83599: PUSH
83600: LD_INT 2
83602: PUSH
83603: LD_INT 1
83605: PUSH
83606: EMPTY
83607: LIST
83608: LIST
83609: PUSH
83610: LD_INT 2
83612: PUSH
83613: LD_INT 2
83615: PUSH
83616: EMPTY
83617: LIST
83618: LIST
83619: PUSH
83620: LD_INT 1
83622: PUSH
83623: LD_INT 2
83625: PUSH
83626: EMPTY
83627: LIST
83628: LIST
83629: PUSH
83630: LD_INT 0
83632: PUSH
83633: LD_INT 2
83635: PUSH
83636: EMPTY
83637: LIST
83638: LIST
83639: PUSH
83640: LD_INT 1
83642: NEG
83643: PUSH
83644: LD_INT 1
83646: PUSH
83647: EMPTY
83648: LIST
83649: LIST
83650: PUSH
83651: LD_INT 2
83653: NEG
83654: PUSH
83655: LD_INT 1
83657: NEG
83658: PUSH
83659: EMPTY
83660: LIST
83661: LIST
83662: PUSH
83663: LD_INT 2
83665: NEG
83666: PUSH
83667: LD_INT 2
83669: NEG
83670: PUSH
83671: EMPTY
83672: LIST
83673: LIST
83674: PUSH
83675: LD_INT 2
83677: NEG
83678: PUSH
83679: LD_INT 3
83681: NEG
83682: PUSH
83683: EMPTY
83684: LIST
83685: LIST
83686: PUSH
83687: LD_INT 2
83689: PUSH
83690: LD_INT 1
83692: NEG
83693: PUSH
83694: EMPTY
83695: LIST
83696: LIST
83697: PUSH
83698: LD_INT 3
83700: PUSH
83701: LD_INT 1
83703: PUSH
83704: EMPTY
83705: LIST
83706: LIST
83707: PUSH
83708: LD_INT 1
83710: PUSH
83711: LD_INT 3
83713: PUSH
83714: EMPTY
83715: LIST
83716: LIST
83717: PUSH
83718: LD_INT 1
83720: NEG
83721: PUSH
83722: LD_INT 2
83724: PUSH
83725: EMPTY
83726: LIST
83727: LIST
83728: PUSH
83729: LD_INT 3
83731: NEG
83732: PUSH
83733: LD_INT 2
83735: NEG
83736: PUSH
83737: EMPTY
83738: LIST
83739: LIST
83740: PUSH
83741: EMPTY
83742: LIST
83743: LIST
83744: LIST
83745: LIST
83746: LIST
83747: LIST
83748: LIST
83749: LIST
83750: LIST
83751: LIST
83752: LIST
83753: LIST
83754: LIST
83755: LIST
83756: LIST
83757: LIST
83758: LIST
83759: LIST
83760: LIST
83761: LIST
83762: LIST
83763: LIST
83764: LIST
83765: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83766: LD_ADDR_VAR 0 32
83770: PUSH
83771: LD_INT 0
83773: PUSH
83774: LD_INT 0
83776: PUSH
83777: EMPTY
83778: LIST
83779: LIST
83780: PUSH
83781: LD_INT 0
83783: PUSH
83784: LD_INT 1
83786: NEG
83787: PUSH
83788: EMPTY
83789: LIST
83790: LIST
83791: PUSH
83792: LD_INT 1
83794: PUSH
83795: LD_INT 0
83797: PUSH
83798: EMPTY
83799: LIST
83800: LIST
83801: PUSH
83802: LD_INT 1
83804: PUSH
83805: LD_INT 1
83807: PUSH
83808: EMPTY
83809: LIST
83810: LIST
83811: PUSH
83812: LD_INT 0
83814: PUSH
83815: LD_INT 1
83817: PUSH
83818: EMPTY
83819: LIST
83820: LIST
83821: PUSH
83822: LD_INT 1
83824: NEG
83825: PUSH
83826: LD_INT 0
83828: PUSH
83829: EMPTY
83830: LIST
83831: LIST
83832: PUSH
83833: LD_INT 1
83835: NEG
83836: PUSH
83837: LD_INT 1
83839: NEG
83840: PUSH
83841: EMPTY
83842: LIST
83843: LIST
83844: PUSH
83845: LD_INT 1
83847: NEG
83848: PUSH
83849: LD_INT 2
83851: NEG
83852: PUSH
83853: EMPTY
83854: LIST
83855: LIST
83856: PUSH
83857: LD_INT 0
83859: PUSH
83860: LD_INT 2
83862: NEG
83863: PUSH
83864: EMPTY
83865: LIST
83866: LIST
83867: PUSH
83868: LD_INT 1
83870: PUSH
83871: LD_INT 1
83873: NEG
83874: PUSH
83875: EMPTY
83876: LIST
83877: LIST
83878: PUSH
83879: LD_INT 2
83881: PUSH
83882: LD_INT 1
83884: PUSH
83885: EMPTY
83886: LIST
83887: LIST
83888: PUSH
83889: LD_INT 2
83891: PUSH
83892: LD_INT 2
83894: PUSH
83895: EMPTY
83896: LIST
83897: LIST
83898: PUSH
83899: LD_INT 1
83901: PUSH
83902: LD_INT 2
83904: PUSH
83905: EMPTY
83906: LIST
83907: LIST
83908: PUSH
83909: LD_INT 0
83911: PUSH
83912: LD_INT 2
83914: PUSH
83915: EMPTY
83916: LIST
83917: LIST
83918: PUSH
83919: LD_INT 1
83921: NEG
83922: PUSH
83923: LD_INT 1
83925: PUSH
83926: EMPTY
83927: LIST
83928: LIST
83929: PUSH
83930: LD_INT 2
83932: NEG
83933: PUSH
83934: LD_INT 0
83936: PUSH
83937: EMPTY
83938: LIST
83939: LIST
83940: PUSH
83941: LD_INT 2
83943: NEG
83944: PUSH
83945: LD_INT 1
83947: NEG
83948: PUSH
83949: EMPTY
83950: LIST
83951: LIST
83952: PUSH
83953: LD_INT 1
83955: NEG
83956: PUSH
83957: LD_INT 3
83959: NEG
83960: PUSH
83961: EMPTY
83962: LIST
83963: LIST
83964: PUSH
83965: LD_INT 1
83967: PUSH
83968: LD_INT 2
83970: NEG
83971: PUSH
83972: EMPTY
83973: LIST
83974: LIST
83975: PUSH
83976: LD_INT 3
83978: PUSH
83979: LD_INT 2
83981: PUSH
83982: EMPTY
83983: LIST
83984: LIST
83985: PUSH
83986: LD_INT 2
83988: PUSH
83989: LD_INT 3
83991: PUSH
83992: EMPTY
83993: LIST
83994: LIST
83995: PUSH
83996: LD_INT 2
83998: NEG
83999: PUSH
84000: LD_INT 1
84002: PUSH
84003: EMPTY
84004: LIST
84005: LIST
84006: PUSH
84007: LD_INT 3
84009: NEG
84010: PUSH
84011: LD_INT 1
84013: NEG
84014: PUSH
84015: EMPTY
84016: LIST
84017: LIST
84018: PUSH
84019: EMPTY
84020: LIST
84021: LIST
84022: LIST
84023: LIST
84024: LIST
84025: LIST
84026: LIST
84027: LIST
84028: LIST
84029: LIST
84030: LIST
84031: LIST
84032: LIST
84033: LIST
84034: LIST
84035: LIST
84036: LIST
84037: LIST
84038: LIST
84039: LIST
84040: LIST
84041: LIST
84042: LIST
84043: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84044: LD_ADDR_VAR 0 33
84048: PUSH
84049: LD_INT 0
84051: PUSH
84052: LD_INT 0
84054: PUSH
84055: EMPTY
84056: LIST
84057: LIST
84058: PUSH
84059: LD_INT 0
84061: PUSH
84062: LD_INT 1
84064: NEG
84065: PUSH
84066: EMPTY
84067: LIST
84068: LIST
84069: PUSH
84070: LD_INT 1
84072: PUSH
84073: LD_INT 0
84075: PUSH
84076: EMPTY
84077: LIST
84078: LIST
84079: PUSH
84080: LD_INT 1
84082: PUSH
84083: LD_INT 1
84085: PUSH
84086: EMPTY
84087: LIST
84088: LIST
84089: PUSH
84090: LD_INT 0
84092: PUSH
84093: LD_INT 1
84095: PUSH
84096: EMPTY
84097: LIST
84098: LIST
84099: PUSH
84100: LD_INT 1
84102: NEG
84103: PUSH
84104: LD_INT 0
84106: PUSH
84107: EMPTY
84108: LIST
84109: LIST
84110: PUSH
84111: LD_INT 1
84113: NEG
84114: PUSH
84115: LD_INT 1
84117: NEG
84118: PUSH
84119: EMPTY
84120: LIST
84121: LIST
84122: PUSH
84123: LD_INT 1
84125: NEG
84126: PUSH
84127: LD_INT 2
84129: NEG
84130: PUSH
84131: EMPTY
84132: LIST
84133: LIST
84134: PUSH
84135: LD_INT 1
84137: PUSH
84138: LD_INT 1
84140: NEG
84141: PUSH
84142: EMPTY
84143: LIST
84144: LIST
84145: PUSH
84146: LD_INT 2
84148: PUSH
84149: LD_INT 0
84151: PUSH
84152: EMPTY
84153: LIST
84154: LIST
84155: PUSH
84156: LD_INT 2
84158: PUSH
84159: LD_INT 1
84161: PUSH
84162: EMPTY
84163: LIST
84164: LIST
84165: PUSH
84166: LD_INT 1
84168: PUSH
84169: LD_INT 2
84171: PUSH
84172: EMPTY
84173: LIST
84174: LIST
84175: PUSH
84176: LD_INT 0
84178: PUSH
84179: LD_INT 2
84181: PUSH
84182: EMPTY
84183: LIST
84184: LIST
84185: PUSH
84186: LD_INT 1
84188: NEG
84189: PUSH
84190: LD_INT 1
84192: PUSH
84193: EMPTY
84194: LIST
84195: LIST
84196: PUSH
84197: LD_INT 2
84199: NEG
84200: PUSH
84201: LD_INT 0
84203: PUSH
84204: EMPTY
84205: LIST
84206: LIST
84207: PUSH
84208: LD_INT 2
84210: NEG
84211: PUSH
84212: LD_INT 1
84214: NEG
84215: PUSH
84216: EMPTY
84217: LIST
84218: LIST
84219: PUSH
84220: LD_INT 2
84222: NEG
84223: PUSH
84224: LD_INT 2
84226: NEG
84227: PUSH
84228: EMPTY
84229: LIST
84230: LIST
84231: PUSH
84232: LD_INT 2
84234: NEG
84235: PUSH
84236: LD_INT 3
84238: NEG
84239: PUSH
84240: EMPTY
84241: LIST
84242: LIST
84243: PUSH
84244: LD_INT 2
84246: PUSH
84247: LD_INT 1
84249: NEG
84250: PUSH
84251: EMPTY
84252: LIST
84253: LIST
84254: PUSH
84255: LD_INT 3
84257: PUSH
84258: LD_INT 1
84260: PUSH
84261: EMPTY
84262: LIST
84263: LIST
84264: PUSH
84265: LD_INT 1
84267: PUSH
84268: LD_INT 3
84270: PUSH
84271: EMPTY
84272: LIST
84273: LIST
84274: PUSH
84275: LD_INT 1
84277: NEG
84278: PUSH
84279: LD_INT 2
84281: PUSH
84282: EMPTY
84283: LIST
84284: LIST
84285: PUSH
84286: LD_INT 3
84288: NEG
84289: PUSH
84290: LD_INT 2
84292: NEG
84293: PUSH
84294: EMPTY
84295: LIST
84296: LIST
84297: PUSH
84298: EMPTY
84299: LIST
84300: LIST
84301: LIST
84302: LIST
84303: LIST
84304: LIST
84305: LIST
84306: LIST
84307: LIST
84308: LIST
84309: LIST
84310: LIST
84311: LIST
84312: LIST
84313: LIST
84314: LIST
84315: LIST
84316: LIST
84317: LIST
84318: LIST
84319: LIST
84320: LIST
84321: LIST
84322: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84323: LD_ADDR_VAR 0 34
84327: PUSH
84328: LD_INT 0
84330: PUSH
84331: LD_INT 0
84333: PUSH
84334: EMPTY
84335: LIST
84336: LIST
84337: PUSH
84338: LD_INT 0
84340: PUSH
84341: LD_INT 1
84343: NEG
84344: PUSH
84345: EMPTY
84346: LIST
84347: LIST
84348: PUSH
84349: LD_INT 1
84351: PUSH
84352: LD_INT 0
84354: PUSH
84355: EMPTY
84356: LIST
84357: LIST
84358: PUSH
84359: LD_INT 1
84361: PUSH
84362: LD_INT 1
84364: PUSH
84365: EMPTY
84366: LIST
84367: LIST
84368: PUSH
84369: LD_INT 0
84371: PUSH
84372: LD_INT 1
84374: PUSH
84375: EMPTY
84376: LIST
84377: LIST
84378: PUSH
84379: LD_INT 1
84381: NEG
84382: PUSH
84383: LD_INT 0
84385: PUSH
84386: EMPTY
84387: LIST
84388: LIST
84389: PUSH
84390: LD_INT 1
84392: NEG
84393: PUSH
84394: LD_INT 1
84396: NEG
84397: PUSH
84398: EMPTY
84399: LIST
84400: LIST
84401: PUSH
84402: LD_INT 1
84404: NEG
84405: PUSH
84406: LD_INT 2
84408: NEG
84409: PUSH
84410: EMPTY
84411: LIST
84412: LIST
84413: PUSH
84414: LD_INT 0
84416: PUSH
84417: LD_INT 2
84419: NEG
84420: PUSH
84421: EMPTY
84422: LIST
84423: LIST
84424: PUSH
84425: LD_INT 1
84427: PUSH
84428: LD_INT 1
84430: NEG
84431: PUSH
84432: EMPTY
84433: LIST
84434: LIST
84435: PUSH
84436: LD_INT 2
84438: PUSH
84439: LD_INT 1
84441: PUSH
84442: EMPTY
84443: LIST
84444: LIST
84445: PUSH
84446: LD_INT 2
84448: PUSH
84449: LD_INT 2
84451: PUSH
84452: EMPTY
84453: LIST
84454: LIST
84455: PUSH
84456: LD_INT 1
84458: PUSH
84459: LD_INT 2
84461: PUSH
84462: EMPTY
84463: LIST
84464: LIST
84465: PUSH
84466: LD_INT 1
84468: NEG
84469: PUSH
84470: LD_INT 1
84472: PUSH
84473: EMPTY
84474: LIST
84475: LIST
84476: PUSH
84477: LD_INT 2
84479: NEG
84480: PUSH
84481: LD_INT 0
84483: PUSH
84484: EMPTY
84485: LIST
84486: LIST
84487: PUSH
84488: LD_INT 2
84490: NEG
84491: PUSH
84492: LD_INT 1
84494: NEG
84495: PUSH
84496: EMPTY
84497: LIST
84498: LIST
84499: PUSH
84500: LD_INT 2
84502: NEG
84503: PUSH
84504: LD_INT 2
84506: NEG
84507: PUSH
84508: EMPTY
84509: LIST
84510: LIST
84511: PUSH
84512: LD_INT 1
84514: NEG
84515: PUSH
84516: LD_INT 3
84518: NEG
84519: PUSH
84520: EMPTY
84521: LIST
84522: LIST
84523: PUSH
84524: LD_INT 1
84526: PUSH
84527: LD_INT 2
84529: NEG
84530: PUSH
84531: EMPTY
84532: LIST
84533: LIST
84534: PUSH
84535: LD_INT 3
84537: PUSH
84538: LD_INT 2
84540: PUSH
84541: EMPTY
84542: LIST
84543: LIST
84544: PUSH
84545: LD_INT 2
84547: PUSH
84548: LD_INT 3
84550: PUSH
84551: EMPTY
84552: LIST
84553: LIST
84554: PUSH
84555: LD_INT 2
84557: NEG
84558: PUSH
84559: LD_INT 1
84561: PUSH
84562: EMPTY
84563: LIST
84564: LIST
84565: PUSH
84566: LD_INT 3
84568: NEG
84569: PUSH
84570: LD_INT 1
84572: NEG
84573: PUSH
84574: EMPTY
84575: LIST
84576: LIST
84577: PUSH
84578: EMPTY
84579: LIST
84580: LIST
84581: LIST
84582: LIST
84583: LIST
84584: LIST
84585: LIST
84586: LIST
84587: LIST
84588: LIST
84589: LIST
84590: LIST
84591: LIST
84592: LIST
84593: LIST
84594: LIST
84595: LIST
84596: LIST
84597: LIST
84598: LIST
84599: LIST
84600: LIST
84601: LIST
84602: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84603: LD_ADDR_VAR 0 35
84607: PUSH
84608: LD_INT 0
84610: PUSH
84611: LD_INT 0
84613: PUSH
84614: EMPTY
84615: LIST
84616: LIST
84617: PUSH
84618: LD_INT 0
84620: PUSH
84621: LD_INT 1
84623: NEG
84624: PUSH
84625: EMPTY
84626: LIST
84627: LIST
84628: PUSH
84629: LD_INT 1
84631: PUSH
84632: LD_INT 0
84634: PUSH
84635: EMPTY
84636: LIST
84637: LIST
84638: PUSH
84639: LD_INT 1
84641: PUSH
84642: LD_INT 1
84644: PUSH
84645: EMPTY
84646: LIST
84647: LIST
84648: PUSH
84649: LD_INT 0
84651: PUSH
84652: LD_INT 1
84654: PUSH
84655: EMPTY
84656: LIST
84657: LIST
84658: PUSH
84659: LD_INT 1
84661: NEG
84662: PUSH
84663: LD_INT 0
84665: PUSH
84666: EMPTY
84667: LIST
84668: LIST
84669: PUSH
84670: LD_INT 1
84672: NEG
84673: PUSH
84674: LD_INT 1
84676: NEG
84677: PUSH
84678: EMPTY
84679: LIST
84680: LIST
84681: PUSH
84682: LD_INT 2
84684: PUSH
84685: LD_INT 1
84687: PUSH
84688: EMPTY
84689: LIST
84690: LIST
84691: PUSH
84692: LD_INT 2
84694: NEG
84695: PUSH
84696: LD_INT 1
84698: NEG
84699: PUSH
84700: EMPTY
84701: LIST
84702: LIST
84703: PUSH
84704: EMPTY
84705: LIST
84706: LIST
84707: LIST
84708: LIST
84709: LIST
84710: LIST
84711: LIST
84712: LIST
84713: LIST
84714: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84715: LD_ADDR_VAR 0 36
84719: PUSH
84720: LD_INT 0
84722: PUSH
84723: LD_INT 0
84725: PUSH
84726: EMPTY
84727: LIST
84728: LIST
84729: PUSH
84730: LD_INT 0
84732: PUSH
84733: LD_INT 1
84735: NEG
84736: PUSH
84737: EMPTY
84738: LIST
84739: LIST
84740: PUSH
84741: LD_INT 1
84743: PUSH
84744: LD_INT 0
84746: PUSH
84747: EMPTY
84748: LIST
84749: LIST
84750: PUSH
84751: LD_INT 1
84753: PUSH
84754: LD_INT 1
84756: PUSH
84757: EMPTY
84758: LIST
84759: LIST
84760: PUSH
84761: LD_INT 0
84763: PUSH
84764: LD_INT 1
84766: PUSH
84767: EMPTY
84768: LIST
84769: LIST
84770: PUSH
84771: LD_INT 1
84773: NEG
84774: PUSH
84775: LD_INT 0
84777: PUSH
84778: EMPTY
84779: LIST
84780: LIST
84781: PUSH
84782: LD_INT 1
84784: NEG
84785: PUSH
84786: LD_INT 1
84788: NEG
84789: PUSH
84790: EMPTY
84791: LIST
84792: LIST
84793: PUSH
84794: LD_INT 1
84796: NEG
84797: PUSH
84798: LD_INT 2
84800: NEG
84801: PUSH
84802: EMPTY
84803: LIST
84804: LIST
84805: PUSH
84806: LD_INT 1
84808: PUSH
84809: LD_INT 2
84811: PUSH
84812: EMPTY
84813: LIST
84814: LIST
84815: PUSH
84816: EMPTY
84817: LIST
84818: LIST
84819: LIST
84820: LIST
84821: LIST
84822: LIST
84823: LIST
84824: LIST
84825: LIST
84826: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84827: LD_ADDR_VAR 0 37
84831: PUSH
84832: LD_INT 0
84834: PUSH
84835: LD_INT 0
84837: PUSH
84838: EMPTY
84839: LIST
84840: LIST
84841: PUSH
84842: LD_INT 0
84844: PUSH
84845: LD_INT 1
84847: NEG
84848: PUSH
84849: EMPTY
84850: LIST
84851: LIST
84852: PUSH
84853: LD_INT 1
84855: PUSH
84856: LD_INT 0
84858: PUSH
84859: EMPTY
84860: LIST
84861: LIST
84862: PUSH
84863: LD_INT 1
84865: PUSH
84866: LD_INT 1
84868: PUSH
84869: EMPTY
84870: LIST
84871: LIST
84872: PUSH
84873: LD_INT 0
84875: PUSH
84876: LD_INT 1
84878: PUSH
84879: EMPTY
84880: LIST
84881: LIST
84882: PUSH
84883: LD_INT 1
84885: NEG
84886: PUSH
84887: LD_INT 0
84889: PUSH
84890: EMPTY
84891: LIST
84892: LIST
84893: PUSH
84894: LD_INT 1
84896: NEG
84897: PUSH
84898: LD_INT 1
84900: NEG
84901: PUSH
84902: EMPTY
84903: LIST
84904: LIST
84905: PUSH
84906: LD_INT 1
84908: PUSH
84909: LD_INT 1
84911: NEG
84912: PUSH
84913: EMPTY
84914: LIST
84915: LIST
84916: PUSH
84917: LD_INT 1
84919: NEG
84920: PUSH
84921: LD_INT 1
84923: PUSH
84924: EMPTY
84925: LIST
84926: LIST
84927: PUSH
84928: EMPTY
84929: LIST
84930: LIST
84931: LIST
84932: LIST
84933: LIST
84934: LIST
84935: LIST
84936: LIST
84937: LIST
84938: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84939: LD_ADDR_VAR 0 38
84943: PUSH
84944: LD_INT 0
84946: PUSH
84947: LD_INT 0
84949: PUSH
84950: EMPTY
84951: LIST
84952: LIST
84953: PUSH
84954: LD_INT 0
84956: PUSH
84957: LD_INT 1
84959: NEG
84960: PUSH
84961: EMPTY
84962: LIST
84963: LIST
84964: PUSH
84965: LD_INT 1
84967: PUSH
84968: LD_INT 0
84970: PUSH
84971: EMPTY
84972: LIST
84973: LIST
84974: PUSH
84975: LD_INT 1
84977: PUSH
84978: LD_INT 1
84980: PUSH
84981: EMPTY
84982: LIST
84983: LIST
84984: PUSH
84985: LD_INT 0
84987: PUSH
84988: LD_INT 1
84990: PUSH
84991: EMPTY
84992: LIST
84993: LIST
84994: PUSH
84995: LD_INT 1
84997: NEG
84998: PUSH
84999: LD_INT 0
85001: PUSH
85002: EMPTY
85003: LIST
85004: LIST
85005: PUSH
85006: LD_INT 1
85008: NEG
85009: PUSH
85010: LD_INT 1
85012: NEG
85013: PUSH
85014: EMPTY
85015: LIST
85016: LIST
85017: PUSH
85018: LD_INT 2
85020: PUSH
85021: LD_INT 1
85023: PUSH
85024: EMPTY
85025: LIST
85026: LIST
85027: PUSH
85028: LD_INT 2
85030: NEG
85031: PUSH
85032: LD_INT 1
85034: NEG
85035: PUSH
85036: EMPTY
85037: LIST
85038: LIST
85039: PUSH
85040: EMPTY
85041: LIST
85042: LIST
85043: LIST
85044: LIST
85045: LIST
85046: LIST
85047: LIST
85048: LIST
85049: LIST
85050: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
85051: LD_ADDR_VAR 0 39
85055: PUSH
85056: LD_INT 0
85058: PUSH
85059: LD_INT 0
85061: PUSH
85062: EMPTY
85063: LIST
85064: LIST
85065: PUSH
85066: LD_INT 0
85068: PUSH
85069: LD_INT 1
85071: NEG
85072: PUSH
85073: EMPTY
85074: LIST
85075: LIST
85076: PUSH
85077: LD_INT 1
85079: PUSH
85080: LD_INT 0
85082: PUSH
85083: EMPTY
85084: LIST
85085: LIST
85086: PUSH
85087: LD_INT 1
85089: PUSH
85090: LD_INT 1
85092: PUSH
85093: EMPTY
85094: LIST
85095: LIST
85096: PUSH
85097: LD_INT 0
85099: PUSH
85100: LD_INT 1
85102: PUSH
85103: EMPTY
85104: LIST
85105: LIST
85106: PUSH
85107: LD_INT 1
85109: NEG
85110: PUSH
85111: LD_INT 0
85113: PUSH
85114: EMPTY
85115: LIST
85116: LIST
85117: PUSH
85118: LD_INT 1
85120: NEG
85121: PUSH
85122: LD_INT 1
85124: NEG
85125: PUSH
85126: EMPTY
85127: LIST
85128: LIST
85129: PUSH
85130: LD_INT 1
85132: NEG
85133: PUSH
85134: LD_INT 2
85136: NEG
85137: PUSH
85138: EMPTY
85139: LIST
85140: LIST
85141: PUSH
85142: LD_INT 1
85144: PUSH
85145: LD_INT 2
85147: PUSH
85148: EMPTY
85149: LIST
85150: LIST
85151: PUSH
85152: EMPTY
85153: LIST
85154: LIST
85155: LIST
85156: LIST
85157: LIST
85158: LIST
85159: LIST
85160: LIST
85161: LIST
85162: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
85163: LD_ADDR_VAR 0 40
85167: PUSH
85168: LD_INT 0
85170: PUSH
85171: LD_INT 0
85173: PUSH
85174: EMPTY
85175: LIST
85176: LIST
85177: PUSH
85178: LD_INT 0
85180: PUSH
85181: LD_INT 1
85183: NEG
85184: PUSH
85185: EMPTY
85186: LIST
85187: LIST
85188: PUSH
85189: LD_INT 1
85191: PUSH
85192: LD_INT 0
85194: PUSH
85195: EMPTY
85196: LIST
85197: LIST
85198: PUSH
85199: LD_INT 1
85201: PUSH
85202: LD_INT 1
85204: PUSH
85205: EMPTY
85206: LIST
85207: LIST
85208: PUSH
85209: LD_INT 0
85211: PUSH
85212: LD_INT 1
85214: PUSH
85215: EMPTY
85216: LIST
85217: LIST
85218: PUSH
85219: LD_INT 1
85221: NEG
85222: PUSH
85223: LD_INT 0
85225: PUSH
85226: EMPTY
85227: LIST
85228: LIST
85229: PUSH
85230: LD_INT 1
85232: NEG
85233: PUSH
85234: LD_INT 1
85236: NEG
85237: PUSH
85238: EMPTY
85239: LIST
85240: LIST
85241: PUSH
85242: LD_INT 1
85244: PUSH
85245: LD_INT 1
85247: NEG
85248: PUSH
85249: EMPTY
85250: LIST
85251: LIST
85252: PUSH
85253: LD_INT 1
85255: NEG
85256: PUSH
85257: LD_INT 1
85259: PUSH
85260: EMPTY
85261: LIST
85262: LIST
85263: PUSH
85264: EMPTY
85265: LIST
85266: LIST
85267: LIST
85268: LIST
85269: LIST
85270: LIST
85271: LIST
85272: LIST
85273: LIST
85274: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85275: LD_ADDR_VAR 0 41
85279: PUSH
85280: LD_INT 0
85282: PUSH
85283: LD_INT 0
85285: PUSH
85286: EMPTY
85287: LIST
85288: LIST
85289: PUSH
85290: LD_INT 0
85292: PUSH
85293: LD_INT 1
85295: NEG
85296: PUSH
85297: EMPTY
85298: LIST
85299: LIST
85300: PUSH
85301: LD_INT 1
85303: PUSH
85304: LD_INT 0
85306: PUSH
85307: EMPTY
85308: LIST
85309: LIST
85310: PUSH
85311: LD_INT 1
85313: PUSH
85314: LD_INT 1
85316: PUSH
85317: EMPTY
85318: LIST
85319: LIST
85320: PUSH
85321: LD_INT 0
85323: PUSH
85324: LD_INT 1
85326: PUSH
85327: EMPTY
85328: LIST
85329: LIST
85330: PUSH
85331: LD_INT 1
85333: NEG
85334: PUSH
85335: LD_INT 0
85337: PUSH
85338: EMPTY
85339: LIST
85340: LIST
85341: PUSH
85342: LD_INT 1
85344: NEG
85345: PUSH
85346: LD_INT 1
85348: NEG
85349: PUSH
85350: EMPTY
85351: LIST
85352: LIST
85353: PUSH
85354: LD_INT 1
85356: NEG
85357: PUSH
85358: LD_INT 2
85360: NEG
85361: PUSH
85362: EMPTY
85363: LIST
85364: LIST
85365: PUSH
85366: LD_INT 1
85368: PUSH
85369: LD_INT 1
85371: NEG
85372: PUSH
85373: EMPTY
85374: LIST
85375: LIST
85376: PUSH
85377: LD_INT 2
85379: PUSH
85380: LD_INT 0
85382: PUSH
85383: EMPTY
85384: LIST
85385: LIST
85386: PUSH
85387: LD_INT 2
85389: PUSH
85390: LD_INT 1
85392: PUSH
85393: EMPTY
85394: LIST
85395: LIST
85396: PUSH
85397: LD_INT 2
85399: PUSH
85400: LD_INT 2
85402: PUSH
85403: EMPTY
85404: LIST
85405: LIST
85406: PUSH
85407: LD_INT 1
85409: PUSH
85410: LD_INT 2
85412: PUSH
85413: EMPTY
85414: LIST
85415: LIST
85416: PUSH
85417: LD_INT 1
85419: NEG
85420: PUSH
85421: LD_INT 1
85423: PUSH
85424: EMPTY
85425: LIST
85426: LIST
85427: PUSH
85428: LD_INT 2
85430: NEG
85431: PUSH
85432: LD_INT 0
85434: PUSH
85435: EMPTY
85436: LIST
85437: LIST
85438: PUSH
85439: LD_INT 2
85441: NEG
85442: PUSH
85443: LD_INT 1
85445: NEG
85446: PUSH
85447: EMPTY
85448: LIST
85449: LIST
85450: PUSH
85451: LD_INT 2
85453: NEG
85454: PUSH
85455: LD_INT 2
85457: NEG
85458: PUSH
85459: EMPTY
85460: LIST
85461: LIST
85462: PUSH
85463: LD_INT 2
85465: NEG
85466: PUSH
85467: LD_INT 3
85469: NEG
85470: PUSH
85471: EMPTY
85472: LIST
85473: LIST
85474: PUSH
85475: LD_INT 2
85477: PUSH
85478: LD_INT 1
85480: NEG
85481: PUSH
85482: EMPTY
85483: LIST
85484: LIST
85485: PUSH
85486: LD_INT 3
85488: PUSH
85489: LD_INT 0
85491: PUSH
85492: EMPTY
85493: LIST
85494: LIST
85495: PUSH
85496: LD_INT 3
85498: PUSH
85499: LD_INT 1
85501: PUSH
85502: EMPTY
85503: LIST
85504: LIST
85505: PUSH
85506: LD_INT 3
85508: PUSH
85509: LD_INT 2
85511: PUSH
85512: EMPTY
85513: LIST
85514: LIST
85515: PUSH
85516: LD_INT 3
85518: PUSH
85519: LD_INT 3
85521: PUSH
85522: EMPTY
85523: LIST
85524: LIST
85525: PUSH
85526: LD_INT 2
85528: PUSH
85529: LD_INT 3
85531: PUSH
85532: EMPTY
85533: LIST
85534: LIST
85535: PUSH
85536: LD_INT 2
85538: NEG
85539: PUSH
85540: LD_INT 1
85542: PUSH
85543: EMPTY
85544: LIST
85545: LIST
85546: PUSH
85547: LD_INT 3
85549: NEG
85550: PUSH
85551: LD_INT 0
85553: PUSH
85554: EMPTY
85555: LIST
85556: LIST
85557: PUSH
85558: LD_INT 3
85560: NEG
85561: PUSH
85562: LD_INT 1
85564: NEG
85565: PUSH
85566: EMPTY
85567: LIST
85568: LIST
85569: PUSH
85570: LD_INT 3
85572: NEG
85573: PUSH
85574: LD_INT 2
85576: NEG
85577: PUSH
85578: EMPTY
85579: LIST
85580: LIST
85581: PUSH
85582: LD_INT 3
85584: NEG
85585: PUSH
85586: LD_INT 3
85588: NEG
85589: PUSH
85590: EMPTY
85591: LIST
85592: LIST
85593: PUSH
85594: EMPTY
85595: LIST
85596: LIST
85597: LIST
85598: LIST
85599: LIST
85600: LIST
85601: LIST
85602: LIST
85603: LIST
85604: LIST
85605: LIST
85606: LIST
85607: LIST
85608: LIST
85609: LIST
85610: LIST
85611: LIST
85612: LIST
85613: LIST
85614: LIST
85615: LIST
85616: LIST
85617: LIST
85618: LIST
85619: LIST
85620: LIST
85621: LIST
85622: LIST
85623: LIST
85624: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85625: LD_ADDR_VAR 0 42
85629: PUSH
85630: LD_INT 0
85632: PUSH
85633: LD_INT 0
85635: PUSH
85636: EMPTY
85637: LIST
85638: LIST
85639: PUSH
85640: LD_INT 0
85642: PUSH
85643: LD_INT 1
85645: NEG
85646: PUSH
85647: EMPTY
85648: LIST
85649: LIST
85650: PUSH
85651: LD_INT 1
85653: PUSH
85654: LD_INT 0
85656: PUSH
85657: EMPTY
85658: LIST
85659: LIST
85660: PUSH
85661: LD_INT 1
85663: PUSH
85664: LD_INT 1
85666: PUSH
85667: EMPTY
85668: LIST
85669: LIST
85670: PUSH
85671: LD_INT 0
85673: PUSH
85674: LD_INT 1
85676: PUSH
85677: EMPTY
85678: LIST
85679: LIST
85680: PUSH
85681: LD_INT 1
85683: NEG
85684: PUSH
85685: LD_INT 0
85687: PUSH
85688: EMPTY
85689: LIST
85690: LIST
85691: PUSH
85692: LD_INT 1
85694: NEG
85695: PUSH
85696: LD_INT 1
85698: NEG
85699: PUSH
85700: EMPTY
85701: LIST
85702: LIST
85703: PUSH
85704: LD_INT 1
85706: NEG
85707: PUSH
85708: LD_INT 2
85710: NEG
85711: PUSH
85712: EMPTY
85713: LIST
85714: LIST
85715: PUSH
85716: LD_INT 0
85718: PUSH
85719: LD_INT 2
85721: NEG
85722: PUSH
85723: EMPTY
85724: LIST
85725: LIST
85726: PUSH
85727: LD_INT 1
85729: PUSH
85730: LD_INT 1
85732: NEG
85733: PUSH
85734: EMPTY
85735: LIST
85736: LIST
85737: PUSH
85738: LD_INT 2
85740: PUSH
85741: LD_INT 1
85743: PUSH
85744: EMPTY
85745: LIST
85746: LIST
85747: PUSH
85748: LD_INT 2
85750: PUSH
85751: LD_INT 2
85753: PUSH
85754: EMPTY
85755: LIST
85756: LIST
85757: PUSH
85758: LD_INT 1
85760: PUSH
85761: LD_INT 2
85763: PUSH
85764: EMPTY
85765: LIST
85766: LIST
85767: PUSH
85768: LD_INT 0
85770: PUSH
85771: LD_INT 2
85773: PUSH
85774: EMPTY
85775: LIST
85776: LIST
85777: PUSH
85778: LD_INT 1
85780: NEG
85781: PUSH
85782: LD_INT 1
85784: PUSH
85785: EMPTY
85786: LIST
85787: LIST
85788: PUSH
85789: LD_INT 2
85791: NEG
85792: PUSH
85793: LD_INT 1
85795: NEG
85796: PUSH
85797: EMPTY
85798: LIST
85799: LIST
85800: PUSH
85801: LD_INT 2
85803: NEG
85804: PUSH
85805: LD_INT 2
85807: NEG
85808: PUSH
85809: EMPTY
85810: LIST
85811: LIST
85812: PUSH
85813: LD_INT 2
85815: NEG
85816: PUSH
85817: LD_INT 3
85819: NEG
85820: PUSH
85821: EMPTY
85822: LIST
85823: LIST
85824: PUSH
85825: LD_INT 1
85827: NEG
85828: PUSH
85829: LD_INT 3
85831: NEG
85832: PUSH
85833: EMPTY
85834: LIST
85835: LIST
85836: PUSH
85837: LD_INT 0
85839: PUSH
85840: LD_INT 3
85842: NEG
85843: PUSH
85844: EMPTY
85845: LIST
85846: LIST
85847: PUSH
85848: LD_INT 1
85850: PUSH
85851: LD_INT 2
85853: NEG
85854: PUSH
85855: EMPTY
85856: LIST
85857: LIST
85858: PUSH
85859: LD_INT 3
85861: PUSH
85862: LD_INT 2
85864: PUSH
85865: EMPTY
85866: LIST
85867: LIST
85868: PUSH
85869: LD_INT 3
85871: PUSH
85872: LD_INT 3
85874: PUSH
85875: EMPTY
85876: LIST
85877: LIST
85878: PUSH
85879: LD_INT 2
85881: PUSH
85882: LD_INT 3
85884: PUSH
85885: EMPTY
85886: LIST
85887: LIST
85888: PUSH
85889: LD_INT 1
85891: PUSH
85892: LD_INT 3
85894: PUSH
85895: EMPTY
85896: LIST
85897: LIST
85898: PUSH
85899: LD_INT 0
85901: PUSH
85902: LD_INT 3
85904: PUSH
85905: EMPTY
85906: LIST
85907: LIST
85908: PUSH
85909: LD_INT 1
85911: NEG
85912: PUSH
85913: LD_INT 2
85915: PUSH
85916: EMPTY
85917: LIST
85918: LIST
85919: PUSH
85920: LD_INT 3
85922: NEG
85923: PUSH
85924: LD_INT 2
85926: NEG
85927: PUSH
85928: EMPTY
85929: LIST
85930: LIST
85931: PUSH
85932: LD_INT 3
85934: NEG
85935: PUSH
85936: LD_INT 3
85938: NEG
85939: PUSH
85940: EMPTY
85941: LIST
85942: LIST
85943: PUSH
85944: EMPTY
85945: LIST
85946: LIST
85947: LIST
85948: LIST
85949: LIST
85950: LIST
85951: LIST
85952: LIST
85953: LIST
85954: LIST
85955: LIST
85956: LIST
85957: LIST
85958: LIST
85959: LIST
85960: LIST
85961: LIST
85962: LIST
85963: LIST
85964: LIST
85965: LIST
85966: LIST
85967: LIST
85968: LIST
85969: LIST
85970: LIST
85971: LIST
85972: LIST
85973: LIST
85974: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85975: LD_ADDR_VAR 0 43
85979: PUSH
85980: LD_INT 0
85982: PUSH
85983: LD_INT 0
85985: PUSH
85986: EMPTY
85987: LIST
85988: LIST
85989: PUSH
85990: LD_INT 0
85992: PUSH
85993: LD_INT 1
85995: NEG
85996: PUSH
85997: EMPTY
85998: LIST
85999: LIST
86000: PUSH
86001: LD_INT 1
86003: PUSH
86004: LD_INT 0
86006: PUSH
86007: EMPTY
86008: LIST
86009: LIST
86010: PUSH
86011: LD_INT 1
86013: PUSH
86014: LD_INT 1
86016: PUSH
86017: EMPTY
86018: LIST
86019: LIST
86020: PUSH
86021: LD_INT 0
86023: PUSH
86024: LD_INT 1
86026: PUSH
86027: EMPTY
86028: LIST
86029: LIST
86030: PUSH
86031: LD_INT 1
86033: NEG
86034: PUSH
86035: LD_INT 0
86037: PUSH
86038: EMPTY
86039: LIST
86040: LIST
86041: PUSH
86042: LD_INT 1
86044: NEG
86045: PUSH
86046: LD_INT 1
86048: NEG
86049: PUSH
86050: EMPTY
86051: LIST
86052: LIST
86053: PUSH
86054: LD_INT 1
86056: NEG
86057: PUSH
86058: LD_INT 2
86060: NEG
86061: PUSH
86062: EMPTY
86063: LIST
86064: LIST
86065: PUSH
86066: LD_INT 0
86068: PUSH
86069: LD_INT 2
86071: NEG
86072: PUSH
86073: EMPTY
86074: LIST
86075: LIST
86076: PUSH
86077: LD_INT 1
86079: PUSH
86080: LD_INT 1
86082: NEG
86083: PUSH
86084: EMPTY
86085: LIST
86086: LIST
86087: PUSH
86088: LD_INT 2
86090: PUSH
86091: LD_INT 0
86093: PUSH
86094: EMPTY
86095: LIST
86096: LIST
86097: PUSH
86098: LD_INT 2
86100: PUSH
86101: LD_INT 1
86103: PUSH
86104: EMPTY
86105: LIST
86106: LIST
86107: PUSH
86108: LD_INT 1
86110: PUSH
86111: LD_INT 2
86113: PUSH
86114: EMPTY
86115: LIST
86116: LIST
86117: PUSH
86118: LD_INT 0
86120: PUSH
86121: LD_INT 2
86123: PUSH
86124: EMPTY
86125: LIST
86126: LIST
86127: PUSH
86128: LD_INT 1
86130: NEG
86131: PUSH
86132: LD_INT 1
86134: PUSH
86135: EMPTY
86136: LIST
86137: LIST
86138: PUSH
86139: LD_INT 2
86141: NEG
86142: PUSH
86143: LD_INT 0
86145: PUSH
86146: EMPTY
86147: LIST
86148: LIST
86149: PUSH
86150: LD_INT 2
86152: NEG
86153: PUSH
86154: LD_INT 1
86156: NEG
86157: PUSH
86158: EMPTY
86159: LIST
86160: LIST
86161: PUSH
86162: LD_INT 1
86164: NEG
86165: PUSH
86166: LD_INT 3
86168: NEG
86169: PUSH
86170: EMPTY
86171: LIST
86172: LIST
86173: PUSH
86174: LD_INT 0
86176: PUSH
86177: LD_INT 3
86179: NEG
86180: PUSH
86181: EMPTY
86182: LIST
86183: LIST
86184: PUSH
86185: LD_INT 1
86187: PUSH
86188: LD_INT 2
86190: NEG
86191: PUSH
86192: EMPTY
86193: LIST
86194: LIST
86195: PUSH
86196: LD_INT 2
86198: PUSH
86199: LD_INT 1
86201: NEG
86202: PUSH
86203: EMPTY
86204: LIST
86205: LIST
86206: PUSH
86207: LD_INT 3
86209: PUSH
86210: LD_INT 0
86212: PUSH
86213: EMPTY
86214: LIST
86215: LIST
86216: PUSH
86217: LD_INT 3
86219: PUSH
86220: LD_INT 1
86222: PUSH
86223: EMPTY
86224: LIST
86225: LIST
86226: PUSH
86227: LD_INT 1
86229: PUSH
86230: LD_INT 3
86232: PUSH
86233: EMPTY
86234: LIST
86235: LIST
86236: PUSH
86237: LD_INT 0
86239: PUSH
86240: LD_INT 3
86242: PUSH
86243: EMPTY
86244: LIST
86245: LIST
86246: PUSH
86247: LD_INT 1
86249: NEG
86250: PUSH
86251: LD_INT 2
86253: PUSH
86254: EMPTY
86255: LIST
86256: LIST
86257: PUSH
86258: LD_INT 2
86260: NEG
86261: PUSH
86262: LD_INT 1
86264: PUSH
86265: EMPTY
86266: LIST
86267: LIST
86268: PUSH
86269: LD_INT 3
86271: NEG
86272: PUSH
86273: LD_INT 0
86275: PUSH
86276: EMPTY
86277: LIST
86278: LIST
86279: PUSH
86280: LD_INT 3
86282: NEG
86283: PUSH
86284: LD_INT 1
86286: NEG
86287: PUSH
86288: EMPTY
86289: LIST
86290: LIST
86291: PUSH
86292: EMPTY
86293: LIST
86294: LIST
86295: LIST
86296: LIST
86297: LIST
86298: LIST
86299: LIST
86300: LIST
86301: LIST
86302: LIST
86303: LIST
86304: LIST
86305: LIST
86306: LIST
86307: LIST
86308: LIST
86309: LIST
86310: LIST
86311: LIST
86312: LIST
86313: LIST
86314: LIST
86315: LIST
86316: LIST
86317: LIST
86318: LIST
86319: LIST
86320: LIST
86321: LIST
86322: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86323: LD_ADDR_VAR 0 44
86327: PUSH
86328: LD_INT 0
86330: PUSH
86331: LD_INT 0
86333: PUSH
86334: EMPTY
86335: LIST
86336: LIST
86337: PUSH
86338: LD_INT 0
86340: PUSH
86341: LD_INT 1
86343: NEG
86344: PUSH
86345: EMPTY
86346: LIST
86347: LIST
86348: PUSH
86349: LD_INT 1
86351: PUSH
86352: LD_INT 0
86354: PUSH
86355: EMPTY
86356: LIST
86357: LIST
86358: PUSH
86359: LD_INT 1
86361: PUSH
86362: LD_INT 1
86364: PUSH
86365: EMPTY
86366: LIST
86367: LIST
86368: PUSH
86369: LD_INT 0
86371: PUSH
86372: LD_INT 1
86374: PUSH
86375: EMPTY
86376: LIST
86377: LIST
86378: PUSH
86379: LD_INT 1
86381: NEG
86382: PUSH
86383: LD_INT 0
86385: PUSH
86386: EMPTY
86387: LIST
86388: LIST
86389: PUSH
86390: LD_INT 1
86392: NEG
86393: PUSH
86394: LD_INT 1
86396: NEG
86397: PUSH
86398: EMPTY
86399: LIST
86400: LIST
86401: PUSH
86402: LD_INT 1
86404: NEG
86405: PUSH
86406: LD_INT 2
86408: NEG
86409: PUSH
86410: EMPTY
86411: LIST
86412: LIST
86413: PUSH
86414: LD_INT 1
86416: PUSH
86417: LD_INT 1
86419: NEG
86420: PUSH
86421: EMPTY
86422: LIST
86423: LIST
86424: PUSH
86425: LD_INT 2
86427: PUSH
86428: LD_INT 0
86430: PUSH
86431: EMPTY
86432: LIST
86433: LIST
86434: PUSH
86435: LD_INT 2
86437: PUSH
86438: LD_INT 1
86440: PUSH
86441: EMPTY
86442: LIST
86443: LIST
86444: PUSH
86445: LD_INT 2
86447: PUSH
86448: LD_INT 2
86450: PUSH
86451: EMPTY
86452: LIST
86453: LIST
86454: PUSH
86455: LD_INT 1
86457: PUSH
86458: LD_INT 2
86460: PUSH
86461: EMPTY
86462: LIST
86463: LIST
86464: PUSH
86465: LD_INT 1
86467: NEG
86468: PUSH
86469: LD_INT 1
86471: PUSH
86472: EMPTY
86473: LIST
86474: LIST
86475: PUSH
86476: LD_INT 2
86478: NEG
86479: PUSH
86480: LD_INT 0
86482: PUSH
86483: EMPTY
86484: LIST
86485: LIST
86486: PUSH
86487: LD_INT 2
86489: NEG
86490: PUSH
86491: LD_INT 1
86493: NEG
86494: PUSH
86495: EMPTY
86496: LIST
86497: LIST
86498: PUSH
86499: LD_INT 2
86501: NEG
86502: PUSH
86503: LD_INT 2
86505: NEG
86506: PUSH
86507: EMPTY
86508: LIST
86509: LIST
86510: PUSH
86511: LD_INT 2
86513: NEG
86514: PUSH
86515: LD_INT 3
86517: NEG
86518: PUSH
86519: EMPTY
86520: LIST
86521: LIST
86522: PUSH
86523: LD_INT 2
86525: PUSH
86526: LD_INT 1
86528: NEG
86529: PUSH
86530: EMPTY
86531: LIST
86532: LIST
86533: PUSH
86534: LD_INT 3
86536: PUSH
86537: LD_INT 0
86539: PUSH
86540: EMPTY
86541: LIST
86542: LIST
86543: PUSH
86544: LD_INT 3
86546: PUSH
86547: LD_INT 1
86549: PUSH
86550: EMPTY
86551: LIST
86552: LIST
86553: PUSH
86554: LD_INT 3
86556: PUSH
86557: LD_INT 2
86559: PUSH
86560: EMPTY
86561: LIST
86562: LIST
86563: PUSH
86564: LD_INT 3
86566: PUSH
86567: LD_INT 3
86569: PUSH
86570: EMPTY
86571: LIST
86572: LIST
86573: PUSH
86574: LD_INT 2
86576: PUSH
86577: LD_INT 3
86579: PUSH
86580: EMPTY
86581: LIST
86582: LIST
86583: PUSH
86584: LD_INT 2
86586: NEG
86587: PUSH
86588: LD_INT 1
86590: PUSH
86591: EMPTY
86592: LIST
86593: LIST
86594: PUSH
86595: LD_INT 3
86597: NEG
86598: PUSH
86599: LD_INT 0
86601: PUSH
86602: EMPTY
86603: LIST
86604: LIST
86605: PUSH
86606: LD_INT 3
86608: NEG
86609: PUSH
86610: LD_INT 1
86612: NEG
86613: PUSH
86614: EMPTY
86615: LIST
86616: LIST
86617: PUSH
86618: LD_INT 3
86620: NEG
86621: PUSH
86622: LD_INT 2
86624: NEG
86625: PUSH
86626: EMPTY
86627: LIST
86628: LIST
86629: PUSH
86630: LD_INT 3
86632: NEG
86633: PUSH
86634: LD_INT 3
86636: NEG
86637: PUSH
86638: EMPTY
86639: LIST
86640: LIST
86641: PUSH
86642: EMPTY
86643: LIST
86644: LIST
86645: LIST
86646: LIST
86647: LIST
86648: LIST
86649: LIST
86650: LIST
86651: LIST
86652: LIST
86653: LIST
86654: LIST
86655: LIST
86656: LIST
86657: LIST
86658: LIST
86659: LIST
86660: LIST
86661: LIST
86662: LIST
86663: LIST
86664: LIST
86665: LIST
86666: LIST
86667: LIST
86668: LIST
86669: LIST
86670: LIST
86671: LIST
86672: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86673: LD_ADDR_VAR 0 45
86677: PUSH
86678: LD_INT 0
86680: PUSH
86681: LD_INT 0
86683: PUSH
86684: EMPTY
86685: LIST
86686: LIST
86687: PUSH
86688: LD_INT 0
86690: PUSH
86691: LD_INT 1
86693: NEG
86694: PUSH
86695: EMPTY
86696: LIST
86697: LIST
86698: PUSH
86699: LD_INT 1
86701: PUSH
86702: LD_INT 0
86704: PUSH
86705: EMPTY
86706: LIST
86707: LIST
86708: PUSH
86709: LD_INT 1
86711: PUSH
86712: LD_INT 1
86714: PUSH
86715: EMPTY
86716: LIST
86717: LIST
86718: PUSH
86719: LD_INT 0
86721: PUSH
86722: LD_INT 1
86724: PUSH
86725: EMPTY
86726: LIST
86727: LIST
86728: PUSH
86729: LD_INT 1
86731: NEG
86732: PUSH
86733: LD_INT 0
86735: PUSH
86736: EMPTY
86737: LIST
86738: LIST
86739: PUSH
86740: LD_INT 1
86742: NEG
86743: PUSH
86744: LD_INT 1
86746: NEG
86747: PUSH
86748: EMPTY
86749: LIST
86750: LIST
86751: PUSH
86752: LD_INT 1
86754: NEG
86755: PUSH
86756: LD_INT 2
86758: NEG
86759: PUSH
86760: EMPTY
86761: LIST
86762: LIST
86763: PUSH
86764: LD_INT 0
86766: PUSH
86767: LD_INT 2
86769: NEG
86770: PUSH
86771: EMPTY
86772: LIST
86773: LIST
86774: PUSH
86775: LD_INT 1
86777: PUSH
86778: LD_INT 1
86780: NEG
86781: PUSH
86782: EMPTY
86783: LIST
86784: LIST
86785: PUSH
86786: LD_INT 2
86788: PUSH
86789: LD_INT 1
86791: PUSH
86792: EMPTY
86793: LIST
86794: LIST
86795: PUSH
86796: LD_INT 2
86798: PUSH
86799: LD_INT 2
86801: PUSH
86802: EMPTY
86803: LIST
86804: LIST
86805: PUSH
86806: LD_INT 1
86808: PUSH
86809: LD_INT 2
86811: PUSH
86812: EMPTY
86813: LIST
86814: LIST
86815: PUSH
86816: LD_INT 0
86818: PUSH
86819: LD_INT 2
86821: PUSH
86822: EMPTY
86823: LIST
86824: LIST
86825: PUSH
86826: LD_INT 1
86828: NEG
86829: PUSH
86830: LD_INT 1
86832: PUSH
86833: EMPTY
86834: LIST
86835: LIST
86836: PUSH
86837: LD_INT 2
86839: NEG
86840: PUSH
86841: LD_INT 1
86843: NEG
86844: PUSH
86845: EMPTY
86846: LIST
86847: LIST
86848: PUSH
86849: LD_INT 2
86851: NEG
86852: PUSH
86853: LD_INT 2
86855: NEG
86856: PUSH
86857: EMPTY
86858: LIST
86859: LIST
86860: PUSH
86861: LD_INT 2
86863: NEG
86864: PUSH
86865: LD_INT 3
86867: NEG
86868: PUSH
86869: EMPTY
86870: LIST
86871: LIST
86872: PUSH
86873: LD_INT 1
86875: NEG
86876: PUSH
86877: LD_INT 3
86879: NEG
86880: PUSH
86881: EMPTY
86882: LIST
86883: LIST
86884: PUSH
86885: LD_INT 0
86887: PUSH
86888: LD_INT 3
86890: NEG
86891: PUSH
86892: EMPTY
86893: LIST
86894: LIST
86895: PUSH
86896: LD_INT 1
86898: PUSH
86899: LD_INT 2
86901: NEG
86902: PUSH
86903: EMPTY
86904: LIST
86905: LIST
86906: PUSH
86907: LD_INT 3
86909: PUSH
86910: LD_INT 2
86912: PUSH
86913: EMPTY
86914: LIST
86915: LIST
86916: PUSH
86917: LD_INT 3
86919: PUSH
86920: LD_INT 3
86922: PUSH
86923: EMPTY
86924: LIST
86925: LIST
86926: PUSH
86927: LD_INT 2
86929: PUSH
86930: LD_INT 3
86932: PUSH
86933: EMPTY
86934: LIST
86935: LIST
86936: PUSH
86937: LD_INT 1
86939: PUSH
86940: LD_INT 3
86942: PUSH
86943: EMPTY
86944: LIST
86945: LIST
86946: PUSH
86947: LD_INT 0
86949: PUSH
86950: LD_INT 3
86952: PUSH
86953: EMPTY
86954: LIST
86955: LIST
86956: PUSH
86957: LD_INT 1
86959: NEG
86960: PUSH
86961: LD_INT 2
86963: PUSH
86964: EMPTY
86965: LIST
86966: LIST
86967: PUSH
86968: LD_INT 3
86970: NEG
86971: PUSH
86972: LD_INT 2
86974: NEG
86975: PUSH
86976: EMPTY
86977: LIST
86978: LIST
86979: PUSH
86980: LD_INT 3
86982: NEG
86983: PUSH
86984: LD_INT 3
86986: NEG
86987: PUSH
86988: EMPTY
86989: LIST
86990: LIST
86991: PUSH
86992: EMPTY
86993: LIST
86994: LIST
86995: LIST
86996: LIST
86997: LIST
86998: LIST
86999: LIST
87000: LIST
87001: LIST
87002: LIST
87003: LIST
87004: LIST
87005: LIST
87006: LIST
87007: LIST
87008: LIST
87009: LIST
87010: LIST
87011: LIST
87012: LIST
87013: LIST
87014: LIST
87015: LIST
87016: LIST
87017: LIST
87018: LIST
87019: LIST
87020: LIST
87021: LIST
87022: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87023: LD_ADDR_VAR 0 46
87027: PUSH
87028: LD_INT 0
87030: PUSH
87031: LD_INT 0
87033: PUSH
87034: EMPTY
87035: LIST
87036: LIST
87037: PUSH
87038: LD_INT 0
87040: PUSH
87041: LD_INT 1
87043: NEG
87044: PUSH
87045: EMPTY
87046: LIST
87047: LIST
87048: PUSH
87049: LD_INT 1
87051: PUSH
87052: LD_INT 0
87054: PUSH
87055: EMPTY
87056: LIST
87057: LIST
87058: PUSH
87059: LD_INT 1
87061: PUSH
87062: LD_INT 1
87064: PUSH
87065: EMPTY
87066: LIST
87067: LIST
87068: PUSH
87069: LD_INT 0
87071: PUSH
87072: LD_INT 1
87074: PUSH
87075: EMPTY
87076: LIST
87077: LIST
87078: PUSH
87079: LD_INT 1
87081: NEG
87082: PUSH
87083: LD_INT 0
87085: PUSH
87086: EMPTY
87087: LIST
87088: LIST
87089: PUSH
87090: LD_INT 1
87092: NEG
87093: PUSH
87094: LD_INT 1
87096: NEG
87097: PUSH
87098: EMPTY
87099: LIST
87100: LIST
87101: PUSH
87102: LD_INT 1
87104: NEG
87105: PUSH
87106: LD_INT 2
87108: NEG
87109: PUSH
87110: EMPTY
87111: LIST
87112: LIST
87113: PUSH
87114: LD_INT 0
87116: PUSH
87117: LD_INT 2
87119: NEG
87120: PUSH
87121: EMPTY
87122: LIST
87123: LIST
87124: PUSH
87125: LD_INT 1
87127: PUSH
87128: LD_INT 1
87130: NEG
87131: PUSH
87132: EMPTY
87133: LIST
87134: LIST
87135: PUSH
87136: LD_INT 2
87138: PUSH
87139: LD_INT 0
87141: PUSH
87142: EMPTY
87143: LIST
87144: LIST
87145: PUSH
87146: LD_INT 2
87148: PUSH
87149: LD_INT 1
87151: PUSH
87152: EMPTY
87153: LIST
87154: LIST
87155: PUSH
87156: LD_INT 1
87158: PUSH
87159: LD_INT 2
87161: PUSH
87162: EMPTY
87163: LIST
87164: LIST
87165: PUSH
87166: LD_INT 0
87168: PUSH
87169: LD_INT 2
87171: PUSH
87172: EMPTY
87173: LIST
87174: LIST
87175: PUSH
87176: LD_INT 1
87178: NEG
87179: PUSH
87180: LD_INT 1
87182: PUSH
87183: EMPTY
87184: LIST
87185: LIST
87186: PUSH
87187: LD_INT 2
87189: NEG
87190: PUSH
87191: LD_INT 0
87193: PUSH
87194: EMPTY
87195: LIST
87196: LIST
87197: PUSH
87198: LD_INT 2
87200: NEG
87201: PUSH
87202: LD_INT 1
87204: NEG
87205: PUSH
87206: EMPTY
87207: LIST
87208: LIST
87209: PUSH
87210: LD_INT 1
87212: NEG
87213: PUSH
87214: LD_INT 3
87216: NEG
87217: PUSH
87218: EMPTY
87219: LIST
87220: LIST
87221: PUSH
87222: LD_INT 0
87224: PUSH
87225: LD_INT 3
87227: NEG
87228: PUSH
87229: EMPTY
87230: LIST
87231: LIST
87232: PUSH
87233: LD_INT 1
87235: PUSH
87236: LD_INT 2
87238: NEG
87239: PUSH
87240: EMPTY
87241: LIST
87242: LIST
87243: PUSH
87244: LD_INT 2
87246: PUSH
87247: LD_INT 1
87249: NEG
87250: PUSH
87251: EMPTY
87252: LIST
87253: LIST
87254: PUSH
87255: LD_INT 3
87257: PUSH
87258: LD_INT 0
87260: PUSH
87261: EMPTY
87262: LIST
87263: LIST
87264: PUSH
87265: LD_INT 3
87267: PUSH
87268: LD_INT 1
87270: PUSH
87271: EMPTY
87272: LIST
87273: LIST
87274: PUSH
87275: LD_INT 1
87277: PUSH
87278: LD_INT 3
87280: PUSH
87281: EMPTY
87282: LIST
87283: LIST
87284: PUSH
87285: LD_INT 0
87287: PUSH
87288: LD_INT 3
87290: PUSH
87291: EMPTY
87292: LIST
87293: LIST
87294: PUSH
87295: LD_INT 1
87297: NEG
87298: PUSH
87299: LD_INT 2
87301: PUSH
87302: EMPTY
87303: LIST
87304: LIST
87305: PUSH
87306: LD_INT 2
87308: NEG
87309: PUSH
87310: LD_INT 1
87312: PUSH
87313: EMPTY
87314: LIST
87315: LIST
87316: PUSH
87317: LD_INT 3
87319: NEG
87320: PUSH
87321: LD_INT 0
87323: PUSH
87324: EMPTY
87325: LIST
87326: LIST
87327: PUSH
87328: LD_INT 3
87330: NEG
87331: PUSH
87332: LD_INT 1
87334: NEG
87335: PUSH
87336: EMPTY
87337: LIST
87338: LIST
87339: PUSH
87340: EMPTY
87341: LIST
87342: LIST
87343: LIST
87344: LIST
87345: LIST
87346: LIST
87347: LIST
87348: LIST
87349: LIST
87350: LIST
87351: LIST
87352: LIST
87353: LIST
87354: LIST
87355: LIST
87356: LIST
87357: LIST
87358: LIST
87359: LIST
87360: LIST
87361: LIST
87362: LIST
87363: LIST
87364: LIST
87365: LIST
87366: LIST
87367: LIST
87368: LIST
87369: LIST
87370: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87371: LD_ADDR_VAR 0 47
87375: PUSH
87376: LD_INT 0
87378: PUSH
87379: LD_INT 0
87381: PUSH
87382: EMPTY
87383: LIST
87384: LIST
87385: PUSH
87386: LD_INT 0
87388: PUSH
87389: LD_INT 1
87391: NEG
87392: PUSH
87393: EMPTY
87394: LIST
87395: LIST
87396: PUSH
87397: LD_INT 1
87399: PUSH
87400: LD_INT 0
87402: PUSH
87403: EMPTY
87404: LIST
87405: LIST
87406: PUSH
87407: LD_INT 1
87409: PUSH
87410: LD_INT 1
87412: PUSH
87413: EMPTY
87414: LIST
87415: LIST
87416: PUSH
87417: LD_INT 0
87419: PUSH
87420: LD_INT 1
87422: PUSH
87423: EMPTY
87424: LIST
87425: LIST
87426: PUSH
87427: LD_INT 1
87429: NEG
87430: PUSH
87431: LD_INT 0
87433: PUSH
87434: EMPTY
87435: LIST
87436: LIST
87437: PUSH
87438: LD_INT 1
87440: NEG
87441: PUSH
87442: LD_INT 1
87444: NEG
87445: PUSH
87446: EMPTY
87447: LIST
87448: LIST
87449: PUSH
87450: LD_INT 1
87452: NEG
87453: PUSH
87454: LD_INT 2
87456: NEG
87457: PUSH
87458: EMPTY
87459: LIST
87460: LIST
87461: PUSH
87462: LD_INT 0
87464: PUSH
87465: LD_INT 2
87467: NEG
87468: PUSH
87469: EMPTY
87470: LIST
87471: LIST
87472: PUSH
87473: LD_INT 1
87475: PUSH
87476: LD_INT 1
87478: NEG
87479: PUSH
87480: EMPTY
87481: LIST
87482: LIST
87483: PUSH
87484: LD_INT 2
87486: NEG
87487: PUSH
87488: LD_INT 1
87490: NEG
87491: PUSH
87492: EMPTY
87493: LIST
87494: LIST
87495: PUSH
87496: LD_INT 2
87498: NEG
87499: PUSH
87500: LD_INT 2
87502: NEG
87503: PUSH
87504: EMPTY
87505: LIST
87506: LIST
87507: PUSH
87508: EMPTY
87509: LIST
87510: LIST
87511: LIST
87512: LIST
87513: LIST
87514: LIST
87515: LIST
87516: LIST
87517: LIST
87518: LIST
87519: LIST
87520: LIST
87521: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
87522: LD_ADDR_VAR 0 48
87526: PUSH
87527: LD_INT 0
87529: PUSH
87530: LD_INT 0
87532: PUSH
87533: EMPTY
87534: LIST
87535: LIST
87536: PUSH
87537: LD_INT 0
87539: PUSH
87540: LD_INT 1
87542: NEG
87543: PUSH
87544: EMPTY
87545: LIST
87546: LIST
87547: PUSH
87548: LD_INT 1
87550: PUSH
87551: LD_INT 0
87553: PUSH
87554: EMPTY
87555: LIST
87556: LIST
87557: PUSH
87558: LD_INT 1
87560: PUSH
87561: LD_INT 1
87563: PUSH
87564: EMPTY
87565: LIST
87566: LIST
87567: PUSH
87568: LD_INT 0
87570: PUSH
87571: LD_INT 1
87573: PUSH
87574: EMPTY
87575: LIST
87576: LIST
87577: PUSH
87578: LD_INT 1
87580: NEG
87581: PUSH
87582: LD_INT 0
87584: PUSH
87585: EMPTY
87586: LIST
87587: LIST
87588: PUSH
87589: LD_INT 1
87591: NEG
87592: PUSH
87593: LD_INT 1
87595: NEG
87596: PUSH
87597: EMPTY
87598: LIST
87599: LIST
87600: PUSH
87601: LD_INT 1
87603: NEG
87604: PUSH
87605: LD_INT 2
87607: NEG
87608: PUSH
87609: EMPTY
87610: LIST
87611: LIST
87612: PUSH
87613: LD_INT 0
87615: PUSH
87616: LD_INT 2
87618: NEG
87619: PUSH
87620: EMPTY
87621: LIST
87622: LIST
87623: PUSH
87624: LD_INT 1
87626: PUSH
87627: LD_INT 1
87629: NEG
87630: PUSH
87631: EMPTY
87632: LIST
87633: LIST
87634: PUSH
87635: LD_INT 2
87637: PUSH
87638: LD_INT 0
87640: PUSH
87641: EMPTY
87642: LIST
87643: LIST
87644: PUSH
87645: LD_INT 2
87647: PUSH
87648: LD_INT 1
87650: PUSH
87651: EMPTY
87652: LIST
87653: LIST
87654: PUSH
87655: EMPTY
87656: LIST
87657: LIST
87658: LIST
87659: LIST
87660: LIST
87661: LIST
87662: LIST
87663: LIST
87664: LIST
87665: LIST
87666: LIST
87667: LIST
87668: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
87669: LD_ADDR_VAR 0 49
87673: PUSH
87674: LD_INT 0
87676: PUSH
87677: LD_INT 0
87679: PUSH
87680: EMPTY
87681: LIST
87682: LIST
87683: PUSH
87684: LD_INT 0
87686: PUSH
87687: LD_INT 1
87689: NEG
87690: PUSH
87691: EMPTY
87692: LIST
87693: LIST
87694: PUSH
87695: LD_INT 1
87697: PUSH
87698: LD_INT 0
87700: PUSH
87701: EMPTY
87702: LIST
87703: LIST
87704: PUSH
87705: LD_INT 1
87707: PUSH
87708: LD_INT 1
87710: PUSH
87711: EMPTY
87712: LIST
87713: LIST
87714: PUSH
87715: LD_INT 0
87717: PUSH
87718: LD_INT 1
87720: PUSH
87721: EMPTY
87722: LIST
87723: LIST
87724: PUSH
87725: LD_INT 1
87727: NEG
87728: PUSH
87729: LD_INT 0
87731: PUSH
87732: EMPTY
87733: LIST
87734: LIST
87735: PUSH
87736: LD_INT 1
87738: NEG
87739: PUSH
87740: LD_INT 1
87742: NEG
87743: PUSH
87744: EMPTY
87745: LIST
87746: LIST
87747: PUSH
87748: LD_INT 1
87750: PUSH
87751: LD_INT 1
87753: NEG
87754: PUSH
87755: EMPTY
87756: LIST
87757: LIST
87758: PUSH
87759: LD_INT 2
87761: PUSH
87762: LD_INT 0
87764: PUSH
87765: EMPTY
87766: LIST
87767: LIST
87768: PUSH
87769: LD_INT 2
87771: PUSH
87772: LD_INT 1
87774: PUSH
87775: EMPTY
87776: LIST
87777: LIST
87778: PUSH
87779: LD_INT 2
87781: PUSH
87782: LD_INT 2
87784: PUSH
87785: EMPTY
87786: LIST
87787: LIST
87788: PUSH
87789: LD_INT 1
87791: PUSH
87792: LD_INT 2
87794: PUSH
87795: EMPTY
87796: LIST
87797: LIST
87798: PUSH
87799: EMPTY
87800: LIST
87801: LIST
87802: LIST
87803: LIST
87804: LIST
87805: LIST
87806: LIST
87807: LIST
87808: LIST
87809: LIST
87810: LIST
87811: LIST
87812: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
87813: LD_ADDR_VAR 0 50
87817: PUSH
87818: LD_INT 0
87820: PUSH
87821: LD_INT 0
87823: PUSH
87824: EMPTY
87825: LIST
87826: LIST
87827: PUSH
87828: LD_INT 0
87830: PUSH
87831: LD_INT 1
87833: NEG
87834: PUSH
87835: EMPTY
87836: LIST
87837: LIST
87838: PUSH
87839: LD_INT 1
87841: PUSH
87842: LD_INT 0
87844: PUSH
87845: EMPTY
87846: LIST
87847: LIST
87848: PUSH
87849: LD_INT 1
87851: PUSH
87852: LD_INT 1
87854: PUSH
87855: EMPTY
87856: LIST
87857: LIST
87858: PUSH
87859: LD_INT 0
87861: PUSH
87862: LD_INT 1
87864: PUSH
87865: EMPTY
87866: LIST
87867: LIST
87868: PUSH
87869: LD_INT 1
87871: NEG
87872: PUSH
87873: LD_INT 0
87875: PUSH
87876: EMPTY
87877: LIST
87878: LIST
87879: PUSH
87880: LD_INT 1
87882: NEG
87883: PUSH
87884: LD_INT 1
87886: NEG
87887: PUSH
87888: EMPTY
87889: LIST
87890: LIST
87891: PUSH
87892: LD_INT 2
87894: PUSH
87895: LD_INT 1
87897: PUSH
87898: EMPTY
87899: LIST
87900: LIST
87901: PUSH
87902: LD_INT 2
87904: PUSH
87905: LD_INT 2
87907: PUSH
87908: EMPTY
87909: LIST
87910: LIST
87911: PUSH
87912: LD_INT 1
87914: PUSH
87915: LD_INT 2
87917: PUSH
87918: EMPTY
87919: LIST
87920: LIST
87921: PUSH
87922: LD_INT 0
87924: PUSH
87925: LD_INT 2
87927: PUSH
87928: EMPTY
87929: LIST
87930: LIST
87931: PUSH
87932: LD_INT 1
87934: NEG
87935: PUSH
87936: LD_INT 1
87938: PUSH
87939: EMPTY
87940: LIST
87941: LIST
87942: PUSH
87943: EMPTY
87944: LIST
87945: LIST
87946: LIST
87947: LIST
87948: LIST
87949: LIST
87950: LIST
87951: LIST
87952: LIST
87953: LIST
87954: LIST
87955: LIST
87956: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
87957: LD_ADDR_VAR 0 51
87961: PUSH
87962: LD_INT 0
87964: PUSH
87965: LD_INT 0
87967: PUSH
87968: EMPTY
87969: LIST
87970: LIST
87971: PUSH
87972: LD_INT 0
87974: PUSH
87975: LD_INT 1
87977: NEG
87978: PUSH
87979: EMPTY
87980: LIST
87981: LIST
87982: PUSH
87983: LD_INT 1
87985: PUSH
87986: LD_INT 0
87988: PUSH
87989: EMPTY
87990: LIST
87991: LIST
87992: PUSH
87993: LD_INT 1
87995: PUSH
87996: LD_INT 1
87998: PUSH
87999: EMPTY
88000: LIST
88001: LIST
88002: PUSH
88003: LD_INT 0
88005: PUSH
88006: LD_INT 1
88008: PUSH
88009: EMPTY
88010: LIST
88011: LIST
88012: PUSH
88013: LD_INT 1
88015: NEG
88016: PUSH
88017: LD_INT 0
88019: PUSH
88020: EMPTY
88021: LIST
88022: LIST
88023: PUSH
88024: LD_INT 1
88026: NEG
88027: PUSH
88028: LD_INT 1
88030: NEG
88031: PUSH
88032: EMPTY
88033: LIST
88034: LIST
88035: PUSH
88036: LD_INT 1
88038: PUSH
88039: LD_INT 2
88041: PUSH
88042: EMPTY
88043: LIST
88044: LIST
88045: PUSH
88046: LD_INT 0
88048: PUSH
88049: LD_INT 2
88051: PUSH
88052: EMPTY
88053: LIST
88054: LIST
88055: PUSH
88056: LD_INT 1
88058: NEG
88059: PUSH
88060: LD_INT 1
88062: PUSH
88063: EMPTY
88064: LIST
88065: LIST
88066: PUSH
88067: LD_INT 2
88069: NEG
88070: PUSH
88071: LD_INT 0
88073: PUSH
88074: EMPTY
88075: LIST
88076: LIST
88077: PUSH
88078: LD_INT 2
88080: NEG
88081: PUSH
88082: LD_INT 1
88084: NEG
88085: PUSH
88086: EMPTY
88087: LIST
88088: LIST
88089: PUSH
88090: EMPTY
88091: LIST
88092: LIST
88093: LIST
88094: LIST
88095: LIST
88096: LIST
88097: LIST
88098: LIST
88099: LIST
88100: LIST
88101: LIST
88102: LIST
88103: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88104: LD_ADDR_VAR 0 52
88108: PUSH
88109: LD_INT 0
88111: PUSH
88112: LD_INT 0
88114: PUSH
88115: EMPTY
88116: LIST
88117: LIST
88118: PUSH
88119: LD_INT 0
88121: PUSH
88122: LD_INT 1
88124: NEG
88125: PUSH
88126: EMPTY
88127: LIST
88128: LIST
88129: PUSH
88130: LD_INT 1
88132: PUSH
88133: LD_INT 0
88135: PUSH
88136: EMPTY
88137: LIST
88138: LIST
88139: PUSH
88140: LD_INT 1
88142: PUSH
88143: LD_INT 1
88145: PUSH
88146: EMPTY
88147: LIST
88148: LIST
88149: PUSH
88150: LD_INT 0
88152: PUSH
88153: LD_INT 1
88155: PUSH
88156: EMPTY
88157: LIST
88158: LIST
88159: PUSH
88160: LD_INT 1
88162: NEG
88163: PUSH
88164: LD_INT 0
88166: PUSH
88167: EMPTY
88168: LIST
88169: LIST
88170: PUSH
88171: LD_INT 1
88173: NEG
88174: PUSH
88175: LD_INT 1
88177: NEG
88178: PUSH
88179: EMPTY
88180: LIST
88181: LIST
88182: PUSH
88183: LD_INT 1
88185: NEG
88186: PUSH
88187: LD_INT 2
88189: NEG
88190: PUSH
88191: EMPTY
88192: LIST
88193: LIST
88194: PUSH
88195: LD_INT 1
88197: NEG
88198: PUSH
88199: LD_INT 1
88201: PUSH
88202: EMPTY
88203: LIST
88204: LIST
88205: PUSH
88206: LD_INT 2
88208: NEG
88209: PUSH
88210: LD_INT 0
88212: PUSH
88213: EMPTY
88214: LIST
88215: LIST
88216: PUSH
88217: LD_INT 2
88219: NEG
88220: PUSH
88221: LD_INT 1
88223: NEG
88224: PUSH
88225: EMPTY
88226: LIST
88227: LIST
88228: PUSH
88229: LD_INT 2
88231: NEG
88232: PUSH
88233: LD_INT 2
88235: NEG
88236: PUSH
88237: EMPTY
88238: LIST
88239: LIST
88240: PUSH
88241: EMPTY
88242: LIST
88243: LIST
88244: LIST
88245: LIST
88246: LIST
88247: LIST
88248: LIST
88249: LIST
88250: LIST
88251: LIST
88252: LIST
88253: LIST
88254: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88255: LD_ADDR_VAR 0 53
88259: PUSH
88260: LD_INT 0
88262: PUSH
88263: LD_INT 0
88265: PUSH
88266: EMPTY
88267: LIST
88268: LIST
88269: PUSH
88270: LD_INT 0
88272: PUSH
88273: LD_INT 1
88275: NEG
88276: PUSH
88277: EMPTY
88278: LIST
88279: LIST
88280: PUSH
88281: LD_INT 1
88283: PUSH
88284: LD_INT 0
88286: PUSH
88287: EMPTY
88288: LIST
88289: LIST
88290: PUSH
88291: LD_INT 1
88293: PUSH
88294: LD_INT 1
88296: PUSH
88297: EMPTY
88298: LIST
88299: LIST
88300: PUSH
88301: LD_INT 0
88303: PUSH
88304: LD_INT 1
88306: PUSH
88307: EMPTY
88308: LIST
88309: LIST
88310: PUSH
88311: LD_INT 1
88313: NEG
88314: PUSH
88315: LD_INT 0
88317: PUSH
88318: EMPTY
88319: LIST
88320: LIST
88321: PUSH
88322: LD_INT 1
88324: NEG
88325: PUSH
88326: LD_INT 1
88328: NEG
88329: PUSH
88330: EMPTY
88331: LIST
88332: LIST
88333: PUSH
88334: LD_INT 1
88336: NEG
88337: PUSH
88338: LD_INT 2
88340: NEG
88341: PUSH
88342: EMPTY
88343: LIST
88344: LIST
88345: PUSH
88346: LD_INT 0
88348: PUSH
88349: LD_INT 2
88351: NEG
88352: PUSH
88353: EMPTY
88354: LIST
88355: LIST
88356: PUSH
88357: LD_INT 1
88359: PUSH
88360: LD_INT 1
88362: NEG
88363: PUSH
88364: EMPTY
88365: LIST
88366: LIST
88367: PUSH
88368: LD_INT 2
88370: PUSH
88371: LD_INT 0
88373: PUSH
88374: EMPTY
88375: LIST
88376: LIST
88377: PUSH
88378: LD_INT 2
88380: PUSH
88381: LD_INT 1
88383: PUSH
88384: EMPTY
88385: LIST
88386: LIST
88387: PUSH
88388: LD_INT 2
88390: PUSH
88391: LD_INT 2
88393: PUSH
88394: EMPTY
88395: LIST
88396: LIST
88397: PUSH
88398: LD_INT 1
88400: PUSH
88401: LD_INT 2
88403: PUSH
88404: EMPTY
88405: LIST
88406: LIST
88407: PUSH
88408: LD_INT 0
88410: PUSH
88411: LD_INT 2
88413: PUSH
88414: EMPTY
88415: LIST
88416: LIST
88417: PUSH
88418: LD_INT 1
88420: NEG
88421: PUSH
88422: LD_INT 1
88424: PUSH
88425: EMPTY
88426: LIST
88427: LIST
88428: PUSH
88429: LD_INT 2
88431: NEG
88432: PUSH
88433: LD_INT 0
88435: PUSH
88436: EMPTY
88437: LIST
88438: LIST
88439: PUSH
88440: LD_INT 2
88442: NEG
88443: PUSH
88444: LD_INT 1
88446: NEG
88447: PUSH
88448: EMPTY
88449: LIST
88450: LIST
88451: PUSH
88452: LD_INT 2
88454: NEG
88455: PUSH
88456: LD_INT 2
88458: NEG
88459: PUSH
88460: EMPTY
88461: LIST
88462: LIST
88463: PUSH
88464: EMPTY
88465: LIST
88466: LIST
88467: LIST
88468: LIST
88469: LIST
88470: LIST
88471: LIST
88472: LIST
88473: LIST
88474: LIST
88475: LIST
88476: LIST
88477: LIST
88478: LIST
88479: LIST
88480: LIST
88481: LIST
88482: LIST
88483: LIST
88484: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88485: LD_ADDR_VAR 0 54
88489: PUSH
88490: LD_INT 0
88492: PUSH
88493: LD_INT 0
88495: PUSH
88496: EMPTY
88497: LIST
88498: LIST
88499: PUSH
88500: LD_INT 0
88502: PUSH
88503: LD_INT 1
88505: NEG
88506: PUSH
88507: EMPTY
88508: LIST
88509: LIST
88510: PUSH
88511: LD_INT 1
88513: PUSH
88514: LD_INT 0
88516: PUSH
88517: EMPTY
88518: LIST
88519: LIST
88520: PUSH
88521: LD_INT 1
88523: PUSH
88524: LD_INT 1
88526: PUSH
88527: EMPTY
88528: LIST
88529: LIST
88530: PUSH
88531: LD_INT 0
88533: PUSH
88534: LD_INT 1
88536: PUSH
88537: EMPTY
88538: LIST
88539: LIST
88540: PUSH
88541: LD_INT 1
88543: NEG
88544: PUSH
88545: LD_INT 0
88547: PUSH
88548: EMPTY
88549: LIST
88550: LIST
88551: PUSH
88552: LD_INT 1
88554: NEG
88555: PUSH
88556: LD_INT 1
88558: NEG
88559: PUSH
88560: EMPTY
88561: LIST
88562: LIST
88563: PUSH
88564: LD_INT 1
88566: NEG
88567: PUSH
88568: LD_INT 2
88570: NEG
88571: PUSH
88572: EMPTY
88573: LIST
88574: LIST
88575: PUSH
88576: LD_INT 0
88578: PUSH
88579: LD_INT 2
88581: NEG
88582: PUSH
88583: EMPTY
88584: LIST
88585: LIST
88586: PUSH
88587: LD_INT 1
88589: PUSH
88590: LD_INT 1
88592: NEG
88593: PUSH
88594: EMPTY
88595: LIST
88596: LIST
88597: PUSH
88598: LD_INT 2
88600: PUSH
88601: LD_INT 0
88603: PUSH
88604: EMPTY
88605: LIST
88606: LIST
88607: PUSH
88608: LD_INT 2
88610: PUSH
88611: LD_INT 1
88613: PUSH
88614: EMPTY
88615: LIST
88616: LIST
88617: PUSH
88618: LD_INT 2
88620: PUSH
88621: LD_INT 2
88623: PUSH
88624: EMPTY
88625: LIST
88626: LIST
88627: PUSH
88628: LD_INT 1
88630: PUSH
88631: LD_INT 2
88633: PUSH
88634: EMPTY
88635: LIST
88636: LIST
88637: PUSH
88638: LD_INT 0
88640: PUSH
88641: LD_INT 2
88643: PUSH
88644: EMPTY
88645: LIST
88646: LIST
88647: PUSH
88648: LD_INT 1
88650: NEG
88651: PUSH
88652: LD_INT 1
88654: PUSH
88655: EMPTY
88656: LIST
88657: LIST
88658: PUSH
88659: LD_INT 2
88661: NEG
88662: PUSH
88663: LD_INT 0
88665: PUSH
88666: EMPTY
88667: LIST
88668: LIST
88669: PUSH
88670: LD_INT 2
88672: NEG
88673: PUSH
88674: LD_INT 1
88676: NEG
88677: PUSH
88678: EMPTY
88679: LIST
88680: LIST
88681: PUSH
88682: LD_INT 2
88684: NEG
88685: PUSH
88686: LD_INT 2
88688: NEG
88689: PUSH
88690: EMPTY
88691: LIST
88692: LIST
88693: PUSH
88694: EMPTY
88695: LIST
88696: LIST
88697: LIST
88698: LIST
88699: LIST
88700: LIST
88701: LIST
88702: LIST
88703: LIST
88704: LIST
88705: LIST
88706: LIST
88707: LIST
88708: LIST
88709: LIST
88710: LIST
88711: LIST
88712: LIST
88713: LIST
88714: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88715: LD_ADDR_VAR 0 55
88719: PUSH
88720: LD_INT 0
88722: PUSH
88723: LD_INT 0
88725: PUSH
88726: EMPTY
88727: LIST
88728: LIST
88729: PUSH
88730: LD_INT 0
88732: PUSH
88733: LD_INT 1
88735: NEG
88736: PUSH
88737: EMPTY
88738: LIST
88739: LIST
88740: PUSH
88741: LD_INT 1
88743: PUSH
88744: LD_INT 0
88746: PUSH
88747: EMPTY
88748: LIST
88749: LIST
88750: PUSH
88751: LD_INT 1
88753: PUSH
88754: LD_INT 1
88756: PUSH
88757: EMPTY
88758: LIST
88759: LIST
88760: PUSH
88761: LD_INT 0
88763: PUSH
88764: LD_INT 1
88766: PUSH
88767: EMPTY
88768: LIST
88769: LIST
88770: PUSH
88771: LD_INT 1
88773: NEG
88774: PUSH
88775: LD_INT 0
88777: PUSH
88778: EMPTY
88779: LIST
88780: LIST
88781: PUSH
88782: LD_INT 1
88784: NEG
88785: PUSH
88786: LD_INT 1
88788: NEG
88789: PUSH
88790: EMPTY
88791: LIST
88792: LIST
88793: PUSH
88794: LD_INT 1
88796: NEG
88797: PUSH
88798: LD_INT 2
88800: NEG
88801: PUSH
88802: EMPTY
88803: LIST
88804: LIST
88805: PUSH
88806: LD_INT 0
88808: PUSH
88809: LD_INT 2
88811: NEG
88812: PUSH
88813: EMPTY
88814: LIST
88815: LIST
88816: PUSH
88817: LD_INT 1
88819: PUSH
88820: LD_INT 1
88822: NEG
88823: PUSH
88824: EMPTY
88825: LIST
88826: LIST
88827: PUSH
88828: LD_INT 2
88830: PUSH
88831: LD_INT 0
88833: PUSH
88834: EMPTY
88835: LIST
88836: LIST
88837: PUSH
88838: LD_INT 2
88840: PUSH
88841: LD_INT 1
88843: PUSH
88844: EMPTY
88845: LIST
88846: LIST
88847: PUSH
88848: LD_INT 2
88850: PUSH
88851: LD_INT 2
88853: PUSH
88854: EMPTY
88855: LIST
88856: LIST
88857: PUSH
88858: LD_INT 1
88860: PUSH
88861: LD_INT 2
88863: PUSH
88864: EMPTY
88865: LIST
88866: LIST
88867: PUSH
88868: LD_INT 0
88870: PUSH
88871: LD_INT 2
88873: PUSH
88874: EMPTY
88875: LIST
88876: LIST
88877: PUSH
88878: LD_INT 1
88880: NEG
88881: PUSH
88882: LD_INT 1
88884: PUSH
88885: EMPTY
88886: LIST
88887: LIST
88888: PUSH
88889: LD_INT 2
88891: NEG
88892: PUSH
88893: LD_INT 0
88895: PUSH
88896: EMPTY
88897: LIST
88898: LIST
88899: PUSH
88900: LD_INT 2
88902: NEG
88903: PUSH
88904: LD_INT 1
88906: NEG
88907: PUSH
88908: EMPTY
88909: LIST
88910: LIST
88911: PUSH
88912: LD_INT 2
88914: NEG
88915: PUSH
88916: LD_INT 2
88918: NEG
88919: PUSH
88920: EMPTY
88921: LIST
88922: LIST
88923: PUSH
88924: EMPTY
88925: LIST
88926: LIST
88927: LIST
88928: LIST
88929: LIST
88930: LIST
88931: LIST
88932: LIST
88933: LIST
88934: LIST
88935: LIST
88936: LIST
88937: LIST
88938: LIST
88939: LIST
88940: LIST
88941: LIST
88942: LIST
88943: LIST
88944: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88945: LD_ADDR_VAR 0 56
88949: PUSH
88950: LD_INT 0
88952: PUSH
88953: LD_INT 0
88955: PUSH
88956: EMPTY
88957: LIST
88958: LIST
88959: PUSH
88960: LD_INT 0
88962: PUSH
88963: LD_INT 1
88965: NEG
88966: PUSH
88967: EMPTY
88968: LIST
88969: LIST
88970: PUSH
88971: LD_INT 1
88973: PUSH
88974: LD_INT 0
88976: PUSH
88977: EMPTY
88978: LIST
88979: LIST
88980: PUSH
88981: LD_INT 1
88983: PUSH
88984: LD_INT 1
88986: PUSH
88987: EMPTY
88988: LIST
88989: LIST
88990: PUSH
88991: LD_INT 0
88993: PUSH
88994: LD_INT 1
88996: PUSH
88997: EMPTY
88998: LIST
88999: LIST
89000: PUSH
89001: LD_INT 1
89003: NEG
89004: PUSH
89005: LD_INT 0
89007: PUSH
89008: EMPTY
89009: LIST
89010: LIST
89011: PUSH
89012: LD_INT 1
89014: NEG
89015: PUSH
89016: LD_INT 1
89018: NEG
89019: PUSH
89020: EMPTY
89021: LIST
89022: LIST
89023: PUSH
89024: LD_INT 1
89026: NEG
89027: PUSH
89028: LD_INT 2
89030: NEG
89031: PUSH
89032: EMPTY
89033: LIST
89034: LIST
89035: PUSH
89036: LD_INT 0
89038: PUSH
89039: LD_INT 2
89041: NEG
89042: PUSH
89043: EMPTY
89044: LIST
89045: LIST
89046: PUSH
89047: LD_INT 1
89049: PUSH
89050: LD_INT 1
89052: NEG
89053: PUSH
89054: EMPTY
89055: LIST
89056: LIST
89057: PUSH
89058: LD_INT 2
89060: PUSH
89061: LD_INT 0
89063: PUSH
89064: EMPTY
89065: LIST
89066: LIST
89067: PUSH
89068: LD_INT 2
89070: PUSH
89071: LD_INT 1
89073: PUSH
89074: EMPTY
89075: LIST
89076: LIST
89077: PUSH
89078: LD_INT 2
89080: PUSH
89081: LD_INT 2
89083: PUSH
89084: EMPTY
89085: LIST
89086: LIST
89087: PUSH
89088: LD_INT 1
89090: PUSH
89091: LD_INT 2
89093: PUSH
89094: EMPTY
89095: LIST
89096: LIST
89097: PUSH
89098: LD_INT 0
89100: PUSH
89101: LD_INT 2
89103: PUSH
89104: EMPTY
89105: LIST
89106: LIST
89107: PUSH
89108: LD_INT 1
89110: NEG
89111: PUSH
89112: LD_INT 1
89114: PUSH
89115: EMPTY
89116: LIST
89117: LIST
89118: PUSH
89119: LD_INT 2
89121: NEG
89122: PUSH
89123: LD_INT 0
89125: PUSH
89126: EMPTY
89127: LIST
89128: LIST
89129: PUSH
89130: LD_INT 2
89132: NEG
89133: PUSH
89134: LD_INT 1
89136: NEG
89137: PUSH
89138: EMPTY
89139: LIST
89140: LIST
89141: PUSH
89142: LD_INT 2
89144: NEG
89145: PUSH
89146: LD_INT 2
89148: NEG
89149: PUSH
89150: EMPTY
89151: LIST
89152: LIST
89153: PUSH
89154: EMPTY
89155: LIST
89156: LIST
89157: LIST
89158: LIST
89159: LIST
89160: LIST
89161: LIST
89162: LIST
89163: LIST
89164: LIST
89165: LIST
89166: LIST
89167: LIST
89168: LIST
89169: LIST
89170: LIST
89171: LIST
89172: LIST
89173: LIST
89174: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89175: LD_ADDR_VAR 0 57
89179: PUSH
89180: LD_INT 0
89182: PUSH
89183: LD_INT 0
89185: PUSH
89186: EMPTY
89187: LIST
89188: LIST
89189: PUSH
89190: LD_INT 0
89192: PUSH
89193: LD_INT 1
89195: NEG
89196: PUSH
89197: EMPTY
89198: LIST
89199: LIST
89200: PUSH
89201: LD_INT 1
89203: PUSH
89204: LD_INT 0
89206: PUSH
89207: EMPTY
89208: LIST
89209: LIST
89210: PUSH
89211: LD_INT 1
89213: PUSH
89214: LD_INT 1
89216: PUSH
89217: EMPTY
89218: LIST
89219: LIST
89220: PUSH
89221: LD_INT 0
89223: PUSH
89224: LD_INT 1
89226: PUSH
89227: EMPTY
89228: LIST
89229: LIST
89230: PUSH
89231: LD_INT 1
89233: NEG
89234: PUSH
89235: LD_INT 0
89237: PUSH
89238: EMPTY
89239: LIST
89240: LIST
89241: PUSH
89242: LD_INT 1
89244: NEG
89245: PUSH
89246: LD_INT 1
89248: NEG
89249: PUSH
89250: EMPTY
89251: LIST
89252: LIST
89253: PUSH
89254: LD_INT 1
89256: NEG
89257: PUSH
89258: LD_INT 2
89260: NEG
89261: PUSH
89262: EMPTY
89263: LIST
89264: LIST
89265: PUSH
89266: LD_INT 0
89268: PUSH
89269: LD_INT 2
89271: NEG
89272: PUSH
89273: EMPTY
89274: LIST
89275: LIST
89276: PUSH
89277: LD_INT 1
89279: PUSH
89280: LD_INT 1
89282: NEG
89283: PUSH
89284: EMPTY
89285: LIST
89286: LIST
89287: PUSH
89288: LD_INT 2
89290: PUSH
89291: LD_INT 0
89293: PUSH
89294: EMPTY
89295: LIST
89296: LIST
89297: PUSH
89298: LD_INT 2
89300: PUSH
89301: LD_INT 1
89303: PUSH
89304: EMPTY
89305: LIST
89306: LIST
89307: PUSH
89308: LD_INT 2
89310: PUSH
89311: LD_INT 2
89313: PUSH
89314: EMPTY
89315: LIST
89316: LIST
89317: PUSH
89318: LD_INT 1
89320: PUSH
89321: LD_INT 2
89323: PUSH
89324: EMPTY
89325: LIST
89326: LIST
89327: PUSH
89328: LD_INT 0
89330: PUSH
89331: LD_INT 2
89333: PUSH
89334: EMPTY
89335: LIST
89336: LIST
89337: PUSH
89338: LD_INT 1
89340: NEG
89341: PUSH
89342: LD_INT 1
89344: PUSH
89345: EMPTY
89346: LIST
89347: LIST
89348: PUSH
89349: LD_INT 2
89351: NEG
89352: PUSH
89353: LD_INT 0
89355: PUSH
89356: EMPTY
89357: LIST
89358: LIST
89359: PUSH
89360: LD_INT 2
89362: NEG
89363: PUSH
89364: LD_INT 1
89366: NEG
89367: PUSH
89368: EMPTY
89369: LIST
89370: LIST
89371: PUSH
89372: LD_INT 2
89374: NEG
89375: PUSH
89376: LD_INT 2
89378: NEG
89379: PUSH
89380: EMPTY
89381: LIST
89382: LIST
89383: PUSH
89384: EMPTY
89385: LIST
89386: LIST
89387: LIST
89388: LIST
89389: LIST
89390: LIST
89391: LIST
89392: LIST
89393: LIST
89394: LIST
89395: LIST
89396: LIST
89397: LIST
89398: LIST
89399: LIST
89400: LIST
89401: LIST
89402: LIST
89403: LIST
89404: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89405: LD_ADDR_VAR 0 58
89409: PUSH
89410: LD_INT 0
89412: PUSH
89413: LD_INT 0
89415: PUSH
89416: EMPTY
89417: LIST
89418: LIST
89419: PUSH
89420: LD_INT 0
89422: PUSH
89423: LD_INT 1
89425: NEG
89426: PUSH
89427: EMPTY
89428: LIST
89429: LIST
89430: PUSH
89431: LD_INT 1
89433: PUSH
89434: LD_INT 0
89436: PUSH
89437: EMPTY
89438: LIST
89439: LIST
89440: PUSH
89441: LD_INT 1
89443: PUSH
89444: LD_INT 1
89446: PUSH
89447: EMPTY
89448: LIST
89449: LIST
89450: PUSH
89451: LD_INT 0
89453: PUSH
89454: LD_INT 1
89456: PUSH
89457: EMPTY
89458: LIST
89459: LIST
89460: PUSH
89461: LD_INT 1
89463: NEG
89464: PUSH
89465: LD_INT 0
89467: PUSH
89468: EMPTY
89469: LIST
89470: LIST
89471: PUSH
89472: LD_INT 1
89474: NEG
89475: PUSH
89476: LD_INT 1
89478: NEG
89479: PUSH
89480: EMPTY
89481: LIST
89482: LIST
89483: PUSH
89484: LD_INT 1
89486: NEG
89487: PUSH
89488: LD_INT 2
89490: NEG
89491: PUSH
89492: EMPTY
89493: LIST
89494: LIST
89495: PUSH
89496: LD_INT 0
89498: PUSH
89499: LD_INT 2
89501: NEG
89502: PUSH
89503: EMPTY
89504: LIST
89505: LIST
89506: PUSH
89507: LD_INT 1
89509: PUSH
89510: LD_INT 1
89512: NEG
89513: PUSH
89514: EMPTY
89515: LIST
89516: LIST
89517: PUSH
89518: LD_INT 2
89520: PUSH
89521: LD_INT 0
89523: PUSH
89524: EMPTY
89525: LIST
89526: LIST
89527: PUSH
89528: LD_INT 2
89530: PUSH
89531: LD_INT 1
89533: PUSH
89534: EMPTY
89535: LIST
89536: LIST
89537: PUSH
89538: LD_INT 2
89540: PUSH
89541: LD_INT 2
89543: PUSH
89544: EMPTY
89545: LIST
89546: LIST
89547: PUSH
89548: LD_INT 1
89550: PUSH
89551: LD_INT 2
89553: PUSH
89554: EMPTY
89555: LIST
89556: LIST
89557: PUSH
89558: LD_INT 0
89560: PUSH
89561: LD_INT 2
89563: PUSH
89564: EMPTY
89565: LIST
89566: LIST
89567: PUSH
89568: LD_INT 1
89570: NEG
89571: PUSH
89572: LD_INT 1
89574: PUSH
89575: EMPTY
89576: LIST
89577: LIST
89578: PUSH
89579: LD_INT 2
89581: NEG
89582: PUSH
89583: LD_INT 0
89585: PUSH
89586: EMPTY
89587: LIST
89588: LIST
89589: PUSH
89590: LD_INT 2
89592: NEG
89593: PUSH
89594: LD_INT 1
89596: NEG
89597: PUSH
89598: EMPTY
89599: LIST
89600: LIST
89601: PUSH
89602: LD_INT 2
89604: NEG
89605: PUSH
89606: LD_INT 2
89608: NEG
89609: PUSH
89610: EMPTY
89611: LIST
89612: LIST
89613: PUSH
89614: EMPTY
89615: LIST
89616: LIST
89617: LIST
89618: LIST
89619: LIST
89620: LIST
89621: LIST
89622: LIST
89623: LIST
89624: LIST
89625: LIST
89626: LIST
89627: LIST
89628: LIST
89629: LIST
89630: LIST
89631: LIST
89632: LIST
89633: LIST
89634: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89635: LD_ADDR_VAR 0 59
89639: PUSH
89640: LD_INT 0
89642: PUSH
89643: LD_INT 0
89645: PUSH
89646: EMPTY
89647: LIST
89648: LIST
89649: PUSH
89650: LD_INT 0
89652: PUSH
89653: LD_INT 1
89655: NEG
89656: PUSH
89657: EMPTY
89658: LIST
89659: LIST
89660: PUSH
89661: LD_INT 1
89663: PUSH
89664: LD_INT 0
89666: PUSH
89667: EMPTY
89668: LIST
89669: LIST
89670: PUSH
89671: LD_INT 1
89673: PUSH
89674: LD_INT 1
89676: PUSH
89677: EMPTY
89678: LIST
89679: LIST
89680: PUSH
89681: LD_INT 0
89683: PUSH
89684: LD_INT 1
89686: PUSH
89687: EMPTY
89688: LIST
89689: LIST
89690: PUSH
89691: LD_INT 1
89693: NEG
89694: PUSH
89695: LD_INT 0
89697: PUSH
89698: EMPTY
89699: LIST
89700: LIST
89701: PUSH
89702: LD_INT 1
89704: NEG
89705: PUSH
89706: LD_INT 1
89708: NEG
89709: PUSH
89710: EMPTY
89711: LIST
89712: LIST
89713: PUSH
89714: EMPTY
89715: LIST
89716: LIST
89717: LIST
89718: LIST
89719: LIST
89720: LIST
89721: LIST
89722: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89723: LD_ADDR_VAR 0 60
89727: PUSH
89728: LD_INT 0
89730: PUSH
89731: LD_INT 0
89733: PUSH
89734: EMPTY
89735: LIST
89736: LIST
89737: PUSH
89738: LD_INT 0
89740: PUSH
89741: LD_INT 1
89743: NEG
89744: PUSH
89745: EMPTY
89746: LIST
89747: LIST
89748: PUSH
89749: LD_INT 1
89751: PUSH
89752: LD_INT 0
89754: PUSH
89755: EMPTY
89756: LIST
89757: LIST
89758: PUSH
89759: LD_INT 1
89761: PUSH
89762: LD_INT 1
89764: PUSH
89765: EMPTY
89766: LIST
89767: LIST
89768: PUSH
89769: LD_INT 0
89771: PUSH
89772: LD_INT 1
89774: PUSH
89775: EMPTY
89776: LIST
89777: LIST
89778: PUSH
89779: LD_INT 1
89781: NEG
89782: PUSH
89783: LD_INT 0
89785: PUSH
89786: EMPTY
89787: LIST
89788: LIST
89789: PUSH
89790: LD_INT 1
89792: NEG
89793: PUSH
89794: LD_INT 1
89796: NEG
89797: PUSH
89798: EMPTY
89799: LIST
89800: LIST
89801: PUSH
89802: EMPTY
89803: LIST
89804: LIST
89805: LIST
89806: LIST
89807: LIST
89808: LIST
89809: LIST
89810: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89811: LD_ADDR_VAR 0 61
89815: PUSH
89816: LD_INT 0
89818: PUSH
89819: LD_INT 0
89821: PUSH
89822: EMPTY
89823: LIST
89824: LIST
89825: PUSH
89826: LD_INT 0
89828: PUSH
89829: LD_INT 1
89831: NEG
89832: PUSH
89833: EMPTY
89834: LIST
89835: LIST
89836: PUSH
89837: LD_INT 1
89839: PUSH
89840: LD_INT 0
89842: PUSH
89843: EMPTY
89844: LIST
89845: LIST
89846: PUSH
89847: LD_INT 1
89849: PUSH
89850: LD_INT 1
89852: PUSH
89853: EMPTY
89854: LIST
89855: LIST
89856: PUSH
89857: LD_INT 0
89859: PUSH
89860: LD_INT 1
89862: PUSH
89863: EMPTY
89864: LIST
89865: LIST
89866: PUSH
89867: LD_INT 1
89869: NEG
89870: PUSH
89871: LD_INT 0
89873: PUSH
89874: EMPTY
89875: LIST
89876: LIST
89877: PUSH
89878: LD_INT 1
89880: NEG
89881: PUSH
89882: LD_INT 1
89884: NEG
89885: PUSH
89886: EMPTY
89887: LIST
89888: LIST
89889: PUSH
89890: EMPTY
89891: LIST
89892: LIST
89893: LIST
89894: LIST
89895: LIST
89896: LIST
89897: LIST
89898: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89899: LD_ADDR_VAR 0 62
89903: PUSH
89904: LD_INT 0
89906: PUSH
89907: LD_INT 0
89909: PUSH
89910: EMPTY
89911: LIST
89912: LIST
89913: PUSH
89914: LD_INT 0
89916: PUSH
89917: LD_INT 1
89919: NEG
89920: PUSH
89921: EMPTY
89922: LIST
89923: LIST
89924: PUSH
89925: LD_INT 1
89927: PUSH
89928: LD_INT 0
89930: PUSH
89931: EMPTY
89932: LIST
89933: LIST
89934: PUSH
89935: LD_INT 1
89937: PUSH
89938: LD_INT 1
89940: PUSH
89941: EMPTY
89942: LIST
89943: LIST
89944: PUSH
89945: LD_INT 0
89947: PUSH
89948: LD_INT 1
89950: PUSH
89951: EMPTY
89952: LIST
89953: LIST
89954: PUSH
89955: LD_INT 1
89957: NEG
89958: PUSH
89959: LD_INT 0
89961: PUSH
89962: EMPTY
89963: LIST
89964: LIST
89965: PUSH
89966: LD_INT 1
89968: NEG
89969: PUSH
89970: LD_INT 1
89972: NEG
89973: PUSH
89974: EMPTY
89975: LIST
89976: LIST
89977: PUSH
89978: EMPTY
89979: LIST
89980: LIST
89981: LIST
89982: LIST
89983: LIST
89984: LIST
89985: LIST
89986: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89987: LD_ADDR_VAR 0 63
89991: PUSH
89992: LD_INT 0
89994: PUSH
89995: LD_INT 0
89997: PUSH
89998: EMPTY
89999: LIST
90000: LIST
90001: PUSH
90002: LD_INT 0
90004: PUSH
90005: LD_INT 1
90007: NEG
90008: PUSH
90009: EMPTY
90010: LIST
90011: LIST
90012: PUSH
90013: LD_INT 1
90015: PUSH
90016: LD_INT 0
90018: PUSH
90019: EMPTY
90020: LIST
90021: LIST
90022: PUSH
90023: LD_INT 1
90025: PUSH
90026: LD_INT 1
90028: PUSH
90029: EMPTY
90030: LIST
90031: LIST
90032: PUSH
90033: LD_INT 0
90035: PUSH
90036: LD_INT 1
90038: PUSH
90039: EMPTY
90040: LIST
90041: LIST
90042: PUSH
90043: LD_INT 1
90045: NEG
90046: PUSH
90047: LD_INT 0
90049: PUSH
90050: EMPTY
90051: LIST
90052: LIST
90053: PUSH
90054: LD_INT 1
90056: NEG
90057: PUSH
90058: LD_INT 1
90060: NEG
90061: PUSH
90062: EMPTY
90063: LIST
90064: LIST
90065: PUSH
90066: EMPTY
90067: LIST
90068: LIST
90069: LIST
90070: LIST
90071: LIST
90072: LIST
90073: LIST
90074: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90075: LD_ADDR_VAR 0 64
90079: PUSH
90080: LD_INT 0
90082: PUSH
90083: LD_INT 0
90085: PUSH
90086: EMPTY
90087: LIST
90088: LIST
90089: PUSH
90090: LD_INT 0
90092: PUSH
90093: LD_INT 1
90095: NEG
90096: PUSH
90097: EMPTY
90098: LIST
90099: LIST
90100: PUSH
90101: LD_INT 1
90103: PUSH
90104: LD_INT 0
90106: PUSH
90107: EMPTY
90108: LIST
90109: LIST
90110: PUSH
90111: LD_INT 1
90113: PUSH
90114: LD_INT 1
90116: PUSH
90117: EMPTY
90118: LIST
90119: LIST
90120: PUSH
90121: LD_INT 0
90123: PUSH
90124: LD_INT 1
90126: PUSH
90127: EMPTY
90128: LIST
90129: LIST
90130: PUSH
90131: LD_INT 1
90133: NEG
90134: PUSH
90135: LD_INT 0
90137: PUSH
90138: EMPTY
90139: LIST
90140: LIST
90141: PUSH
90142: LD_INT 1
90144: NEG
90145: PUSH
90146: LD_INT 1
90148: NEG
90149: PUSH
90150: EMPTY
90151: LIST
90152: LIST
90153: PUSH
90154: EMPTY
90155: LIST
90156: LIST
90157: LIST
90158: LIST
90159: LIST
90160: LIST
90161: LIST
90162: ST_TO_ADDR
// end ; 1 :
90163: GO 96060
90165: LD_INT 1
90167: DOUBLE
90168: EQUAL
90169: IFTRUE 90173
90171: GO 92796
90173: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90174: LD_ADDR_VAR 0 11
90178: PUSH
90179: LD_INT 1
90181: NEG
90182: PUSH
90183: LD_INT 3
90185: NEG
90186: PUSH
90187: EMPTY
90188: LIST
90189: LIST
90190: PUSH
90191: LD_INT 0
90193: PUSH
90194: LD_INT 3
90196: NEG
90197: PUSH
90198: EMPTY
90199: LIST
90200: LIST
90201: PUSH
90202: LD_INT 1
90204: PUSH
90205: LD_INT 2
90207: NEG
90208: PUSH
90209: EMPTY
90210: LIST
90211: LIST
90212: PUSH
90213: EMPTY
90214: LIST
90215: LIST
90216: LIST
90217: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90218: LD_ADDR_VAR 0 12
90222: PUSH
90223: LD_INT 2
90225: PUSH
90226: LD_INT 1
90228: NEG
90229: PUSH
90230: EMPTY
90231: LIST
90232: LIST
90233: PUSH
90234: LD_INT 3
90236: PUSH
90237: LD_INT 0
90239: PUSH
90240: EMPTY
90241: LIST
90242: LIST
90243: PUSH
90244: LD_INT 3
90246: PUSH
90247: LD_INT 1
90249: PUSH
90250: EMPTY
90251: LIST
90252: LIST
90253: PUSH
90254: EMPTY
90255: LIST
90256: LIST
90257: LIST
90258: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90259: LD_ADDR_VAR 0 13
90263: PUSH
90264: LD_INT 3
90266: PUSH
90267: LD_INT 2
90269: PUSH
90270: EMPTY
90271: LIST
90272: LIST
90273: PUSH
90274: LD_INT 3
90276: PUSH
90277: LD_INT 3
90279: PUSH
90280: EMPTY
90281: LIST
90282: LIST
90283: PUSH
90284: LD_INT 2
90286: PUSH
90287: LD_INT 3
90289: PUSH
90290: EMPTY
90291: LIST
90292: LIST
90293: PUSH
90294: EMPTY
90295: LIST
90296: LIST
90297: LIST
90298: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90299: LD_ADDR_VAR 0 14
90303: PUSH
90304: LD_INT 1
90306: PUSH
90307: LD_INT 3
90309: PUSH
90310: EMPTY
90311: LIST
90312: LIST
90313: PUSH
90314: LD_INT 0
90316: PUSH
90317: LD_INT 3
90319: PUSH
90320: EMPTY
90321: LIST
90322: LIST
90323: PUSH
90324: LD_INT 1
90326: NEG
90327: PUSH
90328: LD_INT 2
90330: PUSH
90331: EMPTY
90332: LIST
90333: LIST
90334: PUSH
90335: EMPTY
90336: LIST
90337: LIST
90338: LIST
90339: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90340: LD_ADDR_VAR 0 15
90344: PUSH
90345: LD_INT 2
90347: NEG
90348: PUSH
90349: LD_INT 1
90351: PUSH
90352: EMPTY
90353: LIST
90354: LIST
90355: PUSH
90356: LD_INT 3
90358: NEG
90359: PUSH
90360: LD_INT 0
90362: PUSH
90363: EMPTY
90364: LIST
90365: LIST
90366: PUSH
90367: LD_INT 3
90369: NEG
90370: PUSH
90371: LD_INT 1
90373: NEG
90374: PUSH
90375: EMPTY
90376: LIST
90377: LIST
90378: PUSH
90379: EMPTY
90380: LIST
90381: LIST
90382: LIST
90383: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90384: LD_ADDR_VAR 0 16
90388: PUSH
90389: LD_INT 2
90391: NEG
90392: PUSH
90393: LD_INT 3
90395: NEG
90396: PUSH
90397: EMPTY
90398: LIST
90399: LIST
90400: PUSH
90401: LD_INT 3
90403: NEG
90404: PUSH
90405: LD_INT 2
90407: NEG
90408: PUSH
90409: EMPTY
90410: LIST
90411: LIST
90412: PUSH
90413: LD_INT 3
90415: NEG
90416: PUSH
90417: LD_INT 3
90419: NEG
90420: PUSH
90421: EMPTY
90422: LIST
90423: LIST
90424: PUSH
90425: EMPTY
90426: LIST
90427: LIST
90428: LIST
90429: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90430: LD_ADDR_VAR 0 17
90434: PUSH
90435: LD_INT 1
90437: NEG
90438: PUSH
90439: LD_INT 3
90441: NEG
90442: PUSH
90443: EMPTY
90444: LIST
90445: LIST
90446: PUSH
90447: LD_INT 0
90449: PUSH
90450: LD_INT 3
90452: NEG
90453: PUSH
90454: EMPTY
90455: LIST
90456: LIST
90457: PUSH
90458: LD_INT 1
90460: PUSH
90461: LD_INT 2
90463: NEG
90464: PUSH
90465: EMPTY
90466: LIST
90467: LIST
90468: PUSH
90469: EMPTY
90470: LIST
90471: LIST
90472: LIST
90473: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90474: LD_ADDR_VAR 0 18
90478: PUSH
90479: LD_INT 2
90481: PUSH
90482: LD_INT 1
90484: NEG
90485: PUSH
90486: EMPTY
90487: LIST
90488: LIST
90489: PUSH
90490: LD_INT 3
90492: PUSH
90493: LD_INT 0
90495: PUSH
90496: EMPTY
90497: LIST
90498: LIST
90499: PUSH
90500: LD_INT 3
90502: PUSH
90503: LD_INT 1
90505: PUSH
90506: EMPTY
90507: LIST
90508: LIST
90509: PUSH
90510: EMPTY
90511: LIST
90512: LIST
90513: LIST
90514: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90515: LD_ADDR_VAR 0 19
90519: PUSH
90520: LD_INT 3
90522: PUSH
90523: LD_INT 2
90525: PUSH
90526: EMPTY
90527: LIST
90528: LIST
90529: PUSH
90530: LD_INT 3
90532: PUSH
90533: LD_INT 3
90535: PUSH
90536: EMPTY
90537: LIST
90538: LIST
90539: PUSH
90540: LD_INT 2
90542: PUSH
90543: LD_INT 3
90545: PUSH
90546: EMPTY
90547: LIST
90548: LIST
90549: PUSH
90550: EMPTY
90551: LIST
90552: LIST
90553: LIST
90554: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90555: LD_ADDR_VAR 0 20
90559: PUSH
90560: LD_INT 1
90562: PUSH
90563: LD_INT 3
90565: PUSH
90566: EMPTY
90567: LIST
90568: LIST
90569: PUSH
90570: LD_INT 0
90572: PUSH
90573: LD_INT 3
90575: PUSH
90576: EMPTY
90577: LIST
90578: LIST
90579: PUSH
90580: LD_INT 1
90582: NEG
90583: PUSH
90584: LD_INT 2
90586: PUSH
90587: EMPTY
90588: LIST
90589: LIST
90590: PUSH
90591: EMPTY
90592: LIST
90593: LIST
90594: LIST
90595: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90596: LD_ADDR_VAR 0 21
90600: PUSH
90601: LD_INT 2
90603: NEG
90604: PUSH
90605: LD_INT 1
90607: PUSH
90608: EMPTY
90609: LIST
90610: LIST
90611: PUSH
90612: LD_INT 3
90614: NEG
90615: PUSH
90616: LD_INT 0
90618: PUSH
90619: EMPTY
90620: LIST
90621: LIST
90622: PUSH
90623: LD_INT 3
90625: NEG
90626: PUSH
90627: LD_INT 1
90629: NEG
90630: PUSH
90631: EMPTY
90632: LIST
90633: LIST
90634: PUSH
90635: EMPTY
90636: LIST
90637: LIST
90638: LIST
90639: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90640: LD_ADDR_VAR 0 22
90644: PUSH
90645: LD_INT 2
90647: NEG
90648: PUSH
90649: LD_INT 3
90651: NEG
90652: PUSH
90653: EMPTY
90654: LIST
90655: LIST
90656: PUSH
90657: LD_INT 3
90659: NEG
90660: PUSH
90661: LD_INT 2
90663: NEG
90664: PUSH
90665: EMPTY
90666: LIST
90667: LIST
90668: PUSH
90669: LD_INT 3
90671: NEG
90672: PUSH
90673: LD_INT 3
90675: NEG
90676: PUSH
90677: EMPTY
90678: LIST
90679: LIST
90680: PUSH
90681: EMPTY
90682: LIST
90683: LIST
90684: LIST
90685: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
90686: LD_ADDR_VAR 0 23
90690: PUSH
90691: LD_INT 0
90693: PUSH
90694: LD_INT 3
90696: NEG
90697: PUSH
90698: EMPTY
90699: LIST
90700: LIST
90701: PUSH
90702: LD_INT 1
90704: NEG
90705: PUSH
90706: LD_INT 4
90708: NEG
90709: PUSH
90710: EMPTY
90711: LIST
90712: LIST
90713: PUSH
90714: LD_INT 1
90716: PUSH
90717: LD_INT 3
90719: NEG
90720: PUSH
90721: EMPTY
90722: LIST
90723: LIST
90724: PUSH
90725: EMPTY
90726: LIST
90727: LIST
90728: LIST
90729: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
90730: LD_ADDR_VAR 0 24
90734: PUSH
90735: LD_INT 3
90737: PUSH
90738: LD_INT 0
90740: PUSH
90741: EMPTY
90742: LIST
90743: LIST
90744: PUSH
90745: LD_INT 3
90747: PUSH
90748: LD_INT 1
90750: NEG
90751: PUSH
90752: EMPTY
90753: LIST
90754: LIST
90755: PUSH
90756: LD_INT 4
90758: PUSH
90759: LD_INT 1
90761: PUSH
90762: EMPTY
90763: LIST
90764: LIST
90765: PUSH
90766: EMPTY
90767: LIST
90768: LIST
90769: LIST
90770: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
90771: LD_ADDR_VAR 0 25
90775: PUSH
90776: LD_INT 3
90778: PUSH
90779: LD_INT 3
90781: PUSH
90782: EMPTY
90783: LIST
90784: LIST
90785: PUSH
90786: LD_INT 4
90788: PUSH
90789: LD_INT 3
90791: PUSH
90792: EMPTY
90793: LIST
90794: LIST
90795: PUSH
90796: LD_INT 3
90798: PUSH
90799: LD_INT 4
90801: PUSH
90802: EMPTY
90803: LIST
90804: LIST
90805: PUSH
90806: EMPTY
90807: LIST
90808: LIST
90809: LIST
90810: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
90811: LD_ADDR_VAR 0 26
90815: PUSH
90816: LD_INT 0
90818: PUSH
90819: LD_INT 3
90821: PUSH
90822: EMPTY
90823: LIST
90824: LIST
90825: PUSH
90826: LD_INT 1
90828: PUSH
90829: LD_INT 4
90831: PUSH
90832: EMPTY
90833: LIST
90834: LIST
90835: PUSH
90836: LD_INT 1
90838: NEG
90839: PUSH
90840: LD_INT 3
90842: PUSH
90843: EMPTY
90844: LIST
90845: LIST
90846: PUSH
90847: EMPTY
90848: LIST
90849: LIST
90850: LIST
90851: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
90852: LD_ADDR_VAR 0 27
90856: PUSH
90857: LD_INT 3
90859: NEG
90860: PUSH
90861: LD_INT 0
90863: PUSH
90864: EMPTY
90865: LIST
90866: LIST
90867: PUSH
90868: LD_INT 3
90870: NEG
90871: PUSH
90872: LD_INT 1
90874: PUSH
90875: EMPTY
90876: LIST
90877: LIST
90878: PUSH
90879: LD_INT 4
90881: NEG
90882: PUSH
90883: LD_INT 1
90885: NEG
90886: PUSH
90887: EMPTY
90888: LIST
90889: LIST
90890: PUSH
90891: EMPTY
90892: LIST
90893: LIST
90894: LIST
90895: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
90896: LD_ADDR_VAR 0 28
90900: PUSH
90901: LD_INT 3
90903: NEG
90904: PUSH
90905: LD_INT 3
90907: NEG
90908: PUSH
90909: EMPTY
90910: LIST
90911: LIST
90912: PUSH
90913: LD_INT 3
90915: NEG
90916: PUSH
90917: LD_INT 4
90919: NEG
90920: PUSH
90921: EMPTY
90922: LIST
90923: LIST
90924: PUSH
90925: LD_INT 4
90927: NEG
90928: PUSH
90929: LD_INT 3
90931: NEG
90932: PUSH
90933: EMPTY
90934: LIST
90935: LIST
90936: PUSH
90937: EMPTY
90938: LIST
90939: LIST
90940: LIST
90941: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
90942: LD_ADDR_VAR 0 29
90946: PUSH
90947: LD_INT 1
90949: NEG
90950: PUSH
90951: LD_INT 3
90953: NEG
90954: PUSH
90955: EMPTY
90956: LIST
90957: LIST
90958: PUSH
90959: LD_INT 0
90961: PUSH
90962: LD_INT 3
90964: NEG
90965: PUSH
90966: EMPTY
90967: LIST
90968: LIST
90969: PUSH
90970: LD_INT 1
90972: PUSH
90973: LD_INT 2
90975: NEG
90976: PUSH
90977: EMPTY
90978: LIST
90979: LIST
90980: PUSH
90981: LD_INT 1
90983: NEG
90984: PUSH
90985: LD_INT 4
90987: NEG
90988: PUSH
90989: EMPTY
90990: LIST
90991: LIST
90992: PUSH
90993: LD_INT 0
90995: PUSH
90996: LD_INT 4
90998: NEG
90999: PUSH
91000: EMPTY
91001: LIST
91002: LIST
91003: PUSH
91004: LD_INT 1
91006: PUSH
91007: LD_INT 3
91009: NEG
91010: PUSH
91011: EMPTY
91012: LIST
91013: LIST
91014: PUSH
91015: LD_INT 1
91017: NEG
91018: PUSH
91019: LD_INT 5
91021: NEG
91022: PUSH
91023: EMPTY
91024: LIST
91025: LIST
91026: PUSH
91027: LD_INT 0
91029: PUSH
91030: LD_INT 5
91032: NEG
91033: PUSH
91034: EMPTY
91035: LIST
91036: LIST
91037: PUSH
91038: LD_INT 1
91040: PUSH
91041: LD_INT 4
91043: NEG
91044: PUSH
91045: EMPTY
91046: LIST
91047: LIST
91048: PUSH
91049: LD_INT 1
91051: NEG
91052: PUSH
91053: LD_INT 6
91055: NEG
91056: PUSH
91057: EMPTY
91058: LIST
91059: LIST
91060: PUSH
91061: LD_INT 0
91063: PUSH
91064: LD_INT 6
91066: NEG
91067: PUSH
91068: EMPTY
91069: LIST
91070: LIST
91071: PUSH
91072: LD_INT 1
91074: PUSH
91075: LD_INT 5
91077: NEG
91078: PUSH
91079: EMPTY
91080: LIST
91081: LIST
91082: PUSH
91083: EMPTY
91084: LIST
91085: LIST
91086: LIST
91087: LIST
91088: LIST
91089: LIST
91090: LIST
91091: LIST
91092: LIST
91093: LIST
91094: LIST
91095: LIST
91096: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
91097: LD_ADDR_VAR 0 30
91101: PUSH
91102: LD_INT 2
91104: PUSH
91105: LD_INT 1
91107: NEG
91108: PUSH
91109: EMPTY
91110: LIST
91111: LIST
91112: PUSH
91113: LD_INT 3
91115: PUSH
91116: LD_INT 0
91118: PUSH
91119: EMPTY
91120: LIST
91121: LIST
91122: PUSH
91123: LD_INT 3
91125: PUSH
91126: LD_INT 1
91128: PUSH
91129: EMPTY
91130: LIST
91131: LIST
91132: PUSH
91133: LD_INT 3
91135: PUSH
91136: LD_INT 1
91138: NEG
91139: PUSH
91140: EMPTY
91141: LIST
91142: LIST
91143: PUSH
91144: LD_INT 4
91146: PUSH
91147: LD_INT 0
91149: PUSH
91150: EMPTY
91151: LIST
91152: LIST
91153: PUSH
91154: LD_INT 4
91156: PUSH
91157: LD_INT 1
91159: PUSH
91160: EMPTY
91161: LIST
91162: LIST
91163: PUSH
91164: LD_INT 4
91166: PUSH
91167: LD_INT 1
91169: NEG
91170: PUSH
91171: EMPTY
91172: LIST
91173: LIST
91174: PUSH
91175: LD_INT 5
91177: PUSH
91178: LD_INT 0
91180: PUSH
91181: EMPTY
91182: LIST
91183: LIST
91184: PUSH
91185: LD_INT 5
91187: PUSH
91188: LD_INT 1
91190: PUSH
91191: EMPTY
91192: LIST
91193: LIST
91194: PUSH
91195: LD_INT 5
91197: PUSH
91198: LD_INT 1
91200: NEG
91201: PUSH
91202: EMPTY
91203: LIST
91204: LIST
91205: PUSH
91206: LD_INT 6
91208: PUSH
91209: LD_INT 0
91211: PUSH
91212: EMPTY
91213: LIST
91214: LIST
91215: PUSH
91216: LD_INT 6
91218: PUSH
91219: LD_INT 1
91221: PUSH
91222: EMPTY
91223: LIST
91224: LIST
91225: PUSH
91226: EMPTY
91227: LIST
91228: LIST
91229: LIST
91230: LIST
91231: LIST
91232: LIST
91233: LIST
91234: LIST
91235: LIST
91236: LIST
91237: LIST
91238: LIST
91239: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
91240: LD_ADDR_VAR 0 31
91244: PUSH
91245: LD_INT 3
91247: PUSH
91248: LD_INT 2
91250: PUSH
91251: EMPTY
91252: LIST
91253: LIST
91254: PUSH
91255: LD_INT 3
91257: PUSH
91258: LD_INT 3
91260: PUSH
91261: EMPTY
91262: LIST
91263: LIST
91264: PUSH
91265: LD_INT 2
91267: PUSH
91268: LD_INT 3
91270: PUSH
91271: EMPTY
91272: LIST
91273: LIST
91274: PUSH
91275: LD_INT 4
91277: PUSH
91278: LD_INT 3
91280: PUSH
91281: EMPTY
91282: LIST
91283: LIST
91284: PUSH
91285: LD_INT 4
91287: PUSH
91288: LD_INT 4
91290: PUSH
91291: EMPTY
91292: LIST
91293: LIST
91294: PUSH
91295: LD_INT 3
91297: PUSH
91298: LD_INT 4
91300: PUSH
91301: EMPTY
91302: LIST
91303: LIST
91304: PUSH
91305: LD_INT 5
91307: PUSH
91308: LD_INT 4
91310: PUSH
91311: EMPTY
91312: LIST
91313: LIST
91314: PUSH
91315: LD_INT 5
91317: PUSH
91318: LD_INT 5
91320: PUSH
91321: EMPTY
91322: LIST
91323: LIST
91324: PUSH
91325: LD_INT 4
91327: PUSH
91328: LD_INT 5
91330: PUSH
91331: EMPTY
91332: LIST
91333: LIST
91334: PUSH
91335: LD_INT 6
91337: PUSH
91338: LD_INT 5
91340: PUSH
91341: EMPTY
91342: LIST
91343: LIST
91344: PUSH
91345: LD_INT 6
91347: PUSH
91348: LD_INT 6
91350: PUSH
91351: EMPTY
91352: LIST
91353: LIST
91354: PUSH
91355: LD_INT 5
91357: PUSH
91358: LD_INT 6
91360: PUSH
91361: EMPTY
91362: LIST
91363: LIST
91364: PUSH
91365: EMPTY
91366: LIST
91367: LIST
91368: LIST
91369: LIST
91370: LIST
91371: LIST
91372: LIST
91373: LIST
91374: LIST
91375: LIST
91376: LIST
91377: LIST
91378: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
91379: LD_ADDR_VAR 0 32
91383: PUSH
91384: LD_INT 1
91386: PUSH
91387: LD_INT 3
91389: PUSH
91390: EMPTY
91391: LIST
91392: LIST
91393: PUSH
91394: LD_INT 0
91396: PUSH
91397: LD_INT 3
91399: PUSH
91400: EMPTY
91401: LIST
91402: LIST
91403: PUSH
91404: LD_INT 1
91406: NEG
91407: PUSH
91408: LD_INT 2
91410: PUSH
91411: EMPTY
91412: LIST
91413: LIST
91414: PUSH
91415: LD_INT 1
91417: PUSH
91418: LD_INT 4
91420: PUSH
91421: EMPTY
91422: LIST
91423: LIST
91424: PUSH
91425: LD_INT 0
91427: PUSH
91428: LD_INT 4
91430: PUSH
91431: EMPTY
91432: LIST
91433: LIST
91434: PUSH
91435: LD_INT 1
91437: NEG
91438: PUSH
91439: LD_INT 3
91441: PUSH
91442: EMPTY
91443: LIST
91444: LIST
91445: PUSH
91446: LD_INT 1
91448: PUSH
91449: LD_INT 5
91451: PUSH
91452: EMPTY
91453: LIST
91454: LIST
91455: PUSH
91456: LD_INT 0
91458: PUSH
91459: LD_INT 5
91461: PUSH
91462: EMPTY
91463: LIST
91464: LIST
91465: PUSH
91466: LD_INT 1
91468: NEG
91469: PUSH
91470: LD_INT 4
91472: PUSH
91473: EMPTY
91474: LIST
91475: LIST
91476: PUSH
91477: LD_INT 1
91479: PUSH
91480: LD_INT 6
91482: PUSH
91483: EMPTY
91484: LIST
91485: LIST
91486: PUSH
91487: LD_INT 0
91489: PUSH
91490: LD_INT 6
91492: PUSH
91493: EMPTY
91494: LIST
91495: LIST
91496: PUSH
91497: LD_INT 1
91499: NEG
91500: PUSH
91501: LD_INT 5
91503: PUSH
91504: EMPTY
91505: LIST
91506: LIST
91507: PUSH
91508: EMPTY
91509: LIST
91510: LIST
91511: LIST
91512: LIST
91513: LIST
91514: LIST
91515: LIST
91516: LIST
91517: LIST
91518: LIST
91519: LIST
91520: LIST
91521: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
91522: LD_ADDR_VAR 0 33
91526: PUSH
91527: LD_INT 2
91529: NEG
91530: PUSH
91531: LD_INT 1
91533: PUSH
91534: EMPTY
91535: LIST
91536: LIST
91537: PUSH
91538: LD_INT 3
91540: NEG
91541: PUSH
91542: LD_INT 0
91544: PUSH
91545: EMPTY
91546: LIST
91547: LIST
91548: PUSH
91549: LD_INT 3
91551: NEG
91552: PUSH
91553: LD_INT 1
91555: NEG
91556: PUSH
91557: EMPTY
91558: LIST
91559: LIST
91560: PUSH
91561: LD_INT 3
91563: NEG
91564: PUSH
91565: LD_INT 1
91567: PUSH
91568: EMPTY
91569: LIST
91570: LIST
91571: PUSH
91572: LD_INT 4
91574: NEG
91575: PUSH
91576: LD_INT 0
91578: PUSH
91579: EMPTY
91580: LIST
91581: LIST
91582: PUSH
91583: LD_INT 4
91585: NEG
91586: PUSH
91587: LD_INT 1
91589: NEG
91590: PUSH
91591: EMPTY
91592: LIST
91593: LIST
91594: PUSH
91595: LD_INT 4
91597: NEG
91598: PUSH
91599: LD_INT 1
91601: PUSH
91602: EMPTY
91603: LIST
91604: LIST
91605: PUSH
91606: LD_INT 5
91608: NEG
91609: PUSH
91610: LD_INT 0
91612: PUSH
91613: EMPTY
91614: LIST
91615: LIST
91616: PUSH
91617: LD_INT 5
91619: NEG
91620: PUSH
91621: LD_INT 1
91623: NEG
91624: PUSH
91625: EMPTY
91626: LIST
91627: LIST
91628: PUSH
91629: LD_INT 5
91631: NEG
91632: PUSH
91633: LD_INT 1
91635: PUSH
91636: EMPTY
91637: LIST
91638: LIST
91639: PUSH
91640: LD_INT 6
91642: NEG
91643: PUSH
91644: LD_INT 0
91646: PUSH
91647: EMPTY
91648: LIST
91649: LIST
91650: PUSH
91651: LD_INT 6
91653: NEG
91654: PUSH
91655: LD_INT 1
91657: NEG
91658: PUSH
91659: EMPTY
91660: LIST
91661: LIST
91662: PUSH
91663: EMPTY
91664: LIST
91665: LIST
91666: LIST
91667: LIST
91668: LIST
91669: LIST
91670: LIST
91671: LIST
91672: LIST
91673: LIST
91674: LIST
91675: LIST
91676: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
91677: LD_ADDR_VAR 0 34
91681: PUSH
91682: LD_INT 2
91684: NEG
91685: PUSH
91686: LD_INT 3
91688: NEG
91689: PUSH
91690: EMPTY
91691: LIST
91692: LIST
91693: PUSH
91694: LD_INT 3
91696: NEG
91697: PUSH
91698: LD_INT 2
91700: NEG
91701: PUSH
91702: EMPTY
91703: LIST
91704: LIST
91705: PUSH
91706: LD_INT 3
91708: NEG
91709: PUSH
91710: LD_INT 3
91712: NEG
91713: PUSH
91714: EMPTY
91715: LIST
91716: LIST
91717: PUSH
91718: LD_INT 3
91720: NEG
91721: PUSH
91722: LD_INT 4
91724: NEG
91725: PUSH
91726: EMPTY
91727: LIST
91728: LIST
91729: PUSH
91730: LD_INT 4
91732: NEG
91733: PUSH
91734: LD_INT 3
91736: NEG
91737: PUSH
91738: EMPTY
91739: LIST
91740: LIST
91741: PUSH
91742: LD_INT 4
91744: NEG
91745: PUSH
91746: LD_INT 4
91748: NEG
91749: PUSH
91750: EMPTY
91751: LIST
91752: LIST
91753: PUSH
91754: LD_INT 4
91756: NEG
91757: PUSH
91758: LD_INT 5
91760: NEG
91761: PUSH
91762: EMPTY
91763: LIST
91764: LIST
91765: PUSH
91766: LD_INT 5
91768: NEG
91769: PUSH
91770: LD_INT 4
91772: NEG
91773: PUSH
91774: EMPTY
91775: LIST
91776: LIST
91777: PUSH
91778: LD_INT 5
91780: NEG
91781: PUSH
91782: LD_INT 5
91784: NEG
91785: PUSH
91786: EMPTY
91787: LIST
91788: LIST
91789: PUSH
91790: LD_INT 5
91792: NEG
91793: PUSH
91794: LD_INT 6
91796: NEG
91797: PUSH
91798: EMPTY
91799: LIST
91800: LIST
91801: PUSH
91802: LD_INT 6
91804: NEG
91805: PUSH
91806: LD_INT 5
91808: NEG
91809: PUSH
91810: EMPTY
91811: LIST
91812: LIST
91813: PUSH
91814: LD_INT 6
91816: NEG
91817: PUSH
91818: LD_INT 6
91820: NEG
91821: PUSH
91822: EMPTY
91823: LIST
91824: LIST
91825: PUSH
91826: EMPTY
91827: LIST
91828: LIST
91829: LIST
91830: LIST
91831: LIST
91832: LIST
91833: LIST
91834: LIST
91835: LIST
91836: LIST
91837: LIST
91838: LIST
91839: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
91840: LD_ADDR_VAR 0 41
91844: PUSH
91845: LD_INT 0
91847: PUSH
91848: LD_INT 2
91850: NEG
91851: PUSH
91852: EMPTY
91853: LIST
91854: LIST
91855: PUSH
91856: LD_INT 1
91858: NEG
91859: PUSH
91860: LD_INT 3
91862: NEG
91863: PUSH
91864: EMPTY
91865: LIST
91866: LIST
91867: PUSH
91868: LD_INT 1
91870: PUSH
91871: LD_INT 2
91873: NEG
91874: PUSH
91875: EMPTY
91876: LIST
91877: LIST
91878: PUSH
91879: EMPTY
91880: LIST
91881: LIST
91882: LIST
91883: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
91884: LD_ADDR_VAR 0 42
91888: PUSH
91889: LD_INT 2
91891: PUSH
91892: LD_INT 0
91894: PUSH
91895: EMPTY
91896: LIST
91897: LIST
91898: PUSH
91899: LD_INT 2
91901: PUSH
91902: LD_INT 1
91904: NEG
91905: PUSH
91906: EMPTY
91907: LIST
91908: LIST
91909: PUSH
91910: LD_INT 3
91912: PUSH
91913: LD_INT 1
91915: PUSH
91916: EMPTY
91917: LIST
91918: LIST
91919: PUSH
91920: EMPTY
91921: LIST
91922: LIST
91923: LIST
91924: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
91925: LD_ADDR_VAR 0 43
91929: PUSH
91930: LD_INT 2
91932: PUSH
91933: LD_INT 2
91935: PUSH
91936: EMPTY
91937: LIST
91938: LIST
91939: PUSH
91940: LD_INT 3
91942: PUSH
91943: LD_INT 2
91945: PUSH
91946: EMPTY
91947: LIST
91948: LIST
91949: PUSH
91950: LD_INT 2
91952: PUSH
91953: LD_INT 3
91955: PUSH
91956: EMPTY
91957: LIST
91958: LIST
91959: PUSH
91960: EMPTY
91961: LIST
91962: LIST
91963: LIST
91964: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
91965: LD_ADDR_VAR 0 44
91969: PUSH
91970: LD_INT 0
91972: PUSH
91973: LD_INT 2
91975: PUSH
91976: EMPTY
91977: LIST
91978: LIST
91979: PUSH
91980: LD_INT 1
91982: PUSH
91983: LD_INT 3
91985: PUSH
91986: EMPTY
91987: LIST
91988: LIST
91989: PUSH
91990: LD_INT 1
91992: NEG
91993: PUSH
91994: LD_INT 2
91996: PUSH
91997: EMPTY
91998: LIST
91999: LIST
92000: PUSH
92001: EMPTY
92002: LIST
92003: LIST
92004: LIST
92005: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
92006: LD_ADDR_VAR 0 45
92010: PUSH
92011: LD_INT 2
92013: NEG
92014: PUSH
92015: LD_INT 0
92017: PUSH
92018: EMPTY
92019: LIST
92020: LIST
92021: PUSH
92022: LD_INT 2
92024: NEG
92025: PUSH
92026: LD_INT 1
92028: PUSH
92029: EMPTY
92030: LIST
92031: LIST
92032: PUSH
92033: LD_INT 3
92035: NEG
92036: PUSH
92037: LD_INT 1
92039: NEG
92040: PUSH
92041: EMPTY
92042: LIST
92043: LIST
92044: PUSH
92045: EMPTY
92046: LIST
92047: LIST
92048: LIST
92049: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
92050: LD_ADDR_VAR 0 46
92054: PUSH
92055: LD_INT 2
92057: NEG
92058: PUSH
92059: LD_INT 2
92061: NEG
92062: PUSH
92063: EMPTY
92064: LIST
92065: LIST
92066: PUSH
92067: LD_INT 2
92069: NEG
92070: PUSH
92071: LD_INT 3
92073: NEG
92074: PUSH
92075: EMPTY
92076: LIST
92077: LIST
92078: PUSH
92079: LD_INT 3
92081: NEG
92082: PUSH
92083: LD_INT 2
92085: NEG
92086: PUSH
92087: EMPTY
92088: LIST
92089: LIST
92090: PUSH
92091: EMPTY
92092: LIST
92093: LIST
92094: LIST
92095: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
92096: LD_ADDR_VAR 0 47
92100: PUSH
92101: LD_INT 2
92103: NEG
92104: PUSH
92105: LD_INT 3
92107: NEG
92108: PUSH
92109: EMPTY
92110: LIST
92111: LIST
92112: PUSH
92113: LD_INT 1
92115: NEG
92116: PUSH
92117: LD_INT 3
92119: NEG
92120: PUSH
92121: EMPTY
92122: LIST
92123: LIST
92124: PUSH
92125: EMPTY
92126: LIST
92127: LIST
92128: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
92129: LD_ADDR_VAR 0 48
92133: PUSH
92134: LD_INT 1
92136: PUSH
92137: LD_INT 2
92139: NEG
92140: PUSH
92141: EMPTY
92142: LIST
92143: LIST
92144: PUSH
92145: LD_INT 2
92147: PUSH
92148: LD_INT 1
92150: NEG
92151: PUSH
92152: EMPTY
92153: LIST
92154: LIST
92155: PUSH
92156: EMPTY
92157: LIST
92158: LIST
92159: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
92160: LD_ADDR_VAR 0 49
92164: PUSH
92165: LD_INT 3
92167: PUSH
92168: LD_INT 1
92170: PUSH
92171: EMPTY
92172: LIST
92173: LIST
92174: PUSH
92175: LD_INT 3
92177: PUSH
92178: LD_INT 2
92180: PUSH
92181: EMPTY
92182: LIST
92183: LIST
92184: PUSH
92185: EMPTY
92186: LIST
92187: LIST
92188: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
92189: LD_ADDR_VAR 0 50
92193: PUSH
92194: LD_INT 2
92196: PUSH
92197: LD_INT 3
92199: PUSH
92200: EMPTY
92201: LIST
92202: LIST
92203: PUSH
92204: LD_INT 1
92206: PUSH
92207: LD_INT 3
92209: PUSH
92210: EMPTY
92211: LIST
92212: LIST
92213: PUSH
92214: EMPTY
92215: LIST
92216: LIST
92217: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
92218: LD_ADDR_VAR 0 51
92222: PUSH
92223: LD_INT 1
92225: NEG
92226: PUSH
92227: LD_INT 2
92229: PUSH
92230: EMPTY
92231: LIST
92232: LIST
92233: PUSH
92234: LD_INT 2
92236: NEG
92237: PUSH
92238: LD_INT 1
92240: PUSH
92241: EMPTY
92242: LIST
92243: LIST
92244: PUSH
92245: EMPTY
92246: LIST
92247: LIST
92248: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
92249: LD_ADDR_VAR 0 52
92253: PUSH
92254: LD_INT 3
92256: NEG
92257: PUSH
92258: LD_INT 1
92260: NEG
92261: PUSH
92262: EMPTY
92263: LIST
92264: LIST
92265: PUSH
92266: LD_INT 3
92268: NEG
92269: PUSH
92270: LD_INT 2
92272: NEG
92273: PUSH
92274: EMPTY
92275: LIST
92276: LIST
92277: PUSH
92278: EMPTY
92279: LIST
92280: LIST
92281: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92282: LD_ADDR_VAR 0 53
92286: PUSH
92287: LD_INT 1
92289: NEG
92290: PUSH
92291: LD_INT 3
92293: NEG
92294: PUSH
92295: EMPTY
92296: LIST
92297: LIST
92298: PUSH
92299: LD_INT 0
92301: PUSH
92302: LD_INT 3
92304: NEG
92305: PUSH
92306: EMPTY
92307: LIST
92308: LIST
92309: PUSH
92310: LD_INT 1
92312: PUSH
92313: LD_INT 2
92315: NEG
92316: PUSH
92317: EMPTY
92318: LIST
92319: LIST
92320: PUSH
92321: EMPTY
92322: LIST
92323: LIST
92324: LIST
92325: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92326: LD_ADDR_VAR 0 54
92330: PUSH
92331: LD_INT 2
92333: PUSH
92334: LD_INT 1
92336: NEG
92337: PUSH
92338: EMPTY
92339: LIST
92340: LIST
92341: PUSH
92342: LD_INT 3
92344: PUSH
92345: LD_INT 0
92347: PUSH
92348: EMPTY
92349: LIST
92350: LIST
92351: PUSH
92352: LD_INT 3
92354: PUSH
92355: LD_INT 1
92357: PUSH
92358: EMPTY
92359: LIST
92360: LIST
92361: PUSH
92362: EMPTY
92363: LIST
92364: LIST
92365: LIST
92366: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92367: LD_ADDR_VAR 0 55
92371: PUSH
92372: LD_INT 3
92374: PUSH
92375: LD_INT 2
92377: PUSH
92378: EMPTY
92379: LIST
92380: LIST
92381: PUSH
92382: LD_INT 3
92384: PUSH
92385: LD_INT 3
92387: PUSH
92388: EMPTY
92389: LIST
92390: LIST
92391: PUSH
92392: LD_INT 2
92394: PUSH
92395: LD_INT 3
92397: PUSH
92398: EMPTY
92399: LIST
92400: LIST
92401: PUSH
92402: EMPTY
92403: LIST
92404: LIST
92405: LIST
92406: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92407: LD_ADDR_VAR 0 56
92411: PUSH
92412: LD_INT 1
92414: PUSH
92415: LD_INT 3
92417: PUSH
92418: EMPTY
92419: LIST
92420: LIST
92421: PUSH
92422: LD_INT 0
92424: PUSH
92425: LD_INT 3
92427: PUSH
92428: EMPTY
92429: LIST
92430: LIST
92431: PUSH
92432: LD_INT 1
92434: NEG
92435: PUSH
92436: LD_INT 2
92438: PUSH
92439: EMPTY
92440: LIST
92441: LIST
92442: PUSH
92443: EMPTY
92444: LIST
92445: LIST
92446: LIST
92447: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92448: LD_ADDR_VAR 0 57
92452: PUSH
92453: LD_INT 2
92455: NEG
92456: PUSH
92457: LD_INT 1
92459: PUSH
92460: EMPTY
92461: LIST
92462: LIST
92463: PUSH
92464: LD_INT 3
92466: NEG
92467: PUSH
92468: LD_INT 0
92470: PUSH
92471: EMPTY
92472: LIST
92473: LIST
92474: PUSH
92475: LD_INT 3
92477: NEG
92478: PUSH
92479: LD_INT 1
92481: NEG
92482: PUSH
92483: EMPTY
92484: LIST
92485: LIST
92486: PUSH
92487: EMPTY
92488: LIST
92489: LIST
92490: LIST
92491: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92492: LD_ADDR_VAR 0 58
92496: PUSH
92497: LD_INT 2
92499: NEG
92500: PUSH
92501: LD_INT 3
92503: NEG
92504: PUSH
92505: EMPTY
92506: LIST
92507: LIST
92508: PUSH
92509: LD_INT 3
92511: NEG
92512: PUSH
92513: LD_INT 2
92515: NEG
92516: PUSH
92517: EMPTY
92518: LIST
92519: LIST
92520: PUSH
92521: LD_INT 3
92523: NEG
92524: PUSH
92525: LD_INT 3
92527: NEG
92528: PUSH
92529: EMPTY
92530: LIST
92531: LIST
92532: PUSH
92533: EMPTY
92534: LIST
92535: LIST
92536: LIST
92537: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
92538: LD_ADDR_VAR 0 59
92542: PUSH
92543: LD_INT 1
92545: NEG
92546: PUSH
92547: LD_INT 2
92549: NEG
92550: PUSH
92551: EMPTY
92552: LIST
92553: LIST
92554: PUSH
92555: LD_INT 0
92557: PUSH
92558: LD_INT 2
92560: NEG
92561: PUSH
92562: EMPTY
92563: LIST
92564: LIST
92565: PUSH
92566: LD_INT 1
92568: PUSH
92569: LD_INT 1
92571: NEG
92572: PUSH
92573: EMPTY
92574: LIST
92575: LIST
92576: PUSH
92577: EMPTY
92578: LIST
92579: LIST
92580: LIST
92581: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
92582: LD_ADDR_VAR 0 60
92586: PUSH
92587: LD_INT 1
92589: PUSH
92590: LD_INT 1
92592: NEG
92593: PUSH
92594: EMPTY
92595: LIST
92596: LIST
92597: PUSH
92598: LD_INT 2
92600: PUSH
92601: LD_INT 0
92603: PUSH
92604: EMPTY
92605: LIST
92606: LIST
92607: PUSH
92608: LD_INT 2
92610: PUSH
92611: LD_INT 1
92613: PUSH
92614: EMPTY
92615: LIST
92616: LIST
92617: PUSH
92618: EMPTY
92619: LIST
92620: LIST
92621: LIST
92622: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
92623: LD_ADDR_VAR 0 61
92627: PUSH
92628: LD_INT 2
92630: PUSH
92631: LD_INT 1
92633: PUSH
92634: EMPTY
92635: LIST
92636: LIST
92637: PUSH
92638: LD_INT 2
92640: PUSH
92641: LD_INT 2
92643: PUSH
92644: EMPTY
92645: LIST
92646: LIST
92647: PUSH
92648: LD_INT 1
92650: PUSH
92651: LD_INT 2
92653: PUSH
92654: EMPTY
92655: LIST
92656: LIST
92657: PUSH
92658: EMPTY
92659: LIST
92660: LIST
92661: LIST
92662: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
92663: LD_ADDR_VAR 0 62
92667: PUSH
92668: LD_INT 1
92670: PUSH
92671: LD_INT 2
92673: PUSH
92674: EMPTY
92675: LIST
92676: LIST
92677: PUSH
92678: LD_INT 0
92680: PUSH
92681: LD_INT 2
92683: PUSH
92684: EMPTY
92685: LIST
92686: LIST
92687: PUSH
92688: LD_INT 1
92690: NEG
92691: PUSH
92692: LD_INT 1
92694: PUSH
92695: EMPTY
92696: LIST
92697: LIST
92698: PUSH
92699: EMPTY
92700: LIST
92701: LIST
92702: LIST
92703: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
92704: LD_ADDR_VAR 0 63
92708: PUSH
92709: LD_INT 1
92711: NEG
92712: PUSH
92713: LD_INT 1
92715: PUSH
92716: EMPTY
92717: LIST
92718: LIST
92719: PUSH
92720: LD_INT 2
92722: NEG
92723: PUSH
92724: LD_INT 0
92726: PUSH
92727: EMPTY
92728: LIST
92729: LIST
92730: PUSH
92731: LD_INT 2
92733: NEG
92734: PUSH
92735: LD_INT 1
92737: NEG
92738: PUSH
92739: EMPTY
92740: LIST
92741: LIST
92742: PUSH
92743: EMPTY
92744: LIST
92745: LIST
92746: LIST
92747: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92748: LD_ADDR_VAR 0 64
92752: PUSH
92753: LD_INT 1
92755: NEG
92756: PUSH
92757: LD_INT 2
92759: NEG
92760: PUSH
92761: EMPTY
92762: LIST
92763: LIST
92764: PUSH
92765: LD_INT 2
92767: NEG
92768: PUSH
92769: LD_INT 1
92771: NEG
92772: PUSH
92773: EMPTY
92774: LIST
92775: LIST
92776: PUSH
92777: LD_INT 2
92779: NEG
92780: PUSH
92781: LD_INT 2
92783: NEG
92784: PUSH
92785: EMPTY
92786: LIST
92787: LIST
92788: PUSH
92789: EMPTY
92790: LIST
92791: LIST
92792: LIST
92793: ST_TO_ADDR
// end ; 2 :
92794: GO 96060
92796: LD_INT 2
92798: DOUBLE
92799: EQUAL
92800: IFTRUE 92804
92802: GO 96059
92804: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
92805: LD_ADDR_VAR 0 29
92809: PUSH
92810: LD_INT 4
92812: PUSH
92813: LD_INT 0
92815: PUSH
92816: EMPTY
92817: LIST
92818: LIST
92819: PUSH
92820: LD_INT 4
92822: PUSH
92823: LD_INT 1
92825: NEG
92826: PUSH
92827: EMPTY
92828: LIST
92829: LIST
92830: PUSH
92831: LD_INT 5
92833: PUSH
92834: LD_INT 0
92836: PUSH
92837: EMPTY
92838: LIST
92839: LIST
92840: PUSH
92841: LD_INT 5
92843: PUSH
92844: LD_INT 1
92846: PUSH
92847: EMPTY
92848: LIST
92849: LIST
92850: PUSH
92851: LD_INT 4
92853: PUSH
92854: LD_INT 1
92856: PUSH
92857: EMPTY
92858: LIST
92859: LIST
92860: PUSH
92861: LD_INT 3
92863: PUSH
92864: LD_INT 0
92866: PUSH
92867: EMPTY
92868: LIST
92869: LIST
92870: PUSH
92871: LD_INT 3
92873: PUSH
92874: LD_INT 1
92876: NEG
92877: PUSH
92878: EMPTY
92879: LIST
92880: LIST
92881: PUSH
92882: LD_INT 3
92884: PUSH
92885: LD_INT 2
92887: NEG
92888: PUSH
92889: EMPTY
92890: LIST
92891: LIST
92892: PUSH
92893: LD_INT 5
92895: PUSH
92896: LD_INT 2
92898: PUSH
92899: EMPTY
92900: LIST
92901: LIST
92902: PUSH
92903: LD_INT 3
92905: PUSH
92906: LD_INT 3
92908: PUSH
92909: EMPTY
92910: LIST
92911: LIST
92912: PUSH
92913: LD_INT 3
92915: PUSH
92916: LD_INT 2
92918: PUSH
92919: EMPTY
92920: LIST
92921: LIST
92922: PUSH
92923: LD_INT 4
92925: PUSH
92926: LD_INT 3
92928: PUSH
92929: EMPTY
92930: LIST
92931: LIST
92932: PUSH
92933: LD_INT 4
92935: PUSH
92936: LD_INT 4
92938: PUSH
92939: EMPTY
92940: LIST
92941: LIST
92942: PUSH
92943: LD_INT 3
92945: PUSH
92946: LD_INT 4
92948: PUSH
92949: EMPTY
92950: LIST
92951: LIST
92952: PUSH
92953: LD_INT 2
92955: PUSH
92956: LD_INT 3
92958: PUSH
92959: EMPTY
92960: LIST
92961: LIST
92962: PUSH
92963: LD_INT 2
92965: PUSH
92966: LD_INT 2
92968: PUSH
92969: EMPTY
92970: LIST
92971: LIST
92972: PUSH
92973: LD_INT 4
92975: PUSH
92976: LD_INT 2
92978: PUSH
92979: EMPTY
92980: LIST
92981: LIST
92982: PUSH
92983: LD_INT 2
92985: PUSH
92986: LD_INT 4
92988: PUSH
92989: EMPTY
92990: LIST
92991: LIST
92992: PUSH
92993: LD_INT 0
92995: PUSH
92996: LD_INT 4
92998: PUSH
92999: EMPTY
93000: LIST
93001: LIST
93002: PUSH
93003: LD_INT 0
93005: PUSH
93006: LD_INT 3
93008: PUSH
93009: EMPTY
93010: LIST
93011: LIST
93012: PUSH
93013: LD_INT 1
93015: PUSH
93016: LD_INT 4
93018: PUSH
93019: EMPTY
93020: LIST
93021: LIST
93022: PUSH
93023: LD_INT 1
93025: PUSH
93026: LD_INT 5
93028: PUSH
93029: EMPTY
93030: LIST
93031: LIST
93032: PUSH
93033: LD_INT 0
93035: PUSH
93036: LD_INT 5
93038: PUSH
93039: EMPTY
93040: LIST
93041: LIST
93042: PUSH
93043: LD_INT 1
93045: NEG
93046: PUSH
93047: LD_INT 4
93049: PUSH
93050: EMPTY
93051: LIST
93052: LIST
93053: PUSH
93054: LD_INT 1
93056: NEG
93057: PUSH
93058: LD_INT 3
93060: PUSH
93061: EMPTY
93062: LIST
93063: LIST
93064: PUSH
93065: LD_INT 2
93067: PUSH
93068: LD_INT 5
93070: PUSH
93071: EMPTY
93072: LIST
93073: LIST
93074: PUSH
93075: LD_INT 2
93077: NEG
93078: PUSH
93079: LD_INT 3
93081: PUSH
93082: EMPTY
93083: LIST
93084: LIST
93085: PUSH
93086: LD_INT 3
93088: NEG
93089: PUSH
93090: LD_INT 0
93092: PUSH
93093: EMPTY
93094: LIST
93095: LIST
93096: PUSH
93097: LD_INT 3
93099: NEG
93100: PUSH
93101: LD_INT 1
93103: NEG
93104: PUSH
93105: EMPTY
93106: LIST
93107: LIST
93108: PUSH
93109: LD_INT 2
93111: NEG
93112: PUSH
93113: LD_INT 0
93115: PUSH
93116: EMPTY
93117: LIST
93118: LIST
93119: PUSH
93120: LD_INT 2
93122: NEG
93123: PUSH
93124: LD_INT 1
93126: PUSH
93127: EMPTY
93128: LIST
93129: LIST
93130: PUSH
93131: LD_INT 3
93133: NEG
93134: PUSH
93135: LD_INT 1
93137: PUSH
93138: EMPTY
93139: LIST
93140: LIST
93141: PUSH
93142: LD_INT 4
93144: NEG
93145: PUSH
93146: LD_INT 0
93148: PUSH
93149: EMPTY
93150: LIST
93151: LIST
93152: PUSH
93153: LD_INT 4
93155: NEG
93156: PUSH
93157: LD_INT 1
93159: NEG
93160: PUSH
93161: EMPTY
93162: LIST
93163: LIST
93164: PUSH
93165: LD_INT 4
93167: NEG
93168: PUSH
93169: LD_INT 2
93171: NEG
93172: PUSH
93173: EMPTY
93174: LIST
93175: LIST
93176: PUSH
93177: LD_INT 2
93179: NEG
93180: PUSH
93181: LD_INT 2
93183: PUSH
93184: EMPTY
93185: LIST
93186: LIST
93187: PUSH
93188: LD_INT 4
93190: NEG
93191: PUSH
93192: LD_INT 4
93194: NEG
93195: PUSH
93196: EMPTY
93197: LIST
93198: LIST
93199: PUSH
93200: LD_INT 4
93202: NEG
93203: PUSH
93204: LD_INT 5
93206: NEG
93207: PUSH
93208: EMPTY
93209: LIST
93210: LIST
93211: PUSH
93212: LD_INT 3
93214: NEG
93215: PUSH
93216: LD_INT 4
93218: NEG
93219: PUSH
93220: EMPTY
93221: LIST
93222: LIST
93223: PUSH
93224: LD_INT 3
93226: NEG
93227: PUSH
93228: LD_INT 3
93230: NEG
93231: PUSH
93232: EMPTY
93233: LIST
93234: LIST
93235: PUSH
93236: LD_INT 4
93238: NEG
93239: PUSH
93240: LD_INT 3
93242: NEG
93243: PUSH
93244: EMPTY
93245: LIST
93246: LIST
93247: PUSH
93248: LD_INT 5
93250: NEG
93251: PUSH
93252: LD_INT 4
93254: NEG
93255: PUSH
93256: EMPTY
93257: LIST
93258: LIST
93259: PUSH
93260: LD_INT 5
93262: NEG
93263: PUSH
93264: LD_INT 5
93266: NEG
93267: PUSH
93268: EMPTY
93269: LIST
93270: LIST
93271: PUSH
93272: LD_INT 3
93274: NEG
93275: PUSH
93276: LD_INT 5
93278: NEG
93279: PUSH
93280: EMPTY
93281: LIST
93282: LIST
93283: PUSH
93284: LD_INT 5
93286: NEG
93287: PUSH
93288: LD_INT 3
93290: NEG
93291: PUSH
93292: EMPTY
93293: LIST
93294: LIST
93295: PUSH
93296: EMPTY
93297: LIST
93298: LIST
93299: LIST
93300: LIST
93301: LIST
93302: LIST
93303: LIST
93304: LIST
93305: LIST
93306: LIST
93307: LIST
93308: LIST
93309: LIST
93310: LIST
93311: LIST
93312: LIST
93313: LIST
93314: LIST
93315: LIST
93316: LIST
93317: LIST
93318: LIST
93319: LIST
93320: LIST
93321: LIST
93322: LIST
93323: LIST
93324: LIST
93325: LIST
93326: LIST
93327: LIST
93328: LIST
93329: LIST
93330: LIST
93331: LIST
93332: LIST
93333: LIST
93334: LIST
93335: LIST
93336: LIST
93337: LIST
93338: LIST
93339: LIST
93340: LIST
93341: LIST
93342: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
93343: LD_ADDR_VAR 0 30
93347: PUSH
93348: LD_INT 4
93350: PUSH
93351: LD_INT 4
93353: PUSH
93354: EMPTY
93355: LIST
93356: LIST
93357: PUSH
93358: LD_INT 4
93360: PUSH
93361: LD_INT 3
93363: PUSH
93364: EMPTY
93365: LIST
93366: LIST
93367: PUSH
93368: LD_INT 5
93370: PUSH
93371: LD_INT 4
93373: PUSH
93374: EMPTY
93375: LIST
93376: LIST
93377: PUSH
93378: LD_INT 5
93380: PUSH
93381: LD_INT 5
93383: PUSH
93384: EMPTY
93385: LIST
93386: LIST
93387: PUSH
93388: LD_INT 4
93390: PUSH
93391: LD_INT 5
93393: PUSH
93394: EMPTY
93395: LIST
93396: LIST
93397: PUSH
93398: LD_INT 3
93400: PUSH
93401: LD_INT 4
93403: PUSH
93404: EMPTY
93405: LIST
93406: LIST
93407: PUSH
93408: LD_INT 3
93410: PUSH
93411: LD_INT 3
93413: PUSH
93414: EMPTY
93415: LIST
93416: LIST
93417: PUSH
93418: LD_INT 5
93420: PUSH
93421: LD_INT 3
93423: PUSH
93424: EMPTY
93425: LIST
93426: LIST
93427: PUSH
93428: LD_INT 3
93430: PUSH
93431: LD_INT 5
93433: PUSH
93434: EMPTY
93435: LIST
93436: LIST
93437: PUSH
93438: LD_INT 0
93440: PUSH
93441: LD_INT 3
93443: PUSH
93444: EMPTY
93445: LIST
93446: LIST
93447: PUSH
93448: LD_INT 0
93450: PUSH
93451: LD_INT 2
93453: PUSH
93454: EMPTY
93455: LIST
93456: LIST
93457: PUSH
93458: LD_INT 1
93460: PUSH
93461: LD_INT 3
93463: PUSH
93464: EMPTY
93465: LIST
93466: LIST
93467: PUSH
93468: LD_INT 1
93470: PUSH
93471: LD_INT 4
93473: PUSH
93474: EMPTY
93475: LIST
93476: LIST
93477: PUSH
93478: LD_INT 0
93480: PUSH
93481: LD_INT 4
93483: PUSH
93484: EMPTY
93485: LIST
93486: LIST
93487: PUSH
93488: LD_INT 1
93490: NEG
93491: PUSH
93492: LD_INT 3
93494: PUSH
93495: EMPTY
93496: LIST
93497: LIST
93498: PUSH
93499: LD_INT 1
93501: NEG
93502: PUSH
93503: LD_INT 2
93505: PUSH
93506: EMPTY
93507: LIST
93508: LIST
93509: PUSH
93510: LD_INT 2
93512: PUSH
93513: LD_INT 4
93515: PUSH
93516: EMPTY
93517: LIST
93518: LIST
93519: PUSH
93520: LD_INT 2
93522: NEG
93523: PUSH
93524: LD_INT 2
93526: PUSH
93527: EMPTY
93528: LIST
93529: LIST
93530: PUSH
93531: LD_INT 4
93533: NEG
93534: PUSH
93535: LD_INT 0
93537: PUSH
93538: EMPTY
93539: LIST
93540: LIST
93541: PUSH
93542: LD_INT 4
93544: NEG
93545: PUSH
93546: LD_INT 1
93548: NEG
93549: PUSH
93550: EMPTY
93551: LIST
93552: LIST
93553: PUSH
93554: LD_INT 3
93556: NEG
93557: PUSH
93558: LD_INT 0
93560: PUSH
93561: EMPTY
93562: LIST
93563: LIST
93564: PUSH
93565: LD_INT 3
93567: NEG
93568: PUSH
93569: LD_INT 1
93571: PUSH
93572: EMPTY
93573: LIST
93574: LIST
93575: PUSH
93576: LD_INT 4
93578: NEG
93579: PUSH
93580: LD_INT 1
93582: PUSH
93583: EMPTY
93584: LIST
93585: LIST
93586: PUSH
93587: LD_INT 5
93589: NEG
93590: PUSH
93591: LD_INT 0
93593: PUSH
93594: EMPTY
93595: LIST
93596: LIST
93597: PUSH
93598: LD_INT 5
93600: NEG
93601: PUSH
93602: LD_INT 1
93604: NEG
93605: PUSH
93606: EMPTY
93607: LIST
93608: LIST
93609: PUSH
93610: LD_INT 5
93612: NEG
93613: PUSH
93614: LD_INT 2
93616: NEG
93617: PUSH
93618: EMPTY
93619: LIST
93620: LIST
93621: PUSH
93622: LD_INT 3
93624: NEG
93625: PUSH
93626: LD_INT 2
93628: PUSH
93629: EMPTY
93630: LIST
93631: LIST
93632: PUSH
93633: LD_INT 3
93635: NEG
93636: PUSH
93637: LD_INT 3
93639: NEG
93640: PUSH
93641: EMPTY
93642: LIST
93643: LIST
93644: PUSH
93645: LD_INT 3
93647: NEG
93648: PUSH
93649: LD_INT 4
93651: NEG
93652: PUSH
93653: EMPTY
93654: LIST
93655: LIST
93656: PUSH
93657: LD_INT 2
93659: NEG
93660: PUSH
93661: LD_INT 3
93663: NEG
93664: PUSH
93665: EMPTY
93666: LIST
93667: LIST
93668: PUSH
93669: LD_INT 2
93671: NEG
93672: PUSH
93673: LD_INT 2
93675: NEG
93676: PUSH
93677: EMPTY
93678: LIST
93679: LIST
93680: PUSH
93681: LD_INT 3
93683: NEG
93684: PUSH
93685: LD_INT 2
93687: NEG
93688: PUSH
93689: EMPTY
93690: LIST
93691: LIST
93692: PUSH
93693: LD_INT 4
93695: NEG
93696: PUSH
93697: LD_INT 3
93699: NEG
93700: PUSH
93701: EMPTY
93702: LIST
93703: LIST
93704: PUSH
93705: LD_INT 4
93707: NEG
93708: PUSH
93709: LD_INT 4
93711: NEG
93712: PUSH
93713: EMPTY
93714: LIST
93715: LIST
93716: PUSH
93717: LD_INT 2
93719: NEG
93720: PUSH
93721: LD_INT 4
93723: NEG
93724: PUSH
93725: EMPTY
93726: LIST
93727: LIST
93728: PUSH
93729: LD_INT 4
93731: NEG
93732: PUSH
93733: LD_INT 2
93735: NEG
93736: PUSH
93737: EMPTY
93738: LIST
93739: LIST
93740: PUSH
93741: LD_INT 0
93743: PUSH
93744: LD_INT 4
93746: NEG
93747: PUSH
93748: EMPTY
93749: LIST
93750: LIST
93751: PUSH
93752: LD_INT 0
93754: PUSH
93755: LD_INT 5
93757: NEG
93758: PUSH
93759: EMPTY
93760: LIST
93761: LIST
93762: PUSH
93763: LD_INT 1
93765: PUSH
93766: LD_INT 4
93768: NEG
93769: PUSH
93770: EMPTY
93771: LIST
93772: LIST
93773: PUSH
93774: LD_INT 1
93776: PUSH
93777: LD_INT 3
93779: NEG
93780: PUSH
93781: EMPTY
93782: LIST
93783: LIST
93784: PUSH
93785: LD_INT 0
93787: PUSH
93788: LD_INT 3
93790: NEG
93791: PUSH
93792: EMPTY
93793: LIST
93794: LIST
93795: PUSH
93796: LD_INT 1
93798: NEG
93799: PUSH
93800: LD_INT 4
93802: NEG
93803: PUSH
93804: EMPTY
93805: LIST
93806: LIST
93807: PUSH
93808: LD_INT 1
93810: NEG
93811: PUSH
93812: LD_INT 5
93814: NEG
93815: PUSH
93816: EMPTY
93817: LIST
93818: LIST
93819: PUSH
93820: LD_INT 2
93822: PUSH
93823: LD_INT 3
93825: NEG
93826: PUSH
93827: EMPTY
93828: LIST
93829: LIST
93830: PUSH
93831: LD_INT 2
93833: NEG
93834: PUSH
93835: LD_INT 5
93837: NEG
93838: PUSH
93839: EMPTY
93840: LIST
93841: LIST
93842: PUSH
93843: EMPTY
93844: LIST
93845: LIST
93846: LIST
93847: LIST
93848: LIST
93849: LIST
93850: LIST
93851: LIST
93852: LIST
93853: LIST
93854: LIST
93855: LIST
93856: LIST
93857: LIST
93858: LIST
93859: LIST
93860: LIST
93861: LIST
93862: LIST
93863: LIST
93864: LIST
93865: LIST
93866: LIST
93867: LIST
93868: LIST
93869: LIST
93870: LIST
93871: LIST
93872: LIST
93873: LIST
93874: LIST
93875: LIST
93876: LIST
93877: LIST
93878: LIST
93879: LIST
93880: LIST
93881: LIST
93882: LIST
93883: LIST
93884: LIST
93885: LIST
93886: LIST
93887: LIST
93888: LIST
93889: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
93890: LD_ADDR_VAR 0 31
93894: PUSH
93895: LD_INT 0
93897: PUSH
93898: LD_INT 4
93900: PUSH
93901: EMPTY
93902: LIST
93903: LIST
93904: PUSH
93905: LD_INT 0
93907: PUSH
93908: LD_INT 3
93910: PUSH
93911: EMPTY
93912: LIST
93913: LIST
93914: PUSH
93915: LD_INT 1
93917: PUSH
93918: LD_INT 4
93920: PUSH
93921: EMPTY
93922: LIST
93923: LIST
93924: PUSH
93925: LD_INT 1
93927: PUSH
93928: LD_INT 5
93930: PUSH
93931: EMPTY
93932: LIST
93933: LIST
93934: PUSH
93935: LD_INT 0
93937: PUSH
93938: LD_INT 5
93940: PUSH
93941: EMPTY
93942: LIST
93943: LIST
93944: PUSH
93945: LD_INT 1
93947: NEG
93948: PUSH
93949: LD_INT 4
93951: PUSH
93952: EMPTY
93953: LIST
93954: LIST
93955: PUSH
93956: LD_INT 1
93958: NEG
93959: PUSH
93960: LD_INT 3
93962: PUSH
93963: EMPTY
93964: LIST
93965: LIST
93966: PUSH
93967: LD_INT 2
93969: PUSH
93970: LD_INT 5
93972: PUSH
93973: EMPTY
93974: LIST
93975: LIST
93976: PUSH
93977: LD_INT 2
93979: NEG
93980: PUSH
93981: LD_INT 3
93983: PUSH
93984: EMPTY
93985: LIST
93986: LIST
93987: PUSH
93988: LD_INT 3
93990: NEG
93991: PUSH
93992: LD_INT 0
93994: PUSH
93995: EMPTY
93996: LIST
93997: LIST
93998: PUSH
93999: LD_INT 3
94001: NEG
94002: PUSH
94003: LD_INT 1
94005: NEG
94006: PUSH
94007: EMPTY
94008: LIST
94009: LIST
94010: PUSH
94011: LD_INT 2
94013: NEG
94014: PUSH
94015: LD_INT 0
94017: PUSH
94018: EMPTY
94019: LIST
94020: LIST
94021: PUSH
94022: LD_INT 2
94024: NEG
94025: PUSH
94026: LD_INT 1
94028: PUSH
94029: EMPTY
94030: LIST
94031: LIST
94032: PUSH
94033: LD_INT 3
94035: NEG
94036: PUSH
94037: LD_INT 1
94039: PUSH
94040: EMPTY
94041: LIST
94042: LIST
94043: PUSH
94044: LD_INT 4
94046: NEG
94047: PUSH
94048: LD_INT 0
94050: PUSH
94051: EMPTY
94052: LIST
94053: LIST
94054: PUSH
94055: LD_INT 4
94057: NEG
94058: PUSH
94059: LD_INT 1
94061: NEG
94062: PUSH
94063: EMPTY
94064: LIST
94065: LIST
94066: PUSH
94067: LD_INT 4
94069: NEG
94070: PUSH
94071: LD_INT 2
94073: NEG
94074: PUSH
94075: EMPTY
94076: LIST
94077: LIST
94078: PUSH
94079: LD_INT 2
94081: NEG
94082: PUSH
94083: LD_INT 2
94085: PUSH
94086: EMPTY
94087: LIST
94088: LIST
94089: PUSH
94090: LD_INT 4
94092: NEG
94093: PUSH
94094: LD_INT 4
94096: NEG
94097: PUSH
94098: EMPTY
94099: LIST
94100: LIST
94101: PUSH
94102: LD_INT 4
94104: NEG
94105: PUSH
94106: LD_INT 5
94108: NEG
94109: PUSH
94110: EMPTY
94111: LIST
94112: LIST
94113: PUSH
94114: LD_INT 3
94116: NEG
94117: PUSH
94118: LD_INT 4
94120: NEG
94121: PUSH
94122: EMPTY
94123: LIST
94124: LIST
94125: PUSH
94126: LD_INT 3
94128: NEG
94129: PUSH
94130: LD_INT 3
94132: NEG
94133: PUSH
94134: EMPTY
94135: LIST
94136: LIST
94137: PUSH
94138: LD_INT 4
94140: NEG
94141: PUSH
94142: LD_INT 3
94144: NEG
94145: PUSH
94146: EMPTY
94147: LIST
94148: LIST
94149: PUSH
94150: LD_INT 5
94152: NEG
94153: PUSH
94154: LD_INT 4
94156: NEG
94157: PUSH
94158: EMPTY
94159: LIST
94160: LIST
94161: PUSH
94162: LD_INT 5
94164: NEG
94165: PUSH
94166: LD_INT 5
94168: NEG
94169: PUSH
94170: EMPTY
94171: LIST
94172: LIST
94173: PUSH
94174: LD_INT 3
94176: NEG
94177: PUSH
94178: LD_INT 5
94180: NEG
94181: PUSH
94182: EMPTY
94183: LIST
94184: LIST
94185: PUSH
94186: LD_INT 5
94188: NEG
94189: PUSH
94190: LD_INT 3
94192: NEG
94193: PUSH
94194: EMPTY
94195: LIST
94196: LIST
94197: PUSH
94198: LD_INT 0
94200: PUSH
94201: LD_INT 3
94203: NEG
94204: PUSH
94205: EMPTY
94206: LIST
94207: LIST
94208: PUSH
94209: LD_INT 0
94211: PUSH
94212: LD_INT 4
94214: NEG
94215: PUSH
94216: EMPTY
94217: LIST
94218: LIST
94219: PUSH
94220: LD_INT 1
94222: PUSH
94223: LD_INT 3
94225: NEG
94226: PUSH
94227: EMPTY
94228: LIST
94229: LIST
94230: PUSH
94231: LD_INT 1
94233: PUSH
94234: LD_INT 2
94236: NEG
94237: PUSH
94238: EMPTY
94239: LIST
94240: LIST
94241: PUSH
94242: LD_INT 0
94244: PUSH
94245: LD_INT 2
94247: NEG
94248: PUSH
94249: EMPTY
94250: LIST
94251: LIST
94252: PUSH
94253: LD_INT 1
94255: NEG
94256: PUSH
94257: LD_INT 3
94259: NEG
94260: PUSH
94261: EMPTY
94262: LIST
94263: LIST
94264: PUSH
94265: LD_INT 1
94267: NEG
94268: PUSH
94269: LD_INT 4
94271: NEG
94272: PUSH
94273: EMPTY
94274: LIST
94275: LIST
94276: PUSH
94277: LD_INT 2
94279: PUSH
94280: LD_INT 2
94282: NEG
94283: PUSH
94284: EMPTY
94285: LIST
94286: LIST
94287: PUSH
94288: LD_INT 2
94290: NEG
94291: PUSH
94292: LD_INT 4
94294: NEG
94295: PUSH
94296: EMPTY
94297: LIST
94298: LIST
94299: PUSH
94300: LD_INT 4
94302: PUSH
94303: LD_INT 0
94305: PUSH
94306: EMPTY
94307: LIST
94308: LIST
94309: PUSH
94310: LD_INT 4
94312: PUSH
94313: LD_INT 1
94315: NEG
94316: PUSH
94317: EMPTY
94318: LIST
94319: LIST
94320: PUSH
94321: LD_INT 5
94323: PUSH
94324: LD_INT 0
94326: PUSH
94327: EMPTY
94328: LIST
94329: LIST
94330: PUSH
94331: LD_INT 5
94333: PUSH
94334: LD_INT 1
94336: PUSH
94337: EMPTY
94338: LIST
94339: LIST
94340: PUSH
94341: LD_INT 4
94343: PUSH
94344: LD_INT 1
94346: PUSH
94347: EMPTY
94348: LIST
94349: LIST
94350: PUSH
94351: LD_INT 3
94353: PUSH
94354: LD_INT 0
94356: PUSH
94357: EMPTY
94358: LIST
94359: LIST
94360: PUSH
94361: LD_INT 3
94363: PUSH
94364: LD_INT 1
94366: NEG
94367: PUSH
94368: EMPTY
94369: LIST
94370: LIST
94371: PUSH
94372: LD_INT 3
94374: PUSH
94375: LD_INT 2
94377: NEG
94378: PUSH
94379: EMPTY
94380: LIST
94381: LIST
94382: PUSH
94383: LD_INT 5
94385: PUSH
94386: LD_INT 2
94388: PUSH
94389: EMPTY
94390: LIST
94391: LIST
94392: PUSH
94393: EMPTY
94394: LIST
94395: LIST
94396: LIST
94397: LIST
94398: LIST
94399: LIST
94400: LIST
94401: LIST
94402: LIST
94403: LIST
94404: LIST
94405: LIST
94406: LIST
94407: LIST
94408: LIST
94409: LIST
94410: LIST
94411: LIST
94412: LIST
94413: LIST
94414: LIST
94415: LIST
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: LIST
94423: LIST
94424: LIST
94425: LIST
94426: LIST
94427: LIST
94428: LIST
94429: LIST
94430: LIST
94431: LIST
94432: LIST
94433: LIST
94434: LIST
94435: LIST
94436: LIST
94437: LIST
94438: LIST
94439: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
94440: LD_ADDR_VAR 0 32
94444: PUSH
94445: LD_INT 4
94447: NEG
94448: PUSH
94449: LD_INT 0
94451: PUSH
94452: EMPTY
94453: LIST
94454: LIST
94455: PUSH
94456: LD_INT 4
94458: NEG
94459: PUSH
94460: LD_INT 1
94462: NEG
94463: PUSH
94464: EMPTY
94465: LIST
94466: LIST
94467: PUSH
94468: LD_INT 3
94470: NEG
94471: PUSH
94472: LD_INT 0
94474: PUSH
94475: EMPTY
94476: LIST
94477: LIST
94478: PUSH
94479: LD_INT 3
94481: NEG
94482: PUSH
94483: LD_INT 1
94485: PUSH
94486: EMPTY
94487: LIST
94488: LIST
94489: PUSH
94490: LD_INT 4
94492: NEG
94493: PUSH
94494: LD_INT 1
94496: PUSH
94497: EMPTY
94498: LIST
94499: LIST
94500: PUSH
94501: LD_INT 5
94503: NEG
94504: PUSH
94505: LD_INT 0
94507: PUSH
94508: EMPTY
94509: LIST
94510: LIST
94511: PUSH
94512: LD_INT 5
94514: NEG
94515: PUSH
94516: LD_INT 1
94518: NEG
94519: PUSH
94520: EMPTY
94521: LIST
94522: LIST
94523: PUSH
94524: LD_INT 5
94526: NEG
94527: PUSH
94528: LD_INT 2
94530: NEG
94531: PUSH
94532: EMPTY
94533: LIST
94534: LIST
94535: PUSH
94536: LD_INT 3
94538: NEG
94539: PUSH
94540: LD_INT 2
94542: PUSH
94543: EMPTY
94544: LIST
94545: LIST
94546: PUSH
94547: LD_INT 3
94549: NEG
94550: PUSH
94551: LD_INT 3
94553: NEG
94554: PUSH
94555: EMPTY
94556: LIST
94557: LIST
94558: PUSH
94559: LD_INT 3
94561: NEG
94562: PUSH
94563: LD_INT 4
94565: NEG
94566: PUSH
94567: EMPTY
94568: LIST
94569: LIST
94570: PUSH
94571: LD_INT 2
94573: NEG
94574: PUSH
94575: LD_INT 3
94577: NEG
94578: PUSH
94579: EMPTY
94580: LIST
94581: LIST
94582: PUSH
94583: LD_INT 2
94585: NEG
94586: PUSH
94587: LD_INT 2
94589: NEG
94590: PUSH
94591: EMPTY
94592: LIST
94593: LIST
94594: PUSH
94595: LD_INT 3
94597: NEG
94598: PUSH
94599: LD_INT 2
94601: NEG
94602: PUSH
94603: EMPTY
94604: LIST
94605: LIST
94606: PUSH
94607: LD_INT 4
94609: NEG
94610: PUSH
94611: LD_INT 3
94613: NEG
94614: PUSH
94615: EMPTY
94616: LIST
94617: LIST
94618: PUSH
94619: LD_INT 4
94621: NEG
94622: PUSH
94623: LD_INT 4
94625: NEG
94626: PUSH
94627: EMPTY
94628: LIST
94629: LIST
94630: PUSH
94631: LD_INT 2
94633: NEG
94634: PUSH
94635: LD_INT 4
94637: NEG
94638: PUSH
94639: EMPTY
94640: LIST
94641: LIST
94642: PUSH
94643: LD_INT 4
94645: NEG
94646: PUSH
94647: LD_INT 2
94649: NEG
94650: PUSH
94651: EMPTY
94652: LIST
94653: LIST
94654: PUSH
94655: LD_INT 0
94657: PUSH
94658: LD_INT 4
94660: NEG
94661: PUSH
94662: EMPTY
94663: LIST
94664: LIST
94665: PUSH
94666: LD_INT 0
94668: PUSH
94669: LD_INT 5
94671: NEG
94672: PUSH
94673: EMPTY
94674: LIST
94675: LIST
94676: PUSH
94677: LD_INT 1
94679: PUSH
94680: LD_INT 4
94682: NEG
94683: PUSH
94684: EMPTY
94685: LIST
94686: LIST
94687: PUSH
94688: LD_INT 1
94690: PUSH
94691: LD_INT 3
94693: NEG
94694: PUSH
94695: EMPTY
94696: LIST
94697: LIST
94698: PUSH
94699: LD_INT 0
94701: PUSH
94702: LD_INT 3
94704: NEG
94705: PUSH
94706: EMPTY
94707: LIST
94708: LIST
94709: PUSH
94710: LD_INT 1
94712: NEG
94713: PUSH
94714: LD_INT 4
94716: NEG
94717: PUSH
94718: EMPTY
94719: LIST
94720: LIST
94721: PUSH
94722: LD_INT 1
94724: NEG
94725: PUSH
94726: LD_INT 5
94728: NEG
94729: PUSH
94730: EMPTY
94731: LIST
94732: LIST
94733: PUSH
94734: LD_INT 2
94736: PUSH
94737: LD_INT 3
94739: NEG
94740: PUSH
94741: EMPTY
94742: LIST
94743: LIST
94744: PUSH
94745: LD_INT 2
94747: NEG
94748: PUSH
94749: LD_INT 5
94751: NEG
94752: PUSH
94753: EMPTY
94754: LIST
94755: LIST
94756: PUSH
94757: LD_INT 3
94759: PUSH
94760: LD_INT 0
94762: PUSH
94763: EMPTY
94764: LIST
94765: LIST
94766: PUSH
94767: LD_INT 3
94769: PUSH
94770: LD_INT 1
94772: NEG
94773: PUSH
94774: EMPTY
94775: LIST
94776: LIST
94777: PUSH
94778: LD_INT 4
94780: PUSH
94781: LD_INT 0
94783: PUSH
94784: EMPTY
94785: LIST
94786: LIST
94787: PUSH
94788: LD_INT 4
94790: PUSH
94791: LD_INT 1
94793: PUSH
94794: EMPTY
94795: LIST
94796: LIST
94797: PUSH
94798: LD_INT 3
94800: PUSH
94801: LD_INT 1
94803: PUSH
94804: EMPTY
94805: LIST
94806: LIST
94807: PUSH
94808: LD_INT 2
94810: PUSH
94811: LD_INT 0
94813: PUSH
94814: EMPTY
94815: LIST
94816: LIST
94817: PUSH
94818: LD_INT 2
94820: PUSH
94821: LD_INT 1
94823: NEG
94824: PUSH
94825: EMPTY
94826: LIST
94827: LIST
94828: PUSH
94829: LD_INT 2
94831: PUSH
94832: LD_INT 2
94834: NEG
94835: PUSH
94836: EMPTY
94837: LIST
94838: LIST
94839: PUSH
94840: LD_INT 4
94842: PUSH
94843: LD_INT 2
94845: PUSH
94846: EMPTY
94847: LIST
94848: LIST
94849: PUSH
94850: LD_INT 4
94852: PUSH
94853: LD_INT 4
94855: PUSH
94856: EMPTY
94857: LIST
94858: LIST
94859: PUSH
94860: LD_INT 4
94862: PUSH
94863: LD_INT 3
94865: PUSH
94866: EMPTY
94867: LIST
94868: LIST
94869: PUSH
94870: LD_INT 5
94872: PUSH
94873: LD_INT 4
94875: PUSH
94876: EMPTY
94877: LIST
94878: LIST
94879: PUSH
94880: LD_INT 5
94882: PUSH
94883: LD_INT 5
94885: PUSH
94886: EMPTY
94887: LIST
94888: LIST
94889: PUSH
94890: LD_INT 4
94892: PUSH
94893: LD_INT 5
94895: PUSH
94896: EMPTY
94897: LIST
94898: LIST
94899: PUSH
94900: LD_INT 3
94902: PUSH
94903: LD_INT 4
94905: PUSH
94906: EMPTY
94907: LIST
94908: LIST
94909: PUSH
94910: LD_INT 3
94912: PUSH
94913: LD_INT 3
94915: PUSH
94916: EMPTY
94917: LIST
94918: LIST
94919: PUSH
94920: LD_INT 5
94922: PUSH
94923: LD_INT 3
94925: PUSH
94926: EMPTY
94927: LIST
94928: LIST
94929: PUSH
94930: LD_INT 3
94932: PUSH
94933: LD_INT 5
94935: PUSH
94936: EMPTY
94937: LIST
94938: LIST
94939: PUSH
94940: EMPTY
94941: LIST
94942: LIST
94943: LIST
94944: LIST
94945: LIST
94946: LIST
94947: LIST
94948: LIST
94949: LIST
94950: LIST
94951: LIST
94952: LIST
94953: LIST
94954: LIST
94955: LIST
94956: LIST
94957: LIST
94958: LIST
94959: LIST
94960: LIST
94961: LIST
94962: LIST
94963: LIST
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: LIST
94970: LIST
94971: LIST
94972: LIST
94973: LIST
94974: LIST
94975: LIST
94976: LIST
94977: LIST
94978: LIST
94979: LIST
94980: LIST
94981: LIST
94982: LIST
94983: LIST
94984: LIST
94985: LIST
94986: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
94987: LD_ADDR_VAR 0 33
94991: PUSH
94992: LD_INT 4
94994: NEG
94995: PUSH
94996: LD_INT 4
94998: NEG
94999: PUSH
95000: EMPTY
95001: LIST
95002: LIST
95003: PUSH
95004: LD_INT 4
95006: NEG
95007: PUSH
95008: LD_INT 5
95010: NEG
95011: PUSH
95012: EMPTY
95013: LIST
95014: LIST
95015: PUSH
95016: LD_INT 3
95018: NEG
95019: PUSH
95020: LD_INT 4
95022: NEG
95023: PUSH
95024: EMPTY
95025: LIST
95026: LIST
95027: PUSH
95028: LD_INT 3
95030: NEG
95031: PUSH
95032: LD_INT 3
95034: NEG
95035: PUSH
95036: EMPTY
95037: LIST
95038: LIST
95039: PUSH
95040: LD_INT 4
95042: NEG
95043: PUSH
95044: LD_INT 3
95046: NEG
95047: PUSH
95048: EMPTY
95049: LIST
95050: LIST
95051: PUSH
95052: LD_INT 5
95054: NEG
95055: PUSH
95056: LD_INT 4
95058: NEG
95059: PUSH
95060: EMPTY
95061: LIST
95062: LIST
95063: PUSH
95064: LD_INT 5
95066: NEG
95067: PUSH
95068: LD_INT 5
95070: NEG
95071: PUSH
95072: EMPTY
95073: LIST
95074: LIST
95075: PUSH
95076: LD_INT 3
95078: NEG
95079: PUSH
95080: LD_INT 5
95082: NEG
95083: PUSH
95084: EMPTY
95085: LIST
95086: LIST
95087: PUSH
95088: LD_INT 5
95090: NEG
95091: PUSH
95092: LD_INT 3
95094: NEG
95095: PUSH
95096: EMPTY
95097: LIST
95098: LIST
95099: PUSH
95100: LD_INT 0
95102: PUSH
95103: LD_INT 3
95105: NEG
95106: PUSH
95107: EMPTY
95108: LIST
95109: LIST
95110: PUSH
95111: LD_INT 0
95113: PUSH
95114: LD_INT 4
95116: NEG
95117: PUSH
95118: EMPTY
95119: LIST
95120: LIST
95121: PUSH
95122: LD_INT 1
95124: PUSH
95125: LD_INT 3
95127: NEG
95128: PUSH
95129: EMPTY
95130: LIST
95131: LIST
95132: PUSH
95133: LD_INT 1
95135: PUSH
95136: LD_INT 2
95138: NEG
95139: PUSH
95140: EMPTY
95141: LIST
95142: LIST
95143: PUSH
95144: LD_INT 0
95146: PUSH
95147: LD_INT 2
95149: NEG
95150: PUSH
95151: EMPTY
95152: LIST
95153: LIST
95154: PUSH
95155: LD_INT 1
95157: NEG
95158: PUSH
95159: LD_INT 3
95161: NEG
95162: PUSH
95163: EMPTY
95164: LIST
95165: LIST
95166: PUSH
95167: LD_INT 1
95169: NEG
95170: PUSH
95171: LD_INT 4
95173: NEG
95174: PUSH
95175: EMPTY
95176: LIST
95177: LIST
95178: PUSH
95179: LD_INT 2
95181: PUSH
95182: LD_INT 2
95184: NEG
95185: PUSH
95186: EMPTY
95187: LIST
95188: LIST
95189: PUSH
95190: LD_INT 2
95192: NEG
95193: PUSH
95194: LD_INT 4
95196: NEG
95197: PUSH
95198: EMPTY
95199: LIST
95200: LIST
95201: PUSH
95202: LD_INT 4
95204: PUSH
95205: LD_INT 0
95207: PUSH
95208: EMPTY
95209: LIST
95210: LIST
95211: PUSH
95212: LD_INT 4
95214: PUSH
95215: LD_INT 1
95217: NEG
95218: PUSH
95219: EMPTY
95220: LIST
95221: LIST
95222: PUSH
95223: LD_INT 5
95225: PUSH
95226: LD_INT 0
95228: PUSH
95229: EMPTY
95230: LIST
95231: LIST
95232: PUSH
95233: LD_INT 5
95235: PUSH
95236: LD_INT 1
95238: PUSH
95239: EMPTY
95240: LIST
95241: LIST
95242: PUSH
95243: LD_INT 4
95245: PUSH
95246: LD_INT 1
95248: PUSH
95249: EMPTY
95250: LIST
95251: LIST
95252: PUSH
95253: LD_INT 3
95255: PUSH
95256: LD_INT 0
95258: PUSH
95259: EMPTY
95260: LIST
95261: LIST
95262: PUSH
95263: LD_INT 3
95265: PUSH
95266: LD_INT 1
95268: NEG
95269: PUSH
95270: EMPTY
95271: LIST
95272: LIST
95273: PUSH
95274: LD_INT 3
95276: PUSH
95277: LD_INT 2
95279: NEG
95280: PUSH
95281: EMPTY
95282: LIST
95283: LIST
95284: PUSH
95285: LD_INT 5
95287: PUSH
95288: LD_INT 2
95290: PUSH
95291: EMPTY
95292: LIST
95293: LIST
95294: PUSH
95295: LD_INT 3
95297: PUSH
95298: LD_INT 3
95300: PUSH
95301: EMPTY
95302: LIST
95303: LIST
95304: PUSH
95305: LD_INT 3
95307: PUSH
95308: LD_INT 2
95310: PUSH
95311: EMPTY
95312: LIST
95313: LIST
95314: PUSH
95315: LD_INT 4
95317: PUSH
95318: LD_INT 3
95320: PUSH
95321: EMPTY
95322: LIST
95323: LIST
95324: PUSH
95325: LD_INT 4
95327: PUSH
95328: LD_INT 4
95330: PUSH
95331: EMPTY
95332: LIST
95333: LIST
95334: PUSH
95335: LD_INT 3
95337: PUSH
95338: LD_INT 4
95340: PUSH
95341: EMPTY
95342: LIST
95343: LIST
95344: PUSH
95345: LD_INT 2
95347: PUSH
95348: LD_INT 3
95350: PUSH
95351: EMPTY
95352: LIST
95353: LIST
95354: PUSH
95355: LD_INT 2
95357: PUSH
95358: LD_INT 2
95360: PUSH
95361: EMPTY
95362: LIST
95363: LIST
95364: PUSH
95365: LD_INT 4
95367: PUSH
95368: LD_INT 2
95370: PUSH
95371: EMPTY
95372: LIST
95373: LIST
95374: PUSH
95375: LD_INT 2
95377: PUSH
95378: LD_INT 4
95380: PUSH
95381: EMPTY
95382: LIST
95383: LIST
95384: PUSH
95385: LD_INT 0
95387: PUSH
95388: LD_INT 4
95390: PUSH
95391: EMPTY
95392: LIST
95393: LIST
95394: PUSH
95395: LD_INT 0
95397: PUSH
95398: LD_INT 3
95400: PUSH
95401: EMPTY
95402: LIST
95403: LIST
95404: PUSH
95405: LD_INT 1
95407: PUSH
95408: LD_INT 4
95410: PUSH
95411: EMPTY
95412: LIST
95413: LIST
95414: PUSH
95415: LD_INT 1
95417: PUSH
95418: LD_INT 5
95420: PUSH
95421: EMPTY
95422: LIST
95423: LIST
95424: PUSH
95425: LD_INT 0
95427: PUSH
95428: LD_INT 5
95430: PUSH
95431: EMPTY
95432: LIST
95433: LIST
95434: PUSH
95435: LD_INT 1
95437: NEG
95438: PUSH
95439: LD_INT 4
95441: PUSH
95442: EMPTY
95443: LIST
95444: LIST
95445: PUSH
95446: LD_INT 1
95448: NEG
95449: PUSH
95450: LD_INT 3
95452: PUSH
95453: EMPTY
95454: LIST
95455: LIST
95456: PUSH
95457: LD_INT 2
95459: PUSH
95460: LD_INT 5
95462: PUSH
95463: EMPTY
95464: LIST
95465: LIST
95466: PUSH
95467: LD_INT 2
95469: NEG
95470: PUSH
95471: LD_INT 3
95473: PUSH
95474: EMPTY
95475: LIST
95476: LIST
95477: PUSH
95478: EMPTY
95479: LIST
95480: LIST
95481: LIST
95482: LIST
95483: LIST
95484: LIST
95485: LIST
95486: LIST
95487: LIST
95488: LIST
95489: LIST
95490: LIST
95491: LIST
95492: LIST
95493: LIST
95494: LIST
95495: LIST
95496: LIST
95497: LIST
95498: LIST
95499: LIST
95500: LIST
95501: LIST
95502: LIST
95503: LIST
95504: LIST
95505: LIST
95506: LIST
95507: LIST
95508: LIST
95509: LIST
95510: LIST
95511: LIST
95512: LIST
95513: LIST
95514: LIST
95515: LIST
95516: LIST
95517: LIST
95518: LIST
95519: LIST
95520: LIST
95521: LIST
95522: LIST
95523: LIST
95524: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
95525: LD_ADDR_VAR 0 34
95529: PUSH
95530: LD_INT 0
95532: PUSH
95533: LD_INT 4
95535: NEG
95536: PUSH
95537: EMPTY
95538: LIST
95539: LIST
95540: PUSH
95541: LD_INT 0
95543: PUSH
95544: LD_INT 5
95546: NEG
95547: PUSH
95548: EMPTY
95549: LIST
95550: LIST
95551: PUSH
95552: LD_INT 1
95554: PUSH
95555: LD_INT 4
95557: NEG
95558: PUSH
95559: EMPTY
95560: LIST
95561: LIST
95562: PUSH
95563: LD_INT 1
95565: PUSH
95566: LD_INT 3
95568: NEG
95569: PUSH
95570: EMPTY
95571: LIST
95572: LIST
95573: PUSH
95574: LD_INT 0
95576: PUSH
95577: LD_INT 3
95579: NEG
95580: PUSH
95581: EMPTY
95582: LIST
95583: LIST
95584: PUSH
95585: LD_INT 1
95587: NEG
95588: PUSH
95589: LD_INT 4
95591: NEG
95592: PUSH
95593: EMPTY
95594: LIST
95595: LIST
95596: PUSH
95597: LD_INT 1
95599: NEG
95600: PUSH
95601: LD_INT 5
95603: NEG
95604: PUSH
95605: EMPTY
95606: LIST
95607: LIST
95608: PUSH
95609: LD_INT 2
95611: PUSH
95612: LD_INT 3
95614: NEG
95615: PUSH
95616: EMPTY
95617: LIST
95618: LIST
95619: PUSH
95620: LD_INT 2
95622: NEG
95623: PUSH
95624: LD_INT 5
95626: NEG
95627: PUSH
95628: EMPTY
95629: LIST
95630: LIST
95631: PUSH
95632: LD_INT 3
95634: PUSH
95635: LD_INT 0
95637: PUSH
95638: EMPTY
95639: LIST
95640: LIST
95641: PUSH
95642: LD_INT 3
95644: PUSH
95645: LD_INT 1
95647: NEG
95648: PUSH
95649: EMPTY
95650: LIST
95651: LIST
95652: PUSH
95653: LD_INT 4
95655: PUSH
95656: LD_INT 0
95658: PUSH
95659: EMPTY
95660: LIST
95661: LIST
95662: PUSH
95663: LD_INT 4
95665: PUSH
95666: LD_INT 1
95668: PUSH
95669: EMPTY
95670: LIST
95671: LIST
95672: PUSH
95673: LD_INT 3
95675: PUSH
95676: LD_INT 1
95678: PUSH
95679: EMPTY
95680: LIST
95681: LIST
95682: PUSH
95683: LD_INT 2
95685: PUSH
95686: LD_INT 0
95688: PUSH
95689: EMPTY
95690: LIST
95691: LIST
95692: PUSH
95693: LD_INT 2
95695: PUSH
95696: LD_INT 1
95698: NEG
95699: PUSH
95700: EMPTY
95701: LIST
95702: LIST
95703: PUSH
95704: LD_INT 2
95706: PUSH
95707: LD_INT 2
95709: NEG
95710: PUSH
95711: EMPTY
95712: LIST
95713: LIST
95714: PUSH
95715: LD_INT 4
95717: PUSH
95718: LD_INT 2
95720: PUSH
95721: EMPTY
95722: LIST
95723: LIST
95724: PUSH
95725: LD_INT 4
95727: PUSH
95728: LD_INT 4
95730: PUSH
95731: EMPTY
95732: LIST
95733: LIST
95734: PUSH
95735: LD_INT 4
95737: PUSH
95738: LD_INT 3
95740: PUSH
95741: EMPTY
95742: LIST
95743: LIST
95744: PUSH
95745: LD_INT 5
95747: PUSH
95748: LD_INT 4
95750: PUSH
95751: EMPTY
95752: LIST
95753: LIST
95754: PUSH
95755: LD_INT 5
95757: PUSH
95758: LD_INT 5
95760: PUSH
95761: EMPTY
95762: LIST
95763: LIST
95764: PUSH
95765: LD_INT 4
95767: PUSH
95768: LD_INT 5
95770: PUSH
95771: EMPTY
95772: LIST
95773: LIST
95774: PUSH
95775: LD_INT 3
95777: PUSH
95778: LD_INT 4
95780: PUSH
95781: EMPTY
95782: LIST
95783: LIST
95784: PUSH
95785: LD_INT 3
95787: PUSH
95788: LD_INT 3
95790: PUSH
95791: EMPTY
95792: LIST
95793: LIST
95794: PUSH
95795: LD_INT 5
95797: PUSH
95798: LD_INT 3
95800: PUSH
95801: EMPTY
95802: LIST
95803: LIST
95804: PUSH
95805: LD_INT 3
95807: PUSH
95808: LD_INT 5
95810: PUSH
95811: EMPTY
95812: LIST
95813: LIST
95814: PUSH
95815: LD_INT 0
95817: PUSH
95818: LD_INT 3
95820: PUSH
95821: EMPTY
95822: LIST
95823: LIST
95824: PUSH
95825: LD_INT 0
95827: PUSH
95828: LD_INT 2
95830: PUSH
95831: EMPTY
95832: LIST
95833: LIST
95834: PUSH
95835: LD_INT 1
95837: PUSH
95838: LD_INT 3
95840: PUSH
95841: EMPTY
95842: LIST
95843: LIST
95844: PUSH
95845: LD_INT 1
95847: PUSH
95848: LD_INT 4
95850: PUSH
95851: EMPTY
95852: LIST
95853: LIST
95854: PUSH
95855: LD_INT 0
95857: PUSH
95858: LD_INT 4
95860: PUSH
95861: EMPTY
95862: LIST
95863: LIST
95864: PUSH
95865: LD_INT 1
95867: NEG
95868: PUSH
95869: LD_INT 3
95871: PUSH
95872: EMPTY
95873: LIST
95874: LIST
95875: PUSH
95876: LD_INT 1
95878: NEG
95879: PUSH
95880: LD_INT 2
95882: PUSH
95883: EMPTY
95884: LIST
95885: LIST
95886: PUSH
95887: LD_INT 2
95889: PUSH
95890: LD_INT 4
95892: PUSH
95893: EMPTY
95894: LIST
95895: LIST
95896: PUSH
95897: LD_INT 2
95899: NEG
95900: PUSH
95901: LD_INT 2
95903: PUSH
95904: EMPTY
95905: LIST
95906: LIST
95907: PUSH
95908: LD_INT 4
95910: NEG
95911: PUSH
95912: LD_INT 0
95914: PUSH
95915: EMPTY
95916: LIST
95917: LIST
95918: PUSH
95919: LD_INT 4
95921: NEG
95922: PUSH
95923: LD_INT 1
95925: NEG
95926: PUSH
95927: EMPTY
95928: LIST
95929: LIST
95930: PUSH
95931: LD_INT 3
95933: NEG
95934: PUSH
95935: LD_INT 0
95937: PUSH
95938: EMPTY
95939: LIST
95940: LIST
95941: PUSH
95942: LD_INT 3
95944: NEG
95945: PUSH
95946: LD_INT 1
95948: PUSH
95949: EMPTY
95950: LIST
95951: LIST
95952: PUSH
95953: LD_INT 4
95955: NEG
95956: PUSH
95957: LD_INT 1
95959: PUSH
95960: EMPTY
95961: LIST
95962: LIST
95963: PUSH
95964: LD_INT 5
95966: NEG
95967: PUSH
95968: LD_INT 0
95970: PUSH
95971: EMPTY
95972: LIST
95973: LIST
95974: PUSH
95975: LD_INT 5
95977: NEG
95978: PUSH
95979: LD_INT 1
95981: NEG
95982: PUSH
95983: EMPTY
95984: LIST
95985: LIST
95986: PUSH
95987: LD_INT 5
95989: NEG
95990: PUSH
95991: LD_INT 2
95993: NEG
95994: PUSH
95995: EMPTY
95996: LIST
95997: LIST
95998: PUSH
95999: LD_INT 3
96001: NEG
96002: PUSH
96003: LD_INT 2
96005: PUSH
96006: EMPTY
96007: LIST
96008: LIST
96009: PUSH
96010: EMPTY
96011: LIST
96012: LIST
96013: LIST
96014: LIST
96015: LIST
96016: LIST
96017: LIST
96018: LIST
96019: LIST
96020: LIST
96021: LIST
96022: LIST
96023: LIST
96024: LIST
96025: LIST
96026: LIST
96027: LIST
96028: LIST
96029: LIST
96030: LIST
96031: LIST
96032: LIST
96033: LIST
96034: LIST
96035: LIST
96036: LIST
96037: LIST
96038: LIST
96039: LIST
96040: LIST
96041: LIST
96042: LIST
96043: LIST
96044: LIST
96045: LIST
96046: LIST
96047: LIST
96048: LIST
96049: LIST
96050: LIST
96051: LIST
96052: LIST
96053: LIST
96054: LIST
96055: LIST
96056: ST_TO_ADDR
// end ; end ;
96057: GO 96060
96059: POP
// case btype of b_depot , b_warehouse :
96060: LD_VAR 0 1
96064: PUSH
96065: LD_INT 0
96067: DOUBLE
96068: EQUAL
96069: IFTRUE 96079
96071: LD_INT 1
96073: DOUBLE
96074: EQUAL
96075: IFTRUE 96079
96077: GO 96280
96079: POP
// case nation of nation_american :
96080: LD_VAR 0 5
96084: PUSH
96085: LD_INT 1
96087: DOUBLE
96088: EQUAL
96089: IFTRUE 96093
96091: GO 96149
96093: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
96094: LD_ADDR_VAR 0 9
96098: PUSH
96099: LD_VAR 0 11
96103: PUSH
96104: LD_VAR 0 12
96108: PUSH
96109: LD_VAR 0 13
96113: PUSH
96114: LD_VAR 0 14
96118: PUSH
96119: LD_VAR 0 15
96123: PUSH
96124: LD_VAR 0 16
96128: PUSH
96129: EMPTY
96130: LIST
96131: LIST
96132: LIST
96133: LIST
96134: LIST
96135: LIST
96136: PUSH
96137: LD_VAR 0 4
96141: PUSH
96142: LD_INT 1
96144: PLUS
96145: ARRAY
96146: ST_TO_ADDR
96147: GO 96278
96149: LD_INT 2
96151: DOUBLE
96152: EQUAL
96153: IFTRUE 96157
96155: GO 96213
96157: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
96158: LD_ADDR_VAR 0 9
96162: PUSH
96163: LD_VAR 0 17
96167: PUSH
96168: LD_VAR 0 18
96172: PUSH
96173: LD_VAR 0 19
96177: PUSH
96178: LD_VAR 0 20
96182: PUSH
96183: LD_VAR 0 21
96187: PUSH
96188: LD_VAR 0 22
96192: PUSH
96193: EMPTY
96194: LIST
96195: LIST
96196: LIST
96197: LIST
96198: LIST
96199: LIST
96200: PUSH
96201: LD_VAR 0 4
96205: PUSH
96206: LD_INT 1
96208: PLUS
96209: ARRAY
96210: ST_TO_ADDR
96211: GO 96278
96213: LD_INT 3
96215: DOUBLE
96216: EQUAL
96217: IFTRUE 96221
96219: GO 96277
96221: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
96222: LD_ADDR_VAR 0 9
96226: PUSH
96227: LD_VAR 0 23
96231: PUSH
96232: LD_VAR 0 24
96236: PUSH
96237: LD_VAR 0 25
96241: PUSH
96242: LD_VAR 0 26
96246: PUSH
96247: LD_VAR 0 27
96251: PUSH
96252: LD_VAR 0 28
96256: PUSH
96257: EMPTY
96258: LIST
96259: LIST
96260: LIST
96261: LIST
96262: LIST
96263: LIST
96264: PUSH
96265: LD_VAR 0 4
96269: PUSH
96270: LD_INT 1
96272: PLUS
96273: ARRAY
96274: ST_TO_ADDR
96275: GO 96278
96277: POP
96278: GO 96833
96280: LD_INT 2
96282: DOUBLE
96283: EQUAL
96284: IFTRUE 96294
96286: LD_INT 3
96288: DOUBLE
96289: EQUAL
96290: IFTRUE 96294
96292: GO 96350
96294: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
96295: LD_ADDR_VAR 0 9
96299: PUSH
96300: LD_VAR 0 29
96304: PUSH
96305: LD_VAR 0 30
96309: PUSH
96310: LD_VAR 0 31
96314: PUSH
96315: LD_VAR 0 32
96319: PUSH
96320: LD_VAR 0 33
96324: PUSH
96325: LD_VAR 0 34
96329: PUSH
96330: EMPTY
96331: LIST
96332: LIST
96333: LIST
96334: LIST
96335: LIST
96336: LIST
96337: PUSH
96338: LD_VAR 0 4
96342: PUSH
96343: LD_INT 1
96345: PLUS
96346: ARRAY
96347: ST_TO_ADDR
96348: GO 96833
96350: LD_INT 16
96352: DOUBLE
96353: EQUAL
96354: IFTRUE 96412
96356: LD_INT 17
96358: DOUBLE
96359: EQUAL
96360: IFTRUE 96412
96362: LD_INT 18
96364: DOUBLE
96365: EQUAL
96366: IFTRUE 96412
96368: LD_INT 19
96370: DOUBLE
96371: EQUAL
96372: IFTRUE 96412
96374: LD_INT 22
96376: DOUBLE
96377: EQUAL
96378: IFTRUE 96412
96380: LD_INT 20
96382: DOUBLE
96383: EQUAL
96384: IFTRUE 96412
96386: LD_INT 21
96388: DOUBLE
96389: EQUAL
96390: IFTRUE 96412
96392: LD_INT 23
96394: DOUBLE
96395: EQUAL
96396: IFTRUE 96412
96398: LD_INT 24
96400: DOUBLE
96401: EQUAL
96402: IFTRUE 96412
96404: LD_INT 25
96406: DOUBLE
96407: EQUAL
96408: IFTRUE 96412
96410: GO 96468
96412: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
96413: LD_ADDR_VAR 0 9
96417: PUSH
96418: LD_VAR 0 35
96422: PUSH
96423: LD_VAR 0 36
96427: PUSH
96428: LD_VAR 0 37
96432: PUSH
96433: LD_VAR 0 38
96437: PUSH
96438: LD_VAR 0 39
96442: PUSH
96443: LD_VAR 0 40
96447: PUSH
96448: EMPTY
96449: LIST
96450: LIST
96451: LIST
96452: LIST
96453: LIST
96454: LIST
96455: PUSH
96456: LD_VAR 0 4
96460: PUSH
96461: LD_INT 1
96463: PLUS
96464: ARRAY
96465: ST_TO_ADDR
96466: GO 96833
96468: LD_INT 6
96470: DOUBLE
96471: EQUAL
96472: IFTRUE 96524
96474: LD_INT 7
96476: DOUBLE
96477: EQUAL
96478: IFTRUE 96524
96480: LD_INT 8
96482: DOUBLE
96483: EQUAL
96484: IFTRUE 96524
96486: LD_INT 13
96488: DOUBLE
96489: EQUAL
96490: IFTRUE 96524
96492: LD_INT 12
96494: DOUBLE
96495: EQUAL
96496: IFTRUE 96524
96498: LD_INT 15
96500: DOUBLE
96501: EQUAL
96502: IFTRUE 96524
96504: LD_INT 11
96506: DOUBLE
96507: EQUAL
96508: IFTRUE 96524
96510: LD_INT 14
96512: DOUBLE
96513: EQUAL
96514: IFTRUE 96524
96516: LD_INT 10
96518: DOUBLE
96519: EQUAL
96520: IFTRUE 96524
96522: GO 96580
96524: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
96525: LD_ADDR_VAR 0 9
96529: PUSH
96530: LD_VAR 0 41
96534: PUSH
96535: LD_VAR 0 42
96539: PUSH
96540: LD_VAR 0 43
96544: PUSH
96545: LD_VAR 0 44
96549: PUSH
96550: LD_VAR 0 45
96554: PUSH
96555: LD_VAR 0 46
96559: PUSH
96560: EMPTY
96561: LIST
96562: LIST
96563: LIST
96564: LIST
96565: LIST
96566: LIST
96567: PUSH
96568: LD_VAR 0 4
96572: PUSH
96573: LD_INT 1
96575: PLUS
96576: ARRAY
96577: ST_TO_ADDR
96578: GO 96833
96580: LD_INT 36
96582: DOUBLE
96583: EQUAL
96584: IFTRUE 96588
96586: GO 96644
96588: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
96589: LD_ADDR_VAR 0 9
96593: PUSH
96594: LD_VAR 0 47
96598: PUSH
96599: LD_VAR 0 48
96603: PUSH
96604: LD_VAR 0 49
96608: PUSH
96609: LD_VAR 0 50
96613: PUSH
96614: LD_VAR 0 51
96618: PUSH
96619: LD_VAR 0 52
96623: PUSH
96624: EMPTY
96625: LIST
96626: LIST
96627: LIST
96628: LIST
96629: LIST
96630: LIST
96631: PUSH
96632: LD_VAR 0 4
96636: PUSH
96637: LD_INT 1
96639: PLUS
96640: ARRAY
96641: ST_TO_ADDR
96642: GO 96833
96644: LD_INT 4
96646: DOUBLE
96647: EQUAL
96648: IFTRUE 96670
96650: LD_INT 5
96652: DOUBLE
96653: EQUAL
96654: IFTRUE 96670
96656: LD_INT 34
96658: DOUBLE
96659: EQUAL
96660: IFTRUE 96670
96662: LD_INT 37
96664: DOUBLE
96665: EQUAL
96666: IFTRUE 96670
96668: GO 96726
96670: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
96671: LD_ADDR_VAR 0 9
96675: PUSH
96676: LD_VAR 0 53
96680: PUSH
96681: LD_VAR 0 54
96685: PUSH
96686: LD_VAR 0 55
96690: PUSH
96691: LD_VAR 0 56
96695: PUSH
96696: LD_VAR 0 57
96700: PUSH
96701: LD_VAR 0 58
96705: PUSH
96706: EMPTY
96707: LIST
96708: LIST
96709: LIST
96710: LIST
96711: LIST
96712: LIST
96713: PUSH
96714: LD_VAR 0 4
96718: PUSH
96719: LD_INT 1
96721: PLUS
96722: ARRAY
96723: ST_TO_ADDR
96724: GO 96833
96726: LD_INT 31
96728: DOUBLE
96729: EQUAL
96730: IFTRUE 96776
96732: LD_INT 32
96734: DOUBLE
96735: EQUAL
96736: IFTRUE 96776
96738: LD_INT 33
96740: DOUBLE
96741: EQUAL
96742: IFTRUE 96776
96744: LD_INT 27
96746: DOUBLE
96747: EQUAL
96748: IFTRUE 96776
96750: LD_INT 26
96752: DOUBLE
96753: EQUAL
96754: IFTRUE 96776
96756: LD_INT 28
96758: DOUBLE
96759: EQUAL
96760: IFTRUE 96776
96762: LD_INT 29
96764: DOUBLE
96765: EQUAL
96766: IFTRUE 96776
96768: LD_INT 30
96770: DOUBLE
96771: EQUAL
96772: IFTRUE 96776
96774: GO 96832
96776: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
96777: LD_ADDR_VAR 0 9
96781: PUSH
96782: LD_VAR 0 59
96786: PUSH
96787: LD_VAR 0 60
96791: PUSH
96792: LD_VAR 0 61
96796: PUSH
96797: LD_VAR 0 62
96801: PUSH
96802: LD_VAR 0 63
96806: PUSH
96807: LD_VAR 0 64
96811: PUSH
96812: EMPTY
96813: LIST
96814: LIST
96815: LIST
96816: LIST
96817: LIST
96818: LIST
96819: PUSH
96820: LD_VAR 0 4
96824: PUSH
96825: LD_INT 1
96827: PLUS
96828: ARRAY
96829: ST_TO_ADDR
96830: GO 96833
96832: POP
// temp_list2 = [ ] ;
96833: LD_ADDR_VAR 0 10
96837: PUSH
96838: EMPTY
96839: ST_TO_ADDR
// for i in temp_list do
96840: LD_ADDR_VAR 0 8
96844: PUSH
96845: LD_VAR 0 9
96849: PUSH
96850: FOR_IN
96851: IFFALSE 96903
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
96853: LD_ADDR_VAR 0 10
96857: PUSH
96858: LD_VAR 0 10
96862: PUSH
96863: LD_VAR 0 8
96867: PUSH
96868: LD_INT 1
96870: ARRAY
96871: PUSH
96872: LD_VAR 0 2
96876: PLUS
96877: PUSH
96878: LD_VAR 0 8
96882: PUSH
96883: LD_INT 2
96885: ARRAY
96886: PUSH
96887: LD_VAR 0 3
96891: PLUS
96892: PUSH
96893: EMPTY
96894: LIST
96895: LIST
96896: PUSH
96897: EMPTY
96898: LIST
96899: ADD
96900: ST_TO_ADDR
96901: GO 96850
96903: POP
96904: POP
// result = temp_list2 ;
96905: LD_ADDR_VAR 0 7
96909: PUSH
96910: LD_VAR 0 10
96914: ST_TO_ADDR
// end ;
96915: LD_VAR 0 7
96919: RET
// export function EnemyInRange ( unit , dist ) ; begin
96920: LD_INT 0
96922: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
96923: LD_ADDR_VAR 0 3
96927: PUSH
96928: LD_VAR 0 1
96932: PPUSH
96933: CALL_OW 255
96937: PPUSH
96938: LD_VAR 0 1
96942: PPUSH
96943: CALL_OW 250
96947: PPUSH
96948: LD_VAR 0 1
96952: PPUSH
96953: CALL_OW 251
96957: PPUSH
96958: LD_VAR 0 2
96962: PPUSH
96963: CALL 71024 0 4
96967: PUSH
96968: LD_INT 4
96970: ARRAY
96971: ST_TO_ADDR
// end ;
96972: LD_VAR 0 3
96976: RET
// export function PlayerSeeMe ( unit ) ; begin
96977: LD_INT 0
96979: PPUSH
// result := See ( your_side , unit ) ;
96980: LD_ADDR_VAR 0 2
96984: PUSH
96985: LD_OWVAR 2
96989: PPUSH
96990: LD_VAR 0 1
96994: PPUSH
96995: CALL_OW 292
96999: ST_TO_ADDR
// end ;
97000: LD_VAR 0 2
97004: RET
// export function ReverseDir ( unit ) ; begin
97005: LD_INT 0
97007: PPUSH
// if not unit then
97008: LD_VAR 0 1
97012: NOT
97013: IFFALSE 97017
// exit ;
97015: GO 97040
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
97017: LD_ADDR_VAR 0 2
97021: PUSH
97022: LD_VAR 0 1
97026: PPUSH
97027: CALL_OW 254
97031: PUSH
97032: LD_INT 3
97034: PLUS
97035: PUSH
97036: LD_INT 6
97038: MOD
97039: ST_TO_ADDR
// end ;
97040: LD_VAR 0 2
97044: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
97045: LD_INT 0
97047: PPUSH
97048: PPUSH
97049: PPUSH
97050: PPUSH
97051: PPUSH
// if not hexes then
97052: LD_VAR 0 2
97056: NOT
97057: IFFALSE 97061
// exit ;
97059: GO 97209
// dist := 9999 ;
97061: LD_ADDR_VAR 0 5
97065: PUSH
97066: LD_INT 9999
97068: ST_TO_ADDR
// for i = 1 to hexes do
97069: LD_ADDR_VAR 0 4
97073: PUSH
97074: DOUBLE
97075: LD_INT 1
97077: DEC
97078: ST_TO_ADDR
97079: LD_VAR 0 2
97083: PUSH
97084: FOR_TO
97085: IFFALSE 97197
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
97087: LD_VAR 0 1
97091: PPUSH
97092: LD_VAR 0 2
97096: PUSH
97097: LD_VAR 0 4
97101: ARRAY
97102: PUSH
97103: LD_INT 1
97105: ARRAY
97106: PPUSH
97107: LD_VAR 0 2
97111: PUSH
97112: LD_VAR 0 4
97116: ARRAY
97117: PUSH
97118: LD_INT 2
97120: ARRAY
97121: PPUSH
97122: CALL_OW 297
97126: PUSH
97127: LD_VAR 0 5
97131: LESS
97132: IFFALSE 97195
// begin hex := hexes [ i ] ;
97134: LD_ADDR_VAR 0 7
97138: PUSH
97139: LD_VAR 0 2
97143: PUSH
97144: LD_VAR 0 4
97148: ARRAY
97149: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
97150: LD_ADDR_VAR 0 5
97154: PUSH
97155: LD_VAR 0 1
97159: PPUSH
97160: LD_VAR 0 2
97164: PUSH
97165: LD_VAR 0 4
97169: ARRAY
97170: PUSH
97171: LD_INT 1
97173: ARRAY
97174: PPUSH
97175: LD_VAR 0 2
97179: PUSH
97180: LD_VAR 0 4
97184: ARRAY
97185: PUSH
97186: LD_INT 2
97188: ARRAY
97189: PPUSH
97190: CALL_OW 297
97194: ST_TO_ADDR
// end ; end ;
97195: GO 97084
97197: POP
97198: POP
// result := hex ;
97199: LD_ADDR_VAR 0 3
97203: PUSH
97204: LD_VAR 0 7
97208: ST_TO_ADDR
// end ;
97209: LD_VAR 0 3
97213: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
97214: LD_INT 0
97216: PPUSH
97217: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
97218: LD_VAR 0 1
97222: NOT
97223: PUSH
97224: LD_VAR 0 1
97228: PUSH
97229: LD_INT 21
97231: PUSH
97232: LD_INT 2
97234: PUSH
97235: EMPTY
97236: LIST
97237: LIST
97238: PUSH
97239: LD_INT 23
97241: PUSH
97242: LD_INT 2
97244: PUSH
97245: EMPTY
97246: LIST
97247: LIST
97248: PUSH
97249: EMPTY
97250: LIST
97251: LIST
97252: PPUSH
97253: CALL_OW 69
97257: IN
97258: NOT
97259: OR
97260: IFFALSE 97264
// exit ;
97262: GO 97311
// for i = 1 to 3 do
97264: LD_ADDR_VAR 0 3
97268: PUSH
97269: DOUBLE
97270: LD_INT 1
97272: DEC
97273: ST_TO_ADDR
97274: LD_INT 3
97276: PUSH
97277: FOR_TO
97278: IFFALSE 97309
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
97280: LD_VAR 0 1
97284: PPUSH
97285: CALL_OW 250
97289: PPUSH
97290: LD_VAR 0 1
97294: PPUSH
97295: CALL_OW 251
97299: PPUSH
97300: LD_INT 1
97302: PPUSH
97303: CALL_OW 453
97307: GO 97277
97309: POP
97310: POP
// end ;
97311: LD_VAR 0 2
97315: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
97316: LD_INT 0
97318: PPUSH
97319: PPUSH
97320: PPUSH
97321: PPUSH
97322: PPUSH
97323: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
97324: LD_VAR 0 1
97328: NOT
97329: PUSH
97330: LD_VAR 0 2
97334: NOT
97335: OR
97336: PUSH
97337: LD_VAR 0 1
97341: PPUSH
97342: CALL_OW 314
97346: OR
97347: IFFALSE 97351
// exit ;
97349: GO 97792
// x := GetX ( enemy_unit ) ;
97351: LD_ADDR_VAR 0 7
97355: PUSH
97356: LD_VAR 0 2
97360: PPUSH
97361: CALL_OW 250
97365: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
97366: LD_ADDR_VAR 0 8
97370: PUSH
97371: LD_VAR 0 2
97375: PPUSH
97376: CALL_OW 251
97380: ST_TO_ADDR
// if not x or not y then
97381: LD_VAR 0 7
97385: NOT
97386: PUSH
97387: LD_VAR 0 8
97391: NOT
97392: OR
97393: IFFALSE 97397
// exit ;
97395: GO 97792
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
97397: LD_ADDR_VAR 0 6
97401: PUSH
97402: LD_VAR 0 7
97406: PPUSH
97407: LD_INT 0
97409: PPUSH
97410: LD_INT 4
97412: PPUSH
97413: CALL_OW 272
97417: PUSH
97418: LD_VAR 0 8
97422: PPUSH
97423: LD_INT 0
97425: PPUSH
97426: LD_INT 4
97428: PPUSH
97429: CALL_OW 273
97433: PUSH
97434: EMPTY
97435: LIST
97436: LIST
97437: PUSH
97438: LD_VAR 0 7
97442: PPUSH
97443: LD_INT 1
97445: PPUSH
97446: LD_INT 4
97448: PPUSH
97449: CALL_OW 272
97453: PUSH
97454: LD_VAR 0 8
97458: PPUSH
97459: LD_INT 1
97461: PPUSH
97462: LD_INT 4
97464: PPUSH
97465: CALL_OW 273
97469: PUSH
97470: EMPTY
97471: LIST
97472: LIST
97473: PUSH
97474: LD_VAR 0 7
97478: PPUSH
97479: LD_INT 2
97481: PPUSH
97482: LD_INT 4
97484: PPUSH
97485: CALL_OW 272
97489: PUSH
97490: LD_VAR 0 8
97494: PPUSH
97495: LD_INT 2
97497: PPUSH
97498: LD_INT 4
97500: PPUSH
97501: CALL_OW 273
97505: PUSH
97506: EMPTY
97507: LIST
97508: LIST
97509: PUSH
97510: LD_VAR 0 7
97514: PPUSH
97515: LD_INT 3
97517: PPUSH
97518: LD_INT 4
97520: PPUSH
97521: CALL_OW 272
97525: PUSH
97526: LD_VAR 0 8
97530: PPUSH
97531: LD_INT 3
97533: PPUSH
97534: LD_INT 4
97536: PPUSH
97537: CALL_OW 273
97541: PUSH
97542: EMPTY
97543: LIST
97544: LIST
97545: PUSH
97546: LD_VAR 0 7
97550: PPUSH
97551: LD_INT 4
97553: PPUSH
97554: LD_INT 4
97556: PPUSH
97557: CALL_OW 272
97561: PUSH
97562: LD_VAR 0 8
97566: PPUSH
97567: LD_INT 4
97569: PPUSH
97570: LD_INT 4
97572: PPUSH
97573: CALL_OW 273
97577: PUSH
97578: EMPTY
97579: LIST
97580: LIST
97581: PUSH
97582: LD_VAR 0 7
97586: PPUSH
97587: LD_INT 5
97589: PPUSH
97590: LD_INT 4
97592: PPUSH
97593: CALL_OW 272
97597: PUSH
97598: LD_VAR 0 8
97602: PPUSH
97603: LD_INT 5
97605: PPUSH
97606: LD_INT 4
97608: PPUSH
97609: CALL_OW 273
97613: PUSH
97614: EMPTY
97615: LIST
97616: LIST
97617: PUSH
97618: EMPTY
97619: LIST
97620: LIST
97621: LIST
97622: LIST
97623: LIST
97624: LIST
97625: ST_TO_ADDR
// for i = tmp downto 1 do
97626: LD_ADDR_VAR 0 4
97630: PUSH
97631: DOUBLE
97632: LD_VAR 0 6
97636: INC
97637: ST_TO_ADDR
97638: LD_INT 1
97640: PUSH
97641: FOR_DOWNTO
97642: IFFALSE 97743
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
97644: LD_VAR 0 6
97648: PUSH
97649: LD_VAR 0 4
97653: ARRAY
97654: PUSH
97655: LD_INT 1
97657: ARRAY
97658: PPUSH
97659: LD_VAR 0 6
97663: PUSH
97664: LD_VAR 0 4
97668: ARRAY
97669: PUSH
97670: LD_INT 2
97672: ARRAY
97673: PPUSH
97674: CALL_OW 488
97678: NOT
97679: PUSH
97680: LD_VAR 0 6
97684: PUSH
97685: LD_VAR 0 4
97689: ARRAY
97690: PUSH
97691: LD_INT 1
97693: ARRAY
97694: PPUSH
97695: LD_VAR 0 6
97699: PUSH
97700: LD_VAR 0 4
97704: ARRAY
97705: PUSH
97706: LD_INT 2
97708: ARRAY
97709: PPUSH
97710: CALL_OW 428
97714: PUSH
97715: LD_INT 0
97717: NONEQUAL
97718: OR
97719: IFFALSE 97741
// tmp := Delete ( tmp , i ) ;
97721: LD_ADDR_VAR 0 6
97725: PUSH
97726: LD_VAR 0 6
97730: PPUSH
97731: LD_VAR 0 4
97735: PPUSH
97736: CALL_OW 3
97740: ST_TO_ADDR
97741: GO 97641
97743: POP
97744: POP
// j := GetClosestHex ( unit , tmp ) ;
97745: LD_ADDR_VAR 0 5
97749: PUSH
97750: LD_VAR 0 1
97754: PPUSH
97755: LD_VAR 0 6
97759: PPUSH
97760: CALL 97045 0 2
97764: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
97765: LD_VAR 0 1
97769: PPUSH
97770: LD_VAR 0 5
97774: PUSH
97775: LD_INT 1
97777: ARRAY
97778: PPUSH
97779: LD_VAR 0 5
97783: PUSH
97784: LD_INT 2
97786: ARRAY
97787: PPUSH
97788: CALL_OW 111
// end ;
97792: LD_VAR 0 3
97796: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
97797: LD_INT 0
97799: PPUSH
97800: PPUSH
97801: PPUSH
// uc_side = 0 ;
97802: LD_ADDR_OWVAR 20
97806: PUSH
97807: LD_INT 0
97809: ST_TO_ADDR
// uc_nation = 0 ;
97810: LD_ADDR_OWVAR 21
97814: PUSH
97815: LD_INT 0
97817: ST_TO_ADDR
// InitHc_All ( ) ;
97818: CALL_OW 584
// InitVc ;
97822: CALL_OW 20
// if mastodonts then
97826: LD_VAR 0 6
97830: IFFALSE 97897
// for i = 1 to mastodonts do
97832: LD_ADDR_VAR 0 11
97836: PUSH
97837: DOUBLE
97838: LD_INT 1
97840: DEC
97841: ST_TO_ADDR
97842: LD_VAR 0 6
97846: PUSH
97847: FOR_TO
97848: IFFALSE 97895
// begin vc_chassis := 31 ;
97850: LD_ADDR_OWVAR 37
97854: PUSH
97855: LD_INT 31
97857: ST_TO_ADDR
// vc_control := control_rider ;
97858: LD_ADDR_OWVAR 38
97862: PUSH
97863: LD_INT 4
97865: ST_TO_ADDR
// animal := CreateVehicle ;
97866: LD_ADDR_VAR 0 12
97870: PUSH
97871: CALL_OW 45
97875: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97876: LD_VAR 0 12
97880: PPUSH
97881: LD_VAR 0 8
97885: PPUSH
97886: LD_INT 0
97888: PPUSH
97889: CALL 100085 0 3
// end ;
97893: GO 97847
97895: POP
97896: POP
// if horses then
97897: LD_VAR 0 5
97901: IFFALSE 97968
// for i = 1 to horses do
97903: LD_ADDR_VAR 0 11
97907: PUSH
97908: DOUBLE
97909: LD_INT 1
97911: DEC
97912: ST_TO_ADDR
97913: LD_VAR 0 5
97917: PUSH
97918: FOR_TO
97919: IFFALSE 97966
// begin hc_class := 21 ;
97921: LD_ADDR_OWVAR 28
97925: PUSH
97926: LD_INT 21
97928: ST_TO_ADDR
// hc_gallery :=  ;
97929: LD_ADDR_OWVAR 33
97933: PUSH
97934: LD_STRING 
97936: ST_TO_ADDR
// animal := CreateHuman ;
97937: LD_ADDR_VAR 0 12
97941: PUSH
97942: CALL_OW 44
97946: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97947: LD_VAR 0 12
97951: PPUSH
97952: LD_VAR 0 8
97956: PPUSH
97957: LD_INT 0
97959: PPUSH
97960: CALL 100085 0 3
// end ;
97964: GO 97918
97966: POP
97967: POP
// if birds then
97968: LD_VAR 0 1
97972: IFFALSE 98039
// for i = 1 to birds do
97974: LD_ADDR_VAR 0 11
97978: PUSH
97979: DOUBLE
97980: LD_INT 1
97982: DEC
97983: ST_TO_ADDR
97984: LD_VAR 0 1
97988: PUSH
97989: FOR_TO
97990: IFFALSE 98037
// begin hc_class = 18 ;
97992: LD_ADDR_OWVAR 28
97996: PUSH
97997: LD_INT 18
97999: ST_TO_ADDR
// hc_gallery =  ;
98000: LD_ADDR_OWVAR 33
98004: PUSH
98005: LD_STRING 
98007: ST_TO_ADDR
// animal := CreateHuman ;
98008: LD_ADDR_VAR 0 12
98012: PUSH
98013: CALL_OW 44
98017: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98018: LD_VAR 0 12
98022: PPUSH
98023: LD_VAR 0 8
98027: PPUSH
98028: LD_INT 0
98030: PPUSH
98031: CALL 100085 0 3
// end ;
98035: GO 97989
98037: POP
98038: POP
// if tigers then
98039: LD_VAR 0 2
98043: IFFALSE 98127
// for i = 1 to tigers do
98045: LD_ADDR_VAR 0 11
98049: PUSH
98050: DOUBLE
98051: LD_INT 1
98053: DEC
98054: ST_TO_ADDR
98055: LD_VAR 0 2
98059: PUSH
98060: FOR_TO
98061: IFFALSE 98125
// begin hc_class = class_tiger ;
98063: LD_ADDR_OWVAR 28
98067: PUSH
98068: LD_INT 14
98070: ST_TO_ADDR
// hc_gallery =  ;
98071: LD_ADDR_OWVAR 33
98075: PUSH
98076: LD_STRING 
98078: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
98079: LD_ADDR_OWVAR 35
98083: PUSH
98084: LD_INT 7
98086: NEG
98087: PPUSH
98088: LD_INT 7
98090: PPUSH
98091: CALL_OW 12
98095: ST_TO_ADDR
// animal := CreateHuman ;
98096: LD_ADDR_VAR 0 12
98100: PUSH
98101: CALL_OW 44
98105: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98106: LD_VAR 0 12
98110: PPUSH
98111: LD_VAR 0 8
98115: PPUSH
98116: LD_INT 0
98118: PPUSH
98119: CALL 100085 0 3
// end ;
98123: GO 98060
98125: POP
98126: POP
// if apemans then
98127: LD_VAR 0 3
98131: IFFALSE 98254
// for i = 1 to apemans do
98133: LD_ADDR_VAR 0 11
98137: PUSH
98138: DOUBLE
98139: LD_INT 1
98141: DEC
98142: ST_TO_ADDR
98143: LD_VAR 0 3
98147: PUSH
98148: FOR_TO
98149: IFFALSE 98252
// begin hc_class = class_apeman ;
98151: LD_ADDR_OWVAR 28
98155: PUSH
98156: LD_INT 12
98158: ST_TO_ADDR
// hc_gallery =  ;
98159: LD_ADDR_OWVAR 33
98163: PUSH
98164: LD_STRING 
98166: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
98167: LD_ADDR_OWVAR 35
98171: PUSH
98172: LD_INT 5
98174: NEG
98175: PPUSH
98176: LD_INT 5
98178: PPUSH
98179: CALL_OW 12
98183: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
98184: LD_ADDR_OWVAR 31
98188: PUSH
98189: LD_INT 1
98191: PPUSH
98192: LD_INT 3
98194: PPUSH
98195: CALL_OW 12
98199: PUSH
98200: LD_INT 1
98202: PPUSH
98203: LD_INT 3
98205: PPUSH
98206: CALL_OW 12
98210: PUSH
98211: LD_INT 0
98213: PUSH
98214: LD_INT 0
98216: PUSH
98217: EMPTY
98218: LIST
98219: LIST
98220: LIST
98221: LIST
98222: ST_TO_ADDR
// animal := CreateHuman ;
98223: LD_ADDR_VAR 0 12
98227: PUSH
98228: CALL_OW 44
98232: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98233: LD_VAR 0 12
98237: PPUSH
98238: LD_VAR 0 8
98242: PPUSH
98243: LD_INT 0
98245: PPUSH
98246: CALL 100085 0 3
// end ;
98250: GO 98148
98252: POP
98253: POP
// if enchidnas then
98254: LD_VAR 0 4
98258: IFFALSE 98325
// for i = 1 to enchidnas do
98260: LD_ADDR_VAR 0 11
98264: PUSH
98265: DOUBLE
98266: LD_INT 1
98268: DEC
98269: ST_TO_ADDR
98270: LD_VAR 0 4
98274: PUSH
98275: FOR_TO
98276: IFFALSE 98323
// begin hc_class = 13 ;
98278: LD_ADDR_OWVAR 28
98282: PUSH
98283: LD_INT 13
98285: ST_TO_ADDR
// hc_gallery =  ;
98286: LD_ADDR_OWVAR 33
98290: PUSH
98291: LD_STRING 
98293: ST_TO_ADDR
// animal := CreateHuman ;
98294: LD_ADDR_VAR 0 12
98298: PUSH
98299: CALL_OW 44
98303: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98304: LD_VAR 0 12
98308: PPUSH
98309: LD_VAR 0 8
98313: PPUSH
98314: LD_INT 0
98316: PPUSH
98317: CALL 100085 0 3
// end ;
98321: GO 98275
98323: POP
98324: POP
// if fishes then
98325: LD_VAR 0 7
98329: IFFALSE 98396
// for i = 1 to fishes do
98331: LD_ADDR_VAR 0 11
98335: PUSH
98336: DOUBLE
98337: LD_INT 1
98339: DEC
98340: ST_TO_ADDR
98341: LD_VAR 0 7
98345: PUSH
98346: FOR_TO
98347: IFFALSE 98394
// begin hc_class = 20 ;
98349: LD_ADDR_OWVAR 28
98353: PUSH
98354: LD_INT 20
98356: ST_TO_ADDR
// hc_gallery =  ;
98357: LD_ADDR_OWVAR 33
98361: PUSH
98362: LD_STRING 
98364: ST_TO_ADDR
// animal := CreateHuman ;
98365: LD_ADDR_VAR 0 12
98369: PUSH
98370: CALL_OW 44
98374: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
98375: LD_VAR 0 12
98379: PPUSH
98380: LD_VAR 0 9
98384: PPUSH
98385: LD_INT 0
98387: PPUSH
98388: CALL 100085 0 3
// end ;
98392: GO 98346
98394: POP
98395: POP
// end ;
98396: LD_VAR 0 10
98400: RET
// export function WantHeal ( sci , unit ) ; begin
98401: LD_INT 0
98403: PPUSH
// if GetTaskList ( sci ) > 0 then
98404: LD_VAR 0 1
98408: PPUSH
98409: CALL_OW 437
98413: PUSH
98414: LD_INT 0
98416: GREATER
98417: IFFALSE 98487
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
98419: LD_VAR 0 1
98423: PPUSH
98424: CALL_OW 437
98428: PUSH
98429: LD_INT 1
98431: ARRAY
98432: PUSH
98433: LD_INT 1
98435: ARRAY
98436: PUSH
98437: LD_STRING l
98439: EQUAL
98440: PUSH
98441: LD_VAR 0 1
98445: PPUSH
98446: CALL_OW 437
98450: PUSH
98451: LD_INT 1
98453: ARRAY
98454: PUSH
98455: LD_INT 4
98457: ARRAY
98458: PUSH
98459: LD_VAR 0 2
98463: EQUAL
98464: AND
98465: IFFALSE 98477
// result := true else
98467: LD_ADDR_VAR 0 3
98471: PUSH
98472: LD_INT 1
98474: ST_TO_ADDR
98475: GO 98485
// result := false ;
98477: LD_ADDR_VAR 0 3
98481: PUSH
98482: LD_INT 0
98484: ST_TO_ADDR
// end else
98485: GO 98495
// result := false ;
98487: LD_ADDR_VAR 0 3
98491: PUSH
98492: LD_INT 0
98494: ST_TO_ADDR
// end ;
98495: LD_VAR 0 3
98499: RET
// export function HealTarget ( sci ) ; begin
98500: LD_INT 0
98502: PPUSH
// if not sci then
98503: LD_VAR 0 1
98507: NOT
98508: IFFALSE 98512
// exit ;
98510: GO 98577
// result := 0 ;
98512: LD_ADDR_VAR 0 2
98516: PUSH
98517: LD_INT 0
98519: ST_TO_ADDR
// if GetTaskList ( sci ) then
98520: LD_VAR 0 1
98524: PPUSH
98525: CALL_OW 437
98529: IFFALSE 98577
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
98531: LD_VAR 0 1
98535: PPUSH
98536: CALL_OW 437
98540: PUSH
98541: LD_INT 1
98543: ARRAY
98544: PUSH
98545: LD_INT 1
98547: ARRAY
98548: PUSH
98549: LD_STRING l
98551: EQUAL
98552: IFFALSE 98577
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
98554: LD_ADDR_VAR 0 2
98558: PUSH
98559: LD_VAR 0 1
98563: PPUSH
98564: CALL_OW 437
98568: PUSH
98569: LD_INT 1
98571: ARRAY
98572: PUSH
98573: LD_INT 4
98575: ARRAY
98576: ST_TO_ADDR
// end ;
98577: LD_VAR 0 2
98581: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
98582: LD_INT 0
98584: PPUSH
98585: PPUSH
98586: PPUSH
98587: PPUSH
// if not base_units then
98588: LD_VAR 0 1
98592: NOT
98593: IFFALSE 98597
// exit ;
98595: GO 98684
// result := false ;
98597: LD_ADDR_VAR 0 2
98601: PUSH
98602: LD_INT 0
98604: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
98605: LD_ADDR_VAR 0 5
98609: PUSH
98610: LD_VAR 0 1
98614: PPUSH
98615: LD_INT 21
98617: PUSH
98618: LD_INT 3
98620: PUSH
98621: EMPTY
98622: LIST
98623: LIST
98624: PPUSH
98625: CALL_OW 72
98629: ST_TO_ADDR
// if not tmp then
98630: LD_VAR 0 5
98634: NOT
98635: IFFALSE 98639
// exit ;
98637: GO 98684
// for i in tmp do
98639: LD_ADDR_VAR 0 3
98643: PUSH
98644: LD_VAR 0 5
98648: PUSH
98649: FOR_IN
98650: IFFALSE 98682
// begin result := EnemyInRange ( i , 22 ) ;
98652: LD_ADDR_VAR 0 2
98656: PUSH
98657: LD_VAR 0 3
98661: PPUSH
98662: LD_INT 22
98664: PPUSH
98665: CALL 96920 0 2
98669: ST_TO_ADDR
// if result then
98670: LD_VAR 0 2
98674: IFFALSE 98680
// exit ;
98676: POP
98677: POP
98678: GO 98684
// end ;
98680: GO 98649
98682: POP
98683: POP
// end ;
98684: LD_VAR 0 2
98688: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
98689: LD_INT 0
98691: PPUSH
98692: PPUSH
// if not units then
98693: LD_VAR 0 1
98697: NOT
98698: IFFALSE 98702
// exit ;
98700: GO 98772
// result := [ ] ;
98702: LD_ADDR_VAR 0 3
98706: PUSH
98707: EMPTY
98708: ST_TO_ADDR
// for i in units do
98709: LD_ADDR_VAR 0 4
98713: PUSH
98714: LD_VAR 0 1
98718: PUSH
98719: FOR_IN
98720: IFFALSE 98770
// if GetTag ( i ) = tag then
98722: LD_VAR 0 4
98726: PPUSH
98727: CALL_OW 110
98731: PUSH
98732: LD_VAR 0 2
98736: EQUAL
98737: IFFALSE 98768
// result := Insert ( result , result + 1 , i ) ;
98739: LD_ADDR_VAR 0 3
98743: PUSH
98744: LD_VAR 0 3
98748: PPUSH
98749: LD_VAR 0 3
98753: PUSH
98754: LD_INT 1
98756: PLUS
98757: PPUSH
98758: LD_VAR 0 4
98762: PPUSH
98763: CALL_OW 2
98767: ST_TO_ADDR
98768: GO 98719
98770: POP
98771: POP
// end ;
98772: LD_VAR 0 3
98776: RET
// export function IsDriver ( un ) ; begin
98777: LD_INT 0
98779: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
98780: LD_ADDR_VAR 0 2
98784: PUSH
98785: LD_VAR 0 1
98789: PUSH
98790: LD_INT 55
98792: PUSH
98793: EMPTY
98794: LIST
98795: PPUSH
98796: CALL_OW 69
98800: IN
98801: ST_TO_ADDR
// end ;
98802: LD_VAR 0 2
98806: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
98807: LD_INT 0
98809: PPUSH
98810: PPUSH
// list := [ ] ;
98811: LD_ADDR_VAR 0 5
98815: PUSH
98816: EMPTY
98817: ST_TO_ADDR
// case d of 0 :
98818: LD_VAR 0 3
98822: PUSH
98823: LD_INT 0
98825: DOUBLE
98826: EQUAL
98827: IFTRUE 98831
98829: GO 98964
98831: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
98832: LD_ADDR_VAR 0 5
98836: PUSH
98837: LD_VAR 0 1
98841: PUSH
98842: LD_INT 4
98844: MINUS
98845: PUSH
98846: LD_VAR 0 2
98850: PUSH
98851: LD_INT 4
98853: MINUS
98854: PUSH
98855: LD_INT 2
98857: PUSH
98858: EMPTY
98859: LIST
98860: LIST
98861: LIST
98862: PUSH
98863: LD_VAR 0 1
98867: PUSH
98868: LD_INT 3
98870: MINUS
98871: PUSH
98872: LD_VAR 0 2
98876: PUSH
98877: LD_INT 1
98879: PUSH
98880: EMPTY
98881: LIST
98882: LIST
98883: LIST
98884: PUSH
98885: LD_VAR 0 1
98889: PUSH
98890: LD_INT 4
98892: PLUS
98893: PUSH
98894: LD_VAR 0 2
98898: PUSH
98899: LD_INT 4
98901: PUSH
98902: EMPTY
98903: LIST
98904: LIST
98905: LIST
98906: PUSH
98907: LD_VAR 0 1
98911: PUSH
98912: LD_INT 3
98914: PLUS
98915: PUSH
98916: LD_VAR 0 2
98920: PUSH
98921: LD_INT 3
98923: PLUS
98924: PUSH
98925: LD_INT 5
98927: PUSH
98928: EMPTY
98929: LIST
98930: LIST
98931: LIST
98932: PUSH
98933: LD_VAR 0 1
98937: PUSH
98938: LD_VAR 0 2
98942: PUSH
98943: LD_INT 4
98945: PLUS
98946: PUSH
98947: LD_INT 0
98949: PUSH
98950: EMPTY
98951: LIST
98952: LIST
98953: LIST
98954: PUSH
98955: EMPTY
98956: LIST
98957: LIST
98958: LIST
98959: LIST
98960: LIST
98961: ST_TO_ADDR
// end ; 1 :
98962: GO 99662
98964: LD_INT 1
98966: DOUBLE
98967: EQUAL
98968: IFTRUE 98972
98970: GO 99105
98972: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
98973: LD_ADDR_VAR 0 5
98977: PUSH
98978: LD_VAR 0 1
98982: PUSH
98983: LD_VAR 0 2
98987: PUSH
98988: LD_INT 4
98990: MINUS
98991: PUSH
98992: LD_INT 3
98994: PUSH
98995: EMPTY
98996: LIST
98997: LIST
98998: LIST
98999: PUSH
99000: LD_VAR 0 1
99004: PUSH
99005: LD_INT 3
99007: MINUS
99008: PUSH
99009: LD_VAR 0 2
99013: PUSH
99014: LD_INT 3
99016: MINUS
99017: PUSH
99018: LD_INT 2
99020: PUSH
99021: EMPTY
99022: LIST
99023: LIST
99024: LIST
99025: PUSH
99026: LD_VAR 0 1
99030: PUSH
99031: LD_INT 4
99033: MINUS
99034: PUSH
99035: LD_VAR 0 2
99039: PUSH
99040: LD_INT 1
99042: PUSH
99043: EMPTY
99044: LIST
99045: LIST
99046: LIST
99047: PUSH
99048: LD_VAR 0 1
99052: PUSH
99053: LD_VAR 0 2
99057: PUSH
99058: LD_INT 3
99060: PLUS
99061: PUSH
99062: LD_INT 0
99064: PUSH
99065: EMPTY
99066: LIST
99067: LIST
99068: LIST
99069: PUSH
99070: LD_VAR 0 1
99074: PUSH
99075: LD_INT 4
99077: PLUS
99078: PUSH
99079: LD_VAR 0 2
99083: PUSH
99084: LD_INT 4
99086: PLUS
99087: PUSH
99088: LD_INT 5
99090: PUSH
99091: EMPTY
99092: LIST
99093: LIST
99094: LIST
99095: PUSH
99096: EMPTY
99097: LIST
99098: LIST
99099: LIST
99100: LIST
99101: LIST
99102: ST_TO_ADDR
// end ; 2 :
99103: GO 99662
99105: LD_INT 2
99107: DOUBLE
99108: EQUAL
99109: IFTRUE 99113
99111: GO 99242
99113: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
99114: LD_ADDR_VAR 0 5
99118: PUSH
99119: LD_VAR 0 1
99123: PUSH
99124: LD_VAR 0 2
99128: PUSH
99129: LD_INT 3
99131: MINUS
99132: PUSH
99133: LD_INT 3
99135: PUSH
99136: EMPTY
99137: LIST
99138: LIST
99139: LIST
99140: PUSH
99141: LD_VAR 0 1
99145: PUSH
99146: LD_INT 4
99148: PLUS
99149: PUSH
99150: LD_VAR 0 2
99154: PUSH
99155: LD_INT 4
99157: PUSH
99158: EMPTY
99159: LIST
99160: LIST
99161: LIST
99162: PUSH
99163: LD_VAR 0 1
99167: PUSH
99168: LD_VAR 0 2
99172: PUSH
99173: LD_INT 4
99175: PLUS
99176: PUSH
99177: LD_INT 0
99179: PUSH
99180: EMPTY
99181: LIST
99182: LIST
99183: LIST
99184: PUSH
99185: LD_VAR 0 1
99189: PUSH
99190: LD_INT 3
99192: MINUS
99193: PUSH
99194: LD_VAR 0 2
99198: PUSH
99199: LD_INT 1
99201: PUSH
99202: EMPTY
99203: LIST
99204: LIST
99205: LIST
99206: PUSH
99207: LD_VAR 0 1
99211: PUSH
99212: LD_INT 4
99214: MINUS
99215: PUSH
99216: LD_VAR 0 2
99220: PUSH
99221: LD_INT 4
99223: MINUS
99224: PUSH
99225: LD_INT 2
99227: PUSH
99228: EMPTY
99229: LIST
99230: LIST
99231: LIST
99232: PUSH
99233: EMPTY
99234: LIST
99235: LIST
99236: LIST
99237: LIST
99238: LIST
99239: ST_TO_ADDR
// end ; 3 :
99240: GO 99662
99242: LD_INT 3
99244: DOUBLE
99245: EQUAL
99246: IFTRUE 99250
99248: GO 99383
99250: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
99251: LD_ADDR_VAR 0 5
99255: PUSH
99256: LD_VAR 0 1
99260: PUSH
99261: LD_INT 3
99263: PLUS
99264: PUSH
99265: LD_VAR 0 2
99269: PUSH
99270: LD_INT 4
99272: PUSH
99273: EMPTY
99274: LIST
99275: LIST
99276: LIST
99277: PUSH
99278: LD_VAR 0 1
99282: PUSH
99283: LD_INT 4
99285: PLUS
99286: PUSH
99287: LD_VAR 0 2
99291: PUSH
99292: LD_INT 4
99294: PLUS
99295: PUSH
99296: LD_INT 5
99298: PUSH
99299: EMPTY
99300: LIST
99301: LIST
99302: LIST
99303: PUSH
99304: LD_VAR 0 1
99308: PUSH
99309: LD_INT 4
99311: MINUS
99312: PUSH
99313: LD_VAR 0 2
99317: PUSH
99318: LD_INT 1
99320: PUSH
99321: EMPTY
99322: LIST
99323: LIST
99324: LIST
99325: PUSH
99326: LD_VAR 0 1
99330: PUSH
99331: LD_VAR 0 2
99335: PUSH
99336: LD_INT 4
99338: MINUS
99339: PUSH
99340: LD_INT 3
99342: PUSH
99343: EMPTY
99344: LIST
99345: LIST
99346: LIST
99347: PUSH
99348: LD_VAR 0 1
99352: PUSH
99353: LD_INT 3
99355: MINUS
99356: PUSH
99357: LD_VAR 0 2
99361: PUSH
99362: LD_INT 3
99364: MINUS
99365: PUSH
99366: LD_INT 2
99368: PUSH
99369: EMPTY
99370: LIST
99371: LIST
99372: LIST
99373: PUSH
99374: EMPTY
99375: LIST
99376: LIST
99377: LIST
99378: LIST
99379: LIST
99380: ST_TO_ADDR
// end ; 4 :
99381: GO 99662
99383: LD_INT 4
99385: DOUBLE
99386: EQUAL
99387: IFTRUE 99391
99389: GO 99524
99391: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
99392: LD_ADDR_VAR 0 5
99396: PUSH
99397: LD_VAR 0 1
99401: PUSH
99402: LD_VAR 0 2
99406: PUSH
99407: LD_INT 4
99409: PLUS
99410: PUSH
99411: LD_INT 0
99413: PUSH
99414: EMPTY
99415: LIST
99416: LIST
99417: LIST
99418: PUSH
99419: LD_VAR 0 1
99423: PUSH
99424: LD_INT 3
99426: PLUS
99427: PUSH
99428: LD_VAR 0 2
99432: PUSH
99433: LD_INT 3
99435: PLUS
99436: PUSH
99437: LD_INT 5
99439: PUSH
99440: EMPTY
99441: LIST
99442: LIST
99443: LIST
99444: PUSH
99445: LD_VAR 0 1
99449: PUSH
99450: LD_INT 4
99452: PLUS
99453: PUSH
99454: LD_VAR 0 2
99458: PUSH
99459: LD_INT 4
99461: PUSH
99462: EMPTY
99463: LIST
99464: LIST
99465: LIST
99466: PUSH
99467: LD_VAR 0 1
99471: PUSH
99472: LD_VAR 0 2
99476: PUSH
99477: LD_INT 3
99479: MINUS
99480: PUSH
99481: LD_INT 3
99483: PUSH
99484: EMPTY
99485: LIST
99486: LIST
99487: LIST
99488: PUSH
99489: LD_VAR 0 1
99493: PUSH
99494: LD_INT 4
99496: MINUS
99497: PUSH
99498: LD_VAR 0 2
99502: PUSH
99503: LD_INT 4
99505: MINUS
99506: PUSH
99507: LD_INT 2
99509: PUSH
99510: EMPTY
99511: LIST
99512: LIST
99513: LIST
99514: PUSH
99515: EMPTY
99516: LIST
99517: LIST
99518: LIST
99519: LIST
99520: LIST
99521: ST_TO_ADDR
// end ; 5 :
99522: GO 99662
99524: LD_INT 5
99526: DOUBLE
99527: EQUAL
99528: IFTRUE 99532
99530: GO 99661
99532: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
99533: LD_ADDR_VAR 0 5
99537: PUSH
99538: LD_VAR 0 1
99542: PUSH
99543: LD_INT 4
99545: MINUS
99546: PUSH
99547: LD_VAR 0 2
99551: PUSH
99552: LD_INT 1
99554: PUSH
99555: EMPTY
99556: LIST
99557: LIST
99558: LIST
99559: PUSH
99560: LD_VAR 0 1
99564: PUSH
99565: LD_VAR 0 2
99569: PUSH
99570: LD_INT 4
99572: MINUS
99573: PUSH
99574: LD_INT 3
99576: PUSH
99577: EMPTY
99578: LIST
99579: LIST
99580: LIST
99581: PUSH
99582: LD_VAR 0 1
99586: PUSH
99587: LD_INT 4
99589: PLUS
99590: PUSH
99591: LD_VAR 0 2
99595: PUSH
99596: LD_INT 4
99598: PLUS
99599: PUSH
99600: LD_INT 5
99602: PUSH
99603: EMPTY
99604: LIST
99605: LIST
99606: LIST
99607: PUSH
99608: LD_VAR 0 1
99612: PUSH
99613: LD_INT 3
99615: PLUS
99616: PUSH
99617: LD_VAR 0 2
99621: PUSH
99622: LD_INT 4
99624: PUSH
99625: EMPTY
99626: LIST
99627: LIST
99628: LIST
99629: PUSH
99630: LD_VAR 0 1
99634: PUSH
99635: LD_VAR 0 2
99639: PUSH
99640: LD_INT 3
99642: PLUS
99643: PUSH
99644: LD_INT 0
99646: PUSH
99647: EMPTY
99648: LIST
99649: LIST
99650: LIST
99651: PUSH
99652: EMPTY
99653: LIST
99654: LIST
99655: LIST
99656: LIST
99657: LIST
99658: ST_TO_ADDR
// end ; end ;
99659: GO 99662
99661: POP
// result := list ;
99662: LD_ADDR_VAR 0 4
99666: PUSH
99667: LD_VAR 0 5
99671: ST_TO_ADDR
// end ;
99672: LD_VAR 0 4
99676: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
99677: LD_INT 0
99679: PPUSH
99680: PPUSH
99681: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
99682: LD_VAR 0 1
99686: NOT
99687: PUSH
99688: LD_VAR 0 2
99692: PUSH
99693: LD_INT 1
99695: PUSH
99696: LD_INT 2
99698: PUSH
99699: LD_INT 3
99701: PUSH
99702: LD_INT 4
99704: PUSH
99705: EMPTY
99706: LIST
99707: LIST
99708: LIST
99709: LIST
99710: IN
99711: NOT
99712: OR
99713: IFFALSE 99717
// exit ;
99715: GO 99809
// tmp := [ ] ;
99717: LD_ADDR_VAR 0 5
99721: PUSH
99722: EMPTY
99723: ST_TO_ADDR
// for i in units do
99724: LD_ADDR_VAR 0 4
99728: PUSH
99729: LD_VAR 0 1
99733: PUSH
99734: FOR_IN
99735: IFFALSE 99778
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
99737: LD_ADDR_VAR 0 5
99741: PUSH
99742: LD_VAR 0 5
99746: PPUSH
99747: LD_VAR 0 5
99751: PUSH
99752: LD_INT 1
99754: PLUS
99755: PPUSH
99756: LD_VAR 0 4
99760: PPUSH
99761: LD_VAR 0 2
99765: PPUSH
99766: CALL_OW 259
99770: PPUSH
99771: CALL_OW 2
99775: ST_TO_ADDR
99776: GO 99734
99778: POP
99779: POP
// if not tmp then
99780: LD_VAR 0 5
99784: NOT
99785: IFFALSE 99789
// exit ;
99787: GO 99809
// result := SortListByListDesc ( units , tmp ) ;
99789: LD_ADDR_VAR 0 3
99793: PUSH
99794: LD_VAR 0 1
99798: PPUSH
99799: LD_VAR 0 5
99803: PPUSH
99804: CALL_OW 77
99808: ST_TO_ADDR
// end ;
99809: LD_VAR 0 3
99813: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
99814: LD_INT 0
99816: PPUSH
99817: PPUSH
99818: PPUSH
// result := false ;
99819: LD_ADDR_VAR 0 3
99823: PUSH
99824: LD_INT 0
99826: ST_TO_ADDR
// x := GetX ( building ) ;
99827: LD_ADDR_VAR 0 4
99831: PUSH
99832: LD_VAR 0 2
99836: PPUSH
99837: CALL_OW 250
99841: ST_TO_ADDR
// y := GetY ( building ) ;
99842: LD_ADDR_VAR 0 5
99846: PUSH
99847: LD_VAR 0 2
99851: PPUSH
99852: CALL_OW 251
99856: ST_TO_ADDR
// if not building or not x or not y then
99857: LD_VAR 0 2
99861: NOT
99862: PUSH
99863: LD_VAR 0 4
99867: NOT
99868: OR
99869: PUSH
99870: LD_VAR 0 5
99874: NOT
99875: OR
99876: IFFALSE 99880
// exit ;
99878: GO 99972
// if GetTaskList ( unit ) then
99880: LD_VAR 0 1
99884: PPUSH
99885: CALL_OW 437
99889: IFFALSE 99972
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
99891: LD_STRING e
99893: PUSH
99894: LD_VAR 0 1
99898: PPUSH
99899: CALL_OW 437
99903: PUSH
99904: LD_INT 1
99906: ARRAY
99907: PUSH
99908: LD_INT 1
99910: ARRAY
99911: EQUAL
99912: PUSH
99913: LD_VAR 0 4
99917: PUSH
99918: LD_VAR 0 1
99922: PPUSH
99923: CALL_OW 437
99927: PUSH
99928: LD_INT 1
99930: ARRAY
99931: PUSH
99932: LD_INT 2
99934: ARRAY
99935: EQUAL
99936: AND
99937: PUSH
99938: LD_VAR 0 5
99942: PUSH
99943: LD_VAR 0 1
99947: PPUSH
99948: CALL_OW 437
99952: PUSH
99953: LD_INT 1
99955: ARRAY
99956: PUSH
99957: LD_INT 3
99959: ARRAY
99960: EQUAL
99961: AND
99962: IFFALSE 99972
// result := true end ;
99964: LD_ADDR_VAR 0 3
99968: PUSH
99969: LD_INT 1
99971: ST_TO_ADDR
// end ;
99972: LD_VAR 0 3
99976: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
99977: LD_INT 0
99979: PPUSH
// result := false ;
99980: LD_ADDR_VAR 0 4
99984: PUSH
99985: LD_INT 0
99987: ST_TO_ADDR
// if GetTaskList ( unit ) then
99988: LD_VAR 0 1
99992: PPUSH
99993: CALL_OW 437
99997: IFFALSE 100080
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
99999: LD_STRING M
100001: PUSH
100002: LD_VAR 0 1
100006: PPUSH
100007: CALL_OW 437
100011: PUSH
100012: LD_INT 1
100014: ARRAY
100015: PUSH
100016: LD_INT 1
100018: ARRAY
100019: EQUAL
100020: PUSH
100021: LD_VAR 0 2
100025: PUSH
100026: LD_VAR 0 1
100030: PPUSH
100031: CALL_OW 437
100035: PUSH
100036: LD_INT 1
100038: ARRAY
100039: PUSH
100040: LD_INT 2
100042: ARRAY
100043: EQUAL
100044: AND
100045: PUSH
100046: LD_VAR 0 3
100050: PUSH
100051: LD_VAR 0 1
100055: PPUSH
100056: CALL_OW 437
100060: PUSH
100061: LD_INT 1
100063: ARRAY
100064: PUSH
100065: LD_INT 3
100067: ARRAY
100068: EQUAL
100069: AND
100070: IFFALSE 100080
// result := true ;
100072: LD_ADDR_VAR 0 4
100076: PUSH
100077: LD_INT 1
100079: ST_TO_ADDR
// end ; end ;
100080: LD_VAR 0 4
100084: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
100085: LD_INT 0
100087: PPUSH
100088: PPUSH
100089: PPUSH
100090: PPUSH
// if not unit or not area then
100091: LD_VAR 0 1
100095: NOT
100096: PUSH
100097: LD_VAR 0 2
100101: NOT
100102: OR
100103: IFFALSE 100107
// exit ;
100105: GO 100271
// tmp := AreaToList ( area , i ) ;
100107: LD_ADDR_VAR 0 6
100111: PUSH
100112: LD_VAR 0 2
100116: PPUSH
100117: LD_VAR 0 5
100121: PPUSH
100122: CALL_OW 517
100126: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
100127: LD_ADDR_VAR 0 5
100131: PUSH
100132: DOUBLE
100133: LD_INT 1
100135: DEC
100136: ST_TO_ADDR
100137: LD_VAR 0 6
100141: PUSH
100142: LD_INT 1
100144: ARRAY
100145: PUSH
100146: FOR_TO
100147: IFFALSE 100269
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
100149: LD_ADDR_VAR 0 7
100153: PUSH
100154: LD_VAR 0 6
100158: PUSH
100159: LD_INT 1
100161: ARRAY
100162: PUSH
100163: LD_VAR 0 5
100167: ARRAY
100168: PUSH
100169: LD_VAR 0 6
100173: PUSH
100174: LD_INT 2
100176: ARRAY
100177: PUSH
100178: LD_VAR 0 5
100182: ARRAY
100183: PUSH
100184: EMPTY
100185: LIST
100186: LIST
100187: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
100188: LD_VAR 0 7
100192: PUSH
100193: LD_INT 1
100195: ARRAY
100196: PPUSH
100197: LD_VAR 0 7
100201: PUSH
100202: LD_INT 2
100204: ARRAY
100205: PPUSH
100206: CALL_OW 428
100210: PUSH
100211: LD_INT 0
100213: EQUAL
100214: IFFALSE 100267
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
100216: LD_VAR 0 1
100220: PPUSH
100221: LD_VAR 0 7
100225: PUSH
100226: LD_INT 1
100228: ARRAY
100229: PPUSH
100230: LD_VAR 0 7
100234: PUSH
100235: LD_INT 2
100237: ARRAY
100238: PPUSH
100239: LD_VAR 0 3
100243: PPUSH
100244: CALL_OW 48
// result := IsPlaced ( unit ) ;
100248: LD_ADDR_VAR 0 4
100252: PUSH
100253: LD_VAR 0 1
100257: PPUSH
100258: CALL_OW 305
100262: ST_TO_ADDR
// exit ;
100263: POP
100264: POP
100265: GO 100271
// end ; end ;
100267: GO 100146
100269: POP
100270: POP
// end ;
100271: LD_VAR 0 4
100275: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
100276: LD_INT 0
100278: PPUSH
100279: PPUSH
100280: PPUSH
// if not side or side > 8 then
100281: LD_VAR 0 1
100285: NOT
100286: PUSH
100287: LD_VAR 0 1
100291: PUSH
100292: LD_INT 8
100294: GREATER
100295: OR
100296: IFFALSE 100300
// exit ;
100298: GO 100487
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
100300: LD_ADDR_VAR 0 4
100304: PUSH
100305: LD_INT 22
100307: PUSH
100308: LD_VAR 0 1
100312: PUSH
100313: EMPTY
100314: LIST
100315: LIST
100316: PUSH
100317: LD_INT 21
100319: PUSH
100320: LD_INT 3
100322: PUSH
100323: EMPTY
100324: LIST
100325: LIST
100326: PUSH
100327: EMPTY
100328: LIST
100329: LIST
100330: PPUSH
100331: CALL_OW 69
100335: ST_TO_ADDR
// if not tmp then
100336: LD_VAR 0 4
100340: NOT
100341: IFFALSE 100345
// exit ;
100343: GO 100487
// enable_addtolog := true ;
100345: LD_ADDR_OWVAR 81
100349: PUSH
100350: LD_INT 1
100352: ST_TO_ADDR
// AddToLog ( [ ) ;
100353: LD_STRING [
100355: PPUSH
100356: CALL_OW 561
// for i in tmp do
100360: LD_ADDR_VAR 0 3
100364: PUSH
100365: LD_VAR 0 4
100369: PUSH
100370: FOR_IN
100371: IFFALSE 100478
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
100373: LD_STRING [
100375: PUSH
100376: LD_VAR 0 3
100380: PPUSH
100381: CALL_OW 266
100385: STR
100386: PUSH
100387: LD_STRING , 
100389: STR
100390: PUSH
100391: LD_VAR 0 3
100395: PPUSH
100396: CALL_OW 250
100400: STR
100401: PUSH
100402: LD_STRING , 
100404: STR
100405: PUSH
100406: LD_VAR 0 3
100410: PPUSH
100411: CALL_OW 251
100415: STR
100416: PUSH
100417: LD_STRING , 
100419: STR
100420: PUSH
100421: LD_VAR 0 3
100425: PPUSH
100426: CALL_OW 254
100430: STR
100431: PUSH
100432: LD_STRING , 
100434: STR
100435: PUSH
100436: LD_VAR 0 3
100440: PPUSH
100441: LD_INT 1
100443: PPUSH
100444: CALL_OW 268
100448: STR
100449: PUSH
100450: LD_STRING , 
100452: STR
100453: PUSH
100454: LD_VAR 0 3
100458: PPUSH
100459: LD_INT 2
100461: PPUSH
100462: CALL_OW 268
100466: STR
100467: PUSH
100468: LD_STRING ],
100470: STR
100471: PPUSH
100472: CALL_OW 561
// end ;
100476: GO 100370
100478: POP
100479: POP
// AddToLog ( ]; ) ;
100480: LD_STRING ];
100482: PPUSH
100483: CALL_OW 561
// end ;
100487: LD_VAR 0 2
100491: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
100492: LD_INT 0
100494: PPUSH
100495: PPUSH
100496: PPUSH
100497: PPUSH
100498: PPUSH
// if not area or not rate or not max then
100499: LD_VAR 0 1
100503: NOT
100504: PUSH
100505: LD_VAR 0 2
100509: NOT
100510: OR
100511: PUSH
100512: LD_VAR 0 4
100516: NOT
100517: OR
100518: IFFALSE 100522
// exit ;
100520: GO 100714
// while 1 do
100522: LD_INT 1
100524: IFFALSE 100714
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
100526: LD_ADDR_VAR 0 9
100530: PUSH
100531: LD_VAR 0 1
100535: PPUSH
100536: LD_INT 1
100538: PPUSH
100539: CALL_OW 287
100543: PUSH
100544: LD_INT 10
100546: MUL
100547: ST_TO_ADDR
// r := rate / 10 ;
100548: LD_ADDR_VAR 0 7
100552: PUSH
100553: LD_VAR 0 2
100557: PUSH
100558: LD_INT 10
100560: DIVREAL
100561: ST_TO_ADDR
// time := 1 1$00 ;
100562: LD_ADDR_VAR 0 8
100566: PUSH
100567: LD_INT 2100
100569: ST_TO_ADDR
// if amount < min then
100570: LD_VAR 0 9
100574: PUSH
100575: LD_VAR 0 3
100579: LESS
100580: IFFALSE 100598
// r := r * 2 else
100582: LD_ADDR_VAR 0 7
100586: PUSH
100587: LD_VAR 0 7
100591: PUSH
100592: LD_INT 2
100594: MUL
100595: ST_TO_ADDR
100596: GO 100624
// if amount > max then
100598: LD_VAR 0 9
100602: PUSH
100603: LD_VAR 0 4
100607: GREATER
100608: IFFALSE 100624
// r := r / 2 ;
100610: LD_ADDR_VAR 0 7
100614: PUSH
100615: LD_VAR 0 7
100619: PUSH
100620: LD_INT 2
100622: DIVREAL
100623: ST_TO_ADDR
// time := time / r ;
100624: LD_ADDR_VAR 0 8
100628: PUSH
100629: LD_VAR 0 8
100633: PUSH
100634: LD_VAR 0 7
100638: DIVREAL
100639: ST_TO_ADDR
// if time < 0 then
100640: LD_VAR 0 8
100644: PUSH
100645: LD_INT 0
100647: LESS
100648: IFFALSE 100665
// time := time * - 1 ;
100650: LD_ADDR_VAR 0 8
100654: PUSH
100655: LD_VAR 0 8
100659: PUSH
100660: LD_INT 1
100662: NEG
100663: MUL
100664: ST_TO_ADDR
// wait ( time ) ;
100665: LD_VAR 0 8
100669: PPUSH
100670: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
100674: LD_INT 35
100676: PPUSH
100677: LD_INT 875
100679: PPUSH
100680: CALL_OW 12
100684: PPUSH
100685: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
100689: LD_INT 1
100691: PPUSH
100692: LD_INT 5
100694: PPUSH
100695: CALL_OW 12
100699: PPUSH
100700: LD_VAR 0 1
100704: PPUSH
100705: LD_INT 1
100707: PPUSH
100708: CALL_OW 55
// end ;
100712: GO 100522
// end ;
100714: LD_VAR 0 5
100718: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
100719: LD_INT 0
100721: PPUSH
100722: PPUSH
100723: PPUSH
100724: PPUSH
100725: PPUSH
100726: PPUSH
100727: PPUSH
100728: PPUSH
// if not turrets or not factories then
100729: LD_VAR 0 1
100733: NOT
100734: PUSH
100735: LD_VAR 0 2
100739: NOT
100740: OR
100741: IFFALSE 100745
// exit ;
100743: GO 101052
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
100745: LD_ADDR_VAR 0 10
100749: PUSH
100750: LD_INT 5
100752: PUSH
100753: LD_INT 6
100755: PUSH
100756: EMPTY
100757: LIST
100758: LIST
100759: PUSH
100760: LD_INT 2
100762: PUSH
100763: LD_INT 4
100765: PUSH
100766: EMPTY
100767: LIST
100768: LIST
100769: PUSH
100770: LD_INT 3
100772: PUSH
100773: LD_INT 5
100775: PUSH
100776: EMPTY
100777: LIST
100778: LIST
100779: PUSH
100780: EMPTY
100781: LIST
100782: LIST
100783: LIST
100784: PUSH
100785: LD_INT 24
100787: PUSH
100788: LD_INT 25
100790: PUSH
100791: EMPTY
100792: LIST
100793: LIST
100794: PUSH
100795: LD_INT 23
100797: PUSH
100798: LD_INT 27
100800: PUSH
100801: EMPTY
100802: LIST
100803: LIST
100804: PUSH
100805: EMPTY
100806: LIST
100807: LIST
100808: PUSH
100809: LD_INT 42
100811: PUSH
100812: LD_INT 43
100814: PUSH
100815: EMPTY
100816: LIST
100817: LIST
100818: PUSH
100819: LD_INT 44
100821: PUSH
100822: LD_INT 46
100824: PUSH
100825: EMPTY
100826: LIST
100827: LIST
100828: PUSH
100829: LD_INT 45
100831: PUSH
100832: LD_INT 47
100834: PUSH
100835: EMPTY
100836: LIST
100837: LIST
100838: PUSH
100839: EMPTY
100840: LIST
100841: LIST
100842: LIST
100843: PUSH
100844: EMPTY
100845: LIST
100846: LIST
100847: LIST
100848: ST_TO_ADDR
// result := [ ] ;
100849: LD_ADDR_VAR 0 3
100853: PUSH
100854: EMPTY
100855: ST_TO_ADDR
// for i in turrets do
100856: LD_ADDR_VAR 0 4
100860: PUSH
100861: LD_VAR 0 1
100865: PUSH
100866: FOR_IN
100867: IFFALSE 101050
// begin nat := GetNation ( i ) ;
100869: LD_ADDR_VAR 0 7
100873: PUSH
100874: LD_VAR 0 4
100878: PPUSH
100879: CALL_OW 248
100883: ST_TO_ADDR
// weapon := 0 ;
100884: LD_ADDR_VAR 0 8
100888: PUSH
100889: LD_INT 0
100891: ST_TO_ADDR
// if not nat then
100892: LD_VAR 0 7
100896: NOT
100897: IFFALSE 100901
// continue ;
100899: GO 100866
// for j in list [ nat ] do
100901: LD_ADDR_VAR 0 5
100905: PUSH
100906: LD_VAR 0 10
100910: PUSH
100911: LD_VAR 0 7
100915: ARRAY
100916: PUSH
100917: FOR_IN
100918: IFFALSE 100959
// if GetBWeapon ( i ) = j [ 1 ] then
100920: LD_VAR 0 4
100924: PPUSH
100925: CALL_OW 269
100929: PUSH
100930: LD_VAR 0 5
100934: PUSH
100935: LD_INT 1
100937: ARRAY
100938: EQUAL
100939: IFFALSE 100957
// begin weapon := j [ 2 ] ;
100941: LD_ADDR_VAR 0 8
100945: PUSH
100946: LD_VAR 0 5
100950: PUSH
100951: LD_INT 2
100953: ARRAY
100954: ST_TO_ADDR
// break ;
100955: GO 100959
// end ;
100957: GO 100917
100959: POP
100960: POP
// if not weapon then
100961: LD_VAR 0 8
100965: NOT
100966: IFFALSE 100970
// continue ;
100968: GO 100866
// for k in factories do
100970: LD_ADDR_VAR 0 6
100974: PUSH
100975: LD_VAR 0 2
100979: PUSH
100980: FOR_IN
100981: IFFALSE 101046
// begin weapons := AvailableWeaponList ( k ) ;
100983: LD_ADDR_VAR 0 9
100987: PUSH
100988: LD_VAR 0 6
100992: PPUSH
100993: CALL_OW 478
100997: ST_TO_ADDR
// if not weapons then
100998: LD_VAR 0 9
101002: NOT
101003: IFFALSE 101007
// continue ;
101005: GO 100980
// if weapon in weapons then
101007: LD_VAR 0 8
101011: PUSH
101012: LD_VAR 0 9
101016: IN
101017: IFFALSE 101044
// begin result := [ i , weapon ] ;
101019: LD_ADDR_VAR 0 3
101023: PUSH
101024: LD_VAR 0 4
101028: PUSH
101029: LD_VAR 0 8
101033: PUSH
101034: EMPTY
101035: LIST
101036: LIST
101037: ST_TO_ADDR
// exit ;
101038: POP
101039: POP
101040: POP
101041: POP
101042: GO 101052
// end ; end ;
101044: GO 100980
101046: POP
101047: POP
// end ;
101048: GO 100866
101050: POP
101051: POP
// end ;
101052: LD_VAR 0 3
101056: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
101057: LD_INT 0
101059: PPUSH
// if not side or side > 8 then
101060: LD_VAR 0 3
101064: NOT
101065: PUSH
101066: LD_VAR 0 3
101070: PUSH
101071: LD_INT 8
101073: GREATER
101074: OR
101075: IFFALSE 101079
// exit ;
101077: GO 101138
// if not range then
101079: LD_VAR 0 4
101083: NOT
101084: IFFALSE 101095
// range := - 12 ;
101086: LD_ADDR_VAR 0 4
101090: PUSH
101091: LD_INT 12
101093: NEG
101094: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
101095: LD_VAR 0 1
101099: PPUSH
101100: LD_VAR 0 2
101104: PPUSH
101105: LD_VAR 0 3
101109: PPUSH
101110: LD_VAR 0 4
101114: PPUSH
101115: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
101119: LD_VAR 0 1
101123: PPUSH
101124: LD_VAR 0 2
101128: PPUSH
101129: LD_VAR 0 3
101133: PPUSH
101134: CALL_OW 331
// end ;
101138: LD_VAR 0 5
101142: RET
// export function Video ( mode ) ; begin
101143: LD_INT 0
101145: PPUSH
// ingame_video = mode ;
101146: LD_ADDR_OWVAR 52
101150: PUSH
101151: LD_VAR 0 1
101155: ST_TO_ADDR
// interface_hidden = mode ;
101156: LD_ADDR_OWVAR 54
101160: PUSH
101161: LD_VAR 0 1
101165: ST_TO_ADDR
// end ;
101166: LD_VAR 0 2
101170: RET
// export function Join ( array , element ) ; begin
101171: LD_INT 0
101173: PPUSH
// result := Replace ( array , array + 1 , element ) ;
101174: LD_ADDR_VAR 0 3
101178: PUSH
101179: LD_VAR 0 1
101183: PPUSH
101184: LD_VAR 0 1
101188: PUSH
101189: LD_INT 1
101191: PLUS
101192: PPUSH
101193: LD_VAR 0 2
101197: PPUSH
101198: CALL_OW 1
101202: ST_TO_ADDR
// end ;
101203: LD_VAR 0 3
101207: RET
// export function JoinUnion ( array , element ) ; begin
101208: LD_INT 0
101210: PPUSH
// result := array union element ;
101211: LD_ADDR_VAR 0 3
101215: PUSH
101216: LD_VAR 0 1
101220: PUSH
101221: LD_VAR 0 2
101225: UNION
101226: ST_TO_ADDR
// end ;
101227: LD_VAR 0 3
101231: RET
// export function GetBehemoths ( side ) ; begin
101232: LD_INT 0
101234: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
101235: LD_ADDR_VAR 0 2
101239: PUSH
101240: LD_INT 22
101242: PUSH
101243: LD_VAR 0 1
101247: PUSH
101248: EMPTY
101249: LIST
101250: LIST
101251: PUSH
101252: LD_INT 31
101254: PUSH
101255: LD_INT 25
101257: PUSH
101258: EMPTY
101259: LIST
101260: LIST
101261: PUSH
101262: EMPTY
101263: LIST
101264: LIST
101265: PPUSH
101266: CALL_OW 69
101270: ST_TO_ADDR
// end ;
101271: LD_VAR 0 2
101275: RET
// export function Shuffle ( array ) ; var i , index ; begin
101276: LD_INT 0
101278: PPUSH
101279: PPUSH
101280: PPUSH
// result := [ ] ;
101281: LD_ADDR_VAR 0 2
101285: PUSH
101286: EMPTY
101287: ST_TO_ADDR
// if not array then
101288: LD_VAR 0 1
101292: NOT
101293: IFFALSE 101297
// exit ;
101295: GO 101396
// Randomize ;
101297: CALL_OW 10
// for i = array downto 1 do
101301: LD_ADDR_VAR 0 3
101305: PUSH
101306: DOUBLE
101307: LD_VAR 0 1
101311: INC
101312: ST_TO_ADDR
101313: LD_INT 1
101315: PUSH
101316: FOR_DOWNTO
101317: IFFALSE 101394
// begin index := rand ( 1 , array ) ;
101319: LD_ADDR_VAR 0 4
101323: PUSH
101324: LD_INT 1
101326: PPUSH
101327: LD_VAR 0 1
101331: PPUSH
101332: CALL_OW 12
101336: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
101337: LD_ADDR_VAR 0 2
101341: PUSH
101342: LD_VAR 0 2
101346: PPUSH
101347: LD_VAR 0 2
101351: PUSH
101352: LD_INT 1
101354: PLUS
101355: PPUSH
101356: LD_VAR 0 1
101360: PUSH
101361: LD_VAR 0 4
101365: ARRAY
101366: PPUSH
101367: CALL_OW 2
101371: ST_TO_ADDR
// array := Delete ( array , index ) ;
101372: LD_ADDR_VAR 0 1
101376: PUSH
101377: LD_VAR 0 1
101381: PPUSH
101382: LD_VAR 0 4
101386: PPUSH
101387: CALL_OW 3
101391: ST_TO_ADDR
// end ;
101392: GO 101316
101394: POP
101395: POP
// end ;
101396: LD_VAR 0 2
101400: RET
// export function GetBaseMaterials ( base ) ; begin
101401: LD_INT 0
101403: PPUSH
// result := [ 0 , 0 , 0 ] ;
101404: LD_ADDR_VAR 0 2
101408: PUSH
101409: LD_INT 0
101411: PUSH
101412: LD_INT 0
101414: PUSH
101415: LD_INT 0
101417: PUSH
101418: EMPTY
101419: LIST
101420: LIST
101421: LIST
101422: ST_TO_ADDR
// if not base then
101423: LD_VAR 0 1
101427: NOT
101428: IFFALSE 101432
// exit ;
101430: GO 101481
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
101432: LD_ADDR_VAR 0 2
101436: PUSH
101437: LD_VAR 0 1
101441: PPUSH
101442: LD_INT 1
101444: PPUSH
101445: CALL_OW 275
101449: PUSH
101450: LD_VAR 0 1
101454: PPUSH
101455: LD_INT 2
101457: PPUSH
101458: CALL_OW 275
101462: PUSH
101463: LD_VAR 0 1
101467: PPUSH
101468: LD_INT 3
101470: PPUSH
101471: CALL_OW 275
101475: PUSH
101476: EMPTY
101477: LIST
101478: LIST
101479: LIST
101480: ST_TO_ADDR
// end ;
101481: LD_VAR 0 2
101485: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
101486: LD_INT 0
101488: PPUSH
101489: PPUSH
// result := array ;
101490: LD_ADDR_VAR 0 3
101494: PUSH
101495: LD_VAR 0 1
101499: ST_TO_ADDR
// if size > 0 then
101500: LD_VAR 0 2
101504: PUSH
101505: LD_INT 0
101507: GREATER
101508: IFFALSE 101554
// for i := array downto size do
101510: LD_ADDR_VAR 0 4
101514: PUSH
101515: DOUBLE
101516: LD_VAR 0 1
101520: INC
101521: ST_TO_ADDR
101522: LD_VAR 0 2
101526: PUSH
101527: FOR_DOWNTO
101528: IFFALSE 101552
// result := Delete ( result , result ) ;
101530: LD_ADDR_VAR 0 3
101534: PUSH
101535: LD_VAR 0 3
101539: PPUSH
101540: LD_VAR 0 3
101544: PPUSH
101545: CALL_OW 3
101549: ST_TO_ADDR
101550: GO 101527
101552: POP
101553: POP
// end ;
101554: LD_VAR 0 3
101558: RET
// export function ComExit ( unit ) ; var tmp ; begin
101559: LD_INT 0
101561: PPUSH
101562: PPUSH
// if not IsInUnit ( unit ) then
101563: LD_VAR 0 1
101567: PPUSH
101568: CALL_OW 310
101572: NOT
101573: IFFALSE 101577
// exit ;
101575: GO 101637
// tmp := IsInUnit ( unit ) ;
101577: LD_ADDR_VAR 0 3
101581: PUSH
101582: LD_VAR 0 1
101586: PPUSH
101587: CALL_OW 310
101591: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
101592: LD_VAR 0 3
101596: PPUSH
101597: CALL_OW 247
101601: PUSH
101602: LD_INT 2
101604: EQUAL
101605: IFFALSE 101618
// ComExitVehicle ( unit ) else
101607: LD_VAR 0 1
101611: PPUSH
101612: CALL_OW 121
101616: GO 101627
// ComExitBuilding ( unit ) ;
101618: LD_VAR 0 1
101622: PPUSH
101623: CALL_OW 122
// result := tmp ;
101627: LD_ADDR_VAR 0 2
101631: PUSH
101632: LD_VAR 0 3
101636: ST_TO_ADDR
// end ;
101637: LD_VAR 0 2
101641: RET
// export function ResetHc ; begin
101642: LD_INT 0
101644: PPUSH
// InitHc ;
101645: CALL_OW 19
// hc_importance := 0 ;
101649: LD_ADDR_OWVAR 32
101653: PUSH
101654: LD_INT 0
101656: ST_TO_ADDR
// end ;
101657: LD_VAR 0 1
101661: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
101662: LD_INT 0
101664: PPUSH
101665: PPUSH
101666: PPUSH
// _x := ( x1 + x2 ) div 2 ;
101667: LD_ADDR_VAR 0 6
101671: PUSH
101672: LD_VAR 0 1
101676: PUSH
101677: LD_VAR 0 3
101681: PLUS
101682: PUSH
101683: LD_INT 2
101685: DIV
101686: ST_TO_ADDR
// if _x < 0 then
101687: LD_VAR 0 6
101691: PUSH
101692: LD_INT 0
101694: LESS
101695: IFFALSE 101712
// _x := _x * - 1 ;
101697: LD_ADDR_VAR 0 6
101701: PUSH
101702: LD_VAR 0 6
101706: PUSH
101707: LD_INT 1
101709: NEG
101710: MUL
101711: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
101712: LD_ADDR_VAR 0 7
101716: PUSH
101717: LD_VAR 0 2
101721: PUSH
101722: LD_VAR 0 4
101726: PLUS
101727: PUSH
101728: LD_INT 2
101730: DIV
101731: ST_TO_ADDR
// if _y < 0 then
101732: LD_VAR 0 7
101736: PUSH
101737: LD_INT 0
101739: LESS
101740: IFFALSE 101757
// _y := _y * - 1 ;
101742: LD_ADDR_VAR 0 7
101746: PUSH
101747: LD_VAR 0 7
101751: PUSH
101752: LD_INT 1
101754: NEG
101755: MUL
101756: ST_TO_ADDR
// result := [ _x , _y ] ;
101757: LD_ADDR_VAR 0 5
101761: PUSH
101762: LD_VAR 0 6
101766: PUSH
101767: LD_VAR 0 7
101771: PUSH
101772: EMPTY
101773: LIST
101774: LIST
101775: ST_TO_ADDR
// end ;
101776: LD_VAR 0 5
101780: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
101781: LD_INT 0
101783: PPUSH
101784: PPUSH
101785: PPUSH
101786: PPUSH
// task := GetTaskList ( unit ) ;
101787: LD_ADDR_VAR 0 7
101791: PUSH
101792: LD_VAR 0 1
101796: PPUSH
101797: CALL_OW 437
101801: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
101802: LD_VAR 0 7
101806: NOT
101807: PUSH
101808: LD_VAR 0 1
101812: PPUSH
101813: LD_VAR 0 2
101817: PPUSH
101818: CALL_OW 308
101822: NOT
101823: AND
101824: IFFALSE 101828
// exit ;
101826: GO 101946
// if IsInArea ( unit , area ) then
101828: LD_VAR 0 1
101832: PPUSH
101833: LD_VAR 0 2
101837: PPUSH
101838: CALL_OW 308
101842: IFFALSE 101860
// begin ComMoveToArea ( unit , goAway ) ;
101844: LD_VAR 0 1
101848: PPUSH
101849: LD_VAR 0 3
101853: PPUSH
101854: CALL_OW 113
// exit ;
101858: GO 101946
// end ; if task [ 1 ] [ 1 ] <> M then
101860: LD_VAR 0 7
101864: PUSH
101865: LD_INT 1
101867: ARRAY
101868: PUSH
101869: LD_INT 1
101871: ARRAY
101872: PUSH
101873: LD_STRING M
101875: NONEQUAL
101876: IFFALSE 101880
// exit ;
101878: GO 101946
// x := task [ 1 ] [ 2 ] ;
101880: LD_ADDR_VAR 0 5
101884: PUSH
101885: LD_VAR 0 7
101889: PUSH
101890: LD_INT 1
101892: ARRAY
101893: PUSH
101894: LD_INT 2
101896: ARRAY
101897: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
101898: LD_ADDR_VAR 0 6
101902: PUSH
101903: LD_VAR 0 7
101907: PUSH
101908: LD_INT 1
101910: ARRAY
101911: PUSH
101912: LD_INT 3
101914: ARRAY
101915: ST_TO_ADDR
// if InArea ( x , y , area ) then
101916: LD_VAR 0 5
101920: PPUSH
101921: LD_VAR 0 6
101925: PPUSH
101926: LD_VAR 0 2
101930: PPUSH
101931: CALL_OW 309
101935: IFFALSE 101946
// ComStop ( unit ) ;
101937: LD_VAR 0 1
101941: PPUSH
101942: CALL_OW 141
// end ;
101946: LD_VAR 0 4
101950: RET
// export function Abs ( value ) ; begin
101951: LD_INT 0
101953: PPUSH
// result := value ;
101954: LD_ADDR_VAR 0 2
101958: PUSH
101959: LD_VAR 0 1
101963: ST_TO_ADDR
// if value < 0 then
101964: LD_VAR 0 1
101968: PUSH
101969: LD_INT 0
101971: LESS
101972: IFFALSE 101989
// result := value * - 1 ;
101974: LD_ADDR_VAR 0 2
101978: PUSH
101979: LD_VAR 0 1
101983: PUSH
101984: LD_INT 1
101986: NEG
101987: MUL
101988: ST_TO_ADDR
// end ;
101989: LD_VAR 0 2
101993: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
101994: LD_INT 0
101996: PPUSH
101997: PPUSH
101998: PPUSH
101999: PPUSH
102000: PPUSH
102001: PPUSH
102002: PPUSH
102003: PPUSH
// if not unit or not building then
102004: LD_VAR 0 1
102008: NOT
102009: PUSH
102010: LD_VAR 0 2
102014: NOT
102015: OR
102016: IFFALSE 102020
// exit ;
102018: GO 102246
// x := GetX ( building ) ;
102020: LD_ADDR_VAR 0 4
102024: PUSH
102025: LD_VAR 0 2
102029: PPUSH
102030: CALL_OW 250
102034: ST_TO_ADDR
// y := GetY ( building ) ;
102035: LD_ADDR_VAR 0 6
102039: PUSH
102040: LD_VAR 0 2
102044: PPUSH
102045: CALL_OW 251
102049: ST_TO_ADDR
// d := GetDir ( building ) ;
102050: LD_ADDR_VAR 0 8
102054: PUSH
102055: LD_VAR 0 2
102059: PPUSH
102060: CALL_OW 254
102064: ST_TO_ADDR
// r := 4 ;
102065: LD_ADDR_VAR 0 9
102069: PUSH
102070: LD_INT 4
102072: ST_TO_ADDR
// for i := 1 to 5 do
102073: LD_ADDR_VAR 0 10
102077: PUSH
102078: DOUBLE
102079: LD_INT 1
102081: DEC
102082: ST_TO_ADDR
102083: LD_INT 5
102085: PUSH
102086: FOR_TO
102087: IFFALSE 102244
// begin _x := ShiftX ( x , d , r + i ) ;
102089: LD_ADDR_VAR 0 5
102093: PUSH
102094: LD_VAR 0 4
102098: PPUSH
102099: LD_VAR 0 8
102103: PPUSH
102104: LD_VAR 0 9
102108: PUSH
102109: LD_VAR 0 10
102113: PLUS
102114: PPUSH
102115: CALL_OW 272
102119: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
102120: LD_ADDR_VAR 0 7
102124: PUSH
102125: LD_VAR 0 6
102129: PPUSH
102130: LD_VAR 0 8
102134: PPUSH
102135: LD_VAR 0 9
102139: PUSH
102140: LD_VAR 0 10
102144: PLUS
102145: PPUSH
102146: CALL_OW 273
102150: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
102151: LD_VAR 0 5
102155: PPUSH
102156: LD_VAR 0 7
102160: PPUSH
102161: CALL_OW 488
102165: PUSH
102166: LD_VAR 0 5
102170: PPUSH
102171: LD_VAR 0 7
102175: PPUSH
102176: CALL_OW 428
102180: PPUSH
102181: CALL_OW 247
102185: PUSH
102186: LD_INT 3
102188: PUSH
102189: LD_INT 2
102191: PUSH
102192: EMPTY
102193: LIST
102194: LIST
102195: IN
102196: NOT
102197: AND
102198: IFFALSE 102242
// begin ComMoveXY ( unit , _x , _y ) ;
102200: LD_VAR 0 1
102204: PPUSH
102205: LD_VAR 0 5
102209: PPUSH
102210: LD_VAR 0 7
102214: PPUSH
102215: CALL_OW 111
// result := [ _x , _y ] ;
102219: LD_ADDR_VAR 0 3
102223: PUSH
102224: LD_VAR 0 5
102228: PUSH
102229: LD_VAR 0 7
102233: PUSH
102234: EMPTY
102235: LIST
102236: LIST
102237: ST_TO_ADDR
// exit ;
102238: POP
102239: POP
102240: GO 102246
// end ; end ;
102242: GO 102086
102244: POP
102245: POP
// end ; end_of_file end_of_file
102246: LD_VAR 0 3
102250: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
102251: LD_VAR 0 2
102255: PUSH
102256: LD_INT 100
102258: EQUAL
102259: IFFALSE 103208
// begin if not StreamModeActive then
102261: LD_EXP 156
102265: NOT
102266: IFFALSE 102276
// StreamModeActive := true ;
102268: LD_ADDR_EXP 156
102272: PUSH
102273: LD_INT 1
102275: ST_TO_ADDR
// if p3 = 0 then
102276: LD_VAR 0 3
102280: PUSH
102281: LD_INT 0
102283: EQUAL
102284: IFFALSE 102290
// InitStreamMode ;
102286: CALL 103366 0 0
// if p3 = 1 then
102290: LD_VAR 0 3
102294: PUSH
102295: LD_INT 1
102297: EQUAL
102298: IFFALSE 102308
// sRocket := true ;
102300: LD_ADDR_EXP 161
102304: PUSH
102305: LD_INT 1
102307: ST_TO_ADDR
// if p3 = 2 then
102308: LD_VAR 0 3
102312: PUSH
102313: LD_INT 2
102315: EQUAL
102316: IFFALSE 102326
// sSpeed := true ;
102318: LD_ADDR_EXP 160
102322: PUSH
102323: LD_INT 1
102325: ST_TO_ADDR
// if p3 = 3 then
102326: LD_VAR 0 3
102330: PUSH
102331: LD_INT 3
102333: EQUAL
102334: IFFALSE 102344
// sEngine := true ;
102336: LD_ADDR_EXP 162
102340: PUSH
102341: LD_INT 1
102343: ST_TO_ADDR
// if p3 = 4 then
102344: LD_VAR 0 3
102348: PUSH
102349: LD_INT 4
102351: EQUAL
102352: IFFALSE 102362
// sSpec := true ;
102354: LD_ADDR_EXP 159
102358: PUSH
102359: LD_INT 1
102361: ST_TO_ADDR
// if p3 = 5 then
102362: LD_VAR 0 3
102366: PUSH
102367: LD_INT 5
102369: EQUAL
102370: IFFALSE 102380
// sLevel := true ;
102372: LD_ADDR_EXP 163
102376: PUSH
102377: LD_INT 1
102379: ST_TO_ADDR
// if p3 = 6 then
102380: LD_VAR 0 3
102384: PUSH
102385: LD_INT 6
102387: EQUAL
102388: IFFALSE 102398
// sArmoury := true ;
102390: LD_ADDR_EXP 164
102394: PUSH
102395: LD_INT 1
102397: ST_TO_ADDR
// if p3 = 7 then
102398: LD_VAR 0 3
102402: PUSH
102403: LD_INT 7
102405: EQUAL
102406: IFFALSE 102416
// sRadar := true ;
102408: LD_ADDR_EXP 165
102412: PUSH
102413: LD_INT 1
102415: ST_TO_ADDR
// if p3 = 8 then
102416: LD_VAR 0 3
102420: PUSH
102421: LD_INT 8
102423: EQUAL
102424: IFFALSE 102434
// sBunker := true ;
102426: LD_ADDR_EXP 166
102430: PUSH
102431: LD_INT 1
102433: ST_TO_ADDR
// if p3 = 9 then
102434: LD_VAR 0 3
102438: PUSH
102439: LD_INT 9
102441: EQUAL
102442: IFFALSE 102452
// sHack := true ;
102444: LD_ADDR_EXP 167
102448: PUSH
102449: LD_INT 1
102451: ST_TO_ADDR
// if p3 = 10 then
102452: LD_VAR 0 3
102456: PUSH
102457: LD_INT 10
102459: EQUAL
102460: IFFALSE 102470
// sFire := true ;
102462: LD_ADDR_EXP 168
102466: PUSH
102467: LD_INT 1
102469: ST_TO_ADDR
// if p3 = 11 then
102470: LD_VAR 0 3
102474: PUSH
102475: LD_INT 11
102477: EQUAL
102478: IFFALSE 102488
// sRefresh := true ;
102480: LD_ADDR_EXP 169
102484: PUSH
102485: LD_INT 1
102487: ST_TO_ADDR
// if p3 = 12 then
102488: LD_VAR 0 3
102492: PUSH
102493: LD_INT 12
102495: EQUAL
102496: IFFALSE 102506
// sExp := true ;
102498: LD_ADDR_EXP 170
102502: PUSH
102503: LD_INT 1
102505: ST_TO_ADDR
// if p3 = 13 then
102506: LD_VAR 0 3
102510: PUSH
102511: LD_INT 13
102513: EQUAL
102514: IFFALSE 102524
// sDepot := true ;
102516: LD_ADDR_EXP 171
102520: PUSH
102521: LD_INT 1
102523: ST_TO_ADDR
// if p3 = 14 then
102524: LD_VAR 0 3
102528: PUSH
102529: LD_INT 14
102531: EQUAL
102532: IFFALSE 102542
// sFlag := true ;
102534: LD_ADDR_EXP 172
102538: PUSH
102539: LD_INT 1
102541: ST_TO_ADDR
// if p3 = 15 then
102542: LD_VAR 0 3
102546: PUSH
102547: LD_INT 15
102549: EQUAL
102550: IFFALSE 102560
// sKamikadze := true ;
102552: LD_ADDR_EXP 180
102556: PUSH
102557: LD_INT 1
102559: ST_TO_ADDR
// if p3 = 16 then
102560: LD_VAR 0 3
102564: PUSH
102565: LD_INT 16
102567: EQUAL
102568: IFFALSE 102578
// sTroll := true ;
102570: LD_ADDR_EXP 181
102574: PUSH
102575: LD_INT 1
102577: ST_TO_ADDR
// if p3 = 17 then
102578: LD_VAR 0 3
102582: PUSH
102583: LD_INT 17
102585: EQUAL
102586: IFFALSE 102596
// sSlow := true ;
102588: LD_ADDR_EXP 182
102592: PUSH
102593: LD_INT 1
102595: ST_TO_ADDR
// if p3 = 18 then
102596: LD_VAR 0 3
102600: PUSH
102601: LD_INT 18
102603: EQUAL
102604: IFFALSE 102614
// sLack := true ;
102606: LD_ADDR_EXP 183
102610: PUSH
102611: LD_INT 1
102613: ST_TO_ADDR
// if p3 = 19 then
102614: LD_VAR 0 3
102618: PUSH
102619: LD_INT 19
102621: EQUAL
102622: IFFALSE 102632
// sTank := true ;
102624: LD_ADDR_EXP 185
102628: PUSH
102629: LD_INT 1
102631: ST_TO_ADDR
// if p3 = 20 then
102632: LD_VAR 0 3
102636: PUSH
102637: LD_INT 20
102639: EQUAL
102640: IFFALSE 102650
// sRemote := true ;
102642: LD_ADDR_EXP 186
102646: PUSH
102647: LD_INT 1
102649: ST_TO_ADDR
// if p3 = 21 then
102650: LD_VAR 0 3
102654: PUSH
102655: LD_INT 21
102657: EQUAL
102658: IFFALSE 102668
// sPowell := true ;
102660: LD_ADDR_EXP 187
102664: PUSH
102665: LD_INT 1
102667: ST_TO_ADDR
// if p3 = 22 then
102668: LD_VAR 0 3
102672: PUSH
102673: LD_INT 22
102675: EQUAL
102676: IFFALSE 102686
// sTeleport := true ;
102678: LD_ADDR_EXP 190
102682: PUSH
102683: LD_INT 1
102685: ST_TO_ADDR
// if p3 = 23 then
102686: LD_VAR 0 3
102690: PUSH
102691: LD_INT 23
102693: EQUAL
102694: IFFALSE 102704
// sOilTower := true ;
102696: LD_ADDR_EXP 192
102700: PUSH
102701: LD_INT 1
102703: ST_TO_ADDR
// if p3 = 24 then
102704: LD_VAR 0 3
102708: PUSH
102709: LD_INT 24
102711: EQUAL
102712: IFFALSE 102722
// sShovel := true ;
102714: LD_ADDR_EXP 193
102718: PUSH
102719: LD_INT 1
102721: ST_TO_ADDR
// if p3 = 25 then
102722: LD_VAR 0 3
102726: PUSH
102727: LD_INT 25
102729: EQUAL
102730: IFFALSE 102740
// sSheik := true ;
102732: LD_ADDR_EXP 194
102736: PUSH
102737: LD_INT 1
102739: ST_TO_ADDR
// if p3 = 26 then
102740: LD_VAR 0 3
102744: PUSH
102745: LD_INT 26
102747: EQUAL
102748: IFFALSE 102758
// sEarthquake := true ;
102750: LD_ADDR_EXP 196
102754: PUSH
102755: LD_INT 1
102757: ST_TO_ADDR
// if p3 = 27 then
102758: LD_VAR 0 3
102762: PUSH
102763: LD_INT 27
102765: EQUAL
102766: IFFALSE 102776
// sAI := true ;
102768: LD_ADDR_EXP 197
102772: PUSH
102773: LD_INT 1
102775: ST_TO_ADDR
// if p3 = 28 then
102776: LD_VAR 0 3
102780: PUSH
102781: LD_INT 28
102783: EQUAL
102784: IFFALSE 102794
// sCargo := true ;
102786: LD_ADDR_EXP 200
102790: PUSH
102791: LD_INT 1
102793: ST_TO_ADDR
// if p3 = 29 then
102794: LD_VAR 0 3
102798: PUSH
102799: LD_INT 29
102801: EQUAL
102802: IFFALSE 102812
// sDLaser := true ;
102804: LD_ADDR_EXP 201
102808: PUSH
102809: LD_INT 1
102811: ST_TO_ADDR
// if p3 = 30 then
102812: LD_VAR 0 3
102816: PUSH
102817: LD_INT 30
102819: EQUAL
102820: IFFALSE 102830
// sExchange := true ;
102822: LD_ADDR_EXP 202
102826: PUSH
102827: LD_INT 1
102829: ST_TO_ADDR
// if p3 = 31 then
102830: LD_VAR 0 3
102834: PUSH
102835: LD_INT 31
102837: EQUAL
102838: IFFALSE 102848
// sFac := true ;
102840: LD_ADDR_EXP 203
102844: PUSH
102845: LD_INT 1
102847: ST_TO_ADDR
// if p3 = 32 then
102848: LD_VAR 0 3
102852: PUSH
102853: LD_INT 32
102855: EQUAL
102856: IFFALSE 102866
// sPower := true ;
102858: LD_ADDR_EXP 204
102862: PUSH
102863: LD_INT 1
102865: ST_TO_ADDR
// if p3 = 33 then
102866: LD_VAR 0 3
102870: PUSH
102871: LD_INT 33
102873: EQUAL
102874: IFFALSE 102884
// sRandom := true ;
102876: LD_ADDR_EXP 205
102880: PUSH
102881: LD_INT 1
102883: ST_TO_ADDR
// if p3 = 34 then
102884: LD_VAR 0 3
102888: PUSH
102889: LD_INT 34
102891: EQUAL
102892: IFFALSE 102902
// sShield := true ;
102894: LD_ADDR_EXP 206
102898: PUSH
102899: LD_INT 1
102901: ST_TO_ADDR
// if p3 = 35 then
102902: LD_VAR 0 3
102906: PUSH
102907: LD_INT 35
102909: EQUAL
102910: IFFALSE 102920
// sTime := true ;
102912: LD_ADDR_EXP 207
102916: PUSH
102917: LD_INT 1
102919: ST_TO_ADDR
// if p3 = 36 then
102920: LD_VAR 0 3
102924: PUSH
102925: LD_INT 36
102927: EQUAL
102928: IFFALSE 102938
// sTools := true ;
102930: LD_ADDR_EXP 208
102934: PUSH
102935: LD_INT 1
102937: ST_TO_ADDR
// if p3 = 101 then
102938: LD_VAR 0 3
102942: PUSH
102943: LD_INT 101
102945: EQUAL
102946: IFFALSE 102956
// sSold := true ;
102948: LD_ADDR_EXP 173
102952: PUSH
102953: LD_INT 1
102955: ST_TO_ADDR
// if p3 = 102 then
102956: LD_VAR 0 3
102960: PUSH
102961: LD_INT 102
102963: EQUAL
102964: IFFALSE 102974
// sDiff := true ;
102966: LD_ADDR_EXP 174
102970: PUSH
102971: LD_INT 1
102973: ST_TO_ADDR
// if p3 = 103 then
102974: LD_VAR 0 3
102978: PUSH
102979: LD_INT 103
102981: EQUAL
102982: IFFALSE 102992
// sFog := true ;
102984: LD_ADDR_EXP 177
102988: PUSH
102989: LD_INT 1
102991: ST_TO_ADDR
// if p3 = 104 then
102992: LD_VAR 0 3
102996: PUSH
102997: LD_INT 104
102999: EQUAL
103000: IFFALSE 103010
// sReset := true ;
103002: LD_ADDR_EXP 178
103006: PUSH
103007: LD_INT 1
103009: ST_TO_ADDR
// if p3 = 105 then
103010: LD_VAR 0 3
103014: PUSH
103015: LD_INT 105
103017: EQUAL
103018: IFFALSE 103028
// sSun := true ;
103020: LD_ADDR_EXP 179
103024: PUSH
103025: LD_INT 1
103027: ST_TO_ADDR
// if p3 = 106 then
103028: LD_VAR 0 3
103032: PUSH
103033: LD_INT 106
103035: EQUAL
103036: IFFALSE 103046
// sTiger := true ;
103038: LD_ADDR_EXP 175
103042: PUSH
103043: LD_INT 1
103045: ST_TO_ADDR
// if p3 = 107 then
103046: LD_VAR 0 3
103050: PUSH
103051: LD_INT 107
103053: EQUAL
103054: IFFALSE 103064
// sBomb := true ;
103056: LD_ADDR_EXP 176
103060: PUSH
103061: LD_INT 1
103063: ST_TO_ADDR
// if p3 = 108 then
103064: LD_VAR 0 3
103068: PUSH
103069: LD_INT 108
103071: EQUAL
103072: IFFALSE 103082
// sWound := true ;
103074: LD_ADDR_EXP 184
103078: PUSH
103079: LD_INT 1
103081: ST_TO_ADDR
// if p3 = 109 then
103082: LD_VAR 0 3
103086: PUSH
103087: LD_INT 109
103089: EQUAL
103090: IFFALSE 103100
// sBetray := true ;
103092: LD_ADDR_EXP 188
103096: PUSH
103097: LD_INT 1
103099: ST_TO_ADDR
// if p3 = 110 then
103100: LD_VAR 0 3
103104: PUSH
103105: LD_INT 110
103107: EQUAL
103108: IFFALSE 103118
// sContamin := true ;
103110: LD_ADDR_EXP 189
103114: PUSH
103115: LD_INT 1
103117: ST_TO_ADDR
// if p3 = 111 then
103118: LD_VAR 0 3
103122: PUSH
103123: LD_INT 111
103125: EQUAL
103126: IFFALSE 103136
// sOil := true ;
103128: LD_ADDR_EXP 191
103132: PUSH
103133: LD_INT 1
103135: ST_TO_ADDR
// if p3 = 112 then
103136: LD_VAR 0 3
103140: PUSH
103141: LD_INT 112
103143: EQUAL
103144: IFFALSE 103154
// sStu := true ;
103146: LD_ADDR_EXP 195
103150: PUSH
103151: LD_INT 1
103153: ST_TO_ADDR
// if p3 = 113 then
103154: LD_VAR 0 3
103158: PUSH
103159: LD_INT 113
103161: EQUAL
103162: IFFALSE 103172
// sBazooka := true ;
103164: LD_ADDR_EXP 198
103168: PUSH
103169: LD_INT 1
103171: ST_TO_ADDR
// if p3 = 114 then
103172: LD_VAR 0 3
103176: PUSH
103177: LD_INT 114
103179: EQUAL
103180: IFFALSE 103190
// sMortar := true ;
103182: LD_ADDR_EXP 199
103186: PUSH
103187: LD_INT 1
103189: ST_TO_ADDR
// if p3 = 115 then
103190: LD_VAR 0 3
103194: PUSH
103195: LD_INT 115
103197: EQUAL
103198: IFFALSE 103208
// sRanger := true ;
103200: LD_ADDR_EXP 209
103204: PUSH
103205: LD_INT 1
103207: ST_TO_ADDR
// end ; if p2 = 101 then
103208: LD_VAR 0 2
103212: PUSH
103213: LD_INT 101
103215: EQUAL
103216: IFFALSE 103344
// begin case p3 of 1 :
103218: LD_VAR 0 3
103222: PUSH
103223: LD_INT 1
103225: DOUBLE
103226: EQUAL
103227: IFTRUE 103231
103229: GO 103238
103231: POP
// hHackUnlimitedResources ; 2 :
103232: CALL 114379 0 0
103236: GO 103344
103238: LD_INT 2
103240: DOUBLE
103241: EQUAL
103242: IFTRUE 103246
103244: GO 103253
103246: POP
// hHackSetLevel10 ; 3 :
103247: CALL 114512 0 0
103251: GO 103344
103253: LD_INT 3
103255: DOUBLE
103256: EQUAL
103257: IFTRUE 103261
103259: GO 103268
103261: POP
// hHackSetLevel10YourUnits ; 4 :
103262: CALL 114597 0 0
103266: GO 103344
103268: LD_INT 4
103270: DOUBLE
103271: EQUAL
103272: IFTRUE 103276
103274: GO 103283
103276: POP
// hHackInvincible ; 5 :
103277: CALL 115045 0 0
103281: GO 103344
103283: LD_INT 5
103285: DOUBLE
103286: EQUAL
103287: IFTRUE 103291
103289: GO 103298
103291: POP
// hHackInvisible ; 6 :
103292: CALL 115156 0 0
103296: GO 103344
103298: LD_INT 6
103300: DOUBLE
103301: EQUAL
103302: IFTRUE 103306
103304: GO 103313
103306: POP
// hHackChangeYourSide ; 7 :
103307: CALL 115213 0 0
103311: GO 103344
103313: LD_INT 7
103315: DOUBLE
103316: EQUAL
103317: IFTRUE 103321
103319: GO 103328
103321: POP
// hHackChangeUnitSide ; 8 :
103322: CALL 115255 0 0
103326: GO 103344
103328: LD_INT 8
103330: DOUBLE
103331: EQUAL
103332: IFTRUE 103336
103334: GO 103343
103336: POP
// hHackFog ; end ;
103337: CALL 115356 0 0
103341: GO 103344
103343: POP
// end ; end ;
103344: PPOPN 6
103346: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
103347: GO 103349
103349: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
103350: LD_STRING initStreamRollete();
103352: PPUSH
103353: CALL_OW 559
// InitStreamMode ;
103357: CALL 103366 0 0
// DefineStreamItems ( ) ;
103361: CALL 103806 0 0
// end ;
103365: END
// function InitStreamMode ; begin
103366: LD_INT 0
103368: PPUSH
// streamModeActive := false ;
103369: LD_ADDR_EXP 156
103373: PUSH
103374: LD_INT 0
103376: ST_TO_ADDR
// normalCounter := 36 ;
103377: LD_ADDR_EXP 157
103381: PUSH
103382: LD_INT 36
103384: ST_TO_ADDR
// hardcoreCounter := 16 ;
103385: LD_ADDR_EXP 158
103389: PUSH
103390: LD_INT 16
103392: ST_TO_ADDR
// sRocket := false ;
103393: LD_ADDR_EXP 161
103397: PUSH
103398: LD_INT 0
103400: ST_TO_ADDR
// sSpeed := false ;
103401: LD_ADDR_EXP 160
103405: PUSH
103406: LD_INT 0
103408: ST_TO_ADDR
// sEngine := false ;
103409: LD_ADDR_EXP 162
103413: PUSH
103414: LD_INT 0
103416: ST_TO_ADDR
// sSpec := false ;
103417: LD_ADDR_EXP 159
103421: PUSH
103422: LD_INT 0
103424: ST_TO_ADDR
// sLevel := false ;
103425: LD_ADDR_EXP 163
103429: PUSH
103430: LD_INT 0
103432: ST_TO_ADDR
// sArmoury := false ;
103433: LD_ADDR_EXP 164
103437: PUSH
103438: LD_INT 0
103440: ST_TO_ADDR
// sRadar := false ;
103441: LD_ADDR_EXP 165
103445: PUSH
103446: LD_INT 0
103448: ST_TO_ADDR
// sBunker := false ;
103449: LD_ADDR_EXP 166
103453: PUSH
103454: LD_INT 0
103456: ST_TO_ADDR
// sHack := false ;
103457: LD_ADDR_EXP 167
103461: PUSH
103462: LD_INT 0
103464: ST_TO_ADDR
// sFire := false ;
103465: LD_ADDR_EXP 168
103469: PUSH
103470: LD_INT 0
103472: ST_TO_ADDR
// sRefresh := false ;
103473: LD_ADDR_EXP 169
103477: PUSH
103478: LD_INT 0
103480: ST_TO_ADDR
// sExp := false ;
103481: LD_ADDR_EXP 170
103485: PUSH
103486: LD_INT 0
103488: ST_TO_ADDR
// sDepot := false ;
103489: LD_ADDR_EXP 171
103493: PUSH
103494: LD_INT 0
103496: ST_TO_ADDR
// sFlag := false ;
103497: LD_ADDR_EXP 172
103501: PUSH
103502: LD_INT 0
103504: ST_TO_ADDR
// sKamikadze := false ;
103505: LD_ADDR_EXP 180
103509: PUSH
103510: LD_INT 0
103512: ST_TO_ADDR
// sTroll := false ;
103513: LD_ADDR_EXP 181
103517: PUSH
103518: LD_INT 0
103520: ST_TO_ADDR
// sSlow := false ;
103521: LD_ADDR_EXP 182
103525: PUSH
103526: LD_INT 0
103528: ST_TO_ADDR
// sLack := false ;
103529: LD_ADDR_EXP 183
103533: PUSH
103534: LD_INT 0
103536: ST_TO_ADDR
// sTank := false ;
103537: LD_ADDR_EXP 185
103541: PUSH
103542: LD_INT 0
103544: ST_TO_ADDR
// sRemote := false ;
103545: LD_ADDR_EXP 186
103549: PUSH
103550: LD_INT 0
103552: ST_TO_ADDR
// sPowell := false ;
103553: LD_ADDR_EXP 187
103557: PUSH
103558: LD_INT 0
103560: ST_TO_ADDR
// sTeleport := false ;
103561: LD_ADDR_EXP 190
103565: PUSH
103566: LD_INT 0
103568: ST_TO_ADDR
// sOilTower := false ;
103569: LD_ADDR_EXP 192
103573: PUSH
103574: LD_INT 0
103576: ST_TO_ADDR
// sShovel := false ;
103577: LD_ADDR_EXP 193
103581: PUSH
103582: LD_INT 0
103584: ST_TO_ADDR
// sSheik := false ;
103585: LD_ADDR_EXP 194
103589: PUSH
103590: LD_INT 0
103592: ST_TO_ADDR
// sEarthquake := false ;
103593: LD_ADDR_EXP 196
103597: PUSH
103598: LD_INT 0
103600: ST_TO_ADDR
// sAI := false ;
103601: LD_ADDR_EXP 197
103605: PUSH
103606: LD_INT 0
103608: ST_TO_ADDR
// sCargo := false ;
103609: LD_ADDR_EXP 200
103613: PUSH
103614: LD_INT 0
103616: ST_TO_ADDR
// sDLaser := false ;
103617: LD_ADDR_EXP 201
103621: PUSH
103622: LD_INT 0
103624: ST_TO_ADDR
// sExchange := false ;
103625: LD_ADDR_EXP 202
103629: PUSH
103630: LD_INT 0
103632: ST_TO_ADDR
// sFac := false ;
103633: LD_ADDR_EXP 203
103637: PUSH
103638: LD_INT 0
103640: ST_TO_ADDR
// sPower := false ;
103641: LD_ADDR_EXP 204
103645: PUSH
103646: LD_INT 0
103648: ST_TO_ADDR
// sRandom := false ;
103649: LD_ADDR_EXP 205
103653: PUSH
103654: LD_INT 0
103656: ST_TO_ADDR
// sShield := false ;
103657: LD_ADDR_EXP 206
103661: PUSH
103662: LD_INT 0
103664: ST_TO_ADDR
// sTime := false ;
103665: LD_ADDR_EXP 207
103669: PUSH
103670: LD_INT 0
103672: ST_TO_ADDR
// sTools := false ;
103673: LD_ADDR_EXP 208
103677: PUSH
103678: LD_INT 0
103680: ST_TO_ADDR
// sSold := false ;
103681: LD_ADDR_EXP 173
103685: PUSH
103686: LD_INT 0
103688: ST_TO_ADDR
// sDiff := false ;
103689: LD_ADDR_EXP 174
103693: PUSH
103694: LD_INT 0
103696: ST_TO_ADDR
// sFog := false ;
103697: LD_ADDR_EXP 177
103701: PUSH
103702: LD_INT 0
103704: ST_TO_ADDR
// sReset := false ;
103705: LD_ADDR_EXP 178
103709: PUSH
103710: LD_INT 0
103712: ST_TO_ADDR
// sSun := false ;
103713: LD_ADDR_EXP 179
103717: PUSH
103718: LD_INT 0
103720: ST_TO_ADDR
// sTiger := false ;
103721: LD_ADDR_EXP 175
103725: PUSH
103726: LD_INT 0
103728: ST_TO_ADDR
// sBomb := false ;
103729: LD_ADDR_EXP 176
103733: PUSH
103734: LD_INT 0
103736: ST_TO_ADDR
// sWound := false ;
103737: LD_ADDR_EXP 184
103741: PUSH
103742: LD_INT 0
103744: ST_TO_ADDR
// sBetray := false ;
103745: LD_ADDR_EXP 188
103749: PUSH
103750: LD_INT 0
103752: ST_TO_ADDR
// sContamin := false ;
103753: LD_ADDR_EXP 189
103757: PUSH
103758: LD_INT 0
103760: ST_TO_ADDR
// sOil := false ;
103761: LD_ADDR_EXP 191
103765: PUSH
103766: LD_INT 0
103768: ST_TO_ADDR
// sStu := false ;
103769: LD_ADDR_EXP 195
103773: PUSH
103774: LD_INT 0
103776: ST_TO_ADDR
// sBazooka := false ;
103777: LD_ADDR_EXP 198
103781: PUSH
103782: LD_INT 0
103784: ST_TO_ADDR
// sMortar := false ;
103785: LD_ADDR_EXP 199
103789: PUSH
103790: LD_INT 0
103792: ST_TO_ADDR
// sRanger := false ;
103793: LD_ADDR_EXP 209
103797: PUSH
103798: LD_INT 0
103800: ST_TO_ADDR
// end ;
103801: LD_VAR 0 1
103805: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
103806: LD_INT 0
103808: PPUSH
103809: PPUSH
103810: PPUSH
103811: PPUSH
103812: PPUSH
// result := [ ] ;
103813: LD_ADDR_VAR 0 1
103817: PUSH
103818: EMPTY
103819: ST_TO_ADDR
// if campaign_id = 1 then
103820: LD_OWVAR 69
103824: PUSH
103825: LD_INT 1
103827: EQUAL
103828: IFFALSE 106766
// begin case mission_number of 1 :
103830: LD_OWVAR 70
103834: PUSH
103835: LD_INT 1
103837: DOUBLE
103838: EQUAL
103839: IFTRUE 103843
103841: GO 103907
103843: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
103844: LD_ADDR_VAR 0 1
103848: PUSH
103849: LD_INT 2
103851: PUSH
103852: LD_INT 4
103854: PUSH
103855: LD_INT 11
103857: PUSH
103858: LD_INT 12
103860: PUSH
103861: LD_INT 15
103863: PUSH
103864: LD_INT 16
103866: PUSH
103867: LD_INT 22
103869: PUSH
103870: LD_INT 23
103872: PUSH
103873: LD_INT 26
103875: PUSH
103876: EMPTY
103877: LIST
103878: LIST
103879: LIST
103880: LIST
103881: LIST
103882: LIST
103883: LIST
103884: LIST
103885: LIST
103886: PUSH
103887: LD_INT 101
103889: PUSH
103890: LD_INT 102
103892: PUSH
103893: LD_INT 106
103895: PUSH
103896: EMPTY
103897: LIST
103898: LIST
103899: LIST
103900: PUSH
103901: EMPTY
103902: LIST
103903: LIST
103904: ST_TO_ADDR
103905: GO 106764
103907: LD_INT 2
103909: DOUBLE
103910: EQUAL
103911: IFTRUE 103915
103913: GO 103987
103915: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
103916: LD_ADDR_VAR 0 1
103920: PUSH
103921: LD_INT 2
103923: PUSH
103924: LD_INT 4
103926: PUSH
103927: LD_INT 11
103929: PUSH
103930: LD_INT 12
103932: PUSH
103933: LD_INT 15
103935: PUSH
103936: LD_INT 16
103938: PUSH
103939: LD_INT 22
103941: PUSH
103942: LD_INT 23
103944: PUSH
103945: LD_INT 26
103947: PUSH
103948: EMPTY
103949: LIST
103950: LIST
103951: LIST
103952: LIST
103953: LIST
103954: LIST
103955: LIST
103956: LIST
103957: LIST
103958: PUSH
103959: LD_INT 101
103961: PUSH
103962: LD_INT 102
103964: PUSH
103965: LD_INT 105
103967: PUSH
103968: LD_INT 106
103970: PUSH
103971: LD_INT 108
103973: PUSH
103974: EMPTY
103975: LIST
103976: LIST
103977: LIST
103978: LIST
103979: LIST
103980: PUSH
103981: EMPTY
103982: LIST
103983: LIST
103984: ST_TO_ADDR
103985: GO 106764
103987: LD_INT 3
103989: DOUBLE
103990: EQUAL
103991: IFTRUE 103995
103993: GO 104071
103995: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
103996: LD_ADDR_VAR 0 1
104000: PUSH
104001: LD_INT 2
104003: PUSH
104004: LD_INT 4
104006: PUSH
104007: LD_INT 5
104009: PUSH
104010: LD_INT 11
104012: PUSH
104013: LD_INT 12
104015: PUSH
104016: LD_INT 15
104018: PUSH
104019: LD_INT 16
104021: PUSH
104022: LD_INT 22
104024: PUSH
104025: LD_INT 26
104027: PUSH
104028: LD_INT 36
104030: PUSH
104031: EMPTY
104032: LIST
104033: LIST
104034: LIST
104035: LIST
104036: LIST
104037: LIST
104038: LIST
104039: LIST
104040: LIST
104041: LIST
104042: PUSH
104043: LD_INT 101
104045: PUSH
104046: LD_INT 102
104048: PUSH
104049: LD_INT 105
104051: PUSH
104052: LD_INT 106
104054: PUSH
104055: LD_INT 108
104057: PUSH
104058: EMPTY
104059: LIST
104060: LIST
104061: LIST
104062: LIST
104063: LIST
104064: PUSH
104065: EMPTY
104066: LIST
104067: LIST
104068: ST_TO_ADDR
104069: GO 106764
104071: LD_INT 4
104073: DOUBLE
104074: EQUAL
104075: IFTRUE 104079
104077: GO 104163
104079: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
104080: LD_ADDR_VAR 0 1
104084: PUSH
104085: LD_INT 2
104087: PUSH
104088: LD_INT 4
104090: PUSH
104091: LD_INT 5
104093: PUSH
104094: LD_INT 8
104096: PUSH
104097: LD_INT 11
104099: PUSH
104100: LD_INT 12
104102: PUSH
104103: LD_INT 15
104105: PUSH
104106: LD_INT 16
104108: PUSH
104109: LD_INT 22
104111: PUSH
104112: LD_INT 23
104114: PUSH
104115: LD_INT 26
104117: PUSH
104118: LD_INT 36
104120: PUSH
104121: EMPTY
104122: LIST
104123: LIST
104124: LIST
104125: LIST
104126: LIST
104127: LIST
104128: LIST
104129: LIST
104130: LIST
104131: LIST
104132: LIST
104133: LIST
104134: PUSH
104135: LD_INT 101
104137: PUSH
104138: LD_INT 102
104140: PUSH
104141: LD_INT 105
104143: PUSH
104144: LD_INT 106
104146: PUSH
104147: LD_INT 108
104149: PUSH
104150: EMPTY
104151: LIST
104152: LIST
104153: LIST
104154: LIST
104155: LIST
104156: PUSH
104157: EMPTY
104158: LIST
104159: LIST
104160: ST_TO_ADDR
104161: GO 106764
104163: LD_INT 5
104165: DOUBLE
104166: EQUAL
104167: IFTRUE 104171
104169: GO 104271
104171: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
104172: LD_ADDR_VAR 0 1
104176: PUSH
104177: LD_INT 2
104179: PUSH
104180: LD_INT 4
104182: PUSH
104183: LD_INT 5
104185: PUSH
104186: LD_INT 6
104188: PUSH
104189: LD_INT 8
104191: PUSH
104192: LD_INT 11
104194: PUSH
104195: LD_INT 12
104197: PUSH
104198: LD_INT 15
104200: PUSH
104201: LD_INT 16
104203: PUSH
104204: LD_INT 22
104206: PUSH
104207: LD_INT 23
104209: PUSH
104210: LD_INT 25
104212: PUSH
104213: LD_INT 26
104215: PUSH
104216: LD_INT 36
104218: PUSH
104219: EMPTY
104220: LIST
104221: LIST
104222: LIST
104223: LIST
104224: LIST
104225: LIST
104226: LIST
104227: LIST
104228: LIST
104229: LIST
104230: LIST
104231: LIST
104232: LIST
104233: LIST
104234: PUSH
104235: LD_INT 101
104237: PUSH
104238: LD_INT 102
104240: PUSH
104241: LD_INT 105
104243: PUSH
104244: LD_INT 106
104246: PUSH
104247: LD_INT 108
104249: PUSH
104250: LD_INT 109
104252: PUSH
104253: LD_INT 112
104255: PUSH
104256: EMPTY
104257: LIST
104258: LIST
104259: LIST
104260: LIST
104261: LIST
104262: LIST
104263: LIST
104264: PUSH
104265: EMPTY
104266: LIST
104267: LIST
104268: ST_TO_ADDR
104269: GO 106764
104271: LD_INT 6
104273: DOUBLE
104274: EQUAL
104275: IFTRUE 104279
104277: GO 104399
104279: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
104280: LD_ADDR_VAR 0 1
104284: PUSH
104285: LD_INT 2
104287: PUSH
104288: LD_INT 4
104290: PUSH
104291: LD_INT 5
104293: PUSH
104294: LD_INT 6
104296: PUSH
104297: LD_INT 8
104299: PUSH
104300: LD_INT 11
104302: PUSH
104303: LD_INT 12
104305: PUSH
104306: LD_INT 15
104308: PUSH
104309: LD_INT 16
104311: PUSH
104312: LD_INT 20
104314: PUSH
104315: LD_INT 21
104317: PUSH
104318: LD_INT 22
104320: PUSH
104321: LD_INT 23
104323: PUSH
104324: LD_INT 25
104326: PUSH
104327: LD_INT 26
104329: PUSH
104330: LD_INT 30
104332: PUSH
104333: LD_INT 31
104335: PUSH
104336: LD_INT 32
104338: PUSH
104339: LD_INT 36
104341: PUSH
104342: EMPTY
104343: LIST
104344: LIST
104345: LIST
104346: LIST
104347: LIST
104348: LIST
104349: LIST
104350: LIST
104351: LIST
104352: LIST
104353: LIST
104354: LIST
104355: LIST
104356: LIST
104357: LIST
104358: LIST
104359: LIST
104360: LIST
104361: LIST
104362: PUSH
104363: LD_INT 101
104365: PUSH
104366: LD_INT 102
104368: PUSH
104369: LD_INT 105
104371: PUSH
104372: LD_INT 106
104374: PUSH
104375: LD_INT 108
104377: PUSH
104378: LD_INT 109
104380: PUSH
104381: LD_INT 112
104383: PUSH
104384: EMPTY
104385: LIST
104386: LIST
104387: LIST
104388: LIST
104389: LIST
104390: LIST
104391: LIST
104392: PUSH
104393: EMPTY
104394: LIST
104395: LIST
104396: ST_TO_ADDR
104397: GO 106764
104399: LD_INT 7
104401: DOUBLE
104402: EQUAL
104403: IFTRUE 104407
104405: GO 104507
104407: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
104408: LD_ADDR_VAR 0 1
104412: PUSH
104413: LD_INT 2
104415: PUSH
104416: LD_INT 4
104418: PUSH
104419: LD_INT 5
104421: PUSH
104422: LD_INT 7
104424: PUSH
104425: LD_INT 11
104427: PUSH
104428: LD_INT 12
104430: PUSH
104431: LD_INT 15
104433: PUSH
104434: LD_INT 16
104436: PUSH
104437: LD_INT 20
104439: PUSH
104440: LD_INT 21
104442: PUSH
104443: LD_INT 22
104445: PUSH
104446: LD_INT 23
104448: PUSH
104449: LD_INT 25
104451: PUSH
104452: LD_INT 26
104454: PUSH
104455: EMPTY
104456: LIST
104457: LIST
104458: LIST
104459: LIST
104460: LIST
104461: LIST
104462: LIST
104463: LIST
104464: LIST
104465: LIST
104466: LIST
104467: LIST
104468: LIST
104469: LIST
104470: PUSH
104471: LD_INT 101
104473: PUSH
104474: LD_INT 102
104476: PUSH
104477: LD_INT 103
104479: PUSH
104480: LD_INT 105
104482: PUSH
104483: LD_INT 106
104485: PUSH
104486: LD_INT 108
104488: PUSH
104489: LD_INT 112
104491: PUSH
104492: EMPTY
104493: LIST
104494: LIST
104495: LIST
104496: LIST
104497: LIST
104498: LIST
104499: LIST
104500: PUSH
104501: EMPTY
104502: LIST
104503: LIST
104504: ST_TO_ADDR
104505: GO 106764
104507: LD_INT 8
104509: DOUBLE
104510: EQUAL
104511: IFTRUE 104515
104513: GO 104643
104515: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
104516: LD_ADDR_VAR 0 1
104520: PUSH
104521: LD_INT 2
104523: PUSH
104524: LD_INT 4
104526: PUSH
104527: LD_INT 5
104529: PUSH
104530: LD_INT 6
104532: PUSH
104533: LD_INT 7
104535: PUSH
104536: LD_INT 8
104538: PUSH
104539: LD_INT 11
104541: PUSH
104542: LD_INT 12
104544: PUSH
104545: LD_INT 15
104547: PUSH
104548: LD_INT 16
104550: PUSH
104551: LD_INT 20
104553: PUSH
104554: LD_INT 21
104556: PUSH
104557: LD_INT 22
104559: PUSH
104560: LD_INT 23
104562: PUSH
104563: LD_INT 25
104565: PUSH
104566: LD_INT 26
104568: PUSH
104569: LD_INT 30
104571: PUSH
104572: LD_INT 31
104574: PUSH
104575: LD_INT 32
104577: PUSH
104578: LD_INT 36
104580: PUSH
104581: EMPTY
104582: LIST
104583: LIST
104584: LIST
104585: LIST
104586: LIST
104587: LIST
104588: LIST
104589: LIST
104590: LIST
104591: LIST
104592: LIST
104593: LIST
104594: LIST
104595: LIST
104596: LIST
104597: LIST
104598: LIST
104599: LIST
104600: LIST
104601: LIST
104602: PUSH
104603: LD_INT 101
104605: PUSH
104606: LD_INT 102
104608: PUSH
104609: LD_INT 103
104611: PUSH
104612: LD_INT 105
104614: PUSH
104615: LD_INT 106
104617: PUSH
104618: LD_INT 108
104620: PUSH
104621: LD_INT 109
104623: PUSH
104624: LD_INT 112
104626: PUSH
104627: EMPTY
104628: LIST
104629: LIST
104630: LIST
104631: LIST
104632: LIST
104633: LIST
104634: LIST
104635: LIST
104636: PUSH
104637: EMPTY
104638: LIST
104639: LIST
104640: ST_TO_ADDR
104641: GO 106764
104643: LD_INT 9
104645: DOUBLE
104646: EQUAL
104647: IFTRUE 104651
104649: GO 104787
104651: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
104652: LD_ADDR_VAR 0 1
104656: PUSH
104657: LD_INT 2
104659: PUSH
104660: LD_INT 4
104662: PUSH
104663: LD_INT 5
104665: PUSH
104666: LD_INT 6
104668: PUSH
104669: LD_INT 7
104671: PUSH
104672: LD_INT 8
104674: PUSH
104675: LD_INT 11
104677: PUSH
104678: LD_INT 12
104680: PUSH
104681: LD_INT 15
104683: PUSH
104684: LD_INT 16
104686: PUSH
104687: LD_INT 20
104689: PUSH
104690: LD_INT 21
104692: PUSH
104693: LD_INT 22
104695: PUSH
104696: LD_INT 23
104698: PUSH
104699: LD_INT 25
104701: PUSH
104702: LD_INT 26
104704: PUSH
104705: LD_INT 28
104707: PUSH
104708: LD_INT 30
104710: PUSH
104711: LD_INT 31
104713: PUSH
104714: LD_INT 32
104716: PUSH
104717: LD_INT 36
104719: PUSH
104720: EMPTY
104721: LIST
104722: LIST
104723: LIST
104724: LIST
104725: LIST
104726: LIST
104727: LIST
104728: LIST
104729: LIST
104730: LIST
104731: LIST
104732: LIST
104733: LIST
104734: LIST
104735: LIST
104736: LIST
104737: LIST
104738: LIST
104739: LIST
104740: LIST
104741: LIST
104742: PUSH
104743: LD_INT 101
104745: PUSH
104746: LD_INT 102
104748: PUSH
104749: LD_INT 103
104751: PUSH
104752: LD_INT 105
104754: PUSH
104755: LD_INT 106
104757: PUSH
104758: LD_INT 108
104760: PUSH
104761: LD_INT 109
104763: PUSH
104764: LD_INT 112
104766: PUSH
104767: LD_INT 114
104769: PUSH
104770: EMPTY
104771: LIST
104772: LIST
104773: LIST
104774: LIST
104775: LIST
104776: LIST
104777: LIST
104778: LIST
104779: LIST
104780: PUSH
104781: EMPTY
104782: LIST
104783: LIST
104784: ST_TO_ADDR
104785: GO 106764
104787: LD_INT 10
104789: DOUBLE
104790: EQUAL
104791: IFTRUE 104795
104793: GO 104979
104795: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
104796: LD_ADDR_VAR 0 1
104800: PUSH
104801: LD_INT 2
104803: PUSH
104804: LD_INT 4
104806: PUSH
104807: LD_INT 5
104809: PUSH
104810: LD_INT 6
104812: PUSH
104813: LD_INT 7
104815: PUSH
104816: LD_INT 8
104818: PUSH
104819: LD_INT 9
104821: PUSH
104822: LD_INT 10
104824: PUSH
104825: LD_INT 11
104827: PUSH
104828: LD_INT 12
104830: PUSH
104831: LD_INT 13
104833: PUSH
104834: LD_INT 14
104836: PUSH
104837: LD_INT 15
104839: PUSH
104840: LD_INT 16
104842: PUSH
104843: LD_INT 17
104845: PUSH
104846: LD_INT 18
104848: PUSH
104849: LD_INT 19
104851: PUSH
104852: LD_INT 20
104854: PUSH
104855: LD_INT 21
104857: PUSH
104858: LD_INT 22
104860: PUSH
104861: LD_INT 23
104863: PUSH
104864: LD_INT 24
104866: PUSH
104867: LD_INT 25
104869: PUSH
104870: LD_INT 26
104872: PUSH
104873: LD_INT 28
104875: PUSH
104876: LD_INT 30
104878: PUSH
104879: LD_INT 31
104881: PUSH
104882: LD_INT 32
104884: PUSH
104885: LD_INT 36
104887: PUSH
104888: EMPTY
104889: LIST
104890: LIST
104891: LIST
104892: LIST
104893: LIST
104894: LIST
104895: LIST
104896: LIST
104897: LIST
104898: LIST
104899: LIST
104900: LIST
104901: LIST
104902: LIST
104903: LIST
104904: LIST
104905: LIST
104906: LIST
104907: LIST
104908: LIST
104909: LIST
104910: LIST
104911: LIST
104912: LIST
104913: LIST
104914: LIST
104915: LIST
104916: LIST
104917: LIST
104918: PUSH
104919: LD_INT 101
104921: PUSH
104922: LD_INT 102
104924: PUSH
104925: LD_INT 103
104927: PUSH
104928: LD_INT 104
104930: PUSH
104931: LD_INT 105
104933: PUSH
104934: LD_INT 106
104936: PUSH
104937: LD_INT 107
104939: PUSH
104940: LD_INT 108
104942: PUSH
104943: LD_INT 109
104945: PUSH
104946: LD_INT 110
104948: PUSH
104949: LD_INT 111
104951: PUSH
104952: LD_INT 112
104954: PUSH
104955: LD_INT 114
104957: PUSH
104958: EMPTY
104959: LIST
104960: LIST
104961: LIST
104962: LIST
104963: LIST
104964: LIST
104965: LIST
104966: LIST
104967: LIST
104968: LIST
104969: LIST
104970: LIST
104971: LIST
104972: PUSH
104973: EMPTY
104974: LIST
104975: LIST
104976: ST_TO_ADDR
104977: GO 106764
104979: LD_INT 11
104981: DOUBLE
104982: EQUAL
104983: IFTRUE 104987
104985: GO 105179
104987: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
104988: LD_ADDR_VAR 0 1
104992: PUSH
104993: LD_INT 2
104995: PUSH
104996: LD_INT 3
104998: PUSH
104999: LD_INT 4
105001: PUSH
105002: LD_INT 5
105004: PUSH
105005: LD_INT 6
105007: PUSH
105008: LD_INT 7
105010: PUSH
105011: LD_INT 8
105013: PUSH
105014: LD_INT 9
105016: PUSH
105017: LD_INT 10
105019: PUSH
105020: LD_INT 11
105022: PUSH
105023: LD_INT 12
105025: PUSH
105026: LD_INT 13
105028: PUSH
105029: LD_INT 14
105031: PUSH
105032: LD_INT 15
105034: PUSH
105035: LD_INT 16
105037: PUSH
105038: LD_INT 17
105040: PUSH
105041: LD_INT 18
105043: PUSH
105044: LD_INT 19
105046: PUSH
105047: LD_INT 20
105049: PUSH
105050: LD_INT 21
105052: PUSH
105053: LD_INT 22
105055: PUSH
105056: LD_INT 23
105058: PUSH
105059: LD_INT 24
105061: PUSH
105062: LD_INT 25
105064: PUSH
105065: LD_INT 26
105067: PUSH
105068: LD_INT 28
105070: PUSH
105071: LD_INT 30
105073: PUSH
105074: LD_INT 31
105076: PUSH
105077: LD_INT 32
105079: PUSH
105080: LD_INT 34
105082: PUSH
105083: LD_INT 36
105085: PUSH
105086: EMPTY
105087: LIST
105088: LIST
105089: LIST
105090: LIST
105091: LIST
105092: LIST
105093: LIST
105094: LIST
105095: LIST
105096: LIST
105097: LIST
105098: LIST
105099: LIST
105100: LIST
105101: LIST
105102: LIST
105103: LIST
105104: LIST
105105: LIST
105106: LIST
105107: LIST
105108: LIST
105109: LIST
105110: LIST
105111: LIST
105112: LIST
105113: LIST
105114: LIST
105115: LIST
105116: LIST
105117: LIST
105118: PUSH
105119: LD_INT 101
105121: PUSH
105122: LD_INT 102
105124: PUSH
105125: LD_INT 103
105127: PUSH
105128: LD_INT 104
105130: PUSH
105131: LD_INT 105
105133: PUSH
105134: LD_INT 106
105136: PUSH
105137: LD_INT 107
105139: PUSH
105140: LD_INT 108
105142: PUSH
105143: LD_INT 109
105145: PUSH
105146: LD_INT 110
105148: PUSH
105149: LD_INT 111
105151: PUSH
105152: LD_INT 112
105154: PUSH
105155: LD_INT 114
105157: PUSH
105158: EMPTY
105159: LIST
105160: LIST
105161: LIST
105162: LIST
105163: LIST
105164: LIST
105165: LIST
105166: LIST
105167: LIST
105168: LIST
105169: LIST
105170: LIST
105171: LIST
105172: PUSH
105173: EMPTY
105174: LIST
105175: LIST
105176: ST_TO_ADDR
105177: GO 106764
105179: LD_INT 12
105181: DOUBLE
105182: EQUAL
105183: IFTRUE 105187
105185: GO 105395
105187: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
105188: LD_ADDR_VAR 0 1
105192: PUSH
105193: LD_INT 1
105195: PUSH
105196: LD_INT 2
105198: PUSH
105199: LD_INT 3
105201: PUSH
105202: LD_INT 4
105204: PUSH
105205: LD_INT 5
105207: PUSH
105208: LD_INT 6
105210: PUSH
105211: LD_INT 7
105213: PUSH
105214: LD_INT 8
105216: PUSH
105217: LD_INT 9
105219: PUSH
105220: LD_INT 10
105222: PUSH
105223: LD_INT 11
105225: PUSH
105226: LD_INT 12
105228: PUSH
105229: LD_INT 13
105231: PUSH
105232: LD_INT 14
105234: PUSH
105235: LD_INT 15
105237: PUSH
105238: LD_INT 16
105240: PUSH
105241: LD_INT 17
105243: PUSH
105244: LD_INT 18
105246: PUSH
105247: LD_INT 19
105249: PUSH
105250: LD_INT 20
105252: PUSH
105253: LD_INT 21
105255: PUSH
105256: LD_INT 22
105258: PUSH
105259: LD_INT 23
105261: PUSH
105262: LD_INT 24
105264: PUSH
105265: LD_INT 25
105267: PUSH
105268: LD_INT 26
105270: PUSH
105271: LD_INT 27
105273: PUSH
105274: LD_INT 28
105276: PUSH
105277: LD_INT 30
105279: PUSH
105280: LD_INT 31
105282: PUSH
105283: LD_INT 32
105285: PUSH
105286: LD_INT 33
105288: PUSH
105289: LD_INT 34
105291: PUSH
105292: LD_INT 36
105294: PUSH
105295: EMPTY
105296: LIST
105297: LIST
105298: LIST
105299: LIST
105300: LIST
105301: LIST
105302: LIST
105303: LIST
105304: LIST
105305: LIST
105306: LIST
105307: LIST
105308: LIST
105309: LIST
105310: LIST
105311: LIST
105312: LIST
105313: LIST
105314: LIST
105315: LIST
105316: LIST
105317: LIST
105318: LIST
105319: LIST
105320: LIST
105321: LIST
105322: LIST
105323: LIST
105324: LIST
105325: LIST
105326: LIST
105327: LIST
105328: LIST
105329: LIST
105330: PUSH
105331: LD_INT 101
105333: PUSH
105334: LD_INT 102
105336: PUSH
105337: LD_INT 103
105339: PUSH
105340: LD_INT 104
105342: PUSH
105343: LD_INT 105
105345: PUSH
105346: LD_INT 106
105348: PUSH
105349: LD_INT 107
105351: PUSH
105352: LD_INT 108
105354: PUSH
105355: LD_INT 109
105357: PUSH
105358: LD_INT 110
105360: PUSH
105361: LD_INT 111
105363: PUSH
105364: LD_INT 112
105366: PUSH
105367: LD_INT 113
105369: PUSH
105370: LD_INT 114
105372: PUSH
105373: EMPTY
105374: LIST
105375: LIST
105376: LIST
105377: LIST
105378: LIST
105379: LIST
105380: LIST
105381: LIST
105382: LIST
105383: LIST
105384: LIST
105385: LIST
105386: LIST
105387: LIST
105388: PUSH
105389: EMPTY
105390: LIST
105391: LIST
105392: ST_TO_ADDR
105393: GO 106764
105395: LD_INT 13
105397: DOUBLE
105398: EQUAL
105399: IFTRUE 105403
105401: GO 105599
105403: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
105404: LD_ADDR_VAR 0 1
105408: PUSH
105409: LD_INT 1
105411: PUSH
105412: LD_INT 2
105414: PUSH
105415: LD_INT 3
105417: PUSH
105418: LD_INT 4
105420: PUSH
105421: LD_INT 5
105423: PUSH
105424: LD_INT 8
105426: PUSH
105427: LD_INT 9
105429: PUSH
105430: LD_INT 10
105432: PUSH
105433: LD_INT 11
105435: PUSH
105436: LD_INT 12
105438: PUSH
105439: LD_INT 14
105441: PUSH
105442: LD_INT 15
105444: PUSH
105445: LD_INT 16
105447: PUSH
105448: LD_INT 17
105450: PUSH
105451: LD_INT 18
105453: PUSH
105454: LD_INT 19
105456: PUSH
105457: LD_INT 20
105459: PUSH
105460: LD_INT 21
105462: PUSH
105463: LD_INT 22
105465: PUSH
105466: LD_INT 23
105468: PUSH
105469: LD_INT 24
105471: PUSH
105472: LD_INT 25
105474: PUSH
105475: LD_INT 26
105477: PUSH
105478: LD_INT 27
105480: PUSH
105481: LD_INT 28
105483: PUSH
105484: LD_INT 30
105486: PUSH
105487: LD_INT 31
105489: PUSH
105490: LD_INT 32
105492: PUSH
105493: LD_INT 33
105495: PUSH
105496: LD_INT 34
105498: PUSH
105499: LD_INT 36
105501: PUSH
105502: EMPTY
105503: LIST
105504: LIST
105505: LIST
105506: LIST
105507: LIST
105508: LIST
105509: LIST
105510: LIST
105511: LIST
105512: LIST
105513: LIST
105514: LIST
105515: LIST
105516: LIST
105517: LIST
105518: LIST
105519: LIST
105520: LIST
105521: LIST
105522: LIST
105523: LIST
105524: LIST
105525: LIST
105526: LIST
105527: LIST
105528: LIST
105529: LIST
105530: LIST
105531: LIST
105532: LIST
105533: LIST
105534: PUSH
105535: LD_INT 101
105537: PUSH
105538: LD_INT 102
105540: PUSH
105541: LD_INT 103
105543: PUSH
105544: LD_INT 104
105546: PUSH
105547: LD_INT 105
105549: PUSH
105550: LD_INT 106
105552: PUSH
105553: LD_INT 107
105555: PUSH
105556: LD_INT 108
105558: PUSH
105559: LD_INT 109
105561: PUSH
105562: LD_INT 110
105564: PUSH
105565: LD_INT 111
105567: PUSH
105568: LD_INT 112
105570: PUSH
105571: LD_INT 113
105573: PUSH
105574: LD_INT 114
105576: PUSH
105577: EMPTY
105578: LIST
105579: LIST
105580: LIST
105581: LIST
105582: LIST
105583: LIST
105584: LIST
105585: LIST
105586: LIST
105587: LIST
105588: LIST
105589: LIST
105590: LIST
105591: LIST
105592: PUSH
105593: EMPTY
105594: LIST
105595: LIST
105596: ST_TO_ADDR
105597: GO 106764
105599: LD_INT 14
105601: DOUBLE
105602: EQUAL
105603: IFTRUE 105607
105605: GO 105819
105607: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
105608: LD_ADDR_VAR 0 1
105612: PUSH
105613: LD_INT 1
105615: PUSH
105616: LD_INT 2
105618: PUSH
105619: LD_INT 3
105621: PUSH
105622: LD_INT 4
105624: PUSH
105625: LD_INT 5
105627: PUSH
105628: LD_INT 6
105630: PUSH
105631: LD_INT 7
105633: PUSH
105634: LD_INT 8
105636: PUSH
105637: LD_INT 9
105639: PUSH
105640: LD_INT 10
105642: PUSH
105643: LD_INT 11
105645: PUSH
105646: LD_INT 12
105648: PUSH
105649: LD_INT 13
105651: PUSH
105652: LD_INT 14
105654: PUSH
105655: LD_INT 15
105657: PUSH
105658: LD_INT 16
105660: PUSH
105661: LD_INT 17
105663: PUSH
105664: LD_INT 18
105666: PUSH
105667: LD_INT 19
105669: PUSH
105670: LD_INT 20
105672: PUSH
105673: LD_INT 21
105675: PUSH
105676: LD_INT 22
105678: PUSH
105679: LD_INT 23
105681: PUSH
105682: LD_INT 24
105684: PUSH
105685: LD_INT 25
105687: PUSH
105688: LD_INT 26
105690: PUSH
105691: LD_INT 27
105693: PUSH
105694: LD_INT 28
105696: PUSH
105697: LD_INT 29
105699: PUSH
105700: LD_INT 30
105702: PUSH
105703: LD_INT 31
105705: PUSH
105706: LD_INT 32
105708: PUSH
105709: LD_INT 33
105711: PUSH
105712: LD_INT 34
105714: PUSH
105715: LD_INT 36
105717: PUSH
105718: EMPTY
105719: LIST
105720: LIST
105721: LIST
105722: LIST
105723: LIST
105724: LIST
105725: LIST
105726: LIST
105727: LIST
105728: LIST
105729: LIST
105730: LIST
105731: LIST
105732: LIST
105733: LIST
105734: LIST
105735: LIST
105736: LIST
105737: LIST
105738: LIST
105739: LIST
105740: LIST
105741: LIST
105742: LIST
105743: LIST
105744: LIST
105745: LIST
105746: LIST
105747: LIST
105748: LIST
105749: LIST
105750: LIST
105751: LIST
105752: LIST
105753: LIST
105754: PUSH
105755: LD_INT 101
105757: PUSH
105758: LD_INT 102
105760: PUSH
105761: LD_INT 103
105763: PUSH
105764: LD_INT 104
105766: PUSH
105767: LD_INT 105
105769: PUSH
105770: LD_INT 106
105772: PUSH
105773: LD_INT 107
105775: PUSH
105776: LD_INT 108
105778: PUSH
105779: LD_INT 109
105781: PUSH
105782: LD_INT 110
105784: PUSH
105785: LD_INT 111
105787: PUSH
105788: LD_INT 112
105790: PUSH
105791: LD_INT 113
105793: PUSH
105794: LD_INT 114
105796: PUSH
105797: EMPTY
105798: LIST
105799: LIST
105800: LIST
105801: LIST
105802: LIST
105803: LIST
105804: LIST
105805: LIST
105806: LIST
105807: LIST
105808: LIST
105809: LIST
105810: LIST
105811: LIST
105812: PUSH
105813: EMPTY
105814: LIST
105815: LIST
105816: ST_TO_ADDR
105817: GO 106764
105819: LD_INT 15
105821: DOUBLE
105822: EQUAL
105823: IFTRUE 105827
105825: GO 106039
105827: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
105828: LD_ADDR_VAR 0 1
105832: PUSH
105833: LD_INT 1
105835: PUSH
105836: LD_INT 2
105838: PUSH
105839: LD_INT 3
105841: PUSH
105842: LD_INT 4
105844: PUSH
105845: LD_INT 5
105847: PUSH
105848: LD_INT 6
105850: PUSH
105851: LD_INT 7
105853: PUSH
105854: LD_INT 8
105856: PUSH
105857: LD_INT 9
105859: PUSH
105860: LD_INT 10
105862: PUSH
105863: LD_INT 11
105865: PUSH
105866: LD_INT 12
105868: PUSH
105869: LD_INT 13
105871: PUSH
105872: LD_INT 14
105874: PUSH
105875: LD_INT 15
105877: PUSH
105878: LD_INT 16
105880: PUSH
105881: LD_INT 17
105883: PUSH
105884: LD_INT 18
105886: PUSH
105887: LD_INT 19
105889: PUSH
105890: LD_INT 20
105892: PUSH
105893: LD_INT 21
105895: PUSH
105896: LD_INT 22
105898: PUSH
105899: LD_INT 23
105901: PUSH
105902: LD_INT 24
105904: PUSH
105905: LD_INT 25
105907: PUSH
105908: LD_INT 26
105910: PUSH
105911: LD_INT 27
105913: PUSH
105914: LD_INT 28
105916: PUSH
105917: LD_INT 29
105919: PUSH
105920: LD_INT 30
105922: PUSH
105923: LD_INT 31
105925: PUSH
105926: LD_INT 32
105928: PUSH
105929: LD_INT 33
105931: PUSH
105932: LD_INT 34
105934: PUSH
105935: LD_INT 36
105937: PUSH
105938: EMPTY
105939: LIST
105940: LIST
105941: LIST
105942: LIST
105943: LIST
105944: LIST
105945: LIST
105946: LIST
105947: LIST
105948: LIST
105949: LIST
105950: LIST
105951: LIST
105952: LIST
105953: LIST
105954: LIST
105955: LIST
105956: LIST
105957: LIST
105958: LIST
105959: LIST
105960: LIST
105961: LIST
105962: LIST
105963: LIST
105964: LIST
105965: LIST
105966: LIST
105967: LIST
105968: LIST
105969: LIST
105970: LIST
105971: LIST
105972: LIST
105973: LIST
105974: PUSH
105975: LD_INT 101
105977: PUSH
105978: LD_INT 102
105980: PUSH
105981: LD_INT 103
105983: PUSH
105984: LD_INT 104
105986: PUSH
105987: LD_INT 105
105989: PUSH
105990: LD_INT 106
105992: PUSH
105993: LD_INT 107
105995: PUSH
105996: LD_INT 108
105998: PUSH
105999: LD_INT 109
106001: PUSH
106002: LD_INT 110
106004: PUSH
106005: LD_INT 111
106007: PUSH
106008: LD_INT 112
106010: PUSH
106011: LD_INT 113
106013: PUSH
106014: LD_INT 114
106016: PUSH
106017: EMPTY
106018: LIST
106019: LIST
106020: LIST
106021: LIST
106022: LIST
106023: LIST
106024: LIST
106025: LIST
106026: LIST
106027: LIST
106028: LIST
106029: LIST
106030: LIST
106031: LIST
106032: PUSH
106033: EMPTY
106034: LIST
106035: LIST
106036: ST_TO_ADDR
106037: GO 106764
106039: LD_INT 16
106041: DOUBLE
106042: EQUAL
106043: IFTRUE 106047
106045: GO 106171
106047: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
106048: LD_ADDR_VAR 0 1
106052: PUSH
106053: LD_INT 2
106055: PUSH
106056: LD_INT 4
106058: PUSH
106059: LD_INT 5
106061: PUSH
106062: LD_INT 7
106064: PUSH
106065: LD_INT 11
106067: PUSH
106068: LD_INT 12
106070: PUSH
106071: LD_INT 15
106073: PUSH
106074: LD_INT 16
106076: PUSH
106077: LD_INT 20
106079: PUSH
106080: LD_INT 21
106082: PUSH
106083: LD_INT 22
106085: PUSH
106086: LD_INT 23
106088: PUSH
106089: LD_INT 25
106091: PUSH
106092: LD_INT 26
106094: PUSH
106095: LD_INT 30
106097: PUSH
106098: LD_INT 31
106100: PUSH
106101: LD_INT 32
106103: PUSH
106104: LD_INT 33
106106: PUSH
106107: LD_INT 34
106109: PUSH
106110: EMPTY
106111: LIST
106112: LIST
106113: LIST
106114: LIST
106115: LIST
106116: LIST
106117: LIST
106118: LIST
106119: LIST
106120: LIST
106121: LIST
106122: LIST
106123: LIST
106124: LIST
106125: LIST
106126: LIST
106127: LIST
106128: LIST
106129: LIST
106130: PUSH
106131: LD_INT 101
106133: PUSH
106134: LD_INT 102
106136: PUSH
106137: LD_INT 103
106139: PUSH
106140: LD_INT 106
106142: PUSH
106143: LD_INT 108
106145: PUSH
106146: LD_INT 112
106148: PUSH
106149: LD_INT 113
106151: PUSH
106152: LD_INT 114
106154: PUSH
106155: EMPTY
106156: LIST
106157: LIST
106158: LIST
106159: LIST
106160: LIST
106161: LIST
106162: LIST
106163: LIST
106164: PUSH
106165: EMPTY
106166: LIST
106167: LIST
106168: ST_TO_ADDR
106169: GO 106764
106171: LD_INT 17
106173: DOUBLE
106174: EQUAL
106175: IFTRUE 106179
106177: GO 106391
106179: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
106180: LD_ADDR_VAR 0 1
106184: PUSH
106185: LD_INT 1
106187: PUSH
106188: LD_INT 2
106190: PUSH
106191: LD_INT 3
106193: PUSH
106194: LD_INT 4
106196: PUSH
106197: LD_INT 5
106199: PUSH
106200: LD_INT 6
106202: PUSH
106203: LD_INT 7
106205: PUSH
106206: LD_INT 8
106208: PUSH
106209: LD_INT 9
106211: PUSH
106212: LD_INT 10
106214: PUSH
106215: LD_INT 11
106217: PUSH
106218: LD_INT 12
106220: PUSH
106221: LD_INT 13
106223: PUSH
106224: LD_INT 14
106226: PUSH
106227: LD_INT 15
106229: PUSH
106230: LD_INT 16
106232: PUSH
106233: LD_INT 17
106235: PUSH
106236: LD_INT 18
106238: PUSH
106239: LD_INT 19
106241: PUSH
106242: LD_INT 20
106244: PUSH
106245: LD_INT 21
106247: PUSH
106248: LD_INT 22
106250: PUSH
106251: LD_INT 23
106253: PUSH
106254: LD_INT 24
106256: PUSH
106257: LD_INT 25
106259: PUSH
106260: LD_INT 26
106262: PUSH
106263: LD_INT 27
106265: PUSH
106266: LD_INT 28
106268: PUSH
106269: LD_INT 29
106271: PUSH
106272: LD_INT 30
106274: PUSH
106275: LD_INT 31
106277: PUSH
106278: LD_INT 32
106280: PUSH
106281: LD_INT 33
106283: PUSH
106284: LD_INT 34
106286: PUSH
106287: LD_INT 36
106289: PUSH
106290: EMPTY
106291: LIST
106292: LIST
106293: LIST
106294: LIST
106295: LIST
106296: LIST
106297: LIST
106298: LIST
106299: LIST
106300: LIST
106301: LIST
106302: LIST
106303: LIST
106304: LIST
106305: LIST
106306: LIST
106307: LIST
106308: LIST
106309: LIST
106310: LIST
106311: LIST
106312: LIST
106313: LIST
106314: LIST
106315: LIST
106316: LIST
106317: LIST
106318: LIST
106319: LIST
106320: LIST
106321: LIST
106322: LIST
106323: LIST
106324: LIST
106325: LIST
106326: PUSH
106327: LD_INT 101
106329: PUSH
106330: LD_INT 102
106332: PUSH
106333: LD_INT 103
106335: PUSH
106336: LD_INT 104
106338: PUSH
106339: LD_INT 105
106341: PUSH
106342: LD_INT 106
106344: PUSH
106345: LD_INT 107
106347: PUSH
106348: LD_INT 108
106350: PUSH
106351: LD_INT 109
106353: PUSH
106354: LD_INT 110
106356: PUSH
106357: LD_INT 111
106359: PUSH
106360: LD_INT 112
106362: PUSH
106363: LD_INT 113
106365: PUSH
106366: LD_INT 114
106368: PUSH
106369: EMPTY
106370: LIST
106371: LIST
106372: LIST
106373: LIST
106374: LIST
106375: LIST
106376: LIST
106377: LIST
106378: LIST
106379: LIST
106380: LIST
106381: LIST
106382: LIST
106383: LIST
106384: PUSH
106385: EMPTY
106386: LIST
106387: LIST
106388: ST_TO_ADDR
106389: GO 106764
106391: LD_INT 18
106393: DOUBLE
106394: EQUAL
106395: IFTRUE 106399
106397: GO 106535
106399: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
106400: LD_ADDR_VAR 0 1
106404: PUSH
106405: LD_INT 2
106407: PUSH
106408: LD_INT 4
106410: PUSH
106411: LD_INT 5
106413: PUSH
106414: LD_INT 7
106416: PUSH
106417: LD_INT 11
106419: PUSH
106420: LD_INT 12
106422: PUSH
106423: LD_INT 15
106425: PUSH
106426: LD_INT 16
106428: PUSH
106429: LD_INT 20
106431: PUSH
106432: LD_INT 21
106434: PUSH
106435: LD_INT 22
106437: PUSH
106438: LD_INT 23
106440: PUSH
106441: LD_INT 25
106443: PUSH
106444: LD_INT 26
106446: PUSH
106447: LD_INT 30
106449: PUSH
106450: LD_INT 31
106452: PUSH
106453: LD_INT 32
106455: PUSH
106456: LD_INT 33
106458: PUSH
106459: LD_INT 34
106461: PUSH
106462: LD_INT 35
106464: PUSH
106465: LD_INT 36
106467: PUSH
106468: EMPTY
106469: LIST
106470: LIST
106471: LIST
106472: LIST
106473: LIST
106474: LIST
106475: LIST
106476: LIST
106477: LIST
106478: LIST
106479: LIST
106480: LIST
106481: LIST
106482: LIST
106483: LIST
106484: LIST
106485: LIST
106486: LIST
106487: LIST
106488: LIST
106489: LIST
106490: PUSH
106491: LD_INT 101
106493: PUSH
106494: LD_INT 102
106496: PUSH
106497: LD_INT 103
106499: PUSH
106500: LD_INT 106
106502: PUSH
106503: LD_INT 108
106505: PUSH
106506: LD_INT 112
106508: PUSH
106509: LD_INT 113
106511: PUSH
106512: LD_INT 114
106514: PUSH
106515: LD_INT 115
106517: PUSH
106518: EMPTY
106519: LIST
106520: LIST
106521: LIST
106522: LIST
106523: LIST
106524: LIST
106525: LIST
106526: LIST
106527: LIST
106528: PUSH
106529: EMPTY
106530: LIST
106531: LIST
106532: ST_TO_ADDR
106533: GO 106764
106535: LD_INT 19
106537: DOUBLE
106538: EQUAL
106539: IFTRUE 106543
106541: GO 106763
106543: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
106544: LD_ADDR_VAR 0 1
106548: PUSH
106549: LD_INT 1
106551: PUSH
106552: LD_INT 2
106554: PUSH
106555: LD_INT 3
106557: PUSH
106558: LD_INT 4
106560: PUSH
106561: LD_INT 5
106563: PUSH
106564: LD_INT 6
106566: PUSH
106567: LD_INT 7
106569: PUSH
106570: LD_INT 8
106572: PUSH
106573: LD_INT 9
106575: PUSH
106576: LD_INT 10
106578: PUSH
106579: LD_INT 11
106581: PUSH
106582: LD_INT 12
106584: PUSH
106585: LD_INT 13
106587: PUSH
106588: LD_INT 14
106590: PUSH
106591: LD_INT 15
106593: PUSH
106594: LD_INT 16
106596: PUSH
106597: LD_INT 17
106599: PUSH
106600: LD_INT 18
106602: PUSH
106603: LD_INT 19
106605: PUSH
106606: LD_INT 20
106608: PUSH
106609: LD_INT 21
106611: PUSH
106612: LD_INT 22
106614: PUSH
106615: LD_INT 23
106617: PUSH
106618: LD_INT 24
106620: PUSH
106621: LD_INT 25
106623: PUSH
106624: LD_INT 26
106626: PUSH
106627: LD_INT 27
106629: PUSH
106630: LD_INT 28
106632: PUSH
106633: LD_INT 29
106635: PUSH
106636: LD_INT 30
106638: PUSH
106639: LD_INT 31
106641: PUSH
106642: LD_INT 32
106644: PUSH
106645: LD_INT 33
106647: PUSH
106648: LD_INT 34
106650: PUSH
106651: LD_INT 35
106653: PUSH
106654: LD_INT 36
106656: PUSH
106657: EMPTY
106658: LIST
106659: LIST
106660: LIST
106661: LIST
106662: LIST
106663: LIST
106664: LIST
106665: LIST
106666: LIST
106667: LIST
106668: LIST
106669: LIST
106670: LIST
106671: LIST
106672: LIST
106673: LIST
106674: LIST
106675: LIST
106676: LIST
106677: LIST
106678: LIST
106679: LIST
106680: LIST
106681: LIST
106682: LIST
106683: LIST
106684: LIST
106685: LIST
106686: LIST
106687: LIST
106688: LIST
106689: LIST
106690: LIST
106691: LIST
106692: LIST
106693: LIST
106694: PUSH
106695: LD_INT 101
106697: PUSH
106698: LD_INT 102
106700: PUSH
106701: LD_INT 103
106703: PUSH
106704: LD_INT 104
106706: PUSH
106707: LD_INT 105
106709: PUSH
106710: LD_INT 106
106712: PUSH
106713: LD_INT 107
106715: PUSH
106716: LD_INT 108
106718: PUSH
106719: LD_INT 109
106721: PUSH
106722: LD_INT 110
106724: PUSH
106725: LD_INT 111
106727: PUSH
106728: LD_INT 112
106730: PUSH
106731: LD_INT 113
106733: PUSH
106734: LD_INT 114
106736: PUSH
106737: LD_INT 115
106739: PUSH
106740: EMPTY
106741: LIST
106742: LIST
106743: LIST
106744: LIST
106745: LIST
106746: LIST
106747: LIST
106748: LIST
106749: LIST
106750: LIST
106751: LIST
106752: LIST
106753: LIST
106754: LIST
106755: LIST
106756: PUSH
106757: EMPTY
106758: LIST
106759: LIST
106760: ST_TO_ADDR
106761: GO 106764
106763: POP
// end else
106764: GO 106983
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
106766: LD_ADDR_VAR 0 1
106770: PUSH
106771: LD_INT 1
106773: PUSH
106774: LD_INT 2
106776: PUSH
106777: LD_INT 3
106779: PUSH
106780: LD_INT 4
106782: PUSH
106783: LD_INT 5
106785: PUSH
106786: LD_INT 6
106788: PUSH
106789: LD_INT 7
106791: PUSH
106792: LD_INT 8
106794: PUSH
106795: LD_INT 9
106797: PUSH
106798: LD_INT 10
106800: PUSH
106801: LD_INT 11
106803: PUSH
106804: LD_INT 12
106806: PUSH
106807: LD_INT 13
106809: PUSH
106810: LD_INT 14
106812: PUSH
106813: LD_INT 15
106815: PUSH
106816: LD_INT 16
106818: PUSH
106819: LD_INT 17
106821: PUSH
106822: LD_INT 18
106824: PUSH
106825: LD_INT 19
106827: PUSH
106828: LD_INT 20
106830: PUSH
106831: LD_INT 21
106833: PUSH
106834: LD_INT 22
106836: PUSH
106837: LD_INT 23
106839: PUSH
106840: LD_INT 24
106842: PUSH
106843: LD_INT 25
106845: PUSH
106846: LD_INT 26
106848: PUSH
106849: LD_INT 27
106851: PUSH
106852: LD_INT 28
106854: PUSH
106855: LD_INT 29
106857: PUSH
106858: LD_INT 30
106860: PUSH
106861: LD_INT 31
106863: PUSH
106864: LD_INT 32
106866: PUSH
106867: LD_INT 33
106869: PUSH
106870: LD_INT 34
106872: PUSH
106873: LD_INT 35
106875: PUSH
106876: LD_INT 36
106878: PUSH
106879: EMPTY
106880: LIST
106881: LIST
106882: LIST
106883: LIST
106884: LIST
106885: LIST
106886: LIST
106887: LIST
106888: LIST
106889: LIST
106890: LIST
106891: LIST
106892: LIST
106893: LIST
106894: LIST
106895: LIST
106896: LIST
106897: LIST
106898: LIST
106899: LIST
106900: LIST
106901: LIST
106902: LIST
106903: LIST
106904: LIST
106905: LIST
106906: LIST
106907: LIST
106908: LIST
106909: LIST
106910: LIST
106911: LIST
106912: LIST
106913: LIST
106914: LIST
106915: LIST
106916: PUSH
106917: LD_INT 101
106919: PUSH
106920: LD_INT 102
106922: PUSH
106923: LD_INT 103
106925: PUSH
106926: LD_INT 104
106928: PUSH
106929: LD_INT 105
106931: PUSH
106932: LD_INT 106
106934: PUSH
106935: LD_INT 107
106937: PUSH
106938: LD_INT 108
106940: PUSH
106941: LD_INT 109
106943: PUSH
106944: LD_INT 110
106946: PUSH
106947: LD_INT 111
106949: PUSH
106950: LD_INT 112
106952: PUSH
106953: LD_INT 113
106955: PUSH
106956: LD_INT 114
106958: PUSH
106959: LD_INT 115
106961: PUSH
106962: EMPTY
106963: LIST
106964: LIST
106965: LIST
106966: LIST
106967: LIST
106968: LIST
106969: LIST
106970: LIST
106971: LIST
106972: LIST
106973: LIST
106974: LIST
106975: LIST
106976: LIST
106977: LIST
106978: PUSH
106979: EMPTY
106980: LIST
106981: LIST
106982: ST_TO_ADDR
// if result then
106983: LD_VAR 0 1
106987: IFFALSE 107276
// begin normal :=  ;
106989: LD_ADDR_VAR 0 3
106993: PUSH
106994: LD_STRING 
106996: ST_TO_ADDR
// hardcore :=  ;
106997: LD_ADDR_VAR 0 4
107001: PUSH
107002: LD_STRING 
107004: ST_TO_ADDR
// for i = 1 to normalCounter do
107005: LD_ADDR_VAR 0 5
107009: PUSH
107010: DOUBLE
107011: LD_INT 1
107013: DEC
107014: ST_TO_ADDR
107015: LD_EXP 157
107019: PUSH
107020: FOR_TO
107021: IFFALSE 107122
// begin tmp := 0 ;
107023: LD_ADDR_VAR 0 2
107027: PUSH
107028: LD_STRING 0
107030: ST_TO_ADDR
// if result [ 1 ] then
107031: LD_VAR 0 1
107035: PUSH
107036: LD_INT 1
107038: ARRAY
107039: IFFALSE 107104
// if result [ 1 ] [ 1 ] = i then
107041: LD_VAR 0 1
107045: PUSH
107046: LD_INT 1
107048: ARRAY
107049: PUSH
107050: LD_INT 1
107052: ARRAY
107053: PUSH
107054: LD_VAR 0 5
107058: EQUAL
107059: IFFALSE 107104
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
107061: LD_ADDR_VAR 0 1
107065: PUSH
107066: LD_VAR 0 1
107070: PPUSH
107071: LD_INT 1
107073: PPUSH
107074: LD_VAR 0 1
107078: PUSH
107079: LD_INT 1
107081: ARRAY
107082: PPUSH
107083: LD_INT 1
107085: PPUSH
107086: CALL_OW 3
107090: PPUSH
107091: CALL_OW 1
107095: ST_TO_ADDR
// tmp := 1 ;
107096: LD_ADDR_VAR 0 2
107100: PUSH
107101: LD_STRING 1
107103: ST_TO_ADDR
// end ; normal := normal & tmp ;
107104: LD_ADDR_VAR 0 3
107108: PUSH
107109: LD_VAR 0 3
107113: PUSH
107114: LD_VAR 0 2
107118: STR
107119: ST_TO_ADDR
// end ;
107120: GO 107020
107122: POP
107123: POP
// for i = 1 to hardcoreCounter do
107124: LD_ADDR_VAR 0 5
107128: PUSH
107129: DOUBLE
107130: LD_INT 1
107132: DEC
107133: ST_TO_ADDR
107134: LD_EXP 158
107138: PUSH
107139: FOR_TO
107140: IFFALSE 107245
// begin tmp := 0 ;
107142: LD_ADDR_VAR 0 2
107146: PUSH
107147: LD_STRING 0
107149: ST_TO_ADDR
// if result [ 2 ] then
107150: LD_VAR 0 1
107154: PUSH
107155: LD_INT 2
107157: ARRAY
107158: IFFALSE 107227
// if result [ 2 ] [ 1 ] = 100 + i then
107160: LD_VAR 0 1
107164: PUSH
107165: LD_INT 2
107167: ARRAY
107168: PUSH
107169: LD_INT 1
107171: ARRAY
107172: PUSH
107173: LD_INT 100
107175: PUSH
107176: LD_VAR 0 5
107180: PLUS
107181: EQUAL
107182: IFFALSE 107227
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
107184: LD_ADDR_VAR 0 1
107188: PUSH
107189: LD_VAR 0 1
107193: PPUSH
107194: LD_INT 2
107196: PPUSH
107197: LD_VAR 0 1
107201: PUSH
107202: LD_INT 2
107204: ARRAY
107205: PPUSH
107206: LD_INT 1
107208: PPUSH
107209: CALL_OW 3
107213: PPUSH
107214: CALL_OW 1
107218: ST_TO_ADDR
// tmp := 1 ;
107219: LD_ADDR_VAR 0 2
107223: PUSH
107224: LD_STRING 1
107226: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
107227: LD_ADDR_VAR 0 4
107231: PUSH
107232: LD_VAR 0 4
107236: PUSH
107237: LD_VAR 0 2
107241: STR
107242: ST_TO_ADDR
// end ;
107243: GO 107139
107245: POP
107246: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
107247: LD_STRING getStreamItemsFromMission("
107249: PUSH
107250: LD_VAR 0 3
107254: STR
107255: PUSH
107256: LD_STRING ","
107258: STR
107259: PUSH
107260: LD_VAR 0 4
107264: STR
107265: PUSH
107266: LD_STRING ")
107268: STR
107269: PPUSH
107270: CALL_OW 559
// end else
107274: GO 107283
// ToLua ( getStreamItemsFromMission("","") ) ;
107276: LD_STRING getStreamItemsFromMission("","")
107278: PPUSH
107279: CALL_OW 559
// end ;
107283: LD_VAR 0 1
107287: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
107288: LD_EXP 156
107292: PUSH
107293: LD_EXP 161
107297: AND
107298: IFFALSE 107422
107300: GO 107302
107302: DISABLE
107303: LD_INT 0
107305: PPUSH
107306: PPUSH
// begin enable ;
107307: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
107308: LD_ADDR_VAR 0 2
107312: PUSH
107313: LD_INT 22
107315: PUSH
107316: LD_OWVAR 2
107320: PUSH
107321: EMPTY
107322: LIST
107323: LIST
107324: PUSH
107325: LD_INT 2
107327: PUSH
107328: LD_INT 34
107330: PUSH
107331: LD_INT 7
107333: PUSH
107334: EMPTY
107335: LIST
107336: LIST
107337: PUSH
107338: LD_INT 34
107340: PUSH
107341: LD_INT 45
107343: PUSH
107344: EMPTY
107345: LIST
107346: LIST
107347: PUSH
107348: LD_INT 34
107350: PUSH
107351: LD_INT 28
107353: PUSH
107354: EMPTY
107355: LIST
107356: LIST
107357: PUSH
107358: LD_INT 34
107360: PUSH
107361: LD_INT 47
107363: PUSH
107364: EMPTY
107365: LIST
107366: LIST
107367: PUSH
107368: EMPTY
107369: LIST
107370: LIST
107371: LIST
107372: LIST
107373: LIST
107374: PUSH
107375: EMPTY
107376: LIST
107377: LIST
107378: PPUSH
107379: CALL_OW 69
107383: ST_TO_ADDR
// if not tmp then
107384: LD_VAR 0 2
107388: NOT
107389: IFFALSE 107393
// exit ;
107391: GO 107422
// for i in tmp do
107393: LD_ADDR_VAR 0 1
107397: PUSH
107398: LD_VAR 0 2
107402: PUSH
107403: FOR_IN
107404: IFFALSE 107420
// begin SetLives ( i , 0 ) ;
107406: LD_VAR 0 1
107410: PPUSH
107411: LD_INT 0
107413: PPUSH
107414: CALL_OW 234
// end ;
107418: GO 107403
107420: POP
107421: POP
// end ;
107422: PPOPN 2
107424: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
107425: LD_EXP 156
107429: PUSH
107430: LD_EXP 162
107434: AND
107435: IFFALSE 107519
107437: GO 107439
107439: DISABLE
107440: LD_INT 0
107442: PPUSH
107443: PPUSH
// begin enable ;
107444: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
107445: LD_ADDR_VAR 0 2
107449: PUSH
107450: LD_INT 22
107452: PUSH
107453: LD_OWVAR 2
107457: PUSH
107458: EMPTY
107459: LIST
107460: LIST
107461: PUSH
107462: LD_INT 32
107464: PUSH
107465: LD_INT 3
107467: PUSH
107468: EMPTY
107469: LIST
107470: LIST
107471: PUSH
107472: EMPTY
107473: LIST
107474: LIST
107475: PPUSH
107476: CALL_OW 69
107480: ST_TO_ADDR
// if not tmp then
107481: LD_VAR 0 2
107485: NOT
107486: IFFALSE 107490
// exit ;
107488: GO 107519
// for i in tmp do
107490: LD_ADDR_VAR 0 1
107494: PUSH
107495: LD_VAR 0 2
107499: PUSH
107500: FOR_IN
107501: IFFALSE 107517
// begin SetLives ( i , 0 ) ;
107503: LD_VAR 0 1
107507: PPUSH
107508: LD_INT 0
107510: PPUSH
107511: CALL_OW 234
// end ;
107515: GO 107500
107517: POP
107518: POP
// end ;
107519: PPOPN 2
107521: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
107522: LD_EXP 156
107526: PUSH
107527: LD_EXP 159
107531: AND
107532: IFFALSE 107625
107534: GO 107536
107536: DISABLE
107537: LD_INT 0
107539: PPUSH
// begin enable ;
107540: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
107541: LD_ADDR_VAR 0 1
107545: PUSH
107546: LD_INT 22
107548: PUSH
107549: LD_OWVAR 2
107553: PUSH
107554: EMPTY
107555: LIST
107556: LIST
107557: PUSH
107558: LD_INT 2
107560: PUSH
107561: LD_INT 25
107563: PUSH
107564: LD_INT 5
107566: PUSH
107567: EMPTY
107568: LIST
107569: LIST
107570: PUSH
107571: LD_INT 25
107573: PUSH
107574: LD_INT 9
107576: PUSH
107577: EMPTY
107578: LIST
107579: LIST
107580: PUSH
107581: LD_INT 25
107583: PUSH
107584: LD_INT 8
107586: PUSH
107587: EMPTY
107588: LIST
107589: LIST
107590: PUSH
107591: EMPTY
107592: LIST
107593: LIST
107594: LIST
107595: LIST
107596: PUSH
107597: EMPTY
107598: LIST
107599: LIST
107600: PPUSH
107601: CALL_OW 69
107605: PUSH
107606: FOR_IN
107607: IFFALSE 107623
// begin SetClass ( i , 1 ) ;
107609: LD_VAR 0 1
107613: PPUSH
107614: LD_INT 1
107616: PPUSH
107617: CALL_OW 336
// end ;
107621: GO 107606
107623: POP
107624: POP
// end ;
107625: PPOPN 1
107627: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
107628: LD_EXP 156
107632: PUSH
107633: LD_EXP 160
107637: AND
107638: PUSH
107639: LD_OWVAR 65
107643: PUSH
107644: LD_INT 7
107646: LESS
107647: AND
107648: IFFALSE 107662
107650: GO 107652
107652: DISABLE
// begin enable ;
107653: ENABLE
// game_speed := 7 ;
107654: LD_ADDR_OWVAR 65
107658: PUSH
107659: LD_INT 7
107661: ST_TO_ADDR
// end ;
107662: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
107663: LD_EXP 156
107667: PUSH
107668: LD_EXP 163
107672: AND
107673: IFFALSE 107875
107675: GO 107677
107677: DISABLE
107678: LD_INT 0
107680: PPUSH
107681: PPUSH
107682: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
107683: LD_ADDR_VAR 0 3
107687: PUSH
107688: LD_INT 81
107690: PUSH
107691: LD_OWVAR 2
107695: PUSH
107696: EMPTY
107697: LIST
107698: LIST
107699: PUSH
107700: LD_INT 21
107702: PUSH
107703: LD_INT 1
107705: PUSH
107706: EMPTY
107707: LIST
107708: LIST
107709: PUSH
107710: EMPTY
107711: LIST
107712: LIST
107713: PPUSH
107714: CALL_OW 69
107718: ST_TO_ADDR
// if not tmp then
107719: LD_VAR 0 3
107723: NOT
107724: IFFALSE 107728
// exit ;
107726: GO 107875
// if tmp > 5 then
107728: LD_VAR 0 3
107732: PUSH
107733: LD_INT 5
107735: GREATER
107736: IFFALSE 107748
// k := 5 else
107738: LD_ADDR_VAR 0 2
107742: PUSH
107743: LD_INT 5
107745: ST_TO_ADDR
107746: GO 107758
// k := tmp ;
107748: LD_ADDR_VAR 0 2
107752: PUSH
107753: LD_VAR 0 3
107757: ST_TO_ADDR
// for i := 1 to k do
107758: LD_ADDR_VAR 0 1
107762: PUSH
107763: DOUBLE
107764: LD_INT 1
107766: DEC
107767: ST_TO_ADDR
107768: LD_VAR 0 2
107772: PUSH
107773: FOR_TO
107774: IFFALSE 107873
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
107776: LD_VAR 0 3
107780: PUSH
107781: LD_VAR 0 1
107785: ARRAY
107786: PPUSH
107787: LD_VAR 0 1
107791: PUSH
107792: LD_INT 4
107794: MOD
107795: PUSH
107796: LD_INT 1
107798: PLUS
107799: PPUSH
107800: CALL_OW 259
107804: PUSH
107805: LD_INT 10
107807: LESS
107808: IFFALSE 107871
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
107810: LD_VAR 0 3
107814: PUSH
107815: LD_VAR 0 1
107819: ARRAY
107820: PPUSH
107821: LD_VAR 0 1
107825: PUSH
107826: LD_INT 4
107828: MOD
107829: PUSH
107830: LD_INT 1
107832: PLUS
107833: PPUSH
107834: LD_VAR 0 3
107838: PUSH
107839: LD_VAR 0 1
107843: ARRAY
107844: PPUSH
107845: LD_VAR 0 1
107849: PUSH
107850: LD_INT 4
107852: MOD
107853: PUSH
107854: LD_INT 1
107856: PLUS
107857: PPUSH
107858: CALL_OW 259
107862: PUSH
107863: LD_INT 1
107865: PLUS
107866: PPUSH
107867: CALL_OW 237
107871: GO 107773
107873: POP
107874: POP
// end ;
107875: PPOPN 3
107877: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
107878: LD_EXP 156
107882: PUSH
107883: LD_EXP 164
107887: AND
107888: IFFALSE 107908
107890: GO 107892
107892: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
107893: LD_INT 4
107895: PPUSH
107896: LD_OWVAR 2
107900: PPUSH
107901: LD_INT 0
107903: PPUSH
107904: CALL_OW 324
107908: END
// every 0 0$1 trigger StreamModeActive and sShovel do
107909: LD_EXP 156
107913: PUSH
107914: LD_EXP 193
107918: AND
107919: IFFALSE 107939
107921: GO 107923
107923: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
107924: LD_INT 19
107926: PPUSH
107927: LD_OWVAR 2
107931: PPUSH
107932: LD_INT 0
107934: PPUSH
107935: CALL_OW 324
107939: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
107940: LD_EXP 156
107944: PUSH
107945: LD_EXP 165
107949: AND
107950: IFFALSE 108052
107952: GO 107954
107954: DISABLE
107955: LD_INT 0
107957: PPUSH
107958: PPUSH
// begin enable ;
107959: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
107960: LD_ADDR_VAR 0 2
107964: PUSH
107965: LD_INT 22
107967: PUSH
107968: LD_OWVAR 2
107972: PUSH
107973: EMPTY
107974: LIST
107975: LIST
107976: PUSH
107977: LD_INT 2
107979: PUSH
107980: LD_INT 34
107982: PUSH
107983: LD_INT 11
107985: PUSH
107986: EMPTY
107987: LIST
107988: LIST
107989: PUSH
107990: LD_INT 34
107992: PUSH
107993: LD_INT 30
107995: PUSH
107996: EMPTY
107997: LIST
107998: LIST
107999: PUSH
108000: EMPTY
108001: LIST
108002: LIST
108003: LIST
108004: PUSH
108005: EMPTY
108006: LIST
108007: LIST
108008: PPUSH
108009: CALL_OW 69
108013: ST_TO_ADDR
// if not tmp then
108014: LD_VAR 0 2
108018: NOT
108019: IFFALSE 108023
// exit ;
108021: GO 108052
// for i in tmp do
108023: LD_ADDR_VAR 0 1
108027: PUSH
108028: LD_VAR 0 2
108032: PUSH
108033: FOR_IN
108034: IFFALSE 108050
// begin SetLives ( i , 0 ) ;
108036: LD_VAR 0 1
108040: PPUSH
108041: LD_INT 0
108043: PPUSH
108044: CALL_OW 234
// end ;
108048: GO 108033
108050: POP
108051: POP
// end ;
108052: PPOPN 2
108054: END
// every 0 0$1 trigger StreamModeActive and sBunker do
108055: LD_EXP 156
108059: PUSH
108060: LD_EXP 166
108064: AND
108065: IFFALSE 108085
108067: GO 108069
108069: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
108070: LD_INT 32
108072: PPUSH
108073: LD_OWVAR 2
108077: PPUSH
108078: LD_INT 0
108080: PPUSH
108081: CALL_OW 324
108085: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
108086: LD_EXP 156
108090: PUSH
108091: LD_EXP 167
108095: AND
108096: IFFALSE 108277
108098: GO 108100
108100: DISABLE
108101: LD_INT 0
108103: PPUSH
108104: PPUSH
108105: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
108106: LD_ADDR_VAR 0 2
108110: PUSH
108111: LD_INT 22
108113: PUSH
108114: LD_OWVAR 2
108118: PUSH
108119: EMPTY
108120: LIST
108121: LIST
108122: PUSH
108123: LD_INT 33
108125: PUSH
108126: LD_INT 3
108128: PUSH
108129: EMPTY
108130: LIST
108131: LIST
108132: PUSH
108133: EMPTY
108134: LIST
108135: LIST
108136: PPUSH
108137: CALL_OW 69
108141: ST_TO_ADDR
// if not tmp then
108142: LD_VAR 0 2
108146: NOT
108147: IFFALSE 108151
// exit ;
108149: GO 108277
// side := 0 ;
108151: LD_ADDR_VAR 0 3
108155: PUSH
108156: LD_INT 0
108158: ST_TO_ADDR
// for i := 1 to 8 do
108159: LD_ADDR_VAR 0 1
108163: PUSH
108164: DOUBLE
108165: LD_INT 1
108167: DEC
108168: ST_TO_ADDR
108169: LD_INT 8
108171: PUSH
108172: FOR_TO
108173: IFFALSE 108221
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
108175: LD_OWVAR 2
108179: PUSH
108180: LD_VAR 0 1
108184: NONEQUAL
108185: PUSH
108186: LD_OWVAR 2
108190: PPUSH
108191: LD_VAR 0 1
108195: PPUSH
108196: CALL_OW 81
108200: PUSH
108201: LD_INT 2
108203: EQUAL
108204: AND
108205: IFFALSE 108219
// begin side := i ;
108207: LD_ADDR_VAR 0 3
108211: PUSH
108212: LD_VAR 0 1
108216: ST_TO_ADDR
// break ;
108217: GO 108221
// end ;
108219: GO 108172
108221: POP
108222: POP
// if not side then
108223: LD_VAR 0 3
108227: NOT
108228: IFFALSE 108232
// exit ;
108230: GO 108277
// for i := 1 to tmp do
108232: LD_ADDR_VAR 0 1
108236: PUSH
108237: DOUBLE
108238: LD_INT 1
108240: DEC
108241: ST_TO_ADDR
108242: LD_VAR 0 2
108246: PUSH
108247: FOR_TO
108248: IFFALSE 108275
// if Prob ( 60 ) then
108250: LD_INT 60
108252: PPUSH
108253: CALL_OW 13
108257: IFFALSE 108273
// SetSide ( i , side ) ;
108259: LD_VAR 0 1
108263: PPUSH
108264: LD_VAR 0 3
108268: PPUSH
108269: CALL_OW 235
108273: GO 108247
108275: POP
108276: POP
// end ;
108277: PPOPN 3
108279: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
108280: LD_EXP 156
108284: PUSH
108285: LD_EXP 169
108289: AND
108290: IFFALSE 108409
108292: GO 108294
108294: DISABLE
108295: LD_INT 0
108297: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
108298: LD_ADDR_VAR 0 1
108302: PUSH
108303: LD_INT 22
108305: PUSH
108306: LD_OWVAR 2
108310: PUSH
108311: EMPTY
108312: LIST
108313: LIST
108314: PUSH
108315: LD_INT 21
108317: PUSH
108318: LD_INT 1
108320: PUSH
108321: EMPTY
108322: LIST
108323: LIST
108324: PUSH
108325: LD_INT 3
108327: PUSH
108328: LD_INT 23
108330: PUSH
108331: LD_INT 0
108333: PUSH
108334: EMPTY
108335: LIST
108336: LIST
108337: PUSH
108338: EMPTY
108339: LIST
108340: LIST
108341: PUSH
108342: EMPTY
108343: LIST
108344: LIST
108345: LIST
108346: PPUSH
108347: CALL_OW 69
108351: PUSH
108352: FOR_IN
108353: IFFALSE 108407
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
108355: LD_VAR 0 1
108359: PPUSH
108360: CALL_OW 257
108364: PUSH
108365: LD_INT 1
108367: PUSH
108368: LD_INT 2
108370: PUSH
108371: LD_INT 3
108373: PUSH
108374: LD_INT 4
108376: PUSH
108377: EMPTY
108378: LIST
108379: LIST
108380: LIST
108381: LIST
108382: IN
108383: IFFALSE 108405
// SetClass ( un , rand ( 1 , 4 ) ) ;
108385: LD_VAR 0 1
108389: PPUSH
108390: LD_INT 1
108392: PPUSH
108393: LD_INT 4
108395: PPUSH
108396: CALL_OW 12
108400: PPUSH
108401: CALL_OW 336
108405: GO 108352
108407: POP
108408: POP
// end ;
108409: PPOPN 1
108411: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
108412: LD_EXP 156
108416: PUSH
108417: LD_EXP 168
108421: AND
108422: IFFALSE 108501
108424: GO 108426
108426: DISABLE
108427: LD_INT 0
108429: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
108430: LD_ADDR_VAR 0 1
108434: PUSH
108435: LD_INT 22
108437: PUSH
108438: LD_OWVAR 2
108442: PUSH
108443: EMPTY
108444: LIST
108445: LIST
108446: PUSH
108447: LD_INT 21
108449: PUSH
108450: LD_INT 3
108452: PUSH
108453: EMPTY
108454: LIST
108455: LIST
108456: PUSH
108457: EMPTY
108458: LIST
108459: LIST
108460: PPUSH
108461: CALL_OW 69
108465: ST_TO_ADDR
// if not tmp then
108466: LD_VAR 0 1
108470: NOT
108471: IFFALSE 108475
// exit ;
108473: GO 108501
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
108475: LD_VAR 0 1
108479: PUSH
108480: LD_INT 1
108482: PPUSH
108483: LD_VAR 0 1
108487: PPUSH
108488: CALL_OW 12
108492: ARRAY
108493: PPUSH
108494: LD_INT 100
108496: PPUSH
108497: CALL_OW 234
// end ;
108501: PPOPN 1
108503: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
108504: LD_EXP 156
108508: PUSH
108509: LD_EXP 170
108513: AND
108514: IFFALSE 108612
108516: GO 108518
108518: DISABLE
108519: LD_INT 0
108521: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
108522: LD_ADDR_VAR 0 1
108526: PUSH
108527: LD_INT 22
108529: PUSH
108530: LD_OWVAR 2
108534: PUSH
108535: EMPTY
108536: LIST
108537: LIST
108538: PUSH
108539: LD_INT 21
108541: PUSH
108542: LD_INT 1
108544: PUSH
108545: EMPTY
108546: LIST
108547: LIST
108548: PUSH
108549: EMPTY
108550: LIST
108551: LIST
108552: PPUSH
108553: CALL_OW 69
108557: ST_TO_ADDR
// if not tmp then
108558: LD_VAR 0 1
108562: NOT
108563: IFFALSE 108567
// exit ;
108565: GO 108612
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
108567: LD_VAR 0 1
108571: PUSH
108572: LD_INT 1
108574: PPUSH
108575: LD_VAR 0 1
108579: PPUSH
108580: CALL_OW 12
108584: ARRAY
108585: PPUSH
108586: LD_INT 1
108588: PPUSH
108589: LD_INT 4
108591: PPUSH
108592: CALL_OW 12
108596: PPUSH
108597: LD_INT 3000
108599: PPUSH
108600: LD_INT 9000
108602: PPUSH
108603: CALL_OW 12
108607: PPUSH
108608: CALL_OW 492
// end ;
108612: PPOPN 1
108614: END
// every 0 0$1 trigger StreamModeActive and sDepot do
108615: LD_EXP 156
108619: PUSH
108620: LD_EXP 171
108624: AND
108625: IFFALSE 108645
108627: GO 108629
108629: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
108630: LD_INT 1
108632: PPUSH
108633: LD_OWVAR 2
108637: PPUSH
108638: LD_INT 0
108640: PPUSH
108641: CALL_OW 324
108645: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
108646: LD_EXP 156
108650: PUSH
108651: LD_EXP 172
108655: AND
108656: IFFALSE 108739
108658: GO 108660
108660: DISABLE
108661: LD_INT 0
108663: PPUSH
108664: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
108665: LD_ADDR_VAR 0 2
108669: PUSH
108670: LD_INT 22
108672: PUSH
108673: LD_OWVAR 2
108677: PUSH
108678: EMPTY
108679: LIST
108680: LIST
108681: PUSH
108682: LD_INT 21
108684: PUSH
108685: LD_INT 3
108687: PUSH
108688: EMPTY
108689: LIST
108690: LIST
108691: PUSH
108692: EMPTY
108693: LIST
108694: LIST
108695: PPUSH
108696: CALL_OW 69
108700: ST_TO_ADDR
// if not tmp then
108701: LD_VAR 0 2
108705: NOT
108706: IFFALSE 108710
// exit ;
108708: GO 108739
// for i in tmp do
108710: LD_ADDR_VAR 0 1
108714: PUSH
108715: LD_VAR 0 2
108719: PUSH
108720: FOR_IN
108721: IFFALSE 108737
// SetBLevel ( i , 10 ) ;
108723: LD_VAR 0 1
108727: PPUSH
108728: LD_INT 10
108730: PPUSH
108731: CALL_OW 241
108735: GO 108720
108737: POP
108738: POP
// end ;
108739: PPOPN 2
108741: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
108742: LD_EXP 156
108746: PUSH
108747: LD_EXP 173
108751: AND
108752: IFFALSE 108863
108754: GO 108756
108756: DISABLE
108757: LD_INT 0
108759: PPUSH
108760: PPUSH
108761: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
108762: LD_ADDR_VAR 0 3
108766: PUSH
108767: LD_INT 22
108769: PUSH
108770: LD_OWVAR 2
108774: PUSH
108775: EMPTY
108776: LIST
108777: LIST
108778: PUSH
108779: LD_INT 25
108781: PUSH
108782: LD_INT 1
108784: PUSH
108785: EMPTY
108786: LIST
108787: LIST
108788: PUSH
108789: EMPTY
108790: LIST
108791: LIST
108792: PPUSH
108793: CALL_OW 69
108797: ST_TO_ADDR
// if not tmp then
108798: LD_VAR 0 3
108802: NOT
108803: IFFALSE 108807
// exit ;
108805: GO 108863
// un := tmp [ rand ( 1 , tmp ) ] ;
108807: LD_ADDR_VAR 0 2
108811: PUSH
108812: LD_VAR 0 3
108816: PUSH
108817: LD_INT 1
108819: PPUSH
108820: LD_VAR 0 3
108824: PPUSH
108825: CALL_OW 12
108829: ARRAY
108830: ST_TO_ADDR
// if Crawls ( un ) then
108831: LD_VAR 0 2
108835: PPUSH
108836: CALL_OW 318
108840: IFFALSE 108851
// ComWalk ( un ) ;
108842: LD_VAR 0 2
108846: PPUSH
108847: CALL_OW 138
// SetClass ( un , class_sniper ) ;
108851: LD_VAR 0 2
108855: PPUSH
108856: LD_INT 5
108858: PPUSH
108859: CALL_OW 336
// end ;
108863: PPOPN 3
108865: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
108866: LD_EXP 156
108870: PUSH
108871: LD_EXP 174
108875: AND
108876: PUSH
108877: LD_OWVAR 67
108881: PUSH
108882: LD_INT 3
108884: LESS
108885: AND
108886: IFFALSE 108905
108888: GO 108890
108890: DISABLE
// Difficulty := Difficulty + 1 ;
108891: LD_ADDR_OWVAR 67
108895: PUSH
108896: LD_OWVAR 67
108900: PUSH
108901: LD_INT 1
108903: PLUS
108904: ST_TO_ADDR
108905: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
108906: LD_EXP 156
108910: PUSH
108911: LD_EXP 175
108915: AND
108916: IFFALSE 109019
108918: GO 108920
108920: DISABLE
108921: LD_INT 0
108923: PPUSH
// begin for i := 1 to 5 do
108924: LD_ADDR_VAR 0 1
108928: PUSH
108929: DOUBLE
108930: LD_INT 1
108932: DEC
108933: ST_TO_ADDR
108934: LD_INT 5
108936: PUSH
108937: FOR_TO
108938: IFFALSE 109017
// begin uc_nation := nation_nature ;
108940: LD_ADDR_OWVAR 21
108944: PUSH
108945: LD_INT 0
108947: ST_TO_ADDR
// uc_side := 0 ;
108948: LD_ADDR_OWVAR 20
108952: PUSH
108953: LD_INT 0
108955: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
108956: LD_ADDR_OWVAR 29
108960: PUSH
108961: LD_INT 12
108963: PUSH
108964: LD_INT 12
108966: PUSH
108967: EMPTY
108968: LIST
108969: LIST
108970: ST_TO_ADDR
// hc_agressivity := 20 ;
108971: LD_ADDR_OWVAR 35
108975: PUSH
108976: LD_INT 20
108978: ST_TO_ADDR
// hc_class := class_tiger ;
108979: LD_ADDR_OWVAR 28
108983: PUSH
108984: LD_INT 14
108986: ST_TO_ADDR
// hc_gallery :=  ;
108987: LD_ADDR_OWVAR 33
108991: PUSH
108992: LD_STRING 
108994: ST_TO_ADDR
// hc_name :=  ;
108995: LD_ADDR_OWVAR 26
108999: PUSH
109000: LD_STRING 
109002: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
109003: CALL_OW 44
109007: PPUSH
109008: LD_INT 0
109010: PPUSH
109011: CALL_OW 51
// end ;
109015: GO 108937
109017: POP
109018: POP
// end ;
109019: PPOPN 1
109021: END
// every 0 0$1 trigger StreamModeActive and sBomb do
109022: LD_EXP 156
109026: PUSH
109027: LD_EXP 176
109031: AND
109032: IFFALSE 109041
109034: GO 109036
109036: DISABLE
// StreamSibBomb ;
109037: CALL 109042 0 0
109041: END
// export function StreamSibBomb ; var i , x , y ; begin
109042: LD_INT 0
109044: PPUSH
109045: PPUSH
109046: PPUSH
109047: PPUSH
// result := false ;
109048: LD_ADDR_VAR 0 1
109052: PUSH
109053: LD_INT 0
109055: ST_TO_ADDR
// for i := 1 to 16 do
109056: LD_ADDR_VAR 0 2
109060: PUSH
109061: DOUBLE
109062: LD_INT 1
109064: DEC
109065: ST_TO_ADDR
109066: LD_INT 16
109068: PUSH
109069: FOR_TO
109070: IFFALSE 109269
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
109072: LD_ADDR_VAR 0 3
109076: PUSH
109077: LD_INT 10
109079: PUSH
109080: LD_INT 20
109082: PUSH
109083: LD_INT 30
109085: PUSH
109086: LD_INT 40
109088: PUSH
109089: LD_INT 50
109091: PUSH
109092: LD_INT 60
109094: PUSH
109095: LD_INT 70
109097: PUSH
109098: LD_INT 80
109100: PUSH
109101: LD_INT 90
109103: PUSH
109104: LD_INT 100
109106: PUSH
109107: LD_INT 110
109109: PUSH
109110: LD_INT 120
109112: PUSH
109113: LD_INT 130
109115: PUSH
109116: LD_INT 140
109118: PUSH
109119: LD_INT 150
109121: PUSH
109122: EMPTY
109123: LIST
109124: LIST
109125: LIST
109126: LIST
109127: LIST
109128: LIST
109129: LIST
109130: LIST
109131: LIST
109132: LIST
109133: LIST
109134: LIST
109135: LIST
109136: LIST
109137: LIST
109138: PUSH
109139: LD_INT 1
109141: PPUSH
109142: LD_INT 15
109144: PPUSH
109145: CALL_OW 12
109149: ARRAY
109150: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
109151: LD_ADDR_VAR 0 4
109155: PUSH
109156: LD_INT 10
109158: PUSH
109159: LD_INT 20
109161: PUSH
109162: LD_INT 30
109164: PUSH
109165: LD_INT 40
109167: PUSH
109168: LD_INT 50
109170: PUSH
109171: LD_INT 60
109173: PUSH
109174: LD_INT 70
109176: PUSH
109177: LD_INT 80
109179: PUSH
109180: LD_INT 90
109182: PUSH
109183: LD_INT 100
109185: PUSH
109186: LD_INT 110
109188: PUSH
109189: LD_INT 120
109191: PUSH
109192: LD_INT 130
109194: PUSH
109195: LD_INT 140
109197: PUSH
109198: LD_INT 150
109200: PUSH
109201: EMPTY
109202: LIST
109203: LIST
109204: LIST
109205: LIST
109206: LIST
109207: LIST
109208: LIST
109209: LIST
109210: LIST
109211: LIST
109212: LIST
109213: LIST
109214: LIST
109215: LIST
109216: LIST
109217: PUSH
109218: LD_INT 1
109220: PPUSH
109221: LD_INT 15
109223: PPUSH
109224: CALL_OW 12
109228: ARRAY
109229: ST_TO_ADDR
// if ValidHex ( x , y ) then
109230: LD_VAR 0 3
109234: PPUSH
109235: LD_VAR 0 4
109239: PPUSH
109240: CALL_OW 488
109244: IFFALSE 109267
// begin result := [ x , y ] ;
109246: LD_ADDR_VAR 0 1
109250: PUSH
109251: LD_VAR 0 3
109255: PUSH
109256: LD_VAR 0 4
109260: PUSH
109261: EMPTY
109262: LIST
109263: LIST
109264: ST_TO_ADDR
// break ;
109265: GO 109269
// end ; end ;
109267: GO 109069
109269: POP
109270: POP
// if result then
109271: LD_VAR 0 1
109275: IFFALSE 109335
// begin ToLua ( playSibBomb() ) ;
109277: LD_STRING playSibBomb()
109279: PPUSH
109280: CALL_OW 559
// wait ( 0 0$14 ) ;
109284: LD_INT 490
109286: PPUSH
109287: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
109291: LD_VAR 0 1
109295: PUSH
109296: LD_INT 1
109298: ARRAY
109299: PPUSH
109300: LD_VAR 0 1
109304: PUSH
109305: LD_INT 2
109307: ARRAY
109308: PPUSH
109309: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
109313: LD_VAR 0 1
109317: PUSH
109318: LD_INT 1
109320: ARRAY
109321: PPUSH
109322: LD_VAR 0 1
109326: PUSH
109327: LD_INT 2
109329: ARRAY
109330: PPUSH
109331: CALL_OW 429
// end ; end ;
109335: LD_VAR 0 1
109339: RET
// every 0 0$1 trigger StreamModeActive and sReset do
109340: LD_EXP 156
109344: PUSH
109345: LD_EXP 178
109349: AND
109350: IFFALSE 109362
109352: GO 109354
109354: DISABLE
// YouLost (  ) ;
109355: LD_STRING 
109357: PPUSH
109358: CALL_OW 104
109362: END
// every 0 0$1 trigger StreamModeActive and sFog do
109363: LD_EXP 156
109367: PUSH
109368: LD_EXP 177
109372: AND
109373: IFFALSE 109387
109375: GO 109377
109377: DISABLE
// FogOff ( your_side ) ;
109378: LD_OWVAR 2
109382: PPUSH
109383: CALL_OW 344
109387: END
// every 0 0$1 trigger StreamModeActive and sSun do
109388: LD_EXP 156
109392: PUSH
109393: LD_EXP 179
109397: AND
109398: IFFALSE 109426
109400: GO 109402
109402: DISABLE
// begin solar_recharge_percent := 0 ;
109403: LD_ADDR_OWVAR 79
109407: PUSH
109408: LD_INT 0
109410: ST_TO_ADDR
// wait ( 5 5$00 ) ;
109411: LD_INT 10500
109413: PPUSH
109414: CALL_OW 67
// solar_recharge_percent := 100 ;
109418: LD_ADDR_OWVAR 79
109422: PUSH
109423: LD_INT 100
109425: ST_TO_ADDR
// end ;
109426: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
109427: LD_EXP 156
109431: PUSH
109432: LD_EXP 180
109436: AND
109437: IFFALSE 109676
109439: GO 109441
109441: DISABLE
109442: LD_INT 0
109444: PPUSH
109445: PPUSH
109446: PPUSH
// begin tmp := [ ] ;
109447: LD_ADDR_VAR 0 3
109451: PUSH
109452: EMPTY
109453: ST_TO_ADDR
// for i := 1 to 6 do
109454: LD_ADDR_VAR 0 1
109458: PUSH
109459: DOUBLE
109460: LD_INT 1
109462: DEC
109463: ST_TO_ADDR
109464: LD_INT 6
109466: PUSH
109467: FOR_TO
109468: IFFALSE 109573
// begin uc_nation := nation_nature ;
109470: LD_ADDR_OWVAR 21
109474: PUSH
109475: LD_INT 0
109477: ST_TO_ADDR
// uc_side := 0 ;
109478: LD_ADDR_OWVAR 20
109482: PUSH
109483: LD_INT 0
109485: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
109486: LD_ADDR_OWVAR 29
109490: PUSH
109491: LD_INT 12
109493: PUSH
109494: LD_INT 12
109496: PUSH
109497: EMPTY
109498: LIST
109499: LIST
109500: ST_TO_ADDR
// hc_agressivity := 20 ;
109501: LD_ADDR_OWVAR 35
109505: PUSH
109506: LD_INT 20
109508: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
109509: LD_ADDR_OWVAR 28
109513: PUSH
109514: LD_INT 17
109516: ST_TO_ADDR
// hc_gallery :=  ;
109517: LD_ADDR_OWVAR 33
109521: PUSH
109522: LD_STRING 
109524: ST_TO_ADDR
// hc_name :=  ;
109525: LD_ADDR_OWVAR 26
109529: PUSH
109530: LD_STRING 
109532: ST_TO_ADDR
// un := CreateHuman ;
109533: LD_ADDR_VAR 0 2
109537: PUSH
109538: CALL_OW 44
109542: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
109543: LD_VAR 0 2
109547: PPUSH
109548: LD_INT 1
109550: PPUSH
109551: CALL_OW 51
// tmp := tmp ^ un ;
109555: LD_ADDR_VAR 0 3
109559: PUSH
109560: LD_VAR 0 3
109564: PUSH
109565: LD_VAR 0 2
109569: ADD
109570: ST_TO_ADDR
// end ;
109571: GO 109467
109573: POP
109574: POP
// repeat wait ( 0 0$1 ) ;
109575: LD_INT 35
109577: PPUSH
109578: CALL_OW 67
// for un in tmp do
109582: LD_ADDR_VAR 0 2
109586: PUSH
109587: LD_VAR 0 3
109591: PUSH
109592: FOR_IN
109593: IFFALSE 109667
// begin if IsDead ( un ) then
109595: LD_VAR 0 2
109599: PPUSH
109600: CALL_OW 301
109604: IFFALSE 109624
// begin tmp := tmp diff un ;
109606: LD_ADDR_VAR 0 3
109610: PUSH
109611: LD_VAR 0 3
109615: PUSH
109616: LD_VAR 0 2
109620: DIFF
109621: ST_TO_ADDR
// continue ;
109622: GO 109592
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
109624: LD_VAR 0 2
109628: PPUSH
109629: LD_INT 3
109631: PUSH
109632: LD_INT 22
109634: PUSH
109635: LD_INT 0
109637: PUSH
109638: EMPTY
109639: LIST
109640: LIST
109641: PUSH
109642: EMPTY
109643: LIST
109644: LIST
109645: PPUSH
109646: CALL_OW 69
109650: PPUSH
109651: LD_VAR 0 2
109655: PPUSH
109656: CALL_OW 74
109660: PPUSH
109661: CALL_OW 115
// end ;
109665: GO 109592
109667: POP
109668: POP
// until not tmp ;
109669: LD_VAR 0 3
109673: NOT
109674: IFFALSE 109575
// end ;
109676: PPOPN 3
109678: END
// every 0 0$1 trigger StreamModeActive and sTroll do
109679: LD_EXP 156
109683: PUSH
109684: LD_EXP 181
109688: AND
109689: IFFALSE 109743
109691: GO 109693
109693: DISABLE
// begin ToLua ( displayTroll(); ) ;
109694: LD_STRING displayTroll();
109696: PPUSH
109697: CALL_OW 559
// wait ( 3 3$00 ) ;
109701: LD_INT 6300
109703: PPUSH
109704: CALL_OW 67
// ToLua ( hideTroll(); ) ;
109708: LD_STRING hideTroll();
109710: PPUSH
109711: CALL_OW 559
// wait ( 1 1$00 ) ;
109715: LD_INT 2100
109717: PPUSH
109718: CALL_OW 67
// ToLua ( displayTroll(); ) ;
109722: LD_STRING displayTroll();
109724: PPUSH
109725: CALL_OW 559
// wait ( 1 1$00 ) ;
109729: LD_INT 2100
109731: PPUSH
109732: CALL_OW 67
// ToLua ( hideTroll(); ) ;
109736: LD_STRING hideTroll();
109738: PPUSH
109739: CALL_OW 559
// end ;
109743: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
109744: LD_EXP 156
109748: PUSH
109749: LD_EXP 182
109753: AND
109754: IFFALSE 109817
109756: GO 109758
109758: DISABLE
109759: LD_INT 0
109761: PPUSH
// begin p := 0 ;
109762: LD_ADDR_VAR 0 1
109766: PUSH
109767: LD_INT 0
109769: ST_TO_ADDR
// repeat game_speed := 1 ;
109770: LD_ADDR_OWVAR 65
109774: PUSH
109775: LD_INT 1
109777: ST_TO_ADDR
// wait ( 0 0$1 ) ;
109778: LD_INT 35
109780: PPUSH
109781: CALL_OW 67
// p := p + 1 ;
109785: LD_ADDR_VAR 0 1
109789: PUSH
109790: LD_VAR 0 1
109794: PUSH
109795: LD_INT 1
109797: PLUS
109798: ST_TO_ADDR
// until p >= 60 ;
109799: LD_VAR 0 1
109803: PUSH
109804: LD_INT 60
109806: GREATEREQUAL
109807: IFFALSE 109770
// game_speed := 4 ;
109809: LD_ADDR_OWVAR 65
109813: PUSH
109814: LD_INT 4
109816: ST_TO_ADDR
// end ;
109817: PPOPN 1
109819: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
109820: LD_EXP 156
109824: PUSH
109825: LD_EXP 183
109829: AND
109830: IFFALSE 109976
109832: GO 109834
109834: DISABLE
109835: LD_INT 0
109837: PPUSH
109838: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
109839: LD_ADDR_VAR 0 1
109843: PUSH
109844: LD_INT 22
109846: PUSH
109847: LD_OWVAR 2
109851: PUSH
109852: EMPTY
109853: LIST
109854: LIST
109855: PUSH
109856: LD_INT 2
109858: PUSH
109859: LD_INT 30
109861: PUSH
109862: LD_INT 0
109864: PUSH
109865: EMPTY
109866: LIST
109867: LIST
109868: PUSH
109869: LD_INT 30
109871: PUSH
109872: LD_INT 1
109874: PUSH
109875: EMPTY
109876: LIST
109877: LIST
109878: PUSH
109879: EMPTY
109880: LIST
109881: LIST
109882: LIST
109883: PUSH
109884: EMPTY
109885: LIST
109886: LIST
109887: PPUSH
109888: CALL_OW 69
109892: ST_TO_ADDR
// if not depot then
109893: LD_VAR 0 1
109897: NOT
109898: IFFALSE 109902
// exit ;
109900: GO 109976
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
109902: LD_ADDR_VAR 0 2
109906: PUSH
109907: LD_VAR 0 1
109911: PUSH
109912: LD_INT 1
109914: PPUSH
109915: LD_VAR 0 1
109919: PPUSH
109920: CALL_OW 12
109924: ARRAY
109925: PPUSH
109926: CALL_OW 274
109930: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
109931: LD_VAR 0 2
109935: PPUSH
109936: LD_INT 1
109938: PPUSH
109939: LD_INT 0
109941: PPUSH
109942: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
109946: LD_VAR 0 2
109950: PPUSH
109951: LD_INT 2
109953: PPUSH
109954: LD_INT 0
109956: PPUSH
109957: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
109961: LD_VAR 0 2
109965: PPUSH
109966: LD_INT 3
109968: PPUSH
109969: LD_INT 0
109971: PPUSH
109972: CALL_OW 277
// end ;
109976: PPOPN 2
109978: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
109979: LD_EXP 156
109983: PUSH
109984: LD_EXP 184
109988: AND
109989: IFFALSE 110086
109991: GO 109993
109993: DISABLE
109994: LD_INT 0
109996: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
109997: LD_ADDR_VAR 0 1
110001: PUSH
110002: LD_INT 22
110004: PUSH
110005: LD_OWVAR 2
110009: PUSH
110010: EMPTY
110011: LIST
110012: LIST
110013: PUSH
110014: LD_INT 21
110016: PUSH
110017: LD_INT 1
110019: PUSH
110020: EMPTY
110021: LIST
110022: LIST
110023: PUSH
110024: LD_INT 3
110026: PUSH
110027: LD_INT 23
110029: PUSH
110030: LD_INT 0
110032: PUSH
110033: EMPTY
110034: LIST
110035: LIST
110036: PUSH
110037: EMPTY
110038: LIST
110039: LIST
110040: PUSH
110041: EMPTY
110042: LIST
110043: LIST
110044: LIST
110045: PPUSH
110046: CALL_OW 69
110050: ST_TO_ADDR
// if not tmp then
110051: LD_VAR 0 1
110055: NOT
110056: IFFALSE 110060
// exit ;
110058: GO 110086
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
110060: LD_VAR 0 1
110064: PUSH
110065: LD_INT 1
110067: PPUSH
110068: LD_VAR 0 1
110072: PPUSH
110073: CALL_OW 12
110077: ARRAY
110078: PPUSH
110079: LD_INT 200
110081: PPUSH
110082: CALL_OW 234
// end ;
110086: PPOPN 1
110088: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
110089: LD_EXP 156
110093: PUSH
110094: LD_EXP 185
110098: AND
110099: IFFALSE 110178
110101: GO 110103
110103: DISABLE
110104: LD_INT 0
110106: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
110107: LD_ADDR_VAR 0 1
110111: PUSH
110112: LD_INT 22
110114: PUSH
110115: LD_OWVAR 2
110119: PUSH
110120: EMPTY
110121: LIST
110122: LIST
110123: PUSH
110124: LD_INT 21
110126: PUSH
110127: LD_INT 2
110129: PUSH
110130: EMPTY
110131: LIST
110132: LIST
110133: PUSH
110134: EMPTY
110135: LIST
110136: LIST
110137: PPUSH
110138: CALL_OW 69
110142: ST_TO_ADDR
// if not tmp then
110143: LD_VAR 0 1
110147: NOT
110148: IFFALSE 110152
// exit ;
110150: GO 110178
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
110152: LD_VAR 0 1
110156: PUSH
110157: LD_INT 1
110159: PPUSH
110160: LD_VAR 0 1
110164: PPUSH
110165: CALL_OW 12
110169: ARRAY
110170: PPUSH
110171: LD_INT 60
110173: PPUSH
110174: CALL_OW 234
// end ;
110178: PPOPN 1
110180: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
110181: LD_EXP 156
110185: PUSH
110186: LD_EXP 186
110190: AND
110191: IFFALSE 110290
110193: GO 110195
110195: DISABLE
110196: LD_INT 0
110198: PPUSH
110199: PPUSH
// begin enable ;
110200: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
110201: LD_ADDR_VAR 0 1
110205: PUSH
110206: LD_INT 22
110208: PUSH
110209: LD_OWVAR 2
110213: PUSH
110214: EMPTY
110215: LIST
110216: LIST
110217: PUSH
110218: LD_INT 61
110220: PUSH
110221: EMPTY
110222: LIST
110223: PUSH
110224: LD_INT 33
110226: PUSH
110227: LD_INT 2
110229: PUSH
110230: EMPTY
110231: LIST
110232: LIST
110233: PUSH
110234: EMPTY
110235: LIST
110236: LIST
110237: LIST
110238: PPUSH
110239: CALL_OW 69
110243: ST_TO_ADDR
// if not tmp then
110244: LD_VAR 0 1
110248: NOT
110249: IFFALSE 110253
// exit ;
110251: GO 110290
// for i in tmp do
110253: LD_ADDR_VAR 0 2
110257: PUSH
110258: LD_VAR 0 1
110262: PUSH
110263: FOR_IN
110264: IFFALSE 110288
// if IsControledBy ( i ) then
110266: LD_VAR 0 2
110270: PPUSH
110271: CALL_OW 312
110275: IFFALSE 110286
// ComUnlink ( i ) ;
110277: LD_VAR 0 2
110281: PPUSH
110282: CALL_OW 136
110286: GO 110263
110288: POP
110289: POP
// end ;
110290: PPOPN 2
110292: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
110293: LD_EXP 156
110297: PUSH
110298: LD_EXP 187
110302: AND
110303: IFFALSE 110443
110305: GO 110307
110307: DISABLE
110308: LD_INT 0
110310: PPUSH
110311: PPUSH
// begin ToLua ( displayPowell(); ) ;
110312: LD_STRING displayPowell();
110314: PPUSH
110315: CALL_OW 559
// uc_side := 0 ;
110319: LD_ADDR_OWVAR 20
110323: PUSH
110324: LD_INT 0
110326: ST_TO_ADDR
// uc_nation := 2 ;
110327: LD_ADDR_OWVAR 21
110331: PUSH
110332: LD_INT 2
110334: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
110335: LD_ADDR_OWVAR 37
110339: PUSH
110340: LD_INT 14
110342: ST_TO_ADDR
// vc_engine := engine_siberite ;
110343: LD_ADDR_OWVAR 39
110347: PUSH
110348: LD_INT 3
110350: ST_TO_ADDR
// vc_control := control_apeman ;
110351: LD_ADDR_OWVAR 38
110355: PUSH
110356: LD_INT 5
110358: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
110359: LD_ADDR_OWVAR 40
110363: PUSH
110364: LD_INT 29
110366: ST_TO_ADDR
// un := CreateVehicle ;
110367: LD_ADDR_VAR 0 2
110371: PUSH
110372: CALL_OW 45
110376: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
110377: LD_VAR 0 2
110381: PPUSH
110382: LD_INT 1
110384: PPUSH
110385: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
110389: LD_INT 35
110391: PPUSH
110392: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
110396: LD_VAR 0 2
110400: PPUSH
110401: LD_INT 22
110403: PUSH
110404: LD_OWVAR 2
110408: PUSH
110409: EMPTY
110410: LIST
110411: LIST
110412: PPUSH
110413: CALL_OW 69
110417: PPUSH
110418: LD_VAR 0 2
110422: PPUSH
110423: CALL_OW 74
110427: PPUSH
110428: CALL_OW 115
// until IsDead ( un ) ;
110432: LD_VAR 0 2
110436: PPUSH
110437: CALL_OW 301
110441: IFFALSE 110389
// end ;
110443: PPOPN 2
110445: END
// every 0 0$1 trigger StreamModeActive and sStu do
110446: LD_EXP 156
110450: PUSH
110451: LD_EXP 195
110455: AND
110456: IFFALSE 110472
110458: GO 110460
110460: DISABLE
// begin ToLua ( displayStucuk(); ) ;
110461: LD_STRING displayStucuk();
110463: PPUSH
110464: CALL_OW 559
// ResetFog ;
110468: CALL_OW 335
// end ;
110472: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
110473: LD_EXP 156
110477: PUSH
110478: LD_EXP 188
110482: AND
110483: IFFALSE 110624
110485: GO 110487
110487: DISABLE
110488: LD_INT 0
110490: PPUSH
110491: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
110492: LD_ADDR_VAR 0 2
110496: PUSH
110497: LD_INT 22
110499: PUSH
110500: LD_OWVAR 2
110504: PUSH
110505: EMPTY
110506: LIST
110507: LIST
110508: PUSH
110509: LD_INT 21
110511: PUSH
110512: LD_INT 1
110514: PUSH
110515: EMPTY
110516: LIST
110517: LIST
110518: PUSH
110519: EMPTY
110520: LIST
110521: LIST
110522: PPUSH
110523: CALL_OW 69
110527: ST_TO_ADDR
// if not tmp then
110528: LD_VAR 0 2
110532: NOT
110533: IFFALSE 110537
// exit ;
110535: GO 110624
// un := tmp [ rand ( 1 , tmp ) ] ;
110537: LD_ADDR_VAR 0 1
110541: PUSH
110542: LD_VAR 0 2
110546: PUSH
110547: LD_INT 1
110549: PPUSH
110550: LD_VAR 0 2
110554: PPUSH
110555: CALL_OW 12
110559: ARRAY
110560: ST_TO_ADDR
// SetSide ( un , 0 ) ;
110561: LD_VAR 0 1
110565: PPUSH
110566: LD_INT 0
110568: PPUSH
110569: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
110573: LD_VAR 0 1
110577: PPUSH
110578: LD_OWVAR 3
110582: PUSH
110583: LD_VAR 0 1
110587: DIFF
110588: PPUSH
110589: LD_VAR 0 1
110593: PPUSH
110594: CALL_OW 74
110598: PPUSH
110599: CALL_OW 115
// wait ( 0 0$20 ) ;
110603: LD_INT 700
110605: PPUSH
110606: CALL_OW 67
// SetSide ( un , your_side ) ;
110610: LD_VAR 0 1
110614: PPUSH
110615: LD_OWVAR 2
110619: PPUSH
110620: CALL_OW 235
// end ;
110624: PPOPN 2
110626: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
110627: LD_EXP 156
110631: PUSH
110632: LD_EXP 189
110636: AND
110637: IFFALSE 110743
110639: GO 110641
110641: DISABLE
110642: LD_INT 0
110644: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
110645: LD_ADDR_VAR 0 1
110649: PUSH
110650: LD_INT 22
110652: PUSH
110653: LD_OWVAR 2
110657: PUSH
110658: EMPTY
110659: LIST
110660: LIST
110661: PUSH
110662: LD_INT 2
110664: PUSH
110665: LD_INT 30
110667: PUSH
110668: LD_INT 0
110670: PUSH
110671: EMPTY
110672: LIST
110673: LIST
110674: PUSH
110675: LD_INT 30
110677: PUSH
110678: LD_INT 1
110680: PUSH
110681: EMPTY
110682: LIST
110683: LIST
110684: PUSH
110685: EMPTY
110686: LIST
110687: LIST
110688: LIST
110689: PUSH
110690: EMPTY
110691: LIST
110692: LIST
110693: PPUSH
110694: CALL_OW 69
110698: ST_TO_ADDR
// if not depot then
110699: LD_VAR 0 1
110703: NOT
110704: IFFALSE 110708
// exit ;
110706: GO 110743
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
110708: LD_VAR 0 1
110712: PUSH
110713: LD_INT 1
110715: ARRAY
110716: PPUSH
110717: CALL_OW 250
110721: PPUSH
110722: LD_VAR 0 1
110726: PUSH
110727: LD_INT 1
110729: ARRAY
110730: PPUSH
110731: CALL_OW 251
110735: PPUSH
110736: LD_INT 70
110738: PPUSH
110739: CALL_OW 495
// end ;
110743: PPOPN 1
110745: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
110746: LD_EXP 156
110750: PUSH
110751: LD_EXP 190
110755: AND
110756: IFFALSE 110967
110758: GO 110760
110760: DISABLE
110761: LD_INT 0
110763: PPUSH
110764: PPUSH
110765: PPUSH
110766: PPUSH
110767: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
110768: LD_ADDR_VAR 0 5
110772: PUSH
110773: LD_INT 22
110775: PUSH
110776: LD_OWVAR 2
110780: PUSH
110781: EMPTY
110782: LIST
110783: LIST
110784: PUSH
110785: LD_INT 21
110787: PUSH
110788: LD_INT 1
110790: PUSH
110791: EMPTY
110792: LIST
110793: LIST
110794: PUSH
110795: EMPTY
110796: LIST
110797: LIST
110798: PPUSH
110799: CALL_OW 69
110803: ST_TO_ADDR
// if not tmp then
110804: LD_VAR 0 5
110808: NOT
110809: IFFALSE 110813
// exit ;
110811: GO 110967
// for i in tmp do
110813: LD_ADDR_VAR 0 1
110817: PUSH
110818: LD_VAR 0 5
110822: PUSH
110823: FOR_IN
110824: IFFALSE 110965
// begin d := rand ( 0 , 5 ) ;
110826: LD_ADDR_VAR 0 4
110830: PUSH
110831: LD_INT 0
110833: PPUSH
110834: LD_INT 5
110836: PPUSH
110837: CALL_OW 12
110841: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
110842: LD_ADDR_VAR 0 2
110846: PUSH
110847: LD_VAR 0 1
110851: PPUSH
110852: CALL_OW 250
110856: PPUSH
110857: LD_VAR 0 4
110861: PPUSH
110862: LD_INT 3
110864: PPUSH
110865: LD_INT 12
110867: PPUSH
110868: CALL_OW 12
110872: PPUSH
110873: CALL_OW 272
110877: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
110878: LD_ADDR_VAR 0 3
110882: PUSH
110883: LD_VAR 0 1
110887: PPUSH
110888: CALL_OW 251
110892: PPUSH
110893: LD_VAR 0 4
110897: PPUSH
110898: LD_INT 3
110900: PPUSH
110901: LD_INT 12
110903: PPUSH
110904: CALL_OW 12
110908: PPUSH
110909: CALL_OW 273
110913: ST_TO_ADDR
// if ValidHex ( x , y ) then
110914: LD_VAR 0 2
110918: PPUSH
110919: LD_VAR 0 3
110923: PPUSH
110924: CALL_OW 488
110928: IFFALSE 110963
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
110930: LD_VAR 0 1
110934: PPUSH
110935: LD_VAR 0 2
110939: PPUSH
110940: LD_VAR 0 3
110944: PPUSH
110945: LD_INT 3
110947: PPUSH
110948: LD_INT 6
110950: PPUSH
110951: CALL_OW 12
110955: PPUSH
110956: LD_INT 1
110958: PPUSH
110959: CALL_OW 483
// end ;
110963: GO 110823
110965: POP
110966: POP
// end ;
110967: PPOPN 5
110969: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
110970: LD_EXP 156
110974: PUSH
110975: LD_EXP 191
110979: AND
110980: IFFALSE 111074
110982: GO 110984
110984: DISABLE
110985: LD_INT 0
110987: PPUSH
110988: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
110989: LD_ADDR_VAR 0 2
110993: PUSH
110994: LD_INT 22
110996: PUSH
110997: LD_OWVAR 2
111001: PUSH
111002: EMPTY
111003: LIST
111004: LIST
111005: PUSH
111006: LD_INT 32
111008: PUSH
111009: LD_INT 1
111011: PUSH
111012: EMPTY
111013: LIST
111014: LIST
111015: PUSH
111016: LD_INT 21
111018: PUSH
111019: LD_INT 2
111021: PUSH
111022: EMPTY
111023: LIST
111024: LIST
111025: PUSH
111026: EMPTY
111027: LIST
111028: LIST
111029: LIST
111030: PPUSH
111031: CALL_OW 69
111035: ST_TO_ADDR
// if not tmp then
111036: LD_VAR 0 2
111040: NOT
111041: IFFALSE 111045
// exit ;
111043: GO 111074
// for i in tmp do
111045: LD_ADDR_VAR 0 1
111049: PUSH
111050: LD_VAR 0 2
111054: PUSH
111055: FOR_IN
111056: IFFALSE 111072
// SetFuel ( i , 0 ) ;
111058: LD_VAR 0 1
111062: PPUSH
111063: LD_INT 0
111065: PPUSH
111066: CALL_OW 240
111070: GO 111055
111072: POP
111073: POP
// end ;
111074: PPOPN 2
111076: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
111077: LD_EXP 156
111081: PUSH
111082: LD_EXP 192
111086: AND
111087: IFFALSE 111153
111089: GO 111091
111091: DISABLE
111092: LD_INT 0
111094: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
111095: LD_ADDR_VAR 0 1
111099: PUSH
111100: LD_INT 22
111102: PUSH
111103: LD_OWVAR 2
111107: PUSH
111108: EMPTY
111109: LIST
111110: LIST
111111: PUSH
111112: LD_INT 30
111114: PUSH
111115: LD_INT 29
111117: PUSH
111118: EMPTY
111119: LIST
111120: LIST
111121: PUSH
111122: EMPTY
111123: LIST
111124: LIST
111125: PPUSH
111126: CALL_OW 69
111130: ST_TO_ADDR
// if not tmp then
111131: LD_VAR 0 1
111135: NOT
111136: IFFALSE 111140
// exit ;
111138: GO 111153
// DestroyUnit ( tmp [ 1 ] ) ;
111140: LD_VAR 0 1
111144: PUSH
111145: LD_INT 1
111147: ARRAY
111148: PPUSH
111149: CALL_OW 65
// end ;
111153: PPOPN 1
111155: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
111156: LD_EXP 156
111160: PUSH
111161: LD_EXP 194
111165: AND
111166: IFFALSE 111295
111168: GO 111170
111170: DISABLE
111171: LD_INT 0
111173: PPUSH
// begin uc_side := 0 ;
111174: LD_ADDR_OWVAR 20
111178: PUSH
111179: LD_INT 0
111181: ST_TO_ADDR
// uc_nation := nation_arabian ;
111182: LD_ADDR_OWVAR 21
111186: PUSH
111187: LD_INT 2
111189: ST_TO_ADDR
// hc_gallery :=  ;
111190: LD_ADDR_OWVAR 33
111194: PUSH
111195: LD_STRING 
111197: ST_TO_ADDR
// hc_name :=  ;
111198: LD_ADDR_OWVAR 26
111202: PUSH
111203: LD_STRING 
111205: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
111206: LD_INT 1
111208: PPUSH
111209: LD_INT 11
111211: PPUSH
111212: LD_INT 10
111214: PPUSH
111215: CALL_OW 380
// un := CreateHuman ;
111219: LD_ADDR_VAR 0 1
111223: PUSH
111224: CALL_OW 44
111228: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
111229: LD_VAR 0 1
111233: PPUSH
111234: LD_INT 1
111236: PPUSH
111237: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
111241: LD_INT 35
111243: PPUSH
111244: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
111248: LD_VAR 0 1
111252: PPUSH
111253: LD_INT 22
111255: PUSH
111256: LD_OWVAR 2
111260: PUSH
111261: EMPTY
111262: LIST
111263: LIST
111264: PPUSH
111265: CALL_OW 69
111269: PPUSH
111270: LD_VAR 0 1
111274: PPUSH
111275: CALL_OW 74
111279: PPUSH
111280: CALL_OW 115
// until IsDead ( un ) ;
111284: LD_VAR 0 1
111288: PPUSH
111289: CALL_OW 301
111293: IFFALSE 111241
// end ;
111295: PPOPN 1
111297: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
111298: LD_EXP 156
111302: PUSH
111303: LD_EXP 196
111307: AND
111308: IFFALSE 111320
111310: GO 111312
111312: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
111313: LD_STRING earthquake(getX(game), 0, 32)
111315: PPUSH
111316: CALL_OW 559
111320: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
111321: LD_EXP 156
111325: PUSH
111326: LD_EXP 197
111330: AND
111331: IFFALSE 111422
111333: GO 111335
111335: DISABLE
111336: LD_INT 0
111338: PPUSH
// begin enable ;
111339: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
111340: LD_ADDR_VAR 0 1
111344: PUSH
111345: LD_INT 22
111347: PUSH
111348: LD_OWVAR 2
111352: PUSH
111353: EMPTY
111354: LIST
111355: LIST
111356: PUSH
111357: LD_INT 21
111359: PUSH
111360: LD_INT 2
111362: PUSH
111363: EMPTY
111364: LIST
111365: LIST
111366: PUSH
111367: LD_INT 33
111369: PUSH
111370: LD_INT 3
111372: PUSH
111373: EMPTY
111374: LIST
111375: LIST
111376: PUSH
111377: EMPTY
111378: LIST
111379: LIST
111380: LIST
111381: PPUSH
111382: CALL_OW 69
111386: ST_TO_ADDR
// if not tmp then
111387: LD_VAR 0 1
111391: NOT
111392: IFFALSE 111396
// exit ;
111394: GO 111422
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
111396: LD_VAR 0 1
111400: PUSH
111401: LD_INT 1
111403: PPUSH
111404: LD_VAR 0 1
111408: PPUSH
111409: CALL_OW 12
111413: ARRAY
111414: PPUSH
111415: LD_INT 1
111417: PPUSH
111418: CALL_OW 234
// end ;
111422: PPOPN 1
111424: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
111425: LD_EXP 156
111429: PUSH
111430: LD_EXP 198
111434: AND
111435: IFFALSE 111576
111437: GO 111439
111439: DISABLE
111440: LD_INT 0
111442: PPUSH
111443: PPUSH
111444: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
111445: LD_ADDR_VAR 0 3
111449: PUSH
111450: LD_INT 22
111452: PUSH
111453: LD_OWVAR 2
111457: PUSH
111458: EMPTY
111459: LIST
111460: LIST
111461: PUSH
111462: LD_INT 25
111464: PUSH
111465: LD_INT 1
111467: PUSH
111468: EMPTY
111469: LIST
111470: LIST
111471: PUSH
111472: EMPTY
111473: LIST
111474: LIST
111475: PPUSH
111476: CALL_OW 69
111480: ST_TO_ADDR
// if not tmp then
111481: LD_VAR 0 3
111485: NOT
111486: IFFALSE 111490
// exit ;
111488: GO 111576
// un := tmp [ rand ( 1 , tmp ) ] ;
111490: LD_ADDR_VAR 0 2
111494: PUSH
111495: LD_VAR 0 3
111499: PUSH
111500: LD_INT 1
111502: PPUSH
111503: LD_VAR 0 3
111507: PPUSH
111508: CALL_OW 12
111512: ARRAY
111513: ST_TO_ADDR
// if Crawls ( un ) then
111514: LD_VAR 0 2
111518: PPUSH
111519: CALL_OW 318
111523: IFFALSE 111534
// ComWalk ( un ) ;
111525: LD_VAR 0 2
111529: PPUSH
111530: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
111534: LD_VAR 0 2
111538: PPUSH
111539: LD_INT 9
111541: PPUSH
111542: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
111546: LD_INT 28
111548: PPUSH
111549: LD_OWVAR 2
111553: PPUSH
111554: LD_INT 2
111556: PPUSH
111557: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
111561: LD_INT 29
111563: PPUSH
111564: LD_OWVAR 2
111568: PPUSH
111569: LD_INT 2
111571: PPUSH
111572: CALL_OW 322
// end ;
111576: PPOPN 3
111578: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
111579: LD_EXP 156
111583: PUSH
111584: LD_EXP 199
111588: AND
111589: IFFALSE 111700
111591: GO 111593
111593: DISABLE
111594: LD_INT 0
111596: PPUSH
111597: PPUSH
111598: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
111599: LD_ADDR_VAR 0 3
111603: PUSH
111604: LD_INT 22
111606: PUSH
111607: LD_OWVAR 2
111611: PUSH
111612: EMPTY
111613: LIST
111614: LIST
111615: PUSH
111616: LD_INT 25
111618: PUSH
111619: LD_INT 1
111621: PUSH
111622: EMPTY
111623: LIST
111624: LIST
111625: PUSH
111626: EMPTY
111627: LIST
111628: LIST
111629: PPUSH
111630: CALL_OW 69
111634: ST_TO_ADDR
// if not tmp then
111635: LD_VAR 0 3
111639: NOT
111640: IFFALSE 111644
// exit ;
111642: GO 111700
// un := tmp [ rand ( 1 , tmp ) ] ;
111644: LD_ADDR_VAR 0 2
111648: PUSH
111649: LD_VAR 0 3
111653: PUSH
111654: LD_INT 1
111656: PPUSH
111657: LD_VAR 0 3
111661: PPUSH
111662: CALL_OW 12
111666: ARRAY
111667: ST_TO_ADDR
// if Crawls ( un ) then
111668: LD_VAR 0 2
111672: PPUSH
111673: CALL_OW 318
111677: IFFALSE 111688
// ComWalk ( un ) ;
111679: LD_VAR 0 2
111683: PPUSH
111684: CALL_OW 138
// SetClass ( un , class_mortar ) ;
111688: LD_VAR 0 2
111692: PPUSH
111693: LD_INT 8
111695: PPUSH
111696: CALL_OW 336
// end ;
111700: PPOPN 3
111702: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
111703: LD_EXP 156
111707: PUSH
111708: LD_EXP 200
111712: AND
111713: IFFALSE 111857
111715: GO 111717
111717: DISABLE
111718: LD_INT 0
111720: PPUSH
111721: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
111722: LD_ADDR_VAR 0 2
111726: PUSH
111727: LD_INT 22
111729: PUSH
111730: LD_OWVAR 2
111734: PUSH
111735: EMPTY
111736: LIST
111737: LIST
111738: PUSH
111739: LD_INT 21
111741: PUSH
111742: LD_INT 2
111744: PUSH
111745: EMPTY
111746: LIST
111747: LIST
111748: PUSH
111749: LD_INT 2
111751: PUSH
111752: LD_INT 34
111754: PUSH
111755: LD_INT 12
111757: PUSH
111758: EMPTY
111759: LIST
111760: LIST
111761: PUSH
111762: LD_INT 34
111764: PUSH
111765: LD_INT 51
111767: PUSH
111768: EMPTY
111769: LIST
111770: LIST
111771: PUSH
111772: LD_INT 34
111774: PUSH
111775: LD_INT 32
111777: PUSH
111778: EMPTY
111779: LIST
111780: LIST
111781: PUSH
111782: EMPTY
111783: LIST
111784: LIST
111785: LIST
111786: LIST
111787: PUSH
111788: EMPTY
111789: LIST
111790: LIST
111791: LIST
111792: PPUSH
111793: CALL_OW 69
111797: ST_TO_ADDR
// if not tmp then
111798: LD_VAR 0 2
111802: NOT
111803: IFFALSE 111807
// exit ;
111805: GO 111857
// for i in tmp do
111807: LD_ADDR_VAR 0 1
111811: PUSH
111812: LD_VAR 0 2
111816: PUSH
111817: FOR_IN
111818: IFFALSE 111855
// if GetCargo ( i , mat_artifact ) = 0 then
111820: LD_VAR 0 1
111824: PPUSH
111825: LD_INT 4
111827: PPUSH
111828: CALL_OW 289
111832: PUSH
111833: LD_INT 0
111835: EQUAL
111836: IFFALSE 111853
// SetCargo ( i , mat_siberit , 100 ) ;
111838: LD_VAR 0 1
111842: PPUSH
111843: LD_INT 3
111845: PPUSH
111846: LD_INT 100
111848: PPUSH
111849: CALL_OW 290
111853: GO 111817
111855: POP
111856: POP
// end ;
111857: PPOPN 2
111859: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
111860: LD_EXP 156
111864: PUSH
111865: LD_EXP 201
111869: AND
111870: IFFALSE 112053
111872: GO 111874
111874: DISABLE
111875: LD_INT 0
111877: PPUSH
111878: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
111879: LD_ADDR_VAR 0 2
111883: PUSH
111884: LD_INT 22
111886: PUSH
111887: LD_OWVAR 2
111891: PUSH
111892: EMPTY
111893: LIST
111894: LIST
111895: PPUSH
111896: CALL_OW 69
111900: ST_TO_ADDR
// if not tmp then
111901: LD_VAR 0 2
111905: NOT
111906: IFFALSE 111910
// exit ;
111908: GO 112053
// for i := 1 to 2 do
111910: LD_ADDR_VAR 0 1
111914: PUSH
111915: DOUBLE
111916: LD_INT 1
111918: DEC
111919: ST_TO_ADDR
111920: LD_INT 2
111922: PUSH
111923: FOR_TO
111924: IFFALSE 112051
// begin uc_side := your_side ;
111926: LD_ADDR_OWVAR 20
111930: PUSH
111931: LD_OWVAR 2
111935: ST_TO_ADDR
// uc_nation := nation_american ;
111936: LD_ADDR_OWVAR 21
111940: PUSH
111941: LD_INT 1
111943: ST_TO_ADDR
// vc_chassis := us_morphling ;
111944: LD_ADDR_OWVAR 37
111948: PUSH
111949: LD_INT 5
111951: ST_TO_ADDR
// vc_engine := engine_siberite ;
111952: LD_ADDR_OWVAR 39
111956: PUSH
111957: LD_INT 3
111959: ST_TO_ADDR
// vc_control := control_computer ;
111960: LD_ADDR_OWVAR 38
111964: PUSH
111965: LD_INT 3
111967: ST_TO_ADDR
// vc_weapon := us_double_laser ;
111968: LD_ADDR_OWVAR 40
111972: PUSH
111973: LD_INT 10
111975: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
111976: LD_VAR 0 2
111980: PUSH
111981: LD_INT 1
111983: ARRAY
111984: PPUSH
111985: CALL_OW 310
111989: NOT
111990: IFFALSE 112037
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
111992: CALL_OW 45
111996: PPUSH
111997: LD_VAR 0 2
112001: PUSH
112002: LD_INT 1
112004: ARRAY
112005: PPUSH
112006: CALL_OW 250
112010: PPUSH
112011: LD_VAR 0 2
112015: PUSH
112016: LD_INT 1
112018: ARRAY
112019: PPUSH
112020: CALL_OW 251
112024: PPUSH
112025: LD_INT 12
112027: PPUSH
112028: LD_INT 1
112030: PPUSH
112031: CALL_OW 50
112035: GO 112049
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
112037: CALL_OW 45
112041: PPUSH
112042: LD_INT 1
112044: PPUSH
112045: CALL_OW 51
// end ;
112049: GO 111923
112051: POP
112052: POP
// end ;
112053: PPOPN 2
112055: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
112056: LD_EXP 156
112060: PUSH
112061: LD_EXP 202
112065: AND
112066: IFFALSE 112288
112068: GO 112070
112070: DISABLE
112071: LD_INT 0
112073: PPUSH
112074: PPUSH
112075: PPUSH
112076: PPUSH
112077: PPUSH
112078: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
112079: LD_ADDR_VAR 0 6
112083: PUSH
112084: LD_INT 22
112086: PUSH
112087: LD_OWVAR 2
112091: PUSH
112092: EMPTY
112093: LIST
112094: LIST
112095: PUSH
112096: LD_INT 21
112098: PUSH
112099: LD_INT 1
112101: PUSH
112102: EMPTY
112103: LIST
112104: LIST
112105: PUSH
112106: LD_INT 3
112108: PUSH
112109: LD_INT 23
112111: PUSH
112112: LD_INT 0
112114: PUSH
112115: EMPTY
112116: LIST
112117: LIST
112118: PUSH
112119: EMPTY
112120: LIST
112121: LIST
112122: PUSH
112123: EMPTY
112124: LIST
112125: LIST
112126: LIST
112127: PPUSH
112128: CALL_OW 69
112132: ST_TO_ADDR
// if not tmp then
112133: LD_VAR 0 6
112137: NOT
112138: IFFALSE 112142
// exit ;
112140: GO 112288
// s1 := rand ( 1 , 4 ) ;
112142: LD_ADDR_VAR 0 2
112146: PUSH
112147: LD_INT 1
112149: PPUSH
112150: LD_INT 4
112152: PPUSH
112153: CALL_OW 12
112157: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
112158: LD_ADDR_VAR 0 4
112162: PUSH
112163: LD_VAR 0 6
112167: PUSH
112168: LD_INT 1
112170: ARRAY
112171: PPUSH
112172: LD_VAR 0 2
112176: PPUSH
112177: CALL_OW 259
112181: ST_TO_ADDR
// if s1 = 1 then
112182: LD_VAR 0 2
112186: PUSH
112187: LD_INT 1
112189: EQUAL
112190: IFFALSE 112210
// s2 := rand ( 2 , 4 ) else
112192: LD_ADDR_VAR 0 3
112196: PUSH
112197: LD_INT 2
112199: PPUSH
112200: LD_INT 4
112202: PPUSH
112203: CALL_OW 12
112207: ST_TO_ADDR
112208: GO 112218
// s2 := 1 ;
112210: LD_ADDR_VAR 0 3
112214: PUSH
112215: LD_INT 1
112217: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
112218: LD_ADDR_VAR 0 5
112222: PUSH
112223: LD_VAR 0 6
112227: PUSH
112228: LD_INT 1
112230: ARRAY
112231: PPUSH
112232: LD_VAR 0 3
112236: PPUSH
112237: CALL_OW 259
112241: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
112242: LD_VAR 0 6
112246: PUSH
112247: LD_INT 1
112249: ARRAY
112250: PPUSH
112251: LD_VAR 0 2
112255: PPUSH
112256: LD_VAR 0 5
112260: PPUSH
112261: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
112265: LD_VAR 0 6
112269: PUSH
112270: LD_INT 1
112272: ARRAY
112273: PPUSH
112274: LD_VAR 0 3
112278: PPUSH
112279: LD_VAR 0 4
112283: PPUSH
112284: CALL_OW 237
// end ;
112288: PPOPN 6
112290: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
112291: LD_EXP 156
112295: PUSH
112296: LD_EXP 203
112300: AND
112301: IFFALSE 112380
112303: GO 112305
112305: DISABLE
112306: LD_INT 0
112308: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
112309: LD_ADDR_VAR 0 1
112313: PUSH
112314: LD_INT 22
112316: PUSH
112317: LD_OWVAR 2
112321: PUSH
112322: EMPTY
112323: LIST
112324: LIST
112325: PUSH
112326: LD_INT 30
112328: PUSH
112329: LD_INT 3
112331: PUSH
112332: EMPTY
112333: LIST
112334: LIST
112335: PUSH
112336: EMPTY
112337: LIST
112338: LIST
112339: PPUSH
112340: CALL_OW 69
112344: ST_TO_ADDR
// if not tmp then
112345: LD_VAR 0 1
112349: NOT
112350: IFFALSE 112354
// exit ;
112352: GO 112380
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
112354: LD_VAR 0 1
112358: PUSH
112359: LD_INT 1
112361: PPUSH
112362: LD_VAR 0 1
112366: PPUSH
112367: CALL_OW 12
112371: ARRAY
112372: PPUSH
112373: LD_INT 1
112375: PPUSH
112376: CALL_OW 234
// end ;
112380: PPOPN 1
112382: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
112383: LD_EXP 156
112387: PUSH
112388: LD_EXP 204
112392: AND
112393: IFFALSE 112505
112395: GO 112397
112397: DISABLE
112398: LD_INT 0
112400: PPUSH
112401: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
112402: LD_ADDR_VAR 0 2
112406: PUSH
112407: LD_INT 22
112409: PUSH
112410: LD_OWVAR 2
112414: PUSH
112415: EMPTY
112416: LIST
112417: LIST
112418: PUSH
112419: LD_INT 2
112421: PUSH
112422: LD_INT 30
112424: PUSH
112425: LD_INT 27
112427: PUSH
112428: EMPTY
112429: LIST
112430: LIST
112431: PUSH
112432: LD_INT 30
112434: PUSH
112435: LD_INT 26
112437: PUSH
112438: EMPTY
112439: LIST
112440: LIST
112441: PUSH
112442: LD_INT 30
112444: PUSH
112445: LD_INT 28
112447: PUSH
112448: EMPTY
112449: LIST
112450: LIST
112451: PUSH
112452: EMPTY
112453: LIST
112454: LIST
112455: LIST
112456: LIST
112457: PUSH
112458: EMPTY
112459: LIST
112460: LIST
112461: PPUSH
112462: CALL_OW 69
112466: ST_TO_ADDR
// if not tmp then
112467: LD_VAR 0 2
112471: NOT
112472: IFFALSE 112476
// exit ;
112474: GO 112505
// for i in tmp do
112476: LD_ADDR_VAR 0 1
112480: PUSH
112481: LD_VAR 0 2
112485: PUSH
112486: FOR_IN
112487: IFFALSE 112503
// SetLives ( i , 1 ) ;
112489: LD_VAR 0 1
112493: PPUSH
112494: LD_INT 1
112496: PPUSH
112497: CALL_OW 234
112501: GO 112486
112503: POP
112504: POP
// end ;
112505: PPOPN 2
112507: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
112508: LD_EXP 156
112512: PUSH
112513: LD_EXP 205
112517: AND
112518: IFFALSE 112792
112520: GO 112522
112522: DISABLE
112523: LD_INT 0
112525: PPUSH
112526: PPUSH
112527: PPUSH
// begin i := rand ( 1 , 7 ) ;
112528: LD_ADDR_VAR 0 1
112532: PUSH
112533: LD_INT 1
112535: PPUSH
112536: LD_INT 7
112538: PPUSH
112539: CALL_OW 12
112543: ST_TO_ADDR
// case i of 1 :
112544: LD_VAR 0 1
112548: PUSH
112549: LD_INT 1
112551: DOUBLE
112552: EQUAL
112553: IFTRUE 112557
112555: GO 112567
112557: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
112558: LD_STRING earthquake(getX(game), 0, 32)
112560: PPUSH
112561: CALL_OW 559
112565: GO 112792
112567: LD_INT 2
112569: DOUBLE
112570: EQUAL
112571: IFTRUE 112575
112573: GO 112589
112575: POP
// begin ToLua ( displayStucuk(); ) ;
112576: LD_STRING displayStucuk();
112578: PPUSH
112579: CALL_OW 559
// ResetFog ;
112583: CALL_OW 335
// end ; 3 :
112587: GO 112792
112589: LD_INT 3
112591: DOUBLE
112592: EQUAL
112593: IFTRUE 112597
112595: GO 112701
112597: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
112598: LD_ADDR_VAR 0 2
112602: PUSH
112603: LD_INT 22
112605: PUSH
112606: LD_OWVAR 2
112610: PUSH
112611: EMPTY
112612: LIST
112613: LIST
112614: PUSH
112615: LD_INT 25
112617: PUSH
112618: LD_INT 1
112620: PUSH
112621: EMPTY
112622: LIST
112623: LIST
112624: PUSH
112625: EMPTY
112626: LIST
112627: LIST
112628: PPUSH
112629: CALL_OW 69
112633: ST_TO_ADDR
// if not tmp then
112634: LD_VAR 0 2
112638: NOT
112639: IFFALSE 112643
// exit ;
112641: GO 112792
// un := tmp [ rand ( 1 , tmp ) ] ;
112643: LD_ADDR_VAR 0 3
112647: PUSH
112648: LD_VAR 0 2
112652: PUSH
112653: LD_INT 1
112655: PPUSH
112656: LD_VAR 0 2
112660: PPUSH
112661: CALL_OW 12
112665: ARRAY
112666: ST_TO_ADDR
// if Crawls ( un ) then
112667: LD_VAR 0 3
112671: PPUSH
112672: CALL_OW 318
112676: IFFALSE 112687
// ComWalk ( un ) ;
112678: LD_VAR 0 3
112682: PPUSH
112683: CALL_OW 138
// SetClass ( un , class_mortar ) ;
112687: LD_VAR 0 3
112691: PPUSH
112692: LD_INT 8
112694: PPUSH
112695: CALL_OW 336
// end ; 4 :
112699: GO 112792
112701: LD_INT 4
112703: DOUBLE
112704: EQUAL
112705: IFTRUE 112709
112707: GO 112770
112709: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
112710: LD_ADDR_VAR 0 2
112714: PUSH
112715: LD_INT 22
112717: PUSH
112718: LD_OWVAR 2
112722: PUSH
112723: EMPTY
112724: LIST
112725: LIST
112726: PUSH
112727: LD_INT 30
112729: PUSH
112730: LD_INT 29
112732: PUSH
112733: EMPTY
112734: LIST
112735: LIST
112736: PUSH
112737: EMPTY
112738: LIST
112739: LIST
112740: PPUSH
112741: CALL_OW 69
112745: ST_TO_ADDR
// if not tmp then
112746: LD_VAR 0 2
112750: NOT
112751: IFFALSE 112755
// exit ;
112753: GO 112792
// DestroyUnit ( tmp [ 1 ] ) ;
112755: LD_VAR 0 2
112759: PUSH
112760: LD_INT 1
112762: ARRAY
112763: PPUSH
112764: CALL_OW 65
// end ; 5 .. 7 :
112768: GO 112792
112770: LD_INT 5
112772: DOUBLE
112773: GREATEREQUAL
112774: IFFALSE 112782
112776: LD_INT 7
112778: DOUBLE
112779: LESSEQUAL
112780: IFTRUE 112784
112782: GO 112791
112784: POP
// StreamSibBomb ; end ;
112785: CALL 109042 0 0
112789: GO 112792
112791: POP
// end ;
112792: PPOPN 3
112794: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
112795: LD_EXP 156
112799: PUSH
112800: LD_EXP 206
112804: AND
112805: IFFALSE 112961
112807: GO 112809
112809: DISABLE
112810: LD_INT 0
112812: PPUSH
112813: PPUSH
112814: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
112815: LD_ADDR_VAR 0 2
112819: PUSH
112820: LD_INT 81
112822: PUSH
112823: LD_OWVAR 2
112827: PUSH
112828: EMPTY
112829: LIST
112830: LIST
112831: PUSH
112832: LD_INT 2
112834: PUSH
112835: LD_INT 21
112837: PUSH
112838: LD_INT 1
112840: PUSH
112841: EMPTY
112842: LIST
112843: LIST
112844: PUSH
112845: LD_INT 21
112847: PUSH
112848: LD_INT 2
112850: PUSH
112851: EMPTY
112852: LIST
112853: LIST
112854: PUSH
112855: EMPTY
112856: LIST
112857: LIST
112858: LIST
112859: PUSH
112860: EMPTY
112861: LIST
112862: LIST
112863: PPUSH
112864: CALL_OW 69
112868: ST_TO_ADDR
// if not tmp then
112869: LD_VAR 0 2
112873: NOT
112874: IFFALSE 112878
// exit ;
112876: GO 112961
// p := 0 ;
112878: LD_ADDR_VAR 0 3
112882: PUSH
112883: LD_INT 0
112885: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
112886: LD_INT 35
112888: PPUSH
112889: CALL_OW 67
// p := p + 1 ;
112893: LD_ADDR_VAR 0 3
112897: PUSH
112898: LD_VAR 0 3
112902: PUSH
112903: LD_INT 1
112905: PLUS
112906: ST_TO_ADDR
// for i in tmp do
112907: LD_ADDR_VAR 0 1
112911: PUSH
112912: LD_VAR 0 2
112916: PUSH
112917: FOR_IN
112918: IFFALSE 112949
// if GetLives ( i ) < 1000 then
112920: LD_VAR 0 1
112924: PPUSH
112925: CALL_OW 256
112929: PUSH
112930: LD_INT 1000
112932: LESS
112933: IFFALSE 112947
// SetLives ( i , 1000 ) ;
112935: LD_VAR 0 1
112939: PPUSH
112940: LD_INT 1000
112942: PPUSH
112943: CALL_OW 234
112947: GO 112917
112949: POP
112950: POP
// until p > 20 ;
112951: LD_VAR 0 3
112955: PUSH
112956: LD_INT 20
112958: GREATER
112959: IFFALSE 112886
// end ;
112961: PPOPN 3
112963: END
// every 0 0$1 trigger StreamModeActive and sTime do
112964: LD_EXP 156
112968: PUSH
112969: LD_EXP 207
112973: AND
112974: IFFALSE 113009
112976: GO 112978
112978: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
112979: LD_INT 28
112981: PPUSH
112982: LD_OWVAR 2
112986: PPUSH
112987: LD_INT 2
112989: PPUSH
112990: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
112994: LD_INT 30
112996: PPUSH
112997: LD_OWVAR 2
113001: PPUSH
113002: LD_INT 2
113004: PPUSH
113005: CALL_OW 322
// end ;
113009: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
113010: LD_EXP 156
113014: PUSH
113015: LD_EXP 208
113019: AND
113020: IFFALSE 113141
113022: GO 113024
113024: DISABLE
113025: LD_INT 0
113027: PPUSH
113028: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
113029: LD_ADDR_VAR 0 2
113033: PUSH
113034: LD_INT 22
113036: PUSH
113037: LD_OWVAR 2
113041: PUSH
113042: EMPTY
113043: LIST
113044: LIST
113045: PUSH
113046: LD_INT 21
113048: PUSH
113049: LD_INT 1
113051: PUSH
113052: EMPTY
113053: LIST
113054: LIST
113055: PUSH
113056: LD_INT 3
113058: PUSH
113059: LD_INT 23
113061: PUSH
113062: LD_INT 0
113064: PUSH
113065: EMPTY
113066: LIST
113067: LIST
113068: PUSH
113069: EMPTY
113070: LIST
113071: LIST
113072: PUSH
113073: EMPTY
113074: LIST
113075: LIST
113076: LIST
113077: PPUSH
113078: CALL_OW 69
113082: ST_TO_ADDR
// if not tmp then
113083: LD_VAR 0 2
113087: NOT
113088: IFFALSE 113092
// exit ;
113090: GO 113141
// for i in tmp do
113092: LD_ADDR_VAR 0 1
113096: PUSH
113097: LD_VAR 0 2
113101: PUSH
113102: FOR_IN
113103: IFFALSE 113139
// begin if Crawls ( i ) then
113105: LD_VAR 0 1
113109: PPUSH
113110: CALL_OW 318
113114: IFFALSE 113125
// ComWalk ( i ) ;
113116: LD_VAR 0 1
113120: PPUSH
113121: CALL_OW 138
// SetClass ( i , 2 ) ;
113125: LD_VAR 0 1
113129: PPUSH
113130: LD_INT 2
113132: PPUSH
113133: CALL_OW 336
// end ;
113137: GO 113102
113139: POP
113140: POP
// end ;
113141: PPOPN 2
113143: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
113144: LD_EXP 156
113148: PUSH
113149: LD_EXP 209
113153: AND
113154: IFFALSE 113435
113156: GO 113158
113158: DISABLE
113159: LD_INT 0
113161: PPUSH
113162: PPUSH
113163: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
113164: LD_OWVAR 2
113168: PPUSH
113169: LD_INT 9
113171: PPUSH
113172: LD_INT 1
113174: PPUSH
113175: LD_INT 1
113177: PPUSH
113178: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
113182: LD_INT 9
113184: PPUSH
113185: LD_OWVAR 2
113189: PPUSH
113190: CALL_OW 343
// uc_side := 9 ;
113194: LD_ADDR_OWVAR 20
113198: PUSH
113199: LD_INT 9
113201: ST_TO_ADDR
// uc_nation := 2 ;
113202: LD_ADDR_OWVAR 21
113206: PUSH
113207: LD_INT 2
113209: ST_TO_ADDR
// hc_name := Dark Warrior ;
113210: LD_ADDR_OWVAR 26
113214: PUSH
113215: LD_STRING Dark Warrior
113217: ST_TO_ADDR
// hc_gallery :=  ;
113218: LD_ADDR_OWVAR 33
113222: PUSH
113223: LD_STRING 
113225: ST_TO_ADDR
// hc_noskilllimit := true ;
113226: LD_ADDR_OWVAR 76
113230: PUSH
113231: LD_INT 1
113233: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
113234: LD_ADDR_OWVAR 31
113238: PUSH
113239: LD_INT 30
113241: PUSH
113242: LD_INT 30
113244: PUSH
113245: LD_INT 30
113247: PUSH
113248: LD_INT 30
113250: PUSH
113251: EMPTY
113252: LIST
113253: LIST
113254: LIST
113255: LIST
113256: ST_TO_ADDR
// un := CreateHuman ;
113257: LD_ADDR_VAR 0 3
113261: PUSH
113262: CALL_OW 44
113266: ST_TO_ADDR
// hc_noskilllimit := false ;
113267: LD_ADDR_OWVAR 76
113271: PUSH
113272: LD_INT 0
113274: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
113275: LD_VAR 0 3
113279: PPUSH
113280: LD_INT 1
113282: PPUSH
113283: CALL_OW 51
// p := 0 ;
113287: LD_ADDR_VAR 0 2
113291: PUSH
113292: LD_INT 0
113294: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
113295: LD_INT 35
113297: PPUSH
113298: CALL_OW 67
// p := p + 1 ;
113302: LD_ADDR_VAR 0 2
113306: PUSH
113307: LD_VAR 0 2
113311: PUSH
113312: LD_INT 1
113314: PLUS
113315: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
113316: LD_VAR 0 3
113320: PPUSH
113321: CALL_OW 256
113325: PUSH
113326: LD_INT 1000
113328: LESS
113329: IFFALSE 113343
// SetLives ( un , 1000 ) ;
113331: LD_VAR 0 3
113335: PPUSH
113336: LD_INT 1000
113338: PPUSH
113339: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
113343: LD_VAR 0 3
113347: PPUSH
113348: LD_INT 81
113350: PUSH
113351: LD_OWVAR 2
113355: PUSH
113356: EMPTY
113357: LIST
113358: LIST
113359: PUSH
113360: LD_INT 91
113362: PUSH
113363: LD_VAR 0 3
113367: PUSH
113368: LD_INT 30
113370: PUSH
113371: EMPTY
113372: LIST
113373: LIST
113374: LIST
113375: PUSH
113376: EMPTY
113377: LIST
113378: LIST
113379: PPUSH
113380: CALL_OW 69
113384: PPUSH
113385: LD_VAR 0 3
113389: PPUSH
113390: CALL_OW 74
113394: PPUSH
113395: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
113399: LD_VAR 0 2
113403: PUSH
113404: LD_INT 60
113406: GREATER
113407: PUSH
113408: LD_VAR 0 3
113412: PPUSH
113413: CALL_OW 301
113417: OR
113418: IFFALSE 113295
// if un then
113420: LD_VAR 0 3
113424: IFFALSE 113435
// RemoveUnit ( un ) ;
113426: LD_VAR 0 3
113430: PPUSH
113431: CALL_OW 64
// end ;
113435: PPOPN 3
113437: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
113438: LD_INT 0
113440: PPUSH
// case cmd of 301 :
113441: LD_VAR 0 1
113445: PUSH
113446: LD_INT 301
113448: DOUBLE
113449: EQUAL
113450: IFTRUE 113454
113452: GO 113486
113454: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
113455: LD_VAR 0 6
113459: PPUSH
113460: LD_VAR 0 7
113464: PPUSH
113465: LD_VAR 0 8
113469: PPUSH
113470: LD_VAR 0 4
113474: PPUSH
113475: LD_VAR 0 5
113479: PPUSH
113480: CALL 114687 0 5
113484: GO 113607
113486: LD_INT 302
113488: DOUBLE
113489: EQUAL
113490: IFTRUE 113494
113492: GO 113531
113494: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
113495: LD_VAR 0 6
113499: PPUSH
113500: LD_VAR 0 7
113504: PPUSH
113505: LD_VAR 0 8
113509: PPUSH
113510: LD_VAR 0 9
113514: PPUSH
113515: LD_VAR 0 4
113519: PPUSH
113520: LD_VAR 0 5
113524: PPUSH
113525: CALL 114778 0 6
113529: GO 113607
113531: LD_INT 303
113533: DOUBLE
113534: EQUAL
113535: IFTRUE 113539
113537: GO 113576
113539: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
113540: LD_VAR 0 6
113544: PPUSH
113545: LD_VAR 0 7
113549: PPUSH
113550: LD_VAR 0 8
113554: PPUSH
113555: LD_VAR 0 9
113559: PPUSH
113560: LD_VAR 0 4
113564: PPUSH
113565: LD_VAR 0 5
113569: PPUSH
113570: CALL 113612 0 6
113574: GO 113607
113576: LD_INT 304
113578: DOUBLE
113579: EQUAL
113580: IFTRUE 113584
113582: GO 113606
113584: POP
// hHackTeleport ( unit , x , y ) ; end ;
113585: LD_VAR 0 2
113589: PPUSH
113590: LD_VAR 0 4
113594: PPUSH
113595: LD_VAR 0 5
113599: PPUSH
113600: CALL 115371 0 3
113604: GO 113607
113606: POP
// end ;
113607: LD_VAR 0 12
113611: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
113612: LD_INT 0
113614: PPUSH
113615: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
113616: LD_VAR 0 1
113620: PUSH
113621: LD_INT 1
113623: LESS
113624: PUSH
113625: LD_VAR 0 1
113629: PUSH
113630: LD_INT 3
113632: GREATER
113633: OR
113634: PUSH
113635: LD_VAR 0 5
113639: PPUSH
113640: LD_VAR 0 6
113644: PPUSH
113645: CALL_OW 428
113649: OR
113650: IFFALSE 113654
// exit ;
113652: GO 114374
// uc_side := your_side ;
113654: LD_ADDR_OWVAR 20
113658: PUSH
113659: LD_OWVAR 2
113663: ST_TO_ADDR
// uc_nation := nation ;
113664: LD_ADDR_OWVAR 21
113668: PUSH
113669: LD_VAR 0 1
113673: ST_TO_ADDR
// bc_level = 1 ;
113674: LD_ADDR_OWVAR 43
113678: PUSH
113679: LD_INT 1
113681: ST_TO_ADDR
// case btype of 1 :
113682: LD_VAR 0 2
113686: PUSH
113687: LD_INT 1
113689: DOUBLE
113690: EQUAL
113691: IFTRUE 113695
113693: GO 113706
113695: POP
// bc_type := b_depot ; 2 :
113696: LD_ADDR_OWVAR 42
113700: PUSH
113701: LD_INT 0
113703: ST_TO_ADDR
113704: GO 114318
113706: LD_INT 2
113708: DOUBLE
113709: EQUAL
113710: IFTRUE 113714
113712: GO 113725
113714: POP
// bc_type := b_warehouse ; 3 :
113715: LD_ADDR_OWVAR 42
113719: PUSH
113720: LD_INT 1
113722: ST_TO_ADDR
113723: GO 114318
113725: LD_INT 3
113727: DOUBLE
113728: EQUAL
113729: IFTRUE 113733
113731: GO 113744
113733: POP
// bc_type := b_lab ; 4 .. 9 :
113734: LD_ADDR_OWVAR 42
113738: PUSH
113739: LD_INT 6
113741: ST_TO_ADDR
113742: GO 114318
113744: LD_INT 4
113746: DOUBLE
113747: GREATEREQUAL
113748: IFFALSE 113756
113750: LD_INT 9
113752: DOUBLE
113753: LESSEQUAL
113754: IFTRUE 113758
113756: GO 113810
113758: POP
// begin bc_type := b_lab_half ;
113759: LD_ADDR_OWVAR 42
113763: PUSH
113764: LD_INT 7
113766: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
113767: LD_ADDR_OWVAR 44
113771: PUSH
113772: LD_INT 10
113774: PUSH
113775: LD_INT 11
113777: PUSH
113778: LD_INT 12
113780: PUSH
113781: LD_INT 15
113783: PUSH
113784: LD_INT 14
113786: PUSH
113787: LD_INT 13
113789: PUSH
113790: EMPTY
113791: LIST
113792: LIST
113793: LIST
113794: LIST
113795: LIST
113796: LIST
113797: PUSH
113798: LD_VAR 0 2
113802: PUSH
113803: LD_INT 3
113805: MINUS
113806: ARRAY
113807: ST_TO_ADDR
// end ; 10 .. 13 :
113808: GO 114318
113810: LD_INT 10
113812: DOUBLE
113813: GREATEREQUAL
113814: IFFALSE 113822
113816: LD_INT 13
113818: DOUBLE
113819: LESSEQUAL
113820: IFTRUE 113824
113822: GO 113901
113824: POP
// begin bc_type := b_lab_full ;
113825: LD_ADDR_OWVAR 42
113829: PUSH
113830: LD_INT 8
113832: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
113833: LD_ADDR_OWVAR 44
113837: PUSH
113838: LD_INT 10
113840: PUSH
113841: LD_INT 12
113843: PUSH
113844: LD_INT 14
113846: PUSH
113847: LD_INT 13
113849: PUSH
113850: EMPTY
113851: LIST
113852: LIST
113853: LIST
113854: LIST
113855: PUSH
113856: LD_VAR 0 2
113860: PUSH
113861: LD_INT 9
113863: MINUS
113864: ARRAY
113865: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
113866: LD_ADDR_OWVAR 45
113870: PUSH
113871: LD_INT 11
113873: PUSH
113874: LD_INT 15
113876: PUSH
113877: LD_INT 12
113879: PUSH
113880: LD_INT 15
113882: PUSH
113883: EMPTY
113884: LIST
113885: LIST
113886: LIST
113887: LIST
113888: PUSH
113889: LD_VAR 0 2
113893: PUSH
113894: LD_INT 9
113896: MINUS
113897: ARRAY
113898: ST_TO_ADDR
// end ; 14 :
113899: GO 114318
113901: LD_INT 14
113903: DOUBLE
113904: EQUAL
113905: IFTRUE 113909
113907: GO 113920
113909: POP
// bc_type := b_workshop ; 15 :
113910: LD_ADDR_OWVAR 42
113914: PUSH
113915: LD_INT 2
113917: ST_TO_ADDR
113918: GO 114318
113920: LD_INT 15
113922: DOUBLE
113923: EQUAL
113924: IFTRUE 113928
113926: GO 113939
113928: POP
// bc_type := b_factory ; 16 :
113929: LD_ADDR_OWVAR 42
113933: PUSH
113934: LD_INT 3
113936: ST_TO_ADDR
113937: GO 114318
113939: LD_INT 16
113941: DOUBLE
113942: EQUAL
113943: IFTRUE 113947
113945: GO 113958
113947: POP
// bc_type := b_ext_gun ; 17 :
113948: LD_ADDR_OWVAR 42
113952: PUSH
113953: LD_INT 17
113955: ST_TO_ADDR
113956: GO 114318
113958: LD_INT 17
113960: DOUBLE
113961: EQUAL
113962: IFTRUE 113966
113964: GO 113994
113966: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
113967: LD_ADDR_OWVAR 42
113971: PUSH
113972: LD_INT 19
113974: PUSH
113975: LD_INT 23
113977: PUSH
113978: LD_INT 19
113980: PUSH
113981: EMPTY
113982: LIST
113983: LIST
113984: LIST
113985: PUSH
113986: LD_VAR 0 1
113990: ARRAY
113991: ST_TO_ADDR
113992: GO 114318
113994: LD_INT 18
113996: DOUBLE
113997: EQUAL
113998: IFTRUE 114002
114000: GO 114013
114002: POP
// bc_type := b_ext_radar ; 19 :
114003: LD_ADDR_OWVAR 42
114007: PUSH
114008: LD_INT 20
114010: ST_TO_ADDR
114011: GO 114318
114013: LD_INT 19
114015: DOUBLE
114016: EQUAL
114017: IFTRUE 114021
114019: GO 114032
114021: POP
// bc_type := b_ext_radio ; 20 :
114022: LD_ADDR_OWVAR 42
114026: PUSH
114027: LD_INT 22
114029: ST_TO_ADDR
114030: GO 114318
114032: LD_INT 20
114034: DOUBLE
114035: EQUAL
114036: IFTRUE 114040
114038: GO 114051
114040: POP
// bc_type := b_ext_siberium ; 21 :
114041: LD_ADDR_OWVAR 42
114045: PUSH
114046: LD_INT 21
114048: ST_TO_ADDR
114049: GO 114318
114051: LD_INT 21
114053: DOUBLE
114054: EQUAL
114055: IFTRUE 114059
114057: GO 114070
114059: POP
// bc_type := b_ext_computer ; 22 :
114060: LD_ADDR_OWVAR 42
114064: PUSH
114065: LD_INT 24
114067: ST_TO_ADDR
114068: GO 114318
114070: LD_INT 22
114072: DOUBLE
114073: EQUAL
114074: IFTRUE 114078
114076: GO 114089
114078: POP
// bc_type := b_ext_track ; 23 :
114079: LD_ADDR_OWVAR 42
114083: PUSH
114084: LD_INT 16
114086: ST_TO_ADDR
114087: GO 114318
114089: LD_INT 23
114091: DOUBLE
114092: EQUAL
114093: IFTRUE 114097
114095: GO 114108
114097: POP
// bc_type := b_ext_laser ; 24 :
114098: LD_ADDR_OWVAR 42
114102: PUSH
114103: LD_INT 25
114105: ST_TO_ADDR
114106: GO 114318
114108: LD_INT 24
114110: DOUBLE
114111: EQUAL
114112: IFTRUE 114116
114114: GO 114127
114116: POP
// bc_type := b_control_tower ; 25 :
114117: LD_ADDR_OWVAR 42
114121: PUSH
114122: LD_INT 36
114124: ST_TO_ADDR
114125: GO 114318
114127: LD_INT 25
114129: DOUBLE
114130: EQUAL
114131: IFTRUE 114135
114133: GO 114146
114135: POP
// bc_type := b_breastwork ; 26 :
114136: LD_ADDR_OWVAR 42
114140: PUSH
114141: LD_INT 31
114143: ST_TO_ADDR
114144: GO 114318
114146: LD_INT 26
114148: DOUBLE
114149: EQUAL
114150: IFTRUE 114154
114152: GO 114165
114154: POP
// bc_type := b_bunker ; 27 :
114155: LD_ADDR_OWVAR 42
114159: PUSH
114160: LD_INT 32
114162: ST_TO_ADDR
114163: GO 114318
114165: LD_INT 27
114167: DOUBLE
114168: EQUAL
114169: IFTRUE 114173
114171: GO 114184
114173: POP
// bc_type := b_turret ; 28 :
114174: LD_ADDR_OWVAR 42
114178: PUSH
114179: LD_INT 33
114181: ST_TO_ADDR
114182: GO 114318
114184: LD_INT 28
114186: DOUBLE
114187: EQUAL
114188: IFTRUE 114192
114190: GO 114203
114192: POP
// bc_type := b_armoury ; 29 :
114193: LD_ADDR_OWVAR 42
114197: PUSH
114198: LD_INT 4
114200: ST_TO_ADDR
114201: GO 114318
114203: LD_INT 29
114205: DOUBLE
114206: EQUAL
114207: IFTRUE 114211
114209: GO 114222
114211: POP
// bc_type := b_barracks ; 30 :
114212: LD_ADDR_OWVAR 42
114216: PUSH
114217: LD_INT 5
114219: ST_TO_ADDR
114220: GO 114318
114222: LD_INT 30
114224: DOUBLE
114225: EQUAL
114226: IFTRUE 114230
114228: GO 114241
114230: POP
// bc_type := b_solar_power ; 31 :
114231: LD_ADDR_OWVAR 42
114235: PUSH
114236: LD_INT 27
114238: ST_TO_ADDR
114239: GO 114318
114241: LD_INT 31
114243: DOUBLE
114244: EQUAL
114245: IFTRUE 114249
114247: GO 114260
114249: POP
// bc_type := b_oil_power ; 32 :
114250: LD_ADDR_OWVAR 42
114254: PUSH
114255: LD_INT 26
114257: ST_TO_ADDR
114258: GO 114318
114260: LD_INT 32
114262: DOUBLE
114263: EQUAL
114264: IFTRUE 114268
114266: GO 114279
114268: POP
// bc_type := b_siberite_power ; 33 :
114269: LD_ADDR_OWVAR 42
114273: PUSH
114274: LD_INT 28
114276: ST_TO_ADDR
114277: GO 114318
114279: LD_INT 33
114281: DOUBLE
114282: EQUAL
114283: IFTRUE 114287
114285: GO 114298
114287: POP
// bc_type := b_oil_mine ; 34 :
114288: LD_ADDR_OWVAR 42
114292: PUSH
114293: LD_INT 29
114295: ST_TO_ADDR
114296: GO 114318
114298: LD_INT 34
114300: DOUBLE
114301: EQUAL
114302: IFTRUE 114306
114304: GO 114317
114306: POP
// bc_type := b_siberite_mine ; end ;
114307: LD_ADDR_OWVAR 42
114311: PUSH
114312: LD_INT 30
114314: ST_TO_ADDR
114315: GO 114318
114317: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
114318: LD_ADDR_VAR 0 8
114322: PUSH
114323: LD_VAR 0 5
114327: PPUSH
114328: LD_VAR 0 6
114332: PPUSH
114333: LD_VAR 0 3
114337: PPUSH
114338: CALL_OW 47
114342: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
114343: LD_OWVAR 42
114347: PUSH
114348: LD_INT 32
114350: PUSH
114351: LD_INT 33
114353: PUSH
114354: EMPTY
114355: LIST
114356: LIST
114357: IN
114358: IFFALSE 114374
// PlaceWeaponTurret ( b , weapon ) ;
114360: LD_VAR 0 8
114364: PPUSH
114365: LD_VAR 0 4
114369: PPUSH
114370: CALL_OW 431
// end ;
114374: LD_VAR 0 7
114378: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
114379: LD_INT 0
114381: PPUSH
114382: PPUSH
114383: PPUSH
114384: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
114385: LD_ADDR_VAR 0 4
114389: PUSH
114390: LD_INT 22
114392: PUSH
114393: LD_OWVAR 2
114397: PUSH
114398: EMPTY
114399: LIST
114400: LIST
114401: PUSH
114402: LD_INT 2
114404: PUSH
114405: LD_INT 30
114407: PUSH
114408: LD_INT 0
114410: PUSH
114411: EMPTY
114412: LIST
114413: LIST
114414: PUSH
114415: LD_INT 30
114417: PUSH
114418: LD_INT 1
114420: PUSH
114421: EMPTY
114422: LIST
114423: LIST
114424: PUSH
114425: EMPTY
114426: LIST
114427: LIST
114428: LIST
114429: PUSH
114430: EMPTY
114431: LIST
114432: LIST
114433: PPUSH
114434: CALL_OW 69
114438: ST_TO_ADDR
// if not tmp then
114439: LD_VAR 0 4
114443: NOT
114444: IFFALSE 114448
// exit ;
114446: GO 114507
// for i in tmp do
114448: LD_ADDR_VAR 0 2
114452: PUSH
114453: LD_VAR 0 4
114457: PUSH
114458: FOR_IN
114459: IFFALSE 114505
// for j = 1 to 3 do
114461: LD_ADDR_VAR 0 3
114465: PUSH
114466: DOUBLE
114467: LD_INT 1
114469: DEC
114470: ST_TO_ADDR
114471: LD_INT 3
114473: PUSH
114474: FOR_TO
114475: IFFALSE 114501
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
114477: LD_VAR 0 2
114481: PPUSH
114482: CALL_OW 274
114486: PPUSH
114487: LD_VAR 0 3
114491: PPUSH
114492: LD_INT 99999
114494: PPUSH
114495: CALL_OW 277
114499: GO 114474
114501: POP
114502: POP
114503: GO 114458
114505: POP
114506: POP
// end ;
114507: LD_VAR 0 1
114511: RET
// export function hHackSetLevel10 ; var i , j ; begin
114512: LD_INT 0
114514: PPUSH
114515: PPUSH
114516: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
114517: LD_ADDR_VAR 0 2
114521: PUSH
114522: LD_INT 21
114524: PUSH
114525: LD_INT 1
114527: PUSH
114528: EMPTY
114529: LIST
114530: LIST
114531: PPUSH
114532: CALL_OW 69
114536: PUSH
114537: FOR_IN
114538: IFFALSE 114590
// if IsSelected ( i ) then
114540: LD_VAR 0 2
114544: PPUSH
114545: CALL_OW 306
114549: IFFALSE 114588
// begin for j := 1 to 4 do
114551: LD_ADDR_VAR 0 3
114555: PUSH
114556: DOUBLE
114557: LD_INT 1
114559: DEC
114560: ST_TO_ADDR
114561: LD_INT 4
114563: PUSH
114564: FOR_TO
114565: IFFALSE 114586
// SetSkill ( i , j , 10 ) ;
114567: LD_VAR 0 2
114571: PPUSH
114572: LD_VAR 0 3
114576: PPUSH
114577: LD_INT 10
114579: PPUSH
114580: CALL_OW 237
114584: GO 114564
114586: POP
114587: POP
// end ;
114588: GO 114537
114590: POP
114591: POP
// end ;
114592: LD_VAR 0 1
114596: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
114597: LD_INT 0
114599: PPUSH
114600: PPUSH
114601: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
114602: LD_ADDR_VAR 0 2
114606: PUSH
114607: LD_INT 22
114609: PUSH
114610: LD_OWVAR 2
114614: PUSH
114615: EMPTY
114616: LIST
114617: LIST
114618: PUSH
114619: LD_INT 21
114621: PUSH
114622: LD_INT 1
114624: PUSH
114625: EMPTY
114626: LIST
114627: LIST
114628: PUSH
114629: EMPTY
114630: LIST
114631: LIST
114632: PPUSH
114633: CALL_OW 69
114637: PUSH
114638: FOR_IN
114639: IFFALSE 114680
// begin for j := 1 to 4 do
114641: LD_ADDR_VAR 0 3
114645: PUSH
114646: DOUBLE
114647: LD_INT 1
114649: DEC
114650: ST_TO_ADDR
114651: LD_INT 4
114653: PUSH
114654: FOR_TO
114655: IFFALSE 114676
// SetSkill ( i , j , 10 ) ;
114657: LD_VAR 0 2
114661: PPUSH
114662: LD_VAR 0 3
114666: PPUSH
114667: LD_INT 10
114669: PPUSH
114670: CALL_OW 237
114674: GO 114654
114676: POP
114677: POP
// end ;
114678: GO 114638
114680: POP
114681: POP
// end ;
114682: LD_VAR 0 1
114686: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
114687: LD_INT 0
114689: PPUSH
// uc_side := your_side ;
114690: LD_ADDR_OWVAR 20
114694: PUSH
114695: LD_OWVAR 2
114699: ST_TO_ADDR
// uc_nation := nation ;
114700: LD_ADDR_OWVAR 21
114704: PUSH
114705: LD_VAR 0 1
114709: ST_TO_ADDR
// InitHc ;
114710: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
114714: LD_INT 0
114716: PPUSH
114717: LD_VAR 0 2
114721: PPUSH
114722: LD_VAR 0 3
114726: PPUSH
114727: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
114731: LD_VAR 0 4
114735: PPUSH
114736: LD_VAR 0 5
114740: PPUSH
114741: CALL_OW 428
114745: PUSH
114746: LD_INT 0
114748: EQUAL
114749: IFFALSE 114773
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
114751: CALL_OW 44
114755: PPUSH
114756: LD_VAR 0 4
114760: PPUSH
114761: LD_VAR 0 5
114765: PPUSH
114766: LD_INT 1
114768: PPUSH
114769: CALL_OW 48
// end ;
114773: LD_VAR 0 6
114777: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
114778: LD_INT 0
114780: PPUSH
114781: PPUSH
// uc_side := your_side ;
114782: LD_ADDR_OWVAR 20
114786: PUSH
114787: LD_OWVAR 2
114791: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
114792: LD_VAR 0 1
114796: PUSH
114797: LD_INT 1
114799: PUSH
114800: LD_INT 2
114802: PUSH
114803: LD_INT 3
114805: PUSH
114806: LD_INT 4
114808: PUSH
114809: LD_INT 5
114811: PUSH
114812: EMPTY
114813: LIST
114814: LIST
114815: LIST
114816: LIST
114817: LIST
114818: IN
114819: IFFALSE 114831
// uc_nation := nation_american else
114821: LD_ADDR_OWVAR 21
114825: PUSH
114826: LD_INT 1
114828: ST_TO_ADDR
114829: GO 114874
// if chassis in [ 11 , 12 , 13 , 14 ] then
114831: LD_VAR 0 1
114835: PUSH
114836: LD_INT 11
114838: PUSH
114839: LD_INT 12
114841: PUSH
114842: LD_INT 13
114844: PUSH
114845: LD_INT 14
114847: PUSH
114848: EMPTY
114849: LIST
114850: LIST
114851: LIST
114852: LIST
114853: IN
114854: IFFALSE 114866
// uc_nation := nation_arabian else
114856: LD_ADDR_OWVAR 21
114860: PUSH
114861: LD_INT 2
114863: ST_TO_ADDR
114864: GO 114874
// uc_nation := nation_russian ;
114866: LD_ADDR_OWVAR 21
114870: PUSH
114871: LD_INT 3
114873: ST_TO_ADDR
// vc_chassis := chassis ;
114874: LD_ADDR_OWVAR 37
114878: PUSH
114879: LD_VAR 0 1
114883: ST_TO_ADDR
// vc_engine := engine ;
114884: LD_ADDR_OWVAR 39
114888: PUSH
114889: LD_VAR 0 2
114893: ST_TO_ADDR
// vc_control := control ;
114894: LD_ADDR_OWVAR 38
114898: PUSH
114899: LD_VAR 0 3
114903: ST_TO_ADDR
// vc_weapon := weapon ;
114904: LD_ADDR_OWVAR 40
114908: PUSH
114909: LD_VAR 0 4
114913: ST_TO_ADDR
// un := CreateVehicle ;
114914: LD_ADDR_VAR 0 8
114918: PUSH
114919: CALL_OW 45
114923: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
114924: LD_VAR 0 8
114928: PPUSH
114929: LD_INT 0
114931: PPUSH
114932: LD_INT 5
114934: PPUSH
114935: CALL_OW 12
114939: PPUSH
114940: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
114944: LD_VAR 0 8
114948: PPUSH
114949: LD_VAR 0 5
114953: PPUSH
114954: LD_VAR 0 6
114958: PPUSH
114959: LD_INT 1
114961: PPUSH
114962: CALL_OW 48
// end ;
114966: LD_VAR 0 7
114970: RET
// export hInvincible ; every 1 do
114971: GO 114973
114973: DISABLE
// hInvincible := [ ] ;
114974: LD_ADDR_EXP 210
114978: PUSH
114979: EMPTY
114980: ST_TO_ADDR
114981: END
// every 10 do var i ;
114982: GO 114984
114984: DISABLE
114985: LD_INT 0
114987: PPUSH
// begin enable ;
114988: ENABLE
// if not hInvincible then
114989: LD_EXP 210
114993: NOT
114994: IFFALSE 114998
// exit ;
114996: GO 115042
// for i in hInvincible do
114998: LD_ADDR_VAR 0 1
115002: PUSH
115003: LD_EXP 210
115007: PUSH
115008: FOR_IN
115009: IFFALSE 115040
// if GetLives ( i ) < 1000 then
115011: LD_VAR 0 1
115015: PPUSH
115016: CALL_OW 256
115020: PUSH
115021: LD_INT 1000
115023: LESS
115024: IFFALSE 115038
// SetLives ( i , 1000 ) ;
115026: LD_VAR 0 1
115030: PPUSH
115031: LD_INT 1000
115033: PPUSH
115034: CALL_OW 234
115038: GO 115008
115040: POP
115041: POP
// end ;
115042: PPOPN 1
115044: END
// export function hHackInvincible ; var i ; begin
115045: LD_INT 0
115047: PPUSH
115048: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
115049: LD_ADDR_VAR 0 2
115053: PUSH
115054: LD_INT 2
115056: PUSH
115057: LD_INT 21
115059: PUSH
115060: LD_INT 1
115062: PUSH
115063: EMPTY
115064: LIST
115065: LIST
115066: PUSH
115067: LD_INT 21
115069: PUSH
115070: LD_INT 2
115072: PUSH
115073: EMPTY
115074: LIST
115075: LIST
115076: PUSH
115077: EMPTY
115078: LIST
115079: LIST
115080: LIST
115081: PPUSH
115082: CALL_OW 69
115086: PUSH
115087: FOR_IN
115088: IFFALSE 115149
// if IsSelected ( i ) then
115090: LD_VAR 0 2
115094: PPUSH
115095: CALL_OW 306
115099: IFFALSE 115147
// begin if i in hInvincible then
115101: LD_VAR 0 2
115105: PUSH
115106: LD_EXP 210
115110: IN
115111: IFFALSE 115131
// hInvincible := hInvincible diff i else
115113: LD_ADDR_EXP 210
115117: PUSH
115118: LD_EXP 210
115122: PUSH
115123: LD_VAR 0 2
115127: DIFF
115128: ST_TO_ADDR
115129: GO 115147
// hInvincible := hInvincible union i ;
115131: LD_ADDR_EXP 210
115135: PUSH
115136: LD_EXP 210
115140: PUSH
115141: LD_VAR 0 2
115145: UNION
115146: ST_TO_ADDR
// end ;
115147: GO 115087
115149: POP
115150: POP
// end ;
115151: LD_VAR 0 1
115155: RET
// export function hHackInvisible ; var i , j ; begin
115156: LD_INT 0
115158: PPUSH
115159: PPUSH
115160: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
115161: LD_ADDR_VAR 0 2
115165: PUSH
115166: LD_INT 21
115168: PUSH
115169: LD_INT 1
115171: PUSH
115172: EMPTY
115173: LIST
115174: LIST
115175: PPUSH
115176: CALL_OW 69
115180: PUSH
115181: FOR_IN
115182: IFFALSE 115206
// if IsSelected ( i ) then
115184: LD_VAR 0 2
115188: PPUSH
115189: CALL_OW 306
115193: IFFALSE 115204
// ComForceInvisible ( i ) ;
115195: LD_VAR 0 2
115199: PPUSH
115200: CALL_OW 496
115204: GO 115181
115206: POP
115207: POP
// end ;
115208: LD_VAR 0 1
115212: RET
// export function hHackChangeYourSide ; begin
115213: LD_INT 0
115215: PPUSH
// if your_side = 8 then
115216: LD_OWVAR 2
115220: PUSH
115221: LD_INT 8
115223: EQUAL
115224: IFFALSE 115236
// your_side := 0 else
115226: LD_ADDR_OWVAR 2
115230: PUSH
115231: LD_INT 0
115233: ST_TO_ADDR
115234: GO 115250
// your_side := your_side + 1 ;
115236: LD_ADDR_OWVAR 2
115240: PUSH
115241: LD_OWVAR 2
115245: PUSH
115246: LD_INT 1
115248: PLUS
115249: ST_TO_ADDR
// end ;
115250: LD_VAR 0 1
115254: RET
// export function hHackChangeUnitSide ; var i , j ; begin
115255: LD_INT 0
115257: PPUSH
115258: PPUSH
115259: PPUSH
// for i in all_units do
115260: LD_ADDR_VAR 0 2
115264: PUSH
115265: LD_OWVAR 3
115269: PUSH
115270: FOR_IN
115271: IFFALSE 115349
// if IsSelected ( i ) then
115273: LD_VAR 0 2
115277: PPUSH
115278: CALL_OW 306
115282: IFFALSE 115347
// begin j := GetSide ( i ) ;
115284: LD_ADDR_VAR 0 3
115288: PUSH
115289: LD_VAR 0 2
115293: PPUSH
115294: CALL_OW 255
115298: ST_TO_ADDR
// if j = 8 then
115299: LD_VAR 0 3
115303: PUSH
115304: LD_INT 8
115306: EQUAL
115307: IFFALSE 115319
// j := 0 else
115309: LD_ADDR_VAR 0 3
115313: PUSH
115314: LD_INT 0
115316: ST_TO_ADDR
115317: GO 115333
// j := j + 1 ;
115319: LD_ADDR_VAR 0 3
115323: PUSH
115324: LD_VAR 0 3
115328: PUSH
115329: LD_INT 1
115331: PLUS
115332: ST_TO_ADDR
// SetSide ( i , j ) ;
115333: LD_VAR 0 2
115337: PPUSH
115338: LD_VAR 0 3
115342: PPUSH
115343: CALL_OW 235
// end ;
115347: GO 115270
115349: POP
115350: POP
// end ;
115351: LD_VAR 0 1
115355: RET
// export function hHackFog ; begin
115356: LD_INT 0
115358: PPUSH
// FogOff ( true ) ;
115359: LD_INT 1
115361: PPUSH
115362: CALL_OW 344
// end ;
115366: LD_VAR 0 1
115370: RET
// export function hHackTeleport ( unit , x , y ) ; begin
115371: LD_INT 0
115373: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
115374: LD_VAR 0 1
115378: PPUSH
115379: LD_VAR 0 2
115383: PPUSH
115384: LD_VAR 0 3
115388: PPUSH
115389: LD_INT 1
115391: PPUSH
115392: LD_INT 1
115394: PPUSH
115395: CALL_OW 483
// CenterOnXY ( x , y ) ;
115399: LD_VAR 0 2
115403: PPUSH
115404: LD_VAR 0 3
115408: PPUSH
115409: CALL_OW 84
// end ; end_of_file
115413: LD_VAR 0 4
115417: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
115418: LD_INT 0
115420: PPUSH
115421: PPUSH
115422: PPUSH
115423: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
115424: LD_VAR 0 1
115428: PPUSH
115429: CALL_OW 264
115433: PUSH
115434: LD_EXP 99
115438: EQUAL
115439: IFFALSE 115511
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
115441: LD_INT 68
115443: PPUSH
115444: LD_VAR 0 1
115448: PPUSH
115449: CALL_OW 255
115453: PPUSH
115454: CALL_OW 321
115458: PUSH
115459: LD_INT 2
115461: EQUAL
115462: IFFALSE 115474
// eff := 70 else
115464: LD_ADDR_VAR 0 4
115468: PUSH
115469: LD_INT 70
115471: ST_TO_ADDR
115472: GO 115482
// eff := 30 ;
115474: LD_ADDR_VAR 0 4
115478: PUSH
115479: LD_INT 30
115481: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
115482: LD_VAR 0 1
115486: PPUSH
115487: CALL_OW 250
115491: PPUSH
115492: LD_VAR 0 1
115496: PPUSH
115497: CALL_OW 251
115501: PPUSH
115502: LD_VAR 0 4
115506: PPUSH
115507: CALL_OW 495
// end ; end ;
115511: LD_VAR 0 2
115515: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
115516: LD_INT 0
115518: PPUSH
// end ;
115519: LD_VAR 0 4
115523: RET
// export function SOS_Command ( cmd ) ; begin
115524: LD_INT 0
115526: PPUSH
// end ;
115527: LD_VAR 0 2
115531: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
115532: LD_INT 0
115534: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
115535: LD_VAR 0 1
115539: PUSH
115540: LD_INT 250
115542: EQUAL
115543: PUSH
115544: LD_VAR 0 2
115548: PPUSH
115549: CALL_OW 264
115553: PUSH
115554: LD_EXP 102
115558: EQUAL
115559: AND
115560: IFFALSE 115581
// MinerPlaceMine ( unit , x , y ) ;
115562: LD_VAR 0 2
115566: PPUSH
115567: LD_VAR 0 4
115571: PPUSH
115572: LD_VAR 0 5
115576: PPUSH
115577: CALL 117922 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
115581: LD_VAR 0 1
115585: PUSH
115586: LD_INT 251
115588: EQUAL
115589: PUSH
115590: LD_VAR 0 2
115594: PPUSH
115595: CALL_OW 264
115599: PUSH
115600: LD_EXP 102
115604: EQUAL
115605: AND
115606: IFFALSE 115627
// MinerDetonateMine ( unit , x , y ) ;
115608: LD_VAR 0 2
115612: PPUSH
115613: LD_VAR 0 4
115617: PPUSH
115618: LD_VAR 0 5
115622: PPUSH
115623: CALL 118199 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
115627: LD_VAR 0 1
115631: PUSH
115632: LD_INT 252
115634: EQUAL
115635: PUSH
115636: LD_VAR 0 2
115640: PPUSH
115641: CALL_OW 264
115645: PUSH
115646: LD_EXP 102
115650: EQUAL
115651: AND
115652: IFFALSE 115673
// MinerCreateMinefield ( unit , x , y ) ;
115654: LD_VAR 0 2
115658: PPUSH
115659: LD_VAR 0 4
115663: PPUSH
115664: LD_VAR 0 5
115668: PPUSH
115669: CALL 118616 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
115673: LD_VAR 0 1
115677: PUSH
115678: LD_INT 253
115680: EQUAL
115681: PUSH
115682: LD_VAR 0 2
115686: PPUSH
115687: CALL_OW 257
115691: PUSH
115692: LD_INT 5
115694: EQUAL
115695: AND
115696: IFFALSE 115717
// ComBinocular ( unit , x , y ) ;
115698: LD_VAR 0 2
115702: PPUSH
115703: LD_VAR 0 4
115707: PPUSH
115708: LD_VAR 0 5
115712: PPUSH
115713: CALL 118987 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
115717: LD_VAR 0 1
115721: PUSH
115722: LD_INT 254
115724: EQUAL
115725: PUSH
115726: LD_VAR 0 2
115730: PPUSH
115731: CALL_OW 264
115735: PUSH
115736: LD_EXP 97
115740: EQUAL
115741: AND
115742: PUSH
115743: LD_VAR 0 3
115747: PPUSH
115748: CALL_OW 263
115752: PUSH
115753: LD_INT 3
115755: EQUAL
115756: AND
115757: IFFALSE 115773
// HackDestroyVehicle ( unit , selectedUnit ) ;
115759: LD_VAR 0 2
115763: PPUSH
115764: LD_VAR 0 3
115768: PPUSH
115769: CALL 117282 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
115773: LD_VAR 0 1
115777: PUSH
115778: LD_INT 255
115780: EQUAL
115781: PUSH
115782: LD_VAR 0 2
115786: PPUSH
115787: CALL_OW 264
115791: PUSH
115792: LD_INT 14
115794: PUSH
115795: LD_INT 53
115797: PUSH
115798: EMPTY
115799: LIST
115800: LIST
115801: IN
115802: AND
115803: PUSH
115804: LD_VAR 0 4
115808: PPUSH
115809: LD_VAR 0 5
115813: PPUSH
115814: CALL_OW 488
115818: AND
115819: IFFALSE 115843
// CutTreeXYR ( unit , x , y , 12 ) ;
115821: LD_VAR 0 2
115825: PPUSH
115826: LD_VAR 0 4
115830: PPUSH
115831: LD_VAR 0 5
115835: PPUSH
115836: LD_INT 12
115838: PPUSH
115839: CALL 115848 0 4
// end ;
115843: LD_VAR 0 6
115847: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
115848: LD_INT 0
115850: PPUSH
115851: PPUSH
115852: PPUSH
115853: PPUSH
115854: PPUSH
115855: PPUSH
115856: PPUSH
115857: PPUSH
115858: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
115859: LD_VAR 0 1
115863: NOT
115864: PUSH
115865: LD_VAR 0 2
115869: PPUSH
115870: LD_VAR 0 3
115874: PPUSH
115875: CALL_OW 488
115879: NOT
115880: OR
115881: PUSH
115882: LD_VAR 0 4
115886: NOT
115887: OR
115888: IFFALSE 115892
// exit ;
115890: GO 116232
// list := [ ] ;
115892: LD_ADDR_VAR 0 13
115896: PUSH
115897: EMPTY
115898: ST_TO_ADDR
// if x - r < 0 then
115899: LD_VAR 0 2
115903: PUSH
115904: LD_VAR 0 4
115908: MINUS
115909: PUSH
115910: LD_INT 0
115912: LESS
115913: IFFALSE 115925
// min_x := 0 else
115915: LD_ADDR_VAR 0 7
115919: PUSH
115920: LD_INT 0
115922: ST_TO_ADDR
115923: GO 115941
// min_x := x - r ;
115925: LD_ADDR_VAR 0 7
115929: PUSH
115930: LD_VAR 0 2
115934: PUSH
115935: LD_VAR 0 4
115939: MINUS
115940: ST_TO_ADDR
// if y - r < 0 then
115941: LD_VAR 0 3
115945: PUSH
115946: LD_VAR 0 4
115950: MINUS
115951: PUSH
115952: LD_INT 0
115954: LESS
115955: IFFALSE 115967
// min_y := 0 else
115957: LD_ADDR_VAR 0 8
115961: PUSH
115962: LD_INT 0
115964: ST_TO_ADDR
115965: GO 115983
// min_y := y - r ;
115967: LD_ADDR_VAR 0 8
115971: PUSH
115972: LD_VAR 0 3
115976: PUSH
115977: LD_VAR 0 4
115981: MINUS
115982: ST_TO_ADDR
// max_x := x + r ;
115983: LD_ADDR_VAR 0 9
115987: PUSH
115988: LD_VAR 0 2
115992: PUSH
115993: LD_VAR 0 4
115997: PLUS
115998: ST_TO_ADDR
// max_y := y + r ;
115999: LD_ADDR_VAR 0 10
116003: PUSH
116004: LD_VAR 0 3
116008: PUSH
116009: LD_VAR 0 4
116013: PLUS
116014: ST_TO_ADDR
// for _x = min_x to max_x do
116015: LD_ADDR_VAR 0 11
116019: PUSH
116020: DOUBLE
116021: LD_VAR 0 7
116025: DEC
116026: ST_TO_ADDR
116027: LD_VAR 0 9
116031: PUSH
116032: FOR_TO
116033: IFFALSE 116150
// for _y = min_y to max_y do
116035: LD_ADDR_VAR 0 12
116039: PUSH
116040: DOUBLE
116041: LD_VAR 0 8
116045: DEC
116046: ST_TO_ADDR
116047: LD_VAR 0 10
116051: PUSH
116052: FOR_TO
116053: IFFALSE 116146
// begin if not ValidHex ( _x , _y ) then
116055: LD_VAR 0 11
116059: PPUSH
116060: LD_VAR 0 12
116064: PPUSH
116065: CALL_OW 488
116069: NOT
116070: IFFALSE 116074
// continue ;
116072: GO 116052
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
116074: LD_VAR 0 11
116078: PPUSH
116079: LD_VAR 0 12
116083: PPUSH
116084: CALL_OW 351
116088: PUSH
116089: LD_VAR 0 11
116093: PPUSH
116094: LD_VAR 0 12
116098: PPUSH
116099: CALL_OW 554
116103: AND
116104: IFFALSE 116144
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
116106: LD_ADDR_VAR 0 13
116110: PUSH
116111: LD_VAR 0 13
116115: PPUSH
116116: LD_VAR 0 13
116120: PUSH
116121: LD_INT 1
116123: PLUS
116124: PPUSH
116125: LD_VAR 0 11
116129: PUSH
116130: LD_VAR 0 12
116134: PUSH
116135: EMPTY
116136: LIST
116137: LIST
116138: PPUSH
116139: CALL_OW 2
116143: ST_TO_ADDR
// end ;
116144: GO 116052
116146: POP
116147: POP
116148: GO 116032
116150: POP
116151: POP
// if not list then
116152: LD_VAR 0 13
116156: NOT
116157: IFFALSE 116161
// exit ;
116159: GO 116232
// for i in list do
116161: LD_ADDR_VAR 0 6
116165: PUSH
116166: LD_VAR 0 13
116170: PUSH
116171: FOR_IN
116172: IFFALSE 116230
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
116174: LD_VAR 0 1
116178: PPUSH
116179: LD_STRING M
116181: PUSH
116182: LD_VAR 0 6
116186: PUSH
116187: LD_INT 1
116189: ARRAY
116190: PUSH
116191: LD_VAR 0 6
116195: PUSH
116196: LD_INT 2
116198: ARRAY
116199: PUSH
116200: LD_INT 0
116202: PUSH
116203: LD_INT 0
116205: PUSH
116206: LD_INT 0
116208: PUSH
116209: LD_INT 0
116211: PUSH
116212: EMPTY
116213: LIST
116214: LIST
116215: LIST
116216: LIST
116217: LIST
116218: LIST
116219: LIST
116220: PUSH
116221: EMPTY
116222: LIST
116223: PPUSH
116224: CALL_OW 447
116228: GO 116171
116230: POP
116231: POP
// end ;
116232: LD_VAR 0 5
116236: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
116237: LD_EXP 211
116241: NOT
116242: IFFALSE 116292
116244: GO 116246
116246: DISABLE
// begin initHack := true ;
116247: LD_ADDR_EXP 211
116251: PUSH
116252: LD_INT 1
116254: ST_TO_ADDR
// hackTanks := [ ] ;
116255: LD_ADDR_EXP 212
116259: PUSH
116260: EMPTY
116261: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
116262: LD_ADDR_EXP 213
116266: PUSH
116267: EMPTY
116268: ST_TO_ADDR
// hackLimit := 3 ;
116269: LD_ADDR_EXP 214
116273: PUSH
116274: LD_INT 3
116276: ST_TO_ADDR
// hackDist := 12 ;
116277: LD_ADDR_EXP 215
116281: PUSH
116282: LD_INT 12
116284: ST_TO_ADDR
// hackCounter := [ ] ;
116285: LD_ADDR_EXP 216
116289: PUSH
116290: EMPTY
116291: ST_TO_ADDR
// end ;
116292: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
116293: LD_EXP 211
116297: PUSH
116298: LD_INT 34
116300: PUSH
116301: LD_EXP 97
116305: PUSH
116306: EMPTY
116307: LIST
116308: LIST
116309: PPUSH
116310: CALL_OW 69
116314: AND
116315: IFFALSE 116570
116317: GO 116319
116319: DISABLE
116320: LD_INT 0
116322: PPUSH
116323: PPUSH
// begin enable ;
116324: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
116325: LD_ADDR_VAR 0 1
116329: PUSH
116330: LD_INT 34
116332: PUSH
116333: LD_EXP 97
116337: PUSH
116338: EMPTY
116339: LIST
116340: LIST
116341: PPUSH
116342: CALL_OW 69
116346: PUSH
116347: FOR_IN
116348: IFFALSE 116568
// begin if not i in hackTanks then
116350: LD_VAR 0 1
116354: PUSH
116355: LD_EXP 212
116359: IN
116360: NOT
116361: IFFALSE 116444
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
116363: LD_ADDR_EXP 212
116367: PUSH
116368: LD_EXP 212
116372: PPUSH
116373: LD_EXP 212
116377: PUSH
116378: LD_INT 1
116380: PLUS
116381: PPUSH
116382: LD_VAR 0 1
116386: PPUSH
116387: CALL_OW 1
116391: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
116392: LD_ADDR_EXP 213
116396: PUSH
116397: LD_EXP 213
116401: PPUSH
116402: LD_EXP 213
116406: PUSH
116407: LD_INT 1
116409: PLUS
116410: PPUSH
116411: EMPTY
116412: PPUSH
116413: CALL_OW 1
116417: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
116418: LD_ADDR_EXP 216
116422: PUSH
116423: LD_EXP 216
116427: PPUSH
116428: LD_EXP 216
116432: PUSH
116433: LD_INT 1
116435: PLUS
116436: PPUSH
116437: EMPTY
116438: PPUSH
116439: CALL_OW 1
116443: ST_TO_ADDR
// end ; if not IsOk ( i ) then
116444: LD_VAR 0 1
116448: PPUSH
116449: CALL_OW 302
116453: NOT
116454: IFFALSE 116467
// begin HackUnlinkAll ( i ) ;
116456: LD_VAR 0 1
116460: PPUSH
116461: CALL 116573 0 1
// continue ;
116465: GO 116347
// end ; HackCheckCapturedStatus ( i ) ;
116467: LD_VAR 0 1
116471: PPUSH
116472: CALL 117016 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
116476: LD_ADDR_VAR 0 2
116480: PUSH
116481: LD_INT 81
116483: PUSH
116484: LD_VAR 0 1
116488: PPUSH
116489: CALL_OW 255
116493: PUSH
116494: EMPTY
116495: LIST
116496: LIST
116497: PUSH
116498: LD_INT 33
116500: PUSH
116501: LD_INT 3
116503: PUSH
116504: EMPTY
116505: LIST
116506: LIST
116507: PUSH
116508: LD_INT 91
116510: PUSH
116511: LD_VAR 0 1
116515: PUSH
116516: LD_EXP 215
116520: PUSH
116521: EMPTY
116522: LIST
116523: LIST
116524: LIST
116525: PUSH
116526: LD_INT 50
116528: PUSH
116529: EMPTY
116530: LIST
116531: PUSH
116532: EMPTY
116533: LIST
116534: LIST
116535: LIST
116536: LIST
116537: PPUSH
116538: CALL_OW 69
116542: ST_TO_ADDR
// if not tmp then
116543: LD_VAR 0 2
116547: NOT
116548: IFFALSE 116552
// continue ;
116550: GO 116347
// HackLink ( i , tmp ) ;
116552: LD_VAR 0 1
116556: PPUSH
116557: LD_VAR 0 2
116561: PPUSH
116562: CALL 116709 0 2
// end ;
116566: GO 116347
116568: POP
116569: POP
// end ;
116570: PPOPN 2
116572: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
116573: LD_INT 0
116575: PPUSH
116576: PPUSH
116577: PPUSH
// if not hack in hackTanks then
116578: LD_VAR 0 1
116582: PUSH
116583: LD_EXP 212
116587: IN
116588: NOT
116589: IFFALSE 116593
// exit ;
116591: GO 116704
// index := GetElementIndex ( hackTanks , hack ) ;
116593: LD_ADDR_VAR 0 4
116597: PUSH
116598: LD_EXP 212
116602: PPUSH
116603: LD_VAR 0 1
116607: PPUSH
116608: CALL 69913 0 2
116612: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
116613: LD_EXP 213
116617: PUSH
116618: LD_VAR 0 4
116622: ARRAY
116623: IFFALSE 116704
// begin for i in hackTanksCaptured [ index ] do
116625: LD_ADDR_VAR 0 3
116629: PUSH
116630: LD_EXP 213
116634: PUSH
116635: LD_VAR 0 4
116639: ARRAY
116640: PUSH
116641: FOR_IN
116642: IFFALSE 116668
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
116644: LD_VAR 0 3
116648: PUSH
116649: LD_INT 1
116651: ARRAY
116652: PPUSH
116653: LD_VAR 0 3
116657: PUSH
116658: LD_INT 2
116660: ARRAY
116661: PPUSH
116662: CALL_OW 235
116666: GO 116641
116668: POP
116669: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
116670: LD_ADDR_EXP 213
116674: PUSH
116675: LD_EXP 213
116679: PPUSH
116680: LD_VAR 0 4
116684: PPUSH
116685: EMPTY
116686: PPUSH
116687: CALL_OW 1
116691: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
116692: LD_VAR 0 1
116696: PPUSH
116697: LD_INT 0
116699: PPUSH
116700: CALL_OW 505
// end ; end ;
116704: LD_VAR 0 2
116708: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
116709: LD_INT 0
116711: PPUSH
116712: PPUSH
116713: PPUSH
// if not hack in hackTanks or not vehicles then
116714: LD_VAR 0 1
116718: PUSH
116719: LD_EXP 212
116723: IN
116724: NOT
116725: PUSH
116726: LD_VAR 0 2
116730: NOT
116731: OR
116732: IFFALSE 116736
// exit ;
116734: GO 117011
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
116736: LD_ADDR_VAR 0 2
116740: PUSH
116741: LD_VAR 0 1
116745: PPUSH
116746: LD_VAR 0 2
116750: PPUSH
116751: LD_INT 1
116753: PPUSH
116754: LD_INT 1
116756: PPUSH
116757: CALL 70563 0 4
116761: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
116762: LD_ADDR_VAR 0 5
116766: PUSH
116767: LD_EXP 212
116771: PPUSH
116772: LD_VAR 0 1
116776: PPUSH
116777: CALL 69913 0 2
116781: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
116782: LD_EXP 213
116786: PUSH
116787: LD_VAR 0 5
116791: ARRAY
116792: PUSH
116793: LD_EXP 214
116797: LESS
116798: IFFALSE 116987
// begin for i := 1 to vehicles do
116800: LD_ADDR_VAR 0 4
116804: PUSH
116805: DOUBLE
116806: LD_INT 1
116808: DEC
116809: ST_TO_ADDR
116810: LD_VAR 0 2
116814: PUSH
116815: FOR_TO
116816: IFFALSE 116985
// begin if hackTanksCaptured [ index ] = hackLimit then
116818: LD_EXP 213
116822: PUSH
116823: LD_VAR 0 5
116827: ARRAY
116828: PUSH
116829: LD_EXP 214
116833: EQUAL
116834: IFFALSE 116838
// break ;
116836: GO 116985
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
116838: LD_ADDR_EXP 216
116842: PUSH
116843: LD_EXP 216
116847: PPUSH
116848: LD_VAR 0 5
116852: PPUSH
116853: LD_EXP 216
116857: PUSH
116858: LD_VAR 0 5
116862: ARRAY
116863: PUSH
116864: LD_INT 1
116866: PLUS
116867: PPUSH
116868: CALL_OW 1
116872: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
116873: LD_ADDR_EXP 213
116877: PUSH
116878: LD_EXP 213
116882: PPUSH
116883: LD_VAR 0 5
116887: PUSH
116888: LD_EXP 213
116892: PUSH
116893: LD_VAR 0 5
116897: ARRAY
116898: PUSH
116899: LD_INT 1
116901: PLUS
116902: PUSH
116903: EMPTY
116904: LIST
116905: LIST
116906: PPUSH
116907: LD_VAR 0 2
116911: PUSH
116912: LD_VAR 0 4
116916: ARRAY
116917: PUSH
116918: LD_VAR 0 2
116922: PUSH
116923: LD_VAR 0 4
116927: ARRAY
116928: PPUSH
116929: CALL_OW 255
116933: PUSH
116934: EMPTY
116935: LIST
116936: LIST
116937: PPUSH
116938: CALL 70128 0 3
116942: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
116943: LD_VAR 0 2
116947: PUSH
116948: LD_VAR 0 4
116952: ARRAY
116953: PPUSH
116954: LD_VAR 0 1
116958: PPUSH
116959: CALL_OW 255
116963: PPUSH
116964: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
116968: LD_VAR 0 2
116972: PUSH
116973: LD_VAR 0 4
116977: ARRAY
116978: PPUSH
116979: CALL_OW 141
// end ;
116983: GO 116815
116985: POP
116986: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
116987: LD_VAR 0 1
116991: PPUSH
116992: LD_EXP 213
116996: PUSH
116997: LD_VAR 0 5
117001: ARRAY
117002: PUSH
117003: LD_INT 0
117005: PLUS
117006: PPUSH
117007: CALL_OW 505
// end ;
117011: LD_VAR 0 3
117015: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
117016: LD_INT 0
117018: PPUSH
117019: PPUSH
117020: PPUSH
117021: PPUSH
// if not hack in hackTanks then
117022: LD_VAR 0 1
117026: PUSH
117027: LD_EXP 212
117031: IN
117032: NOT
117033: IFFALSE 117037
// exit ;
117035: GO 117277
// index := GetElementIndex ( hackTanks , hack ) ;
117037: LD_ADDR_VAR 0 4
117041: PUSH
117042: LD_EXP 212
117046: PPUSH
117047: LD_VAR 0 1
117051: PPUSH
117052: CALL 69913 0 2
117056: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
117057: LD_ADDR_VAR 0 3
117061: PUSH
117062: DOUBLE
117063: LD_EXP 213
117067: PUSH
117068: LD_VAR 0 4
117072: ARRAY
117073: INC
117074: ST_TO_ADDR
117075: LD_INT 1
117077: PUSH
117078: FOR_DOWNTO
117079: IFFALSE 117251
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
117081: LD_ADDR_VAR 0 5
117085: PUSH
117086: LD_EXP 213
117090: PUSH
117091: LD_VAR 0 4
117095: ARRAY
117096: PUSH
117097: LD_VAR 0 3
117101: ARRAY
117102: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
117103: LD_VAR 0 5
117107: PUSH
117108: LD_INT 1
117110: ARRAY
117111: PPUSH
117112: CALL_OW 302
117116: NOT
117117: PUSH
117118: LD_VAR 0 5
117122: PUSH
117123: LD_INT 1
117125: ARRAY
117126: PPUSH
117127: CALL_OW 255
117131: PUSH
117132: LD_VAR 0 1
117136: PPUSH
117137: CALL_OW 255
117141: NONEQUAL
117142: OR
117143: IFFALSE 117249
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
117145: LD_VAR 0 5
117149: PUSH
117150: LD_INT 1
117152: ARRAY
117153: PPUSH
117154: CALL_OW 305
117158: PUSH
117159: LD_VAR 0 5
117163: PUSH
117164: LD_INT 1
117166: ARRAY
117167: PPUSH
117168: CALL_OW 255
117172: PUSH
117173: LD_VAR 0 1
117177: PPUSH
117178: CALL_OW 255
117182: EQUAL
117183: AND
117184: IFFALSE 117208
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
117186: LD_VAR 0 5
117190: PUSH
117191: LD_INT 1
117193: ARRAY
117194: PPUSH
117195: LD_VAR 0 5
117199: PUSH
117200: LD_INT 2
117202: ARRAY
117203: PPUSH
117204: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
117208: LD_ADDR_EXP 213
117212: PUSH
117213: LD_EXP 213
117217: PPUSH
117218: LD_VAR 0 4
117222: PPUSH
117223: LD_EXP 213
117227: PUSH
117228: LD_VAR 0 4
117232: ARRAY
117233: PPUSH
117234: LD_VAR 0 3
117238: PPUSH
117239: CALL_OW 3
117243: PPUSH
117244: CALL_OW 1
117248: ST_TO_ADDR
// end ; end ;
117249: GO 117078
117251: POP
117252: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
117253: LD_VAR 0 1
117257: PPUSH
117258: LD_EXP 213
117262: PUSH
117263: LD_VAR 0 4
117267: ARRAY
117268: PUSH
117269: LD_INT 0
117271: PLUS
117272: PPUSH
117273: CALL_OW 505
// end ;
117277: LD_VAR 0 2
117281: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
117282: LD_INT 0
117284: PPUSH
117285: PPUSH
117286: PPUSH
117287: PPUSH
// if not hack in hackTanks then
117288: LD_VAR 0 1
117292: PUSH
117293: LD_EXP 212
117297: IN
117298: NOT
117299: IFFALSE 117303
// exit ;
117301: GO 117388
// index := GetElementIndex ( hackTanks , hack ) ;
117303: LD_ADDR_VAR 0 5
117307: PUSH
117308: LD_EXP 212
117312: PPUSH
117313: LD_VAR 0 1
117317: PPUSH
117318: CALL 69913 0 2
117322: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
117323: LD_ADDR_VAR 0 4
117327: PUSH
117328: DOUBLE
117329: LD_INT 1
117331: DEC
117332: ST_TO_ADDR
117333: LD_EXP 213
117337: PUSH
117338: LD_VAR 0 5
117342: ARRAY
117343: PUSH
117344: FOR_TO
117345: IFFALSE 117386
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
117347: LD_EXP 213
117351: PUSH
117352: LD_VAR 0 5
117356: ARRAY
117357: PUSH
117358: LD_VAR 0 4
117362: ARRAY
117363: PUSH
117364: LD_INT 1
117366: ARRAY
117367: PUSH
117368: LD_VAR 0 2
117372: EQUAL
117373: IFFALSE 117384
// KillUnit ( vehicle ) ;
117375: LD_VAR 0 2
117379: PPUSH
117380: CALL_OW 66
117384: GO 117344
117386: POP
117387: POP
// end ;
117388: LD_VAR 0 3
117392: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
117393: LD_EXP 217
117397: NOT
117398: IFFALSE 117433
117400: GO 117402
117402: DISABLE
// begin initMiner := true ;
117403: LD_ADDR_EXP 217
117407: PUSH
117408: LD_INT 1
117410: ST_TO_ADDR
// minersList := [ ] ;
117411: LD_ADDR_EXP 218
117415: PUSH
117416: EMPTY
117417: ST_TO_ADDR
// minerMinesList := [ ] ;
117418: LD_ADDR_EXP 219
117422: PUSH
117423: EMPTY
117424: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
117425: LD_ADDR_EXP 220
117429: PUSH
117430: LD_INT 5
117432: ST_TO_ADDR
// end ;
117433: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
117434: LD_EXP 217
117438: PUSH
117439: LD_INT 34
117441: PUSH
117442: LD_EXP 102
117446: PUSH
117447: EMPTY
117448: LIST
117449: LIST
117450: PPUSH
117451: CALL_OW 69
117455: AND
117456: IFFALSE 117919
117458: GO 117460
117460: DISABLE
117461: LD_INT 0
117463: PPUSH
117464: PPUSH
117465: PPUSH
117466: PPUSH
// begin enable ;
117467: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
117468: LD_ADDR_VAR 0 1
117472: PUSH
117473: LD_INT 34
117475: PUSH
117476: LD_EXP 102
117480: PUSH
117481: EMPTY
117482: LIST
117483: LIST
117484: PPUSH
117485: CALL_OW 69
117489: PUSH
117490: FOR_IN
117491: IFFALSE 117563
// begin if not i in minersList then
117493: LD_VAR 0 1
117497: PUSH
117498: LD_EXP 218
117502: IN
117503: NOT
117504: IFFALSE 117561
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
117506: LD_ADDR_EXP 218
117510: PUSH
117511: LD_EXP 218
117515: PPUSH
117516: LD_EXP 218
117520: PUSH
117521: LD_INT 1
117523: PLUS
117524: PPUSH
117525: LD_VAR 0 1
117529: PPUSH
117530: CALL_OW 1
117534: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
117535: LD_ADDR_EXP 219
117539: PUSH
117540: LD_EXP 219
117544: PPUSH
117545: LD_EXP 219
117549: PUSH
117550: LD_INT 1
117552: PLUS
117553: PPUSH
117554: EMPTY
117555: PPUSH
117556: CALL_OW 1
117560: ST_TO_ADDR
// end end ;
117561: GO 117490
117563: POP
117564: POP
// for i := minerMinesList downto 1 do
117565: LD_ADDR_VAR 0 1
117569: PUSH
117570: DOUBLE
117571: LD_EXP 219
117575: INC
117576: ST_TO_ADDR
117577: LD_INT 1
117579: PUSH
117580: FOR_DOWNTO
117581: IFFALSE 117917
// begin if IsLive ( minersList [ i ] ) then
117583: LD_EXP 218
117587: PUSH
117588: LD_VAR 0 1
117592: ARRAY
117593: PPUSH
117594: CALL_OW 300
117598: IFFALSE 117626
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
117600: LD_EXP 218
117604: PUSH
117605: LD_VAR 0 1
117609: ARRAY
117610: PPUSH
117611: LD_EXP 219
117615: PUSH
117616: LD_VAR 0 1
117620: ARRAY
117621: PPUSH
117622: CALL_OW 505
// if not minerMinesList [ i ] then
117626: LD_EXP 219
117630: PUSH
117631: LD_VAR 0 1
117635: ARRAY
117636: NOT
117637: IFFALSE 117641
// continue ;
117639: GO 117580
// for j := minerMinesList [ i ] downto 1 do
117641: LD_ADDR_VAR 0 2
117645: PUSH
117646: DOUBLE
117647: LD_EXP 219
117651: PUSH
117652: LD_VAR 0 1
117656: ARRAY
117657: INC
117658: ST_TO_ADDR
117659: LD_INT 1
117661: PUSH
117662: FOR_DOWNTO
117663: IFFALSE 117913
// begin side := GetSide ( minersList [ i ] ) ;
117665: LD_ADDR_VAR 0 3
117669: PUSH
117670: LD_EXP 218
117674: PUSH
117675: LD_VAR 0 1
117679: ARRAY
117680: PPUSH
117681: CALL_OW 255
117685: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
117686: LD_ADDR_VAR 0 4
117690: PUSH
117691: LD_EXP 219
117695: PUSH
117696: LD_VAR 0 1
117700: ARRAY
117701: PUSH
117702: LD_VAR 0 2
117706: ARRAY
117707: PUSH
117708: LD_INT 1
117710: ARRAY
117711: PPUSH
117712: LD_EXP 219
117716: PUSH
117717: LD_VAR 0 1
117721: ARRAY
117722: PUSH
117723: LD_VAR 0 2
117727: ARRAY
117728: PUSH
117729: LD_INT 2
117731: ARRAY
117732: PPUSH
117733: CALL_OW 428
117737: ST_TO_ADDR
// if not tmp then
117738: LD_VAR 0 4
117742: NOT
117743: IFFALSE 117747
// continue ;
117745: GO 117662
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
117747: LD_VAR 0 4
117751: PUSH
117752: LD_INT 81
117754: PUSH
117755: LD_VAR 0 3
117759: PUSH
117760: EMPTY
117761: LIST
117762: LIST
117763: PPUSH
117764: CALL_OW 69
117768: IN
117769: PUSH
117770: LD_EXP 219
117774: PUSH
117775: LD_VAR 0 1
117779: ARRAY
117780: PUSH
117781: LD_VAR 0 2
117785: ARRAY
117786: PUSH
117787: LD_INT 1
117789: ARRAY
117790: PPUSH
117791: LD_EXP 219
117795: PUSH
117796: LD_VAR 0 1
117800: ARRAY
117801: PUSH
117802: LD_VAR 0 2
117806: ARRAY
117807: PUSH
117808: LD_INT 2
117810: ARRAY
117811: PPUSH
117812: CALL_OW 458
117816: AND
117817: IFFALSE 117911
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
117819: LD_EXP 219
117823: PUSH
117824: LD_VAR 0 1
117828: ARRAY
117829: PUSH
117830: LD_VAR 0 2
117834: ARRAY
117835: PUSH
117836: LD_INT 1
117838: ARRAY
117839: PPUSH
117840: LD_EXP 219
117844: PUSH
117845: LD_VAR 0 1
117849: ARRAY
117850: PUSH
117851: LD_VAR 0 2
117855: ARRAY
117856: PUSH
117857: LD_INT 2
117859: ARRAY
117860: PPUSH
117861: LD_VAR 0 3
117865: PPUSH
117866: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
117870: LD_ADDR_EXP 219
117874: PUSH
117875: LD_EXP 219
117879: PPUSH
117880: LD_VAR 0 1
117884: PPUSH
117885: LD_EXP 219
117889: PUSH
117890: LD_VAR 0 1
117894: ARRAY
117895: PPUSH
117896: LD_VAR 0 2
117900: PPUSH
117901: CALL_OW 3
117905: PPUSH
117906: CALL_OW 1
117910: ST_TO_ADDR
// end ; end ;
117911: GO 117662
117913: POP
117914: POP
// end ;
117915: GO 117580
117917: POP
117918: POP
// end ;
117919: PPOPN 4
117921: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
117922: LD_INT 0
117924: PPUSH
117925: PPUSH
// result := false ;
117926: LD_ADDR_VAR 0 4
117930: PUSH
117931: LD_INT 0
117933: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
117934: LD_VAR 0 1
117938: PPUSH
117939: CALL_OW 264
117943: PUSH
117944: LD_EXP 102
117948: EQUAL
117949: NOT
117950: IFFALSE 117954
// exit ;
117952: GO 118194
// index := GetElementIndex ( minersList , unit ) ;
117954: LD_ADDR_VAR 0 5
117958: PUSH
117959: LD_EXP 218
117963: PPUSH
117964: LD_VAR 0 1
117968: PPUSH
117969: CALL 69913 0 2
117973: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
117974: LD_EXP 219
117978: PUSH
117979: LD_VAR 0 5
117983: ARRAY
117984: PUSH
117985: LD_EXP 220
117989: GREATEREQUAL
117990: IFFALSE 117994
// exit ;
117992: GO 118194
// ComMoveXY ( unit , x , y ) ;
117994: LD_VAR 0 1
117998: PPUSH
117999: LD_VAR 0 2
118003: PPUSH
118004: LD_VAR 0 3
118008: PPUSH
118009: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
118013: LD_INT 35
118015: PPUSH
118016: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
118020: LD_VAR 0 1
118024: PPUSH
118025: LD_VAR 0 2
118029: PPUSH
118030: LD_VAR 0 3
118034: PPUSH
118035: CALL 99977 0 3
118039: NOT
118040: PUSH
118041: LD_VAR 0 1
118045: PPUSH
118046: CALL_OW 314
118050: AND
118051: IFFALSE 118055
// exit ;
118053: GO 118194
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
118055: LD_VAR 0 2
118059: PPUSH
118060: LD_VAR 0 3
118064: PPUSH
118065: CALL_OW 428
118069: PUSH
118070: LD_VAR 0 1
118074: EQUAL
118075: PUSH
118076: LD_VAR 0 1
118080: PPUSH
118081: CALL_OW 314
118085: NOT
118086: AND
118087: IFFALSE 118013
// PlaySoundXY ( x , y , PlantMine ) ;
118089: LD_VAR 0 2
118093: PPUSH
118094: LD_VAR 0 3
118098: PPUSH
118099: LD_STRING PlantMine
118101: PPUSH
118102: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
118106: LD_VAR 0 2
118110: PPUSH
118111: LD_VAR 0 3
118115: PPUSH
118116: LD_VAR 0 1
118120: PPUSH
118121: CALL_OW 255
118125: PPUSH
118126: LD_INT 0
118128: PPUSH
118129: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
118133: LD_ADDR_EXP 219
118137: PUSH
118138: LD_EXP 219
118142: PPUSH
118143: LD_VAR 0 5
118147: PUSH
118148: LD_EXP 219
118152: PUSH
118153: LD_VAR 0 5
118157: ARRAY
118158: PUSH
118159: LD_INT 1
118161: PLUS
118162: PUSH
118163: EMPTY
118164: LIST
118165: LIST
118166: PPUSH
118167: LD_VAR 0 2
118171: PUSH
118172: LD_VAR 0 3
118176: PUSH
118177: EMPTY
118178: LIST
118179: LIST
118180: PPUSH
118181: CALL 70128 0 3
118185: ST_TO_ADDR
// result := true ;
118186: LD_ADDR_VAR 0 4
118190: PUSH
118191: LD_INT 1
118193: ST_TO_ADDR
// end ;
118194: LD_VAR 0 4
118198: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
118199: LD_INT 0
118201: PPUSH
118202: PPUSH
118203: PPUSH
// if not unit in minersList then
118204: LD_VAR 0 1
118208: PUSH
118209: LD_EXP 218
118213: IN
118214: NOT
118215: IFFALSE 118219
// exit ;
118217: GO 118611
// index := GetElementIndex ( minersList , unit ) ;
118219: LD_ADDR_VAR 0 6
118223: PUSH
118224: LD_EXP 218
118228: PPUSH
118229: LD_VAR 0 1
118233: PPUSH
118234: CALL 69913 0 2
118238: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
118239: LD_ADDR_VAR 0 5
118243: PUSH
118244: DOUBLE
118245: LD_EXP 219
118249: PUSH
118250: LD_VAR 0 6
118254: ARRAY
118255: INC
118256: ST_TO_ADDR
118257: LD_INT 1
118259: PUSH
118260: FOR_DOWNTO
118261: IFFALSE 118422
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
118263: LD_EXP 219
118267: PUSH
118268: LD_VAR 0 6
118272: ARRAY
118273: PUSH
118274: LD_VAR 0 5
118278: ARRAY
118279: PUSH
118280: LD_INT 1
118282: ARRAY
118283: PUSH
118284: LD_VAR 0 2
118288: EQUAL
118289: PUSH
118290: LD_EXP 219
118294: PUSH
118295: LD_VAR 0 6
118299: ARRAY
118300: PUSH
118301: LD_VAR 0 5
118305: ARRAY
118306: PUSH
118307: LD_INT 2
118309: ARRAY
118310: PUSH
118311: LD_VAR 0 3
118315: EQUAL
118316: AND
118317: IFFALSE 118420
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
118319: LD_EXP 219
118323: PUSH
118324: LD_VAR 0 6
118328: ARRAY
118329: PUSH
118330: LD_VAR 0 5
118334: ARRAY
118335: PUSH
118336: LD_INT 1
118338: ARRAY
118339: PPUSH
118340: LD_EXP 219
118344: PUSH
118345: LD_VAR 0 6
118349: ARRAY
118350: PUSH
118351: LD_VAR 0 5
118355: ARRAY
118356: PUSH
118357: LD_INT 2
118359: ARRAY
118360: PPUSH
118361: LD_VAR 0 1
118365: PPUSH
118366: CALL_OW 255
118370: PPUSH
118371: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
118375: LD_ADDR_EXP 219
118379: PUSH
118380: LD_EXP 219
118384: PPUSH
118385: LD_VAR 0 6
118389: PPUSH
118390: LD_EXP 219
118394: PUSH
118395: LD_VAR 0 6
118399: ARRAY
118400: PPUSH
118401: LD_VAR 0 5
118405: PPUSH
118406: CALL_OW 3
118410: PPUSH
118411: CALL_OW 1
118415: ST_TO_ADDR
// exit ;
118416: POP
118417: POP
118418: GO 118611
// end ; end ;
118420: GO 118260
118422: POP
118423: POP
// for i := minerMinesList [ index ] downto 1 do
118424: LD_ADDR_VAR 0 5
118428: PUSH
118429: DOUBLE
118430: LD_EXP 219
118434: PUSH
118435: LD_VAR 0 6
118439: ARRAY
118440: INC
118441: ST_TO_ADDR
118442: LD_INT 1
118444: PUSH
118445: FOR_DOWNTO
118446: IFFALSE 118609
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
118448: LD_EXP 219
118452: PUSH
118453: LD_VAR 0 6
118457: ARRAY
118458: PUSH
118459: LD_VAR 0 5
118463: ARRAY
118464: PUSH
118465: LD_INT 1
118467: ARRAY
118468: PPUSH
118469: LD_EXP 219
118473: PUSH
118474: LD_VAR 0 6
118478: ARRAY
118479: PUSH
118480: LD_VAR 0 5
118484: ARRAY
118485: PUSH
118486: LD_INT 2
118488: ARRAY
118489: PPUSH
118490: LD_VAR 0 2
118494: PPUSH
118495: LD_VAR 0 3
118499: PPUSH
118500: CALL_OW 298
118504: PUSH
118505: LD_INT 6
118507: LESS
118508: IFFALSE 118607
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
118510: LD_EXP 219
118514: PUSH
118515: LD_VAR 0 6
118519: ARRAY
118520: PUSH
118521: LD_VAR 0 5
118525: ARRAY
118526: PUSH
118527: LD_INT 1
118529: ARRAY
118530: PPUSH
118531: LD_EXP 219
118535: PUSH
118536: LD_VAR 0 6
118540: ARRAY
118541: PUSH
118542: LD_VAR 0 5
118546: ARRAY
118547: PUSH
118548: LD_INT 2
118550: ARRAY
118551: PPUSH
118552: LD_VAR 0 1
118556: PPUSH
118557: CALL_OW 255
118561: PPUSH
118562: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
118566: LD_ADDR_EXP 219
118570: PUSH
118571: LD_EXP 219
118575: PPUSH
118576: LD_VAR 0 6
118580: PPUSH
118581: LD_EXP 219
118585: PUSH
118586: LD_VAR 0 6
118590: ARRAY
118591: PPUSH
118592: LD_VAR 0 5
118596: PPUSH
118597: CALL_OW 3
118601: PPUSH
118602: CALL_OW 1
118606: ST_TO_ADDR
// end ; end ;
118607: GO 118445
118609: POP
118610: POP
// end ;
118611: LD_VAR 0 4
118615: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
118616: LD_INT 0
118618: PPUSH
118619: PPUSH
118620: PPUSH
118621: PPUSH
118622: PPUSH
118623: PPUSH
118624: PPUSH
118625: PPUSH
118626: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
118627: LD_VAR 0 1
118631: PPUSH
118632: CALL_OW 264
118636: PUSH
118637: LD_EXP 102
118641: EQUAL
118642: NOT
118643: PUSH
118644: LD_VAR 0 1
118648: PUSH
118649: LD_EXP 218
118653: IN
118654: NOT
118655: OR
118656: IFFALSE 118660
// exit ;
118658: GO 118982
// index := GetElementIndex ( minersList , unit ) ;
118660: LD_ADDR_VAR 0 6
118664: PUSH
118665: LD_EXP 218
118669: PPUSH
118670: LD_VAR 0 1
118674: PPUSH
118675: CALL 69913 0 2
118679: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
118680: LD_ADDR_VAR 0 8
118684: PUSH
118685: LD_EXP 220
118689: PUSH
118690: LD_EXP 219
118694: PUSH
118695: LD_VAR 0 6
118699: ARRAY
118700: MINUS
118701: ST_TO_ADDR
// if not minesFreeAmount then
118702: LD_VAR 0 8
118706: NOT
118707: IFFALSE 118711
// exit ;
118709: GO 118982
// tmp := [ ] ;
118711: LD_ADDR_VAR 0 7
118715: PUSH
118716: EMPTY
118717: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
118718: LD_ADDR_VAR 0 5
118722: PUSH
118723: DOUBLE
118724: LD_INT 1
118726: DEC
118727: ST_TO_ADDR
118728: LD_VAR 0 8
118732: PUSH
118733: FOR_TO
118734: IFFALSE 118929
// begin _d := rand ( 0 , 5 ) ;
118736: LD_ADDR_VAR 0 11
118740: PUSH
118741: LD_INT 0
118743: PPUSH
118744: LD_INT 5
118746: PPUSH
118747: CALL_OW 12
118751: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
118752: LD_ADDR_VAR 0 12
118756: PUSH
118757: LD_INT 2
118759: PPUSH
118760: LD_INT 6
118762: PPUSH
118763: CALL_OW 12
118767: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
118768: LD_ADDR_VAR 0 9
118772: PUSH
118773: LD_VAR 0 2
118777: PPUSH
118778: LD_VAR 0 11
118782: PPUSH
118783: LD_VAR 0 12
118787: PPUSH
118788: CALL_OW 272
118792: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
118793: LD_ADDR_VAR 0 10
118797: PUSH
118798: LD_VAR 0 3
118802: PPUSH
118803: LD_VAR 0 11
118807: PPUSH
118808: LD_VAR 0 12
118812: PPUSH
118813: CALL_OW 273
118817: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
118818: LD_VAR 0 9
118822: PPUSH
118823: LD_VAR 0 10
118827: PPUSH
118828: CALL_OW 488
118832: PUSH
118833: LD_VAR 0 9
118837: PUSH
118838: LD_VAR 0 10
118842: PUSH
118843: EMPTY
118844: LIST
118845: LIST
118846: PUSH
118847: LD_VAR 0 7
118851: IN
118852: NOT
118853: AND
118854: PUSH
118855: LD_VAR 0 9
118859: PPUSH
118860: LD_VAR 0 10
118864: PPUSH
118865: CALL_OW 458
118869: NOT
118870: AND
118871: IFFALSE 118913
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
118873: LD_ADDR_VAR 0 7
118877: PUSH
118878: LD_VAR 0 7
118882: PPUSH
118883: LD_VAR 0 7
118887: PUSH
118888: LD_INT 1
118890: PLUS
118891: PPUSH
118892: LD_VAR 0 9
118896: PUSH
118897: LD_VAR 0 10
118901: PUSH
118902: EMPTY
118903: LIST
118904: LIST
118905: PPUSH
118906: CALL_OW 1
118910: ST_TO_ADDR
118911: GO 118927
// i := i - 1 ;
118913: LD_ADDR_VAR 0 5
118917: PUSH
118918: LD_VAR 0 5
118922: PUSH
118923: LD_INT 1
118925: MINUS
118926: ST_TO_ADDR
// end ;
118927: GO 118733
118929: POP
118930: POP
// for i in tmp do
118931: LD_ADDR_VAR 0 5
118935: PUSH
118936: LD_VAR 0 7
118940: PUSH
118941: FOR_IN
118942: IFFALSE 118980
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
118944: LD_VAR 0 1
118948: PPUSH
118949: LD_VAR 0 5
118953: PUSH
118954: LD_INT 1
118956: ARRAY
118957: PPUSH
118958: LD_VAR 0 5
118962: PUSH
118963: LD_INT 2
118965: ARRAY
118966: PPUSH
118967: CALL 117922 0 3
118971: NOT
118972: IFFALSE 118978
// exit ;
118974: POP
118975: POP
118976: GO 118982
118978: GO 118941
118980: POP
118981: POP
// end ;
118982: LD_VAR 0 4
118986: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
118987: LD_INT 0
118989: PPUSH
118990: PPUSH
118991: PPUSH
118992: PPUSH
118993: PPUSH
118994: PPUSH
118995: PPUSH
// if not GetClass ( unit ) = class_sniper then
118996: LD_VAR 0 1
119000: PPUSH
119001: CALL_OW 257
119005: PUSH
119006: LD_INT 5
119008: EQUAL
119009: NOT
119010: IFFALSE 119014
// exit ;
119012: GO 119402
// dist := 8 ;
119014: LD_ADDR_VAR 0 5
119018: PUSH
119019: LD_INT 8
119021: ST_TO_ADDR
// viewRange := 12 ;
119022: LD_ADDR_VAR 0 7
119026: PUSH
119027: LD_INT 12
119029: ST_TO_ADDR
// side := GetSide ( unit ) ;
119030: LD_ADDR_VAR 0 6
119034: PUSH
119035: LD_VAR 0 1
119039: PPUSH
119040: CALL_OW 255
119044: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
119045: LD_INT 61
119047: PPUSH
119048: LD_VAR 0 6
119052: PPUSH
119053: CALL_OW 321
119057: PUSH
119058: LD_INT 2
119060: EQUAL
119061: IFFALSE 119071
// viewRange := 16 ;
119063: LD_ADDR_VAR 0 7
119067: PUSH
119068: LD_INT 16
119070: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
119071: LD_VAR 0 1
119075: PPUSH
119076: LD_VAR 0 2
119080: PPUSH
119081: LD_VAR 0 3
119085: PPUSH
119086: CALL_OW 297
119090: PUSH
119091: LD_VAR 0 5
119095: GREATER
119096: IFFALSE 119175
// begin ComMoveXY ( unit , x , y ) ;
119098: LD_VAR 0 1
119102: PPUSH
119103: LD_VAR 0 2
119107: PPUSH
119108: LD_VAR 0 3
119112: PPUSH
119113: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
119117: LD_INT 35
119119: PPUSH
119120: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
119124: LD_VAR 0 1
119128: PPUSH
119129: LD_VAR 0 2
119133: PPUSH
119134: LD_VAR 0 3
119138: PPUSH
119139: CALL 99977 0 3
119143: NOT
119144: IFFALSE 119148
// exit ;
119146: GO 119402
// until GetDistUnitXY ( unit , x , y ) < dist ;
119148: LD_VAR 0 1
119152: PPUSH
119153: LD_VAR 0 2
119157: PPUSH
119158: LD_VAR 0 3
119162: PPUSH
119163: CALL_OW 297
119167: PUSH
119168: LD_VAR 0 5
119172: LESS
119173: IFFALSE 119117
// end ; ComTurnXY ( unit , x , y ) ;
119175: LD_VAR 0 1
119179: PPUSH
119180: LD_VAR 0 2
119184: PPUSH
119185: LD_VAR 0 3
119189: PPUSH
119190: CALL_OW 118
// wait ( 5 ) ;
119194: LD_INT 5
119196: PPUSH
119197: CALL_OW 67
// _d := GetDir ( unit ) ;
119201: LD_ADDR_VAR 0 10
119205: PUSH
119206: LD_VAR 0 1
119210: PPUSH
119211: CALL_OW 254
119215: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
119216: LD_ADDR_VAR 0 8
119220: PUSH
119221: LD_VAR 0 1
119225: PPUSH
119226: CALL_OW 250
119230: PPUSH
119231: LD_VAR 0 10
119235: PPUSH
119236: LD_VAR 0 5
119240: PPUSH
119241: CALL_OW 272
119245: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
119246: LD_ADDR_VAR 0 9
119250: PUSH
119251: LD_VAR 0 1
119255: PPUSH
119256: CALL_OW 251
119260: PPUSH
119261: LD_VAR 0 10
119265: PPUSH
119266: LD_VAR 0 5
119270: PPUSH
119271: CALL_OW 273
119275: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
119276: LD_VAR 0 8
119280: PPUSH
119281: LD_VAR 0 9
119285: PPUSH
119286: CALL_OW 488
119290: NOT
119291: IFFALSE 119295
// exit ;
119293: GO 119402
// ComAnimCustom ( unit , 1 ) ;
119295: LD_VAR 0 1
119299: PPUSH
119300: LD_INT 1
119302: PPUSH
119303: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
119307: LD_VAR 0 8
119311: PPUSH
119312: LD_VAR 0 9
119316: PPUSH
119317: LD_VAR 0 6
119321: PPUSH
119322: LD_VAR 0 7
119326: PPUSH
119327: CALL_OW 330
// repeat wait ( 1 ) ;
119331: LD_INT 1
119333: PPUSH
119334: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
119338: LD_VAR 0 1
119342: PPUSH
119343: CALL_OW 316
119347: PUSH
119348: LD_VAR 0 1
119352: PPUSH
119353: CALL_OW 314
119357: OR
119358: PUSH
119359: LD_VAR 0 1
119363: PPUSH
119364: CALL_OW 302
119368: NOT
119369: OR
119370: PUSH
119371: LD_VAR 0 1
119375: PPUSH
119376: CALL_OW 301
119380: OR
119381: IFFALSE 119331
// RemoveSeeing ( _x , _y , side ) ;
119383: LD_VAR 0 8
119387: PPUSH
119388: LD_VAR 0 9
119392: PPUSH
119393: LD_VAR 0 6
119397: PPUSH
119398: CALL_OW 331
// end ; end_of_file
119402: LD_VAR 0 4
119406: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
119407: LD_INT 0
119409: PPUSH
119410: PPUSH
119411: PPUSH
119412: PPUSH
119413: PPUSH
119414: PPUSH
119415: PPUSH
119416: PPUSH
119417: PPUSH
119418: PPUSH
119419: PPUSH
119420: PPUSH
119421: PPUSH
119422: PPUSH
119423: PPUSH
119424: PPUSH
119425: PPUSH
119426: PPUSH
119427: PPUSH
119428: PPUSH
119429: PPUSH
119430: PPUSH
119431: PPUSH
119432: PPUSH
119433: PPUSH
119434: PPUSH
119435: PPUSH
119436: PPUSH
119437: PPUSH
119438: PPUSH
119439: PPUSH
119440: PPUSH
119441: PPUSH
119442: PPUSH
// if not list then
119443: LD_VAR 0 1
119447: NOT
119448: IFFALSE 119452
// exit ;
119450: GO 124111
// base := list [ 1 ] ;
119452: LD_ADDR_VAR 0 3
119456: PUSH
119457: LD_VAR 0 1
119461: PUSH
119462: LD_INT 1
119464: ARRAY
119465: ST_TO_ADDR
// group := list [ 2 ] ;
119466: LD_ADDR_VAR 0 4
119470: PUSH
119471: LD_VAR 0 1
119475: PUSH
119476: LD_INT 2
119478: ARRAY
119479: ST_TO_ADDR
// path := list [ 3 ] ;
119480: LD_ADDR_VAR 0 5
119484: PUSH
119485: LD_VAR 0 1
119489: PUSH
119490: LD_INT 3
119492: ARRAY
119493: ST_TO_ADDR
// flags := list [ 4 ] ;
119494: LD_ADDR_VAR 0 6
119498: PUSH
119499: LD_VAR 0 1
119503: PUSH
119504: LD_INT 4
119506: ARRAY
119507: ST_TO_ADDR
// mined := [ ] ;
119508: LD_ADDR_VAR 0 27
119512: PUSH
119513: EMPTY
119514: ST_TO_ADDR
// bombed := [ ] ;
119515: LD_ADDR_VAR 0 28
119519: PUSH
119520: EMPTY
119521: ST_TO_ADDR
// healers := [ ] ;
119522: LD_ADDR_VAR 0 31
119526: PUSH
119527: EMPTY
119528: ST_TO_ADDR
// to_heal := [ ] ;
119529: LD_ADDR_VAR 0 30
119533: PUSH
119534: EMPTY
119535: ST_TO_ADDR
// repairs := [ ] ;
119536: LD_ADDR_VAR 0 33
119540: PUSH
119541: EMPTY
119542: ST_TO_ADDR
// to_repair := [ ] ;
119543: LD_ADDR_VAR 0 32
119547: PUSH
119548: EMPTY
119549: ST_TO_ADDR
// if not group or not path then
119550: LD_VAR 0 4
119554: NOT
119555: PUSH
119556: LD_VAR 0 5
119560: NOT
119561: OR
119562: IFFALSE 119566
// exit ;
119564: GO 124111
// side := GetSide ( group [ 1 ] ) ;
119566: LD_ADDR_VAR 0 35
119570: PUSH
119571: LD_VAR 0 4
119575: PUSH
119576: LD_INT 1
119578: ARRAY
119579: PPUSH
119580: CALL_OW 255
119584: ST_TO_ADDR
// if flags then
119585: LD_VAR 0 6
119589: IFFALSE 119733
// begin f_ignore_area := flags [ 1 ] ;
119591: LD_ADDR_VAR 0 17
119595: PUSH
119596: LD_VAR 0 6
119600: PUSH
119601: LD_INT 1
119603: ARRAY
119604: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
119605: LD_ADDR_VAR 0 18
119609: PUSH
119610: LD_VAR 0 6
119614: PUSH
119615: LD_INT 2
119617: ARRAY
119618: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
119619: LD_ADDR_VAR 0 19
119623: PUSH
119624: LD_VAR 0 6
119628: PUSH
119629: LD_INT 3
119631: ARRAY
119632: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
119633: LD_ADDR_VAR 0 20
119637: PUSH
119638: LD_VAR 0 6
119642: PUSH
119643: LD_INT 4
119645: ARRAY
119646: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
119647: LD_ADDR_VAR 0 21
119651: PUSH
119652: LD_VAR 0 6
119656: PUSH
119657: LD_INT 5
119659: ARRAY
119660: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
119661: LD_ADDR_VAR 0 22
119665: PUSH
119666: LD_VAR 0 6
119670: PUSH
119671: LD_INT 6
119673: ARRAY
119674: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
119675: LD_ADDR_VAR 0 23
119679: PUSH
119680: LD_VAR 0 6
119684: PUSH
119685: LD_INT 7
119687: ARRAY
119688: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
119689: LD_ADDR_VAR 0 24
119693: PUSH
119694: LD_VAR 0 6
119698: PUSH
119699: LD_INT 8
119701: ARRAY
119702: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
119703: LD_ADDR_VAR 0 25
119707: PUSH
119708: LD_VAR 0 6
119712: PUSH
119713: LD_INT 9
119715: ARRAY
119716: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
119717: LD_ADDR_VAR 0 26
119721: PUSH
119722: LD_VAR 0 6
119726: PUSH
119727: LD_INT 10
119729: ARRAY
119730: ST_TO_ADDR
// end else
119731: GO 119813
// begin f_ignore_area := false ;
119733: LD_ADDR_VAR 0 17
119737: PUSH
119738: LD_INT 0
119740: ST_TO_ADDR
// f_capture := false ;
119741: LD_ADDR_VAR 0 18
119745: PUSH
119746: LD_INT 0
119748: ST_TO_ADDR
// f_ignore_civ := false ;
119749: LD_ADDR_VAR 0 19
119753: PUSH
119754: LD_INT 0
119756: ST_TO_ADDR
// f_murder := false ;
119757: LD_ADDR_VAR 0 20
119761: PUSH
119762: LD_INT 0
119764: ST_TO_ADDR
// f_mines := false ;
119765: LD_ADDR_VAR 0 21
119769: PUSH
119770: LD_INT 0
119772: ST_TO_ADDR
// f_repair := false ;
119773: LD_ADDR_VAR 0 22
119777: PUSH
119778: LD_INT 0
119780: ST_TO_ADDR
// f_heal := false ;
119781: LD_ADDR_VAR 0 23
119785: PUSH
119786: LD_INT 0
119788: ST_TO_ADDR
// f_spacetime := false ;
119789: LD_ADDR_VAR 0 24
119793: PUSH
119794: LD_INT 0
119796: ST_TO_ADDR
// f_attack_depot := false ;
119797: LD_ADDR_VAR 0 25
119801: PUSH
119802: LD_INT 0
119804: ST_TO_ADDR
// f_crawl := false ;
119805: LD_ADDR_VAR 0 26
119809: PUSH
119810: LD_INT 0
119812: ST_TO_ADDR
// end ; if f_heal then
119813: LD_VAR 0 23
119817: IFFALSE 119844
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
119819: LD_ADDR_VAR 0 31
119823: PUSH
119824: LD_VAR 0 4
119828: PPUSH
119829: LD_INT 25
119831: PUSH
119832: LD_INT 4
119834: PUSH
119835: EMPTY
119836: LIST
119837: LIST
119838: PPUSH
119839: CALL_OW 72
119843: ST_TO_ADDR
// if f_repair then
119844: LD_VAR 0 22
119848: IFFALSE 119875
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
119850: LD_ADDR_VAR 0 33
119854: PUSH
119855: LD_VAR 0 4
119859: PPUSH
119860: LD_INT 25
119862: PUSH
119863: LD_INT 3
119865: PUSH
119866: EMPTY
119867: LIST
119868: LIST
119869: PPUSH
119870: CALL_OW 72
119874: ST_TO_ADDR
// units_path := [ ] ;
119875: LD_ADDR_VAR 0 16
119879: PUSH
119880: EMPTY
119881: ST_TO_ADDR
// for i = 1 to group do
119882: LD_ADDR_VAR 0 7
119886: PUSH
119887: DOUBLE
119888: LD_INT 1
119890: DEC
119891: ST_TO_ADDR
119892: LD_VAR 0 4
119896: PUSH
119897: FOR_TO
119898: IFFALSE 119927
// units_path := Replace ( units_path , i , path ) ;
119900: LD_ADDR_VAR 0 16
119904: PUSH
119905: LD_VAR 0 16
119909: PPUSH
119910: LD_VAR 0 7
119914: PPUSH
119915: LD_VAR 0 5
119919: PPUSH
119920: CALL_OW 1
119924: ST_TO_ADDR
119925: GO 119897
119927: POP
119928: POP
// repeat for i = group downto 1 do
119929: LD_ADDR_VAR 0 7
119933: PUSH
119934: DOUBLE
119935: LD_VAR 0 4
119939: INC
119940: ST_TO_ADDR
119941: LD_INT 1
119943: PUSH
119944: FOR_DOWNTO
119945: IFFALSE 124067
// begin wait ( 5 ) ;
119947: LD_INT 5
119949: PPUSH
119950: CALL_OW 67
// tmp := [ ] ;
119954: LD_ADDR_VAR 0 14
119958: PUSH
119959: EMPTY
119960: ST_TO_ADDR
// attacking := false ;
119961: LD_ADDR_VAR 0 29
119965: PUSH
119966: LD_INT 0
119968: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
119969: LD_VAR 0 4
119973: PUSH
119974: LD_VAR 0 7
119978: ARRAY
119979: PPUSH
119980: CALL_OW 301
119984: PUSH
119985: LD_VAR 0 4
119989: PUSH
119990: LD_VAR 0 7
119994: ARRAY
119995: NOT
119996: OR
119997: IFFALSE 120106
// begin if GetType ( group [ i ] ) = unit_human then
119999: LD_VAR 0 4
120003: PUSH
120004: LD_VAR 0 7
120008: ARRAY
120009: PPUSH
120010: CALL_OW 247
120014: PUSH
120015: LD_INT 1
120017: EQUAL
120018: IFFALSE 120064
// begin to_heal := to_heal diff group [ i ] ;
120020: LD_ADDR_VAR 0 30
120024: PUSH
120025: LD_VAR 0 30
120029: PUSH
120030: LD_VAR 0 4
120034: PUSH
120035: LD_VAR 0 7
120039: ARRAY
120040: DIFF
120041: ST_TO_ADDR
// healers := healers diff group [ i ] ;
120042: LD_ADDR_VAR 0 31
120046: PUSH
120047: LD_VAR 0 31
120051: PUSH
120052: LD_VAR 0 4
120056: PUSH
120057: LD_VAR 0 7
120061: ARRAY
120062: DIFF
120063: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
120064: LD_ADDR_VAR 0 4
120068: PUSH
120069: LD_VAR 0 4
120073: PPUSH
120074: LD_VAR 0 7
120078: PPUSH
120079: CALL_OW 3
120083: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
120084: LD_ADDR_VAR 0 16
120088: PUSH
120089: LD_VAR 0 16
120093: PPUSH
120094: LD_VAR 0 7
120098: PPUSH
120099: CALL_OW 3
120103: ST_TO_ADDR
// continue ;
120104: GO 119944
// end ; if f_repair then
120106: LD_VAR 0 22
120110: IFFALSE 120599
// begin if GetType ( group [ i ] ) = unit_vehicle then
120112: LD_VAR 0 4
120116: PUSH
120117: LD_VAR 0 7
120121: ARRAY
120122: PPUSH
120123: CALL_OW 247
120127: PUSH
120128: LD_INT 2
120130: EQUAL
120131: IFFALSE 120321
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
120133: LD_VAR 0 4
120137: PUSH
120138: LD_VAR 0 7
120142: ARRAY
120143: PPUSH
120144: CALL_OW 256
120148: PUSH
120149: LD_INT 700
120151: LESS
120152: PUSH
120153: LD_VAR 0 4
120157: PUSH
120158: LD_VAR 0 7
120162: ARRAY
120163: PUSH
120164: LD_VAR 0 32
120168: IN
120169: NOT
120170: AND
120171: IFFALSE 120195
// to_repair := to_repair union group [ i ] ;
120173: LD_ADDR_VAR 0 32
120177: PUSH
120178: LD_VAR 0 32
120182: PUSH
120183: LD_VAR 0 4
120187: PUSH
120188: LD_VAR 0 7
120192: ARRAY
120193: UNION
120194: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
120195: LD_VAR 0 4
120199: PUSH
120200: LD_VAR 0 7
120204: ARRAY
120205: PPUSH
120206: CALL_OW 256
120210: PUSH
120211: LD_INT 1000
120213: EQUAL
120214: PUSH
120215: LD_VAR 0 4
120219: PUSH
120220: LD_VAR 0 7
120224: ARRAY
120225: PUSH
120226: LD_VAR 0 32
120230: IN
120231: AND
120232: IFFALSE 120256
// to_repair := to_repair diff group [ i ] ;
120234: LD_ADDR_VAR 0 32
120238: PUSH
120239: LD_VAR 0 32
120243: PUSH
120244: LD_VAR 0 4
120248: PUSH
120249: LD_VAR 0 7
120253: ARRAY
120254: DIFF
120255: ST_TO_ADDR
// if group [ i ] in to_repair then
120256: LD_VAR 0 4
120260: PUSH
120261: LD_VAR 0 7
120265: ARRAY
120266: PUSH
120267: LD_VAR 0 32
120271: IN
120272: IFFALSE 120319
// begin if not IsInArea ( group [ i ] , f_repair ) then
120274: LD_VAR 0 4
120278: PUSH
120279: LD_VAR 0 7
120283: ARRAY
120284: PPUSH
120285: LD_VAR 0 22
120289: PPUSH
120290: CALL_OW 308
120294: NOT
120295: IFFALSE 120317
// ComMoveToArea ( group [ i ] , f_repair ) ;
120297: LD_VAR 0 4
120301: PUSH
120302: LD_VAR 0 7
120306: ARRAY
120307: PPUSH
120308: LD_VAR 0 22
120312: PPUSH
120313: CALL_OW 113
// continue ;
120317: GO 119944
// end ; end else
120319: GO 120599
// if group [ i ] in repairs then
120321: LD_VAR 0 4
120325: PUSH
120326: LD_VAR 0 7
120330: ARRAY
120331: PUSH
120332: LD_VAR 0 33
120336: IN
120337: IFFALSE 120599
// begin if IsInUnit ( group [ i ] ) then
120339: LD_VAR 0 4
120343: PUSH
120344: LD_VAR 0 7
120348: ARRAY
120349: PPUSH
120350: CALL_OW 310
120354: IFFALSE 120422
// begin z := IsInUnit ( group [ i ] ) ;
120356: LD_ADDR_VAR 0 13
120360: PUSH
120361: LD_VAR 0 4
120365: PUSH
120366: LD_VAR 0 7
120370: ARRAY
120371: PPUSH
120372: CALL_OW 310
120376: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
120377: LD_VAR 0 13
120381: PUSH
120382: LD_VAR 0 32
120386: IN
120387: PUSH
120388: LD_VAR 0 13
120392: PPUSH
120393: LD_VAR 0 22
120397: PPUSH
120398: CALL_OW 308
120402: AND
120403: IFFALSE 120420
// ComExitVehicle ( group [ i ] ) ;
120405: LD_VAR 0 4
120409: PUSH
120410: LD_VAR 0 7
120414: ARRAY
120415: PPUSH
120416: CALL_OW 121
// end else
120420: GO 120599
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
120422: LD_ADDR_VAR 0 13
120426: PUSH
120427: LD_VAR 0 4
120431: PPUSH
120432: LD_INT 95
120434: PUSH
120435: LD_VAR 0 22
120439: PUSH
120440: EMPTY
120441: LIST
120442: LIST
120443: PUSH
120444: LD_INT 58
120446: PUSH
120447: EMPTY
120448: LIST
120449: PUSH
120450: EMPTY
120451: LIST
120452: LIST
120453: PPUSH
120454: CALL_OW 72
120458: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
120459: LD_VAR 0 4
120463: PUSH
120464: LD_VAR 0 7
120468: ARRAY
120469: PPUSH
120470: CALL_OW 314
120474: NOT
120475: IFFALSE 120597
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
120477: LD_ADDR_VAR 0 10
120481: PUSH
120482: LD_VAR 0 13
120486: PPUSH
120487: LD_VAR 0 4
120491: PUSH
120492: LD_VAR 0 7
120496: ARRAY
120497: PPUSH
120498: CALL_OW 74
120502: ST_TO_ADDR
// if not x then
120503: LD_VAR 0 10
120507: NOT
120508: IFFALSE 120512
// continue ;
120510: GO 119944
// if GetLives ( x ) < 1000 then
120512: LD_VAR 0 10
120516: PPUSH
120517: CALL_OW 256
120521: PUSH
120522: LD_INT 1000
120524: LESS
120525: IFFALSE 120549
// ComRepairVehicle ( group [ i ] , x ) else
120527: LD_VAR 0 4
120531: PUSH
120532: LD_VAR 0 7
120536: ARRAY
120537: PPUSH
120538: LD_VAR 0 10
120542: PPUSH
120543: CALL_OW 129
120547: GO 120597
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
120549: LD_VAR 0 23
120553: PUSH
120554: LD_VAR 0 4
120558: PUSH
120559: LD_VAR 0 7
120563: ARRAY
120564: PPUSH
120565: CALL_OW 256
120569: PUSH
120570: LD_INT 1000
120572: LESS
120573: AND
120574: NOT
120575: IFFALSE 120597
// ComEnterUnit ( group [ i ] , x ) ;
120577: LD_VAR 0 4
120581: PUSH
120582: LD_VAR 0 7
120586: ARRAY
120587: PPUSH
120588: LD_VAR 0 10
120592: PPUSH
120593: CALL_OW 120
// end ; continue ;
120597: GO 119944
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
120599: LD_VAR 0 23
120603: PUSH
120604: LD_VAR 0 4
120608: PUSH
120609: LD_VAR 0 7
120613: ARRAY
120614: PPUSH
120615: CALL_OW 247
120619: PUSH
120620: LD_INT 1
120622: EQUAL
120623: AND
120624: IFFALSE 121102
// begin if group [ i ] in healers then
120626: LD_VAR 0 4
120630: PUSH
120631: LD_VAR 0 7
120635: ARRAY
120636: PUSH
120637: LD_VAR 0 31
120641: IN
120642: IFFALSE 120915
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
120644: LD_VAR 0 4
120648: PUSH
120649: LD_VAR 0 7
120653: ARRAY
120654: PPUSH
120655: LD_VAR 0 23
120659: PPUSH
120660: CALL_OW 308
120664: NOT
120665: PUSH
120666: LD_VAR 0 4
120670: PUSH
120671: LD_VAR 0 7
120675: ARRAY
120676: PPUSH
120677: CALL_OW 314
120681: NOT
120682: AND
120683: IFFALSE 120707
// ComMoveToArea ( group [ i ] , f_heal ) else
120685: LD_VAR 0 4
120689: PUSH
120690: LD_VAR 0 7
120694: ARRAY
120695: PPUSH
120696: LD_VAR 0 23
120700: PPUSH
120701: CALL_OW 113
120705: GO 120913
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
120707: LD_VAR 0 4
120711: PUSH
120712: LD_VAR 0 7
120716: ARRAY
120717: PPUSH
120718: CALL 98500 0 1
120722: PPUSH
120723: CALL_OW 256
120727: PUSH
120728: LD_INT 1000
120730: EQUAL
120731: IFFALSE 120750
// ComStop ( group [ i ] ) else
120733: LD_VAR 0 4
120737: PUSH
120738: LD_VAR 0 7
120742: ARRAY
120743: PPUSH
120744: CALL_OW 141
120748: GO 120913
// if not HasTask ( group [ i ] ) and to_heal then
120750: LD_VAR 0 4
120754: PUSH
120755: LD_VAR 0 7
120759: ARRAY
120760: PPUSH
120761: CALL_OW 314
120765: NOT
120766: PUSH
120767: LD_VAR 0 30
120771: AND
120772: IFFALSE 120913
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
120774: LD_ADDR_VAR 0 13
120778: PUSH
120779: LD_VAR 0 30
120783: PPUSH
120784: LD_INT 3
120786: PUSH
120787: LD_INT 54
120789: PUSH
120790: EMPTY
120791: LIST
120792: PUSH
120793: EMPTY
120794: LIST
120795: LIST
120796: PPUSH
120797: CALL_OW 72
120801: PPUSH
120802: LD_VAR 0 4
120806: PUSH
120807: LD_VAR 0 7
120811: ARRAY
120812: PPUSH
120813: CALL_OW 74
120817: ST_TO_ADDR
// if z then
120818: LD_VAR 0 13
120822: IFFALSE 120913
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
120824: LD_INT 91
120826: PUSH
120827: LD_VAR 0 13
120831: PUSH
120832: LD_INT 10
120834: PUSH
120835: EMPTY
120836: LIST
120837: LIST
120838: LIST
120839: PUSH
120840: LD_INT 81
120842: PUSH
120843: LD_VAR 0 13
120847: PPUSH
120848: CALL_OW 255
120852: PUSH
120853: EMPTY
120854: LIST
120855: LIST
120856: PUSH
120857: EMPTY
120858: LIST
120859: LIST
120860: PPUSH
120861: CALL_OW 69
120865: PUSH
120866: LD_INT 0
120868: EQUAL
120869: IFFALSE 120893
// ComHeal ( group [ i ] , z ) else
120871: LD_VAR 0 4
120875: PUSH
120876: LD_VAR 0 7
120880: ARRAY
120881: PPUSH
120882: LD_VAR 0 13
120886: PPUSH
120887: CALL_OW 128
120891: GO 120913
// ComMoveToArea ( group [ i ] , f_heal ) ;
120893: LD_VAR 0 4
120897: PUSH
120898: LD_VAR 0 7
120902: ARRAY
120903: PPUSH
120904: LD_VAR 0 23
120908: PPUSH
120909: CALL_OW 113
// end ; continue ;
120913: GO 119944
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
120915: LD_VAR 0 4
120919: PUSH
120920: LD_VAR 0 7
120924: ARRAY
120925: PPUSH
120926: CALL_OW 256
120930: PUSH
120931: LD_INT 700
120933: LESS
120934: PUSH
120935: LD_VAR 0 4
120939: PUSH
120940: LD_VAR 0 7
120944: ARRAY
120945: PUSH
120946: LD_VAR 0 30
120950: IN
120951: NOT
120952: AND
120953: IFFALSE 120977
// to_heal := to_heal union group [ i ] ;
120955: LD_ADDR_VAR 0 30
120959: PUSH
120960: LD_VAR 0 30
120964: PUSH
120965: LD_VAR 0 4
120969: PUSH
120970: LD_VAR 0 7
120974: ARRAY
120975: UNION
120976: ST_TO_ADDR
// if group [ i ] in to_heal then
120977: LD_VAR 0 4
120981: PUSH
120982: LD_VAR 0 7
120986: ARRAY
120987: PUSH
120988: LD_VAR 0 30
120992: IN
120993: IFFALSE 121102
// begin if GetLives ( group [ i ] ) = 1000 then
120995: LD_VAR 0 4
120999: PUSH
121000: LD_VAR 0 7
121004: ARRAY
121005: PPUSH
121006: CALL_OW 256
121010: PUSH
121011: LD_INT 1000
121013: EQUAL
121014: IFFALSE 121040
// to_heal := to_heal diff group [ i ] else
121016: LD_ADDR_VAR 0 30
121020: PUSH
121021: LD_VAR 0 30
121025: PUSH
121026: LD_VAR 0 4
121030: PUSH
121031: LD_VAR 0 7
121035: ARRAY
121036: DIFF
121037: ST_TO_ADDR
121038: GO 121102
// begin if not IsInArea ( group [ i ] , to_heal ) then
121040: LD_VAR 0 4
121044: PUSH
121045: LD_VAR 0 7
121049: ARRAY
121050: PPUSH
121051: LD_VAR 0 30
121055: PPUSH
121056: CALL_OW 308
121060: NOT
121061: IFFALSE 121085
// ComMoveToArea ( group [ i ] , f_heal ) else
121063: LD_VAR 0 4
121067: PUSH
121068: LD_VAR 0 7
121072: ARRAY
121073: PPUSH
121074: LD_VAR 0 23
121078: PPUSH
121079: CALL_OW 113
121083: GO 121100
// ComHold ( group [ i ] ) ;
121085: LD_VAR 0 4
121089: PUSH
121090: LD_VAR 0 7
121094: ARRAY
121095: PPUSH
121096: CALL_OW 140
// continue ;
121100: GO 119944
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
121102: LD_VAR 0 4
121106: PUSH
121107: LD_VAR 0 7
121111: ARRAY
121112: PPUSH
121113: LD_INT 10
121115: PPUSH
121116: CALL 96920 0 2
121120: NOT
121121: PUSH
121122: LD_VAR 0 16
121126: PUSH
121127: LD_VAR 0 7
121131: ARRAY
121132: PUSH
121133: EMPTY
121134: EQUAL
121135: NOT
121136: AND
121137: IFFALSE 121403
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
121139: LD_VAR 0 4
121143: PUSH
121144: LD_VAR 0 7
121148: ARRAY
121149: PPUSH
121150: CALL_OW 262
121154: PUSH
121155: LD_INT 1
121157: PUSH
121158: LD_INT 2
121160: PUSH
121161: EMPTY
121162: LIST
121163: LIST
121164: IN
121165: IFFALSE 121206
// if GetFuel ( group [ i ] ) < 10 then
121167: LD_VAR 0 4
121171: PUSH
121172: LD_VAR 0 7
121176: ARRAY
121177: PPUSH
121178: CALL_OW 261
121182: PUSH
121183: LD_INT 10
121185: LESS
121186: IFFALSE 121206
// SetFuel ( group [ i ] , 12 ) ;
121188: LD_VAR 0 4
121192: PUSH
121193: LD_VAR 0 7
121197: ARRAY
121198: PPUSH
121199: LD_INT 12
121201: PPUSH
121202: CALL_OW 240
// if units_path [ i ] then
121206: LD_VAR 0 16
121210: PUSH
121211: LD_VAR 0 7
121215: ARRAY
121216: IFFALSE 121401
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
121218: LD_VAR 0 4
121222: PUSH
121223: LD_VAR 0 7
121227: ARRAY
121228: PPUSH
121229: LD_VAR 0 16
121233: PUSH
121234: LD_VAR 0 7
121238: ARRAY
121239: PUSH
121240: LD_INT 1
121242: ARRAY
121243: PUSH
121244: LD_INT 1
121246: ARRAY
121247: PPUSH
121248: LD_VAR 0 16
121252: PUSH
121253: LD_VAR 0 7
121257: ARRAY
121258: PUSH
121259: LD_INT 1
121261: ARRAY
121262: PUSH
121263: LD_INT 2
121265: ARRAY
121266: PPUSH
121267: CALL_OW 297
121271: PUSH
121272: LD_INT 6
121274: GREATER
121275: IFFALSE 121350
// begin if not HasTask ( group [ i ] ) then
121277: LD_VAR 0 4
121281: PUSH
121282: LD_VAR 0 7
121286: ARRAY
121287: PPUSH
121288: CALL_OW 314
121292: NOT
121293: IFFALSE 121348
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
121295: LD_VAR 0 4
121299: PUSH
121300: LD_VAR 0 7
121304: ARRAY
121305: PPUSH
121306: LD_VAR 0 16
121310: PUSH
121311: LD_VAR 0 7
121315: ARRAY
121316: PUSH
121317: LD_INT 1
121319: ARRAY
121320: PUSH
121321: LD_INT 1
121323: ARRAY
121324: PPUSH
121325: LD_VAR 0 16
121329: PUSH
121330: LD_VAR 0 7
121334: ARRAY
121335: PUSH
121336: LD_INT 1
121338: ARRAY
121339: PUSH
121340: LD_INT 2
121342: ARRAY
121343: PPUSH
121344: CALL_OW 114
// end else
121348: GO 121401
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
121350: LD_ADDR_VAR 0 15
121354: PUSH
121355: LD_VAR 0 16
121359: PUSH
121360: LD_VAR 0 7
121364: ARRAY
121365: PPUSH
121366: LD_INT 1
121368: PPUSH
121369: CALL_OW 3
121373: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
121374: LD_ADDR_VAR 0 16
121378: PUSH
121379: LD_VAR 0 16
121383: PPUSH
121384: LD_VAR 0 7
121388: PPUSH
121389: LD_VAR 0 15
121393: PPUSH
121394: CALL_OW 1
121398: ST_TO_ADDR
// continue ;
121399: GO 119944
// end ; end ; end else
121401: GO 124065
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
121403: LD_ADDR_VAR 0 14
121407: PUSH
121408: LD_INT 81
121410: PUSH
121411: LD_VAR 0 4
121415: PUSH
121416: LD_VAR 0 7
121420: ARRAY
121421: PPUSH
121422: CALL_OW 255
121426: PUSH
121427: EMPTY
121428: LIST
121429: LIST
121430: PPUSH
121431: CALL_OW 69
121435: ST_TO_ADDR
// if not tmp then
121436: LD_VAR 0 14
121440: NOT
121441: IFFALSE 121445
// continue ;
121443: GO 119944
// if f_ignore_area then
121445: LD_VAR 0 17
121449: IFFALSE 121537
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
121451: LD_ADDR_VAR 0 15
121455: PUSH
121456: LD_VAR 0 14
121460: PPUSH
121461: LD_INT 3
121463: PUSH
121464: LD_INT 92
121466: PUSH
121467: LD_VAR 0 17
121471: PUSH
121472: LD_INT 1
121474: ARRAY
121475: PUSH
121476: LD_VAR 0 17
121480: PUSH
121481: LD_INT 2
121483: ARRAY
121484: PUSH
121485: LD_VAR 0 17
121489: PUSH
121490: LD_INT 3
121492: ARRAY
121493: PUSH
121494: EMPTY
121495: LIST
121496: LIST
121497: LIST
121498: LIST
121499: PUSH
121500: EMPTY
121501: LIST
121502: LIST
121503: PPUSH
121504: CALL_OW 72
121508: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
121509: LD_VAR 0 14
121513: PUSH
121514: LD_VAR 0 15
121518: DIFF
121519: IFFALSE 121537
// tmp := tmp diff tmp2 ;
121521: LD_ADDR_VAR 0 14
121525: PUSH
121526: LD_VAR 0 14
121530: PUSH
121531: LD_VAR 0 15
121535: DIFF
121536: ST_TO_ADDR
// end ; if not f_murder then
121537: LD_VAR 0 20
121541: NOT
121542: IFFALSE 121600
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
121544: LD_ADDR_VAR 0 15
121548: PUSH
121549: LD_VAR 0 14
121553: PPUSH
121554: LD_INT 3
121556: PUSH
121557: LD_INT 50
121559: PUSH
121560: EMPTY
121561: LIST
121562: PUSH
121563: EMPTY
121564: LIST
121565: LIST
121566: PPUSH
121567: CALL_OW 72
121571: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
121572: LD_VAR 0 14
121576: PUSH
121577: LD_VAR 0 15
121581: DIFF
121582: IFFALSE 121600
// tmp := tmp diff tmp2 ;
121584: LD_ADDR_VAR 0 14
121588: PUSH
121589: LD_VAR 0 14
121593: PUSH
121594: LD_VAR 0 15
121598: DIFF
121599: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
121600: LD_ADDR_VAR 0 14
121604: PUSH
121605: LD_VAR 0 4
121609: PUSH
121610: LD_VAR 0 7
121614: ARRAY
121615: PPUSH
121616: LD_VAR 0 14
121620: PPUSH
121621: LD_INT 1
121623: PPUSH
121624: LD_INT 1
121626: PPUSH
121627: CALL 70563 0 4
121631: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
121632: LD_VAR 0 4
121636: PUSH
121637: LD_VAR 0 7
121641: ARRAY
121642: PPUSH
121643: CALL_OW 257
121647: PUSH
121648: LD_INT 1
121650: EQUAL
121651: IFFALSE 122099
// begin if WantPlant ( group [ i ] ) then
121653: LD_VAR 0 4
121657: PUSH
121658: LD_VAR 0 7
121662: ARRAY
121663: PPUSH
121664: CALL 70064 0 1
121668: IFFALSE 121672
// continue ;
121670: GO 119944
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
121672: LD_VAR 0 18
121676: PUSH
121677: LD_VAR 0 4
121681: PUSH
121682: LD_VAR 0 7
121686: ARRAY
121687: PPUSH
121688: CALL_OW 310
121692: NOT
121693: AND
121694: PUSH
121695: LD_VAR 0 14
121699: PUSH
121700: LD_INT 1
121702: ARRAY
121703: PUSH
121704: LD_VAR 0 14
121708: PPUSH
121709: LD_INT 21
121711: PUSH
121712: LD_INT 2
121714: PUSH
121715: EMPTY
121716: LIST
121717: LIST
121718: PUSH
121719: LD_INT 58
121721: PUSH
121722: EMPTY
121723: LIST
121724: PUSH
121725: EMPTY
121726: LIST
121727: LIST
121728: PPUSH
121729: CALL_OW 72
121733: IN
121734: AND
121735: IFFALSE 121771
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
121737: LD_VAR 0 4
121741: PUSH
121742: LD_VAR 0 7
121746: ARRAY
121747: PPUSH
121748: LD_VAR 0 14
121752: PUSH
121753: LD_INT 1
121755: ARRAY
121756: PPUSH
121757: CALL_OW 120
// attacking := true ;
121761: LD_ADDR_VAR 0 29
121765: PUSH
121766: LD_INT 1
121768: ST_TO_ADDR
// continue ;
121769: GO 119944
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
121771: LD_VAR 0 26
121775: PUSH
121776: LD_VAR 0 4
121780: PUSH
121781: LD_VAR 0 7
121785: ARRAY
121786: PPUSH
121787: CALL_OW 257
121791: PUSH
121792: LD_INT 1
121794: EQUAL
121795: AND
121796: PUSH
121797: LD_VAR 0 4
121801: PUSH
121802: LD_VAR 0 7
121806: ARRAY
121807: PPUSH
121808: CALL_OW 256
121812: PUSH
121813: LD_INT 800
121815: LESS
121816: AND
121817: PUSH
121818: LD_VAR 0 4
121822: PUSH
121823: LD_VAR 0 7
121827: ARRAY
121828: PPUSH
121829: CALL_OW 318
121833: NOT
121834: AND
121835: IFFALSE 121852
// ComCrawl ( group [ i ] ) ;
121837: LD_VAR 0 4
121841: PUSH
121842: LD_VAR 0 7
121846: ARRAY
121847: PPUSH
121848: CALL_OW 137
// if f_mines then
121852: LD_VAR 0 21
121856: IFFALSE 122099
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
121858: LD_VAR 0 14
121862: PUSH
121863: LD_INT 1
121865: ARRAY
121866: PPUSH
121867: CALL_OW 247
121871: PUSH
121872: LD_INT 3
121874: EQUAL
121875: PUSH
121876: LD_VAR 0 14
121880: PUSH
121881: LD_INT 1
121883: ARRAY
121884: PUSH
121885: LD_VAR 0 27
121889: IN
121890: NOT
121891: AND
121892: IFFALSE 122099
// begin x := GetX ( tmp [ 1 ] ) ;
121894: LD_ADDR_VAR 0 10
121898: PUSH
121899: LD_VAR 0 14
121903: PUSH
121904: LD_INT 1
121906: ARRAY
121907: PPUSH
121908: CALL_OW 250
121912: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
121913: LD_ADDR_VAR 0 11
121917: PUSH
121918: LD_VAR 0 14
121922: PUSH
121923: LD_INT 1
121925: ARRAY
121926: PPUSH
121927: CALL_OW 251
121931: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
121932: LD_ADDR_VAR 0 12
121936: PUSH
121937: LD_VAR 0 4
121941: PUSH
121942: LD_VAR 0 7
121946: ARRAY
121947: PPUSH
121948: CALL 97005 0 1
121952: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
121953: LD_VAR 0 4
121957: PUSH
121958: LD_VAR 0 7
121962: ARRAY
121963: PPUSH
121964: LD_VAR 0 10
121968: PPUSH
121969: LD_VAR 0 11
121973: PPUSH
121974: LD_VAR 0 14
121978: PUSH
121979: LD_INT 1
121981: ARRAY
121982: PPUSH
121983: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
121987: LD_VAR 0 4
121991: PUSH
121992: LD_VAR 0 7
121996: ARRAY
121997: PPUSH
121998: LD_VAR 0 10
122002: PPUSH
122003: LD_VAR 0 12
122007: PPUSH
122008: LD_INT 7
122010: PPUSH
122011: CALL_OW 272
122015: PPUSH
122016: LD_VAR 0 11
122020: PPUSH
122021: LD_VAR 0 12
122025: PPUSH
122026: LD_INT 7
122028: PPUSH
122029: CALL_OW 273
122033: PPUSH
122034: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
122038: LD_VAR 0 4
122042: PUSH
122043: LD_VAR 0 7
122047: ARRAY
122048: PPUSH
122049: LD_INT 71
122051: PPUSH
122052: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
122056: LD_ADDR_VAR 0 27
122060: PUSH
122061: LD_VAR 0 27
122065: PPUSH
122066: LD_VAR 0 27
122070: PUSH
122071: LD_INT 1
122073: PLUS
122074: PPUSH
122075: LD_VAR 0 14
122079: PUSH
122080: LD_INT 1
122082: ARRAY
122083: PPUSH
122084: CALL_OW 1
122088: ST_TO_ADDR
// attacking := true ;
122089: LD_ADDR_VAR 0 29
122093: PUSH
122094: LD_INT 1
122096: ST_TO_ADDR
// continue ;
122097: GO 119944
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
122099: LD_VAR 0 4
122103: PUSH
122104: LD_VAR 0 7
122108: ARRAY
122109: PPUSH
122110: CALL_OW 257
122114: PUSH
122115: LD_INT 17
122117: EQUAL
122118: PUSH
122119: LD_VAR 0 4
122123: PUSH
122124: LD_VAR 0 7
122128: ARRAY
122129: PPUSH
122130: CALL_OW 110
122134: PUSH
122135: LD_INT 71
122137: EQUAL
122138: NOT
122139: AND
122140: IFFALSE 122286
// begin attacking := false ;
122142: LD_ADDR_VAR 0 29
122146: PUSH
122147: LD_INT 0
122149: ST_TO_ADDR
// k := 5 ;
122150: LD_ADDR_VAR 0 9
122154: PUSH
122155: LD_INT 5
122157: ST_TO_ADDR
// if tmp < k then
122158: LD_VAR 0 14
122162: PUSH
122163: LD_VAR 0 9
122167: LESS
122168: IFFALSE 122180
// k := tmp ;
122170: LD_ADDR_VAR 0 9
122174: PUSH
122175: LD_VAR 0 14
122179: ST_TO_ADDR
// for j = 1 to k do
122180: LD_ADDR_VAR 0 8
122184: PUSH
122185: DOUBLE
122186: LD_INT 1
122188: DEC
122189: ST_TO_ADDR
122190: LD_VAR 0 9
122194: PUSH
122195: FOR_TO
122196: IFFALSE 122284
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
122198: LD_VAR 0 14
122202: PUSH
122203: LD_VAR 0 8
122207: ARRAY
122208: PUSH
122209: LD_VAR 0 14
122213: PPUSH
122214: LD_INT 58
122216: PUSH
122217: EMPTY
122218: LIST
122219: PPUSH
122220: CALL_OW 72
122224: IN
122225: NOT
122226: IFFALSE 122282
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
122228: LD_VAR 0 4
122232: PUSH
122233: LD_VAR 0 7
122237: ARRAY
122238: PPUSH
122239: LD_VAR 0 14
122243: PUSH
122244: LD_VAR 0 8
122248: ARRAY
122249: PPUSH
122250: CALL_OW 115
// attacking := true ;
122254: LD_ADDR_VAR 0 29
122258: PUSH
122259: LD_INT 1
122261: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
122262: LD_VAR 0 4
122266: PUSH
122267: LD_VAR 0 7
122271: ARRAY
122272: PPUSH
122273: LD_INT 71
122275: PPUSH
122276: CALL_OW 109
// continue ;
122280: GO 122195
// end ; end ;
122282: GO 122195
122284: POP
122285: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
122286: LD_VAR 0 4
122290: PUSH
122291: LD_VAR 0 7
122295: ARRAY
122296: PPUSH
122297: CALL_OW 257
122301: PUSH
122302: LD_INT 8
122304: EQUAL
122305: PUSH
122306: LD_VAR 0 4
122310: PUSH
122311: LD_VAR 0 7
122315: ARRAY
122316: PPUSH
122317: CALL_OW 264
122321: PUSH
122322: LD_INT 28
122324: PUSH
122325: LD_INT 45
122327: PUSH
122328: LD_INT 7
122330: PUSH
122331: LD_INT 47
122333: PUSH
122334: EMPTY
122335: LIST
122336: LIST
122337: LIST
122338: LIST
122339: IN
122340: OR
122341: IFFALSE 122597
// begin attacking := false ;
122343: LD_ADDR_VAR 0 29
122347: PUSH
122348: LD_INT 0
122350: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
122351: LD_VAR 0 14
122355: PUSH
122356: LD_INT 1
122358: ARRAY
122359: PPUSH
122360: CALL_OW 266
122364: PUSH
122365: LD_INT 32
122367: PUSH
122368: LD_INT 31
122370: PUSH
122371: LD_INT 33
122373: PUSH
122374: LD_INT 4
122376: PUSH
122377: LD_INT 5
122379: PUSH
122380: EMPTY
122381: LIST
122382: LIST
122383: LIST
122384: LIST
122385: LIST
122386: IN
122387: IFFALSE 122573
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
122389: LD_ADDR_VAR 0 9
122393: PUSH
122394: LD_VAR 0 14
122398: PUSH
122399: LD_INT 1
122401: ARRAY
122402: PPUSH
122403: CALL_OW 266
122407: PPUSH
122408: LD_VAR 0 14
122412: PUSH
122413: LD_INT 1
122415: ARRAY
122416: PPUSH
122417: CALL_OW 250
122421: PPUSH
122422: LD_VAR 0 14
122426: PUSH
122427: LD_INT 1
122429: ARRAY
122430: PPUSH
122431: CALL_OW 251
122435: PPUSH
122436: LD_VAR 0 14
122440: PUSH
122441: LD_INT 1
122443: ARRAY
122444: PPUSH
122445: CALL_OW 254
122449: PPUSH
122450: LD_VAR 0 14
122454: PUSH
122455: LD_INT 1
122457: ARRAY
122458: PPUSH
122459: CALL_OW 248
122463: PPUSH
122464: LD_INT 0
122466: PPUSH
122467: CALL 78375 0 6
122471: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
122472: LD_ADDR_VAR 0 8
122476: PUSH
122477: LD_VAR 0 4
122481: PUSH
122482: LD_VAR 0 7
122486: ARRAY
122487: PPUSH
122488: LD_VAR 0 9
122492: PPUSH
122493: CALL 97045 0 2
122497: ST_TO_ADDR
// if j then
122498: LD_VAR 0 8
122502: IFFALSE 122571
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
122504: LD_VAR 0 8
122508: PUSH
122509: LD_INT 1
122511: ARRAY
122512: PPUSH
122513: LD_VAR 0 8
122517: PUSH
122518: LD_INT 2
122520: ARRAY
122521: PPUSH
122522: CALL_OW 488
122526: IFFALSE 122571
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
122528: LD_VAR 0 4
122532: PUSH
122533: LD_VAR 0 7
122537: ARRAY
122538: PPUSH
122539: LD_VAR 0 8
122543: PUSH
122544: LD_INT 1
122546: ARRAY
122547: PPUSH
122548: LD_VAR 0 8
122552: PUSH
122553: LD_INT 2
122555: ARRAY
122556: PPUSH
122557: CALL_OW 116
// attacking := true ;
122561: LD_ADDR_VAR 0 29
122565: PUSH
122566: LD_INT 1
122568: ST_TO_ADDR
// continue ;
122569: GO 119944
// end ; end else
122571: GO 122597
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
122573: LD_VAR 0 4
122577: PUSH
122578: LD_VAR 0 7
122582: ARRAY
122583: PPUSH
122584: LD_VAR 0 14
122588: PUSH
122589: LD_INT 1
122591: ARRAY
122592: PPUSH
122593: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
122597: LD_VAR 0 4
122601: PUSH
122602: LD_VAR 0 7
122606: ARRAY
122607: PPUSH
122608: CALL_OW 265
122612: PUSH
122613: LD_INT 11
122615: EQUAL
122616: IFFALSE 122894
// begin k := 10 ;
122618: LD_ADDR_VAR 0 9
122622: PUSH
122623: LD_INT 10
122625: ST_TO_ADDR
// x := 0 ;
122626: LD_ADDR_VAR 0 10
122630: PUSH
122631: LD_INT 0
122633: ST_TO_ADDR
// if tmp < k then
122634: LD_VAR 0 14
122638: PUSH
122639: LD_VAR 0 9
122643: LESS
122644: IFFALSE 122656
// k := tmp ;
122646: LD_ADDR_VAR 0 9
122650: PUSH
122651: LD_VAR 0 14
122655: ST_TO_ADDR
// for j = k downto 1 do
122656: LD_ADDR_VAR 0 8
122660: PUSH
122661: DOUBLE
122662: LD_VAR 0 9
122666: INC
122667: ST_TO_ADDR
122668: LD_INT 1
122670: PUSH
122671: FOR_DOWNTO
122672: IFFALSE 122747
// begin if GetType ( tmp [ j ] ) = unit_human then
122674: LD_VAR 0 14
122678: PUSH
122679: LD_VAR 0 8
122683: ARRAY
122684: PPUSH
122685: CALL_OW 247
122689: PUSH
122690: LD_INT 1
122692: EQUAL
122693: IFFALSE 122745
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
122695: LD_VAR 0 4
122699: PUSH
122700: LD_VAR 0 7
122704: ARRAY
122705: PPUSH
122706: LD_VAR 0 14
122710: PUSH
122711: LD_VAR 0 8
122715: ARRAY
122716: PPUSH
122717: CALL 97316 0 2
// x := tmp [ j ] ;
122721: LD_ADDR_VAR 0 10
122725: PUSH
122726: LD_VAR 0 14
122730: PUSH
122731: LD_VAR 0 8
122735: ARRAY
122736: ST_TO_ADDR
// attacking := true ;
122737: LD_ADDR_VAR 0 29
122741: PUSH
122742: LD_INT 1
122744: ST_TO_ADDR
// end ; end ;
122745: GO 122671
122747: POP
122748: POP
// if not x then
122749: LD_VAR 0 10
122753: NOT
122754: IFFALSE 122894
// begin attacking := true ;
122756: LD_ADDR_VAR 0 29
122760: PUSH
122761: LD_INT 1
122763: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
122764: LD_VAR 0 4
122768: PUSH
122769: LD_VAR 0 7
122773: ARRAY
122774: PPUSH
122775: CALL_OW 250
122779: PPUSH
122780: LD_VAR 0 4
122784: PUSH
122785: LD_VAR 0 7
122789: ARRAY
122790: PPUSH
122791: CALL_OW 251
122795: PPUSH
122796: CALL_OW 546
122800: PUSH
122801: LD_INT 2
122803: ARRAY
122804: PUSH
122805: LD_VAR 0 14
122809: PUSH
122810: LD_INT 1
122812: ARRAY
122813: PPUSH
122814: CALL_OW 250
122818: PPUSH
122819: LD_VAR 0 14
122823: PUSH
122824: LD_INT 1
122826: ARRAY
122827: PPUSH
122828: CALL_OW 251
122832: PPUSH
122833: CALL_OW 546
122837: PUSH
122838: LD_INT 2
122840: ARRAY
122841: EQUAL
122842: IFFALSE 122870
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
122844: LD_VAR 0 4
122848: PUSH
122849: LD_VAR 0 7
122853: ARRAY
122854: PPUSH
122855: LD_VAR 0 14
122859: PUSH
122860: LD_INT 1
122862: ARRAY
122863: PPUSH
122864: CALL 97316 0 2
122868: GO 122894
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
122870: LD_VAR 0 4
122874: PUSH
122875: LD_VAR 0 7
122879: ARRAY
122880: PPUSH
122881: LD_VAR 0 14
122885: PUSH
122886: LD_INT 1
122888: ARRAY
122889: PPUSH
122890: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
122894: LD_VAR 0 4
122898: PUSH
122899: LD_VAR 0 7
122903: ARRAY
122904: PPUSH
122905: CALL_OW 264
122909: PUSH
122910: LD_INT 29
122912: EQUAL
122913: IFFALSE 123279
// begin if WantsToAttack ( group [ i ] ) in bombed then
122915: LD_VAR 0 4
122919: PUSH
122920: LD_VAR 0 7
122924: ARRAY
122925: PPUSH
122926: CALL_OW 319
122930: PUSH
122931: LD_VAR 0 28
122935: IN
122936: IFFALSE 122940
// continue ;
122938: GO 119944
// k := 8 ;
122940: LD_ADDR_VAR 0 9
122944: PUSH
122945: LD_INT 8
122947: ST_TO_ADDR
// x := 0 ;
122948: LD_ADDR_VAR 0 10
122952: PUSH
122953: LD_INT 0
122955: ST_TO_ADDR
// if tmp < k then
122956: LD_VAR 0 14
122960: PUSH
122961: LD_VAR 0 9
122965: LESS
122966: IFFALSE 122978
// k := tmp ;
122968: LD_ADDR_VAR 0 9
122972: PUSH
122973: LD_VAR 0 14
122977: ST_TO_ADDR
// for j = 1 to k do
122978: LD_ADDR_VAR 0 8
122982: PUSH
122983: DOUBLE
122984: LD_INT 1
122986: DEC
122987: ST_TO_ADDR
122988: LD_VAR 0 9
122992: PUSH
122993: FOR_TO
122994: IFFALSE 123126
// begin if GetType ( tmp [ j ] ) = unit_building then
122996: LD_VAR 0 14
123000: PUSH
123001: LD_VAR 0 8
123005: ARRAY
123006: PPUSH
123007: CALL_OW 247
123011: PUSH
123012: LD_INT 3
123014: EQUAL
123015: IFFALSE 123124
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
123017: LD_VAR 0 14
123021: PUSH
123022: LD_VAR 0 8
123026: ARRAY
123027: PUSH
123028: LD_VAR 0 28
123032: IN
123033: NOT
123034: PUSH
123035: LD_VAR 0 14
123039: PUSH
123040: LD_VAR 0 8
123044: ARRAY
123045: PPUSH
123046: CALL_OW 313
123050: AND
123051: IFFALSE 123124
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
123053: LD_VAR 0 4
123057: PUSH
123058: LD_VAR 0 7
123062: ARRAY
123063: PPUSH
123064: LD_VAR 0 14
123068: PUSH
123069: LD_VAR 0 8
123073: ARRAY
123074: PPUSH
123075: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
123079: LD_ADDR_VAR 0 28
123083: PUSH
123084: LD_VAR 0 28
123088: PPUSH
123089: LD_VAR 0 28
123093: PUSH
123094: LD_INT 1
123096: PLUS
123097: PPUSH
123098: LD_VAR 0 14
123102: PUSH
123103: LD_VAR 0 8
123107: ARRAY
123108: PPUSH
123109: CALL_OW 1
123113: ST_TO_ADDR
// attacking := true ;
123114: LD_ADDR_VAR 0 29
123118: PUSH
123119: LD_INT 1
123121: ST_TO_ADDR
// break ;
123122: GO 123126
// end ; end ;
123124: GO 122993
123126: POP
123127: POP
// if not attacking and f_attack_depot then
123128: LD_VAR 0 29
123132: NOT
123133: PUSH
123134: LD_VAR 0 25
123138: AND
123139: IFFALSE 123234
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
123141: LD_ADDR_VAR 0 13
123145: PUSH
123146: LD_VAR 0 14
123150: PPUSH
123151: LD_INT 2
123153: PUSH
123154: LD_INT 30
123156: PUSH
123157: LD_INT 0
123159: PUSH
123160: EMPTY
123161: LIST
123162: LIST
123163: PUSH
123164: LD_INT 30
123166: PUSH
123167: LD_INT 1
123169: PUSH
123170: EMPTY
123171: LIST
123172: LIST
123173: PUSH
123174: EMPTY
123175: LIST
123176: LIST
123177: LIST
123178: PPUSH
123179: CALL_OW 72
123183: ST_TO_ADDR
// if z then
123184: LD_VAR 0 13
123188: IFFALSE 123234
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
123190: LD_VAR 0 4
123194: PUSH
123195: LD_VAR 0 7
123199: ARRAY
123200: PPUSH
123201: LD_VAR 0 13
123205: PPUSH
123206: LD_VAR 0 4
123210: PUSH
123211: LD_VAR 0 7
123215: ARRAY
123216: PPUSH
123217: CALL_OW 74
123221: PPUSH
123222: CALL_OW 115
// attacking := true ;
123226: LD_ADDR_VAR 0 29
123230: PUSH
123231: LD_INT 1
123233: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
123234: LD_VAR 0 4
123238: PUSH
123239: LD_VAR 0 7
123243: ARRAY
123244: PPUSH
123245: CALL_OW 256
123249: PUSH
123250: LD_INT 500
123252: LESS
123253: IFFALSE 123279
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
123255: LD_VAR 0 4
123259: PUSH
123260: LD_VAR 0 7
123264: ARRAY
123265: PPUSH
123266: LD_VAR 0 14
123270: PUSH
123271: LD_INT 1
123273: ARRAY
123274: PPUSH
123275: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
123279: LD_VAR 0 4
123283: PUSH
123284: LD_VAR 0 7
123288: ARRAY
123289: PPUSH
123290: CALL_OW 264
123294: PUSH
123295: LD_INT 49
123297: EQUAL
123298: IFFALSE 123419
// begin if not HasTask ( group [ i ] ) then
123300: LD_VAR 0 4
123304: PUSH
123305: LD_VAR 0 7
123309: ARRAY
123310: PPUSH
123311: CALL_OW 314
123315: NOT
123316: IFFALSE 123419
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
123318: LD_ADDR_VAR 0 9
123322: PUSH
123323: LD_INT 81
123325: PUSH
123326: LD_VAR 0 4
123330: PUSH
123331: LD_VAR 0 7
123335: ARRAY
123336: PPUSH
123337: CALL_OW 255
123341: PUSH
123342: EMPTY
123343: LIST
123344: LIST
123345: PPUSH
123346: CALL_OW 69
123350: PPUSH
123351: LD_VAR 0 4
123355: PUSH
123356: LD_VAR 0 7
123360: ARRAY
123361: PPUSH
123362: CALL_OW 74
123366: ST_TO_ADDR
// if k then
123367: LD_VAR 0 9
123371: IFFALSE 123419
// if GetDistUnits ( group [ i ] , k ) > 10 then
123373: LD_VAR 0 4
123377: PUSH
123378: LD_VAR 0 7
123382: ARRAY
123383: PPUSH
123384: LD_VAR 0 9
123388: PPUSH
123389: CALL_OW 296
123393: PUSH
123394: LD_INT 10
123396: GREATER
123397: IFFALSE 123419
// ComMoveUnit ( group [ i ] , k ) ;
123399: LD_VAR 0 4
123403: PUSH
123404: LD_VAR 0 7
123408: ARRAY
123409: PPUSH
123410: LD_VAR 0 9
123414: PPUSH
123415: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
123419: LD_VAR 0 4
123423: PUSH
123424: LD_VAR 0 7
123428: ARRAY
123429: PPUSH
123430: CALL_OW 256
123434: PUSH
123435: LD_INT 250
123437: LESS
123438: PUSH
123439: LD_VAR 0 4
123443: PUSH
123444: LD_VAR 0 7
123448: ARRAY
123449: PUSH
123450: LD_INT 21
123452: PUSH
123453: LD_INT 2
123455: PUSH
123456: EMPTY
123457: LIST
123458: LIST
123459: PUSH
123460: LD_INT 23
123462: PUSH
123463: LD_INT 2
123465: PUSH
123466: EMPTY
123467: LIST
123468: LIST
123469: PUSH
123470: EMPTY
123471: LIST
123472: LIST
123473: PPUSH
123474: CALL_OW 69
123478: IN
123479: AND
123480: IFFALSE 123605
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
123482: LD_ADDR_VAR 0 9
123486: PUSH
123487: LD_OWVAR 3
123491: PUSH
123492: LD_VAR 0 4
123496: PUSH
123497: LD_VAR 0 7
123501: ARRAY
123502: DIFF
123503: PPUSH
123504: LD_VAR 0 4
123508: PUSH
123509: LD_VAR 0 7
123513: ARRAY
123514: PPUSH
123515: CALL_OW 74
123519: ST_TO_ADDR
// if not k then
123520: LD_VAR 0 9
123524: NOT
123525: IFFALSE 123529
// continue ;
123527: GO 119944
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
123529: LD_VAR 0 9
123533: PUSH
123534: LD_INT 81
123536: PUSH
123537: LD_VAR 0 4
123541: PUSH
123542: LD_VAR 0 7
123546: ARRAY
123547: PPUSH
123548: CALL_OW 255
123552: PUSH
123553: EMPTY
123554: LIST
123555: LIST
123556: PPUSH
123557: CALL_OW 69
123561: IN
123562: PUSH
123563: LD_VAR 0 9
123567: PPUSH
123568: LD_VAR 0 4
123572: PUSH
123573: LD_VAR 0 7
123577: ARRAY
123578: PPUSH
123579: CALL_OW 296
123583: PUSH
123584: LD_INT 5
123586: LESS
123587: AND
123588: IFFALSE 123605
// ComAutodestruct ( group [ i ] ) ;
123590: LD_VAR 0 4
123594: PUSH
123595: LD_VAR 0 7
123599: ARRAY
123600: PPUSH
123601: CALL 97214 0 1
// end ; if f_attack_depot then
123605: LD_VAR 0 25
123609: IFFALSE 123721
// begin k := 6 ;
123611: LD_ADDR_VAR 0 9
123615: PUSH
123616: LD_INT 6
123618: ST_TO_ADDR
// if tmp < k then
123619: LD_VAR 0 14
123623: PUSH
123624: LD_VAR 0 9
123628: LESS
123629: IFFALSE 123641
// k := tmp ;
123631: LD_ADDR_VAR 0 9
123635: PUSH
123636: LD_VAR 0 14
123640: ST_TO_ADDR
// for j = 1 to k do
123641: LD_ADDR_VAR 0 8
123645: PUSH
123646: DOUBLE
123647: LD_INT 1
123649: DEC
123650: ST_TO_ADDR
123651: LD_VAR 0 9
123655: PUSH
123656: FOR_TO
123657: IFFALSE 123719
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
123659: LD_VAR 0 8
123663: PPUSH
123664: CALL_OW 266
123668: PUSH
123669: LD_INT 0
123671: PUSH
123672: LD_INT 1
123674: PUSH
123675: EMPTY
123676: LIST
123677: LIST
123678: IN
123679: IFFALSE 123717
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
123681: LD_VAR 0 4
123685: PUSH
123686: LD_VAR 0 7
123690: ARRAY
123691: PPUSH
123692: LD_VAR 0 14
123696: PUSH
123697: LD_VAR 0 8
123701: ARRAY
123702: PPUSH
123703: CALL_OW 115
// attacking := true ;
123707: LD_ADDR_VAR 0 29
123711: PUSH
123712: LD_INT 1
123714: ST_TO_ADDR
// break ;
123715: GO 123719
// end ;
123717: GO 123656
123719: POP
123720: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
123721: LD_VAR 0 4
123725: PUSH
123726: LD_VAR 0 7
123730: ARRAY
123731: PPUSH
123732: CALL_OW 302
123736: PUSH
123737: LD_VAR 0 29
123741: NOT
123742: AND
123743: IFFALSE 124065
// begin if GetTag ( group [ i ] ) = 71 then
123745: LD_VAR 0 4
123749: PUSH
123750: LD_VAR 0 7
123754: ARRAY
123755: PPUSH
123756: CALL_OW 110
123760: PUSH
123761: LD_INT 71
123763: EQUAL
123764: IFFALSE 123805
// begin if HasTask ( group [ i ] ) then
123766: LD_VAR 0 4
123770: PUSH
123771: LD_VAR 0 7
123775: ARRAY
123776: PPUSH
123777: CALL_OW 314
123781: IFFALSE 123787
// continue else
123783: GO 119944
123785: GO 123805
// SetTag ( group [ i ] , 0 ) ;
123787: LD_VAR 0 4
123791: PUSH
123792: LD_VAR 0 7
123796: ARRAY
123797: PPUSH
123798: LD_INT 0
123800: PPUSH
123801: CALL_OW 109
// end ; k := 8 ;
123805: LD_ADDR_VAR 0 9
123809: PUSH
123810: LD_INT 8
123812: ST_TO_ADDR
// x := 0 ;
123813: LD_ADDR_VAR 0 10
123817: PUSH
123818: LD_INT 0
123820: ST_TO_ADDR
// if tmp < k then
123821: LD_VAR 0 14
123825: PUSH
123826: LD_VAR 0 9
123830: LESS
123831: IFFALSE 123843
// k := tmp ;
123833: LD_ADDR_VAR 0 9
123837: PUSH
123838: LD_VAR 0 14
123842: ST_TO_ADDR
// for j = 1 to k do
123843: LD_ADDR_VAR 0 8
123847: PUSH
123848: DOUBLE
123849: LD_INT 1
123851: DEC
123852: ST_TO_ADDR
123853: LD_VAR 0 9
123857: PUSH
123858: FOR_TO
123859: IFFALSE 123957
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
123861: LD_VAR 0 14
123865: PUSH
123866: LD_VAR 0 8
123870: ARRAY
123871: PPUSH
123872: CALL_OW 247
123876: PUSH
123877: LD_INT 1
123879: EQUAL
123880: PUSH
123881: LD_VAR 0 14
123885: PUSH
123886: LD_VAR 0 8
123890: ARRAY
123891: PPUSH
123892: CALL_OW 256
123896: PUSH
123897: LD_INT 250
123899: LESS
123900: PUSH
123901: LD_VAR 0 20
123905: AND
123906: PUSH
123907: LD_VAR 0 20
123911: NOT
123912: PUSH
123913: LD_VAR 0 14
123917: PUSH
123918: LD_VAR 0 8
123922: ARRAY
123923: PPUSH
123924: CALL_OW 256
123928: PUSH
123929: LD_INT 250
123931: GREATEREQUAL
123932: AND
123933: OR
123934: AND
123935: IFFALSE 123955
// begin x := tmp [ j ] ;
123937: LD_ADDR_VAR 0 10
123941: PUSH
123942: LD_VAR 0 14
123946: PUSH
123947: LD_VAR 0 8
123951: ARRAY
123952: ST_TO_ADDR
// break ;
123953: GO 123957
// end ;
123955: GO 123858
123957: POP
123958: POP
// if x then
123959: LD_VAR 0 10
123963: IFFALSE 123987
// ComAttackUnit ( group [ i ] , x ) else
123965: LD_VAR 0 4
123969: PUSH
123970: LD_VAR 0 7
123974: ARRAY
123975: PPUSH
123976: LD_VAR 0 10
123980: PPUSH
123981: CALL_OW 115
123985: GO 124011
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
123987: LD_VAR 0 4
123991: PUSH
123992: LD_VAR 0 7
123996: ARRAY
123997: PPUSH
123998: LD_VAR 0 14
124002: PUSH
124003: LD_INT 1
124005: ARRAY
124006: PPUSH
124007: CALL_OW 115
// if not HasTask ( group [ i ] ) then
124011: LD_VAR 0 4
124015: PUSH
124016: LD_VAR 0 7
124020: ARRAY
124021: PPUSH
124022: CALL_OW 314
124026: NOT
124027: IFFALSE 124065
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
124029: LD_VAR 0 4
124033: PUSH
124034: LD_VAR 0 7
124038: ARRAY
124039: PPUSH
124040: LD_VAR 0 14
124044: PPUSH
124045: LD_VAR 0 4
124049: PUSH
124050: LD_VAR 0 7
124054: ARRAY
124055: PPUSH
124056: CALL_OW 74
124060: PPUSH
124061: CALL_OW 115
// end ; end ; end ;
124065: GO 119944
124067: POP
124068: POP
// wait ( 0 0$2 ) ;
124069: LD_INT 70
124071: PPUSH
124072: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
124076: LD_VAR 0 4
124080: NOT
124081: PUSH
124082: LD_VAR 0 4
124086: PUSH
124087: EMPTY
124088: EQUAL
124089: OR
124090: PUSH
124091: LD_INT 81
124093: PUSH
124094: LD_VAR 0 35
124098: PUSH
124099: EMPTY
124100: LIST
124101: LIST
124102: PPUSH
124103: CALL_OW 69
124107: NOT
124108: OR
124109: IFFALSE 119929
// end ;
124111: LD_VAR 0 2
124115: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
124116: LD_INT 0
124118: PPUSH
124119: PPUSH
124120: PPUSH
124121: PPUSH
124122: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
124123: LD_VAR 0 1
124127: NOT
124128: PUSH
124129: LD_EXP 113
124133: PUSH
124134: LD_VAR 0 1
124138: ARRAY
124139: NOT
124140: OR
124141: PUSH
124142: LD_VAR 0 2
124146: NOT
124147: OR
124148: PUSH
124149: LD_VAR 0 3
124153: NOT
124154: OR
124155: IFFALSE 124159
// exit ;
124157: GO 124672
// side := mc_sides [ base ] ;
124159: LD_ADDR_VAR 0 6
124163: PUSH
124164: LD_EXP 139
124168: PUSH
124169: LD_VAR 0 1
124173: ARRAY
124174: ST_TO_ADDR
// if not side then
124175: LD_VAR 0 6
124179: NOT
124180: IFFALSE 124184
// exit ;
124182: GO 124672
// for i in solds do
124184: LD_ADDR_VAR 0 7
124188: PUSH
124189: LD_VAR 0 2
124193: PUSH
124194: FOR_IN
124195: IFFALSE 124256
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
124197: LD_VAR 0 7
124201: PPUSH
124202: CALL_OW 310
124206: PPUSH
124207: CALL_OW 266
124211: PUSH
124212: LD_INT 32
124214: PUSH
124215: LD_INT 31
124217: PUSH
124218: EMPTY
124219: LIST
124220: LIST
124221: IN
124222: IFFALSE 124242
// solds := solds diff i else
124224: LD_ADDR_VAR 0 2
124228: PUSH
124229: LD_VAR 0 2
124233: PUSH
124234: LD_VAR 0 7
124238: DIFF
124239: ST_TO_ADDR
124240: GO 124254
// SetTag ( i , 18 ) ;
124242: LD_VAR 0 7
124246: PPUSH
124247: LD_INT 18
124249: PPUSH
124250: CALL_OW 109
124254: GO 124194
124256: POP
124257: POP
// if not solds then
124258: LD_VAR 0 2
124262: NOT
124263: IFFALSE 124267
// exit ;
124265: GO 124672
// repeat wait ( 0 0$1 ) ;
124267: LD_INT 35
124269: PPUSH
124270: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
124274: LD_ADDR_VAR 0 5
124278: PUSH
124279: LD_VAR 0 6
124283: PPUSH
124284: LD_VAR 0 3
124288: PPUSH
124289: CALL 66929 0 2
124293: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
124294: LD_EXP 113
124298: PUSH
124299: LD_VAR 0 1
124303: ARRAY
124304: NOT
124305: PUSH
124306: LD_EXP 113
124310: PUSH
124311: LD_VAR 0 1
124315: ARRAY
124316: PUSH
124317: EMPTY
124318: EQUAL
124319: OR
124320: IFFALSE 124357
// begin for i in solds do
124322: LD_ADDR_VAR 0 7
124326: PUSH
124327: LD_VAR 0 2
124331: PUSH
124332: FOR_IN
124333: IFFALSE 124346
// ComStop ( i ) ;
124335: LD_VAR 0 7
124339: PPUSH
124340: CALL_OW 141
124344: GO 124332
124346: POP
124347: POP
// solds := [ ] ;
124348: LD_ADDR_VAR 0 2
124352: PUSH
124353: EMPTY
124354: ST_TO_ADDR
// exit ;
124355: GO 124672
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
124357: LD_VAR 0 5
124361: NOT
124362: PUSH
124363: LD_VAR 0 5
124367: PUSH
124368: LD_INT 3
124370: GREATER
124371: OR
124372: PUSH
124373: LD_EXP 135
124377: PUSH
124378: LD_VAR 0 1
124382: ARRAY
124383: OR
124384: IFFALSE 124425
// begin for i in solds do
124386: LD_ADDR_VAR 0 7
124390: PUSH
124391: LD_VAR 0 2
124395: PUSH
124396: FOR_IN
124397: IFFALSE 124421
// if HasTask ( i ) then
124399: LD_VAR 0 7
124403: PPUSH
124404: CALL_OW 314
124408: IFFALSE 124419
// ComStop ( i ) ;
124410: LD_VAR 0 7
124414: PPUSH
124415: CALL_OW 141
124419: GO 124396
124421: POP
124422: POP
// break ;
124423: GO 124660
// end ; for i in solds do
124425: LD_ADDR_VAR 0 7
124429: PUSH
124430: LD_VAR 0 2
124434: PUSH
124435: FOR_IN
124436: IFFALSE 124652
// begin if IsInUnit ( i ) then
124438: LD_VAR 0 7
124442: PPUSH
124443: CALL_OW 310
124447: IFFALSE 124458
// ComExitBuilding ( i ) ;
124449: LD_VAR 0 7
124453: PPUSH
124454: CALL_OW 122
// if GetLives ( i ) > 333 then
124458: LD_VAR 0 7
124462: PPUSH
124463: CALL_OW 256
124467: PUSH
124468: LD_INT 333
124470: GREATER
124471: IFFALSE 124499
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
124473: LD_VAR 0 7
124477: PPUSH
124478: LD_VAR 0 5
124482: PPUSH
124483: LD_VAR 0 7
124487: PPUSH
124488: CALL_OW 74
124492: PPUSH
124493: CALL_OW 115
124497: GO 124650
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
124499: LD_ADDR_VAR 0 8
124503: PUSH
124504: LD_EXP 113
124508: PUSH
124509: LD_VAR 0 1
124513: ARRAY
124514: PPUSH
124515: LD_INT 2
124517: PUSH
124518: LD_INT 30
124520: PUSH
124521: LD_INT 0
124523: PUSH
124524: EMPTY
124525: LIST
124526: LIST
124527: PUSH
124528: LD_INT 30
124530: PUSH
124531: LD_INT 1
124533: PUSH
124534: EMPTY
124535: LIST
124536: LIST
124537: PUSH
124538: LD_INT 30
124540: PUSH
124541: LD_INT 6
124543: PUSH
124544: EMPTY
124545: LIST
124546: LIST
124547: PUSH
124548: EMPTY
124549: LIST
124550: LIST
124551: LIST
124552: LIST
124553: PPUSH
124554: CALL_OW 72
124558: PPUSH
124559: LD_VAR 0 7
124563: PPUSH
124564: CALL_OW 74
124568: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
124569: LD_VAR 0 7
124573: PPUSH
124574: LD_VAR 0 8
124578: PPUSH
124579: CALL_OW 250
124583: PPUSH
124584: LD_INT 3
124586: PPUSH
124587: LD_INT 5
124589: PPUSH
124590: CALL_OW 272
124594: PPUSH
124595: LD_VAR 0 8
124599: PPUSH
124600: CALL_OW 251
124604: PPUSH
124605: LD_INT 3
124607: PPUSH
124608: LD_INT 5
124610: PPUSH
124611: CALL_OW 273
124615: PPUSH
124616: CALL_OW 111
// SetTag ( i , 0 ) ;
124620: LD_VAR 0 7
124624: PPUSH
124625: LD_INT 0
124627: PPUSH
124628: CALL_OW 109
// solds := solds diff i ;
124632: LD_ADDR_VAR 0 2
124636: PUSH
124637: LD_VAR 0 2
124641: PUSH
124642: LD_VAR 0 7
124646: DIFF
124647: ST_TO_ADDR
// continue ;
124648: GO 124435
// end ; end ;
124650: GO 124435
124652: POP
124653: POP
// until solds ;
124654: LD_VAR 0 2
124658: IFFALSE 124267
// MC_Reset ( base , 18 ) ;
124660: LD_VAR 0 1
124664: PPUSH
124665: LD_INT 18
124667: PPUSH
124668: CALL 39192 0 2
// end ;
124672: LD_VAR 0 4
124676: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
124677: LD_INT 0
124679: PPUSH
124680: PPUSH
124681: PPUSH
124682: PPUSH
124683: PPUSH
124684: PPUSH
124685: PPUSH
124686: PPUSH
124687: PPUSH
124688: PPUSH
124689: PPUSH
124690: PPUSH
124691: PPUSH
124692: PPUSH
124693: PPUSH
124694: PPUSH
124695: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
124696: LD_ADDR_VAR 0 13
124700: PUSH
124701: LD_EXP 113
124705: PUSH
124706: LD_VAR 0 1
124710: ARRAY
124711: PPUSH
124712: LD_INT 25
124714: PUSH
124715: LD_INT 3
124717: PUSH
124718: EMPTY
124719: LIST
124720: LIST
124721: PPUSH
124722: CALL_OW 72
124726: ST_TO_ADDR
// if mc_remote_driver [ base ] then
124727: LD_EXP 153
124731: PUSH
124732: LD_VAR 0 1
124736: ARRAY
124737: IFFALSE 124761
// mechs := mechs diff mc_remote_driver [ base ] ;
124739: LD_ADDR_VAR 0 13
124743: PUSH
124744: LD_VAR 0 13
124748: PUSH
124749: LD_EXP 153
124753: PUSH
124754: LD_VAR 0 1
124758: ARRAY
124759: DIFF
124760: ST_TO_ADDR
// for i in mechs do
124761: LD_ADDR_VAR 0 5
124765: PUSH
124766: LD_VAR 0 13
124770: PUSH
124771: FOR_IN
124772: IFFALSE 124807
// if GetTag ( i ) > 0 then
124774: LD_VAR 0 5
124778: PPUSH
124779: CALL_OW 110
124783: PUSH
124784: LD_INT 0
124786: GREATER
124787: IFFALSE 124805
// mechs := mechs diff i ;
124789: LD_ADDR_VAR 0 13
124793: PUSH
124794: LD_VAR 0 13
124798: PUSH
124799: LD_VAR 0 5
124803: DIFF
124804: ST_TO_ADDR
124805: GO 124771
124807: POP
124808: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
124809: LD_ADDR_VAR 0 9
124813: PUSH
124814: LD_EXP 113
124818: PUSH
124819: LD_VAR 0 1
124823: ARRAY
124824: PPUSH
124825: LD_INT 2
124827: PUSH
124828: LD_INT 25
124830: PUSH
124831: LD_INT 1
124833: PUSH
124834: EMPTY
124835: LIST
124836: LIST
124837: PUSH
124838: LD_INT 25
124840: PUSH
124841: LD_INT 5
124843: PUSH
124844: EMPTY
124845: LIST
124846: LIST
124847: PUSH
124848: LD_INT 25
124850: PUSH
124851: LD_INT 8
124853: PUSH
124854: EMPTY
124855: LIST
124856: LIST
124857: PUSH
124858: LD_INT 25
124860: PUSH
124861: LD_INT 9
124863: PUSH
124864: EMPTY
124865: LIST
124866: LIST
124867: PUSH
124868: EMPTY
124869: LIST
124870: LIST
124871: LIST
124872: LIST
124873: LIST
124874: PPUSH
124875: CALL_OW 72
124879: ST_TO_ADDR
// if not defenders and not solds then
124880: LD_VAR 0 2
124884: NOT
124885: PUSH
124886: LD_VAR 0 9
124890: NOT
124891: AND
124892: IFFALSE 124896
// exit ;
124894: GO 126522
// depot_under_attack := false ;
124896: LD_ADDR_VAR 0 17
124900: PUSH
124901: LD_INT 0
124903: ST_TO_ADDR
// sold_defenders := [ ] ;
124904: LD_ADDR_VAR 0 18
124908: PUSH
124909: EMPTY
124910: ST_TO_ADDR
// if mechs then
124911: LD_VAR 0 13
124915: IFFALSE 125044
// for i in defenders do
124917: LD_ADDR_VAR 0 5
124921: PUSH
124922: LD_VAR 0 2
124926: PUSH
124927: FOR_IN
124928: IFFALSE 125042
// begin SetTag ( i , 20 ) ;
124930: LD_VAR 0 5
124934: PPUSH
124935: LD_INT 20
124937: PPUSH
124938: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
124942: LD_VAR 0 5
124946: PPUSH
124947: CALL_OW 263
124951: PUSH
124952: LD_INT 1
124954: EQUAL
124955: PUSH
124956: LD_VAR 0 5
124960: PPUSH
124961: CALL_OW 311
124965: NOT
124966: AND
124967: PUSH
124968: LD_VAR 0 13
124972: AND
124973: IFFALSE 125040
// begin un := mechs [ 1 ] ;
124975: LD_ADDR_VAR 0 11
124979: PUSH
124980: LD_VAR 0 13
124984: PUSH
124985: LD_INT 1
124987: ARRAY
124988: ST_TO_ADDR
// ComExitBuilding ( un ) ;
124989: LD_VAR 0 11
124993: PPUSH
124994: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
124998: LD_VAR 0 11
125002: PPUSH
125003: LD_VAR 0 5
125007: PPUSH
125008: CALL_OW 180
// SetTag ( un , 19 ) ;
125012: LD_VAR 0 11
125016: PPUSH
125017: LD_INT 19
125019: PPUSH
125020: CALL_OW 109
// mechs := mechs diff un ;
125024: LD_ADDR_VAR 0 13
125028: PUSH
125029: LD_VAR 0 13
125033: PUSH
125034: LD_VAR 0 11
125038: DIFF
125039: ST_TO_ADDR
// end ; end ;
125040: GO 124927
125042: POP
125043: POP
// if solds then
125044: LD_VAR 0 9
125048: IFFALSE 125107
// for i in solds do
125050: LD_ADDR_VAR 0 5
125054: PUSH
125055: LD_VAR 0 9
125059: PUSH
125060: FOR_IN
125061: IFFALSE 125105
// if not GetTag ( i ) then
125063: LD_VAR 0 5
125067: PPUSH
125068: CALL_OW 110
125072: NOT
125073: IFFALSE 125103
// begin defenders := defenders union i ;
125075: LD_ADDR_VAR 0 2
125079: PUSH
125080: LD_VAR 0 2
125084: PUSH
125085: LD_VAR 0 5
125089: UNION
125090: ST_TO_ADDR
// SetTag ( i , 18 ) ;
125091: LD_VAR 0 5
125095: PPUSH
125096: LD_INT 18
125098: PPUSH
125099: CALL_OW 109
// end ;
125103: GO 125060
125105: POP
125106: POP
// repeat wait ( 0 0$1 ) ;
125107: LD_INT 35
125109: PPUSH
125110: CALL_OW 67
// enemy := mc_scan [ base ] ;
125114: LD_ADDR_VAR 0 3
125118: PUSH
125119: LD_EXP 136
125123: PUSH
125124: LD_VAR 0 1
125128: ARRAY
125129: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
125130: LD_EXP 113
125134: PUSH
125135: LD_VAR 0 1
125139: ARRAY
125140: NOT
125141: PUSH
125142: LD_EXP 113
125146: PUSH
125147: LD_VAR 0 1
125151: ARRAY
125152: PUSH
125153: EMPTY
125154: EQUAL
125155: OR
125156: IFFALSE 125193
// begin for i in defenders do
125158: LD_ADDR_VAR 0 5
125162: PUSH
125163: LD_VAR 0 2
125167: PUSH
125168: FOR_IN
125169: IFFALSE 125182
// ComStop ( i ) ;
125171: LD_VAR 0 5
125175: PPUSH
125176: CALL_OW 141
125180: GO 125168
125182: POP
125183: POP
// defenders := [ ] ;
125184: LD_ADDR_VAR 0 2
125188: PUSH
125189: EMPTY
125190: ST_TO_ADDR
// exit ;
125191: GO 126522
// end ; for i in defenders do
125193: LD_ADDR_VAR 0 5
125197: PUSH
125198: LD_VAR 0 2
125202: PUSH
125203: FOR_IN
125204: IFFALSE 126022
// begin e := NearestUnitToUnit ( enemy , i ) ;
125206: LD_ADDR_VAR 0 14
125210: PUSH
125211: LD_VAR 0 3
125215: PPUSH
125216: LD_VAR 0 5
125220: PPUSH
125221: CALL_OW 74
125225: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
125226: LD_ADDR_VAR 0 8
125230: PUSH
125231: LD_EXP 113
125235: PUSH
125236: LD_VAR 0 1
125240: ARRAY
125241: PPUSH
125242: LD_INT 2
125244: PUSH
125245: LD_INT 30
125247: PUSH
125248: LD_INT 0
125250: PUSH
125251: EMPTY
125252: LIST
125253: LIST
125254: PUSH
125255: LD_INT 30
125257: PUSH
125258: LD_INT 1
125260: PUSH
125261: EMPTY
125262: LIST
125263: LIST
125264: PUSH
125265: EMPTY
125266: LIST
125267: LIST
125268: LIST
125269: PPUSH
125270: CALL_OW 72
125274: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
125275: LD_ADDR_VAR 0 17
125279: PUSH
125280: LD_VAR 0 8
125284: NOT
125285: PUSH
125286: LD_VAR 0 8
125290: PPUSH
125291: LD_INT 3
125293: PUSH
125294: LD_INT 24
125296: PUSH
125297: LD_INT 600
125299: PUSH
125300: EMPTY
125301: LIST
125302: LIST
125303: PUSH
125304: EMPTY
125305: LIST
125306: LIST
125307: PPUSH
125308: CALL_OW 72
125312: OR
125313: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
125314: LD_VAR 0 5
125318: PPUSH
125319: CALL_OW 247
125323: PUSH
125324: LD_INT 2
125326: DOUBLE
125327: EQUAL
125328: IFTRUE 125332
125330: GO 125728
125332: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
125333: LD_VAR 0 5
125337: PPUSH
125338: CALL_OW 256
125342: PUSH
125343: LD_INT 650
125345: GREATER
125346: PUSH
125347: LD_VAR 0 5
125351: PPUSH
125352: LD_VAR 0 14
125356: PPUSH
125357: CALL_OW 296
125361: PUSH
125362: LD_INT 40
125364: LESS
125365: PUSH
125366: LD_VAR 0 14
125370: PPUSH
125371: LD_EXP 138
125375: PUSH
125376: LD_VAR 0 1
125380: ARRAY
125381: PPUSH
125382: CALL_OW 308
125386: OR
125387: AND
125388: IFFALSE 125510
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
125390: LD_VAR 0 5
125394: PPUSH
125395: CALL_OW 262
125399: PUSH
125400: LD_INT 1
125402: EQUAL
125403: PUSH
125404: LD_VAR 0 5
125408: PPUSH
125409: CALL_OW 261
125413: PUSH
125414: LD_INT 30
125416: LESS
125417: AND
125418: PUSH
125419: LD_VAR 0 8
125423: AND
125424: IFFALSE 125494
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
125426: LD_VAR 0 5
125430: PPUSH
125431: LD_VAR 0 8
125435: PPUSH
125436: LD_VAR 0 5
125440: PPUSH
125441: CALL_OW 74
125445: PPUSH
125446: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
125450: LD_VAR 0 5
125454: PPUSH
125455: LD_VAR 0 8
125459: PPUSH
125460: LD_VAR 0 5
125464: PPUSH
125465: CALL_OW 74
125469: PPUSH
125470: CALL_OW 296
125474: PUSH
125475: LD_INT 6
125477: LESS
125478: IFFALSE 125492
// SetFuel ( i , 100 ) ;
125480: LD_VAR 0 5
125484: PPUSH
125485: LD_INT 100
125487: PPUSH
125488: CALL_OW 240
// end else
125492: GO 125508
// ComAttackUnit ( i , e ) ;
125494: LD_VAR 0 5
125498: PPUSH
125499: LD_VAR 0 14
125503: PPUSH
125504: CALL_OW 115
// end else
125508: GO 125611
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
125510: LD_VAR 0 14
125514: PPUSH
125515: LD_EXP 138
125519: PUSH
125520: LD_VAR 0 1
125524: ARRAY
125525: PPUSH
125526: CALL_OW 308
125530: NOT
125531: PUSH
125532: LD_VAR 0 5
125536: PPUSH
125537: LD_VAR 0 14
125541: PPUSH
125542: CALL_OW 296
125546: PUSH
125547: LD_INT 40
125549: GREATEREQUAL
125550: AND
125551: PUSH
125552: LD_VAR 0 5
125556: PPUSH
125557: CALL_OW 256
125561: PUSH
125562: LD_INT 650
125564: LESSEQUAL
125565: OR
125566: PUSH
125567: LD_VAR 0 5
125571: PPUSH
125572: LD_EXP 137
125576: PUSH
125577: LD_VAR 0 1
125581: ARRAY
125582: PPUSH
125583: CALL_OW 308
125587: NOT
125588: AND
125589: IFFALSE 125611
// ComMoveToArea ( i , mc_parking [ base ] ) ;
125591: LD_VAR 0 5
125595: PPUSH
125596: LD_EXP 137
125600: PUSH
125601: LD_VAR 0 1
125605: ARRAY
125606: PPUSH
125607: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
125611: LD_VAR 0 5
125615: PPUSH
125616: CALL_OW 256
125620: PUSH
125621: LD_INT 998
125623: LESS
125624: PUSH
125625: LD_VAR 0 5
125629: PPUSH
125630: CALL_OW 263
125634: PUSH
125635: LD_INT 1
125637: EQUAL
125638: AND
125639: PUSH
125640: LD_VAR 0 5
125644: PPUSH
125645: CALL_OW 311
125649: AND
125650: PUSH
125651: LD_VAR 0 5
125655: PPUSH
125656: LD_EXP 137
125660: PUSH
125661: LD_VAR 0 1
125665: ARRAY
125666: PPUSH
125667: CALL_OW 308
125671: AND
125672: IFFALSE 125726
// begin mech := IsDrivenBy ( i ) ;
125674: LD_ADDR_VAR 0 10
125678: PUSH
125679: LD_VAR 0 5
125683: PPUSH
125684: CALL_OW 311
125688: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
125689: LD_VAR 0 10
125693: PPUSH
125694: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
125698: LD_VAR 0 10
125702: PPUSH
125703: LD_VAR 0 5
125707: PPUSH
125708: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
125712: LD_VAR 0 10
125716: PPUSH
125717: LD_VAR 0 5
125721: PPUSH
125722: CALL_OW 180
// end ; end ; unit_human :
125726: GO 125993
125728: LD_INT 1
125730: DOUBLE
125731: EQUAL
125732: IFTRUE 125736
125734: GO 125992
125736: POP
// begin b := IsInUnit ( i ) ;
125737: LD_ADDR_VAR 0 19
125741: PUSH
125742: LD_VAR 0 5
125746: PPUSH
125747: CALL_OW 310
125751: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
125752: LD_ADDR_VAR 0 20
125756: PUSH
125757: LD_VAR 0 19
125761: NOT
125762: PUSH
125763: LD_VAR 0 19
125767: PPUSH
125768: CALL_OW 266
125772: PUSH
125773: LD_INT 32
125775: PUSH
125776: LD_INT 31
125778: PUSH
125779: EMPTY
125780: LIST
125781: LIST
125782: IN
125783: OR
125784: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
125785: LD_VAR 0 17
125789: PUSH
125790: LD_VAR 0 2
125794: PPUSH
125795: LD_INT 21
125797: PUSH
125798: LD_INT 2
125800: PUSH
125801: EMPTY
125802: LIST
125803: LIST
125804: PPUSH
125805: CALL_OW 72
125809: PUSH
125810: LD_INT 1
125812: LESSEQUAL
125813: OR
125814: PUSH
125815: LD_VAR 0 20
125819: AND
125820: PUSH
125821: LD_VAR 0 5
125825: PUSH
125826: LD_VAR 0 18
125830: IN
125831: NOT
125832: AND
125833: IFFALSE 125926
// begin if b then
125835: LD_VAR 0 19
125839: IFFALSE 125888
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
125841: LD_VAR 0 19
125845: PPUSH
125846: LD_VAR 0 3
125850: PPUSH
125851: LD_VAR 0 19
125855: PPUSH
125856: CALL_OW 74
125860: PPUSH
125861: CALL_OW 296
125865: PUSH
125866: LD_INT 10
125868: LESS
125869: PUSH
125870: LD_VAR 0 19
125874: PPUSH
125875: CALL_OW 461
125879: PUSH
125880: LD_INT 7
125882: NONEQUAL
125883: AND
125884: IFFALSE 125888
// continue ;
125886: GO 125203
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
125888: LD_ADDR_VAR 0 18
125892: PUSH
125893: LD_VAR 0 18
125897: PPUSH
125898: LD_VAR 0 18
125902: PUSH
125903: LD_INT 1
125905: PLUS
125906: PPUSH
125907: LD_VAR 0 5
125911: PPUSH
125912: CALL_OW 1
125916: ST_TO_ADDR
// ComExitBuilding ( i ) ;
125917: LD_VAR 0 5
125921: PPUSH
125922: CALL_OW 122
// end ; if sold_defenders then
125926: LD_VAR 0 18
125930: IFFALSE 125990
// if i in sold_defenders then
125932: LD_VAR 0 5
125936: PUSH
125937: LD_VAR 0 18
125941: IN
125942: IFFALSE 125990
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
125944: LD_VAR 0 5
125948: PPUSH
125949: CALL_OW 314
125953: NOT
125954: PUSH
125955: LD_VAR 0 5
125959: PPUSH
125960: LD_VAR 0 14
125964: PPUSH
125965: CALL_OW 296
125969: PUSH
125970: LD_INT 30
125972: LESS
125973: AND
125974: IFFALSE 125990
// ComAttackUnit ( i , e ) ;
125976: LD_VAR 0 5
125980: PPUSH
125981: LD_VAR 0 14
125985: PPUSH
125986: CALL_OW 115
// end ; end ; end ;
125990: GO 125993
125992: POP
// if IsDead ( i ) then
125993: LD_VAR 0 5
125997: PPUSH
125998: CALL_OW 301
126002: IFFALSE 126020
// defenders := defenders diff i ;
126004: LD_ADDR_VAR 0 2
126008: PUSH
126009: LD_VAR 0 2
126013: PUSH
126014: LD_VAR 0 5
126018: DIFF
126019: ST_TO_ADDR
// end ;
126020: GO 125203
126022: POP
126023: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
126024: LD_VAR 0 3
126028: NOT
126029: PUSH
126030: LD_VAR 0 2
126034: NOT
126035: OR
126036: PUSH
126037: LD_EXP 113
126041: PUSH
126042: LD_VAR 0 1
126046: ARRAY
126047: NOT
126048: OR
126049: IFFALSE 125107
// MC_Reset ( base , 18 ) ;
126051: LD_VAR 0 1
126055: PPUSH
126056: LD_INT 18
126058: PPUSH
126059: CALL 39192 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
126063: LD_ADDR_VAR 0 2
126067: PUSH
126068: LD_VAR 0 2
126072: PUSH
126073: LD_VAR 0 2
126077: PPUSH
126078: LD_INT 2
126080: PUSH
126081: LD_INT 25
126083: PUSH
126084: LD_INT 1
126086: PUSH
126087: EMPTY
126088: LIST
126089: LIST
126090: PUSH
126091: LD_INT 25
126093: PUSH
126094: LD_INT 5
126096: PUSH
126097: EMPTY
126098: LIST
126099: LIST
126100: PUSH
126101: LD_INT 25
126103: PUSH
126104: LD_INT 8
126106: PUSH
126107: EMPTY
126108: LIST
126109: LIST
126110: PUSH
126111: LD_INT 25
126113: PUSH
126114: LD_INT 9
126116: PUSH
126117: EMPTY
126118: LIST
126119: LIST
126120: PUSH
126121: EMPTY
126122: LIST
126123: LIST
126124: LIST
126125: LIST
126126: LIST
126127: PPUSH
126128: CALL_OW 72
126132: DIFF
126133: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
126134: LD_VAR 0 3
126138: NOT
126139: PUSH
126140: LD_VAR 0 2
126144: PPUSH
126145: LD_INT 21
126147: PUSH
126148: LD_INT 2
126150: PUSH
126151: EMPTY
126152: LIST
126153: LIST
126154: PPUSH
126155: CALL_OW 72
126159: AND
126160: IFFALSE 126498
// begin tmp := FilterByTag ( defenders , 19 ) ;
126162: LD_ADDR_VAR 0 12
126166: PUSH
126167: LD_VAR 0 2
126171: PPUSH
126172: LD_INT 19
126174: PPUSH
126175: CALL 98689 0 2
126179: ST_TO_ADDR
// if tmp then
126180: LD_VAR 0 12
126184: IFFALSE 126254
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
126186: LD_ADDR_VAR 0 12
126190: PUSH
126191: LD_VAR 0 12
126195: PPUSH
126196: LD_INT 25
126198: PUSH
126199: LD_INT 3
126201: PUSH
126202: EMPTY
126203: LIST
126204: LIST
126205: PPUSH
126206: CALL_OW 72
126210: ST_TO_ADDR
// if tmp then
126211: LD_VAR 0 12
126215: IFFALSE 126254
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
126217: LD_ADDR_EXP 125
126221: PUSH
126222: LD_EXP 125
126226: PPUSH
126227: LD_VAR 0 1
126231: PPUSH
126232: LD_EXP 125
126236: PUSH
126237: LD_VAR 0 1
126241: ARRAY
126242: PUSH
126243: LD_VAR 0 12
126247: UNION
126248: PPUSH
126249: CALL_OW 1
126253: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
126254: LD_VAR 0 1
126258: PPUSH
126259: LD_INT 19
126261: PPUSH
126262: CALL 39192 0 2
// repeat wait ( 0 0$1 ) ;
126266: LD_INT 35
126268: PPUSH
126269: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
126273: LD_EXP 113
126277: PUSH
126278: LD_VAR 0 1
126282: ARRAY
126283: NOT
126284: PUSH
126285: LD_EXP 113
126289: PUSH
126290: LD_VAR 0 1
126294: ARRAY
126295: PUSH
126296: EMPTY
126297: EQUAL
126298: OR
126299: IFFALSE 126336
// begin for i in defenders do
126301: LD_ADDR_VAR 0 5
126305: PUSH
126306: LD_VAR 0 2
126310: PUSH
126311: FOR_IN
126312: IFFALSE 126325
// ComStop ( i ) ;
126314: LD_VAR 0 5
126318: PPUSH
126319: CALL_OW 141
126323: GO 126311
126325: POP
126326: POP
// defenders := [ ] ;
126327: LD_ADDR_VAR 0 2
126331: PUSH
126332: EMPTY
126333: ST_TO_ADDR
// exit ;
126334: GO 126522
// end ; for i in defenders do
126336: LD_ADDR_VAR 0 5
126340: PUSH
126341: LD_VAR 0 2
126345: PUSH
126346: FOR_IN
126347: IFFALSE 126436
// begin if not IsInArea ( i , mc_parking [ base ] ) then
126349: LD_VAR 0 5
126353: PPUSH
126354: LD_EXP 137
126358: PUSH
126359: LD_VAR 0 1
126363: ARRAY
126364: PPUSH
126365: CALL_OW 308
126369: NOT
126370: IFFALSE 126394
// ComMoveToArea ( i , mc_parking [ base ] ) else
126372: LD_VAR 0 5
126376: PPUSH
126377: LD_EXP 137
126381: PUSH
126382: LD_VAR 0 1
126386: ARRAY
126387: PPUSH
126388: CALL_OW 113
126392: GO 126434
// if GetControl ( i ) = control_manual then
126394: LD_VAR 0 5
126398: PPUSH
126399: CALL_OW 263
126403: PUSH
126404: LD_INT 1
126406: EQUAL
126407: IFFALSE 126434
// if IsDrivenBy ( i ) then
126409: LD_VAR 0 5
126413: PPUSH
126414: CALL_OW 311
126418: IFFALSE 126434
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
126420: LD_VAR 0 5
126424: PPUSH
126425: CALL_OW 311
126429: PPUSH
126430: CALL_OW 121
// end ;
126434: GO 126346
126436: POP
126437: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
126438: LD_VAR 0 2
126442: PPUSH
126443: LD_INT 95
126445: PUSH
126446: LD_EXP 137
126450: PUSH
126451: LD_VAR 0 1
126455: ARRAY
126456: PUSH
126457: EMPTY
126458: LIST
126459: LIST
126460: PPUSH
126461: CALL_OW 72
126465: PUSH
126466: LD_VAR 0 2
126470: EQUAL
126471: PUSH
126472: LD_EXP 136
126476: PUSH
126477: LD_VAR 0 1
126481: ARRAY
126482: OR
126483: PUSH
126484: LD_EXP 113
126488: PUSH
126489: LD_VAR 0 1
126493: ARRAY
126494: NOT
126495: OR
126496: IFFALSE 126266
// end ; MC_Reset ( base , 19 ) ;
126498: LD_VAR 0 1
126502: PPUSH
126503: LD_INT 19
126505: PPUSH
126506: CALL 39192 0 2
// MC_Reset ( base , 20 ) ;
126510: LD_VAR 0 1
126514: PPUSH
126515: LD_INT 20
126517: PPUSH
126518: CALL 39192 0 2
// end ; end_of_file
126522: LD_VAR 0 4
126526: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
126527: LD_VAR 0 1
126531: PUSH
126532: LD_INT 200
126534: DOUBLE
126535: GREATEREQUAL
126536: IFFALSE 126544
126538: LD_INT 299
126540: DOUBLE
126541: LESSEQUAL
126542: IFTRUE 126546
126544: GO 126578
126546: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
126547: LD_VAR 0 1
126551: PPUSH
126552: LD_VAR 0 2
126556: PPUSH
126557: LD_VAR 0 3
126561: PPUSH
126562: LD_VAR 0 4
126566: PPUSH
126567: LD_VAR 0 5
126571: PPUSH
126572: CALL 115532 0 5
126576: GO 126655
126578: LD_INT 300
126580: DOUBLE
126581: GREATEREQUAL
126582: IFFALSE 126590
126584: LD_INT 399
126586: DOUBLE
126587: LESSEQUAL
126588: IFTRUE 126592
126590: GO 126654
126592: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
126593: LD_VAR 0 1
126597: PPUSH
126598: LD_VAR 0 2
126602: PPUSH
126603: LD_VAR 0 3
126607: PPUSH
126608: LD_VAR 0 4
126612: PPUSH
126613: LD_VAR 0 5
126617: PPUSH
126618: LD_VAR 0 6
126622: PPUSH
126623: LD_VAR 0 7
126627: PPUSH
126628: LD_VAR 0 8
126632: PPUSH
126633: LD_VAR 0 9
126637: PPUSH
126638: LD_VAR 0 10
126642: PPUSH
126643: LD_VAR 0 11
126647: PPUSH
126648: CALL 113438 0 11
126652: GO 126655
126654: POP
// end ;
126655: PPOPN 11
126657: END
