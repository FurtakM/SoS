// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 37280 0 0
// InitNature ;
  19: CALL 37148 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 12055 0 0
// PrepareRussian ;
  40: CALL 7197 0 0
// PrepareLegion ;
  44: CALL 4352 0 0
// PreparePowell ;
  48: CALL 3056 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 16262 0 0
// MC_Start ( ) ;
  60: CALL 39460 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 124
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 125
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 62242 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 62335 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 61685 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 3
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 3
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 61500 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 62242 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 62335 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 61500 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 61685 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 62115 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 61163 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 62242 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 62335 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 129
 971: PUSH
 972: LD_EXP 129
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 61500 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 62242 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 62335 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 61392 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 62653 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 61824 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 62115 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 62115 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 62447 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 61500 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 62066 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker , Mike ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 67974 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1900
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 72814 0 5
1898: GO 1959
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1900: LD_EXP 4
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 1
1911: ARRAY
1912: PPUSH
1913: LD_EXP 4
1917: PUSH
1918: LD_INT 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_EXP 4
1930: PUSH
1931: LD_INT 3
1933: ARRAY
1934: PUSH
1935: LD_INT 1
1937: ARRAY
1938: PPUSH
1939: LD_EXP 4
1943: PUSH
1944: LD_INT 4
1946: ARRAY
1947: PUSH
1948: LD_INT 1
1950: ARRAY
1951: PPUSH
1952: LD_INT 30
1954: PPUSH
1955: CALL 72814 0 5
// JMMNewVeh := CreateVehicle ;
1959: LD_ADDR_EXP 58
1963: PUSH
1964: CALL_OW 45
1968: ST_TO_ADDR
// if not JMMNewVeh then
1969: LD_EXP 58
1973: NOT
1974: IFFALSE 2005
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1976: LD_INT 5
1978: PPUSH
1979: LD_INT 3
1981: PPUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 9
1987: PPUSH
1988: LD_INT 100
1990: PPUSH
1991: CALL 72814 0 5
// JMMNewVeh := CreateVehicle ;
1995: LD_ADDR_EXP 58
1999: PUSH
2000: CALL_OW 45
2004: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2005: LD_EXP 58
2009: PPUSH
2010: LD_INT 4
2012: PPUSH
2013: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2017: LD_EXP 58
2021: PPUSH
2022: LD_INT 79
2024: PPUSH
2025: LD_INT 91
2027: PPUSH
2028: LD_INT 0
2030: PPUSH
2031: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2035: LD_EXP 40
2039: PPUSH
2040: LD_EXP 58
2044: PPUSH
2045: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2049: LD_EXP 6
2053: PUSH
2054: LD_EXP 2
2058: NOT
2059: AND
2060: IFFALSE 2318
// begin if not JMMGirlVeh then
2062: LD_EXP 5
2066: NOT
2067: IFFALSE 2090
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2069: LD_INT 3
2071: PPUSH
2072: LD_INT 3
2074: PPUSH
2075: LD_INT 1
2077: PPUSH
2078: LD_INT 9
2080: PPUSH
2081: LD_INT 100
2083: PPUSH
2084: CALL 72814 0 5
2088: GO 2149
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2090: LD_EXP 5
2094: PUSH
2095: LD_INT 1
2097: ARRAY
2098: PUSH
2099: LD_INT 1
2101: ARRAY
2102: PPUSH
2103: LD_EXP 5
2107: PUSH
2108: LD_INT 2
2110: ARRAY
2111: PUSH
2112: LD_INT 1
2114: ARRAY
2115: PPUSH
2116: LD_EXP 5
2120: PUSH
2121: LD_INT 3
2123: ARRAY
2124: PUSH
2125: LD_INT 1
2127: ARRAY
2128: PPUSH
2129: LD_EXP 5
2133: PUSH
2134: LD_INT 4
2136: ARRAY
2137: PUSH
2138: LD_INT 1
2140: ARRAY
2141: PPUSH
2142: LD_INT 30
2144: PPUSH
2145: CALL 72814 0 5
// GirlNewVeh := CreateVehicle ;
2149: LD_ADDR_EXP 59
2153: PUSH
2154: CALL_OW 45
2158: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2159: LD_EXP 59
2163: PPUSH
2164: LD_INT 4
2166: PPUSH
2167: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2171: LD_EXP 59
2175: PPUSH
2176: LD_INT 82
2178: PPUSH
2179: LD_INT 96
2181: PPUSH
2182: LD_INT 0
2184: PPUSH
2185: CALL_OW 48
// if JMMGirl = 1 then
2189: LD_EXP 7
2193: PUSH
2194: LD_INT 1
2196: EQUAL
2197: IFFALSE 2232
// begin Joan := PrepareUnit ( Joan , true , 14_ ) ;
2199: LD_ADDR_EXP 41
2203: PUSH
2204: LD_STRING Joan
2206: PPUSH
2207: LD_INT 1
2209: PPUSH
2210: LD_STRING 14_
2212: PPUSH
2213: CALL 67974 0 3
2217: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2218: LD_EXP 41
2222: PPUSH
2223: LD_EXP 59
2227: PPUSH
2228: CALL_OW 52
// end ; if JMMGirl = 2 then
2232: LD_EXP 7
2236: PUSH
2237: LD_INT 2
2239: EQUAL
2240: IFFALSE 2275
// begin Lisa := PrepareUnit ( Lisa , true , 14_ ) ;
2242: LD_ADDR_EXP 43
2246: PUSH
2247: LD_STRING Lisa
2249: PPUSH
2250: LD_INT 1
2252: PPUSH
2253: LD_STRING 14_
2255: PPUSH
2256: CALL 67974 0 3
2260: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2261: LD_EXP 43
2265: PPUSH
2266: LD_EXP 59
2270: PPUSH
2271: CALL_OW 52
// end ; if JMMGirl = 3 then
2275: LD_EXP 7
2279: PUSH
2280: LD_INT 3
2282: EQUAL
2283: IFFALSE 2318
// begin Connie := PrepareUnit ( Connie , true , 14_ ) ;
2285: LD_ADDR_EXP 55
2289: PUSH
2290: LD_STRING Connie
2292: PPUSH
2293: LD_INT 1
2295: PPUSH
2296: LD_STRING 14_
2298: PPUSH
2299: CALL 67974 0 3
2303: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2304: LD_EXP 55
2308: PPUSH
2309: LD_EXP 59
2313: PPUSH
2314: CALL_OW 52
// end ; end ; end ;
2318: LD_VAR 0 1
2322: RET
// export function PrepareStevensSquad ; var tmp ; begin
2323: LD_INT 0
2325: PPUSH
2326: PPUSH
// uc_side := 1 ;
2327: LD_ADDR_OWVAR 20
2331: PUSH
2332: LD_INT 1
2334: ST_TO_ADDR
// uc_nation := 1 ;
2335: LD_ADDR_OWVAR 21
2339: PUSH
2340: LD_INT 1
2342: ST_TO_ADDR
// tmp := [ ] ;
2343: LD_ADDR_VAR 0 2
2347: PUSH
2348: EMPTY
2349: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2350: LD_ADDR_EXP 42
2354: PUSH
2355: LD_STRING Stevens
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13f_
2366: PPUSH
2367: CALL 67974 0 3
2371: ST_TO_ADDR
// if not Stevens then
2372: LD_EXP 42
2376: NOT
2377: IFFALSE 2445
// begin hc_name = Baker Smith ;
2379: LD_ADDR_OWVAR 26
2383: PUSH
2384: LD_STRING Baker Smith
2386: ST_TO_ADDR
// hc_gallery = us ;
2387: LD_ADDR_OWVAR 33
2391: PUSH
2392: LD_STRING us
2394: ST_TO_ADDR
// hc_face_number := 29 ;
2395: LD_ADDR_OWVAR 34
2399: PUSH
2400: LD_INT 29
2402: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2403: LD_INT 1
2405: PPUSH
2406: LD_INT 10
2408: PPUSH
2409: CALL_OW 384
// Baker = CreateHuman ;
2413: LD_ADDR_EXP 56
2417: PUSH
2418: CALL_OW 44
2422: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2423: LD_ADDR_VAR 0 2
2427: PUSH
2428: LD_VAR 0 2
2432: PUSH
2433: LD_EXP 56
2437: ADD
2438: ST_TO_ADDR
// InitHc ;
2439: CALL_OW 19
// end else
2443: GO 2461
// tmp := tmp ^ Stevens ;
2445: LD_ADDR_VAR 0 2
2449: PUSH
2450: LD_VAR 0 2
2454: PUSH
2455: LD_EXP 42
2459: ADD
2460: ST_TO_ADDR
// if not Lisa then
2461: LD_EXP 43
2465: NOT
2466: IFFALSE 2512
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2468: LD_ADDR_EXP 43
2472: PUSH
2473: LD_STRING Lisa
2475: PPUSH
2476: LD_EXP 1
2480: NOT
2481: PPUSH
2482: LD_STRING 13f_
2484: PPUSH
2485: CALL 67974 0 3
2489: ST_TO_ADDR
// if Lisa then
2490: LD_EXP 43
2494: IFFALSE 2512
// tmp := tmp ^ Lisa ;
2496: LD_ADDR_VAR 0 2
2500: PUSH
2501: LD_VAR 0 2
2505: PUSH
2506: LD_EXP 43
2510: ADD
2511: ST_TO_ADDR
// end ; if not Donaldson then
2512: LD_EXP 44
2516: NOT
2517: IFFALSE 2563
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2519: LD_ADDR_EXP 44
2523: PUSH
2524: LD_STRING Donaldson
2526: PPUSH
2527: LD_EXP 1
2531: NOT
2532: PPUSH
2533: LD_STRING 13f_
2535: PPUSH
2536: CALL 67974 0 3
2540: ST_TO_ADDR
// if Donaldson then
2541: LD_EXP 44
2545: IFFALSE 2563
// tmp := tmp ^ Donaldson ;
2547: LD_ADDR_VAR 0 2
2551: PUSH
2552: LD_VAR 0 2
2556: PUSH
2557: LD_EXP 44
2561: ADD
2562: ST_TO_ADDR
// end ; if not Bobby then
2563: LD_EXP 45
2567: NOT
2568: IFFALSE 2614
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2570: LD_ADDR_EXP 45
2574: PUSH
2575: LD_STRING Bobby
2577: PPUSH
2578: LD_EXP 1
2582: NOT
2583: PPUSH
2584: LD_STRING 13f_
2586: PPUSH
2587: CALL 67974 0 3
2591: ST_TO_ADDR
// if Bobby then
2592: LD_EXP 45
2596: IFFALSE 2614
// tmp := tmp ^ Bobby ;
2598: LD_ADDR_VAR 0 2
2602: PUSH
2603: LD_VAR 0 2
2607: PUSH
2608: LD_EXP 45
2612: ADD
2613: ST_TO_ADDR
// end ; if not Cyrus then
2614: LD_EXP 46
2618: NOT
2619: IFFALSE 2665
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2621: LD_ADDR_EXP 46
2625: PUSH
2626: LD_STRING Cyrus
2628: PPUSH
2629: LD_EXP 1
2633: NOT
2634: PPUSH
2635: LD_STRING 13f_
2637: PPUSH
2638: CALL 67974 0 3
2642: ST_TO_ADDR
// if Cyrus then
2643: LD_EXP 46
2647: IFFALSE 2665
// tmp := tmp ^ Cyrus ;
2649: LD_ADDR_VAR 0 2
2653: PUSH
2654: LD_VAR 0 2
2658: PUSH
2659: LD_EXP 46
2663: ADD
2664: ST_TO_ADDR
// end ; if not Brown then
2665: LD_EXP 48
2669: NOT
2670: IFFALSE 2716
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2672: LD_ADDR_EXP 48
2676: PUSH
2677: LD_STRING Brown
2679: PPUSH
2680: LD_EXP 1
2684: NOT
2685: PPUSH
2686: LD_STRING 13f_
2688: PPUSH
2689: CALL 67974 0 3
2693: ST_TO_ADDR
// if Brown then
2694: LD_EXP 48
2698: IFFALSE 2716
// tmp := tmp ^ Brown ;
2700: LD_ADDR_VAR 0 2
2704: PUSH
2705: LD_VAR 0 2
2709: PUSH
2710: LD_EXP 48
2714: ADD
2715: ST_TO_ADDR
// end ; if not Gladstone then
2716: LD_EXP 49
2720: NOT
2721: IFFALSE 2767
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2723: LD_ADDR_EXP 49
2727: PUSH
2728: LD_STRING Gladstone
2730: PPUSH
2731: LD_EXP 1
2735: NOT
2736: PPUSH
2737: LD_STRING 13f_
2739: PPUSH
2740: CALL 67974 0 3
2744: ST_TO_ADDR
// if Gladstone then
2745: LD_EXP 49
2749: IFFALSE 2767
// tmp := tmp ^ Gladstone ;
2751: LD_ADDR_VAR 0 2
2755: PUSH
2756: LD_VAR 0 2
2760: PUSH
2761: LD_EXP 49
2765: ADD
2766: ST_TO_ADDR
// end ; if not Houten then
2767: LD_EXP 50
2771: NOT
2772: IFFALSE 2818
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2774: LD_ADDR_EXP 50
2778: PUSH
2779: LD_STRING Houten
2781: PPUSH
2782: LD_EXP 1
2786: NOT
2787: PPUSH
2788: LD_STRING 13f_
2790: PPUSH
2791: CALL 67974 0 3
2795: ST_TO_ADDR
// if Houten then
2796: LD_EXP 50
2800: IFFALSE 2818
// tmp := tmp ^ Houten ;
2802: LD_ADDR_VAR 0 2
2806: PUSH
2807: LD_VAR 0 2
2811: PUSH
2812: LD_EXP 50
2816: ADD
2817: ST_TO_ADDR
// end ; if not Cornel then
2818: LD_EXP 51
2822: NOT
2823: IFFALSE 2869
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2825: LD_ADDR_EXP 51
2829: PUSH
2830: LD_STRING Cornell
2832: PPUSH
2833: LD_EXP 1
2837: NOT
2838: PPUSH
2839: LD_STRING 13f_
2841: PPUSH
2842: CALL 67974 0 3
2846: ST_TO_ADDR
// if Cornel then
2847: LD_EXP 51
2851: IFFALSE 2869
// tmp := tmp ^ Cornel ;
2853: LD_ADDR_VAR 0 2
2857: PUSH
2858: LD_VAR 0 2
2862: PUSH
2863: LD_EXP 51
2867: ADD
2868: ST_TO_ADDR
// end ; if not Gary then
2869: LD_EXP 52
2873: NOT
2874: IFFALSE 2920
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2876: LD_ADDR_EXP 52
2880: PUSH
2881: LD_STRING Gary
2883: PPUSH
2884: LD_EXP 1
2888: NOT
2889: PPUSH
2890: LD_STRING 13f_
2892: PPUSH
2893: CALL 67974 0 3
2897: ST_TO_ADDR
// if Gary then
2898: LD_EXP 52
2902: IFFALSE 2920
// tmp := tmp ^ Gary ;
2904: LD_ADDR_VAR 0 2
2908: PUSH
2909: LD_VAR 0 2
2913: PUSH
2914: LD_EXP 52
2918: ADD
2919: ST_TO_ADDR
// end ; if not Frank then
2920: LD_EXP 53
2924: NOT
2925: IFFALSE 2971
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2927: LD_ADDR_EXP 53
2931: PUSH
2932: LD_STRING Frank
2934: PPUSH
2935: LD_EXP 1
2939: NOT
2940: PPUSH
2941: LD_STRING 13f_
2943: PPUSH
2944: CALL 67974 0 3
2948: ST_TO_ADDR
// if Frank then
2949: LD_EXP 53
2953: IFFALSE 2971
// tmp := tmp ^ Frank ;
2955: LD_ADDR_VAR 0 2
2959: PUSH
2960: LD_VAR 0 2
2964: PUSH
2965: LD_EXP 53
2969: ADD
2970: ST_TO_ADDR
// end ; if not Kikuchi then
2971: LD_EXP 54
2975: NOT
2976: IFFALSE 3022
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2978: LD_ADDR_EXP 54
2982: PUSH
2983: LD_STRING Kikuchi
2985: PPUSH
2986: LD_EXP 1
2990: NOT
2991: PPUSH
2992: LD_STRING 13f_
2994: PPUSH
2995: CALL 67974 0 3
2999: ST_TO_ADDR
// if Kikuchi then
3000: LD_EXP 54
3004: IFFALSE 3022
// tmp := tmp ^ Kikuchi ;
3006: LD_ADDR_VAR 0 2
3010: PUSH
3011: LD_VAR 0 2
3015: PUSH
3016: LD_EXP 54
3020: ADD
3021: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3022: LD_ADDR_VAR 0 2
3026: PUSH
3027: LD_VAR 0 2
3031: PUSH
3032: LD_STRING 13_other_survivors
3034: PPUSH
3035: CALL_OW 31
3039: UNION
3040: ST_TO_ADDR
// result := tmp ;
3041: LD_ADDR_VAR 0 1
3045: PUSH
3046: LD_VAR 0 2
3050: ST_TO_ADDR
// end ; end_of_file
3051: LD_VAR 0 1
3055: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3056: LD_INT 0
3058: PPUSH
3059: PPUSH
3060: PPUSH
3061: PPUSH
3062: PPUSH
3063: PPUSH
3064: PPUSH
3065: PPUSH
3066: PPUSH
3067: PPUSH
// uc_side := 4 ;
3068: LD_ADDR_OWVAR 20
3072: PUSH
3073: LD_INT 4
3075: ST_TO_ADDR
// uc_nation := 1 ;
3076: LD_ADDR_OWVAR 21
3080: PUSH
3081: LD_INT 1
3083: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3084: LD_INT 387
3086: PPUSH
3087: CALL_OW 274
3091: PPUSH
3092: LD_INT 1
3094: PPUSH
3095: LD_INT 3500
3097: PUSH
3098: LD_INT 3000
3100: PUSH
3101: LD_INT 2500
3103: PUSH
3104: LD_INT 2000
3106: PUSH
3107: EMPTY
3108: LIST
3109: LIST
3110: LIST
3111: LIST
3112: PUSH
3113: LD_OWVAR 67
3117: ARRAY
3118: PPUSH
3119: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3123: LD_INT 387
3125: PPUSH
3126: CALL_OW 274
3130: PPUSH
3131: LD_INT 2
3133: PPUSH
3134: LD_INT 400
3136: PPUSH
3137: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3141: LD_INT 387
3143: PPUSH
3144: CALL_OW 274
3148: PPUSH
3149: LD_INT 3
3151: PPUSH
3152: LD_INT 10
3154: PPUSH
3155: CALL_OW 277
// SetBName ( am_depot , sigma ) ;
3159: LD_INT 387
3161: PPUSH
3162: LD_STRING sigma
3164: PPUSH
3165: CALL_OW 500
// Powell := NewCharacter ( Powell ) ;
3169: LD_ADDR_EXP 60
3173: PUSH
3174: LD_STRING Powell
3176: PPUSH
3177: CALL_OW 25
3181: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3182: LD_EXP 60
3186: PPUSH
3187: LD_INT 57
3189: PPUSH
3190: LD_INT 94
3192: PPUSH
3193: LD_INT 0
3195: PPUSH
3196: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3200: LD_EXP 60
3204: PPUSH
3205: LD_INT 58
3207: PPUSH
3208: LD_INT 94
3210: PPUSH
3211: CALL_OW 118
// vip := [ ] ;
3215: LD_ADDR_EXP 61
3219: PUSH
3220: EMPTY
3221: ST_TO_ADDR
// tmp := [ ] ;
3222: LD_ADDR_VAR 0 5
3226: PUSH
3227: EMPTY
3228: ST_TO_ADDR
// if JMMGirl <> 2 then
3229: LD_EXP 7
3233: PUSH
3234: LD_INT 2
3236: NONEQUAL
3237: IFFALSE 3261
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3239: LD_ADDR_EXP 43
3243: PUSH
3244: LD_STRING Lisa
3246: PPUSH
3247: LD_EXP 1
3251: NOT
3252: PPUSH
3253: LD_STRING 13s_
3255: PPUSH
3256: CALL 67974 0 3
3260: ST_TO_ADDR
// if Lisa then
3261: LD_EXP 43
3265: IFFALSE 3283
// tmp := tmp ^ Lisa ;
3267: LD_ADDR_VAR 0 5
3271: PUSH
3272: LD_VAR 0 5
3276: PUSH
3277: LD_EXP 43
3281: ADD
3282: ST_TO_ADDR
// if JMMGirl < 3 then
3283: LD_EXP 7
3287: PUSH
3288: LD_INT 3
3290: LESS
3291: IFFALSE 3322
// begin Connie := NewCharacter ( Coonie ) ;
3293: LD_ADDR_EXP 55
3297: PUSH
3298: LD_STRING Coonie
3300: PPUSH
3301: CALL_OW 25
3305: ST_TO_ADDR
// tmp := tmp ^ Connie ;
3306: LD_ADDR_VAR 0 5
3310: PUSH
3311: LD_VAR 0 5
3315: PUSH
3316: LD_EXP 55
3320: ADD
3321: ST_TO_ADDR
// end ; Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3322: LD_ADDR_EXP 44
3326: PUSH
3327: LD_STRING Donaldson
3329: PPUSH
3330: LD_EXP 1
3334: NOT
3335: PPUSH
3336: LD_STRING 13s_
3338: PPUSH
3339: CALL 67974 0 3
3343: ST_TO_ADDR
// if Donaldson then
3344: LD_EXP 44
3348: IFFALSE 3366
// tmp := tmp ^ Donaldson ;
3350: LD_ADDR_VAR 0 5
3354: PUSH
3355: LD_VAR 0 5
3359: PUSH
3360: LD_EXP 44
3364: ADD
3365: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3366: LD_ADDR_EXP 45
3370: PUSH
3371: LD_STRING Bobby
3373: PPUSH
3374: LD_EXP 1
3378: NOT
3379: PPUSH
3380: LD_STRING 13s_
3382: PPUSH
3383: CALL 67974 0 3
3387: ST_TO_ADDR
// if Bobby then
3388: LD_EXP 45
3392: IFFALSE 3410
// tmp := tmp ^ Bobby ;
3394: LD_ADDR_VAR 0 5
3398: PUSH
3399: LD_VAR 0 5
3403: PUSH
3404: LD_EXP 45
3408: ADD
3409: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3410: LD_ADDR_EXP 46
3414: PUSH
3415: LD_STRING Cyrus
3417: PPUSH
3418: LD_EXP 1
3422: NOT
3423: PPUSH
3424: LD_STRING 13s_
3426: PPUSH
3427: CALL 67974 0 3
3431: ST_TO_ADDR
// if Cyrus then
3432: LD_EXP 46
3436: IFFALSE 3454
// tmp := tmp ^ Cyrus ;
3438: LD_ADDR_VAR 0 5
3442: PUSH
3443: LD_VAR 0 5
3447: PUSH
3448: LD_EXP 46
3452: ADD
3453: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3454: LD_ADDR_EXP 47
3458: PUSH
3459: LD_STRING Denis
3461: PPUSH
3462: LD_EXP 1
3466: NOT
3467: PPUSH
3468: LD_STRING 13s_
3470: PPUSH
3471: CALL 67974 0 3
3475: ST_TO_ADDR
// if not Denis then
3476: LD_EXP 47
3480: NOT
3481: IFFALSE 3505
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3483: LD_ADDR_EXP 47
3487: PUSH
3488: LD_STRING Denis
3490: PPUSH
3491: LD_EXP 1
3495: NOT
3496: PPUSH
3497: LD_STRING 13f_
3499: PPUSH
3500: CALL 67974 0 3
3504: ST_TO_ADDR
// if Denis then
3505: LD_EXP 47
3509: IFFALSE 3527
// tmp := tmp ^ Denis ;
3511: LD_ADDR_VAR 0 5
3515: PUSH
3516: LD_VAR 0 5
3520: PUSH
3521: LD_EXP 47
3525: ADD
3526: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3527: LD_ADDR_EXP 48
3531: PUSH
3532: LD_STRING Brown
3534: PPUSH
3535: LD_EXP 1
3539: NOT
3540: PPUSH
3541: LD_STRING 13s_
3543: PPUSH
3544: CALL 67974 0 3
3548: ST_TO_ADDR
// if Brown then
3549: LD_EXP 48
3553: IFFALSE 3571
// tmp := tmp ^ Brown ;
3555: LD_ADDR_VAR 0 5
3559: PUSH
3560: LD_VAR 0 5
3564: PUSH
3565: LD_EXP 48
3569: ADD
3570: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3571: LD_ADDR_EXP 49
3575: PUSH
3576: LD_STRING Gladstone
3578: PPUSH
3579: LD_EXP 1
3583: NOT
3584: PPUSH
3585: LD_STRING 13s_
3587: PPUSH
3588: CALL 67974 0 3
3592: ST_TO_ADDR
// if Gladstone then
3593: LD_EXP 49
3597: IFFALSE 3615
// tmp := tmp ^ Gladstone ;
3599: LD_ADDR_VAR 0 5
3603: PUSH
3604: LD_VAR 0 5
3608: PUSH
3609: LD_EXP 49
3613: ADD
3614: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3615: LD_ADDR_EXP 50
3619: PUSH
3620: LD_STRING Houten
3622: PPUSH
3623: LD_EXP 1
3627: NOT
3628: PPUSH
3629: LD_STRING 13s_
3631: PPUSH
3632: CALL 67974 0 3
3636: ST_TO_ADDR
// if Houten then
3637: LD_EXP 50
3641: IFFALSE 3659
// tmp := tmp ^ Houten ;
3643: LD_ADDR_VAR 0 5
3647: PUSH
3648: LD_VAR 0 5
3652: PUSH
3653: LD_EXP 50
3657: ADD
3658: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3659: LD_ADDR_EXP 51
3663: PUSH
3664: LD_STRING Cornel
3666: PPUSH
3667: LD_EXP 1
3671: NOT
3672: PPUSH
3673: LD_STRING 13s_
3675: PPUSH
3676: CALL 67974 0 3
3680: ST_TO_ADDR
// if Cornel then
3681: LD_EXP 51
3685: IFFALSE 3703
// tmp := tmp ^ Cornel ;
3687: LD_ADDR_VAR 0 5
3691: PUSH
3692: LD_VAR 0 5
3696: PUSH
3697: LD_EXP 51
3701: ADD
3702: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3703: LD_ADDR_EXP 52
3707: PUSH
3708: LD_STRING Gary
3710: PPUSH
3711: LD_EXP 1
3715: NOT
3716: PPUSH
3717: LD_STRING 13s_
3719: PPUSH
3720: CALL 67974 0 3
3724: ST_TO_ADDR
// if Gary then
3725: LD_EXP 52
3729: IFFALSE 3747
// tmp := tmp ^ Gary ;
3731: LD_ADDR_VAR 0 5
3735: PUSH
3736: LD_VAR 0 5
3740: PUSH
3741: LD_EXP 52
3745: ADD
3746: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3747: LD_ADDR_EXP 53
3751: PUSH
3752: LD_STRING Frank
3754: PPUSH
3755: LD_EXP 1
3759: NOT
3760: PPUSH
3761: LD_STRING 13s_
3763: PPUSH
3764: CALL 67974 0 3
3768: ST_TO_ADDR
// if Frank then
3769: LD_EXP 53
3773: IFFALSE 3791
// tmp := tmp ^ Frank ;
3775: LD_ADDR_VAR 0 5
3779: PUSH
3780: LD_VAR 0 5
3784: PUSH
3785: LD_EXP 53
3789: ADD
3790: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3791: LD_ADDR_EXP 54
3795: PUSH
3796: LD_STRING Kikuchi
3798: PPUSH
3799: LD_EXP 1
3803: NOT
3804: PPUSH
3805: LD_STRING 13s_
3807: PPUSH
3808: CALL 67974 0 3
3812: ST_TO_ADDR
// if Kikuchi then
3813: LD_EXP 54
3817: IFFALSE 3835
// tmp := tmp ^ Kikuchi ;
3819: LD_ADDR_VAR 0 5
3823: PUSH
3824: LD_VAR 0 5
3828: PUSH
3829: LD_EXP 54
3833: ADD
3834: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 10c_ ) ;
3835: LD_ADDR_EXP 57
3839: PUSH
3840: LD_STRING Mike
3842: PPUSH
3843: LD_EXP 1
3847: NOT
3848: PPUSH
3849: LD_STRING 10c_
3851: PPUSH
3852: CALL 67974 0 3
3856: ST_TO_ADDR
// if Mike then
3857: LD_EXP 57
3861: IFFALSE 3884
// PlaceUnitXYR ( Mike , 61 , 89 , 8 , false ) ;
3863: LD_EXP 57
3867: PPUSH
3868: LD_INT 61
3870: PPUSH
3871: LD_INT 89
3873: PPUSH
3874: LD_INT 8
3876: PPUSH
3877: LD_INT 0
3879: PPUSH
3880: CALL_OW 50
// vip := tmp ;
3884: LD_ADDR_EXP 61
3888: PUSH
3889: LD_VAR 0 5
3893: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3894: LD_ADDR_VAR 0 5
3898: PUSH
3899: LD_VAR 0 5
3903: PUSH
3904: LD_STRING 13s_others
3906: PPUSH
3907: CALL_OW 31
3911: UNION
3912: ST_TO_ADDR
// if tmp < 18 then
3913: LD_VAR 0 5
3917: PUSH
3918: LD_INT 18
3920: LESS
3921: IFFALSE 4014
// for i = 1 to 18 - tmp do
3923: LD_ADDR_VAR 0 2
3927: PUSH
3928: DOUBLE
3929: LD_INT 1
3931: DEC
3932: ST_TO_ADDR
3933: LD_INT 18
3935: PUSH
3936: LD_VAR 0 5
3940: MINUS
3941: PUSH
3942: FOR_TO
3943: IFFALSE 4012
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
3945: LD_INT 1
3947: PPUSH
3948: LD_VAR 0 2
3952: PUSH
3953: LD_INT 4
3955: MOD
3956: PUSH
3957: LD_INT 1
3959: PLUS
3960: PPUSH
3961: LD_INT 4
3963: PPUSH
3964: CALL_OW 380
// un := CreateHuman ;
3968: LD_ADDR_VAR 0 10
3972: PUSH
3973: CALL_OW 44
3977: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
3978: LD_ADDR_VAR 0 5
3982: PUSH
3983: LD_VAR 0 5
3987: PPUSH
3988: LD_VAR 0 10
3992: PPUSH
3993: CALL 105266 0 2
3997: ST_TO_ADDR
// SetTag ( un , 1 ) ;
3998: LD_VAR 0 10
4002: PPUSH
4003: LD_INT 1
4005: PPUSH
4006: CALL_OW 109
// end ;
4010: GO 3942
4012: POP
4013: POP
// depot := HexInfo ( 53 , 94 ) ;
4014: LD_ADDR_VAR 0 6
4018: PUSH
4019: LD_INT 53
4021: PPUSH
4022: LD_INT 94
4024: PPUSH
4025: CALL_OW 428
4029: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
4030: LD_ADDR_VAR 0 7
4034: PUSH
4035: LD_INT 56
4037: PPUSH
4038: LD_INT 101
4040: PPUSH
4041: CALL_OW 428
4045: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
4046: LD_ADDR_VAR 0 8
4050: PUSH
4051: LD_INT 67
4053: PPUSH
4054: LD_INT 101
4056: PPUSH
4057: CALL_OW 428
4061: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
4062: LD_ADDR_VAR 0 9
4066: PUSH
4067: LD_INT 54
4069: PPUSH
4070: LD_INT 85
4072: PPUSH
4073: CALL_OW 428
4077: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
4078: LD_ADDR_VAR 0 3
4082: PUSH
4083: LD_VAR 0 8
4087: PUSH
4088: LD_VAR 0 6
4092: PUSH
4093: LD_VAR 0 9
4097: PUSH
4098: LD_VAR 0 7
4102: PUSH
4103: EMPTY
4104: LIST
4105: LIST
4106: LIST
4107: LIST
4108: ST_TO_ADDR
// for i in tmp do
4109: LD_ADDR_VAR 0 2
4113: PUSH
4114: LD_VAR 0 5
4118: PUSH
4119: FOR_IN
4120: IFFALSE 4208
// begin if UnitsInside ( b [ 1 ] ) = 6 then
4122: LD_VAR 0 3
4126: PUSH
4127: LD_INT 1
4129: ARRAY
4130: PPUSH
4131: CALL_OW 313
4135: PUSH
4136: LD_INT 6
4138: EQUAL
4139: IFFALSE 4159
// b := Delete ( b , 1 ) ;
4141: LD_ADDR_VAR 0 3
4145: PUSH
4146: LD_VAR 0 3
4150: PPUSH
4151: LD_INT 1
4153: PPUSH
4154: CALL_OW 3
4158: ST_TO_ADDR
// if b then
4159: LD_VAR 0 3
4163: IFFALSE 4185
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4165: LD_VAR 0 2
4169: PPUSH
4170: LD_VAR 0 3
4174: PUSH
4175: LD_INT 1
4177: ARRAY
4178: PPUSH
4179: CALL_OW 52
4183: GO 4206
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4185: LD_VAR 0 2
4189: PPUSH
4190: LD_INT 61
4192: PPUSH
4193: LD_INT 89
4195: PPUSH
4196: LD_INT 8
4198: PPUSH
4199: LD_INT 0
4201: PPUSH
4202: CALL_OW 50
// end ;
4206: GO 4119
4208: POP
4209: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4210: LD_INT 2
4212: PPUSH
4213: LD_INT 1
4215: PPUSH
4216: LD_INT 1
4218: PPUSH
4219: LD_INT 12
4221: PPUSH
4222: LD_INT 100
4224: PPUSH
4225: CALL 72814 0 5
// veh := CreateVehicle ;
4229: LD_ADDR_VAR 0 4
4233: PUSH
4234: CALL_OW 45
4238: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4239: LD_VAR 0 4
4243: PPUSH
4244: LD_INT 4
4246: PPUSH
4247: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4251: LD_VAR 0 4
4255: PPUSH
4256: LD_INT 49
4258: PPUSH
4259: LD_INT 88
4261: PPUSH
4262: LD_INT 0
4264: PPUSH
4265: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4269: LD_VAR 0 4
4273: PPUSH
4274: LD_INT 1
4276: PPUSH
4277: LD_INT 100
4279: PPUSH
4280: CALL_OW 290
// uc_side := 0 ;
4284: LD_ADDR_OWVAR 20
4288: PUSH
4289: LD_INT 0
4291: ST_TO_ADDR
// uc_nation := 0 ;
4292: LD_ADDR_OWVAR 21
4296: PUSH
4297: LD_INT 0
4299: ST_TO_ADDR
// for i := 1 to 3 do
4300: LD_ADDR_VAR 0 2
4304: PUSH
4305: DOUBLE
4306: LD_INT 1
4308: DEC
4309: ST_TO_ADDR
4310: LD_INT 3
4312: PUSH
4313: FOR_TO
4314: IFFALSE 4345
// begin InitHc ;
4316: CALL_OW 19
// hc_class := class_apeman ;
4320: LD_ADDR_OWVAR 28
4324: PUSH
4325: LD_INT 12
4327: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4328: CALL_OW 44
4332: PPUSH
4333: LD_INT 13
4335: PPUSH
4336: LD_INT 0
4338: PPUSH
4339: CALL_OW 49
// end ;
4343: GO 4313
4345: POP
4346: POP
// end ; end_of_file
4347: LD_VAR 0 1
4351: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4352: LD_INT 0
4354: PPUSH
4355: PPUSH
4356: PPUSH
4357: PPUSH
4358: PPUSH
// side := 8 ;
4359: LD_ADDR_VAR 0 3
4363: PUSH
4364: LD_INT 8
4366: ST_TO_ADDR
// uc_side := side ;
4367: LD_ADDR_OWVAR 20
4371: PUSH
4372: LD_VAR 0 3
4376: ST_TO_ADDR
// uc_nation := 2 ;
4377: LD_ADDR_OWVAR 21
4381: PUSH
4382: LD_INT 2
4384: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4385: LD_ADDR_VAR 0 2
4389: PUSH
4390: LD_INT 22
4392: PUSH
4393: LD_VAR 0 3
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PUSH
4402: LD_INT 21
4404: PUSH
4405: LD_INT 3
4407: PUSH
4408: EMPTY
4409: LIST
4410: LIST
4411: PUSH
4412: EMPTY
4413: LIST
4414: LIST
4415: PPUSH
4416: CALL_OW 69
4420: PUSH
4421: FOR_IN
4422: IFFALSE 4438
// SetBLevel ( i , 10 ) ;
4424: LD_VAR 0 2
4428: PPUSH
4429: LD_INT 10
4431: PPUSH
4432: CALL_OW 241
4436: GO 4421
4438: POP
4439: POP
// if KurtStatus then
4440: LD_EXP 3
4444: IFFALSE 4467
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4446: LD_ADDR_EXP 62
4450: PUSH
4451: LD_STRING Kurt
4453: PPUSH
4454: LD_INT 0
4456: PPUSH
4457: LD_STRING 
4459: PPUSH
4460: CALL 67974 0 3
4464: ST_TO_ADDR
4465: GO 4489
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4467: LD_ADDR_EXP 62
4471: PUSH
4472: LD_STRING AltKurt
4474: PPUSH
4475: LD_EXP 1
4479: NOT
4480: PPUSH
4481: LD_STRING 
4483: PPUSH
4484: CALL 67974 0 3
4488: ST_TO_ADDR
// if not Kurt then
4489: LD_EXP 62
4493: NOT
4494: IFFALSE 4520
// begin InitHc ;
4496: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4500: LD_INT 1
4502: PPUSH
4503: LD_INT 10
4505: PPUSH
4506: CALL_OW 381
// Kurt := CreateHuman ;
4510: LD_ADDR_EXP 62
4514: PUSH
4515: CALL_OW 44
4519: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4520: LD_EXP 62
4524: PPUSH
4525: LD_INT 324
4527: PPUSH
4528: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4532: LD_ADDR_EXP 63
4536: PUSH
4537: LD_STRING Kozlov
4539: PPUSH
4540: LD_INT 0
4542: PPUSH
4543: LD_STRING 
4545: PPUSH
4546: CALL 67974 0 3
4550: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4551: LD_EXP 63
4555: PPUSH
4556: LD_INT 22
4558: PUSH
4559: LD_INT 8
4561: PUSH
4562: EMPTY
4563: LIST
4564: LIST
4565: PUSH
4566: LD_INT 23
4568: PUSH
4569: LD_INT 3
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: PUSH
4576: LD_INT 30
4578: PUSH
4579: LD_INT 8
4581: PUSH
4582: EMPTY
4583: LIST
4584: LIST
4585: PUSH
4586: EMPTY
4587: LIST
4588: LIST
4589: LIST
4590: PPUSH
4591: CALL_OW 69
4595: PUSH
4596: LD_INT 1
4598: ARRAY
4599: PPUSH
4600: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4604: LD_EXP 63
4608: PPUSH
4609: LD_INT 3
4611: PPUSH
4612: LD_INT 10
4614: PPUSH
4615: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4619: LD_EXP 63
4623: PPUSH
4624: LD_INT 4
4626: PPUSH
4627: LD_INT 10
4629: PPUSH
4630: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4634: LD_ADDR_VAR 0 5
4638: PUSH
4639: LD_INT 22
4641: PUSH
4642: LD_VAR 0 3
4646: PUSH
4647: EMPTY
4648: LIST
4649: LIST
4650: PUSH
4651: LD_INT 30
4653: PUSH
4654: LD_INT 32
4656: PUSH
4657: EMPTY
4658: LIST
4659: LIST
4660: PUSH
4661: LD_INT 58
4663: PUSH
4664: EMPTY
4665: LIST
4666: PUSH
4667: EMPTY
4668: LIST
4669: LIST
4670: LIST
4671: PPUSH
4672: CALL_OW 69
4676: ST_TO_ADDR
// for i = 1 to 10 do
4677: LD_ADDR_VAR 0 2
4681: PUSH
4682: DOUBLE
4683: LD_INT 1
4685: DEC
4686: ST_TO_ADDR
4687: LD_INT 10
4689: PUSH
4690: FOR_TO
4691: IFFALSE 4763
// begin uc_nation := nation_nature ;
4693: LD_ADDR_OWVAR 21
4697: PUSH
4698: LD_INT 0
4700: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4701: LD_ADDR_OWVAR 28
4705: PUSH
4706: LD_INT 15
4708: ST_TO_ADDR
// hc_gallery :=  ;
4709: LD_ADDR_OWVAR 33
4713: PUSH
4714: LD_STRING 
4716: ST_TO_ADDR
// hc_name :=  ;
4717: LD_ADDR_OWVAR 26
4721: PUSH
4722: LD_STRING 
4724: ST_TO_ADDR
// un := CreateHuman ;
4725: LD_ADDR_VAR 0 4
4729: PUSH
4730: CALL_OW 44
4734: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4735: LD_VAR 0 4
4739: PPUSH
4740: LD_VAR 0 5
4744: PUSH
4745: LD_VAR 0 5
4749: PUSH
4750: LD_VAR 0 2
4754: MINUS
4755: ARRAY
4756: PPUSH
4757: CALL_OW 52
// end ;
4761: GO 4690
4763: POP
4764: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4765: LD_ADDR_VAR 0 5
4769: PUSH
4770: LD_STRING 12_kurt_squad
4772: PPUSH
4773: CALL_OW 31
4777: ST_TO_ADDR
// if tmp then
4778: LD_VAR 0 5
4782: IFFALSE 4816
// for i in tmp do
4784: LD_ADDR_VAR 0 2
4788: PUSH
4789: LD_VAR 0 5
4793: PUSH
4794: FOR_IN
4795: IFFALSE 4814
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4797: LD_VAR 0 2
4801: PPUSH
4802: LD_INT 5
4804: PPUSH
4805: LD_INT 0
4807: PPUSH
4808: CALL_OW 49
4812: GO 4794
4814: POP
4815: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4816: LD_INT 324
4818: PPUSH
4819: LD_INT 5
4821: PPUSH
4822: LD_STRING 
4824: PPUSH
4825: LD_INT 8
4827: PUSH
4828: LD_INT 9
4830: PUSH
4831: LD_INT 10
4833: PUSH
4834: LD_INT 10
4836: PUSH
4837: EMPTY
4838: LIST
4839: LIST
4840: LIST
4841: LIST
4842: PUSH
4843: LD_OWVAR 67
4847: ARRAY
4848: PPUSH
4849: LD_INT 3000
4851: PUSH
4852: LD_INT 500
4854: PUSH
4855: LD_INT 150
4857: PUSH
4858: EMPTY
4859: LIST
4860: LIST
4861: LIST
4862: PPUSH
4863: LD_INT 16
4865: PUSH
4866: LD_INT 6
4868: PUSH
4869: LD_INT 6
4871: PUSH
4872: LD_INT 8
4874: PUSH
4875: EMPTY
4876: LIST
4877: LIST
4878: LIST
4879: LIST
4880: PPUSH
4881: CALL 76258 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4885: LD_ADDR_EXP 100
4889: PUSH
4890: LD_EXP 100
4894: PPUSH
4895: LD_INT 3
4897: PPUSH
4898: LD_INT 22
4900: PUSH
4901: LD_VAR 0 3
4905: PUSH
4906: EMPTY
4907: LIST
4908: LIST
4909: PUSH
4910: LD_INT 23
4912: PUSH
4913: LD_INT 2
4915: PUSH
4916: EMPTY
4917: LIST
4918: LIST
4919: PUSH
4920: LD_INT 3
4922: PUSH
4923: LD_INT 21
4925: PUSH
4926: LD_INT 2
4928: PUSH
4929: EMPTY
4930: LIST
4931: LIST
4932: PUSH
4933: EMPTY
4934: LIST
4935: LIST
4936: PUSH
4937: EMPTY
4938: LIST
4939: LIST
4940: LIST
4941: PPUSH
4942: CALL_OW 69
4946: PUSH
4947: LD_EXP 62
4951: DIFF
4952: PPUSH
4953: CALL_OW 1
4957: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4958: LD_INT 1
4960: PPUSH
4961: LD_INT 7
4963: PPUSH
4964: CALL_OW 383
// hc_name := Ali Hadrach ;
4968: LD_ADDR_OWVAR 26
4972: PUSH
4973: LD_STRING Ali Hadrach
4975: ST_TO_ADDR
// hc_face_number := 31 ;
4976: LD_ADDR_OWVAR 34
4980: PUSH
4981: LD_INT 31
4983: ST_TO_ADDR
// Friend := CreateHuman ;
4984: LD_ADDR_EXP 64
4988: PUSH
4989: CALL_OW 44
4993: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4994: LD_INT 14
4996: PPUSH
4997: LD_INT 3
4999: PPUSH
5000: LD_INT 1
5002: PPUSH
5003: LD_INT 29
5005: PPUSH
5006: LD_INT 100
5008: PPUSH
5009: CALL 72814 0 5
// powellBomb := CreateVehicle ;
5013: LD_ADDR_EXP 65
5017: PUSH
5018: CALL_OW 45
5022: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
5023: LD_EXP 65
5027: PPUSH
5028: LD_INT 90
5030: PPUSH
5031: LD_INT 51
5033: PPUSH
5034: LD_INT 0
5036: PPUSH
5037: CALL_OW 48
// end ;
5041: LD_VAR 0 1
5045: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
5046: LD_INT 0
5048: PPUSH
5049: PPUSH
5050: PPUSH
// if IsLive ( kozlov_fac ) then
5051: LD_INT 332
5053: PPUSH
5054: CALL_OW 300
5058: IFFALSE 5062
// exit ;
5060: GO 5629
// ComExitBuilding ( Kozlov ) ;
5062: LD_EXP 63
5066: PPUSH
5067: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
5071: LD_EXP 63
5075: PPUSH
5076: CALL_OW 257
5080: PUSH
5081: LD_INT 2
5083: NONEQUAL
5084: IFFALSE 5119
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
5086: LD_EXP 63
5090: PPUSH
5091: LD_INT 324
5093: PPUSH
5094: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
5098: LD_EXP 63
5102: PPUSH
5103: LD_INT 2
5105: PPUSH
5106: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
5110: LD_EXP 63
5114: PPUSH
5115: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
5119: LD_EXP 63
5123: PPUSH
5124: LD_INT 2
5126: PPUSH
5127: LD_INT 93
5129: PPUSH
5130: LD_INT 32
5132: PPUSH
5133: LD_INT 3
5135: PPUSH
5136: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5140: LD_INT 35
5142: PPUSH
5143: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5147: LD_INT 22
5149: PUSH
5150: LD_INT 8
5152: PUSH
5153: EMPTY
5154: LIST
5155: LIST
5156: PUSH
5157: LD_INT 30
5159: PUSH
5160: LD_INT 3
5162: PUSH
5163: EMPTY
5164: LIST
5165: LIST
5166: PUSH
5167: LD_INT 23
5169: PUSH
5170: LD_INT 3
5172: PUSH
5173: EMPTY
5174: LIST
5175: LIST
5176: PUSH
5177: LD_INT 57
5179: PUSH
5180: EMPTY
5181: LIST
5182: PUSH
5183: EMPTY
5184: LIST
5185: LIST
5186: LIST
5187: LIST
5188: PPUSH
5189: CALL_OW 69
5193: IFFALSE 5140
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5195: LD_ADDR_VAR 0 2
5199: PUSH
5200: LD_INT 22
5202: PUSH
5203: LD_INT 8
5205: PUSH
5206: EMPTY
5207: LIST
5208: LIST
5209: PUSH
5210: LD_INT 30
5212: PUSH
5213: LD_INT 3
5215: PUSH
5216: EMPTY
5217: LIST
5218: LIST
5219: PUSH
5220: LD_INT 23
5222: PUSH
5223: LD_INT 3
5225: PUSH
5226: EMPTY
5227: LIST
5228: LIST
5229: PUSH
5230: LD_INT 57
5232: PUSH
5233: EMPTY
5234: LIST
5235: PUSH
5236: EMPTY
5237: LIST
5238: LIST
5239: LIST
5240: LIST
5241: PPUSH
5242: CALL_OW 69
5246: PUSH
5247: LD_INT 1
5249: ARRAY
5250: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5251: LD_INT 22
5253: PUSH
5254: LD_INT 8
5256: PUSH
5257: EMPTY
5258: LIST
5259: LIST
5260: PUSH
5261: LD_INT 23
5263: PUSH
5264: LD_INT 3
5266: PUSH
5267: EMPTY
5268: LIST
5269: LIST
5270: PUSH
5271: LD_INT 30
5273: PUSH
5274: LD_INT 21
5276: PUSH
5277: EMPTY
5278: LIST
5279: LIST
5280: PUSH
5281: EMPTY
5282: LIST
5283: LIST
5284: LIST
5285: PPUSH
5286: CALL_OW 69
5290: NOT
5291: IFFALSE 5369
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5293: LD_EXP 63
5297: PPUSH
5298: LD_INT 21
5300: PPUSH
5301: LD_INT 97
5303: PPUSH
5304: LD_INT 36
5306: PPUSH
5307: LD_INT 5
5309: PPUSH
5310: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5314: LD_INT 35
5316: PPUSH
5317: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5321: LD_INT 22
5323: PUSH
5324: LD_INT 8
5326: PUSH
5327: EMPTY
5328: LIST
5329: LIST
5330: PUSH
5331: LD_INT 23
5333: PUSH
5334: LD_INT 3
5336: PUSH
5337: EMPTY
5338: LIST
5339: LIST
5340: PUSH
5341: LD_INT 30
5343: PUSH
5344: LD_INT 21
5346: PUSH
5347: EMPTY
5348: LIST
5349: LIST
5350: PUSH
5351: LD_INT 57
5353: PUSH
5354: EMPTY
5355: LIST
5356: PUSH
5357: EMPTY
5358: LIST
5359: LIST
5360: LIST
5361: LIST
5362: PPUSH
5363: CALL_OW 69
5367: IFFALSE 5314
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5369: LD_INT 22
5371: PUSH
5372: LD_INT 8
5374: PUSH
5375: EMPTY
5376: LIST
5377: LIST
5378: PUSH
5379: LD_INT 23
5381: PUSH
5382: LD_INT 3
5384: PUSH
5385: EMPTY
5386: LIST
5387: LIST
5388: PUSH
5389: LD_INT 30
5391: PUSH
5392: LD_INT 18
5394: PUSH
5395: EMPTY
5396: LIST
5397: LIST
5398: PUSH
5399: EMPTY
5400: LIST
5401: LIST
5402: LIST
5403: PPUSH
5404: CALL_OW 69
5408: NOT
5409: IFFALSE 5487
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5411: LD_EXP 63
5415: PPUSH
5416: LD_INT 18
5418: PPUSH
5419: LD_INT 89
5421: PPUSH
5422: LD_INT 32
5424: PPUSH
5425: LD_INT 1
5427: PPUSH
5428: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5432: LD_INT 35
5434: PPUSH
5435: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5439: LD_INT 22
5441: PUSH
5442: LD_INT 8
5444: PUSH
5445: EMPTY
5446: LIST
5447: LIST
5448: PUSH
5449: LD_INT 23
5451: PUSH
5452: LD_INT 3
5454: PUSH
5455: EMPTY
5456: LIST
5457: LIST
5458: PUSH
5459: LD_INT 30
5461: PUSH
5462: LD_INT 18
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: PUSH
5469: LD_INT 57
5471: PUSH
5472: EMPTY
5473: LIST
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: LIST
5479: LIST
5480: PPUSH
5481: CALL_OW 69
5485: IFFALSE 5432
// end ; lab := kozlov_lab ;
5487: LD_ADDR_VAR 0 3
5491: PUSH
5492: LD_INT 336
5494: ST_TO_ADDR
// if not lab then
5495: LD_VAR 0 3
5499: NOT
5500: IFFALSE 5504
// exit ;
5502: GO 5629
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5504: LD_EXP 63
5508: PPUSH
5509: LD_VAR 0 3
5513: PUSH
5514: LD_INT 1
5516: ARRAY
5517: PPUSH
5518: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5522: LD_EXP 63
5526: PPUSH
5527: LD_INT 4
5529: PPUSH
5530: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5534: LD_VAR 0 3
5538: PUSH
5539: LD_INT 1
5541: ARRAY
5542: PPUSH
5543: LD_INT 25
5545: PPUSH
5546: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5550: LD_INT 35
5552: PPUSH
5553: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5557: LD_INT 25
5559: PPUSH
5560: LD_INT 8
5562: PPUSH
5563: CALL_OW 321
5567: PUSH
5568: LD_INT 2
5570: EQUAL
5571: IFFALSE 5550
// ComExitBuilding ( Kozlov ) ;
5573: LD_EXP 63
5577: PPUSH
5578: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5582: LD_EXP 63
5586: PPUSH
5587: LD_VAR 0 2
5591: PPUSH
5592: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5596: LD_EXP 63
5600: PPUSH
5601: LD_INT 3
5603: PPUSH
5604: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5608: LD_VAR 0 2
5612: PPUSH
5613: LD_INT 23
5615: PPUSH
5616: LD_INT 3
5618: PPUSH
5619: LD_INT 1
5621: PPUSH
5622: LD_INT 48
5624: PPUSH
5625: CALL_OW 125
// end ;
5629: LD_VAR 0 1
5633: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5634: LD_EXP 22
5638: NOT
5639: PUSH
5640: LD_EXP 15
5644: PUSH
5645: LD_INT 6
5647: GREATEREQUAL
5648: AND
5649: IFFALSE 5730
5651: GO 5653
5653: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5654: LD_INT 3
5656: PPUSH
5657: LD_INT 3
5659: PPUSH
5660: CALL 61685 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5664: LD_INT 3
5666: PPUSH
5667: LD_INT 14
5669: PUSH
5670: LD_INT 1
5672: PUSH
5673: LD_INT 1
5675: PUSH
5676: LD_INT 28
5678: PUSH
5679: EMPTY
5680: LIST
5681: LIST
5682: LIST
5683: LIST
5684: PUSH
5685: LD_INT 14
5687: PUSH
5688: LD_INT 1
5690: PUSH
5691: LD_INT 1
5693: PUSH
5694: LD_INT 28
5696: PUSH
5697: EMPTY
5698: LIST
5699: LIST
5700: LIST
5701: LIST
5702: PUSH
5703: LD_INT 14
5705: PUSH
5706: LD_INT 1
5708: PUSH
5709: LD_INT 1
5711: PUSH
5712: LD_INT 28
5714: PUSH
5715: EMPTY
5716: LIST
5717: LIST
5718: LIST
5719: LIST
5720: PUSH
5721: EMPTY
5722: LIST
5723: LIST
5724: LIST
5725: PPUSH
5726: CALL 61548 0 2
// end ;
5730: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5731: LD_EXP 22
5735: NOT
5736: PUSH
5737: LD_EXP 15
5741: PUSH
5742: LD_INT 6
5744: GREATEREQUAL
5745: AND
5746: PUSH
5747: LD_INT 3
5749: PPUSH
5750: LD_INT 1
5752: PPUSH
5753: CALL 62966 0 2
5757: NOT
5758: AND
5759: IFFALSE 6633
5761: GO 5763
5763: DISABLE
5764: LD_INT 0
5766: PPUSH
5767: PPUSH
5768: PPUSH
// begin enable ;
5769: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5770: LD_INT 22
5772: PUSH
5773: LD_INT 8
5775: PUSH
5776: EMPTY
5777: LIST
5778: LIST
5779: PUSH
5780: LD_INT 23
5782: PUSH
5783: LD_INT 2
5785: PUSH
5786: EMPTY
5787: LIST
5788: LIST
5789: PUSH
5790: LD_INT 30
5792: PUSH
5793: LD_INT 3
5795: PUSH
5796: EMPTY
5797: LIST
5798: LIST
5799: PUSH
5800: EMPTY
5801: LIST
5802: LIST
5803: LIST
5804: PPUSH
5805: CALL_OW 69
5809: NOT
5810: IFFALSE 5814
// exit ;
5812: GO 6633
// if Prob ( 40 ) then
5814: LD_INT 40
5816: PPUSH
5817: CALL_OW 13
5821: IFFALSE 5948
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5823: LD_INT 3
5825: PPUSH
5826: LD_INT 14
5828: PUSH
5829: LD_INT 1
5831: PUSH
5832: LD_INT 2
5834: PUSH
5835: LD_INT 28
5837: PUSH
5838: EMPTY
5839: LIST
5840: LIST
5841: LIST
5842: LIST
5843: PUSH
5844: LD_INT 14
5846: PUSH
5847: LD_INT 1
5849: PUSH
5850: LD_INT 2
5852: PUSH
5853: LD_INT 28
5855: PUSH
5856: EMPTY
5857: LIST
5858: LIST
5859: LIST
5860: LIST
5861: PUSH
5862: LD_INT 14
5864: PUSH
5865: LD_INT 1
5867: PUSH
5868: LD_INT 2
5870: PUSH
5871: LD_INT 28
5873: PUSH
5874: EMPTY
5875: LIST
5876: LIST
5877: LIST
5878: LIST
5879: PUSH
5880: LD_INT 14
5882: PUSH
5883: LD_INT 1
5885: PUSH
5886: LD_INT 2
5888: PUSH
5889: LD_INT 28
5891: PUSH
5892: EMPTY
5893: LIST
5894: LIST
5895: LIST
5896: LIST
5897: PUSH
5898: LD_INT 14
5900: PUSH
5901: LD_INT 1
5903: PUSH
5904: LD_INT 2
5906: PUSH
5907: LD_INT 28
5909: PUSH
5910: EMPTY
5911: LIST
5912: LIST
5913: LIST
5914: LIST
5915: PUSH
5916: LD_INT 14
5918: PUSH
5919: LD_INT 1
5921: PUSH
5922: LD_INT 2
5924: PUSH
5925: LD_INT 26
5927: PUSH
5928: EMPTY
5929: LIST
5930: LIST
5931: LIST
5932: LIST
5933: PUSH
5934: EMPTY
5935: LIST
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: LIST
5941: PPUSH
5942: CALL 61548 0 2
// end else
5946: GO 6155
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5948: LD_INT 3
5950: PPUSH
5951: LD_INT 14
5953: PUSH
5954: LD_INT 1
5956: PUSH
5957: LD_INT 2
5959: PUSH
5960: LD_INT 27
5962: PUSH
5963: LD_INT 26
5965: PUSH
5966: LD_INT 26
5968: PUSH
5969: LD_INT 28
5971: PUSH
5972: EMPTY
5973: LIST
5974: LIST
5975: LIST
5976: LIST
5977: PUSH
5978: LD_OWVAR 67
5982: ARRAY
5983: PUSH
5984: EMPTY
5985: LIST
5986: LIST
5987: LIST
5988: LIST
5989: PUSH
5990: LD_INT 14
5992: PUSH
5993: LD_INT 1
5995: PUSH
5996: LD_INT 2
5998: PUSH
5999: LD_INT 27
6001: PUSH
6002: LD_INT 26
6004: PUSH
6005: LD_INT 26
6007: PUSH
6008: LD_INT 26
6010: PUSH
6011: EMPTY
6012: LIST
6013: LIST
6014: LIST
6015: LIST
6016: PUSH
6017: LD_OWVAR 67
6021: ARRAY
6022: PUSH
6023: EMPTY
6024: LIST
6025: LIST
6026: LIST
6027: LIST
6028: PUSH
6029: LD_INT 14
6031: PUSH
6032: LD_INT 1
6034: PUSH
6035: LD_INT 2
6037: PUSH
6038: LD_INT 26
6040: PUSH
6041: LD_INT 26
6043: PUSH
6044: LD_INT 29
6046: PUSH
6047: LD_INT 29
6049: PUSH
6050: EMPTY
6051: LIST
6052: LIST
6053: LIST
6054: LIST
6055: PUSH
6056: LD_OWVAR 67
6060: ARRAY
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: LIST
6066: LIST
6067: PUSH
6068: LD_INT 13
6070: PUSH
6071: LD_INT 1
6073: PUSH
6074: LD_INT 2
6076: PUSH
6077: LD_INT 26
6079: PUSH
6080: LD_INT 29
6082: PUSH
6083: LD_INT 29
6085: PUSH
6086: LD_INT 29
6088: PUSH
6089: EMPTY
6090: LIST
6091: LIST
6092: LIST
6093: LIST
6094: PUSH
6095: LD_OWVAR 67
6099: ARRAY
6100: PUSH
6101: EMPTY
6102: LIST
6103: LIST
6104: LIST
6105: LIST
6106: PUSH
6107: LD_INT 13
6109: PUSH
6110: LD_INT 1
6112: PUSH
6113: LD_INT 2
6115: PUSH
6116: LD_INT 29
6118: PUSH
6119: EMPTY
6120: LIST
6121: LIST
6122: LIST
6123: LIST
6124: PUSH
6125: LD_INT 14
6127: PUSH
6128: LD_INT 1
6130: PUSH
6131: LD_INT 2
6133: PUSH
6134: LD_INT 26
6136: PUSH
6137: EMPTY
6138: LIST
6139: LIST
6140: LIST
6141: LIST
6142: PUSH
6143: EMPTY
6144: LIST
6145: LIST
6146: LIST
6147: LIST
6148: LIST
6149: LIST
6150: PPUSH
6151: CALL 61548 0 2
// end ; repeat wait ( 0 0$1 ) ;
6155: LD_INT 35
6157: PPUSH
6158: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
6162: LD_INT 3
6164: PPUSH
6165: LD_INT 1
6167: PPUSH
6168: CALL 62966 0 2
6172: PUSH
6173: LD_INT 6
6175: GREATEREQUAL
6176: IFFALSE 6155
// wait ( 0 0$30 ) ;
6178: LD_INT 1050
6180: PPUSH
6181: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6185: LD_ADDR_VAR 0 2
6189: PUSH
6190: LD_INT 3
6192: PPUSH
6193: LD_INT 1
6195: PPUSH
6196: CALL 62966 0 2
6200: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6201: LD_ADDR_EXP 119
6205: PUSH
6206: LD_EXP 119
6210: PPUSH
6211: LD_INT 3
6213: PPUSH
6214: LD_EXP 119
6218: PUSH
6219: LD_INT 3
6221: ARRAY
6222: PUSH
6223: LD_VAR 0 2
6227: DIFF
6228: PPUSH
6229: CALL_OW 1
6233: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6234: LD_ADDR_VAR 0 3
6238: PUSH
6239: LD_INT 0
6241: PPUSH
6242: LD_INT 2
6244: PPUSH
6245: CALL_OW 12
6249: ST_TO_ADDR
// if target then
6250: LD_VAR 0 3
6254: IFFALSE 6391
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6256: LD_ADDR_VAR 0 2
6260: PUSH
6261: LD_VAR 0 2
6265: PPUSH
6266: LD_INT 24
6268: PUSH
6269: LD_INT 250
6271: PUSH
6272: EMPTY
6273: LIST
6274: LIST
6275: PPUSH
6276: CALL_OW 72
6280: ST_TO_ADDR
// if not tmp then
6281: LD_VAR 0 2
6285: NOT
6286: IFFALSE 6290
// break ;
6288: GO 6389
// for i in tmp do
6290: LD_ADDR_VAR 0 1
6294: PUSH
6295: LD_VAR 0 2
6299: PUSH
6300: FOR_IN
6301: IFFALSE 6341
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6303: LD_VAR 0 1
6307: PPUSH
6308: LD_INT 89
6310: PPUSH
6311: LD_INT 71
6313: PPUSH
6314: CALL_OW 297
6318: PUSH
6319: LD_INT 9
6321: GREATER
6322: IFFALSE 6339
// ComMoveXY ( i , 89 , 71 ) ;
6324: LD_VAR 0 1
6328: PPUSH
6329: LD_INT 89
6331: PPUSH
6332: LD_INT 71
6334: PPUSH
6335: CALL_OW 111
6339: GO 6300
6341: POP
6342: POP
// wait ( 0 0$1 ) ;
6343: LD_INT 35
6345: PPUSH
6346: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6350: LD_VAR 0 2
6354: PPUSH
6355: LD_INT 92
6357: PUSH
6358: LD_INT 89
6360: PUSH
6361: LD_INT 71
6363: PUSH
6364: LD_INT 9
6366: PUSH
6367: EMPTY
6368: LIST
6369: LIST
6370: LIST
6371: LIST
6372: PPUSH
6373: CALL_OW 72
6377: PUSH
6378: LD_VAR 0 2
6382: PUSH
6383: LD_INT 1
6385: MINUS
6386: GREATEREQUAL
6387: IFFALSE 6256
// end else
6389: GO 6524
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6391: LD_ADDR_VAR 0 2
6395: PUSH
6396: LD_VAR 0 2
6400: PPUSH
6401: LD_INT 24
6403: PUSH
6404: LD_INT 250
6406: PUSH
6407: EMPTY
6408: LIST
6409: LIST
6410: PPUSH
6411: CALL_OW 72
6415: ST_TO_ADDR
// if not tmp then
6416: LD_VAR 0 2
6420: NOT
6421: IFFALSE 6425
// break ;
6423: GO 6524
// for i in tmp do
6425: LD_ADDR_VAR 0 1
6429: PUSH
6430: LD_VAR 0 2
6434: PUSH
6435: FOR_IN
6436: IFFALSE 6476
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6438: LD_VAR 0 1
6442: PPUSH
6443: LD_INT 125
6445: PPUSH
6446: LD_INT 129
6448: PPUSH
6449: CALL_OW 297
6453: PUSH
6454: LD_INT 9
6456: GREATER
6457: IFFALSE 6474
// ComMoveXY ( i , 125 , 129 ) ;
6459: LD_VAR 0 1
6463: PPUSH
6464: LD_INT 125
6466: PPUSH
6467: LD_INT 129
6469: PPUSH
6470: CALL_OW 111
6474: GO 6435
6476: POP
6477: POP
// wait ( 0 0$1 ) ;
6478: LD_INT 35
6480: PPUSH
6481: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6485: LD_VAR 0 2
6489: PPUSH
6490: LD_INT 92
6492: PUSH
6493: LD_INT 125
6495: PUSH
6496: LD_INT 129
6498: PUSH
6499: LD_INT 9
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PPUSH
6508: CALL_OW 72
6512: PUSH
6513: LD_VAR 0 2
6517: PUSH
6518: LD_INT 1
6520: MINUS
6521: GREATEREQUAL
6522: IFFALSE 6391
// end ; repeat wait ( 0 0$1 ) ;
6524: LD_INT 35
6526: PPUSH
6527: CALL_OW 67
// for i in tmp do
6531: LD_ADDR_VAR 0 1
6535: PUSH
6536: LD_VAR 0 2
6540: PUSH
6541: FOR_IN
6542: IFFALSE 6624
// begin if GetLives ( i ) > 251 then
6544: LD_VAR 0 1
6548: PPUSH
6549: CALL_OW 256
6553: PUSH
6554: LD_INT 251
6556: GREATER
6557: IFFALSE 6595
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6559: LD_VAR 0 1
6563: PPUSH
6564: LD_INT 81
6566: PUSH
6567: LD_INT 8
6569: PUSH
6570: EMPTY
6571: LIST
6572: LIST
6573: PPUSH
6574: CALL_OW 69
6578: PPUSH
6579: LD_VAR 0 1
6583: PPUSH
6584: CALL_OW 74
6588: PPUSH
6589: CALL_OW 115
6593: GO 6622
// if IsDead ( i ) then
6595: LD_VAR 0 1
6599: PPUSH
6600: CALL_OW 301
6604: IFFALSE 6622
// tmp := tmp diff i ;
6606: LD_ADDR_VAR 0 2
6610: PUSH
6611: LD_VAR 0 2
6615: PUSH
6616: LD_VAR 0 1
6620: DIFF
6621: ST_TO_ADDR
// end ;
6622: GO 6541
6624: POP
6625: POP
// until not tmp ;
6626: LD_VAR 0 2
6630: NOT
6631: IFFALSE 6524
// end ;
6633: PPOPN 3
6635: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6636: LD_EXP 22
6640: NOT
6641: PUSH
6642: LD_EXP 15
6646: PUSH
6647: LD_INT 6
6649: GREATEREQUAL
6650: AND
6651: PUSH
6652: LD_OWVAR 67
6656: PUSH
6657: LD_INT 1
6659: GREATER
6660: AND
6661: IFFALSE 7194
6663: GO 6665
6665: DISABLE
6666: LD_INT 0
6668: PPUSH
6669: PPUSH
6670: PPUSH
// begin enable ;
6671: ENABLE
// tmp := [ ] ;
6672: LD_ADDR_VAR 0 3
6676: PUSH
6677: EMPTY
6678: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6679: LD_ADDR_VAR 0 1
6683: PUSH
6684: DOUBLE
6685: LD_INT 1
6687: DEC
6688: ST_TO_ADDR
6689: LD_INT 4
6691: PUSH
6692: LD_INT 6
6694: PUSH
6695: LD_INT 7
6697: PUSH
6698: LD_INT 8
6700: PUSH
6701: EMPTY
6702: LIST
6703: LIST
6704: LIST
6705: LIST
6706: PUSH
6707: LD_OWVAR 67
6711: ARRAY
6712: PUSH
6713: FOR_TO
6714: IFFALSE 6874
// begin uc_side := 8 ;
6716: LD_ADDR_OWVAR 20
6720: PUSH
6721: LD_INT 8
6723: ST_TO_ADDR
// uc_nation := 2 ;
6724: LD_ADDR_OWVAR 21
6728: PUSH
6729: LD_INT 2
6731: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6732: LD_INT 13
6734: PUSH
6735: LD_INT 14
6737: PUSH
6738: EMPTY
6739: LIST
6740: LIST
6741: PUSH
6742: LD_INT 1
6744: PPUSH
6745: LD_INT 2
6747: PPUSH
6748: CALL_OW 12
6752: ARRAY
6753: PPUSH
6754: LD_INT 1
6756: PPUSH
6757: LD_INT 5
6759: PPUSH
6760: LD_INT 27
6762: PUSH
6763: LD_INT 28
6765: PUSH
6766: LD_INT 26
6768: PUSH
6769: LD_INT 25
6771: PUSH
6772: EMPTY
6773: LIST
6774: LIST
6775: LIST
6776: LIST
6777: PUSH
6778: LD_INT 1
6780: PPUSH
6781: LD_INT 4
6783: PPUSH
6784: CALL_OW 12
6788: ARRAY
6789: PPUSH
6790: LD_INT 88
6792: PPUSH
6793: CALL 72814 0 5
// un := CreateVehicle ;
6797: LD_ADDR_VAR 0 2
6801: PUSH
6802: CALL_OW 45
6806: ST_TO_ADDR
// tmp := tmp ^ un ;
6807: LD_ADDR_VAR 0 3
6811: PUSH
6812: LD_VAR 0 3
6816: PUSH
6817: LD_VAR 0 2
6821: ADD
6822: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6823: LD_VAR 0 2
6827: PPUSH
6828: LD_INT 3
6830: PPUSH
6831: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6835: LD_VAR 0 2
6839: PPUSH
6840: LD_INT 30
6842: PPUSH
6843: LD_INT 0
6845: PPUSH
6846: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6850: LD_VAR 0 2
6854: PPUSH
6855: LD_INT 16
6857: PPUSH
6858: LD_INT 11
6860: PPUSH
6861: CALL_OW 111
// wait ( 0 0$2 ) ;
6865: LD_INT 70
6867: PPUSH
6868: CALL_OW 67
// end ;
6872: GO 6713
6874: POP
6875: POP
// for i = 1 to Difficulty do
6876: LD_ADDR_VAR 0 1
6880: PUSH
6881: DOUBLE
6882: LD_INT 1
6884: DEC
6885: ST_TO_ADDR
6886: LD_OWVAR 67
6890: PUSH
6891: FOR_TO
6892: IFFALSE 7021
// begin uc_side := 8 ;
6894: LD_ADDR_OWVAR 20
6898: PUSH
6899: LD_INT 8
6901: ST_TO_ADDR
// uc_nation := 2 ;
6902: LD_ADDR_OWVAR 21
6906: PUSH
6907: LD_INT 2
6909: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
6910: LD_INT 0
6912: PPUSH
6913: LD_INT 8
6915: PPUSH
6916: LD_INT 8
6918: PUSH
6919: LD_INT 8
6921: PUSH
6922: LD_INT 9
6924: PUSH
6925: LD_INT 10
6927: PUSH
6928: EMPTY
6929: LIST
6930: LIST
6931: LIST
6932: LIST
6933: PUSH
6934: LD_OWVAR 67
6938: ARRAY
6939: PPUSH
6940: CALL_OW 380
// un := CreateHuman ;
6944: LD_ADDR_VAR 0 2
6948: PUSH
6949: CALL_OW 44
6953: ST_TO_ADDR
// tmp := tmp ^ un ;
6954: LD_ADDR_VAR 0 3
6958: PUSH
6959: LD_VAR 0 3
6963: PUSH
6964: LD_VAR 0 2
6968: ADD
6969: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6970: LD_VAR 0 2
6974: PPUSH
6975: LD_INT 3
6977: PPUSH
6978: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6982: LD_VAR 0 2
6986: PPUSH
6987: LD_INT 30
6989: PPUSH
6990: LD_INT 0
6992: PPUSH
6993: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6997: LD_VAR 0 2
7001: PPUSH
7002: LD_INT 16
7004: PPUSH
7005: LD_INT 11
7007: PPUSH
7008: CALL_OW 111
// wait ( 0 0$2 ) ;
7012: LD_INT 70
7014: PPUSH
7015: CALL_OW 67
// end ;
7019: GO 6891
7021: POP
7022: POP
// repeat wait ( 0 0$1 ) ;
7023: LD_INT 35
7025: PPUSH
7026: CALL_OW 67
// if legionDestroyed then
7030: LD_EXP 22
7034: IFFALSE 7038
// exit ;
7036: GO 7194
// for i in tmp do
7038: LD_ADDR_VAR 0 1
7042: PUSH
7043: LD_VAR 0 3
7047: PUSH
7048: FOR_IN
7049: IFFALSE 7185
// begin if GetLives ( i ) > 250 then
7051: LD_VAR 0 1
7055: PPUSH
7056: CALL_OW 256
7060: PUSH
7061: LD_INT 250
7063: GREATER
7064: IFFALSE 7156
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
7066: LD_INT 81
7068: PUSH
7069: LD_INT 8
7071: PUSH
7072: EMPTY
7073: LIST
7074: LIST
7075: PUSH
7076: LD_INT 91
7078: PUSH
7079: LD_VAR 0 1
7083: PUSH
7084: LD_INT 10
7086: PUSH
7087: EMPTY
7088: LIST
7089: LIST
7090: LIST
7091: PUSH
7092: EMPTY
7093: LIST
7094: LIST
7095: PPUSH
7096: CALL_OW 69
7100: NOT
7101: IFFALSE 7120
// ComAgressiveMove ( i , 67 , 110 ) else
7103: LD_VAR 0 1
7107: PPUSH
7108: LD_INT 67
7110: PPUSH
7111: LD_INT 110
7113: PPUSH
7114: CALL_OW 114
7118: GO 7154
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7120: LD_VAR 0 1
7124: PPUSH
7125: LD_INT 81
7127: PUSH
7128: LD_INT 8
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: PPUSH
7135: CALL_OW 69
7139: PPUSH
7140: LD_VAR 0 1
7144: PPUSH
7145: CALL_OW 74
7149: PPUSH
7150: CALL_OW 115
// end else
7154: GO 7183
// if IsDead ( i ) then
7156: LD_VAR 0 1
7160: PPUSH
7161: CALL_OW 301
7165: IFFALSE 7183
// tmp := tmp diff i ;
7167: LD_ADDR_VAR 0 3
7171: PUSH
7172: LD_VAR 0 3
7176: PUSH
7177: LD_VAR 0 1
7181: DIFF
7182: ST_TO_ADDR
// end ;
7183: GO 7048
7185: POP
7186: POP
// until not tmp ;
7187: LD_VAR 0 3
7191: NOT
7192: IFFALSE 7023
// end ; end_of_file
7194: PPOPN 3
7196: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
7197: LD_INT 0
7199: PPUSH
7200: PPUSH
7201: PPUSH
7202: PPUSH
7203: PPUSH
7204: PPUSH
7205: PPUSH
7206: PPUSH
7207: PPUSH
7208: PPUSH
// side := 3 ;
7209: LD_ADDR_VAR 0 6
7213: PUSH
7214: LD_INT 3
7216: ST_TO_ADDR
// uc_side := side ;
7217: LD_ADDR_OWVAR 20
7221: PUSH
7222: LD_VAR 0 6
7226: ST_TO_ADDR
// uc_nation := 3 ;
7227: LD_ADDR_OWVAR 21
7231: PUSH
7232: LD_INT 3
7234: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7235: LD_ADDR_VAR 0 2
7239: PUSH
7240: LD_INT 22
7242: PUSH
7243: LD_VAR 0 6
7247: PUSH
7248: EMPTY
7249: LIST
7250: LIST
7251: PUSH
7252: LD_INT 21
7254: PUSH
7255: LD_INT 3
7257: PUSH
7258: EMPTY
7259: LIST
7260: LIST
7261: PUSH
7262: EMPTY
7263: LIST
7264: LIST
7265: PPUSH
7266: CALL_OW 69
7270: PUSH
7271: FOR_IN
7272: IFFALSE 7288
// SetBLevel ( i , 10 ) ;
7274: LD_VAR 0 2
7278: PPUSH
7279: LD_INT 10
7281: PPUSH
7282: CALL_OW 241
7286: GO 7271
7288: POP
7289: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7290: LD_ADDR_VAR 0 10
7294: PUSH
7295: LD_INT 22
7297: PUSH
7298: LD_VAR 0 6
7302: PUSH
7303: EMPTY
7304: LIST
7305: LIST
7306: PUSH
7307: LD_INT 30
7309: PUSH
7310: LD_INT 34
7312: PUSH
7313: EMPTY
7314: LIST
7315: LIST
7316: PUSH
7317: EMPTY
7318: LIST
7319: LIST
7320: PPUSH
7321: CALL_OW 69
7325: ST_TO_ADDR
// if teleport then
7326: LD_VAR 0 10
7330: IFFALSE 7351
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7332: LD_VAR 0 10
7336: PUSH
7337: LD_INT 1
7339: ARRAY
7340: PPUSH
7341: LD_INT 123
7343: PPUSH
7344: LD_INT 122
7346: PPUSH
7347: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7351: LD_ADDR_EXP 66
7355: PUSH
7356: LD_STRING Platonov
7358: PPUSH
7359: CALL_OW 25
7363: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7364: LD_ADDR_EXP 67
7368: PUSH
7369: LD_STRING Kovalyuk
7371: PPUSH
7372: CALL_OW 25
7376: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7377: LD_ADDR_EXP 69
7381: PUSH
7382: LD_STRING Yakotich
7384: PPUSH
7385: LD_EXP 1
7389: NOT
7390: PPUSH
7391: LD_STRING 09_
7393: PPUSH
7394: CALL 67974 0 3
7398: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7399: LD_ADDR_EXP 68
7403: PUSH
7404: LD_STRING Bystrov
7406: PPUSH
7407: CALL_OW 25
7411: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7412: LD_ADDR_EXP 70
7416: PUSH
7417: LD_STRING Gleb
7419: PPUSH
7420: CALL_OW 25
7424: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7425: LD_STRING 03_Cornel
7427: PPUSH
7428: CALL_OW 28
7432: IFFALSE 7480
// begin Bierezov := NewCharacter ( Mikhail ) ;
7434: LD_ADDR_EXP 71
7438: PUSH
7439: LD_STRING Mikhail
7441: PPUSH
7442: CALL_OW 25
7446: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7447: LD_EXP 71
7451: PPUSH
7452: LD_INT 197
7454: PPUSH
7455: LD_INT 111
7457: PPUSH
7458: LD_INT 9
7460: PPUSH
7461: LD_INT 0
7463: PPUSH
7464: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7468: LD_EXP 71
7472: PPUSH
7473: LD_INT 3
7475: PPUSH
7476: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7480: LD_EXP 66
7484: PPUSH
7485: LD_INT 126
7487: PPUSH
7488: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7492: LD_EXP 67
7496: PPUSH
7497: LD_INT 134
7499: PPUSH
7500: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7504: LD_EXP 69
7508: PPUSH
7509: LD_INT 197
7511: PPUSH
7512: LD_INT 111
7514: PPUSH
7515: LD_INT 9
7517: PPUSH
7518: LD_INT 0
7520: PPUSH
7521: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7525: LD_EXP 68
7529: PPUSH
7530: LD_INT 197
7532: PPUSH
7533: LD_INT 111
7535: PPUSH
7536: LD_INT 9
7538: PPUSH
7539: LD_INT 0
7541: PPUSH
7542: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7546: LD_EXP 70
7550: PPUSH
7551: LD_INT 197
7553: PPUSH
7554: LD_INT 111
7556: PPUSH
7557: LD_INT 9
7559: PPUSH
7560: LD_INT 0
7562: PPUSH
7563: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7567: LD_ADDR_VAR 0 5
7571: PUSH
7572: LD_INT 126
7574: PPUSH
7575: LD_INT 4
7577: PPUSH
7578: LD_STRING zhukov
7580: PPUSH
7581: LD_INT 9
7583: PUSH
7584: LD_INT 10
7586: PUSH
7587: LD_INT 10
7589: PUSH
7590: LD_INT 10
7592: PUSH
7593: EMPTY
7594: LIST
7595: LIST
7596: LIST
7597: LIST
7598: PUSH
7599: LD_OWVAR 67
7603: ARRAY
7604: PPUSH
7605: LD_INT 90000
7607: PUSH
7608: LD_INT 1000
7610: PUSH
7611: LD_INT 300
7613: PUSH
7614: EMPTY
7615: LIST
7616: LIST
7617: LIST
7618: PPUSH
7619: LD_INT 18
7621: PUSH
7622: LD_INT 8
7624: PUSH
7625: LD_INT 13
7627: PUSH
7628: LD_INT 8
7630: PUSH
7631: EMPTY
7632: LIST
7633: LIST
7634: LIST
7635: LIST
7636: PPUSH
7637: CALL 76258 0 6
7641: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Bystrov , Gleb , Bierezov ] ) ;
7642: LD_ADDR_EXP 100
7646: PUSH
7647: LD_EXP 100
7651: PPUSH
7652: LD_INT 2
7654: PPUSH
7655: LD_VAR 0 5
7659: PUSH
7660: LD_EXP 69
7664: PUSH
7665: LD_EXP 68
7669: PUSH
7670: LD_EXP 70
7674: PUSH
7675: LD_EXP 71
7679: PUSH
7680: EMPTY
7681: LIST
7682: LIST
7683: LIST
7684: LIST
7685: UNION
7686: PPUSH
7687: CALL_OW 1
7691: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7692: LD_ADDR_VAR 0 4
7696: PUSH
7697: LD_INT 267
7699: PPUSH
7700: CALL_OW 274
7704: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7705: LD_VAR 0 4
7709: PPUSH
7710: LD_INT 1
7712: PPUSH
7713: LD_INT 5000
7715: PPUSH
7716: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7720: LD_VAR 0 4
7724: PPUSH
7725: LD_INT 2
7727: PPUSH
7728: LD_INT 200
7730: PPUSH
7731: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7735: LD_VAR 0 4
7739: PPUSH
7740: LD_INT 3
7742: PPUSH
7743: LD_INT 200
7745: PPUSH
7746: CALL_OW 277
// for i := 1 to 6 do
7750: LD_ADDR_VAR 0 2
7754: PUSH
7755: DOUBLE
7756: LD_INT 1
7758: DEC
7759: ST_TO_ADDR
7760: LD_INT 6
7762: PUSH
7763: FOR_TO
7764: IFFALSE 7847
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
7766: LD_INT 0
7768: PPUSH
7769: LD_INT 8
7771: PUSH
7772: LD_INT 9
7774: PUSH
7775: LD_INT 10
7777: PUSH
7778: LD_INT 10
7780: PUSH
7781: EMPTY
7782: LIST
7783: LIST
7784: LIST
7785: LIST
7786: PUSH
7787: LD_OWVAR 67
7791: ARRAY
7792: PPUSH
7793: CALL_OW 381
// un := CreateHuman ;
7797: LD_ADDR_VAR 0 8
7801: PUSH
7802: CALL_OW 44
7806: ST_TO_ADDR
// if i mod 2 = 0 then
7807: LD_VAR 0 2
7811: PUSH
7812: LD_INT 2
7814: MOD
7815: PUSH
7816: LD_INT 0
7818: EQUAL
7819: IFFALSE 7833
// SetClass ( un , class_bazooker ) ;
7821: LD_VAR 0 8
7825: PPUSH
7826: LD_INT 9
7828: PPUSH
7829: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
7833: LD_VAR 0 8
7837: PPUSH
7838: LD_INT 460
7840: PPUSH
7841: CALL_OW 52
// end ;
7845: GO 7763
7847: POP
7848: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
7849: LD_INT 21
7851: PPUSH
7852: LD_INT 3
7854: PPUSH
7855: LD_INT 3
7857: PPUSH
7858: LD_INT 52
7860: PPUSH
7861: LD_INT 100
7863: PPUSH
7864: CALL 72814 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
7868: CALL_OW 45
7872: PPUSH
7873: LD_INT 259
7875: PPUSH
7876: LD_INT 145
7878: PPUSH
7879: LD_INT 3
7881: PPUSH
7882: LD_INT 0
7884: PPUSH
7885: CALL 107406 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
7889: CALL_OW 45
7893: PPUSH
7894: LD_INT 245
7896: PPUSH
7897: LD_INT 139
7899: PPUSH
7900: LD_INT 3
7902: PPUSH
7903: LD_INT 0
7905: PPUSH
7906: CALL 107406 0 5
// behemoths := [ ] ;
7910: LD_ADDR_EXP 74
7914: PUSH
7915: EMPTY
7916: ST_TO_ADDR
// behemothBuilders := [ ] ;
7917: LD_ADDR_EXP 75
7921: PUSH
7922: EMPTY
7923: ST_TO_ADDR
// if Kovalyuk then
7924: LD_EXP 67
7928: IFFALSE 7950
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7930: LD_ADDR_EXP 75
7934: PUSH
7935: LD_EXP 75
7939: PPUSH
7940: LD_EXP 67
7944: PPUSH
7945: CALL 105266 0 2
7949: ST_TO_ADDR
// j := 3 ;
7950: LD_ADDR_VAR 0 3
7954: PUSH
7955: LD_INT 3
7957: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7958: LD_ADDR_VAR 0 2
7962: PUSH
7963: LD_INT 22
7965: PUSH
7966: LD_INT 3
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: PUSH
7973: LD_INT 25
7975: PUSH
7976: LD_INT 3
7978: PUSH
7979: EMPTY
7980: LIST
7981: LIST
7982: PUSH
7983: EMPTY
7984: LIST
7985: LIST
7986: PPUSH
7987: CALL_OW 69
7991: PUSH
7992: LD_EXP 67
7996: DIFF
7997: PUSH
7998: FOR_IN
7999: IFFALSE 8049
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8001: LD_ADDR_EXP 75
8005: PUSH
8006: LD_EXP 75
8010: PPUSH
8011: LD_VAR 0 2
8015: PPUSH
8016: CALL 105266 0 2
8020: ST_TO_ADDR
// j := j - 1 ;
8021: LD_ADDR_VAR 0 3
8025: PUSH
8026: LD_VAR 0 3
8030: PUSH
8031: LD_INT 1
8033: MINUS
8034: ST_TO_ADDR
// if j = 0 then
8035: LD_VAR 0 3
8039: PUSH
8040: LD_INT 0
8042: EQUAL
8043: IFFALSE 8047
// break ;
8045: GO 8049
// end ;
8047: GO 7998
8049: POP
8050: POP
// end ;
8051: LD_VAR 0 1
8055: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8056: LD_INT 0
8058: PPUSH
8059: PPUSH
8060: PPUSH
8061: PPUSH
8062: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8063: LD_ADDR_VAR 0 4
8067: PUSH
8068: LD_INT 209
8070: PUSH
8071: LD_INT 149
8073: PUSH
8074: EMPTY
8075: LIST
8076: LIST
8077: PUSH
8078: LD_INT 219
8080: PUSH
8081: LD_INT 154
8083: PUSH
8084: EMPTY
8085: LIST
8086: LIST
8087: PUSH
8088: LD_INT 223
8090: PUSH
8091: LD_INT 149
8093: PUSH
8094: EMPTY
8095: LIST
8096: LIST
8097: PUSH
8098: LD_INT 232
8100: PUSH
8101: LD_INT 155
8103: PUSH
8104: EMPTY
8105: LIST
8106: LIST
8107: PUSH
8108: EMPTY
8109: LIST
8110: LIST
8111: LIST
8112: LIST
8113: ST_TO_ADDR
// if not behemothBuilders then
8114: LD_EXP 75
8118: NOT
8119: IFFALSE 8123
// exit ;
8121: GO 8254
// j := 1 ;
8123: LD_ADDR_VAR 0 3
8127: PUSH
8128: LD_INT 1
8130: ST_TO_ADDR
// for i in behemothBuilders do
8131: LD_ADDR_VAR 0 2
8135: PUSH
8136: LD_EXP 75
8140: PUSH
8141: FOR_IN
8142: IFFALSE 8252
// begin if GetClass ( i ) <> class_mechanic then
8144: LD_VAR 0 2
8148: PPUSH
8149: CALL_OW 257
8153: PUSH
8154: LD_INT 3
8156: NONEQUAL
8157: IFFALSE 8171
// SetClass ( i , class_mechanic ) ;
8159: LD_VAR 0 2
8163: PPUSH
8164: LD_INT 3
8166: PPUSH
8167: CALL_OW 336
// if IsInUnit ( i ) then
8171: LD_VAR 0 2
8175: PPUSH
8176: CALL_OW 310
8180: IFFALSE 8191
// ComExitBuilding ( i ) ;
8182: LD_VAR 0 2
8186: PPUSH
8187: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8191: LD_VAR 0 2
8195: PPUSH
8196: LD_INT 37
8198: PPUSH
8199: LD_VAR 0 4
8203: PUSH
8204: LD_VAR 0 3
8208: ARRAY
8209: PUSH
8210: LD_INT 1
8212: ARRAY
8213: PPUSH
8214: LD_VAR 0 4
8218: PUSH
8219: LD_VAR 0 3
8223: ARRAY
8224: PUSH
8225: LD_INT 2
8227: ARRAY
8228: PPUSH
8229: LD_INT 0
8231: PPUSH
8232: CALL_OW 230
// j := j + 1 ;
8236: LD_ADDR_VAR 0 3
8240: PUSH
8241: LD_VAR 0 3
8245: PUSH
8246: LD_INT 1
8248: PLUS
8249: ST_TO_ADDR
// end ;
8250: GO 8141
8252: POP
8253: POP
// end ;
8254: LD_VAR 0 1
8258: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
8259: LD_INT 24
8261: PPUSH
8262: LD_INT 30
8264: PUSH
8265: LD_INT 37
8267: PUSH
8268: EMPTY
8269: LIST
8270: LIST
8271: PPUSH
8272: CALL_OW 70
8276: IFFALSE 8289
8278: GO 8280
8280: DISABLE
// behemothUnderConstruct := true ;
8281: LD_ADDR_EXP 26
8285: PUSH
8286: LD_INT 1
8288: ST_TO_ADDR
8289: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8290: LD_INT 3
8292: PPUSH
8293: CALL 105327 0 1
8297: PUSH
8298: LD_INT 22
8300: PUSH
8301: LD_INT 3
8303: PUSH
8304: EMPTY
8305: LIST
8306: LIST
8307: PUSH
8308: LD_INT 30
8310: PUSH
8311: LD_INT 37
8313: PUSH
8314: EMPTY
8315: LIST
8316: LIST
8317: PUSH
8318: EMPTY
8319: LIST
8320: LIST
8321: PPUSH
8322: CALL_OW 69
8326: NOT
8327: AND
8328: IFFALSE 8514
8330: GO 8332
8332: DISABLE
8333: LD_INT 0
8335: PPUSH
8336: PPUSH
// begin enable ;
8337: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8338: LD_ADDR_VAR 0 2
8342: PUSH
8343: LD_INT 3
8345: PPUSH
8346: CALL 105327 0 1
8350: ST_TO_ADDR
// for i in tmp do
8351: LD_ADDR_VAR 0 1
8355: PUSH
8356: LD_VAR 0 2
8360: PUSH
8361: FOR_IN
8362: IFFALSE 8512
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8364: LD_VAR 0 1
8368: PPUSH
8369: LD_INT 9
8371: PPUSH
8372: CALL_OW 308
8376: PUSH
8377: LD_VAR 0 1
8381: PPUSH
8382: CALL_OW 110
8386: PUSH
8387: LD_INT 2
8389: EQUAL
8390: NOT
8391: AND
8392: IFFALSE 8406
// SetTag ( i , 2 ) ;
8394: LD_VAR 0 1
8398: PPUSH
8399: LD_INT 2
8401: PPUSH
8402: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8406: LD_INT 81
8408: PUSH
8409: LD_INT 3
8411: PUSH
8412: EMPTY
8413: LIST
8414: LIST
8415: PUSH
8416: LD_INT 91
8418: PUSH
8419: LD_VAR 0 1
8423: PUSH
8424: LD_INT 12
8426: PUSH
8427: EMPTY
8428: LIST
8429: LIST
8430: LIST
8431: PUSH
8432: EMPTY
8433: LIST
8434: LIST
8435: PPUSH
8436: CALL_OW 69
8440: NOT
8441: PUSH
8442: LD_VAR 0 1
8446: PPUSH
8447: CALL_OW 110
8451: PUSH
8452: LD_INT 2
8454: EQUAL
8455: NOT
8456: AND
8457: IFFALSE 8476
// ComAgressiveMove ( i , 64 , 93 ) else
8459: LD_VAR 0 1
8463: PPUSH
8464: LD_INT 64
8466: PPUSH
8467: LD_INT 93
8469: PPUSH
8470: CALL_OW 114
8474: GO 8510
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8476: LD_VAR 0 1
8480: PPUSH
8481: LD_INT 81
8483: PUSH
8484: LD_INT 3
8486: PUSH
8487: EMPTY
8488: LIST
8489: LIST
8490: PPUSH
8491: CALL_OW 69
8495: PPUSH
8496: LD_VAR 0 1
8500: PPUSH
8501: CALL_OW 74
8505: PPUSH
8506: CALL_OW 115
// end ;
8510: GO 8361
8512: POP
8513: POP
// end ;
8514: PPOPN 2
8516: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8517: LD_INT 0
8519: PPUSH
8520: PPUSH
8521: PPUSH
// result := [ ] ;
8522: LD_ADDR_VAR 0 2
8526: PUSH
8527: EMPTY
8528: ST_TO_ADDR
// uc_side := 6 ;
8529: LD_ADDR_OWVAR 20
8533: PUSH
8534: LD_INT 6
8536: ST_TO_ADDR
// uc_nation := 3 ;
8537: LD_ADDR_OWVAR 21
8541: PUSH
8542: LD_INT 3
8544: ST_TO_ADDR
// case strength of 1 :
8545: LD_VAR 0 1
8549: PUSH
8550: LD_INT 1
8552: DOUBLE
8553: EQUAL
8554: IFTRUE 8558
8556: GO 8700
8558: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8559: LD_ADDR_VAR 0 3
8563: PUSH
8564: DOUBLE
8565: LD_INT 1
8567: DEC
8568: ST_TO_ADDR
8569: LD_INT 4
8571: PUSH
8572: LD_INT 5
8574: PUSH
8575: LD_INT 6
8577: PUSH
8578: LD_INT 7
8580: PUSH
8581: EMPTY
8582: LIST
8583: LIST
8584: LIST
8585: LIST
8586: PUSH
8587: LD_OWVAR 67
8591: ARRAY
8592: PUSH
8593: FOR_TO
8594: IFFALSE 8696
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8596: LD_INT 22
8598: PUSH
8599: LD_INT 24
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: PUSH
8606: LD_VAR 0 3
8610: PUSH
8611: LD_INT 2
8613: MOD
8614: PUSH
8615: LD_INT 1
8617: PLUS
8618: ARRAY
8619: PPUSH
8620: LD_INT 1
8622: PUSH
8623: LD_INT 3
8625: PUSH
8626: EMPTY
8627: LIST
8628: LIST
8629: PUSH
8630: LD_INT 1
8632: PPUSH
8633: LD_INT 2
8635: PPUSH
8636: CALL_OW 12
8640: ARRAY
8641: PPUSH
8642: LD_INT 3
8644: PPUSH
8645: LD_INT 43
8647: PUSH
8648: LD_INT 44
8650: PUSH
8651: LD_INT 45
8653: PUSH
8654: EMPTY
8655: LIST
8656: LIST
8657: LIST
8658: PUSH
8659: LD_INT 1
8661: PPUSH
8662: LD_INT 3
8664: PPUSH
8665: CALL_OW 12
8669: ARRAY
8670: PPUSH
8671: LD_INT 80
8673: PPUSH
8674: CALL 72814 0 5
// result := result union CreateVehicle ;
8678: LD_ADDR_VAR 0 2
8682: PUSH
8683: LD_VAR 0 2
8687: PUSH
8688: CALL_OW 45
8692: UNION
8693: ST_TO_ADDR
// end ;
8694: GO 8593
8696: POP
8697: POP
// end ; 2 :
8698: GO 9695
8700: LD_INT 2
8702: DOUBLE
8703: EQUAL
8704: IFTRUE 8708
8706: GO 8876
8708: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8709: LD_ADDR_VAR 0 3
8713: PUSH
8714: DOUBLE
8715: LD_INT 1
8717: DEC
8718: ST_TO_ADDR
8719: LD_INT 5
8721: PUSH
8722: LD_INT 6
8724: PUSH
8725: LD_INT 7
8727: PUSH
8728: LD_INT 8
8730: PUSH
8731: EMPTY
8732: LIST
8733: LIST
8734: LIST
8735: LIST
8736: PUSH
8737: LD_OWVAR 67
8741: ARRAY
8742: PUSH
8743: FOR_TO
8744: IFFALSE 8872
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
8746: LD_INT 22
8748: PUSH
8749: LD_INT 24
8751: PUSH
8752: LD_INT 24
8754: PUSH
8755: EMPTY
8756: LIST
8757: LIST
8758: LIST
8759: PUSH
8760: LD_VAR 0 3
8764: PUSH
8765: LD_INT 3
8767: MOD
8768: PUSH
8769: LD_INT 1
8771: PLUS
8772: ARRAY
8773: PPUSH
8774: LD_INT 1
8776: PUSH
8777: LD_INT 3
8779: PUSH
8780: EMPTY
8781: LIST
8782: LIST
8783: PUSH
8784: LD_INT 1
8786: PPUSH
8787: LD_INT 2
8789: PPUSH
8790: CALL_OW 12
8794: ARRAY
8795: PPUSH
8796: LD_INT 3
8798: PPUSH
8799: LD_INT 43
8801: PUSH
8802: LD_INT 44
8804: PUSH
8805: LD_INT 45
8807: PUSH
8808: LD_INT 44
8810: PUSH
8811: LD_INT 46
8813: PUSH
8814: LD_INT 46
8816: PUSH
8817: LD_INT 49
8819: PUSH
8820: LD_INT 49
8822: PUSH
8823: EMPTY
8824: LIST
8825: LIST
8826: LIST
8827: LIST
8828: LIST
8829: LIST
8830: LIST
8831: LIST
8832: PUSH
8833: LD_VAR 0 3
8837: PUSH
8838: LD_INT 8
8840: MOD
8841: PUSH
8842: LD_INT 1
8844: PLUS
8845: ARRAY
8846: PPUSH
8847: LD_INT 80
8849: PPUSH
8850: CALL 72814 0 5
// result := result union CreateVehicle ;
8854: LD_ADDR_VAR 0 2
8858: PUSH
8859: LD_VAR 0 2
8863: PUSH
8864: CALL_OW 45
8868: UNION
8869: ST_TO_ADDR
// end ;
8870: GO 8743
8872: POP
8873: POP
// end ; 3 :
8874: GO 9695
8876: LD_INT 3
8878: DOUBLE
8879: EQUAL
8880: IFTRUE 8884
8882: GO 9056
8884: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
8885: LD_ADDR_VAR 0 3
8889: PUSH
8890: DOUBLE
8891: LD_INT 1
8893: DEC
8894: ST_TO_ADDR
8895: LD_INT 6
8897: PUSH
8898: LD_INT 7
8900: PUSH
8901: LD_INT 8
8903: PUSH
8904: LD_INT 9
8906: PUSH
8907: EMPTY
8908: LIST
8909: LIST
8910: LIST
8911: LIST
8912: PUSH
8913: LD_OWVAR 67
8917: ARRAY
8918: PUSH
8919: FOR_TO
8920: IFFALSE 9052
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
8922: LD_INT 22
8924: PUSH
8925: LD_INT 24
8927: PUSH
8928: LD_INT 24
8930: PUSH
8931: EMPTY
8932: LIST
8933: LIST
8934: LIST
8935: PUSH
8936: LD_VAR 0 3
8940: PUSH
8941: LD_INT 3
8943: MOD
8944: PUSH
8945: LD_INT 1
8947: PLUS
8948: ARRAY
8949: PPUSH
8950: LD_INT 1
8952: PUSH
8953: LD_INT 3
8955: PUSH
8956: EMPTY
8957: LIST
8958: LIST
8959: PUSH
8960: LD_INT 1
8962: PPUSH
8963: LD_INT 2
8965: PPUSH
8966: CALL_OW 12
8970: ARRAY
8971: PPUSH
8972: LD_INT 3
8974: PPUSH
8975: LD_INT 43
8977: PUSH
8978: LD_INT 47
8980: PUSH
8981: LD_INT 45
8983: PUSH
8984: LD_INT 45
8986: PUSH
8987: LD_INT 46
8989: PUSH
8990: LD_INT 46
8992: PUSH
8993: LD_INT 49
8995: PUSH
8996: LD_INT 49
8998: PUSH
8999: LD_INT 49
9001: PUSH
9002: EMPTY
9003: LIST
9004: LIST
9005: LIST
9006: LIST
9007: LIST
9008: LIST
9009: LIST
9010: LIST
9011: LIST
9012: PUSH
9013: LD_VAR 0 3
9017: PUSH
9018: LD_INT 9
9020: MOD
9021: PUSH
9022: LD_INT 1
9024: PLUS
9025: ARRAY
9026: PPUSH
9027: LD_INT 80
9029: PPUSH
9030: CALL 72814 0 5
// result := result union CreateVehicle ;
9034: LD_ADDR_VAR 0 2
9038: PUSH
9039: LD_VAR 0 2
9043: PUSH
9044: CALL_OW 45
9048: UNION
9049: ST_TO_ADDR
// end ;
9050: GO 8919
9052: POP
9053: POP
// end ; 4 :
9054: GO 9695
9056: LD_INT 4
9058: DOUBLE
9059: EQUAL
9060: IFTRUE 9064
9062: GO 9694
9064: POP
// begin uc_nation := 3 ;
9065: LD_ADDR_OWVAR 21
9069: PUSH
9070: LD_INT 3
9072: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
9073: LD_ADDR_VAR 0 3
9077: PUSH
9078: DOUBLE
9079: LD_INT 1
9081: DEC
9082: ST_TO_ADDR
9083: LD_INT 6
9085: PUSH
9086: LD_INT 8
9088: PUSH
9089: LD_INT 9
9091: PUSH
9092: LD_INT 10
9094: PUSH
9095: EMPTY
9096: LIST
9097: LIST
9098: LIST
9099: LIST
9100: PUSH
9101: LD_OWVAR 67
9105: ARRAY
9106: PUSH
9107: FOR_TO
9108: IFFALSE 9240
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9110: LD_INT 22
9112: PUSH
9113: LD_INT 24
9115: PUSH
9116: LD_INT 24
9118: PUSH
9119: EMPTY
9120: LIST
9121: LIST
9122: LIST
9123: PUSH
9124: LD_VAR 0 3
9128: PUSH
9129: LD_INT 3
9131: MOD
9132: PUSH
9133: LD_INT 1
9135: PLUS
9136: ARRAY
9137: PPUSH
9138: LD_INT 1
9140: PUSH
9141: LD_INT 3
9143: PUSH
9144: EMPTY
9145: LIST
9146: LIST
9147: PUSH
9148: LD_INT 1
9150: PPUSH
9151: LD_INT 2
9153: PPUSH
9154: CALL_OW 12
9158: ARRAY
9159: PPUSH
9160: LD_INT 3
9162: PPUSH
9163: LD_INT 45
9165: PUSH
9166: LD_INT 47
9168: PUSH
9169: LD_INT 47
9171: PUSH
9172: LD_INT 45
9174: PUSH
9175: LD_INT 46
9177: PUSH
9178: LD_INT 46
9180: PUSH
9181: LD_INT 49
9183: PUSH
9184: LD_INT 49
9186: PUSH
9187: LD_INT 49
9189: PUSH
9190: EMPTY
9191: LIST
9192: LIST
9193: LIST
9194: LIST
9195: LIST
9196: LIST
9197: LIST
9198: LIST
9199: LIST
9200: PUSH
9201: LD_VAR 0 3
9205: PUSH
9206: LD_INT 9
9208: MOD
9209: PUSH
9210: LD_INT 1
9212: PLUS
9213: ARRAY
9214: PPUSH
9215: LD_INT 80
9217: PPUSH
9218: CALL 72814 0 5
// result := result union CreateVehicle ;
9222: LD_ADDR_VAR 0 2
9226: PUSH
9227: LD_VAR 0 2
9231: PUSH
9232: CALL_OW 45
9236: UNION
9237: ST_TO_ADDR
// end ;
9238: GO 9107
9240: POP
9241: POP
// if not KappaStatus then
9242: LD_EXP 2
9246: NOT
9247: IFFALSE 9482
// begin uc_nation := 1 ;
9249: LD_ADDR_OWVAR 21
9253: PUSH
9254: LD_INT 1
9256: ST_TO_ADDR
// for i = 1 to 3 do
9257: LD_ADDR_VAR 0 3
9261: PUSH
9262: DOUBLE
9263: LD_INT 1
9265: DEC
9266: ST_TO_ADDR
9267: LD_INT 3
9269: PUSH
9270: FOR_TO
9271: IFFALSE 9407
// begin j := rand ( 0 , 1 ) ;
9273: LD_ADDR_VAR 0 4
9277: PUSH
9278: LD_INT 0
9280: PPUSH
9281: LD_INT 1
9283: PPUSH
9284: CALL_OW 12
9288: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9289: LD_INT 3
9291: PUSH
9292: LD_INT 5
9294: PUSH
9295: LD_INT 5
9297: PUSH
9298: LD_INT 4
9300: PUSH
9301: EMPTY
9302: LIST
9303: LIST
9304: LIST
9305: LIST
9306: PUSH
9307: LD_VAR 0 4
9311: PUSH
9312: LD_INT 1
9314: PPUSH
9315: LD_INT 3
9317: PPUSH
9318: CALL_OW 12
9322: PLUS
9323: ARRAY
9324: PPUSH
9325: LD_INT 1
9327: PUSH
9328: LD_INT 3
9330: PUSH
9331: EMPTY
9332: LIST
9333: LIST
9334: PUSH
9335: LD_INT 1
9337: PPUSH
9338: LD_INT 2
9340: PPUSH
9341: CALL_OW 12
9345: ARRAY
9346: PPUSH
9347: LD_INT 3
9349: PPUSH
9350: LD_INT 9
9352: PUSH
9353: LD_INT 7
9355: PUSH
9356: LD_INT 6
9358: PUSH
9359: EMPTY
9360: LIST
9361: LIST
9362: LIST
9363: PUSH
9364: LD_VAR 0 4
9368: PUSH
9369: LD_INT 1
9371: PPUSH
9372: LD_INT 2
9374: PPUSH
9375: CALL_OW 12
9379: PLUS
9380: ARRAY
9381: PPUSH
9382: LD_INT 85
9384: PPUSH
9385: CALL 72814 0 5
// result := result union CreateVehicle ;
9389: LD_ADDR_VAR 0 2
9393: PUSH
9394: LD_VAR 0 2
9398: PUSH
9399: CALL_OW 45
9403: UNION
9404: ST_TO_ADDR
// end ;
9405: GO 9270
9407: POP
9408: POP
// if vsevolodFirstAttack then
9409: LD_EXP 24
9413: IFFALSE 9480
// begin vsevolodFirstAttack := false ;
9415: LD_ADDR_EXP 24
9419: PUSH
9420: LD_INT 0
9422: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9423: LD_INT 5
9425: PPUSH
9426: LD_INT 3
9428: PPUSH
9429: LD_INT 1
9431: PPUSH
9432: LD_INT 6
9434: PPUSH
9435: LD_INT 100
9437: PPUSH
9438: CALL 72814 0 5
// sewiVeh := CreateVehicle ;
9442: LD_ADDR_EXP 73
9446: PUSH
9447: CALL_OW 45
9451: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9452: LD_EXP 73
9456: PPUSH
9457: LD_INT 1
9459: PPUSH
9460: CALL_OW 242
// result := result union sewiVeh ;
9464: LD_ADDR_VAR 0 2
9468: PUSH
9469: LD_VAR 0 2
9473: PUSH
9474: LD_EXP 73
9478: UNION
9479: ST_TO_ADDR
// end ; end else
9480: GO 9692
// if vsevolodFirstAttack then
9482: LD_EXP 24
9486: IFFALSE 9692
// begin vsevolodFirstAttack := false ;
9488: LD_ADDR_EXP 24
9492: PUSH
9493: LD_INT 0
9495: ST_TO_ADDR
// uc_nation := 3 ;
9496: LD_ADDR_OWVAR 21
9500: PUSH
9501: LD_INT 3
9503: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9504: LD_ADDR_VAR 0 3
9508: PUSH
9509: DOUBLE
9510: LD_INT 1
9512: DEC
9513: ST_TO_ADDR
9514: LD_INT 2
9516: PUSH
9517: LD_OWVAR 67
9521: PLUS
9522: PUSH
9523: FOR_TO
9524: IFFALSE 9632
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9526: LD_INT 22
9528: PUSH
9529: LD_INT 24
9531: PUSH
9532: LD_INT 24
9534: PUSH
9535: EMPTY
9536: LIST
9537: LIST
9538: LIST
9539: PUSH
9540: LD_VAR 0 3
9544: PUSH
9545: LD_INT 3
9547: MOD
9548: PUSH
9549: LD_INT 1
9551: PLUS
9552: ARRAY
9553: PPUSH
9554: LD_INT 1
9556: PUSH
9557: LD_INT 3
9559: PUSH
9560: EMPTY
9561: LIST
9562: LIST
9563: PUSH
9564: LD_INT 1
9566: PPUSH
9567: LD_INT 2
9569: PPUSH
9570: CALL_OW 12
9574: ARRAY
9575: PPUSH
9576: LD_INT 1
9578: PPUSH
9579: LD_INT 45
9581: PUSH
9582: LD_INT 47
9584: PUSH
9585: LD_INT 47
9587: PUSH
9588: EMPTY
9589: LIST
9590: LIST
9591: LIST
9592: PUSH
9593: LD_VAR 0 3
9597: PUSH
9598: LD_INT 3
9600: MOD
9601: PUSH
9602: LD_INT 1
9604: PLUS
9605: ARRAY
9606: PPUSH
9607: LD_INT 80
9609: PPUSH
9610: CALL 72814 0 5
// result := result union CreateVehicle ;
9614: LD_ADDR_VAR 0 2
9618: PUSH
9619: LD_VAR 0 2
9623: PUSH
9624: CALL_OW 45
9628: UNION
9629: ST_TO_ADDR
// end ;
9630: GO 9523
9632: POP
9633: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9634: LD_INT 24
9636: PPUSH
9637: LD_INT 3
9639: PPUSH
9640: LD_INT 1
9642: PPUSH
9643: LD_INT 47
9645: PPUSH
9646: LD_INT 100
9648: PPUSH
9649: CALL 72814 0 5
// sewiVeh := CreateVehicle ;
9653: LD_ADDR_EXP 73
9657: PUSH
9658: CALL_OW 45
9662: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9663: LD_EXP 73
9667: PPUSH
9668: LD_INT 6
9670: NEG
9671: PPUSH
9672: CALL_OW 242
// result := result union sewiVeh ;
9676: LD_ADDR_VAR 0 2
9680: PUSH
9681: LD_VAR 0 2
9685: PUSH
9686: LD_EXP 73
9690: UNION
9691: ST_TO_ADDR
// end ; end ; end ;
9692: GO 9695
9694: POP
// end ;
9695: LD_VAR 0 2
9699: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9700: LD_EXP 16
9704: IFFALSE 10375
9706: GO 9708
9708: DISABLE
9709: LD_INT 0
9711: PPUSH
9712: PPUSH
9713: PPUSH
9714: PPUSH
9715: PPUSH
9716: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9717: LD_ADDR_VAR 0 4
9721: PUSH
9722: LD_INT 11
9724: PUSH
9725: LD_INT 12
9727: PUSH
9728: EMPTY
9729: LIST
9730: LIST
9731: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9732: LD_ADDR_VAR 0 3
9736: PUSH
9737: LD_INT 11550
9739: PUSH
9740: LD_INT 10150
9742: PUSH
9743: LD_INT 9800
9745: PUSH
9746: LD_INT 9450
9748: PUSH
9749: EMPTY
9750: LIST
9751: LIST
9752: LIST
9753: LIST
9754: PUSH
9755: LD_OWVAR 67
9759: ARRAY
9760: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9761: LD_ADDR_VAR 0 6
9765: PUSH
9766: LD_INT 70
9768: PUSH
9769: LD_INT 118
9771: PUSH
9772: EMPTY
9773: LIST
9774: LIST
9775: PUSH
9776: LD_INT 78
9778: PUSH
9779: LD_INT 31
9781: PUSH
9782: EMPTY
9783: LIST
9784: LIST
9785: PUSH
9786: EMPTY
9787: LIST
9788: LIST
9789: ST_TO_ADDR
// repeat if missionStage = 2 then
9790: LD_EXP 15
9794: PUSH
9795: LD_INT 2
9797: EQUAL
9798: IFFALSE 9809
// wait ( 1 1$30 ) else
9800: LD_INT 3150
9802: PPUSH
9803: CALL_OW 67
9807: GO 9818
// wait ( time ) ;
9809: LD_VAR 0 3
9813: PPUSH
9814: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
9818: LD_EXP 15
9822: PUSH
9823: LD_INT 6
9825: EQUAL
9826: PUSH
9827: LD_OWVAR 67
9831: PUSH
9832: LD_INT 2
9834: GREATER
9835: OR
9836: IFFALSE 9864
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9838: LD_INT 51
9840: PPUSH
9841: LD_INT 6
9843: PPUSH
9844: LD_INT 2
9846: PPUSH
9847: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9851: LD_INT 57
9853: PPUSH
9854: LD_INT 6
9856: PPUSH
9857: LD_INT 2
9859: PPUSH
9860: CALL_OW 322
// end ; if missionStage = 8 then
9864: LD_EXP 15
9868: PUSH
9869: LD_INT 8
9871: EQUAL
9872: IFFALSE 9900
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9874: LD_INT 52
9876: PPUSH
9877: LD_INT 6
9879: PPUSH
9880: LD_INT 2
9882: PPUSH
9883: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9887: LD_INT 58
9889: PPUSH
9890: LD_INT 6
9892: PPUSH
9893: LD_INT 2
9895: PPUSH
9896: CALL_OW 322
// end ; if Difficulty = 4 or missionStage = 10 then
9900: LD_OWVAR 67
9904: PUSH
9905: LD_INT 4
9907: EQUAL
9908: PUSH
9909: LD_EXP 15
9913: PUSH
9914: LD_INT 10
9916: EQUAL
9917: OR
9918: IFFALSE 9946
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9920: LD_INT 53
9922: PPUSH
9923: LD_INT 6
9925: PPUSH
9926: LD_INT 2
9928: PPUSH
9929: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9933: LD_INT 59
9935: PPUSH
9936: LD_INT 6
9938: PPUSH
9939: LD_INT 2
9941: PPUSH
9942: CALL_OW 322
// end ; if activeAttacks then
9946: LD_EXP 16
9950: IFFALSE 10369
// begin if missionStage = 2 then
9952: LD_EXP 15
9956: PUSH
9957: LD_INT 2
9959: EQUAL
9960: IFFALSE 9970
// strength := 1 ;
9962: LD_ADDR_VAR 0 5
9966: PUSH
9967: LD_INT 1
9969: ST_TO_ADDR
// if missionStage > 2 then
9970: LD_EXP 15
9974: PUSH
9975: LD_INT 2
9977: GREATER
9978: IFFALSE 9988
// strength := 2 ;
9980: LD_ADDR_VAR 0 5
9984: PUSH
9985: LD_INT 2
9987: ST_TO_ADDR
// if missionStage > 6 then
9988: LD_EXP 15
9992: PUSH
9993: LD_INT 6
9995: GREATER
9996: IFFALSE 10006
// strength := 3 ;
9998: LD_ADDR_VAR 0 5
10002: PUSH
10003: LD_INT 3
10005: ST_TO_ADDR
// if missionStage > 10 then
10006: LD_EXP 15
10010: PUSH
10011: LD_INT 10
10013: GREATER
10014: IFFALSE 10024
// strength := 4 ;
10016: LD_ADDR_VAR 0 5
10020: PUSH
10021: LD_INT 4
10023: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
10024: LD_ADDR_VAR 0 2
10028: PUSH
10029: LD_VAR 0 5
10033: PPUSH
10034: CALL 8517 0 1
10038: ST_TO_ADDR
// for i in tmp do
10039: LD_ADDR_VAR 0 1
10043: PUSH
10044: LD_VAR 0 2
10048: PUSH
10049: FOR_IN
10050: IFFALSE 10259
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
10052: LD_VAR 0 1
10056: PPUSH
10057: LD_VAR 0 4
10061: PUSH
10062: LD_INT 1
10064: PPUSH
10065: LD_INT 2
10067: PPUSH
10068: CALL_OW 12
10072: ARRAY
10073: PPUSH
10074: LD_INT 0
10076: PPUSH
10077: CALL_OW 49
// if i = sewiVeh then
10081: LD_VAR 0 1
10085: PUSH
10086: LD_EXP 73
10090: EQUAL
10091: IFFALSE 10128
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
10093: LD_ADDR_EXP 72
10097: PUSH
10098: LD_STRING Vsevolod
10100: PPUSH
10101: LD_INT 0
10103: PPUSH
10104: LD_STRING 
10106: PPUSH
10107: CALL 67974 0 3
10111: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
10112: LD_EXP 72
10116: PPUSH
10117: LD_VAR 0 1
10121: PPUSH
10122: CALL_OW 52
// end else
10126: GO 10209
// if GetControl ( i ) = control_manual then
10128: LD_VAR 0 1
10132: PPUSH
10133: CALL_OW 263
10137: PUSH
10138: LD_INT 1
10140: EQUAL
10141: IFFALSE 10209
// begin uc_side := 6 ;
10143: LD_ADDR_OWVAR 20
10147: PUSH
10148: LD_INT 6
10150: ST_TO_ADDR
// uc_nation := 3 ;
10151: LD_ADDR_OWVAR 21
10155: PUSH
10156: LD_INT 3
10158: ST_TO_ADDR
// hc_gallery :=  ;
10159: LD_ADDR_OWVAR 33
10163: PUSH
10164: LD_STRING 
10166: ST_TO_ADDR
// hc_name :=  ;
10167: LD_ADDR_OWVAR 26
10171: PUSH
10172: LD_STRING 
10174: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
10175: LD_INT 0
10177: PPUSH
10178: LD_INT 3
10180: PPUSH
10181: LD_INT 10
10183: PPUSH
10184: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
10188: CALL_OW 44
10192: PPUSH
10193: LD_VAR 0 1
10197: PPUSH
10198: CALL_OW 52
// wait ( 0 0$0.3 ) ;
10202: LD_INT 10
10204: PPUSH
10205: CALL_OW 67
// end ; if Prob ( 50 ) then
10209: LD_INT 50
10211: PPUSH
10212: CALL_OW 13
10216: IFFALSE 10235
// ComMoveXY ( i , 111 , 197 ) else
10218: LD_VAR 0 1
10222: PPUSH
10223: LD_INT 111
10225: PPUSH
10226: LD_INT 197
10228: PPUSH
10229: CALL_OW 111
10233: GO 10250
// ComMoveXY ( i , 91 , 165 ) ;
10235: LD_VAR 0 1
10239: PPUSH
10240: LD_INT 91
10242: PPUSH
10243: LD_INT 165
10245: PPUSH
10246: CALL_OW 111
// wait ( 0 0$2 ) ;
10250: LD_INT 70
10252: PPUSH
10253: CALL_OW 67
// end ;
10257: GO 10049
10259: POP
10260: POP
// repeat wait ( 0 0$1 ) ;
10261: LD_INT 35
10263: PPUSH
10264: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
10268: LD_ADDR_VAR 0 1
10272: PUSH
10273: LD_VAR 0 2
10277: PPUSH
10278: LD_INT 50
10280: PUSH
10281: EMPTY
10282: LIST
10283: PPUSH
10284: CALL_OW 72
10288: PUSH
10289: FOR_IN
10290: IFFALSE 10349
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10292: LD_VAR 0 1
10296: PPUSH
10297: LD_INT 108
10299: PUSH
10300: LD_INT 153
10302: PUSH
10303: EMPTY
10304: LIST
10305: LIST
10306: PUSH
10307: LD_INT 105
10309: PUSH
10310: LD_INT 149
10312: PUSH
10313: EMPTY
10314: LIST
10315: LIST
10316: PUSH
10317: LD_INT 85
10319: PUSH
10320: LD_INT 131
10322: PUSH
10323: EMPTY
10324: LIST
10325: LIST
10326: PUSH
10327: LD_INT 64
10329: PUSH
10330: LD_INT 105
10332: PUSH
10333: EMPTY
10334: LIST
10335: LIST
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: PPUSH
10343: CALL 107870 0 2
10347: GO 10289
10349: POP
10350: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
10351: LD_VAR 0 2
10355: PPUSH
10356: LD_INT 50
10358: PUSH
10359: EMPTY
10360: LIST
10361: PPUSH
10362: CALL_OW 72
10366: NOT
10367: IFFALSE 10261
// end ; until russianDestroyed ;
10369: LD_EXP 21
10373: IFFALSE 9790
// end ;
10375: PPOPN 6
10377: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 do var i , tmp , target , teleport ;
10378: LD_EXP 21
10382: NOT
10383: PUSH
10384: LD_EXP 15
10388: PUSH
10389: LD_INT 6
10391: GREATEREQUAL
10392: AND
10393: IFFALSE 11332
10395: GO 10397
10397: DISABLE
10398: LD_INT 0
10400: PPUSH
10401: PPUSH
10402: PPUSH
10403: PPUSH
// begin enable ;
10404: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10405: LD_INT 22
10407: PUSH
10408: LD_INT 3
10410: PUSH
10411: EMPTY
10412: LIST
10413: LIST
10414: PUSH
10415: LD_INT 30
10417: PUSH
10418: LD_INT 3
10420: PUSH
10421: EMPTY
10422: LIST
10423: LIST
10424: PUSH
10425: EMPTY
10426: LIST
10427: LIST
10428: PPUSH
10429: CALL_OW 69
10433: NOT
10434: IFFALSE 10438
// exit ;
10436: GO 11332
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10438: LD_ADDR_VAR 0 4
10442: PUSH
10443: LD_INT 22
10445: PUSH
10446: LD_INT 3
10448: PUSH
10449: EMPTY
10450: LIST
10451: LIST
10452: PUSH
10453: LD_INT 30
10455: PUSH
10456: LD_INT 34
10458: PUSH
10459: EMPTY
10460: LIST
10461: LIST
10462: PUSH
10463: EMPTY
10464: LIST
10465: LIST
10466: PPUSH
10467: CALL_OW 69
10471: ST_TO_ADDR
// if Prob ( 40 ) then
10472: LD_INT 40
10474: PPUSH
10475: CALL_OW 13
10479: IFFALSE 10625
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10481: LD_INT 2
10483: PPUSH
10484: LD_INT 22
10486: PUSH
10487: LD_INT 3
10489: PUSH
10490: LD_INT 3
10492: PUSH
10493: LD_INT 49
10495: PUSH
10496: EMPTY
10497: LIST
10498: LIST
10499: LIST
10500: LIST
10501: PUSH
10502: LD_INT 22
10504: PUSH
10505: LD_INT 3
10507: PUSH
10508: LD_INT 3
10510: PUSH
10511: LD_INT 49
10513: PUSH
10514: EMPTY
10515: LIST
10516: LIST
10517: LIST
10518: LIST
10519: PUSH
10520: LD_INT 22
10522: PUSH
10523: LD_INT 3
10525: PUSH
10526: LD_INT 3
10528: PUSH
10529: LD_INT 49
10531: PUSH
10532: EMPTY
10533: LIST
10534: LIST
10535: LIST
10536: LIST
10537: PUSH
10538: LD_INT 24
10540: PUSH
10541: LD_INT 3
10543: PUSH
10544: LD_INT 3
10546: PUSH
10547: LD_INT 46
10549: PUSH
10550: EMPTY
10551: LIST
10552: LIST
10553: LIST
10554: LIST
10555: PUSH
10556: LD_INT 24
10558: PUSH
10559: LD_INT 3
10561: PUSH
10562: LD_INT 3
10564: PUSH
10565: LD_INT 46
10567: PUSH
10568: EMPTY
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: PUSH
10574: LD_INT 24
10576: PUSH
10577: LD_INT 3
10579: PUSH
10580: LD_INT 3
10582: PUSH
10583: LD_INT 46
10585: PUSH
10586: EMPTY
10587: LIST
10588: LIST
10589: LIST
10590: LIST
10591: PUSH
10592: LD_INT 24
10594: PUSH
10595: LD_INT 3
10597: PUSH
10598: LD_INT 3
10600: PUSH
10601: LD_INT 46
10603: PUSH
10604: EMPTY
10605: LIST
10606: LIST
10607: LIST
10608: LIST
10609: PUSH
10610: EMPTY
10611: LIST
10612: LIST
10613: LIST
10614: LIST
10615: LIST
10616: LIST
10617: LIST
10618: PPUSH
10619: CALL 61548 0 2
// end else
10623: GO 10767
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10625: LD_INT 2
10627: PPUSH
10628: LD_INT 24
10630: PUSH
10631: LD_INT 3
10633: PUSH
10634: LD_INT 3
10636: PUSH
10637: LD_INT 47
10639: PUSH
10640: EMPTY
10641: LIST
10642: LIST
10643: LIST
10644: LIST
10645: PUSH
10646: LD_INT 24
10648: PUSH
10649: LD_INT 3
10651: PUSH
10652: LD_INT 3
10654: PUSH
10655: LD_INT 47
10657: PUSH
10658: EMPTY
10659: LIST
10660: LIST
10661: LIST
10662: LIST
10663: PUSH
10664: LD_INT 24
10666: PUSH
10667: LD_INT 3
10669: PUSH
10670: LD_INT 3
10672: PUSH
10673: LD_INT 47
10675: PUSH
10676: EMPTY
10677: LIST
10678: LIST
10679: LIST
10680: LIST
10681: PUSH
10682: LD_INT 24
10684: PUSH
10685: LD_INT 3
10687: PUSH
10688: LD_INT 3
10690: PUSH
10691: LD_INT 46
10693: PUSH
10694: EMPTY
10695: LIST
10696: LIST
10697: LIST
10698: LIST
10699: PUSH
10700: LD_INT 24
10702: PUSH
10703: LD_INT 3
10705: PUSH
10706: LD_INT 3
10708: PUSH
10709: LD_INT 46
10711: PUSH
10712: EMPTY
10713: LIST
10714: LIST
10715: LIST
10716: LIST
10717: PUSH
10718: LD_INT 24
10720: PUSH
10721: LD_INT 3
10723: PUSH
10724: LD_INT 3
10726: PUSH
10727: LD_INT 46
10729: PUSH
10730: EMPTY
10731: LIST
10732: LIST
10733: LIST
10734: LIST
10735: PUSH
10736: LD_INT 24
10738: PUSH
10739: LD_INT 3
10741: PUSH
10742: LD_INT 3
10744: PUSH
10745: LD_INT 46
10747: PUSH
10748: EMPTY
10749: LIST
10750: LIST
10751: LIST
10752: LIST
10753: PUSH
10754: EMPTY
10755: LIST
10756: LIST
10757: LIST
10758: LIST
10759: LIST
10760: LIST
10761: LIST
10762: PPUSH
10763: CALL 61548 0 2
// end ; repeat wait ( 0 0$1 ) ;
10767: LD_INT 35
10769: PPUSH
10770: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= 7 ;
10774: LD_INT 2
10776: PPUSH
10777: LD_INT 1
10779: PPUSH
10780: CALL 62966 0 2
10784: PUSH
10785: LD_INT 7
10787: GREATEREQUAL
10788: IFFALSE 10767
// wait ( 0 0$10 ) ;
10790: LD_INT 350
10792: PPUSH
10793: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10797: LD_ADDR_VAR 0 2
10801: PUSH
10802: LD_INT 2
10804: PPUSH
10805: LD_INT 1
10807: PPUSH
10808: CALL 62966 0 2
10812: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10813: LD_ADDR_EXP 119
10817: PUSH
10818: LD_EXP 119
10822: PPUSH
10823: LD_INT 2
10825: PPUSH
10826: LD_EXP 119
10830: PUSH
10831: LD_INT 2
10833: ARRAY
10834: PUSH
10835: LD_VAR 0 2
10839: DIFF
10840: PPUSH
10841: CALL_OW 1
10845: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10846: LD_ADDR_VAR 0 3
10850: PUSH
10851: LD_INT 0
10853: PPUSH
10854: LD_INT 1
10856: PPUSH
10857: CALL_OW 12
10861: ST_TO_ADDR
// if target then
10862: LD_VAR 0 3
10866: IFFALSE 10994
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10868: LD_ADDR_VAR 0 2
10872: PUSH
10873: LD_VAR 0 2
10877: PPUSH
10878: LD_INT 24
10880: PUSH
10881: LD_INT 250
10883: PUSH
10884: EMPTY
10885: LIST
10886: LIST
10887: PPUSH
10888: CALL_OW 72
10892: ST_TO_ADDR
// for i in tmp do
10893: LD_ADDR_VAR 0 1
10897: PUSH
10898: LD_VAR 0 2
10902: PUSH
10903: FOR_IN
10904: IFFALSE 10944
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10906: LD_VAR 0 1
10910: PPUSH
10911: LD_INT 139
10913: PPUSH
10914: LD_INT 89
10916: PPUSH
10917: CALL_OW 297
10921: PUSH
10922: LD_INT 9
10924: GREATER
10925: IFFALSE 10942
// ComMoveXY ( i , 139 , 89 ) ;
10927: LD_VAR 0 1
10931: PPUSH
10932: LD_INT 139
10934: PPUSH
10935: LD_INT 89
10937: PPUSH
10938: CALL_OW 111
10942: GO 10903
10944: POP
10945: POP
// wait ( 0 0$1 ) ;
10946: LD_INT 35
10948: PPUSH
10949: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10953: LD_VAR 0 2
10957: PPUSH
10958: LD_INT 92
10960: PUSH
10961: LD_INT 139
10963: PUSH
10964: LD_INT 89
10966: PUSH
10967: LD_INT 9
10969: PUSH
10970: EMPTY
10971: LIST
10972: LIST
10973: LIST
10974: LIST
10975: PPUSH
10976: CALL_OW 72
10980: PUSH
10981: LD_VAR 0 2
10985: PUSH
10986: LD_INT 1
10988: MINUS
10989: GREATEREQUAL
10990: IFFALSE 10868
// end else
10992: GO 11136
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10994: LD_VAR 0 2
10998: PPUSH
10999: LD_VAR 0 4
11003: PUSH
11004: LD_INT 1
11006: ARRAY
11007: PPUSH
11008: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11012: LD_ADDR_VAR 0 2
11016: PUSH
11017: LD_VAR 0 2
11021: PPUSH
11022: LD_INT 24
11024: PUSH
11025: LD_INT 250
11027: PUSH
11028: EMPTY
11029: LIST
11030: LIST
11031: PPUSH
11032: CALL_OW 72
11036: ST_TO_ADDR
// for i in tmp do
11037: LD_ADDR_VAR 0 1
11041: PUSH
11042: LD_VAR 0 2
11046: PUSH
11047: FOR_IN
11048: IFFALSE 11088
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11050: LD_VAR 0 1
11054: PPUSH
11055: LD_INT 124
11057: PPUSH
11058: LD_INT 139
11060: PPUSH
11061: CALL_OW 297
11065: PUSH
11066: LD_INT 9
11068: GREATER
11069: IFFALSE 11086
// ComMoveXY ( i , 124 , 139 ) ;
11071: LD_VAR 0 1
11075: PPUSH
11076: LD_INT 124
11078: PPUSH
11079: LD_INT 139
11081: PPUSH
11082: CALL_OW 111
11086: GO 11047
11088: POP
11089: POP
// wait ( 0 0$1 ) ;
11090: LD_INT 35
11092: PPUSH
11093: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
11097: LD_VAR 0 2
11101: PPUSH
11102: LD_INT 92
11104: PUSH
11105: LD_INT 124
11107: PUSH
11108: LD_INT 139
11110: PUSH
11111: LD_INT 9
11113: PUSH
11114: EMPTY
11115: LIST
11116: LIST
11117: LIST
11118: LIST
11119: PPUSH
11120: CALL_OW 72
11124: PUSH
11125: LD_VAR 0 2
11129: PUSH
11130: LD_INT 1
11132: MINUS
11133: GREATEREQUAL
11134: IFFALSE 11012
// end ; repeat wait ( 0 0$1 ) ;
11136: LD_INT 35
11138: PPUSH
11139: CALL_OW 67
// for i in tmp do
11143: LD_ADDR_VAR 0 1
11147: PUSH
11148: LD_VAR 0 2
11152: PUSH
11153: FOR_IN
11154: IFFALSE 11323
// begin if GetLives ( i ) > 251 then
11156: LD_VAR 0 1
11160: PPUSH
11161: CALL_OW 256
11165: PUSH
11166: LD_INT 251
11168: GREATER
11169: IFFALSE 11294
// begin if GetWeapon ( i ) = ru_time_lapser then
11171: LD_VAR 0 1
11175: PPUSH
11176: CALL_OW 264
11180: PUSH
11181: LD_INT 49
11183: EQUAL
11184: IFFALSE 11240
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11186: LD_VAR 0 1
11190: PPUSH
11191: LD_INT 2
11193: PUSH
11194: LD_INT 22
11196: PUSH
11197: LD_INT 1
11199: PUSH
11200: EMPTY
11201: LIST
11202: LIST
11203: PUSH
11204: LD_INT 22
11206: PUSH
11207: LD_INT 8
11209: PUSH
11210: EMPTY
11211: LIST
11212: LIST
11213: PUSH
11214: EMPTY
11215: LIST
11216: LIST
11217: LIST
11218: PPUSH
11219: CALL_OW 69
11223: PPUSH
11224: LD_VAR 0 1
11228: PPUSH
11229: CALL_OW 74
11233: PPUSH
11234: CALL_OW 112
11238: GO 11292
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11240: LD_VAR 0 1
11244: PPUSH
11245: LD_INT 2
11247: PUSH
11248: LD_INT 22
11250: PUSH
11251: LD_INT 1
11253: PUSH
11254: EMPTY
11255: LIST
11256: LIST
11257: PUSH
11258: LD_INT 22
11260: PUSH
11261: LD_INT 8
11263: PUSH
11264: EMPTY
11265: LIST
11266: LIST
11267: PUSH
11268: EMPTY
11269: LIST
11270: LIST
11271: LIST
11272: PPUSH
11273: CALL_OW 69
11277: PPUSH
11278: LD_VAR 0 1
11282: PPUSH
11283: CALL_OW 74
11287: PPUSH
11288: CALL_OW 115
// end else
11292: GO 11321
// if IsDead ( i ) then
11294: LD_VAR 0 1
11298: PPUSH
11299: CALL_OW 301
11303: IFFALSE 11321
// tmp := tmp diff i ;
11305: LD_ADDR_VAR 0 2
11309: PUSH
11310: LD_VAR 0 2
11314: PUSH
11315: LD_VAR 0 1
11319: DIFF
11320: ST_TO_ADDR
// end ;
11321: GO 11153
11323: POP
11324: POP
// until not tmp ;
11325: LD_VAR 0 2
11329: NOT
11330: IFFALSE 11136
// end ;
11332: PPOPN 4
11334: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 7 and Difficulty > 1 do var i , veh , un ;
11335: LD_EXP 15
11339: PUSH
11340: LD_INT 7
11342: GREATEREQUAL
11343: PUSH
11344: LD_OWVAR 67
11348: PUSH
11349: LD_INT 1
11351: GREATER
11352: AND
11353: IFFALSE 11537
11355: GO 11357
11357: DISABLE
11358: LD_INT 0
11360: PPUSH
11361: PPUSH
11362: PPUSH
// begin ruMobile := [ ] ;
11363: LD_ADDR_EXP 76
11367: PUSH
11368: EMPTY
11369: ST_TO_ADDR
// for i := 1 to [ 3 , 4 , 5 ] [ Difficulty - 1 ] do
11370: LD_ADDR_VAR 0 1
11374: PUSH
11375: DOUBLE
11376: LD_INT 1
11378: DEC
11379: ST_TO_ADDR
11380: LD_INT 3
11382: PUSH
11383: LD_INT 4
11385: PUSH
11386: LD_INT 5
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: LIST
11393: PUSH
11394: LD_OWVAR 67
11398: PUSH
11399: LD_INT 1
11401: MINUS
11402: ARRAY
11403: PUSH
11404: FOR_TO
11405: IFFALSE 11535
// begin uc_side := 3 ;
11407: LD_ADDR_OWVAR 20
11411: PUSH
11412: LD_INT 3
11414: ST_TO_ADDR
// uc_nation := 3 ;
11415: LD_ADDR_OWVAR 21
11419: PUSH
11420: LD_INT 3
11422: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
11423: LD_INT 21
11425: PPUSH
11426: LD_INT 3
11428: PPUSH
11429: LD_INT 1
11431: PPUSH
11432: LD_INT 45
11434: PPUSH
11435: LD_INT 100
11437: PPUSH
11438: CALL 72814 0 5
// veh := CreateVehicle ;
11442: LD_ADDR_VAR 0 2
11446: PUSH
11447: CALL_OW 45
11451: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11452: LD_VAR 0 2
11456: PPUSH
11457: LD_INT 3
11459: PPUSH
11460: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11464: LD_VAR 0 2
11468: PPUSH
11469: LD_INT 29
11471: PPUSH
11472: LD_INT 0
11474: PPUSH
11475: CALL_OW 49
// PrepareMechanic ( false , 10 ) ;
11479: LD_INT 0
11481: PPUSH
11482: LD_INT 10
11484: PPUSH
11485: CALL_OW 383
// un := CreateHuman ;
11489: LD_ADDR_VAR 0 3
11493: PUSH
11494: CALL_OW 44
11498: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
11499: LD_VAR 0 3
11503: PPUSH
11504: LD_VAR 0 2
11508: PPUSH
11509: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
11513: LD_ADDR_EXP 76
11517: PUSH
11518: LD_EXP 76
11522: PPUSH
11523: LD_VAR 0 2
11527: PPUSH
11528: CALL 105266 0 2
11532: ST_TO_ADDR
// end ;
11533: GO 11404
11535: POP
11536: POP
// end ;
11537: PPOPN 3
11539: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
11540: LD_EXP 76
11544: IFFALSE 12052
11546: GO 11548
11548: DISABLE
11549: LD_INT 0
11551: PPUSH
11552: PPUSH
11553: PPUSH
// begin enable ;
11554: ENABLE
// if not ruMobile then
11555: LD_EXP 76
11559: NOT
11560: IFFALSE 11564
// exit ;
11562: GO 12052
// for i in ruMobile do
11564: LD_ADDR_VAR 0 1
11568: PUSH
11569: LD_EXP 76
11573: PUSH
11574: FOR_IN
11575: IFFALSE 12050
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
11577: LD_VAR 0 1
11581: PPUSH
11582: CALL_OW 302
11586: NOT
11587: PUSH
11588: LD_VAR 0 1
11592: PPUSH
11593: CALL_OW 255
11597: PUSH
11598: LD_INT 3
11600: NONEQUAL
11601: OR
11602: IFFALSE 11622
// begin ruMobile := ruMobile diff i ;
11604: LD_ADDR_EXP 76
11608: PUSH
11609: LD_EXP 76
11613: PUSH
11614: LD_VAR 0 1
11618: DIFF
11619: ST_TO_ADDR
// continue ;
11620: GO 11574
// end ; if GetTag ( i ) = 300 then
11622: LD_VAR 0 1
11626: PPUSH
11627: CALL_OW 110
11631: PUSH
11632: LD_INT 300
11634: EQUAL
11635: IFFALSE 11685
// begin ComMoveXY ( i , 160 , 81 ) ;
11637: LD_VAR 0 1
11641: PPUSH
11642: LD_INT 160
11644: PPUSH
11645: LD_INT 81
11647: PPUSH
11648: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
11652: LD_VAR 0 1
11656: PPUSH
11657: LD_INT 160
11659: PPUSH
11660: LD_INT 81
11662: PPUSH
11663: CALL_OW 297
11667: PUSH
11668: LD_INT 8
11670: LESS
11671: IFFALSE 11685
// SetTag ( i , 301 ) ;
11673: LD_VAR 0 1
11677: PPUSH
11678: LD_INT 301
11680: PPUSH
11681: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
11685: LD_VAR 0 1
11689: PPUSH
11690: CALL_OW 110
11694: PUSH
11695: LD_INT 301
11697: EQUAL
11698: IFFALSE 11741
// begin if not IsInArea ( i , ruMobileParkingArea ) then
11700: LD_VAR 0 1
11704: PPUSH
11705: LD_INT 33
11707: PPUSH
11708: CALL_OW 308
11712: NOT
11713: IFFALSE 11729
// ComMoveToArea ( i , ruMobileParkingArea ) else
11715: LD_VAR 0 1
11719: PPUSH
11720: LD_INT 33
11722: PPUSH
11723: CALL_OW 113
11727: GO 11741
// SetTag ( i , 302 ) ;
11729: LD_VAR 0 1
11733: PPUSH
11734: LD_INT 302
11736: PPUSH
11737: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
11741: LD_VAR 0 1
11745: PPUSH
11746: CALL_OW 110
11750: PUSH
11751: LD_INT 302
11753: EQUAL
11754: IFFALSE 11884
// begin if GetLives ( i ) < 1000 then
11756: LD_VAR 0 1
11760: PPUSH
11761: CALL_OW 256
11765: PUSH
11766: LD_INT 1000
11768: LESS
11769: IFFALSE 11861
// begin if not IsDrivenBy ( i ) then
11771: LD_VAR 0 1
11775: PPUSH
11776: CALL_OW 311
11780: NOT
11781: IFFALSE 11785
// continue ;
11783: GO 11574
// mech := IsDrivenBy ( i ) ;
11785: LD_ADDR_VAR 0 2
11789: PUSH
11790: LD_VAR 0 1
11794: PPUSH
11795: CALL_OW 311
11799: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
11800: LD_VAR 0 2
11804: PPUSH
11805: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
11809: LD_VAR 0 2
11813: PPUSH
11814: LD_VAR 0 1
11818: PPUSH
11819: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
11823: LD_INT 35
11825: PPUSH
11826: CALL_OW 67
// until GetLives ( i ) = 1000 ;
11830: LD_VAR 0 1
11834: PPUSH
11835: CALL_OW 256
11839: PUSH
11840: LD_INT 1000
11842: EQUAL
11843: IFFALSE 11823
// ComEnterUnit ( mech , i ) ;
11845: LD_VAR 0 2
11849: PPUSH
11850: LD_VAR 0 1
11854: PPUSH
11855: CALL_OW 120
// end else
11859: GO 11884
// if IsDrivenBy ( i ) then
11861: LD_VAR 0 1
11865: PPUSH
11866: CALL_OW 311
11870: IFFALSE 11884
// SetTag ( i , 0 ) ;
11872: LD_VAR 0 1
11876: PPUSH
11877: LD_INT 0
11879: PPUSH
11880: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
11884: LD_VAR 0 1
11888: PPUSH
11889: CALL_OW 110
11893: PUSH
11894: LD_INT 300
11896: LESS
11897: IFFALSE 12048
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
11899: LD_ADDR_VAR 0 3
11903: PUSH
11904: LD_INT 4
11906: PPUSH
11907: LD_INT 81
11909: PUSH
11910: LD_INT 3
11912: PUSH
11913: EMPTY
11914: LIST
11915: LIST
11916: PPUSH
11917: CALL_OW 70
11921: ST_TO_ADDR
// if GetLives ( i ) < 650 then
11922: LD_VAR 0 1
11926: PPUSH
11927: CALL_OW 256
11931: PUSH
11932: LD_INT 650
11934: LESS
11935: IFFALSE 11960
// begin ComStop ( i ) ;
11937: LD_VAR 0 1
11941: PPUSH
11942: CALL_OW 141
// SetTag ( i , 300 ) ;
11946: LD_VAR 0 1
11950: PPUSH
11951: LD_INT 300
11953: PPUSH
11954: CALL_OW 109
// continue ;
11958: GO 11574
// end ; if enemy then
11960: LD_VAR 0 3
11964: IFFALSE 12004
// begin if not HasTask ( i ) then
11966: LD_VAR 0 1
11970: PPUSH
11971: CALL_OW 314
11975: NOT
11976: IFFALSE 12002
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
11978: LD_VAR 0 1
11982: PPUSH
11983: LD_VAR 0 3
11987: PPUSH
11988: LD_VAR 0 1
11992: PPUSH
11993: CALL_OW 74
11997: PPUSH
11998: CALL_OW 115
// end else
12002: GO 12048
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
12004: LD_VAR 0 1
12008: PPUSH
12009: LD_INT 158
12011: PUSH
12012: LD_INT 61
12014: PUSH
12015: EMPTY
12016: LIST
12017: LIST
12018: PUSH
12019: LD_INT 98
12021: PUSH
12022: LD_INT 100
12024: PUSH
12025: EMPTY
12026: LIST
12027: LIST
12028: PUSH
12029: LD_INT 78
12031: PUSH
12032: LD_INT 93
12034: PUSH
12035: EMPTY
12036: LIST
12037: LIST
12038: PUSH
12039: EMPTY
12040: LIST
12041: LIST
12042: LIST
12043: PPUSH
12044: CALL 107870 0 2
// end ; end ;
12048: GO 11574
12050: POP
12051: POP
// end ; end_of_file
12052: PPOPN 3
12054: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
12055: LD_INT 0
12057: PPUSH
12058: PPUSH
12059: PPUSH
12060: PPUSH
12061: PPUSH
12062: PPUSH
// side := 7 ;
12063: LD_ADDR_VAR 0 5
12067: PUSH
12068: LD_INT 7
12070: ST_TO_ADDR
// uc_side := side ;
12071: LD_ADDR_OWVAR 20
12075: PUSH
12076: LD_VAR 0 5
12080: ST_TO_ADDR
// uc_nation := 1 ;
12081: LD_ADDR_OWVAR 21
12085: PUSH
12086: LD_INT 1
12088: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
12089: LD_ADDR_VAR 0 2
12093: PUSH
12094: LD_INT 22
12096: PUSH
12097: LD_VAR 0 5
12101: PUSH
12102: EMPTY
12103: LIST
12104: LIST
12105: PUSH
12106: LD_INT 21
12108: PUSH
12109: LD_INT 3
12111: PUSH
12112: EMPTY
12113: LIST
12114: LIST
12115: PUSH
12116: EMPTY
12117: LIST
12118: LIST
12119: PPUSH
12120: CALL_OW 69
12124: PUSH
12125: FOR_IN
12126: IFFALSE 12142
// SetBLevel ( i , 10 ) ;
12128: LD_VAR 0 2
12132: PPUSH
12133: LD_INT 10
12135: PPUSH
12136: CALL_OW 241
12140: GO 12125
12142: POP
12143: POP
// base := GetBase ( al_depot ) ;
12144: LD_ADDR_VAR 0 4
12148: PUSH
12149: LD_INT 2
12151: PPUSH
12152: CALL_OW 274
12156: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
12157: LD_ADDR_VAR 0 6
12161: PUSH
12162: LD_INT 22
12164: PUSH
12165: LD_VAR 0 5
12169: PUSH
12170: EMPTY
12171: LIST
12172: LIST
12173: PUSH
12174: LD_INT 30
12176: PUSH
12177: LD_INT 34
12179: PUSH
12180: EMPTY
12181: LIST
12182: LIST
12183: PUSH
12184: EMPTY
12185: LIST
12186: LIST
12187: PPUSH
12188: CALL_OW 69
12192: ST_TO_ADDR
// if teleport then
12193: LD_VAR 0 6
12197: IFFALSE 12218
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
12199: LD_VAR 0 6
12203: PUSH
12204: LD_INT 1
12206: ARRAY
12207: PPUSH
12208: LD_INT 262
12210: PPUSH
12211: LD_INT 119
12213: PPUSH
12214: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
12218: LD_VAR 0 4
12222: PPUSH
12223: LD_INT 1
12225: PPUSH
12226: LD_INT 19500
12228: PPUSH
12229: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
12233: LD_VAR 0 4
12237: PPUSH
12238: LD_INT 2
12240: PPUSH
12241: LD_INT 200
12243: PPUSH
12244: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
12248: LD_VAR 0 4
12252: PPUSH
12253: LD_INT 3
12255: PPUSH
12256: LD_INT 650
12258: PPUSH
12259: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12263: LD_ADDR_EXP 77
12267: PUSH
12268: LD_STRING Roth
12270: PPUSH
12271: CALL_OW 25
12275: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12276: LD_ADDR_EXP 78
12280: PUSH
12281: LD_STRING Simms
12283: PPUSH
12284: LD_EXP 1
12288: NOT
12289: PPUSH
12290: LD_STRING 10c_
12292: PPUSH
12293: CALL 67974 0 3
12297: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
12298: LD_EXP 78
12302: PPUSH
12303: LD_INT 4
12305: PPUSH
12306: CALL_OW 336
// if not Simms then
12310: LD_EXP 78
12314: NOT
12315: IFFALSE 12345
// begin uc_nation := 1 ;
12317: LD_ADDR_OWVAR 21
12321: PUSH
12322: LD_INT 1
12324: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12325: LD_INT 2
12327: PPUSH
12328: LD_INT 10
12330: PPUSH
12331: CALL_OW 384
// Simms := CreateHuman ;
12335: LD_ADDR_EXP 78
12339: PUSH
12340: CALL_OW 44
12344: ST_TO_ADDR
// end ; uc_nation := 3 ;
12345: LD_ADDR_OWVAR 21
12349: PUSH
12350: LD_INT 3
12352: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
12353: LD_ADDR_EXP 79
12357: PUSH
12358: LD_STRING Kirilenkova
12360: PPUSH
12361: CALL_OW 25
12365: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
12366: LD_ADDR_EXP 93
12370: PUSH
12371: LD_STRING Oblukov
12373: PPUSH
12374: CALL_OW 25
12378: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
12379: LD_ADDR_EXP 80
12383: PUSH
12384: LD_STRING Dolgov
12386: PPUSH
12387: CALL_OW 25
12391: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
12392: LD_ADDR_EXP 81
12396: PUSH
12397: LD_STRING Petrosyan
12399: PPUSH
12400: CALL_OW 25
12404: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
12405: LD_ADDR_EXP 92
12409: PUSH
12410: LD_STRING Scholtze
12412: PPUSH
12413: CALL_OW 25
12417: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
12418: LD_ADDR_EXP 91
12422: PUSH
12423: LD_STRING Kapitsova
12425: PPUSH
12426: CALL_OW 25
12430: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
12431: LD_ADDR_EXP 82
12435: PUSH
12436: LD_STRING Petrovova
12438: PPUSH
12439: CALL_OW 25
12443: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
12444: LD_ADDR_EXP 83
12448: PUSH
12449: LD_STRING Kuzmov
12451: PPUSH
12452: CALL_OW 25
12456: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
12457: LD_ADDR_EXP 90
12461: PUSH
12462: LD_STRING Karamazov
12464: PPUSH
12465: CALL_OW 25
12469: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
12470: LD_STRING 13_Lipshchin_1
12472: PPUSH
12473: LD_INT 0
12475: PPUSH
12476: CALL_OW 30
12480: IFFALSE 12495
// Lipshchin := NewCharacter ( Lipshchin ) ;
12482: LD_ADDR_EXP 84
12486: PUSH
12487: LD_STRING Lipshchin
12489: PPUSH
12490: CALL_OW 25
12494: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
12495: LD_STRING 13_Titov_1
12497: PPUSH
12498: LD_INT 0
12500: PPUSH
12501: CALL_OW 30
12505: IFFALSE 12520
// Titov := NewCharacter ( Titov ) ;
12507: LD_ADDR_EXP 86
12511: PUSH
12512: LD_STRING Titov
12514: PPUSH
12515: CALL_OW 25
12519: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
12520: LD_STRING 13_Gnyevko_1
12522: PPUSH
12523: LD_INT 0
12525: PPUSH
12526: CALL_OW 30
12530: IFFALSE 12545
// Gnyevko := NewCharacter ( Gnyevko ) ;
12532: LD_ADDR_EXP 85
12536: PUSH
12537: LD_STRING Gnyevko
12539: PPUSH
12540: CALL_OW 25
12544: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
12545: LD_STRING 13_Xavier_1
12547: PPUSH
12548: LD_INT 0
12550: PPUSH
12551: CALL_OW 30
12555: IFFALSE 12570
// Xavier := NewCharacter ( Xavier2 ) ;
12557: LD_ADDR_EXP 87
12561: PUSH
12562: LD_STRING Xavier2
12564: PPUSH
12565: CALL_OW 25
12569: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
12570: LD_STRING 13_Belkov_1
12572: PPUSH
12573: LD_INT 0
12575: PPUSH
12576: CALL_OW 30
12580: IFFALSE 12595
// Belkov := NewCharacter ( Belkov ) ;
12582: LD_ADDR_EXP 88
12586: PUSH
12587: LD_STRING Belkov
12589: PPUSH
12590: CALL_OW 25
12594: ST_TO_ADDR
// if not BurlakStatus then
12595: LD_EXP 9
12599: NOT
12600: IFFALSE 12615
// Burlak = NewCharacter ( Burlak ) ;
12602: LD_ADDR_EXP 89
12606: PUSH
12607: LD_STRING Burlak
12609: PPUSH
12610: CALL_OW 25
12614: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
12615: LD_ADDR_VAR 0 3
12619: PUSH
12620: LD_EXP 77
12624: PUSH
12625: LD_EXP 79
12629: PUSH
12630: LD_EXP 93
12634: PUSH
12635: LD_EXP 80
12639: PUSH
12640: LD_EXP 81
12644: PUSH
12645: LD_EXP 92
12649: PUSH
12650: LD_EXP 91
12654: PUSH
12655: LD_EXP 82
12659: PUSH
12660: LD_EXP 83
12664: PUSH
12665: LD_EXP 90
12669: PUSH
12670: EMPTY
12671: LIST
12672: LIST
12673: LIST
12674: LIST
12675: LIST
12676: LIST
12677: LIST
12678: LIST
12679: LIST
12680: LIST
12681: ST_TO_ADDR
// if Simms then
12682: LD_EXP 78
12686: IFFALSE 12704
// tmp := tmp ^ Simms ;
12688: LD_ADDR_VAR 0 3
12692: PUSH
12693: LD_VAR 0 3
12697: PUSH
12698: LD_EXP 78
12702: ADD
12703: ST_TO_ADDR
// if Titov then
12704: LD_EXP 86
12708: IFFALSE 12726
// tmp := tmp ^ Titov ;
12710: LD_ADDR_VAR 0 3
12714: PUSH
12715: LD_VAR 0 3
12719: PUSH
12720: LD_EXP 86
12724: ADD
12725: ST_TO_ADDR
// if Lipshchin then
12726: LD_EXP 84
12730: IFFALSE 12748
// tmp := tmp ^ Lipshchin ;
12732: LD_ADDR_VAR 0 3
12736: PUSH
12737: LD_VAR 0 3
12741: PUSH
12742: LD_EXP 84
12746: ADD
12747: ST_TO_ADDR
// if Gnyevko then
12748: LD_EXP 85
12752: IFFALSE 12770
// tmp := tmp ^ Gnyevko ;
12754: LD_ADDR_VAR 0 3
12758: PUSH
12759: LD_VAR 0 3
12763: PUSH
12764: LD_EXP 85
12768: ADD
12769: ST_TO_ADDR
// if Xavier then
12770: LD_EXP 87
12774: IFFALSE 12792
// tmp := tmp ^ Xavier ;
12776: LD_ADDR_VAR 0 3
12780: PUSH
12781: LD_VAR 0 3
12785: PUSH
12786: LD_EXP 87
12790: ADD
12791: ST_TO_ADDR
// if Belkov then
12792: LD_EXP 88
12796: IFFALSE 12814
// tmp := tmp ^ Belkov ;
12798: LD_ADDR_VAR 0 3
12802: PUSH
12803: LD_VAR 0 3
12807: PUSH
12808: LD_EXP 88
12812: ADD
12813: ST_TO_ADDR
// if Burlak then
12814: LD_EXP 89
12818: IFFALSE 12836
// tmp := tmp ^ Burlak ;
12820: LD_ADDR_VAR 0 3
12824: PUSH
12825: LD_VAR 0 3
12829: PUSH
12830: LD_EXP 89
12834: ADD
12835: ST_TO_ADDR
// for i = 1 to 11 do
12836: LD_ADDR_VAR 0 2
12840: PUSH
12841: DOUBLE
12842: LD_INT 1
12844: DEC
12845: ST_TO_ADDR
12846: LD_INT 11
12848: PUSH
12849: FOR_TO
12850: IFFALSE 12918
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
12852: LD_ADDR_OWVAR 21
12856: PUSH
12857: LD_INT 1
12859: PUSH
12860: LD_INT 3
12862: PUSH
12863: EMPTY
12864: LIST
12865: LIST
12866: PUSH
12867: LD_INT 1
12869: PPUSH
12870: LD_INT 2
12872: PPUSH
12873: CALL_OW 12
12877: ARRAY
12878: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 10 ) ;
12879: LD_INT 0
12881: PPUSH
12882: LD_INT 1
12884: PPUSH
12885: LD_INT 4
12887: PPUSH
12888: CALL_OW 12
12892: PPUSH
12893: LD_INT 10
12895: PPUSH
12896: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
12900: LD_ADDR_VAR 0 3
12904: PUSH
12905: LD_VAR 0 3
12909: PUSH
12910: CALL_OW 44
12914: ADD
12915: ST_TO_ADDR
// end ;
12916: GO 12849
12918: POP
12919: POP
// for i in tmp do
12920: LD_ADDR_VAR 0 2
12924: PUSH
12925: LD_VAR 0 3
12929: PUSH
12930: FOR_IN
12931: IFFALSE 12956
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
12933: LD_VAR 0 2
12937: PPUSH
12938: LD_INT 260
12940: PPUSH
12941: LD_INT 235
12943: PPUSH
12944: LD_INT 8
12946: PPUSH
12947: LD_INT 0
12949: PPUSH
12950: CALL_OW 50
12954: GO 12930
12956: POP
12957: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
12958: LD_ADDR_EXP 100
12962: PUSH
12963: LD_EXP 100
12967: PPUSH
12968: LD_INT 1
12970: PPUSH
12971: LD_INT 22
12973: PUSH
12974: LD_VAR 0 5
12978: PUSH
12979: EMPTY
12980: LIST
12981: LIST
12982: PUSH
12983: LD_INT 3
12985: PUSH
12986: LD_INT 21
12988: PUSH
12989: LD_INT 2
12991: PUSH
12992: EMPTY
12993: LIST
12994: LIST
12995: PUSH
12996: EMPTY
12997: LIST
12998: LIST
12999: PUSH
13000: EMPTY
13001: LIST
13002: LIST
13003: PPUSH
13004: CALL_OW 69
13008: PUSH
13009: LD_EXP 77
13013: PUSH
13014: LD_EXP 78
13018: PUSH
13019: EMPTY
13020: LIST
13021: LIST
13022: DIFF
13023: PPUSH
13024: CALL_OW 1
13028: ST_TO_ADDR
// uc_side := 0 ;
13029: LD_ADDR_OWVAR 20
13033: PUSH
13034: LD_INT 0
13036: ST_TO_ADDR
// uc_nation := 0 ;
13037: LD_ADDR_OWVAR 21
13041: PUSH
13042: LD_INT 0
13044: ST_TO_ADDR
// for i = 1 to 5 do
13045: LD_ADDR_VAR 0 2
13049: PUSH
13050: DOUBLE
13051: LD_INT 1
13053: DEC
13054: ST_TO_ADDR
13055: LD_INT 5
13057: PUSH
13058: FOR_TO
13059: IFFALSE 13096
// begin InitHc ;
13061: CALL_OW 19
// hc_class := class_apeman ;
13065: LD_ADDR_OWVAR 28
13069: PUSH
13070: LD_INT 12
13072: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
13073: CALL_OW 44
13077: PPUSH
13078: LD_INT 299
13080: PPUSH
13081: LD_INT 229
13083: PPUSH
13084: LD_INT 10
13086: PPUSH
13087: LD_INT 0
13089: PPUSH
13090: CALL_OW 50
// end ;
13094: GO 13058
13096: POP
13097: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
13098: LD_EXP 77
13102: PPUSH
13103: LD_INT 259
13105: PPUSH
13106: LD_INT 235
13108: PPUSH
13109: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
13113: LD_EXP 77
13117: PPUSH
13118: LD_INT 262
13120: PPUSH
13121: LD_INT 235
13123: PPUSH
13124: CALL_OW 178
// if Simms then
13128: LD_EXP 78
13132: IFFALSE 13163
// begin ComMoveXY ( Simms , 262 , 235 ) ;
13134: LD_EXP 78
13138: PPUSH
13139: LD_INT 262
13141: PPUSH
13142: LD_INT 235
13144: PPUSH
13145: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
13149: LD_EXP 78
13153: PPUSH
13154: LD_EXP 77
13158: PPUSH
13159: CALL_OW 179
// end ; end ;
13163: LD_VAR 0 1
13167: RET
// every 5 5$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
13168: LD_EXP 31
13172: PUSH
13173: LD_EXP 23
13177: NOT
13178: AND
13179: IFFALSE 13407
13181: GO 13183
13183: DISABLE
13184: LD_INT 0
13186: PPUSH
13187: PPUSH
13188: PPUSH
// begin enable ;
13189: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
13190: LD_ADDR_VAR 0 2
13194: PUSH
13195: LD_INT 81
13197: PUSH
13198: LD_INT 7
13200: PUSH
13201: EMPTY
13202: LIST
13203: LIST
13204: PUSH
13205: LD_INT 2
13207: PUSH
13208: LD_INT 32
13210: PUSH
13211: LD_INT 3
13213: PUSH
13214: EMPTY
13215: LIST
13216: LIST
13217: PUSH
13218: LD_INT 30
13220: PUSH
13221: LD_INT 30
13223: PUSH
13224: EMPTY
13225: LIST
13226: LIST
13227: PUSH
13228: LD_INT 30
13230: PUSH
13231: LD_INT 28
13233: PUSH
13234: EMPTY
13235: LIST
13236: LIST
13237: PUSH
13238: LD_INT 34
13240: PUSH
13241: LD_INT 49
13243: PUSH
13244: EMPTY
13245: LIST
13246: LIST
13247: PUSH
13248: LD_INT 34
13250: PUSH
13251: LD_INT 10
13253: PUSH
13254: EMPTY
13255: LIST
13256: LIST
13257: PUSH
13258: LD_INT 34
13260: PUSH
13261: LD_INT 8
13263: PUSH
13264: EMPTY
13265: LIST
13266: LIST
13267: PUSH
13268: EMPTY
13269: LIST
13270: LIST
13271: LIST
13272: LIST
13273: LIST
13274: LIST
13275: LIST
13276: PUSH
13277: EMPTY
13278: LIST
13279: LIST
13280: PPUSH
13281: CALL_OW 69
13285: ST_TO_ADDR
// if not tmp then
13286: LD_VAR 0 2
13290: NOT
13291: IFFALSE 13295
// exit ;
13293: GO 13407
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
13295: LD_VAR 0 2
13299: PPUSH
13300: LD_INT 34
13302: PUSH
13303: LD_INT 8
13305: PUSH
13306: EMPTY
13307: LIST
13308: LIST
13309: PPUSH
13310: CALL_OW 72
13314: IFFALSE 13347
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
13316: LD_ADDR_VAR 0 3
13320: PUSH
13321: LD_VAR 0 2
13325: PPUSH
13326: LD_INT 34
13328: PUSH
13329: LD_INT 8
13331: PUSH
13332: EMPTY
13333: LIST
13334: LIST
13335: PPUSH
13336: CALL_OW 72
13340: PUSH
13341: LD_INT 1
13343: ARRAY
13344: ST_TO_ADDR
13345: GO 13371
// target := tmp [ rand ( 1 , tmp ) ] ;
13347: LD_ADDR_VAR 0 3
13351: PUSH
13352: LD_VAR 0 2
13356: PUSH
13357: LD_INT 1
13359: PPUSH
13360: LD_VAR 0 2
13364: PPUSH
13365: CALL_OW 12
13369: ARRAY
13370: ST_TO_ADDR
// if GetSide ( target ) = 1 then
13371: LD_VAR 0 3
13375: PPUSH
13376: CALL_OW 255
13380: PUSH
13381: LD_INT 1
13383: EQUAL
13384: IFFALSE 13395
// CenterNowOnUnits ( target ) ;
13386: LD_VAR 0 3
13390: PPUSH
13391: CALL_OW 87
// SetLives ( target , 0 ) ;
13395: LD_VAR 0 3
13399: PPUSH
13400: LD_INT 0
13402: PPUSH
13403: CALL_OW 234
// end ;
13407: PPOPN 3
13409: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
13410: LD_EXP 23
13414: NOT
13415: PUSH
13416: LD_EXP 31
13420: AND
13421: IFFALSE 13947
13423: GO 13425
13425: DISABLE
13426: LD_INT 0
13428: PPUSH
13429: PPUSH
13430: PPUSH
// begin uc_side := 7 ;
13431: LD_ADDR_OWVAR 20
13435: PUSH
13436: LD_INT 7
13438: ST_TO_ADDR
// uc_nation := 1 ;
13439: LD_ADDR_OWVAR 21
13443: PUSH
13444: LD_INT 1
13446: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
13447: LD_ADDR_VAR 0 3
13451: PUSH
13452: LD_INT 125
13454: PUSH
13455: LD_INT 163
13457: PUSH
13458: EMPTY
13459: LIST
13460: LIST
13461: PUSH
13462: LD_INT 185
13464: PUSH
13465: LD_INT 168
13467: PUSH
13468: EMPTY
13469: LIST
13470: LIST
13471: PUSH
13472: LD_INT 111
13474: PUSH
13475: LD_INT 97
13477: PUSH
13478: EMPTY
13479: LIST
13480: LIST
13481: PUSH
13482: EMPTY
13483: LIST
13484: LIST
13485: LIST
13486: PPUSH
13487: CALL 105371 0 1
13491: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
13492: LD_ADDR_EXP 94
13496: PUSH
13497: EMPTY
13498: ST_TO_ADDR
// for i = 1 to Difficulty do
13499: LD_ADDR_VAR 0 1
13503: PUSH
13504: DOUBLE
13505: LD_INT 1
13507: DEC
13508: ST_TO_ADDR
13509: LD_OWVAR 67
13513: PUSH
13514: FOR_TO
13515: IFFALSE 13673
// begin InitHc ;
13517: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
13521: LD_INT 0
13523: PPUSH
13524: LD_INT 8
13526: PPUSH
13527: CALL_OW 381
// un := CreateHuman ;
13531: LD_ADDR_VAR 0 2
13535: PUSH
13536: CALL_OW 44
13540: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
13541: LD_VAR 0 2
13545: PPUSH
13546: LD_INT 258
13548: PPUSH
13549: LD_INT 267
13551: PPUSH
13552: LD_INT 4
13554: PPUSH
13555: LD_INT 0
13557: PPUSH
13558: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
13562: LD_ADDR_EXP 94
13566: PUSH
13567: LD_EXP 94
13571: PUSH
13572: LD_VAR 0 2
13576: UNION
13577: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
13578: LD_VAR 0 2
13582: PPUSH
13583: LD_VAR 0 3
13587: PUSH
13588: LD_VAR 0 1
13592: ARRAY
13593: PUSH
13594: LD_INT 1
13596: ARRAY
13597: PPUSH
13598: LD_VAR 0 3
13602: PUSH
13603: LD_VAR 0 1
13607: ARRAY
13608: PUSH
13609: LD_INT 2
13611: ARRAY
13612: PPUSH
13613: LD_INT 4
13615: PPUSH
13616: LD_INT 1
13618: PPUSH
13619: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
13623: LD_VAR 0 2
13627: PPUSH
13628: LD_VAR 0 3
13632: PUSH
13633: LD_VAR 0 1
13637: ARRAY
13638: PUSH
13639: LD_INT 1
13641: ARRAY
13642: PPUSH
13643: LD_VAR 0 3
13647: PUSH
13648: LD_VAR 0 1
13652: ARRAY
13653: PUSH
13654: LD_INT 2
13656: ARRAY
13657: PPUSH
13658: CALL_OW 171
// AddComInvisible ( un ) ;
13662: LD_VAR 0 2
13666: PPUSH
13667: CALL_OW 212
// end ;
13671: GO 13514
13673: POP
13674: POP
// repeat wait ( 0 0$20 ) ;
13675: LD_INT 700
13677: PPUSH
13678: CALL_OW 67
// for i in allianceSpecialForce do
13682: LD_ADDR_VAR 0 1
13686: PUSH
13687: LD_EXP 94
13691: PUSH
13692: FOR_IN
13693: IFFALSE 13932
// begin if IsInvisible ( i ) then
13695: LD_VAR 0 1
13699: PPUSH
13700: CALL_OW 571
13704: IFFALSE 13901
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 , 40 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
13706: LD_ADDR_VAR 0 3
13710: PUSH
13711: LD_INT 22
13713: PUSH
13714: LD_INT 1
13716: PUSH
13717: EMPTY
13718: LIST
13719: LIST
13720: PUSH
13721: LD_INT 50
13723: PUSH
13724: EMPTY
13725: LIST
13726: PUSH
13727: LD_INT 56
13729: PUSH
13730: EMPTY
13731: LIST
13732: PUSH
13733: LD_INT 91
13735: PUSH
13736: LD_VAR 0 1
13740: PUSH
13741: LD_INT 25
13743: PUSH
13744: LD_INT 30
13746: PUSH
13747: LD_INT 35
13749: PUSH
13750: LD_INT 40
13752: PUSH
13753: EMPTY
13754: LIST
13755: LIST
13756: LIST
13757: LIST
13758: PUSH
13759: LD_OWVAR 67
13763: ARRAY
13764: PUSH
13765: EMPTY
13766: LIST
13767: LIST
13768: LIST
13769: PUSH
13770: LD_INT 2
13772: PUSH
13773: LD_INT 25
13775: PUSH
13776: LD_INT 1
13778: PUSH
13779: EMPTY
13780: LIST
13781: LIST
13782: PUSH
13783: LD_INT 25
13785: PUSH
13786: LD_INT 2
13788: PUSH
13789: EMPTY
13790: LIST
13791: LIST
13792: PUSH
13793: LD_INT 25
13795: PUSH
13796: LD_INT 3
13798: PUSH
13799: EMPTY
13800: LIST
13801: LIST
13802: PUSH
13803: LD_INT 25
13805: PUSH
13806: LD_INT 4
13808: PUSH
13809: EMPTY
13810: LIST
13811: LIST
13812: PUSH
13813: LD_INT 25
13815: PUSH
13816: LD_INT 5
13818: PUSH
13819: EMPTY
13820: LIST
13821: LIST
13822: PUSH
13823: LD_INT 25
13825: PUSH
13826: LD_INT 8
13828: PUSH
13829: EMPTY
13830: LIST
13831: LIST
13832: PUSH
13833: EMPTY
13834: LIST
13835: LIST
13836: LIST
13837: LIST
13838: LIST
13839: LIST
13840: LIST
13841: PUSH
13842: EMPTY
13843: LIST
13844: LIST
13845: LIST
13846: LIST
13847: LIST
13848: PPUSH
13849: CALL_OW 69
13853: ST_TO_ADDR
// if not tmp then
13854: LD_VAR 0 3
13858: NOT
13859: IFFALSE 13863
// continue ;
13861: GO 13692
// if Prob ( 30 * Difficulty ) then
13863: LD_INT 30
13865: PUSH
13866: LD_OWVAR 67
13870: MUL
13871: PPUSH
13872: CALL_OW 13
13876: IFFALSE 13901
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
13878: LD_VAR 0 3
13882: PUSH
13883: LD_INT 1
13885: PPUSH
13886: LD_VAR 0 3
13890: PPUSH
13891: CALL_OW 12
13895: ARRAY
13896: PPUSH
13897: CALL 33216 0 1
// end ; if IsDead ( i ) then
13901: LD_VAR 0 1
13905: PPUSH
13906: CALL_OW 301
13910: IFFALSE 13930
// begin allianceSpecialForce := allianceSpecialForce diff i ;
13912: LD_ADDR_EXP 94
13916: PUSH
13917: LD_EXP 94
13921: PUSH
13922: LD_VAR 0 1
13926: DIFF
13927: ST_TO_ADDR
// continue ;
13928: GO 13692
// end ; end ;
13930: GO 13692
13932: POP
13933: POP
// until allianceDestroyed or not allianceSpecialForce ;
13934: LD_EXP 23
13938: PUSH
13939: LD_EXP 94
13943: NOT
13944: OR
13945: IFFALSE 13675
// end ;
13947: PPOPN 3
13949: END
// every 8 8$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
13950: LD_EXP 23
13954: NOT
13955: PUSH
13956: LD_EXP 31
13960: AND
13961: IFFALSE 14911
13963: GO 13965
13965: DISABLE
13966: LD_INT 0
13968: PPUSH
13969: PPUSH
13970: PPUSH
13971: PPUSH
// begin enable ;
13972: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
13973: LD_INT 22
13975: PUSH
13976: LD_INT 7
13978: PUSH
13979: EMPTY
13980: LIST
13981: LIST
13982: PUSH
13983: LD_INT 30
13985: PUSH
13986: LD_INT 3
13988: PUSH
13989: EMPTY
13990: LIST
13991: LIST
13992: PUSH
13993: EMPTY
13994: LIST
13995: LIST
13996: PPUSH
13997: CALL_OW 69
14001: NOT
14002: IFFALSE 14006
// exit ;
14004: GO 14911
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
14006: LD_ADDR_VAR 0 4
14010: PUSH
14011: LD_INT 22
14013: PUSH
14014: LD_INT 7
14016: PUSH
14017: EMPTY
14018: LIST
14019: LIST
14020: PUSH
14021: LD_INT 30
14023: PUSH
14024: LD_INT 34
14026: PUSH
14027: EMPTY
14028: LIST
14029: LIST
14030: PUSH
14031: EMPTY
14032: LIST
14033: LIST
14034: PPUSH
14035: CALL_OW 69
14039: ST_TO_ADDR
// if Prob ( 40 ) then
14040: LD_INT 40
14042: PPUSH
14043: CALL_OW 13
14047: IFFALSE 14193
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
14049: LD_INT 1
14051: PPUSH
14052: LD_INT 5
14054: PUSH
14055: LD_INT 3
14057: PUSH
14058: LD_INT 2
14060: PUSH
14061: LD_INT 6
14063: PUSH
14064: EMPTY
14065: LIST
14066: LIST
14067: LIST
14068: LIST
14069: PUSH
14070: LD_INT 5
14072: PUSH
14073: LD_INT 3
14075: PUSH
14076: LD_INT 2
14078: PUSH
14079: LD_INT 6
14081: PUSH
14082: EMPTY
14083: LIST
14084: LIST
14085: LIST
14086: LIST
14087: PUSH
14088: LD_INT 5
14090: PUSH
14091: LD_INT 3
14093: PUSH
14094: LD_INT 2
14096: PUSH
14097: LD_INT 6
14099: PUSH
14100: EMPTY
14101: LIST
14102: LIST
14103: LIST
14104: LIST
14105: PUSH
14106: LD_INT 5
14108: PUSH
14109: LD_INT 3
14111: PUSH
14112: LD_INT 2
14114: PUSH
14115: LD_INT 9
14117: PUSH
14118: EMPTY
14119: LIST
14120: LIST
14121: LIST
14122: LIST
14123: PUSH
14124: LD_INT 24
14126: PUSH
14127: LD_INT 3
14129: PUSH
14130: LD_INT 3
14132: PUSH
14133: LD_INT 45
14135: PUSH
14136: EMPTY
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: PUSH
14142: LD_INT 24
14144: PUSH
14145: LD_INT 3
14147: PUSH
14148: LD_INT 3
14150: PUSH
14151: LD_INT 47
14153: PUSH
14154: EMPTY
14155: LIST
14156: LIST
14157: LIST
14158: LIST
14159: PUSH
14160: LD_INT 24
14162: PUSH
14163: LD_INT 3
14165: PUSH
14166: LD_INT 3
14168: PUSH
14169: LD_INT 45
14171: PUSH
14172: EMPTY
14173: LIST
14174: LIST
14175: LIST
14176: LIST
14177: PUSH
14178: EMPTY
14179: LIST
14180: LIST
14181: LIST
14182: LIST
14183: LIST
14184: LIST
14185: LIST
14186: PPUSH
14187: CALL 61548 0 2
// end else
14191: GO 14335
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
14193: LD_INT 1
14195: PPUSH
14196: LD_INT 24
14198: PUSH
14199: LD_INT 3
14201: PUSH
14202: LD_INT 3
14204: PUSH
14205: LD_INT 47
14207: PUSH
14208: EMPTY
14209: LIST
14210: LIST
14211: LIST
14212: LIST
14213: PUSH
14214: LD_INT 24
14216: PUSH
14217: LD_INT 3
14219: PUSH
14220: LD_INT 3
14222: PUSH
14223: LD_INT 47
14225: PUSH
14226: EMPTY
14227: LIST
14228: LIST
14229: LIST
14230: LIST
14231: PUSH
14232: LD_INT 5
14234: PUSH
14235: LD_INT 3
14237: PUSH
14238: LD_INT 2
14240: PUSH
14241: LD_INT 9
14243: PUSH
14244: EMPTY
14245: LIST
14246: LIST
14247: LIST
14248: LIST
14249: PUSH
14250: LD_INT 5
14252: PUSH
14253: LD_INT 3
14255: PUSH
14256: LD_INT 2
14258: PUSH
14259: LD_INT 9
14261: PUSH
14262: EMPTY
14263: LIST
14264: LIST
14265: LIST
14266: LIST
14267: PUSH
14268: LD_INT 5
14270: PUSH
14271: LD_INT 3
14273: PUSH
14274: LD_INT 2
14276: PUSH
14277: LD_INT 9
14279: PUSH
14280: EMPTY
14281: LIST
14282: LIST
14283: LIST
14284: LIST
14285: PUSH
14286: LD_INT 24
14288: PUSH
14289: LD_INT 1
14291: PUSH
14292: LD_INT 3
14294: PUSH
14295: LD_INT 45
14297: PUSH
14298: EMPTY
14299: LIST
14300: LIST
14301: LIST
14302: LIST
14303: PUSH
14304: LD_INT 24
14306: PUSH
14307: LD_INT 1
14309: PUSH
14310: LD_INT 3
14312: PUSH
14313: LD_INT 45
14315: PUSH
14316: EMPTY
14317: LIST
14318: LIST
14319: LIST
14320: LIST
14321: PUSH
14322: EMPTY
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: PPUSH
14331: CALL 61548 0 2
// end ; repeat wait ( 0 0$1 ) ;
14335: LD_INT 35
14337: PPUSH
14338: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= 7 ;
14342: LD_INT 1
14344: PPUSH
14345: LD_INT 1
14347: PPUSH
14348: CALL 62966 0 2
14352: PUSH
14353: LD_INT 7
14355: GREATEREQUAL
14356: IFFALSE 14335
// wait ( 0 0$10 ) ;
14358: LD_INT 350
14360: PPUSH
14361: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
14365: LD_ADDR_VAR 0 2
14369: PUSH
14370: LD_INT 1
14372: PPUSH
14373: LD_INT 1
14375: PPUSH
14376: CALL 62966 0 2
14380: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
14381: LD_ADDR_EXP 119
14385: PUSH
14386: LD_EXP 119
14390: PPUSH
14391: LD_INT 1
14393: PPUSH
14394: LD_EXP 119
14398: PUSH
14399: LD_INT 1
14401: ARRAY
14402: PUSH
14403: LD_VAR 0 2
14407: DIFF
14408: PPUSH
14409: CALL_OW 1
14413: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
14414: LD_ADDR_VAR 0 3
14418: PUSH
14419: LD_INT 0
14421: PPUSH
14422: LD_INT 1
14424: PPUSH
14425: CALL_OW 12
14429: ST_TO_ADDR
// if target then
14430: LD_VAR 0 3
14434: IFFALSE 14600
// begin for i in tmp do
14436: LD_ADDR_VAR 0 1
14440: PUSH
14441: LD_VAR 0 2
14445: PUSH
14446: FOR_IN
14447: IFFALSE 14472
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
14449: LD_VAR 0 1
14453: PPUSH
14454: LD_INT 179
14456: PPUSH
14457: LD_INT 209
14459: PPUSH
14460: LD_INT 8
14462: PPUSH
14463: LD_INT 1
14465: PPUSH
14466: CALL_OW 483
14470: GO 14446
14472: POP
14473: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
14474: LD_ADDR_VAR 0 2
14478: PUSH
14479: LD_VAR 0 2
14483: PPUSH
14484: LD_INT 24
14486: PUSH
14487: LD_INT 250
14489: PUSH
14490: EMPTY
14491: LIST
14492: LIST
14493: PPUSH
14494: CALL_OW 72
14498: ST_TO_ADDR
// for i in tmp do
14499: LD_ADDR_VAR 0 1
14503: PUSH
14504: LD_VAR 0 2
14508: PUSH
14509: FOR_IN
14510: IFFALSE 14550
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
14512: LD_VAR 0 1
14516: PPUSH
14517: LD_INT 179
14519: PPUSH
14520: LD_INT 209
14522: PPUSH
14523: CALL_OW 297
14527: PUSH
14528: LD_INT 9
14530: GREATER
14531: IFFALSE 14548
// ComMoveXY ( i , 179 , 209 ) ;
14533: LD_VAR 0 1
14537: PPUSH
14538: LD_INT 179
14540: PPUSH
14541: LD_INT 209
14543: PPUSH
14544: CALL_OW 111
14548: GO 14509
14550: POP
14551: POP
// wait ( 0 0$1 ) ;
14552: LD_INT 35
14554: PPUSH
14555: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
14559: LD_VAR 0 2
14563: PPUSH
14564: LD_INT 92
14566: PUSH
14567: LD_INT 179
14569: PUSH
14570: LD_INT 209
14572: PUSH
14573: LD_INT 9
14575: PUSH
14576: EMPTY
14577: LIST
14578: LIST
14579: LIST
14580: LIST
14581: PPUSH
14582: CALL_OW 72
14586: PUSH
14587: LD_VAR 0 2
14591: PUSH
14592: LD_INT 1
14594: MINUS
14595: GREATEREQUAL
14596: IFFALSE 14474
// end else
14598: GO 14762
// begin for i in tmp do
14600: LD_ADDR_VAR 0 1
14604: PUSH
14605: LD_VAR 0 2
14609: PUSH
14610: FOR_IN
14611: IFFALSE 14636
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
14613: LD_VAR 0 1
14617: PPUSH
14618: LD_INT 285
14620: PPUSH
14621: LD_INT 163
14623: PPUSH
14624: LD_INT 8
14626: PPUSH
14627: LD_INT 1
14629: PPUSH
14630: CALL_OW 483
14634: GO 14610
14636: POP
14637: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
14638: LD_ADDR_VAR 0 2
14642: PUSH
14643: LD_VAR 0 2
14647: PPUSH
14648: LD_INT 24
14650: PUSH
14651: LD_INT 250
14653: PUSH
14654: EMPTY
14655: LIST
14656: LIST
14657: PPUSH
14658: CALL_OW 72
14662: ST_TO_ADDR
// for i in tmp do
14663: LD_ADDR_VAR 0 1
14667: PUSH
14668: LD_VAR 0 2
14672: PUSH
14673: FOR_IN
14674: IFFALSE 14714
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
14676: LD_VAR 0 1
14680: PPUSH
14681: LD_INT 285
14683: PPUSH
14684: LD_INT 163
14686: PPUSH
14687: CALL_OW 297
14691: PUSH
14692: LD_INT 9
14694: GREATER
14695: IFFALSE 14712
// ComMoveXY ( i , 285 , 163 ) ;
14697: LD_VAR 0 1
14701: PPUSH
14702: LD_INT 285
14704: PPUSH
14705: LD_INT 163
14707: PPUSH
14708: CALL_OW 111
14712: GO 14673
14714: POP
14715: POP
// wait ( 0 0$1 ) ;
14716: LD_INT 35
14718: PPUSH
14719: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
14723: LD_VAR 0 2
14727: PPUSH
14728: LD_INT 92
14730: PUSH
14731: LD_INT 285
14733: PUSH
14734: LD_INT 163
14736: PUSH
14737: LD_INT 9
14739: PUSH
14740: EMPTY
14741: LIST
14742: LIST
14743: LIST
14744: LIST
14745: PPUSH
14746: CALL_OW 72
14750: PUSH
14751: LD_VAR 0 2
14755: PUSH
14756: LD_INT 1
14758: MINUS
14759: GREATEREQUAL
14760: IFFALSE 14638
// end ; repeat wait ( 0 0$1 ) ;
14762: LD_INT 35
14764: PPUSH
14765: CALL_OW 67
// for i in tmp do
14769: LD_ADDR_VAR 0 1
14773: PUSH
14774: LD_VAR 0 2
14778: PUSH
14779: FOR_IN
14780: IFFALSE 14902
// if GetLives ( i ) > 251 then
14782: LD_VAR 0 1
14786: PPUSH
14787: CALL_OW 256
14791: PUSH
14792: LD_INT 251
14794: GREATER
14795: IFFALSE 14884
// begin if GetWeapon ( i ) = ru_time_lapser then
14797: LD_VAR 0 1
14801: PPUSH
14802: CALL_OW 264
14806: PUSH
14807: LD_INT 49
14809: EQUAL
14810: IFFALSE 14848
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
14812: LD_VAR 0 1
14816: PPUSH
14817: LD_INT 81
14819: PUSH
14820: LD_INT 7
14822: PUSH
14823: EMPTY
14824: LIST
14825: LIST
14826: PPUSH
14827: CALL_OW 69
14831: PPUSH
14832: LD_VAR 0 1
14836: PPUSH
14837: CALL_OW 74
14841: PPUSH
14842: CALL_OW 112
14846: GO 14882
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
14848: LD_VAR 0 1
14852: PPUSH
14853: LD_INT 81
14855: PUSH
14856: LD_INT 7
14858: PUSH
14859: EMPTY
14860: LIST
14861: LIST
14862: PPUSH
14863: CALL_OW 69
14867: PPUSH
14868: LD_VAR 0 1
14872: PPUSH
14873: CALL_OW 74
14877: PPUSH
14878: CALL_OW 115
// end else
14882: GO 14900
// tmp := tmp diff i ;
14884: LD_ADDR_VAR 0 2
14888: PUSH
14889: LD_VAR 0 2
14893: PUSH
14894: LD_VAR 0 1
14898: DIFF
14899: ST_TO_ADDR
14900: GO 14779
14902: POP
14903: POP
// until not tmp ;
14904: LD_VAR 0 2
14908: NOT
14909: IFFALSE 14762
// end ;
14911: PPOPN 4
14913: END
// every 1 1$30 trigger allianceActive and IsOk ( Roth ) and Difficulty > 2 do
14914: LD_EXP 31
14918: PUSH
14919: LD_EXP 77
14923: PPUSH
14924: CALL_OW 302
14928: AND
14929: PUSH
14930: LD_OWVAR 67
14934: PUSH
14935: LD_INT 2
14937: GREATER
14938: AND
14939: IFFALSE 15039
14941: GO 14943
14943: DISABLE
// begin enable ;
14944: ENABLE
// if GetDistUnitXY ( Roth , 245 , 234 ) > 6 then
14945: LD_EXP 77
14949: PPUSH
14950: LD_INT 245
14952: PPUSH
14953: LD_INT 234
14955: PPUSH
14956: CALL_OW 297
14960: PUSH
14961: LD_INT 6
14963: GREATER
14964: IFFALSE 14983
// ComMoveXY ( Roth , 245 , 234 ) else
14966: LD_EXP 77
14970: PPUSH
14971: LD_INT 245
14973: PPUSH
14974: LD_INT 234
14976: PPUSH
14977: CALL_OW 111
14981: GO 15039
// ComMoveHex ( Roth , [ [ 259 , 235 ] , [ 252 , 209 ] , [ 275 , 235 ] ] [ rand ( 1 , 3 ) ] ) ;
14983: LD_EXP 77
14987: PPUSH
14988: LD_INT 259
14990: PUSH
14991: LD_INT 235
14993: PUSH
14994: EMPTY
14995: LIST
14996: LIST
14997: PUSH
14998: LD_INT 252
15000: PUSH
15001: LD_INT 209
15003: PUSH
15004: EMPTY
15005: LIST
15006: LIST
15007: PUSH
15008: LD_INT 275
15010: PUSH
15011: LD_INT 235
15013: PUSH
15014: EMPTY
15015: LIST
15016: LIST
15017: PUSH
15018: EMPTY
15019: LIST
15020: LIST
15021: LIST
15022: PUSH
15023: LD_INT 1
15025: PPUSH
15026: LD_INT 3
15028: PPUSH
15029: CALL_OW 12
15033: ARRAY
15034: PPUSH
15035: CALL 109268 0 2
// end ; end_of_file
15039: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
15040: LD_INT 0
15042: PPUSH
15043: PPUSH
15044: PPUSH
15045: PPUSH
// missionStage := 13 ;
15046: LD_ADDR_EXP 15
15050: PUSH
15051: LD_INT 13
15053: ST_TO_ADDR
// uc_side := 2 ;
15054: LD_ADDR_OWVAR 20
15058: PUSH
15059: LD_INT 2
15061: ST_TO_ADDR
// uc_nation := 2 ;
15062: LD_ADDR_OWVAR 21
15066: PUSH
15067: LD_INT 2
15069: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
15070: LD_ADDR_EXP 95
15074: PUSH
15075: LD_STRING Omar
15077: PPUSH
15078: CALL_OW 25
15082: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
15083: LD_EXP 95
15087: PPUSH
15088: LD_INT 4
15090: PPUSH
15091: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
15095: LD_EXP 95
15099: PPUSH
15100: LD_INT 242
15102: PPUSH
15103: LD_INT 75
15105: PPUSH
15106: LD_INT 0
15108: PPUSH
15109: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
15113: LD_ADDR_EXP 96
15117: PUSH
15118: LD_STRING Heike
15120: PPUSH
15121: CALL_OW 25
15125: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
15126: LD_INT 14
15128: PPUSH
15129: LD_INT 3
15131: PPUSH
15132: LD_INT 1
15134: PPUSH
15135: LD_INT 27
15137: PPUSH
15138: LD_INT 100
15140: PPUSH
15141: CALL 72814 0 5
// veh := CreateVehicle ;
15145: LD_ADDR_VAR 0 3
15149: PUSH
15150: CALL_OW 45
15154: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
15155: LD_VAR 0 3
15159: PPUSH
15160: LD_INT 2
15162: NEG
15163: PPUSH
15164: CALL_OW 242
// SetDir ( veh , 4 ) ;
15168: LD_VAR 0 3
15172: PPUSH
15173: LD_INT 4
15175: PPUSH
15176: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
15180: LD_VAR 0 3
15184: PPUSH
15185: LD_INT 241
15187: PPUSH
15188: LD_INT 72
15190: PPUSH
15191: LD_INT 0
15193: PPUSH
15194: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
15198: LD_EXP 96
15202: PPUSH
15203: LD_VAR 0 3
15207: PPUSH
15208: CALL_OW 52
// if KhatamStatus then
15212: LD_EXP 8
15216: IFFALSE 15279
// begin Khatam := NewCharacter ( Khatam ) ;
15218: LD_ADDR_EXP 97
15222: PUSH
15223: LD_STRING Khatam
15225: PPUSH
15226: CALL_OW 25
15230: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
15231: LD_EXP 97
15235: PPUSH
15236: LD_INT 245
15238: PPUSH
15239: LD_INT 78
15241: PPUSH
15242: LD_INT 3
15244: PPUSH
15245: LD_INT 0
15247: PPUSH
15248: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
15252: LD_EXP 97
15256: PPUSH
15257: LD_INT 4
15259: PPUSH
15260: LD_INT 10
15262: PPUSH
15263: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
15267: LD_EXP 97
15271: PPUSH
15272: LD_INT 4
15274: PPUSH
15275: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
15279: LD_ADDR_VAR 0 2
15283: PUSH
15284: DOUBLE
15285: LD_INT 1
15287: DEC
15288: ST_TO_ADDR
15289: LD_INT 2
15291: PUSH
15292: LD_INT 2
15294: PUSH
15295: LD_INT 3
15297: PUSH
15298: LD_INT 3
15300: PUSH
15301: EMPTY
15302: LIST
15303: LIST
15304: LIST
15305: LIST
15306: PUSH
15307: LD_OWVAR 67
15311: ARRAY
15312: PUSH
15313: FOR_TO
15314: IFFALSE 15380
// begin PrepareScientist ( false , 6 + Difficulty ) ;
15316: LD_INT 0
15318: PPUSH
15319: LD_INT 6
15321: PUSH
15322: LD_OWVAR 67
15326: PLUS
15327: PPUSH
15328: CALL_OW 384
// un := CreateHuman ;
15332: LD_ADDR_VAR 0 4
15336: PUSH
15337: CALL_OW 44
15341: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
15342: LD_VAR 0 4
15346: PPUSH
15347: LD_INT 28
15349: PUSH
15350: LD_INT 29
15352: PUSH
15353: EMPTY
15354: LIST
15355: LIST
15356: PUSH
15357: LD_VAR 0 2
15361: PUSH
15362: LD_INT 2
15364: MOD
15365: PUSH
15366: LD_INT 1
15368: PLUS
15369: ARRAY
15370: PPUSH
15371: LD_INT 0
15373: PPUSH
15374: CALL_OW 49
// end ;
15378: GO 15313
15380: POP
15381: POP
// for i = 1 to 6 do
15382: LD_ADDR_VAR 0 2
15386: PUSH
15387: DOUBLE
15388: LD_INT 1
15390: DEC
15391: ST_TO_ADDR
15392: LD_INT 6
15394: PUSH
15395: FOR_TO
15396: IFFALSE 15441
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
15398: LD_INT 0
15400: PPUSH
15401: LD_INT 6
15403: PUSH
15404: LD_OWVAR 67
15408: PLUS
15409: PPUSH
15410: CALL_OW 381
// un := CreateHuman ;
15414: LD_ADDR_VAR 0 4
15418: PUSH
15419: CALL_OW 44
15423: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
15424: LD_VAR 0 4
15428: PPUSH
15429: LD_INT 32
15431: PPUSH
15432: LD_INT 0
15434: PPUSH
15435: CALL_OW 49
// end ;
15439: GO 15395
15441: POP
15442: POP
// for i = 1 to 3 do
15443: LD_ADDR_VAR 0 2
15447: PUSH
15448: DOUBLE
15449: LD_INT 1
15451: DEC
15452: ST_TO_ADDR
15453: LD_INT 3
15455: PUSH
15456: FOR_TO
15457: IFFALSE 15505
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
15459: LD_INT 0
15461: PPUSH
15462: LD_INT 8
15464: PPUSH
15465: LD_INT 6
15467: PUSH
15468: LD_OWVAR 67
15472: PLUS
15473: PPUSH
15474: CALL_OW 380
// un := CreateHuman ;
15478: LD_ADDR_VAR 0 4
15482: PUSH
15483: CALL_OW 44
15487: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
15488: LD_VAR 0 4
15492: PPUSH
15493: LD_INT 32
15495: PPUSH
15496: LD_INT 0
15498: PPUSH
15499: CALL_OW 49
// end ;
15503: GO 15456
15505: POP
15506: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
15507: LD_ADDR_VAR 0 2
15511: PUSH
15512: DOUBLE
15513: LD_INT 1
15515: DEC
15516: ST_TO_ADDR
15517: LD_INT 2
15519: PUSH
15520: LD_INT 3
15522: PUSH
15523: LD_INT 4
15525: PUSH
15526: LD_INT 4
15528: PUSH
15529: EMPTY
15530: LIST
15531: LIST
15532: LIST
15533: LIST
15534: PUSH
15535: LD_OWVAR 67
15539: ARRAY
15540: PUSH
15541: FOR_TO
15542: IFFALSE 15632
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
15544: LD_INT 14
15546: PPUSH
15547: LD_INT 2
15549: PPUSH
15550: LD_INT 1
15552: PPUSH
15553: LD_INT 28
15555: PPUSH
15556: LD_INT 80
15558: PPUSH
15559: CALL 72814 0 5
// veh := CreateVehicle ;
15563: LD_ADDR_VAR 0 3
15567: PUSH
15568: CALL_OW 45
15572: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
15573: LD_VAR 0 3
15577: PPUSH
15578: LD_INT 3
15580: PPUSH
15581: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
15585: LD_VAR 0 3
15589: PPUSH
15590: LD_INT 29
15592: PPUSH
15593: LD_INT 0
15595: PPUSH
15596: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
15600: LD_INT 0
15602: PPUSH
15603: LD_INT 6
15605: PUSH
15606: LD_OWVAR 67
15610: PLUS
15611: PPUSH
15612: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
15616: CALL_OW 44
15620: PPUSH
15621: LD_VAR 0 3
15625: PPUSH
15626: CALL_OW 52
// end ;
15630: GO 15541
15632: POP
15633: POP
// for i = 1 to 5 + Difficulty do
15634: LD_ADDR_VAR 0 2
15638: PUSH
15639: DOUBLE
15640: LD_INT 1
15642: DEC
15643: ST_TO_ADDR
15644: LD_INT 5
15646: PUSH
15647: LD_OWVAR 67
15651: PLUS
15652: PUSH
15653: FOR_TO
15654: IFFALSE 15781
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
15656: LD_INT 14
15658: PPUSH
15659: LD_INT 1
15661: PPUSH
15662: LD_INT 3
15664: PPUSH
15665: CALL_OW 12
15669: PPUSH
15670: LD_INT 1
15672: PPUSH
15673: LD_INT 28
15675: PUSH
15676: LD_INT 26
15678: PUSH
15679: LD_INT 27
15681: PUSH
15682: LD_INT 25
15684: PUSH
15685: EMPTY
15686: LIST
15687: LIST
15688: LIST
15689: LIST
15690: PUSH
15691: LD_VAR 0 2
15695: PUSH
15696: LD_INT 4
15698: MOD
15699: PUSH
15700: LD_INT 1
15702: PLUS
15703: ARRAY
15704: PPUSH
15705: LD_INT 80
15707: PPUSH
15708: CALL 72814 0 5
// veh := CreateVehicle ;
15712: LD_ADDR_VAR 0 3
15716: PUSH
15717: CALL_OW 45
15721: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
15722: LD_VAR 0 3
15726: PPUSH
15727: LD_INT 4
15729: PPUSH
15730: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
15734: LD_VAR 0 3
15738: PPUSH
15739: LD_INT 28
15741: PPUSH
15742: LD_INT 0
15744: PPUSH
15745: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
15749: LD_INT 0
15751: PPUSH
15752: LD_INT 6
15754: PUSH
15755: LD_OWVAR 67
15759: PLUS
15760: PPUSH
15761: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
15765: CALL_OW 44
15769: PPUSH
15770: LD_VAR 0 3
15774: PPUSH
15775: CALL_OW 52
// end ;
15779: GO 15653
15781: POP
15782: POP
// for i = 1 to Difficulty do
15783: LD_ADDR_VAR 0 2
15787: PUSH
15788: DOUBLE
15789: LD_INT 1
15791: DEC
15792: ST_TO_ADDR
15793: LD_OWVAR 67
15797: PUSH
15798: FOR_TO
15799: IFFALSE 15859
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
15801: LD_INT 14
15803: PPUSH
15804: LD_INT 3
15806: PPUSH
15807: LD_INT 5
15809: PPUSH
15810: LD_INT 29
15812: PPUSH
15813: LD_INT 80
15815: PPUSH
15816: CALL 72814 0 5
// veh := CreateVehicle ;
15820: LD_ADDR_VAR 0 3
15824: PUSH
15825: CALL_OW 45
15829: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
15830: LD_VAR 0 3
15834: PPUSH
15835: LD_INT 4
15837: PPUSH
15838: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
15842: LD_VAR 0 3
15846: PPUSH
15847: LD_INT 28
15849: PPUSH
15850: LD_INT 0
15852: PPUSH
15853: CALL_OW 49
// end ;
15857: GO 15798
15859: POP
15860: POP
// end ;
15861: LD_VAR 0 1
15865: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
15866: LD_INT 22
15868: PUSH
15869: LD_INT 2
15871: PUSH
15872: EMPTY
15873: LIST
15874: LIST
15875: PPUSH
15876: CALL_OW 69
15880: IFFALSE 16259
15882: GO 15884
15884: DISABLE
15885: LD_INT 0
15887: PPUSH
15888: PPUSH
15889: PPUSH
15890: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
15891: LD_ADDR_VAR 0 3
15895: PUSH
15896: LD_INT 22
15898: PUSH
15899: LD_INT 2
15901: PUSH
15902: EMPTY
15903: LIST
15904: LIST
15905: PUSH
15906: LD_INT 25
15908: PUSH
15909: LD_INT 4
15911: PUSH
15912: EMPTY
15913: LIST
15914: LIST
15915: PUSH
15916: EMPTY
15917: LIST
15918: LIST
15919: PPUSH
15920: CALL_OW 69
15924: PUSH
15925: LD_EXP 97
15929: DIFF
15930: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
15931: LD_ADDR_VAR 0 2
15935: PUSH
15936: LD_INT 22
15938: PUSH
15939: LD_INT 2
15941: PUSH
15942: EMPTY
15943: LIST
15944: LIST
15945: PPUSH
15946: CALL_OW 69
15950: PUSH
15951: LD_EXP 97
15955: PUSH
15956: LD_VAR 0 3
15960: UNION
15961: DIFF
15962: ST_TO_ADDR
// if Khatam then
15963: LD_EXP 97
15967: IFFALSE 15984
// ComMoveXY ( Khatam , 211 , 92 ) ;
15969: LD_EXP 97
15973: PPUSH
15974: LD_INT 211
15976: PPUSH
15977: LD_INT 92
15979: PPUSH
15980: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
15984: LD_INT 197
15986: PPUSH
15987: LD_INT 80
15989: PPUSH
15990: LD_INT 2
15992: PPUSH
15993: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
15997: LD_INT 213
15999: PPUSH
16000: LD_INT 90
16002: PPUSH
16003: LD_INT 2
16005: PPUSH
16006: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
16010: LD_INT 215
16012: PPUSH
16013: LD_INT 129
16015: PPUSH
16016: LD_INT 2
16018: PPUSH
16019: CALL_OW 441
// if sci then
16023: LD_VAR 0 3
16027: IFFALSE 16048
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
16029: LD_VAR 0 3
16033: PUSH
16034: LD_INT 1
16036: ARRAY
16037: PPUSH
16038: LD_INT 197
16040: PPUSH
16041: LD_INT 80
16043: PPUSH
16044: CALL_OW 158
// if sci > 1 then
16048: LD_VAR 0 3
16052: PUSH
16053: LD_INT 1
16055: GREATER
16056: IFFALSE 16077
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
16058: LD_VAR 0 3
16062: PUSH
16063: LD_INT 2
16065: ARRAY
16066: PPUSH
16067: LD_INT 213
16069: PPUSH
16070: LD_INT 90
16072: PPUSH
16073: CALL_OW 158
// if sci > 2 then
16077: LD_VAR 0 3
16081: PUSH
16082: LD_INT 2
16084: GREATER
16085: IFFALSE 16106
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
16087: LD_VAR 0 3
16091: PUSH
16092: LD_INT 3
16094: ARRAY
16095: PPUSH
16096: LD_INT 215
16098: PPUSH
16099: LD_INT 129
16101: PPUSH
16102: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
16106: LD_VAR 0 2
16110: PPUSH
16111: LD_INT 195
16113: PPUSH
16114: LD_INT 102
16116: PPUSH
16117: CALL_OW 114
// wait ( 0 0$5 ) ;
16121: LD_INT 175
16123: PPUSH
16124: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
16128: LD_INT 70
16130: PPUSH
16131: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
16135: LD_ADDR_VAR 0 4
16139: PUSH
16140: LD_INT 92
16142: PUSH
16143: LD_INT 195
16145: PUSH
16146: LD_INT 102
16148: PUSH
16149: LD_INT 36
16151: PUSH
16152: EMPTY
16153: LIST
16154: LIST
16155: LIST
16156: LIST
16157: PUSH
16158: LD_INT 22
16160: PUSH
16161: LD_INT 1
16163: PUSH
16164: EMPTY
16165: LIST
16166: LIST
16167: PUSH
16168: EMPTY
16169: LIST
16170: LIST
16171: PPUSH
16172: CALL_OW 69
16176: ST_TO_ADDR
// for i in tmp do
16177: LD_ADDR_VAR 0 1
16181: PUSH
16182: LD_VAR 0 2
16186: PUSH
16187: FOR_IN
16188: IFFALSE 16239
// if enemy then
16190: LD_VAR 0 4
16194: IFFALSE 16222
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
16196: LD_VAR 0 1
16200: PPUSH
16201: LD_VAR 0 4
16205: PPUSH
16206: LD_VAR 0 1
16210: PPUSH
16211: CALL_OW 74
16215: PPUSH
16216: CALL_OW 115
16220: GO 16237
// ComAgressiveMove ( i , 195 , 102 ) ;
16222: LD_VAR 0 1
16226: PPUSH
16227: LD_INT 195
16229: PPUSH
16230: LD_INT 102
16232: PPUSH
16233: CALL_OW 114
16237: GO 16187
16239: POP
16240: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
16241: LD_VAR 0 2
16245: PPUSH
16246: LD_INT 50
16248: PUSH
16249: EMPTY
16250: LIST
16251: PPUSH
16252: CALL_OW 72
16256: NOT
16257: IFFALSE 16128
// end ; end_of_file
16259: PPOPN 4
16261: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
16262: LD_INT 0
16264: PPUSH
16265: PPUSH
16266: PPUSH
16267: PPUSH
16268: PPUSH
16269: PPUSH
16270: PPUSH
16271: PPUSH
16272: PPUSH
// Video ( true ) ;
16273: LD_INT 1
16275: PPUSH
16276: CALL 105238 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
16280: LD_ADDR_VAR 0 5
16284: PUSH
16285: LD_INT 7
16287: PPUSH
16288: LD_INT 0
16290: PPUSH
16291: CALL_OW 517
16295: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
16296: LD_ADDR_VAR 0 2
16300: PUSH
16301: DOUBLE
16302: LD_INT 1
16304: DEC
16305: ST_TO_ADDR
16306: LD_VAR 0 5
16310: PUSH
16311: LD_INT 1
16313: ARRAY
16314: PUSH
16315: FOR_TO
16316: IFFALSE 16361
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
16318: LD_VAR 0 5
16322: PUSH
16323: LD_INT 1
16325: ARRAY
16326: PUSH
16327: LD_VAR 0 2
16331: ARRAY
16332: PPUSH
16333: LD_VAR 0 5
16337: PUSH
16338: LD_INT 2
16340: ARRAY
16341: PUSH
16342: LD_VAR 0 2
16346: ARRAY
16347: PPUSH
16348: LD_INT 1
16350: PPUSH
16351: LD_INT 15
16353: NEG
16354: PPUSH
16355: CALL 105152 0 4
16359: GO 16315
16361: POP
16362: POP
// CenterNowOnUnits ( Powell ) ;
16363: LD_EXP 60
16367: PPUSH
16368: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
16372: LD_ADDR_VAR 0 5
16376: PUSH
16377: LD_EXP 58
16381: PUSH
16382: EMPTY
16383: LIST
16384: ST_TO_ADDR
// if GirlNewVeh then
16385: LD_EXP 59
16389: IFFALSE 16407
// tmp := tmp ^ GirlNewVeh ;
16391: LD_ADDR_VAR 0 5
16395: PUSH
16396: LD_VAR 0 5
16400: PUSH
16401: LD_EXP 59
16405: ADD
16406: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
16407: LD_VAR 0 5
16411: PPUSH
16412: LD_INT 60
16414: PPUSH
16415: LD_INT 109
16417: PPUSH
16418: CALL_OW 111
// if KappaStatus then
16422: LD_EXP 2
16426: IFFALSE 16478
// begin Say ( JMM , D1nT-JMM-1 ) ;
16428: LD_EXP 40
16432: PPUSH
16433: LD_STRING D1nT-JMM-1
16435: PPUSH
16436: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
16440: LD_EXP 60
16444: PPUSH
16445: LD_STRING D1T-Pow-1
16447: PPUSH
16448: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
16452: LD_EXP 40
16456: PPUSH
16457: LD_STRING D1T-JMM-2
16459: PPUSH
16460: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
16464: LD_EXP 60
16468: PPUSH
16469: LD_STRING D1T-Pow-2
16471: PPUSH
16472: CALL_OW 88
// end else
16476: GO 16684
// if JMMGirlStatus then
16478: LD_EXP 6
16482: IFFALSE 16627
// begin Say ( JMM , D1T-JMM-1 ) ;
16484: LD_EXP 40
16488: PPUSH
16489: LD_STRING D1T-JMM-1
16491: PPUSH
16492: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
16496: LD_EXP 60
16500: PPUSH
16501: LD_STRING D1T-Pow-1
16503: PPUSH
16504: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
16508: LD_EXP 40
16512: PPUSH
16513: LD_STRING D1T-JMM-3
16515: PPUSH
16516: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
16520: LD_EXP 60
16524: PPUSH
16525: LD_STRING D1T-Pow-3
16527: PPUSH
16528: CALL_OW 88
// if JMMGirl then
16532: LD_EXP 7
16536: IFFALSE 16625
// begin case JMMGirl of 1 :
16538: LD_EXP 7
16542: PUSH
16543: LD_INT 1
16545: DOUBLE
16546: EQUAL
16547: IFTRUE 16551
16549: GO 16566
16551: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
16552: LD_EXP 41
16556: PPUSH
16557: LD_STRING D1T-Joan-3
16559: PPUSH
16560: CALL_OW 88
16564: GO 16613
16566: LD_INT 2
16568: DOUBLE
16569: EQUAL
16570: IFTRUE 16574
16572: GO 16589
16574: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
16575: LD_EXP 43
16579: PPUSH
16580: LD_STRING D1T-Lisa-3
16582: PPUSH
16583: CALL_OW 88
16587: GO 16613
16589: LD_INT 3
16591: DOUBLE
16592: EQUAL
16593: IFTRUE 16597
16595: GO 16612
16597: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
16598: LD_EXP 55
16602: PPUSH
16603: LD_STRING D1T-Con-3
16605: PPUSH
16606: CALL_OW 88
16610: GO 16613
16612: POP
// Say ( Powell , D1T-Pow-4 ) ;
16613: LD_EXP 60
16617: PPUSH
16618: LD_STRING D1T-Pow-4
16620: PPUSH
16621: CALL_OW 88
// end ; end else
16625: GO 16684
// if not FastEnd then
16627: LD_EXP 11
16631: NOT
16632: IFFALSE 16660
// begin Say ( JMM , D1T-JMM-4 ) ;
16634: LD_EXP 40
16638: PPUSH
16639: LD_STRING D1T-JMM-4
16641: PPUSH
16642: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
16646: LD_EXP 60
16650: PPUSH
16651: LD_STRING D1T-Pow-5
16653: PPUSH
16654: CALL_OW 88
// end else
16658: GO 16684
// begin Say ( JMM , D1nT-JMM-1 ) ;
16660: LD_EXP 40
16664: PPUSH
16665: LD_STRING D1nT-JMM-1
16667: PPUSH
16668: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
16672: LD_EXP 60
16676: PPUSH
16677: LD_STRING D1nT-Pow-1
16679: PPUSH
16680: CALL_OW 88
// end ; repeat wait ( 3 ) ;
16684: LD_INT 3
16686: PPUSH
16687: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
16691: LD_EXP 58
16695: PPUSH
16696: CALL_OW 314
16700: NOT
16701: IFFALSE 16684
// ComExitVehicle ( JMM ) ;
16703: LD_EXP 40
16707: PPUSH
16708: CALL_OW 121
// repeat wait ( 3 ) ;
16712: LD_INT 3
16714: PPUSH
16715: CALL_OW 67
// until not IsInUnit ( JMM ) ;
16719: LD_EXP 40
16723: PPUSH
16724: CALL_OW 310
16728: NOT
16729: IFFALSE 16712
// ComMoveXY ( JMM , 60 , 94 ) ;
16731: LD_EXP 40
16735: PPUSH
16736: LD_INT 60
16738: PPUSH
16739: LD_INT 94
16741: PPUSH
16742: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16746: LD_EXP 40
16750: PPUSH
16751: LD_EXP 60
16755: PPUSH
16756: CALL_OW 179
// if Joan then
16760: LD_EXP 41
16764: IFFALSE 16818
// begin ComExitVehicle ( Joan ) ;
16766: LD_EXP 41
16770: PPUSH
16771: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
16775: LD_EXP 41
16779: PPUSH
16780: LD_INT 35
16782: PPUSH
16783: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
16787: LD_EXP 41
16791: PPUSH
16792: LD_INT 65
16794: PPUSH
16795: LD_INT 104
16797: PPUSH
16798: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
16802: LD_EXP 41
16806: PPUSH
16807: LD_EXP 40
16811: PPUSH
16812: CALL_OW 179
// end else
16816: GO 16952
// if Lisa and JMMGirl = 2 then
16818: LD_EXP 43
16822: PUSH
16823: LD_EXP 7
16827: PUSH
16828: LD_INT 2
16830: EQUAL
16831: AND
16832: IFFALSE 16886
// begin ComExitVehicle ( Lisa ) ;
16834: LD_EXP 43
16838: PPUSH
16839: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
16843: LD_EXP 43
16847: PPUSH
16848: LD_INT 35
16850: PPUSH
16851: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
16855: LD_EXP 43
16859: PPUSH
16860: LD_INT 65
16862: PPUSH
16863: LD_INT 104
16865: PPUSH
16866: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
16870: LD_EXP 43
16874: PPUSH
16875: LD_EXP 40
16879: PPUSH
16880: CALL_OW 179
// end else
16884: GO 16952
// if Connie and JMMGirl = 3 then
16886: LD_EXP 55
16890: PUSH
16891: LD_EXP 7
16895: PUSH
16896: LD_INT 3
16898: EQUAL
16899: AND
16900: IFFALSE 16952
// begin ComExitVehicle ( Connie ) ;
16902: LD_EXP 55
16906: PPUSH
16907: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
16911: LD_EXP 55
16915: PPUSH
16916: LD_INT 35
16918: PPUSH
16919: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
16923: LD_EXP 55
16927: PPUSH
16928: LD_INT 65
16930: PPUSH
16931: LD_INT 104
16933: PPUSH
16934: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
16938: LD_EXP 55
16942: PPUSH
16943: LD_EXP 40
16947: PPUSH
16948: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
16952: LD_INT 35
16954: PPUSH
16955: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
16959: LD_EXP 40
16963: PPUSH
16964: LD_EXP 60
16968: PPUSH
16969: CALL_OW 296
16973: PUSH
16974: LD_INT 8
16976: LESS
16977: IFFALSE 16952
// wait ( 0 0$0.5 ) ;
16979: LD_INT 18
16981: PPUSH
16982: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
16986: LD_EXP 40
16990: PPUSH
16991: LD_STRING D1-JMM-1
16993: PPUSH
16994: CALL_OW 88
// async ;
16998: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
16999: LD_EXP 60
17003: PPUSH
17004: LD_STRING D1-Pow-1
17006: PPUSH
17007: CALL_OW 88
// if not dialogue_skipped then
17011: LD_OWVAR 59
17015: NOT
17016: IFFALSE 17025
// wait ( 0 0$2 ) ;
17018: LD_INT 70
17020: PPUSH
17021: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
17025: LD_INT 170
17027: PPUSH
17028: LD_INT 99
17030: PPUSH
17031: LD_INT 1
17033: PPUSH
17034: LD_INT 6
17036: NEG
17037: PPUSH
17038: CALL 105152 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
17042: LD_INT 174
17044: PPUSH
17045: LD_INT 115
17047: PPUSH
17048: LD_INT 1
17050: PPUSH
17051: LD_INT 6
17053: NEG
17054: PPUSH
17055: CALL 105152 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
17059: LD_INT 169
17061: PPUSH
17062: LD_INT 71
17064: PPUSH
17065: LD_INT 1
17067: PPUSH
17068: LD_INT 6
17070: NEG
17071: PPUSH
17072: CALL 105152 0 4
// if not dialogue_skipped then
17076: LD_OWVAR 59
17080: NOT
17081: IFFALSE 17100
// begin CenterOnXY ( 170 , 99 ) ;
17083: LD_INT 170
17085: PPUSH
17086: LD_INT 99
17088: PPUSH
17089: CALL_OW 84
// wait ( 0 0$2.3 ) ;
17093: LD_INT 80
17095: PPUSH
17096: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
17100: LD_INT 75
17102: PPUSH
17103: LD_INT 53
17105: PPUSH
17106: LD_INT 1
17108: PPUSH
17109: LD_INT 9
17111: NEG
17112: PPUSH
17113: CALL 105152 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
17117: LD_INT 54
17119: PPUSH
17120: LD_INT 42
17122: PPUSH
17123: LD_INT 1
17125: PPUSH
17126: LD_INT 9
17128: NEG
17129: PPUSH
17130: CALL 105152 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
17134: LD_INT 62
17136: PPUSH
17137: LD_INT 51
17139: PPUSH
17140: LD_INT 1
17142: PPUSH
17143: LD_INT 9
17145: NEG
17146: PPUSH
17147: CALL 105152 0 4
// if not dialogue_skipped then
17151: LD_OWVAR 59
17155: NOT
17156: IFFALSE 17175
// begin CenterOnXY ( 75 , 53 ) ;
17158: LD_INT 75
17160: PPUSH
17161: LD_INT 53
17163: PPUSH
17164: CALL_OW 84
// wait ( 0 0$4 ) ;
17168: LD_INT 140
17170: PPUSH
17171: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
17175: LD_EXP 60
17179: PPUSH
17180: CALL_OW 87
// if not dialogue_skipped then
17184: LD_OWVAR 59
17188: NOT
17189: IFFALSE 17198
// wait ( 0 0$2 ) ;
17191: LD_INT 70
17193: PPUSH
17194: CALL_OW 67
// sync ;
17198: SYNC
// Say ( JMM , D1-JMM-2 ) ;
17199: LD_EXP 40
17203: PPUSH
17204: LD_STRING D1-JMM-2
17206: PPUSH
17207: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
17211: LD_EXP 60
17215: PPUSH
17216: LD_STRING D1-Pow-2
17218: PPUSH
17219: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
17223: LD_EXP 40
17227: PPUSH
17228: LD_STRING D1-JMM-3
17230: PPUSH
17231: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
17235: LD_EXP 60
17239: PPUSH
17240: LD_STRING D1-Pow-3
17242: PPUSH
17243: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
17247: LD_EXP 40
17251: PPUSH
17252: LD_STRING D1-JMM-4
17254: PPUSH
17255: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
17259: LD_EXP 60
17263: PPUSH
17264: LD_STRING D1-Pow-4
17266: PPUSH
17267: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
17271: LD_EXP 40
17275: PPUSH
17276: LD_STRING D1-JMM-5
17278: PPUSH
17279: CALL_OW 88
// async ;
17283: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
17284: LD_EXP 60
17288: PPUSH
17289: LD_STRING D1-Pow-5
17291: PPUSH
17292: CALL_OW 88
// if not dialogue_skipped then
17296: LD_OWVAR 59
17300: NOT
17301: IFFALSE 17310
// wait ( 0 0$3.6 ) ;
17303: LD_INT 126
17305: PPUSH
17306: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
17310: LD_INT 134
17312: PPUSH
17313: LD_INT 210
17315: PPUSH
17316: LD_INT 1
17318: PPUSH
17319: LD_INT 11
17321: NEG
17322: PPUSH
17323: CALL 105152 0 4
// if not dialogue_skipped then
17327: LD_OWVAR 59
17331: NOT
17332: IFFALSE 17351
// begin CenterOnXY ( 134 , 210 ) ;
17334: LD_INT 134
17336: PPUSH
17337: LD_INT 210
17339: PPUSH
17340: CALL_OW 84
// wait ( 0 0$2 ) ;
17344: LD_INT 70
17346: PPUSH
17347: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
17351: LD_INT 101
17353: PPUSH
17354: LD_INT 159
17356: PPUSH
17357: LD_INT 1
17359: PPUSH
17360: LD_INT 10
17362: NEG
17363: PPUSH
17364: CALL 105152 0 4
// if not dialogue_skipped then
17368: LD_OWVAR 59
17372: NOT
17373: IFFALSE 17392
// begin CenterOnXY ( 101 , 159 ) ;
17375: LD_INT 101
17377: PPUSH
17378: LD_INT 159
17380: PPUSH
17381: CALL_OW 84
// wait ( 0 0$2 ) ;
17385: LD_INT 70
17387: PPUSH
17388: CALL_OW 67
// end ; sync ;
17392: SYNC
// CenterNowOnUnits ( Powell ) ;
17393: LD_EXP 60
17397: PPUSH
17398: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
17402: LD_ADDR_VAR 0 6
17406: PUSH
17407: LD_INT 1
17409: PUSH
17410: LD_INT 2
17412: PUSH
17413: LD_INT 3
17415: PUSH
17416: LD_INT 4
17418: PUSH
17419: LD_INT 5
17421: PUSH
17422: LD_INT 6
17424: PUSH
17425: EMPTY
17426: LIST
17427: LIST
17428: LIST
17429: LIST
17430: LIST
17431: LIST
17432: ST_TO_ADDR
// if not dialogue_skipped then
17433: LD_OWVAR 59
17437: NOT
17438: IFFALSE 17607
// begin game_speed := 4 ;
17440: LD_ADDR_OWVAR 65
17444: PUSH
17445: LD_INT 4
17447: ST_TO_ADDR
// wait ( 0 0$6 ) ;
17448: LD_INT 210
17450: PPUSH
17451: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
17455: LD_ADDR_VAR 0 7
17459: PUSH
17460: LD_STRING Q1
17462: PPUSH
17463: LD_VAR 0 6
17467: PPUSH
17468: CALL_OW 98
17472: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
17473: LD_ADDR_VAR 0 7
17477: PUSH
17478: LD_STRING Q1
17480: PPUSH
17481: LD_VAR 0 6
17485: PPUSH
17486: CALL_OW 98
17490: ST_TO_ADDR
// options := options diff dec ;
17491: LD_ADDR_VAR 0 6
17495: PUSH
17496: LD_VAR 0 6
17500: PUSH
17501: LD_VAR 0 7
17505: DIFF
17506: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
17507: LD_VAR 0 7
17511: PPUSH
17512: LD_VAR 0 6
17516: PPUSH
17517: CALL 19171 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
17521: LD_VAR 0 7
17525: PUSH
17526: LD_INT 5
17528: PUSH
17529: LD_INT 6
17531: PUSH
17532: EMPTY
17533: LIST
17534: LIST
17535: IN
17536: PUSH
17537: LD_VAR 0 6
17541: PUSH
17542: LD_INT 2
17544: EQUAL
17545: OR
17546: IFFALSE 17473
// if not ( dec in [ 5 , 6 ] ) then
17548: LD_VAR 0 7
17552: PUSH
17553: LD_INT 5
17555: PUSH
17556: LD_INT 6
17558: PUSH
17559: EMPTY
17560: LIST
17561: LIST
17562: IN
17563: NOT
17564: IFFALSE 17607
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
17566: LD_ADDR_VAR 0 7
17570: PUSH
17571: LD_STRING Q1a
17573: PPUSH
17574: LD_INT 1
17576: PUSH
17577: LD_INT 2
17579: PUSH
17580: EMPTY
17581: LIST
17582: LIST
17583: PPUSH
17584: CALL_OW 98
17588: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
17589: LD_VAR 0 7
17593: PUSH
17594: LD_INT 4
17596: PLUS
17597: PPUSH
17598: LD_VAR 0 6
17602: PPUSH
17603: CALL 19171 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
17607: LD_INT 81
17609: PPUSH
17610: LD_INT 127
17612: PPUSH
17613: CALL_OW 84
// amount := 8 ;
17617: LD_ADDR_VAR 0 8
17621: PUSH
17622: LD_INT 8
17624: ST_TO_ADDR
// macmilan_squad := [ ] ;
17625: LD_ADDR_VAR 0 9
17629: PUSH
17630: EMPTY
17631: ST_TO_ADDR
// if vip < amount then
17632: LD_EXP 61
17636: PUSH
17637: LD_VAR 0 8
17641: LESS
17642: IFFALSE 17686
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
17644: LD_ADDR_VAR 0 5
17648: PUSH
17649: LD_EXP 61
17653: PUSH
17654: LD_INT 22
17656: PUSH
17657: LD_INT 4
17659: PUSH
17660: EMPTY
17661: LIST
17662: LIST
17663: PUSH
17664: LD_INT 21
17666: PUSH
17667: LD_INT 1
17669: PUSH
17670: EMPTY
17671: LIST
17672: LIST
17673: PUSH
17674: EMPTY
17675: LIST
17676: LIST
17677: PPUSH
17678: CALL_OW 69
17682: UNION
17683: ST_TO_ADDR
17684: GO 17696
// tmp := vip ;
17686: LD_ADDR_VAR 0 5
17690: PUSH
17691: LD_EXP 61
17695: ST_TO_ADDR
// tmp := tmp diff Powell ;
17696: LD_ADDR_VAR 0 5
17700: PUSH
17701: LD_VAR 0 5
17705: PUSH
17706: LD_EXP 60
17710: DIFF
17711: ST_TO_ADDR
// if tmp < amount then
17712: LD_VAR 0 5
17716: PUSH
17717: LD_VAR 0 8
17721: LESS
17722: IFFALSE 17734
// amount := tmp ;
17724: LD_ADDR_VAR 0 8
17728: PUSH
17729: LD_VAR 0 5
17733: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
17734: LD_VAR 0 5
17738: PUSH
17739: LD_INT 1
17741: ARRAY
17742: PPUSH
17743: CALL_OW 257
17747: PUSH
17748: LD_INT 2
17750: NONEQUAL
17751: IFFALSE 17849
// begin if IsInUnit ( tmp [ 1 ] ) then
17753: LD_VAR 0 5
17757: PUSH
17758: LD_INT 1
17760: ARRAY
17761: PPUSH
17762: CALL_OW 310
17766: IFFALSE 17781
// ComExitBuilding ( tmp [ 1 ] ) ;
17768: LD_VAR 0 5
17772: PUSH
17773: LD_INT 1
17775: ARRAY
17776: PPUSH
17777: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
17781: LD_INT 387
17783: PPUSH
17784: CALL_OW 313
17788: PUSH
17789: LD_INT 6
17791: EQUAL
17792: IFFALSE 17817
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
17794: LD_INT 387
17796: PPUSH
17797: CALL_OW 313
17801: PUSH
17802: LD_INT 1
17804: ARRAY
17805: PPUSH
17806: CALL_OW 122
// wait ( 3 ) ;
17810: LD_INT 3
17812: PPUSH
17813: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
17817: LD_VAR 0 5
17821: PUSH
17822: LD_INT 1
17824: ARRAY
17825: PPUSH
17826: LD_INT 387
17828: PPUSH
17829: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
17833: LD_VAR 0 5
17837: PUSH
17838: LD_INT 1
17840: ARRAY
17841: PPUSH
17842: LD_INT 2
17844: PPUSH
17845: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
17849: LD_EXP 40
17853: PPUSH
17854: LD_INT 82
17856: PPUSH
17857: LD_INT 129
17859: PPUSH
17860: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
17864: LD_EXP 40
17868: PPUSH
17869: LD_EXP 60
17873: PPUSH
17874: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
17878: LD_INT 22
17880: PUSH
17881: LD_INT 1
17883: PUSH
17884: EMPTY
17885: LIST
17886: LIST
17887: PPUSH
17888: CALL_OW 69
17892: PUSH
17893: LD_EXP 40
17897: DIFF
17898: PPUSH
17899: LD_INT 84
17901: PPUSH
17902: LD_INT 128
17904: PPUSH
17905: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
17909: LD_INT 22
17911: PUSH
17912: LD_INT 1
17914: PUSH
17915: EMPTY
17916: LIST
17917: LIST
17918: PPUSH
17919: CALL_OW 69
17923: PUSH
17924: LD_EXP 40
17928: DIFF
17929: PPUSH
17930: LD_EXP 40
17934: PPUSH
17935: CALL_OW 179
// for i = 1 to amount do
17939: LD_ADDR_VAR 0 2
17943: PUSH
17944: DOUBLE
17945: LD_INT 1
17947: DEC
17948: ST_TO_ADDR
17949: LD_VAR 0 8
17953: PUSH
17954: FOR_TO
17955: IFFALSE 18123
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
17957: LD_ADDR_VAR 0 9
17961: PUSH
17962: LD_VAR 0 9
17966: PUSH
17967: LD_VAR 0 5
17971: PUSH
17972: LD_VAR 0 2
17976: ARRAY
17977: ADD
17978: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
17979: LD_VAR 0 5
17983: PUSH
17984: LD_VAR 0 2
17988: ARRAY
17989: PPUSH
17990: CALL_OW 310
17994: IFFALSE 18011
// AddComExitBuilding ( tmp [ i ] ) ;
17996: LD_VAR 0 5
18000: PUSH
18001: LD_VAR 0 2
18005: ARRAY
18006: PPUSH
18007: CALL_OW 182
// if i = 2 and JMMNewVeh then
18011: LD_VAR 0 2
18015: PUSH
18016: LD_INT 2
18018: EQUAL
18019: PUSH
18020: LD_EXP 58
18024: AND
18025: IFFALSE 18083
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
18027: LD_VAR 0 5
18031: PUSH
18032: LD_VAR 0 2
18036: ARRAY
18037: PPUSH
18038: LD_EXP 58
18042: PPUSH
18043: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
18047: LD_VAR 0 5
18051: PUSH
18052: LD_VAR 0 2
18056: ARRAY
18057: PPUSH
18058: LD_INT 86
18060: PPUSH
18061: LD_INT 133
18063: PPUSH
18064: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
18068: LD_VAR 0 5
18072: PUSH
18073: LD_VAR 0 2
18077: ARRAY
18078: PPUSH
18079: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
18083: LD_VAR 0 5
18087: PUSH
18088: LD_VAR 0 2
18092: ARRAY
18093: PPUSH
18094: LD_INT 8
18096: PPUSH
18097: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
18101: LD_VAR 0 5
18105: PUSH
18106: LD_VAR 0 2
18110: ARRAY
18111: PPUSH
18112: LD_EXP 40
18116: PPUSH
18117: CALL_OW 179
// end ;
18121: GO 17954
18123: POP
18124: POP
// if GirlNewVeh then
18125: LD_EXP 59
18129: IFFALSE 18143
// SetSide ( GirlNewVeh , 4 ) ;
18131: LD_EXP 59
18135: PPUSH
18136: LD_INT 4
18138: PPUSH
18139: CALL_OW 235
// if Mike then
18143: LD_EXP 57
18147: IFFALSE 18184
// begin macmilan_squad := Join ( macmilan_squad , Mike ) ;
18149: LD_ADDR_VAR 0 9
18153: PUSH
18154: LD_VAR 0 9
18158: PPUSH
18159: LD_EXP 57
18163: PPUSH
18164: CALL 105266 0 2
18168: ST_TO_ADDR
// ComMoveXY ( Mike , 86 , 133 ) ;
18169: LD_EXP 57
18173: PPUSH
18174: LD_INT 86
18176: PPUSH
18177: LD_INT 133
18179: PPUSH
18180: CALL_OW 111
// end ; repeat wait ( 0 0$1 ) ;
18184: LD_INT 35
18186: PPUSH
18187: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
18191: LD_VAR 0 9
18195: PPUSH
18196: LD_INT 95
18198: PUSH
18199: LD_INT 9
18201: PUSH
18202: EMPTY
18203: LIST
18204: LIST
18205: PPUSH
18206: CALL_OW 72
18210: PUSH
18211: LD_INT 0
18213: EQUAL
18214: PUSH
18215: LD_EXP 40
18219: PPUSH
18220: LD_INT 9
18222: PPUSH
18223: CALL_OW 308
18227: NOT
18228: AND
18229: IFFALSE 18184
// wait ( 0 0$2 ) ;
18231: LD_INT 70
18233: PPUSH
18234: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
18238: LD_VAR 0 9
18242: PPUSH
18243: LD_INT 1
18245: PPUSH
18246: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
18250: LD_INT 21
18252: PUSH
18253: LD_INT 2
18255: PUSH
18256: EMPTY
18257: LIST
18258: LIST
18259: PUSH
18260: LD_INT 92
18262: PUSH
18263: LD_INT 83
18265: PUSH
18266: LD_INT 130
18268: PUSH
18269: LD_INT 10
18271: PUSH
18272: EMPTY
18273: LIST
18274: LIST
18275: LIST
18276: LIST
18277: PUSH
18278: EMPTY
18279: LIST
18280: LIST
18281: PPUSH
18282: CALL_OW 69
18286: PPUSH
18287: LD_INT 1
18289: PPUSH
18290: CALL_OW 235
// tick := 0 ;
18294: LD_ADDR_OWVAR 1
18298: PUSH
18299: LD_INT 0
18301: ST_TO_ADDR
// Video ( false ) ;
18302: LD_INT 0
18304: PPUSH
18305: CALL 105238 0 1
// ChangeMissionObjectives ( M1 ) ;
18309: LD_STRING M1
18311: PPUSH
18312: CALL_OW 337
// SaveForQuickRestart ;
18316: CALL_OW 22
// missionStart := true ;
18320: LD_ADDR_EXP 13
18324: PUSH
18325: LD_INT 1
18327: ST_TO_ADDR
// missionStage := 2 ;
18328: LD_ADDR_EXP 15
18332: PUSH
18333: LD_INT 2
18335: ST_TO_ADDR
// wait ( 0 0$1 ) ;
18336: LD_INT 35
18338: PPUSH
18339: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
18343: LD_ADDR_VAR 0 5
18347: PUSH
18348: LD_INT 22
18350: PUSH
18351: LD_INT 4
18353: PUSH
18354: EMPTY
18355: LIST
18356: LIST
18357: PUSH
18358: LD_INT 21
18360: PUSH
18361: LD_INT 1
18363: PUSH
18364: EMPTY
18365: LIST
18366: LIST
18367: PUSH
18368: EMPTY
18369: LIST
18370: LIST
18371: PPUSH
18372: CALL_OW 69
18376: PUSH
18377: LD_EXP 60
18381: DIFF
18382: ST_TO_ADDR
// if not tmp then
18383: LD_VAR 0 5
18387: NOT
18388: IFFALSE 18403
// tmp := [ Powell ] ;
18390: LD_ADDR_VAR 0 5
18394: PUSH
18395: LD_EXP 60
18399: PUSH
18400: EMPTY
18401: LIST
18402: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
18403: LD_ADDR_VAR 0 4
18407: PUSH
18408: LD_INT 22
18410: PUSH
18411: LD_INT 4
18413: PUSH
18414: EMPTY
18415: LIST
18416: LIST
18417: PUSH
18418: LD_INT 34
18420: PUSH
18421: LD_INT 12
18423: PUSH
18424: EMPTY
18425: LIST
18426: LIST
18427: PUSH
18428: EMPTY
18429: LIST
18430: LIST
18431: PPUSH
18432: CALL_OW 69
18436: PUSH
18437: LD_INT 1
18439: ARRAY
18440: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
18441: LD_VAR 0 5
18445: PUSH
18446: LD_INT 1
18448: ARRAY
18449: PPUSH
18450: CALL_OW 310
18454: IFFALSE 18469
// ComExitBuilding ( tmp [ 1 ] ) ;
18456: LD_VAR 0 5
18460: PUSH
18461: LD_INT 1
18463: ARRAY
18464: PPUSH
18465: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
18469: LD_VAR 0 5
18473: PUSH
18474: LD_INT 1
18476: ARRAY
18477: PPUSH
18478: LD_VAR 0 4
18482: PPUSH
18483: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
18487: LD_VAR 0 5
18491: PUSH
18492: LD_INT 1
18494: ARRAY
18495: PPUSH
18496: LD_INT 80
18498: PPUSH
18499: LD_INT 136
18501: PPUSH
18502: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
18506: LD_VAR 0 5
18510: PUSH
18511: LD_INT 1
18513: ARRAY
18514: PPUSH
18515: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
18519: LD_VAR 0 5
18523: PUSH
18524: LD_INT 1
18526: ARRAY
18527: PPUSH
18528: LD_INT 59
18530: PPUSH
18531: LD_INT 112
18533: PPUSH
18534: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
18538: LD_VAR 0 5
18542: PUSH
18543: LD_INT 1
18545: ARRAY
18546: PPUSH
18547: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
18551: LD_EXP 41
18555: PUSH
18556: LD_EXP 41
18560: PPUSH
18561: CALL_OW 255
18565: PUSH
18566: LD_INT 1
18568: EQUAL
18569: AND
18570: IFFALSE 18596
// begin Say ( Joan , D3W-Joan-1 ) ;
18572: LD_EXP 41
18576: PPUSH
18577: LD_STRING D3W-Joan-1
18579: PPUSH
18580: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18584: LD_EXP 40
18588: PPUSH
18589: LD_STRING D3W-JMM-1
18591: PPUSH
18592: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
18596: LD_EXP 43
18600: PUSH
18601: LD_EXP 43
18605: PPUSH
18606: CALL_OW 255
18610: PUSH
18611: LD_INT 1
18613: EQUAL
18614: AND
18615: PUSH
18616: LD_EXP 43
18620: PUSH
18621: LD_EXP 61
18625: IN
18626: NOT
18627: AND
18628: IFFALSE 18654
// begin Say ( Lisa , D3W-Lisa-1 ) ;
18630: LD_EXP 43
18634: PPUSH
18635: LD_STRING D3W-Lisa-1
18637: PPUSH
18638: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18642: LD_EXP 40
18646: PPUSH
18647: LD_STRING D3W-JMM-1
18649: PPUSH
18650: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
18654: LD_EXP 55
18658: PUSH
18659: LD_EXP 55
18663: PPUSH
18664: CALL_OW 255
18668: PUSH
18669: LD_INT 1
18671: EQUAL
18672: AND
18673: IFFALSE 18699
// begin Say ( Connie , D3W-Con-1 ) ;
18675: LD_EXP 55
18679: PPUSH
18680: LD_STRING D3W-Con-1
18682: PPUSH
18683: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18687: LD_EXP 40
18691: PPUSH
18692: LD_STRING D3W-JMM-1
18694: PPUSH
18695: CALL_OW 88
// end ; wait ( 0 0$0.5 ) ;
18699: LD_INT 18
18701: PPUSH
18702: CALL_OW 67
// if Lisa in vip and GetSide ( Lisa ) = 1 then
18706: LD_EXP 43
18710: PUSH
18711: LD_EXP 61
18715: IN
18716: PUSH
18717: LD_EXP 43
18721: PPUSH
18722: CALL_OW 255
18726: PUSH
18727: LD_INT 1
18729: EQUAL
18730: AND
18731: IFFALSE 18747
// Say ( Lisa , D3nW-Lisa-1 ) else
18733: LD_EXP 43
18737: PPUSH
18738: LD_STRING D3nW-Lisa-1
18740: PPUSH
18741: CALL_OW 88
18745: GO 18991
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
18747: LD_EXP 46
18751: PUSH
18752: LD_EXP 61
18756: IN
18757: PUSH
18758: LD_EXP 46
18762: PPUSH
18763: CALL_OW 255
18767: PUSH
18768: LD_INT 1
18770: EQUAL
18771: AND
18772: IFFALSE 18788
// Say ( Cyrus , D3nW-Cyrus-1 ) else
18774: LD_EXP 46
18778: PPUSH
18779: LD_STRING D3nW-Cyrus-1
18781: PPUSH
18782: CALL_OW 88
18786: GO 18991
// if Bobby in vip and GetSide ( Bobby ) = 1 then
18788: LD_EXP 45
18792: PUSH
18793: LD_EXP 61
18797: IN
18798: PUSH
18799: LD_EXP 45
18803: PPUSH
18804: CALL_OW 255
18808: PUSH
18809: LD_INT 1
18811: EQUAL
18812: AND
18813: IFFALSE 18829
// Say ( Bobby , D3nW-Bobby-1 ) else
18815: LD_EXP 45
18819: PPUSH
18820: LD_STRING D3nW-Bobby-1
18822: PPUSH
18823: CALL_OW 88
18827: GO 18991
// if Gary in vip and GetSide ( Gary ) = 1 then
18829: LD_EXP 52
18833: PUSH
18834: LD_EXP 61
18838: IN
18839: PUSH
18840: LD_EXP 52
18844: PPUSH
18845: CALL_OW 255
18849: PUSH
18850: LD_INT 1
18852: EQUAL
18853: AND
18854: IFFALSE 18870
// Say ( Gary , D3nW-Gary-1 ) else
18856: LD_EXP 52
18860: PPUSH
18861: LD_STRING D3nW-Gary-1
18863: PPUSH
18864: CALL_OW 88
18868: GO 18991
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
18870: LD_EXP 44
18874: PUSH
18875: LD_EXP 61
18879: IN
18880: PUSH
18881: LD_EXP 44
18885: PPUSH
18886: CALL_OW 255
18890: PUSH
18891: LD_INT 1
18893: EQUAL
18894: AND
18895: IFFALSE 18911
// Say ( Donaldson , D3nW-Don-1 ) else
18897: LD_EXP 44
18901: PPUSH
18902: LD_STRING D3nW-Don-1
18904: PPUSH
18905: CALL_OW 88
18909: GO 18991
// if Cornel in vip and GetSide ( Cornel ) = 1 then
18911: LD_EXP 51
18915: PUSH
18916: LD_EXP 61
18920: IN
18921: PUSH
18922: LD_EXP 51
18926: PPUSH
18927: CALL_OW 255
18931: PUSH
18932: LD_INT 1
18934: EQUAL
18935: AND
18936: IFFALSE 18952
// Say ( Cornel , D3nW-Corn-1 ) else
18938: LD_EXP 51
18942: PPUSH
18943: LD_STRING D3nW-Corn-1
18945: PPUSH
18946: CALL_OW 88
18950: GO 18991
// if Frank in vip and GetSide ( Frank ) = 1 then
18952: LD_EXP 53
18956: PUSH
18957: LD_EXP 61
18961: IN
18962: PUSH
18963: LD_EXP 53
18967: PPUSH
18968: CALL_OW 255
18972: PUSH
18973: LD_INT 1
18975: EQUAL
18976: AND
18977: IFFALSE 18991
// Say ( Frank , D3nW-Frank-1 ) ;
18979: LD_EXP 53
18983: PPUSH
18984: LD_STRING D3nW-Frank-1
18986: PPUSH
18987: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
18991: LD_EXP 61
18995: PPUSH
18996: LD_INT 22
18998: PUSH
18999: LD_INT 1
19001: PUSH
19002: EMPTY
19003: LIST
19004: LIST
19005: PPUSH
19006: CALL_OW 72
19010: IFFALSE 19036
// begin Say ( JMM , D3nW-JMM-1 ) ;
19012: LD_EXP 40
19016: PPUSH
19017: LD_STRING D3nW-JMM-1
19019: PPUSH
19020: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
19024: LD_EXP 40
19028: PPUSH
19029: LD_STRING D3nW-JMM-1a
19031: PPUSH
19032: CALL_OW 88
// end ; t := 0 0$00 ;
19036: LD_ADDR_VAR 0 3
19040: PUSH
19041: LD_INT 0
19043: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19044: LD_INT 35
19046: PPUSH
19047: CALL_OW 67
// t := t + 0 0$1 ;
19051: LD_ADDR_VAR 0 3
19055: PUSH
19056: LD_VAR 0 3
19060: PUSH
19061: LD_INT 35
19063: PLUS
19064: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
19065: LD_INT 59
19067: PPUSH
19068: LD_INT 112
19070: PPUSH
19071: CALL_OW 428
19075: PUSH
19076: LD_VAR 0 3
19080: PUSH
19081: LD_INT 2100
19083: GREATER
19084: OR
19085: IFFALSE 19044
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
19087: LD_ADDR_EXP 100
19091: PUSH
19092: LD_EXP 100
19096: PPUSH
19097: LD_INT 4
19099: PPUSH
19100: LD_INT 22
19102: PUSH
19103: LD_INT 4
19105: PUSH
19106: EMPTY
19107: LIST
19108: LIST
19109: PUSH
19110: LD_INT 23
19112: PUSH
19113: LD_INT 1
19115: PUSH
19116: EMPTY
19117: LIST
19118: LIST
19119: PUSH
19120: LD_INT 3
19122: PUSH
19123: LD_INT 21
19125: PUSH
19126: LD_INT 2
19128: PUSH
19129: EMPTY
19130: LIST
19131: LIST
19132: PUSH
19133: EMPTY
19134: LIST
19135: LIST
19136: PUSH
19137: EMPTY
19138: LIST
19139: LIST
19140: LIST
19141: PPUSH
19142: CALL_OW 69
19146: PUSH
19147: LD_EXP 60
19151: DIFF
19152: PPUSH
19153: CALL_OW 1
19157: ST_TO_ADDR
// activeAttacks := true ;
19158: LD_ADDR_EXP 16
19162: PUSH
19163: LD_INT 1
19165: ST_TO_ADDR
// end ;
19166: LD_VAR 0 1
19170: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
19171: LD_INT 0
19173: PPUSH
// case question of 1 :
19174: LD_VAR 0 1
19178: PUSH
19179: LD_INT 1
19181: DOUBLE
19182: EQUAL
19183: IFTRUE 19187
19185: GO 19238
19187: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
19188: LD_EXP 40
19192: PPUSH
19193: LD_STRING D2Mot-JMM-1
19195: PPUSH
19196: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
19200: LD_EXP 60
19204: PPUSH
19205: LD_STRING D2Mot-Pow-1
19207: PPUSH
19208: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
19212: LD_EXP 40
19216: PPUSH
19217: LD_STRING D2Mot-JMM-2
19219: PPUSH
19220: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
19224: LD_EXP 60
19228: PPUSH
19229: LD_STRING D2Mot-Pow-2
19231: PPUSH
19232: CALL_OW 88
// end ; 2 :
19236: GO 19589
19238: LD_INT 2
19240: DOUBLE
19241: EQUAL
19242: IFTRUE 19246
19244: GO 19322
19246: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
19247: LD_EXP 40
19251: PPUSH
19252: LD_STRING D2Rus-JMM-1
19254: PPUSH
19255: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
19259: LD_EXP 60
19263: PPUSH
19264: LD_STRING D2Rus-Pow-1
19266: PPUSH
19267: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
19271: LD_EXP 40
19275: PPUSH
19276: LD_STRING D2Rus-JMM-2
19278: PPUSH
19279: CALL_OW 88
// if not ( 3 in list_of_q ) then
19283: LD_INT 3
19285: PUSH
19286: LD_VAR 0 2
19290: IN
19291: NOT
19292: IFFALSE 19308
// Say ( Powell , D2Rus-Pow-2 ) else
19294: LD_EXP 60
19298: PPUSH
19299: LD_STRING D2Rus-Pow-2
19301: PPUSH
19302: CALL_OW 88
19306: GO 19320
// Say ( Powell , D2Rus-Pow-2a ) ;
19308: LD_EXP 60
19312: PPUSH
19313: LD_STRING D2Rus-Pow-2a
19315: PPUSH
19316: CALL_OW 88
// end ; 3 :
19320: GO 19589
19322: LD_INT 3
19324: DOUBLE
19325: EQUAL
19326: IFTRUE 19330
19328: GO 19415
19330: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
19331: LD_EXP 40
19335: PPUSH
19336: LD_STRING D2Leg-JMM-1
19338: PPUSH
19339: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
19343: LD_EXP 60
19347: PPUSH
19348: LD_STRING D2Leg-Pow-1
19350: PPUSH
19351: CALL_OW 88
// if 2 in list_of_q then
19355: LD_INT 2
19357: PUSH
19358: LD_VAR 0 2
19362: IN
19363: IFFALSE 19389
// begin Say ( JMM , D2Leg-JMM-2 ) ;
19365: LD_EXP 40
19369: PPUSH
19370: LD_STRING D2Leg-JMM-2
19372: PPUSH
19373: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
19377: LD_EXP 60
19381: PPUSH
19382: LD_STRING D2Leg-Pow-2
19384: PPUSH
19385: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
19389: LD_EXP 40
19393: PPUSH
19394: LD_STRING D2Leg-JMM-3
19396: PPUSH
19397: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
19401: LD_EXP 60
19405: PPUSH
19406: LD_STRING D2Leg-Pow-3
19408: PPUSH
19409: CALL_OW 88
// end ; 4 :
19413: GO 19589
19415: LD_INT 4
19417: DOUBLE
19418: EQUAL
19419: IFTRUE 19423
19421: GO 19498
19423: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
19424: LD_EXP 40
19428: PPUSH
19429: LD_STRING D2Ar-JMM-1
19431: PPUSH
19432: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
19436: LD_EXP 60
19440: PPUSH
19441: LD_STRING D2Ar-Pow-1
19443: PPUSH
19444: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
19448: LD_EXP 40
19452: PPUSH
19453: LD_STRING D2Ar-JMM-2
19455: PPUSH
19456: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
19460: LD_EXP 60
19464: PPUSH
19465: LD_STRING D2Ar-Pow-2
19467: PPUSH
19468: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
19472: LD_EXP 40
19476: PPUSH
19477: LD_STRING D2Ar-JMM-3
19479: PPUSH
19480: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
19484: LD_EXP 60
19488: PPUSH
19489: LD_STRING D2Ar-Pow-3
19491: PPUSH
19492: CALL_OW 88
// end ; 5 :
19496: GO 19589
19498: LD_INT 5
19500: DOUBLE
19501: EQUAL
19502: IFTRUE 19506
19504: GO 19521
19506: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
19507: LD_EXP 40
19511: PPUSH
19512: LD_STRING D2Conf-JMM-1
19514: PPUSH
19515: CALL_OW 88
19519: GO 19589
19521: LD_INT 6
19523: DOUBLE
19524: EQUAL
19525: IFTRUE 19529
19527: GO 19588
19529: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
19530: LD_EXP 40
19534: PPUSH
19535: LD_STRING D2Com-JMM-1
19537: PPUSH
19538: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
19542: LD_EXP 60
19546: PPUSH
19547: LD_STRING D2Com-Pow-1
19549: PPUSH
19550: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
19554: LD_EXP 40
19558: PPUSH
19559: LD_STRING D2Com-JMM-2
19561: PPUSH
19562: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
19566: LD_EXP 60
19570: PPUSH
19571: LD_STRING D2Com-Pow-2
19573: PPUSH
19574: CALL_OW 88
// powellAngerQuery := true ;
19578: LD_ADDR_EXP 36
19582: PUSH
19583: LD_INT 1
19585: ST_TO_ADDR
// end ; end ;
19586: GO 19589
19588: POP
// end ;
19589: LD_VAR 0 3
19593: RET
// every 0 0$5 trigger missionStart do var tmp ;
19594: LD_EXP 13
19598: IFFALSE 19881
19600: GO 19602
19602: DISABLE
19603: LD_INT 0
19605: PPUSH
// begin repeat wait ( 0 0$1 ) ;
19606: LD_INT 35
19608: PPUSH
19609: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
19613: LD_INT 14
19615: PPUSH
19616: LD_INT 22
19618: PUSH
19619: LD_INT 1
19621: PUSH
19622: EMPTY
19623: LIST
19624: LIST
19625: PPUSH
19626: CALL_OW 70
19630: PUSH
19631: LD_EXP 15
19635: PUSH
19636: LD_INT 2
19638: PUSH
19639: LD_INT 3
19641: PUSH
19642: LD_INT 4
19644: PUSH
19645: LD_INT 5
19647: PUSH
19648: EMPTY
19649: LIST
19650: LIST
19651: LIST
19652: LIST
19653: IN
19654: AND
19655: IFFALSE 19871
// begin powellAnger := powellAnger + 1 ;
19657: LD_ADDR_EXP 17
19661: PUSH
19662: LD_EXP 17
19666: PUSH
19667: LD_INT 1
19669: PLUS
19670: ST_TO_ADDR
// Video ( true ) ;
19671: LD_INT 1
19673: PPUSH
19674: CALL 105238 0 1
// CenterNowOnUnits ( tmp ) ;
19678: LD_VAR 0 1
19682: PPUSH
19683: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
19687: LD_INT 14
19689: PPUSH
19690: LD_INT 22
19692: PUSH
19693: LD_INT 1
19695: PUSH
19696: EMPTY
19697: LIST
19698: LIST
19699: PPUSH
19700: CALL_OW 70
19704: PPUSH
19705: LD_INT 86
19707: PPUSH
19708: LD_INT 133
19710: PPUSH
19711: CALL_OW 111
// async ;
19715: ASYNC
// case powellAnger of 1 :
19716: LD_EXP 17
19720: PUSH
19721: LD_INT 1
19723: DOUBLE
19724: EQUAL
19725: IFTRUE 19729
19727: GO 19744
19729: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
19730: LD_EXP 60
19734: PPUSH
19735: LD_STRING DBack1-Pow-1
19737: PPUSH
19738: CALL_OW 88
19742: GO 19791
19744: LD_INT 2
19746: DOUBLE
19747: EQUAL
19748: IFTRUE 19752
19750: GO 19767
19752: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
19753: LD_EXP 60
19757: PPUSH
19758: LD_STRING DBack2-Pow-1
19760: PPUSH
19761: CALL_OW 88
19765: GO 19791
19767: LD_INT 3
19769: DOUBLE
19770: EQUAL
19771: IFTRUE 19775
19773: GO 19790
19775: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
19776: LD_EXP 60
19780: PPUSH
19781: LD_STRING DBack3-Pow-1
19783: PPUSH
19784: CALL_OW 88
19788: GO 19791
19790: POP
// sync ;
19791: SYNC
// repeat wait ( 0 0$1 ) ;
19792: LD_INT 35
19794: PPUSH
19795: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
19799: LD_INT 14
19801: PPUSH
19802: LD_INT 22
19804: PUSH
19805: LD_INT 1
19807: PUSH
19808: EMPTY
19809: LIST
19810: LIST
19811: PPUSH
19812: CALL_OW 70
19816: PPUSH
19817: LD_INT 86
19819: PPUSH
19820: LD_INT 133
19822: PPUSH
19823: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
19827: LD_INT 14
19829: PPUSH
19830: LD_INT 22
19832: PUSH
19833: LD_INT 1
19835: PUSH
19836: EMPTY
19837: LIST
19838: LIST
19839: PPUSH
19840: CALL_OW 70
19844: NOT
19845: IFFALSE 19792
// if powellAnger >= 3 then
19847: LD_EXP 17
19851: PUSH
19852: LD_INT 3
19854: GREATEREQUAL
19855: IFFALSE 19864
// YouLost ( Dismissed ) ;
19857: LD_STRING Dismissed
19859: PPUSH
19860: CALL_OW 104
// Video ( false ) ;
19864: LD_INT 0
19866: PPUSH
19867: CALL 105238 0 1
// end ; until missionStage > 5 ;
19871: LD_EXP 15
19875: PUSH
19876: LD_INT 5
19878: GREATER
19879: IFFALSE 19606
// end ;
19881: PPOPN 1
19883: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t ;
19884: LD_EXP 13
19888: PUSH
19889: LD_INT 22
19891: PUSH
19892: LD_INT 4
19894: PUSH
19895: EMPTY
19896: LIST
19897: LIST
19898: PUSH
19899: LD_INT 21
19901: PUSH
19902: LD_INT 2
19904: PUSH
19905: EMPTY
19906: LIST
19907: LIST
19908: PUSH
19909: EMPTY
19910: LIST
19911: LIST
19912: PPUSH
19913: CALL_OW 69
19917: PUSH
19918: LD_INT 4
19920: GREATEREQUAL
19921: AND
19922: PUSH
19923: LD_EXP 15
19927: PUSH
19928: LD_INT 2
19930: EQUAL
19931: AND
19932: IFFALSE 22122
19934: GO 19936
19936: DISABLE
19937: LD_INT 0
19939: PPUSH
19940: PPUSH
19941: PPUSH
19942: PPUSH
19943: PPUSH
19944: PPUSH
19945: PPUSH
19946: PPUSH
19947: PPUSH
19948: PPUSH
// begin missionStage := 3 ;
19949: LD_ADDR_EXP 15
19953: PUSH
19954: LD_INT 3
19956: ST_TO_ADDR
// retreat := false ;
19957: LD_ADDR_VAR 0 4
19961: PUSH
19962: LD_INT 0
19964: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
19965: LD_ADDR_VAR 0 5
19969: PUSH
19970: LD_INT 22
19972: PUSH
19973: LD_INT 4
19975: PUSH
19976: EMPTY
19977: LIST
19978: LIST
19979: PUSH
19980: LD_INT 30
19982: PUSH
19983: LD_INT 4
19985: PUSH
19986: EMPTY
19987: LIST
19988: LIST
19989: PUSH
19990: EMPTY
19991: LIST
19992: LIST
19993: PPUSH
19994: CALL_OW 69
19998: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
19999: LD_ADDR_VAR 0 6
20003: PUSH
20004: LD_INT 22
20006: PUSH
20007: LD_INT 4
20009: PUSH
20010: EMPTY
20011: LIST
20012: LIST
20013: PUSH
20014: LD_INT 30
20016: PUSH
20017: LD_INT 5
20019: PUSH
20020: EMPTY
20021: LIST
20022: LIST
20023: PUSH
20024: EMPTY
20025: LIST
20026: LIST
20027: PPUSH
20028: CALL_OW 69
20032: ST_TO_ADDR
// if not bar then
20033: LD_VAR 0 6
20037: NOT
20038: IFFALSE 20091
// begin repeat wait ( 0 0$1 ) ;
20040: LD_INT 35
20042: PPUSH
20043: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
20047: LD_INT 22
20049: PUSH
20050: LD_INT 4
20052: PUSH
20053: EMPTY
20054: LIST
20055: LIST
20056: PUSH
20057: LD_INT 3
20059: PUSH
20060: LD_INT 57
20062: PUSH
20063: EMPTY
20064: LIST
20065: PUSH
20066: EMPTY
20067: LIST
20068: LIST
20069: PUSH
20070: LD_INT 30
20072: PUSH
20073: LD_INT 5
20075: PUSH
20076: EMPTY
20077: LIST
20078: LIST
20079: PUSH
20080: EMPTY
20081: LIST
20082: LIST
20083: LIST
20084: PPUSH
20085: CALL_OW 69
20089: IFFALSE 20040
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
20091: LD_ADDR_VAR 0 6
20095: PUSH
20096: LD_INT 22
20098: PUSH
20099: LD_INT 4
20101: PUSH
20102: EMPTY
20103: LIST
20104: LIST
20105: PUSH
20106: LD_INT 30
20108: PUSH
20109: LD_INT 5
20111: PUSH
20112: EMPTY
20113: LIST
20114: LIST
20115: PUSH
20116: EMPTY
20117: LIST
20118: LIST
20119: PPUSH
20120: CALL_OW 69
20124: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20125: LD_INT 35
20127: PPUSH
20128: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
20132: LD_EXP 119
20136: PUSH
20137: LD_INT 4
20139: ARRAY
20140: PUSH
20141: LD_INT 4
20143: GREATEREQUAL
20144: IFFALSE 20125
// tmp := [ ] ;
20146: LD_ADDR_VAR 0 2
20150: PUSH
20151: EMPTY
20152: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) do
20153: LD_ADDR_VAR 0 1
20157: PUSH
20158: LD_INT 22
20160: PUSH
20161: LD_INT 4
20163: PUSH
20164: EMPTY
20165: LIST
20166: LIST
20167: PUSH
20168: LD_INT 2
20170: PUSH
20171: LD_INT 25
20173: PUSH
20174: LD_INT 1
20176: PUSH
20177: EMPTY
20178: LIST
20179: LIST
20180: PUSH
20181: LD_INT 25
20183: PUSH
20184: LD_INT 2
20186: PUSH
20187: EMPTY
20188: LIST
20189: LIST
20190: PUSH
20191: LD_INT 25
20193: PUSH
20194: LD_INT 3
20196: PUSH
20197: EMPTY
20198: LIST
20199: LIST
20200: PUSH
20201: LD_INT 25
20203: PUSH
20204: LD_INT 4
20206: PUSH
20207: EMPTY
20208: LIST
20209: LIST
20210: PUSH
20211: LD_INT 25
20213: PUSH
20214: LD_INT 5
20216: PUSH
20217: EMPTY
20218: LIST
20219: LIST
20220: PUSH
20221: EMPTY
20222: LIST
20223: LIST
20224: LIST
20225: LIST
20226: LIST
20227: LIST
20228: PUSH
20229: EMPTY
20230: LIST
20231: LIST
20232: PPUSH
20233: CALL_OW 69
20237: PUSH
20238: LD_EXP 60
20242: PUSH
20243: LD_EXP 61
20247: ADD
20248: DIFF
20249: PUSH
20250: FOR_IN
20251: IFFALSE 20315
// if GetTag ( i ) = 1 then
20253: LD_VAR 0 1
20257: PPUSH
20258: CALL_OW 110
20262: PUSH
20263: LD_INT 1
20265: EQUAL
20266: IFFALSE 20290
// tmp := Join ( tmp , i ) else
20268: LD_ADDR_VAR 0 2
20272: PUSH
20273: LD_VAR 0 2
20277: PPUSH
20278: LD_VAR 0 1
20282: PPUSH
20283: CALL 105266 0 2
20287: ST_TO_ADDR
20288: GO 20313
// tmp := Insert ( tmp , 1 , i ) ;
20290: LD_ADDR_VAR 0 2
20294: PUSH
20295: LD_VAR 0 2
20299: PPUSH
20300: LD_INT 1
20302: PPUSH
20303: LD_VAR 0 1
20307: PPUSH
20308: CALL_OW 2
20312: ST_TO_ADDR
20313: GO 20250
20315: POP
20316: POP
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
20317: LD_ADDR_VAR 0 3
20321: PUSH
20322: LD_VAR 0 2
20326: PPUSH
20327: LD_INT 26
20329: PUSH
20330: LD_INT 1
20332: PUSH
20333: EMPTY
20334: LIST
20335: LIST
20336: PPUSH
20337: CALL_OW 72
20341: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
20342: LD_ADDR_VAR 0 2
20346: PUSH
20347: LD_VAR 0 2
20351: PUSH
20352: LD_VAR 0 3
20356: DIFF
20357: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
20358: LD_ADDR_VAR 0 2
20362: PUSH
20363: LD_VAR 0 2
20367: PPUSH
20368: LD_INT 3
20370: PPUSH
20371: CALL 103783 0 2
20375: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
20376: LD_ADDR_VAR 0 3
20380: PUSH
20381: LD_VAR 0 3
20385: PPUSH
20386: LD_INT 3
20388: PPUSH
20389: CALL 103783 0 2
20393: ST_TO_ADDR
// for i := 1 to 4 do
20394: LD_ADDR_VAR 0 1
20398: PUSH
20399: DOUBLE
20400: LD_INT 1
20402: DEC
20403: ST_TO_ADDR
20404: LD_INT 4
20406: PUSH
20407: FOR_TO
20408: IFFALSE 20561
// begin if tmp2 then
20410: LD_VAR 0 3
20414: IFFALSE 20482
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
20416: LD_ADDR_EXP 18
20420: PUSH
20421: LD_EXP 18
20425: PPUSH
20426: LD_INT 1
20428: PPUSH
20429: LD_EXP 18
20433: PUSH
20434: LD_INT 1
20436: ARRAY
20437: PUSH
20438: LD_VAR 0 3
20442: PUSH
20443: LD_VAR 0 3
20447: ARRAY
20448: ADD
20449: PPUSH
20450: CALL_OW 1
20454: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
20455: LD_VAR 0 3
20459: PUSH
20460: LD_VAR 0 3
20464: ARRAY
20465: PPUSH
20466: LD_INT 1
20468: PPUSH
20469: CALL_OW 109
// tmp2 := [ ] ;
20473: LD_ADDR_VAR 0 3
20477: PUSH
20478: EMPTY
20479: ST_TO_ADDR
// end else
20480: GO 20559
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
20482: LD_ADDR_EXP 18
20486: PUSH
20487: LD_EXP 18
20491: PPUSH
20492: LD_INT 1
20494: PPUSH
20495: LD_EXP 18
20499: PUSH
20500: LD_INT 1
20502: ARRAY
20503: PUSH
20504: LD_VAR 0 2
20508: PUSH
20509: LD_VAR 0 2
20513: ARRAY
20514: ADD
20515: PPUSH
20516: CALL_OW 1
20520: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
20521: LD_VAR 0 2
20525: PUSH
20526: LD_VAR 0 2
20530: ARRAY
20531: PPUSH
20532: LD_INT 1
20534: PPUSH
20535: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
20539: LD_ADDR_VAR 0 2
20543: PUSH
20544: LD_VAR 0 2
20548: PPUSH
20549: LD_VAR 0 2
20553: PPUSH
20554: CALL_OW 3
20558: ST_TO_ADDR
// end ; end ;
20559: GO 20407
20561: POP
20562: POP
// if tmp2 then
20563: LD_VAR 0 3
20567: IFFALSE 20585
// tmp := tmp union tmp2 ;
20569: LD_ADDR_VAR 0 2
20573: PUSH
20574: LD_VAR 0 2
20578: PUSH
20579: LD_VAR 0 3
20583: UNION
20584: ST_TO_ADDR
// for i := 1 to 4 do
20585: LD_ADDR_VAR 0 1
20589: PUSH
20590: DOUBLE
20591: LD_INT 1
20593: DEC
20594: ST_TO_ADDR
20595: LD_INT 4
20597: PUSH
20598: FOR_TO
20599: IFFALSE 20648
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
20601: LD_ADDR_EXP 18
20605: PUSH
20606: LD_EXP 18
20610: PPUSH
20611: LD_INT 2
20613: PPUSH
20614: LD_EXP 18
20618: PUSH
20619: LD_INT 2
20621: ARRAY
20622: PUSH
20623: LD_VAR 0 2
20627: PUSH
20628: LD_VAR 0 2
20632: PUSH
20633: LD_VAR 0 1
20637: MINUS
20638: ARRAY
20639: ADD
20640: PPUSH
20641: CALL_OW 1
20645: ST_TO_ADDR
20646: GO 20598
20648: POP
20649: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
20650: LD_ADDR_EXP 100
20654: PUSH
20655: LD_EXP 100
20659: PPUSH
20660: LD_INT 4
20662: PPUSH
20663: LD_EXP 100
20667: PUSH
20668: LD_INT 4
20670: ARRAY
20671: PUSH
20672: LD_EXP 18
20676: PUSH
20677: LD_INT 1
20679: ARRAY
20680: DIFF
20681: PPUSH
20682: CALL_OW 1
20686: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
20687: LD_VAR 0 5
20691: PUSH
20692: LD_INT 1
20694: ARRAY
20695: PPUSH
20696: CALL_OW 313
20700: IFFALSE 20755
// begin for i in UnitsInside ( arm [ 1 ] ) do
20702: LD_ADDR_VAR 0 1
20706: PUSH
20707: LD_VAR 0 5
20711: PUSH
20712: LD_INT 1
20714: ARRAY
20715: PPUSH
20716: CALL_OW 313
20720: PUSH
20721: FOR_IN
20722: IFFALSE 20753
// begin ComExitBuilding ( i ) ;
20724: LD_VAR 0 1
20728: PPUSH
20729: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
20733: LD_VAR 0 1
20737: PPUSH
20738: LD_VAR 0 6
20742: PUSH
20743: LD_INT 1
20745: ARRAY
20746: PPUSH
20747: CALL_OW 180
// end ;
20751: GO 20721
20753: POP
20754: POP
// end ; wait ( 0 0$3 ) ;
20755: LD_INT 105
20757: PPUSH
20758: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
20762: LD_ADDR_VAR 0 1
20766: PUSH
20767: LD_EXP 18
20771: PUSH
20772: LD_INT 1
20774: ARRAY
20775: PUSH
20776: FOR_IN
20777: IFFALSE 20884
// begin if IsInUnit ( i ) then
20779: LD_VAR 0 1
20783: PPUSH
20784: CALL_OW 310
20788: IFFALSE 20799
// ComExitBuilding ( i ) ;
20790: LD_VAR 0 1
20794: PPUSH
20795: CALL_OW 122
// if GetClass ( i ) <> 1 then
20799: LD_VAR 0 1
20803: PPUSH
20804: CALL_OW 257
20808: PUSH
20809: LD_INT 1
20811: NONEQUAL
20812: IFFALSE 20853
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
20814: LD_VAR 0 1
20818: PPUSH
20819: LD_VAR 0 5
20823: PUSH
20824: LD_INT 1
20826: ARRAY
20827: PPUSH
20828: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
20832: LD_VAR 0 1
20836: PPUSH
20837: LD_INT 1
20839: PPUSH
20840: CALL_OW 183
// AddComExitBuilding ( i ) ;
20844: LD_VAR 0 1
20848: PPUSH
20849: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
20853: LD_VAR 0 1
20857: PPUSH
20858: LD_INT 60
20860: PPUSH
20861: LD_INT 94
20863: PPUSH
20864: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
20868: LD_VAR 0 1
20872: PPUSH
20873: LD_EXP 60
20877: PPUSH
20878: CALL_OW 179
// end ;
20882: GO 20776
20884: POP
20885: POP
// wait ( 0 0$10 ) ;
20886: LD_INT 350
20888: PPUSH
20889: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
20893: LD_EXP 60
20897: PPUSH
20898: LD_STRING D4-Pow-1
20900: PPUSH
20901: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
20905: LD_ADDR_VAR 0 2
20909: PUSH
20910: LD_EXP 18
20914: PUSH
20915: LD_INT 1
20917: ARRAY
20918: PPUSH
20919: LD_INT 26
20921: PUSH
20922: LD_INT 1
20924: PUSH
20925: EMPTY
20926: LIST
20927: LIST
20928: PPUSH
20929: CALL_OW 72
20933: ST_TO_ADDR
// if tmp then
20934: LD_VAR 0 2
20938: IFFALSE 20956
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
20940: LD_VAR 0 2
20944: PUSH
20945: LD_INT 1
20947: ARRAY
20948: PPUSH
20949: LD_STRING D4-Sol1-1
20951: PPUSH
20952: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
20956: LD_EXP 60
20960: PPUSH
20961: LD_STRING D4-Pow-2
20963: PPUSH
20964: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
20968: LD_ADDR_VAR 0 1
20972: PUSH
20973: DOUBLE
20974: LD_INT 1
20976: DEC
20977: ST_TO_ADDR
20978: LD_EXP 18
20982: PUSH
20983: LD_INT 1
20985: ARRAY
20986: PUSH
20987: FOR_TO
20988: IFFALSE 21081
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
20990: LD_EXP 18
20994: PUSH
20995: LD_INT 1
20997: ARRAY
20998: PUSH
20999: LD_VAR 0 1
21003: ARRAY
21004: PPUSH
21005: LD_EXP 119
21009: PUSH
21010: LD_INT 4
21012: ARRAY
21013: PUSH
21014: LD_INT 1
21016: ARRAY
21017: PPUSH
21018: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
21022: LD_ADDR_EXP 119
21026: PUSH
21027: LD_EXP 119
21031: PPUSH
21032: LD_INT 4
21034: PPUSH
21035: LD_EXP 119
21039: PUSH
21040: LD_INT 4
21042: ARRAY
21043: PPUSH
21044: LD_INT 1
21046: PPUSH
21047: CALL_OW 3
21051: PPUSH
21052: CALL_OW 1
21056: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
21057: LD_INT 8
21059: PPUSH
21060: LD_EXP 18
21064: PUSH
21065: LD_INT 1
21067: ARRAY
21068: PUSH
21069: LD_VAR 0 1
21073: ARRAY
21074: PPUSH
21075: CALL_OW 471
// end ;
21079: GO 20987
21081: POP
21082: POP
// repeat wait ( 0 0$1 ) ;
21083: LD_INT 35
21085: PPUSH
21086: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
21090: LD_EXP 18
21094: PUSH
21095: LD_INT 1
21097: ARRAY
21098: PPUSH
21099: LD_INT 55
21101: PUSH
21102: EMPTY
21103: LIST
21104: PPUSH
21105: CALL_OW 72
21109: PUSH
21110: LD_INT 4
21112: GREATEREQUAL
21113: IFFALSE 21083
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
21115: LD_EXP 18
21119: PUSH
21120: LD_INT 1
21122: ARRAY
21123: PPUSH
21124: LD_INT 69
21126: PPUSH
21127: LD_INT 94
21129: PPUSH
21130: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
21134: LD_EXP 18
21138: PUSH
21139: LD_INT 1
21141: ARRAY
21142: PPUSH
21143: LD_INT 82
21145: PPUSH
21146: LD_INT 83
21148: PPUSH
21149: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
21153: LD_EXP 18
21157: PUSH
21158: LD_INT 1
21160: ARRAY
21161: PPUSH
21162: LD_INT 77
21164: PPUSH
21165: LD_INT 69
21167: PPUSH
21168: CALL_OW 174
// repeat wait ( 3 ) ;
21172: LD_INT 3
21174: PPUSH
21175: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
21179: LD_ADDR_VAR 0 1
21183: PUSH
21184: LD_EXP 18
21188: PUSH
21189: LD_INT 1
21191: ARRAY
21192: PUSH
21193: FOR_IN
21194: IFFALSE 21330
// begin if GetLives ( i ) < 990 then
21196: LD_VAR 0 1
21200: PPUSH
21201: CALL_OW 256
21205: PUSH
21206: LD_INT 990
21208: LESS
21209: IFFALSE 21223
// SetLives ( i , 1000 ) ;
21211: LD_VAR 0 1
21215: PPUSH
21216: LD_INT 1000
21218: PPUSH
21219: CALL_OW 234
// if not IsInUnit ( i ) then
21223: LD_VAR 0 1
21227: PPUSH
21228: CALL_OW 310
21232: NOT
21233: IFFALSE 21328
// begin if not HasTask ( i ) then
21235: LD_VAR 0 1
21239: PPUSH
21240: CALL_OW 314
21244: NOT
21245: IFFALSE 21262
// ComMoveXY ( i , 64 , 93 ) ;
21247: LD_VAR 0 1
21251: PPUSH
21252: LD_INT 64
21254: PPUSH
21255: LD_INT 93
21257: PPUSH
21258: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
21262: LD_VAR 0 4
21266: NOT
21267: PUSH
21268: LD_VAR 0 1
21272: PPUSH
21273: CALL_OW 258
21277: PUSH
21278: LD_INT 1
21280: EQUAL
21281: AND
21282: IFFALSE 21328
// begin retreat := true ;
21284: LD_ADDR_VAR 0 4
21288: PUSH
21289: LD_INT 1
21291: ST_TO_ADDR
// SetTag ( i , 2 ) ;
21292: LD_VAR 0 1
21296: PPUSH
21297: LD_INT 2
21299: PPUSH
21300: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
21304: LD_VAR 0 1
21308: PPUSH
21309: LD_STRING D4a-Sol1-1
21311: PPUSH
21312: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
21316: LD_EXP 60
21320: PPUSH
21321: LD_STRING D4a-Pow-1
21323: PPUSH
21324: CALL_OW 88
// end ; end ; end ;
21328: GO 21193
21330: POP
21331: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
21332: LD_EXP 18
21336: PUSH
21337: LD_INT 1
21339: ARRAY
21340: PPUSH
21341: LD_INT 95
21343: PUSH
21344: LD_INT 9
21346: PUSH
21347: EMPTY
21348: LIST
21349: LIST
21350: PUSH
21351: LD_INT 3
21353: PUSH
21354: LD_INT 55
21356: PUSH
21357: EMPTY
21358: LIST
21359: PUSH
21360: EMPTY
21361: LIST
21362: LIST
21363: PUSH
21364: EMPTY
21365: LIST
21366: LIST
21367: PPUSH
21368: CALL_OW 72
21372: PUSH
21373: LD_INT 4
21375: GREATEREQUAL
21376: IFFALSE 21172
// for i in powellSquadAttack [ 1 ] do
21378: LD_ADDR_VAR 0 1
21382: PUSH
21383: LD_EXP 18
21387: PUSH
21388: LD_INT 1
21390: ARRAY
21391: PUSH
21392: FOR_IN
21393: IFFALSE 21529
// begin if GetTag ( i ) = 2 then
21395: LD_VAR 0 1
21399: PPUSH
21400: CALL_OW 110
21404: PUSH
21405: LD_INT 2
21407: EQUAL
21408: IFFALSE 21470
// begin ComMoveXY ( i , 60 , 94 ) ;
21410: LD_VAR 0 1
21414: PPUSH
21415: LD_INT 60
21417: PPUSH
21418: LD_INT 94
21420: PPUSH
21421: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
21425: LD_VAR 0 1
21429: PPUSH
21430: LD_EXP 60
21434: PPUSH
21435: CALL_OW 179
// wait ( 0 0$3 ) ;
21439: LD_INT 105
21441: PPUSH
21442: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
21446: LD_VAR 0 1
21450: PPUSH
21451: LD_STRING D4a-Sol1-2
21453: PPUSH
21454: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
21458: LD_EXP 60
21462: PPUSH
21463: LD_STRING D4a-Pow-2
21465: PPUSH
21466: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
21470: LD_VAR 0 1
21474: PPUSH
21475: LD_INT 0
21477: PPUSH
21478: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
21482: LD_ADDR_EXP 100
21486: PUSH
21487: LD_EXP 100
21491: PPUSH
21492: LD_INT 4
21494: PPUSH
21495: LD_EXP 100
21499: PUSH
21500: LD_INT 4
21502: ARRAY
21503: PUSH
21504: LD_VAR 0 1
21508: UNION
21509: PPUSH
21510: CALL_OW 1
21514: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
21515: LD_INT 8
21517: PPUSH
21518: LD_VAR 0 1
21522: PPUSH
21523: CALL_OW 472
// end ;
21527: GO 21392
21529: POP
21530: POP
// wait ( 2 2$00 ) ;
21531: LD_INT 4200
21533: PPUSH
21534: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21538: LD_ADDR_VAR 0 9
21542: PUSH
21543: LD_INT 22
21545: PUSH
21546: LD_INT 4
21548: PUSH
21549: EMPTY
21550: LIST
21551: LIST
21552: PUSH
21553: LD_INT 30
21555: PUSH
21556: LD_INT 32
21558: PUSH
21559: EMPTY
21560: LIST
21561: LIST
21562: PUSH
21563: LD_INT 58
21565: PUSH
21566: EMPTY
21567: LIST
21568: PUSH
21569: EMPTY
21570: LIST
21571: LIST
21572: LIST
21573: PPUSH
21574: CALL_OW 69
21578: ST_TO_ADDR
// if tmp then
21579: LD_VAR 0 2
21583: IFFALSE 21823
// begin for i := 1 to tmp do
21585: LD_ADDR_VAR 0 1
21589: PUSH
21590: DOUBLE
21591: LD_INT 1
21593: DEC
21594: ST_TO_ADDR
21595: LD_VAR 0 2
21599: PUSH
21600: FOR_TO
21601: IFFALSE 21814
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
21603: LD_ADDR_EXP 100
21607: PUSH
21608: LD_EXP 100
21612: PPUSH
21613: LD_INT 4
21615: PPUSH
21616: LD_EXP 100
21620: PUSH
21621: LD_INT 4
21623: ARRAY
21624: PUSH
21625: LD_VAR 0 2
21629: PUSH
21630: LD_VAR 0 1
21634: ARRAY
21635: DIFF
21636: PPUSH
21637: CALL_OW 1
21641: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
21642: LD_ADDR_VAR 0 10
21646: PUSH
21647: LD_VAR 0 2
21651: PUSH
21652: LD_VAR 0 1
21656: ARRAY
21657: PPUSH
21658: CALL_OW 310
21662: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
21663: LD_VAR 0 10
21667: PUSH
21668: LD_VAR 0 10
21672: PPUSH
21673: CALL_OW 266
21677: PUSH
21678: LD_INT 32
21680: EQUAL
21681: AND
21682: IFFALSE 21686
// continue ;
21684: GO 21600
// if t then
21686: LD_VAR 0 10
21690: IFFALSE 21707
// ComExitBuilding ( tmp [ i ] ) ;
21692: LD_VAR 0 2
21696: PUSH
21697: LD_VAR 0 1
21701: ARRAY
21702: PPUSH
21703: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21707: LD_VAR 0 2
21711: PUSH
21712: LD_VAR 0 1
21716: ARRAY
21717: PPUSH
21718: LD_VAR 0 5
21722: PUSH
21723: LD_INT 1
21725: ARRAY
21726: PPUSH
21727: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21731: LD_VAR 0 2
21735: PUSH
21736: LD_VAR 0 1
21740: ARRAY
21741: PPUSH
21742: LD_INT 1
21744: PPUSH
21745: CALL_OW 183
// if emptyTowers then
21749: LD_VAR 0 9
21753: IFFALSE 21812
// begin AddComExitBuilding ( tmp [ i ] ) ;
21755: LD_VAR 0 2
21759: PUSH
21760: LD_VAR 0 1
21764: ARRAY
21765: PPUSH
21766: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
21770: LD_VAR 0 2
21774: PUSH
21775: LD_VAR 0 1
21779: ARRAY
21780: PPUSH
21781: LD_VAR 0 9
21785: PUSH
21786: LD_INT 1
21788: ARRAY
21789: PPUSH
21790: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
21794: LD_ADDR_VAR 0 9
21798: PUSH
21799: LD_VAR 0 9
21803: PPUSH
21804: LD_INT 1
21806: PPUSH
21807: CALL_OW 3
21811: ST_TO_ADDR
// end ; end ;
21812: GO 21600
21814: POP
21815: POP
// wait ( 0 0$30 ) ;
21816: LD_INT 1050
21818: PPUSH
21819: CALL_OW 67
// end ; uc_side := 6 ;
21823: LD_ADDR_OWVAR 20
21827: PUSH
21828: LD_INT 6
21830: ST_TO_ADDR
// uc_nation := 3 ;
21831: LD_ADDR_OWVAR 21
21835: PUSH
21836: LD_INT 3
21838: ST_TO_ADDR
// ru := [ ] ;
21839: LD_ADDR_VAR 0 7
21843: PUSH
21844: EMPTY
21845: ST_TO_ADDR
// for i = 1 to 5 do
21846: LD_ADDR_VAR 0 1
21850: PUSH
21851: DOUBLE
21852: LD_INT 1
21854: DEC
21855: ST_TO_ADDR
21856: LD_INT 5
21858: PUSH
21859: FOR_TO
21860: IFFALSE 21980
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
21862: LD_INT 22
21864: PUSH
21865: LD_INT 23
21867: PUSH
21868: EMPTY
21869: LIST
21870: LIST
21871: PUSH
21872: LD_INT 1
21874: PPUSH
21875: LD_INT 2
21877: PPUSH
21878: CALL_OW 12
21882: ARRAY
21883: PPUSH
21884: LD_INT 1
21886: PPUSH
21887: LD_INT 3
21889: PPUSH
21890: LD_INT 43
21892: PUSH
21893: LD_INT 44
21895: PUSH
21896: EMPTY
21897: LIST
21898: LIST
21899: PUSH
21900: LD_INT 1
21902: PPUSH
21903: LD_INT 2
21905: PPUSH
21906: CALL_OW 12
21910: ARRAY
21911: PPUSH
21912: LD_INT 89
21914: PPUSH
21915: CALL 72814 0 5
// un := CreateVehicle ;
21919: LD_ADDR_VAR 0 8
21923: PUSH
21924: CALL_OW 45
21928: ST_TO_ADDR
// SetDir ( un , 4 ) ;
21929: LD_VAR 0 8
21933: PPUSH
21934: LD_INT 4
21936: PPUSH
21937: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
21941: LD_VAR 0 8
21945: PPUSH
21946: LD_INT 136
21948: PPUSH
21949: LD_INT 90
21951: PPUSH
21952: LD_INT 8
21954: PPUSH
21955: LD_INT 0
21957: PPUSH
21958: CALL_OW 50
// ru := ru ^ un ;
21962: LD_ADDR_VAR 0 7
21966: PUSH
21967: LD_VAR 0 7
21971: PUSH
21972: LD_VAR 0 8
21976: ADD
21977: ST_TO_ADDR
// end ;
21978: GO 21859
21980: POP
21981: POP
// if ru then
21982: LD_VAR 0 7
21986: IFFALSE 22003
// ComAgressiveMove ( ru , 57 , 94 ) ;
21988: LD_VAR 0 7
21992: PPUSH
21993: LD_INT 57
21995: PPUSH
21996: LD_INT 94
21998: PPUSH
21999: CALL_OW 114
// wait ( 3 3$00 ) ;
22003: LD_INT 6300
22005: PPUSH
22006: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
22010: LD_INT 4
22012: PPUSH
22013: LD_INT 3
22015: PUSH
22016: LD_INT 1
22018: PUSH
22019: LD_INT 1
22021: PUSH
22022: LD_INT 5
22024: PUSH
22025: EMPTY
22026: LIST
22027: LIST
22028: LIST
22029: LIST
22030: PUSH
22031: LD_INT 4
22033: PUSH
22034: LD_INT 1
22036: PUSH
22037: LD_INT 1
22039: PUSH
22040: LD_INT 6
22042: PUSH
22043: EMPTY
22044: LIST
22045: LIST
22046: LIST
22047: LIST
22048: PUSH
22049: LD_INT 4
22051: PUSH
22052: LD_INT 1
22054: PUSH
22055: LD_INT 1
22057: PUSH
22058: LD_INT 7
22060: PUSH
22061: EMPTY
22062: LIST
22063: LIST
22064: LIST
22065: LIST
22066: PUSH
22067: LD_INT 3
22069: PUSH
22070: LD_INT 1
22072: PUSH
22073: LD_INT 1
22075: PUSH
22076: LD_INT 7
22078: PUSH
22079: EMPTY
22080: LIST
22081: LIST
22082: LIST
22083: LIST
22084: PUSH
22085: LD_INT 3
22087: PUSH
22088: LD_INT 1
22090: PUSH
22091: LD_INT 1
22093: PUSH
22094: LD_INT 5
22096: PUSH
22097: EMPTY
22098: LIST
22099: LIST
22100: LIST
22101: LIST
22102: PUSH
22103: EMPTY
22104: LIST
22105: LIST
22106: LIST
22107: LIST
22108: LIST
22109: PPUSH
22110: CALL 61500 0 2
// missionStage := 4 ;
22114: LD_ADDR_EXP 15
22118: PUSH
22119: LD_INT 4
22121: ST_TO_ADDR
// end ;
22122: PPOPN 10
22124: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
22125: LD_EXP 15
22129: PUSH
22130: LD_INT 4
22132: EQUAL
22133: PUSH
22134: LD_INT 22
22136: PUSH
22137: LD_INT 4
22139: PUSH
22140: EMPTY
22141: LIST
22142: LIST
22143: PUSH
22144: LD_INT 21
22146: PUSH
22147: LD_INT 2
22149: PUSH
22150: EMPTY
22151: LIST
22152: LIST
22153: PUSH
22154: EMPTY
22155: LIST
22156: LIST
22157: PPUSH
22158: CALL_OW 69
22162: PUSH
22163: LD_INT 5
22165: GREATEREQUAL
22166: AND
22167: IFFALSE 26434
22169: GO 22171
22171: DISABLE
22172: LD_INT 0
22174: PPUSH
22175: PPUSH
22176: PPUSH
22177: PPUSH
22178: PPUSH
22179: PPUSH
22180: PPUSH
22181: PPUSH
22182: PPUSH
22183: PPUSH
22184: PPUSH
22185: PPUSH
22186: PPUSH
// begin wait ( 0 0$10 ) ;
22187: LD_INT 350
22189: PPUSH
22190: CALL_OW 67
// missionStage := 5 ;
22194: LD_ADDR_EXP 15
22198: PUSH
22199: LD_INT 5
22201: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
22202: LD_ADDR_VAR 0 10
22206: PUSH
22207: LD_INT 22
22209: PUSH
22210: LD_INT 4
22212: PUSH
22213: EMPTY
22214: LIST
22215: LIST
22216: PUSH
22217: LD_INT 2
22219: PUSH
22220: LD_INT 30
22222: PUSH
22223: LD_INT 4
22225: PUSH
22226: EMPTY
22227: LIST
22228: LIST
22229: PUSH
22230: LD_INT 30
22232: PUSH
22233: LD_INT 5
22235: PUSH
22236: EMPTY
22237: LIST
22238: LIST
22239: PUSH
22240: EMPTY
22241: LIST
22242: LIST
22243: LIST
22244: PUSH
22245: EMPTY
22246: LIST
22247: LIST
22248: PPUSH
22249: CALL_OW 69
22253: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
22254: LD_ADDR_VAR 0 6
22258: PUSH
22259: LD_INT 22
22261: PUSH
22262: LD_INT 4
22264: PUSH
22265: EMPTY
22266: LIST
22267: LIST
22268: PUSH
22269: LD_INT 21
22271: PUSH
22272: LD_INT 1
22274: PUSH
22275: EMPTY
22276: LIST
22277: LIST
22278: PUSH
22279: LD_INT 3
22281: PUSH
22282: LD_INT 25
22284: PUSH
22285: LD_INT 16
22287: PUSH
22288: EMPTY
22289: LIST
22290: LIST
22291: PUSH
22292: EMPTY
22293: LIST
22294: LIST
22295: PUSH
22296: LD_INT 3
22298: PUSH
22299: LD_INT 25
22301: PUSH
22302: LD_INT 12
22304: PUSH
22305: EMPTY
22306: LIST
22307: LIST
22308: PUSH
22309: EMPTY
22310: LIST
22311: LIST
22312: PUSH
22313: EMPTY
22314: LIST
22315: LIST
22316: LIST
22317: LIST
22318: PPUSH
22319: CALL_OW 69
22323: PUSH
22324: LD_EXP 60
22328: DIFF
22329: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
22330: LD_ADDR_VAR 0 9
22334: PUSH
22335: LD_INT 22
22337: PUSH
22338: LD_INT 4
22340: PUSH
22341: EMPTY
22342: LIST
22343: LIST
22344: PUSH
22345: LD_INT 30
22347: PUSH
22348: LD_INT 3
22350: PUSH
22351: EMPTY
22352: LIST
22353: LIST
22354: PUSH
22355: EMPTY
22356: LIST
22357: LIST
22358: PPUSH
22359: CALL_OW 69
22363: PUSH
22364: LD_INT 1
22366: ARRAY
22367: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
22368: LD_INT 350
22370: PPUSH
22371: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
22375: LD_EXP 119
22379: PUSH
22380: LD_INT 4
22382: ARRAY
22383: PUSH
22384: LD_INT 5
22386: LESS
22387: PUSH
22388: LD_VAR 0 9
22392: PPUSH
22393: CALL_OW 461
22397: PUSH
22398: LD_INT 2
22400: EQUAL
22401: AND
22402: IFFALSE 22432
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
22404: LD_INT 4
22406: PPUSH
22407: LD_INT 3
22409: PUSH
22410: LD_INT 1
22412: PUSH
22413: LD_INT 1
22415: PUSH
22416: LD_INT 5
22418: PUSH
22419: EMPTY
22420: LIST
22421: LIST
22422: LIST
22423: LIST
22424: PUSH
22425: EMPTY
22426: LIST
22427: PPUSH
22428: CALL 61548 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
22432: LD_EXP 119
22436: PUSH
22437: LD_INT 4
22439: ARRAY
22440: PUSH
22441: LD_INT 5
22443: GREATEREQUAL
22444: PUSH
22445: LD_EXP 119
22449: PUSH
22450: LD_INT 4
22452: ARRAY
22453: PPUSH
22454: LD_INT 58
22456: PUSH
22457: EMPTY
22458: LIST
22459: PPUSH
22460: CALL_OW 72
22464: PUSH
22465: LD_INT 5
22467: GREATEREQUAL
22468: AND
22469: IFFALSE 22368
// powellAllowRetreat := false ;
22471: LD_ADDR_EXP 19
22475: PUSH
22476: LD_INT 0
22478: ST_TO_ADDR
// activeAttacks := false ;
22479: LD_ADDR_EXP 16
22483: PUSH
22484: LD_INT 0
22486: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22487: LD_INT 35
22489: PPUSH
22490: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
22494: LD_INT 22
22496: PUSH
22497: LD_INT 6
22499: PUSH
22500: EMPTY
22501: LIST
22502: LIST
22503: PPUSH
22504: CALL_OW 69
22508: PUSH
22509: LD_INT 0
22511: EQUAL
22512: IFFALSE 22487
// tmp := mc_vehicles [ 4 ] ;
22514: LD_ADDR_VAR 0 3
22518: PUSH
22519: LD_EXP 119
22523: PUSH
22524: LD_INT 4
22526: ARRAY
22527: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
22528: LD_ADDR_VAR 0 1
22532: PUSH
22533: DOUBLE
22534: LD_INT 1
22536: DEC
22537: ST_TO_ADDR
22538: LD_EXP 18
22542: PUSH
22543: FOR_TO
22544: IFFALSE 22805
// begin for j in powellSquadAttack [ i ] do
22546: LD_ADDR_VAR 0 2
22550: PUSH
22551: LD_EXP 18
22555: PUSH
22556: LD_VAR 0 1
22560: ARRAY
22561: PUSH
22562: FOR_IN
22563: IFFALSE 22801
// begin forces := forces diff j ;
22565: LD_ADDR_VAR 0 6
22569: PUSH
22570: LD_VAR 0 6
22574: PUSH
22575: LD_VAR 0 2
22579: DIFF
22580: ST_TO_ADDR
// SetTag ( j , 1 ) ;
22581: LD_VAR 0 2
22585: PPUSH
22586: LD_INT 1
22588: PPUSH
22589: CALL_OW 109
// wait ( 0 0$2 ) ;
22593: LD_INT 70
22595: PPUSH
22596: CALL_OW 67
// if IsInUnit ( j ) then
22600: LD_VAR 0 2
22604: PPUSH
22605: CALL_OW 310
22609: IFFALSE 22620
// ComExitBuilding ( j ) ;
22611: LD_VAR 0 2
22615: PPUSH
22616: CALL_OW 122
// if GetClass ( j ) <> 1 then
22620: LD_VAR 0 2
22624: PPUSH
22625: CALL_OW 257
22629: PUSH
22630: LD_INT 1
22632: NONEQUAL
22633: IFFALSE 22713
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
22635: LD_VAR 0 10
22639: PUSH
22640: LD_INT 1
22642: ARRAY
22643: PPUSH
22644: CALL_OW 313
22648: PUSH
22649: LD_INT 5
22651: GREATEREQUAL
22652: IFFALSE 22674
// AddComEnterUnit ( j , arm [ 2 ] ) else
22654: LD_VAR 0 2
22658: PPUSH
22659: LD_VAR 0 10
22663: PUSH
22664: LD_INT 2
22666: ARRAY
22667: PPUSH
22668: CALL_OW 180
22672: GO 22692
// AddComEnterUnit ( j , arm [ 1 ] ) ;
22674: LD_VAR 0 2
22678: PPUSH
22679: LD_VAR 0 10
22683: PUSH
22684: LD_INT 1
22686: ARRAY
22687: PPUSH
22688: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
22692: LD_VAR 0 2
22696: PPUSH
22697: LD_INT 1
22699: PPUSH
22700: CALL_OW 183
// AddComExitBuilding ( j ) ;
22704: LD_VAR 0 2
22708: PPUSH
22709: CALL_OW 182
// end ; if i = 2 then
22713: LD_VAR 0 1
22717: PUSH
22718: LD_INT 2
22720: EQUAL
22721: IFFALSE 22738
// AddComMoveXY ( j , 61 , 93 ) ;
22723: LD_VAR 0 2
22727: PPUSH
22728: LD_INT 61
22730: PPUSH
22731: LD_INT 93
22733: PPUSH
22734: CALL_OW 171
// if i = 1 then
22738: LD_VAR 0 1
22742: PUSH
22743: LD_INT 1
22745: EQUAL
22746: IFFALSE 22799
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
22748: LD_VAR 0 2
22752: PPUSH
22753: LD_VAR 0 3
22757: PUSH
22758: LD_INT 1
22760: ARRAY
22761: PPUSH
22762: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
22766: LD_ADDR_VAR 0 3
22770: PUSH
22771: LD_VAR 0 3
22775: PPUSH
22776: LD_INT 1
22778: PPUSH
22779: CALL_OW 3
22783: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
22784: LD_VAR 0 2
22788: PPUSH
22789: LD_INT 69
22791: PPUSH
22792: LD_INT 94
22794: PPUSH
22795: CALL_OW 171
// end ; end ;
22799: GO 22562
22801: POP
22802: POP
// end ;
22803: GO 22543
22805: POP
22806: POP
// wait ( 0 0$30 ) ;
22807: LD_INT 1050
22809: PPUSH
22810: CALL_OW 67
// MC_Kill ( 4 ) ;
22814: LD_INT 4
22816: PPUSH
22817: CALL 37537 0 1
// tmp := UnitsInside ( fac ) ;
22821: LD_ADDR_VAR 0 3
22825: PUSH
22826: LD_VAR 0 9
22830: PPUSH
22831: CALL_OW 313
22835: ST_TO_ADDR
// if tmp then
22836: LD_VAR 0 3
22840: IFFALSE 22961
// for i in tmp do
22842: LD_ADDR_VAR 0 1
22846: PUSH
22847: LD_VAR 0 3
22851: PUSH
22852: FOR_IN
22853: IFFALSE 22959
// begin ComExitBuilding ( i ) ;
22855: LD_VAR 0 1
22859: PPUSH
22860: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
22864: LD_VAR 0 10
22868: PUSH
22869: LD_INT 2
22871: ARRAY
22872: PPUSH
22873: CALL_OW 313
22877: PUSH
22878: LD_INT 6
22880: LESS
22881: IFFALSE 22903
// AddComEnterUnit ( i , arm [ 2 ] ) else
22883: LD_VAR 0 1
22887: PPUSH
22888: LD_VAR 0 10
22892: PUSH
22893: LD_INT 2
22895: ARRAY
22896: PPUSH
22897: CALL_OW 180
22901: GO 22957
// if UnitsInside ( arm [ 1 ] ) < 6 then
22903: LD_VAR 0 10
22907: PUSH
22908: LD_INT 1
22910: ARRAY
22911: PPUSH
22912: CALL_OW 313
22916: PUSH
22917: LD_INT 6
22919: LESS
22920: IFFALSE 22942
// AddComEnterUnit ( i , arm [ 1 ] ) else
22922: LD_VAR 0 1
22926: PPUSH
22927: LD_VAR 0 10
22931: PUSH
22932: LD_INT 1
22934: ARRAY
22935: PPUSH
22936: CALL_OW 180
22940: GO 22957
// AddComMoveXY ( i , 37 , 68 ) ;
22942: LD_VAR 0 1
22946: PPUSH
22947: LD_INT 37
22949: PPUSH
22950: LD_INT 68
22952: PPUSH
22953: CALL_OW 171
// end ;
22957: GO 22852
22959: POP
22960: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
22961: LD_ADDR_VAR 0 11
22965: PUSH
22966: LD_VAR 0 6
22970: PPUSH
22971: LD_INT 26
22973: PUSH
22974: LD_INT 1
22976: PUSH
22977: EMPTY
22978: LIST
22979: LIST
22980: PPUSH
22981: CALL_OW 72
22985: PUSH
22986: LD_EXP 61
22990: DIFF
22991: ST_TO_ADDR
// if not speaker then
22992: LD_VAR 0 11
22996: NOT
22997: IFFALSE 23024
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
22999: LD_ADDR_VAR 0 11
23003: PUSH
23004: LD_VAR 0 6
23008: PPUSH
23009: LD_INT 26
23011: PUSH
23012: LD_INT 1
23014: PUSH
23015: EMPTY
23016: LIST
23017: LIST
23018: PPUSH
23019: CALL_OW 72
23023: ST_TO_ADDR
// if speaker then
23024: LD_VAR 0 11
23028: IFFALSE 23044
// speaker := speaker [ 1 ] ;
23030: LD_ADDR_VAR 0 11
23034: PUSH
23035: LD_VAR 0 11
23039: PUSH
23040: LD_INT 1
23042: ARRAY
23043: ST_TO_ADDR
// Video ( true ) ;
23044: LD_INT 1
23046: PPUSH
23047: CALL 105238 0 1
// CenterNowOnUnits ( Powell ) ;
23051: LD_EXP 60
23055: PPUSH
23056: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
23060: LD_ADDR_VAR 0 3
23064: PUSH
23065: LD_VAR 0 6
23069: PPUSH
23070: LD_INT 3
23072: PUSH
23073: LD_INT 25
23075: PUSH
23076: LD_INT 1
23078: PUSH
23079: EMPTY
23080: LIST
23081: LIST
23082: PUSH
23083: EMPTY
23084: LIST
23085: LIST
23086: PPUSH
23087: CALL_OW 72
23091: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
23092: LD_ADDR_VAR 0 12
23096: PUSH
23097: LD_INT 22
23099: PUSH
23100: LD_INT 4
23102: PUSH
23103: EMPTY
23104: LIST
23105: LIST
23106: PUSH
23107: LD_INT 30
23109: PUSH
23110: LD_INT 32
23112: PUSH
23113: EMPTY
23114: LIST
23115: LIST
23116: PUSH
23117: LD_INT 58
23119: PUSH
23120: EMPTY
23121: LIST
23122: PUSH
23123: EMPTY
23124: LIST
23125: LIST
23126: LIST
23127: PPUSH
23128: CALL_OW 69
23132: ST_TO_ADDR
// for i := 1 to 4 do
23133: LD_ADDR_VAR 0 1
23137: PUSH
23138: DOUBLE
23139: LD_INT 1
23141: DEC
23142: ST_TO_ADDR
23143: LD_INT 4
23145: PUSH
23146: FOR_TO
23147: IFFALSE 23293
// begin if IsInUnit ( tmp [ i ] ) then
23149: LD_VAR 0 3
23153: PUSH
23154: LD_VAR 0 1
23158: ARRAY
23159: PPUSH
23160: CALL_OW 310
23164: IFFALSE 23181
// ComExitBuilding ( tmp [ i ] ) ;
23166: LD_VAR 0 3
23170: PUSH
23171: LD_VAR 0 1
23175: ARRAY
23176: PPUSH
23177: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
23181: LD_VAR 0 3
23185: PUSH
23186: LD_VAR 0 1
23190: ARRAY
23191: PPUSH
23192: LD_VAR 0 10
23196: PUSH
23197: LD_INT 1
23199: ARRAY
23200: PPUSH
23201: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
23205: LD_VAR 0 3
23209: PUSH
23210: LD_VAR 0 1
23214: ARRAY
23215: PPUSH
23216: LD_INT 1
23218: PPUSH
23219: CALL_OW 183
// if Count ( emp_towers ) then
23223: LD_VAR 0 12
23227: PPUSH
23228: CALL 70076 0 1
23232: IFFALSE 23291
// begin AddComExitBuilding ( tmp [ i ] ) ;
23234: LD_VAR 0 3
23238: PUSH
23239: LD_VAR 0 1
23243: ARRAY
23244: PPUSH
23245: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
23249: LD_VAR 0 3
23253: PUSH
23254: LD_VAR 0 1
23258: ARRAY
23259: PPUSH
23260: LD_VAR 0 12
23264: PUSH
23265: LD_INT 1
23267: ARRAY
23268: PPUSH
23269: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
23273: LD_ADDR_VAR 0 12
23277: PUSH
23278: LD_VAR 0 12
23282: PPUSH
23283: LD_INT 1
23285: PPUSH
23286: CALL_OW 3
23290: ST_TO_ADDR
// end ; end ;
23291: GO 23146
23293: POP
23294: POP
// wait ( 0 0$5 ) ;
23295: LD_INT 175
23297: PPUSH
23298: CALL_OW 67
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
23302: LD_VAR 0 3
23306: PPUSH
23307: LD_INT 3
23309: PUSH
23310: LD_INT 54
23312: PUSH
23313: EMPTY
23314: LIST
23315: PUSH
23316: EMPTY
23317: LIST
23318: LIST
23319: PPUSH
23320: CALL_OW 72
23324: IFFALSE 23344
// ComEnterUnit ( tmp , arm [ 1 ] ) ;
23326: LD_VAR 0 3
23330: PPUSH
23331: LD_VAR 0 10
23335: PUSH
23336: LD_INT 1
23338: ARRAY
23339: PPUSH
23340: CALL_OW 120
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
23344: LD_ADDR_VAR 0 3
23348: PUSH
23349: LD_EXP 18
23353: PUSH
23354: LD_INT 1
23356: ARRAY
23357: PUSH
23358: LD_EXP 18
23362: PUSH
23363: LD_INT 2
23365: ARRAY
23366: ADD
23367: PPUSH
23368: LD_INT 26
23370: PUSH
23371: LD_INT 1
23373: PUSH
23374: EMPTY
23375: LIST
23376: LIST
23377: PPUSH
23378: CALL_OW 72
23382: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
23383: LD_ADDR_VAR 0 1
23387: PUSH
23388: LD_EXP 18
23392: PUSH
23393: LD_INT 2
23395: ARRAY
23396: PUSH
23397: FOR_IN
23398: IFFALSE 23416
// ComTurnUnit ( i , Powell ) ;
23400: LD_VAR 0 1
23404: PPUSH
23405: LD_EXP 60
23409: PPUSH
23410: CALL_OW 119
23414: GO 23397
23416: POP
23417: POP
// Say ( Powell , D5-Pow-1 ) ;
23418: LD_EXP 60
23422: PPUSH
23423: LD_STRING D5-Pow-1
23425: PPUSH
23426: CALL_OW 88
// if tmp then
23430: LD_VAR 0 3
23434: IFFALSE 23452
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
23436: LD_VAR 0 3
23440: PUSH
23441: LD_INT 1
23443: ARRAY
23444: PPUSH
23445: LD_STRING D5-Sol2-1
23447: PPUSH
23448: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
23452: LD_EXP 60
23456: PPUSH
23457: LD_STRING D5-Pow-2
23459: PPUSH
23460: CALL_OW 88
// if tmp > 1 then
23464: LD_VAR 0 3
23468: PUSH
23469: LD_INT 1
23471: GREATER
23472: IFFALSE 23490
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
23474: LD_VAR 0 3
23478: PUSH
23479: LD_INT 2
23481: ARRAY
23482: PPUSH
23483: LD_STRING D5-Sol2-2
23485: PPUSH
23486: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
23490: LD_EXP 60
23494: PPUSH
23495: LD_STRING D5-Pow-3
23497: PPUSH
23498: CALL_OW 88
// wait ( 0 0$1 ) ;
23502: LD_INT 35
23504: PPUSH
23505: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
23509: LD_ADDR_VAR 0 3
23513: PUSH
23514: LD_EXP 18
23518: PUSH
23519: LD_INT 1
23521: ARRAY
23522: PUSH
23523: LD_EXP 18
23527: PUSH
23528: LD_INT 2
23530: ARRAY
23531: UNION
23532: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
23533: LD_VAR 0 3
23537: PPUSH
23538: LD_INT 80
23540: PPUSH
23541: LD_INT 67
23543: PPUSH
23544: CALL_OW 114
// wait ( 0 0$2 ) ;
23548: LD_INT 70
23550: PPUSH
23551: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
23555: LD_INT 79
23557: PPUSH
23558: LD_INT 72
23560: PPUSH
23561: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
23565: LD_INT 70
23567: PPUSH
23568: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
23572: LD_VAR 0 3
23576: PPUSH
23577: LD_INT 3
23579: PUSH
23580: LD_INT 24
23582: PUSH
23583: LD_INT 1000
23585: PUSH
23586: EMPTY
23587: LIST
23588: LIST
23589: PUSH
23590: EMPTY
23591: LIST
23592: LIST
23593: PPUSH
23594: CALL_OW 72
23598: IFFALSE 23565
// Say ( Powell , D5a-Pow-1 ) ;
23600: LD_EXP 60
23604: PPUSH
23605: LD_STRING D5a-Pow-1
23607: PPUSH
23608: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
23612: LD_EXP 60
23616: PPUSH
23617: LD_STRING D5a-Pow-1a
23619: PPUSH
23620: CALL_OW 88
// wait ( 0 0$0.7 ) ;
23624: LD_INT 24
23626: PPUSH
23627: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
23631: LD_EXP 60
23635: PPUSH
23636: LD_STRING D5a-Pow-1b
23638: PPUSH
23639: CALL_OW 88
// wait ( 0 0$0.3 ) ;
23643: LD_INT 10
23645: PPUSH
23646: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
23650: LD_EXP 60
23654: PPUSH
23655: LD_STRING D5a-Pow-1c
23657: PPUSH
23658: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
23662: LD_VAR 0 3
23666: PPUSH
23667: LD_INT 68
23669: PPUSH
23670: LD_INT 63
23672: PPUSH
23673: CALL_OW 111
// wait ( 0 0$0.5 ) ;
23677: LD_INT 18
23679: PPUSH
23680: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
23684: LD_EXP 60
23688: PPUSH
23689: LD_STRING D5a-Pow-1d
23691: PPUSH
23692: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
23696: LD_INT 35
23698: PPUSH
23699: CALL_OW 67
// if not HasTask ( tmp ) then
23703: LD_VAR 0 3
23707: PPUSH
23708: CALL_OW 314
23712: NOT
23713: IFFALSE 23730
// ComAgressiveMove ( tmp , 68 , 63 ) ;
23715: LD_VAR 0 3
23719: PPUSH
23720: LD_INT 68
23722: PPUSH
23723: LD_INT 63
23725: PPUSH
23726: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
23730: LD_VAR 0 3
23734: PPUSH
23735: LD_INT 24
23737: PUSH
23738: LD_INT 1
23740: PUSH
23741: EMPTY
23742: LIST
23743: LIST
23744: PPUSH
23745: CALL_OW 72
23749: NOT
23750: IFFALSE 23696
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
23752: LD_ADDR_VAR 0 3
23756: PUSH
23757: LD_INT 22
23759: PUSH
23760: LD_INT 4
23762: PUSH
23763: EMPTY
23764: LIST
23765: LIST
23766: PUSH
23767: LD_INT 92
23769: PUSH
23770: LD_INT 60
23772: PUSH
23773: LD_INT 93
23775: PUSH
23776: LD_INT 10
23778: PUSH
23779: EMPTY
23780: LIST
23781: LIST
23782: LIST
23783: LIST
23784: PUSH
23785: LD_INT 3
23787: PUSH
23788: LD_INT 54
23790: PUSH
23791: EMPTY
23792: LIST
23793: PUSH
23794: EMPTY
23795: LIST
23796: LIST
23797: PUSH
23798: EMPTY
23799: LIST
23800: LIST
23801: LIST
23802: PPUSH
23803: CALL_OW 69
23807: PUSH
23808: LD_EXP 60
23812: DIFF
23813: ST_TO_ADDR
// if tmp then
23814: LD_VAR 0 3
23818: IFFALSE 23852
// for i in tmp do
23820: LD_ADDR_VAR 0 1
23824: PUSH
23825: LD_VAR 0 3
23829: PUSH
23830: FOR_IN
23831: IFFALSE 23850
// ComMoveXY ( i , 36 , 67 ) ;
23833: LD_VAR 0 1
23837: PPUSH
23838: LD_INT 36
23840: PPUSH
23841: LD_INT 67
23843: PPUSH
23844: CALL_OW 111
23848: GO 23830
23850: POP
23851: POP
// wait ( 0 0$3 ) ;
23852: LD_INT 105
23854: PPUSH
23855: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
23859: LD_VAR 0 11
23863: PPUSH
23864: LD_STRING D6-Sol3-1
23866: PPUSH
23867: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
23871: LD_EXP 60
23875: PPUSH
23876: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
23880: LD_EXP 60
23884: PPUSH
23885: LD_STRING D6-Pow-1
23887: PPUSH
23888: CALL_OW 88
// tmp := [ ] ;
23892: LD_ADDR_VAR 0 3
23896: PUSH
23897: EMPTY
23898: ST_TO_ADDR
// for i = 1 to 2 do
23899: LD_ADDR_VAR 0 1
23903: PUSH
23904: DOUBLE
23905: LD_INT 1
23907: DEC
23908: ST_TO_ADDR
23909: LD_INT 2
23911: PUSH
23912: FOR_TO
23913: IFFALSE 24027
// begin uc_side := 8 ;
23915: LD_ADDR_OWVAR 20
23919: PUSH
23920: LD_INT 8
23922: ST_TO_ADDR
// uc_nation := 2 ;
23923: LD_ADDR_OWVAR 21
23927: PUSH
23928: LD_INT 2
23930: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
23931: LD_INT 14
23933: PPUSH
23934: LD_INT 3
23936: PPUSH
23937: LD_INT 2
23939: PPUSH
23940: LD_INT 29
23942: PPUSH
23943: LD_INT 100
23945: PPUSH
23946: CALL 72814 0 5
// veh := CreateVehicle ;
23950: LD_ADDR_VAR 0 13
23954: PUSH
23955: CALL_OW 45
23959: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
23960: LD_VAR 0 13
23964: PPUSH
23965: LD_INT 4
23967: PPUSH
23968: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
23972: LD_VAR 0 13
23976: PPUSH
23977: LD_INT 99
23979: PPUSH
23980: LD_INT 83
23982: PPUSH
23983: LD_INT 3
23985: PPUSH
23986: LD_INT 0
23988: PPUSH
23989: CALL_OW 50
// wait ( 3 ) ;
23993: LD_INT 3
23995: PPUSH
23996: CALL_OW 67
// Connect ( veh ) ;
24000: LD_VAR 0 13
24004: PPUSH
24005: CALL 75905 0 1
// tmp := tmp ^ veh ;
24009: LD_ADDR_VAR 0 3
24013: PUSH
24014: LD_VAR 0 3
24018: PUSH
24019: LD_VAR 0 13
24023: ADD
24024: ST_TO_ADDR
// end ;
24025: GO 23912
24027: POP
24028: POP
// wait ( 0 0$1 ) ;
24029: LD_INT 35
24031: PPUSH
24032: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
24036: LD_INT 99
24038: PPUSH
24039: LD_INT 83
24041: PPUSH
24042: LD_INT 1
24044: PPUSH
24045: LD_INT 10
24047: PPUSH
24048: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
24052: LD_INT 99
24054: PPUSH
24055: LD_INT 83
24057: PPUSH
24058: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
24062: LD_VAR 0 11
24066: PPUSH
24067: LD_STRING D6-Sol3-2
24069: PPUSH
24070: CALL_OW 88
// async ;
24074: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
24075: LD_EXP 60
24079: PPUSH
24080: LD_STRING D6-Pow-2
24082: PPUSH
24083: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
24087: LD_VAR 0 3
24091: PUSH
24092: LD_INT 1
24094: ARRAY
24095: PPUSH
24096: LD_VAR 0 9
24100: PPUSH
24101: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
24105: LD_VAR 0 3
24109: PUSH
24110: LD_INT 2
24112: ARRAY
24113: PPUSH
24114: LD_INT 22
24116: PUSH
24117: LD_INT 4
24119: PUSH
24120: EMPTY
24121: LIST
24122: LIST
24123: PUSH
24124: LD_INT 21
24126: PUSH
24127: LD_INT 3
24129: PUSH
24130: EMPTY
24131: LIST
24132: LIST
24133: PUSH
24134: EMPTY
24135: LIST
24136: LIST
24137: PPUSH
24138: CALL_OW 69
24142: PPUSH
24143: LD_VAR 0 3
24147: PUSH
24148: LD_INT 2
24150: ARRAY
24151: PPUSH
24152: CALL_OW 74
24156: PPUSH
24157: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
24161: LD_EXP 60
24165: PPUSH
24166: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
24170: LD_INT 99
24172: PPUSH
24173: LD_INT 83
24175: PPUSH
24176: LD_INT 1
24178: PPUSH
24179: CALL_OW 331
// repeat wait ( 4 ) ;
24183: LD_INT 4
24185: PPUSH
24186: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
24190: LD_VAR 0 3
24194: PUSH
24195: LD_INT 1
24197: ARRAY
24198: PPUSH
24199: CALL_OW 256
24203: PUSH
24204: LD_INT 1000
24206: LESS
24207: IFFALSE 24225
// SetLives ( tmp [ 1 ] , 1000 ) ;
24209: LD_VAR 0 3
24213: PUSH
24214: LD_INT 1
24216: ARRAY
24217: PPUSH
24218: LD_INT 1000
24220: PPUSH
24221: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
24225: LD_INT 22
24227: PUSH
24228: LD_INT 4
24230: PUSH
24231: EMPTY
24232: LIST
24233: LIST
24234: PUSH
24235: LD_INT 30
24237: PUSH
24238: LD_INT 3
24240: PUSH
24241: EMPTY
24242: LIST
24243: LIST
24244: PUSH
24245: EMPTY
24246: LIST
24247: LIST
24248: PPUSH
24249: CALL_OW 69
24253: PUSH
24254: LD_INT 0
24256: EQUAL
24257: IFFALSE 24183
// skirmish := false ;
24259: LD_ADDR_EXP 98
24263: PUSH
24264: LD_INT 0
24266: ST_TO_ADDR
// sync ;
24267: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
24268: LD_EXP 60
24272: PPUSH
24273: LD_STRING D6a-Pow-1
24275: PPUSH
24276: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
24280: LD_VAR 0 11
24284: PPUSH
24285: LD_STRING D6a-Sol3-1
24287: PPUSH
24288: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
24292: LD_EXP 60
24296: PPUSH
24297: LD_STRING D6a-Pow-2
24299: PPUSH
24300: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
24304: LD_VAR 0 11
24308: PPUSH
24309: LD_STRING D6a-Sol3-2
24311: PPUSH
24312: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
24316: LD_EXP 60
24320: PPUSH
24321: LD_STRING D6a-Pow-3
24323: PPUSH
24324: CALL_OW 88
// powellCenterCameraMode := true ;
24328: LD_ADDR_EXP 20
24332: PUSH
24333: LD_INT 1
24335: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
24336: LD_ADDR_VAR 0 1
24340: PUSH
24341: LD_INT 22
24343: PUSH
24344: LD_INT 8
24346: PUSH
24347: EMPTY
24348: LIST
24349: LIST
24350: PUSH
24351: LD_INT 25
24353: PUSH
24354: LD_INT 2
24356: PUSH
24357: EMPTY
24358: LIST
24359: LIST
24360: PUSH
24361: EMPTY
24362: LIST
24363: LIST
24364: PPUSH
24365: CALL_OW 69
24369: PUSH
24370: FOR_IN
24371: IFFALSE 24426
// begin SetTag ( i , 1 ) ;
24373: LD_VAR 0 1
24377: PPUSH
24378: LD_INT 1
24380: PPUSH
24381: CALL_OW 109
// ComExitBuilding ( i ) ;
24385: LD_VAR 0 1
24389: PPUSH
24390: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
24394: LD_VAR 0 1
24398: PPUSH
24399: LD_INT 35
24401: PPUSH
24402: LD_INT 6
24404: PPUSH
24405: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
24409: LD_VAR 0 1
24413: PPUSH
24414: LD_INT 53
24416: PPUSH
24417: LD_INT 4
24419: PPUSH
24420: CALL_OW 171
// end ;
24424: GO 24370
24426: POP
24427: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
24428: LD_ADDR_VAR 0 3
24432: PUSH
24433: LD_INT 22
24435: PUSH
24436: LD_INT 4
24438: PUSH
24439: EMPTY
24440: LIST
24441: LIST
24442: PUSH
24443: LD_INT 21
24445: PUSH
24446: LD_INT 2
24448: PUSH
24449: EMPTY
24450: LIST
24451: LIST
24452: PUSH
24453: LD_INT 3
24455: PUSH
24456: LD_INT 34
24458: PUSH
24459: LD_INT 12
24461: PUSH
24462: EMPTY
24463: LIST
24464: LIST
24465: PUSH
24466: EMPTY
24467: LIST
24468: LIST
24469: PUSH
24470: EMPTY
24471: LIST
24472: LIST
24473: LIST
24474: PPUSH
24475: CALL_OW 69
24479: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
24480: LD_EXP 60
24484: PPUSH
24485: LD_VAR 0 3
24489: PPUSH
24490: LD_EXP 60
24494: PPUSH
24495: CALL_OW 74
24499: PPUSH
24500: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
24504: LD_EXP 60
24508: PPUSH
24509: LD_INT 100
24511: PPUSH
24512: LD_INT 88
24514: PPUSH
24515: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
24519: LD_EXP 60
24523: PPUSH
24524: LD_INT 100
24526: PPUSH
24527: LD_INT 75
24529: PPUSH
24530: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
24534: LD_EXP 60
24538: PPUSH
24539: LD_INT 88
24541: PPUSH
24542: LD_INT 53
24544: PPUSH
24545: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
24549: LD_INT 8
24551: PPUSH
24552: LD_EXP 60
24556: PPUSH
24557: CALL_OW 471
// repeat wait ( 3 ) ;
24561: LD_INT 3
24563: PPUSH
24564: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
24568: LD_INT 22
24570: PUSH
24571: LD_INT 4
24573: PUSH
24574: EMPTY
24575: LIST
24576: LIST
24577: PUSH
24578: LD_INT 92
24580: PUSH
24581: LD_INT 100
24583: PUSH
24584: LD_INT 75
24586: PUSH
24587: LD_INT 6
24589: PUSH
24590: EMPTY
24591: LIST
24592: LIST
24593: LIST
24594: LIST
24595: PUSH
24596: EMPTY
24597: LIST
24598: LIST
24599: PPUSH
24600: CALL_OW 69
24604: IFFALSE 24561
// async ;
24606: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
24607: LD_EXP 60
24611: PPUSH
24612: LD_STRING D6b-Pow-1
24614: PPUSH
24615: CALL_OW 88
// repeat wait ( 3 ) ;
24619: LD_INT 3
24621: PPUSH
24622: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
24626: LD_EXP 60
24630: PPUSH
24631: CALL_OW 310
24635: PPUSH
24636: CALL_OW 256
24640: PUSH
24641: LD_INT 1000
24643: LESS
24644: IFFALSE 24663
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
24646: LD_EXP 60
24650: PPUSH
24651: CALL_OW 310
24655: PPUSH
24656: LD_INT 1000
24658: PPUSH
24659: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
24663: LD_EXP 60
24667: PPUSH
24668: CALL_OW 256
24672: PUSH
24673: LD_INT 1000
24675: LESS
24676: IFFALSE 24690
// SetLives ( Powell , 1000 ) ;
24678: LD_EXP 60
24682: PPUSH
24683: LD_INT 1000
24685: PPUSH
24686: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
24690: LD_EXP 60
24694: PPUSH
24695: LD_EXP 65
24699: PPUSH
24700: CALL_OW 296
24704: PUSH
24705: LD_INT 5
24707: LESS
24708: PUSH
24709: LD_EXP 60
24713: PPUSH
24714: CALL_OW 310
24718: PPUSH
24719: LD_EXP 65
24723: PPUSH
24724: CALL_OW 296
24728: PUSH
24729: LD_INT 5
24731: LESS
24732: OR
24733: IFFALSE 24752
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
24735: LD_EXP 60
24739: PPUSH
24740: CALL_OW 310
24744: PPUSH
24745: LD_INT 100
24747: PPUSH
24748: CALL_OW 234
// until not IsInUnit ( Powell ) ;
24752: LD_EXP 60
24756: PPUSH
24757: CALL_OW 310
24761: NOT
24762: IFFALSE 24619
// DoNotAttack ( 8 , powellBomb ) ;
24764: LD_INT 8
24766: PPUSH
24767: LD_EXP 65
24771: PPUSH
24772: CALL_OW 471
// game_speed := 4 ;
24776: LD_ADDR_OWVAR 65
24780: PUSH
24781: LD_INT 4
24783: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
24784: LD_EXP 60
24788: PPUSH
24789: LD_STRING D6b-Pow-1a
24791: PPUSH
24792: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
24796: LD_EXP 60
24800: PPUSH
24801: LD_EXP 65
24805: PPUSH
24806: CALL_OW 180
// sync ;
24810: SYNC
// repeat wait ( 0 0$1 ) ;
24811: LD_INT 35
24813: PPUSH
24814: CALL_OW 67
// until IsInUnit ( Powell ) ;
24818: LD_EXP 60
24822: PPUSH
24823: CALL_OW 310
24827: IFFALSE 24811
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
24829: LD_INT 8
24831: PPUSH
24832: LD_EXP 60
24836: PPUSH
24837: CALL_OW 310
24841: PPUSH
24842: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
24846: LD_EXP 60
24850: PPUSH
24851: LD_INT 91
24853: PPUSH
24854: LD_INT 44
24856: PPUSH
24857: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
24861: LD_EXP 60
24865: PPUSH
24866: LD_INT 96
24868: PPUSH
24869: LD_INT 44
24871: PPUSH
24872: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
24876: LD_EXP 60
24880: PPUSH
24881: LD_INT 96
24883: PPUSH
24884: LD_INT 41
24886: PPUSH
24887: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
24891: LD_EXP 60
24895: PPUSH
24896: LD_INT 92
24898: PPUSH
24899: LD_INT 39
24901: PPUSH
24902: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
24906: LD_EXP 60
24910: PPUSH
24911: LD_INT 88
24913: PPUSH
24914: LD_INT 41
24916: PPUSH
24917: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
24921: LD_EXP 60
24925: PPUSH
24926: LD_INT 91
24928: PPUSH
24929: LD_INT 44
24931: PPUSH
24932: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
24936: LD_EXP 60
24940: PPUSH
24941: LD_INT 96
24943: PPUSH
24944: LD_INT 44
24946: PPUSH
24947: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
24951: LD_EXP 60
24955: PPUSH
24956: LD_INT 96
24958: PPUSH
24959: LD_INT 41
24961: PPUSH
24962: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
24966: LD_EXP 60
24970: PPUSH
24971: LD_INT 92
24973: PPUSH
24974: LD_INT 39
24976: PPUSH
24977: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
24981: LD_EXP 60
24985: PPUSH
24986: LD_INT 88
24988: PPUSH
24989: LD_INT 41
24991: PPUSH
24992: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
24996: LD_EXP 60
25000: PPUSH
25001: LD_INT 91
25003: PPUSH
25004: LD_INT 44
25006: PPUSH
25007: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
25011: LD_EXP 60
25015: PPUSH
25016: LD_INT 93
25018: PPUSH
25019: LD_INT 39
25021: PPUSH
25022: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
25026: LD_EXP 60
25030: PPUSH
25031: LD_INT 93
25033: PPUSH
25034: LD_INT 36
25036: PPUSH
25037: CALL_OW 171
// wait ( 0 0$3.5 ) ;
25041: LD_INT 122
25043: PPUSH
25044: CALL_OW 67
// game_speed := 4 ;
25048: LD_ADDR_OWVAR 65
25052: PUSH
25053: LD_INT 4
25055: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
25056: LD_EXP 60
25060: PPUSH
25061: LD_STRING D6b-Pow-1b
25063: PPUSH
25064: CALL_OW 88
// tmp := [ ] ;
25068: LD_ADDR_VAR 0 3
25072: PUSH
25073: EMPTY
25074: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
25075: LD_ADDR_VAR 0 5
25079: PUSH
25080: LD_INT 78
25082: PUSH
25083: LD_INT 47
25085: PUSH
25086: EMPTY
25087: LIST
25088: LIST
25089: PUSH
25090: LD_INT 106
25092: PUSH
25093: LD_INT 53
25095: PUSH
25096: EMPTY
25097: LIST
25098: LIST
25099: PUSH
25100: EMPTY
25101: LIST
25102: LIST
25103: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
25104: LD_ADDR_VAR 0 1
25108: PUSH
25109: LD_INT 22
25111: PUSH
25112: LD_INT 8
25114: PUSH
25115: EMPTY
25116: LIST
25117: LIST
25118: PUSH
25119: LD_INT 21
25121: PUSH
25122: LD_INT 3
25124: PUSH
25125: EMPTY
25126: LIST
25127: LIST
25128: PUSH
25129: LD_INT 92
25131: PUSH
25132: LD_INT 90
25134: PUSH
25135: LD_INT 52
25137: PUSH
25138: LD_INT 12
25140: PUSH
25141: EMPTY
25142: LIST
25143: LIST
25144: LIST
25145: LIST
25146: PUSH
25147: EMPTY
25148: LIST
25149: LIST
25150: LIST
25151: PPUSH
25152: CALL_OW 69
25156: PUSH
25157: FOR_IN
25158: IFFALSE 25183
// tmp := tmp ^ UnitsInside ( i ) ;
25160: LD_ADDR_VAR 0 3
25164: PUSH
25165: LD_VAR 0 3
25169: PUSH
25170: LD_VAR 0 1
25174: PPUSH
25175: CALL_OW 313
25179: ADD
25180: ST_TO_ADDR
25181: GO 25157
25183: POP
25184: POP
// for i in tmp do
25185: LD_ADDR_VAR 0 1
25189: PUSH
25190: LD_VAR 0 3
25194: PUSH
25195: FOR_IN
25196: IFFALSE 25358
// begin dist := 9999 ;
25198: LD_ADDR_VAR 0 8
25202: PUSH
25203: LD_INT 9999
25205: ST_TO_ADDR
// _xy := [ ] ;
25206: LD_ADDR_VAR 0 7
25210: PUSH
25211: EMPTY
25212: ST_TO_ADDR
// SetTag ( i , 1 ) ;
25213: LD_VAR 0 1
25217: PPUSH
25218: LD_INT 1
25220: PPUSH
25221: CALL_OW 109
// ComExitBuilding ( i ) ;
25225: LD_VAR 0 1
25229: PPUSH
25230: CALL_OW 122
// for j in xy do
25234: LD_ADDR_VAR 0 2
25238: PUSH
25239: LD_VAR 0 5
25243: PUSH
25244: FOR_IN
25245: IFFALSE 25327
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
25247: LD_VAR 0 1
25251: PPUSH
25252: LD_VAR 0 2
25256: PUSH
25257: LD_INT 1
25259: ARRAY
25260: PPUSH
25261: LD_VAR 0 2
25265: PUSH
25266: LD_INT 2
25268: ARRAY
25269: PPUSH
25270: CALL_OW 297
25274: PUSH
25275: LD_VAR 0 8
25279: LESS
25280: IFFALSE 25325
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
25282: LD_ADDR_VAR 0 8
25286: PUSH
25287: LD_VAR 0 1
25291: PPUSH
25292: LD_VAR 0 2
25296: PUSH
25297: LD_INT 1
25299: ARRAY
25300: PPUSH
25301: LD_VAR 0 2
25305: PUSH
25306: LD_INT 2
25308: ARRAY
25309: PPUSH
25310: CALL_OW 297
25314: ST_TO_ADDR
// _xy := j ;
25315: LD_ADDR_VAR 0 7
25319: PUSH
25320: LD_VAR 0 2
25324: ST_TO_ADDR
// end ;
25325: GO 25244
25327: POP
25328: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
25329: LD_VAR 0 1
25333: PPUSH
25334: LD_VAR 0 7
25338: PUSH
25339: LD_INT 1
25341: ARRAY
25342: PPUSH
25343: LD_VAR 0 7
25347: PUSH
25348: LD_INT 2
25350: ARRAY
25351: PPUSH
25352: CALL_OW 171
// end ;
25356: GO 25195
25358: POP
25359: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
25360: LD_ADDR_VAR 0 4
25364: PUSH
25365: LD_VAR 0 3
25369: PPUSH
25370: LD_INT 26
25372: PUSH
25373: LD_INT 1
25375: PUSH
25376: EMPTY
25377: LIST
25378: LIST
25379: PUSH
25380: LD_INT 25
25382: PUSH
25383: LD_INT 1
25385: PUSH
25386: EMPTY
25387: LIST
25388: LIST
25389: PUSH
25390: EMPTY
25391: LIST
25392: LIST
25393: PPUSH
25394: CALL_OW 72
25398: ST_TO_ADDR
// if tmp2 < 2 then
25399: LD_VAR 0 4
25403: PUSH
25404: LD_INT 2
25406: LESS
25407: IFFALSE 25476
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
25409: LD_ADDR_VAR 0 4
25413: PUSH
25414: LD_INT 22
25416: PUSH
25417: LD_INT 8
25419: PUSH
25420: EMPTY
25421: LIST
25422: LIST
25423: PUSH
25424: LD_INT 26
25426: PUSH
25427: LD_INT 1
25429: PUSH
25430: EMPTY
25431: LIST
25432: LIST
25433: PUSH
25434: LD_INT 3
25436: PUSH
25437: LD_INT 25
25439: PUSH
25440: LD_INT 15
25442: PUSH
25443: EMPTY
25444: LIST
25445: LIST
25446: PUSH
25447: EMPTY
25448: LIST
25449: LIST
25450: PUSH
25451: EMPTY
25452: LIST
25453: LIST
25454: LIST
25455: PPUSH
25456: CALL_OW 69
25460: PUSH
25461: LD_EXP 62
25465: PUSH
25466: LD_EXP 63
25470: PUSH
25471: EMPTY
25472: LIST
25473: LIST
25474: DIFF
25475: ST_TO_ADDR
// if tmp2 then
25476: LD_VAR 0 4
25480: IFFALSE 25498
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
25482: LD_VAR 0 4
25486: PUSH
25487: LD_INT 1
25489: ARRAY
25490: PPUSH
25491: LD_STRING D6b-ArSol1-1
25493: PPUSH
25494: CALL_OW 88
// async ;
25498: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
25499: LD_EXP 60
25503: PPUSH
25504: LD_STRING D6b-Pow-2
25506: PPUSH
25507: CALL_OW 88
// wait ( 0 0$0.5 ) ;
25511: LD_INT 18
25513: PPUSH
25514: CALL_OW 67
// if tmp2 > 1 then
25518: LD_VAR 0 4
25522: PUSH
25523: LD_INT 1
25525: GREATER
25526: IFFALSE 25544
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
25528: LD_VAR 0 4
25532: PUSH
25533: LD_INT 2
25535: ARRAY
25536: PPUSH
25537: LD_STRING D6b-ArSol2-1
25539: PPUSH
25540: CALL_OW 88
// sync ;
25544: SYNC
// repeat wait ( 5 ) ;
25545: LD_INT 5
25547: PPUSH
25548: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
25552: LD_INT 93
25554: PPUSH
25555: LD_INT 36
25557: PPUSH
25558: CALL_OW 428
25562: PPUSH
25563: CALL_OW 255
25567: PUSH
25568: LD_INT 4
25570: EQUAL
25571: IFFALSE 25545
// DialogueOn ;
25573: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
25577: LD_INT 10
25579: PPUSH
25580: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
25584: LD_EXP 60
25588: PPUSH
25589: LD_STRING D6b-Pow-2a
25591: PPUSH
25592: CALL_OW 88
// DialogueOff ;
25596: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
25600: LD_EXP 60
25604: PPUSH
25605: CALL_OW 310
25609: PPUSH
25610: LD_INT 332
25612: PPUSH
25613: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
25617: LD_INT 93
25619: PPUSH
25620: LD_INT 35
25622: PPUSH
25623: LD_INT 1
25625: PPUSH
25626: LD_INT 6
25628: NEG
25629: PPUSH
25630: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
25634: LD_INT 35
25636: PPUSH
25637: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
25641: LD_INT 332
25643: PPUSH
25644: CALL_OW 256
25648: PUSH
25649: LD_INT 1000
25651: LESS
25652: PUSH
25653: LD_INT 332
25655: PPUSH
25656: CALL_OW 300
25660: AND
25661: IFFALSE 25673
// SetLives ( kozlov_fac , 0 ) ;
25663: LD_INT 332
25665: PPUSH
25666: LD_INT 0
25668: PPUSH
25669: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
25673: LD_INT 332
25675: PPUSH
25676: CALL_OW 301
25680: PUSH
25681: LD_EXP 60
25685: PPUSH
25686: CALL_OW 301
25690: OR
25691: IFFALSE 25634
// game_speed := 4 ;
25693: LD_ADDR_OWVAR 65
25697: PUSH
25698: LD_INT 4
25700: ST_TO_ADDR
// powellCenterCameraMode := false ;
25701: LD_ADDR_EXP 20
25705: PUSH
25706: LD_INT 0
25708: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
25709: LD_ADDR_VAR 0 1
25713: PUSH
25714: LD_VAR 0 3
25718: PUSH
25719: LD_INT 22
25721: PUSH
25722: LD_INT 8
25724: PUSH
25725: EMPTY
25726: LIST
25727: LIST
25728: PUSH
25729: LD_INT 25
25731: PUSH
25732: LD_INT 2
25734: PUSH
25735: EMPTY
25736: LIST
25737: LIST
25738: PUSH
25739: EMPTY
25740: LIST
25741: LIST
25742: PPUSH
25743: CALL_OW 69
25747: UNION
25748: PUSH
25749: FOR_IN
25750: IFFALSE 25766
// SetTag ( i , 0 ) ;
25752: LD_VAR 0 1
25756: PPUSH
25757: LD_INT 0
25759: PPUSH
25760: CALL_OW 109
25764: GO 25749
25766: POP
25767: POP
// wait ( 0 0$3 ) ;
25768: LD_INT 105
25770: PPUSH
25771: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
25775: LD_INT 93
25777: PPUSH
25778: LD_INT 35
25780: PPUSH
25781: LD_INT 1
25783: PPUSH
25784: CALL_OW 331
// DialogueOn ;
25788: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
25792: LD_VAR 0 11
25796: PPUSH
25797: LD_STRING D6c-Sol3-1
25799: PPUSH
25800: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
25804: LD_INT 10
25806: PPUSH
25807: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
25811: LD_EXP 40
25815: PPUSH
25816: LD_STRING D6c-JMM-1
25818: PPUSH
25819: CALL_OW 88
// if Cyrus then
25823: LD_EXP 46
25827: IFFALSE 25841
// Say ( Cyrus , D6c-Cyrus-1 ) ;
25829: LD_EXP 46
25833: PPUSH
25834: LD_STRING D6c-Cyrus-1
25836: PPUSH
25837: CALL_OW 88
// if Bobby then
25841: LD_EXP 45
25845: IFFALSE 25859
// Say ( Bobby , D6c-Bobby-1 ) ;
25847: LD_EXP 45
25851: PPUSH
25852: LD_STRING D6c-Bobby-1
25854: PPUSH
25855: CALL_OW 88
// if Cornel then
25859: LD_EXP 51
25863: IFFALSE 25877
// Say ( Cornel , D6c-Corn-1 ) ;
25865: LD_EXP 51
25869: PPUSH
25870: LD_STRING D6c-Corn-1
25872: PPUSH
25873: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
25877: LD_ADDR_VAR 0 4
25881: PUSH
25882: LD_INT 2
25884: PUSH
25885: LD_INT 22
25887: PUSH
25888: LD_INT 1
25890: PUSH
25891: EMPTY
25892: LIST
25893: LIST
25894: PUSH
25895: LD_INT 22
25897: PUSH
25898: LD_INT 4
25900: PUSH
25901: EMPTY
25902: LIST
25903: LIST
25904: PUSH
25905: EMPTY
25906: LIST
25907: LIST
25908: LIST
25909: PUSH
25910: LD_INT 26
25912: PUSH
25913: LD_INT 1
25915: PUSH
25916: EMPTY
25917: LIST
25918: LIST
25919: PUSH
25920: LD_INT 23
25922: PUSH
25923: LD_INT 1
25925: PUSH
25926: EMPTY
25927: LIST
25928: LIST
25929: PUSH
25930: EMPTY
25931: LIST
25932: LIST
25933: LIST
25934: PPUSH
25935: CALL_OW 69
25939: PUSH
25940: LD_VAR 0 11
25944: PUSH
25945: LD_EXP 40
25949: UNION
25950: PUSH
25951: LD_EXP 61
25955: UNION
25956: DIFF
25957: ST_TO_ADDR
// if tmp2 then
25958: LD_VAR 0 4
25962: IFFALSE 25980
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
25964: LD_VAR 0 4
25968: PUSH
25969: LD_INT 1
25971: ARRAY
25972: PPUSH
25973: LD_STRING D6c-Sol1-1
25975: PPUSH
25976: CALL_OW 88
// if Lisa then
25980: LD_EXP 43
25984: IFFALSE 25998
// Say ( Lisa , D6c-Lisa-1 ) ;
25986: LD_EXP 43
25990: PPUSH
25991: LD_STRING D6c-Lisa-1
25993: PPUSH
25994: CALL_OW 88
// if Gary then
25998: LD_EXP 52
26002: IFFALSE 26016
// Say ( Gary , D6c-Gary-1 ) ;
26004: LD_EXP 52
26008: PPUSH
26009: LD_STRING D6c-Gary-1
26011: PPUSH
26012: CALL_OW 88
// if Donaldson then
26016: LD_EXP 44
26020: IFFALSE 26034
// Say ( Donaldson , D6c-Don-1 ) ;
26022: LD_EXP 44
26026: PPUSH
26027: LD_STRING D6c-Don-1
26029: PPUSH
26030: CALL_OW 88
// if tmp2 > 1 then
26034: LD_VAR 0 4
26038: PUSH
26039: LD_INT 1
26041: GREATER
26042: IFFALSE 26060
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
26044: LD_VAR 0 4
26048: PUSH
26049: LD_INT 2
26051: ARRAY
26052: PPUSH
26053: LD_STRING D6c-Sol2-1
26055: PPUSH
26056: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
26060: LD_VAR 0 11
26064: PPUSH
26065: LD_STRING D6c-Sol3-2
26067: PPUSH
26068: CALL_OW 88
// if IsInUnit ( JMM ) then
26072: LD_EXP 40
26076: PPUSH
26077: CALL_OW 310
26081: IFFALSE 26099
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
26083: LD_EXP 40
26087: PPUSH
26088: CALL_OW 310
26092: PPUSH
26093: CALL_OW 87
26097: GO 26108
// CenterNowOnUnits ( JMM ) ;
26099: LD_EXP 40
26103: PPUSH
26104: CALL_OW 87
// dwait ( 0 0$2 ) ;
26108: LD_INT 70
26110: PPUSH
26111: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
26115: LD_EXP 40
26119: PPUSH
26120: LD_STRING D6c-JMM-2
26122: PPUSH
26123: CALL_OW 88
// DialogueOff ;
26127: CALL_OW 7
// Video ( false ) ;
26131: LD_INT 0
26133: PPUSH
26134: CALL 105238 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
26138: LD_INT 22
26140: PUSH
26141: LD_INT 4
26143: PUSH
26144: EMPTY
26145: LIST
26146: LIST
26147: PPUSH
26148: CALL_OW 69
26152: PPUSH
26153: LD_INT 1
26155: PPUSH
26156: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
26160: LD_INT 4
26162: PPUSH
26163: LD_INT 4
26165: PPUSH
26166: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
26170: LD_ADDR_VAR 0 1
26174: PUSH
26175: LD_INT 4
26177: PPUSH
26178: LD_INT 1
26180: PPUSH
26181: LD_INT 2
26183: PPUSH
26184: CALL 68037 0 3
26188: PUSH
26189: FOR_IN
26190: IFFALSE 26227
// if GetTech ( i , 1 ) <> state_researched then
26192: LD_VAR 0 1
26196: PPUSH
26197: LD_INT 1
26199: PPUSH
26200: CALL_OW 321
26204: PUSH
26205: LD_INT 2
26207: NONEQUAL
26208: IFFALSE 26225
// SetTech ( i , 1 , state_researched ) ;
26210: LD_VAR 0 1
26214: PPUSH
26215: LD_INT 1
26217: PPUSH
26218: LD_INT 2
26220: PPUSH
26221: CALL_OW 322
26225: GO 26189
26227: POP
26228: POP
// missionStage := 6 ;
26229: LD_ADDR_EXP 15
26233: PUSH
26234: LD_INT 6
26236: ST_TO_ADDR
// activeAttacks := true ;
26237: LD_ADDR_EXP 16
26241: PUSH
26242: LD_INT 1
26244: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
26245: LD_STRING M2
26247: PPUSH
26248: CALL_OW 337
// SaveForQuickRestart ;
26252: CALL_OW 22
// wait ( 0 0$40 ) ;
26256: LD_INT 1400
26258: PPUSH
26259: CALL_OW 67
// DialogueOn ;
26263: CALL_OW 6
// SayRadioNoFaceNoName ( Friend , D7-Friend-1 ) ;
26267: LD_EXP 64
26271: PPUSH
26272: LD_STRING D7-Friend-1
26274: PPUSH
26275: CALL 109185 0 2
// Say ( JMM , D7-JMM-1 ) ;
26279: LD_EXP 40
26283: PPUSH
26284: LD_STRING D7-JMM-1
26286: PPUSH
26287: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-2 ) ;
26291: LD_EXP 64
26295: PPUSH
26296: LD_STRING D7-Friend-2
26298: PPUSH
26299: CALL 109185 0 2
// Say ( JMM , D7-JMM-2 ) ;
26303: LD_EXP 40
26307: PPUSH
26308: LD_STRING D7-JMM-2
26310: PPUSH
26311: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-3 ) ;
26315: LD_EXP 64
26319: PPUSH
26320: LD_STRING D7-Friend-3
26322: PPUSH
26323: CALL 109185 0 2
// Say ( JMM , D7-JMM-3 ) ;
26327: LD_EXP 40
26331: PPUSH
26332: LD_STRING D7-JMM-3
26334: PPUSH
26335: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-4 ) ;
26339: LD_EXP 64
26343: PPUSH
26344: LD_STRING D7-Friend-4
26346: PPUSH
26347: CALL 109185 0 2
// Say ( JMM , D7-JMM-4 ) ;
26351: LD_EXP 40
26355: PPUSH
26356: LD_STRING D7-JMM-4
26358: PPUSH
26359: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-5 ) ;
26363: LD_EXP 64
26367: PPUSH
26368: LD_STRING D7-Friend-5
26370: PPUSH
26371: CALL 109185 0 2
// Say ( JMM , D7-JMM-5 ) ;
26375: LD_EXP 40
26379: PPUSH
26380: LD_STRING D7-JMM-5
26382: PPUSH
26383: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-6 ) ;
26387: LD_EXP 64
26391: PPUSH
26392: LD_STRING D7-Friend-6
26394: PPUSH
26395: CALL 109185 0 2
// Say ( JMM , D7-JMM-6 ) ;
26399: LD_EXP 40
26403: PPUSH
26404: LD_STRING D7-JMM-6
26406: PPUSH
26407: CALL_OW 88
// DialogueOff ;
26411: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
26415: LD_STRING Mlegion
26417: PPUSH
26418: CALL_OW 337
// skirmish := true ;
26422: LD_ADDR_EXP 98
26426: PUSH
26427: LD_INT 1
26429: ST_TO_ADDR
// RebuildKozlovFactory ;
26430: CALL 5046 0 0
// end ;
26434: PPOPN 13
26436: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
26437: LD_EXP 20
26441: PUSH
26442: LD_EXP 60
26446: PPUSH
26447: CALL_OW 300
26451: AND
26452: IFFALSE 26494
26454: GO 26456
26456: DISABLE
// begin enable ;
26457: ENABLE
// if IsInUnit ( Powell ) then
26458: LD_EXP 60
26462: PPUSH
26463: CALL_OW 310
26467: IFFALSE 26485
// CenterOnUnits ( IsInUnit ( Powell ) ) else
26469: LD_EXP 60
26473: PPUSH
26474: CALL_OW 310
26478: PPUSH
26479: CALL_OW 85
26483: GO 26494
// CenterOnUnits ( Powell ) ;
26485: LD_EXP 60
26489: PPUSH
26490: CALL_OW 85
// end ;
26494: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
26495: LD_INT 22
26497: PUSH
26498: LD_INT 8
26500: PUSH
26501: EMPTY
26502: LIST
26503: LIST
26504: PUSH
26505: LD_INT 34
26507: PUSH
26508: LD_INT 48
26510: PUSH
26511: EMPTY
26512: LIST
26513: LIST
26514: PUSH
26515: EMPTY
26516: LIST
26517: LIST
26518: PPUSH
26519: CALL_OW 69
26523: IFFALSE 26797
26525: GO 26527
26527: DISABLE
26528: LD_INT 0
26530: PPUSH
26531: PPUSH
// begin if missionStage < 9 then
26532: LD_EXP 15
26536: PUSH
26537: LD_INT 9
26539: LESS
26540: IFFALSE 26550
// missionStage := 9 ;
26542: LD_ADDR_EXP 15
26546: PUSH
26547: LD_INT 9
26549: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
26550: LD_ADDR_VAR 0 1
26554: PUSH
26555: LD_INT 22
26557: PUSH
26558: LD_INT 8
26560: PUSH
26561: EMPTY
26562: LIST
26563: LIST
26564: PUSH
26565: LD_INT 34
26567: PUSH
26568: LD_INT 48
26570: PUSH
26571: EMPTY
26572: LIST
26573: LIST
26574: PUSH
26575: EMPTY
26576: LIST
26577: LIST
26578: PPUSH
26579: CALL_OW 69
26583: PUSH
26584: LD_INT 1
26586: ARRAY
26587: ST_TO_ADDR
// wait ( 0 0$05 ) ;
26588: LD_INT 175
26590: PPUSH
26591: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
26595: LD_EXP 12
26599: PUSH
26600: LD_EXP 3
26604: PUSH
26605: LD_INT 0
26607: PUSH
26608: LD_INT 2
26610: PUSH
26611: EMPTY
26612: LIST
26613: LIST
26614: IN
26615: OR
26616: IFFALSE 26639
// target := [ 68 , 108 , 1 ] else
26618: LD_ADDR_VAR 0 2
26622: PUSH
26623: LD_INT 68
26625: PUSH
26626: LD_INT 108
26628: PUSH
26629: LD_INT 1
26631: PUSH
26632: EMPTY
26633: LIST
26634: LIST
26635: LIST
26636: ST_TO_ADDR
26637: GO 26658
// target := [ 181 , 88 , 2 ] ;
26639: LD_ADDR_VAR 0 2
26643: PUSH
26644: LD_INT 181
26646: PUSH
26647: LD_INT 88
26649: PUSH
26650: LD_INT 2
26652: PUSH
26653: EMPTY
26654: LIST
26655: LIST
26656: LIST
26657: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
26658: LD_VAR 0 1
26662: PPUSH
26663: LD_VAR 0 2
26667: PUSH
26668: LD_INT 1
26670: ARRAY
26671: PPUSH
26672: LD_VAR 0 2
26676: PUSH
26677: LD_INT 2
26679: ARRAY
26680: PPUSH
26681: CALL_OW 176
// if target [ 3 ] = 1 then
26685: LD_VAR 0 2
26689: PUSH
26690: LD_INT 3
26692: ARRAY
26693: PUSH
26694: LD_INT 1
26696: EQUAL
26697: IFFALSE 26713
// SayRadio ( Kurt , D12-Kurt-1 ) else
26699: LD_EXP 62
26703: PPUSH
26704: LD_STRING D12-Kurt-1
26706: PPUSH
26707: CALL_OW 94
26711: GO 26737
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
26713: LD_EXP 62
26717: PPUSH
26718: LD_STRING D12a-Kurt-1
26720: PPUSH
26721: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
26725: LD_EXP 77
26729: PPUSH
26730: LD_STRING D12a-Roth-1
26732: PPUSH
26733: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
26737: LD_INT 350
26739: PPUSH
26740: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
26744: LD_VAR 0 1
26748: PPUSH
26749: LD_INT 22
26751: PUSH
26752: LD_INT 8
26754: PUSH
26755: EMPTY
26756: LIST
26757: LIST
26758: PUSH
26759: LD_INT 23
26761: PUSH
26762: LD_INT 2
26764: PUSH
26765: EMPTY
26766: LIST
26767: LIST
26768: PUSH
26769: LD_INT 30
26771: PUSH
26772: LD_INT 3
26774: PUSH
26775: EMPTY
26776: LIST
26777: LIST
26778: PUSH
26779: EMPTY
26780: LIST
26781: LIST
26782: LIST
26783: PPUSH
26784: CALL_OW 69
26788: PUSH
26789: LD_INT 1
26791: ARRAY
26792: PPUSH
26793: CALL_OW 228
// end ;
26797: PPOPN 2
26799: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
26800: LD_EXP 62
26804: PPUSH
26805: CALL_OW 256
26809: PUSH
26810: LD_INT 999
26812: LESS
26813: PUSH
26814: LD_INT 22
26816: PUSH
26817: LD_INT 8
26819: PUSH
26820: EMPTY
26821: LIST
26822: LIST
26823: PUSH
26824: LD_INT 21
26826: PUSH
26827: LD_INT 1
26829: PUSH
26830: EMPTY
26831: LIST
26832: LIST
26833: PUSH
26834: LD_INT 23
26836: PUSH
26837: LD_INT 2
26839: PUSH
26840: EMPTY
26841: LIST
26842: LIST
26843: PUSH
26844: EMPTY
26845: LIST
26846: LIST
26847: LIST
26848: PPUSH
26849: CALL_OW 69
26853: PUSH
26854: LD_INT 9
26856: PUSH
26857: LD_INT 8
26859: PUSH
26860: LD_INT 7
26862: PUSH
26863: LD_INT 6
26865: PUSH
26866: EMPTY
26867: LIST
26868: LIST
26869: LIST
26870: LIST
26871: PUSH
26872: LD_OWVAR 67
26876: ARRAY
26877: LESSEQUAL
26878: OR
26879: PUSH
26880: LD_INT 22
26882: PUSH
26883: LD_INT 8
26885: PUSH
26886: EMPTY
26887: LIST
26888: LIST
26889: PUSH
26890: LD_INT 34
26892: PUSH
26893: LD_INT 48
26895: PUSH
26896: EMPTY
26897: LIST
26898: LIST
26899: PUSH
26900: EMPTY
26901: LIST
26902: LIST
26903: PPUSH
26904: CALL_OW 69
26908: NOT
26909: AND
26910: PUSH
26911: LD_EXP 62
26915: PPUSH
26916: CALL_OW 302
26920: AND
26921: PUSH
26922: LD_INT 5
26924: PPUSH
26925: LD_INT 22
26927: PUSH
26928: LD_INT 1
26930: PUSH
26931: EMPTY
26932: LIST
26933: LIST
26934: PPUSH
26935: CALL_OW 70
26939: AND
26940: IFFALSE 27684
26942: GO 26944
26944: DISABLE
26945: LD_INT 0
26947: PPUSH
26948: PPUSH
26949: PPUSH
// begin legionDestroyed := true ;
26950: LD_ADDR_EXP 22
26954: PUSH
26955: LD_INT 1
26957: ST_TO_ADDR
// DialogueOn ;
26958: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
26962: LD_EXP 40
26966: PPUSH
26967: LD_STRING D13-JMM-1
26969: PPUSH
26970: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
26974: LD_EXP 62
26978: PPUSH
26979: LD_STRING D13-Kurt-1
26981: PPUSH
26982: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
26986: LD_EXP 40
26990: PPUSH
26991: LD_STRING D13-JMM-2
26993: PPUSH
26994: CALL_OW 88
// if FakeInfo then
26998: LD_EXP 12
27002: IFFALSE 27022
// begin Say ( Kurt , D13-Kurt-2 ) ;
27004: LD_EXP 62
27008: PPUSH
27009: LD_STRING D13-Kurt-2
27011: PPUSH
27012: CALL_OW 88
// DialogueOff ;
27016: CALL_OW 7
// exit ;
27020: GO 27684
// end ; if not KurtStatus then
27022: LD_EXP 3
27026: NOT
27027: IFFALSE 27043
// Say ( Kurt , D13-Kurt-2b ) else
27029: LD_EXP 62
27033: PPUSH
27034: LD_STRING D13-Kurt-2b
27036: PPUSH
27037: CALL_OW 88
27041: GO 27055
// Say ( Kurt , D13-Kurt-2a ) ;
27043: LD_EXP 62
27047: PPUSH
27048: LD_STRING D13-Kurt-2a
27050: PPUSH
27051: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
27055: LD_EXP 40
27059: PPUSH
27060: LD_STRING D13-JMM-3
27062: PPUSH
27063: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
27067: LD_EXP 62
27071: PPUSH
27072: LD_STRING D13-Kurt-3
27074: PPUSH
27075: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
27079: LD_EXP 40
27083: PPUSH
27084: LD_STRING D13-JMM-4
27086: PPUSH
27087: CALL_OW 88
// DialogueOff ;
27091: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
27095: LD_STRING MlegionOut
27097: PPUSH
27098: CALL_OW 337
// MC_Kill ( 3 ) ;
27102: LD_INT 3
27104: PPUSH
27105: CALL 37537 0 1
// KillUnit ( Kozlov ) ;
27109: LD_EXP 63
27113: PPUSH
27114: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
27118: LD_ADDR_VAR 0 1
27122: PUSH
27123: LD_INT 22
27125: PUSH
27126: LD_INT 8
27128: PUSH
27129: EMPTY
27130: LIST
27131: LIST
27132: PUSH
27133: LD_INT 23
27135: PUSH
27136: LD_INT 3
27138: PUSH
27139: EMPTY
27140: LIST
27141: LIST
27142: PUSH
27143: LD_INT 3
27145: PUSH
27146: LD_INT 21
27148: PUSH
27149: LD_INT 33
27151: PUSH
27152: EMPTY
27153: LIST
27154: LIST
27155: PUSH
27156: EMPTY
27157: LIST
27158: LIST
27159: PUSH
27160: EMPTY
27161: LIST
27162: LIST
27163: LIST
27164: PPUSH
27165: CALL_OW 69
27169: PUSH
27170: FOR_IN
27171: IFFALSE 27184
// KillUnit ( i ) ;
27173: LD_VAR 0 1
27177: PPUSH
27178: CALL_OW 66
27182: GO 27170
27184: POP
27185: POP
// ChangeSideFog ( 8 , 1 ) ;
27186: LD_INT 8
27188: PPUSH
27189: LD_INT 1
27191: PPUSH
27192: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
27196: LD_ADDR_VAR 0 2
27200: PUSH
27201: LD_INT 22
27203: PUSH
27204: LD_INT 8
27206: PUSH
27207: EMPTY
27208: LIST
27209: LIST
27210: PUSH
27211: LD_INT 21
27213: PUSH
27214: LD_INT 1
27216: PUSH
27217: EMPTY
27218: LIST
27219: LIST
27220: PUSH
27221: EMPTY
27222: LIST
27223: LIST
27224: PPUSH
27225: CALL_OW 69
27229: PUSH
27230: LD_EXP 63
27234: PUSH
27235: LD_EXP 62
27239: PUSH
27240: EMPTY
27241: LIST
27242: LIST
27243: DIFF
27244: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
27245: LD_VAR 0 2
27249: PUSH
27250: LD_INT 6
27252: PUSH
27253: LD_INT 5
27255: PUSH
27256: LD_INT 4
27258: PUSH
27259: LD_INT 3
27261: PUSH
27262: EMPTY
27263: LIST
27264: LIST
27265: LIST
27266: LIST
27267: PUSH
27268: LD_OWVAR 67
27272: ARRAY
27273: GREATEREQUAL
27274: IFFALSE 27426
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
27276: LD_ADDR_VAR 0 3
27280: PUSH
27281: LD_INT 6
27283: PUSH
27284: LD_INT 5
27286: PUSH
27287: LD_INT 4
27289: PUSH
27290: LD_INT 3
27292: PUSH
27293: EMPTY
27294: LIST
27295: LIST
27296: LIST
27297: LIST
27298: PUSH
27299: LD_OWVAR 67
27303: ARRAY
27304: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
27305: LD_ADDR_VAR 0 1
27309: PUSH
27310: DOUBLE
27311: LD_VAR 0 2
27315: PUSH
27316: LD_VAR 0 3
27320: PUSH
27321: LD_INT 1
27323: PLUS
27324: MINUS
27325: INC
27326: ST_TO_ADDR
27327: LD_INT 1
27329: PUSH
27330: FOR_DOWNTO
27331: IFFALSE 27422
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
27333: LD_ADDR_EXP 38
27337: PUSH
27338: LD_EXP 38
27342: PUSH
27343: LD_VAR 0 2
27347: PUSH
27348: LD_VAR 0 1
27352: ARRAY
27353: ADD
27354: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
27355: LD_VAR 0 2
27359: PUSH
27360: LD_VAR 0 1
27364: ARRAY
27365: PPUSH
27366: CALL_OW 310
27370: IFFALSE 27387
// ComExit ( tmp [ i ] ) ;
27372: LD_VAR 0 2
27376: PUSH
27377: LD_VAR 0 1
27381: ARRAY
27382: PPUSH
27383: CALL 105664 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
27387: LD_VAR 0 2
27391: PUSH
27392: LD_VAR 0 1
27396: ARRAY
27397: PPUSH
27398: LD_INT 34
27400: PUSH
27401: LD_INT 0
27403: PPUSH
27404: LD_INT 6
27406: PPUSH
27407: CALL_OW 12
27411: PLUS
27412: PPUSH
27413: LD_INT 1
27415: PPUSH
27416: CALL_OW 171
// end ;
27420: GO 27330
27422: POP
27423: POP
// end else
27424: GO 27436
// x := tmp ;
27426: LD_ADDR_VAR 0 3
27430: PUSH
27431: LD_VAR 0 2
27435: ST_TO_ADDR
// for i := tmp downto tmp - x do
27436: LD_ADDR_VAR 0 1
27440: PUSH
27441: DOUBLE
27442: LD_VAR 0 2
27446: INC
27447: ST_TO_ADDR
27448: LD_VAR 0 2
27452: PUSH
27453: LD_VAR 0 3
27457: MINUS
27458: PUSH
27459: FOR_DOWNTO
27460: IFFALSE 27514
// begin if IsInUnit ( tmp [ i ] ) then
27462: LD_VAR 0 2
27466: PUSH
27467: LD_VAR 0 1
27471: ARRAY
27472: PPUSH
27473: CALL_OW 310
27477: IFFALSE 27494
// ComExit ( tmp [ i ] ) ;
27479: LD_VAR 0 2
27483: PUSH
27484: LD_VAR 0 1
27488: ARRAY
27489: PPUSH
27490: CALL 105664 0 1
// SetSide ( tmp [ i ] , 1 ) ;
27494: LD_VAR 0 2
27498: PUSH
27499: LD_VAR 0 1
27503: ARRAY
27504: PPUSH
27505: LD_INT 1
27507: PPUSH
27508: CALL_OW 235
// end ;
27512: GO 27459
27514: POP
27515: POP
// wait ( 0 0$0.3 ) ;
27516: LD_INT 10
27518: PPUSH
27519: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
27523: LD_ADDR_VAR 0 1
27527: PUSH
27528: LD_INT 22
27530: PUSH
27531: LD_INT 8
27533: PUSH
27534: EMPTY
27535: LIST
27536: LIST
27537: PUSH
27538: LD_INT 21
27540: PUSH
27541: LD_INT 2
27543: PUSH
27544: EMPTY
27545: LIST
27546: LIST
27547: PUSH
27548: EMPTY
27549: LIST
27550: LIST
27551: PPUSH
27552: CALL_OW 69
27556: PUSH
27557: FOR_IN
27558: IFFALSE 27571
// KillUnit ( i ) ;
27560: LD_VAR 0 1
27564: PPUSH
27565: CALL_OW 66
27569: GO 27557
27571: POP
27572: POP
// SetSide ( Kurt , 1 ) ;
27573: LD_EXP 62
27577: PPUSH
27578: LD_INT 1
27580: PPUSH
27581: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
27585: LD_INT 22
27587: PUSH
27588: LD_INT 8
27590: PUSH
27591: EMPTY
27592: LIST
27593: LIST
27594: PUSH
27595: LD_INT 21
27597: PUSH
27598: LD_INT 3
27600: PUSH
27601: EMPTY
27602: LIST
27603: LIST
27604: PUSH
27605: EMPTY
27606: LIST
27607: LIST
27608: PPUSH
27609: CALL_OW 69
27613: PPUSH
27614: LD_INT 1
27616: PPUSH
27617: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
27621: LD_INT 8
27623: PPUSH
27624: LD_INT 1
27626: PPUSH
27627: LD_INT 1
27629: PPUSH
27630: LD_INT 1
27632: PPUSH
27633: CALL_OW 80
// wait ( 1 1$20 ) ;
27637: LD_INT 2800
27639: PPUSH
27640: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
27644: LD_EXP 64
27648: PPUSH
27649: LD_INT 37
27651: PPUSH
27652: LD_INT 1
27654: PPUSH
27655: LD_INT 0
27657: PPUSH
27658: CALL_OW 48
// wait ( 0 0$1 ) ;
27662: LD_INT 35
27664: PPUSH
27665: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
27669: LD_EXP 64
27673: PPUSH
27674: LD_INT 60
27676: PPUSH
27677: LD_INT 95
27679: PPUSH
27680: CALL_OW 111
// end ;
27684: PPOPN 3
27686: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
27687: LD_EXP 22
27691: NOT
27692: PUSH
27693: LD_INT 22
27695: PUSH
27696: LD_INT 8
27698: PUSH
27699: EMPTY
27700: LIST
27701: LIST
27702: PUSH
27703: LD_INT 21
27705: PUSH
27706: LD_INT 1
27708: PUSH
27709: EMPTY
27710: LIST
27711: LIST
27712: PUSH
27713: EMPTY
27714: LIST
27715: LIST
27716: PPUSH
27717: CALL_OW 69
27721: PUSH
27722: LD_INT 0
27724: EQUAL
27725: AND
27726: IFFALSE 27746
27728: GO 27730
27730: DISABLE
// begin legionDestroyed := true ;
27731: LD_ADDR_EXP 22
27735: PUSH
27736: LD_INT 1
27738: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
27739: LD_STRING MlegionOut
27741: PPUSH
27742: CALL_OW 337
// end ;
27746: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
27747: LD_EXP 38
27751: IFFALSE 27826
27753: GO 27755
27755: DISABLE
27756: LD_INT 0
27758: PPUSH
// begin enable ;
27759: ENABLE
// for i in legionEscapeUnits do
27760: LD_ADDR_VAR 0 1
27764: PUSH
27765: LD_EXP 38
27769: PUSH
27770: FOR_IN
27771: IFFALSE 27824
// begin if IsInArea ( i , legionEscapeArea ) then
27773: LD_VAR 0 1
27777: PPUSH
27778: LD_INT 31
27780: PPUSH
27781: CALL_OW 308
27785: IFFALSE 27798
// RemoveUnit ( i ) else
27787: LD_VAR 0 1
27791: PPUSH
27792: CALL_OW 64
27796: GO 27822
// if not HasTask ( i ) then
27798: LD_VAR 0 1
27802: PPUSH
27803: CALL_OW 314
27807: NOT
27808: IFFALSE 27822
// ComMoveToArea ( i , legionEscapeArea ) ;
27810: LD_VAR 0 1
27814: PPUSH
27815: LD_INT 31
27817: PPUSH
27818: CALL_OW 113
// end ;
27822: GO 27770
27824: POP
27825: POP
// end ;
27826: PPOPN 1
27828: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
27829: LD_INT 1
27831: PPUSH
27832: LD_EXP 64
27836: PPUSH
27837: CALL_OW 292
27841: IFFALSE 28139
27843: GO 27845
27845: DISABLE
27846: LD_INT 0
27848: PPUSH
// begin wait ( 0 0$2 ) ;
27849: LD_INT 70
27851: PPUSH
27852: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27856: LD_EXP 64
27860: PPUSH
27861: CALL_OW 87
// DialogueOn ;
27865: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
27869: LD_EXP 40
27873: PPUSH
27874: LD_STRING D14-JMM-1
27876: PPUSH
27877: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
27881: LD_EXP 64
27885: PPUSH
27886: LD_STRING D14-Friend-1
27888: PPUSH
27889: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
27893: LD_EXP 40
27897: PPUSH
27898: LD_STRING D14-JMM-2
27900: PPUSH
27901: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
27905: LD_EXP 64
27909: PPUSH
27910: LD_STRING D14-Friend-2
27912: PPUSH
27913: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
27917: LD_EXP 40
27921: PPUSH
27922: LD_STRING D14-JMM-3
27924: PPUSH
27925: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
27929: LD_EXP 64
27933: PPUSH
27934: LD_STRING D14-Friend-3
27936: PPUSH
27937: CALL_OW 88
// DialogueOff ;
27941: CALL_OW 7
// dec = Query ( Q14 ) ;
27945: LD_ADDR_VAR 0 1
27949: PUSH
27950: LD_STRING Q14
27952: PPUSH
27953: CALL_OW 97
27957: ST_TO_ADDR
// if dec = 1 then
27958: LD_VAR 0 1
27962: PUSH
27963: LD_INT 1
27965: EQUAL
27966: IFFALSE 28000
// begin DialogueOn ;
27968: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
27972: LD_EXP 40
27976: PPUSH
27977: LD_STRING D14a-JMM-1
27979: PPUSH
27980: CALL_OW 88
// DialogueOff ;
27984: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27988: LD_EXP 64
27992: PPUSH
27993: LD_INT 1
27995: PPUSH
27996: CALL_OW 235
// end ; if dec = 2 then
28000: LD_VAR 0 1
28004: PUSH
28005: LD_INT 2
28007: EQUAL
28008: IFFALSE 28061
// begin DialogueOn ;
28010: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
28014: LD_EXP 40
28018: PPUSH
28019: LD_STRING D14b-JMM-1
28021: PPUSH
28022: CALL_OW 88
// DialogueOff ;
28026: CALL_OW 7
// wait ( 0 0$1 ) ;
28030: LD_INT 35
28032: PPUSH
28033: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
28037: LD_EXP 64
28041: PPUSH
28042: LD_INT 9
28044: PPUSH
28045: LD_INT 2
28047: PPUSH
28048: CALL_OW 111
// AddComHold ( Friend ) ;
28052: LD_EXP 64
28056: PPUSH
28057: CALL_OW 200
// end ; if dec = 3 then
28061: LD_VAR 0 1
28065: PUSH
28066: LD_INT 3
28068: EQUAL
28069: IFFALSE 28139
// begin DialogueOn ;
28071: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
28075: LD_EXP 40
28079: PPUSH
28080: LD_STRING D14c-JMM-1
28082: PPUSH
28083: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
28087: LD_EXP 64
28091: PPUSH
28092: LD_STRING D14c-Friend-1
28094: PPUSH
28095: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
28099: LD_EXP 40
28103: PPUSH
28104: LD_STRING D14c-JMM-2
28106: PPUSH
28107: CALL_OW 88
// DialogueOff ;
28111: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
28115: LD_EXP 64
28119: PPUSH
28120: LD_INT 9
28122: PPUSH
28123: LD_INT 2
28125: PPUSH
28126: CALL_OW 111
// AddComHold ( Friend ) ;
28130: LD_EXP 64
28134: PPUSH
28135: CALL_OW 200
// end ; end ;
28139: PPOPN 1
28141: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
28142: LD_INT 9
28144: PPUSH
28145: LD_INT 2
28147: PPUSH
28148: CALL_OW 428
28152: PUSH
28153: LD_EXP 64
28157: EQUAL
28158: PUSH
28159: LD_EXP 64
28163: PPUSH
28164: CALL_OW 255
28168: PUSH
28169: LD_INT 8
28171: EQUAL
28172: AND
28173: IFFALSE 28187
28175: GO 28177
28177: DISABLE
// RemoveUnit ( Friend ) ;
28178: LD_EXP 64
28182: PPUSH
28183: CALL_OW 64
28187: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
28188: LD_EXP 14
28192: PUSH
28193: LD_INT 31500
28195: GREATEREQUAL
28196: PUSH
28197: LD_EXP 7
28201: AND
28202: PUSH
28203: LD_EXP 2
28207: AND
28208: IFFALSE 28638
28210: GO 28212
28212: DISABLE
28213: LD_INT 0
28215: PPUSH
28216: PPUSH
28217: PPUSH
// begin missionStage := 7 ;
28218: LD_ADDR_EXP 15
28222: PUSH
28223: LD_INT 7
28225: ST_TO_ADDR
// uc_side = 1 ;
28226: LD_ADDR_OWVAR 20
28230: PUSH
28231: LD_INT 1
28233: ST_TO_ADDR
// uc_nation = 1 ;
28234: LD_ADDR_OWVAR 21
28238: PUSH
28239: LD_INT 1
28241: ST_TO_ADDR
// for i = 1 to 5 do
28242: LD_ADDR_VAR 0 1
28246: PUSH
28247: DOUBLE
28248: LD_INT 1
28250: DEC
28251: ST_TO_ADDR
28252: LD_INT 5
28254: PUSH
28255: FOR_TO
28256: IFFALSE 28352
// begin vc_engine = 3 ;
28258: LD_ADDR_OWVAR 39
28262: PUSH
28263: LD_INT 3
28265: ST_TO_ADDR
// vc_control = 3 ;
28266: LD_ADDR_OWVAR 38
28270: PUSH
28271: LD_INT 3
28273: ST_TO_ADDR
// vc_chassis = 3 ;
28274: LD_ADDR_OWVAR 37
28278: PUSH
28279: LD_INT 3
28281: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
28282: LD_ADDR_OWVAR 40
28286: PUSH
28287: LD_INT 5
28289: PUSH
28290: LD_INT 9
28292: PUSH
28293: LD_INT 7
28295: PUSH
28296: EMPTY
28297: LIST
28298: LIST
28299: LIST
28300: PUSH
28301: LD_INT 1
28303: PPUSH
28304: LD_INT 3
28306: PPUSH
28307: CALL_OW 12
28311: ARRAY
28312: ST_TO_ADDR
// veh = CreateVehicle ;
28313: LD_ADDR_VAR 0 2
28317: PUSH
28318: CALL_OW 45
28322: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
28323: LD_VAR 0 2
28327: PPUSH
28328: LD_INT 1
28330: PPUSH
28331: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
28335: LD_VAR 0 2
28339: PPUSH
28340: LD_INT 19
28342: PPUSH
28343: LD_INT 0
28345: PPUSH
28346: CALL_OW 49
// end ;
28350: GO 28255
28352: POP
28353: POP
// vc_engine = 3 ;
28354: LD_ADDR_OWVAR 39
28358: PUSH
28359: LD_INT 3
28361: ST_TO_ADDR
// vc_control = 1 ;
28362: LD_ADDR_OWVAR 38
28366: PUSH
28367: LD_INT 1
28369: ST_TO_ADDR
// vc_chassis = 3 ;
28370: LD_ADDR_OWVAR 37
28374: PUSH
28375: LD_INT 3
28377: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
28378: LD_ADDR_OWVAR 40
28382: PUSH
28383: LD_INT 5
28385: PUSH
28386: LD_INT 9
28388: PUSH
28389: LD_INT 7
28391: PUSH
28392: EMPTY
28393: LIST
28394: LIST
28395: LIST
28396: PUSH
28397: LD_INT 1
28399: PPUSH
28400: LD_INT 3
28402: PPUSH
28403: CALL_OW 12
28407: ARRAY
28408: ST_TO_ADDR
// vehG = CreateVehicle ;
28409: LD_ADDR_VAR 0 3
28413: PUSH
28414: CALL_OW 45
28418: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
28419: LD_VAR 0 3
28423: PPUSH
28424: LD_INT 1
28426: PPUSH
28427: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
28431: LD_VAR 0 3
28435: PPUSH
28436: LD_INT 19
28438: PPUSH
28439: LD_INT 0
28441: PPUSH
28442: CALL_OW 49
// if JMMGirl = 1 then
28446: LD_EXP 7
28450: PUSH
28451: LD_INT 1
28453: EQUAL
28454: IFFALSE 28510
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
28456: LD_ADDR_EXP 41
28460: PUSH
28461: LD_STRING Joan
28463: PPUSH
28464: LD_INT 1
28466: PPUSH
28467: LD_STRING 14_
28469: PPUSH
28470: CALL 67974 0 3
28474: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
28475: LD_EXP 41
28479: PPUSH
28480: LD_VAR 0 3
28484: PPUSH
28485: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28489: LD_VAR 0 3
28493: PPUSH
28494: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
28498: LD_EXP 41
28502: PPUSH
28503: LD_STRING D10BW-Joan-1
28505: PPUSH
28506: CALL_OW 94
// end ; if JMMGirl = 2 then
28510: LD_EXP 7
28514: PUSH
28515: LD_INT 2
28517: EQUAL
28518: IFFALSE 28574
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
28520: LD_ADDR_EXP 43
28524: PUSH
28525: LD_STRING Lisa
28527: PPUSH
28528: LD_INT 1
28530: PPUSH
28531: LD_STRING 14_
28533: PPUSH
28534: CALL 67974 0 3
28538: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
28539: LD_EXP 43
28543: PPUSH
28544: LD_VAR 0 3
28548: PPUSH
28549: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28553: LD_VAR 0 3
28557: PPUSH
28558: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
28562: LD_EXP 43
28566: PPUSH
28567: LD_STRING D10BW-Lisa-1
28569: PPUSH
28570: CALL_OW 94
// end ; if JMMGirl = 3 then
28574: LD_EXP 7
28578: PUSH
28579: LD_INT 3
28581: EQUAL
28582: IFFALSE 28638
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
28584: LD_ADDR_EXP 55
28588: PUSH
28589: LD_STRING Connie
28591: PPUSH
28592: LD_INT 1
28594: PPUSH
28595: LD_STRING 14_
28597: PPUSH
28598: CALL 67974 0 3
28602: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
28603: LD_EXP 55
28607: PPUSH
28608: LD_VAR 0 3
28612: PPUSH
28613: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28617: LD_VAR 0 3
28621: PPUSH
28622: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
28626: LD_EXP 55
28630: PPUSH
28631: LD_STRING D10BW-Con-1
28633: PPUSH
28634: CALL_OW 94
// end ; end ;
28638: PPOPN 3
28640: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
28641: LD_EXP 14
28645: PUSH
28646: LD_INT 94500
28648: GREATEREQUAL
28649: IFFALSE 29061
28651: GO 28653
28653: DISABLE
28654: LD_INT 0
28656: PPUSH
28657: PPUSH
28658: PPUSH
// begin tmp := PrepareStevensSquad ;
28659: LD_ADDR_VAR 0 3
28663: PUSH
28664: CALL 2323 0 0
28668: ST_TO_ADDR
// if not tmp then
28669: LD_VAR 0 3
28673: NOT
28674: IFFALSE 28678
// exit ;
28676: GO 29061
// uc_side := 1 ;
28678: LD_ADDR_OWVAR 20
28682: PUSH
28683: LD_INT 1
28685: ST_TO_ADDR
// uc_nation := 1 ;
28686: LD_ADDR_OWVAR 21
28690: PUSH
28691: LD_INT 1
28693: ST_TO_ADDR
// for i in tmp do
28694: LD_ADDR_VAR 0 1
28698: PUSH
28699: LD_VAR 0 3
28703: PUSH
28704: FOR_IN
28705: IFFALSE 28802
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
28707: LD_INT 3
28709: PPUSH
28710: LD_INT 3
28712: PPUSH
28713: LD_INT 1
28715: PPUSH
28716: LD_INT 5
28718: PUSH
28719: LD_INT 9
28721: PUSH
28722: LD_INT 7
28724: PUSH
28725: EMPTY
28726: LIST
28727: LIST
28728: LIST
28729: PUSH
28730: LD_INT 1
28732: PPUSH
28733: LD_INT 3
28735: PPUSH
28736: CALL_OW 12
28740: ARRAY
28741: PPUSH
28742: LD_INT 40
28744: PPUSH
28745: CALL 72814 0 5
// veh := CreateVehicle ;
28749: LD_ADDR_VAR 0 2
28753: PUSH
28754: CALL_OW 45
28758: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
28759: LD_VAR 0 2
28763: PPUSH
28764: LD_INT 1
28766: PPUSH
28767: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
28771: LD_VAR 0 2
28775: PPUSH
28776: LD_INT 19
28778: PPUSH
28779: LD_INT 0
28781: PPUSH
28782: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
28786: LD_VAR 0 1
28790: PPUSH
28791: LD_VAR 0 2
28795: PPUSH
28796: CALL_OW 52
// end ;
28800: GO 28704
28802: POP
28803: POP
// missionStage := 8 ;
28804: LD_ADDR_EXP 15
28808: PUSH
28809: LD_INT 8
28811: ST_TO_ADDR
// DialogueOn ;
28812: CALL_OW 6
// if Stevens then
28816: LD_EXP 42
28820: IFFALSE 28934
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
28822: LD_EXP 42
28826: PPUSH
28827: CALL_OW 310
28831: PPUSH
28832: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
28836: LD_EXP 42
28840: PPUSH
28841: LD_STRING D8-Huck-1
28843: PPUSH
28844: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
28848: LD_EXP 40
28852: PPUSH
28853: LD_STRING D8-JMM-1
28855: PPUSH
28856: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
28860: LD_EXP 42
28864: PPUSH
28865: LD_STRING D8-Huck-2
28867: PPUSH
28868: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
28872: LD_EXP 40
28876: PPUSH
28877: LD_STRING D8-JMM-2
28879: PPUSH
28880: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
28884: LD_EXP 42
28888: PPUSH
28889: LD_STRING D8-Huck-3
28891: PPUSH
28892: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
28896: LD_EXP 40
28900: PPUSH
28901: LD_STRING D8-JMM-3
28903: PPUSH
28904: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
28908: LD_EXP 42
28912: PPUSH
28913: LD_STRING D8-Huck-4
28915: PPUSH
28916: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
28920: LD_EXP 40
28924: PPUSH
28925: LD_STRING D8-JMM-4
28927: PPUSH
28928: CALL_OW 88
// end else
28932: GO 29044
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
28934: LD_EXP 56
28938: PPUSH
28939: CALL_OW 310
28943: PPUSH
28944: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
28948: LD_EXP 56
28952: PPUSH
28953: LD_STRING D8-Huck-1
28955: PPUSH
28956: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
28960: LD_EXP 40
28964: PPUSH
28965: LD_STRING D8-JMM-1a
28967: PPUSH
28968: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
28972: LD_EXP 56
28976: PPUSH
28977: LD_STRING D8-Huck-2
28979: PPUSH
28980: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
28984: LD_EXP 40
28988: PPUSH
28989: LD_STRING D8-JMM-2
28991: PPUSH
28992: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
28996: LD_EXP 56
29000: PPUSH
29001: LD_STRING D8-Huck-3
29003: PPUSH
29004: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
29008: LD_EXP 40
29012: PPUSH
29013: LD_STRING D8-JMM-3
29015: PPUSH
29016: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
29020: LD_EXP 56
29024: PPUSH
29025: LD_STRING D8-Huck-4
29027: PPUSH
29028: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
29032: LD_EXP 40
29036: PPUSH
29037: LD_STRING D8-JMM-4
29039: PPUSH
29040: CALL_OW 88
// end ; DialogueOff ;
29044: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
29048: LD_INT 25
29050: PPUSH
29051: LD_INT 1
29053: PPUSH
29054: LD_INT 1
29056: PPUSH
29057: CALL_OW 322
// end ;
29061: PPOPN 3
29063: END
// every 0 0$1 trigger IsOk ( sewiVeh ) and See ( 1 , sewiVeh ) do
29064: LD_EXP 73
29068: PPUSH
29069: CALL_OW 302
29073: PUSH
29074: LD_INT 1
29076: PPUSH
29077: LD_EXP 73
29081: PPUSH
29082: CALL_OW 292
29086: AND
29087: IFFALSE 29338
29089: GO 29091
29091: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
29092: LD_EXP 73
29096: PPUSH
29097: CALL_OW 87
// DialogueOn ;
29101: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
29105: LD_EXP 40
29109: PPUSH
29110: LD_STRING D10nB-JMM-1
29112: PPUSH
29113: CALL_OW 88
// if BurlakStatus = 1 then
29117: LD_EXP 9
29121: PUSH
29122: LD_INT 1
29124: EQUAL
29125: IFFALSE 29139
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
29127: LD_EXP 72
29131: PPUSH
29132: LD_STRING D10nB-Vse-1a
29134: PPUSH
29135: CALL_OW 94
// end ; if BurlakStatus = 0 then
29139: LD_EXP 9
29143: PUSH
29144: LD_INT 0
29146: EQUAL
29147: IFFALSE 29161
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
29149: LD_EXP 72
29153: PPUSH
29154: LD_STRING D10nB-Vse-1
29156: PPUSH
29157: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
29161: LD_EXP 40
29165: PPUSH
29166: LD_STRING D10nB-JMM-2
29168: PPUSH
29169: CALL_OW 88
// if KappaStatus then
29173: LD_EXP 2
29177: IFFALSE 29191
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
29179: LD_EXP 72
29183: PPUSH
29184: LD_STRING D10nB-Vse-5a
29186: PPUSH
29187: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
29191: LD_EXP 2
29195: NOT
29196: PUSH
29197: LD_EXP 6
29201: PUSH
29202: LD_INT 0
29204: EQUAL
29205: AND
29206: IFFALSE 29334
// begin if JMMGirl = 1 then
29208: LD_EXP 7
29212: PUSH
29213: LD_INT 1
29215: EQUAL
29216: IFFALSE 29266
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
29218: LD_EXP 72
29222: PPUSH
29223: LD_STRING D10nB-Vse-2
29225: PPUSH
29226: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
29230: LD_EXP 40
29234: PPUSH
29235: LD_STRING D10nB-JMM-3
29237: PPUSH
29238: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
29242: LD_EXP 72
29246: PPUSH
29247: LD_STRING D10nB-Vse-3
29249: PPUSH
29250: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
29254: LD_EXP 40
29258: PPUSH
29259: LD_STRING D10nB-JMM-4
29261: PPUSH
29262: CALL_OW 88
// end ; if JMMGirl = 2 then
29266: LD_EXP 7
29270: PUSH
29271: LD_INT 2
29273: EQUAL
29274: IFFALSE 29300
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
29276: LD_EXP 72
29280: PPUSH
29281: LD_STRING D10nB-Vse-4
29283: PPUSH
29284: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
29288: LD_EXP 40
29292: PPUSH
29293: LD_STRING D10nB-JMM-5
29295: PPUSH
29296: CALL_OW 88
// end ; if JMMGirl = 3 then
29300: LD_EXP 7
29304: PUSH
29305: LD_INT 3
29307: EQUAL
29308: IFFALSE 29334
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
29310: LD_EXP 72
29314: PPUSH
29315: LD_STRING D10nB-Vse-5
29317: PPUSH
29318: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
29322: LD_EXP 40
29326: PPUSH
29327: LD_STRING D10nB-JMM-6
29329: PPUSH
29330: CALL_OW 88
// end ; end ; DialogueOff ;
29334: CALL_OW 7
// end ;
29338: END
// every 0 0$1 trigger missionTime >= 55 55$00 and IsOk ( Kovalyuk ) and IsOk ( ru_depot2 ) do var tmp ;
29339: LD_EXP 14
29343: PUSH
29344: LD_INT 115500
29346: GREATEREQUAL
29347: PUSH
29348: LD_EXP 67
29352: PPUSH
29353: CALL_OW 302
29357: AND
29358: PUSH
29359: LD_INT 267
29361: PPUSH
29362: CALL_OW 302
29366: AND
29367: IFFALSE 29743
29369: GO 29371
29371: DISABLE
29372: LD_INT 0
29374: PPUSH
// begin missionStage := 10 ;
29375: LD_ADDR_EXP 15
29379: PUSH
29380: LD_INT 10
29382: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
29383: LD_ADDR_VAR 0 1
29387: PUSH
29388: LD_INT 22
29390: PUSH
29391: LD_INT 1
29393: PUSH
29394: EMPTY
29395: LIST
29396: LIST
29397: PUSH
29398: LD_INT 23
29400: PUSH
29401: LD_INT 1
29403: PUSH
29404: EMPTY
29405: LIST
29406: LIST
29407: PUSH
29408: LD_INT 26
29410: PUSH
29411: LD_INT 1
29413: PUSH
29414: EMPTY
29415: LIST
29416: LIST
29417: PUSH
29418: LD_INT 3
29420: PUSH
29421: LD_INT 25
29423: PUSH
29424: LD_INT 12
29426: PUSH
29427: EMPTY
29428: LIST
29429: LIST
29430: PUSH
29431: EMPTY
29432: LIST
29433: LIST
29434: PUSH
29435: LD_INT 3
29437: PUSH
29438: LD_INT 25
29440: PUSH
29441: LD_INT 16
29443: PUSH
29444: EMPTY
29445: LIST
29446: LIST
29447: PUSH
29448: EMPTY
29449: LIST
29450: LIST
29451: PUSH
29452: EMPTY
29453: LIST
29454: LIST
29455: LIST
29456: LIST
29457: LIST
29458: PPUSH
29459: CALL_OW 69
29463: PUSH
29464: LD_EXP 40
29468: PUSH
29469: LD_EXP 62
29473: PUSH
29474: LD_EXP 42
29478: PUSH
29479: LD_EXP 56
29483: PUSH
29484: LD_EXP 43
29488: PUSH
29489: LD_EXP 44
29493: PUSH
29494: LD_EXP 45
29498: PUSH
29499: LD_EXP 46
29503: PUSH
29504: LD_EXP 47
29508: PUSH
29509: LD_EXP 48
29513: PUSH
29514: LD_EXP 49
29518: PUSH
29519: LD_EXP 50
29523: PUSH
29524: LD_EXP 51
29528: PUSH
29529: LD_EXP 52
29533: PUSH
29534: LD_EXP 53
29538: PUSH
29539: LD_EXP 54
29543: PUSH
29544: EMPTY
29545: LIST
29546: LIST
29547: LIST
29548: LIST
29549: LIST
29550: LIST
29551: LIST
29552: LIST
29553: LIST
29554: LIST
29555: LIST
29556: LIST
29557: LIST
29558: LIST
29559: LIST
29560: LIST
29561: DIFF
29562: ST_TO_ADDR
// if not tmp and Brown then
29563: LD_VAR 0 1
29567: NOT
29568: PUSH
29569: LD_EXP 48
29573: AND
29574: IFFALSE 29589
// tmp := [ Brown ] ;
29576: LD_ADDR_VAR 0 1
29580: PUSH
29581: LD_EXP 48
29585: PUSH
29586: EMPTY
29587: LIST
29588: ST_TO_ADDR
// DialogueOn ;
29589: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
29593: LD_VAR 0 1
29597: PUSH
29598: LD_INT 1
29600: ARRAY
29601: PPUSH
29602: LD_STRING D11-Sol1-1
29604: PPUSH
29605: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
29609: LD_EXP 66
29613: PPUSH
29614: LD_STRING D11-Pla-1
29616: PPUSH
29617: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
29621: LD_EXP 67
29625: PPUSH
29626: LD_STRING D11-Kov-1
29628: PPUSH
29629: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
29633: LD_EXP 66
29637: PPUSH
29638: LD_STRING D11-Pla-2
29640: PPUSH
29641: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
29645: LD_VAR 0 1
29649: PUSH
29650: LD_INT 1
29652: ARRAY
29653: PPUSH
29654: LD_STRING D11-Sol1-2
29656: PPUSH
29657: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
29661: LD_EXP 40
29665: PPUSH
29666: LD_STRING D11-JMM-2
29668: PPUSH
29669: CALL_OW 88
// DialogueOff ;
29673: CALL_OW 7
// allowBehemothConstruct := true ;
29677: LD_ADDR_EXP 25
29681: PUSH
29682: LD_INT 1
29684: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
29685: LD_STRING M4
29687: PPUSH
29688: CALL_OW 337
// BuildBehemoths ;
29692: CALL 8056 0 0
// repeat wait ( 15 15$00 ) ;
29696: LD_INT 31500
29698: PPUSH
29699: CALL_OW 67
// if behemothDestroyedBeforeFinish then
29703: LD_EXP 27
29707: IFFALSE 29711
// break ;
29709: GO 29743
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
29711: LD_INT 267
29713: PPUSH
29714: CALL_OW 274
29718: PPUSH
29719: LD_INT 1
29721: PPUSH
29722: CALL_OW 275
29726: PUSH
29727: LD_INT 1000
29729: GREATEREQUAL
29730: IFFALSE 29736
// BuildBehemoths ;
29732: CALL 8056 0 0
// until not behemothBuilders ;
29736: LD_EXP 75
29740: NOT
29741: IFFALSE 29696
// end ;
29743: PPOPN 1
29745: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
29746: LD_EXP 75
29750: NOT
29751: PUSH
29752: LD_EXP 28
29756: NOT
29757: AND
29758: PUSH
29759: LD_EXP 25
29763: AND
29764: IFFALSE 29784
29766: GO 29768
29768: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
29769: LD_STRING M4a
29771: PPUSH
29772: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
29776: LD_ADDR_EXP 27
29780: PUSH
29781: LD_INT 1
29783: ST_TO_ADDR
// end ;
29784: END
// every 0 0$1 trigger behemothDone do
29785: LD_EXP 28
29789: IFFALSE 29801
29791: GO 29793
29793: DISABLE
// ChangeMissionObjectives ( M4b ) ;
29794: LD_STRING M4b
29796: PPUSH
29797: CALL_OW 337
29801: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
29802: LD_EXP 29
29806: NOT
29807: IFFALSE 30003
29809: GO 29811
29811: DISABLE
29812: LD_INT 0
29814: PPUSH
29815: PPUSH
// begin enable ;
29816: ENABLE
// tmp := GetBehemoths ( 3 ) ;
29817: LD_ADDR_VAR 0 1
29821: PUSH
29822: LD_INT 3
29824: PPUSH
29825: CALL 105327 0 1
29829: ST_TO_ADDR
// if not tmp and not behemothDone then
29830: LD_VAR 0 1
29834: NOT
29835: PUSH
29836: LD_EXP 28
29840: NOT
29841: AND
29842: IFFALSE 29878
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
29844: LD_ADDR_VAR 0 1
29848: PUSH
29849: LD_INT 22
29851: PUSH
29852: LD_INT 3
29854: PUSH
29855: EMPTY
29856: LIST
29857: LIST
29858: PUSH
29859: LD_INT 30
29861: PUSH
29862: LD_INT 37
29864: PUSH
29865: EMPTY
29866: LIST
29867: LIST
29868: PUSH
29869: EMPTY
29870: LIST
29871: LIST
29872: PPUSH
29873: CALL_OW 69
29877: ST_TO_ADDR
// if not tmp then
29878: LD_VAR 0 1
29882: NOT
29883: IFFALSE 29887
// exit ;
29885: GO 30003
// for i in tmp do
29887: LD_ADDR_VAR 0 2
29891: PUSH
29892: LD_VAR 0 1
29896: PUSH
29897: FOR_IN
29898: IFFALSE 30001
// if See ( 1 , i ) then
29900: LD_INT 1
29902: PPUSH
29903: LD_VAR 0 2
29907: PPUSH
29908: CALL_OW 292
29912: IFFALSE 29999
// begin if GetType ( i ) = unit_building then
29914: LD_VAR 0 2
29918: PPUSH
29919: CALL_OW 247
29923: PUSH
29924: LD_INT 3
29926: EQUAL
29927: IFFALSE 29965
// begin disable ;
29929: DISABLE
// CenterNowOnUnits ( i ) ;
29930: LD_VAR 0 2
29934: PPUSH
29935: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
29939: LD_EXP 40
29943: PPUSH
29944: LD_STRING D17a-JMM-1
29946: PPUSH
29947: CALL_OW 88
// seeBehemoth := true ;
29951: LD_ADDR_EXP 29
29955: PUSH
29956: LD_INT 1
29958: ST_TO_ADDR
// exit ;
29959: POP
29960: POP
29961: GO 30003
// end else
29963: GO 29999
// begin disable ;
29965: DISABLE
// CenterNowOnUnits ( i ) ;
29966: LD_VAR 0 2
29970: PPUSH
29971: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
29975: LD_EXP 40
29979: PPUSH
29980: LD_STRING D17b-JMM-1
29982: PPUSH
29983: CALL_OW 88
// seeBehemoth := true ;
29987: LD_ADDR_EXP 29
29991: PUSH
29992: LD_INT 1
29994: ST_TO_ADDR
// exit ;
29995: POP
29996: POP
29997: GO 30003
// end ; end ;
29999: GO 29897
30001: POP
30002: POP
// end ;
30003: PPOPN 2
30005: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
30006: LD_EXP 14
30010: PUSH
30011: LD_INT 123200
30013: GREATEREQUAL
30014: IFFALSE 31214
30016: GO 30018
30018: DISABLE
30019: LD_INT 0
30021: PPUSH
30022: PPUSH
30023: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
30024: LD_INT 2
30026: PPUSH
30027: LD_INT 23
30029: PUSH
30030: LD_INT 3
30032: PUSH
30033: LD_INT 3
30035: PUSH
30036: LD_INT 48
30038: PUSH
30039: EMPTY
30040: LIST
30041: LIST
30042: LIST
30043: LIST
30044: PUSH
30045: EMPTY
30046: LIST
30047: PPUSH
30048: CALL 61548 0 2
// repeat wait ( 0 0$1 ) ;
30052: LD_INT 35
30054: PPUSH
30055: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
30059: LD_INT 22
30061: PUSH
30062: LD_INT 3
30064: PUSH
30065: EMPTY
30066: LIST
30067: LIST
30068: PUSH
30069: LD_INT 34
30071: PUSH
30072: LD_INT 48
30074: PUSH
30075: EMPTY
30076: LIST
30077: LIST
30078: PUSH
30079: EMPTY
30080: LIST
30081: LIST
30082: PPUSH
30083: CALL_OW 69
30087: IFFALSE 30052
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
30089: LD_ADDR_VAR 0 1
30093: PUSH
30094: LD_INT 22
30096: PUSH
30097: LD_INT 3
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PUSH
30104: LD_INT 34
30106: PUSH
30107: LD_INT 48
30109: PUSH
30110: EMPTY
30111: LIST
30112: LIST
30113: PUSH
30114: EMPTY
30115: LIST
30116: LIST
30117: PPUSH
30118: CALL_OW 69
30122: PUSH
30123: LD_INT 1
30125: ARRAY
30126: ST_TO_ADDR
// missionStage := 12 ;
30127: LD_ADDR_EXP 15
30131: PUSH
30132: LD_INT 12
30134: ST_TO_ADDR
// platonovHasBomb := true ;
30135: LD_ADDR_EXP 30
30139: PUSH
30140: LD_INT 1
30142: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
30143: LD_VAR 0 1
30147: PPUSH
30148: LD_INT 181
30150: PPUSH
30151: LD_INT 86
30153: PPUSH
30154: CALL_OW 171
// AddComHold ( bomb ) ;
30158: LD_VAR 0 1
30162: PPUSH
30163: CALL_OW 200
// wait ( 0 0$10 ) ;
30167: LD_INT 350
30169: PPUSH
30170: CALL_OW 67
// DialogueOn ;
30174: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
30178: LD_EXP 66
30182: PPUSH
30183: LD_STRING D15-Pla-1
30185: PPUSH
30186: CALL_OW 94
// dec = Query ( Q15a ) ;
30190: LD_ADDR_VAR 0 2
30194: PUSH
30195: LD_STRING Q15a
30197: PPUSH
30198: CALL_OW 97
30202: ST_TO_ADDR
// if dec = 1 then
30203: LD_VAR 0 2
30207: PUSH
30208: LD_INT 1
30210: EQUAL
30211: IFFALSE 30234
// begin Say ( JMM , D15a-JMM-1 ) ;
30213: LD_EXP 40
30217: PPUSH
30218: LD_STRING D15a-JMM-1
30220: PPUSH
30221: CALL_OW 88
// YouLost ( Surrender ) ;
30225: LD_STRING Surrender
30227: PPUSH
30228: CALL_OW 104
// exit ;
30232: GO 31214
// end ; if dec = 2 then
30234: LD_VAR 0 2
30238: PUSH
30239: LD_INT 2
30241: EQUAL
30242: IFFALSE 30311
// begin Say ( JMM , D15b-JMM-1 ) ;
30244: LD_EXP 40
30248: PPUSH
30249: LD_STRING D15b-JMM-1
30251: PPUSH
30252: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
30256: LD_EXP 66
30260: PPUSH
30261: LD_STRING D15b-Pla-1
30263: PPUSH
30264: CALL_OW 94
// DialogueOff ;
30268: CALL_OW 7
// wait ( 3 3$00 ) ;
30272: LD_INT 6300
30274: PPUSH
30275: CALL_OW 67
// DialogueOn ;
30279: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
30283: LD_EXP 40
30287: PPUSH
30288: LD_STRING D15d-JMM-1a
30290: PPUSH
30291: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
30295: LD_EXP 66
30299: PPUSH
30300: LD_STRING D15d-Pla-1
30302: PPUSH
30303: CALL_OW 94
// DialogueOff ;
30307: CALL_OW 7
// end ; if dec = 3 then
30311: LD_VAR 0 2
30315: PUSH
30316: LD_INT 3
30318: EQUAL
30319: IFFALSE 30373
// begin Say ( JMM , D15c-JMM-1 ) ;
30321: LD_EXP 40
30325: PPUSH
30326: LD_STRING D15c-JMM-1
30328: PPUSH
30329: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
30333: LD_EXP 66
30337: PPUSH
30338: LD_STRING D15c-Pla-1
30340: PPUSH
30341: CALL_OW 94
// DialogueOff ;
30345: CALL_OW 7
// wait ( 0 0$15 ) ;
30349: LD_INT 525
30351: PPUSH
30352: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
30356: LD_VAR 0 1
30360: PPUSH
30361: LD_INT 60
30363: PPUSH
30364: LD_INT 95
30366: PPUSH
30367: CALL_OW 116
// exit ;
30371: GO 31214
// end ; if dec = 4 then
30373: LD_VAR 0 2
30377: PUSH
30378: LD_INT 4
30380: EQUAL
30381: IFFALSE 30411
// begin Say ( JMM , D15d-JMM-1 ) ;
30383: LD_EXP 40
30387: PPUSH
30388: LD_STRING D15d-JMM-1
30390: PPUSH
30391: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
30395: LD_EXP 66
30399: PPUSH
30400: LD_STRING D15d-Pla-1
30402: PPUSH
30403: CALL_OW 94
// DialogueOff ;
30407: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30411: LD_EXP 64
30415: PPUSH
30416: CALL_OW 302
30420: PUSH
30421: LD_EXP 64
30425: PPUSH
30426: CALL_OW 255
30430: PUSH
30431: LD_INT 1
30433: EQUAL
30434: AND
30435: PUSH
30436: LD_INT 22
30438: PUSH
30439: LD_INT 1
30441: PUSH
30442: EMPTY
30443: LIST
30444: LIST
30445: PUSH
30446: LD_INT 34
30448: PUSH
30449: LD_INT 8
30451: PUSH
30452: EMPTY
30453: LIST
30454: LIST
30455: PUSH
30456: EMPTY
30457: LIST
30458: LIST
30459: PPUSH
30460: CALL_OW 69
30464: NOT
30465: AND
30466: IFFALSE 31115
// begin SetSide ( Friend , 8 ) ;
30468: LD_EXP 64
30472: PPUSH
30473: LD_INT 8
30475: PPUSH
30476: CALL_OW 235
// if IsInUnit ( Friend ) then
30480: LD_EXP 64
30484: PPUSH
30485: CALL_OW 310
30489: IFFALSE 30500
// ComExitBuilding ( Friend ) ;
30491: LD_EXP 64
30495: PPUSH
30496: CALL_OW 122
// if IsDriver ( Friend ) then
30500: LD_EXP 64
30504: PPUSH
30505: CALL 102883 0 1
30509: IFFALSE 30520
// ComExitVehicle ( Friend ) ;
30511: LD_EXP 64
30515: PPUSH
30516: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
30520: LD_EXP 64
30524: PPUSH
30525: LD_INT 9
30527: PPUSH
30528: LD_INT 2
30530: PPUSH
30531: CALL_OW 171
// wait ( 0 0$05 ) ;
30535: LD_INT 175
30537: PPUSH
30538: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
30542: LD_EXP 64
30546: PPUSH
30547: CALL_OW 87
// DialogueOn ;
30551: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
30555: LD_EXP 40
30559: PPUSH
30560: LD_STRING D16-JMM-1
30562: PPUSH
30563: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
30567: LD_EXP 64
30571: PPUSH
30572: LD_STRING D16-Friend-1
30574: PPUSH
30575: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
30579: LD_EXP 40
30583: PPUSH
30584: LD_STRING D16-JMM-2
30586: PPUSH
30587: CALL_OW 88
// DialogueOff ;
30591: CALL_OW 7
// SetSide ( Friend , 1 ) ;
30595: LD_EXP 64
30599: PPUSH
30600: LD_INT 1
30602: PPUSH
30603: CALL_OW 235
// ComHold ( Friend ) ;
30607: LD_EXP 64
30611: PPUSH
30612: CALL_OW 140
// wait ( 0 0$20 ) ;
30616: LD_INT 700
30618: PPUSH
30619: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
30623: LD_EXP 64
30627: PPUSH
30628: LD_INT 9
30630: PPUSH
30631: LD_INT 2
30633: PPUSH
30634: CALL_OW 297
30638: PUSH
30639: LD_INT 30
30641: LESS
30642: IFFALSE 30711
// begin SetSide ( Friend , 8 ) ;
30644: LD_EXP 64
30648: PPUSH
30649: LD_INT 8
30651: PPUSH
30652: CALL_OW 235
// if IsInUnit ( Friend ) then
30656: LD_EXP 64
30660: PPUSH
30661: CALL_OW 310
30665: IFFALSE 30676
// ComExitBuilding ( Friend ) ;
30667: LD_EXP 64
30671: PPUSH
30672: CALL_OW 122
// if IsDriver ( Friend ) then
30676: LD_EXP 64
30680: PPUSH
30681: CALL 102883 0 1
30685: IFFALSE 30696
// ComExitVehicle ( Friend ) ;
30687: LD_EXP 64
30691: PPUSH
30692: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
30696: LD_EXP 64
30700: PPUSH
30701: LD_INT 9
30703: PPUSH
30704: LD_INT 2
30706: PPUSH
30707: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
30711: LD_INT 1050
30713: PPUSH
30714: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30718: LD_INT 22
30720: PUSH
30721: LD_INT 1
30723: PUSH
30724: EMPTY
30725: LIST
30726: LIST
30727: PUSH
30728: LD_INT 34
30730: PUSH
30731: LD_INT 8
30733: PUSH
30734: EMPTY
30735: LIST
30736: LIST
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: PPUSH
30742: CALL_OW 69
30746: NOT
30747: IFFALSE 31093
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
30749: LD_ADDR_VAR 0 3
30753: PUSH
30754: LD_INT 22
30756: PUSH
30757: LD_INT 1
30759: PUSH
30760: EMPTY
30761: LIST
30762: LIST
30763: PUSH
30764: LD_INT 26
30766: PUSH
30767: LD_INT 1
30769: PUSH
30770: EMPTY
30771: LIST
30772: LIST
30773: PUSH
30774: LD_INT 3
30776: PUSH
30777: LD_INT 25
30779: PUSH
30780: LD_INT 12
30782: PUSH
30783: EMPTY
30784: LIST
30785: LIST
30786: PUSH
30787: LD_INT 25
30789: PUSH
30790: LD_INT 16
30792: PUSH
30793: EMPTY
30794: LIST
30795: LIST
30796: PUSH
30797: EMPTY
30798: LIST
30799: LIST
30800: LIST
30801: PUSH
30802: EMPTY
30803: LIST
30804: LIST
30805: LIST
30806: PPUSH
30807: CALL_OW 69
30811: PUSH
30812: LD_EXP 40
30816: PUSH
30817: LD_EXP 42
30821: PUSH
30822: LD_EXP 56
30826: PUSH
30827: LD_EXP 43
30831: PUSH
30832: LD_EXP 44
30836: PUSH
30837: LD_EXP 45
30841: PUSH
30842: LD_EXP 46
30846: PUSH
30847: LD_EXP 47
30851: PUSH
30852: LD_EXP 48
30856: PUSH
30857: LD_EXP 49
30861: PUSH
30862: LD_EXP 50
30866: PUSH
30867: LD_EXP 51
30871: PUSH
30872: LD_EXP 52
30876: PUSH
30877: LD_EXP 53
30881: PUSH
30882: LD_EXP 54
30886: PUSH
30887: EMPTY
30888: LIST
30889: LIST
30890: LIST
30891: LIST
30892: LIST
30893: LIST
30894: LIST
30895: LIST
30896: LIST
30897: LIST
30898: LIST
30899: LIST
30900: LIST
30901: LIST
30902: LIST
30903: DIFF
30904: ST_TO_ADDR
// DialogueOn ;
30905: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
30909: LD_EXP 66
30913: PPUSH
30914: LD_STRING D16a-Pla-1
30916: PPUSH
30917: CALL_OW 94
// if Stevens then
30921: LD_EXP 42
30925: IFFALSE 30941
// Say ( Stevens , D16a-Huck-1 ) else
30927: LD_EXP 42
30931: PPUSH
30932: LD_STRING D16a-Huck-1
30934: PPUSH
30935: CALL_OW 88
30939: GO 30983
// if Baker then
30941: LD_EXP 56
30945: IFFALSE 30961
// Say ( Baker , D16a-Huck-1 ) else
30947: LD_EXP 56
30951: PPUSH
30952: LD_STRING D16a-Huck-1
30954: PPUSH
30955: CALL_OW 88
30959: GO 30983
// if tmp then
30961: LD_VAR 0 3
30965: IFFALSE 30983
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
30967: LD_VAR 0 3
30971: PUSH
30972: LD_INT 1
30974: ARRAY
30975: PPUSH
30976: LD_STRING D16a-Sol1-1
30978: PPUSH
30979: CALL_OW 88
// if GetSide ( Friend ) = 8 then
30983: LD_EXP 64
30987: PPUSH
30988: CALL_OW 255
30992: PUSH
30993: LD_INT 8
30995: EQUAL
30996: IFFALSE 31012
// Say ( JMM , D16a-JMM-1 ) else
30998: LD_EXP 40
31002: PPUSH
31003: LD_STRING D16a-JMM-1
31005: PPUSH
31006: CALL_OW 88
31010: GO 31072
// begin Say ( JMM , D16a-JMM-1a ) ;
31012: LD_EXP 40
31016: PPUSH
31017: LD_STRING D16a-JMM-1a
31019: PPUSH
31020: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
31024: LD_EXP 64
31028: PPUSH
31029: LD_STRING D16a-Friend-1
31031: PPUSH
31032: CALL_OW 88
// ComExitBuilding ( Friend ) ;
31036: LD_EXP 64
31040: PPUSH
31041: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
31045: LD_EXP 64
31049: PPUSH
31050: LD_INT 191
31052: PPUSH
31053: LD_INT 103
31055: PPUSH
31056: CALL_OW 171
// SetSide ( Friend , 3 ) ;
31060: LD_EXP 64
31064: PPUSH
31065: LD_INT 3
31067: PPUSH
31068: CALL_OW 235
// end ; DialogueOff ;
31072: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
31076: LD_VAR 0 1
31080: PPUSH
31081: LD_INT 60
31083: PPUSH
31084: LD_INT 95
31086: PPUSH
31087: CALL_OW 116
// end else
31091: GO 31113
// begin DialogueOn ;
31093: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
31097: LD_EXP 66
31101: PPUSH
31102: LD_STRING D16c-Pla-1
31104: PPUSH
31105: CALL_OW 94
// DialogueOff ;
31109: CALL_OW 7
// end ; end else
31113: GO 31214
// begin wait ( 3 3$00 ) ;
31115: LD_INT 6300
31117: PPUSH
31118: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
31122: LD_INT 22
31124: PUSH
31125: LD_INT 1
31127: PUSH
31128: EMPTY
31129: LIST
31130: LIST
31131: PUSH
31132: LD_INT 34
31134: PUSH
31135: LD_INT 8
31137: PUSH
31138: EMPTY
31139: LIST
31140: LIST
31141: PUSH
31142: EMPTY
31143: LIST
31144: LIST
31145: PPUSH
31146: CALL_OW 69
31150: NOT
31151: IFFALSE 31194
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
31153: LD_EXP 66
31157: PPUSH
31158: LD_STRING D16b-Pla-1
31160: PPUSH
31161: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
31165: LD_EXP 40
31169: PPUSH
31170: LD_STRING D16b-JMM-1
31172: PPUSH
31173: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
31177: LD_VAR 0 1
31181: PPUSH
31182: LD_INT 60
31184: PPUSH
31185: LD_INT 95
31187: PPUSH
31188: CALL_OW 116
// end else
31192: GO 31214
// begin DialogueOn ;
31194: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
31198: LD_EXP 66
31202: PPUSH
31203: LD_STRING D16c-Pla-1
31205: PPUSH
31206: CALL_OW 94
// DialogueOff ;
31210: CALL_OW 7
// end ; end ; end ;
31214: PPOPN 3
31216: END
// every 0 0$10 trigger ( GetTech ( tech_SibFiss , 1 ) = state_researched or missionTime >= 60 60$00 ) and not allianceDestroyed and IsOk ( Roth ) do var dec ;
31217: LD_INT 25
31219: PPUSH
31220: LD_INT 1
31222: PPUSH
31223: CALL_OW 321
31227: PUSH
31228: LD_INT 2
31230: EQUAL
31231: PUSH
31232: LD_EXP 14
31236: PUSH
31237: LD_INT 126000
31239: GREATEREQUAL
31240: OR
31241: PUSH
31242: LD_EXP 23
31246: NOT
31247: AND
31248: PUSH
31249: LD_EXP 77
31253: PPUSH
31254: CALL_OW 302
31258: AND
31259: IFFALSE 31617
31261: GO 31263
31263: DISABLE
31264: LD_INT 0
31266: PPUSH
// begin missionStage := 11 ;
31267: LD_ADDR_EXP 15
31271: PUSH
31272: LD_INT 11
31274: ST_TO_ADDR
// DialogueOn ;
31275: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
31279: LD_EXP 77
31283: PPUSH
31284: LD_STRING D9-Roth-1
31286: PPUSH
31287: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
31291: LD_EXP 40
31295: PPUSH
31296: LD_STRING D9-JMM-1
31298: PPUSH
31299: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
31303: LD_EXP 77
31307: PPUSH
31308: LD_STRING D9-Roth-2
31310: PPUSH
31311: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
31315: LD_EXP 77
31319: PPUSH
31320: LD_STRING D9-Roth-2a
31322: PPUSH
31323: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
31327: LD_EXP 66
31331: PPUSH
31332: LD_STRING D9-Pla-2
31334: PPUSH
31335: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
31339: LD_EXP 77
31343: PPUSH
31344: LD_STRING D9-Roth-3
31346: PPUSH
31347: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
31351: LD_EXP 66
31355: PPUSH
31356: LD_STRING D9-Pla-3
31358: PPUSH
31359: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
31363: LD_EXP 77
31367: PPUSH
31368: LD_STRING D9-Roth-4
31370: PPUSH
31371: CALL_OW 94
// dec := Query ( Q9 ) ;
31375: LD_ADDR_VAR 0 1
31379: PUSH
31380: LD_STRING Q9
31382: PPUSH
31383: CALL_OW 97
31387: ST_TO_ADDR
// if dec = 1 then
31388: LD_VAR 0 1
31392: PUSH
31393: LD_INT 1
31395: EQUAL
31396: IFFALSE 31410
// SayRadio ( Roth , D9a-Roth-1 ) ;
31398: LD_EXP 77
31402: PPUSH
31403: LD_STRING D9a-Roth-1
31405: PPUSH
31406: CALL_OW 94
// if dec = 2 then
31410: LD_VAR 0 1
31414: PUSH
31415: LD_INT 2
31417: EQUAL
31418: IFFALSE 31444
// begin Say ( JMM , D9b-JMM-1 ) ;
31420: LD_EXP 40
31424: PPUSH
31425: LD_STRING D9b-JMM-1
31427: PPUSH
31428: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
31432: LD_EXP 77
31436: PPUSH
31437: LD_STRING D9b-Roth-1
31439: PPUSH
31440: CALL_OW 94
// end ; if dec = 3 then
31444: LD_VAR 0 1
31448: PUSH
31449: LD_INT 3
31451: EQUAL
31452: IFFALSE 31514
// begin Say ( JMM , D9c-JMM-1 ) ;
31454: LD_EXP 40
31458: PPUSH
31459: LD_STRING D9c-JMM-1
31461: PPUSH
31462: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
31466: LD_EXP 77
31470: PPUSH
31471: LD_STRING D9c-Roth-1
31473: PPUSH
31474: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
31478: LD_EXP 40
31482: PPUSH
31483: LD_STRING D9c-JMM-2
31485: PPUSH
31486: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
31490: LD_EXP 77
31494: PPUSH
31495: LD_STRING D9c-Roth-2
31497: PPUSH
31498: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
31502: LD_EXP 40
31506: PPUSH
31507: LD_STRING D9c-JMM-3
31509: PPUSH
31510: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
31514: LD_EXP 77
31518: PPUSH
31519: LD_STRING D9c-Roth-3
31521: PPUSH
31522: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
31526: LD_EXP 77
31530: PPUSH
31531: LD_STRING D9cont-Roth-1
31533: PPUSH
31534: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
31538: LD_EXP 40
31542: PPUSH
31543: LD_STRING D9cont-JMM-1
31545: PPUSH
31546: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
31550: LD_EXP 77
31554: PPUSH
31555: LD_STRING D9cont-Roth-2
31557: PPUSH
31558: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
31562: LD_EXP 40
31566: PPUSH
31567: LD_STRING D9cont-JMM-2
31569: PPUSH
31570: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
31574: LD_EXP 77
31578: PPUSH
31579: LD_STRING D9cont-Roth-3
31581: PPUSH
31582: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
31586: LD_EXP 40
31590: PPUSH
31591: LD_STRING D9cont-JMM-3
31593: PPUSH
31594: CALL_OW 88
// DialogueOff ;
31598: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
31602: LD_STRING M3
31604: PPUSH
31605: CALL_OW 337
// allianceActive := true ;
31609: LD_ADDR_EXP 31
31613: PUSH
31614: LD_INT 1
31616: ST_TO_ADDR
// end ;
31617: PPOPN 1
31619: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
31620: LD_INT 1
31622: PPUSH
31623: LD_INT 126
31625: PPUSH
31626: CALL_OW 292
31630: PUSH
31631: LD_EXP 66
31635: PPUSH
31636: CALL_OW 310
31640: AND
31641: IFFALSE 31721
31643: GO 31645
31645: DISABLE
31646: LD_INT 0
31648: PPUSH
// begin ComExitBuilding ( Platonov ) ;
31649: LD_EXP 66
31653: PPUSH
31654: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
31658: LD_ADDR_VAR 0 1
31662: PUSH
31663: LD_INT 4
31665: PPUSH
31666: LD_INT 22
31668: PUSH
31669: LD_INT 1
31671: PUSH
31672: EMPTY
31673: LIST
31674: LIST
31675: PPUSH
31676: CALL_OW 70
31680: PPUSH
31681: LD_EXP 66
31685: PPUSH
31686: CALL_OW 74
31690: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
31691: LD_EXP 66
31695: PPUSH
31696: LD_VAR 0 1
31700: PUSH
31701: LD_INT 1
31703: ARRAY
31704: PPUSH
31705: CALL_OW 175
// SayRadio ( Platonov , D18-Pla-1 ) ;
31709: LD_EXP 66
31713: PPUSH
31714: LD_STRING D18-Pla-1
31716: PPUSH
31717: CALL_OW 94
// end ;
31721: PPOPN 1
31723: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
31724: LD_EXP 66
31728: PPUSH
31729: CALL_OW 301
31733: PUSH
31734: LD_EXP 69
31738: PPUSH
31739: CALL_OW 301
31743: AND
31744: PUSH
31745: LD_INT 22
31747: PUSH
31748: LD_INT 3
31750: PUSH
31751: EMPTY
31752: LIST
31753: LIST
31754: PUSH
31755: LD_INT 21
31757: PUSH
31758: LD_INT 1
31760: PUSH
31761: EMPTY
31762: LIST
31763: LIST
31764: PUSH
31765: LD_INT 50
31767: PUSH
31768: EMPTY
31769: LIST
31770: PUSH
31771: EMPTY
31772: LIST
31773: LIST
31774: LIST
31775: PPUSH
31776: CALL_OW 69
31780: PUSH
31781: LD_INT 7
31783: PUSH
31784: LD_INT 8
31786: PUSH
31787: LD_INT 9
31789: PUSH
31790: LD_INT 10
31792: PUSH
31793: EMPTY
31794: LIST
31795: LIST
31796: LIST
31797: LIST
31798: PUSH
31799: LD_OWVAR 67
31803: ARRAY
31804: LESS
31805: AND
31806: IFFALSE 32605
31808: GO 31810
31810: DISABLE
31811: LD_INT 0
31813: PPUSH
31814: PPUSH
31815: PPUSH
31816: PPUSH
// begin MC_Kill ( 2 ) ;
31817: LD_INT 2
31819: PPUSH
31820: CALL 37537 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
31824: LD_INT 1
31826: PPUSH
31827: LD_INT 3
31829: PPUSH
31830: LD_INT 1
31832: PPUSH
31833: LD_INT 1
31835: PPUSH
31836: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
31840: LD_ADDR_VAR 0 2
31844: PUSH
31845: LD_INT 22
31847: PUSH
31848: LD_INT 3
31850: PUSH
31851: EMPTY
31852: LIST
31853: LIST
31854: PUSH
31855: LD_INT 21
31857: PUSH
31858: LD_INT 1
31860: PUSH
31861: EMPTY
31862: LIST
31863: LIST
31864: PUSH
31865: LD_INT 50
31867: PUSH
31868: EMPTY
31869: LIST
31870: PUSH
31871: LD_INT 26
31873: PUSH
31874: LD_INT 1
31876: PUSH
31877: EMPTY
31878: LIST
31879: LIST
31880: PUSH
31881: EMPTY
31882: LIST
31883: LIST
31884: LIST
31885: LIST
31886: PPUSH
31887: CALL_OW 69
31891: ST_TO_ADDR
// if not tmp then
31892: LD_VAR 0 2
31896: NOT
31897: IFFALSE 31953
// begin uc_side = 3 ;
31899: LD_ADDR_OWVAR 20
31903: PUSH
31904: LD_INT 3
31906: ST_TO_ADDR
// uc_nation = 3 ;
31907: LD_ADDR_OWVAR 21
31911: PUSH
31912: LD_INT 3
31914: ST_TO_ADDR
// hc_name =  ;
31915: LD_ADDR_OWVAR 26
31919: PUSH
31920: LD_STRING 
31922: ST_TO_ADDR
// hc_gallery =  ;
31923: LD_ADDR_OWVAR 33
31927: PUSH
31928: LD_STRING 
31930: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
31931: LD_INT 1
31933: PPUSH
31934: LD_INT 10
31936: PPUSH
31937: CALL_OW 381
// tmp = CreateHuman ;
31941: LD_ADDR_VAR 0 2
31945: PUSH
31946: CALL_OW 44
31950: ST_TO_ADDR
// end else
31951: GO 31967
// tmp := tmp [ 1 ] ;
31953: LD_ADDR_VAR 0 2
31957: PUSH
31958: LD_VAR 0 2
31962: PUSH
31963: LD_INT 1
31965: ARRAY
31966: ST_TO_ADDR
// DialogueOn ;
31967: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
31971: LD_VAR 0 2
31975: PPUSH
31976: LD_STRING DSurrenderRussians-RSol1-1a
31978: PPUSH
31979: CALL_OW 94
// DialogueOff ;
31983: CALL_OW 7
// russianDestroyed := true ;
31987: LD_ADDR_EXP 21
31991: PUSH
31992: LD_INT 1
31994: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
31995: LD_ADDR_VAR 0 1
31999: PUSH
32000: LD_INT 22
32002: PUSH
32003: LD_INT 6
32005: PUSH
32006: EMPTY
32007: LIST
32008: LIST
32009: PPUSH
32010: CALL_OW 69
32014: PUSH
32015: FOR_IN
32016: IFFALSE 32029
// KillUnit ( i ) ;
32018: LD_VAR 0 1
32022: PPUSH
32023: CALL_OW 66
32027: GO 32015
32029: POP
32030: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
32031: LD_INT 22
32033: PUSH
32034: LD_INT 3
32036: PUSH
32037: EMPTY
32038: LIST
32039: LIST
32040: PUSH
32041: LD_INT 21
32043: PUSH
32044: LD_INT 1
32046: PUSH
32047: EMPTY
32048: LIST
32049: LIST
32050: PUSH
32051: EMPTY
32052: LIST
32053: LIST
32054: PPUSH
32055: CALL_OW 69
32059: PPUSH
32060: CALL_OW 122
// wait ( 0 0$1 ) ;
32064: LD_INT 35
32066: PPUSH
32067: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
32071: LD_INT 22
32073: PUSH
32074: LD_INT 3
32076: PUSH
32077: EMPTY
32078: LIST
32079: LIST
32080: PUSH
32081: LD_INT 21
32083: PUSH
32084: LD_INT 1
32086: PUSH
32087: EMPTY
32088: LIST
32089: LIST
32090: PUSH
32091: EMPTY
32092: LIST
32093: LIST
32094: PPUSH
32095: CALL_OW 69
32099: PPUSH
32100: LD_INT 25
32102: PPUSH
32103: CALL_OW 173
// wait ( 0 0$35 ) ;
32107: LD_INT 1225
32109: PPUSH
32110: CALL_OW 67
// PrepareOmarInvasion ;
32114: CALL 15040 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
32118: LD_ADDR_VAR 0 2
32122: PUSH
32123: LD_EXP 95
32127: PPUSH
32128: CALL_OW 250
32132: PUSH
32133: LD_EXP 95
32137: PPUSH
32138: CALL_OW 251
32142: PUSH
32143: EMPTY
32144: LIST
32145: LIST
32146: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
32147: LD_VAR 0 2
32151: PUSH
32152: LD_INT 1
32154: ARRAY
32155: PPUSH
32156: LD_VAR 0 2
32160: PUSH
32161: LD_INT 2
32163: ARRAY
32164: PPUSH
32165: LD_INT 1
32167: PPUSH
32168: LD_INT 8
32170: NEG
32171: PPUSH
32172: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
32176: LD_EXP 95
32180: PPUSH
32181: CALL_OW 87
// DialogueOn ;
32185: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
32189: LD_EXP 40
32193: PPUSH
32194: LD_STRING D19-JMM-1
32196: PPUSH
32197: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Kurt , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
32201: LD_ADDR_VAR 0 3
32205: PUSH
32206: LD_INT 22
32208: PUSH
32209: LD_INT 1
32211: PUSH
32212: EMPTY
32213: LIST
32214: LIST
32215: PUSH
32216: LD_INT 26
32218: PUSH
32219: LD_INT 1
32221: PUSH
32222: EMPTY
32223: LIST
32224: LIST
32225: PUSH
32226: LD_INT 2
32228: PUSH
32229: LD_INT 25
32231: PUSH
32232: LD_INT 1
32234: PUSH
32235: EMPTY
32236: LIST
32237: LIST
32238: PUSH
32239: LD_INT 25
32241: PUSH
32242: LD_INT 2
32244: PUSH
32245: EMPTY
32246: LIST
32247: LIST
32248: PUSH
32249: LD_INT 25
32251: PUSH
32252: LD_INT 3
32254: PUSH
32255: EMPTY
32256: LIST
32257: LIST
32258: PUSH
32259: LD_INT 25
32261: PUSH
32262: LD_INT 4
32264: PUSH
32265: EMPTY
32266: LIST
32267: LIST
32268: PUSH
32269: LD_INT 25
32271: PUSH
32272: LD_INT 5
32274: PUSH
32275: EMPTY
32276: LIST
32277: LIST
32278: PUSH
32279: LD_INT 25
32281: PUSH
32282: LD_INT 8
32284: PUSH
32285: EMPTY
32286: LIST
32287: LIST
32288: PUSH
32289: EMPTY
32290: LIST
32291: LIST
32292: LIST
32293: LIST
32294: LIST
32295: LIST
32296: LIST
32297: PUSH
32298: EMPTY
32299: LIST
32300: LIST
32301: LIST
32302: PPUSH
32303: CALL_OW 69
32307: PUSH
32308: LD_EXP 40
32312: PUSH
32313: LD_EXP 41
32317: PUSH
32318: LD_EXP 62
32322: PUSH
32323: LD_EXP 42
32327: PUSH
32328: LD_EXP 43
32332: PUSH
32333: LD_EXP 44
32337: PUSH
32338: LD_EXP 45
32342: PUSH
32343: LD_EXP 46
32347: PUSH
32348: LD_EXP 47
32352: PUSH
32353: LD_EXP 48
32357: PUSH
32358: LD_EXP 49
32362: PUSH
32363: LD_EXP 50
32367: PUSH
32368: LD_EXP 51
32372: PUSH
32373: LD_EXP 52
32377: PUSH
32378: LD_EXP 53
32382: PUSH
32383: LD_EXP 54
32387: PUSH
32388: LD_EXP 55
32392: PUSH
32393: LD_EXP 56
32397: PUSH
32398: EMPTY
32399: LIST
32400: LIST
32401: LIST
32402: LIST
32403: LIST
32404: LIST
32405: LIST
32406: LIST
32407: LIST
32408: LIST
32409: LIST
32410: LIST
32411: LIST
32412: LIST
32413: LIST
32414: LIST
32415: LIST
32416: LIST
32417: DIFF
32418: ST_TO_ADDR
// if tmp2 then
32419: LD_VAR 0 3
32423: IFFALSE 32441
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
32425: LD_VAR 0 3
32429: PUSH
32430: LD_INT 1
32432: ARRAY
32433: PPUSH
32434: LD_STRING D19-Sol1-1
32436: PPUSH
32437: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
32441: LD_EXP 40
32445: PPUSH
32446: LD_STRING D19-JMM-2
32448: PPUSH
32449: CALL_OW 88
// DialogueOff ;
32453: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
32457: LD_VAR 0 2
32461: PUSH
32462: LD_INT 1
32464: ARRAY
32465: PPUSH
32466: LD_VAR 0 2
32470: PUSH
32471: LD_INT 2
32473: ARRAY
32474: PPUSH
32475: LD_INT 1
32477: PPUSH
32478: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
32482: LD_STRING M5
32484: PPUSH
32485: CALL_OW 337
// omarOnMotherLode := false ;
32489: LD_ADDR_VAR 0 4
32493: PUSH
32494: LD_INT 0
32496: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
32497: LD_INT 35
32499: PPUSH
32500: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
32504: LD_EXP 95
32508: PPUSH
32509: LD_INT 215
32511: PPUSH
32512: LD_INT 100
32514: PPUSH
32515: CALL_OW 297
32519: PUSH
32520: LD_INT 10
32522: LESS
32523: PUSH
32524: LD_VAR 0 4
32528: NOT
32529: AND
32530: IFFALSE 32564
// begin omarOnMotherLode := true ;
32532: LD_ADDR_VAR 0 4
32536: PUSH
32537: LD_INT 1
32539: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
32540: LD_EXP 40
32544: PPUSH
32545: LD_STRING D19b-JMM-1
32547: PPUSH
32548: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
32552: LD_EXP 95
32556: PPUSH
32557: LD_STRING DOmarContam-Omar-1
32559: PPUSH
32560: CALL_OW 88
// end ; until IsDead ( Omar ) ;
32564: LD_EXP 95
32568: PPUSH
32569: CALL_OW 301
32573: IFFALSE 32497
// Say ( JMM , D19a-JMM-1 ) ;
32575: LD_EXP 40
32579: PPUSH
32580: LD_STRING D19a-JMM-1
32582: PPUSH
32583: CALL_OW 88
// if Heike then
32587: LD_EXP 96
32591: IFFALSE 32605
// Say ( Heike , D19a-Hke-1 ) ;
32593: LD_EXP 96
32597: PPUSH
32598: LD_STRING D19a-Hke-1
32600: PPUSH
32601: CALL_OW 88
// end ;
32605: PPOPN 4
32607: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
32608: LD_INT 22
32610: PUSH
32611: LD_INT 3
32613: PUSH
32614: EMPTY
32615: LIST
32616: LIST
32617: PUSH
32618: LD_INT 21
32620: PUSH
32621: LD_INT 1
32623: PUSH
32624: EMPTY
32625: LIST
32626: LIST
32627: PUSH
32628: EMPTY
32629: LIST
32630: LIST
32631: PPUSH
32632: CALL_OW 69
32636: PUSH
32637: LD_EXP 21
32641: AND
32642: IFFALSE 32710
32644: GO 32646
32646: DISABLE
32647: LD_INT 0
32649: PPUSH
32650: PPUSH
// begin enable ;
32651: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
32652: LD_ADDR_VAR 0 2
32656: PUSH
32657: LD_INT 25
32659: PPUSH
32660: LD_INT 22
32662: PUSH
32663: LD_INT 3
32665: PUSH
32666: EMPTY
32667: LIST
32668: LIST
32669: PPUSH
32670: CALL_OW 70
32674: ST_TO_ADDR
// if not tmp then
32675: LD_VAR 0 2
32679: NOT
32680: IFFALSE 32684
// exit ;
32682: GO 32710
// for i in tmp do
32684: LD_ADDR_VAR 0 1
32688: PUSH
32689: LD_VAR 0 2
32693: PUSH
32694: FOR_IN
32695: IFFALSE 32708
// RemoveUnit ( i ) ;
32697: LD_VAR 0 1
32701: PPUSH
32702: CALL_OW 64
32706: GO 32694
32708: POP
32709: POP
// end ;
32710: PPOPN 2
32712: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
32713: LD_INT 22
32715: PUSH
32716: LD_INT 7
32718: PUSH
32719: EMPTY
32720: LIST
32721: LIST
32722: PUSH
32723: LD_INT 21
32725: PUSH
32726: LD_INT 1
32728: PUSH
32729: EMPTY
32730: LIST
32731: LIST
32732: PUSH
32733: EMPTY
32734: LIST
32735: LIST
32736: PPUSH
32737: CALL_OW 69
32741: PUSH
32742: LD_INT 6
32744: LESS
32745: IFFALSE 33213
32747: GO 32749
32749: DISABLE
32750: LD_INT 0
32752: PPUSH
32753: PPUSH
// begin MC_Kill ( 1 ) ;
32754: LD_INT 1
32756: PPUSH
32757: CALL 37537 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
32761: LD_INT 7
32763: PPUSH
32764: LD_INT 1
32766: PPUSH
32767: LD_INT 1
32769: PPUSH
32770: LD_INT 1
32772: PPUSH
32773: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
32777: LD_ADDR_VAR 0 1
32781: PUSH
32782: LD_INT 22
32784: PUSH
32785: LD_INT 7
32787: PUSH
32788: EMPTY
32789: LIST
32790: LIST
32791: PUSH
32792: LD_INT 26
32794: PUSH
32795: LD_INT 1
32797: PUSH
32798: EMPTY
32799: LIST
32800: LIST
32801: PUSH
32802: EMPTY
32803: LIST
32804: LIST
32805: PPUSH
32806: CALL_OW 69
32810: PUSH
32811: LD_EXP 77
32815: DIFF
32816: ST_TO_ADDR
// if tmp then
32817: LD_VAR 0 1
32821: IFFALSE 32839
// tmp := tmp [ 1 ] else
32823: LD_ADDR_VAR 0 1
32827: PUSH
32828: LD_VAR 0 1
32832: PUSH
32833: LD_INT 1
32835: ARRAY
32836: ST_TO_ADDR
32837: GO 32875
// begin uc_side := 7 ;
32839: LD_ADDR_OWVAR 20
32843: PUSH
32844: LD_INT 7
32846: ST_TO_ADDR
// uc_nation := 1 ;
32847: LD_ADDR_OWVAR 21
32851: PUSH
32852: LD_INT 1
32854: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
32855: LD_INT 1
32857: PPUSH
32858: LD_INT 8
32860: PPUSH
32861: CALL_OW 384
// tmp := CreateHuman ;
32865: LD_ADDR_VAR 0 1
32869: PUSH
32870: CALL_OW 44
32874: ST_TO_ADDR
// end ; DialogueOn ;
32875: CALL_OW 6
// if IsOK ( Roth ) then
32879: LD_EXP 77
32883: PPUSH
32884: CALL_OW 302
32888: IFFALSE 32902
// Say ( JMM , DAb-JMM-1 ) ;
32890: LD_EXP 40
32894: PPUSH
32895: LD_STRING DAb-JMM-1
32897: PPUSH
32898: CALL_OW 88
// if IsOK ( Roth ) then
32902: LD_EXP 77
32906: PPUSH
32907: CALL_OW 302
32911: IFFALSE 32935
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
32913: LD_EXP 77
32917: PPUSH
32918: LD_STRING DSurrenderAlliance-Roth-1
32920: PPUSH
32921: CALL_OW 88
// RothCaptured := true ;
32925: LD_ADDR_EXP 33
32929: PUSH
32930: LD_INT 1
32932: ST_TO_ADDR
// end else
32933: GO 32947
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
32935: LD_VAR 0 1
32939: PPUSH
32940: LD_STRING DSurrenderAlliance-Sci1-1
32942: PPUSH
32943: CALL_OW 88
// DialogueOff ;
32947: CALL_OW 7
// allianceDestroyed := true ;
32951: LD_ADDR_EXP 23
32955: PUSH
32956: LD_INT 1
32958: ST_TO_ADDR
// if capturedUnit = 0 then
32959: LD_EXP 34
32963: PUSH
32964: LD_INT 0
32966: EQUAL
32967: IFFALSE 32976
// SetAchievement ( ACH_ALLIANCE ) ;
32969: LD_STRING ACH_ALLIANCE
32971: PPUSH
32972: CALL_OW 543
// if trueAmericans then
32976: LD_EXP 35
32980: IFFALSE 33056
// begin if trueAmericans = 1 then
32982: LD_EXP 35
32986: PUSH
32987: LD_INT 1
32989: EQUAL
32990: IFFALSE 33006
// Say ( JMM , DAb-JMM-1a ) else
32992: LD_EXP 40
32996: PPUSH
32997: LD_STRING DAb-JMM-1a
32999: PPUSH
33000: CALL_OW 88
33004: GO 33018
// Say ( JMM , DAb-JMM-1b ) ;
33006: LD_EXP 40
33010: PPUSH
33011: LD_STRING DAb-JMM-1b
33013: PPUSH
33014: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
33018: LD_EXP 35
33022: PPUSH
33023: CALL_OW 87
// for i in trueAmericans do
33027: LD_ADDR_VAR 0 2
33031: PUSH
33032: LD_EXP 35
33036: PUSH
33037: FOR_IN
33038: IFFALSE 33054
// SetSide ( i , 1 ) ;
33040: LD_VAR 0 2
33044: PPUSH
33045: LD_INT 1
33047: PPUSH
33048: CALL_OW 235
33052: GO 33037
33054: POP
33055: POP
// end ; repeat wait ( 0 0$1 ) ;
33056: LD_INT 35
33058: PPUSH
33059: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
33063: LD_ADDR_VAR 0 2
33067: PUSH
33068: LD_INT 22
33070: PUSH
33071: LD_INT 7
33073: PUSH
33074: EMPTY
33075: LIST
33076: LIST
33077: PUSH
33078: LD_INT 21
33080: PUSH
33081: LD_INT 1
33083: PUSH
33084: EMPTY
33085: LIST
33086: LIST
33087: PUSH
33088: EMPTY
33089: LIST
33090: LIST
33091: PPUSH
33092: CALL_OW 69
33096: PUSH
33097: FOR_IN
33098: IFFALSE 33180
// begin if IsInUnit ( i ) then
33100: LD_VAR 0 2
33104: PPUSH
33105: CALL_OW 310
33109: IFFALSE 33120
// ComExitBuilding ( i ) ;
33111: LD_VAR 0 2
33115: PPUSH
33116: CALL_OW 122
// if IsDriver ( i ) then
33120: LD_VAR 0 2
33124: PPUSH
33125: CALL 102883 0 1
33129: IFFALSE 33140
// ComExitVehicle ( i ) ;
33131: LD_VAR 0 2
33135: PPUSH
33136: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
33140: LD_VAR 0 2
33144: PPUSH
33145: LD_INT 26
33147: PPUSH
33148: CALL_OW 308
33152: NOT
33153: IFFALSE 33169
// AddComMoveToArea ( i , allianceEscapeArea ) else
33155: LD_VAR 0 2
33159: PPUSH
33160: LD_INT 26
33162: PPUSH
33163: CALL_OW 173
33167: GO 33178
// RemoveUnit ( i ) ;
33169: LD_VAR 0 2
33173: PPUSH
33174: CALL_OW 64
// end ;
33178: GO 33097
33180: POP
33181: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
33182: LD_INT 22
33184: PUSH
33185: LD_INT 7
33187: PUSH
33188: EMPTY
33189: LIST
33190: LIST
33191: PUSH
33192: LD_INT 21
33194: PUSH
33195: LD_INT 1
33197: PUSH
33198: EMPTY
33199: LIST
33200: LIST
33201: PUSH
33202: EMPTY
33203: LIST
33204: LIST
33205: PPUSH
33206: CALL_OW 69
33210: NOT
33211: IFFALSE 33056
// end ;
33213: PPOPN 2
33215: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
33216: LD_INT 0
33218: PPUSH
33219: PPUSH
// if not unit then
33220: LD_VAR 0 1
33224: NOT
33225: IFFALSE 33229
// exit ;
33227: GO 34737
// DoNotAttack ( 7 , unit ) ;
33229: LD_INT 7
33231: PPUSH
33232: LD_VAR 0 1
33236: PPUSH
33237: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
33241: LD_VAR 0 1
33245: PPUSH
33246: LD_INT 260
33248: PPUSH
33249: LD_INT 235
33251: PPUSH
33252: LD_INT 3
33254: PPUSH
33255: LD_INT 1
33257: PPUSH
33258: CALL_OW 483
// SetSide ( unit , 4 ) ;
33262: LD_VAR 0 1
33266: PPUSH
33267: LD_INT 4
33269: PPUSH
33270: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
33274: LD_ADDR_EXP 34
33278: PUSH
33279: LD_EXP 34
33283: PUSH
33284: LD_INT 1
33286: PLUS
33287: ST_TO_ADDR
// wait ( 0 0$2 ) ;
33288: LD_INT 70
33290: PPUSH
33291: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
33295: LD_INT 260
33297: PPUSH
33298: LD_INT 235
33300: PPUSH
33301: LD_INT 1
33303: PPUSH
33304: LD_INT 8
33306: NEG
33307: PPUSH
33308: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
33312: LD_VAR 0 1
33316: PPUSH
33317: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
33321: LD_VAR 0 1
33325: PPUSH
33326: LD_EXP 77
33330: PPUSH
33331: CALL_OW 119
// DialogueOn ;
33335: CALL_OW 6
// case unit of JMM :
33339: LD_VAR 0 1
33343: PUSH
33344: LD_EXP 40
33348: DOUBLE
33349: EQUAL
33350: IFTRUE 33354
33352: GO 33369
33354: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
33355: LD_EXP 40
33359: PPUSH
33360: LD_STRING DA1-JMM-1
33362: PPUSH
33363: CALL_OW 91
33367: GO 33811
33369: LD_EXP 41
33373: DOUBLE
33374: EQUAL
33375: IFTRUE 33379
33377: GO 33394
33379: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
33380: LD_EXP 41
33384: PPUSH
33385: LD_STRING DA1-Joan-1
33387: PPUSH
33388: CALL_OW 91
33392: GO 33811
33394: LD_EXP 43
33398: DOUBLE
33399: EQUAL
33400: IFTRUE 33404
33402: GO 33419
33404: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
33405: LD_EXP 43
33409: PPUSH
33410: LD_STRING DA1-Lisa-1
33412: PPUSH
33413: CALL_OW 91
33417: GO 33811
33419: LD_EXP 44
33423: DOUBLE
33424: EQUAL
33425: IFTRUE 33429
33427: GO 33444
33429: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
33430: LD_EXP 44
33434: PPUSH
33435: LD_STRING DA1-Don-1
33437: PPUSH
33438: CALL_OW 91
33442: GO 33811
33444: LD_EXP 51
33448: DOUBLE
33449: EQUAL
33450: IFTRUE 33454
33452: GO 33469
33454: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
33455: LD_EXP 51
33459: PPUSH
33460: LD_STRING DA1-Corn-1
33462: PPUSH
33463: CALL_OW 91
33467: GO 33811
33469: LD_EXP 47
33473: DOUBLE
33474: EQUAL
33475: IFTRUE 33479
33477: GO 33494
33479: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
33480: LD_EXP 47
33484: PPUSH
33485: LD_STRING DA1-Den-1
33487: PPUSH
33488: CALL_OW 91
33492: GO 33811
33494: LD_EXP 45
33498: DOUBLE
33499: EQUAL
33500: IFTRUE 33504
33502: GO 33519
33504: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
33505: LD_EXP 45
33509: PPUSH
33510: LD_STRING DA1-Bobby-1
33512: PPUSH
33513: CALL_OW 91
33517: GO 33811
33519: LD_EXP 49
33523: DOUBLE
33524: EQUAL
33525: IFTRUE 33529
33527: GO 33544
33529: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
33530: LD_EXP 49
33534: PPUSH
33535: LD_STRING DA1-Glad-1
33537: PPUSH
33538: CALL_OW 91
33542: GO 33811
33544: LD_EXP 46
33548: DOUBLE
33549: EQUAL
33550: IFTRUE 33554
33552: GO 33569
33554: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
33555: LD_EXP 46
33559: PPUSH
33560: LD_STRING DA1-Cyrus-1
33562: PPUSH
33563: CALL_OW 91
33567: GO 33811
33569: LD_EXP 42
33573: DOUBLE
33574: EQUAL
33575: IFTRUE 33579
33577: GO 33594
33579: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
33580: LD_EXP 42
33584: PPUSH
33585: LD_STRING DA1-Huck-1
33587: PPUSH
33588: CALL_OW 91
33592: GO 33811
33594: LD_EXP 56
33598: DOUBLE
33599: EQUAL
33600: IFTRUE 33604
33602: GO 33619
33604: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
33605: LD_EXP 56
33609: PPUSH
33610: LD_STRING DA1-Huck-1
33612: PPUSH
33613: CALL_OW 91
33617: GO 33811
33619: LD_EXP 48
33623: DOUBLE
33624: EQUAL
33625: IFTRUE 33629
33627: GO 33644
33629: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
33630: LD_EXP 48
33634: PPUSH
33635: LD_STRING DA1-Brown-1
33637: PPUSH
33638: CALL_OW 91
33642: GO 33811
33644: LD_EXP 52
33648: DOUBLE
33649: EQUAL
33650: IFTRUE 33654
33652: GO 33669
33654: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
33655: LD_EXP 52
33659: PPUSH
33660: LD_STRING DA1-Gary-1
33662: PPUSH
33663: CALL_OW 91
33667: GO 33811
33669: LD_EXP 55
33673: DOUBLE
33674: EQUAL
33675: IFTRUE 33679
33677: GO 33694
33679: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
33680: LD_EXP 55
33684: PPUSH
33685: LD_STRING DA1-Con-1
33687: PPUSH
33688: CALL_OW 91
33692: GO 33811
33694: LD_EXP 62
33698: DOUBLE
33699: EQUAL
33700: IFTRUE 33704
33702: GO 33719
33704: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
33705: LD_EXP 62
33709: PPUSH
33710: LD_STRING DA1-Kurt-1
33712: PPUSH
33713: CALL_OW 91
33717: GO 33811
33719: LD_EXP 54
33723: DOUBLE
33724: EQUAL
33725: IFTRUE 33729
33727: GO 33744
33729: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
33730: LD_EXP 54
33734: PPUSH
33735: LD_STRING DA1-Yam-1
33737: PPUSH
33738: CALL_OW 91
33742: GO 33811
33744: LD_EXP 53
33748: DOUBLE
33749: EQUAL
33750: IFTRUE 33754
33752: GO 33769
33754: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
33755: LD_EXP 53
33759: PPUSH
33760: LD_STRING DA1-Frank-1
33762: PPUSH
33763: CALL_OW 91
33767: GO 33811
33769: POP
// begin if GetSex ( unit ) = sex_male then
33770: LD_VAR 0 1
33774: PPUSH
33775: CALL_OW 258
33779: PUSH
33780: LD_INT 1
33782: EQUAL
33783: IFFALSE 33799
// ForceSay ( unit , DA1-Sol1-1 ) else
33785: LD_VAR 0 1
33789: PPUSH
33790: LD_STRING DA1-Sol1-1
33792: PPUSH
33793: CALL_OW 91
33797: GO 33811
// ForceSay ( unit , DA1-FSol1-1 ) ;
33799: LD_VAR 0 1
33803: PPUSH
33804: LD_STRING DA1-FSol1-1
33806: PPUSH
33807: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
33811: LD_EXP 77
33815: PPUSH
33816: LD_STRING DA-Roth-1
33818: PPUSH
33819: CALL_OW 88
// if capturedUnit = 1 then
33823: LD_EXP 34
33827: PUSH
33828: LD_INT 1
33830: EQUAL
33831: IFFALSE 33859
// begin Say ( Simms , DA-Sim-1 ) ;
33833: LD_EXP 78
33837: PPUSH
33838: LD_STRING DA-Sim-1
33840: PPUSH
33841: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
33845: LD_EXP 77
33849: PPUSH
33850: LD_STRING DA-Roth-2
33852: PPUSH
33853: CALL_OW 88
// end else
33857: GO 33871
// Say ( Simms , DA-Sim-2 ) ;
33859: LD_EXP 78
33863: PPUSH
33864: LD_STRING DA-Sim-2
33866: PPUSH
33867: CALL_OW 88
// case unit of JMM :
33871: LD_VAR 0 1
33875: PUSH
33876: LD_EXP 40
33880: DOUBLE
33881: EQUAL
33882: IFTRUE 33886
33884: GO 33901
33886: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
33887: LD_EXP 40
33891: PPUSH
33892: LD_STRING DA1-JMM-1a
33894: PPUSH
33895: CALL_OW 91
33899: GO 34418
33901: LD_EXP 41
33905: DOUBLE
33906: EQUAL
33907: IFTRUE 33911
33909: GO 33926
33911: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
33912: LD_EXP 41
33916: PPUSH
33917: LD_STRING DA1-Joan-1a
33919: PPUSH
33920: CALL_OW 91
33924: GO 34418
33926: LD_EXP 43
33930: DOUBLE
33931: EQUAL
33932: IFTRUE 33936
33934: GO 33951
33936: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
33937: LD_EXP 43
33941: PPUSH
33942: LD_STRING DA1-Lisa-1a
33944: PPUSH
33945: CALL_OW 91
33949: GO 34418
33951: LD_EXP 44
33955: DOUBLE
33956: EQUAL
33957: IFTRUE 33961
33959: GO 33976
33961: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
33962: LD_EXP 44
33966: PPUSH
33967: LD_STRING DA1-Don-1a
33969: PPUSH
33970: CALL_OW 91
33974: GO 34418
33976: LD_EXP 51
33980: DOUBLE
33981: EQUAL
33982: IFTRUE 33986
33984: GO 34001
33986: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
33987: LD_EXP 51
33991: PPUSH
33992: LD_STRING DA1-Corn-1a
33994: PPUSH
33995: CALL_OW 91
33999: GO 34418
34001: LD_EXP 47
34005: DOUBLE
34006: EQUAL
34007: IFTRUE 34011
34009: GO 34026
34011: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
34012: LD_EXP 47
34016: PPUSH
34017: LD_STRING DA1-Den-1a
34019: PPUSH
34020: CALL_OW 91
34024: GO 34418
34026: LD_EXP 45
34030: DOUBLE
34031: EQUAL
34032: IFTRUE 34036
34034: GO 34051
34036: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
34037: LD_EXP 45
34041: PPUSH
34042: LD_STRING DA1-Bobby-1a
34044: PPUSH
34045: CALL_OW 91
34049: GO 34418
34051: LD_EXP 49
34055: DOUBLE
34056: EQUAL
34057: IFTRUE 34061
34059: GO 34076
34061: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
34062: LD_EXP 49
34066: PPUSH
34067: LD_STRING DA1-Glad-1a
34069: PPUSH
34070: CALL_OW 91
34074: GO 34418
34076: LD_EXP 46
34080: DOUBLE
34081: EQUAL
34082: IFTRUE 34086
34084: GO 34101
34086: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
34087: LD_EXP 46
34091: PPUSH
34092: LD_STRING DA1-Cyrus-1a
34094: PPUSH
34095: CALL_OW 91
34099: GO 34418
34101: LD_EXP 42
34105: DOUBLE
34106: EQUAL
34107: IFTRUE 34111
34109: GO 34126
34111: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
34112: LD_EXP 42
34116: PPUSH
34117: LD_STRING DA1-Huck-1a
34119: PPUSH
34120: CALL_OW 91
34124: GO 34418
34126: LD_EXP 56
34130: DOUBLE
34131: EQUAL
34132: IFTRUE 34136
34134: GO 34151
34136: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
34137: LD_EXP 56
34141: PPUSH
34142: LD_STRING DA1-Huck-1a
34144: PPUSH
34145: CALL_OW 91
34149: GO 34418
34151: LD_EXP 48
34155: DOUBLE
34156: EQUAL
34157: IFTRUE 34161
34159: GO 34176
34161: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
34162: LD_EXP 48
34166: PPUSH
34167: LD_STRING DA1-Brown-1a
34169: PPUSH
34170: CALL_OW 91
34174: GO 34418
34176: LD_EXP 52
34180: DOUBLE
34181: EQUAL
34182: IFTRUE 34186
34184: GO 34201
34186: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
34187: LD_EXP 52
34191: PPUSH
34192: LD_STRING DA1-Gary-1a
34194: PPUSH
34195: CALL_OW 91
34199: GO 34418
34201: LD_EXP 55
34205: DOUBLE
34206: EQUAL
34207: IFTRUE 34211
34209: GO 34236
34211: POP
// if JMMGirl = 3 then
34212: LD_EXP 7
34216: PUSH
34217: LD_INT 3
34219: EQUAL
34220: IFFALSE 34234
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
34222: LD_EXP 55
34226: PPUSH
34227: LD_STRING DA1-Con-1a
34229: PPUSH
34230: CALL_OW 91
34234: GO 34418
34236: LD_EXP 62
34240: DOUBLE
34241: EQUAL
34242: IFTRUE 34246
34244: GO 34261
34246: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
34247: LD_EXP 62
34251: PPUSH
34252: LD_STRING DA1-Kurt-1a
34254: PPUSH
34255: CALL_OW 91
34259: GO 34418
34261: LD_EXP 54
34265: DOUBLE
34266: EQUAL
34267: IFTRUE 34271
34269: GO 34286
34271: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
34272: LD_EXP 54
34276: PPUSH
34277: LD_STRING DA1-Yam-1a
34279: PPUSH
34280: CALL_OW 91
34284: GO 34418
34286: LD_EXP 53
34290: DOUBLE
34291: EQUAL
34292: IFTRUE 34296
34294: GO 34311
34296: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
34297: LD_EXP 53
34301: PPUSH
34302: LD_STRING DA1-Frank-1a
34304: PPUSH
34305: CALL_OW 91
34309: GO 34418
34311: POP
// begin join := rand ( 0 , 1 ) ;
34312: LD_ADDR_VAR 0 3
34316: PUSH
34317: LD_INT 0
34319: PPUSH
34320: LD_INT 1
34322: PPUSH
34323: CALL_OW 12
34327: ST_TO_ADDR
// if join then
34328: LD_VAR 0 3
34332: IFFALSE 34377
// begin if GetSex ( unit ) = sex_male then
34334: LD_VAR 0 1
34338: PPUSH
34339: CALL_OW 258
34343: PUSH
34344: LD_INT 1
34346: EQUAL
34347: IFFALSE 34363
// ForceSay ( unit , DA1-Sol1-1b ) else
34349: LD_VAR 0 1
34353: PPUSH
34354: LD_STRING DA1-Sol1-1b
34356: PPUSH
34357: CALL_OW 91
34361: GO 34375
// ForceSay ( unit , DA1-FSol1-1b ) ;
34363: LD_VAR 0 1
34367: PPUSH
34368: LD_STRING DA1-FSol1-1b
34370: PPUSH
34371: CALL_OW 91
// end else
34375: GO 34418
// begin if GetSex ( unit ) = sex_male then
34377: LD_VAR 0 1
34381: PPUSH
34382: CALL_OW 258
34386: PUSH
34387: LD_INT 1
34389: EQUAL
34390: IFFALSE 34406
// ForceSay ( unit , DA1-Sol1-1a ) else
34392: LD_VAR 0 1
34396: PPUSH
34397: LD_STRING DA1-Sol1-1a
34399: PPUSH
34400: CALL_OW 91
34404: GO 34418
// ForceSay ( unit , DA1-FSol1-1a ) ;
34406: LD_VAR 0 1
34410: PPUSH
34411: LD_STRING DA1-FSol1-1a
34413: PPUSH
34414: CALL_OW 91
// end ; end ; end ; if unit = JMM then
34418: LD_VAR 0 1
34422: PUSH
34423: LD_EXP 40
34427: EQUAL
34428: IFFALSE 34439
// begin YouLost ( JMMCaptured ) ;
34430: LD_STRING JMMCaptured
34432: PPUSH
34433: CALL_OW 104
// exit ;
34437: GO 34737
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
34439: LD_VAR 0 1
34443: PUSH
34444: LD_EXP 44
34448: PUSH
34449: LD_EXP 47
34453: PUSH
34454: LD_EXP 45
34458: PUSH
34459: LD_EXP 42
34463: PUSH
34464: LD_EXP 56
34468: PUSH
34469: LD_EXP 48
34473: PUSH
34474: LD_EXP 54
34478: PUSH
34479: EMPTY
34480: LIST
34481: LIST
34482: LIST
34483: LIST
34484: LIST
34485: LIST
34486: LIST
34487: IN
34488: PUSH
34489: LD_VAR 0 3
34493: OR
34494: IFFALSE 34593
// begin Say ( Roth , DA-Roth-3 ) ;
34496: LD_EXP 77
34500: PPUSH
34501: LD_STRING DA-Roth-3
34503: PPUSH
34504: CALL_OW 88
// SetSide ( unit , 7 ) ;
34508: LD_VAR 0 1
34512: PPUSH
34513: LD_INT 7
34515: PPUSH
34516: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
34520: LD_ADDR_EXP 100
34524: PUSH
34525: LD_EXP 100
34529: PPUSH
34530: LD_INT 1
34532: PPUSH
34533: LD_EXP 100
34537: PUSH
34538: LD_INT 1
34540: ARRAY
34541: PUSH
34542: LD_VAR 0 1
34546: ADD
34547: PPUSH
34548: CALL_OW 1
34552: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
34553: LD_INT 260
34555: PPUSH
34556: LD_INT 235
34558: PPUSH
34559: LD_INT 1
34561: PPUSH
34562: CALL_OW 331
// SetLives ( unit , 1000 ) ;
34566: LD_VAR 0 1
34570: PPUSH
34571: LD_INT 1000
34573: PPUSH
34574: CALL_OW 234
// DialogueOff ;
34578: CALL_OW 7
// ComFree ( unit ) ;
34582: LD_VAR 0 1
34586: PPUSH
34587: CALL_OW 139
// end else
34591: GO 34674
// begin Say ( Roth , DA-Roth-3a ) ;
34593: LD_EXP 77
34597: PPUSH
34598: LD_STRING DA-Roth-3a
34600: PPUSH
34601: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
34605: LD_ADDR_EXP 35
34609: PUSH
34610: LD_EXP 35
34614: PUSH
34615: LD_VAR 0 1
34619: ADD
34620: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
34621: LD_INT 260
34623: PPUSH
34624: LD_INT 235
34626: PPUSH
34627: LD_INT 1
34629: PPUSH
34630: CALL_OW 331
// SetLives ( unit , 1000 ) ;
34634: LD_VAR 0 1
34638: PPUSH
34639: LD_INT 1000
34641: PPUSH
34642: CALL_OW 234
// DialogueOff ;
34646: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
34650: LD_VAR 0 1
34654: PPUSH
34655: LD_INT 272
34657: PPUSH
34658: LD_INT 254
34660: PPUSH
34661: CALL_OW 111
// AddComHold ( unit ) ;
34665: LD_VAR 0 1
34669: PPUSH
34670: CALL_OW 200
// end ; if capturedUnit = 1 then
34674: LD_EXP 34
34678: PUSH
34679: LD_INT 1
34681: EQUAL
34682: IFFALSE 34737
// begin DialogueOn ;
34684: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
34688: LD_EXP 40
34692: PPUSH
34693: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
34697: LD_EXP 40
34701: PPUSH
34702: LD_STRING DAa-JMM-1
34704: PPUSH
34705: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
34709: LD_EXP 40
34713: PPUSH
34714: LD_STRING DAa-JMM-1a
34716: PPUSH
34717: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
34721: LD_EXP 40
34725: PPUSH
34726: LD_STRING DAa-JMM-1b
34728: PPUSH
34729: CALL_OW 88
// DialogueOff ;
34733: CALL_OW 7
// end ; end ;
34737: LD_VAR 0 2
34741: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
34742: LD_EXP 15
34746: PUSH
34747: LD_INT 13
34749: GREATEREQUAL
34750: PUSH
34751: LD_INT 22
34753: PUSH
34754: LD_INT 2
34756: PUSH
34757: EMPTY
34758: LIST
34759: LIST
34760: PUSH
34761: LD_INT 21
34763: PUSH
34764: LD_INT 1
34766: PUSH
34767: EMPTY
34768: LIST
34769: LIST
34770: PUSH
34771: EMPTY
34772: LIST
34773: LIST
34774: PPUSH
34775: CALL_OW 69
34779: PUSH
34780: LD_INT 0
34782: EQUAL
34783: AND
34784: PUSH
34785: LD_INT 22
34787: PUSH
34788: LD_INT 2
34790: PUSH
34791: EMPTY
34792: LIST
34793: LIST
34794: PUSH
34795: LD_INT 33
34797: PUSH
34798: LD_INT 5
34800: PUSH
34801: EMPTY
34802: LIST
34803: LIST
34804: PUSH
34805: LD_INT 21
34807: PUSH
34808: LD_INT 2
34810: PUSH
34811: EMPTY
34812: LIST
34813: LIST
34814: PUSH
34815: LD_INT 50
34817: PUSH
34818: EMPTY
34819: LIST
34820: PUSH
34821: EMPTY
34822: LIST
34823: LIST
34824: LIST
34825: LIST
34826: PPUSH
34827: CALL_OW 69
34831: PUSH
34832: LD_INT 0
34834: EQUAL
34835: AND
34836: PUSH
34837: LD_EXP 21
34841: AND
34842: PUSH
34843: LD_EXP 22
34847: AND
34848: PUSH
34849: LD_EXP 23
34853: AND
34854: IFFALSE 35550
34856: GO 34858
34858: DISABLE
34859: LD_INT 0
34861: PPUSH
34862: PPUSH
34863: PPUSH
// begin m1 := false ;
34864: LD_ADDR_VAR 0 1
34868: PUSH
34869: LD_INT 0
34871: ST_TO_ADDR
// m2 := false ;
34872: LD_ADDR_VAR 0 2
34876: PUSH
34877: LD_INT 0
34879: ST_TO_ADDR
// m3 := false ;
34880: LD_ADDR_VAR 0 3
34884: PUSH
34885: LD_INT 0
34887: ST_TO_ADDR
// if not bombExploded then
34888: LD_EXP 37
34892: NOT
34893: IFFALSE 34902
// SetAchievement ( ACH_SIBROCKET ) ;
34895: LD_STRING ACH_SIBROCKET
34897: PPUSH
34898: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
34902: LD_EXP 64
34906: PPUSH
34907: CALL_OW 255
34911: PUSH
34912: LD_INT 1
34914: EQUAL
34915: PUSH
34916: LD_EXP 64
34920: PPUSH
34921: CALL_OW 302
34925: AND
34926: IFFALSE 34942
// begin wait ( 3 ) ;
34928: LD_INT 3
34930: PPUSH
34931: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
34935: LD_STRING ACH_OPO
34937: PPUSH
34938: CALL_OW 543
// end ; if tick <= 120 120$00 then
34942: LD_OWVAR 1
34946: PUSH
34947: LD_INT 252000
34949: LESSEQUAL
34950: IFFALSE 34966
// begin wait ( 3 ) ;
34952: LD_INT 3
34954: PPUSH
34955: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
34959: LD_STRING ACH_ASPEED_15
34961: PPUSH
34962: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
34966: LD_EXP 40
34970: PPUSH
34971: CALL_OW 87
// music_class := 5 ;
34975: LD_ADDR_OWVAR 72
34979: PUSH
34980: LD_INT 5
34982: ST_TO_ADDR
// music_nat := 5 ;
34983: LD_ADDR_OWVAR 71
34987: PUSH
34988: LD_INT 5
34990: ST_TO_ADDR
// DialogueOn ;
34991: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
34995: LD_EXP 40
34999: PPUSH
35000: LD_STRING D20-JMM-1
35002: PPUSH
35003: CALL_OW 88
// if IsOK ( Joan ) then
35007: LD_EXP 41
35011: PPUSH
35012: CALL_OW 302
35016: IFFALSE 35030
// Say ( Joan , D20-Joan-1 ) ;
35018: LD_EXP 41
35022: PPUSH
35023: LD_STRING D20-Joan-1
35025: PPUSH
35026: CALL_OW 88
// if IsOk ( Lisa ) then
35030: LD_EXP 43
35034: PPUSH
35035: CALL_OW 302
35039: IFFALSE 35053
// Say ( Lisa , D20-Lisa-1 ) ;
35041: LD_EXP 43
35045: PPUSH
35046: LD_STRING D20-Lisa-1
35048: PPUSH
35049: CALL_OW 88
// if IsOk ( Donaldson ) then
35053: LD_EXP 44
35057: PPUSH
35058: CALL_OW 302
35062: IFFALSE 35076
// Say ( Donaldson , D20-Don-1 ) ;
35064: LD_EXP 44
35068: PPUSH
35069: LD_STRING D20-Don-1
35071: PPUSH
35072: CALL_OW 88
// if IsOK ( Cornel ) then
35076: LD_EXP 51
35080: PPUSH
35081: CALL_OW 302
35085: IFFALSE 35099
// Say ( Cornel , D20-Corn-1 ) ;
35087: LD_EXP 51
35091: PPUSH
35092: LD_STRING D20-Corn-1
35094: PPUSH
35095: CALL_OW 88
// if IsOk ( Denis ) then
35099: LD_EXP 47
35103: PPUSH
35104: CALL_OW 302
35108: IFFALSE 35122
// Say ( Denis , D20-Den-1 ) ;
35110: LD_EXP 47
35114: PPUSH
35115: LD_STRING D20-Den-1
35117: PPUSH
35118: CALL_OW 88
// if IsOk ( Bobby ) then
35122: LD_EXP 45
35126: PPUSH
35127: CALL_OW 302
35131: IFFALSE 35145
// Say ( Bobby , D20-Bobby-1 ) ;
35133: LD_EXP 45
35137: PPUSH
35138: LD_STRING D20-Bobby-1
35140: PPUSH
35141: CALL_OW 88
// if IsOk ( Gladstone ) then
35145: LD_EXP 49
35149: PPUSH
35150: CALL_OW 302
35154: IFFALSE 35168
// Say ( Gladstone , D20-Glad-1 ) ;
35156: LD_EXP 49
35160: PPUSH
35161: LD_STRING D20-Glad-1
35163: PPUSH
35164: CALL_OW 88
// if IsOk ( Cyrus ) then
35168: LD_EXP 46
35172: PPUSH
35173: CALL_OW 302
35177: IFFALSE 35191
// Say ( Cyrus , D20-Cyrus-1 ) ;
35179: LD_EXP 46
35183: PPUSH
35184: LD_STRING D20-Cyrus-1
35186: PPUSH
35187: CALL_OW 88
// if IsOk ( Stevens ) then
35191: LD_EXP 42
35195: PPUSH
35196: CALL_OW 302
35200: IFFALSE 35214
// Say ( Stevens , D20-Huck-1 ) ;
35202: LD_EXP 42
35206: PPUSH
35207: LD_STRING D20-Huck-1
35209: PPUSH
35210: CALL_OW 88
// if IsOk ( Brown ) then
35214: LD_EXP 48
35218: PPUSH
35219: CALL_OW 302
35223: IFFALSE 35237
// Say ( Brown , D20-Brown-1 ) ;
35225: LD_EXP 48
35229: PPUSH
35230: LD_STRING D20-Brown-1
35232: PPUSH
35233: CALL_OW 88
// if IsOk ( Gary ) then
35237: LD_EXP 52
35241: PPUSH
35242: CALL_OW 302
35246: IFFALSE 35260
// Say ( Gary , D20-Gary-1 ) ;
35248: LD_EXP 52
35252: PPUSH
35253: LD_STRING D20-Gary-1
35255: PPUSH
35256: CALL_OW 88
// if IsOk ( Connie ) then
35260: LD_EXP 55
35264: PPUSH
35265: CALL_OW 302
35269: IFFALSE 35283
// Say ( Connie , D20-Con-1 ) ;
35271: LD_EXP 55
35275: PPUSH
35276: LD_STRING D20-Con-1
35278: PPUSH
35279: CALL_OW 88
// if IsOk ( Kurt ) then
35283: LD_EXP 62
35287: PPUSH
35288: CALL_OW 302
35292: IFFALSE 35306
// Say ( Kurt , D20-Kurt-1 ) ;
35294: LD_EXP 62
35298: PPUSH
35299: LD_STRING D20-Kurt-1
35301: PPUSH
35302: CALL_OW 88
// if IsOk ( Kikuchi ) then
35306: LD_EXP 54
35310: PPUSH
35311: CALL_OW 302
35315: IFFALSE 35329
// Say ( Kikuchi , D20-Yam-1 ) ;
35317: LD_EXP 54
35321: PPUSH
35322: LD_STRING D20-Yam-1
35324: PPUSH
35325: CALL_OW 88
// if IsOk ( Frank ) then
35329: LD_EXP 53
35333: PPUSH
35334: CALL_OW 302
35338: IFFALSE 35352
// Say ( Frank , D20-Frank-1 ) ;
35340: LD_EXP 53
35344: PPUSH
35345: LD_STRING D20-Frank-1
35347: PPUSH
35348: CALL_OW 88
// DialogueOff ;
35352: CALL_OW 7
// if RothCaptured then
35356: LD_EXP 33
35360: IFFALSE 35382
// begin m1 := true ;
35362: LD_ADDR_VAR 0 1
35366: PUSH
35367: LD_INT 1
35369: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
35370: LD_STRING Roth
35372: PPUSH
35373: LD_INT 1
35375: PPUSH
35376: CALL_OW 101
// end else
35380: GO 35393
// AddMedal ( Roth , - 1 ) ;
35382: LD_STRING Roth
35384: PPUSH
35385: LD_INT 1
35387: NEG
35388: PPUSH
35389: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish or not behemothDone then
35393: LD_EXP 25
35397: NOT
35398: PUSH
35399: LD_EXP 27
35403: OR
35404: PUSH
35405: LD_EXP 28
35409: NOT
35410: OR
35411: IFFALSE 35433
// begin m2 := true ;
35413: LD_ADDR_VAR 0 2
35417: PUSH
35418: LD_INT 1
35420: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
35421: LD_STRING Project
35423: PPUSH
35424: LD_INT 1
35426: PPUSH
35427: CALL_OW 101
// end else
35431: GO 35444
// AddMedal ( Project , - 1 ) ;
35433: LD_STRING Project
35435: PPUSH
35436: LD_INT 1
35438: NEG
35439: PPUSH
35440: CALL_OW 101
// if lostCounter = 0 then
35444: LD_EXP 32
35448: PUSH
35449: LD_INT 0
35451: EQUAL
35452: IFFALSE 35474
// begin m3 := true ;
35454: LD_ADDR_VAR 0 3
35458: PUSH
35459: LD_INT 1
35461: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
35462: LD_STRING NoLosses
35464: PPUSH
35465: LD_INT 1
35467: PPUSH
35468: CALL_OW 101
// end else
35472: GO 35485
// AddMedal ( NoLosses , - 1 ) ;
35474: LD_STRING NoLosses
35476: PPUSH
35477: LD_INT 1
35479: NEG
35480: PPUSH
35481: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
35485: LD_VAR 0 1
35489: PUSH
35490: LD_VAR 0 2
35494: AND
35495: PUSH
35496: LD_VAR 0 3
35500: AND
35501: PUSH
35502: LD_OWVAR 67
35506: PUSH
35507: LD_INT 3
35509: GREATEREQUAL
35510: AND
35511: IFFALSE 35523
// SetAchievementEX ( ACH_AMER , 15 ) ;
35513: LD_STRING ACH_AMER
35515: PPUSH
35516: LD_INT 15
35518: PPUSH
35519: CALL_OW 564
// GiveMedals ( MAIN ) ;
35523: LD_STRING MAIN
35525: PPUSH
35526: CALL_OW 102
// music_class := 4 ;
35530: LD_ADDR_OWVAR 72
35534: PUSH
35535: LD_INT 4
35537: ST_TO_ADDR
// music_nat := 1 ;
35538: LD_ADDR_OWVAR 71
35542: PUSH
35543: LD_INT 1
35545: ST_TO_ADDR
// YouWin ;
35546: CALL_OW 103
// end ; end_of_file
35550: PPOPN 3
35552: END
// export function CustomEvent ( event ) ; begin
35553: LD_INT 0
35555: PPUSH
// end ;
35556: LD_VAR 0 2
35560: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
35561: LD_VAR 0 1
35565: PUSH
35566: LD_INT 1
35568: EQUAL
35569: PUSH
35570: LD_VAR 0 2
35574: PUSH
35575: LD_INT 4
35577: EQUAL
35578: AND
35579: PUSH
35580: LD_EXP 60
35584: PPUSH
35585: CALL_OW 300
35589: AND
35590: IFFALSE 35606
// begin wait ( 0 0$2 ) ;
35592: LD_INT 70
35594: PPUSH
35595: CALL_OW 67
// YouLost ( Dismissed ) ;
35599: LD_STRING Dismissed
35601: PPUSH
35602: CALL_OW 104
// end ; end ;
35606: PPOPN 2
35608: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
35609: LD_VAR 0 2
35613: PPUSH
35614: LD_VAR 0 3
35618: PPUSH
35619: LD_INT 18
35621: PPUSH
35622: CALL_OW 309
35626: IFFALSE 35635
// YouLost ( Motherlode3 ) ;
35628: LD_STRING Motherlode3
35630: PPUSH
35631: CALL_OW 104
// end ;
35635: PPOPN 3
35637: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
35638: LD_EXP 27
35642: NOT
35643: IFFALSE 35653
// behemothDone := true ;
35645: LD_ADDR_EXP 28
35649: PUSH
35650: LD_INT 1
35652: ST_TO_ADDR
// end ;
35653: PPOPN 1
35655: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
35656: LD_VAR 0 1
35660: PPUSH
35661: CALL_OW 255
35665: PUSH
35666: LD_INT 1
35668: EQUAL
35669: IFFALSE 35679
// bombExploded := true ;
35671: LD_ADDR_EXP 37
35675: PUSH
35676: LD_INT 1
35678: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
35679: LD_VAR 0 1
35683: PPUSH
35684: CALL_OW 255
35688: PUSH
35689: LD_INT 3
35691: EQUAL
35692: IFFALSE 35722
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
35694: LD_INT 2
35696: PPUSH
35697: LD_INT 23
35699: PUSH
35700: LD_INT 3
35702: PUSH
35703: LD_INT 3
35705: PUSH
35706: LD_INT 48
35708: PUSH
35709: EMPTY
35710: LIST
35711: LIST
35712: LIST
35713: LIST
35714: PUSH
35715: EMPTY
35716: LIST
35717: PPUSH
35718: CALL 61548 0 2
// if GetSide ( unit ) = 1 and GetSide ( Friend ) = 1 and IsOk ( Friend ) and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
35722: LD_VAR 0 1
35726: PPUSH
35727: CALL_OW 255
35731: PUSH
35732: LD_INT 1
35734: EQUAL
35735: PUSH
35736: LD_EXP 64
35740: PPUSH
35741: CALL_OW 255
35745: PUSH
35746: LD_INT 1
35748: EQUAL
35749: AND
35750: PUSH
35751: LD_EXP 64
35755: PPUSH
35756: CALL_OW 302
35760: AND
35761: PUSH
35762: LD_EXP 30
35766: AND
35767: PUSH
35768: LD_INT 22
35770: PUSH
35771: LD_INT 3
35773: PUSH
35774: EMPTY
35775: LIST
35776: LIST
35777: PUSH
35778: LD_INT 34
35780: PUSH
35781: LD_INT 48
35783: PUSH
35784: EMPTY
35785: LIST
35786: LIST
35787: PUSH
35788: EMPTY
35789: LIST
35790: LIST
35791: PPUSH
35792: CALL_OW 69
35796: AND
35797: PUSH
35798: LD_INT 22
35800: PUSH
35801: LD_INT 1
35803: PUSH
35804: EMPTY
35805: LIST
35806: LIST
35807: PUSH
35808: LD_INT 34
35810: PUSH
35811: LD_INT 8
35813: PUSH
35814: EMPTY
35815: LIST
35816: LIST
35817: PUSH
35818: EMPTY
35819: LIST
35820: LIST
35821: PPUSH
35822: CALL_OW 69
35826: NOT
35827: AND
35828: IFFALSE 35880
// begin wait ( 0 0$5 ) ;
35830: LD_INT 175
35832: PPUSH
35833: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
35837: LD_INT 22
35839: PUSH
35840: LD_INT 3
35842: PUSH
35843: EMPTY
35844: LIST
35845: LIST
35846: PUSH
35847: LD_INT 34
35849: PUSH
35850: LD_INT 48
35852: PUSH
35853: EMPTY
35854: LIST
35855: LIST
35856: PUSH
35857: EMPTY
35858: LIST
35859: LIST
35860: PPUSH
35861: CALL_OW 69
35865: PUSH
35866: LD_INT 1
35868: ARRAY
35869: PPUSH
35870: LD_INT 60
35872: PPUSH
35873: LD_INT 95
35875: PPUSH
35876: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
35880: LD_VAR 0 2
35884: PPUSH
35885: LD_VAR 0 3
35889: PPUSH
35890: LD_INT 18
35892: PPUSH
35893: CALL_OW 309
35897: PUSH
35898: LD_VAR 0 2
35902: PPUSH
35903: LD_VAR 0 3
35907: PPUSH
35908: LD_INT 18
35910: PPUSH
35911: CALL 109075 0 3
35915: OR
35916: IFFALSE 35963
// begin if GetSide ( unit ) = 1 then
35918: LD_VAR 0 1
35922: PPUSH
35923: CALL_OW 255
35927: PUSH
35928: LD_INT 1
35930: EQUAL
35931: IFFALSE 35949
// begin wait ( 0 0$6 ) ;
35933: LD_INT 210
35935: PPUSH
35936: CALL_OW 67
// YouLost ( Motherlode2 ) ;
35940: LD_STRING Motherlode2
35942: PPUSH
35943: CALL_OW 104
// end else
35947: GO 35963
// begin wait ( 0 0$6 ) ;
35949: LD_INT 210
35951: PPUSH
35952: CALL_OW 67
// YouLost ( Motherlode1 ) ;
35956: LD_STRING Motherlode1
35958: PPUSH
35959: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
35963: LD_VAR 0 1
35967: PPUSH
35968: CALL_OW 255
35972: PUSH
35973: LD_INT 3
35975: EQUAL
35976: IFFALSE 35997
// begin wait ( 0 0$5 ) ;
35978: LD_INT 175
35980: PPUSH
35981: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
35985: LD_EXP 66
35989: PPUSH
35990: LD_STRING D18-Pla-1
35992: PPUSH
35993: CALL_OW 94
// end ; end ;
35997: PPOPN 3
35999: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
36000: LD_VAR 0 1
36004: PPUSH
36005: CALL 125132 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
36009: LD_VAR 0 1
36013: PUSH
36014: LD_INT 22
36016: PUSH
36017: LD_INT 1
36019: PUSH
36020: EMPTY
36021: LIST
36022: LIST
36023: PUSH
36024: LD_INT 21
36026: PUSH
36027: LD_INT 1
36029: PUSH
36030: EMPTY
36031: LIST
36032: LIST
36033: PUSH
36034: LD_INT 23
36036: PUSH
36037: LD_INT 1
36039: PUSH
36040: EMPTY
36041: LIST
36042: LIST
36043: PUSH
36044: EMPTY
36045: LIST
36046: LIST
36047: LIST
36048: PPUSH
36049: CALL_OW 69
36053: IN
36054: IFFALSE 36070
// lostCounter := lostCounter + 1 ;
36056: LD_ADDR_EXP 32
36060: PUSH
36061: LD_EXP 32
36065: PUSH
36066: LD_INT 1
36068: PLUS
36069: ST_TO_ADDR
// if un in behemothBuilders then
36070: LD_VAR 0 1
36074: PUSH
36075: LD_EXP 75
36079: IN
36080: IFFALSE 36100
// begin behemothBuilders := behemothBuilders diff un ;
36082: LD_ADDR_EXP 75
36086: PUSH
36087: LD_EXP 75
36091: PUSH
36092: LD_VAR 0 1
36096: DIFF
36097: ST_TO_ADDR
// exit ;
36098: GO 36130
// end ; if un = JMM then
36100: LD_VAR 0 1
36104: PUSH
36105: LD_EXP 40
36109: EQUAL
36110: IFFALSE 36121
// begin YouLost ( JMM ) ;
36112: LD_STRING JMM
36114: PPUSH
36115: CALL_OW 104
// exit ;
36119: GO 36130
// end ; MCE_UnitDestroyed ( un ) ;
36121: LD_VAR 0 1
36125: PPUSH
36126: CALL 64990 0 1
// end ;
36130: PPOPN 1
36132: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
36133: LD_VAR 0 1
36137: PPUSH
36138: LD_VAR 0 2
36142: PPUSH
36143: CALL 67322 0 2
// end ;
36147: PPOPN 2
36149: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
36150: LD_VAR 0 1
36154: PPUSH
36155: CALL 66390 0 1
// end ;
36159: PPOPN 1
36161: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
36162: LD_VAR 0 1
36166: PUSH
36167: LD_INT 22
36169: PUSH
36170: LD_INT 8
36172: PUSH
36173: EMPTY
36174: LIST
36175: LIST
36176: PUSH
36177: LD_INT 30
36179: PUSH
36180: LD_INT 2
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: PUSH
36187: LD_INT 23
36189: PUSH
36190: LD_INT 3
36192: PUSH
36193: EMPTY
36194: LIST
36195: LIST
36196: PUSH
36197: EMPTY
36198: LIST
36199: LIST
36200: LIST
36201: PPUSH
36202: CALL_OW 69
36206: IN
36207: IFFALSE 36234
// begin ComUpgrade ( building ) ;
36209: LD_VAR 0 1
36213: PPUSH
36214: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
36218: LD_EXP 63
36222: PPUSH
36223: LD_VAR 0 1
36227: PPUSH
36228: CALL 75797 0 2
// exit ;
36232: GO 36243
// end ; MCE_BuildingComplete ( building ) ;
36234: LD_VAR 0 1
36238: PPUSH
36239: CALL 66631 0 1
// end ;
36243: PPOPN 1
36245: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
36246: LD_VAR 0 1
36250: PPUSH
36251: LD_VAR 0 2
36255: PPUSH
36256: CALL 64686 0 2
// end ;
36260: PPOPN 2
36262: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
36263: LD_VAR 0 1
36267: PPUSH
36268: LD_VAR 0 2
36272: PPUSH
36273: LD_VAR 0 3
36277: PPUSH
36278: LD_VAR 0 4
36282: PPUSH
36283: LD_VAR 0 5
36287: PPUSH
36288: CALL 64306 0 5
// end ;
36292: PPOPN 5
36294: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
36295: LD_VAR 0 1
36299: PPUSH
36300: CALL_OW 255
36304: PUSH
36305: LD_INT 1
36307: EQUAL
36308: IFFALSE 36325
// amConstructCounter := Inc ( amConstructCounter ) ;
36310: LD_ADDR_EXP 39
36314: PUSH
36315: LD_EXP 39
36319: PPUSH
36320: CALL 106627 0 1
36324: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
36325: LD_VAR 0 1
36329: PPUSH
36330: LD_VAR 0 2
36334: PPUSH
36335: CALL 125252 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
36339: LD_VAR 0 1
36343: PPUSH
36344: LD_VAR 0 2
36348: PPUSH
36349: CALL 63859 0 2
// end ;
36353: PPOPN 2
36355: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
36356: LD_VAR 0 1
36360: PPUSH
36361: LD_VAR 0 2
36365: PPUSH
36366: LD_VAR 0 3
36370: PPUSH
36371: LD_VAR 0 4
36375: PPUSH
36376: CALL 63697 0 4
// end ;
36380: PPOPN 4
36382: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
36383: LD_VAR 0 1
36387: PPUSH
36388: LD_VAR 0 2
36392: PPUSH
36393: LD_VAR 0 3
36397: PPUSH
36398: CALL 63472 0 3
// end ;
36402: PPOPN 3
36404: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
36405: LD_VAR 0 1
36409: PPUSH
36410: LD_VAR 0 2
36414: PPUSH
36415: CALL 63357 0 2
// end ;
36419: PPOPN 2
36421: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
36422: LD_VAR 0 1
36426: PPUSH
36427: LD_VAR 0 2
36431: PPUSH
36432: CALL 67617 0 2
// end ;
36436: PPOPN 2
36438: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
36439: LD_VAR 0 1
36443: PUSH
36444: LD_INT 460
36446: EQUAL
36447: IFFALSE 36469
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
36449: LD_VAR 0 2
36453: PPUSH
36454: LD_INT 227
36456: PPUSH
36457: LD_INT 136
36459: PPUSH
36460: CALL_OW 428
36464: PPUSH
36465: CALL_OW 120
// end ;
36469: PPOPN 2
36471: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
36472: LD_VAR 0 1
36476: PPUSH
36477: CALL_OW 255
36481: PUSH
36482: LD_INT 4
36484: EQUAL
36485: PUSH
36486: LD_VAR 0 1
36490: PUSH
36491: LD_EXP 18
36495: PUSH
36496: LD_INT 1
36498: ARRAY
36499: IN
36500: AND
36501: PUSH
36502: LD_EXP 19
36506: AND
36507: IFFALSE 36526
// begin ComMoveXY ( driver , 61 , 93 ) ;
36509: LD_VAR 0 1
36513: PPUSH
36514: LD_INT 61
36516: PPUSH
36517: LD_INT 93
36519: PPUSH
36520: CALL_OW 111
// exit ;
36524: GO 36550
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
36526: LD_VAR 0 1
36530: PPUSH
36531: LD_VAR 0 2
36535: PPUSH
36536: LD_VAR 0 3
36540: PPUSH
36541: LD_VAR 0 4
36545: PPUSH
36546: CALL 67833 0 4
// end ;
36550: PPOPN 4
36552: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
36553: LD_VAR 0 1
36557: PPUSH
36558: LD_VAR 0 2
36562: PPUSH
36563: CALL 63166 0 2
// end ;
36567: PPOPN 2
36569: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
36570: LD_VAR 0 1
36574: PPUSH
36575: CALL 125236 0 1
// end ; end_of_file
36579: PPOPN 1
36581: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
36582: LD_EXP 15
36586: PUSH
36587: LD_INT 2
36589: EQUAL
36590: IFFALSE 37093
36592: GO 36594
36594: DISABLE
36595: LD_INT 0
36597: PPUSH
36598: PPUSH
// begin time := 0 0$35 ;
36599: LD_ADDR_VAR 0 2
36603: PUSH
36604: LD_INT 1225
36606: ST_TO_ADDR
// repeat wait ( time ) ;
36607: LD_VAR 0 2
36611: PPUSH
36612: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
36616: LD_INT 1
36618: PPUSH
36619: LD_INT 5
36621: PPUSH
36622: CALL_OW 12
36626: PPUSH
36627: LD_INT 106
36629: PPUSH
36630: LD_INT 150
36632: PPUSH
36633: LD_INT 19
36635: PPUSH
36636: LD_INT 1
36638: PPUSH
36639: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
36643: LD_INT 455
36645: PPUSH
36646: LD_INT 770
36648: PPUSH
36649: CALL_OW 12
36653: PPUSH
36654: CALL_OW 67
// if Prob ( 50 ) then
36658: LD_INT 50
36660: PPUSH
36661: CALL_OW 13
36665: IFFALSE 36694
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
36667: LD_INT 1
36669: PPUSH
36670: LD_INT 5
36672: PPUSH
36673: CALL_OW 12
36677: PPUSH
36678: LD_INT 62
36680: PPUSH
36681: LD_INT 108
36683: PPUSH
36684: LD_INT 10
36686: PPUSH
36687: LD_INT 1
36689: PPUSH
36690: CALL_OW 56
// until missionStage > 4 ;
36694: LD_EXP 15
36698: PUSH
36699: LD_INT 4
36701: GREATER
36702: IFFALSE 36607
// repeat wait ( 0 0$1 ) ;
36704: LD_INT 35
36706: PPUSH
36707: CALL_OW 67
// until missionStage = 6 ;
36711: LD_EXP 15
36715: PUSH
36716: LD_INT 6
36718: EQUAL
36719: IFFALSE 36704
// time := 0 0$20 ;
36721: LD_ADDR_VAR 0 2
36725: PUSH
36726: LD_INT 700
36728: ST_TO_ADDR
// repeat wait ( time ) ;
36729: LD_VAR 0 2
36733: PPUSH
36734: CALL_OW 67
// if Prob ( 90 ) then
36738: LD_INT 90
36740: PPUSH
36741: CALL_OW 13
36745: IFFALSE 36788
// begin time := time + 0 0$2 ;
36747: LD_ADDR_VAR 0 2
36751: PUSH
36752: LD_VAR 0 2
36756: PUSH
36757: LD_INT 70
36759: PLUS
36760: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
36761: LD_INT 1
36763: PPUSH
36764: LD_INT 5
36766: PPUSH
36767: CALL_OW 12
36771: PPUSH
36772: LD_INT 106
36774: PPUSH
36775: LD_INT 89
36777: PPUSH
36778: LD_INT 45
36780: PPUSH
36781: LD_INT 1
36783: PPUSH
36784: CALL_OW 56
// end ; if Prob ( 45 ) then
36788: LD_INT 45
36790: PPUSH
36791: CALL_OW 13
36795: IFFALSE 36851
// begin for i := 1 to 4 do
36797: LD_ADDR_VAR 0 1
36801: PUSH
36802: DOUBLE
36803: LD_INT 1
36805: DEC
36806: ST_TO_ADDR
36807: LD_INT 4
36809: PUSH
36810: FOR_TO
36811: IFFALSE 36849
// begin wait ( 0 0$5 ) ;
36813: LD_INT 175
36815: PPUSH
36816: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
36820: LD_INT 1
36822: PPUSH
36823: LD_INT 5
36825: PPUSH
36826: CALL_OW 12
36830: PPUSH
36831: LD_INT 113
36833: PPUSH
36834: LD_INT 117
36836: PPUSH
36837: LD_INT 25
36839: PPUSH
36840: LD_INT 1
36842: PPUSH
36843: CALL_OW 56
// end ;
36847: GO 36810
36849: POP
36850: POP
// end ; if Prob ( 40 ) then
36851: LD_INT 40
36853: PPUSH
36854: CALL_OW 13
36858: IFFALSE 36904
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
36860: LD_INT 385
36862: PPUSH
36863: LD_INT 945
36865: PPUSH
36866: CALL_OW 12
36870: PPUSH
36871: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
36875: LD_INT 1
36877: PPUSH
36878: LD_INT 5
36880: PPUSH
36881: CALL_OW 12
36885: PPUSH
36886: LD_INT 21
36888: PPUSH
36889: LD_INT 26
36891: PPUSH
36892: LD_INT 12
36894: PPUSH
36895: LD_INT 1
36897: PPUSH
36898: CALL_OW 56
// end else
36902: GO 36940
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
36904: LD_INT 700
36906: PPUSH
36907: LD_INT 1225
36909: PPUSH
36910: CALL_OW 12
36914: PPUSH
36915: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
36919: LD_INT 1
36921: PPUSH
36922: LD_INT 5
36924: PPUSH
36925: CALL_OW 12
36929: PPUSH
36930: LD_INT 16
36932: PPUSH
36933: LD_INT 1
36935: PPUSH
36936: CALL_OW 55
// end ; if Prob ( 50 ) then
36940: LD_INT 50
36942: PPUSH
36943: CALL_OW 13
36947: IFFALSE 36993
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
36949: LD_INT 700
36951: PPUSH
36952: LD_INT 1050
36954: PPUSH
36955: CALL_OW 12
36959: PPUSH
36960: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
36964: LD_INT 1
36966: PPUSH
36967: LD_INT 5
36969: PPUSH
36970: CALL_OW 12
36974: PPUSH
36975: LD_INT 168
36977: PPUSH
36978: LD_INT 168
36980: PPUSH
36981: LD_INT 16
36983: PPUSH
36984: LD_INT 1
36986: PPUSH
36987: CALL_OW 56
// end else
36991: GO 37029
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
36993: LD_INT 350
36995: PPUSH
36996: LD_INT 525
36998: PPUSH
36999: CALL_OW 12
37003: PPUSH
37004: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
37008: LD_INT 1
37010: PPUSH
37011: LD_INT 5
37013: PPUSH
37014: CALL_OW 12
37018: PPUSH
37019: LD_INT 15
37021: PPUSH
37022: LD_INT 1
37024: PPUSH
37025: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
37029: LD_INT 175
37031: PPUSH
37032: LD_INT 315
37034: PPUSH
37035: CALL_OW 12
37039: PPUSH
37040: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
37044: LD_INT 1
37046: PPUSH
37047: LD_INT 5
37049: PPUSH
37050: CALL_OW 12
37054: PPUSH
37055: LD_INT 103
37057: PPUSH
37058: LD_INT 140
37060: PPUSH
37061: LD_INT 20
37063: PPUSH
37064: LD_INT 1
37066: PPUSH
37067: CALL_OW 56
// if time > 1 1$10 then
37071: LD_VAR 0 2
37075: PUSH
37076: LD_INT 2450
37078: GREATER
37079: IFFALSE 37089
// time := 0 0$30 ;
37081: LD_ADDR_VAR 0 2
37085: PUSH
37086: LD_INT 1050
37088: ST_TO_ADDR
// until false ;
37089: LD_INT 0
37091: IFFALSE 36729
// end ; end_of_file
37093: PPOPN 2
37095: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
37096: LD_EXP 13
37100: PUSH
37101: LD_EXP 15
37105: PUSH
37106: LD_INT 6
37108: GREATEREQUAL
37109: AND
37110: IFFALSE 37147
37112: GO 37114
37114: DISABLE
// begin enable ;
37115: ENABLE
// missionTime := missionTime + 0 0$1 ;
37116: LD_ADDR_EXP 14
37120: PUSH
37121: LD_EXP 14
37125: PUSH
37126: LD_INT 35
37128: PLUS
37129: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
37130: LD_ADDR_OWVAR 47
37134: PUSH
37135: LD_STRING #Am15-1
37137: PUSH
37138: LD_EXP 14
37142: PUSH
37143: EMPTY
37144: LIST
37145: LIST
37146: ST_TO_ADDR
// end ; end_of_file
37147: END
// export function InitNature ; begin
37148: LD_INT 0
37150: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
37151: LD_INT 3
37153: PPUSH
37154: LD_INT 3
37156: PPUSH
37157: LD_INT 2
37159: PPUSH
37160: LD_INT 1
37162: PPUSH
37163: LD_INT 1
37165: PPUSH
37166: LD_INT 0
37168: PPUSH
37169: LD_INT 0
37171: PPUSH
37172: LD_INT 20
37174: PPUSH
37175: LD_INT 0
37177: PPUSH
37178: CALL 101956 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
37182: LD_INT 2
37184: PPUSH
37185: LD_INT 1
37187: PPUSH
37188: LD_INT 1
37190: PPUSH
37191: LD_INT 1
37193: PPUSH
37194: LD_INT 1
37196: PPUSH
37197: LD_INT 0
37199: PPUSH
37200: LD_INT 0
37202: PPUSH
37203: LD_INT 21
37205: PPUSH
37206: LD_INT 0
37208: PPUSH
37209: CALL 101956 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
37213: LD_INT 4
37215: PPUSH
37216: LD_INT 1
37218: PPUSH
37219: LD_INT 2
37221: PPUSH
37222: LD_INT 4
37224: PPUSH
37225: LD_INT 2
37227: PPUSH
37228: LD_INT 1
37230: PPUSH
37231: LD_INT 0
37233: PPUSH
37234: LD_INT 22
37236: PPUSH
37237: LD_INT 0
37239: PPUSH
37240: CALL 101956 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
37244: LD_INT 0
37246: PPUSH
37247: LD_INT 0
37249: PPUSH
37250: LD_INT 0
37252: PPUSH
37253: LD_INT 0
37255: PPUSH
37256: LD_INT 0
37258: PPUSH
37259: LD_INT 0
37261: PPUSH
37262: LD_INT 9
37264: PPUSH
37265: LD_INT 0
37267: PPUSH
37268: LD_INT 23
37270: PPUSH
37271: CALL 101956 0 9
// end ; end_of_file
37275: LD_VAR 0 1
37279: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
37280: LD_INT 0
37282: PPUSH
37283: PPUSH
// skirmish := false ;
37284: LD_ADDR_EXP 98
37288: PUSH
37289: LD_INT 0
37291: ST_TO_ADDR
// debug_mc := false ;
37292: LD_ADDR_EXP 99
37296: PUSH
37297: LD_INT 0
37299: ST_TO_ADDR
// mc_bases := [ ] ;
37300: LD_ADDR_EXP 100
37304: PUSH
37305: EMPTY
37306: ST_TO_ADDR
// mc_sides := [ ] ;
37307: LD_ADDR_EXP 126
37311: PUSH
37312: EMPTY
37313: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
37314: LD_ADDR_EXP 101
37318: PUSH
37319: EMPTY
37320: ST_TO_ADDR
// mc_building_repairs := [ ] ;
37321: LD_ADDR_EXP 102
37325: PUSH
37326: EMPTY
37327: ST_TO_ADDR
// mc_need_heal := [ ] ;
37328: LD_ADDR_EXP 103
37332: PUSH
37333: EMPTY
37334: ST_TO_ADDR
// mc_healers := [ ] ;
37335: LD_ADDR_EXP 104
37339: PUSH
37340: EMPTY
37341: ST_TO_ADDR
// mc_build_list := [ ] ;
37342: LD_ADDR_EXP 105
37346: PUSH
37347: EMPTY
37348: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
37349: LD_ADDR_EXP 132
37353: PUSH
37354: EMPTY
37355: ST_TO_ADDR
// mc_builders := [ ] ;
37356: LD_ADDR_EXP 106
37360: PUSH
37361: EMPTY
37362: ST_TO_ADDR
// mc_construct_list := [ ] ;
37363: LD_ADDR_EXP 107
37367: PUSH
37368: EMPTY
37369: ST_TO_ADDR
// mc_turret_list := [ ] ;
37370: LD_ADDR_EXP 108
37374: PUSH
37375: EMPTY
37376: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
37377: LD_ADDR_EXP 109
37381: PUSH
37382: EMPTY
37383: ST_TO_ADDR
// mc_miners := [ ] ;
37384: LD_ADDR_EXP 114
37388: PUSH
37389: EMPTY
37390: ST_TO_ADDR
// mc_mines := [ ] ;
37391: LD_ADDR_EXP 113
37395: PUSH
37396: EMPTY
37397: ST_TO_ADDR
// mc_minefields := [ ] ;
37398: LD_ADDR_EXP 115
37402: PUSH
37403: EMPTY
37404: ST_TO_ADDR
// mc_crates := [ ] ;
37405: LD_ADDR_EXP 116
37409: PUSH
37410: EMPTY
37411: ST_TO_ADDR
// mc_crates_collector := [ ] ;
37412: LD_ADDR_EXP 117
37416: PUSH
37417: EMPTY
37418: ST_TO_ADDR
// mc_crates_area := [ ] ;
37419: LD_ADDR_EXP 118
37423: PUSH
37424: EMPTY
37425: ST_TO_ADDR
// mc_vehicles := [ ] ;
37426: LD_ADDR_EXP 119
37430: PUSH
37431: EMPTY
37432: ST_TO_ADDR
// mc_attack := [ ] ;
37433: LD_ADDR_EXP 120
37437: PUSH
37438: EMPTY
37439: ST_TO_ADDR
// mc_produce := [ ] ;
37440: LD_ADDR_EXP 121
37444: PUSH
37445: EMPTY
37446: ST_TO_ADDR
// mc_defender := [ ] ;
37447: LD_ADDR_EXP 122
37451: PUSH
37452: EMPTY
37453: ST_TO_ADDR
// mc_parking := [ ] ;
37454: LD_ADDR_EXP 124
37458: PUSH
37459: EMPTY
37460: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
37461: LD_ADDR_EXP 110
37465: PUSH
37466: EMPTY
37467: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
37468: LD_ADDR_EXP 112
37472: PUSH
37473: EMPTY
37474: ST_TO_ADDR
// mc_scan := [ ] ;
37475: LD_ADDR_EXP 123
37479: PUSH
37480: EMPTY
37481: ST_TO_ADDR
// mc_scan_area := [ ] ;
37482: LD_ADDR_EXP 125
37486: PUSH
37487: EMPTY
37488: ST_TO_ADDR
// mc_tech := [ ] ;
37489: LD_ADDR_EXP 127
37493: PUSH
37494: EMPTY
37495: ST_TO_ADDR
// mc_class := [ ] ;
37496: LD_ADDR_EXP 141
37500: PUSH
37501: EMPTY
37502: ST_TO_ADDR
// mc_class_case_use := [ ] ;
37503: LD_ADDR_EXP 142
37507: PUSH
37508: EMPTY
37509: ST_TO_ADDR
// mc_is_defending := [ ] ;
37510: LD_ADDR_EXP 143
37514: PUSH
37515: EMPTY
37516: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
37517: LD_ADDR_EXP 134
37521: PUSH
37522: EMPTY
37523: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
37524: LD_ADDR_EXP 144
37528: PUSH
37529: LD_INT 0
37531: ST_TO_ADDR
// end ;
37532: LD_VAR 0 1
37536: RET
// export function MC_Kill ( base ) ; begin
37537: LD_INT 0
37539: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
37540: LD_ADDR_EXP 100
37544: PUSH
37545: LD_EXP 100
37549: PPUSH
37550: LD_VAR 0 1
37554: PPUSH
37555: EMPTY
37556: PPUSH
37557: CALL_OW 1
37561: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
37562: LD_ADDR_EXP 101
37566: PUSH
37567: LD_EXP 101
37571: PPUSH
37572: LD_VAR 0 1
37576: PPUSH
37577: EMPTY
37578: PPUSH
37579: CALL_OW 1
37583: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
37584: LD_ADDR_EXP 102
37588: PUSH
37589: LD_EXP 102
37593: PPUSH
37594: LD_VAR 0 1
37598: PPUSH
37599: EMPTY
37600: PPUSH
37601: CALL_OW 1
37605: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
37606: LD_ADDR_EXP 103
37610: PUSH
37611: LD_EXP 103
37615: PPUSH
37616: LD_VAR 0 1
37620: PPUSH
37621: EMPTY
37622: PPUSH
37623: CALL_OW 1
37627: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
37628: LD_ADDR_EXP 104
37632: PUSH
37633: LD_EXP 104
37637: PPUSH
37638: LD_VAR 0 1
37642: PPUSH
37643: EMPTY
37644: PPUSH
37645: CALL_OW 1
37649: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
37650: LD_ADDR_EXP 105
37654: PUSH
37655: LD_EXP 105
37659: PPUSH
37660: LD_VAR 0 1
37664: PPUSH
37665: EMPTY
37666: PPUSH
37667: CALL_OW 1
37671: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
37672: LD_ADDR_EXP 106
37676: PUSH
37677: LD_EXP 106
37681: PPUSH
37682: LD_VAR 0 1
37686: PPUSH
37687: EMPTY
37688: PPUSH
37689: CALL_OW 1
37693: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
37694: LD_ADDR_EXP 107
37698: PUSH
37699: LD_EXP 107
37703: PPUSH
37704: LD_VAR 0 1
37708: PPUSH
37709: EMPTY
37710: PPUSH
37711: CALL_OW 1
37715: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
37716: LD_ADDR_EXP 108
37720: PUSH
37721: LD_EXP 108
37725: PPUSH
37726: LD_VAR 0 1
37730: PPUSH
37731: EMPTY
37732: PPUSH
37733: CALL_OW 1
37737: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
37738: LD_ADDR_EXP 109
37742: PUSH
37743: LD_EXP 109
37747: PPUSH
37748: LD_VAR 0 1
37752: PPUSH
37753: EMPTY
37754: PPUSH
37755: CALL_OW 1
37759: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
37760: LD_ADDR_EXP 110
37764: PUSH
37765: LD_EXP 110
37769: PPUSH
37770: LD_VAR 0 1
37774: PPUSH
37775: EMPTY
37776: PPUSH
37777: CALL_OW 1
37781: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
37782: LD_ADDR_EXP 111
37786: PUSH
37787: LD_EXP 111
37791: PPUSH
37792: LD_VAR 0 1
37796: PPUSH
37797: LD_INT 0
37799: PPUSH
37800: CALL_OW 1
37804: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
37805: LD_ADDR_EXP 112
37809: PUSH
37810: LD_EXP 112
37814: PPUSH
37815: LD_VAR 0 1
37819: PPUSH
37820: EMPTY
37821: PPUSH
37822: CALL_OW 1
37826: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
37827: LD_ADDR_EXP 113
37831: PUSH
37832: LD_EXP 113
37836: PPUSH
37837: LD_VAR 0 1
37841: PPUSH
37842: EMPTY
37843: PPUSH
37844: CALL_OW 1
37848: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
37849: LD_ADDR_EXP 114
37853: PUSH
37854: LD_EXP 114
37858: PPUSH
37859: LD_VAR 0 1
37863: PPUSH
37864: EMPTY
37865: PPUSH
37866: CALL_OW 1
37870: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
37871: LD_ADDR_EXP 115
37875: PUSH
37876: LD_EXP 115
37880: PPUSH
37881: LD_VAR 0 1
37885: PPUSH
37886: EMPTY
37887: PPUSH
37888: CALL_OW 1
37892: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
37893: LD_ADDR_EXP 116
37897: PUSH
37898: LD_EXP 116
37902: PPUSH
37903: LD_VAR 0 1
37907: PPUSH
37908: EMPTY
37909: PPUSH
37910: CALL_OW 1
37914: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
37915: LD_ADDR_EXP 117
37919: PUSH
37920: LD_EXP 117
37924: PPUSH
37925: LD_VAR 0 1
37929: PPUSH
37930: EMPTY
37931: PPUSH
37932: CALL_OW 1
37936: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
37937: LD_ADDR_EXP 118
37941: PUSH
37942: LD_EXP 118
37946: PPUSH
37947: LD_VAR 0 1
37951: PPUSH
37952: EMPTY
37953: PPUSH
37954: CALL_OW 1
37958: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
37959: LD_ADDR_EXP 119
37963: PUSH
37964: LD_EXP 119
37968: PPUSH
37969: LD_VAR 0 1
37973: PPUSH
37974: EMPTY
37975: PPUSH
37976: CALL_OW 1
37980: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
37981: LD_ADDR_EXP 120
37985: PUSH
37986: LD_EXP 120
37990: PPUSH
37991: LD_VAR 0 1
37995: PPUSH
37996: EMPTY
37997: PPUSH
37998: CALL_OW 1
38002: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
38003: LD_ADDR_EXP 121
38007: PUSH
38008: LD_EXP 121
38012: PPUSH
38013: LD_VAR 0 1
38017: PPUSH
38018: EMPTY
38019: PPUSH
38020: CALL_OW 1
38024: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
38025: LD_ADDR_EXP 122
38029: PUSH
38030: LD_EXP 122
38034: PPUSH
38035: LD_VAR 0 1
38039: PPUSH
38040: EMPTY
38041: PPUSH
38042: CALL_OW 1
38046: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
38047: LD_ADDR_EXP 123
38051: PUSH
38052: LD_EXP 123
38056: PPUSH
38057: LD_VAR 0 1
38061: PPUSH
38062: EMPTY
38063: PPUSH
38064: CALL_OW 1
38068: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
38069: LD_ADDR_EXP 124
38073: PUSH
38074: LD_EXP 124
38078: PPUSH
38079: LD_VAR 0 1
38083: PPUSH
38084: EMPTY
38085: PPUSH
38086: CALL_OW 1
38090: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
38091: LD_ADDR_EXP 125
38095: PUSH
38096: LD_EXP 125
38100: PPUSH
38101: LD_VAR 0 1
38105: PPUSH
38106: EMPTY
38107: PPUSH
38108: CALL_OW 1
38112: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
38113: LD_ADDR_EXP 127
38117: PUSH
38118: LD_EXP 127
38122: PPUSH
38123: LD_VAR 0 1
38127: PPUSH
38128: EMPTY
38129: PPUSH
38130: CALL_OW 1
38134: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
38135: LD_ADDR_EXP 129
38139: PUSH
38140: LD_EXP 129
38144: PPUSH
38145: LD_VAR 0 1
38149: PPUSH
38150: EMPTY
38151: PPUSH
38152: CALL_OW 1
38156: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
38157: LD_ADDR_EXP 130
38161: PUSH
38162: LD_EXP 130
38166: PPUSH
38167: LD_VAR 0 1
38171: PPUSH
38172: EMPTY
38173: PPUSH
38174: CALL_OW 1
38178: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
38179: LD_ADDR_EXP 131
38183: PUSH
38184: LD_EXP 131
38188: PPUSH
38189: LD_VAR 0 1
38193: PPUSH
38194: EMPTY
38195: PPUSH
38196: CALL_OW 1
38200: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
38201: LD_ADDR_EXP 132
38205: PUSH
38206: LD_EXP 132
38210: PPUSH
38211: LD_VAR 0 1
38215: PPUSH
38216: EMPTY
38217: PPUSH
38218: CALL_OW 1
38222: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
38223: LD_ADDR_EXP 133
38227: PUSH
38228: LD_EXP 133
38232: PPUSH
38233: LD_VAR 0 1
38237: PPUSH
38238: EMPTY
38239: PPUSH
38240: CALL_OW 1
38244: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
38245: LD_ADDR_EXP 134
38249: PUSH
38250: LD_EXP 134
38254: PPUSH
38255: LD_VAR 0 1
38259: PPUSH
38260: EMPTY
38261: PPUSH
38262: CALL_OW 1
38266: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
38267: LD_ADDR_EXP 135
38271: PUSH
38272: LD_EXP 135
38276: PPUSH
38277: LD_VAR 0 1
38281: PPUSH
38282: EMPTY
38283: PPUSH
38284: CALL_OW 1
38288: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
38289: LD_ADDR_EXP 136
38293: PUSH
38294: LD_EXP 136
38298: PPUSH
38299: LD_VAR 0 1
38303: PPUSH
38304: EMPTY
38305: PPUSH
38306: CALL_OW 1
38310: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
38311: LD_ADDR_EXP 137
38315: PUSH
38316: LD_EXP 137
38320: PPUSH
38321: LD_VAR 0 1
38325: PPUSH
38326: EMPTY
38327: PPUSH
38328: CALL_OW 1
38332: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
38333: LD_ADDR_EXP 138
38337: PUSH
38338: LD_EXP 138
38342: PPUSH
38343: LD_VAR 0 1
38347: PPUSH
38348: EMPTY
38349: PPUSH
38350: CALL_OW 1
38354: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
38355: LD_ADDR_EXP 139
38359: PUSH
38360: LD_EXP 139
38364: PPUSH
38365: LD_VAR 0 1
38369: PPUSH
38370: EMPTY
38371: PPUSH
38372: CALL_OW 1
38376: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
38377: LD_ADDR_EXP 140
38381: PUSH
38382: LD_EXP 140
38386: PPUSH
38387: LD_VAR 0 1
38391: PPUSH
38392: EMPTY
38393: PPUSH
38394: CALL_OW 1
38398: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
38399: LD_ADDR_EXP 141
38403: PUSH
38404: LD_EXP 141
38408: PPUSH
38409: LD_VAR 0 1
38413: PPUSH
38414: EMPTY
38415: PPUSH
38416: CALL_OW 1
38420: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
38421: LD_ADDR_EXP 142
38425: PUSH
38426: LD_EXP 142
38430: PPUSH
38431: LD_VAR 0 1
38435: PPUSH
38436: LD_INT 0
38438: PPUSH
38439: CALL_OW 1
38443: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
38444: LD_ADDR_EXP 143
38448: PUSH
38449: LD_EXP 143
38453: PPUSH
38454: LD_VAR 0 1
38458: PPUSH
38459: LD_INT 0
38461: PPUSH
38462: CALL_OW 1
38466: ST_TO_ADDR
// end ;
38467: LD_VAR 0 2
38471: RET
// export function MC_Add ( side , units ) ; var base ; begin
38472: LD_INT 0
38474: PPUSH
38475: PPUSH
// base := mc_bases + 1 ;
38476: LD_ADDR_VAR 0 4
38480: PUSH
38481: LD_EXP 100
38485: PUSH
38486: LD_INT 1
38488: PLUS
38489: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
38490: LD_ADDR_EXP 126
38494: PUSH
38495: LD_EXP 126
38499: PPUSH
38500: LD_VAR 0 4
38504: PPUSH
38505: LD_VAR 0 1
38509: PPUSH
38510: CALL_OW 1
38514: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
38515: LD_ADDR_EXP 100
38519: PUSH
38520: LD_EXP 100
38524: PPUSH
38525: LD_VAR 0 4
38529: PPUSH
38530: LD_VAR 0 2
38534: PPUSH
38535: CALL_OW 1
38539: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
38540: LD_ADDR_EXP 101
38544: PUSH
38545: LD_EXP 101
38549: PPUSH
38550: LD_VAR 0 4
38554: PPUSH
38555: EMPTY
38556: PPUSH
38557: CALL_OW 1
38561: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
38562: LD_ADDR_EXP 102
38566: PUSH
38567: LD_EXP 102
38571: PPUSH
38572: LD_VAR 0 4
38576: PPUSH
38577: EMPTY
38578: PPUSH
38579: CALL_OW 1
38583: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
38584: LD_ADDR_EXP 103
38588: PUSH
38589: LD_EXP 103
38593: PPUSH
38594: LD_VAR 0 4
38598: PPUSH
38599: EMPTY
38600: PPUSH
38601: CALL_OW 1
38605: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
38606: LD_ADDR_EXP 104
38610: PUSH
38611: LD_EXP 104
38615: PPUSH
38616: LD_VAR 0 4
38620: PPUSH
38621: EMPTY
38622: PPUSH
38623: CALL_OW 1
38627: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
38628: LD_ADDR_EXP 105
38632: PUSH
38633: LD_EXP 105
38637: PPUSH
38638: LD_VAR 0 4
38642: PPUSH
38643: EMPTY
38644: PPUSH
38645: CALL_OW 1
38649: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
38650: LD_ADDR_EXP 106
38654: PUSH
38655: LD_EXP 106
38659: PPUSH
38660: LD_VAR 0 4
38664: PPUSH
38665: EMPTY
38666: PPUSH
38667: CALL_OW 1
38671: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
38672: LD_ADDR_EXP 107
38676: PUSH
38677: LD_EXP 107
38681: PPUSH
38682: LD_VAR 0 4
38686: PPUSH
38687: EMPTY
38688: PPUSH
38689: CALL_OW 1
38693: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
38694: LD_ADDR_EXP 108
38698: PUSH
38699: LD_EXP 108
38703: PPUSH
38704: LD_VAR 0 4
38708: PPUSH
38709: EMPTY
38710: PPUSH
38711: CALL_OW 1
38715: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
38716: LD_ADDR_EXP 109
38720: PUSH
38721: LD_EXP 109
38725: PPUSH
38726: LD_VAR 0 4
38730: PPUSH
38731: EMPTY
38732: PPUSH
38733: CALL_OW 1
38737: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
38738: LD_ADDR_EXP 110
38742: PUSH
38743: LD_EXP 110
38747: PPUSH
38748: LD_VAR 0 4
38752: PPUSH
38753: EMPTY
38754: PPUSH
38755: CALL_OW 1
38759: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
38760: LD_ADDR_EXP 111
38764: PUSH
38765: LD_EXP 111
38769: PPUSH
38770: LD_VAR 0 4
38774: PPUSH
38775: LD_INT 0
38777: PPUSH
38778: CALL_OW 1
38782: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
38783: LD_ADDR_EXP 112
38787: PUSH
38788: LD_EXP 112
38792: PPUSH
38793: LD_VAR 0 4
38797: PPUSH
38798: EMPTY
38799: PPUSH
38800: CALL_OW 1
38804: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
38805: LD_ADDR_EXP 113
38809: PUSH
38810: LD_EXP 113
38814: PPUSH
38815: LD_VAR 0 4
38819: PPUSH
38820: EMPTY
38821: PPUSH
38822: CALL_OW 1
38826: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
38827: LD_ADDR_EXP 114
38831: PUSH
38832: LD_EXP 114
38836: PPUSH
38837: LD_VAR 0 4
38841: PPUSH
38842: EMPTY
38843: PPUSH
38844: CALL_OW 1
38848: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
38849: LD_ADDR_EXP 115
38853: PUSH
38854: LD_EXP 115
38858: PPUSH
38859: LD_VAR 0 4
38863: PPUSH
38864: EMPTY
38865: PPUSH
38866: CALL_OW 1
38870: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
38871: LD_ADDR_EXP 116
38875: PUSH
38876: LD_EXP 116
38880: PPUSH
38881: LD_VAR 0 4
38885: PPUSH
38886: EMPTY
38887: PPUSH
38888: CALL_OW 1
38892: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
38893: LD_ADDR_EXP 117
38897: PUSH
38898: LD_EXP 117
38902: PPUSH
38903: LD_VAR 0 4
38907: PPUSH
38908: EMPTY
38909: PPUSH
38910: CALL_OW 1
38914: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
38915: LD_ADDR_EXP 118
38919: PUSH
38920: LD_EXP 118
38924: PPUSH
38925: LD_VAR 0 4
38929: PPUSH
38930: EMPTY
38931: PPUSH
38932: CALL_OW 1
38936: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
38937: LD_ADDR_EXP 119
38941: PUSH
38942: LD_EXP 119
38946: PPUSH
38947: LD_VAR 0 4
38951: PPUSH
38952: EMPTY
38953: PPUSH
38954: CALL_OW 1
38958: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
38959: LD_ADDR_EXP 120
38963: PUSH
38964: LD_EXP 120
38968: PPUSH
38969: LD_VAR 0 4
38973: PPUSH
38974: EMPTY
38975: PPUSH
38976: CALL_OW 1
38980: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
38981: LD_ADDR_EXP 121
38985: PUSH
38986: LD_EXP 121
38990: PPUSH
38991: LD_VAR 0 4
38995: PPUSH
38996: EMPTY
38997: PPUSH
38998: CALL_OW 1
39002: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
39003: LD_ADDR_EXP 122
39007: PUSH
39008: LD_EXP 122
39012: PPUSH
39013: LD_VAR 0 4
39017: PPUSH
39018: EMPTY
39019: PPUSH
39020: CALL_OW 1
39024: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
39025: LD_ADDR_EXP 123
39029: PUSH
39030: LD_EXP 123
39034: PPUSH
39035: LD_VAR 0 4
39039: PPUSH
39040: EMPTY
39041: PPUSH
39042: CALL_OW 1
39046: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
39047: LD_ADDR_EXP 124
39051: PUSH
39052: LD_EXP 124
39056: PPUSH
39057: LD_VAR 0 4
39061: PPUSH
39062: EMPTY
39063: PPUSH
39064: CALL_OW 1
39068: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
39069: LD_ADDR_EXP 125
39073: PUSH
39074: LD_EXP 125
39078: PPUSH
39079: LD_VAR 0 4
39083: PPUSH
39084: EMPTY
39085: PPUSH
39086: CALL_OW 1
39090: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
39091: LD_ADDR_EXP 127
39095: PUSH
39096: LD_EXP 127
39100: PPUSH
39101: LD_VAR 0 4
39105: PPUSH
39106: EMPTY
39107: PPUSH
39108: CALL_OW 1
39112: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
39113: LD_ADDR_EXP 129
39117: PUSH
39118: LD_EXP 129
39122: PPUSH
39123: LD_VAR 0 4
39127: PPUSH
39128: EMPTY
39129: PPUSH
39130: CALL_OW 1
39134: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
39135: LD_ADDR_EXP 130
39139: PUSH
39140: LD_EXP 130
39144: PPUSH
39145: LD_VAR 0 4
39149: PPUSH
39150: EMPTY
39151: PPUSH
39152: CALL_OW 1
39156: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
39157: LD_ADDR_EXP 131
39161: PUSH
39162: LD_EXP 131
39166: PPUSH
39167: LD_VAR 0 4
39171: PPUSH
39172: EMPTY
39173: PPUSH
39174: CALL_OW 1
39178: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
39179: LD_ADDR_EXP 132
39183: PUSH
39184: LD_EXP 132
39188: PPUSH
39189: LD_VAR 0 4
39193: PPUSH
39194: EMPTY
39195: PPUSH
39196: CALL_OW 1
39200: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
39201: LD_ADDR_EXP 133
39205: PUSH
39206: LD_EXP 133
39210: PPUSH
39211: LD_VAR 0 4
39215: PPUSH
39216: EMPTY
39217: PPUSH
39218: CALL_OW 1
39222: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
39223: LD_ADDR_EXP 134
39227: PUSH
39228: LD_EXP 134
39232: PPUSH
39233: LD_VAR 0 4
39237: PPUSH
39238: EMPTY
39239: PPUSH
39240: CALL_OW 1
39244: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
39245: LD_ADDR_EXP 135
39249: PUSH
39250: LD_EXP 135
39254: PPUSH
39255: LD_VAR 0 4
39259: PPUSH
39260: EMPTY
39261: PPUSH
39262: CALL_OW 1
39266: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
39267: LD_ADDR_EXP 136
39271: PUSH
39272: LD_EXP 136
39276: PPUSH
39277: LD_VAR 0 4
39281: PPUSH
39282: EMPTY
39283: PPUSH
39284: CALL_OW 1
39288: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
39289: LD_ADDR_EXP 137
39293: PUSH
39294: LD_EXP 137
39298: PPUSH
39299: LD_VAR 0 4
39303: PPUSH
39304: EMPTY
39305: PPUSH
39306: CALL_OW 1
39310: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
39311: LD_ADDR_EXP 138
39315: PUSH
39316: LD_EXP 138
39320: PPUSH
39321: LD_VAR 0 4
39325: PPUSH
39326: EMPTY
39327: PPUSH
39328: CALL_OW 1
39332: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
39333: LD_ADDR_EXP 139
39337: PUSH
39338: LD_EXP 139
39342: PPUSH
39343: LD_VAR 0 4
39347: PPUSH
39348: EMPTY
39349: PPUSH
39350: CALL_OW 1
39354: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
39355: LD_ADDR_EXP 140
39359: PUSH
39360: LD_EXP 140
39364: PPUSH
39365: LD_VAR 0 4
39369: PPUSH
39370: EMPTY
39371: PPUSH
39372: CALL_OW 1
39376: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
39377: LD_ADDR_EXP 141
39381: PUSH
39382: LD_EXP 141
39386: PPUSH
39387: LD_VAR 0 4
39391: PPUSH
39392: EMPTY
39393: PPUSH
39394: CALL_OW 1
39398: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
39399: LD_ADDR_EXP 142
39403: PUSH
39404: LD_EXP 142
39408: PPUSH
39409: LD_VAR 0 4
39413: PPUSH
39414: LD_INT 0
39416: PPUSH
39417: CALL_OW 1
39421: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
39422: LD_ADDR_EXP 143
39426: PUSH
39427: LD_EXP 143
39431: PPUSH
39432: LD_VAR 0 4
39436: PPUSH
39437: LD_INT 0
39439: PPUSH
39440: CALL_OW 1
39444: ST_TO_ADDR
// result := base ;
39445: LD_ADDR_VAR 0 3
39449: PUSH
39450: LD_VAR 0 4
39454: ST_TO_ADDR
// end ;
39455: LD_VAR 0 3
39459: RET
// export function MC_Start ( ) ; var i ; begin
39460: LD_INT 0
39462: PPUSH
39463: PPUSH
// for i = 1 to mc_bases do
39464: LD_ADDR_VAR 0 2
39468: PUSH
39469: DOUBLE
39470: LD_INT 1
39472: DEC
39473: ST_TO_ADDR
39474: LD_EXP 100
39478: PUSH
39479: FOR_TO
39480: IFFALSE 40580
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
39482: LD_ADDR_EXP 100
39486: PUSH
39487: LD_EXP 100
39491: PPUSH
39492: LD_VAR 0 2
39496: PPUSH
39497: LD_EXP 100
39501: PUSH
39502: LD_VAR 0 2
39506: ARRAY
39507: PUSH
39508: LD_INT 0
39510: DIFF
39511: PPUSH
39512: CALL_OW 1
39516: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
39517: LD_ADDR_EXP 101
39521: PUSH
39522: LD_EXP 101
39526: PPUSH
39527: LD_VAR 0 2
39531: PPUSH
39532: EMPTY
39533: PPUSH
39534: CALL_OW 1
39538: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
39539: LD_ADDR_EXP 102
39543: PUSH
39544: LD_EXP 102
39548: PPUSH
39549: LD_VAR 0 2
39553: PPUSH
39554: EMPTY
39555: PPUSH
39556: CALL_OW 1
39560: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
39561: LD_ADDR_EXP 103
39565: PUSH
39566: LD_EXP 103
39570: PPUSH
39571: LD_VAR 0 2
39575: PPUSH
39576: EMPTY
39577: PPUSH
39578: CALL_OW 1
39582: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
39583: LD_ADDR_EXP 104
39587: PUSH
39588: LD_EXP 104
39592: PPUSH
39593: LD_VAR 0 2
39597: PPUSH
39598: EMPTY
39599: PUSH
39600: EMPTY
39601: PUSH
39602: EMPTY
39603: LIST
39604: LIST
39605: PPUSH
39606: CALL_OW 1
39610: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
39611: LD_ADDR_EXP 105
39615: PUSH
39616: LD_EXP 105
39620: PPUSH
39621: LD_VAR 0 2
39625: PPUSH
39626: EMPTY
39627: PPUSH
39628: CALL_OW 1
39632: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
39633: LD_ADDR_EXP 132
39637: PUSH
39638: LD_EXP 132
39642: PPUSH
39643: LD_VAR 0 2
39647: PPUSH
39648: EMPTY
39649: PPUSH
39650: CALL_OW 1
39654: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
39655: LD_ADDR_EXP 106
39659: PUSH
39660: LD_EXP 106
39664: PPUSH
39665: LD_VAR 0 2
39669: PPUSH
39670: EMPTY
39671: PPUSH
39672: CALL_OW 1
39676: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
39677: LD_ADDR_EXP 107
39681: PUSH
39682: LD_EXP 107
39686: PPUSH
39687: LD_VAR 0 2
39691: PPUSH
39692: EMPTY
39693: PPUSH
39694: CALL_OW 1
39698: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
39699: LD_ADDR_EXP 108
39703: PUSH
39704: LD_EXP 108
39708: PPUSH
39709: LD_VAR 0 2
39713: PPUSH
39714: LD_EXP 100
39718: PUSH
39719: LD_VAR 0 2
39723: ARRAY
39724: PPUSH
39725: LD_INT 2
39727: PUSH
39728: LD_INT 30
39730: PUSH
39731: LD_INT 32
39733: PUSH
39734: EMPTY
39735: LIST
39736: LIST
39737: PUSH
39738: LD_INT 30
39740: PUSH
39741: LD_INT 33
39743: PUSH
39744: EMPTY
39745: LIST
39746: LIST
39747: PUSH
39748: EMPTY
39749: LIST
39750: LIST
39751: LIST
39752: PPUSH
39753: CALL_OW 72
39757: PPUSH
39758: CALL_OW 1
39762: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
39763: LD_ADDR_EXP 109
39767: PUSH
39768: LD_EXP 109
39772: PPUSH
39773: LD_VAR 0 2
39777: PPUSH
39778: LD_EXP 100
39782: PUSH
39783: LD_VAR 0 2
39787: ARRAY
39788: PPUSH
39789: LD_INT 2
39791: PUSH
39792: LD_INT 30
39794: PUSH
39795: LD_INT 32
39797: PUSH
39798: EMPTY
39799: LIST
39800: LIST
39801: PUSH
39802: LD_INT 30
39804: PUSH
39805: LD_INT 31
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: EMPTY
39813: LIST
39814: LIST
39815: LIST
39816: PUSH
39817: LD_INT 58
39819: PUSH
39820: EMPTY
39821: LIST
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: PPUSH
39827: CALL_OW 72
39831: PPUSH
39832: CALL_OW 1
39836: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
39837: LD_ADDR_EXP 110
39841: PUSH
39842: LD_EXP 110
39846: PPUSH
39847: LD_VAR 0 2
39851: PPUSH
39852: EMPTY
39853: PPUSH
39854: CALL_OW 1
39858: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
39859: LD_ADDR_EXP 114
39863: PUSH
39864: LD_EXP 114
39868: PPUSH
39869: LD_VAR 0 2
39873: PPUSH
39874: EMPTY
39875: PPUSH
39876: CALL_OW 1
39880: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
39881: LD_ADDR_EXP 113
39885: PUSH
39886: LD_EXP 113
39890: PPUSH
39891: LD_VAR 0 2
39895: PPUSH
39896: EMPTY
39897: PPUSH
39898: CALL_OW 1
39902: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
39903: LD_ADDR_EXP 115
39907: PUSH
39908: LD_EXP 115
39912: PPUSH
39913: LD_VAR 0 2
39917: PPUSH
39918: EMPTY
39919: PPUSH
39920: CALL_OW 1
39924: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
39925: LD_ADDR_EXP 116
39929: PUSH
39930: LD_EXP 116
39934: PPUSH
39935: LD_VAR 0 2
39939: PPUSH
39940: EMPTY
39941: PPUSH
39942: CALL_OW 1
39946: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
39947: LD_ADDR_EXP 117
39951: PUSH
39952: LD_EXP 117
39956: PPUSH
39957: LD_VAR 0 2
39961: PPUSH
39962: EMPTY
39963: PPUSH
39964: CALL_OW 1
39968: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
39969: LD_ADDR_EXP 118
39973: PUSH
39974: LD_EXP 118
39978: PPUSH
39979: LD_VAR 0 2
39983: PPUSH
39984: EMPTY
39985: PPUSH
39986: CALL_OW 1
39990: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
39991: LD_ADDR_EXP 119
39995: PUSH
39996: LD_EXP 119
40000: PPUSH
40001: LD_VAR 0 2
40005: PPUSH
40006: EMPTY
40007: PPUSH
40008: CALL_OW 1
40012: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
40013: LD_ADDR_EXP 120
40017: PUSH
40018: LD_EXP 120
40022: PPUSH
40023: LD_VAR 0 2
40027: PPUSH
40028: EMPTY
40029: PPUSH
40030: CALL_OW 1
40034: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
40035: LD_ADDR_EXP 121
40039: PUSH
40040: LD_EXP 121
40044: PPUSH
40045: LD_VAR 0 2
40049: PPUSH
40050: EMPTY
40051: PPUSH
40052: CALL_OW 1
40056: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
40057: LD_ADDR_EXP 122
40061: PUSH
40062: LD_EXP 122
40066: PPUSH
40067: LD_VAR 0 2
40071: PPUSH
40072: EMPTY
40073: PPUSH
40074: CALL_OW 1
40078: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
40079: LD_ADDR_EXP 111
40083: PUSH
40084: LD_EXP 111
40088: PPUSH
40089: LD_VAR 0 2
40093: PPUSH
40094: LD_INT 0
40096: PPUSH
40097: CALL_OW 1
40101: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
40102: LD_ADDR_EXP 124
40106: PUSH
40107: LD_EXP 124
40111: PPUSH
40112: LD_VAR 0 2
40116: PPUSH
40117: LD_INT 0
40119: PPUSH
40120: CALL_OW 1
40124: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
40125: LD_ADDR_EXP 112
40129: PUSH
40130: LD_EXP 112
40134: PPUSH
40135: LD_VAR 0 2
40139: PPUSH
40140: EMPTY
40141: PPUSH
40142: CALL_OW 1
40146: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
40147: LD_ADDR_EXP 123
40151: PUSH
40152: LD_EXP 123
40156: PPUSH
40157: LD_VAR 0 2
40161: PPUSH
40162: LD_INT 0
40164: PPUSH
40165: CALL_OW 1
40169: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
40170: LD_ADDR_EXP 125
40174: PUSH
40175: LD_EXP 125
40179: PPUSH
40180: LD_VAR 0 2
40184: PPUSH
40185: EMPTY
40186: PPUSH
40187: CALL_OW 1
40191: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
40192: LD_ADDR_EXP 128
40196: PUSH
40197: LD_EXP 128
40201: PPUSH
40202: LD_VAR 0 2
40206: PPUSH
40207: LD_INT 0
40209: PPUSH
40210: CALL_OW 1
40214: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
40215: LD_ADDR_EXP 129
40219: PUSH
40220: LD_EXP 129
40224: PPUSH
40225: LD_VAR 0 2
40229: PPUSH
40230: EMPTY
40231: PPUSH
40232: CALL_OW 1
40236: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
40237: LD_ADDR_EXP 130
40241: PUSH
40242: LD_EXP 130
40246: PPUSH
40247: LD_VAR 0 2
40251: PPUSH
40252: EMPTY
40253: PPUSH
40254: CALL_OW 1
40258: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
40259: LD_ADDR_EXP 131
40263: PUSH
40264: LD_EXP 131
40268: PPUSH
40269: LD_VAR 0 2
40273: PPUSH
40274: EMPTY
40275: PPUSH
40276: CALL_OW 1
40280: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
40281: LD_ADDR_EXP 133
40285: PUSH
40286: LD_EXP 133
40290: PPUSH
40291: LD_VAR 0 2
40295: PPUSH
40296: LD_EXP 100
40300: PUSH
40301: LD_VAR 0 2
40305: ARRAY
40306: PPUSH
40307: LD_INT 2
40309: PUSH
40310: LD_INT 30
40312: PUSH
40313: LD_INT 6
40315: PUSH
40316: EMPTY
40317: LIST
40318: LIST
40319: PUSH
40320: LD_INT 30
40322: PUSH
40323: LD_INT 7
40325: PUSH
40326: EMPTY
40327: LIST
40328: LIST
40329: PUSH
40330: LD_INT 30
40332: PUSH
40333: LD_INT 8
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: PUSH
40340: EMPTY
40341: LIST
40342: LIST
40343: LIST
40344: LIST
40345: PPUSH
40346: CALL_OW 72
40350: PPUSH
40351: CALL_OW 1
40355: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
40356: LD_ADDR_EXP 134
40360: PUSH
40361: LD_EXP 134
40365: PPUSH
40366: LD_VAR 0 2
40370: PPUSH
40371: EMPTY
40372: PPUSH
40373: CALL_OW 1
40377: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
40378: LD_ADDR_EXP 135
40382: PUSH
40383: LD_EXP 135
40387: PPUSH
40388: LD_VAR 0 2
40392: PPUSH
40393: EMPTY
40394: PPUSH
40395: CALL_OW 1
40399: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
40400: LD_ADDR_EXP 136
40404: PUSH
40405: LD_EXP 136
40409: PPUSH
40410: LD_VAR 0 2
40414: PPUSH
40415: EMPTY
40416: PPUSH
40417: CALL_OW 1
40421: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
40422: LD_ADDR_EXP 137
40426: PUSH
40427: LD_EXP 137
40431: PPUSH
40432: LD_VAR 0 2
40436: PPUSH
40437: EMPTY
40438: PPUSH
40439: CALL_OW 1
40443: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
40444: LD_ADDR_EXP 138
40448: PUSH
40449: LD_EXP 138
40453: PPUSH
40454: LD_VAR 0 2
40458: PPUSH
40459: EMPTY
40460: PPUSH
40461: CALL_OW 1
40465: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
40466: LD_ADDR_EXP 139
40470: PUSH
40471: LD_EXP 139
40475: PPUSH
40476: LD_VAR 0 2
40480: PPUSH
40481: EMPTY
40482: PPUSH
40483: CALL_OW 1
40487: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
40488: LD_ADDR_EXP 140
40492: PUSH
40493: LD_EXP 140
40497: PPUSH
40498: LD_VAR 0 2
40502: PPUSH
40503: EMPTY
40504: PPUSH
40505: CALL_OW 1
40509: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
40510: LD_ADDR_EXP 141
40514: PUSH
40515: LD_EXP 141
40519: PPUSH
40520: LD_VAR 0 2
40524: PPUSH
40525: EMPTY
40526: PPUSH
40527: CALL_OW 1
40531: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
40532: LD_ADDR_EXP 142
40536: PUSH
40537: LD_EXP 142
40541: PPUSH
40542: LD_VAR 0 2
40546: PPUSH
40547: LD_INT 0
40549: PPUSH
40550: CALL_OW 1
40554: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
40555: LD_ADDR_EXP 143
40559: PUSH
40560: LD_EXP 143
40564: PPUSH
40565: LD_VAR 0 2
40569: PPUSH
40570: LD_INT 0
40572: PPUSH
40573: CALL_OW 1
40577: ST_TO_ADDR
// end ;
40578: GO 39479
40580: POP
40581: POP
// MC_InitSides ( ) ;
40582: CALL 40868 0 0
// MC_InitResearch ( ) ;
40586: CALL 40607 0 0
// CustomInitMacro ( ) ;
40590: CALL 475 0 0
// skirmish := true ;
40594: LD_ADDR_EXP 98
40598: PUSH
40599: LD_INT 1
40601: ST_TO_ADDR
// end ;
40602: LD_VAR 0 1
40606: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
40607: LD_INT 0
40609: PPUSH
40610: PPUSH
40611: PPUSH
40612: PPUSH
40613: PPUSH
40614: PPUSH
// if not mc_bases then
40615: LD_EXP 100
40619: NOT
40620: IFFALSE 40624
// exit ;
40622: GO 40863
// for i = 1 to 8 do
40624: LD_ADDR_VAR 0 2
40628: PUSH
40629: DOUBLE
40630: LD_INT 1
40632: DEC
40633: ST_TO_ADDR
40634: LD_INT 8
40636: PUSH
40637: FOR_TO
40638: IFFALSE 40664
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
40640: LD_ADDR_EXP 127
40644: PUSH
40645: LD_EXP 127
40649: PPUSH
40650: LD_VAR 0 2
40654: PPUSH
40655: EMPTY
40656: PPUSH
40657: CALL_OW 1
40661: ST_TO_ADDR
40662: GO 40637
40664: POP
40665: POP
// tmp := [ ] ;
40666: LD_ADDR_VAR 0 5
40670: PUSH
40671: EMPTY
40672: ST_TO_ADDR
// for i = 1 to mc_sides do
40673: LD_ADDR_VAR 0 2
40677: PUSH
40678: DOUBLE
40679: LD_INT 1
40681: DEC
40682: ST_TO_ADDR
40683: LD_EXP 126
40687: PUSH
40688: FOR_TO
40689: IFFALSE 40747
// if not mc_sides [ i ] in tmp then
40691: LD_EXP 126
40695: PUSH
40696: LD_VAR 0 2
40700: ARRAY
40701: PUSH
40702: LD_VAR 0 5
40706: IN
40707: NOT
40708: IFFALSE 40745
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
40710: LD_ADDR_VAR 0 5
40714: PUSH
40715: LD_VAR 0 5
40719: PPUSH
40720: LD_VAR 0 5
40724: PUSH
40725: LD_INT 1
40727: PLUS
40728: PPUSH
40729: LD_EXP 126
40733: PUSH
40734: LD_VAR 0 2
40738: ARRAY
40739: PPUSH
40740: CALL_OW 2
40744: ST_TO_ADDR
40745: GO 40688
40747: POP
40748: POP
// if not tmp then
40749: LD_VAR 0 5
40753: NOT
40754: IFFALSE 40758
// exit ;
40756: GO 40863
// for j in tmp do
40758: LD_ADDR_VAR 0 3
40762: PUSH
40763: LD_VAR 0 5
40767: PUSH
40768: FOR_IN
40769: IFFALSE 40861
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
40771: LD_ADDR_VAR 0 6
40775: PUSH
40776: LD_INT 22
40778: PUSH
40779: LD_VAR 0 3
40783: PUSH
40784: EMPTY
40785: LIST
40786: LIST
40787: PPUSH
40788: CALL_OW 69
40792: ST_TO_ADDR
// if not un then
40793: LD_VAR 0 6
40797: NOT
40798: IFFALSE 40802
// continue ;
40800: GO 40768
// nation := GetNation ( un [ 1 ] ) ;
40802: LD_ADDR_VAR 0 4
40806: PUSH
40807: LD_VAR 0 6
40811: PUSH
40812: LD_INT 1
40814: ARRAY
40815: PPUSH
40816: CALL_OW 248
40820: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
40821: LD_ADDR_EXP 127
40825: PUSH
40826: LD_EXP 127
40830: PPUSH
40831: LD_VAR 0 3
40835: PPUSH
40836: LD_VAR 0 3
40840: PPUSH
40841: LD_VAR 0 4
40845: PPUSH
40846: LD_INT 1
40848: PPUSH
40849: CALL 68037 0 3
40853: PPUSH
40854: CALL_OW 1
40858: ST_TO_ADDR
// end ;
40859: GO 40768
40861: POP
40862: POP
// end ;
40863: LD_VAR 0 1
40867: RET
// export function MC_InitSides ( ) ; var i ; begin
40868: LD_INT 0
40870: PPUSH
40871: PPUSH
// if not mc_bases then
40872: LD_EXP 100
40876: NOT
40877: IFFALSE 40881
// exit ;
40879: GO 40955
// for i = 1 to mc_bases do
40881: LD_ADDR_VAR 0 2
40885: PUSH
40886: DOUBLE
40887: LD_INT 1
40889: DEC
40890: ST_TO_ADDR
40891: LD_EXP 100
40895: PUSH
40896: FOR_TO
40897: IFFALSE 40953
// if mc_bases [ i ] then
40899: LD_EXP 100
40903: PUSH
40904: LD_VAR 0 2
40908: ARRAY
40909: IFFALSE 40951
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
40911: LD_ADDR_EXP 126
40915: PUSH
40916: LD_EXP 126
40920: PPUSH
40921: LD_VAR 0 2
40925: PPUSH
40926: LD_EXP 100
40930: PUSH
40931: LD_VAR 0 2
40935: ARRAY
40936: PUSH
40937: LD_INT 1
40939: ARRAY
40940: PPUSH
40941: CALL_OW 255
40945: PPUSH
40946: CALL_OW 1
40950: ST_TO_ADDR
40951: GO 40896
40953: POP
40954: POP
// end ;
40955: LD_VAR 0 1
40959: RET
// every 0 0$03 trigger skirmish do
40960: LD_EXP 98
40964: IFFALSE 41118
40966: GO 40968
40968: DISABLE
// begin enable ;
40969: ENABLE
// MC_CheckBuildings ( ) ;
40970: CALL 45616 0 0
// MC_CheckPeopleLife ( ) ;
40974: CALL 45777 0 0
// RaiseSailEvent ( 100 ) ;
40978: LD_INT 100
40980: PPUSH
40981: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
40985: LD_INT 103
40987: PPUSH
40988: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
40992: LD_INT 104
40994: PPUSH
40995: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
40999: LD_INT 105
41001: PPUSH
41002: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
41006: LD_INT 106
41008: PPUSH
41009: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
41013: LD_INT 107
41015: PPUSH
41016: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
41020: LD_INT 108
41022: PPUSH
41023: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
41027: LD_INT 109
41029: PPUSH
41030: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
41034: LD_INT 110
41036: PPUSH
41037: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
41041: LD_INT 111
41043: PPUSH
41044: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
41048: LD_INT 112
41050: PPUSH
41051: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
41055: LD_INT 113
41057: PPUSH
41058: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
41062: LD_INT 120
41064: PPUSH
41065: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
41069: LD_INT 121
41071: PPUSH
41072: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
41076: LD_INT 122
41078: PPUSH
41079: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
41083: LD_INT 123
41085: PPUSH
41086: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
41090: LD_INT 124
41092: PPUSH
41093: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
41097: LD_INT 125
41099: PPUSH
41100: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
41104: LD_INT 126
41106: PPUSH
41107: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
41111: LD_INT 200
41113: PPUSH
41114: CALL_OW 427
// end ;
41118: END
// on SailEvent ( event ) do begin if event < 100 then
41119: LD_VAR 0 1
41123: PUSH
41124: LD_INT 100
41126: LESS
41127: IFFALSE 41138
// CustomEvent ( event ) ;
41129: LD_VAR 0 1
41133: PPUSH
41134: CALL 35553 0 1
// if event = 100 then
41138: LD_VAR 0 1
41142: PUSH
41143: LD_INT 100
41145: EQUAL
41146: IFFALSE 41152
// MC_ClassManager ( ) ;
41148: CALL 41544 0 0
// if event = 101 then
41152: LD_VAR 0 1
41156: PUSH
41157: LD_INT 101
41159: EQUAL
41160: IFFALSE 41166
// MC_RepairBuildings ( ) ;
41162: CALL 46362 0 0
// if event = 102 then
41166: LD_VAR 0 1
41170: PUSH
41171: LD_INT 102
41173: EQUAL
41174: IFFALSE 41180
// MC_Heal ( ) ;
41176: CALL 47297 0 0
// if event = 103 then
41180: LD_VAR 0 1
41184: PUSH
41185: LD_INT 103
41187: EQUAL
41188: IFFALSE 41194
// MC_Build ( ) ;
41190: CALL 47719 0 0
// if event = 104 then
41194: LD_VAR 0 1
41198: PUSH
41199: LD_INT 104
41201: EQUAL
41202: IFFALSE 41208
// MC_TurretWeapon ( ) ;
41204: CALL 49353 0 0
// if event = 105 then
41208: LD_VAR 0 1
41212: PUSH
41213: LD_INT 105
41215: EQUAL
41216: IFFALSE 41222
// MC_BuildUpgrade ( ) ;
41218: CALL 48904 0 0
// if event = 106 then
41222: LD_VAR 0 1
41226: PUSH
41227: LD_INT 106
41229: EQUAL
41230: IFFALSE 41236
// MC_PlantMines ( ) ;
41232: CALL 49783 0 0
// if event = 107 then
41236: LD_VAR 0 1
41240: PUSH
41241: LD_INT 107
41243: EQUAL
41244: IFFALSE 41250
// MC_CollectCrates ( ) ;
41246: CALL 50581 0 0
// if event = 108 then
41250: LD_VAR 0 1
41254: PUSH
41255: LD_INT 108
41257: EQUAL
41258: IFFALSE 41264
// MC_LinkRemoteControl ( ) ;
41260: CALL 52431 0 0
// if event = 109 then
41264: LD_VAR 0 1
41268: PUSH
41269: LD_INT 109
41271: EQUAL
41272: IFFALSE 41278
// MC_ProduceVehicle ( ) ;
41274: CALL 52612 0 0
// if event = 110 then
41278: LD_VAR 0 1
41282: PUSH
41283: LD_INT 110
41285: EQUAL
41286: IFFALSE 41292
// MC_SendAttack ( ) ;
41288: CALL 53078 0 0
// if event = 111 then
41292: LD_VAR 0 1
41296: PUSH
41297: LD_INT 111
41299: EQUAL
41300: IFFALSE 41306
// MC_Defend ( ) ;
41302: CALL 53186 0 0
// if event = 112 then
41306: LD_VAR 0 1
41310: PUSH
41311: LD_INT 112
41313: EQUAL
41314: IFFALSE 41320
// MC_Research ( ) ;
41316: CALL 54066 0 0
// if event = 113 then
41320: LD_VAR 0 1
41324: PUSH
41325: LD_INT 113
41327: EQUAL
41328: IFFALSE 41334
// MC_MinesTrigger ( ) ;
41330: CALL 55180 0 0
// if event = 120 then
41334: LD_VAR 0 1
41338: PUSH
41339: LD_INT 120
41341: EQUAL
41342: IFFALSE 41348
// MC_RepairVehicle ( ) ;
41344: CALL 55279 0 0
// if event = 121 then
41348: LD_VAR 0 1
41352: PUSH
41353: LD_INT 121
41355: EQUAL
41356: IFFALSE 41362
// MC_TameApe ( ) ;
41358: CALL 56048 0 0
// if event = 122 then
41362: LD_VAR 0 1
41366: PUSH
41367: LD_INT 122
41369: EQUAL
41370: IFFALSE 41376
// MC_ChangeApeClass ( ) ;
41372: CALL 56877 0 0
// if event = 123 then
41376: LD_VAR 0 1
41380: PUSH
41381: LD_INT 123
41383: EQUAL
41384: IFFALSE 41390
// MC_Bazooka ( ) ;
41386: CALL 57527 0 0
// if event = 124 then
41390: LD_VAR 0 1
41394: PUSH
41395: LD_INT 124
41397: EQUAL
41398: IFFALSE 41404
// MC_TeleportExit ( ) ;
41400: CALL 57725 0 0
// if event = 125 then
41404: LD_VAR 0 1
41408: PUSH
41409: LD_INT 125
41411: EQUAL
41412: IFFALSE 41418
// MC_Deposits ( ) ;
41414: CALL 58372 0 0
// if event = 126 then
41418: LD_VAR 0 1
41422: PUSH
41423: LD_INT 126
41425: EQUAL
41426: IFFALSE 41432
// MC_RemoteDriver ( ) ;
41428: CALL 58997 0 0
// if event = 200 then
41432: LD_VAR 0 1
41436: PUSH
41437: LD_INT 200
41439: EQUAL
41440: IFFALSE 41446
// MC_Idle ( ) ;
41442: CALL 60904 0 0
// end ;
41446: PPOPN 1
41448: END
// export function MC_Reset ( base , tag ) ; var i ; begin
41449: LD_INT 0
41451: PPUSH
41452: PPUSH
// if not mc_bases [ base ] or not tag then
41453: LD_EXP 100
41457: PUSH
41458: LD_VAR 0 1
41462: ARRAY
41463: NOT
41464: PUSH
41465: LD_VAR 0 2
41469: NOT
41470: OR
41471: IFFALSE 41475
// exit ;
41473: GO 41539
// for i in mc_bases [ base ] union mc_ape [ base ] do
41475: LD_ADDR_VAR 0 4
41479: PUSH
41480: LD_EXP 100
41484: PUSH
41485: LD_VAR 0 1
41489: ARRAY
41490: PUSH
41491: LD_EXP 129
41495: PUSH
41496: LD_VAR 0 1
41500: ARRAY
41501: UNION
41502: PUSH
41503: FOR_IN
41504: IFFALSE 41537
// if GetTag ( i ) = tag then
41506: LD_VAR 0 4
41510: PPUSH
41511: CALL_OW 110
41515: PUSH
41516: LD_VAR 0 2
41520: EQUAL
41521: IFFALSE 41535
// SetTag ( i , 0 ) ;
41523: LD_VAR 0 4
41527: PPUSH
41528: LD_INT 0
41530: PPUSH
41531: CALL_OW 109
41535: GO 41503
41537: POP
41538: POP
// end ;
41539: LD_VAR 0 3
41543: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
41544: LD_INT 0
41546: PPUSH
41547: PPUSH
41548: PPUSH
41549: PPUSH
41550: PPUSH
41551: PPUSH
41552: PPUSH
41553: PPUSH
// if not mc_bases then
41554: LD_EXP 100
41558: NOT
41559: IFFALSE 41563
// exit ;
41561: GO 42021
// for i = 1 to mc_bases do
41563: LD_ADDR_VAR 0 2
41567: PUSH
41568: DOUBLE
41569: LD_INT 1
41571: DEC
41572: ST_TO_ADDR
41573: LD_EXP 100
41577: PUSH
41578: FOR_TO
41579: IFFALSE 42019
// begin tmp := MC_ClassCheckReq ( i ) ;
41581: LD_ADDR_VAR 0 4
41585: PUSH
41586: LD_VAR 0 2
41590: PPUSH
41591: CALL 42026 0 1
41595: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
41596: LD_ADDR_EXP 141
41600: PUSH
41601: LD_EXP 141
41605: PPUSH
41606: LD_VAR 0 2
41610: PPUSH
41611: LD_VAR 0 4
41615: PPUSH
41616: CALL_OW 1
41620: ST_TO_ADDR
// if not tmp then
41621: LD_VAR 0 4
41625: NOT
41626: IFFALSE 41630
// continue ;
41628: GO 41578
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
41630: LD_ADDR_VAR 0 6
41634: PUSH
41635: LD_EXP 100
41639: PUSH
41640: LD_VAR 0 2
41644: ARRAY
41645: PPUSH
41646: LD_INT 2
41648: PUSH
41649: LD_INT 30
41651: PUSH
41652: LD_INT 4
41654: PUSH
41655: EMPTY
41656: LIST
41657: LIST
41658: PUSH
41659: LD_INT 30
41661: PUSH
41662: LD_INT 5
41664: PUSH
41665: EMPTY
41666: LIST
41667: LIST
41668: PUSH
41669: EMPTY
41670: LIST
41671: LIST
41672: LIST
41673: PPUSH
41674: CALL_OW 72
41678: PUSH
41679: LD_EXP 100
41683: PUSH
41684: LD_VAR 0 2
41688: ARRAY
41689: PPUSH
41690: LD_INT 2
41692: PUSH
41693: LD_INT 30
41695: PUSH
41696: LD_INT 0
41698: PUSH
41699: EMPTY
41700: LIST
41701: LIST
41702: PUSH
41703: LD_INT 30
41705: PUSH
41706: LD_INT 1
41708: PUSH
41709: EMPTY
41710: LIST
41711: LIST
41712: PUSH
41713: EMPTY
41714: LIST
41715: LIST
41716: LIST
41717: PPUSH
41718: CALL_OW 72
41722: PUSH
41723: LD_EXP 100
41727: PUSH
41728: LD_VAR 0 2
41732: ARRAY
41733: PPUSH
41734: LD_INT 30
41736: PUSH
41737: LD_INT 3
41739: PUSH
41740: EMPTY
41741: LIST
41742: LIST
41743: PPUSH
41744: CALL_OW 72
41748: PUSH
41749: LD_EXP 100
41753: PUSH
41754: LD_VAR 0 2
41758: ARRAY
41759: PPUSH
41760: LD_INT 2
41762: PUSH
41763: LD_INT 30
41765: PUSH
41766: LD_INT 6
41768: PUSH
41769: EMPTY
41770: LIST
41771: LIST
41772: PUSH
41773: LD_INT 30
41775: PUSH
41776: LD_INT 7
41778: PUSH
41779: EMPTY
41780: LIST
41781: LIST
41782: PUSH
41783: LD_INT 30
41785: PUSH
41786: LD_INT 8
41788: PUSH
41789: EMPTY
41790: LIST
41791: LIST
41792: PUSH
41793: EMPTY
41794: LIST
41795: LIST
41796: LIST
41797: LIST
41798: PPUSH
41799: CALL_OW 72
41803: PUSH
41804: EMPTY
41805: LIST
41806: LIST
41807: LIST
41808: LIST
41809: ST_TO_ADDR
// for j = 1 to 4 do
41810: LD_ADDR_VAR 0 3
41814: PUSH
41815: DOUBLE
41816: LD_INT 1
41818: DEC
41819: ST_TO_ADDR
41820: LD_INT 4
41822: PUSH
41823: FOR_TO
41824: IFFALSE 42015
// begin if not tmp [ j ] then
41826: LD_VAR 0 4
41830: PUSH
41831: LD_VAR 0 3
41835: ARRAY
41836: NOT
41837: IFFALSE 41841
// continue ;
41839: GO 41823
// for p in tmp [ j ] do
41841: LD_ADDR_VAR 0 5
41845: PUSH
41846: LD_VAR 0 4
41850: PUSH
41851: LD_VAR 0 3
41855: ARRAY
41856: PUSH
41857: FOR_IN
41858: IFFALSE 42011
// begin if not b [ j ] then
41860: LD_VAR 0 6
41864: PUSH
41865: LD_VAR 0 3
41869: ARRAY
41870: NOT
41871: IFFALSE 41875
// break ;
41873: GO 42011
// e := 0 ;
41875: LD_ADDR_VAR 0 7
41879: PUSH
41880: LD_INT 0
41882: ST_TO_ADDR
// for k in b [ j ] do
41883: LD_ADDR_VAR 0 8
41887: PUSH
41888: LD_VAR 0 6
41892: PUSH
41893: LD_VAR 0 3
41897: ARRAY
41898: PUSH
41899: FOR_IN
41900: IFFALSE 41927
// if IsNotFull ( k ) then
41902: LD_VAR 0 8
41906: PPUSH
41907: CALL 70158 0 1
41911: IFFALSE 41925
// begin e := k ;
41913: LD_ADDR_VAR 0 7
41917: PUSH
41918: LD_VAR 0 8
41922: ST_TO_ADDR
// break ;
41923: GO 41927
// end ;
41925: GO 41899
41927: POP
41928: POP
// if e and not UnitGoingToBuilding ( p , e ) then
41929: LD_VAR 0 7
41933: PUSH
41934: LD_VAR 0 5
41938: PPUSH
41939: LD_VAR 0 7
41943: PPUSH
41944: CALL 103911 0 2
41948: NOT
41949: AND
41950: IFFALSE 42009
// begin if IsInUnit ( p ) then
41952: LD_VAR 0 5
41956: PPUSH
41957: CALL_OW 310
41961: IFFALSE 41972
// ComExitBuilding ( p ) ;
41963: LD_VAR 0 5
41967: PPUSH
41968: CALL_OW 122
// ComEnterUnit ( p , e ) ;
41972: LD_VAR 0 5
41976: PPUSH
41977: LD_VAR 0 7
41981: PPUSH
41982: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
41986: LD_VAR 0 5
41990: PPUSH
41991: LD_VAR 0 3
41995: PPUSH
41996: CALL_OW 183
// AddComExitBuilding ( p ) ;
42000: LD_VAR 0 5
42004: PPUSH
42005: CALL_OW 182
// end ; end ;
42009: GO 41857
42011: POP
42012: POP
// end ;
42013: GO 41823
42015: POP
42016: POP
// end ;
42017: GO 41578
42019: POP
42020: POP
// end ;
42021: LD_VAR 0 1
42025: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
42026: LD_INT 0
42028: PPUSH
42029: PPUSH
42030: PPUSH
42031: PPUSH
42032: PPUSH
42033: PPUSH
42034: PPUSH
42035: PPUSH
42036: PPUSH
42037: PPUSH
42038: PPUSH
42039: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
42040: LD_VAR 0 1
42044: NOT
42045: PUSH
42046: LD_EXP 100
42050: PUSH
42051: LD_VAR 0 1
42055: ARRAY
42056: NOT
42057: OR
42058: PUSH
42059: LD_EXP 100
42063: PUSH
42064: LD_VAR 0 1
42068: ARRAY
42069: PPUSH
42070: LD_INT 2
42072: PUSH
42073: LD_INT 30
42075: PUSH
42076: LD_INT 0
42078: PUSH
42079: EMPTY
42080: LIST
42081: LIST
42082: PUSH
42083: LD_INT 30
42085: PUSH
42086: LD_INT 1
42088: PUSH
42089: EMPTY
42090: LIST
42091: LIST
42092: PUSH
42093: EMPTY
42094: LIST
42095: LIST
42096: LIST
42097: PPUSH
42098: CALL_OW 72
42102: NOT
42103: OR
42104: IFFALSE 42108
// exit ;
42106: GO 45611
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
42108: LD_ADDR_VAR 0 4
42112: PUSH
42113: LD_EXP 100
42117: PUSH
42118: LD_VAR 0 1
42122: ARRAY
42123: PPUSH
42124: LD_INT 2
42126: PUSH
42127: LD_INT 25
42129: PUSH
42130: LD_INT 1
42132: PUSH
42133: EMPTY
42134: LIST
42135: LIST
42136: PUSH
42137: LD_INT 25
42139: PUSH
42140: LD_INT 2
42142: PUSH
42143: EMPTY
42144: LIST
42145: LIST
42146: PUSH
42147: LD_INT 25
42149: PUSH
42150: LD_INT 3
42152: PUSH
42153: EMPTY
42154: LIST
42155: LIST
42156: PUSH
42157: LD_INT 25
42159: PUSH
42160: LD_INT 4
42162: PUSH
42163: EMPTY
42164: LIST
42165: LIST
42166: PUSH
42167: LD_INT 25
42169: PUSH
42170: LD_INT 5
42172: PUSH
42173: EMPTY
42174: LIST
42175: LIST
42176: PUSH
42177: LD_INT 25
42179: PUSH
42180: LD_INT 8
42182: PUSH
42183: EMPTY
42184: LIST
42185: LIST
42186: PUSH
42187: LD_INT 25
42189: PUSH
42190: LD_INT 9
42192: PUSH
42193: EMPTY
42194: LIST
42195: LIST
42196: PUSH
42197: EMPTY
42198: LIST
42199: LIST
42200: LIST
42201: LIST
42202: LIST
42203: LIST
42204: LIST
42205: LIST
42206: PPUSH
42207: CALL_OW 72
42211: ST_TO_ADDR
// if not tmp then
42212: LD_VAR 0 4
42216: NOT
42217: IFFALSE 42221
// exit ;
42219: GO 45611
// for i in tmp do
42221: LD_ADDR_VAR 0 3
42225: PUSH
42226: LD_VAR 0 4
42230: PUSH
42231: FOR_IN
42232: IFFALSE 42263
// if GetTag ( i ) then
42234: LD_VAR 0 3
42238: PPUSH
42239: CALL_OW 110
42243: IFFALSE 42261
// tmp := tmp diff i ;
42245: LD_ADDR_VAR 0 4
42249: PUSH
42250: LD_VAR 0 4
42254: PUSH
42255: LD_VAR 0 3
42259: DIFF
42260: ST_TO_ADDR
42261: GO 42231
42263: POP
42264: POP
// if not tmp then
42265: LD_VAR 0 4
42269: NOT
42270: IFFALSE 42274
// exit ;
42272: GO 45611
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
42274: LD_ADDR_VAR 0 5
42278: PUSH
42279: LD_EXP 100
42283: PUSH
42284: LD_VAR 0 1
42288: ARRAY
42289: PPUSH
42290: LD_INT 2
42292: PUSH
42293: LD_INT 25
42295: PUSH
42296: LD_INT 1
42298: PUSH
42299: EMPTY
42300: LIST
42301: LIST
42302: PUSH
42303: LD_INT 25
42305: PUSH
42306: LD_INT 5
42308: PUSH
42309: EMPTY
42310: LIST
42311: LIST
42312: PUSH
42313: LD_INT 25
42315: PUSH
42316: LD_INT 8
42318: PUSH
42319: EMPTY
42320: LIST
42321: LIST
42322: PUSH
42323: LD_INT 25
42325: PUSH
42326: LD_INT 9
42328: PUSH
42329: EMPTY
42330: LIST
42331: LIST
42332: PUSH
42333: EMPTY
42334: LIST
42335: LIST
42336: LIST
42337: LIST
42338: LIST
42339: PPUSH
42340: CALL_OW 72
42344: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
42345: LD_ADDR_VAR 0 6
42349: PUSH
42350: LD_EXP 100
42354: PUSH
42355: LD_VAR 0 1
42359: ARRAY
42360: PPUSH
42361: LD_INT 25
42363: PUSH
42364: LD_INT 2
42366: PUSH
42367: EMPTY
42368: LIST
42369: LIST
42370: PPUSH
42371: CALL_OW 72
42375: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
42376: LD_ADDR_VAR 0 7
42380: PUSH
42381: LD_EXP 100
42385: PUSH
42386: LD_VAR 0 1
42390: ARRAY
42391: PPUSH
42392: LD_INT 25
42394: PUSH
42395: LD_INT 3
42397: PUSH
42398: EMPTY
42399: LIST
42400: LIST
42401: PPUSH
42402: CALL_OW 72
42406: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
42407: LD_ADDR_VAR 0 8
42411: PUSH
42412: LD_EXP 100
42416: PUSH
42417: LD_VAR 0 1
42421: ARRAY
42422: PPUSH
42423: LD_INT 25
42425: PUSH
42426: LD_INT 4
42428: PUSH
42429: EMPTY
42430: LIST
42431: LIST
42432: PUSH
42433: LD_INT 24
42435: PUSH
42436: LD_INT 251
42438: PUSH
42439: EMPTY
42440: LIST
42441: LIST
42442: PUSH
42443: EMPTY
42444: LIST
42445: LIST
42446: PPUSH
42447: CALL_OW 72
42451: ST_TO_ADDR
// if mc_is_defending [ base ] then
42452: LD_EXP 143
42456: PUSH
42457: LD_VAR 0 1
42461: ARRAY
42462: IFFALSE 42923
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
42464: LD_ADDR_EXP 142
42468: PUSH
42469: LD_EXP 142
42473: PPUSH
42474: LD_VAR 0 1
42478: PPUSH
42479: LD_INT 4
42481: PPUSH
42482: CALL_OW 1
42486: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
42487: LD_ADDR_VAR 0 12
42491: PUSH
42492: LD_EXP 100
42496: PUSH
42497: LD_VAR 0 1
42501: ARRAY
42502: PPUSH
42503: LD_INT 2
42505: PUSH
42506: LD_INT 30
42508: PUSH
42509: LD_INT 4
42511: PUSH
42512: EMPTY
42513: LIST
42514: LIST
42515: PUSH
42516: LD_INT 30
42518: PUSH
42519: LD_INT 5
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PUSH
42526: EMPTY
42527: LIST
42528: LIST
42529: LIST
42530: PPUSH
42531: CALL_OW 72
42535: ST_TO_ADDR
// if not b then
42536: LD_VAR 0 12
42540: NOT
42541: IFFALSE 42545
// exit ;
42543: GO 45611
// p := [ ] ;
42545: LD_ADDR_VAR 0 11
42549: PUSH
42550: EMPTY
42551: ST_TO_ADDR
// if sci >= 2 then
42552: LD_VAR 0 8
42556: PUSH
42557: LD_INT 2
42559: GREATEREQUAL
42560: IFFALSE 42591
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
42562: LD_ADDR_VAR 0 8
42566: PUSH
42567: LD_VAR 0 8
42571: PUSH
42572: LD_INT 1
42574: ARRAY
42575: PUSH
42576: LD_VAR 0 8
42580: PUSH
42581: LD_INT 2
42583: ARRAY
42584: PUSH
42585: EMPTY
42586: LIST
42587: LIST
42588: ST_TO_ADDR
42589: GO 42652
// if sci = 1 then
42591: LD_VAR 0 8
42595: PUSH
42596: LD_INT 1
42598: EQUAL
42599: IFFALSE 42620
// sci := [ sci [ 1 ] ] else
42601: LD_ADDR_VAR 0 8
42605: PUSH
42606: LD_VAR 0 8
42610: PUSH
42611: LD_INT 1
42613: ARRAY
42614: PUSH
42615: EMPTY
42616: LIST
42617: ST_TO_ADDR
42618: GO 42652
// if sci = 0 then
42620: LD_VAR 0 8
42624: PUSH
42625: LD_INT 0
42627: EQUAL
42628: IFFALSE 42652
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
42630: LD_ADDR_VAR 0 11
42634: PUSH
42635: LD_VAR 0 4
42639: PPUSH
42640: LD_INT 4
42642: PPUSH
42643: CALL 103783 0 2
42647: PUSH
42648: LD_INT 1
42650: ARRAY
42651: ST_TO_ADDR
// if eng > 4 then
42652: LD_VAR 0 6
42656: PUSH
42657: LD_INT 4
42659: GREATER
42660: IFFALSE 42706
// for i = eng downto 4 do
42662: LD_ADDR_VAR 0 3
42666: PUSH
42667: DOUBLE
42668: LD_VAR 0 6
42672: INC
42673: ST_TO_ADDR
42674: LD_INT 4
42676: PUSH
42677: FOR_DOWNTO
42678: IFFALSE 42704
// eng := eng diff eng [ i ] ;
42680: LD_ADDR_VAR 0 6
42684: PUSH
42685: LD_VAR 0 6
42689: PUSH
42690: LD_VAR 0 6
42694: PUSH
42695: LD_VAR 0 3
42699: ARRAY
42700: DIFF
42701: ST_TO_ADDR
42702: GO 42677
42704: POP
42705: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
42706: LD_ADDR_VAR 0 4
42710: PUSH
42711: LD_VAR 0 4
42715: PUSH
42716: LD_VAR 0 5
42720: PUSH
42721: LD_VAR 0 6
42725: UNION
42726: PUSH
42727: LD_VAR 0 7
42731: UNION
42732: PUSH
42733: LD_VAR 0 8
42737: UNION
42738: DIFF
42739: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
42740: LD_ADDR_VAR 0 13
42744: PUSH
42745: LD_EXP 100
42749: PUSH
42750: LD_VAR 0 1
42754: ARRAY
42755: PPUSH
42756: LD_INT 2
42758: PUSH
42759: LD_INT 30
42761: PUSH
42762: LD_INT 32
42764: PUSH
42765: EMPTY
42766: LIST
42767: LIST
42768: PUSH
42769: LD_INT 30
42771: PUSH
42772: LD_INT 31
42774: PUSH
42775: EMPTY
42776: LIST
42777: LIST
42778: PUSH
42779: EMPTY
42780: LIST
42781: LIST
42782: LIST
42783: PPUSH
42784: CALL_OW 72
42788: PUSH
42789: LD_EXP 100
42793: PUSH
42794: LD_VAR 0 1
42798: ARRAY
42799: PPUSH
42800: LD_INT 2
42802: PUSH
42803: LD_INT 30
42805: PUSH
42806: LD_INT 4
42808: PUSH
42809: EMPTY
42810: LIST
42811: LIST
42812: PUSH
42813: LD_INT 30
42815: PUSH
42816: LD_INT 5
42818: PUSH
42819: EMPTY
42820: LIST
42821: LIST
42822: PUSH
42823: EMPTY
42824: LIST
42825: LIST
42826: LIST
42827: PPUSH
42828: CALL_OW 72
42832: PUSH
42833: LD_INT 6
42835: MUL
42836: PLUS
42837: ST_TO_ADDR
// if bcount < tmp then
42838: LD_VAR 0 13
42842: PUSH
42843: LD_VAR 0 4
42847: LESS
42848: IFFALSE 42894
// for i = tmp downto bcount do
42850: LD_ADDR_VAR 0 3
42854: PUSH
42855: DOUBLE
42856: LD_VAR 0 4
42860: INC
42861: ST_TO_ADDR
42862: LD_VAR 0 13
42866: PUSH
42867: FOR_DOWNTO
42868: IFFALSE 42892
// tmp := Delete ( tmp , tmp ) ;
42870: LD_ADDR_VAR 0 4
42874: PUSH
42875: LD_VAR 0 4
42879: PPUSH
42880: LD_VAR 0 4
42884: PPUSH
42885: CALL_OW 3
42889: ST_TO_ADDR
42890: GO 42867
42892: POP
42893: POP
// result := [ tmp , 0 , 0 , p ] ;
42894: LD_ADDR_VAR 0 2
42898: PUSH
42899: LD_VAR 0 4
42903: PUSH
42904: LD_INT 0
42906: PUSH
42907: LD_INT 0
42909: PUSH
42910: LD_VAR 0 11
42914: PUSH
42915: EMPTY
42916: LIST
42917: LIST
42918: LIST
42919: LIST
42920: ST_TO_ADDR
// exit ;
42921: GO 45611
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42923: LD_EXP 100
42927: PUSH
42928: LD_VAR 0 1
42932: ARRAY
42933: PPUSH
42934: LD_INT 2
42936: PUSH
42937: LD_INT 30
42939: PUSH
42940: LD_INT 6
42942: PUSH
42943: EMPTY
42944: LIST
42945: LIST
42946: PUSH
42947: LD_INT 30
42949: PUSH
42950: LD_INT 7
42952: PUSH
42953: EMPTY
42954: LIST
42955: LIST
42956: PUSH
42957: LD_INT 30
42959: PUSH
42960: LD_INT 8
42962: PUSH
42963: EMPTY
42964: LIST
42965: LIST
42966: PUSH
42967: EMPTY
42968: LIST
42969: LIST
42970: LIST
42971: LIST
42972: PPUSH
42973: CALL_OW 72
42977: NOT
42978: PUSH
42979: LD_EXP 100
42983: PUSH
42984: LD_VAR 0 1
42988: ARRAY
42989: PPUSH
42990: LD_INT 30
42992: PUSH
42993: LD_INT 3
42995: PUSH
42996: EMPTY
42997: LIST
42998: LIST
42999: PPUSH
43000: CALL_OW 72
43004: NOT
43005: AND
43006: IFFALSE 43078
// begin if eng = tmp then
43008: LD_VAR 0 6
43012: PUSH
43013: LD_VAR 0 4
43017: EQUAL
43018: IFFALSE 43022
// exit ;
43020: GO 45611
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
43022: LD_ADDR_EXP 142
43026: PUSH
43027: LD_EXP 142
43031: PPUSH
43032: LD_VAR 0 1
43036: PPUSH
43037: LD_INT 1
43039: PPUSH
43040: CALL_OW 1
43044: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
43045: LD_ADDR_VAR 0 2
43049: PUSH
43050: LD_INT 0
43052: PUSH
43053: LD_VAR 0 4
43057: PUSH
43058: LD_VAR 0 6
43062: DIFF
43063: PUSH
43064: LD_INT 0
43066: PUSH
43067: LD_INT 0
43069: PUSH
43070: EMPTY
43071: LIST
43072: LIST
43073: LIST
43074: LIST
43075: ST_TO_ADDR
// exit ;
43076: GO 45611
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
43078: LD_EXP 127
43082: PUSH
43083: LD_EXP 126
43087: PUSH
43088: LD_VAR 0 1
43092: ARRAY
43093: ARRAY
43094: PUSH
43095: LD_EXP 100
43099: PUSH
43100: LD_VAR 0 1
43104: ARRAY
43105: PPUSH
43106: LD_INT 2
43108: PUSH
43109: LD_INT 30
43111: PUSH
43112: LD_INT 6
43114: PUSH
43115: EMPTY
43116: LIST
43117: LIST
43118: PUSH
43119: LD_INT 30
43121: PUSH
43122: LD_INT 7
43124: PUSH
43125: EMPTY
43126: LIST
43127: LIST
43128: PUSH
43129: LD_INT 30
43131: PUSH
43132: LD_INT 8
43134: PUSH
43135: EMPTY
43136: LIST
43137: LIST
43138: PUSH
43139: EMPTY
43140: LIST
43141: LIST
43142: LIST
43143: LIST
43144: PPUSH
43145: CALL_OW 72
43149: AND
43150: PUSH
43151: LD_EXP 100
43155: PUSH
43156: LD_VAR 0 1
43160: ARRAY
43161: PPUSH
43162: LD_INT 30
43164: PUSH
43165: LD_INT 3
43167: PUSH
43168: EMPTY
43169: LIST
43170: LIST
43171: PPUSH
43172: CALL_OW 72
43176: NOT
43177: AND
43178: IFFALSE 43392
// begin if sci >= 6 then
43180: LD_VAR 0 8
43184: PUSH
43185: LD_INT 6
43187: GREATEREQUAL
43188: IFFALSE 43192
// exit ;
43190: GO 45611
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
43192: LD_ADDR_EXP 142
43196: PUSH
43197: LD_EXP 142
43201: PPUSH
43202: LD_VAR 0 1
43206: PPUSH
43207: LD_INT 2
43209: PPUSH
43210: CALL_OW 1
43214: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
43215: LD_ADDR_VAR 0 9
43219: PUSH
43220: LD_VAR 0 4
43224: PUSH
43225: LD_VAR 0 8
43229: DIFF
43230: PPUSH
43231: LD_INT 4
43233: PPUSH
43234: CALL 103783 0 2
43238: ST_TO_ADDR
// p := [ ] ;
43239: LD_ADDR_VAR 0 11
43243: PUSH
43244: EMPTY
43245: ST_TO_ADDR
// if sci < 6 and sort > 6 then
43246: LD_VAR 0 8
43250: PUSH
43251: LD_INT 6
43253: LESS
43254: PUSH
43255: LD_VAR 0 9
43259: PUSH
43260: LD_INT 6
43262: GREATER
43263: AND
43264: IFFALSE 43345
// begin for i = 1 to 6 - sci do
43266: LD_ADDR_VAR 0 3
43270: PUSH
43271: DOUBLE
43272: LD_INT 1
43274: DEC
43275: ST_TO_ADDR
43276: LD_INT 6
43278: PUSH
43279: LD_VAR 0 8
43283: MINUS
43284: PUSH
43285: FOR_TO
43286: IFFALSE 43341
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
43288: LD_ADDR_VAR 0 11
43292: PUSH
43293: LD_VAR 0 11
43297: PPUSH
43298: LD_VAR 0 11
43302: PUSH
43303: LD_INT 1
43305: PLUS
43306: PPUSH
43307: LD_VAR 0 9
43311: PUSH
43312: LD_INT 1
43314: ARRAY
43315: PPUSH
43316: CALL_OW 2
43320: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
43321: LD_ADDR_VAR 0 9
43325: PUSH
43326: LD_VAR 0 9
43330: PPUSH
43331: LD_INT 1
43333: PPUSH
43334: CALL_OW 3
43338: ST_TO_ADDR
// end ;
43339: GO 43285
43341: POP
43342: POP
// end else
43343: GO 43365
// if sort then
43345: LD_VAR 0 9
43349: IFFALSE 43365
// p := sort [ 1 ] ;
43351: LD_ADDR_VAR 0 11
43355: PUSH
43356: LD_VAR 0 9
43360: PUSH
43361: LD_INT 1
43363: ARRAY
43364: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
43365: LD_ADDR_VAR 0 2
43369: PUSH
43370: LD_INT 0
43372: PUSH
43373: LD_INT 0
43375: PUSH
43376: LD_INT 0
43378: PUSH
43379: LD_VAR 0 11
43383: PUSH
43384: EMPTY
43385: LIST
43386: LIST
43387: LIST
43388: LIST
43389: ST_TO_ADDR
// exit ;
43390: GO 45611
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
43392: LD_EXP 127
43396: PUSH
43397: LD_EXP 126
43401: PUSH
43402: LD_VAR 0 1
43406: ARRAY
43407: ARRAY
43408: PUSH
43409: LD_EXP 100
43413: PUSH
43414: LD_VAR 0 1
43418: ARRAY
43419: PPUSH
43420: LD_INT 2
43422: PUSH
43423: LD_INT 30
43425: PUSH
43426: LD_INT 6
43428: PUSH
43429: EMPTY
43430: LIST
43431: LIST
43432: PUSH
43433: LD_INT 30
43435: PUSH
43436: LD_INT 7
43438: PUSH
43439: EMPTY
43440: LIST
43441: LIST
43442: PUSH
43443: LD_INT 30
43445: PUSH
43446: LD_INT 8
43448: PUSH
43449: EMPTY
43450: LIST
43451: LIST
43452: PUSH
43453: EMPTY
43454: LIST
43455: LIST
43456: LIST
43457: LIST
43458: PPUSH
43459: CALL_OW 72
43463: AND
43464: PUSH
43465: LD_EXP 100
43469: PUSH
43470: LD_VAR 0 1
43474: ARRAY
43475: PPUSH
43476: LD_INT 30
43478: PUSH
43479: LD_INT 3
43481: PUSH
43482: EMPTY
43483: LIST
43484: LIST
43485: PPUSH
43486: CALL_OW 72
43490: AND
43491: IFFALSE 44225
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
43493: LD_ADDR_EXP 142
43497: PUSH
43498: LD_EXP 142
43502: PPUSH
43503: LD_VAR 0 1
43507: PPUSH
43508: LD_INT 3
43510: PPUSH
43511: CALL_OW 1
43515: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
43516: LD_ADDR_VAR 0 2
43520: PUSH
43521: LD_INT 0
43523: PUSH
43524: LD_INT 0
43526: PUSH
43527: LD_INT 0
43529: PUSH
43530: LD_INT 0
43532: PUSH
43533: EMPTY
43534: LIST
43535: LIST
43536: LIST
43537: LIST
43538: ST_TO_ADDR
// if not eng then
43539: LD_VAR 0 6
43543: NOT
43544: IFFALSE 43607
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
43546: LD_ADDR_VAR 0 11
43550: PUSH
43551: LD_VAR 0 4
43555: PPUSH
43556: LD_INT 2
43558: PPUSH
43559: CALL 103783 0 2
43563: PUSH
43564: LD_INT 1
43566: ARRAY
43567: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
43568: LD_ADDR_VAR 0 2
43572: PUSH
43573: LD_VAR 0 2
43577: PPUSH
43578: LD_INT 2
43580: PPUSH
43581: LD_VAR 0 11
43585: PPUSH
43586: CALL_OW 1
43590: ST_TO_ADDR
// tmp := tmp diff p ;
43591: LD_ADDR_VAR 0 4
43595: PUSH
43596: LD_VAR 0 4
43600: PUSH
43601: LD_VAR 0 11
43605: DIFF
43606: ST_TO_ADDR
// end ; if tmp and sci < 6 then
43607: LD_VAR 0 4
43611: PUSH
43612: LD_VAR 0 8
43616: PUSH
43617: LD_INT 6
43619: LESS
43620: AND
43621: IFFALSE 43809
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
43623: LD_ADDR_VAR 0 9
43627: PUSH
43628: LD_VAR 0 4
43632: PUSH
43633: LD_VAR 0 8
43637: PUSH
43638: LD_VAR 0 7
43642: UNION
43643: DIFF
43644: PPUSH
43645: LD_INT 4
43647: PPUSH
43648: CALL 103783 0 2
43652: ST_TO_ADDR
// p := [ ] ;
43653: LD_ADDR_VAR 0 11
43657: PUSH
43658: EMPTY
43659: ST_TO_ADDR
// if sort then
43660: LD_VAR 0 9
43664: IFFALSE 43780
// for i = 1 to 6 - sci do
43666: LD_ADDR_VAR 0 3
43670: PUSH
43671: DOUBLE
43672: LD_INT 1
43674: DEC
43675: ST_TO_ADDR
43676: LD_INT 6
43678: PUSH
43679: LD_VAR 0 8
43683: MINUS
43684: PUSH
43685: FOR_TO
43686: IFFALSE 43778
// begin if i = sort then
43688: LD_VAR 0 3
43692: PUSH
43693: LD_VAR 0 9
43697: EQUAL
43698: IFFALSE 43702
// break ;
43700: GO 43778
// if GetClass ( i ) = 4 then
43702: LD_VAR 0 3
43706: PPUSH
43707: CALL_OW 257
43711: PUSH
43712: LD_INT 4
43714: EQUAL
43715: IFFALSE 43719
// continue ;
43717: GO 43685
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43719: LD_ADDR_VAR 0 11
43723: PUSH
43724: LD_VAR 0 11
43728: PPUSH
43729: LD_VAR 0 11
43733: PUSH
43734: LD_INT 1
43736: PLUS
43737: PPUSH
43738: LD_VAR 0 9
43742: PUSH
43743: LD_VAR 0 3
43747: ARRAY
43748: PPUSH
43749: CALL_OW 2
43753: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43754: LD_ADDR_VAR 0 4
43758: PUSH
43759: LD_VAR 0 4
43763: PUSH
43764: LD_VAR 0 9
43768: PUSH
43769: LD_VAR 0 3
43773: ARRAY
43774: DIFF
43775: ST_TO_ADDR
// end ;
43776: GO 43685
43778: POP
43779: POP
// if p then
43780: LD_VAR 0 11
43784: IFFALSE 43809
// result := Replace ( result , 4 , p ) ;
43786: LD_ADDR_VAR 0 2
43790: PUSH
43791: LD_VAR 0 2
43795: PPUSH
43796: LD_INT 4
43798: PPUSH
43799: LD_VAR 0 11
43803: PPUSH
43804: CALL_OW 1
43808: ST_TO_ADDR
// end ; if tmp and mech < 6 then
43809: LD_VAR 0 4
43813: PUSH
43814: LD_VAR 0 7
43818: PUSH
43819: LD_INT 6
43821: LESS
43822: AND
43823: IFFALSE 44011
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
43825: LD_ADDR_VAR 0 9
43829: PUSH
43830: LD_VAR 0 4
43834: PUSH
43835: LD_VAR 0 8
43839: PUSH
43840: LD_VAR 0 7
43844: UNION
43845: DIFF
43846: PPUSH
43847: LD_INT 3
43849: PPUSH
43850: CALL 103783 0 2
43854: ST_TO_ADDR
// p := [ ] ;
43855: LD_ADDR_VAR 0 11
43859: PUSH
43860: EMPTY
43861: ST_TO_ADDR
// if sort then
43862: LD_VAR 0 9
43866: IFFALSE 43982
// for i = 1 to 6 - mech do
43868: LD_ADDR_VAR 0 3
43872: PUSH
43873: DOUBLE
43874: LD_INT 1
43876: DEC
43877: ST_TO_ADDR
43878: LD_INT 6
43880: PUSH
43881: LD_VAR 0 7
43885: MINUS
43886: PUSH
43887: FOR_TO
43888: IFFALSE 43980
// begin if i = sort then
43890: LD_VAR 0 3
43894: PUSH
43895: LD_VAR 0 9
43899: EQUAL
43900: IFFALSE 43904
// break ;
43902: GO 43980
// if GetClass ( i ) = 3 then
43904: LD_VAR 0 3
43908: PPUSH
43909: CALL_OW 257
43913: PUSH
43914: LD_INT 3
43916: EQUAL
43917: IFFALSE 43921
// continue ;
43919: GO 43887
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43921: LD_ADDR_VAR 0 11
43925: PUSH
43926: LD_VAR 0 11
43930: PPUSH
43931: LD_VAR 0 11
43935: PUSH
43936: LD_INT 1
43938: PLUS
43939: PPUSH
43940: LD_VAR 0 9
43944: PUSH
43945: LD_VAR 0 3
43949: ARRAY
43950: PPUSH
43951: CALL_OW 2
43955: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43956: LD_ADDR_VAR 0 4
43960: PUSH
43961: LD_VAR 0 4
43965: PUSH
43966: LD_VAR 0 9
43970: PUSH
43971: LD_VAR 0 3
43975: ARRAY
43976: DIFF
43977: ST_TO_ADDR
// end ;
43978: GO 43887
43980: POP
43981: POP
// if p then
43982: LD_VAR 0 11
43986: IFFALSE 44011
// result := Replace ( result , 3 , p ) ;
43988: LD_ADDR_VAR 0 2
43992: PUSH
43993: LD_VAR 0 2
43997: PPUSH
43998: LD_INT 3
44000: PPUSH
44001: LD_VAR 0 11
44005: PPUSH
44006: CALL_OW 1
44010: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
44011: LD_VAR 0 4
44015: PUSH
44016: LD_INT 6
44018: GREATER
44019: PUSH
44020: LD_VAR 0 6
44024: PUSH
44025: LD_INT 6
44027: LESS
44028: AND
44029: IFFALSE 44223
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
44031: LD_ADDR_VAR 0 9
44035: PUSH
44036: LD_VAR 0 4
44040: PUSH
44041: LD_VAR 0 8
44045: PUSH
44046: LD_VAR 0 7
44050: UNION
44051: PUSH
44052: LD_VAR 0 6
44056: UNION
44057: DIFF
44058: PPUSH
44059: LD_INT 2
44061: PPUSH
44062: CALL 103783 0 2
44066: ST_TO_ADDR
// p := [ ] ;
44067: LD_ADDR_VAR 0 11
44071: PUSH
44072: EMPTY
44073: ST_TO_ADDR
// if sort then
44074: LD_VAR 0 9
44078: IFFALSE 44194
// for i = 1 to 6 - eng do
44080: LD_ADDR_VAR 0 3
44084: PUSH
44085: DOUBLE
44086: LD_INT 1
44088: DEC
44089: ST_TO_ADDR
44090: LD_INT 6
44092: PUSH
44093: LD_VAR 0 6
44097: MINUS
44098: PUSH
44099: FOR_TO
44100: IFFALSE 44192
// begin if i = sort then
44102: LD_VAR 0 3
44106: PUSH
44107: LD_VAR 0 9
44111: EQUAL
44112: IFFALSE 44116
// break ;
44114: GO 44192
// if GetClass ( i ) = 2 then
44116: LD_VAR 0 3
44120: PPUSH
44121: CALL_OW 257
44125: PUSH
44126: LD_INT 2
44128: EQUAL
44129: IFFALSE 44133
// continue ;
44131: GO 44099
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44133: LD_ADDR_VAR 0 11
44137: PUSH
44138: LD_VAR 0 11
44142: PPUSH
44143: LD_VAR 0 11
44147: PUSH
44148: LD_INT 1
44150: PLUS
44151: PPUSH
44152: LD_VAR 0 9
44156: PUSH
44157: LD_VAR 0 3
44161: ARRAY
44162: PPUSH
44163: CALL_OW 2
44167: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44168: LD_ADDR_VAR 0 4
44172: PUSH
44173: LD_VAR 0 4
44177: PUSH
44178: LD_VAR 0 9
44182: PUSH
44183: LD_VAR 0 3
44187: ARRAY
44188: DIFF
44189: ST_TO_ADDR
// end ;
44190: GO 44099
44192: POP
44193: POP
// if p then
44194: LD_VAR 0 11
44198: IFFALSE 44223
// result := Replace ( result , 2 , p ) ;
44200: LD_ADDR_VAR 0 2
44204: PUSH
44205: LD_VAR 0 2
44209: PPUSH
44210: LD_INT 2
44212: PPUSH
44213: LD_VAR 0 11
44217: PPUSH
44218: CALL_OW 1
44222: ST_TO_ADDR
// end ; exit ;
44223: GO 45611
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
44225: LD_EXP 127
44229: PUSH
44230: LD_EXP 126
44234: PUSH
44235: LD_VAR 0 1
44239: ARRAY
44240: ARRAY
44241: NOT
44242: PUSH
44243: LD_EXP 100
44247: PUSH
44248: LD_VAR 0 1
44252: ARRAY
44253: PPUSH
44254: LD_INT 30
44256: PUSH
44257: LD_INT 3
44259: PUSH
44260: EMPTY
44261: LIST
44262: LIST
44263: PPUSH
44264: CALL_OW 72
44268: AND
44269: PUSH
44270: LD_EXP 105
44274: PUSH
44275: LD_VAR 0 1
44279: ARRAY
44280: AND
44281: IFFALSE 44889
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
44283: LD_ADDR_EXP 142
44287: PUSH
44288: LD_EXP 142
44292: PPUSH
44293: LD_VAR 0 1
44297: PPUSH
44298: LD_INT 5
44300: PPUSH
44301: CALL_OW 1
44305: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
44306: LD_ADDR_VAR 0 2
44310: PUSH
44311: LD_INT 0
44313: PUSH
44314: LD_INT 0
44316: PUSH
44317: LD_INT 0
44319: PUSH
44320: LD_INT 0
44322: PUSH
44323: EMPTY
44324: LIST
44325: LIST
44326: LIST
44327: LIST
44328: ST_TO_ADDR
// if sci > 1 then
44329: LD_VAR 0 8
44333: PUSH
44334: LD_INT 1
44336: GREATER
44337: IFFALSE 44365
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
44339: LD_ADDR_VAR 0 4
44343: PUSH
44344: LD_VAR 0 4
44348: PUSH
44349: LD_VAR 0 8
44353: PUSH
44354: LD_VAR 0 8
44358: PUSH
44359: LD_INT 1
44361: ARRAY
44362: DIFF
44363: DIFF
44364: ST_TO_ADDR
// if tmp and not sci then
44365: LD_VAR 0 4
44369: PUSH
44370: LD_VAR 0 8
44374: NOT
44375: AND
44376: IFFALSE 44445
// begin sort := SortBySkill ( tmp , 4 ) ;
44378: LD_ADDR_VAR 0 9
44382: PUSH
44383: LD_VAR 0 4
44387: PPUSH
44388: LD_INT 4
44390: PPUSH
44391: CALL 103783 0 2
44395: ST_TO_ADDR
// if sort then
44396: LD_VAR 0 9
44400: IFFALSE 44416
// p := sort [ 1 ] ;
44402: LD_ADDR_VAR 0 11
44406: PUSH
44407: LD_VAR 0 9
44411: PUSH
44412: LD_INT 1
44414: ARRAY
44415: ST_TO_ADDR
// if p then
44416: LD_VAR 0 11
44420: IFFALSE 44445
// result := Replace ( result , 4 , p ) ;
44422: LD_ADDR_VAR 0 2
44426: PUSH
44427: LD_VAR 0 2
44431: PPUSH
44432: LD_INT 4
44434: PPUSH
44435: LD_VAR 0 11
44439: PPUSH
44440: CALL_OW 1
44444: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
44445: LD_ADDR_VAR 0 4
44449: PUSH
44450: LD_VAR 0 4
44454: PUSH
44455: LD_VAR 0 7
44459: DIFF
44460: ST_TO_ADDR
// if tmp and mech < 6 then
44461: LD_VAR 0 4
44465: PUSH
44466: LD_VAR 0 7
44470: PUSH
44471: LD_INT 6
44473: LESS
44474: AND
44475: IFFALSE 44663
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
44477: LD_ADDR_VAR 0 9
44481: PUSH
44482: LD_VAR 0 4
44486: PUSH
44487: LD_VAR 0 8
44491: PUSH
44492: LD_VAR 0 7
44496: UNION
44497: DIFF
44498: PPUSH
44499: LD_INT 3
44501: PPUSH
44502: CALL 103783 0 2
44506: ST_TO_ADDR
// p := [ ] ;
44507: LD_ADDR_VAR 0 11
44511: PUSH
44512: EMPTY
44513: ST_TO_ADDR
// if sort then
44514: LD_VAR 0 9
44518: IFFALSE 44634
// for i = 1 to 6 - mech do
44520: LD_ADDR_VAR 0 3
44524: PUSH
44525: DOUBLE
44526: LD_INT 1
44528: DEC
44529: ST_TO_ADDR
44530: LD_INT 6
44532: PUSH
44533: LD_VAR 0 7
44537: MINUS
44538: PUSH
44539: FOR_TO
44540: IFFALSE 44632
// begin if i = sort then
44542: LD_VAR 0 3
44546: PUSH
44547: LD_VAR 0 9
44551: EQUAL
44552: IFFALSE 44556
// break ;
44554: GO 44632
// if GetClass ( i ) = 3 then
44556: LD_VAR 0 3
44560: PPUSH
44561: CALL_OW 257
44565: PUSH
44566: LD_INT 3
44568: EQUAL
44569: IFFALSE 44573
// continue ;
44571: GO 44539
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44573: LD_ADDR_VAR 0 11
44577: PUSH
44578: LD_VAR 0 11
44582: PPUSH
44583: LD_VAR 0 11
44587: PUSH
44588: LD_INT 1
44590: PLUS
44591: PPUSH
44592: LD_VAR 0 9
44596: PUSH
44597: LD_VAR 0 3
44601: ARRAY
44602: PPUSH
44603: CALL_OW 2
44607: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44608: LD_ADDR_VAR 0 4
44612: PUSH
44613: LD_VAR 0 4
44617: PUSH
44618: LD_VAR 0 9
44622: PUSH
44623: LD_VAR 0 3
44627: ARRAY
44628: DIFF
44629: ST_TO_ADDR
// end ;
44630: GO 44539
44632: POP
44633: POP
// if p then
44634: LD_VAR 0 11
44638: IFFALSE 44663
// result := Replace ( result , 3 , p ) ;
44640: LD_ADDR_VAR 0 2
44644: PUSH
44645: LD_VAR 0 2
44649: PPUSH
44650: LD_INT 3
44652: PPUSH
44653: LD_VAR 0 11
44657: PPUSH
44658: CALL_OW 1
44662: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
44663: LD_ADDR_VAR 0 4
44667: PUSH
44668: LD_VAR 0 4
44672: PUSH
44673: LD_VAR 0 6
44677: DIFF
44678: ST_TO_ADDR
// if tmp and eng < 6 then
44679: LD_VAR 0 4
44683: PUSH
44684: LD_VAR 0 6
44688: PUSH
44689: LD_INT 6
44691: LESS
44692: AND
44693: IFFALSE 44887
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
44695: LD_ADDR_VAR 0 9
44699: PUSH
44700: LD_VAR 0 4
44704: PUSH
44705: LD_VAR 0 8
44709: PUSH
44710: LD_VAR 0 7
44714: UNION
44715: PUSH
44716: LD_VAR 0 6
44720: UNION
44721: DIFF
44722: PPUSH
44723: LD_INT 2
44725: PPUSH
44726: CALL 103783 0 2
44730: ST_TO_ADDR
// p := [ ] ;
44731: LD_ADDR_VAR 0 11
44735: PUSH
44736: EMPTY
44737: ST_TO_ADDR
// if sort then
44738: LD_VAR 0 9
44742: IFFALSE 44858
// for i = 1 to 6 - eng do
44744: LD_ADDR_VAR 0 3
44748: PUSH
44749: DOUBLE
44750: LD_INT 1
44752: DEC
44753: ST_TO_ADDR
44754: LD_INT 6
44756: PUSH
44757: LD_VAR 0 6
44761: MINUS
44762: PUSH
44763: FOR_TO
44764: IFFALSE 44856
// begin if i = sort then
44766: LD_VAR 0 3
44770: PUSH
44771: LD_VAR 0 9
44775: EQUAL
44776: IFFALSE 44780
// break ;
44778: GO 44856
// if GetClass ( i ) = 2 then
44780: LD_VAR 0 3
44784: PPUSH
44785: CALL_OW 257
44789: PUSH
44790: LD_INT 2
44792: EQUAL
44793: IFFALSE 44797
// continue ;
44795: GO 44763
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44797: LD_ADDR_VAR 0 11
44801: PUSH
44802: LD_VAR 0 11
44806: PPUSH
44807: LD_VAR 0 11
44811: PUSH
44812: LD_INT 1
44814: PLUS
44815: PPUSH
44816: LD_VAR 0 9
44820: PUSH
44821: LD_VAR 0 3
44825: ARRAY
44826: PPUSH
44827: CALL_OW 2
44831: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44832: LD_ADDR_VAR 0 4
44836: PUSH
44837: LD_VAR 0 4
44841: PUSH
44842: LD_VAR 0 9
44846: PUSH
44847: LD_VAR 0 3
44851: ARRAY
44852: DIFF
44853: ST_TO_ADDR
// end ;
44854: GO 44763
44856: POP
44857: POP
// if p then
44858: LD_VAR 0 11
44862: IFFALSE 44887
// result := Replace ( result , 2 , p ) ;
44864: LD_ADDR_VAR 0 2
44868: PUSH
44869: LD_VAR 0 2
44873: PPUSH
44874: LD_INT 2
44876: PPUSH
44877: LD_VAR 0 11
44881: PPUSH
44882: CALL_OW 1
44886: ST_TO_ADDR
// end ; exit ;
44887: GO 45611
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
44889: LD_EXP 127
44893: PUSH
44894: LD_EXP 126
44898: PUSH
44899: LD_VAR 0 1
44903: ARRAY
44904: ARRAY
44905: NOT
44906: PUSH
44907: LD_EXP 100
44911: PUSH
44912: LD_VAR 0 1
44916: ARRAY
44917: PPUSH
44918: LD_INT 30
44920: PUSH
44921: LD_INT 3
44923: PUSH
44924: EMPTY
44925: LIST
44926: LIST
44927: PPUSH
44928: CALL_OW 72
44932: AND
44933: PUSH
44934: LD_EXP 105
44938: PUSH
44939: LD_VAR 0 1
44943: ARRAY
44944: NOT
44945: AND
44946: IFFALSE 45611
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
44948: LD_ADDR_EXP 142
44952: PUSH
44953: LD_EXP 142
44957: PPUSH
44958: LD_VAR 0 1
44962: PPUSH
44963: LD_INT 6
44965: PPUSH
44966: CALL_OW 1
44970: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
44971: LD_ADDR_VAR 0 2
44975: PUSH
44976: LD_INT 0
44978: PUSH
44979: LD_INT 0
44981: PUSH
44982: LD_INT 0
44984: PUSH
44985: LD_INT 0
44987: PUSH
44988: EMPTY
44989: LIST
44990: LIST
44991: LIST
44992: LIST
44993: ST_TO_ADDR
// if sci >= 1 then
44994: LD_VAR 0 8
44998: PUSH
44999: LD_INT 1
45001: GREATEREQUAL
45002: IFFALSE 45024
// tmp := tmp diff sci [ 1 ] ;
45004: LD_ADDR_VAR 0 4
45008: PUSH
45009: LD_VAR 0 4
45013: PUSH
45014: LD_VAR 0 8
45018: PUSH
45019: LD_INT 1
45021: ARRAY
45022: DIFF
45023: ST_TO_ADDR
// if tmp and not sci then
45024: LD_VAR 0 4
45028: PUSH
45029: LD_VAR 0 8
45033: NOT
45034: AND
45035: IFFALSE 45104
// begin sort := SortBySkill ( tmp , 4 ) ;
45037: LD_ADDR_VAR 0 9
45041: PUSH
45042: LD_VAR 0 4
45046: PPUSH
45047: LD_INT 4
45049: PPUSH
45050: CALL 103783 0 2
45054: ST_TO_ADDR
// if sort then
45055: LD_VAR 0 9
45059: IFFALSE 45075
// p := sort [ 1 ] ;
45061: LD_ADDR_VAR 0 11
45065: PUSH
45066: LD_VAR 0 9
45070: PUSH
45071: LD_INT 1
45073: ARRAY
45074: ST_TO_ADDR
// if p then
45075: LD_VAR 0 11
45079: IFFALSE 45104
// result := Replace ( result , 4 , p ) ;
45081: LD_ADDR_VAR 0 2
45085: PUSH
45086: LD_VAR 0 2
45090: PPUSH
45091: LD_INT 4
45093: PPUSH
45094: LD_VAR 0 11
45098: PPUSH
45099: CALL_OW 1
45103: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
45104: LD_ADDR_VAR 0 4
45108: PUSH
45109: LD_VAR 0 4
45113: PUSH
45114: LD_VAR 0 7
45118: DIFF
45119: ST_TO_ADDR
// if tmp and mech < 6 then
45120: LD_VAR 0 4
45124: PUSH
45125: LD_VAR 0 7
45129: PUSH
45130: LD_INT 6
45132: LESS
45133: AND
45134: IFFALSE 45316
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
45136: LD_ADDR_VAR 0 9
45140: PUSH
45141: LD_VAR 0 4
45145: PUSH
45146: LD_VAR 0 7
45150: DIFF
45151: PPUSH
45152: LD_INT 3
45154: PPUSH
45155: CALL 103783 0 2
45159: ST_TO_ADDR
// p := [ ] ;
45160: LD_ADDR_VAR 0 11
45164: PUSH
45165: EMPTY
45166: ST_TO_ADDR
// if sort then
45167: LD_VAR 0 9
45171: IFFALSE 45287
// for i = 1 to 6 - mech do
45173: LD_ADDR_VAR 0 3
45177: PUSH
45178: DOUBLE
45179: LD_INT 1
45181: DEC
45182: ST_TO_ADDR
45183: LD_INT 6
45185: PUSH
45186: LD_VAR 0 7
45190: MINUS
45191: PUSH
45192: FOR_TO
45193: IFFALSE 45285
// begin if i = sort then
45195: LD_VAR 0 3
45199: PUSH
45200: LD_VAR 0 9
45204: EQUAL
45205: IFFALSE 45209
// break ;
45207: GO 45285
// if GetClass ( i ) = 3 then
45209: LD_VAR 0 3
45213: PPUSH
45214: CALL_OW 257
45218: PUSH
45219: LD_INT 3
45221: EQUAL
45222: IFFALSE 45226
// continue ;
45224: GO 45192
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45226: LD_ADDR_VAR 0 11
45230: PUSH
45231: LD_VAR 0 11
45235: PPUSH
45236: LD_VAR 0 11
45240: PUSH
45241: LD_INT 1
45243: PLUS
45244: PPUSH
45245: LD_VAR 0 9
45249: PUSH
45250: LD_VAR 0 3
45254: ARRAY
45255: PPUSH
45256: CALL_OW 2
45260: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45261: LD_ADDR_VAR 0 4
45265: PUSH
45266: LD_VAR 0 4
45270: PUSH
45271: LD_VAR 0 9
45275: PUSH
45276: LD_VAR 0 3
45280: ARRAY
45281: DIFF
45282: ST_TO_ADDR
// end ;
45283: GO 45192
45285: POP
45286: POP
// if p then
45287: LD_VAR 0 11
45291: IFFALSE 45316
// result := Replace ( result , 3 , p ) ;
45293: LD_ADDR_VAR 0 2
45297: PUSH
45298: LD_VAR 0 2
45302: PPUSH
45303: LD_INT 3
45305: PPUSH
45306: LD_VAR 0 11
45310: PPUSH
45311: CALL_OW 1
45315: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
45316: LD_ADDR_VAR 0 4
45320: PUSH
45321: LD_VAR 0 4
45325: PUSH
45326: LD_VAR 0 6
45330: DIFF
45331: ST_TO_ADDR
// if tmp and eng < 4 then
45332: LD_VAR 0 4
45336: PUSH
45337: LD_VAR 0 6
45341: PUSH
45342: LD_INT 4
45344: LESS
45345: AND
45346: IFFALSE 45536
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
45348: LD_ADDR_VAR 0 9
45352: PUSH
45353: LD_VAR 0 4
45357: PUSH
45358: LD_VAR 0 7
45362: PUSH
45363: LD_VAR 0 6
45367: UNION
45368: DIFF
45369: PPUSH
45370: LD_INT 2
45372: PPUSH
45373: CALL 103783 0 2
45377: ST_TO_ADDR
// p := [ ] ;
45378: LD_ADDR_VAR 0 11
45382: PUSH
45383: EMPTY
45384: ST_TO_ADDR
// if sort then
45385: LD_VAR 0 9
45389: IFFALSE 45505
// for i = 1 to 4 - eng do
45391: LD_ADDR_VAR 0 3
45395: PUSH
45396: DOUBLE
45397: LD_INT 1
45399: DEC
45400: ST_TO_ADDR
45401: LD_INT 4
45403: PUSH
45404: LD_VAR 0 6
45408: MINUS
45409: PUSH
45410: FOR_TO
45411: IFFALSE 45503
// begin if i = sort then
45413: LD_VAR 0 3
45417: PUSH
45418: LD_VAR 0 9
45422: EQUAL
45423: IFFALSE 45427
// break ;
45425: GO 45503
// if GetClass ( i ) = 2 then
45427: LD_VAR 0 3
45431: PPUSH
45432: CALL_OW 257
45436: PUSH
45437: LD_INT 2
45439: EQUAL
45440: IFFALSE 45444
// continue ;
45442: GO 45410
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45444: LD_ADDR_VAR 0 11
45448: PUSH
45449: LD_VAR 0 11
45453: PPUSH
45454: LD_VAR 0 11
45458: PUSH
45459: LD_INT 1
45461: PLUS
45462: PPUSH
45463: LD_VAR 0 9
45467: PUSH
45468: LD_VAR 0 3
45472: ARRAY
45473: PPUSH
45474: CALL_OW 2
45478: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45479: LD_ADDR_VAR 0 4
45483: PUSH
45484: LD_VAR 0 4
45488: PUSH
45489: LD_VAR 0 9
45493: PUSH
45494: LD_VAR 0 3
45498: ARRAY
45499: DIFF
45500: ST_TO_ADDR
// end ;
45501: GO 45410
45503: POP
45504: POP
// if p then
45505: LD_VAR 0 11
45509: IFFALSE 45534
// result := Replace ( result , 2 , p ) ;
45511: LD_ADDR_VAR 0 2
45515: PUSH
45516: LD_VAR 0 2
45520: PPUSH
45521: LD_INT 2
45523: PPUSH
45524: LD_VAR 0 11
45528: PPUSH
45529: CALL_OW 1
45533: ST_TO_ADDR
// end else
45534: GO 45580
// for i = eng downto 5 do
45536: LD_ADDR_VAR 0 3
45540: PUSH
45541: DOUBLE
45542: LD_VAR 0 6
45546: INC
45547: ST_TO_ADDR
45548: LD_INT 5
45550: PUSH
45551: FOR_DOWNTO
45552: IFFALSE 45578
// tmp := tmp union eng [ i ] ;
45554: LD_ADDR_VAR 0 4
45558: PUSH
45559: LD_VAR 0 4
45563: PUSH
45564: LD_VAR 0 6
45568: PUSH
45569: LD_VAR 0 3
45573: ARRAY
45574: UNION
45575: ST_TO_ADDR
45576: GO 45551
45578: POP
45579: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
45580: LD_ADDR_VAR 0 2
45584: PUSH
45585: LD_VAR 0 2
45589: PPUSH
45590: LD_INT 1
45592: PPUSH
45593: LD_VAR 0 4
45597: PUSH
45598: LD_VAR 0 5
45602: DIFF
45603: PPUSH
45604: CALL_OW 1
45608: ST_TO_ADDR
// exit ;
45609: GO 45611
// end ; end ;
45611: LD_VAR 0 2
45615: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
45616: LD_INT 0
45618: PPUSH
45619: PPUSH
45620: PPUSH
// if not mc_bases then
45621: LD_EXP 100
45625: NOT
45626: IFFALSE 45630
// exit ;
45628: GO 45772
// for i = 1 to mc_bases do
45630: LD_ADDR_VAR 0 2
45634: PUSH
45635: DOUBLE
45636: LD_INT 1
45638: DEC
45639: ST_TO_ADDR
45640: LD_EXP 100
45644: PUSH
45645: FOR_TO
45646: IFFALSE 45763
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
45648: LD_ADDR_VAR 0 3
45652: PUSH
45653: LD_EXP 100
45657: PUSH
45658: LD_VAR 0 2
45662: ARRAY
45663: PPUSH
45664: LD_INT 21
45666: PUSH
45667: LD_INT 3
45669: PUSH
45670: EMPTY
45671: LIST
45672: LIST
45673: PUSH
45674: LD_INT 3
45676: PUSH
45677: LD_INT 2
45679: PUSH
45680: LD_INT 30
45682: PUSH
45683: LD_INT 29
45685: PUSH
45686: EMPTY
45687: LIST
45688: LIST
45689: PUSH
45690: LD_INT 30
45692: PUSH
45693: LD_INT 30
45695: PUSH
45696: EMPTY
45697: LIST
45698: LIST
45699: PUSH
45700: EMPTY
45701: LIST
45702: LIST
45703: LIST
45704: PUSH
45705: EMPTY
45706: LIST
45707: LIST
45708: PUSH
45709: LD_INT 3
45711: PUSH
45712: LD_INT 24
45714: PUSH
45715: LD_INT 1000
45717: PUSH
45718: EMPTY
45719: LIST
45720: LIST
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: PUSH
45726: EMPTY
45727: LIST
45728: LIST
45729: LIST
45730: PPUSH
45731: CALL_OW 72
45735: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
45736: LD_ADDR_EXP 101
45740: PUSH
45741: LD_EXP 101
45745: PPUSH
45746: LD_VAR 0 2
45750: PPUSH
45751: LD_VAR 0 3
45755: PPUSH
45756: CALL_OW 1
45760: ST_TO_ADDR
// end ;
45761: GO 45645
45763: POP
45764: POP
// RaiseSailEvent ( 101 ) ;
45765: LD_INT 101
45767: PPUSH
45768: CALL_OW 427
// end ;
45772: LD_VAR 0 1
45776: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
45777: LD_INT 0
45779: PPUSH
45780: PPUSH
45781: PPUSH
45782: PPUSH
45783: PPUSH
45784: PPUSH
45785: PPUSH
// if not mc_bases then
45786: LD_EXP 100
45790: NOT
45791: IFFALSE 45795
// exit ;
45793: GO 46357
// for i = 1 to mc_bases do
45795: LD_ADDR_VAR 0 2
45799: PUSH
45800: DOUBLE
45801: LD_INT 1
45803: DEC
45804: ST_TO_ADDR
45805: LD_EXP 100
45809: PUSH
45810: FOR_TO
45811: IFFALSE 46348
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
45813: LD_ADDR_VAR 0 5
45817: PUSH
45818: LD_EXP 100
45822: PUSH
45823: LD_VAR 0 2
45827: ARRAY
45828: PUSH
45829: LD_EXP 129
45833: PUSH
45834: LD_VAR 0 2
45838: ARRAY
45839: UNION
45840: PPUSH
45841: LD_INT 21
45843: PUSH
45844: LD_INT 1
45846: PUSH
45847: EMPTY
45848: LIST
45849: LIST
45850: PUSH
45851: LD_INT 1
45853: PUSH
45854: LD_INT 3
45856: PUSH
45857: LD_INT 54
45859: PUSH
45860: EMPTY
45861: LIST
45862: PUSH
45863: EMPTY
45864: LIST
45865: LIST
45866: PUSH
45867: LD_INT 3
45869: PUSH
45870: LD_INT 24
45872: PUSH
45873: LD_INT 1000
45875: PUSH
45876: EMPTY
45877: LIST
45878: LIST
45879: PUSH
45880: EMPTY
45881: LIST
45882: LIST
45883: PUSH
45884: EMPTY
45885: LIST
45886: LIST
45887: LIST
45888: PUSH
45889: EMPTY
45890: LIST
45891: LIST
45892: PPUSH
45893: CALL_OW 72
45897: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
45898: LD_ADDR_VAR 0 6
45902: PUSH
45903: LD_EXP 100
45907: PUSH
45908: LD_VAR 0 2
45912: ARRAY
45913: PPUSH
45914: LD_INT 21
45916: PUSH
45917: LD_INT 1
45919: PUSH
45920: EMPTY
45921: LIST
45922: LIST
45923: PUSH
45924: LD_INT 1
45926: PUSH
45927: LD_INT 3
45929: PUSH
45930: LD_INT 54
45932: PUSH
45933: EMPTY
45934: LIST
45935: PUSH
45936: EMPTY
45937: LIST
45938: LIST
45939: PUSH
45940: LD_INT 3
45942: PUSH
45943: LD_INT 24
45945: PUSH
45946: LD_INT 250
45948: PUSH
45949: EMPTY
45950: LIST
45951: LIST
45952: PUSH
45953: EMPTY
45954: LIST
45955: LIST
45956: PUSH
45957: EMPTY
45958: LIST
45959: LIST
45960: LIST
45961: PUSH
45962: EMPTY
45963: LIST
45964: LIST
45965: PPUSH
45966: CALL_OW 72
45970: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
45971: LD_ADDR_VAR 0 7
45975: PUSH
45976: LD_VAR 0 5
45980: PUSH
45981: LD_VAR 0 6
45985: DIFF
45986: ST_TO_ADDR
// if not need_heal_1 then
45987: LD_VAR 0 6
45991: NOT
45992: IFFALSE 46025
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
45994: LD_ADDR_EXP 103
45998: PUSH
45999: LD_EXP 103
46003: PPUSH
46004: LD_VAR 0 2
46008: PUSH
46009: LD_INT 1
46011: PUSH
46012: EMPTY
46013: LIST
46014: LIST
46015: PPUSH
46016: EMPTY
46017: PPUSH
46018: CALL 72936 0 3
46022: ST_TO_ADDR
46023: GO 46095
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
46025: LD_ADDR_EXP 103
46029: PUSH
46030: LD_EXP 103
46034: PPUSH
46035: LD_VAR 0 2
46039: PUSH
46040: LD_INT 1
46042: PUSH
46043: EMPTY
46044: LIST
46045: LIST
46046: PPUSH
46047: LD_EXP 103
46051: PUSH
46052: LD_VAR 0 2
46056: ARRAY
46057: PUSH
46058: LD_INT 1
46060: ARRAY
46061: PPUSH
46062: LD_INT 3
46064: PUSH
46065: LD_INT 24
46067: PUSH
46068: LD_INT 1000
46070: PUSH
46071: EMPTY
46072: LIST
46073: LIST
46074: PUSH
46075: EMPTY
46076: LIST
46077: LIST
46078: PPUSH
46079: CALL_OW 72
46083: PUSH
46084: LD_VAR 0 6
46088: UNION
46089: PPUSH
46090: CALL 72936 0 3
46094: ST_TO_ADDR
// if not need_heal_2 then
46095: LD_VAR 0 7
46099: NOT
46100: IFFALSE 46133
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
46102: LD_ADDR_EXP 103
46106: PUSH
46107: LD_EXP 103
46111: PPUSH
46112: LD_VAR 0 2
46116: PUSH
46117: LD_INT 2
46119: PUSH
46120: EMPTY
46121: LIST
46122: LIST
46123: PPUSH
46124: EMPTY
46125: PPUSH
46126: CALL 72936 0 3
46130: ST_TO_ADDR
46131: GO 46165
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
46133: LD_ADDR_EXP 103
46137: PUSH
46138: LD_EXP 103
46142: PPUSH
46143: LD_VAR 0 2
46147: PUSH
46148: LD_INT 2
46150: PUSH
46151: EMPTY
46152: LIST
46153: LIST
46154: PPUSH
46155: LD_VAR 0 7
46159: PPUSH
46160: CALL 72936 0 3
46164: ST_TO_ADDR
// if need_heal_2 then
46165: LD_VAR 0 7
46169: IFFALSE 46330
// for j in need_heal_2 do
46171: LD_ADDR_VAR 0 3
46175: PUSH
46176: LD_VAR 0 7
46180: PUSH
46181: FOR_IN
46182: IFFALSE 46328
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46184: LD_ADDR_VAR 0 5
46188: PUSH
46189: LD_EXP 100
46193: PUSH
46194: LD_VAR 0 2
46198: ARRAY
46199: PPUSH
46200: LD_INT 2
46202: PUSH
46203: LD_INT 30
46205: PUSH
46206: LD_INT 6
46208: PUSH
46209: EMPTY
46210: LIST
46211: LIST
46212: PUSH
46213: LD_INT 30
46215: PUSH
46216: LD_INT 7
46218: PUSH
46219: EMPTY
46220: LIST
46221: LIST
46222: PUSH
46223: LD_INT 30
46225: PUSH
46226: LD_INT 8
46228: PUSH
46229: EMPTY
46230: LIST
46231: LIST
46232: PUSH
46233: LD_INT 30
46235: PUSH
46236: LD_INT 0
46238: PUSH
46239: EMPTY
46240: LIST
46241: LIST
46242: PUSH
46243: LD_INT 30
46245: PUSH
46246: LD_INT 1
46248: PUSH
46249: EMPTY
46250: LIST
46251: LIST
46252: PUSH
46253: EMPTY
46254: LIST
46255: LIST
46256: LIST
46257: LIST
46258: LIST
46259: LIST
46260: PPUSH
46261: CALL_OW 72
46265: ST_TO_ADDR
// if tmp then
46266: LD_VAR 0 5
46270: IFFALSE 46326
// begin k := NearestUnitToUnit ( tmp , j ) ;
46272: LD_ADDR_VAR 0 4
46276: PUSH
46277: LD_VAR 0 5
46281: PPUSH
46282: LD_VAR 0 3
46286: PPUSH
46287: CALL_OW 74
46291: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
46292: LD_VAR 0 3
46296: PPUSH
46297: LD_VAR 0 4
46301: PPUSH
46302: CALL_OW 296
46306: PUSH
46307: LD_INT 5
46309: GREATER
46310: IFFALSE 46326
// ComMoveToNearbyEntrance ( j , k ) ;
46312: LD_VAR 0 3
46316: PPUSH
46317: LD_VAR 0 4
46321: PPUSH
46322: CALL 106143 0 2
// end ; end ;
46326: GO 46181
46328: POP
46329: POP
// if not need_heal_1 and not need_heal_2 then
46330: LD_VAR 0 6
46334: NOT
46335: PUSH
46336: LD_VAR 0 7
46340: NOT
46341: AND
46342: IFFALSE 46346
// continue ;
46344: GO 45810
// end ;
46346: GO 45810
46348: POP
46349: POP
// RaiseSailEvent ( 102 ) ;
46350: LD_INT 102
46352: PPUSH
46353: CALL_OW 427
// end ;
46357: LD_VAR 0 1
46361: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
46362: LD_INT 0
46364: PPUSH
46365: PPUSH
46366: PPUSH
46367: PPUSH
46368: PPUSH
46369: PPUSH
46370: PPUSH
46371: PPUSH
// if not mc_bases then
46372: LD_EXP 100
46376: NOT
46377: IFFALSE 46381
// exit ;
46379: GO 47292
// for i = 1 to mc_bases do
46381: LD_ADDR_VAR 0 2
46385: PUSH
46386: DOUBLE
46387: LD_INT 1
46389: DEC
46390: ST_TO_ADDR
46391: LD_EXP 100
46395: PUSH
46396: FOR_TO
46397: IFFALSE 47290
// begin if not mc_building_need_repair [ i ] then
46399: LD_EXP 101
46403: PUSH
46404: LD_VAR 0 2
46408: ARRAY
46409: NOT
46410: IFFALSE 46595
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
46412: LD_ADDR_VAR 0 6
46416: PUSH
46417: LD_EXP 119
46421: PUSH
46422: LD_VAR 0 2
46426: ARRAY
46427: PPUSH
46428: LD_INT 3
46430: PUSH
46431: LD_INT 24
46433: PUSH
46434: LD_INT 1000
46436: PUSH
46437: EMPTY
46438: LIST
46439: LIST
46440: PUSH
46441: EMPTY
46442: LIST
46443: LIST
46444: PUSH
46445: LD_INT 2
46447: PUSH
46448: LD_INT 34
46450: PUSH
46451: LD_INT 13
46453: PUSH
46454: EMPTY
46455: LIST
46456: LIST
46457: PUSH
46458: LD_INT 34
46460: PUSH
46461: LD_INT 52
46463: PUSH
46464: EMPTY
46465: LIST
46466: LIST
46467: PUSH
46468: LD_INT 34
46470: PUSH
46471: LD_INT 88
46473: PUSH
46474: EMPTY
46475: LIST
46476: LIST
46477: PUSH
46478: EMPTY
46479: LIST
46480: LIST
46481: LIST
46482: LIST
46483: PUSH
46484: EMPTY
46485: LIST
46486: LIST
46487: PPUSH
46488: CALL_OW 72
46492: ST_TO_ADDR
// if cranes then
46493: LD_VAR 0 6
46497: IFFALSE 46559
// for j in cranes do
46499: LD_ADDR_VAR 0 3
46503: PUSH
46504: LD_VAR 0 6
46508: PUSH
46509: FOR_IN
46510: IFFALSE 46557
// if not IsInArea ( j , mc_parking [ i ] ) then
46512: LD_VAR 0 3
46516: PPUSH
46517: LD_EXP 124
46521: PUSH
46522: LD_VAR 0 2
46526: ARRAY
46527: PPUSH
46528: CALL_OW 308
46532: NOT
46533: IFFALSE 46555
// ComMoveToArea ( j , mc_parking [ i ] ) ;
46535: LD_VAR 0 3
46539: PPUSH
46540: LD_EXP 124
46544: PUSH
46545: LD_VAR 0 2
46549: ARRAY
46550: PPUSH
46551: CALL_OW 113
46555: GO 46509
46557: POP
46558: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
46559: LD_ADDR_EXP 102
46563: PUSH
46564: LD_EXP 102
46568: PPUSH
46569: LD_VAR 0 2
46573: PPUSH
46574: EMPTY
46575: PPUSH
46576: CALL_OW 1
46580: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
46581: LD_VAR 0 2
46585: PPUSH
46586: LD_INT 101
46588: PPUSH
46589: CALL 41449 0 2
// continue ;
46593: GO 46396
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
46595: LD_ADDR_EXP 106
46599: PUSH
46600: LD_EXP 106
46604: PPUSH
46605: LD_VAR 0 2
46609: PPUSH
46610: EMPTY
46611: PPUSH
46612: CALL_OW 1
46616: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
46617: LD_VAR 0 2
46621: PPUSH
46622: LD_INT 103
46624: PPUSH
46625: CALL 41449 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
46629: LD_ADDR_VAR 0 5
46633: PUSH
46634: LD_EXP 100
46638: PUSH
46639: LD_VAR 0 2
46643: ARRAY
46644: PUSH
46645: LD_EXP 129
46649: PUSH
46650: LD_VAR 0 2
46654: ARRAY
46655: UNION
46656: PPUSH
46657: LD_INT 2
46659: PUSH
46660: LD_INT 25
46662: PUSH
46663: LD_INT 2
46665: PUSH
46666: EMPTY
46667: LIST
46668: LIST
46669: PUSH
46670: LD_INT 25
46672: PUSH
46673: LD_INT 16
46675: PUSH
46676: EMPTY
46677: LIST
46678: LIST
46679: PUSH
46680: EMPTY
46681: LIST
46682: LIST
46683: LIST
46684: PUSH
46685: EMPTY
46686: LIST
46687: PPUSH
46688: CALL_OW 72
46692: ST_TO_ADDR
// if mc_need_heal [ i ] then
46693: LD_EXP 103
46697: PUSH
46698: LD_VAR 0 2
46702: ARRAY
46703: IFFALSE 46747
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
46705: LD_ADDR_VAR 0 5
46709: PUSH
46710: LD_VAR 0 5
46714: PUSH
46715: LD_EXP 103
46719: PUSH
46720: LD_VAR 0 2
46724: ARRAY
46725: PUSH
46726: LD_INT 1
46728: ARRAY
46729: PUSH
46730: LD_EXP 103
46734: PUSH
46735: LD_VAR 0 2
46739: ARRAY
46740: PUSH
46741: LD_INT 2
46743: ARRAY
46744: UNION
46745: DIFF
46746: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
46747: LD_ADDR_VAR 0 6
46751: PUSH
46752: LD_EXP 119
46756: PUSH
46757: LD_VAR 0 2
46761: ARRAY
46762: PPUSH
46763: LD_INT 2
46765: PUSH
46766: LD_INT 34
46768: PUSH
46769: LD_INT 13
46771: PUSH
46772: EMPTY
46773: LIST
46774: LIST
46775: PUSH
46776: LD_INT 34
46778: PUSH
46779: LD_INT 52
46781: PUSH
46782: EMPTY
46783: LIST
46784: LIST
46785: PUSH
46786: LD_INT 34
46788: PUSH
46789: LD_INT 88
46791: PUSH
46792: EMPTY
46793: LIST
46794: LIST
46795: PUSH
46796: EMPTY
46797: LIST
46798: LIST
46799: LIST
46800: LIST
46801: PPUSH
46802: CALL_OW 72
46806: ST_TO_ADDR
// if cranes then
46807: LD_VAR 0 6
46811: IFFALSE 46979
// begin for j in cranes do
46813: LD_ADDR_VAR 0 3
46817: PUSH
46818: LD_VAR 0 6
46822: PUSH
46823: FOR_IN
46824: IFFALSE 46977
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
46826: LD_VAR 0 3
46830: PPUSH
46831: CALL_OW 256
46835: PUSH
46836: LD_INT 1000
46838: EQUAL
46839: PUSH
46840: LD_VAR 0 3
46844: PPUSH
46845: CALL_OW 314
46849: NOT
46850: AND
46851: IFFALSE 46917
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
46853: LD_ADDR_VAR 0 8
46857: PUSH
46858: LD_EXP 101
46862: PUSH
46863: LD_VAR 0 2
46867: ARRAY
46868: PPUSH
46869: LD_VAR 0 3
46873: PPUSH
46874: CALL_OW 74
46878: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
46879: LD_VAR 0 8
46883: PPUSH
46884: LD_INT 16
46886: PPUSH
46887: CALL 75533 0 2
46891: PUSH
46892: LD_INT 4
46894: ARRAY
46895: PUSH
46896: LD_INT 10
46898: LESS
46899: IFFALSE 46915
// ComRepairBuilding ( j , to_repair ) ;
46901: LD_VAR 0 3
46905: PPUSH
46906: LD_VAR 0 8
46910: PPUSH
46911: CALL_OW 130
// end else
46915: GO 46975
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
46917: LD_VAR 0 3
46921: PPUSH
46922: CALL_OW 256
46926: PUSH
46927: LD_INT 500
46929: LESS
46930: PUSH
46931: LD_VAR 0 3
46935: PPUSH
46936: LD_EXP 124
46940: PUSH
46941: LD_VAR 0 2
46945: ARRAY
46946: PPUSH
46947: CALL_OW 308
46951: NOT
46952: AND
46953: IFFALSE 46975
// ComMoveToArea ( j , mc_parking [ i ] ) ;
46955: LD_VAR 0 3
46959: PPUSH
46960: LD_EXP 124
46964: PUSH
46965: LD_VAR 0 2
46969: ARRAY
46970: PPUSH
46971: CALL_OW 113
// end ;
46975: GO 46823
46977: POP
46978: POP
// end ; if tmp > 3 then
46979: LD_VAR 0 5
46983: PUSH
46984: LD_INT 3
46986: GREATER
46987: IFFALSE 47007
// tmp := ShrinkArray ( tmp , 4 ) ;
46989: LD_ADDR_VAR 0 5
46993: PUSH
46994: LD_VAR 0 5
46998: PPUSH
46999: LD_INT 4
47001: PPUSH
47002: CALL 105581 0 2
47006: ST_TO_ADDR
// if not tmp then
47007: LD_VAR 0 5
47011: NOT
47012: IFFALSE 47016
// continue ;
47014: GO 46396
// for j in tmp do
47016: LD_ADDR_VAR 0 3
47020: PUSH
47021: LD_VAR 0 5
47025: PUSH
47026: FOR_IN
47027: IFFALSE 47286
// begin if IsInUnit ( j ) then
47029: LD_VAR 0 3
47033: PPUSH
47034: CALL_OW 310
47038: IFFALSE 47049
// ComExitBuilding ( j ) ;
47040: LD_VAR 0 3
47044: PPUSH
47045: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
47049: LD_VAR 0 3
47053: PUSH
47054: LD_EXP 102
47058: PUSH
47059: LD_VAR 0 2
47063: ARRAY
47064: IN
47065: NOT
47066: IFFALSE 47124
// begin SetTag ( j , 101 ) ;
47068: LD_VAR 0 3
47072: PPUSH
47073: LD_INT 101
47075: PPUSH
47076: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
47080: LD_ADDR_EXP 102
47084: PUSH
47085: LD_EXP 102
47089: PPUSH
47090: LD_VAR 0 2
47094: PUSH
47095: LD_EXP 102
47099: PUSH
47100: LD_VAR 0 2
47104: ARRAY
47105: PUSH
47106: LD_INT 1
47108: PLUS
47109: PUSH
47110: EMPTY
47111: LIST
47112: LIST
47113: PPUSH
47114: LD_VAR 0 3
47118: PPUSH
47119: CALL 72936 0 3
47123: ST_TO_ADDR
// end ; wait ( 1 ) ;
47124: LD_INT 1
47126: PPUSH
47127: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
47131: LD_ADDR_VAR 0 7
47135: PUSH
47136: LD_EXP 101
47140: PUSH
47141: LD_VAR 0 2
47145: ARRAY
47146: ST_TO_ADDR
// if mc_scan [ i ] then
47147: LD_EXP 123
47151: PUSH
47152: LD_VAR 0 2
47156: ARRAY
47157: IFFALSE 47219
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
47159: LD_ADDR_VAR 0 7
47163: PUSH
47164: LD_EXP 101
47168: PUSH
47169: LD_VAR 0 2
47173: ARRAY
47174: PPUSH
47175: LD_INT 3
47177: PUSH
47178: LD_INT 30
47180: PUSH
47181: LD_INT 32
47183: PUSH
47184: EMPTY
47185: LIST
47186: LIST
47187: PUSH
47188: LD_INT 30
47190: PUSH
47191: LD_INT 33
47193: PUSH
47194: EMPTY
47195: LIST
47196: LIST
47197: PUSH
47198: LD_INT 30
47200: PUSH
47201: LD_INT 31
47203: PUSH
47204: EMPTY
47205: LIST
47206: LIST
47207: PUSH
47208: EMPTY
47209: LIST
47210: LIST
47211: LIST
47212: LIST
47213: PPUSH
47214: CALL_OW 72
47218: ST_TO_ADDR
// if not to_repair_tmp then
47219: LD_VAR 0 7
47223: NOT
47224: IFFALSE 47228
// continue ;
47226: GO 47026
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
47228: LD_ADDR_VAR 0 8
47232: PUSH
47233: LD_VAR 0 7
47237: PPUSH
47238: LD_VAR 0 3
47242: PPUSH
47243: CALL_OW 74
47247: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
47248: LD_VAR 0 8
47252: PPUSH
47253: LD_INT 16
47255: PPUSH
47256: CALL 75533 0 2
47260: PUSH
47261: LD_INT 4
47263: ARRAY
47264: PUSH
47265: LD_INT 14
47267: LESS
47268: IFFALSE 47284
// ComRepairBuilding ( j , to_repair ) ;
47270: LD_VAR 0 3
47274: PPUSH
47275: LD_VAR 0 8
47279: PPUSH
47280: CALL_OW 130
// end ;
47284: GO 47026
47286: POP
47287: POP
// end ;
47288: GO 46396
47290: POP
47291: POP
// end ;
47292: LD_VAR 0 1
47296: RET
// export function MC_Heal ; var i , j , tmp ; begin
47297: LD_INT 0
47299: PPUSH
47300: PPUSH
47301: PPUSH
47302: PPUSH
// if not mc_bases then
47303: LD_EXP 100
47307: NOT
47308: IFFALSE 47312
// exit ;
47310: GO 47714
// for i = 1 to mc_bases do
47312: LD_ADDR_VAR 0 2
47316: PUSH
47317: DOUBLE
47318: LD_INT 1
47320: DEC
47321: ST_TO_ADDR
47322: LD_EXP 100
47326: PUSH
47327: FOR_TO
47328: IFFALSE 47712
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
47330: LD_EXP 103
47334: PUSH
47335: LD_VAR 0 2
47339: ARRAY
47340: PUSH
47341: LD_INT 1
47343: ARRAY
47344: NOT
47345: PUSH
47346: LD_EXP 103
47350: PUSH
47351: LD_VAR 0 2
47355: ARRAY
47356: PUSH
47357: LD_INT 2
47359: ARRAY
47360: NOT
47361: AND
47362: IFFALSE 47400
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
47364: LD_ADDR_EXP 104
47368: PUSH
47369: LD_EXP 104
47373: PPUSH
47374: LD_VAR 0 2
47378: PPUSH
47379: EMPTY
47380: PPUSH
47381: CALL_OW 1
47385: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
47386: LD_VAR 0 2
47390: PPUSH
47391: LD_INT 102
47393: PPUSH
47394: CALL 41449 0 2
// continue ;
47398: GO 47327
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
47400: LD_ADDR_VAR 0 4
47404: PUSH
47405: LD_EXP 100
47409: PUSH
47410: LD_VAR 0 2
47414: ARRAY
47415: PPUSH
47416: LD_INT 25
47418: PUSH
47419: LD_INT 4
47421: PUSH
47422: EMPTY
47423: LIST
47424: LIST
47425: PPUSH
47426: CALL_OW 72
47430: ST_TO_ADDR
// if not tmp then
47431: LD_VAR 0 4
47435: NOT
47436: IFFALSE 47440
// continue ;
47438: GO 47327
// if mc_taming [ i ] then
47440: LD_EXP 131
47444: PUSH
47445: LD_VAR 0 2
47449: ARRAY
47450: IFFALSE 47474
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
47452: LD_ADDR_EXP 131
47456: PUSH
47457: LD_EXP 131
47461: PPUSH
47462: LD_VAR 0 2
47466: PPUSH
47467: EMPTY
47468: PPUSH
47469: CALL_OW 1
47473: ST_TO_ADDR
// for j in tmp do
47474: LD_ADDR_VAR 0 3
47478: PUSH
47479: LD_VAR 0 4
47483: PUSH
47484: FOR_IN
47485: IFFALSE 47708
// begin if IsInUnit ( j ) then
47487: LD_VAR 0 3
47491: PPUSH
47492: CALL_OW 310
47496: IFFALSE 47507
// ComExitBuilding ( j ) ;
47498: LD_VAR 0 3
47502: PPUSH
47503: CALL_OW 122
// if not j in mc_healers [ i ] then
47507: LD_VAR 0 3
47511: PUSH
47512: LD_EXP 104
47516: PUSH
47517: LD_VAR 0 2
47521: ARRAY
47522: IN
47523: NOT
47524: IFFALSE 47570
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
47526: LD_ADDR_EXP 104
47530: PUSH
47531: LD_EXP 104
47535: PPUSH
47536: LD_VAR 0 2
47540: PUSH
47541: LD_EXP 104
47545: PUSH
47546: LD_VAR 0 2
47550: ARRAY
47551: PUSH
47552: LD_INT 1
47554: PLUS
47555: PUSH
47556: EMPTY
47557: LIST
47558: LIST
47559: PPUSH
47560: LD_VAR 0 3
47564: PPUSH
47565: CALL 72936 0 3
47569: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
47570: LD_VAR 0 3
47574: PPUSH
47575: CALL_OW 110
47579: PUSH
47580: LD_INT 102
47582: NONEQUAL
47583: IFFALSE 47597
// SetTag ( j , 102 ) ;
47585: LD_VAR 0 3
47589: PPUSH
47590: LD_INT 102
47592: PPUSH
47593: CALL_OW 109
// Wait ( 3 ) ;
47597: LD_INT 3
47599: PPUSH
47600: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
47604: LD_EXP 103
47608: PUSH
47609: LD_VAR 0 2
47613: ARRAY
47614: PUSH
47615: LD_INT 1
47617: ARRAY
47618: IFFALSE 47650
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
47620: LD_VAR 0 3
47624: PPUSH
47625: LD_EXP 103
47629: PUSH
47630: LD_VAR 0 2
47634: ARRAY
47635: PUSH
47636: LD_INT 1
47638: ARRAY
47639: PUSH
47640: LD_INT 1
47642: ARRAY
47643: PPUSH
47644: CALL_OW 128
47648: GO 47706
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
47650: LD_VAR 0 3
47654: PPUSH
47655: CALL_OW 314
47659: NOT
47660: PUSH
47661: LD_EXP 103
47665: PUSH
47666: LD_VAR 0 2
47670: ARRAY
47671: PUSH
47672: LD_INT 2
47674: ARRAY
47675: AND
47676: IFFALSE 47706
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
47678: LD_VAR 0 3
47682: PPUSH
47683: LD_EXP 103
47687: PUSH
47688: LD_VAR 0 2
47692: ARRAY
47693: PUSH
47694: LD_INT 2
47696: ARRAY
47697: PUSH
47698: LD_INT 1
47700: ARRAY
47701: PPUSH
47702: CALL_OW 128
// end ;
47706: GO 47484
47708: POP
47709: POP
// end ;
47710: GO 47327
47712: POP
47713: POP
// end ;
47714: LD_VAR 0 1
47718: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
47719: LD_INT 0
47721: PPUSH
47722: PPUSH
47723: PPUSH
47724: PPUSH
47725: PPUSH
47726: PPUSH
// if not mc_bases then
47727: LD_EXP 100
47731: NOT
47732: IFFALSE 47736
// exit ;
47734: GO 48899
// for i = 1 to mc_bases do
47736: LD_ADDR_VAR 0 2
47740: PUSH
47741: DOUBLE
47742: LD_INT 1
47744: DEC
47745: ST_TO_ADDR
47746: LD_EXP 100
47750: PUSH
47751: FOR_TO
47752: IFFALSE 48897
// begin if mc_scan [ i ] then
47754: LD_EXP 123
47758: PUSH
47759: LD_VAR 0 2
47763: ARRAY
47764: IFFALSE 47768
// continue ;
47766: GO 47751
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
47768: LD_EXP 105
47772: PUSH
47773: LD_VAR 0 2
47777: ARRAY
47778: NOT
47779: PUSH
47780: LD_EXP 107
47784: PUSH
47785: LD_VAR 0 2
47789: ARRAY
47790: NOT
47791: AND
47792: PUSH
47793: LD_EXP 106
47797: PUSH
47798: LD_VAR 0 2
47802: ARRAY
47803: AND
47804: IFFALSE 47842
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
47806: LD_ADDR_EXP 106
47810: PUSH
47811: LD_EXP 106
47815: PPUSH
47816: LD_VAR 0 2
47820: PPUSH
47821: EMPTY
47822: PPUSH
47823: CALL_OW 1
47827: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
47828: LD_VAR 0 2
47832: PPUSH
47833: LD_INT 103
47835: PPUSH
47836: CALL 41449 0 2
// continue ;
47840: GO 47751
// end ; if mc_construct_list [ i ] then
47842: LD_EXP 107
47846: PUSH
47847: LD_VAR 0 2
47851: ARRAY
47852: IFFALSE 48072
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
47854: LD_ADDR_VAR 0 5
47858: PUSH
47859: LD_EXP 100
47863: PUSH
47864: LD_VAR 0 2
47868: ARRAY
47869: PPUSH
47870: LD_INT 25
47872: PUSH
47873: LD_INT 2
47875: PUSH
47876: EMPTY
47877: LIST
47878: LIST
47879: PPUSH
47880: CALL_OW 72
47884: PUSH
47885: LD_EXP 102
47889: PUSH
47890: LD_VAR 0 2
47894: ARRAY
47895: DIFF
47896: ST_TO_ADDR
// if not tmp then
47897: LD_VAR 0 5
47901: NOT
47902: IFFALSE 47906
// continue ;
47904: GO 47751
// for j in tmp do
47906: LD_ADDR_VAR 0 3
47910: PUSH
47911: LD_VAR 0 5
47915: PUSH
47916: FOR_IN
47917: IFFALSE 48068
// begin if not mc_builders [ i ] then
47919: LD_EXP 106
47923: PUSH
47924: LD_VAR 0 2
47928: ARRAY
47929: NOT
47930: IFFALSE 47988
// begin SetTag ( j , 103 ) ;
47932: LD_VAR 0 3
47936: PPUSH
47937: LD_INT 103
47939: PPUSH
47940: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
47944: LD_ADDR_EXP 106
47948: PUSH
47949: LD_EXP 106
47953: PPUSH
47954: LD_VAR 0 2
47958: PUSH
47959: LD_EXP 106
47963: PUSH
47964: LD_VAR 0 2
47968: ARRAY
47969: PUSH
47970: LD_INT 1
47972: PLUS
47973: PUSH
47974: EMPTY
47975: LIST
47976: LIST
47977: PPUSH
47978: LD_VAR 0 3
47982: PPUSH
47983: CALL 72936 0 3
47987: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
47988: LD_VAR 0 3
47992: PPUSH
47993: CALL_OW 310
47997: IFFALSE 48008
// ComExitBuilding ( j ) ;
47999: LD_VAR 0 3
48003: PPUSH
48004: CALL_OW 122
// wait ( 3 ) ;
48008: LD_INT 3
48010: PPUSH
48011: CALL_OW 67
// if not mc_construct_list [ i ] then
48015: LD_EXP 107
48019: PUSH
48020: LD_VAR 0 2
48024: ARRAY
48025: NOT
48026: IFFALSE 48030
// break ;
48028: GO 48068
// if not HasTask ( j ) then
48030: LD_VAR 0 3
48034: PPUSH
48035: CALL_OW 314
48039: NOT
48040: IFFALSE 48066
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
48042: LD_VAR 0 3
48046: PPUSH
48047: LD_EXP 107
48051: PUSH
48052: LD_VAR 0 2
48056: ARRAY
48057: PUSH
48058: LD_INT 1
48060: ARRAY
48061: PPUSH
48062: CALL 75797 0 2
// end ;
48066: GO 47916
48068: POP
48069: POP
// end else
48070: GO 48895
// if mc_build_list [ i ] then
48072: LD_EXP 105
48076: PUSH
48077: LD_VAR 0 2
48081: ARRAY
48082: IFFALSE 48895
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
48084: LD_EXP 105
48088: PUSH
48089: LD_VAR 0 2
48093: ARRAY
48094: PUSH
48095: LD_INT 1
48097: ARRAY
48098: PUSH
48099: LD_INT 1
48101: ARRAY
48102: PPUSH
48103: CALL 75621 0 1
48107: PUSH
48108: LD_EXP 100
48112: PUSH
48113: LD_VAR 0 2
48117: ARRAY
48118: PPUSH
48119: LD_INT 2
48121: PUSH
48122: LD_INT 30
48124: PUSH
48125: LD_INT 2
48127: PUSH
48128: EMPTY
48129: LIST
48130: LIST
48131: PUSH
48132: LD_INT 30
48134: PUSH
48135: LD_INT 3
48137: PUSH
48138: EMPTY
48139: LIST
48140: LIST
48141: PUSH
48142: EMPTY
48143: LIST
48144: LIST
48145: LIST
48146: PPUSH
48147: CALL_OW 72
48151: NOT
48152: AND
48153: IFFALSE 48258
// begin for j = 1 to mc_build_list [ i ] do
48155: LD_ADDR_VAR 0 3
48159: PUSH
48160: DOUBLE
48161: LD_INT 1
48163: DEC
48164: ST_TO_ADDR
48165: LD_EXP 105
48169: PUSH
48170: LD_VAR 0 2
48174: ARRAY
48175: PUSH
48176: FOR_TO
48177: IFFALSE 48256
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
48179: LD_EXP 105
48183: PUSH
48184: LD_VAR 0 2
48188: ARRAY
48189: PUSH
48190: LD_VAR 0 3
48194: ARRAY
48195: PUSH
48196: LD_INT 1
48198: ARRAY
48199: PUSH
48200: LD_INT 2
48202: EQUAL
48203: IFFALSE 48254
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
48205: LD_ADDR_EXP 105
48209: PUSH
48210: LD_EXP 105
48214: PPUSH
48215: LD_VAR 0 2
48219: PPUSH
48220: LD_EXP 105
48224: PUSH
48225: LD_VAR 0 2
48229: ARRAY
48230: PPUSH
48231: LD_VAR 0 3
48235: PPUSH
48236: LD_INT 1
48238: PPUSH
48239: LD_INT 0
48241: PPUSH
48242: CALL 72354 0 4
48246: PPUSH
48247: CALL_OW 1
48251: ST_TO_ADDR
// break ;
48252: GO 48256
// end ;
48254: GO 48176
48256: POP
48257: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48258: LD_ADDR_VAR 0 6
48262: PUSH
48263: LD_EXP 100
48267: PUSH
48268: LD_VAR 0 2
48272: ARRAY
48273: PPUSH
48274: LD_INT 2
48276: PUSH
48277: LD_INT 30
48279: PUSH
48280: LD_INT 0
48282: PUSH
48283: EMPTY
48284: LIST
48285: LIST
48286: PUSH
48287: LD_INT 30
48289: PUSH
48290: LD_INT 1
48292: PUSH
48293: EMPTY
48294: LIST
48295: LIST
48296: PUSH
48297: EMPTY
48298: LIST
48299: LIST
48300: LIST
48301: PPUSH
48302: CALL_OW 72
48306: ST_TO_ADDR
// for k := 1 to depot do
48307: LD_ADDR_VAR 0 4
48311: PUSH
48312: DOUBLE
48313: LD_INT 1
48315: DEC
48316: ST_TO_ADDR
48317: LD_VAR 0 6
48321: PUSH
48322: FOR_TO
48323: IFFALSE 48893
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
48325: LD_EXP 105
48329: PUSH
48330: LD_VAR 0 2
48334: ARRAY
48335: PUSH
48336: LD_INT 1
48338: ARRAY
48339: PUSH
48340: LD_INT 1
48342: ARRAY
48343: PUSH
48344: LD_INT 0
48346: EQUAL
48347: PUSH
48348: LD_VAR 0 6
48352: PUSH
48353: LD_VAR 0 4
48357: ARRAY
48358: PPUSH
48359: LD_EXP 105
48363: PUSH
48364: LD_VAR 0 2
48368: ARRAY
48369: PUSH
48370: LD_INT 1
48372: ARRAY
48373: PUSH
48374: LD_INT 1
48376: ARRAY
48377: PPUSH
48378: LD_EXP 105
48382: PUSH
48383: LD_VAR 0 2
48387: ARRAY
48388: PUSH
48389: LD_INT 1
48391: ARRAY
48392: PUSH
48393: LD_INT 2
48395: ARRAY
48396: PPUSH
48397: LD_EXP 105
48401: PUSH
48402: LD_VAR 0 2
48406: ARRAY
48407: PUSH
48408: LD_INT 1
48410: ARRAY
48411: PUSH
48412: LD_INT 3
48414: ARRAY
48415: PPUSH
48416: LD_EXP 105
48420: PUSH
48421: LD_VAR 0 2
48425: ARRAY
48426: PUSH
48427: LD_INT 1
48429: ARRAY
48430: PUSH
48431: LD_INT 4
48433: ARRAY
48434: PPUSH
48435: CALL 81033 0 5
48439: OR
48440: IFFALSE 48721
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
48442: LD_ADDR_VAR 0 5
48446: PUSH
48447: LD_EXP 100
48451: PUSH
48452: LD_VAR 0 2
48456: ARRAY
48457: PPUSH
48458: LD_INT 25
48460: PUSH
48461: LD_INT 2
48463: PUSH
48464: EMPTY
48465: LIST
48466: LIST
48467: PPUSH
48468: CALL_OW 72
48472: PUSH
48473: LD_EXP 102
48477: PUSH
48478: LD_VAR 0 2
48482: ARRAY
48483: DIFF
48484: ST_TO_ADDR
// if not tmp then
48485: LD_VAR 0 5
48489: NOT
48490: IFFALSE 48494
// continue ;
48492: GO 48322
// for j in tmp do
48494: LD_ADDR_VAR 0 3
48498: PUSH
48499: LD_VAR 0 5
48503: PUSH
48504: FOR_IN
48505: IFFALSE 48717
// begin if not mc_builders [ i ] then
48507: LD_EXP 106
48511: PUSH
48512: LD_VAR 0 2
48516: ARRAY
48517: NOT
48518: IFFALSE 48576
// begin SetTag ( j , 103 ) ;
48520: LD_VAR 0 3
48524: PPUSH
48525: LD_INT 103
48527: PPUSH
48528: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
48532: LD_ADDR_EXP 106
48536: PUSH
48537: LD_EXP 106
48541: PPUSH
48542: LD_VAR 0 2
48546: PUSH
48547: LD_EXP 106
48551: PUSH
48552: LD_VAR 0 2
48556: ARRAY
48557: PUSH
48558: LD_INT 1
48560: PLUS
48561: PUSH
48562: EMPTY
48563: LIST
48564: LIST
48565: PPUSH
48566: LD_VAR 0 3
48570: PPUSH
48571: CALL 72936 0 3
48575: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
48576: LD_VAR 0 3
48580: PPUSH
48581: CALL_OW 310
48585: IFFALSE 48596
// ComExitBuilding ( j ) ;
48587: LD_VAR 0 3
48591: PPUSH
48592: CALL_OW 122
// wait ( 3 ) ;
48596: LD_INT 3
48598: PPUSH
48599: CALL_OW 67
// if not mc_build_list [ i ] then
48603: LD_EXP 105
48607: PUSH
48608: LD_VAR 0 2
48612: ARRAY
48613: NOT
48614: IFFALSE 48618
// break ;
48616: GO 48717
// if not HasTask ( j ) then
48618: LD_VAR 0 3
48622: PPUSH
48623: CALL_OW 314
48627: NOT
48628: IFFALSE 48715
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
48630: LD_VAR 0 3
48634: PPUSH
48635: LD_EXP 105
48639: PUSH
48640: LD_VAR 0 2
48644: ARRAY
48645: PUSH
48646: LD_INT 1
48648: ARRAY
48649: PUSH
48650: LD_INT 1
48652: ARRAY
48653: PPUSH
48654: LD_EXP 105
48658: PUSH
48659: LD_VAR 0 2
48663: ARRAY
48664: PUSH
48665: LD_INT 1
48667: ARRAY
48668: PUSH
48669: LD_INT 2
48671: ARRAY
48672: PPUSH
48673: LD_EXP 105
48677: PUSH
48678: LD_VAR 0 2
48682: ARRAY
48683: PUSH
48684: LD_INT 1
48686: ARRAY
48687: PUSH
48688: LD_INT 3
48690: ARRAY
48691: PPUSH
48692: LD_EXP 105
48696: PUSH
48697: LD_VAR 0 2
48701: ARRAY
48702: PUSH
48703: LD_INT 1
48705: ARRAY
48706: PUSH
48707: LD_INT 4
48709: ARRAY
48710: PPUSH
48711: CALL_OW 145
// end ;
48715: GO 48504
48717: POP
48718: POP
// end else
48719: GO 48891
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
48721: LD_EXP 100
48725: PUSH
48726: LD_VAR 0 2
48730: ARRAY
48731: PPUSH
48732: LD_EXP 105
48736: PUSH
48737: LD_VAR 0 2
48741: ARRAY
48742: PUSH
48743: LD_INT 1
48745: ARRAY
48746: PUSH
48747: LD_INT 1
48749: ARRAY
48750: PPUSH
48751: LD_EXP 105
48755: PUSH
48756: LD_VAR 0 2
48760: ARRAY
48761: PUSH
48762: LD_INT 1
48764: ARRAY
48765: PUSH
48766: LD_INT 2
48768: ARRAY
48769: PPUSH
48770: LD_EXP 105
48774: PUSH
48775: LD_VAR 0 2
48779: ARRAY
48780: PUSH
48781: LD_INT 1
48783: ARRAY
48784: PUSH
48785: LD_INT 3
48787: ARRAY
48788: PPUSH
48789: LD_EXP 105
48793: PUSH
48794: LD_VAR 0 2
48798: ARRAY
48799: PUSH
48800: LD_INT 1
48802: ARRAY
48803: PUSH
48804: LD_INT 4
48806: ARRAY
48807: PPUSH
48808: LD_EXP 100
48812: PUSH
48813: LD_VAR 0 2
48817: ARRAY
48818: PPUSH
48819: LD_INT 21
48821: PUSH
48822: LD_INT 3
48824: PUSH
48825: EMPTY
48826: LIST
48827: LIST
48828: PPUSH
48829: CALL_OW 72
48833: PPUSH
48834: EMPTY
48835: PPUSH
48836: CALL 79787 0 7
48840: NOT
48841: IFFALSE 48891
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
48843: LD_ADDR_EXP 105
48847: PUSH
48848: LD_EXP 105
48852: PPUSH
48853: LD_VAR 0 2
48857: PPUSH
48858: LD_EXP 105
48862: PUSH
48863: LD_VAR 0 2
48867: ARRAY
48868: PPUSH
48869: LD_INT 1
48871: PPUSH
48872: LD_INT 1
48874: NEG
48875: PPUSH
48876: LD_INT 0
48878: PPUSH
48879: CALL 72354 0 4
48883: PPUSH
48884: CALL_OW 1
48888: ST_TO_ADDR
// continue ;
48889: GO 48322
// end ; end ;
48891: GO 48322
48893: POP
48894: POP
// end ; end ;
48895: GO 47751
48897: POP
48898: POP
// end ;
48899: LD_VAR 0 1
48903: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
48904: LD_INT 0
48906: PPUSH
48907: PPUSH
48908: PPUSH
48909: PPUSH
48910: PPUSH
48911: PPUSH
// if not mc_bases then
48912: LD_EXP 100
48916: NOT
48917: IFFALSE 48921
// exit ;
48919: GO 49348
// for i = 1 to mc_bases do
48921: LD_ADDR_VAR 0 2
48925: PUSH
48926: DOUBLE
48927: LD_INT 1
48929: DEC
48930: ST_TO_ADDR
48931: LD_EXP 100
48935: PUSH
48936: FOR_TO
48937: IFFALSE 49346
// begin tmp := mc_build_upgrade [ i ] ;
48939: LD_ADDR_VAR 0 4
48943: PUSH
48944: LD_EXP 132
48948: PUSH
48949: LD_VAR 0 2
48953: ARRAY
48954: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
48955: LD_ADDR_VAR 0 6
48959: PUSH
48960: LD_EXP 133
48964: PUSH
48965: LD_VAR 0 2
48969: ARRAY
48970: PPUSH
48971: LD_INT 2
48973: PUSH
48974: LD_INT 30
48976: PUSH
48977: LD_INT 6
48979: PUSH
48980: EMPTY
48981: LIST
48982: LIST
48983: PUSH
48984: LD_INT 30
48986: PUSH
48987: LD_INT 7
48989: PUSH
48990: EMPTY
48991: LIST
48992: LIST
48993: PUSH
48994: EMPTY
48995: LIST
48996: LIST
48997: LIST
48998: PPUSH
48999: CALL_OW 72
49003: ST_TO_ADDR
// if not tmp and not lab then
49004: LD_VAR 0 4
49008: NOT
49009: PUSH
49010: LD_VAR 0 6
49014: NOT
49015: AND
49016: IFFALSE 49020
// continue ;
49018: GO 48936
// if tmp then
49020: LD_VAR 0 4
49024: IFFALSE 49144
// for j in tmp do
49026: LD_ADDR_VAR 0 3
49030: PUSH
49031: LD_VAR 0 4
49035: PUSH
49036: FOR_IN
49037: IFFALSE 49142
// begin if UpgradeCost ( j ) then
49039: LD_VAR 0 3
49043: PPUSH
49044: CALL 79447 0 1
49048: IFFALSE 49140
// begin ComUpgrade ( j ) ;
49050: LD_VAR 0 3
49054: PPUSH
49055: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
49059: LD_ADDR_EXP 132
49063: PUSH
49064: LD_EXP 132
49068: PPUSH
49069: LD_VAR 0 2
49073: PPUSH
49074: LD_EXP 132
49078: PUSH
49079: LD_VAR 0 2
49083: ARRAY
49084: PUSH
49085: LD_VAR 0 3
49089: DIFF
49090: PPUSH
49091: CALL_OW 1
49095: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
49096: LD_ADDR_EXP 107
49100: PUSH
49101: LD_EXP 107
49105: PPUSH
49106: LD_VAR 0 2
49110: PUSH
49111: LD_EXP 107
49115: PUSH
49116: LD_VAR 0 2
49120: ARRAY
49121: PUSH
49122: LD_INT 1
49124: PLUS
49125: PUSH
49126: EMPTY
49127: LIST
49128: LIST
49129: PPUSH
49130: LD_VAR 0 3
49134: PPUSH
49135: CALL 72936 0 3
49139: ST_TO_ADDR
// end ; end ;
49140: GO 49036
49142: POP
49143: POP
// if not lab or not mc_lab_upgrade [ i ] then
49144: LD_VAR 0 6
49148: NOT
49149: PUSH
49150: LD_EXP 134
49154: PUSH
49155: LD_VAR 0 2
49159: ARRAY
49160: NOT
49161: OR
49162: IFFALSE 49166
// continue ;
49164: GO 48936
// for j in lab do
49166: LD_ADDR_VAR 0 3
49170: PUSH
49171: LD_VAR 0 6
49175: PUSH
49176: FOR_IN
49177: IFFALSE 49342
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
49179: LD_VAR 0 3
49183: PPUSH
49184: CALL_OW 266
49188: PUSH
49189: LD_INT 6
49191: PUSH
49192: LD_INT 7
49194: PUSH
49195: EMPTY
49196: LIST
49197: LIST
49198: IN
49199: PUSH
49200: LD_VAR 0 3
49204: PPUSH
49205: CALL_OW 461
49209: PUSH
49210: LD_INT 1
49212: NONEQUAL
49213: AND
49214: IFFALSE 49340
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
49216: LD_VAR 0 3
49220: PPUSH
49221: LD_EXP 134
49225: PUSH
49226: LD_VAR 0 2
49230: ARRAY
49231: PUSH
49232: LD_INT 1
49234: ARRAY
49235: PPUSH
49236: CALL 79652 0 2
49240: IFFALSE 49340
// begin ComCancel ( j ) ;
49242: LD_VAR 0 3
49246: PPUSH
49247: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
49251: LD_VAR 0 3
49255: PPUSH
49256: LD_EXP 134
49260: PUSH
49261: LD_VAR 0 2
49265: ARRAY
49266: PUSH
49267: LD_INT 1
49269: ARRAY
49270: PPUSH
49271: CALL_OW 207
// if not j in mc_construct_list [ i ] then
49275: LD_VAR 0 3
49279: PUSH
49280: LD_EXP 107
49284: PUSH
49285: LD_VAR 0 2
49289: ARRAY
49290: IN
49291: NOT
49292: IFFALSE 49338
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
49294: LD_ADDR_EXP 107
49298: PUSH
49299: LD_EXP 107
49303: PPUSH
49304: LD_VAR 0 2
49308: PUSH
49309: LD_EXP 107
49313: PUSH
49314: LD_VAR 0 2
49318: ARRAY
49319: PUSH
49320: LD_INT 1
49322: PLUS
49323: PUSH
49324: EMPTY
49325: LIST
49326: LIST
49327: PPUSH
49328: LD_VAR 0 3
49332: PPUSH
49333: CALL 72936 0 3
49337: ST_TO_ADDR
// break ;
49338: GO 49342
// end ; end ; end ;
49340: GO 49176
49342: POP
49343: POP
// end ;
49344: GO 48936
49346: POP
49347: POP
// end ;
49348: LD_VAR 0 1
49352: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
49353: LD_INT 0
49355: PPUSH
49356: PPUSH
49357: PPUSH
49358: PPUSH
49359: PPUSH
49360: PPUSH
49361: PPUSH
49362: PPUSH
49363: PPUSH
// if not mc_bases then
49364: LD_EXP 100
49368: NOT
49369: IFFALSE 49373
// exit ;
49371: GO 49778
// for i = 1 to mc_bases do
49373: LD_ADDR_VAR 0 2
49377: PUSH
49378: DOUBLE
49379: LD_INT 1
49381: DEC
49382: ST_TO_ADDR
49383: LD_EXP 100
49387: PUSH
49388: FOR_TO
49389: IFFALSE 49776
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
49391: LD_EXP 108
49395: PUSH
49396: LD_VAR 0 2
49400: ARRAY
49401: NOT
49402: PUSH
49403: LD_EXP 100
49407: PUSH
49408: LD_VAR 0 2
49412: ARRAY
49413: PPUSH
49414: LD_INT 30
49416: PUSH
49417: LD_INT 3
49419: PUSH
49420: EMPTY
49421: LIST
49422: LIST
49423: PPUSH
49424: CALL_OW 72
49428: NOT
49429: OR
49430: IFFALSE 49434
// continue ;
49432: GO 49388
// busy := false ;
49434: LD_ADDR_VAR 0 8
49438: PUSH
49439: LD_INT 0
49441: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49442: LD_ADDR_VAR 0 4
49446: PUSH
49447: LD_EXP 100
49451: PUSH
49452: LD_VAR 0 2
49456: ARRAY
49457: PPUSH
49458: LD_INT 30
49460: PUSH
49461: LD_INT 3
49463: PUSH
49464: EMPTY
49465: LIST
49466: LIST
49467: PPUSH
49468: CALL_OW 72
49472: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
49473: LD_ADDR_VAR 0 6
49477: PUSH
49478: LD_EXP 108
49482: PUSH
49483: LD_VAR 0 2
49487: ARRAY
49488: PPUSH
49489: LD_INT 2
49491: PUSH
49492: LD_INT 30
49494: PUSH
49495: LD_INT 32
49497: PUSH
49498: EMPTY
49499: LIST
49500: LIST
49501: PUSH
49502: LD_INT 30
49504: PUSH
49505: LD_INT 33
49507: PUSH
49508: EMPTY
49509: LIST
49510: LIST
49511: PUSH
49512: EMPTY
49513: LIST
49514: LIST
49515: LIST
49516: PPUSH
49517: CALL_OW 72
49521: ST_TO_ADDR
// if not t then
49522: LD_VAR 0 6
49526: NOT
49527: IFFALSE 49531
// continue ;
49529: GO 49388
// for j in tmp do
49531: LD_ADDR_VAR 0 3
49535: PUSH
49536: LD_VAR 0 4
49540: PUSH
49541: FOR_IN
49542: IFFALSE 49572
// if not BuildingStatus ( j ) = bs_idle then
49544: LD_VAR 0 3
49548: PPUSH
49549: CALL_OW 461
49553: PUSH
49554: LD_INT 2
49556: EQUAL
49557: NOT
49558: IFFALSE 49570
// begin busy := true ;
49560: LD_ADDR_VAR 0 8
49564: PUSH
49565: LD_INT 1
49567: ST_TO_ADDR
// break ;
49568: GO 49572
// end ;
49570: GO 49541
49572: POP
49573: POP
// if busy then
49574: LD_VAR 0 8
49578: IFFALSE 49582
// continue ;
49580: GO 49388
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
49582: LD_ADDR_VAR 0 7
49586: PUSH
49587: LD_VAR 0 6
49591: PPUSH
49592: LD_INT 35
49594: PUSH
49595: LD_INT 0
49597: PUSH
49598: EMPTY
49599: LIST
49600: LIST
49601: PPUSH
49602: CALL_OW 72
49606: ST_TO_ADDR
// if tw then
49607: LD_VAR 0 7
49611: IFFALSE 49688
// begin tw := tw [ 1 ] ;
49613: LD_ADDR_VAR 0 7
49617: PUSH
49618: LD_VAR 0 7
49622: PUSH
49623: LD_INT 1
49625: ARRAY
49626: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
49627: LD_ADDR_VAR 0 9
49631: PUSH
49632: LD_VAR 0 7
49636: PPUSH
49637: LD_EXP 125
49641: PUSH
49642: LD_VAR 0 2
49646: ARRAY
49647: PPUSH
49648: CALL 77944 0 2
49652: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
49653: LD_EXP 139
49657: PUSH
49658: LD_VAR 0 2
49662: ARRAY
49663: IFFALSE 49686
// if not weapon in mc_allowed_tower_weapons [ i ] then
49665: LD_VAR 0 9
49669: PUSH
49670: LD_EXP 139
49674: PUSH
49675: LD_VAR 0 2
49679: ARRAY
49680: IN
49681: NOT
49682: IFFALSE 49686
// continue ;
49684: GO 49388
// end else
49686: GO 49751
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
49688: LD_ADDR_VAR 0 5
49692: PUSH
49693: LD_EXP 108
49697: PUSH
49698: LD_VAR 0 2
49702: ARRAY
49703: PPUSH
49704: LD_VAR 0 4
49708: PPUSH
49709: CALL 104814 0 2
49713: ST_TO_ADDR
// if not tmp2 then
49714: LD_VAR 0 5
49718: NOT
49719: IFFALSE 49723
// continue ;
49721: GO 49388
// tw := tmp2 [ 1 ] ;
49723: LD_ADDR_VAR 0 7
49727: PUSH
49728: LD_VAR 0 5
49732: PUSH
49733: LD_INT 1
49735: ARRAY
49736: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
49737: LD_ADDR_VAR 0 9
49741: PUSH
49742: LD_VAR 0 5
49746: PUSH
49747: LD_INT 2
49749: ARRAY
49750: ST_TO_ADDR
// end ; if not weapon then
49751: LD_VAR 0 9
49755: NOT
49756: IFFALSE 49760
// continue ;
49758: GO 49388
// ComPlaceWeapon ( tw , weapon ) ;
49760: LD_VAR 0 7
49764: PPUSH
49765: LD_VAR 0 9
49769: PPUSH
49770: CALL_OW 148
// end ;
49774: GO 49388
49776: POP
49777: POP
// end ;
49778: LD_VAR 0 1
49782: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
49783: LD_INT 0
49785: PPUSH
49786: PPUSH
49787: PPUSH
49788: PPUSH
49789: PPUSH
49790: PPUSH
49791: PPUSH
// if not mc_bases then
49792: LD_EXP 100
49796: NOT
49797: IFFALSE 49801
// exit ;
49799: GO 50576
// for i = 1 to mc_bases do
49801: LD_ADDR_VAR 0 2
49805: PUSH
49806: DOUBLE
49807: LD_INT 1
49809: DEC
49810: ST_TO_ADDR
49811: LD_EXP 100
49815: PUSH
49816: FOR_TO
49817: IFFALSE 50574
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
49819: LD_EXP 113
49823: PUSH
49824: LD_VAR 0 2
49828: ARRAY
49829: NOT
49830: PUSH
49831: LD_EXP 113
49835: PUSH
49836: LD_VAR 0 2
49840: ARRAY
49841: PUSH
49842: LD_EXP 114
49846: PUSH
49847: LD_VAR 0 2
49851: ARRAY
49852: EQUAL
49853: OR
49854: PUSH
49855: LD_EXP 123
49859: PUSH
49860: LD_VAR 0 2
49864: ARRAY
49865: OR
49866: IFFALSE 49870
// continue ;
49868: GO 49816
// if mc_miners [ i ] then
49870: LD_EXP 114
49874: PUSH
49875: LD_VAR 0 2
49879: ARRAY
49880: IFFALSE 50261
// begin for j = mc_miners [ i ] downto 1 do
49882: LD_ADDR_VAR 0 3
49886: PUSH
49887: DOUBLE
49888: LD_EXP 114
49892: PUSH
49893: LD_VAR 0 2
49897: ARRAY
49898: INC
49899: ST_TO_ADDR
49900: LD_INT 1
49902: PUSH
49903: FOR_DOWNTO
49904: IFFALSE 50259
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
49906: LD_EXP 114
49910: PUSH
49911: LD_VAR 0 2
49915: ARRAY
49916: PUSH
49917: LD_VAR 0 3
49921: ARRAY
49922: PPUSH
49923: CALL_OW 301
49927: PUSH
49928: LD_EXP 114
49932: PUSH
49933: LD_VAR 0 2
49937: ARRAY
49938: PUSH
49939: LD_VAR 0 3
49943: ARRAY
49944: PPUSH
49945: CALL_OW 257
49949: PUSH
49950: LD_INT 1
49952: NONEQUAL
49953: OR
49954: IFFALSE 50017
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
49956: LD_ADDR_VAR 0 5
49960: PUSH
49961: LD_EXP 114
49965: PUSH
49966: LD_VAR 0 2
49970: ARRAY
49971: PUSH
49972: LD_EXP 114
49976: PUSH
49977: LD_VAR 0 2
49981: ARRAY
49982: PUSH
49983: LD_VAR 0 3
49987: ARRAY
49988: DIFF
49989: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
49990: LD_ADDR_EXP 114
49994: PUSH
49995: LD_EXP 114
49999: PPUSH
50000: LD_VAR 0 2
50004: PPUSH
50005: LD_VAR 0 5
50009: PPUSH
50010: CALL_OW 1
50014: ST_TO_ADDR
// continue ;
50015: GO 49903
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
50017: LD_EXP 114
50021: PUSH
50022: LD_VAR 0 2
50026: ARRAY
50027: PUSH
50028: LD_VAR 0 3
50032: ARRAY
50033: PPUSH
50034: CALL_OW 257
50038: PUSH
50039: LD_INT 1
50041: EQUAL
50042: PUSH
50043: LD_EXP 114
50047: PUSH
50048: LD_VAR 0 2
50052: ARRAY
50053: PUSH
50054: LD_VAR 0 3
50058: ARRAY
50059: PPUSH
50060: CALL_OW 459
50064: NOT
50065: AND
50066: PUSH
50067: LD_EXP 114
50071: PUSH
50072: LD_VAR 0 2
50076: ARRAY
50077: PUSH
50078: LD_VAR 0 3
50082: ARRAY
50083: PPUSH
50084: CALL_OW 314
50088: NOT
50089: AND
50090: IFFALSE 50257
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
50092: LD_EXP 114
50096: PUSH
50097: LD_VAR 0 2
50101: ARRAY
50102: PUSH
50103: LD_VAR 0 3
50107: ARRAY
50108: PPUSH
50109: CALL_OW 310
50113: IFFALSE 50136
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
50115: LD_EXP 114
50119: PUSH
50120: LD_VAR 0 2
50124: ARRAY
50125: PUSH
50126: LD_VAR 0 3
50130: ARRAY
50131: PPUSH
50132: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
50136: LD_EXP 114
50140: PUSH
50141: LD_VAR 0 2
50145: ARRAY
50146: PUSH
50147: LD_VAR 0 3
50151: ARRAY
50152: PPUSH
50153: CALL_OW 314
50157: NOT
50158: IFFALSE 50257
// begin r := ( Count ( mc_mines [ i ] ) mod j ) + 1 ;
50160: LD_ADDR_VAR 0 7
50164: PUSH
50165: LD_EXP 113
50169: PUSH
50170: LD_VAR 0 2
50174: ARRAY
50175: PPUSH
50176: CALL 70076 0 1
50180: PUSH
50181: LD_VAR 0 3
50185: MOD
50186: PUSH
50187: LD_INT 1
50189: PLUS
50190: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
50191: LD_EXP 114
50195: PUSH
50196: LD_VAR 0 2
50200: ARRAY
50201: PUSH
50202: LD_VAR 0 3
50206: ARRAY
50207: PPUSH
50208: LD_EXP 113
50212: PUSH
50213: LD_VAR 0 2
50217: ARRAY
50218: PUSH
50219: LD_VAR 0 7
50223: ARRAY
50224: PUSH
50225: LD_INT 1
50227: ARRAY
50228: PPUSH
50229: LD_EXP 113
50233: PUSH
50234: LD_VAR 0 2
50238: ARRAY
50239: PUSH
50240: LD_VAR 0 7
50244: ARRAY
50245: PUSH
50246: LD_INT 2
50248: ARRAY
50249: PPUSH
50250: LD_INT 0
50252: PPUSH
50253: CALL_OW 193
// end ; end ; end ;
50257: GO 49903
50259: POP
50260: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
50261: LD_ADDR_VAR 0 5
50265: PUSH
50266: LD_EXP 100
50270: PUSH
50271: LD_VAR 0 2
50275: ARRAY
50276: PPUSH
50277: LD_INT 2
50279: PUSH
50280: LD_INT 30
50282: PUSH
50283: LD_INT 4
50285: PUSH
50286: EMPTY
50287: LIST
50288: LIST
50289: PUSH
50290: LD_INT 30
50292: PUSH
50293: LD_INT 5
50295: PUSH
50296: EMPTY
50297: LIST
50298: LIST
50299: PUSH
50300: LD_INT 30
50302: PUSH
50303: LD_INT 32
50305: PUSH
50306: EMPTY
50307: LIST
50308: LIST
50309: PUSH
50310: EMPTY
50311: LIST
50312: LIST
50313: LIST
50314: LIST
50315: PPUSH
50316: CALL_OW 72
50320: ST_TO_ADDR
// if not tmp then
50321: LD_VAR 0 5
50325: NOT
50326: IFFALSE 50330
// continue ;
50328: GO 49816
// list := [ ] ;
50330: LD_ADDR_VAR 0 6
50334: PUSH
50335: EMPTY
50336: ST_TO_ADDR
// for j in tmp do
50337: LD_ADDR_VAR 0 3
50341: PUSH
50342: LD_VAR 0 5
50346: PUSH
50347: FOR_IN
50348: IFFALSE 50417
// begin for k in UnitsInside ( j ) do
50350: LD_ADDR_VAR 0 4
50354: PUSH
50355: LD_VAR 0 3
50359: PPUSH
50360: CALL_OW 313
50364: PUSH
50365: FOR_IN
50366: IFFALSE 50413
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
50368: LD_VAR 0 4
50372: PPUSH
50373: CALL_OW 257
50377: PUSH
50378: LD_INT 1
50380: EQUAL
50381: PUSH
50382: LD_VAR 0 4
50386: PPUSH
50387: CALL_OW 459
50391: NOT
50392: AND
50393: IFFALSE 50411
// list := list ^ k ;
50395: LD_ADDR_VAR 0 6
50399: PUSH
50400: LD_VAR 0 6
50404: PUSH
50405: LD_VAR 0 4
50409: ADD
50410: ST_TO_ADDR
50411: GO 50365
50413: POP
50414: POP
// end ;
50415: GO 50347
50417: POP
50418: POP
// list := list diff mc_miners [ i ] ;
50419: LD_ADDR_VAR 0 6
50423: PUSH
50424: LD_VAR 0 6
50428: PUSH
50429: LD_EXP 114
50433: PUSH
50434: LD_VAR 0 2
50438: ARRAY
50439: DIFF
50440: ST_TO_ADDR
// if not list then
50441: LD_VAR 0 6
50445: NOT
50446: IFFALSE 50450
// continue ;
50448: GO 49816
// k := mc_mines [ i ] - mc_miners [ i ] ;
50450: LD_ADDR_VAR 0 4
50454: PUSH
50455: LD_EXP 113
50459: PUSH
50460: LD_VAR 0 2
50464: ARRAY
50465: PUSH
50466: LD_EXP 114
50470: PUSH
50471: LD_VAR 0 2
50475: ARRAY
50476: MINUS
50477: ST_TO_ADDR
// if k > list then
50478: LD_VAR 0 4
50482: PUSH
50483: LD_VAR 0 6
50487: GREATER
50488: IFFALSE 50500
// k := list ;
50490: LD_ADDR_VAR 0 4
50494: PUSH
50495: LD_VAR 0 6
50499: ST_TO_ADDR
// for j = 1 to k do
50500: LD_ADDR_VAR 0 3
50504: PUSH
50505: DOUBLE
50506: LD_INT 1
50508: DEC
50509: ST_TO_ADDR
50510: LD_VAR 0 4
50514: PUSH
50515: FOR_TO
50516: IFFALSE 50570
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
50518: LD_ADDR_EXP 114
50522: PUSH
50523: LD_EXP 114
50527: PPUSH
50528: LD_VAR 0 2
50532: PUSH
50533: LD_EXP 114
50537: PUSH
50538: LD_VAR 0 2
50542: ARRAY
50543: PUSH
50544: LD_INT 1
50546: PLUS
50547: PUSH
50548: EMPTY
50549: LIST
50550: LIST
50551: PPUSH
50552: LD_VAR 0 6
50556: PUSH
50557: LD_VAR 0 3
50561: ARRAY
50562: PPUSH
50563: CALL 72936 0 3
50567: ST_TO_ADDR
50568: GO 50515
50570: POP
50571: POP
// end ;
50572: GO 49816
50574: POP
50575: POP
// end ;
50576: LD_VAR 0 1
50580: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
50581: LD_INT 0
50583: PPUSH
50584: PPUSH
50585: PPUSH
50586: PPUSH
50587: PPUSH
50588: PPUSH
50589: PPUSH
50590: PPUSH
50591: PPUSH
50592: PPUSH
50593: PPUSH
// if not mc_bases then
50594: LD_EXP 100
50598: NOT
50599: IFFALSE 50603
// exit ;
50601: GO 52426
// for i = 1 to mc_bases do
50603: LD_ADDR_VAR 0 2
50607: PUSH
50608: DOUBLE
50609: LD_INT 1
50611: DEC
50612: ST_TO_ADDR
50613: LD_EXP 100
50617: PUSH
50618: FOR_TO
50619: IFFALSE 52424
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
50621: LD_EXP 100
50625: PUSH
50626: LD_VAR 0 2
50630: ARRAY
50631: NOT
50632: PUSH
50633: LD_EXP 107
50637: PUSH
50638: LD_VAR 0 2
50642: ARRAY
50643: OR
50644: IFFALSE 50648
// continue ;
50646: GO 50618
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
50648: LD_EXP 116
50652: PUSH
50653: LD_VAR 0 2
50657: ARRAY
50658: NOT
50659: PUSH
50660: LD_EXP 117
50664: PUSH
50665: LD_VAR 0 2
50669: ARRAY
50670: AND
50671: IFFALSE 50709
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
50673: LD_ADDR_EXP 117
50677: PUSH
50678: LD_EXP 117
50682: PPUSH
50683: LD_VAR 0 2
50687: PPUSH
50688: EMPTY
50689: PPUSH
50690: CALL_OW 1
50694: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
50695: LD_VAR 0 2
50699: PPUSH
50700: LD_INT 107
50702: PPUSH
50703: CALL 41449 0 2
// continue ;
50707: GO 50618
// end ; target := [ ] ;
50709: LD_ADDR_VAR 0 7
50713: PUSH
50714: EMPTY
50715: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
50716: LD_ADDR_VAR 0 6
50720: PUSH
50721: LD_EXP 100
50725: PUSH
50726: LD_VAR 0 2
50730: ARRAY
50731: PUSH
50732: LD_INT 1
50734: ARRAY
50735: PPUSH
50736: CALL_OW 255
50740: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50741: LD_ADDR_VAR 0 9
50745: PUSH
50746: LD_EXP 100
50750: PUSH
50751: LD_VAR 0 2
50755: ARRAY
50756: PPUSH
50757: LD_INT 2
50759: PUSH
50760: LD_INT 30
50762: PUSH
50763: LD_INT 0
50765: PUSH
50766: EMPTY
50767: LIST
50768: LIST
50769: PUSH
50770: LD_INT 30
50772: PUSH
50773: LD_INT 1
50775: PUSH
50776: EMPTY
50777: LIST
50778: LIST
50779: PUSH
50780: EMPTY
50781: LIST
50782: LIST
50783: LIST
50784: PPUSH
50785: CALL_OW 72
50789: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
50790: LD_ADDR_VAR 0 3
50794: PUSH
50795: DOUBLE
50796: LD_EXP 116
50800: PUSH
50801: LD_VAR 0 2
50805: ARRAY
50806: INC
50807: ST_TO_ADDR
50808: LD_INT 1
50810: PUSH
50811: FOR_DOWNTO
50812: IFFALSE 51057
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
50814: LD_EXP 116
50818: PUSH
50819: LD_VAR 0 2
50823: ARRAY
50824: PUSH
50825: LD_VAR 0 3
50829: ARRAY
50830: PUSH
50831: LD_INT 2
50833: ARRAY
50834: PPUSH
50835: LD_EXP 116
50839: PUSH
50840: LD_VAR 0 2
50844: ARRAY
50845: PUSH
50846: LD_VAR 0 3
50850: ARRAY
50851: PUSH
50852: LD_INT 3
50854: ARRAY
50855: PPUSH
50856: CALL_OW 488
50860: PUSH
50861: LD_EXP 116
50865: PUSH
50866: LD_VAR 0 2
50870: ARRAY
50871: PUSH
50872: LD_VAR 0 3
50876: ARRAY
50877: PUSH
50878: LD_INT 2
50880: ARRAY
50881: PPUSH
50882: LD_EXP 116
50886: PUSH
50887: LD_VAR 0 2
50891: ARRAY
50892: PUSH
50893: LD_VAR 0 3
50897: ARRAY
50898: PUSH
50899: LD_INT 3
50901: ARRAY
50902: PPUSH
50903: CALL_OW 284
50907: PUSH
50908: LD_INT 0
50910: EQUAL
50911: AND
50912: IFFALSE 50967
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
50914: LD_ADDR_VAR 0 5
50918: PUSH
50919: LD_EXP 116
50923: PUSH
50924: LD_VAR 0 2
50928: ARRAY
50929: PPUSH
50930: LD_VAR 0 3
50934: PPUSH
50935: CALL_OW 3
50939: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
50940: LD_ADDR_EXP 116
50944: PUSH
50945: LD_EXP 116
50949: PPUSH
50950: LD_VAR 0 2
50954: PPUSH
50955: LD_VAR 0 5
50959: PPUSH
50960: CALL_OW 1
50964: ST_TO_ADDR
// continue ;
50965: GO 50811
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
50967: LD_VAR 0 6
50971: PPUSH
50972: LD_EXP 116
50976: PUSH
50977: LD_VAR 0 2
50981: ARRAY
50982: PUSH
50983: LD_VAR 0 3
50987: ARRAY
50988: PUSH
50989: LD_INT 2
50991: ARRAY
50992: PPUSH
50993: LD_EXP 116
50997: PUSH
50998: LD_VAR 0 2
51002: ARRAY
51003: PUSH
51004: LD_VAR 0 3
51008: ARRAY
51009: PUSH
51010: LD_INT 3
51012: ARRAY
51013: PPUSH
51014: LD_INT 30
51016: PPUSH
51017: CALL 73832 0 4
51021: PUSH
51022: LD_INT 4
51024: ARRAY
51025: PUSH
51026: LD_INT 0
51028: EQUAL
51029: IFFALSE 51055
// begin target := mc_crates [ i ] [ j ] ;
51031: LD_ADDR_VAR 0 7
51035: PUSH
51036: LD_EXP 116
51040: PUSH
51041: LD_VAR 0 2
51045: ARRAY
51046: PUSH
51047: LD_VAR 0 3
51051: ARRAY
51052: ST_TO_ADDR
// break ;
51053: GO 51057
// end ; end ;
51055: GO 50811
51057: POP
51058: POP
// if not target then
51059: LD_VAR 0 7
51063: NOT
51064: IFFALSE 51068
// continue ;
51066: GO 50618
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
51068: LD_ADDR_VAR 0 8
51072: PUSH
51073: LD_EXP 119
51077: PUSH
51078: LD_VAR 0 2
51082: ARRAY
51083: PPUSH
51084: LD_INT 2
51086: PUSH
51087: LD_INT 3
51089: PUSH
51090: LD_INT 58
51092: PUSH
51093: EMPTY
51094: LIST
51095: PUSH
51096: EMPTY
51097: LIST
51098: LIST
51099: PUSH
51100: LD_INT 61
51102: PUSH
51103: EMPTY
51104: LIST
51105: PUSH
51106: LD_INT 33
51108: PUSH
51109: LD_INT 5
51111: PUSH
51112: EMPTY
51113: LIST
51114: LIST
51115: PUSH
51116: LD_INT 33
51118: PUSH
51119: LD_INT 3
51121: PUSH
51122: EMPTY
51123: LIST
51124: LIST
51125: PUSH
51126: EMPTY
51127: LIST
51128: LIST
51129: LIST
51130: LIST
51131: LIST
51132: PUSH
51133: LD_INT 2
51135: PUSH
51136: LD_INT 34
51138: PUSH
51139: LD_INT 32
51141: PUSH
51142: EMPTY
51143: LIST
51144: LIST
51145: PUSH
51146: LD_INT 34
51148: PUSH
51149: LD_INT 51
51151: PUSH
51152: EMPTY
51153: LIST
51154: LIST
51155: PUSH
51156: LD_INT 34
51158: PUSH
51159: LD_INT 12
51161: PUSH
51162: EMPTY
51163: LIST
51164: LIST
51165: PUSH
51166: EMPTY
51167: LIST
51168: LIST
51169: LIST
51170: LIST
51171: PUSH
51172: EMPTY
51173: LIST
51174: LIST
51175: PPUSH
51176: CALL_OW 72
51180: ST_TO_ADDR
// if not cargo then
51181: LD_VAR 0 8
51185: NOT
51186: IFFALSE 51892
// begin if mc_crates_collector [ i ] < 5 then
51188: LD_EXP 117
51192: PUSH
51193: LD_VAR 0 2
51197: ARRAY
51198: PUSH
51199: LD_INT 5
51201: LESS
51202: IFFALSE 51568
// begin if mc_ape [ i ] then
51204: LD_EXP 129
51208: PUSH
51209: LD_VAR 0 2
51213: ARRAY
51214: IFFALSE 51261
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
51216: LD_ADDR_VAR 0 5
51220: PUSH
51221: LD_EXP 129
51225: PUSH
51226: LD_VAR 0 2
51230: ARRAY
51231: PPUSH
51232: LD_INT 25
51234: PUSH
51235: LD_INT 16
51237: PUSH
51238: EMPTY
51239: LIST
51240: LIST
51241: PUSH
51242: LD_INT 24
51244: PUSH
51245: LD_INT 750
51247: PUSH
51248: EMPTY
51249: LIST
51250: LIST
51251: PUSH
51252: EMPTY
51253: LIST
51254: LIST
51255: PPUSH
51256: CALL_OW 72
51260: ST_TO_ADDR
// if not tmp then
51261: LD_VAR 0 5
51265: NOT
51266: IFFALSE 51313
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
51268: LD_ADDR_VAR 0 5
51272: PUSH
51273: LD_EXP 100
51277: PUSH
51278: LD_VAR 0 2
51282: ARRAY
51283: PPUSH
51284: LD_INT 25
51286: PUSH
51287: LD_INT 2
51289: PUSH
51290: EMPTY
51291: LIST
51292: LIST
51293: PUSH
51294: LD_INT 24
51296: PUSH
51297: LD_INT 750
51299: PUSH
51300: EMPTY
51301: LIST
51302: LIST
51303: PUSH
51304: EMPTY
51305: LIST
51306: LIST
51307: PPUSH
51308: CALL_OW 72
51312: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
51313: LD_EXP 129
51317: PUSH
51318: LD_VAR 0 2
51322: ARRAY
51323: PUSH
51324: LD_EXP 100
51328: PUSH
51329: LD_VAR 0 2
51333: ARRAY
51334: PPUSH
51335: LD_INT 25
51337: PUSH
51338: LD_INT 2
51340: PUSH
51341: EMPTY
51342: LIST
51343: LIST
51344: PUSH
51345: LD_INT 24
51347: PUSH
51348: LD_INT 750
51350: PUSH
51351: EMPTY
51352: LIST
51353: LIST
51354: PUSH
51355: EMPTY
51356: LIST
51357: LIST
51358: PPUSH
51359: CALL_OW 72
51363: AND
51364: PUSH
51365: LD_VAR 0 5
51369: PUSH
51370: LD_INT 5
51372: LESS
51373: AND
51374: IFFALSE 51456
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
51376: LD_ADDR_VAR 0 3
51380: PUSH
51381: LD_EXP 100
51385: PUSH
51386: LD_VAR 0 2
51390: ARRAY
51391: PPUSH
51392: LD_INT 25
51394: PUSH
51395: LD_INT 2
51397: PUSH
51398: EMPTY
51399: LIST
51400: LIST
51401: PUSH
51402: LD_INT 24
51404: PUSH
51405: LD_INT 750
51407: PUSH
51408: EMPTY
51409: LIST
51410: LIST
51411: PUSH
51412: EMPTY
51413: LIST
51414: LIST
51415: PPUSH
51416: CALL_OW 72
51420: PUSH
51421: FOR_IN
51422: IFFALSE 51454
// begin tmp := tmp union j ;
51424: LD_ADDR_VAR 0 5
51428: PUSH
51429: LD_VAR 0 5
51433: PUSH
51434: LD_VAR 0 3
51438: UNION
51439: ST_TO_ADDR
// if tmp >= 5 then
51440: LD_VAR 0 5
51444: PUSH
51445: LD_INT 5
51447: GREATEREQUAL
51448: IFFALSE 51452
// break ;
51450: GO 51454
// end ;
51452: GO 51421
51454: POP
51455: POP
// end ; if not tmp then
51456: LD_VAR 0 5
51460: NOT
51461: IFFALSE 51465
// continue ;
51463: GO 50618
// for j in tmp do
51465: LD_ADDR_VAR 0 3
51469: PUSH
51470: LD_VAR 0 5
51474: PUSH
51475: FOR_IN
51476: IFFALSE 51566
// if not GetTag ( j ) then
51478: LD_VAR 0 3
51482: PPUSH
51483: CALL_OW 110
51487: NOT
51488: IFFALSE 51564
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
51490: LD_ADDR_EXP 117
51494: PUSH
51495: LD_EXP 117
51499: PPUSH
51500: LD_VAR 0 2
51504: PUSH
51505: LD_EXP 117
51509: PUSH
51510: LD_VAR 0 2
51514: ARRAY
51515: PUSH
51516: LD_INT 1
51518: PLUS
51519: PUSH
51520: EMPTY
51521: LIST
51522: LIST
51523: PPUSH
51524: LD_VAR 0 3
51528: PPUSH
51529: CALL 72936 0 3
51533: ST_TO_ADDR
// SetTag ( j , 107 ) ;
51534: LD_VAR 0 3
51538: PPUSH
51539: LD_INT 107
51541: PPUSH
51542: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
51546: LD_EXP 117
51550: PUSH
51551: LD_VAR 0 2
51555: ARRAY
51556: PUSH
51557: LD_INT 5
51559: GREATEREQUAL
51560: IFFALSE 51564
// break ;
51562: GO 51566
// end ;
51564: GO 51475
51566: POP
51567: POP
// end ; if mc_crates_collector [ i ] and target then
51568: LD_EXP 117
51572: PUSH
51573: LD_VAR 0 2
51577: ARRAY
51578: PUSH
51579: LD_VAR 0 7
51583: AND
51584: IFFALSE 51890
// begin if mc_crates_collector [ i ] < target [ 1 ] then
51586: LD_EXP 117
51590: PUSH
51591: LD_VAR 0 2
51595: ARRAY
51596: PUSH
51597: LD_VAR 0 7
51601: PUSH
51602: LD_INT 1
51604: ARRAY
51605: LESS
51606: IFFALSE 51626
// tmp := mc_crates_collector [ i ] else
51608: LD_ADDR_VAR 0 5
51612: PUSH
51613: LD_EXP 117
51617: PUSH
51618: LD_VAR 0 2
51622: ARRAY
51623: ST_TO_ADDR
51624: GO 51640
// tmp := target [ 1 ] ;
51626: LD_ADDR_VAR 0 5
51630: PUSH
51631: LD_VAR 0 7
51635: PUSH
51636: LD_INT 1
51638: ARRAY
51639: ST_TO_ADDR
// k := 0 ;
51640: LD_ADDR_VAR 0 4
51644: PUSH
51645: LD_INT 0
51647: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
51648: LD_ADDR_VAR 0 3
51652: PUSH
51653: LD_EXP 117
51657: PUSH
51658: LD_VAR 0 2
51662: ARRAY
51663: PUSH
51664: FOR_IN
51665: IFFALSE 51888
// begin k := k + 1 ;
51667: LD_ADDR_VAR 0 4
51671: PUSH
51672: LD_VAR 0 4
51676: PUSH
51677: LD_INT 1
51679: PLUS
51680: ST_TO_ADDR
// if k > tmp then
51681: LD_VAR 0 4
51685: PUSH
51686: LD_VAR 0 5
51690: GREATER
51691: IFFALSE 51695
// break ;
51693: GO 51888
// if not GetClass ( j ) in [ 2 , 16 ] then
51695: LD_VAR 0 3
51699: PPUSH
51700: CALL_OW 257
51704: PUSH
51705: LD_INT 2
51707: PUSH
51708: LD_INT 16
51710: PUSH
51711: EMPTY
51712: LIST
51713: LIST
51714: IN
51715: NOT
51716: IFFALSE 51769
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
51718: LD_ADDR_EXP 117
51722: PUSH
51723: LD_EXP 117
51727: PPUSH
51728: LD_VAR 0 2
51732: PPUSH
51733: LD_EXP 117
51737: PUSH
51738: LD_VAR 0 2
51742: ARRAY
51743: PUSH
51744: LD_VAR 0 3
51748: DIFF
51749: PPUSH
51750: CALL_OW 1
51754: ST_TO_ADDR
// SetTag ( j , 0 ) ;
51755: LD_VAR 0 3
51759: PPUSH
51760: LD_INT 0
51762: PPUSH
51763: CALL_OW 109
// continue ;
51767: GO 51664
// end ; if IsInUnit ( j ) then
51769: LD_VAR 0 3
51773: PPUSH
51774: CALL_OW 310
51778: IFFALSE 51789
// ComExitBuilding ( j ) ;
51780: LD_VAR 0 3
51784: PPUSH
51785: CALL_OW 122
// wait ( 3 ) ;
51789: LD_INT 3
51791: PPUSH
51792: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
51796: LD_VAR 0 3
51800: PPUSH
51801: CALL_OW 314
51805: PUSH
51806: LD_VAR 0 6
51810: PPUSH
51811: LD_VAR 0 7
51815: PUSH
51816: LD_INT 2
51818: ARRAY
51819: PPUSH
51820: LD_VAR 0 7
51824: PUSH
51825: LD_INT 3
51827: ARRAY
51828: PPUSH
51829: LD_INT 30
51831: PPUSH
51832: CALL 73832 0 4
51836: PUSH
51837: LD_INT 4
51839: ARRAY
51840: AND
51841: IFFALSE 51859
// ComStandNearbyBuilding ( j , depot ) else
51843: LD_VAR 0 3
51847: PPUSH
51848: LD_VAR 0 9
51852: PPUSH
51853: CALL 69538 0 2
51857: GO 51886
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
51859: LD_VAR 0 3
51863: PPUSH
51864: LD_VAR 0 7
51868: PUSH
51869: LD_INT 2
51871: ARRAY
51872: PPUSH
51873: LD_VAR 0 7
51877: PUSH
51878: LD_INT 3
51880: ARRAY
51881: PPUSH
51882: CALL_OW 117
// end ;
51886: GO 51664
51888: POP
51889: POP
// end ; end else
51890: GO 52422
// begin for j in cargo do
51892: LD_ADDR_VAR 0 3
51896: PUSH
51897: LD_VAR 0 8
51901: PUSH
51902: FOR_IN
51903: IFFALSE 52420
// begin if GetTag ( j ) <> 0 then
51905: LD_VAR 0 3
51909: PPUSH
51910: CALL_OW 110
51914: PUSH
51915: LD_INT 0
51917: NONEQUAL
51918: IFFALSE 51922
// continue ;
51920: GO 51902
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
51922: LD_VAR 0 3
51926: PPUSH
51927: CALL_OW 256
51931: PUSH
51932: LD_INT 1000
51934: LESS
51935: PUSH
51936: LD_VAR 0 3
51940: PPUSH
51941: LD_EXP 124
51945: PUSH
51946: LD_VAR 0 2
51950: ARRAY
51951: PPUSH
51952: CALL_OW 308
51956: NOT
51957: AND
51958: IFFALSE 51980
// ComMoveToArea ( j , mc_parking [ i ] ) ;
51960: LD_VAR 0 3
51964: PPUSH
51965: LD_EXP 124
51969: PUSH
51970: LD_VAR 0 2
51974: ARRAY
51975: PPUSH
51976: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
51980: LD_VAR 0 3
51984: PPUSH
51985: CALL_OW 256
51989: PUSH
51990: LD_INT 1000
51992: LESS
51993: PUSH
51994: LD_VAR 0 3
51998: PPUSH
51999: LD_EXP 124
52003: PUSH
52004: LD_VAR 0 2
52008: ARRAY
52009: PPUSH
52010: CALL_OW 308
52014: AND
52015: IFFALSE 52019
// continue ;
52017: GO 51902
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
52019: LD_VAR 0 3
52023: PPUSH
52024: CALL_OW 262
52028: PUSH
52029: LD_INT 2
52031: EQUAL
52032: PUSH
52033: LD_VAR 0 3
52037: PPUSH
52038: CALL_OW 261
52042: PUSH
52043: LD_INT 15
52045: LESS
52046: AND
52047: IFFALSE 52051
// continue ;
52049: GO 51902
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
52051: LD_VAR 0 3
52055: PPUSH
52056: CALL_OW 262
52060: PUSH
52061: LD_INT 1
52063: EQUAL
52064: PUSH
52065: LD_VAR 0 3
52069: PPUSH
52070: CALL_OW 261
52074: PUSH
52075: LD_INT 10
52077: LESS
52078: AND
52079: IFFALSE 52359
// begin if not depot then
52081: LD_VAR 0 9
52085: NOT
52086: IFFALSE 52090
// continue ;
52088: GO 51902
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
52090: LD_VAR 0 3
52094: PPUSH
52095: LD_VAR 0 9
52099: PPUSH
52100: LD_VAR 0 3
52104: PPUSH
52105: CALL_OW 74
52109: PPUSH
52110: CALL_OW 296
52114: PUSH
52115: LD_INT 6
52117: LESS
52118: IFFALSE 52134
// SetFuel ( j , 100 ) else
52120: LD_VAR 0 3
52124: PPUSH
52125: LD_INT 100
52127: PPUSH
52128: CALL_OW 240
52132: GO 52359
// if GetFuel ( j ) = 0 then
52134: LD_VAR 0 3
52138: PPUSH
52139: CALL_OW 261
52143: PUSH
52144: LD_INT 0
52146: EQUAL
52147: IFFALSE 52359
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
52149: LD_ADDR_EXP 119
52153: PUSH
52154: LD_EXP 119
52158: PPUSH
52159: LD_VAR 0 2
52163: PPUSH
52164: LD_EXP 119
52168: PUSH
52169: LD_VAR 0 2
52173: ARRAY
52174: PUSH
52175: LD_VAR 0 3
52179: DIFF
52180: PPUSH
52181: CALL_OW 1
52185: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
52186: LD_VAR 0 3
52190: PPUSH
52191: CALL_OW 263
52195: PUSH
52196: LD_INT 1
52198: EQUAL
52199: IFFALSE 52215
// ComExitVehicle ( IsInUnit ( j ) ) ;
52201: LD_VAR 0 3
52205: PPUSH
52206: CALL_OW 310
52210: PPUSH
52211: CALL_OW 121
// if GetControl ( j ) = control_remote then
52215: LD_VAR 0 3
52219: PPUSH
52220: CALL_OW 263
52224: PUSH
52225: LD_INT 2
52227: EQUAL
52228: IFFALSE 52239
// ComUnlink ( j ) ;
52230: LD_VAR 0 3
52234: PPUSH
52235: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
52239: LD_ADDR_VAR 0 10
52243: PUSH
52244: LD_VAR 0 2
52248: PPUSH
52249: LD_INT 3
52251: PPUSH
52252: CALL 62003 0 2
52256: ST_TO_ADDR
// if fac then
52257: LD_VAR 0 10
52261: IFFALSE 52357
// begin for k in fac do
52263: LD_ADDR_VAR 0 4
52267: PUSH
52268: LD_VAR 0 10
52272: PUSH
52273: FOR_IN
52274: IFFALSE 52355
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
52276: LD_ADDR_VAR 0 11
52280: PUSH
52281: LD_VAR 0 10
52285: PPUSH
52286: LD_VAR 0 3
52290: PPUSH
52291: CALL_OW 265
52295: PPUSH
52296: LD_VAR 0 3
52300: PPUSH
52301: CALL_OW 262
52305: PPUSH
52306: LD_VAR 0 3
52310: PPUSH
52311: CALL_OW 263
52315: PPUSH
52316: LD_VAR 0 3
52320: PPUSH
52321: CALL_OW 264
52325: PPUSH
52326: CALL 70434 0 5
52330: ST_TO_ADDR
// if components then
52331: LD_VAR 0 11
52335: IFFALSE 52353
// begin MC_InsertProduceList ( i , components ) ;
52337: LD_VAR 0 2
52341: PPUSH
52342: LD_VAR 0 11
52346: PPUSH
52347: CALL 61548 0 2
// break ;
52351: GO 52355
// end ; end ;
52353: GO 52273
52355: POP
52356: POP
// end ; continue ;
52357: GO 51902
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
52359: LD_VAR 0 3
52363: PPUSH
52364: LD_INT 1
52366: PPUSH
52367: CALL_OW 289
52371: PUSH
52372: LD_INT 100
52374: LESS
52375: PUSH
52376: LD_VAR 0 3
52380: PPUSH
52381: CALL_OW 314
52385: NOT
52386: AND
52387: IFFALSE 52416
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
52389: LD_VAR 0 3
52393: PPUSH
52394: LD_VAR 0 7
52398: PUSH
52399: LD_INT 2
52401: ARRAY
52402: PPUSH
52403: LD_VAR 0 7
52407: PUSH
52408: LD_INT 3
52410: ARRAY
52411: PPUSH
52412: CALL_OW 117
// break ;
52416: GO 52420
// end ;
52418: GO 51902
52420: POP
52421: POP
// end ; end ;
52422: GO 50618
52424: POP
52425: POP
// end ;
52426: LD_VAR 0 1
52430: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
52431: LD_INT 0
52433: PPUSH
52434: PPUSH
52435: PPUSH
52436: PPUSH
// if not mc_bases then
52437: LD_EXP 100
52441: NOT
52442: IFFALSE 52446
// exit ;
52444: GO 52607
// for i = 1 to mc_bases do
52446: LD_ADDR_VAR 0 2
52450: PUSH
52451: DOUBLE
52452: LD_INT 1
52454: DEC
52455: ST_TO_ADDR
52456: LD_EXP 100
52460: PUSH
52461: FOR_TO
52462: IFFALSE 52605
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
52464: LD_ADDR_VAR 0 4
52468: PUSH
52469: LD_EXP 119
52473: PUSH
52474: LD_VAR 0 2
52478: ARRAY
52479: PUSH
52480: LD_EXP 122
52484: PUSH
52485: LD_VAR 0 2
52489: ARRAY
52490: UNION
52491: PPUSH
52492: LD_INT 33
52494: PUSH
52495: LD_INT 2
52497: PUSH
52498: EMPTY
52499: LIST
52500: LIST
52501: PPUSH
52502: CALL_OW 72
52506: ST_TO_ADDR
// if tmp then
52507: LD_VAR 0 4
52511: IFFALSE 52603
// for j in tmp do
52513: LD_ADDR_VAR 0 3
52517: PUSH
52518: LD_VAR 0 4
52522: PUSH
52523: FOR_IN
52524: IFFALSE 52601
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
52526: LD_VAR 0 3
52530: PPUSH
52531: CALL_OW 312
52535: NOT
52536: PUSH
52537: LD_VAR 0 3
52541: PPUSH
52542: CALL_OW 256
52546: PUSH
52547: LD_INT 250
52549: GREATEREQUAL
52550: AND
52551: IFFALSE 52564
// Connect ( j ) else
52553: LD_VAR 0 3
52557: PPUSH
52558: CALL 75905 0 1
52562: GO 52599
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
52564: LD_VAR 0 3
52568: PPUSH
52569: CALL_OW 256
52573: PUSH
52574: LD_INT 250
52576: LESS
52577: PUSH
52578: LD_VAR 0 3
52582: PPUSH
52583: CALL_OW 312
52587: AND
52588: IFFALSE 52599
// ComUnlink ( j ) ;
52590: LD_VAR 0 3
52594: PPUSH
52595: CALL_OW 136
52599: GO 52523
52601: POP
52602: POP
// end ;
52603: GO 52461
52605: POP
52606: POP
// end ;
52607: LD_VAR 0 1
52611: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
52612: LD_INT 0
52614: PPUSH
52615: PPUSH
52616: PPUSH
52617: PPUSH
52618: PPUSH
// if not mc_bases then
52619: LD_EXP 100
52623: NOT
52624: IFFALSE 52628
// exit ;
52626: GO 53073
// for i = 1 to mc_bases do
52628: LD_ADDR_VAR 0 2
52632: PUSH
52633: DOUBLE
52634: LD_INT 1
52636: DEC
52637: ST_TO_ADDR
52638: LD_EXP 100
52642: PUSH
52643: FOR_TO
52644: IFFALSE 53071
// begin if not mc_produce [ i ] then
52646: LD_EXP 121
52650: PUSH
52651: LD_VAR 0 2
52655: ARRAY
52656: NOT
52657: IFFALSE 52661
// continue ;
52659: GO 52643
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52661: LD_ADDR_VAR 0 5
52665: PUSH
52666: LD_EXP 100
52670: PUSH
52671: LD_VAR 0 2
52675: ARRAY
52676: PPUSH
52677: LD_INT 30
52679: PUSH
52680: LD_INT 3
52682: PUSH
52683: EMPTY
52684: LIST
52685: LIST
52686: PPUSH
52687: CALL_OW 72
52691: ST_TO_ADDR
// if not fac then
52692: LD_VAR 0 5
52696: NOT
52697: IFFALSE 52701
// continue ;
52699: GO 52643
// for j in fac do
52701: LD_ADDR_VAR 0 3
52705: PUSH
52706: LD_VAR 0 5
52710: PUSH
52711: FOR_IN
52712: IFFALSE 53067
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
52714: LD_VAR 0 3
52718: PPUSH
52719: CALL_OW 461
52723: PUSH
52724: LD_INT 2
52726: NONEQUAL
52727: PUSH
52728: LD_VAR 0 3
52732: PPUSH
52733: LD_INT 15
52735: PPUSH
52736: CALL 75533 0 2
52740: PUSH
52741: LD_INT 4
52743: ARRAY
52744: OR
52745: IFFALSE 52749
// continue ;
52747: GO 52711
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
52749: LD_VAR 0 3
52753: PPUSH
52754: LD_EXP 121
52758: PUSH
52759: LD_VAR 0 2
52763: ARRAY
52764: PUSH
52765: LD_INT 1
52767: ARRAY
52768: PUSH
52769: LD_INT 1
52771: ARRAY
52772: PPUSH
52773: LD_EXP 121
52777: PUSH
52778: LD_VAR 0 2
52782: ARRAY
52783: PUSH
52784: LD_INT 1
52786: ARRAY
52787: PUSH
52788: LD_INT 2
52790: ARRAY
52791: PPUSH
52792: LD_EXP 121
52796: PUSH
52797: LD_VAR 0 2
52801: ARRAY
52802: PUSH
52803: LD_INT 1
52805: ARRAY
52806: PUSH
52807: LD_INT 3
52809: ARRAY
52810: PPUSH
52811: LD_EXP 121
52815: PUSH
52816: LD_VAR 0 2
52820: ARRAY
52821: PUSH
52822: LD_INT 1
52824: ARRAY
52825: PUSH
52826: LD_INT 4
52828: ARRAY
52829: PPUSH
52830: CALL_OW 448
52834: PUSH
52835: LD_VAR 0 3
52839: PPUSH
52840: LD_EXP 121
52844: PUSH
52845: LD_VAR 0 2
52849: ARRAY
52850: PUSH
52851: LD_INT 1
52853: ARRAY
52854: PUSH
52855: LD_INT 1
52857: ARRAY
52858: PUSH
52859: LD_EXP 121
52863: PUSH
52864: LD_VAR 0 2
52868: ARRAY
52869: PUSH
52870: LD_INT 1
52872: ARRAY
52873: PUSH
52874: LD_INT 2
52876: ARRAY
52877: PUSH
52878: LD_EXP 121
52882: PUSH
52883: LD_VAR 0 2
52887: ARRAY
52888: PUSH
52889: LD_INT 1
52891: ARRAY
52892: PUSH
52893: LD_INT 3
52895: ARRAY
52896: PUSH
52897: LD_EXP 121
52901: PUSH
52902: LD_VAR 0 2
52906: ARRAY
52907: PUSH
52908: LD_INT 1
52910: ARRAY
52911: PUSH
52912: LD_INT 4
52914: ARRAY
52915: PUSH
52916: EMPTY
52917: LIST
52918: LIST
52919: LIST
52920: LIST
52921: PPUSH
52922: CALL 79300 0 2
52926: AND
52927: IFFALSE 53065
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
52929: LD_VAR 0 3
52933: PPUSH
52934: LD_EXP 121
52938: PUSH
52939: LD_VAR 0 2
52943: ARRAY
52944: PUSH
52945: LD_INT 1
52947: ARRAY
52948: PUSH
52949: LD_INT 1
52951: ARRAY
52952: PPUSH
52953: LD_EXP 121
52957: PUSH
52958: LD_VAR 0 2
52962: ARRAY
52963: PUSH
52964: LD_INT 1
52966: ARRAY
52967: PUSH
52968: LD_INT 2
52970: ARRAY
52971: PPUSH
52972: LD_EXP 121
52976: PUSH
52977: LD_VAR 0 2
52981: ARRAY
52982: PUSH
52983: LD_INT 1
52985: ARRAY
52986: PUSH
52987: LD_INT 3
52989: ARRAY
52990: PPUSH
52991: LD_EXP 121
52995: PUSH
52996: LD_VAR 0 2
53000: ARRAY
53001: PUSH
53002: LD_INT 1
53004: ARRAY
53005: PUSH
53006: LD_INT 4
53008: ARRAY
53009: PPUSH
53010: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
53014: LD_ADDR_VAR 0 4
53018: PUSH
53019: LD_EXP 121
53023: PUSH
53024: LD_VAR 0 2
53028: ARRAY
53029: PPUSH
53030: LD_INT 1
53032: PPUSH
53033: CALL_OW 3
53037: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
53038: LD_ADDR_EXP 121
53042: PUSH
53043: LD_EXP 121
53047: PPUSH
53048: LD_VAR 0 2
53052: PPUSH
53053: LD_VAR 0 4
53057: PPUSH
53058: CALL_OW 1
53062: ST_TO_ADDR
// break ;
53063: GO 53067
// end ; end ;
53065: GO 52711
53067: POP
53068: POP
// end ;
53069: GO 52643
53071: POP
53072: POP
// end ;
53073: LD_VAR 0 1
53077: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
53078: LD_INT 0
53080: PPUSH
53081: PPUSH
53082: PPUSH
// if not mc_bases then
53083: LD_EXP 100
53087: NOT
53088: IFFALSE 53092
// exit ;
53090: GO 53181
// for i = 1 to mc_bases do
53092: LD_ADDR_VAR 0 2
53096: PUSH
53097: DOUBLE
53098: LD_INT 1
53100: DEC
53101: ST_TO_ADDR
53102: LD_EXP 100
53106: PUSH
53107: FOR_TO
53108: IFFALSE 53179
// begin if mc_attack [ i ] then
53110: LD_EXP 120
53114: PUSH
53115: LD_VAR 0 2
53119: ARRAY
53120: IFFALSE 53177
// begin tmp := mc_attack [ i ] [ 1 ] ;
53122: LD_ADDR_VAR 0 3
53126: PUSH
53127: LD_EXP 120
53131: PUSH
53132: LD_VAR 0 2
53136: ARRAY
53137: PUSH
53138: LD_INT 1
53140: ARRAY
53141: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
53142: LD_ADDR_EXP 120
53146: PUSH
53147: LD_EXP 120
53151: PPUSH
53152: LD_VAR 0 2
53156: PPUSH
53157: EMPTY
53158: PPUSH
53159: CALL_OW 1
53163: ST_TO_ADDR
// Attack ( tmp ) ;
53164: LD_VAR 0 3
53168: PPUSH
53169: CALL 129421 0 1
// exit ;
53173: POP
53174: POP
53175: GO 53181
// end ; end ;
53177: GO 53107
53179: POP
53180: POP
// end ;
53181: LD_VAR 0 1
53185: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
53186: LD_INT 0
53188: PPUSH
53189: PPUSH
53190: PPUSH
53191: PPUSH
53192: PPUSH
53193: PPUSH
53194: PPUSH
// if not mc_bases then
53195: LD_EXP 100
53199: NOT
53200: IFFALSE 53204
// exit ;
53202: GO 54061
// for i = 1 to mc_bases do
53204: LD_ADDR_VAR 0 2
53208: PUSH
53209: DOUBLE
53210: LD_INT 1
53212: DEC
53213: ST_TO_ADDR
53214: LD_EXP 100
53218: PUSH
53219: FOR_TO
53220: IFFALSE 54059
// begin if not mc_bases [ i ] then
53222: LD_EXP 100
53226: PUSH
53227: LD_VAR 0 2
53231: ARRAY
53232: NOT
53233: IFFALSE 53237
// continue ;
53235: GO 53219
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
53237: LD_ADDR_VAR 0 7
53241: PUSH
53242: LD_EXP 100
53246: PUSH
53247: LD_VAR 0 2
53251: ARRAY
53252: PUSH
53253: LD_INT 1
53255: ARRAY
53256: PPUSH
53257: CALL 69760 0 1
53261: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
53262: LD_ADDR_EXP 123
53266: PUSH
53267: LD_EXP 123
53271: PPUSH
53272: LD_VAR 0 2
53276: PPUSH
53277: LD_EXP 100
53281: PUSH
53282: LD_VAR 0 2
53286: ARRAY
53287: PUSH
53288: LD_INT 1
53290: ARRAY
53291: PPUSH
53292: CALL_OW 255
53296: PPUSH
53297: LD_EXP 125
53301: PUSH
53302: LD_VAR 0 2
53306: ARRAY
53307: PPUSH
53308: CALL 69725 0 2
53312: PPUSH
53313: CALL_OW 1
53317: ST_TO_ADDR
// if not mc_scan [ i ] then
53318: LD_EXP 123
53322: PUSH
53323: LD_VAR 0 2
53327: ARRAY
53328: NOT
53329: IFFALSE 53507
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
53331: LD_ADDR_EXP 143
53335: PUSH
53336: LD_EXP 143
53340: PPUSH
53341: LD_VAR 0 2
53345: PPUSH
53346: LD_INT 0
53348: PPUSH
53349: CALL_OW 1
53353: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
53354: LD_ADDR_VAR 0 4
53358: PUSH
53359: LD_EXP 100
53363: PUSH
53364: LD_VAR 0 2
53368: ARRAY
53369: PPUSH
53370: LD_INT 2
53372: PUSH
53373: LD_INT 25
53375: PUSH
53376: LD_INT 5
53378: PUSH
53379: EMPTY
53380: LIST
53381: LIST
53382: PUSH
53383: LD_INT 25
53385: PUSH
53386: LD_INT 8
53388: PUSH
53389: EMPTY
53390: LIST
53391: LIST
53392: PUSH
53393: LD_INT 25
53395: PUSH
53396: LD_INT 9
53398: PUSH
53399: EMPTY
53400: LIST
53401: LIST
53402: PUSH
53403: EMPTY
53404: LIST
53405: LIST
53406: LIST
53407: LIST
53408: PPUSH
53409: CALL_OW 72
53413: ST_TO_ADDR
// if not tmp then
53414: LD_VAR 0 4
53418: NOT
53419: IFFALSE 53423
// continue ;
53421: GO 53219
// for j in tmp do
53423: LD_ADDR_VAR 0 3
53427: PUSH
53428: LD_VAR 0 4
53432: PUSH
53433: FOR_IN
53434: IFFALSE 53505
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
53436: LD_VAR 0 3
53440: PPUSH
53441: CALL_OW 310
53445: PPUSH
53446: CALL_OW 266
53450: PUSH
53451: LD_INT 5
53453: EQUAL
53454: PUSH
53455: LD_VAR 0 3
53459: PPUSH
53460: CALL_OW 257
53464: PUSH
53465: LD_INT 1
53467: EQUAL
53468: AND
53469: PUSH
53470: LD_VAR 0 3
53474: PPUSH
53475: CALL_OW 459
53479: NOT
53480: AND
53481: PUSH
53482: LD_VAR 0 7
53486: AND
53487: IFFALSE 53503
// ComChangeProfession ( j , class ) ;
53489: LD_VAR 0 3
53493: PPUSH
53494: LD_VAR 0 7
53498: PPUSH
53499: CALL_OW 123
53503: GO 53433
53505: POP
53506: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
53507: LD_EXP 123
53511: PUSH
53512: LD_VAR 0 2
53516: ARRAY
53517: PUSH
53518: LD_EXP 143
53522: PUSH
53523: LD_VAR 0 2
53527: ARRAY
53528: NOT
53529: AND
53530: PUSH
53531: LD_EXP 122
53535: PUSH
53536: LD_VAR 0 2
53540: ARRAY
53541: NOT
53542: AND
53543: PUSH
53544: LD_EXP 100
53548: PUSH
53549: LD_VAR 0 2
53553: ARRAY
53554: PPUSH
53555: LD_INT 50
53557: PUSH
53558: EMPTY
53559: LIST
53560: PUSH
53561: LD_INT 2
53563: PUSH
53564: LD_INT 30
53566: PUSH
53567: LD_INT 32
53569: PUSH
53570: EMPTY
53571: LIST
53572: LIST
53573: PUSH
53574: LD_INT 30
53576: PUSH
53577: LD_INT 33
53579: PUSH
53580: EMPTY
53581: LIST
53582: LIST
53583: PUSH
53584: LD_INT 30
53586: PUSH
53587: LD_INT 4
53589: PUSH
53590: EMPTY
53591: LIST
53592: LIST
53593: PUSH
53594: LD_INT 30
53596: PUSH
53597: LD_INT 5
53599: PUSH
53600: EMPTY
53601: LIST
53602: LIST
53603: PUSH
53604: EMPTY
53605: LIST
53606: LIST
53607: LIST
53608: LIST
53609: LIST
53610: PUSH
53611: EMPTY
53612: LIST
53613: LIST
53614: PPUSH
53615: CALL_OW 72
53619: PUSH
53620: LD_INT 4
53622: LESS
53623: PUSH
53624: LD_EXP 100
53628: PUSH
53629: LD_VAR 0 2
53633: ARRAY
53634: PPUSH
53635: LD_INT 3
53637: PUSH
53638: LD_INT 24
53640: PUSH
53641: LD_INT 1000
53643: PUSH
53644: EMPTY
53645: LIST
53646: LIST
53647: PUSH
53648: EMPTY
53649: LIST
53650: LIST
53651: PUSH
53652: LD_INT 2
53654: PUSH
53655: LD_INT 30
53657: PUSH
53658: LD_INT 0
53660: PUSH
53661: EMPTY
53662: LIST
53663: LIST
53664: PUSH
53665: LD_INT 30
53667: PUSH
53668: LD_INT 1
53670: PUSH
53671: EMPTY
53672: LIST
53673: LIST
53674: PUSH
53675: EMPTY
53676: LIST
53677: LIST
53678: LIST
53679: PUSH
53680: EMPTY
53681: LIST
53682: LIST
53683: PPUSH
53684: CALL_OW 72
53688: OR
53689: AND
53690: IFFALSE 53941
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
53692: LD_ADDR_EXP 143
53696: PUSH
53697: LD_EXP 143
53701: PPUSH
53702: LD_VAR 0 2
53706: PPUSH
53707: LD_INT 1
53709: PPUSH
53710: CALL_OW 1
53714: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
53715: LD_ADDR_VAR 0 4
53719: PUSH
53720: LD_EXP 100
53724: PUSH
53725: LD_VAR 0 2
53729: ARRAY
53730: PPUSH
53731: LD_INT 2
53733: PUSH
53734: LD_INT 25
53736: PUSH
53737: LD_INT 1
53739: PUSH
53740: EMPTY
53741: LIST
53742: LIST
53743: PUSH
53744: LD_INT 25
53746: PUSH
53747: LD_INT 5
53749: PUSH
53750: EMPTY
53751: LIST
53752: LIST
53753: PUSH
53754: LD_INT 25
53756: PUSH
53757: LD_INT 8
53759: PUSH
53760: EMPTY
53761: LIST
53762: LIST
53763: PUSH
53764: LD_INT 25
53766: PUSH
53767: LD_INT 9
53769: PUSH
53770: EMPTY
53771: LIST
53772: LIST
53773: PUSH
53774: EMPTY
53775: LIST
53776: LIST
53777: LIST
53778: LIST
53779: LIST
53780: PPUSH
53781: CALL_OW 72
53785: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
53786: LD_ADDR_VAR 0 4
53790: PUSH
53791: LD_VAR 0 4
53795: PUSH
53796: LD_VAR 0 4
53800: PPUSH
53801: LD_INT 18
53803: PPUSH
53804: CALL 102848 0 2
53808: DIFF
53809: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
53810: LD_VAR 0 4
53814: NOT
53815: PUSH
53816: LD_EXP 100
53820: PUSH
53821: LD_VAR 0 2
53825: ARRAY
53826: PPUSH
53827: LD_INT 2
53829: PUSH
53830: LD_INT 30
53832: PUSH
53833: LD_INT 4
53835: PUSH
53836: EMPTY
53837: LIST
53838: LIST
53839: PUSH
53840: LD_INT 30
53842: PUSH
53843: LD_INT 5
53845: PUSH
53846: EMPTY
53847: LIST
53848: LIST
53849: PUSH
53850: EMPTY
53851: LIST
53852: LIST
53853: LIST
53854: PPUSH
53855: CALL_OW 72
53859: NOT
53860: AND
53861: IFFALSE 53923
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
53863: LD_ADDR_VAR 0 4
53867: PUSH
53868: LD_EXP 100
53872: PUSH
53873: LD_VAR 0 2
53877: ARRAY
53878: PPUSH
53879: LD_INT 2
53881: PUSH
53882: LD_INT 25
53884: PUSH
53885: LD_INT 2
53887: PUSH
53888: EMPTY
53889: LIST
53890: LIST
53891: PUSH
53892: LD_INT 25
53894: PUSH
53895: LD_INT 3
53897: PUSH
53898: EMPTY
53899: LIST
53900: LIST
53901: PUSH
53902: LD_INT 25
53904: PUSH
53905: LD_INT 4
53907: PUSH
53908: EMPTY
53909: LIST
53910: LIST
53911: PUSH
53912: EMPTY
53913: LIST
53914: LIST
53915: LIST
53916: LIST
53917: PPUSH
53918: CALL_OW 72
53922: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
53923: LD_VAR 0 2
53927: PPUSH
53928: LD_VAR 0 4
53932: PPUSH
53933: CALL 134130 0 2
// exit ;
53937: POP
53938: POP
53939: GO 54061
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
53941: LD_EXP 123
53945: PUSH
53946: LD_VAR 0 2
53950: ARRAY
53951: PUSH
53952: LD_EXP 143
53956: PUSH
53957: LD_VAR 0 2
53961: ARRAY
53962: NOT
53963: AND
53964: PUSH
53965: LD_EXP 122
53969: PUSH
53970: LD_VAR 0 2
53974: ARRAY
53975: AND
53976: IFFALSE 54057
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
53978: LD_ADDR_EXP 143
53982: PUSH
53983: LD_EXP 143
53987: PPUSH
53988: LD_VAR 0 2
53992: PPUSH
53993: LD_INT 1
53995: PPUSH
53996: CALL_OW 1
54000: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
54001: LD_ADDR_VAR 0 4
54005: PUSH
54006: LD_EXP 122
54010: PUSH
54011: LD_VAR 0 2
54015: ARRAY
54016: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
54017: LD_ADDR_EXP 122
54021: PUSH
54022: LD_EXP 122
54026: PPUSH
54027: LD_VAR 0 2
54031: PPUSH
54032: EMPTY
54033: PPUSH
54034: CALL_OW 1
54038: ST_TO_ADDR
// Defend ( i , tmp ) ;
54039: LD_VAR 0 2
54043: PPUSH
54044: LD_VAR 0 4
54048: PPUSH
54049: CALL 134726 0 2
// exit ;
54053: POP
54054: POP
54055: GO 54061
// end ; end ;
54057: GO 53219
54059: POP
54060: POP
// end ;
54061: LD_VAR 0 1
54065: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
54066: LD_INT 0
54068: PPUSH
54069: PPUSH
54070: PPUSH
54071: PPUSH
54072: PPUSH
54073: PPUSH
54074: PPUSH
54075: PPUSH
54076: PPUSH
54077: PPUSH
54078: PPUSH
// if not mc_bases then
54079: LD_EXP 100
54083: NOT
54084: IFFALSE 54088
// exit ;
54086: GO 55175
// for i = 1 to mc_bases do
54088: LD_ADDR_VAR 0 2
54092: PUSH
54093: DOUBLE
54094: LD_INT 1
54096: DEC
54097: ST_TO_ADDR
54098: LD_EXP 100
54102: PUSH
54103: FOR_TO
54104: IFFALSE 55173
// begin tmp := mc_lab [ i ] ;
54106: LD_ADDR_VAR 0 6
54110: PUSH
54111: LD_EXP 133
54115: PUSH
54116: LD_VAR 0 2
54120: ARRAY
54121: ST_TO_ADDR
// if not tmp then
54122: LD_VAR 0 6
54126: NOT
54127: IFFALSE 54131
// continue ;
54129: GO 54103
// idle_lab := 0 ;
54131: LD_ADDR_VAR 0 11
54135: PUSH
54136: LD_INT 0
54138: ST_TO_ADDR
// for j in tmp do
54139: LD_ADDR_VAR 0 3
54143: PUSH
54144: LD_VAR 0 6
54148: PUSH
54149: FOR_IN
54150: IFFALSE 55169
// begin researching := false ;
54152: LD_ADDR_VAR 0 10
54156: PUSH
54157: LD_INT 0
54159: ST_TO_ADDR
// side := GetSide ( j ) ;
54160: LD_ADDR_VAR 0 4
54164: PUSH
54165: LD_VAR 0 3
54169: PPUSH
54170: CALL_OW 255
54174: ST_TO_ADDR
// if not mc_tech [ side ] then
54175: LD_EXP 127
54179: PUSH
54180: LD_VAR 0 4
54184: ARRAY
54185: NOT
54186: IFFALSE 54190
// continue ;
54188: GO 54149
// if BuildingStatus ( j ) = bs_idle then
54190: LD_VAR 0 3
54194: PPUSH
54195: CALL_OW 461
54199: PUSH
54200: LD_INT 2
54202: EQUAL
54203: IFFALSE 54391
// begin if idle_lab and UnitsInside ( j ) < 6 then
54205: LD_VAR 0 11
54209: PUSH
54210: LD_VAR 0 3
54214: PPUSH
54215: CALL_OW 313
54219: PUSH
54220: LD_INT 6
54222: LESS
54223: AND
54224: IFFALSE 54295
// begin tmp2 := UnitsInside ( idle_lab ) ;
54226: LD_ADDR_VAR 0 9
54230: PUSH
54231: LD_VAR 0 11
54235: PPUSH
54236: CALL_OW 313
54240: ST_TO_ADDR
// if tmp2 then
54241: LD_VAR 0 9
54245: IFFALSE 54287
// for x in tmp2 do
54247: LD_ADDR_VAR 0 7
54251: PUSH
54252: LD_VAR 0 9
54256: PUSH
54257: FOR_IN
54258: IFFALSE 54285
// begin ComExitBuilding ( x ) ;
54260: LD_VAR 0 7
54264: PPUSH
54265: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
54269: LD_VAR 0 7
54273: PPUSH
54274: LD_VAR 0 3
54278: PPUSH
54279: CALL_OW 180
// end ;
54283: GO 54257
54285: POP
54286: POP
// idle_lab := 0 ;
54287: LD_ADDR_VAR 0 11
54291: PUSH
54292: LD_INT 0
54294: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
54295: LD_ADDR_VAR 0 5
54299: PUSH
54300: LD_EXP 127
54304: PUSH
54305: LD_VAR 0 4
54309: ARRAY
54310: PUSH
54311: FOR_IN
54312: IFFALSE 54372
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
54314: LD_VAR 0 3
54318: PPUSH
54319: LD_VAR 0 5
54323: PPUSH
54324: CALL_OW 430
54328: PUSH
54329: LD_VAR 0 4
54333: PPUSH
54334: LD_VAR 0 5
54338: PPUSH
54339: CALL 68830 0 2
54343: AND
54344: IFFALSE 54370
// begin researching := true ;
54346: LD_ADDR_VAR 0 10
54350: PUSH
54351: LD_INT 1
54353: ST_TO_ADDR
// ComResearch ( j , t ) ;
54354: LD_VAR 0 3
54358: PPUSH
54359: LD_VAR 0 5
54363: PPUSH
54364: CALL_OW 124
// break ;
54368: GO 54372
// end ;
54370: GO 54311
54372: POP
54373: POP
// if not researching then
54374: LD_VAR 0 10
54378: NOT
54379: IFFALSE 54391
// idle_lab := j ;
54381: LD_ADDR_VAR 0 11
54385: PUSH
54386: LD_VAR 0 3
54390: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
54391: LD_VAR 0 3
54395: PPUSH
54396: CALL_OW 461
54400: PUSH
54401: LD_INT 10
54403: EQUAL
54404: IFFALSE 54992
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
54406: LD_EXP 129
54410: PUSH
54411: LD_VAR 0 2
54415: ARRAY
54416: NOT
54417: PUSH
54418: LD_EXP 130
54422: PUSH
54423: LD_VAR 0 2
54427: ARRAY
54428: NOT
54429: AND
54430: PUSH
54431: LD_EXP 127
54435: PUSH
54436: LD_VAR 0 4
54440: ARRAY
54441: PUSH
54442: LD_INT 1
54444: GREATER
54445: AND
54446: IFFALSE 54577
// begin ComCancel ( j ) ;
54448: LD_VAR 0 3
54452: PPUSH
54453: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
54457: LD_ADDR_EXP 127
54461: PUSH
54462: LD_EXP 127
54466: PPUSH
54467: LD_VAR 0 4
54471: PPUSH
54472: LD_EXP 127
54476: PUSH
54477: LD_VAR 0 4
54481: ARRAY
54482: PPUSH
54483: LD_EXP 127
54487: PUSH
54488: LD_VAR 0 4
54492: ARRAY
54493: PUSH
54494: LD_INT 1
54496: MINUS
54497: PPUSH
54498: LD_EXP 127
54502: PUSH
54503: LD_VAR 0 4
54507: ARRAY
54508: PPUSH
54509: LD_INT 0
54511: PPUSH
54512: CALL 72354 0 4
54516: PPUSH
54517: CALL_OW 1
54521: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
54522: LD_ADDR_EXP 127
54526: PUSH
54527: LD_EXP 127
54531: PPUSH
54532: LD_VAR 0 4
54536: PPUSH
54537: LD_EXP 127
54541: PUSH
54542: LD_VAR 0 4
54546: ARRAY
54547: PPUSH
54548: LD_EXP 127
54552: PUSH
54553: LD_VAR 0 4
54557: ARRAY
54558: PPUSH
54559: LD_INT 1
54561: PPUSH
54562: LD_INT 0
54564: PPUSH
54565: CALL 72354 0 4
54569: PPUSH
54570: CALL_OW 1
54574: ST_TO_ADDR
// continue ;
54575: GO 54149
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
54577: LD_EXP 129
54581: PUSH
54582: LD_VAR 0 2
54586: ARRAY
54587: PUSH
54588: LD_EXP 130
54592: PUSH
54593: LD_VAR 0 2
54597: ARRAY
54598: NOT
54599: AND
54600: IFFALSE 54727
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
54602: LD_ADDR_EXP 130
54606: PUSH
54607: LD_EXP 130
54611: PPUSH
54612: LD_VAR 0 2
54616: PUSH
54617: LD_EXP 130
54621: PUSH
54622: LD_VAR 0 2
54626: ARRAY
54627: PUSH
54628: LD_INT 1
54630: PLUS
54631: PUSH
54632: EMPTY
54633: LIST
54634: LIST
54635: PPUSH
54636: LD_EXP 129
54640: PUSH
54641: LD_VAR 0 2
54645: ARRAY
54646: PUSH
54647: LD_INT 1
54649: ARRAY
54650: PPUSH
54651: CALL 72936 0 3
54655: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
54656: LD_EXP 129
54660: PUSH
54661: LD_VAR 0 2
54665: ARRAY
54666: PUSH
54667: LD_INT 1
54669: ARRAY
54670: PPUSH
54671: LD_INT 112
54673: PPUSH
54674: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
54678: LD_ADDR_VAR 0 9
54682: PUSH
54683: LD_EXP 129
54687: PUSH
54688: LD_VAR 0 2
54692: ARRAY
54693: PPUSH
54694: LD_INT 1
54696: PPUSH
54697: CALL_OW 3
54701: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
54702: LD_ADDR_EXP 129
54706: PUSH
54707: LD_EXP 129
54711: PPUSH
54712: LD_VAR 0 2
54716: PPUSH
54717: LD_VAR 0 9
54721: PPUSH
54722: CALL_OW 1
54726: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
54727: LD_EXP 129
54731: PUSH
54732: LD_VAR 0 2
54736: ARRAY
54737: PUSH
54738: LD_EXP 130
54742: PUSH
54743: LD_VAR 0 2
54747: ARRAY
54748: AND
54749: PUSH
54750: LD_EXP 130
54754: PUSH
54755: LD_VAR 0 2
54759: ARRAY
54760: PUSH
54761: LD_INT 1
54763: ARRAY
54764: PPUSH
54765: CALL_OW 310
54769: NOT
54770: AND
54771: PUSH
54772: LD_VAR 0 3
54776: PPUSH
54777: CALL_OW 313
54781: PUSH
54782: LD_INT 6
54784: EQUAL
54785: AND
54786: IFFALSE 54842
// begin tmp2 := UnitsInside ( j ) ;
54788: LD_ADDR_VAR 0 9
54792: PUSH
54793: LD_VAR 0 3
54797: PPUSH
54798: CALL_OW 313
54802: ST_TO_ADDR
// if tmp2 = 6 then
54803: LD_VAR 0 9
54807: PUSH
54808: LD_INT 6
54810: EQUAL
54811: IFFALSE 54842
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
54813: LD_VAR 0 9
54817: PUSH
54818: LD_INT 1
54820: ARRAY
54821: PPUSH
54822: LD_INT 112
54824: PPUSH
54825: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
54829: LD_VAR 0 9
54833: PUSH
54834: LD_INT 1
54836: ARRAY
54837: PPUSH
54838: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
54842: LD_EXP 130
54846: PUSH
54847: LD_VAR 0 2
54851: ARRAY
54852: PUSH
54853: LD_EXP 130
54857: PUSH
54858: LD_VAR 0 2
54862: ARRAY
54863: PUSH
54864: LD_INT 1
54866: ARRAY
54867: PPUSH
54868: CALL_OW 314
54872: NOT
54873: AND
54874: PUSH
54875: LD_EXP 130
54879: PUSH
54880: LD_VAR 0 2
54884: ARRAY
54885: PUSH
54886: LD_INT 1
54888: ARRAY
54889: PPUSH
54890: CALL_OW 310
54894: NOT
54895: AND
54896: IFFALSE 54922
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
54898: LD_EXP 130
54902: PUSH
54903: LD_VAR 0 2
54907: ARRAY
54908: PUSH
54909: LD_INT 1
54911: ARRAY
54912: PPUSH
54913: LD_VAR 0 3
54917: PPUSH
54918: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
54922: LD_EXP 130
54926: PUSH
54927: LD_VAR 0 2
54931: ARRAY
54932: PUSH
54933: LD_INT 1
54935: ARRAY
54936: PPUSH
54937: CALL_OW 310
54941: PUSH
54942: LD_EXP 130
54946: PUSH
54947: LD_VAR 0 2
54951: ARRAY
54952: PUSH
54953: LD_INT 1
54955: ARRAY
54956: PPUSH
54957: CALL_OW 310
54961: PPUSH
54962: CALL_OW 461
54966: PUSH
54967: LD_INT 3
54969: NONEQUAL
54970: AND
54971: IFFALSE 54992
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
54973: LD_EXP 130
54977: PUSH
54978: LD_VAR 0 2
54982: ARRAY
54983: PUSH
54984: LD_INT 1
54986: ARRAY
54987: PPUSH
54988: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
54992: LD_VAR 0 3
54996: PPUSH
54997: CALL_OW 461
55001: PUSH
55002: LD_INT 6
55004: EQUAL
55005: PUSH
55006: LD_VAR 0 6
55010: PUSH
55011: LD_INT 1
55013: GREATER
55014: AND
55015: IFFALSE 55167
// begin sci := [ ] ;
55017: LD_ADDR_VAR 0 8
55021: PUSH
55022: EMPTY
55023: ST_TO_ADDR
// for x in ( tmp diff j ) do
55024: LD_ADDR_VAR 0 7
55028: PUSH
55029: LD_VAR 0 6
55033: PUSH
55034: LD_VAR 0 3
55038: DIFF
55039: PUSH
55040: FOR_IN
55041: IFFALSE 55093
// begin if sci = 6 then
55043: LD_VAR 0 8
55047: PUSH
55048: LD_INT 6
55050: EQUAL
55051: IFFALSE 55055
// break ;
55053: GO 55093
// if BuildingStatus ( x ) = bs_idle then
55055: LD_VAR 0 7
55059: PPUSH
55060: CALL_OW 461
55064: PUSH
55065: LD_INT 2
55067: EQUAL
55068: IFFALSE 55091
// sci := sci ^ UnitsInside ( x ) ;
55070: LD_ADDR_VAR 0 8
55074: PUSH
55075: LD_VAR 0 8
55079: PUSH
55080: LD_VAR 0 7
55084: PPUSH
55085: CALL_OW 313
55089: ADD
55090: ST_TO_ADDR
// end ;
55091: GO 55040
55093: POP
55094: POP
// if not sci then
55095: LD_VAR 0 8
55099: NOT
55100: IFFALSE 55104
// continue ;
55102: GO 54149
// for x in sci do
55104: LD_ADDR_VAR 0 7
55108: PUSH
55109: LD_VAR 0 8
55113: PUSH
55114: FOR_IN
55115: IFFALSE 55165
// if IsInUnit ( x ) and not HasTask ( x ) then
55117: LD_VAR 0 7
55121: PPUSH
55122: CALL_OW 310
55126: PUSH
55127: LD_VAR 0 7
55131: PPUSH
55132: CALL_OW 314
55136: NOT
55137: AND
55138: IFFALSE 55163
// begin ComExitBuilding ( x ) ;
55140: LD_VAR 0 7
55144: PPUSH
55145: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
55149: LD_VAR 0 7
55153: PPUSH
55154: LD_VAR 0 3
55158: PPUSH
55159: CALL_OW 180
// end ;
55163: GO 55114
55165: POP
55166: POP
// end ; end ;
55167: GO 54149
55169: POP
55170: POP
// end ;
55171: GO 54103
55173: POP
55174: POP
// end ;
55175: LD_VAR 0 1
55179: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
55180: LD_INT 0
55182: PPUSH
55183: PPUSH
// if not mc_bases then
55184: LD_EXP 100
55188: NOT
55189: IFFALSE 55193
// exit ;
55191: GO 55274
// for i = 1 to mc_bases do
55193: LD_ADDR_VAR 0 2
55197: PUSH
55198: DOUBLE
55199: LD_INT 1
55201: DEC
55202: ST_TO_ADDR
55203: LD_EXP 100
55207: PUSH
55208: FOR_TO
55209: IFFALSE 55272
// if mc_mines [ i ] and mc_miners [ i ] then
55211: LD_EXP 113
55215: PUSH
55216: LD_VAR 0 2
55220: ARRAY
55221: PUSH
55222: LD_EXP 114
55226: PUSH
55227: LD_VAR 0 2
55231: ARRAY
55232: AND
55233: IFFALSE 55270
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
55235: LD_EXP 114
55239: PUSH
55240: LD_VAR 0 2
55244: ARRAY
55245: PUSH
55246: LD_INT 1
55248: ARRAY
55249: PPUSH
55250: CALL_OW 255
55254: PPUSH
55255: LD_EXP 113
55259: PUSH
55260: LD_VAR 0 2
55264: ARRAY
55265: PPUSH
55266: CALL 69913 0 2
55270: GO 55208
55272: POP
55273: POP
// end ;
55274: LD_VAR 0 1
55278: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
55279: LD_INT 0
55281: PPUSH
55282: PPUSH
55283: PPUSH
55284: PPUSH
55285: PPUSH
55286: PPUSH
55287: PPUSH
55288: PPUSH
// if not mc_bases or not mc_parking then
55289: LD_EXP 100
55293: NOT
55294: PUSH
55295: LD_EXP 124
55299: NOT
55300: OR
55301: IFFALSE 55305
// exit ;
55303: GO 56043
// for i = 1 to mc_bases do
55305: LD_ADDR_VAR 0 2
55309: PUSH
55310: DOUBLE
55311: LD_INT 1
55313: DEC
55314: ST_TO_ADDR
55315: LD_EXP 100
55319: PUSH
55320: FOR_TO
55321: IFFALSE 56041
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
55323: LD_EXP 100
55327: PUSH
55328: LD_VAR 0 2
55332: ARRAY
55333: NOT
55334: PUSH
55335: LD_EXP 124
55339: PUSH
55340: LD_VAR 0 2
55344: ARRAY
55345: NOT
55346: OR
55347: IFFALSE 55351
// continue ;
55349: GO 55320
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
55351: LD_ADDR_VAR 0 5
55355: PUSH
55356: LD_EXP 100
55360: PUSH
55361: LD_VAR 0 2
55365: ARRAY
55366: PUSH
55367: LD_INT 1
55369: ARRAY
55370: PPUSH
55371: CALL_OW 255
55375: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
55376: LD_ADDR_VAR 0 6
55380: PUSH
55381: LD_EXP 100
55385: PUSH
55386: LD_VAR 0 2
55390: ARRAY
55391: PPUSH
55392: LD_INT 30
55394: PUSH
55395: LD_INT 3
55397: PUSH
55398: EMPTY
55399: LIST
55400: LIST
55401: PPUSH
55402: CALL_OW 72
55406: ST_TO_ADDR
// if not fac then
55407: LD_VAR 0 6
55411: NOT
55412: IFFALSE 55463
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
55414: LD_ADDR_VAR 0 6
55418: PUSH
55419: LD_EXP 100
55423: PUSH
55424: LD_VAR 0 2
55428: ARRAY
55429: PPUSH
55430: LD_INT 2
55432: PUSH
55433: LD_INT 30
55435: PUSH
55436: LD_INT 0
55438: PUSH
55439: EMPTY
55440: LIST
55441: LIST
55442: PUSH
55443: LD_INT 30
55445: PUSH
55446: LD_INT 1
55448: PUSH
55449: EMPTY
55450: LIST
55451: LIST
55452: PUSH
55453: EMPTY
55454: LIST
55455: LIST
55456: LIST
55457: PPUSH
55458: CALL_OW 72
55462: ST_TO_ADDR
// if not fac then
55463: LD_VAR 0 6
55467: NOT
55468: IFFALSE 55472
// continue ;
55470: GO 55320
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
55472: LD_ADDR_VAR 0 7
55476: PUSH
55477: LD_EXP 124
55481: PUSH
55482: LD_VAR 0 2
55486: ARRAY
55487: PPUSH
55488: LD_INT 22
55490: PUSH
55491: LD_VAR 0 5
55495: PUSH
55496: EMPTY
55497: LIST
55498: LIST
55499: PUSH
55500: LD_INT 21
55502: PUSH
55503: LD_INT 2
55505: PUSH
55506: EMPTY
55507: LIST
55508: LIST
55509: PUSH
55510: LD_INT 3
55512: PUSH
55513: LD_INT 60
55515: PUSH
55516: EMPTY
55517: LIST
55518: PUSH
55519: EMPTY
55520: LIST
55521: LIST
55522: PUSH
55523: LD_INT 3
55525: PUSH
55526: LD_INT 24
55528: PUSH
55529: LD_INT 1000
55531: PUSH
55532: EMPTY
55533: LIST
55534: LIST
55535: PUSH
55536: EMPTY
55537: LIST
55538: LIST
55539: PUSH
55540: EMPTY
55541: LIST
55542: LIST
55543: LIST
55544: LIST
55545: PPUSH
55546: CALL_OW 70
55550: ST_TO_ADDR
// for j in fac do
55551: LD_ADDR_VAR 0 3
55555: PUSH
55556: LD_VAR 0 6
55560: PUSH
55561: FOR_IN
55562: IFFALSE 55657
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
55564: LD_ADDR_VAR 0 7
55568: PUSH
55569: LD_VAR 0 7
55573: PUSH
55574: LD_INT 22
55576: PUSH
55577: LD_VAR 0 5
55581: PUSH
55582: EMPTY
55583: LIST
55584: LIST
55585: PUSH
55586: LD_INT 91
55588: PUSH
55589: LD_VAR 0 3
55593: PUSH
55594: LD_INT 15
55596: PUSH
55597: EMPTY
55598: LIST
55599: LIST
55600: LIST
55601: PUSH
55602: LD_INT 21
55604: PUSH
55605: LD_INT 2
55607: PUSH
55608: EMPTY
55609: LIST
55610: LIST
55611: PUSH
55612: LD_INT 3
55614: PUSH
55615: LD_INT 60
55617: PUSH
55618: EMPTY
55619: LIST
55620: PUSH
55621: EMPTY
55622: LIST
55623: LIST
55624: PUSH
55625: LD_INT 3
55627: PUSH
55628: LD_INT 24
55630: PUSH
55631: LD_INT 1000
55633: PUSH
55634: EMPTY
55635: LIST
55636: LIST
55637: PUSH
55638: EMPTY
55639: LIST
55640: LIST
55641: PUSH
55642: EMPTY
55643: LIST
55644: LIST
55645: LIST
55646: LIST
55647: LIST
55648: PPUSH
55649: CALL_OW 69
55653: UNION
55654: ST_TO_ADDR
55655: GO 55561
55657: POP
55658: POP
// if not vehs then
55659: LD_VAR 0 7
55663: NOT
55664: IFFALSE 55690
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
55666: LD_ADDR_EXP 112
55670: PUSH
55671: LD_EXP 112
55675: PPUSH
55676: LD_VAR 0 2
55680: PPUSH
55681: EMPTY
55682: PPUSH
55683: CALL_OW 1
55687: ST_TO_ADDR
// continue ;
55688: GO 55320
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
55690: LD_ADDR_VAR 0 8
55694: PUSH
55695: LD_EXP 100
55699: PUSH
55700: LD_VAR 0 2
55704: ARRAY
55705: PPUSH
55706: LD_INT 30
55708: PUSH
55709: LD_INT 3
55711: PUSH
55712: EMPTY
55713: LIST
55714: LIST
55715: PPUSH
55716: CALL_OW 72
55720: ST_TO_ADDR
// if tmp then
55721: LD_VAR 0 8
55725: IFFALSE 55828
// begin for j in tmp do
55727: LD_ADDR_VAR 0 3
55731: PUSH
55732: LD_VAR 0 8
55736: PUSH
55737: FOR_IN
55738: IFFALSE 55826
// for k in UnitsInside ( j ) do
55740: LD_ADDR_VAR 0 4
55744: PUSH
55745: LD_VAR 0 3
55749: PPUSH
55750: CALL_OW 313
55754: PUSH
55755: FOR_IN
55756: IFFALSE 55822
// if k then
55758: LD_VAR 0 4
55762: IFFALSE 55820
// if not k in mc_repair_vehicle [ i ] then
55764: LD_VAR 0 4
55768: PUSH
55769: LD_EXP 112
55773: PUSH
55774: LD_VAR 0 2
55778: ARRAY
55779: IN
55780: NOT
55781: IFFALSE 55820
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
55783: LD_ADDR_EXP 112
55787: PUSH
55788: LD_EXP 112
55792: PPUSH
55793: LD_VAR 0 2
55797: PPUSH
55798: LD_EXP 112
55802: PUSH
55803: LD_VAR 0 2
55807: ARRAY
55808: PUSH
55809: LD_VAR 0 4
55813: UNION
55814: PPUSH
55815: CALL_OW 1
55819: ST_TO_ADDR
55820: GO 55755
55822: POP
55823: POP
55824: GO 55737
55826: POP
55827: POP
// end ; if not mc_repair_vehicle [ i ] then
55828: LD_EXP 112
55832: PUSH
55833: LD_VAR 0 2
55837: ARRAY
55838: NOT
55839: IFFALSE 55843
// continue ;
55841: GO 55320
// for j in mc_repair_vehicle [ i ] do
55843: LD_ADDR_VAR 0 3
55847: PUSH
55848: LD_EXP 112
55852: PUSH
55853: LD_VAR 0 2
55857: ARRAY
55858: PUSH
55859: FOR_IN
55860: IFFALSE 56037
// begin if GetClass ( j ) <> 3 then
55862: LD_VAR 0 3
55866: PPUSH
55867: CALL_OW 257
55871: PUSH
55872: LD_INT 3
55874: NONEQUAL
55875: IFFALSE 55916
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
55877: LD_ADDR_EXP 112
55881: PUSH
55882: LD_EXP 112
55886: PPUSH
55887: LD_VAR 0 2
55891: PPUSH
55892: LD_EXP 112
55896: PUSH
55897: LD_VAR 0 2
55901: ARRAY
55902: PUSH
55903: LD_VAR 0 3
55907: DIFF
55908: PPUSH
55909: CALL_OW 1
55913: ST_TO_ADDR
// continue ;
55914: GO 55859
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
55916: LD_VAR 0 3
55920: PPUSH
55921: CALL_OW 311
55925: NOT
55926: PUSH
55927: LD_VAR 0 3
55931: PUSH
55932: LD_EXP 103
55936: PUSH
55937: LD_VAR 0 2
55941: ARRAY
55942: PUSH
55943: LD_INT 1
55945: ARRAY
55946: IN
55947: NOT
55948: AND
55949: PUSH
55950: LD_VAR 0 3
55954: PUSH
55955: LD_EXP 103
55959: PUSH
55960: LD_VAR 0 2
55964: ARRAY
55965: PUSH
55966: LD_INT 2
55968: ARRAY
55969: IN
55970: NOT
55971: AND
55972: IFFALSE 56035
// begin if IsInUnit ( j ) then
55974: LD_VAR 0 3
55978: PPUSH
55979: CALL_OW 310
55983: IFFALSE 55996
// ComExitBuilding ( j ) else
55985: LD_VAR 0 3
55989: PPUSH
55990: CALL_OW 122
55994: GO 56035
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
55996: LD_VAR 0 3
56000: PPUSH
56001: LD_VAR 0 7
56005: PUSH
56006: LD_INT 1
56008: ARRAY
56009: PPUSH
56010: CALL 107331 0 2
56014: NOT
56015: IFFALSE 56035
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
56017: LD_VAR 0 3
56021: PPUSH
56022: LD_VAR 0 7
56026: PUSH
56027: LD_INT 1
56029: ARRAY
56030: PPUSH
56031: CALL_OW 129
// end ; end ;
56035: GO 55859
56037: POP
56038: POP
// end ;
56039: GO 55320
56041: POP
56042: POP
// end ;
56043: LD_VAR 0 1
56047: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
56048: LD_INT 0
56050: PPUSH
56051: PPUSH
56052: PPUSH
56053: PPUSH
56054: PPUSH
56055: PPUSH
56056: PPUSH
56057: PPUSH
56058: PPUSH
56059: PPUSH
56060: PPUSH
// if not mc_bases then
56061: LD_EXP 100
56065: NOT
56066: IFFALSE 56070
// exit ;
56068: GO 56872
// for i = 1 to mc_bases do
56070: LD_ADDR_VAR 0 2
56074: PUSH
56075: DOUBLE
56076: LD_INT 1
56078: DEC
56079: ST_TO_ADDR
56080: LD_EXP 100
56084: PUSH
56085: FOR_TO
56086: IFFALSE 56870
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
56088: LD_EXP 128
56092: PUSH
56093: LD_VAR 0 2
56097: ARRAY
56098: NOT
56099: PUSH
56100: LD_EXP 103
56104: PUSH
56105: LD_VAR 0 2
56109: ARRAY
56110: PUSH
56111: LD_INT 1
56113: ARRAY
56114: OR
56115: PUSH
56116: LD_EXP 103
56120: PUSH
56121: LD_VAR 0 2
56125: ARRAY
56126: PUSH
56127: LD_INT 2
56129: ARRAY
56130: OR
56131: PUSH
56132: LD_EXP 126
56136: PUSH
56137: LD_VAR 0 2
56141: ARRAY
56142: PPUSH
56143: LD_INT 1
56145: PPUSH
56146: CALL_OW 325
56150: NOT
56151: OR
56152: PUSH
56153: LD_EXP 123
56157: PUSH
56158: LD_VAR 0 2
56162: ARRAY
56163: OR
56164: IFFALSE 56168
// continue ;
56166: GO 56085
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
56168: LD_ADDR_VAR 0 8
56172: PUSH
56173: LD_EXP 100
56177: PUSH
56178: LD_VAR 0 2
56182: ARRAY
56183: PPUSH
56184: LD_INT 25
56186: PUSH
56187: LD_INT 4
56189: PUSH
56190: EMPTY
56191: LIST
56192: LIST
56193: PUSH
56194: LD_INT 50
56196: PUSH
56197: EMPTY
56198: LIST
56199: PUSH
56200: LD_INT 3
56202: PUSH
56203: LD_INT 60
56205: PUSH
56206: EMPTY
56207: LIST
56208: PUSH
56209: EMPTY
56210: LIST
56211: LIST
56212: PUSH
56213: EMPTY
56214: LIST
56215: LIST
56216: LIST
56217: PPUSH
56218: CALL_OW 72
56222: PUSH
56223: LD_EXP 104
56227: PUSH
56228: LD_VAR 0 2
56232: ARRAY
56233: DIFF
56234: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56235: LD_ADDR_VAR 0 9
56239: PUSH
56240: LD_EXP 100
56244: PUSH
56245: LD_VAR 0 2
56249: ARRAY
56250: PPUSH
56251: LD_INT 2
56253: PUSH
56254: LD_INT 30
56256: PUSH
56257: LD_INT 0
56259: PUSH
56260: EMPTY
56261: LIST
56262: LIST
56263: PUSH
56264: LD_INT 30
56266: PUSH
56267: LD_INT 1
56269: PUSH
56270: EMPTY
56271: LIST
56272: LIST
56273: PUSH
56274: EMPTY
56275: LIST
56276: LIST
56277: LIST
56278: PPUSH
56279: CALL_OW 72
56283: ST_TO_ADDR
// if not tmp or not dep then
56284: LD_VAR 0 8
56288: NOT
56289: PUSH
56290: LD_VAR 0 9
56294: NOT
56295: OR
56296: IFFALSE 56300
// continue ;
56298: GO 56085
// side := GetSide ( tmp [ 1 ] ) ;
56300: LD_ADDR_VAR 0 11
56304: PUSH
56305: LD_VAR 0 8
56309: PUSH
56310: LD_INT 1
56312: ARRAY
56313: PPUSH
56314: CALL_OW 255
56318: ST_TO_ADDR
// dep := dep [ 1 ] ;
56319: LD_ADDR_VAR 0 9
56323: PUSH
56324: LD_VAR 0 9
56328: PUSH
56329: LD_INT 1
56331: ARRAY
56332: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
56333: LD_ADDR_VAR 0 7
56337: PUSH
56338: LD_EXP 128
56342: PUSH
56343: LD_VAR 0 2
56347: ARRAY
56348: PPUSH
56349: LD_INT 22
56351: PUSH
56352: LD_INT 0
56354: PUSH
56355: EMPTY
56356: LIST
56357: LIST
56358: PUSH
56359: LD_INT 25
56361: PUSH
56362: LD_INT 12
56364: PUSH
56365: EMPTY
56366: LIST
56367: LIST
56368: PUSH
56369: EMPTY
56370: LIST
56371: LIST
56372: PPUSH
56373: CALL_OW 70
56377: PUSH
56378: LD_INT 22
56380: PUSH
56381: LD_INT 0
56383: PUSH
56384: EMPTY
56385: LIST
56386: LIST
56387: PUSH
56388: LD_INT 25
56390: PUSH
56391: LD_INT 12
56393: PUSH
56394: EMPTY
56395: LIST
56396: LIST
56397: PUSH
56398: LD_INT 91
56400: PUSH
56401: LD_VAR 0 9
56405: PUSH
56406: LD_INT 20
56408: PUSH
56409: EMPTY
56410: LIST
56411: LIST
56412: LIST
56413: PUSH
56414: EMPTY
56415: LIST
56416: LIST
56417: LIST
56418: PPUSH
56419: CALL_OW 69
56423: UNION
56424: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
56425: LD_ADDR_VAR 0 10
56429: PUSH
56430: LD_EXP 128
56434: PUSH
56435: LD_VAR 0 2
56439: ARRAY
56440: PPUSH
56441: LD_INT 81
56443: PUSH
56444: LD_VAR 0 11
56448: PUSH
56449: EMPTY
56450: LIST
56451: LIST
56452: PPUSH
56453: CALL_OW 70
56457: ST_TO_ADDR
// if not apes or danger_at_area then
56458: LD_VAR 0 7
56462: NOT
56463: PUSH
56464: LD_VAR 0 10
56468: OR
56469: IFFALSE 56519
// begin if mc_taming [ i ] then
56471: LD_EXP 131
56475: PUSH
56476: LD_VAR 0 2
56480: ARRAY
56481: IFFALSE 56517
// begin MC_Reset ( i , 121 ) ;
56483: LD_VAR 0 2
56487: PPUSH
56488: LD_INT 121
56490: PPUSH
56491: CALL 41449 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
56495: LD_ADDR_EXP 131
56499: PUSH
56500: LD_EXP 131
56504: PPUSH
56505: LD_VAR 0 2
56509: PPUSH
56510: EMPTY
56511: PPUSH
56512: CALL_OW 1
56516: ST_TO_ADDR
// end ; continue ;
56517: GO 56085
// end ; for j in tmp do
56519: LD_ADDR_VAR 0 3
56523: PUSH
56524: LD_VAR 0 8
56528: PUSH
56529: FOR_IN
56530: IFFALSE 56866
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
56532: LD_VAR 0 3
56536: PUSH
56537: LD_EXP 131
56541: PUSH
56542: LD_VAR 0 2
56546: ARRAY
56547: IN
56548: NOT
56549: PUSH
56550: LD_EXP 131
56554: PUSH
56555: LD_VAR 0 2
56559: ARRAY
56560: PUSH
56561: LD_INT 3
56563: LESS
56564: AND
56565: IFFALSE 56623
// begin SetTag ( j , 121 ) ;
56567: LD_VAR 0 3
56571: PPUSH
56572: LD_INT 121
56574: PPUSH
56575: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
56579: LD_ADDR_EXP 131
56583: PUSH
56584: LD_EXP 131
56588: PPUSH
56589: LD_VAR 0 2
56593: PUSH
56594: LD_EXP 131
56598: PUSH
56599: LD_VAR 0 2
56603: ARRAY
56604: PUSH
56605: LD_INT 1
56607: PLUS
56608: PUSH
56609: EMPTY
56610: LIST
56611: LIST
56612: PPUSH
56613: LD_VAR 0 3
56617: PPUSH
56618: CALL 72936 0 3
56622: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
56623: LD_VAR 0 3
56627: PUSH
56628: LD_EXP 131
56632: PUSH
56633: LD_VAR 0 2
56637: ARRAY
56638: IN
56639: IFFALSE 56864
// begin if GetClass ( j ) <> 4 then
56641: LD_VAR 0 3
56645: PPUSH
56646: CALL_OW 257
56650: PUSH
56651: LD_INT 4
56653: NONEQUAL
56654: IFFALSE 56707
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
56656: LD_ADDR_EXP 131
56660: PUSH
56661: LD_EXP 131
56665: PPUSH
56666: LD_VAR 0 2
56670: PPUSH
56671: LD_EXP 131
56675: PUSH
56676: LD_VAR 0 2
56680: ARRAY
56681: PUSH
56682: LD_VAR 0 3
56686: DIFF
56687: PPUSH
56688: CALL_OW 1
56692: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56693: LD_VAR 0 3
56697: PPUSH
56698: LD_INT 0
56700: PPUSH
56701: CALL_OW 109
// continue ;
56705: GO 56529
// end ; if IsInUnit ( j ) then
56707: LD_VAR 0 3
56711: PPUSH
56712: CALL_OW 310
56716: IFFALSE 56727
// ComExitBuilding ( j ) ;
56718: LD_VAR 0 3
56722: PPUSH
56723: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
56727: LD_ADDR_VAR 0 6
56731: PUSH
56732: LD_VAR 0 7
56736: PPUSH
56737: LD_VAR 0 3
56741: PPUSH
56742: CALL_OW 74
56746: ST_TO_ADDR
// if not ape then
56747: LD_VAR 0 6
56751: NOT
56752: IFFALSE 56756
// break ;
56754: GO 56866
// x := GetX ( ape ) ;
56756: LD_ADDR_VAR 0 4
56760: PUSH
56761: LD_VAR 0 6
56765: PPUSH
56766: CALL_OW 250
56770: ST_TO_ADDR
// y := GetY ( ape ) ;
56771: LD_ADDR_VAR 0 5
56775: PUSH
56776: LD_VAR 0 6
56780: PPUSH
56781: CALL_OW 251
56785: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
56786: LD_VAR 0 4
56790: PPUSH
56791: LD_VAR 0 5
56795: PPUSH
56796: CALL_OW 488
56800: NOT
56801: PUSH
56802: LD_VAR 0 11
56806: PPUSH
56807: LD_VAR 0 4
56811: PPUSH
56812: LD_VAR 0 5
56816: PPUSH
56817: LD_INT 20
56819: PPUSH
56820: CALL 73832 0 4
56824: PUSH
56825: LD_INT 4
56827: ARRAY
56828: OR
56829: IFFALSE 56833
// break ;
56831: GO 56866
// if not HasTask ( j ) then
56833: LD_VAR 0 3
56837: PPUSH
56838: CALL_OW 314
56842: NOT
56843: IFFALSE 56864
// ComTameXY ( j , x , y ) ;
56845: LD_VAR 0 3
56849: PPUSH
56850: LD_VAR 0 4
56854: PPUSH
56855: LD_VAR 0 5
56859: PPUSH
56860: CALL_OW 131
// end ; end ;
56864: GO 56529
56866: POP
56867: POP
// end ;
56868: GO 56085
56870: POP
56871: POP
// end ;
56872: LD_VAR 0 1
56876: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
56877: LD_INT 0
56879: PPUSH
56880: PPUSH
56881: PPUSH
56882: PPUSH
56883: PPUSH
56884: PPUSH
56885: PPUSH
56886: PPUSH
// if not mc_bases then
56887: LD_EXP 100
56891: NOT
56892: IFFALSE 56896
// exit ;
56894: GO 57522
// for i = 1 to mc_bases do
56896: LD_ADDR_VAR 0 2
56900: PUSH
56901: DOUBLE
56902: LD_INT 1
56904: DEC
56905: ST_TO_ADDR
56906: LD_EXP 100
56910: PUSH
56911: FOR_TO
56912: IFFALSE 57520
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
56914: LD_EXP 129
56918: PUSH
56919: LD_VAR 0 2
56923: ARRAY
56924: NOT
56925: PUSH
56926: LD_EXP 129
56930: PUSH
56931: LD_VAR 0 2
56935: ARRAY
56936: PPUSH
56937: LD_INT 25
56939: PUSH
56940: LD_INT 12
56942: PUSH
56943: EMPTY
56944: LIST
56945: LIST
56946: PPUSH
56947: CALL_OW 72
56951: NOT
56952: OR
56953: IFFALSE 56957
// continue ;
56955: GO 56911
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
56957: LD_ADDR_VAR 0 5
56961: PUSH
56962: LD_EXP 129
56966: PUSH
56967: LD_VAR 0 2
56971: ARRAY
56972: PUSH
56973: LD_INT 1
56975: ARRAY
56976: PPUSH
56977: CALL_OW 255
56981: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
56982: LD_VAR 0 5
56986: PPUSH
56987: LD_INT 2
56989: PPUSH
56990: CALL_OW 325
56994: IFFALSE 57247
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
56996: LD_ADDR_VAR 0 4
57000: PUSH
57001: LD_EXP 129
57005: PUSH
57006: LD_VAR 0 2
57010: ARRAY
57011: PPUSH
57012: LD_INT 25
57014: PUSH
57015: LD_INT 16
57017: PUSH
57018: EMPTY
57019: LIST
57020: LIST
57021: PPUSH
57022: CALL_OW 72
57026: ST_TO_ADDR
// if tmp < 6 then
57027: LD_VAR 0 4
57031: PUSH
57032: LD_INT 6
57034: LESS
57035: IFFALSE 57247
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57037: LD_ADDR_VAR 0 6
57041: PUSH
57042: LD_EXP 100
57046: PUSH
57047: LD_VAR 0 2
57051: ARRAY
57052: PPUSH
57053: LD_INT 2
57055: PUSH
57056: LD_INT 30
57058: PUSH
57059: LD_INT 0
57061: PUSH
57062: EMPTY
57063: LIST
57064: LIST
57065: PUSH
57066: LD_INT 30
57068: PUSH
57069: LD_INT 1
57071: PUSH
57072: EMPTY
57073: LIST
57074: LIST
57075: PUSH
57076: EMPTY
57077: LIST
57078: LIST
57079: LIST
57080: PPUSH
57081: CALL_OW 72
57085: ST_TO_ADDR
// if depot then
57086: LD_VAR 0 6
57090: IFFALSE 57247
// begin selected := 0 ;
57092: LD_ADDR_VAR 0 7
57096: PUSH
57097: LD_INT 0
57099: ST_TO_ADDR
// for j in depot do
57100: LD_ADDR_VAR 0 3
57104: PUSH
57105: LD_VAR 0 6
57109: PUSH
57110: FOR_IN
57111: IFFALSE 57142
// begin if UnitsInside ( j ) < 6 then
57113: LD_VAR 0 3
57117: PPUSH
57118: CALL_OW 313
57122: PUSH
57123: LD_INT 6
57125: LESS
57126: IFFALSE 57140
// begin selected := j ;
57128: LD_ADDR_VAR 0 7
57132: PUSH
57133: LD_VAR 0 3
57137: ST_TO_ADDR
// break ;
57138: GO 57142
// end ; end ;
57140: GO 57110
57142: POP
57143: POP
// if selected then
57144: LD_VAR 0 7
57148: IFFALSE 57247
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
57150: LD_ADDR_VAR 0 3
57154: PUSH
57155: LD_EXP 129
57159: PUSH
57160: LD_VAR 0 2
57164: ARRAY
57165: PPUSH
57166: LD_INT 25
57168: PUSH
57169: LD_INT 12
57171: PUSH
57172: EMPTY
57173: LIST
57174: LIST
57175: PPUSH
57176: CALL_OW 72
57180: PUSH
57181: FOR_IN
57182: IFFALSE 57245
// if not HasTask ( j ) then
57184: LD_VAR 0 3
57188: PPUSH
57189: CALL_OW 314
57193: NOT
57194: IFFALSE 57243
// begin if not IsInUnit ( j ) then
57196: LD_VAR 0 3
57200: PPUSH
57201: CALL_OW 310
57205: NOT
57206: IFFALSE 57222
// ComEnterUnit ( j , selected ) ;
57208: LD_VAR 0 3
57212: PPUSH
57213: LD_VAR 0 7
57217: PPUSH
57218: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
57222: LD_VAR 0 3
57226: PPUSH
57227: LD_INT 16
57229: PPUSH
57230: CALL_OW 183
// AddComExitBuilding ( j ) ;
57234: LD_VAR 0 3
57238: PPUSH
57239: CALL_OW 182
// end ;
57243: GO 57181
57245: POP
57246: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
57247: LD_VAR 0 5
57251: PPUSH
57252: LD_INT 11
57254: PPUSH
57255: CALL_OW 325
57259: IFFALSE 57518
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
57261: LD_ADDR_VAR 0 4
57265: PUSH
57266: LD_EXP 129
57270: PUSH
57271: LD_VAR 0 2
57275: ARRAY
57276: PPUSH
57277: LD_INT 25
57279: PUSH
57280: LD_INT 16
57282: PUSH
57283: EMPTY
57284: LIST
57285: LIST
57286: PPUSH
57287: CALL_OW 72
57291: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
57292: LD_VAR 0 4
57296: PUSH
57297: LD_INT 6
57299: GREATEREQUAL
57300: PUSH
57301: LD_VAR 0 5
57305: PPUSH
57306: LD_INT 2
57308: PPUSH
57309: CALL_OW 325
57313: NOT
57314: OR
57315: IFFALSE 57518
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
57317: LD_ADDR_VAR 0 8
57321: PUSH
57322: LD_EXP 100
57326: PUSH
57327: LD_VAR 0 2
57331: ARRAY
57332: PPUSH
57333: LD_INT 2
57335: PUSH
57336: LD_INT 30
57338: PUSH
57339: LD_INT 4
57341: PUSH
57342: EMPTY
57343: LIST
57344: LIST
57345: PUSH
57346: LD_INT 30
57348: PUSH
57349: LD_INT 5
57351: PUSH
57352: EMPTY
57353: LIST
57354: LIST
57355: PUSH
57356: EMPTY
57357: LIST
57358: LIST
57359: LIST
57360: PPUSH
57361: CALL_OW 72
57365: ST_TO_ADDR
// if barracks then
57366: LD_VAR 0 8
57370: IFFALSE 57518
// begin selected := 0 ;
57372: LD_ADDR_VAR 0 7
57376: PUSH
57377: LD_INT 0
57379: ST_TO_ADDR
// for j in barracks do
57380: LD_ADDR_VAR 0 3
57384: PUSH
57385: LD_VAR 0 8
57389: PUSH
57390: FOR_IN
57391: IFFALSE 57422
// begin if UnitsInside ( j ) < 6 then
57393: LD_VAR 0 3
57397: PPUSH
57398: CALL_OW 313
57402: PUSH
57403: LD_INT 6
57405: LESS
57406: IFFALSE 57420
// begin selected := j ;
57408: LD_ADDR_VAR 0 7
57412: PUSH
57413: LD_VAR 0 3
57417: ST_TO_ADDR
// break ;
57418: GO 57422
// end ; end ;
57420: GO 57390
57422: POP
57423: POP
// if selected then
57424: LD_VAR 0 7
57428: IFFALSE 57518
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
57430: LD_ADDR_VAR 0 3
57434: PUSH
57435: LD_EXP 129
57439: PUSH
57440: LD_VAR 0 2
57444: ARRAY
57445: PPUSH
57446: LD_INT 25
57448: PUSH
57449: LD_INT 12
57451: PUSH
57452: EMPTY
57453: LIST
57454: LIST
57455: PPUSH
57456: CALL_OW 72
57460: PUSH
57461: FOR_IN
57462: IFFALSE 57516
// if not IsInUnit ( j ) and not HasTask ( j ) then
57464: LD_VAR 0 3
57468: PPUSH
57469: CALL_OW 310
57473: NOT
57474: PUSH
57475: LD_VAR 0 3
57479: PPUSH
57480: CALL_OW 314
57484: NOT
57485: AND
57486: IFFALSE 57514
// begin ComEnterUnit ( j , selected ) ;
57488: LD_VAR 0 3
57492: PPUSH
57493: LD_VAR 0 7
57497: PPUSH
57498: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
57502: LD_VAR 0 3
57506: PPUSH
57507: LD_INT 15
57509: PPUSH
57510: CALL_OW 183
// end ;
57514: GO 57461
57516: POP
57517: POP
// end ; end ; end ; end ; end ;
57518: GO 56911
57520: POP
57521: POP
// end ;
57522: LD_VAR 0 1
57526: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
57527: LD_INT 0
57529: PPUSH
57530: PPUSH
57531: PPUSH
57532: PPUSH
// if not mc_bases then
57533: LD_EXP 100
57537: NOT
57538: IFFALSE 57542
// exit ;
57540: GO 57720
// for i = 1 to mc_bases do
57542: LD_ADDR_VAR 0 2
57546: PUSH
57547: DOUBLE
57548: LD_INT 1
57550: DEC
57551: ST_TO_ADDR
57552: LD_EXP 100
57556: PUSH
57557: FOR_TO
57558: IFFALSE 57718
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
57560: LD_ADDR_VAR 0 4
57564: PUSH
57565: LD_EXP 100
57569: PUSH
57570: LD_VAR 0 2
57574: ARRAY
57575: PPUSH
57576: LD_INT 25
57578: PUSH
57579: LD_INT 9
57581: PUSH
57582: EMPTY
57583: LIST
57584: LIST
57585: PPUSH
57586: CALL_OW 72
57590: ST_TO_ADDR
// if not tmp then
57591: LD_VAR 0 4
57595: NOT
57596: IFFALSE 57600
// continue ;
57598: GO 57557
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
57600: LD_EXP 126
57604: PUSH
57605: LD_VAR 0 2
57609: ARRAY
57610: PPUSH
57611: LD_INT 29
57613: PPUSH
57614: CALL_OW 325
57618: NOT
57619: PUSH
57620: LD_EXP 126
57624: PUSH
57625: LD_VAR 0 2
57629: ARRAY
57630: PPUSH
57631: LD_INT 28
57633: PPUSH
57634: CALL_OW 325
57638: NOT
57639: AND
57640: IFFALSE 57644
// continue ;
57642: GO 57557
// for j in tmp do
57644: LD_ADDR_VAR 0 3
57648: PUSH
57649: LD_VAR 0 4
57653: PUSH
57654: FOR_IN
57655: IFFALSE 57714
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
57657: LD_VAR 0 3
57661: PUSH
57662: LD_EXP 103
57666: PUSH
57667: LD_VAR 0 2
57671: ARRAY
57672: PUSH
57673: LD_INT 1
57675: ARRAY
57676: IN
57677: NOT
57678: PUSH
57679: LD_VAR 0 3
57683: PUSH
57684: LD_EXP 103
57688: PUSH
57689: LD_VAR 0 2
57693: ARRAY
57694: PUSH
57695: LD_INT 2
57697: ARRAY
57698: IN
57699: NOT
57700: AND
57701: IFFALSE 57712
// ComSpaceTimeShoot ( j ) ;
57703: LD_VAR 0 3
57707: PPUSH
57708: CALL 68921 0 1
57712: GO 57654
57714: POP
57715: POP
// end ;
57716: GO 57557
57718: POP
57719: POP
// end ;
57720: LD_VAR 0 1
57724: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
57725: LD_INT 0
57727: PPUSH
57728: PPUSH
57729: PPUSH
57730: PPUSH
57731: PPUSH
57732: PPUSH
57733: PPUSH
57734: PPUSH
57735: PPUSH
// if not mc_bases then
57736: LD_EXP 100
57740: NOT
57741: IFFALSE 57745
// exit ;
57743: GO 58367
// for i = 1 to mc_bases do
57745: LD_ADDR_VAR 0 2
57749: PUSH
57750: DOUBLE
57751: LD_INT 1
57753: DEC
57754: ST_TO_ADDR
57755: LD_EXP 100
57759: PUSH
57760: FOR_TO
57761: IFFALSE 58365
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
57763: LD_EXP 135
57767: PUSH
57768: LD_VAR 0 2
57772: ARRAY
57773: NOT
57774: PUSH
57775: LD_INT 38
57777: PPUSH
57778: LD_EXP 126
57782: PUSH
57783: LD_VAR 0 2
57787: ARRAY
57788: PPUSH
57789: CALL_OW 321
57793: PUSH
57794: LD_INT 2
57796: NONEQUAL
57797: OR
57798: IFFALSE 57802
// continue ;
57800: GO 57760
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
57802: LD_ADDR_VAR 0 8
57806: PUSH
57807: LD_EXP 100
57811: PUSH
57812: LD_VAR 0 2
57816: ARRAY
57817: PPUSH
57818: LD_INT 30
57820: PUSH
57821: LD_INT 34
57823: PUSH
57824: EMPTY
57825: LIST
57826: LIST
57827: PPUSH
57828: CALL_OW 72
57832: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
57833: LD_ADDR_VAR 0 9
57837: PUSH
57838: LD_EXP 100
57842: PUSH
57843: LD_VAR 0 2
57847: ARRAY
57848: PPUSH
57849: LD_INT 25
57851: PUSH
57852: LD_INT 4
57854: PUSH
57855: EMPTY
57856: LIST
57857: LIST
57858: PPUSH
57859: CALL_OW 72
57863: PPUSH
57864: LD_INT 0
57866: PPUSH
57867: CALL 102848 0 2
57871: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
57872: LD_VAR 0 9
57876: NOT
57877: PUSH
57878: LD_VAR 0 8
57882: NOT
57883: OR
57884: PUSH
57885: LD_EXP 100
57889: PUSH
57890: LD_VAR 0 2
57894: ARRAY
57895: PPUSH
57896: LD_INT 124
57898: PPUSH
57899: CALL 102848 0 2
57903: OR
57904: IFFALSE 57908
// continue ;
57906: GO 57760
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
57908: LD_EXP 136
57912: PUSH
57913: LD_VAR 0 2
57917: ARRAY
57918: PUSH
57919: LD_EXP 135
57923: PUSH
57924: LD_VAR 0 2
57928: ARRAY
57929: LESS
57930: PUSH
57931: LD_EXP 136
57935: PUSH
57936: LD_VAR 0 2
57940: ARRAY
57941: PUSH
57942: LD_VAR 0 8
57946: LESS
57947: AND
57948: IFFALSE 58363
// begin tmp := sci [ 1 ] ;
57950: LD_ADDR_VAR 0 7
57954: PUSH
57955: LD_VAR 0 9
57959: PUSH
57960: LD_INT 1
57962: ARRAY
57963: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
57964: LD_VAR 0 7
57968: PPUSH
57969: LD_INT 124
57971: PPUSH
57972: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
57976: LD_ADDR_VAR 0 3
57980: PUSH
57981: DOUBLE
57982: LD_EXP 135
57986: PUSH
57987: LD_VAR 0 2
57991: ARRAY
57992: INC
57993: ST_TO_ADDR
57994: LD_EXP 135
57998: PUSH
57999: LD_VAR 0 2
58003: ARRAY
58004: PUSH
58005: FOR_DOWNTO
58006: IFFALSE 58349
// begin if IsInUnit ( tmp ) then
58008: LD_VAR 0 7
58012: PPUSH
58013: CALL_OW 310
58017: IFFALSE 58028
// ComExitBuilding ( tmp ) ;
58019: LD_VAR 0 7
58023: PPUSH
58024: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
58028: LD_INT 35
58030: PPUSH
58031: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
58035: LD_VAR 0 7
58039: PPUSH
58040: CALL_OW 310
58044: NOT
58045: PUSH
58046: LD_VAR 0 7
58050: PPUSH
58051: CALL_OW 314
58055: NOT
58056: AND
58057: IFFALSE 58028
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
58059: LD_ADDR_VAR 0 6
58063: PUSH
58064: LD_VAR 0 7
58068: PPUSH
58069: CALL_OW 250
58073: PUSH
58074: LD_VAR 0 7
58078: PPUSH
58079: CALL_OW 251
58083: PUSH
58084: EMPTY
58085: LIST
58086: LIST
58087: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
58088: LD_INT 35
58090: PPUSH
58091: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
58095: LD_ADDR_VAR 0 4
58099: PUSH
58100: LD_EXP 135
58104: PUSH
58105: LD_VAR 0 2
58109: ARRAY
58110: PUSH
58111: LD_VAR 0 3
58115: ARRAY
58116: PUSH
58117: LD_INT 1
58119: ARRAY
58120: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
58121: LD_ADDR_VAR 0 5
58125: PUSH
58126: LD_EXP 135
58130: PUSH
58131: LD_VAR 0 2
58135: ARRAY
58136: PUSH
58137: LD_VAR 0 3
58141: ARRAY
58142: PUSH
58143: LD_INT 2
58145: ARRAY
58146: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
58147: LD_VAR 0 7
58151: PPUSH
58152: LD_INT 10
58154: PPUSH
58155: CALL 75533 0 2
58159: PUSH
58160: LD_INT 4
58162: ARRAY
58163: IFFALSE 58201
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
58165: LD_VAR 0 7
58169: PPUSH
58170: LD_VAR 0 6
58174: PUSH
58175: LD_INT 1
58177: ARRAY
58178: PPUSH
58179: LD_VAR 0 6
58183: PUSH
58184: LD_INT 2
58186: ARRAY
58187: PPUSH
58188: CALL_OW 111
// wait ( 0 0$10 ) ;
58192: LD_INT 350
58194: PPUSH
58195: CALL_OW 67
// end else
58199: GO 58227
// begin ComMoveXY ( tmp , x , y ) ;
58201: LD_VAR 0 7
58205: PPUSH
58206: LD_VAR 0 4
58210: PPUSH
58211: LD_VAR 0 5
58215: PPUSH
58216: CALL_OW 111
// wait ( 0 0$3 ) ;
58220: LD_INT 105
58222: PPUSH
58223: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
58227: LD_VAR 0 7
58231: PPUSH
58232: LD_VAR 0 4
58236: PPUSH
58237: LD_VAR 0 5
58241: PPUSH
58242: CALL_OW 307
58246: IFFALSE 58088
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
58248: LD_VAR 0 7
58252: PPUSH
58253: LD_VAR 0 4
58257: PPUSH
58258: LD_VAR 0 5
58262: PPUSH
58263: LD_VAR 0 8
58267: PUSH
58268: LD_VAR 0 3
58272: ARRAY
58273: PPUSH
58274: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
58278: LD_INT 35
58280: PPUSH
58281: CALL_OW 67
// until not HasTask ( tmp ) ;
58285: LD_VAR 0 7
58289: PPUSH
58290: CALL_OW 314
58294: NOT
58295: IFFALSE 58278
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
58297: LD_ADDR_EXP 136
58301: PUSH
58302: LD_EXP 136
58306: PPUSH
58307: LD_VAR 0 2
58311: PUSH
58312: LD_EXP 136
58316: PUSH
58317: LD_VAR 0 2
58321: ARRAY
58322: PUSH
58323: LD_INT 1
58325: PLUS
58326: PUSH
58327: EMPTY
58328: LIST
58329: LIST
58330: PPUSH
58331: LD_VAR 0 8
58335: PUSH
58336: LD_VAR 0 3
58340: ARRAY
58341: PPUSH
58342: CALL 72936 0 3
58346: ST_TO_ADDR
// end ;
58347: GO 58005
58349: POP
58350: POP
// MC_Reset ( i , 124 ) ;
58351: LD_VAR 0 2
58355: PPUSH
58356: LD_INT 124
58358: PPUSH
58359: CALL 41449 0 2
// end ; end ;
58363: GO 57760
58365: POP
58366: POP
// end ;
58367: LD_VAR 0 1
58371: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
58372: LD_INT 0
58374: PPUSH
58375: PPUSH
58376: PPUSH
// if not mc_bases then
58377: LD_EXP 100
58381: NOT
58382: IFFALSE 58386
// exit ;
58384: GO 58992
// for i = 1 to mc_bases do
58386: LD_ADDR_VAR 0 2
58390: PUSH
58391: DOUBLE
58392: LD_INT 1
58394: DEC
58395: ST_TO_ADDR
58396: LD_EXP 100
58400: PUSH
58401: FOR_TO
58402: IFFALSE 58990
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
58404: LD_ADDR_VAR 0 3
58408: PUSH
58409: LD_EXP 100
58413: PUSH
58414: LD_VAR 0 2
58418: ARRAY
58419: PPUSH
58420: LD_INT 25
58422: PUSH
58423: LD_INT 4
58425: PUSH
58426: EMPTY
58427: LIST
58428: LIST
58429: PPUSH
58430: CALL_OW 72
58434: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
58435: LD_VAR 0 3
58439: NOT
58440: PUSH
58441: LD_EXP 137
58445: PUSH
58446: LD_VAR 0 2
58450: ARRAY
58451: NOT
58452: OR
58453: PUSH
58454: LD_EXP 100
58458: PUSH
58459: LD_VAR 0 2
58463: ARRAY
58464: PPUSH
58465: LD_INT 2
58467: PUSH
58468: LD_INT 30
58470: PUSH
58471: LD_INT 0
58473: PUSH
58474: EMPTY
58475: LIST
58476: LIST
58477: PUSH
58478: LD_INT 30
58480: PUSH
58481: LD_INT 1
58483: PUSH
58484: EMPTY
58485: LIST
58486: LIST
58487: PUSH
58488: EMPTY
58489: LIST
58490: LIST
58491: LIST
58492: PPUSH
58493: CALL_OW 72
58497: NOT
58498: OR
58499: IFFALSE 58549
// begin if mc_deposits_finder [ i ] then
58501: LD_EXP 138
58505: PUSH
58506: LD_VAR 0 2
58510: ARRAY
58511: IFFALSE 58547
// begin MC_Reset ( i , 125 ) ;
58513: LD_VAR 0 2
58517: PPUSH
58518: LD_INT 125
58520: PPUSH
58521: CALL 41449 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
58525: LD_ADDR_EXP 138
58529: PUSH
58530: LD_EXP 138
58534: PPUSH
58535: LD_VAR 0 2
58539: PPUSH
58540: EMPTY
58541: PPUSH
58542: CALL_OW 1
58546: ST_TO_ADDR
// end ; continue ;
58547: GO 58401
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
58549: LD_EXP 137
58553: PUSH
58554: LD_VAR 0 2
58558: ARRAY
58559: PUSH
58560: LD_INT 1
58562: ARRAY
58563: PUSH
58564: LD_INT 3
58566: ARRAY
58567: PUSH
58568: LD_INT 1
58570: EQUAL
58571: PUSH
58572: LD_INT 20
58574: PPUSH
58575: LD_EXP 126
58579: PUSH
58580: LD_VAR 0 2
58584: ARRAY
58585: PPUSH
58586: CALL_OW 321
58590: PUSH
58591: LD_INT 2
58593: NONEQUAL
58594: AND
58595: IFFALSE 58645
// begin if mc_deposits_finder [ i ] then
58597: LD_EXP 138
58601: PUSH
58602: LD_VAR 0 2
58606: ARRAY
58607: IFFALSE 58643
// begin MC_Reset ( i , 125 ) ;
58609: LD_VAR 0 2
58613: PPUSH
58614: LD_INT 125
58616: PPUSH
58617: CALL 41449 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
58621: LD_ADDR_EXP 138
58625: PUSH
58626: LD_EXP 138
58630: PPUSH
58631: LD_VAR 0 2
58635: PPUSH
58636: EMPTY
58637: PPUSH
58638: CALL_OW 1
58642: ST_TO_ADDR
// end ; continue ;
58643: GO 58401
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
58645: LD_EXP 137
58649: PUSH
58650: LD_VAR 0 2
58654: ARRAY
58655: PUSH
58656: LD_INT 1
58658: ARRAY
58659: PUSH
58660: LD_INT 1
58662: ARRAY
58663: PPUSH
58664: LD_EXP 137
58668: PUSH
58669: LD_VAR 0 2
58673: ARRAY
58674: PUSH
58675: LD_INT 1
58677: ARRAY
58678: PUSH
58679: LD_INT 2
58681: ARRAY
58682: PPUSH
58683: LD_EXP 126
58687: PUSH
58688: LD_VAR 0 2
58692: ARRAY
58693: PPUSH
58694: CALL_OW 440
58698: IFFALSE 58741
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
58700: LD_ADDR_EXP 137
58704: PUSH
58705: LD_EXP 137
58709: PPUSH
58710: LD_VAR 0 2
58714: PPUSH
58715: LD_EXP 137
58719: PUSH
58720: LD_VAR 0 2
58724: ARRAY
58725: PPUSH
58726: LD_INT 1
58728: PPUSH
58729: CALL_OW 3
58733: PPUSH
58734: CALL_OW 1
58738: ST_TO_ADDR
58739: GO 58988
// begin if not mc_deposits_finder [ i ] then
58741: LD_EXP 138
58745: PUSH
58746: LD_VAR 0 2
58750: ARRAY
58751: NOT
58752: IFFALSE 58804
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
58754: LD_ADDR_EXP 138
58758: PUSH
58759: LD_EXP 138
58763: PPUSH
58764: LD_VAR 0 2
58768: PPUSH
58769: LD_VAR 0 3
58773: PUSH
58774: LD_INT 1
58776: ARRAY
58777: PUSH
58778: EMPTY
58779: LIST
58780: PPUSH
58781: CALL_OW 1
58785: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
58786: LD_VAR 0 3
58790: PUSH
58791: LD_INT 1
58793: ARRAY
58794: PPUSH
58795: LD_INT 125
58797: PPUSH
58798: CALL_OW 109
// end else
58802: GO 58988
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
58804: LD_EXP 138
58808: PUSH
58809: LD_VAR 0 2
58813: ARRAY
58814: PUSH
58815: LD_INT 1
58817: ARRAY
58818: PPUSH
58819: CALL_OW 310
58823: IFFALSE 58846
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
58825: LD_EXP 138
58829: PUSH
58830: LD_VAR 0 2
58834: ARRAY
58835: PUSH
58836: LD_INT 1
58838: ARRAY
58839: PPUSH
58840: CALL_OW 122
58844: GO 58988
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
58846: LD_EXP 138
58850: PUSH
58851: LD_VAR 0 2
58855: ARRAY
58856: PUSH
58857: LD_INT 1
58859: ARRAY
58860: PPUSH
58861: CALL_OW 314
58865: NOT
58866: PUSH
58867: LD_EXP 138
58871: PUSH
58872: LD_VAR 0 2
58876: ARRAY
58877: PUSH
58878: LD_INT 1
58880: ARRAY
58881: PPUSH
58882: LD_EXP 137
58886: PUSH
58887: LD_VAR 0 2
58891: ARRAY
58892: PUSH
58893: LD_INT 1
58895: ARRAY
58896: PUSH
58897: LD_INT 1
58899: ARRAY
58900: PPUSH
58901: LD_EXP 137
58905: PUSH
58906: LD_VAR 0 2
58910: ARRAY
58911: PUSH
58912: LD_INT 1
58914: ARRAY
58915: PUSH
58916: LD_INT 2
58918: ARRAY
58919: PPUSH
58920: CALL_OW 297
58924: PUSH
58925: LD_INT 6
58927: GREATER
58928: AND
58929: IFFALSE 58988
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
58931: LD_EXP 138
58935: PUSH
58936: LD_VAR 0 2
58940: ARRAY
58941: PUSH
58942: LD_INT 1
58944: ARRAY
58945: PPUSH
58946: LD_EXP 137
58950: PUSH
58951: LD_VAR 0 2
58955: ARRAY
58956: PUSH
58957: LD_INT 1
58959: ARRAY
58960: PUSH
58961: LD_INT 1
58963: ARRAY
58964: PPUSH
58965: LD_EXP 137
58969: PUSH
58970: LD_VAR 0 2
58974: ARRAY
58975: PUSH
58976: LD_INT 1
58978: ARRAY
58979: PUSH
58980: LD_INT 2
58982: ARRAY
58983: PPUSH
58984: CALL_OW 111
// end ; end ; end ;
58988: GO 58401
58990: POP
58991: POP
// end ;
58992: LD_VAR 0 1
58996: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
58997: LD_INT 0
58999: PPUSH
59000: PPUSH
59001: PPUSH
59002: PPUSH
59003: PPUSH
59004: PPUSH
59005: PPUSH
59006: PPUSH
59007: PPUSH
59008: PPUSH
59009: PPUSH
// if not mc_bases then
59010: LD_EXP 100
59014: NOT
59015: IFFALSE 59019
// exit ;
59017: GO 59959
// for i = 1 to mc_bases do
59019: LD_ADDR_VAR 0 2
59023: PUSH
59024: DOUBLE
59025: LD_INT 1
59027: DEC
59028: ST_TO_ADDR
59029: LD_EXP 100
59033: PUSH
59034: FOR_TO
59035: IFFALSE 59957
// begin if not mc_bases [ i ] or mc_scan [ i ] then
59037: LD_EXP 100
59041: PUSH
59042: LD_VAR 0 2
59046: ARRAY
59047: NOT
59048: PUSH
59049: LD_EXP 123
59053: PUSH
59054: LD_VAR 0 2
59058: ARRAY
59059: OR
59060: IFFALSE 59064
// continue ;
59062: GO 59034
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
59064: LD_ADDR_VAR 0 7
59068: PUSH
59069: LD_EXP 100
59073: PUSH
59074: LD_VAR 0 2
59078: ARRAY
59079: PUSH
59080: LD_INT 1
59082: ARRAY
59083: PPUSH
59084: CALL_OW 248
59088: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
59089: LD_VAR 0 7
59093: PUSH
59094: LD_INT 3
59096: EQUAL
59097: PUSH
59098: LD_EXP 119
59102: PUSH
59103: LD_VAR 0 2
59107: ARRAY
59108: PUSH
59109: LD_EXP 122
59113: PUSH
59114: LD_VAR 0 2
59118: ARRAY
59119: UNION
59120: PPUSH
59121: LD_INT 33
59123: PUSH
59124: LD_INT 2
59126: PUSH
59127: EMPTY
59128: LIST
59129: LIST
59130: PPUSH
59131: CALL_OW 72
59135: NOT
59136: OR
59137: IFFALSE 59141
// continue ;
59139: GO 59034
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
59141: LD_ADDR_VAR 0 9
59145: PUSH
59146: LD_EXP 100
59150: PUSH
59151: LD_VAR 0 2
59155: ARRAY
59156: PPUSH
59157: LD_INT 30
59159: PUSH
59160: LD_INT 36
59162: PUSH
59163: EMPTY
59164: LIST
59165: LIST
59166: PPUSH
59167: CALL_OW 72
59171: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
59172: LD_ADDR_VAR 0 10
59176: PUSH
59177: LD_EXP 119
59181: PUSH
59182: LD_VAR 0 2
59186: ARRAY
59187: PPUSH
59188: LD_INT 34
59190: PUSH
59191: LD_INT 31
59193: PUSH
59194: EMPTY
59195: LIST
59196: LIST
59197: PPUSH
59198: CALL_OW 72
59202: ST_TO_ADDR
// if not cts and not mcts then
59203: LD_VAR 0 9
59207: NOT
59208: PUSH
59209: LD_VAR 0 10
59213: NOT
59214: AND
59215: IFFALSE 59219
// continue ;
59217: GO 59034
// x := cts ;
59219: LD_ADDR_VAR 0 11
59223: PUSH
59224: LD_VAR 0 9
59228: ST_TO_ADDR
// if not x then
59229: LD_VAR 0 11
59233: NOT
59234: IFFALSE 59246
// x := mcts ;
59236: LD_ADDR_VAR 0 11
59240: PUSH
59241: LD_VAR 0 10
59245: ST_TO_ADDR
// if not x then
59246: LD_VAR 0 11
59250: NOT
59251: IFFALSE 59255
// continue ;
59253: GO 59034
// if mc_remote_driver [ i ] then
59255: LD_EXP 140
59259: PUSH
59260: LD_VAR 0 2
59264: ARRAY
59265: IFFALSE 59652
// for j in mc_remote_driver [ i ] do
59267: LD_ADDR_VAR 0 3
59271: PUSH
59272: LD_EXP 140
59276: PUSH
59277: LD_VAR 0 2
59281: ARRAY
59282: PUSH
59283: FOR_IN
59284: IFFALSE 59650
// begin if GetClass ( j ) <> 3 then
59286: LD_VAR 0 3
59290: PPUSH
59291: CALL_OW 257
59295: PUSH
59296: LD_INT 3
59298: NONEQUAL
59299: IFFALSE 59352
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
59301: LD_ADDR_EXP 140
59305: PUSH
59306: LD_EXP 140
59310: PPUSH
59311: LD_VAR 0 2
59315: PPUSH
59316: LD_EXP 140
59320: PUSH
59321: LD_VAR 0 2
59325: ARRAY
59326: PUSH
59327: LD_VAR 0 3
59331: DIFF
59332: PPUSH
59333: CALL_OW 1
59337: ST_TO_ADDR
// SetTag ( j , 0 ) ;
59338: LD_VAR 0 3
59342: PPUSH
59343: LD_INT 0
59345: PPUSH
59346: CALL_OW 109
// continue ;
59350: GO 59283
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
59352: LD_EXP 119
59356: PUSH
59357: LD_VAR 0 2
59361: ARRAY
59362: PPUSH
59363: LD_INT 34
59365: PUSH
59366: LD_INT 31
59368: PUSH
59369: EMPTY
59370: LIST
59371: LIST
59372: PUSH
59373: LD_INT 58
59375: PUSH
59376: EMPTY
59377: LIST
59378: PUSH
59379: EMPTY
59380: LIST
59381: LIST
59382: PPUSH
59383: CALL_OW 72
59387: PUSH
59388: LD_VAR 0 3
59392: PPUSH
59393: CALL 102883 0 1
59397: NOT
59398: AND
59399: IFFALSE 59470
// begin if IsInUnit ( j ) then
59401: LD_VAR 0 3
59405: PPUSH
59406: CALL_OW 310
59410: IFFALSE 59421
// ComExitBuilding ( j ) ;
59412: LD_VAR 0 3
59416: PPUSH
59417: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
59421: LD_VAR 0 3
59425: PPUSH
59426: LD_EXP 119
59430: PUSH
59431: LD_VAR 0 2
59435: ARRAY
59436: PPUSH
59437: LD_INT 34
59439: PUSH
59440: LD_INT 31
59442: PUSH
59443: EMPTY
59444: LIST
59445: LIST
59446: PUSH
59447: LD_INT 58
59449: PUSH
59450: EMPTY
59451: LIST
59452: PUSH
59453: EMPTY
59454: LIST
59455: LIST
59456: PPUSH
59457: CALL_OW 72
59461: PUSH
59462: LD_INT 1
59464: ARRAY
59465: PPUSH
59466: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
59470: LD_VAR 0 3
59474: PPUSH
59475: CALL_OW 310
59479: NOT
59480: PUSH
59481: LD_VAR 0 3
59485: PPUSH
59486: CALL_OW 310
59490: PPUSH
59491: CALL_OW 266
59495: PUSH
59496: LD_INT 36
59498: NONEQUAL
59499: PUSH
59500: LD_VAR 0 3
59504: PPUSH
59505: CALL 102883 0 1
59509: NOT
59510: AND
59511: OR
59512: IFFALSE 59648
// begin if IsInUnit ( j ) then
59514: LD_VAR 0 3
59518: PPUSH
59519: CALL_OW 310
59523: IFFALSE 59534
// ComExitBuilding ( j ) ;
59525: LD_VAR 0 3
59529: PPUSH
59530: CALL_OW 122
// ct := 0 ;
59534: LD_ADDR_VAR 0 8
59538: PUSH
59539: LD_INT 0
59541: ST_TO_ADDR
// for k in x do
59542: LD_ADDR_VAR 0 4
59546: PUSH
59547: LD_VAR 0 11
59551: PUSH
59552: FOR_IN
59553: IFFALSE 59626
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
59555: LD_VAR 0 4
59559: PPUSH
59560: CALL_OW 264
59564: PUSH
59565: LD_INT 31
59567: EQUAL
59568: PUSH
59569: LD_VAR 0 4
59573: PPUSH
59574: CALL_OW 311
59578: NOT
59579: AND
59580: PUSH
59581: LD_VAR 0 4
59585: PPUSH
59586: CALL_OW 266
59590: PUSH
59591: LD_INT 36
59593: EQUAL
59594: PUSH
59595: LD_VAR 0 4
59599: PPUSH
59600: CALL_OW 313
59604: PUSH
59605: LD_INT 3
59607: LESS
59608: AND
59609: OR
59610: IFFALSE 59624
// begin ct := k ;
59612: LD_ADDR_VAR 0 8
59616: PUSH
59617: LD_VAR 0 4
59621: ST_TO_ADDR
// break ;
59622: GO 59626
// end ;
59624: GO 59552
59626: POP
59627: POP
// if ct then
59628: LD_VAR 0 8
59632: IFFALSE 59648
// ComEnterUnit ( j , ct ) ;
59634: LD_VAR 0 3
59638: PPUSH
59639: LD_VAR 0 8
59643: PPUSH
59644: CALL_OW 120
// end ; end ;
59648: GO 59283
59650: POP
59651: POP
// places := 0 ;
59652: LD_ADDR_VAR 0 5
59656: PUSH
59657: LD_INT 0
59659: ST_TO_ADDR
// for j = 1 to x do
59660: LD_ADDR_VAR 0 3
59664: PUSH
59665: DOUBLE
59666: LD_INT 1
59668: DEC
59669: ST_TO_ADDR
59670: LD_VAR 0 11
59674: PUSH
59675: FOR_TO
59676: IFFALSE 59752
// if GetWeapon ( x [ j ] ) = ar_control_tower then
59678: LD_VAR 0 11
59682: PUSH
59683: LD_VAR 0 3
59687: ARRAY
59688: PPUSH
59689: CALL_OW 264
59693: PUSH
59694: LD_INT 31
59696: EQUAL
59697: IFFALSE 59715
// places := places + 1 else
59699: LD_ADDR_VAR 0 5
59703: PUSH
59704: LD_VAR 0 5
59708: PUSH
59709: LD_INT 1
59711: PLUS
59712: ST_TO_ADDR
59713: GO 59750
// if GetBType ( x [ j ] ) = b_control_tower then
59715: LD_VAR 0 11
59719: PUSH
59720: LD_VAR 0 3
59724: ARRAY
59725: PPUSH
59726: CALL_OW 266
59730: PUSH
59731: LD_INT 36
59733: EQUAL
59734: IFFALSE 59750
// places := places + 3 ;
59736: LD_ADDR_VAR 0 5
59740: PUSH
59741: LD_VAR 0 5
59745: PUSH
59746: LD_INT 3
59748: PLUS
59749: ST_TO_ADDR
59750: GO 59675
59752: POP
59753: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
59754: LD_VAR 0 5
59758: PUSH
59759: LD_INT 0
59761: EQUAL
59762: PUSH
59763: LD_VAR 0 5
59767: PUSH
59768: LD_EXP 140
59772: PUSH
59773: LD_VAR 0 2
59777: ARRAY
59778: LESSEQUAL
59779: OR
59780: IFFALSE 59784
// continue ;
59782: GO 59034
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
59784: LD_ADDR_VAR 0 6
59788: PUSH
59789: LD_EXP 100
59793: PUSH
59794: LD_VAR 0 2
59798: ARRAY
59799: PPUSH
59800: LD_INT 25
59802: PUSH
59803: LD_INT 3
59805: PUSH
59806: EMPTY
59807: LIST
59808: LIST
59809: PPUSH
59810: CALL_OW 72
59814: PUSH
59815: LD_EXP 140
59819: PUSH
59820: LD_VAR 0 2
59824: ARRAY
59825: DIFF
59826: PPUSH
59827: LD_INT 3
59829: PPUSH
59830: CALL 103783 0 2
59834: ST_TO_ADDR
// for j in tmp do
59835: LD_ADDR_VAR 0 3
59839: PUSH
59840: LD_VAR 0 6
59844: PUSH
59845: FOR_IN
59846: IFFALSE 59881
// if GetTag ( j ) > 0 then
59848: LD_VAR 0 3
59852: PPUSH
59853: CALL_OW 110
59857: PUSH
59858: LD_INT 0
59860: GREATER
59861: IFFALSE 59879
// tmp := tmp diff j ;
59863: LD_ADDR_VAR 0 6
59867: PUSH
59868: LD_VAR 0 6
59872: PUSH
59873: LD_VAR 0 3
59877: DIFF
59878: ST_TO_ADDR
59879: GO 59845
59881: POP
59882: POP
// if not tmp then
59883: LD_VAR 0 6
59887: NOT
59888: IFFALSE 59892
// continue ;
59890: GO 59034
// if places then
59892: LD_VAR 0 5
59896: IFFALSE 59955
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
59898: LD_ADDR_EXP 140
59902: PUSH
59903: LD_EXP 140
59907: PPUSH
59908: LD_VAR 0 2
59912: PPUSH
59913: LD_EXP 140
59917: PUSH
59918: LD_VAR 0 2
59922: ARRAY
59923: PUSH
59924: LD_VAR 0 6
59928: PUSH
59929: LD_INT 1
59931: ARRAY
59932: UNION
59933: PPUSH
59934: CALL_OW 1
59938: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
59939: LD_VAR 0 6
59943: PUSH
59944: LD_INT 1
59946: ARRAY
59947: PPUSH
59948: LD_INT 126
59950: PPUSH
59951: CALL_OW 109
// end ; end ;
59955: GO 59034
59957: POP
59958: POP
// end ;
59959: LD_VAR 0 1
59963: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
59964: LD_INT 0
59966: PPUSH
59967: PPUSH
59968: PPUSH
59969: PPUSH
59970: PPUSH
59971: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
59972: LD_VAR 0 1
59976: NOT
59977: PUSH
59978: LD_VAR 0 2
59982: NOT
59983: OR
59984: PUSH
59985: LD_VAR 0 3
59989: NOT
59990: OR
59991: PUSH
59992: LD_VAR 0 4
59996: PUSH
59997: LD_INT 1
59999: PUSH
60000: LD_INT 2
60002: PUSH
60003: LD_INT 3
60005: PUSH
60006: LD_INT 4
60008: PUSH
60009: LD_INT 5
60011: PUSH
60012: LD_INT 8
60014: PUSH
60015: LD_INT 9
60017: PUSH
60018: LD_INT 15
60020: PUSH
60021: LD_INT 16
60023: PUSH
60024: EMPTY
60025: LIST
60026: LIST
60027: LIST
60028: LIST
60029: LIST
60030: LIST
60031: LIST
60032: LIST
60033: LIST
60034: IN
60035: NOT
60036: OR
60037: IFFALSE 60041
// exit ;
60039: GO 60899
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
60041: LD_ADDR_VAR 0 2
60045: PUSH
60046: LD_VAR 0 2
60050: PPUSH
60051: LD_INT 21
60053: PUSH
60054: LD_INT 3
60056: PUSH
60057: EMPTY
60058: LIST
60059: LIST
60060: PUSH
60061: LD_INT 24
60063: PUSH
60064: LD_INT 250
60066: PUSH
60067: EMPTY
60068: LIST
60069: LIST
60070: PUSH
60071: EMPTY
60072: LIST
60073: LIST
60074: PPUSH
60075: CALL_OW 72
60079: ST_TO_ADDR
// case class of 1 , 15 :
60080: LD_VAR 0 4
60084: PUSH
60085: LD_INT 1
60087: DOUBLE
60088: EQUAL
60089: IFTRUE 60099
60091: LD_INT 15
60093: DOUBLE
60094: EQUAL
60095: IFTRUE 60099
60097: GO 60184
60099: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
60100: LD_ADDR_VAR 0 8
60104: PUSH
60105: LD_VAR 0 2
60109: PPUSH
60110: LD_INT 2
60112: PUSH
60113: LD_INT 30
60115: PUSH
60116: LD_INT 32
60118: PUSH
60119: EMPTY
60120: LIST
60121: LIST
60122: PUSH
60123: LD_INT 30
60125: PUSH
60126: LD_INT 31
60128: PUSH
60129: EMPTY
60130: LIST
60131: LIST
60132: PUSH
60133: EMPTY
60134: LIST
60135: LIST
60136: LIST
60137: PPUSH
60138: CALL_OW 72
60142: PUSH
60143: LD_VAR 0 2
60147: PPUSH
60148: LD_INT 2
60150: PUSH
60151: LD_INT 30
60153: PUSH
60154: LD_INT 4
60156: PUSH
60157: EMPTY
60158: LIST
60159: LIST
60160: PUSH
60161: LD_INT 30
60163: PUSH
60164: LD_INT 5
60166: PUSH
60167: EMPTY
60168: LIST
60169: LIST
60170: PUSH
60171: EMPTY
60172: LIST
60173: LIST
60174: LIST
60175: PPUSH
60176: CALL_OW 72
60180: ADD
60181: ST_TO_ADDR
60182: GO 60430
60184: LD_INT 2
60186: DOUBLE
60187: EQUAL
60188: IFTRUE 60198
60190: LD_INT 16
60192: DOUBLE
60193: EQUAL
60194: IFTRUE 60198
60196: GO 60244
60198: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
60199: LD_ADDR_VAR 0 8
60203: PUSH
60204: LD_VAR 0 2
60208: PPUSH
60209: LD_INT 2
60211: PUSH
60212: LD_INT 30
60214: PUSH
60215: LD_INT 0
60217: PUSH
60218: EMPTY
60219: LIST
60220: LIST
60221: PUSH
60222: LD_INT 30
60224: PUSH
60225: LD_INT 1
60227: PUSH
60228: EMPTY
60229: LIST
60230: LIST
60231: PUSH
60232: EMPTY
60233: LIST
60234: LIST
60235: LIST
60236: PPUSH
60237: CALL_OW 72
60241: ST_TO_ADDR
60242: GO 60430
60244: LD_INT 3
60246: DOUBLE
60247: EQUAL
60248: IFTRUE 60252
60250: GO 60298
60252: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
60253: LD_ADDR_VAR 0 8
60257: PUSH
60258: LD_VAR 0 2
60262: PPUSH
60263: LD_INT 2
60265: PUSH
60266: LD_INT 30
60268: PUSH
60269: LD_INT 2
60271: PUSH
60272: EMPTY
60273: LIST
60274: LIST
60275: PUSH
60276: LD_INT 30
60278: PUSH
60279: LD_INT 3
60281: PUSH
60282: EMPTY
60283: LIST
60284: LIST
60285: PUSH
60286: EMPTY
60287: LIST
60288: LIST
60289: LIST
60290: PPUSH
60291: CALL_OW 72
60295: ST_TO_ADDR
60296: GO 60430
60298: LD_INT 4
60300: DOUBLE
60301: EQUAL
60302: IFTRUE 60306
60304: GO 60363
60306: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
60307: LD_ADDR_VAR 0 8
60311: PUSH
60312: LD_VAR 0 2
60316: PPUSH
60317: LD_INT 2
60319: PUSH
60320: LD_INT 30
60322: PUSH
60323: LD_INT 6
60325: PUSH
60326: EMPTY
60327: LIST
60328: LIST
60329: PUSH
60330: LD_INT 30
60332: PUSH
60333: LD_INT 7
60335: PUSH
60336: EMPTY
60337: LIST
60338: LIST
60339: PUSH
60340: LD_INT 30
60342: PUSH
60343: LD_INT 8
60345: PUSH
60346: EMPTY
60347: LIST
60348: LIST
60349: PUSH
60350: EMPTY
60351: LIST
60352: LIST
60353: LIST
60354: LIST
60355: PPUSH
60356: CALL_OW 72
60360: ST_TO_ADDR
60361: GO 60430
60363: LD_INT 5
60365: DOUBLE
60366: EQUAL
60367: IFTRUE 60383
60369: LD_INT 8
60371: DOUBLE
60372: EQUAL
60373: IFTRUE 60383
60375: LD_INT 9
60377: DOUBLE
60378: EQUAL
60379: IFTRUE 60383
60381: GO 60429
60383: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
60384: LD_ADDR_VAR 0 8
60388: PUSH
60389: LD_VAR 0 2
60393: PPUSH
60394: LD_INT 2
60396: PUSH
60397: LD_INT 30
60399: PUSH
60400: LD_INT 4
60402: PUSH
60403: EMPTY
60404: LIST
60405: LIST
60406: PUSH
60407: LD_INT 30
60409: PUSH
60410: LD_INT 5
60412: PUSH
60413: EMPTY
60414: LIST
60415: LIST
60416: PUSH
60417: EMPTY
60418: LIST
60419: LIST
60420: LIST
60421: PPUSH
60422: CALL_OW 72
60426: ST_TO_ADDR
60427: GO 60430
60429: POP
// if not tmp then
60430: LD_VAR 0 8
60434: NOT
60435: IFFALSE 60439
// exit ;
60437: GO 60899
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
60439: LD_VAR 0 4
60443: PUSH
60444: LD_INT 1
60446: PUSH
60447: LD_INT 15
60449: PUSH
60450: EMPTY
60451: LIST
60452: LIST
60453: IN
60454: PUSH
60455: LD_EXP 109
60459: PUSH
60460: LD_VAR 0 1
60464: ARRAY
60465: AND
60466: IFFALSE 60622
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
60468: LD_ADDR_VAR 0 9
60472: PUSH
60473: LD_EXP 109
60477: PUSH
60478: LD_VAR 0 1
60482: ARRAY
60483: PUSH
60484: LD_INT 1
60486: ARRAY
60487: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
60488: LD_VAR 0 9
60492: PUSH
60493: LD_EXP 110
60497: PUSH
60498: LD_VAR 0 1
60502: ARRAY
60503: IN
60504: NOT
60505: IFFALSE 60620
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
60507: LD_ADDR_EXP 110
60511: PUSH
60512: LD_EXP 110
60516: PPUSH
60517: LD_VAR 0 1
60521: PUSH
60522: LD_EXP 110
60526: PUSH
60527: LD_VAR 0 1
60531: ARRAY
60532: PUSH
60533: LD_INT 1
60535: PLUS
60536: PUSH
60537: EMPTY
60538: LIST
60539: LIST
60540: PPUSH
60541: LD_VAR 0 9
60545: PPUSH
60546: CALL 72936 0 3
60550: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
60551: LD_ADDR_EXP 109
60555: PUSH
60556: LD_EXP 109
60560: PPUSH
60561: LD_VAR 0 1
60565: PPUSH
60566: LD_EXP 109
60570: PUSH
60571: LD_VAR 0 1
60575: ARRAY
60576: PUSH
60577: LD_VAR 0 9
60581: DIFF
60582: PPUSH
60583: CALL_OW 1
60587: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
60588: LD_VAR 0 3
60592: PPUSH
60593: LD_EXP 110
60597: PUSH
60598: LD_VAR 0 1
60602: ARRAY
60603: PUSH
60604: LD_EXP 110
60608: PUSH
60609: LD_VAR 0 1
60613: ARRAY
60614: ARRAY
60615: PPUSH
60616: CALL_OW 120
// end ; exit ;
60620: GO 60899
// end ; if tmp > 1 then
60622: LD_VAR 0 8
60626: PUSH
60627: LD_INT 1
60629: GREATER
60630: IFFALSE 60734
// for i = 2 to tmp do
60632: LD_ADDR_VAR 0 6
60636: PUSH
60637: DOUBLE
60638: LD_INT 2
60640: DEC
60641: ST_TO_ADDR
60642: LD_VAR 0 8
60646: PUSH
60647: FOR_TO
60648: IFFALSE 60732
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
60650: LD_VAR 0 8
60654: PUSH
60655: LD_VAR 0 6
60659: ARRAY
60660: PPUSH
60661: CALL_OW 461
60665: PUSH
60666: LD_INT 6
60668: EQUAL
60669: IFFALSE 60730
// begin x := tmp [ i ] ;
60671: LD_ADDR_VAR 0 9
60675: PUSH
60676: LD_VAR 0 8
60680: PUSH
60681: LD_VAR 0 6
60685: ARRAY
60686: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
60687: LD_ADDR_VAR 0 8
60691: PUSH
60692: LD_VAR 0 8
60696: PPUSH
60697: LD_VAR 0 6
60701: PPUSH
60702: CALL_OW 3
60706: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
60707: LD_ADDR_VAR 0 8
60711: PUSH
60712: LD_VAR 0 8
60716: PPUSH
60717: LD_INT 1
60719: PPUSH
60720: LD_VAR 0 9
60724: PPUSH
60725: CALL_OW 2
60729: ST_TO_ADDR
// end ;
60730: GO 60647
60732: POP
60733: POP
// for i in tmp do
60734: LD_ADDR_VAR 0 6
60738: PUSH
60739: LD_VAR 0 8
60743: PUSH
60744: FOR_IN
60745: IFFALSE 60772
// begin if IsNotFull ( i ) then
60747: LD_VAR 0 6
60751: PPUSH
60752: CALL 70158 0 1
60756: IFFALSE 60770
// begin j := i ;
60758: LD_ADDR_VAR 0 7
60762: PUSH
60763: LD_VAR 0 6
60767: ST_TO_ADDR
// break ;
60768: GO 60772
// end ; end ;
60770: GO 60744
60772: POP
60773: POP
// if j then
60774: LD_VAR 0 7
60778: IFFALSE 60796
// ComEnterUnit ( unit , j ) else
60780: LD_VAR 0 3
60784: PPUSH
60785: LD_VAR 0 7
60789: PPUSH
60790: CALL_OW 120
60794: GO 60899
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60796: LD_ADDR_VAR 0 10
60800: PUSH
60801: LD_VAR 0 2
60805: PPUSH
60806: LD_INT 2
60808: PUSH
60809: LD_INT 30
60811: PUSH
60812: LD_INT 0
60814: PUSH
60815: EMPTY
60816: LIST
60817: LIST
60818: PUSH
60819: LD_INT 30
60821: PUSH
60822: LD_INT 1
60824: PUSH
60825: EMPTY
60826: LIST
60827: LIST
60828: PUSH
60829: EMPTY
60830: LIST
60831: LIST
60832: LIST
60833: PPUSH
60834: CALL_OW 72
60838: ST_TO_ADDR
// if depot then
60839: LD_VAR 0 10
60843: IFFALSE 60899
// begin depot := NearestUnitToUnit ( depot , unit ) ;
60845: LD_ADDR_VAR 0 10
60849: PUSH
60850: LD_VAR 0 10
60854: PPUSH
60855: LD_VAR 0 3
60859: PPUSH
60860: CALL_OW 74
60864: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
60865: LD_VAR 0 3
60869: PPUSH
60870: LD_VAR 0 10
60874: PPUSH
60875: CALL_OW 296
60879: PUSH
60880: LD_INT 10
60882: GREATER
60883: IFFALSE 60899
// ComStandNearbyBuilding ( unit , depot ) ;
60885: LD_VAR 0 3
60889: PPUSH
60890: LD_VAR 0 10
60894: PPUSH
60895: CALL 69538 0 2
// end ; end ; end ;
60899: LD_VAR 0 5
60903: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
60904: LD_INT 0
60906: PPUSH
60907: PPUSH
60908: PPUSH
60909: PPUSH
// if not mc_bases then
60910: LD_EXP 100
60914: NOT
60915: IFFALSE 60919
// exit ;
60917: GO 61158
// for i = 1 to mc_bases do
60919: LD_ADDR_VAR 0 2
60923: PUSH
60924: DOUBLE
60925: LD_INT 1
60927: DEC
60928: ST_TO_ADDR
60929: LD_EXP 100
60933: PUSH
60934: FOR_TO
60935: IFFALSE 61156
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
60937: LD_ADDR_VAR 0 4
60941: PUSH
60942: LD_EXP 100
60946: PUSH
60947: LD_VAR 0 2
60951: ARRAY
60952: PPUSH
60953: LD_INT 21
60955: PUSH
60956: LD_INT 1
60958: PUSH
60959: EMPTY
60960: LIST
60961: LIST
60962: PPUSH
60963: CALL_OW 72
60967: PUSH
60968: LD_EXP 129
60972: PUSH
60973: LD_VAR 0 2
60977: ARRAY
60978: UNION
60979: ST_TO_ADDR
// if not tmp then
60980: LD_VAR 0 4
60984: NOT
60985: IFFALSE 60989
// continue ;
60987: GO 60934
// for j in tmp do
60989: LD_ADDR_VAR 0 3
60993: PUSH
60994: LD_VAR 0 4
60998: PUSH
60999: FOR_IN
61000: IFFALSE 61152
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
61002: LD_VAR 0 3
61006: PPUSH
61007: CALL_OW 110
61011: NOT
61012: PUSH
61013: LD_VAR 0 3
61017: PPUSH
61018: CALL_OW 314
61022: NOT
61023: AND
61024: PUSH
61025: LD_VAR 0 3
61029: PPUSH
61030: CALL_OW 311
61034: NOT
61035: AND
61036: PUSH
61037: LD_VAR 0 3
61041: PPUSH
61042: CALL_OW 310
61046: NOT
61047: AND
61048: PUSH
61049: LD_VAR 0 3
61053: PUSH
61054: LD_EXP 103
61058: PUSH
61059: LD_VAR 0 2
61063: ARRAY
61064: PUSH
61065: LD_INT 1
61067: ARRAY
61068: IN
61069: NOT
61070: AND
61071: PUSH
61072: LD_VAR 0 3
61076: PUSH
61077: LD_EXP 103
61081: PUSH
61082: LD_VAR 0 2
61086: ARRAY
61087: PUSH
61088: LD_INT 2
61090: ARRAY
61091: IN
61092: NOT
61093: AND
61094: PUSH
61095: LD_VAR 0 3
61099: PUSH
61100: LD_EXP 112
61104: PUSH
61105: LD_VAR 0 2
61109: ARRAY
61110: IN
61111: NOT
61112: AND
61113: IFFALSE 61150
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
61115: LD_VAR 0 2
61119: PPUSH
61120: LD_EXP 100
61124: PUSH
61125: LD_VAR 0 2
61129: ARRAY
61130: PPUSH
61131: LD_VAR 0 3
61135: PPUSH
61136: LD_VAR 0 3
61140: PPUSH
61141: CALL_OW 257
61145: PPUSH
61146: CALL 59964 0 4
// end ;
61150: GO 60999
61152: POP
61153: POP
// end ;
61154: GO 60934
61156: POP
61157: POP
// end ;
61158: LD_VAR 0 1
61162: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
61163: LD_INT 0
61165: PPUSH
61166: PPUSH
61167: PPUSH
61168: PPUSH
61169: PPUSH
61170: PPUSH
// if not mc_bases [ base ] then
61171: LD_EXP 100
61175: PUSH
61176: LD_VAR 0 1
61180: ARRAY
61181: NOT
61182: IFFALSE 61186
// exit ;
61184: GO 61387
// tmp := [ ] ;
61186: LD_ADDR_VAR 0 6
61190: PUSH
61191: EMPTY
61192: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
61193: LD_ADDR_VAR 0 7
61197: PUSH
61198: LD_VAR 0 3
61202: PPUSH
61203: LD_INT 0
61205: PPUSH
61206: CALL_OW 517
61210: ST_TO_ADDR
// if not list then
61211: LD_VAR 0 7
61215: NOT
61216: IFFALSE 61220
// exit ;
61218: GO 61387
// c := Count ( list [ 1 ] ) ;
61220: LD_ADDR_VAR 0 9
61224: PUSH
61225: LD_VAR 0 7
61229: PUSH
61230: LD_INT 1
61232: ARRAY
61233: PPUSH
61234: CALL 70076 0 1
61238: ST_TO_ADDR
// if amount > c then
61239: LD_VAR 0 2
61243: PUSH
61244: LD_VAR 0 9
61248: GREATER
61249: IFFALSE 61261
// amount := c ;
61251: LD_ADDR_VAR 0 2
61255: PUSH
61256: LD_VAR 0 9
61260: ST_TO_ADDR
// for i := 1 to amount do
61261: LD_ADDR_VAR 0 5
61265: PUSH
61266: DOUBLE
61267: LD_INT 1
61269: DEC
61270: ST_TO_ADDR
61271: LD_VAR 0 2
61275: PUSH
61276: FOR_TO
61277: IFFALSE 61335
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
61279: LD_ADDR_VAR 0 6
61283: PUSH
61284: LD_VAR 0 6
61288: PPUSH
61289: LD_VAR 0 5
61293: PPUSH
61294: LD_VAR 0 7
61298: PUSH
61299: LD_INT 1
61301: ARRAY
61302: PUSH
61303: LD_VAR 0 5
61307: ARRAY
61308: PUSH
61309: LD_VAR 0 7
61313: PUSH
61314: LD_INT 2
61316: ARRAY
61317: PUSH
61318: LD_VAR 0 5
61322: ARRAY
61323: PUSH
61324: EMPTY
61325: LIST
61326: LIST
61327: PPUSH
61328: CALL_OW 1
61332: ST_TO_ADDR
61333: GO 61276
61335: POP
61336: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
61337: LD_ADDR_EXP 113
61341: PUSH
61342: LD_EXP 113
61346: PPUSH
61347: LD_VAR 0 1
61351: PPUSH
61352: LD_VAR 0 6
61356: PPUSH
61357: CALL_OW 1
61361: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
61362: LD_ADDR_EXP 115
61366: PUSH
61367: LD_EXP 115
61371: PPUSH
61372: LD_VAR 0 1
61376: PPUSH
61377: LD_VAR 0 3
61381: PPUSH
61382: CALL_OW 1
61386: ST_TO_ADDR
// end ;
61387: LD_VAR 0 4
61391: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
61392: LD_INT 0
61394: PPUSH
// if not mc_bases [ base ] then
61395: LD_EXP 100
61399: PUSH
61400: LD_VAR 0 1
61404: ARRAY
61405: NOT
61406: IFFALSE 61410
// exit ;
61408: GO 61435
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
61410: LD_ADDR_EXP 105
61414: PUSH
61415: LD_EXP 105
61419: PPUSH
61420: LD_VAR 0 1
61424: PPUSH
61425: LD_VAR 0 2
61429: PPUSH
61430: CALL_OW 1
61434: ST_TO_ADDR
// end ;
61435: LD_VAR 0 3
61439: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
61440: LD_INT 0
61442: PPUSH
// if not mc_bases [ base ] then
61443: LD_EXP 100
61447: PUSH
61448: LD_VAR 0 1
61452: ARRAY
61453: NOT
61454: IFFALSE 61458
// exit ;
61456: GO 61495
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
61458: LD_ADDR_EXP 105
61462: PUSH
61463: LD_EXP 105
61467: PPUSH
61468: LD_VAR 0 1
61472: PPUSH
61473: LD_EXP 105
61477: PUSH
61478: LD_VAR 0 1
61482: ARRAY
61483: PUSH
61484: LD_VAR 0 2
61488: UNION
61489: PPUSH
61490: CALL_OW 1
61494: ST_TO_ADDR
// end ;
61495: LD_VAR 0 3
61499: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
61500: LD_INT 0
61502: PPUSH
// if not mc_bases [ base ] then
61503: LD_EXP 100
61507: PUSH
61508: LD_VAR 0 1
61512: ARRAY
61513: NOT
61514: IFFALSE 61518
// exit ;
61516: GO 61543
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
61518: LD_ADDR_EXP 121
61522: PUSH
61523: LD_EXP 121
61527: PPUSH
61528: LD_VAR 0 1
61532: PPUSH
61533: LD_VAR 0 2
61537: PPUSH
61538: CALL_OW 1
61542: ST_TO_ADDR
// end ;
61543: LD_VAR 0 3
61547: RET
// export function MC_InsertProduceList ( base , components ) ; begin
61548: LD_INT 0
61550: PPUSH
// if not mc_bases [ base ] then
61551: LD_EXP 100
61555: PUSH
61556: LD_VAR 0 1
61560: ARRAY
61561: NOT
61562: IFFALSE 61566
// exit ;
61564: GO 61603
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
61566: LD_ADDR_EXP 121
61570: PUSH
61571: LD_EXP 121
61575: PPUSH
61576: LD_VAR 0 1
61580: PPUSH
61581: LD_EXP 121
61585: PUSH
61586: LD_VAR 0 1
61590: ARRAY
61591: PUSH
61592: LD_VAR 0 2
61596: ADD
61597: PPUSH
61598: CALL_OW 1
61602: ST_TO_ADDR
// end ;
61603: LD_VAR 0 3
61607: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
61608: LD_INT 0
61610: PPUSH
// if not mc_bases [ base ] then
61611: LD_EXP 100
61615: PUSH
61616: LD_VAR 0 1
61620: ARRAY
61621: NOT
61622: IFFALSE 61626
// exit ;
61624: GO 61680
// mc_defender := Replace ( mc_defender , base , deflist ) ;
61626: LD_ADDR_EXP 122
61630: PUSH
61631: LD_EXP 122
61635: PPUSH
61636: LD_VAR 0 1
61640: PPUSH
61641: LD_VAR 0 2
61645: PPUSH
61646: CALL_OW 1
61650: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
61651: LD_ADDR_EXP 111
61655: PUSH
61656: LD_EXP 111
61660: PPUSH
61661: LD_VAR 0 1
61665: PPUSH
61666: LD_VAR 0 2
61670: PUSH
61671: LD_INT 0
61673: PLUS
61674: PPUSH
61675: CALL_OW 1
61679: ST_TO_ADDR
// end ;
61680: LD_VAR 0 3
61684: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
61685: LD_INT 0
61687: PPUSH
// if not mc_bases [ base ] then
61688: LD_EXP 100
61692: PUSH
61693: LD_VAR 0 1
61697: ARRAY
61698: NOT
61699: IFFALSE 61703
// exit ;
61701: GO 61728
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
61703: LD_ADDR_EXP 111
61707: PUSH
61708: LD_EXP 111
61712: PPUSH
61713: LD_VAR 0 1
61717: PPUSH
61718: LD_VAR 0 2
61722: PPUSH
61723: CALL_OW 1
61727: ST_TO_ADDR
// end ;
61728: LD_VAR 0 3
61732: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
61733: LD_INT 0
61735: PPUSH
61736: PPUSH
61737: PPUSH
61738: PPUSH
// if not mc_bases [ base ] then
61739: LD_EXP 100
61743: PUSH
61744: LD_VAR 0 1
61748: ARRAY
61749: NOT
61750: IFFALSE 61754
// exit ;
61752: GO 61819
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
61754: LD_ADDR_EXP 120
61758: PUSH
61759: LD_EXP 120
61763: PPUSH
61764: LD_VAR 0 1
61768: PUSH
61769: LD_EXP 120
61773: PUSH
61774: LD_VAR 0 1
61778: ARRAY
61779: PUSH
61780: LD_INT 1
61782: PLUS
61783: PUSH
61784: EMPTY
61785: LIST
61786: LIST
61787: PPUSH
61788: LD_VAR 0 1
61792: PUSH
61793: LD_VAR 0 2
61797: PUSH
61798: LD_VAR 0 3
61802: PUSH
61803: LD_VAR 0 4
61807: PUSH
61808: EMPTY
61809: LIST
61810: LIST
61811: LIST
61812: LIST
61813: PPUSH
61814: CALL 72936 0 3
61818: ST_TO_ADDR
// end ;
61819: LD_VAR 0 5
61823: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
61824: LD_INT 0
61826: PPUSH
// if not mc_bases [ base ] then
61827: LD_EXP 100
61831: PUSH
61832: LD_VAR 0 1
61836: ARRAY
61837: NOT
61838: IFFALSE 61842
// exit ;
61840: GO 61867
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
61842: LD_ADDR_EXP 137
61846: PUSH
61847: LD_EXP 137
61851: PPUSH
61852: LD_VAR 0 1
61856: PPUSH
61857: LD_VAR 0 2
61861: PPUSH
61862: CALL_OW 1
61866: ST_TO_ADDR
// end ;
61867: LD_VAR 0 3
61871: RET
// export function MC_GetMinesField ( base ) ; begin
61872: LD_INT 0
61874: PPUSH
// result := mc_mines [ base ] ;
61875: LD_ADDR_VAR 0 2
61879: PUSH
61880: LD_EXP 113
61884: PUSH
61885: LD_VAR 0 1
61889: ARRAY
61890: ST_TO_ADDR
// end ;
61891: LD_VAR 0 2
61895: RET
// export function MC_GetProduceList ( base ) ; begin
61896: LD_INT 0
61898: PPUSH
// result := mc_produce [ base ] ;
61899: LD_ADDR_VAR 0 2
61903: PUSH
61904: LD_EXP 121
61908: PUSH
61909: LD_VAR 0 1
61913: ARRAY
61914: ST_TO_ADDR
// end ;
61915: LD_VAR 0 2
61919: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
61920: LD_INT 0
61922: PPUSH
61923: PPUSH
// if not mc_bases then
61924: LD_EXP 100
61928: NOT
61929: IFFALSE 61933
// exit ;
61931: GO 61998
// if mc_bases [ base ] then
61933: LD_EXP 100
61937: PUSH
61938: LD_VAR 0 1
61942: ARRAY
61943: IFFALSE 61998
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61945: LD_ADDR_VAR 0 3
61949: PUSH
61950: LD_EXP 100
61954: PUSH
61955: LD_VAR 0 1
61959: ARRAY
61960: PPUSH
61961: LD_INT 30
61963: PUSH
61964: LD_VAR 0 2
61968: PUSH
61969: EMPTY
61970: LIST
61971: LIST
61972: PPUSH
61973: CALL_OW 72
61977: ST_TO_ADDR
// if result then
61978: LD_VAR 0 3
61982: IFFALSE 61998
// result := result [ 1 ] ;
61984: LD_ADDR_VAR 0 3
61988: PUSH
61989: LD_VAR 0 3
61993: PUSH
61994: LD_INT 1
61996: ARRAY
61997: ST_TO_ADDR
// end ; end ;
61998: LD_VAR 0 3
62002: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
62003: LD_INT 0
62005: PPUSH
62006: PPUSH
// if not mc_bases then
62007: LD_EXP 100
62011: NOT
62012: IFFALSE 62016
// exit ;
62014: GO 62061
// if mc_bases [ base ] then
62016: LD_EXP 100
62020: PUSH
62021: LD_VAR 0 1
62025: ARRAY
62026: IFFALSE 62061
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
62028: LD_ADDR_VAR 0 3
62032: PUSH
62033: LD_EXP 100
62037: PUSH
62038: LD_VAR 0 1
62042: ARRAY
62043: PPUSH
62044: LD_INT 30
62046: PUSH
62047: LD_VAR 0 2
62051: PUSH
62052: EMPTY
62053: LIST
62054: LIST
62055: PPUSH
62056: CALL_OW 72
62060: ST_TO_ADDR
// end ;
62061: LD_VAR 0 3
62065: RET
// export function MC_SetTame ( base , area ) ; begin
62066: LD_INT 0
62068: PPUSH
// if not mc_bases or not base then
62069: LD_EXP 100
62073: NOT
62074: PUSH
62075: LD_VAR 0 1
62079: NOT
62080: OR
62081: IFFALSE 62085
// exit ;
62083: GO 62110
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
62085: LD_ADDR_EXP 128
62089: PUSH
62090: LD_EXP 128
62094: PPUSH
62095: LD_VAR 0 1
62099: PPUSH
62100: LD_VAR 0 2
62104: PPUSH
62105: CALL_OW 1
62109: ST_TO_ADDR
// end ;
62110: LD_VAR 0 3
62114: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
62115: LD_INT 0
62117: PPUSH
62118: PPUSH
// if not mc_bases or not base then
62119: LD_EXP 100
62123: NOT
62124: PUSH
62125: LD_VAR 0 1
62129: NOT
62130: OR
62131: IFFALSE 62135
// exit ;
62133: GO 62237
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
62135: LD_ADDR_VAR 0 4
62139: PUSH
62140: LD_EXP 100
62144: PUSH
62145: LD_VAR 0 1
62149: ARRAY
62150: PPUSH
62151: LD_INT 30
62153: PUSH
62154: LD_VAR 0 2
62158: PUSH
62159: EMPTY
62160: LIST
62161: LIST
62162: PPUSH
62163: CALL_OW 72
62167: ST_TO_ADDR
// if not tmp then
62168: LD_VAR 0 4
62172: NOT
62173: IFFALSE 62177
// exit ;
62175: GO 62237
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
62177: LD_ADDR_EXP 132
62181: PUSH
62182: LD_EXP 132
62186: PPUSH
62187: LD_VAR 0 1
62191: PPUSH
62192: LD_EXP 132
62196: PUSH
62197: LD_VAR 0 1
62201: ARRAY
62202: PPUSH
62203: LD_EXP 132
62207: PUSH
62208: LD_VAR 0 1
62212: ARRAY
62213: PUSH
62214: LD_INT 1
62216: PLUS
62217: PPUSH
62218: LD_VAR 0 4
62222: PUSH
62223: LD_INT 1
62225: ARRAY
62226: PPUSH
62227: CALL_OW 2
62231: PPUSH
62232: CALL_OW 1
62236: ST_TO_ADDR
// end ;
62237: LD_VAR 0 3
62241: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
62242: LD_INT 0
62244: PPUSH
62245: PPUSH
// if not mc_bases or not base or not kinds then
62246: LD_EXP 100
62250: NOT
62251: PUSH
62252: LD_VAR 0 1
62256: NOT
62257: OR
62258: PUSH
62259: LD_VAR 0 2
62263: NOT
62264: OR
62265: IFFALSE 62269
// exit ;
62267: GO 62330
// for i in kinds do
62269: LD_ADDR_VAR 0 4
62273: PUSH
62274: LD_VAR 0 2
62278: PUSH
62279: FOR_IN
62280: IFFALSE 62328
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
62282: LD_ADDR_EXP 134
62286: PUSH
62287: LD_EXP 134
62291: PPUSH
62292: LD_VAR 0 1
62296: PUSH
62297: LD_EXP 134
62301: PUSH
62302: LD_VAR 0 1
62306: ARRAY
62307: PUSH
62308: LD_INT 1
62310: PLUS
62311: PUSH
62312: EMPTY
62313: LIST
62314: LIST
62315: PPUSH
62316: LD_VAR 0 4
62320: PPUSH
62321: CALL 72936 0 3
62325: ST_TO_ADDR
62326: GO 62279
62328: POP
62329: POP
// end ;
62330: LD_VAR 0 3
62334: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
62335: LD_INT 0
62337: PPUSH
// if not mc_bases or not base or not areas then
62338: LD_EXP 100
62342: NOT
62343: PUSH
62344: LD_VAR 0 1
62348: NOT
62349: OR
62350: PUSH
62351: LD_VAR 0 2
62355: NOT
62356: OR
62357: IFFALSE 62361
// exit ;
62359: GO 62386
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
62361: LD_ADDR_EXP 118
62365: PUSH
62366: LD_EXP 118
62370: PPUSH
62371: LD_VAR 0 1
62375: PPUSH
62376: LD_VAR 0 2
62380: PPUSH
62381: CALL_OW 1
62385: ST_TO_ADDR
// end ;
62386: LD_VAR 0 3
62390: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
62391: LD_INT 0
62393: PPUSH
// if not mc_bases or not base or not teleports_exit then
62394: LD_EXP 100
62398: NOT
62399: PUSH
62400: LD_VAR 0 1
62404: NOT
62405: OR
62406: PUSH
62407: LD_VAR 0 2
62411: NOT
62412: OR
62413: IFFALSE 62417
// exit ;
62415: GO 62442
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
62417: LD_ADDR_EXP 135
62421: PUSH
62422: LD_EXP 135
62426: PPUSH
62427: LD_VAR 0 1
62431: PPUSH
62432: LD_VAR 0 2
62436: PPUSH
62437: CALL_OW 1
62441: ST_TO_ADDR
// end ;
62442: LD_VAR 0 3
62446: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
62447: LD_INT 0
62449: PPUSH
62450: PPUSH
62451: PPUSH
// if not mc_bases or not base or not ext_list then
62452: LD_EXP 100
62456: NOT
62457: PUSH
62458: LD_VAR 0 1
62462: NOT
62463: OR
62464: PUSH
62465: LD_VAR 0 5
62469: NOT
62470: OR
62471: IFFALSE 62475
// exit ;
62473: GO 62648
// tmp := GetFacExtXYD ( x , y , d ) ;
62475: LD_ADDR_VAR 0 8
62479: PUSH
62480: LD_VAR 0 2
62484: PPUSH
62485: LD_VAR 0 3
62489: PPUSH
62490: LD_VAR 0 4
62494: PPUSH
62495: CALL 102913 0 3
62499: ST_TO_ADDR
// if not tmp then
62500: LD_VAR 0 8
62504: NOT
62505: IFFALSE 62509
// exit ;
62507: GO 62648
// for i in tmp do
62509: LD_ADDR_VAR 0 7
62513: PUSH
62514: LD_VAR 0 8
62518: PUSH
62519: FOR_IN
62520: IFFALSE 62646
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
62522: LD_ADDR_EXP 105
62526: PUSH
62527: LD_EXP 105
62531: PPUSH
62532: LD_VAR 0 1
62536: PPUSH
62537: LD_EXP 105
62541: PUSH
62542: LD_VAR 0 1
62546: ARRAY
62547: PPUSH
62548: LD_EXP 105
62552: PUSH
62553: LD_VAR 0 1
62557: ARRAY
62558: PUSH
62559: LD_INT 1
62561: PLUS
62562: PPUSH
62563: LD_VAR 0 5
62567: PUSH
62568: LD_INT 1
62570: ARRAY
62571: PUSH
62572: LD_VAR 0 7
62576: PUSH
62577: LD_INT 1
62579: ARRAY
62580: PUSH
62581: LD_VAR 0 7
62585: PUSH
62586: LD_INT 2
62588: ARRAY
62589: PUSH
62590: LD_VAR 0 7
62594: PUSH
62595: LD_INT 3
62597: ARRAY
62598: PUSH
62599: EMPTY
62600: LIST
62601: LIST
62602: LIST
62603: LIST
62604: PPUSH
62605: CALL_OW 2
62609: PPUSH
62610: CALL_OW 1
62614: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
62615: LD_ADDR_VAR 0 5
62619: PUSH
62620: LD_VAR 0 5
62624: PPUSH
62625: LD_INT 1
62627: PPUSH
62628: CALL_OW 3
62632: ST_TO_ADDR
// if not ext_list then
62633: LD_VAR 0 5
62637: NOT
62638: IFFALSE 62644
// exit ;
62640: POP
62641: POP
62642: GO 62648
// end ;
62644: GO 62519
62646: POP
62647: POP
// end ;
62648: LD_VAR 0 6
62652: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
62653: LD_INT 0
62655: PPUSH
// if not mc_bases or not base or not weapon_list then
62656: LD_EXP 100
62660: NOT
62661: PUSH
62662: LD_VAR 0 1
62666: NOT
62667: OR
62668: PUSH
62669: LD_VAR 0 2
62673: NOT
62674: OR
62675: IFFALSE 62679
// exit ;
62677: GO 62704
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
62679: LD_ADDR_EXP 139
62683: PUSH
62684: LD_EXP 139
62688: PPUSH
62689: LD_VAR 0 1
62693: PPUSH
62694: LD_VAR 0 2
62698: PPUSH
62699: CALL_OW 1
62703: ST_TO_ADDR
// end ;
62704: LD_VAR 0 3
62708: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
62709: LD_INT 0
62711: PPUSH
// if not mc_bases or not base or not tech_list then
62712: LD_EXP 100
62716: NOT
62717: PUSH
62718: LD_VAR 0 1
62722: NOT
62723: OR
62724: PUSH
62725: LD_VAR 0 2
62729: NOT
62730: OR
62731: IFFALSE 62735
// exit ;
62733: GO 62760
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
62735: LD_ADDR_EXP 127
62739: PUSH
62740: LD_EXP 127
62744: PPUSH
62745: LD_VAR 0 1
62749: PPUSH
62750: LD_VAR 0 2
62754: PPUSH
62755: CALL_OW 1
62759: ST_TO_ADDR
// end ;
62760: LD_VAR 0 3
62764: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
62765: LD_INT 0
62767: PPUSH
// if not mc_bases or not parking_area or not base then
62768: LD_EXP 100
62772: NOT
62773: PUSH
62774: LD_VAR 0 2
62778: NOT
62779: OR
62780: PUSH
62781: LD_VAR 0 1
62785: NOT
62786: OR
62787: IFFALSE 62791
// exit ;
62789: GO 62816
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
62791: LD_ADDR_EXP 124
62795: PUSH
62796: LD_EXP 124
62800: PPUSH
62801: LD_VAR 0 1
62805: PPUSH
62806: LD_VAR 0 2
62810: PPUSH
62811: CALL_OW 1
62815: ST_TO_ADDR
// end ;
62816: LD_VAR 0 3
62820: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
62821: LD_INT 0
62823: PPUSH
// if not mc_bases or not base or not scan_area then
62824: LD_EXP 100
62828: NOT
62829: PUSH
62830: LD_VAR 0 1
62834: NOT
62835: OR
62836: PUSH
62837: LD_VAR 0 2
62841: NOT
62842: OR
62843: IFFALSE 62847
// exit ;
62845: GO 62872
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
62847: LD_ADDR_EXP 125
62851: PUSH
62852: LD_EXP 125
62856: PPUSH
62857: LD_VAR 0 1
62861: PPUSH
62862: LD_VAR 0 2
62866: PPUSH
62867: CALL_OW 1
62871: ST_TO_ADDR
// end ;
62872: LD_VAR 0 3
62876: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
62877: LD_INT 0
62879: PPUSH
62880: PPUSH
// if not mc_bases or not base then
62881: LD_EXP 100
62885: NOT
62886: PUSH
62887: LD_VAR 0 1
62891: NOT
62892: OR
62893: IFFALSE 62897
// exit ;
62895: GO 62961
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
62897: LD_ADDR_VAR 0 3
62901: PUSH
62902: LD_INT 1
62904: PUSH
62905: LD_INT 2
62907: PUSH
62908: LD_INT 3
62910: PUSH
62911: LD_INT 4
62913: PUSH
62914: LD_INT 11
62916: PUSH
62917: EMPTY
62918: LIST
62919: LIST
62920: LIST
62921: LIST
62922: LIST
62923: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
62924: LD_ADDR_EXP 127
62928: PUSH
62929: LD_EXP 127
62933: PPUSH
62934: LD_VAR 0 1
62938: PPUSH
62939: LD_EXP 127
62943: PUSH
62944: LD_VAR 0 1
62948: ARRAY
62949: PUSH
62950: LD_VAR 0 3
62954: DIFF
62955: PPUSH
62956: CALL_OW 1
62960: ST_TO_ADDR
// end ;
62961: LD_VAR 0 2
62965: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
62966: LD_INT 0
62968: PPUSH
// result := mc_vehicles [ base ] ;
62969: LD_ADDR_VAR 0 3
62973: PUSH
62974: LD_EXP 119
62978: PUSH
62979: LD_VAR 0 1
62983: ARRAY
62984: ST_TO_ADDR
// if onlyCombat then
62985: LD_VAR 0 2
62989: IFFALSE 63161
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
62991: LD_ADDR_VAR 0 3
62995: PUSH
62996: LD_VAR 0 3
63000: PUSH
63001: LD_VAR 0 3
63005: PPUSH
63006: LD_INT 2
63008: PUSH
63009: LD_INT 34
63011: PUSH
63012: LD_INT 12
63014: PUSH
63015: EMPTY
63016: LIST
63017: LIST
63018: PUSH
63019: LD_INT 34
63021: PUSH
63022: LD_INT 51
63024: PUSH
63025: EMPTY
63026: LIST
63027: LIST
63028: PUSH
63029: LD_INT 34
63031: PUSH
63032: LD_INT 89
63034: PUSH
63035: EMPTY
63036: LIST
63037: LIST
63038: PUSH
63039: LD_INT 34
63041: PUSH
63042: LD_INT 32
63044: PUSH
63045: EMPTY
63046: LIST
63047: LIST
63048: PUSH
63049: LD_INT 34
63051: PUSH
63052: LD_INT 13
63054: PUSH
63055: EMPTY
63056: LIST
63057: LIST
63058: PUSH
63059: LD_INT 34
63061: PUSH
63062: LD_INT 52
63064: PUSH
63065: EMPTY
63066: LIST
63067: LIST
63068: PUSH
63069: LD_INT 34
63071: PUSH
63072: LD_INT 88
63074: PUSH
63075: EMPTY
63076: LIST
63077: LIST
63078: PUSH
63079: LD_INT 34
63081: PUSH
63082: LD_INT 14
63084: PUSH
63085: EMPTY
63086: LIST
63087: LIST
63088: PUSH
63089: LD_INT 34
63091: PUSH
63092: LD_INT 53
63094: PUSH
63095: EMPTY
63096: LIST
63097: LIST
63098: PUSH
63099: LD_INT 34
63101: PUSH
63102: LD_INT 98
63104: PUSH
63105: EMPTY
63106: LIST
63107: LIST
63108: PUSH
63109: LD_INT 34
63111: PUSH
63112: LD_INT 31
63114: PUSH
63115: EMPTY
63116: LIST
63117: LIST
63118: PUSH
63119: LD_INT 34
63121: PUSH
63122: LD_INT 48
63124: PUSH
63125: EMPTY
63126: LIST
63127: LIST
63128: PUSH
63129: LD_INT 34
63131: PUSH
63132: LD_INT 8
63134: PUSH
63135: EMPTY
63136: LIST
63137: LIST
63138: PUSH
63139: EMPTY
63140: LIST
63141: LIST
63142: LIST
63143: LIST
63144: LIST
63145: LIST
63146: LIST
63147: LIST
63148: LIST
63149: LIST
63150: LIST
63151: LIST
63152: LIST
63153: LIST
63154: PPUSH
63155: CALL_OW 72
63159: DIFF
63160: ST_TO_ADDR
// end ; end_of_file
63161: LD_VAR 0 3
63165: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
63166: LD_INT 0
63168: PPUSH
63169: PPUSH
63170: PPUSH
// if not mc_bases or not skirmish then
63171: LD_EXP 100
63175: NOT
63176: PUSH
63177: LD_EXP 98
63181: NOT
63182: OR
63183: IFFALSE 63187
// exit ;
63185: GO 63352
// for i = 1 to mc_bases do
63187: LD_ADDR_VAR 0 4
63191: PUSH
63192: DOUBLE
63193: LD_INT 1
63195: DEC
63196: ST_TO_ADDR
63197: LD_EXP 100
63201: PUSH
63202: FOR_TO
63203: IFFALSE 63350
// begin if sci in mc_bases [ i ] then
63205: LD_VAR 0 2
63209: PUSH
63210: LD_EXP 100
63214: PUSH
63215: LD_VAR 0 4
63219: ARRAY
63220: IN
63221: IFFALSE 63348
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
63223: LD_ADDR_EXP 129
63227: PUSH
63228: LD_EXP 129
63232: PPUSH
63233: LD_VAR 0 4
63237: PUSH
63238: LD_EXP 129
63242: PUSH
63243: LD_VAR 0 4
63247: ARRAY
63248: PUSH
63249: LD_INT 1
63251: PLUS
63252: PUSH
63253: EMPTY
63254: LIST
63255: LIST
63256: PPUSH
63257: LD_VAR 0 1
63261: PPUSH
63262: CALL 72936 0 3
63266: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
63267: LD_ADDR_VAR 0 5
63271: PUSH
63272: LD_EXP 100
63276: PUSH
63277: LD_VAR 0 4
63281: ARRAY
63282: PPUSH
63283: LD_INT 2
63285: PUSH
63286: LD_INT 30
63288: PUSH
63289: LD_INT 0
63291: PUSH
63292: EMPTY
63293: LIST
63294: LIST
63295: PUSH
63296: LD_INT 30
63298: PUSH
63299: LD_INT 1
63301: PUSH
63302: EMPTY
63303: LIST
63304: LIST
63305: PUSH
63306: EMPTY
63307: LIST
63308: LIST
63309: LIST
63310: PPUSH
63311: CALL_OW 72
63315: PPUSH
63316: LD_VAR 0 1
63320: PPUSH
63321: CALL_OW 74
63325: ST_TO_ADDR
// if tmp then
63326: LD_VAR 0 5
63330: IFFALSE 63346
// ComStandNearbyBuilding ( ape , tmp ) ;
63332: LD_VAR 0 1
63336: PPUSH
63337: LD_VAR 0 5
63341: PPUSH
63342: CALL 69538 0 2
// break ;
63346: GO 63350
// end ; end ;
63348: GO 63202
63350: POP
63351: POP
// end ;
63352: LD_VAR 0 3
63356: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
63357: LD_INT 0
63359: PPUSH
63360: PPUSH
63361: PPUSH
// if not mc_bases or not skirmish then
63362: LD_EXP 100
63366: NOT
63367: PUSH
63368: LD_EXP 98
63372: NOT
63373: OR
63374: IFFALSE 63378
// exit ;
63376: GO 63467
// for i = 1 to mc_bases do
63378: LD_ADDR_VAR 0 4
63382: PUSH
63383: DOUBLE
63384: LD_INT 1
63386: DEC
63387: ST_TO_ADDR
63388: LD_EXP 100
63392: PUSH
63393: FOR_TO
63394: IFFALSE 63465
// begin if building in mc_busy_turret_list [ i ] then
63396: LD_VAR 0 1
63400: PUSH
63401: LD_EXP 110
63405: PUSH
63406: LD_VAR 0 4
63410: ARRAY
63411: IN
63412: IFFALSE 63463
// begin tmp := mc_busy_turret_list [ i ] diff building ;
63414: LD_ADDR_VAR 0 5
63418: PUSH
63419: LD_EXP 110
63423: PUSH
63424: LD_VAR 0 4
63428: ARRAY
63429: PUSH
63430: LD_VAR 0 1
63434: DIFF
63435: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
63436: LD_ADDR_EXP 110
63440: PUSH
63441: LD_EXP 110
63445: PPUSH
63446: LD_VAR 0 4
63450: PPUSH
63451: LD_VAR 0 5
63455: PPUSH
63456: CALL_OW 1
63460: ST_TO_ADDR
// break ;
63461: GO 63465
// end ; end ;
63463: GO 63393
63465: POP
63466: POP
// end ;
63467: LD_VAR 0 3
63471: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
63472: LD_INT 0
63474: PPUSH
63475: PPUSH
63476: PPUSH
// if not mc_bases or not skirmish then
63477: LD_EXP 100
63481: NOT
63482: PUSH
63483: LD_EXP 98
63487: NOT
63488: OR
63489: IFFALSE 63493
// exit ;
63491: GO 63692
// for i = 1 to mc_bases do
63493: LD_ADDR_VAR 0 5
63497: PUSH
63498: DOUBLE
63499: LD_INT 1
63501: DEC
63502: ST_TO_ADDR
63503: LD_EXP 100
63507: PUSH
63508: FOR_TO
63509: IFFALSE 63690
// if building in mc_bases [ i ] then
63511: LD_VAR 0 1
63515: PUSH
63516: LD_EXP 100
63520: PUSH
63521: LD_VAR 0 5
63525: ARRAY
63526: IN
63527: IFFALSE 63688
// begin tmp := mc_bases [ i ] diff building ;
63529: LD_ADDR_VAR 0 6
63533: PUSH
63534: LD_EXP 100
63538: PUSH
63539: LD_VAR 0 5
63543: ARRAY
63544: PUSH
63545: LD_VAR 0 1
63549: DIFF
63550: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
63551: LD_ADDR_EXP 100
63555: PUSH
63556: LD_EXP 100
63560: PPUSH
63561: LD_VAR 0 5
63565: PPUSH
63566: LD_VAR 0 6
63570: PPUSH
63571: CALL_OW 1
63575: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
63576: LD_VAR 0 1
63580: PUSH
63581: LD_EXP 108
63585: PUSH
63586: LD_VAR 0 5
63590: ARRAY
63591: IN
63592: IFFALSE 63631
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
63594: LD_ADDR_EXP 108
63598: PUSH
63599: LD_EXP 108
63603: PPUSH
63604: LD_VAR 0 5
63608: PPUSH
63609: LD_EXP 108
63613: PUSH
63614: LD_VAR 0 5
63618: ARRAY
63619: PUSH
63620: LD_VAR 0 1
63624: DIFF
63625: PPUSH
63626: CALL_OW 1
63630: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
63631: LD_VAR 0 1
63635: PUSH
63636: LD_EXP 109
63640: PUSH
63641: LD_VAR 0 5
63645: ARRAY
63646: IN
63647: IFFALSE 63686
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
63649: LD_ADDR_EXP 109
63653: PUSH
63654: LD_EXP 109
63658: PPUSH
63659: LD_VAR 0 5
63663: PPUSH
63664: LD_EXP 109
63668: PUSH
63669: LD_VAR 0 5
63673: ARRAY
63674: PUSH
63675: LD_VAR 0 1
63679: DIFF
63680: PPUSH
63681: CALL_OW 1
63685: ST_TO_ADDR
// break ;
63686: GO 63690
// end ;
63688: GO 63508
63690: POP
63691: POP
// end ;
63692: LD_VAR 0 4
63696: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
63697: LD_INT 0
63699: PPUSH
63700: PPUSH
63701: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
63702: LD_EXP 100
63706: NOT
63707: PUSH
63708: LD_EXP 98
63712: NOT
63713: OR
63714: PUSH
63715: LD_VAR 0 3
63719: PUSH
63720: LD_EXP 126
63724: IN
63725: NOT
63726: OR
63727: IFFALSE 63731
// exit ;
63729: GO 63854
// for i = 1 to mc_vehicles do
63731: LD_ADDR_VAR 0 6
63735: PUSH
63736: DOUBLE
63737: LD_INT 1
63739: DEC
63740: ST_TO_ADDR
63741: LD_EXP 119
63745: PUSH
63746: FOR_TO
63747: IFFALSE 63852
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
63749: LD_VAR 0 2
63753: PUSH
63754: LD_EXP 119
63758: PUSH
63759: LD_VAR 0 6
63763: ARRAY
63764: IN
63765: PUSH
63766: LD_VAR 0 1
63770: PUSH
63771: LD_EXP 119
63775: PUSH
63776: LD_VAR 0 6
63780: ARRAY
63781: IN
63782: OR
63783: IFFALSE 63850
// begin tmp := mc_vehicles [ i ] diff old ;
63785: LD_ADDR_VAR 0 7
63789: PUSH
63790: LD_EXP 119
63794: PUSH
63795: LD_VAR 0 6
63799: ARRAY
63800: PUSH
63801: LD_VAR 0 2
63805: DIFF
63806: ST_TO_ADDR
// tmp := tmp diff new ;
63807: LD_ADDR_VAR 0 7
63811: PUSH
63812: LD_VAR 0 7
63816: PUSH
63817: LD_VAR 0 1
63821: DIFF
63822: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
63823: LD_ADDR_EXP 119
63827: PUSH
63828: LD_EXP 119
63832: PPUSH
63833: LD_VAR 0 6
63837: PPUSH
63838: LD_VAR 0 7
63842: PPUSH
63843: CALL_OW 1
63847: ST_TO_ADDR
// break ;
63848: GO 63852
// end ;
63850: GO 63746
63852: POP
63853: POP
// end ;
63854: LD_VAR 0 5
63858: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
63859: LD_INT 0
63861: PPUSH
63862: PPUSH
63863: PPUSH
63864: PPUSH
// if not mc_bases or not skirmish then
63865: LD_EXP 100
63869: NOT
63870: PUSH
63871: LD_EXP 98
63875: NOT
63876: OR
63877: IFFALSE 63881
// exit ;
63879: GO 64301
// repeat wait ( 0 0$1 ) ;
63881: LD_INT 35
63883: PPUSH
63884: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
63888: LD_EXP 144
63892: NOT
63893: IFFALSE 63881
// mc_block_vehicle_constructed_thread := true ;
63895: LD_ADDR_EXP 144
63899: PUSH
63900: LD_INT 1
63902: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
63903: LD_ADDR_VAR 0 5
63907: PUSH
63908: LD_VAR 0 1
63912: PPUSH
63913: CALL_OW 255
63917: ST_TO_ADDR
// for i = 1 to mc_bases do
63918: LD_ADDR_VAR 0 4
63922: PUSH
63923: DOUBLE
63924: LD_INT 1
63926: DEC
63927: ST_TO_ADDR
63928: LD_EXP 100
63932: PUSH
63933: FOR_TO
63934: IFFALSE 64291
// begin if factory in mc_bases [ i ] then
63936: LD_VAR 0 2
63940: PUSH
63941: LD_EXP 100
63945: PUSH
63946: LD_VAR 0 4
63950: ARRAY
63951: IN
63952: IFFALSE 64289
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
63954: LD_EXP 122
63958: PUSH
63959: LD_VAR 0 4
63963: ARRAY
63964: PUSH
63965: LD_EXP 111
63969: PUSH
63970: LD_VAR 0 4
63974: ARRAY
63975: LESS
63976: PUSH
63977: LD_VAR 0 1
63981: PPUSH
63982: CALL_OW 264
63986: PUSH
63987: LD_INT 31
63989: PUSH
63990: LD_INT 32
63992: PUSH
63993: LD_INT 51
63995: PUSH
63996: LD_INT 89
63998: PUSH
63999: LD_INT 12
64001: PUSH
64002: LD_INT 30
64004: PUSH
64005: LD_INT 98
64007: PUSH
64008: LD_INT 11
64010: PUSH
64011: LD_INT 53
64013: PUSH
64014: LD_INT 14
64016: PUSH
64017: LD_INT 91
64019: PUSH
64020: LD_INT 29
64022: PUSH
64023: LD_INT 99
64025: PUSH
64026: LD_INT 13
64028: PUSH
64029: LD_INT 52
64031: PUSH
64032: LD_INT 88
64034: PUSH
64035: LD_INT 48
64037: PUSH
64038: LD_INT 8
64040: PUSH
64041: EMPTY
64042: LIST
64043: LIST
64044: LIST
64045: LIST
64046: LIST
64047: LIST
64048: LIST
64049: LIST
64050: LIST
64051: LIST
64052: LIST
64053: LIST
64054: LIST
64055: LIST
64056: LIST
64057: LIST
64058: LIST
64059: LIST
64060: IN
64061: NOT
64062: AND
64063: IFFALSE 64111
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
64065: LD_ADDR_EXP 122
64069: PUSH
64070: LD_EXP 122
64074: PPUSH
64075: LD_VAR 0 4
64079: PUSH
64080: LD_EXP 122
64084: PUSH
64085: LD_VAR 0 4
64089: ARRAY
64090: PUSH
64091: LD_INT 1
64093: PLUS
64094: PUSH
64095: EMPTY
64096: LIST
64097: LIST
64098: PPUSH
64099: LD_VAR 0 1
64103: PPUSH
64104: CALL 72936 0 3
64108: ST_TO_ADDR
64109: GO 64155
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
64111: LD_ADDR_EXP 119
64115: PUSH
64116: LD_EXP 119
64120: PPUSH
64121: LD_VAR 0 4
64125: PUSH
64126: LD_EXP 119
64130: PUSH
64131: LD_VAR 0 4
64135: ARRAY
64136: PUSH
64137: LD_INT 1
64139: PLUS
64140: PUSH
64141: EMPTY
64142: LIST
64143: LIST
64144: PPUSH
64145: LD_VAR 0 1
64149: PPUSH
64150: CALL 72936 0 3
64154: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
64155: LD_ADDR_EXP 144
64159: PUSH
64160: LD_INT 0
64162: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
64163: LD_VAR 0 1
64167: PPUSH
64168: CALL_OW 263
64172: PUSH
64173: LD_INT 2
64175: EQUAL
64176: IFFALSE 64205
// begin repeat wait ( 0 0$3 ) ;
64178: LD_INT 105
64180: PPUSH
64181: CALL_OW 67
// Connect ( vehicle ) ;
64185: LD_VAR 0 1
64189: PPUSH
64190: CALL 75905 0 1
// until IsControledBy ( vehicle ) ;
64194: LD_VAR 0 1
64198: PPUSH
64199: CALL_OW 312
64203: IFFALSE 64178
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
64205: LD_VAR 0 1
64209: PPUSH
64210: LD_EXP 124
64214: PUSH
64215: LD_VAR 0 4
64219: ARRAY
64220: PPUSH
64221: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
64225: LD_VAR 0 1
64229: PPUSH
64230: CALL_OW 263
64234: PUSH
64235: LD_INT 1
64237: NONEQUAL
64238: IFFALSE 64242
// break ;
64240: GO 64291
// repeat wait ( 0 0$1 ) ;
64242: LD_INT 35
64244: PPUSH
64245: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
64249: LD_VAR 0 1
64253: PPUSH
64254: LD_EXP 124
64258: PUSH
64259: LD_VAR 0 4
64263: ARRAY
64264: PPUSH
64265: CALL_OW 308
64269: IFFALSE 64242
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
64271: LD_VAR 0 1
64275: PPUSH
64276: CALL_OW 311
64280: PPUSH
64281: CALL_OW 121
// exit ;
64285: POP
64286: POP
64287: GO 64301
// end ; end ;
64289: GO 63933
64291: POP
64292: POP
// mc_block_vehicle_constructed_thread := false ;
64293: LD_ADDR_EXP 144
64297: PUSH
64298: LD_INT 0
64300: ST_TO_ADDR
// end ;
64301: LD_VAR 0 3
64305: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
64306: LD_INT 0
64308: PPUSH
64309: PPUSH
64310: PPUSH
64311: PPUSH
// if not mc_bases or not skirmish then
64312: LD_EXP 100
64316: NOT
64317: PUSH
64318: LD_EXP 98
64322: NOT
64323: OR
64324: IFFALSE 64328
// exit ;
64326: GO 64681
// repeat wait ( 0 0$1 ) ;
64328: LD_INT 35
64330: PPUSH
64331: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
64335: LD_VAR 0 2
64339: PPUSH
64340: LD_VAR 0 3
64344: PPUSH
64345: CALL_OW 284
64349: IFFALSE 64328
// if GetResourceTypeXY ( x , y ) = mat_artefact then
64351: LD_VAR 0 2
64355: PPUSH
64356: LD_VAR 0 3
64360: PPUSH
64361: CALL_OW 283
64365: PUSH
64366: LD_INT 4
64368: EQUAL
64369: IFFALSE 64373
// exit ;
64371: GO 64681
// for i = 1 to mc_bases do
64373: LD_ADDR_VAR 0 7
64377: PUSH
64378: DOUBLE
64379: LD_INT 1
64381: DEC
64382: ST_TO_ADDR
64383: LD_EXP 100
64387: PUSH
64388: FOR_TO
64389: IFFALSE 64679
// begin if mc_crates_area [ i ] then
64391: LD_EXP 118
64395: PUSH
64396: LD_VAR 0 7
64400: ARRAY
64401: IFFALSE 64512
// for j in mc_crates_area [ i ] do
64403: LD_ADDR_VAR 0 8
64407: PUSH
64408: LD_EXP 118
64412: PUSH
64413: LD_VAR 0 7
64417: ARRAY
64418: PUSH
64419: FOR_IN
64420: IFFALSE 64510
// if InArea ( x , y , j ) then
64422: LD_VAR 0 2
64426: PPUSH
64427: LD_VAR 0 3
64431: PPUSH
64432: LD_VAR 0 8
64436: PPUSH
64437: CALL_OW 309
64441: IFFALSE 64508
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
64443: LD_ADDR_EXP 116
64447: PUSH
64448: LD_EXP 116
64452: PPUSH
64453: LD_VAR 0 7
64457: PUSH
64458: LD_EXP 116
64462: PUSH
64463: LD_VAR 0 7
64467: ARRAY
64468: PUSH
64469: LD_INT 1
64471: PLUS
64472: PUSH
64473: EMPTY
64474: LIST
64475: LIST
64476: PPUSH
64477: LD_VAR 0 4
64481: PUSH
64482: LD_VAR 0 2
64486: PUSH
64487: LD_VAR 0 3
64491: PUSH
64492: EMPTY
64493: LIST
64494: LIST
64495: LIST
64496: PPUSH
64497: CALL 72936 0 3
64501: ST_TO_ADDR
// exit ;
64502: POP
64503: POP
64504: POP
64505: POP
64506: GO 64681
// end ;
64508: GO 64419
64510: POP
64511: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64512: LD_ADDR_VAR 0 9
64516: PUSH
64517: LD_EXP 100
64521: PUSH
64522: LD_VAR 0 7
64526: ARRAY
64527: PPUSH
64528: LD_INT 2
64530: PUSH
64531: LD_INT 30
64533: PUSH
64534: LD_INT 0
64536: PUSH
64537: EMPTY
64538: LIST
64539: LIST
64540: PUSH
64541: LD_INT 30
64543: PUSH
64544: LD_INT 1
64546: PUSH
64547: EMPTY
64548: LIST
64549: LIST
64550: PUSH
64551: EMPTY
64552: LIST
64553: LIST
64554: LIST
64555: PPUSH
64556: CALL_OW 72
64560: ST_TO_ADDR
// if not depot then
64561: LD_VAR 0 9
64565: NOT
64566: IFFALSE 64570
// continue ;
64568: GO 64388
// for j in depot do
64570: LD_ADDR_VAR 0 8
64574: PUSH
64575: LD_VAR 0 9
64579: PUSH
64580: FOR_IN
64581: IFFALSE 64675
// if GetDistUnitXY ( j , x , y ) < 30 then
64583: LD_VAR 0 8
64587: PPUSH
64588: LD_VAR 0 2
64592: PPUSH
64593: LD_VAR 0 3
64597: PPUSH
64598: CALL_OW 297
64602: PUSH
64603: LD_INT 30
64605: LESS
64606: IFFALSE 64673
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
64608: LD_ADDR_EXP 116
64612: PUSH
64613: LD_EXP 116
64617: PPUSH
64618: LD_VAR 0 7
64622: PUSH
64623: LD_EXP 116
64627: PUSH
64628: LD_VAR 0 7
64632: ARRAY
64633: PUSH
64634: LD_INT 1
64636: PLUS
64637: PUSH
64638: EMPTY
64639: LIST
64640: LIST
64641: PPUSH
64642: LD_VAR 0 4
64646: PUSH
64647: LD_VAR 0 2
64651: PUSH
64652: LD_VAR 0 3
64656: PUSH
64657: EMPTY
64658: LIST
64659: LIST
64660: LIST
64661: PPUSH
64662: CALL 72936 0 3
64666: ST_TO_ADDR
// exit ;
64667: POP
64668: POP
64669: POP
64670: POP
64671: GO 64681
// end ;
64673: GO 64580
64675: POP
64676: POP
// end ;
64677: GO 64388
64679: POP
64680: POP
// end ;
64681: LD_VAR 0 6
64685: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
64686: LD_INT 0
64688: PPUSH
64689: PPUSH
64690: PPUSH
64691: PPUSH
// if not mc_bases or not skirmish then
64692: LD_EXP 100
64696: NOT
64697: PUSH
64698: LD_EXP 98
64702: NOT
64703: OR
64704: IFFALSE 64708
// exit ;
64706: GO 64985
// side := GetSide ( lab ) ;
64708: LD_ADDR_VAR 0 4
64712: PUSH
64713: LD_VAR 0 2
64717: PPUSH
64718: CALL_OW 255
64722: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
64723: LD_VAR 0 4
64727: PUSH
64728: LD_EXP 126
64732: IN
64733: NOT
64734: PUSH
64735: LD_EXP 127
64739: NOT
64740: OR
64741: PUSH
64742: LD_EXP 100
64746: NOT
64747: OR
64748: IFFALSE 64752
// exit ;
64750: GO 64985
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
64752: LD_ADDR_EXP 127
64756: PUSH
64757: LD_EXP 127
64761: PPUSH
64762: LD_VAR 0 4
64766: PPUSH
64767: LD_EXP 127
64771: PUSH
64772: LD_VAR 0 4
64776: ARRAY
64777: PUSH
64778: LD_VAR 0 1
64782: DIFF
64783: PPUSH
64784: CALL_OW 1
64788: ST_TO_ADDR
// for i = 1 to mc_bases do
64789: LD_ADDR_VAR 0 5
64793: PUSH
64794: DOUBLE
64795: LD_INT 1
64797: DEC
64798: ST_TO_ADDR
64799: LD_EXP 100
64803: PUSH
64804: FOR_TO
64805: IFFALSE 64983
// begin if lab in mc_bases [ i ] then
64807: LD_VAR 0 2
64811: PUSH
64812: LD_EXP 100
64816: PUSH
64817: LD_VAR 0 5
64821: ARRAY
64822: IN
64823: IFFALSE 64981
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
64825: LD_VAR 0 1
64829: PUSH
64830: LD_INT 11
64832: PUSH
64833: LD_INT 4
64835: PUSH
64836: LD_INT 3
64838: PUSH
64839: LD_INT 2
64841: PUSH
64842: EMPTY
64843: LIST
64844: LIST
64845: LIST
64846: LIST
64847: IN
64848: PUSH
64849: LD_EXP 130
64853: PUSH
64854: LD_VAR 0 5
64858: ARRAY
64859: AND
64860: IFFALSE 64981
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
64862: LD_ADDR_VAR 0 6
64866: PUSH
64867: LD_EXP 130
64871: PUSH
64872: LD_VAR 0 5
64876: ARRAY
64877: PUSH
64878: LD_INT 1
64880: ARRAY
64881: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64882: LD_ADDR_EXP 130
64886: PUSH
64887: LD_EXP 130
64891: PPUSH
64892: LD_VAR 0 5
64896: PPUSH
64897: EMPTY
64898: PPUSH
64899: CALL_OW 1
64903: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
64904: LD_VAR 0 6
64908: PPUSH
64909: LD_INT 0
64911: PPUSH
64912: CALL_OW 109
// ComExitBuilding ( tmp ) ;
64916: LD_VAR 0 6
64920: PPUSH
64921: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
64925: LD_ADDR_EXP 129
64929: PUSH
64930: LD_EXP 129
64934: PPUSH
64935: LD_VAR 0 5
64939: PPUSH
64940: LD_EXP 129
64944: PUSH
64945: LD_VAR 0 5
64949: ARRAY
64950: PPUSH
64951: LD_INT 1
64953: PPUSH
64954: LD_VAR 0 6
64958: PPUSH
64959: CALL_OW 2
64963: PPUSH
64964: CALL_OW 1
64968: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
64969: LD_VAR 0 5
64973: PPUSH
64974: LD_INT 112
64976: PPUSH
64977: CALL 41449 0 2
// end ; end ; end ;
64981: GO 64804
64983: POP
64984: POP
// end ;
64985: LD_VAR 0 3
64989: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
64990: LD_INT 0
64992: PPUSH
64993: PPUSH
64994: PPUSH
64995: PPUSH
64996: PPUSH
64997: PPUSH
64998: PPUSH
64999: PPUSH
// if not mc_bases or not skirmish then
65000: LD_EXP 100
65004: NOT
65005: PUSH
65006: LD_EXP 98
65010: NOT
65011: OR
65012: IFFALSE 65016
// exit ;
65014: GO 66385
// for i = 1 to mc_bases do
65016: LD_ADDR_VAR 0 3
65020: PUSH
65021: DOUBLE
65022: LD_INT 1
65024: DEC
65025: ST_TO_ADDR
65026: LD_EXP 100
65030: PUSH
65031: FOR_TO
65032: IFFALSE 66383
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
65034: LD_VAR 0 1
65038: PUSH
65039: LD_EXP 100
65043: PUSH
65044: LD_VAR 0 3
65048: ARRAY
65049: IN
65050: PUSH
65051: LD_VAR 0 1
65055: PUSH
65056: LD_EXP 107
65060: PUSH
65061: LD_VAR 0 3
65065: ARRAY
65066: IN
65067: OR
65068: PUSH
65069: LD_VAR 0 1
65073: PUSH
65074: LD_EXP 122
65078: PUSH
65079: LD_VAR 0 3
65083: ARRAY
65084: IN
65085: OR
65086: PUSH
65087: LD_VAR 0 1
65091: PUSH
65092: LD_EXP 119
65096: PUSH
65097: LD_VAR 0 3
65101: ARRAY
65102: IN
65103: OR
65104: PUSH
65105: LD_VAR 0 1
65109: PUSH
65110: LD_EXP 129
65114: PUSH
65115: LD_VAR 0 3
65119: ARRAY
65120: IN
65121: OR
65122: PUSH
65123: LD_VAR 0 1
65127: PUSH
65128: LD_EXP 130
65132: PUSH
65133: LD_VAR 0 3
65137: ARRAY
65138: IN
65139: OR
65140: IFFALSE 66381
// begin if un in mc_ape [ i ] then
65142: LD_VAR 0 1
65146: PUSH
65147: LD_EXP 129
65151: PUSH
65152: LD_VAR 0 3
65156: ARRAY
65157: IN
65158: IFFALSE 65197
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
65160: LD_ADDR_EXP 129
65164: PUSH
65165: LD_EXP 129
65169: PPUSH
65170: LD_VAR 0 3
65174: PPUSH
65175: LD_EXP 129
65179: PUSH
65180: LD_VAR 0 3
65184: ARRAY
65185: PUSH
65186: LD_VAR 0 1
65190: DIFF
65191: PPUSH
65192: CALL_OW 1
65196: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
65197: LD_VAR 0 1
65201: PUSH
65202: LD_EXP 130
65206: PUSH
65207: LD_VAR 0 3
65211: ARRAY
65212: IN
65213: IFFALSE 65237
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
65215: LD_ADDR_EXP 130
65219: PUSH
65220: LD_EXP 130
65224: PPUSH
65225: LD_VAR 0 3
65229: PPUSH
65230: EMPTY
65231: PPUSH
65232: CALL_OW 1
65236: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
65237: LD_VAR 0 1
65241: PPUSH
65242: CALL_OW 247
65246: PUSH
65247: LD_INT 2
65249: EQUAL
65250: PUSH
65251: LD_VAR 0 1
65255: PPUSH
65256: CALL_OW 110
65260: PUSH
65261: LD_INT 20
65263: EQUAL
65264: PUSH
65265: LD_VAR 0 1
65269: PUSH
65270: LD_EXP 122
65274: PUSH
65275: LD_VAR 0 3
65279: ARRAY
65280: IN
65281: OR
65282: PUSH
65283: LD_VAR 0 1
65287: PPUSH
65288: CALL_OW 264
65292: PUSH
65293: LD_INT 12
65295: PUSH
65296: LD_INT 51
65298: PUSH
65299: LD_INT 89
65301: PUSH
65302: LD_INT 32
65304: PUSH
65305: LD_INT 13
65307: PUSH
65308: LD_INT 52
65310: PUSH
65311: LD_INT 31
65313: PUSH
65314: EMPTY
65315: LIST
65316: LIST
65317: LIST
65318: LIST
65319: LIST
65320: LIST
65321: LIST
65322: IN
65323: OR
65324: AND
65325: IFFALSE 65633
// begin if un in mc_defender [ i ] then
65327: LD_VAR 0 1
65331: PUSH
65332: LD_EXP 122
65336: PUSH
65337: LD_VAR 0 3
65341: ARRAY
65342: IN
65343: IFFALSE 65382
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
65345: LD_ADDR_EXP 122
65349: PUSH
65350: LD_EXP 122
65354: PPUSH
65355: LD_VAR 0 3
65359: PPUSH
65360: LD_EXP 122
65364: PUSH
65365: LD_VAR 0 3
65369: ARRAY
65370: PUSH
65371: LD_VAR 0 1
65375: DIFF
65376: PPUSH
65377: CALL_OW 1
65381: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
65382: LD_ADDR_VAR 0 8
65386: PUSH
65387: LD_VAR 0 3
65391: PPUSH
65392: LD_INT 3
65394: PPUSH
65395: CALL 62003 0 2
65399: ST_TO_ADDR
// if fac then
65400: LD_VAR 0 8
65404: IFFALSE 65633
// begin for j in fac do
65406: LD_ADDR_VAR 0 4
65410: PUSH
65411: LD_VAR 0 8
65415: PUSH
65416: FOR_IN
65417: IFFALSE 65631
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
65419: LD_ADDR_VAR 0 9
65423: PUSH
65424: LD_VAR 0 8
65428: PPUSH
65429: LD_VAR 0 1
65433: PPUSH
65434: CALL_OW 265
65438: PPUSH
65439: LD_VAR 0 1
65443: PPUSH
65444: CALL_OW 262
65448: PPUSH
65449: LD_VAR 0 1
65453: PPUSH
65454: CALL_OW 263
65458: PPUSH
65459: LD_VAR 0 1
65463: PPUSH
65464: CALL_OW 264
65468: PPUSH
65469: CALL 70434 0 5
65473: ST_TO_ADDR
// if components then
65474: LD_VAR 0 9
65478: IFFALSE 65629
// begin if GetWeapon ( un ) = ar_control_tower then
65480: LD_VAR 0 1
65484: PPUSH
65485: CALL_OW 264
65489: PUSH
65490: LD_INT 31
65492: EQUAL
65493: IFFALSE 65610
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
65495: LD_VAR 0 1
65499: PPUSH
65500: CALL_OW 311
65504: PPUSH
65505: LD_INT 0
65507: PPUSH
65508: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
65512: LD_ADDR_EXP 140
65516: PUSH
65517: LD_EXP 140
65521: PPUSH
65522: LD_VAR 0 3
65526: PPUSH
65527: LD_EXP 140
65531: PUSH
65532: LD_VAR 0 3
65536: ARRAY
65537: PUSH
65538: LD_VAR 0 1
65542: PPUSH
65543: CALL_OW 311
65547: DIFF
65548: PPUSH
65549: CALL_OW 1
65553: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
65554: LD_ADDR_VAR 0 7
65558: PUSH
65559: LD_EXP 121
65563: PUSH
65564: LD_VAR 0 3
65568: ARRAY
65569: PPUSH
65570: LD_INT 1
65572: PPUSH
65573: LD_VAR 0 9
65577: PPUSH
65578: CALL_OW 2
65582: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
65583: LD_ADDR_EXP 121
65587: PUSH
65588: LD_EXP 121
65592: PPUSH
65593: LD_VAR 0 3
65597: PPUSH
65598: LD_VAR 0 7
65602: PPUSH
65603: CALL_OW 1
65607: ST_TO_ADDR
// end else
65608: GO 65627
// MC_InsertProduceList ( i , [ components ] ) ;
65610: LD_VAR 0 3
65614: PPUSH
65615: LD_VAR 0 9
65619: PUSH
65620: EMPTY
65621: LIST
65622: PPUSH
65623: CALL 61548 0 2
// break ;
65627: GO 65631
// end ; end ;
65629: GO 65416
65631: POP
65632: POP
// end ; end ; if GetType ( un ) = unit_building then
65633: LD_VAR 0 1
65637: PPUSH
65638: CALL_OW 247
65642: PUSH
65643: LD_INT 3
65645: EQUAL
65646: IFFALSE 66049
// begin btype := GetBType ( un ) ;
65648: LD_ADDR_VAR 0 5
65652: PUSH
65653: LD_VAR 0 1
65657: PPUSH
65658: CALL_OW 266
65662: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
65663: LD_VAR 0 5
65667: PUSH
65668: LD_INT 29
65670: PUSH
65671: LD_INT 30
65673: PUSH
65674: EMPTY
65675: LIST
65676: LIST
65677: IN
65678: IFFALSE 65751
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
65680: LD_VAR 0 1
65684: PPUSH
65685: CALL_OW 250
65689: PPUSH
65690: LD_VAR 0 1
65694: PPUSH
65695: CALL_OW 251
65699: PPUSH
65700: LD_VAR 0 1
65704: PPUSH
65705: CALL_OW 255
65709: PPUSH
65710: CALL_OW 440
65714: NOT
65715: IFFALSE 65751
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
65717: LD_VAR 0 1
65721: PPUSH
65722: CALL_OW 250
65726: PPUSH
65727: LD_VAR 0 1
65731: PPUSH
65732: CALL_OW 251
65736: PPUSH
65737: LD_VAR 0 1
65741: PPUSH
65742: CALL_OW 255
65746: PPUSH
65747: CALL_OW 441
// end ; if btype = b_warehouse then
65751: LD_VAR 0 5
65755: PUSH
65756: LD_INT 1
65758: EQUAL
65759: IFFALSE 65777
// begin btype := b_depot ;
65761: LD_ADDR_VAR 0 5
65765: PUSH
65766: LD_INT 0
65768: ST_TO_ADDR
// pos := 1 ;
65769: LD_ADDR_VAR 0 6
65773: PUSH
65774: LD_INT 1
65776: ST_TO_ADDR
// end ; if btype = b_factory then
65777: LD_VAR 0 5
65781: PUSH
65782: LD_INT 3
65784: EQUAL
65785: IFFALSE 65803
// begin btype := b_workshop ;
65787: LD_ADDR_VAR 0 5
65791: PUSH
65792: LD_INT 2
65794: ST_TO_ADDR
// pos := 1 ;
65795: LD_ADDR_VAR 0 6
65799: PUSH
65800: LD_INT 1
65802: ST_TO_ADDR
// end ; if btype = b_barracks then
65803: LD_VAR 0 5
65807: PUSH
65808: LD_INT 5
65810: EQUAL
65811: IFFALSE 65821
// btype := b_armoury ;
65813: LD_ADDR_VAR 0 5
65817: PUSH
65818: LD_INT 4
65820: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
65821: LD_VAR 0 5
65825: PUSH
65826: LD_INT 7
65828: PUSH
65829: LD_INT 8
65831: PUSH
65832: EMPTY
65833: LIST
65834: LIST
65835: IN
65836: IFFALSE 65846
// btype := b_lab ;
65838: LD_ADDR_VAR 0 5
65842: PUSH
65843: LD_INT 6
65845: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
65846: LD_ADDR_EXP 105
65850: PUSH
65851: LD_EXP 105
65855: PPUSH
65856: LD_VAR 0 3
65860: PUSH
65861: LD_EXP 105
65865: PUSH
65866: LD_VAR 0 3
65870: ARRAY
65871: PUSH
65872: LD_INT 1
65874: PLUS
65875: PUSH
65876: EMPTY
65877: LIST
65878: LIST
65879: PPUSH
65880: LD_VAR 0 5
65884: PUSH
65885: LD_VAR 0 1
65889: PPUSH
65890: CALL_OW 250
65894: PUSH
65895: LD_VAR 0 1
65899: PPUSH
65900: CALL_OW 251
65904: PUSH
65905: LD_VAR 0 1
65909: PPUSH
65910: CALL_OW 254
65914: PUSH
65915: EMPTY
65916: LIST
65917: LIST
65918: LIST
65919: LIST
65920: PPUSH
65921: CALL 72936 0 3
65925: ST_TO_ADDR
// if pos = 1 then
65926: LD_VAR 0 6
65930: PUSH
65931: LD_INT 1
65933: EQUAL
65934: IFFALSE 66049
// begin tmp := mc_build_list [ i ] ;
65936: LD_ADDR_VAR 0 7
65940: PUSH
65941: LD_EXP 105
65945: PUSH
65946: LD_VAR 0 3
65950: ARRAY
65951: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
65952: LD_VAR 0 7
65956: PPUSH
65957: LD_INT 2
65959: PUSH
65960: LD_INT 30
65962: PUSH
65963: LD_INT 0
65965: PUSH
65966: EMPTY
65967: LIST
65968: LIST
65969: PUSH
65970: LD_INT 30
65972: PUSH
65973: LD_INT 1
65975: PUSH
65976: EMPTY
65977: LIST
65978: LIST
65979: PUSH
65980: EMPTY
65981: LIST
65982: LIST
65983: LIST
65984: PPUSH
65985: CALL_OW 72
65989: IFFALSE 65999
// pos := 2 ;
65991: LD_ADDR_VAR 0 6
65995: PUSH
65996: LD_INT 2
65998: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
65999: LD_ADDR_VAR 0 7
66003: PUSH
66004: LD_VAR 0 7
66008: PPUSH
66009: LD_VAR 0 6
66013: PPUSH
66014: LD_VAR 0 7
66018: PPUSH
66019: CALL 73262 0 3
66023: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
66024: LD_ADDR_EXP 105
66028: PUSH
66029: LD_EXP 105
66033: PPUSH
66034: LD_VAR 0 3
66038: PPUSH
66039: LD_VAR 0 7
66043: PPUSH
66044: CALL_OW 1
66048: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
66049: LD_VAR 0 1
66053: PUSH
66054: LD_EXP 100
66058: PUSH
66059: LD_VAR 0 3
66063: ARRAY
66064: IN
66065: IFFALSE 66104
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
66067: LD_ADDR_EXP 100
66071: PUSH
66072: LD_EXP 100
66076: PPUSH
66077: LD_VAR 0 3
66081: PPUSH
66082: LD_EXP 100
66086: PUSH
66087: LD_VAR 0 3
66091: ARRAY
66092: PUSH
66093: LD_VAR 0 1
66097: DIFF
66098: PPUSH
66099: CALL_OW 1
66103: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
66104: LD_VAR 0 1
66108: PUSH
66109: LD_EXP 107
66113: PUSH
66114: LD_VAR 0 3
66118: ARRAY
66119: IN
66120: IFFALSE 66159
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
66122: LD_ADDR_EXP 107
66126: PUSH
66127: LD_EXP 107
66131: PPUSH
66132: LD_VAR 0 3
66136: PPUSH
66137: LD_EXP 107
66141: PUSH
66142: LD_VAR 0 3
66146: ARRAY
66147: PUSH
66148: LD_VAR 0 1
66152: DIFF
66153: PPUSH
66154: CALL_OW 1
66158: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
66159: LD_VAR 0 1
66163: PUSH
66164: LD_EXP 119
66168: PUSH
66169: LD_VAR 0 3
66173: ARRAY
66174: IN
66175: IFFALSE 66214
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
66177: LD_ADDR_EXP 119
66181: PUSH
66182: LD_EXP 119
66186: PPUSH
66187: LD_VAR 0 3
66191: PPUSH
66192: LD_EXP 119
66196: PUSH
66197: LD_VAR 0 3
66201: ARRAY
66202: PUSH
66203: LD_VAR 0 1
66207: DIFF
66208: PPUSH
66209: CALL_OW 1
66213: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
66214: LD_VAR 0 1
66218: PUSH
66219: LD_EXP 122
66223: PUSH
66224: LD_VAR 0 3
66228: ARRAY
66229: IN
66230: IFFALSE 66269
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
66232: LD_ADDR_EXP 122
66236: PUSH
66237: LD_EXP 122
66241: PPUSH
66242: LD_VAR 0 3
66246: PPUSH
66247: LD_EXP 122
66251: PUSH
66252: LD_VAR 0 3
66256: ARRAY
66257: PUSH
66258: LD_VAR 0 1
66262: DIFF
66263: PPUSH
66264: CALL_OW 1
66268: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
66269: LD_VAR 0 1
66273: PUSH
66274: LD_EXP 109
66278: PUSH
66279: LD_VAR 0 3
66283: ARRAY
66284: IN
66285: IFFALSE 66324
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
66287: LD_ADDR_EXP 109
66291: PUSH
66292: LD_EXP 109
66296: PPUSH
66297: LD_VAR 0 3
66301: PPUSH
66302: LD_EXP 109
66306: PUSH
66307: LD_VAR 0 3
66311: ARRAY
66312: PUSH
66313: LD_VAR 0 1
66317: DIFF
66318: PPUSH
66319: CALL_OW 1
66323: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
66324: LD_VAR 0 1
66328: PUSH
66329: LD_EXP 108
66333: PUSH
66334: LD_VAR 0 3
66338: ARRAY
66339: IN
66340: IFFALSE 66379
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
66342: LD_ADDR_EXP 108
66346: PUSH
66347: LD_EXP 108
66351: PPUSH
66352: LD_VAR 0 3
66356: PPUSH
66357: LD_EXP 108
66361: PUSH
66362: LD_VAR 0 3
66366: ARRAY
66367: PUSH
66368: LD_VAR 0 1
66372: DIFF
66373: PPUSH
66374: CALL_OW 1
66378: ST_TO_ADDR
// end ; break ;
66379: GO 66383
// end ;
66381: GO 65031
66383: POP
66384: POP
// end ;
66385: LD_VAR 0 2
66389: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
66390: LD_INT 0
66392: PPUSH
66393: PPUSH
66394: PPUSH
// if not mc_bases or not skirmish then
66395: LD_EXP 100
66399: NOT
66400: PUSH
66401: LD_EXP 98
66405: NOT
66406: OR
66407: IFFALSE 66411
// exit ;
66409: GO 66626
// for i = 1 to mc_bases do
66411: LD_ADDR_VAR 0 3
66415: PUSH
66416: DOUBLE
66417: LD_INT 1
66419: DEC
66420: ST_TO_ADDR
66421: LD_EXP 100
66425: PUSH
66426: FOR_TO
66427: IFFALSE 66624
// begin if building in mc_construct_list [ i ] then
66429: LD_VAR 0 1
66433: PUSH
66434: LD_EXP 107
66438: PUSH
66439: LD_VAR 0 3
66443: ARRAY
66444: IN
66445: IFFALSE 66622
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
66447: LD_ADDR_EXP 107
66451: PUSH
66452: LD_EXP 107
66456: PPUSH
66457: LD_VAR 0 3
66461: PPUSH
66462: LD_EXP 107
66466: PUSH
66467: LD_VAR 0 3
66471: ARRAY
66472: PUSH
66473: LD_VAR 0 1
66477: DIFF
66478: PPUSH
66479: CALL_OW 1
66483: ST_TO_ADDR
// if building in mc_lab [ i ] then
66484: LD_VAR 0 1
66488: PUSH
66489: LD_EXP 133
66493: PUSH
66494: LD_VAR 0 3
66498: ARRAY
66499: IN
66500: IFFALSE 66555
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
66502: LD_ADDR_EXP 134
66506: PUSH
66507: LD_EXP 134
66511: PPUSH
66512: LD_VAR 0 3
66516: PPUSH
66517: LD_EXP 134
66521: PUSH
66522: LD_VAR 0 3
66526: ARRAY
66527: PPUSH
66528: LD_INT 1
66530: PPUSH
66531: LD_EXP 134
66535: PUSH
66536: LD_VAR 0 3
66540: ARRAY
66541: PPUSH
66542: LD_INT 0
66544: PPUSH
66545: CALL 72354 0 4
66549: PPUSH
66550: CALL_OW 1
66554: ST_TO_ADDR
// if not building in mc_bases [ i ] then
66555: LD_VAR 0 1
66559: PUSH
66560: LD_EXP 100
66564: PUSH
66565: LD_VAR 0 3
66569: ARRAY
66570: IN
66571: NOT
66572: IFFALSE 66618
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
66574: LD_ADDR_EXP 100
66578: PUSH
66579: LD_EXP 100
66583: PPUSH
66584: LD_VAR 0 3
66588: PUSH
66589: LD_EXP 100
66593: PUSH
66594: LD_VAR 0 3
66598: ARRAY
66599: PUSH
66600: LD_INT 1
66602: PLUS
66603: PUSH
66604: EMPTY
66605: LIST
66606: LIST
66607: PPUSH
66608: LD_VAR 0 1
66612: PPUSH
66613: CALL 72936 0 3
66617: ST_TO_ADDR
// exit ;
66618: POP
66619: POP
66620: GO 66626
// end ; end ;
66622: GO 66426
66624: POP
66625: POP
// end ;
66626: LD_VAR 0 2
66630: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
66631: LD_INT 0
66633: PPUSH
66634: PPUSH
66635: PPUSH
66636: PPUSH
66637: PPUSH
66638: PPUSH
66639: PPUSH
// if not mc_bases or not skirmish then
66640: LD_EXP 100
66644: NOT
66645: PUSH
66646: LD_EXP 98
66650: NOT
66651: OR
66652: IFFALSE 66656
// exit ;
66654: GO 67317
// for i = 1 to mc_bases do
66656: LD_ADDR_VAR 0 3
66660: PUSH
66661: DOUBLE
66662: LD_INT 1
66664: DEC
66665: ST_TO_ADDR
66666: LD_EXP 100
66670: PUSH
66671: FOR_TO
66672: IFFALSE 67315
// begin if building in mc_construct_list [ i ] then
66674: LD_VAR 0 1
66678: PUSH
66679: LD_EXP 107
66683: PUSH
66684: LD_VAR 0 3
66688: ARRAY
66689: IN
66690: IFFALSE 67313
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
66692: LD_ADDR_EXP 107
66696: PUSH
66697: LD_EXP 107
66701: PPUSH
66702: LD_VAR 0 3
66706: PPUSH
66707: LD_EXP 107
66711: PUSH
66712: LD_VAR 0 3
66716: ARRAY
66717: PUSH
66718: LD_VAR 0 1
66722: DIFF
66723: PPUSH
66724: CALL_OW 1
66728: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
66729: LD_ADDR_EXP 100
66733: PUSH
66734: LD_EXP 100
66738: PPUSH
66739: LD_VAR 0 3
66743: PUSH
66744: LD_EXP 100
66748: PUSH
66749: LD_VAR 0 3
66753: ARRAY
66754: PUSH
66755: LD_INT 1
66757: PLUS
66758: PUSH
66759: EMPTY
66760: LIST
66761: LIST
66762: PPUSH
66763: LD_VAR 0 1
66767: PPUSH
66768: CALL 72936 0 3
66772: ST_TO_ADDR
// btype := GetBType ( building ) ;
66773: LD_ADDR_VAR 0 5
66777: PUSH
66778: LD_VAR 0 1
66782: PPUSH
66783: CALL_OW 266
66787: ST_TO_ADDR
// side := GetSide ( building ) ;
66788: LD_ADDR_VAR 0 8
66792: PUSH
66793: LD_VAR 0 1
66797: PPUSH
66798: CALL_OW 255
66802: ST_TO_ADDR
// if btype = b_lab then
66803: LD_VAR 0 5
66807: PUSH
66808: LD_INT 6
66810: EQUAL
66811: IFFALSE 66861
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
66813: LD_ADDR_EXP 133
66817: PUSH
66818: LD_EXP 133
66822: PPUSH
66823: LD_VAR 0 3
66827: PUSH
66828: LD_EXP 133
66832: PUSH
66833: LD_VAR 0 3
66837: ARRAY
66838: PUSH
66839: LD_INT 1
66841: PLUS
66842: PUSH
66843: EMPTY
66844: LIST
66845: LIST
66846: PPUSH
66847: LD_VAR 0 1
66851: PPUSH
66852: CALL 72936 0 3
66856: ST_TO_ADDR
// exit ;
66857: POP
66858: POP
66859: GO 67317
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
66861: LD_VAR 0 5
66865: PUSH
66866: LD_INT 0
66868: PUSH
66869: LD_INT 2
66871: PUSH
66872: LD_INT 4
66874: PUSH
66875: EMPTY
66876: LIST
66877: LIST
66878: LIST
66879: IN
66880: IFFALSE 67004
// begin if btype = b_armoury then
66882: LD_VAR 0 5
66886: PUSH
66887: LD_INT 4
66889: EQUAL
66890: IFFALSE 66900
// btype := b_barracks ;
66892: LD_ADDR_VAR 0 5
66896: PUSH
66897: LD_INT 5
66899: ST_TO_ADDR
// if btype = b_depot then
66900: LD_VAR 0 5
66904: PUSH
66905: LD_INT 0
66907: EQUAL
66908: IFFALSE 66918
// btype := b_warehouse ;
66910: LD_ADDR_VAR 0 5
66914: PUSH
66915: LD_INT 1
66917: ST_TO_ADDR
// if btype = b_workshop then
66918: LD_VAR 0 5
66922: PUSH
66923: LD_INT 2
66925: EQUAL
66926: IFFALSE 66936
// btype := b_factory ;
66928: LD_ADDR_VAR 0 5
66932: PUSH
66933: LD_INT 3
66935: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
66936: LD_VAR 0 5
66940: PPUSH
66941: LD_VAR 0 8
66945: PPUSH
66946: CALL_OW 323
66950: PUSH
66951: LD_INT 1
66953: EQUAL
66954: IFFALSE 67000
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
66956: LD_ADDR_EXP 132
66960: PUSH
66961: LD_EXP 132
66965: PPUSH
66966: LD_VAR 0 3
66970: PUSH
66971: LD_EXP 132
66975: PUSH
66976: LD_VAR 0 3
66980: ARRAY
66981: PUSH
66982: LD_INT 1
66984: PLUS
66985: PUSH
66986: EMPTY
66987: LIST
66988: LIST
66989: PPUSH
66990: LD_VAR 0 1
66994: PPUSH
66995: CALL 72936 0 3
66999: ST_TO_ADDR
// exit ;
67000: POP
67001: POP
67002: GO 67317
// end ; if btype in [ b_bunker , b_turret ] then
67004: LD_VAR 0 5
67008: PUSH
67009: LD_INT 32
67011: PUSH
67012: LD_INT 33
67014: PUSH
67015: EMPTY
67016: LIST
67017: LIST
67018: IN
67019: IFFALSE 67309
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
67021: LD_ADDR_EXP 108
67025: PUSH
67026: LD_EXP 108
67030: PPUSH
67031: LD_VAR 0 3
67035: PUSH
67036: LD_EXP 108
67040: PUSH
67041: LD_VAR 0 3
67045: ARRAY
67046: PUSH
67047: LD_INT 1
67049: PLUS
67050: PUSH
67051: EMPTY
67052: LIST
67053: LIST
67054: PPUSH
67055: LD_VAR 0 1
67059: PPUSH
67060: CALL 72936 0 3
67064: ST_TO_ADDR
// if btype = b_bunker then
67065: LD_VAR 0 5
67069: PUSH
67070: LD_INT 32
67072: EQUAL
67073: IFFALSE 67309
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
67075: LD_ADDR_EXP 109
67079: PUSH
67080: LD_EXP 109
67084: PPUSH
67085: LD_VAR 0 3
67089: PUSH
67090: LD_EXP 109
67094: PUSH
67095: LD_VAR 0 3
67099: ARRAY
67100: PUSH
67101: LD_INT 1
67103: PLUS
67104: PUSH
67105: EMPTY
67106: LIST
67107: LIST
67108: PPUSH
67109: LD_VAR 0 1
67113: PPUSH
67114: CALL 72936 0 3
67118: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
67119: LD_ADDR_VAR 0 6
67123: PUSH
67124: LD_EXP 100
67128: PUSH
67129: LD_VAR 0 3
67133: ARRAY
67134: PPUSH
67135: LD_INT 25
67137: PUSH
67138: LD_INT 1
67140: PUSH
67141: EMPTY
67142: LIST
67143: LIST
67144: PUSH
67145: LD_INT 3
67147: PUSH
67148: LD_INT 54
67150: PUSH
67151: EMPTY
67152: LIST
67153: PUSH
67154: EMPTY
67155: LIST
67156: LIST
67157: PUSH
67158: EMPTY
67159: LIST
67160: LIST
67161: PPUSH
67162: CALL_OW 72
67166: ST_TO_ADDR
// if tmp then
67167: LD_VAR 0 6
67171: IFFALSE 67177
// exit ;
67173: POP
67174: POP
67175: GO 67317
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
67177: LD_ADDR_VAR 0 6
67181: PUSH
67182: LD_EXP 100
67186: PUSH
67187: LD_VAR 0 3
67191: ARRAY
67192: PPUSH
67193: LD_INT 2
67195: PUSH
67196: LD_INT 30
67198: PUSH
67199: LD_INT 4
67201: PUSH
67202: EMPTY
67203: LIST
67204: LIST
67205: PUSH
67206: LD_INT 30
67208: PUSH
67209: LD_INT 5
67211: PUSH
67212: EMPTY
67213: LIST
67214: LIST
67215: PUSH
67216: EMPTY
67217: LIST
67218: LIST
67219: LIST
67220: PPUSH
67221: CALL_OW 72
67225: ST_TO_ADDR
// if not tmp then
67226: LD_VAR 0 6
67230: NOT
67231: IFFALSE 67237
// exit ;
67233: POP
67234: POP
67235: GO 67317
// for j in tmp do
67237: LD_ADDR_VAR 0 4
67241: PUSH
67242: LD_VAR 0 6
67246: PUSH
67247: FOR_IN
67248: IFFALSE 67307
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
67250: LD_ADDR_VAR 0 7
67254: PUSH
67255: LD_VAR 0 4
67259: PPUSH
67260: CALL_OW 313
67264: PPUSH
67265: LD_INT 25
67267: PUSH
67268: LD_INT 1
67270: PUSH
67271: EMPTY
67272: LIST
67273: LIST
67274: PPUSH
67275: CALL_OW 72
67279: ST_TO_ADDR
// if units then
67280: LD_VAR 0 7
67284: IFFALSE 67305
// begin ComExitBuilding ( units [ 1 ] ) ;
67286: LD_VAR 0 7
67290: PUSH
67291: LD_INT 1
67293: ARRAY
67294: PPUSH
67295: CALL_OW 122
// exit ;
67299: POP
67300: POP
67301: POP
67302: POP
67303: GO 67317
// end ; end ;
67305: GO 67247
67307: POP
67308: POP
// end ; end ; exit ;
67309: POP
67310: POP
67311: GO 67317
// end ; end ;
67313: GO 66671
67315: POP
67316: POP
// end ;
67317: LD_VAR 0 2
67321: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
67322: LD_INT 0
67324: PPUSH
67325: PPUSH
67326: PPUSH
67327: PPUSH
67328: PPUSH
67329: PPUSH
67330: PPUSH
// if not mc_bases or not skirmish then
67331: LD_EXP 100
67335: NOT
67336: PUSH
67337: LD_EXP 98
67341: NOT
67342: OR
67343: IFFALSE 67347
// exit ;
67345: GO 67612
// btype := GetBType ( building ) ;
67347: LD_ADDR_VAR 0 6
67351: PUSH
67352: LD_VAR 0 1
67356: PPUSH
67357: CALL_OW 266
67361: ST_TO_ADDR
// x := GetX ( building ) ;
67362: LD_ADDR_VAR 0 7
67366: PUSH
67367: LD_VAR 0 1
67371: PPUSH
67372: CALL_OW 250
67376: ST_TO_ADDR
// y := GetY ( building ) ;
67377: LD_ADDR_VAR 0 8
67381: PUSH
67382: LD_VAR 0 1
67386: PPUSH
67387: CALL_OW 251
67391: ST_TO_ADDR
// d := GetDir ( building ) ;
67392: LD_ADDR_VAR 0 9
67396: PUSH
67397: LD_VAR 0 1
67401: PPUSH
67402: CALL_OW 254
67406: ST_TO_ADDR
// for i = 1 to mc_bases do
67407: LD_ADDR_VAR 0 4
67411: PUSH
67412: DOUBLE
67413: LD_INT 1
67415: DEC
67416: ST_TO_ADDR
67417: LD_EXP 100
67421: PUSH
67422: FOR_TO
67423: IFFALSE 67610
// begin if not mc_build_list [ i ] then
67425: LD_EXP 105
67429: PUSH
67430: LD_VAR 0 4
67434: ARRAY
67435: NOT
67436: IFFALSE 67440
// continue ;
67438: GO 67422
// for j := 1 to mc_build_list [ i ] do
67440: LD_ADDR_VAR 0 5
67444: PUSH
67445: DOUBLE
67446: LD_INT 1
67448: DEC
67449: ST_TO_ADDR
67450: LD_EXP 105
67454: PUSH
67455: LD_VAR 0 4
67459: ARRAY
67460: PUSH
67461: FOR_TO
67462: IFFALSE 67606
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
67464: LD_VAR 0 6
67468: PUSH
67469: LD_VAR 0 7
67473: PUSH
67474: LD_VAR 0 8
67478: PUSH
67479: LD_VAR 0 9
67483: PUSH
67484: EMPTY
67485: LIST
67486: LIST
67487: LIST
67488: LIST
67489: PPUSH
67490: LD_EXP 105
67494: PUSH
67495: LD_VAR 0 4
67499: ARRAY
67500: PUSH
67501: LD_VAR 0 5
67505: ARRAY
67506: PPUSH
67507: CALL 79116 0 2
67511: IFFALSE 67604
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
67513: LD_ADDR_EXP 105
67517: PUSH
67518: LD_EXP 105
67522: PPUSH
67523: LD_VAR 0 4
67527: PPUSH
67528: LD_EXP 105
67532: PUSH
67533: LD_VAR 0 4
67537: ARRAY
67538: PPUSH
67539: LD_VAR 0 5
67543: PPUSH
67544: CALL_OW 3
67548: PPUSH
67549: CALL_OW 1
67553: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
67554: LD_ADDR_EXP 107
67558: PUSH
67559: LD_EXP 107
67563: PPUSH
67564: LD_VAR 0 4
67568: PUSH
67569: LD_EXP 107
67573: PUSH
67574: LD_VAR 0 4
67578: ARRAY
67579: PUSH
67580: LD_INT 1
67582: PLUS
67583: PUSH
67584: EMPTY
67585: LIST
67586: LIST
67587: PPUSH
67588: LD_VAR 0 1
67592: PPUSH
67593: CALL 72936 0 3
67597: ST_TO_ADDR
// exit ;
67598: POP
67599: POP
67600: POP
67601: POP
67602: GO 67612
// end ;
67604: GO 67461
67606: POP
67607: POP
// end ;
67608: GO 67422
67610: POP
67611: POP
// end ;
67612: LD_VAR 0 3
67616: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
67617: LD_INT 0
67619: PPUSH
67620: PPUSH
67621: PPUSH
// if not mc_bases or not skirmish then
67622: LD_EXP 100
67626: NOT
67627: PUSH
67628: LD_EXP 98
67632: NOT
67633: OR
67634: IFFALSE 67638
// exit ;
67636: GO 67828
// for i = 1 to mc_bases do
67638: LD_ADDR_VAR 0 4
67642: PUSH
67643: DOUBLE
67644: LD_INT 1
67646: DEC
67647: ST_TO_ADDR
67648: LD_EXP 100
67652: PUSH
67653: FOR_TO
67654: IFFALSE 67741
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
67656: LD_VAR 0 1
67660: PUSH
67661: LD_EXP 108
67665: PUSH
67666: LD_VAR 0 4
67670: ARRAY
67671: IN
67672: PUSH
67673: LD_VAR 0 1
67677: PUSH
67678: LD_EXP 109
67682: PUSH
67683: LD_VAR 0 4
67687: ARRAY
67688: IN
67689: NOT
67690: AND
67691: IFFALSE 67739
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
67693: LD_ADDR_EXP 109
67697: PUSH
67698: LD_EXP 109
67702: PPUSH
67703: LD_VAR 0 4
67707: PUSH
67708: LD_EXP 109
67712: PUSH
67713: LD_VAR 0 4
67717: ARRAY
67718: PUSH
67719: LD_INT 1
67721: PLUS
67722: PUSH
67723: EMPTY
67724: LIST
67725: LIST
67726: PPUSH
67727: LD_VAR 0 1
67731: PPUSH
67732: CALL 72936 0 3
67736: ST_TO_ADDR
// break ;
67737: GO 67741
// end ; end ;
67739: GO 67653
67741: POP
67742: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
67743: LD_VAR 0 1
67747: PPUSH
67748: CALL_OW 257
67752: PUSH
67753: LD_EXP 126
67757: IN
67758: PUSH
67759: LD_VAR 0 1
67763: PPUSH
67764: CALL_OW 266
67768: PUSH
67769: LD_INT 5
67771: EQUAL
67772: AND
67773: PUSH
67774: LD_VAR 0 2
67778: PPUSH
67779: CALL_OW 110
67783: PUSH
67784: LD_INT 18
67786: NONEQUAL
67787: AND
67788: IFFALSE 67828
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
67790: LD_VAR 0 2
67794: PPUSH
67795: CALL_OW 257
67799: PUSH
67800: LD_INT 5
67802: PUSH
67803: LD_INT 8
67805: PUSH
67806: LD_INT 9
67808: PUSH
67809: EMPTY
67810: LIST
67811: LIST
67812: LIST
67813: IN
67814: IFFALSE 67828
// SetClass ( unit , 1 ) ;
67816: LD_VAR 0 2
67820: PPUSH
67821: LD_INT 1
67823: PPUSH
67824: CALL_OW 336
// end ;
67828: LD_VAR 0 3
67832: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
67833: LD_INT 0
67835: PPUSH
67836: PPUSH
// if not mc_bases or not skirmish then
67837: LD_EXP 100
67841: NOT
67842: PUSH
67843: LD_EXP 98
67847: NOT
67848: OR
67849: IFFALSE 67853
// exit ;
67851: GO 67969
// if GetLives ( abandoned_vehicle ) > 250 then
67853: LD_VAR 0 2
67857: PPUSH
67858: CALL_OW 256
67862: PUSH
67863: LD_INT 250
67865: GREATER
67866: IFFALSE 67870
// exit ;
67868: GO 67969
// for i = 1 to mc_bases do
67870: LD_ADDR_VAR 0 6
67874: PUSH
67875: DOUBLE
67876: LD_INT 1
67878: DEC
67879: ST_TO_ADDR
67880: LD_EXP 100
67884: PUSH
67885: FOR_TO
67886: IFFALSE 67967
// begin if driver in mc_bases [ i ] then
67888: LD_VAR 0 1
67892: PUSH
67893: LD_EXP 100
67897: PUSH
67898: LD_VAR 0 6
67902: ARRAY
67903: IN
67904: IFFALSE 67965
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
67906: LD_VAR 0 1
67910: PPUSH
67911: LD_EXP 100
67915: PUSH
67916: LD_VAR 0 6
67920: ARRAY
67921: PPUSH
67922: LD_INT 2
67924: PUSH
67925: LD_INT 30
67927: PUSH
67928: LD_INT 0
67930: PUSH
67931: EMPTY
67932: LIST
67933: LIST
67934: PUSH
67935: LD_INT 30
67937: PUSH
67938: LD_INT 1
67940: PUSH
67941: EMPTY
67942: LIST
67943: LIST
67944: PUSH
67945: EMPTY
67946: LIST
67947: LIST
67948: LIST
67949: PPUSH
67950: CALL_OW 72
67954: PUSH
67955: LD_INT 1
67957: ARRAY
67958: PPUSH
67959: CALL 106143 0 2
// break ;
67963: GO 67967
// end ; end ;
67965: GO 67885
67967: POP
67968: POP
// end ; end_of_file
67969: LD_VAR 0 5
67973: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
67974: LD_INT 0
67976: PPUSH
67977: PPUSH
// if exist_mode then
67978: LD_VAR 0 2
67982: IFFALSE 68007
// unit := CreateCharacter ( prefix & ident ) else
67984: LD_ADDR_VAR 0 5
67988: PUSH
67989: LD_VAR 0 3
67993: PUSH
67994: LD_VAR 0 1
67998: STR
67999: PPUSH
68000: CALL_OW 34
68004: ST_TO_ADDR
68005: GO 68022
// unit := NewCharacter ( ident ) ;
68007: LD_ADDR_VAR 0 5
68011: PUSH
68012: LD_VAR 0 1
68016: PPUSH
68017: CALL_OW 25
68021: ST_TO_ADDR
// result := unit ;
68022: LD_ADDR_VAR 0 4
68026: PUSH
68027: LD_VAR 0 5
68031: ST_TO_ADDR
// end ;
68032: LD_VAR 0 4
68036: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
68037: LD_INT 0
68039: PPUSH
68040: PPUSH
// if not side or not nation then
68041: LD_VAR 0 1
68045: NOT
68046: PUSH
68047: LD_VAR 0 2
68051: NOT
68052: OR
68053: IFFALSE 68057
// exit ;
68055: GO 68825
// case nation of nation_american :
68057: LD_VAR 0 2
68061: PUSH
68062: LD_INT 1
68064: DOUBLE
68065: EQUAL
68066: IFTRUE 68070
68068: GO 68284
68070: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
68071: LD_ADDR_VAR 0 4
68075: PUSH
68076: LD_INT 35
68078: PUSH
68079: LD_INT 45
68081: PUSH
68082: LD_INT 46
68084: PUSH
68085: LD_INT 47
68087: PUSH
68088: LD_INT 82
68090: PUSH
68091: LD_INT 83
68093: PUSH
68094: LD_INT 84
68096: PUSH
68097: LD_INT 85
68099: PUSH
68100: LD_INT 86
68102: PUSH
68103: LD_INT 1
68105: PUSH
68106: LD_INT 2
68108: PUSH
68109: LD_INT 6
68111: PUSH
68112: LD_INT 15
68114: PUSH
68115: LD_INT 16
68117: PUSH
68118: LD_INT 7
68120: PUSH
68121: LD_INT 12
68123: PUSH
68124: LD_INT 13
68126: PUSH
68127: LD_INT 10
68129: PUSH
68130: LD_INT 14
68132: PUSH
68133: LD_INT 20
68135: PUSH
68136: LD_INT 21
68138: PUSH
68139: LD_INT 22
68141: PUSH
68142: LD_INT 25
68144: PUSH
68145: LD_INT 32
68147: PUSH
68148: LD_INT 27
68150: PUSH
68151: LD_INT 36
68153: PUSH
68154: LD_INT 69
68156: PUSH
68157: LD_INT 39
68159: PUSH
68160: LD_INT 34
68162: PUSH
68163: LD_INT 40
68165: PUSH
68166: LD_INT 48
68168: PUSH
68169: LD_INT 49
68171: PUSH
68172: LD_INT 50
68174: PUSH
68175: LD_INT 51
68177: PUSH
68178: LD_INT 52
68180: PUSH
68181: LD_INT 53
68183: PUSH
68184: LD_INT 54
68186: PUSH
68187: LD_INT 55
68189: PUSH
68190: LD_INT 56
68192: PUSH
68193: LD_INT 57
68195: PUSH
68196: LD_INT 58
68198: PUSH
68199: LD_INT 59
68201: PUSH
68202: LD_INT 60
68204: PUSH
68205: LD_INT 61
68207: PUSH
68208: LD_INT 62
68210: PUSH
68211: LD_INT 80
68213: PUSH
68214: LD_INT 82
68216: PUSH
68217: LD_INT 83
68219: PUSH
68220: LD_INT 84
68222: PUSH
68223: LD_INT 85
68225: PUSH
68226: LD_INT 86
68228: PUSH
68229: EMPTY
68230: LIST
68231: LIST
68232: LIST
68233: LIST
68234: LIST
68235: LIST
68236: LIST
68237: LIST
68238: LIST
68239: LIST
68240: LIST
68241: LIST
68242: LIST
68243: LIST
68244: LIST
68245: LIST
68246: LIST
68247: LIST
68248: LIST
68249: LIST
68250: LIST
68251: LIST
68252: LIST
68253: LIST
68254: LIST
68255: LIST
68256: LIST
68257: LIST
68258: LIST
68259: LIST
68260: LIST
68261: LIST
68262: LIST
68263: LIST
68264: LIST
68265: LIST
68266: LIST
68267: LIST
68268: LIST
68269: LIST
68270: LIST
68271: LIST
68272: LIST
68273: LIST
68274: LIST
68275: LIST
68276: LIST
68277: LIST
68278: LIST
68279: LIST
68280: LIST
68281: ST_TO_ADDR
68282: GO 68749
68284: LD_INT 2
68286: DOUBLE
68287: EQUAL
68288: IFTRUE 68292
68290: GO 68518
68292: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
68293: LD_ADDR_VAR 0 4
68297: PUSH
68298: LD_INT 35
68300: PUSH
68301: LD_INT 45
68303: PUSH
68304: LD_INT 46
68306: PUSH
68307: LD_INT 47
68309: PUSH
68310: LD_INT 82
68312: PUSH
68313: LD_INT 83
68315: PUSH
68316: LD_INT 84
68318: PUSH
68319: LD_INT 85
68321: PUSH
68322: LD_INT 87
68324: PUSH
68325: LD_INT 70
68327: PUSH
68328: LD_INT 1
68330: PUSH
68331: LD_INT 11
68333: PUSH
68334: LD_INT 3
68336: PUSH
68337: LD_INT 4
68339: PUSH
68340: LD_INT 5
68342: PUSH
68343: LD_INT 6
68345: PUSH
68346: LD_INT 15
68348: PUSH
68349: LD_INT 18
68351: PUSH
68352: LD_INT 7
68354: PUSH
68355: LD_INT 17
68357: PUSH
68358: LD_INT 8
68360: PUSH
68361: LD_INT 20
68363: PUSH
68364: LD_INT 21
68366: PUSH
68367: LD_INT 22
68369: PUSH
68370: LD_INT 72
68372: PUSH
68373: LD_INT 26
68375: PUSH
68376: LD_INT 69
68378: PUSH
68379: LD_INT 39
68381: PUSH
68382: LD_INT 40
68384: PUSH
68385: LD_INT 41
68387: PUSH
68388: LD_INT 42
68390: PUSH
68391: LD_INT 43
68393: PUSH
68394: LD_INT 48
68396: PUSH
68397: LD_INT 49
68399: PUSH
68400: LD_INT 50
68402: PUSH
68403: LD_INT 51
68405: PUSH
68406: LD_INT 52
68408: PUSH
68409: LD_INT 53
68411: PUSH
68412: LD_INT 54
68414: PUSH
68415: LD_INT 55
68417: PUSH
68418: LD_INT 56
68420: PUSH
68421: LD_INT 60
68423: PUSH
68424: LD_INT 61
68426: PUSH
68427: LD_INT 62
68429: PUSH
68430: LD_INT 66
68432: PUSH
68433: LD_INT 67
68435: PUSH
68436: LD_INT 68
68438: PUSH
68439: LD_INT 81
68441: PUSH
68442: LD_INT 82
68444: PUSH
68445: LD_INT 83
68447: PUSH
68448: LD_INT 84
68450: PUSH
68451: LD_INT 85
68453: PUSH
68454: LD_INT 87
68456: PUSH
68457: LD_INT 88
68459: PUSH
68460: EMPTY
68461: LIST
68462: LIST
68463: LIST
68464: LIST
68465: LIST
68466: LIST
68467: LIST
68468: LIST
68469: LIST
68470: LIST
68471: LIST
68472: LIST
68473: LIST
68474: LIST
68475: LIST
68476: LIST
68477: LIST
68478: LIST
68479: LIST
68480: LIST
68481: LIST
68482: LIST
68483: LIST
68484: LIST
68485: LIST
68486: LIST
68487: LIST
68488: LIST
68489: LIST
68490: LIST
68491: LIST
68492: LIST
68493: LIST
68494: LIST
68495: LIST
68496: LIST
68497: LIST
68498: LIST
68499: LIST
68500: LIST
68501: LIST
68502: LIST
68503: LIST
68504: LIST
68505: LIST
68506: LIST
68507: LIST
68508: LIST
68509: LIST
68510: LIST
68511: LIST
68512: LIST
68513: LIST
68514: LIST
68515: ST_TO_ADDR
68516: GO 68749
68518: LD_INT 3
68520: DOUBLE
68521: EQUAL
68522: IFTRUE 68526
68524: GO 68748
68526: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
68527: LD_ADDR_VAR 0 4
68531: PUSH
68532: LD_INT 46
68534: PUSH
68535: LD_INT 47
68537: PUSH
68538: LD_INT 1
68540: PUSH
68541: LD_INT 2
68543: PUSH
68544: LD_INT 82
68546: PUSH
68547: LD_INT 83
68549: PUSH
68550: LD_INT 84
68552: PUSH
68553: LD_INT 85
68555: PUSH
68556: LD_INT 86
68558: PUSH
68559: LD_INT 11
68561: PUSH
68562: LD_INT 9
68564: PUSH
68565: LD_INT 20
68567: PUSH
68568: LD_INT 19
68570: PUSH
68571: LD_INT 21
68573: PUSH
68574: LD_INT 24
68576: PUSH
68577: LD_INT 22
68579: PUSH
68580: LD_INT 25
68582: PUSH
68583: LD_INT 28
68585: PUSH
68586: LD_INT 29
68588: PUSH
68589: LD_INT 30
68591: PUSH
68592: LD_INT 31
68594: PUSH
68595: LD_INT 37
68597: PUSH
68598: LD_INT 38
68600: PUSH
68601: LD_INT 32
68603: PUSH
68604: LD_INT 27
68606: PUSH
68607: LD_INT 33
68609: PUSH
68610: LD_INT 69
68612: PUSH
68613: LD_INT 39
68615: PUSH
68616: LD_INT 34
68618: PUSH
68619: LD_INT 40
68621: PUSH
68622: LD_INT 71
68624: PUSH
68625: LD_INT 23
68627: PUSH
68628: LD_INT 44
68630: PUSH
68631: LD_INT 48
68633: PUSH
68634: LD_INT 49
68636: PUSH
68637: LD_INT 50
68639: PUSH
68640: LD_INT 51
68642: PUSH
68643: LD_INT 52
68645: PUSH
68646: LD_INT 53
68648: PUSH
68649: LD_INT 54
68651: PUSH
68652: LD_INT 55
68654: PUSH
68655: LD_INT 56
68657: PUSH
68658: LD_INT 57
68660: PUSH
68661: LD_INT 58
68663: PUSH
68664: LD_INT 59
68666: PUSH
68667: LD_INT 63
68669: PUSH
68670: LD_INT 64
68672: PUSH
68673: LD_INT 65
68675: PUSH
68676: LD_INT 82
68678: PUSH
68679: LD_INT 83
68681: PUSH
68682: LD_INT 84
68684: PUSH
68685: LD_INT 85
68687: PUSH
68688: LD_INT 86
68690: PUSH
68691: EMPTY
68692: LIST
68693: LIST
68694: LIST
68695: LIST
68696: LIST
68697: LIST
68698: LIST
68699: LIST
68700: LIST
68701: LIST
68702: LIST
68703: LIST
68704: LIST
68705: LIST
68706: LIST
68707: LIST
68708: LIST
68709: LIST
68710: LIST
68711: LIST
68712: LIST
68713: LIST
68714: LIST
68715: LIST
68716: LIST
68717: LIST
68718: LIST
68719: LIST
68720: LIST
68721: LIST
68722: LIST
68723: LIST
68724: LIST
68725: LIST
68726: LIST
68727: LIST
68728: LIST
68729: LIST
68730: LIST
68731: LIST
68732: LIST
68733: LIST
68734: LIST
68735: LIST
68736: LIST
68737: LIST
68738: LIST
68739: LIST
68740: LIST
68741: LIST
68742: LIST
68743: LIST
68744: LIST
68745: ST_TO_ADDR
68746: GO 68749
68748: POP
// if state > - 1 and state < 3 then
68749: LD_VAR 0 3
68753: PUSH
68754: LD_INT 1
68756: NEG
68757: GREATER
68758: PUSH
68759: LD_VAR 0 3
68763: PUSH
68764: LD_INT 3
68766: LESS
68767: AND
68768: IFFALSE 68825
// for i in result do
68770: LD_ADDR_VAR 0 5
68774: PUSH
68775: LD_VAR 0 4
68779: PUSH
68780: FOR_IN
68781: IFFALSE 68823
// if GetTech ( i , side ) <> state then
68783: LD_VAR 0 5
68787: PPUSH
68788: LD_VAR 0 1
68792: PPUSH
68793: CALL_OW 321
68797: PUSH
68798: LD_VAR 0 3
68802: NONEQUAL
68803: IFFALSE 68821
// result := result diff i ;
68805: LD_ADDR_VAR 0 4
68809: PUSH
68810: LD_VAR 0 4
68814: PUSH
68815: LD_VAR 0 5
68819: DIFF
68820: ST_TO_ADDR
68821: GO 68780
68823: POP
68824: POP
// end ;
68825: LD_VAR 0 4
68829: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
68830: LD_INT 0
68832: PPUSH
68833: PPUSH
68834: PPUSH
// result := true ;
68835: LD_ADDR_VAR 0 3
68839: PUSH
68840: LD_INT 1
68842: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
68843: LD_ADDR_VAR 0 5
68847: PUSH
68848: LD_VAR 0 2
68852: PPUSH
68853: CALL_OW 480
68857: ST_TO_ADDR
// if not tmp then
68858: LD_VAR 0 5
68862: NOT
68863: IFFALSE 68867
// exit ;
68865: GO 68916
// for i in tmp do
68867: LD_ADDR_VAR 0 4
68871: PUSH
68872: LD_VAR 0 5
68876: PUSH
68877: FOR_IN
68878: IFFALSE 68914
// if GetTech ( i , side ) <> state_researched then
68880: LD_VAR 0 4
68884: PPUSH
68885: LD_VAR 0 1
68889: PPUSH
68890: CALL_OW 321
68894: PUSH
68895: LD_INT 2
68897: NONEQUAL
68898: IFFALSE 68912
// begin result := false ;
68900: LD_ADDR_VAR 0 3
68904: PUSH
68905: LD_INT 0
68907: ST_TO_ADDR
// exit ;
68908: POP
68909: POP
68910: GO 68916
// end ;
68912: GO 68877
68914: POP
68915: POP
// end ;
68916: LD_VAR 0 3
68920: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
68921: LD_INT 0
68923: PPUSH
68924: PPUSH
68925: PPUSH
68926: PPUSH
68927: PPUSH
68928: PPUSH
68929: PPUSH
68930: PPUSH
68931: PPUSH
68932: PPUSH
68933: PPUSH
68934: PPUSH
68935: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
68936: LD_VAR 0 1
68940: NOT
68941: PUSH
68942: LD_VAR 0 1
68946: PPUSH
68947: CALL_OW 257
68951: PUSH
68952: LD_INT 9
68954: NONEQUAL
68955: OR
68956: IFFALSE 68960
// exit ;
68958: GO 69533
// side := GetSide ( unit ) ;
68960: LD_ADDR_VAR 0 9
68964: PUSH
68965: LD_VAR 0 1
68969: PPUSH
68970: CALL_OW 255
68974: ST_TO_ADDR
// tech_space := tech_spacanom ;
68975: LD_ADDR_VAR 0 12
68979: PUSH
68980: LD_INT 29
68982: ST_TO_ADDR
// tech_time := tech_taurad ;
68983: LD_ADDR_VAR 0 13
68987: PUSH
68988: LD_INT 28
68990: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
68991: LD_ADDR_VAR 0 11
68995: PUSH
68996: LD_VAR 0 1
69000: PPUSH
69001: CALL_OW 310
69005: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
69006: LD_VAR 0 11
69010: PPUSH
69011: CALL_OW 247
69015: PUSH
69016: LD_INT 2
69018: EQUAL
69019: IFFALSE 69023
// exit ;
69021: GO 69533
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69023: LD_ADDR_VAR 0 8
69027: PUSH
69028: LD_INT 81
69030: PUSH
69031: LD_VAR 0 9
69035: PUSH
69036: EMPTY
69037: LIST
69038: LIST
69039: PUSH
69040: LD_INT 3
69042: PUSH
69043: LD_INT 21
69045: PUSH
69046: LD_INT 3
69048: PUSH
69049: EMPTY
69050: LIST
69051: LIST
69052: PUSH
69053: EMPTY
69054: LIST
69055: LIST
69056: PUSH
69057: EMPTY
69058: LIST
69059: LIST
69060: PPUSH
69061: CALL_OW 69
69065: ST_TO_ADDR
// if not tmp then
69066: LD_VAR 0 8
69070: NOT
69071: IFFALSE 69075
// exit ;
69073: GO 69533
// if in_unit then
69075: LD_VAR 0 11
69079: IFFALSE 69103
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
69081: LD_ADDR_VAR 0 10
69085: PUSH
69086: LD_VAR 0 8
69090: PPUSH
69091: LD_VAR 0 11
69095: PPUSH
69096: CALL_OW 74
69100: ST_TO_ADDR
69101: GO 69123
// enemy := NearestUnitToUnit ( tmp , unit ) ;
69103: LD_ADDR_VAR 0 10
69107: PUSH
69108: LD_VAR 0 8
69112: PPUSH
69113: LD_VAR 0 1
69117: PPUSH
69118: CALL_OW 74
69122: ST_TO_ADDR
// if not enemy then
69123: LD_VAR 0 10
69127: NOT
69128: IFFALSE 69132
// exit ;
69130: GO 69533
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
69132: LD_VAR 0 11
69136: PUSH
69137: LD_VAR 0 11
69141: PPUSH
69142: LD_VAR 0 10
69146: PPUSH
69147: CALL_OW 296
69151: PUSH
69152: LD_INT 13
69154: GREATER
69155: AND
69156: PUSH
69157: LD_VAR 0 1
69161: PPUSH
69162: LD_VAR 0 10
69166: PPUSH
69167: CALL_OW 296
69171: PUSH
69172: LD_INT 12
69174: GREATER
69175: OR
69176: IFFALSE 69180
// exit ;
69178: GO 69533
// missile := [ 1 ] ;
69180: LD_ADDR_VAR 0 14
69184: PUSH
69185: LD_INT 1
69187: PUSH
69188: EMPTY
69189: LIST
69190: ST_TO_ADDR
// if Researched ( side , tech_space ) then
69191: LD_VAR 0 9
69195: PPUSH
69196: LD_VAR 0 12
69200: PPUSH
69201: CALL_OW 325
69205: IFFALSE 69234
// missile := Replace ( missile , missile + 1 , 2 ) ;
69207: LD_ADDR_VAR 0 14
69211: PUSH
69212: LD_VAR 0 14
69216: PPUSH
69217: LD_VAR 0 14
69221: PUSH
69222: LD_INT 1
69224: PLUS
69225: PPUSH
69226: LD_INT 2
69228: PPUSH
69229: CALL_OW 1
69233: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
69234: LD_VAR 0 9
69238: PPUSH
69239: LD_VAR 0 13
69243: PPUSH
69244: CALL_OW 325
69248: PUSH
69249: LD_VAR 0 10
69253: PPUSH
69254: CALL_OW 255
69258: PPUSH
69259: LD_VAR 0 13
69263: PPUSH
69264: CALL_OW 325
69268: NOT
69269: AND
69270: IFFALSE 69299
// missile := Replace ( missile , missile + 1 , 3 ) ;
69272: LD_ADDR_VAR 0 14
69276: PUSH
69277: LD_VAR 0 14
69281: PPUSH
69282: LD_VAR 0 14
69286: PUSH
69287: LD_INT 1
69289: PLUS
69290: PPUSH
69291: LD_INT 3
69293: PPUSH
69294: CALL_OW 1
69298: ST_TO_ADDR
// if missile < 2 then
69299: LD_VAR 0 14
69303: PUSH
69304: LD_INT 2
69306: LESS
69307: IFFALSE 69311
// exit ;
69309: GO 69533
// x := GetX ( enemy ) ;
69311: LD_ADDR_VAR 0 4
69315: PUSH
69316: LD_VAR 0 10
69320: PPUSH
69321: CALL_OW 250
69325: ST_TO_ADDR
// y := GetY ( enemy ) ;
69326: LD_ADDR_VAR 0 5
69330: PUSH
69331: LD_VAR 0 10
69335: PPUSH
69336: CALL_OW 251
69340: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
69341: LD_ADDR_VAR 0 6
69345: PUSH
69346: LD_VAR 0 4
69350: PUSH
69351: LD_INT 1
69353: NEG
69354: PPUSH
69355: LD_INT 1
69357: PPUSH
69358: CALL_OW 12
69362: PLUS
69363: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
69364: LD_ADDR_VAR 0 7
69368: PUSH
69369: LD_VAR 0 5
69373: PUSH
69374: LD_INT 1
69376: NEG
69377: PPUSH
69378: LD_INT 1
69380: PPUSH
69381: CALL_OW 12
69385: PLUS
69386: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
69387: LD_VAR 0 6
69391: PPUSH
69392: LD_VAR 0 7
69396: PPUSH
69397: CALL_OW 488
69401: NOT
69402: IFFALSE 69424
// begin _x := x ;
69404: LD_ADDR_VAR 0 6
69408: PUSH
69409: LD_VAR 0 4
69413: ST_TO_ADDR
// _y := y ;
69414: LD_ADDR_VAR 0 7
69418: PUSH
69419: LD_VAR 0 5
69423: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
69424: LD_ADDR_VAR 0 3
69428: PUSH
69429: LD_INT 1
69431: PPUSH
69432: LD_VAR 0 14
69436: PPUSH
69437: CALL_OW 12
69441: ST_TO_ADDR
// case i of 1 :
69442: LD_VAR 0 3
69446: PUSH
69447: LD_INT 1
69449: DOUBLE
69450: EQUAL
69451: IFTRUE 69455
69453: GO 69472
69455: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
69456: LD_VAR 0 1
69460: PPUSH
69461: LD_VAR 0 10
69465: PPUSH
69466: CALL_OW 115
69470: GO 69533
69472: LD_INT 2
69474: DOUBLE
69475: EQUAL
69476: IFTRUE 69480
69478: GO 69502
69480: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
69481: LD_VAR 0 1
69485: PPUSH
69486: LD_VAR 0 6
69490: PPUSH
69491: LD_VAR 0 7
69495: PPUSH
69496: CALL_OW 153
69500: GO 69533
69502: LD_INT 3
69504: DOUBLE
69505: EQUAL
69506: IFTRUE 69510
69508: GO 69532
69510: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
69511: LD_VAR 0 1
69515: PPUSH
69516: LD_VAR 0 6
69520: PPUSH
69521: LD_VAR 0 7
69525: PPUSH
69526: CALL_OW 154
69530: GO 69533
69532: POP
// end ;
69533: LD_VAR 0 2
69537: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
69538: LD_INT 0
69540: PPUSH
69541: PPUSH
69542: PPUSH
69543: PPUSH
69544: PPUSH
69545: PPUSH
// if not unit or not building then
69546: LD_VAR 0 1
69550: NOT
69551: PUSH
69552: LD_VAR 0 2
69556: NOT
69557: OR
69558: IFFALSE 69562
// exit ;
69560: GO 69720
// x := GetX ( building ) ;
69562: LD_ADDR_VAR 0 5
69566: PUSH
69567: LD_VAR 0 2
69571: PPUSH
69572: CALL_OW 250
69576: ST_TO_ADDR
// y := GetY ( building ) ;
69577: LD_ADDR_VAR 0 6
69581: PUSH
69582: LD_VAR 0 2
69586: PPUSH
69587: CALL_OW 251
69591: ST_TO_ADDR
// for i = 0 to 5 do
69592: LD_ADDR_VAR 0 4
69596: PUSH
69597: DOUBLE
69598: LD_INT 0
69600: DEC
69601: ST_TO_ADDR
69602: LD_INT 5
69604: PUSH
69605: FOR_TO
69606: IFFALSE 69718
// begin _x := ShiftX ( x , i , 3 ) ;
69608: LD_ADDR_VAR 0 7
69612: PUSH
69613: LD_VAR 0 5
69617: PPUSH
69618: LD_VAR 0 4
69622: PPUSH
69623: LD_INT 3
69625: PPUSH
69626: CALL_OW 272
69630: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
69631: LD_ADDR_VAR 0 8
69635: PUSH
69636: LD_VAR 0 6
69640: PPUSH
69641: LD_VAR 0 4
69645: PPUSH
69646: LD_INT 3
69648: PPUSH
69649: CALL_OW 273
69653: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
69654: LD_VAR 0 7
69658: PPUSH
69659: LD_VAR 0 8
69663: PPUSH
69664: CALL_OW 488
69668: NOT
69669: IFFALSE 69673
// continue ;
69671: GO 69605
// if HexInfo ( _x , _y ) = 0 then
69673: LD_VAR 0 7
69677: PPUSH
69678: LD_VAR 0 8
69682: PPUSH
69683: CALL_OW 428
69687: PUSH
69688: LD_INT 0
69690: EQUAL
69691: IFFALSE 69716
// begin ComMoveXY ( unit , _x , _y ) ;
69693: LD_VAR 0 1
69697: PPUSH
69698: LD_VAR 0 7
69702: PPUSH
69703: LD_VAR 0 8
69707: PPUSH
69708: CALL_OW 111
// exit ;
69712: POP
69713: POP
69714: GO 69720
// end ; end ;
69716: GO 69605
69718: POP
69719: POP
// end ;
69720: LD_VAR 0 3
69724: RET
// export function ScanBase ( side , base_area ) ; begin
69725: LD_INT 0
69727: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
69728: LD_ADDR_VAR 0 3
69732: PUSH
69733: LD_VAR 0 2
69737: PPUSH
69738: LD_INT 81
69740: PUSH
69741: LD_VAR 0 1
69745: PUSH
69746: EMPTY
69747: LIST
69748: LIST
69749: PPUSH
69750: CALL_OW 70
69754: ST_TO_ADDR
// end ;
69755: LD_VAR 0 3
69759: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
69760: LD_INT 0
69762: PPUSH
69763: PPUSH
69764: PPUSH
69765: PPUSH
// result := false ;
69766: LD_ADDR_VAR 0 2
69770: PUSH
69771: LD_INT 0
69773: ST_TO_ADDR
// side := GetSide ( unit ) ;
69774: LD_ADDR_VAR 0 3
69778: PUSH
69779: LD_VAR 0 1
69783: PPUSH
69784: CALL_OW 255
69788: ST_TO_ADDR
// nat := GetNation ( unit ) ;
69789: LD_ADDR_VAR 0 4
69793: PUSH
69794: LD_VAR 0 1
69798: PPUSH
69799: CALL_OW 248
69803: ST_TO_ADDR
// case nat of 1 :
69804: LD_VAR 0 4
69808: PUSH
69809: LD_INT 1
69811: DOUBLE
69812: EQUAL
69813: IFTRUE 69817
69815: GO 69828
69817: POP
// tech := tech_lassight ; 2 :
69818: LD_ADDR_VAR 0 5
69822: PUSH
69823: LD_INT 12
69825: ST_TO_ADDR
69826: GO 69867
69828: LD_INT 2
69830: DOUBLE
69831: EQUAL
69832: IFTRUE 69836
69834: GO 69847
69836: POP
// tech := tech_mortar ; 3 :
69837: LD_ADDR_VAR 0 5
69841: PUSH
69842: LD_INT 41
69844: ST_TO_ADDR
69845: GO 69867
69847: LD_INT 3
69849: DOUBLE
69850: EQUAL
69851: IFTRUE 69855
69853: GO 69866
69855: POP
// tech := tech_bazooka ; end ;
69856: LD_ADDR_VAR 0 5
69860: PUSH
69861: LD_INT 44
69863: ST_TO_ADDR
69864: GO 69867
69866: POP
// if Researched ( side , tech ) then
69867: LD_VAR 0 3
69871: PPUSH
69872: LD_VAR 0 5
69876: PPUSH
69877: CALL_OW 325
69881: IFFALSE 69908
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
69883: LD_ADDR_VAR 0 2
69887: PUSH
69888: LD_INT 5
69890: PUSH
69891: LD_INT 8
69893: PUSH
69894: LD_INT 9
69896: PUSH
69897: EMPTY
69898: LIST
69899: LIST
69900: LIST
69901: PUSH
69902: LD_VAR 0 4
69906: ARRAY
69907: ST_TO_ADDR
// end ;
69908: LD_VAR 0 2
69912: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
69913: LD_INT 0
69915: PPUSH
69916: PPUSH
69917: PPUSH
// if not mines then
69918: LD_VAR 0 2
69922: NOT
69923: IFFALSE 69927
// exit ;
69925: GO 70071
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69927: LD_ADDR_VAR 0 5
69931: PUSH
69932: LD_INT 81
69934: PUSH
69935: LD_VAR 0 1
69939: PUSH
69940: EMPTY
69941: LIST
69942: LIST
69943: PUSH
69944: LD_INT 3
69946: PUSH
69947: LD_INT 21
69949: PUSH
69950: LD_INT 3
69952: PUSH
69953: EMPTY
69954: LIST
69955: LIST
69956: PUSH
69957: EMPTY
69958: LIST
69959: LIST
69960: PUSH
69961: EMPTY
69962: LIST
69963: LIST
69964: PPUSH
69965: CALL_OW 69
69969: ST_TO_ADDR
// for i in mines do
69970: LD_ADDR_VAR 0 4
69974: PUSH
69975: LD_VAR 0 2
69979: PUSH
69980: FOR_IN
69981: IFFALSE 70069
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
69983: LD_VAR 0 4
69987: PUSH
69988: LD_INT 1
69990: ARRAY
69991: PPUSH
69992: LD_VAR 0 4
69996: PUSH
69997: LD_INT 2
69999: ARRAY
70000: PPUSH
70001: CALL_OW 458
70005: NOT
70006: IFFALSE 70010
// continue ;
70008: GO 69980
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
70010: LD_VAR 0 4
70014: PUSH
70015: LD_INT 1
70017: ARRAY
70018: PPUSH
70019: LD_VAR 0 4
70023: PUSH
70024: LD_INT 2
70026: ARRAY
70027: PPUSH
70028: CALL_OW 428
70032: PUSH
70033: LD_VAR 0 5
70037: IN
70038: IFFALSE 70067
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
70040: LD_VAR 0 4
70044: PUSH
70045: LD_INT 1
70047: ARRAY
70048: PPUSH
70049: LD_VAR 0 4
70053: PUSH
70054: LD_INT 2
70056: ARRAY
70057: PPUSH
70058: LD_VAR 0 1
70062: PPUSH
70063: CALL_OW 456
// end ;
70067: GO 69980
70069: POP
70070: POP
// end ;
70071: LD_VAR 0 3
70075: RET
// export function Count ( array ) ; begin
70076: LD_INT 0
70078: PPUSH
// result := array + 0 ;
70079: LD_ADDR_VAR 0 2
70083: PUSH
70084: LD_VAR 0 1
70088: PUSH
70089: LD_INT 0
70091: PLUS
70092: ST_TO_ADDR
// end ;
70093: LD_VAR 0 2
70097: RET
// export function IsEmpty ( building ) ; begin
70098: LD_INT 0
70100: PPUSH
// if not building then
70101: LD_VAR 0 1
70105: NOT
70106: IFFALSE 70110
// exit ;
70108: GO 70153
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
70110: LD_ADDR_VAR 0 2
70114: PUSH
70115: LD_VAR 0 1
70119: PUSH
70120: LD_INT 22
70122: PUSH
70123: LD_VAR 0 1
70127: PPUSH
70128: CALL_OW 255
70132: PUSH
70133: EMPTY
70134: LIST
70135: LIST
70136: PUSH
70137: LD_INT 58
70139: PUSH
70140: EMPTY
70141: LIST
70142: PUSH
70143: EMPTY
70144: LIST
70145: LIST
70146: PPUSH
70147: CALL_OW 69
70151: IN
70152: ST_TO_ADDR
// end ;
70153: LD_VAR 0 2
70157: RET
// export function IsNotFull ( building ) ; var places ; begin
70158: LD_INT 0
70160: PPUSH
70161: PPUSH
// if not building then
70162: LD_VAR 0 1
70166: NOT
70167: IFFALSE 70171
// exit ;
70169: GO 70199
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
70171: LD_ADDR_VAR 0 2
70175: PUSH
70176: LD_VAR 0 1
70180: PPUSH
70181: LD_INT 3
70183: PUSH
70184: LD_INT 62
70186: PUSH
70187: EMPTY
70188: LIST
70189: PUSH
70190: EMPTY
70191: LIST
70192: LIST
70193: PPUSH
70194: CALL_OW 72
70198: ST_TO_ADDR
// end ;
70199: LD_VAR 0 2
70203: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
70204: LD_INT 0
70206: PPUSH
70207: PPUSH
70208: PPUSH
70209: PPUSH
// tmp := [ ] ;
70210: LD_ADDR_VAR 0 3
70214: PUSH
70215: EMPTY
70216: ST_TO_ADDR
// list := [ ] ;
70217: LD_ADDR_VAR 0 5
70221: PUSH
70222: EMPTY
70223: ST_TO_ADDR
// for i = 16 to 25 do
70224: LD_ADDR_VAR 0 4
70228: PUSH
70229: DOUBLE
70230: LD_INT 16
70232: DEC
70233: ST_TO_ADDR
70234: LD_INT 25
70236: PUSH
70237: FOR_TO
70238: IFFALSE 70311
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
70240: LD_ADDR_VAR 0 3
70244: PUSH
70245: LD_VAR 0 3
70249: PUSH
70250: LD_INT 22
70252: PUSH
70253: LD_VAR 0 1
70257: PPUSH
70258: CALL_OW 255
70262: PUSH
70263: EMPTY
70264: LIST
70265: LIST
70266: PUSH
70267: LD_INT 91
70269: PUSH
70270: LD_VAR 0 1
70274: PUSH
70275: LD_INT 6
70277: PUSH
70278: EMPTY
70279: LIST
70280: LIST
70281: LIST
70282: PUSH
70283: LD_INT 30
70285: PUSH
70286: LD_VAR 0 4
70290: PUSH
70291: EMPTY
70292: LIST
70293: LIST
70294: PUSH
70295: EMPTY
70296: LIST
70297: LIST
70298: LIST
70299: PUSH
70300: EMPTY
70301: LIST
70302: PPUSH
70303: CALL_OW 69
70307: ADD
70308: ST_TO_ADDR
70309: GO 70237
70311: POP
70312: POP
// for i = 1 to tmp do
70313: LD_ADDR_VAR 0 4
70317: PUSH
70318: DOUBLE
70319: LD_INT 1
70321: DEC
70322: ST_TO_ADDR
70323: LD_VAR 0 3
70327: PUSH
70328: FOR_TO
70329: IFFALSE 70417
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
70331: LD_ADDR_VAR 0 5
70335: PUSH
70336: LD_VAR 0 5
70340: PUSH
70341: LD_VAR 0 3
70345: PUSH
70346: LD_VAR 0 4
70350: ARRAY
70351: PPUSH
70352: CALL_OW 266
70356: PUSH
70357: LD_VAR 0 3
70361: PUSH
70362: LD_VAR 0 4
70366: ARRAY
70367: PPUSH
70368: CALL_OW 250
70372: PUSH
70373: LD_VAR 0 3
70377: PUSH
70378: LD_VAR 0 4
70382: ARRAY
70383: PPUSH
70384: CALL_OW 251
70388: PUSH
70389: LD_VAR 0 3
70393: PUSH
70394: LD_VAR 0 4
70398: ARRAY
70399: PPUSH
70400: CALL_OW 254
70404: PUSH
70405: EMPTY
70406: LIST
70407: LIST
70408: LIST
70409: LIST
70410: PUSH
70411: EMPTY
70412: LIST
70413: ADD
70414: ST_TO_ADDR
70415: GO 70328
70417: POP
70418: POP
// result := list ;
70419: LD_ADDR_VAR 0 2
70423: PUSH
70424: LD_VAR 0 5
70428: ST_TO_ADDR
// end ;
70429: LD_VAR 0 2
70433: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
70434: LD_INT 0
70436: PPUSH
70437: PPUSH
70438: PPUSH
70439: PPUSH
70440: PPUSH
70441: PPUSH
70442: PPUSH
// if not factory then
70443: LD_VAR 0 1
70447: NOT
70448: IFFALSE 70452
// exit ;
70450: GO 71045
// if control = control_apeman then
70452: LD_VAR 0 4
70456: PUSH
70457: LD_INT 5
70459: EQUAL
70460: IFFALSE 70569
// begin tmp := UnitsInside ( factory ) ;
70462: LD_ADDR_VAR 0 8
70466: PUSH
70467: LD_VAR 0 1
70471: PPUSH
70472: CALL_OW 313
70476: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
70477: LD_VAR 0 8
70481: PPUSH
70482: LD_INT 25
70484: PUSH
70485: LD_INT 12
70487: PUSH
70488: EMPTY
70489: LIST
70490: LIST
70491: PPUSH
70492: CALL_OW 72
70496: NOT
70497: IFFALSE 70507
// control := control_manual ;
70499: LD_ADDR_VAR 0 4
70503: PUSH
70504: LD_INT 1
70506: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
70507: LD_ADDR_VAR 0 8
70511: PUSH
70512: LD_VAR 0 1
70516: PPUSH
70517: CALL 70204 0 1
70521: ST_TO_ADDR
// if tmp then
70522: LD_VAR 0 8
70526: IFFALSE 70569
// begin for i in tmp do
70528: LD_ADDR_VAR 0 7
70532: PUSH
70533: LD_VAR 0 8
70537: PUSH
70538: FOR_IN
70539: IFFALSE 70567
// if i [ 1 ] = b_ext_radio then
70541: LD_VAR 0 7
70545: PUSH
70546: LD_INT 1
70548: ARRAY
70549: PUSH
70550: LD_INT 22
70552: EQUAL
70553: IFFALSE 70565
// begin control := control_remote ;
70555: LD_ADDR_VAR 0 4
70559: PUSH
70560: LD_INT 2
70562: ST_TO_ADDR
// break ;
70563: GO 70567
// end ;
70565: GO 70538
70567: POP
70568: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70569: LD_VAR 0 1
70573: PPUSH
70574: LD_VAR 0 2
70578: PPUSH
70579: LD_VAR 0 3
70583: PPUSH
70584: LD_VAR 0 4
70588: PPUSH
70589: LD_VAR 0 5
70593: PPUSH
70594: CALL_OW 448
70598: IFFALSE 70633
// begin result := [ chassis , engine , control , weapon ] ;
70600: LD_ADDR_VAR 0 6
70604: PUSH
70605: LD_VAR 0 2
70609: PUSH
70610: LD_VAR 0 3
70614: PUSH
70615: LD_VAR 0 4
70619: PUSH
70620: LD_VAR 0 5
70624: PUSH
70625: EMPTY
70626: LIST
70627: LIST
70628: LIST
70629: LIST
70630: ST_TO_ADDR
// exit ;
70631: GO 71045
// end ; _chassis := AvailableChassisList ( factory ) ;
70633: LD_ADDR_VAR 0 9
70637: PUSH
70638: LD_VAR 0 1
70642: PPUSH
70643: CALL_OW 475
70647: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
70648: LD_ADDR_VAR 0 11
70652: PUSH
70653: LD_VAR 0 1
70657: PPUSH
70658: CALL_OW 476
70662: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
70663: LD_ADDR_VAR 0 12
70667: PUSH
70668: LD_VAR 0 1
70672: PPUSH
70673: CALL_OW 477
70677: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
70678: LD_ADDR_VAR 0 10
70682: PUSH
70683: LD_VAR 0 1
70687: PPUSH
70688: CALL_OW 478
70692: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
70693: LD_VAR 0 9
70697: NOT
70698: PUSH
70699: LD_VAR 0 11
70703: NOT
70704: OR
70705: PUSH
70706: LD_VAR 0 12
70710: NOT
70711: OR
70712: PUSH
70713: LD_VAR 0 10
70717: NOT
70718: OR
70719: IFFALSE 70754
// begin result := [ chassis , engine , control , weapon ] ;
70721: LD_ADDR_VAR 0 6
70725: PUSH
70726: LD_VAR 0 2
70730: PUSH
70731: LD_VAR 0 3
70735: PUSH
70736: LD_VAR 0 4
70740: PUSH
70741: LD_VAR 0 5
70745: PUSH
70746: EMPTY
70747: LIST
70748: LIST
70749: LIST
70750: LIST
70751: ST_TO_ADDR
// exit ;
70752: GO 71045
// end ; if not chassis in _chassis then
70754: LD_VAR 0 2
70758: PUSH
70759: LD_VAR 0 9
70763: IN
70764: NOT
70765: IFFALSE 70791
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
70767: LD_ADDR_VAR 0 2
70771: PUSH
70772: LD_VAR 0 9
70776: PUSH
70777: LD_INT 1
70779: PPUSH
70780: LD_VAR 0 9
70784: PPUSH
70785: CALL_OW 12
70789: ARRAY
70790: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
70791: LD_VAR 0 2
70795: PPUSH
70796: LD_VAR 0 3
70800: PPUSH
70801: CALL 71050 0 2
70805: NOT
70806: IFFALSE 70865
// repeat engine := _engine [ 1 ] ;
70808: LD_ADDR_VAR 0 3
70812: PUSH
70813: LD_VAR 0 11
70817: PUSH
70818: LD_INT 1
70820: ARRAY
70821: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
70822: LD_ADDR_VAR 0 11
70826: PUSH
70827: LD_VAR 0 11
70831: PPUSH
70832: LD_INT 1
70834: PPUSH
70835: CALL_OW 3
70839: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
70840: LD_VAR 0 2
70844: PPUSH
70845: LD_VAR 0 3
70849: PPUSH
70850: CALL 71050 0 2
70854: PUSH
70855: LD_VAR 0 11
70859: PUSH
70860: EMPTY
70861: EQUAL
70862: OR
70863: IFFALSE 70808
// if not control in _control then
70865: LD_VAR 0 4
70869: PUSH
70870: LD_VAR 0 12
70874: IN
70875: NOT
70876: IFFALSE 70902
// control := _control [ rand ( 1 , _control ) ] ;
70878: LD_ADDR_VAR 0 4
70882: PUSH
70883: LD_VAR 0 12
70887: PUSH
70888: LD_INT 1
70890: PPUSH
70891: LD_VAR 0 12
70895: PPUSH
70896: CALL_OW 12
70900: ARRAY
70901: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
70902: LD_VAR 0 2
70906: PPUSH
70907: LD_VAR 0 5
70911: PPUSH
70912: CALL 71270 0 2
70916: NOT
70917: IFFALSE 70976
// repeat weapon := _weapon [ 1 ] ;
70919: LD_ADDR_VAR 0 5
70923: PUSH
70924: LD_VAR 0 10
70928: PUSH
70929: LD_INT 1
70931: ARRAY
70932: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
70933: LD_ADDR_VAR 0 10
70937: PUSH
70938: LD_VAR 0 10
70942: PPUSH
70943: LD_INT 1
70945: PPUSH
70946: CALL_OW 3
70950: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
70951: LD_VAR 0 2
70955: PPUSH
70956: LD_VAR 0 5
70960: PPUSH
70961: CALL 71270 0 2
70965: PUSH
70966: LD_VAR 0 10
70970: PUSH
70971: EMPTY
70972: EQUAL
70973: OR
70974: IFFALSE 70919
// result := [ ] ;
70976: LD_ADDR_VAR 0 6
70980: PUSH
70981: EMPTY
70982: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70983: LD_VAR 0 1
70987: PPUSH
70988: LD_VAR 0 2
70992: PPUSH
70993: LD_VAR 0 3
70997: PPUSH
70998: LD_VAR 0 4
71002: PPUSH
71003: LD_VAR 0 5
71007: PPUSH
71008: CALL_OW 448
71012: IFFALSE 71045
// result := [ chassis , engine , control , weapon ] ;
71014: LD_ADDR_VAR 0 6
71018: PUSH
71019: LD_VAR 0 2
71023: PUSH
71024: LD_VAR 0 3
71028: PUSH
71029: LD_VAR 0 4
71033: PUSH
71034: LD_VAR 0 5
71038: PUSH
71039: EMPTY
71040: LIST
71041: LIST
71042: LIST
71043: LIST
71044: ST_TO_ADDR
// end ;
71045: LD_VAR 0 6
71049: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
71050: LD_INT 0
71052: PPUSH
// if not chassis or not engine then
71053: LD_VAR 0 1
71057: NOT
71058: PUSH
71059: LD_VAR 0 2
71063: NOT
71064: OR
71065: IFFALSE 71069
// exit ;
71067: GO 71265
// case engine of engine_solar :
71069: LD_VAR 0 2
71073: PUSH
71074: LD_INT 2
71076: DOUBLE
71077: EQUAL
71078: IFTRUE 71082
71080: GO 71120
71082: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
71083: LD_ADDR_VAR 0 3
71087: PUSH
71088: LD_INT 11
71090: PUSH
71091: LD_INT 12
71093: PUSH
71094: LD_INT 13
71096: PUSH
71097: LD_INT 14
71099: PUSH
71100: LD_INT 1
71102: PUSH
71103: LD_INT 2
71105: PUSH
71106: LD_INT 3
71108: PUSH
71109: EMPTY
71110: LIST
71111: LIST
71112: LIST
71113: LIST
71114: LIST
71115: LIST
71116: LIST
71117: ST_TO_ADDR
71118: GO 71249
71120: LD_INT 1
71122: DOUBLE
71123: EQUAL
71124: IFTRUE 71128
71126: GO 71190
71128: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
71129: LD_ADDR_VAR 0 3
71133: PUSH
71134: LD_INT 11
71136: PUSH
71137: LD_INT 12
71139: PUSH
71140: LD_INT 13
71142: PUSH
71143: LD_INT 14
71145: PUSH
71146: LD_INT 1
71148: PUSH
71149: LD_INT 2
71151: PUSH
71152: LD_INT 3
71154: PUSH
71155: LD_INT 4
71157: PUSH
71158: LD_INT 5
71160: PUSH
71161: LD_INT 21
71163: PUSH
71164: LD_INT 23
71166: PUSH
71167: LD_INT 22
71169: PUSH
71170: LD_INT 24
71172: PUSH
71173: EMPTY
71174: LIST
71175: LIST
71176: LIST
71177: LIST
71178: LIST
71179: LIST
71180: LIST
71181: LIST
71182: LIST
71183: LIST
71184: LIST
71185: LIST
71186: LIST
71187: ST_TO_ADDR
71188: GO 71249
71190: LD_INT 3
71192: DOUBLE
71193: EQUAL
71194: IFTRUE 71198
71196: GO 71248
71198: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
71199: LD_ADDR_VAR 0 3
71203: PUSH
71204: LD_INT 13
71206: PUSH
71207: LD_INT 14
71209: PUSH
71210: LD_INT 2
71212: PUSH
71213: LD_INT 3
71215: PUSH
71216: LD_INT 4
71218: PUSH
71219: LD_INT 5
71221: PUSH
71222: LD_INT 21
71224: PUSH
71225: LD_INT 22
71227: PUSH
71228: LD_INT 23
71230: PUSH
71231: LD_INT 24
71233: PUSH
71234: EMPTY
71235: LIST
71236: LIST
71237: LIST
71238: LIST
71239: LIST
71240: LIST
71241: LIST
71242: LIST
71243: LIST
71244: LIST
71245: ST_TO_ADDR
71246: GO 71249
71248: POP
// result := ( chassis in result ) ;
71249: LD_ADDR_VAR 0 3
71253: PUSH
71254: LD_VAR 0 1
71258: PUSH
71259: LD_VAR 0 3
71263: IN
71264: ST_TO_ADDR
// end ;
71265: LD_VAR 0 3
71269: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
71270: LD_INT 0
71272: PPUSH
// if not chassis or not weapon then
71273: LD_VAR 0 1
71277: NOT
71278: PUSH
71279: LD_VAR 0 2
71283: NOT
71284: OR
71285: IFFALSE 71289
// exit ;
71287: GO 72349
// case weapon of us_machine_gun :
71289: LD_VAR 0 2
71293: PUSH
71294: LD_INT 2
71296: DOUBLE
71297: EQUAL
71298: IFTRUE 71302
71300: GO 71332
71302: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
71303: LD_ADDR_VAR 0 3
71307: PUSH
71308: LD_INT 1
71310: PUSH
71311: LD_INT 2
71313: PUSH
71314: LD_INT 3
71316: PUSH
71317: LD_INT 4
71319: PUSH
71320: LD_INT 5
71322: PUSH
71323: EMPTY
71324: LIST
71325: LIST
71326: LIST
71327: LIST
71328: LIST
71329: ST_TO_ADDR
71330: GO 72333
71332: LD_INT 3
71334: DOUBLE
71335: EQUAL
71336: IFTRUE 71340
71338: GO 71370
71340: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
71341: LD_ADDR_VAR 0 3
71345: PUSH
71346: LD_INT 1
71348: PUSH
71349: LD_INT 2
71351: PUSH
71352: LD_INT 3
71354: PUSH
71355: LD_INT 4
71357: PUSH
71358: LD_INT 5
71360: PUSH
71361: EMPTY
71362: LIST
71363: LIST
71364: LIST
71365: LIST
71366: LIST
71367: ST_TO_ADDR
71368: GO 72333
71370: LD_INT 11
71372: DOUBLE
71373: EQUAL
71374: IFTRUE 71378
71376: GO 71408
71378: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
71379: LD_ADDR_VAR 0 3
71383: PUSH
71384: LD_INT 1
71386: PUSH
71387: LD_INT 2
71389: PUSH
71390: LD_INT 3
71392: PUSH
71393: LD_INT 4
71395: PUSH
71396: LD_INT 5
71398: PUSH
71399: EMPTY
71400: LIST
71401: LIST
71402: LIST
71403: LIST
71404: LIST
71405: ST_TO_ADDR
71406: GO 72333
71408: LD_INT 4
71410: DOUBLE
71411: EQUAL
71412: IFTRUE 71416
71414: GO 71442
71416: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
71417: LD_ADDR_VAR 0 3
71421: PUSH
71422: LD_INT 2
71424: PUSH
71425: LD_INT 3
71427: PUSH
71428: LD_INT 4
71430: PUSH
71431: LD_INT 5
71433: PUSH
71434: EMPTY
71435: LIST
71436: LIST
71437: LIST
71438: LIST
71439: ST_TO_ADDR
71440: GO 72333
71442: LD_INT 5
71444: DOUBLE
71445: EQUAL
71446: IFTRUE 71450
71448: GO 71476
71450: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
71451: LD_ADDR_VAR 0 3
71455: PUSH
71456: LD_INT 2
71458: PUSH
71459: LD_INT 3
71461: PUSH
71462: LD_INT 4
71464: PUSH
71465: LD_INT 5
71467: PUSH
71468: EMPTY
71469: LIST
71470: LIST
71471: LIST
71472: LIST
71473: ST_TO_ADDR
71474: GO 72333
71476: LD_INT 9
71478: DOUBLE
71479: EQUAL
71480: IFTRUE 71484
71482: GO 71510
71484: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
71485: LD_ADDR_VAR 0 3
71489: PUSH
71490: LD_INT 2
71492: PUSH
71493: LD_INT 3
71495: PUSH
71496: LD_INT 4
71498: PUSH
71499: LD_INT 5
71501: PUSH
71502: EMPTY
71503: LIST
71504: LIST
71505: LIST
71506: LIST
71507: ST_TO_ADDR
71508: GO 72333
71510: LD_INT 7
71512: DOUBLE
71513: EQUAL
71514: IFTRUE 71518
71516: GO 71544
71518: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
71519: LD_ADDR_VAR 0 3
71523: PUSH
71524: LD_INT 2
71526: PUSH
71527: LD_INT 3
71529: PUSH
71530: LD_INT 4
71532: PUSH
71533: LD_INT 5
71535: PUSH
71536: EMPTY
71537: LIST
71538: LIST
71539: LIST
71540: LIST
71541: ST_TO_ADDR
71542: GO 72333
71544: LD_INT 12
71546: DOUBLE
71547: EQUAL
71548: IFTRUE 71552
71550: GO 71578
71552: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
71553: LD_ADDR_VAR 0 3
71557: PUSH
71558: LD_INT 2
71560: PUSH
71561: LD_INT 3
71563: PUSH
71564: LD_INT 4
71566: PUSH
71567: LD_INT 5
71569: PUSH
71570: EMPTY
71571: LIST
71572: LIST
71573: LIST
71574: LIST
71575: ST_TO_ADDR
71576: GO 72333
71578: LD_INT 13
71580: DOUBLE
71581: EQUAL
71582: IFTRUE 71586
71584: GO 71612
71586: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
71587: LD_ADDR_VAR 0 3
71591: PUSH
71592: LD_INT 2
71594: PUSH
71595: LD_INT 3
71597: PUSH
71598: LD_INT 4
71600: PUSH
71601: LD_INT 5
71603: PUSH
71604: EMPTY
71605: LIST
71606: LIST
71607: LIST
71608: LIST
71609: ST_TO_ADDR
71610: GO 72333
71612: LD_INT 14
71614: DOUBLE
71615: EQUAL
71616: IFTRUE 71620
71618: GO 71638
71620: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
71621: LD_ADDR_VAR 0 3
71625: PUSH
71626: LD_INT 4
71628: PUSH
71629: LD_INT 5
71631: PUSH
71632: EMPTY
71633: LIST
71634: LIST
71635: ST_TO_ADDR
71636: GO 72333
71638: LD_INT 6
71640: DOUBLE
71641: EQUAL
71642: IFTRUE 71646
71644: GO 71664
71646: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
71647: LD_ADDR_VAR 0 3
71651: PUSH
71652: LD_INT 4
71654: PUSH
71655: LD_INT 5
71657: PUSH
71658: EMPTY
71659: LIST
71660: LIST
71661: ST_TO_ADDR
71662: GO 72333
71664: LD_INT 10
71666: DOUBLE
71667: EQUAL
71668: IFTRUE 71672
71670: GO 71690
71672: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
71673: LD_ADDR_VAR 0 3
71677: PUSH
71678: LD_INT 4
71680: PUSH
71681: LD_INT 5
71683: PUSH
71684: EMPTY
71685: LIST
71686: LIST
71687: ST_TO_ADDR
71688: GO 72333
71690: LD_INT 22
71692: DOUBLE
71693: EQUAL
71694: IFTRUE 71698
71696: GO 71724
71698: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
71699: LD_ADDR_VAR 0 3
71703: PUSH
71704: LD_INT 11
71706: PUSH
71707: LD_INT 12
71709: PUSH
71710: LD_INT 13
71712: PUSH
71713: LD_INT 14
71715: PUSH
71716: EMPTY
71717: LIST
71718: LIST
71719: LIST
71720: LIST
71721: ST_TO_ADDR
71722: GO 72333
71724: LD_INT 23
71726: DOUBLE
71727: EQUAL
71728: IFTRUE 71732
71730: GO 71758
71732: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
71733: LD_ADDR_VAR 0 3
71737: PUSH
71738: LD_INT 11
71740: PUSH
71741: LD_INT 12
71743: PUSH
71744: LD_INT 13
71746: PUSH
71747: LD_INT 14
71749: PUSH
71750: EMPTY
71751: LIST
71752: LIST
71753: LIST
71754: LIST
71755: ST_TO_ADDR
71756: GO 72333
71758: LD_INT 24
71760: DOUBLE
71761: EQUAL
71762: IFTRUE 71766
71764: GO 71792
71766: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
71767: LD_ADDR_VAR 0 3
71771: PUSH
71772: LD_INT 11
71774: PUSH
71775: LD_INT 12
71777: PUSH
71778: LD_INT 13
71780: PUSH
71781: LD_INT 14
71783: PUSH
71784: EMPTY
71785: LIST
71786: LIST
71787: LIST
71788: LIST
71789: ST_TO_ADDR
71790: GO 72333
71792: LD_INT 30
71794: DOUBLE
71795: EQUAL
71796: IFTRUE 71800
71798: GO 71826
71800: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
71801: LD_ADDR_VAR 0 3
71805: PUSH
71806: LD_INT 11
71808: PUSH
71809: LD_INT 12
71811: PUSH
71812: LD_INT 13
71814: PUSH
71815: LD_INT 14
71817: PUSH
71818: EMPTY
71819: LIST
71820: LIST
71821: LIST
71822: LIST
71823: ST_TO_ADDR
71824: GO 72333
71826: LD_INT 25
71828: DOUBLE
71829: EQUAL
71830: IFTRUE 71834
71832: GO 71852
71834: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
71835: LD_ADDR_VAR 0 3
71839: PUSH
71840: LD_INT 13
71842: PUSH
71843: LD_INT 14
71845: PUSH
71846: EMPTY
71847: LIST
71848: LIST
71849: ST_TO_ADDR
71850: GO 72333
71852: LD_INT 27
71854: DOUBLE
71855: EQUAL
71856: IFTRUE 71860
71858: GO 71878
71860: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
71861: LD_ADDR_VAR 0 3
71865: PUSH
71866: LD_INT 13
71868: PUSH
71869: LD_INT 14
71871: PUSH
71872: EMPTY
71873: LIST
71874: LIST
71875: ST_TO_ADDR
71876: GO 72333
71878: LD_INT 92
71880: DOUBLE
71881: EQUAL
71882: IFTRUE 71886
71884: GO 71912
71886: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
71887: LD_ADDR_VAR 0 3
71891: PUSH
71892: LD_INT 11
71894: PUSH
71895: LD_INT 12
71897: PUSH
71898: LD_INT 13
71900: PUSH
71901: LD_INT 14
71903: PUSH
71904: EMPTY
71905: LIST
71906: LIST
71907: LIST
71908: LIST
71909: ST_TO_ADDR
71910: GO 72333
71912: LD_INT 28
71914: DOUBLE
71915: EQUAL
71916: IFTRUE 71920
71918: GO 71938
71920: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
71921: LD_ADDR_VAR 0 3
71925: PUSH
71926: LD_INT 13
71928: PUSH
71929: LD_INT 14
71931: PUSH
71932: EMPTY
71933: LIST
71934: LIST
71935: ST_TO_ADDR
71936: GO 72333
71938: LD_INT 29
71940: DOUBLE
71941: EQUAL
71942: IFTRUE 71946
71944: GO 71964
71946: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
71947: LD_ADDR_VAR 0 3
71951: PUSH
71952: LD_INT 13
71954: PUSH
71955: LD_INT 14
71957: PUSH
71958: EMPTY
71959: LIST
71960: LIST
71961: ST_TO_ADDR
71962: GO 72333
71964: LD_INT 31
71966: DOUBLE
71967: EQUAL
71968: IFTRUE 71972
71970: GO 71990
71972: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
71973: LD_ADDR_VAR 0 3
71977: PUSH
71978: LD_INT 13
71980: PUSH
71981: LD_INT 14
71983: PUSH
71984: EMPTY
71985: LIST
71986: LIST
71987: ST_TO_ADDR
71988: GO 72333
71990: LD_INT 26
71992: DOUBLE
71993: EQUAL
71994: IFTRUE 71998
71996: GO 72016
71998: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
71999: LD_ADDR_VAR 0 3
72003: PUSH
72004: LD_INT 13
72006: PUSH
72007: LD_INT 14
72009: PUSH
72010: EMPTY
72011: LIST
72012: LIST
72013: ST_TO_ADDR
72014: GO 72333
72016: LD_INT 42
72018: DOUBLE
72019: EQUAL
72020: IFTRUE 72024
72022: GO 72050
72024: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
72025: LD_ADDR_VAR 0 3
72029: PUSH
72030: LD_INT 21
72032: PUSH
72033: LD_INT 22
72035: PUSH
72036: LD_INT 23
72038: PUSH
72039: LD_INT 24
72041: PUSH
72042: EMPTY
72043: LIST
72044: LIST
72045: LIST
72046: LIST
72047: ST_TO_ADDR
72048: GO 72333
72050: LD_INT 43
72052: DOUBLE
72053: EQUAL
72054: IFTRUE 72058
72056: GO 72084
72058: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
72059: LD_ADDR_VAR 0 3
72063: PUSH
72064: LD_INT 21
72066: PUSH
72067: LD_INT 22
72069: PUSH
72070: LD_INT 23
72072: PUSH
72073: LD_INT 24
72075: PUSH
72076: EMPTY
72077: LIST
72078: LIST
72079: LIST
72080: LIST
72081: ST_TO_ADDR
72082: GO 72333
72084: LD_INT 44
72086: DOUBLE
72087: EQUAL
72088: IFTRUE 72092
72090: GO 72118
72092: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
72093: LD_ADDR_VAR 0 3
72097: PUSH
72098: LD_INT 21
72100: PUSH
72101: LD_INT 22
72103: PUSH
72104: LD_INT 23
72106: PUSH
72107: LD_INT 24
72109: PUSH
72110: EMPTY
72111: LIST
72112: LIST
72113: LIST
72114: LIST
72115: ST_TO_ADDR
72116: GO 72333
72118: LD_INT 45
72120: DOUBLE
72121: EQUAL
72122: IFTRUE 72126
72124: GO 72152
72126: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
72127: LD_ADDR_VAR 0 3
72131: PUSH
72132: LD_INT 21
72134: PUSH
72135: LD_INT 22
72137: PUSH
72138: LD_INT 23
72140: PUSH
72141: LD_INT 24
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: LIST
72148: LIST
72149: ST_TO_ADDR
72150: GO 72333
72152: LD_INT 49
72154: DOUBLE
72155: EQUAL
72156: IFTRUE 72160
72158: GO 72186
72160: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
72161: LD_ADDR_VAR 0 3
72165: PUSH
72166: LD_INT 21
72168: PUSH
72169: LD_INT 22
72171: PUSH
72172: LD_INT 23
72174: PUSH
72175: LD_INT 24
72177: PUSH
72178: EMPTY
72179: LIST
72180: LIST
72181: LIST
72182: LIST
72183: ST_TO_ADDR
72184: GO 72333
72186: LD_INT 51
72188: DOUBLE
72189: EQUAL
72190: IFTRUE 72194
72192: GO 72220
72194: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
72195: LD_ADDR_VAR 0 3
72199: PUSH
72200: LD_INT 21
72202: PUSH
72203: LD_INT 22
72205: PUSH
72206: LD_INT 23
72208: PUSH
72209: LD_INT 24
72211: PUSH
72212: EMPTY
72213: LIST
72214: LIST
72215: LIST
72216: LIST
72217: ST_TO_ADDR
72218: GO 72333
72220: LD_INT 52
72222: DOUBLE
72223: EQUAL
72224: IFTRUE 72228
72226: GO 72254
72228: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
72229: LD_ADDR_VAR 0 3
72233: PUSH
72234: LD_INT 21
72236: PUSH
72237: LD_INT 22
72239: PUSH
72240: LD_INT 23
72242: PUSH
72243: LD_INT 24
72245: PUSH
72246: EMPTY
72247: LIST
72248: LIST
72249: LIST
72250: LIST
72251: ST_TO_ADDR
72252: GO 72333
72254: LD_INT 53
72256: DOUBLE
72257: EQUAL
72258: IFTRUE 72262
72260: GO 72280
72262: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
72263: LD_ADDR_VAR 0 3
72267: PUSH
72268: LD_INT 23
72270: PUSH
72271: LD_INT 24
72273: PUSH
72274: EMPTY
72275: LIST
72276: LIST
72277: ST_TO_ADDR
72278: GO 72333
72280: LD_INT 46
72282: DOUBLE
72283: EQUAL
72284: IFTRUE 72288
72286: GO 72306
72288: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
72289: LD_ADDR_VAR 0 3
72293: PUSH
72294: LD_INT 23
72296: PUSH
72297: LD_INT 24
72299: PUSH
72300: EMPTY
72301: LIST
72302: LIST
72303: ST_TO_ADDR
72304: GO 72333
72306: LD_INT 47
72308: DOUBLE
72309: EQUAL
72310: IFTRUE 72314
72312: GO 72332
72314: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
72315: LD_ADDR_VAR 0 3
72319: PUSH
72320: LD_INT 23
72322: PUSH
72323: LD_INT 24
72325: PUSH
72326: EMPTY
72327: LIST
72328: LIST
72329: ST_TO_ADDR
72330: GO 72333
72332: POP
// result := ( chassis in result ) ;
72333: LD_ADDR_VAR 0 3
72337: PUSH
72338: LD_VAR 0 1
72342: PUSH
72343: LD_VAR 0 3
72347: IN
72348: ST_TO_ADDR
// end ;
72349: LD_VAR 0 3
72353: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
72354: LD_INT 0
72356: PPUSH
72357: PPUSH
72358: PPUSH
72359: PPUSH
72360: PPUSH
72361: PPUSH
72362: PPUSH
// result := array ;
72363: LD_ADDR_VAR 0 5
72367: PUSH
72368: LD_VAR 0 1
72372: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
72373: LD_VAR 0 1
72377: NOT
72378: PUSH
72379: LD_VAR 0 2
72383: NOT
72384: OR
72385: PUSH
72386: LD_VAR 0 3
72390: NOT
72391: OR
72392: PUSH
72393: LD_VAR 0 2
72397: PUSH
72398: LD_VAR 0 1
72402: GREATER
72403: OR
72404: PUSH
72405: LD_VAR 0 3
72409: PUSH
72410: LD_VAR 0 1
72414: GREATER
72415: OR
72416: IFFALSE 72420
// exit ;
72418: GO 72716
// if direction then
72420: LD_VAR 0 4
72424: IFFALSE 72488
// begin d := 1 ;
72426: LD_ADDR_VAR 0 9
72430: PUSH
72431: LD_INT 1
72433: ST_TO_ADDR
// if i_from > i_to then
72434: LD_VAR 0 2
72438: PUSH
72439: LD_VAR 0 3
72443: GREATER
72444: IFFALSE 72470
// length := ( array - i_from ) + i_to else
72446: LD_ADDR_VAR 0 11
72450: PUSH
72451: LD_VAR 0 1
72455: PUSH
72456: LD_VAR 0 2
72460: MINUS
72461: PUSH
72462: LD_VAR 0 3
72466: PLUS
72467: ST_TO_ADDR
72468: GO 72486
// length := i_to - i_from ;
72470: LD_ADDR_VAR 0 11
72474: PUSH
72475: LD_VAR 0 3
72479: PUSH
72480: LD_VAR 0 2
72484: MINUS
72485: ST_TO_ADDR
// end else
72486: GO 72549
// begin d := - 1 ;
72488: LD_ADDR_VAR 0 9
72492: PUSH
72493: LD_INT 1
72495: NEG
72496: ST_TO_ADDR
// if i_from > i_to then
72497: LD_VAR 0 2
72501: PUSH
72502: LD_VAR 0 3
72506: GREATER
72507: IFFALSE 72527
// length := i_from - i_to else
72509: LD_ADDR_VAR 0 11
72513: PUSH
72514: LD_VAR 0 2
72518: PUSH
72519: LD_VAR 0 3
72523: MINUS
72524: ST_TO_ADDR
72525: GO 72549
// length := ( array - i_to ) + i_from ;
72527: LD_ADDR_VAR 0 11
72531: PUSH
72532: LD_VAR 0 1
72536: PUSH
72537: LD_VAR 0 3
72541: MINUS
72542: PUSH
72543: LD_VAR 0 2
72547: PLUS
72548: ST_TO_ADDR
// end ; if not length then
72549: LD_VAR 0 11
72553: NOT
72554: IFFALSE 72558
// exit ;
72556: GO 72716
// tmp := array ;
72558: LD_ADDR_VAR 0 10
72562: PUSH
72563: LD_VAR 0 1
72567: ST_TO_ADDR
// for i = 1 to length do
72568: LD_ADDR_VAR 0 6
72572: PUSH
72573: DOUBLE
72574: LD_INT 1
72576: DEC
72577: ST_TO_ADDR
72578: LD_VAR 0 11
72582: PUSH
72583: FOR_TO
72584: IFFALSE 72704
// begin for j = 1 to array do
72586: LD_ADDR_VAR 0 7
72590: PUSH
72591: DOUBLE
72592: LD_INT 1
72594: DEC
72595: ST_TO_ADDR
72596: LD_VAR 0 1
72600: PUSH
72601: FOR_TO
72602: IFFALSE 72690
// begin k := j + d ;
72604: LD_ADDR_VAR 0 8
72608: PUSH
72609: LD_VAR 0 7
72613: PUSH
72614: LD_VAR 0 9
72618: PLUS
72619: ST_TO_ADDR
// if k > array then
72620: LD_VAR 0 8
72624: PUSH
72625: LD_VAR 0 1
72629: GREATER
72630: IFFALSE 72640
// k := 1 ;
72632: LD_ADDR_VAR 0 8
72636: PUSH
72637: LD_INT 1
72639: ST_TO_ADDR
// if not k then
72640: LD_VAR 0 8
72644: NOT
72645: IFFALSE 72657
// k := array ;
72647: LD_ADDR_VAR 0 8
72651: PUSH
72652: LD_VAR 0 1
72656: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
72657: LD_ADDR_VAR 0 10
72661: PUSH
72662: LD_VAR 0 10
72666: PPUSH
72667: LD_VAR 0 8
72671: PPUSH
72672: LD_VAR 0 1
72676: PUSH
72677: LD_VAR 0 7
72681: ARRAY
72682: PPUSH
72683: CALL_OW 1
72687: ST_TO_ADDR
// end ;
72688: GO 72601
72690: POP
72691: POP
// array := tmp ;
72692: LD_ADDR_VAR 0 1
72696: PUSH
72697: LD_VAR 0 10
72701: ST_TO_ADDR
// end ;
72702: GO 72583
72704: POP
72705: POP
// result := array ;
72706: LD_ADDR_VAR 0 5
72710: PUSH
72711: LD_VAR 0 1
72715: ST_TO_ADDR
// end ;
72716: LD_VAR 0 5
72720: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
72721: LD_INT 0
72723: PPUSH
72724: PPUSH
// result := 0 ;
72725: LD_ADDR_VAR 0 3
72729: PUSH
72730: LD_INT 0
72732: ST_TO_ADDR
// if not array or not value in array then
72733: LD_VAR 0 1
72737: NOT
72738: PUSH
72739: LD_VAR 0 2
72743: PUSH
72744: LD_VAR 0 1
72748: IN
72749: NOT
72750: OR
72751: IFFALSE 72755
// exit ;
72753: GO 72809
// for i = 1 to array do
72755: LD_ADDR_VAR 0 4
72759: PUSH
72760: DOUBLE
72761: LD_INT 1
72763: DEC
72764: ST_TO_ADDR
72765: LD_VAR 0 1
72769: PUSH
72770: FOR_TO
72771: IFFALSE 72807
// if value = array [ i ] then
72773: LD_VAR 0 2
72777: PUSH
72778: LD_VAR 0 1
72782: PUSH
72783: LD_VAR 0 4
72787: ARRAY
72788: EQUAL
72789: IFFALSE 72805
// begin result := i ;
72791: LD_ADDR_VAR 0 3
72795: PUSH
72796: LD_VAR 0 4
72800: ST_TO_ADDR
// exit ;
72801: POP
72802: POP
72803: GO 72809
// end ;
72805: GO 72770
72807: POP
72808: POP
// end ;
72809: LD_VAR 0 3
72813: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
72814: LD_INT 0
72816: PPUSH
// vc_chassis := chassis ;
72817: LD_ADDR_OWVAR 37
72821: PUSH
72822: LD_VAR 0 1
72826: ST_TO_ADDR
// vc_engine := engine ;
72827: LD_ADDR_OWVAR 39
72831: PUSH
72832: LD_VAR 0 2
72836: ST_TO_ADDR
// vc_control := control ;
72837: LD_ADDR_OWVAR 38
72841: PUSH
72842: LD_VAR 0 3
72846: ST_TO_ADDR
// vc_weapon := weapon ;
72847: LD_ADDR_OWVAR 40
72851: PUSH
72852: LD_VAR 0 4
72856: ST_TO_ADDR
// vc_fuel_battery := fuel ;
72857: LD_ADDR_OWVAR 41
72861: PUSH
72862: LD_VAR 0 5
72866: ST_TO_ADDR
// end ;
72867: LD_VAR 0 6
72871: RET
// export function WantPlant ( unit ) ; var task ; begin
72872: LD_INT 0
72874: PPUSH
72875: PPUSH
// result := false ;
72876: LD_ADDR_VAR 0 2
72880: PUSH
72881: LD_INT 0
72883: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
72884: LD_ADDR_VAR 0 3
72888: PUSH
72889: LD_VAR 0 1
72893: PPUSH
72894: CALL_OW 437
72898: ST_TO_ADDR
// if task then
72899: LD_VAR 0 3
72903: IFFALSE 72931
// if task [ 1 ] [ 1 ] = p then
72905: LD_VAR 0 3
72909: PUSH
72910: LD_INT 1
72912: ARRAY
72913: PUSH
72914: LD_INT 1
72916: ARRAY
72917: PUSH
72918: LD_STRING p
72920: EQUAL
72921: IFFALSE 72931
// result := true ;
72923: LD_ADDR_VAR 0 2
72927: PUSH
72928: LD_INT 1
72930: ST_TO_ADDR
// end ;
72931: LD_VAR 0 2
72935: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
72936: LD_INT 0
72938: PPUSH
72939: PPUSH
72940: PPUSH
72941: PPUSH
// if pos < 1 then
72942: LD_VAR 0 2
72946: PUSH
72947: LD_INT 1
72949: LESS
72950: IFFALSE 72954
// exit ;
72952: GO 73257
// if pos = 1 then
72954: LD_VAR 0 2
72958: PUSH
72959: LD_INT 1
72961: EQUAL
72962: IFFALSE 72995
// result := Replace ( arr , pos [ 1 ] , value ) else
72964: LD_ADDR_VAR 0 4
72968: PUSH
72969: LD_VAR 0 1
72973: PPUSH
72974: LD_VAR 0 2
72978: PUSH
72979: LD_INT 1
72981: ARRAY
72982: PPUSH
72983: LD_VAR 0 3
72987: PPUSH
72988: CALL_OW 1
72992: ST_TO_ADDR
72993: GO 73257
// begin tmp := arr ;
72995: LD_ADDR_VAR 0 6
72999: PUSH
73000: LD_VAR 0 1
73004: ST_TO_ADDR
// s_arr := [ tmp ] ;
73005: LD_ADDR_VAR 0 7
73009: PUSH
73010: LD_VAR 0 6
73014: PUSH
73015: EMPTY
73016: LIST
73017: ST_TO_ADDR
// for i = 1 to pos - 1 do
73018: LD_ADDR_VAR 0 5
73022: PUSH
73023: DOUBLE
73024: LD_INT 1
73026: DEC
73027: ST_TO_ADDR
73028: LD_VAR 0 2
73032: PUSH
73033: LD_INT 1
73035: MINUS
73036: PUSH
73037: FOR_TO
73038: IFFALSE 73083
// begin tmp := tmp [ pos [ i ] ] ;
73040: LD_ADDR_VAR 0 6
73044: PUSH
73045: LD_VAR 0 6
73049: PUSH
73050: LD_VAR 0 2
73054: PUSH
73055: LD_VAR 0 5
73059: ARRAY
73060: ARRAY
73061: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
73062: LD_ADDR_VAR 0 7
73066: PUSH
73067: LD_VAR 0 7
73071: PUSH
73072: LD_VAR 0 6
73076: PUSH
73077: EMPTY
73078: LIST
73079: ADD
73080: ST_TO_ADDR
// end ;
73081: GO 73037
73083: POP
73084: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
73085: LD_ADDR_VAR 0 6
73089: PUSH
73090: LD_VAR 0 6
73094: PPUSH
73095: LD_VAR 0 2
73099: PUSH
73100: LD_VAR 0 2
73104: ARRAY
73105: PPUSH
73106: LD_VAR 0 3
73110: PPUSH
73111: CALL_OW 1
73115: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
73116: LD_ADDR_VAR 0 7
73120: PUSH
73121: LD_VAR 0 7
73125: PPUSH
73126: LD_VAR 0 7
73130: PPUSH
73131: LD_VAR 0 6
73135: PPUSH
73136: CALL_OW 1
73140: ST_TO_ADDR
// for i = s_arr downto 2 do
73141: LD_ADDR_VAR 0 5
73145: PUSH
73146: DOUBLE
73147: LD_VAR 0 7
73151: INC
73152: ST_TO_ADDR
73153: LD_INT 2
73155: PUSH
73156: FOR_DOWNTO
73157: IFFALSE 73241
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
73159: LD_ADDR_VAR 0 6
73163: PUSH
73164: LD_VAR 0 7
73168: PUSH
73169: LD_VAR 0 5
73173: PUSH
73174: LD_INT 1
73176: MINUS
73177: ARRAY
73178: PPUSH
73179: LD_VAR 0 2
73183: PUSH
73184: LD_VAR 0 5
73188: PUSH
73189: LD_INT 1
73191: MINUS
73192: ARRAY
73193: PPUSH
73194: LD_VAR 0 7
73198: PUSH
73199: LD_VAR 0 5
73203: ARRAY
73204: PPUSH
73205: CALL_OW 1
73209: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
73210: LD_ADDR_VAR 0 7
73214: PUSH
73215: LD_VAR 0 7
73219: PPUSH
73220: LD_VAR 0 5
73224: PUSH
73225: LD_INT 1
73227: MINUS
73228: PPUSH
73229: LD_VAR 0 6
73233: PPUSH
73234: CALL_OW 1
73238: ST_TO_ADDR
// end ;
73239: GO 73156
73241: POP
73242: POP
// result := s_arr [ 1 ] ;
73243: LD_ADDR_VAR 0 4
73247: PUSH
73248: LD_VAR 0 7
73252: PUSH
73253: LD_INT 1
73255: ARRAY
73256: ST_TO_ADDR
// end ; end ;
73257: LD_VAR 0 4
73261: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
73262: LD_INT 0
73264: PPUSH
73265: PPUSH
// if not list then
73266: LD_VAR 0 1
73270: NOT
73271: IFFALSE 73275
// exit ;
73273: GO 73366
// i := list [ pos1 ] ;
73275: LD_ADDR_VAR 0 5
73279: PUSH
73280: LD_VAR 0 1
73284: PUSH
73285: LD_VAR 0 2
73289: ARRAY
73290: ST_TO_ADDR
// if not i then
73291: LD_VAR 0 5
73295: NOT
73296: IFFALSE 73300
// exit ;
73298: GO 73366
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
73300: LD_ADDR_VAR 0 1
73304: PUSH
73305: LD_VAR 0 1
73309: PPUSH
73310: LD_VAR 0 2
73314: PPUSH
73315: LD_VAR 0 1
73319: PUSH
73320: LD_VAR 0 3
73324: ARRAY
73325: PPUSH
73326: CALL_OW 1
73330: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
73331: LD_ADDR_VAR 0 1
73335: PUSH
73336: LD_VAR 0 1
73340: PPUSH
73341: LD_VAR 0 3
73345: PPUSH
73346: LD_VAR 0 5
73350: PPUSH
73351: CALL_OW 1
73355: ST_TO_ADDR
// result := list ;
73356: LD_ADDR_VAR 0 4
73360: PUSH
73361: LD_VAR 0 1
73365: ST_TO_ADDR
// end ;
73366: LD_VAR 0 4
73370: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
73371: LD_INT 0
73373: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
73374: LD_ADDR_VAR 0 5
73378: PUSH
73379: LD_VAR 0 1
73383: PPUSH
73384: CALL_OW 250
73388: PPUSH
73389: LD_VAR 0 1
73393: PPUSH
73394: CALL_OW 251
73398: PPUSH
73399: LD_VAR 0 2
73403: PPUSH
73404: LD_VAR 0 3
73408: PPUSH
73409: LD_VAR 0 4
73413: PPUSH
73414: CALL 73424 0 5
73418: ST_TO_ADDR
// end ;
73419: LD_VAR 0 5
73423: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
73424: LD_INT 0
73426: PPUSH
73427: PPUSH
73428: PPUSH
73429: PPUSH
// if not list then
73430: LD_VAR 0 3
73434: NOT
73435: IFFALSE 73439
// exit ;
73437: GO 73827
// result := [ ] ;
73439: LD_ADDR_VAR 0 6
73443: PUSH
73444: EMPTY
73445: ST_TO_ADDR
// for i in list do
73446: LD_ADDR_VAR 0 7
73450: PUSH
73451: LD_VAR 0 3
73455: PUSH
73456: FOR_IN
73457: IFFALSE 73659
// begin tmp := GetDistUnitXY ( i , x , y ) ;
73459: LD_ADDR_VAR 0 9
73463: PUSH
73464: LD_VAR 0 7
73468: PPUSH
73469: LD_VAR 0 1
73473: PPUSH
73474: LD_VAR 0 2
73478: PPUSH
73479: CALL_OW 297
73483: ST_TO_ADDR
// if not result then
73484: LD_VAR 0 6
73488: NOT
73489: IFFALSE 73515
// result := [ [ i , tmp ] ] else
73491: LD_ADDR_VAR 0 6
73495: PUSH
73496: LD_VAR 0 7
73500: PUSH
73501: LD_VAR 0 9
73505: PUSH
73506: EMPTY
73507: LIST
73508: LIST
73509: PUSH
73510: EMPTY
73511: LIST
73512: ST_TO_ADDR
73513: GO 73657
// begin if result [ result ] [ 2 ] < tmp then
73515: LD_VAR 0 6
73519: PUSH
73520: LD_VAR 0 6
73524: ARRAY
73525: PUSH
73526: LD_INT 2
73528: ARRAY
73529: PUSH
73530: LD_VAR 0 9
73534: LESS
73535: IFFALSE 73577
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
73537: LD_ADDR_VAR 0 6
73541: PUSH
73542: LD_VAR 0 6
73546: PPUSH
73547: LD_VAR 0 6
73551: PUSH
73552: LD_INT 1
73554: PLUS
73555: PPUSH
73556: LD_VAR 0 7
73560: PUSH
73561: LD_VAR 0 9
73565: PUSH
73566: EMPTY
73567: LIST
73568: LIST
73569: PPUSH
73570: CALL_OW 2
73574: ST_TO_ADDR
73575: GO 73657
// for j = 1 to result do
73577: LD_ADDR_VAR 0 8
73581: PUSH
73582: DOUBLE
73583: LD_INT 1
73585: DEC
73586: ST_TO_ADDR
73587: LD_VAR 0 6
73591: PUSH
73592: FOR_TO
73593: IFFALSE 73655
// begin if tmp < result [ j ] [ 2 ] then
73595: LD_VAR 0 9
73599: PUSH
73600: LD_VAR 0 6
73604: PUSH
73605: LD_VAR 0 8
73609: ARRAY
73610: PUSH
73611: LD_INT 2
73613: ARRAY
73614: LESS
73615: IFFALSE 73653
// begin result := Insert ( result , j , [ i , tmp ] ) ;
73617: LD_ADDR_VAR 0 6
73621: PUSH
73622: LD_VAR 0 6
73626: PPUSH
73627: LD_VAR 0 8
73631: PPUSH
73632: LD_VAR 0 7
73636: PUSH
73637: LD_VAR 0 9
73641: PUSH
73642: EMPTY
73643: LIST
73644: LIST
73645: PPUSH
73646: CALL_OW 2
73650: ST_TO_ADDR
// break ;
73651: GO 73655
// end ; end ;
73653: GO 73592
73655: POP
73656: POP
// end ; end ;
73657: GO 73456
73659: POP
73660: POP
// if result and not asc then
73661: LD_VAR 0 6
73665: PUSH
73666: LD_VAR 0 4
73670: NOT
73671: AND
73672: IFFALSE 73747
// begin tmp := result ;
73674: LD_ADDR_VAR 0 9
73678: PUSH
73679: LD_VAR 0 6
73683: ST_TO_ADDR
// for i = tmp downto 1 do
73684: LD_ADDR_VAR 0 7
73688: PUSH
73689: DOUBLE
73690: LD_VAR 0 9
73694: INC
73695: ST_TO_ADDR
73696: LD_INT 1
73698: PUSH
73699: FOR_DOWNTO
73700: IFFALSE 73745
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
73702: LD_ADDR_VAR 0 6
73706: PUSH
73707: LD_VAR 0 6
73711: PPUSH
73712: LD_VAR 0 9
73716: PUSH
73717: LD_VAR 0 7
73721: MINUS
73722: PUSH
73723: LD_INT 1
73725: PLUS
73726: PPUSH
73727: LD_VAR 0 9
73731: PUSH
73732: LD_VAR 0 7
73736: ARRAY
73737: PPUSH
73738: CALL_OW 1
73742: ST_TO_ADDR
73743: GO 73699
73745: POP
73746: POP
// end ; tmp := [ ] ;
73747: LD_ADDR_VAR 0 9
73751: PUSH
73752: EMPTY
73753: ST_TO_ADDR
// if mode then
73754: LD_VAR 0 5
73758: IFFALSE 73827
// begin for i = 1 to result do
73760: LD_ADDR_VAR 0 7
73764: PUSH
73765: DOUBLE
73766: LD_INT 1
73768: DEC
73769: ST_TO_ADDR
73770: LD_VAR 0 6
73774: PUSH
73775: FOR_TO
73776: IFFALSE 73815
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
73778: LD_ADDR_VAR 0 9
73782: PUSH
73783: LD_VAR 0 9
73787: PPUSH
73788: LD_VAR 0 7
73792: PPUSH
73793: LD_VAR 0 6
73797: PUSH
73798: LD_VAR 0 7
73802: ARRAY
73803: PUSH
73804: LD_INT 1
73806: ARRAY
73807: PPUSH
73808: CALL_OW 1
73812: ST_TO_ADDR
73813: GO 73775
73815: POP
73816: POP
// result := tmp ;
73817: LD_ADDR_VAR 0 6
73821: PUSH
73822: LD_VAR 0 9
73826: ST_TO_ADDR
// end ; end ;
73827: LD_VAR 0 6
73831: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
73832: LD_INT 0
73834: PPUSH
73835: PPUSH
73836: PPUSH
73837: PPUSH
73838: PPUSH
73839: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
73840: LD_ADDR_VAR 0 5
73844: PUSH
73845: LD_INT 0
73847: PUSH
73848: LD_INT 0
73850: PUSH
73851: LD_INT 0
73853: PUSH
73854: EMPTY
73855: PUSH
73856: EMPTY
73857: LIST
73858: LIST
73859: LIST
73860: LIST
73861: ST_TO_ADDR
// if not x or not y then
73862: LD_VAR 0 2
73866: NOT
73867: PUSH
73868: LD_VAR 0 3
73872: NOT
73873: OR
73874: IFFALSE 73878
// exit ;
73876: GO 75528
// if not range then
73878: LD_VAR 0 4
73882: NOT
73883: IFFALSE 73893
// range := 10 ;
73885: LD_ADDR_VAR 0 4
73889: PUSH
73890: LD_INT 10
73892: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
73893: LD_ADDR_VAR 0 8
73897: PUSH
73898: LD_INT 81
73900: PUSH
73901: LD_VAR 0 1
73905: PUSH
73906: EMPTY
73907: LIST
73908: LIST
73909: PUSH
73910: LD_INT 92
73912: PUSH
73913: LD_VAR 0 2
73917: PUSH
73918: LD_VAR 0 3
73922: PUSH
73923: LD_VAR 0 4
73927: PUSH
73928: EMPTY
73929: LIST
73930: LIST
73931: LIST
73932: LIST
73933: PUSH
73934: LD_INT 3
73936: PUSH
73937: LD_INT 21
73939: PUSH
73940: LD_INT 3
73942: PUSH
73943: EMPTY
73944: LIST
73945: LIST
73946: PUSH
73947: EMPTY
73948: LIST
73949: LIST
73950: PUSH
73951: EMPTY
73952: LIST
73953: LIST
73954: LIST
73955: PPUSH
73956: CALL_OW 69
73960: ST_TO_ADDR
// if not tmp then
73961: LD_VAR 0 8
73965: NOT
73966: IFFALSE 73970
// exit ;
73968: GO 75528
// for i in tmp do
73970: LD_ADDR_VAR 0 6
73974: PUSH
73975: LD_VAR 0 8
73979: PUSH
73980: FOR_IN
73981: IFFALSE 75503
// begin points := [ 0 , 0 , 0 ] ;
73983: LD_ADDR_VAR 0 9
73987: PUSH
73988: LD_INT 0
73990: PUSH
73991: LD_INT 0
73993: PUSH
73994: LD_INT 0
73996: PUSH
73997: EMPTY
73998: LIST
73999: LIST
74000: LIST
74001: ST_TO_ADDR
// bpoints := 1 ;
74002: LD_ADDR_VAR 0 10
74006: PUSH
74007: LD_INT 1
74009: ST_TO_ADDR
// case GetType ( i ) of unit_human :
74010: LD_VAR 0 6
74014: PPUSH
74015: CALL_OW 247
74019: PUSH
74020: LD_INT 1
74022: DOUBLE
74023: EQUAL
74024: IFTRUE 74028
74026: GO 74606
74028: POP
// begin if GetClass ( i ) = 1 then
74029: LD_VAR 0 6
74033: PPUSH
74034: CALL_OW 257
74038: PUSH
74039: LD_INT 1
74041: EQUAL
74042: IFFALSE 74063
// points := [ 10 , 5 , 3 ] ;
74044: LD_ADDR_VAR 0 9
74048: PUSH
74049: LD_INT 10
74051: PUSH
74052: LD_INT 5
74054: PUSH
74055: LD_INT 3
74057: PUSH
74058: EMPTY
74059: LIST
74060: LIST
74061: LIST
74062: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
74063: LD_VAR 0 6
74067: PPUSH
74068: CALL_OW 257
74072: PUSH
74073: LD_INT 2
74075: PUSH
74076: LD_INT 3
74078: PUSH
74079: LD_INT 4
74081: PUSH
74082: EMPTY
74083: LIST
74084: LIST
74085: LIST
74086: IN
74087: IFFALSE 74108
// points := [ 3 , 2 , 1 ] ;
74089: LD_ADDR_VAR 0 9
74093: PUSH
74094: LD_INT 3
74096: PUSH
74097: LD_INT 2
74099: PUSH
74100: LD_INT 1
74102: PUSH
74103: EMPTY
74104: LIST
74105: LIST
74106: LIST
74107: ST_TO_ADDR
// if GetClass ( i ) = 5 then
74108: LD_VAR 0 6
74112: PPUSH
74113: CALL_OW 257
74117: PUSH
74118: LD_INT 5
74120: EQUAL
74121: IFFALSE 74142
// points := [ 130 , 5 , 2 ] ;
74123: LD_ADDR_VAR 0 9
74127: PUSH
74128: LD_INT 130
74130: PUSH
74131: LD_INT 5
74133: PUSH
74134: LD_INT 2
74136: PUSH
74137: EMPTY
74138: LIST
74139: LIST
74140: LIST
74141: ST_TO_ADDR
// if GetClass ( i ) = 8 then
74142: LD_VAR 0 6
74146: PPUSH
74147: CALL_OW 257
74151: PUSH
74152: LD_INT 8
74154: EQUAL
74155: IFFALSE 74176
// points := [ 35 , 35 , 30 ] ;
74157: LD_ADDR_VAR 0 9
74161: PUSH
74162: LD_INT 35
74164: PUSH
74165: LD_INT 35
74167: PUSH
74168: LD_INT 30
74170: PUSH
74171: EMPTY
74172: LIST
74173: LIST
74174: LIST
74175: ST_TO_ADDR
// if GetClass ( i ) = 9 then
74176: LD_VAR 0 6
74180: PPUSH
74181: CALL_OW 257
74185: PUSH
74186: LD_INT 9
74188: EQUAL
74189: IFFALSE 74210
// points := [ 20 , 55 , 40 ] ;
74191: LD_ADDR_VAR 0 9
74195: PUSH
74196: LD_INT 20
74198: PUSH
74199: LD_INT 55
74201: PUSH
74202: LD_INT 40
74204: PUSH
74205: EMPTY
74206: LIST
74207: LIST
74208: LIST
74209: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
74210: LD_VAR 0 6
74214: PPUSH
74215: CALL_OW 257
74219: PUSH
74220: LD_INT 12
74222: PUSH
74223: LD_INT 16
74225: PUSH
74226: EMPTY
74227: LIST
74228: LIST
74229: IN
74230: IFFALSE 74251
// points := [ 5 , 3 , 2 ] ;
74232: LD_ADDR_VAR 0 9
74236: PUSH
74237: LD_INT 5
74239: PUSH
74240: LD_INT 3
74242: PUSH
74243: LD_INT 2
74245: PUSH
74246: EMPTY
74247: LIST
74248: LIST
74249: LIST
74250: ST_TO_ADDR
// if GetClass ( i ) = 17 then
74251: LD_VAR 0 6
74255: PPUSH
74256: CALL_OW 257
74260: PUSH
74261: LD_INT 17
74263: EQUAL
74264: IFFALSE 74285
// points := [ 100 , 50 , 75 ] ;
74266: LD_ADDR_VAR 0 9
74270: PUSH
74271: LD_INT 100
74273: PUSH
74274: LD_INT 50
74276: PUSH
74277: LD_INT 75
74279: PUSH
74280: EMPTY
74281: LIST
74282: LIST
74283: LIST
74284: ST_TO_ADDR
// if GetClass ( i ) = 15 then
74285: LD_VAR 0 6
74289: PPUSH
74290: CALL_OW 257
74294: PUSH
74295: LD_INT 15
74297: EQUAL
74298: IFFALSE 74319
// points := [ 10 , 5 , 3 ] ;
74300: LD_ADDR_VAR 0 9
74304: PUSH
74305: LD_INT 10
74307: PUSH
74308: LD_INT 5
74310: PUSH
74311: LD_INT 3
74313: PUSH
74314: EMPTY
74315: LIST
74316: LIST
74317: LIST
74318: ST_TO_ADDR
// if GetClass ( i ) = 14 then
74319: LD_VAR 0 6
74323: PPUSH
74324: CALL_OW 257
74328: PUSH
74329: LD_INT 14
74331: EQUAL
74332: IFFALSE 74353
// points := [ 10 , 0 , 0 ] ;
74334: LD_ADDR_VAR 0 9
74338: PUSH
74339: LD_INT 10
74341: PUSH
74342: LD_INT 0
74344: PUSH
74345: LD_INT 0
74347: PUSH
74348: EMPTY
74349: LIST
74350: LIST
74351: LIST
74352: ST_TO_ADDR
// if GetClass ( i ) = 11 then
74353: LD_VAR 0 6
74357: PPUSH
74358: CALL_OW 257
74362: PUSH
74363: LD_INT 11
74365: EQUAL
74366: IFFALSE 74387
// points := [ 30 , 10 , 5 ] ;
74368: LD_ADDR_VAR 0 9
74372: PUSH
74373: LD_INT 30
74375: PUSH
74376: LD_INT 10
74378: PUSH
74379: LD_INT 5
74381: PUSH
74382: EMPTY
74383: LIST
74384: LIST
74385: LIST
74386: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
74387: LD_VAR 0 1
74391: PPUSH
74392: LD_INT 5
74394: PPUSH
74395: CALL_OW 321
74399: PUSH
74400: LD_INT 2
74402: EQUAL
74403: IFFALSE 74420
// bpoints := bpoints * 1.8 ;
74405: LD_ADDR_VAR 0 10
74409: PUSH
74410: LD_VAR 0 10
74414: PUSH
74415: LD_REAL  1.80000000000000E+0000
74418: MUL
74419: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
74420: LD_VAR 0 6
74424: PPUSH
74425: CALL_OW 257
74429: PUSH
74430: LD_INT 1
74432: PUSH
74433: LD_INT 2
74435: PUSH
74436: LD_INT 3
74438: PUSH
74439: LD_INT 4
74441: PUSH
74442: EMPTY
74443: LIST
74444: LIST
74445: LIST
74446: LIST
74447: IN
74448: PUSH
74449: LD_VAR 0 1
74453: PPUSH
74454: LD_INT 51
74456: PPUSH
74457: CALL_OW 321
74461: PUSH
74462: LD_INT 2
74464: EQUAL
74465: AND
74466: IFFALSE 74483
// bpoints := bpoints * 1.2 ;
74468: LD_ADDR_VAR 0 10
74472: PUSH
74473: LD_VAR 0 10
74477: PUSH
74478: LD_REAL  1.20000000000000E+0000
74481: MUL
74482: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
74483: LD_VAR 0 6
74487: PPUSH
74488: CALL_OW 257
74492: PUSH
74493: LD_INT 5
74495: PUSH
74496: LD_INT 7
74498: PUSH
74499: LD_INT 9
74501: PUSH
74502: EMPTY
74503: LIST
74504: LIST
74505: LIST
74506: IN
74507: PUSH
74508: LD_VAR 0 1
74512: PPUSH
74513: LD_INT 52
74515: PPUSH
74516: CALL_OW 321
74520: PUSH
74521: LD_INT 2
74523: EQUAL
74524: AND
74525: IFFALSE 74542
// bpoints := bpoints * 1.5 ;
74527: LD_ADDR_VAR 0 10
74531: PUSH
74532: LD_VAR 0 10
74536: PUSH
74537: LD_REAL  1.50000000000000E+0000
74540: MUL
74541: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
74542: LD_VAR 0 1
74546: PPUSH
74547: LD_INT 66
74549: PPUSH
74550: CALL_OW 321
74554: PUSH
74555: LD_INT 2
74557: EQUAL
74558: IFFALSE 74575
// bpoints := bpoints * 1.1 ;
74560: LD_ADDR_VAR 0 10
74564: PUSH
74565: LD_VAR 0 10
74569: PUSH
74570: LD_REAL  1.10000000000000E+0000
74573: MUL
74574: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
74575: LD_ADDR_VAR 0 10
74579: PUSH
74580: LD_VAR 0 10
74584: PUSH
74585: LD_VAR 0 6
74589: PPUSH
74590: LD_INT 1
74592: PPUSH
74593: CALL_OW 259
74597: PUSH
74598: LD_REAL  1.15000000000000E+0000
74601: MUL
74602: MUL
74603: ST_TO_ADDR
// end ; unit_vehicle :
74604: GO 75432
74606: LD_INT 2
74608: DOUBLE
74609: EQUAL
74610: IFTRUE 74614
74612: GO 75420
74614: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
74615: LD_VAR 0 6
74619: PPUSH
74620: CALL_OW 264
74624: PUSH
74625: LD_INT 2
74627: PUSH
74628: LD_INT 42
74630: PUSH
74631: LD_INT 24
74633: PUSH
74634: EMPTY
74635: LIST
74636: LIST
74637: LIST
74638: IN
74639: IFFALSE 74660
// points := [ 25 , 5 , 3 ] ;
74641: LD_ADDR_VAR 0 9
74645: PUSH
74646: LD_INT 25
74648: PUSH
74649: LD_INT 5
74651: PUSH
74652: LD_INT 3
74654: PUSH
74655: EMPTY
74656: LIST
74657: LIST
74658: LIST
74659: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
74660: LD_VAR 0 6
74664: PPUSH
74665: CALL_OW 264
74669: PUSH
74670: LD_INT 4
74672: PUSH
74673: LD_INT 43
74675: PUSH
74676: LD_INT 25
74678: PUSH
74679: EMPTY
74680: LIST
74681: LIST
74682: LIST
74683: IN
74684: IFFALSE 74705
// points := [ 40 , 15 , 5 ] ;
74686: LD_ADDR_VAR 0 9
74690: PUSH
74691: LD_INT 40
74693: PUSH
74694: LD_INT 15
74696: PUSH
74697: LD_INT 5
74699: PUSH
74700: EMPTY
74701: LIST
74702: LIST
74703: LIST
74704: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
74705: LD_VAR 0 6
74709: PPUSH
74710: CALL_OW 264
74714: PUSH
74715: LD_INT 3
74717: PUSH
74718: LD_INT 23
74720: PUSH
74721: EMPTY
74722: LIST
74723: LIST
74724: IN
74725: IFFALSE 74746
// points := [ 7 , 25 , 8 ] ;
74727: LD_ADDR_VAR 0 9
74731: PUSH
74732: LD_INT 7
74734: PUSH
74735: LD_INT 25
74737: PUSH
74738: LD_INT 8
74740: PUSH
74741: EMPTY
74742: LIST
74743: LIST
74744: LIST
74745: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
74746: LD_VAR 0 6
74750: PPUSH
74751: CALL_OW 264
74755: PUSH
74756: LD_INT 5
74758: PUSH
74759: LD_INT 27
74761: PUSH
74762: LD_INT 44
74764: PUSH
74765: EMPTY
74766: LIST
74767: LIST
74768: LIST
74769: IN
74770: IFFALSE 74791
// points := [ 14 , 50 , 16 ] ;
74772: LD_ADDR_VAR 0 9
74776: PUSH
74777: LD_INT 14
74779: PUSH
74780: LD_INT 50
74782: PUSH
74783: LD_INT 16
74785: PUSH
74786: EMPTY
74787: LIST
74788: LIST
74789: LIST
74790: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
74791: LD_VAR 0 6
74795: PPUSH
74796: CALL_OW 264
74800: PUSH
74801: LD_INT 6
74803: PUSH
74804: LD_INT 46
74806: PUSH
74807: EMPTY
74808: LIST
74809: LIST
74810: IN
74811: IFFALSE 74832
// points := [ 32 , 120 , 70 ] ;
74813: LD_ADDR_VAR 0 9
74817: PUSH
74818: LD_INT 32
74820: PUSH
74821: LD_INT 120
74823: PUSH
74824: LD_INT 70
74826: PUSH
74827: EMPTY
74828: LIST
74829: LIST
74830: LIST
74831: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
74832: LD_VAR 0 6
74836: PPUSH
74837: CALL_OW 264
74841: PUSH
74842: LD_INT 7
74844: PUSH
74845: LD_INT 28
74847: PUSH
74848: LD_INT 45
74850: PUSH
74851: LD_INT 92
74853: PUSH
74854: EMPTY
74855: LIST
74856: LIST
74857: LIST
74858: LIST
74859: IN
74860: IFFALSE 74881
// points := [ 35 , 20 , 45 ] ;
74862: LD_ADDR_VAR 0 9
74866: PUSH
74867: LD_INT 35
74869: PUSH
74870: LD_INT 20
74872: PUSH
74873: LD_INT 45
74875: PUSH
74876: EMPTY
74877: LIST
74878: LIST
74879: LIST
74880: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
74881: LD_VAR 0 6
74885: PPUSH
74886: CALL_OW 264
74890: PUSH
74891: LD_INT 47
74893: PUSH
74894: EMPTY
74895: LIST
74896: IN
74897: IFFALSE 74918
// points := [ 67 , 45 , 75 ] ;
74899: LD_ADDR_VAR 0 9
74903: PUSH
74904: LD_INT 67
74906: PUSH
74907: LD_INT 45
74909: PUSH
74910: LD_INT 75
74912: PUSH
74913: EMPTY
74914: LIST
74915: LIST
74916: LIST
74917: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
74918: LD_VAR 0 6
74922: PPUSH
74923: CALL_OW 264
74927: PUSH
74928: LD_INT 26
74930: PUSH
74931: EMPTY
74932: LIST
74933: IN
74934: IFFALSE 74955
// points := [ 120 , 30 , 80 ] ;
74936: LD_ADDR_VAR 0 9
74940: PUSH
74941: LD_INT 120
74943: PUSH
74944: LD_INT 30
74946: PUSH
74947: LD_INT 80
74949: PUSH
74950: EMPTY
74951: LIST
74952: LIST
74953: LIST
74954: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
74955: LD_VAR 0 6
74959: PPUSH
74960: CALL_OW 264
74964: PUSH
74965: LD_INT 22
74967: PUSH
74968: EMPTY
74969: LIST
74970: IN
74971: IFFALSE 74992
// points := [ 40 , 1 , 1 ] ;
74973: LD_ADDR_VAR 0 9
74977: PUSH
74978: LD_INT 40
74980: PUSH
74981: LD_INT 1
74983: PUSH
74984: LD_INT 1
74986: PUSH
74987: EMPTY
74988: LIST
74989: LIST
74990: LIST
74991: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
74992: LD_VAR 0 6
74996: PPUSH
74997: CALL_OW 264
75001: PUSH
75002: LD_INT 29
75004: PUSH
75005: EMPTY
75006: LIST
75007: IN
75008: IFFALSE 75029
// points := [ 70 , 200 , 400 ] ;
75010: LD_ADDR_VAR 0 9
75014: PUSH
75015: LD_INT 70
75017: PUSH
75018: LD_INT 200
75020: PUSH
75021: LD_INT 400
75023: PUSH
75024: EMPTY
75025: LIST
75026: LIST
75027: LIST
75028: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
75029: LD_VAR 0 6
75033: PPUSH
75034: CALL_OW 264
75038: PUSH
75039: LD_INT 14
75041: PUSH
75042: LD_INT 53
75044: PUSH
75045: EMPTY
75046: LIST
75047: LIST
75048: IN
75049: IFFALSE 75070
// points := [ 40 , 10 , 20 ] ;
75051: LD_ADDR_VAR 0 9
75055: PUSH
75056: LD_INT 40
75058: PUSH
75059: LD_INT 10
75061: PUSH
75062: LD_INT 20
75064: PUSH
75065: EMPTY
75066: LIST
75067: LIST
75068: LIST
75069: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
75070: LD_VAR 0 6
75074: PPUSH
75075: CALL_OW 264
75079: PUSH
75080: LD_INT 9
75082: PUSH
75083: EMPTY
75084: LIST
75085: IN
75086: IFFALSE 75107
// points := [ 5 , 70 , 20 ] ;
75088: LD_ADDR_VAR 0 9
75092: PUSH
75093: LD_INT 5
75095: PUSH
75096: LD_INT 70
75098: PUSH
75099: LD_INT 20
75101: PUSH
75102: EMPTY
75103: LIST
75104: LIST
75105: LIST
75106: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
75107: LD_VAR 0 6
75111: PPUSH
75112: CALL_OW 264
75116: PUSH
75117: LD_INT 10
75119: PUSH
75120: EMPTY
75121: LIST
75122: IN
75123: IFFALSE 75144
// points := [ 35 , 110 , 70 ] ;
75125: LD_ADDR_VAR 0 9
75129: PUSH
75130: LD_INT 35
75132: PUSH
75133: LD_INT 110
75135: PUSH
75136: LD_INT 70
75138: PUSH
75139: EMPTY
75140: LIST
75141: LIST
75142: LIST
75143: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
75144: LD_VAR 0 6
75148: PPUSH
75149: CALL_OW 265
75153: PUSH
75154: LD_INT 25
75156: EQUAL
75157: IFFALSE 75178
// points := [ 80 , 65 , 100 ] ;
75159: LD_ADDR_VAR 0 9
75163: PUSH
75164: LD_INT 80
75166: PUSH
75167: LD_INT 65
75169: PUSH
75170: LD_INT 100
75172: PUSH
75173: EMPTY
75174: LIST
75175: LIST
75176: LIST
75177: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
75178: LD_VAR 0 6
75182: PPUSH
75183: CALL_OW 263
75187: PUSH
75188: LD_INT 1
75190: EQUAL
75191: IFFALSE 75226
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
75193: LD_ADDR_VAR 0 10
75197: PUSH
75198: LD_VAR 0 10
75202: PUSH
75203: LD_VAR 0 6
75207: PPUSH
75208: CALL_OW 311
75212: PPUSH
75213: LD_INT 3
75215: PPUSH
75216: CALL_OW 259
75220: PUSH
75221: LD_INT 4
75223: MUL
75224: MUL
75225: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
75226: LD_VAR 0 6
75230: PPUSH
75231: CALL_OW 263
75235: PUSH
75236: LD_INT 2
75238: EQUAL
75239: IFFALSE 75290
// begin j := IsControledBy ( i ) ;
75241: LD_ADDR_VAR 0 7
75245: PUSH
75246: LD_VAR 0 6
75250: PPUSH
75251: CALL_OW 312
75255: ST_TO_ADDR
// if j then
75256: LD_VAR 0 7
75260: IFFALSE 75290
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
75262: LD_ADDR_VAR 0 10
75266: PUSH
75267: LD_VAR 0 10
75271: PUSH
75272: LD_VAR 0 7
75276: PPUSH
75277: LD_INT 3
75279: PPUSH
75280: CALL_OW 259
75284: PUSH
75285: LD_INT 3
75287: MUL
75288: MUL
75289: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
75290: LD_VAR 0 6
75294: PPUSH
75295: CALL_OW 264
75299: PUSH
75300: LD_INT 5
75302: PUSH
75303: LD_INT 6
75305: PUSH
75306: LD_INT 46
75308: PUSH
75309: LD_INT 44
75311: PUSH
75312: LD_INT 47
75314: PUSH
75315: LD_INT 45
75317: PUSH
75318: LD_INT 28
75320: PUSH
75321: LD_INT 7
75323: PUSH
75324: LD_INT 27
75326: PUSH
75327: LD_INT 29
75329: PUSH
75330: EMPTY
75331: LIST
75332: LIST
75333: LIST
75334: LIST
75335: LIST
75336: LIST
75337: LIST
75338: LIST
75339: LIST
75340: LIST
75341: IN
75342: PUSH
75343: LD_VAR 0 1
75347: PPUSH
75348: LD_INT 52
75350: PPUSH
75351: CALL_OW 321
75355: PUSH
75356: LD_INT 2
75358: EQUAL
75359: AND
75360: IFFALSE 75377
// bpoints := bpoints * 1.2 ;
75362: LD_ADDR_VAR 0 10
75366: PUSH
75367: LD_VAR 0 10
75371: PUSH
75372: LD_REAL  1.20000000000000E+0000
75375: MUL
75376: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
75377: LD_VAR 0 6
75381: PPUSH
75382: CALL_OW 264
75386: PUSH
75387: LD_INT 6
75389: PUSH
75390: LD_INT 46
75392: PUSH
75393: LD_INT 47
75395: PUSH
75396: EMPTY
75397: LIST
75398: LIST
75399: LIST
75400: IN
75401: IFFALSE 75418
// bpoints := bpoints * 1.2 ;
75403: LD_ADDR_VAR 0 10
75407: PUSH
75408: LD_VAR 0 10
75412: PUSH
75413: LD_REAL  1.20000000000000E+0000
75416: MUL
75417: ST_TO_ADDR
// end ; unit_building :
75418: GO 75432
75420: LD_INT 3
75422: DOUBLE
75423: EQUAL
75424: IFTRUE 75428
75426: GO 75431
75428: POP
// ; end ;
75429: GO 75432
75431: POP
// for j = 1 to 3 do
75432: LD_ADDR_VAR 0 7
75436: PUSH
75437: DOUBLE
75438: LD_INT 1
75440: DEC
75441: ST_TO_ADDR
75442: LD_INT 3
75444: PUSH
75445: FOR_TO
75446: IFFALSE 75499
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
75448: LD_ADDR_VAR 0 5
75452: PUSH
75453: LD_VAR 0 5
75457: PPUSH
75458: LD_VAR 0 7
75462: PPUSH
75463: LD_VAR 0 5
75467: PUSH
75468: LD_VAR 0 7
75472: ARRAY
75473: PUSH
75474: LD_VAR 0 9
75478: PUSH
75479: LD_VAR 0 7
75483: ARRAY
75484: PUSH
75485: LD_VAR 0 10
75489: MUL
75490: PLUS
75491: PPUSH
75492: CALL_OW 1
75496: ST_TO_ADDR
75497: GO 75445
75499: POP
75500: POP
// end ;
75501: GO 73980
75503: POP
75504: POP
// result := Replace ( result , 4 , tmp ) ;
75505: LD_ADDR_VAR 0 5
75509: PUSH
75510: LD_VAR 0 5
75514: PPUSH
75515: LD_INT 4
75517: PPUSH
75518: LD_VAR 0 8
75522: PPUSH
75523: CALL_OW 1
75527: ST_TO_ADDR
// end ;
75528: LD_VAR 0 5
75532: RET
// export function DangerAtRange ( unit , range ) ; begin
75533: LD_INT 0
75535: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
75536: LD_ADDR_VAR 0 3
75540: PUSH
75541: LD_VAR 0 1
75545: PPUSH
75546: CALL_OW 255
75550: PPUSH
75551: LD_VAR 0 1
75555: PPUSH
75556: CALL_OW 250
75560: PPUSH
75561: LD_VAR 0 1
75565: PPUSH
75566: CALL_OW 251
75570: PPUSH
75571: LD_VAR 0 2
75575: PPUSH
75576: CALL 73832 0 4
75580: ST_TO_ADDR
// end ;
75581: LD_VAR 0 3
75585: RET
// export function DangerInArea ( side , area ) ; begin
75586: LD_INT 0
75588: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
75589: LD_ADDR_VAR 0 3
75593: PUSH
75594: LD_VAR 0 2
75598: PPUSH
75599: LD_INT 81
75601: PUSH
75602: LD_VAR 0 1
75606: PUSH
75607: EMPTY
75608: LIST
75609: LIST
75610: PPUSH
75611: CALL_OW 70
75615: ST_TO_ADDR
// end ;
75616: LD_VAR 0 3
75620: RET
// export function IsExtension ( b ) ; begin
75621: LD_INT 0
75623: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
75624: LD_ADDR_VAR 0 2
75628: PUSH
75629: LD_VAR 0 1
75633: PUSH
75634: LD_INT 23
75636: PUSH
75637: LD_INT 20
75639: PUSH
75640: LD_INT 22
75642: PUSH
75643: LD_INT 17
75645: PUSH
75646: LD_INT 24
75648: PUSH
75649: LD_INT 21
75651: PUSH
75652: LD_INT 19
75654: PUSH
75655: LD_INT 16
75657: PUSH
75658: LD_INT 25
75660: PUSH
75661: LD_INT 18
75663: PUSH
75664: EMPTY
75665: LIST
75666: LIST
75667: LIST
75668: LIST
75669: LIST
75670: LIST
75671: LIST
75672: LIST
75673: LIST
75674: LIST
75675: IN
75676: ST_TO_ADDR
// end ;
75677: LD_VAR 0 2
75681: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
75682: LD_INT 0
75684: PPUSH
75685: PPUSH
75686: PPUSH
// result := [ ] ;
75687: LD_ADDR_VAR 0 4
75691: PUSH
75692: EMPTY
75693: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
75694: LD_ADDR_VAR 0 5
75698: PUSH
75699: LD_VAR 0 2
75703: PPUSH
75704: LD_INT 21
75706: PUSH
75707: LD_INT 3
75709: PUSH
75710: EMPTY
75711: LIST
75712: LIST
75713: PPUSH
75714: CALL_OW 70
75718: ST_TO_ADDR
// if not tmp then
75719: LD_VAR 0 5
75723: NOT
75724: IFFALSE 75728
// exit ;
75726: GO 75792
// if checkLink then
75728: LD_VAR 0 3
75732: IFFALSE 75782
// begin for i in tmp do
75734: LD_ADDR_VAR 0 6
75738: PUSH
75739: LD_VAR 0 5
75743: PUSH
75744: FOR_IN
75745: IFFALSE 75780
// if GetBase ( i ) <> base then
75747: LD_VAR 0 6
75751: PPUSH
75752: CALL_OW 274
75756: PUSH
75757: LD_VAR 0 1
75761: NONEQUAL
75762: IFFALSE 75778
// ComLinkToBase ( base , i ) ;
75764: LD_VAR 0 1
75768: PPUSH
75769: LD_VAR 0 6
75773: PPUSH
75774: CALL_OW 169
75778: GO 75744
75780: POP
75781: POP
// end ; result := tmp ;
75782: LD_ADDR_VAR 0 4
75786: PUSH
75787: LD_VAR 0 5
75791: ST_TO_ADDR
// end ;
75792: LD_VAR 0 4
75796: RET
// export function ComComplete ( units , b ) ; var i ; begin
75797: LD_INT 0
75799: PPUSH
75800: PPUSH
// if not units then
75801: LD_VAR 0 1
75805: NOT
75806: IFFALSE 75810
// exit ;
75808: GO 75900
// for i in units do
75810: LD_ADDR_VAR 0 4
75814: PUSH
75815: LD_VAR 0 1
75819: PUSH
75820: FOR_IN
75821: IFFALSE 75898
// if BuildingStatus ( b ) = bs_build then
75823: LD_VAR 0 2
75827: PPUSH
75828: CALL_OW 461
75832: PUSH
75833: LD_INT 1
75835: EQUAL
75836: IFFALSE 75896
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
75838: LD_VAR 0 4
75842: PPUSH
75843: LD_STRING h
75845: PUSH
75846: LD_VAR 0 2
75850: PPUSH
75851: CALL_OW 250
75855: PUSH
75856: LD_VAR 0 2
75860: PPUSH
75861: CALL_OW 251
75865: PUSH
75866: LD_VAR 0 2
75870: PUSH
75871: LD_INT 0
75873: PUSH
75874: LD_INT 0
75876: PUSH
75877: LD_INT 0
75879: PUSH
75880: EMPTY
75881: LIST
75882: LIST
75883: LIST
75884: LIST
75885: LIST
75886: LIST
75887: LIST
75888: PUSH
75889: EMPTY
75890: LIST
75891: PPUSH
75892: CALL_OW 446
75896: GO 75820
75898: POP
75899: POP
// end ;
75900: LD_VAR 0 3
75904: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
75905: LD_INT 0
75907: PPUSH
75908: PPUSH
75909: PPUSH
75910: PPUSH
75911: PPUSH
75912: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
75913: LD_VAR 0 1
75917: NOT
75918: PUSH
75919: LD_VAR 0 1
75923: PPUSH
75924: CALL_OW 263
75928: PUSH
75929: LD_INT 2
75931: NONEQUAL
75932: OR
75933: IFFALSE 75937
// exit ;
75935: GO 76253
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
75937: LD_ADDR_VAR 0 6
75941: PUSH
75942: LD_INT 22
75944: PUSH
75945: LD_VAR 0 1
75949: PPUSH
75950: CALL_OW 255
75954: PUSH
75955: EMPTY
75956: LIST
75957: LIST
75958: PUSH
75959: LD_INT 2
75961: PUSH
75962: LD_INT 30
75964: PUSH
75965: LD_INT 36
75967: PUSH
75968: EMPTY
75969: LIST
75970: LIST
75971: PUSH
75972: LD_INT 34
75974: PUSH
75975: LD_INT 31
75977: PUSH
75978: EMPTY
75979: LIST
75980: LIST
75981: PUSH
75982: EMPTY
75983: LIST
75984: LIST
75985: LIST
75986: PUSH
75987: EMPTY
75988: LIST
75989: LIST
75990: PPUSH
75991: CALL_OW 69
75995: ST_TO_ADDR
// if not tmp then
75996: LD_VAR 0 6
76000: NOT
76001: IFFALSE 76005
// exit ;
76003: GO 76253
// result := [ ] ;
76005: LD_ADDR_VAR 0 2
76009: PUSH
76010: EMPTY
76011: ST_TO_ADDR
// for i in tmp do
76012: LD_ADDR_VAR 0 3
76016: PUSH
76017: LD_VAR 0 6
76021: PUSH
76022: FOR_IN
76023: IFFALSE 76094
// begin t := UnitsInside ( i ) ;
76025: LD_ADDR_VAR 0 4
76029: PUSH
76030: LD_VAR 0 3
76034: PPUSH
76035: CALL_OW 313
76039: ST_TO_ADDR
// if t then
76040: LD_VAR 0 4
76044: IFFALSE 76092
// for j in t do
76046: LD_ADDR_VAR 0 7
76050: PUSH
76051: LD_VAR 0 4
76055: PUSH
76056: FOR_IN
76057: IFFALSE 76090
// result := Replace ( result , result + 1 , j ) ;
76059: LD_ADDR_VAR 0 2
76063: PUSH
76064: LD_VAR 0 2
76068: PPUSH
76069: LD_VAR 0 2
76073: PUSH
76074: LD_INT 1
76076: PLUS
76077: PPUSH
76078: LD_VAR 0 7
76082: PPUSH
76083: CALL_OW 1
76087: ST_TO_ADDR
76088: GO 76056
76090: POP
76091: POP
// end ;
76092: GO 76022
76094: POP
76095: POP
// if not result then
76096: LD_VAR 0 2
76100: NOT
76101: IFFALSE 76105
// exit ;
76103: GO 76253
// mech := result [ 1 ] ;
76105: LD_ADDR_VAR 0 5
76109: PUSH
76110: LD_VAR 0 2
76114: PUSH
76115: LD_INT 1
76117: ARRAY
76118: ST_TO_ADDR
// if result > 1 then
76119: LD_VAR 0 2
76123: PUSH
76124: LD_INT 1
76126: GREATER
76127: IFFALSE 76239
// begin for i = 2 to result do
76129: LD_ADDR_VAR 0 3
76133: PUSH
76134: DOUBLE
76135: LD_INT 2
76137: DEC
76138: ST_TO_ADDR
76139: LD_VAR 0 2
76143: PUSH
76144: FOR_TO
76145: IFFALSE 76237
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
76147: LD_ADDR_VAR 0 4
76151: PUSH
76152: LD_VAR 0 2
76156: PUSH
76157: LD_VAR 0 3
76161: ARRAY
76162: PPUSH
76163: LD_INT 3
76165: PPUSH
76166: CALL_OW 259
76170: PUSH
76171: LD_VAR 0 2
76175: PUSH
76176: LD_VAR 0 3
76180: ARRAY
76181: PPUSH
76182: CALL_OW 432
76186: MINUS
76187: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
76188: LD_VAR 0 4
76192: PUSH
76193: LD_VAR 0 5
76197: PPUSH
76198: LD_INT 3
76200: PPUSH
76201: CALL_OW 259
76205: PUSH
76206: LD_VAR 0 5
76210: PPUSH
76211: CALL_OW 432
76215: MINUS
76216: GREATEREQUAL
76217: IFFALSE 76235
// mech := result [ i ] ;
76219: LD_ADDR_VAR 0 5
76223: PUSH
76224: LD_VAR 0 2
76228: PUSH
76229: LD_VAR 0 3
76233: ARRAY
76234: ST_TO_ADDR
// end ;
76235: GO 76144
76237: POP
76238: POP
// end ; ComLinkTo ( vehicle , mech ) ;
76239: LD_VAR 0 1
76243: PPUSH
76244: LD_VAR 0 5
76248: PPUSH
76249: CALL_OW 135
// end ;
76253: LD_VAR 0 2
76257: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
76258: LD_INT 0
76260: PPUSH
76261: PPUSH
76262: PPUSH
76263: PPUSH
76264: PPUSH
76265: PPUSH
76266: PPUSH
76267: PPUSH
76268: PPUSH
76269: PPUSH
76270: PPUSH
76271: PPUSH
76272: PPUSH
// result := [ ] ;
76273: LD_ADDR_VAR 0 7
76277: PUSH
76278: EMPTY
76279: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
76280: LD_VAR 0 1
76284: PPUSH
76285: CALL_OW 266
76289: PUSH
76290: LD_INT 0
76292: PUSH
76293: LD_INT 1
76295: PUSH
76296: EMPTY
76297: LIST
76298: LIST
76299: IN
76300: NOT
76301: IFFALSE 76305
// exit ;
76303: GO 77939
// if name then
76305: LD_VAR 0 3
76309: IFFALSE 76325
// SetBName ( base_dep , name ) ;
76311: LD_VAR 0 1
76315: PPUSH
76316: LD_VAR 0 3
76320: PPUSH
76321: CALL_OW 500
// base := GetBase ( base_dep ) ;
76325: LD_ADDR_VAR 0 15
76329: PUSH
76330: LD_VAR 0 1
76334: PPUSH
76335: CALL_OW 274
76339: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
76340: LD_ADDR_VAR 0 16
76344: PUSH
76345: LD_VAR 0 1
76349: PPUSH
76350: CALL_OW 255
76354: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
76355: LD_ADDR_VAR 0 17
76359: PUSH
76360: LD_VAR 0 1
76364: PPUSH
76365: CALL_OW 248
76369: ST_TO_ADDR
// if sources then
76370: LD_VAR 0 5
76374: IFFALSE 76421
// for i = 1 to 3 do
76376: LD_ADDR_VAR 0 8
76380: PUSH
76381: DOUBLE
76382: LD_INT 1
76384: DEC
76385: ST_TO_ADDR
76386: LD_INT 3
76388: PUSH
76389: FOR_TO
76390: IFFALSE 76419
// AddResourceType ( base , i , sources [ i ] ) ;
76392: LD_VAR 0 15
76396: PPUSH
76397: LD_VAR 0 8
76401: PPUSH
76402: LD_VAR 0 5
76406: PUSH
76407: LD_VAR 0 8
76411: ARRAY
76412: PPUSH
76413: CALL_OW 276
76417: GO 76389
76419: POP
76420: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
76421: LD_ADDR_VAR 0 18
76425: PUSH
76426: LD_VAR 0 15
76430: PPUSH
76431: LD_VAR 0 2
76435: PPUSH
76436: LD_INT 1
76438: PPUSH
76439: CALL 75682 0 3
76443: ST_TO_ADDR
// InitHc ;
76444: CALL_OW 19
// InitUc ;
76448: CALL_OW 18
// uc_side := side ;
76452: LD_ADDR_OWVAR 20
76456: PUSH
76457: LD_VAR 0 16
76461: ST_TO_ADDR
// uc_nation := nation ;
76462: LD_ADDR_OWVAR 21
76466: PUSH
76467: LD_VAR 0 17
76471: ST_TO_ADDR
// if buildings then
76472: LD_VAR 0 18
76476: IFFALSE 77798
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
76478: LD_ADDR_VAR 0 19
76482: PUSH
76483: LD_VAR 0 18
76487: PPUSH
76488: LD_INT 2
76490: PUSH
76491: LD_INT 30
76493: PUSH
76494: LD_INT 29
76496: PUSH
76497: EMPTY
76498: LIST
76499: LIST
76500: PUSH
76501: LD_INT 30
76503: PUSH
76504: LD_INT 30
76506: PUSH
76507: EMPTY
76508: LIST
76509: LIST
76510: PUSH
76511: EMPTY
76512: LIST
76513: LIST
76514: LIST
76515: PPUSH
76516: CALL_OW 72
76520: ST_TO_ADDR
// if tmp then
76521: LD_VAR 0 19
76525: IFFALSE 76573
// for i in tmp do
76527: LD_ADDR_VAR 0 8
76531: PUSH
76532: LD_VAR 0 19
76536: PUSH
76537: FOR_IN
76538: IFFALSE 76571
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
76540: LD_VAR 0 8
76544: PPUSH
76545: CALL_OW 250
76549: PPUSH
76550: LD_VAR 0 8
76554: PPUSH
76555: CALL_OW 251
76559: PPUSH
76560: LD_VAR 0 16
76564: PPUSH
76565: CALL_OW 441
76569: GO 76537
76571: POP
76572: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
76573: LD_VAR 0 18
76577: PPUSH
76578: LD_INT 2
76580: PUSH
76581: LD_INT 30
76583: PUSH
76584: LD_INT 32
76586: PUSH
76587: EMPTY
76588: LIST
76589: LIST
76590: PUSH
76591: LD_INT 30
76593: PUSH
76594: LD_INT 33
76596: PUSH
76597: EMPTY
76598: LIST
76599: LIST
76600: PUSH
76601: EMPTY
76602: LIST
76603: LIST
76604: LIST
76605: PPUSH
76606: CALL_OW 72
76610: IFFALSE 76698
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
76612: LD_ADDR_VAR 0 8
76616: PUSH
76617: LD_VAR 0 18
76621: PPUSH
76622: LD_INT 2
76624: PUSH
76625: LD_INT 30
76627: PUSH
76628: LD_INT 32
76630: PUSH
76631: EMPTY
76632: LIST
76633: LIST
76634: PUSH
76635: LD_INT 30
76637: PUSH
76638: LD_INT 33
76640: PUSH
76641: EMPTY
76642: LIST
76643: LIST
76644: PUSH
76645: EMPTY
76646: LIST
76647: LIST
76648: LIST
76649: PPUSH
76650: CALL_OW 72
76654: PUSH
76655: FOR_IN
76656: IFFALSE 76696
// begin if not GetBWeapon ( i ) then
76658: LD_VAR 0 8
76662: PPUSH
76663: CALL_OW 269
76667: NOT
76668: IFFALSE 76694
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
76670: LD_VAR 0 8
76674: PPUSH
76675: LD_VAR 0 8
76679: PPUSH
76680: LD_VAR 0 2
76684: PPUSH
76685: CALL 77944 0 2
76689: PPUSH
76690: CALL_OW 431
// end ;
76694: GO 76655
76696: POP
76697: POP
// end ; for i = 1 to personel do
76698: LD_ADDR_VAR 0 8
76702: PUSH
76703: DOUBLE
76704: LD_INT 1
76706: DEC
76707: ST_TO_ADDR
76708: LD_VAR 0 6
76712: PUSH
76713: FOR_TO
76714: IFFALSE 77778
// begin if i > 4 then
76716: LD_VAR 0 8
76720: PUSH
76721: LD_INT 4
76723: GREATER
76724: IFFALSE 76728
// break ;
76726: GO 77778
// case i of 1 :
76728: LD_VAR 0 8
76732: PUSH
76733: LD_INT 1
76735: DOUBLE
76736: EQUAL
76737: IFTRUE 76741
76739: GO 76821
76741: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
76742: LD_ADDR_VAR 0 12
76746: PUSH
76747: LD_VAR 0 18
76751: PPUSH
76752: LD_INT 22
76754: PUSH
76755: LD_VAR 0 16
76759: PUSH
76760: EMPTY
76761: LIST
76762: LIST
76763: PUSH
76764: LD_INT 58
76766: PUSH
76767: EMPTY
76768: LIST
76769: PUSH
76770: LD_INT 2
76772: PUSH
76773: LD_INT 30
76775: PUSH
76776: LD_INT 32
76778: PUSH
76779: EMPTY
76780: LIST
76781: LIST
76782: PUSH
76783: LD_INT 30
76785: PUSH
76786: LD_INT 4
76788: PUSH
76789: EMPTY
76790: LIST
76791: LIST
76792: PUSH
76793: LD_INT 30
76795: PUSH
76796: LD_INT 5
76798: PUSH
76799: EMPTY
76800: LIST
76801: LIST
76802: PUSH
76803: EMPTY
76804: LIST
76805: LIST
76806: LIST
76807: LIST
76808: PUSH
76809: EMPTY
76810: LIST
76811: LIST
76812: LIST
76813: PPUSH
76814: CALL_OW 72
76818: ST_TO_ADDR
76819: GO 77043
76821: LD_INT 2
76823: DOUBLE
76824: EQUAL
76825: IFTRUE 76829
76827: GO 76891
76829: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
76830: LD_ADDR_VAR 0 12
76834: PUSH
76835: LD_VAR 0 18
76839: PPUSH
76840: LD_INT 22
76842: PUSH
76843: LD_VAR 0 16
76847: PUSH
76848: EMPTY
76849: LIST
76850: LIST
76851: PUSH
76852: LD_INT 2
76854: PUSH
76855: LD_INT 30
76857: PUSH
76858: LD_INT 0
76860: PUSH
76861: EMPTY
76862: LIST
76863: LIST
76864: PUSH
76865: LD_INT 30
76867: PUSH
76868: LD_INT 1
76870: PUSH
76871: EMPTY
76872: LIST
76873: LIST
76874: PUSH
76875: EMPTY
76876: LIST
76877: LIST
76878: LIST
76879: PUSH
76880: EMPTY
76881: LIST
76882: LIST
76883: PPUSH
76884: CALL_OW 72
76888: ST_TO_ADDR
76889: GO 77043
76891: LD_INT 3
76893: DOUBLE
76894: EQUAL
76895: IFTRUE 76899
76897: GO 76961
76899: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
76900: LD_ADDR_VAR 0 12
76904: PUSH
76905: LD_VAR 0 18
76909: PPUSH
76910: LD_INT 22
76912: PUSH
76913: LD_VAR 0 16
76917: PUSH
76918: EMPTY
76919: LIST
76920: LIST
76921: PUSH
76922: LD_INT 2
76924: PUSH
76925: LD_INT 30
76927: PUSH
76928: LD_INT 2
76930: PUSH
76931: EMPTY
76932: LIST
76933: LIST
76934: PUSH
76935: LD_INT 30
76937: PUSH
76938: LD_INT 3
76940: PUSH
76941: EMPTY
76942: LIST
76943: LIST
76944: PUSH
76945: EMPTY
76946: LIST
76947: LIST
76948: LIST
76949: PUSH
76950: EMPTY
76951: LIST
76952: LIST
76953: PPUSH
76954: CALL_OW 72
76958: ST_TO_ADDR
76959: GO 77043
76961: LD_INT 4
76963: DOUBLE
76964: EQUAL
76965: IFTRUE 76969
76967: GO 77042
76969: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
76970: LD_ADDR_VAR 0 12
76974: PUSH
76975: LD_VAR 0 18
76979: PPUSH
76980: LD_INT 22
76982: PUSH
76983: LD_VAR 0 16
76987: PUSH
76988: EMPTY
76989: LIST
76990: LIST
76991: PUSH
76992: LD_INT 2
76994: PUSH
76995: LD_INT 30
76997: PUSH
76998: LD_INT 6
77000: PUSH
77001: EMPTY
77002: LIST
77003: LIST
77004: PUSH
77005: LD_INT 30
77007: PUSH
77008: LD_INT 7
77010: PUSH
77011: EMPTY
77012: LIST
77013: LIST
77014: PUSH
77015: LD_INT 30
77017: PUSH
77018: LD_INT 8
77020: PUSH
77021: EMPTY
77022: LIST
77023: LIST
77024: PUSH
77025: EMPTY
77026: LIST
77027: LIST
77028: LIST
77029: LIST
77030: PUSH
77031: EMPTY
77032: LIST
77033: LIST
77034: PPUSH
77035: CALL_OW 72
77039: ST_TO_ADDR
77040: GO 77043
77042: POP
// if i = 1 then
77043: LD_VAR 0 8
77047: PUSH
77048: LD_INT 1
77050: EQUAL
77051: IFFALSE 77162
// begin tmp := [ ] ;
77053: LD_ADDR_VAR 0 19
77057: PUSH
77058: EMPTY
77059: ST_TO_ADDR
// for j in f do
77060: LD_ADDR_VAR 0 9
77064: PUSH
77065: LD_VAR 0 12
77069: PUSH
77070: FOR_IN
77071: IFFALSE 77144
// if GetBType ( j ) = b_bunker then
77073: LD_VAR 0 9
77077: PPUSH
77078: CALL_OW 266
77082: PUSH
77083: LD_INT 32
77085: EQUAL
77086: IFFALSE 77113
// tmp := Insert ( tmp , 1 , j ) else
77088: LD_ADDR_VAR 0 19
77092: PUSH
77093: LD_VAR 0 19
77097: PPUSH
77098: LD_INT 1
77100: PPUSH
77101: LD_VAR 0 9
77105: PPUSH
77106: CALL_OW 2
77110: ST_TO_ADDR
77111: GO 77142
// tmp := Insert ( tmp , tmp + 1 , j ) ;
77113: LD_ADDR_VAR 0 19
77117: PUSH
77118: LD_VAR 0 19
77122: PPUSH
77123: LD_VAR 0 19
77127: PUSH
77128: LD_INT 1
77130: PLUS
77131: PPUSH
77132: LD_VAR 0 9
77136: PPUSH
77137: CALL_OW 2
77141: ST_TO_ADDR
77142: GO 77070
77144: POP
77145: POP
// if tmp then
77146: LD_VAR 0 19
77150: IFFALSE 77162
// f := tmp ;
77152: LD_ADDR_VAR 0 12
77156: PUSH
77157: LD_VAR 0 19
77161: ST_TO_ADDR
// end ; x := personel [ i ] ;
77162: LD_ADDR_VAR 0 13
77166: PUSH
77167: LD_VAR 0 6
77171: PUSH
77172: LD_VAR 0 8
77176: ARRAY
77177: ST_TO_ADDR
// if x = - 1 then
77178: LD_VAR 0 13
77182: PUSH
77183: LD_INT 1
77185: NEG
77186: EQUAL
77187: IFFALSE 77396
// begin for j in f do
77189: LD_ADDR_VAR 0 9
77193: PUSH
77194: LD_VAR 0 12
77198: PUSH
77199: FOR_IN
77200: IFFALSE 77392
// repeat InitHc ;
77202: CALL_OW 19
// if GetBType ( j ) = b_barracks then
77206: LD_VAR 0 9
77210: PPUSH
77211: CALL_OW 266
77215: PUSH
77216: LD_INT 5
77218: EQUAL
77219: IFFALSE 77289
// begin if UnitsInside ( j ) < 3 then
77221: LD_VAR 0 9
77225: PPUSH
77226: CALL_OW 313
77230: PUSH
77231: LD_INT 3
77233: LESS
77234: IFFALSE 77270
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
77236: LD_INT 0
77238: PPUSH
77239: LD_INT 5
77241: PUSH
77242: LD_INT 8
77244: PUSH
77245: LD_INT 9
77247: PUSH
77248: EMPTY
77249: LIST
77250: LIST
77251: LIST
77252: PUSH
77253: LD_VAR 0 17
77257: ARRAY
77258: PPUSH
77259: LD_VAR 0 4
77263: PPUSH
77264: CALL_OW 380
77268: GO 77287
// PrepareHuman ( false , i , skill ) ;
77270: LD_INT 0
77272: PPUSH
77273: LD_VAR 0 8
77277: PPUSH
77278: LD_VAR 0 4
77282: PPUSH
77283: CALL_OW 380
// end else
77287: GO 77306
// PrepareHuman ( false , i , skill ) ;
77289: LD_INT 0
77291: PPUSH
77292: LD_VAR 0 8
77296: PPUSH
77297: LD_VAR 0 4
77301: PPUSH
77302: CALL_OW 380
// un := CreateHuman ;
77306: LD_ADDR_VAR 0 14
77310: PUSH
77311: CALL_OW 44
77315: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
77316: LD_ADDR_VAR 0 7
77320: PUSH
77321: LD_VAR 0 7
77325: PPUSH
77326: LD_INT 1
77328: PPUSH
77329: LD_VAR 0 14
77333: PPUSH
77334: CALL_OW 2
77338: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
77339: LD_VAR 0 14
77343: PPUSH
77344: LD_VAR 0 9
77348: PPUSH
77349: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
77353: LD_VAR 0 9
77357: PPUSH
77358: CALL_OW 313
77362: PUSH
77363: LD_INT 6
77365: EQUAL
77366: PUSH
77367: LD_VAR 0 9
77371: PPUSH
77372: CALL_OW 266
77376: PUSH
77377: LD_INT 32
77379: PUSH
77380: LD_INT 31
77382: PUSH
77383: EMPTY
77384: LIST
77385: LIST
77386: IN
77387: OR
77388: IFFALSE 77202
77390: GO 77199
77392: POP
77393: POP
// end else
77394: GO 77776
// for j = 1 to x do
77396: LD_ADDR_VAR 0 9
77400: PUSH
77401: DOUBLE
77402: LD_INT 1
77404: DEC
77405: ST_TO_ADDR
77406: LD_VAR 0 13
77410: PUSH
77411: FOR_TO
77412: IFFALSE 77774
// begin InitHc ;
77414: CALL_OW 19
// if not f then
77418: LD_VAR 0 12
77422: NOT
77423: IFFALSE 77512
// begin PrepareHuman ( false , i , skill ) ;
77425: LD_INT 0
77427: PPUSH
77428: LD_VAR 0 8
77432: PPUSH
77433: LD_VAR 0 4
77437: PPUSH
77438: CALL_OW 380
// un := CreateHuman ;
77442: LD_ADDR_VAR 0 14
77446: PUSH
77447: CALL_OW 44
77451: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
77452: LD_ADDR_VAR 0 7
77456: PUSH
77457: LD_VAR 0 7
77461: PPUSH
77462: LD_INT 1
77464: PPUSH
77465: LD_VAR 0 14
77469: PPUSH
77470: CALL_OW 2
77474: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
77475: LD_VAR 0 14
77479: PPUSH
77480: LD_VAR 0 1
77484: PPUSH
77485: CALL_OW 250
77489: PPUSH
77490: LD_VAR 0 1
77494: PPUSH
77495: CALL_OW 251
77499: PPUSH
77500: LD_INT 10
77502: PPUSH
77503: LD_INT 0
77505: PPUSH
77506: CALL_OW 50
// continue ;
77510: GO 77411
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
77512: LD_VAR 0 12
77516: PUSH
77517: LD_INT 1
77519: ARRAY
77520: PPUSH
77521: CALL_OW 313
77525: PUSH
77526: LD_VAR 0 12
77530: PUSH
77531: LD_INT 1
77533: ARRAY
77534: PPUSH
77535: CALL_OW 266
77539: PUSH
77540: LD_INT 32
77542: PUSH
77543: LD_INT 31
77545: PUSH
77546: EMPTY
77547: LIST
77548: LIST
77549: IN
77550: AND
77551: PUSH
77552: LD_VAR 0 12
77556: PUSH
77557: LD_INT 1
77559: ARRAY
77560: PPUSH
77561: CALL_OW 313
77565: PUSH
77566: LD_INT 6
77568: EQUAL
77569: OR
77570: IFFALSE 77590
// f := Delete ( f , 1 ) ;
77572: LD_ADDR_VAR 0 12
77576: PUSH
77577: LD_VAR 0 12
77581: PPUSH
77582: LD_INT 1
77584: PPUSH
77585: CALL_OW 3
77589: ST_TO_ADDR
// if not f then
77590: LD_VAR 0 12
77594: NOT
77595: IFFALSE 77613
// begin x := x + 2 ;
77597: LD_ADDR_VAR 0 13
77601: PUSH
77602: LD_VAR 0 13
77606: PUSH
77607: LD_INT 2
77609: PLUS
77610: ST_TO_ADDR
// continue ;
77611: GO 77411
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
77613: LD_VAR 0 12
77617: PUSH
77618: LD_INT 1
77620: ARRAY
77621: PPUSH
77622: CALL_OW 266
77626: PUSH
77627: LD_INT 5
77629: EQUAL
77630: IFFALSE 77704
// begin if UnitsInside ( f [ 1 ] ) < 3 then
77632: LD_VAR 0 12
77636: PUSH
77637: LD_INT 1
77639: ARRAY
77640: PPUSH
77641: CALL_OW 313
77645: PUSH
77646: LD_INT 3
77648: LESS
77649: IFFALSE 77685
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
77651: LD_INT 0
77653: PPUSH
77654: LD_INT 5
77656: PUSH
77657: LD_INT 8
77659: PUSH
77660: LD_INT 9
77662: PUSH
77663: EMPTY
77664: LIST
77665: LIST
77666: LIST
77667: PUSH
77668: LD_VAR 0 17
77672: ARRAY
77673: PPUSH
77674: LD_VAR 0 4
77678: PPUSH
77679: CALL_OW 380
77683: GO 77702
// PrepareHuman ( false , i , skill ) ;
77685: LD_INT 0
77687: PPUSH
77688: LD_VAR 0 8
77692: PPUSH
77693: LD_VAR 0 4
77697: PPUSH
77698: CALL_OW 380
// end else
77702: GO 77721
// PrepareHuman ( false , i , skill ) ;
77704: LD_INT 0
77706: PPUSH
77707: LD_VAR 0 8
77711: PPUSH
77712: LD_VAR 0 4
77716: PPUSH
77717: CALL_OW 380
// un := CreateHuman ;
77721: LD_ADDR_VAR 0 14
77725: PUSH
77726: CALL_OW 44
77730: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
77731: LD_ADDR_VAR 0 7
77735: PUSH
77736: LD_VAR 0 7
77740: PPUSH
77741: LD_INT 1
77743: PPUSH
77744: LD_VAR 0 14
77748: PPUSH
77749: CALL_OW 2
77753: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
77754: LD_VAR 0 14
77758: PPUSH
77759: LD_VAR 0 12
77763: PUSH
77764: LD_INT 1
77766: ARRAY
77767: PPUSH
77768: CALL_OW 52
// end ;
77772: GO 77411
77774: POP
77775: POP
// end ;
77776: GO 76713
77778: POP
77779: POP
// result := result ^ buildings ;
77780: LD_ADDR_VAR 0 7
77784: PUSH
77785: LD_VAR 0 7
77789: PUSH
77790: LD_VAR 0 18
77794: ADD
77795: ST_TO_ADDR
// end else
77796: GO 77939
// begin for i = 1 to personel do
77798: LD_ADDR_VAR 0 8
77802: PUSH
77803: DOUBLE
77804: LD_INT 1
77806: DEC
77807: ST_TO_ADDR
77808: LD_VAR 0 6
77812: PUSH
77813: FOR_TO
77814: IFFALSE 77937
// begin if i > 4 then
77816: LD_VAR 0 8
77820: PUSH
77821: LD_INT 4
77823: GREATER
77824: IFFALSE 77828
// break ;
77826: GO 77937
// x := personel [ i ] ;
77828: LD_ADDR_VAR 0 13
77832: PUSH
77833: LD_VAR 0 6
77837: PUSH
77838: LD_VAR 0 8
77842: ARRAY
77843: ST_TO_ADDR
// if x = - 1 then
77844: LD_VAR 0 13
77848: PUSH
77849: LD_INT 1
77851: NEG
77852: EQUAL
77853: IFFALSE 77857
// continue ;
77855: GO 77813
// PrepareHuman ( false , i , skill ) ;
77857: LD_INT 0
77859: PPUSH
77860: LD_VAR 0 8
77864: PPUSH
77865: LD_VAR 0 4
77869: PPUSH
77870: CALL_OW 380
// un := CreateHuman ;
77874: LD_ADDR_VAR 0 14
77878: PUSH
77879: CALL_OW 44
77883: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
77884: LD_VAR 0 14
77888: PPUSH
77889: LD_VAR 0 1
77893: PPUSH
77894: CALL_OW 250
77898: PPUSH
77899: LD_VAR 0 1
77903: PPUSH
77904: CALL_OW 251
77908: PPUSH
77909: LD_INT 10
77911: PPUSH
77912: LD_INT 0
77914: PPUSH
77915: CALL_OW 50
// result := result ^ un ;
77919: LD_ADDR_VAR 0 7
77923: PUSH
77924: LD_VAR 0 7
77928: PUSH
77929: LD_VAR 0 14
77933: ADD
77934: ST_TO_ADDR
// end ;
77935: GO 77813
77937: POP
77938: POP
// end ; end ;
77939: LD_VAR 0 7
77943: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
77944: LD_INT 0
77946: PPUSH
77947: PPUSH
77948: PPUSH
77949: PPUSH
77950: PPUSH
77951: PPUSH
77952: PPUSH
77953: PPUSH
77954: PPUSH
77955: PPUSH
77956: PPUSH
77957: PPUSH
77958: PPUSH
77959: PPUSH
77960: PPUSH
77961: PPUSH
// result := false ;
77962: LD_ADDR_VAR 0 3
77966: PUSH
77967: LD_INT 0
77969: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
77970: LD_VAR 0 1
77974: NOT
77975: PUSH
77976: LD_VAR 0 1
77980: PPUSH
77981: CALL_OW 266
77985: PUSH
77986: LD_INT 32
77988: PUSH
77989: LD_INT 33
77991: PUSH
77992: EMPTY
77993: LIST
77994: LIST
77995: IN
77996: NOT
77997: OR
77998: IFFALSE 78002
// exit ;
78000: GO 79111
// nat := GetNation ( tower ) ;
78002: LD_ADDR_VAR 0 12
78006: PUSH
78007: LD_VAR 0 1
78011: PPUSH
78012: CALL_OW 248
78016: ST_TO_ADDR
// side := GetSide ( tower ) ;
78017: LD_ADDR_VAR 0 16
78021: PUSH
78022: LD_VAR 0 1
78026: PPUSH
78027: CALL_OW 255
78031: ST_TO_ADDR
// x := GetX ( tower ) ;
78032: LD_ADDR_VAR 0 10
78036: PUSH
78037: LD_VAR 0 1
78041: PPUSH
78042: CALL_OW 250
78046: ST_TO_ADDR
// y := GetY ( tower ) ;
78047: LD_ADDR_VAR 0 11
78051: PUSH
78052: LD_VAR 0 1
78056: PPUSH
78057: CALL_OW 251
78061: ST_TO_ADDR
// if not x or not y then
78062: LD_VAR 0 10
78066: NOT
78067: PUSH
78068: LD_VAR 0 11
78072: NOT
78073: OR
78074: IFFALSE 78078
// exit ;
78076: GO 79111
// weapon := 0 ;
78078: LD_ADDR_VAR 0 18
78082: PUSH
78083: LD_INT 0
78085: ST_TO_ADDR
// fac_list := [ ] ;
78086: LD_ADDR_VAR 0 17
78090: PUSH
78091: EMPTY
78092: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
78093: LD_ADDR_VAR 0 6
78097: PUSH
78098: LD_VAR 0 1
78102: PPUSH
78103: CALL_OW 274
78107: PPUSH
78108: LD_VAR 0 2
78112: PPUSH
78113: LD_INT 0
78115: PPUSH
78116: CALL 75682 0 3
78120: PPUSH
78121: LD_INT 30
78123: PUSH
78124: LD_INT 3
78126: PUSH
78127: EMPTY
78128: LIST
78129: LIST
78130: PPUSH
78131: CALL_OW 72
78135: ST_TO_ADDR
// if not factories then
78136: LD_VAR 0 6
78140: NOT
78141: IFFALSE 78145
// exit ;
78143: GO 79111
// for i in factories do
78145: LD_ADDR_VAR 0 8
78149: PUSH
78150: LD_VAR 0 6
78154: PUSH
78155: FOR_IN
78156: IFFALSE 78181
// fac_list := fac_list union AvailableWeaponList ( i ) ;
78158: LD_ADDR_VAR 0 17
78162: PUSH
78163: LD_VAR 0 17
78167: PUSH
78168: LD_VAR 0 8
78172: PPUSH
78173: CALL_OW 478
78177: UNION
78178: ST_TO_ADDR
78179: GO 78155
78181: POP
78182: POP
// if not fac_list then
78183: LD_VAR 0 17
78187: NOT
78188: IFFALSE 78192
// exit ;
78190: GO 79111
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
78192: LD_ADDR_VAR 0 5
78196: PUSH
78197: LD_INT 4
78199: PUSH
78200: LD_INT 5
78202: PUSH
78203: LD_INT 9
78205: PUSH
78206: LD_INT 10
78208: PUSH
78209: LD_INT 6
78211: PUSH
78212: LD_INT 7
78214: PUSH
78215: LD_INT 11
78217: PUSH
78218: EMPTY
78219: LIST
78220: LIST
78221: LIST
78222: LIST
78223: LIST
78224: LIST
78225: LIST
78226: PUSH
78227: LD_INT 27
78229: PUSH
78230: LD_INT 28
78232: PUSH
78233: LD_INT 26
78235: PUSH
78236: LD_INT 30
78238: PUSH
78239: EMPTY
78240: LIST
78241: LIST
78242: LIST
78243: LIST
78244: PUSH
78245: LD_INT 43
78247: PUSH
78248: LD_INT 44
78250: PUSH
78251: LD_INT 46
78253: PUSH
78254: LD_INT 45
78256: PUSH
78257: LD_INT 47
78259: PUSH
78260: LD_INT 49
78262: PUSH
78263: EMPTY
78264: LIST
78265: LIST
78266: LIST
78267: LIST
78268: LIST
78269: LIST
78270: PUSH
78271: EMPTY
78272: LIST
78273: LIST
78274: LIST
78275: PUSH
78276: LD_VAR 0 12
78280: ARRAY
78281: ST_TO_ADDR
// list := list isect fac_list ;
78282: LD_ADDR_VAR 0 5
78286: PUSH
78287: LD_VAR 0 5
78291: PUSH
78292: LD_VAR 0 17
78296: ISECT
78297: ST_TO_ADDR
// if not list then
78298: LD_VAR 0 5
78302: NOT
78303: IFFALSE 78307
// exit ;
78305: GO 79111
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
78307: LD_VAR 0 12
78311: PUSH
78312: LD_INT 3
78314: EQUAL
78315: PUSH
78316: LD_INT 49
78318: PUSH
78319: LD_VAR 0 5
78323: IN
78324: AND
78325: PUSH
78326: LD_INT 31
78328: PPUSH
78329: LD_VAR 0 16
78333: PPUSH
78334: CALL_OW 321
78338: PUSH
78339: LD_INT 2
78341: EQUAL
78342: AND
78343: IFFALSE 78403
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
78345: LD_INT 22
78347: PUSH
78348: LD_VAR 0 16
78352: PUSH
78353: EMPTY
78354: LIST
78355: LIST
78356: PUSH
78357: LD_INT 35
78359: PUSH
78360: LD_INT 49
78362: PUSH
78363: EMPTY
78364: LIST
78365: LIST
78366: PUSH
78367: LD_INT 91
78369: PUSH
78370: LD_VAR 0 1
78374: PUSH
78375: LD_INT 10
78377: PUSH
78378: EMPTY
78379: LIST
78380: LIST
78381: LIST
78382: PUSH
78383: EMPTY
78384: LIST
78385: LIST
78386: LIST
78387: PPUSH
78388: CALL_OW 69
78392: NOT
78393: IFFALSE 78403
// weapon := ru_time_lapser ;
78395: LD_ADDR_VAR 0 18
78399: PUSH
78400: LD_INT 49
78402: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
78403: LD_VAR 0 12
78407: PUSH
78408: LD_INT 1
78410: PUSH
78411: LD_INT 2
78413: PUSH
78414: EMPTY
78415: LIST
78416: LIST
78417: IN
78418: PUSH
78419: LD_INT 11
78421: PUSH
78422: LD_VAR 0 5
78426: IN
78427: PUSH
78428: LD_INT 30
78430: PUSH
78431: LD_VAR 0 5
78435: IN
78436: OR
78437: AND
78438: PUSH
78439: LD_INT 6
78441: PPUSH
78442: LD_VAR 0 16
78446: PPUSH
78447: CALL_OW 321
78451: PUSH
78452: LD_INT 2
78454: EQUAL
78455: AND
78456: IFFALSE 78621
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
78458: LD_INT 22
78460: PUSH
78461: LD_VAR 0 16
78465: PUSH
78466: EMPTY
78467: LIST
78468: LIST
78469: PUSH
78470: LD_INT 2
78472: PUSH
78473: LD_INT 35
78475: PUSH
78476: LD_INT 11
78478: PUSH
78479: EMPTY
78480: LIST
78481: LIST
78482: PUSH
78483: LD_INT 35
78485: PUSH
78486: LD_INT 30
78488: PUSH
78489: EMPTY
78490: LIST
78491: LIST
78492: PUSH
78493: EMPTY
78494: LIST
78495: LIST
78496: LIST
78497: PUSH
78498: LD_INT 91
78500: PUSH
78501: LD_VAR 0 1
78505: PUSH
78506: LD_INT 18
78508: PUSH
78509: EMPTY
78510: LIST
78511: LIST
78512: LIST
78513: PUSH
78514: EMPTY
78515: LIST
78516: LIST
78517: LIST
78518: PPUSH
78519: CALL_OW 69
78523: NOT
78524: PUSH
78525: LD_INT 22
78527: PUSH
78528: LD_VAR 0 16
78532: PUSH
78533: EMPTY
78534: LIST
78535: LIST
78536: PUSH
78537: LD_INT 2
78539: PUSH
78540: LD_INT 30
78542: PUSH
78543: LD_INT 32
78545: PUSH
78546: EMPTY
78547: LIST
78548: LIST
78549: PUSH
78550: LD_INT 30
78552: PUSH
78553: LD_INT 33
78555: PUSH
78556: EMPTY
78557: LIST
78558: LIST
78559: PUSH
78560: EMPTY
78561: LIST
78562: LIST
78563: LIST
78564: PUSH
78565: LD_INT 91
78567: PUSH
78568: LD_VAR 0 1
78572: PUSH
78573: LD_INT 12
78575: PUSH
78576: EMPTY
78577: LIST
78578: LIST
78579: LIST
78580: PUSH
78581: EMPTY
78582: LIST
78583: LIST
78584: LIST
78585: PUSH
78586: EMPTY
78587: LIST
78588: PPUSH
78589: CALL_OW 69
78593: PUSH
78594: LD_INT 2
78596: GREATER
78597: AND
78598: IFFALSE 78621
// weapon := [ us_radar , ar_radar ] [ nat ] ;
78600: LD_ADDR_VAR 0 18
78604: PUSH
78605: LD_INT 11
78607: PUSH
78608: LD_INT 30
78610: PUSH
78611: EMPTY
78612: LIST
78613: LIST
78614: PUSH
78615: LD_VAR 0 12
78619: ARRAY
78620: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
78621: LD_VAR 0 18
78625: NOT
78626: PUSH
78627: LD_INT 40
78629: PPUSH
78630: LD_VAR 0 16
78634: PPUSH
78635: CALL_OW 321
78639: PUSH
78640: LD_INT 2
78642: EQUAL
78643: AND
78644: PUSH
78645: LD_INT 7
78647: PUSH
78648: LD_VAR 0 5
78652: IN
78653: PUSH
78654: LD_INT 28
78656: PUSH
78657: LD_VAR 0 5
78661: IN
78662: OR
78663: PUSH
78664: LD_INT 45
78666: PUSH
78667: LD_VAR 0 5
78671: IN
78672: OR
78673: AND
78674: IFFALSE 78928
// begin hex := GetHexInfo ( x , y ) ;
78676: LD_ADDR_VAR 0 4
78680: PUSH
78681: LD_VAR 0 10
78685: PPUSH
78686: LD_VAR 0 11
78690: PPUSH
78691: CALL_OW 546
78695: ST_TO_ADDR
// if hex [ 1 ] then
78696: LD_VAR 0 4
78700: PUSH
78701: LD_INT 1
78703: ARRAY
78704: IFFALSE 78708
// exit ;
78706: GO 79111
// height := hex [ 2 ] ;
78708: LD_ADDR_VAR 0 15
78712: PUSH
78713: LD_VAR 0 4
78717: PUSH
78718: LD_INT 2
78720: ARRAY
78721: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
78722: LD_ADDR_VAR 0 14
78726: PUSH
78727: LD_INT 0
78729: PUSH
78730: LD_INT 2
78732: PUSH
78733: LD_INT 3
78735: PUSH
78736: LD_INT 5
78738: PUSH
78739: EMPTY
78740: LIST
78741: LIST
78742: LIST
78743: LIST
78744: ST_TO_ADDR
// for i in tmp do
78745: LD_ADDR_VAR 0 8
78749: PUSH
78750: LD_VAR 0 14
78754: PUSH
78755: FOR_IN
78756: IFFALSE 78926
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
78758: LD_ADDR_VAR 0 9
78762: PUSH
78763: LD_VAR 0 10
78767: PPUSH
78768: LD_VAR 0 8
78772: PPUSH
78773: LD_INT 5
78775: PPUSH
78776: CALL_OW 272
78780: PUSH
78781: LD_VAR 0 11
78785: PPUSH
78786: LD_VAR 0 8
78790: PPUSH
78791: LD_INT 5
78793: PPUSH
78794: CALL_OW 273
78798: PUSH
78799: EMPTY
78800: LIST
78801: LIST
78802: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
78803: LD_VAR 0 9
78807: PUSH
78808: LD_INT 1
78810: ARRAY
78811: PPUSH
78812: LD_VAR 0 9
78816: PUSH
78817: LD_INT 2
78819: ARRAY
78820: PPUSH
78821: CALL_OW 488
78825: IFFALSE 78924
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
78827: LD_ADDR_VAR 0 4
78831: PUSH
78832: LD_VAR 0 9
78836: PUSH
78837: LD_INT 1
78839: ARRAY
78840: PPUSH
78841: LD_VAR 0 9
78845: PUSH
78846: LD_INT 2
78848: ARRAY
78849: PPUSH
78850: CALL_OW 546
78854: ST_TO_ADDR
// if hex [ 1 ] then
78855: LD_VAR 0 4
78859: PUSH
78860: LD_INT 1
78862: ARRAY
78863: IFFALSE 78867
// continue ;
78865: GO 78755
// h := hex [ 2 ] ;
78867: LD_ADDR_VAR 0 13
78871: PUSH
78872: LD_VAR 0 4
78876: PUSH
78877: LD_INT 2
78879: ARRAY
78880: ST_TO_ADDR
// if h + 7 < height then
78881: LD_VAR 0 13
78885: PUSH
78886: LD_INT 7
78888: PLUS
78889: PUSH
78890: LD_VAR 0 15
78894: LESS
78895: IFFALSE 78924
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
78897: LD_ADDR_VAR 0 18
78901: PUSH
78902: LD_INT 7
78904: PUSH
78905: LD_INT 28
78907: PUSH
78908: LD_INT 45
78910: PUSH
78911: EMPTY
78912: LIST
78913: LIST
78914: LIST
78915: PUSH
78916: LD_VAR 0 12
78920: ARRAY
78921: ST_TO_ADDR
// break ;
78922: GO 78926
// end ; end ; end ;
78924: GO 78755
78926: POP
78927: POP
// end ; if not weapon then
78928: LD_VAR 0 18
78932: NOT
78933: IFFALSE 78993
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
78935: LD_ADDR_VAR 0 5
78939: PUSH
78940: LD_VAR 0 5
78944: PUSH
78945: LD_INT 11
78947: PUSH
78948: LD_INT 30
78950: PUSH
78951: LD_INT 49
78953: PUSH
78954: EMPTY
78955: LIST
78956: LIST
78957: LIST
78958: DIFF
78959: ST_TO_ADDR
// if not list then
78960: LD_VAR 0 5
78964: NOT
78965: IFFALSE 78969
// exit ;
78967: GO 79111
// weapon := list [ rand ( 1 , list ) ] ;
78969: LD_ADDR_VAR 0 18
78973: PUSH
78974: LD_VAR 0 5
78978: PUSH
78979: LD_INT 1
78981: PPUSH
78982: LD_VAR 0 5
78986: PPUSH
78987: CALL_OW 12
78991: ARRAY
78992: ST_TO_ADDR
// end ; if weapon then
78993: LD_VAR 0 18
78997: IFFALSE 79111
// begin tmp := CostOfWeapon ( weapon ) ;
78999: LD_ADDR_VAR 0 14
79003: PUSH
79004: LD_VAR 0 18
79008: PPUSH
79009: CALL_OW 451
79013: ST_TO_ADDR
// j := GetBase ( tower ) ;
79014: LD_ADDR_VAR 0 9
79018: PUSH
79019: LD_VAR 0 1
79023: PPUSH
79024: CALL_OW 274
79028: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
79029: LD_VAR 0 9
79033: PPUSH
79034: LD_INT 1
79036: PPUSH
79037: CALL_OW 275
79041: PUSH
79042: LD_VAR 0 14
79046: PUSH
79047: LD_INT 1
79049: ARRAY
79050: GREATEREQUAL
79051: PUSH
79052: LD_VAR 0 9
79056: PPUSH
79057: LD_INT 2
79059: PPUSH
79060: CALL_OW 275
79064: PUSH
79065: LD_VAR 0 14
79069: PUSH
79070: LD_INT 2
79072: ARRAY
79073: GREATEREQUAL
79074: AND
79075: PUSH
79076: LD_VAR 0 9
79080: PPUSH
79081: LD_INT 3
79083: PPUSH
79084: CALL_OW 275
79088: PUSH
79089: LD_VAR 0 14
79093: PUSH
79094: LD_INT 3
79096: ARRAY
79097: GREATEREQUAL
79098: AND
79099: IFFALSE 79111
// result := weapon ;
79101: LD_ADDR_VAR 0 3
79105: PUSH
79106: LD_VAR 0 18
79110: ST_TO_ADDR
// end ; end ;
79111: LD_VAR 0 3
79115: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
79116: LD_INT 0
79118: PPUSH
79119: PPUSH
// result := true ;
79120: LD_ADDR_VAR 0 3
79124: PUSH
79125: LD_INT 1
79127: ST_TO_ADDR
// if array1 = array2 then
79128: LD_VAR 0 1
79132: PUSH
79133: LD_VAR 0 2
79137: EQUAL
79138: IFFALSE 79198
// begin for i = 1 to array1 do
79140: LD_ADDR_VAR 0 4
79144: PUSH
79145: DOUBLE
79146: LD_INT 1
79148: DEC
79149: ST_TO_ADDR
79150: LD_VAR 0 1
79154: PUSH
79155: FOR_TO
79156: IFFALSE 79194
// if array1 [ i ] <> array2 [ i ] then
79158: LD_VAR 0 1
79162: PUSH
79163: LD_VAR 0 4
79167: ARRAY
79168: PUSH
79169: LD_VAR 0 2
79173: PUSH
79174: LD_VAR 0 4
79178: ARRAY
79179: NONEQUAL
79180: IFFALSE 79192
// begin result := false ;
79182: LD_ADDR_VAR 0 3
79186: PUSH
79187: LD_INT 0
79189: ST_TO_ADDR
// break ;
79190: GO 79194
// end ;
79192: GO 79155
79194: POP
79195: POP
// end else
79196: GO 79206
// result := false ;
79198: LD_ADDR_VAR 0 3
79202: PUSH
79203: LD_INT 0
79205: ST_TO_ADDR
// end ;
79206: LD_VAR 0 3
79210: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
79211: LD_INT 0
79213: PPUSH
79214: PPUSH
// if not array1 or not array2 then
79215: LD_VAR 0 1
79219: NOT
79220: PUSH
79221: LD_VAR 0 2
79225: NOT
79226: OR
79227: IFFALSE 79231
// exit ;
79229: GO 79295
// result := true ;
79231: LD_ADDR_VAR 0 3
79235: PUSH
79236: LD_INT 1
79238: ST_TO_ADDR
// for i = 1 to array1 do
79239: LD_ADDR_VAR 0 4
79243: PUSH
79244: DOUBLE
79245: LD_INT 1
79247: DEC
79248: ST_TO_ADDR
79249: LD_VAR 0 1
79253: PUSH
79254: FOR_TO
79255: IFFALSE 79293
// if array1 [ i ] <> array2 [ i ] then
79257: LD_VAR 0 1
79261: PUSH
79262: LD_VAR 0 4
79266: ARRAY
79267: PUSH
79268: LD_VAR 0 2
79272: PUSH
79273: LD_VAR 0 4
79277: ARRAY
79278: NONEQUAL
79279: IFFALSE 79291
// begin result := false ;
79281: LD_ADDR_VAR 0 3
79285: PUSH
79286: LD_INT 0
79288: ST_TO_ADDR
// break ;
79289: GO 79293
// end ;
79291: GO 79254
79293: POP
79294: POP
// end ;
79295: LD_VAR 0 3
79299: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
79300: LD_INT 0
79302: PPUSH
79303: PPUSH
79304: PPUSH
// pom := GetBase ( fac ) ;
79305: LD_ADDR_VAR 0 5
79309: PUSH
79310: LD_VAR 0 1
79314: PPUSH
79315: CALL_OW 274
79319: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
79320: LD_ADDR_VAR 0 4
79324: PUSH
79325: LD_VAR 0 2
79329: PUSH
79330: LD_INT 1
79332: ARRAY
79333: PPUSH
79334: LD_VAR 0 2
79338: PUSH
79339: LD_INT 2
79341: ARRAY
79342: PPUSH
79343: LD_VAR 0 2
79347: PUSH
79348: LD_INT 3
79350: ARRAY
79351: PPUSH
79352: LD_VAR 0 2
79356: PUSH
79357: LD_INT 4
79359: ARRAY
79360: PPUSH
79361: CALL_OW 449
79365: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79366: LD_ADDR_VAR 0 3
79370: PUSH
79371: LD_VAR 0 5
79375: PPUSH
79376: LD_INT 1
79378: PPUSH
79379: CALL_OW 275
79383: PUSH
79384: LD_VAR 0 4
79388: PUSH
79389: LD_INT 1
79391: ARRAY
79392: GREATEREQUAL
79393: PUSH
79394: LD_VAR 0 5
79398: PPUSH
79399: LD_INT 2
79401: PPUSH
79402: CALL_OW 275
79406: PUSH
79407: LD_VAR 0 4
79411: PUSH
79412: LD_INT 2
79414: ARRAY
79415: GREATEREQUAL
79416: AND
79417: PUSH
79418: LD_VAR 0 5
79422: PPUSH
79423: LD_INT 3
79425: PPUSH
79426: CALL_OW 275
79430: PUSH
79431: LD_VAR 0 4
79435: PUSH
79436: LD_INT 3
79438: ARRAY
79439: GREATEREQUAL
79440: AND
79441: ST_TO_ADDR
// end ;
79442: LD_VAR 0 3
79446: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
79447: LD_INT 0
79449: PPUSH
79450: PPUSH
79451: PPUSH
79452: PPUSH
// pom := GetBase ( building ) ;
79453: LD_ADDR_VAR 0 3
79457: PUSH
79458: LD_VAR 0 1
79462: PPUSH
79463: CALL_OW 274
79467: ST_TO_ADDR
// if not pom then
79468: LD_VAR 0 3
79472: NOT
79473: IFFALSE 79477
// exit ;
79475: GO 79647
// btype := GetBType ( building ) ;
79477: LD_ADDR_VAR 0 5
79481: PUSH
79482: LD_VAR 0 1
79486: PPUSH
79487: CALL_OW 266
79491: ST_TO_ADDR
// if btype = b_armoury then
79492: LD_VAR 0 5
79496: PUSH
79497: LD_INT 4
79499: EQUAL
79500: IFFALSE 79510
// btype := b_barracks ;
79502: LD_ADDR_VAR 0 5
79506: PUSH
79507: LD_INT 5
79509: ST_TO_ADDR
// if btype = b_depot then
79510: LD_VAR 0 5
79514: PUSH
79515: LD_INT 0
79517: EQUAL
79518: IFFALSE 79528
// btype := b_warehouse ;
79520: LD_ADDR_VAR 0 5
79524: PUSH
79525: LD_INT 1
79527: ST_TO_ADDR
// if btype = b_workshop then
79528: LD_VAR 0 5
79532: PUSH
79533: LD_INT 2
79535: EQUAL
79536: IFFALSE 79546
// btype := b_factory ;
79538: LD_ADDR_VAR 0 5
79542: PUSH
79543: LD_INT 3
79545: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
79546: LD_ADDR_VAR 0 4
79550: PUSH
79551: LD_VAR 0 5
79555: PPUSH
79556: LD_VAR 0 1
79560: PPUSH
79561: CALL_OW 248
79565: PPUSH
79566: CALL_OW 450
79570: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79571: LD_ADDR_VAR 0 2
79575: PUSH
79576: LD_VAR 0 3
79580: PPUSH
79581: LD_INT 1
79583: PPUSH
79584: CALL_OW 275
79588: PUSH
79589: LD_VAR 0 4
79593: PUSH
79594: LD_INT 1
79596: ARRAY
79597: GREATEREQUAL
79598: PUSH
79599: LD_VAR 0 3
79603: PPUSH
79604: LD_INT 2
79606: PPUSH
79607: CALL_OW 275
79611: PUSH
79612: LD_VAR 0 4
79616: PUSH
79617: LD_INT 2
79619: ARRAY
79620: GREATEREQUAL
79621: AND
79622: PUSH
79623: LD_VAR 0 3
79627: PPUSH
79628: LD_INT 3
79630: PPUSH
79631: CALL_OW 275
79635: PUSH
79636: LD_VAR 0 4
79640: PUSH
79641: LD_INT 3
79643: ARRAY
79644: GREATEREQUAL
79645: AND
79646: ST_TO_ADDR
// end ;
79647: LD_VAR 0 2
79651: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
79652: LD_INT 0
79654: PPUSH
79655: PPUSH
79656: PPUSH
// pom := GetBase ( building ) ;
79657: LD_ADDR_VAR 0 4
79661: PUSH
79662: LD_VAR 0 1
79666: PPUSH
79667: CALL_OW 274
79671: ST_TO_ADDR
// if not pom then
79672: LD_VAR 0 4
79676: NOT
79677: IFFALSE 79681
// exit ;
79679: GO 79782
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
79681: LD_ADDR_VAR 0 5
79685: PUSH
79686: LD_VAR 0 2
79690: PPUSH
79691: LD_VAR 0 1
79695: PPUSH
79696: CALL_OW 248
79700: PPUSH
79701: CALL_OW 450
79705: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79706: LD_ADDR_VAR 0 3
79710: PUSH
79711: LD_VAR 0 4
79715: PPUSH
79716: LD_INT 1
79718: PPUSH
79719: CALL_OW 275
79723: PUSH
79724: LD_VAR 0 5
79728: PUSH
79729: LD_INT 1
79731: ARRAY
79732: GREATEREQUAL
79733: PUSH
79734: LD_VAR 0 4
79738: PPUSH
79739: LD_INT 2
79741: PPUSH
79742: CALL_OW 275
79746: PUSH
79747: LD_VAR 0 5
79751: PUSH
79752: LD_INT 2
79754: ARRAY
79755: GREATEREQUAL
79756: AND
79757: PUSH
79758: LD_VAR 0 4
79762: PPUSH
79763: LD_INT 3
79765: PPUSH
79766: CALL_OW 275
79770: PUSH
79771: LD_VAR 0 5
79775: PUSH
79776: LD_INT 3
79778: ARRAY
79779: GREATEREQUAL
79780: AND
79781: ST_TO_ADDR
// end ;
79782: LD_VAR 0 3
79786: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
79787: LD_INT 0
79789: PPUSH
79790: PPUSH
79791: PPUSH
79792: PPUSH
79793: PPUSH
79794: PPUSH
79795: PPUSH
79796: PPUSH
79797: PPUSH
79798: PPUSH
79799: PPUSH
// result := false ;
79800: LD_ADDR_VAR 0 8
79804: PUSH
79805: LD_INT 0
79807: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
79808: LD_VAR 0 5
79812: NOT
79813: PUSH
79814: LD_VAR 0 1
79818: NOT
79819: OR
79820: PUSH
79821: LD_VAR 0 2
79825: NOT
79826: OR
79827: PUSH
79828: LD_VAR 0 3
79832: NOT
79833: OR
79834: IFFALSE 79838
// exit ;
79836: GO 80652
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
79838: LD_ADDR_VAR 0 14
79842: PUSH
79843: LD_VAR 0 1
79847: PPUSH
79848: LD_VAR 0 2
79852: PPUSH
79853: LD_VAR 0 3
79857: PPUSH
79858: LD_VAR 0 4
79862: PPUSH
79863: LD_VAR 0 5
79867: PUSH
79868: LD_INT 1
79870: ARRAY
79871: PPUSH
79872: CALL_OW 248
79876: PPUSH
79877: LD_INT 0
79879: PPUSH
79880: CALL 81885 0 6
79884: ST_TO_ADDR
// if not hexes then
79885: LD_VAR 0 14
79889: NOT
79890: IFFALSE 79894
// exit ;
79892: GO 80652
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
79894: LD_ADDR_VAR 0 17
79898: PUSH
79899: LD_VAR 0 5
79903: PPUSH
79904: LD_INT 22
79906: PUSH
79907: LD_VAR 0 13
79911: PPUSH
79912: CALL_OW 255
79916: PUSH
79917: EMPTY
79918: LIST
79919: LIST
79920: PUSH
79921: LD_INT 2
79923: PUSH
79924: LD_INT 30
79926: PUSH
79927: LD_INT 0
79929: PUSH
79930: EMPTY
79931: LIST
79932: LIST
79933: PUSH
79934: LD_INT 30
79936: PUSH
79937: LD_INT 1
79939: PUSH
79940: EMPTY
79941: LIST
79942: LIST
79943: PUSH
79944: EMPTY
79945: LIST
79946: LIST
79947: LIST
79948: PUSH
79949: EMPTY
79950: LIST
79951: LIST
79952: PPUSH
79953: CALL_OW 72
79957: ST_TO_ADDR
// for i = 1 to hexes do
79958: LD_ADDR_VAR 0 9
79962: PUSH
79963: DOUBLE
79964: LD_INT 1
79966: DEC
79967: ST_TO_ADDR
79968: LD_VAR 0 14
79972: PUSH
79973: FOR_TO
79974: IFFALSE 80650
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79976: LD_ADDR_VAR 0 13
79980: PUSH
79981: LD_VAR 0 14
79985: PUSH
79986: LD_VAR 0 9
79990: ARRAY
79991: PUSH
79992: LD_INT 1
79994: ARRAY
79995: PPUSH
79996: LD_VAR 0 14
80000: PUSH
80001: LD_VAR 0 9
80005: ARRAY
80006: PUSH
80007: LD_INT 2
80009: ARRAY
80010: PPUSH
80011: CALL_OW 428
80015: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
80016: LD_VAR 0 14
80020: PUSH
80021: LD_VAR 0 9
80025: ARRAY
80026: PUSH
80027: LD_INT 1
80029: ARRAY
80030: PPUSH
80031: LD_VAR 0 14
80035: PUSH
80036: LD_VAR 0 9
80040: ARRAY
80041: PUSH
80042: LD_INT 2
80044: ARRAY
80045: PPUSH
80046: CALL_OW 351
80050: PUSH
80051: LD_VAR 0 14
80055: PUSH
80056: LD_VAR 0 9
80060: ARRAY
80061: PUSH
80062: LD_INT 1
80064: ARRAY
80065: PPUSH
80066: LD_VAR 0 14
80070: PUSH
80071: LD_VAR 0 9
80075: ARRAY
80076: PUSH
80077: LD_INT 2
80079: ARRAY
80080: PPUSH
80081: CALL_OW 488
80085: NOT
80086: OR
80087: PUSH
80088: LD_VAR 0 13
80092: PPUSH
80093: CALL_OW 247
80097: PUSH
80098: LD_INT 3
80100: EQUAL
80101: OR
80102: IFFALSE 80108
// exit ;
80104: POP
80105: POP
80106: GO 80652
// if not tmp then
80108: LD_VAR 0 13
80112: NOT
80113: IFFALSE 80117
// continue ;
80115: GO 79973
// result := true ;
80117: LD_ADDR_VAR 0 8
80121: PUSH
80122: LD_INT 1
80124: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
80125: LD_VAR 0 6
80129: PUSH
80130: LD_VAR 0 13
80134: PPUSH
80135: CALL_OW 247
80139: PUSH
80140: LD_INT 2
80142: EQUAL
80143: AND
80144: PUSH
80145: LD_VAR 0 13
80149: PPUSH
80150: CALL_OW 263
80154: PUSH
80155: LD_INT 1
80157: EQUAL
80158: AND
80159: IFFALSE 80323
// begin if IsDrivenBy ( tmp ) then
80161: LD_VAR 0 13
80165: PPUSH
80166: CALL_OW 311
80170: IFFALSE 80174
// continue ;
80172: GO 79973
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
80174: LD_VAR 0 6
80178: PPUSH
80179: LD_INT 3
80181: PUSH
80182: LD_INT 60
80184: PUSH
80185: EMPTY
80186: LIST
80187: PUSH
80188: EMPTY
80189: LIST
80190: LIST
80191: PUSH
80192: LD_INT 3
80194: PUSH
80195: LD_INT 55
80197: PUSH
80198: EMPTY
80199: LIST
80200: PUSH
80201: EMPTY
80202: LIST
80203: LIST
80204: PUSH
80205: EMPTY
80206: LIST
80207: LIST
80208: PPUSH
80209: CALL_OW 72
80213: IFFALSE 80321
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
80215: LD_ADDR_VAR 0 18
80219: PUSH
80220: LD_VAR 0 6
80224: PPUSH
80225: LD_INT 3
80227: PUSH
80228: LD_INT 60
80230: PUSH
80231: EMPTY
80232: LIST
80233: PUSH
80234: EMPTY
80235: LIST
80236: LIST
80237: PUSH
80238: LD_INT 3
80240: PUSH
80241: LD_INT 55
80243: PUSH
80244: EMPTY
80245: LIST
80246: PUSH
80247: EMPTY
80248: LIST
80249: LIST
80250: PUSH
80251: EMPTY
80252: LIST
80253: LIST
80254: PPUSH
80255: CALL_OW 72
80259: PUSH
80260: LD_INT 1
80262: ARRAY
80263: ST_TO_ADDR
// if IsInUnit ( driver ) then
80264: LD_VAR 0 18
80268: PPUSH
80269: CALL_OW 310
80273: IFFALSE 80284
// ComExit ( driver ) ;
80275: LD_VAR 0 18
80279: PPUSH
80280: CALL 105664 0 1
// AddComEnterUnit ( driver , tmp ) ;
80284: LD_VAR 0 18
80288: PPUSH
80289: LD_VAR 0 13
80293: PPUSH
80294: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
80298: LD_VAR 0 18
80302: PPUSH
80303: LD_VAR 0 7
80307: PPUSH
80308: CALL_OW 173
// AddComExitVehicle ( driver ) ;
80312: LD_VAR 0 18
80316: PPUSH
80317: CALL_OW 181
// end ; continue ;
80321: GO 79973
// end ; if not cleaners or not tmp in cleaners then
80323: LD_VAR 0 6
80327: NOT
80328: PUSH
80329: LD_VAR 0 13
80333: PUSH
80334: LD_VAR 0 6
80338: IN
80339: NOT
80340: OR
80341: IFFALSE 80648
// begin if dep then
80343: LD_VAR 0 17
80347: IFFALSE 80483
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
80349: LD_ADDR_VAR 0 16
80353: PUSH
80354: LD_VAR 0 17
80358: PUSH
80359: LD_INT 1
80361: ARRAY
80362: PPUSH
80363: CALL_OW 250
80367: PPUSH
80368: LD_VAR 0 17
80372: PUSH
80373: LD_INT 1
80375: ARRAY
80376: PPUSH
80377: CALL_OW 254
80381: PPUSH
80382: LD_INT 5
80384: PPUSH
80385: CALL_OW 272
80389: PUSH
80390: LD_VAR 0 17
80394: PUSH
80395: LD_INT 1
80397: ARRAY
80398: PPUSH
80399: CALL_OW 251
80403: PPUSH
80404: LD_VAR 0 17
80408: PUSH
80409: LD_INT 1
80411: ARRAY
80412: PPUSH
80413: CALL_OW 254
80417: PPUSH
80418: LD_INT 5
80420: PPUSH
80421: CALL_OW 273
80425: PUSH
80426: EMPTY
80427: LIST
80428: LIST
80429: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
80430: LD_VAR 0 16
80434: PUSH
80435: LD_INT 1
80437: ARRAY
80438: PPUSH
80439: LD_VAR 0 16
80443: PUSH
80444: LD_INT 2
80446: ARRAY
80447: PPUSH
80448: CALL_OW 488
80452: IFFALSE 80483
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
80454: LD_VAR 0 13
80458: PPUSH
80459: LD_VAR 0 16
80463: PUSH
80464: LD_INT 1
80466: ARRAY
80467: PPUSH
80468: LD_VAR 0 16
80472: PUSH
80473: LD_INT 2
80475: ARRAY
80476: PPUSH
80477: CALL_OW 111
// continue ;
80481: GO 79973
// end ; end ; r := GetDir ( tmp ) ;
80483: LD_ADDR_VAR 0 15
80487: PUSH
80488: LD_VAR 0 13
80492: PPUSH
80493: CALL_OW 254
80497: ST_TO_ADDR
// if r = 5 then
80498: LD_VAR 0 15
80502: PUSH
80503: LD_INT 5
80505: EQUAL
80506: IFFALSE 80516
// r := 0 ;
80508: LD_ADDR_VAR 0 15
80512: PUSH
80513: LD_INT 0
80515: ST_TO_ADDR
// for j = r to 5 do
80516: LD_ADDR_VAR 0 10
80520: PUSH
80521: DOUBLE
80522: LD_VAR 0 15
80526: DEC
80527: ST_TO_ADDR
80528: LD_INT 5
80530: PUSH
80531: FOR_TO
80532: IFFALSE 80646
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
80534: LD_ADDR_VAR 0 11
80538: PUSH
80539: LD_VAR 0 13
80543: PPUSH
80544: CALL_OW 250
80548: PPUSH
80549: LD_VAR 0 10
80553: PPUSH
80554: LD_INT 2
80556: PPUSH
80557: CALL_OW 272
80561: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
80562: LD_ADDR_VAR 0 12
80566: PUSH
80567: LD_VAR 0 13
80571: PPUSH
80572: CALL_OW 251
80576: PPUSH
80577: LD_VAR 0 10
80581: PPUSH
80582: LD_INT 2
80584: PPUSH
80585: CALL_OW 273
80589: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
80590: LD_VAR 0 11
80594: PPUSH
80595: LD_VAR 0 12
80599: PPUSH
80600: CALL_OW 488
80604: PUSH
80605: LD_VAR 0 11
80609: PPUSH
80610: LD_VAR 0 12
80614: PPUSH
80615: CALL_OW 428
80619: NOT
80620: AND
80621: IFFALSE 80644
// begin ComMoveXY ( tmp , _x , _y ) ;
80623: LD_VAR 0 13
80627: PPUSH
80628: LD_VAR 0 11
80632: PPUSH
80633: LD_VAR 0 12
80637: PPUSH
80638: CALL_OW 111
// break ;
80642: GO 80646
// end ; end ;
80644: GO 80531
80646: POP
80647: POP
// end ; end ;
80648: GO 79973
80650: POP
80651: POP
// end ;
80652: LD_VAR 0 8
80656: RET
// export function BuildingTechInvented ( side , btype ) ; begin
80657: LD_INT 0
80659: PPUSH
// result := true ;
80660: LD_ADDR_VAR 0 3
80664: PUSH
80665: LD_INT 1
80667: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
80668: LD_VAR 0 2
80672: PUSH
80673: LD_INT 24
80675: DOUBLE
80676: EQUAL
80677: IFTRUE 80687
80679: LD_INT 33
80681: DOUBLE
80682: EQUAL
80683: IFTRUE 80687
80685: GO 80712
80687: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
80688: LD_ADDR_VAR 0 3
80692: PUSH
80693: LD_INT 32
80695: PPUSH
80696: LD_VAR 0 1
80700: PPUSH
80701: CALL_OW 321
80705: PUSH
80706: LD_INT 2
80708: EQUAL
80709: ST_TO_ADDR
80710: GO 81028
80712: LD_INT 20
80714: DOUBLE
80715: EQUAL
80716: IFTRUE 80720
80718: GO 80745
80720: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
80721: LD_ADDR_VAR 0 3
80725: PUSH
80726: LD_INT 6
80728: PPUSH
80729: LD_VAR 0 1
80733: PPUSH
80734: CALL_OW 321
80738: PUSH
80739: LD_INT 2
80741: EQUAL
80742: ST_TO_ADDR
80743: GO 81028
80745: LD_INT 22
80747: DOUBLE
80748: EQUAL
80749: IFTRUE 80759
80751: LD_INT 36
80753: DOUBLE
80754: EQUAL
80755: IFTRUE 80759
80757: GO 80784
80759: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
80760: LD_ADDR_VAR 0 3
80764: PUSH
80765: LD_INT 15
80767: PPUSH
80768: LD_VAR 0 1
80772: PPUSH
80773: CALL_OW 321
80777: PUSH
80778: LD_INT 2
80780: EQUAL
80781: ST_TO_ADDR
80782: GO 81028
80784: LD_INT 30
80786: DOUBLE
80787: EQUAL
80788: IFTRUE 80792
80790: GO 80817
80792: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
80793: LD_ADDR_VAR 0 3
80797: PUSH
80798: LD_INT 20
80800: PPUSH
80801: LD_VAR 0 1
80805: PPUSH
80806: CALL_OW 321
80810: PUSH
80811: LD_INT 2
80813: EQUAL
80814: ST_TO_ADDR
80815: GO 81028
80817: LD_INT 28
80819: DOUBLE
80820: EQUAL
80821: IFTRUE 80831
80823: LD_INT 21
80825: DOUBLE
80826: EQUAL
80827: IFTRUE 80831
80829: GO 80856
80831: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
80832: LD_ADDR_VAR 0 3
80836: PUSH
80837: LD_INT 21
80839: PPUSH
80840: LD_VAR 0 1
80844: PPUSH
80845: CALL_OW 321
80849: PUSH
80850: LD_INT 2
80852: EQUAL
80853: ST_TO_ADDR
80854: GO 81028
80856: LD_INT 16
80858: DOUBLE
80859: EQUAL
80860: IFTRUE 80864
80862: GO 80889
80864: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
80865: LD_ADDR_VAR 0 3
80869: PUSH
80870: LD_INT 84
80872: PPUSH
80873: LD_VAR 0 1
80877: PPUSH
80878: CALL_OW 321
80882: PUSH
80883: LD_INT 2
80885: EQUAL
80886: ST_TO_ADDR
80887: GO 81028
80889: LD_INT 19
80891: DOUBLE
80892: EQUAL
80893: IFTRUE 80903
80895: LD_INT 23
80897: DOUBLE
80898: EQUAL
80899: IFTRUE 80903
80901: GO 80928
80903: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
80904: LD_ADDR_VAR 0 3
80908: PUSH
80909: LD_INT 83
80911: PPUSH
80912: LD_VAR 0 1
80916: PPUSH
80917: CALL_OW 321
80921: PUSH
80922: LD_INT 2
80924: EQUAL
80925: ST_TO_ADDR
80926: GO 81028
80928: LD_INT 17
80930: DOUBLE
80931: EQUAL
80932: IFTRUE 80936
80934: GO 80961
80936: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
80937: LD_ADDR_VAR 0 3
80941: PUSH
80942: LD_INT 39
80944: PPUSH
80945: LD_VAR 0 1
80949: PPUSH
80950: CALL_OW 321
80954: PUSH
80955: LD_INT 2
80957: EQUAL
80958: ST_TO_ADDR
80959: GO 81028
80961: LD_INT 18
80963: DOUBLE
80964: EQUAL
80965: IFTRUE 80969
80967: GO 80994
80969: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
80970: LD_ADDR_VAR 0 3
80974: PUSH
80975: LD_INT 40
80977: PPUSH
80978: LD_VAR 0 1
80982: PPUSH
80983: CALL_OW 321
80987: PUSH
80988: LD_INT 2
80990: EQUAL
80991: ST_TO_ADDR
80992: GO 81028
80994: LD_INT 27
80996: DOUBLE
80997: EQUAL
80998: IFTRUE 81002
81000: GO 81027
81002: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
81003: LD_ADDR_VAR 0 3
81007: PUSH
81008: LD_INT 35
81010: PPUSH
81011: LD_VAR 0 1
81015: PPUSH
81016: CALL_OW 321
81020: PUSH
81021: LD_INT 2
81023: EQUAL
81024: ST_TO_ADDR
81025: GO 81028
81027: POP
// end ;
81028: LD_VAR 0 3
81032: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
81033: LD_INT 0
81035: PPUSH
81036: PPUSH
81037: PPUSH
81038: PPUSH
81039: PPUSH
81040: PPUSH
81041: PPUSH
81042: PPUSH
81043: PPUSH
81044: PPUSH
81045: PPUSH
// result := false ;
81046: LD_ADDR_VAR 0 6
81050: PUSH
81051: LD_INT 0
81053: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
81054: LD_VAR 0 1
81058: NOT
81059: PUSH
81060: LD_VAR 0 1
81064: PPUSH
81065: CALL_OW 266
81069: PUSH
81070: LD_INT 0
81072: PUSH
81073: LD_INT 1
81075: PUSH
81076: EMPTY
81077: LIST
81078: LIST
81079: IN
81080: NOT
81081: OR
81082: PUSH
81083: LD_VAR 0 2
81087: NOT
81088: OR
81089: PUSH
81090: LD_VAR 0 5
81094: PUSH
81095: LD_INT 0
81097: PUSH
81098: LD_INT 1
81100: PUSH
81101: LD_INT 2
81103: PUSH
81104: LD_INT 3
81106: PUSH
81107: LD_INT 4
81109: PUSH
81110: LD_INT 5
81112: PUSH
81113: EMPTY
81114: LIST
81115: LIST
81116: LIST
81117: LIST
81118: LIST
81119: LIST
81120: IN
81121: NOT
81122: OR
81123: PUSH
81124: LD_VAR 0 3
81128: PPUSH
81129: LD_VAR 0 4
81133: PPUSH
81134: CALL_OW 488
81138: NOT
81139: OR
81140: IFFALSE 81144
// exit ;
81142: GO 81880
// side := GetSide ( depot ) ;
81144: LD_ADDR_VAR 0 9
81148: PUSH
81149: LD_VAR 0 1
81153: PPUSH
81154: CALL_OW 255
81158: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
81159: LD_VAR 0 9
81163: PPUSH
81164: LD_VAR 0 2
81168: PPUSH
81169: CALL 80657 0 2
81173: NOT
81174: IFFALSE 81178
// exit ;
81176: GO 81880
// pom := GetBase ( depot ) ;
81178: LD_ADDR_VAR 0 10
81182: PUSH
81183: LD_VAR 0 1
81187: PPUSH
81188: CALL_OW 274
81192: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
81193: LD_ADDR_VAR 0 11
81197: PUSH
81198: LD_VAR 0 2
81202: PPUSH
81203: LD_VAR 0 1
81207: PPUSH
81208: CALL_OW 248
81212: PPUSH
81213: CALL_OW 450
81217: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
81218: LD_VAR 0 10
81222: PPUSH
81223: LD_INT 1
81225: PPUSH
81226: CALL_OW 275
81230: PUSH
81231: LD_VAR 0 11
81235: PUSH
81236: LD_INT 1
81238: ARRAY
81239: GREATEREQUAL
81240: PUSH
81241: LD_VAR 0 10
81245: PPUSH
81246: LD_INT 2
81248: PPUSH
81249: CALL_OW 275
81253: PUSH
81254: LD_VAR 0 11
81258: PUSH
81259: LD_INT 2
81261: ARRAY
81262: GREATEREQUAL
81263: AND
81264: PUSH
81265: LD_VAR 0 10
81269: PPUSH
81270: LD_INT 3
81272: PPUSH
81273: CALL_OW 275
81277: PUSH
81278: LD_VAR 0 11
81282: PUSH
81283: LD_INT 3
81285: ARRAY
81286: GREATEREQUAL
81287: AND
81288: NOT
81289: IFFALSE 81293
// exit ;
81291: GO 81880
// if GetBType ( depot ) = b_depot then
81293: LD_VAR 0 1
81297: PPUSH
81298: CALL_OW 266
81302: PUSH
81303: LD_INT 0
81305: EQUAL
81306: IFFALSE 81318
// dist := 28 else
81308: LD_ADDR_VAR 0 14
81312: PUSH
81313: LD_INT 28
81315: ST_TO_ADDR
81316: GO 81326
// dist := 36 ;
81318: LD_ADDR_VAR 0 14
81322: PUSH
81323: LD_INT 36
81325: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
81326: LD_VAR 0 1
81330: PPUSH
81331: LD_VAR 0 3
81335: PPUSH
81336: LD_VAR 0 4
81340: PPUSH
81341: CALL_OW 297
81345: PUSH
81346: LD_VAR 0 14
81350: GREATER
81351: IFFALSE 81355
// exit ;
81353: GO 81880
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
81355: LD_ADDR_VAR 0 12
81359: PUSH
81360: LD_VAR 0 2
81364: PPUSH
81365: LD_VAR 0 3
81369: PPUSH
81370: LD_VAR 0 4
81374: PPUSH
81375: LD_VAR 0 5
81379: PPUSH
81380: LD_VAR 0 1
81384: PPUSH
81385: CALL_OW 248
81389: PPUSH
81390: LD_INT 0
81392: PPUSH
81393: CALL 81885 0 6
81397: ST_TO_ADDR
// if not hexes then
81398: LD_VAR 0 12
81402: NOT
81403: IFFALSE 81407
// exit ;
81405: GO 81880
// hex := GetHexInfo ( x , y ) ;
81407: LD_ADDR_VAR 0 15
81411: PUSH
81412: LD_VAR 0 3
81416: PPUSH
81417: LD_VAR 0 4
81421: PPUSH
81422: CALL_OW 546
81426: ST_TO_ADDR
// if hex [ 1 ] then
81427: LD_VAR 0 15
81431: PUSH
81432: LD_INT 1
81434: ARRAY
81435: IFFALSE 81439
// exit ;
81437: GO 81880
// height := hex [ 2 ] ;
81439: LD_ADDR_VAR 0 13
81443: PUSH
81444: LD_VAR 0 15
81448: PUSH
81449: LD_INT 2
81451: ARRAY
81452: ST_TO_ADDR
// for i = 1 to hexes do
81453: LD_ADDR_VAR 0 7
81457: PUSH
81458: DOUBLE
81459: LD_INT 1
81461: DEC
81462: ST_TO_ADDR
81463: LD_VAR 0 12
81467: PUSH
81468: FOR_TO
81469: IFFALSE 81799
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
81471: LD_VAR 0 12
81475: PUSH
81476: LD_VAR 0 7
81480: ARRAY
81481: PUSH
81482: LD_INT 1
81484: ARRAY
81485: PPUSH
81486: LD_VAR 0 12
81490: PUSH
81491: LD_VAR 0 7
81495: ARRAY
81496: PUSH
81497: LD_INT 2
81499: ARRAY
81500: PPUSH
81501: CALL_OW 488
81505: NOT
81506: PUSH
81507: LD_VAR 0 12
81511: PUSH
81512: LD_VAR 0 7
81516: ARRAY
81517: PUSH
81518: LD_INT 1
81520: ARRAY
81521: PPUSH
81522: LD_VAR 0 12
81526: PUSH
81527: LD_VAR 0 7
81531: ARRAY
81532: PUSH
81533: LD_INT 2
81535: ARRAY
81536: PPUSH
81537: CALL_OW 428
81541: PUSH
81542: LD_INT 0
81544: GREATER
81545: OR
81546: PUSH
81547: LD_VAR 0 12
81551: PUSH
81552: LD_VAR 0 7
81556: ARRAY
81557: PUSH
81558: LD_INT 1
81560: ARRAY
81561: PPUSH
81562: LD_VAR 0 12
81566: PUSH
81567: LD_VAR 0 7
81571: ARRAY
81572: PUSH
81573: LD_INT 2
81575: ARRAY
81576: PPUSH
81577: CALL_OW 351
81581: OR
81582: IFFALSE 81588
// exit ;
81584: POP
81585: POP
81586: GO 81880
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81588: LD_ADDR_VAR 0 8
81592: PUSH
81593: LD_VAR 0 12
81597: PUSH
81598: LD_VAR 0 7
81602: ARRAY
81603: PUSH
81604: LD_INT 1
81606: ARRAY
81607: PPUSH
81608: LD_VAR 0 12
81612: PUSH
81613: LD_VAR 0 7
81617: ARRAY
81618: PUSH
81619: LD_INT 2
81621: ARRAY
81622: PPUSH
81623: CALL_OW 546
81627: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
81628: LD_VAR 0 8
81632: PUSH
81633: LD_INT 1
81635: ARRAY
81636: PUSH
81637: LD_VAR 0 8
81641: PUSH
81642: LD_INT 2
81644: ARRAY
81645: PUSH
81646: LD_VAR 0 13
81650: PUSH
81651: LD_INT 2
81653: PLUS
81654: GREATER
81655: OR
81656: PUSH
81657: LD_VAR 0 8
81661: PUSH
81662: LD_INT 2
81664: ARRAY
81665: PUSH
81666: LD_VAR 0 13
81670: PUSH
81671: LD_INT 2
81673: MINUS
81674: LESS
81675: OR
81676: PUSH
81677: LD_VAR 0 8
81681: PUSH
81682: LD_INT 3
81684: ARRAY
81685: PUSH
81686: LD_INT 0
81688: PUSH
81689: LD_INT 8
81691: PUSH
81692: LD_INT 9
81694: PUSH
81695: LD_INT 10
81697: PUSH
81698: LD_INT 11
81700: PUSH
81701: LD_INT 12
81703: PUSH
81704: LD_INT 13
81706: PUSH
81707: LD_INT 16
81709: PUSH
81710: LD_INT 17
81712: PUSH
81713: LD_INT 18
81715: PUSH
81716: LD_INT 19
81718: PUSH
81719: LD_INT 20
81721: PUSH
81722: LD_INT 21
81724: PUSH
81725: EMPTY
81726: LIST
81727: LIST
81728: LIST
81729: LIST
81730: LIST
81731: LIST
81732: LIST
81733: LIST
81734: LIST
81735: LIST
81736: LIST
81737: LIST
81738: LIST
81739: IN
81740: NOT
81741: OR
81742: PUSH
81743: LD_VAR 0 8
81747: PUSH
81748: LD_INT 5
81750: ARRAY
81751: NOT
81752: OR
81753: PUSH
81754: LD_VAR 0 8
81758: PUSH
81759: LD_INT 6
81761: ARRAY
81762: PUSH
81763: LD_INT 1
81765: PUSH
81766: LD_INT 2
81768: PUSH
81769: LD_INT 7
81771: PUSH
81772: LD_INT 9
81774: PUSH
81775: LD_INT 10
81777: PUSH
81778: LD_INT 11
81780: PUSH
81781: EMPTY
81782: LIST
81783: LIST
81784: LIST
81785: LIST
81786: LIST
81787: LIST
81788: IN
81789: NOT
81790: OR
81791: IFFALSE 81797
// exit ;
81793: POP
81794: POP
81795: GO 81880
// end ;
81797: GO 81468
81799: POP
81800: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
81801: LD_VAR 0 9
81805: PPUSH
81806: LD_VAR 0 3
81810: PPUSH
81811: LD_VAR 0 4
81815: PPUSH
81816: LD_INT 20
81818: PPUSH
81819: CALL 73832 0 4
81823: PUSH
81824: LD_INT 4
81826: ARRAY
81827: IFFALSE 81831
// exit ;
81829: GO 81880
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
81831: LD_VAR 0 2
81835: PUSH
81836: LD_INT 29
81838: PUSH
81839: LD_INT 30
81841: PUSH
81842: EMPTY
81843: LIST
81844: LIST
81845: IN
81846: PUSH
81847: LD_VAR 0 3
81851: PPUSH
81852: LD_VAR 0 4
81856: PPUSH
81857: LD_VAR 0 9
81861: PPUSH
81862: CALL_OW 440
81866: NOT
81867: AND
81868: IFFALSE 81872
// exit ;
81870: GO 81880
// result := true ;
81872: LD_ADDR_VAR 0 6
81876: PUSH
81877: LD_INT 1
81879: ST_TO_ADDR
// end ;
81880: LD_VAR 0 6
81884: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
81885: LD_INT 0
81887: PPUSH
81888: PPUSH
81889: PPUSH
81890: PPUSH
81891: PPUSH
81892: PPUSH
81893: PPUSH
81894: PPUSH
81895: PPUSH
81896: PPUSH
81897: PPUSH
81898: PPUSH
81899: PPUSH
81900: PPUSH
81901: PPUSH
81902: PPUSH
81903: PPUSH
81904: PPUSH
81905: PPUSH
81906: PPUSH
81907: PPUSH
81908: PPUSH
81909: PPUSH
81910: PPUSH
81911: PPUSH
81912: PPUSH
81913: PPUSH
81914: PPUSH
81915: PPUSH
81916: PPUSH
81917: PPUSH
81918: PPUSH
81919: PPUSH
81920: PPUSH
81921: PPUSH
81922: PPUSH
81923: PPUSH
81924: PPUSH
81925: PPUSH
81926: PPUSH
81927: PPUSH
81928: PPUSH
81929: PPUSH
81930: PPUSH
81931: PPUSH
81932: PPUSH
81933: PPUSH
81934: PPUSH
81935: PPUSH
81936: PPUSH
81937: PPUSH
81938: PPUSH
81939: PPUSH
81940: PPUSH
81941: PPUSH
81942: PPUSH
81943: PPUSH
81944: PPUSH
// result = [ ] ;
81945: LD_ADDR_VAR 0 7
81949: PUSH
81950: EMPTY
81951: ST_TO_ADDR
// temp_list = [ ] ;
81952: LD_ADDR_VAR 0 9
81956: PUSH
81957: EMPTY
81958: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
81959: LD_VAR 0 4
81963: PUSH
81964: LD_INT 0
81966: PUSH
81967: LD_INT 1
81969: PUSH
81970: LD_INT 2
81972: PUSH
81973: LD_INT 3
81975: PUSH
81976: LD_INT 4
81978: PUSH
81979: LD_INT 5
81981: PUSH
81982: EMPTY
81983: LIST
81984: LIST
81985: LIST
81986: LIST
81987: LIST
81988: LIST
81989: IN
81990: NOT
81991: PUSH
81992: LD_VAR 0 1
81996: PUSH
81997: LD_INT 0
81999: PUSH
82000: LD_INT 1
82002: PUSH
82003: EMPTY
82004: LIST
82005: LIST
82006: IN
82007: PUSH
82008: LD_VAR 0 5
82012: PUSH
82013: LD_INT 1
82015: PUSH
82016: LD_INT 2
82018: PUSH
82019: LD_INT 3
82021: PUSH
82022: EMPTY
82023: LIST
82024: LIST
82025: LIST
82026: IN
82027: NOT
82028: AND
82029: OR
82030: IFFALSE 82034
// exit ;
82032: GO 100425
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
82034: LD_VAR 0 1
82038: PUSH
82039: LD_INT 6
82041: PUSH
82042: LD_INT 7
82044: PUSH
82045: LD_INT 8
82047: PUSH
82048: LD_INT 13
82050: PUSH
82051: LD_INT 12
82053: PUSH
82054: LD_INT 15
82056: PUSH
82057: LD_INT 11
82059: PUSH
82060: LD_INT 14
82062: PUSH
82063: LD_INT 10
82065: PUSH
82066: EMPTY
82067: LIST
82068: LIST
82069: LIST
82070: LIST
82071: LIST
82072: LIST
82073: LIST
82074: LIST
82075: LIST
82076: IN
82077: IFFALSE 82087
// btype = b_lab ;
82079: LD_ADDR_VAR 0 1
82083: PUSH
82084: LD_INT 6
82086: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
82087: LD_VAR 0 6
82091: PUSH
82092: LD_INT 0
82094: PUSH
82095: LD_INT 1
82097: PUSH
82098: LD_INT 2
82100: PUSH
82101: EMPTY
82102: LIST
82103: LIST
82104: LIST
82105: IN
82106: NOT
82107: PUSH
82108: LD_VAR 0 1
82112: PUSH
82113: LD_INT 0
82115: PUSH
82116: LD_INT 1
82118: PUSH
82119: LD_INT 2
82121: PUSH
82122: LD_INT 3
82124: PUSH
82125: LD_INT 6
82127: PUSH
82128: LD_INT 36
82130: PUSH
82131: LD_INT 4
82133: PUSH
82134: LD_INT 5
82136: PUSH
82137: LD_INT 31
82139: PUSH
82140: LD_INT 32
82142: PUSH
82143: LD_INT 33
82145: PUSH
82146: EMPTY
82147: LIST
82148: LIST
82149: LIST
82150: LIST
82151: LIST
82152: LIST
82153: LIST
82154: LIST
82155: LIST
82156: LIST
82157: LIST
82158: IN
82159: NOT
82160: PUSH
82161: LD_VAR 0 6
82165: PUSH
82166: LD_INT 1
82168: EQUAL
82169: AND
82170: OR
82171: PUSH
82172: LD_VAR 0 1
82176: PUSH
82177: LD_INT 2
82179: PUSH
82180: LD_INT 3
82182: PUSH
82183: EMPTY
82184: LIST
82185: LIST
82186: IN
82187: NOT
82188: PUSH
82189: LD_VAR 0 6
82193: PUSH
82194: LD_INT 2
82196: EQUAL
82197: AND
82198: OR
82199: IFFALSE 82209
// mode = 0 ;
82201: LD_ADDR_VAR 0 6
82205: PUSH
82206: LD_INT 0
82208: ST_TO_ADDR
// case mode of 0 :
82209: LD_VAR 0 6
82213: PUSH
82214: LD_INT 0
82216: DOUBLE
82217: EQUAL
82218: IFTRUE 82222
82220: GO 93675
82222: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
82223: LD_ADDR_VAR 0 11
82227: PUSH
82228: LD_INT 0
82230: PUSH
82231: LD_INT 0
82233: PUSH
82234: EMPTY
82235: LIST
82236: LIST
82237: PUSH
82238: LD_INT 0
82240: PUSH
82241: LD_INT 1
82243: NEG
82244: PUSH
82245: EMPTY
82246: LIST
82247: LIST
82248: PUSH
82249: LD_INT 1
82251: PUSH
82252: LD_INT 0
82254: PUSH
82255: EMPTY
82256: LIST
82257: LIST
82258: PUSH
82259: LD_INT 1
82261: PUSH
82262: LD_INT 1
82264: PUSH
82265: EMPTY
82266: LIST
82267: LIST
82268: PUSH
82269: LD_INT 0
82271: PUSH
82272: LD_INT 1
82274: PUSH
82275: EMPTY
82276: LIST
82277: LIST
82278: PUSH
82279: LD_INT 1
82281: NEG
82282: PUSH
82283: LD_INT 0
82285: PUSH
82286: EMPTY
82287: LIST
82288: LIST
82289: PUSH
82290: LD_INT 1
82292: NEG
82293: PUSH
82294: LD_INT 1
82296: NEG
82297: PUSH
82298: EMPTY
82299: LIST
82300: LIST
82301: PUSH
82302: LD_INT 1
82304: NEG
82305: PUSH
82306: LD_INT 2
82308: NEG
82309: PUSH
82310: EMPTY
82311: LIST
82312: LIST
82313: PUSH
82314: LD_INT 0
82316: PUSH
82317: LD_INT 2
82319: NEG
82320: PUSH
82321: EMPTY
82322: LIST
82323: LIST
82324: PUSH
82325: LD_INT 1
82327: PUSH
82328: LD_INT 1
82330: NEG
82331: PUSH
82332: EMPTY
82333: LIST
82334: LIST
82335: PUSH
82336: LD_INT 1
82338: PUSH
82339: LD_INT 2
82341: PUSH
82342: EMPTY
82343: LIST
82344: LIST
82345: PUSH
82346: LD_INT 0
82348: PUSH
82349: LD_INT 2
82351: PUSH
82352: EMPTY
82353: LIST
82354: LIST
82355: PUSH
82356: LD_INT 1
82358: NEG
82359: PUSH
82360: LD_INT 1
82362: PUSH
82363: EMPTY
82364: LIST
82365: LIST
82366: PUSH
82367: LD_INT 1
82369: PUSH
82370: LD_INT 3
82372: PUSH
82373: EMPTY
82374: LIST
82375: LIST
82376: PUSH
82377: LD_INT 0
82379: PUSH
82380: LD_INT 3
82382: PUSH
82383: EMPTY
82384: LIST
82385: LIST
82386: PUSH
82387: LD_INT 1
82389: NEG
82390: PUSH
82391: LD_INT 2
82393: PUSH
82394: EMPTY
82395: LIST
82396: LIST
82397: PUSH
82398: EMPTY
82399: LIST
82400: LIST
82401: LIST
82402: LIST
82403: LIST
82404: LIST
82405: LIST
82406: LIST
82407: LIST
82408: LIST
82409: LIST
82410: LIST
82411: LIST
82412: LIST
82413: LIST
82414: LIST
82415: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
82416: LD_ADDR_VAR 0 12
82420: PUSH
82421: LD_INT 0
82423: PUSH
82424: LD_INT 0
82426: PUSH
82427: EMPTY
82428: LIST
82429: LIST
82430: PUSH
82431: LD_INT 0
82433: PUSH
82434: LD_INT 1
82436: NEG
82437: PUSH
82438: EMPTY
82439: LIST
82440: LIST
82441: PUSH
82442: LD_INT 1
82444: PUSH
82445: LD_INT 0
82447: PUSH
82448: EMPTY
82449: LIST
82450: LIST
82451: PUSH
82452: LD_INT 1
82454: PUSH
82455: LD_INT 1
82457: PUSH
82458: EMPTY
82459: LIST
82460: LIST
82461: PUSH
82462: LD_INT 0
82464: PUSH
82465: LD_INT 1
82467: PUSH
82468: EMPTY
82469: LIST
82470: LIST
82471: PUSH
82472: LD_INT 1
82474: NEG
82475: PUSH
82476: LD_INT 0
82478: PUSH
82479: EMPTY
82480: LIST
82481: LIST
82482: PUSH
82483: LD_INT 1
82485: NEG
82486: PUSH
82487: LD_INT 1
82489: NEG
82490: PUSH
82491: EMPTY
82492: LIST
82493: LIST
82494: PUSH
82495: LD_INT 1
82497: PUSH
82498: LD_INT 1
82500: NEG
82501: PUSH
82502: EMPTY
82503: LIST
82504: LIST
82505: PUSH
82506: LD_INT 2
82508: PUSH
82509: LD_INT 0
82511: PUSH
82512: EMPTY
82513: LIST
82514: LIST
82515: PUSH
82516: LD_INT 2
82518: PUSH
82519: LD_INT 1
82521: PUSH
82522: EMPTY
82523: LIST
82524: LIST
82525: PUSH
82526: LD_INT 1
82528: NEG
82529: PUSH
82530: LD_INT 1
82532: PUSH
82533: EMPTY
82534: LIST
82535: LIST
82536: PUSH
82537: LD_INT 2
82539: NEG
82540: PUSH
82541: LD_INT 0
82543: PUSH
82544: EMPTY
82545: LIST
82546: LIST
82547: PUSH
82548: LD_INT 2
82550: NEG
82551: PUSH
82552: LD_INT 1
82554: NEG
82555: PUSH
82556: EMPTY
82557: LIST
82558: LIST
82559: PUSH
82560: LD_INT 2
82562: NEG
82563: PUSH
82564: LD_INT 1
82566: PUSH
82567: EMPTY
82568: LIST
82569: LIST
82570: PUSH
82571: LD_INT 3
82573: NEG
82574: PUSH
82575: LD_INT 0
82577: PUSH
82578: EMPTY
82579: LIST
82580: LIST
82581: PUSH
82582: LD_INT 3
82584: NEG
82585: PUSH
82586: LD_INT 1
82588: NEG
82589: PUSH
82590: EMPTY
82591: LIST
82592: LIST
82593: PUSH
82594: EMPTY
82595: LIST
82596: LIST
82597: LIST
82598: LIST
82599: LIST
82600: LIST
82601: LIST
82602: LIST
82603: LIST
82604: LIST
82605: LIST
82606: LIST
82607: LIST
82608: LIST
82609: LIST
82610: LIST
82611: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82612: LD_ADDR_VAR 0 13
82616: PUSH
82617: LD_INT 0
82619: PUSH
82620: LD_INT 0
82622: PUSH
82623: EMPTY
82624: LIST
82625: LIST
82626: PUSH
82627: LD_INT 0
82629: PUSH
82630: LD_INT 1
82632: NEG
82633: PUSH
82634: EMPTY
82635: LIST
82636: LIST
82637: PUSH
82638: LD_INT 1
82640: PUSH
82641: LD_INT 0
82643: PUSH
82644: EMPTY
82645: LIST
82646: LIST
82647: PUSH
82648: LD_INT 1
82650: PUSH
82651: LD_INT 1
82653: PUSH
82654: EMPTY
82655: LIST
82656: LIST
82657: PUSH
82658: LD_INT 0
82660: PUSH
82661: LD_INT 1
82663: PUSH
82664: EMPTY
82665: LIST
82666: LIST
82667: PUSH
82668: LD_INT 1
82670: NEG
82671: PUSH
82672: LD_INT 0
82674: PUSH
82675: EMPTY
82676: LIST
82677: LIST
82678: PUSH
82679: LD_INT 1
82681: NEG
82682: PUSH
82683: LD_INT 1
82685: NEG
82686: PUSH
82687: EMPTY
82688: LIST
82689: LIST
82690: PUSH
82691: LD_INT 1
82693: NEG
82694: PUSH
82695: LD_INT 2
82697: NEG
82698: PUSH
82699: EMPTY
82700: LIST
82701: LIST
82702: PUSH
82703: LD_INT 2
82705: PUSH
82706: LD_INT 1
82708: PUSH
82709: EMPTY
82710: LIST
82711: LIST
82712: PUSH
82713: LD_INT 2
82715: PUSH
82716: LD_INT 2
82718: PUSH
82719: EMPTY
82720: LIST
82721: LIST
82722: PUSH
82723: LD_INT 1
82725: PUSH
82726: LD_INT 2
82728: PUSH
82729: EMPTY
82730: LIST
82731: LIST
82732: PUSH
82733: LD_INT 2
82735: NEG
82736: PUSH
82737: LD_INT 1
82739: NEG
82740: PUSH
82741: EMPTY
82742: LIST
82743: LIST
82744: PUSH
82745: LD_INT 2
82747: NEG
82748: PUSH
82749: LD_INT 2
82751: NEG
82752: PUSH
82753: EMPTY
82754: LIST
82755: LIST
82756: PUSH
82757: LD_INT 2
82759: NEG
82760: PUSH
82761: LD_INT 3
82763: NEG
82764: PUSH
82765: EMPTY
82766: LIST
82767: LIST
82768: PUSH
82769: LD_INT 3
82771: NEG
82772: PUSH
82773: LD_INT 2
82775: NEG
82776: PUSH
82777: EMPTY
82778: LIST
82779: LIST
82780: PUSH
82781: LD_INT 3
82783: NEG
82784: PUSH
82785: LD_INT 3
82787: NEG
82788: PUSH
82789: EMPTY
82790: LIST
82791: LIST
82792: PUSH
82793: EMPTY
82794: LIST
82795: LIST
82796: LIST
82797: LIST
82798: LIST
82799: LIST
82800: LIST
82801: LIST
82802: LIST
82803: LIST
82804: LIST
82805: LIST
82806: LIST
82807: LIST
82808: LIST
82809: LIST
82810: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
82811: LD_ADDR_VAR 0 14
82815: PUSH
82816: LD_INT 0
82818: PUSH
82819: LD_INT 0
82821: PUSH
82822: EMPTY
82823: LIST
82824: LIST
82825: PUSH
82826: LD_INT 0
82828: PUSH
82829: LD_INT 1
82831: NEG
82832: PUSH
82833: EMPTY
82834: LIST
82835: LIST
82836: PUSH
82837: LD_INT 1
82839: PUSH
82840: LD_INT 0
82842: PUSH
82843: EMPTY
82844: LIST
82845: LIST
82846: PUSH
82847: LD_INT 1
82849: PUSH
82850: LD_INT 1
82852: PUSH
82853: EMPTY
82854: LIST
82855: LIST
82856: PUSH
82857: LD_INT 0
82859: PUSH
82860: LD_INT 1
82862: PUSH
82863: EMPTY
82864: LIST
82865: LIST
82866: PUSH
82867: LD_INT 1
82869: NEG
82870: PUSH
82871: LD_INT 0
82873: PUSH
82874: EMPTY
82875: LIST
82876: LIST
82877: PUSH
82878: LD_INT 1
82880: NEG
82881: PUSH
82882: LD_INT 1
82884: NEG
82885: PUSH
82886: EMPTY
82887: LIST
82888: LIST
82889: PUSH
82890: LD_INT 1
82892: NEG
82893: PUSH
82894: LD_INT 2
82896: NEG
82897: PUSH
82898: EMPTY
82899: LIST
82900: LIST
82901: PUSH
82902: LD_INT 0
82904: PUSH
82905: LD_INT 2
82907: NEG
82908: PUSH
82909: EMPTY
82910: LIST
82911: LIST
82912: PUSH
82913: LD_INT 1
82915: PUSH
82916: LD_INT 1
82918: NEG
82919: PUSH
82920: EMPTY
82921: LIST
82922: LIST
82923: PUSH
82924: LD_INT 1
82926: PUSH
82927: LD_INT 2
82929: PUSH
82930: EMPTY
82931: LIST
82932: LIST
82933: PUSH
82934: LD_INT 0
82936: PUSH
82937: LD_INT 2
82939: PUSH
82940: EMPTY
82941: LIST
82942: LIST
82943: PUSH
82944: LD_INT 1
82946: NEG
82947: PUSH
82948: LD_INT 1
82950: PUSH
82951: EMPTY
82952: LIST
82953: LIST
82954: PUSH
82955: LD_INT 1
82957: NEG
82958: PUSH
82959: LD_INT 3
82961: NEG
82962: PUSH
82963: EMPTY
82964: LIST
82965: LIST
82966: PUSH
82967: LD_INT 0
82969: PUSH
82970: LD_INT 3
82972: NEG
82973: PUSH
82974: EMPTY
82975: LIST
82976: LIST
82977: PUSH
82978: LD_INT 1
82980: PUSH
82981: LD_INT 2
82983: NEG
82984: PUSH
82985: EMPTY
82986: LIST
82987: LIST
82988: PUSH
82989: EMPTY
82990: LIST
82991: LIST
82992: LIST
82993: LIST
82994: LIST
82995: LIST
82996: LIST
82997: LIST
82998: LIST
82999: LIST
83000: LIST
83001: LIST
83002: LIST
83003: LIST
83004: LIST
83005: LIST
83006: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
83007: LD_ADDR_VAR 0 15
83011: PUSH
83012: LD_INT 0
83014: PUSH
83015: LD_INT 0
83017: PUSH
83018: EMPTY
83019: LIST
83020: LIST
83021: PUSH
83022: LD_INT 0
83024: PUSH
83025: LD_INT 1
83027: NEG
83028: PUSH
83029: EMPTY
83030: LIST
83031: LIST
83032: PUSH
83033: LD_INT 1
83035: PUSH
83036: LD_INT 0
83038: PUSH
83039: EMPTY
83040: LIST
83041: LIST
83042: PUSH
83043: LD_INT 1
83045: PUSH
83046: LD_INT 1
83048: PUSH
83049: EMPTY
83050: LIST
83051: LIST
83052: PUSH
83053: LD_INT 0
83055: PUSH
83056: LD_INT 1
83058: PUSH
83059: EMPTY
83060: LIST
83061: LIST
83062: PUSH
83063: LD_INT 1
83065: NEG
83066: PUSH
83067: LD_INT 0
83069: PUSH
83070: EMPTY
83071: LIST
83072: LIST
83073: PUSH
83074: LD_INT 1
83076: NEG
83077: PUSH
83078: LD_INT 1
83080: NEG
83081: PUSH
83082: EMPTY
83083: LIST
83084: LIST
83085: PUSH
83086: LD_INT 1
83088: PUSH
83089: LD_INT 1
83091: NEG
83092: PUSH
83093: EMPTY
83094: LIST
83095: LIST
83096: PUSH
83097: LD_INT 2
83099: PUSH
83100: LD_INT 0
83102: PUSH
83103: EMPTY
83104: LIST
83105: LIST
83106: PUSH
83107: LD_INT 2
83109: PUSH
83110: LD_INT 1
83112: PUSH
83113: EMPTY
83114: LIST
83115: LIST
83116: PUSH
83117: LD_INT 1
83119: NEG
83120: PUSH
83121: LD_INT 1
83123: PUSH
83124: EMPTY
83125: LIST
83126: LIST
83127: PUSH
83128: LD_INT 2
83130: NEG
83131: PUSH
83132: LD_INT 0
83134: PUSH
83135: EMPTY
83136: LIST
83137: LIST
83138: PUSH
83139: LD_INT 2
83141: NEG
83142: PUSH
83143: LD_INT 1
83145: NEG
83146: PUSH
83147: EMPTY
83148: LIST
83149: LIST
83150: PUSH
83151: LD_INT 2
83153: PUSH
83154: LD_INT 1
83156: NEG
83157: PUSH
83158: EMPTY
83159: LIST
83160: LIST
83161: PUSH
83162: LD_INT 3
83164: PUSH
83165: LD_INT 0
83167: PUSH
83168: EMPTY
83169: LIST
83170: LIST
83171: PUSH
83172: LD_INT 3
83174: PUSH
83175: LD_INT 1
83177: PUSH
83178: EMPTY
83179: LIST
83180: LIST
83181: PUSH
83182: EMPTY
83183: LIST
83184: LIST
83185: LIST
83186: LIST
83187: LIST
83188: LIST
83189: LIST
83190: LIST
83191: LIST
83192: LIST
83193: LIST
83194: LIST
83195: LIST
83196: LIST
83197: LIST
83198: LIST
83199: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
83200: LD_ADDR_VAR 0 16
83204: PUSH
83205: LD_INT 0
83207: PUSH
83208: LD_INT 0
83210: PUSH
83211: EMPTY
83212: LIST
83213: LIST
83214: PUSH
83215: LD_INT 0
83217: PUSH
83218: LD_INT 1
83220: NEG
83221: PUSH
83222: EMPTY
83223: LIST
83224: LIST
83225: PUSH
83226: LD_INT 1
83228: PUSH
83229: LD_INT 0
83231: PUSH
83232: EMPTY
83233: LIST
83234: LIST
83235: PUSH
83236: LD_INT 1
83238: PUSH
83239: LD_INT 1
83241: PUSH
83242: EMPTY
83243: LIST
83244: LIST
83245: PUSH
83246: LD_INT 0
83248: PUSH
83249: LD_INT 1
83251: PUSH
83252: EMPTY
83253: LIST
83254: LIST
83255: PUSH
83256: LD_INT 1
83258: NEG
83259: PUSH
83260: LD_INT 0
83262: PUSH
83263: EMPTY
83264: LIST
83265: LIST
83266: PUSH
83267: LD_INT 1
83269: NEG
83270: PUSH
83271: LD_INT 1
83273: NEG
83274: PUSH
83275: EMPTY
83276: LIST
83277: LIST
83278: PUSH
83279: LD_INT 1
83281: NEG
83282: PUSH
83283: LD_INT 2
83285: NEG
83286: PUSH
83287: EMPTY
83288: LIST
83289: LIST
83290: PUSH
83291: LD_INT 2
83293: PUSH
83294: LD_INT 1
83296: PUSH
83297: EMPTY
83298: LIST
83299: LIST
83300: PUSH
83301: LD_INT 2
83303: PUSH
83304: LD_INT 2
83306: PUSH
83307: EMPTY
83308: LIST
83309: LIST
83310: PUSH
83311: LD_INT 1
83313: PUSH
83314: LD_INT 2
83316: PUSH
83317: EMPTY
83318: LIST
83319: LIST
83320: PUSH
83321: LD_INT 2
83323: NEG
83324: PUSH
83325: LD_INT 1
83327: NEG
83328: PUSH
83329: EMPTY
83330: LIST
83331: LIST
83332: PUSH
83333: LD_INT 2
83335: NEG
83336: PUSH
83337: LD_INT 2
83339: NEG
83340: PUSH
83341: EMPTY
83342: LIST
83343: LIST
83344: PUSH
83345: LD_INT 3
83347: PUSH
83348: LD_INT 2
83350: PUSH
83351: EMPTY
83352: LIST
83353: LIST
83354: PUSH
83355: LD_INT 3
83357: PUSH
83358: LD_INT 3
83360: PUSH
83361: EMPTY
83362: LIST
83363: LIST
83364: PUSH
83365: LD_INT 2
83367: PUSH
83368: LD_INT 3
83370: PUSH
83371: EMPTY
83372: LIST
83373: LIST
83374: PUSH
83375: EMPTY
83376: LIST
83377: LIST
83378: LIST
83379: LIST
83380: LIST
83381: LIST
83382: LIST
83383: LIST
83384: LIST
83385: LIST
83386: LIST
83387: LIST
83388: LIST
83389: LIST
83390: LIST
83391: LIST
83392: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83393: LD_ADDR_VAR 0 17
83397: PUSH
83398: LD_INT 0
83400: PUSH
83401: LD_INT 0
83403: PUSH
83404: EMPTY
83405: LIST
83406: LIST
83407: PUSH
83408: LD_INT 0
83410: PUSH
83411: LD_INT 1
83413: NEG
83414: PUSH
83415: EMPTY
83416: LIST
83417: LIST
83418: PUSH
83419: LD_INT 1
83421: PUSH
83422: LD_INT 0
83424: PUSH
83425: EMPTY
83426: LIST
83427: LIST
83428: PUSH
83429: LD_INT 1
83431: PUSH
83432: LD_INT 1
83434: PUSH
83435: EMPTY
83436: LIST
83437: LIST
83438: PUSH
83439: LD_INT 0
83441: PUSH
83442: LD_INT 1
83444: PUSH
83445: EMPTY
83446: LIST
83447: LIST
83448: PUSH
83449: LD_INT 1
83451: NEG
83452: PUSH
83453: LD_INT 0
83455: PUSH
83456: EMPTY
83457: LIST
83458: LIST
83459: PUSH
83460: LD_INT 1
83462: NEG
83463: PUSH
83464: LD_INT 1
83466: NEG
83467: PUSH
83468: EMPTY
83469: LIST
83470: LIST
83471: PUSH
83472: LD_INT 1
83474: NEG
83475: PUSH
83476: LD_INT 2
83478: NEG
83479: PUSH
83480: EMPTY
83481: LIST
83482: LIST
83483: PUSH
83484: LD_INT 0
83486: PUSH
83487: LD_INT 2
83489: NEG
83490: PUSH
83491: EMPTY
83492: LIST
83493: LIST
83494: PUSH
83495: LD_INT 1
83497: PUSH
83498: LD_INT 1
83500: NEG
83501: PUSH
83502: EMPTY
83503: LIST
83504: LIST
83505: PUSH
83506: LD_INT 2
83508: PUSH
83509: LD_INT 0
83511: PUSH
83512: EMPTY
83513: LIST
83514: LIST
83515: PUSH
83516: LD_INT 2
83518: PUSH
83519: LD_INT 1
83521: PUSH
83522: EMPTY
83523: LIST
83524: LIST
83525: PUSH
83526: LD_INT 2
83528: PUSH
83529: LD_INT 2
83531: PUSH
83532: EMPTY
83533: LIST
83534: LIST
83535: PUSH
83536: LD_INT 1
83538: PUSH
83539: LD_INT 2
83541: PUSH
83542: EMPTY
83543: LIST
83544: LIST
83545: PUSH
83546: LD_INT 0
83548: PUSH
83549: LD_INT 2
83551: PUSH
83552: EMPTY
83553: LIST
83554: LIST
83555: PUSH
83556: LD_INT 1
83558: NEG
83559: PUSH
83560: LD_INT 1
83562: PUSH
83563: EMPTY
83564: LIST
83565: LIST
83566: PUSH
83567: LD_INT 2
83569: NEG
83570: PUSH
83571: LD_INT 0
83573: PUSH
83574: EMPTY
83575: LIST
83576: LIST
83577: PUSH
83578: LD_INT 2
83580: NEG
83581: PUSH
83582: LD_INT 1
83584: NEG
83585: PUSH
83586: EMPTY
83587: LIST
83588: LIST
83589: PUSH
83590: LD_INT 2
83592: NEG
83593: PUSH
83594: LD_INT 2
83596: NEG
83597: PUSH
83598: EMPTY
83599: LIST
83600: LIST
83601: PUSH
83602: EMPTY
83603: LIST
83604: LIST
83605: LIST
83606: LIST
83607: LIST
83608: LIST
83609: LIST
83610: LIST
83611: LIST
83612: LIST
83613: LIST
83614: LIST
83615: LIST
83616: LIST
83617: LIST
83618: LIST
83619: LIST
83620: LIST
83621: LIST
83622: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83623: LD_ADDR_VAR 0 18
83627: PUSH
83628: LD_INT 0
83630: PUSH
83631: LD_INT 0
83633: PUSH
83634: EMPTY
83635: LIST
83636: LIST
83637: PUSH
83638: LD_INT 0
83640: PUSH
83641: LD_INT 1
83643: NEG
83644: PUSH
83645: EMPTY
83646: LIST
83647: LIST
83648: PUSH
83649: LD_INT 1
83651: PUSH
83652: LD_INT 0
83654: PUSH
83655: EMPTY
83656: LIST
83657: LIST
83658: PUSH
83659: LD_INT 1
83661: PUSH
83662: LD_INT 1
83664: PUSH
83665: EMPTY
83666: LIST
83667: LIST
83668: PUSH
83669: LD_INT 0
83671: PUSH
83672: LD_INT 1
83674: PUSH
83675: EMPTY
83676: LIST
83677: LIST
83678: PUSH
83679: LD_INT 1
83681: NEG
83682: PUSH
83683: LD_INT 0
83685: PUSH
83686: EMPTY
83687: LIST
83688: LIST
83689: PUSH
83690: LD_INT 1
83692: NEG
83693: PUSH
83694: LD_INT 1
83696: NEG
83697: PUSH
83698: EMPTY
83699: LIST
83700: LIST
83701: PUSH
83702: LD_INT 1
83704: NEG
83705: PUSH
83706: LD_INT 2
83708: NEG
83709: PUSH
83710: EMPTY
83711: LIST
83712: LIST
83713: PUSH
83714: LD_INT 0
83716: PUSH
83717: LD_INT 2
83719: NEG
83720: PUSH
83721: EMPTY
83722: LIST
83723: LIST
83724: PUSH
83725: LD_INT 1
83727: PUSH
83728: LD_INT 1
83730: NEG
83731: PUSH
83732: EMPTY
83733: LIST
83734: LIST
83735: PUSH
83736: LD_INT 2
83738: PUSH
83739: LD_INT 0
83741: PUSH
83742: EMPTY
83743: LIST
83744: LIST
83745: PUSH
83746: LD_INT 2
83748: PUSH
83749: LD_INT 1
83751: PUSH
83752: EMPTY
83753: LIST
83754: LIST
83755: PUSH
83756: LD_INT 2
83758: PUSH
83759: LD_INT 2
83761: PUSH
83762: EMPTY
83763: LIST
83764: LIST
83765: PUSH
83766: LD_INT 1
83768: PUSH
83769: LD_INT 2
83771: PUSH
83772: EMPTY
83773: LIST
83774: LIST
83775: PUSH
83776: LD_INT 0
83778: PUSH
83779: LD_INT 2
83781: PUSH
83782: EMPTY
83783: LIST
83784: LIST
83785: PUSH
83786: LD_INT 1
83788: NEG
83789: PUSH
83790: LD_INT 1
83792: PUSH
83793: EMPTY
83794: LIST
83795: LIST
83796: PUSH
83797: LD_INT 2
83799: NEG
83800: PUSH
83801: LD_INT 0
83803: PUSH
83804: EMPTY
83805: LIST
83806: LIST
83807: PUSH
83808: LD_INT 2
83810: NEG
83811: PUSH
83812: LD_INT 1
83814: NEG
83815: PUSH
83816: EMPTY
83817: LIST
83818: LIST
83819: PUSH
83820: LD_INT 2
83822: NEG
83823: PUSH
83824: LD_INT 2
83826: NEG
83827: PUSH
83828: EMPTY
83829: LIST
83830: LIST
83831: PUSH
83832: EMPTY
83833: LIST
83834: LIST
83835: LIST
83836: LIST
83837: LIST
83838: LIST
83839: LIST
83840: LIST
83841: LIST
83842: LIST
83843: LIST
83844: LIST
83845: LIST
83846: LIST
83847: LIST
83848: LIST
83849: LIST
83850: LIST
83851: LIST
83852: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83853: LD_ADDR_VAR 0 19
83857: PUSH
83858: LD_INT 0
83860: PUSH
83861: LD_INT 0
83863: PUSH
83864: EMPTY
83865: LIST
83866: LIST
83867: PUSH
83868: LD_INT 0
83870: PUSH
83871: LD_INT 1
83873: NEG
83874: PUSH
83875: EMPTY
83876: LIST
83877: LIST
83878: PUSH
83879: LD_INT 1
83881: PUSH
83882: LD_INT 0
83884: PUSH
83885: EMPTY
83886: LIST
83887: LIST
83888: PUSH
83889: LD_INT 1
83891: PUSH
83892: LD_INT 1
83894: PUSH
83895: EMPTY
83896: LIST
83897: LIST
83898: PUSH
83899: LD_INT 0
83901: PUSH
83902: LD_INT 1
83904: PUSH
83905: EMPTY
83906: LIST
83907: LIST
83908: PUSH
83909: LD_INT 1
83911: NEG
83912: PUSH
83913: LD_INT 0
83915: PUSH
83916: EMPTY
83917: LIST
83918: LIST
83919: PUSH
83920: LD_INT 1
83922: NEG
83923: PUSH
83924: LD_INT 1
83926: NEG
83927: PUSH
83928: EMPTY
83929: LIST
83930: LIST
83931: PUSH
83932: LD_INT 1
83934: NEG
83935: PUSH
83936: LD_INT 2
83938: NEG
83939: PUSH
83940: EMPTY
83941: LIST
83942: LIST
83943: PUSH
83944: LD_INT 0
83946: PUSH
83947: LD_INT 2
83949: NEG
83950: PUSH
83951: EMPTY
83952: LIST
83953: LIST
83954: PUSH
83955: LD_INT 1
83957: PUSH
83958: LD_INT 1
83960: NEG
83961: PUSH
83962: EMPTY
83963: LIST
83964: LIST
83965: PUSH
83966: LD_INT 2
83968: PUSH
83969: LD_INT 0
83971: PUSH
83972: EMPTY
83973: LIST
83974: LIST
83975: PUSH
83976: LD_INT 2
83978: PUSH
83979: LD_INT 1
83981: PUSH
83982: EMPTY
83983: LIST
83984: LIST
83985: PUSH
83986: LD_INT 2
83988: PUSH
83989: LD_INT 2
83991: PUSH
83992: EMPTY
83993: LIST
83994: LIST
83995: PUSH
83996: LD_INT 1
83998: PUSH
83999: LD_INT 2
84001: PUSH
84002: EMPTY
84003: LIST
84004: LIST
84005: PUSH
84006: LD_INT 0
84008: PUSH
84009: LD_INT 2
84011: PUSH
84012: EMPTY
84013: LIST
84014: LIST
84015: PUSH
84016: LD_INT 1
84018: NEG
84019: PUSH
84020: LD_INT 1
84022: PUSH
84023: EMPTY
84024: LIST
84025: LIST
84026: PUSH
84027: LD_INT 2
84029: NEG
84030: PUSH
84031: LD_INT 0
84033: PUSH
84034: EMPTY
84035: LIST
84036: LIST
84037: PUSH
84038: LD_INT 2
84040: NEG
84041: PUSH
84042: LD_INT 1
84044: NEG
84045: PUSH
84046: EMPTY
84047: LIST
84048: LIST
84049: PUSH
84050: LD_INT 2
84052: NEG
84053: PUSH
84054: LD_INT 2
84056: NEG
84057: PUSH
84058: EMPTY
84059: LIST
84060: LIST
84061: PUSH
84062: EMPTY
84063: LIST
84064: LIST
84065: LIST
84066: LIST
84067: LIST
84068: LIST
84069: LIST
84070: LIST
84071: LIST
84072: LIST
84073: LIST
84074: LIST
84075: LIST
84076: LIST
84077: LIST
84078: LIST
84079: LIST
84080: LIST
84081: LIST
84082: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84083: LD_ADDR_VAR 0 20
84087: PUSH
84088: LD_INT 0
84090: PUSH
84091: LD_INT 0
84093: PUSH
84094: EMPTY
84095: LIST
84096: LIST
84097: PUSH
84098: LD_INT 0
84100: PUSH
84101: LD_INT 1
84103: NEG
84104: PUSH
84105: EMPTY
84106: LIST
84107: LIST
84108: PUSH
84109: LD_INT 1
84111: PUSH
84112: LD_INT 0
84114: PUSH
84115: EMPTY
84116: LIST
84117: LIST
84118: PUSH
84119: LD_INT 1
84121: PUSH
84122: LD_INT 1
84124: PUSH
84125: EMPTY
84126: LIST
84127: LIST
84128: PUSH
84129: LD_INT 0
84131: PUSH
84132: LD_INT 1
84134: PUSH
84135: EMPTY
84136: LIST
84137: LIST
84138: PUSH
84139: LD_INT 1
84141: NEG
84142: PUSH
84143: LD_INT 0
84145: PUSH
84146: EMPTY
84147: LIST
84148: LIST
84149: PUSH
84150: LD_INT 1
84152: NEG
84153: PUSH
84154: LD_INT 1
84156: NEG
84157: PUSH
84158: EMPTY
84159: LIST
84160: LIST
84161: PUSH
84162: LD_INT 1
84164: NEG
84165: PUSH
84166: LD_INT 2
84168: NEG
84169: PUSH
84170: EMPTY
84171: LIST
84172: LIST
84173: PUSH
84174: LD_INT 0
84176: PUSH
84177: LD_INT 2
84179: NEG
84180: PUSH
84181: EMPTY
84182: LIST
84183: LIST
84184: PUSH
84185: LD_INT 1
84187: PUSH
84188: LD_INT 1
84190: NEG
84191: PUSH
84192: EMPTY
84193: LIST
84194: LIST
84195: PUSH
84196: LD_INT 2
84198: PUSH
84199: LD_INT 0
84201: PUSH
84202: EMPTY
84203: LIST
84204: LIST
84205: PUSH
84206: LD_INT 2
84208: PUSH
84209: LD_INT 1
84211: PUSH
84212: EMPTY
84213: LIST
84214: LIST
84215: PUSH
84216: LD_INT 2
84218: PUSH
84219: LD_INT 2
84221: PUSH
84222: EMPTY
84223: LIST
84224: LIST
84225: PUSH
84226: LD_INT 1
84228: PUSH
84229: LD_INT 2
84231: PUSH
84232: EMPTY
84233: LIST
84234: LIST
84235: PUSH
84236: LD_INT 0
84238: PUSH
84239: LD_INT 2
84241: PUSH
84242: EMPTY
84243: LIST
84244: LIST
84245: PUSH
84246: LD_INT 1
84248: NEG
84249: PUSH
84250: LD_INT 1
84252: PUSH
84253: EMPTY
84254: LIST
84255: LIST
84256: PUSH
84257: LD_INT 2
84259: NEG
84260: PUSH
84261: LD_INT 0
84263: PUSH
84264: EMPTY
84265: LIST
84266: LIST
84267: PUSH
84268: LD_INT 2
84270: NEG
84271: PUSH
84272: LD_INT 1
84274: NEG
84275: PUSH
84276: EMPTY
84277: LIST
84278: LIST
84279: PUSH
84280: LD_INT 2
84282: NEG
84283: PUSH
84284: LD_INT 2
84286: NEG
84287: PUSH
84288: EMPTY
84289: LIST
84290: LIST
84291: PUSH
84292: EMPTY
84293: LIST
84294: LIST
84295: LIST
84296: LIST
84297: LIST
84298: LIST
84299: LIST
84300: LIST
84301: LIST
84302: LIST
84303: LIST
84304: LIST
84305: LIST
84306: LIST
84307: LIST
84308: LIST
84309: LIST
84310: LIST
84311: LIST
84312: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84313: LD_ADDR_VAR 0 21
84317: PUSH
84318: LD_INT 0
84320: PUSH
84321: LD_INT 0
84323: PUSH
84324: EMPTY
84325: LIST
84326: LIST
84327: PUSH
84328: LD_INT 0
84330: PUSH
84331: LD_INT 1
84333: NEG
84334: PUSH
84335: EMPTY
84336: LIST
84337: LIST
84338: PUSH
84339: LD_INT 1
84341: PUSH
84342: LD_INT 0
84344: PUSH
84345: EMPTY
84346: LIST
84347: LIST
84348: PUSH
84349: LD_INT 1
84351: PUSH
84352: LD_INT 1
84354: PUSH
84355: EMPTY
84356: LIST
84357: LIST
84358: PUSH
84359: LD_INT 0
84361: PUSH
84362: LD_INT 1
84364: PUSH
84365: EMPTY
84366: LIST
84367: LIST
84368: PUSH
84369: LD_INT 1
84371: NEG
84372: PUSH
84373: LD_INT 0
84375: PUSH
84376: EMPTY
84377: LIST
84378: LIST
84379: PUSH
84380: LD_INT 1
84382: NEG
84383: PUSH
84384: LD_INT 1
84386: NEG
84387: PUSH
84388: EMPTY
84389: LIST
84390: LIST
84391: PUSH
84392: LD_INT 1
84394: NEG
84395: PUSH
84396: LD_INT 2
84398: NEG
84399: PUSH
84400: EMPTY
84401: LIST
84402: LIST
84403: PUSH
84404: LD_INT 0
84406: PUSH
84407: LD_INT 2
84409: NEG
84410: PUSH
84411: EMPTY
84412: LIST
84413: LIST
84414: PUSH
84415: LD_INT 1
84417: PUSH
84418: LD_INT 1
84420: NEG
84421: PUSH
84422: EMPTY
84423: LIST
84424: LIST
84425: PUSH
84426: LD_INT 2
84428: PUSH
84429: LD_INT 0
84431: PUSH
84432: EMPTY
84433: LIST
84434: LIST
84435: PUSH
84436: LD_INT 2
84438: PUSH
84439: LD_INT 1
84441: PUSH
84442: EMPTY
84443: LIST
84444: LIST
84445: PUSH
84446: LD_INT 2
84448: PUSH
84449: LD_INT 2
84451: PUSH
84452: EMPTY
84453: LIST
84454: LIST
84455: PUSH
84456: LD_INT 1
84458: PUSH
84459: LD_INT 2
84461: PUSH
84462: EMPTY
84463: LIST
84464: LIST
84465: PUSH
84466: LD_INT 0
84468: PUSH
84469: LD_INT 2
84471: PUSH
84472: EMPTY
84473: LIST
84474: LIST
84475: PUSH
84476: LD_INT 1
84478: NEG
84479: PUSH
84480: LD_INT 1
84482: PUSH
84483: EMPTY
84484: LIST
84485: LIST
84486: PUSH
84487: LD_INT 2
84489: NEG
84490: PUSH
84491: LD_INT 0
84493: PUSH
84494: EMPTY
84495: LIST
84496: LIST
84497: PUSH
84498: LD_INT 2
84500: NEG
84501: PUSH
84502: LD_INT 1
84504: NEG
84505: PUSH
84506: EMPTY
84507: LIST
84508: LIST
84509: PUSH
84510: LD_INT 2
84512: NEG
84513: PUSH
84514: LD_INT 2
84516: NEG
84517: PUSH
84518: EMPTY
84519: LIST
84520: LIST
84521: PUSH
84522: EMPTY
84523: LIST
84524: LIST
84525: LIST
84526: LIST
84527: LIST
84528: LIST
84529: LIST
84530: LIST
84531: LIST
84532: LIST
84533: LIST
84534: LIST
84535: LIST
84536: LIST
84537: LIST
84538: LIST
84539: LIST
84540: LIST
84541: LIST
84542: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84543: LD_ADDR_VAR 0 22
84547: PUSH
84548: LD_INT 0
84550: PUSH
84551: LD_INT 0
84553: PUSH
84554: EMPTY
84555: LIST
84556: LIST
84557: PUSH
84558: LD_INT 0
84560: PUSH
84561: LD_INT 1
84563: NEG
84564: PUSH
84565: EMPTY
84566: LIST
84567: LIST
84568: PUSH
84569: LD_INT 1
84571: PUSH
84572: LD_INT 0
84574: PUSH
84575: EMPTY
84576: LIST
84577: LIST
84578: PUSH
84579: LD_INT 1
84581: PUSH
84582: LD_INT 1
84584: PUSH
84585: EMPTY
84586: LIST
84587: LIST
84588: PUSH
84589: LD_INT 0
84591: PUSH
84592: LD_INT 1
84594: PUSH
84595: EMPTY
84596: LIST
84597: LIST
84598: PUSH
84599: LD_INT 1
84601: NEG
84602: PUSH
84603: LD_INT 0
84605: PUSH
84606: EMPTY
84607: LIST
84608: LIST
84609: PUSH
84610: LD_INT 1
84612: NEG
84613: PUSH
84614: LD_INT 1
84616: NEG
84617: PUSH
84618: EMPTY
84619: LIST
84620: LIST
84621: PUSH
84622: LD_INT 1
84624: NEG
84625: PUSH
84626: LD_INT 2
84628: NEG
84629: PUSH
84630: EMPTY
84631: LIST
84632: LIST
84633: PUSH
84634: LD_INT 0
84636: PUSH
84637: LD_INT 2
84639: NEG
84640: PUSH
84641: EMPTY
84642: LIST
84643: LIST
84644: PUSH
84645: LD_INT 1
84647: PUSH
84648: LD_INT 1
84650: NEG
84651: PUSH
84652: EMPTY
84653: LIST
84654: LIST
84655: PUSH
84656: LD_INT 2
84658: PUSH
84659: LD_INT 0
84661: PUSH
84662: EMPTY
84663: LIST
84664: LIST
84665: PUSH
84666: LD_INT 2
84668: PUSH
84669: LD_INT 1
84671: PUSH
84672: EMPTY
84673: LIST
84674: LIST
84675: PUSH
84676: LD_INT 2
84678: PUSH
84679: LD_INT 2
84681: PUSH
84682: EMPTY
84683: LIST
84684: LIST
84685: PUSH
84686: LD_INT 1
84688: PUSH
84689: LD_INT 2
84691: PUSH
84692: EMPTY
84693: LIST
84694: LIST
84695: PUSH
84696: LD_INT 0
84698: PUSH
84699: LD_INT 2
84701: PUSH
84702: EMPTY
84703: LIST
84704: LIST
84705: PUSH
84706: LD_INT 1
84708: NEG
84709: PUSH
84710: LD_INT 1
84712: PUSH
84713: EMPTY
84714: LIST
84715: LIST
84716: PUSH
84717: LD_INT 2
84719: NEG
84720: PUSH
84721: LD_INT 0
84723: PUSH
84724: EMPTY
84725: LIST
84726: LIST
84727: PUSH
84728: LD_INT 2
84730: NEG
84731: PUSH
84732: LD_INT 1
84734: NEG
84735: PUSH
84736: EMPTY
84737: LIST
84738: LIST
84739: PUSH
84740: LD_INT 2
84742: NEG
84743: PUSH
84744: LD_INT 2
84746: NEG
84747: PUSH
84748: EMPTY
84749: LIST
84750: LIST
84751: PUSH
84752: EMPTY
84753: LIST
84754: LIST
84755: LIST
84756: LIST
84757: LIST
84758: LIST
84759: LIST
84760: LIST
84761: LIST
84762: LIST
84763: LIST
84764: LIST
84765: LIST
84766: LIST
84767: LIST
84768: LIST
84769: LIST
84770: LIST
84771: LIST
84772: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
84773: LD_ADDR_VAR 0 23
84777: PUSH
84778: LD_INT 0
84780: PUSH
84781: LD_INT 0
84783: PUSH
84784: EMPTY
84785: LIST
84786: LIST
84787: PUSH
84788: LD_INT 0
84790: PUSH
84791: LD_INT 1
84793: NEG
84794: PUSH
84795: EMPTY
84796: LIST
84797: LIST
84798: PUSH
84799: LD_INT 1
84801: PUSH
84802: LD_INT 0
84804: PUSH
84805: EMPTY
84806: LIST
84807: LIST
84808: PUSH
84809: LD_INT 1
84811: PUSH
84812: LD_INT 1
84814: PUSH
84815: EMPTY
84816: LIST
84817: LIST
84818: PUSH
84819: LD_INT 0
84821: PUSH
84822: LD_INT 1
84824: PUSH
84825: EMPTY
84826: LIST
84827: LIST
84828: PUSH
84829: LD_INT 1
84831: NEG
84832: PUSH
84833: LD_INT 0
84835: PUSH
84836: EMPTY
84837: LIST
84838: LIST
84839: PUSH
84840: LD_INT 1
84842: NEG
84843: PUSH
84844: LD_INT 1
84846: NEG
84847: PUSH
84848: EMPTY
84849: LIST
84850: LIST
84851: PUSH
84852: LD_INT 1
84854: NEG
84855: PUSH
84856: LD_INT 2
84858: NEG
84859: PUSH
84860: EMPTY
84861: LIST
84862: LIST
84863: PUSH
84864: LD_INT 0
84866: PUSH
84867: LD_INT 2
84869: NEG
84870: PUSH
84871: EMPTY
84872: LIST
84873: LIST
84874: PUSH
84875: LD_INT 1
84877: PUSH
84878: LD_INT 1
84880: NEG
84881: PUSH
84882: EMPTY
84883: LIST
84884: LIST
84885: PUSH
84886: LD_INT 2
84888: PUSH
84889: LD_INT 0
84891: PUSH
84892: EMPTY
84893: LIST
84894: LIST
84895: PUSH
84896: LD_INT 2
84898: PUSH
84899: LD_INT 1
84901: PUSH
84902: EMPTY
84903: LIST
84904: LIST
84905: PUSH
84906: LD_INT 2
84908: PUSH
84909: LD_INT 2
84911: PUSH
84912: EMPTY
84913: LIST
84914: LIST
84915: PUSH
84916: LD_INT 1
84918: PUSH
84919: LD_INT 2
84921: PUSH
84922: EMPTY
84923: LIST
84924: LIST
84925: PUSH
84926: LD_INT 0
84928: PUSH
84929: LD_INT 2
84931: PUSH
84932: EMPTY
84933: LIST
84934: LIST
84935: PUSH
84936: LD_INT 1
84938: NEG
84939: PUSH
84940: LD_INT 1
84942: PUSH
84943: EMPTY
84944: LIST
84945: LIST
84946: PUSH
84947: LD_INT 2
84949: NEG
84950: PUSH
84951: LD_INT 0
84953: PUSH
84954: EMPTY
84955: LIST
84956: LIST
84957: PUSH
84958: LD_INT 2
84960: NEG
84961: PUSH
84962: LD_INT 1
84964: NEG
84965: PUSH
84966: EMPTY
84967: LIST
84968: LIST
84969: PUSH
84970: LD_INT 2
84972: NEG
84973: PUSH
84974: LD_INT 2
84976: NEG
84977: PUSH
84978: EMPTY
84979: LIST
84980: LIST
84981: PUSH
84982: LD_INT 2
84984: NEG
84985: PUSH
84986: LD_INT 3
84988: NEG
84989: PUSH
84990: EMPTY
84991: LIST
84992: LIST
84993: PUSH
84994: LD_INT 1
84996: NEG
84997: PUSH
84998: LD_INT 3
85000: NEG
85001: PUSH
85002: EMPTY
85003: LIST
85004: LIST
85005: PUSH
85006: LD_INT 1
85008: PUSH
85009: LD_INT 2
85011: NEG
85012: PUSH
85013: EMPTY
85014: LIST
85015: LIST
85016: PUSH
85017: LD_INT 2
85019: PUSH
85020: LD_INT 1
85022: NEG
85023: PUSH
85024: EMPTY
85025: LIST
85026: LIST
85027: PUSH
85028: EMPTY
85029: LIST
85030: LIST
85031: LIST
85032: LIST
85033: LIST
85034: LIST
85035: LIST
85036: LIST
85037: LIST
85038: LIST
85039: LIST
85040: LIST
85041: LIST
85042: LIST
85043: LIST
85044: LIST
85045: LIST
85046: LIST
85047: LIST
85048: LIST
85049: LIST
85050: LIST
85051: LIST
85052: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
85053: LD_ADDR_VAR 0 24
85057: PUSH
85058: LD_INT 0
85060: PUSH
85061: LD_INT 0
85063: PUSH
85064: EMPTY
85065: LIST
85066: LIST
85067: PUSH
85068: LD_INT 0
85070: PUSH
85071: LD_INT 1
85073: NEG
85074: PUSH
85075: EMPTY
85076: LIST
85077: LIST
85078: PUSH
85079: LD_INT 1
85081: PUSH
85082: LD_INT 0
85084: PUSH
85085: EMPTY
85086: LIST
85087: LIST
85088: PUSH
85089: LD_INT 1
85091: PUSH
85092: LD_INT 1
85094: PUSH
85095: EMPTY
85096: LIST
85097: LIST
85098: PUSH
85099: LD_INT 0
85101: PUSH
85102: LD_INT 1
85104: PUSH
85105: EMPTY
85106: LIST
85107: LIST
85108: PUSH
85109: LD_INT 1
85111: NEG
85112: PUSH
85113: LD_INT 0
85115: PUSH
85116: EMPTY
85117: LIST
85118: LIST
85119: PUSH
85120: LD_INT 1
85122: NEG
85123: PUSH
85124: LD_INT 1
85126: NEG
85127: PUSH
85128: EMPTY
85129: LIST
85130: LIST
85131: PUSH
85132: LD_INT 1
85134: NEG
85135: PUSH
85136: LD_INT 2
85138: NEG
85139: PUSH
85140: EMPTY
85141: LIST
85142: LIST
85143: PUSH
85144: LD_INT 0
85146: PUSH
85147: LD_INT 2
85149: NEG
85150: PUSH
85151: EMPTY
85152: LIST
85153: LIST
85154: PUSH
85155: LD_INT 1
85157: PUSH
85158: LD_INT 1
85160: NEG
85161: PUSH
85162: EMPTY
85163: LIST
85164: LIST
85165: PUSH
85166: LD_INT 2
85168: PUSH
85169: LD_INT 0
85171: PUSH
85172: EMPTY
85173: LIST
85174: LIST
85175: PUSH
85176: LD_INT 2
85178: PUSH
85179: LD_INT 1
85181: PUSH
85182: EMPTY
85183: LIST
85184: LIST
85185: PUSH
85186: LD_INT 2
85188: PUSH
85189: LD_INT 2
85191: PUSH
85192: EMPTY
85193: LIST
85194: LIST
85195: PUSH
85196: LD_INT 1
85198: PUSH
85199: LD_INT 2
85201: PUSH
85202: EMPTY
85203: LIST
85204: LIST
85205: PUSH
85206: LD_INT 0
85208: PUSH
85209: LD_INT 2
85211: PUSH
85212: EMPTY
85213: LIST
85214: LIST
85215: PUSH
85216: LD_INT 1
85218: NEG
85219: PUSH
85220: LD_INT 1
85222: PUSH
85223: EMPTY
85224: LIST
85225: LIST
85226: PUSH
85227: LD_INT 2
85229: NEG
85230: PUSH
85231: LD_INT 0
85233: PUSH
85234: EMPTY
85235: LIST
85236: LIST
85237: PUSH
85238: LD_INT 2
85240: NEG
85241: PUSH
85242: LD_INT 1
85244: NEG
85245: PUSH
85246: EMPTY
85247: LIST
85248: LIST
85249: PUSH
85250: LD_INT 2
85252: NEG
85253: PUSH
85254: LD_INT 2
85256: NEG
85257: PUSH
85258: EMPTY
85259: LIST
85260: LIST
85261: PUSH
85262: LD_INT 1
85264: PUSH
85265: LD_INT 2
85267: NEG
85268: PUSH
85269: EMPTY
85270: LIST
85271: LIST
85272: PUSH
85273: LD_INT 2
85275: PUSH
85276: LD_INT 1
85278: NEG
85279: PUSH
85280: EMPTY
85281: LIST
85282: LIST
85283: PUSH
85284: LD_INT 3
85286: PUSH
85287: LD_INT 1
85289: PUSH
85290: EMPTY
85291: LIST
85292: LIST
85293: PUSH
85294: LD_INT 3
85296: PUSH
85297: LD_INT 2
85299: PUSH
85300: EMPTY
85301: LIST
85302: LIST
85303: PUSH
85304: EMPTY
85305: LIST
85306: LIST
85307: LIST
85308: LIST
85309: LIST
85310: LIST
85311: LIST
85312: LIST
85313: LIST
85314: LIST
85315: LIST
85316: LIST
85317: LIST
85318: LIST
85319: LIST
85320: LIST
85321: LIST
85322: LIST
85323: LIST
85324: LIST
85325: LIST
85326: LIST
85327: LIST
85328: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
85329: LD_ADDR_VAR 0 25
85333: PUSH
85334: LD_INT 0
85336: PUSH
85337: LD_INT 0
85339: PUSH
85340: EMPTY
85341: LIST
85342: LIST
85343: PUSH
85344: LD_INT 0
85346: PUSH
85347: LD_INT 1
85349: NEG
85350: PUSH
85351: EMPTY
85352: LIST
85353: LIST
85354: PUSH
85355: LD_INT 1
85357: PUSH
85358: LD_INT 0
85360: PUSH
85361: EMPTY
85362: LIST
85363: LIST
85364: PUSH
85365: LD_INT 1
85367: PUSH
85368: LD_INT 1
85370: PUSH
85371: EMPTY
85372: LIST
85373: LIST
85374: PUSH
85375: LD_INT 0
85377: PUSH
85378: LD_INT 1
85380: PUSH
85381: EMPTY
85382: LIST
85383: LIST
85384: PUSH
85385: LD_INT 1
85387: NEG
85388: PUSH
85389: LD_INT 0
85391: PUSH
85392: EMPTY
85393: LIST
85394: LIST
85395: PUSH
85396: LD_INT 1
85398: NEG
85399: PUSH
85400: LD_INT 1
85402: NEG
85403: PUSH
85404: EMPTY
85405: LIST
85406: LIST
85407: PUSH
85408: LD_INT 1
85410: NEG
85411: PUSH
85412: LD_INT 2
85414: NEG
85415: PUSH
85416: EMPTY
85417: LIST
85418: LIST
85419: PUSH
85420: LD_INT 0
85422: PUSH
85423: LD_INT 2
85425: NEG
85426: PUSH
85427: EMPTY
85428: LIST
85429: LIST
85430: PUSH
85431: LD_INT 1
85433: PUSH
85434: LD_INT 1
85436: NEG
85437: PUSH
85438: EMPTY
85439: LIST
85440: LIST
85441: PUSH
85442: LD_INT 2
85444: PUSH
85445: LD_INT 0
85447: PUSH
85448: EMPTY
85449: LIST
85450: LIST
85451: PUSH
85452: LD_INT 2
85454: PUSH
85455: LD_INT 1
85457: PUSH
85458: EMPTY
85459: LIST
85460: LIST
85461: PUSH
85462: LD_INT 2
85464: PUSH
85465: LD_INT 2
85467: PUSH
85468: EMPTY
85469: LIST
85470: LIST
85471: PUSH
85472: LD_INT 1
85474: PUSH
85475: LD_INT 2
85477: PUSH
85478: EMPTY
85479: LIST
85480: LIST
85481: PUSH
85482: LD_INT 0
85484: PUSH
85485: LD_INT 2
85487: PUSH
85488: EMPTY
85489: LIST
85490: LIST
85491: PUSH
85492: LD_INT 1
85494: NEG
85495: PUSH
85496: LD_INT 1
85498: PUSH
85499: EMPTY
85500: LIST
85501: LIST
85502: PUSH
85503: LD_INT 2
85505: NEG
85506: PUSH
85507: LD_INT 0
85509: PUSH
85510: EMPTY
85511: LIST
85512: LIST
85513: PUSH
85514: LD_INT 2
85516: NEG
85517: PUSH
85518: LD_INT 1
85520: NEG
85521: PUSH
85522: EMPTY
85523: LIST
85524: LIST
85525: PUSH
85526: LD_INT 2
85528: NEG
85529: PUSH
85530: LD_INT 2
85532: NEG
85533: PUSH
85534: EMPTY
85535: LIST
85536: LIST
85537: PUSH
85538: LD_INT 3
85540: PUSH
85541: LD_INT 1
85543: PUSH
85544: EMPTY
85545: LIST
85546: LIST
85547: PUSH
85548: LD_INT 3
85550: PUSH
85551: LD_INT 2
85553: PUSH
85554: EMPTY
85555: LIST
85556: LIST
85557: PUSH
85558: LD_INT 2
85560: PUSH
85561: LD_INT 3
85563: PUSH
85564: EMPTY
85565: LIST
85566: LIST
85567: PUSH
85568: LD_INT 1
85570: PUSH
85571: LD_INT 3
85573: PUSH
85574: EMPTY
85575: LIST
85576: LIST
85577: PUSH
85578: EMPTY
85579: LIST
85580: LIST
85581: LIST
85582: LIST
85583: LIST
85584: LIST
85585: LIST
85586: LIST
85587: LIST
85588: LIST
85589: LIST
85590: LIST
85591: LIST
85592: LIST
85593: LIST
85594: LIST
85595: LIST
85596: LIST
85597: LIST
85598: LIST
85599: LIST
85600: LIST
85601: LIST
85602: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
85603: LD_ADDR_VAR 0 26
85607: PUSH
85608: LD_INT 0
85610: PUSH
85611: LD_INT 0
85613: PUSH
85614: EMPTY
85615: LIST
85616: LIST
85617: PUSH
85618: LD_INT 0
85620: PUSH
85621: LD_INT 1
85623: NEG
85624: PUSH
85625: EMPTY
85626: LIST
85627: LIST
85628: PUSH
85629: LD_INT 1
85631: PUSH
85632: LD_INT 0
85634: PUSH
85635: EMPTY
85636: LIST
85637: LIST
85638: PUSH
85639: LD_INT 1
85641: PUSH
85642: LD_INT 1
85644: PUSH
85645: EMPTY
85646: LIST
85647: LIST
85648: PUSH
85649: LD_INT 0
85651: PUSH
85652: LD_INT 1
85654: PUSH
85655: EMPTY
85656: LIST
85657: LIST
85658: PUSH
85659: LD_INT 1
85661: NEG
85662: PUSH
85663: LD_INT 0
85665: PUSH
85666: EMPTY
85667: LIST
85668: LIST
85669: PUSH
85670: LD_INT 1
85672: NEG
85673: PUSH
85674: LD_INT 1
85676: NEG
85677: PUSH
85678: EMPTY
85679: LIST
85680: LIST
85681: PUSH
85682: LD_INT 1
85684: NEG
85685: PUSH
85686: LD_INT 2
85688: NEG
85689: PUSH
85690: EMPTY
85691: LIST
85692: LIST
85693: PUSH
85694: LD_INT 0
85696: PUSH
85697: LD_INT 2
85699: NEG
85700: PUSH
85701: EMPTY
85702: LIST
85703: LIST
85704: PUSH
85705: LD_INT 1
85707: PUSH
85708: LD_INT 1
85710: NEG
85711: PUSH
85712: EMPTY
85713: LIST
85714: LIST
85715: PUSH
85716: LD_INT 2
85718: PUSH
85719: LD_INT 0
85721: PUSH
85722: EMPTY
85723: LIST
85724: LIST
85725: PUSH
85726: LD_INT 2
85728: PUSH
85729: LD_INT 1
85731: PUSH
85732: EMPTY
85733: LIST
85734: LIST
85735: PUSH
85736: LD_INT 2
85738: PUSH
85739: LD_INT 2
85741: PUSH
85742: EMPTY
85743: LIST
85744: LIST
85745: PUSH
85746: LD_INT 1
85748: PUSH
85749: LD_INT 2
85751: PUSH
85752: EMPTY
85753: LIST
85754: LIST
85755: PUSH
85756: LD_INT 0
85758: PUSH
85759: LD_INT 2
85761: PUSH
85762: EMPTY
85763: LIST
85764: LIST
85765: PUSH
85766: LD_INT 1
85768: NEG
85769: PUSH
85770: LD_INT 1
85772: PUSH
85773: EMPTY
85774: LIST
85775: LIST
85776: PUSH
85777: LD_INT 2
85779: NEG
85780: PUSH
85781: LD_INT 0
85783: PUSH
85784: EMPTY
85785: LIST
85786: LIST
85787: PUSH
85788: LD_INT 2
85790: NEG
85791: PUSH
85792: LD_INT 1
85794: NEG
85795: PUSH
85796: EMPTY
85797: LIST
85798: LIST
85799: PUSH
85800: LD_INT 2
85802: NEG
85803: PUSH
85804: LD_INT 2
85806: NEG
85807: PUSH
85808: EMPTY
85809: LIST
85810: LIST
85811: PUSH
85812: LD_INT 2
85814: PUSH
85815: LD_INT 3
85817: PUSH
85818: EMPTY
85819: LIST
85820: LIST
85821: PUSH
85822: LD_INT 1
85824: PUSH
85825: LD_INT 3
85827: PUSH
85828: EMPTY
85829: LIST
85830: LIST
85831: PUSH
85832: LD_INT 1
85834: NEG
85835: PUSH
85836: LD_INT 2
85838: PUSH
85839: EMPTY
85840: LIST
85841: LIST
85842: PUSH
85843: LD_INT 2
85845: NEG
85846: PUSH
85847: LD_INT 1
85849: PUSH
85850: EMPTY
85851: LIST
85852: LIST
85853: PUSH
85854: EMPTY
85855: LIST
85856: LIST
85857: LIST
85858: LIST
85859: LIST
85860: LIST
85861: LIST
85862: LIST
85863: LIST
85864: LIST
85865: LIST
85866: LIST
85867: LIST
85868: LIST
85869: LIST
85870: LIST
85871: LIST
85872: LIST
85873: LIST
85874: LIST
85875: LIST
85876: LIST
85877: LIST
85878: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
85879: LD_ADDR_VAR 0 27
85883: PUSH
85884: LD_INT 0
85886: PUSH
85887: LD_INT 0
85889: PUSH
85890: EMPTY
85891: LIST
85892: LIST
85893: PUSH
85894: LD_INT 0
85896: PUSH
85897: LD_INT 1
85899: NEG
85900: PUSH
85901: EMPTY
85902: LIST
85903: LIST
85904: PUSH
85905: LD_INT 1
85907: PUSH
85908: LD_INT 0
85910: PUSH
85911: EMPTY
85912: LIST
85913: LIST
85914: PUSH
85915: LD_INT 1
85917: PUSH
85918: LD_INT 1
85920: PUSH
85921: EMPTY
85922: LIST
85923: LIST
85924: PUSH
85925: LD_INT 0
85927: PUSH
85928: LD_INT 1
85930: PUSH
85931: EMPTY
85932: LIST
85933: LIST
85934: PUSH
85935: LD_INT 1
85937: NEG
85938: PUSH
85939: LD_INT 0
85941: PUSH
85942: EMPTY
85943: LIST
85944: LIST
85945: PUSH
85946: LD_INT 1
85948: NEG
85949: PUSH
85950: LD_INT 1
85952: NEG
85953: PUSH
85954: EMPTY
85955: LIST
85956: LIST
85957: PUSH
85958: LD_INT 1
85960: NEG
85961: PUSH
85962: LD_INT 2
85964: NEG
85965: PUSH
85966: EMPTY
85967: LIST
85968: LIST
85969: PUSH
85970: LD_INT 0
85972: PUSH
85973: LD_INT 2
85975: NEG
85976: PUSH
85977: EMPTY
85978: LIST
85979: LIST
85980: PUSH
85981: LD_INT 1
85983: PUSH
85984: LD_INT 1
85986: NEG
85987: PUSH
85988: EMPTY
85989: LIST
85990: LIST
85991: PUSH
85992: LD_INT 2
85994: PUSH
85995: LD_INT 0
85997: PUSH
85998: EMPTY
85999: LIST
86000: LIST
86001: PUSH
86002: LD_INT 2
86004: PUSH
86005: LD_INT 1
86007: PUSH
86008: EMPTY
86009: LIST
86010: LIST
86011: PUSH
86012: LD_INT 2
86014: PUSH
86015: LD_INT 2
86017: PUSH
86018: EMPTY
86019: LIST
86020: LIST
86021: PUSH
86022: LD_INT 1
86024: PUSH
86025: LD_INT 2
86027: PUSH
86028: EMPTY
86029: LIST
86030: LIST
86031: PUSH
86032: LD_INT 0
86034: PUSH
86035: LD_INT 2
86037: PUSH
86038: EMPTY
86039: LIST
86040: LIST
86041: PUSH
86042: LD_INT 1
86044: NEG
86045: PUSH
86046: LD_INT 1
86048: PUSH
86049: EMPTY
86050: LIST
86051: LIST
86052: PUSH
86053: LD_INT 2
86055: NEG
86056: PUSH
86057: LD_INT 0
86059: PUSH
86060: EMPTY
86061: LIST
86062: LIST
86063: PUSH
86064: LD_INT 2
86066: NEG
86067: PUSH
86068: LD_INT 1
86070: NEG
86071: PUSH
86072: EMPTY
86073: LIST
86074: LIST
86075: PUSH
86076: LD_INT 2
86078: NEG
86079: PUSH
86080: LD_INT 2
86082: NEG
86083: PUSH
86084: EMPTY
86085: LIST
86086: LIST
86087: PUSH
86088: LD_INT 1
86090: NEG
86091: PUSH
86092: LD_INT 2
86094: PUSH
86095: EMPTY
86096: LIST
86097: LIST
86098: PUSH
86099: LD_INT 2
86101: NEG
86102: PUSH
86103: LD_INT 1
86105: PUSH
86106: EMPTY
86107: LIST
86108: LIST
86109: PUSH
86110: LD_INT 3
86112: NEG
86113: PUSH
86114: LD_INT 1
86116: NEG
86117: PUSH
86118: EMPTY
86119: LIST
86120: LIST
86121: PUSH
86122: LD_INT 3
86124: NEG
86125: PUSH
86126: LD_INT 2
86128: NEG
86129: PUSH
86130: EMPTY
86131: LIST
86132: LIST
86133: PUSH
86134: EMPTY
86135: LIST
86136: LIST
86137: LIST
86138: LIST
86139: LIST
86140: LIST
86141: LIST
86142: LIST
86143: LIST
86144: LIST
86145: LIST
86146: LIST
86147: LIST
86148: LIST
86149: LIST
86150: LIST
86151: LIST
86152: LIST
86153: LIST
86154: LIST
86155: LIST
86156: LIST
86157: LIST
86158: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
86159: LD_ADDR_VAR 0 28
86163: PUSH
86164: LD_INT 0
86166: PUSH
86167: LD_INT 0
86169: PUSH
86170: EMPTY
86171: LIST
86172: LIST
86173: PUSH
86174: LD_INT 0
86176: PUSH
86177: LD_INT 1
86179: NEG
86180: PUSH
86181: EMPTY
86182: LIST
86183: LIST
86184: PUSH
86185: LD_INT 1
86187: PUSH
86188: LD_INT 0
86190: PUSH
86191: EMPTY
86192: LIST
86193: LIST
86194: PUSH
86195: LD_INT 1
86197: PUSH
86198: LD_INT 1
86200: PUSH
86201: EMPTY
86202: LIST
86203: LIST
86204: PUSH
86205: LD_INT 0
86207: PUSH
86208: LD_INT 1
86210: PUSH
86211: EMPTY
86212: LIST
86213: LIST
86214: PUSH
86215: LD_INT 1
86217: NEG
86218: PUSH
86219: LD_INT 0
86221: PUSH
86222: EMPTY
86223: LIST
86224: LIST
86225: PUSH
86226: LD_INT 1
86228: NEG
86229: PUSH
86230: LD_INT 1
86232: NEG
86233: PUSH
86234: EMPTY
86235: LIST
86236: LIST
86237: PUSH
86238: LD_INT 1
86240: NEG
86241: PUSH
86242: LD_INT 2
86244: NEG
86245: PUSH
86246: EMPTY
86247: LIST
86248: LIST
86249: PUSH
86250: LD_INT 0
86252: PUSH
86253: LD_INT 2
86255: NEG
86256: PUSH
86257: EMPTY
86258: LIST
86259: LIST
86260: PUSH
86261: LD_INT 1
86263: PUSH
86264: LD_INT 1
86266: NEG
86267: PUSH
86268: EMPTY
86269: LIST
86270: LIST
86271: PUSH
86272: LD_INT 2
86274: PUSH
86275: LD_INT 0
86277: PUSH
86278: EMPTY
86279: LIST
86280: LIST
86281: PUSH
86282: LD_INT 2
86284: PUSH
86285: LD_INT 1
86287: PUSH
86288: EMPTY
86289: LIST
86290: LIST
86291: PUSH
86292: LD_INT 2
86294: PUSH
86295: LD_INT 2
86297: PUSH
86298: EMPTY
86299: LIST
86300: LIST
86301: PUSH
86302: LD_INT 1
86304: PUSH
86305: LD_INT 2
86307: PUSH
86308: EMPTY
86309: LIST
86310: LIST
86311: PUSH
86312: LD_INT 0
86314: PUSH
86315: LD_INT 2
86317: PUSH
86318: EMPTY
86319: LIST
86320: LIST
86321: PUSH
86322: LD_INT 1
86324: NEG
86325: PUSH
86326: LD_INT 1
86328: PUSH
86329: EMPTY
86330: LIST
86331: LIST
86332: PUSH
86333: LD_INT 2
86335: NEG
86336: PUSH
86337: LD_INT 0
86339: PUSH
86340: EMPTY
86341: LIST
86342: LIST
86343: PUSH
86344: LD_INT 2
86346: NEG
86347: PUSH
86348: LD_INT 1
86350: NEG
86351: PUSH
86352: EMPTY
86353: LIST
86354: LIST
86355: PUSH
86356: LD_INT 2
86358: NEG
86359: PUSH
86360: LD_INT 2
86362: NEG
86363: PUSH
86364: EMPTY
86365: LIST
86366: LIST
86367: PUSH
86368: LD_INT 2
86370: NEG
86371: PUSH
86372: LD_INT 3
86374: NEG
86375: PUSH
86376: EMPTY
86377: LIST
86378: LIST
86379: PUSH
86380: LD_INT 1
86382: NEG
86383: PUSH
86384: LD_INT 3
86386: NEG
86387: PUSH
86388: EMPTY
86389: LIST
86390: LIST
86391: PUSH
86392: LD_INT 3
86394: NEG
86395: PUSH
86396: LD_INT 1
86398: NEG
86399: PUSH
86400: EMPTY
86401: LIST
86402: LIST
86403: PUSH
86404: LD_INT 3
86406: NEG
86407: PUSH
86408: LD_INT 2
86410: NEG
86411: PUSH
86412: EMPTY
86413: LIST
86414: LIST
86415: PUSH
86416: EMPTY
86417: LIST
86418: LIST
86419: LIST
86420: LIST
86421: LIST
86422: LIST
86423: LIST
86424: LIST
86425: LIST
86426: LIST
86427: LIST
86428: LIST
86429: LIST
86430: LIST
86431: LIST
86432: LIST
86433: LIST
86434: LIST
86435: LIST
86436: LIST
86437: LIST
86438: LIST
86439: LIST
86440: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
86441: LD_ADDR_VAR 0 29
86445: PUSH
86446: LD_INT 0
86448: PUSH
86449: LD_INT 0
86451: PUSH
86452: EMPTY
86453: LIST
86454: LIST
86455: PUSH
86456: LD_INT 0
86458: PUSH
86459: LD_INT 1
86461: NEG
86462: PUSH
86463: EMPTY
86464: LIST
86465: LIST
86466: PUSH
86467: LD_INT 1
86469: PUSH
86470: LD_INT 0
86472: PUSH
86473: EMPTY
86474: LIST
86475: LIST
86476: PUSH
86477: LD_INT 1
86479: PUSH
86480: LD_INT 1
86482: PUSH
86483: EMPTY
86484: LIST
86485: LIST
86486: PUSH
86487: LD_INT 0
86489: PUSH
86490: LD_INT 1
86492: PUSH
86493: EMPTY
86494: LIST
86495: LIST
86496: PUSH
86497: LD_INT 1
86499: NEG
86500: PUSH
86501: LD_INT 0
86503: PUSH
86504: EMPTY
86505: LIST
86506: LIST
86507: PUSH
86508: LD_INT 1
86510: NEG
86511: PUSH
86512: LD_INT 1
86514: NEG
86515: PUSH
86516: EMPTY
86517: LIST
86518: LIST
86519: PUSH
86520: LD_INT 1
86522: NEG
86523: PUSH
86524: LD_INT 2
86526: NEG
86527: PUSH
86528: EMPTY
86529: LIST
86530: LIST
86531: PUSH
86532: LD_INT 0
86534: PUSH
86535: LD_INT 2
86537: NEG
86538: PUSH
86539: EMPTY
86540: LIST
86541: LIST
86542: PUSH
86543: LD_INT 1
86545: PUSH
86546: LD_INT 1
86548: NEG
86549: PUSH
86550: EMPTY
86551: LIST
86552: LIST
86553: PUSH
86554: LD_INT 2
86556: PUSH
86557: LD_INT 0
86559: PUSH
86560: EMPTY
86561: LIST
86562: LIST
86563: PUSH
86564: LD_INT 2
86566: PUSH
86567: LD_INT 1
86569: PUSH
86570: EMPTY
86571: LIST
86572: LIST
86573: PUSH
86574: LD_INT 1
86576: PUSH
86577: LD_INT 2
86579: PUSH
86580: EMPTY
86581: LIST
86582: LIST
86583: PUSH
86584: LD_INT 0
86586: PUSH
86587: LD_INT 2
86589: PUSH
86590: EMPTY
86591: LIST
86592: LIST
86593: PUSH
86594: LD_INT 1
86596: NEG
86597: PUSH
86598: LD_INT 1
86600: PUSH
86601: EMPTY
86602: LIST
86603: LIST
86604: PUSH
86605: LD_INT 2
86607: NEG
86608: PUSH
86609: LD_INT 1
86611: NEG
86612: PUSH
86613: EMPTY
86614: LIST
86615: LIST
86616: PUSH
86617: LD_INT 2
86619: NEG
86620: PUSH
86621: LD_INT 2
86623: NEG
86624: PUSH
86625: EMPTY
86626: LIST
86627: LIST
86628: PUSH
86629: LD_INT 2
86631: NEG
86632: PUSH
86633: LD_INT 3
86635: NEG
86636: PUSH
86637: EMPTY
86638: LIST
86639: LIST
86640: PUSH
86641: LD_INT 2
86643: PUSH
86644: LD_INT 1
86646: NEG
86647: PUSH
86648: EMPTY
86649: LIST
86650: LIST
86651: PUSH
86652: LD_INT 3
86654: PUSH
86655: LD_INT 1
86657: PUSH
86658: EMPTY
86659: LIST
86660: LIST
86661: PUSH
86662: LD_INT 1
86664: PUSH
86665: LD_INT 3
86667: PUSH
86668: EMPTY
86669: LIST
86670: LIST
86671: PUSH
86672: LD_INT 1
86674: NEG
86675: PUSH
86676: LD_INT 2
86678: PUSH
86679: EMPTY
86680: LIST
86681: LIST
86682: PUSH
86683: LD_INT 3
86685: NEG
86686: PUSH
86687: LD_INT 2
86689: NEG
86690: PUSH
86691: EMPTY
86692: LIST
86693: LIST
86694: PUSH
86695: EMPTY
86696: LIST
86697: LIST
86698: LIST
86699: LIST
86700: LIST
86701: LIST
86702: LIST
86703: LIST
86704: LIST
86705: LIST
86706: LIST
86707: LIST
86708: LIST
86709: LIST
86710: LIST
86711: LIST
86712: LIST
86713: LIST
86714: LIST
86715: LIST
86716: LIST
86717: LIST
86718: LIST
86719: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86720: LD_ADDR_VAR 0 30
86724: PUSH
86725: LD_INT 0
86727: PUSH
86728: LD_INT 0
86730: PUSH
86731: EMPTY
86732: LIST
86733: LIST
86734: PUSH
86735: LD_INT 0
86737: PUSH
86738: LD_INT 1
86740: NEG
86741: PUSH
86742: EMPTY
86743: LIST
86744: LIST
86745: PUSH
86746: LD_INT 1
86748: PUSH
86749: LD_INT 0
86751: PUSH
86752: EMPTY
86753: LIST
86754: LIST
86755: PUSH
86756: LD_INT 1
86758: PUSH
86759: LD_INT 1
86761: PUSH
86762: EMPTY
86763: LIST
86764: LIST
86765: PUSH
86766: LD_INT 0
86768: PUSH
86769: LD_INT 1
86771: PUSH
86772: EMPTY
86773: LIST
86774: LIST
86775: PUSH
86776: LD_INT 1
86778: NEG
86779: PUSH
86780: LD_INT 0
86782: PUSH
86783: EMPTY
86784: LIST
86785: LIST
86786: PUSH
86787: LD_INT 1
86789: NEG
86790: PUSH
86791: LD_INT 1
86793: NEG
86794: PUSH
86795: EMPTY
86796: LIST
86797: LIST
86798: PUSH
86799: LD_INT 1
86801: NEG
86802: PUSH
86803: LD_INT 2
86805: NEG
86806: PUSH
86807: EMPTY
86808: LIST
86809: LIST
86810: PUSH
86811: LD_INT 0
86813: PUSH
86814: LD_INT 2
86816: NEG
86817: PUSH
86818: EMPTY
86819: LIST
86820: LIST
86821: PUSH
86822: LD_INT 1
86824: PUSH
86825: LD_INT 1
86827: NEG
86828: PUSH
86829: EMPTY
86830: LIST
86831: LIST
86832: PUSH
86833: LD_INT 2
86835: PUSH
86836: LD_INT 0
86838: PUSH
86839: EMPTY
86840: LIST
86841: LIST
86842: PUSH
86843: LD_INT 2
86845: PUSH
86846: LD_INT 1
86848: PUSH
86849: EMPTY
86850: LIST
86851: LIST
86852: PUSH
86853: LD_INT 2
86855: PUSH
86856: LD_INT 2
86858: PUSH
86859: EMPTY
86860: LIST
86861: LIST
86862: PUSH
86863: LD_INT 1
86865: PUSH
86866: LD_INT 2
86868: PUSH
86869: EMPTY
86870: LIST
86871: LIST
86872: PUSH
86873: LD_INT 1
86875: NEG
86876: PUSH
86877: LD_INT 1
86879: PUSH
86880: EMPTY
86881: LIST
86882: LIST
86883: PUSH
86884: LD_INT 2
86886: NEG
86887: PUSH
86888: LD_INT 0
86890: PUSH
86891: EMPTY
86892: LIST
86893: LIST
86894: PUSH
86895: LD_INT 2
86897: NEG
86898: PUSH
86899: LD_INT 1
86901: NEG
86902: PUSH
86903: EMPTY
86904: LIST
86905: LIST
86906: PUSH
86907: LD_INT 1
86909: NEG
86910: PUSH
86911: LD_INT 3
86913: NEG
86914: PUSH
86915: EMPTY
86916: LIST
86917: LIST
86918: PUSH
86919: LD_INT 1
86921: PUSH
86922: LD_INT 2
86924: NEG
86925: PUSH
86926: EMPTY
86927: LIST
86928: LIST
86929: PUSH
86930: LD_INT 3
86932: PUSH
86933: LD_INT 2
86935: PUSH
86936: EMPTY
86937: LIST
86938: LIST
86939: PUSH
86940: LD_INT 2
86942: PUSH
86943: LD_INT 3
86945: PUSH
86946: EMPTY
86947: LIST
86948: LIST
86949: PUSH
86950: LD_INT 2
86952: NEG
86953: PUSH
86954: LD_INT 1
86956: PUSH
86957: EMPTY
86958: LIST
86959: LIST
86960: PUSH
86961: LD_INT 3
86963: NEG
86964: PUSH
86965: LD_INT 1
86967: NEG
86968: PUSH
86969: EMPTY
86970: LIST
86971: LIST
86972: PUSH
86973: EMPTY
86974: LIST
86975: LIST
86976: LIST
86977: LIST
86978: LIST
86979: LIST
86980: LIST
86981: LIST
86982: LIST
86983: LIST
86984: LIST
86985: LIST
86986: LIST
86987: LIST
86988: LIST
86989: LIST
86990: LIST
86991: LIST
86992: LIST
86993: LIST
86994: LIST
86995: LIST
86996: LIST
86997: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
86998: LD_ADDR_VAR 0 31
87002: PUSH
87003: LD_INT 0
87005: PUSH
87006: LD_INT 0
87008: PUSH
87009: EMPTY
87010: LIST
87011: LIST
87012: PUSH
87013: LD_INT 0
87015: PUSH
87016: LD_INT 1
87018: NEG
87019: PUSH
87020: EMPTY
87021: LIST
87022: LIST
87023: PUSH
87024: LD_INT 1
87026: PUSH
87027: LD_INT 0
87029: PUSH
87030: EMPTY
87031: LIST
87032: LIST
87033: PUSH
87034: LD_INT 1
87036: PUSH
87037: LD_INT 1
87039: PUSH
87040: EMPTY
87041: LIST
87042: LIST
87043: PUSH
87044: LD_INT 0
87046: PUSH
87047: LD_INT 1
87049: PUSH
87050: EMPTY
87051: LIST
87052: LIST
87053: PUSH
87054: LD_INT 1
87056: NEG
87057: PUSH
87058: LD_INT 0
87060: PUSH
87061: EMPTY
87062: LIST
87063: LIST
87064: PUSH
87065: LD_INT 1
87067: NEG
87068: PUSH
87069: LD_INT 1
87071: NEG
87072: PUSH
87073: EMPTY
87074: LIST
87075: LIST
87076: PUSH
87077: LD_INT 1
87079: NEG
87080: PUSH
87081: LD_INT 2
87083: NEG
87084: PUSH
87085: EMPTY
87086: LIST
87087: LIST
87088: PUSH
87089: LD_INT 1
87091: PUSH
87092: LD_INT 1
87094: NEG
87095: PUSH
87096: EMPTY
87097: LIST
87098: LIST
87099: PUSH
87100: LD_INT 2
87102: PUSH
87103: LD_INT 0
87105: PUSH
87106: EMPTY
87107: LIST
87108: LIST
87109: PUSH
87110: LD_INT 2
87112: PUSH
87113: LD_INT 1
87115: PUSH
87116: EMPTY
87117: LIST
87118: LIST
87119: PUSH
87120: LD_INT 2
87122: PUSH
87123: LD_INT 2
87125: PUSH
87126: EMPTY
87127: LIST
87128: LIST
87129: PUSH
87130: LD_INT 1
87132: PUSH
87133: LD_INT 2
87135: PUSH
87136: EMPTY
87137: LIST
87138: LIST
87139: PUSH
87140: LD_INT 0
87142: PUSH
87143: LD_INT 2
87145: PUSH
87146: EMPTY
87147: LIST
87148: LIST
87149: PUSH
87150: LD_INT 1
87152: NEG
87153: PUSH
87154: LD_INT 1
87156: PUSH
87157: EMPTY
87158: LIST
87159: LIST
87160: PUSH
87161: LD_INT 2
87163: NEG
87164: PUSH
87165: LD_INT 1
87167: NEG
87168: PUSH
87169: EMPTY
87170: LIST
87171: LIST
87172: PUSH
87173: LD_INT 2
87175: NEG
87176: PUSH
87177: LD_INT 2
87179: NEG
87180: PUSH
87181: EMPTY
87182: LIST
87183: LIST
87184: PUSH
87185: LD_INT 2
87187: NEG
87188: PUSH
87189: LD_INT 3
87191: NEG
87192: PUSH
87193: EMPTY
87194: LIST
87195: LIST
87196: PUSH
87197: LD_INT 2
87199: PUSH
87200: LD_INT 1
87202: NEG
87203: PUSH
87204: EMPTY
87205: LIST
87206: LIST
87207: PUSH
87208: LD_INT 3
87210: PUSH
87211: LD_INT 1
87213: PUSH
87214: EMPTY
87215: LIST
87216: LIST
87217: PUSH
87218: LD_INT 1
87220: PUSH
87221: LD_INT 3
87223: PUSH
87224: EMPTY
87225: LIST
87226: LIST
87227: PUSH
87228: LD_INT 1
87230: NEG
87231: PUSH
87232: LD_INT 2
87234: PUSH
87235: EMPTY
87236: LIST
87237: LIST
87238: PUSH
87239: LD_INT 3
87241: NEG
87242: PUSH
87243: LD_INT 2
87245: NEG
87246: PUSH
87247: EMPTY
87248: LIST
87249: LIST
87250: PUSH
87251: EMPTY
87252: LIST
87253: LIST
87254: LIST
87255: LIST
87256: LIST
87257: LIST
87258: LIST
87259: LIST
87260: LIST
87261: LIST
87262: LIST
87263: LIST
87264: LIST
87265: LIST
87266: LIST
87267: LIST
87268: LIST
87269: LIST
87270: LIST
87271: LIST
87272: LIST
87273: LIST
87274: LIST
87275: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
87276: LD_ADDR_VAR 0 32
87280: PUSH
87281: LD_INT 0
87283: PUSH
87284: LD_INT 0
87286: PUSH
87287: EMPTY
87288: LIST
87289: LIST
87290: PUSH
87291: LD_INT 0
87293: PUSH
87294: LD_INT 1
87296: NEG
87297: PUSH
87298: EMPTY
87299: LIST
87300: LIST
87301: PUSH
87302: LD_INT 1
87304: PUSH
87305: LD_INT 0
87307: PUSH
87308: EMPTY
87309: LIST
87310: LIST
87311: PUSH
87312: LD_INT 1
87314: PUSH
87315: LD_INT 1
87317: PUSH
87318: EMPTY
87319: LIST
87320: LIST
87321: PUSH
87322: LD_INT 0
87324: PUSH
87325: LD_INT 1
87327: PUSH
87328: EMPTY
87329: LIST
87330: LIST
87331: PUSH
87332: LD_INT 1
87334: NEG
87335: PUSH
87336: LD_INT 0
87338: PUSH
87339: EMPTY
87340: LIST
87341: LIST
87342: PUSH
87343: LD_INT 1
87345: NEG
87346: PUSH
87347: LD_INT 1
87349: NEG
87350: PUSH
87351: EMPTY
87352: LIST
87353: LIST
87354: PUSH
87355: LD_INT 1
87357: NEG
87358: PUSH
87359: LD_INT 2
87361: NEG
87362: PUSH
87363: EMPTY
87364: LIST
87365: LIST
87366: PUSH
87367: LD_INT 0
87369: PUSH
87370: LD_INT 2
87372: NEG
87373: PUSH
87374: EMPTY
87375: LIST
87376: LIST
87377: PUSH
87378: LD_INT 1
87380: PUSH
87381: LD_INT 1
87383: NEG
87384: PUSH
87385: EMPTY
87386: LIST
87387: LIST
87388: PUSH
87389: LD_INT 2
87391: PUSH
87392: LD_INT 1
87394: PUSH
87395: EMPTY
87396: LIST
87397: LIST
87398: PUSH
87399: LD_INT 2
87401: PUSH
87402: LD_INT 2
87404: PUSH
87405: EMPTY
87406: LIST
87407: LIST
87408: PUSH
87409: LD_INT 1
87411: PUSH
87412: LD_INT 2
87414: PUSH
87415: EMPTY
87416: LIST
87417: LIST
87418: PUSH
87419: LD_INT 0
87421: PUSH
87422: LD_INT 2
87424: PUSH
87425: EMPTY
87426: LIST
87427: LIST
87428: PUSH
87429: LD_INT 1
87431: NEG
87432: PUSH
87433: LD_INT 1
87435: PUSH
87436: EMPTY
87437: LIST
87438: LIST
87439: PUSH
87440: LD_INT 2
87442: NEG
87443: PUSH
87444: LD_INT 0
87446: PUSH
87447: EMPTY
87448: LIST
87449: LIST
87450: PUSH
87451: LD_INT 2
87453: NEG
87454: PUSH
87455: LD_INT 1
87457: NEG
87458: PUSH
87459: EMPTY
87460: LIST
87461: LIST
87462: PUSH
87463: LD_INT 1
87465: NEG
87466: PUSH
87467: LD_INT 3
87469: NEG
87470: PUSH
87471: EMPTY
87472: LIST
87473: LIST
87474: PUSH
87475: LD_INT 1
87477: PUSH
87478: LD_INT 2
87480: NEG
87481: PUSH
87482: EMPTY
87483: LIST
87484: LIST
87485: PUSH
87486: LD_INT 3
87488: PUSH
87489: LD_INT 2
87491: PUSH
87492: EMPTY
87493: LIST
87494: LIST
87495: PUSH
87496: LD_INT 2
87498: PUSH
87499: LD_INT 3
87501: PUSH
87502: EMPTY
87503: LIST
87504: LIST
87505: PUSH
87506: LD_INT 2
87508: NEG
87509: PUSH
87510: LD_INT 1
87512: PUSH
87513: EMPTY
87514: LIST
87515: LIST
87516: PUSH
87517: LD_INT 3
87519: NEG
87520: PUSH
87521: LD_INT 1
87523: NEG
87524: PUSH
87525: EMPTY
87526: LIST
87527: LIST
87528: PUSH
87529: EMPTY
87530: LIST
87531: LIST
87532: LIST
87533: LIST
87534: LIST
87535: LIST
87536: LIST
87537: LIST
87538: LIST
87539: LIST
87540: LIST
87541: LIST
87542: LIST
87543: LIST
87544: LIST
87545: LIST
87546: LIST
87547: LIST
87548: LIST
87549: LIST
87550: LIST
87551: LIST
87552: LIST
87553: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
87554: LD_ADDR_VAR 0 33
87558: PUSH
87559: LD_INT 0
87561: PUSH
87562: LD_INT 0
87564: PUSH
87565: EMPTY
87566: LIST
87567: LIST
87568: PUSH
87569: LD_INT 0
87571: PUSH
87572: LD_INT 1
87574: NEG
87575: PUSH
87576: EMPTY
87577: LIST
87578: LIST
87579: PUSH
87580: LD_INT 1
87582: PUSH
87583: LD_INT 0
87585: PUSH
87586: EMPTY
87587: LIST
87588: LIST
87589: PUSH
87590: LD_INT 1
87592: PUSH
87593: LD_INT 1
87595: PUSH
87596: EMPTY
87597: LIST
87598: LIST
87599: PUSH
87600: LD_INT 0
87602: PUSH
87603: LD_INT 1
87605: PUSH
87606: EMPTY
87607: LIST
87608: LIST
87609: PUSH
87610: LD_INT 1
87612: NEG
87613: PUSH
87614: LD_INT 0
87616: PUSH
87617: EMPTY
87618: LIST
87619: LIST
87620: PUSH
87621: LD_INT 1
87623: NEG
87624: PUSH
87625: LD_INT 1
87627: NEG
87628: PUSH
87629: EMPTY
87630: LIST
87631: LIST
87632: PUSH
87633: LD_INT 1
87635: NEG
87636: PUSH
87637: LD_INT 2
87639: NEG
87640: PUSH
87641: EMPTY
87642: LIST
87643: LIST
87644: PUSH
87645: LD_INT 1
87647: PUSH
87648: LD_INT 1
87650: NEG
87651: PUSH
87652: EMPTY
87653: LIST
87654: LIST
87655: PUSH
87656: LD_INT 2
87658: PUSH
87659: LD_INT 0
87661: PUSH
87662: EMPTY
87663: LIST
87664: LIST
87665: PUSH
87666: LD_INT 2
87668: PUSH
87669: LD_INT 1
87671: PUSH
87672: EMPTY
87673: LIST
87674: LIST
87675: PUSH
87676: LD_INT 1
87678: PUSH
87679: LD_INT 2
87681: PUSH
87682: EMPTY
87683: LIST
87684: LIST
87685: PUSH
87686: LD_INT 0
87688: PUSH
87689: LD_INT 2
87691: PUSH
87692: EMPTY
87693: LIST
87694: LIST
87695: PUSH
87696: LD_INT 1
87698: NEG
87699: PUSH
87700: LD_INT 1
87702: PUSH
87703: EMPTY
87704: LIST
87705: LIST
87706: PUSH
87707: LD_INT 2
87709: NEG
87710: PUSH
87711: LD_INT 0
87713: PUSH
87714: EMPTY
87715: LIST
87716: LIST
87717: PUSH
87718: LD_INT 2
87720: NEG
87721: PUSH
87722: LD_INT 1
87724: NEG
87725: PUSH
87726: EMPTY
87727: LIST
87728: LIST
87729: PUSH
87730: LD_INT 2
87732: NEG
87733: PUSH
87734: LD_INT 2
87736: NEG
87737: PUSH
87738: EMPTY
87739: LIST
87740: LIST
87741: PUSH
87742: LD_INT 2
87744: NEG
87745: PUSH
87746: LD_INT 3
87748: NEG
87749: PUSH
87750: EMPTY
87751: LIST
87752: LIST
87753: PUSH
87754: LD_INT 2
87756: PUSH
87757: LD_INT 1
87759: NEG
87760: PUSH
87761: EMPTY
87762: LIST
87763: LIST
87764: PUSH
87765: LD_INT 3
87767: PUSH
87768: LD_INT 1
87770: PUSH
87771: EMPTY
87772: LIST
87773: LIST
87774: PUSH
87775: LD_INT 1
87777: PUSH
87778: LD_INT 3
87780: PUSH
87781: EMPTY
87782: LIST
87783: LIST
87784: PUSH
87785: LD_INT 1
87787: NEG
87788: PUSH
87789: LD_INT 2
87791: PUSH
87792: EMPTY
87793: LIST
87794: LIST
87795: PUSH
87796: LD_INT 3
87798: NEG
87799: PUSH
87800: LD_INT 2
87802: NEG
87803: PUSH
87804: EMPTY
87805: LIST
87806: LIST
87807: PUSH
87808: EMPTY
87809: LIST
87810: LIST
87811: LIST
87812: LIST
87813: LIST
87814: LIST
87815: LIST
87816: LIST
87817: LIST
87818: LIST
87819: LIST
87820: LIST
87821: LIST
87822: LIST
87823: LIST
87824: LIST
87825: LIST
87826: LIST
87827: LIST
87828: LIST
87829: LIST
87830: LIST
87831: LIST
87832: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
87833: LD_ADDR_VAR 0 34
87837: PUSH
87838: LD_INT 0
87840: PUSH
87841: LD_INT 0
87843: PUSH
87844: EMPTY
87845: LIST
87846: LIST
87847: PUSH
87848: LD_INT 0
87850: PUSH
87851: LD_INT 1
87853: NEG
87854: PUSH
87855: EMPTY
87856: LIST
87857: LIST
87858: PUSH
87859: LD_INT 1
87861: PUSH
87862: LD_INT 0
87864: PUSH
87865: EMPTY
87866: LIST
87867: LIST
87868: PUSH
87869: LD_INT 1
87871: PUSH
87872: LD_INT 1
87874: PUSH
87875: EMPTY
87876: LIST
87877: LIST
87878: PUSH
87879: LD_INT 0
87881: PUSH
87882: LD_INT 1
87884: PUSH
87885: EMPTY
87886: LIST
87887: LIST
87888: PUSH
87889: LD_INT 1
87891: NEG
87892: PUSH
87893: LD_INT 0
87895: PUSH
87896: EMPTY
87897: LIST
87898: LIST
87899: PUSH
87900: LD_INT 1
87902: NEG
87903: PUSH
87904: LD_INT 1
87906: NEG
87907: PUSH
87908: EMPTY
87909: LIST
87910: LIST
87911: PUSH
87912: LD_INT 1
87914: NEG
87915: PUSH
87916: LD_INT 2
87918: NEG
87919: PUSH
87920: EMPTY
87921: LIST
87922: LIST
87923: PUSH
87924: LD_INT 0
87926: PUSH
87927: LD_INT 2
87929: NEG
87930: PUSH
87931: EMPTY
87932: LIST
87933: LIST
87934: PUSH
87935: LD_INT 1
87937: PUSH
87938: LD_INT 1
87940: NEG
87941: PUSH
87942: EMPTY
87943: LIST
87944: LIST
87945: PUSH
87946: LD_INT 2
87948: PUSH
87949: LD_INT 1
87951: PUSH
87952: EMPTY
87953: LIST
87954: LIST
87955: PUSH
87956: LD_INT 2
87958: PUSH
87959: LD_INT 2
87961: PUSH
87962: EMPTY
87963: LIST
87964: LIST
87965: PUSH
87966: LD_INT 1
87968: PUSH
87969: LD_INT 2
87971: PUSH
87972: EMPTY
87973: LIST
87974: LIST
87975: PUSH
87976: LD_INT 1
87978: NEG
87979: PUSH
87980: LD_INT 1
87982: PUSH
87983: EMPTY
87984: LIST
87985: LIST
87986: PUSH
87987: LD_INT 2
87989: NEG
87990: PUSH
87991: LD_INT 0
87993: PUSH
87994: EMPTY
87995: LIST
87996: LIST
87997: PUSH
87998: LD_INT 2
88000: NEG
88001: PUSH
88002: LD_INT 1
88004: NEG
88005: PUSH
88006: EMPTY
88007: LIST
88008: LIST
88009: PUSH
88010: LD_INT 2
88012: NEG
88013: PUSH
88014: LD_INT 2
88016: NEG
88017: PUSH
88018: EMPTY
88019: LIST
88020: LIST
88021: PUSH
88022: LD_INT 1
88024: NEG
88025: PUSH
88026: LD_INT 3
88028: NEG
88029: PUSH
88030: EMPTY
88031: LIST
88032: LIST
88033: PUSH
88034: LD_INT 1
88036: PUSH
88037: LD_INT 2
88039: NEG
88040: PUSH
88041: EMPTY
88042: LIST
88043: LIST
88044: PUSH
88045: LD_INT 3
88047: PUSH
88048: LD_INT 2
88050: PUSH
88051: EMPTY
88052: LIST
88053: LIST
88054: PUSH
88055: LD_INT 2
88057: PUSH
88058: LD_INT 3
88060: PUSH
88061: EMPTY
88062: LIST
88063: LIST
88064: PUSH
88065: LD_INT 2
88067: NEG
88068: PUSH
88069: LD_INT 1
88071: PUSH
88072: EMPTY
88073: LIST
88074: LIST
88075: PUSH
88076: LD_INT 3
88078: NEG
88079: PUSH
88080: LD_INT 1
88082: NEG
88083: PUSH
88084: EMPTY
88085: LIST
88086: LIST
88087: PUSH
88088: EMPTY
88089: LIST
88090: LIST
88091: LIST
88092: LIST
88093: LIST
88094: LIST
88095: LIST
88096: LIST
88097: LIST
88098: LIST
88099: LIST
88100: LIST
88101: LIST
88102: LIST
88103: LIST
88104: LIST
88105: LIST
88106: LIST
88107: LIST
88108: LIST
88109: LIST
88110: LIST
88111: LIST
88112: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
88113: LD_ADDR_VAR 0 35
88117: PUSH
88118: LD_INT 0
88120: PUSH
88121: LD_INT 0
88123: PUSH
88124: EMPTY
88125: LIST
88126: LIST
88127: PUSH
88128: LD_INT 0
88130: PUSH
88131: LD_INT 1
88133: NEG
88134: PUSH
88135: EMPTY
88136: LIST
88137: LIST
88138: PUSH
88139: LD_INT 1
88141: PUSH
88142: LD_INT 0
88144: PUSH
88145: EMPTY
88146: LIST
88147: LIST
88148: PUSH
88149: LD_INT 1
88151: PUSH
88152: LD_INT 1
88154: PUSH
88155: EMPTY
88156: LIST
88157: LIST
88158: PUSH
88159: LD_INT 0
88161: PUSH
88162: LD_INT 1
88164: PUSH
88165: EMPTY
88166: LIST
88167: LIST
88168: PUSH
88169: LD_INT 1
88171: NEG
88172: PUSH
88173: LD_INT 0
88175: PUSH
88176: EMPTY
88177: LIST
88178: LIST
88179: PUSH
88180: LD_INT 1
88182: NEG
88183: PUSH
88184: LD_INT 1
88186: NEG
88187: PUSH
88188: EMPTY
88189: LIST
88190: LIST
88191: PUSH
88192: LD_INT 2
88194: PUSH
88195: LD_INT 1
88197: PUSH
88198: EMPTY
88199: LIST
88200: LIST
88201: PUSH
88202: LD_INT 2
88204: NEG
88205: PUSH
88206: LD_INT 1
88208: NEG
88209: PUSH
88210: EMPTY
88211: LIST
88212: LIST
88213: PUSH
88214: EMPTY
88215: LIST
88216: LIST
88217: LIST
88218: LIST
88219: LIST
88220: LIST
88221: LIST
88222: LIST
88223: LIST
88224: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
88225: LD_ADDR_VAR 0 36
88229: PUSH
88230: LD_INT 0
88232: PUSH
88233: LD_INT 0
88235: PUSH
88236: EMPTY
88237: LIST
88238: LIST
88239: PUSH
88240: LD_INT 0
88242: PUSH
88243: LD_INT 1
88245: NEG
88246: PUSH
88247: EMPTY
88248: LIST
88249: LIST
88250: PUSH
88251: LD_INT 1
88253: PUSH
88254: LD_INT 0
88256: PUSH
88257: EMPTY
88258: LIST
88259: LIST
88260: PUSH
88261: LD_INT 1
88263: PUSH
88264: LD_INT 1
88266: PUSH
88267: EMPTY
88268: LIST
88269: LIST
88270: PUSH
88271: LD_INT 0
88273: PUSH
88274: LD_INT 1
88276: PUSH
88277: EMPTY
88278: LIST
88279: LIST
88280: PUSH
88281: LD_INT 1
88283: NEG
88284: PUSH
88285: LD_INT 0
88287: PUSH
88288: EMPTY
88289: LIST
88290: LIST
88291: PUSH
88292: LD_INT 1
88294: NEG
88295: PUSH
88296: LD_INT 1
88298: NEG
88299: PUSH
88300: EMPTY
88301: LIST
88302: LIST
88303: PUSH
88304: LD_INT 1
88306: NEG
88307: PUSH
88308: LD_INT 2
88310: NEG
88311: PUSH
88312: EMPTY
88313: LIST
88314: LIST
88315: PUSH
88316: LD_INT 1
88318: PUSH
88319: LD_INT 2
88321: PUSH
88322: EMPTY
88323: LIST
88324: LIST
88325: PUSH
88326: EMPTY
88327: LIST
88328: LIST
88329: LIST
88330: LIST
88331: LIST
88332: LIST
88333: LIST
88334: LIST
88335: LIST
88336: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
88337: LD_ADDR_VAR 0 37
88341: PUSH
88342: LD_INT 0
88344: PUSH
88345: LD_INT 0
88347: PUSH
88348: EMPTY
88349: LIST
88350: LIST
88351: PUSH
88352: LD_INT 0
88354: PUSH
88355: LD_INT 1
88357: NEG
88358: PUSH
88359: EMPTY
88360: LIST
88361: LIST
88362: PUSH
88363: LD_INT 1
88365: PUSH
88366: LD_INT 0
88368: PUSH
88369: EMPTY
88370: LIST
88371: LIST
88372: PUSH
88373: LD_INT 1
88375: PUSH
88376: LD_INT 1
88378: PUSH
88379: EMPTY
88380: LIST
88381: LIST
88382: PUSH
88383: LD_INT 0
88385: PUSH
88386: LD_INT 1
88388: PUSH
88389: EMPTY
88390: LIST
88391: LIST
88392: PUSH
88393: LD_INT 1
88395: NEG
88396: PUSH
88397: LD_INT 0
88399: PUSH
88400: EMPTY
88401: LIST
88402: LIST
88403: PUSH
88404: LD_INT 1
88406: NEG
88407: PUSH
88408: LD_INT 1
88410: NEG
88411: PUSH
88412: EMPTY
88413: LIST
88414: LIST
88415: PUSH
88416: LD_INT 1
88418: PUSH
88419: LD_INT 1
88421: NEG
88422: PUSH
88423: EMPTY
88424: LIST
88425: LIST
88426: PUSH
88427: LD_INT 1
88429: NEG
88430: PUSH
88431: LD_INT 1
88433: PUSH
88434: EMPTY
88435: LIST
88436: LIST
88437: PUSH
88438: EMPTY
88439: LIST
88440: LIST
88441: LIST
88442: LIST
88443: LIST
88444: LIST
88445: LIST
88446: LIST
88447: LIST
88448: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
88449: LD_ADDR_VAR 0 38
88453: PUSH
88454: LD_INT 0
88456: PUSH
88457: LD_INT 0
88459: PUSH
88460: EMPTY
88461: LIST
88462: LIST
88463: PUSH
88464: LD_INT 0
88466: PUSH
88467: LD_INT 1
88469: NEG
88470: PUSH
88471: EMPTY
88472: LIST
88473: LIST
88474: PUSH
88475: LD_INT 1
88477: PUSH
88478: LD_INT 0
88480: PUSH
88481: EMPTY
88482: LIST
88483: LIST
88484: PUSH
88485: LD_INT 1
88487: PUSH
88488: LD_INT 1
88490: PUSH
88491: EMPTY
88492: LIST
88493: LIST
88494: PUSH
88495: LD_INT 0
88497: PUSH
88498: LD_INT 1
88500: PUSH
88501: EMPTY
88502: LIST
88503: LIST
88504: PUSH
88505: LD_INT 1
88507: NEG
88508: PUSH
88509: LD_INT 0
88511: PUSH
88512: EMPTY
88513: LIST
88514: LIST
88515: PUSH
88516: LD_INT 1
88518: NEG
88519: PUSH
88520: LD_INT 1
88522: NEG
88523: PUSH
88524: EMPTY
88525: LIST
88526: LIST
88527: PUSH
88528: LD_INT 2
88530: PUSH
88531: LD_INT 1
88533: PUSH
88534: EMPTY
88535: LIST
88536: LIST
88537: PUSH
88538: LD_INT 2
88540: NEG
88541: PUSH
88542: LD_INT 1
88544: NEG
88545: PUSH
88546: EMPTY
88547: LIST
88548: LIST
88549: PUSH
88550: EMPTY
88551: LIST
88552: LIST
88553: LIST
88554: LIST
88555: LIST
88556: LIST
88557: LIST
88558: LIST
88559: LIST
88560: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
88561: LD_ADDR_VAR 0 39
88565: PUSH
88566: LD_INT 0
88568: PUSH
88569: LD_INT 0
88571: PUSH
88572: EMPTY
88573: LIST
88574: LIST
88575: PUSH
88576: LD_INT 0
88578: PUSH
88579: LD_INT 1
88581: NEG
88582: PUSH
88583: EMPTY
88584: LIST
88585: LIST
88586: PUSH
88587: LD_INT 1
88589: PUSH
88590: LD_INT 0
88592: PUSH
88593: EMPTY
88594: LIST
88595: LIST
88596: PUSH
88597: LD_INT 1
88599: PUSH
88600: LD_INT 1
88602: PUSH
88603: EMPTY
88604: LIST
88605: LIST
88606: PUSH
88607: LD_INT 0
88609: PUSH
88610: LD_INT 1
88612: PUSH
88613: EMPTY
88614: LIST
88615: LIST
88616: PUSH
88617: LD_INT 1
88619: NEG
88620: PUSH
88621: LD_INT 0
88623: PUSH
88624: EMPTY
88625: LIST
88626: LIST
88627: PUSH
88628: LD_INT 1
88630: NEG
88631: PUSH
88632: LD_INT 1
88634: NEG
88635: PUSH
88636: EMPTY
88637: LIST
88638: LIST
88639: PUSH
88640: LD_INT 1
88642: NEG
88643: PUSH
88644: LD_INT 2
88646: NEG
88647: PUSH
88648: EMPTY
88649: LIST
88650: LIST
88651: PUSH
88652: LD_INT 1
88654: PUSH
88655: LD_INT 2
88657: PUSH
88658: EMPTY
88659: LIST
88660: LIST
88661: PUSH
88662: EMPTY
88663: LIST
88664: LIST
88665: LIST
88666: LIST
88667: LIST
88668: LIST
88669: LIST
88670: LIST
88671: LIST
88672: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
88673: LD_ADDR_VAR 0 40
88677: PUSH
88678: LD_INT 0
88680: PUSH
88681: LD_INT 0
88683: PUSH
88684: EMPTY
88685: LIST
88686: LIST
88687: PUSH
88688: LD_INT 0
88690: PUSH
88691: LD_INT 1
88693: NEG
88694: PUSH
88695: EMPTY
88696: LIST
88697: LIST
88698: PUSH
88699: LD_INT 1
88701: PUSH
88702: LD_INT 0
88704: PUSH
88705: EMPTY
88706: LIST
88707: LIST
88708: PUSH
88709: LD_INT 1
88711: PUSH
88712: LD_INT 1
88714: PUSH
88715: EMPTY
88716: LIST
88717: LIST
88718: PUSH
88719: LD_INT 0
88721: PUSH
88722: LD_INT 1
88724: PUSH
88725: EMPTY
88726: LIST
88727: LIST
88728: PUSH
88729: LD_INT 1
88731: NEG
88732: PUSH
88733: LD_INT 0
88735: PUSH
88736: EMPTY
88737: LIST
88738: LIST
88739: PUSH
88740: LD_INT 1
88742: NEG
88743: PUSH
88744: LD_INT 1
88746: NEG
88747: PUSH
88748: EMPTY
88749: LIST
88750: LIST
88751: PUSH
88752: LD_INT 1
88754: PUSH
88755: LD_INT 1
88757: NEG
88758: PUSH
88759: EMPTY
88760: LIST
88761: LIST
88762: PUSH
88763: LD_INT 1
88765: NEG
88766: PUSH
88767: LD_INT 1
88769: PUSH
88770: EMPTY
88771: LIST
88772: LIST
88773: PUSH
88774: EMPTY
88775: LIST
88776: LIST
88777: LIST
88778: LIST
88779: LIST
88780: LIST
88781: LIST
88782: LIST
88783: LIST
88784: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88785: LD_ADDR_VAR 0 41
88789: PUSH
88790: LD_INT 0
88792: PUSH
88793: LD_INT 0
88795: PUSH
88796: EMPTY
88797: LIST
88798: LIST
88799: PUSH
88800: LD_INT 0
88802: PUSH
88803: LD_INT 1
88805: NEG
88806: PUSH
88807: EMPTY
88808: LIST
88809: LIST
88810: PUSH
88811: LD_INT 1
88813: PUSH
88814: LD_INT 0
88816: PUSH
88817: EMPTY
88818: LIST
88819: LIST
88820: PUSH
88821: LD_INT 1
88823: PUSH
88824: LD_INT 1
88826: PUSH
88827: EMPTY
88828: LIST
88829: LIST
88830: PUSH
88831: LD_INT 0
88833: PUSH
88834: LD_INT 1
88836: PUSH
88837: EMPTY
88838: LIST
88839: LIST
88840: PUSH
88841: LD_INT 1
88843: NEG
88844: PUSH
88845: LD_INT 0
88847: PUSH
88848: EMPTY
88849: LIST
88850: LIST
88851: PUSH
88852: LD_INT 1
88854: NEG
88855: PUSH
88856: LD_INT 1
88858: NEG
88859: PUSH
88860: EMPTY
88861: LIST
88862: LIST
88863: PUSH
88864: LD_INT 1
88866: NEG
88867: PUSH
88868: LD_INT 2
88870: NEG
88871: PUSH
88872: EMPTY
88873: LIST
88874: LIST
88875: PUSH
88876: LD_INT 1
88878: PUSH
88879: LD_INT 1
88881: NEG
88882: PUSH
88883: EMPTY
88884: LIST
88885: LIST
88886: PUSH
88887: LD_INT 2
88889: PUSH
88890: LD_INT 0
88892: PUSH
88893: EMPTY
88894: LIST
88895: LIST
88896: PUSH
88897: LD_INT 2
88899: PUSH
88900: LD_INT 1
88902: PUSH
88903: EMPTY
88904: LIST
88905: LIST
88906: PUSH
88907: LD_INT 2
88909: PUSH
88910: LD_INT 2
88912: PUSH
88913: EMPTY
88914: LIST
88915: LIST
88916: PUSH
88917: LD_INT 1
88919: PUSH
88920: LD_INT 2
88922: PUSH
88923: EMPTY
88924: LIST
88925: LIST
88926: PUSH
88927: LD_INT 1
88929: NEG
88930: PUSH
88931: LD_INT 1
88933: PUSH
88934: EMPTY
88935: LIST
88936: LIST
88937: PUSH
88938: LD_INT 2
88940: NEG
88941: PUSH
88942: LD_INT 0
88944: PUSH
88945: EMPTY
88946: LIST
88947: LIST
88948: PUSH
88949: LD_INT 2
88951: NEG
88952: PUSH
88953: LD_INT 1
88955: NEG
88956: PUSH
88957: EMPTY
88958: LIST
88959: LIST
88960: PUSH
88961: LD_INT 2
88963: NEG
88964: PUSH
88965: LD_INT 2
88967: NEG
88968: PUSH
88969: EMPTY
88970: LIST
88971: LIST
88972: PUSH
88973: LD_INT 2
88975: NEG
88976: PUSH
88977: LD_INT 3
88979: NEG
88980: PUSH
88981: EMPTY
88982: LIST
88983: LIST
88984: PUSH
88985: LD_INT 2
88987: PUSH
88988: LD_INT 1
88990: NEG
88991: PUSH
88992: EMPTY
88993: LIST
88994: LIST
88995: PUSH
88996: LD_INT 3
88998: PUSH
88999: LD_INT 0
89001: PUSH
89002: EMPTY
89003: LIST
89004: LIST
89005: PUSH
89006: LD_INT 3
89008: PUSH
89009: LD_INT 1
89011: PUSH
89012: EMPTY
89013: LIST
89014: LIST
89015: PUSH
89016: LD_INT 3
89018: PUSH
89019: LD_INT 2
89021: PUSH
89022: EMPTY
89023: LIST
89024: LIST
89025: PUSH
89026: LD_INT 3
89028: PUSH
89029: LD_INT 3
89031: PUSH
89032: EMPTY
89033: LIST
89034: LIST
89035: PUSH
89036: LD_INT 2
89038: PUSH
89039: LD_INT 3
89041: PUSH
89042: EMPTY
89043: LIST
89044: LIST
89045: PUSH
89046: LD_INT 2
89048: NEG
89049: PUSH
89050: LD_INT 1
89052: PUSH
89053: EMPTY
89054: LIST
89055: LIST
89056: PUSH
89057: LD_INT 3
89059: NEG
89060: PUSH
89061: LD_INT 0
89063: PUSH
89064: EMPTY
89065: LIST
89066: LIST
89067: PUSH
89068: LD_INT 3
89070: NEG
89071: PUSH
89072: LD_INT 1
89074: NEG
89075: PUSH
89076: EMPTY
89077: LIST
89078: LIST
89079: PUSH
89080: LD_INT 3
89082: NEG
89083: PUSH
89084: LD_INT 2
89086: NEG
89087: PUSH
89088: EMPTY
89089: LIST
89090: LIST
89091: PUSH
89092: LD_INT 3
89094: NEG
89095: PUSH
89096: LD_INT 3
89098: NEG
89099: PUSH
89100: EMPTY
89101: LIST
89102: LIST
89103: PUSH
89104: EMPTY
89105: LIST
89106: LIST
89107: LIST
89108: LIST
89109: LIST
89110: LIST
89111: LIST
89112: LIST
89113: LIST
89114: LIST
89115: LIST
89116: LIST
89117: LIST
89118: LIST
89119: LIST
89120: LIST
89121: LIST
89122: LIST
89123: LIST
89124: LIST
89125: LIST
89126: LIST
89127: LIST
89128: LIST
89129: LIST
89130: LIST
89131: LIST
89132: LIST
89133: LIST
89134: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89135: LD_ADDR_VAR 0 42
89139: PUSH
89140: LD_INT 0
89142: PUSH
89143: LD_INT 0
89145: PUSH
89146: EMPTY
89147: LIST
89148: LIST
89149: PUSH
89150: LD_INT 0
89152: PUSH
89153: LD_INT 1
89155: NEG
89156: PUSH
89157: EMPTY
89158: LIST
89159: LIST
89160: PUSH
89161: LD_INT 1
89163: PUSH
89164: LD_INT 0
89166: PUSH
89167: EMPTY
89168: LIST
89169: LIST
89170: PUSH
89171: LD_INT 1
89173: PUSH
89174: LD_INT 1
89176: PUSH
89177: EMPTY
89178: LIST
89179: LIST
89180: PUSH
89181: LD_INT 0
89183: PUSH
89184: LD_INT 1
89186: PUSH
89187: EMPTY
89188: LIST
89189: LIST
89190: PUSH
89191: LD_INT 1
89193: NEG
89194: PUSH
89195: LD_INT 0
89197: PUSH
89198: EMPTY
89199: LIST
89200: LIST
89201: PUSH
89202: LD_INT 1
89204: NEG
89205: PUSH
89206: LD_INT 1
89208: NEG
89209: PUSH
89210: EMPTY
89211: LIST
89212: LIST
89213: PUSH
89214: LD_INT 1
89216: NEG
89217: PUSH
89218: LD_INT 2
89220: NEG
89221: PUSH
89222: EMPTY
89223: LIST
89224: LIST
89225: PUSH
89226: LD_INT 0
89228: PUSH
89229: LD_INT 2
89231: NEG
89232: PUSH
89233: EMPTY
89234: LIST
89235: LIST
89236: PUSH
89237: LD_INT 1
89239: PUSH
89240: LD_INT 1
89242: NEG
89243: PUSH
89244: EMPTY
89245: LIST
89246: LIST
89247: PUSH
89248: LD_INT 2
89250: PUSH
89251: LD_INT 1
89253: PUSH
89254: EMPTY
89255: LIST
89256: LIST
89257: PUSH
89258: LD_INT 2
89260: PUSH
89261: LD_INT 2
89263: PUSH
89264: EMPTY
89265: LIST
89266: LIST
89267: PUSH
89268: LD_INT 1
89270: PUSH
89271: LD_INT 2
89273: PUSH
89274: EMPTY
89275: LIST
89276: LIST
89277: PUSH
89278: LD_INT 0
89280: PUSH
89281: LD_INT 2
89283: PUSH
89284: EMPTY
89285: LIST
89286: LIST
89287: PUSH
89288: LD_INT 1
89290: NEG
89291: PUSH
89292: LD_INT 1
89294: PUSH
89295: EMPTY
89296: LIST
89297: LIST
89298: PUSH
89299: LD_INT 2
89301: NEG
89302: PUSH
89303: LD_INT 1
89305: NEG
89306: PUSH
89307: EMPTY
89308: LIST
89309: LIST
89310: PUSH
89311: LD_INT 2
89313: NEG
89314: PUSH
89315: LD_INT 2
89317: NEG
89318: PUSH
89319: EMPTY
89320: LIST
89321: LIST
89322: PUSH
89323: LD_INT 2
89325: NEG
89326: PUSH
89327: LD_INT 3
89329: NEG
89330: PUSH
89331: EMPTY
89332: LIST
89333: LIST
89334: PUSH
89335: LD_INT 1
89337: NEG
89338: PUSH
89339: LD_INT 3
89341: NEG
89342: PUSH
89343: EMPTY
89344: LIST
89345: LIST
89346: PUSH
89347: LD_INT 0
89349: PUSH
89350: LD_INT 3
89352: NEG
89353: PUSH
89354: EMPTY
89355: LIST
89356: LIST
89357: PUSH
89358: LD_INT 1
89360: PUSH
89361: LD_INT 2
89363: NEG
89364: PUSH
89365: EMPTY
89366: LIST
89367: LIST
89368: PUSH
89369: LD_INT 3
89371: PUSH
89372: LD_INT 2
89374: PUSH
89375: EMPTY
89376: LIST
89377: LIST
89378: PUSH
89379: LD_INT 3
89381: PUSH
89382: LD_INT 3
89384: PUSH
89385: EMPTY
89386: LIST
89387: LIST
89388: PUSH
89389: LD_INT 2
89391: PUSH
89392: LD_INT 3
89394: PUSH
89395: EMPTY
89396: LIST
89397: LIST
89398: PUSH
89399: LD_INT 1
89401: PUSH
89402: LD_INT 3
89404: PUSH
89405: EMPTY
89406: LIST
89407: LIST
89408: PUSH
89409: LD_INT 0
89411: PUSH
89412: LD_INT 3
89414: PUSH
89415: EMPTY
89416: LIST
89417: LIST
89418: PUSH
89419: LD_INT 1
89421: NEG
89422: PUSH
89423: LD_INT 2
89425: PUSH
89426: EMPTY
89427: LIST
89428: LIST
89429: PUSH
89430: LD_INT 3
89432: NEG
89433: PUSH
89434: LD_INT 2
89436: NEG
89437: PUSH
89438: EMPTY
89439: LIST
89440: LIST
89441: PUSH
89442: LD_INT 3
89444: NEG
89445: PUSH
89446: LD_INT 3
89448: NEG
89449: PUSH
89450: EMPTY
89451: LIST
89452: LIST
89453: PUSH
89454: EMPTY
89455: LIST
89456: LIST
89457: LIST
89458: LIST
89459: LIST
89460: LIST
89461: LIST
89462: LIST
89463: LIST
89464: LIST
89465: LIST
89466: LIST
89467: LIST
89468: LIST
89469: LIST
89470: LIST
89471: LIST
89472: LIST
89473: LIST
89474: LIST
89475: LIST
89476: LIST
89477: LIST
89478: LIST
89479: LIST
89480: LIST
89481: LIST
89482: LIST
89483: LIST
89484: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89485: LD_ADDR_VAR 0 43
89489: PUSH
89490: LD_INT 0
89492: PUSH
89493: LD_INT 0
89495: PUSH
89496: EMPTY
89497: LIST
89498: LIST
89499: PUSH
89500: LD_INT 0
89502: PUSH
89503: LD_INT 1
89505: NEG
89506: PUSH
89507: EMPTY
89508: LIST
89509: LIST
89510: PUSH
89511: LD_INT 1
89513: PUSH
89514: LD_INT 0
89516: PUSH
89517: EMPTY
89518: LIST
89519: LIST
89520: PUSH
89521: LD_INT 1
89523: PUSH
89524: LD_INT 1
89526: PUSH
89527: EMPTY
89528: LIST
89529: LIST
89530: PUSH
89531: LD_INT 0
89533: PUSH
89534: LD_INT 1
89536: PUSH
89537: EMPTY
89538: LIST
89539: LIST
89540: PUSH
89541: LD_INT 1
89543: NEG
89544: PUSH
89545: LD_INT 0
89547: PUSH
89548: EMPTY
89549: LIST
89550: LIST
89551: PUSH
89552: LD_INT 1
89554: NEG
89555: PUSH
89556: LD_INT 1
89558: NEG
89559: PUSH
89560: EMPTY
89561: LIST
89562: LIST
89563: PUSH
89564: LD_INT 1
89566: NEG
89567: PUSH
89568: LD_INT 2
89570: NEG
89571: PUSH
89572: EMPTY
89573: LIST
89574: LIST
89575: PUSH
89576: LD_INT 0
89578: PUSH
89579: LD_INT 2
89581: NEG
89582: PUSH
89583: EMPTY
89584: LIST
89585: LIST
89586: PUSH
89587: LD_INT 1
89589: PUSH
89590: LD_INT 1
89592: NEG
89593: PUSH
89594: EMPTY
89595: LIST
89596: LIST
89597: PUSH
89598: LD_INT 2
89600: PUSH
89601: LD_INT 0
89603: PUSH
89604: EMPTY
89605: LIST
89606: LIST
89607: PUSH
89608: LD_INT 2
89610: PUSH
89611: LD_INT 1
89613: PUSH
89614: EMPTY
89615: LIST
89616: LIST
89617: PUSH
89618: LD_INT 1
89620: PUSH
89621: LD_INT 2
89623: PUSH
89624: EMPTY
89625: LIST
89626: LIST
89627: PUSH
89628: LD_INT 0
89630: PUSH
89631: LD_INT 2
89633: PUSH
89634: EMPTY
89635: LIST
89636: LIST
89637: PUSH
89638: LD_INT 1
89640: NEG
89641: PUSH
89642: LD_INT 1
89644: PUSH
89645: EMPTY
89646: LIST
89647: LIST
89648: PUSH
89649: LD_INT 2
89651: NEG
89652: PUSH
89653: LD_INT 0
89655: PUSH
89656: EMPTY
89657: LIST
89658: LIST
89659: PUSH
89660: LD_INT 2
89662: NEG
89663: PUSH
89664: LD_INT 1
89666: NEG
89667: PUSH
89668: EMPTY
89669: LIST
89670: LIST
89671: PUSH
89672: LD_INT 1
89674: NEG
89675: PUSH
89676: LD_INT 3
89678: NEG
89679: PUSH
89680: EMPTY
89681: LIST
89682: LIST
89683: PUSH
89684: LD_INT 0
89686: PUSH
89687: LD_INT 3
89689: NEG
89690: PUSH
89691: EMPTY
89692: LIST
89693: LIST
89694: PUSH
89695: LD_INT 1
89697: PUSH
89698: LD_INT 2
89700: NEG
89701: PUSH
89702: EMPTY
89703: LIST
89704: LIST
89705: PUSH
89706: LD_INT 2
89708: PUSH
89709: LD_INT 1
89711: NEG
89712: PUSH
89713: EMPTY
89714: LIST
89715: LIST
89716: PUSH
89717: LD_INT 3
89719: PUSH
89720: LD_INT 0
89722: PUSH
89723: EMPTY
89724: LIST
89725: LIST
89726: PUSH
89727: LD_INT 3
89729: PUSH
89730: LD_INT 1
89732: PUSH
89733: EMPTY
89734: LIST
89735: LIST
89736: PUSH
89737: LD_INT 1
89739: PUSH
89740: LD_INT 3
89742: PUSH
89743: EMPTY
89744: LIST
89745: LIST
89746: PUSH
89747: LD_INT 0
89749: PUSH
89750: LD_INT 3
89752: PUSH
89753: EMPTY
89754: LIST
89755: LIST
89756: PUSH
89757: LD_INT 1
89759: NEG
89760: PUSH
89761: LD_INT 2
89763: PUSH
89764: EMPTY
89765: LIST
89766: LIST
89767: PUSH
89768: LD_INT 2
89770: NEG
89771: PUSH
89772: LD_INT 1
89774: PUSH
89775: EMPTY
89776: LIST
89777: LIST
89778: PUSH
89779: LD_INT 3
89781: NEG
89782: PUSH
89783: LD_INT 0
89785: PUSH
89786: EMPTY
89787: LIST
89788: LIST
89789: PUSH
89790: LD_INT 3
89792: NEG
89793: PUSH
89794: LD_INT 1
89796: NEG
89797: PUSH
89798: EMPTY
89799: LIST
89800: LIST
89801: PUSH
89802: EMPTY
89803: LIST
89804: LIST
89805: LIST
89806: LIST
89807: LIST
89808: LIST
89809: LIST
89810: LIST
89811: LIST
89812: LIST
89813: LIST
89814: LIST
89815: LIST
89816: LIST
89817: LIST
89818: LIST
89819: LIST
89820: LIST
89821: LIST
89822: LIST
89823: LIST
89824: LIST
89825: LIST
89826: LIST
89827: LIST
89828: LIST
89829: LIST
89830: LIST
89831: LIST
89832: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89833: LD_ADDR_VAR 0 44
89837: PUSH
89838: LD_INT 0
89840: PUSH
89841: LD_INT 0
89843: PUSH
89844: EMPTY
89845: LIST
89846: LIST
89847: PUSH
89848: LD_INT 0
89850: PUSH
89851: LD_INT 1
89853: NEG
89854: PUSH
89855: EMPTY
89856: LIST
89857: LIST
89858: PUSH
89859: LD_INT 1
89861: PUSH
89862: LD_INT 0
89864: PUSH
89865: EMPTY
89866: LIST
89867: LIST
89868: PUSH
89869: LD_INT 1
89871: PUSH
89872: LD_INT 1
89874: PUSH
89875: EMPTY
89876: LIST
89877: LIST
89878: PUSH
89879: LD_INT 0
89881: PUSH
89882: LD_INT 1
89884: PUSH
89885: EMPTY
89886: LIST
89887: LIST
89888: PUSH
89889: LD_INT 1
89891: NEG
89892: PUSH
89893: LD_INT 0
89895: PUSH
89896: EMPTY
89897: LIST
89898: LIST
89899: PUSH
89900: LD_INT 1
89902: NEG
89903: PUSH
89904: LD_INT 1
89906: NEG
89907: PUSH
89908: EMPTY
89909: LIST
89910: LIST
89911: PUSH
89912: LD_INT 1
89914: NEG
89915: PUSH
89916: LD_INT 2
89918: NEG
89919: PUSH
89920: EMPTY
89921: LIST
89922: LIST
89923: PUSH
89924: LD_INT 1
89926: PUSH
89927: LD_INT 1
89929: NEG
89930: PUSH
89931: EMPTY
89932: LIST
89933: LIST
89934: PUSH
89935: LD_INT 2
89937: PUSH
89938: LD_INT 0
89940: PUSH
89941: EMPTY
89942: LIST
89943: LIST
89944: PUSH
89945: LD_INT 2
89947: PUSH
89948: LD_INT 1
89950: PUSH
89951: EMPTY
89952: LIST
89953: LIST
89954: PUSH
89955: LD_INT 2
89957: PUSH
89958: LD_INT 2
89960: PUSH
89961: EMPTY
89962: LIST
89963: LIST
89964: PUSH
89965: LD_INT 1
89967: PUSH
89968: LD_INT 2
89970: PUSH
89971: EMPTY
89972: LIST
89973: LIST
89974: PUSH
89975: LD_INT 1
89977: NEG
89978: PUSH
89979: LD_INT 1
89981: PUSH
89982: EMPTY
89983: LIST
89984: LIST
89985: PUSH
89986: LD_INT 2
89988: NEG
89989: PUSH
89990: LD_INT 0
89992: PUSH
89993: EMPTY
89994: LIST
89995: LIST
89996: PUSH
89997: LD_INT 2
89999: NEG
90000: PUSH
90001: LD_INT 1
90003: NEG
90004: PUSH
90005: EMPTY
90006: LIST
90007: LIST
90008: PUSH
90009: LD_INT 2
90011: NEG
90012: PUSH
90013: LD_INT 2
90015: NEG
90016: PUSH
90017: EMPTY
90018: LIST
90019: LIST
90020: PUSH
90021: LD_INT 2
90023: NEG
90024: PUSH
90025: LD_INT 3
90027: NEG
90028: PUSH
90029: EMPTY
90030: LIST
90031: LIST
90032: PUSH
90033: LD_INT 2
90035: PUSH
90036: LD_INT 1
90038: NEG
90039: PUSH
90040: EMPTY
90041: LIST
90042: LIST
90043: PUSH
90044: LD_INT 3
90046: PUSH
90047: LD_INT 0
90049: PUSH
90050: EMPTY
90051: LIST
90052: LIST
90053: PUSH
90054: LD_INT 3
90056: PUSH
90057: LD_INT 1
90059: PUSH
90060: EMPTY
90061: LIST
90062: LIST
90063: PUSH
90064: LD_INT 3
90066: PUSH
90067: LD_INT 2
90069: PUSH
90070: EMPTY
90071: LIST
90072: LIST
90073: PUSH
90074: LD_INT 3
90076: PUSH
90077: LD_INT 3
90079: PUSH
90080: EMPTY
90081: LIST
90082: LIST
90083: PUSH
90084: LD_INT 2
90086: PUSH
90087: LD_INT 3
90089: PUSH
90090: EMPTY
90091: LIST
90092: LIST
90093: PUSH
90094: LD_INT 2
90096: NEG
90097: PUSH
90098: LD_INT 1
90100: PUSH
90101: EMPTY
90102: LIST
90103: LIST
90104: PUSH
90105: LD_INT 3
90107: NEG
90108: PUSH
90109: LD_INT 0
90111: PUSH
90112: EMPTY
90113: LIST
90114: LIST
90115: PUSH
90116: LD_INT 3
90118: NEG
90119: PUSH
90120: LD_INT 1
90122: NEG
90123: PUSH
90124: EMPTY
90125: LIST
90126: LIST
90127: PUSH
90128: LD_INT 3
90130: NEG
90131: PUSH
90132: LD_INT 2
90134: NEG
90135: PUSH
90136: EMPTY
90137: LIST
90138: LIST
90139: PUSH
90140: LD_INT 3
90142: NEG
90143: PUSH
90144: LD_INT 3
90146: NEG
90147: PUSH
90148: EMPTY
90149: LIST
90150: LIST
90151: PUSH
90152: EMPTY
90153: LIST
90154: LIST
90155: LIST
90156: LIST
90157: LIST
90158: LIST
90159: LIST
90160: LIST
90161: LIST
90162: LIST
90163: LIST
90164: LIST
90165: LIST
90166: LIST
90167: LIST
90168: LIST
90169: LIST
90170: LIST
90171: LIST
90172: LIST
90173: LIST
90174: LIST
90175: LIST
90176: LIST
90177: LIST
90178: LIST
90179: LIST
90180: LIST
90181: LIST
90182: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90183: LD_ADDR_VAR 0 45
90187: PUSH
90188: LD_INT 0
90190: PUSH
90191: LD_INT 0
90193: PUSH
90194: EMPTY
90195: LIST
90196: LIST
90197: PUSH
90198: LD_INT 0
90200: PUSH
90201: LD_INT 1
90203: NEG
90204: PUSH
90205: EMPTY
90206: LIST
90207: LIST
90208: PUSH
90209: LD_INT 1
90211: PUSH
90212: LD_INT 0
90214: PUSH
90215: EMPTY
90216: LIST
90217: LIST
90218: PUSH
90219: LD_INT 1
90221: PUSH
90222: LD_INT 1
90224: PUSH
90225: EMPTY
90226: LIST
90227: LIST
90228: PUSH
90229: LD_INT 0
90231: PUSH
90232: LD_INT 1
90234: PUSH
90235: EMPTY
90236: LIST
90237: LIST
90238: PUSH
90239: LD_INT 1
90241: NEG
90242: PUSH
90243: LD_INT 0
90245: PUSH
90246: EMPTY
90247: LIST
90248: LIST
90249: PUSH
90250: LD_INT 1
90252: NEG
90253: PUSH
90254: LD_INT 1
90256: NEG
90257: PUSH
90258: EMPTY
90259: LIST
90260: LIST
90261: PUSH
90262: LD_INT 1
90264: NEG
90265: PUSH
90266: LD_INT 2
90268: NEG
90269: PUSH
90270: EMPTY
90271: LIST
90272: LIST
90273: PUSH
90274: LD_INT 0
90276: PUSH
90277: LD_INT 2
90279: NEG
90280: PUSH
90281: EMPTY
90282: LIST
90283: LIST
90284: PUSH
90285: LD_INT 1
90287: PUSH
90288: LD_INT 1
90290: NEG
90291: PUSH
90292: EMPTY
90293: LIST
90294: LIST
90295: PUSH
90296: LD_INT 2
90298: PUSH
90299: LD_INT 1
90301: PUSH
90302: EMPTY
90303: LIST
90304: LIST
90305: PUSH
90306: LD_INT 2
90308: PUSH
90309: LD_INT 2
90311: PUSH
90312: EMPTY
90313: LIST
90314: LIST
90315: PUSH
90316: LD_INT 1
90318: PUSH
90319: LD_INT 2
90321: PUSH
90322: EMPTY
90323: LIST
90324: LIST
90325: PUSH
90326: LD_INT 0
90328: PUSH
90329: LD_INT 2
90331: PUSH
90332: EMPTY
90333: LIST
90334: LIST
90335: PUSH
90336: LD_INT 1
90338: NEG
90339: PUSH
90340: LD_INT 1
90342: PUSH
90343: EMPTY
90344: LIST
90345: LIST
90346: PUSH
90347: LD_INT 2
90349: NEG
90350: PUSH
90351: LD_INT 1
90353: NEG
90354: PUSH
90355: EMPTY
90356: LIST
90357: LIST
90358: PUSH
90359: LD_INT 2
90361: NEG
90362: PUSH
90363: LD_INT 2
90365: NEG
90366: PUSH
90367: EMPTY
90368: LIST
90369: LIST
90370: PUSH
90371: LD_INT 2
90373: NEG
90374: PUSH
90375: LD_INT 3
90377: NEG
90378: PUSH
90379: EMPTY
90380: LIST
90381: LIST
90382: PUSH
90383: LD_INT 1
90385: NEG
90386: PUSH
90387: LD_INT 3
90389: NEG
90390: PUSH
90391: EMPTY
90392: LIST
90393: LIST
90394: PUSH
90395: LD_INT 0
90397: PUSH
90398: LD_INT 3
90400: NEG
90401: PUSH
90402: EMPTY
90403: LIST
90404: LIST
90405: PUSH
90406: LD_INT 1
90408: PUSH
90409: LD_INT 2
90411: NEG
90412: PUSH
90413: EMPTY
90414: LIST
90415: LIST
90416: PUSH
90417: LD_INT 3
90419: PUSH
90420: LD_INT 2
90422: PUSH
90423: EMPTY
90424: LIST
90425: LIST
90426: PUSH
90427: LD_INT 3
90429: PUSH
90430: LD_INT 3
90432: PUSH
90433: EMPTY
90434: LIST
90435: LIST
90436: PUSH
90437: LD_INT 2
90439: PUSH
90440: LD_INT 3
90442: PUSH
90443: EMPTY
90444: LIST
90445: LIST
90446: PUSH
90447: LD_INT 1
90449: PUSH
90450: LD_INT 3
90452: PUSH
90453: EMPTY
90454: LIST
90455: LIST
90456: PUSH
90457: LD_INT 0
90459: PUSH
90460: LD_INT 3
90462: PUSH
90463: EMPTY
90464: LIST
90465: LIST
90466: PUSH
90467: LD_INT 1
90469: NEG
90470: PUSH
90471: LD_INT 2
90473: PUSH
90474: EMPTY
90475: LIST
90476: LIST
90477: PUSH
90478: LD_INT 3
90480: NEG
90481: PUSH
90482: LD_INT 2
90484: NEG
90485: PUSH
90486: EMPTY
90487: LIST
90488: LIST
90489: PUSH
90490: LD_INT 3
90492: NEG
90493: PUSH
90494: LD_INT 3
90496: NEG
90497: PUSH
90498: EMPTY
90499: LIST
90500: LIST
90501: PUSH
90502: EMPTY
90503: LIST
90504: LIST
90505: LIST
90506: LIST
90507: LIST
90508: LIST
90509: LIST
90510: LIST
90511: LIST
90512: LIST
90513: LIST
90514: LIST
90515: LIST
90516: LIST
90517: LIST
90518: LIST
90519: LIST
90520: LIST
90521: LIST
90522: LIST
90523: LIST
90524: LIST
90525: LIST
90526: LIST
90527: LIST
90528: LIST
90529: LIST
90530: LIST
90531: LIST
90532: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90533: LD_ADDR_VAR 0 46
90537: PUSH
90538: LD_INT 0
90540: PUSH
90541: LD_INT 0
90543: PUSH
90544: EMPTY
90545: LIST
90546: LIST
90547: PUSH
90548: LD_INT 0
90550: PUSH
90551: LD_INT 1
90553: NEG
90554: PUSH
90555: EMPTY
90556: LIST
90557: LIST
90558: PUSH
90559: LD_INT 1
90561: PUSH
90562: LD_INT 0
90564: PUSH
90565: EMPTY
90566: LIST
90567: LIST
90568: PUSH
90569: LD_INT 1
90571: PUSH
90572: LD_INT 1
90574: PUSH
90575: EMPTY
90576: LIST
90577: LIST
90578: PUSH
90579: LD_INT 0
90581: PUSH
90582: LD_INT 1
90584: PUSH
90585: EMPTY
90586: LIST
90587: LIST
90588: PUSH
90589: LD_INT 1
90591: NEG
90592: PUSH
90593: LD_INT 0
90595: PUSH
90596: EMPTY
90597: LIST
90598: LIST
90599: PUSH
90600: LD_INT 1
90602: NEG
90603: PUSH
90604: LD_INT 1
90606: NEG
90607: PUSH
90608: EMPTY
90609: LIST
90610: LIST
90611: PUSH
90612: LD_INT 1
90614: NEG
90615: PUSH
90616: LD_INT 2
90618: NEG
90619: PUSH
90620: EMPTY
90621: LIST
90622: LIST
90623: PUSH
90624: LD_INT 0
90626: PUSH
90627: LD_INT 2
90629: NEG
90630: PUSH
90631: EMPTY
90632: LIST
90633: LIST
90634: PUSH
90635: LD_INT 1
90637: PUSH
90638: LD_INT 1
90640: NEG
90641: PUSH
90642: EMPTY
90643: LIST
90644: LIST
90645: PUSH
90646: LD_INT 2
90648: PUSH
90649: LD_INT 0
90651: PUSH
90652: EMPTY
90653: LIST
90654: LIST
90655: PUSH
90656: LD_INT 2
90658: PUSH
90659: LD_INT 1
90661: PUSH
90662: EMPTY
90663: LIST
90664: LIST
90665: PUSH
90666: LD_INT 1
90668: PUSH
90669: LD_INT 2
90671: PUSH
90672: EMPTY
90673: LIST
90674: LIST
90675: PUSH
90676: LD_INT 0
90678: PUSH
90679: LD_INT 2
90681: PUSH
90682: EMPTY
90683: LIST
90684: LIST
90685: PUSH
90686: LD_INT 1
90688: NEG
90689: PUSH
90690: LD_INT 1
90692: PUSH
90693: EMPTY
90694: LIST
90695: LIST
90696: PUSH
90697: LD_INT 2
90699: NEG
90700: PUSH
90701: LD_INT 0
90703: PUSH
90704: EMPTY
90705: LIST
90706: LIST
90707: PUSH
90708: LD_INT 2
90710: NEG
90711: PUSH
90712: LD_INT 1
90714: NEG
90715: PUSH
90716: EMPTY
90717: LIST
90718: LIST
90719: PUSH
90720: LD_INT 1
90722: NEG
90723: PUSH
90724: LD_INT 3
90726: NEG
90727: PUSH
90728: EMPTY
90729: LIST
90730: LIST
90731: PUSH
90732: LD_INT 0
90734: PUSH
90735: LD_INT 3
90737: NEG
90738: PUSH
90739: EMPTY
90740: LIST
90741: LIST
90742: PUSH
90743: LD_INT 1
90745: PUSH
90746: LD_INT 2
90748: NEG
90749: PUSH
90750: EMPTY
90751: LIST
90752: LIST
90753: PUSH
90754: LD_INT 2
90756: PUSH
90757: LD_INT 1
90759: NEG
90760: PUSH
90761: EMPTY
90762: LIST
90763: LIST
90764: PUSH
90765: LD_INT 3
90767: PUSH
90768: LD_INT 0
90770: PUSH
90771: EMPTY
90772: LIST
90773: LIST
90774: PUSH
90775: LD_INT 3
90777: PUSH
90778: LD_INT 1
90780: PUSH
90781: EMPTY
90782: LIST
90783: LIST
90784: PUSH
90785: LD_INT 1
90787: PUSH
90788: LD_INT 3
90790: PUSH
90791: EMPTY
90792: LIST
90793: LIST
90794: PUSH
90795: LD_INT 0
90797: PUSH
90798: LD_INT 3
90800: PUSH
90801: EMPTY
90802: LIST
90803: LIST
90804: PUSH
90805: LD_INT 1
90807: NEG
90808: PUSH
90809: LD_INT 2
90811: PUSH
90812: EMPTY
90813: LIST
90814: LIST
90815: PUSH
90816: LD_INT 2
90818: NEG
90819: PUSH
90820: LD_INT 1
90822: PUSH
90823: EMPTY
90824: LIST
90825: LIST
90826: PUSH
90827: LD_INT 3
90829: NEG
90830: PUSH
90831: LD_INT 0
90833: PUSH
90834: EMPTY
90835: LIST
90836: LIST
90837: PUSH
90838: LD_INT 3
90840: NEG
90841: PUSH
90842: LD_INT 1
90844: NEG
90845: PUSH
90846: EMPTY
90847: LIST
90848: LIST
90849: PUSH
90850: EMPTY
90851: LIST
90852: LIST
90853: LIST
90854: LIST
90855: LIST
90856: LIST
90857: LIST
90858: LIST
90859: LIST
90860: LIST
90861: LIST
90862: LIST
90863: LIST
90864: LIST
90865: LIST
90866: LIST
90867: LIST
90868: LIST
90869: LIST
90870: LIST
90871: LIST
90872: LIST
90873: LIST
90874: LIST
90875: LIST
90876: LIST
90877: LIST
90878: LIST
90879: LIST
90880: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90881: LD_ADDR_VAR 0 47
90885: PUSH
90886: LD_INT 0
90888: PUSH
90889: LD_INT 0
90891: PUSH
90892: EMPTY
90893: LIST
90894: LIST
90895: PUSH
90896: LD_INT 0
90898: PUSH
90899: LD_INT 1
90901: NEG
90902: PUSH
90903: EMPTY
90904: LIST
90905: LIST
90906: PUSH
90907: LD_INT 1
90909: PUSH
90910: LD_INT 0
90912: PUSH
90913: EMPTY
90914: LIST
90915: LIST
90916: PUSH
90917: LD_INT 1
90919: PUSH
90920: LD_INT 1
90922: PUSH
90923: EMPTY
90924: LIST
90925: LIST
90926: PUSH
90927: LD_INT 0
90929: PUSH
90930: LD_INT 1
90932: PUSH
90933: EMPTY
90934: LIST
90935: LIST
90936: PUSH
90937: LD_INT 1
90939: NEG
90940: PUSH
90941: LD_INT 0
90943: PUSH
90944: EMPTY
90945: LIST
90946: LIST
90947: PUSH
90948: LD_INT 1
90950: NEG
90951: PUSH
90952: LD_INT 1
90954: NEG
90955: PUSH
90956: EMPTY
90957: LIST
90958: LIST
90959: PUSH
90960: LD_INT 1
90962: NEG
90963: PUSH
90964: LD_INT 2
90966: NEG
90967: PUSH
90968: EMPTY
90969: LIST
90970: LIST
90971: PUSH
90972: LD_INT 0
90974: PUSH
90975: LD_INT 2
90977: NEG
90978: PUSH
90979: EMPTY
90980: LIST
90981: LIST
90982: PUSH
90983: LD_INT 1
90985: PUSH
90986: LD_INT 1
90988: NEG
90989: PUSH
90990: EMPTY
90991: LIST
90992: LIST
90993: PUSH
90994: LD_INT 2
90996: NEG
90997: PUSH
90998: LD_INT 1
91000: NEG
91001: PUSH
91002: EMPTY
91003: LIST
91004: LIST
91005: PUSH
91006: LD_INT 2
91008: NEG
91009: PUSH
91010: LD_INT 2
91012: NEG
91013: PUSH
91014: EMPTY
91015: LIST
91016: LIST
91017: PUSH
91018: EMPTY
91019: LIST
91020: LIST
91021: LIST
91022: LIST
91023: LIST
91024: LIST
91025: LIST
91026: LIST
91027: LIST
91028: LIST
91029: LIST
91030: LIST
91031: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
91032: LD_ADDR_VAR 0 48
91036: PUSH
91037: LD_INT 0
91039: PUSH
91040: LD_INT 0
91042: PUSH
91043: EMPTY
91044: LIST
91045: LIST
91046: PUSH
91047: LD_INT 0
91049: PUSH
91050: LD_INT 1
91052: NEG
91053: PUSH
91054: EMPTY
91055: LIST
91056: LIST
91057: PUSH
91058: LD_INT 1
91060: PUSH
91061: LD_INT 0
91063: PUSH
91064: EMPTY
91065: LIST
91066: LIST
91067: PUSH
91068: LD_INT 1
91070: PUSH
91071: LD_INT 1
91073: PUSH
91074: EMPTY
91075: LIST
91076: LIST
91077: PUSH
91078: LD_INT 0
91080: PUSH
91081: LD_INT 1
91083: PUSH
91084: EMPTY
91085: LIST
91086: LIST
91087: PUSH
91088: LD_INT 1
91090: NEG
91091: PUSH
91092: LD_INT 0
91094: PUSH
91095: EMPTY
91096: LIST
91097: LIST
91098: PUSH
91099: LD_INT 1
91101: NEG
91102: PUSH
91103: LD_INT 1
91105: NEG
91106: PUSH
91107: EMPTY
91108: LIST
91109: LIST
91110: PUSH
91111: LD_INT 1
91113: NEG
91114: PUSH
91115: LD_INT 2
91117: NEG
91118: PUSH
91119: EMPTY
91120: LIST
91121: LIST
91122: PUSH
91123: LD_INT 0
91125: PUSH
91126: LD_INT 2
91128: NEG
91129: PUSH
91130: EMPTY
91131: LIST
91132: LIST
91133: PUSH
91134: LD_INT 1
91136: PUSH
91137: LD_INT 1
91139: NEG
91140: PUSH
91141: EMPTY
91142: LIST
91143: LIST
91144: PUSH
91145: LD_INT 2
91147: PUSH
91148: LD_INT 0
91150: PUSH
91151: EMPTY
91152: LIST
91153: LIST
91154: PUSH
91155: LD_INT 2
91157: PUSH
91158: LD_INT 1
91160: PUSH
91161: EMPTY
91162: LIST
91163: LIST
91164: PUSH
91165: EMPTY
91166: LIST
91167: LIST
91168: LIST
91169: LIST
91170: LIST
91171: LIST
91172: LIST
91173: LIST
91174: LIST
91175: LIST
91176: LIST
91177: LIST
91178: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
91179: LD_ADDR_VAR 0 49
91183: PUSH
91184: LD_INT 0
91186: PUSH
91187: LD_INT 0
91189: PUSH
91190: EMPTY
91191: LIST
91192: LIST
91193: PUSH
91194: LD_INT 0
91196: PUSH
91197: LD_INT 1
91199: NEG
91200: PUSH
91201: EMPTY
91202: LIST
91203: LIST
91204: PUSH
91205: LD_INT 1
91207: PUSH
91208: LD_INT 0
91210: PUSH
91211: EMPTY
91212: LIST
91213: LIST
91214: PUSH
91215: LD_INT 1
91217: PUSH
91218: LD_INT 1
91220: PUSH
91221: EMPTY
91222: LIST
91223: LIST
91224: PUSH
91225: LD_INT 0
91227: PUSH
91228: LD_INT 1
91230: PUSH
91231: EMPTY
91232: LIST
91233: LIST
91234: PUSH
91235: LD_INT 1
91237: NEG
91238: PUSH
91239: LD_INT 0
91241: PUSH
91242: EMPTY
91243: LIST
91244: LIST
91245: PUSH
91246: LD_INT 1
91248: NEG
91249: PUSH
91250: LD_INT 1
91252: NEG
91253: PUSH
91254: EMPTY
91255: LIST
91256: LIST
91257: PUSH
91258: LD_INT 1
91260: PUSH
91261: LD_INT 1
91263: NEG
91264: PUSH
91265: EMPTY
91266: LIST
91267: LIST
91268: PUSH
91269: LD_INT 2
91271: PUSH
91272: LD_INT 0
91274: PUSH
91275: EMPTY
91276: LIST
91277: LIST
91278: PUSH
91279: LD_INT 2
91281: PUSH
91282: LD_INT 1
91284: PUSH
91285: EMPTY
91286: LIST
91287: LIST
91288: PUSH
91289: LD_INT 2
91291: PUSH
91292: LD_INT 2
91294: PUSH
91295: EMPTY
91296: LIST
91297: LIST
91298: PUSH
91299: LD_INT 1
91301: PUSH
91302: LD_INT 2
91304: PUSH
91305: EMPTY
91306: LIST
91307: LIST
91308: PUSH
91309: EMPTY
91310: LIST
91311: LIST
91312: LIST
91313: LIST
91314: LIST
91315: LIST
91316: LIST
91317: LIST
91318: LIST
91319: LIST
91320: LIST
91321: LIST
91322: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
91323: LD_ADDR_VAR 0 50
91327: PUSH
91328: LD_INT 0
91330: PUSH
91331: LD_INT 0
91333: PUSH
91334: EMPTY
91335: LIST
91336: LIST
91337: PUSH
91338: LD_INT 0
91340: PUSH
91341: LD_INT 1
91343: NEG
91344: PUSH
91345: EMPTY
91346: LIST
91347: LIST
91348: PUSH
91349: LD_INT 1
91351: PUSH
91352: LD_INT 0
91354: PUSH
91355: EMPTY
91356: LIST
91357: LIST
91358: PUSH
91359: LD_INT 1
91361: PUSH
91362: LD_INT 1
91364: PUSH
91365: EMPTY
91366: LIST
91367: LIST
91368: PUSH
91369: LD_INT 0
91371: PUSH
91372: LD_INT 1
91374: PUSH
91375: EMPTY
91376: LIST
91377: LIST
91378: PUSH
91379: LD_INT 1
91381: NEG
91382: PUSH
91383: LD_INT 0
91385: PUSH
91386: EMPTY
91387: LIST
91388: LIST
91389: PUSH
91390: LD_INT 1
91392: NEG
91393: PUSH
91394: LD_INT 1
91396: NEG
91397: PUSH
91398: EMPTY
91399: LIST
91400: LIST
91401: PUSH
91402: LD_INT 2
91404: PUSH
91405: LD_INT 1
91407: PUSH
91408: EMPTY
91409: LIST
91410: LIST
91411: PUSH
91412: LD_INT 2
91414: PUSH
91415: LD_INT 2
91417: PUSH
91418: EMPTY
91419: LIST
91420: LIST
91421: PUSH
91422: LD_INT 1
91424: PUSH
91425: LD_INT 2
91427: PUSH
91428: EMPTY
91429: LIST
91430: LIST
91431: PUSH
91432: LD_INT 0
91434: PUSH
91435: LD_INT 2
91437: PUSH
91438: EMPTY
91439: LIST
91440: LIST
91441: PUSH
91442: LD_INT 1
91444: NEG
91445: PUSH
91446: LD_INT 1
91448: PUSH
91449: EMPTY
91450: LIST
91451: LIST
91452: PUSH
91453: EMPTY
91454: LIST
91455: LIST
91456: LIST
91457: LIST
91458: LIST
91459: LIST
91460: LIST
91461: LIST
91462: LIST
91463: LIST
91464: LIST
91465: LIST
91466: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
91467: LD_ADDR_VAR 0 51
91471: PUSH
91472: LD_INT 0
91474: PUSH
91475: LD_INT 0
91477: PUSH
91478: EMPTY
91479: LIST
91480: LIST
91481: PUSH
91482: LD_INT 0
91484: PUSH
91485: LD_INT 1
91487: NEG
91488: PUSH
91489: EMPTY
91490: LIST
91491: LIST
91492: PUSH
91493: LD_INT 1
91495: PUSH
91496: LD_INT 0
91498: PUSH
91499: EMPTY
91500: LIST
91501: LIST
91502: PUSH
91503: LD_INT 1
91505: PUSH
91506: LD_INT 1
91508: PUSH
91509: EMPTY
91510: LIST
91511: LIST
91512: PUSH
91513: LD_INT 0
91515: PUSH
91516: LD_INT 1
91518: PUSH
91519: EMPTY
91520: LIST
91521: LIST
91522: PUSH
91523: LD_INT 1
91525: NEG
91526: PUSH
91527: LD_INT 0
91529: PUSH
91530: EMPTY
91531: LIST
91532: LIST
91533: PUSH
91534: LD_INT 1
91536: NEG
91537: PUSH
91538: LD_INT 1
91540: NEG
91541: PUSH
91542: EMPTY
91543: LIST
91544: LIST
91545: PUSH
91546: LD_INT 1
91548: PUSH
91549: LD_INT 2
91551: PUSH
91552: EMPTY
91553: LIST
91554: LIST
91555: PUSH
91556: LD_INT 0
91558: PUSH
91559: LD_INT 2
91561: PUSH
91562: EMPTY
91563: LIST
91564: LIST
91565: PUSH
91566: LD_INT 1
91568: NEG
91569: PUSH
91570: LD_INT 1
91572: PUSH
91573: EMPTY
91574: LIST
91575: LIST
91576: PUSH
91577: LD_INT 2
91579: NEG
91580: PUSH
91581: LD_INT 0
91583: PUSH
91584: EMPTY
91585: LIST
91586: LIST
91587: PUSH
91588: LD_INT 2
91590: NEG
91591: PUSH
91592: LD_INT 1
91594: NEG
91595: PUSH
91596: EMPTY
91597: LIST
91598: LIST
91599: PUSH
91600: EMPTY
91601: LIST
91602: LIST
91603: LIST
91604: LIST
91605: LIST
91606: LIST
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: LIST
91612: LIST
91613: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91614: LD_ADDR_VAR 0 52
91618: PUSH
91619: LD_INT 0
91621: PUSH
91622: LD_INT 0
91624: PUSH
91625: EMPTY
91626: LIST
91627: LIST
91628: PUSH
91629: LD_INT 0
91631: PUSH
91632: LD_INT 1
91634: NEG
91635: PUSH
91636: EMPTY
91637: LIST
91638: LIST
91639: PUSH
91640: LD_INT 1
91642: PUSH
91643: LD_INT 0
91645: PUSH
91646: EMPTY
91647: LIST
91648: LIST
91649: PUSH
91650: LD_INT 1
91652: PUSH
91653: LD_INT 1
91655: PUSH
91656: EMPTY
91657: LIST
91658: LIST
91659: PUSH
91660: LD_INT 0
91662: PUSH
91663: LD_INT 1
91665: PUSH
91666: EMPTY
91667: LIST
91668: LIST
91669: PUSH
91670: LD_INT 1
91672: NEG
91673: PUSH
91674: LD_INT 0
91676: PUSH
91677: EMPTY
91678: LIST
91679: LIST
91680: PUSH
91681: LD_INT 1
91683: NEG
91684: PUSH
91685: LD_INT 1
91687: NEG
91688: PUSH
91689: EMPTY
91690: LIST
91691: LIST
91692: PUSH
91693: LD_INT 1
91695: NEG
91696: PUSH
91697: LD_INT 2
91699: NEG
91700: PUSH
91701: EMPTY
91702: LIST
91703: LIST
91704: PUSH
91705: LD_INT 1
91707: NEG
91708: PUSH
91709: LD_INT 1
91711: PUSH
91712: EMPTY
91713: LIST
91714: LIST
91715: PUSH
91716: LD_INT 2
91718: NEG
91719: PUSH
91720: LD_INT 0
91722: PUSH
91723: EMPTY
91724: LIST
91725: LIST
91726: PUSH
91727: LD_INT 2
91729: NEG
91730: PUSH
91731: LD_INT 1
91733: NEG
91734: PUSH
91735: EMPTY
91736: LIST
91737: LIST
91738: PUSH
91739: LD_INT 2
91741: NEG
91742: PUSH
91743: LD_INT 2
91745: NEG
91746: PUSH
91747: EMPTY
91748: LIST
91749: LIST
91750: PUSH
91751: EMPTY
91752: LIST
91753: LIST
91754: LIST
91755: LIST
91756: LIST
91757: LIST
91758: LIST
91759: LIST
91760: LIST
91761: LIST
91762: LIST
91763: LIST
91764: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91765: LD_ADDR_VAR 0 53
91769: PUSH
91770: LD_INT 0
91772: PUSH
91773: LD_INT 0
91775: PUSH
91776: EMPTY
91777: LIST
91778: LIST
91779: PUSH
91780: LD_INT 0
91782: PUSH
91783: LD_INT 1
91785: NEG
91786: PUSH
91787: EMPTY
91788: LIST
91789: LIST
91790: PUSH
91791: LD_INT 1
91793: PUSH
91794: LD_INT 0
91796: PUSH
91797: EMPTY
91798: LIST
91799: LIST
91800: PUSH
91801: LD_INT 1
91803: PUSH
91804: LD_INT 1
91806: PUSH
91807: EMPTY
91808: LIST
91809: LIST
91810: PUSH
91811: LD_INT 0
91813: PUSH
91814: LD_INT 1
91816: PUSH
91817: EMPTY
91818: LIST
91819: LIST
91820: PUSH
91821: LD_INT 1
91823: NEG
91824: PUSH
91825: LD_INT 0
91827: PUSH
91828: EMPTY
91829: LIST
91830: LIST
91831: PUSH
91832: LD_INT 1
91834: NEG
91835: PUSH
91836: LD_INT 1
91838: NEG
91839: PUSH
91840: EMPTY
91841: LIST
91842: LIST
91843: PUSH
91844: LD_INT 1
91846: NEG
91847: PUSH
91848: LD_INT 2
91850: NEG
91851: PUSH
91852: EMPTY
91853: LIST
91854: LIST
91855: PUSH
91856: LD_INT 0
91858: PUSH
91859: LD_INT 2
91861: NEG
91862: PUSH
91863: EMPTY
91864: LIST
91865: LIST
91866: PUSH
91867: LD_INT 1
91869: PUSH
91870: LD_INT 1
91872: NEG
91873: PUSH
91874: EMPTY
91875: LIST
91876: LIST
91877: PUSH
91878: LD_INT 2
91880: PUSH
91881: LD_INT 0
91883: PUSH
91884: EMPTY
91885: LIST
91886: LIST
91887: PUSH
91888: LD_INT 2
91890: PUSH
91891: LD_INT 1
91893: PUSH
91894: EMPTY
91895: LIST
91896: LIST
91897: PUSH
91898: LD_INT 2
91900: PUSH
91901: LD_INT 2
91903: PUSH
91904: EMPTY
91905: LIST
91906: LIST
91907: PUSH
91908: LD_INT 1
91910: PUSH
91911: LD_INT 2
91913: PUSH
91914: EMPTY
91915: LIST
91916: LIST
91917: PUSH
91918: LD_INT 0
91920: PUSH
91921: LD_INT 2
91923: PUSH
91924: EMPTY
91925: LIST
91926: LIST
91927: PUSH
91928: LD_INT 1
91930: NEG
91931: PUSH
91932: LD_INT 1
91934: PUSH
91935: EMPTY
91936: LIST
91937: LIST
91938: PUSH
91939: LD_INT 2
91941: NEG
91942: PUSH
91943: LD_INT 0
91945: PUSH
91946: EMPTY
91947: LIST
91948: LIST
91949: PUSH
91950: LD_INT 2
91952: NEG
91953: PUSH
91954: LD_INT 1
91956: NEG
91957: PUSH
91958: EMPTY
91959: LIST
91960: LIST
91961: PUSH
91962: LD_INT 2
91964: NEG
91965: PUSH
91966: LD_INT 2
91968: NEG
91969: PUSH
91970: EMPTY
91971: LIST
91972: LIST
91973: PUSH
91974: EMPTY
91975: LIST
91976: LIST
91977: LIST
91978: LIST
91979: LIST
91980: LIST
91981: LIST
91982: LIST
91983: LIST
91984: LIST
91985: LIST
91986: LIST
91987: LIST
91988: LIST
91989: LIST
91990: LIST
91991: LIST
91992: LIST
91993: LIST
91994: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91995: LD_ADDR_VAR 0 54
91999: PUSH
92000: LD_INT 0
92002: PUSH
92003: LD_INT 0
92005: PUSH
92006: EMPTY
92007: LIST
92008: LIST
92009: PUSH
92010: LD_INT 0
92012: PUSH
92013: LD_INT 1
92015: NEG
92016: PUSH
92017: EMPTY
92018: LIST
92019: LIST
92020: PUSH
92021: LD_INT 1
92023: PUSH
92024: LD_INT 0
92026: PUSH
92027: EMPTY
92028: LIST
92029: LIST
92030: PUSH
92031: LD_INT 1
92033: PUSH
92034: LD_INT 1
92036: PUSH
92037: EMPTY
92038: LIST
92039: LIST
92040: PUSH
92041: LD_INT 0
92043: PUSH
92044: LD_INT 1
92046: PUSH
92047: EMPTY
92048: LIST
92049: LIST
92050: PUSH
92051: LD_INT 1
92053: NEG
92054: PUSH
92055: LD_INT 0
92057: PUSH
92058: EMPTY
92059: LIST
92060: LIST
92061: PUSH
92062: LD_INT 1
92064: NEG
92065: PUSH
92066: LD_INT 1
92068: NEG
92069: PUSH
92070: EMPTY
92071: LIST
92072: LIST
92073: PUSH
92074: LD_INT 1
92076: NEG
92077: PUSH
92078: LD_INT 2
92080: NEG
92081: PUSH
92082: EMPTY
92083: LIST
92084: LIST
92085: PUSH
92086: LD_INT 0
92088: PUSH
92089: LD_INT 2
92091: NEG
92092: PUSH
92093: EMPTY
92094: LIST
92095: LIST
92096: PUSH
92097: LD_INT 1
92099: PUSH
92100: LD_INT 1
92102: NEG
92103: PUSH
92104: EMPTY
92105: LIST
92106: LIST
92107: PUSH
92108: LD_INT 2
92110: PUSH
92111: LD_INT 0
92113: PUSH
92114: EMPTY
92115: LIST
92116: LIST
92117: PUSH
92118: LD_INT 2
92120: PUSH
92121: LD_INT 1
92123: PUSH
92124: EMPTY
92125: LIST
92126: LIST
92127: PUSH
92128: LD_INT 2
92130: PUSH
92131: LD_INT 2
92133: PUSH
92134: EMPTY
92135: LIST
92136: LIST
92137: PUSH
92138: LD_INT 1
92140: PUSH
92141: LD_INT 2
92143: PUSH
92144: EMPTY
92145: LIST
92146: LIST
92147: PUSH
92148: LD_INT 0
92150: PUSH
92151: LD_INT 2
92153: PUSH
92154: EMPTY
92155: LIST
92156: LIST
92157: PUSH
92158: LD_INT 1
92160: NEG
92161: PUSH
92162: LD_INT 1
92164: PUSH
92165: EMPTY
92166: LIST
92167: LIST
92168: PUSH
92169: LD_INT 2
92171: NEG
92172: PUSH
92173: LD_INT 0
92175: PUSH
92176: EMPTY
92177: LIST
92178: LIST
92179: PUSH
92180: LD_INT 2
92182: NEG
92183: PUSH
92184: LD_INT 1
92186: NEG
92187: PUSH
92188: EMPTY
92189: LIST
92190: LIST
92191: PUSH
92192: LD_INT 2
92194: NEG
92195: PUSH
92196: LD_INT 2
92198: NEG
92199: PUSH
92200: EMPTY
92201: LIST
92202: LIST
92203: PUSH
92204: EMPTY
92205: LIST
92206: LIST
92207: LIST
92208: LIST
92209: LIST
92210: LIST
92211: LIST
92212: LIST
92213: LIST
92214: LIST
92215: LIST
92216: LIST
92217: LIST
92218: LIST
92219: LIST
92220: LIST
92221: LIST
92222: LIST
92223: LIST
92224: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92225: LD_ADDR_VAR 0 55
92229: PUSH
92230: LD_INT 0
92232: PUSH
92233: LD_INT 0
92235: PUSH
92236: EMPTY
92237: LIST
92238: LIST
92239: PUSH
92240: LD_INT 0
92242: PUSH
92243: LD_INT 1
92245: NEG
92246: PUSH
92247: EMPTY
92248: LIST
92249: LIST
92250: PUSH
92251: LD_INT 1
92253: PUSH
92254: LD_INT 0
92256: PUSH
92257: EMPTY
92258: LIST
92259: LIST
92260: PUSH
92261: LD_INT 1
92263: PUSH
92264: LD_INT 1
92266: PUSH
92267: EMPTY
92268: LIST
92269: LIST
92270: PUSH
92271: LD_INT 0
92273: PUSH
92274: LD_INT 1
92276: PUSH
92277: EMPTY
92278: LIST
92279: LIST
92280: PUSH
92281: LD_INT 1
92283: NEG
92284: PUSH
92285: LD_INT 0
92287: PUSH
92288: EMPTY
92289: LIST
92290: LIST
92291: PUSH
92292: LD_INT 1
92294: NEG
92295: PUSH
92296: LD_INT 1
92298: NEG
92299: PUSH
92300: EMPTY
92301: LIST
92302: LIST
92303: PUSH
92304: LD_INT 1
92306: NEG
92307: PUSH
92308: LD_INT 2
92310: NEG
92311: PUSH
92312: EMPTY
92313: LIST
92314: LIST
92315: PUSH
92316: LD_INT 0
92318: PUSH
92319: LD_INT 2
92321: NEG
92322: PUSH
92323: EMPTY
92324: LIST
92325: LIST
92326: PUSH
92327: LD_INT 1
92329: PUSH
92330: LD_INT 1
92332: NEG
92333: PUSH
92334: EMPTY
92335: LIST
92336: LIST
92337: PUSH
92338: LD_INT 2
92340: PUSH
92341: LD_INT 0
92343: PUSH
92344: EMPTY
92345: LIST
92346: LIST
92347: PUSH
92348: LD_INT 2
92350: PUSH
92351: LD_INT 1
92353: PUSH
92354: EMPTY
92355: LIST
92356: LIST
92357: PUSH
92358: LD_INT 2
92360: PUSH
92361: LD_INT 2
92363: PUSH
92364: EMPTY
92365: LIST
92366: LIST
92367: PUSH
92368: LD_INT 1
92370: PUSH
92371: LD_INT 2
92373: PUSH
92374: EMPTY
92375: LIST
92376: LIST
92377: PUSH
92378: LD_INT 0
92380: PUSH
92381: LD_INT 2
92383: PUSH
92384: EMPTY
92385: LIST
92386: LIST
92387: PUSH
92388: LD_INT 1
92390: NEG
92391: PUSH
92392: LD_INT 1
92394: PUSH
92395: EMPTY
92396: LIST
92397: LIST
92398: PUSH
92399: LD_INT 2
92401: NEG
92402: PUSH
92403: LD_INT 0
92405: PUSH
92406: EMPTY
92407: LIST
92408: LIST
92409: PUSH
92410: LD_INT 2
92412: NEG
92413: PUSH
92414: LD_INT 1
92416: NEG
92417: PUSH
92418: EMPTY
92419: LIST
92420: LIST
92421: PUSH
92422: LD_INT 2
92424: NEG
92425: PUSH
92426: LD_INT 2
92428: NEG
92429: PUSH
92430: EMPTY
92431: LIST
92432: LIST
92433: PUSH
92434: EMPTY
92435: LIST
92436: LIST
92437: LIST
92438: LIST
92439: LIST
92440: LIST
92441: LIST
92442: LIST
92443: LIST
92444: LIST
92445: LIST
92446: LIST
92447: LIST
92448: LIST
92449: LIST
92450: LIST
92451: LIST
92452: LIST
92453: LIST
92454: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92455: LD_ADDR_VAR 0 56
92459: PUSH
92460: LD_INT 0
92462: PUSH
92463: LD_INT 0
92465: PUSH
92466: EMPTY
92467: LIST
92468: LIST
92469: PUSH
92470: LD_INT 0
92472: PUSH
92473: LD_INT 1
92475: NEG
92476: PUSH
92477: EMPTY
92478: LIST
92479: LIST
92480: PUSH
92481: LD_INT 1
92483: PUSH
92484: LD_INT 0
92486: PUSH
92487: EMPTY
92488: LIST
92489: LIST
92490: PUSH
92491: LD_INT 1
92493: PUSH
92494: LD_INT 1
92496: PUSH
92497: EMPTY
92498: LIST
92499: LIST
92500: PUSH
92501: LD_INT 0
92503: PUSH
92504: LD_INT 1
92506: PUSH
92507: EMPTY
92508: LIST
92509: LIST
92510: PUSH
92511: LD_INT 1
92513: NEG
92514: PUSH
92515: LD_INT 0
92517: PUSH
92518: EMPTY
92519: LIST
92520: LIST
92521: PUSH
92522: LD_INT 1
92524: NEG
92525: PUSH
92526: LD_INT 1
92528: NEG
92529: PUSH
92530: EMPTY
92531: LIST
92532: LIST
92533: PUSH
92534: LD_INT 1
92536: NEG
92537: PUSH
92538: LD_INT 2
92540: NEG
92541: PUSH
92542: EMPTY
92543: LIST
92544: LIST
92545: PUSH
92546: LD_INT 0
92548: PUSH
92549: LD_INT 2
92551: NEG
92552: PUSH
92553: EMPTY
92554: LIST
92555: LIST
92556: PUSH
92557: LD_INT 1
92559: PUSH
92560: LD_INT 1
92562: NEG
92563: PUSH
92564: EMPTY
92565: LIST
92566: LIST
92567: PUSH
92568: LD_INT 2
92570: PUSH
92571: LD_INT 0
92573: PUSH
92574: EMPTY
92575: LIST
92576: LIST
92577: PUSH
92578: LD_INT 2
92580: PUSH
92581: LD_INT 1
92583: PUSH
92584: EMPTY
92585: LIST
92586: LIST
92587: PUSH
92588: LD_INT 2
92590: PUSH
92591: LD_INT 2
92593: PUSH
92594: EMPTY
92595: LIST
92596: LIST
92597: PUSH
92598: LD_INT 1
92600: PUSH
92601: LD_INT 2
92603: PUSH
92604: EMPTY
92605: LIST
92606: LIST
92607: PUSH
92608: LD_INT 0
92610: PUSH
92611: LD_INT 2
92613: PUSH
92614: EMPTY
92615: LIST
92616: LIST
92617: PUSH
92618: LD_INT 1
92620: NEG
92621: PUSH
92622: LD_INT 1
92624: PUSH
92625: EMPTY
92626: LIST
92627: LIST
92628: PUSH
92629: LD_INT 2
92631: NEG
92632: PUSH
92633: LD_INT 0
92635: PUSH
92636: EMPTY
92637: LIST
92638: LIST
92639: PUSH
92640: LD_INT 2
92642: NEG
92643: PUSH
92644: LD_INT 1
92646: NEG
92647: PUSH
92648: EMPTY
92649: LIST
92650: LIST
92651: PUSH
92652: LD_INT 2
92654: NEG
92655: PUSH
92656: LD_INT 2
92658: NEG
92659: PUSH
92660: EMPTY
92661: LIST
92662: LIST
92663: PUSH
92664: EMPTY
92665: LIST
92666: LIST
92667: LIST
92668: LIST
92669: LIST
92670: LIST
92671: LIST
92672: LIST
92673: LIST
92674: LIST
92675: LIST
92676: LIST
92677: LIST
92678: LIST
92679: LIST
92680: LIST
92681: LIST
92682: LIST
92683: LIST
92684: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92685: LD_ADDR_VAR 0 57
92689: PUSH
92690: LD_INT 0
92692: PUSH
92693: LD_INT 0
92695: PUSH
92696: EMPTY
92697: LIST
92698: LIST
92699: PUSH
92700: LD_INT 0
92702: PUSH
92703: LD_INT 1
92705: NEG
92706: PUSH
92707: EMPTY
92708: LIST
92709: LIST
92710: PUSH
92711: LD_INT 1
92713: PUSH
92714: LD_INT 0
92716: PUSH
92717: EMPTY
92718: LIST
92719: LIST
92720: PUSH
92721: LD_INT 1
92723: PUSH
92724: LD_INT 1
92726: PUSH
92727: EMPTY
92728: LIST
92729: LIST
92730: PUSH
92731: LD_INT 0
92733: PUSH
92734: LD_INT 1
92736: PUSH
92737: EMPTY
92738: LIST
92739: LIST
92740: PUSH
92741: LD_INT 1
92743: NEG
92744: PUSH
92745: LD_INT 0
92747: PUSH
92748: EMPTY
92749: LIST
92750: LIST
92751: PUSH
92752: LD_INT 1
92754: NEG
92755: PUSH
92756: LD_INT 1
92758: NEG
92759: PUSH
92760: EMPTY
92761: LIST
92762: LIST
92763: PUSH
92764: LD_INT 1
92766: NEG
92767: PUSH
92768: LD_INT 2
92770: NEG
92771: PUSH
92772: EMPTY
92773: LIST
92774: LIST
92775: PUSH
92776: LD_INT 0
92778: PUSH
92779: LD_INT 2
92781: NEG
92782: PUSH
92783: EMPTY
92784: LIST
92785: LIST
92786: PUSH
92787: LD_INT 1
92789: PUSH
92790: LD_INT 1
92792: NEG
92793: PUSH
92794: EMPTY
92795: LIST
92796: LIST
92797: PUSH
92798: LD_INT 2
92800: PUSH
92801: LD_INT 0
92803: PUSH
92804: EMPTY
92805: LIST
92806: LIST
92807: PUSH
92808: LD_INT 2
92810: PUSH
92811: LD_INT 1
92813: PUSH
92814: EMPTY
92815: LIST
92816: LIST
92817: PUSH
92818: LD_INT 2
92820: PUSH
92821: LD_INT 2
92823: PUSH
92824: EMPTY
92825: LIST
92826: LIST
92827: PUSH
92828: LD_INT 1
92830: PUSH
92831: LD_INT 2
92833: PUSH
92834: EMPTY
92835: LIST
92836: LIST
92837: PUSH
92838: LD_INT 0
92840: PUSH
92841: LD_INT 2
92843: PUSH
92844: EMPTY
92845: LIST
92846: LIST
92847: PUSH
92848: LD_INT 1
92850: NEG
92851: PUSH
92852: LD_INT 1
92854: PUSH
92855: EMPTY
92856: LIST
92857: LIST
92858: PUSH
92859: LD_INT 2
92861: NEG
92862: PUSH
92863: LD_INT 0
92865: PUSH
92866: EMPTY
92867: LIST
92868: LIST
92869: PUSH
92870: LD_INT 2
92872: NEG
92873: PUSH
92874: LD_INT 1
92876: NEG
92877: PUSH
92878: EMPTY
92879: LIST
92880: LIST
92881: PUSH
92882: LD_INT 2
92884: NEG
92885: PUSH
92886: LD_INT 2
92888: NEG
92889: PUSH
92890: EMPTY
92891: LIST
92892: LIST
92893: PUSH
92894: EMPTY
92895: LIST
92896: LIST
92897: LIST
92898: LIST
92899: LIST
92900: LIST
92901: LIST
92902: LIST
92903: LIST
92904: LIST
92905: LIST
92906: LIST
92907: LIST
92908: LIST
92909: LIST
92910: LIST
92911: LIST
92912: LIST
92913: LIST
92914: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92915: LD_ADDR_VAR 0 58
92919: PUSH
92920: LD_INT 0
92922: PUSH
92923: LD_INT 0
92925: PUSH
92926: EMPTY
92927: LIST
92928: LIST
92929: PUSH
92930: LD_INT 0
92932: PUSH
92933: LD_INT 1
92935: NEG
92936: PUSH
92937: EMPTY
92938: LIST
92939: LIST
92940: PUSH
92941: LD_INT 1
92943: PUSH
92944: LD_INT 0
92946: PUSH
92947: EMPTY
92948: LIST
92949: LIST
92950: PUSH
92951: LD_INT 1
92953: PUSH
92954: LD_INT 1
92956: PUSH
92957: EMPTY
92958: LIST
92959: LIST
92960: PUSH
92961: LD_INT 0
92963: PUSH
92964: LD_INT 1
92966: PUSH
92967: EMPTY
92968: LIST
92969: LIST
92970: PUSH
92971: LD_INT 1
92973: NEG
92974: PUSH
92975: LD_INT 0
92977: PUSH
92978: EMPTY
92979: LIST
92980: LIST
92981: PUSH
92982: LD_INT 1
92984: NEG
92985: PUSH
92986: LD_INT 1
92988: NEG
92989: PUSH
92990: EMPTY
92991: LIST
92992: LIST
92993: PUSH
92994: LD_INT 1
92996: NEG
92997: PUSH
92998: LD_INT 2
93000: NEG
93001: PUSH
93002: EMPTY
93003: LIST
93004: LIST
93005: PUSH
93006: LD_INT 0
93008: PUSH
93009: LD_INT 2
93011: NEG
93012: PUSH
93013: EMPTY
93014: LIST
93015: LIST
93016: PUSH
93017: LD_INT 1
93019: PUSH
93020: LD_INT 1
93022: NEG
93023: PUSH
93024: EMPTY
93025: LIST
93026: LIST
93027: PUSH
93028: LD_INT 2
93030: PUSH
93031: LD_INT 0
93033: PUSH
93034: EMPTY
93035: LIST
93036: LIST
93037: PUSH
93038: LD_INT 2
93040: PUSH
93041: LD_INT 1
93043: PUSH
93044: EMPTY
93045: LIST
93046: LIST
93047: PUSH
93048: LD_INT 2
93050: PUSH
93051: LD_INT 2
93053: PUSH
93054: EMPTY
93055: LIST
93056: LIST
93057: PUSH
93058: LD_INT 1
93060: PUSH
93061: LD_INT 2
93063: PUSH
93064: EMPTY
93065: LIST
93066: LIST
93067: PUSH
93068: LD_INT 0
93070: PUSH
93071: LD_INT 2
93073: PUSH
93074: EMPTY
93075: LIST
93076: LIST
93077: PUSH
93078: LD_INT 1
93080: NEG
93081: PUSH
93082: LD_INT 1
93084: PUSH
93085: EMPTY
93086: LIST
93087: LIST
93088: PUSH
93089: LD_INT 2
93091: NEG
93092: PUSH
93093: LD_INT 0
93095: PUSH
93096: EMPTY
93097: LIST
93098: LIST
93099: PUSH
93100: LD_INT 2
93102: NEG
93103: PUSH
93104: LD_INT 1
93106: NEG
93107: PUSH
93108: EMPTY
93109: LIST
93110: LIST
93111: PUSH
93112: LD_INT 2
93114: NEG
93115: PUSH
93116: LD_INT 2
93118: NEG
93119: PUSH
93120: EMPTY
93121: LIST
93122: LIST
93123: PUSH
93124: EMPTY
93125: LIST
93126: LIST
93127: LIST
93128: LIST
93129: LIST
93130: LIST
93131: LIST
93132: LIST
93133: LIST
93134: LIST
93135: LIST
93136: LIST
93137: LIST
93138: LIST
93139: LIST
93140: LIST
93141: LIST
93142: LIST
93143: LIST
93144: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93145: LD_ADDR_VAR 0 59
93149: PUSH
93150: LD_INT 0
93152: PUSH
93153: LD_INT 0
93155: PUSH
93156: EMPTY
93157: LIST
93158: LIST
93159: PUSH
93160: LD_INT 0
93162: PUSH
93163: LD_INT 1
93165: NEG
93166: PUSH
93167: EMPTY
93168: LIST
93169: LIST
93170: PUSH
93171: LD_INT 1
93173: PUSH
93174: LD_INT 0
93176: PUSH
93177: EMPTY
93178: LIST
93179: LIST
93180: PUSH
93181: LD_INT 1
93183: PUSH
93184: LD_INT 1
93186: PUSH
93187: EMPTY
93188: LIST
93189: LIST
93190: PUSH
93191: LD_INT 0
93193: PUSH
93194: LD_INT 1
93196: PUSH
93197: EMPTY
93198: LIST
93199: LIST
93200: PUSH
93201: LD_INT 1
93203: NEG
93204: PUSH
93205: LD_INT 0
93207: PUSH
93208: EMPTY
93209: LIST
93210: LIST
93211: PUSH
93212: LD_INT 1
93214: NEG
93215: PUSH
93216: LD_INT 1
93218: NEG
93219: PUSH
93220: EMPTY
93221: LIST
93222: LIST
93223: PUSH
93224: EMPTY
93225: LIST
93226: LIST
93227: LIST
93228: LIST
93229: LIST
93230: LIST
93231: LIST
93232: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93233: LD_ADDR_VAR 0 60
93237: PUSH
93238: LD_INT 0
93240: PUSH
93241: LD_INT 0
93243: PUSH
93244: EMPTY
93245: LIST
93246: LIST
93247: PUSH
93248: LD_INT 0
93250: PUSH
93251: LD_INT 1
93253: NEG
93254: PUSH
93255: EMPTY
93256: LIST
93257: LIST
93258: PUSH
93259: LD_INT 1
93261: PUSH
93262: LD_INT 0
93264: PUSH
93265: EMPTY
93266: LIST
93267: LIST
93268: PUSH
93269: LD_INT 1
93271: PUSH
93272: LD_INT 1
93274: PUSH
93275: EMPTY
93276: LIST
93277: LIST
93278: PUSH
93279: LD_INT 0
93281: PUSH
93282: LD_INT 1
93284: PUSH
93285: EMPTY
93286: LIST
93287: LIST
93288: PUSH
93289: LD_INT 1
93291: NEG
93292: PUSH
93293: LD_INT 0
93295: PUSH
93296: EMPTY
93297: LIST
93298: LIST
93299: PUSH
93300: LD_INT 1
93302: NEG
93303: PUSH
93304: LD_INT 1
93306: NEG
93307: PUSH
93308: EMPTY
93309: LIST
93310: LIST
93311: PUSH
93312: EMPTY
93313: LIST
93314: LIST
93315: LIST
93316: LIST
93317: LIST
93318: LIST
93319: LIST
93320: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93321: LD_ADDR_VAR 0 61
93325: PUSH
93326: LD_INT 0
93328: PUSH
93329: LD_INT 0
93331: PUSH
93332: EMPTY
93333: LIST
93334: LIST
93335: PUSH
93336: LD_INT 0
93338: PUSH
93339: LD_INT 1
93341: NEG
93342: PUSH
93343: EMPTY
93344: LIST
93345: LIST
93346: PUSH
93347: LD_INT 1
93349: PUSH
93350: LD_INT 0
93352: PUSH
93353: EMPTY
93354: LIST
93355: LIST
93356: PUSH
93357: LD_INT 1
93359: PUSH
93360: LD_INT 1
93362: PUSH
93363: EMPTY
93364: LIST
93365: LIST
93366: PUSH
93367: LD_INT 0
93369: PUSH
93370: LD_INT 1
93372: PUSH
93373: EMPTY
93374: LIST
93375: LIST
93376: PUSH
93377: LD_INT 1
93379: NEG
93380: PUSH
93381: LD_INT 0
93383: PUSH
93384: EMPTY
93385: LIST
93386: LIST
93387: PUSH
93388: LD_INT 1
93390: NEG
93391: PUSH
93392: LD_INT 1
93394: NEG
93395: PUSH
93396: EMPTY
93397: LIST
93398: LIST
93399: PUSH
93400: EMPTY
93401: LIST
93402: LIST
93403: LIST
93404: LIST
93405: LIST
93406: LIST
93407: LIST
93408: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93409: LD_ADDR_VAR 0 62
93413: PUSH
93414: LD_INT 0
93416: PUSH
93417: LD_INT 0
93419: PUSH
93420: EMPTY
93421: LIST
93422: LIST
93423: PUSH
93424: LD_INT 0
93426: PUSH
93427: LD_INT 1
93429: NEG
93430: PUSH
93431: EMPTY
93432: LIST
93433: LIST
93434: PUSH
93435: LD_INT 1
93437: PUSH
93438: LD_INT 0
93440: PUSH
93441: EMPTY
93442: LIST
93443: LIST
93444: PUSH
93445: LD_INT 1
93447: PUSH
93448: LD_INT 1
93450: PUSH
93451: EMPTY
93452: LIST
93453: LIST
93454: PUSH
93455: LD_INT 0
93457: PUSH
93458: LD_INT 1
93460: PUSH
93461: EMPTY
93462: LIST
93463: LIST
93464: PUSH
93465: LD_INT 1
93467: NEG
93468: PUSH
93469: LD_INT 0
93471: PUSH
93472: EMPTY
93473: LIST
93474: LIST
93475: PUSH
93476: LD_INT 1
93478: NEG
93479: PUSH
93480: LD_INT 1
93482: NEG
93483: PUSH
93484: EMPTY
93485: LIST
93486: LIST
93487: PUSH
93488: EMPTY
93489: LIST
93490: LIST
93491: LIST
93492: LIST
93493: LIST
93494: LIST
93495: LIST
93496: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93497: LD_ADDR_VAR 0 63
93501: PUSH
93502: LD_INT 0
93504: PUSH
93505: LD_INT 0
93507: PUSH
93508: EMPTY
93509: LIST
93510: LIST
93511: PUSH
93512: LD_INT 0
93514: PUSH
93515: LD_INT 1
93517: NEG
93518: PUSH
93519: EMPTY
93520: LIST
93521: LIST
93522: PUSH
93523: LD_INT 1
93525: PUSH
93526: LD_INT 0
93528: PUSH
93529: EMPTY
93530: LIST
93531: LIST
93532: PUSH
93533: LD_INT 1
93535: PUSH
93536: LD_INT 1
93538: PUSH
93539: EMPTY
93540: LIST
93541: LIST
93542: PUSH
93543: LD_INT 0
93545: PUSH
93546: LD_INT 1
93548: PUSH
93549: EMPTY
93550: LIST
93551: LIST
93552: PUSH
93553: LD_INT 1
93555: NEG
93556: PUSH
93557: LD_INT 0
93559: PUSH
93560: EMPTY
93561: LIST
93562: LIST
93563: PUSH
93564: LD_INT 1
93566: NEG
93567: PUSH
93568: LD_INT 1
93570: NEG
93571: PUSH
93572: EMPTY
93573: LIST
93574: LIST
93575: PUSH
93576: EMPTY
93577: LIST
93578: LIST
93579: LIST
93580: LIST
93581: LIST
93582: LIST
93583: LIST
93584: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93585: LD_ADDR_VAR 0 64
93589: PUSH
93590: LD_INT 0
93592: PUSH
93593: LD_INT 0
93595: PUSH
93596: EMPTY
93597: LIST
93598: LIST
93599: PUSH
93600: LD_INT 0
93602: PUSH
93603: LD_INT 1
93605: NEG
93606: PUSH
93607: EMPTY
93608: LIST
93609: LIST
93610: PUSH
93611: LD_INT 1
93613: PUSH
93614: LD_INT 0
93616: PUSH
93617: EMPTY
93618: LIST
93619: LIST
93620: PUSH
93621: LD_INT 1
93623: PUSH
93624: LD_INT 1
93626: PUSH
93627: EMPTY
93628: LIST
93629: LIST
93630: PUSH
93631: LD_INT 0
93633: PUSH
93634: LD_INT 1
93636: PUSH
93637: EMPTY
93638: LIST
93639: LIST
93640: PUSH
93641: LD_INT 1
93643: NEG
93644: PUSH
93645: LD_INT 0
93647: PUSH
93648: EMPTY
93649: LIST
93650: LIST
93651: PUSH
93652: LD_INT 1
93654: NEG
93655: PUSH
93656: LD_INT 1
93658: NEG
93659: PUSH
93660: EMPTY
93661: LIST
93662: LIST
93663: PUSH
93664: EMPTY
93665: LIST
93666: LIST
93667: LIST
93668: LIST
93669: LIST
93670: LIST
93671: LIST
93672: ST_TO_ADDR
// end ; 1 :
93673: GO 99570
93675: LD_INT 1
93677: DOUBLE
93678: EQUAL
93679: IFTRUE 93683
93681: GO 96306
93683: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93684: LD_ADDR_VAR 0 11
93688: PUSH
93689: LD_INT 1
93691: NEG
93692: PUSH
93693: LD_INT 3
93695: NEG
93696: PUSH
93697: EMPTY
93698: LIST
93699: LIST
93700: PUSH
93701: LD_INT 0
93703: PUSH
93704: LD_INT 3
93706: NEG
93707: PUSH
93708: EMPTY
93709: LIST
93710: LIST
93711: PUSH
93712: LD_INT 1
93714: PUSH
93715: LD_INT 2
93717: NEG
93718: PUSH
93719: EMPTY
93720: LIST
93721: LIST
93722: PUSH
93723: EMPTY
93724: LIST
93725: LIST
93726: LIST
93727: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93728: LD_ADDR_VAR 0 12
93732: PUSH
93733: LD_INT 2
93735: PUSH
93736: LD_INT 1
93738: NEG
93739: PUSH
93740: EMPTY
93741: LIST
93742: LIST
93743: PUSH
93744: LD_INT 3
93746: PUSH
93747: LD_INT 0
93749: PUSH
93750: EMPTY
93751: LIST
93752: LIST
93753: PUSH
93754: LD_INT 3
93756: PUSH
93757: LD_INT 1
93759: PUSH
93760: EMPTY
93761: LIST
93762: LIST
93763: PUSH
93764: EMPTY
93765: LIST
93766: LIST
93767: LIST
93768: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93769: LD_ADDR_VAR 0 13
93773: PUSH
93774: LD_INT 3
93776: PUSH
93777: LD_INT 2
93779: PUSH
93780: EMPTY
93781: LIST
93782: LIST
93783: PUSH
93784: LD_INT 3
93786: PUSH
93787: LD_INT 3
93789: PUSH
93790: EMPTY
93791: LIST
93792: LIST
93793: PUSH
93794: LD_INT 2
93796: PUSH
93797: LD_INT 3
93799: PUSH
93800: EMPTY
93801: LIST
93802: LIST
93803: PUSH
93804: EMPTY
93805: LIST
93806: LIST
93807: LIST
93808: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93809: LD_ADDR_VAR 0 14
93813: PUSH
93814: LD_INT 1
93816: PUSH
93817: LD_INT 3
93819: PUSH
93820: EMPTY
93821: LIST
93822: LIST
93823: PUSH
93824: LD_INT 0
93826: PUSH
93827: LD_INT 3
93829: PUSH
93830: EMPTY
93831: LIST
93832: LIST
93833: PUSH
93834: LD_INT 1
93836: NEG
93837: PUSH
93838: LD_INT 2
93840: PUSH
93841: EMPTY
93842: LIST
93843: LIST
93844: PUSH
93845: EMPTY
93846: LIST
93847: LIST
93848: LIST
93849: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93850: LD_ADDR_VAR 0 15
93854: PUSH
93855: LD_INT 2
93857: NEG
93858: PUSH
93859: LD_INT 1
93861: PUSH
93862: EMPTY
93863: LIST
93864: LIST
93865: PUSH
93866: LD_INT 3
93868: NEG
93869: PUSH
93870: LD_INT 0
93872: PUSH
93873: EMPTY
93874: LIST
93875: LIST
93876: PUSH
93877: LD_INT 3
93879: NEG
93880: PUSH
93881: LD_INT 1
93883: NEG
93884: PUSH
93885: EMPTY
93886: LIST
93887: LIST
93888: PUSH
93889: EMPTY
93890: LIST
93891: LIST
93892: LIST
93893: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93894: LD_ADDR_VAR 0 16
93898: PUSH
93899: LD_INT 2
93901: NEG
93902: PUSH
93903: LD_INT 3
93905: NEG
93906: PUSH
93907: EMPTY
93908: LIST
93909: LIST
93910: PUSH
93911: LD_INT 3
93913: NEG
93914: PUSH
93915: LD_INT 2
93917: NEG
93918: PUSH
93919: EMPTY
93920: LIST
93921: LIST
93922: PUSH
93923: LD_INT 3
93925: NEG
93926: PUSH
93927: LD_INT 3
93929: NEG
93930: PUSH
93931: EMPTY
93932: LIST
93933: LIST
93934: PUSH
93935: EMPTY
93936: LIST
93937: LIST
93938: LIST
93939: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93940: LD_ADDR_VAR 0 17
93944: PUSH
93945: LD_INT 1
93947: NEG
93948: PUSH
93949: LD_INT 3
93951: NEG
93952: PUSH
93953: EMPTY
93954: LIST
93955: LIST
93956: PUSH
93957: LD_INT 0
93959: PUSH
93960: LD_INT 3
93962: NEG
93963: PUSH
93964: EMPTY
93965: LIST
93966: LIST
93967: PUSH
93968: LD_INT 1
93970: PUSH
93971: LD_INT 2
93973: NEG
93974: PUSH
93975: EMPTY
93976: LIST
93977: LIST
93978: PUSH
93979: EMPTY
93980: LIST
93981: LIST
93982: LIST
93983: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93984: LD_ADDR_VAR 0 18
93988: PUSH
93989: LD_INT 2
93991: PUSH
93992: LD_INT 1
93994: NEG
93995: PUSH
93996: EMPTY
93997: LIST
93998: LIST
93999: PUSH
94000: LD_INT 3
94002: PUSH
94003: LD_INT 0
94005: PUSH
94006: EMPTY
94007: LIST
94008: LIST
94009: PUSH
94010: LD_INT 3
94012: PUSH
94013: LD_INT 1
94015: PUSH
94016: EMPTY
94017: LIST
94018: LIST
94019: PUSH
94020: EMPTY
94021: LIST
94022: LIST
94023: LIST
94024: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
94025: LD_ADDR_VAR 0 19
94029: PUSH
94030: LD_INT 3
94032: PUSH
94033: LD_INT 2
94035: PUSH
94036: EMPTY
94037: LIST
94038: LIST
94039: PUSH
94040: LD_INT 3
94042: PUSH
94043: LD_INT 3
94045: PUSH
94046: EMPTY
94047: LIST
94048: LIST
94049: PUSH
94050: LD_INT 2
94052: PUSH
94053: LD_INT 3
94055: PUSH
94056: EMPTY
94057: LIST
94058: LIST
94059: PUSH
94060: EMPTY
94061: LIST
94062: LIST
94063: LIST
94064: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
94065: LD_ADDR_VAR 0 20
94069: PUSH
94070: LD_INT 1
94072: PUSH
94073: LD_INT 3
94075: PUSH
94076: EMPTY
94077: LIST
94078: LIST
94079: PUSH
94080: LD_INT 0
94082: PUSH
94083: LD_INT 3
94085: PUSH
94086: EMPTY
94087: LIST
94088: LIST
94089: PUSH
94090: LD_INT 1
94092: NEG
94093: PUSH
94094: LD_INT 2
94096: PUSH
94097: EMPTY
94098: LIST
94099: LIST
94100: PUSH
94101: EMPTY
94102: LIST
94103: LIST
94104: LIST
94105: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
94106: LD_ADDR_VAR 0 21
94110: PUSH
94111: LD_INT 2
94113: NEG
94114: PUSH
94115: LD_INT 1
94117: PUSH
94118: EMPTY
94119: LIST
94120: LIST
94121: PUSH
94122: LD_INT 3
94124: NEG
94125: PUSH
94126: LD_INT 0
94128: PUSH
94129: EMPTY
94130: LIST
94131: LIST
94132: PUSH
94133: LD_INT 3
94135: NEG
94136: PUSH
94137: LD_INT 1
94139: NEG
94140: PUSH
94141: EMPTY
94142: LIST
94143: LIST
94144: PUSH
94145: EMPTY
94146: LIST
94147: LIST
94148: LIST
94149: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
94150: LD_ADDR_VAR 0 22
94154: PUSH
94155: LD_INT 2
94157: NEG
94158: PUSH
94159: LD_INT 3
94161: NEG
94162: PUSH
94163: EMPTY
94164: LIST
94165: LIST
94166: PUSH
94167: LD_INT 3
94169: NEG
94170: PUSH
94171: LD_INT 2
94173: NEG
94174: PUSH
94175: EMPTY
94176: LIST
94177: LIST
94178: PUSH
94179: LD_INT 3
94181: NEG
94182: PUSH
94183: LD_INT 3
94185: NEG
94186: PUSH
94187: EMPTY
94188: LIST
94189: LIST
94190: PUSH
94191: EMPTY
94192: LIST
94193: LIST
94194: LIST
94195: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
94196: LD_ADDR_VAR 0 23
94200: PUSH
94201: LD_INT 0
94203: PUSH
94204: LD_INT 3
94206: NEG
94207: PUSH
94208: EMPTY
94209: LIST
94210: LIST
94211: PUSH
94212: LD_INT 1
94214: NEG
94215: PUSH
94216: LD_INT 4
94218: NEG
94219: PUSH
94220: EMPTY
94221: LIST
94222: LIST
94223: PUSH
94224: LD_INT 1
94226: PUSH
94227: LD_INT 3
94229: NEG
94230: PUSH
94231: EMPTY
94232: LIST
94233: LIST
94234: PUSH
94235: EMPTY
94236: LIST
94237: LIST
94238: LIST
94239: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
94240: LD_ADDR_VAR 0 24
94244: PUSH
94245: LD_INT 3
94247: PUSH
94248: LD_INT 0
94250: PUSH
94251: EMPTY
94252: LIST
94253: LIST
94254: PUSH
94255: LD_INT 3
94257: PUSH
94258: LD_INT 1
94260: NEG
94261: PUSH
94262: EMPTY
94263: LIST
94264: LIST
94265: PUSH
94266: LD_INT 4
94268: PUSH
94269: LD_INT 1
94271: PUSH
94272: EMPTY
94273: LIST
94274: LIST
94275: PUSH
94276: EMPTY
94277: LIST
94278: LIST
94279: LIST
94280: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
94281: LD_ADDR_VAR 0 25
94285: PUSH
94286: LD_INT 3
94288: PUSH
94289: LD_INT 3
94291: PUSH
94292: EMPTY
94293: LIST
94294: LIST
94295: PUSH
94296: LD_INT 4
94298: PUSH
94299: LD_INT 3
94301: PUSH
94302: EMPTY
94303: LIST
94304: LIST
94305: PUSH
94306: LD_INT 3
94308: PUSH
94309: LD_INT 4
94311: PUSH
94312: EMPTY
94313: LIST
94314: LIST
94315: PUSH
94316: EMPTY
94317: LIST
94318: LIST
94319: LIST
94320: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
94321: LD_ADDR_VAR 0 26
94325: PUSH
94326: LD_INT 0
94328: PUSH
94329: LD_INT 3
94331: PUSH
94332: EMPTY
94333: LIST
94334: LIST
94335: PUSH
94336: LD_INT 1
94338: PUSH
94339: LD_INT 4
94341: PUSH
94342: EMPTY
94343: LIST
94344: LIST
94345: PUSH
94346: LD_INT 1
94348: NEG
94349: PUSH
94350: LD_INT 3
94352: PUSH
94353: EMPTY
94354: LIST
94355: LIST
94356: PUSH
94357: EMPTY
94358: LIST
94359: LIST
94360: LIST
94361: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
94362: LD_ADDR_VAR 0 27
94366: PUSH
94367: LD_INT 3
94369: NEG
94370: PUSH
94371: LD_INT 0
94373: PUSH
94374: EMPTY
94375: LIST
94376: LIST
94377: PUSH
94378: LD_INT 3
94380: NEG
94381: PUSH
94382: LD_INT 1
94384: PUSH
94385: EMPTY
94386: LIST
94387: LIST
94388: PUSH
94389: LD_INT 4
94391: NEG
94392: PUSH
94393: LD_INT 1
94395: NEG
94396: PUSH
94397: EMPTY
94398: LIST
94399: LIST
94400: PUSH
94401: EMPTY
94402: LIST
94403: LIST
94404: LIST
94405: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
94406: LD_ADDR_VAR 0 28
94410: PUSH
94411: LD_INT 3
94413: NEG
94414: PUSH
94415: LD_INT 3
94417: NEG
94418: PUSH
94419: EMPTY
94420: LIST
94421: LIST
94422: PUSH
94423: LD_INT 3
94425: NEG
94426: PUSH
94427: LD_INT 4
94429: NEG
94430: PUSH
94431: EMPTY
94432: LIST
94433: LIST
94434: PUSH
94435: LD_INT 4
94437: NEG
94438: PUSH
94439: LD_INT 3
94441: NEG
94442: PUSH
94443: EMPTY
94444: LIST
94445: LIST
94446: PUSH
94447: EMPTY
94448: LIST
94449: LIST
94450: LIST
94451: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
94452: LD_ADDR_VAR 0 29
94456: PUSH
94457: LD_INT 1
94459: NEG
94460: PUSH
94461: LD_INT 3
94463: NEG
94464: PUSH
94465: EMPTY
94466: LIST
94467: LIST
94468: PUSH
94469: LD_INT 0
94471: PUSH
94472: LD_INT 3
94474: NEG
94475: PUSH
94476: EMPTY
94477: LIST
94478: LIST
94479: PUSH
94480: LD_INT 1
94482: PUSH
94483: LD_INT 2
94485: NEG
94486: PUSH
94487: EMPTY
94488: LIST
94489: LIST
94490: PUSH
94491: LD_INT 1
94493: NEG
94494: PUSH
94495: LD_INT 4
94497: NEG
94498: PUSH
94499: EMPTY
94500: LIST
94501: LIST
94502: PUSH
94503: LD_INT 0
94505: PUSH
94506: LD_INT 4
94508: NEG
94509: PUSH
94510: EMPTY
94511: LIST
94512: LIST
94513: PUSH
94514: LD_INT 1
94516: PUSH
94517: LD_INT 3
94519: NEG
94520: PUSH
94521: EMPTY
94522: LIST
94523: LIST
94524: PUSH
94525: LD_INT 1
94527: NEG
94528: PUSH
94529: LD_INT 5
94531: NEG
94532: PUSH
94533: EMPTY
94534: LIST
94535: LIST
94536: PUSH
94537: LD_INT 0
94539: PUSH
94540: LD_INT 5
94542: NEG
94543: PUSH
94544: EMPTY
94545: LIST
94546: LIST
94547: PUSH
94548: LD_INT 1
94550: PUSH
94551: LD_INT 4
94553: NEG
94554: PUSH
94555: EMPTY
94556: LIST
94557: LIST
94558: PUSH
94559: LD_INT 1
94561: NEG
94562: PUSH
94563: LD_INT 6
94565: NEG
94566: PUSH
94567: EMPTY
94568: LIST
94569: LIST
94570: PUSH
94571: LD_INT 0
94573: PUSH
94574: LD_INT 6
94576: NEG
94577: PUSH
94578: EMPTY
94579: LIST
94580: LIST
94581: PUSH
94582: LD_INT 1
94584: PUSH
94585: LD_INT 5
94587: NEG
94588: PUSH
94589: EMPTY
94590: LIST
94591: LIST
94592: PUSH
94593: EMPTY
94594: LIST
94595: LIST
94596: LIST
94597: LIST
94598: LIST
94599: LIST
94600: LIST
94601: LIST
94602: LIST
94603: LIST
94604: LIST
94605: LIST
94606: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
94607: LD_ADDR_VAR 0 30
94611: PUSH
94612: LD_INT 2
94614: PUSH
94615: LD_INT 1
94617: NEG
94618: PUSH
94619: EMPTY
94620: LIST
94621: LIST
94622: PUSH
94623: LD_INT 3
94625: PUSH
94626: LD_INT 0
94628: PUSH
94629: EMPTY
94630: LIST
94631: LIST
94632: PUSH
94633: LD_INT 3
94635: PUSH
94636: LD_INT 1
94638: PUSH
94639: EMPTY
94640: LIST
94641: LIST
94642: PUSH
94643: LD_INT 3
94645: PUSH
94646: LD_INT 1
94648: NEG
94649: PUSH
94650: EMPTY
94651: LIST
94652: LIST
94653: PUSH
94654: LD_INT 4
94656: PUSH
94657: LD_INT 0
94659: PUSH
94660: EMPTY
94661: LIST
94662: LIST
94663: PUSH
94664: LD_INT 4
94666: PUSH
94667: LD_INT 1
94669: PUSH
94670: EMPTY
94671: LIST
94672: LIST
94673: PUSH
94674: LD_INT 4
94676: PUSH
94677: LD_INT 1
94679: NEG
94680: PUSH
94681: EMPTY
94682: LIST
94683: LIST
94684: PUSH
94685: LD_INT 5
94687: PUSH
94688: LD_INT 0
94690: PUSH
94691: EMPTY
94692: LIST
94693: LIST
94694: PUSH
94695: LD_INT 5
94697: PUSH
94698: LD_INT 1
94700: PUSH
94701: EMPTY
94702: LIST
94703: LIST
94704: PUSH
94705: LD_INT 5
94707: PUSH
94708: LD_INT 1
94710: NEG
94711: PUSH
94712: EMPTY
94713: LIST
94714: LIST
94715: PUSH
94716: LD_INT 6
94718: PUSH
94719: LD_INT 0
94721: PUSH
94722: EMPTY
94723: LIST
94724: LIST
94725: PUSH
94726: LD_INT 6
94728: PUSH
94729: LD_INT 1
94731: PUSH
94732: EMPTY
94733: LIST
94734: LIST
94735: PUSH
94736: EMPTY
94737: LIST
94738: LIST
94739: LIST
94740: LIST
94741: LIST
94742: LIST
94743: LIST
94744: LIST
94745: LIST
94746: LIST
94747: LIST
94748: LIST
94749: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
94750: LD_ADDR_VAR 0 31
94754: PUSH
94755: LD_INT 3
94757: PUSH
94758: LD_INT 2
94760: PUSH
94761: EMPTY
94762: LIST
94763: LIST
94764: PUSH
94765: LD_INT 3
94767: PUSH
94768: LD_INT 3
94770: PUSH
94771: EMPTY
94772: LIST
94773: LIST
94774: PUSH
94775: LD_INT 2
94777: PUSH
94778: LD_INT 3
94780: PUSH
94781: EMPTY
94782: LIST
94783: LIST
94784: PUSH
94785: LD_INT 4
94787: PUSH
94788: LD_INT 3
94790: PUSH
94791: EMPTY
94792: LIST
94793: LIST
94794: PUSH
94795: LD_INT 4
94797: PUSH
94798: LD_INT 4
94800: PUSH
94801: EMPTY
94802: LIST
94803: LIST
94804: PUSH
94805: LD_INT 3
94807: PUSH
94808: LD_INT 4
94810: PUSH
94811: EMPTY
94812: LIST
94813: LIST
94814: PUSH
94815: LD_INT 5
94817: PUSH
94818: LD_INT 4
94820: PUSH
94821: EMPTY
94822: LIST
94823: LIST
94824: PUSH
94825: LD_INT 5
94827: PUSH
94828: LD_INT 5
94830: PUSH
94831: EMPTY
94832: LIST
94833: LIST
94834: PUSH
94835: LD_INT 4
94837: PUSH
94838: LD_INT 5
94840: PUSH
94841: EMPTY
94842: LIST
94843: LIST
94844: PUSH
94845: LD_INT 6
94847: PUSH
94848: LD_INT 5
94850: PUSH
94851: EMPTY
94852: LIST
94853: LIST
94854: PUSH
94855: LD_INT 6
94857: PUSH
94858: LD_INT 6
94860: PUSH
94861: EMPTY
94862: LIST
94863: LIST
94864: PUSH
94865: LD_INT 5
94867: PUSH
94868: LD_INT 6
94870: PUSH
94871: EMPTY
94872: LIST
94873: LIST
94874: PUSH
94875: EMPTY
94876: LIST
94877: LIST
94878: LIST
94879: LIST
94880: LIST
94881: LIST
94882: LIST
94883: LIST
94884: LIST
94885: LIST
94886: LIST
94887: LIST
94888: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
94889: LD_ADDR_VAR 0 32
94893: PUSH
94894: LD_INT 1
94896: PUSH
94897: LD_INT 3
94899: PUSH
94900: EMPTY
94901: LIST
94902: LIST
94903: PUSH
94904: LD_INT 0
94906: PUSH
94907: LD_INT 3
94909: PUSH
94910: EMPTY
94911: LIST
94912: LIST
94913: PUSH
94914: LD_INT 1
94916: NEG
94917: PUSH
94918: LD_INT 2
94920: PUSH
94921: EMPTY
94922: LIST
94923: LIST
94924: PUSH
94925: LD_INT 1
94927: PUSH
94928: LD_INT 4
94930: PUSH
94931: EMPTY
94932: LIST
94933: LIST
94934: PUSH
94935: LD_INT 0
94937: PUSH
94938: LD_INT 4
94940: PUSH
94941: EMPTY
94942: LIST
94943: LIST
94944: PUSH
94945: LD_INT 1
94947: NEG
94948: PUSH
94949: LD_INT 3
94951: PUSH
94952: EMPTY
94953: LIST
94954: LIST
94955: PUSH
94956: LD_INT 1
94958: PUSH
94959: LD_INT 5
94961: PUSH
94962: EMPTY
94963: LIST
94964: LIST
94965: PUSH
94966: LD_INT 0
94968: PUSH
94969: LD_INT 5
94971: PUSH
94972: EMPTY
94973: LIST
94974: LIST
94975: PUSH
94976: LD_INT 1
94978: NEG
94979: PUSH
94980: LD_INT 4
94982: PUSH
94983: EMPTY
94984: LIST
94985: LIST
94986: PUSH
94987: LD_INT 1
94989: PUSH
94990: LD_INT 6
94992: PUSH
94993: EMPTY
94994: LIST
94995: LIST
94996: PUSH
94997: LD_INT 0
94999: PUSH
95000: LD_INT 6
95002: PUSH
95003: EMPTY
95004: LIST
95005: LIST
95006: PUSH
95007: LD_INT 1
95009: NEG
95010: PUSH
95011: LD_INT 5
95013: PUSH
95014: EMPTY
95015: LIST
95016: LIST
95017: PUSH
95018: EMPTY
95019: LIST
95020: LIST
95021: LIST
95022: LIST
95023: LIST
95024: LIST
95025: LIST
95026: LIST
95027: LIST
95028: LIST
95029: LIST
95030: LIST
95031: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
95032: LD_ADDR_VAR 0 33
95036: PUSH
95037: LD_INT 2
95039: NEG
95040: PUSH
95041: LD_INT 1
95043: PUSH
95044: EMPTY
95045: LIST
95046: LIST
95047: PUSH
95048: LD_INT 3
95050: NEG
95051: PUSH
95052: LD_INT 0
95054: PUSH
95055: EMPTY
95056: LIST
95057: LIST
95058: PUSH
95059: LD_INT 3
95061: NEG
95062: PUSH
95063: LD_INT 1
95065: NEG
95066: PUSH
95067: EMPTY
95068: LIST
95069: LIST
95070: PUSH
95071: LD_INT 3
95073: NEG
95074: PUSH
95075: LD_INT 1
95077: PUSH
95078: EMPTY
95079: LIST
95080: LIST
95081: PUSH
95082: LD_INT 4
95084: NEG
95085: PUSH
95086: LD_INT 0
95088: PUSH
95089: EMPTY
95090: LIST
95091: LIST
95092: PUSH
95093: LD_INT 4
95095: NEG
95096: PUSH
95097: LD_INT 1
95099: NEG
95100: PUSH
95101: EMPTY
95102: LIST
95103: LIST
95104: PUSH
95105: LD_INT 4
95107: NEG
95108: PUSH
95109: LD_INT 1
95111: PUSH
95112: EMPTY
95113: LIST
95114: LIST
95115: PUSH
95116: LD_INT 5
95118: NEG
95119: PUSH
95120: LD_INT 0
95122: PUSH
95123: EMPTY
95124: LIST
95125: LIST
95126: PUSH
95127: LD_INT 5
95129: NEG
95130: PUSH
95131: LD_INT 1
95133: NEG
95134: PUSH
95135: EMPTY
95136: LIST
95137: LIST
95138: PUSH
95139: LD_INT 5
95141: NEG
95142: PUSH
95143: LD_INT 1
95145: PUSH
95146: EMPTY
95147: LIST
95148: LIST
95149: PUSH
95150: LD_INT 6
95152: NEG
95153: PUSH
95154: LD_INT 0
95156: PUSH
95157: EMPTY
95158: LIST
95159: LIST
95160: PUSH
95161: LD_INT 6
95163: NEG
95164: PUSH
95165: LD_INT 1
95167: NEG
95168: PUSH
95169: EMPTY
95170: LIST
95171: LIST
95172: PUSH
95173: EMPTY
95174: LIST
95175: LIST
95176: LIST
95177: LIST
95178: LIST
95179: LIST
95180: LIST
95181: LIST
95182: LIST
95183: LIST
95184: LIST
95185: LIST
95186: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
95187: LD_ADDR_VAR 0 34
95191: PUSH
95192: LD_INT 2
95194: NEG
95195: PUSH
95196: LD_INT 3
95198: NEG
95199: PUSH
95200: EMPTY
95201: LIST
95202: LIST
95203: PUSH
95204: LD_INT 3
95206: NEG
95207: PUSH
95208: LD_INT 2
95210: NEG
95211: PUSH
95212: EMPTY
95213: LIST
95214: LIST
95215: PUSH
95216: LD_INT 3
95218: NEG
95219: PUSH
95220: LD_INT 3
95222: NEG
95223: PUSH
95224: EMPTY
95225: LIST
95226: LIST
95227: PUSH
95228: LD_INT 3
95230: NEG
95231: PUSH
95232: LD_INT 4
95234: NEG
95235: PUSH
95236: EMPTY
95237: LIST
95238: LIST
95239: PUSH
95240: LD_INT 4
95242: NEG
95243: PUSH
95244: LD_INT 3
95246: NEG
95247: PUSH
95248: EMPTY
95249: LIST
95250: LIST
95251: PUSH
95252: LD_INT 4
95254: NEG
95255: PUSH
95256: LD_INT 4
95258: NEG
95259: PUSH
95260: EMPTY
95261: LIST
95262: LIST
95263: PUSH
95264: LD_INT 4
95266: NEG
95267: PUSH
95268: LD_INT 5
95270: NEG
95271: PUSH
95272: EMPTY
95273: LIST
95274: LIST
95275: PUSH
95276: LD_INT 5
95278: NEG
95279: PUSH
95280: LD_INT 4
95282: NEG
95283: PUSH
95284: EMPTY
95285: LIST
95286: LIST
95287: PUSH
95288: LD_INT 5
95290: NEG
95291: PUSH
95292: LD_INT 5
95294: NEG
95295: PUSH
95296: EMPTY
95297: LIST
95298: LIST
95299: PUSH
95300: LD_INT 5
95302: NEG
95303: PUSH
95304: LD_INT 6
95306: NEG
95307: PUSH
95308: EMPTY
95309: LIST
95310: LIST
95311: PUSH
95312: LD_INT 6
95314: NEG
95315: PUSH
95316: LD_INT 5
95318: NEG
95319: PUSH
95320: EMPTY
95321: LIST
95322: LIST
95323: PUSH
95324: LD_INT 6
95326: NEG
95327: PUSH
95328: LD_INT 6
95330: NEG
95331: PUSH
95332: EMPTY
95333: LIST
95334: LIST
95335: PUSH
95336: EMPTY
95337: LIST
95338: LIST
95339: LIST
95340: LIST
95341: LIST
95342: LIST
95343: LIST
95344: LIST
95345: LIST
95346: LIST
95347: LIST
95348: LIST
95349: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
95350: LD_ADDR_VAR 0 41
95354: PUSH
95355: LD_INT 0
95357: PUSH
95358: LD_INT 2
95360: NEG
95361: PUSH
95362: EMPTY
95363: LIST
95364: LIST
95365: PUSH
95366: LD_INT 1
95368: NEG
95369: PUSH
95370: LD_INT 3
95372: NEG
95373: PUSH
95374: EMPTY
95375: LIST
95376: LIST
95377: PUSH
95378: LD_INT 1
95380: PUSH
95381: LD_INT 2
95383: NEG
95384: PUSH
95385: EMPTY
95386: LIST
95387: LIST
95388: PUSH
95389: EMPTY
95390: LIST
95391: LIST
95392: LIST
95393: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
95394: LD_ADDR_VAR 0 42
95398: PUSH
95399: LD_INT 2
95401: PUSH
95402: LD_INT 0
95404: PUSH
95405: EMPTY
95406: LIST
95407: LIST
95408: PUSH
95409: LD_INT 2
95411: PUSH
95412: LD_INT 1
95414: NEG
95415: PUSH
95416: EMPTY
95417: LIST
95418: LIST
95419: PUSH
95420: LD_INT 3
95422: PUSH
95423: LD_INT 1
95425: PUSH
95426: EMPTY
95427: LIST
95428: LIST
95429: PUSH
95430: EMPTY
95431: LIST
95432: LIST
95433: LIST
95434: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
95435: LD_ADDR_VAR 0 43
95439: PUSH
95440: LD_INT 2
95442: PUSH
95443: LD_INT 2
95445: PUSH
95446: EMPTY
95447: LIST
95448: LIST
95449: PUSH
95450: LD_INT 3
95452: PUSH
95453: LD_INT 2
95455: PUSH
95456: EMPTY
95457: LIST
95458: LIST
95459: PUSH
95460: LD_INT 2
95462: PUSH
95463: LD_INT 3
95465: PUSH
95466: EMPTY
95467: LIST
95468: LIST
95469: PUSH
95470: EMPTY
95471: LIST
95472: LIST
95473: LIST
95474: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
95475: LD_ADDR_VAR 0 44
95479: PUSH
95480: LD_INT 0
95482: PUSH
95483: LD_INT 2
95485: PUSH
95486: EMPTY
95487: LIST
95488: LIST
95489: PUSH
95490: LD_INT 1
95492: PUSH
95493: LD_INT 3
95495: PUSH
95496: EMPTY
95497: LIST
95498: LIST
95499: PUSH
95500: LD_INT 1
95502: NEG
95503: PUSH
95504: LD_INT 2
95506: PUSH
95507: EMPTY
95508: LIST
95509: LIST
95510: PUSH
95511: EMPTY
95512: LIST
95513: LIST
95514: LIST
95515: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
95516: LD_ADDR_VAR 0 45
95520: PUSH
95521: LD_INT 2
95523: NEG
95524: PUSH
95525: LD_INT 0
95527: PUSH
95528: EMPTY
95529: LIST
95530: LIST
95531: PUSH
95532: LD_INT 2
95534: NEG
95535: PUSH
95536: LD_INT 1
95538: PUSH
95539: EMPTY
95540: LIST
95541: LIST
95542: PUSH
95543: LD_INT 3
95545: NEG
95546: PUSH
95547: LD_INT 1
95549: NEG
95550: PUSH
95551: EMPTY
95552: LIST
95553: LIST
95554: PUSH
95555: EMPTY
95556: LIST
95557: LIST
95558: LIST
95559: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
95560: LD_ADDR_VAR 0 46
95564: PUSH
95565: LD_INT 2
95567: NEG
95568: PUSH
95569: LD_INT 2
95571: NEG
95572: PUSH
95573: EMPTY
95574: LIST
95575: LIST
95576: PUSH
95577: LD_INT 2
95579: NEG
95580: PUSH
95581: LD_INT 3
95583: NEG
95584: PUSH
95585: EMPTY
95586: LIST
95587: LIST
95588: PUSH
95589: LD_INT 3
95591: NEG
95592: PUSH
95593: LD_INT 2
95595: NEG
95596: PUSH
95597: EMPTY
95598: LIST
95599: LIST
95600: PUSH
95601: EMPTY
95602: LIST
95603: LIST
95604: LIST
95605: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
95606: LD_ADDR_VAR 0 47
95610: PUSH
95611: LD_INT 2
95613: NEG
95614: PUSH
95615: LD_INT 3
95617: NEG
95618: PUSH
95619: EMPTY
95620: LIST
95621: LIST
95622: PUSH
95623: LD_INT 1
95625: NEG
95626: PUSH
95627: LD_INT 3
95629: NEG
95630: PUSH
95631: EMPTY
95632: LIST
95633: LIST
95634: PUSH
95635: EMPTY
95636: LIST
95637: LIST
95638: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
95639: LD_ADDR_VAR 0 48
95643: PUSH
95644: LD_INT 1
95646: PUSH
95647: LD_INT 2
95649: NEG
95650: PUSH
95651: EMPTY
95652: LIST
95653: LIST
95654: PUSH
95655: LD_INT 2
95657: PUSH
95658: LD_INT 1
95660: NEG
95661: PUSH
95662: EMPTY
95663: LIST
95664: LIST
95665: PUSH
95666: EMPTY
95667: LIST
95668: LIST
95669: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
95670: LD_ADDR_VAR 0 49
95674: PUSH
95675: LD_INT 3
95677: PUSH
95678: LD_INT 1
95680: PUSH
95681: EMPTY
95682: LIST
95683: LIST
95684: PUSH
95685: LD_INT 3
95687: PUSH
95688: LD_INT 2
95690: PUSH
95691: EMPTY
95692: LIST
95693: LIST
95694: PUSH
95695: EMPTY
95696: LIST
95697: LIST
95698: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
95699: LD_ADDR_VAR 0 50
95703: PUSH
95704: LD_INT 2
95706: PUSH
95707: LD_INT 3
95709: PUSH
95710: EMPTY
95711: LIST
95712: LIST
95713: PUSH
95714: LD_INT 1
95716: PUSH
95717: LD_INT 3
95719: PUSH
95720: EMPTY
95721: LIST
95722: LIST
95723: PUSH
95724: EMPTY
95725: LIST
95726: LIST
95727: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
95728: LD_ADDR_VAR 0 51
95732: PUSH
95733: LD_INT 1
95735: NEG
95736: PUSH
95737: LD_INT 2
95739: PUSH
95740: EMPTY
95741: LIST
95742: LIST
95743: PUSH
95744: LD_INT 2
95746: NEG
95747: PUSH
95748: LD_INT 1
95750: PUSH
95751: EMPTY
95752: LIST
95753: LIST
95754: PUSH
95755: EMPTY
95756: LIST
95757: LIST
95758: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
95759: LD_ADDR_VAR 0 52
95763: PUSH
95764: LD_INT 3
95766: NEG
95767: PUSH
95768: LD_INT 1
95770: NEG
95771: PUSH
95772: EMPTY
95773: LIST
95774: LIST
95775: PUSH
95776: LD_INT 3
95778: NEG
95779: PUSH
95780: LD_INT 2
95782: NEG
95783: PUSH
95784: EMPTY
95785: LIST
95786: LIST
95787: PUSH
95788: EMPTY
95789: LIST
95790: LIST
95791: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
95792: LD_ADDR_VAR 0 53
95796: PUSH
95797: LD_INT 1
95799: NEG
95800: PUSH
95801: LD_INT 3
95803: NEG
95804: PUSH
95805: EMPTY
95806: LIST
95807: LIST
95808: PUSH
95809: LD_INT 0
95811: PUSH
95812: LD_INT 3
95814: NEG
95815: PUSH
95816: EMPTY
95817: LIST
95818: LIST
95819: PUSH
95820: LD_INT 1
95822: PUSH
95823: LD_INT 2
95825: NEG
95826: PUSH
95827: EMPTY
95828: LIST
95829: LIST
95830: PUSH
95831: EMPTY
95832: LIST
95833: LIST
95834: LIST
95835: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
95836: LD_ADDR_VAR 0 54
95840: PUSH
95841: LD_INT 2
95843: PUSH
95844: LD_INT 1
95846: NEG
95847: PUSH
95848: EMPTY
95849: LIST
95850: LIST
95851: PUSH
95852: LD_INT 3
95854: PUSH
95855: LD_INT 0
95857: PUSH
95858: EMPTY
95859: LIST
95860: LIST
95861: PUSH
95862: LD_INT 3
95864: PUSH
95865: LD_INT 1
95867: PUSH
95868: EMPTY
95869: LIST
95870: LIST
95871: PUSH
95872: EMPTY
95873: LIST
95874: LIST
95875: LIST
95876: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
95877: LD_ADDR_VAR 0 55
95881: PUSH
95882: LD_INT 3
95884: PUSH
95885: LD_INT 2
95887: PUSH
95888: EMPTY
95889: LIST
95890: LIST
95891: PUSH
95892: LD_INT 3
95894: PUSH
95895: LD_INT 3
95897: PUSH
95898: EMPTY
95899: LIST
95900: LIST
95901: PUSH
95902: LD_INT 2
95904: PUSH
95905: LD_INT 3
95907: PUSH
95908: EMPTY
95909: LIST
95910: LIST
95911: PUSH
95912: EMPTY
95913: LIST
95914: LIST
95915: LIST
95916: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
95917: LD_ADDR_VAR 0 56
95921: PUSH
95922: LD_INT 1
95924: PUSH
95925: LD_INT 3
95927: PUSH
95928: EMPTY
95929: LIST
95930: LIST
95931: PUSH
95932: LD_INT 0
95934: PUSH
95935: LD_INT 3
95937: PUSH
95938: EMPTY
95939: LIST
95940: LIST
95941: PUSH
95942: LD_INT 1
95944: NEG
95945: PUSH
95946: LD_INT 2
95948: PUSH
95949: EMPTY
95950: LIST
95951: LIST
95952: PUSH
95953: EMPTY
95954: LIST
95955: LIST
95956: LIST
95957: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
95958: LD_ADDR_VAR 0 57
95962: PUSH
95963: LD_INT 2
95965: NEG
95966: PUSH
95967: LD_INT 1
95969: PUSH
95970: EMPTY
95971: LIST
95972: LIST
95973: PUSH
95974: LD_INT 3
95976: NEG
95977: PUSH
95978: LD_INT 0
95980: PUSH
95981: EMPTY
95982: LIST
95983: LIST
95984: PUSH
95985: LD_INT 3
95987: NEG
95988: PUSH
95989: LD_INT 1
95991: NEG
95992: PUSH
95993: EMPTY
95994: LIST
95995: LIST
95996: PUSH
95997: EMPTY
95998: LIST
95999: LIST
96000: LIST
96001: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
96002: LD_ADDR_VAR 0 58
96006: PUSH
96007: LD_INT 2
96009: NEG
96010: PUSH
96011: LD_INT 3
96013: NEG
96014: PUSH
96015: EMPTY
96016: LIST
96017: LIST
96018: PUSH
96019: LD_INT 3
96021: NEG
96022: PUSH
96023: LD_INT 2
96025: NEG
96026: PUSH
96027: EMPTY
96028: LIST
96029: LIST
96030: PUSH
96031: LD_INT 3
96033: NEG
96034: PUSH
96035: LD_INT 3
96037: NEG
96038: PUSH
96039: EMPTY
96040: LIST
96041: LIST
96042: PUSH
96043: EMPTY
96044: LIST
96045: LIST
96046: LIST
96047: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
96048: LD_ADDR_VAR 0 59
96052: PUSH
96053: LD_INT 1
96055: NEG
96056: PUSH
96057: LD_INT 2
96059: NEG
96060: PUSH
96061: EMPTY
96062: LIST
96063: LIST
96064: PUSH
96065: LD_INT 0
96067: PUSH
96068: LD_INT 2
96070: NEG
96071: PUSH
96072: EMPTY
96073: LIST
96074: LIST
96075: PUSH
96076: LD_INT 1
96078: PUSH
96079: LD_INT 1
96081: NEG
96082: PUSH
96083: EMPTY
96084: LIST
96085: LIST
96086: PUSH
96087: EMPTY
96088: LIST
96089: LIST
96090: LIST
96091: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
96092: LD_ADDR_VAR 0 60
96096: PUSH
96097: LD_INT 1
96099: PUSH
96100: LD_INT 1
96102: NEG
96103: PUSH
96104: EMPTY
96105: LIST
96106: LIST
96107: PUSH
96108: LD_INT 2
96110: PUSH
96111: LD_INT 0
96113: PUSH
96114: EMPTY
96115: LIST
96116: LIST
96117: PUSH
96118: LD_INT 2
96120: PUSH
96121: LD_INT 1
96123: PUSH
96124: EMPTY
96125: LIST
96126: LIST
96127: PUSH
96128: EMPTY
96129: LIST
96130: LIST
96131: LIST
96132: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
96133: LD_ADDR_VAR 0 61
96137: PUSH
96138: LD_INT 2
96140: PUSH
96141: LD_INT 1
96143: PUSH
96144: EMPTY
96145: LIST
96146: LIST
96147: PUSH
96148: LD_INT 2
96150: PUSH
96151: LD_INT 2
96153: PUSH
96154: EMPTY
96155: LIST
96156: LIST
96157: PUSH
96158: LD_INT 1
96160: PUSH
96161: LD_INT 2
96163: PUSH
96164: EMPTY
96165: LIST
96166: LIST
96167: PUSH
96168: EMPTY
96169: LIST
96170: LIST
96171: LIST
96172: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
96173: LD_ADDR_VAR 0 62
96177: PUSH
96178: LD_INT 1
96180: PUSH
96181: LD_INT 2
96183: PUSH
96184: EMPTY
96185: LIST
96186: LIST
96187: PUSH
96188: LD_INT 0
96190: PUSH
96191: LD_INT 2
96193: PUSH
96194: EMPTY
96195: LIST
96196: LIST
96197: PUSH
96198: LD_INT 1
96200: NEG
96201: PUSH
96202: LD_INT 1
96204: PUSH
96205: EMPTY
96206: LIST
96207: LIST
96208: PUSH
96209: EMPTY
96210: LIST
96211: LIST
96212: LIST
96213: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
96214: LD_ADDR_VAR 0 63
96218: PUSH
96219: LD_INT 1
96221: NEG
96222: PUSH
96223: LD_INT 1
96225: PUSH
96226: EMPTY
96227: LIST
96228: LIST
96229: PUSH
96230: LD_INT 2
96232: NEG
96233: PUSH
96234: LD_INT 0
96236: PUSH
96237: EMPTY
96238: LIST
96239: LIST
96240: PUSH
96241: LD_INT 2
96243: NEG
96244: PUSH
96245: LD_INT 1
96247: NEG
96248: PUSH
96249: EMPTY
96250: LIST
96251: LIST
96252: PUSH
96253: EMPTY
96254: LIST
96255: LIST
96256: LIST
96257: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
96258: LD_ADDR_VAR 0 64
96262: PUSH
96263: LD_INT 1
96265: NEG
96266: PUSH
96267: LD_INT 2
96269: NEG
96270: PUSH
96271: EMPTY
96272: LIST
96273: LIST
96274: PUSH
96275: LD_INT 2
96277: NEG
96278: PUSH
96279: LD_INT 1
96281: NEG
96282: PUSH
96283: EMPTY
96284: LIST
96285: LIST
96286: PUSH
96287: LD_INT 2
96289: NEG
96290: PUSH
96291: LD_INT 2
96293: NEG
96294: PUSH
96295: EMPTY
96296: LIST
96297: LIST
96298: PUSH
96299: EMPTY
96300: LIST
96301: LIST
96302: LIST
96303: ST_TO_ADDR
// end ; 2 :
96304: GO 99570
96306: LD_INT 2
96308: DOUBLE
96309: EQUAL
96310: IFTRUE 96314
96312: GO 99569
96314: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
96315: LD_ADDR_VAR 0 29
96319: PUSH
96320: LD_INT 4
96322: PUSH
96323: LD_INT 0
96325: PUSH
96326: EMPTY
96327: LIST
96328: LIST
96329: PUSH
96330: LD_INT 4
96332: PUSH
96333: LD_INT 1
96335: NEG
96336: PUSH
96337: EMPTY
96338: LIST
96339: LIST
96340: PUSH
96341: LD_INT 5
96343: PUSH
96344: LD_INT 0
96346: PUSH
96347: EMPTY
96348: LIST
96349: LIST
96350: PUSH
96351: LD_INT 5
96353: PUSH
96354: LD_INT 1
96356: PUSH
96357: EMPTY
96358: LIST
96359: LIST
96360: PUSH
96361: LD_INT 4
96363: PUSH
96364: LD_INT 1
96366: PUSH
96367: EMPTY
96368: LIST
96369: LIST
96370: PUSH
96371: LD_INT 3
96373: PUSH
96374: LD_INT 0
96376: PUSH
96377: EMPTY
96378: LIST
96379: LIST
96380: PUSH
96381: LD_INT 3
96383: PUSH
96384: LD_INT 1
96386: NEG
96387: PUSH
96388: EMPTY
96389: LIST
96390: LIST
96391: PUSH
96392: LD_INT 3
96394: PUSH
96395: LD_INT 2
96397: NEG
96398: PUSH
96399: EMPTY
96400: LIST
96401: LIST
96402: PUSH
96403: LD_INT 5
96405: PUSH
96406: LD_INT 2
96408: PUSH
96409: EMPTY
96410: LIST
96411: LIST
96412: PUSH
96413: LD_INT 3
96415: PUSH
96416: LD_INT 3
96418: PUSH
96419: EMPTY
96420: LIST
96421: LIST
96422: PUSH
96423: LD_INT 3
96425: PUSH
96426: LD_INT 2
96428: PUSH
96429: EMPTY
96430: LIST
96431: LIST
96432: PUSH
96433: LD_INT 4
96435: PUSH
96436: LD_INT 3
96438: PUSH
96439: EMPTY
96440: LIST
96441: LIST
96442: PUSH
96443: LD_INT 4
96445: PUSH
96446: LD_INT 4
96448: PUSH
96449: EMPTY
96450: LIST
96451: LIST
96452: PUSH
96453: LD_INT 3
96455: PUSH
96456: LD_INT 4
96458: PUSH
96459: EMPTY
96460: LIST
96461: LIST
96462: PUSH
96463: LD_INT 2
96465: PUSH
96466: LD_INT 3
96468: PUSH
96469: EMPTY
96470: LIST
96471: LIST
96472: PUSH
96473: LD_INT 2
96475: PUSH
96476: LD_INT 2
96478: PUSH
96479: EMPTY
96480: LIST
96481: LIST
96482: PUSH
96483: LD_INT 4
96485: PUSH
96486: LD_INT 2
96488: PUSH
96489: EMPTY
96490: LIST
96491: LIST
96492: PUSH
96493: LD_INT 2
96495: PUSH
96496: LD_INT 4
96498: PUSH
96499: EMPTY
96500: LIST
96501: LIST
96502: PUSH
96503: LD_INT 0
96505: PUSH
96506: LD_INT 4
96508: PUSH
96509: EMPTY
96510: LIST
96511: LIST
96512: PUSH
96513: LD_INT 0
96515: PUSH
96516: LD_INT 3
96518: PUSH
96519: EMPTY
96520: LIST
96521: LIST
96522: PUSH
96523: LD_INT 1
96525: PUSH
96526: LD_INT 4
96528: PUSH
96529: EMPTY
96530: LIST
96531: LIST
96532: PUSH
96533: LD_INT 1
96535: PUSH
96536: LD_INT 5
96538: PUSH
96539: EMPTY
96540: LIST
96541: LIST
96542: PUSH
96543: LD_INT 0
96545: PUSH
96546: LD_INT 5
96548: PUSH
96549: EMPTY
96550: LIST
96551: LIST
96552: PUSH
96553: LD_INT 1
96555: NEG
96556: PUSH
96557: LD_INT 4
96559: PUSH
96560: EMPTY
96561: LIST
96562: LIST
96563: PUSH
96564: LD_INT 1
96566: NEG
96567: PUSH
96568: LD_INT 3
96570: PUSH
96571: EMPTY
96572: LIST
96573: LIST
96574: PUSH
96575: LD_INT 2
96577: PUSH
96578: LD_INT 5
96580: PUSH
96581: EMPTY
96582: LIST
96583: LIST
96584: PUSH
96585: LD_INT 2
96587: NEG
96588: PUSH
96589: LD_INT 3
96591: PUSH
96592: EMPTY
96593: LIST
96594: LIST
96595: PUSH
96596: LD_INT 3
96598: NEG
96599: PUSH
96600: LD_INT 0
96602: PUSH
96603: EMPTY
96604: LIST
96605: LIST
96606: PUSH
96607: LD_INT 3
96609: NEG
96610: PUSH
96611: LD_INT 1
96613: NEG
96614: PUSH
96615: EMPTY
96616: LIST
96617: LIST
96618: PUSH
96619: LD_INT 2
96621: NEG
96622: PUSH
96623: LD_INT 0
96625: PUSH
96626: EMPTY
96627: LIST
96628: LIST
96629: PUSH
96630: LD_INT 2
96632: NEG
96633: PUSH
96634: LD_INT 1
96636: PUSH
96637: EMPTY
96638: LIST
96639: LIST
96640: PUSH
96641: LD_INT 3
96643: NEG
96644: PUSH
96645: LD_INT 1
96647: PUSH
96648: EMPTY
96649: LIST
96650: LIST
96651: PUSH
96652: LD_INT 4
96654: NEG
96655: PUSH
96656: LD_INT 0
96658: PUSH
96659: EMPTY
96660: LIST
96661: LIST
96662: PUSH
96663: LD_INT 4
96665: NEG
96666: PUSH
96667: LD_INT 1
96669: NEG
96670: PUSH
96671: EMPTY
96672: LIST
96673: LIST
96674: PUSH
96675: LD_INT 4
96677: NEG
96678: PUSH
96679: LD_INT 2
96681: NEG
96682: PUSH
96683: EMPTY
96684: LIST
96685: LIST
96686: PUSH
96687: LD_INT 2
96689: NEG
96690: PUSH
96691: LD_INT 2
96693: PUSH
96694: EMPTY
96695: LIST
96696: LIST
96697: PUSH
96698: LD_INT 4
96700: NEG
96701: PUSH
96702: LD_INT 4
96704: NEG
96705: PUSH
96706: EMPTY
96707: LIST
96708: LIST
96709: PUSH
96710: LD_INT 4
96712: NEG
96713: PUSH
96714: LD_INT 5
96716: NEG
96717: PUSH
96718: EMPTY
96719: LIST
96720: LIST
96721: PUSH
96722: LD_INT 3
96724: NEG
96725: PUSH
96726: LD_INT 4
96728: NEG
96729: PUSH
96730: EMPTY
96731: LIST
96732: LIST
96733: PUSH
96734: LD_INT 3
96736: NEG
96737: PUSH
96738: LD_INT 3
96740: NEG
96741: PUSH
96742: EMPTY
96743: LIST
96744: LIST
96745: PUSH
96746: LD_INT 4
96748: NEG
96749: PUSH
96750: LD_INT 3
96752: NEG
96753: PUSH
96754: EMPTY
96755: LIST
96756: LIST
96757: PUSH
96758: LD_INT 5
96760: NEG
96761: PUSH
96762: LD_INT 4
96764: NEG
96765: PUSH
96766: EMPTY
96767: LIST
96768: LIST
96769: PUSH
96770: LD_INT 5
96772: NEG
96773: PUSH
96774: LD_INT 5
96776: NEG
96777: PUSH
96778: EMPTY
96779: LIST
96780: LIST
96781: PUSH
96782: LD_INT 3
96784: NEG
96785: PUSH
96786: LD_INT 5
96788: NEG
96789: PUSH
96790: EMPTY
96791: LIST
96792: LIST
96793: PUSH
96794: LD_INT 5
96796: NEG
96797: PUSH
96798: LD_INT 3
96800: NEG
96801: PUSH
96802: EMPTY
96803: LIST
96804: LIST
96805: PUSH
96806: EMPTY
96807: LIST
96808: LIST
96809: LIST
96810: LIST
96811: LIST
96812: LIST
96813: LIST
96814: LIST
96815: LIST
96816: LIST
96817: LIST
96818: LIST
96819: LIST
96820: LIST
96821: LIST
96822: LIST
96823: LIST
96824: LIST
96825: LIST
96826: LIST
96827: LIST
96828: LIST
96829: LIST
96830: LIST
96831: LIST
96832: LIST
96833: LIST
96834: LIST
96835: LIST
96836: LIST
96837: LIST
96838: LIST
96839: LIST
96840: LIST
96841: LIST
96842: LIST
96843: LIST
96844: LIST
96845: LIST
96846: LIST
96847: LIST
96848: LIST
96849: LIST
96850: LIST
96851: LIST
96852: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
96853: LD_ADDR_VAR 0 30
96857: PUSH
96858: LD_INT 4
96860: PUSH
96861: LD_INT 4
96863: PUSH
96864: EMPTY
96865: LIST
96866: LIST
96867: PUSH
96868: LD_INT 4
96870: PUSH
96871: LD_INT 3
96873: PUSH
96874: EMPTY
96875: LIST
96876: LIST
96877: PUSH
96878: LD_INT 5
96880: PUSH
96881: LD_INT 4
96883: PUSH
96884: EMPTY
96885: LIST
96886: LIST
96887: PUSH
96888: LD_INT 5
96890: PUSH
96891: LD_INT 5
96893: PUSH
96894: EMPTY
96895: LIST
96896: LIST
96897: PUSH
96898: LD_INT 4
96900: PUSH
96901: LD_INT 5
96903: PUSH
96904: EMPTY
96905: LIST
96906: LIST
96907: PUSH
96908: LD_INT 3
96910: PUSH
96911: LD_INT 4
96913: PUSH
96914: EMPTY
96915: LIST
96916: LIST
96917: PUSH
96918: LD_INT 3
96920: PUSH
96921: LD_INT 3
96923: PUSH
96924: EMPTY
96925: LIST
96926: LIST
96927: PUSH
96928: LD_INT 5
96930: PUSH
96931: LD_INT 3
96933: PUSH
96934: EMPTY
96935: LIST
96936: LIST
96937: PUSH
96938: LD_INT 3
96940: PUSH
96941: LD_INT 5
96943: PUSH
96944: EMPTY
96945: LIST
96946: LIST
96947: PUSH
96948: LD_INT 0
96950: PUSH
96951: LD_INT 3
96953: PUSH
96954: EMPTY
96955: LIST
96956: LIST
96957: PUSH
96958: LD_INT 0
96960: PUSH
96961: LD_INT 2
96963: PUSH
96964: EMPTY
96965: LIST
96966: LIST
96967: PUSH
96968: LD_INT 1
96970: PUSH
96971: LD_INT 3
96973: PUSH
96974: EMPTY
96975: LIST
96976: LIST
96977: PUSH
96978: LD_INT 1
96980: PUSH
96981: LD_INT 4
96983: PUSH
96984: EMPTY
96985: LIST
96986: LIST
96987: PUSH
96988: LD_INT 0
96990: PUSH
96991: LD_INT 4
96993: PUSH
96994: EMPTY
96995: LIST
96996: LIST
96997: PUSH
96998: LD_INT 1
97000: NEG
97001: PUSH
97002: LD_INT 3
97004: PUSH
97005: EMPTY
97006: LIST
97007: LIST
97008: PUSH
97009: LD_INT 1
97011: NEG
97012: PUSH
97013: LD_INT 2
97015: PUSH
97016: EMPTY
97017: LIST
97018: LIST
97019: PUSH
97020: LD_INT 2
97022: PUSH
97023: LD_INT 4
97025: PUSH
97026: EMPTY
97027: LIST
97028: LIST
97029: PUSH
97030: LD_INT 2
97032: NEG
97033: PUSH
97034: LD_INT 2
97036: PUSH
97037: EMPTY
97038: LIST
97039: LIST
97040: PUSH
97041: LD_INT 4
97043: NEG
97044: PUSH
97045: LD_INT 0
97047: PUSH
97048: EMPTY
97049: LIST
97050: LIST
97051: PUSH
97052: LD_INT 4
97054: NEG
97055: PUSH
97056: LD_INT 1
97058: NEG
97059: PUSH
97060: EMPTY
97061: LIST
97062: LIST
97063: PUSH
97064: LD_INT 3
97066: NEG
97067: PUSH
97068: LD_INT 0
97070: PUSH
97071: EMPTY
97072: LIST
97073: LIST
97074: PUSH
97075: LD_INT 3
97077: NEG
97078: PUSH
97079: LD_INT 1
97081: PUSH
97082: EMPTY
97083: LIST
97084: LIST
97085: PUSH
97086: LD_INT 4
97088: NEG
97089: PUSH
97090: LD_INT 1
97092: PUSH
97093: EMPTY
97094: LIST
97095: LIST
97096: PUSH
97097: LD_INT 5
97099: NEG
97100: PUSH
97101: LD_INT 0
97103: PUSH
97104: EMPTY
97105: LIST
97106: LIST
97107: PUSH
97108: LD_INT 5
97110: NEG
97111: PUSH
97112: LD_INT 1
97114: NEG
97115: PUSH
97116: EMPTY
97117: LIST
97118: LIST
97119: PUSH
97120: LD_INT 5
97122: NEG
97123: PUSH
97124: LD_INT 2
97126: NEG
97127: PUSH
97128: EMPTY
97129: LIST
97130: LIST
97131: PUSH
97132: LD_INT 3
97134: NEG
97135: PUSH
97136: LD_INT 2
97138: PUSH
97139: EMPTY
97140: LIST
97141: LIST
97142: PUSH
97143: LD_INT 3
97145: NEG
97146: PUSH
97147: LD_INT 3
97149: NEG
97150: PUSH
97151: EMPTY
97152: LIST
97153: LIST
97154: PUSH
97155: LD_INT 3
97157: NEG
97158: PUSH
97159: LD_INT 4
97161: NEG
97162: PUSH
97163: EMPTY
97164: LIST
97165: LIST
97166: PUSH
97167: LD_INT 2
97169: NEG
97170: PUSH
97171: LD_INT 3
97173: NEG
97174: PUSH
97175: EMPTY
97176: LIST
97177: LIST
97178: PUSH
97179: LD_INT 2
97181: NEG
97182: PUSH
97183: LD_INT 2
97185: NEG
97186: PUSH
97187: EMPTY
97188: LIST
97189: LIST
97190: PUSH
97191: LD_INT 3
97193: NEG
97194: PUSH
97195: LD_INT 2
97197: NEG
97198: PUSH
97199: EMPTY
97200: LIST
97201: LIST
97202: PUSH
97203: LD_INT 4
97205: NEG
97206: PUSH
97207: LD_INT 3
97209: NEG
97210: PUSH
97211: EMPTY
97212: LIST
97213: LIST
97214: PUSH
97215: LD_INT 4
97217: NEG
97218: PUSH
97219: LD_INT 4
97221: NEG
97222: PUSH
97223: EMPTY
97224: LIST
97225: LIST
97226: PUSH
97227: LD_INT 2
97229: NEG
97230: PUSH
97231: LD_INT 4
97233: NEG
97234: PUSH
97235: EMPTY
97236: LIST
97237: LIST
97238: PUSH
97239: LD_INT 4
97241: NEG
97242: PUSH
97243: LD_INT 2
97245: NEG
97246: PUSH
97247: EMPTY
97248: LIST
97249: LIST
97250: PUSH
97251: LD_INT 0
97253: PUSH
97254: LD_INT 4
97256: NEG
97257: PUSH
97258: EMPTY
97259: LIST
97260: LIST
97261: PUSH
97262: LD_INT 0
97264: PUSH
97265: LD_INT 5
97267: NEG
97268: PUSH
97269: EMPTY
97270: LIST
97271: LIST
97272: PUSH
97273: LD_INT 1
97275: PUSH
97276: LD_INT 4
97278: NEG
97279: PUSH
97280: EMPTY
97281: LIST
97282: LIST
97283: PUSH
97284: LD_INT 1
97286: PUSH
97287: LD_INT 3
97289: NEG
97290: PUSH
97291: EMPTY
97292: LIST
97293: LIST
97294: PUSH
97295: LD_INT 0
97297: PUSH
97298: LD_INT 3
97300: NEG
97301: PUSH
97302: EMPTY
97303: LIST
97304: LIST
97305: PUSH
97306: LD_INT 1
97308: NEG
97309: PUSH
97310: LD_INT 4
97312: NEG
97313: PUSH
97314: EMPTY
97315: LIST
97316: LIST
97317: PUSH
97318: LD_INT 1
97320: NEG
97321: PUSH
97322: LD_INT 5
97324: NEG
97325: PUSH
97326: EMPTY
97327: LIST
97328: LIST
97329: PUSH
97330: LD_INT 2
97332: PUSH
97333: LD_INT 3
97335: NEG
97336: PUSH
97337: EMPTY
97338: LIST
97339: LIST
97340: PUSH
97341: LD_INT 2
97343: NEG
97344: PUSH
97345: LD_INT 5
97347: NEG
97348: PUSH
97349: EMPTY
97350: LIST
97351: LIST
97352: PUSH
97353: EMPTY
97354: LIST
97355: LIST
97356: LIST
97357: LIST
97358: LIST
97359: LIST
97360: LIST
97361: LIST
97362: LIST
97363: LIST
97364: LIST
97365: LIST
97366: LIST
97367: LIST
97368: LIST
97369: LIST
97370: LIST
97371: LIST
97372: LIST
97373: LIST
97374: LIST
97375: LIST
97376: LIST
97377: LIST
97378: LIST
97379: LIST
97380: LIST
97381: LIST
97382: LIST
97383: LIST
97384: LIST
97385: LIST
97386: LIST
97387: LIST
97388: LIST
97389: LIST
97390: LIST
97391: LIST
97392: LIST
97393: LIST
97394: LIST
97395: LIST
97396: LIST
97397: LIST
97398: LIST
97399: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
97400: LD_ADDR_VAR 0 31
97404: PUSH
97405: LD_INT 0
97407: PUSH
97408: LD_INT 4
97410: PUSH
97411: EMPTY
97412: LIST
97413: LIST
97414: PUSH
97415: LD_INT 0
97417: PUSH
97418: LD_INT 3
97420: PUSH
97421: EMPTY
97422: LIST
97423: LIST
97424: PUSH
97425: LD_INT 1
97427: PUSH
97428: LD_INT 4
97430: PUSH
97431: EMPTY
97432: LIST
97433: LIST
97434: PUSH
97435: LD_INT 1
97437: PUSH
97438: LD_INT 5
97440: PUSH
97441: EMPTY
97442: LIST
97443: LIST
97444: PUSH
97445: LD_INT 0
97447: PUSH
97448: LD_INT 5
97450: PUSH
97451: EMPTY
97452: LIST
97453: LIST
97454: PUSH
97455: LD_INT 1
97457: NEG
97458: PUSH
97459: LD_INT 4
97461: PUSH
97462: EMPTY
97463: LIST
97464: LIST
97465: PUSH
97466: LD_INT 1
97468: NEG
97469: PUSH
97470: LD_INT 3
97472: PUSH
97473: EMPTY
97474: LIST
97475: LIST
97476: PUSH
97477: LD_INT 2
97479: PUSH
97480: LD_INT 5
97482: PUSH
97483: EMPTY
97484: LIST
97485: LIST
97486: PUSH
97487: LD_INT 2
97489: NEG
97490: PUSH
97491: LD_INT 3
97493: PUSH
97494: EMPTY
97495: LIST
97496: LIST
97497: PUSH
97498: LD_INT 3
97500: NEG
97501: PUSH
97502: LD_INT 0
97504: PUSH
97505: EMPTY
97506: LIST
97507: LIST
97508: PUSH
97509: LD_INT 3
97511: NEG
97512: PUSH
97513: LD_INT 1
97515: NEG
97516: PUSH
97517: EMPTY
97518: LIST
97519: LIST
97520: PUSH
97521: LD_INT 2
97523: NEG
97524: PUSH
97525: LD_INT 0
97527: PUSH
97528: EMPTY
97529: LIST
97530: LIST
97531: PUSH
97532: LD_INT 2
97534: NEG
97535: PUSH
97536: LD_INT 1
97538: PUSH
97539: EMPTY
97540: LIST
97541: LIST
97542: PUSH
97543: LD_INT 3
97545: NEG
97546: PUSH
97547: LD_INT 1
97549: PUSH
97550: EMPTY
97551: LIST
97552: LIST
97553: PUSH
97554: LD_INT 4
97556: NEG
97557: PUSH
97558: LD_INT 0
97560: PUSH
97561: EMPTY
97562: LIST
97563: LIST
97564: PUSH
97565: LD_INT 4
97567: NEG
97568: PUSH
97569: LD_INT 1
97571: NEG
97572: PUSH
97573: EMPTY
97574: LIST
97575: LIST
97576: PUSH
97577: LD_INT 4
97579: NEG
97580: PUSH
97581: LD_INT 2
97583: NEG
97584: PUSH
97585: EMPTY
97586: LIST
97587: LIST
97588: PUSH
97589: LD_INT 2
97591: NEG
97592: PUSH
97593: LD_INT 2
97595: PUSH
97596: EMPTY
97597: LIST
97598: LIST
97599: PUSH
97600: LD_INT 4
97602: NEG
97603: PUSH
97604: LD_INT 4
97606: NEG
97607: PUSH
97608: EMPTY
97609: LIST
97610: LIST
97611: PUSH
97612: LD_INT 4
97614: NEG
97615: PUSH
97616: LD_INT 5
97618: NEG
97619: PUSH
97620: EMPTY
97621: LIST
97622: LIST
97623: PUSH
97624: LD_INT 3
97626: NEG
97627: PUSH
97628: LD_INT 4
97630: NEG
97631: PUSH
97632: EMPTY
97633: LIST
97634: LIST
97635: PUSH
97636: LD_INT 3
97638: NEG
97639: PUSH
97640: LD_INT 3
97642: NEG
97643: PUSH
97644: EMPTY
97645: LIST
97646: LIST
97647: PUSH
97648: LD_INT 4
97650: NEG
97651: PUSH
97652: LD_INT 3
97654: NEG
97655: PUSH
97656: EMPTY
97657: LIST
97658: LIST
97659: PUSH
97660: LD_INT 5
97662: NEG
97663: PUSH
97664: LD_INT 4
97666: NEG
97667: PUSH
97668: EMPTY
97669: LIST
97670: LIST
97671: PUSH
97672: LD_INT 5
97674: NEG
97675: PUSH
97676: LD_INT 5
97678: NEG
97679: PUSH
97680: EMPTY
97681: LIST
97682: LIST
97683: PUSH
97684: LD_INT 3
97686: NEG
97687: PUSH
97688: LD_INT 5
97690: NEG
97691: PUSH
97692: EMPTY
97693: LIST
97694: LIST
97695: PUSH
97696: LD_INT 5
97698: NEG
97699: PUSH
97700: LD_INT 3
97702: NEG
97703: PUSH
97704: EMPTY
97705: LIST
97706: LIST
97707: PUSH
97708: LD_INT 0
97710: PUSH
97711: LD_INT 3
97713: NEG
97714: PUSH
97715: EMPTY
97716: LIST
97717: LIST
97718: PUSH
97719: LD_INT 0
97721: PUSH
97722: LD_INT 4
97724: NEG
97725: PUSH
97726: EMPTY
97727: LIST
97728: LIST
97729: PUSH
97730: LD_INT 1
97732: PUSH
97733: LD_INT 3
97735: NEG
97736: PUSH
97737: EMPTY
97738: LIST
97739: LIST
97740: PUSH
97741: LD_INT 1
97743: PUSH
97744: LD_INT 2
97746: NEG
97747: PUSH
97748: EMPTY
97749: LIST
97750: LIST
97751: PUSH
97752: LD_INT 0
97754: PUSH
97755: LD_INT 2
97757: NEG
97758: PUSH
97759: EMPTY
97760: LIST
97761: LIST
97762: PUSH
97763: LD_INT 1
97765: NEG
97766: PUSH
97767: LD_INT 3
97769: NEG
97770: PUSH
97771: EMPTY
97772: LIST
97773: LIST
97774: PUSH
97775: LD_INT 1
97777: NEG
97778: PUSH
97779: LD_INT 4
97781: NEG
97782: PUSH
97783: EMPTY
97784: LIST
97785: LIST
97786: PUSH
97787: LD_INT 2
97789: PUSH
97790: LD_INT 2
97792: NEG
97793: PUSH
97794: EMPTY
97795: LIST
97796: LIST
97797: PUSH
97798: LD_INT 2
97800: NEG
97801: PUSH
97802: LD_INT 4
97804: NEG
97805: PUSH
97806: EMPTY
97807: LIST
97808: LIST
97809: PUSH
97810: LD_INT 4
97812: PUSH
97813: LD_INT 0
97815: PUSH
97816: EMPTY
97817: LIST
97818: LIST
97819: PUSH
97820: LD_INT 4
97822: PUSH
97823: LD_INT 1
97825: NEG
97826: PUSH
97827: EMPTY
97828: LIST
97829: LIST
97830: PUSH
97831: LD_INT 5
97833: PUSH
97834: LD_INT 0
97836: PUSH
97837: EMPTY
97838: LIST
97839: LIST
97840: PUSH
97841: LD_INT 5
97843: PUSH
97844: LD_INT 1
97846: PUSH
97847: EMPTY
97848: LIST
97849: LIST
97850: PUSH
97851: LD_INT 4
97853: PUSH
97854: LD_INT 1
97856: PUSH
97857: EMPTY
97858: LIST
97859: LIST
97860: PUSH
97861: LD_INT 3
97863: PUSH
97864: LD_INT 0
97866: PUSH
97867: EMPTY
97868: LIST
97869: LIST
97870: PUSH
97871: LD_INT 3
97873: PUSH
97874: LD_INT 1
97876: NEG
97877: PUSH
97878: EMPTY
97879: LIST
97880: LIST
97881: PUSH
97882: LD_INT 3
97884: PUSH
97885: LD_INT 2
97887: NEG
97888: PUSH
97889: EMPTY
97890: LIST
97891: LIST
97892: PUSH
97893: LD_INT 5
97895: PUSH
97896: LD_INT 2
97898: PUSH
97899: EMPTY
97900: LIST
97901: LIST
97902: PUSH
97903: EMPTY
97904: LIST
97905: LIST
97906: LIST
97907: LIST
97908: LIST
97909: LIST
97910: LIST
97911: LIST
97912: LIST
97913: LIST
97914: LIST
97915: LIST
97916: LIST
97917: LIST
97918: LIST
97919: LIST
97920: LIST
97921: LIST
97922: LIST
97923: LIST
97924: LIST
97925: LIST
97926: LIST
97927: LIST
97928: LIST
97929: LIST
97930: LIST
97931: LIST
97932: LIST
97933: LIST
97934: LIST
97935: LIST
97936: LIST
97937: LIST
97938: LIST
97939: LIST
97940: LIST
97941: LIST
97942: LIST
97943: LIST
97944: LIST
97945: LIST
97946: LIST
97947: LIST
97948: LIST
97949: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
97950: LD_ADDR_VAR 0 32
97954: PUSH
97955: LD_INT 4
97957: NEG
97958: PUSH
97959: LD_INT 0
97961: PUSH
97962: EMPTY
97963: LIST
97964: LIST
97965: PUSH
97966: LD_INT 4
97968: NEG
97969: PUSH
97970: LD_INT 1
97972: NEG
97973: PUSH
97974: EMPTY
97975: LIST
97976: LIST
97977: PUSH
97978: LD_INT 3
97980: NEG
97981: PUSH
97982: LD_INT 0
97984: PUSH
97985: EMPTY
97986: LIST
97987: LIST
97988: PUSH
97989: LD_INT 3
97991: NEG
97992: PUSH
97993: LD_INT 1
97995: PUSH
97996: EMPTY
97997: LIST
97998: LIST
97999: PUSH
98000: LD_INT 4
98002: NEG
98003: PUSH
98004: LD_INT 1
98006: PUSH
98007: EMPTY
98008: LIST
98009: LIST
98010: PUSH
98011: LD_INT 5
98013: NEG
98014: PUSH
98015: LD_INT 0
98017: PUSH
98018: EMPTY
98019: LIST
98020: LIST
98021: PUSH
98022: LD_INT 5
98024: NEG
98025: PUSH
98026: LD_INT 1
98028: NEG
98029: PUSH
98030: EMPTY
98031: LIST
98032: LIST
98033: PUSH
98034: LD_INT 5
98036: NEG
98037: PUSH
98038: LD_INT 2
98040: NEG
98041: PUSH
98042: EMPTY
98043: LIST
98044: LIST
98045: PUSH
98046: LD_INT 3
98048: NEG
98049: PUSH
98050: LD_INT 2
98052: PUSH
98053: EMPTY
98054: LIST
98055: LIST
98056: PUSH
98057: LD_INT 3
98059: NEG
98060: PUSH
98061: LD_INT 3
98063: NEG
98064: PUSH
98065: EMPTY
98066: LIST
98067: LIST
98068: PUSH
98069: LD_INT 3
98071: NEG
98072: PUSH
98073: LD_INT 4
98075: NEG
98076: PUSH
98077: EMPTY
98078: LIST
98079: LIST
98080: PUSH
98081: LD_INT 2
98083: NEG
98084: PUSH
98085: LD_INT 3
98087: NEG
98088: PUSH
98089: EMPTY
98090: LIST
98091: LIST
98092: PUSH
98093: LD_INT 2
98095: NEG
98096: PUSH
98097: LD_INT 2
98099: NEG
98100: PUSH
98101: EMPTY
98102: LIST
98103: LIST
98104: PUSH
98105: LD_INT 3
98107: NEG
98108: PUSH
98109: LD_INT 2
98111: NEG
98112: PUSH
98113: EMPTY
98114: LIST
98115: LIST
98116: PUSH
98117: LD_INT 4
98119: NEG
98120: PUSH
98121: LD_INT 3
98123: NEG
98124: PUSH
98125: EMPTY
98126: LIST
98127: LIST
98128: PUSH
98129: LD_INT 4
98131: NEG
98132: PUSH
98133: LD_INT 4
98135: NEG
98136: PUSH
98137: EMPTY
98138: LIST
98139: LIST
98140: PUSH
98141: LD_INT 2
98143: NEG
98144: PUSH
98145: LD_INT 4
98147: NEG
98148: PUSH
98149: EMPTY
98150: LIST
98151: LIST
98152: PUSH
98153: LD_INT 4
98155: NEG
98156: PUSH
98157: LD_INT 2
98159: NEG
98160: PUSH
98161: EMPTY
98162: LIST
98163: LIST
98164: PUSH
98165: LD_INT 0
98167: PUSH
98168: LD_INT 4
98170: NEG
98171: PUSH
98172: EMPTY
98173: LIST
98174: LIST
98175: PUSH
98176: LD_INT 0
98178: PUSH
98179: LD_INT 5
98181: NEG
98182: PUSH
98183: EMPTY
98184: LIST
98185: LIST
98186: PUSH
98187: LD_INT 1
98189: PUSH
98190: LD_INT 4
98192: NEG
98193: PUSH
98194: EMPTY
98195: LIST
98196: LIST
98197: PUSH
98198: LD_INT 1
98200: PUSH
98201: LD_INT 3
98203: NEG
98204: PUSH
98205: EMPTY
98206: LIST
98207: LIST
98208: PUSH
98209: LD_INT 0
98211: PUSH
98212: LD_INT 3
98214: NEG
98215: PUSH
98216: EMPTY
98217: LIST
98218: LIST
98219: PUSH
98220: LD_INT 1
98222: NEG
98223: PUSH
98224: LD_INT 4
98226: NEG
98227: PUSH
98228: EMPTY
98229: LIST
98230: LIST
98231: PUSH
98232: LD_INT 1
98234: NEG
98235: PUSH
98236: LD_INT 5
98238: NEG
98239: PUSH
98240: EMPTY
98241: LIST
98242: LIST
98243: PUSH
98244: LD_INT 2
98246: PUSH
98247: LD_INT 3
98249: NEG
98250: PUSH
98251: EMPTY
98252: LIST
98253: LIST
98254: PUSH
98255: LD_INT 2
98257: NEG
98258: PUSH
98259: LD_INT 5
98261: NEG
98262: PUSH
98263: EMPTY
98264: LIST
98265: LIST
98266: PUSH
98267: LD_INT 3
98269: PUSH
98270: LD_INT 0
98272: PUSH
98273: EMPTY
98274: LIST
98275: LIST
98276: PUSH
98277: LD_INT 3
98279: PUSH
98280: LD_INT 1
98282: NEG
98283: PUSH
98284: EMPTY
98285: LIST
98286: LIST
98287: PUSH
98288: LD_INT 4
98290: PUSH
98291: LD_INT 0
98293: PUSH
98294: EMPTY
98295: LIST
98296: LIST
98297: PUSH
98298: LD_INT 4
98300: PUSH
98301: LD_INT 1
98303: PUSH
98304: EMPTY
98305: LIST
98306: LIST
98307: PUSH
98308: LD_INT 3
98310: PUSH
98311: LD_INT 1
98313: PUSH
98314: EMPTY
98315: LIST
98316: LIST
98317: PUSH
98318: LD_INT 2
98320: PUSH
98321: LD_INT 0
98323: PUSH
98324: EMPTY
98325: LIST
98326: LIST
98327: PUSH
98328: LD_INT 2
98330: PUSH
98331: LD_INT 1
98333: NEG
98334: PUSH
98335: EMPTY
98336: LIST
98337: LIST
98338: PUSH
98339: LD_INT 2
98341: PUSH
98342: LD_INT 2
98344: NEG
98345: PUSH
98346: EMPTY
98347: LIST
98348: LIST
98349: PUSH
98350: LD_INT 4
98352: PUSH
98353: LD_INT 2
98355: PUSH
98356: EMPTY
98357: LIST
98358: LIST
98359: PUSH
98360: LD_INT 4
98362: PUSH
98363: LD_INT 4
98365: PUSH
98366: EMPTY
98367: LIST
98368: LIST
98369: PUSH
98370: LD_INT 4
98372: PUSH
98373: LD_INT 3
98375: PUSH
98376: EMPTY
98377: LIST
98378: LIST
98379: PUSH
98380: LD_INT 5
98382: PUSH
98383: LD_INT 4
98385: PUSH
98386: EMPTY
98387: LIST
98388: LIST
98389: PUSH
98390: LD_INT 5
98392: PUSH
98393: LD_INT 5
98395: PUSH
98396: EMPTY
98397: LIST
98398: LIST
98399: PUSH
98400: LD_INT 4
98402: PUSH
98403: LD_INT 5
98405: PUSH
98406: EMPTY
98407: LIST
98408: LIST
98409: PUSH
98410: LD_INT 3
98412: PUSH
98413: LD_INT 4
98415: PUSH
98416: EMPTY
98417: LIST
98418: LIST
98419: PUSH
98420: LD_INT 3
98422: PUSH
98423: LD_INT 3
98425: PUSH
98426: EMPTY
98427: LIST
98428: LIST
98429: PUSH
98430: LD_INT 5
98432: PUSH
98433: LD_INT 3
98435: PUSH
98436: EMPTY
98437: LIST
98438: LIST
98439: PUSH
98440: LD_INT 3
98442: PUSH
98443: LD_INT 5
98445: PUSH
98446: EMPTY
98447: LIST
98448: LIST
98449: PUSH
98450: EMPTY
98451: LIST
98452: LIST
98453: LIST
98454: LIST
98455: LIST
98456: LIST
98457: LIST
98458: LIST
98459: LIST
98460: LIST
98461: LIST
98462: LIST
98463: LIST
98464: LIST
98465: LIST
98466: LIST
98467: LIST
98468: LIST
98469: LIST
98470: LIST
98471: LIST
98472: LIST
98473: LIST
98474: LIST
98475: LIST
98476: LIST
98477: LIST
98478: LIST
98479: LIST
98480: LIST
98481: LIST
98482: LIST
98483: LIST
98484: LIST
98485: LIST
98486: LIST
98487: LIST
98488: LIST
98489: LIST
98490: LIST
98491: LIST
98492: LIST
98493: LIST
98494: LIST
98495: LIST
98496: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
98497: LD_ADDR_VAR 0 33
98501: PUSH
98502: LD_INT 4
98504: NEG
98505: PUSH
98506: LD_INT 4
98508: NEG
98509: PUSH
98510: EMPTY
98511: LIST
98512: LIST
98513: PUSH
98514: LD_INT 4
98516: NEG
98517: PUSH
98518: LD_INT 5
98520: NEG
98521: PUSH
98522: EMPTY
98523: LIST
98524: LIST
98525: PUSH
98526: LD_INT 3
98528: NEG
98529: PUSH
98530: LD_INT 4
98532: NEG
98533: PUSH
98534: EMPTY
98535: LIST
98536: LIST
98537: PUSH
98538: LD_INT 3
98540: NEG
98541: PUSH
98542: LD_INT 3
98544: NEG
98545: PUSH
98546: EMPTY
98547: LIST
98548: LIST
98549: PUSH
98550: LD_INT 4
98552: NEG
98553: PUSH
98554: LD_INT 3
98556: NEG
98557: PUSH
98558: EMPTY
98559: LIST
98560: LIST
98561: PUSH
98562: LD_INT 5
98564: NEG
98565: PUSH
98566: LD_INT 4
98568: NEG
98569: PUSH
98570: EMPTY
98571: LIST
98572: LIST
98573: PUSH
98574: LD_INT 5
98576: NEG
98577: PUSH
98578: LD_INT 5
98580: NEG
98581: PUSH
98582: EMPTY
98583: LIST
98584: LIST
98585: PUSH
98586: LD_INT 3
98588: NEG
98589: PUSH
98590: LD_INT 5
98592: NEG
98593: PUSH
98594: EMPTY
98595: LIST
98596: LIST
98597: PUSH
98598: LD_INT 5
98600: NEG
98601: PUSH
98602: LD_INT 3
98604: NEG
98605: PUSH
98606: EMPTY
98607: LIST
98608: LIST
98609: PUSH
98610: LD_INT 0
98612: PUSH
98613: LD_INT 3
98615: NEG
98616: PUSH
98617: EMPTY
98618: LIST
98619: LIST
98620: PUSH
98621: LD_INT 0
98623: PUSH
98624: LD_INT 4
98626: NEG
98627: PUSH
98628: EMPTY
98629: LIST
98630: LIST
98631: PUSH
98632: LD_INT 1
98634: PUSH
98635: LD_INT 3
98637: NEG
98638: PUSH
98639: EMPTY
98640: LIST
98641: LIST
98642: PUSH
98643: LD_INT 1
98645: PUSH
98646: LD_INT 2
98648: NEG
98649: PUSH
98650: EMPTY
98651: LIST
98652: LIST
98653: PUSH
98654: LD_INT 0
98656: PUSH
98657: LD_INT 2
98659: NEG
98660: PUSH
98661: EMPTY
98662: LIST
98663: LIST
98664: PUSH
98665: LD_INT 1
98667: NEG
98668: PUSH
98669: LD_INT 3
98671: NEG
98672: PUSH
98673: EMPTY
98674: LIST
98675: LIST
98676: PUSH
98677: LD_INT 1
98679: NEG
98680: PUSH
98681: LD_INT 4
98683: NEG
98684: PUSH
98685: EMPTY
98686: LIST
98687: LIST
98688: PUSH
98689: LD_INT 2
98691: PUSH
98692: LD_INT 2
98694: NEG
98695: PUSH
98696: EMPTY
98697: LIST
98698: LIST
98699: PUSH
98700: LD_INT 2
98702: NEG
98703: PUSH
98704: LD_INT 4
98706: NEG
98707: PUSH
98708: EMPTY
98709: LIST
98710: LIST
98711: PUSH
98712: LD_INT 4
98714: PUSH
98715: LD_INT 0
98717: PUSH
98718: EMPTY
98719: LIST
98720: LIST
98721: PUSH
98722: LD_INT 4
98724: PUSH
98725: LD_INT 1
98727: NEG
98728: PUSH
98729: EMPTY
98730: LIST
98731: LIST
98732: PUSH
98733: LD_INT 5
98735: PUSH
98736: LD_INT 0
98738: PUSH
98739: EMPTY
98740: LIST
98741: LIST
98742: PUSH
98743: LD_INT 5
98745: PUSH
98746: LD_INT 1
98748: PUSH
98749: EMPTY
98750: LIST
98751: LIST
98752: PUSH
98753: LD_INT 4
98755: PUSH
98756: LD_INT 1
98758: PUSH
98759: EMPTY
98760: LIST
98761: LIST
98762: PUSH
98763: LD_INT 3
98765: PUSH
98766: LD_INT 0
98768: PUSH
98769: EMPTY
98770: LIST
98771: LIST
98772: PUSH
98773: LD_INT 3
98775: PUSH
98776: LD_INT 1
98778: NEG
98779: PUSH
98780: EMPTY
98781: LIST
98782: LIST
98783: PUSH
98784: LD_INT 3
98786: PUSH
98787: LD_INT 2
98789: NEG
98790: PUSH
98791: EMPTY
98792: LIST
98793: LIST
98794: PUSH
98795: LD_INT 5
98797: PUSH
98798: LD_INT 2
98800: PUSH
98801: EMPTY
98802: LIST
98803: LIST
98804: PUSH
98805: LD_INT 3
98807: PUSH
98808: LD_INT 3
98810: PUSH
98811: EMPTY
98812: LIST
98813: LIST
98814: PUSH
98815: LD_INT 3
98817: PUSH
98818: LD_INT 2
98820: PUSH
98821: EMPTY
98822: LIST
98823: LIST
98824: PUSH
98825: LD_INT 4
98827: PUSH
98828: LD_INT 3
98830: PUSH
98831: EMPTY
98832: LIST
98833: LIST
98834: PUSH
98835: LD_INT 4
98837: PUSH
98838: LD_INT 4
98840: PUSH
98841: EMPTY
98842: LIST
98843: LIST
98844: PUSH
98845: LD_INT 3
98847: PUSH
98848: LD_INT 4
98850: PUSH
98851: EMPTY
98852: LIST
98853: LIST
98854: PUSH
98855: LD_INT 2
98857: PUSH
98858: LD_INT 3
98860: PUSH
98861: EMPTY
98862: LIST
98863: LIST
98864: PUSH
98865: LD_INT 2
98867: PUSH
98868: LD_INT 2
98870: PUSH
98871: EMPTY
98872: LIST
98873: LIST
98874: PUSH
98875: LD_INT 4
98877: PUSH
98878: LD_INT 2
98880: PUSH
98881: EMPTY
98882: LIST
98883: LIST
98884: PUSH
98885: LD_INT 2
98887: PUSH
98888: LD_INT 4
98890: PUSH
98891: EMPTY
98892: LIST
98893: LIST
98894: PUSH
98895: LD_INT 0
98897: PUSH
98898: LD_INT 4
98900: PUSH
98901: EMPTY
98902: LIST
98903: LIST
98904: PUSH
98905: LD_INT 0
98907: PUSH
98908: LD_INT 3
98910: PUSH
98911: EMPTY
98912: LIST
98913: LIST
98914: PUSH
98915: LD_INT 1
98917: PUSH
98918: LD_INT 4
98920: PUSH
98921: EMPTY
98922: LIST
98923: LIST
98924: PUSH
98925: LD_INT 1
98927: PUSH
98928: LD_INT 5
98930: PUSH
98931: EMPTY
98932: LIST
98933: LIST
98934: PUSH
98935: LD_INT 0
98937: PUSH
98938: LD_INT 5
98940: PUSH
98941: EMPTY
98942: LIST
98943: LIST
98944: PUSH
98945: LD_INT 1
98947: NEG
98948: PUSH
98949: LD_INT 4
98951: PUSH
98952: EMPTY
98953: LIST
98954: LIST
98955: PUSH
98956: LD_INT 1
98958: NEG
98959: PUSH
98960: LD_INT 3
98962: PUSH
98963: EMPTY
98964: LIST
98965: LIST
98966: PUSH
98967: LD_INT 2
98969: PUSH
98970: LD_INT 5
98972: PUSH
98973: EMPTY
98974: LIST
98975: LIST
98976: PUSH
98977: LD_INT 2
98979: NEG
98980: PUSH
98981: LD_INT 3
98983: PUSH
98984: EMPTY
98985: LIST
98986: LIST
98987: PUSH
98988: EMPTY
98989: LIST
98990: LIST
98991: LIST
98992: LIST
98993: LIST
98994: LIST
98995: LIST
98996: LIST
98997: LIST
98998: LIST
98999: LIST
99000: LIST
99001: LIST
99002: LIST
99003: LIST
99004: LIST
99005: LIST
99006: LIST
99007: LIST
99008: LIST
99009: LIST
99010: LIST
99011: LIST
99012: LIST
99013: LIST
99014: LIST
99015: LIST
99016: LIST
99017: LIST
99018: LIST
99019: LIST
99020: LIST
99021: LIST
99022: LIST
99023: LIST
99024: LIST
99025: LIST
99026: LIST
99027: LIST
99028: LIST
99029: LIST
99030: LIST
99031: LIST
99032: LIST
99033: LIST
99034: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
99035: LD_ADDR_VAR 0 34
99039: PUSH
99040: LD_INT 0
99042: PUSH
99043: LD_INT 4
99045: NEG
99046: PUSH
99047: EMPTY
99048: LIST
99049: LIST
99050: PUSH
99051: LD_INT 0
99053: PUSH
99054: LD_INT 5
99056: NEG
99057: PUSH
99058: EMPTY
99059: LIST
99060: LIST
99061: PUSH
99062: LD_INT 1
99064: PUSH
99065: LD_INT 4
99067: NEG
99068: PUSH
99069: EMPTY
99070: LIST
99071: LIST
99072: PUSH
99073: LD_INT 1
99075: PUSH
99076: LD_INT 3
99078: NEG
99079: PUSH
99080: EMPTY
99081: LIST
99082: LIST
99083: PUSH
99084: LD_INT 0
99086: PUSH
99087: LD_INT 3
99089: NEG
99090: PUSH
99091: EMPTY
99092: LIST
99093: LIST
99094: PUSH
99095: LD_INT 1
99097: NEG
99098: PUSH
99099: LD_INT 4
99101: NEG
99102: PUSH
99103: EMPTY
99104: LIST
99105: LIST
99106: PUSH
99107: LD_INT 1
99109: NEG
99110: PUSH
99111: LD_INT 5
99113: NEG
99114: PUSH
99115: EMPTY
99116: LIST
99117: LIST
99118: PUSH
99119: LD_INT 2
99121: PUSH
99122: LD_INT 3
99124: NEG
99125: PUSH
99126: EMPTY
99127: LIST
99128: LIST
99129: PUSH
99130: LD_INT 2
99132: NEG
99133: PUSH
99134: LD_INT 5
99136: NEG
99137: PUSH
99138: EMPTY
99139: LIST
99140: LIST
99141: PUSH
99142: LD_INT 3
99144: PUSH
99145: LD_INT 0
99147: PUSH
99148: EMPTY
99149: LIST
99150: LIST
99151: PUSH
99152: LD_INT 3
99154: PUSH
99155: LD_INT 1
99157: NEG
99158: PUSH
99159: EMPTY
99160: LIST
99161: LIST
99162: PUSH
99163: LD_INT 4
99165: PUSH
99166: LD_INT 0
99168: PUSH
99169: EMPTY
99170: LIST
99171: LIST
99172: PUSH
99173: LD_INT 4
99175: PUSH
99176: LD_INT 1
99178: PUSH
99179: EMPTY
99180: LIST
99181: LIST
99182: PUSH
99183: LD_INT 3
99185: PUSH
99186: LD_INT 1
99188: PUSH
99189: EMPTY
99190: LIST
99191: LIST
99192: PUSH
99193: LD_INT 2
99195: PUSH
99196: LD_INT 0
99198: PUSH
99199: EMPTY
99200: LIST
99201: LIST
99202: PUSH
99203: LD_INT 2
99205: PUSH
99206: LD_INT 1
99208: NEG
99209: PUSH
99210: EMPTY
99211: LIST
99212: LIST
99213: PUSH
99214: LD_INT 2
99216: PUSH
99217: LD_INT 2
99219: NEG
99220: PUSH
99221: EMPTY
99222: LIST
99223: LIST
99224: PUSH
99225: LD_INT 4
99227: PUSH
99228: LD_INT 2
99230: PUSH
99231: EMPTY
99232: LIST
99233: LIST
99234: PUSH
99235: LD_INT 4
99237: PUSH
99238: LD_INT 4
99240: PUSH
99241: EMPTY
99242: LIST
99243: LIST
99244: PUSH
99245: LD_INT 4
99247: PUSH
99248: LD_INT 3
99250: PUSH
99251: EMPTY
99252: LIST
99253: LIST
99254: PUSH
99255: LD_INT 5
99257: PUSH
99258: LD_INT 4
99260: PUSH
99261: EMPTY
99262: LIST
99263: LIST
99264: PUSH
99265: LD_INT 5
99267: PUSH
99268: LD_INT 5
99270: PUSH
99271: EMPTY
99272: LIST
99273: LIST
99274: PUSH
99275: LD_INT 4
99277: PUSH
99278: LD_INT 5
99280: PUSH
99281: EMPTY
99282: LIST
99283: LIST
99284: PUSH
99285: LD_INT 3
99287: PUSH
99288: LD_INT 4
99290: PUSH
99291: EMPTY
99292: LIST
99293: LIST
99294: PUSH
99295: LD_INT 3
99297: PUSH
99298: LD_INT 3
99300: PUSH
99301: EMPTY
99302: LIST
99303: LIST
99304: PUSH
99305: LD_INT 5
99307: PUSH
99308: LD_INT 3
99310: PUSH
99311: EMPTY
99312: LIST
99313: LIST
99314: PUSH
99315: LD_INT 3
99317: PUSH
99318: LD_INT 5
99320: PUSH
99321: EMPTY
99322: LIST
99323: LIST
99324: PUSH
99325: LD_INT 0
99327: PUSH
99328: LD_INT 3
99330: PUSH
99331: EMPTY
99332: LIST
99333: LIST
99334: PUSH
99335: LD_INT 0
99337: PUSH
99338: LD_INT 2
99340: PUSH
99341: EMPTY
99342: LIST
99343: LIST
99344: PUSH
99345: LD_INT 1
99347: PUSH
99348: LD_INT 3
99350: PUSH
99351: EMPTY
99352: LIST
99353: LIST
99354: PUSH
99355: LD_INT 1
99357: PUSH
99358: LD_INT 4
99360: PUSH
99361: EMPTY
99362: LIST
99363: LIST
99364: PUSH
99365: LD_INT 0
99367: PUSH
99368: LD_INT 4
99370: PUSH
99371: EMPTY
99372: LIST
99373: LIST
99374: PUSH
99375: LD_INT 1
99377: NEG
99378: PUSH
99379: LD_INT 3
99381: PUSH
99382: EMPTY
99383: LIST
99384: LIST
99385: PUSH
99386: LD_INT 1
99388: NEG
99389: PUSH
99390: LD_INT 2
99392: PUSH
99393: EMPTY
99394: LIST
99395: LIST
99396: PUSH
99397: LD_INT 2
99399: PUSH
99400: LD_INT 4
99402: PUSH
99403: EMPTY
99404: LIST
99405: LIST
99406: PUSH
99407: LD_INT 2
99409: NEG
99410: PUSH
99411: LD_INT 2
99413: PUSH
99414: EMPTY
99415: LIST
99416: LIST
99417: PUSH
99418: LD_INT 4
99420: NEG
99421: PUSH
99422: LD_INT 0
99424: PUSH
99425: EMPTY
99426: LIST
99427: LIST
99428: PUSH
99429: LD_INT 4
99431: NEG
99432: PUSH
99433: LD_INT 1
99435: NEG
99436: PUSH
99437: EMPTY
99438: LIST
99439: LIST
99440: PUSH
99441: LD_INT 3
99443: NEG
99444: PUSH
99445: LD_INT 0
99447: PUSH
99448: EMPTY
99449: LIST
99450: LIST
99451: PUSH
99452: LD_INT 3
99454: NEG
99455: PUSH
99456: LD_INT 1
99458: PUSH
99459: EMPTY
99460: LIST
99461: LIST
99462: PUSH
99463: LD_INT 4
99465: NEG
99466: PUSH
99467: LD_INT 1
99469: PUSH
99470: EMPTY
99471: LIST
99472: LIST
99473: PUSH
99474: LD_INT 5
99476: NEG
99477: PUSH
99478: LD_INT 0
99480: PUSH
99481: EMPTY
99482: LIST
99483: LIST
99484: PUSH
99485: LD_INT 5
99487: NEG
99488: PUSH
99489: LD_INT 1
99491: NEG
99492: PUSH
99493: EMPTY
99494: LIST
99495: LIST
99496: PUSH
99497: LD_INT 5
99499: NEG
99500: PUSH
99501: LD_INT 2
99503: NEG
99504: PUSH
99505: EMPTY
99506: LIST
99507: LIST
99508: PUSH
99509: LD_INT 3
99511: NEG
99512: PUSH
99513: LD_INT 2
99515: PUSH
99516: EMPTY
99517: LIST
99518: LIST
99519: PUSH
99520: EMPTY
99521: LIST
99522: LIST
99523: LIST
99524: LIST
99525: LIST
99526: LIST
99527: LIST
99528: LIST
99529: LIST
99530: LIST
99531: LIST
99532: LIST
99533: LIST
99534: LIST
99535: LIST
99536: LIST
99537: LIST
99538: LIST
99539: LIST
99540: LIST
99541: LIST
99542: LIST
99543: LIST
99544: LIST
99545: LIST
99546: LIST
99547: LIST
99548: LIST
99549: LIST
99550: LIST
99551: LIST
99552: LIST
99553: LIST
99554: LIST
99555: LIST
99556: LIST
99557: LIST
99558: LIST
99559: LIST
99560: LIST
99561: LIST
99562: LIST
99563: LIST
99564: LIST
99565: LIST
99566: ST_TO_ADDR
// end ; end ;
99567: GO 99570
99569: POP
// case btype of b_depot , b_warehouse :
99570: LD_VAR 0 1
99574: PUSH
99575: LD_INT 0
99577: DOUBLE
99578: EQUAL
99579: IFTRUE 99589
99581: LD_INT 1
99583: DOUBLE
99584: EQUAL
99585: IFTRUE 99589
99587: GO 99790
99589: POP
// case nation of nation_american :
99590: LD_VAR 0 5
99594: PUSH
99595: LD_INT 1
99597: DOUBLE
99598: EQUAL
99599: IFTRUE 99603
99601: GO 99659
99603: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
99604: LD_ADDR_VAR 0 9
99608: PUSH
99609: LD_VAR 0 11
99613: PUSH
99614: LD_VAR 0 12
99618: PUSH
99619: LD_VAR 0 13
99623: PUSH
99624: LD_VAR 0 14
99628: PUSH
99629: LD_VAR 0 15
99633: PUSH
99634: LD_VAR 0 16
99638: PUSH
99639: EMPTY
99640: LIST
99641: LIST
99642: LIST
99643: LIST
99644: LIST
99645: LIST
99646: PUSH
99647: LD_VAR 0 4
99651: PUSH
99652: LD_INT 1
99654: PLUS
99655: ARRAY
99656: ST_TO_ADDR
99657: GO 99788
99659: LD_INT 2
99661: DOUBLE
99662: EQUAL
99663: IFTRUE 99667
99665: GO 99723
99667: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
99668: LD_ADDR_VAR 0 9
99672: PUSH
99673: LD_VAR 0 17
99677: PUSH
99678: LD_VAR 0 18
99682: PUSH
99683: LD_VAR 0 19
99687: PUSH
99688: LD_VAR 0 20
99692: PUSH
99693: LD_VAR 0 21
99697: PUSH
99698: LD_VAR 0 22
99702: PUSH
99703: EMPTY
99704: LIST
99705: LIST
99706: LIST
99707: LIST
99708: LIST
99709: LIST
99710: PUSH
99711: LD_VAR 0 4
99715: PUSH
99716: LD_INT 1
99718: PLUS
99719: ARRAY
99720: ST_TO_ADDR
99721: GO 99788
99723: LD_INT 3
99725: DOUBLE
99726: EQUAL
99727: IFTRUE 99731
99729: GO 99787
99731: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
99732: LD_ADDR_VAR 0 9
99736: PUSH
99737: LD_VAR 0 23
99741: PUSH
99742: LD_VAR 0 24
99746: PUSH
99747: LD_VAR 0 25
99751: PUSH
99752: LD_VAR 0 26
99756: PUSH
99757: LD_VAR 0 27
99761: PUSH
99762: LD_VAR 0 28
99766: PUSH
99767: EMPTY
99768: LIST
99769: LIST
99770: LIST
99771: LIST
99772: LIST
99773: LIST
99774: PUSH
99775: LD_VAR 0 4
99779: PUSH
99780: LD_INT 1
99782: PLUS
99783: ARRAY
99784: ST_TO_ADDR
99785: GO 99788
99787: POP
99788: GO 100343
99790: LD_INT 2
99792: DOUBLE
99793: EQUAL
99794: IFTRUE 99804
99796: LD_INT 3
99798: DOUBLE
99799: EQUAL
99800: IFTRUE 99804
99802: GO 99860
99804: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
99805: LD_ADDR_VAR 0 9
99809: PUSH
99810: LD_VAR 0 29
99814: PUSH
99815: LD_VAR 0 30
99819: PUSH
99820: LD_VAR 0 31
99824: PUSH
99825: LD_VAR 0 32
99829: PUSH
99830: LD_VAR 0 33
99834: PUSH
99835: LD_VAR 0 34
99839: PUSH
99840: EMPTY
99841: LIST
99842: LIST
99843: LIST
99844: LIST
99845: LIST
99846: LIST
99847: PUSH
99848: LD_VAR 0 4
99852: PUSH
99853: LD_INT 1
99855: PLUS
99856: ARRAY
99857: ST_TO_ADDR
99858: GO 100343
99860: LD_INT 16
99862: DOUBLE
99863: EQUAL
99864: IFTRUE 99922
99866: LD_INT 17
99868: DOUBLE
99869: EQUAL
99870: IFTRUE 99922
99872: LD_INT 18
99874: DOUBLE
99875: EQUAL
99876: IFTRUE 99922
99878: LD_INT 19
99880: DOUBLE
99881: EQUAL
99882: IFTRUE 99922
99884: LD_INT 22
99886: DOUBLE
99887: EQUAL
99888: IFTRUE 99922
99890: LD_INT 20
99892: DOUBLE
99893: EQUAL
99894: IFTRUE 99922
99896: LD_INT 21
99898: DOUBLE
99899: EQUAL
99900: IFTRUE 99922
99902: LD_INT 23
99904: DOUBLE
99905: EQUAL
99906: IFTRUE 99922
99908: LD_INT 24
99910: DOUBLE
99911: EQUAL
99912: IFTRUE 99922
99914: LD_INT 25
99916: DOUBLE
99917: EQUAL
99918: IFTRUE 99922
99920: GO 99978
99922: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
99923: LD_ADDR_VAR 0 9
99927: PUSH
99928: LD_VAR 0 35
99932: PUSH
99933: LD_VAR 0 36
99937: PUSH
99938: LD_VAR 0 37
99942: PUSH
99943: LD_VAR 0 38
99947: PUSH
99948: LD_VAR 0 39
99952: PUSH
99953: LD_VAR 0 40
99957: PUSH
99958: EMPTY
99959: LIST
99960: LIST
99961: LIST
99962: LIST
99963: LIST
99964: LIST
99965: PUSH
99966: LD_VAR 0 4
99970: PUSH
99971: LD_INT 1
99973: PLUS
99974: ARRAY
99975: ST_TO_ADDR
99976: GO 100343
99978: LD_INT 6
99980: DOUBLE
99981: EQUAL
99982: IFTRUE 100034
99984: LD_INT 7
99986: DOUBLE
99987: EQUAL
99988: IFTRUE 100034
99990: LD_INT 8
99992: DOUBLE
99993: EQUAL
99994: IFTRUE 100034
99996: LD_INT 13
99998: DOUBLE
99999: EQUAL
100000: IFTRUE 100034
100002: LD_INT 12
100004: DOUBLE
100005: EQUAL
100006: IFTRUE 100034
100008: LD_INT 15
100010: DOUBLE
100011: EQUAL
100012: IFTRUE 100034
100014: LD_INT 11
100016: DOUBLE
100017: EQUAL
100018: IFTRUE 100034
100020: LD_INT 14
100022: DOUBLE
100023: EQUAL
100024: IFTRUE 100034
100026: LD_INT 10
100028: DOUBLE
100029: EQUAL
100030: IFTRUE 100034
100032: GO 100090
100034: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
100035: LD_ADDR_VAR 0 9
100039: PUSH
100040: LD_VAR 0 41
100044: PUSH
100045: LD_VAR 0 42
100049: PUSH
100050: LD_VAR 0 43
100054: PUSH
100055: LD_VAR 0 44
100059: PUSH
100060: LD_VAR 0 45
100064: PUSH
100065: LD_VAR 0 46
100069: PUSH
100070: EMPTY
100071: LIST
100072: LIST
100073: LIST
100074: LIST
100075: LIST
100076: LIST
100077: PUSH
100078: LD_VAR 0 4
100082: PUSH
100083: LD_INT 1
100085: PLUS
100086: ARRAY
100087: ST_TO_ADDR
100088: GO 100343
100090: LD_INT 36
100092: DOUBLE
100093: EQUAL
100094: IFTRUE 100098
100096: GO 100154
100098: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
100099: LD_ADDR_VAR 0 9
100103: PUSH
100104: LD_VAR 0 47
100108: PUSH
100109: LD_VAR 0 48
100113: PUSH
100114: LD_VAR 0 49
100118: PUSH
100119: LD_VAR 0 50
100123: PUSH
100124: LD_VAR 0 51
100128: PUSH
100129: LD_VAR 0 52
100133: PUSH
100134: EMPTY
100135: LIST
100136: LIST
100137: LIST
100138: LIST
100139: LIST
100140: LIST
100141: PUSH
100142: LD_VAR 0 4
100146: PUSH
100147: LD_INT 1
100149: PLUS
100150: ARRAY
100151: ST_TO_ADDR
100152: GO 100343
100154: LD_INT 4
100156: DOUBLE
100157: EQUAL
100158: IFTRUE 100180
100160: LD_INT 5
100162: DOUBLE
100163: EQUAL
100164: IFTRUE 100180
100166: LD_INT 34
100168: DOUBLE
100169: EQUAL
100170: IFTRUE 100180
100172: LD_INT 37
100174: DOUBLE
100175: EQUAL
100176: IFTRUE 100180
100178: GO 100236
100180: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
100181: LD_ADDR_VAR 0 9
100185: PUSH
100186: LD_VAR 0 53
100190: PUSH
100191: LD_VAR 0 54
100195: PUSH
100196: LD_VAR 0 55
100200: PUSH
100201: LD_VAR 0 56
100205: PUSH
100206: LD_VAR 0 57
100210: PUSH
100211: LD_VAR 0 58
100215: PUSH
100216: EMPTY
100217: LIST
100218: LIST
100219: LIST
100220: LIST
100221: LIST
100222: LIST
100223: PUSH
100224: LD_VAR 0 4
100228: PUSH
100229: LD_INT 1
100231: PLUS
100232: ARRAY
100233: ST_TO_ADDR
100234: GO 100343
100236: LD_INT 31
100238: DOUBLE
100239: EQUAL
100240: IFTRUE 100286
100242: LD_INT 32
100244: DOUBLE
100245: EQUAL
100246: IFTRUE 100286
100248: LD_INT 33
100250: DOUBLE
100251: EQUAL
100252: IFTRUE 100286
100254: LD_INT 27
100256: DOUBLE
100257: EQUAL
100258: IFTRUE 100286
100260: LD_INT 26
100262: DOUBLE
100263: EQUAL
100264: IFTRUE 100286
100266: LD_INT 28
100268: DOUBLE
100269: EQUAL
100270: IFTRUE 100286
100272: LD_INT 29
100274: DOUBLE
100275: EQUAL
100276: IFTRUE 100286
100278: LD_INT 30
100280: DOUBLE
100281: EQUAL
100282: IFTRUE 100286
100284: GO 100342
100286: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
100287: LD_ADDR_VAR 0 9
100291: PUSH
100292: LD_VAR 0 59
100296: PUSH
100297: LD_VAR 0 60
100301: PUSH
100302: LD_VAR 0 61
100306: PUSH
100307: LD_VAR 0 62
100311: PUSH
100312: LD_VAR 0 63
100316: PUSH
100317: LD_VAR 0 64
100321: PUSH
100322: EMPTY
100323: LIST
100324: LIST
100325: LIST
100326: LIST
100327: LIST
100328: LIST
100329: PUSH
100330: LD_VAR 0 4
100334: PUSH
100335: LD_INT 1
100337: PLUS
100338: ARRAY
100339: ST_TO_ADDR
100340: GO 100343
100342: POP
// temp_list2 = [ ] ;
100343: LD_ADDR_VAR 0 10
100347: PUSH
100348: EMPTY
100349: ST_TO_ADDR
// for i in temp_list do
100350: LD_ADDR_VAR 0 8
100354: PUSH
100355: LD_VAR 0 9
100359: PUSH
100360: FOR_IN
100361: IFFALSE 100413
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
100363: LD_ADDR_VAR 0 10
100367: PUSH
100368: LD_VAR 0 10
100372: PUSH
100373: LD_VAR 0 8
100377: PUSH
100378: LD_INT 1
100380: ARRAY
100381: PUSH
100382: LD_VAR 0 2
100386: PLUS
100387: PUSH
100388: LD_VAR 0 8
100392: PUSH
100393: LD_INT 2
100395: ARRAY
100396: PUSH
100397: LD_VAR 0 3
100401: PLUS
100402: PUSH
100403: EMPTY
100404: LIST
100405: LIST
100406: PUSH
100407: EMPTY
100408: LIST
100409: ADD
100410: ST_TO_ADDR
100411: GO 100360
100413: POP
100414: POP
// result = temp_list2 ;
100415: LD_ADDR_VAR 0 7
100419: PUSH
100420: LD_VAR 0 10
100424: ST_TO_ADDR
// end ;
100425: LD_VAR 0 7
100429: RET
// export function EnemyInRange ( unit , dist ) ; begin
100430: LD_INT 0
100432: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
100433: LD_ADDR_VAR 0 3
100437: PUSH
100438: LD_VAR 0 1
100442: PPUSH
100443: CALL_OW 255
100447: PPUSH
100448: LD_VAR 0 1
100452: PPUSH
100453: CALL_OW 250
100457: PPUSH
100458: LD_VAR 0 1
100462: PPUSH
100463: CALL_OW 251
100467: PPUSH
100468: LD_VAR 0 2
100472: PPUSH
100473: CALL 73832 0 4
100477: PUSH
100478: LD_INT 4
100480: ARRAY
100481: ST_TO_ADDR
// end ;
100482: LD_VAR 0 3
100486: RET
// export function PlayerSeeMe ( unit ) ; begin
100487: LD_INT 0
100489: PPUSH
// result := See ( your_side , unit ) ;
100490: LD_ADDR_VAR 0 2
100494: PUSH
100495: LD_OWVAR 2
100499: PPUSH
100500: LD_VAR 0 1
100504: PPUSH
100505: CALL_OW 292
100509: ST_TO_ADDR
// end ;
100510: LD_VAR 0 2
100514: RET
// export function ReverseDir ( unit ) ; begin
100515: LD_INT 0
100517: PPUSH
// if not unit then
100518: LD_VAR 0 1
100522: NOT
100523: IFFALSE 100527
// exit ;
100525: GO 100550
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
100527: LD_ADDR_VAR 0 2
100531: PUSH
100532: LD_VAR 0 1
100536: PPUSH
100537: CALL_OW 254
100541: PUSH
100542: LD_INT 3
100544: PLUS
100545: PUSH
100546: LD_INT 6
100548: MOD
100549: ST_TO_ADDR
// end ;
100550: LD_VAR 0 2
100554: RET
// export function ReverseArray ( array ) ; var i ; begin
100555: LD_INT 0
100557: PPUSH
100558: PPUSH
// if not array then
100559: LD_VAR 0 1
100563: NOT
100564: IFFALSE 100568
// exit ;
100566: GO 100623
// result := [ ] ;
100568: LD_ADDR_VAR 0 2
100572: PUSH
100573: EMPTY
100574: ST_TO_ADDR
// for i := array downto 1 do
100575: LD_ADDR_VAR 0 3
100579: PUSH
100580: DOUBLE
100581: LD_VAR 0 1
100585: INC
100586: ST_TO_ADDR
100587: LD_INT 1
100589: PUSH
100590: FOR_DOWNTO
100591: IFFALSE 100621
// result := Join ( result , array [ i ] ) ;
100593: LD_ADDR_VAR 0 2
100597: PUSH
100598: LD_VAR 0 2
100602: PPUSH
100603: LD_VAR 0 1
100607: PUSH
100608: LD_VAR 0 3
100612: ARRAY
100613: PPUSH
100614: CALL 105266 0 2
100618: ST_TO_ADDR
100619: GO 100590
100621: POP
100622: POP
// end ;
100623: LD_VAR 0 2
100627: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
100628: LD_INT 0
100630: PPUSH
100631: PPUSH
100632: PPUSH
100633: PPUSH
100634: PPUSH
100635: PPUSH
// if not unit or not hexes then
100636: LD_VAR 0 1
100640: NOT
100641: PUSH
100642: LD_VAR 0 2
100646: NOT
100647: OR
100648: IFFALSE 100652
// exit ;
100650: GO 100775
// dist := 9999 ;
100652: LD_ADDR_VAR 0 5
100656: PUSH
100657: LD_INT 9999
100659: ST_TO_ADDR
// for i = 1 to hexes do
100660: LD_ADDR_VAR 0 4
100664: PUSH
100665: DOUBLE
100666: LD_INT 1
100668: DEC
100669: ST_TO_ADDR
100670: LD_VAR 0 2
100674: PUSH
100675: FOR_TO
100676: IFFALSE 100763
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
100678: LD_ADDR_VAR 0 6
100682: PUSH
100683: LD_VAR 0 1
100687: PPUSH
100688: LD_VAR 0 2
100692: PUSH
100693: LD_VAR 0 4
100697: ARRAY
100698: PUSH
100699: LD_INT 1
100701: ARRAY
100702: PPUSH
100703: LD_VAR 0 2
100707: PUSH
100708: LD_VAR 0 4
100712: ARRAY
100713: PUSH
100714: LD_INT 2
100716: ARRAY
100717: PPUSH
100718: CALL_OW 297
100722: ST_TO_ADDR
// if tdist < dist then
100723: LD_VAR 0 6
100727: PUSH
100728: LD_VAR 0 5
100732: LESS
100733: IFFALSE 100761
// begin hex := hexes [ i ] ;
100735: LD_ADDR_VAR 0 8
100739: PUSH
100740: LD_VAR 0 2
100744: PUSH
100745: LD_VAR 0 4
100749: ARRAY
100750: ST_TO_ADDR
// dist := tdist ;
100751: LD_ADDR_VAR 0 5
100755: PUSH
100756: LD_VAR 0 6
100760: ST_TO_ADDR
// end ; end ;
100761: GO 100675
100763: POP
100764: POP
// result := hex ;
100765: LD_ADDR_VAR 0 3
100769: PUSH
100770: LD_VAR 0 8
100774: ST_TO_ADDR
// end ;
100775: LD_VAR 0 3
100779: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
100780: LD_INT 0
100782: PPUSH
100783: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
100784: LD_VAR 0 1
100788: NOT
100789: PUSH
100790: LD_VAR 0 1
100794: PUSH
100795: LD_INT 21
100797: PUSH
100798: LD_INT 2
100800: PUSH
100801: EMPTY
100802: LIST
100803: LIST
100804: PUSH
100805: LD_INT 23
100807: PUSH
100808: LD_INT 2
100810: PUSH
100811: EMPTY
100812: LIST
100813: LIST
100814: PUSH
100815: EMPTY
100816: LIST
100817: LIST
100818: PPUSH
100819: CALL_OW 69
100823: IN
100824: NOT
100825: OR
100826: IFFALSE 100830
// exit ;
100828: GO 100877
// for i = 1 to 3 do
100830: LD_ADDR_VAR 0 3
100834: PUSH
100835: DOUBLE
100836: LD_INT 1
100838: DEC
100839: ST_TO_ADDR
100840: LD_INT 3
100842: PUSH
100843: FOR_TO
100844: IFFALSE 100875
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
100846: LD_VAR 0 1
100850: PPUSH
100851: CALL_OW 250
100855: PPUSH
100856: LD_VAR 0 1
100860: PPUSH
100861: CALL_OW 251
100865: PPUSH
100866: LD_INT 1
100868: PPUSH
100869: CALL_OW 453
100873: GO 100843
100875: POP
100876: POP
// end ;
100877: LD_VAR 0 2
100881: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
100882: LD_INT 0
100884: PPUSH
100885: PPUSH
100886: PPUSH
100887: PPUSH
100888: PPUSH
100889: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
100890: LD_VAR 0 1
100894: NOT
100895: PUSH
100896: LD_VAR 0 2
100900: NOT
100901: OR
100902: PUSH
100903: LD_VAR 0 1
100907: PPUSH
100908: CALL_OW 314
100912: OR
100913: IFFALSE 100917
// exit ;
100915: GO 101384
// if GetLives ( i ) < 250 then
100917: LD_VAR 0 4
100921: PPUSH
100922: CALL_OW 256
100926: PUSH
100927: LD_INT 250
100929: LESS
100930: IFFALSE 100943
// begin ComAutodestruct ( i ) ;
100932: LD_VAR 0 4
100936: PPUSH
100937: CALL 100780 0 1
// exit ;
100941: GO 101384
// end ; x := GetX ( enemy_unit ) ;
100943: LD_ADDR_VAR 0 7
100947: PUSH
100948: LD_VAR 0 2
100952: PPUSH
100953: CALL_OW 250
100957: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
100958: LD_ADDR_VAR 0 8
100962: PUSH
100963: LD_VAR 0 2
100967: PPUSH
100968: CALL_OW 251
100972: ST_TO_ADDR
// if not x or not y then
100973: LD_VAR 0 7
100977: NOT
100978: PUSH
100979: LD_VAR 0 8
100983: NOT
100984: OR
100985: IFFALSE 100989
// exit ;
100987: GO 101384
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
100989: LD_ADDR_VAR 0 6
100993: PUSH
100994: LD_VAR 0 7
100998: PPUSH
100999: LD_INT 0
101001: PPUSH
101002: LD_INT 4
101004: PPUSH
101005: CALL_OW 272
101009: PUSH
101010: LD_VAR 0 8
101014: PPUSH
101015: LD_INT 0
101017: PPUSH
101018: LD_INT 4
101020: PPUSH
101021: CALL_OW 273
101025: PUSH
101026: EMPTY
101027: LIST
101028: LIST
101029: PUSH
101030: LD_VAR 0 7
101034: PPUSH
101035: LD_INT 1
101037: PPUSH
101038: LD_INT 4
101040: PPUSH
101041: CALL_OW 272
101045: PUSH
101046: LD_VAR 0 8
101050: PPUSH
101051: LD_INT 1
101053: PPUSH
101054: LD_INT 4
101056: PPUSH
101057: CALL_OW 273
101061: PUSH
101062: EMPTY
101063: LIST
101064: LIST
101065: PUSH
101066: LD_VAR 0 7
101070: PPUSH
101071: LD_INT 2
101073: PPUSH
101074: LD_INT 4
101076: PPUSH
101077: CALL_OW 272
101081: PUSH
101082: LD_VAR 0 8
101086: PPUSH
101087: LD_INT 2
101089: PPUSH
101090: LD_INT 4
101092: PPUSH
101093: CALL_OW 273
101097: PUSH
101098: EMPTY
101099: LIST
101100: LIST
101101: PUSH
101102: LD_VAR 0 7
101106: PPUSH
101107: LD_INT 3
101109: PPUSH
101110: LD_INT 4
101112: PPUSH
101113: CALL_OW 272
101117: PUSH
101118: LD_VAR 0 8
101122: PPUSH
101123: LD_INT 3
101125: PPUSH
101126: LD_INT 4
101128: PPUSH
101129: CALL_OW 273
101133: PUSH
101134: EMPTY
101135: LIST
101136: LIST
101137: PUSH
101138: LD_VAR 0 7
101142: PPUSH
101143: LD_INT 4
101145: PPUSH
101146: LD_INT 4
101148: PPUSH
101149: CALL_OW 272
101153: PUSH
101154: LD_VAR 0 8
101158: PPUSH
101159: LD_INT 4
101161: PPUSH
101162: LD_INT 4
101164: PPUSH
101165: CALL_OW 273
101169: PUSH
101170: EMPTY
101171: LIST
101172: LIST
101173: PUSH
101174: LD_VAR 0 7
101178: PPUSH
101179: LD_INT 5
101181: PPUSH
101182: LD_INT 4
101184: PPUSH
101185: CALL_OW 272
101189: PUSH
101190: LD_VAR 0 8
101194: PPUSH
101195: LD_INT 5
101197: PPUSH
101198: LD_INT 4
101200: PPUSH
101201: CALL_OW 273
101205: PUSH
101206: EMPTY
101207: LIST
101208: LIST
101209: PUSH
101210: EMPTY
101211: LIST
101212: LIST
101213: LIST
101214: LIST
101215: LIST
101216: LIST
101217: ST_TO_ADDR
// for i = tmp downto 1 do
101218: LD_ADDR_VAR 0 4
101222: PUSH
101223: DOUBLE
101224: LD_VAR 0 6
101228: INC
101229: ST_TO_ADDR
101230: LD_INT 1
101232: PUSH
101233: FOR_DOWNTO
101234: IFFALSE 101335
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
101236: LD_VAR 0 6
101240: PUSH
101241: LD_VAR 0 4
101245: ARRAY
101246: PUSH
101247: LD_INT 1
101249: ARRAY
101250: PPUSH
101251: LD_VAR 0 6
101255: PUSH
101256: LD_VAR 0 4
101260: ARRAY
101261: PUSH
101262: LD_INT 2
101264: ARRAY
101265: PPUSH
101266: CALL_OW 488
101270: NOT
101271: PUSH
101272: LD_VAR 0 6
101276: PUSH
101277: LD_VAR 0 4
101281: ARRAY
101282: PUSH
101283: LD_INT 1
101285: ARRAY
101286: PPUSH
101287: LD_VAR 0 6
101291: PUSH
101292: LD_VAR 0 4
101296: ARRAY
101297: PUSH
101298: LD_INT 2
101300: ARRAY
101301: PPUSH
101302: CALL_OW 428
101306: PUSH
101307: LD_INT 0
101309: NONEQUAL
101310: OR
101311: IFFALSE 101333
// tmp := Delete ( tmp , i ) ;
101313: LD_ADDR_VAR 0 6
101317: PUSH
101318: LD_VAR 0 6
101322: PPUSH
101323: LD_VAR 0 4
101327: PPUSH
101328: CALL_OW 3
101332: ST_TO_ADDR
101333: GO 101233
101335: POP
101336: POP
// j := GetClosestHex ( unit , tmp ) ;
101337: LD_ADDR_VAR 0 5
101341: PUSH
101342: LD_VAR 0 1
101346: PPUSH
101347: LD_VAR 0 6
101351: PPUSH
101352: CALL 100628 0 2
101356: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
101357: LD_VAR 0 1
101361: PPUSH
101362: LD_VAR 0 5
101366: PUSH
101367: LD_INT 1
101369: ARRAY
101370: PPUSH
101371: LD_VAR 0 5
101375: PUSH
101376: LD_INT 2
101378: ARRAY
101379: PPUSH
101380: CALL_OW 111
// end ;
101384: LD_VAR 0 3
101388: RET
// export function PrepareApemanSoldier ( ) ; begin
101389: LD_INT 0
101391: PPUSH
// uc_nation := 0 ;
101392: LD_ADDR_OWVAR 21
101396: PUSH
101397: LD_INT 0
101399: ST_TO_ADDR
// hc_sex := sex_male ;
101400: LD_ADDR_OWVAR 27
101404: PUSH
101405: LD_INT 1
101407: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
101408: LD_ADDR_OWVAR 28
101412: PUSH
101413: LD_INT 15
101415: ST_TO_ADDR
// hc_gallery :=  ;
101416: LD_ADDR_OWVAR 33
101420: PUSH
101421: LD_STRING 
101423: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
101424: LD_ADDR_OWVAR 31
101428: PUSH
101429: LD_INT 0
101431: PPUSH
101432: LD_INT 3
101434: PPUSH
101435: CALL_OW 12
101439: PUSH
101440: LD_INT 0
101442: PPUSH
101443: LD_INT 3
101445: PPUSH
101446: CALL_OW 12
101450: PUSH
101451: LD_INT 0
101453: PUSH
101454: LD_INT 0
101456: PUSH
101457: EMPTY
101458: LIST
101459: LIST
101460: LIST
101461: LIST
101462: ST_TO_ADDR
// end ;
101463: LD_VAR 0 1
101467: RET
// export function PrepareApemanEngineer ( ) ; begin
101468: LD_INT 0
101470: PPUSH
// uc_nation := 0 ;
101471: LD_ADDR_OWVAR 21
101475: PUSH
101476: LD_INT 0
101478: ST_TO_ADDR
// hc_sex := sex_male ;
101479: LD_ADDR_OWVAR 27
101483: PUSH
101484: LD_INT 1
101486: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
101487: LD_ADDR_OWVAR 28
101491: PUSH
101492: LD_INT 16
101494: ST_TO_ADDR
// hc_gallery :=  ;
101495: LD_ADDR_OWVAR 33
101499: PUSH
101500: LD_STRING 
101502: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
101503: LD_ADDR_OWVAR 31
101507: PUSH
101508: LD_INT 0
101510: PPUSH
101511: LD_INT 3
101513: PPUSH
101514: CALL_OW 12
101518: PUSH
101519: LD_INT 0
101521: PPUSH
101522: LD_INT 3
101524: PPUSH
101525: CALL_OW 12
101529: PUSH
101530: LD_INT 0
101532: PUSH
101533: LD_INT 0
101535: PUSH
101536: EMPTY
101537: LIST
101538: LIST
101539: LIST
101540: LIST
101541: ST_TO_ADDR
// end ;
101542: LD_VAR 0 1
101546: RET
// export function PrepareApeman ( agressivity ) ; begin
101547: LD_INT 0
101549: PPUSH
// uc_side := 0 ;
101550: LD_ADDR_OWVAR 20
101554: PUSH
101555: LD_INT 0
101557: ST_TO_ADDR
// uc_nation := 0 ;
101558: LD_ADDR_OWVAR 21
101562: PUSH
101563: LD_INT 0
101565: ST_TO_ADDR
// hc_sex := sex_male ;
101566: LD_ADDR_OWVAR 27
101570: PUSH
101571: LD_INT 1
101573: ST_TO_ADDR
// hc_class := class_apeman ;
101574: LD_ADDR_OWVAR 28
101578: PUSH
101579: LD_INT 12
101581: ST_TO_ADDR
// hc_gallery :=  ;
101582: LD_ADDR_OWVAR 33
101586: PUSH
101587: LD_STRING 
101589: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
101590: LD_ADDR_OWVAR 35
101594: PUSH
101595: LD_VAR 0 1
101599: NEG
101600: PPUSH
101601: LD_VAR 0 1
101605: PPUSH
101606: CALL_OW 12
101610: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
101611: LD_ADDR_OWVAR 31
101615: PUSH
101616: LD_INT 0
101618: PPUSH
101619: LD_INT 3
101621: PPUSH
101622: CALL_OW 12
101626: PUSH
101627: LD_INT 0
101629: PPUSH
101630: LD_INT 3
101632: PPUSH
101633: CALL_OW 12
101637: PUSH
101638: LD_INT 0
101640: PUSH
101641: LD_INT 0
101643: PUSH
101644: EMPTY
101645: LIST
101646: LIST
101647: LIST
101648: LIST
101649: ST_TO_ADDR
// end ;
101650: LD_VAR 0 2
101654: RET
// export function PrepareTiger ( agressivity ) ; begin
101655: LD_INT 0
101657: PPUSH
// uc_side := 0 ;
101658: LD_ADDR_OWVAR 20
101662: PUSH
101663: LD_INT 0
101665: ST_TO_ADDR
// uc_nation := 0 ;
101666: LD_ADDR_OWVAR 21
101670: PUSH
101671: LD_INT 0
101673: ST_TO_ADDR
// hc_class := class_tiger ;
101674: LD_ADDR_OWVAR 28
101678: PUSH
101679: LD_INT 14
101681: ST_TO_ADDR
// hc_gallery :=  ;
101682: LD_ADDR_OWVAR 33
101686: PUSH
101687: LD_STRING 
101689: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
101690: LD_ADDR_OWVAR 35
101694: PUSH
101695: LD_VAR 0 1
101699: NEG
101700: PPUSH
101701: LD_VAR 0 1
101705: PPUSH
101706: CALL_OW 12
101710: ST_TO_ADDR
// end ;
101711: LD_VAR 0 2
101715: RET
// export function PrepareEnchidna ( ) ; begin
101716: LD_INT 0
101718: PPUSH
// uc_side := 0 ;
101719: LD_ADDR_OWVAR 20
101723: PUSH
101724: LD_INT 0
101726: ST_TO_ADDR
// uc_nation := 0 ;
101727: LD_ADDR_OWVAR 21
101731: PUSH
101732: LD_INT 0
101734: ST_TO_ADDR
// hc_class := class_baggie ;
101735: LD_ADDR_OWVAR 28
101739: PUSH
101740: LD_INT 13
101742: ST_TO_ADDR
// hc_gallery :=  ;
101743: LD_ADDR_OWVAR 33
101747: PUSH
101748: LD_STRING 
101750: ST_TO_ADDR
// end ;
101751: LD_VAR 0 1
101755: RET
// export function PrepareFrog ( ) ; begin
101756: LD_INT 0
101758: PPUSH
// uc_side := 0 ;
101759: LD_ADDR_OWVAR 20
101763: PUSH
101764: LD_INT 0
101766: ST_TO_ADDR
// uc_nation := 0 ;
101767: LD_ADDR_OWVAR 21
101771: PUSH
101772: LD_INT 0
101774: ST_TO_ADDR
// hc_class := class_frog ;
101775: LD_ADDR_OWVAR 28
101779: PUSH
101780: LD_INT 19
101782: ST_TO_ADDR
// hc_gallery :=  ;
101783: LD_ADDR_OWVAR 33
101787: PUSH
101788: LD_STRING 
101790: ST_TO_ADDR
// end ;
101791: LD_VAR 0 1
101795: RET
// export function PrepareFish ( ) ; begin
101796: LD_INT 0
101798: PPUSH
// uc_side := 0 ;
101799: LD_ADDR_OWVAR 20
101803: PUSH
101804: LD_INT 0
101806: ST_TO_ADDR
// uc_nation := 0 ;
101807: LD_ADDR_OWVAR 21
101811: PUSH
101812: LD_INT 0
101814: ST_TO_ADDR
// hc_class := class_fish ;
101815: LD_ADDR_OWVAR 28
101819: PUSH
101820: LD_INT 20
101822: ST_TO_ADDR
// hc_gallery :=  ;
101823: LD_ADDR_OWVAR 33
101827: PUSH
101828: LD_STRING 
101830: ST_TO_ADDR
// end ;
101831: LD_VAR 0 1
101835: RET
// export function PrepareBird ( ) ; begin
101836: LD_INT 0
101838: PPUSH
// uc_side := 0 ;
101839: LD_ADDR_OWVAR 20
101843: PUSH
101844: LD_INT 0
101846: ST_TO_ADDR
// uc_nation := 0 ;
101847: LD_ADDR_OWVAR 21
101851: PUSH
101852: LD_INT 0
101854: ST_TO_ADDR
// hc_class := class_phororhacos ;
101855: LD_ADDR_OWVAR 28
101859: PUSH
101860: LD_INT 18
101862: ST_TO_ADDR
// hc_gallery :=  ;
101863: LD_ADDR_OWVAR 33
101867: PUSH
101868: LD_STRING 
101870: ST_TO_ADDR
// end ;
101871: LD_VAR 0 1
101875: RET
// export function PrepareHorse ( ) ; begin
101876: LD_INT 0
101878: PPUSH
// uc_side := 0 ;
101879: LD_ADDR_OWVAR 20
101883: PUSH
101884: LD_INT 0
101886: ST_TO_ADDR
// uc_nation := 0 ;
101887: LD_ADDR_OWVAR 21
101891: PUSH
101892: LD_INT 0
101894: ST_TO_ADDR
// hc_class := class_horse ;
101895: LD_ADDR_OWVAR 28
101899: PUSH
101900: LD_INT 21
101902: ST_TO_ADDR
// hc_gallery :=  ;
101903: LD_ADDR_OWVAR 33
101907: PUSH
101908: LD_STRING 
101910: ST_TO_ADDR
// end ;
101911: LD_VAR 0 1
101915: RET
// export function PrepareMastodont ( ) ; begin
101916: LD_INT 0
101918: PPUSH
// uc_side := 0 ;
101919: LD_ADDR_OWVAR 20
101923: PUSH
101924: LD_INT 0
101926: ST_TO_ADDR
// uc_nation := 0 ;
101927: LD_ADDR_OWVAR 21
101931: PUSH
101932: LD_INT 0
101934: ST_TO_ADDR
// vc_chassis := class_mastodont ;
101935: LD_ADDR_OWVAR 37
101939: PUSH
101940: LD_INT 31
101942: ST_TO_ADDR
// vc_control := control_rider ;
101943: LD_ADDR_OWVAR 38
101947: PUSH
101948: LD_INT 4
101950: ST_TO_ADDR
// end ;
101951: LD_VAR 0 1
101955: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
101956: LD_INT 0
101958: PPUSH
101959: PPUSH
101960: PPUSH
// uc_side = 0 ;
101961: LD_ADDR_OWVAR 20
101965: PUSH
101966: LD_INT 0
101968: ST_TO_ADDR
// uc_nation = 0 ;
101969: LD_ADDR_OWVAR 21
101973: PUSH
101974: LD_INT 0
101976: ST_TO_ADDR
// InitHc_All ( ) ;
101977: CALL_OW 584
// InitVc ;
101981: CALL_OW 20
// if mastodonts then
101985: LD_VAR 0 6
101989: IFFALSE 102056
// for i = 1 to mastodonts do
101991: LD_ADDR_VAR 0 11
101995: PUSH
101996: DOUBLE
101997: LD_INT 1
101999: DEC
102000: ST_TO_ADDR
102001: LD_VAR 0 6
102005: PUSH
102006: FOR_TO
102007: IFFALSE 102054
// begin vc_chassis := 31 ;
102009: LD_ADDR_OWVAR 37
102013: PUSH
102014: LD_INT 31
102016: ST_TO_ADDR
// vc_control := control_rider ;
102017: LD_ADDR_OWVAR 38
102021: PUSH
102022: LD_INT 4
102024: ST_TO_ADDR
// animal := CreateVehicle ;
102025: LD_ADDR_VAR 0 12
102029: PUSH
102030: CALL_OW 45
102034: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102035: LD_VAR 0 12
102039: PPUSH
102040: LD_VAR 0 8
102044: PPUSH
102045: LD_INT 0
102047: PPUSH
102048: CALL 104184 0 3
// end ;
102052: GO 102006
102054: POP
102055: POP
// if horses then
102056: LD_VAR 0 5
102060: IFFALSE 102127
// for i = 1 to horses do
102062: LD_ADDR_VAR 0 11
102066: PUSH
102067: DOUBLE
102068: LD_INT 1
102070: DEC
102071: ST_TO_ADDR
102072: LD_VAR 0 5
102076: PUSH
102077: FOR_TO
102078: IFFALSE 102125
// begin hc_class := 21 ;
102080: LD_ADDR_OWVAR 28
102084: PUSH
102085: LD_INT 21
102087: ST_TO_ADDR
// hc_gallery :=  ;
102088: LD_ADDR_OWVAR 33
102092: PUSH
102093: LD_STRING 
102095: ST_TO_ADDR
// animal := CreateHuman ;
102096: LD_ADDR_VAR 0 12
102100: PUSH
102101: CALL_OW 44
102105: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102106: LD_VAR 0 12
102110: PPUSH
102111: LD_VAR 0 8
102115: PPUSH
102116: LD_INT 0
102118: PPUSH
102119: CALL 104184 0 3
// end ;
102123: GO 102077
102125: POP
102126: POP
// if birds then
102127: LD_VAR 0 1
102131: IFFALSE 102198
// for i = 1 to birds do
102133: LD_ADDR_VAR 0 11
102137: PUSH
102138: DOUBLE
102139: LD_INT 1
102141: DEC
102142: ST_TO_ADDR
102143: LD_VAR 0 1
102147: PUSH
102148: FOR_TO
102149: IFFALSE 102196
// begin hc_class = 18 ;
102151: LD_ADDR_OWVAR 28
102155: PUSH
102156: LD_INT 18
102158: ST_TO_ADDR
// hc_gallery =  ;
102159: LD_ADDR_OWVAR 33
102163: PUSH
102164: LD_STRING 
102166: ST_TO_ADDR
// animal := CreateHuman ;
102167: LD_ADDR_VAR 0 12
102171: PUSH
102172: CALL_OW 44
102176: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102177: LD_VAR 0 12
102181: PPUSH
102182: LD_VAR 0 8
102186: PPUSH
102187: LD_INT 0
102189: PPUSH
102190: CALL 104184 0 3
// end ;
102194: GO 102148
102196: POP
102197: POP
// if tigers then
102198: LD_VAR 0 2
102202: IFFALSE 102286
// for i = 1 to tigers do
102204: LD_ADDR_VAR 0 11
102208: PUSH
102209: DOUBLE
102210: LD_INT 1
102212: DEC
102213: ST_TO_ADDR
102214: LD_VAR 0 2
102218: PUSH
102219: FOR_TO
102220: IFFALSE 102284
// begin hc_class = class_tiger ;
102222: LD_ADDR_OWVAR 28
102226: PUSH
102227: LD_INT 14
102229: ST_TO_ADDR
// hc_gallery =  ;
102230: LD_ADDR_OWVAR 33
102234: PUSH
102235: LD_STRING 
102237: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
102238: LD_ADDR_OWVAR 35
102242: PUSH
102243: LD_INT 7
102245: NEG
102246: PPUSH
102247: LD_INT 7
102249: PPUSH
102250: CALL_OW 12
102254: ST_TO_ADDR
// animal := CreateHuman ;
102255: LD_ADDR_VAR 0 12
102259: PUSH
102260: CALL_OW 44
102264: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102265: LD_VAR 0 12
102269: PPUSH
102270: LD_VAR 0 8
102274: PPUSH
102275: LD_INT 0
102277: PPUSH
102278: CALL 104184 0 3
// end ;
102282: GO 102219
102284: POP
102285: POP
// if apemans then
102286: LD_VAR 0 3
102290: IFFALSE 102413
// for i = 1 to apemans do
102292: LD_ADDR_VAR 0 11
102296: PUSH
102297: DOUBLE
102298: LD_INT 1
102300: DEC
102301: ST_TO_ADDR
102302: LD_VAR 0 3
102306: PUSH
102307: FOR_TO
102308: IFFALSE 102411
// begin hc_class = class_apeman ;
102310: LD_ADDR_OWVAR 28
102314: PUSH
102315: LD_INT 12
102317: ST_TO_ADDR
// hc_gallery =  ;
102318: LD_ADDR_OWVAR 33
102322: PUSH
102323: LD_STRING 
102325: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
102326: LD_ADDR_OWVAR 35
102330: PUSH
102331: LD_INT 2
102333: NEG
102334: PPUSH
102335: LD_INT 2
102337: PPUSH
102338: CALL_OW 12
102342: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
102343: LD_ADDR_OWVAR 31
102347: PUSH
102348: LD_INT 1
102350: PPUSH
102351: LD_INT 3
102353: PPUSH
102354: CALL_OW 12
102358: PUSH
102359: LD_INT 1
102361: PPUSH
102362: LD_INT 3
102364: PPUSH
102365: CALL_OW 12
102369: PUSH
102370: LD_INT 0
102372: PUSH
102373: LD_INT 0
102375: PUSH
102376: EMPTY
102377: LIST
102378: LIST
102379: LIST
102380: LIST
102381: ST_TO_ADDR
// animal := CreateHuman ;
102382: LD_ADDR_VAR 0 12
102386: PUSH
102387: CALL_OW 44
102391: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102392: LD_VAR 0 12
102396: PPUSH
102397: LD_VAR 0 8
102401: PPUSH
102402: LD_INT 0
102404: PPUSH
102405: CALL 104184 0 3
// end ;
102409: GO 102307
102411: POP
102412: POP
// if enchidnas then
102413: LD_VAR 0 4
102417: IFFALSE 102484
// for i = 1 to enchidnas do
102419: LD_ADDR_VAR 0 11
102423: PUSH
102424: DOUBLE
102425: LD_INT 1
102427: DEC
102428: ST_TO_ADDR
102429: LD_VAR 0 4
102433: PUSH
102434: FOR_TO
102435: IFFALSE 102482
// begin hc_class = 13 ;
102437: LD_ADDR_OWVAR 28
102441: PUSH
102442: LD_INT 13
102444: ST_TO_ADDR
// hc_gallery =  ;
102445: LD_ADDR_OWVAR 33
102449: PUSH
102450: LD_STRING 
102452: ST_TO_ADDR
// animal := CreateHuman ;
102453: LD_ADDR_VAR 0 12
102457: PUSH
102458: CALL_OW 44
102462: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102463: LD_VAR 0 12
102467: PPUSH
102468: LD_VAR 0 8
102472: PPUSH
102473: LD_INT 0
102475: PPUSH
102476: CALL 104184 0 3
// end ;
102480: GO 102434
102482: POP
102483: POP
// if fishes then
102484: LD_VAR 0 7
102488: IFFALSE 102555
// for i = 1 to fishes do
102490: LD_ADDR_VAR 0 11
102494: PUSH
102495: DOUBLE
102496: LD_INT 1
102498: DEC
102499: ST_TO_ADDR
102500: LD_VAR 0 7
102504: PUSH
102505: FOR_TO
102506: IFFALSE 102553
// begin hc_class = 20 ;
102508: LD_ADDR_OWVAR 28
102512: PUSH
102513: LD_INT 20
102515: ST_TO_ADDR
// hc_gallery =  ;
102516: LD_ADDR_OWVAR 33
102520: PUSH
102521: LD_STRING 
102523: ST_TO_ADDR
// animal := CreateHuman ;
102524: LD_ADDR_VAR 0 12
102528: PUSH
102529: CALL_OW 44
102533: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
102534: LD_VAR 0 12
102538: PPUSH
102539: LD_VAR 0 9
102543: PPUSH
102544: LD_INT 0
102546: PPUSH
102547: CALL 104184 0 3
// end ;
102551: GO 102505
102553: POP
102554: POP
// end ;
102555: LD_VAR 0 10
102559: RET
// export function WantHeal ( sci , unit ) ; begin
102560: LD_INT 0
102562: PPUSH
// if GetTaskList ( sci ) > 0 then
102563: LD_VAR 0 1
102567: PPUSH
102568: CALL_OW 437
102572: PUSH
102573: LD_INT 0
102575: GREATER
102576: IFFALSE 102646
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
102578: LD_VAR 0 1
102582: PPUSH
102583: CALL_OW 437
102587: PUSH
102588: LD_INT 1
102590: ARRAY
102591: PUSH
102592: LD_INT 1
102594: ARRAY
102595: PUSH
102596: LD_STRING l
102598: EQUAL
102599: PUSH
102600: LD_VAR 0 1
102604: PPUSH
102605: CALL_OW 437
102609: PUSH
102610: LD_INT 1
102612: ARRAY
102613: PUSH
102614: LD_INT 4
102616: ARRAY
102617: PUSH
102618: LD_VAR 0 2
102622: EQUAL
102623: AND
102624: IFFALSE 102636
// result := true else
102626: LD_ADDR_VAR 0 3
102630: PUSH
102631: LD_INT 1
102633: ST_TO_ADDR
102634: GO 102644
// result := false ;
102636: LD_ADDR_VAR 0 3
102640: PUSH
102641: LD_INT 0
102643: ST_TO_ADDR
// end else
102644: GO 102654
// result := false ;
102646: LD_ADDR_VAR 0 3
102650: PUSH
102651: LD_INT 0
102653: ST_TO_ADDR
// end ;
102654: LD_VAR 0 3
102658: RET
// export function HealTarget ( sci ) ; begin
102659: LD_INT 0
102661: PPUSH
// if not sci then
102662: LD_VAR 0 1
102666: NOT
102667: IFFALSE 102671
// exit ;
102669: GO 102736
// result := 0 ;
102671: LD_ADDR_VAR 0 2
102675: PUSH
102676: LD_INT 0
102678: ST_TO_ADDR
// if GetTaskList ( sci ) then
102679: LD_VAR 0 1
102683: PPUSH
102684: CALL_OW 437
102688: IFFALSE 102736
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
102690: LD_VAR 0 1
102694: PPUSH
102695: CALL_OW 437
102699: PUSH
102700: LD_INT 1
102702: ARRAY
102703: PUSH
102704: LD_INT 1
102706: ARRAY
102707: PUSH
102708: LD_STRING l
102710: EQUAL
102711: IFFALSE 102736
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
102713: LD_ADDR_VAR 0 2
102717: PUSH
102718: LD_VAR 0 1
102722: PPUSH
102723: CALL_OW 437
102727: PUSH
102728: LD_INT 1
102730: ARRAY
102731: PUSH
102732: LD_INT 4
102734: ARRAY
102735: ST_TO_ADDR
// end ;
102736: LD_VAR 0 2
102740: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
102741: LD_INT 0
102743: PPUSH
102744: PPUSH
102745: PPUSH
102746: PPUSH
// if not base_units then
102747: LD_VAR 0 1
102751: NOT
102752: IFFALSE 102756
// exit ;
102754: GO 102843
// result := false ;
102756: LD_ADDR_VAR 0 2
102760: PUSH
102761: LD_INT 0
102763: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
102764: LD_ADDR_VAR 0 5
102768: PUSH
102769: LD_VAR 0 1
102773: PPUSH
102774: LD_INT 21
102776: PUSH
102777: LD_INT 3
102779: PUSH
102780: EMPTY
102781: LIST
102782: LIST
102783: PPUSH
102784: CALL_OW 72
102788: ST_TO_ADDR
// if not tmp then
102789: LD_VAR 0 5
102793: NOT
102794: IFFALSE 102798
// exit ;
102796: GO 102843
// for i in tmp do
102798: LD_ADDR_VAR 0 3
102802: PUSH
102803: LD_VAR 0 5
102807: PUSH
102808: FOR_IN
102809: IFFALSE 102841
// begin result := EnemyInRange ( i , 22 ) ;
102811: LD_ADDR_VAR 0 2
102815: PUSH
102816: LD_VAR 0 3
102820: PPUSH
102821: LD_INT 22
102823: PPUSH
102824: CALL 100430 0 2
102828: ST_TO_ADDR
// if result then
102829: LD_VAR 0 2
102833: IFFALSE 102839
// exit ;
102835: POP
102836: POP
102837: GO 102843
// end ;
102839: GO 102808
102841: POP
102842: POP
// end ;
102843: LD_VAR 0 2
102847: RET
// export function FilterByTag ( units , tag ) ; begin
102848: LD_INT 0
102850: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
102851: LD_ADDR_VAR 0 3
102855: PUSH
102856: LD_VAR 0 1
102860: PPUSH
102861: LD_INT 120
102863: PUSH
102864: LD_VAR 0 2
102868: PUSH
102869: EMPTY
102870: LIST
102871: LIST
102872: PPUSH
102873: CALL_OW 72
102877: ST_TO_ADDR
// end ;
102878: LD_VAR 0 3
102882: RET
// export function IsDriver ( un ) ; begin
102883: LD_INT 0
102885: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
102886: LD_ADDR_VAR 0 2
102890: PUSH
102891: LD_VAR 0 1
102895: PUSH
102896: LD_INT 55
102898: PUSH
102899: EMPTY
102900: LIST
102901: PPUSH
102902: CALL_OW 69
102906: IN
102907: ST_TO_ADDR
// end ;
102908: LD_VAR 0 2
102912: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
102913: LD_INT 0
102915: PPUSH
102916: PPUSH
// list := [ ] ;
102917: LD_ADDR_VAR 0 5
102921: PUSH
102922: EMPTY
102923: ST_TO_ADDR
// case d of 0 :
102924: LD_VAR 0 3
102928: PUSH
102929: LD_INT 0
102931: DOUBLE
102932: EQUAL
102933: IFTRUE 102937
102935: GO 103070
102937: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
102938: LD_ADDR_VAR 0 5
102942: PUSH
102943: LD_VAR 0 1
102947: PUSH
102948: LD_INT 4
102950: MINUS
102951: PUSH
102952: LD_VAR 0 2
102956: PUSH
102957: LD_INT 4
102959: MINUS
102960: PUSH
102961: LD_INT 2
102963: PUSH
102964: EMPTY
102965: LIST
102966: LIST
102967: LIST
102968: PUSH
102969: LD_VAR 0 1
102973: PUSH
102974: LD_INT 3
102976: MINUS
102977: PUSH
102978: LD_VAR 0 2
102982: PUSH
102983: LD_INT 1
102985: PUSH
102986: EMPTY
102987: LIST
102988: LIST
102989: LIST
102990: PUSH
102991: LD_VAR 0 1
102995: PUSH
102996: LD_INT 4
102998: PLUS
102999: PUSH
103000: LD_VAR 0 2
103004: PUSH
103005: LD_INT 4
103007: PUSH
103008: EMPTY
103009: LIST
103010: LIST
103011: LIST
103012: PUSH
103013: LD_VAR 0 1
103017: PUSH
103018: LD_INT 3
103020: PLUS
103021: PUSH
103022: LD_VAR 0 2
103026: PUSH
103027: LD_INT 3
103029: PLUS
103030: PUSH
103031: LD_INT 5
103033: PUSH
103034: EMPTY
103035: LIST
103036: LIST
103037: LIST
103038: PUSH
103039: LD_VAR 0 1
103043: PUSH
103044: LD_VAR 0 2
103048: PUSH
103049: LD_INT 4
103051: PLUS
103052: PUSH
103053: LD_INT 0
103055: PUSH
103056: EMPTY
103057: LIST
103058: LIST
103059: LIST
103060: PUSH
103061: EMPTY
103062: LIST
103063: LIST
103064: LIST
103065: LIST
103066: LIST
103067: ST_TO_ADDR
// end ; 1 :
103068: GO 103768
103070: LD_INT 1
103072: DOUBLE
103073: EQUAL
103074: IFTRUE 103078
103076: GO 103211
103078: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
103079: LD_ADDR_VAR 0 5
103083: PUSH
103084: LD_VAR 0 1
103088: PUSH
103089: LD_VAR 0 2
103093: PUSH
103094: LD_INT 4
103096: MINUS
103097: PUSH
103098: LD_INT 3
103100: PUSH
103101: EMPTY
103102: LIST
103103: LIST
103104: LIST
103105: PUSH
103106: LD_VAR 0 1
103110: PUSH
103111: LD_INT 3
103113: MINUS
103114: PUSH
103115: LD_VAR 0 2
103119: PUSH
103120: LD_INT 3
103122: MINUS
103123: PUSH
103124: LD_INT 2
103126: PUSH
103127: EMPTY
103128: LIST
103129: LIST
103130: LIST
103131: PUSH
103132: LD_VAR 0 1
103136: PUSH
103137: LD_INT 4
103139: MINUS
103140: PUSH
103141: LD_VAR 0 2
103145: PUSH
103146: LD_INT 1
103148: PUSH
103149: EMPTY
103150: LIST
103151: LIST
103152: LIST
103153: PUSH
103154: LD_VAR 0 1
103158: PUSH
103159: LD_VAR 0 2
103163: PUSH
103164: LD_INT 3
103166: PLUS
103167: PUSH
103168: LD_INT 0
103170: PUSH
103171: EMPTY
103172: LIST
103173: LIST
103174: LIST
103175: PUSH
103176: LD_VAR 0 1
103180: PUSH
103181: LD_INT 4
103183: PLUS
103184: PUSH
103185: LD_VAR 0 2
103189: PUSH
103190: LD_INT 4
103192: PLUS
103193: PUSH
103194: LD_INT 5
103196: PUSH
103197: EMPTY
103198: LIST
103199: LIST
103200: LIST
103201: PUSH
103202: EMPTY
103203: LIST
103204: LIST
103205: LIST
103206: LIST
103207: LIST
103208: ST_TO_ADDR
// end ; 2 :
103209: GO 103768
103211: LD_INT 2
103213: DOUBLE
103214: EQUAL
103215: IFTRUE 103219
103217: GO 103348
103219: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
103220: LD_ADDR_VAR 0 5
103224: PUSH
103225: LD_VAR 0 1
103229: PUSH
103230: LD_VAR 0 2
103234: PUSH
103235: LD_INT 3
103237: MINUS
103238: PUSH
103239: LD_INT 3
103241: PUSH
103242: EMPTY
103243: LIST
103244: LIST
103245: LIST
103246: PUSH
103247: LD_VAR 0 1
103251: PUSH
103252: LD_INT 4
103254: PLUS
103255: PUSH
103256: LD_VAR 0 2
103260: PUSH
103261: LD_INT 4
103263: PUSH
103264: EMPTY
103265: LIST
103266: LIST
103267: LIST
103268: PUSH
103269: LD_VAR 0 1
103273: PUSH
103274: LD_VAR 0 2
103278: PUSH
103279: LD_INT 4
103281: PLUS
103282: PUSH
103283: LD_INT 0
103285: PUSH
103286: EMPTY
103287: LIST
103288: LIST
103289: LIST
103290: PUSH
103291: LD_VAR 0 1
103295: PUSH
103296: LD_INT 3
103298: MINUS
103299: PUSH
103300: LD_VAR 0 2
103304: PUSH
103305: LD_INT 1
103307: PUSH
103308: EMPTY
103309: LIST
103310: LIST
103311: LIST
103312: PUSH
103313: LD_VAR 0 1
103317: PUSH
103318: LD_INT 4
103320: MINUS
103321: PUSH
103322: LD_VAR 0 2
103326: PUSH
103327: LD_INT 4
103329: MINUS
103330: PUSH
103331: LD_INT 2
103333: PUSH
103334: EMPTY
103335: LIST
103336: LIST
103337: LIST
103338: PUSH
103339: EMPTY
103340: LIST
103341: LIST
103342: LIST
103343: LIST
103344: LIST
103345: ST_TO_ADDR
// end ; 3 :
103346: GO 103768
103348: LD_INT 3
103350: DOUBLE
103351: EQUAL
103352: IFTRUE 103356
103354: GO 103489
103356: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
103357: LD_ADDR_VAR 0 5
103361: PUSH
103362: LD_VAR 0 1
103366: PUSH
103367: LD_INT 3
103369: PLUS
103370: PUSH
103371: LD_VAR 0 2
103375: PUSH
103376: LD_INT 4
103378: PUSH
103379: EMPTY
103380: LIST
103381: LIST
103382: LIST
103383: PUSH
103384: LD_VAR 0 1
103388: PUSH
103389: LD_INT 4
103391: PLUS
103392: PUSH
103393: LD_VAR 0 2
103397: PUSH
103398: LD_INT 4
103400: PLUS
103401: PUSH
103402: LD_INT 5
103404: PUSH
103405: EMPTY
103406: LIST
103407: LIST
103408: LIST
103409: PUSH
103410: LD_VAR 0 1
103414: PUSH
103415: LD_INT 4
103417: MINUS
103418: PUSH
103419: LD_VAR 0 2
103423: PUSH
103424: LD_INT 1
103426: PUSH
103427: EMPTY
103428: LIST
103429: LIST
103430: LIST
103431: PUSH
103432: LD_VAR 0 1
103436: PUSH
103437: LD_VAR 0 2
103441: PUSH
103442: LD_INT 4
103444: MINUS
103445: PUSH
103446: LD_INT 3
103448: PUSH
103449: EMPTY
103450: LIST
103451: LIST
103452: LIST
103453: PUSH
103454: LD_VAR 0 1
103458: PUSH
103459: LD_INT 3
103461: MINUS
103462: PUSH
103463: LD_VAR 0 2
103467: PUSH
103468: LD_INT 3
103470: MINUS
103471: PUSH
103472: LD_INT 2
103474: PUSH
103475: EMPTY
103476: LIST
103477: LIST
103478: LIST
103479: PUSH
103480: EMPTY
103481: LIST
103482: LIST
103483: LIST
103484: LIST
103485: LIST
103486: ST_TO_ADDR
// end ; 4 :
103487: GO 103768
103489: LD_INT 4
103491: DOUBLE
103492: EQUAL
103493: IFTRUE 103497
103495: GO 103630
103497: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
103498: LD_ADDR_VAR 0 5
103502: PUSH
103503: LD_VAR 0 1
103507: PUSH
103508: LD_VAR 0 2
103512: PUSH
103513: LD_INT 4
103515: PLUS
103516: PUSH
103517: LD_INT 0
103519: PUSH
103520: EMPTY
103521: LIST
103522: LIST
103523: LIST
103524: PUSH
103525: LD_VAR 0 1
103529: PUSH
103530: LD_INT 3
103532: PLUS
103533: PUSH
103534: LD_VAR 0 2
103538: PUSH
103539: LD_INT 3
103541: PLUS
103542: PUSH
103543: LD_INT 5
103545: PUSH
103546: EMPTY
103547: LIST
103548: LIST
103549: LIST
103550: PUSH
103551: LD_VAR 0 1
103555: PUSH
103556: LD_INT 4
103558: PLUS
103559: PUSH
103560: LD_VAR 0 2
103564: PUSH
103565: LD_INT 4
103567: PUSH
103568: EMPTY
103569: LIST
103570: LIST
103571: LIST
103572: PUSH
103573: LD_VAR 0 1
103577: PUSH
103578: LD_VAR 0 2
103582: PUSH
103583: LD_INT 3
103585: MINUS
103586: PUSH
103587: LD_INT 3
103589: PUSH
103590: EMPTY
103591: LIST
103592: LIST
103593: LIST
103594: PUSH
103595: LD_VAR 0 1
103599: PUSH
103600: LD_INT 4
103602: MINUS
103603: PUSH
103604: LD_VAR 0 2
103608: PUSH
103609: LD_INT 4
103611: MINUS
103612: PUSH
103613: LD_INT 2
103615: PUSH
103616: EMPTY
103617: LIST
103618: LIST
103619: LIST
103620: PUSH
103621: EMPTY
103622: LIST
103623: LIST
103624: LIST
103625: LIST
103626: LIST
103627: ST_TO_ADDR
// end ; 5 :
103628: GO 103768
103630: LD_INT 5
103632: DOUBLE
103633: EQUAL
103634: IFTRUE 103638
103636: GO 103767
103638: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
103639: LD_ADDR_VAR 0 5
103643: PUSH
103644: LD_VAR 0 1
103648: PUSH
103649: LD_INT 4
103651: MINUS
103652: PUSH
103653: LD_VAR 0 2
103657: PUSH
103658: LD_INT 1
103660: PUSH
103661: EMPTY
103662: LIST
103663: LIST
103664: LIST
103665: PUSH
103666: LD_VAR 0 1
103670: PUSH
103671: LD_VAR 0 2
103675: PUSH
103676: LD_INT 4
103678: MINUS
103679: PUSH
103680: LD_INT 3
103682: PUSH
103683: EMPTY
103684: LIST
103685: LIST
103686: LIST
103687: PUSH
103688: LD_VAR 0 1
103692: PUSH
103693: LD_INT 4
103695: PLUS
103696: PUSH
103697: LD_VAR 0 2
103701: PUSH
103702: LD_INT 4
103704: PLUS
103705: PUSH
103706: LD_INT 5
103708: PUSH
103709: EMPTY
103710: LIST
103711: LIST
103712: LIST
103713: PUSH
103714: LD_VAR 0 1
103718: PUSH
103719: LD_INT 3
103721: PLUS
103722: PUSH
103723: LD_VAR 0 2
103727: PUSH
103728: LD_INT 4
103730: PUSH
103731: EMPTY
103732: LIST
103733: LIST
103734: LIST
103735: PUSH
103736: LD_VAR 0 1
103740: PUSH
103741: LD_VAR 0 2
103745: PUSH
103746: LD_INT 3
103748: PLUS
103749: PUSH
103750: LD_INT 0
103752: PUSH
103753: EMPTY
103754: LIST
103755: LIST
103756: LIST
103757: PUSH
103758: EMPTY
103759: LIST
103760: LIST
103761: LIST
103762: LIST
103763: LIST
103764: ST_TO_ADDR
// end ; end ;
103765: GO 103768
103767: POP
// result := list ;
103768: LD_ADDR_VAR 0 4
103772: PUSH
103773: LD_VAR 0 5
103777: ST_TO_ADDR
// end ;
103778: LD_VAR 0 4
103782: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
103783: LD_INT 0
103785: PPUSH
103786: PPUSH
103787: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
103788: LD_VAR 0 1
103792: NOT
103793: PUSH
103794: LD_VAR 0 2
103798: PUSH
103799: LD_INT 1
103801: PUSH
103802: LD_INT 2
103804: PUSH
103805: LD_INT 3
103807: PUSH
103808: LD_INT 4
103810: PUSH
103811: EMPTY
103812: LIST
103813: LIST
103814: LIST
103815: LIST
103816: IN
103817: NOT
103818: OR
103819: IFFALSE 103823
// exit ;
103821: GO 103906
// tmp := [ ] ;
103823: LD_ADDR_VAR 0 5
103827: PUSH
103828: EMPTY
103829: ST_TO_ADDR
// for i in units do
103830: LD_ADDR_VAR 0 4
103834: PUSH
103835: LD_VAR 0 1
103839: PUSH
103840: FOR_IN
103841: IFFALSE 103875
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
103843: LD_ADDR_VAR 0 5
103847: PUSH
103848: LD_VAR 0 5
103852: PPUSH
103853: LD_VAR 0 4
103857: PPUSH
103858: LD_VAR 0 2
103862: PPUSH
103863: CALL_OW 259
103867: PPUSH
103868: CALL 105266 0 2
103872: ST_TO_ADDR
103873: GO 103840
103875: POP
103876: POP
// if not tmp then
103877: LD_VAR 0 5
103881: NOT
103882: IFFALSE 103886
// exit ;
103884: GO 103906
// result := SortListByListDesc ( units , tmp ) ;
103886: LD_ADDR_VAR 0 3
103890: PUSH
103891: LD_VAR 0 1
103895: PPUSH
103896: LD_VAR 0 5
103900: PPUSH
103901: CALL_OW 77
103905: ST_TO_ADDR
// end ;
103906: LD_VAR 0 3
103910: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
103911: LD_INT 0
103913: PPUSH
103914: PPUSH
103915: PPUSH
// result := false ;
103916: LD_ADDR_VAR 0 3
103920: PUSH
103921: LD_INT 0
103923: ST_TO_ADDR
// if not building then
103924: LD_VAR 0 2
103928: NOT
103929: IFFALSE 103933
// exit ;
103931: GO 104071
// x := GetX ( building ) ;
103933: LD_ADDR_VAR 0 4
103937: PUSH
103938: LD_VAR 0 2
103942: PPUSH
103943: CALL_OW 250
103947: ST_TO_ADDR
// y := GetY ( building ) ;
103948: LD_ADDR_VAR 0 5
103952: PUSH
103953: LD_VAR 0 2
103957: PPUSH
103958: CALL_OW 251
103962: ST_TO_ADDR
// if not x or not y then
103963: LD_VAR 0 4
103967: NOT
103968: PUSH
103969: LD_VAR 0 5
103973: NOT
103974: OR
103975: IFFALSE 103979
// exit ;
103977: GO 104071
// if GetTaskList ( unit ) then
103979: LD_VAR 0 1
103983: PPUSH
103984: CALL_OW 437
103988: IFFALSE 104071
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
103990: LD_STRING e
103992: PUSH
103993: LD_VAR 0 1
103997: PPUSH
103998: CALL_OW 437
104002: PUSH
104003: LD_INT 1
104005: ARRAY
104006: PUSH
104007: LD_INT 1
104009: ARRAY
104010: EQUAL
104011: PUSH
104012: LD_VAR 0 4
104016: PUSH
104017: LD_VAR 0 1
104021: PPUSH
104022: CALL_OW 437
104026: PUSH
104027: LD_INT 1
104029: ARRAY
104030: PUSH
104031: LD_INT 2
104033: ARRAY
104034: EQUAL
104035: AND
104036: PUSH
104037: LD_VAR 0 5
104041: PUSH
104042: LD_VAR 0 1
104046: PPUSH
104047: CALL_OW 437
104051: PUSH
104052: LD_INT 1
104054: ARRAY
104055: PUSH
104056: LD_INT 3
104058: ARRAY
104059: EQUAL
104060: AND
104061: IFFALSE 104071
// result := true end ;
104063: LD_ADDR_VAR 0 3
104067: PUSH
104068: LD_INT 1
104070: ST_TO_ADDR
// end ;
104071: LD_VAR 0 3
104075: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
104076: LD_INT 0
104078: PPUSH
// result := false ;
104079: LD_ADDR_VAR 0 4
104083: PUSH
104084: LD_INT 0
104086: ST_TO_ADDR
// if GetTaskList ( unit ) then
104087: LD_VAR 0 1
104091: PPUSH
104092: CALL_OW 437
104096: IFFALSE 104179
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
104098: LD_STRING M
104100: PUSH
104101: LD_VAR 0 1
104105: PPUSH
104106: CALL_OW 437
104110: PUSH
104111: LD_INT 1
104113: ARRAY
104114: PUSH
104115: LD_INT 1
104117: ARRAY
104118: EQUAL
104119: PUSH
104120: LD_VAR 0 2
104124: PUSH
104125: LD_VAR 0 1
104129: PPUSH
104130: CALL_OW 437
104134: PUSH
104135: LD_INT 1
104137: ARRAY
104138: PUSH
104139: LD_INT 2
104141: ARRAY
104142: EQUAL
104143: AND
104144: PUSH
104145: LD_VAR 0 3
104149: PUSH
104150: LD_VAR 0 1
104154: PPUSH
104155: CALL_OW 437
104159: PUSH
104160: LD_INT 1
104162: ARRAY
104163: PUSH
104164: LD_INT 3
104166: ARRAY
104167: EQUAL
104168: AND
104169: IFFALSE 104179
// result := true ;
104171: LD_ADDR_VAR 0 4
104175: PUSH
104176: LD_INT 1
104178: ST_TO_ADDR
// end ; end ;
104179: LD_VAR 0 4
104183: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
104184: LD_INT 0
104186: PPUSH
104187: PPUSH
104188: PPUSH
104189: PPUSH
// if not unit or not area then
104190: LD_VAR 0 1
104194: NOT
104195: PUSH
104196: LD_VAR 0 2
104200: NOT
104201: OR
104202: IFFALSE 104206
// exit ;
104204: GO 104369
// tmp := AreaToList ( area , i ) ;
104206: LD_ADDR_VAR 0 6
104210: PUSH
104211: LD_VAR 0 2
104215: PPUSH
104216: LD_VAR 0 5
104220: PPUSH
104221: CALL_OW 517
104225: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
104226: LD_ADDR_VAR 0 5
104230: PUSH
104231: DOUBLE
104232: LD_INT 1
104234: DEC
104235: ST_TO_ADDR
104236: LD_VAR 0 6
104240: PUSH
104241: LD_INT 1
104243: ARRAY
104244: PUSH
104245: FOR_TO
104246: IFFALSE 104367
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
104248: LD_ADDR_VAR 0 7
104252: PUSH
104253: LD_VAR 0 6
104257: PUSH
104258: LD_INT 1
104260: ARRAY
104261: PUSH
104262: LD_VAR 0 5
104266: ARRAY
104267: PUSH
104268: LD_VAR 0 6
104272: PUSH
104273: LD_INT 2
104275: ARRAY
104276: PUSH
104277: LD_VAR 0 5
104281: ARRAY
104282: PUSH
104283: EMPTY
104284: LIST
104285: LIST
104286: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 3 ] ) = 0 then
104287: LD_INT 92
104289: PUSH
104290: LD_VAR 0 7
104294: PUSH
104295: LD_INT 1
104297: ARRAY
104298: PUSH
104299: LD_VAR 0 7
104303: PUSH
104304: LD_INT 2
104306: ARRAY
104307: PUSH
104308: LD_INT 3
104310: PUSH
104311: EMPTY
104312: LIST
104313: LIST
104314: LIST
104315: LIST
104316: PPUSH
104317: CALL_OW 69
104321: PUSH
104322: LD_INT 0
104324: EQUAL
104325: IFFALSE 104365
// begin PlaceUnitArea ( unit , area , mode ) ;
104327: LD_VAR 0 1
104331: PPUSH
104332: LD_VAR 0 2
104336: PPUSH
104337: LD_VAR 0 3
104341: PPUSH
104342: CALL_OW 49
// result := IsPlaced ( unit ) ;
104346: LD_ADDR_VAR 0 4
104350: PUSH
104351: LD_VAR 0 1
104355: PPUSH
104356: CALL_OW 305
104360: ST_TO_ADDR
// exit ;
104361: POP
104362: POP
104363: GO 104369
// end ; end ;
104365: GO 104245
104367: POP
104368: POP
// end ;
104369: LD_VAR 0 4
104373: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
104374: LD_INT 0
104376: PPUSH
104377: PPUSH
104378: PPUSH
// if not side or side > 8 then
104379: LD_VAR 0 1
104383: NOT
104384: PUSH
104385: LD_VAR 0 1
104389: PUSH
104390: LD_INT 8
104392: GREATER
104393: OR
104394: IFFALSE 104398
// exit ;
104396: GO 104585
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
104398: LD_ADDR_VAR 0 4
104402: PUSH
104403: LD_INT 22
104405: PUSH
104406: LD_VAR 0 1
104410: PUSH
104411: EMPTY
104412: LIST
104413: LIST
104414: PUSH
104415: LD_INT 21
104417: PUSH
104418: LD_INT 3
104420: PUSH
104421: EMPTY
104422: LIST
104423: LIST
104424: PUSH
104425: EMPTY
104426: LIST
104427: LIST
104428: PPUSH
104429: CALL_OW 69
104433: ST_TO_ADDR
// if not tmp then
104434: LD_VAR 0 4
104438: NOT
104439: IFFALSE 104443
// exit ;
104441: GO 104585
// enable_addtolog := true ;
104443: LD_ADDR_OWVAR 81
104447: PUSH
104448: LD_INT 1
104450: ST_TO_ADDR
// AddToLog ( [ ) ;
104451: LD_STRING [
104453: PPUSH
104454: CALL_OW 561
// for i in tmp do
104458: LD_ADDR_VAR 0 3
104462: PUSH
104463: LD_VAR 0 4
104467: PUSH
104468: FOR_IN
104469: IFFALSE 104576
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
104471: LD_STRING [
104473: PUSH
104474: LD_VAR 0 3
104478: PPUSH
104479: CALL_OW 266
104483: STR
104484: PUSH
104485: LD_STRING , 
104487: STR
104488: PUSH
104489: LD_VAR 0 3
104493: PPUSH
104494: CALL_OW 250
104498: STR
104499: PUSH
104500: LD_STRING , 
104502: STR
104503: PUSH
104504: LD_VAR 0 3
104508: PPUSH
104509: CALL_OW 251
104513: STR
104514: PUSH
104515: LD_STRING , 
104517: STR
104518: PUSH
104519: LD_VAR 0 3
104523: PPUSH
104524: CALL_OW 254
104528: STR
104529: PUSH
104530: LD_STRING , 
104532: STR
104533: PUSH
104534: LD_VAR 0 3
104538: PPUSH
104539: LD_INT 1
104541: PPUSH
104542: CALL_OW 268
104546: STR
104547: PUSH
104548: LD_STRING , 
104550: STR
104551: PUSH
104552: LD_VAR 0 3
104556: PPUSH
104557: LD_INT 2
104559: PPUSH
104560: CALL_OW 268
104564: STR
104565: PUSH
104566: LD_STRING ],
104568: STR
104569: PPUSH
104570: CALL_OW 561
// end ;
104574: GO 104468
104576: POP
104577: POP
// AddToLog ( ]; ) ;
104578: LD_STRING ];
104580: PPUSH
104581: CALL_OW 561
// end ;
104585: LD_VAR 0 2
104589: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
104590: LD_INT 0
104592: PPUSH
104593: PPUSH
104594: PPUSH
104595: PPUSH
104596: PPUSH
// if not area or not rate or not max then
104597: LD_VAR 0 1
104601: NOT
104602: PUSH
104603: LD_VAR 0 2
104607: NOT
104608: OR
104609: PUSH
104610: LD_VAR 0 4
104614: NOT
104615: OR
104616: IFFALSE 104620
// exit ;
104618: GO 104809
// while 1 do
104620: LD_INT 1
104622: IFFALSE 104809
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
104624: LD_ADDR_VAR 0 9
104628: PUSH
104629: LD_VAR 0 1
104633: PPUSH
104634: LD_INT 1
104636: PPUSH
104637: CALL_OW 287
104641: PUSH
104642: LD_INT 10
104644: MUL
104645: ST_TO_ADDR
// r := rate / 10 ;
104646: LD_ADDR_VAR 0 7
104650: PUSH
104651: LD_VAR 0 2
104655: PUSH
104656: LD_INT 10
104658: DIVREAL
104659: ST_TO_ADDR
// time := 1 1$00 ;
104660: LD_ADDR_VAR 0 8
104664: PUSH
104665: LD_INT 2100
104667: ST_TO_ADDR
// if amount < min then
104668: LD_VAR 0 9
104672: PUSH
104673: LD_VAR 0 3
104677: LESS
104678: IFFALSE 104696
// r := r * 2 else
104680: LD_ADDR_VAR 0 7
104684: PUSH
104685: LD_VAR 0 7
104689: PUSH
104690: LD_INT 2
104692: MUL
104693: ST_TO_ADDR
104694: GO 104722
// if amount > max then
104696: LD_VAR 0 9
104700: PUSH
104701: LD_VAR 0 4
104705: GREATER
104706: IFFALSE 104722
// r := r / 2 ;
104708: LD_ADDR_VAR 0 7
104712: PUSH
104713: LD_VAR 0 7
104717: PUSH
104718: LD_INT 2
104720: DIVREAL
104721: ST_TO_ADDR
// time := time / r ;
104722: LD_ADDR_VAR 0 8
104726: PUSH
104727: LD_VAR 0 8
104731: PUSH
104732: LD_VAR 0 7
104736: DIVREAL
104737: ST_TO_ADDR
// if time < 0 then
104738: LD_VAR 0 8
104742: PUSH
104743: LD_INT 0
104745: LESS
104746: IFFALSE 104763
// time := time * - 1 ;
104748: LD_ADDR_VAR 0 8
104752: PUSH
104753: LD_VAR 0 8
104757: PUSH
104758: LD_INT 1
104760: NEG
104761: MUL
104762: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
104763: LD_VAR 0 8
104767: PUSH
104768: LD_INT 35
104770: PPUSH
104771: LD_INT 875
104773: PPUSH
104774: CALL_OW 12
104778: PLUS
104779: PPUSH
104780: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
104784: LD_INT 1
104786: PPUSH
104787: LD_INT 5
104789: PPUSH
104790: CALL_OW 12
104794: PPUSH
104795: LD_VAR 0 1
104799: PPUSH
104800: LD_INT 1
104802: PPUSH
104803: CALL_OW 55
// end ;
104807: GO 104620
// end ;
104809: LD_VAR 0 5
104813: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
104814: LD_INT 0
104816: PPUSH
104817: PPUSH
104818: PPUSH
104819: PPUSH
104820: PPUSH
104821: PPUSH
104822: PPUSH
104823: PPUSH
// if not turrets or not factories then
104824: LD_VAR 0 1
104828: NOT
104829: PUSH
104830: LD_VAR 0 2
104834: NOT
104835: OR
104836: IFFALSE 104840
// exit ;
104838: GO 105147
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
104840: LD_ADDR_VAR 0 10
104844: PUSH
104845: LD_INT 5
104847: PUSH
104848: LD_INT 6
104850: PUSH
104851: EMPTY
104852: LIST
104853: LIST
104854: PUSH
104855: LD_INT 2
104857: PUSH
104858: LD_INT 4
104860: PUSH
104861: EMPTY
104862: LIST
104863: LIST
104864: PUSH
104865: LD_INT 3
104867: PUSH
104868: LD_INT 5
104870: PUSH
104871: EMPTY
104872: LIST
104873: LIST
104874: PUSH
104875: EMPTY
104876: LIST
104877: LIST
104878: LIST
104879: PUSH
104880: LD_INT 24
104882: PUSH
104883: LD_INT 25
104885: PUSH
104886: EMPTY
104887: LIST
104888: LIST
104889: PUSH
104890: LD_INT 23
104892: PUSH
104893: LD_INT 27
104895: PUSH
104896: EMPTY
104897: LIST
104898: LIST
104899: PUSH
104900: EMPTY
104901: LIST
104902: LIST
104903: PUSH
104904: LD_INT 42
104906: PUSH
104907: LD_INT 43
104909: PUSH
104910: EMPTY
104911: LIST
104912: LIST
104913: PUSH
104914: LD_INT 44
104916: PUSH
104917: LD_INT 46
104919: PUSH
104920: EMPTY
104921: LIST
104922: LIST
104923: PUSH
104924: LD_INT 45
104926: PUSH
104927: LD_INT 47
104929: PUSH
104930: EMPTY
104931: LIST
104932: LIST
104933: PUSH
104934: EMPTY
104935: LIST
104936: LIST
104937: LIST
104938: PUSH
104939: EMPTY
104940: LIST
104941: LIST
104942: LIST
104943: ST_TO_ADDR
// result := [ ] ;
104944: LD_ADDR_VAR 0 3
104948: PUSH
104949: EMPTY
104950: ST_TO_ADDR
// for i in turrets do
104951: LD_ADDR_VAR 0 4
104955: PUSH
104956: LD_VAR 0 1
104960: PUSH
104961: FOR_IN
104962: IFFALSE 105145
// begin nat := GetNation ( i ) ;
104964: LD_ADDR_VAR 0 7
104968: PUSH
104969: LD_VAR 0 4
104973: PPUSH
104974: CALL_OW 248
104978: ST_TO_ADDR
// weapon := 0 ;
104979: LD_ADDR_VAR 0 8
104983: PUSH
104984: LD_INT 0
104986: ST_TO_ADDR
// if not nat then
104987: LD_VAR 0 7
104991: NOT
104992: IFFALSE 104996
// continue ;
104994: GO 104961
// for j in list [ nat ] do
104996: LD_ADDR_VAR 0 5
105000: PUSH
105001: LD_VAR 0 10
105005: PUSH
105006: LD_VAR 0 7
105010: ARRAY
105011: PUSH
105012: FOR_IN
105013: IFFALSE 105054
// if GetBWeapon ( i ) = j [ 1 ] then
105015: LD_VAR 0 4
105019: PPUSH
105020: CALL_OW 269
105024: PUSH
105025: LD_VAR 0 5
105029: PUSH
105030: LD_INT 1
105032: ARRAY
105033: EQUAL
105034: IFFALSE 105052
// begin weapon := j [ 2 ] ;
105036: LD_ADDR_VAR 0 8
105040: PUSH
105041: LD_VAR 0 5
105045: PUSH
105046: LD_INT 2
105048: ARRAY
105049: ST_TO_ADDR
// break ;
105050: GO 105054
// end ;
105052: GO 105012
105054: POP
105055: POP
// if not weapon then
105056: LD_VAR 0 8
105060: NOT
105061: IFFALSE 105065
// continue ;
105063: GO 104961
// for k in factories do
105065: LD_ADDR_VAR 0 6
105069: PUSH
105070: LD_VAR 0 2
105074: PUSH
105075: FOR_IN
105076: IFFALSE 105141
// begin weapons := AvailableWeaponList ( k ) ;
105078: LD_ADDR_VAR 0 9
105082: PUSH
105083: LD_VAR 0 6
105087: PPUSH
105088: CALL_OW 478
105092: ST_TO_ADDR
// if not weapons then
105093: LD_VAR 0 9
105097: NOT
105098: IFFALSE 105102
// continue ;
105100: GO 105075
// if weapon in weapons then
105102: LD_VAR 0 8
105106: PUSH
105107: LD_VAR 0 9
105111: IN
105112: IFFALSE 105139
// begin result := [ i , weapon ] ;
105114: LD_ADDR_VAR 0 3
105118: PUSH
105119: LD_VAR 0 4
105123: PUSH
105124: LD_VAR 0 8
105128: PUSH
105129: EMPTY
105130: LIST
105131: LIST
105132: ST_TO_ADDR
// exit ;
105133: POP
105134: POP
105135: POP
105136: POP
105137: GO 105147
// end ; end ;
105139: GO 105075
105141: POP
105142: POP
// end ;
105143: GO 104961
105145: POP
105146: POP
// end ;
105147: LD_VAR 0 3
105151: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
105152: LD_INT 0
105154: PPUSH
// if not side or side > 8 then
105155: LD_VAR 0 3
105159: NOT
105160: PUSH
105161: LD_VAR 0 3
105165: PUSH
105166: LD_INT 8
105168: GREATER
105169: OR
105170: IFFALSE 105174
// exit ;
105172: GO 105233
// if not range then
105174: LD_VAR 0 4
105178: NOT
105179: IFFALSE 105190
// range := - 12 ;
105181: LD_ADDR_VAR 0 4
105185: PUSH
105186: LD_INT 12
105188: NEG
105189: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
105190: LD_VAR 0 1
105194: PPUSH
105195: LD_VAR 0 2
105199: PPUSH
105200: LD_VAR 0 3
105204: PPUSH
105205: LD_VAR 0 4
105209: PPUSH
105210: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
105214: LD_VAR 0 1
105218: PPUSH
105219: LD_VAR 0 2
105223: PPUSH
105224: LD_VAR 0 3
105228: PPUSH
105229: CALL_OW 331
// end ;
105233: LD_VAR 0 5
105237: RET
// export function Video ( mode ) ; begin
105238: LD_INT 0
105240: PPUSH
// ingame_video = mode ;
105241: LD_ADDR_OWVAR 52
105245: PUSH
105246: LD_VAR 0 1
105250: ST_TO_ADDR
// interface_hidden = mode ;
105251: LD_ADDR_OWVAR 54
105255: PUSH
105256: LD_VAR 0 1
105260: ST_TO_ADDR
// end ;
105261: LD_VAR 0 2
105265: RET
// export function Join ( array , element ) ; begin
105266: LD_INT 0
105268: PPUSH
// result := Replace ( array , array + 1 , element ) ;
105269: LD_ADDR_VAR 0 3
105273: PUSH
105274: LD_VAR 0 1
105278: PPUSH
105279: LD_VAR 0 1
105283: PUSH
105284: LD_INT 1
105286: PLUS
105287: PPUSH
105288: LD_VAR 0 2
105292: PPUSH
105293: CALL_OW 1
105297: ST_TO_ADDR
// end ;
105298: LD_VAR 0 3
105302: RET
// export function JoinUnion ( array , element ) ; begin
105303: LD_INT 0
105305: PPUSH
// result := array union element ;
105306: LD_ADDR_VAR 0 3
105310: PUSH
105311: LD_VAR 0 1
105315: PUSH
105316: LD_VAR 0 2
105320: UNION
105321: ST_TO_ADDR
// end ;
105322: LD_VAR 0 3
105326: RET
// export function GetBehemoths ( side ) ; begin
105327: LD_INT 0
105329: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
105330: LD_ADDR_VAR 0 2
105334: PUSH
105335: LD_INT 22
105337: PUSH
105338: LD_VAR 0 1
105342: PUSH
105343: EMPTY
105344: LIST
105345: LIST
105346: PUSH
105347: LD_INT 31
105349: PUSH
105350: LD_INT 25
105352: PUSH
105353: EMPTY
105354: LIST
105355: LIST
105356: PUSH
105357: EMPTY
105358: LIST
105359: LIST
105360: PPUSH
105361: CALL_OW 69
105365: ST_TO_ADDR
// end ;
105366: LD_VAR 0 2
105370: RET
// export function Shuffle ( array ) ; var i , index ; begin
105371: LD_INT 0
105373: PPUSH
105374: PPUSH
105375: PPUSH
// result := [ ] ;
105376: LD_ADDR_VAR 0 2
105380: PUSH
105381: EMPTY
105382: ST_TO_ADDR
// if not array then
105383: LD_VAR 0 1
105387: NOT
105388: IFFALSE 105392
// exit ;
105390: GO 105491
// Randomize ;
105392: CALL_OW 10
// for i = array downto 1 do
105396: LD_ADDR_VAR 0 3
105400: PUSH
105401: DOUBLE
105402: LD_VAR 0 1
105406: INC
105407: ST_TO_ADDR
105408: LD_INT 1
105410: PUSH
105411: FOR_DOWNTO
105412: IFFALSE 105489
// begin index := rand ( 1 , array ) ;
105414: LD_ADDR_VAR 0 4
105418: PUSH
105419: LD_INT 1
105421: PPUSH
105422: LD_VAR 0 1
105426: PPUSH
105427: CALL_OW 12
105431: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
105432: LD_ADDR_VAR 0 2
105436: PUSH
105437: LD_VAR 0 2
105441: PPUSH
105442: LD_VAR 0 2
105446: PUSH
105447: LD_INT 1
105449: PLUS
105450: PPUSH
105451: LD_VAR 0 1
105455: PUSH
105456: LD_VAR 0 4
105460: ARRAY
105461: PPUSH
105462: CALL_OW 2
105466: ST_TO_ADDR
// array := Delete ( array , index ) ;
105467: LD_ADDR_VAR 0 1
105471: PUSH
105472: LD_VAR 0 1
105476: PPUSH
105477: LD_VAR 0 4
105481: PPUSH
105482: CALL_OW 3
105486: ST_TO_ADDR
// end ;
105487: GO 105411
105489: POP
105490: POP
// end ;
105491: LD_VAR 0 2
105495: RET
// export function GetBaseMaterials ( base ) ; begin
105496: LD_INT 0
105498: PPUSH
// result := [ 0 , 0 , 0 ] ;
105499: LD_ADDR_VAR 0 2
105503: PUSH
105504: LD_INT 0
105506: PUSH
105507: LD_INT 0
105509: PUSH
105510: LD_INT 0
105512: PUSH
105513: EMPTY
105514: LIST
105515: LIST
105516: LIST
105517: ST_TO_ADDR
// if not base then
105518: LD_VAR 0 1
105522: NOT
105523: IFFALSE 105527
// exit ;
105525: GO 105576
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
105527: LD_ADDR_VAR 0 2
105531: PUSH
105532: LD_VAR 0 1
105536: PPUSH
105537: LD_INT 1
105539: PPUSH
105540: CALL_OW 275
105544: PUSH
105545: LD_VAR 0 1
105549: PPUSH
105550: LD_INT 2
105552: PPUSH
105553: CALL_OW 275
105557: PUSH
105558: LD_VAR 0 1
105562: PPUSH
105563: LD_INT 3
105565: PPUSH
105566: CALL_OW 275
105570: PUSH
105571: EMPTY
105572: LIST
105573: LIST
105574: LIST
105575: ST_TO_ADDR
// end ;
105576: LD_VAR 0 2
105580: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
105581: LD_INT 0
105583: PPUSH
105584: PPUSH
// result := array ;
105585: LD_ADDR_VAR 0 3
105589: PUSH
105590: LD_VAR 0 1
105594: ST_TO_ADDR
// if size >= result then
105595: LD_VAR 0 2
105599: PUSH
105600: LD_VAR 0 3
105604: GREATEREQUAL
105605: IFFALSE 105609
// exit ;
105607: GO 105659
// if size then
105609: LD_VAR 0 2
105613: IFFALSE 105659
// for i := array downto size do
105615: LD_ADDR_VAR 0 4
105619: PUSH
105620: DOUBLE
105621: LD_VAR 0 1
105625: INC
105626: ST_TO_ADDR
105627: LD_VAR 0 2
105631: PUSH
105632: FOR_DOWNTO
105633: IFFALSE 105657
// result := Delete ( result , result ) ;
105635: LD_ADDR_VAR 0 3
105639: PUSH
105640: LD_VAR 0 3
105644: PPUSH
105645: LD_VAR 0 3
105649: PPUSH
105650: CALL_OW 3
105654: ST_TO_ADDR
105655: GO 105632
105657: POP
105658: POP
// end ;
105659: LD_VAR 0 3
105663: RET
// export function ComExit ( unit ) ; var tmp ; begin
105664: LD_INT 0
105666: PPUSH
105667: PPUSH
// if not IsInUnit ( unit ) then
105668: LD_VAR 0 1
105672: PPUSH
105673: CALL_OW 310
105677: NOT
105678: IFFALSE 105682
// exit ;
105680: GO 105742
// tmp := IsInUnit ( unit ) ;
105682: LD_ADDR_VAR 0 3
105686: PUSH
105687: LD_VAR 0 1
105691: PPUSH
105692: CALL_OW 310
105696: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
105697: LD_VAR 0 3
105701: PPUSH
105702: CALL_OW 247
105706: PUSH
105707: LD_INT 2
105709: EQUAL
105710: IFFALSE 105723
// ComExitVehicle ( unit ) else
105712: LD_VAR 0 1
105716: PPUSH
105717: CALL_OW 121
105721: GO 105732
// ComExitBuilding ( unit ) ;
105723: LD_VAR 0 1
105727: PPUSH
105728: CALL_OW 122
// result := tmp ;
105732: LD_ADDR_VAR 0 2
105736: PUSH
105737: LD_VAR 0 3
105741: ST_TO_ADDR
// end ;
105742: LD_VAR 0 2
105746: RET
// export function ComExitAll ( units ) ; var i ; begin
105747: LD_INT 0
105749: PPUSH
105750: PPUSH
// if not units then
105751: LD_VAR 0 1
105755: NOT
105756: IFFALSE 105760
// exit ;
105758: GO 105786
// for i in units do
105760: LD_ADDR_VAR 0 3
105764: PUSH
105765: LD_VAR 0 1
105769: PUSH
105770: FOR_IN
105771: IFFALSE 105784
// ComExit ( i ) ;
105773: LD_VAR 0 3
105777: PPUSH
105778: CALL 105664 0 1
105782: GO 105770
105784: POP
105785: POP
// end ;
105786: LD_VAR 0 2
105790: RET
// export function ResetHc ; begin
105791: LD_INT 0
105793: PPUSH
// InitHc ;
105794: CALL_OW 19
// hc_importance := 0 ;
105798: LD_ADDR_OWVAR 32
105802: PUSH
105803: LD_INT 0
105805: ST_TO_ADDR
// end ;
105806: LD_VAR 0 1
105810: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
105811: LD_INT 0
105813: PPUSH
105814: PPUSH
105815: PPUSH
// _x := ( x1 + x2 ) div 2 ;
105816: LD_ADDR_VAR 0 6
105820: PUSH
105821: LD_VAR 0 1
105825: PUSH
105826: LD_VAR 0 3
105830: PLUS
105831: PUSH
105832: LD_INT 2
105834: DIV
105835: ST_TO_ADDR
// if _x < 0 then
105836: LD_VAR 0 6
105840: PUSH
105841: LD_INT 0
105843: LESS
105844: IFFALSE 105861
// _x := _x * - 1 ;
105846: LD_ADDR_VAR 0 6
105850: PUSH
105851: LD_VAR 0 6
105855: PUSH
105856: LD_INT 1
105858: NEG
105859: MUL
105860: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
105861: LD_ADDR_VAR 0 7
105865: PUSH
105866: LD_VAR 0 2
105870: PUSH
105871: LD_VAR 0 4
105875: PLUS
105876: PUSH
105877: LD_INT 2
105879: DIV
105880: ST_TO_ADDR
// if _y < 0 then
105881: LD_VAR 0 7
105885: PUSH
105886: LD_INT 0
105888: LESS
105889: IFFALSE 105906
// _y := _y * - 1 ;
105891: LD_ADDR_VAR 0 7
105895: PUSH
105896: LD_VAR 0 7
105900: PUSH
105901: LD_INT 1
105903: NEG
105904: MUL
105905: ST_TO_ADDR
// result := [ _x , _y ] ;
105906: LD_ADDR_VAR 0 5
105910: PUSH
105911: LD_VAR 0 6
105915: PUSH
105916: LD_VAR 0 7
105920: PUSH
105921: EMPTY
105922: LIST
105923: LIST
105924: ST_TO_ADDR
// end ;
105925: LD_VAR 0 5
105929: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
105930: LD_INT 0
105932: PPUSH
105933: PPUSH
105934: PPUSH
105935: PPUSH
// task := GetTaskList ( unit ) ;
105936: LD_ADDR_VAR 0 7
105940: PUSH
105941: LD_VAR 0 1
105945: PPUSH
105946: CALL_OW 437
105950: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
105951: LD_VAR 0 7
105955: NOT
105956: PUSH
105957: LD_VAR 0 1
105961: PPUSH
105962: LD_VAR 0 2
105966: PPUSH
105967: CALL_OW 308
105971: NOT
105972: AND
105973: IFFALSE 105977
// exit ;
105975: GO 106095
// if IsInArea ( unit , area ) then
105977: LD_VAR 0 1
105981: PPUSH
105982: LD_VAR 0 2
105986: PPUSH
105987: CALL_OW 308
105991: IFFALSE 106009
// begin ComMoveToArea ( unit , goAway ) ;
105993: LD_VAR 0 1
105997: PPUSH
105998: LD_VAR 0 3
106002: PPUSH
106003: CALL_OW 113
// exit ;
106007: GO 106095
// end ; if task [ 1 ] [ 1 ] <> M then
106009: LD_VAR 0 7
106013: PUSH
106014: LD_INT 1
106016: ARRAY
106017: PUSH
106018: LD_INT 1
106020: ARRAY
106021: PUSH
106022: LD_STRING M
106024: NONEQUAL
106025: IFFALSE 106029
// exit ;
106027: GO 106095
// x := task [ 1 ] [ 2 ] ;
106029: LD_ADDR_VAR 0 5
106033: PUSH
106034: LD_VAR 0 7
106038: PUSH
106039: LD_INT 1
106041: ARRAY
106042: PUSH
106043: LD_INT 2
106045: ARRAY
106046: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
106047: LD_ADDR_VAR 0 6
106051: PUSH
106052: LD_VAR 0 7
106056: PUSH
106057: LD_INT 1
106059: ARRAY
106060: PUSH
106061: LD_INT 3
106063: ARRAY
106064: ST_TO_ADDR
// if InArea ( x , y , area ) then
106065: LD_VAR 0 5
106069: PPUSH
106070: LD_VAR 0 6
106074: PPUSH
106075: LD_VAR 0 2
106079: PPUSH
106080: CALL_OW 309
106084: IFFALSE 106095
// ComStop ( unit ) ;
106086: LD_VAR 0 1
106090: PPUSH
106091: CALL_OW 141
// end ;
106095: LD_VAR 0 4
106099: RET
// export function Abs ( value ) ; begin
106100: LD_INT 0
106102: PPUSH
// result := value ;
106103: LD_ADDR_VAR 0 2
106107: PUSH
106108: LD_VAR 0 1
106112: ST_TO_ADDR
// if value < 0 then
106113: LD_VAR 0 1
106117: PUSH
106118: LD_INT 0
106120: LESS
106121: IFFALSE 106138
// result := value * - 1 ;
106123: LD_ADDR_VAR 0 2
106127: PUSH
106128: LD_VAR 0 1
106132: PUSH
106133: LD_INT 1
106135: NEG
106136: MUL
106137: ST_TO_ADDR
// end ;
106138: LD_VAR 0 2
106142: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
106143: LD_INT 0
106145: PPUSH
106146: PPUSH
106147: PPUSH
106148: PPUSH
106149: PPUSH
106150: PPUSH
106151: PPUSH
106152: PPUSH
// if not unit or not building then
106153: LD_VAR 0 1
106157: NOT
106158: PUSH
106159: LD_VAR 0 2
106163: NOT
106164: OR
106165: IFFALSE 106169
// exit ;
106167: GO 106395
// x := GetX ( building ) ;
106169: LD_ADDR_VAR 0 4
106173: PUSH
106174: LD_VAR 0 2
106178: PPUSH
106179: CALL_OW 250
106183: ST_TO_ADDR
// y := GetY ( building ) ;
106184: LD_ADDR_VAR 0 6
106188: PUSH
106189: LD_VAR 0 2
106193: PPUSH
106194: CALL_OW 251
106198: ST_TO_ADDR
// d := GetDir ( building ) ;
106199: LD_ADDR_VAR 0 8
106203: PUSH
106204: LD_VAR 0 2
106208: PPUSH
106209: CALL_OW 254
106213: ST_TO_ADDR
// r := 4 ;
106214: LD_ADDR_VAR 0 9
106218: PUSH
106219: LD_INT 4
106221: ST_TO_ADDR
// for i := 1 to 5 do
106222: LD_ADDR_VAR 0 10
106226: PUSH
106227: DOUBLE
106228: LD_INT 1
106230: DEC
106231: ST_TO_ADDR
106232: LD_INT 5
106234: PUSH
106235: FOR_TO
106236: IFFALSE 106393
// begin _x := ShiftX ( x , d , r + i ) ;
106238: LD_ADDR_VAR 0 5
106242: PUSH
106243: LD_VAR 0 4
106247: PPUSH
106248: LD_VAR 0 8
106252: PPUSH
106253: LD_VAR 0 9
106257: PUSH
106258: LD_VAR 0 10
106262: PLUS
106263: PPUSH
106264: CALL_OW 272
106268: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
106269: LD_ADDR_VAR 0 7
106273: PUSH
106274: LD_VAR 0 6
106278: PPUSH
106279: LD_VAR 0 8
106283: PPUSH
106284: LD_VAR 0 9
106288: PUSH
106289: LD_VAR 0 10
106293: PLUS
106294: PPUSH
106295: CALL_OW 273
106299: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
106300: LD_VAR 0 5
106304: PPUSH
106305: LD_VAR 0 7
106309: PPUSH
106310: CALL_OW 488
106314: PUSH
106315: LD_VAR 0 5
106319: PPUSH
106320: LD_VAR 0 7
106324: PPUSH
106325: CALL_OW 428
106329: PPUSH
106330: CALL_OW 247
106334: PUSH
106335: LD_INT 3
106337: PUSH
106338: LD_INT 2
106340: PUSH
106341: EMPTY
106342: LIST
106343: LIST
106344: IN
106345: NOT
106346: AND
106347: IFFALSE 106391
// begin ComMoveXY ( unit , _x , _y ) ;
106349: LD_VAR 0 1
106353: PPUSH
106354: LD_VAR 0 5
106358: PPUSH
106359: LD_VAR 0 7
106363: PPUSH
106364: CALL_OW 111
// result := [ _x , _y ] ;
106368: LD_ADDR_VAR 0 3
106372: PUSH
106373: LD_VAR 0 5
106377: PUSH
106378: LD_VAR 0 7
106382: PUSH
106383: EMPTY
106384: LIST
106385: LIST
106386: ST_TO_ADDR
// exit ;
106387: POP
106388: POP
106389: GO 106395
// end ; end ;
106391: GO 106235
106393: POP
106394: POP
// end ;
106395: LD_VAR 0 3
106399: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
106400: LD_INT 0
106402: PPUSH
106403: PPUSH
106404: PPUSH
// result := 0 ;
106405: LD_ADDR_VAR 0 3
106409: PUSH
106410: LD_INT 0
106412: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
106413: LD_VAR 0 1
106417: PUSH
106418: LD_INT 0
106420: LESS
106421: PUSH
106422: LD_VAR 0 1
106426: PUSH
106427: LD_INT 8
106429: GREATER
106430: OR
106431: PUSH
106432: LD_VAR 0 2
106436: PUSH
106437: LD_INT 0
106439: LESS
106440: OR
106441: PUSH
106442: LD_VAR 0 2
106446: PUSH
106447: LD_INT 8
106449: GREATER
106450: OR
106451: IFFALSE 106455
// exit ;
106453: GO 106530
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
106455: LD_ADDR_VAR 0 4
106459: PUSH
106460: LD_INT 22
106462: PUSH
106463: LD_VAR 0 2
106467: PUSH
106468: EMPTY
106469: LIST
106470: LIST
106471: PPUSH
106472: CALL_OW 69
106476: PUSH
106477: FOR_IN
106478: IFFALSE 106528
// begin un := UnitShoot ( i ) ;
106480: LD_ADDR_VAR 0 5
106484: PUSH
106485: LD_VAR 0 4
106489: PPUSH
106490: CALL_OW 504
106494: ST_TO_ADDR
// if GetSide ( un ) = side1 then
106495: LD_VAR 0 5
106499: PPUSH
106500: CALL_OW 255
106504: PUSH
106505: LD_VAR 0 1
106509: EQUAL
106510: IFFALSE 106526
// begin result := un ;
106512: LD_ADDR_VAR 0 3
106516: PUSH
106517: LD_VAR 0 5
106521: ST_TO_ADDR
// exit ;
106522: POP
106523: POP
106524: GO 106530
// end ; end ;
106526: GO 106477
106528: POP
106529: POP
// end ;
106530: LD_VAR 0 3
106534: RET
// export function GetCargoBay ( units ) ; begin
106535: LD_INT 0
106537: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
106538: LD_ADDR_VAR 0 2
106542: PUSH
106543: LD_VAR 0 1
106547: PPUSH
106548: LD_INT 2
106550: PUSH
106551: LD_INT 34
106553: PUSH
106554: LD_INT 12
106556: PUSH
106557: EMPTY
106558: LIST
106559: LIST
106560: PUSH
106561: LD_INT 34
106563: PUSH
106564: LD_INT 51
106566: PUSH
106567: EMPTY
106568: LIST
106569: LIST
106570: PUSH
106571: LD_INT 34
106573: PUSH
106574: LD_INT 32
106576: PUSH
106577: EMPTY
106578: LIST
106579: LIST
106580: PUSH
106581: LD_INT 34
106583: PUSH
106584: LD_INT 89
106586: PUSH
106587: EMPTY
106588: LIST
106589: LIST
106590: PUSH
106591: EMPTY
106592: LIST
106593: LIST
106594: LIST
106595: LIST
106596: LIST
106597: PPUSH
106598: CALL_OW 72
106602: ST_TO_ADDR
// end ;
106603: LD_VAR 0 2
106607: RET
// export function Negate ( value ) ; begin
106608: LD_INT 0
106610: PPUSH
// result := not value ;
106611: LD_ADDR_VAR 0 2
106615: PUSH
106616: LD_VAR 0 1
106620: NOT
106621: ST_TO_ADDR
// end ;
106622: LD_VAR 0 2
106626: RET
// export function Inc ( value ) ; begin
106627: LD_INT 0
106629: PPUSH
// result := value + 1 ;
106630: LD_ADDR_VAR 0 2
106634: PUSH
106635: LD_VAR 0 1
106639: PUSH
106640: LD_INT 1
106642: PLUS
106643: ST_TO_ADDR
// end ;
106644: LD_VAR 0 2
106648: RET
// export function Dec ( value ) ; begin
106649: LD_INT 0
106651: PPUSH
// result := value - 1 ;
106652: LD_ADDR_VAR 0 2
106656: PUSH
106657: LD_VAR 0 1
106661: PUSH
106662: LD_INT 1
106664: MINUS
106665: ST_TO_ADDR
// end ;
106666: LD_VAR 0 2
106670: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
106671: LD_INT 0
106673: PPUSH
106674: PPUSH
106675: PPUSH
106676: PPUSH
106677: PPUSH
106678: PPUSH
106679: PPUSH
106680: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
106681: LD_VAR 0 1
106685: PPUSH
106686: LD_VAR 0 2
106690: PPUSH
106691: CALL_OW 488
106695: NOT
106696: PUSH
106697: LD_VAR 0 3
106701: PPUSH
106702: LD_VAR 0 4
106706: PPUSH
106707: CALL_OW 488
106711: NOT
106712: OR
106713: IFFALSE 106726
// begin result := - 1 ;
106715: LD_ADDR_VAR 0 5
106719: PUSH
106720: LD_INT 1
106722: NEG
106723: ST_TO_ADDR
// exit ;
106724: GO 106961
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
106726: LD_ADDR_VAR 0 12
106730: PUSH
106731: LD_VAR 0 1
106735: PPUSH
106736: LD_VAR 0 2
106740: PPUSH
106741: LD_VAR 0 3
106745: PPUSH
106746: LD_VAR 0 4
106750: PPUSH
106751: CALL 105811 0 4
106755: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
106756: LD_ADDR_VAR 0 11
106760: PUSH
106761: LD_VAR 0 1
106765: PPUSH
106766: LD_VAR 0 2
106770: PPUSH
106771: LD_VAR 0 12
106775: PUSH
106776: LD_INT 1
106778: ARRAY
106779: PPUSH
106780: LD_VAR 0 12
106784: PUSH
106785: LD_INT 2
106787: ARRAY
106788: PPUSH
106789: CALL_OW 298
106793: ST_TO_ADDR
// distance := 9999 ;
106794: LD_ADDR_VAR 0 10
106798: PUSH
106799: LD_INT 9999
106801: ST_TO_ADDR
// for i := 0 to 5 do
106802: LD_ADDR_VAR 0 6
106806: PUSH
106807: DOUBLE
106808: LD_INT 0
106810: DEC
106811: ST_TO_ADDR
106812: LD_INT 5
106814: PUSH
106815: FOR_TO
106816: IFFALSE 106959
// begin _x := ShiftX ( x1 , i , centerDist ) ;
106818: LD_ADDR_VAR 0 7
106822: PUSH
106823: LD_VAR 0 1
106827: PPUSH
106828: LD_VAR 0 6
106832: PPUSH
106833: LD_VAR 0 11
106837: PPUSH
106838: CALL_OW 272
106842: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
106843: LD_ADDR_VAR 0 8
106847: PUSH
106848: LD_VAR 0 2
106852: PPUSH
106853: LD_VAR 0 6
106857: PPUSH
106858: LD_VAR 0 11
106862: PPUSH
106863: CALL_OW 273
106867: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
106868: LD_VAR 0 7
106872: PPUSH
106873: LD_VAR 0 8
106877: PPUSH
106878: CALL_OW 488
106882: NOT
106883: IFFALSE 106887
// continue ;
106885: GO 106815
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
106887: LD_ADDR_VAR 0 9
106891: PUSH
106892: LD_VAR 0 12
106896: PUSH
106897: LD_INT 1
106899: ARRAY
106900: PPUSH
106901: LD_VAR 0 12
106905: PUSH
106906: LD_INT 2
106908: ARRAY
106909: PPUSH
106910: LD_VAR 0 7
106914: PPUSH
106915: LD_VAR 0 8
106919: PPUSH
106920: CALL_OW 298
106924: ST_TO_ADDR
// if tmp < distance then
106925: LD_VAR 0 9
106929: PUSH
106930: LD_VAR 0 10
106934: LESS
106935: IFFALSE 106957
// begin result := i ;
106937: LD_ADDR_VAR 0 5
106941: PUSH
106942: LD_VAR 0 6
106946: ST_TO_ADDR
// distance := tmp ;
106947: LD_ADDR_VAR 0 10
106951: PUSH
106952: LD_VAR 0 9
106956: ST_TO_ADDR
// end ; end ;
106957: GO 106815
106959: POP
106960: POP
// end ;
106961: LD_VAR 0 5
106965: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
106966: LD_INT 0
106968: PPUSH
106969: PPUSH
// if not driver or not IsInUnit ( driver ) then
106970: LD_VAR 0 1
106974: NOT
106975: PUSH
106976: LD_VAR 0 1
106980: PPUSH
106981: CALL_OW 310
106985: NOT
106986: OR
106987: IFFALSE 106991
// exit ;
106989: GO 107081
// vehicle := IsInUnit ( driver ) ;
106991: LD_ADDR_VAR 0 3
106995: PUSH
106996: LD_VAR 0 1
107000: PPUSH
107001: CALL_OW 310
107005: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
107006: LD_VAR 0 1
107010: PPUSH
107011: LD_STRING \
107013: PUSH
107014: LD_INT 0
107016: PUSH
107017: LD_INT 0
107019: PUSH
107020: LD_INT 0
107022: PUSH
107023: LD_INT 0
107025: PUSH
107026: LD_INT 0
107028: PUSH
107029: LD_INT 0
107031: PUSH
107032: EMPTY
107033: LIST
107034: LIST
107035: LIST
107036: LIST
107037: LIST
107038: LIST
107039: LIST
107040: PUSH
107041: LD_STRING E
107043: PUSH
107044: LD_INT 0
107046: PUSH
107047: LD_INT 0
107049: PUSH
107050: LD_VAR 0 3
107054: PUSH
107055: LD_INT 0
107057: PUSH
107058: LD_INT 0
107060: PUSH
107061: LD_INT 0
107063: PUSH
107064: EMPTY
107065: LIST
107066: LIST
107067: LIST
107068: LIST
107069: LIST
107070: LIST
107071: LIST
107072: PUSH
107073: EMPTY
107074: LIST
107075: LIST
107076: PPUSH
107077: CALL_OW 446
// end ;
107081: LD_VAR 0 2
107085: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
107086: LD_INT 0
107088: PPUSH
107089: PPUSH
// if not driver or not IsInUnit ( driver ) then
107090: LD_VAR 0 1
107094: NOT
107095: PUSH
107096: LD_VAR 0 1
107100: PPUSH
107101: CALL_OW 310
107105: NOT
107106: OR
107107: IFFALSE 107111
// exit ;
107109: GO 107201
// vehicle := IsInUnit ( driver ) ;
107111: LD_ADDR_VAR 0 3
107115: PUSH
107116: LD_VAR 0 1
107120: PPUSH
107121: CALL_OW 310
107125: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
107126: LD_VAR 0 1
107130: PPUSH
107131: LD_STRING \
107133: PUSH
107134: LD_INT 0
107136: PUSH
107137: LD_INT 0
107139: PUSH
107140: LD_INT 0
107142: PUSH
107143: LD_INT 0
107145: PUSH
107146: LD_INT 0
107148: PUSH
107149: LD_INT 0
107151: PUSH
107152: EMPTY
107153: LIST
107154: LIST
107155: LIST
107156: LIST
107157: LIST
107158: LIST
107159: LIST
107160: PUSH
107161: LD_STRING E
107163: PUSH
107164: LD_INT 0
107166: PUSH
107167: LD_INT 0
107169: PUSH
107170: LD_VAR 0 3
107174: PUSH
107175: LD_INT 0
107177: PUSH
107178: LD_INT 0
107180: PUSH
107181: LD_INT 0
107183: PUSH
107184: EMPTY
107185: LIST
107186: LIST
107187: LIST
107188: LIST
107189: LIST
107190: LIST
107191: LIST
107192: PUSH
107193: EMPTY
107194: LIST
107195: LIST
107196: PPUSH
107197: CALL_OW 447
// end ;
107201: LD_VAR 0 2
107205: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
107206: LD_INT 0
107208: PPUSH
107209: PPUSH
107210: PPUSH
// tmp := [ ] ;
107211: LD_ADDR_VAR 0 5
107215: PUSH
107216: EMPTY
107217: ST_TO_ADDR
// for i in units do
107218: LD_ADDR_VAR 0 4
107222: PUSH
107223: LD_VAR 0 1
107227: PUSH
107228: FOR_IN
107229: IFFALSE 107267
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
107231: LD_ADDR_VAR 0 5
107235: PUSH
107236: LD_VAR 0 5
107240: PPUSH
107241: LD_VAR 0 5
107245: PUSH
107246: LD_INT 1
107248: PLUS
107249: PPUSH
107250: LD_VAR 0 4
107254: PPUSH
107255: CALL_OW 256
107259: PPUSH
107260: CALL_OW 2
107264: ST_TO_ADDR
107265: GO 107228
107267: POP
107268: POP
// if not tmp then
107269: LD_VAR 0 5
107273: NOT
107274: IFFALSE 107278
// exit ;
107276: GO 107326
// if asc then
107278: LD_VAR 0 2
107282: IFFALSE 107306
// result := SortListByListAsc ( units , tmp ) else
107284: LD_ADDR_VAR 0 3
107288: PUSH
107289: LD_VAR 0 1
107293: PPUSH
107294: LD_VAR 0 5
107298: PPUSH
107299: CALL_OW 76
107303: ST_TO_ADDR
107304: GO 107326
// result := SortListByListDesc ( units , tmp ) ;
107306: LD_ADDR_VAR 0 3
107310: PUSH
107311: LD_VAR 0 1
107315: PPUSH
107316: LD_VAR 0 5
107320: PPUSH
107321: CALL_OW 77
107325: ST_TO_ADDR
// end ;
107326: LD_VAR 0 3
107330: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
107331: LD_INT 0
107333: PPUSH
107334: PPUSH
// task := GetTaskList ( mech ) ;
107335: LD_ADDR_VAR 0 4
107339: PUSH
107340: LD_VAR 0 1
107344: PPUSH
107345: CALL_OW 437
107349: ST_TO_ADDR
// if not task then
107350: LD_VAR 0 4
107354: NOT
107355: IFFALSE 107359
// exit ;
107357: GO 107401
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
107359: LD_ADDR_VAR 0 3
107363: PUSH
107364: LD_VAR 0 4
107368: PUSH
107369: LD_INT 1
107371: ARRAY
107372: PUSH
107373: LD_INT 1
107375: ARRAY
107376: PUSH
107377: LD_STRING r
107379: EQUAL
107380: PUSH
107381: LD_VAR 0 4
107385: PUSH
107386: LD_INT 1
107388: ARRAY
107389: PUSH
107390: LD_INT 4
107392: ARRAY
107393: PUSH
107394: LD_VAR 0 2
107398: EQUAL
107399: AND
107400: ST_TO_ADDR
// end ;
107401: LD_VAR 0 3
107405: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
107406: LD_INT 0
107408: PPUSH
// SetDir ( unit , d ) ;
107409: LD_VAR 0 1
107413: PPUSH
107414: LD_VAR 0 4
107418: PPUSH
107419: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
107423: LD_VAR 0 1
107427: PPUSH
107428: LD_VAR 0 2
107432: PPUSH
107433: LD_VAR 0 3
107437: PPUSH
107438: LD_VAR 0 5
107442: PPUSH
107443: CALL_OW 48
// end ;
107447: LD_VAR 0 6
107451: RET
// export function ToNaturalNumber ( number ) ; begin
107452: LD_INT 0
107454: PPUSH
// result := number div 1 ;
107455: LD_ADDR_VAR 0 2
107459: PUSH
107460: LD_VAR 0 1
107464: PUSH
107465: LD_INT 1
107467: DIV
107468: ST_TO_ADDR
// if number < 0 then
107469: LD_VAR 0 1
107473: PUSH
107474: LD_INT 0
107476: LESS
107477: IFFALSE 107487
// result := 0 ;
107479: LD_ADDR_VAR 0 2
107483: PUSH
107484: LD_INT 0
107486: ST_TO_ADDR
// end ;
107487: LD_VAR 0 2
107491: RET
// export function SortByClass ( units , class ) ; var un ; begin
107492: LD_INT 0
107494: PPUSH
107495: PPUSH
// if not units or not class then
107496: LD_VAR 0 1
107500: NOT
107501: PUSH
107502: LD_VAR 0 2
107506: NOT
107507: OR
107508: IFFALSE 107512
// exit ;
107510: GO 107607
// result := [ ] ;
107512: LD_ADDR_VAR 0 3
107516: PUSH
107517: EMPTY
107518: ST_TO_ADDR
// for un in units do
107519: LD_ADDR_VAR 0 4
107523: PUSH
107524: LD_VAR 0 1
107528: PUSH
107529: FOR_IN
107530: IFFALSE 107605
// if GetClass ( un ) = class then
107532: LD_VAR 0 4
107536: PPUSH
107537: CALL_OW 257
107541: PUSH
107542: LD_VAR 0 2
107546: EQUAL
107547: IFFALSE 107574
// result := Insert ( result , 1 , un ) else
107549: LD_ADDR_VAR 0 3
107553: PUSH
107554: LD_VAR 0 3
107558: PPUSH
107559: LD_INT 1
107561: PPUSH
107562: LD_VAR 0 4
107566: PPUSH
107567: CALL_OW 2
107571: ST_TO_ADDR
107572: GO 107603
// result := Replace ( result , result + 1 , un ) ;
107574: LD_ADDR_VAR 0 3
107578: PUSH
107579: LD_VAR 0 3
107583: PPUSH
107584: LD_VAR 0 3
107588: PUSH
107589: LD_INT 1
107591: PLUS
107592: PPUSH
107593: LD_VAR 0 4
107597: PPUSH
107598: CALL_OW 1
107602: ST_TO_ADDR
107603: GO 107529
107605: POP
107606: POP
// end ;
107607: LD_VAR 0 3
107611: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
107612: LD_INT 0
107614: PPUSH
107615: PPUSH
107616: PPUSH
107617: PPUSH
107618: PPUSH
107619: PPUSH
107620: PPUSH
// result := [ ] ;
107621: LD_ADDR_VAR 0 4
107625: PUSH
107626: EMPTY
107627: ST_TO_ADDR
// if x - r < 0 then
107628: LD_VAR 0 1
107632: PUSH
107633: LD_VAR 0 3
107637: MINUS
107638: PUSH
107639: LD_INT 0
107641: LESS
107642: IFFALSE 107654
// min_x := 0 else
107644: LD_ADDR_VAR 0 8
107648: PUSH
107649: LD_INT 0
107651: ST_TO_ADDR
107652: GO 107670
// min_x := x - r ;
107654: LD_ADDR_VAR 0 8
107658: PUSH
107659: LD_VAR 0 1
107663: PUSH
107664: LD_VAR 0 3
107668: MINUS
107669: ST_TO_ADDR
// if y - r < 0 then
107670: LD_VAR 0 2
107674: PUSH
107675: LD_VAR 0 3
107679: MINUS
107680: PUSH
107681: LD_INT 0
107683: LESS
107684: IFFALSE 107696
// min_y := 0 else
107686: LD_ADDR_VAR 0 7
107690: PUSH
107691: LD_INT 0
107693: ST_TO_ADDR
107694: GO 107712
// min_y := y - r ;
107696: LD_ADDR_VAR 0 7
107700: PUSH
107701: LD_VAR 0 2
107705: PUSH
107706: LD_VAR 0 3
107710: MINUS
107711: ST_TO_ADDR
// max_x := x + r ;
107712: LD_ADDR_VAR 0 9
107716: PUSH
107717: LD_VAR 0 1
107721: PUSH
107722: LD_VAR 0 3
107726: PLUS
107727: ST_TO_ADDR
// max_y := y + r ;
107728: LD_ADDR_VAR 0 10
107732: PUSH
107733: LD_VAR 0 2
107737: PUSH
107738: LD_VAR 0 3
107742: PLUS
107743: ST_TO_ADDR
// for _x = min_x to max_x do
107744: LD_ADDR_VAR 0 5
107748: PUSH
107749: DOUBLE
107750: LD_VAR 0 8
107754: DEC
107755: ST_TO_ADDR
107756: LD_VAR 0 9
107760: PUSH
107761: FOR_TO
107762: IFFALSE 107863
// for _y = min_y to max_y do
107764: LD_ADDR_VAR 0 6
107768: PUSH
107769: DOUBLE
107770: LD_VAR 0 7
107774: DEC
107775: ST_TO_ADDR
107776: LD_VAR 0 10
107780: PUSH
107781: FOR_TO
107782: IFFALSE 107859
// begin if not ValidHex ( _x , _y ) then
107784: LD_VAR 0 5
107788: PPUSH
107789: LD_VAR 0 6
107793: PPUSH
107794: CALL_OW 488
107798: NOT
107799: IFFALSE 107803
// continue ;
107801: GO 107781
// if GetResourceTypeXY ( _x , _y ) then
107803: LD_VAR 0 5
107807: PPUSH
107808: LD_VAR 0 6
107812: PPUSH
107813: CALL_OW 283
107817: IFFALSE 107857
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
107819: LD_ADDR_VAR 0 4
107823: PUSH
107824: LD_VAR 0 4
107828: PPUSH
107829: LD_VAR 0 4
107833: PUSH
107834: LD_INT 1
107836: PLUS
107837: PPUSH
107838: LD_VAR 0 5
107842: PUSH
107843: LD_VAR 0 6
107847: PUSH
107848: EMPTY
107849: LIST
107850: LIST
107851: PPUSH
107852: CALL_OW 1
107856: ST_TO_ADDR
// end ;
107857: GO 107781
107859: POP
107860: POP
107861: GO 107761
107863: POP
107864: POP
// end ;
107865: LD_VAR 0 4
107869: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
107870: LD_INT 0
107872: PPUSH
107873: PPUSH
107874: PPUSH
107875: PPUSH
107876: PPUSH
107877: PPUSH
107878: PPUSH
107879: PPUSH
// if not units then
107880: LD_VAR 0 1
107884: NOT
107885: IFFALSE 107889
// exit ;
107887: GO 108413
// result := UnitFilter ( units , [ f_ok ] ) ;
107889: LD_ADDR_VAR 0 3
107893: PUSH
107894: LD_VAR 0 1
107898: PPUSH
107899: LD_INT 50
107901: PUSH
107902: EMPTY
107903: LIST
107904: PPUSH
107905: CALL_OW 72
107909: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
107910: LD_ADDR_VAR 0 8
107914: PUSH
107915: LD_VAR 0 1
107919: PUSH
107920: LD_INT 1
107922: ARRAY
107923: PPUSH
107924: CALL_OW 255
107928: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
107929: LD_ADDR_VAR 0 10
107933: PUSH
107934: LD_INT 29
107936: PUSH
107937: LD_INT 91
107939: PUSH
107940: LD_INT 49
107942: PUSH
107943: EMPTY
107944: LIST
107945: LIST
107946: LIST
107947: ST_TO_ADDR
// if not result then
107948: LD_VAR 0 3
107952: NOT
107953: IFFALSE 107957
// exit ;
107955: GO 108413
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
107957: LD_ADDR_VAR 0 5
107961: PUSH
107962: LD_INT 81
107964: PUSH
107965: LD_VAR 0 8
107969: PUSH
107970: EMPTY
107971: LIST
107972: LIST
107973: PPUSH
107974: CALL_OW 69
107978: ST_TO_ADDR
// for i in result do
107979: LD_ADDR_VAR 0 4
107983: PUSH
107984: LD_VAR 0 3
107988: PUSH
107989: FOR_IN
107990: IFFALSE 108411
// begin tag := GetTag ( i ) + 1 ;
107992: LD_ADDR_VAR 0 9
107996: PUSH
107997: LD_VAR 0 4
108001: PPUSH
108002: CALL_OW 110
108006: PUSH
108007: LD_INT 1
108009: PLUS
108010: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
108011: LD_ADDR_VAR 0 7
108015: PUSH
108016: LD_VAR 0 4
108020: PPUSH
108021: CALL_OW 250
108025: PPUSH
108026: LD_VAR 0 4
108030: PPUSH
108031: CALL_OW 251
108035: PPUSH
108036: LD_INT 6
108038: PPUSH
108039: CALL 107612 0 3
108043: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
108044: LD_VAR 0 4
108048: PPUSH
108049: CALL_OW 247
108053: PUSH
108054: LD_INT 2
108056: EQUAL
108057: PUSH
108058: LD_VAR 0 7
108062: AND
108063: PUSH
108064: LD_VAR 0 4
108068: PPUSH
108069: CALL_OW 264
108073: PUSH
108074: LD_VAR 0 10
108078: IN
108079: NOT
108080: AND
108081: IFFALSE 108120
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
108083: LD_VAR 0 4
108087: PPUSH
108088: LD_VAR 0 7
108092: PUSH
108093: LD_INT 1
108095: ARRAY
108096: PUSH
108097: LD_INT 1
108099: ARRAY
108100: PPUSH
108101: LD_VAR 0 7
108105: PUSH
108106: LD_INT 1
108108: ARRAY
108109: PUSH
108110: LD_INT 2
108112: ARRAY
108113: PPUSH
108114: CALL_OW 116
108118: GO 108409
// if path > tag then
108120: LD_VAR 0 2
108124: PUSH
108125: LD_VAR 0 9
108129: GREATER
108130: IFFALSE 108338
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
108132: LD_ADDR_VAR 0 6
108136: PUSH
108137: LD_VAR 0 5
108141: PPUSH
108142: LD_INT 91
108144: PUSH
108145: LD_VAR 0 4
108149: PUSH
108150: LD_INT 8
108152: PUSH
108153: EMPTY
108154: LIST
108155: LIST
108156: LIST
108157: PPUSH
108158: CALL_OW 72
108162: ST_TO_ADDR
// if nearEnemy then
108163: LD_VAR 0 6
108167: IFFALSE 108236
// begin if GetWeapon ( i ) = ru_time_lapser then
108169: LD_VAR 0 4
108173: PPUSH
108174: CALL_OW 264
108178: PUSH
108179: LD_INT 49
108181: EQUAL
108182: IFFALSE 108210
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
108184: LD_VAR 0 4
108188: PPUSH
108189: LD_VAR 0 6
108193: PPUSH
108194: LD_VAR 0 4
108198: PPUSH
108199: CALL_OW 74
108203: PPUSH
108204: CALL_OW 112
108208: GO 108234
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
108210: LD_VAR 0 4
108214: PPUSH
108215: LD_VAR 0 6
108219: PPUSH
108220: LD_VAR 0 4
108224: PPUSH
108225: CALL_OW 74
108229: PPUSH
108230: CALL_OW 115
// end else
108234: GO 108336
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
108236: LD_VAR 0 4
108240: PPUSH
108241: LD_VAR 0 2
108245: PUSH
108246: LD_VAR 0 9
108250: ARRAY
108251: PUSH
108252: LD_INT 1
108254: ARRAY
108255: PPUSH
108256: LD_VAR 0 2
108260: PUSH
108261: LD_VAR 0 9
108265: ARRAY
108266: PUSH
108267: LD_INT 2
108269: ARRAY
108270: PPUSH
108271: CALL_OW 297
108275: PUSH
108276: LD_INT 6
108278: GREATER
108279: IFFALSE 108322
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
108281: LD_VAR 0 4
108285: PPUSH
108286: LD_VAR 0 2
108290: PUSH
108291: LD_VAR 0 9
108295: ARRAY
108296: PUSH
108297: LD_INT 1
108299: ARRAY
108300: PPUSH
108301: LD_VAR 0 2
108305: PUSH
108306: LD_VAR 0 9
108310: ARRAY
108311: PUSH
108312: LD_INT 2
108314: ARRAY
108315: PPUSH
108316: CALL_OW 114
108320: GO 108336
// SetTag ( i , tag ) ;
108322: LD_VAR 0 4
108326: PPUSH
108327: LD_VAR 0 9
108331: PPUSH
108332: CALL_OW 109
// end else
108336: GO 108409
// if enemy then
108338: LD_VAR 0 5
108342: IFFALSE 108409
// begin if GetWeapon ( i ) = ru_time_lapser then
108344: LD_VAR 0 4
108348: PPUSH
108349: CALL_OW 264
108353: PUSH
108354: LD_INT 49
108356: EQUAL
108357: IFFALSE 108385
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
108359: LD_VAR 0 4
108363: PPUSH
108364: LD_VAR 0 5
108368: PPUSH
108369: LD_VAR 0 4
108373: PPUSH
108374: CALL_OW 74
108378: PPUSH
108379: CALL_OW 112
108383: GO 108409
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
108385: LD_VAR 0 4
108389: PPUSH
108390: LD_VAR 0 5
108394: PPUSH
108395: LD_VAR 0 4
108399: PPUSH
108400: CALL_OW 74
108404: PPUSH
108405: CALL_OW 115
// end ; end ;
108409: GO 107989
108411: POP
108412: POP
// end ;
108413: LD_VAR 0 3
108417: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
108418: LD_INT 0
108420: PPUSH
108421: PPUSH
108422: PPUSH
// if not unit or IsInUnit ( unit ) then
108423: LD_VAR 0 1
108427: NOT
108428: PUSH
108429: LD_VAR 0 1
108433: PPUSH
108434: CALL_OW 310
108438: OR
108439: IFFALSE 108443
// exit ;
108441: GO 108534
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
108443: LD_ADDR_VAR 0 4
108447: PUSH
108448: LD_VAR 0 1
108452: PPUSH
108453: CALL_OW 250
108457: PPUSH
108458: LD_VAR 0 2
108462: PPUSH
108463: LD_INT 1
108465: PPUSH
108466: CALL_OW 272
108470: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
108471: LD_ADDR_VAR 0 5
108475: PUSH
108476: LD_VAR 0 1
108480: PPUSH
108481: CALL_OW 251
108485: PPUSH
108486: LD_VAR 0 2
108490: PPUSH
108491: LD_INT 1
108493: PPUSH
108494: CALL_OW 273
108498: ST_TO_ADDR
// if ValidHex ( x , y ) then
108499: LD_VAR 0 4
108503: PPUSH
108504: LD_VAR 0 5
108508: PPUSH
108509: CALL_OW 488
108513: IFFALSE 108534
// ComTurnXY ( unit , x , y ) ;
108515: LD_VAR 0 1
108519: PPUSH
108520: LD_VAR 0 4
108524: PPUSH
108525: LD_VAR 0 5
108529: PPUSH
108530: CALL_OW 118
// end ;
108534: LD_VAR 0 3
108538: RET
// export function SeeUnits ( side , units ) ; var i ; begin
108539: LD_INT 0
108541: PPUSH
108542: PPUSH
// result := false ;
108543: LD_ADDR_VAR 0 3
108547: PUSH
108548: LD_INT 0
108550: ST_TO_ADDR
// if not units then
108551: LD_VAR 0 2
108555: NOT
108556: IFFALSE 108560
// exit ;
108558: GO 108605
// for i in units do
108560: LD_ADDR_VAR 0 4
108564: PUSH
108565: LD_VAR 0 2
108569: PUSH
108570: FOR_IN
108571: IFFALSE 108603
// if See ( side , i ) then
108573: LD_VAR 0 1
108577: PPUSH
108578: LD_VAR 0 4
108582: PPUSH
108583: CALL_OW 292
108587: IFFALSE 108601
// begin result := true ;
108589: LD_ADDR_VAR 0 3
108593: PUSH
108594: LD_INT 1
108596: ST_TO_ADDR
// exit ;
108597: POP
108598: POP
108599: GO 108605
// end ;
108601: GO 108570
108603: POP
108604: POP
// end ;
108605: LD_VAR 0 3
108609: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
108610: LD_INT 0
108612: PPUSH
108613: PPUSH
108614: PPUSH
108615: PPUSH
// if not unit or not points then
108616: LD_VAR 0 1
108620: NOT
108621: PUSH
108622: LD_VAR 0 2
108626: NOT
108627: OR
108628: IFFALSE 108632
// exit ;
108630: GO 108722
// dist := 99999 ;
108632: LD_ADDR_VAR 0 5
108636: PUSH
108637: LD_INT 99999
108639: ST_TO_ADDR
// for i in points do
108640: LD_ADDR_VAR 0 4
108644: PUSH
108645: LD_VAR 0 2
108649: PUSH
108650: FOR_IN
108651: IFFALSE 108720
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
108653: LD_ADDR_VAR 0 6
108657: PUSH
108658: LD_VAR 0 1
108662: PPUSH
108663: LD_VAR 0 4
108667: PUSH
108668: LD_INT 1
108670: ARRAY
108671: PPUSH
108672: LD_VAR 0 4
108676: PUSH
108677: LD_INT 2
108679: ARRAY
108680: PPUSH
108681: CALL_OW 297
108685: ST_TO_ADDR
// if tmpDist < dist then
108686: LD_VAR 0 6
108690: PUSH
108691: LD_VAR 0 5
108695: LESS
108696: IFFALSE 108718
// begin result := i ;
108698: LD_ADDR_VAR 0 3
108702: PUSH
108703: LD_VAR 0 4
108707: ST_TO_ADDR
// dist := tmpDist ;
108708: LD_ADDR_VAR 0 5
108712: PUSH
108713: LD_VAR 0 6
108717: ST_TO_ADDR
// end ; end ;
108718: GO 108650
108720: POP
108721: POP
// end ;
108722: LD_VAR 0 3
108726: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
108727: LD_INT 0
108729: PPUSH
// uc_side := side ;
108730: LD_ADDR_OWVAR 20
108734: PUSH
108735: LD_VAR 0 1
108739: ST_TO_ADDR
// uc_nation := 3 ;
108740: LD_ADDR_OWVAR 21
108744: PUSH
108745: LD_INT 3
108747: ST_TO_ADDR
// vc_chassis := 25 ;
108748: LD_ADDR_OWVAR 37
108752: PUSH
108753: LD_INT 25
108755: ST_TO_ADDR
// vc_engine := engine_siberite ;
108756: LD_ADDR_OWVAR 39
108760: PUSH
108761: LD_INT 3
108763: ST_TO_ADDR
// vc_control := control_computer ;
108764: LD_ADDR_OWVAR 38
108768: PUSH
108769: LD_INT 3
108771: ST_TO_ADDR
// vc_weapon := 59 ;
108772: LD_ADDR_OWVAR 40
108776: PUSH
108777: LD_INT 59
108779: ST_TO_ADDR
// result := CreateVehicle ;
108780: LD_ADDR_VAR 0 5
108784: PUSH
108785: CALL_OW 45
108789: ST_TO_ADDR
// SetDir ( result , d ) ;
108790: LD_VAR 0 5
108794: PPUSH
108795: LD_VAR 0 4
108799: PPUSH
108800: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
108804: LD_VAR 0 5
108808: PPUSH
108809: LD_VAR 0 2
108813: PPUSH
108814: LD_VAR 0 3
108818: PPUSH
108819: LD_INT 0
108821: PPUSH
108822: CALL_OW 48
// end ;
108826: LD_VAR 0 5
108830: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
108831: LD_INT 0
108833: PPUSH
108834: PPUSH
108835: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
108836: LD_ADDR_VAR 0 2
108840: PUSH
108841: LD_INT 0
108843: PUSH
108844: LD_INT 0
108846: PUSH
108847: LD_INT 0
108849: PUSH
108850: LD_INT 0
108852: PUSH
108853: EMPTY
108854: LIST
108855: LIST
108856: LIST
108857: LIST
108858: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
108859: LD_VAR 0 1
108863: NOT
108864: PUSH
108865: LD_VAR 0 1
108869: PPUSH
108870: CALL_OW 264
108874: PUSH
108875: LD_INT 12
108877: PUSH
108878: LD_INT 51
108880: PUSH
108881: LD_INT 32
108883: PUSH
108884: LD_INT 89
108886: PUSH
108887: EMPTY
108888: LIST
108889: LIST
108890: LIST
108891: LIST
108892: IN
108893: NOT
108894: OR
108895: IFFALSE 108899
// exit ;
108897: GO 108997
// for i := 1 to 3 do
108899: LD_ADDR_VAR 0 3
108903: PUSH
108904: DOUBLE
108905: LD_INT 1
108907: DEC
108908: ST_TO_ADDR
108909: LD_INT 3
108911: PUSH
108912: FOR_TO
108913: IFFALSE 108995
// begin tmp := GetCargo ( cargo , i ) ;
108915: LD_ADDR_VAR 0 4
108919: PUSH
108920: LD_VAR 0 1
108924: PPUSH
108925: LD_VAR 0 3
108929: PPUSH
108930: CALL_OW 289
108934: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
108935: LD_ADDR_VAR 0 2
108939: PUSH
108940: LD_VAR 0 2
108944: PPUSH
108945: LD_VAR 0 3
108949: PPUSH
108950: LD_VAR 0 4
108954: PPUSH
108955: CALL_OW 1
108959: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
108960: LD_ADDR_VAR 0 2
108964: PUSH
108965: LD_VAR 0 2
108969: PPUSH
108970: LD_INT 4
108972: PPUSH
108973: LD_VAR 0 2
108977: PUSH
108978: LD_INT 4
108980: ARRAY
108981: PUSH
108982: LD_VAR 0 4
108986: PLUS
108987: PPUSH
108988: CALL_OW 1
108992: ST_TO_ADDR
// end ;
108993: GO 108912
108995: POP
108996: POP
// end ;
108997: LD_VAR 0 2
109001: RET
// export function Length ( array ) ; begin
109002: LD_INT 0
109004: PPUSH
// result := array + 0 ;
109005: LD_ADDR_VAR 0 2
109009: PUSH
109010: LD_VAR 0 1
109014: PUSH
109015: LD_INT 0
109017: PLUS
109018: ST_TO_ADDR
// end ;
109019: LD_VAR 0 2
109023: RET
// export function PrepareArray ( array ) ; begin
109024: LD_INT 0
109026: PPUSH
// result := array diff 0 ;
109027: LD_ADDR_VAR 0 2
109031: PUSH
109032: LD_VAR 0 1
109036: PUSH
109037: LD_INT 0
109039: DIFF
109040: ST_TO_ADDR
// if not result [ 1 ] then
109041: LD_VAR 0 2
109045: PUSH
109046: LD_INT 1
109048: ARRAY
109049: NOT
109050: IFFALSE 109070
// result := Delete ( result , 1 ) ;
109052: LD_ADDR_VAR 0 2
109056: PUSH
109057: LD_VAR 0 2
109061: PPUSH
109062: LD_INT 1
109064: PPUSH
109065: CALL_OW 3
109069: ST_TO_ADDR
// end ;
109070: LD_VAR 0 2
109074: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
109075: LD_INT 0
109077: PPUSH
109078: PPUSH
109079: PPUSH
109080: PPUSH
// sibRocketRange := 25 ;
109081: LD_ADDR_VAR 0 6
109085: PUSH
109086: LD_INT 25
109088: ST_TO_ADDR
// result := false ;
109089: LD_ADDR_VAR 0 4
109093: PUSH
109094: LD_INT 0
109096: ST_TO_ADDR
// for i := 0 to 5 do
109097: LD_ADDR_VAR 0 5
109101: PUSH
109102: DOUBLE
109103: LD_INT 0
109105: DEC
109106: ST_TO_ADDR
109107: LD_INT 5
109109: PUSH
109110: FOR_TO
109111: IFFALSE 109178
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
109113: LD_VAR 0 1
109117: PPUSH
109118: LD_VAR 0 5
109122: PPUSH
109123: LD_VAR 0 6
109127: PPUSH
109128: CALL_OW 272
109132: PPUSH
109133: LD_VAR 0 2
109137: PPUSH
109138: LD_VAR 0 5
109142: PPUSH
109143: LD_VAR 0 6
109147: PPUSH
109148: CALL_OW 273
109152: PPUSH
109153: LD_VAR 0 3
109157: PPUSH
109158: CALL_OW 309
109162: IFFALSE 109176
// begin result := true ;
109164: LD_ADDR_VAR 0 4
109168: PUSH
109169: LD_INT 1
109171: ST_TO_ADDR
// exit ;
109172: POP
109173: POP
109174: GO 109180
// end ;
109176: GO 109110
109178: POP
109179: POP
// end ;
109180: LD_VAR 0 4
109184: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
109185: LD_INT 0
109187: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
109188: LD_VAR 0 1
109192: PPUSH
109193: LD_VAR 0 2
109197: PPUSH
109198: LD_INT 0
109200: PPUSH
109201: LD_INT 0
109203: PPUSH
109204: LD_INT 1
109206: PPUSH
109207: LD_INT 0
109209: PPUSH
109210: CALL_OW 587
// end ;
109214: LD_VAR 0 3
109218: RET
// export function CenterOnNow ( unit ) ; begin
109219: LD_INT 0
109221: PPUSH
// result := IsInUnit ( unit ) ;
109222: LD_ADDR_VAR 0 2
109226: PUSH
109227: LD_VAR 0 1
109231: PPUSH
109232: CALL_OW 310
109236: ST_TO_ADDR
// if not result then
109237: LD_VAR 0 2
109241: NOT
109242: IFFALSE 109254
// result := unit ;
109244: LD_ADDR_VAR 0 2
109248: PUSH
109249: LD_VAR 0 1
109253: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
109254: LD_VAR 0 1
109258: PPUSH
109259: CALL_OW 87
// end ;
109263: LD_VAR 0 2
109267: RET
// export function ComMoveHex ( unit , hex ) ; begin
109268: LD_INT 0
109270: PPUSH
// if not hex then
109271: LD_VAR 0 2
109275: NOT
109276: IFFALSE 109280
// exit ;
109278: GO 109333
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
109280: LD_VAR 0 2
109284: PUSH
109285: LD_INT 1
109287: ARRAY
109288: PPUSH
109289: LD_VAR 0 2
109293: PUSH
109294: LD_INT 2
109296: ARRAY
109297: PPUSH
109298: CALL_OW 428
109302: IFFALSE 109306
// exit ;
109304: GO 109333
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
109306: LD_VAR 0 1
109310: PPUSH
109311: LD_VAR 0 2
109315: PUSH
109316: LD_INT 1
109318: ARRAY
109319: PPUSH
109320: LD_VAR 0 2
109324: PUSH
109325: LD_INT 2
109327: ARRAY
109328: PPUSH
109329: CALL_OW 111
// end ; end_of_file end_of_file
109333: LD_VAR 0 3
109337: RET
// export globalGameSaveCounter ; every 0 0$1 do
109338: GO 109340
109340: DISABLE
// begin enable ;
109341: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
109342: LD_STRING updateTimer(
109344: PUSH
109345: LD_OWVAR 1
109349: STR
109350: PUSH
109351: LD_STRING );
109353: STR
109354: PPUSH
109355: CALL_OW 559
// end ;
109359: END
// every 0 0$1 do
109360: GO 109362
109362: DISABLE
// begin globalGameSaveCounter := 0 ;
109363: LD_ADDR_EXP 145
109367: PUSH
109368: LD_INT 0
109370: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
109371: LD_STRING setGameSaveCounter(0)
109373: PPUSH
109374: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
109378: LD_STRING initStreamRollete();
109380: PPUSH
109381: CALL_OW 559
// InitStreamMode ;
109385: CALL 110711 0 0
// DefineStreamItems ( false ) ;
109389: LD_INT 0
109391: PPUSH
109392: CALL 111175 0 1
// end ;
109396: END
// export function SOS_MapStart ( ) ; begin
109397: LD_INT 0
109399: PPUSH
// if streamModeActive then
109400: LD_EXP 146
109404: IFFALSE 109413
// DefineStreamItems ( true ) ;
109406: LD_INT 1
109408: PPUSH
109409: CALL 111175 0 1
// UpdateLuaVariables ( ) ;
109413: CALL 109430 0 0
// UpdateFactoryWaypoints ( ) ;
109417: CALL 124036 0 0
// UpdateWarehouseGatheringPoints ( ) ;
109421: CALL 124293 0 0
// end ;
109425: LD_VAR 0 1
109429: RET
// function UpdateLuaVariables ( ) ; begin
109430: LD_INT 0
109432: PPUSH
// if globalGameSaveCounter then
109433: LD_EXP 145
109437: IFFALSE 109471
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
109439: LD_ADDR_EXP 145
109443: PUSH
109444: LD_EXP 145
109448: PPUSH
109449: CALL 106627 0 1
109453: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
109454: LD_STRING setGameSaveCounter(
109456: PUSH
109457: LD_EXP 145
109461: STR
109462: PUSH
109463: LD_STRING )
109465: STR
109466: PPUSH
109467: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
109471: LD_STRING setGameDifficulty(
109473: PUSH
109474: LD_OWVAR 67
109478: STR
109479: PUSH
109480: LD_STRING )
109482: STR
109483: PPUSH
109484: CALL_OW 559
// end ;
109488: LD_VAR 0 1
109492: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
109493: LD_INT 0
109495: PPUSH
// if p2 = stream_mode then
109496: LD_VAR 0 2
109500: PUSH
109501: LD_INT 100
109503: EQUAL
109504: IFFALSE 110507
// begin if not StreamModeActive then
109506: LD_EXP 146
109510: NOT
109511: IFFALSE 109521
// StreamModeActive := true ;
109513: LD_ADDR_EXP 146
109517: PUSH
109518: LD_INT 1
109520: ST_TO_ADDR
// if p3 = 0 then
109521: LD_VAR 0 3
109525: PUSH
109526: LD_INT 0
109528: EQUAL
109529: IFFALSE 109535
// InitStreamMode ;
109531: CALL 110711 0 0
// if p3 = 1 then
109535: LD_VAR 0 3
109539: PUSH
109540: LD_INT 1
109542: EQUAL
109543: IFFALSE 109553
// sRocket := true ;
109545: LD_ADDR_EXP 151
109549: PUSH
109550: LD_INT 1
109552: ST_TO_ADDR
// if p3 = 2 then
109553: LD_VAR 0 3
109557: PUSH
109558: LD_INT 2
109560: EQUAL
109561: IFFALSE 109571
// sSpeed := true ;
109563: LD_ADDR_EXP 150
109567: PUSH
109568: LD_INT 1
109570: ST_TO_ADDR
// if p3 = 3 then
109571: LD_VAR 0 3
109575: PUSH
109576: LD_INT 3
109578: EQUAL
109579: IFFALSE 109589
// sEngine := true ;
109581: LD_ADDR_EXP 152
109585: PUSH
109586: LD_INT 1
109588: ST_TO_ADDR
// if p3 = 4 then
109589: LD_VAR 0 3
109593: PUSH
109594: LD_INT 4
109596: EQUAL
109597: IFFALSE 109607
// sSpec := true ;
109599: LD_ADDR_EXP 149
109603: PUSH
109604: LD_INT 1
109606: ST_TO_ADDR
// if p3 = 5 then
109607: LD_VAR 0 3
109611: PUSH
109612: LD_INT 5
109614: EQUAL
109615: IFFALSE 109625
// sLevel := true ;
109617: LD_ADDR_EXP 153
109621: PUSH
109622: LD_INT 1
109624: ST_TO_ADDR
// if p3 = 6 then
109625: LD_VAR 0 3
109629: PUSH
109630: LD_INT 6
109632: EQUAL
109633: IFFALSE 109643
// sArmoury := true ;
109635: LD_ADDR_EXP 154
109639: PUSH
109640: LD_INT 1
109642: ST_TO_ADDR
// if p3 = 7 then
109643: LD_VAR 0 3
109647: PUSH
109648: LD_INT 7
109650: EQUAL
109651: IFFALSE 109661
// sRadar := true ;
109653: LD_ADDR_EXP 155
109657: PUSH
109658: LD_INT 1
109660: ST_TO_ADDR
// if p3 = 8 then
109661: LD_VAR 0 3
109665: PUSH
109666: LD_INT 8
109668: EQUAL
109669: IFFALSE 109679
// sBunker := true ;
109671: LD_ADDR_EXP 156
109675: PUSH
109676: LD_INT 1
109678: ST_TO_ADDR
// if p3 = 9 then
109679: LD_VAR 0 3
109683: PUSH
109684: LD_INT 9
109686: EQUAL
109687: IFFALSE 109697
// sHack := true ;
109689: LD_ADDR_EXP 157
109693: PUSH
109694: LD_INT 1
109696: ST_TO_ADDR
// if p3 = 10 then
109697: LD_VAR 0 3
109701: PUSH
109702: LD_INT 10
109704: EQUAL
109705: IFFALSE 109715
// sFire := true ;
109707: LD_ADDR_EXP 158
109711: PUSH
109712: LD_INT 1
109714: ST_TO_ADDR
// if p3 = 11 then
109715: LD_VAR 0 3
109719: PUSH
109720: LD_INT 11
109722: EQUAL
109723: IFFALSE 109733
// sRefresh := true ;
109725: LD_ADDR_EXP 159
109729: PUSH
109730: LD_INT 1
109732: ST_TO_ADDR
// if p3 = 12 then
109733: LD_VAR 0 3
109737: PUSH
109738: LD_INT 12
109740: EQUAL
109741: IFFALSE 109751
// sExp := true ;
109743: LD_ADDR_EXP 160
109747: PUSH
109748: LD_INT 1
109750: ST_TO_ADDR
// if p3 = 13 then
109751: LD_VAR 0 3
109755: PUSH
109756: LD_INT 13
109758: EQUAL
109759: IFFALSE 109769
// sDepot := true ;
109761: LD_ADDR_EXP 161
109765: PUSH
109766: LD_INT 1
109768: ST_TO_ADDR
// if p3 = 14 then
109769: LD_VAR 0 3
109773: PUSH
109774: LD_INT 14
109776: EQUAL
109777: IFFALSE 109787
// sFlag := true ;
109779: LD_ADDR_EXP 162
109783: PUSH
109784: LD_INT 1
109786: ST_TO_ADDR
// if p3 = 15 then
109787: LD_VAR 0 3
109791: PUSH
109792: LD_INT 15
109794: EQUAL
109795: IFFALSE 109805
// sKamikadze := true ;
109797: LD_ADDR_EXP 170
109801: PUSH
109802: LD_INT 1
109804: ST_TO_ADDR
// if p3 = 16 then
109805: LD_VAR 0 3
109809: PUSH
109810: LD_INT 16
109812: EQUAL
109813: IFFALSE 109823
// sTroll := true ;
109815: LD_ADDR_EXP 171
109819: PUSH
109820: LD_INT 1
109822: ST_TO_ADDR
// if p3 = 17 then
109823: LD_VAR 0 3
109827: PUSH
109828: LD_INT 17
109830: EQUAL
109831: IFFALSE 109841
// sSlow := true ;
109833: LD_ADDR_EXP 172
109837: PUSH
109838: LD_INT 1
109840: ST_TO_ADDR
// if p3 = 18 then
109841: LD_VAR 0 3
109845: PUSH
109846: LD_INT 18
109848: EQUAL
109849: IFFALSE 109859
// sLack := true ;
109851: LD_ADDR_EXP 173
109855: PUSH
109856: LD_INT 1
109858: ST_TO_ADDR
// if p3 = 19 then
109859: LD_VAR 0 3
109863: PUSH
109864: LD_INT 19
109866: EQUAL
109867: IFFALSE 109877
// sTank := true ;
109869: LD_ADDR_EXP 175
109873: PUSH
109874: LD_INT 1
109876: ST_TO_ADDR
// if p3 = 20 then
109877: LD_VAR 0 3
109881: PUSH
109882: LD_INT 20
109884: EQUAL
109885: IFFALSE 109895
// sRemote := true ;
109887: LD_ADDR_EXP 176
109891: PUSH
109892: LD_INT 1
109894: ST_TO_ADDR
// if p3 = 21 then
109895: LD_VAR 0 3
109899: PUSH
109900: LD_INT 21
109902: EQUAL
109903: IFFALSE 109913
// sPowell := true ;
109905: LD_ADDR_EXP 177
109909: PUSH
109910: LD_INT 1
109912: ST_TO_ADDR
// if p3 = 22 then
109913: LD_VAR 0 3
109917: PUSH
109918: LD_INT 22
109920: EQUAL
109921: IFFALSE 109931
// sTeleport := true ;
109923: LD_ADDR_EXP 180
109927: PUSH
109928: LD_INT 1
109930: ST_TO_ADDR
// if p3 = 23 then
109931: LD_VAR 0 3
109935: PUSH
109936: LD_INT 23
109938: EQUAL
109939: IFFALSE 109949
// sOilTower := true ;
109941: LD_ADDR_EXP 182
109945: PUSH
109946: LD_INT 1
109948: ST_TO_ADDR
// if p3 = 24 then
109949: LD_VAR 0 3
109953: PUSH
109954: LD_INT 24
109956: EQUAL
109957: IFFALSE 109967
// sShovel := true ;
109959: LD_ADDR_EXP 183
109963: PUSH
109964: LD_INT 1
109966: ST_TO_ADDR
// if p3 = 25 then
109967: LD_VAR 0 3
109971: PUSH
109972: LD_INT 25
109974: EQUAL
109975: IFFALSE 109985
// sSheik := true ;
109977: LD_ADDR_EXP 184
109981: PUSH
109982: LD_INT 1
109984: ST_TO_ADDR
// if p3 = 26 then
109985: LD_VAR 0 3
109989: PUSH
109990: LD_INT 26
109992: EQUAL
109993: IFFALSE 110003
// sEarthquake := true ;
109995: LD_ADDR_EXP 186
109999: PUSH
110000: LD_INT 1
110002: ST_TO_ADDR
// if p3 = 27 then
110003: LD_VAR 0 3
110007: PUSH
110008: LD_INT 27
110010: EQUAL
110011: IFFALSE 110021
// sAI := true ;
110013: LD_ADDR_EXP 187
110017: PUSH
110018: LD_INT 1
110020: ST_TO_ADDR
// if p3 = 28 then
110021: LD_VAR 0 3
110025: PUSH
110026: LD_INT 28
110028: EQUAL
110029: IFFALSE 110039
// sCargo := true ;
110031: LD_ADDR_EXP 190
110035: PUSH
110036: LD_INT 1
110038: ST_TO_ADDR
// if p3 = 29 then
110039: LD_VAR 0 3
110043: PUSH
110044: LD_INT 29
110046: EQUAL
110047: IFFALSE 110057
// sDLaser := true ;
110049: LD_ADDR_EXP 191
110053: PUSH
110054: LD_INT 1
110056: ST_TO_ADDR
// if p3 = 30 then
110057: LD_VAR 0 3
110061: PUSH
110062: LD_INT 30
110064: EQUAL
110065: IFFALSE 110075
// sExchange := true ;
110067: LD_ADDR_EXP 192
110071: PUSH
110072: LD_INT 1
110074: ST_TO_ADDR
// if p3 = 31 then
110075: LD_VAR 0 3
110079: PUSH
110080: LD_INT 31
110082: EQUAL
110083: IFFALSE 110093
// sFac := true ;
110085: LD_ADDR_EXP 193
110089: PUSH
110090: LD_INT 1
110092: ST_TO_ADDR
// if p3 = 32 then
110093: LD_VAR 0 3
110097: PUSH
110098: LD_INT 32
110100: EQUAL
110101: IFFALSE 110111
// sPower := true ;
110103: LD_ADDR_EXP 194
110107: PUSH
110108: LD_INT 1
110110: ST_TO_ADDR
// if p3 = 33 then
110111: LD_VAR 0 3
110115: PUSH
110116: LD_INT 33
110118: EQUAL
110119: IFFALSE 110129
// sRandom := true ;
110121: LD_ADDR_EXP 195
110125: PUSH
110126: LD_INT 1
110128: ST_TO_ADDR
// if p3 = 34 then
110129: LD_VAR 0 3
110133: PUSH
110134: LD_INT 34
110136: EQUAL
110137: IFFALSE 110147
// sShield := true ;
110139: LD_ADDR_EXP 196
110143: PUSH
110144: LD_INT 1
110146: ST_TO_ADDR
// if p3 = 35 then
110147: LD_VAR 0 3
110151: PUSH
110152: LD_INT 35
110154: EQUAL
110155: IFFALSE 110165
// sTime := true ;
110157: LD_ADDR_EXP 197
110161: PUSH
110162: LD_INT 1
110164: ST_TO_ADDR
// if p3 = 36 then
110165: LD_VAR 0 3
110169: PUSH
110170: LD_INT 36
110172: EQUAL
110173: IFFALSE 110183
// sTools := true ;
110175: LD_ADDR_EXP 198
110179: PUSH
110180: LD_INT 1
110182: ST_TO_ADDR
// if p3 = 101 then
110183: LD_VAR 0 3
110187: PUSH
110188: LD_INT 101
110190: EQUAL
110191: IFFALSE 110201
// sSold := true ;
110193: LD_ADDR_EXP 163
110197: PUSH
110198: LD_INT 1
110200: ST_TO_ADDR
// if p3 = 102 then
110201: LD_VAR 0 3
110205: PUSH
110206: LD_INT 102
110208: EQUAL
110209: IFFALSE 110219
// sDiff := true ;
110211: LD_ADDR_EXP 164
110215: PUSH
110216: LD_INT 1
110218: ST_TO_ADDR
// if p3 = 103 then
110219: LD_VAR 0 3
110223: PUSH
110224: LD_INT 103
110226: EQUAL
110227: IFFALSE 110237
// sFog := true ;
110229: LD_ADDR_EXP 167
110233: PUSH
110234: LD_INT 1
110236: ST_TO_ADDR
// if p3 = 104 then
110237: LD_VAR 0 3
110241: PUSH
110242: LD_INT 104
110244: EQUAL
110245: IFFALSE 110255
// sReset := true ;
110247: LD_ADDR_EXP 168
110251: PUSH
110252: LD_INT 1
110254: ST_TO_ADDR
// if p3 = 105 then
110255: LD_VAR 0 3
110259: PUSH
110260: LD_INT 105
110262: EQUAL
110263: IFFALSE 110273
// sSun := true ;
110265: LD_ADDR_EXP 169
110269: PUSH
110270: LD_INT 1
110272: ST_TO_ADDR
// if p3 = 106 then
110273: LD_VAR 0 3
110277: PUSH
110278: LD_INT 106
110280: EQUAL
110281: IFFALSE 110291
// sTiger := true ;
110283: LD_ADDR_EXP 165
110287: PUSH
110288: LD_INT 1
110290: ST_TO_ADDR
// if p3 = 107 then
110291: LD_VAR 0 3
110295: PUSH
110296: LD_INT 107
110298: EQUAL
110299: IFFALSE 110309
// sBomb := true ;
110301: LD_ADDR_EXP 166
110305: PUSH
110306: LD_INT 1
110308: ST_TO_ADDR
// if p3 = 108 then
110309: LD_VAR 0 3
110313: PUSH
110314: LD_INT 108
110316: EQUAL
110317: IFFALSE 110327
// sWound := true ;
110319: LD_ADDR_EXP 174
110323: PUSH
110324: LD_INT 1
110326: ST_TO_ADDR
// if p3 = 109 then
110327: LD_VAR 0 3
110331: PUSH
110332: LD_INT 109
110334: EQUAL
110335: IFFALSE 110345
// sBetray := true ;
110337: LD_ADDR_EXP 178
110341: PUSH
110342: LD_INT 1
110344: ST_TO_ADDR
// if p3 = 110 then
110345: LD_VAR 0 3
110349: PUSH
110350: LD_INT 110
110352: EQUAL
110353: IFFALSE 110363
// sContamin := true ;
110355: LD_ADDR_EXP 179
110359: PUSH
110360: LD_INT 1
110362: ST_TO_ADDR
// if p3 = 111 then
110363: LD_VAR 0 3
110367: PUSH
110368: LD_INT 111
110370: EQUAL
110371: IFFALSE 110381
// sOil := true ;
110373: LD_ADDR_EXP 181
110377: PUSH
110378: LD_INT 1
110380: ST_TO_ADDR
// if p3 = 112 then
110381: LD_VAR 0 3
110385: PUSH
110386: LD_INT 112
110388: EQUAL
110389: IFFALSE 110399
// sStu := true ;
110391: LD_ADDR_EXP 185
110395: PUSH
110396: LD_INT 1
110398: ST_TO_ADDR
// if p3 = 113 then
110399: LD_VAR 0 3
110403: PUSH
110404: LD_INT 113
110406: EQUAL
110407: IFFALSE 110417
// sBazooka := true ;
110409: LD_ADDR_EXP 188
110413: PUSH
110414: LD_INT 1
110416: ST_TO_ADDR
// if p3 = 114 then
110417: LD_VAR 0 3
110421: PUSH
110422: LD_INT 114
110424: EQUAL
110425: IFFALSE 110435
// sMortar := true ;
110427: LD_ADDR_EXP 189
110431: PUSH
110432: LD_INT 1
110434: ST_TO_ADDR
// if p3 = 115 then
110435: LD_VAR 0 3
110439: PUSH
110440: LD_INT 115
110442: EQUAL
110443: IFFALSE 110453
// sRanger := true ;
110445: LD_ADDR_EXP 199
110449: PUSH
110450: LD_INT 1
110452: ST_TO_ADDR
// if p3 = 116 then
110453: LD_VAR 0 3
110457: PUSH
110458: LD_INT 116
110460: EQUAL
110461: IFFALSE 110471
// sComputer := true ;
110463: LD_ADDR_EXP 200
110467: PUSH
110468: LD_INT 1
110470: ST_TO_ADDR
// if p3 = 117 then
110471: LD_VAR 0 3
110475: PUSH
110476: LD_INT 117
110478: EQUAL
110479: IFFALSE 110489
// s30 := true ;
110481: LD_ADDR_EXP 201
110485: PUSH
110486: LD_INT 1
110488: ST_TO_ADDR
// if p3 = 118 then
110489: LD_VAR 0 3
110493: PUSH
110494: LD_INT 118
110496: EQUAL
110497: IFFALSE 110507
// s60 := true ;
110499: LD_ADDR_EXP 202
110503: PUSH
110504: LD_INT 1
110506: ST_TO_ADDR
// end ; if p2 = hack_mode then
110507: LD_VAR 0 2
110511: PUSH
110512: LD_INT 101
110514: EQUAL
110515: IFFALSE 110643
// begin case p3 of 1 :
110517: LD_VAR 0 3
110521: PUSH
110522: LD_INT 1
110524: DOUBLE
110525: EQUAL
110526: IFTRUE 110530
110528: GO 110537
110530: POP
// hHackUnlimitedResources ; 2 :
110531: CALL 122782 0 0
110535: GO 110643
110537: LD_INT 2
110539: DOUBLE
110540: EQUAL
110541: IFTRUE 110545
110543: GO 110552
110545: POP
// hHackSetLevel10 ; 3 :
110546: CALL 122915 0 0
110550: GO 110643
110552: LD_INT 3
110554: DOUBLE
110555: EQUAL
110556: IFTRUE 110560
110558: GO 110567
110560: POP
// hHackSetLevel10YourUnits ; 4 :
110561: CALL 123000 0 0
110565: GO 110643
110567: LD_INT 4
110569: DOUBLE
110570: EQUAL
110571: IFTRUE 110575
110573: GO 110582
110575: POP
// hHackInvincible ; 5 :
110576: CALL 123448 0 0
110580: GO 110643
110582: LD_INT 5
110584: DOUBLE
110585: EQUAL
110586: IFTRUE 110590
110588: GO 110597
110590: POP
// hHackInvisible ; 6 :
110591: CALL 123559 0 0
110595: GO 110643
110597: LD_INT 6
110599: DOUBLE
110600: EQUAL
110601: IFTRUE 110605
110603: GO 110612
110605: POP
// hHackChangeYourSide ; 7 :
110606: CALL 123616 0 0
110610: GO 110643
110612: LD_INT 7
110614: DOUBLE
110615: EQUAL
110616: IFTRUE 110620
110618: GO 110627
110620: POP
// hHackChangeUnitSide ; 8 :
110621: CALL 123658 0 0
110625: GO 110643
110627: LD_INT 8
110629: DOUBLE
110630: EQUAL
110631: IFTRUE 110635
110633: GO 110642
110635: POP
// hHackFog ; end ;
110636: CALL 123759 0 0
110640: GO 110643
110642: POP
// end ; if p2 = game_save_mode then
110643: LD_VAR 0 2
110647: PUSH
110648: LD_INT 102
110650: EQUAL
110651: IFFALSE 110706
// begin if p3 = 1 then
110653: LD_VAR 0 3
110657: PUSH
110658: LD_INT 1
110660: EQUAL
110661: IFFALSE 110673
// globalGameSaveCounter := p4 ;
110663: LD_ADDR_EXP 145
110667: PUSH
110668: LD_VAR 0 4
110672: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
110673: LD_VAR 0 3
110677: PUSH
110678: LD_INT 2
110680: EQUAL
110681: PUSH
110682: LD_EXP 145
110686: AND
110687: IFFALSE 110706
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
110689: LD_STRING setGameSaveCounter(
110691: PUSH
110692: LD_EXP 145
110696: STR
110697: PUSH
110698: LD_STRING )
110700: STR
110701: PPUSH
110702: CALL_OW 559
// end ; end ;
110706: LD_VAR 0 7
110710: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
110711: LD_INT 0
110713: PPUSH
// streamModeActive := false ;
110714: LD_ADDR_EXP 146
110718: PUSH
110719: LD_INT 0
110721: ST_TO_ADDR
// normalCounter := 36 ;
110722: LD_ADDR_EXP 147
110726: PUSH
110727: LD_INT 36
110729: ST_TO_ADDR
// hardcoreCounter := 18 ;
110730: LD_ADDR_EXP 148
110734: PUSH
110735: LD_INT 18
110737: ST_TO_ADDR
// sRocket := false ;
110738: LD_ADDR_EXP 151
110742: PUSH
110743: LD_INT 0
110745: ST_TO_ADDR
// sSpeed := false ;
110746: LD_ADDR_EXP 150
110750: PUSH
110751: LD_INT 0
110753: ST_TO_ADDR
// sEngine := false ;
110754: LD_ADDR_EXP 152
110758: PUSH
110759: LD_INT 0
110761: ST_TO_ADDR
// sSpec := false ;
110762: LD_ADDR_EXP 149
110766: PUSH
110767: LD_INT 0
110769: ST_TO_ADDR
// sLevel := false ;
110770: LD_ADDR_EXP 153
110774: PUSH
110775: LD_INT 0
110777: ST_TO_ADDR
// sArmoury := false ;
110778: LD_ADDR_EXP 154
110782: PUSH
110783: LD_INT 0
110785: ST_TO_ADDR
// sRadar := false ;
110786: LD_ADDR_EXP 155
110790: PUSH
110791: LD_INT 0
110793: ST_TO_ADDR
// sBunker := false ;
110794: LD_ADDR_EXP 156
110798: PUSH
110799: LD_INT 0
110801: ST_TO_ADDR
// sHack := false ;
110802: LD_ADDR_EXP 157
110806: PUSH
110807: LD_INT 0
110809: ST_TO_ADDR
// sFire := false ;
110810: LD_ADDR_EXP 158
110814: PUSH
110815: LD_INT 0
110817: ST_TO_ADDR
// sRefresh := false ;
110818: LD_ADDR_EXP 159
110822: PUSH
110823: LD_INT 0
110825: ST_TO_ADDR
// sExp := false ;
110826: LD_ADDR_EXP 160
110830: PUSH
110831: LD_INT 0
110833: ST_TO_ADDR
// sDepot := false ;
110834: LD_ADDR_EXP 161
110838: PUSH
110839: LD_INT 0
110841: ST_TO_ADDR
// sFlag := false ;
110842: LD_ADDR_EXP 162
110846: PUSH
110847: LD_INT 0
110849: ST_TO_ADDR
// sKamikadze := false ;
110850: LD_ADDR_EXP 170
110854: PUSH
110855: LD_INT 0
110857: ST_TO_ADDR
// sTroll := false ;
110858: LD_ADDR_EXP 171
110862: PUSH
110863: LD_INT 0
110865: ST_TO_ADDR
// sSlow := false ;
110866: LD_ADDR_EXP 172
110870: PUSH
110871: LD_INT 0
110873: ST_TO_ADDR
// sLack := false ;
110874: LD_ADDR_EXP 173
110878: PUSH
110879: LD_INT 0
110881: ST_TO_ADDR
// sTank := false ;
110882: LD_ADDR_EXP 175
110886: PUSH
110887: LD_INT 0
110889: ST_TO_ADDR
// sRemote := false ;
110890: LD_ADDR_EXP 176
110894: PUSH
110895: LD_INT 0
110897: ST_TO_ADDR
// sPowell := false ;
110898: LD_ADDR_EXP 177
110902: PUSH
110903: LD_INT 0
110905: ST_TO_ADDR
// sTeleport := false ;
110906: LD_ADDR_EXP 180
110910: PUSH
110911: LD_INT 0
110913: ST_TO_ADDR
// sOilTower := false ;
110914: LD_ADDR_EXP 182
110918: PUSH
110919: LD_INT 0
110921: ST_TO_ADDR
// sShovel := false ;
110922: LD_ADDR_EXP 183
110926: PUSH
110927: LD_INT 0
110929: ST_TO_ADDR
// sSheik := false ;
110930: LD_ADDR_EXP 184
110934: PUSH
110935: LD_INT 0
110937: ST_TO_ADDR
// sEarthquake := false ;
110938: LD_ADDR_EXP 186
110942: PUSH
110943: LD_INT 0
110945: ST_TO_ADDR
// sAI := false ;
110946: LD_ADDR_EXP 187
110950: PUSH
110951: LD_INT 0
110953: ST_TO_ADDR
// sCargo := false ;
110954: LD_ADDR_EXP 190
110958: PUSH
110959: LD_INT 0
110961: ST_TO_ADDR
// sDLaser := false ;
110962: LD_ADDR_EXP 191
110966: PUSH
110967: LD_INT 0
110969: ST_TO_ADDR
// sExchange := false ;
110970: LD_ADDR_EXP 192
110974: PUSH
110975: LD_INT 0
110977: ST_TO_ADDR
// sFac := false ;
110978: LD_ADDR_EXP 193
110982: PUSH
110983: LD_INT 0
110985: ST_TO_ADDR
// sPower := false ;
110986: LD_ADDR_EXP 194
110990: PUSH
110991: LD_INT 0
110993: ST_TO_ADDR
// sRandom := false ;
110994: LD_ADDR_EXP 195
110998: PUSH
110999: LD_INT 0
111001: ST_TO_ADDR
// sShield := false ;
111002: LD_ADDR_EXP 196
111006: PUSH
111007: LD_INT 0
111009: ST_TO_ADDR
// sTime := false ;
111010: LD_ADDR_EXP 197
111014: PUSH
111015: LD_INT 0
111017: ST_TO_ADDR
// sTools := false ;
111018: LD_ADDR_EXP 198
111022: PUSH
111023: LD_INT 0
111025: ST_TO_ADDR
// sSold := false ;
111026: LD_ADDR_EXP 163
111030: PUSH
111031: LD_INT 0
111033: ST_TO_ADDR
// sDiff := false ;
111034: LD_ADDR_EXP 164
111038: PUSH
111039: LD_INT 0
111041: ST_TO_ADDR
// sFog := false ;
111042: LD_ADDR_EXP 167
111046: PUSH
111047: LD_INT 0
111049: ST_TO_ADDR
// sReset := false ;
111050: LD_ADDR_EXP 168
111054: PUSH
111055: LD_INT 0
111057: ST_TO_ADDR
// sSun := false ;
111058: LD_ADDR_EXP 169
111062: PUSH
111063: LD_INT 0
111065: ST_TO_ADDR
// sTiger := false ;
111066: LD_ADDR_EXP 165
111070: PUSH
111071: LD_INT 0
111073: ST_TO_ADDR
// sBomb := false ;
111074: LD_ADDR_EXP 166
111078: PUSH
111079: LD_INT 0
111081: ST_TO_ADDR
// sWound := false ;
111082: LD_ADDR_EXP 174
111086: PUSH
111087: LD_INT 0
111089: ST_TO_ADDR
// sBetray := false ;
111090: LD_ADDR_EXP 178
111094: PUSH
111095: LD_INT 0
111097: ST_TO_ADDR
// sContamin := false ;
111098: LD_ADDR_EXP 179
111102: PUSH
111103: LD_INT 0
111105: ST_TO_ADDR
// sOil := false ;
111106: LD_ADDR_EXP 181
111110: PUSH
111111: LD_INT 0
111113: ST_TO_ADDR
// sStu := false ;
111114: LD_ADDR_EXP 185
111118: PUSH
111119: LD_INT 0
111121: ST_TO_ADDR
// sBazooka := false ;
111122: LD_ADDR_EXP 188
111126: PUSH
111127: LD_INT 0
111129: ST_TO_ADDR
// sMortar := false ;
111130: LD_ADDR_EXP 189
111134: PUSH
111135: LD_INT 0
111137: ST_TO_ADDR
// sRanger := false ;
111138: LD_ADDR_EXP 199
111142: PUSH
111143: LD_INT 0
111145: ST_TO_ADDR
// sComputer := false ;
111146: LD_ADDR_EXP 200
111150: PUSH
111151: LD_INT 0
111153: ST_TO_ADDR
// s30 := false ;
111154: LD_ADDR_EXP 201
111158: PUSH
111159: LD_INT 0
111161: ST_TO_ADDR
// s60 := false ;
111162: LD_ADDR_EXP 202
111166: PUSH
111167: LD_INT 0
111169: ST_TO_ADDR
// end ;
111170: LD_VAR 0 1
111174: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
111175: LD_INT 0
111177: PPUSH
111178: PPUSH
111179: PPUSH
111180: PPUSH
111181: PPUSH
111182: PPUSH
111183: PPUSH
// result := [ ] ;
111184: LD_ADDR_VAR 0 2
111188: PUSH
111189: EMPTY
111190: ST_TO_ADDR
// if campaign_id = 1 then
111191: LD_OWVAR 69
111195: PUSH
111196: LD_INT 1
111198: EQUAL
111199: IFFALSE 114365
// begin case mission_number of 1 :
111201: LD_OWVAR 70
111205: PUSH
111206: LD_INT 1
111208: DOUBLE
111209: EQUAL
111210: IFTRUE 111214
111212: GO 111290
111214: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
111215: LD_ADDR_VAR 0 2
111219: PUSH
111220: LD_INT 2
111222: PUSH
111223: LD_INT 4
111225: PUSH
111226: LD_INT 11
111228: PUSH
111229: LD_INT 12
111231: PUSH
111232: LD_INT 15
111234: PUSH
111235: LD_INT 16
111237: PUSH
111238: LD_INT 22
111240: PUSH
111241: LD_INT 23
111243: PUSH
111244: LD_INT 26
111246: PUSH
111247: EMPTY
111248: LIST
111249: LIST
111250: LIST
111251: LIST
111252: LIST
111253: LIST
111254: LIST
111255: LIST
111256: LIST
111257: PUSH
111258: LD_INT 101
111260: PUSH
111261: LD_INT 102
111263: PUSH
111264: LD_INT 106
111266: PUSH
111267: LD_INT 116
111269: PUSH
111270: LD_INT 117
111272: PUSH
111273: LD_INT 118
111275: PUSH
111276: EMPTY
111277: LIST
111278: LIST
111279: LIST
111280: LIST
111281: LIST
111282: LIST
111283: PUSH
111284: EMPTY
111285: LIST
111286: LIST
111287: ST_TO_ADDR
111288: GO 114363
111290: LD_INT 2
111292: DOUBLE
111293: EQUAL
111294: IFTRUE 111298
111296: GO 111382
111298: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
111299: LD_ADDR_VAR 0 2
111303: PUSH
111304: LD_INT 2
111306: PUSH
111307: LD_INT 4
111309: PUSH
111310: LD_INT 11
111312: PUSH
111313: LD_INT 12
111315: PUSH
111316: LD_INT 15
111318: PUSH
111319: LD_INT 16
111321: PUSH
111322: LD_INT 22
111324: PUSH
111325: LD_INT 23
111327: PUSH
111328: LD_INT 26
111330: PUSH
111331: EMPTY
111332: LIST
111333: LIST
111334: LIST
111335: LIST
111336: LIST
111337: LIST
111338: LIST
111339: LIST
111340: LIST
111341: PUSH
111342: LD_INT 101
111344: PUSH
111345: LD_INT 102
111347: PUSH
111348: LD_INT 105
111350: PUSH
111351: LD_INT 106
111353: PUSH
111354: LD_INT 108
111356: PUSH
111357: LD_INT 116
111359: PUSH
111360: LD_INT 117
111362: PUSH
111363: LD_INT 118
111365: PUSH
111366: EMPTY
111367: LIST
111368: LIST
111369: LIST
111370: LIST
111371: LIST
111372: LIST
111373: LIST
111374: LIST
111375: PUSH
111376: EMPTY
111377: LIST
111378: LIST
111379: ST_TO_ADDR
111380: GO 114363
111382: LD_INT 3
111384: DOUBLE
111385: EQUAL
111386: IFTRUE 111390
111388: GO 111478
111390: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
111391: LD_ADDR_VAR 0 2
111395: PUSH
111396: LD_INT 2
111398: PUSH
111399: LD_INT 4
111401: PUSH
111402: LD_INT 5
111404: PUSH
111405: LD_INT 11
111407: PUSH
111408: LD_INT 12
111410: PUSH
111411: LD_INT 15
111413: PUSH
111414: LD_INT 16
111416: PUSH
111417: LD_INT 22
111419: PUSH
111420: LD_INT 26
111422: PUSH
111423: LD_INT 36
111425: PUSH
111426: EMPTY
111427: LIST
111428: LIST
111429: LIST
111430: LIST
111431: LIST
111432: LIST
111433: LIST
111434: LIST
111435: LIST
111436: LIST
111437: PUSH
111438: LD_INT 101
111440: PUSH
111441: LD_INT 102
111443: PUSH
111444: LD_INT 105
111446: PUSH
111447: LD_INT 106
111449: PUSH
111450: LD_INT 108
111452: PUSH
111453: LD_INT 116
111455: PUSH
111456: LD_INT 117
111458: PUSH
111459: LD_INT 118
111461: PUSH
111462: EMPTY
111463: LIST
111464: LIST
111465: LIST
111466: LIST
111467: LIST
111468: LIST
111469: LIST
111470: LIST
111471: PUSH
111472: EMPTY
111473: LIST
111474: LIST
111475: ST_TO_ADDR
111476: GO 114363
111478: LD_INT 4
111480: DOUBLE
111481: EQUAL
111482: IFTRUE 111486
111484: GO 111582
111486: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
111487: LD_ADDR_VAR 0 2
111491: PUSH
111492: LD_INT 2
111494: PUSH
111495: LD_INT 4
111497: PUSH
111498: LD_INT 5
111500: PUSH
111501: LD_INT 8
111503: PUSH
111504: LD_INT 11
111506: PUSH
111507: LD_INT 12
111509: PUSH
111510: LD_INT 15
111512: PUSH
111513: LD_INT 16
111515: PUSH
111516: LD_INT 22
111518: PUSH
111519: LD_INT 23
111521: PUSH
111522: LD_INT 26
111524: PUSH
111525: LD_INT 36
111527: PUSH
111528: EMPTY
111529: LIST
111530: LIST
111531: LIST
111532: LIST
111533: LIST
111534: LIST
111535: LIST
111536: LIST
111537: LIST
111538: LIST
111539: LIST
111540: LIST
111541: PUSH
111542: LD_INT 101
111544: PUSH
111545: LD_INT 102
111547: PUSH
111548: LD_INT 105
111550: PUSH
111551: LD_INT 106
111553: PUSH
111554: LD_INT 108
111556: PUSH
111557: LD_INT 116
111559: PUSH
111560: LD_INT 117
111562: PUSH
111563: LD_INT 118
111565: PUSH
111566: EMPTY
111567: LIST
111568: LIST
111569: LIST
111570: LIST
111571: LIST
111572: LIST
111573: LIST
111574: LIST
111575: PUSH
111576: EMPTY
111577: LIST
111578: LIST
111579: ST_TO_ADDR
111580: GO 114363
111582: LD_INT 5
111584: DOUBLE
111585: EQUAL
111586: IFTRUE 111590
111588: GO 111702
111590: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
111591: LD_ADDR_VAR 0 2
111595: PUSH
111596: LD_INT 2
111598: PUSH
111599: LD_INT 4
111601: PUSH
111602: LD_INT 5
111604: PUSH
111605: LD_INT 6
111607: PUSH
111608: LD_INT 8
111610: PUSH
111611: LD_INT 11
111613: PUSH
111614: LD_INT 12
111616: PUSH
111617: LD_INT 15
111619: PUSH
111620: LD_INT 16
111622: PUSH
111623: LD_INT 22
111625: PUSH
111626: LD_INT 23
111628: PUSH
111629: LD_INT 25
111631: PUSH
111632: LD_INT 26
111634: PUSH
111635: LD_INT 36
111637: PUSH
111638: EMPTY
111639: LIST
111640: LIST
111641: LIST
111642: LIST
111643: LIST
111644: LIST
111645: LIST
111646: LIST
111647: LIST
111648: LIST
111649: LIST
111650: LIST
111651: LIST
111652: LIST
111653: PUSH
111654: LD_INT 101
111656: PUSH
111657: LD_INT 102
111659: PUSH
111660: LD_INT 105
111662: PUSH
111663: LD_INT 106
111665: PUSH
111666: LD_INT 108
111668: PUSH
111669: LD_INT 109
111671: PUSH
111672: LD_INT 112
111674: PUSH
111675: LD_INT 116
111677: PUSH
111678: LD_INT 117
111680: PUSH
111681: LD_INT 118
111683: PUSH
111684: EMPTY
111685: LIST
111686: LIST
111687: LIST
111688: LIST
111689: LIST
111690: LIST
111691: LIST
111692: LIST
111693: LIST
111694: LIST
111695: PUSH
111696: EMPTY
111697: LIST
111698: LIST
111699: ST_TO_ADDR
111700: GO 114363
111702: LD_INT 6
111704: DOUBLE
111705: EQUAL
111706: IFTRUE 111710
111708: GO 111842
111710: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
111711: LD_ADDR_VAR 0 2
111715: PUSH
111716: LD_INT 2
111718: PUSH
111719: LD_INT 4
111721: PUSH
111722: LD_INT 5
111724: PUSH
111725: LD_INT 6
111727: PUSH
111728: LD_INT 8
111730: PUSH
111731: LD_INT 11
111733: PUSH
111734: LD_INT 12
111736: PUSH
111737: LD_INT 15
111739: PUSH
111740: LD_INT 16
111742: PUSH
111743: LD_INT 20
111745: PUSH
111746: LD_INT 21
111748: PUSH
111749: LD_INT 22
111751: PUSH
111752: LD_INT 23
111754: PUSH
111755: LD_INT 25
111757: PUSH
111758: LD_INT 26
111760: PUSH
111761: LD_INT 30
111763: PUSH
111764: LD_INT 31
111766: PUSH
111767: LD_INT 32
111769: PUSH
111770: LD_INT 36
111772: PUSH
111773: EMPTY
111774: LIST
111775: LIST
111776: LIST
111777: LIST
111778: LIST
111779: LIST
111780: LIST
111781: LIST
111782: LIST
111783: LIST
111784: LIST
111785: LIST
111786: LIST
111787: LIST
111788: LIST
111789: LIST
111790: LIST
111791: LIST
111792: LIST
111793: PUSH
111794: LD_INT 101
111796: PUSH
111797: LD_INT 102
111799: PUSH
111800: LD_INT 105
111802: PUSH
111803: LD_INT 106
111805: PUSH
111806: LD_INT 108
111808: PUSH
111809: LD_INT 109
111811: PUSH
111812: LD_INT 112
111814: PUSH
111815: LD_INT 116
111817: PUSH
111818: LD_INT 117
111820: PUSH
111821: LD_INT 118
111823: PUSH
111824: EMPTY
111825: LIST
111826: LIST
111827: LIST
111828: LIST
111829: LIST
111830: LIST
111831: LIST
111832: LIST
111833: LIST
111834: LIST
111835: PUSH
111836: EMPTY
111837: LIST
111838: LIST
111839: ST_TO_ADDR
111840: GO 114363
111842: LD_INT 7
111844: DOUBLE
111845: EQUAL
111846: IFTRUE 111850
111848: GO 111962
111850: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
111851: LD_ADDR_VAR 0 2
111855: PUSH
111856: LD_INT 2
111858: PUSH
111859: LD_INT 4
111861: PUSH
111862: LD_INT 5
111864: PUSH
111865: LD_INT 7
111867: PUSH
111868: LD_INT 11
111870: PUSH
111871: LD_INT 12
111873: PUSH
111874: LD_INT 15
111876: PUSH
111877: LD_INT 16
111879: PUSH
111880: LD_INT 20
111882: PUSH
111883: LD_INT 21
111885: PUSH
111886: LD_INT 22
111888: PUSH
111889: LD_INT 23
111891: PUSH
111892: LD_INT 25
111894: PUSH
111895: LD_INT 26
111897: PUSH
111898: EMPTY
111899: LIST
111900: LIST
111901: LIST
111902: LIST
111903: LIST
111904: LIST
111905: LIST
111906: LIST
111907: LIST
111908: LIST
111909: LIST
111910: LIST
111911: LIST
111912: LIST
111913: PUSH
111914: LD_INT 101
111916: PUSH
111917: LD_INT 102
111919: PUSH
111920: LD_INT 103
111922: PUSH
111923: LD_INT 105
111925: PUSH
111926: LD_INT 106
111928: PUSH
111929: LD_INT 108
111931: PUSH
111932: LD_INT 112
111934: PUSH
111935: LD_INT 116
111937: PUSH
111938: LD_INT 117
111940: PUSH
111941: LD_INT 118
111943: PUSH
111944: EMPTY
111945: LIST
111946: LIST
111947: LIST
111948: LIST
111949: LIST
111950: LIST
111951: LIST
111952: LIST
111953: LIST
111954: LIST
111955: PUSH
111956: EMPTY
111957: LIST
111958: LIST
111959: ST_TO_ADDR
111960: GO 114363
111962: LD_INT 8
111964: DOUBLE
111965: EQUAL
111966: IFTRUE 111970
111968: GO 112110
111970: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
111971: LD_ADDR_VAR 0 2
111975: PUSH
111976: LD_INT 2
111978: PUSH
111979: LD_INT 4
111981: PUSH
111982: LD_INT 5
111984: PUSH
111985: LD_INT 6
111987: PUSH
111988: LD_INT 7
111990: PUSH
111991: LD_INT 8
111993: PUSH
111994: LD_INT 11
111996: PUSH
111997: LD_INT 12
111999: PUSH
112000: LD_INT 15
112002: PUSH
112003: LD_INT 16
112005: PUSH
112006: LD_INT 20
112008: PUSH
112009: LD_INT 21
112011: PUSH
112012: LD_INT 22
112014: PUSH
112015: LD_INT 23
112017: PUSH
112018: LD_INT 25
112020: PUSH
112021: LD_INT 26
112023: PUSH
112024: LD_INT 30
112026: PUSH
112027: LD_INT 31
112029: PUSH
112030: LD_INT 32
112032: PUSH
112033: LD_INT 36
112035: PUSH
112036: EMPTY
112037: LIST
112038: LIST
112039: LIST
112040: LIST
112041: LIST
112042: LIST
112043: LIST
112044: LIST
112045: LIST
112046: LIST
112047: LIST
112048: LIST
112049: LIST
112050: LIST
112051: LIST
112052: LIST
112053: LIST
112054: LIST
112055: LIST
112056: LIST
112057: PUSH
112058: LD_INT 101
112060: PUSH
112061: LD_INT 102
112063: PUSH
112064: LD_INT 103
112066: PUSH
112067: LD_INT 105
112069: PUSH
112070: LD_INT 106
112072: PUSH
112073: LD_INT 108
112075: PUSH
112076: LD_INT 109
112078: PUSH
112079: LD_INT 112
112081: PUSH
112082: LD_INT 116
112084: PUSH
112085: LD_INT 117
112087: PUSH
112088: LD_INT 118
112090: PUSH
112091: EMPTY
112092: LIST
112093: LIST
112094: LIST
112095: LIST
112096: LIST
112097: LIST
112098: LIST
112099: LIST
112100: LIST
112101: LIST
112102: LIST
112103: PUSH
112104: EMPTY
112105: LIST
112106: LIST
112107: ST_TO_ADDR
112108: GO 114363
112110: LD_INT 9
112112: DOUBLE
112113: EQUAL
112114: IFTRUE 112118
112116: GO 112266
112118: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
112119: LD_ADDR_VAR 0 2
112123: PUSH
112124: LD_INT 2
112126: PUSH
112127: LD_INT 4
112129: PUSH
112130: LD_INT 5
112132: PUSH
112133: LD_INT 6
112135: PUSH
112136: LD_INT 7
112138: PUSH
112139: LD_INT 8
112141: PUSH
112142: LD_INT 11
112144: PUSH
112145: LD_INT 12
112147: PUSH
112148: LD_INT 15
112150: PUSH
112151: LD_INT 16
112153: PUSH
112154: LD_INT 20
112156: PUSH
112157: LD_INT 21
112159: PUSH
112160: LD_INT 22
112162: PUSH
112163: LD_INT 23
112165: PUSH
112166: LD_INT 25
112168: PUSH
112169: LD_INT 26
112171: PUSH
112172: LD_INT 28
112174: PUSH
112175: LD_INT 30
112177: PUSH
112178: LD_INT 31
112180: PUSH
112181: LD_INT 32
112183: PUSH
112184: LD_INT 36
112186: PUSH
112187: EMPTY
112188: LIST
112189: LIST
112190: LIST
112191: LIST
112192: LIST
112193: LIST
112194: LIST
112195: LIST
112196: LIST
112197: LIST
112198: LIST
112199: LIST
112200: LIST
112201: LIST
112202: LIST
112203: LIST
112204: LIST
112205: LIST
112206: LIST
112207: LIST
112208: LIST
112209: PUSH
112210: LD_INT 101
112212: PUSH
112213: LD_INT 102
112215: PUSH
112216: LD_INT 103
112218: PUSH
112219: LD_INT 105
112221: PUSH
112222: LD_INT 106
112224: PUSH
112225: LD_INT 108
112227: PUSH
112228: LD_INT 109
112230: PUSH
112231: LD_INT 112
112233: PUSH
112234: LD_INT 114
112236: PUSH
112237: LD_INT 116
112239: PUSH
112240: LD_INT 117
112242: PUSH
112243: LD_INT 118
112245: PUSH
112246: EMPTY
112247: LIST
112248: LIST
112249: LIST
112250: LIST
112251: LIST
112252: LIST
112253: LIST
112254: LIST
112255: LIST
112256: LIST
112257: LIST
112258: LIST
112259: PUSH
112260: EMPTY
112261: LIST
112262: LIST
112263: ST_TO_ADDR
112264: GO 114363
112266: LD_INT 10
112268: DOUBLE
112269: EQUAL
112270: IFTRUE 112274
112272: GO 112470
112274: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
112275: LD_ADDR_VAR 0 2
112279: PUSH
112280: LD_INT 2
112282: PUSH
112283: LD_INT 4
112285: PUSH
112286: LD_INT 5
112288: PUSH
112289: LD_INT 6
112291: PUSH
112292: LD_INT 7
112294: PUSH
112295: LD_INT 8
112297: PUSH
112298: LD_INT 9
112300: PUSH
112301: LD_INT 10
112303: PUSH
112304: LD_INT 11
112306: PUSH
112307: LD_INT 12
112309: PUSH
112310: LD_INT 13
112312: PUSH
112313: LD_INT 14
112315: PUSH
112316: LD_INT 15
112318: PUSH
112319: LD_INT 16
112321: PUSH
112322: LD_INT 17
112324: PUSH
112325: LD_INT 18
112327: PUSH
112328: LD_INT 19
112330: PUSH
112331: LD_INT 20
112333: PUSH
112334: LD_INT 21
112336: PUSH
112337: LD_INT 22
112339: PUSH
112340: LD_INT 23
112342: PUSH
112343: LD_INT 24
112345: PUSH
112346: LD_INT 25
112348: PUSH
112349: LD_INT 26
112351: PUSH
112352: LD_INT 28
112354: PUSH
112355: LD_INT 30
112357: PUSH
112358: LD_INT 31
112360: PUSH
112361: LD_INT 32
112363: PUSH
112364: LD_INT 36
112366: PUSH
112367: EMPTY
112368: LIST
112369: LIST
112370: LIST
112371: LIST
112372: LIST
112373: LIST
112374: LIST
112375: LIST
112376: LIST
112377: LIST
112378: LIST
112379: LIST
112380: LIST
112381: LIST
112382: LIST
112383: LIST
112384: LIST
112385: LIST
112386: LIST
112387: LIST
112388: LIST
112389: LIST
112390: LIST
112391: LIST
112392: LIST
112393: LIST
112394: LIST
112395: LIST
112396: LIST
112397: PUSH
112398: LD_INT 101
112400: PUSH
112401: LD_INT 102
112403: PUSH
112404: LD_INT 103
112406: PUSH
112407: LD_INT 104
112409: PUSH
112410: LD_INT 105
112412: PUSH
112413: LD_INT 106
112415: PUSH
112416: LD_INT 107
112418: PUSH
112419: LD_INT 108
112421: PUSH
112422: LD_INT 109
112424: PUSH
112425: LD_INT 110
112427: PUSH
112428: LD_INT 111
112430: PUSH
112431: LD_INT 112
112433: PUSH
112434: LD_INT 114
112436: PUSH
112437: LD_INT 116
112439: PUSH
112440: LD_INT 117
112442: PUSH
112443: LD_INT 118
112445: PUSH
112446: EMPTY
112447: LIST
112448: LIST
112449: LIST
112450: LIST
112451: LIST
112452: LIST
112453: LIST
112454: LIST
112455: LIST
112456: LIST
112457: LIST
112458: LIST
112459: LIST
112460: LIST
112461: LIST
112462: LIST
112463: PUSH
112464: EMPTY
112465: LIST
112466: LIST
112467: ST_TO_ADDR
112468: GO 114363
112470: LD_INT 11
112472: DOUBLE
112473: EQUAL
112474: IFTRUE 112478
112476: GO 112682
112478: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
112479: LD_ADDR_VAR 0 2
112483: PUSH
112484: LD_INT 2
112486: PUSH
112487: LD_INT 3
112489: PUSH
112490: LD_INT 4
112492: PUSH
112493: LD_INT 5
112495: PUSH
112496: LD_INT 6
112498: PUSH
112499: LD_INT 7
112501: PUSH
112502: LD_INT 8
112504: PUSH
112505: LD_INT 9
112507: PUSH
112508: LD_INT 10
112510: PUSH
112511: LD_INT 11
112513: PUSH
112514: LD_INT 12
112516: PUSH
112517: LD_INT 13
112519: PUSH
112520: LD_INT 14
112522: PUSH
112523: LD_INT 15
112525: PUSH
112526: LD_INT 16
112528: PUSH
112529: LD_INT 17
112531: PUSH
112532: LD_INT 18
112534: PUSH
112535: LD_INT 19
112537: PUSH
112538: LD_INT 20
112540: PUSH
112541: LD_INT 21
112543: PUSH
112544: LD_INT 22
112546: PUSH
112547: LD_INT 23
112549: PUSH
112550: LD_INT 24
112552: PUSH
112553: LD_INT 25
112555: PUSH
112556: LD_INT 26
112558: PUSH
112559: LD_INT 28
112561: PUSH
112562: LD_INT 30
112564: PUSH
112565: LD_INT 31
112567: PUSH
112568: LD_INT 32
112570: PUSH
112571: LD_INT 34
112573: PUSH
112574: LD_INT 36
112576: PUSH
112577: EMPTY
112578: LIST
112579: LIST
112580: LIST
112581: LIST
112582: LIST
112583: LIST
112584: LIST
112585: LIST
112586: LIST
112587: LIST
112588: LIST
112589: LIST
112590: LIST
112591: LIST
112592: LIST
112593: LIST
112594: LIST
112595: LIST
112596: LIST
112597: LIST
112598: LIST
112599: LIST
112600: LIST
112601: LIST
112602: LIST
112603: LIST
112604: LIST
112605: LIST
112606: LIST
112607: LIST
112608: LIST
112609: PUSH
112610: LD_INT 101
112612: PUSH
112613: LD_INT 102
112615: PUSH
112616: LD_INT 103
112618: PUSH
112619: LD_INT 104
112621: PUSH
112622: LD_INT 105
112624: PUSH
112625: LD_INT 106
112627: PUSH
112628: LD_INT 107
112630: PUSH
112631: LD_INT 108
112633: PUSH
112634: LD_INT 109
112636: PUSH
112637: LD_INT 110
112639: PUSH
112640: LD_INT 111
112642: PUSH
112643: LD_INT 112
112645: PUSH
112646: LD_INT 114
112648: PUSH
112649: LD_INT 116
112651: PUSH
112652: LD_INT 117
112654: PUSH
112655: LD_INT 118
112657: PUSH
112658: EMPTY
112659: LIST
112660: LIST
112661: LIST
112662: LIST
112663: LIST
112664: LIST
112665: LIST
112666: LIST
112667: LIST
112668: LIST
112669: LIST
112670: LIST
112671: LIST
112672: LIST
112673: LIST
112674: LIST
112675: PUSH
112676: EMPTY
112677: LIST
112678: LIST
112679: ST_TO_ADDR
112680: GO 114363
112682: LD_INT 12
112684: DOUBLE
112685: EQUAL
112686: IFTRUE 112690
112688: GO 112910
112690: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
112691: LD_ADDR_VAR 0 2
112695: PUSH
112696: LD_INT 1
112698: PUSH
112699: LD_INT 2
112701: PUSH
112702: LD_INT 3
112704: PUSH
112705: LD_INT 4
112707: PUSH
112708: LD_INT 5
112710: PUSH
112711: LD_INT 6
112713: PUSH
112714: LD_INT 7
112716: PUSH
112717: LD_INT 8
112719: PUSH
112720: LD_INT 9
112722: PUSH
112723: LD_INT 10
112725: PUSH
112726: LD_INT 11
112728: PUSH
112729: LD_INT 12
112731: PUSH
112732: LD_INT 13
112734: PUSH
112735: LD_INT 14
112737: PUSH
112738: LD_INT 15
112740: PUSH
112741: LD_INT 16
112743: PUSH
112744: LD_INT 17
112746: PUSH
112747: LD_INT 18
112749: PUSH
112750: LD_INT 19
112752: PUSH
112753: LD_INT 20
112755: PUSH
112756: LD_INT 21
112758: PUSH
112759: LD_INT 22
112761: PUSH
112762: LD_INT 23
112764: PUSH
112765: LD_INT 24
112767: PUSH
112768: LD_INT 25
112770: PUSH
112771: LD_INT 26
112773: PUSH
112774: LD_INT 27
112776: PUSH
112777: LD_INT 28
112779: PUSH
112780: LD_INT 30
112782: PUSH
112783: LD_INT 31
112785: PUSH
112786: LD_INT 32
112788: PUSH
112789: LD_INT 33
112791: PUSH
112792: LD_INT 34
112794: PUSH
112795: LD_INT 36
112797: PUSH
112798: EMPTY
112799: LIST
112800: LIST
112801: LIST
112802: LIST
112803: LIST
112804: LIST
112805: LIST
112806: LIST
112807: LIST
112808: LIST
112809: LIST
112810: LIST
112811: LIST
112812: LIST
112813: LIST
112814: LIST
112815: LIST
112816: LIST
112817: LIST
112818: LIST
112819: LIST
112820: LIST
112821: LIST
112822: LIST
112823: LIST
112824: LIST
112825: LIST
112826: LIST
112827: LIST
112828: LIST
112829: LIST
112830: LIST
112831: LIST
112832: LIST
112833: PUSH
112834: LD_INT 101
112836: PUSH
112837: LD_INT 102
112839: PUSH
112840: LD_INT 103
112842: PUSH
112843: LD_INT 104
112845: PUSH
112846: LD_INT 105
112848: PUSH
112849: LD_INT 106
112851: PUSH
112852: LD_INT 107
112854: PUSH
112855: LD_INT 108
112857: PUSH
112858: LD_INT 109
112860: PUSH
112861: LD_INT 110
112863: PUSH
112864: LD_INT 111
112866: PUSH
112867: LD_INT 112
112869: PUSH
112870: LD_INT 113
112872: PUSH
112873: LD_INT 114
112875: PUSH
112876: LD_INT 116
112878: PUSH
112879: LD_INT 117
112881: PUSH
112882: LD_INT 118
112884: PUSH
112885: EMPTY
112886: LIST
112887: LIST
112888: LIST
112889: LIST
112890: LIST
112891: LIST
112892: LIST
112893: LIST
112894: LIST
112895: LIST
112896: LIST
112897: LIST
112898: LIST
112899: LIST
112900: LIST
112901: LIST
112902: LIST
112903: PUSH
112904: EMPTY
112905: LIST
112906: LIST
112907: ST_TO_ADDR
112908: GO 114363
112910: LD_INT 13
112912: DOUBLE
112913: EQUAL
112914: IFTRUE 112918
112916: GO 113126
112918: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
112919: LD_ADDR_VAR 0 2
112923: PUSH
112924: LD_INT 1
112926: PUSH
112927: LD_INT 2
112929: PUSH
112930: LD_INT 3
112932: PUSH
112933: LD_INT 4
112935: PUSH
112936: LD_INT 5
112938: PUSH
112939: LD_INT 8
112941: PUSH
112942: LD_INT 9
112944: PUSH
112945: LD_INT 10
112947: PUSH
112948: LD_INT 11
112950: PUSH
112951: LD_INT 12
112953: PUSH
112954: LD_INT 14
112956: PUSH
112957: LD_INT 15
112959: PUSH
112960: LD_INT 16
112962: PUSH
112963: LD_INT 17
112965: PUSH
112966: LD_INT 18
112968: PUSH
112969: LD_INT 19
112971: PUSH
112972: LD_INT 20
112974: PUSH
112975: LD_INT 21
112977: PUSH
112978: LD_INT 22
112980: PUSH
112981: LD_INT 23
112983: PUSH
112984: LD_INT 24
112986: PUSH
112987: LD_INT 25
112989: PUSH
112990: LD_INT 26
112992: PUSH
112993: LD_INT 27
112995: PUSH
112996: LD_INT 28
112998: PUSH
112999: LD_INT 30
113001: PUSH
113002: LD_INT 31
113004: PUSH
113005: LD_INT 32
113007: PUSH
113008: LD_INT 33
113010: PUSH
113011: LD_INT 34
113013: PUSH
113014: LD_INT 36
113016: PUSH
113017: EMPTY
113018: LIST
113019: LIST
113020: LIST
113021: LIST
113022: LIST
113023: LIST
113024: LIST
113025: LIST
113026: LIST
113027: LIST
113028: LIST
113029: LIST
113030: LIST
113031: LIST
113032: LIST
113033: LIST
113034: LIST
113035: LIST
113036: LIST
113037: LIST
113038: LIST
113039: LIST
113040: LIST
113041: LIST
113042: LIST
113043: LIST
113044: LIST
113045: LIST
113046: LIST
113047: LIST
113048: LIST
113049: PUSH
113050: LD_INT 101
113052: PUSH
113053: LD_INT 102
113055: PUSH
113056: LD_INT 103
113058: PUSH
113059: LD_INT 104
113061: PUSH
113062: LD_INT 105
113064: PUSH
113065: LD_INT 106
113067: PUSH
113068: LD_INT 107
113070: PUSH
113071: LD_INT 108
113073: PUSH
113074: LD_INT 109
113076: PUSH
113077: LD_INT 110
113079: PUSH
113080: LD_INT 111
113082: PUSH
113083: LD_INT 112
113085: PUSH
113086: LD_INT 113
113088: PUSH
113089: LD_INT 114
113091: PUSH
113092: LD_INT 116
113094: PUSH
113095: LD_INT 117
113097: PUSH
113098: LD_INT 118
113100: PUSH
113101: EMPTY
113102: LIST
113103: LIST
113104: LIST
113105: LIST
113106: LIST
113107: LIST
113108: LIST
113109: LIST
113110: LIST
113111: LIST
113112: LIST
113113: LIST
113114: LIST
113115: LIST
113116: LIST
113117: LIST
113118: LIST
113119: PUSH
113120: EMPTY
113121: LIST
113122: LIST
113123: ST_TO_ADDR
113124: GO 114363
113126: LD_INT 14
113128: DOUBLE
113129: EQUAL
113130: IFTRUE 113134
113132: GO 113358
113134: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
113135: LD_ADDR_VAR 0 2
113139: PUSH
113140: LD_INT 1
113142: PUSH
113143: LD_INT 2
113145: PUSH
113146: LD_INT 3
113148: PUSH
113149: LD_INT 4
113151: PUSH
113152: LD_INT 5
113154: PUSH
113155: LD_INT 6
113157: PUSH
113158: LD_INT 7
113160: PUSH
113161: LD_INT 8
113163: PUSH
113164: LD_INT 9
113166: PUSH
113167: LD_INT 10
113169: PUSH
113170: LD_INT 11
113172: PUSH
113173: LD_INT 12
113175: PUSH
113176: LD_INT 13
113178: PUSH
113179: LD_INT 14
113181: PUSH
113182: LD_INT 15
113184: PUSH
113185: LD_INT 16
113187: PUSH
113188: LD_INT 17
113190: PUSH
113191: LD_INT 18
113193: PUSH
113194: LD_INT 19
113196: PUSH
113197: LD_INT 20
113199: PUSH
113200: LD_INT 21
113202: PUSH
113203: LD_INT 22
113205: PUSH
113206: LD_INT 23
113208: PUSH
113209: LD_INT 24
113211: PUSH
113212: LD_INT 25
113214: PUSH
113215: LD_INT 26
113217: PUSH
113218: LD_INT 27
113220: PUSH
113221: LD_INT 28
113223: PUSH
113224: LD_INT 29
113226: PUSH
113227: LD_INT 30
113229: PUSH
113230: LD_INT 31
113232: PUSH
113233: LD_INT 32
113235: PUSH
113236: LD_INT 33
113238: PUSH
113239: LD_INT 34
113241: PUSH
113242: LD_INT 36
113244: PUSH
113245: EMPTY
113246: LIST
113247: LIST
113248: LIST
113249: LIST
113250: LIST
113251: LIST
113252: LIST
113253: LIST
113254: LIST
113255: LIST
113256: LIST
113257: LIST
113258: LIST
113259: LIST
113260: LIST
113261: LIST
113262: LIST
113263: LIST
113264: LIST
113265: LIST
113266: LIST
113267: LIST
113268: LIST
113269: LIST
113270: LIST
113271: LIST
113272: LIST
113273: LIST
113274: LIST
113275: LIST
113276: LIST
113277: LIST
113278: LIST
113279: LIST
113280: LIST
113281: PUSH
113282: LD_INT 101
113284: PUSH
113285: LD_INT 102
113287: PUSH
113288: LD_INT 103
113290: PUSH
113291: LD_INT 104
113293: PUSH
113294: LD_INT 105
113296: PUSH
113297: LD_INT 106
113299: PUSH
113300: LD_INT 107
113302: PUSH
113303: LD_INT 108
113305: PUSH
113306: LD_INT 109
113308: PUSH
113309: LD_INT 110
113311: PUSH
113312: LD_INT 111
113314: PUSH
113315: LD_INT 112
113317: PUSH
113318: LD_INT 113
113320: PUSH
113321: LD_INT 114
113323: PUSH
113324: LD_INT 116
113326: PUSH
113327: LD_INT 117
113329: PUSH
113330: LD_INT 118
113332: PUSH
113333: EMPTY
113334: LIST
113335: LIST
113336: LIST
113337: LIST
113338: LIST
113339: LIST
113340: LIST
113341: LIST
113342: LIST
113343: LIST
113344: LIST
113345: LIST
113346: LIST
113347: LIST
113348: LIST
113349: LIST
113350: LIST
113351: PUSH
113352: EMPTY
113353: LIST
113354: LIST
113355: ST_TO_ADDR
113356: GO 114363
113358: LD_INT 15
113360: DOUBLE
113361: EQUAL
113362: IFTRUE 113366
113364: GO 113590
113366: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
113367: LD_ADDR_VAR 0 2
113371: PUSH
113372: LD_INT 1
113374: PUSH
113375: LD_INT 2
113377: PUSH
113378: LD_INT 3
113380: PUSH
113381: LD_INT 4
113383: PUSH
113384: LD_INT 5
113386: PUSH
113387: LD_INT 6
113389: PUSH
113390: LD_INT 7
113392: PUSH
113393: LD_INT 8
113395: PUSH
113396: LD_INT 9
113398: PUSH
113399: LD_INT 10
113401: PUSH
113402: LD_INT 11
113404: PUSH
113405: LD_INT 12
113407: PUSH
113408: LD_INT 13
113410: PUSH
113411: LD_INT 14
113413: PUSH
113414: LD_INT 15
113416: PUSH
113417: LD_INT 16
113419: PUSH
113420: LD_INT 17
113422: PUSH
113423: LD_INT 18
113425: PUSH
113426: LD_INT 19
113428: PUSH
113429: LD_INT 20
113431: PUSH
113432: LD_INT 21
113434: PUSH
113435: LD_INT 22
113437: PUSH
113438: LD_INT 23
113440: PUSH
113441: LD_INT 24
113443: PUSH
113444: LD_INT 25
113446: PUSH
113447: LD_INT 26
113449: PUSH
113450: LD_INT 27
113452: PUSH
113453: LD_INT 28
113455: PUSH
113456: LD_INT 29
113458: PUSH
113459: LD_INT 30
113461: PUSH
113462: LD_INT 31
113464: PUSH
113465: LD_INT 32
113467: PUSH
113468: LD_INT 33
113470: PUSH
113471: LD_INT 34
113473: PUSH
113474: LD_INT 36
113476: PUSH
113477: EMPTY
113478: LIST
113479: LIST
113480: LIST
113481: LIST
113482: LIST
113483: LIST
113484: LIST
113485: LIST
113486: LIST
113487: LIST
113488: LIST
113489: LIST
113490: LIST
113491: LIST
113492: LIST
113493: LIST
113494: LIST
113495: LIST
113496: LIST
113497: LIST
113498: LIST
113499: LIST
113500: LIST
113501: LIST
113502: LIST
113503: LIST
113504: LIST
113505: LIST
113506: LIST
113507: LIST
113508: LIST
113509: LIST
113510: LIST
113511: LIST
113512: LIST
113513: PUSH
113514: LD_INT 101
113516: PUSH
113517: LD_INT 102
113519: PUSH
113520: LD_INT 103
113522: PUSH
113523: LD_INT 104
113525: PUSH
113526: LD_INT 105
113528: PUSH
113529: LD_INT 106
113531: PUSH
113532: LD_INT 107
113534: PUSH
113535: LD_INT 108
113537: PUSH
113538: LD_INT 109
113540: PUSH
113541: LD_INT 110
113543: PUSH
113544: LD_INT 111
113546: PUSH
113547: LD_INT 112
113549: PUSH
113550: LD_INT 113
113552: PUSH
113553: LD_INT 114
113555: PUSH
113556: LD_INT 116
113558: PUSH
113559: LD_INT 117
113561: PUSH
113562: LD_INT 118
113564: PUSH
113565: EMPTY
113566: LIST
113567: LIST
113568: LIST
113569: LIST
113570: LIST
113571: LIST
113572: LIST
113573: LIST
113574: LIST
113575: LIST
113576: LIST
113577: LIST
113578: LIST
113579: LIST
113580: LIST
113581: LIST
113582: LIST
113583: PUSH
113584: EMPTY
113585: LIST
113586: LIST
113587: ST_TO_ADDR
113588: GO 114363
113590: LD_INT 16
113592: DOUBLE
113593: EQUAL
113594: IFTRUE 113598
113596: GO 113734
113598: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
113599: LD_ADDR_VAR 0 2
113603: PUSH
113604: LD_INT 2
113606: PUSH
113607: LD_INT 4
113609: PUSH
113610: LD_INT 5
113612: PUSH
113613: LD_INT 7
113615: PUSH
113616: LD_INT 11
113618: PUSH
113619: LD_INT 12
113621: PUSH
113622: LD_INT 15
113624: PUSH
113625: LD_INT 16
113627: PUSH
113628: LD_INT 20
113630: PUSH
113631: LD_INT 21
113633: PUSH
113634: LD_INT 22
113636: PUSH
113637: LD_INT 23
113639: PUSH
113640: LD_INT 25
113642: PUSH
113643: LD_INT 26
113645: PUSH
113646: LD_INT 30
113648: PUSH
113649: LD_INT 31
113651: PUSH
113652: LD_INT 32
113654: PUSH
113655: LD_INT 33
113657: PUSH
113658: LD_INT 34
113660: PUSH
113661: EMPTY
113662: LIST
113663: LIST
113664: LIST
113665: LIST
113666: LIST
113667: LIST
113668: LIST
113669: LIST
113670: LIST
113671: LIST
113672: LIST
113673: LIST
113674: LIST
113675: LIST
113676: LIST
113677: LIST
113678: LIST
113679: LIST
113680: LIST
113681: PUSH
113682: LD_INT 101
113684: PUSH
113685: LD_INT 102
113687: PUSH
113688: LD_INT 103
113690: PUSH
113691: LD_INT 106
113693: PUSH
113694: LD_INT 108
113696: PUSH
113697: LD_INT 112
113699: PUSH
113700: LD_INT 113
113702: PUSH
113703: LD_INT 114
113705: PUSH
113706: LD_INT 116
113708: PUSH
113709: LD_INT 117
113711: PUSH
113712: LD_INT 118
113714: PUSH
113715: EMPTY
113716: LIST
113717: LIST
113718: LIST
113719: LIST
113720: LIST
113721: LIST
113722: LIST
113723: LIST
113724: LIST
113725: LIST
113726: LIST
113727: PUSH
113728: EMPTY
113729: LIST
113730: LIST
113731: ST_TO_ADDR
113732: GO 114363
113734: LD_INT 17
113736: DOUBLE
113737: EQUAL
113738: IFTRUE 113742
113740: GO 113966
113742: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
113743: LD_ADDR_VAR 0 2
113747: PUSH
113748: LD_INT 1
113750: PUSH
113751: LD_INT 2
113753: PUSH
113754: LD_INT 3
113756: PUSH
113757: LD_INT 4
113759: PUSH
113760: LD_INT 5
113762: PUSH
113763: LD_INT 6
113765: PUSH
113766: LD_INT 7
113768: PUSH
113769: LD_INT 8
113771: PUSH
113772: LD_INT 9
113774: PUSH
113775: LD_INT 10
113777: PUSH
113778: LD_INT 11
113780: PUSH
113781: LD_INT 12
113783: PUSH
113784: LD_INT 13
113786: PUSH
113787: LD_INT 14
113789: PUSH
113790: LD_INT 15
113792: PUSH
113793: LD_INT 16
113795: PUSH
113796: LD_INT 17
113798: PUSH
113799: LD_INT 18
113801: PUSH
113802: LD_INT 19
113804: PUSH
113805: LD_INT 20
113807: PUSH
113808: LD_INT 21
113810: PUSH
113811: LD_INT 22
113813: PUSH
113814: LD_INT 23
113816: PUSH
113817: LD_INT 24
113819: PUSH
113820: LD_INT 25
113822: PUSH
113823: LD_INT 26
113825: PUSH
113826: LD_INT 27
113828: PUSH
113829: LD_INT 28
113831: PUSH
113832: LD_INT 29
113834: PUSH
113835: LD_INT 30
113837: PUSH
113838: LD_INT 31
113840: PUSH
113841: LD_INT 32
113843: PUSH
113844: LD_INT 33
113846: PUSH
113847: LD_INT 34
113849: PUSH
113850: LD_INT 36
113852: PUSH
113853: EMPTY
113854: LIST
113855: LIST
113856: LIST
113857: LIST
113858: LIST
113859: LIST
113860: LIST
113861: LIST
113862: LIST
113863: LIST
113864: LIST
113865: LIST
113866: LIST
113867: LIST
113868: LIST
113869: LIST
113870: LIST
113871: LIST
113872: LIST
113873: LIST
113874: LIST
113875: LIST
113876: LIST
113877: LIST
113878: LIST
113879: LIST
113880: LIST
113881: LIST
113882: LIST
113883: LIST
113884: LIST
113885: LIST
113886: LIST
113887: LIST
113888: LIST
113889: PUSH
113890: LD_INT 101
113892: PUSH
113893: LD_INT 102
113895: PUSH
113896: LD_INT 103
113898: PUSH
113899: LD_INT 104
113901: PUSH
113902: LD_INT 105
113904: PUSH
113905: LD_INT 106
113907: PUSH
113908: LD_INT 107
113910: PUSH
113911: LD_INT 108
113913: PUSH
113914: LD_INT 109
113916: PUSH
113917: LD_INT 110
113919: PUSH
113920: LD_INT 111
113922: PUSH
113923: LD_INT 112
113925: PUSH
113926: LD_INT 113
113928: PUSH
113929: LD_INT 114
113931: PUSH
113932: LD_INT 116
113934: PUSH
113935: LD_INT 117
113937: PUSH
113938: LD_INT 118
113940: PUSH
113941: EMPTY
113942: LIST
113943: LIST
113944: LIST
113945: LIST
113946: LIST
113947: LIST
113948: LIST
113949: LIST
113950: LIST
113951: LIST
113952: LIST
113953: LIST
113954: LIST
113955: LIST
113956: LIST
113957: LIST
113958: LIST
113959: PUSH
113960: EMPTY
113961: LIST
113962: LIST
113963: ST_TO_ADDR
113964: GO 114363
113966: LD_INT 18
113968: DOUBLE
113969: EQUAL
113970: IFTRUE 113974
113972: GO 114122
113974: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
113975: LD_ADDR_VAR 0 2
113979: PUSH
113980: LD_INT 2
113982: PUSH
113983: LD_INT 4
113985: PUSH
113986: LD_INT 5
113988: PUSH
113989: LD_INT 7
113991: PUSH
113992: LD_INT 11
113994: PUSH
113995: LD_INT 12
113997: PUSH
113998: LD_INT 15
114000: PUSH
114001: LD_INT 16
114003: PUSH
114004: LD_INT 20
114006: PUSH
114007: LD_INT 21
114009: PUSH
114010: LD_INT 22
114012: PUSH
114013: LD_INT 23
114015: PUSH
114016: LD_INT 25
114018: PUSH
114019: LD_INT 26
114021: PUSH
114022: LD_INT 30
114024: PUSH
114025: LD_INT 31
114027: PUSH
114028: LD_INT 32
114030: PUSH
114031: LD_INT 33
114033: PUSH
114034: LD_INT 34
114036: PUSH
114037: LD_INT 35
114039: PUSH
114040: LD_INT 36
114042: PUSH
114043: EMPTY
114044: LIST
114045: LIST
114046: LIST
114047: LIST
114048: LIST
114049: LIST
114050: LIST
114051: LIST
114052: LIST
114053: LIST
114054: LIST
114055: LIST
114056: LIST
114057: LIST
114058: LIST
114059: LIST
114060: LIST
114061: LIST
114062: LIST
114063: LIST
114064: LIST
114065: PUSH
114066: LD_INT 101
114068: PUSH
114069: LD_INT 102
114071: PUSH
114072: LD_INT 103
114074: PUSH
114075: LD_INT 106
114077: PUSH
114078: LD_INT 108
114080: PUSH
114081: LD_INT 112
114083: PUSH
114084: LD_INT 113
114086: PUSH
114087: LD_INT 114
114089: PUSH
114090: LD_INT 115
114092: PUSH
114093: LD_INT 116
114095: PUSH
114096: LD_INT 117
114098: PUSH
114099: LD_INT 118
114101: PUSH
114102: EMPTY
114103: LIST
114104: LIST
114105: LIST
114106: LIST
114107: LIST
114108: LIST
114109: LIST
114110: LIST
114111: LIST
114112: LIST
114113: LIST
114114: LIST
114115: PUSH
114116: EMPTY
114117: LIST
114118: LIST
114119: ST_TO_ADDR
114120: GO 114363
114122: LD_INT 19
114124: DOUBLE
114125: EQUAL
114126: IFTRUE 114130
114128: GO 114362
114130: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
114131: LD_ADDR_VAR 0 2
114135: PUSH
114136: LD_INT 1
114138: PUSH
114139: LD_INT 2
114141: PUSH
114142: LD_INT 3
114144: PUSH
114145: LD_INT 4
114147: PUSH
114148: LD_INT 5
114150: PUSH
114151: LD_INT 6
114153: PUSH
114154: LD_INT 7
114156: PUSH
114157: LD_INT 8
114159: PUSH
114160: LD_INT 9
114162: PUSH
114163: LD_INT 10
114165: PUSH
114166: LD_INT 11
114168: PUSH
114169: LD_INT 12
114171: PUSH
114172: LD_INT 13
114174: PUSH
114175: LD_INT 14
114177: PUSH
114178: LD_INT 15
114180: PUSH
114181: LD_INT 16
114183: PUSH
114184: LD_INT 17
114186: PUSH
114187: LD_INT 18
114189: PUSH
114190: LD_INT 19
114192: PUSH
114193: LD_INT 20
114195: PUSH
114196: LD_INT 21
114198: PUSH
114199: LD_INT 22
114201: PUSH
114202: LD_INT 23
114204: PUSH
114205: LD_INT 24
114207: PUSH
114208: LD_INT 25
114210: PUSH
114211: LD_INT 26
114213: PUSH
114214: LD_INT 27
114216: PUSH
114217: LD_INT 28
114219: PUSH
114220: LD_INT 29
114222: PUSH
114223: LD_INT 30
114225: PUSH
114226: LD_INT 31
114228: PUSH
114229: LD_INT 32
114231: PUSH
114232: LD_INT 33
114234: PUSH
114235: LD_INT 34
114237: PUSH
114238: LD_INT 35
114240: PUSH
114241: LD_INT 36
114243: PUSH
114244: EMPTY
114245: LIST
114246: LIST
114247: LIST
114248: LIST
114249: LIST
114250: LIST
114251: LIST
114252: LIST
114253: LIST
114254: LIST
114255: LIST
114256: LIST
114257: LIST
114258: LIST
114259: LIST
114260: LIST
114261: LIST
114262: LIST
114263: LIST
114264: LIST
114265: LIST
114266: LIST
114267: LIST
114268: LIST
114269: LIST
114270: LIST
114271: LIST
114272: LIST
114273: LIST
114274: LIST
114275: LIST
114276: LIST
114277: LIST
114278: LIST
114279: LIST
114280: LIST
114281: PUSH
114282: LD_INT 101
114284: PUSH
114285: LD_INT 102
114287: PUSH
114288: LD_INT 103
114290: PUSH
114291: LD_INT 104
114293: PUSH
114294: LD_INT 105
114296: PUSH
114297: LD_INT 106
114299: PUSH
114300: LD_INT 107
114302: PUSH
114303: LD_INT 108
114305: PUSH
114306: LD_INT 109
114308: PUSH
114309: LD_INT 110
114311: PUSH
114312: LD_INT 111
114314: PUSH
114315: LD_INT 112
114317: PUSH
114318: LD_INT 113
114320: PUSH
114321: LD_INT 114
114323: PUSH
114324: LD_INT 115
114326: PUSH
114327: LD_INT 116
114329: PUSH
114330: LD_INT 117
114332: PUSH
114333: LD_INT 118
114335: PUSH
114336: EMPTY
114337: LIST
114338: LIST
114339: LIST
114340: LIST
114341: LIST
114342: LIST
114343: LIST
114344: LIST
114345: LIST
114346: LIST
114347: LIST
114348: LIST
114349: LIST
114350: LIST
114351: LIST
114352: LIST
114353: LIST
114354: LIST
114355: PUSH
114356: EMPTY
114357: LIST
114358: LIST
114359: ST_TO_ADDR
114360: GO 114363
114362: POP
// end else
114363: GO 114594
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
114365: LD_ADDR_VAR 0 2
114369: PUSH
114370: LD_INT 1
114372: PUSH
114373: LD_INT 2
114375: PUSH
114376: LD_INT 3
114378: PUSH
114379: LD_INT 4
114381: PUSH
114382: LD_INT 5
114384: PUSH
114385: LD_INT 6
114387: PUSH
114388: LD_INT 7
114390: PUSH
114391: LD_INT 8
114393: PUSH
114394: LD_INT 9
114396: PUSH
114397: LD_INT 10
114399: PUSH
114400: LD_INT 11
114402: PUSH
114403: LD_INT 12
114405: PUSH
114406: LD_INT 13
114408: PUSH
114409: LD_INT 14
114411: PUSH
114412: LD_INT 15
114414: PUSH
114415: LD_INT 16
114417: PUSH
114418: LD_INT 17
114420: PUSH
114421: LD_INT 18
114423: PUSH
114424: LD_INT 19
114426: PUSH
114427: LD_INT 20
114429: PUSH
114430: LD_INT 21
114432: PUSH
114433: LD_INT 22
114435: PUSH
114436: LD_INT 23
114438: PUSH
114439: LD_INT 24
114441: PUSH
114442: LD_INT 25
114444: PUSH
114445: LD_INT 26
114447: PUSH
114448: LD_INT 27
114450: PUSH
114451: LD_INT 28
114453: PUSH
114454: LD_INT 29
114456: PUSH
114457: LD_INT 30
114459: PUSH
114460: LD_INT 31
114462: PUSH
114463: LD_INT 32
114465: PUSH
114466: LD_INT 33
114468: PUSH
114469: LD_INT 34
114471: PUSH
114472: LD_INT 35
114474: PUSH
114475: LD_INT 36
114477: PUSH
114478: EMPTY
114479: LIST
114480: LIST
114481: LIST
114482: LIST
114483: LIST
114484: LIST
114485: LIST
114486: LIST
114487: LIST
114488: LIST
114489: LIST
114490: LIST
114491: LIST
114492: LIST
114493: LIST
114494: LIST
114495: LIST
114496: LIST
114497: LIST
114498: LIST
114499: LIST
114500: LIST
114501: LIST
114502: LIST
114503: LIST
114504: LIST
114505: LIST
114506: LIST
114507: LIST
114508: LIST
114509: LIST
114510: LIST
114511: LIST
114512: LIST
114513: LIST
114514: LIST
114515: PUSH
114516: LD_INT 101
114518: PUSH
114519: LD_INT 102
114521: PUSH
114522: LD_INT 103
114524: PUSH
114525: LD_INT 104
114527: PUSH
114528: LD_INT 105
114530: PUSH
114531: LD_INT 106
114533: PUSH
114534: LD_INT 107
114536: PUSH
114537: LD_INT 108
114539: PUSH
114540: LD_INT 109
114542: PUSH
114543: LD_INT 110
114545: PUSH
114546: LD_INT 111
114548: PUSH
114549: LD_INT 112
114551: PUSH
114552: LD_INT 113
114554: PUSH
114555: LD_INT 114
114557: PUSH
114558: LD_INT 115
114560: PUSH
114561: LD_INT 116
114563: PUSH
114564: LD_INT 117
114566: PUSH
114567: LD_INT 118
114569: PUSH
114570: EMPTY
114571: LIST
114572: LIST
114573: LIST
114574: LIST
114575: LIST
114576: LIST
114577: LIST
114578: LIST
114579: LIST
114580: LIST
114581: LIST
114582: LIST
114583: LIST
114584: LIST
114585: LIST
114586: LIST
114587: LIST
114588: LIST
114589: PUSH
114590: EMPTY
114591: LIST
114592: LIST
114593: ST_TO_ADDR
// if result then
114594: LD_VAR 0 2
114598: IFFALSE 115384
// begin normal :=  ;
114600: LD_ADDR_VAR 0 5
114604: PUSH
114605: LD_STRING 
114607: ST_TO_ADDR
// hardcore :=  ;
114608: LD_ADDR_VAR 0 6
114612: PUSH
114613: LD_STRING 
114615: ST_TO_ADDR
// active :=  ;
114616: LD_ADDR_VAR 0 7
114620: PUSH
114621: LD_STRING 
114623: ST_TO_ADDR
// for i = 1 to normalCounter do
114624: LD_ADDR_VAR 0 8
114628: PUSH
114629: DOUBLE
114630: LD_INT 1
114632: DEC
114633: ST_TO_ADDR
114634: LD_EXP 147
114638: PUSH
114639: FOR_TO
114640: IFFALSE 114741
// begin tmp := 0 ;
114642: LD_ADDR_VAR 0 3
114646: PUSH
114647: LD_STRING 0
114649: ST_TO_ADDR
// if result [ 1 ] then
114650: LD_VAR 0 2
114654: PUSH
114655: LD_INT 1
114657: ARRAY
114658: IFFALSE 114723
// if result [ 1 ] [ 1 ] = i then
114660: LD_VAR 0 2
114664: PUSH
114665: LD_INT 1
114667: ARRAY
114668: PUSH
114669: LD_INT 1
114671: ARRAY
114672: PUSH
114673: LD_VAR 0 8
114677: EQUAL
114678: IFFALSE 114723
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
114680: LD_ADDR_VAR 0 2
114684: PUSH
114685: LD_VAR 0 2
114689: PPUSH
114690: LD_INT 1
114692: PPUSH
114693: LD_VAR 0 2
114697: PUSH
114698: LD_INT 1
114700: ARRAY
114701: PPUSH
114702: LD_INT 1
114704: PPUSH
114705: CALL_OW 3
114709: PPUSH
114710: CALL_OW 1
114714: ST_TO_ADDR
// tmp := 1 ;
114715: LD_ADDR_VAR 0 3
114719: PUSH
114720: LD_STRING 1
114722: ST_TO_ADDR
// end ; normal := normal & tmp ;
114723: LD_ADDR_VAR 0 5
114727: PUSH
114728: LD_VAR 0 5
114732: PUSH
114733: LD_VAR 0 3
114737: STR
114738: ST_TO_ADDR
// end ;
114739: GO 114639
114741: POP
114742: POP
// for i = 1 to hardcoreCounter do
114743: LD_ADDR_VAR 0 8
114747: PUSH
114748: DOUBLE
114749: LD_INT 1
114751: DEC
114752: ST_TO_ADDR
114753: LD_EXP 148
114757: PUSH
114758: FOR_TO
114759: IFFALSE 114864
// begin tmp := 0 ;
114761: LD_ADDR_VAR 0 3
114765: PUSH
114766: LD_STRING 0
114768: ST_TO_ADDR
// if result [ 2 ] then
114769: LD_VAR 0 2
114773: PUSH
114774: LD_INT 2
114776: ARRAY
114777: IFFALSE 114846
// if result [ 2 ] [ 1 ] = 100 + i then
114779: LD_VAR 0 2
114783: PUSH
114784: LD_INT 2
114786: ARRAY
114787: PUSH
114788: LD_INT 1
114790: ARRAY
114791: PUSH
114792: LD_INT 100
114794: PUSH
114795: LD_VAR 0 8
114799: PLUS
114800: EQUAL
114801: IFFALSE 114846
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
114803: LD_ADDR_VAR 0 2
114807: PUSH
114808: LD_VAR 0 2
114812: PPUSH
114813: LD_INT 2
114815: PPUSH
114816: LD_VAR 0 2
114820: PUSH
114821: LD_INT 2
114823: ARRAY
114824: PPUSH
114825: LD_INT 1
114827: PPUSH
114828: CALL_OW 3
114832: PPUSH
114833: CALL_OW 1
114837: ST_TO_ADDR
// tmp := 1 ;
114838: LD_ADDR_VAR 0 3
114842: PUSH
114843: LD_STRING 1
114845: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
114846: LD_ADDR_VAR 0 6
114850: PUSH
114851: LD_VAR 0 6
114855: PUSH
114856: LD_VAR 0 3
114860: STR
114861: ST_TO_ADDR
// end ;
114862: GO 114758
114864: POP
114865: POP
// if isGameLoad then
114866: LD_VAR 0 1
114870: IFFALSE 115345
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
114872: LD_ADDR_VAR 0 4
114876: PUSH
114877: LD_EXP 151
114881: PUSH
114882: LD_EXP 150
114886: PUSH
114887: LD_EXP 152
114891: PUSH
114892: LD_EXP 149
114896: PUSH
114897: LD_EXP 153
114901: PUSH
114902: LD_EXP 154
114906: PUSH
114907: LD_EXP 155
114911: PUSH
114912: LD_EXP 156
114916: PUSH
114917: LD_EXP 157
114921: PUSH
114922: LD_EXP 158
114926: PUSH
114927: LD_EXP 159
114931: PUSH
114932: LD_EXP 160
114936: PUSH
114937: LD_EXP 161
114941: PUSH
114942: LD_EXP 162
114946: PUSH
114947: LD_EXP 170
114951: PUSH
114952: LD_EXP 171
114956: PUSH
114957: LD_EXP 172
114961: PUSH
114962: LD_EXP 173
114966: PUSH
114967: LD_EXP 175
114971: PUSH
114972: LD_EXP 176
114976: PUSH
114977: LD_EXP 177
114981: PUSH
114982: LD_EXP 180
114986: PUSH
114987: LD_EXP 182
114991: PUSH
114992: LD_EXP 183
114996: PUSH
114997: LD_EXP 184
115001: PUSH
115002: LD_EXP 186
115006: PUSH
115007: LD_EXP 187
115011: PUSH
115012: LD_EXP 190
115016: PUSH
115017: LD_EXP 191
115021: PUSH
115022: LD_EXP 192
115026: PUSH
115027: LD_EXP 193
115031: PUSH
115032: LD_EXP 194
115036: PUSH
115037: LD_EXP 195
115041: PUSH
115042: LD_EXP 196
115046: PUSH
115047: LD_EXP 197
115051: PUSH
115052: LD_EXP 198
115056: PUSH
115057: LD_EXP 163
115061: PUSH
115062: LD_EXP 164
115066: PUSH
115067: LD_EXP 167
115071: PUSH
115072: LD_EXP 168
115076: PUSH
115077: LD_EXP 169
115081: PUSH
115082: LD_EXP 165
115086: PUSH
115087: LD_EXP 166
115091: PUSH
115092: LD_EXP 174
115096: PUSH
115097: LD_EXP 178
115101: PUSH
115102: LD_EXP 179
115106: PUSH
115107: LD_EXP 181
115111: PUSH
115112: LD_EXP 185
115116: PUSH
115117: LD_EXP 188
115121: PUSH
115122: LD_EXP 189
115126: PUSH
115127: LD_EXP 199
115131: PUSH
115132: LD_EXP 200
115136: PUSH
115137: LD_EXP 201
115141: PUSH
115142: LD_EXP 202
115146: PUSH
115147: EMPTY
115148: LIST
115149: LIST
115150: LIST
115151: LIST
115152: LIST
115153: LIST
115154: LIST
115155: LIST
115156: LIST
115157: LIST
115158: LIST
115159: LIST
115160: LIST
115161: LIST
115162: LIST
115163: LIST
115164: LIST
115165: LIST
115166: LIST
115167: LIST
115168: LIST
115169: LIST
115170: LIST
115171: LIST
115172: LIST
115173: LIST
115174: LIST
115175: LIST
115176: LIST
115177: LIST
115178: LIST
115179: LIST
115180: LIST
115181: LIST
115182: LIST
115183: LIST
115184: LIST
115185: LIST
115186: LIST
115187: LIST
115188: LIST
115189: LIST
115190: LIST
115191: LIST
115192: LIST
115193: LIST
115194: LIST
115195: LIST
115196: LIST
115197: LIST
115198: LIST
115199: LIST
115200: LIST
115201: LIST
115202: ST_TO_ADDR
// tmp :=  ;
115203: LD_ADDR_VAR 0 3
115207: PUSH
115208: LD_STRING 
115210: ST_TO_ADDR
// for i = 1 to normalCounter do
115211: LD_ADDR_VAR 0 8
115215: PUSH
115216: DOUBLE
115217: LD_INT 1
115219: DEC
115220: ST_TO_ADDR
115221: LD_EXP 147
115225: PUSH
115226: FOR_TO
115227: IFFALSE 115263
// begin if flags [ i ] then
115229: LD_VAR 0 4
115233: PUSH
115234: LD_VAR 0 8
115238: ARRAY
115239: IFFALSE 115261
// tmp := tmp & i & ; ;
115241: LD_ADDR_VAR 0 3
115245: PUSH
115246: LD_VAR 0 3
115250: PUSH
115251: LD_VAR 0 8
115255: STR
115256: PUSH
115257: LD_STRING ;
115259: STR
115260: ST_TO_ADDR
// end ;
115261: GO 115226
115263: POP
115264: POP
// for i = 1 to hardcoreCounter do
115265: LD_ADDR_VAR 0 8
115269: PUSH
115270: DOUBLE
115271: LD_INT 1
115273: DEC
115274: ST_TO_ADDR
115275: LD_EXP 148
115279: PUSH
115280: FOR_TO
115281: IFFALSE 115327
// begin if flags [ normalCounter + i ] then
115283: LD_VAR 0 4
115287: PUSH
115288: LD_EXP 147
115292: PUSH
115293: LD_VAR 0 8
115297: PLUS
115298: ARRAY
115299: IFFALSE 115325
// tmp := tmp & ( 100 + i ) & ; ;
115301: LD_ADDR_VAR 0 3
115305: PUSH
115306: LD_VAR 0 3
115310: PUSH
115311: LD_INT 100
115313: PUSH
115314: LD_VAR 0 8
115318: PLUS
115319: STR
115320: PUSH
115321: LD_STRING ;
115323: STR
115324: ST_TO_ADDR
// end ;
115325: GO 115280
115327: POP
115328: POP
// if tmp then
115329: LD_VAR 0 3
115333: IFFALSE 115345
// active := tmp ;
115335: LD_ADDR_VAR 0 7
115339: PUSH
115340: LD_VAR 0 3
115344: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
115345: LD_STRING getStreamItemsFromMission("
115347: PUSH
115348: LD_VAR 0 5
115352: STR
115353: PUSH
115354: LD_STRING ","
115356: STR
115357: PUSH
115358: LD_VAR 0 6
115362: STR
115363: PUSH
115364: LD_STRING ","
115366: STR
115367: PUSH
115368: LD_VAR 0 7
115372: STR
115373: PUSH
115374: LD_STRING ")
115376: STR
115377: PPUSH
115378: CALL_OW 559
// end else
115382: GO 115391
// ToLua ( getStreamItemsFromMission("","","") ) ;
115384: LD_STRING getStreamItemsFromMission("","","")
115386: PPUSH
115387: CALL_OW 559
// end ;
115391: LD_VAR 0 2
115395: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
115396: LD_EXP 146
115400: PUSH
115401: LD_EXP 151
115405: AND
115406: IFFALSE 115530
115408: GO 115410
115410: DISABLE
115411: LD_INT 0
115413: PPUSH
115414: PPUSH
// begin enable ;
115415: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
115416: LD_ADDR_VAR 0 2
115420: PUSH
115421: LD_INT 22
115423: PUSH
115424: LD_OWVAR 2
115428: PUSH
115429: EMPTY
115430: LIST
115431: LIST
115432: PUSH
115433: LD_INT 2
115435: PUSH
115436: LD_INT 34
115438: PUSH
115439: LD_INT 7
115441: PUSH
115442: EMPTY
115443: LIST
115444: LIST
115445: PUSH
115446: LD_INT 34
115448: PUSH
115449: LD_INT 45
115451: PUSH
115452: EMPTY
115453: LIST
115454: LIST
115455: PUSH
115456: LD_INT 34
115458: PUSH
115459: LD_INT 28
115461: PUSH
115462: EMPTY
115463: LIST
115464: LIST
115465: PUSH
115466: LD_INT 34
115468: PUSH
115469: LD_INT 47
115471: PUSH
115472: EMPTY
115473: LIST
115474: LIST
115475: PUSH
115476: EMPTY
115477: LIST
115478: LIST
115479: LIST
115480: LIST
115481: LIST
115482: PUSH
115483: EMPTY
115484: LIST
115485: LIST
115486: PPUSH
115487: CALL_OW 69
115491: ST_TO_ADDR
// if not tmp then
115492: LD_VAR 0 2
115496: NOT
115497: IFFALSE 115501
// exit ;
115499: GO 115530
// for i in tmp do
115501: LD_ADDR_VAR 0 1
115505: PUSH
115506: LD_VAR 0 2
115510: PUSH
115511: FOR_IN
115512: IFFALSE 115528
// begin SetLives ( i , 0 ) ;
115514: LD_VAR 0 1
115518: PPUSH
115519: LD_INT 0
115521: PPUSH
115522: CALL_OW 234
// end ;
115526: GO 115511
115528: POP
115529: POP
// end ;
115530: PPOPN 2
115532: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
115533: LD_EXP 146
115537: PUSH
115538: LD_EXP 152
115542: AND
115543: IFFALSE 115627
115545: GO 115547
115547: DISABLE
115548: LD_INT 0
115550: PPUSH
115551: PPUSH
// begin enable ;
115552: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
115553: LD_ADDR_VAR 0 2
115557: PUSH
115558: LD_INT 22
115560: PUSH
115561: LD_OWVAR 2
115565: PUSH
115566: EMPTY
115567: LIST
115568: LIST
115569: PUSH
115570: LD_INT 32
115572: PUSH
115573: LD_INT 3
115575: PUSH
115576: EMPTY
115577: LIST
115578: LIST
115579: PUSH
115580: EMPTY
115581: LIST
115582: LIST
115583: PPUSH
115584: CALL_OW 69
115588: ST_TO_ADDR
// if not tmp then
115589: LD_VAR 0 2
115593: NOT
115594: IFFALSE 115598
// exit ;
115596: GO 115627
// for i in tmp do
115598: LD_ADDR_VAR 0 1
115602: PUSH
115603: LD_VAR 0 2
115607: PUSH
115608: FOR_IN
115609: IFFALSE 115625
// begin SetLives ( i , 0 ) ;
115611: LD_VAR 0 1
115615: PPUSH
115616: LD_INT 0
115618: PPUSH
115619: CALL_OW 234
// end ;
115623: GO 115608
115625: POP
115626: POP
// end ;
115627: PPOPN 2
115629: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
115630: LD_EXP 146
115634: PUSH
115635: LD_EXP 149
115639: AND
115640: IFFALSE 115733
115642: GO 115644
115644: DISABLE
115645: LD_INT 0
115647: PPUSH
// begin enable ;
115648: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
115649: LD_ADDR_VAR 0 1
115653: PUSH
115654: LD_INT 22
115656: PUSH
115657: LD_OWVAR 2
115661: PUSH
115662: EMPTY
115663: LIST
115664: LIST
115665: PUSH
115666: LD_INT 2
115668: PUSH
115669: LD_INT 25
115671: PUSH
115672: LD_INT 5
115674: PUSH
115675: EMPTY
115676: LIST
115677: LIST
115678: PUSH
115679: LD_INT 25
115681: PUSH
115682: LD_INT 9
115684: PUSH
115685: EMPTY
115686: LIST
115687: LIST
115688: PUSH
115689: LD_INT 25
115691: PUSH
115692: LD_INT 8
115694: PUSH
115695: EMPTY
115696: LIST
115697: LIST
115698: PUSH
115699: EMPTY
115700: LIST
115701: LIST
115702: LIST
115703: LIST
115704: PUSH
115705: EMPTY
115706: LIST
115707: LIST
115708: PPUSH
115709: CALL_OW 69
115713: PUSH
115714: FOR_IN
115715: IFFALSE 115731
// begin SetClass ( i , 1 ) ;
115717: LD_VAR 0 1
115721: PPUSH
115722: LD_INT 1
115724: PPUSH
115725: CALL_OW 336
// end ;
115729: GO 115714
115731: POP
115732: POP
// end ;
115733: PPOPN 1
115735: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
115736: LD_EXP 146
115740: PUSH
115741: LD_EXP 150
115745: AND
115746: PUSH
115747: LD_OWVAR 65
115751: PUSH
115752: LD_INT 7
115754: LESS
115755: AND
115756: IFFALSE 115770
115758: GO 115760
115760: DISABLE
// begin enable ;
115761: ENABLE
// game_speed := 7 ;
115762: LD_ADDR_OWVAR 65
115766: PUSH
115767: LD_INT 7
115769: ST_TO_ADDR
// end ;
115770: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
115771: LD_EXP 146
115775: PUSH
115776: LD_EXP 153
115780: AND
115781: IFFALSE 115983
115783: GO 115785
115785: DISABLE
115786: LD_INT 0
115788: PPUSH
115789: PPUSH
115790: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
115791: LD_ADDR_VAR 0 3
115795: PUSH
115796: LD_INT 81
115798: PUSH
115799: LD_OWVAR 2
115803: PUSH
115804: EMPTY
115805: LIST
115806: LIST
115807: PUSH
115808: LD_INT 21
115810: PUSH
115811: LD_INT 1
115813: PUSH
115814: EMPTY
115815: LIST
115816: LIST
115817: PUSH
115818: EMPTY
115819: LIST
115820: LIST
115821: PPUSH
115822: CALL_OW 69
115826: ST_TO_ADDR
// if not tmp then
115827: LD_VAR 0 3
115831: NOT
115832: IFFALSE 115836
// exit ;
115834: GO 115983
// if tmp > 5 then
115836: LD_VAR 0 3
115840: PUSH
115841: LD_INT 5
115843: GREATER
115844: IFFALSE 115856
// k := 5 else
115846: LD_ADDR_VAR 0 2
115850: PUSH
115851: LD_INT 5
115853: ST_TO_ADDR
115854: GO 115866
// k := tmp ;
115856: LD_ADDR_VAR 0 2
115860: PUSH
115861: LD_VAR 0 3
115865: ST_TO_ADDR
// for i := 1 to k do
115866: LD_ADDR_VAR 0 1
115870: PUSH
115871: DOUBLE
115872: LD_INT 1
115874: DEC
115875: ST_TO_ADDR
115876: LD_VAR 0 2
115880: PUSH
115881: FOR_TO
115882: IFFALSE 115981
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
115884: LD_VAR 0 3
115888: PUSH
115889: LD_VAR 0 1
115893: ARRAY
115894: PPUSH
115895: LD_VAR 0 1
115899: PUSH
115900: LD_INT 4
115902: MOD
115903: PUSH
115904: LD_INT 1
115906: PLUS
115907: PPUSH
115908: CALL_OW 259
115912: PUSH
115913: LD_INT 10
115915: LESS
115916: IFFALSE 115979
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
115918: LD_VAR 0 3
115922: PUSH
115923: LD_VAR 0 1
115927: ARRAY
115928: PPUSH
115929: LD_VAR 0 1
115933: PUSH
115934: LD_INT 4
115936: MOD
115937: PUSH
115938: LD_INT 1
115940: PLUS
115941: PPUSH
115942: LD_VAR 0 3
115946: PUSH
115947: LD_VAR 0 1
115951: ARRAY
115952: PPUSH
115953: LD_VAR 0 1
115957: PUSH
115958: LD_INT 4
115960: MOD
115961: PUSH
115962: LD_INT 1
115964: PLUS
115965: PPUSH
115966: CALL_OW 259
115970: PUSH
115971: LD_INT 1
115973: PLUS
115974: PPUSH
115975: CALL_OW 237
115979: GO 115881
115981: POP
115982: POP
// end ;
115983: PPOPN 3
115985: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
115986: LD_EXP 146
115990: PUSH
115991: LD_EXP 154
115995: AND
115996: IFFALSE 116016
115998: GO 116000
116000: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
116001: LD_INT 4
116003: PPUSH
116004: LD_OWVAR 2
116008: PPUSH
116009: LD_INT 0
116011: PPUSH
116012: CALL_OW 324
116016: END
// every 0 0$1 trigger StreamModeActive and sShovel do
116017: LD_EXP 146
116021: PUSH
116022: LD_EXP 183
116026: AND
116027: IFFALSE 116047
116029: GO 116031
116031: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
116032: LD_INT 19
116034: PPUSH
116035: LD_OWVAR 2
116039: PPUSH
116040: LD_INT 0
116042: PPUSH
116043: CALL_OW 324
116047: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
116048: LD_EXP 146
116052: PUSH
116053: LD_EXP 155
116057: AND
116058: IFFALSE 116160
116060: GO 116062
116062: DISABLE
116063: LD_INT 0
116065: PPUSH
116066: PPUSH
// begin enable ;
116067: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
116068: LD_ADDR_VAR 0 2
116072: PUSH
116073: LD_INT 22
116075: PUSH
116076: LD_OWVAR 2
116080: PUSH
116081: EMPTY
116082: LIST
116083: LIST
116084: PUSH
116085: LD_INT 2
116087: PUSH
116088: LD_INT 34
116090: PUSH
116091: LD_INT 11
116093: PUSH
116094: EMPTY
116095: LIST
116096: LIST
116097: PUSH
116098: LD_INT 34
116100: PUSH
116101: LD_INT 30
116103: PUSH
116104: EMPTY
116105: LIST
116106: LIST
116107: PUSH
116108: EMPTY
116109: LIST
116110: LIST
116111: LIST
116112: PUSH
116113: EMPTY
116114: LIST
116115: LIST
116116: PPUSH
116117: CALL_OW 69
116121: ST_TO_ADDR
// if not tmp then
116122: LD_VAR 0 2
116126: NOT
116127: IFFALSE 116131
// exit ;
116129: GO 116160
// for i in tmp do
116131: LD_ADDR_VAR 0 1
116135: PUSH
116136: LD_VAR 0 2
116140: PUSH
116141: FOR_IN
116142: IFFALSE 116158
// begin SetLives ( i , 0 ) ;
116144: LD_VAR 0 1
116148: PPUSH
116149: LD_INT 0
116151: PPUSH
116152: CALL_OW 234
// end ;
116156: GO 116141
116158: POP
116159: POP
// end ;
116160: PPOPN 2
116162: END
// every 0 0$1 trigger StreamModeActive and sBunker do
116163: LD_EXP 146
116167: PUSH
116168: LD_EXP 156
116172: AND
116173: IFFALSE 116193
116175: GO 116177
116177: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
116178: LD_INT 32
116180: PPUSH
116181: LD_OWVAR 2
116185: PPUSH
116186: LD_INT 0
116188: PPUSH
116189: CALL_OW 324
116193: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
116194: LD_EXP 146
116198: PUSH
116199: LD_EXP 157
116203: AND
116204: IFFALSE 116385
116206: GO 116208
116208: DISABLE
116209: LD_INT 0
116211: PPUSH
116212: PPUSH
116213: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
116214: LD_ADDR_VAR 0 2
116218: PUSH
116219: LD_INT 22
116221: PUSH
116222: LD_OWVAR 2
116226: PUSH
116227: EMPTY
116228: LIST
116229: LIST
116230: PUSH
116231: LD_INT 33
116233: PUSH
116234: LD_INT 3
116236: PUSH
116237: EMPTY
116238: LIST
116239: LIST
116240: PUSH
116241: EMPTY
116242: LIST
116243: LIST
116244: PPUSH
116245: CALL_OW 69
116249: ST_TO_ADDR
// if not tmp then
116250: LD_VAR 0 2
116254: NOT
116255: IFFALSE 116259
// exit ;
116257: GO 116385
// side := 0 ;
116259: LD_ADDR_VAR 0 3
116263: PUSH
116264: LD_INT 0
116266: ST_TO_ADDR
// for i := 1 to 8 do
116267: LD_ADDR_VAR 0 1
116271: PUSH
116272: DOUBLE
116273: LD_INT 1
116275: DEC
116276: ST_TO_ADDR
116277: LD_INT 8
116279: PUSH
116280: FOR_TO
116281: IFFALSE 116329
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
116283: LD_OWVAR 2
116287: PUSH
116288: LD_VAR 0 1
116292: NONEQUAL
116293: PUSH
116294: LD_OWVAR 2
116298: PPUSH
116299: LD_VAR 0 1
116303: PPUSH
116304: CALL_OW 81
116308: PUSH
116309: LD_INT 2
116311: EQUAL
116312: AND
116313: IFFALSE 116327
// begin side := i ;
116315: LD_ADDR_VAR 0 3
116319: PUSH
116320: LD_VAR 0 1
116324: ST_TO_ADDR
// break ;
116325: GO 116329
// end ;
116327: GO 116280
116329: POP
116330: POP
// if not side then
116331: LD_VAR 0 3
116335: NOT
116336: IFFALSE 116340
// exit ;
116338: GO 116385
// for i := 1 to tmp do
116340: LD_ADDR_VAR 0 1
116344: PUSH
116345: DOUBLE
116346: LD_INT 1
116348: DEC
116349: ST_TO_ADDR
116350: LD_VAR 0 2
116354: PUSH
116355: FOR_TO
116356: IFFALSE 116383
// if Prob ( 60 ) then
116358: LD_INT 60
116360: PPUSH
116361: CALL_OW 13
116365: IFFALSE 116381
// SetSide ( i , side ) ;
116367: LD_VAR 0 1
116371: PPUSH
116372: LD_VAR 0 3
116376: PPUSH
116377: CALL_OW 235
116381: GO 116355
116383: POP
116384: POP
// end ;
116385: PPOPN 3
116387: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
116388: LD_EXP 146
116392: PUSH
116393: LD_EXP 159
116397: AND
116398: IFFALSE 116517
116400: GO 116402
116402: DISABLE
116403: LD_INT 0
116405: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
116406: LD_ADDR_VAR 0 1
116410: PUSH
116411: LD_INT 22
116413: PUSH
116414: LD_OWVAR 2
116418: PUSH
116419: EMPTY
116420: LIST
116421: LIST
116422: PUSH
116423: LD_INT 21
116425: PUSH
116426: LD_INT 1
116428: PUSH
116429: EMPTY
116430: LIST
116431: LIST
116432: PUSH
116433: LD_INT 3
116435: PUSH
116436: LD_INT 23
116438: PUSH
116439: LD_INT 0
116441: PUSH
116442: EMPTY
116443: LIST
116444: LIST
116445: PUSH
116446: EMPTY
116447: LIST
116448: LIST
116449: PUSH
116450: EMPTY
116451: LIST
116452: LIST
116453: LIST
116454: PPUSH
116455: CALL_OW 69
116459: PUSH
116460: FOR_IN
116461: IFFALSE 116515
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
116463: LD_VAR 0 1
116467: PPUSH
116468: CALL_OW 257
116472: PUSH
116473: LD_INT 1
116475: PUSH
116476: LD_INT 2
116478: PUSH
116479: LD_INT 3
116481: PUSH
116482: LD_INT 4
116484: PUSH
116485: EMPTY
116486: LIST
116487: LIST
116488: LIST
116489: LIST
116490: IN
116491: IFFALSE 116513
// SetClass ( un , rand ( 1 , 4 ) ) ;
116493: LD_VAR 0 1
116497: PPUSH
116498: LD_INT 1
116500: PPUSH
116501: LD_INT 4
116503: PPUSH
116504: CALL_OW 12
116508: PPUSH
116509: CALL_OW 336
116513: GO 116460
116515: POP
116516: POP
// end ;
116517: PPOPN 1
116519: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
116520: LD_EXP 146
116524: PUSH
116525: LD_EXP 158
116529: AND
116530: IFFALSE 116609
116532: GO 116534
116534: DISABLE
116535: LD_INT 0
116537: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
116538: LD_ADDR_VAR 0 1
116542: PUSH
116543: LD_INT 22
116545: PUSH
116546: LD_OWVAR 2
116550: PUSH
116551: EMPTY
116552: LIST
116553: LIST
116554: PUSH
116555: LD_INT 21
116557: PUSH
116558: LD_INT 3
116560: PUSH
116561: EMPTY
116562: LIST
116563: LIST
116564: PUSH
116565: EMPTY
116566: LIST
116567: LIST
116568: PPUSH
116569: CALL_OW 69
116573: ST_TO_ADDR
// if not tmp then
116574: LD_VAR 0 1
116578: NOT
116579: IFFALSE 116583
// exit ;
116581: GO 116609
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
116583: LD_VAR 0 1
116587: PUSH
116588: LD_INT 1
116590: PPUSH
116591: LD_VAR 0 1
116595: PPUSH
116596: CALL_OW 12
116600: ARRAY
116601: PPUSH
116602: LD_INT 100
116604: PPUSH
116605: CALL_OW 234
// end ;
116609: PPOPN 1
116611: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
116612: LD_EXP 146
116616: PUSH
116617: LD_EXP 160
116621: AND
116622: IFFALSE 116720
116624: GO 116626
116626: DISABLE
116627: LD_INT 0
116629: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
116630: LD_ADDR_VAR 0 1
116634: PUSH
116635: LD_INT 22
116637: PUSH
116638: LD_OWVAR 2
116642: PUSH
116643: EMPTY
116644: LIST
116645: LIST
116646: PUSH
116647: LD_INT 21
116649: PUSH
116650: LD_INT 1
116652: PUSH
116653: EMPTY
116654: LIST
116655: LIST
116656: PUSH
116657: EMPTY
116658: LIST
116659: LIST
116660: PPUSH
116661: CALL_OW 69
116665: ST_TO_ADDR
// if not tmp then
116666: LD_VAR 0 1
116670: NOT
116671: IFFALSE 116675
// exit ;
116673: GO 116720
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
116675: LD_VAR 0 1
116679: PUSH
116680: LD_INT 1
116682: PPUSH
116683: LD_VAR 0 1
116687: PPUSH
116688: CALL_OW 12
116692: ARRAY
116693: PPUSH
116694: LD_INT 1
116696: PPUSH
116697: LD_INT 4
116699: PPUSH
116700: CALL_OW 12
116704: PPUSH
116705: LD_INT 3000
116707: PPUSH
116708: LD_INT 9000
116710: PPUSH
116711: CALL_OW 12
116715: PPUSH
116716: CALL_OW 492
// end ;
116720: PPOPN 1
116722: END
// every 0 0$1 trigger StreamModeActive and sDepot do
116723: LD_EXP 146
116727: PUSH
116728: LD_EXP 161
116732: AND
116733: IFFALSE 116753
116735: GO 116737
116737: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
116738: LD_INT 1
116740: PPUSH
116741: LD_OWVAR 2
116745: PPUSH
116746: LD_INT 0
116748: PPUSH
116749: CALL_OW 324
116753: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
116754: LD_EXP 146
116758: PUSH
116759: LD_EXP 162
116763: AND
116764: IFFALSE 116847
116766: GO 116768
116768: DISABLE
116769: LD_INT 0
116771: PPUSH
116772: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
116773: LD_ADDR_VAR 0 2
116777: PUSH
116778: LD_INT 22
116780: PUSH
116781: LD_OWVAR 2
116785: PUSH
116786: EMPTY
116787: LIST
116788: LIST
116789: PUSH
116790: LD_INT 21
116792: PUSH
116793: LD_INT 3
116795: PUSH
116796: EMPTY
116797: LIST
116798: LIST
116799: PUSH
116800: EMPTY
116801: LIST
116802: LIST
116803: PPUSH
116804: CALL_OW 69
116808: ST_TO_ADDR
// if not tmp then
116809: LD_VAR 0 2
116813: NOT
116814: IFFALSE 116818
// exit ;
116816: GO 116847
// for i in tmp do
116818: LD_ADDR_VAR 0 1
116822: PUSH
116823: LD_VAR 0 2
116827: PUSH
116828: FOR_IN
116829: IFFALSE 116845
// SetBLevel ( i , 10 ) ;
116831: LD_VAR 0 1
116835: PPUSH
116836: LD_INT 10
116838: PPUSH
116839: CALL_OW 241
116843: GO 116828
116845: POP
116846: POP
// end ;
116847: PPOPN 2
116849: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
116850: LD_EXP 146
116854: PUSH
116855: LD_EXP 163
116859: AND
116860: IFFALSE 116971
116862: GO 116864
116864: DISABLE
116865: LD_INT 0
116867: PPUSH
116868: PPUSH
116869: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
116870: LD_ADDR_VAR 0 3
116874: PUSH
116875: LD_INT 22
116877: PUSH
116878: LD_OWVAR 2
116882: PUSH
116883: EMPTY
116884: LIST
116885: LIST
116886: PUSH
116887: LD_INT 25
116889: PUSH
116890: LD_INT 1
116892: PUSH
116893: EMPTY
116894: LIST
116895: LIST
116896: PUSH
116897: EMPTY
116898: LIST
116899: LIST
116900: PPUSH
116901: CALL_OW 69
116905: ST_TO_ADDR
// if not tmp then
116906: LD_VAR 0 3
116910: NOT
116911: IFFALSE 116915
// exit ;
116913: GO 116971
// un := tmp [ rand ( 1 , tmp ) ] ;
116915: LD_ADDR_VAR 0 2
116919: PUSH
116920: LD_VAR 0 3
116924: PUSH
116925: LD_INT 1
116927: PPUSH
116928: LD_VAR 0 3
116932: PPUSH
116933: CALL_OW 12
116937: ARRAY
116938: ST_TO_ADDR
// if Crawls ( un ) then
116939: LD_VAR 0 2
116943: PPUSH
116944: CALL_OW 318
116948: IFFALSE 116959
// ComWalk ( un ) ;
116950: LD_VAR 0 2
116954: PPUSH
116955: CALL_OW 138
// SetClass ( un , class_sniper ) ;
116959: LD_VAR 0 2
116963: PPUSH
116964: LD_INT 5
116966: PPUSH
116967: CALL_OW 336
// end ;
116971: PPOPN 3
116973: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
116974: LD_EXP 146
116978: PUSH
116979: LD_EXP 164
116983: AND
116984: PUSH
116985: LD_OWVAR 67
116989: PUSH
116990: LD_INT 4
116992: LESS
116993: AND
116994: IFFALSE 117013
116996: GO 116998
116998: DISABLE
// begin Difficulty := Difficulty + 1 ;
116999: LD_ADDR_OWVAR 67
117003: PUSH
117004: LD_OWVAR 67
117008: PUSH
117009: LD_INT 1
117011: PLUS
117012: ST_TO_ADDR
// end ;
117013: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
117014: LD_EXP 146
117018: PUSH
117019: LD_EXP 165
117023: AND
117024: IFFALSE 117127
117026: GO 117028
117028: DISABLE
117029: LD_INT 0
117031: PPUSH
// begin for i := 1 to 5 do
117032: LD_ADDR_VAR 0 1
117036: PUSH
117037: DOUBLE
117038: LD_INT 1
117040: DEC
117041: ST_TO_ADDR
117042: LD_INT 5
117044: PUSH
117045: FOR_TO
117046: IFFALSE 117125
// begin uc_nation := nation_nature ;
117048: LD_ADDR_OWVAR 21
117052: PUSH
117053: LD_INT 0
117055: ST_TO_ADDR
// uc_side := 0 ;
117056: LD_ADDR_OWVAR 20
117060: PUSH
117061: LD_INT 0
117063: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
117064: LD_ADDR_OWVAR 29
117068: PUSH
117069: LD_INT 12
117071: PUSH
117072: LD_INT 12
117074: PUSH
117075: EMPTY
117076: LIST
117077: LIST
117078: ST_TO_ADDR
// hc_agressivity := 20 ;
117079: LD_ADDR_OWVAR 35
117083: PUSH
117084: LD_INT 20
117086: ST_TO_ADDR
// hc_class := class_tiger ;
117087: LD_ADDR_OWVAR 28
117091: PUSH
117092: LD_INT 14
117094: ST_TO_ADDR
// hc_gallery :=  ;
117095: LD_ADDR_OWVAR 33
117099: PUSH
117100: LD_STRING 
117102: ST_TO_ADDR
// hc_name :=  ;
117103: LD_ADDR_OWVAR 26
117107: PUSH
117108: LD_STRING 
117110: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
117111: CALL_OW 44
117115: PPUSH
117116: LD_INT 0
117118: PPUSH
117119: CALL_OW 51
// end ;
117123: GO 117045
117125: POP
117126: POP
// end ;
117127: PPOPN 1
117129: END
// every 0 0$1 trigger StreamModeActive and sBomb do
117130: LD_EXP 146
117134: PUSH
117135: LD_EXP 166
117139: AND
117140: IFFALSE 117149
117142: GO 117144
117144: DISABLE
// StreamSibBomb ;
117145: CALL 117150 0 0
117149: END
// export function StreamSibBomb ; var i , x , y ; begin
117150: LD_INT 0
117152: PPUSH
117153: PPUSH
117154: PPUSH
117155: PPUSH
// result := false ;
117156: LD_ADDR_VAR 0 1
117160: PUSH
117161: LD_INT 0
117163: ST_TO_ADDR
// for i := 1 to 16 do
117164: LD_ADDR_VAR 0 2
117168: PUSH
117169: DOUBLE
117170: LD_INT 1
117172: DEC
117173: ST_TO_ADDR
117174: LD_INT 16
117176: PUSH
117177: FOR_TO
117178: IFFALSE 117377
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
117180: LD_ADDR_VAR 0 3
117184: PUSH
117185: LD_INT 10
117187: PUSH
117188: LD_INT 20
117190: PUSH
117191: LD_INT 30
117193: PUSH
117194: LD_INT 40
117196: PUSH
117197: LD_INT 50
117199: PUSH
117200: LD_INT 60
117202: PUSH
117203: LD_INT 70
117205: PUSH
117206: LD_INT 80
117208: PUSH
117209: LD_INT 90
117211: PUSH
117212: LD_INT 100
117214: PUSH
117215: LD_INT 110
117217: PUSH
117218: LD_INT 120
117220: PUSH
117221: LD_INT 130
117223: PUSH
117224: LD_INT 140
117226: PUSH
117227: LD_INT 150
117229: PUSH
117230: EMPTY
117231: LIST
117232: LIST
117233: LIST
117234: LIST
117235: LIST
117236: LIST
117237: LIST
117238: LIST
117239: LIST
117240: LIST
117241: LIST
117242: LIST
117243: LIST
117244: LIST
117245: LIST
117246: PUSH
117247: LD_INT 1
117249: PPUSH
117250: LD_INT 15
117252: PPUSH
117253: CALL_OW 12
117257: ARRAY
117258: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
117259: LD_ADDR_VAR 0 4
117263: PUSH
117264: LD_INT 10
117266: PUSH
117267: LD_INT 20
117269: PUSH
117270: LD_INT 30
117272: PUSH
117273: LD_INT 40
117275: PUSH
117276: LD_INT 50
117278: PUSH
117279: LD_INT 60
117281: PUSH
117282: LD_INT 70
117284: PUSH
117285: LD_INT 80
117287: PUSH
117288: LD_INT 90
117290: PUSH
117291: LD_INT 100
117293: PUSH
117294: LD_INT 110
117296: PUSH
117297: LD_INT 120
117299: PUSH
117300: LD_INT 130
117302: PUSH
117303: LD_INT 140
117305: PUSH
117306: LD_INT 150
117308: PUSH
117309: EMPTY
117310: LIST
117311: LIST
117312: LIST
117313: LIST
117314: LIST
117315: LIST
117316: LIST
117317: LIST
117318: LIST
117319: LIST
117320: LIST
117321: LIST
117322: LIST
117323: LIST
117324: LIST
117325: PUSH
117326: LD_INT 1
117328: PPUSH
117329: LD_INT 15
117331: PPUSH
117332: CALL_OW 12
117336: ARRAY
117337: ST_TO_ADDR
// if ValidHex ( x , y ) then
117338: LD_VAR 0 3
117342: PPUSH
117343: LD_VAR 0 4
117347: PPUSH
117348: CALL_OW 488
117352: IFFALSE 117375
// begin result := [ x , y ] ;
117354: LD_ADDR_VAR 0 1
117358: PUSH
117359: LD_VAR 0 3
117363: PUSH
117364: LD_VAR 0 4
117368: PUSH
117369: EMPTY
117370: LIST
117371: LIST
117372: ST_TO_ADDR
// break ;
117373: GO 117377
// end ; end ;
117375: GO 117177
117377: POP
117378: POP
// if result then
117379: LD_VAR 0 1
117383: IFFALSE 117443
// begin ToLua ( playSibBomb() ) ;
117385: LD_STRING playSibBomb()
117387: PPUSH
117388: CALL_OW 559
// wait ( 0 0$14 ) ;
117392: LD_INT 490
117394: PPUSH
117395: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
117399: LD_VAR 0 1
117403: PUSH
117404: LD_INT 1
117406: ARRAY
117407: PPUSH
117408: LD_VAR 0 1
117412: PUSH
117413: LD_INT 2
117415: ARRAY
117416: PPUSH
117417: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
117421: LD_VAR 0 1
117425: PUSH
117426: LD_INT 1
117428: ARRAY
117429: PPUSH
117430: LD_VAR 0 1
117434: PUSH
117435: LD_INT 2
117437: ARRAY
117438: PPUSH
117439: CALL_OW 429
// end ; end ;
117443: LD_VAR 0 1
117447: RET
// every 0 0$1 trigger StreamModeActive and sReset do
117448: LD_EXP 146
117452: PUSH
117453: LD_EXP 168
117457: AND
117458: IFFALSE 117470
117460: GO 117462
117462: DISABLE
// YouLost (  ) ;
117463: LD_STRING 
117465: PPUSH
117466: CALL_OW 104
117470: END
// every 0 0$1 trigger StreamModeActive and sFog do
117471: LD_EXP 146
117475: PUSH
117476: LD_EXP 167
117480: AND
117481: IFFALSE 117495
117483: GO 117485
117485: DISABLE
// FogOff ( your_side ) ;
117486: LD_OWVAR 2
117490: PPUSH
117491: CALL_OW 344
117495: END
// every 0 0$1 trigger StreamModeActive and sSun do
117496: LD_EXP 146
117500: PUSH
117501: LD_EXP 169
117505: AND
117506: IFFALSE 117534
117508: GO 117510
117510: DISABLE
// begin solar_recharge_percent := 0 ;
117511: LD_ADDR_OWVAR 79
117515: PUSH
117516: LD_INT 0
117518: ST_TO_ADDR
// wait ( 5 5$00 ) ;
117519: LD_INT 10500
117521: PPUSH
117522: CALL_OW 67
// solar_recharge_percent := 100 ;
117526: LD_ADDR_OWVAR 79
117530: PUSH
117531: LD_INT 100
117533: ST_TO_ADDR
// end ;
117534: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
117535: LD_EXP 146
117539: PUSH
117540: LD_EXP 170
117544: AND
117545: IFFALSE 117784
117547: GO 117549
117549: DISABLE
117550: LD_INT 0
117552: PPUSH
117553: PPUSH
117554: PPUSH
// begin tmp := [ ] ;
117555: LD_ADDR_VAR 0 3
117559: PUSH
117560: EMPTY
117561: ST_TO_ADDR
// for i := 1 to 6 do
117562: LD_ADDR_VAR 0 1
117566: PUSH
117567: DOUBLE
117568: LD_INT 1
117570: DEC
117571: ST_TO_ADDR
117572: LD_INT 6
117574: PUSH
117575: FOR_TO
117576: IFFALSE 117681
// begin uc_nation := nation_nature ;
117578: LD_ADDR_OWVAR 21
117582: PUSH
117583: LD_INT 0
117585: ST_TO_ADDR
// uc_side := 0 ;
117586: LD_ADDR_OWVAR 20
117590: PUSH
117591: LD_INT 0
117593: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
117594: LD_ADDR_OWVAR 29
117598: PUSH
117599: LD_INT 12
117601: PUSH
117602: LD_INT 12
117604: PUSH
117605: EMPTY
117606: LIST
117607: LIST
117608: ST_TO_ADDR
// hc_agressivity := 20 ;
117609: LD_ADDR_OWVAR 35
117613: PUSH
117614: LD_INT 20
117616: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
117617: LD_ADDR_OWVAR 28
117621: PUSH
117622: LD_INT 17
117624: ST_TO_ADDR
// hc_gallery :=  ;
117625: LD_ADDR_OWVAR 33
117629: PUSH
117630: LD_STRING 
117632: ST_TO_ADDR
// hc_name :=  ;
117633: LD_ADDR_OWVAR 26
117637: PUSH
117638: LD_STRING 
117640: ST_TO_ADDR
// un := CreateHuman ;
117641: LD_ADDR_VAR 0 2
117645: PUSH
117646: CALL_OW 44
117650: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
117651: LD_VAR 0 2
117655: PPUSH
117656: LD_INT 1
117658: PPUSH
117659: CALL_OW 51
// tmp := tmp ^ un ;
117663: LD_ADDR_VAR 0 3
117667: PUSH
117668: LD_VAR 0 3
117672: PUSH
117673: LD_VAR 0 2
117677: ADD
117678: ST_TO_ADDR
// end ;
117679: GO 117575
117681: POP
117682: POP
// repeat wait ( 0 0$1 ) ;
117683: LD_INT 35
117685: PPUSH
117686: CALL_OW 67
// for un in tmp do
117690: LD_ADDR_VAR 0 2
117694: PUSH
117695: LD_VAR 0 3
117699: PUSH
117700: FOR_IN
117701: IFFALSE 117775
// begin if IsDead ( un ) then
117703: LD_VAR 0 2
117707: PPUSH
117708: CALL_OW 301
117712: IFFALSE 117732
// begin tmp := tmp diff un ;
117714: LD_ADDR_VAR 0 3
117718: PUSH
117719: LD_VAR 0 3
117723: PUSH
117724: LD_VAR 0 2
117728: DIFF
117729: ST_TO_ADDR
// continue ;
117730: GO 117700
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
117732: LD_VAR 0 2
117736: PPUSH
117737: LD_INT 3
117739: PUSH
117740: LD_INT 22
117742: PUSH
117743: LD_INT 0
117745: PUSH
117746: EMPTY
117747: LIST
117748: LIST
117749: PUSH
117750: EMPTY
117751: LIST
117752: LIST
117753: PPUSH
117754: CALL_OW 69
117758: PPUSH
117759: LD_VAR 0 2
117763: PPUSH
117764: CALL_OW 74
117768: PPUSH
117769: CALL_OW 115
// end ;
117773: GO 117700
117775: POP
117776: POP
// until not tmp ;
117777: LD_VAR 0 3
117781: NOT
117782: IFFALSE 117683
// end ;
117784: PPOPN 3
117786: END
// every 0 0$1 trigger StreamModeActive and sTroll do
117787: LD_EXP 146
117791: PUSH
117792: LD_EXP 171
117796: AND
117797: IFFALSE 117851
117799: GO 117801
117801: DISABLE
// begin ToLua ( displayTroll(); ) ;
117802: LD_STRING displayTroll();
117804: PPUSH
117805: CALL_OW 559
// wait ( 3 3$00 ) ;
117809: LD_INT 6300
117811: PPUSH
117812: CALL_OW 67
// ToLua ( hideTroll(); ) ;
117816: LD_STRING hideTroll();
117818: PPUSH
117819: CALL_OW 559
// wait ( 1 1$00 ) ;
117823: LD_INT 2100
117825: PPUSH
117826: CALL_OW 67
// ToLua ( displayTroll(); ) ;
117830: LD_STRING displayTroll();
117832: PPUSH
117833: CALL_OW 559
// wait ( 1 1$00 ) ;
117837: LD_INT 2100
117839: PPUSH
117840: CALL_OW 67
// ToLua ( hideTroll(); ) ;
117844: LD_STRING hideTroll();
117846: PPUSH
117847: CALL_OW 559
// end ;
117851: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
117852: LD_EXP 146
117856: PUSH
117857: LD_EXP 172
117861: AND
117862: IFFALSE 117925
117864: GO 117866
117866: DISABLE
117867: LD_INT 0
117869: PPUSH
// begin p := 0 ;
117870: LD_ADDR_VAR 0 1
117874: PUSH
117875: LD_INT 0
117877: ST_TO_ADDR
// repeat game_speed := 1 ;
117878: LD_ADDR_OWVAR 65
117882: PUSH
117883: LD_INT 1
117885: ST_TO_ADDR
// wait ( 0 0$1 ) ;
117886: LD_INT 35
117888: PPUSH
117889: CALL_OW 67
// p := p + 1 ;
117893: LD_ADDR_VAR 0 1
117897: PUSH
117898: LD_VAR 0 1
117902: PUSH
117903: LD_INT 1
117905: PLUS
117906: ST_TO_ADDR
// until p >= 60 ;
117907: LD_VAR 0 1
117911: PUSH
117912: LD_INT 60
117914: GREATEREQUAL
117915: IFFALSE 117878
// game_speed := 4 ;
117917: LD_ADDR_OWVAR 65
117921: PUSH
117922: LD_INT 4
117924: ST_TO_ADDR
// end ;
117925: PPOPN 1
117927: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
117928: LD_EXP 146
117932: PUSH
117933: LD_EXP 173
117937: AND
117938: IFFALSE 118084
117940: GO 117942
117942: DISABLE
117943: LD_INT 0
117945: PPUSH
117946: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
117947: LD_ADDR_VAR 0 1
117951: PUSH
117952: LD_INT 22
117954: PUSH
117955: LD_OWVAR 2
117959: PUSH
117960: EMPTY
117961: LIST
117962: LIST
117963: PUSH
117964: LD_INT 2
117966: PUSH
117967: LD_INT 30
117969: PUSH
117970: LD_INT 0
117972: PUSH
117973: EMPTY
117974: LIST
117975: LIST
117976: PUSH
117977: LD_INT 30
117979: PUSH
117980: LD_INT 1
117982: PUSH
117983: EMPTY
117984: LIST
117985: LIST
117986: PUSH
117987: EMPTY
117988: LIST
117989: LIST
117990: LIST
117991: PUSH
117992: EMPTY
117993: LIST
117994: LIST
117995: PPUSH
117996: CALL_OW 69
118000: ST_TO_ADDR
// if not depot then
118001: LD_VAR 0 1
118005: NOT
118006: IFFALSE 118010
// exit ;
118008: GO 118084
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
118010: LD_ADDR_VAR 0 2
118014: PUSH
118015: LD_VAR 0 1
118019: PUSH
118020: LD_INT 1
118022: PPUSH
118023: LD_VAR 0 1
118027: PPUSH
118028: CALL_OW 12
118032: ARRAY
118033: PPUSH
118034: CALL_OW 274
118038: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
118039: LD_VAR 0 2
118043: PPUSH
118044: LD_INT 1
118046: PPUSH
118047: LD_INT 0
118049: PPUSH
118050: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
118054: LD_VAR 0 2
118058: PPUSH
118059: LD_INT 2
118061: PPUSH
118062: LD_INT 0
118064: PPUSH
118065: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
118069: LD_VAR 0 2
118073: PPUSH
118074: LD_INT 3
118076: PPUSH
118077: LD_INT 0
118079: PPUSH
118080: CALL_OW 277
// end ;
118084: PPOPN 2
118086: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
118087: LD_EXP 146
118091: PUSH
118092: LD_EXP 174
118096: AND
118097: IFFALSE 118194
118099: GO 118101
118101: DISABLE
118102: LD_INT 0
118104: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
118105: LD_ADDR_VAR 0 1
118109: PUSH
118110: LD_INT 22
118112: PUSH
118113: LD_OWVAR 2
118117: PUSH
118118: EMPTY
118119: LIST
118120: LIST
118121: PUSH
118122: LD_INT 21
118124: PUSH
118125: LD_INT 1
118127: PUSH
118128: EMPTY
118129: LIST
118130: LIST
118131: PUSH
118132: LD_INT 3
118134: PUSH
118135: LD_INT 23
118137: PUSH
118138: LD_INT 0
118140: PUSH
118141: EMPTY
118142: LIST
118143: LIST
118144: PUSH
118145: EMPTY
118146: LIST
118147: LIST
118148: PUSH
118149: EMPTY
118150: LIST
118151: LIST
118152: LIST
118153: PPUSH
118154: CALL_OW 69
118158: ST_TO_ADDR
// if not tmp then
118159: LD_VAR 0 1
118163: NOT
118164: IFFALSE 118168
// exit ;
118166: GO 118194
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
118168: LD_VAR 0 1
118172: PUSH
118173: LD_INT 1
118175: PPUSH
118176: LD_VAR 0 1
118180: PPUSH
118181: CALL_OW 12
118185: ARRAY
118186: PPUSH
118187: LD_INT 200
118189: PPUSH
118190: CALL_OW 234
// end ;
118194: PPOPN 1
118196: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
118197: LD_EXP 146
118201: PUSH
118202: LD_EXP 175
118206: AND
118207: IFFALSE 118286
118209: GO 118211
118211: DISABLE
118212: LD_INT 0
118214: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
118215: LD_ADDR_VAR 0 1
118219: PUSH
118220: LD_INT 22
118222: PUSH
118223: LD_OWVAR 2
118227: PUSH
118228: EMPTY
118229: LIST
118230: LIST
118231: PUSH
118232: LD_INT 21
118234: PUSH
118235: LD_INT 2
118237: PUSH
118238: EMPTY
118239: LIST
118240: LIST
118241: PUSH
118242: EMPTY
118243: LIST
118244: LIST
118245: PPUSH
118246: CALL_OW 69
118250: ST_TO_ADDR
// if not tmp then
118251: LD_VAR 0 1
118255: NOT
118256: IFFALSE 118260
// exit ;
118258: GO 118286
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
118260: LD_VAR 0 1
118264: PUSH
118265: LD_INT 1
118267: PPUSH
118268: LD_VAR 0 1
118272: PPUSH
118273: CALL_OW 12
118277: ARRAY
118278: PPUSH
118279: LD_INT 60
118281: PPUSH
118282: CALL_OW 234
// end ;
118286: PPOPN 1
118288: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
118289: LD_EXP 146
118293: PUSH
118294: LD_EXP 176
118298: AND
118299: IFFALSE 118398
118301: GO 118303
118303: DISABLE
118304: LD_INT 0
118306: PPUSH
118307: PPUSH
// begin enable ;
118308: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
118309: LD_ADDR_VAR 0 1
118313: PUSH
118314: LD_INT 22
118316: PUSH
118317: LD_OWVAR 2
118321: PUSH
118322: EMPTY
118323: LIST
118324: LIST
118325: PUSH
118326: LD_INT 61
118328: PUSH
118329: EMPTY
118330: LIST
118331: PUSH
118332: LD_INT 33
118334: PUSH
118335: LD_INT 2
118337: PUSH
118338: EMPTY
118339: LIST
118340: LIST
118341: PUSH
118342: EMPTY
118343: LIST
118344: LIST
118345: LIST
118346: PPUSH
118347: CALL_OW 69
118351: ST_TO_ADDR
// if not tmp then
118352: LD_VAR 0 1
118356: NOT
118357: IFFALSE 118361
// exit ;
118359: GO 118398
// for i in tmp do
118361: LD_ADDR_VAR 0 2
118365: PUSH
118366: LD_VAR 0 1
118370: PUSH
118371: FOR_IN
118372: IFFALSE 118396
// if IsControledBy ( i ) then
118374: LD_VAR 0 2
118378: PPUSH
118379: CALL_OW 312
118383: IFFALSE 118394
// ComUnlink ( i ) ;
118385: LD_VAR 0 2
118389: PPUSH
118390: CALL_OW 136
118394: GO 118371
118396: POP
118397: POP
// end ;
118398: PPOPN 2
118400: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
118401: LD_EXP 146
118405: PUSH
118406: LD_EXP 177
118410: AND
118411: IFFALSE 118551
118413: GO 118415
118415: DISABLE
118416: LD_INT 0
118418: PPUSH
118419: PPUSH
// begin ToLua ( displayPowell(); ) ;
118420: LD_STRING displayPowell();
118422: PPUSH
118423: CALL_OW 559
// uc_side := 0 ;
118427: LD_ADDR_OWVAR 20
118431: PUSH
118432: LD_INT 0
118434: ST_TO_ADDR
// uc_nation := 2 ;
118435: LD_ADDR_OWVAR 21
118439: PUSH
118440: LD_INT 2
118442: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
118443: LD_ADDR_OWVAR 37
118447: PUSH
118448: LD_INT 14
118450: ST_TO_ADDR
// vc_engine := engine_siberite ;
118451: LD_ADDR_OWVAR 39
118455: PUSH
118456: LD_INT 3
118458: ST_TO_ADDR
// vc_control := control_apeman ;
118459: LD_ADDR_OWVAR 38
118463: PUSH
118464: LD_INT 5
118466: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
118467: LD_ADDR_OWVAR 40
118471: PUSH
118472: LD_INT 29
118474: ST_TO_ADDR
// un := CreateVehicle ;
118475: LD_ADDR_VAR 0 2
118479: PUSH
118480: CALL_OW 45
118484: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
118485: LD_VAR 0 2
118489: PPUSH
118490: LD_INT 1
118492: PPUSH
118493: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
118497: LD_INT 35
118499: PPUSH
118500: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
118504: LD_VAR 0 2
118508: PPUSH
118509: LD_INT 22
118511: PUSH
118512: LD_OWVAR 2
118516: PUSH
118517: EMPTY
118518: LIST
118519: LIST
118520: PPUSH
118521: CALL_OW 69
118525: PPUSH
118526: LD_VAR 0 2
118530: PPUSH
118531: CALL_OW 74
118535: PPUSH
118536: CALL_OW 115
// until IsDead ( un ) ;
118540: LD_VAR 0 2
118544: PPUSH
118545: CALL_OW 301
118549: IFFALSE 118497
// end ;
118551: PPOPN 2
118553: END
// every 0 0$1 trigger StreamModeActive and sStu do
118554: LD_EXP 146
118558: PUSH
118559: LD_EXP 185
118563: AND
118564: IFFALSE 118580
118566: GO 118568
118568: DISABLE
// begin ToLua ( displayStucuk(); ) ;
118569: LD_STRING displayStucuk();
118571: PPUSH
118572: CALL_OW 559
// ResetFog ;
118576: CALL_OW 335
// end ;
118580: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
118581: LD_EXP 146
118585: PUSH
118586: LD_EXP 178
118590: AND
118591: IFFALSE 118732
118593: GO 118595
118595: DISABLE
118596: LD_INT 0
118598: PPUSH
118599: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
118600: LD_ADDR_VAR 0 2
118604: PUSH
118605: LD_INT 22
118607: PUSH
118608: LD_OWVAR 2
118612: PUSH
118613: EMPTY
118614: LIST
118615: LIST
118616: PUSH
118617: LD_INT 21
118619: PUSH
118620: LD_INT 1
118622: PUSH
118623: EMPTY
118624: LIST
118625: LIST
118626: PUSH
118627: EMPTY
118628: LIST
118629: LIST
118630: PPUSH
118631: CALL_OW 69
118635: ST_TO_ADDR
// if not tmp then
118636: LD_VAR 0 2
118640: NOT
118641: IFFALSE 118645
// exit ;
118643: GO 118732
// un := tmp [ rand ( 1 , tmp ) ] ;
118645: LD_ADDR_VAR 0 1
118649: PUSH
118650: LD_VAR 0 2
118654: PUSH
118655: LD_INT 1
118657: PPUSH
118658: LD_VAR 0 2
118662: PPUSH
118663: CALL_OW 12
118667: ARRAY
118668: ST_TO_ADDR
// SetSide ( un , 0 ) ;
118669: LD_VAR 0 1
118673: PPUSH
118674: LD_INT 0
118676: PPUSH
118677: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
118681: LD_VAR 0 1
118685: PPUSH
118686: LD_OWVAR 3
118690: PUSH
118691: LD_VAR 0 1
118695: DIFF
118696: PPUSH
118697: LD_VAR 0 1
118701: PPUSH
118702: CALL_OW 74
118706: PPUSH
118707: CALL_OW 115
// wait ( 0 0$20 ) ;
118711: LD_INT 700
118713: PPUSH
118714: CALL_OW 67
// SetSide ( un , your_side ) ;
118718: LD_VAR 0 1
118722: PPUSH
118723: LD_OWVAR 2
118727: PPUSH
118728: CALL_OW 235
// end ;
118732: PPOPN 2
118734: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
118735: LD_EXP 146
118739: PUSH
118740: LD_EXP 179
118744: AND
118745: IFFALSE 118851
118747: GO 118749
118749: DISABLE
118750: LD_INT 0
118752: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
118753: LD_ADDR_VAR 0 1
118757: PUSH
118758: LD_INT 22
118760: PUSH
118761: LD_OWVAR 2
118765: PUSH
118766: EMPTY
118767: LIST
118768: LIST
118769: PUSH
118770: LD_INT 2
118772: PUSH
118773: LD_INT 30
118775: PUSH
118776: LD_INT 0
118778: PUSH
118779: EMPTY
118780: LIST
118781: LIST
118782: PUSH
118783: LD_INT 30
118785: PUSH
118786: LD_INT 1
118788: PUSH
118789: EMPTY
118790: LIST
118791: LIST
118792: PUSH
118793: EMPTY
118794: LIST
118795: LIST
118796: LIST
118797: PUSH
118798: EMPTY
118799: LIST
118800: LIST
118801: PPUSH
118802: CALL_OW 69
118806: ST_TO_ADDR
// if not depot then
118807: LD_VAR 0 1
118811: NOT
118812: IFFALSE 118816
// exit ;
118814: GO 118851
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
118816: LD_VAR 0 1
118820: PUSH
118821: LD_INT 1
118823: ARRAY
118824: PPUSH
118825: CALL_OW 250
118829: PPUSH
118830: LD_VAR 0 1
118834: PUSH
118835: LD_INT 1
118837: ARRAY
118838: PPUSH
118839: CALL_OW 251
118843: PPUSH
118844: LD_INT 70
118846: PPUSH
118847: CALL_OW 495
// end ;
118851: PPOPN 1
118853: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
118854: LD_EXP 146
118858: PUSH
118859: LD_EXP 180
118863: AND
118864: IFFALSE 119075
118866: GO 118868
118868: DISABLE
118869: LD_INT 0
118871: PPUSH
118872: PPUSH
118873: PPUSH
118874: PPUSH
118875: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
118876: LD_ADDR_VAR 0 5
118880: PUSH
118881: LD_INT 22
118883: PUSH
118884: LD_OWVAR 2
118888: PUSH
118889: EMPTY
118890: LIST
118891: LIST
118892: PUSH
118893: LD_INT 21
118895: PUSH
118896: LD_INT 1
118898: PUSH
118899: EMPTY
118900: LIST
118901: LIST
118902: PUSH
118903: EMPTY
118904: LIST
118905: LIST
118906: PPUSH
118907: CALL_OW 69
118911: ST_TO_ADDR
// if not tmp then
118912: LD_VAR 0 5
118916: NOT
118917: IFFALSE 118921
// exit ;
118919: GO 119075
// for i in tmp do
118921: LD_ADDR_VAR 0 1
118925: PUSH
118926: LD_VAR 0 5
118930: PUSH
118931: FOR_IN
118932: IFFALSE 119073
// begin d := rand ( 0 , 5 ) ;
118934: LD_ADDR_VAR 0 4
118938: PUSH
118939: LD_INT 0
118941: PPUSH
118942: LD_INT 5
118944: PPUSH
118945: CALL_OW 12
118949: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
118950: LD_ADDR_VAR 0 2
118954: PUSH
118955: LD_VAR 0 1
118959: PPUSH
118960: CALL_OW 250
118964: PPUSH
118965: LD_VAR 0 4
118969: PPUSH
118970: LD_INT 3
118972: PPUSH
118973: LD_INT 12
118975: PPUSH
118976: CALL_OW 12
118980: PPUSH
118981: CALL_OW 272
118985: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
118986: LD_ADDR_VAR 0 3
118990: PUSH
118991: LD_VAR 0 1
118995: PPUSH
118996: CALL_OW 251
119000: PPUSH
119001: LD_VAR 0 4
119005: PPUSH
119006: LD_INT 3
119008: PPUSH
119009: LD_INT 12
119011: PPUSH
119012: CALL_OW 12
119016: PPUSH
119017: CALL_OW 273
119021: ST_TO_ADDR
// if ValidHex ( x , y ) then
119022: LD_VAR 0 2
119026: PPUSH
119027: LD_VAR 0 3
119031: PPUSH
119032: CALL_OW 488
119036: IFFALSE 119071
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
119038: LD_VAR 0 1
119042: PPUSH
119043: LD_VAR 0 2
119047: PPUSH
119048: LD_VAR 0 3
119052: PPUSH
119053: LD_INT 3
119055: PPUSH
119056: LD_INT 6
119058: PPUSH
119059: CALL_OW 12
119063: PPUSH
119064: LD_INT 1
119066: PPUSH
119067: CALL_OW 483
// end ;
119071: GO 118931
119073: POP
119074: POP
// end ;
119075: PPOPN 5
119077: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
119078: LD_EXP 146
119082: PUSH
119083: LD_EXP 181
119087: AND
119088: IFFALSE 119182
119090: GO 119092
119092: DISABLE
119093: LD_INT 0
119095: PPUSH
119096: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
119097: LD_ADDR_VAR 0 2
119101: PUSH
119102: LD_INT 22
119104: PUSH
119105: LD_OWVAR 2
119109: PUSH
119110: EMPTY
119111: LIST
119112: LIST
119113: PUSH
119114: LD_INT 32
119116: PUSH
119117: LD_INT 1
119119: PUSH
119120: EMPTY
119121: LIST
119122: LIST
119123: PUSH
119124: LD_INT 21
119126: PUSH
119127: LD_INT 2
119129: PUSH
119130: EMPTY
119131: LIST
119132: LIST
119133: PUSH
119134: EMPTY
119135: LIST
119136: LIST
119137: LIST
119138: PPUSH
119139: CALL_OW 69
119143: ST_TO_ADDR
// if not tmp then
119144: LD_VAR 0 2
119148: NOT
119149: IFFALSE 119153
// exit ;
119151: GO 119182
// for i in tmp do
119153: LD_ADDR_VAR 0 1
119157: PUSH
119158: LD_VAR 0 2
119162: PUSH
119163: FOR_IN
119164: IFFALSE 119180
// SetFuel ( i , 0 ) ;
119166: LD_VAR 0 1
119170: PPUSH
119171: LD_INT 0
119173: PPUSH
119174: CALL_OW 240
119178: GO 119163
119180: POP
119181: POP
// end ;
119182: PPOPN 2
119184: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
119185: LD_EXP 146
119189: PUSH
119190: LD_EXP 182
119194: AND
119195: IFFALSE 119261
119197: GO 119199
119199: DISABLE
119200: LD_INT 0
119202: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
119203: LD_ADDR_VAR 0 1
119207: PUSH
119208: LD_INT 22
119210: PUSH
119211: LD_OWVAR 2
119215: PUSH
119216: EMPTY
119217: LIST
119218: LIST
119219: PUSH
119220: LD_INT 30
119222: PUSH
119223: LD_INT 29
119225: PUSH
119226: EMPTY
119227: LIST
119228: LIST
119229: PUSH
119230: EMPTY
119231: LIST
119232: LIST
119233: PPUSH
119234: CALL_OW 69
119238: ST_TO_ADDR
// if not tmp then
119239: LD_VAR 0 1
119243: NOT
119244: IFFALSE 119248
// exit ;
119246: GO 119261
// DestroyUnit ( tmp [ 1 ] ) ;
119248: LD_VAR 0 1
119252: PUSH
119253: LD_INT 1
119255: ARRAY
119256: PPUSH
119257: CALL_OW 65
// end ;
119261: PPOPN 1
119263: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
119264: LD_EXP 146
119268: PUSH
119269: LD_EXP 184
119273: AND
119274: IFFALSE 119403
119276: GO 119278
119278: DISABLE
119279: LD_INT 0
119281: PPUSH
// begin uc_side := 0 ;
119282: LD_ADDR_OWVAR 20
119286: PUSH
119287: LD_INT 0
119289: ST_TO_ADDR
// uc_nation := nation_arabian ;
119290: LD_ADDR_OWVAR 21
119294: PUSH
119295: LD_INT 2
119297: ST_TO_ADDR
// hc_gallery :=  ;
119298: LD_ADDR_OWVAR 33
119302: PUSH
119303: LD_STRING 
119305: ST_TO_ADDR
// hc_name :=  ;
119306: LD_ADDR_OWVAR 26
119310: PUSH
119311: LD_STRING 
119313: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
119314: LD_INT 1
119316: PPUSH
119317: LD_INT 11
119319: PPUSH
119320: LD_INT 10
119322: PPUSH
119323: CALL_OW 380
// un := CreateHuman ;
119327: LD_ADDR_VAR 0 1
119331: PUSH
119332: CALL_OW 44
119336: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
119337: LD_VAR 0 1
119341: PPUSH
119342: LD_INT 1
119344: PPUSH
119345: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
119349: LD_INT 35
119351: PPUSH
119352: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
119356: LD_VAR 0 1
119360: PPUSH
119361: LD_INT 22
119363: PUSH
119364: LD_OWVAR 2
119368: PUSH
119369: EMPTY
119370: LIST
119371: LIST
119372: PPUSH
119373: CALL_OW 69
119377: PPUSH
119378: LD_VAR 0 1
119382: PPUSH
119383: CALL_OW 74
119387: PPUSH
119388: CALL_OW 115
// until IsDead ( un ) ;
119392: LD_VAR 0 1
119396: PPUSH
119397: CALL_OW 301
119401: IFFALSE 119349
// end ;
119403: PPOPN 1
119405: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
119406: LD_EXP 146
119410: PUSH
119411: LD_EXP 186
119415: AND
119416: IFFALSE 119428
119418: GO 119420
119420: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
119421: LD_STRING earthquake(getX(game), 0, 32)
119423: PPUSH
119424: CALL_OW 559
119428: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
119429: LD_EXP 146
119433: PUSH
119434: LD_EXP 187
119438: AND
119439: IFFALSE 119530
119441: GO 119443
119443: DISABLE
119444: LD_INT 0
119446: PPUSH
// begin enable ;
119447: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
119448: LD_ADDR_VAR 0 1
119452: PUSH
119453: LD_INT 22
119455: PUSH
119456: LD_OWVAR 2
119460: PUSH
119461: EMPTY
119462: LIST
119463: LIST
119464: PUSH
119465: LD_INT 21
119467: PUSH
119468: LD_INT 2
119470: PUSH
119471: EMPTY
119472: LIST
119473: LIST
119474: PUSH
119475: LD_INT 33
119477: PUSH
119478: LD_INT 3
119480: PUSH
119481: EMPTY
119482: LIST
119483: LIST
119484: PUSH
119485: EMPTY
119486: LIST
119487: LIST
119488: LIST
119489: PPUSH
119490: CALL_OW 69
119494: ST_TO_ADDR
// if not tmp then
119495: LD_VAR 0 1
119499: NOT
119500: IFFALSE 119504
// exit ;
119502: GO 119530
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
119504: LD_VAR 0 1
119508: PUSH
119509: LD_INT 1
119511: PPUSH
119512: LD_VAR 0 1
119516: PPUSH
119517: CALL_OW 12
119521: ARRAY
119522: PPUSH
119523: LD_INT 1
119525: PPUSH
119526: CALL_OW 234
// end ;
119530: PPOPN 1
119532: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
119533: LD_EXP 146
119537: PUSH
119538: LD_EXP 188
119542: AND
119543: IFFALSE 119684
119545: GO 119547
119547: DISABLE
119548: LD_INT 0
119550: PPUSH
119551: PPUSH
119552: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
119553: LD_ADDR_VAR 0 3
119557: PUSH
119558: LD_INT 22
119560: PUSH
119561: LD_OWVAR 2
119565: PUSH
119566: EMPTY
119567: LIST
119568: LIST
119569: PUSH
119570: LD_INT 25
119572: PUSH
119573: LD_INT 1
119575: PUSH
119576: EMPTY
119577: LIST
119578: LIST
119579: PUSH
119580: EMPTY
119581: LIST
119582: LIST
119583: PPUSH
119584: CALL_OW 69
119588: ST_TO_ADDR
// if not tmp then
119589: LD_VAR 0 3
119593: NOT
119594: IFFALSE 119598
// exit ;
119596: GO 119684
// un := tmp [ rand ( 1 , tmp ) ] ;
119598: LD_ADDR_VAR 0 2
119602: PUSH
119603: LD_VAR 0 3
119607: PUSH
119608: LD_INT 1
119610: PPUSH
119611: LD_VAR 0 3
119615: PPUSH
119616: CALL_OW 12
119620: ARRAY
119621: ST_TO_ADDR
// if Crawls ( un ) then
119622: LD_VAR 0 2
119626: PPUSH
119627: CALL_OW 318
119631: IFFALSE 119642
// ComWalk ( un ) ;
119633: LD_VAR 0 2
119637: PPUSH
119638: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
119642: LD_VAR 0 2
119646: PPUSH
119647: LD_INT 9
119649: PPUSH
119650: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
119654: LD_INT 28
119656: PPUSH
119657: LD_OWVAR 2
119661: PPUSH
119662: LD_INT 2
119664: PPUSH
119665: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
119669: LD_INT 29
119671: PPUSH
119672: LD_OWVAR 2
119676: PPUSH
119677: LD_INT 2
119679: PPUSH
119680: CALL_OW 322
// end ;
119684: PPOPN 3
119686: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
119687: LD_EXP 146
119691: PUSH
119692: LD_EXP 189
119696: AND
119697: IFFALSE 119808
119699: GO 119701
119701: DISABLE
119702: LD_INT 0
119704: PPUSH
119705: PPUSH
119706: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
119707: LD_ADDR_VAR 0 3
119711: PUSH
119712: LD_INT 22
119714: PUSH
119715: LD_OWVAR 2
119719: PUSH
119720: EMPTY
119721: LIST
119722: LIST
119723: PUSH
119724: LD_INT 25
119726: PUSH
119727: LD_INT 1
119729: PUSH
119730: EMPTY
119731: LIST
119732: LIST
119733: PUSH
119734: EMPTY
119735: LIST
119736: LIST
119737: PPUSH
119738: CALL_OW 69
119742: ST_TO_ADDR
// if not tmp then
119743: LD_VAR 0 3
119747: NOT
119748: IFFALSE 119752
// exit ;
119750: GO 119808
// un := tmp [ rand ( 1 , tmp ) ] ;
119752: LD_ADDR_VAR 0 2
119756: PUSH
119757: LD_VAR 0 3
119761: PUSH
119762: LD_INT 1
119764: PPUSH
119765: LD_VAR 0 3
119769: PPUSH
119770: CALL_OW 12
119774: ARRAY
119775: ST_TO_ADDR
// if Crawls ( un ) then
119776: LD_VAR 0 2
119780: PPUSH
119781: CALL_OW 318
119785: IFFALSE 119796
// ComWalk ( un ) ;
119787: LD_VAR 0 2
119791: PPUSH
119792: CALL_OW 138
// SetClass ( un , class_mortar ) ;
119796: LD_VAR 0 2
119800: PPUSH
119801: LD_INT 8
119803: PPUSH
119804: CALL_OW 336
// end ;
119808: PPOPN 3
119810: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
119811: LD_EXP 146
119815: PUSH
119816: LD_EXP 190
119820: AND
119821: IFFALSE 119965
119823: GO 119825
119825: DISABLE
119826: LD_INT 0
119828: PPUSH
119829: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
119830: LD_ADDR_VAR 0 2
119834: PUSH
119835: LD_INT 22
119837: PUSH
119838: LD_OWVAR 2
119842: PUSH
119843: EMPTY
119844: LIST
119845: LIST
119846: PUSH
119847: LD_INT 21
119849: PUSH
119850: LD_INT 2
119852: PUSH
119853: EMPTY
119854: LIST
119855: LIST
119856: PUSH
119857: LD_INT 2
119859: PUSH
119860: LD_INT 34
119862: PUSH
119863: LD_INT 12
119865: PUSH
119866: EMPTY
119867: LIST
119868: LIST
119869: PUSH
119870: LD_INT 34
119872: PUSH
119873: LD_INT 51
119875: PUSH
119876: EMPTY
119877: LIST
119878: LIST
119879: PUSH
119880: LD_INT 34
119882: PUSH
119883: LD_INT 32
119885: PUSH
119886: EMPTY
119887: LIST
119888: LIST
119889: PUSH
119890: EMPTY
119891: LIST
119892: LIST
119893: LIST
119894: LIST
119895: PUSH
119896: EMPTY
119897: LIST
119898: LIST
119899: LIST
119900: PPUSH
119901: CALL_OW 69
119905: ST_TO_ADDR
// if not tmp then
119906: LD_VAR 0 2
119910: NOT
119911: IFFALSE 119915
// exit ;
119913: GO 119965
// for i in tmp do
119915: LD_ADDR_VAR 0 1
119919: PUSH
119920: LD_VAR 0 2
119924: PUSH
119925: FOR_IN
119926: IFFALSE 119963
// if GetCargo ( i , mat_artifact ) = 0 then
119928: LD_VAR 0 1
119932: PPUSH
119933: LD_INT 4
119935: PPUSH
119936: CALL_OW 289
119940: PUSH
119941: LD_INT 0
119943: EQUAL
119944: IFFALSE 119961
// SetCargo ( i , mat_siberit , 100 ) ;
119946: LD_VAR 0 1
119950: PPUSH
119951: LD_INT 3
119953: PPUSH
119954: LD_INT 100
119956: PPUSH
119957: CALL_OW 290
119961: GO 119925
119963: POP
119964: POP
// end ;
119965: PPOPN 2
119967: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
119968: LD_EXP 146
119972: PUSH
119973: LD_EXP 191
119977: AND
119978: IFFALSE 120161
119980: GO 119982
119982: DISABLE
119983: LD_INT 0
119985: PPUSH
119986: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
119987: LD_ADDR_VAR 0 2
119991: PUSH
119992: LD_INT 22
119994: PUSH
119995: LD_OWVAR 2
119999: PUSH
120000: EMPTY
120001: LIST
120002: LIST
120003: PPUSH
120004: CALL_OW 69
120008: ST_TO_ADDR
// if not tmp then
120009: LD_VAR 0 2
120013: NOT
120014: IFFALSE 120018
// exit ;
120016: GO 120161
// for i := 1 to 2 do
120018: LD_ADDR_VAR 0 1
120022: PUSH
120023: DOUBLE
120024: LD_INT 1
120026: DEC
120027: ST_TO_ADDR
120028: LD_INT 2
120030: PUSH
120031: FOR_TO
120032: IFFALSE 120159
// begin uc_side := your_side ;
120034: LD_ADDR_OWVAR 20
120038: PUSH
120039: LD_OWVAR 2
120043: ST_TO_ADDR
// uc_nation := nation_american ;
120044: LD_ADDR_OWVAR 21
120048: PUSH
120049: LD_INT 1
120051: ST_TO_ADDR
// vc_chassis := us_morphling ;
120052: LD_ADDR_OWVAR 37
120056: PUSH
120057: LD_INT 5
120059: ST_TO_ADDR
// vc_engine := engine_siberite ;
120060: LD_ADDR_OWVAR 39
120064: PUSH
120065: LD_INT 3
120067: ST_TO_ADDR
// vc_control := control_computer ;
120068: LD_ADDR_OWVAR 38
120072: PUSH
120073: LD_INT 3
120075: ST_TO_ADDR
// vc_weapon := us_double_laser ;
120076: LD_ADDR_OWVAR 40
120080: PUSH
120081: LD_INT 10
120083: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
120084: LD_VAR 0 2
120088: PUSH
120089: LD_INT 1
120091: ARRAY
120092: PPUSH
120093: CALL_OW 310
120097: NOT
120098: IFFALSE 120145
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
120100: CALL_OW 45
120104: PPUSH
120105: LD_VAR 0 2
120109: PUSH
120110: LD_INT 1
120112: ARRAY
120113: PPUSH
120114: CALL_OW 250
120118: PPUSH
120119: LD_VAR 0 2
120123: PUSH
120124: LD_INT 1
120126: ARRAY
120127: PPUSH
120128: CALL_OW 251
120132: PPUSH
120133: LD_INT 12
120135: PPUSH
120136: LD_INT 1
120138: PPUSH
120139: CALL_OW 50
120143: GO 120157
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
120145: CALL_OW 45
120149: PPUSH
120150: LD_INT 1
120152: PPUSH
120153: CALL_OW 51
// end ;
120157: GO 120031
120159: POP
120160: POP
// end ;
120161: PPOPN 2
120163: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
120164: LD_EXP 146
120168: PUSH
120169: LD_EXP 192
120173: AND
120174: IFFALSE 120396
120176: GO 120178
120178: DISABLE
120179: LD_INT 0
120181: PPUSH
120182: PPUSH
120183: PPUSH
120184: PPUSH
120185: PPUSH
120186: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
120187: LD_ADDR_VAR 0 6
120191: PUSH
120192: LD_INT 22
120194: PUSH
120195: LD_OWVAR 2
120199: PUSH
120200: EMPTY
120201: LIST
120202: LIST
120203: PUSH
120204: LD_INT 21
120206: PUSH
120207: LD_INT 1
120209: PUSH
120210: EMPTY
120211: LIST
120212: LIST
120213: PUSH
120214: LD_INT 3
120216: PUSH
120217: LD_INT 23
120219: PUSH
120220: LD_INT 0
120222: PUSH
120223: EMPTY
120224: LIST
120225: LIST
120226: PUSH
120227: EMPTY
120228: LIST
120229: LIST
120230: PUSH
120231: EMPTY
120232: LIST
120233: LIST
120234: LIST
120235: PPUSH
120236: CALL_OW 69
120240: ST_TO_ADDR
// if not tmp then
120241: LD_VAR 0 6
120245: NOT
120246: IFFALSE 120250
// exit ;
120248: GO 120396
// s1 := rand ( 1 , 4 ) ;
120250: LD_ADDR_VAR 0 2
120254: PUSH
120255: LD_INT 1
120257: PPUSH
120258: LD_INT 4
120260: PPUSH
120261: CALL_OW 12
120265: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
120266: LD_ADDR_VAR 0 4
120270: PUSH
120271: LD_VAR 0 6
120275: PUSH
120276: LD_INT 1
120278: ARRAY
120279: PPUSH
120280: LD_VAR 0 2
120284: PPUSH
120285: CALL_OW 259
120289: ST_TO_ADDR
// if s1 = 1 then
120290: LD_VAR 0 2
120294: PUSH
120295: LD_INT 1
120297: EQUAL
120298: IFFALSE 120318
// s2 := rand ( 2 , 4 ) else
120300: LD_ADDR_VAR 0 3
120304: PUSH
120305: LD_INT 2
120307: PPUSH
120308: LD_INT 4
120310: PPUSH
120311: CALL_OW 12
120315: ST_TO_ADDR
120316: GO 120326
// s2 := 1 ;
120318: LD_ADDR_VAR 0 3
120322: PUSH
120323: LD_INT 1
120325: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
120326: LD_ADDR_VAR 0 5
120330: PUSH
120331: LD_VAR 0 6
120335: PUSH
120336: LD_INT 1
120338: ARRAY
120339: PPUSH
120340: LD_VAR 0 3
120344: PPUSH
120345: CALL_OW 259
120349: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
120350: LD_VAR 0 6
120354: PUSH
120355: LD_INT 1
120357: ARRAY
120358: PPUSH
120359: LD_VAR 0 2
120363: PPUSH
120364: LD_VAR 0 5
120368: PPUSH
120369: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
120373: LD_VAR 0 6
120377: PUSH
120378: LD_INT 1
120380: ARRAY
120381: PPUSH
120382: LD_VAR 0 3
120386: PPUSH
120387: LD_VAR 0 4
120391: PPUSH
120392: CALL_OW 237
// end ;
120396: PPOPN 6
120398: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
120399: LD_EXP 146
120403: PUSH
120404: LD_EXP 193
120408: AND
120409: IFFALSE 120488
120411: GO 120413
120413: DISABLE
120414: LD_INT 0
120416: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
120417: LD_ADDR_VAR 0 1
120421: PUSH
120422: LD_INT 22
120424: PUSH
120425: LD_OWVAR 2
120429: PUSH
120430: EMPTY
120431: LIST
120432: LIST
120433: PUSH
120434: LD_INT 30
120436: PUSH
120437: LD_INT 3
120439: PUSH
120440: EMPTY
120441: LIST
120442: LIST
120443: PUSH
120444: EMPTY
120445: LIST
120446: LIST
120447: PPUSH
120448: CALL_OW 69
120452: ST_TO_ADDR
// if not tmp then
120453: LD_VAR 0 1
120457: NOT
120458: IFFALSE 120462
// exit ;
120460: GO 120488
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
120462: LD_VAR 0 1
120466: PUSH
120467: LD_INT 1
120469: PPUSH
120470: LD_VAR 0 1
120474: PPUSH
120475: CALL_OW 12
120479: ARRAY
120480: PPUSH
120481: LD_INT 1
120483: PPUSH
120484: CALL_OW 234
// end ;
120488: PPOPN 1
120490: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
120491: LD_EXP 146
120495: PUSH
120496: LD_EXP 194
120500: AND
120501: IFFALSE 120613
120503: GO 120505
120505: DISABLE
120506: LD_INT 0
120508: PPUSH
120509: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
120510: LD_ADDR_VAR 0 2
120514: PUSH
120515: LD_INT 22
120517: PUSH
120518: LD_OWVAR 2
120522: PUSH
120523: EMPTY
120524: LIST
120525: LIST
120526: PUSH
120527: LD_INT 2
120529: PUSH
120530: LD_INT 30
120532: PUSH
120533: LD_INT 27
120535: PUSH
120536: EMPTY
120537: LIST
120538: LIST
120539: PUSH
120540: LD_INT 30
120542: PUSH
120543: LD_INT 26
120545: PUSH
120546: EMPTY
120547: LIST
120548: LIST
120549: PUSH
120550: LD_INT 30
120552: PUSH
120553: LD_INT 28
120555: PUSH
120556: EMPTY
120557: LIST
120558: LIST
120559: PUSH
120560: EMPTY
120561: LIST
120562: LIST
120563: LIST
120564: LIST
120565: PUSH
120566: EMPTY
120567: LIST
120568: LIST
120569: PPUSH
120570: CALL_OW 69
120574: ST_TO_ADDR
// if not tmp then
120575: LD_VAR 0 2
120579: NOT
120580: IFFALSE 120584
// exit ;
120582: GO 120613
// for i in tmp do
120584: LD_ADDR_VAR 0 1
120588: PUSH
120589: LD_VAR 0 2
120593: PUSH
120594: FOR_IN
120595: IFFALSE 120611
// SetLives ( i , 1 ) ;
120597: LD_VAR 0 1
120601: PPUSH
120602: LD_INT 1
120604: PPUSH
120605: CALL_OW 234
120609: GO 120594
120611: POP
120612: POP
// end ;
120613: PPOPN 2
120615: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
120616: LD_EXP 146
120620: PUSH
120621: LD_EXP 195
120625: AND
120626: IFFALSE 120913
120628: GO 120630
120630: DISABLE
120631: LD_INT 0
120633: PPUSH
120634: PPUSH
120635: PPUSH
// begin i := rand ( 1 , 7 ) ;
120636: LD_ADDR_VAR 0 1
120640: PUSH
120641: LD_INT 1
120643: PPUSH
120644: LD_INT 7
120646: PPUSH
120647: CALL_OW 12
120651: ST_TO_ADDR
// case i of 1 :
120652: LD_VAR 0 1
120656: PUSH
120657: LD_INT 1
120659: DOUBLE
120660: EQUAL
120661: IFTRUE 120665
120663: GO 120675
120665: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
120666: LD_STRING earthquake(getX(game), 0, 32)
120668: PPUSH
120669: CALL_OW 559
120673: GO 120913
120675: LD_INT 2
120677: DOUBLE
120678: EQUAL
120679: IFTRUE 120683
120681: GO 120697
120683: POP
// begin ToLua ( displayStucuk(); ) ;
120684: LD_STRING displayStucuk();
120686: PPUSH
120687: CALL_OW 559
// ResetFog ;
120691: CALL_OW 335
// end ; 3 :
120695: GO 120913
120697: LD_INT 3
120699: DOUBLE
120700: EQUAL
120701: IFTRUE 120705
120703: GO 120809
120705: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
120706: LD_ADDR_VAR 0 2
120710: PUSH
120711: LD_INT 22
120713: PUSH
120714: LD_OWVAR 2
120718: PUSH
120719: EMPTY
120720: LIST
120721: LIST
120722: PUSH
120723: LD_INT 25
120725: PUSH
120726: LD_INT 1
120728: PUSH
120729: EMPTY
120730: LIST
120731: LIST
120732: PUSH
120733: EMPTY
120734: LIST
120735: LIST
120736: PPUSH
120737: CALL_OW 69
120741: ST_TO_ADDR
// if not tmp then
120742: LD_VAR 0 2
120746: NOT
120747: IFFALSE 120751
// exit ;
120749: GO 120913
// un := tmp [ rand ( 1 , tmp ) ] ;
120751: LD_ADDR_VAR 0 3
120755: PUSH
120756: LD_VAR 0 2
120760: PUSH
120761: LD_INT 1
120763: PPUSH
120764: LD_VAR 0 2
120768: PPUSH
120769: CALL_OW 12
120773: ARRAY
120774: ST_TO_ADDR
// if Crawls ( un ) then
120775: LD_VAR 0 3
120779: PPUSH
120780: CALL_OW 318
120784: IFFALSE 120795
// ComWalk ( un ) ;
120786: LD_VAR 0 3
120790: PPUSH
120791: CALL_OW 138
// SetClass ( un , class_mortar ) ;
120795: LD_VAR 0 3
120799: PPUSH
120800: LD_INT 8
120802: PPUSH
120803: CALL_OW 336
// end ; 4 :
120807: GO 120913
120809: LD_INT 4
120811: DOUBLE
120812: EQUAL
120813: IFTRUE 120817
120815: GO 120891
120817: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
120818: LD_ADDR_VAR 0 2
120822: PUSH
120823: LD_INT 22
120825: PUSH
120826: LD_OWVAR 2
120830: PUSH
120831: EMPTY
120832: LIST
120833: LIST
120834: PUSH
120835: LD_INT 30
120837: PUSH
120838: LD_INT 29
120840: PUSH
120841: EMPTY
120842: LIST
120843: LIST
120844: PUSH
120845: EMPTY
120846: LIST
120847: LIST
120848: PPUSH
120849: CALL_OW 69
120853: ST_TO_ADDR
// if not tmp then
120854: LD_VAR 0 2
120858: NOT
120859: IFFALSE 120863
// exit ;
120861: GO 120913
// CenterNowOnUnits ( tmp [ 1 ] ) ;
120863: LD_VAR 0 2
120867: PUSH
120868: LD_INT 1
120870: ARRAY
120871: PPUSH
120872: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
120876: LD_VAR 0 2
120880: PUSH
120881: LD_INT 1
120883: ARRAY
120884: PPUSH
120885: CALL_OW 65
// end ; 5 .. 7 :
120889: GO 120913
120891: LD_INT 5
120893: DOUBLE
120894: GREATEREQUAL
120895: IFFALSE 120903
120897: LD_INT 7
120899: DOUBLE
120900: LESSEQUAL
120901: IFTRUE 120905
120903: GO 120912
120905: POP
// StreamSibBomb ; end ;
120906: CALL 117150 0 0
120910: GO 120913
120912: POP
// end ;
120913: PPOPN 3
120915: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
120916: LD_EXP 146
120920: PUSH
120921: LD_EXP 196
120925: AND
120926: IFFALSE 121082
120928: GO 120930
120930: DISABLE
120931: LD_INT 0
120933: PPUSH
120934: PPUSH
120935: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
120936: LD_ADDR_VAR 0 2
120940: PUSH
120941: LD_INT 81
120943: PUSH
120944: LD_OWVAR 2
120948: PUSH
120949: EMPTY
120950: LIST
120951: LIST
120952: PUSH
120953: LD_INT 2
120955: PUSH
120956: LD_INT 21
120958: PUSH
120959: LD_INT 1
120961: PUSH
120962: EMPTY
120963: LIST
120964: LIST
120965: PUSH
120966: LD_INT 21
120968: PUSH
120969: LD_INT 2
120971: PUSH
120972: EMPTY
120973: LIST
120974: LIST
120975: PUSH
120976: EMPTY
120977: LIST
120978: LIST
120979: LIST
120980: PUSH
120981: EMPTY
120982: LIST
120983: LIST
120984: PPUSH
120985: CALL_OW 69
120989: ST_TO_ADDR
// if not tmp then
120990: LD_VAR 0 2
120994: NOT
120995: IFFALSE 120999
// exit ;
120997: GO 121082
// p := 0 ;
120999: LD_ADDR_VAR 0 3
121003: PUSH
121004: LD_INT 0
121006: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
121007: LD_INT 35
121009: PPUSH
121010: CALL_OW 67
// p := p + 1 ;
121014: LD_ADDR_VAR 0 3
121018: PUSH
121019: LD_VAR 0 3
121023: PUSH
121024: LD_INT 1
121026: PLUS
121027: ST_TO_ADDR
// for i in tmp do
121028: LD_ADDR_VAR 0 1
121032: PUSH
121033: LD_VAR 0 2
121037: PUSH
121038: FOR_IN
121039: IFFALSE 121070
// if GetLives ( i ) < 1000 then
121041: LD_VAR 0 1
121045: PPUSH
121046: CALL_OW 256
121050: PUSH
121051: LD_INT 1000
121053: LESS
121054: IFFALSE 121068
// SetLives ( i , 1000 ) ;
121056: LD_VAR 0 1
121060: PPUSH
121061: LD_INT 1000
121063: PPUSH
121064: CALL_OW 234
121068: GO 121038
121070: POP
121071: POP
// until p > 20 ;
121072: LD_VAR 0 3
121076: PUSH
121077: LD_INT 20
121079: GREATER
121080: IFFALSE 121007
// end ;
121082: PPOPN 3
121084: END
// every 0 0$1 trigger StreamModeActive and sTime do
121085: LD_EXP 146
121089: PUSH
121090: LD_EXP 197
121094: AND
121095: IFFALSE 121130
121097: GO 121099
121099: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
121100: LD_INT 28
121102: PPUSH
121103: LD_OWVAR 2
121107: PPUSH
121108: LD_INT 2
121110: PPUSH
121111: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
121115: LD_INT 30
121117: PPUSH
121118: LD_OWVAR 2
121122: PPUSH
121123: LD_INT 2
121125: PPUSH
121126: CALL_OW 322
// end ;
121130: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
121131: LD_EXP 146
121135: PUSH
121136: LD_EXP 198
121140: AND
121141: IFFALSE 121262
121143: GO 121145
121145: DISABLE
121146: LD_INT 0
121148: PPUSH
121149: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
121150: LD_ADDR_VAR 0 2
121154: PUSH
121155: LD_INT 22
121157: PUSH
121158: LD_OWVAR 2
121162: PUSH
121163: EMPTY
121164: LIST
121165: LIST
121166: PUSH
121167: LD_INT 21
121169: PUSH
121170: LD_INT 1
121172: PUSH
121173: EMPTY
121174: LIST
121175: LIST
121176: PUSH
121177: LD_INT 3
121179: PUSH
121180: LD_INT 23
121182: PUSH
121183: LD_INT 0
121185: PUSH
121186: EMPTY
121187: LIST
121188: LIST
121189: PUSH
121190: EMPTY
121191: LIST
121192: LIST
121193: PUSH
121194: EMPTY
121195: LIST
121196: LIST
121197: LIST
121198: PPUSH
121199: CALL_OW 69
121203: ST_TO_ADDR
// if not tmp then
121204: LD_VAR 0 2
121208: NOT
121209: IFFALSE 121213
// exit ;
121211: GO 121262
// for i in tmp do
121213: LD_ADDR_VAR 0 1
121217: PUSH
121218: LD_VAR 0 2
121222: PUSH
121223: FOR_IN
121224: IFFALSE 121260
// begin if Crawls ( i ) then
121226: LD_VAR 0 1
121230: PPUSH
121231: CALL_OW 318
121235: IFFALSE 121246
// ComWalk ( i ) ;
121237: LD_VAR 0 1
121241: PPUSH
121242: CALL_OW 138
// SetClass ( i , 2 ) ;
121246: LD_VAR 0 1
121250: PPUSH
121251: LD_INT 2
121253: PPUSH
121254: CALL_OW 336
// end ;
121258: GO 121223
121260: POP
121261: POP
// end ;
121262: PPOPN 2
121264: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
121265: LD_EXP 146
121269: PUSH
121270: LD_EXP 199
121274: AND
121275: IFFALSE 121563
121277: GO 121279
121279: DISABLE
121280: LD_INT 0
121282: PPUSH
121283: PPUSH
121284: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
121285: LD_OWVAR 2
121289: PPUSH
121290: LD_INT 9
121292: PPUSH
121293: LD_INT 1
121295: PPUSH
121296: LD_INT 1
121298: PPUSH
121299: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
121303: LD_INT 9
121305: PPUSH
121306: LD_OWVAR 2
121310: PPUSH
121311: CALL_OW 343
// uc_side := 9 ;
121315: LD_ADDR_OWVAR 20
121319: PUSH
121320: LD_INT 9
121322: ST_TO_ADDR
// uc_nation := 2 ;
121323: LD_ADDR_OWVAR 21
121327: PUSH
121328: LD_INT 2
121330: ST_TO_ADDR
// hc_name := Dark Warrior ;
121331: LD_ADDR_OWVAR 26
121335: PUSH
121336: LD_STRING Dark Warrior
121338: ST_TO_ADDR
// hc_gallery :=  ;
121339: LD_ADDR_OWVAR 33
121343: PUSH
121344: LD_STRING 
121346: ST_TO_ADDR
// hc_noskilllimit := true ;
121347: LD_ADDR_OWVAR 76
121351: PUSH
121352: LD_INT 1
121354: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
121355: LD_ADDR_OWVAR 31
121359: PUSH
121360: LD_INT 30
121362: PUSH
121363: LD_INT 30
121365: PUSH
121366: LD_INT 30
121368: PUSH
121369: LD_INT 30
121371: PUSH
121372: EMPTY
121373: LIST
121374: LIST
121375: LIST
121376: LIST
121377: ST_TO_ADDR
// un := CreateHuman ;
121378: LD_ADDR_VAR 0 3
121382: PUSH
121383: CALL_OW 44
121387: ST_TO_ADDR
// hc_noskilllimit := false ;
121388: LD_ADDR_OWVAR 76
121392: PUSH
121393: LD_INT 0
121395: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
121396: LD_VAR 0 3
121400: PPUSH
121401: LD_INT 1
121403: PPUSH
121404: CALL_OW 51
// ToLua ( playRanger() ) ;
121408: LD_STRING playRanger()
121410: PPUSH
121411: CALL_OW 559
// p := 0 ;
121415: LD_ADDR_VAR 0 2
121419: PUSH
121420: LD_INT 0
121422: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
121423: LD_INT 35
121425: PPUSH
121426: CALL_OW 67
// p := p + 1 ;
121430: LD_ADDR_VAR 0 2
121434: PUSH
121435: LD_VAR 0 2
121439: PUSH
121440: LD_INT 1
121442: PLUS
121443: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
121444: LD_VAR 0 3
121448: PPUSH
121449: CALL_OW 256
121453: PUSH
121454: LD_INT 1000
121456: LESS
121457: IFFALSE 121471
// SetLives ( un , 1000 ) ;
121459: LD_VAR 0 3
121463: PPUSH
121464: LD_INT 1000
121466: PPUSH
121467: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
121471: LD_VAR 0 3
121475: PPUSH
121476: LD_INT 81
121478: PUSH
121479: LD_OWVAR 2
121483: PUSH
121484: EMPTY
121485: LIST
121486: LIST
121487: PUSH
121488: LD_INT 91
121490: PUSH
121491: LD_VAR 0 3
121495: PUSH
121496: LD_INT 30
121498: PUSH
121499: EMPTY
121500: LIST
121501: LIST
121502: LIST
121503: PUSH
121504: EMPTY
121505: LIST
121506: LIST
121507: PPUSH
121508: CALL_OW 69
121512: PPUSH
121513: LD_VAR 0 3
121517: PPUSH
121518: CALL_OW 74
121522: PPUSH
121523: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
121527: LD_VAR 0 2
121531: PUSH
121532: LD_INT 80
121534: GREATER
121535: PUSH
121536: LD_VAR 0 3
121540: PPUSH
121541: CALL_OW 301
121545: OR
121546: IFFALSE 121423
// if un then
121548: LD_VAR 0 3
121552: IFFALSE 121563
// RemoveUnit ( un ) ;
121554: LD_VAR 0 3
121558: PPUSH
121559: CALL_OW 64
// end ;
121563: PPOPN 3
121565: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
121566: LD_EXP 200
121570: IFFALSE 121686
121572: GO 121574
121574: DISABLE
121575: LD_INT 0
121577: PPUSH
121578: PPUSH
121579: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
121580: LD_ADDR_VAR 0 2
121584: PUSH
121585: LD_INT 81
121587: PUSH
121588: LD_OWVAR 2
121592: PUSH
121593: EMPTY
121594: LIST
121595: LIST
121596: PUSH
121597: LD_INT 21
121599: PUSH
121600: LD_INT 1
121602: PUSH
121603: EMPTY
121604: LIST
121605: LIST
121606: PUSH
121607: EMPTY
121608: LIST
121609: LIST
121610: PPUSH
121611: CALL_OW 69
121615: ST_TO_ADDR
// ToLua ( playComputer() ) ;
121616: LD_STRING playComputer()
121618: PPUSH
121619: CALL_OW 559
// if not tmp then
121623: LD_VAR 0 2
121627: NOT
121628: IFFALSE 121632
// exit ;
121630: GO 121686
// for i in tmp do
121632: LD_ADDR_VAR 0 1
121636: PUSH
121637: LD_VAR 0 2
121641: PUSH
121642: FOR_IN
121643: IFFALSE 121684
// for j := 1 to 4 do
121645: LD_ADDR_VAR 0 3
121649: PUSH
121650: DOUBLE
121651: LD_INT 1
121653: DEC
121654: ST_TO_ADDR
121655: LD_INT 4
121657: PUSH
121658: FOR_TO
121659: IFFALSE 121680
// SetSkill ( i , j , 10 ) ;
121661: LD_VAR 0 1
121665: PPUSH
121666: LD_VAR 0 3
121670: PPUSH
121671: LD_INT 10
121673: PPUSH
121674: CALL_OW 237
121678: GO 121658
121680: POP
121681: POP
121682: GO 121642
121684: POP
121685: POP
// end ;
121686: PPOPN 3
121688: END
// every 0 0$1 trigger s30 do var i , tmp ;
121689: LD_EXP 201
121693: IFFALSE 121762
121695: GO 121697
121697: DISABLE
121698: LD_INT 0
121700: PPUSH
121701: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
121702: LD_ADDR_VAR 0 2
121706: PUSH
121707: LD_INT 22
121709: PUSH
121710: LD_OWVAR 2
121714: PUSH
121715: EMPTY
121716: LIST
121717: LIST
121718: PPUSH
121719: CALL_OW 69
121723: ST_TO_ADDR
// if not tmp then
121724: LD_VAR 0 2
121728: NOT
121729: IFFALSE 121733
// exit ;
121731: GO 121762
// for i in tmp do
121733: LD_ADDR_VAR 0 1
121737: PUSH
121738: LD_VAR 0 2
121742: PUSH
121743: FOR_IN
121744: IFFALSE 121760
// SetLives ( i , 300 ) ;
121746: LD_VAR 0 1
121750: PPUSH
121751: LD_INT 300
121753: PPUSH
121754: CALL_OW 234
121758: GO 121743
121760: POP
121761: POP
// end ;
121762: PPOPN 2
121764: END
// every 0 0$1 trigger s60 do var i , tmp ;
121765: LD_EXP 202
121769: IFFALSE 121838
121771: GO 121773
121773: DISABLE
121774: LD_INT 0
121776: PPUSH
121777: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
121778: LD_ADDR_VAR 0 2
121782: PUSH
121783: LD_INT 22
121785: PUSH
121786: LD_OWVAR 2
121790: PUSH
121791: EMPTY
121792: LIST
121793: LIST
121794: PPUSH
121795: CALL_OW 69
121799: ST_TO_ADDR
// if not tmp then
121800: LD_VAR 0 2
121804: NOT
121805: IFFALSE 121809
// exit ;
121807: GO 121838
// for i in tmp do
121809: LD_ADDR_VAR 0 1
121813: PUSH
121814: LD_VAR 0 2
121818: PUSH
121819: FOR_IN
121820: IFFALSE 121836
// SetLives ( i , 600 ) ;
121822: LD_VAR 0 1
121826: PPUSH
121827: LD_INT 600
121829: PPUSH
121830: CALL_OW 234
121834: GO 121819
121836: POP
121837: POP
// end ;
121838: PPOPN 2
121840: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
121841: LD_INT 0
121843: PPUSH
// case cmd of 301 :
121844: LD_VAR 0 1
121848: PUSH
121849: LD_INT 301
121851: DOUBLE
121852: EQUAL
121853: IFTRUE 121857
121855: GO 121889
121857: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
121858: LD_VAR 0 6
121862: PPUSH
121863: LD_VAR 0 7
121867: PPUSH
121868: LD_VAR 0 8
121872: PPUSH
121873: LD_VAR 0 4
121877: PPUSH
121878: LD_VAR 0 5
121882: PPUSH
121883: CALL 123090 0 5
121887: GO 122010
121889: LD_INT 302
121891: DOUBLE
121892: EQUAL
121893: IFTRUE 121897
121895: GO 121934
121897: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
121898: LD_VAR 0 6
121902: PPUSH
121903: LD_VAR 0 7
121907: PPUSH
121908: LD_VAR 0 8
121912: PPUSH
121913: LD_VAR 0 9
121917: PPUSH
121918: LD_VAR 0 4
121922: PPUSH
121923: LD_VAR 0 5
121927: PPUSH
121928: CALL 123181 0 6
121932: GO 122010
121934: LD_INT 303
121936: DOUBLE
121937: EQUAL
121938: IFTRUE 121942
121940: GO 121979
121942: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
121943: LD_VAR 0 6
121947: PPUSH
121948: LD_VAR 0 7
121952: PPUSH
121953: LD_VAR 0 8
121957: PPUSH
121958: LD_VAR 0 9
121962: PPUSH
121963: LD_VAR 0 4
121967: PPUSH
121968: LD_VAR 0 5
121972: PPUSH
121973: CALL 122015 0 6
121977: GO 122010
121979: LD_INT 304
121981: DOUBLE
121982: EQUAL
121983: IFTRUE 121987
121985: GO 122009
121987: POP
// hHackTeleport ( unit , x , y ) ; end ;
121988: LD_VAR 0 2
121992: PPUSH
121993: LD_VAR 0 4
121997: PPUSH
121998: LD_VAR 0 5
122002: PPUSH
122003: CALL 123774 0 3
122007: GO 122010
122009: POP
// end ;
122010: LD_VAR 0 12
122014: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
122015: LD_INT 0
122017: PPUSH
122018: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
122019: LD_VAR 0 1
122023: PUSH
122024: LD_INT 1
122026: LESS
122027: PUSH
122028: LD_VAR 0 1
122032: PUSH
122033: LD_INT 3
122035: GREATER
122036: OR
122037: PUSH
122038: LD_VAR 0 5
122042: PPUSH
122043: LD_VAR 0 6
122047: PPUSH
122048: CALL_OW 428
122052: OR
122053: IFFALSE 122057
// exit ;
122055: GO 122777
// uc_side := your_side ;
122057: LD_ADDR_OWVAR 20
122061: PUSH
122062: LD_OWVAR 2
122066: ST_TO_ADDR
// uc_nation := nation ;
122067: LD_ADDR_OWVAR 21
122071: PUSH
122072: LD_VAR 0 1
122076: ST_TO_ADDR
// bc_level = 1 ;
122077: LD_ADDR_OWVAR 43
122081: PUSH
122082: LD_INT 1
122084: ST_TO_ADDR
// case btype of 1 :
122085: LD_VAR 0 2
122089: PUSH
122090: LD_INT 1
122092: DOUBLE
122093: EQUAL
122094: IFTRUE 122098
122096: GO 122109
122098: POP
// bc_type := b_depot ; 2 :
122099: LD_ADDR_OWVAR 42
122103: PUSH
122104: LD_INT 0
122106: ST_TO_ADDR
122107: GO 122721
122109: LD_INT 2
122111: DOUBLE
122112: EQUAL
122113: IFTRUE 122117
122115: GO 122128
122117: POP
// bc_type := b_warehouse ; 3 :
122118: LD_ADDR_OWVAR 42
122122: PUSH
122123: LD_INT 1
122125: ST_TO_ADDR
122126: GO 122721
122128: LD_INT 3
122130: DOUBLE
122131: EQUAL
122132: IFTRUE 122136
122134: GO 122147
122136: POP
// bc_type := b_lab ; 4 .. 9 :
122137: LD_ADDR_OWVAR 42
122141: PUSH
122142: LD_INT 6
122144: ST_TO_ADDR
122145: GO 122721
122147: LD_INT 4
122149: DOUBLE
122150: GREATEREQUAL
122151: IFFALSE 122159
122153: LD_INT 9
122155: DOUBLE
122156: LESSEQUAL
122157: IFTRUE 122161
122159: GO 122213
122161: POP
// begin bc_type := b_lab_half ;
122162: LD_ADDR_OWVAR 42
122166: PUSH
122167: LD_INT 7
122169: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
122170: LD_ADDR_OWVAR 44
122174: PUSH
122175: LD_INT 10
122177: PUSH
122178: LD_INT 11
122180: PUSH
122181: LD_INT 12
122183: PUSH
122184: LD_INT 15
122186: PUSH
122187: LD_INT 14
122189: PUSH
122190: LD_INT 13
122192: PUSH
122193: EMPTY
122194: LIST
122195: LIST
122196: LIST
122197: LIST
122198: LIST
122199: LIST
122200: PUSH
122201: LD_VAR 0 2
122205: PUSH
122206: LD_INT 3
122208: MINUS
122209: ARRAY
122210: ST_TO_ADDR
// end ; 10 .. 13 :
122211: GO 122721
122213: LD_INT 10
122215: DOUBLE
122216: GREATEREQUAL
122217: IFFALSE 122225
122219: LD_INT 13
122221: DOUBLE
122222: LESSEQUAL
122223: IFTRUE 122227
122225: GO 122304
122227: POP
// begin bc_type := b_lab_full ;
122228: LD_ADDR_OWVAR 42
122232: PUSH
122233: LD_INT 8
122235: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
122236: LD_ADDR_OWVAR 44
122240: PUSH
122241: LD_INT 10
122243: PUSH
122244: LD_INT 12
122246: PUSH
122247: LD_INT 14
122249: PUSH
122250: LD_INT 13
122252: PUSH
122253: EMPTY
122254: LIST
122255: LIST
122256: LIST
122257: LIST
122258: PUSH
122259: LD_VAR 0 2
122263: PUSH
122264: LD_INT 9
122266: MINUS
122267: ARRAY
122268: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
122269: LD_ADDR_OWVAR 45
122273: PUSH
122274: LD_INT 11
122276: PUSH
122277: LD_INT 15
122279: PUSH
122280: LD_INT 12
122282: PUSH
122283: LD_INT 15
122285: PUSH
122286: EMPTY
122287: LIST
122288: LIST
122289: LIST
122290: LIST
122291: PUSH
122292: LD_VAR 0 2
122296: PUSH
122297: LD_INT 9
122299: MINUS
122300: ARRAY
122301: ST_TO_ADDR
// end ; 14 :
122302: GO 122721
122304: LD_INT 14
122306: DOUBLE
122307: EQUAL
122308: IFTRUE 122312
122310: GO 122323
122312: POP
// bc_type := b_workshop ; 15 :
122313: LD_ADDR_OWVAR 42
122317: PUSH
122318: LD_INT 2
122320: ST_TO_ADDR
122321: GO 122721
122323: LD_INT 15
122325: DOUBLE
122326: EQUAL
122327: IFTRUE 122331
122329: GO 122342
122331: POP
// bc_type := b_factory ; 16 :
122332: LD_ADDR_OWVAR 42
122336: PUSH
122337: LD_INT 3
122339: ST_TO_ADDR
122340: GO 122721
122342: LD_INT 16
122344: DOUBLE
122345: EQUAL
122346: IFTRUE 122350
122348: GO 122361
122350: POP
// bc_type := b_ext_gun ; 17 :
122351: LD_ADDR_OWVAR 42
122355: PUSH
122356: LD_INT 17
122358: ST_TO_ADDR
122359: GO 122721
122361: LD_INT 17
122363: DOUBLE
122364: EQUAL
122365: IFTRUE 122369
122367: GO 122397
122369: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
122370: LD_ADDR_OWVAR 42
122374: PUSH
122375: LD_INT 19
122377: PUSH
122378: LD_INT 23
122380: PUSH
122381: LD_INT 19
122383: PUSH
122384: EMPTY
122385: LIST
122386: LIST
122387: LIST
122388: PUSH
122389: LD_VAR 0 1
122393: ARRAY
122394: ST_TO_ADDR
122395: GO 122721
122397: LD_INT 18
122399: DOUBLE
122400: EQUAL
122401: IFTRUE 122405
122403: GO 122416
122405: POP
// bc_type := b_ext_radar ; 19 :
122406: LD_ADDR_OWVAR 42
122410: PUSH
122411: LD_INT 20
122413: ST_TO_ADDR
122414: GO 122721
122416: LD_INT 19
122418: DOUBLE
122419: EQUAL
122420: IFTRUE 122424
122422: GO 122435
122424: POP
// bc_type := b_ext_radio ; 20 :
122425: LD_ADDR_OWVAR 42
122429: PUSH
122430: LD_INT 22
122432: ST_TO_ADDR
122433: GO 122721
122435: LD_INT 20
122437: DOUBLE
122438: EQUAL
122439: IFTRUE 122443
122441: GO 122454
122443: POP
// bc_type := b_ext_siberium ; 21 :
122444: LD_ADDR_OWVAR 42
122448: PUSH
122449: LD_INT 21
122451: ST_TO_ADDR
122452: GO 122721
122454: LD_INT 21
122456: DOUBLE
122457: EQUAL
122458: IFTRUE 122462
122460: GO 122473
122462: POP
// bc_type := b_ext_computer ; 22 :
122463: LD_ADDR_OWVAR 42
122467: PUSH
122468: LD_INT 24
122470: ST_TO_ADDR
122471: GO 122721
122473: LD_INT 22
122475: DOUBLE
122476: EQUAL
122477: IFTRUE 122481
122479: GO 122492
122481: POP
// bc_type := b_ext_track ; 23 :
122482: LD_ADDR_OWVAR 42
122486: PUSH
122487: LD_INT 16
122489: ST_TO_ADDR
122490: GO 122721
122492: LD_INT 23
122494: DOUBLE
122495: EQUAL
122496: IFTRUE 122500
122498: GO 122511
122500: POP
// bc_type := b_ext_laser ; 24 :
122501: LD_ADDR_OWVAR 42
122505: PUSH
122506: LD_INT 25
122508: ST_TO_ADDR
122509: GO 122721
122511: LD_INT 24
122513: DOUBLE
122514: EQUAL
122515: IFTRUE 122519
122517: GO 122530
122519: POP
// bc_type := b_control_tower ; 25 :
122520: LD_ADDR_OWVAR 42
122524: PUSH
122525: LD_INT 36
122527: ST_TO_ADDR
122528: GO 122721
122530: LD_INT 25
122532: DOUBLE
122533: EQUAL
122534: IFTRUE 122538
122536: GO 122549
122538: POP
// bc_type := b_breastwork ; 26 :
122539: LD_ADDR_OWVAR 42
122543: PUSH
122544: LD_INT 31
122546: ST_TO_ADDR
122547: GO 122721
122549: LD_INT 26
122551: DOUBLE
122552: EQUAL
122553: IFTRUE 122557
122555: GO 122568
122557: POP
// bc_type := b_bunker ; 27 :
122558: LD_ADDR_OWVAR 42
122562: PUSH
122563: LD_INT 32
122565: ST_TO_ADDR
122566: GO 122721
122568: LD_INT 27
122570: DOUBLE
122571: EQUAL
122572: IFTRUE 122576
122574: GO 122587
122576: POP
// bc_type := b_turret ; 28 :
122577: LD_ADDR_OWVAR 42
122581: PUSH
122582: LD_INT 33
122584: ST_TO_ADDR
122585: GO 122721
122587: LD_INT 28
122589: DOUBLE
122590: EQUAL
122591: IFTRUE 122595
122593: GO 122606
122595: POP
// bc_type := b_armoury ; 29 :
122596: LD_ADDR_OWVAR 42
122600: PUSH
122601: LD_INT 4
122603: ST_TO_ADDR
122604: GO 122721
122606: LD_INT 29
122608: DOUBLE
122609: EQUAL
122610: IFTRUE 122614
122612: GO 122625
122614: POP
// bc_type := b_barracks ; 30 :
122615: LD_ADDR_OWVAR 42
122619: PUSH
122620: LD_INT 5
122622: ST_TO_ADDR
122623: GO 122721
122625: LD_INT 30
122627: DOUBLE
122628: EQUAL
122629: IFTRUE 122633
122631: GO 122644
122633: POP
// bc_type := b_solar_power ; 31 :
122634: LD_ADDR_OWVAR 42
122638: PUSH
122639: LD_INT 27
122641: ST_TO_ADDR
122642: GO 122721
122644: LD_INT 31
122646: DOUBLE
122647: EQUAL
122648: IFTRUE 122652
122650: GO 122663
122652: POP
// bc_type := b_oil_power ; 32 :
122653: LD_ADDR_OWVAR 42
122657: PUSH
122658: LD_INT 26
122660: ST_TO_ADDR
122661: GO 122721
122663: LD_INT 32
122665: DOUBLE
122666: EQUAL
122667: IFTRUE 122671
122669: GO 122682
122671: POP
// bc_type := b_siberite_power ; 33 :
122672: LD_ADDR_OWVAR 42
122676: PUSH
122677: LD_INT 28
122679: ST_TO_ADDR
122680: GO 122721
122682: LD_INT 33
122684: DOUBLE
122685: EQUAL
122686: IFTRUE 122690
122688: GO 122701
122690: POP
// bc_type := b_oil_mine ; 34 :
122691: LD_ADDR_OWVAR 42
122695: PUSH
122696: LD_INT 29
122698: ST_TO_ADDR
122699: GO 122721
122701: LD_INT 34
122703: DOUBLE
122704: EQUAL
122705: IFTRUE 122709
122707: GO 122720
122709: POP
// bc_type := b_siberite_mine ; end ;
122710: LD_ADDR_OWVAR 42
122714: PUSH
122715: LD_INT 30
122717: ST_TO_ADDR
122718: GO 122721
122720: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
122721: LD_ADDR_VAR 0 8
122725: PUSH
122726: LD_VAR 0 5
122730: PPUSH
122731: LD_VAR 0 6
122735: PPUSH
122736: LD_VAR 0 3
122740: PPUSH
122741: CALL_OW 47
122745: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
122746: LD_OWVAR 42
122750: PUSH
122751: LD_INT 32
122753: PUSH
122754: LD_INT 33
122756: PUSH
122757: EMPTY
122758: LIST
122759: LIST
122760: IN
122761: IFFALSE 122777
// PlaceWeaponTurret ( b , weapon ) ;
122763: LD_VAR 0 8
122767: PPUSH
122768: LD_VAR 0 4
122772: PPUSH
122773: CALL_OW 431
// end ;
122777: LD_VAR 0 7
122781: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
122782: LD_INT 0
122784: PPUSH
122785: PPUSH
122786: PPUSH
122787: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
122788: LD_ADDR_VAR 0 4
122792: PUSH
122793: LD_INT 22
122795: PUSH
122796: LD_OWVAR 2
122800: PUSH
122801: EMPTY
122802: LIST
122803: LIST
122804: PUSH
122805: LD_INT 2
122807: PUSH
122808: LD_INT 30
122810: PUSH
122811: LD_INT 0
122813: PUSH
122814: EMPTY
122815: LIST
122816: LIST
122817: PUSH
122818: LD_INT 30
122820: PUSH
122821: LD_INT 1
122823: PUSH
122824: EMPTY
122825: LIST
122826: LIST
122827: PUSH
122828: EMPTY
122829: LIST
122830: LIST
122831: LIST
122832: PUSH
122833: EMPTY
122834: LIST
122835: LIST
122836: PPUSH
122837: CALL_OW 69
122841: ST_TO_ADDR
// if not tmp then
122842: LD_VAR 0 4
122846: NOT
122847: IFFALSE 122851
// exit ;
122849: GO 122910
// for i in tmp do
122851: LD_ADDR_VAR 0 2
122855: PUSH
122856: LD_VAR 0 4
122860: PUSH
122861: FOR_IN
122862: IFFALSE 122908
// for j = 1 to 3 do
122864: LD_ADDR_VAR 0 3
122868: PUSH
122869: DOUBLE
122870: LD_INT 1
122872: DEC
122873: ST_TO_ADDR
122874: LD_INT 3
122876: PUSH
122877: FOR_TO
122878: IFFALSE 122904
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
122880: LD_VAR 0 2
122884: PPUSH
122885: CALL_OW 274
122889: PPUSH
122890: LD_VAR 0 3
122894: PPUSH
122895: LD_INT 99999
122897: PPUSH
122898: CALL_OW 277
122902: GO 122877
122904: POP
122905: POP
122906: GO 122861
122908: POP
122909: POP
// end ;
122910: LD_VAR 0 1
122914: RET
// export function hHackSetLevel10 ; var i , j ; begin
122915: LD_INT 0
122917: PPUSH
122918: PPUSH
122919: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
122920: LD_ADDR_VAR 0 2
122924: PUSH
122925: LD_INT 21
122927: PUSH
122928: LD_INT 1
122930: PUSH
122931: EMPTY
122932: LIST
122933: LIST
122934: PPUSH
122935: CALL_OW 69
122939: PUSH
122940: FOR_IN
122941: IFFALSE 122993
// if IsSelected ( i ) then
122943: LD_VAR 0 2
122947: PPUSH
122948: CALL_OW 306
122952: IFFALSE 122991
// begin for j := 1 to 4 do
122954: LD_ADDR_VAR 0 3
122958: PUSH
122959: DOUBLE
122960: LD_INT 1
122962: DEC
122963: ST_TO_ADDR
122964: LD_INT 4
122966: PUSH
122967: FOR_TO
122968: IFFALSE 122989
// SetSkill ( i , j , 10 ) ;
122970: LD_VAR 0 2
122974: PPUSH
122975: LD_VAR 0 3
122979: PPUSH
122980: LD_INT 10
122982: PPUSH
122983: CALL_OW 237
122987: GO 122967
122989: POP
122990: POP
// end ;
122991: GO 122940
122993: POP
122994: POP
// end ;
122995: LD_VAR 0 1
122999: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
123000: LD_INT 0
123002: PPUSH
123003: PPUSH
123004: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
123005: LD_ADDR_VAR 0 2
123009: PUSH
123010: LD_INT 22
123012: PUSH
123013: LD_OWVAR 2
123017: PUSH
123018: EMPTY
123019: LIST
123020: LIST
123021: PUSH
123022: LD_INT 21
123024: PUSH
123025: LD_INT 1
123027: PUSH
123028: EMPTY
123029: LIST
123030: LIST
123031: PUSH
123032: EMPTY
123033: LIST
123034: LIST
123035: PPUSH
123036: CALL_OW 69
123040: PUSH
123041: FOR_IN
123042: IFFALSE 123083
// begin for j := 1 to 4 do
123044: LD_ADDR_VAR 0 3
123048: PUSH
123049: DOUBLE
123050: LD_INT 1
123052: DEC
123053: ST_TO_ADDR
123054: LD_INT 4
123056: PUSH
123057: FOR_TO
123058: IFFALSE 123079
// SetSkill ( i , j , 10 ) ;
123060: LD_VAR 0 2
123064: PPUSH
123065: LD_VAR 0 3
123069: PPUSH
123070: LD_INT 10
123072: PPUSH
123073: CALL_OW 237
123077: GO 123057
123079: POP
123080: POP
// end ;
123081: GO 123041
123083: POP
123084: POP
// end ;
123085: LD_VAR 0 1
123089: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
123090: LD_INT 0
123092: PPUSH
// uc_side := your_side ;
123093: LD_ADDR_OWVAR 20
123097: PUSH
123098: LD_OWVAR 2
123102: ST_TO_ADDR
// uc_nation := nation ;
123103: LD_ADDR_OWVAR 21
123107: PUSH
123108: LD_VAR 0 1
123112: ST_TO_ADDR
// InitHc ;
123113: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
123117: LD_INT 0
123119: PPUSH
123120: LD_VAR 0 2
123124: PPUSH
123125: LD_VAR 0 3
123129: PPUSH
123130: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
123134: LD_VAR 0 4
123138: PPUSH
123139: LD_VAR 0 5
123143: PPUSH
123144: CALL_OW 428
123148: PUSH
123149: LD_INT 0
123151: EQUAL
123152: IFFALSE 123176
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
123154: CALL_OW 44
123158: PPUSH
123159: LD_VAR 0 4
123163: PPUSH
123164: LD_VAR 0 5
123168: PPUSH
123169: LD_INT 1
123171: PPUSH
123172: CALL_OW 48
// end ;
123176: LD_VAR 0 6
123180: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
123181: LD_INT 0
123183: PPUSH
123184: PPUSH
// uc_side := your_side ;
123185: LD_ADDR_OWVAR 20
123189: PUSH
123190: LD_OWVAR 2
123194: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
123195: LD_VAR 0 1
123199: PUSH
123200: LD_INT 1
123202: PUSH
123203: LD_INT 2
123205: PUSH
123206: LD_INT 3
123208: PUSH
123209: LD_INT 4
123211: PUSH
123212: LD_INT 5
123214: PUSH
123215: EMPTY
123216: LIST
123217: LIST
123218: LIST
123219: LIST
123220: LIST
123221: IN
123222: IFFALSE 123234
// uc_nation := nation_american else
123224: LD_ADDR_OWVAR 21
123228: PUSH
123229: LD_INT 1
123231: ST_TO_ADDR
123232: GO 123277
// if chassis in [ 11 , 12 , 13 , 14 ] then
123234: LD_VAR 0 1
123238: PUSH
123239: LD_INT 11
123241: PUSH
123242: LD_INT 12
123244: PUSH
123245: LD_INT 13
123247: PUSH
123248: LD_INT 14
123250: PUSH
123251: EMPTY
123252: LIST
123253: LIST
123254: LIST
123255: LIST
123256: IN
123257: IFFALSE 123269
// uc_nation := nation_arabian else
123259: LD_ADDR_OWVAR 21
123263: PUSH
123264: LD_INT 2
123266: ST_TO_ADDR
123267: GO 123277
// uc_nation := nation_russian ;
123269: LD_ADDR_OWVAR 21
123273: PUSH
123274: LD_INT 3
123276: ST_TO_ADDR
// vc_chassis := chassis ;
123277: LD_ADDR_OWVAR 37
123281: PUSH
123282: LD_VAR 0 1
123286: ST_TO_ADDR
// vc_engine := engine ;
123287: LD_ADDR_OWVAR 39
123291: PUSH
123292: LD_VAR 0 2
123296: ST_TO_ADDR
// vc_control := control ;
123297: LD_ADDR_OWVAR 38
123301: PUSH
123302: LD_VAR 0 3
123306: ST_TO_ADDR
// vc_weapon := weapon ;
123307: LD_ADDR_OWVAR 40
123311: PUSH
123312: LD_VAR 0 4
123316: ST_TO_ADDR
// un := CreateVehicle ;
123317: LD_ADDR_VAR 0 8
123321: PUSH
123322: CALL_OW 45
123326: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
123327: LD_VAR 0 8
123331: PPUSH
123332: LD_INT 0
123334: PPUSH
123335: LD_INT 5
123337: PPUSH
123338: CALL_OW 12
123342: PPUSH
123343: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
123347: LD_VAR 0 8
123351: PPUSH
123352: LD_VAR 0 5
123356: PPUSH
123357: LD_VAR 0 6
123361: PPUSH
123362: LD_INT 1
123364: PPUSH
123365: CALL_OW 48
// end ;
123369: LD_VAR 0 7
123373: RET
// export hInvincible ; every 1 do
123374: GO 123376
123376: DISABLE
// hInvincible := [ ] ;
123377: LD_ADDR_EXP 203
123381: PUSH
123382: EMPTY
123383: ST_TO_ADDR
123384: END
// every 10 do var i ;
123385: GO 123387
123387: DISABLE
123388: LD_INT 0
123390: PPUSH
// begin enable ;
123391: ENABLE
// if not hInvincible then
123392: LD_EXP 203
123396: NOT
123397: IFFALSE 123401
// exit ;
123399: GO 123445
// for i in hInvincible do
123401: LD_ADDR_VAR 0 1
123405: PUSH
123406: LD_EXP 203
123410: PUSH
123411: FOR_IN
123412: IFFALSE 123443
// if GetLives ( i ) < 1000 then
123414: LD_VAR 0 1
123418: PPUSH
123419: CALL_OW 256
123423: PUSH
123424: LD_INT 1000
123426: LESS
123427: IFFALSE 123441
// SetLives ( i , 1000 ) ;
123429: LD_VAR 0 1
123433: PPUSH
123434: LD_INT 1000
123436: PPUSH
123437: CALL_OW 234
123441: GO 123411
123443: POP
123444: POP
// end ;
123445: PPOPN 1
123447: END
// export function hHackInvincible ; var i ; begin
123448: LD_INT 0
123450: PPUSH
123451: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
123452: LD_ADDR_VAR 0 2
123456: PUSH
123457: LD_INT 2
123459: PUSH
123460: LD_INT 21
123462: PUSH
123463: LD_INT 1
123465: PUSH
123466: EMPTY
123467: LIST
123468: LIST
123469: PUSH
123470: LD_INT 21
123472: PUSH
123473: LD_INT 2
123475: PUSH
123476: EMPTY
123477: LIST
123478: LIST
123479: PUSH
123480: EMPTY
123481: LIST
123482: LIST
123483: LIST
123484: PPUSH
123485: CALL_OW 69
123489: PUSH
123490: FOR_IN
123491: IFFALSE 123552
// if IsSelected ( i ) then
123493: LD_VAR 0 2
123497: PPUSH
123498: CALL_OW 306
123502: IFFALSE 123550
// begin if i in hInvincible then
123504: LD_VAR 0 2
123508: PUSH
123509: LD_EXP 203
123513: IN
123514: IFFALSE 123534
// hInvincible := hInvincible diff i else
123516: LD_ADDR_EXP 203
123520: PUSH
123521: LD_EXP 203
123525: PUSH
123526: LD_VAR 0 2
123530: DIFF
123531: ST_TO_ADDR
123532: GO 123550
// hInvincible := hInvincible union i ;
123534: LD_ADDR_EXP 203
123538: PUSH
123539: LD_EXP 203
123543: PUSH
123544: LD_VAR 0 2
123548: UNION
123549: ST_TO_ADDR
// end ;
123550: GO 123490
123552: POP
123553: POP
// end ;
123554: LD_VAR 0 1
123558: RET
// export function hHackInvisible ; var i , j ; begin
123559: LD_INT 0
123561: PPUSH
123562: PPUSH
123563: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
123564: LD_ADDR_VAR 0 2
123568: PUSH
123569: LD_INT 21
123571: PUSH
123572: LD_INT 1
123574: PUSH
123575: EMPTY
123576: LIST
123577: LIST
123578: PPUSH
123579: CALL_OW 69
123583: PUSH
123584: FOR_IN
123585: IFFALSE 123609
// if IsSelected ( i ) then
123587: LD_VAR 0 2
123591: PPUSH
123592: CALL_OW 306
123596: IFFALSE 123607
// ComForceInvisible ( i ) ;
123598: LD_VAR 0 2
123602: PPUSH
123603: CALL_OW 496
123607: GO 123584
123609: POP
123610: POP
// end ;
123611: LD_VAR 0 1
123615: RET
// export function hHackChangeYourSide ; begin
123616: LD_INT 0
123618: PPUSH
// if your_side = 8 then
123619: LD_OWVAR 2
123623: PUSH
123624: LD_INT 8
123626: EQUAL
123627: IFFALSE 123639
// your_side := 0 else
123629: LD_ADDR_OWVAR 2
123633: PUSH
123634: LD_INT 0
123636: ST_TO_ADDR
123637: GO 123653
// your_side := your_side + 1 ;
123639: LD_ADDR_OWVAR 2
123643: PUSH
123644: LD_OWVAR 2
123648: PUSH
123649: LD_INT 1
123651: PLUS
123652: ST_TO_ADDR
// end ;
123653: LD_VAR 0 1
123657: RET
// export function hHackChangeUnitSide ; var i , j ; begin
123658: LD_INT 0
123660: PPUSH
123661: PPUSH
123662: PPUSH
// for i in all_units do
123663: LD_ADDR_VAR 0 2
123667: PUSH
123668: LD_OWVAR 3
123672: PUSH
123673: FOR_IN
123674: IFFALSE 123752
// if IsSelected ( i ) then
123676: LD_VAR 0 2
123680: PPUSH
123681: CALL_OW 306
123685: IFFALSE 123750
// begin j := GetSide ( i ) ;
123687: LD_ADDR_VAR 0 3
123691: PUSH
123692: LD_VAR 0 2
123696: PPUSH
123697: CALL_OW 255
123701: ST_TO_ADDR
// if j = 8 then
123702: LD_VAR 0 3
123706: PUSH
123707: LD_INT 8
123709: EQUAL
123710: IFFALSE 123722
// j := 0 else
123712: LD_ADDR_VAR 0 3
123716: PUSH
123717: LD_INT 0
123719: ST_TO_ADDR
123720: GO 123736
// j := j + 1 ;
123722: LD_ADDR_VAR 0 3
123726: PUSH
123727: LD_VAR 0 3
123731: PUSH
123732: LD_INT 1
123734: PLUS
123735: ST_TO_ADDR
// SetSide ( i , j ) ;
123736: LD_VAR 0 2
123740: PPUSH
123741: LD_VAR 0 3
123745: PPUSH
123746: CALL_OW 235
// end ;
123750: GO 123673
123752: POP
123753: POP
// end ;
123754: LD_VAR 0 1
123758: RET
// export function hHackFog ; begin
123759: LD_INT 0
123761: PPUSH
// FogOff ( true ) ;
123762: LD_INT 1
123764: PPUSH
123765: CALL_OW 344
// end ;
123769: LD_VAR 0 1
123773: RET
// export function hHackTeleport ( unit , x , y ) ; begin
123774: LD_INT 0
123776: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
123777: LD_VAR 0 1
123781: PPUSH
123782: LD_VAR 0 2
123786: PPUSH
123787: LD_VAR 0 3
123791: PPUSH
123792: LD_INT 1
123794: PPUSH
123795: LD_INT 1
123797: PPUSH
123798: CALL_OW 483
// CenterOnXY ( x , y ) ;
123802: LD_VAR 0 2
123806: PPUSH
123807: LD_VAR 0 3
123811: PPUSH
123812: CALL_OW 84
// end ;
123816: LD_VAR 0 4
123820: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
123821: LD_INT 0
123823: PPUSH
123824: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
123825: LD_VAR 0 1
123829: NOT
123830: PUSH
123831: LD_VAR 0 2
123835: PPUSH
123836: LD_VAR 0 3
123840: PPUSH
123841: CALL_OW 488
123845: NOT
123846: OR
123847: PUSH
123848: LD_VAR 0 1
123852: PPUSH
123853: CALL_OW 266
123857: PUSH
123858: LD_INT 3
123860: NONEQUAL
123861: PUSH
123862: LD_VAR 0 1
123866: PPUSH
123867: CALL_OW 247
123871: PUSH
123872: LD_INT 1
123874: EQUAL
123875: NOT
123876: AND
123877: OR
123878: IFFALSE 123882
// exit ;
123880: GO 124031
// if GetType ( factory ) = unit_human then
123882: LD_VAR 0 1
123886: PPUSH
123887: CALL_OW 247
123891: PUSH
123892: LD_INT 1
123894: EQUAL
123895: IFFALSE 123912
// factory := IsInUnit ( factory ) ;
123897: LD_ADDR_VAR 0 1
123901: PUSH
123902: LD_VAR 0 1
123906: PPUSH
123907: CALL_OW 310
123911: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
123912: LD_VAR 0 1
123916: PPUSH
123917: CALL_OW 266
123921: PUSH
123922: LD_INT 3
123924: NONEQUAL
123925: IFFALSE 123929
// exit ;
123927: GO 124031
// if HexInfo ( x , y ) = factory then
123929: LD_VAR 0 2
123933: PPUSH
123934: LD_VAR 0 3
123938: PPUSH
123939: CALL_OW 428
123943: PUSH
123944: LD_VAR 0 1
123948: EQUAL
123949: IFFALSE 123976
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
123951: LD_ADDR_EXP 204
123955: PUSH
123956: LD_EXP 204
123960: PPUSH
123961: LD_VAR 0 1
123965: PPUSH
123966: LD_INT 0
123968: PPUSH
123969: CALL_OW 1
123973: ST_TO_ADDR
123974: GO 124027
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
123976: LD_ADDR_EXP 204
123980: PUSH
123981: LD_EXP 204
123985: PPUSH
123986: LD_VAR 0 1
123990: PPUSH
123991: LD_VAR 0 1
123995: PPUSH
123996: CALL_OW 255
124000: PUSH
124001: LD_VAR 0 1
124005: PUSH
124006: LD_VAR 0 2
124010: PUSH
124011: LD_VAR 0 3
124015: PUSH
124016: EMPTY
124017: LIST
124018: LIST
124019: LIST
124020: LIST
124021: PPUSH
124022: CALL_OW 1
124026: ST_TO_ADDR
// UpdateFactoryWaypoints ;
124027: CALL 124036 0 0
// end ;
124031: LD_VAR 0 4
124035: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
124036: LD_INT 0
124038: PPUSH
124039: PPUSH
124040: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
124041: LD_STRING resetFactoryWaypoint();
124043: PPUSH
124044: CALL_OW 559
// if factoryWaypoints then
124048: LD_EXP 204
124052: IFFALSE 124178
// begin list := PrepareArray ( factoryWaypoints ) ;
124054: LD_ADDR_VAR 0 3
124058: PUSH
124059: LD_EXP 204
124063: PPUSH
124064: CALL 109024 0 1
124068: ST_TO_ADDR
// for i := 1 to list do
124069: LD_ADDR_VAR 0 2
124073: PUSH
124074: DOUBLE
124075: LD_INT 1
124077: DEC
124078: ST_TO_ADDR
124079: LD_VAR 0 3
124083: PUSH
124084: FOR_TO
124085: IFFALSE 124176
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
124087: LD_STRING setFactoryWaypointXY(
124089: PUSH
124090: LD_VAR 0 3
124094: PUSH
124095: LD_VAR 0 2
124099: ARRAY
124100: PUSH
124101: LD_INT 1
124103: ARRAY
124104: STR
124105: PUSH
124106: LD_STRING ,
124108: STR
124109: PUSH
124110: LD_VAR 0 3
124114: PUSH
124115: LD_VAR 0 2
124119: ARRAY
124120: PUSH
124121: LD_INT 2
124123: ARRAY
124124: STR
124125: PUSH
124126: LD_STRING ,
124128: STR
124129: PUSH
124130: LD_VAR 0 3
124134: PUSH
124135: LD_VAR 0 2
124139: ARRAY
124140: PUSH
124141: LD_INT 3
124143: ARRAY
124144: STR
124145: PUSH
124146: LD_STRING ,
124148: STR
124149: PUSH
124150: LD_VAR 0 3
124154: PUSH
124155: LD_VAR 0 2
124159: ARRAY
124160: PUSH
124161: LD_INT 4
124163: ARRAY
124164: STR
124165: PUSH
124166: LD_STRING )
124168: STR
124169: PPUSH
124170: CALL_OW 559
124174: GO 124084
124176: POP
124177: POP
// end ; end ;
124178: LD_VAR 0 1
124182: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
124183: LD_INT 0
124185: PPUSH
// if HexInfo ( x , y ) = warehouse then
124186: LD_VAR 0 2
124190: PPUSH
124191: LD_VAR 0 3
124195: PPUSH
124196: CALL_OW 428
124200: PUSH
124201: LD_VAR 0 1
124205: EQUAL
124206: IFFALSE 124233
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
124208: LD_ADDR_EXP 205
124212: PUSH
124213: LD_EXP 205
124217: PPUSH
124218: LD_VAR 0 1
124222: PPUSH
124223: LD_INT 0
124225: PPUSH
124226: CALL_OW 1
124230: ST_TO_ADDR
124231: GO 124284
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
124233: LD_ADDR_EXP 205
124237: PUSH
124238: LD_EXP 205
124242: PPUSH
124243: LD_VAR 0 1
124247: PPUSH
124248: LD_VAR 0 1
124252: PPUSH
124253: CALL_OW 255
124257: PUSH
124258: LD_VAR 0 1
124262: PUSH
124263: LD_VAR 0 2
124267: PUSH
124268: LD_VAR 0 3
124272: PUSH
124273: EMPTY
124274: LIST
124275: LIST
124276: LIST
124277: LIST
124278: PPUSH
124279: CALL_OW 1
124283: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
124284: CALL 124293 0 0
// end ;
124288: LD_VAR 0 4
124292: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
124293: LD_INT 0
124295: PPUSH
124296: PPUSH
124297: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
124298: LD_STRING resetWarehouseGatheringPoints();
124300: PPUSH
124301: CALL_OW 559
// if warehouseGatheringPoints then
124305: LD_EXP 205
124309: IFFALSE 124435
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
124311: LD_ADDR_VAR 0 3
124315: PUSH
124316: LD_EXP 205
124320: PPUSH
124321: CALL 109024 0 1
124325: ST_TO_ADDR
// for i := 1 to list do
124326: LD_ADDR_VAR 0 2
124330: PUSH
124331: DOUBLE
124332: LD_INT 1
124334: DEC
124335: ST_TO_ADDR
124336: LD_VAR 0 3
124340: PUSH
124341: FOR_TO
124342: IFFALSE 124433
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
124344: LD_STRING setWarehouseGatheringPointXY(
124346: PUSH
124347: LD_VAR 0 3
124351: PUSH
124352: LD_VAR 0 2
124356: ARRAY
124357: PUSH
124358: LD_INT 1
124360: ARRAY
124361: STR
124362: PUSH
124363: LD_STRING ,
124365: STR
124366: PUSH
124367: LD_VAR 0 3
124371: PUSH
124372: LD_VAR 0 2
124376: ARRAY
124377: PUSH
124378: LD_INT 2
124380: ARRAY
124381: STR
124382: PUSH
124383: LD_STRING ,
124385: STR
124386: PUSH
124387: LD_VAR 0 3
124391: PUSH
124392: LD_VAR 0 2
124396: ARRAY
124397: PUSH
124398: LD_INT 3
124400: ARRAY
124401: STR
124402: PUSH
124403: LD_STRING ,
124405: STR
124406: PUSH
124407: LD_VAR 0 3
124411: PUSH
124412: LD_VAR 0 2
124416: ARRAY
124417: PUSH
124418: LD_INT 4
124420: ARRAY
124421: STR
124422: PUSH
124423: LD_STRING )
124425: STR
124426: PPUSH
124427: CALL_OW 559
124431: GO 124341
124433: POP
124434: POP
// end ; end ;
124435: LD_VAR 0 1
124439: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
124440: LD_EXP 205
124444: IFFALSE 125129
124446: GO 124448
124448: DISABLE
124449: LD_INT 0
124451: PPUSH
124452: PPUSH
124453: PPUSH
124454: PPUSH
124455: PPUSH
124456: PPUSH
124457: PPUSH
124458: PPUSH
124459: PPUSH
// begin enable ;
124460: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
124461: LD_ADDR_VAR 0 3
124465: PUSH
124466: LD_EXP 205
124470: PPUSH
124471: CALL 109024 0 1
124475: ST_TO_ADDR
// if not list then
124476: LD_VAR 0 3
124480: NOT
124481: IFFALSE 124485
// exit ;
124483: GO 125129
// for i := 1 to list do
124485: LD_ADDR_VAR 0 1
124489: PUSH
124490: DOUBLE
124491: LD_INT 1
124493: DEC
124494: ST_TO_ADDR
124495: LD_VAR 0 3
124499: PUSH
124500: FOR_TO
124501: IFFALSE 125127
// begin depot := list [ i ] [ 2 ] ;
124503: LD_ADDR_VAR 0 8
124507: PUSH
124508: LD_VAR 0 3
124512: PUSH
124513: LD_VAR 0 1
124517: ARRAY
124518: PUSH
124519: LD_INT 2
124521: ARRAY
124522: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
124523: LD_ADDR_VAR 0 5
124527: PUSH
124528: LD_VAR 0 3
124532: PUSH
124533: LD_VAR 0 1
124537: ARRAY
124538: PUSH
124539: LD_INT 1
124541: ARRAY
124542: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
124543: LD_VAR 0 8
124547: PPUSH
124548: CALL_OW 301
124552: PUSH
124553: LD_VAR 0 5
124557: PUSH
124558: LD_VAR 0 8
124562: PPUSH
124563: CALL_OW 255
124567: NONEQUAL
124568: OR
124569: IFFALSE 124598
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
124571: LD_ADDR_EXP 205
124575: PUSH
124576: LD_EXP 205
124580: PPUSH
124581: LD_VAR 0 8
124585: PPUSH
124586: LD_INT 0
124588: PPUSH
124589: CALL_OW 1
124593: ST_TO_ADDR
// exit ;
124594: POP
124595: POP
124596: GO 125129
// end ; x := list [ i ] [ 3 ] ;
124598: LD_ADDR_VAR 0 6
124602: PUSH
124603: LD_VAR 0 3
124607: PUSH
124608: LD_VAR 0 1
124612: ARRAY
124613: PUSH
124614: LD_INT 3
124616: ARRAY
124617: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
124618: LD_ADDR_VAR 0 7
124622: PUSH
124623: LD_VAR 0 3
124627: PUSH
124628: LD_VAR 0 1
124632: ARRAY
124633: PUSH
124634: LD_INT 4
124636: ARRAY
124637: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
124638: LD_ADDR_VAR 0 9
124642: PUSH
124643: LD_VAR 0 6
124647: PPUSH
124648: LD_VAR 0 7
124652: PPUSH
124653: LD_INT 16
124655: PPUSH
124656: CALL 107612 0 3
124660: ST_TO_ADDR
// if not cratesNearbyPoint then
124661: LD_VAR 0 9
124665: NOT
124666: IFFALSE 124672
// exit ;
124668: POP
124669: POP
124670: GO 125129
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
124672: LD_ADDR_VAR 0 4
124676: PUSH
124677: LD_INT 22
124679: PUSH
124680: LD_VAR 0 5
124684: PUSH
124685: EMPTY
124686: LIST
124687: LIST
124688: PUSH
124689: LD_INT 3
124691: PUSH
124692: LD_INT 60
124694: PUSH
124695: EMPTY
124696: LIST
124697: PUSH
124698: EMPTY
124699: LIST
124700: LIST
124701: PUSH
124702: LD_INT 91
124704: PUSH
124705: LD_VAR 0 8
124709: PUSH
124710: LD_INT 6
124712: PUSH
124713: EMPTY
124714: LIST
124715: LIST
124716: LIST
124717: PUSH
124718: LD_INT 2
124720: PUSH
124721: LD_INT 25
124723: PUSH
124724: LD_INT 2
124726: PUSH
124727: EMPTY
124728: LIST
124729: LIST
124730: PUSH
124731: LD_INT 25
124733: PUSH
124734: LD_INT 16
124736: PUSH
124737: EMPTY
124738: LIST
124739: LIST
124740: PUSH
124741: EMPTY
124742: LIST
124743: LIST
124744: LIST
124745: PUSH
124746: EMPTY
124747: LIST
124748: LIST
124749: LIST
124750: LIST
124751: PPUSH
124752: CALL_OW 69
124756: PUSH
124757: LD_VAR 0 8
124761: PPUSH
124762: CALL_OW 313
124766: PPUSH
124767: LD_INT 3
124769: PUSH
124770: LD_INT 60
124772: PUSH
124773: EMPTY
124774: LIST
124775: PUSH
124776: EMPTY
124777: LIST
124778: LIST
124779: PUSH
124780: LD_INT 2
124782: PUSH
124783: LD_INT 25
124785: PUSH
124786: LD_INT 2
124788: PUSH
124789: EMPTY
124790: LIST
124791: LIST
124792: PUSH
124793: LD_INT 25
124795: PUSH
124796: LD_INT 16
124798: PUSH
124799: EMPTY
124800: LIST
124801: LIST
124802: PUSH
124803: EMPTY
124804: LIST
124805: LIST
124806: LIST
124807: PUSH
124808: EMPTY
124809: LIST
124810: LIST
124811: PPUSH
124812: CALL_OW 72
124816: UNION
124817: ST_TO_ADDR
// if tmp then
124818: LD_VAR 0 4
124822: IFFALSE 124902
// begin tmp := ShrinkArray ( tmp , 3 ) ;
124824: LD_ADDR_VAR 0 4
124828: PUSH
124829: LD_VAR 0 4
124833: PPUSH
124834: LD_INT 3
124836: PPUSH
124837: CALL 105581 0 2
124841: ST_TO_ADDR
// for j in tmp do
124842: LD_ADDR_VAR 0 2
124846: PUSH
124847: LD_VAR 0 4
124851: PUSH
124852: FOR_IN
124853: IFFALSE 124896
// begin if IsInUnit ( j ) then
124855: LD_VAR 0 2
124859: PPUSH
124860: CALL_OW 310
124864: IFFALSE 124875
// ComExit ( j ) ;
124866: LD_VAR 0 2
124870: PPUSH
124871: CALL 105664 0 1
// AddComCollect ( j , x , y ) ;
124875: LD_VAR 0 2
124879: PPUSH
124880: LD_VAR 0 6
124884: PPUSH
124885: LD_VAR 0 7
124889: PPUSH
124890: CALL_OW 177
// end ;
124894: GO 124852
124896: POP
124897: POP
// exit ;
124898: POP
124899: POP
124900: GO 125129
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
124902: LD_ADDR_VAR 0 4
124906: PUSH
124907: LD_INT 22
124909: PUSH
124910: LD_VAR 0 5
124914: PUSH
124915: EMPTY
124916: LIST
124917: LIST
124918: PUSH
124919: LD_INT 91
124921: PUSH
124922: LD_VAR 0 8
124926: PUSH
124927: LD_INT 8
124929: PUSH
124930: EMPTY
124931: LIST
124932: LIST
124933: LIST
124934: PUSH
124935: LD_INT 2
124937: PUSH
124938: LD_INT 34
124940: PUSH
124941: LD_INT 12
124943: PUSH
124944: EMPTY
124945: LIST
124946: LIST
124947: PUSH
124948: LD_INT 34
124950: PUSH
124951: LD_INT 51
124953: PUSH
124954: EMPTY
124955: LIST
124956: LIST
124957: PUSH
124958: LD_INT 34
124960: PUSH
124961: LD_INT 32
124963: PUSH
124964: EMPTY
124965: LIST
124966: LIST
124967: PUSH
124968: LD_INT 34
124970: PUSH
124971: LD_INT 89
124973: PUSH
124974: EMPTY
124975: LIST
124976: LIST
124977: PUSH
124978: EMPTY
124979: LIST
124980: LIST
124981: LIST
124982: LIST
124983: LIST
124984: PUSH
124985: EMPTY
124986: LIST
124987: LIST
124988: LIST
124989: PPUSH
124990: CALL_OW 69
124994: ST_TO_ADDR
// if tmp then
124995: LD_VAR 0 4
124999: IFFALSE 125125
// begin for j in tmp do
125001: LD_ADDR_VAR 0 2
125005: PUSH
125006: LD_VAR 0 4
125010: PUSH
125011: FOR_IN
125012: IFFALSE 125123
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
125014: LD_VAR 0 2
125018: PPUSH
125019: CALL_OW 262
125023: PUSH
125024: LD_INT 3
125026: EQUAL
125027: PUSH
125028: LD_VAR 0 2
125032: PPUSH
125033: CALL_OW 261
125037: PUSH
125038: LD_INT 20
125040: GREATER
125041: OR
125042: PUSH
125043: LD_VAR 0 2
125047: PPUSH
125048: CALL_OW 314
125052: NOT
125053: AND
125054: PUSH
125055: LD_VAR 0 2
125059: PPUSH
125060: CALL_OW 263
125064: PUSH
125065: LD_INT 1
125067: NONEQUAL
125068: PUSH
125069: LD_VAR 0 2
125073: PPUSH
125074: CALL_OW 311
125078: OR
125079: AND
125080: IFFALSE 125121
// begin ComCollect ( j , x , y ) ;
125082: LD_VAR 0 2
125086: PPUSH
125087: LD_VAR 0 6
125091: PPUSH
125092: LD_VAR 0 7
125096: PPUSH
125097: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
125101: LD_VAR 0 2
125105: PPUSH
125106: LD_VAR 0 8
125110: PPUSH
125111: CALL_OW 172
// exit ;
125115: POP
125116: POP
125117: POP
125118: POP
125119: GO 125129
// end ;
125121: GO 125011
125123: POP
125124: POP
// end ; end ;
125125: GO 124500
125127: POP
125128: POP
// end ; end_of_file
125129: PPOPN 9
125131: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
125132: LD_INT 0
125134: PPUSH
125135: PPUSH
125136: PPUSH
125137: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
125138: LD_VAR 0 1
125142: PPUSH
125143: CALL_OW 264
125147: PUSH
125148: LD_INT 91
125150: EQUAL
125151: IFFALSE 125223
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
125153: LD_INT 68
125155: PPUSH
125156: LD_VAR 0 1
125160: PPUSH
125161: CALL_OW 255
125165: PPUSH
125166: CALL_OW 321
125170: PUSH
125171: LD_INT 2
125173: EQUAL
125174: IFFALSE 125186
// eff := 70 else
125176: LD_ADDR_VAR 0 4
125180: PUSH
125181: LD_INT 70
125183: ST_TO_ADDR
125184: GO 125194
// eff := 30 ;
125186: LD_ADDR_VAR 0 4
125190: PUSH
125191: LD_INT 30
125193: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
125194: LD_VAR 0 1
125198: PPUSH
125199: CALL_OW 250
125203: PPUSH
125204: LD_VAR 0 1
125208: PPUSH
125209: CALL_OW 251
125213: PPUSH
125214: LD_VAR 0 4
125218: PPUSH
125219: CALL_OW 495
// end ; end ;
125223: LD_VAR 0 2
125227: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
125228: LD_INT 0
125230: PPUSH
// end ;
125231: LD_VAR 0 4
125235: RET
// export function SOS_Command ( cmd ) ; begin
125236: LD_INT 0
125238: PPUSH
// end ;
125239: LD_VAR 0 2
125243: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
125244: LD_INT 0
125246: PPUSH
// end ;
125247: LD_VAR 0 6
125251: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
125252: LD_INT 0
125254: PPUSH
125255: PPUSH
// if not vehicle or not factory then
125256: LD_VAR 0 1
125260: NOT
125261: PUSH
125262: LD_VAR 0 2
125266: NOT
125267: OR
125268: IFFALSE 125272
// exit ;
125270: GO 125503
// if factoryWaypoints >= factory then
125272: LD_EXP 204
125276: PUSH
125277: LD_VAR 0 2
125281: GREATEREQUAL
125282: IFFALSE 125503
// if factoryWaypoints [ factory ] then
125284: LD_EXP 204
125288: PUSH
125289: LD_VAR 0 2
125293: ARRAY
125294: IFFALSE 125503
// begin if GetControl ( vehicle ) = control_manual then
125296: LD_VAR 0 1
125300: PPUSH
125301: CALL_OW 263
125305: PUSH
125306: LD_INT 1
125308: EQUAL
125309: IFFALSE 125390
// begin driver := IsDrivenBy ( vehicle ) ;
125311: LD_ADDR_VAR 0 4
125315: PUSH
125316: LD_VAR 0 1
125320: PPUSH
125321: CALL_OW 311
125325: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
125326: LD_VAR 0 4
125330: PPUSH
125331: LD_EXP 204
125335: PUSH
125336: LD_VAR 0 2
125340: ARRAY
125341: PUSH
125342: LD_INT 3
125344: ARRAY
125345: PPUSH
125346: LD_EXP 204
125350: PUSH
125351: LD_VAR 0 2
125355: ARRAY
125356: PUSH
125357: LD_INT 4
125359: ARRAY
125360: PPUSH
125361: CALL_OW 171
// AddComExitVehicle ( driver ) ;
125365: LD_VAR 0 4
125369: PPUSH
125370: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
125374: LD_VAR 0 4
125378: PPUSH
125379: LD_VAR 0 2
125383: PPUSH
125384: CALL_OW 180
// end else
125388: GO 125503
// if GetControl ( vehicle ) = control_remote then
125390: LD_VAR 0 1
125394: PPUSH
125395: CALL_OW 263
125399: PUSH
125400: LD_INT 2
125402: EQUAL
125403: IFFALSE 125464
// begin wait ( 0 0$2 ) ;
125405: LD_INT 70
125407: PPUSH
125408: CALL_OW 67
// if Connect ( vehicle ) then
125412: LD_VAR 0 1
125416: PPUSH
125417: CALL 75905 0 1
125421: IFFALSE 125462
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
125423: LD_VAR 0 1
125427: PPUSH
125428: LD_EXP 204
125432: PUSH
125433: LD_VAR 0 2
125437: ARRAY
125438: PUSH
125439: LD_INT 3
125441: ARRAY
125442: PPUSH
125443: LD_EXP 204
125447: PUSH
125448: LD_VAR 0 2
125452: ARRAY
125453: PUSH
125454: LD_INT 4
125456: ARRAY
125457: PPUSH
125458: CALL_OW 171
// end else
125462: GO 125503
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
125464: LD_VAR 0 1
125468: PPUSH
125469: LD_EXP 204
125473: PUSH
125474: LD_VAR 0 2
125478: ARRAY
125479: PUSH
125480: LD_INT 3
125482: ARRAY
125483: PPUSH
125484: LD_EXP 204
125488: PUSH
125489: LD_VAR 0 2
125493: ARRAY
125494: PUSH
125495: LD_INT 4
125497: ARRAY
125498: PPUSH
125499: CALL_OW 171
// end ; end ;
125503: LD_VAR 0 3
125507: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
125508: LD_INT 0
125510: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
125511: LD_VAR 0 1
125515: PUSH
125516: LD_INT 250
125518: EQUAL
125519: PUSH
125520: LD_VAR 0 2
125524: PPUSH
125525: CALL_OW 264
125529: PUSH
125530: LD_INT 81
125532: EQUAL
125533: AND
125534: IFFALSE 125555
// MinerPlaceMine ( unit , x , y ) ;
125536: LD_VAR 0 2
125540: PPUSH
125541: LD_VAR 0 4
125545: PPUSH
125546: LD_VAR 0 5
125550: PPUSH
125551: CALL 127940 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
125555: LD_VAR 0 1
125559: PUSH
125560: LD_INT 251
125562: EQUAL
125563: PUSH
125564: LD_VAR 0 2
125568: PPUSH
125569: CALL_OW 264
125573: PUSH
125574: LD_INT 81
125576: EQUAL
125577: AND
125578: IFFALSE 125599
// MinerDetonateMine ( unit , x , y ) ;
125580: LD_VAR 0 2
125584: PPUSH
125585: LD_VAR 0 4
125589: PPUSH
125590: LD_VAR 0 5
125594: PPUSH
125595: CALL 128215 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
125599: LD_VAR 0 1
125603: PUSH
125604: LD_INT 252
125606: EQUAL
125607: PUSH
125608: LD_VAR 0 2
125612: PPUSH
125613: CALL_OW 264
125617: PUSH
125618: LD_INT 81
125620: EQUAL
125621: AND
125622: IFFALSE 125643
// MinerCreateMinefield ( unit , x , y ) ;
125624: LD_VAR 0 2
125628: PPUSH
125629: LD_VAR 0 4
125633: PPUSH
125634: LD_VAR 0 5
125638: PPUSH
125639: CALL 128632 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
125643: LD_VAR 0 1
125647: PUSH
125648: LD_INT 253
125650: EQUAL
125651: PUSH
125652: LD_VAR 0 2
125656: PPUSH
125657: CALL_OW 257
125661: PUSH
125662: LD_INT 5
125664: EQUAL
125665: AND
125666: IFFALSE 125687
// ComBinocular ( unit , x , y ) ;
125668: LD_VAR 0 2
125672: PPUSH
125673: LD_VAR 0 4
125677: PPUSH
125678: LD_VAR 0 5
125682: PPUSH
125683: CALL 129001 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
125687: LD_VAR 0 1
125691: PUSH
125692: LD_INT 254
125694: EQUAL
125695: PUSH
125696: LD_VAR 0 2
125700: PPUSH
125701: CALL_OW 264
125705: PUSH
125706: LD_INT 99
125708: EQUAL
125709: AND
125710: PUSH
125711: LD_VAR 0 3
125715: PPUSH
125716: CALL_OW 263
125720: PUSH
125721: LD_INT 3
125723: EQUAL
125724: AND
125725: IFFALSE 125741
// HackDestroyVehicle ( unit , selectedUnit ) ;
125727: LD_VAR 0 2
125731: PPUSH
125732: LD_VAR 0 3
125736: PPUSH
125737: CALL 127304 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
125741: LD_VAR 0 1
125745: PUSH
125746: LD_INT 255
125748: EQUAL
125749: PUSH
125750: LD_VAR 0 2
125754: PPUSH
125755: CALL_OW 264
125759: PUSH
125760: LD_INT 14
125762: PUSH
125763: LD_INT 53
125765: PUSH
125766: EMPTY
125767: LIST
125768: LIST
125769: IN
125770: AND
125771: PUSH
125772: LD_VAR 0 4
125776: PPUSH
125777: LD_VAR 0 5
125781: PPUSH
125782: CALL_OW 488
125786: AND
125787: IFFALSE 125811
// CutTreeXYR ( unit , x , y , 12 ) ;
125789: LD_VAR 0 2
125793: PPUSH
125794: LD_VAR 0 4
125798: PPUSH
125799: LD_VAR 0 5
125803: PPUSH
125804: LD_INT 12
125806: PPUSH
125807: CALL 125874 0 4
// if cmd = 256 then
125811: LD_VAR 0 1
125815: PUSH
125816: LD_INT 256
125818: EQUAL
125819: IFFALSE 125840
// SetFactoryWaypoint ( unit , x , y ) ;
125821: LD_VAR 0 2
125825: PPUSH
125826: LD_VAR 0 4
125830: PPUSH
125831: LD_VAR 0 5
125835: PPUSH
125836: CALL 123821 0 3
// if cmd = 257 then
125840: LD_VAR 0 1
125844: PUSH
125845: LD_INT 257
125847: EQUAL
125848: IFFALSE 125869
// SetWarehouseGatheringPoint ( unit , x , y ) ;
125850: LD_VAR 0 2
125854: PPUSH
125855: LD_VAR 0 4
125859: PPUSH
125860: LD_VAR 0 5
125864: PPUSH
125865: CALL 124183 0 3
// end ;
125869: LD_VAR 0 6
125873: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
125874: LD_INT 0
125876: PPUSH
125877: PPUSH
125878: PPUSH
125879: PPUSH
125880: PPUSH
125881: PPUSH
125882: PPUSH
125883: PPUSH
125884: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
125885: LD_VAR 0 1
125889: NOT
125890: PUSH
125891: LD_VAR 0 2
125895: PPUSH
125896: LD_VAR 0 3
125900: PPUSH
125901: CALL_OW 488
125905: NOT
125906: OR
125907: PUSH
125908: LD_VAR 0 4
125912: NOT
125913: OR
125914: IFFALSE 125918
// exit ;
125916: GO 126258
// list := [ ] ;
125918: LD_ADDR_VAR 0 13
125922: PUSH
125923: EMPTY
125924: ST_TO_ADDR
// if x - r < 0 then
125925: LD_VAR 0 2
125929: PUSH
125930: LD_VAR 0 4
125934: MINUS
125935: PUSH
125936: LD_INT 0
125938: LESS
125939: IFFALSE 125951
// min_x := 0 else
125941: LD_ADDR_VAR 0 7
125945: PUSH
125946: LD_INT 0
125948: ST_TO_ADDR
125949: GO 125967
// min_x := x - r ;
125951: LD_ADDR_VAR 0 7
125955: PUSH
125956: LD_VAR 0 2
125960: PUSH
125961: LD_VAR 0 4
125965: MINUS
125966: ST_TO_ADDR
// if y - r < 0 then
125967: LD_VAR 0 3
125971: PUSH
125972: LD_VAR 0 4
125976: MINUS
125977: PUSH
125978: LD_INT 0
125980: LESS
125981: IFFALSE 125993
// min_y := 0 else
125983: LD_ADDR_VAR 0 8
125987: PUSH
125988: LD_INT 0
125990: ST_TO_ADDR
125991: GO 126009
// min_y := y - r ;
125993: LD_ADDR_VAR 0 8
125997: PUSH
125998: LD_VAR 0 3
126002: PUSH
126003: LD_VAR 0 4
126007: MINUS
126008: ST_TO_ADDR
// max_x := x + r ;
126009: LD_ADDR_VAR 0 9
126013: PUSH
126014: LD_VAR 0 2
126018: PUSH
126019: LD_VAR 0 4
126023: PLUS
126024: ST_TO_ADDR
// max_y := y + r ;
126025: LD_ADDR_VAR 0 10
126029: PUSH
126030: LD_VAR 0 3
126034: PUSH
126035: LD_VAR 0 4
126039: PLUS
126040: ST_TO_ADDR
// for _x = min_x to max_x do
126041: LD_ADDR_VAR 0 11
126045: PUSH
126046: DOUBLE
126047: LD_VAR 0 7
126051: DEC
126052: ST_TO_ADDR
126053: LD_VAR 0 9
126057: PUSH
126058: FOR_TO
126059: IFFALSE 126176
// for _y = min_y to max_y do
126061: LD_ADDR_VAR 0 12
126065: PUSH
126066: DOUBLE
126067: LD_VAR 0 8
126071: DEC
126072: ST_TO_ADDR
126073: LD_VAR 0 10
126077: PUSH
126078: FOR_TO
126079: IFFALSE 126172
// begin if not ValidHex ( _x , _y ) then
126081: LD_VAR 0 11
126085: PPUSH
126086: LD_VAR 0 12
126090: PPUSH
126091: CALL_OW 488
126095: NOT
126096: IFFALSE 126100
// continue ;
126098: GO 126078
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
126100: LD_VAR 0 11
126104: PPUSH
126105: LD_VAR 0 12
126109: PPUSH
126110: CALL_OW 351
126114: PUSH
126115: LD_VAR 0 11
126119: PPUSH
126120: LD_VAR 0 12
126124: PPUSH
126125: CALL_OW 554
126129: AND
126130: IFFALSE 126170
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
126132: LD_ADDR_VAR 0 13
126136: PUSH
126137: LD_VAR 0 13
126141: PPUSH
126142: LD_VAR 0 13
126146: PUSH
126147: LD_INT 1
126149: PLUS
126150: PPUSH
126151: LD_VAR 0 11
126155: PUSH
126156: LD_VAR 0 12
126160: PUSH
126161: EMPTY
126162: LIST
126163: LIST
126164: PPUSH
126165: CALL_OW 2
126169: ST_TO_ADDR
// end ;
126170: GO 126078
126172: POP
126173: POP
126174: GO 126058
126176: POP
126177: POP
// if not list then
126178: LD_VAR 0 13
126182: NOT
126183: IFFALSE 126187
// exit ;
126185: GO 126258
// for i in list do
126187: LD_ADDR_VAR 0 6
126191: PUSH
126192: LD_VAR 0 13
126196: PUSH
126197: FOR_IN
126198: IFFALSE 126256
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
126200: LD_VAR 0 1
126204: PPUSH
126205: LD_STRING M
126207: PUSH
126208: LD_VAR 0 6
126212: PUSH
126213: LD_INT 1
126215: ARRAY
126216: PUSH
126217: LD_VAR 0 6
126221: PUSH
126222: LD_INT 2
126224: ARRAY
126225: PUSH
126226: LD_INT 0
126228: PUSH
126229: LD_INT 0
126231: PUSH
126232: LD_INT 0
126234: PUSH
126235: LD_INT 0
126237: PUSH
126238: EMPTY
126239: LIST
126240: LIST
126241: LIST
126242: LIST
126243: LIST
126244: LIST
126245: LIST
126246: PUSH
126247: EMPTY
126248: LIST
126249: PPUSH
126250: CALL_OW 447
126254: GO 126197
126256: POP
126257: POP
// end ;
126258: LD_VAR 0 5
126262: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
126263: LD_EXP 207
126267: NOT
126268: IFFALSE 126318
126270: GO 126272
126272: DISABLE
// begin initHack := true ;
126273: LD_ADDR_EXP 207
126277: PUSH
126278: LD_INT 1
126280: ST_TO_ADDR
// hackTanks := [ ] ;
126281: LD_ADDR_EXP 208
126285: PUSH
126286: EMPTY
126287: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
126288: LD_ADDR_EXP 209
126292: PUSH
126293: EMPTY
126294: ST_TO_ADDR
// hackLimit := 3 ;
126295: LD_ADDR_EXP 210
126299: PUSH
126300: LD_INT 3
126302: ST_TO_ADDR
// hackDist := 12 ;
126303: LD_ADDR_EXP 211
126307: PUSH
126308: LD_INT 12
126310: ST_TO_ADDR
// hackCounter := [ ] ;
126311: LD_ADDR_EXP 212
126315: PUSH
126316: EMPTY
126317: ST_TO_ADDR
// end ;
126318: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
126319: LD_EXP 207
126323: PUSH
126324: LD_INT 34
126326: PUSH
126327: LD_INT 99
126329: PUSH
126330: EMPTY
126331: LIST
126332: LIST
126333: PPUSH
126334: CALL_OW 69
126338: AND
126339: IFFALSE 126592
126341: GO 126343
126343: DISABLE
126344: LD_INT 0
126346: PPUSH
126347: PPUSH
// begin enable ;
126348: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
126349: LD_ADDR_VAR 0 1
126353: PUSH
126354: LD_INT 34
126356: PUSH
126357: LD_INT 99
126359: PUSH
126360: EMPTY
126361: LIST
126362: LIST
126363: PPUSH
126364: CALL_OW 69
126368: PUSH
126369: FOR_IN
126370: IFFALSE 126590
// begin if not i in hackTanks then
126372: LD_VAR 0 1
126376: PUSH
126377: LD_EXP 208
126381: IN
126382: NOT
126383: IFFALSE 126466
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
126385: LD_ADDR_EXP 208
126389: PUSH
126390: LD_EXP 208
126394: PPUSH
126395: LD_EXP 208
126399: PUSH
126400: LD_INT 1
126402: PLUS
126403: PPUSH
126404: LD_VAR 0 1
126408: PPUSH
126409: CALL_OW 1
126413: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
126414: LD_ADDR_EXP 209
126418: PUSH
126419: LD_EXP 209
126423: PPUSH
126424: LD_EXP 209
126428: PUSH
126429: LD_INT 1
126431: PLUS
126432: PPUSH
126433: EMPTY
126434: PPUSH
126435: CALL_OW 1
126439: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
126440: LD_ADDR_EXP 212
126444: PUSH
126445: LD_EXP 212
126449: PPUSH
126450: LD_EXP 212
126454: PUSH
126455: LD_INT 1
126457: PLUS
126458: PPUSH
126459: EMPTY
126460: PPUSH
126461: CALL_OW 1
126465: ST_TO_ADDR
// end ; if not IsOk ( i ) then
126466: LD_VAR 0 1
126470: PPUSH
126471: CALL_OW 302
126475: NOT
126476: IFFALSE 126489
// begin HackUnlinkAll ( i ) ;
126478: LD_VAR 0 1
126482: PPUSH
126483: CALL 126595 0 1
// continue ;
126487: GO 126369
// end ; HackCheckCapturedStatus ( i ) ;
126489: LD_VAR 0 1
126493: PPUSH
126494: CALL 127038 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
126498: LD_ADDR_VAR 0 2
126502: PUSH
126503: LD_INT 81
126505: PUSH
126506: LD_VAR 0 1
126510: PPUSH
126511: CALL_OW 255
126515: PUSH
126516: EMPTY
126517: LIST
126518: LIST
126519: PUSH
126520: LD_INT 33
126522: PUSH
126523: LD_INT 3
126525: PUSH
126526: EMPTY
126527: LIST
126528: LIST
126529: PUSH
126530: LD_INT 91
126532: PUSH
126533: LD_VAR 0 1
126537: PUSH
126538: LD_EXP 211
126542: PUSH
126543: EMPTY
126544: LIST
126545: LIST
126546: LIST
126547: PUSH
126548: LD_INT 50
126550: PUSH
126551: EMPTY
126552: LIST
126553: PUSH
126554: EMPTY
126555: LIST
126556: LIST
126557: LIST
126558: LIST
126559: PPUSH
126560: CALL_OW 69
126564: ST_TO_ADDR
// if not tmp then
126565: LD_VAR 0 2
126569: NOT
126570: IFFALSE 126574
// continue ;
126572: GO 126369
// HackLink ( i , tmp ) ;
126574: LD_VAR 0 1
126578: PPUSH
126579: LD_VAR 0 2
126583: PPUSH
126584: CALL 126731 0 2
// end ;
126588: GO 126369
126590: POP
126591: POP
// end ;
126592: PPOPN 2
126594: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
126595: LD_INT 0
126597: PPUSH
126598: PPUSH
126599: PPUSH
// if not hack in hackTanks then
126600: LD_VAR 0 1
126604: PUSH
126605: LD_EXP 208
126609: IN
126610: NOT
126611: IFFALSE 126615
// exit ;
126613: GO 126726
// index := GetElementIndex ( hackTanks , hack ) ;
126615: LD_ADDR_VAR 0 4
126619: PUSH
126620: LD_EXP 208
126624: PPUSH
126625: LD_VAR 0 1
126629: PPUSH
126630: CALL 72721 0 2
126634: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
126635: LD_EXP 209
126639: PUSH
126640: LD_VAR 0 4
126644: ARRAY
126645: IFFALSE 126726
// begin for i in hackTanksCaptured [ index ] do
126647: LD_ADDR_VAR 0 3
126651: PUSH
126652: LD_EXP 209
126656: PUSH
126657: LD_VAR 0 4
126661: ARRAY
126662: PUSH
126663: FOR_IN
126664: IFFALSE 126690
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
126666: LD_VAR 0 3
126670: PUSH
126671: LD_INT 1
126673: ARRAY
126674: PPUSH
126675: LD_VAR 0 3
126679: PUSH
126680: LD_INT 2
126682: ARRAY
126683: PPUSH
126684: CALL_OW 235
126688: GO 126663
126690: POP
126691: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
126692: LD_ADDR_EXP 209
126696: PUSH
126697: LD_EXP 209
126701: PPUSH
126702: LD_VAR 0 4
126706: PPUSH
126707: EMPTY
126708: PPUSH
126709: CALL_OW 1
126713: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
126714: LD_VAR 0 1
126718: PPUSH
126719: LD_INT 0
126721: PPUSH
126722: CALL_OW 505
// end ; end ;
126726: LD_VAR 0 2
126730: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
126731: LD_INT 0
126733: PPUSH
126734: PPUSH
126735: PPUSH
// if not hack in hackTanks or not vehicles then
126736: LD_VAR 0 1
126740: PUSH
126741: LD_EXP 208
126745: IN
126746: NOT
126747: PUSH
126748: LD_VAR 0 2
126752: NOT
126753: OR
126754: IFFALSE 126758
// exit ;
126756: GO 127033
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
126758: LD_ADDR_VAR 0 2
126762: PUSH
126763: LD_VAR 0 1
126767: PPUSH
126768: LD_VAR 0 2
126772: PPUSH
126773: LD_INT 1
126775: PPUSH
126776: LD_INT 1
126778: PPUSH
126779: CALL 73371 0 4
126783: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
126784: LD_ADDR_VAR 0 5
126788: PUSH
126789: LD_EXP 208
126793: PPUSH
126794: LD_VAR 0 1
126798: PPUSH
126799: CALL 72721 0 2
126803: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
126804: LD_EXP 209
126808: PUSH
126809: LD_VAR 0 5
126813: ARRAY
126814: PUSH
126815: LD_EXP 210
126819: LESS
126820: IFFALSE 127009
// begin for i := 1 to vehicles do
126822: LD_ADDR_VAR 0 4
126826: PUSH
126827: DOUBLE
126828: LD_INT 1
126830: DEC
126831: ST_TO_ADDR
126832: LD_VAR 0 2
126836: PUSH
126837: FOR_TO
126838: IFFALSE 127007
// begin if hackTanksCaptured [ index ] = hackLimit then
126840: LD_EXP 209
126844: PUSH
126845: LD_VAR 0 5
126849: ARRAY
126850: PUSH
126851: LD_EXP 210
126855: EQUAL
126856: IFFALSE 126860
// break ;
126858: GO 127007
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
126860: LD_ADDR_EXP 212
126864: PUSH
126865: LD_EXP 212
126869: PPUSH
126870: LD_VAR 0 5
126874: PPUSH
126875: LD_EXP 212
126879: PUSH
126880: LD_VAR 0 5
126884: ARRAY
126885: PUSH
126886: LD_INT 1
126888: PLUS
126889: PPUSH
126890: CALL_OW 1
126894: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
126895: LD_ADDR_EXP 209
126899: PUSH
126900: LD_EXP 209
126904: PPUSH
126905: LD_VAR 0 5
126909: PUSH
126910: LD_EXP 209
126914: PUSH
126915: LD_VAR 0 5
126919: ARRAY
126920: PUSH
126921: LD_INT 1
126923: PLUS
126924: PUSH
126925: EMPTY
126926: LIST
126927: LIST
126928: PPUSH
126929: LD_VAR 0 2
126933: PUSH
126934: LD_VAR 0 4
126938: ARRAY
126939: PUSH
126940: LD_VAR 0 2
126944: PUSH
126945: LD_VAR 0 4
126949: ARRAY
126950: PPUSH
126951: CALL_OW 255
126955: PUSH
126956: EMPTY
126957: LIST
126958: LIST
126959: PPUSH
126960: CALL 72936 0 3
126964: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
126965: LD_VAR 0 2
126969: PUSH
126970: LD_VAR 0 4
126974: ARRAY
126975: PPUSH
126976: LD_VAR 0 1
126980: PPUSH
126981: CALL_OW 255
126985: PPUSH
126986: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
126990: LD_VAR 0 2
126994: PUSH
126995: LD_VAR 0 4
126999: ARRAY
127000: PPUSH
127001: CALL_OW 141
// end ;
127005: GO 126837
127007: POP
127008: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
127009: LD_VAR 0 1
127013: PPUSH
127014: LD_EXP 209
127018: PUSH
127019: LD_VAR 0 5
127023: ARRAY
127024: PUSH
127025: LD_INT 0
127027: PLUS
127028: PPUSH
127029: CALL_OW 505
// end ;
127033: LD_VAR 0 3
127037: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
127038: LD_INT 0
127040: PPUSH
127041: PPUSH
127042: PPUSH
127043: PPUSH
// if not hack in hackTanks then
127044: LD_VAR 0 1
127048: PUSH
127049: LD_EXP 208
127053: IN
127054: NOT
127055: IFFALSE 127059
// exit ;
127057: GO 127299
// index := GetElementIndex ( hackTanks , hack ) ;
127059: LD_ADDR_VAR 0 4
127063: PUSH
127064: LD_EXP 208
127068: PPUSH
127069: LD_VAR 0 1
127073: PPUSH
127074: CALL 72721 0 2
127078: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
127079: LD_ADDR_VAR 0 3
127083: PUSH
127084: DOUBLE
127085: LD_EXP 209
127089: PUSH
127090: LD_VAR 0 4
127094: ARRAY
127095: INC
127096: ST_TO_ADDR
127097: LD_INT 1
127099: PUSH
127100: FOR_DOWNTO
127101: IFFALSE 127273
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
127103: LD_ADDR_VAR 0 5
127107: PUSH
127108: LD_EXP 209
127112: PUSH
127113: LD_VAR 0 4
127117: ARRAY
127118: PUSH
127119: LD_VAR 0 3
127123: ARRAY
127124: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
127125: LD_VAR 0 5
127129: PUSH
127130: LD_INT 1
127132: ARRAY
127133: PPUSH
127134: CALL_OW 302
127138: NOT
127139: PUSH
127140: LD_VAR 0 5
127144: PUSH
127145: LD_INT 1
127147: ARRAY
127148: PPUSH
127149: CALL_OW 255
127153: PUSH
127154: LD_VAR 0 1
127158: PPUSH
127159: CALL_OW 255
127163: NONEQUAL
127164: OR
127165: IFFALSE 127271
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
127167: LD_VAR 0 5
127171: PUSH
127172: LD_INT 1
127174: ARRAY
127175: PPUSH
127176: CALL_OW 305
127180: PUSH
127181: LD_VAR 0 5
127185: PUSH
127186: LD_INT 1
127188: ARRAY
127189: PPUSH
127190: CALL_OW 255
127194: PUSH
127195: LD_VAR 0 1
127199: PPUSH
127200: CALL_OW 255
127204: EQUAL
127205: AND
127206: IFFALSE 127230
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
127208: LD_VAR 0 5
127212: PUSH
127213: LD_INT 1
127215: ARRAY
127216: PPUSH
127217: LD_VAR 0 5
127221: PUSH
127222: LD_INT 2
127224: ARRAY
127225: PPUSH
127226: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
127230: LD_ADDR_EXP 209
127234: PUSH
127235: LD_EXP 209
127239: PPUSH
127240: LD_VAR 0 4
127244: PPUSH
127245: LD_EXP 209
127249: PUSH
127250: LD_VAR 0 4
127254: ARRAY
127255: PPUSH
127256: LD_VAR 0 3
127260: PPUSH
127261: CALL_OW 3
127265: PPUSH
127266: CALL_OW 1
127270: ST_TO_ADDR
// end ; end ;
127271: GO 127100
127273: POP
127274: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
127275: LD_VAR 0 1
127279: PPUSH
127280: LD_EXP 209
127284: PUSH
127285: LD_VAR 0 4
127289: ARRAY
127290: PUSH
127291: LD_INT 0
127293: PLUS
127294: PPUSH
127295: CALL_OW 505
// end ;
127299: LD_VAR 0 2
127303: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
127304: LD_INT 0
127306: PPUSH
127307: PPUSH
127308: PPUSH
127309: PPUSH
// if not hack in hackTanks then
127310: LD_VAR 0 1
127314: PUSH
127315: LD_EXP 208
127319: IN
127320: NOT
127321: IFFALSE 127325
// exit ;
127323: GO 127410
// index := GetElementIndex ( hackTanks , hack ) ;
127325: LD_ADDR_VAR 0 5
127329: PUSH
127330: LD_EXP 208
127334: PPUSH
127335: LD_VAR 0 1
127339: PPUSH
127340: CALL 72721 0 2
127344: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
127345: LD_ADDR_VAR 0 4
127349: PUSH
127350: DOUBLE
127351: LD_INT 1
127353: DEC
127354: ST_TO_ADDR
127355: LD_EXP 209
127359: PUSH
127360: LD_VAR 0 5
127364: ARRAY
127365: PUSH
127366: FOR_TO
127367: IFFALSE 127408
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
127369: LD_EXP 209
127373: PUSH
127374: LD_VAR 0 5
127378: ARRAY
127379: PUSH
127380: LD_VAR 0 4
127384: ARRAY
127385: PUSH
127386: LD_INT 1
127388: ARRAY
127389: PUSH
127390: LD_VAR 0 2
127394: EQUAL
127395: IFFALSE 127406
// KillUnit ( vehicle ) ;
127397: LD_VAR 0 2
127401: PPUSH
127402: CALL_OW 66
127406: GO 127366
127408: POP
127409: POP
// end ;
127410: LD_VAR 0 3
127414: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
127415: LD_EXP 213
127419: NOT
127420: IFFALSE 127455
127422: GO 127424
127424: DISABLE
// begin initMiner := true ;
127425: LD_ADDR_EXP 213
127429: PUSH
127430: LD_INT 1
127432: ST_TO_ADDR
// minersList := [ ] ;
127433: LD_ADDR_EXP 214
127437: PUSH
127438: EMPTY
127439: ST_TO_ADDR
// minerMinesList := [ ] ;
127440: LD_ADDR_EXP 215
127444: PUSH
127445: EMPTY
127446: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
127447: LD_ADDR_EXP 216
127451: PUSH
127452: LD_INT 5
127454: ST_TO_ADDR
// end ;
127455: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
127456: LD_EXP 213
127460: PUSH
127461: LD_INT 34
127463: PUSH
127464: LD_INT 81
127466: PUSH
127467: EMPTY
127468: LIST
127469: LIST
127470: PPUSH
127471: CALL_OW 69
127475: AND
127476: IFFALSE 127937
127478: GO 127480
127480: DISABLE
127481: LD_INT 0
127483: PPUSH
127484: PPUSH
127485: PPUSH
127486: PPUSH
// begin enable ;
127487: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
127488: LD_ADDR_VAR 0 1
127492: PUSH
127493: LD_INT 34
127495: PUSH
127496: LD_INT 81
127498: PUSH
127499: EMPTY
127500: LIST
127501: LIST
127502: PPUSH
127503: CALL_OW 69
127507: PUSH
127508: FOR_IN
127509: IFFALSE 127581
// begin if not i in minersList then
127511: LD_VAR 0 1
127515: PUSH
127516: LD_EXP 214
127520: IN
127521: NOT
127522: IFFALSE 127579
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
127524: LD_ADDR_EXP 214
127528: PUSH
127529: LD_EXP 214
127533: PPUSH
127534: LD_EXP 214
127538: PUSH
127539: LD_INT 1
127541: PLUS
127542: PPUSH
127543: LD_VAR 0 1
127547: PPUSH
127548: CALL_OW 1
127552: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
127553: LD_ADDR_EXP 215
127557: PUSH
127558: LD_EXP 215
127562: PPUSH
127563: LD_EXP 215
127567: PUSH
127568: LD_INT 1
127570: PLUS
127571: PPUSH
127572: EMPTY
127573: PPUSH
127574: CALL_OW 1
127578: ST_TO_ADDR
// end end ;
127579: GO 127508
127581: POP
127582: POP
// for i := minerMinesList downto 1 do
127583: LD_ADDR_VAR 0 1
127587: PUSH
127588: DOUBLE
127589: LD_EXP 215
127593: INC
127594: ST_TO_ADDR
127595: LD_INT 1
127597: PUSH
127598: FOR_DOWNTO
127599: IFFALSE 127935
// begin if IsLive ( minersList [ i ] ) then
127601: LD_EXP 214
127605: PUSH
127606: LD_VAR 0 1
127610: ARRAY
127611: PPUSH
127612: CALL_OW 300
127616: IFFALSE 127644
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
127618: LD_EXP 214
127622: PUSH
127623: LD_VAR 0 1
127627: ARRAY
127628: PPUSH
127629: LD_EXP 215
127633: PUSH
127634: LD_VAR 0 1
127638: ARRAY
127639: PPUSH
127640: CALL_OW 505
// if not minerMinesList [ i ] then
127644: LD_EXP 215
127648: PUSH
127649: LD_VAR 0 1
127653: ARRAY
127654: NOT
127655: IFFALSE 127659
// continue ;
127657: GO 127598
// for j := minerMinesList [ i ] downto 1 do
127659: LD_ADDR_VAR 0 2
127663: PUSH
127664: DOUBLE
127665: LD_EXP 215
127669: PUSH
127670: LD_VAR 0 1
127674: ARRAY
127675: INC
127676: ST_TO_ADDR
127677: LD_INT 1
127679: PUSH
127680: FOR_DOWNTO
127681: IFFALSE 127931
// begin side := GetSide ( minersList [ i ] ) ;
127683: LD_ADDR_VAR 0 3
127687: PUSH
127688: LD_EXP 214
127692: PUSH
127693: LD_VAR 0 1
127697: ARRAY
127698: PPUSH
127699: CALL_OW 255
127703: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
127704: LD_ADDR_VAR 0 4
127708: PUSH
127709: LD_EXP 215
127713: PUSH
127714: LD_VAR 0 1
127718: ARRAY
127719: PUSH
127720: LD_VAR 0 2
127724: ARRAY
127725: PUSH
127726: LD_INT 1
127728: ARRAY
127729: PPUSH
127730: LD_EXP 215
127734: PUSH
127735: LD_VAR 0 1
127739: ARRAY
127740: PUSH
127741: LD_VAR 0 2
127745: ARRAY
127746: PUSH
127747: LD_INT 2
127749: ARRAY
127750: PPUSH
127751: CALL_OW 428
127755: ST_TO_ADDR
// if not tmp then
127756: LD_VAR 0 4
127760: NOT
127761: IFFALSE 127765
// continue ;
127763: GO 127680
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
127765: LD_VAR 0 4
127769: PUSH
127770: LD_INT 81
127772: PUSH
127773: LD_VAR 0 3
127777: PUSH
127778: EMPTY
127779: LIST
127780: LIST
127781: PPUSH
127782: CALL_OW 69
127786: IN
127787: PUSH
127788: LD_EXP 215
127792: PUSH
127793: LD_VAR 0 1
127797: ARRAY
127798: PUSH
127799: LD_VAR 0 2
127803: ARRAY
127804: PUSH
127805: LD_INT 1
127807: ARRAY
127808: PPUSH
127809: LD_EXP 215
127813: PUSH
127814: LD_VAR 0 1
127818: ARRAY
127819: PUSH
127820: LD_VAR 0 2
127824: ARRAY
127825: PUSH
127826: LD_INT 2
127828: ARRAY
127829: PPUSH
127830: CALL_OW 458
127834: AND
127835: IFFALSE 127929
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
127837: LD_EXP 215
127841: PUSH
127842: LD_VAR 0 1
127846: ARRAY
127847: PUSH
127848: LD_VAR 0 2
127852: ARRAY
127853: PUSH
127854: LD_INT 1
127856: ARRAY
127857: PPUSH
127858: LD_EXP 215
127862: PUSH
127863: LD_VAR 0 1
127867: ARRAY
127868: PUSH
127869: LD_VAR 0 2
127873: ARRAY
127874: PUSH
127875: LD_INT 2
127877: ARRAY
127878: PPUSH
127879: LD_VAR 0 3
127883: PPUSH
127884: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
127888: LD_ADDR_EXP 215
127892: PUSH
127893: LD_EXP 215
127897: PPUSH
127898: LD_VAR 0 1
127902: PPUSH
127903: LD_EXP 215
127907: PUSH
127908: LD_VAR 0 1
127912: ARRAY
127913: PPUSH
127914: LD_VAR 0 2
127918: PPUSH
127919: CALL_OW 3
127923: PPUSH
127924: CALL_OW 1
127928: ST_TO_ADDR
// end ; end ;
127929: GO 127680
127931: POP
127932: POP
// end ;
127933: GO 127598
127935: POP
127936: POP
// end ;
127937: PPOPN 4
127939: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
127940: LD_INT 0
127942: PPUSH
127943: PPUSH
// result := false ;
127944: LD_ADDR_VAR 0 4
127948: PUSH
127949: LD_INT 0
127951: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
127952: LD_VAR 0 1
127956: PPUSH
127957: CALL_OW 264
127961: PUSH
127962: LD_INT 81
127964: EQUAL
127965: NOT
127966: IFFALSE 127970
// exit ;
127968: GO 128210
// index := GetElementIndex ( minersList , unit ) ;
127970: LD_ADDR_VAR 0 5
127974: PUSH
127975: LD_EXP 214
127979: PPUSH
127980: LD_VAR 0 1
127984: PPUSH
127985: CALL 72721 0 2
127989: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
127990: LD_EXP 215
127994: PUSH
127995: LD_VAR 0 5
127999: ARRAY
128000: PUSH
128001: LD_EXP 216
128005: GREATEREQUAL
128006: IFFALSE 128010
// exit ;
128008: GO 128210
// ComMoveXY ( unit , x , y ) ;
128010: LD_VAR 0 1
128014: PPUSH
128015: LD_VAR 0 2
128019: PPUSH
128020: LD_VAR 0 3
128024: PPUSH
128025: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
128029: LD_INT 35
128031: PPUSH
128032: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
128036: LD_VAR 0 1
128040: PPUSH
128041: LD_VAR 0 2
128045: PPUSH
128046: LD_VAR 0 3
128050: PPUSH
128051: CALL 104076 0 3
128055: NOT
128056: PUSH
128057: LD_VAR 0 1
128061: PPUSH
128062: CALL_OW 314
128066: AND
128067: IFFALSE 128071
// exit ;
128069: GO 128210
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
128071: LD_VAR 0 2
128075: PPUSH
128076: LD_VAR 0 3
128080: PPUSH
128081: CALL_OW 428
128085: PUSH
128086: LD_VAR 0 1
128090: EQUAL
128091: PUSH
128092: LD_VAR 0 1
128096: PPUSH
128097: CALL_OW 314
128101: NOT
128102: AND
128103: IFFALSE 128029
// PlaySoundXY ( x , y , PlantMine ) ;
128105: LD_VAR 0 2
128109: PPUSH
128110: LD_VAR 0 3
128114: PPUSH
128115: LD_STRING PlantMine
128117: PPUSH
128118: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
128122: LD_VAR 0 2
128126: PPUSH
128127: LD_VAR 0 3
128131: PPUSH
128132: LD_VAR 0 1
128136: PPUSH
128137: CALL_OW 255
128141: PPUSH
128142: LD_INT 0
128144: PPUSH
128145: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
128149: LD_ADDR_EXP 215
128153: PUSH
128154: LD_EXP 215
128158: PPUSH
128159: LD_VAR 0 5
128163: PUSH
128164: LD_EXP 215
128168: PUSH
128169: LD_VAR 0 5
128173: ARRAY
128174: PUSH
128175: LD_INT 1
128177: PLUS
128178: PUSH
128179: EMPTY
128180: LIST
128181: LIST
128182: PPUSH
128183: LD_VAR 0 2
128187: PUSH
128188: LD_VAR 0 3
128192: PUSH
128193: EMPTY
128194: LIST
128195: LIST
128196: PPUSH
128197: CALL 72936 0 3
128201: ST_TO_ADDR
// result := true ;
128202: LD_ADDR_VAR 0 4
128206: PUSH
128207: LD_INT 1
128209: ST_TO_ADDR
// end ;
128210: LD_VAR 0 4
128214: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
128215: LD_INT 0
128217: PPUSH
128218: PPUSH
128219: PPUSH
// if not unit in minersList then
128220: LD_VAR 0 1
128224: PUSH
128225: LD_EXP 214
128229: IN
128230: NOT
128231: IFFALSE 128235
// exit ;
128233: GO 128627
// index := GetElementIndex ( minersList , unit ) ;
128235: LD_ADDR_VAR 0 6
128239: PUSH
128240: LD_EXP 214
128244: PPUSH
128245: LD_VAR 0 1
128249: PPUSH
128250: CALL 72721 0 2
128254: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
128255: LD_ADDR_VAR 0 5
128259: PUSH
128260: DOUBLE
128261: LD_EXP 215
128265: PUSH
128266: LD_VAR 0 6
128270: ARRAY
128271: INC
128272: ST_TO_ADDR
128273: LD_INT 1
128275: PUSH
128276: FOR_DOWNTO
128277: IFFALSE 128438
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
128279: LD_EXP 215
128283: PUSH
128284: LD_VAR 0 6
128288: ARRAY
128289: PUSH
128290: LD_VAR 0 5
128294: ARRAY
128295: PUSH
128296: LD_INT 1
128298: ARRAY
128299: PUSH
128300: LD_VAR 0 2
128304: EQUAL
128305: PUSH
128306: LD_EXP 215
128310: PUSH
128311: LD_VAR 0 6
128315: ARRAY
128316: PUSH
128317: LD_VAR 0 5
128321: ARRAY
128322: PUSH
128323: LD_INT 2
128325: ARRAY
128326: PUSH
128327: LD_VAR 0 3
128331: EQUAL
128332: AND
128333: IFFALSE 128436
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
128335: LD_EXP 215
128339: PUSH
128340: LD_VAR 0 6
128344: ARRAY
128345: PUSH
128346: LD_VAR 0 5
128350: ARRAY
128351: PUSH
128352: LD_INT 1
128354: ARRAY
128355: PPUSH
128356: LD_EXP 215
128360: PUSH
128361: LD_VAR 0 6
128365: ARRAY
128366: PUSH
128367: LD_VAR 0 5
128371: ARRAY
128372: PUSH
128373: LD_INT 2
128375: ARRAY
128376: PPUSH
128377: LD_VAR 0 1
128381: PPUSH
128382: CALL_OW 255
128386: PPUSH
128387: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
128391: LD_ADDR_EXP 215
128395: PUSH
128396: LD_EXP 215
128400: PPUSH
128401: LD_VAR 0 6
128405: PPUSH
128406: LD_EXP 215
128410: PUSH
128411: LD_VAR 0 6
128415: ARRAY
128416: PPUSH
128417: LD_VAR 0 5
128421: PPUSH
128422: CALL_OW 3
128426: PPUSH
128427: CALL_OW 1
128431: ST_TO_ADDR
// exit ;
128432: POP
128433: POP
128434: GO 128627
// end ; end ;
128436: GO 128276
128438: POP
128439: POP
// for i := minerMinesList [ index ] downto 1 do
128440: LD_ADDR_VAR 0 5
128444: PUSH
128445: DOUBLE
128446: LD_EXP 215
128450: PUSH
128451: LD_VAR 0 6
128455: ARRAY
128456: INC
128457: ST_TO_ADDR
128458: LD_INT 1
128460: PUSH
128461: FOR_DOWNTO
128462: IFFALSE 128625
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
128464: LD_EXP 215
128468: PUSH
128469: LD_VAR 0 6
128473: ARRAY
128474: PUSH
128475: LD_VAR 0 5
128479: ARRAY
128480: PUSH
128481: LD_INT 1
128483: ARRAY
128484: PPUSH
128485: LD_EXP 215
128489: PUSH
128490: LD_VAR 0 6
128494: ARRAY
128495: PUSH
128496: LD_VAR 0 5
128500: ARRAY
128501: PUSH
128502: LD_INT 2
128504: ARRAY
128505: PPUSH
128506: LD_VAR 0 2
128510: PPUSH
128511: LD_VAR 0 3
128515: PPUSH
128516: CALL_OW 298
128520: PUSH
128521: LD_INT 6
128523: LESS
128524: IFFALSE 128623
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
128526: LD_EXP 215
128530: PUSH
128531: LD_VAR 0 6
128535: ARRAY
128536: PUSH
128537: LD_VAR 0 5
128541: ARRAY
128542: PUSH
128543: LD_INT 1
128545: ARRAY
128546: PPUSH
128547: LD_EXP 215
128551: PUSH
128552: LD_VAR 0 6
128556: ARRAY
128557: PUSH
128558: LD_VAR 0 5
128562: ARRAY
128563: PUSH
128564: LD_INT 2
128566: ARRAY
128567: PPUSH
128568: LD_VAR 0 1
128572: PPUSH
128573: CALL_OW 255
128577: PPUSH
128578: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
128582: LD_ADDR_EXP 215
128586: PUSH
128587: LD_EXP 215
128591: PPUSH
128592: LD_VAR 0 6
128596: PPUSH
128597: LD_EXP 215
128601: PUSH
128602: LD_VAR 0 6
128606: ARRAY
128607: PPUSH
128608: LD_VAR 0 5
128612: PPUSH
128613: CALL_OW 3
128617: PPUSH
128618: CALL_OW 1
128622: ST_TO_ADDR
// end ; end ;
128623: GO 128461
128625: POP
128626: POP
// end ;
128627: LD_VAR 0 4
128631: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
128632: LD_INT 0
128634: PPUSH
128635: PPUSH
128636: PPUSH
128637: PPUSH
128638: PPUSH
128639: PPUSH
128640: PPUSH
128641: PPUSH
128642: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
128643: LD_VAR 0 1
128647: PPUSH
128648: CALL_OW 264
128652: PUSH
128653: LD_INT 81
128655: EQUAL
128656: NOT
128657: PUSH
128658: LD_VAR 0 1
128662: PUSH
128663: LD_EXP 214
128667: IN
128668: NOT
128669: OR
128670: IFFALSE 128674
// exit ;
128672: GO 128996
// index := GetElementIndex ( minersList , unit ) ;
128674: LD_ADDR_VAR 0 6
128678: PUSH
128679: LD_EXP 214
128683: PPUSH
128684: LD_VAR 0 1
128688: PPUSH
128689: CALL 72721 0 2
128693: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
128694: LD_ADDR_VAR 0 8
128698: PUSH
128699: LD_EXP 216
128703: PUSH
128704: LD_EXP 215
128708: PUSH
128709: LD_VAR 0 6
128713: ARRAY
128714: MINUS
128715: ST_TO_ADDR
// if not minesFreeAmount then
128716: LD_VAR 0 8
128720: NOT
128721: IFFALSE 128725
// exit ;
128723: GO 128996
// tmp := [ ] ;
128725: LD_ADDR_VAR 0 7
128729: PUSH
128730: EMPTY
128731: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
128732: LD_ADDR_VAR 0 5
128736: PUSH
128737: DOUBLE
128738: LD_INT 1
128740: DEC
128741: ST_TO_ADDR
128742: LD_VAR 0 8
128746: PUSH
128747: FOR_TO
128748: IFFALSE 128943
// begin _d := rand ( 0 , 5 ) ;
128750: LD_ADDR_VAR 0 11
128754: PUSH
128755: LD_INT 0
128757: PPUSH
128758: LD_INT 5
128760: PPUSH
128761: CALL_OW 12
128765: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
128766: LD_ADDR_VAR 0 12
128770: PUSH
128771: LD_INT 2
128773: PPUSH
128774: LD_INT 6
128776: PPUSH
128777: CALL_OW 12
128781: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
128782: LD_ADDR_VAR 0 9
128786: PUSH
128787: LD_VAR 0 2
128791: PPUSH
128792: LD_VAR 0 11
128796: PPUSH
128797: LD_VAR 0 12
128801: PPUSH
128802: CALL_OW 272
128806: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
128807: LD_ADDR_VAR 0 10
128811: PUSH
128812: LD_VAR 0 3
128816: PPUSH
128817: LD_VAR 0 11
128821: PPUSH
128822: LD_VAR 0 12
128826: PPUSH
128827: CALL_OW 273
128831: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
128832: LD_VAR 0 9
128836: PPUSH
128837: LD_VAR 0 10
128841: PPUSH
128842: CALL_OW 488
128846: PUSH
128847: LD_VAR 0 9
128851: PUSH
128852: LD_VAR 0 10
128856: PUSH
128857: EMPTY
128858: LIST
128859: LIST
128860: PUSH
128861: LD_VAR 0 7
128865: IN
128866: NOT
128867: AND
128868: PUSH
128869: LD_VAR 0 9
128873: PPUSH
128874: LD_VAR 0 10
128878: PPUSH
128879: CALL_OW 458
128883: NOT
128884: AND
128885: IFFALSE 128927
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
128887: LD_ADDR_VAR 0 7
128891: PUSH
128892: LD_VAR 0 7
128896: PPUSH
128897: LD_VAR 0 7
128901: PUSH
128902: LD_INT 1
128904: PLUS
128905: PPUSH
128906: LD_VAR 0 9
128910: PUSH
128911: LD_VAR 0 10
128915: PUSH
128916: EMPTY
128917: LIST
128918: LIST
128919: PPUSH
128920: CALL_OW 1
128924: ST_TO_ADDR
128925: GO 128941
// i := i - 1 ;
128927: LD_ADDR_VAR 0 5
128931: PUSH
128932: LD_VAR 0 5
128936: PUSH
128937: LD_INT 1
128939: MINUS
128940: ST_TO_ADDR
// end ;
128941: GO 128747
128943: POP
128944: POP
// for i in tmp do
128945: LD_ADDR_VAR 0 5
128949: PUSH
128950: LD_VAR 0 7
128954: PUSH
128955: FOR_IN
128956: IFFALSE 128994
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
128958: LD_VAR 0 1
128962: PPUSH
128963: LD_VAR 0 5
128967: PUSH
128968: LD_INT 1
128970: ARRAY
128971: PPUSH
128972: LD_VAR 0 5
128976: PUSH
128977: LD_INT 2
128979: ARRAY
128980: PPUSH
128981: CALL 127940 0 3
128985: NOT
128986: IFFALSE 128992
// exit ;
128988: POP
128989: POP
128990: GO 128996
128992: GO 128955
128994: POP
128995: POP
// end ;
128996: LD_VAR 0 4
129000: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
129001: LD_INT 0
129003: PPUSH
129004: PPUSH
129005: PPUSH
129006: PPUSH
129007: PPUSH
129008: PPUSH
129009: PPUSH
// if not GetClass ( unit ) = class_sniper then
129010: LD_VAR 0 1
129014: PPUSH
129015: CALL_OW 257
129019: PUSH
129020: LD_INT 5
129022: EQUAL
129023: NOT
129024: IFFALSE 129028
// exit ;
129026: GO 129416
// dist := 8 ;
129028: LD_ADDR_VAR 0 5
129032: PUSH
129033: LD_INT 8
129035: ST_TO_ADDR
// viewRange := 12 ;
129036: LD_ADDR_VAR 0 7
129040: PUSH
129041: LD_INT 12
129043: ST_TO_ADDR
// side := GetSide ( unit ) ;
129044: LD_ADDR_VAR 0 6
129048: PUSH
129049: LD_VAR 0 1
129053: PPUSH
129054: CALL_OW 255
129058: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
129059: LD_INT 61
129061: PPUSH
129062: LD_VAR 0 6
129066: PPUSH
129067: CALL_OW 321
129071: PUSH
129072: LD_INT 2
129074: EQUAL
129075: IFFALSE 129085
// viewRange := 16 ;
129077: LD_ADDR_VAR 0 7
129081: PUSH
129082: LD_INT 16
129084: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
129085: LD_VAR 0 1
129089: PPUSH
129090: LD_VAR 0 2
129094: PPUSH
129095: LD_VAR 0 3
129099: PPUSH
129100: CALL_OW 297
129104: PUSH
129105: LD_VAR 0 5
129109: GREATER
129110: IFFALSE 129189
// begin ComMoveXY ( unit , x , y ) ;
129112: LD_VAR 0 1
129116: PPUSH
129117: LD_VAR 0 2
129121: PPUSH
129122: LD_VAR 0 3
129126: PPUSH
129127: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
129131: LD_INT 35
129133: PPUSH
129134: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
129138: LD_VAR 0 1
129142: PPUSH
129143: LD_VAR 0 2
129147: PPUSH
129148: LD_VAR 0 3
129152: PPUSH
129153: CALL 104076 0 3
129157: NOT
129158: IFFALSE 129162
// exit ;
129160: GO 129416
// until GetDistUnitXY ( unit , x , y ) < dist ;
129162: LD_VAR 0 1
129166: PPUSH
129167: LD_VAR 0 2
129171: PPUSH
129172: LD_VAR 0 3
129176: PPUSH
129177: CALL_OW 297
129181: PUSH
129182: LD_VAR 0 5
129186: LESS
129187: IFFALSE 129131
// end ; ComTurnXY ( unit , x , y ) ;
129189: LD_VAR 0 1
129193: PPUSH
129194: LD_VAR 0 2
129198: PPUSH
129199: LD_VAR 0 3
129203: PPUSH
129204: CALL_OW 118
// wait ( 5 ) ;
129208: LD_INT 5
129210: PPUSH
129211: CALL_OW 67
// _d := GetDir ( unit ) ;
129215: LD_ADDR_VAR 0 10
129219: PUSH
129220: LD_VAR 0 1
129224: PPUSH
129225: CALL_OW 254
129229: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
129230: LD_ADDR_VAR 0 8
129234: PUSH
129235: LD_VAR 0 1
129239: PPUSH
129240: CALL_OW 250
129244: PPUSH
129245: LD_VAR 0 10
129249: PPUSH
129250: LD_VAR 0 5
129254: PPUSH
129255: CALL_OW 272
129259: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
129260: LD_ADDR_VAR 0 9
129264: PUSH
129265: LD_VAR 0 1
129269: PPUSH
129270: CALL_OW 251
129274: PPUSH
129275: LD_VAR 0 10
129279: PPUSH
129280: LD_VAR 0 5
129284: PPUSH
129285: CALL_OW 273
129289: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
129290: LD_VAR 0 8
129294: PPUSH
129295: LD_VAR 0 9
129299: PPUSH
129300: CALL_OW 488
129304: NOT
129305: IFFALSE 129309
// exit ;
129307: GO 129416
// ComAnimCustom ( unit , 1 ) ;
129309: LD_VAR 0 1
129313: PPUSH
129314: LD_INT 1
129316: PPUSH
129317: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
129321: LD_VAR 0 8
129325: PPUSH
129326: LD_VAR 0 9
129330: PPUSH
129331: LD_VAR 0 6
129335: PPUSH
129336: LD_VAR 0 7
129340: PPUSH
129341: CALL_OW 330
// repeat wait ( 1 ) ;
129345: LD_INT 1
129347: PPUSH
129348: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
129352: LD_VAR 0 1
129356: PPUSH
129357: CALL_OW 316
129361: PUSH
129362: LD_VAR 0 1
129366: PPUSH
129367: CALL_OW 314
129371: OR
129372: PUSH
129373: LD_VAR 0 1
129377: PPUSH
129378: CALL_OW 302
129382: NOT
129383: OR
129384: PUSH
129385: LD_VAR 0 1
129389: PPUSH
129390: CALL_OW 301
129394: OR
129395: IFFALSE 129345
// RemoveSeeing ( _x , _y , side ) ;
129397: LD_VAR 0 8
129401: PPUSH
129402: LD_VAR 0 9
129406: PPUSH
129407: LD_VAR 0 6
129411: PPUSH
129412: CALL_OW 331
// end ; end_of_file
129416: LD_VAR 0 4
129420: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
129421: LD_INT 0
129423: PPUSH
129424: PPUSH
129425: PPUSH
129426: PPUSH
129427: PPUSH
129428: PPUSH
129429: PPUSH
129430: PPUSH
129431: PPUSH
129432: PPUSH
129433: PPUSH
129434: PPUSH
129435: PPUSH
129436: PPUSH
129437: PPUSH
129438: PPUSH
129439: PPUSH
129440: PPUSH
129441: PPUSH
129442: PPUSH
129443: PPUSH
129444: PPUSH
129445: PPUSH
129446: PPUSH
129447: PPUSH
129448: PPUSH
129449: PPUSH
129450: PPUSH
129451: PPUSH
129452: PPUSH
129453: PPUSH
129454: PPUSH
129455: PPUSH
129456: PPUSH
// if not list then
129457: LD_VAR 0 1
129461: NOT
129462: IFFALSE 129466
// exit ;
129464: GO 134125
// base := list [ 1 ] ;
129466: LD_ADDR_VAR 0 3
129470: PUSH
129471: LD_VAR 0 1
129475: PUSH
129476: LD_INT 1
129478: ARRAY
129479: ST_TO_ADDR
// group := list [ 2 ] ;
129480: LD_ADDR_VAR 0 4
129484: PUSH
129485: LD_VAR 0 1
129489: PUSH
129490: LD_INT 2
129492: ARRAY
129493: ST_TO_ADDR
// path := list [ 3 ] ;
129494: LD_ADDR_VAR 0 5
129498: PUSH
129499: LD_VAR 0 1
129503: PUSH
129504: LD_INT 3
129506: ARRAY
129507: ST_TO_ADDR
// flags := list [ 4 ] ;
129508: LD_ADDR_VAR 0 6
129512: PUSH
129513: LD_VAR 0 1
129517: PUSH
129518: LD_INT 4
129520: ARRAY
129521: ST_TO_ADDR
// mined := [ ] ;
129522: LD_ADDR_VAR 0 27
129526: PUSH
129527: EMPTY
129528: ST_TO_ADDR
// bombed := [ ] ;
129529: LD_ADDR_VAR 0 28
129533: PUSH
129534: EMPTY
129535: ST_TO_ADDR
// healers := [ ] ;
129536: LD_ADDR_VAR 0 31
129540: PUSH
129541: EMPTY
129542: ST_TO_ADDR
// to_heal := [ ] ;
129543: LD_ADDR_VAR 0 30
129547: PUSH
129548: EMPTY
129549: ST_TO_ADDR
// repairs := [ ] ;
129550: LD_ADDR_VAR 0 33
129554: PUSH
129555: EMPTY
129556: ST_TO_ADDR
// to_repair := [ ] ;
129557: LD_ADDR_VAR 0 32
129561: PUSH
129562: EMPTY
129563: ST_TO_ADDR
// if not group or not path then
129564: LD_VAR 0 4
129568: NOT
129569: PUSH
129570: LD_VAR 0 5
129574: NOT
129575: OR
129576: IFFALSE 129580
// exit ;
129578: GO 134125
// side := GetSide ( group [ 1 ] ) ;
129580: LD_ADDR_VAR 0 35
129584: PUSH
129585: LD_VAR 0 4
129589: PUSH
129590: LD_INT 1
129592: ARRAY
129593: PPUSH
129594: CALL_OW 255
129598: ST_TO_ADDR
// if flags then
129599: LD_VAR 0 6
129603: IFFALSE 129747
// begin f_ignore_area := flags [ 1 ] ;
129605: LD_ADDR_VAR 0 17
129609: PUSH
129610: LD_VAR 0 6
129614: PUSH
129615: LD_INT 1
129617: ARRAY
129618: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
129619: LD_ADDR_VAR 0 18
129623: PUSH
129624: LD_VAR 0 6
129628: PUSH
129629: LD_INT 2
129631: ARRAY
129632: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
129633: LD_ADDR_VAR 0 19
129637: PUSH
129638: LD_VAR 0 6
129642: PUSH
129643: LD_INT 3
129645: ARRAY
129646: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
129647: LD_ADDR_VAR 0 20
129651: PUSH
129652: LD_VAR 0 6
129656: PUSH
129657: LD_INT 4
129659: ARRAY
129660: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
129661: LD_ADDR_VAR 0 21
129665: PUSH
129666: LD_VAR 0 6
129670: PUSH
129671: LD_INT 5
129673: ARRAY
129674: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
129675: LD_ADDR_VAR 0 22
129679: PUSH
129680: LD_VAR 0 6
129684: PUSH
129685: LD_INT 6
129687: ARRAY
129688: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
129689: LD_ADDR_VAR 0 23
129693: PUSH
129694: LD_VAR 0 6
129698: PUSH
129699: LD_INT 7
129701: ARRAY
129702: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
129703: LD_ADDR_VAR 0 24
129707: PUSH
129708: LD_VAR 0 6
129712: PUSH
129713: LD_INT 8
129715: ARRAY
129716: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
129717: LD_ADDR_VAR 0 25
129721: PUSH
129722: LD_VAR 0 6
129726: PUSH
129727: LD_INT 9
129729: ARRAY
129730: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
129731: LD_ADDR_VAR 0 26
129735: PUSH
129736: LD_VAR 0 6
129740: PUSH
129741: LD_INT 10
129743: ARRAY
129744: ST_TO_ADDR
// end else
129745: GO 129827
// begin f_ignore_area := false ;
129747: LD_ADDR_VAR 0 17
129751: PUSH
129752: LD_INT 0
129754: ST_TO_ADDR
// f_capture := false ;
129755: LD_ADDR_VAR 0 18
129759: PUSH
129760: LD_INT 0
129762: ST_TO_ADDR
// f_ignore_civ := false ;
129763: LD_ADDR_VAR 0 19
129767: PUSH
129768: LD_INT 0
129770: ST_TO_ADDR
// f_murder := false ;
129771: LD_ADDR_VAR 0 20
129775: PUSH
129776: LD_INT 0
129778: ST_TO_ADDR
// f_mines := false ;
129779: LD_ADDR_VAR 0 21
129783: PUSH
129784: LD_INT 0
129786: ST_TO_ADDR
// f_repair := false ;
129787: LD_ADDR_VAR 0 22
129791: PUSH
129792: LD_INT 0
129794: ST_TO_ADDR
// f_heal := false ;
129795: LD_ADDR_VAR 0 23
129799: PUSH
129800: LD_INT 0
129802: ST_TO_ADDR
// f_spacetime := false ;
129803: LD_ADDR_VAR 0 24
129807: PUSH
129808: LD_INT 0
129810: ST_TO_ADDR
// f_attack_depot := false ;
129811: LD_ADDR_VAR 0 25
129815: PUSH
129816: LD_INT 0
129818: ST_TO_ADDR
// f_crawl := false ;
129819: LD_ADDR_VAR 0 26
129823: PUSH
129824: LD_INT 0
129826: ST_TO_ADDR
// end ; if f_heal then
129827: LD_VAR 0 23
129831: IFFALSE 129858
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
129833: LD_ADDR_VAR 0 31
129837: PUSH
129838: LD_VAR 0 4
129842: PPUSH
129843: LD_INT 25
129845: PUSH
129846: LD_INT 4
129848: PUSH
129849: EMPTY
129850: LIST
129851: LIST
129852: PPUSH
129853: CALL_OW 72
129857: ST_TO_ADDR
// if f_repair then
129858: LD_VAR 0 22
129862: IFFALSE 129889
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
129864: LD_ADDR_VAR 0 33
129868: PUSH
129869: LD_VAR 0 4
129873: PPUSH
129874: LD_INT 25
129876: PUSH
129877: LD_INT 3
129879: PUSH
129880: EMPTY
129881: LIST
129882: LIST
129883: PPUSH
129884: CALL_OW 72
129888: ST_TO_ADDR
// units_path := [ ] ;
129889: LD_ADDR_VAR 0 16
129893: PUSH
129894: EMPTY
129895: ST_TO_ADDR
// for i = 1 to group do
129896: LD_ADDR_VAR 0 7
129900: PUSH
129901: DOUBLE
129902: LD_INT 1
129904: DEC
129905: ST_TO_ADDR
129906: LD_VAR 0 4
129910: PUSH
129911: FOR_TO
129912: IFFALSE 129941
// units_path := Replace ( units_path , i , path ) ;
129914: LD_ADDR_VAR 0 16
129918: PUSH
129919: LD_VAR 0 16
129923: PPUSH
129924: LD_VAR 0 7
129928: PPUSH
129929: LD_VAR 0 5
129933: PPUSH
129934: CALL_OW 1
129938: ST_TO_ADDR
129939: GO 129911
129941: POP
129942: POP
// repeat for i = group downto 1 do
129943: LD_ADDR_VAR 0 7
129947: PUSH
129948: DOUBLE
129949: LD_VAR 0 4
129953: INC
129954: ST_TO_ADDR
129955: LD_INT 1
129957: PUSH
129958: FOR_DOWNTO
129959: IFFALSE 134081
// begin wait ( 5 ) ;
129961: LD_INT 5
129963: PPUSH
129964: CALL_OW 67
// tmp := [ ] ;
129968: LD_ADDR_VAR 0 14
129972: PUSH
129973: EMPTY
129974: ST_TO_ADDR
// attacking := false ;
129975: LD_ADDR_VAR 0 29
129979: PUSH
129980: LD_INT 0
129982: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
129983: LD_VAR 0 4
129987: PUSH
129988: LD_VAR 0 7
129992: ARRAY
129993: PPUSH
129994: CALL_OW 301
129998: PUSH
129999: LD_VAR 0 4
130003: PUSH
130004: LD_VAR 0 7
130008: ARRAY
130009: NOT
130010: OR
130011: IFFALSE 130120
// begin if GetType ( group [ i ] ) = unit_human then
130013: LD_VAR 0 4
130017: PUSH
130018: LD_VAR 0 7
130022: ARRAY
130023: PPUSH
130024: CALL_OW 247
130028: PUSH
130029: LD_INT 1
130031: EQUAL
130032: IFFALSE 130078
// begin to_heal := to_heal diff group [ i ] ;
130034: LD_ADDR_VAR 0 30
130038: PUSH
130039: LD_VAR 0 30
130043: PUSH
130044: LD_VAR 0 4
130048: PUSH
130049: LD_VAR 0 7
130053: ARRAY
130054: DIFF
130055: ST_TO_ADDR
// healers := healers diff group [ i ] ;
130056: LD_ADDR_VAR 0 31
130060: PUSH
130061: LD_VAR 0 31
130065: PUSH
130066: LD_VAR 0 4
130070: PUSH
130071: LD_VAR 0 7
130075: ARRAY
130076: DIFF
130077: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
130078: LD_ADDR_VAR 0 4
130082: PUSH
130083: LD_VAR 0 4
130087: PPUSH
130088: LD_VAR 0 7
130092: PPUSH
130093: CALL_OW 3
130097: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
130098: LD_ADDR_VAR 0 16
130102: PUSH
130103: LD_VAR 0 16
130107: PPUSH
130108: LD_VAR 0 7
130112: PPUSH
130113: CALL_OW 3
130117: ST_TO_ADDR
// continue ;
130118: GO 129958
// end ; if f_repair then
130120: LD_VAR 0 22
130124: IFFALSE 130613
// begin if GetType ( group [ i ] ) = unit_vehicle then
130126: LD_VAR 0 4
130130: PUSH
130131: LD_VAR 0 7
130135: ARRAY
130136: PPUSH
130137: CALL_OW 247
130141: PUSH
130142: LD_INT 2
130144: EQUAL
130145: IFFALSE 130335
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
130147: LD_VAR 0 4
130151: PUSH
130152: LD_VAR 0 7
130156: ARRAY
130157: PPUSH
130158: CALL_OW 256
130162: PUSH
130163: LD_INT 700
130165: LESS
130166: PUSH
130167: LD_VAR 0 4
130171: PUSH
130172: LD_VAR 0 7
130176: ARRAY
130177: PUSH
130178: LD_VAR 0 32
130182: IN
130183: NOT
130184: AND
130185: IFFALSE 130209
// to_repair := to_repair union group [ i ] ;
130187: LD_ADDR_VAR 0 32
130191: PUSH
130192: LD_VAR 0 32
130196: PUSH
130197: LD_VAR 0 4
130201: PUSH
130202: LD_VAR 0 7
130206: ARRAY
130207: UNION
130208: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
130209: LD_VAR 0 4
130213: PUSH
130214: LD_VAR 0 7
130218: ARRAY
130219: PPUSH
130220: CALL_OW 256
130224: PUSH
130225: LD_INT 1000
130227: EQUAL
130228: PUSH
130229: LD_VAR 0 4
130233: PUSH
130234: LD_VAR 0 7
130238: ARRAY
130239: PUSH
130240: LD_VAR 0 32
130244: IN
130245: AND
130246: IFFALSE 130270
// to_repair := to_repair diff group [ i ] ;
130248: LD_ADDR_VAR 0 32
130252: PUSH
130253: LD_VAR 0 32
130257: PUSH
130258: LD_VAR 0 4
130262: PUSH
130263: LD_VAR 0 7
130267: ARRAY
130268: DIFF
130269: ST_TO_ADDR
// if group [ i ] in to_repair then
130270: LD_VAR 0 4
130274: PUSH
130275: LD_VAR 0 7
130279: ARRAY
130280: PUSH
130281: LD_VAR 0 32
130285: IN
130286: IFFALSE 130333
// begin if not IsInArea ( group [ i ] , f_repair ) then
130288: LD_VAR 0 4
130292: PUSH
130293: LD_VAR 0 7
130297: ARRAY
130298: PPUSH
130299: LD_VAR 0 22
130303: PPUSH
130304: CALL_OW 308
130308: NOT
130309: IFFALSE 130331
// ComMoveToArea ( group [ i ] , f_repair ) ;
130311: LD_VAR 0 4
130315: PUSH
130316: LD_VAR 0 7
130320: ARRAY
130321: PPUSH
130322: LD_VAR 0 22
130326: PPUSH
130327: CALL_OW 113
// continue ;
130331: GO 129958
// end ; end else
130333: GO 130613
// if group [ i ] in repairs then
130335: LD_VAR 0 4
130339: PUSH
130340: LD_VAR 0 7
130344: ARRAY
130345: PUSH
130346: LD_VAR 0 33
130350: IN
130351: IFFALSE 130613
// begin if IsInUnit ( group [ i ] ) then
130353: LD_VAR 0 4
130357: PUSH
130358: LD_VAR 0 7
130362: ARRAY
130363: PPUSH
130364: CALL_OW 310
130368: IFFALSE 130436
// begin z := IsInUnit ( group [ i ] ) ;
130370: LD_ADDR_VAR 0 13
130374: PUSH
130375: LD_VAR 0 4
130379: PUSH
130380: LD_VAR 0 7
130384: ARRAY
130385: PPUSH
130386: CALL_OW 310
130390: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
130391: LD_VAR 0 13
130395: PUSH
130396: LD_VAR 0 32
130400: IN
130401: PUSH
130402: LD_VAR 0 13
130406: PPUSH
130407: LD_VAR 0 22
130411: PPUSH
130412: CALL_OW 308
130416: AND
130417: IFFALSE 130434
// ComExitVehicle ( group [ i ] ) ;
130419: LD_VAR 0 4
130423: PUSH
130424: LD_VAR 0 7
130428: ARRAY
130429: PPUSH
130430: CALL_OW 121
// end else
130434: GO 130613
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
130436: LD_ADDR_VAR 0 13
130440: PUSH
130441: LD_VAR 0 4
130445: PPUSH
130446: LD_INT 95
130448: PUSH
130449: LD_VAR 0 22
130453: PUSH
130454: EMPTY
130455: LIST
130456: LIST
130457: PUSH
130458: LD_INT 58
130460: PUSH
130461: EMPTY
130462: LIST
130463: PUSH
130464: EMPTY
130465: LIST
130466: LIST
130467: PPUSH
130468: CALL_OW 72
130472: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
130473: LD_VAR 0 4
130477: PUSH
130478: LD_VAR 0 7
130482: ARRAY
130483: PPUSH
130484: CALL_OW 314
130488: NOT
130489: IFFALSE 130611
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
130491: LD_ADDR_VAR 0 10
130495: PUSH
130496: LD_VAR 0 13
130500: PPUSH
130501: LD_VAR 0 4
130505: PUSH
130506: LD_VAR 0 7
130510: ARRAY
130511: PPUSH
130512: CALL_OW 74
130516: ST_TO_ADDR
// if not x then
130517: LD_VAR 0 10
130521: NOT
130522: IFFALSE 130526
// continue ;
130524: GO 129958
// if GetLives ( x ) < 1000 then
130526: LD_VAR 0 10
130530: PPUSH
130531: CALL_OW 256
130535: PUSH
130536: LD_INT 1000
130538: LESS
130539: IFFALSE 130563
// ComRepairVehicle ( group [ i ] , x ) else
130541: LD_VAR 0 4
130545: PUSH
130546: LD_VAR 0 7
130550: ARRAY
130551: PPUSH
130552: LD_VAR 0 10
130556: PPUSH
130557: CALL_OW 129
130561: GO 130611
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
130563: LD_VAR 0 23
130567: PUSH
130568: LD_VAR 0 4
130572: PUSH
130573: LD_VAR 0 7
130577: ARRAY
130578: PPUSH
130579: CALL_OW 256
130583: PUSH
130584: LD_INT 1000
130586: LESS
130587: AND
130588: NOT
130589: IFFALSE 130611
// ComEnterUnit ( group [ i ] , x ) ;
130591: LD_VAR 0 4
130595: PUSH
130596: LD_VAR 0 7
130600: ARRAY
130601: PPUSH
130602: LD_VAR 0 10
130606: PPUSH
130607: CALL_OW 120
// end ; continue ;
130611: GO 129958
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
130613: LD_VAR 0 23
130617: PUSH
130618: LD_VAR 0 4
130622: PUSH
130623: LD_VAR 0 7
130627: ARRAY
130628: PPUSH
130629: CALL_OW 247
130633: PUSH
130634: LD_INT 1
130636: EQUAL
130637: AND
130638: IFFALSE 131116
// begin if group [ i ] in healers then
130640: LD_VAR 0 4
130644: PUSH
130645: LD_VAR 0 7
130649: ARRAY
130650: PUSH
130651: LD_VAR 0 31
130655: IN
130656: IFFALSE 130929
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
130658: LD_VAR 0 4
130662: PUSH
130663: LD_VAR 0 7
130667: ARRAY
130668: PPUSH
130669: LD_VAR 0 23
130673: PPUSH
130674: CALL_OW 308
130678: NOT
130679: PUSH
130680: LD_VAR 0 4
130684: PUSH
130685: LD_VAR 0 7
130689: ARRAY
130690: PPUSH
130691: CALL_OW 314
130695: NOT
130696: AND
130697: IFFALSE 130721
// ComMoveToArea ( group [ i ] , f_heal ) else
130699: LD_VAR 0 4
130703: PUSH
130704: LD_VAR 0 7
130708: ARRAY
130709: PPUSH
130710: LD_VAR 0 23
130714: PPUSH
130715: CALL_OW 113
130719: GO 130927
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
130721: LD_VAR 0 4
130725: PUSH
130726: LD_VAR 0 7
130730: ARRAY
130731: PPUSH
130732: CALL 102659 0 1
130736: PPUSH
130737: CALL_OW 256
130741: PUSH
130742: LD_INT 1000
130744: EQUAL
130745: IFFALSE 130764
// ComStop ( group [ i ] ) else
130747: LD_VAR 0 4
130751: PUSH
130752: LD_VAR 0 7
130756: ARRAY
130757: PPUSH
130758: CALL_OW 141
130762: GO 130927
// if not HasTask ( group [ i ] ) and to_heal then
130764: LD_VAR 0 4
130768: PUSH
130769: LD_VAR 0 7
130773: ARRAY
130774: PPUSH
130775: CALL_OW 314
130779: NOT
130780: PUSH
130781: LD_VAR 0 30
130785: AND
130786: IFFALSE 130927
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
130788: LD_ADDR_VAR 0 13
130792: PUSH
130793: LD_VAR 0 30
130797: PPUSH
130798: LD_INT 3
130800: PUSH
130801: LD_INT 54
130803: PUSH
130804: EMPTY
130805: LIST
130806: PUSH
130807: EMPTY
130808: LIST
130809: LIST
130810: PPUSH
130811: CALL_OW 72
130815: PPUSH
130816: LD_VAR 0 4
130820: PUSH
130821: LD_VAR 0 7
130825: ARRAY
130826: PPUSH
130827: CALL_OW 74
130831: ST_TO_ADDR
// if z then
130832: LD_VAR 0 13
130836: IFFALSE 130927
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
130838: LD_INT 91
130840: PUSH
130841: LD_VAR 0 13
130845: PUSH
130846: LD_INT 10
130848: PUSH
130849: EMPTY
130850: LIST
130851: LIST
130852: LIST
130853: PUSH
130854: LD_INT 81
130856: PUSH
130857: LD_VAR 0 13
130861: PPUSH
130862: CALL_OW 255
130866: PUSH
130867: EMPTY
130868: LIST
130869: LIST
130870: PUSH
130871: EMPTY
130872: LIST
130873: LIST
130874: PPUSH
130875: CALL_OW 69
130879: PUSH
130880: LD_INT 0
130882: EQUAL
130883: IFFALSE 130907
// ComHeal ( group [ i ] , z ) else
130885: LD_VAR 0 4
130889: PUSH
130890: LD_VAR 0 7
130894: ARRAY
130895: PPUSH
130896: LD_VAR 0 13
130900: PPUSH
130901: CALL_OW 128
130905: GO 130927
// ComMoveToArea ( group [ i ] , f_heal ) ;
130907: LD_VAR 0 4
130911: PUSH
130912: LD_VAR 0 7
130916: ARRAY
130917: PPUSH
130918: LD_VAR 0 23
130922: PPUSH
130923: CALL_OW 113
// end ; continue ;
130927: GO 129958
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
130929: LD_VAR 0 4
130933: PUSH
130934: LD_VAR 0 7
130938: ARRAY
130939: PPUSH
130940: CALL_OW 256
130944: PUSH
130945: LD_INT 700
130947: LESS
130948: PUSH
130949: LD_VAR 0 4
130953: PUSH
130954: LD_VAR 0 7
130958: ARRAY
130959: PUSH
130960: LD_VAR 0 30
130964: IN
130965: NOT
130966: AND
130967: IFFALSE 130991
// to_heal := to_heal union group [ i ] ;
130969: LD_ADDR_VAR 0 30
130973: PUSH
130974: LD_VAR 0 30
130978: PUSH
130979: LD_VAR 0 4
130983: PUSH
130984: LD_VAR 0 7
130988: ARRAY
130989: UNION
130990: ST_TO_ADDR
// if group [ i ] in to_heal then
130991: LD_VAR 0 4
130995: PUSH
130996: LD_VAR 0 7
131000: ARRAY
131001: PUSH
131002: LD_VAR 0 30
131006: IN
131007: IFFALSE 131116
// begin if GetLives ( group [ i ] ) = 1000 then
131009: LD_VAR 0 4
131013: PUSH
131014: LD_VAR 0 7
131018: ARRAY
131019: PPUSH
131020: CALL_OW 256
131024: PUSH
131025: LD_INT 1000
131027: EQUAL
131028: IFFALSE 131054
// to_heal := to_heal diff group [ i ] else
131030: LD_ADDR_VAR 0 30
131034: PUSH
131035: LD_VAR 0 30
131039: PUSH
131040: LD_VAR 0 4
131044: PUSH
131045: LD_VAR 0 7
131049: ARRAY
131050: DIFF
131051: ST_TO_ADDR
131052: GO 131116
// begin if not IsInArea ( group [ i ] , to_heal ) then
131054: LD_VAR 0 4
131058: PUSH
131059: LD_VAR 0 7
131063: ARRAY
131064: PPUSH
131065: LD_VAR 0 30
131069: PPUSH
131070: CALL_OW 308
131074: NOT
131075: IFFALSE 131099
// ComMoveToArea ( group [ i ] , f_heal ) else
131077: LD_VAR 0 4
131081: PUSH
131082: LD_VAR 0 7
131086: ARRAY
131087: PPUSH
131088: LD_VAR 0 23
131092: PPUSH
131093: CALL_OW 113
131097: GO 131114
// ComHold ( group [ i ] ) ;
131099: LD_VAR 0 4
131103: PUSH
131104: LD_VAR 0 7
131108: ARRAY
131109: PPUSH
131110: CALL_OW 140
// continue ;
131114: GO 129958
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
131116: LD_VAR 0 4
131120: PUSH
131121: LD_VAR 0 7
131125: ARRAY
131126: PPUSH
131127: LD_INT 10
131129: PPUSH
131130: CALL 100430 0 2
131134: NOT
131135: PUSH
131136: LD_VAR 0 16
131140: PUSH
131141: LD_VAR 0 7
131145: ARRAY
131146: PUSH
131147: EMPTY
131148: EQUAL
131149: NOT
131150: AND
131151: IFFALSE 131417
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
131153: LD_VAR 0 4
131157: PUSH
131158: LD_VAR 0 7
131162: ARRAY
131163: PPUSH
131164: CALL_OW 262
131168: PUSH
131169: LD_INT 1
131171: PUSH
131172: LD_INT 2
131174: PUSH
131175: EMPTY
131176: LIST
131177: LIST
131178: IN
131179: IFFALSE 131220
// if GetFuel ( group [ i ] ) < 10 then
131181: LD_VAR 0 4
131185: PUSH
131186: LD_VAR 0 7
131190: ARRAY
131191: PPUSH
131192: CALL_OW 261
131196: PUSH
131197: LD_INT 10
131199: LESS
131200: IFFALSE 131220
// SetFuel ( group [ i ] , 12 ) ;
131202: LD_VAR 0 4
131206: PUSH
131207: LD_VAR 0 7
131211: ARRAY
131212: PPUSH
131213: LD_INT 12
131215: PPUSH
131216: CALL_OW 240
// if units_path [ i ] then
131220: LD_VAR 0 16
131224: PUSH
131225: LD_VAR 0 7
131229: ARRAY
131230: IFFALSE 131415
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
131232: LD_VAR 0 4
131236: PUSH
131237: LD_VAR 0 7
131241: ARRAY
131242: PPUSH
131243: LD_VAR 0 16
131247: PUSH
131248: LD_VAR 0 7
131252: ARRAY
131253: PUSH
131254: LD_INT 1
131256: ARRAY
131257: PUSH
131258: LD_INT 1
131260: ARRAY
131261: PPUSH
131262: LD_VAR 0 16
131266: PUSH
131267: LD_VAR 0 7
131271: ARRAY
131272: PUSH
131273: LD_INT 1
131275: ARRAY
131276: PUSH
131277: LD_INT 2
131279: ARRAY
131280: PPUSH
131281: CALL_OW 297
131285: PUSH
131286: LD_INT 6
131288: GREATER
131289: IFFALSE 131364
// begin if not HasTask ( group [ i ] ) then
131291: LD_VAR 0 4
131295: PUSH
131296: LD_VAR 0 7
131300: ARRAY
131301: PPUSH
131302: CALL_OW 314
131306: NOT
131307: IFFALSE 131362
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
131309: LD_VAR 0 4
131313: PUSH
131314: LD_VAR 0 7
131318: ARRAY
131319: PPUSH
131320: LD_VAR 0 16
131324: PUSH
131325: LD_VAR 0 7
131329: ARRAY
131330: PUSH
131331: LD_INT 1
131333: ARRAY
131334: PUSH
131335: LD_INT 1
131337: ARRAY
131338: PPUSH
131339: LD_VAR 0 16
131343: PUSH
131344: LD_VAR 0 7
131348: ARRAY
131349: PUSH
131350: LD_INT 1
131352: ARRAY
131353: PUSH
131354: LD_INT 2
131356: ARRAY
131357: PPUSH
131358: CALL_OW 114
// end else
131362: GO 131415
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
131364: LD_ADDR_VAR 0 15
131368: PUSH
131369: LD_VAR 0 16
131373: PUSH
131374: LD_VAR 0 7
131378: ARRAY
131379: PPUSH
131380: LD_INT 1
131382: PPUSH
131383: CALL_OW 3
131387: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
131388: LD_ADDR_VAR 0 16
131392: PUSH
131393: LD_VAR 0 16
131397: PPUSH
131398: LD_VAR 0 7
131402: PPUSH
131403: LD_VAR 0 15
131407: PPUSH
131408: CALL_OW 1
131412: ST_TO_ADDR
// continue ;
131413: GO 129958
// end ; end ; end else
131415: GO 134079
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
131417: LD_ADDR_VAR 0 14
131421: PUSH
131422: LD_INT 81
131424: PUSH
131425: LD_VAR 0 4
131429: PUSH
131430: LD_VAR 0 7
131434: ARRAY
131435: PPUSH
131436: CALL_OW 255
131440: PUSH
131441: EMPTY
131442: LIST
131443: LIST
131444: PPUSH
131445: CALL_OW 69
131449: ST_TO_ADDR
// if not tmp then
131450: LD_VAR 0 14
131454: NOT
131455: IFFALSE 131459
// continue ;
131457: GO 129958
// if f_ignore_area then
131459: LD_VAR 0 17
131463: IFFALSE 131551
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
131465: LD_ADDR_VAR 0 15
131469: PUSH
131470: LD_VAR 0 14
131474: PPUSH
131475: LD_INT 3
131477: PUSH
131478: LD_INT 92
131480: PUSH
131481: LD_VAR 0 17
131485: PUSH
131486: LD_INT 1
131488: ARRAY
131489: PUSH
131490: LD_VAR 0 17
131494: PUSH
131495: LD_INT 2
131497: ARRAY
131498: PUSH
131499: LD_VAR 0 17
131503: PUSH
131504: LD_INT 3
131506: ARRAY
131507: PUSH
131508: EMPTY
131509: LIST
131510: LIST
131511: LIST
131512: LIST
131513: PUSH
131514: EMPTY
131515: LIST
131516: LIST
131517: PPUSH
131518: CALL_OW 72
131522: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
131523: LD_VAR 0 14
131527: PUSH
131528: LD_VAR 0 15
131532: DIFF
131533: IFFALSE 131551
// tmp := tmp diff tmp2 ;
131535: LD_ADDR_VAR 0 14
131539: PUSH
131540: LD_VAR 0 14
131544: PUSH
131545: LD_VAR 0 15
131549: DIFF
131550: ST_TO_ADDR
// end ; if not f_murder then
131551: LD_VAR 0 20
131555: NOT
131556: IFFALSE 131614
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
131558: LD_ADDR_VAR 0 15
131562: PUSH
131563: LD_VAR 0 14
131567: PPUSH
131568: LD_INT 3
131570: PUSH
131571: LD_INT 50
131573: PUSH
131574: EMPTY
131575: LIST
131576: PUSH
131577: EMPTY
131578: LIST
131579: LIST
131580: PPUSH
131581: CALL_OW 72
131585: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
131586: LD_VAR 0 14
131590: PUSH
131591: LD_VAR 0 15
131595: DIFF
131596: IFFALSE 131614
// tmp := tmp diff tmp2 ;
131598: LD_ADDR_VAR 0 14
131602: PUSH
131603: LD_VAR 0 14
131607: PUSH
131608: LD_VAR 0 15
131612: DIFF
131613: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
131614: LD_ADDR_VAR 0 14
131618: PUSH
131619: LD_VAR 0 4
131623: PUSH
131624: LD_VAR 0 7
131628: ARRAY
131629: PPUSH
131630: LD_VAR 0 14
131634: PPUSH
131635: LD_INT 1
131637: PPUSH
131638: LD_INT 1
131640: PPUSH
131641: CALL 73371 0 4
131645: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
131646: LD_VAR 0 4
131650: PUSH
131651: LD_VAR 0 7
131655: ARRAY
131656: PPUSH
131657: CALL_OW 257
131661: PUSH
131662: LD_INT 1
131664: EQUAL
131665: IFFALSE 132113
// begin if WantPlant ( group [ i ] ) then
131667: LD_VAR 0 4
131671: PUSH
131672: LD_VAR 0 7
131676: ARRAY
131677: PPUSH
131678: CALL 72872 0 1
131682: IFFALSE 131686
// continue ;
131684: GO 129958
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
131686: LD_VAR 0 18
131690: PUSH
131691: LD_VAR 0 4
131695: PUSH
131696: LD_VAR 0 7
131700: ARRAY
131701: PPUSH
131702: CALL_OW 310
131706: NOT
131707: AND
131708: PUSH
131709: LD_VAR 0 14
131713: PUSH
131714: LD_INT 1
131716: ARRAY
131717: PUSH
131718: LD_VAR 0 14
131722: PPUSH
131723: LD_INT 21
131725: PUSH
131726: LD_INT 2
131728: PUSH
131729: EMPTY
131730: LIST
131731: LIST
131732: PUSH
131733: LD_INT 58
131735: PUSH
131736: EMPTY
131737: LIST
131738: PUSH
131739: EMPTY
131740: LIST
131741: LIST
131742: PPUSH
131743: CALL_OW 72
131747: IN
131748: AND
131749: IFFALSE 131785
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
131751: LD_VAR 0 4
131755: PUSH
131756: LD_VAR 0 7
131760: ARRAY
131761: PPUSH
131762: LD_VAR 0 14
131766: PUSH
131767: LD_INT 1
131769: ARRAY
131770: PPUSH
131771: CALL_OW 120
// attacking := true ;
131775: LD_ADDR_VAR 0 29
131779: PUSH
131780: LD_INT 1
131782: ST_TO_ADDR
// continue ;
131783: GO 129958
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
131785: LD_VAR 0 26
131789: PUSH
131790: LD_VAR 0 4
131794: PUSH
131795: LD_VAR 0 7
131799: ARRAY
131800: PPUSH
131801: CALL_OW 257
131805: PUSH
131806: LD_INT 1
131808: EQUAL
131809: AND
131810: PUSH
131811: LD_VAR 0 4
131815: PUSH
131816: LD_VAR 0 7
131820: ARRAY
131821: PPUSH
131822: CALL_OW 256
131826: PUSH
131827: LD_INT 800
131829: LESS
131830: AND
131831: PUSH
131832: LD_VAR 0 4
131836: PUSH
131837: LD_VAR 0 7
131841: ARRAY
131842: PPUSH
131843: CALL_OW 318
131847: NOT
131848: AND
131849: IFFALSE 131866
// ComCrawl ( group [ i ] ) ;
131851: LD_VAR 0 4
131855: PUSH
131856: LD_VAR 0 7
131860: ARRAY
131861: PPUSH
131862: CALL_OW 137
// if f_mines then
131866: LD_VAR 0 21
131870: IFFALSE 132113
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
131872: LD_VAR 0 14
131876: PUSH
131877: LD_INT 1
131879: ARRAY
131880: PPUSH
131881: CALL_OW 247
131885: PUSH
131886: LD_INT 3
131888: EQUAL
131889: PUSH
131890: LD_VAR 0 14
131894: PUSH
131895: LD_INT 1
131897: ARRAY
131898: PUSH
131899: LD_VAR 0 27
131903: IN
131904: NOT
131905: AND
131906: IFFALSE 132113
// begin x := GetX ( tmp [ 1 ] ) ;
131908: LD_ADDR_VAR 0 10
131912: PUSH
131913: LD_VAR 0 14
131917: PUSH
131918: LD_INT 1
131920: ARRAY
131921: PPUSH
131922: CALL_OW 250
131926: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
131927: LD_ADDR_VAR 0 11
131931: PUSH
131932: LD_VAR 0 14
131936: PUSH
131937: LD_INT 1
131939: ARRAY
131940: PPUSH
131941: CALL_OW 251
131945: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
131946: LD_ADDR_VAR 0 12
131950: PUSH
131951: LD_VAR 0 4
131955: PUSH
131956: LD_VAR 0 7
131960: ARRAY
131961: PPUSH
131962: CALL 100515 0 1
131966: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
131967: LD_VAR 0 4
131971: PUSH
131972: LD_VAR 0 7
131976: ARRAY
131977: PPUSH
131978: LD_VAR 0 10
131982: PPUSH
131983: LD_VAR 0 11
131987: PPUSH
131988: LD_VAR 0 14
131992: PUSH
131993: LD_INT 1
131995: ARRAY
131996: PPUSH
131997: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
132001: LD_VAR 0 4
132005: PUSH
132006: LD_VAR 0 7
132010: ARRAY
132011: PPUSH
132012: LD_VAR 0 10
132016: PPUSH
132017: LD_VAR 0 12
132021: PPUSH
132022: LD_INT 7
132024: PPUSH
132025: CALL_OW 272
132029: PPUSH
132030: LD_VAR 0 11
132034: PPUSH
132035: LD_VAR 0 12
132039: PPUSH
132040: LD_INT 7
132042: PPUSH
132043: CALL_OW 273
132047: PPUSH
132048: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
132052: LD_VAR 0 4
132056: PUSH
132057: LD_VAR 0 7
132061: ARRAY
132062: PPUSH
132063: LD_INT 71
132065: PPUSH
132066: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
132070: LD_ADDR_VAR 0 27
132074: PUSH
132075: LD_VAR 0 27
132079: PPUSH
132080: LD_VAR 0 27
132084: PUSH
132085: LD_INT 1
132087: PLUS
132088: PPUSH
132089: LD_VAR 0 14
132093: PUSH
132094: LD_INT 1
132096: ARRAY
132097: PPUSH
132098: CALL_OW 1
132102: ST_TO_ADDR
// attacking := true ;
132103: LD_ADDR_VAR 0 29
132107: PUSH
132108: LD_INT 1
132110: ST_TO_ADDR
// continue ;
132111: GO 129958
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
132113: LD_VAR 0 4
132117: PUSH
132118: LD_VAR 0 7
132122: ARRAY
132123: PPUSH
132124: CALL_OW 257
132128: PUSH
132129: LD_INT 17
132131: EQUAL
132132: PUSH
132133: LD_VAR 0 4
132137: PUSH
132138: LD_VAR 0 7
132142: ARRAY
132143: PPUSH
132144: CALL_OW 110
132148: PUSH
132149: LD_INT 71
132151: EQUAL
132152: NOT
132153: AND
132154: IFFALSE 132300
// begin attacking := false ;
132156: LD_ADDR_VAR 0 29
132160: PUSH
132161: LD_INT 0
132163: ST_TO_ADDR
// k := 5 ;
132164: LD_ADDR_VAR 0 9
132168: PUSH
132169: LD_INT 5
132171: ST_TO_ADDR
// if tmp < k then
132172: LD_VAR 0 14
132176: PUSH
132177: LD_VAR 0 9
132181: LESS
132182: IFFALSE 132194
// k := tmp ;
132184: LD_ADDR_VAR 0 9
132188: PUSH
132189: LD_VAR 0 14
132193: ST_TO_ADDR
// for j = 1 to k do
132194: LD_ADDR_VAR 0 8
132198: PUSH
132199: DOUBLE
132200: LD_INT 1
132202: DEC
132203: ST_TO_ADDR
132204: LD_VAR 0 9
132208: PUSH
132209: FOR_TO
132210: IFFALSE 132298
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
132212: LD_VAR 0 14
132216: PUSH
132217: LD_VAR 0 8
132221: ARRAY
132222: PUSH
132223: LD_VAR 0 14
132227: PPUSH
132228: LD_INT 58
132230: PUSH
132231: EMPTY
132232: LIST
132233: PPUSH
132234: CALL_OW 72
132238: IN
132239: NOT
132240: IFFALSE 132296
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
132242: LD_VAR 0 4
132246: PUSH
132247: LD_VAR 0 7
132251: ARRAY
132252: PPUSH
132253: LD_VAR 0 14
132257: PUSH
132258: LD_VAR 0 8
132262: ARRAY
132263: PPUSH
132264: CALL_OW 115
// attacking := true ;
132268: LD_ADDR_VAR 0 29
132272: PUSH
132273: LD_INT 1
132275: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
132276: LD_VAR 0 4
132280: PUSH
132281: LD_VAR 0 7
132285: ARRAY
132286: PPUSH
132287: LD_INT 71
132289: PPUSH
132290: CALL_OW 109
// continue ;
132294: GO 132209
// end ; end ;
132296: GO 132209
132298: POP
132299: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
132300: LD_VAR 0 4
132304: PUSH
132305: LD_VAR 0 7
132309: ARRAY
132310: PPUSH
132311: CALL_OW 257
132315: PUSH
132316: LD_INT 8
132318: EQUAL
132319: PUSH
132320: LD_VAR 0 4
132324: PUSH
132325: LD_VAR 0 7
132329: ARRAY
132330: PPUSH
132331: CALL_OW 264
132335: PUSH
132336: LD_INT 28
132338: PUSH
132339: LD_INT 45
132341: PUSH
132342: LD_INT 7
132344: PUSH
132345: LD_INT 47
132347: PUSH
132348: EMPTY
132349: LIST
132350: LIST
132351: LIST
132352: LIST
132353: IN
132354: OR
132355: IFFALSE 132611
// begin attacking := false ;
132357: LD_ADDR_VAR 0 29
132361: PUSH
132362: LD_INT 0
132364: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
132365: LD_VAR 0 14
132369: PUSH
132370: LD_INT 1
132372: ARRAY
132373: PPUSH
132374: CALL_OW 266
132378: PUSH
132379: LD_INT 32
132381: PUSH
132382: LD_INT 31
132384: PUSH
132385: LD_INT 33
132387: PUSH
132388: LD_INT 4
132390: PUSH
132391: LD_INT 5
132393: PUSH
132394: EMPTY
132395: LIST
132396: LIST
132397: LIST
132398: LIST
132399: LIST
132400: IN
132401: IFFALSE 132587
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
132403: LD_ADDR_VAR 0 9
132407: PUSH
132408: LD_VAR 0 14
132412: PUSH
132413: LD_INT 1
132415: ARRAY
132416: PPUSH
132417: CALL_OW 266
132421: PPUSH
132422: LD_VAR 0 14
132426: PUSH
132427: LD_INT 1
132429: ARRAY
132430: PPUSH
132431: CALL_OW 250
132435: PPUSH
132436: LD_VAR 0 14
132440: PUSH
132441: LD_INT 1
132443: ARRAY
132444: PPUSH
132445: CALL_OW 251
132449: PPUSH
132450: LD_VAR 0 14
132454: PUSH
132455: LD_INT 1
132457: ARRAY
132458: PPUSH
132459: CALL_OW 254
132463: PPUSH
132464: LD_VAR 0 14
132468: PUSH
132469: LD_INT 1
132471: ARRAY
132472: PPUSH
132473: CALL_OW 248
132477: PPUSH
132478: LD_INT 0
132480: PPUSH
132481: CALL 81885 0 6
132485: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
132486: LD_ADDR_VAR 0 8
132490: PUSH
132491: LD_VAR 0 4
132495: PUSH
132496: LD_VAR 0 7
132500: ARRAY
132501: PPUSH
132502: LD_VAR 0 9
132506: PPUSH
132507: CALL 100628 0 2
132511: ST_TO_ADDR
// if j then
132512: LD_VAR 0 8
132516: IFFALSE 132585
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
132518: LD_VAR 0 8
132522: PUSH
132523: LD_INT 1
132525: ARRAY
132526: PPUSH
132527: LD_VAR 0 8
132531: PUSH
132532: LD_INT 2
132534: ARRAY
132535: PPUSH
132536: CALL_OW 488
132540: IFFALSE 132585
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
132542: LD_VAR 0 4
132546: PUSH
132547: LD_VAR 0 7
132551: ARRAY
132552: PPUSH
132553: LD_VAR 0 8
132557: PUSH
132558: LD_INT 1
132560: ARRAY
132561: PPUSH
132562: LD_VAR 0 8
132566: PUSH
132567: LD_INT 2
132569: ARRAY
132570: PPUSH
132571: CALL_OW 116
// attacking := true ;
132575: LD_ADDR_VAR 0 29
132579: PUSH
132580: LD_INT 1
132582: ST_TO_ADDR
// continue ;
132583: GO 129958
// end ; end else
132585: GO 132611
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
132587: LD_VAR 0 4
132591: PUSH
132592: LD_VAR 0 7
132596: ARRAY
132597: PPUSH
132598: LD_VAR 0 14
132602: PUSH
132603: LD_INT 1
132605: ARRAY
132606: PPUSH
132607: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
132611: LD_VAR 0 4
132615: PUSH
132616: LD_VAR 0 7
132620: ARRAY
132621: PPUSH
132622: CALL_OW 265
132626: PUSH
132627: LD_INT 11
132629: EQUAL
132630: IFFALSE 132908
// begin k := 10 ;
132632: LD_ADDR_VAR 0 9
132636: PUSH
132637: LD_INT 10
132639: ST_TO_ADDR
// x := 0 ;
132640: LD_ADDR_VAR 0 10
132644: PUSH
132645: LD_INT 0
132647: ST_TO_ADDR
// if tmp < k then
132648: LD_VAR 0 14
132652: PUSH
132653: LD_VAR 0 9
132657: LESS
132658: IFFALSE 132670
// k := tmp ;
132660: LD_ADDR_VAR 0 9
132664: PUSH
132665: LD_VAR 0 14
132669: ST_TO_ADDR
// for j = k downto 1 do
132670: LD_ADDR_VAR 0 8
132674: PUSH
132675: DOUBLE
132676: LD_VAR 0 9
132680: INC
132681: ST_TO_ADDR
132682: LD_INT 1
132684: PUSH
132685: FOR_DOWNTO
132686: IFFALSE 132761
// begin if GetType ( tmp [ j ] ) = unit_human then
132688: LD_VAR 0 14
132692: PUSH
132693: LD_VAR 0 8
132697: ARRAY
132698: PPUSH
132699: CALL_OW 247
132703: PUSH
132704: LD_INT 1
132706: EQUAL
132707: IFFALSE 132759
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
132709: LD_VAR 0 4
132713: PUSH
132714: LD_VAR 0 7
132718: ARRAY
132719: PPUSH
132720: LD_VAR 0 14
132724: PUSH
132725: LD_VAR 0 8
132729: ARRAY
132730: PPUSH
132731: CALL 100882 0 2
// x := tmp [ j ] ;
132735: LD_ADDR_VAR 0 10
132739: PUSH
132740: LD_VAR 0 14
132744: PUSH
132745: LD_VAR 0 8
132749: ARRAY
132750: ST_TO_ADDR
// attacking := true ;
132751: LD_ADDR_VAR 0 29
132755: PUSH
132756: LD_INT 1
132758: ST_TO_ADDR
// end ; end ;
132759: GO 132685
132761: POP
132762: POP
// if not x then
132763: LD_VAR 0 10
132767: NOT
132768: IFFALSE 132908
// begin attacking := true ;
132770: LD_ADDR_VAR 0 29
132774: PUSH
132775: LD_INT 1
132777: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
132778: LD_VAR 0 4
132782: PUSH
132783: LD_VAR 0 7
132787: ARRAY
132788: PPUSH
132789: CALL_OW 250
132793: PPUSH
132794: LD_VAR 0 4
132798: PUSH
132799: LD_VAR 0 7
132803: ARRAY
132804: PPUSH
132805: CALL_OW 251
132809: PPUSH
132810: CALL_OW 546
132814: PUSH
132815: LD_INT 2
132817: ARRAY
132818: PUSH
132819: LD_VAR 0 14
132823: PUSH
132824: LD_INT 1
132826: ARRAY
132827: PPUSH
132828: CALL_OW 250
132832: PPUSH
132833: LD_VAR 0 14
132837: PUSH
132838: LD_INT 1
132840: ARRAY
132841: PPUSH
132842: CALL_OW 251
132846: PPUSH
132847: CALL_OW 546
132851: PUSH
132852: LD_INT 2
132854: ARRAY
132855: EQUAL
132856: IFFALSE 132884
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
132858: LD_VAR 0 4
132862: PUSH
132863: LD_VAR 0 7
132867: ARRAY
132868: PPUSH
132869: LD_VAR 0 14
132873: PUSH
132874: LD_INT 1
132876: ARRAY
132877: PPUSH
132878: CALL 100882 0 2
132882: GO 132908
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
132884: LD_VAR 0 4
132888: PUSH
132889: LD_VAR 0 7
132893: ARRAY
132894: PPUSH
132895: LD_VAR 0 14
132899: PUSH
132900: LD_INT 1
132902: ARRAY
132903: PPUSH
132904: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
132908: LD_VAR 0 4
132912: PUSH
132913: LD_VAR 0 7
132917: ARRAY
132918: PPUSH
132919: CALL_OW 264
132923: PUSH
132924: LD_INT 29
132926: EQUAL
132927: IFFALSE 133293
// begin if WantsToAttack ( group [ i ] ) in bombed then
132929: LD_VAR 0 4
132933: PUSH
132934: LD_VAR 0 7
132938: ARRAY
132939: PPUSH
132940: CALL_OW 319
132944: PUSH
132945: LD_VAR 0 28
132949: IN
132950: IFFALSE 132954
// continue ;
132952: GO 129958
// k := 8 ;
132954: LD_ADDR_VAR 0 9
132958: PUSH
132959: LD_INT 8
132961: ST_TO_ADDR
// x := 0 ;
132962: LD_ADDR_VAR 0 10
132966: PUSH
132967: LD_INT 0
132969: ST_TO_ADDR
// if tmp < k then
132970: LD_VAR 0 14
132974: PUSH
132975: LD_VAR 0 9
132979: LESS
132980: IFFALSE 132992
// k := tmp ;
132982: LD_ADDR_VAR 0 9
132986: PUSH
132987: LD_VAR 0 14
132991: ST_TO_ADDR
// for j = 1 to k do
132992: LD_ADDR_VAR 0 8
132996: PUSH
132997: DOUBLE
132998: LD_INT 1
133000: DEC
133001: ST_TO_ADDR
133002: LD_VAR 0 9
133006: PUSH
133007: FOR_TO
133008: IFFALSE 133140
// begin if GetType ( tmp [ j ] ) = unit_building then
133010: LD_VAR 0 14
133014: PUSH
133015: LD_VAR 0 8
133019: ARRAY
133020: PPUSH
133021: CALL_OW 247
133025: PUSH
133026: LD_INT 3
133028: EQUAL
133029: IFFALSE 133138
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
133031: LD_VAR 0 14
133035: PUSH
133036: LD_VAR 0 8
133040: ARRAY
133041: PUSH
133042: LD_VAR 0 28
133046: IN
133047: NOT
133048: PUSH
133049: LD_VAR 0 14
133053: PUSH
133054: LD_VAR 0 8
133058: ARRAY
133059: PPUSH
133060: CALL_OW 313
133064: AND
133065: IFFALSE 133138
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
133067: LD_VAR 0 4
133071: PUSH
133072: LD_VAR 0 7
133076: ARRAY
133077: PPUSH
133078: LD_VAR 0 14
133082: PUSH
133083: LD_VAR 0 8
133087: ARRAY
133088: PPUSH
133089: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
133093: LD_ADDR_VAR 0 28
133097: PUSH
133098: LD_VAR 0 28
133102: PPUSH
133103: LD_VAR 0 28
133107: PUSH
133108: LD_INT 1
133110: PLUS
133111: PPUSH
133112: LD_VAR 0 14
133116: PUSH
133117: LD_VAR 0 8
133121: ARRAY
133122: PPUSH
133123: CALL_OW 1
133127: ST_TO_ADDR
// attacking := true ;
133128: LD_ADDR_VAR 0 29
133132: PUSH
133133: LD_INT 1
133135: ST_TO_ADDR
// break ;
133136: GO 133140
// end ; end ;
133138: GO 133007
133140: POP
133141: POP
// if not attacking and f_attack_depot then
133142: LD_VAR 0 29
133146: NOT
133147: PUSH
133148: LD_VAR 0 25
133152: AND
133153: IFFALSE 133248
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
133155: LD_ADDR_VAR 0 13
133159: PUSH
133160: LD_VAR 0 14
133164: PPUSH
133165: LD_INT 2
133167: PUSH
133168: LD_INT 30
133170: PUSH
133171: LD_INT 0
133173: PUSH
133174: EMPTY
133175: LIST
133176: LIST
133177: PUSH
133178: LD_INT 30
133180: PUSH
133181: LD_INT 1
133183: PUSH
133184: EMPTY
133185: LIST
133186: LIST
133187: PUSH
133188: EMPTY
133189: LIST
133190: LIST
133191: LIST
133192: PPUSH
133193: CALL_OW 72
133197: ST_TO_ADDR
// if z then
133198: LD_VAR 0 13
133202: IFFALSE 133248
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
133204: LD_VAR 0 4
133208: PUSH
133209: LD_VAR 0 7
133213: ARRAY
133214: PPUSH
133215: LD_VAR 0 13
133219: PPUSH
133220: LD_VAR 0 4
133224: PUSH
133225: LD_VAR 0 7
133229: ARRAY
133230: PPUSH
133231: CALL_OW 74
133235: PPUSH
133236: CALL_OW 115
// attacking := true ;
133240: LD_ADDR_VAR 0 29
133244: PUSH
133245: LD_INT 1
133247: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
133248: LD_VAR 0 4
133252: PUSH
133253: LD_VAR 0 7
133257: ARRAY
133258: PPUSH
133259: CALL_OW 256
133263: PUSH
133264: LD_INT 500
133266: LESS
133267: IFFALSE 133293
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
133269: LD_VAR 0 4
133273: PUSH
133274: LD_VAR 0 7
133278: ARRAY
133279: PPUSH
133280: LD_VAR 0 14
133284: PUSH
133285: LD_INT 1
133287: ARRAY
133288: PPUSH
133289: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
133293: LD_VAR 0 4
133297: PUSH
133298: LD_VAR 0 7
133302: ARRAY
133303: PPUSH
133304: CALL_OW 264
133308: PUSH
133309: LD_INT 49
133311: EQUAL
133312: IFFALSE 133433
// begin if not HasTask ( group [ i ] ) then
133314: LD_VAR 0 4
133318: PUSH
133319: LD_VAR 0 7
133323: ARRAY
133324: PPUSH
133325: CALL_OW 314
133329: NOT
133330: IFFALSE 133433
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
133332: LD_ADDR_VAR 0 9
133336: PUSH
133337: LD_INT 81
133339: PUSH
133340: LD_VAR 0 4
133344: PUSH
133345: LD_VAR 0 7
133349: ARRAY
133350: PPUSH
133351: CALL_OW 255
133355: PUSH
133356: EMPTY
133357: LIST
133358: LIST
133359: PPUSH
133360: CALL_OW 69
133364: PPUSH
133365: LD_VAR 0 4
133369: PUSH
133370: LD_VAR 0 7
133374: ARRAY
133375: PPUSH
133376: CALL_OW 74
133380: ST_TO_ADDR
// if k then
133381: LD_VAR 0 9
133385: IFFALSE 133433
// if GetDistUnits ( group [ i ] , k ) > 10 then
133387: LD_VAR 0 4
133391: PUSH
133392: LD_VAR 0 7
133396: ARRAY
133397: PPUSH
133398: LD_VAR 0 9
133402: PPUSH
133403: CALL_OW 296
133407: PUSH
133408: LD_INT 10
133410: GREATER
133411: IFFALSE 133433
// ComMoveUnit ( group [ i ] , k ) ;
133413: LD_VAR 0 4
133417: PUSH
133418: LD_VAR 0 7
133422: ARRAY
133423: PPUSH
133424: LD_VAR 0 9
133428: PPUSH
133429: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
133433: LD_VAR 0 4
133437: PUSH
133438: LD_VAR 0 7
133442: ARRAY
133443: PPUSH
133444: CALL_OW 256
133448: PUSH
133449: LD_INT 250
133451: LESS
133452: PUSH
133453: LD_VAR 0 4
133457: PUSH
133458: LD_VAR 0 7
133462: ARRAY
133463: PUSH
133464: LD_INT 21
133466: PUSH
133467: LD_INT 2
133469: PUSH
133470: EMPTY
133471: LIST
133472: LIST
133473: PUSH
133474: LD_INT 23
133476: PUSH
133477: LD_INT 2
133479: PUSH
133480: EMPTY
133481: LIST
133482: LIST
133483: PUSH
133484: EMPTY
133485: LIST
133486: LIST
133487: PPUSH
133488: CALL_OW 69
133492: IN
133493: AND
133494: IFFALSE 133619
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
133496: LD_ADDR_VAR 0 9
133500: PUSH
133501: LD_OWVAR 3
133505: PUSH
133506: LD_VAR 0 4
133510: PUSH
133511: LD_VAR 0 7
133515: ARRAY
133516: DIFF
133517: PPUSH
133518: LD_VAR 0 4
133522: PUSH
133523: LD_VAR 0 7
133527: ARRAY
133528: PPUSH
133529: CALL_OW 74
133533: ST_TO_ADDR
// if not k then
133534: LD_VAR 0 9
133538: NOT
133539: IFFALSE 133543
// continue ;
133541: GO 129958
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
133543: LD_VAR 0 9
133547: PUSH
133548: LD_INT 81
133550: PUSH
133551: LD_VAR 0 4
133555: PUSH
133556: LD_VAR 0 7
133560: ARRAY
133561: PPUSH
133562: CALL_OW 255
133566: PUSH
133567: EMPTY
133568: LIST
133569: LIST
133570: PPUSH
133571: CALL_OW 69
133575: IN
133576: PUSH
133577: LD_VAR 0 9
133581: PPUSH
133582: LD_VAR 0 4
133586: PUSH
133587: LD_VAR 0 7
133591: ARRAY
133592: PPUSH
133593: CALL_OW 296
133597: PUSH
133598: LD_INT 5
133600: LESS
133601: AND
133602: IFFALSE 133619
// ComAutodestruct ( group [ i ] ) ;
133604: LD_VAR 0 4
133608: PUSH
133609: LD_VAR 0 7
133613: ARRAY
133614: PPUSH
133615: CALL 100780 0 1
// end ; if f_attack_depot then
133619: LD_VAR 0 25
133623: IFFALSE 133735
// begin k := 6 ;
133625: LD_ADDR_VAR 0 9
133629: PUSH
133630: LD_INT 6
133632: ST_TO_ADDR
// if tmp < k then
133633: LD_VAR 0 14
133637: PUSH
133638: LD_VAR 0 9
133642: LESS
133643: IFFALSE 133655
// k := tmp ;
133645: LD_ADDR_VAR 0 9
133649: PUSH
133650: LD_VAR 0 14
133654: ST_TO_ADDR
// for j = 1 to k do
133655: LD_ADDR_VAR 0 8
133659: PUSH
133660: DOUBLE
133661: LD_INT 1
133663: DEC
133664: ST_TO_ADDR
133665: LD_VAR 0 9
133669: PUSH
133670: FOR_TO
133671: IFFALSE 133733
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
133673: LD_VAR 0 8
133677: PPUSH
133678: CALL_OW 266
133682: PUSH
133683: LD_INT 0
133685: PUSH
133686: LD_INT 1
133688: PUSH
133689: EMPTY
133690: LIST
133691: LIST
133692: IN
133693: IFFALSE 133731
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
133695: LD_VAR 0 4
133699: PUSH
133700: LD_VAR 0 7
133704: ARRAY
133705: PPUSH
133706: LD_VAR 0 14
133710: PUSH
133711: LD_VAR 0 8
133715: ARRAY
133716: PPUSH
133717: CALL_OW 115
// attacking := true ;
133721: LD_ADDR_VAR 0 29
133725: PUSH
133726: LD_INT 1
133728: ST_TO_ADDR
// break ;
133729: GO 133733
// end ;
133731: GO 133670
133733: POP
133734: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
133735: LD_VAR 0 4
133739: PUSH
133740: LD_VAR 0 7
133744: ARRAY
133745: PPUSH
133746: CALL_OW 302
133750: PUSH
133751: LD_VAR 0 29
133755: NOT
133756: AND
133757: IFFALSE 134079
// begin if GetTag ( group [ i ] ) = 71 then
133759: LD_VAR 0 4
133763: PUSH
133764: LD_VAR 0 7
133768: ARRAY
133769: PPUSH
133770: CALL_OW 110
133774: PUSH
133775: LD_INT 71
133777: EQUAL
133778: IFFALSE 133819
// begin if HasTask ( group [ i ] ) then
133780: LD_VAR 0 4
133784: PUSH
133785: LD_VAR 0 7
133789: ARRAY
133790: PPUSH
133791: CALL_OW 314
133795: IFFALSE 133801
// continue else
133797: GO 129958
133799: GO 133819
// SetTag ( group [ i ] , 0 ) ;
133801: LD_VAR 0 4
133805: PUSH
133806: LD_VAR 0 7
133810: ARRAY
133811: PPUSH
133812: LD_INT 0
133814: PPUSH
133815: CALL_OW 109
// end ; k := 8 ;
133819: LD_ADDR_VAR 0 9
133823: PUSH
133824: LD_INT 8
133826: ST_TO_ADDR
// x := 0 ;
133827: LD_ADDR_VAR 0 10
133831: PUSH
133832: LD_INT 0
133834: ST_TO_ADDR
// if tmp < k then
133835: LD_VAR 0 14
133839: PUSH
133840: LD_VAR 0 9
133844: LESS
133845: IFFALSE 133857
// k := tmp ;
133847: LD_ADDR_VAR 0 9
133851: PUSH
133852: LD_VAR 0 14
133856: ST_TO_ADDR
// for j = 1 to k do
133857: LD_ADDR_VAR 0 8
133861: PUSH
133862: DOUBLE
133863: LD_INT 1
133865: DEC
133866: ST_TO_ADDR
133867: LD_VAR 0 9
133871: PUSH
133872: FOR_TO
133873: IFFALSE 133971
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
133875: LD_VAR 0 14
133879: PUSH
133880: LD_VAR 0 8
133884: ARRAY
133885: PPUSH
133886: CALL_OW 247
133890: PUSH
133891: LD_INT 1
133893: EQUAL
133894: PUSH
133895: LD_VAR 0 14
133899: PUSH
133900: LD_VAR 0 8
133904: ARRAY
133905: PPUSH
133906: CALL_OW 256
133910: PUSH
133911: LD_INT 250
133913: LESS
133914: PUSH
133915: LD_VAR 0 20
133919: AND
133920: PUSH
133921: LD_VAR 0 20
133925: NOT
133926: PUSH
133927: LD_VAR 0 14
133931: PUSH
133932: LD_VAR 0 8
133936: ARRAY
133937: PPUSH
133938: CALL_OW 256
133942: PUSH
133943: LD_INT 250
133945: GREATEREQUAL
133946: AND
133947: OR
133948: AND
133949: IFFALSE 133969
// begin x := tmp [ j ] ;
133951: LD_ADDR_VAR 0 10
133955: PUSH
133956: LD_VAR 0 14
133960: PUSH
133961: LD_VAR 0 8
133965: ARRAY
133966: ST_TO_ADDR
// break ;
133967: GO 133971
// end ;
133969: GO 133872
133971: POP
133972: POP
// if x then
133973: LD_VAR 0 10
133977: IFFALSE 134001
// ComAttackUnit ( group [ i ] , x ) else
133979: LD_VAR 0 4
133983: PUSH
133984: LD_VAR 0 7
133988: ARRAY
133989: PPUSH
133990: LD_VAR 0 10
133994: PPUSH
133995: CALL_OW 115
133999: GO 134025
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
134001: LD_VAR 0 4
134005: PUSH
134006: LD_VAR 0 7
134010: ARRAY
134011: PPUSH
134012: LD_VAR 0 14
134016: PUSH
134017: LD_INT 1
134019: ARRAY
134020: PPUSH
134021: CALL_OW 115
// if not HasTask ( group [ i ] ) then
134025: LD_VAR 0 4
134029: PUSH
134030: LD_VAR 0 7
134034: ARRAY
134035: PPUSH
134036: CALL_OW 314
134040: NOT
134041: IFFALSE 134079
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
134043: LD_VAR 0 4
134047: PUSH
134048: LD_VAR 0 7
134052: ARRAY
134053: PPUSH
134054: LD_VAR 0 14
134058: PPUSH
134059: LD_VAR 0 4
134063: PUSH
134064: LD_VAR 0 7
134068: ARRAY
134069: PPUSH
134070: CALL_OW 74
134074: PPUSH
134075: CALL_OW 115
// end ; end ; end ;
134079: GO 129958
134081: POP
134082: POP
// wait ( 0 0$2 ) ;
134083: LD_INT 70
134085: PPUSH
134086: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
134090: LD_VAR 0 4
134094: NOT
134095: PUSH
134096: LD_VAR 0 4
134100: PUSH
134101: EMPTY
134102: EQUAL
134103: OR
134104: PUSH
134105: LD_INT 81
134107: PUSH
134108: LD_VAR 0 35
134112: PUSH
134113: EMPTY
134114: LIST
134115: LIST
134116: PPUSH
134117: CALL_OW 69
134121: NOT
134122: OR
134123: IFFALSE 129943
// end ;
134125: LD_VAR 0 2
134129: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
134130: LD_INT 0
134132: PPUSH
134133: PPUSH
134134: PPUSH
134135: PPUSH
134136: PPUSH
134137: PPUSH
// if not base or not mc_bases [ base ] or not solds then
134138: LD_VAR 0 1
134142: NOT
134143: PUSH
134144: LD_EXP 100
134148: PUSH
134149: LD_VAR 0 1
134153: ARRAY
134154: NOT
134155: OR
134156: PUSH
134157: LD_VAR 0 2
134161: NOT
134162: OR
134163: IFFALSE 134167
// exit ;
134165: GO 134721
// side := mc_sides [ base ] ;
134167: LD_ADDR_VAR 0 6
134171: PUSH
134172: LD_EXP 126
134176: PUSH
134177: LD_VAR 0 1
134181: ARRAY
134182: ST_TO_ADDR
// if not side then
134183: LD_VAR 0 6
134187: NOT
134188: IFFALSE 134192
// exit ;
134190: GO 134721
// for i in solds do
134192: LD_ADDR_VAR 0 7
134196: PUSH
134197: LD_VAR 0 2
134201: PUSH
134202: FOR_IN
134203: IFFALSE 134264
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
134205: LD_VAR 0 7
134209: PPUSH
134210: CALL_OW 310
134214: PPUSH
134215: CALL_OW 266
134219: PUSH
134220: LD_INT 32
134222: PUSH
134223: LD_INT 31
134225: PUSH
134226: EMPTY
134227: LIST
134228: LIST
134229: IN
134230: IFFALSE 134250
// solds := solds diff i else
134232: LD_ADDR_VAR 0 2
134236: PUSH
134237: LD_VAR 0 2
134241: PUSH
134242: LD_VAR 0 7
134246: DIFF
134247: ST_TO_ADDR
134248: GO 134262
// SetTag ( i , 18 ) ;
134250: LD_VAR 0 7
134254: PPUSH
134255: LD_INT 18
134257: PPUSH
134258: CALL_OW 109
134262: GO 134202
134264: POP
134265: POP
// if not solds then
134266: LD_VAR 0 2
134270: NOT
134271: IFFALSE 134275
// exit ;
134273: GO 134721
// repeat wait ( 0 0$2 ) ;
134275: LD_INT 70
134277: PPUSH
134278: CALL_OW 67
// enemy := mc_scan [ base ] ;
134282: LD_ADDR_VAR 0 4
134286: PUSH
134287: LD_EXP 123
134291: PUSH
134292: LD_VAR 0 1
134296: ARRAY
134297: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
134298: LD_EXP 100
134302: PUSH
134303: LD_VAR 0 1
134307: ARRAY
134308: NOT
134309: PUSH
134310: LD_EXP 100
134314: PUSH
134315: LD_VAR 0 1
134319: ARRAY
134320: PUSH
134321: EMPTY
134322: EQUAL
134323: OR
134324: IFFALSE 134361
// begin for i in solds do
134326: LD_ADDR_VAR 0 7
134330: PUSH
134331: LD_VAR 0 2
134335: PUSH
134336: FOR_IN
134337: IFFALSE 134350
// ComStop ( i ) ;
134339: LD_VAR 0 7
134343: PPUSH
134344: CALL_OW 141
134348: GO 134336
134350: POP
134351: POP
// solds := [ ] ;
134352: LD_ADDR_VAR 0 2
134356: PUSH
134357: EMPTY
134358: ST_TO_ADDR
// exit ;
134359: GO 134721
// end ; for i in solds do
134361: LD_ADDR_VAR 0 7
134365: PUSH
134366: LD_VAR 0 2
134370: PUSH
134371: FOR_IN
134372: IFFALSE 134693
// begin if IsInUnit ( i ) then
134374: LD_VAR 0 7
134378: PPUSH
134379: CALL_OW 310
134383: IFFALSE 134394
// ComExitBuilding ( i ) ;
134385: LD_VAR 0 7
134389: PPUSH
134390: CALL_OW 122
// if GetLives ( i ) > 500 then
134394: LD_VAR 0 7
134398: PPUSH
134399: CALL_OW 256
134403: PUSH
134404: LD_INT 500
134406: GREATER
134407: IFFALSE 134460
// begin e := NearestUnitToUnit ( enemy , i ) ;
134409: LD_ADDR_VAR 0 5
134413: PUSH
134414: LD_VAR 0 4
134418: PPUSH
134419: LD_VAR 0 7
134423: PPUSH
134424: CALL_OW 74
134428: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
134429: LD_VAR 0 7
134433: PPUSH
134434: LD_VAR 0 5
134438: PPUSH
134439: CALL_OW 250
134443: PPUSH
134444: LD_VAR 0 5
134448: PPUSH
134449: CALL_OW 251
134453: PPUSH
134454: CALL_OW 114
// end else
134458: GO 134691
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
134460: LD_VAR 0 7
134464: PPUSH
134465: LD_EXP 100
134469: PUSH
134470: LD_VAR 0 1
134474: ARRAY
134475: PPUSH
134476: LD_INT 2
134478: PUSH
134479: LD_INT 30
134481: PUSH
134482: LD_INT 0
134484: PUSH
134485: EMPTY
134486: LIST
134487: LIST
134488: PUSH
134489: LD_INT 30
134491: PUSH
134492: LD_INT 1
134494: PUSH
134495: EMPTY
134496: LIST
134497: LIST
134498: PUSH
134499: LD_INT 30
134501: PUSH
134502: LD_INT 6
134504: PUSH
134505: EMPTY
134506: LIST
134507: LIST
134508: PUSH
134509: EMPTY
134510: LIST
134511: LIST
134512: LIST
134513: LIST
134514: PPUSH
134515: CALL_OW 72
134519: PPUSH
134520: LD_VAR 0 7
134524: PPUSH
134525: CALL_OW 74
134529: PPUSH
134530: CALL_OW 296
134534: PUSH
134535: LD_INT 10
134537: GREATER
134538: IFFALSE 134691
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
134540: LD_ADDR_VAR 0 8
134544: PUSH
134545: LD_EXP 100
134549: PUSH
134550: LD_VAR 0 1
134554: ARRAY
134555: PPUSH
134556: LD_INT 2
134558: PUSH
134559: LD_INT 30
134561: PUSH
134562: LD_INT 0
134564: PUSH
134565: EMPTY
134566: LIST
134567: LIST
134568: PUSH
134569: LD_INT 30
134571: PUSH
134572: LD_INT 1
134574: PUSH
134575: EMPTY
134576: LIST
134577: LIST
134578: PUSH
134579: LD_INT 30
134581: PUSH
134582: LD_INT 6
134584: PUSH
134585: EMPTY
134586: LIST
134587: LIST
134588: PUSH
134589: EMPTY
134590: LIST
134591: LIST
134592: LIST
134593: LIST
134594: PPUSH
134595: CALL_OW 72
134599: PPUSH
134600: LD_VAR 0 7
134604: PPUSH
134605: CALL_OW 74
134609: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
134610: LD_VAR 0 7
134614: PPUSH
134615: LD_VAR 0 8
134619: PPUSH
134620: CALL_OW 250
134624: PPUSH
134625: LD_INT 3
134627: PPUSH
134628: LD_INT 5
134630: PPUSH
134631: CALL_OW 272
134635: PPUSH
134636: LD_VAR 0 8
134640: PPUSH
134641: CALL_OW 251
134645: PPUSH
134646: LD_INT 3
134648: PPUSH
134649: LD_INT 5
134651: PPUSH
134652: CALL_OW 273
134656: PPUSH
134657: CALL_OW 111
// SetTag ( i , 0 ) ;
134661: LD_VAR 0 7
134665: PPUSH
134666: LD_INT 0
134668: PPUSH
134669: CALL_OW 109
// solds := solds diff i ;
134673: LD_ADDR_VAR 0 2
134677: PUSH
134678: LD_VAR 0 2
134682: PUSH
134683: LD_VAR 0 7
134687: DIFF
134688: ST_TO_ADDR
// continue ;
134689: GO 134371
// end ; end ;
134691: GO 134371
134693: POP
134694: POP
// until not solds or not enemy ;
134695: LD_VAR 0 2
134699: NOT
134700: PUSH
134701: LD_VAR 0 4
134705: NOT
134706: OR
134707: IFFALSE 134275
// MC_Reset ( base , 18 ) ;
134709: LD_VAR 0 1
134713: PPUSH
134714: LD_INT 18
134716: PPUSH
134717: CALL 41449 0 2
// end ;
134721: LD_VAR 0 3
134725: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
134726: LD_INT 0
134728: PPUSH
134729: PPUSH
134730: PPUSH
134731: PPUSH
134732: PPUSH
134733: PPUSH
134734: PPUSH
134735: PPUSH
134736: PPUSH
134737: PPUSH
134738: PPUSH
134739: PPUSH
134740: PPUSH
134741: PPUSH
134742: PPUSH
134743: PPUSH
134744: PPUSH
134745: PPUSH
134746: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
134747: LD_ADDR_VAR 0 12
134751: PUSH
134752: LD_EXP 100
134756: PUSH
134757: LD_VAR 0 1
134761: ARRAY
134762: PPUSH
134763: LD_INT 25
134765: PUSH
134766: LD_INT 3
134768: PUSH
134769: EMPTY
134770: LIST
134771: LIST
134772: PPUSH
134773: CALL_OW 72
134777: ST_TO_ADDR
// if mc_remote_driver [ base ] then
134778: LD_EXP 140
134782: PUSH
134783: LD_VAR 0 1
134787: ARRAY
134788: IFFALSE 134812
// mechs := mechs diff mc_remote_driver [ base ] ;
134790: LD_ADDR_VAR 0 12
134794: PUSH
134795: LD_VAR 0 12
134799: PUSH
134800: LD_EXP 140
134804: PUSH
134805: LD_VAR 0 1
134809: ARRAY
134810: DIFF
134811: ST_TO_ADDR
// for i in mechs do
134812: LD_ADDR_VAR 0 4
134816: PUSH
134817: LD_VAR 0 12
134821: PUSH
134822: FOR_IN
134823: IFFALSE 134858
// if GetTag ( i ) > 0 then
134825: LD_VAR 0 4
134829: PPUSH
134830: CALL_OW 110
134834: PUSH
134835: LD_INT 0
134837: GREATER
134838: IFFALSE 134856
// mechs := mechs diff i ;
134840: LD_ADDR_VAR 0 12
134844: PUSH
134845: LD_VAR 0 12
134849: PUSH
134850: LD_VAR 0 4
134854: DIFF
134855: ST_TO_ADDR
134856: GO 134822
134858: POP
134859: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
134860: LD_ADDR_VAR 0 8
134864: PUSH
134865: LD_EXP 100
134869: PUSH
134870: LD_VAR 0 1
134874: ARRAY
134875: PPUSH
134876: LD_INT 2
134878: PUSH
134879: LD_INT 25
134881: PUSH
134882: LD_INT 1
134884: PUSH
134885: EMPTY
134886: LIST
134887: LIST
134888: PUSH
134889: LD_INT 25
134891: PUSH
134892: LD_INT 5
134894: PUSH
134895: EMPTY
134896: LIST
134897: LIST
134898: PUSH
134899: LD_INT 25
134901: PUSH
134902: LD_INT 8
134904: PUSH
134905: EMPTY
134906: LIST
134907: LIST
134908: PUSH
134909: LD_INT 25
134911: PUSH
134912: LD_INT 9
134914: PUSH
134915: EMPTY
134916: LIST
134917: LIST
134918: PUSH
134919: EMPTY
134920: LIST
134921: LIST
134922: LIST
134923: LIST
134924: LIST
134925: PPUSH
134926: CALL_OW 72
134930: ST_TO_ADDR
// if not defenders and not solds then
134931: LD_VAR 0 2
134935: NOT
134936: PUSH
134937: LD_VAR 0 8
134941: NOT
134942: AND
134943: IFFALSE 134947
// exit ;
134945: GO 136717
// depot_under_attack := false ;
134947: LD_ADDR_VAR 0 16
134951: PUSH
134952: LD_INT 0
134954: ST_TO_ADDR
// sold_defenders := [ ] ;
134955: LD_ADDR_VAR 0 17
134959: PUSH
134960: EMPTY
134961: ST_TO_ADDR
// if mechs then
134962: LD_VAR 0 12
134966: IFFALSE 135119
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
134968: LD_ADDR_VAR 0 4
134972: PUSH
134973: LD_VAR 0 2
134977: PPUSH
134978: LD_INT 21
134980: PUSH
134981: LD_INT 2
134983: PUSH
134984: EMPTY
134985: LIST
134986: LIST
134987: PPUSH
134988: CALL_OW 72
134992: PUSH
134993: FOR_IN
134994: IFFALSE 135117
// begin if GetTag ( i ) <> 20 then
134996: LD_VAR 0 4
135000: PPUSH
135001: CALL_OW 110
135005: PUSH
135006: LD_INT 20
135008: NONEQUAL
135009: IFFALSE 135023
// SetTag ( i , 20 ) ;
135011: LD_VAR 0 4
135015: PPUSH
135016: LD_INT 20
135018: PPUSH
135019: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
135023: LD_VAR 0 4
135027: PPUSH
135028: CALL_OW 263
135032: PUSH
135033: LD_INT 1
135035: EQUAL
135036: PUSH
135037: LD_VAR 0 4
135041: PPUSH
135042: CALL_OW 311
135046: NOT
135047: AND
135048: IFFALSE 135115
// begin un := mechs [ 1 ] ;
135050: LD_ADDR_VAR 0 10
135054: PUSH
135055: LD_VAR 0 12
135059: PUSH
135060: LD_INT 1
135062: ARRAY
135063: ST_TO_ADDR
// ComExit ( un ) ;
135064: LD_VAR 0 10
135068: PPUSH
135069: CALL 105664 0 1
// AddComEnterUnit ( un , i ) ;
135073: LD_VAR 0 10
135077: PPUSH
135078: LD_VAR 0 4
135082: PPUSH
135083: CALL_OW 180
// SetTag ( un , 19 ) ;
135087: LD_VAR 0 10
135091: PPUSH
135092: LD_INT 19
135094: PPUSH
135095: CALL_OW 109
// mechs := mechs diff un ;
135099: LD_ADDR_VAR 0 12
135103: PUSH
135104: LD_VAR 0 12
135108: PUSH
135109: LD_VAR 0 10
135113: DIFF
135114: ST_TO_ADDR
// end ; end ;
135115: GO 134993
135117: POP
135118: POP
// if solds then
135119: LD_VAR 0 8
135123: IFFALSE 135182
// for i in solds do
135125: LD_ADDR_VAR 0 4
135129: PUSH
135130: LD_VAR 0 8
135134: PUSH
135135: FOR_IN
135136: IFFALSE 135180
// if not GetTag ( i ) then
135138: LD_VAR 0 4
135142: PPUSH
135143: CALL_OW 110
135147: NOT
135148: IFFALSE 135178
// begin defenders := defenders union i ;
135150: LD_ADDR_VAR 0 2
135154: PUSH
135155: LD_VAR 0 2
135159: PUSH
135160: LD_VAR 0 4
135164: UNION
135165: ST_TO_ADDR
// SetTag ( i , 18 ) ;
135166: LD_VAR 0 4
135170: PPUSH
135171: LD_INT 18
135173: PPUSH
135174: CALL_OW 109
// end ;
135178: GO 135135
135180: POP
135181: POP
// repeat wait ( 0 0$2 ) ;
135182: LD_INT 70
135184: PPUSH
135185: CALL_OW 67
// enemy := mc_scan [ base ] ;
135189: LD_ADDR_VAR 0 21
135193: PUSH
135194: LD_EXP 123
135198: PUSH
135199: LD_VAR 0 1
135203: ARRAY
135204: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
135205: LD_EXP 100
135209: PUSH
135210: LD_VAR 0 1
135214: ARRAY
135215: NOT
135216: PUSH
135217: LD_EXP 100
135221: PUSH
135222: LD_VAR 0 1
135226: ARRAY
135227: PUSH
135228: EMPTY
135229: EQUAL
135230: OR
135231: IFFALSE 135268
// begin for i in defenders do
135233: LD_ADDR_VAR 0 4
135237: PUSH
135238: LD_VAR 0 2
135242: PUSH
135243: FOR_IN
135244: IFFALSE 135257
// ComStop ( i ) ;
135246: LD_VAR 0 4
135250: PPUSH
135251: CALL_OW 141
135255: GO 135243
135257: POP
135258: POP
// defenders := [ ] ;
135259: LD_ADDR_VAR 0 2
135263: PUSH
135264: EMPTY
135265: ST_TO_ADDR
// exit ;
135266: GO 136717
// end ; for i in defenders do
135268: LD_ADDR_VAR 0 4
135272: PUSH
135273: LD_VAR 0 2
135277: PUSH
135278: FOR_IN
135279: IFFALSE 136177
// begin e := NearestUnitToUnit ( enemy , i ) ;
135281: LD_ADDR_VAR 0 13
135285: PUSH
135286: LD_VAR 0 21
135290: PPUSH
135291: LD_VAR 0 4
135295: PPUSH
135296: CALL_OW 74
135300: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
135301: LD_ADDR_VAR 0 7
135305: PUSH
135306: LD_EXP 100
135310: PUSH
135311: LD_VAR 0 1
135315: ARRAY
135316: PPUSH
135317: LD_INT 2
135319: PUSH
135320: LD_INT 30
135322: PUSH
135323: LD_INT 0
135325: PUSH
135326: EMPTY
135327: LIST
135328: LIST
135329: PUSH
135330: LD_INT 30
135332: PUSH
135333: LD_INT 1
135335: PUSH
135336: EMPTY
135337: LIST
135338: LIST
135339: PUSH
135340: EMPTY
135341: LIST
135342: LIST
135343: LIST
135344: PPUSH
135345: CALL_OW 72
135349: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
135350: LD_ADDR_VAR 0 16
135354: PUSH
135355: LD_VAR 0 7
135359: NOT
135360: PUSH
135361: LD_VAR 0 7
135365: PPUSH
135366: LD_INT 3
135368: PUSH
135369: LD_INT 24
135371: PUSH
135372: LD_INT 600
135374: PUSH
135375: EMPTY
135376: LIST
135377: LIST
135378: PUSH
135379: EMPTY
135380: LIST
135381: LIST
135382: PPUSH
135383: CALL_OW 72
135387: OR
135388: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
135389: LD_VAR 0 4
135393: PPUSH
135394: CALL_OW 247
135398: PUSH
135399: LD_INT 2
135401: DOUBLE
135402: EQUAL
135403: IFTRUE 135407
135405: GO 135803
135407: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
135408: LD_VAR 0 4
135412: PPUSH
135413: CALL_OW 256
135417: PUSH
135418: LD_INT 1000
135420: EQUAL
135421: PUSH
135422: LD_VAR 0 4
135426: PPUSH
135427: LD_VAR 0 13
135431: PPUSH
135432: CALL_OW 296
135436: PUSH
135437: LD_INT 40
135439: LESS
135440: PUSH
135441: LD_VAR 0 13
135445: PPUSH
135446: LD_EXP 125
135450: PUSH
135451: LD_VAR 0 1
135455: ARRAY
135456: PPUSH
135457: CALL_OW 308
135461: OR
135462: AND
135463: IFFALSE 135585
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
135465: LD_VAR 0 4
135469: PPUSH
135470: CALL_OW 262
135474: PUSH
135475: LD_INT 1
135477: EQUAL
135478: PUSH
135479: LD_VAR 0 4
135483: PPUSH
135484: CALL_OW 261
135488: PUSH
135489: LD_INT 30
135491: LESS
135492: AND
135493: PUSH
135494: LD_VAR 0 7
135498: AND
135499: IFFALSE 135569
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
135501: LD_VAR 0 4
135505: PPUSH
135506: LD_VAR 0 7
135510: PPUSH
135511: LD_VAR 0 4
135515: PPUSH
135516: CALL_OW 74
135520: PPUSH
135521: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
135525: LD_VAR 0 4
135529: PPUSH
135530: LD_VAR 0 7
135534: PPUSH
135535: LD_VAR 0 4
135539: PPUSH
135540: CALL_OW 74
135544: PPUSH
135545: CALL_OW 296
135549: PUSH
135550: LD_INT 6
135552: LESS
135553: IFFALSE 135567
// SetFuel ( i , 100 ) ;
135555: LD_VAR 0 4
135559: PPUSH
135560: LD_INT 100
135562: PPUSH
135563: CALL_OW 240
// end else
135567: GO 135583
// ComAttackUnit ( i , e ) ;
135569: LD_VAR 0 4
135573: PPUSH
135574: LD_VAR 0 13
135578: PPUSH
135579: CALL_OW 115
// end else
135583: GO 135686
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
135585: LD_VAR 0 13
135589: PPUSH
135590: LD_EXP 125
135594: PUSH
135595: LD_VAR 0 1
135599: ARRAY
135600: PPUSH
135601: CALL_OW 308
135605: NOT
135606: PUSH
135607: LD_VAR 0 4
135611: PPUSH
135612: LD_VAR 0 13
135616: PPUSH
135617: CALL_OW 296
135621: PUSH
135622: LD_INT 40
135624: GREATEREQUAL
135625: AND
135626: PUSH
135627: LD_VAR 0 4
135631: PPUSH
135632: CALL_OW 256
135636: PUSH
135637: LD_INT 650
135639: LESSEQUAL
135640: OR
135641: PUSH
135642: LD_VAR 0 4
135646: PPUSH
135647: LD_EXP 124
135651: PUSH
135652: LD_VAR 0 1
135656: ARRAY
135657: PPUSH
135658: CALL_OW 308
135662: NOT
135663: AND
135664: IFFALSE 135686
// ComMoveToArea ( i , mc_parking [ base ] ) ;
135666: LD_VAR 0 4
135670: PPUSH
135671: LD_EXP 124
135675: PUSH
135676: LD_VAR 0 1
135680: ARRAY
135681: PPUSH
135682: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
135686: LD_VAR 0 4
135690: PPUSH
135691: CALL_OW 256
135695: PUSH
135696: LD_INT 1000
135698: LESS
135699: PUSH
135700: LD_VAR 0 4
135704: PPUSH
135705: CALL_OW 263
135709: PUSH
135710: LD_INT 1
135712: EQUAL
135713: AND
135714: PUSH
135715: LD_VAR 0 4
135719: PPUSH
135720: CALL_OW 311
135724: AND
135725: PUSH
135726: LD_VAR 0 4
135730: PPUSH
135731: LD_EXP 124
135735: PUSH
135736: LD_VAR 0 1
135740: ARRAY
135741: PPUSH
135742: CALL_OW 308
135746: AND
135747: IFFALSE 135801
// begin mech := IsDrivenBy ( i ) ;
135749: LD_ADDR_VAR 0 9
135753: PUSH
135754: LD_VAR 0 4
135758: PPUSH
135759: CALL_OW 311
135763: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
135764: LD_VAR 0 9
135768: PPUSH
135769: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
135773: LD_VAR 0 9
135777: PPUSH
135778: LD_VAR 0 4
135782: PPUSH
135783: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
135787: LD_VAR 0 9
135791: PPUSH
135792: LD_VAR 0 4
135796: PPUSH
135797: CALL_OW 180
// end ; end ; unit_human :
135801: GO 136148
135803: LD_INT 1
135805: DOUBLE
135806: EQUAL
135807: IFTRUE 135811
135809: GO 136147
135811: POP
// begin b := IsInUnit ( i ) ;
135812: LD_ADDR_VAR 0 18
135816: PUSH
135817: LD_VAR 0 4
135821: PPUSH
135822: CALL_OW 310
135826: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
135827: LD_ADDR_VAR 0 19
135831: PUSH
135832: LD_VAR 0 18
135836: NOT
135837: PUSH
135838: LD_VAR 0 18
135842: PPUSH
135843: CALL_OW 266
135847: PUSH
135848: LD_INT 32
135850: PUSH
135851: LD_INT 31
135853: PUSH
135854: EMPTY
135855: LIST
135856: LIST
135857: IN
135858: OR
135859: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
135860: LD_VAR 0 18
135864: PPUSH
135865: CALL_OW 266
135869: PUSH
135870: LD_INT 5
135872: EQUAL
135873: PUSH
135874: LD_VAR 0 4
135878: PPUSH
135879: CALL_OW 257
135883: PUSH
135884: LD_INT 1
135886: PUSH
135887: LD_INT 2
135889: PUSH
135890: LD_INT 3
135892: PUSH
135893: LD_INT 4
135895: PUSH
135896: EMPTY
135897: LIST
135898: LIST
135899: LIST
135900: LIST
135901: IN
135902: AND
135903: IFFALSE 135940
// begin class := AllowSpecClass ( i ) ;
135905: LD_ADDR_VAR 0 20
135909: PUSH
135910: LD_VAR 0 4
135914: PPUSH
135915: CALL 69760 0 1
135919: ST_TO_ADDR
// if class then
135920: LD_VAR 0 20
135924: IFFALSE 135940
// ComChangeProfession ( i , class ) ;
135926: LD_VAR 0 4
135930: PPUSH
135931: LD_VAR 0 20
135935: PPUSH
135936: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
135940: LD_VAR 0 16
135944: PUSH
135945: LD_VAR 0 2
135949: PPUSH
135950: LD_INT 21
135952: PUSH
135953: LD_INT 2
135955: PUSH
135956: EMPTY
135957: LIST
135958: LIST
135959: PPUSH
135960: CALL_OW 72
135964: PUSH
135965: LD_INT 1
135967: LESSEQUAL
135968: OR
135969: PUSH
135970: LD_VAR 0 19
135974: AND
135975: PUSH
135976: LD_VAR 0 4
135980: PUSH
135981: LD_VAR 0 17
135985: IN
135986: NOT
135987: AND
135988: IFFALSE 136081
// begin if b then
135990: LD_VAR 0 18
135994: IFFALSE 136043
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
135996: LD_VAR 0 18
136000: PPUSH
136001: LD_VAR 0 21
136005: PPUSH
136006: LD_VAR 0 18
136010: PPUSH
136011: CALL_OW 74
136015: PPUSH
136016: CALL_OW 296
136020: PUSH
136021: LD_INT 10
136023: LESS
136024: PUSH
136025: LD_VAR 0 18
136029: PPUSH
136030: CALL_OW 461
136034: PUSH
136035: LD_INT 7
136037: NONEQUAL
136038: AND
136039: IFFALSE 136043
// continue ;
136041: GO 135278
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
136043: LD_ADDR_VAR 0 17
136047: PUSH
136048: LD_VAR 0 17
136052: PPUSH
136053: LD_VAR 0 17
136057: PUSH
136058: LD_INT 1
136060: PLUS
136061: PPUSH
136062: LD_VAR 0 4
136066: PPUSH
136067: CALL_OW 1
136071: ST_TO_ADDR
// ComExitBuilding ( i ) ;
136072: LD_VAR 0 4
136076: PPUSH
136077: CALL_OW 122
// end ; if sold_defenders then
136081: LD_VAR 0 17
136085: IFFALSE 136145
// if i in sold_defenders then
136087: LD_VAR 0 4
136091: PUSH
136092: LD_VAR 0 17
136096: IN
136097: IFFALSE 136145
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
136099: LD_VAR 0 4
136103: PPUSH
136104: CALL_OW 314
136108: NOT
136109: PUSH
136110: LD_VAR 0 4
136114: PPUSH
136115: LD_VAR 0 13
136119: PPUSH
136120: CALL_OW 296
136124: PUSH
136125: LD_INT 30
136127: LESS
136128: AND
136129: IFFALSE 136145
// ComAttackUnit ( i , e ) ;
136131: LD_VAR 0 4
136135: PPUSH
136136: LD_VAR 0 13
136140: PPUSH
136141: CALL_OW 115
// end ; end ; end ;
136145: GO 136148
136147: POP
// if IsDead ( i ) then
136148: LD_VAR 0 4
136152: PPUSH
136153: CALL_OW 301
136157: IFFALSE 136175
// defenders := defenders diff i ;
136159: LD_ADDR_VAR 0 2
136163: PUSH
136164: LD_VAR 0 2
136168: PUSH
136169: LD_VAR 0 4
136173: DIFF
136174: ST_TO_ADDR
// end ;
136175: GO 135278
136177: POP
136178: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
136179: LD_VAR 0 21
136183: NOT
136184: PUSH
136185: LD_VAR 0 2
136189: NOT
136190: OR
136191: PUSH
136192: LD_EXP 100
136196: PUSH
136197: LD_VAR 0 1
136201: ARRAY
136202: NOT
136203: OR
136204: IFFALSE 135182
// MC_Reset ( base , 18 ) ;
136206: LD_VAR 0 1
136210: PPUSH
136211: LD_INT 18
136213: PPUSH
136214: CALL 41449 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
136218: LD_ADDR_VAR 0 2
136222: PUSH
136223: LD_VAR 0 2
136227: PUSH
136228: LD_VAR 0 2
136232: PPUSH
136233: LD_INT 2
136235: PUSH
136236: LD_INT 25
136238: PUSH
136239: LD_INT 1
136241: PUSH
136242: EMPTY
136243: LIST
136244: LIST
136245: PUSH
136246: LD_INT 25
136248: PUSH
136249: LD_INT 5
136251: PUSH
136252: EMPTY
136253: LIST
136254: LIST
136255: PUSH
136256: LD_INT 25
136258: PUSH
136259: LD_INT 8
136261: PUSH
136262: EMPTY
136263: LIST
136264: LIST
136265: PUSH
136266: LD_INT 25
136268: PUSH
136269: LD_INT 9
136271: PUSH
136272: EMPTY
136273: LIST
136274: LIST
136275: PUSH
136276: EMPTY
136277: LIST
136278: LIST
136279: LIST
136280: LIST
136281: LIST
136282: PPUSH
136283: CALL_OW 72
136287: DIFF
136288: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
136289: LD_VAR 0 21
136293: NOT
136294: PUSH
136295: LD_VAR 0 2
136299: PPUSH
136300: LD_INT 21
136302: PUSH
136303: LD_INT 2
136305: PUSH
136306: EMPTY
136307: LIST
136308: LIST
136309: PPUSH
136310: CALL_OW 72
136314: AND
136315: IFFALSE 136653
// begin tmp := FilterByTag ( defenders , 19 ) ;
136317: LD_ADDR_VAR 0 11
136321: PUSH
136322: LD_VAR 0 2
136326: PPUSH
136327: LD_INT 19
136329: PPUSH
136330: CALL 102848 0 2
136334: ST_TO_ADDR
// if tmp then
136335: LD_VAR 0 11
136339: IFFALSE 136409
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
136341: LD_ADDR_VAR 0 11
136345: PUSH
136346: LD_VAR 0 11
136350: PPUSH
136351: LD_INT 25
136353: PUSH
136354: LD_INT 3
136356: PUSH
136357: EMPTY
136358: LIST
136359: LIST
136360: PPUSH
136361: CALL_OW 72
136365: ST_TO_ADDR
// if tmp then
136366: LD_VAR 0 11
136370: IFFALSE 136409
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
136372: LD_ADDR_EXP 112
136376: PUSH
136377: LD_EXP 112
136381: PPUSH
136382: LD_VAR 0 1
136386: PPUSH
136387: LD_EXP 112
136391: PUSH
136392: LD_VAR 0 1
136396: ARRAY
136397: PUSH
136398: LD_VAR 0 11
136402: UNION
136403: PPUSH
136404: CALL_OW 1
136408: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
136409: LD_VAR 0 1
136413: PPUSH
136414: LD_INT 19
136416: PPUSH
136417: CALL 41449 0 2
// repeat wait ( 0 0$1 ) ;
136421: LD_INT 35
136423: PPUSH
136424: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
136428: LD_EXP 100
136432: PUSH
136433: LD_VAR 0 1
136437: ARRAY
136438: NOT
136439: PUSH
136440: LD_EXP 100
136444: PUSH
136445: LD_VAR 0 1
136449: ARRAY
136450: PUSH
136451: EMPTY
136452: EQUAL
136453: OR
136454: IFFALSE 136491
// begin for i in defenders do
136456: LD_ADDR_VAR 0 4
136460: PUSH
136461: LD_VAR 0 2
136465: PUSH
136466: FOR_IN
136467: IFFALSE 136480
// ComStop ( i ) ;
136469: LD_VAR 0 4
136473: PPUSH
136474: CALL_OW 141
136478: GO 136466
136480: POP
136481: POP
// defenders := [ ] ;
136482: LD_ADDR_VAR 0 2
136486: PUSH
136487: EMPTY
136488: ST_TO_ADDR
// exit ;
136489: GO 136717
// end ; for i in defenders do
136491: LD_ADDR_VAR 0 4
136495: PUSH
136496: LD_VAR 0 2
136500: PUSH
136501: FOR_IN
136502: IFFALSE 136591
// begin if not IsInArea ( i , mc_parking [ base ] ) then
136504: LD_VAR 0 4
136508: PPUSH
136509: LD_EXP 124
136513: PUSH
136514: LD_VAR 0 1
136518: ARRAY
136519: PPUSH
136520: CALL_OW 308
136524: NOT
136525: IFFALSE 136549
// ComMoveToArea ( i , mc_parking [ base ] ) else
136527: LD_VAR 0 4
136531: PPUSH
136532: LD_EXP 124
136536: PUSH
136537: LD_VAR 0 1
136541: ARRAY
136542: PPUSH
136543: CALL_OW 113
136547: GO 136589
// if GetControl ( i ) = control_manual then
136549: LD_VAR 0 4
136553: PPUSH
136554: CALL_OW 263
136558: PUSH
136559: LD_INT 1
136561: EQUAL
136562: IFFALSE 136589
// if IsDrivenBy ( i ) then
136564: LD_VAR 0 4
136568: PPUSH
136569: CALL_OW 311
136573: IFFALSE 136589
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
136575: LD_VAR 0 4
136579: PPUSH
136580: CALL_OW 311
136584: PPUSH
136585: CALL_OW 121
// end ;
136589: GO 136501
136591: POP
136592: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
136593: LD_VAR 0 2
136597: PPUSH
136598: LD_INT 95
136600: PUSH
136601: LD_EXP 124
136605: PUSH
136606: LD_VAR 0 1
136610: ARRAY
136611: PUSH
136612: EMPTY
136613: LIST
136614: LIST
136615: PPUSH
136616: CALL_OW 72
136620: PUSH
136621: LD_VAR 0 2
136625: EQUAL
136626: PUSH
136627: LD_EXP 123
136631: PUSH
136632: LD_VAR 0 1
136636: ARRAY
136637: OR
136638: PUSH
136639: LD_EXP 100
136643: PUSH
136644: LD_VAR 0 1
136648: ARRAY
136649: NOT
136650: OR
136651: IFFALSE 136421
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
136653: LD_ADDR_EXP 122
136657: PUSH
136658: LD_EXP 122
136662: PPUSH
136663: LD_VAR 0 1
136667: PPUSH
136668: LD_VAR 0 2
136672: PPUSH
136673: LD_INT 21
136675: PUSH
136676: LD_INT 2
136678: PUSH
136679: EMPTY
136680: LIST
136681: LIST
136682: PPUSH
136683: CALL_OW 72
136687: PPUSH
136688: CALL_OW 1
136692: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
136693: LD_VAR 0 1
136697: PPUSH
136698: LD_INT 19
136700: PPUSH
136701: CALL 41449 0 2
// MC_Reset ( base , 20 ) ;
136705: LD_VAR 0 1
136709: PPUSH
136710: LD_INT 20
136712: PPUSH
136713: CALL 41449 0 2
// end ; end_of_file
136717: LD_VAR 0 3
136721: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
136722: LD_VAR 0 1
136726: PUSH
136727: LD_INT 200
136729: DOUBLE
136730: GREATEREQUAL
136731: IFFALSE 136739
136733: LD_INT 299
136735: DOUBLE
136736: LESSEQUAL
136737: IFTRUE 136741
136739: GO 136773
136741: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
136742: LD_VAR 0 1
136746: PPUSH
136747: LD_VAR 0 2
136751: PPUSH
136752: LD_VAR 0 3
136756: PPUSH
136757: LD_VAR 0 4
136761: PPUSH
136762: LD_VAR 0 5
136766: PPUSH
136767: CALL 125508 0 5
136771: GO 136850
136773: LD_INT 300
136775: DOUBLE
136776: GREATEREQUAL
136777: IFFALSE 136785
136779: LD_INT 399
136781: DOUBLE
136782: LESSEQUAL
136783: IFTRUE 136787
136785: GO 136849
136787: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
136788: LD_VAR 0 1
136792: PPUSH
136793: LD_VAR 0 2
136797: PPUSH
136798: LD_VAR 0 3
136802: PPUSH
136803: LD_VAR 0 4
136807: PPUSH
136808: LD_VAR 0 5
136812: PPUSH
136813: LD_VAR 0 6
136817: PPUSH
136818: LD_VAR 0 7
136822: PPUSH
136823: LD_VAR 0 8
136827: PPUSH
136828: LD_VAR 0 9
136832: PPUSH
136833: LD_VAR 0 10
136837: PPUSH
136838: LD_VAR 0 11
136842: PPUSH
136843: CALL 121841 0 11
136847: GO 136850
136849: POP
// end ;
136850: PPOPN 11
136852: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
136853: LD_VAR 0 1
136857: PPUSH
136858: LD_VAR 0 2
136862: PPUSH
136863: LD_VAR 0 3
136867: PPUSH
136868: LD_VAR 0 4
136872: PPUSH
136873: LD_VAR 0 5
136877: PPUSH
136878: CALL 125244 0 5
// end ; end_of_file
136882: PPOPN 5
136884: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
136885: LD_VAR 0 1
136889: PPUSH
136890: LD_VAR 0 2
136894: PPUSH
136895: LD_VAR 0 3
136899: PPUSH
136900: LD_VAR 0 4
136904: PPUSH
136905: LD_VAR 0 5
136909: PPUSH
136910: LD_VAR 0 6
136914: PPUSH
136915: CALL 109493 0 6
// end ;
136919: PPOPN 6
136921: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
136922: LD_INT 0
136924: PPUSH
// begin if not units then
136925: LD_VAR 0 1
136929: NOT
136930: IFFALSE 136934
// exit ;
136932: GO 136934
// end ;
136934: PPOPN 7
136936: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
136937: CALL 109397 0 0
// end ;
136941: PPOPN 1
136943: END
